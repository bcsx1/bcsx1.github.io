<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24cc5859304bfe3973e314edd065718/" rel="bookmark">
			安装Anaconda/Python3.9/Tensorflow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装Anaconda/Python3.9/Tensorflow · 安装Anaconda 官网安装，开梯子
Download即可。打开下载好的安装包，按照提示，一路【Next】
选择安装路径
这里官方并没有推荐自动配置环境变量，自动或手动配置均可。一般是默认勾选下边的选项（我这里刚刚已经装好一次，因此勾选不上。）
点击【Install】，等待安装完成。继续按提示操作至安装界面结束。
· 配置Anaconda环境变量 添加如下Path环境变量
cmd查看Anaconda版本
证明Anaconda已经装好。
· 安装Tensorflow 开始菜单打开Anaconda Prompt
配置清华镜像源，从这里开始要关掉代理了。
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes Anaconda创建Python环境，可在官网查看Tensorflow支持的Python版本：
我的Anaconda给我装了Python3.9，于是
conda create -n tensorflow python=3.9 询问[Y/N]时选择Y。完成时给出如下提示
查看目前有哪些环境，通过
conda env list 或
conda info --env 可以看到tensorflow环境已经创建。星号为当前所在环境（基础环境base）。通过activate tensorflow进入tensorflow环境：
开始实际安装Tensorflow。查看当前可使用的Tensorflow版本，通过
conda search --full --name tensorflow 从1.1.0到2.6.0都有。可指定版本安装，这里安装默认版本
pip install --upgrade --ignore-installed tensorflow 无报错结束应该是装好了。打开Python环境，导入tensorflow包进行测试
确定tensorflow已经装好（这里应该是Cuda版本低了，以后再调）。tf.__version__查看版本为2.7。
最后如果想退出tensorflow环境
conda deactivate 同时，conda控制台是默认打开base环境的，如果想管理这一设置
conda config --set auto_activate_base false / true 参考博客如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a24cc5859304bfe3973e314edd065718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77afc26dac53c3566b5b0c8468d964a4/" rel="bookmark">
			jiangly的并查集模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 并查集模板 jls的并查集模板 orz orz orz orz
struct DSU { std::vector&lt;int&gt; p, siz; DSU(int n) : p(n+1), siz(n+1, 1) { std::iota(p.begin(), p.end(), 0); } int find(int x) { return p[x] == x ? x : p[x] = find(p[x]); } bool same(int x, int y) { return find(x) == find(y); } bool merge(int x, int y) { x = find(x); y = find(y); if (x == y) return false; siz[x] += siz[y]; p[y] = x; return true; } int size(int x) { return siz[find(x)]; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d12a5d3209e51c8286521964227b5a/" rel="bookmark">
			hive日期函数，求日期差等,datediff,date_add,date_sub,add_months
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 datediff(end,start) 求日期差值
date_add(date_time,10) 日期增加10天
date_sub(date_time,10) 日期减少10天
add_months（date_time， 2）日期增加两个月
add_months（date_time，-2）日期减少两个月
select datediff(date_time_end,date_time_start); select date_add(date_time,10); select date_sub(date_time,10); select add_months(date_time, 2); select add_months(date_time,-2); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e31aa4be861654485cdde96e35c598c/" rel="bookmark">
			全景图拼接【计算机视觉第三章】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
全景图像拼接基本介绍
全景图拼接步骤
全景图拼接原理
RANSAC算法
图像配准
图割方法
图像融合
APAP算法
multi-band bleing算法​​​​​​​
全景图拼接代码实现 代码调试
报错1
解决方法
报错2
解决方法
运行代码拼接结果 数据集1（定点多角度拍摄的室外场景）
​特征匹配结果： 拼接结果图 数据集2（水平平移拍摄的室外场景） ​
特征匹配结果： 拼接结果图 数据集3（水平平移拍摄的室内场景） 特征匹配结果： 拼接结果图 总结
全景图像拼接基本介绍 图像拼接技术就是将数张有重叠部分的图像（可能是不同时间、不同视角或者不同传感器获得的）拼成一幅无缝的全景图或高分辨率图像的技术。图像拼接在医学成像、计算机视觉、卫星数据、军事目标自动识别等领域具有重要意义。图像拼接的输出是两个输入图像的并集。
图像配准（image alignment）和图像融合是图像拼接的两个关键技术。图像配准是图像融合的基础,而且图像配准算法的计算量一般非常大,因此图像拼接技术的发展很大程度上取决于图像配准技术的创新。早期的图像配准技术主要采用点匹配法,这类方法速度慢、精度低,而且常常需要人工选取初始匹配点,无法适应大数据量图像的融合。图像拼接的方法很多,不同的算法步骤会有一定差异,但大致的过程是相同的。
全景图拼接步骤 将SIFT应用到图像拼接上，根据特征点匹配的方式，则利用这些匹配的点来估算单应矩阵使用RANSAC算法，也就是把其中一张通过个关联性和另一张匹配的方法。通过单应矩阵H，可以将原图像中任意像素点坐标转换为新坐标点，转换后的图像即为适合拼接的结果图像。
可以简单分为以下几步:
1.根据给定图像/集，实现特征匹配。
2.通过匹配特征计算图像之间的变换结构。
3.利用图像变换结构，实现图像映射。
4.针对叠加后的图像，采用APAP之类的算法，对齐特征点。(图像配准)
5.通过图割方法，自动选取拼接缝。
6.根据multi-band blending策略实现融合。
全景图拼接原理 RANSAC算法 RANSAC[1] (随机抽样一致)是一种迭代算法，该算法从一组包含“外点(outlier)”的观测数据中估计数学模型的参数。“外点”指观测数据中的无效数据，通常为噪声或错误数据，比如图像匹配中的误匹配点和曲线拟合中的离群点。与“外点”相对应的是“内点(inlier)”，即用来估计模型参数的有效数据。因此，RANSAC也是一种“外点”检测算法。此外，RANSAC算法是一种非确定算法，它只能在一定概率下产生可信的结果，当迭代次数增加时，准确的概率也会增加。
RANSAC算法是用来找到正确模型来拟合带有噪声数据的迭代方法。
基本思想：数据中包含正确的点和噪声点，合理的模型应该能够在描述正确数据点的同时摈弃噪声点。
RANSAC的基本思想和算法流程如下：
随机采样K个点，K是求解模型参数的最少点个数使用K个点估计模型参数计算剩余点到估计模型的距离，距离小于阈值则为内点，统计内点的数目重复步骤1~3，重复次数M且保留数目最多的内点使用所有的内点重新估计模型
图像配准 图像配准是对图像进行变换，使变换后的图像能够在常见的坐标系中对齐。为了能够进行图像对比和更精细的图像分析，图像配准是一步非常重要的操作。图像配准的方法有很多，这里以APAP算法为例：
提取两张图片的sift特征点对两张图片的特征点进行匹配匹配后，仍有很多错误点，此时用RANSAC进行特征点对的筛选。筛选后的特征点基本能够一一对应。使用DLT算法，将剩下的特征点对进行透视变换矩阵的估计。因为得到的透视变换矩阵是基于全局特征点对进行的，即一个刚性的单应性矩阵完成配准。为提高配准的精度，Apap将图像切割成无数多个小方块，对每个小方块的变换矩阵逐一估计。
图割方法 最大流最小割算法原理，
1.最小割问题
一个有向图，并有一个源顶点（source vertex）和目标顶点（target vertex）.边的权值为正,又称之为容量（capacity）。如下图
一个st-cut(简称割cut)会把有向图的顶点分成两个不相交的集合，其中s在一个集合中，t在另外一个集合中。
这个割的容量（capacity of the cut）就是A到B所有边的容量和。注意这里不包含B到A的。最小割问题就是要找到割容量最小的情况。
2.最大流问题
跟mincut问题类似，maxflow要处理的情况也是一个有向图，并有一个原顶点（source vertex）和目标（target vertex），边的权值为正,又称之为容量（capacity）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e31aa4be861654485cdde96e35c598c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11936a76b2268d61b79d871558f80d9/" rel="bookmark">
			《勘测定界界址点坐标交换格式》解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本格式 [属性描述]
格式版本号=2.01版本
数据生产单位=勘测院
数据生产日期=2021-11-12
坐标系=2000国家大地坐标系
几度分带=3
投影类型=高斯克吕格
计量单位=米
带号=38
精度=0.001
转换参数=X平移,Y平移,Z平移,X旋转,Y旋转,Z旋转,尺度参数
[地块坐标]
界址点数,地块面积（公顷）,地块编号,地块名称,图形属性（点、线、面）,图幅号,地块用途,地类编码,@
点号（起点）,地块圈号,X坐标,Y坐标
点号（起点）,地块圈号,X坐标,Y坐标
界址点数,地块面积（公顷）,地块编号,地块名称,图形属性（点、线、面）,图幅号,地块用途,地类编码,@
点号（起点）,地块圈号,X坐标,Y坐标
点号（起点）,地块圈号,X坐标,Y坐标
特别注意 1.所有逗号必须是英文输入法下的逗号，各项内容不能含逗号、@
2.地块圈号必须从1开始，面类型的起点和终点是同一坐标
3.日期格式：2021-10-10
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/616e1f4204f9681e2d18976eebdded7f/" rel="bookmark">
			CDH开启sentry后hive on spark报错： Failed to create Spark client for Spark session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cdh开启sentry之后，hive on spark报错，网上的方法试了一遍都没有解决我的问题，经过一番摸索，最终解决。
报错日志： ERROR : FAILED: Execution Error, return code 30041 from org.apache.hadoop.hive.ql.exec.spark.SparkTask. Failed to create Spark client for Spark session 2b98a332-72e0-4917-9357-5c1799e4a3ae_1: java.lang.RuntimeException: spark-submit process failed with exit code 1 and error ? 解决办法： 将hive在hdfs上的数据目录（默认为/user/hive）所属用户和组递归改为为hive:hive，权限为771
网上其他方法： 版本不匹配
一般情况下不会出现，之前在HDP上遇到过，换了版本好了，但这种方法不太好，而且很麻烦。yarn 资源配置问题
保证spark executor的内存和overhead的内存相加小于yarn对容器可分配的内存，一般情况下都是小于的，除非你手动改过配置spark服务没有启动
这个就不说了，面壁反思吧配置有问题
如果你是安装的apache的话，这个配置是比较麻烦的，可以参考hive官网上面的相关配置 如果还未解决，可以重新跑个任务，然后从hiveserver2.log中仔细寻找蛛丝马迹，一定要一行一行的看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c319b427cdc8d63d0798138772af3457/" rel="bookmark">
			ConstraintLayout 用法全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是基于constraint-layout:1.1.2
一、前言 在以前，android是使用布局如LinearLayout 、RelativeLayout等来构建页面，但这些布局使用起来很麻烦，并且经常需要一层一层嵌套，写一个简单的页面就需要费很大的劲。所以在16年I/O大会上，google发布了全新的布局-ConstraintLayout，其他布局和ConstraintLayout比起来，根本就没有存在的必要了...
ConstraintLayout具有以下优势：
较高的性能优势。
布局嵌套层次越高，性能开销越大。而使用ConstraintLayout，经常就一层嵌套就搞定了，所以其性能要好很多。
详细的性能分析可参见：解析ConstraintLayout的性能优势
完美的屏幕适配
ConstraintLayout的大小、距离都可以使用比例来设置，所以其适配性更好。
书写简单
可视化编辑。
ConstraintLayout也有十分方便完善的可视化编辑器，不用写xml也基本上能实现大部分功能。但个人还是比较喜欢写xml，所以本篇文章主要介绍如何使用代码控制。如果想看如何使用可视化编辑器，可以参考郭霖大神的这篇文章
引入:api 'com.android.support.constraint:constraint-layout:1.1.2'
二、ConstraintLayout 1. 定位位置 确定位置的属性提供了下面13个属性，其实本质上都是一样的，看名字应该基本上都知道怎么用了(就是哪一条边和哪一条边对齐)
layout_constraintLeft_toLeftOflayout_constraintLeft_toRightOflayout_constraintRight_toLeftOflayout_constraintRight_toRightOflayout_constraintTop_toTopOflayout_constraintTop_toBottomOflayout_constraintBottom_toTopOflayout_constraintBottom_toBottomOflayout_constraintBaseline_toBaselineOflayout_constraintStart_toEndOflayout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOf 来看个例子：
实现上述UI的相关代码如下：
&lt;android.support.constraint.ConstraintLayout ...&gt; &lt;Button android:id="@+id/a" .... app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintTop_toTopOf="parent" android:text="A" /&gt; &lt;Button android:id="@+id/b" .... app:layout_constraintLeft_toRightOf="@id/a" app:layout_constraintTop_toTopOf="@id/a" android:text="B" /&gt; &lt;Button android:id="@+id/c" .... app:layout_constraintLeft_toLeftOf="@id/a" app:layout_constraintTop_toBottomOf="@id/a" android:text="C" /&gt; &lt;Button android:id="@+id/d" .... app:layout_constraintLeft_toRightOf="@id/a" app:layout_constraintTop_toTopOf="@id/c" android:text="D" /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 从中可以看到，
layout_constraint*属性的值可以是某个id或者parent（父布局）B要位于A的右边，则使用app:layout_constraintLeft_toRightOf="@id/a",C位于A的下边，则使用app:layout_constraintTop_toBottomOf="@id/a" 对于一个View的边界界定，官方给了下面这张图：
2. margin 设置margin还是继续用以前的属性layout_margin* 。
不过需要注意，要使margin生效，必须具有对应方向的layout_constraint*，否则margin不生效.
3. 关于view gone 假如现在有如下布局：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;android.support.constraint.ConstraintLayout .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c319b427cdc8d63d0798138772af3457/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21cccd117f7375fd391635ced5dba7da/" rel="bookmark">
			js 实现算法二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二分算法：概念简单易懂、就是把一组有序数组、每次一分为二的去查找。
举例：超市买了一堆东西、结完账警报器响了。东西太多、一个一个拿出来警报器过一遍、太浪费时间。保安大哥将你买的东西一分为二、哪边响了、说明哪边有东西没结账。重复两三次、基本就定位了你没结账的物品。
在lertCode刷了一道有关的题
使用二分算法实现 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-search 起初没明白题意的我直接一个for循环搞定、后来才知道、数据量太大时、这样太损耗性能了。
直接上代码
var search = function (nums, target) { let low = 0, high = nums.length - 1; // 下标 while (low &lt;= high) { const mid = Math.floor((high - low) / 2) + low; const num = nums[mid]; if (num === target) { return mid; } else if (num &gt; target) { high = mid - 1; } else { low = mid + 1; } } return -1; }; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21cccd117f7375fd391635ced5dba7da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd670b4413265a32a685c3fbb1956354/" rel="bookmark">
			Linux Ubuntu 永久修改分辨率到1920x1080（多次尝试有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加 /etc/X11/xorg.conf 文件，将此模式保存为默认分辨率。
$ sudo vim /etc/X11/xorg.conf
(如果没有安装vim，可以使用“sudo gedit /etc/X11/xorg.conf”)
粘贴以下内容：
Section "Monitor"
Identifier "Configured Monitor"
Modeline "1920x1080_60.00" 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync
Option "PreferredMode" "1920x1080_60.00"
EndSection
Section "Screen"
Identifier "Default Screen"
Monitor "Configured Monitor"
Device "Configured Video Device"
EndSection
Section "Device"
Identifier "Configured Video Device"
EndSection
保存。重启后就变成1920x1080了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd3b89e7b9fb911a1ef24688613fb4a/" rel="bookmark">
			Linux QT GUI 界面程序打包 linuxdeployqt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明:
1.主要依赖linuxdeployqt打包工具
2.打包Linux上的QT界面软件，使其不依赖QT开发环境
linuxdeployqt安装过程:
不能下载官方编译好的.appimage文件,会报告gblic的问题 下载官方源码 修改main.cpp,屏蔽掉版本判断部分,否则还会报gblic的问题 可能会报Git错误,不是GIT仓库,找不到commit ID等,解决办法---屏蔽掉其cmakelist中的GIT相关部分，或直接git https://github.com/probonopd/linuxdeployqt/releases 编译安装过程:
1.根目录下:cmake CmakeList.txt
2.make //此时tool/linuxxxxx下会生成linuxdeployqt可执行的二进制文件,
3.将linuxdeployqt可执行文件复制到/usr/local/bin，之后 sudo chmod 777 linuxdeployqt
参考链接：
（本人实测!）Linux下使用linuxdeployqt打包Qt项目用于移植 - 灰信网（软件开发博客聚合）
Ubuntu下使用linuxdeployqt打包Qt程序 - 星星,风,阳光 - 博客园
其他工具：
1. patchelf
sudo apt install patchelf
2. appimage
https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
下载完成后执行如下命令：
sudo mv appimagetool-x86_64.AppImage appimagetool
chmod 777 appimagetool
sudo./appimagetool /usr/local/bin
以上安装完成后进入usr/local/bin目录执行ls其中包含如下三个则说明打包工具安装成功，之后就可以开心的进行项目移植打包喽！
可能报错：
1.ERROR: "/usr/bin/qmake -query" exited with 1 : "qmake: could not exec '/usr/lib/x86_64-linux-gnu/qt4/bin/qmake': No such file or directory\n 找不到qt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd3b89e7b9fb911a1ef24688613fb4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e218b67710bc24918e956fed38d7397/" rel="bookmark">
			pycharm详细配置pytest运行环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.设置默认的测试运行器2.设置运行/调试的配置3.总结 1.设置默认的测试运行器 打开设置
搜索框输入pytest,进行搜索
查看界面变化
小结 这里只是把测试运行环境设置成了pytest,下面我们还要设置运行/调试的配置
2.设置运行/调试的配置 点击编辑配置 删除当前运行环境
新增pytest配置
运行测试用例
3.总结 为了下次更方便的配置,这里记上一笔,有需要的可以关注收藏,以便下次更快的进行配置.
文章内容如果有错误,大佬们可以在评论区指出,共同进步~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a14aeab7c0c73efde9f20183c8ffc3da/" rel="bookmark">
			【转】软件工程核心知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件工程概述
计算机软件
计算机软件分为十类：系统软件、应用软件、工程/科学软件、嵌入式软件、产品线软件、Web应用、人工智能软件、开放计算、网络资源、开源软件。
软件工程基本原理
7条基本原理：用分阶段的生命周期计划严格管理、坚持进行阶段评审、实现严格的产品控制、采用现代程序设计技术、结果应能清楚地审查、开发小组的人员应少而精、承认不断改进软件工程实践的必要性。
软件生存周期
软件生存周期包括可行性分析与项目开发计划、需求分析、设计（概要设计和详细设计）、编码、测试、维护。
软件过程
能力成熟度模型（CMM）分为5个级别：初始级、可重复级、已定义级、已管理级、优化级。
能力成熟度模型集成（CMMI）分为阶段式模型和连续模式模型。
阶段式模型类似CMM，有5个等级：初始的、已管理的、已定义的、定量管理的、优化的。
连续式模型有6个等级：未完成的、已执行的、已管理的、已定义级的、定量管理的、优化的。
二、软件过程模型
瀑布模型
优点：容易理解、管理成本低；强调开发的阶段性早期计划及需求调查和产品测试。
缺点：客户必须能够完整、正确和清晰地表达他们的需要。需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目的风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算。
增量模型
优点：具有瀑布模型的所有优点。此外，第一个可交付版本所需要的成本和时间很少；开发由增量表示的小系统所承担的风险不大；由于很快发布了第一个版本，因此可以减少用户需求的变更；运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。
缺点：如果没有对用户的变更需求进行规划，那么产生的初始增量可能会造成后来的增量的不稳定；如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力。
演化模型
典型的演化模型有原型模型和螺旋模型。
原型模型
原型可以分为3种：探索型原型、实验型原型、演化型原型。
探索型原型：弄清目标的要求、确实希望的特性、并探讨多种方案的可行性。
实验型原型：验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等。
演化型原型：将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。
螺旋模型
螺旋周期分为4个步骤：制订计划、风险分析、实施工程、用户评估。
喷泉模型
优点：提高软件项目的开发效率，节省开发时间。
缺点：需要大量的开发人员，不利于项目的管理，要求严格管理文档，审核难度加大。
基于构件的开发模型
基于构件的开发模型本质上是演化模型，需要以迭代方式构建软件。不同之处在于，基于构件的开发模型采用预先打包的软件构件开发应用系统。
形式化方法模型
统一过程模型
统一过程模型是一种“用例和风险驱动、以架构为中心、迭代并且增量”的开发过程，由UML方法和工具支持。
统一过程定义了4个技术阶段及其制品：
起始阶段：生命周期目标。
精化阶段：生命周期架构。
构建阶段：初始运作功能。
移交阶段：产品发布。
敏捷方法
敏捷方法有5种：极限编程、水晶法、并列争求法、自适应软件开发、敏捷统一过程。
极限编程由价值观、原则、实践和行为4个部分组成。
敏捷统一过程（AUP）迭代执行以下活动：建模、实现、测试、部署、配置及项目管理、环境管理。
三、需求分析
软件需求
软件需求包括：功能需求、性能需求、用户或人的因素、环境需求、界面需求、文档需求、数据需求、资源使用需求、安全保密需求、可靠性需求、软件成本消耗与开发进度需求、其他非功能性需求。
需求分析原则
必须能够表示和理解问题的信息域。
必须能够定义软件将完成的任务。
必须能够表示软件的行为
必须划分描述数据、功能和行为的模型，从而可以分层次地揭示细节。
分析过程应该从要素信息移向细节信息。
需求工程
需求工程可以分为6个阶段：需求获取、需求分析与协商、系统建模、需求规约、需求验证、需求管理。
四、系统设计
系统设计的基本任务分为概要设计、详细设计两个步骤。
概要设计
设计软件系统总体结构、数据结构及数据库设计、编写概要设计文档、评审。
详细设计
对每个模块进行详细的算法设计、对模块内的数据结构进行设计、对数据库进行物理设计、其他设计、编写详细设计说明书、评审。
五、系统测试
系统测试与调试
系统测试遵循的原则：
应尽早并不断地进行测试。
测试工作应该避免由原开发软件的人员或小组承担。
在设计测试方案时要确定输入数据和预期输出结果。
在测试程序时不仅要检验程序，还要检验程序是否做了不该做的事。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a14aeab7c0c73efde9f20183c8ffc3da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a5beadd66168b8d5c97e2dc3ca9be1/" rel="bookmark">
			为什么C语言中printf函数输出%d格式的指针数据时前面要加*而输出%s的格式却不需要？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题其实问的非常好，我也被困扰了很久很久。但是网上的答案基本都是答非所问。我自己查了很多资料，也写了很多测试语句。我觉得：
1 C语言里面没有string这个类型的数据，就比如说有int char float double之类的数据类型，但是字符串这这数据类型在c语言里面是没有的。这个其实非常的不人性化，因为我们在看很多程序代码的时候会发现经常要使用到字符串，而且有一个很重要的函数库就叫做string.h里面的函数在我们日常编程中，全部是非常基础但同时又是非常重要的。所以我个人觉得c语言没有字符串类型这一点，让字符串指针和别的指针概念相比非常难以理解。
2 稍微说一下指针的基本概念。指针就是一块内存的地址编号。地址编号和地址里面存储的东西这两个概念是指针有关的书籍里面讲了无数遍的。一般理解起来是没有任何难度的。但是当我们创建一个指针变量的时候，一定要注意把申请的这个变量和一块内存的地址绑定起来。int *p = 3;//这就是一个经典的错误例子。 a=3; int *p = &amp;a; //绑定一个内存的地址非常重要，绑定了之后再使用，比如a=3; int*p=&amp;a; *p=100;这都是可以的。但是如果没有p=&amp;a;这一步，那么肯定就会报错。如果以后用结构体指针，同样要先malloc一下，作用还是把一个新申请的指针变量绑定到一个内存地址上面去，至于绑定到哪里，这一块内存地址长度多少，就动态的由malloc（sizeof()）来决定了.当然也需要稍微看一下内存的基本知识，明白堆区，栈区，静态储存区等基本概念，知道变量，常量，全局，局部，函数代码都存在哪些区域里也很重要。这些知识看似对于指针理解没有直接的帮助，其实指针深究到最后，就是这些东西了。
3 现在来说一下char *p 首先它是一个常量，如果是char p[10] = {};那么它就是一个变量。常量的值只可以读取不可以写入，变量的值可读可写。
在用printf语句打印%s的时候,printf语句要求提供字符串首地址。这是printf所规定的，也就是看到%s，printf就要求指针变量，而不是我们逻辑上认为的指针里面所存储的内容。所以用printf("%s",p);而不是printf("%s",*p); 这一点必须记住。如果用%c，想输出里面的内容就可以按照正常的指针概念，用*p了。你可以执行一下这一条语句char * p = "string pointer dam fucking sucks!"; printf("%s\n%p\n%c\n", p, p, *p);你就应该明白了。
作者：Michael
链接：https://www.zhihu.com/question/55668469/answer/309056728
若有侵权，联系我马上删除！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1c3b16fc9cd835e843c848f2e6de55/" rel="bookmark">
			Vector翻倍扩容机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习Vector扩容机制时，学习到Vector不设置容量时，初始容量为10，进行扩容容量翻倍也就是20，但是在调试的时候误以为Vector是一个一个扩容的。
下面将简单介绍Vector翻倍扩容的源代码
原代码： 添加第10个元素时判断为flase不进行扩容
添加第11个元素时，进入grow方法开始扩容
看到这里时非常迷惑，以为容量一个一个增加
绿字解释翻译：设置这个向量的大小。如果新大小大于当前大小，则在vector的末尾添加新的空项。如果新大小小于当前大小，则索引newSize及更大的所有组件将被丢弃。
其实这里只是单纯增加minCapacity,但决定新集合容量的并不是它，而是后面的newCapacity
再追，这里的newcapacity才决定新容量的大小。
然后看到newcapacity由newlength方法(3个参数)决定
参数1：oldcapacity=10
参数2：mincapacity=11， 11-10也就是1
参数3：capacityincrement=0（还不清楚是什么变量），所以取值为oldcapacity = 10
进入newlength方法，代入newlength(10,1,10),也就是oldlength=10，mingrowth=1，preGrowth=10。609行计算newlength是
大家知道minGrowth是参数2，minGrowth = minCapacity - oldCapacity
而mincapacity总是比oldcapacity大1
所以参数2 mingrowth每次扩容时应该都是1。
而prefGrowth是参数3也就是下面这个表达式
capacityincrement=0 则每次取值都为oldcapacity,那么很明显newlength每次取值都是两个oldcapacity相加，newcapacity的取值为return newlength 也是翻倍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7d9beb5b20457a2807549aa74e29e7/" rel="bookmark">
			Flink 从0到1学习—— 分享四本 Flink 国外的书和二十多篇 Paper 论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前也分享了不少自己的文章，但是对于 Flink 来说，还是有不少新入门的朋友，这里给大家分享点 Flink 相关的资料（国外数据 pdf 和流处理相关的 Paper），期望可以帮你更好的理解 Flink。
书籍 1、《Introduction to Apache Flink book》
这本书比较薄，简单介绍了 Flink，也有中文版，读完可以对 Flink 有个大概的了解。
2、《Learning Apache Flink》
这本书还是讲的比较多的 API 使用，不仅有 Java 版本还有 Scala 版本，入门看这本我觉得还是 OK 的。
3、《Stream Processing with Apache Flink》
这本书是 Flink PMC 写的，质量还是很好的，对 Flink 中的概念讲的很清楚，还有不少图片帮忙理解，美中不足的是没有 Table 和 SQL API 相关的介绍。
4、《Streaming System》
这本书是讲流处理引擎的，对流处理引擎的发展带来不少的推动，书本的质量非常高，配了大量的图，目的就是让你很容易的懂流处理引擎中的概念（比如时间、窗口、水印等），我强烈的推荐大家都看一下，这本书的内容被很多博客和书籍都引用了。
Paper 这是一份 streaming systems 领域相关的论文列表 20+ 篇，涉及 streaming systems 的设计，实现，故障恢复，弹性扩展等各方面。也包含自 2014 年以来 streaming system 和 batch system 的统一模型的论文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e7d9beb5b20457a2807549aa74e29e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0784bbf52d5a4f7395fc827f77e831f/" rel="bookmark">
			刘二大人《Pytorch深度学习》第七讲作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sigmoid函数（课程中的方法）：
import numpy as np import torch xy=np.loadtxt('E:\study\PyTorch\diabetes.csv',delimiter=',',dtype=np.float32) x_data=torch.from_numpy(xy[:,:-1])#-1加[]保证运算结果为矩阵而非向量 y_data=torch.from_numpy(xy[:,[-1]])#from_numpy根据数值创建两个tensor出来 class Model(torch.nn.Module): def __init__(self): super(Model, self).__init__() self.linear1 = torch.nn.Linear(8, 6) self.linear2 = torch.nn.Linear(6, 4) self.linear3 = torch.nn.Linear(4, 1) self.sigmoid = torch.nn.Sigmoid() def forward(self, x): x = self.sigmoid(self.linear1(x)) x = self.sigmoid(self.linear2(x)) x = self.sigmoid(self.linear3(x)) return x model=Model() criterion=torch.nn.BCELoss(reduction='mean') optimizer=torch.optim.SGD(model.parameters(),lr=0.1) loss_list=[] for epoch in range(10000): #Forward y_pred=model(x_data) loss=criterion(y_pred,y_data) print(epoch,loss.item()) loss_list.append(loss.item()) #Backward optimizer.zero_grad() loss.backward() #Update optimizer.step() import matplotlib.pyplot as plt epoch_list=[i for i in range(10000)] plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0784bbf52d5a4f7395fc827f77e831f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df575ca3160293f0cf747df494eb93f9/" rel="bookmark">
			GhostNet(CVPR2020)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://www.wanglichun.tech/2020/03/08/ghostnet/
论文链接：https://arxiv.org/abs/1911.11907
作者解读：https://zhuanlan.zhihu.com/p/109325275
开源代码：pytorch :https://github.com/iamhankai/ghostnet.pytorch/blob/master/ghost_net.py
本篇论文是发表于CVPR2020的一篇轻量级网络的论文，作者是华为诺亚方舟实验室，文章的总体思路比较清晰，为了减少网络计算量，作者将传统的卷积分成两步进行，首先利用较少的计算量通过传统的卷积生成channel较小的特征图，然后在此特征图的基础上，通过cheap operation(depthwise conv)再进一步利用较少的计算量，生成新的特征图，最后将两组特征图拼接到一起，得到最终的output，最终实验效果还不错，相同计算量的情况下比MobileNet- V3的效果还要更好一些。
虽然说mobileNet或者是shuffleNet提出了使用depthwise或者是shuffle等操作，但是引入的1x1卷积依然会产生一定的计算量
为什么1x1依然会产生较大的计算量?看卷积计算量的计算公式n∗h∗w∗c∗k∗k,可以发现，由于c和n都是比较大的，所以会导致这个计算量也是比较大的，但是作者在分析输出的特征图的时候发现，其实有些特征图是比较相似的，如下所示，作者认为可以通过简单的变换得到。
基于此，作者得到启发，是不是每张图都需要用这么大的计算量去得到？是否可以通过cheap transformation得到这些相似的特征图？
于是乎，就诞生了GhostNet。Ghost就是说相似的特征图，犹如另一个的幽灵，可以通过简单的线性变换得到。
1.Ghost模块
对于某个特征层，只用卷积操作生成部分真实的特征层(真实特征层)，剩余的特征层(幻象特征层)通过对真实特征层进行线性操作获得，然后将真实特征层与幻象特征层拼接到一起组成完整的特征层。
2. 复杂度分析
假设我们输入特征图的尺寸是h*w*c,输出特征图的尺寸是h'*w'*n,卷积核大小为k*k
在cheap operation变换中，我们假设特征图的channel是m，变换的数量是s，最终得到的新的特征图的数量是n,那么我们可以得到等式：
n=m∗s
由于Ghost的变换过程中最后存在一个恒等变换（Identity），所以实际有效的变换数量是s-1,所以上式可以得到如下公式：
m∗(s−1)=n/s∗(s−1)
所以我们便可以计算得到如下结果：
Ghost模块具有两个超参数
① s:用于生成 m=n/s 个内在特征图，
② 以及用于计算幻影特征图的线性运算的 d*d（即深度卷积核的大小）。
实验得s=2；d=3
深度可分卷积vs幻象模块
深度可分卷积用深度卷积处理每个特征通道上的空间信息，然后用点卷积进行通道间的特征融合。而幻象模块用正常卷积生成部分真实特征层，然后由真实特征层线性变换得到幻象特征层，最终由真实特征层和幻象特征层组成完整特征层
3.GhostNet bottleneck
下图是Ghost bottleneck结构图，很类似resnet结构，不同的是channel是先升维再降维。
Ghost Bottleneck：利用Ghost模块的优势，作者介绍了专门为小型CNN设计的Ghost bottleneck（G-bneck）。如图3所示，Ghost bottleneck似乎类似于ResNet中的基本残差块（Basic Residual Block），其中集成了多个卷积层和shortcut。Ghost bottleneck主要由两个堆叠的Ghost模块组成。第一个Ghost模块用作扩展层，增加了通道数。这里将输出通道数与输入通道数之比称为expansion ratio。第二个Ghost模块减少通道数，以与shortcut路径匹配。然后，使用shortcut连接这两个Ghost模块的输入和输出。这里借鉴了MobileNetV2，第二个Ghost模块之后不使用ReLU，其他层在每层之后都应用了批量归一化（BN）和ReLU非线性激活。上述Ghost bottleneck适用于stride= 1，对于stride = 2的情况，shortcut路径由下采样层和stride = 2的深度卷积（Depthwise Convolution）来实现。出于效率考虑，Ghost模块中的初始卷积是点卷积（Pointwise Convolution）。
Difference from existing methods
在MobileNet等网络中，基本都会使用1x1的卷积，而在GhostNet中，可以使用任何尺寸的卷积。在MobileNet中，使用了pointwise+depthwise,但是在GhostNet中，可以使用正常的卷积。Ghost使用了更多的线性变换。 4.GhostNet：
GhostNet：基于Ghost bottleneck，作者提出GhostNet，如表1所属。作者遵循MobileNetV3的基本体系结构的优势，然后使用Ghost bottleneck替换MobileNetV3中的bottleneck。GhostNet主要由一堆Ghost bottleneck组成，其中Ghost bottleneck以Ghost模块为构建基础。第一层是具有16个卷积核的标准卷积层，然后是一系列Ghost bottleneck，通道逐渐增加。这些Ghost bottleneck根据其输入特征图的大小分为不同的阶段。除了每个阶段的最后一个Ghost bottleneck是stride = 2，其他所有Ghost bottleneck都以stride = 1进行应用。最后，利用全局平均池和卷积层将特征图转换为1280维特征向量以进行最终分类。SE模块也用在了某些Ghost bottleneck中的残留层，如表1中所示。与MobileNetV3相比，这里用ReLU换掉了Hard-swish激活函数。尽管进一步的超参数调整或基于自动架构搜索的Ghost模块将进一步提高性能，但表1所提供的架构提供了一个基本设计参考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86093fbebb434059aabc8d631a536f29/" rel="bookmark">
			数组以及冒泡排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组的命名
数据类型名 数组名[数组长度];
例如： int a[4]; 意思就是数组名字叫a，长度为4，是int类型
引用数组则是
数组名[下标]; 例如：
int a[4]={1,2,3,4};
printf("%d\n",a[3]);
注：数组的下标从0开始。例如上面数组a，1的下标为0，以此类推，则4的下标为3。
所以上面a[3]输出是4 冒泡算法：从小到大顺序排列 #include &lt;stdio.h&gt; int main(void) { int a[8] = {89,34,-51,1,23,-45,99,32}; //冒泡排序:进行 n-1 轮比较 int len = 8; int b; //优化算法：最多进行len-1次比较 for (int k = 0; k &lt; len-1; k++) { //每一轮比较前 n-1-k 个，也就是说，已经排序好的最后 i 个不用比较 for (int i = 0; i &lt; len-1-k; i++) { if(a[i] &gt; a[i+1]){ //交换两个数组元素的值 b = a[i]; a[i] = a[i+1]; a[i+1] = b; } } } for (int i = 0; i &lt; len; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86093fbebb434059aabc8d631a536f29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab75adf3632ffc7621b0c6dfc9db9e89/" rel="bookmark">
			【软件工程】常见七种过程模型介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇博客为大家整理软件工程中的七种过程模型，供大家学习参考！！！
如有侵权，请联系作者。
文章目录 前言一、惯用过程模型（A Generic Process Model）1.瀑布模型（the waterfall model）2.增量模型（the incremental model）3.并行模型（the parallel model）4.原型模型（the prototyping model）5.抛弃原型模型（the throwaway prototyping model）6.螺旋模型（the spiral model） 二、敏捷开发（Agile Development）7.极限编程过程（模型）（eXtreme Programming,XP） 三、场景小练习参考 前言 过程模型为软件工程工作提供了特定的路线图，该路线图规定了所有活动的流程、动作、任务、迭代的程度、工作产品及要完成的工作应如何组织。
“混乱的边缘”——有序和混乱之间的一种自然状态，结构化和反常之间的重大妥协。过程模型试图在找出混乱世界中的秩序和适应不断发生变化这两种要求之间寻找平衡。
惯用过程模型有时称为“传统”过程模型（Prescriptive Models）
一、惯用过程模型（A Generic Process Model） 1.瀑布模型（the waterfall model） 瀑布模型又称为经典生命周期，它提出了一个系统的、顺序的软件开发方法，从用户需求规格说明开始，通过策划、建模、构建和部署的过程，最终提供完整的软件支持。
模型特点：
（1）严格的线性模型结构
（2）固定的阶段划分
（3）大量的文档驱动
（4）阶段性的评审机制模型解释：
（1）瀑布模型的过程，将从上一项活动接收该项活动的工作对象（输入），实施该项活动应完成的内容给出该项活动的工作成果，传给下一项活动（输出）。
（2）“瀑布”的理解，像瀑布一样自顶向下，过程不可逆。前一阶段完成，才进行下一阶段。
（3）由于固定的阶段划分，每个阶段会完成规定的文档以保证后续阶段的进行。为了保证文档的正确性，每个阶段结束前都会对文档进行评审。这是必要的。模型存在的问题：
（1）阻塞：由于模型的线性特性，在项目中会发生“阻塞状态”。（想像一下如果你是后一阶段的项目开发者，前一阶段的开发存在问题没办法解决的时候，你只能选择等待）
（2）变更：软件实际项目的发展会面临变更流，变更可能造成混乱。（就好比瀑布自顶向下流，在下游无法改变上游的流向）。模型适用性：
（1）适用于需求确定且清晰，开发过程无大的变更流的软件开发。
（2）不适用于需要快速开发、交付，需求模糊且易产生变更的软件开发。模型变体——V模型，本质上是添加一系列测试（质量保证动作）。
2.增量模型（the incremental model） 增量模型综合了线性过程流和并行过程流的特征，随着时间的推移，在每个阶段都运用线性序列。整体上，按照瀑布模型的流程实施项目开发；软件的实际创建中，将软件系统按功能分解为许多增量构件，并以构件为单位逐个地创建与交付，直到全部增量构件创建完毕，集成到系统之中交付用户使用。
模型特点
（1）将待开发软件系统模块化
（2）将待开发软件系统组件化模型解释
（1）“增量”的理解，从一组给定的需求开始，通过构造一系列可执行中间版本来实施开发活动。第一个版本纳入一部分需求，下一个版本纳入更多的需求，依此类推，直到系统完成。每个中间版本都要执行必需的过程、活动和任务。
（2）第一个增量为核心产品（core product），满足最基本的需求，许多附加的特性（有些已知，但可以先不做；有些未知；）没有提供，客户对核心产品进行评估，然后制定下一各增量计划。
（3）我自己的理解：这与我们平时写算法的过程也类似，首先完成最基本功能的输入输出，做好“模块化”，然后再根据题目中更多的要求对算法各部分进行增加，最后完成最终的代码。（大致意思，比喻可能不准确）模型的优点
（1）模块化，分批次提交软件产品，便于用户及时了解项目进展。
（2）组件化，减少软件开发风险，一个开发周期的错误不会影响到整个软件系统。
（3）开发顺序灵活，可以按照组件优先级实现。逐渐扩展，便于用户在开发过程中需求渐渐明朗，有效适应用户需求的变更。模型适用性
（1）适用于可以分批次交付、系统可模块化的软件，或者开发人员对相关领域不熟悉难以一次性开发，项目管理人员有较高把握全局水平的开发。
（2）不适用于软件系统很难被模块化的软件开发。 3.并行模型（the parallel model） 并行模型主要以开发过程中的主要技术活动和任务为框架，描述了开发过程中主要技术活动和任务的并行性。并行开发模型关注开发活动之间的并行性以及它们的相互关系，使项目管理者能够了解其项目当前的总体状态，便于他们有针对性地实施有效的项目管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab75adf3632ffc7621b0c6dfc9db9e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d62a72b1db4a1c44b607034d7711ff2/" rel="bookmark">
			前端和后端哪个工资更高呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端和后端哪个工资更高呢？
一个大二学生问的，说老师在讲课时说，从工资来看，后端开发要比前端高，并且说，掌握公司核心技术的都是后端。他问事实是否真的如此，然后问该如何规划自己的工作。
这里整理的是个匿名答案，答主应该是在网易工作过，后来去了阿里。答案很有参考意义，特此整理出来供参考。
前端工资比后端低吗？
我可以负责任的告诉题主：据我所知，至少在杭的网易、阿里，前端跟后端是一个批发价。
关于以上，我说的是业务层的。假如你非得说开发Web 3D引擎的前端比一个普通的Java价格贵，或者玩Hadoop的数据研发比一个普通前端高这就是属于杠精了。
我们指的前后端，一定是Web开发的前后端，属于Web业务开发。不然写中间件、大数据的后端，写Web 3D引擎、前端框架设计的前端，都属于脱离传统Web开发的范畴了。
我指的是同水平的情况下，因为个体的差异十分大，但是普遍一个P6/7的前端跟一个P6/P7的后端是一个价格。
很多大学老师，其实离软件行业很远了。我们不排除一些大牛老师跟企业保持着密切的合作，但那只是少数。
所以，老师对行业的一些看法并非可以全信，来知乎问问是好的；但是知乎上每个人的观点也不一样，现在就有人说后端价格更高这个观点，我再给你讲得详细一点。
1. 一定程度上，后端薪资更高的观点也不是错的。
为什么？如果你算一下阿里前端的平均薪资和后端平均薪资，一定是后端高。
前端的地位提高，就这几年的事情。现在你去阿里P7前端跟后端(阿里后端就是Java)是一个价格，可是之前一定是后端高，加之后端在阿里创建之初就有了，很多后端出身的人早进入管理层了。但是他们依然是挂着P9/P10的头衔的后端，前端不过是10年前后才发力的，P10以上的前端其实就那么一两个。
严格来讲到了P10这个级别已经没什么前后端这一说了；只不过是前端出身或者后端出身而已。如果是一路走技术路线上来的，前后端啥的都是通吃的。如果走的管理，其实已经不算技术了，那就是纯粹的管理。
所以，你现在根本不用担心这些问题，现在批发价是一样的，因为不管是平均数怎么样，到自己手里的才是王道。
2. 个体差异很大，即使同一个级别拿的也有多有少。
我其实在同级别的工程师里是属于最高薪那个级别的，虽然讨论薪资是高压线，但是每个员工都或多或少知道自己的情况。
当时去阿里时，我开的价格很高，一个原因是我当时并不想离开网易。如果不到一定价格我是不会走的，还有一个原因是，想探一下自己的价值到底有多高。
这就牵扯到一个程序员生存策略了：每年一定要拿出两个月出去面试——不管你要不要走。需要不断评估自己的价格，和发现自己身上的缺点及时弥补。
很多程序员不知道自己值多少钱，要么不敢要工资、要么狮子大开口。想知道自己值多少，去市场上试水是做好的办法。要记住一点：你的价格是市场决定的，而不是你的能力。你的能力，在稳定市场情况下可以跟价格成正比。但是市场永远不是稳定的。
3. 不管是前端还是后端只是个敲门砖。
很多年轻（其实我也挺年轻的）的小伙伴们都有一些执念，比如打算写一辈子Java成为Java大牛，走向人生巅峰，其实想法是好的，但是不可取。
我们从技术角度来说，因为写一辈子Java是当不了Java大牛的，你依然需要学习JVM系的Scala、Kotlin，更底层的C/C++，还有Go、Erlang这些拥有Java不同哲学的语言。
最后，发现你Java只是你的敲门砖，真正让你成为Java大牛的是你懂的不同语言的哲学，懂得不同场景下发挥出Java的优势，规避Java的劣势，深知Java的优缺点。而不是抱着Java是最好的语言，写一辈子Java。
从职业生涯的角度来说，注意我在前文中用描述高P的工程师的词汇，『xx出身』。对于高P而言，没有前后端。前后端只是敲门砖，因为我们今天讨论的Web业务层面的开发，说实话都是处于计算机难度底端的玩意。之于一些答主说的鄙视链，其实就是中国队鄙视泰国队，菜鸡互啄。
在Web这条线上想走到高P，基本上都是走业务架构这条路，这考验的就是大局观了。
P10以上还能纯玩技术的我指出几个方向，算法相关岗位(深度学习、计算机视觉等)、数据相关岗位、图形学相关岗位（比如网易开发游戏引擎的大牛等）、大规模系统的底层相关（阿里云）、安全相关。
总结：
1. 前后端目前在大厂至少是一个批发价。
2. 你作为一个个体能拿多少取决于市场，也取决你的个人能力和谈判能力，更平均薪资无关。
3. 不管是前端还是后端，只是你之后发展的敲门砖，传统web开发没有难度可言，想走高P懂前后端，是最最起码的要求。
如何规划自己的职业？
最后，题主问到如何规划自己的事业。上文说的很清楚了：前端只是你的敲门砖。下面，谈谈几个靠前端敲门后的大方向：
1. Web开发
前端、后端是Web开发的两个端，其实同城Web开发，在很多国外公司没前后端这个说法，都叫做『软件工程师』或者Web developer。
其实，要转换一个思想：前后端并不是对立的，而是纯粹的一家人。只是被国内外的一些市场强行分成了前后端,所以在你保持前端高水平的情况下，精进一些后端技术是必要的，但是要分清主次，前端为主。
2. 数据方向
以后数据就是互联网时代的石油嘛，这个方向也不错。
在前端这边就是可视化相关的技术，在阿里这边有大量的数据可视化实践，因为阿里号称自己是数据公司。
逼格比Web开发高，以后再精进也还是离不开大数据相关的东西。什么Hive、Hadoop之类的。进一步说，Web开发分Web前端和Web后端，是以Web服务的角度来看待的，数据研发这个是在Web开发的基础上用数据附能，懂可视化的一定是有前端能力的，懂Hadoop的一定Java玩的溜，属于Web开发的拓展方向。
3. 大前端方向
上文提到，移动端的ios/安卓早就式微了，但是并不代表死了。只是所有公司都意识到，没必要上原生开发了。
一些大厂，比如阿里，在大量实践rn和weex；由于公司内部安卓/ios式微，一定程度上，前端把ios和安卓收编了，统称大前端(还有node)。
距刘平川说收编完安卓/ios后加上node团队，大前端人数与后端持平。可以想象大前端的leader的话语权了：学一点ios/安卓没坏处。
4. 图形学方向
图形学的集大成者无疑是游戏行业，当然阿里也有自己的游戏业务,前端自然是与图形学有千丝万缕的联系，除了上面提到了可视化，还有相关3d引擎的开发工作。
不管在广度上下功夫，还是在深度上下功夫，其目的就是在技术上高出其他人一个维度。
当然，不过要先进入这个行业，就得先拿下敲门砖。来千锋，从0基础到项目实战，帮你在短期内迅速掌握企业所需IT技术，快速拿高薪入名企
文末福利
扫描下方二维码免费体验14天正课~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2840bd37fa19cd2270cb676b6641512e/" rel="bookmark">
			VScode配置Latex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载并安装texlive编译器
Index of /CTAN/systems/texlive/Images/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirrorhttps://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/ 在上面的清华镜像中就可以找到texlive的镜像了，点击下载即可。下载完后双击镜像打开找到其中的 install-tl-windows.bat 文件，右键以管理员身份打开。这会要有耐心，稍等片刻出现：
点击左下角 advanced 出现：
点击 Customize 出现：
将右侧改为只选中文和英文，节省磁盘空间。之后一路确定到安装。安装时要有耐心，要安装的包有许多，耗时很长。
2、下载VScode
Download Visual Studio Code - Mac, Linux, Windowshttps://code.visualstudio.com/Download 在上面的网址中即可下载VScode，下载好后右键以管理员身份进行安装，记得修改安装位置，其余直接选择肯定的选项即可。
3、在VScode中配置Latex
点击如图中左侧最后一个，框中输入Latex进行查询，安装下图中第一个插件。
在安装好插件后，点击左下角，在弹出的窗口中找到设置(setting）点击。事实上也可以用中文插件将软件汉化，这里不多介绍。点击过后如下输入json查询，之后点击 在settings.json中编辑 。
在json文件中输入如下代码保存即可完成在VScode中对Latex的配置。(要注意的是如果你是全新安装的VScode，那么json文件中原本就有一对大括号，而我们只需将下面的代码粘贴到到括号中即可)代码如下：
"workbench.colorTheme": "Default Dark+", "latex-workshop.intellisense.biblatexJSON.replace": { }, "latex-workshop.intellisense.bibtexJSON.replace": { }, //设置扩展何时使用默认的(第一个)编译链(recipe),自动构建(build)LaTeX项目, //即什么时候自动进行代码的编译, 选项为3个: //- onSave: 当一个tex文件在vscode中被保存时,构建项目; //- onFileChange: 当检测到任何依赖项中的文件更改(即使被其他应用程序修改)时构建项目,即 //检测到代码被更改时就自动编译tex文件以构建项目 //- never: 从不自动编译,需要编写者手动构建 "latex-workshop.latex.autoBuild.run": "never", //新的LaTeX图标能够编译文档,将在下文提及 //启用上下文LaTeX菜单,此菜单默认停用(因为可以通过新的LaTeX图标使用),即变量设置为false. //只需要将此变量设置为true,即可恢复菜单,将编译文档的两个选项显示在鼠标右键的菜单中,分别是 //- Build LaTeX project: 进行tex文件的编译,构建LaTeX项目 //- SyncTeX from cursor: 进行正向同步,从代码定位到编译出来的pdf文件相应位置 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2840bd37fa19cd2270cb676b6641512e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9edd594a1c686f61b9161761abc84e/" rel="bookmark">
			uniapp h5 位置选择，微信定位&#43;腾讯位置服务获取当前地址，逆地址解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的网站：https://green.yuansu.space 一、获取当前地理坐标 首先引入JSSDK
npm install jweixin-module --save 使用
var jweixin = require('jweixin-module') jweixin.ready(function(){ // TODO }); DCloud官网的论坛，有分享的例子http://ask.dcloud.net.cn/article/36007。
我这里做个定位接口例子。
首先要看微信的文档。清楚大致的流程。https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115
1、common目录，创建文件，名称是wechat.js。内容如下：
注意要点：
1、前端域名要放在微信公众平台js安全域名下。
2、 url:(window.location.href).split('#')[0] 当前页面url作为参数 进行数字签名。
// import request from './request'; var jweixin = require('jweixin-module'); import store from '@/store' import api from '@/common/vmeitime-http/' //自己封装的网络请求类，也可以直接使用uni.request export default { //判断是否在微信中 isWechat: function() { var ua = window.navigator.userAgent.toLowerCase(); if (ua.match(/micromessenger/i) == 'micromessenger') { // console.log('是微信客户端') return true; } else { // console.log('不是微信客户端') return false; } }, //初始化sdk配置 initJssdkShare: function(callback, url) { //服务端进行签名 ，可使用uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9edd594a1c686f61b9161761abc84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d9cccdec629a3d1286521eac2634092/" rel="bookmark">
			【Tableau Desktop 企业日常问题21】Tableau怎么增加条形图间距?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述问题分析设计步骤总结 问题描述 Tableaul里面拖拽的条形图都是固定的(如果没有做过特殊处理的话)，当我们条形图比较多的时候，就不利于查看数据(虽然你可以ctrl+↑↓来调整视图中的条形图大小，但是他们都是固定伸缩的)
先看一下最终结果
问题分析 我们可以从上面的图中看到其实就是两个度量值的条状，那我们在他们直接在增加一个度量(注意：但是这个度量值都是为空值)，他们之间不就“留有余地”了吗？
设计步骤 1.先制作好我们改版前的视图，当然你里面的字段可以和视图里面的不一致，这都可以。
提示：
拖拽相关维度到视图依次双击sales，和profit度量(这样做的目的就不需要将其他度量名称一一排除了)标记哪里调整一下自己喜欢的颜色
2.在度量值框里面双击输入avg(NULL)(当然这里avg(),可以替换min，max都行，因为里面值都为空)
3.更改我们创建的avg(NULL)名称就行
里面记得打上空格
5.最总结果
可以看一下GIF演示
总结 今天看到一本书里面有这样一段话特别受益：
提升思维认知后再去学习点状知识。这世上的知识非常多，你可能经常听到有人推荐各种极具吸引力的课程，这些知识点就像一个球面上的点一样，是无穷无尽的。不要用有限的生命去无规则地学习无限的点状知识。建议先建立成熟的思维认知，用武装好的大脑去学习最核心的原理性知识，方法论。在现实社会中遇到具体问题或者对某方面知识产生兴趣时，再有针对性地补充点状知识。 怎么好的句子肯定要记笔记呀！
在这里放这段话的原因是：我们要需要提升思维认知，学会举一反三，比如为啥要添加一个字段，这个字段里面为啥要Null值。以后遇到需要在视图，或者标题"留余地"的时候，就会想到：哎，创建一个空字段试试。想用其他字符分隔，加入Unicode编码试试(Tableau完全支持Unicode编码)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fc2079735a76305dc3d7e678a2971e1/" rel="bookmark">
			UDS诊断故障码及诊断服务介绍(14h, 19h, 85h)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 诊断故障 人看病就医时，医生通过望闻问切来判定病因。而汽车运行出现故障时，维修人员(或开发人员)通过专业的诊断仪器直接读取当前车辆的故障。原理是车载控制器会时刻监控自身的运行情况，并把发现的故障信息进行存储，当诊断设备通过CAN总线请求读取故障时(19h服务)，车载控制器返回相应的数据。
常见汽车故障 常见的车载故障如下(包含不限于)
1 ECU内部故障（如ECU供电电压过高，ECU供电电压过低）
2 网络通信异常（如总线bus off，节点丢失）
3 输入输出电路异常(传感器短路/开路，执行器异常，温度传感器数值过高)
诊断故障码 产品设计时，会根据产品硬件罗列出所有可能的故障，并为每个特定的故障分配一个代码，这个代码就是诊断故障码。如定义供电电压过低的故障码为U2E0468.诊断故障码可以理解为故障的身份证号。故障码对应一个故障的产生条件，恢复条件，故障内容。
如诊断仪读取到U2E0468，便知道发生了供电电压过低的故障，这个故障会在供电电压持续低于8.6V 3秒后产生，而当供电电压持续大于9V 5秒后消失。
诊断故障码(Diagnostic Trouble Code)的格式如下：
由三个字节组成：(DTC故障码定义由主机厂总线人员定义，且采用ISO15031-6定义的标准)。
DTCHighByteDTCMiddleByteDTCLowByteEE0468 DTC故障码高字节定义如下；中低字节表明具体故障对象跟类型。
小解：前面提及的故障码为U2E0468；，
U指的是通用/网络故障，DTC High bytes的第7位跟第6位是1，
bit5是1，bit4是0
把该故障码解析成16进制变为0xEE0468.
1.1 诊断故障码状态掩码字节 DTC状态掩码用于判定当前故障的状态，占用一个字节。 如该字节计算出的数值为2E代表历史故障确认码，2F代表故障当前检测到。
1.1.1 Bit 0：TF(Test Failed) 该位用以指示当前时刻是否检测到错误；
当检测到故障后，该位置1；
当未检测到故障或者收到$14服务后，该位清0.
状态迁移见下图：
1.1.2 Bit 1：TFTOC(Test Failed This Operation Cycle) 该位指示是否有故障产生在当前点火周期里任一时间内。
本周期内，检测到故障产生，该位置1，
直到下一个周期到来或者收到$14服务请求，该位清0。
当Bit2支持时，Bit1强制支持。 状态迁移见下图：
1.1.3 Bit2 PendingDtc 挂起错误标志位(最近俩个点火周期) 该位指示是否有故障检测到在当前及上个点火周期；
当上个点火周期或本个点火周期检测到错误后，该位置1；
当上个点火周期或本个点火周期都没检测到错误后，或收到$14请求后，该位清0.
1.1.4 bit3_CDTC ConfirmedDtc 历史确认DTC码位 该位用于表示检测到的某故障的次数达一定次数，确认故障存在，该故障被写进掉电非易失型内存中；
该位用于表示故障在过去存在，当前不一定存在。
上次请求$14服务后检测到故障且老化机制没有满足，该位置1；
当接收$14服务或者满足老化机制（连续40个点火周期没有检测到该故障）或存储内存被新的故障信息刷写后或自上次清除故障后再没有检测到该故障，清0；
1.1.5 Bit4_TNCSLC 测试未完成自从上次清除testNotCompletedSinceLastClear 该位指示自从上次$14服务后，是否完成有效的检测(无论检测是有故障还是故障)；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fc2079735a76305dc3d7e678a2971e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1ac9c665b5615f9778ed2d946eb887e/" rel="bookmark">
			单片机的硬件结构（51单片机的组成）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 51单片机的组成优点各部件的功能引脚的功能1．电源引脚（1）**VCC（40脚）**：+5V电源引脚（2）**VSS（20脚）**：数字接地 2．时钟引脚（1）XTAL1(19脚)（2）XTAL2（18脚）： 3. 控制引脚（1）RST (RESET，9脚)（2）EA*/VPP (31脚)（3）ALE/PROG*（30脚） 4. 并行I/O端口P0口电路结构工作过程p0口总结 P1口p1口电路结构： 1．位电路结构2．工作过程分析3．P1口的特点 P2口P2口位电路结构1．位电路结构2．工作过程分析3．P2口的特点 P3口P3口的位电路结构1．位电路结构2．工作过程分析3．P3口的特点 时钟电路与时序时钟电路设计机器周期、指令周期与指令时序指令周期复位操作和复位电路复位操作 CPU运算器特殊功能寄存器PSW各位功能：控制器存储器1. 程序存储器空间２.数据存储器空间３.特殊功能寄存器SFR４.位地址空间 51单片机的组成 （1）8位微处理器（CPU）
（2）数据存储器（128B RAM）
（3）程序存储器（4KB Flash ROM）
（4）4个8位并行I/O口（P0口~P3口）
（5）1个全双工异步串口
（6）2个16位定时器/计数器
（7）1个看门狗定时器
（8）中断系统：5个中断源、5个中断向量；
（9）特殊功能寄存器（SFR）26个；
（10）低功耗的空闲模式和掉电模式；
（11）3个程序加密位；
优点 相比AT89C51，AT89S51有
（1）增加在线可编程功能ISP功能（In System Program），现场程序调试和修改更加方便灵活
（2）数据指针2个，方便对片外RAM的访问过程
（3）看门狗定时器，提高系统抗干扰能力
（4）增加断电标志；
（5）增加掉电状态下的中断恢复模式；
各部件的功能 CPU（微处理器）
8位，包括运算器和控制器两部分，还有位处理功能。数据存储器（RAM）
128B（52子系列为256B），最多可扩64KB。片内RAM为高速RAM，可加快速度和降低功耗。程序存储器（Flash ROM）
4KB Flash（AT89S52 则为8KB；AT89C55片内20KB），如不够，片外可外扩至64KB。中断系统
5个中断源，2级中断优先权。定时器/计数器
2个16位定时器/计数器（52子系列有3个），4种工作方式。1个看门狗定时器WDT
当CPU由于干扰使程序陷入死循环或跑飞时，WDT可使程序恢复正常运行。串行口
全双工异步串行口，4种工作方式。可进行串行通信，扩展并行I/O口，可与多个单片机构成多机系统。P1口、P2口、P3口、P0口：4个8位并行I/O口。特殊功能寄存器（SFR） 26个，对片内各功能部件管理、控制和监视。是各功能部件的控制寄存器和状态寄存器，映射在片内RAM区80H～FFH内。
引脚的功能 1．电源引脚 （1）VCC（40脚）：+5V电源引脚 （2）VSS（20脚）：数字接地 左下脚接地，右上脚接电源
2．时钟引脚 （1）XTAL1(19脚) 输入端，使用片内振荡器时，应接外部石英晶体和微调电容。外接时钟源时，该脚接外部时钟振荡器输出的信号。
（2）XTAL2（18脚）： 片内振荡器反相放大器的输出端。
使用片内振荡器，该脚连接外部石英晶体和微调电容。当使用外部时钟源时，本脚悬空。 3. 控制引脚 （1）RST (RESET，9脚) 复位信号输入端
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1ac9c665b5615f9778ed2d946eb887e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb9ce857691481af44180aa4733a476/" rel="bookmark">
			SWUST OJ#952 单链表插入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题目
思路
代码
数据结构
STL
题目 题目描述
建立长度为n的单链表，在第i个结点之前插入数据元素data。
输入
第一行为自然数n，表示链式线性表的长度； 第二行为n个自然数表示链式线性表各元素值； 第三行为指定插入的位置i；第四行为待插入数据元素data。
输出
指定插入位置合法时候，输出插入元素后的链式线性表的所有元素，元素之间用一个空格隔开。输入不合法，输出"error!"。
样例输入
5 1 2 3 4 5 3 6 样例输出
1 2 6 3 4 5 思路 比较简单，就是从头遍历链表，找到输入位置的 地址p，在p位置进行头插就行。
// 单链表插入 void LinklistInsert(Linklist* &amp;L) { Linklist *p=L; int pos;cin&gt;&gt;pos;//输入位置 //输入不合法退出程序 if(pos&gt;LinklistSize(L)||pos&lt;=0) { cout&lt;&lt;"error!"; exit(0);//退出程序 } //找到插入的地址 p for(int i=1;i&lt;pos;i++) p=p-&gt;next; //创建新节点q Linklist *q; LinklistInit(q); cin&gt;&gt;q-&gt;data; //输入新节点q q-&gt;next=p-&gt;next;//链接节点q p-&gt;next=q;//覆盖位置p } 代码 数据结构 链表模板
#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; //定义链表 typedef struct LNode { int data; LNode* next; }Linklist; // 初始化链表 void LinklistInit(Linklist* &amp;L) { L=(Linklist*)malloc(sizeof(Linklist)); L-&gt;next=NULL; } //输入数据，创建链表 void LinklistCreate(Linklist* &amp;L) { int n;cin&gt;&gt;n; Linklist *p=L; while(n--) { Linklist* q; LinklistInit(q); cin&gt;&gt;q-&gt;data; p-&gt;next=q; p=q; } } int LinklistSize(Linklist* &amp;L) { int size=0; Linklist *p=L; while(p-&gt;next!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb9ce857691481af44180aa4733a476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168339731121ef027f7ce9b6b33c46ff/" rel="bookmark">
			安装photoshop2022遇到安装失败错误代码182如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 PS mac版的时候你有没有遇到过安装失败错误代码182的问题呢？这里小编为大家带来了详细的解决方案，收藏起来吧！
2022版本ps需要安装Adobe Creative Cloud，再运行安装包，否则会出现错误提示。如果遇到错误提示182，说明安装过旧版本
Adobe Creative Cloud for mac（acc）v5.6.5.58最新版https://mac.macsc.com/mac/2981.html?id=Mjk0ODE5
ps2022遇到安装失败错误代码182解决方法
在访达中点击【前往文件夹】
输入路径【/Library/Application Support/Adobe】，点击回车
找到文件夹【caps】并删除它
然后重新安装ps即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ae2ab1ef89a335f873ea3b5d510a97/" rel="bookmark">
			cgo:could not determine kind of name for C.XXX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下交叉编译过程出现的问题could not determine kind of name for C.XXX 网上出现大量的是提示import “C” 与其前面一行/* */中是否有空行。
相关空行的问题解决放方法
我的解决方法查看对应报错行中的声明，找到对应的头文件XXX.h，查看是否存在 ，可能需要更换头文件相关内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d84249920629ead1ea290b1a075dc3b9/" rel="bookmark">
			使用老毛子在腾讯云DNSpod上实现DDNS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用老毛子在腾讯云DNSpod上实现DDNS 需求：
1. 一台刷了老毛子的路由器
​2. 腾讯云上购买的域名
最近申请了电信的动态公网IP，就想着我之前买的域名可以用起来了，于是乎查阅资料在路由器上实现了DDNS
首先在GitHub上搜索DDNS，找到了一个可用的shell脚本rehiy/dnspod-shell为了方便拷贝到路由器，按照作者的方法把配置融合进了单文件内，文件修改好备用
复制进老毛子，浏览器输入192.168.123.1进入老毛子管理界面，依次点击高级设置中的系统管理-服务-启用ssh服务选择“是”
打开FinalShell或者其他ssh软件登录路由器，选择新建ssh连接，地址就是192.168.123.1，用户名密码就是你设置的密码，进入之后把改好的.sh文件复制到路由器/etc/storage/目录下
在计划任务那里输入*/10 * * * * /etc/storage/ardnspod.sh代表10分钟运行一次，最后点击“应用本页面设置”即可。
最后为了能够方便管理，我把代码的输出改到了系统日志输出，这样就可以在路由器管理界面看到运行效果啦
改过的代码我放在最后，只需要改最后两行的arToken和arDdnsCheck即可，arToken可以登录DNSpod点击右上角我的账号-api密钥
然后选择创建DNSpod Token即可获取，arToken格式为ID,Token
如果感觉不错的话请点个小哈。
#!/bin/sh # ############################################################# # AnripDdns v6.1.1 # # Dynamic DNS using DNSPod API # # Author: Rehiy, https://github.com/rehiy # https://www.anrip.com/?s=dnspod # Collaborators: ProfFan, https://github.com/ProfFan # # Usage: please refer to `ddnspod.sh` # ############################################################# # TokenID,Token export arToken="" # Get WAN IPv4 arWanIp4() { local hostIp local lanIps="^$" lanIps="$lanIps|(^10\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$)" lanIps="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d84249920629ead1ea290b1a075dc3b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbf72180a35949e9e5d9aaa386fbbe4c/" rel="bookmark">
			[ERROR] Error executing Maven. [ERROR] The specified user settings file does not exist:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在导入springboot和MAVEN构建的项目时，无法正常运行，点击MAVEN的deploy报错如下
[ERROR] Error executing Maven.
[ERROR] The specified user settings file does not exist: D:\MAVEN\apache-maven-3.8.4\conf\settings.xml
找不到该路径，于是去对应路径人工查找，发现确实没有setting.xml文件，D盘下叫MAVEN的文件夹也是我导入项目时生成的，所以初步判断要改路径。
而IDEA中自带MAVEN，于是想到取消勾选override，使用自带的MAVEN
解决方法，Ctrl+Alt+S→取消勾选override
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e5a5d5f46eccf3482d0e7eb2fbeea0/" rel="bookmark">
			【vue后台管理项目编辑未提交的时候也跟着改变】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue后台管理项目编辑未提交的时候也跟着改变 在做后台管理项目点击编辑出现弹框但是我修改弹框内容还未提交，他后面的列表内容就发生了改变
如图：
解决方案： 提示：编辑打开的弹框渲染的数据一定要重新定义一个对象，然后将对应的对象赋值给新的对象。
注意：该方法只对后台数据为 json 数据的数据类型才会生效，其他数据类型不生效。
editor(item){ this.editorForm = JSON.parse(JSON.stringify(item)); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5143e9ca09d749fb85a2a7bd570e658/" rel="bookmark">
			ubuntu vim 安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装：
sudo apt-get install vim 配置：
如果要配置全局参数，则修改/etc/vim/vimrc
sudo vim /etc/vim/vimrc 如果仅修改vim个人配置的话，则修改/home/username/.vimrc
vim /home/lyy/.vimrc 一般配置参数如下，将其复制保存到文件尾部即可。
" 在窗口标题栏显示文件名称 set title " 显示行号 set number " 语法高亮 set syntax=on " Tab键的宽度为4 set tabstop=4 " 统一缩进为4 set softtabstop=4 " 自动缩进 set autoindent " 代码补全 set completeopt=preview,menu " 去掉输入错误的提示声音 set noeb " 不需要备份 set nobackup " 禁止生成临时文件 set noswapfile " 搜索时高亮显示 set hlsearch " 不区分大小写 set ignorecase 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fbd0b5e55b0d5946dde5d41180bb4b9/" rel="bookmark">
			C&#43;&#43;中类定义下的析构函数，拷贝（复制）函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; using namespace std; class CDate { private: int y, m, d; public: CDate(int y=2001, int m=1, int d=1); void print(); ~CDate(); CDate(const CDate&amp; t); }; CDate::CDate(int y, int m, int d) { this-&gt;y = y; this-&gt;m = m; this-&gt;d = d; } void CDate::print() { cout &lt;&lt; y &lt;&lt; "-" &lt;&lt; m &lt;&lt; "-" &lt;&lt; d &lt;&lt; endl; } CDate::~CDate() { cout&lt;&lt;"destructor..."&lt;&lt; y &lt;&lt; "-" &lt;&lt; m &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fbd0b5e55b0d5946dde5d41180bb4b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f293fc387ff791d4fdca8fed4eacd3f9/" rel="bookmark">
			phpstudy中MySQL无法启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关闭mysql的方法：
sc delete mysql 这样就可以启动了
2、重新启动mysql
然后就会发现你自己的mysql用不了了，以下可找到解决方法
重新启动mysql
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d5d5f6d999aff4d9410ff6ed1011a2/" rel="bookmark">
			SDRAM contreoller控制器自刷新模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sdram controller 自刷新模块
首先明白为什么SDRAM需要自刷新模块，数据断电易失性，所以需要不断刷新来保持数据的有效性。
其次刷新周期为多少如下图所示：64ms/8192=7.8us=390CLK，即执行刷新命令时，至多需要间隔这么多个周期。
仲裁刷新可用状态机来表示：毕竟后面需要读写模块，利用状态机逻辑结构更加清楚明了。这里Flag_init_end还需要传送到自刷新模块，以生成刷新请求；
最后刷新时序如下所示：
1、送A0-A12给物理地址端口，送precharge命令到物理命令端口；
2、等待20ns（一个CLK）送AUTOREFRESH命令到物理命令端口；
3、根据时序图要执行两个自刷新命令，但是实际可以只执行一个也没问题；
调试过程：
仿真测试图：运行到初始化到205us程序正常，即初始化程序正常；
进行自刷新时报错，报错如下
装载寄存器出错；
查错：
1、可以发现仲裁器给自刷新模块的ref_en信号拉高后并没有拉低，导致自刷新模块在执行自刷新命令后，自刷新模块没有等待7.8us发出ref_req请求的情况下马上执行执行自刷新命令。
2、改正 1 的错误后又报错，可以发现没有cmd_reg 寄存器在执行自刷新模块时指令一直都是nop，而自刷新模块aref_cmd会改变，原因可能是顶层状态机模块对指令的赋值出错了；
顶层状态机地址赋值出错，修改后成功自刷新成功：
下面给出代码：
1、tb模块
`timescale 1ns/1ns module tb_sdram_top(); reg sclk; reg s_rstn; wire sdram_clk; wire sdram_cke; wire sdram_cs_n; wire sdram_cas_n; wire sdram_ras_n; wire sdram_we_n; wire [1:0] sdram_bank; wire [11:0] sdram_addr; wire [1:0] sdram_dqm; wire [15:0] sdram_dq; initial begin sclk&lt;=1; s_rstn&lt;=0; #100; s_rstn&lt;=1; end always #10 sclk=~sclk; sdram_top sdram_top_inst1( .sclk (sclk), .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91d5d5f6d999aff4d9410ff6ed1011a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd13e147f1aa399b93e01625f15d4b73/" rel="bookmark">
			Linux-4.4.72内核（uaf-tty_struct-babydriver）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：2017 CISCN babydriver
附件文件 给boot.sh加上-s调试参数解压rootfs.cpio后拿到./lib/modules/4.4.72/babydriver.ko漏洞文件vmlinux-to-elf bzImage vmlinux得到vmlinux内核下面即可分析和编写exp了 保护 分析 将babydriver.ko放入IDA中进入到babydriver_init模块入口函数，简单分析如下：
模块流程核心函数如下：
babyopen函数：
可以注意到参数分别是struct inode *inode, struct file *filp
inode结构存储有关文件和目录（文件夹）的信息，例如文件所有权、访问模式（读取、写入、执行权限）和文件类型。
file结构代表一个打开的文件。（它不特定于设备驱动程序；系统中每个打开的文件在struct file内核空间中都有一个关联。）直到最后一个close。在文件的所有实例都关闭后，内核释放数据结构
babyread：
babywrite：
babyioctl：
babyrelease函数：
综上可知release函数存在一个uaf漏洞，ioctl函数可以重新分配指定大小的堆块
思路 这里利用uaf漏洞劫持tty_struct
/dev/ptmx是一种tty设备，tty设备被open的时候，会申请一个空间作为tty_struct定义如下：
struct tty_struct { int	magic; //魔数 0x00005401 占4byte struct kref kref; //0x00000100 这个结构体最终指向typedef struct --&gt; int counter; 占4byte struct device *dev; //占8byte struct tty_driver *driver;//占8byte const struct tty_operations *ops; //目标指针 定义在下面 int index; /* Protects ldisc changes: Lock tty not pty */ struct ld_semaphore ldisc_sem; struct tty_ldisc *ldisc; struct mutex atomic_write_lock; struct mutex legacy_mutex; struct mutex throttle_mutex; struct rw_semaphore termios_rwsem; struct mutex winsize_mutex; spinlock_t ctrl_lock; spinlock_t flow_lock; //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd13e147f1aa399b93e01625f15d4b73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e07ab56629180b8fa9152d9b79e52a/" rel="bookmark">
			【模仿案例】input插入透明背景图并设置背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实现效果 二、分析需求： 1.圆角矩形文本框
2.左侧有一个搜索的小logo
3.内置有emoji和文字
三、实现思路 1.采用子绝父相定位
如果想将元素定位在一个具体的范围之内，又想让这个元素的位置可以随意调整，可以使用子绝父相（参考网址：关于CSS中的定位使用子绝父相（子类绝对位置和父类相对位置））
因为input内不能直接插入img，用背景图片的形式比较难调整css样式（个人想法），所以这里采用子绝父相的遮眼法把搜索logo置入input之中，后面也方便调整样式
&lt;div class="search-input"&gt; &lt;div class="wrapper"&gt; &lt;input type="text" placeholder="🔥居家防疫必备" class="search"&gt; &lt;/div&gt; &lt;/div&gt; 2.input设置
2.1type设置
2.2内置文字：placeholder（emoji可以直接输入）
2.3样式：圆角矩形 border-radius；
2.4logo图片设置
2.4.1插入用background里面的url
2.4.2调整背景图大小：background-size
2.4.3调整背景图位置：background-position：调整左右 调整上下；
2.4.4背景图片和input的背景色共存：只需要在background的url属性后添加背景色设置
2.4.5根据logo图片适当调整input的padding使之更美观
.search-input .wrapper input { width: 250px; height: 30px; padding-left: 40px; color: #9d9d9d; border-radius: 20px; /* 圆角矩形效果 */ border: 0; /* 取消黑色外框 */ background: url(@/assets/img/search.png) no-repeat #f8f8f8; /* 实现png和背景色共存 */ background-size: 20px 20px; /* 背景图片大小 */ background-position: 10px; /* 背景图片定位：注意这里的第一个属性值是调整左右，第二个属性值是上下 */ } 效果图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73e07ab56629180b8fa9152d9b79e52a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad82a738d225fa29b6c221906b01b0f8/" rel="bookmark">
			软件工程知识点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、软件工程概述1. 定义2. 软硬件失效3. 软件危机4. 软件工程三要素5. 软件工程目标6. 软件工程研究内容7. 软件工程知识体系 二、软件生命周期模型2.1 软件工程过程：PDCA循环2.2 软件生命周期 software life cycle2.3 过程模型（软件生命周期模型）2.3.1 瀑布模型2.3.2. V模型和W模型2.3.2 原型方法(prototyping)2.3.4. 演化模型2.3.5. 增量模型2.3.6. 螺旋模型2.3.7. 喷泉模型(迭代模型)2.3.8. 构件组装模型2.3.9. 快速应用开发(RAD)模型 2.4 新型软件生命周期模型2.4.1 统一软件开发过程2.4.2.敏捷开发 三、软件需求分析3.1 系统分析4.2 需求定义4.3 软件需求分析的目标及任务4.4 软件需求分析建模的原则和方法4.5 软件需求工程4.5.1 软件需求分析过程 1.需求获取2.需求建模3.需求确认 四、 面向对象需求分析方法4.1 UML概述4.2 UML图4.2.1. 用例图4.2.2. 类图4.2.3. 对象图4.2.4. 顺序图4.2.5. 协作图 4.3 面向对象分析概述4.4 用例建模用例之间的关系 4.5 创建领域模型 Domain Model4.6 绘制系统顺序图4.7 创建系统操作契约 五、结构化分析分析模型的结构5.1. 数据建模与范式5.1.1 实体关系图(ER图)5.1.2 数据结构规范化 5.2. 功能建模与数据流图5.3 系统行为建模5.4. 数据词典 (DD，Data Dictionary) 六、 软件设计6.1 软件设计概述6.2 软件概要设计的步骤6.3 软件详细设计的步骤6.4 软件设计模型6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad82a738d225fa29b6c221906b01b0f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0827ffbbd8f1d6dd0670b8655f12c821/" rel="bookmark">
			[Spring] IoC的理解及三种依赖注入方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Spring] IoC的理解及三种依赖注入方式 Spring---IoC的理解及三种依赖注入方式IoC是什么意思依赖控制反转 Spring提供的依赖注入的三种方式setter注入（属性注入）构造器注入p命名空间注入（工厂方法注入） @Autowired Spring—IoC的理解及三种依赖注入方式 IoC是什么意思 IoC，即控制反转，依赖注入（DI）是SpringIoC的一个具体体现，因此，我们可以通过DI（依赖注入）来理解什么是IoC。
要理解什么是依赖注入，首先就要知道什么是依赖。
依赖 定义： 例如在类A中使用了类B的实例化对象，即我们在类A中，用new关键字显示地定义了一个类B的对象，那么就说类A依赖类B。
这样有什么不好？
这种依赖的方法，会造成严重的耦合性，如果类B发生了变化，类A也需要发生相应的变换，这样是非常影响应用的开发和相关维护的。那么，有没有一种方式能够使得类与类之间的依赖关系不这么紧密呢？
控制反转 在计算机中，有这样一句话，没有什么是加一层解决不了的，因此，我们引入了Spring的IoC容器，我们将类的实例化交给SpingIoC容器来执行，这样一来，实例化对象的权利就由用户转交给了Spring容器，这就叫作控制反转！
Spring提供的依赖注入的三种方式 setter注入（属性注入） 构造一个pojo实体类
在xml文件中绑定这个pojo实体类，并用property完成属性注入
在需要依赖注入的地方调用ApplicationContext类的对象来调用Bean容器中的依赖对象（创建对象的过程由程序员本身转移到了框架中，此为控制反转），完成属性注入
构造器注入 构建pojo实体类和有参构造方法
配置xml文件，绑定实体类，使用constructor-arg完成有参构造方法注入
调用ApplicationContext的实例化对象调用Bean容器中用有参构造器创建的对象（创建对象的过程由程序员本身转移到了框架中，此为控制反转）完成注入
p命名空间注入（工厂方法注入） 定义pojo实体类，完成setter方法
完成xml文件配置，注意导入p命名空间的头文件：xmlns:p="http://www.springframework.org/schema/p"
使用ApplicationContext的实例化对象调用Bean容器中的对象完成依赖注入
@Autowired @Autowired是一种注解，可以对成员变量、方法和构造函数进行标注，来完成自动装配的工作；@Autowired标注可以放在成员变量上，也可以放在成员变量的set方法上，也可以放在任意方法上表示，自动执行当前方法，如果方法有参数，会在IOC容器中自动寻找同类型参数为其传值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ef2184ad47ca072ad1165e34c000582/" rel="bookmark">
			使用idea启动vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚来公司实习发现公司的前端使用的是vue，之前根本就没有听说过。然后一上来就需要看代码，but but 就是没有文档什么的东西，
就需要自己去研读，我就想去运行其中的前端和后端联调起来方便理解，结果在配置和运行中出现了很多挫折，我就想写一下方便
大家不去采坑，直接运行好
一、在IDEA中配置vue插件 点击File--&gt;Settings--&gt;Plugins--&gt;搜索vue.js插件进行安装，下面的图中我已经安装好了。
二、搭建node.js环境 安装node.js 可以去官网下载：安装过程就很简单，直接下一步就行
测试是否安装成功：要使用管理员方式打开命令行cmd
安装完成之后，打开命令行工具,输入node -v如果出现版本号，则说明安装成功，npm包管理器是集成在node中的，所以，直接
输入npm -v 就会显示npm版本信息
好了，node环境已经安装成功，由于有些npm有些资源被屏蔽或者是国外资源的原因，经常会导致用npm安装依赖包的时候失败，
所以还需要安装npm的国内镜像----cnpm
三、安装cnpm（注意都是管理员方式运行） 在命令行中输入npm install -g cnpm --registry=http://registry.npm.taobao.org然后等待安装，安装完成之后，我们就可以用cnpm代替npm来安装
依赖包了。
四、安装vue-cli脚手架构建工具（注意都是管理员方式运行） 在命令行中运行命令cnpm install -g vue-cli,然后等待安装完成，通过以上三步，我们的环境和工具都准备好了，接下来就开始使用
vue-cli来构建项目
五、构建运行项目 1.我这里是已经有项目了，需要在命名行中，cd 到项目目录中去
然后需要输入命令：vue init webpack frontend (这里命令的意思是初始化一个项目，项目名称是frontend，其中webpack是构建工具，
也就是整个项目时基于webpack的)
运行命令初始化的时候会让用户输入几个基本的选项，如项目名称、描述、作者等信息，可以直接回车默认就可以了。
六、安装项目依赖资源 在项目的根目录下面会有一个package.json的文件
这里列出了项目依赖资源需要安装
首先需要cd到项目目录中去，然后输入cnpm install 等待安装，安装中会出现警告信息，有的会出现栈溢出等错误，我就是在这里遇到了，一般
第一次安装没事，如果安装过的，可以卸载了在重新安装
七、运行项目 运行命令npm run dev会用热加载的方式运行我们的应用，热加载可以让我们在修改完代码后不用手动刷新，浏览器就能实时看到修改后的效果
我们也可以在IDEA中配置运行
点击edit configurations配置，添加一个npm
然后就可以在IDEA中运行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2c063eda5e82f6f227d4fdf429af67/" rel="bookmark">
			java中的异常 最详细的讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、异常的概念 异常：在程序执行的过程中，出现的非正常情况，最终会导致JVM非正常停止
在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处 理异常的方式是中断处理
异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.
Throwable中的常用方法：
public void printStackTrace() :打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。
public String getMessage() :获取发生异常的原因。 提示给用户的时候,就提示错误原因。
public String toString() :获取异常的类型和异常描述信息(不用)。
二、异常的分类 Error：严重错误Error，无法通过处理的错误，只能事先避免
Exception：分为编译器异常和运行时异常
编译期异常，写代码的时候程序出现问题。可以由程序员写的时候解决
Exception也有子类RuntimeException运行期异常，程序运行时可以抛出的异常。
throws抛出异常，交给虚拟机处理，是中断程序执行的
try catch是会把后续代码执行
三、异常的产生过程解析 四、异常处理 1.抛出异常throw关键字 作用：可以使用ts关键字在指定的方法中抛出指定的异常
格式：throw new xxxException（异常原因）
例如：
throw new NullPointerException("要访问的arr数组不存在");
throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");
注意：1.throw关键字必须写在方法的内部
2.throw关键字后边new的对象必须是Exception的子类对象
3.throw关键字抛出指定的异常对象，我们就必须处理这个异常对象
throw关键字后边创建的是RuntimeException或RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常对象，中断程序）
throw关键字后边创建的是编译异常（写代码报错）就必须处理这个，要么throws要么try..catch
NullPointException 空指针异常是运行期异常
ArrayIndexOutOfBoundsException数组越界异常，运行期异常
2.声明异常throws 异常处理的第一种方式
作用：当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象
可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处理（自己 不处理，给别人处理）最终交给JVM处理-&gt;中断处理
使用格式：修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…{
throw new xxxException（异常原因）....
}
注意：1.throws必须写在方法声明处
2.throws后面生命的异常必须是Exception或Exception的子类对象
3.方法内部如果抛出多个异常对象，那么throws后面也要声明多个异常
如果抛出的异常有父子类关系，直接声明父类异常就行
4.调用了一个声明抛出异常的方法，我们就必须处理声明的异常，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2c063eda5e82f6f227d4fdf429af67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a7100df66b366d01eb6b0842e9e4a4/" rel="bookmark">
			springboot项目部署 &#43; vue项目部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 部署一个简单的前后端分离的博客项目
springboot项目部署 第一步：打包springboot项目(jar包)
第二步：将jar(项目的target目录下)包上传到云服务器上(Xftp)
第三步：新建nohup.out文件(Xshell)
第四步：后台运行jar包
nohup java -jar XXX.jar &amp; 第五步：打开接口文档看是否成功部署
第六步：如果端口的进程被占用：(下面步骤也用于停止项目运行)
netstat -nltp | grep XXXX kill -9 ID vue项目部署(nginx) 第一步：打包vue项目
第二步：打包成功后可看到dist文件夹
第三步：将第二步的dist文件夹上传到/usr/local/nginx/html/html目录下(我在/usr/local/nginx/html下新建了html文件夹)
第四步：配置nginx.conf文件(/usr/local/nginx/conf目录下)
第五步：重启nginx
/usr/local/nginx/sbin/nginx -s reload 查看nginx启动情况 :
ps -ef|grep nginx 第六步：检验结果(直接输地址即可)
第七步：如果报错Uncaught SyntaxError: Unexpected token ‘＜‘，则修改vue.config.js文件。
/*module.exports={ publicPath:"./" }*/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17dcf534399cd22efcb9539f2ab66749/" rel="bookmark">
			docker部署达梦流程记录（DM7和DM8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 https://blog.csdn.net/qq_26147675/article/details/109092797 x86的docker安装https://blog.csdn.net/weixin_42080828/article/details/120890860 arm架构的docker安装安装https://www.cnblogs.com/MisMe/p/13846268.htmlhttps://blog.csdn.net/Xiaoxin_Java/article/details/122784699?spm=1001.2014.3001.5502 麒麟安装达梦https://eco.dameng.com/docs/zh-cn/start/dm-install-docker.html DM8数据库docker安装教程查看容器 docker ps
查看镜像 docker images
查看端口状态 lsof -i:端口号 docker 安装DM8 X86-64架构下DM8数据库docker安装教程 https://eco.dameng.com/docs/zh-cn/start/dm-install-docker.html docker 安装达梦7 docker pull centos:centos7
拉取centos7镜像,若是arm架构的centos，和此命令不一样docker run -tid -p 55236:5236 -p 55237:5237 --privileged --name dmdatabase centos:centos7 /usr/sbin/init (创建容器并运行 -it 为交互模式运行，并分配伪终端 -p 随机端口映射，dm默认端口是5236，55236是外部访问端口)
查看宿主机55236端口是否打开docker cp /home/DMInstall.bin dmdatabase:/root
复制安装文件到容器内部docker exec -it dmdatabase bash
进入容器内部cd /root/
继续进入安装位置chmod 777 DMInstall.bin
授权运行./DMInstall.bin
安装路径 :/opt/dm db name :dm7 port:5236 page size :16 extent size :32 priv mode :0 time zone:+8 case sensitive:y utf-8:1 length in char :y database encrypt:n slice size:512 剩下全0 elog path:/opt/dm 如果报错创建文件错误，则给opt赋予777权限
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17dcf534399cd22efcb9539f2ab66749/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a40d05fc984fc52c8f9e1544b1ef67e6/" rel="bookmark">
			k8s功能介绍和常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Node篇 kubectl get nodes 查看所有node信息
kubectl get nodes -owide 查看所有node的详细信息
kubectl get node -o yaml 查看所有node的yaml文件
kubectl get node master01 -o yaml 查看master01的yaml文件
kubectl get node --show-labels 查看所有node的label信息
kubectl describe node node01 |grep -i taint -A3 查看node01的污点配置
kubectl taint nodes k8s-node01 ssd=true:PreferNoSchedule 给node01配置污点
二、deployment篇 2.1 创建deployment，命名为nginx kubectl create deployment nginx --image=nginx:1.15.2 2.2 查看deployment，包括IP kubectl get deploy -owide kubectl scale deploy {deployment的名称} -n xiyu --replicas=4 缩扩容副本数 kubectl describe -f pod-diff-nodes.yaml 通过查看文件创建deployment的具体信息 备注： NAME： Deployment名称 READY：Pod的状态，已经Ready的个数 UP-TO-DATE：已经达到期望状态的被更新的副本数 AVAILABLE：已经可以用的副本数 AGE：显示应用程序运行的时间 CONTAINERS：容器名称 IMAGES：容器的镜像 SELECTOR：管理的Pod的标签 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a40d05fc984fc52c8f9e1544b1ef67e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5428debff66560d09bfd00940e6c1200/" rel="bookmark">
			Windows10 修改Docker镜像的存储位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从Docker hub上拉下来的镜像默认安装在C盘里，这样时间长了C盘的可用空间越来越小。
Step 1：打开Win + R 输入cmd打开命令行
Step 2：查看当前wsl系统状态
wsl -l -v Step 3：停止当前的WSL
wsl --shutdown Step 4：备份docker-desktop-data和docker-desktop
wsl --export docker-desktop D:\docker\docker-desktop.tar wsl --export docker-desktop-data D:\docker\docker-desktop-data.tar 注：docker-desktop-data这个数据比较大，导入和导出时间会比较长，没有控制台日志输出，耐心等待
Step 5：取消注册
wsl --unregister docker-desktop-data wsl --unregister docker-desktop Step 6：导入备份的数据（注意版本要和前面保持一致）
wsl --import docker-desktop D:\docker\image D:\docker\docker-desktop.tar --version 2 wsl --import docker-desktop-data D:\docker\data D:\docker\docker-desktop-data.tar --version 2 Step 7：检查
wsl -l -v Step 8：重启Docker
* 注意：如果Restart Docker很长时间，报System.TimeoutException操作已超时的错误，有可能是前后两次的版本version对不上，建议重新导入，或者卸载Docker重装。
参考链接：win10修改docker镜像的存储位置_压码路的博客-CSDN博客_docker windows 镜像位置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c556a880becb88592d9ba1c90c098f/" rel="bookmark">
			C&#43;&#43;学习——&amp;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 在c++学习时遇到函数，这里的&amp;表示什么意思呢？
void TcpCongestionOps (const TcpCongestionOps &amp;other) { } 二、示例代码 #include&lt;iostream&gt; using namespace std; void swap1(int aii,int bii) { int cii=aii; aii=bii; bii=cii; } void swap2(int &amp;aii,int &amp;bii) { int cii=aii; aii=bii; bii=cii; } int main () { int a=1; int b=2; swap1(a,b); printf("%d %d\n",a,b); swap2(a,b); printf("%d %d\n",a,b); return 0; } 示例输出：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647e94f8264f17c5d6fa728a5e3425d0/" rel="bookmark">
			管理员已阻止你运行此应用——一步解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 学校上课用的软件，下载下来进行安装，提示“用户账户控制 为了对电脑进行保护，已经阻止此应用 管理员已阻止你运行此应用。有关详情信息，请与管理员联系”。尝试右键以管理员方式打开/关闭杀毒软件/关闭所有电脑防护/关闭防火墙/控制面板 安全和维护 更改用户账户控制设置 UAC级别设置到最低等解决方案均无效。
最终解决方案：
搜索cmd，找到“命令提示符”
右键-&gt;以管理员方式运行将当前路径切换到安装包文件(.exe）所在文件夹下
例如，我的安装包在E盘的tmp目录下，当前目录如下图所示
首先输入“e:”，切换到E盘；然后"cd 文件路径"；最后"要运行的.exe文件名"
即可运行成功。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00873bbaf582e9fc8e6a3f647ce108f0/" rel="bookmark">
			Java实现Gas Tracker(支持EIP-1559提案)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章链接：
How To Building an Ethereum Gas Tracker
基于React语言,改造了Java版本实现的数据层。支持以太坊上及其他生态链（需要支持了EIP-1559提案的链才可以），且优化了原有数据获取方式及拓展了avgGasFee，fastGasFee，slowGasFee等数据
以14549820区块数据为例说明数据
可获取当前区块 指定区块数据之间的 BaseFeePerGas 及通道拥堵率Gas Used Ratio
这里是展示部分数据，文章限制了字数，可以展示当前区块-指定任意区块数的数据进行Gas数据预测
数据示例：
{ "avgFill": "51.43%", "avgGasFee": 30, "fastGasFee": 56, "slowGasFee": 20, "gasList": [ { "reward": [ 1, 2, 2 ], "blockNumber": 14549820, "baseFeePerGas": 33.88785024, "gasUsedRatio": "41.03%" }, { "reward": [ 1, 2, 2 ], "blockNumber": 14549821, "baseFeePerGas": 33.12765708, "gasUsedRatio": "24.88%" }, { "reward": [ 1, 2, 2 ], "blockNumber": 14549822, "baseFeePerGas": 31.04728853, "gasUsedRatio": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00873bbaf582e9fc8e6a3f647ce108f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee30685cacaeb29efb6db93e3c97fd8/" rel="bookmark">
			验证码kaptcha组件（DefaultKaptcha）在本地开发环境没有问题，发到测试环境就报错的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前一直运行好好地系统今天发布到测试环境突然就不行了，但是试了很多办法，发现本地和开发环境都是可以的，该引入的依赖也引入了
&lt;dependency&gt; &lt;groupId&gt;com.github.penggle&lt;/groupId&gt; &lt;artifactId&gt;kaptcha&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 验证码相关的代码最近也没动过，本地测试接口也正常返回数据，controller如下：
ServletOutputStream out = null; try { HttpSession session = request.getSession(); response.setDateHeader("Expires", 0); response.setHeader("Cache-Control", "no-store, no-cache, must-revalidate"); response.addHeader("Cache-Control", "post-check=0, pre-check=0"); response.setHeader("Pragma", "no-cache"); response.setContentType("image/jpeg"); String type = request.getParameter("type"); String capStr = null; String code = null; BufferedImage bi = null; if ("math".equals(type)) { String capText = captchaProducerMath.createText(); capStr = capText.substring(0, capText.lastIndexOf("@")); code = capText.substring(capText.lastIndexOf("@") + 1); bi = captchaProducerMath.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee30685cacaeb29efb6db93e3c97fd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a568848c1b77f4dcc07cc46ebb9c76c/" rel="bookmark">
			根据六根数计算J2000坐标系下的直角坐标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有道云笔记链接如下
有道云笔记https://note.youdao.com/s/5eX7EVZ2
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/281/">«</a>
	<span class="pagination__item pagination__item--current">282/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/283/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>