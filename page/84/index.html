<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c752da4ff2010d38b47a95cc10715f/" rel="bookmark">
			技术 | 基于NI PXI系统的智驾测试方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能化是汽车工业发展的重要方向，目前，L2辅助驾驶在快速渗透，L2+高阶自动驾驶在加速落地。
自动驾驶的实现离不开算法，而算法的实现依托于数据。
各类传感器，如摄像头、激光雷达、毫米波雷达、超声波雷达、惯导等，在汽车行进过程中，时刻产生着大量的数据，为自动驾驶算法的实现提供支撑。
数据对自动驾驶的实现至关重要，鉴于此，部分主机厂已建立自己的数据中心，基于数据中心开展算法开发、算法训练及测试等系列工作。
数据中心的建立及使用，离不开3类测试系统，即智驾数据采集系统、智驾数据回灌系统及智驾HIL闭环仿真系统。
图1：基于数据中心的ADAS/AD开发及测试示意图
NI（恩艾）公司作为世界知名的测试工具厂商，针对智驾数据测试场景有完整的工具链，已推出智驾数采、回灌及HIL闭环仿真的解决方案。NI公司的数据回灌系统，已在中国的市场占据大部分市场份额。
怿星作为NI在智驾测试领域的重要Partner，已基于NI的软硬件平台开展多个智驾相关的项目。
本文分别介绍智驾数据采集系统、智驾数据回灌系统及智驾HIL闭环仿真系统。
智驾数据采集系统 数采系统一般放置于车上，用于采集实车道路环境数据。
NI的数采设备主体是一个板卡机箱，机箱中集成CPU主板及相关板卡，系统示意图如下图2。
图2：数据采集系统架构示意图
数采系统中，主板CPU运行Windows系统及数采相关上位机软件，可外接显示器进行相关操作及监控。系统中可视需插入视频板卡、Ethernet板卡、CAN/LIN板卡、串口板卡等各类板卡，以满足不同数据的采集需求。
NI的数采系统有以下特点，可解决扩展性、同步性等相关需求：
● PXI机箱提供了18个卡槽，可视需接插10+块通信板卡，满足高阶智驾车辆传感器数据及总线数据的采集需求
● 板卡间实现了硬件时钟同步，可保证1us级同步精度
● 系统实现了PTP时钟同步，可获取GPS时间并授时给各板卡，为各类数据打上精确时戳
● 通过磁盘阵列卡可接插多块SSD固态硬盘，可满足压缩数据及非压缩数据的实时数据采集需求
● 视频板卡及Ethernet板卡均具备TAP功能，可实现在进行数采时不影响整车正常通信，保证车辆正常行驶
智驾数据回灌系统 智能驾驶数据回灌系统，将采集的实车道路环境数据回注到智驾域控制器，以满足在实验室环境下还原实车道路环境，进而进行智驾算法开发及训练等工作的需求。
数据回灌系统主体由服务器电脑及板卡机箱组成，系统示意图如下图3。
图3：数据回灌系统架构示意图
在回灌系统中，服务器电脑是市面上外购的高性能服务器，该服务器是数据处理的主设备，需具备多张高性能显卡。服务器电脑获取待回放的数据后，对数据进行解压缩、视频编码格式转换等系列处理，之后通过Ethernet传给板卡机箱，机箱中的各板卡对数据进一步处理后，将数据注入给待测ECU。
回灌系统的板卡机箱与数采系统的板卡机箱实现了硬件通用。
NI的数据回灌系统有以下特点，可解决同步性、可靠性等相关需求：
● PXI机箱提供了18个卡槽，可视需接插10+块通信板卡，满足高阶智驾车辆传感器数据及总线数据的回灌需求
● 板卡间实现了硬件时钟同步，可保证1us级同步精度
● 系统实现了PTP时钟同步，并可实现以下授时功能： （1）获取待测ECU的系统时间并据此时间改变待回注数据的时戳；
（2）获取待回注数据的时戳并据此时间向待测ECU授时
● 使用RDMA技术传输视频数据，保证传输的带宽及可靠性，并可通过增加RDMA网卡数量来扩展带宽
● 可实现动态注入多类视频相关故障以进行故障模拟
● 可实现集群化测试，即多台回灌设备并行协同运行以进行智驾算法相关的训练及测试等
智驾HIL闭环仿真系统 智能驾驶HIL仿真系统与数据回灌系统高度相似，但有两点明显区别：
（1）回灌系统的数据源是采集的实车道路环境数据，而HIL仿真系统，数据源则是通过场景仿真软件生成的数据；
（2）回灌系统是开环测试系统，仅负责将数据回注给待测ECU，而HIL仿真系统是闭环测试系统，可监听待测ECU的响应并据此控制动力学仿真模型的运行，实现闭环仿真。
HIL闭环仿真系统示意图如下图4。
图4：HIL仿真系统架构示意图
在HIL闭环仿真系统中，服务器电脑是市面上外购的高性能服务器，其运行场景仿真软件，生成各类传感器数据及总线数据，这些数据通过Ethernet传给板卡机箱，机箱中的各板卡对数据进一步处理后，将数据注入给待测ECU。在板卡机箱中，CPU主板上运行有动力学仿真软件，其接收待测ECU发出的报文，根据报文信息控制动力学模型的运行，从而实现闭环仿真。
HIL闭环仿真系统的板卡机箱与数采系统、回灌系统的板卡机箱实现了硬件通用。
NI的HIL闭环仿真系统有以下特点，可解决同步性、扩展性等相关需求：
● PXI机箱提供了18个卡槽，可视需接插10+块通信板卡，满足高阶智驾车辆传感器数据及总线数据的通道需求
● 板卡间实现了硬件时钟同步及PTP时钟同步，保证了系统的同步性能
● 开放的平台，可集成业界各主流的仿真软件，如VTD、Prescan等
● 场景仿真软件与动力学仿真软件分开运行，前者运行于图站上，后者运行于机箱的主板CPU的Linux RTOS上，互不干扰，保证了动力学模型运行的实时性
● 可实现集群化测试，即多台HIL闭环仿真设备并行协同运行以进行智驾算法相关的训练及测试等
结语 随着L2+高阶自动驾驶的发展，数采系统、回灌系统及HIL闭环仿真系统在智驾的开发中发挥着越来越重要的作用。
NI提供的数据采集系统、数据回灌系统及HIL闭环仿真系统，均基于PXI平台，实现了硬件的高度复用，且已实现软硬件产品的标准化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68c752da4ff2010d38b47a95cc10715f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9853bf8dcf722b879a2dd231a1bcdc/" rel="bookmark">
			解决办法：E: 仓库 “......” 没有 Release 文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 在安装pantheon的时候遇到了这个情况
错误:8 https://ppa.launchpadcontent.net/keithw/mahimahi/ubuntu jammy Release 404 Not Found [IP: 2620:2d:4000:1::3e 443] 正在读取软件包列表... 完成 E: 仓库 “https://ppa.launchpadcontent.net/keithw/mahimahi/ubuntu jammy Release” 没有 Release 文件。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 解决方法 直接去查了下这个源，如下图
最后的Release对应的版本就到17.04.1,而我的Ubuntu系统是22.04，因此系统设置的就是查找jammy Release，22.04的发行名称是Jammy
选择了16.04对应的Release下载，因此把Jammy改成Xenial就行了
这里我图快就直接在附加驱动里改了，命令行的操作方法还得查一下，不过应该也不难
问题解决！
命中:7 https://ppa.launchpadcontent.net/keithw/mahimahi/ubuntu xenial InRelease 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81543bbfd802e37b0074021b7a27b684/" rel="bookmark">
			Matlab中switch, case, otherwise语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
语法
说明
示例
比较单个值
与多个值进行比较
switch, case, otherwise语句是执行多组语句中的一组。
语法 switch switch_expression case case_expression statements case case_expression statements ... otherwise statements end 提示
case_expression 不能包含关系运算符（例如 &lt; 或 &gt;）来与 switch_expression 进行比较。要测试不相等性，使用if,elseif,else语句。
MATLAB switch 语句不会像C语言的switch语句一样失效。如果第一个case语句为true，则 MATLAB 不会执行其他case语句。例如： result = 52; switch(result) case 52 disp('result is 52') case {52, 78} disp('result is 52 or 78') end result is 52 在该 case 内定义特定 case 中的代码所需要的变量。由于 MATLAB 仅执行任何 switch 语句的一个 case，因此一个 case 内定义的变量不适用于其他 case。例如，如果当前工作区不包含变量 x，则仅定义 x 的情况可以使用它：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81543bbfd802e37b0074021b7a27b684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c57350bb347b2b0bbe2a19f4d9b5ed63/" rel="bookmark">
			做一个贪吃蛇小游戏happy一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接Vue上代码
&lt;template&gt; &lt;div&gt; &lt;div&gt;贪吃蛇&lt;/div&gt; &lt;canvas id="canvas" width="400" height="400"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { ctx: null, interval: null, snakeData: [], count: 0,//步数 pointList: [{ x: 36, y: 18 }],//默认点 direction: "d", // 默认右,w:上,s:下,a:左,d:右 controll: null,//监听 controll2: null,//监听 speedCount: 0, // 渲染倍数 speed: 8 // 渲染倍数分子 }; }, mounted() { // 贪吃蛇，canvas const canvas = document.getElementById("canvas"); this.ctx = canvas.getContext("2d"); // 获取绘制上下文 const list = []; for (let i = 0; i &lt; 2; i++) { list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c57350bb347b2b0bbe2a19f4d9b5ed63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db826ca8c25c7d308926e6c68a0e9cd/" rel="bookmark">
			20个提升效率的JS简写技巧，告别屎山！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 中有很多简写技巧，可以缩短代码长度、减少冗余，并且提高代码的可读性和可维护性。本文将介绍 20 个提升效率的 JS 简写技巧，助你告别屎山，轻松编写优雅的代码！
移除数组假值 可以使用 filter() 结合 Boolean 来简化移除数组假值操作。假值指的是在条件判断中被视为 false 的值，例如 null、undefined、空字符串（"" 或 ''）、0、NaN 和 false。
传统写法：
let arr = [12, null, 0, 'xyz', null, -25, NaN, '', undefined, 0.5, false]; let filterArray = arr.filter(value =&gt; { if(value) { return value }; }); // [12, 'xyz', -25, 0.5] 简化写法：
let arr = [12, null, 0, 'xyz', null, -25, NaN, '', undefined, 0.5, false]; let filterArray = arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6db826ca8c25c7d308926e6c68a0e9cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59820e054871559c43f5f37cd3cf7c8/" rel="bookmark">
			CSS box-shadow阴影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、语法 box-shadow: h-shadow v-shadow blur spread color inset; 值描述h-shadow必需的。水平阴影的位置。允许负值v-shadow必需的。垂直阴影的位置。允许负值blur可选。模糊距离spread可选。阴影的大小color可选。阴影的颜色。在CSS颜色值寻找颜色值的完整列表inset可选。从外层的阴影（开始时）改变阴影内侧阴影 2、外阴影 box-shadow: 0 0 red 阴影不出现
box-shadow: 0 -10px red 垂直方向向上移动10px，只显示上边阴影
box-shadow: 10px 0 red 水平方向向右移动10px，只显示右边阴影
box-shadow: 0 10px red 垂直方向向下移动10px，只显示下边阴影
box-shadow: -10px 0 red 水平方向向左移动10px，只显示左边阴影
box-shadow: 10px 10px red 水平向右移动10px，垂直向下移动10px，显示右边与下边阴影
box-shadow: -10px -10px red 水平向左移动10px，垂直向上移动10px，显示左边与上边阴影
3、内阴影 阴影出现位置与外部阴影相反
box-shadow: 0 0 red inset 阴影不出现
box-shadow: 0 -10px red inset 垂直方向向上移动10px，只显示上边阴影
box-shadow: 10px 0 red inset 水平方向向右移动10px，只显示右边阴影
box-shadow: 0 10px red inset 垂直方向向下移动10px，只显示下边阴影
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c59820e054871559c43f5f37cd3cf7c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588785dd9f91ff66eca62bc58fa59635/" rel="bookmark">
			华为云云耀云服务器L实例评测｜搭建CounterStrike Source Delicated Server（CS起源游戏服务器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为云云耀云服务器L实例评测｜搭建CounterStrike Source Delicated Server（CS起源游戏服务器） #【有奖征文】华为云云服务器焕新上线，快来亲身感受评测吧！#
⭐️ CounterStrikeSource（CS起源是Valve的一款多人游戏，允许玩家自由的假设社区服务器，并且可以通过Sourcemod等插件进行自定义）
🌫前言：
Valve提供了Source Delicated Server允许玩家搭建大多数的Source引擎的游戏，本文介绍的是在云耀服务器提供的Ubuntu系统中安装CounterStrike Source Delicated Server。
该游戏服务器支持linux和Windows操作系统，且配置要求不高，非常适合在轻型服务器中部署。
安装前请更新软件包和源
apt-get update apt-get upgrade Step.1 安装Steamcmd Steamcmd是Steam的命令行工具，可以在命令行中执行命令，在下载CounterStrike Source Deilicated Server前，需要先行登录Steamcmd.
🏅方法一—&gt;从仓库安装：
sudo apt install steamcmd PS: 64位系统需要替换为如何命令
sudo add-apt-repository multiverse sudo dpkg --add-architecture i386 sudo apt update sudo apt install lib32gcc1 sudo apt install steamcmd 如果lib32gcc1下载不了，可能需要替换为lib32gcc1-s1
不是所有源都提供了steamcmd,大概率需要手动下载
🥇方法二—&gt;手动安装:
sudo apt-get install lib32gcc1 #同上如果提示lib32gcc1被lib32gcc-s1替换，则使用后者 mkdir ~/Steam &amp;&amp; cd ~/Steam #创建存放用的文件夹，当然你也可以创建新用户来操作 curl -sqL "https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz" | tar zxvf - 下载并解压后可以看到和
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588785dd9f91ff66eca62bc58fa59635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a21bf745cd1db7ac7898914add828f/" rel="bookmark">
			proc文件读写（4.19）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读写/proc/cpuinfo 文件
文件打开 fs/proc/cpuinfo.c：
static int cpuinfo_open(struct inode *inode, struct file *file) { arch_freq_prepare_all(); return seq_open(file, &amp;cpuinfo_op); } static const struct file_operations proc_cpuinfo_operations = { .open	= cpuinfo_open, .read	= seq_read, .llseek	= seq_lseek, .release	= seq_release, }; static int __init proc_cpuinfo_init(void) { proc_create("cpuinfo", 0, NULL, &amp;proc_cpuinfo_operations); return 0; } proc_create函数： struct proc_dir_entry *proc_create_data(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct file_operations *proc_fops, void *data) { struct proc_dir_entry *p; BUG_ON(proc_fops == NULL); p = proc_create_reg(name, mode, &amp;parent, data); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1a21bf745cd1db7ac7898914add828f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d49892c5c4676de8ad4951c503c1e107/" rel="bookmark">
			喜讯 | 怿星科技获评SAE“优秀核心零部件企业”，测试软件平台工具广受赞誉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年9月22日-23日，SAE 2023汽车智能与网联技术国际学术会议成功举行。此次学术会议由SAE International与南昌智能新能源汽车研究院联合主办，大会汇聚了来自国内外智能网联领域的顶尖专家和学者。大会同期颁布的奖项旨在向行业推选出更多新时代涌现的杰出企业，赋能智能网联产业链并促进创新技术发展。
怿星科技凭借在汽车行业内优秀的软件开发和测试能力，荣获“智能网联软件工具与测试软件平台及工具”类别的“优秀核心零部件企业”荣誉。
随着智能网联汽车时代的到来，汽车电子架构向高性能、低时延计算平台快速演进，SOA、万兆以太网、TSN、DDS、OTA等一批新技术得到广泛应用。怿星科技围绕整车电子及软件系统开发，形成了一系列软硬件产品，涵盖E/E架构设计、网络通信测试、功能测试、域控制器协议栈量产软件、智能驾舱量产软件等，满足了用户高效开发、便捷交付的需求，提升了整车电子及软件开发效率。在汽车测试领域，怿星打造了业界领先的Neptune系列产品和SolarSystem测试管理平台，为客户提供端到端的汽车电子自动化测试与验证服务，覆盖零部件级、系统级、跨域集成和整车集成测试，让智能汽车研发更高效。除了大型测试设备，怿星还开发了一套面向OEM、Tier1的轻量化、低成本汽车以太网通信测试解决方案——SmartETH。它不仅为用户提供了用于汽车以太网通信测试的软件，还可以根据用户需求来提供相关测试服务、硬件设备、技术支持。目前，怿星已为300+客户提供了测试相关的产品及服务，积累超5万条测试用例库，获得客户广泛认可。
本次入选SAE中国智能网联汽车行业优秀核心零部件企业，是行业对怿星产品的技术开发和市场应用的认可和肯定。未来，随着汽车智能化发展和软件定义汽车的深入，怿星科技将持续创新，再接再厉，为汽车研发提供更多更优质的产品和解决方案，为智能网联汽车保驾护航。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7a257d79407cb28531707746b07f5e/" rel="bookmark">
			NoClassDefFoundError：org/apache/poi/util/POILogFactory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：https://poi.apache.org/components/index.html#components
Word DOC需要加入依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;5.2.3&lt;/version&gt; &lt;/dependency&gt; Excel XLS需要加入依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;5.2.2&lt;/version&gt; &lt;/dependency&gt; Word DOCX，Excel XLSX 需要加入依赖
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cdadd61754a3646c90234c36f31fe94/" rel="bookmark">
			基于Traefik3.0和Let‘s Encrypt以及阿里dns的HTTPS方案（docker 部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Traefik3.0和Let’s Encrypt以及阿里dns的HTTPS方案（docker 部署） 前提 申请Let’s Encrypt邮箱绑定域名，https://easy.zhetao.com/购买域名和服务器（备案），域名解析配置泛域名和主域名安装docker以及docker-compose docker-compose version: '3' services: traefik: restart: unless-stopped # The latest Traefik Docker image image: traefik # Enables the web UI and tells Traefik to listen to Docker environment: - ALICLOUD_ACCESS_KEY=${ALICLOUD_ACCESS_KEY} - ALICLOUD_SECRET_KEY=${ALICLOUD_SECRET_KEY} command: - --api.insecure=true - --providers.docker - --providers.docker.exposedbydefault=false - --entrypoints.web.address=:80 - --entrypoints.websecure.address=:443 - --certificatesresolvers.letsencrypt.acme.dnschallenge=true - --certificatesresolvers.letsencrypt.acme.email=${EMAIL} - --certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json - --certificatesresolvers.letsencrypt.acme.dnsChallenge.provider=alidns ports: - "80:80" - "443:443" - "9080:8080" volumes: - ./letsencrypt:/letsencrypt - /var/run/docker.sock:/var/run/docker.sock:ro labels: - traefik.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cdadd61754a3646c90234c36f31fe94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe74a282a5fd2ce5eb632e3998c52a9f/" rel="bookmark">
			WPF中以MVVM方式，实现RTSP视频播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 视频播放在上位机开发中经常会遇到，基本上是两种常见的解决方案
1.采用厂家提供的sdk和前端控件进行展示，常见的海康/大华都提供了相关sdk及文档
2.开启相机onvif协议，捅过rtsp视频流进行播放，前端可以采用web方式，或者wpf中的视频控件进行展示。
项目需求，决定了最终采用开启相机onvif供能，wpf中播放的方式。
网络调研一阵子之后，基本都是推荐Vlc.DotNet或者libvlcsharp.wpf进行前端展示。
参考了很多代码，无论是官方文档，还是不同博客里的代码，很难做到用mvvm的方式对于逻辑解耦。
而且Vlc.DotNet已经不再更新了。
Libvlcasharp.wpf的设计有些反人类，可以参考这篇文章WPF中使用LibVLCSharp.WPF 播放rtsp - Naylor - 博客园 (cnblogs.com)。
所以这部分逻辑写的很难受，需要寻找其他方案。
最近有空了，调研了几个其他开源项目，大家的思路都比较一致，相机打开onvif协议推送rtsp视频流，本地通过ffmpeg进行视频转流，然后推送到wpf前端控件上。
unosquare/ffmediaelement: FFME: The Advanced WPF MediaElement (based on FFmpeg) (github.com)
SuRGeoNix/Flyleaf: Media Player .NET Library for WinUI 3/ WPF/WinForms (based on FFmpeg/DirectX) (github.com)
网上有FFME的样例代码，我在本地搭建没有成功，应该是我的ffmpeg编译版本问题，可以参考这个项目。
DG-Wangtao/FFMEVideoPlayer: 使用FFmepg封装的WPF MideaElement，可以播放rtsp视频流。感谢 https://github.com/unosquare/ffmediaelement
最终选择了Flyleaf的方案，简单搭建了demo给大家参考。
Flyleaf官方项目地址SuRGeoNix/Flyleaf: Media Player .NET Library for WinUI 3/ WPF/WinForms (based on FFmpeg/DirectX) (github.com)
MVVM框架使用的是CommunityToolKit.MVVM
正文 Flyleaf的使用整体分成四步走，
1.App.xaml及App.xaml.cs中配置ffmpeg的dll文件地址；
2.ViewModel中配置参数等信息；
3.View中配置布局等信息；
4.在xaml.cs中确定View和ViewModel的绑定关系
App.xaml.cs中配置ffmpege的地址 1.1ffmpeg的dll文件，我才用的是Flyleaf官方sample中的文件，版本不是最新的。
1.2文件统一放在项目中的FFmpeg文件夹中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe74a282a5fd2ce5eb632e3998c52a9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab785e34a53e3488018178aa3c94e663/" rel="bookmark">
			IDEA解决low memory内容不足(亲测有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1问题描述 打开IDEA右下角窗口提示
low memory内存不足
The IDE is running low on memory and this might affect performance. Please consider increasing available heap.
问题如下图：
2 分析问题 这是因为提示Java内存不足,我们点击增加内存旧可以解决该问题。
3 解决步骤 我使用的是IDEA2022版本，别的版本也是这个步骤哈
在IDEA中 点击 HELP–&gt;Change Memory Setting(改变内存设置)
IDEA默认应该是1024MiB,这里我们给改成2048，保存并重启即可
这种方式是我实践后觉得最快,最简单的方式,推荐给大家,当然解决办法不止这一个
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e972ba56b99f61b0550f9cef0c8141/" rel="bookmark">
			swagger 未授权访问漏洞修复,这可能是你看到的最好的解决方案！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过渗透测试发现springboot项目中存在swagger 未授权访问的漏洞，怎样才能方便的修复未授权访问的漏洞，同时又能通过验证正常访问swagger文档呢？本文给出了解决方案，这可能是你看到的最好的解决方案！
大多数人都是直接禁用swagger，这样一来就给开发人员带来了负担，因为需要解决接口文档的问题，相信大家用惯了swagger文档，都不愿意自己再去手动写接口文档了。
swagger未授权访问主要的路径如下，根据版本不同或者自定义的路径，可能会有一定的差异，自定义路径的只需要把自己的路径添加进来即可。
1、/swagger-resources 2、/v2/api-docs 3、/swagger-ui.html 本人提供的解决方案就是通过过滤器的方式对请求进行验证，请求的时候需要在链接后面加上我们自定义的token参数，通过验证token判断是否是合法的访问，注意，添加过滤器后需要在启动类上加上@ServletComponentScan注解才能生效，具体实现如下：
/** * 解决swagger 未授权访问漏洞，需要在启动类加@ServletComponentScan注解 * * @author lidongyang * @date 2023/9/14 16:43 * @since V1.0.0 */ @Slf4j @WebFilter(urlPatterns = {"/swagger-resources", "/v2/api-docs","/swagger-ui.html"}, filterName = "swaggerFilter") public class SwaggerFilter implements Filter { /** * 访问swagger的token,默认123@abc,根据自己设置的值替换即可 */ @Value("${swagger.token:123@abc}") private String swaggerToken; @Override public void init(FilterConfig filterConfig) throws ServletException { Filter.super.init(filterConfig); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e972ba56b99f61b0550f9cef0c8141/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda937e37cf73292276ef3c4787f4ccc/" rel="bookmark">
			Python中文文本处理利器--jieba分词库详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是jieba？
二、jieba库的使用
1、jieba库的模式
2、jieba库常用函数
三、jieba库实际案例分析
1、简单分词使用
2、统计红楼梦中出现的词语数量
四、总结
一、什么是jieba？ jieba（结巴分词）是一个开源的中文分词工具，用于将中文文本切分成词语或词汇单位。它是一个 Python 库，广泛用于自然语言处理（NLP）和文本分析领域。jieba 有以下主要特点和功能：
中文分词：jieba 可以将中文文本按照词语切分，使得文本可以更容易地被处理和分析。分词是中文文本处理的基础步骤，对于词频统计、文本分类、情感分析等任务非常重要。多种分词模式：jieba 支持不同的分词模式，包括精确模式、全模式和搜索引擎模式。用户可以根据具体任务需求选择不同的模式。自定义词典：用户可以创建自定义词典，以确保特定词汇被正确切分。这对于处理特定行业或领域的文本非常有用。高效快速：jieba 实现了基于前缀词典和动态规划的分词算法，因此在速度上表现出色。关键词提取：jieba 还提供了关键词提取功能，可以帮助用户识别文本中的关键词，有助于文本摘要和信息检索等任务。 二、jieba库的使用 1、jieba库的模式 ①精确模式（精确分词模式）：
概述：精确模式试图将文本切分成最精确的词汇单位，通常用于需要高精度分词的任务。使用方法：jieba.cut(text, cut_all=False) ②全模式（全切分模式）：
概述：全模式会尽可能多地切分文本，将文本中的所有可能的词语都提取出来，通常用于信息检索等任务。使用方法：jieba.cut(text, cut_all=True) ③搜索引擎模式：
概述：搜索引擎模式在精确模式的基础上，对长词再次进行切分，增加了文本中词语的召回率，通常用于搜索引擎等应用。使用方法：jieba.cut_for_search(text) 2、jieba库常用函数 函数描述jieba.cut可以按照指定的分词模式切分文本jieba.load_userdict用于加载用户自定义的词典，以确保特定词汇被正确切分。jieba.add_word手动添加一个新词汇到词典中，临时生效。jieba.del_word从词典中删除一个词汇jieba.enable_parallel启用并行分词，提高分词速度jieba.sent_tokenize将文本拆分成句子jieba.cut_for_search搜索引擎模式的分词函数，适用于搜索引擎相关任务jieba.analyse.extract_tags用于关键词提取，提取文本中的关键词 三、jieba库实际案例分析 1、简单分词使用 import jieba text = "今天是个好日子" cut = jieba.cut(text) string = ' '.join(cut) print(string) 结果展示：
可以看到，使用jieba分词器将一句完整的话分成数个单独的词语，并且输出了分词所用的时间。jieba还可以对一个字符串进行分词，并且使用任意符号进行连接。
2、统计红楼梦中出现的词语数量 import jieba txt = open("red.txt", "r", encoding='utf-8').read() word = jieba.lcut(txt) count = {} for word in word: if len(word) == 1: continue else: count[word] = count.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cda937e37cf73292276ef3c4787f4ccc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21040228bbbf430d0f7d43f73789eb94/" rel="bookmark">
			Push rejected: Push to origin/master was rejected
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Push rejected: Push to origin/master was rejected 原因：推拒绝：推送到起源/主人被拒绝 解决方案如下：
方案1：
1.在Idea打开终端
方案2：
1、在对应项目文件里打开 Git Bash
然后依次输入：
git pull
git pull origin master
git pull origin master --allow-unrelated-histories
最后重新尝试push
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35dae8c919fdae85f3aeaf8b0df71584/" rel="bookmark">
			VSCode使用EmmyLua调试lua
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装EmmyLua插件：
2. 添加调试配置：
保存配置；
3. 选择先前添加的配置：
选择Unity.exe
4. 设置断点：
6.Unity运行游戏，就会触发断点：
参考链接：VSCode进行Lua调试_vscode调试lua_纸煞白的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e28c116ee1bce763047906a389efa9d/" rel="bookmark">
			Cgo 是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cgo 是一项了不起的技术，它允许 Go 程序与 C 语言库相互操作，这是一个非常有用的功能。
没有它，Go 就不会有今天的地位。cgo 是在 Android 和 iOS 上运行 Go 程序的关键。
被过度使用 我个人认为 cgo 在 Go 项目中被过度使用了，当面临在 Go 中重新实现一大段 C 语言代码时，程序员会选择使用 cgo 来包装库，认为这是个更容易解决的问题。但我认为这是一种错误的选择行为。
显然，在某些情况下，cgo 是不可避免的，最明显的是你必须与图形驱动或窗口系统进行互操作，而后者只能以二进制 blob 的形式提供。在这些场景下，cgo 的使用证明了它的权衡是合理的，比许多人准备承认的要少得多。
以下是一份不完整的权衡清单，当你把 Go 项目建立在 cgo 库上时，你可能没有意识到这些权衡。
你需要对此进行思考。
构建时间变长 当你在 Go 包中导入 “C” 时，go build 需要做更多的工作来构建你的代码。
构建你的包不再是简单地将范围内的所有 .go 文件的列表传递给 go 工具编译的一次调用，而是包含以下工作项：
需要调用 cgo 工具来生成 C 到 Go 和 Go 到 C 的相关代码。
系统中的 C 编译器会为软件包中的每个 C 文件进行调用处理。
各个编译单元被合并到一个 .o 文件中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e28c116ee1bce763047906a389efa9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8403c85d2486ef040a628ad8556a3071/" rel="bookmark">
			分享从零开始学习网络设备配置--任务4.1 IPv6地址的基本配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务描述
某公司构建了互联互通的办公网，需要不断扩大网络规模。网络管理员小赵决定采用IPv6的地址，满足公司网络规模的未来发展。 由于IPv4地址耗尽及IPv4地址区域分配不均衡，成为运营商必须面临的一个问题。另外随着互联网的商业化，用户数量呈几何倍数增长，对IPv4地址的海量需求导致IPv4地址短缺的问题日益突出。IPv4的后继版本为IPv6，能提供海量的IP地址，支持几乎无限的地址空间，它将从根本上解决IP地址不足的问题。 IPv6使用了全新的地址配置方式，使配置更加简单。要在网络中使用IPv6地址，首先要掌握IPv6的基本配置。
任务要求
（1）IPv6地址的基本配置，网络拓扑图如图
（2）路由器的端口IPv6地址参数如表
（3）实现两台路由器通过IPv6地址相互通信，配置正确的IPv6地址。
知识准备
1.IPv6的优势
（1）地址空间巨大。 相比IPv4的地址空间而言，IPv6可以提供2128个地址，几乎不会被耗尽，可以满足未来网络的任何应用，比如物联网等新应用。
（2）层次化的路由设计。 IPv6地址规划和设备连接设计时，吸取了IPv4地址分配不连续带来的问题，采用了层次化的设计方法，前3位固定，第4～16位是顶级聚合，理论上，互联网骨干设备上的IPv6路由表只有213=8192条路由信息。
（3）效率高，扩展灵活。 IPv4报头长度可变，为20～60Byte。IPv6报头长度固定，为40Byte。IPv4报头包括的选项多达12个，IPv6把报头分为基本报头和扩展报头，其中基本报头中只包含选路所需要的8个基本选项，其他的功能都设计为扩展报头，这样有利于路由器的转发效率，同时可以根据新的需求设计出新的扩展报头，具有良好的扩展性。
（4）支持即插即用。 设备连接到网络中，可以通过自动配置的方式获取网络前缀和参数，并自动结合设备自身的链路地址生成IP地址，简化了网络管理。
（5）更好的安全性保障。 由于IPv6协议通过扩展报头的形式支持IPSec协议，无需借助其他安全加密设备，可以直接为上层数据提供加密和身份验证，保障数据传输的安全。
（6）引入了流标签（Flow Label）的概念。 使用IPv6新增加的Flow Label字段，加上相同的源地址和目的地址，可以标记数据包同属于某个相同的流量，业务可以根据不同的数据流进行更细的分类，实现优先级控制。比如基于流的QoS等应用，适合于对连接的服务质量有特殊要求的通信，又如音频或视频等实时数据传输。
2.IPv6报头结构 IPv6报文的整体结构分为IPv6基本报头、扩展报头和上层协议数据三部分。IPv6基本报头是必选报文头部，包含该报头的基本信息，如源IP地址、目的IP地址等；扩展报头是可选报头，可能存在0个、1个或多个，IPv6协议可以通过扩展报头实现各种丰富的功能；上层协议数据是该IPv6报文携带的上层数据，可能是ICMPv6报文、TCP报文、UDP报文或其他报文。
（1）IPv6基本报头。 IPv6基本报头的长度固定为40字节，其中包含8个字段，其报头结构如图
由于IPv4的报头功能字段过多，路由器选路时需要读取每一个字段，但往往很多字段都是空的，这样会导致转发效率低下，所以在IPv6报头去除了一些字段，增加了留标签域字段，因此IPv6报头的处理较IPv4大大简化，提高了处理效率。另外，IPv6为了更好地支持各种选项处理，提出了扩展报头的概念。IPv6基本报头字段功能如表
（2）IPv6扩展报头。 IPv6扩展报头被当作IPv6净载荷的一部分，计算在IPv6基本报头的载荷长度字段内。 IPv6扩展报头是可选报头，跟在IPv6基本报头后。其作用是取代IPv4报头中的选项字段，这样可以使得IPv6的基本报头采用固定长度设计（40 Byte），并把IPv4中的部分字段如分段字段等独立出来，设计为IPv6分段扩展报头，这样做的好处是大大提高了中间节点对IPv6数据包的转发效率。IPv6基本报头和扩展报头的下一报头字段表明了紧跟在本报头后面的是什么内容，可能是另一个扩展报头或者是高层协议，如图
3.IPv6地址格式 IPv6地址长度为128 bit，用于标识一个或一组端口。IPv6地址通常写作xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx，其中xxxx是4个十六进制数，等同于16个二进制数；8组xxxx共同组成了一个128bit的IPv6地址。一个IPv6地址由IPv6地址前缀和端口IP地址组成，IPv6地址前缀用来标识IPv6网络，端口IP地址用来标识端口。 IPv6地址的地址长度是IPv4地址长度的4倍，所以IPv4的点分十进制数表示不再适用于IPv6。IPv6一般采用十六进制表示，有三种表示方法。
（1）冒号十六进制表示法。 格式为x:x:x:x:x:x:x:x，其中每个x表示地址中的16bit，以十六进制数表示，例如ABCD:EF01:2343:9876:ABCD:EF02:3456:1234。在这种表示法中，每个x的前导0是可以省略的，例如： 2001:0DB7:0000:0024:0009:0700:200A:412A可以写作2001:DB7:0:24:9:700:200A:412A。
（2）0位压缩表示法。 在某些情况下，一个IPv6地址中间可能包含很长的一段0，可以把连续的一段0压缩为“::”。但为保证地址解析的唯一性，地址中的“::”只能出现一次，例如： FE02:0:0:0:0:0:0:1100可以写作FE01::1100； 0:0:0:0:0:0:0:1可以写作::1； 0:0:0:0:0:0:0:0可以写作::。
（3）内嵌IPv4地址表示法。 为了实现IPv4与IPv6互通，IPv4地址可以嵌入IPv6地址中，此时地址常表示为x:x:x:x:x:x:d.d.d.d，前96bit采用冒号十六进制表示，而后32bit地址则使用IPv4的点分十进制表示，例如“::192.168.1.11”与“::FFFF:192.168.1.11”就是两个典型的例子。注意在前96bit中，0压缩表示法依旧适用。
4.关键技术命令格式
（1）在系统视图下开启设备的IPv6功能。
（2）在端口视图开启设备端口IPv6功能。
（3）在端口视图下，配置端口IPv6 EUI-64地址。
（4）查看路由器端口的IPv6地址配置信息。
（5）测试网络连通性。
任务实施
1.参照图搭建网络拓扑，连线全部使用直通线，开启所有设备电源。
2.在路由器R1上启用IPv6功能，在端口上启用IPv6功能，并配置Pv6地址。 默认情况下，路由器和路由器端口的IPv6功均未开启用，在系统视图下执行ipv6命令启用路由器的IPv6功能，在端口视图下执行ipv6 enable启用端口的IPv6功能。
3.在路由器R2上启用IPv6功能，在端口上启用IPv6功能，并配置Pv6地址。
4.在路由器R1上，使用display ipv6 interface brief命令查看端口的IPv6地址配置信息。
任务验收
测试两台路由器之间的连通性。 在路由器R1上，使用ping ipv6 3001::2命令测试两台路由器之间的连通性，结果显示通信成功。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8403c85d2486ef040a628ad8556a3071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9242b021ec979b864253015541cd7283/" rel="bookmark">
			分享从零开始学习网络设备配置--任务3.8 使用动态路由OSPF实现网络连通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务描述
某公司随着规模的不断扩大，路由器的数量在原有的基础上有所增加。网络管理员发现原有的路由协议已经不适合现有的网络环境，可实施动态路由OSPF协议配置，实现网络中所有主机之间互相通信。因为动态路由OSPF协议可以实现快速收敛，并且出现环路的可能性不大，适合中型和大型企业网络。
任务要求
（1）配置动态OSPF路由实现网络连通，网络拓扑图如图
（2）路由器和交换机的端IP地址如表
（3）每台计算机的IP地址、子网掩码和默认网关，如表
（4）实现动态路由OSPF协议配置，实现全网互通。
知识准备
1．OSPF协议概念
开放最短路径优先（Open Shortest Path First，OSPF）协议是由IETF组织开发的开放性标准协议，是目前网络中应用最广泛的路由协议之一，它是一个链路状态内部网关路由协议，运行OSPF协议的路由器会将自己拥有的链路状态信息，通过启用了OSPF协议的端口发送给其他OSPF协议设备，同一个OSPF协议区域中的每台设备都会参与链路状态信息的创建、发送、接收与转发，直到这个区域中的所有OSPF协议设备都获得了相同的链路状态信息为止。
2．OSPF协议区域 一个OSPF协议网络可以被划分成多个区城（Area）。如果一个OSPF协议网络只包含一个区域，则被称为单区域OSPF协议网络；如果一个OSPF协议网络包含多个区域，则被为多区域OSPF协议网络。 在OSPF协议网络中，每个区域都有一个编号，称为区域ID（Area ID）。区域ID是一个32位的二进制数，一般用十进制数来表示。区域ID为0的区域称为骨干区域（Backbone Area），其他区域都称为非骨干区域。单区域OSPF协议网络中只包含一个区域，这个区域是骨干区域。 在多区域OSPF协议网络中，除了骨干区域，还有若干非骨干区域，一般来说，每个非骨干区域都需要与骨干区域直连，当非骨干区域没有与骨干区域直连时，要采用虚链路（Virtual Link）技术从逻辑上实现非骨干区域与骨干区域的直连。也就是说，非骨干区域之间的通信必须通过骨干区域中转才能实现。 要创建OSPF路由进程，可以在全局命令配置模式下执行以下命令。
需要注意的是，进程号的数值范围为1～65 535，在网络中每台路由器上的进程号既可以相同也可以不同。在华为路由器中，当使用OSPF协议时，network后面跟的是直连网段和相应的反掩码。 3．链路状态及链路状态通告 OSPF 协议是一种基于链路状态的路由协议，链路状态也可以指路由器的端口状态，其核心思想是，每台路由器都将自己的各个端口的端口状态（链路状态）共享给其他路由器。在此基础上，每台路由器都可以依据自身的端口状态和其他路由器的端口状态计算去往各个目的地的路由。路由器的链路状态包含该端口的IP地址及子网掩码等信息。 链路状态通告（Link-State Advertisement，LSA）是链路状态信息的主要载体，链路状态信息主要包含在LSA中，并通过LSA的通告（泛洪）来实现共享。需要说明的是，不同类型的LSA所包含的内容、功能、通告的范围也是不同的，LSA的类型主要有Type-1 LSA（Router LSA）、Type-2 LSA（Network LSA）、Type-3 LSA（Network Summary LSA）和Type-4 LSA（ASBR Summary LSA）等。由于本书的知识范围限制，因此不对LSA的类型做详细阐述。
任务实施
1.参照图搭建网络拓扑、在路由器上添加2SA模块于Serial1/0/0位置，路由器之间的连线使用Serial串口线，其他使用直通线、开启所有设备电源和为每一台计算机设置好相应的IP地址和子网掩码。
2.配置交换机和路由器的端口IP地址等参数。 配置交换机和路由器的端口IP地址等参数，具体的配置方法请参照本项目中任务3.5的SW3A、R1和R2的基本配置。
3.配置动态路由OSPF协议，实现全网互通。
（1）SW3A的路由配置。 SW3A上直连的网络有192.168.2.0、192.168.10.0和192.168.20.0，因此要添加如下动态路由OSPF协议。
（2）R1的路由配置。 R1上直连的网络有192.168.1.0和192.168.2.0，因此要添加如下动态路由OSPF协议。
（3）R2的路由配置。 R2上直连的网络有192.168.0.0和192.168.1.0，因此要添加如下动态路由OSPF协议。
任务验收
1.在R1上，使用display ip routing-table protocol ospf命令查看OSPF路由信息。
2.在R2上，使用display ip routing-table protocol ospf命令查看OSPF路由信息。
3.使用PC1去ping PC2和PC3的IP地址，可以看到是通的。
任务小结
（1）使用动态路由OSPF协议在申明直连网段时，使用该网段的反掩码。
（2）先指明网段所属的区域，再宣告直连网段。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b52e6953b72110fb612bc76b34424c1/" rel="bookmark">
			NVIDIA终端显示从OFF变on
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入
sudo nvidia-smi -pm 1 再次查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f03a63c59e970758b60d30f48444ce21/" rel="bookmark">
			CMake报错处理：Could not find a package configuration file provided by “QT“ with any of
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天使用cmake来管理qt项目，遇到一些报错，在此记录一下
目录
1. Qtcreator创建cmake类型的控制台程序
2.使用Cmake-gui构建vs2012项目
2.1 创建build构建目录
2.2 CMake-gui构建
2.3 报错
（1）解决办法1
（2）解决办法2
1. Qtcreator创建cmake类型的控制台程序 我安装的qt市6.4.1和6.5.0版本
使用MSVC2019编译器
由于本机没有安装msvc2019编译器，导致项目出现问题
切换编译器
切换后程序正常执行
2.使用Cmake-gui构建vs2012项目 2.1 创建build构建目录 2.2 CMake-gui构建 2.3 报错 报错提示内如下：
通过错误显示找不到以下cmake文件
Qt6Config.cmake
qt6-config.cmake
Qt5Config.cmake
qt5-config.cmake
解决办法也给出来了，我安装的qt6，所以只需要查找Qt6Config.cmake 或者
qt6-config.cmake所在路径
qt6-config.cmake找不到
Qt6Config.cmake查找到了，查找对应编译器为 C:\Qt\6.5.0\mingw_64\lib\cmake\Qt6
（1）解决办法1 CMAKE_PREFIX_PATH中添加路径C:\Qt\6.5.0\mingw_64\lib\cmake\Qt6
编译OK，生成了vs2012项目工程
（2）解决办法2 QT_DIR和Qt6_DI设置C:\Qt\6.5.0\mingw_64\lib\cmake\Qt6
生成OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7417839fa1deb496e5b447c174d456c1/" rel="bookmark">
			如何RocketMQ保障消息不丢失、不重复消费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在分布式系统开发中，消息队列成为了不可或缺的一部分，用于解耦、异步处理以及保证数据可靠传输。Apache RocketMQ 作为一个高性能、低延迟的分布式消息中间件，具备了在大规模系统中处理消息的能力。然而，即使在高性能的基础上，如何保证消息不丢失和不重复消费仍然是一个需要认真对待的问题。 为什么消息会丢失或重复消费？ 在探讨如何解决消息丢失和重复消费的问题之前，我们先来了解一下造成这些问题的原因。 消息丢失 可能由于多种原因引起，比如消息发送时网络异常、消息写入磁盘失败、消息队列宕机等。这些情况可能导致消息在传输过程中丢失，从而造成数据不一致的问题。 消息重复消费 则可能因为消费端在处理消息时发生异常，导致消费状态无法正确地反馈给消息队列。这时，消息队列无法判断该消息是否被成功消费，就会重新将该消息投递给消费端，从而导致消息重复消费。 如何保证消息不丢失？ RocketMQ 提供了多种机制来保证消息的不丢失： 1、同步刷盘机制：RocketMQ 支持同步刷盘，即在消息写入磁盘之前，会等待数据写入 磁盘完成后再返回成功。这样可以保证消息在发送时已经持久化到磁盘上，避免了因为写入失败而导致消息丢失的问题。 2、异步复制机制：RocketMQ 使用主从架构，支持消息的异步复制。消息首先发送到主 节点，主节点将消息写入磁盘后，异步地将消息复制到从节点。即使主节点发生故障，消息仍然可以从从节点获取，保证了消息的高可用性和不丢失性。 3、高可用部署：通过将 RocketMQ 部署在多个节点上，可以实现高可用性。如果某个节 点发生故障，消息仍然可以通过其他节点进行处理，避免了单点故障导致的消息丢失问题。 如何保证消息不重复消费？ RocketMQ 通过以下方式来保证消息不重复消费： 1、消息消费确认机制：消费端在处理消息后，需要向 RocketMQ 发送消费确认。RocketMQ 会记录消费状态，如果消费成功，则标记该消息已被消费。如果消费端由于异常崩溃等原因未能发送消费确认，RocketMQ 会重新将消息投递给消费端，确保消息被正确消费。 2、消费端幂等性设计：为了应对消费端处理消息时的异常情况，需要设计消费端的业务逻辑具备幂等性。即使同一条消息被消费多次，也不会对系统产生副作用。这可以通过在消费端使用唯一标识(消息ID)来实现，比如数据库表的唯一索引、分布式锁等。 示例代码演示 下面是一个简单的示例代码，展示了如何使用 RocketMQ 保证消息不丢失和不重复消费的机制。 public class RocketMQDemo { public static void main(String[] args) throws MQClientException { // 创建生产者 DefaultMQProducer producer = new DefaultMQProducer("producer_group"); producer.setNamesrvAddr("127.0.0.1:9876"); producer.start(); // 创建消息 Message message = new Message("topic", "tag", "Hello, RocketMQ!".getBytes()); try { // 发送消息 SendResult sendResult = producer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7417839fa1deb496e5b447c174d456c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33eaadf5103e9bb7d5ad2835f14e9982/" rel="bookmark">
			Unity 通过DOFade 实现Image 闪烁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 private void Update() { if (image.color.a &lt;= 0.01) { image.DOFade(1, 1f); } else if (image.color.a &gt;= 0.99) { image.DOFade(0, 1f); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4428a1ccea7af89a763152be71a7bee1/" rel="bookmark">
			Matlab学习03|exist
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、exist函数 exist主要有两种形式，一个参数和两个参数的，作用都是用于确定某值是否存在：
1. r = exist( a)
若 a 存在，则 r = 1； 否则 r = 0；
2. r = exist( 'name', 'kind')
name 可以是变量名，函数名、m 文件名、mex 文件、dll 文件、内嵌的函数、p码文件、目录、路径、Java class
kind 表示 name 的类型，可以取的值为：builtin（内建类型），class（类），dir（文件夹），file（文件或文件夹），var（变量）。
返回值的含义如下：
二、reshpe函数 1、语法
2、实例
三、~ 参考：MATLAB的21种特殊符号，总有一种你不知道的用法 - 知乎
四、 array2table函数 array2table(A)把数组/矩阵A同构（不改变原来的结构）成表的格式。
语法：
①T = array2table(A) m×n 数组 A 转换为 m×n 表 T，表名会有默认值。
②T = array2table(A,Name,Value)，Name指明为哪个参数命名，可取值RowNames（行名）、VariableNames（列名）、DimensionNames（维度名），Value设定具体的行名/列名/维度名。
&gt;&gt; A = [1 4 7; 2 5 8; 3 6 9] A = 1 4 7 2 5 8 3 6 9 &gt;&gt; T = array2table(A) T = 3×3 table A1 A2 A3 __ __ __ 1 4 7 2 5 8 3 6 9 &gt;&gt; T = array2table(A,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4428a1ccea7af89a763152be71a7bee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca9f406e006b9893455168a3e599263/" rel="bookmark">
			网页&#43;springBoot&#43;websocket程序实现远程执行shell文件并打印日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
我们只有几个服务器程序有权限，但是现在策划也想看那个文件输出。
一个同学使用SpringBoot实现一个文件内容变化的监听，并把数据输出到：html网页中。
同时，使用websocket与SpringBoot建立连接，从而可以发送命令到SpringBoot，然后执行特定路径下的Shell脚本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86010bef4a6ef11b6a07ba939578237f/" rel="bookmark">
			多线程《1》JMM基础知识---volatile的可见性和一致性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JMM 引出线程的不可见性jmm的八个原子性操作volatile 可见性volatile 实现顺序一致性 前言： jvm是java虚拟机用于解释，编译执行java代码，jvm可以再不同的操作系统上执行并且提供了内存管理，垃圾回收等 jmm是java中多线程对于内存共享的行为规范，规定了在多线程环境下如何正确的使用共享变量，jmm定义了变量的可见性，原子性和有序性等特征， 引出线程的不可见性 众所周知，电脑只会有一个主内存和多个cpu，多个cpu想拿到主内存的数据，并不是直接去访问主内存的，需要通过cpu缓存去拿主内存的数据
图下所示：
java多线程的内存标准和cpu缓存模型类似，是基于cpu缓存模型建立的如下图所示：主内存中存储的是isflag=true，每一个线程的工作内存会生成一个副本isflag=true如果线程1修改了值变为了isfalg=fase，那么他修改的对于另外一个线程是不可见的，另外一个线程取的是工作内存中的值线程1的工作内存是isflag=false 线程2的工作内存中的值是isflag==true，线程之间是不可见的
代码演示 public class VolatileThread extends Thread{ public boolean isflag=true; //public volatile boolean isflag=true; @Override public void run() { System.out.println(Thread.currentThread().getName()+"子线程开始执行..."); while (isflag) { } System.out.println(Thread.currentThread().getName()+"子线程执行结束..."); } public void setRuning(boolean isflag) { System.out.println("修改值"); this.isflag = isflag; } } public class ThreadVolatile { public static void main(String[] args) throws InterruptedException { //实例化 VolatileThread volatileThread=new VolatileThread(); //启动线程 volatileThread.start(); Thread.sleep(3000); //睡眠3s后，main线程调用修改状态的方法 volatileThread.setRuning(false); } } 线程1初始值是true，然后顺利的进入的死循环，然后 volatileThread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86010bef4a6ef11b6a07ba939578237f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/170fef4d89b7c20bd954164a3f0ce9c2/" rel="bookmark">
			iOS日常问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、iOS8集成极光推送造成应用闪退问题，报错如下,把UserNotifications.framework的status状态改为Optional可选即可。
dyld: Library not loaded: /System/Library/Frameworks/UserNotifications.framework/UserNotifications Referenced from: /var/containers/Bundle/Application/********-****-****-****-************/****.app/**** Reason: image not found 2、iOS导航条隐藏后无法支持手势侧滑
&lt;UIGestureRecognizerDelegate,UINavigationControllerDelegate&gt; - (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:NO]; self.navigationController.interactivePopGestureRecognizer.delegate = self; self.navigationController.interactivePopGestureRecognizer.enabled = YES; self.navigationController.delegate=self; } 这样解决后发现导航根视图侧滑后页面跳转错乱，解决办法是在跟视图关闭手势
- (void)navigationController:(UINavigationController *)navigationController didShowViewController:(UIViewController *)viewController animated:(BOOL)animated { if (viewController == navigationController.viewControllers[0]) { navigationController.interactivePopGestureRecognizer.enabled = NO; }else { navigationController.interactivePopGestureRecognizer.enabled = YES; } } 导航侧滑手势监听，包含WKWebView设置setAllowsBackForwardNavigationGestures手势返回事件监听
-(BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{ return YES; } 3、AFNetwork错误解析
NSDictionary * errorInfo = error.userInfo; if ([[errorInfo allKeys] containsObject: @"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/170fef4d89b7c20bd954164a3f0ce9c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/931059c231eec7d0c928caa2c633226b/" rel="bookmark">
			Spring MVC 之 Restful 风格请求⽀持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tips：
REST⻛格请求是什么样的？SpringMVC对REST⻛格请求到底提供了怎样的⽀持
在 Web 系统中，前端通过 HTTP 请求给后端传递参数有四种方式，可以将参数放在请求路径、Query 参数、HTTP 协议头、HTTP 协议体中。而放在协议体中的参数又有很多格式，比如 json、form 表单等。当然，前端也可能选择其他协议，比如 Websocket、gRPC-Web 等，具体的参数形式跟 HTTP 又不一样。更多前后端请求和响应参数解析可以看我这篇文章：相关常见的http请求参数和响应参数，前后端交互参数说明。面对这么多种技术实现方式，当我们要设计一套 Web 系统时，该如何选择呢？ 文章目录 RESTful 解决什么问题？什么是 RESTfulRestful 的优点Restful 的特性 RESTful 的示例RESTful 请求规范参考 RESTful 解决什么问题？ 首先，我们来看下三个时间点：
1991 年 HTTP 0.9 诞生1996 年 5 月 HTTP 1.0 诞生1997 年 1 月 HTTP 1.1 诞生 在 HTTP 1.0 出现以前，也就是 HTTP 0.9 时代，HTTP 协议只支持 GET 请求，所有参数只能通过 URL 传递。比如一个获取动态网页的请求可能是这样的 GET /index.php?pageNum=1&amp;pageSize=10&amp;user=共饮一杯无&amp;action=view。
在 HTTP 1.0 出现后，开始有了 POST 请求和 HEAD 请求，支持从 HTTP 协议头和协议体传参数。但 HTTP 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/931059c231eec7d0c928caa2c633226b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ac72fd276a97883f1944e16f2df9bb/" rel="bookmark">
			el-upload上传文件（vue2，Element中的 el-upload文件上传）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：el-upload是一个基于Element UI的上传组件，大家应该都知道，它可以方便地实现文件上传功能，今天来记录下如何（在vue2中）使用el-upload上传文件。 1、首先，我们想要使用el-upload，就需要在项目中安装Element UI依赖，可以通过npm安装，然后使用全局引入或局部引入，确保项目中可以使用该组件，这里就不多介绍； npm install element-ui --save 或者 npm install element-ui 2、安装完成后，在main.js中全局引入使用； import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(ElementUI) 局部引入，在这里： 局部引入https://element.eleme.cn/#/zh-CN/component/quickstart
3、然后可以再在Vue组件中，直接使用，下面是el-upload组件的一个使用实例； &lt;el-upload class="upload-demo" ref="upload" :action="upload_url" :show-file-list="false" :auto-upload="true" :headers="headers" :on-success="handleSuccess" &gt; &lt;el-button slot="trigger" size="small" type="primary" &gt;上传文件&lt;/el-button&gt; &lt;/el-upload&gt; :action="upload_url"	//上传地址 :show-file-list="false"	//不显示上传列表 :headers="headers"	//token :auto-upload="true"	//选取文件后立即进行上传 :on-success="handleSuccess"	//上传事件 //在data中配置相关属性 return { // 上传文件的请求头 headers: {}, // 上传文件的请求地址 upload_url: process.env.VUE_APP_BASE_API + "/file/upload", }, //在created函数中获取请求头 created() { const Authorization = store.getters.access_token // console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89ac72fd276a97883f1944e16f2df9bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b9f246bd01711200925755c3a9a93d/" rel="bookmark">
			C# wpf 使用ffplay实现视频播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffplay自定义系列 第一章 自定义播放器接口
第二章 倍速播放
第三章 dxva2硬解渲染
第四章 提供C#接口
第五章 制作wpf播放器(本章)
文章目录 ffplay自定义系列前言一、播放模块二、界面1、关键实现(1)、圆角边框(2)、拖动移动调整大小(3)、播放(4)、停止(4)、进度条(5)、关闭播放 2、效果预览 三、下载总结 前言 有了《WPF视频渲染系列》的视频渲染方法，再结合笔者已有的一个定制化ffplay播放器《基于ffplay改造成自定义多开播放器》，我们可以很容易的在wpf中实现一个播放器软件，这个播放器可以支持本地播放、摄像头播放、网络点播、rtmp和rtsp拉流。
一、播放模块 参考第四章 提供C#接口
二、界面 由于使用wpf制作界面所以很多酷炫的效果都可以做，界面可以做的比较好看。
1、关键实现 (1)、圆角边框 圆角边框需要设置窗口透明，如果使用AllowsTransparency=“True”,会严重影响性能，可能导致渲染视频卡顿。我使用的是WindowChrome.WindowChrome实现圆角边框。具体代码就不贴出了，网上可以找到解决方案。
还有一个关键点是不能使用窗口阴影，会影响d3dImage渲染性能。
(2)、拖动移动调整大小 由于使用了WindowChrome.WindowChrome实现无边框圆角窗口，所有移动和调整大小功能基本要自己实现了。参考《C# wpf 附加属性实现任意控件（包括窗口）拖动》、《C# wpf 附加属性实现任意控件拖动调整大小》
(3)、播放 由于在界面上渲染视频，且播放中再次Start内部会先调用Stop,Stop是同步实现的，在渲染或停止事件有Invoke时停止容易造成死锁，所以需要判断播放中时异步Stop后再Start。
async void StartPlay(string url) { if (_isStarted) { await Task.Run(() =&gt; { _play.Stop(); }); _play.Start(url); _isStarted = true; } else { _play.Start(url); _isStarted = true; } } (4)、停止 与上面相同，停止的时候需要异步停止。
private async void Stop_Button_Click(object sender, RoutedEventArgs e) { await Task.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b9f246bd01711200925755c3a9a93d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7893ed5844c87bced41a21a88030f838/" rel="bookmark">
			防火墙如何处理nat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思维导图 防火墙实验 1）实验拓扑图 2）相关配置 防火墙配置
[FW-GigabitEthernet0/0/0]ip add 192.168.219.100 24 [FW-GigabitEthernet0/0/0]service-manage all permit 下联内网： 服务器： 连接公网
配置相关IP 创建策略：
测试：
做nat并且放开流量：
测试外网：
什么是防火墙 防火墙（Firewall）是一种网络安全设备或软件，用于保护计算机网络免受未经授权的访问、恶意攻击和不良网络流量的影响。它是网络安全的重要组成部分，通常位于网络的边界或内部，用于监视、过滤和控制网络流量的流入和流出。
防火墙的主要功能包括：
1）包过滤：防火墙会检查传入和传出网络的数据包，并根据预定义的规则来允许或阻止特定类型的数据流量。这些规则通常基于协议、端口、IP地址和应用程序等因素。
2）状态检测：防火墙可以跟踪网络连接的状态，以确保只有合法的连接被建立和维护。这有助于防止未经授权的访问和网络扫描攻击。
3）NAT（网络地址转换）：防火墙可以执行NAT，将内部网络上的多个设备映射到单个公共IP地址，从而隐藏了内部网络的拓扑结构，并增加了网络安全性。
4）应用程序过滤：一些高级防火墙可以检测和控制特定应用程序或服务的访问，以增强网络安全性和管理。
5）VPN支持：防火墙可以提供虚拟专用网络（VPN）功能，允许安全地连接到远程网络或通过加密通信保护数据传输。
6）报告和日志记录：防火墙通常记录网络活动，以便管理员可以审查日志并检测潜在的安全威胁。
防火墙有多种类型，包括网络层防火墙、应用层防火墙、代理防火墙等，它们各自具有不同的特点和用途。防火墙在保护网络免受恶意入侵和数据泄漏方面发挥着关键作用，是维护网络安全和保护敏感信息的重要工具之一。
状态防火墙工作原理 连接建立阶段：当有计算机尝试建立与另一台计算机的网络连接时，状态防火墙会检查连接请求。这通常发生在TCP三次握手中的第一步，即SYN包的发送。防火墙会记录这个连接的相关信息，如源IP地址、目标IP地址、源端口、目标端口等。
连接跟踪：一旦连接被建立，防火墙会继续跟踪该连接的状态。它知道哪些数据包属于这个连接，并会将这些信息存储在连接跟踪表中。
规则匹配：在连接跟踪过程中，防火墙会根据预定义的规则进行匹配。这些规则可以基于协议、端口、源/目标IP地址等因素。如果一个数据包符合规则，则被允许通过；否则，它将被拒绝或丢弃。
状态检查：防火墙还会检查连接的状态，以确保它仍然有效。例如，它会检查数据包是否符合连接的顺序，以防止连接重放攻击或连接中断。如果连接状态不正常，防火墙可以拒绝与之相关的数据包。
连接终止：当连接结束时，防火墙将从连接跟踪表中删除相关的信息，以释放资源。
防火墙如何处理双通道协议 防火墙处理双通道协议时需要特殊的考虑和配置，因为这些协议通常涉及到两个方向的数据流动，而传统的单向防火墙规则可能无法有效地处理它们。
以下是防火墙如何处理双通道协议的一般原则：
应用层检查：防火墙可以使用应用层代理或深度包检查技术来检查双通道协议的应用层数据。这种方式允许防火墙理解协议内部的命令和响应，并能够基于应用层的内容进行过滤和控制。
动态端口分配：某些双通道协议在通信过程中动态地分配端口，这增加了配置防火墙规则的复杂性。防火墙需要允许相关端口范围上的流量，同时限制访问其他不必要的端口。这可以通过设置动态端口范围的规则来实现。
连接状态跟踪：像状态防火墙一样，双通道协议的连接状态需要被跟踪。这意味着防火墙需要维护连接表，以便在双通道协议的不同阶段允许或拒绝相关数据流。
应用层代理：一些双通道协议可能需要应用层代理来有效地处理。防火墙可以充当代理，解析协议的请求和响应，并在代理层面进行过滤和检查。这允许防火墙深入理解协议的内容，而不仅仅是传输层的信息。
加密协议处理：对于使用加密的双通道协议，防火墙可能需要支持解密和重新加密流量以进行检查。这可能需要协调与SSL/TLS等加密协议的解密和证书管理。
日志和审计：双通道协议的处理通常需要详细的日志和审计，以便跟踪和分析通信。防火墙应配置为记录相关的协议操作和事件，以便在需要时进行审查。
防火墙如何处理nat 防火墙处理网络地址转换（Network Address Translation，NAT）时，主要是为了实现内部网络和外部网络之间的通信，并同时增强网络安全性。
以下是防火墙如何处理NAT的一般原则：
出站NAT（SNAT - Source NAT）：防火墙可以配置为执行出站NAT。这意味着当内部设备尝试与外部网络通信时，防火墙会将内部设备的私有IP地址映射为防火墙的公共IP地址。这有助于隐藏内部网络的拓扑结构，并提供了一定程度的匿名性。
入站NAT（DNAT - Destination NAT）：防火墙还可以配置为执行入站NAT。这允许外部网络访问防火墙的公共IP地址，而防火墙将流量重定向到内部网络中的特定设备。这对于托管多个服务或服务器的情况非常有用，可以通过不同的端口或协议将流量路由到正确的内部设备。
端口映射：防火墙可以执行端口映射，将外部网络上的特定端口映射到内部设备的特定端口。这使得多个内部服务可以共享相同的公共IP地址，同时保持唯一的端口映射。
状态跟踪：防火墙需要跟踪NAT会话状态，以确保响应流量正确地映射回内部设备。这通常涉及将出站和入站流量的状态记录在NAT表中，以确保数据包按照正确的顺序返回。
双向通信：防火墙需要允许出站流量和与之相关的入站响应流量。这涉及到维护NAT状态信息，以确保入站响应正确地映射回发起请求的内部设备。
动态NAT和静态NAT：防火墙可以配置为执行动态NAT，其中内部设备使用内部IP地址，但由防火墙动态选择可用的公共IP地址。另外，防火墙也可以配置为执行静态NAT，其中每个内部设备都被映射到一个特定的公共IP地址。
日志和审计：防火墙应该记录NAT操作，以便审查和跟踪网络活动。这有助于监视和分析流量，同时检测潜在的安全问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d82b0fb804ca47eab67dd9c598cc700/" rel="bookmark">
			PermissionError: [Errno 13] Permission denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：权限错误，权限被拒绝
解决方法：
1.设置文件夹权限为完全控制：
2.检查是否是打开了文件夹。
3.修改cmd的权限，以管理员身份运行。
4.检查对应路径下的文件是否存在，是否被占用。
-------------------------更新----------------------------
5.放在C盘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc6cd26244a98eef89746d95011d487/" rel="bookmark">
			项目中接入 micro-app---微前端基座应用和子应用之间的数据通信(详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.npm i @micro-zoe/micro-app --save
2.在入口文件 main.ts 中引入
import microApp from '@micro-zoe/micro-app'
microApp.start()
异步函数importModule来导入图标字体样式表，避免可能的样式冲突。
之后判断是否在微信小程序基座下运行。如果不在基座下运行则导入模块。如果在基座下运行，则会添加一个数据监听器，监听基座下发的数据变化。当数据中的path字段发生变化时（即用户可能需要跳转到新的页面），就会通过router.push方法进行页面跳转。
async function importModule() {
const module = await import('./iconfont/iconfont.css');
return module;
}
let oldPath = null;
if (!window.__MICRO_APP_BASE_ROUTE__) {
importModule();
} else {
// 监听基座下发的数据变化
window.microApp.addDataListener((data) =&gt; {
// 当基座下发跳转指令时进行跳转
if (data.path &amp;&amp; data.path !== oldPath) {
oldPath = data.path;
router.push({path:data.path, query:data.query});
}
});
}
4 路由配置
//router import { createRouter, createWebHistory, RouteRecordRaw } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc6cd26244a98eef89746d95011d487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9160f6460786af70975d6b19658d0529/" rel="bookmark">
			AIGC时代的算力基石，未来的数据平台将如何演进？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里妹导读
智能化是数字化的延伸，数据是AI的基石，AI需要借助数据更好地为社会、商业以及每一个人提供服务。基于AI的数据库将逐步演化为一站式的数据平台，这其中蕴含着巨大的商业价值。
本文根据TEDx系列演讲「AIGC时代下的客户价值」中，阿里云研究员张为题为《一站式智能数据平台的演进》主旨演讲的内容整理。
我叫张为，是阿里云数据库的一名研究员，从事AI与数据库相结合的产品研发工作。
我过去的经历和人工智能其实有过好几段交集，最早是2003年，也就是整整20年前。当时我在清华大学人工智能实验室读研究生，接触到了非常早期的人工神经网络。有个作业是用一个非常小的神经网络来拟合一个简单的函数，用于为我们机器人的控制添加灵活性。当时所做出来的神经网络只有三层几十个神经元，也就是几十个参数。用来训练神经网络的数据，大小只有几个KB。用今天的视角来看，简直不能再迷你了。今天我们常常谈论GPU算力，那时候GPU刚诞生不久，它唯一的用途就是玩游戏，所以回看当年，无论是所拥有的数据，还是我们处理数据的能力，都远远不能让我们构建出接近任何生物的智慧信息处理能力，更不要说去挑战人类的智能了。
让我们把时间拨回到今天，经历了快速发展数字化的20年，今天我们对数据的存储分析和运算的能力，已经通过云计算基础设施得到了大大的加强。随着数据的积累，以及AI算法的不断迭代演进，今天的AI模型已经开始推动各行各业从数字化升级到智能化的全面转型。
2020年，我有幸在Facebook带领团队上线了第一代支持万亿参数的大模型基础设施。从那以后我们看到超大规模的推荐模型、视觉模型，以及最近特别火热的大语言模型纷纷问世，AI模型的能力开始推动各行各业飞快地朝着智能化去演进。
智能化时代，我们用数字化基础设施收集海量数据，用AI算法分析数据，提取其中的知识，将这些知识凝聚成大模型，再用大模型来管理和分析我们的海量数据。
在AI时代，传统的数据服务基础设施，尤其是数据库将面临什么变化，会给我们带来什么样的商业机遇。同时，在这样一个可以利用AI算法来深入挖掘甚至生成数据的时代，我们又会面临什么样的挑战？这就是我今天想和大家分享的话题。
基础数据服务已经给我们今天的生活带来了巨大的便利。请大家看一下左边的例子，例如只要打开你的支付宝，它可以很清楚地回答，你去年把钱花在哪里了？
请大家再去想象这样一个场景，你想和朋友一起享受一顿晚餐，你打开手机APP,输入“有情调的意大利餐厅”。很快你就会得到几百家餐厅的信息，那么问题来了，这些餐厅真的符合你的要求吗？其中有多少仅仅是因为它符合了意大利或者情调这些关键字而被检索出来的呢？
如果我们往更深一层去想，不同的人在不同时间也会有不同的需求，比如说情人节，或是大年三十，人们对情调的要求必然不一样。今天的传统数据库不能很好地完成刚才这个任务。因为在传统数据库的背后，有一套相对固定的算法逻辑，它只能按照预定的规则和关键词搜索和筛选数据。
换句话说，它缺乏对数据深度的理解。而在我们的日常生活中，从选择餐厅到预定酒店到购物、看电影，背后都隐藏着大量的数据决策过程。在这个过程中，传统数据库能力的局限性经常让人感到很不方便。在刚才的例子里，我们想象一下，你约朋友去吃饭，朋友会说好，然后会问你“去哪儿吃？”，这时你会感觉很头痛，因为寻找餐厅是一件很麻烦的事。当你使用餐厅搜索APP查找意大利餐厅，传统数据库只能基于你输入的位置、关键字，比如意大利，来列出附近所有包含该关键词的餐厅，但实际上你可能有更多的期待和要求。
比如你希望这家餐厅提供番茄海鲜口味的意大利面，或者希望餐厅氛围适合约会。这时传统的数据库就束手无策了，因为他们很难理解和搜索到番茄海鲜口味和意大利面的深层次联系。为什么？因为传统的数据库没有真正的理解需求，只是单纯的根据关键词去做匹配。所以结果很可能是这样的，你收到了50家餐厅的推荐，但其中只有两家真正符合你的需求，于是你需要花费大量的时间去翻，一个一个去浏览比对，而不是直接得到你最满意的答案。而且今天随着数据量的不断增加，这种不方便会体现的越来越明显。因为你会花越来越多的时间查询餐馆的照片和评论，这会让我们的决策变得越来越慢，越来越麻烦。无论是找餐馆还是电商购物，相信大家都有类似的感受。
随着技术的演进，人工智能已经开始渗透到各个领域，包括数据库技术，它所带来的不仅仅是技术上的进步，更重要的是一种全新的思维方式。从被动的搜索到主动的理解，这里的理解可以分成三个层次。
第一层是对数据内容的理解。对于传统数据库来说，一张餐厅的照片只是一串二进制代码，而对于AI驱动的数据库，它可以看到这张照片里的风景和蜡烛，它可以识别菜的口味，卖相，甚至感受到这家餐厅的浪漫氛围。这种对于数据内容的深度理解，让数据库不仅仅是存储和检索的工具，它开始具有了理解数据语义的能力。
第二层是理解数据的资产。在传统的数据库中，一条关于餐厅的评论可能仅仅被看作文本数据，但在AI驱动的数据库中，这条评论可以被深入挖掘，找出背后的价值。例如，当一位用户发表了一条评论说这家餐厅的牛排味道不错，但是环境有点儿吵。那么AI驱动的数据库就可以从中提取关键的信息，并结合用户的评论、照片等数据，为我们提供一个更为全面的餐厅画像。比如这家餐厅可能不太适合约会。
最后一层是理解用户的使用意图，这是AI驱动的数据库最具革命性的一点。过去，如果我们想从数据库中查询信息，我们必须使用专业的查询语言，比如SQL。但在AI驱动的世界里，我们可以直接使用自然语言向数据库提问，就好像和一位知识渊博的朋友聊天一样，可以极大降低数据库的使用门槛，让更多的人能够直接与数据互动。那么这一切是如何实现的呢？在技术层面，AI为数据库带来了一系列创新：
首先是深度学习技术，这使得数据库可以自动地识别和分类大量的非结构化数据，例如图片、视频、音频等等。例如当我们上传一张餐厅的照片，AI驱动的数据库可以自动为这张照片打上标签，比如龙虾，意大利面等等，为后期的数据检索提供便利。
其次是自然语言处理技术，这让数据库可以理解用户语言的含义，以及数据库里存放数据的含义，并为用户查询提供更准确的答案，而不再是简单粗暴的关键词匹配。从此，我们的数据库可以真正理解用户的问题，并从大量的数据中找到合适的答案。
最后，AI驱动的数据库，还具备自我学习和优化的能力，它可以根据用户的习惯持续优化查询的算法，提高检索的准确度和速度。
人工智能与数据库的结合，未来不仅能够让我们的数据库变得更加智能，也将为我们的生活所基于的数据化服务带来前所未有的便捷。随着AI技术的快速发展，数据库的智能化已经从理论探索走向了实践。这样的技术进步不仅可以改变我们的生活方式，更将为将来的数字商业带来前所未有的机遇。
智能化的数据库能够为企业带来更精准的数据决策。在传统的数据管理中，企业往往需要依赖大量的人力资源来分析和解读数据。这样的过程既费时又费力，而且常常因为主观的偏见或者是对数据处理的不当而导致决策失误。而现在，利用AI驱动的数据库，企业可以迅速准确地提取他想要的信息，能够做出更科学、更合理的决策。
大家不妨想象一下，一家时尚服饰品牌，通过智能化的数据库就可以做到实时分析全球各地的时尚趋势和消费者的反馈。通过这些数据，它可以更迅速的捕捉到新一季的流行元素，这就可以大大缩短产品的研发周期，并且确保产品能够紧跟市场潮流，得到消费者的喜爱。
再者，智能数据库可以为企业开辟全新的商业模式。在AI驱动的时代，企业不仅可以通过AI分析来优化自身的运营，同时还可将得到的知识产品化，为其他企业、商家、个人提供AI驱动的决策服务。比如一个本地生活服务平台，它可以通过智能化的数据库实时分析用户的需求、消费习惯、评价等等，从而自动帮助商家去调整服务内容，优化服务质量和价格策略。另外，这个平台还可分析用户的行为数据，发现某些服务的潜在需求，从而帮助商家推出新的服务或优化现有的服务。这样的数据分析不仅可以提高用户的满意度，同时还能够为平台和商家带来更多的收入。
智能化的数据库，还可以提高企业的运营效率。因为传统的数据管理和收集通常需要大量的人力进行数据的录入、整理和分析、清洗。这样的过程不仅耗时，而且非常容易出错。智能化的数据库可以自动帮人类完成这些工作，从而大大减轻员工负担，提高运营效率。总的来说，智能化是数字化的延伸，数据库的智能化可以将为数字化商业带来无限的机遇。它不仅可以帮助企业提高效率、降低成本，而且还可以为企业开辟新的收入来源。在这个信息爆炸的时代，掌握了数据和人工智能的企业将会站在时代的前沿，引领未来的商业竞赛。
最后我们来一起看看，智能化数据平台会面临什么样的挑战。在我们享受智能化数据平台提供的智能化服务带来的便利的同时，我们必须清醒认识到，它会伴随巨大的社会挑战。这就好比驾驶一辆高速跑车，速度快是好事儿，但是如果不系上安全带，随时都有可能发生事故。
随着智能化数据平台对数据的理解和利用的加深，AI也可以让数据变成对坏人有利的作案工具。想象一下，以前我们仅仅是姓名、住址、电话等简单信息被泄露，就已造成非常广泛的电信诈骗困扰。
大家已经看见作为AI的重要应用领域，AIGC可以用AI来生成图片、文字、音频、视频等多种类型的数据，而这仅需要少量的个人数据信息作为输入。于是，诈骗分子就可以利用AI的数据合成技术生成虚假的图片、视频、音频，用于制造假新闻、网络欺诈、虚假广告等等。这种假数据未来会急剧欺骗性，让人难以区分真假，从而达到欺骗、诈骗、造谣、恶意攻击等目的。
尽管有这些挑战，但我仍然坚信，智能化的数据平台会推动我们社会更进一步。就像火车、汽车、互联网一样，每一次的技术革命都会带来新的机遇和挑战。关键在于我们怎样把握跑车的方向盘，确保他在飞速前进的同时不会出车祸。所以我们不仅需要技术，还需要良好的规范、透明的管理并提升每个人的数据意识。这样AI带来的变革，才能够成为真正推动我们进步的力量，而不是一场不受控制的狂欢。那么面对智能化数据平台带来的种种挑战，我们该怎么做？
在这里，我提出四个观点：
1、提升数据的所有权和可追溯性。我们需要让每一条数据都有一个所有者，就好像有个家。你想象一下，你在超市买一个商品，每个商品上都会有一个条形码，会告诉你这是什么，从哪里来。我们如果把这个逻辑应用到数据上，让每条数据有一个明确的地址和归属，那么滥用数据的情况就会更易得到控制。
2、提升用户参与数据管理的程度。想象一下，如果我们能够随时了解自己的数据被谁用了、怎么用的，是不是能够安心很多？数据服务平台需要给用户这个权利，让用户可以方便查看并管理自己的数据。
3、大幅加强用户的数据安全教育。直到今天，很多人其实并不清楚数据有什么用，价值在哪里？我们需要极大增强对数据安全的教育，要反复向公众普及、告诉大家数据的重要性，让每个人都学会保护自己的数据资产，就好像保护自己的银行账户一样。
4、制定新的数据使用的合规性审查规范。这就好比制定交通规则，自从汽车被发明出来，我们就需要制定新的交通规则，驾驶员开车也要遵守这一规则。对数据使用，尤其是AI对数据的使用也是一样，我们必须制定一套新的规则，来保证数据的安全和隐私。
总的来说，虽然智能化的数据平台给我们带来了非常多的便利，但是我们确实还要面对很多挑战。畅想未来，我们能够看见，随着AI结合数据将给我们带来无限可能。想象一下，未来我们所有的行为、所有的数据都被记录在智能化的数据平台里。甚至在不久的将来，利用AIGC的技术，可以合成生动的数字人。就好像流浪地球二一样，我们甚至可以通过AI和死去的亲人进行逼真的对话。
所以我们要控制好AI，控制好对数据的使用，我的观点是，要想实现对AI的控制，最好的办法就是加强对数据的控制，这不是一件容易的事情，但我相信，以人类创造AI的智慧，一定能找到最好的解决方案！在这里我借用OpenAI CEO Sam Altman的一句话来作为结尾，We will minimize the bad and maximize the good。
抢先体验AI驱动的智能化数据库，请点击【阅读原文】，即刻开启试用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377fecd2442c1668b1600d45e55922a5/" rel="bookmark">
			k8s--架构基础--cgroup v2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux上，控制组（control groups）限制了分配给进程的资源。
kubelet和底层容器运行时需要与控制组（cgroups）进行接口交互，以实施对Pod和容器的资源管理，包括为容器化工作负载设置CPU和内存的请求和限制。
Linux中存在两个版本的控制组：cgroup v1和cgroup v2。cgroup v2是cgroup API的新一代版本。
cgroup v1是最早版本的控制组API，它提供了一种层次化的组织结构来管理进程组的资源。
它通过在/proc目录下创建一系列的虚拟文件和目录来实现资源隔离和限制。这些文件和目录包含了诸如cpu、memory、io等资源的配置和统计信息。
cgroup v2是对cgroup v1的重大改进和扩展。它提供了更灵活的资源控制机制和更强大的层次结构管理。cgroup v2通过在/sys/fs/cgroup目录下使用文件系统来组织和管理控制组。它提供了以层次结构方式组织控制组的能力，并支持更细粒度的资源控制和配置。
与cgroup v1相比，cgroup v2提供了更多的功能和灵活性，包括更细粒度的资源控制、更丰富的统计信息、更强大的层次管理等。由于其改进和扩展的特性，cgroup v2被视为当前和未来的控制组解决方案。
什么是cgroup v2 cgroup v2是Linux cgroup API的下一个版本。cgroup v2提供了一个统一的控制系统，具有增强的资源管理能力。
与cgroup v1相比，cgroup v2具有以下几个改进：
单一统一的层次结构设计更安全的子树委派给容器支持新特性，如Pressure Stall Information（压力停顿信息）提供跨多个资源的增强资源分配管理和隔离对不同类型的内存分配(网络内存、内核内存等)进行统一的记账记账非即时资源变化，例如页面缓存写回 某些Kubernetes特性专门使用cgroup v2来增强资源管理和隔离。例如，MemoryQoS特性改进了内存的QoS，并依赖于cgroup v2的基本功能。
总而言之，cgroup v2是Linux cgroup API的下一代版本，它提供了统一的控制系统和增强的资源管理功能。这些功能的改进包括设计上的改进、资源隔离和分配的增强以及支持更多类型和特性的记账。在Kubernetes中，一些特性依赖于cgroup v2以实现增强的资源管理和隔离。
“Identify cgroup version on Linux nodes” 这句话的意思是要确定Linux节点上使用的是哪个版本的cgroup（控制组）。
cgroup是Linux内核提供的一种资源管理机制，它可以用来限制和分配系统资源，如CPU、内存、磁盘等。cgroup v2 是 cgroup 的第二个版本，在功能上有一些改进和增强。
使用cgroup v2 要确定你的Linux发行版是否使用cgroup v2，默认方法是查看系统中的相关配置文件。不同发行版可能有不同的配置文件路径，一般来说，你可以尝试查找以下文件：
/proc/cgroups/sys/fs/cgroup/unified/cgroup.controllers 这些文件会显示系统中使用的cgroup版本信息。如果这些文件存在，并且显示的是cgroup v2 的相关信息，那么你的系统就使用的是cgroup v2。
另外，建议你使用默认启用和使用cgroup v2 的Linux发行版，以获得更好的支持和兼容性。
kubelet和容器运行时配置为使用systemd cgroup驱动程序。
在使用cgroup v2时，要确保kubelet和容器运行时（如Docker、containerd、cri-o等）都配置为使用systemd cgroup驱动程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377fecd2442c1668b1600d45e55922a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180315a362017066276fd580f7277751/" rel="bookmark">
			优雅全套式解决树形数据表结构的增删改查问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 在实际的开发过程，经常会使用到树形结构，我的数据库表设计一般都会有这三个字段
id(主键) parent_id（父节点编号） leaf(是否为叶子节点)
由于经常使用，故封装了一系列，全套式解决方法的工具类
构建树形结构 可以选择反射工具类hutool.ReflectUtil
import cn.hutool.core.collection.CollUtil; import java.util.ArrayList; import java.util.List; import java.util.Objects; /** * 构建树形结构工具类 * * @author xzx * @date 2022/11/20 */ public class TreeUtil { /** * 根据父节点的ID获取所有子节点 * * @param list 平级的节点列表 * @param parentId 传入的父节点ID 根节点默认0 * @return String */ public static &lt;T&gt; List&lt;T&gt; getChildPerms(List&lt;T&gt; list, int parentId) { List&lt;T&gt; returnList = new ArrayList&lt;&gt;(); //遍历每一个菜单 for (T t : list) { // 一、根据传入的某个父节点ID,遍历该父节点的所有子节点 Integer pid = ReflectUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180315a362017066276fd580f7277751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a83acf6e94f9351d71df776c4e4bf1/" rel="bookmark">
			U盘复制文件出现文件过大无法复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		convert f:/fs:ntfs f: 指U盘名称
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ec2c1aac8ea230eb60f46b01814b998/" rel="bookmark">
			学习算法第三篇之哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、什么是哈希表 二、哈希表的使用
1、有效的字母异位词（数组）
2、两个数组的交集（set）
3、两数之和（map）
4、四数之和（map）
总结
前言 卡哥的搬运工又来了，这次总结的是哈希表。
一、什么是哈希表 百度百科：哈希表是种数据结构，它可以提供快速的插入操作和查找操作。
哈希表是一种元素+索引的数据结构，哈希表的生成方式有拉链法和探测法。
哈希表一般用于查找表中是否有指定的元素，最简单的哈希表结构就是数组，然后也有set和map。
更多介绍请移步代码随想录
二、哈希表的使用 1、有效的字母异位词（数组） 1.1、问题描述
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
1.2、解题思路
因为本题中只包含小写字母，所以申请一个大小为26的数组，遍历一遍s，将出现的次数存在数组中（数组的下标就为s[i]-'a'），然后再进行遍历t，每次在数组上减去当前字母出现的次数，到最后如果全为0就说明是互为字母异位词，否则不是。
1.3、代码实现
1、循环遍历s，将每个字母出现的次数++。
2、循环遍历t，将每个字母出现的次数--。
3、判断最后的数组是否全是0。
bool isAnagram(string s, string t) { int sLen = s.size(); int tLen = t.size(); int temp[26] = {0}; //循环s，将出现的次数存入数组中 for(int i=0;i&lt;sLen;i++) { temp[s[i]-'a']++; } //循环t，减去字母出现的次数 for(int i=0;i&lt;tLen;i++) { temp[t[i]-'a']--; } //判断是否全为0 for(int i=0;i&lt;26;i++) { if(temp[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ec2c1aac8ea230eb60f46b01814b998/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d412938177ddbf098335f2cbfb3be8d/" rel="bookmark">
			oracle 根据分号分割为多个列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 oracle 没有split 函数，因此没法直接使用，但是时间上会遇到需要分割的时候，可以使用正则表达式
SELECT
REGEXP_SUBSTR(administration, '[^;]+', 1, 1) AS SKILL1,
REGEXP_SUBSTR(administration, '[^;]+', 1, 2) AS SKILL2,
REGEXP_SUBSTR(administration, '[^;]+', 1, 3) AS SKILL3,
REGEXP_SUBSTR(administration, '[^;]+', 1, 4) AS SKILL4
FROM outpbill.outp_bill_items;
REGEXP_SUBSTR 函数的具体用法可以网上看 非常好用。
administration 表的一个列 ，我这里对应的值是
执行sql之后 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aefb6489dfb6137544f8400527ef120c/" rel="bookmark">
			Flink CDC MySQL同步MySQL错误记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、启动 Flink SQL [appuser@whtpjfscpt01 flink-1.17.1]$ bin/sql-client.sh 2、新建源表 问题1：Encountered “(”
处理方法：去掉int(11)，改为int
Flink SQL&gt; CREATE TABLE `t_user` ( &gt; `uid` int(11) NOT NULL AUTO_INCREMENT COMMENT 'user id', &gt; `did` int(11) DEFAULT NULL COMMENT 'dept id', &gt; `username` varchar(14) DEFAULT NULL, &gt; `add_time` datetime DEFAULT NULL, &gt; PRIMARY KEY (`uid`) NOT ENFORCED &gt; ) WITH ( &gt; 'connector' = 'mysql-cdc', &gt; 'hostname' = '192.25.34.2', &gt; 'port' = '3306', &gt; 'username' = '*******', &gt; 'password' = '*******', &gt; 'database-name' = 'test', &gt; 'table-name' = 't_user' &gt; ); [ERROR] Could not execute SQL statement.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aefb6489dfb6137544f8400527ef120c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05471baf5d4ee12ff4a5d97cfc141df5/" rel="bookmark">
			文件blob、File、base64格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、类型简介 （1）blob类型
Blob是一种二进制数据类型，通常表示二进制文件、图片、音频或视频等媒体资源
属性名称读/写描述size只读Blob 对象中所包含数据的大小（字节）type只读一个字符串，表明该Blob对象所包含数据的MIME类型。如果类型未知，则该值为空字符串。例如 “image/png” （2）File类型
File 对象通常是用户在网页中的一个 元素上传文件返回的 FileList 对象，或者是拖放操作返回的 DataTransfer 对象，也可以在浏览器中的控制台中自己创建
属性名称读/写描述name只读返回文件的名称，由于安全原因，返回的值并不包含文件路径type只读返回 File 对象所表示文件的媒体类型（MIME），如PNG 图像是 “image/png”lastModified只读number，返回所引用文件最后修改日期，自 1970年1月1日0:00 以来的毫秒数lastModifiedDate只读Date，返回当前文件的最后修改日期,如果无法获取到文件的最后修改日期，则使用当前日期来替代size只读File 对象中所包含数据的大小（字节）webkitRelativePath只读返回 File 相关的 path 或 URL （3）base64类型
Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。编码规则：把3个字节变成4个字节；每76个字符加一个换行符；最后的结束符也要处理
2、类型转化 （1）blob 和 File 类型转换
blob 转 File blobToFile(blob, fileName) { const file = new File([blob], fileName, { type: blob.type }) return file } this.blobToFile(this.blob, '1.png') File 转 blob fileToBlob(data) { return new Promise((resolve, reject) =&gt; { const fileReader = new FileReader() fileReader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05471baf5d4ee12ff4a5d97cfc141df5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720da1c290b323ff255199245e1b2c85/" rel="bookmark">
			pycharm 中在py文件里面导入同目录下的另一个py文件出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下自己的一个解决方法：
如果直接导入不行，可以加一个. 试试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bd7b0bfc225f96818f82099d40b83d0/" rel="bookmark">
			统计计算 Monte Carlo积分和方差减少 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Monte Carlo Integration and Variance Reduction 计算期望的数学方法：
E [ g ( X ) ] = ∫ − ∞ ∞ g ( x ) f ( x ) d x E[g(X)]=\int_{-\infin}^{\infin}g(x)f(x)dx E[g(X)]=∫−∞∞​g(x)f(x)dx
Simple Monte Carlo estimator 简单MC估计量 对于单位区间上的积分：
θ ^ = ∫ 0 1 g ( x ) d x \hat \theta=\int_0^1g(x)dx θ^=∫01​g(x)dx
可以有以下估计量。
θ ^ = g m ( X ) ‾ = 1 m g ( X i ) \hat \theta=\overline{g_m(X)}=\frac{1}{m}g(X_i) θ^=gm​(X)​=m1​g(Xi​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bd7b0bfc225f96818f82099d40b83d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b20c33f2e6cee104891450700c32b3b6/" rel="bookmark">
			IDS与防火墙的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是IDS？ IDS是入侵检测系统（Intrusion Detection System）的缩写。它是一种计算机安全工具，用于监视计算机网络或系统中的活动，以便检测潜在的恶意行为或入侵尝试。IDS的主要目标是识别可能威胁网络安全的活动，并向管理员或安全团队发出警报，以便他们可以采取必要的措施来阻止入侵或应对安全威胁。
IDS通常分为两种主要类型
网络入侵检测系统（NIDS）：这些系统监视网络流量，检测异常或恶意的网络活动。NIDS通常位于网络中的关键位置，例如网络边界或内部关键服务器上。它们可以检测到例如端口扫描、恶意软件传播、未经授权的访问等网络攻击行为。
主机入侵检测系统（HIDS）：这些系统安装在单个主机或服务器上，监视主机的活动和文件系统。HIDS可以检测到主机上的异常进程、未经授权的文件访问、不寻常的系统配置更改等。它们更关注主机级别的安全。
2. IDS和防火墙有什么不同？ 功能和目标：
IDS（入侵检测系统） 的主要功能是监视网络或系统的活动，以检测潜在的恶意行为或入侵尝试。它的任务是识别已经发生或正在发生的安全事件，并生成警报，以通知管理员或安全团队。
防火墙 的主要功能是阻止未经授权的访问和网络流量进入或离开受保护的网络或系统。它通过实施访问控制规则来阻止特定类型的流量，以防止潜在的攻击者进入网络。
工作方式：
IDS 通过分析网络流量或主机活动来检测已经发生的入侵或异常行为。它关注于监视和检测，而不是主动干预网络流量。
防火墙 则主要是一个主动的安全措施，它通过筛选和阻止流量来防止不受欢迎的网络流量进入受保护的网络或系统。它有一个主动的防御角色，可以根据预定义的规则或策略拒绝或允许流量。
响应：
IDS 通常生成警报，但不主动采取措施来阻止入侵。它的目的是提供有关可能的安全威胁的信息，以便管理员可以采取适当的措施。
防火墙 具有主动的阻止能力，可以根据配置的规则主动阻止或允许特定的流量。它可以立即响应威胁并封锁不受欢迎的流量。
部署位置：
IDS 通常部署在网络内部或服务器上，以监视内部和外部的网络活动。
防火墙 通常部署在网络边界，作为第一道防线，用于过滤外部流量进入受保护的网络。
3. IDS工作原理？ 数据收集： IDS首先收集数据以进行分析。数据可以来自多个来源，包括网络流量、主机日志、操作系统事件等。这些数据用于监视网络或系统的活动。
数据分析： IDS分析收集到的数据以识别潜在的安全威胁。分析可以采用不同的技术和方法，包括：
特征匹配：IDS使用已知的攻击特征或模式来检测与这些特征匹配的活动。这通常使用事先定义的规则或签名完成，类似于病毒检测。
行为分析：一些IDS采用机器学习和行为分析来建立正常行为模型，并检测与正常行为模型不符的活动，因为这可能表示潜在的入侵。
统计分析：IDS还可以使用统计方法来检测异常模式或异常数据点，这些异常可能表明安全问题。
警报生成： 当IDS检测到可能的安全威胁或异常活动时，它会生成警报。这些警报包括与检测到的事件相关的信息，例如事件类型、时间戳、源IP地址、目标IP地址等。警报可以通过多种方式传送，例如电子邮件、短信或通过安全信息和事件管理系统（SIEM）进行记录。
响应： IDS通常不会主动采取措施来阻止入侵，但它会提供信息，以便管理员或安全团队采取适当的响应措施。这可能包括隔离受感染的系统、升级防御策略、修补漏洞或进行进一步的调查以确定入侵的范围和影响。
持续监控： IDS通常是一个持续监控的系统，它不断地分析新的数据以检测新的威胁或异常。这使得它能够及时响应新的攻击和安全漏洞。
4. IDS的主要检测方法有哪些详细说明？ 特征匹配（Signature-Based Detection）：
说明：特征匹配方法使用已知攻击的特征或模式来检测相同或类似的攻击。这些特征通常以规则或签名的形式定义，类似于病毒检测数据库。当监测到的数据与这些规则匹配时，IDS生成警报。
优点：适用于已知的攻击和恶意行为，检测精确度高。
缺点：无法检测未知攻击，需要经常更新规则库以保持有效性。
行为分析（Anomaly-Based Detection）：
说明：行为分析方法建立正常行为模型，监视系统或网络的活动，并检测与正常行为模型不符的异常行为。这可以包括不寻常的数据流量、登录尝试、系统资源使用等。
优点：可以检测未知攻击，不依赖于已知规则。
缺点：可能产生误报，需要大量的训练数据来建立准确的正常行为模型。
统计分析（Statistical-Based Detection）：
说明：统计分析方法使用统计技术来检测异常模式或异常数据点。它可以检测到与正常行为相比具有显着偏差的活动。
优点：能够检测不寻常的行为模式，可以应对一些零日攻击（Zero-Day Attacks）。
缺点：可能产生误报，需要对统计方法进行精细调整。
基于主机的检测（Host-Based Detection）：
说明：基于主机的IDS安装在单个主机或服务器上，监视主机级别的活动，包括文件系统访问、进程启动、登录尝试等。它们可以检测到主机上的异常行为。
优点：适用于监视特定主机的安全，可以提供详细的主机级别信息。
缺点：无法检测跨主机的攻击，需要在每台主机上部署。
基于网络的检测（Network-Based Detection）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b20c33f2e6cee104891450700c32b3b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d9aaa10876e67399749b22985ba5c5/" rel="bookmark">
			使用for循环输入10个数，找出其中最大数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总的来的接触学习编程还是比较早的，按自己的年龄算，刚接触的时候，也是从简单的语句开始学习，比如 for循环、if语句、do-while等，经常练习的题目也都是求各种数、素数、比较大小、水仙花数等比较经典的基础编程题。
最开始的时候都是题目给规定的数，让用for循环、do-while循环、switch循环等找到最大、最小、素数等的题目，直到后来考试，遇到一个题目是让用户输入10个数，并找出其中最大数，当时想都没想写了10个input上去....vfp编程。
N久以前自己写的代码......真是没想到，还有这样的人才.....被蠢哭了。
clear input "输入个数" to n dimension a[n] input "输入第"+alltrim(str(i))+"个数" to a[i] input "输入第"+alltrim(str(i))+"个数" to a[i] input "输入第"+alltrim(str(i))+"个数" to a[i] input "输入第"+alltrim(str(i))+"个数" to a[i] input "输入第"+alltrim(str(i))+"个数" to a[i] input "输入第"+alltrim(str(i))+"个数" to a[i] input "输入第"+alltrim(str(i))+"个数" to a[i] input "输入第"+alltrim(str(i))+"个数" to a[i] input "输入第"+alltrim(str(i))+"个数" to a[i] input "输入第"+alltrim(str(i))+"个数" to a[i] max=a[0] min=a[0] for i=1 to n-1 if min[i]&gt;max max=min[i] endif endfor ?"最大数是:",max 实际上出题本意是考察for循环和if语句的使用
clear input "输入个数" to n dimension a[n] for i=1 to n input "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27d9aaa10876e67399749b22985ba5c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04d76d2caf5299cf7bab53293e2c4c4/" rel="bookmark">
			不同数据源的数据进行比对（手写oracle数据库连接和分页）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务场景 主数据系统使用的是mysql数据库，需要访问其他系统（使用的是oracle数据库）数据库，以oracle数据库数据为基准进行对数据分组统计比对。
技术分析 由于连接的数据源并不多，因此没有把dynamic-datasource动态多数据源技术方案引入进来，这是使用的是纯原生手写oracle数据库连接并手写分页效果实现
功能实现 1、引入maven &lt;dependency&gt; &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt; &lt;version&gt;11.2.0.4&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 2、controller /** * 主数据与其他数据源比对 * @param diffQueryDTO * @return */ @PostMapping("/compareDataDiffListPage") @ApiOperation(value = "主数据与杜巴特数据比对--组织/用户-分页集合", response = DiffResultVO.class) public R&lt;DiffResultVO&gt; compareDataDiffListPage(@RequestBody DiffQueryDTO diffQueryDTO) { DiffResultVO result = iDataProcessService.compareDataDiffListPage(diffQueryDTO); return R.data(result,"主数据与杜巴特数据比对--组织/用户查询成功！"); } 模拟分页数据返回封装
@Data public class DiffResultVO { /** * 总数 */ private Integer total; /** * 分页数据 */ List&lt;DiffVO&gt; resultPage; } 分页差异数据
@Data public class DiffVO { /** * 分包商编码 */ private String manufacturerCode; /** * 分包商名称 */ private String manufacturerName; /** * 数据类型 0：组织 1：用户 */ private Integer dataType; /** * 杜巴特（数量） */ private Integer dubateCount; /** * 主数据（数量） */ private Integer maindataCount; /** * 差异数 */ private Integer diffCount; //&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;差异明细&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; /** * 组织差异infos */ private List&lt;InstitutionVO&gt; institutionDiffInfos; /** * 用户差异infos */ private List&lt;StaffVO&gt; staffDiffInfos; } 分页查询入参封装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e04d76d2caf5299cf7bab53293e2c4c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b7af6077f79efbfdf833a720094401a/" rel="bookmark">
			【ParameterizedTypeReference的用法及场景】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ParameterizedTypeReference的用法及场景 一，类的描述 超类型标记模式会捕获类信息中的泛型参数，以避免Java语言中类型擦除的限制。 关于这个类的描述，可以百度翻译一下。大概意思就是能确定返回对象的类型，而不受范型擦除的影响。
也可以参考这个文章的描述：
https://blog.csdn.net/m0_37607945/article/details/126598116
二，类的用法 场景：
当远程调用，返回的对象是范型确定的，则可以使用这个。避免了对返回对象的强转。
统一的返回类
@Data @AllArgsConstructor @NoArgsConstructor public class ResponseShow&lt;T&gt; { private String code; private String message; private T data; } 返回data的一个类型
@Data @AllArgsConstructor @NoArgsConstructor public class BackArray { private String name; } 方法比较：
package com.madorangecat.artmartxt.use.parameterized; import org.springframework.core.ParameterizedTypeReference; import org.springframework.http.HttpEntity; import org.springframework.http.HttpMethod; import org.springframework.http.ResponseEntity; import org.springframework.web.client.RestTemplate; import java.util.List; public class ParameterizedTe { /** * 为什么要使用 ParameterizedTypeReference * 举例： * 远程调用接口，接口返回的对象为一个统一的封装对象，但对象内部包装但为List的一个对象 * ResponseShow&lt;List&lt;BackArray&gt;&gt; */ private static void parameterizedTe(){ HttpEntity&lt;String&gt; request = new HttpEntity&lt;String&gt;("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b7af6077f79efbfdf833a720094401a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/959e8d2bf7c5965e1b49caff73859cb5/" rel="bookmark">
			HTML5 常用文本样式属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 font-size：字号大小 相对长度单位说明em相对于当前对象内文本的字体尺寸px像素，最常用，推荐使用 绝对长度单位说明in英寸cm厘米mm毫米pt点 font-family：字体 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体
eg: body{font-family:"华文彩云","宋体","黑体";}
font-weight：字体粗细 值描述normal默认值，定义标准的字符bold定义粗体字符bolder定义更粗的字符lighter定义更细的字符100~900（100的整数倍）定义由细到粗的字符。其中400等同于normal，700等同于bold，值越大字体越粗 font-style：字体风格 如设置斜体、倾斜或正常字体，其可用属性值如下：
值描述normal默认值，浏览器会显示标准的字体样式italic浏览器会显示斜体的字体样式oblique浏览器会显示倾斜的字体样式 其中italic和oblique都用于定义斜体，两者在显示效果上并没有本质区别，但实际工作中常使用italic
letter-spacing：字间距 字符与字符之间的空白
word-spacing：单词间距 英文单词之间的间距，对中文字符无效
line-height：行间距 常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px
text-transform：文本转换 用于控制英文字符的大小写，其可用属性值如下：
值描述none默认值，不转换capitalize首字母大写uppercase全部字符转换为大写lowercase全部字符转换为小写 text-decoration：文本装饰 用于设置文本的下划线，上划线，删除线等装饰效果。其可用属性值如下：
值描述none默认值，没有装饰underline下划线overline上划线line-through删除线 text-align：水平对齐方式 相当于html中的align对齐属性。其可用属性值如下：
值描述left默认值，左对齐right右对齐center居中对齐 text-indent：首行缩进 其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值，建议使用em作为设置单位
text-shadow：阴影效果 选择器 {text-shadow:h-shadow v-shadow blur color;}
属性描述h-shadow水平阴影的距离v-shadow垂直阴影的距离blur模糊半径color阴影颜色 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b6c1a56b7632f1d0a2bfc7cb3db922/" rel="bookmark">
			【python中ddddocr安装报错的三种解决方案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ddddocr 安装报错处理 若ddddocr安装报错，可通过以下三种途径进行安装1、python解析器中直接搜索安装：2、通过命令将自动安装符合自己电脑环境的最新 ddddocr3、如果安装速度慢，导致安装失败的，可以连接国内镜像进行安装，命令如下： 若ddddocr安装报错，可通过以下三种途径进行安装 1、python解析器中直接搜索安装： 2、通过命令将自动安装符合自己电脑环境的最新 ddddocr pip install ddddocr 3、如果安装速度慢，导致安装失败的，可以连接国内镜像进行安装，命令如下： pip install ddddocr -i https://pypi.tuna.tsinghua.edu.cn/simple/ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/83/">«</a>
	<span class="pagination__item pagination__item--current">84/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/85/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>