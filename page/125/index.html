<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fdebe1fa5715b6f8fad4a1dbf615861/" rel="bookmark">
			在windows同时安装两个idea的方法教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为近期使用jdk17，所以需要升级Idea的版本，但是我电脑之前用的Idea2018,我又不想卸载，所以想同时装两个版本的。
安装教程如下：
IDea官网：https://www.jetbrains.com.cn/idea/download/?section=windows
在官网下载.zip文件，解压
修改配置 找到bin文件夹下面的idea.properties
将Idea的配置路径放开，默认是关闭的：
在c盘用户下创建文件夹，文件件名称要与上述配置文件中的路径相对应
创建完成之后在bin下找到启动项启动下：
就可以啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78297d3ecedadde324c78f01a6899cd9/" rel="bookmark">
			SQL速通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文记录了我在阅读完SQL 教程 | 菜鸟教程和牛客网在线编程_SQL篇_非技术快速入门之后学到的全部知识点。学习完SQL后建议学习ADO或PHP MySQL
官方文档（可以用来查找date相关函数等）：MySQL :: MySQL 8.0 Reference Manual
目录
增删改合
create：增
drop、delete、truncate：删
Alter、update、SELECT INTO、INSERT INTO：改
Union：合
SQL约束
As：即alias
数据类型
SQL通用数据类型：
NULL
Select、条件
select、select top、limit
where、having
group by、order by
join
SQL主机
典型习题
增删改合 create：增 CREATE DATABASE
CREATE DATABASE database_name
CREATE TABLE
CREATE TABLE table_name
(column_name1 data_type,
column_name2 data_type,
column_name2 data_type,...);
或
CREATE TABLE 新表 AS SELECT * FROM 旧表 CREATE INDEX
用户无法看到索引，它们只能被用来加速查询
CREATE INDEX index_name
ON table_name (column_name)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78297d3ecedadde324c78f01a6899cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884c76f82dab52f3a85b1717cc2d61d1/" rel="bookmark">
			哔哩下载姬 - DownKyi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这款开源工具小编自己还是蛮喜欢的，有兴趣的小伙伴可以体验学习下。
一、简单介绍 Downkyi是一个极其便捷的开源工具，专为Bilibili视频下载而设计。它拥有一个简洁、直观的界面，操作逻辑流畅无比。Downkyi能够下载几乎所有B站视频，并将其转化为mp4格式的文件。它集成了强大的Aria下载器，使用多线程技术实现高速下载。同时，Downkyi还采用了FFmpeg工具，可以进行视频的混流、音视频的提取等操作，更加满足用户的需求。无论您是想将喜欢的视频收藏在本地观看，还是需要进行二次编辑，Downkyi都是您理想的选择。它的简易性和高效性将为您提供极致的用户体验，带来无限便利。
支持二维码登录
支持视频、番剧、剧集、电影、课程下载
支持8K、4K、HDR、杜比视界
支持AVC、HEVC、AV1视频编码
支持杜比全景声、Hi-Res无损音质
支持用户收藏夹、订阅、稍后再看、历史记录下载
支持弹幕下载、样式设置
支持字幕下载
支持封面下载
支持自定义文件命名
支持断点续传
内置Aria2c服务器，支持自定义Aria2c服务器
支持下载历史记录保存
支持av、BV互转
支持弹幕发送者查询
支持音视频分离
支持去水印
支持检查更新 ……
二、测试演示参数 演示操作系统：Windows 11
系统类型：64位
演示版本：v1.5.9
要求 .NET Framework v4.7.2 以上
三、基础演示 1、文件预览 学习文件非常小
​
2、页面预览 双击打开文件
3、启动页面 启动页面可以看到版本号
​
4、网络访问 首次启动会有网络访问权限设置，全勾选允许
​
5、主页面 登录账号可以获取更多权限，复制链接可解析链接并下载
​
6、设置 设置页面中可以根据习惯调整设置
​
设置基本属性
​
网络类别设置
​
默认视频下载设置
​
弹幕设置
​
关于页面可以查看和检查更新
​
7、解析下载 复制需要下载链接地址，先解析再下载选中项
​
8、下载中 可以全速下载
​
9、完成下载 下载完成可以进行查看
​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/884c76f82dab52f3a85b1717cc2d61d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d53295b271c1d6814190e3eec5ba11/" rel="bookmark">
			不登录微信，微信聊天记录加密的图片还能恢复吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1-6
大家是否有需要在不登录微信的情况下查看微信的图片呢？我是一个网管，和很多人交流后发现不少人都有这个需求。
但是微信中收发的图片保存为加密的DAT文件，无法直接查看。因此这里介绍一个小工具，名为《天才小网管DAT转JPG》。它可以在不登录微信的情况下将微信聊天中收到的加密DAT图片转换为普通的JPG格式。
下面是使用方法：
一、首先，在电脑的【文档】文件夹中找到名为【WeChat Files】的微信聊天数据文件夹。
二、如果找不到或者文件夹为空，说明存储路径已更改，可在电脑中搜索该文件夹，使用关键词【WeChat Files】进行搜索。
三、进入文件夹后，可以看到存储有多个微信号的文件夹，每个微信号对应一个文件夹。
四、选择需要转换图片的微信号文件夹，进入后找到【FileStorage】文件夹。
五、进入【FileStorage】文件夹后，可以看到存储有相关文件夹的说明。
六、接下来，打开名为《天才小网管DAT转JPG》的工具。
这个工具可以在这里搞到：点击获取
七、打开工具后，需要选择DAT文件的目录、转换的月份以及保存转换后的图片的文件夹。
八、如果你已经整理好很多DAT文件在一个文件夹里，就不用选择月份，以下是转换【MsgAttach】文件夹里的图片的步骤：
8.1 选择【MsgAttach】文件夹。
8.2 选择要转换的月份，因为该文件夹里的DAT文件很混乱。
8.3 选择一个文件夹保存转换后的图片。
九、最后，点击【一键转换】按钮，稍等片刻即可完成转换。
十、最后在保存目录里可以看到转换好的图片。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3253382534c97cb14eef67c4764076c2/" rel="bookmark">
			Android系统安全 — 6.2 Ethernet安卓架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. Android Ethernet架构介绍 整个Ethernet系统架构如下图所示：
以太网服务（EthernetService）的启动与注册流程；应用层调用使能ethernet功能的方法流程来分析，从应用层如何将指令一步一步传到底层kernel；底层kernel如何一步一步上报Uevent（例如网线的插拔等）给framework层实现。
由SystemServer启动的时候生成的ConnecttivityService创建，负责启动关闭wpa_supplicant,启动和关闭WifiMonitor线程，把命令下发给wpa_supplicant以及更新WIFI的状态。处理其它模块通过IWifiManager接口发送过来的远端WiFi操作。
2. Android 以太网框架主要服务及其作用 2.1 Android framework层 ConnectivityService ：ConnectivityService 是系统网络连接的管理服务，同时也是整个Android系统网络的核心。主要处理App对于网络的监听和请求，以及网络变化时候通知App；另外该服务还会处理Wifi/Telephony/Ethernet等各个网络链路的注册，与信息的更新，以及网络评测和网络评分。
NetworkPolicyManagerService：NetworkPolicyManagerService是网络策略的管理，主要是对某些App的网络数据限制以及放行等。主要通过App的Uid来限制。
NetworkManagementService：NetworkManagementService是网络管理服务。其为ConnectivityService 和其他一些部分Framework Service建立了与Netd之间的通信通道（Android N以后Framework 与 Netd之间的通信，从socket变为了Binder调用，所以framework 其他一些服务目前也是有能力获取到Netd的client端，从而与Netd进行通信的）。
NetworkStatsService：NetworkStatsService主要根据不同的iface收集上下行网络数据，并配合NetworkPolicyManagerService服务对特定的app做网络数据限制及放行。
EthernetServiceImp：主要提供接口，供App来设置和更新网络，比如静态IP，以及网络类型等等，真正工作的是EthernetTracker这个类，这个类最终通过NetworkPolicyManagerService来和Netd进行通信。
EthernetNetworkFactory：EthernetNetworkFactory是NetworkFactory的子类，从名字可以看出该类是个工厂类。主要功能是通过AsyncChannel接受来自ConnectivityService 的禁止自动连接、网络有效性（NetworkMonitor的网络检测结果）、由于网络不可上网等原因主动断开网络。同时通过NetworkAgent（网络代理，其内部也是AsyncChannel）向ConnectivityService更新网络状态NetworkInfo(断开、连接中、已连接)；更新链路配置LinkProperties（本机网口、IP、DNS以及路由信息等）；更新网络能力NetworkCapabilities（信号强度、是否收费等）。
2.2 Android native 层 Android 以太网框架Native层目前从在两套机制，一套是通过Binder调用实现，另外一套是通过socket通信。从Android的版本修改来看，Google更希望使用Binder调用，所以后面Android版本很有可能会将socket通信都换为Binder通信。
NetdNativeService：NetdNativeService 是Framework层INetd的server端，提供Framework层访问Netd。NetdNativeService是Netd进程的核心，负责Android 网络管理和控制。通过xxxController将Framework的网络配置和管理指令通过Syscall的方式传递给底层kernel。
NetlinkManager：其利用SocketListener的方式监听底层Kernel的Uevent事件，并且通过注册NetdUnsolicitedEventListener方式，将底层Uevent事件上报到Framework层，例如网线的插拔等
XXXListener：MDnsSdListener等Listener，主要通过socket监听来自Framework层的指令，以及监听底层的Uevent通过socket上报到framework层。
3.Wifi Ethernet源码 frameworks/base/core/java/android/net/ ---EthernetManager.java ---IEthernetManager.aidl ---ConnectivityManager.java ---NetworkPolicyManager.java ---NetworkAgent.java frameworks/opt/net/ethernet/java/com/android/server/ethernet/ ---EthernetService.java ---EthernetServiceImpl.java ---EthernetTracker.java ---EthernetNetworkFactory.java ---EthernetConfigStore.java frameworks/base/services/core/java/com/android/server/ ---NetworkManagementService.java ---NativeDaemonConnector.java ---NativeDaemonEvent.java ---ConnectivityService.java frameworks/base/services/core/java/com/android/server/net/ ---NetworkStatsService.java ---NetworkPolicyManagerService.java 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ba7d4d7930d34f7afe6b27b5b431f85/" rel="bookmark">
			Hadoo步骤四：安装zookepeer集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 下载文件,解压,重命名 Index of /zookeeper/zookeeper-3.8.1 (apache.org)https://downloads.apache.org/zookeeper/zookeeper-3.8.1/ [root@master servers]# tar -zxvf /export/software/apache-zookeeper-3.8.1-bin.tar.gz -C /export/servers/;mv /export/servers/apache-zookeeper-3.8.1-bin/ /export/servers/zookeeper;ls /export/servers/; 2 修改文件用户属性 [root@master servers]# chown -R hadoop:hadoop /export/servers/zookeeper; 3 编辑环境变量 (1) 编辑profile文件，让其环境变量生效 [root@master servers]# vi /etc/profile;source /etc/profile; 添加以下内容： export ZOOKEEPER_HOME=/export/servers/zookeeper export PATH=$PATH:$ZOOKEEPER_HOME/bin
(2) 编辑zoo.cfg文件，修改zookeeper参数 [root@master servers]# cd /export/servers/zookeeper/conf;mv zoo_sample.cfg zoo.cfg;vi zoo.cfg; 修改的内容: #tickTime：CS通信心跳时间
tickTime=2000 ​
#initLimit：LF初始通信时限
initLimit=5 ​
#syncLimit：LF同步通信时限
syncLimit=2
​
#dataDir：数据文件目录
dataDir=/export/servers/zookeeper/data
​
#clientPort：客户端连接端口
clientPort=2181 以下修改内容：启动日志自动清理功能
autopurge.snapRetainCount:这个参数指定了清理频率，单位是小时，需要填写一个1或更大的整数，默认是0，表示不开启自动清理
autopurge.purgeInterval 这个参数和前面的参数搭配使用，这个参数指定了需要保留的文件数目，默认是保留3个
​
# The number of snapshost to retain in dataDir
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ba7d4d7930d34f7afe6b27b5b431f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0082c2b52c0b171640df361f89f72cf/" rel="bookmark">
			Android系统安全 — 6.1 WiFi安卓架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Android Wi-Fi架构介绍 Android WiFi系统引入了wpa_supplicant，它的整个WiFi系统以wpa_supplicant为核心来定义上层用户接口和下层驱动接口。整个WiFi系统架构如下图所示：
1.1 WifiService 由SystemServer启动的时候生成的ConnecttivityService创建，负责启动关闭wpa_supplicant,启动和关闭WifiMonitor线程，把命令下发给wpa_supplicant以及更新WIFI的状态。处理其它模块通过IWifiManager接口发送过来的远端WiFi操作。
1.2 WifiMonitor 负责从wpa_supplicant接收事件通知。
1.3 wpa_supplicant 读取配置文件初始化配置参数，驱动函数让驱动scan当前所有的bssid检查扫描的参数是否和用户设置的相符如果相符，通知驱动进行权限和认证操作连上AP 1.4 Wifi驱动模块 厂商提供的source,主要进行load firware和kernel的wireless进行通信，控制硬件的GPIO和上下电，让CPU和Wifi模组之间通过sdio接口或USB接口通信
1.5 Wifi工作步骤 Wifi启动开始扫描显示扫描的AP配置AP连接AP获取IP地址上网 1.6 WIFI 模块代码 1）Wifi Settings应用程序 packages/apps/Settings/src/com/android/settings/wifi
2) Wifi Framework frameworks/base/wifi/java/android/net/wifi (UI通过android.net.wifi package 发送命给wifi.c)
frameworks/base/core/java/android/net(更高一级的网络管理)
frameworks/base/services/java/com/android/server
3) Wifi JNI frameworks/base/core/jni/android_net_wifi_Wifi.cpp
4) Wifi Hardware (wifi管理库) hardware/libhardware_legacy/wifi/wifi.c
5) Wpa_supplicant(wifi tool) external/wpa_supplicant8
(1) wpa_client (生成库libwpaclient.so)
external/wpa_supplicant_8/wpa_supplicant/src/common/wpa_ctrl.c
(2) wpa_server (生成守护进程wpa_supplicant)
external/wpa_supplicant_8/wpa_supplicant/main.c
6) Wifi kernel net/wireless drivers/wlan_xxx arch/arm/mach-xxx/wlan_pm.c
2. WifiService和wpa_supplicant启动流程 WifiService和wpa_supplicant启动流程如下图所示：
•加载wifi驱动的状态变化流程如下：
mInitialState(初始状态) | mDriverUnloadedState | mWaitForP2pDisableState | mDriverLoadingState （其中enter中调用WfiNative.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0082c2b52c0b171640df361f89f72cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e92d873026017505e54ef4ba892bbe8/" rel="bookmark">
			MySQL(89)MySQL查看触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL查看触发器 查看触发器是指查看数据库中已经存在的触发器的定义、状态和语法信息等。MySQL 中查看触发器的方法包括 SHOW TRIGGERS 语句和查询 information_schema 数据库下的 triggers 数据表等。本节将详细介绍这两种查看触发器的方法。
SHOW TRIGGERS语句查看触发器信息 在 MySQL 中，可以通过 SHOW TRIGGERS 语句来查看触发器的基本信息，语法格式如下：
SHOW TRIGGERS; 示例 1首先创建一个数据表 account，表中有两个字段，分别是 INT 类型的 accnum 和 DECIMAL 类型的 amount。SQL 语句和运行结果如下：
mysql&gt; CREATE TABLE account( -&gt; accnum INT(4), -&gt; amount DECIMAL(10,2)); Query OK, 0 rows affected (0.49 sec) 创建一个名为 trigupdate 的触发器，每次 account 表更新数据之后都向 myevent 数据表中插入一条数据。创建数据表 myevent 的 SQL 语句和运行结果如下：
mysql&gt; CREATE TABLE myevent( -&gt; id INT(11) DEFAULT NULL, -&gt; evtname CHAR(20) DEFAULT NULL); Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e92d873026017505e54ef4ba892bbe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1870d0d080005eec5be064a7f8eb4ad3/" rel="bookmark">
			ZYNQ开发板启动Qt程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 交叉编译后的Qt可执行文件拷贝到 /usr/root
ZYNQ开发板启动Qt程序前需要配置环境变量
export DISPLAY=:0.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd5bd924d00ae413cd5d7e1b85a8743e/" rel="bookmark">
			图片的base64,blob,file等格式的区别，转换以及使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.区别 Base64：Base64是一种用于表示二进制数据的文本编码方式。它将二进制数据转换为由大小写字母、数字和特殊字符组成的字符串。这样做可以方便在不支持二进制数据传输或存储的场合使用，如JSON、HTML等。
Blob：是一个代表大量二进制数据的对象，通常用于处理图片、音频、视频等文件。浏览器中的Blob对象可以通过URL.createObjectURL方法生成一个临时URL供其他API引用。
File：File对象继承自Blob对象，用于表示用户选择的或者从网络获取的文件。它包含了文件的名称、类型、修改时间等元数据，并可以作为参数传递给其他Web API进行处理。
二.相互转换 （1）base64转为blob对象：
function base64ToBlob(data) { var arr = data.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) { u8arr[n] = bstr.charCodeAt(n); } return new Blob([u8arr], { type: mime }); } （2）base64转为file对象：
// 将base64转换为文件，dataurl为base64字符串，filename为文件名（必须带后缀名，如.jpg,.png） export function dataURLtoFile (dataurl, filename) { const arr = dataurl.split(',') const mime = arr[0].match(/:(.*?);/u)[1] const bstr = atob(arr[1]) let n = bstr.length const u8arr = new Uint8Array(n) while (n--) { u8arr[n] = bstr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd5bd924d00ae413cd5d7e1b85a8743e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8437e8f39a3648902138c8812f069961/" rel="bookmark">
			pycharm远程连接linux服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开setting的project，添加解释器，选择On SSH
2、输入端口用户名密码后，选择exist，因为我已在服务器上创建好环境，只需要在本地调试代码
Local path为本地项目存放地址，Deployment path为服务器上项目存放地址，配置完成后可在Deployment下的Options中设置关闭自动上传，改用右键文件夹手动上传，需要保证可执行的py文件在本地和服务器上能对应，这里我改成只有ctrl+s保存时才上传该文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d7e7ae9503bba0bc48ce1f6a107ff8/" rel="bookmark">
			【Linux 基础】无法ping通外网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Linux 基础】无法ping通外网 ubuntu系统显示正常有线连接，能正常上网，但ping www.baidu.com无法ping通 ip显示正常： ***:~$ ifconfig ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.109.132 netmask 255.255.255.0 broadcast 192.168.109.255 inet6 fe80::4a44:6733:344b:57ed prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:00:3b:6e txqueuelen 1000 (以太网) RX packets 1458131 bytes 1640533316 (1.6 GB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 416289 bytes 25453230 (25.4 MB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d7e7ae9503bba0bc48ce1f6a107ff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd6efe0b9dfc0d89226a073ac1d1c77/" rel="bookmark">
			KEIL中调试dubug模式实时查看变量的变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keil默认是需要debug时stop才能查看变量值。需配置方可
菜单选中View-&gt;选中peiodic windows update勾起即可
勾起
即可实时更新变量变化值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dbce86e2dfef16513f8ecf9d6572fa7/" rel="bookmark">
			Linux安装MySQL8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 #1、在linux系统中通过wget命令下载 wget http://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm #2、下载完成后使用yum命令本地安装yum源 yum localinstall mysql80-community-release-el7-1.noarch.rpm #3、执行完毕后使用下面的命令检查是否安装成功 yum repolist enabled | grep "mysql.*-community.*" #4、安装服务器 yum install -y mysql-community-server 二、配置mysql 2.1、服务命令
#启动MySQL服务 systemctl start mysqld #查看服务启动状态 systemctl status mysqld #开机启动 systemctl enable mysqld #重新加载开机启动配置 systemctl daemon-reload 2.2、修改root默认密码
#查询默认密码 grep 'temporary password' /var/log/mysqld.log #登录mysql,用刚才从文件中找到的密码 mysql -uroot -p #尝试修改密码,使用下面的命令修改root用户的密码 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码'; 2.3、添加远程登陆
#创建一个能全局访问的用户root CREATE USER 'root'@'%' IDENTIFIED BY 你的密码''; #给用户授权任何远程主机都可以访问数据库 GRANT ALL PRIVILEGES ON *.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dbce86e2dfef16513f8ecf9d6572fa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1519a6959d98bd11b9784466766f76f/" rel="bookmark">
			本地搭建svn仓库 &#43; 调试svn hooks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地搭建SVN仓库 + 调试svn hooks : 文章目录 本地搭建SVN仓库 + 调试svn hooks :1. 环境准备：2. 搭建本地仓库的过程：3. 将写好的svn hooks pre-commit.bat放到hooks目录内。4. 创建仓库的本地working copy: 1. 环境准备： 需要安装TortoiseSVN客户端,可以用来搭建仓库，也可以执行svn add commit update等操作。有时直接在linux环境调试svn hooks不方便时，可以考虑此种方式。
2. 搭建本地仓库的过程： a.确保已经安装了TortoiseSVN，在想要放置仓库的地方新建一个空白文件夹。
b.在弹出的弹框中选择Create folder struction,点击确定
继续选择Start RepoBrowser,会弹出下图中的窗口，点击OK.(复制一下svn仓库地址,一会进行checkout时能用到)
到此，一个本地的SVN仓库就搭建成功了
3. 将写好的svn hooks pre-commit.bat放到hooks目录内。 （注意：svn hook在Linux环境下不需要任何后缀，但在windows环境下需要添加.bat后缀进行使用,例如pre-commit.bat） （提示：kook脚本里的svnhook.exe路径需要修改为自己本机的路径，hook起效的分支可以修改为想要进行限制提交的分支） 4. 创建仓库的本地working copy: 在本地创建一个文件夹，然后在文件夹上进行SVN checkout操作:
Repository选本地仓库的url地址(前边复制的那个)，checkout directory选刚创建的这个文件夹，点击OK.
可以发现文件夹内生成了branches tags trunk三个分支:
在branches下创建一个文件夹进行add并提交，验证pre-commit是否生效。可以发现如果提交信息中没有填写关键字，则不能进行提交。
提交信息中填写了pre-commit定义的关键字后，可以成功提交：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f34f94731523993aa9e8b0de572bc59/" rel="bookmark">
			华为远程SSH配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验拓扑图
二、实验配置详解
R1:
[Huawei]sys R1 //将路由器命名改为R1
[R1]INT G0/0/0 //进入G0/0/0接口模式
[R1-GigabitEthernet0/0/0]IP address 192.168.1.1 30 //将该接口的IP地址配置为192.168.1.1/30
配置测试验证
[R1]display ip int brief //查看端口IP情况
[R1]ping 192.168.1.2 //ping对端端口，联通成功
（以上步骤在R2上再次进行）
[R1]aaa //进入aaa（aaa为认证授权审计）
[R1-aaa]local-user yiqing password cipher huawei123 //在本地创建用户yiqing，密码为huawei123
[R1-aaa]local-user yiqing privilege level 15 //设置用户级别为15
[R1-aaa]local-user yiqing service-type ssh //设置用户登陆服务类型为ssh
[R1]ssh user yiqing authentication-type password //设置此用户登陆为密码认证
[R1]stelnet server enable //开启ssh服务
[R1]user-interface vty 0 4 //进入vty接口
[R1-ui-vty0-4]authentication-mode aaa //认证采用aaa认证
[R1-ui-vty0-4]protocol inbound ssh //vty允许ssh进行登陆
R2:
[R2]ssh client first-time enable //用来使能SSH客户端首次认证。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f34f94731523993aa9e8b0de572bc59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a7f49a5e4891ee0076d8330c55f6c8b/" rel="bookmark">
			成功解决 npm ERR! ERESOLVE could not resolve
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法 执行下面装包语句
npm i --legacy-peer-deps 错误日志 E:\kuaijie\employment-service\kj-ui&gt;npm install
npm ERR! code ERESOLVE
npm ERR! ERESOLVE could not resolve
npm ERR!
npm ERR! While resolving: html-webpack-plugin@5.5.0
npm ERR! Found: webpack@4.46.0
npm ERR! node_modules/webpack
npm ERR! peer webpack@"^4.0.0" from @intervolga/optimize-cssnano-plugin@1.0.6
npm ERR! node_modules/@intervolga/optimize-cssnano-plugin
npm ERR! @intervolga/optimize-cssnano-plugin@"^1.0.5" from @vue/cli-service@4.4.6
npm ERR! node_modules/@vue/cli-service
npm ERR! dev @vue/cli-service@"4.4.6" from the root project
npm ERR! 4 more (@vue/cli-plugin-babel, @vue/cli-plugin-eslint, ...)
npm ERR! peer webpack@"^4.0.0 || ^5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a7f49a5e4891ee0076d8330c55f6c8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f715149c26a69601ea38cf0d04eaea/" rel="bookmark">
			Hadoop步骤三:Centos7 卸载自带Openjdk 并 安装JDK19
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：卸载Openjdk(所有用户) (1) 查看jdk版本 --------------------------直接复制蓝字---------------------------------------------
[root@master ~]# java -version;
----------显示内容
openjdk version "1.8.0_242"
OpenJDK Runtime Environment (build 1.8.0_242-b08)
OpenJDK 64-Bit Server VM (build 25.242-b08, mixed mode) (2) 查看自带的jdk --------------------------直接复制蓝字---------------------------------------------
[root@master ~]# rpm -qa|grep java; (3) 删除自带的jdk --------------------------直接复制蓝字---------------------------------------------
[root@master ~]# rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.181-7.b13.el7.x86_64 python-javapackages-3.4.1-11.el7.noarch javapackages-tools-3.4.1-11.el7.noarch java-1.8.0-openjdk-1.8.0.181-7.b13.el7.x86_64 java-1.7.0-openjdk-headless-1.7.0.191-2.6.15.5.el7.x86_64 java-1.7.0-openjdk-1.7.0.191-2.6.15.5.el7.x86_64 tzdata-java-2018e-3.el7.noarch;rpm -qa|grep java; (4) 再一次查看jdk --------------------------直接复制蓝字---------------------------------------------
[root@master ~]# rpm -qa|grep java; 一搬是删干净的，没有就是删干净了 ----------------------------------------------注意------------------------------------- 比如还有剩下的，想删干净，请执行第五步 tzdata-java-2018e-3.el7.noarch (5) 使用以下命令,来删除残余的 [root@master ~]# rpm -e --nodeps XXXX文件名; 比如： rpm -e --nodeps tzdata-java-2018e-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f715149c26a69601ea38cf0d04eaea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30c0a22fb891b78879e0b8e36a08953/" rel="bookmark">
			Hadoop步骤二：设置免密码登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：ssh 安装 （1）创建hadoop用户, 设置密码 [root@localhost ~]# useradd hadoop; passwd hadoop （2） 对 hadoop 用户启用 sudo 命令 [root@master ~]# vi /etc/sudoers 添加内容
hadoop ALL=(ALL) ALL ---------------------------------文件只读无法保存的情况----------------------------------------
如果提示文件readonly（文件只读无法保存的情况），则采用强制保存命令 wq! ，即后面加上一个感叹号！
​ （3）修改hosts (所有节点) 链接master节点和slave节点关系 [root@master ~]# vi /etc/hosts;
====注释掉：就是在前面加上#
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
====添加：
master主机：
master ip(内网)
slave ip(外网)
​
slave主机
slave ip(外网)
master ip(内网) （4） 登录hadoop用户 [root@master ~]# su - hadoop; （5） 每个节点生成密钥对并把公钥发送到要免密登陆的节点上 -----------------------------（先master头节点，后slave子节点）---------------------------------------- [hadoop@master ~]# ssh-keygen -t rsa -P '';ssh-copy-id -i master;ssh-copy-id -i slave1;ssh-copy-id -i slave2; ----------------------------------------注意事项---------------------------------------------------------------------
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b30c0a22fb891b78879e0b8e36a08953/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b2614c3625d440ee5e64a6696c761a/" rel="bookmark">
			ActiveMQ、RabbitMQ、Kafka、RocketMQ消息中间件技术选型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 ActiveMQ特点和优势ActiveMQ适用场景ActiveMQ实现消息发送和接收 RabbitMQ特点和优势RabbitMQ适用场景RabbitMQ实现消息发送和接收 Kafka特点和优势Kafka适用场景Kafka实现消息发送和接收 RocketMQ特点和优势RocketMQ适用场景RocketMQ实现消息发送和接收 ActiveMQ、RabbitMQ、Kafka、RocketMQ综合比较 消息中间件是分布式系统中重要的组件之一，用于实现异步通信、解耦系统、提高系统可靠性和扩展性。在做消息中间件技术选型时，需要考虑多个因素，包括可靠性、性能、可扩展性、功能丰富性、社区支持和成本等。本文将五种流行的消息中间件技术：ActiveMQ、RabbitMQ、Kafka、RocketMQ和ZeroMQ，进行讲解。 ActiveMQ ActiveMQ是一个开源的、基于Java的消息中间件，由Apache Software Foundation开发和维护。它实现了Java Message Service (JMS) API，提供可靠的消息传递机制。ActiveMQ支持多种传输协议和消息模式，具有可靠性、高性能和可扩展性的特点。
特点和优势 可靠性：ActiveMQ提供了持久化机制，可以确保消息在发送和接收过程中的可靠性。它使用日志记录和消息存储来保证消息的可靠传递，并且支持事务处理，确保消息的一致性。
高性能：ActiveMQ使用异步消息传递和优化的网络通信协议，以实现高吞吐量和低延迟。它采用多线程处理消息，提供了高效的消息传递机制。
可扩展性：ActiveMQ支持集群和分布式部署，可以通过添加更多的消息代理节点来实现横向扩展。它还支持动态路由和负载均衡，使系统能够处理大量的并发请求。
丰富的功能：ActiveMQ提供了多种高级特性和模式，如消息持久化、消息选择器、消息过滤器、消息监听器、消息路由等。它支持点对点模式和发布/订阅模式，能够满足不同场景下的需求。
多语言支持：ActiveMQ可以与多种编程语言进行集成，包括Java、C、C++、Python等，提供了多种客户端API和协议，方便开发者使用。
ActiveMQ适用场景 企业应用集成：ActiveMQ可以用于在不同的应用程序之间进行可靠的消息传递，实现系统之间的集成和通信。
分布式系统：ActiveMQ的可扩展性和高性能使其适合用于构建大规模的分布式系统，处理大量的消息和并发请求。
异步通信：ActiveMQ的异步消息传递机制可以提高系统的响应性能，使应用程序能够以异步的方式进行通信和处理。
事件驱动架构：ActiveMQ的发布/订阅模式和消息监听器可以用于实现事件驱动的架构，将系统的各个组件解耦并实现松散耦合。
ActiveMQ实现消息发送和接收 import javax.jms.*; public class ActiveMQExample { public static void main(String[] args) { try { // 创建连接工厂 ConnectionFactory factory = new org.apache.activemq .ActiveMQConnectionFactory("tcp://localhost:61616"); // 创建连接 Connection connection = factory.createConnection(); // 启动连接 connection.start(); // 创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建目标队列 Destination destination = session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b2614c3625d440ee5e64a6696c761a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52ff477d07d6d5a1cd7373254dad450e/" rel="bookmark">
			webstrom 断点调试,小白详细步骤篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网上找了很久都是七零八落的,要么就是不够通俗易懂故作此文章记录和分享
设置debug调试 编辑器右上角点编辑配置
点击+号选js调试
url填你项目运行的url和端口,以及用于调试的浏览器
添加断点和运行测试调试 这里打上断点 点击右上角debug小虫运行并打开F12检查
这里是运行起来的状态,可以随时停止
基本上整个debug流程就是这样,其他的npm,doctor等调试也可以看自己需求去创建,这里就演示一下页面的js调试案例 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d517ca793e792b90018ccd6fb9ca7d08/" rel="bookmark">
			Flink流批一体计算（3）：FLink作业调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		架构 所有的分布式计算引擎都需要有集群的资源管理器，例如：可以把MapReduce、Spark程序运行在YARN集群中、或者是Mesos中。Flink也是一个分布式计算引擎，要运行Flink程序，也需要一个资源管理器。而学习每一种分布式计算引擎，首先需要搞清楚的就是：我们开发的分布式应用程序是如何在集群中执行的，这其中一定会涉及到与资源管理器的交互。其实，可以把资源管理看成是一个cluster的抽象。
我们来看一下Flink集群会涉及到的重要角色。
client client将编写的代码转换为程序的Dataflow，并对Dataflow进行优化，生成Dataflow Graph，再将job提交给JobManager。我们编写的Flink代码，其实主要是用来描述Flink程序在集群中应该如何执行，Flink集群当然也不是像运行编写的单机程序一样，顺序往下执行。它只会接受一个一个的Job，然后运行Job中一个个的任务。
Job Manager Job Manager其实是Flink集群的作业管理器，它负责调度、管理集群的计算资源。
Task Manager 一个集群往往由很多的Task Manager组成，Task Manager负责管理、运行具体的任务。Task Manager与Task Manager之间也是能够互相通信的。
组件
用途
实现
Flink Client
将批处理或流式应用程序编译成数据流图，然后提交给JobManager。
Command Line InterfaceREST EndpointSQL ClientPython REPLScala REPL JobManager
Flink系统的管理节点，管理所有的TaskManager，并决策用户任务在哪些Taskmanager执行。
JobManager的作业提交模式有三种
Application Mode
Per-Job Mode
Session Mode
Standalone：这是一种只需要启动JVM的模式。通过在该模式下手动设置，可以使用Docker、Docker Swarm/Compose、非本地Kubernetes和其他模型进行部署。KubernetesYARN TaskManager
Flink系统的业务执行节点，执行具体的用户任务、Flink作业。
调度 Flink通过Task Slots来定义执行资源。每个TaskManager有一到多个task slot，每个task slot 可以运行一条由多个并行task组成的流水线。 这样一条pipeline由多个连续的task组成。
每个slot能够使用的资源是固定的，例如：如果一个TaskManager上配置了3个slot，那每个slot能够使用的内存为TaskManager管理的内存的1/3。slot与slot之间并不存在内存资源上的竞争。Flink运行用户调整TaskManager的slot数量，如果slot数量为1，那表示每个任务都是在独立的JVM中执行。而如果大于1，表示多个任务运行在一个JVM中。
每个slot运行可以运行一个任务。一个JOB中如果Operator和并行度比较多，就会包含很多任务，而Flink集群中的默认配置，任务是可以共享Slot的。也就是说，一个Slot中可以运行多个任务。
client将Flink代码解析为JobGraph，并且会将一些子任务打包到一个任务中，每个任务运行在一个线程中。每一个任务都是运行在TaskManager中的Slot中。针对流式处理，Flink都会将一个完整的pipeline放在一个Slot中。
这样一个程序运行在一个有两个TaskManager、每个TaskManager有3个slot的Flink集群中。Flink并不是基于每个Operator执行实例来调度的，而是优先会将一个完整的Pipeline，调度到一个slot中。我们看到，针对此处的并行度设置，有三个slot中，都调度了完整的pipeline。
这种方式，可以提高程序运行的吞吐量。如果每一个operator并行度都以独立的线程执行，那么当线程数量较多时，线程需要不停地切换、缓存，这是会有一定开销的。
JobManager数据结构 在作业执行期间，JobManager会持续跟踪各个task，决定何时调度下一个或一组task，处理已完成的task或执行失败的情况。
JobManager 接收 JobGraph，JobGraph 是数据流的表现形式，包括算子（JobVertex）和中间结果（IntermediateDataSet）。每个算子都有诸如并行度和执行代码等属性。
我们编写的代码会转换为JobGraph。其实它也是有向无环图。既然是图结构，那就一定会有Vertex（顶点）以及Edge（边）。Flink中的JobGraph顶点就是JobVertex，它其实就是Flink中的Operator，而JobGraph的边就是IntermediateDataSet，Operator处理后的中间结果。
每个JobVertex都有自己的属性。例如：并行度、以及Operator要执行的代码。而且，为了确保每个JobVertex中的代码能够正确的在JVM中运行，每个JobGraph还得包含一组库（一堆的jar包）
而要真正在集群中运行Flink程序，需要将JobGraph转换为ExecutionGraph。其实，可以把ExecutionGraph理解为JobGraph的并行版本，或者是JobGraph的并行放大。
ExecutionGraph中的顶点为ExecutionVertex。如果某个JobVertex的并行度为50，那么在ExecutionGraph中将会有50个ExecutionVertex（顶点）。每个ExecutionVertex包含了每个任务的执行状态。ExecutionGraph中的边就是IntermediatePartition。因为每个并行度顶点对应的中间结果数据其实就是一个个的分区。
作业状态 每个ExecutionGraph都有一个与之相关的作业状态信息，用来描述当前的作业执行状态。
一次完整的执行 Flink作业刚开始会处于一个created状态，然后开始调度运行时，切换到running状态。在作业运行完后切换到finished状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d517ca793e792b90018ccd6fb9ca7d08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f21786a36860b91cde6a0ae3b55203/" rel="bookmark">
			安卓蓝牙ATT协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 ATT，Attribute Protocol，用于发现、读、写对端设备的协议(针对BLE设备)
ATT允许蓝牙远程设备（比如遥控器）作为服务端提供拥有关联值的属性集，让作为客户端的设备（比如手机、电视）来发现、读、写这些属性；同时服务端能主动通知客户端
ATT定义了两种角色: 服务端(Server)和客户端(Client)，一个设备可以同时拥有Server和Client；而一个Server可以支持多个Client。
ATT中的属性包含下面三个内容
- Attribute Type : 由UUID(Universally Unique IDentifier)来定义 - Attribute Handle : 用来访问Attribute Value - A set of Permissions : 控制是否该Attribute可读、可写、属性值是否通过加密链路发送 相关概念 Attribute Type Attribute Type由UUID唯一指定，UUID是一个128-bit值。但在使用过程中，为了提高效率，使用的是16-bits Attribute UUID，其他bit都是固定值。
128-bit UUID = 16-bit Attribute UUID*2^96 + Bluetooth_Base_UUID Bluetooth_Base_UUID = 00000000-0000-1000-8000-00805F9B34FB 更简单的办法如下(xxxx代表十六进制的16-bit UUID)
0000xxxx-0000-1000-8000-00805F9B34FB TIP: 16-bit Attribute UUIDs与SDP 16-bit UUIDs相同，参考《16-bit UUID Numbers Document.pdf》
Attribute Handle Attribute Handle是由Server分配的一个唯一且非零16-bit值，用于检索Attribute。
0x0000 : 保留 0xFFFF : 最大Attribute Handle Attribute Handle Grouping Attribute Handle Grouping是一组由高层协议定义的属性，他们位于其他属性之前。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5f21786a36860b91cde6a0ae3b55203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c563ad4b7d9bcca397dbe397f7987b4f/" rel="bookmark">
			安卓蓝牙GATT协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 现在低功耗蓝牙（BLE）连接都是建立在 GATT (Generic Attribute Profile) 协议之上。GATT 是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范，这些很短的数据段被称为属性（Attribute）。
GAP 详细介绍 GATT 之前，需要了解 GAP（Generic Access Profile），它在用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。例如 Beacon 设备就只是向外广播，不支持连接，小米手环就等设备就可以与中心设备连接。
设备角色
GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central）。
外围设备：这一般就是非常小或者简单的低功耗设备，用来提供数据，并连接到一个更加相对强大的中心设备。例如小米手环。中心设备：中心设备相对比较强大，用来连接其他外围设备。例如手机等。 广播数据 在 GAP 中外围设备通过两种方式向外广播数据： Advertising Data Payload（广播数据）和 Scan Response Data Payload（扫描回复），每种数据最长可以包含 31 byte。这里广播数据是必需的，因为外设必需不停的向外广播，让中心设备知道它的存在。扫描回复是可选的，中心设备可以向外设请求扫描回复，这里包含一些设备额外的信息，例如设备的名字。
广播流程 GAP 的广播工作流程如下图所示。
从图中我们可以清晰看出广播数据和扫描回复数据是怎么工作的。外围设备会设定一个广播间隔，每个广播间隔中，它会重新发送自己的广播数据。广播间隔越长，越省电，同时也不太容易扫描到。
广播的网络拓扑结构 大部分情况下，外设通过广播自己来让中心设备发现自己，并建立 GATT 连接，从而进行更多的数据交换。也有些情况是不需要连接的，只要外设广播自己的数据即可。用这种方式主要目的是让外围设备，把自己的信息发送给多个中心设备。因为基于 GATT 连接的方式的，只能是一个外设连接一个中心设备。使用广播这种方式最典型的应用就是苹果的 iBeacon。广播工作模式下的网络拓扑图如下：
介绍 GATT 的全名是 Generic Attribute Profile（姑且翻译成：普通属性协议），它定义两个 BLE 设备通过叫做 Service 和 Characteristic 的东西进行通信。GATT 就是使用了 ATT（Attribute Protocol）协议，ATT 协议把 Service, Characteristic遗迹对应的数据保存在一个查找表中，次查找表使用 16 bit ID 作为每一项的索引。
一旦两个设备建立起了连接，GATT 就开始起作用了，这也意味着，你必需完成前面的 GAP 协议。这里需要说明的是，GATT 连接，必需先经过 GAP 协议。实际上，我们在 Android 开发中，可以直接使用设备的 MAC 地址，发起连接，可以不经过扫描的步骤。这并不意味不需要经过 GAP，实际上在芯片级别已经给你做好了，蓝牙芯片发起连接，总是先扫描设备，扫描到了才会发起连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c563ad4b7d9bcca397dbe397f7987b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a902c709665c117ba5f400e747327a/" rel="bookmark">
			element ui Cascader 级联选择器自定义高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;el-cascader -model="value" :options="options"&gt;&lt;/el-cascader&gt; &lt;script&gt; export default { data() { return { value: [], options: [{ value: 'zhinan', label: '指南', children: [{ value: 'shejiyuanze', label: '设计原则', children: [{ value: 'yizhi', label: '一致' }, { value: 'fankui', label: '反馈' }, { value: 'xiaolv', label: '效率' }, { value: 'kekong', label: '可控' }] }, { value: 'daohang', label: '导航', children: [{ value: 'cexiangdaohang', label: '侧向导航' }, { value: 'dingbudaohang', label: '顶部导航' }] }] }, { value: 'zujian', label: '组件', children: [{ value: 'basic', label: 'Basic', children: [{ value: 'layout', label: 'Layout 布局' }, { value: 'color', label: 'Color 色彩' }, { value: 'typography', label: 'Typography 字体' }, { value: 'icon', label: 'Icon 图标' }, { value: 'button', label: 'Button 按钮' }] }, { value: 'form', label: 'Form', children: [{ value: 'radio', label: 'Radio 单选框' }, { value: 'checkbox', label: 'Checkbox 多选框' }, { value: 'input', label: 'Input 输入框' }, { value: 'input-number', label: 'InputNumber 计数器' }, { value: 'select', label: 'Select 选择器' }, { value: 'cascader', label: 'Cascader 级联选择器' }, { value: 'switch', label: 'Switch 开关' }, { value: 'slider', label: 'Slider 滑块' }, { value: 'time-picker', label: 'TimePicker 时间选择器' }, { value: 'date-picker', label: 'DatePicker 日期选择器' }, { value: 'datetime-picker', label: 'DateTimePicker 日期时间选择器' }, { value: 'upload', label: 'Upload 上传' }, { value: 'rate', label: 'Rate 评分' }, { value: 'form', label: 'Form 表单' }] }, { value: 'data', label: 'Data', children: [{ value: 'table', label: 'Table 表格' }, { value: 'tag', label: 'Tag 标签' }, { value: 'progress', label: 'Progress 进度条' }, { value: 'tree', label: 'Tree 树形控件' }, { value: 'pagination', label: 'Pagination 分页' }, { value: 'badge', label: 'Badge 标记' }] }, { value: 'notice', label: 'Notice', children: [{ value: 'alert', label: 'Alert 警告' }, { value: 'loading', label: 'Loading 加载' }, { value: 'message', label: 'Message 消息提示' }, { value: 'message-box', label: 'MessageBox 弹框' }, { value: 'notification', label: 'Notification 通知' }] }, { value: 'navigation', label: 'Navigation', children: [{ value: 'menu', label: 'NavMenu 导航菜单' }, { value: 'tabs', label: 'Tabs 标签页' }, { value: 'breadcrumb', label: 'Breadcrumb 面包屑' }, { value: 'dropdown', label: 'Dropdown 下拉菜单' }, { value: 'steps', label: 'Steps 步骤条' }] }, { value: 'others', label: 'Others', children: [{ value: 'dialog', label: 'Dialog 对话框' }, { value: 'tooltip', label: 'Tooltip 文字提示' }, { value: 'popover', label: 'Popover 弹出框' }, { value: 'card', label: 'Card 卡片' }, { value: 'carousel', label: 'Carousel 走马灯' }, { value: 'collapse', label: 'Collapse 折叠面板' }] }] }, { value: 'ziyuan', label: '资源', children: [{ value: 'axure', label: 'Axure Components' }, { value: 'sketch', label: 'Sketch Templates' }, { value: 'jiaohu', label: '组件交互文档' }] }] }; } }; &lt;/script&gt; 尝试：均不生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a902c709665c117ba5f400e747327a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1270526d28f4c7485a6b0b266524b410/" rel="bookmark">
			创建 VLAN 的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建 VLAN 的命令因设备类型和不同网络操作系统而异，以下是通用的 VLAN 创建命令示例：
Cisco IOS 设备：
进入全局配置模式：configure terminal
创建 VLAN：vlan &lt;vlan-id&gt;
配置 VLAN 名称（可选）：name &lt;vlan-name&gt;
退出 VLAN 配置：exit
保存配置：write memory
例如，创建 VLAN 10 并命名为 “Sales” 可以使用以下命令：
Copy Code
configure terminal vlan 10 name Sales exit write memory Juniper Junos 设备：
进入交换机 VLAN 配置模式：set vlans &lt;vlan-name&gt;
创建 VLAN：vlan-id &lt;vlan-id&gt;
配置 VLAN 名称（可选）：description &lt;description&gt;
退出 VLAN 配置：exit
提交配置更改：commit
例如，创建 VLAN 10 并命名为 “Sales” 可以使用以下命令：
Copy Code
set vlans Sales vlan-id 10 set vlans Sales description "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1270526d28f4c7485a6b0b266524b410/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1eeb9c2ea9cddd79fee5846cbc9549/" rel="bookmark">
			【RabbitMQ】- 死信队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 第六章 死信队列6.1. 死信的概念6.2. 死信的来源6.3. 死信实战6.3.1. 代码架构图6.3.2. 消息 TTL 过期6.3.3. 队列达到最大长度6.3.4. 消息被拒 第六章 死信队列 6.1. 死信的概念 ​ 先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。
​ 应用场景:为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说: 用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。
6.2. 死信的来源 消息 TTL 过期队列达到最大长度(队列满了，无法再添加数据到 mq 中)消息被拒绝(basic.reject 或 basic.nack)并且 requeue=false 6.3. 死信实战 6.3.1. 代码架构图 6.3.2. 消息 TTL 过期 消费者C1代码（比较难写，因为有2个交换机，2个队列）
public class Consumer01 { // 普通交换机名称 public static final String NORMAL_EXCHANGE = "normal_exchange"; // 死信交换机名称 public static final String DEAD_EXCHANGE = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1eeb9c2ea9cddd79fee5846cbc9549/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fe0b1f93ee702fadd049b0d036053af/" rel="bookmark">
			ubuntu(26): ubuntu清理vscode缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查看电脑硬盘占用，点击下面这个
然后在搜索栏输入disk
依次选按 /home/username/.config/Code/User/workspaceStorage选；可以看出有很多vscode工作空间的缓存
比如：/home/meng/.config/Code/User/workspaceStorage/0bf60f2b54f40228f0603d8ed61fc20d下面的workspace.json
内容如下，即为某个已经使用过的工作空间的缓存，可以清理，稍后再次打开会重新缓存
{ "folder": "file:///home/meng/subject/LT_mapper_ws/src/lt-mapper" } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ebaec41d14248ac52bfbc2b5a07d10/" rel="bookmark">
			python(11):python读取excel、csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.python读取excel文件 要读取Excel表格的指定行和列范围，可以使用Python中的第三方库pandas。pandas库提供了强大的数据分析和处理工具，包括读取和处理Excel文件的功能。以下是一个示例代码，演示了如何使用pandas库读取Excel表格中的指定行和列范围：
import pandas as pd # 读取Excel文件 df = pd.read_excel('path/to/excel_file.xlsx') # 指定要读取的行和列范围 start_row = 2 # 起始行（索引为0） end_row = 5 # 结束行 start_col = 'A' # 起始列 end_col = 'C' # 结束列 # 根据行和列范围提取数据 selected_data = df.loc[start_row:end_row, start_col:end_col] # 打印提取的数据 print(selected_data) 在上述代码中，你需要将 'path/to/excel_file.xlsx' 替换为你要读取的Excel文件的实际路径。代码使用 pd.read_excel 函数读取Excel文件并将其存储在一个DataFrame对象中。
然后，通过设置 start_row 和 end_row 来指定要读取的行范围，起始行索引为0。同时，使用 start_col 和 end_col 来指定要读取的列范围，以字母表示列标签。
接下来，使用 df.loc[start_row:end_row, start_col:end_col] 从DataFrame中提取指定的行和列范围的数据，并将结果存储在 selected_data 变量中。
最后，使用 print(selected_data) 打印提取的数据。
请注意，在运行代码之前，确保已经安装了pandas库。你可以使用以下命令安装pandas库：
pip install pandas 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ebaec41d14248ac52bfbc2b5a07d10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a04327d4ac5abfa12027ad4171287f/" rel="bookmark">
			Hadoop步骤一： 配置静态网络 关闭防火墙 设置主机名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 配置静态网络 关闭防火墙（所有节点） VMware安装Centos7及静态IP网络配置详细教程_vmware安装centos7网络配置_Clozzz的博客-CSDN博客
二 ：设置主机名（所有节点） （$）代码汇总 [root@localhost ~]# hostnamectl set-hostname master; reboot;clear;
[root@localhost ~]# hostnamectl set-hostname slave1; reboot;clear;
[root@localhost ~]# hostnamectl set-hostname slave2; reboot;clear; （1）修改节点主机名 [root@localhost ~]# hostnamectl set-hostname master; [root@localhost ~]# hostnamectl set-hostname slave1;
[root@localhost ~]# hostnamectl set-hostname slave2; （2）修改完节点的主机名要重启才能生效 [root@localhost ~]# reboot; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4544f530a0c65ca785a0d62fa93bec/" rel="bookmark">
			ffmpeg(一) ffmpeg&#43;QT开发环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、开发库的选择 （1）音视频开发库
每个主流平台基本都有自己的音视频开发库（API），用以处理音视频数据，比如：
iOS：AVFoundation、AudioUnit 等
Android：MediaPlayer、MediaCodec 等
Windows：DirectShow 等
但是有一个跨平台的库：FFmpeg 库。
其实只要你掌握了FFmpeg，也可以很快上手其他音视频开发库，因为底层原理都是一样的，你最终操作的都是一样的数据，比如MP3、MP4文件。
2）GUI 界面开发库 同理我们也选择可以 跨平台开发的 GUI 界面开发库，QT。
Windows：MFC 2、下载安装环境 （1）安装 ffmpeg
第一种方式：下载源码，将ffmpeg 的所有源码加入到我们的工程当中。（不推荐使用这种方法，因为源码太庞大了，并且里面有很多的代码我们是不需要的。）
下载地址：Download FFmpeg
snapshot：快照版，不是正式版本。
releases：发布版，就是正式版本，我们可以点击 release。
1、我们目前是新手，可能编译会不通过。
2、所以我们直接使用别人编译好的动态链接库。（官网就有提供编译好的动态库，体积大一点）
3、等我们技术达到之后，可以自己对源码进行裁剪，然后编译出属于自己的动态库。
第一个链接：（我是使用这个链接进行下载）
7z 、zip：压缩算法不同，压缩大小不同而已。里面的内容一样。essentials：必要的组件，东西可能不全。full：全面的，里面的库文件比较全。shared：有动态链接库。（我们选取这一个） shared ：代表里面的应用程序：ffmpeg、ffplay、ffprobe 使用的动态链接库。没有带 shared 后缀：说明不是使用动态链接库。gpl、lgpl：代表不同的开源协议。 3、将 ffmpeg 的功能集成到 QT 项目当中 在Windows中，我们最终是通过调用FFmpeg动态库（dll）中的函数来操作音视频数据，使用dll的其中一种方式是需要用到3种文件：
.h：头文件（Header File）
包含了函数的声明
通过*#include*去导入相应的头文件
.dll ：动态链接库（Dynamic Link Library）
包含了函数的具体实现代码
Windows程序会在运行过程中，动态调用dll中的函数
.lib 或 .dll.a：（动态链接库的）导入库（Import Library）
.lib：用于MSVC编译器中（微软 编译器）
.dll.a：用于MinGW编译器中（g++ 编译器）
包含了dll中函数的入口，用于辅助找到并调用dll中的函数，里面只存放索引信息。最终需要链接到Windows程序中（比如合并到exe文件中）
本质：！！！！ 是一个静态库文件，这一部分是要放到 exe 文件当中去。然后指引 exe 程序去寻找 dll 文件当中的函数体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa4544f530a0c65ca785a0d62fa93bec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f3d624e2f1e1915a59f5151cc10337/" rel="bookmark">
			基于STM32的人体测温系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 温度作为身体健康的一项重要参数，一直以来被人们长期关注。在疫情时代，温度检测对于疫情防控也是必不可少的环节。传统的测温计有反应缓慢、测量精度差、测量时间长、测温过程繁琐等缺点，因而基于单片机的人体测温系统设计与实现，在后疫情的背景下具有重要意义。
本设计在主芯片和主要元器件的选型与规格上遵从功能优先、性价比高的原则。系统选用STM32F103的最小系统板，测温传感器选取DS18B20，液晶显示部分则选用LCD1602液晶屏。系统可实现的功能包括测量精度达到±0.1℃的人体测温、预设人体正常温度区间值、检测温度值比较及蜂鸣器告警等功能。
本设计可以实现对人体的温度检测与显示，具有使用便捷，携带方便，检测快速等特点，检测人体温度仅需5秒钟，误差大小仅在±0.5℃。在后疫情时代，此次设计的温度枪具有一定的实用价值，对于疫情防控与人体健康检测有着重要意义。
关键词
STM32F103；DS18B20；温度；LCD1602
目 录 第1章 绪论 1.1 研究背景及意义 1.2 国内外现状分析 1.3 主要研究内容 第2章 硬件方案 2.1 系统总体设计 2.2 硬件简介 2.3 单片机最小系统 2.4 液晶显示 2.5 调控按键及独立按键 2.6 温度传感器模块 2.7 蜂鸣器模块 2.8 电源电路 第3章 软件设计 3.1 整体程序处理 3.2 液晶显示 3.3 按键显示 3.4 温度采集 第4章 硬件调试 第5章 总结 致谢 参考文献 附录 第1章 绪论 1.1 研究背景及意义 温度，是描述物体冷热程度的一个基本物理量。在人们的日常生产生活中，温度是一个重要的参数，温度的变化可以向人们传递着极其重要的信息，对温度的测量及监控就十分有意义了。某些行业对温度的要求较高，温度稍有变化就会产生不可弥补的后果。如食品行业的食品存储，必须保证食品保存在适宜的温湿度中；档案的管理中，纸制品对于温湿度极为敏感，在不适宜的温度中保存会严重降低档案保存年限；另外在医疗行业中，患者的身体情况也会通过温度表现出来，尤其是去年爆发疫情之后，温度的检测有更大的意义。
传统的水银测温往往所需时间久，且读取不是很方便。本文设计了一个基于STM32的人体测温系统，可以实时显示人体温度并判断是否温度异常。
1.2 国内外现状分析 中国是一个人口大国，对于温度计的需求是十分巨大的。传统的水银式测温计在疫情之前的使用量还是很多的，在中国大约有4.3亿的使用量，基本上是一家一个。但水银测温计具有易碎，读数不便捷的缺点，且水银这种重金属对人体的健康是有害的。所以人体测温度计的改革及创新具有重要的社会意义。在2020年初，新冠疫情的爆发，让医生和人们对测温计的创新要求更加迫不及待了，侧面推动了智能人体测温枪的产生和使用。目前，我国已经研发出一种体积小，成本较低，又不受外界环境温度干扰的人体红外测温仪。
国际上也有多家科技公司在智能红外测温枪领域有所研究，且可以进行一定规模的量产，著名的生产商有Keyence、Texas、Maxim等多家公司。
智能人体测温枪的原理是利用传感器获取人体温度，通过芯片和显示屏显示出人体温度。目前常用的传感器有两类，一类是红外测温传感器，另一种是数字式温度传感器。在疫情期间，我国研发的智能人体测温系统所用的传感器基本上采用的是非接触式红外测温传感器。
总体而言，我国的红外检测技术的发展起步比较晚，在2003年非典之前近乎于一片空白，在非典之后我国迅速成立了一支处理紧急情况的医疗器械队伍。在经过数年的不懈努力后，我国已经在该领域取得了一定的成果。
1.3 主要研究内容 本系统是由温度检测模式和测温区间调整模式组成，设计需要研究的内容如下：
（1）实现本系统测温的基本功能。
（2）通过液晶显示屏显示温度数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f3d624e2f1e1915a59f5151cc10337/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/168057d38a741e99a895114cf0cf72d9/" rel="bookmark">
			java&#43;selenium&#43;maven&#43;testng前端自动化步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java、Selenium、Maven和TestNG是常用的工具和框架，结合它们可以进行高效的自动化测试开发。
以下是使用Java、Selenium、Maven和TestNG进行自动化测试的一般步骤：
配置Java开发环境：
安装Java JDK，并设置JAVA_HOME环境变量。在您的IDE中配置Java项目。详情见我的另外一篇文章：https://blog.csdn.net/qq_36232967/article/details/131311314 创建Maven项目：
使用Maven创建一个新的Java项目。在项目的pom.xml文件中添加Selenium和TestNG的依赖。详情见http://t.csdn.cn/WAc95 &lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-api&lt;/artifactId&gt; &lt;version&gt;4.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.testng&lt;/groupId&gt; &lt;artifactId&gt;testng&lt;/artifactId&gt; &lt;version&gt;6.14.3&lt;/version&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt; 编写测试脚本：
使用Java编写测试脚本代码。导入Selenium相关类来实现网页操作和断言验证。使用TestNG注解编写测试方法，并添加测试逻辑。 import org.openqa.selenium.JavascriptExecutor; import org.openqa.selenium.WebDriver; import org.openqa.selenium.WebElement; import org.openqa.selenium.chrome.ChromeDriver; import org.testng.Assert; import org.testng.annotations.Test; import java.util.concurrent.TimeUnit; import static java.lang.Boolean.*; import static org.testng.Assert.assertEquals; import static org.testng.Assert.assertTrue; @Test public class webTest { public static void main(String[] args) throws InternalException { System.setProperty("webdriver.chrome.driver","D:\\chromedriver\\chromedriver.exe"); WebDriver driver= new ChromeDriver(); driver.manage().window().maximize(); driver.get("http://www.baidu.com"); // System.out.println(webDriver.getTitle()); // // webDriver.findElement(By.id("kw")).click(); // webDriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/168057d38a741e99a895114cf0cf72d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c08052a9ed505afcafdff15b9b24cf5/" rel="bookmark">
			HTTPS请求报CONNECTION RESET问题,TLS版本服务端不支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用HttpsURLconnection或者HttpURLConnection进行https请求时，有时会报Connection reset异常
原因：
这是因为客户端的TLS版本服务端不支持的原因。
对于JDK1.6，支持SSLv2、SSLv3、TLSv1，默认使用TLSv1
对于JDK1.7，支持SSLv2、SSLv3、TLSv1、TLSv1.1、TLSv1.2，默认使用TLSv1.1
对于JDK1.8，支持SSLv2、SSLv3、TLSv1、TLSv1.1、TLSv1.2，默认使用TLSv1.2
如果服务端配置的支持的SSL协议为TLSv1.2，那么默认情况下只有JDK1.8才能正常的访问.
解决：在nginx里修改网站 站点配置文件对应的TLS版本，修改为TLSv1.2。
ssl_protocols TLSv1.2.
谷歌游览器通过按F12，会跳出安全的，就可以查看当前TLS版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6282d382cc160b15b80b3a19dd85d080/" rel="bookmark">
			Ubuntu环境下超好用的文件对比工具软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据提供的信息，以下是一些在Ubuntu上使用的好用对比软件的推荐以及对应的使用方法：
1. Meld：Meld是一款基于Python开发的对比工具，它支持文件夹和文件内容的比较。你可以使用以下命令在Ubuntu上安装Meld：
```
sudo apt-get update
sudo apt-get install meld
```
安装完成后，你可以通过在终端中输入`meld`命令来启动Meld。你可以在Meld中选择两个或三个文件夹或文件进行比较，并查看它们之间的差异。
2. Nautilus Compare：Nautilus Compare是一个与BCompare相似的对比工具，它提供了右键菜单功能，使得文件和文件夹的比较更加方便。你可以按照以下步骤在Ubuntu上安装Nautilus Compare：
- 打开终端并执行以下命令以添加Nautilus Compare的PPA：
```
sudo add-apt-repository ppa:boamaod/nautilus-compare
sudo apt-get update
```
- 然后执行以下命令以安装Nautilus Compare：
```
sudo apt-get install nautilus-compare
```
如果由于网络等问题导致`add-apt-repository`命令失败，你可以通过访问Nautilus Compare的下载地址[[3](https://blog.csdn.net/larphy/article/details/105804611)]手动下载适用于你的Ubuntu版本的安装包，并使用`dpkg -i`命令进行安装。
安装完成后，你可以在Nautilus文件管理器中选中文件或文件夹，然后通过右键菜单中的选项执行比较操作。
这些是Ubuntu下一些好用的对比软件的推荐及其使用方法。你可以根据自己的需求选择适合的软件进行文件和文件夹的比较。
并且nautilus-compare是一个免费的Ubuntu文件比较工具，类似于Windows平台上的BCompare。它是基于Python开发的，可以用于比较文件夹和文件的内容，并支持二进制对比。你可以通过添加适当的软件源并使用命令来安装nautilus-compare，或者从相关网站下载并手动安装。它提供了右键菜单功能，使得文件比较更加方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07a29ab12a6946917c1741623a9047b/" rel="bookmark">
			【Elasticsearch】 实际生产中的监控及调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
监控 API
调优
1、CPU使用率
ES中导致CPU 变高的因素
ES导致CPU 变高的解决方案
2、内存使用率
ES内存使用率 过高的可能因素
ES内存使用率 过高的处理方案
3、ES磁盘使用率
ES磁盘使用率过高的可能因素
4、ES 中GC频次
ES 中GC频次增加的可能因素
ES 中GC频次降低GC频次的方案
5、ES中fielddata内存
ES中fielddata内存使用量增加的可能因素
ES 中fielddata内存使用量增高时的解决方案
一个 Elasticsearch 集群至少包括一个节点和一个索引。或者它可能有一百个数据节点、三个单独的主节点，以及一小打客户端节点——这些共同操作一千个索引（以及上万个分片）。
不管集群扩展到多大规模，你都会想要一个快速获取集群状态的途径。Cluster Health API 充当的就是这个角色。你可以把它想象成是在一万英尺的高度鸟瞰集群。它可以告诉你安心吧一切都好，或者警告你集群某个地方有问题。
监控 API 让我们执行一下 cluster-health API ：
GET _cluster/health response: 返回集群概览信息
{ "cluster_name": "elasticsearch_zach", "status": "green", "timed_out": false, "number_of_nodes": 1, "number_of_data_nodes": 1, "active_primary_shards": 10, "active_shards": 10, "relocating_shards": 0, "initializing_shards": 0, "unassigned_shards": 0 } 响应信息中最重要的一个指标 status 字段。状态可能是下列三个值之一：
green
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07a29ab12a6946917c1741623a9047b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b8b51a322bfca657d69175a52762be/" rel="bookmark">
			Android Studio学习一得——Android用户界面的设计布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们创建了一个安卓项目后，我们会发现真正建立一个完善的安卓项目并不是想象的那么容易。其实和设计可视化界面一样，开发安卓也需要考虑很多方面，主要考虑的还是界面布局和需要的组件。
一、Android用户界面布局管理 Android系统按照MVC(模型(model) - 视图(view) - 控制器(controller))设计模式将应用程序的界面设计与功能控制设计分离，类似于前后端分离，可以单独修改用户界面和后面的控制代码，而在AS中，前端的界面布局文件是在生成的应用程序框架项目的res资源目录的layout子目录中，文件名为activity_main.xm(创建新项目时可以改名字)，可以用界面化的和XML文件共同管理。如果要调用资源文件，就使用R.iava的R类，把res目录中的资源与id编号进行映射，用id号进行资源管理。
1.布局文件的规范 (1)布局文件作为项目的资源存放在res\layout目录下，是一个xml文件默认文件名为activity_main.xml.
(2)布局文件的根节点通常是一个布局方式，在根节点内可以添加组件作为结点。
(3)布局文件的根节点必须包含一个命名空间，为了与其他项目进行分离
如下: xmlns:android="http://schemas.android.com/apk/res/android" (4)如果要实现java程序中控制界面的组件，则必须为界面文件的组件定义个id，也就是通过id把资源文件以及组件引用过来进行控制。
组件定义格式如下:
android:id="@+id/&lt;组件id&gt;" 2.布局文件常用的重要属性值 (1)设置组件大小的属性值 wrap_contont: 强制性地使视图扩展以显示全部内容完整显示其内部的文本和图像，根据组件内容的大小来决定组件的大小。
match_parent: Android2.2以上和fill_parent通用，填充在容器的所有空间。
fill_parent: 强制性地使构件扩展，以填充布局单元内尽可能多的空间就是强制性让它布满整个屏幕。
(2)设置组件大小的单位 px(pixels): 像素，即屏幕上的发光点
dp(或dip，全称为device independent pixels): 设备独立像素一种支持多分辨率设备的抽象单位，和硬件相关
sp(scaled pixels): 比例像素，设置字体大小。
(3)设置组件的对产方式 在组件中由"android:gravity”属性控制组件的对齐方式，其属性有上(top) ，下(bottom) ，左 (left) ，右 (right) ，水平方向居中(center_horizontal).垂直方向居中(center_vertical)等。
3.常见的布局 有关用户界面的布局有下面常见的七种布局
线性布局(LinearLayout) ，帧布局(FrameLayout) ，表格布局(TableLayout)， 相对布局 (RelativeLayout) ，绝对布局(AbsolateLayout)约束布，网格布局 (GridLayout) ， 约束布局(ConstraintLayout)。 而相对布局已使用约束布局替代，绝对布局难以实现多分辨率适配，不建议使用。
(1)线性布局(LinearLayout) 特点: 将组件按照水平或垂直方向排列。
特殊属性: 由”android:orientation”属性控制排列方式，其属性值有水平(horizontal)和垂直(vertical)两种
实例: 按水平和垂直方向线性布局显示几个按钮
水平结果：
垂直结果： (2)帧布局(FrameLayout) 特点:将组件放置在左上角位置，当添加多个组件时后面的组件将遮盖前面的组件。 帧布局会按照添加顺序层叠在一起，默认层叠在左上角位置。 特殊属性: 用"layout_gravity”可以设置层叠的位置。
实例: 将不同大小的图片进行层，这里引用图片的方法可以在用户界面，也可以在源程序控制文件中。 (3)表格布局(TableLayout) 特点: 将页面分为由行，列构成的单元格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7b8b51a322bfca657d69175a52762be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18177069c2d5056a8a399db92f707593/" rel="bookmark">
			Vben学习记录(格式化时间戳)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 格式化后台传入的时间数据，三种方法：
1.
{ title: '开始时间', dataIndex: 'startTime', width: 80, format:'date|YYYY-MM-DD HH:mm:ss' } 2.
{ title: '开始时间', dataIndex: 'startTime', width: 80, format:(record) =&gt; { return !!record ? dayjs(record).format('YYYY-MM-DD hh:mm:ss') : record } } 3.
{ title: '开始时间', dataIndex: 'startTime', width: 100, sorter: true, customRender:({ record }) =&gt; record.startTime == null ? '' : formatDateTime(new Date(record.startTime),'YYYY/MM/DD hh:mm:ss'), } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b14c42bc7c671d4f53d7cb9ec1f87be/" rel="bookmark">
			华为HCIA进阶笔记：AAA原理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Authentication Authorization Accounting 认证 授权 统计
前言
AAA应用场景
认证
授权
计费
AAA域
AAA配置
AAA配置
配置验证
Authentication Authorization Accounting 认证 授权 统计 前言 AAA是Authentication(认证)、Authorization(授权）和Accounting (计费)的简称，它提供了认证、授权、计费三种安全功能。AAA可以通过多种协议来实现,目前华为设备支持基于RADIUS (Remote Authentication Dial-In User Service)协议或HWTACACS ( Huawei Terminal Access Controller Access Controlsystem)协议来实现AAA。
AAA应用场景 ⦁ AAA是一种提供认证、授权和计费的安全技术。该技术可以用于验证用户帐户是否合法，授权用户可以访问的服务，并记录用户使用网络资源的情况。
⦁ 例如，企业总部需要对服务器的资源访问进行控制，只有通过认证的用户才能访问特定的资源，并对用户使用资源的情况进行记录。在这种场景下，可以按照如图所示的方案进行AAA部署，NAS为网络接入服务器，负责集中收集和管理用户的访问请求。
⦁ AAA服务器表示远端的Radius或HWTACACS服务器，负责制定认证、授权和计费方案。如果企业分支的员工希望访问总部的服务器，远端的Radius或HWTACACS服务器会要求员工发送正确的用户名和密码，之后会进行验证，通过后则执行相关的授权策略，接下来，该员工就可以访问特定的服务器了。如果还需要记录员工访问网络资源的行为，网络管理员还可以在Radius或HWTACACS服务器上配置计费方案。
⦁ 目前，ARG3系列路由器只支持配置认证和授权。
认证 ⦁ AAA支持三种认证方式:
⦁ 不认证：完全信任用户，不对用户身份进行合法性检查。鉴于安全考虑，这种认证方式很少被采用。
⦁ 本地认证：将本地用户信息（包括用户名、密码和各种属性）配置在NAS上。本地认证的优点是处理速度快、运营成本低；缺点是存储信息量受设备硬件条件限制。
⦁ 远端认证：将用户信息（包括用户名、密码和各种属性）配置在认证服务器上。AAA支持通过RADIUS协议或HWTACACS协议进行远端认证。NAS作为客户端，与RADIUS服务器或HWTACACS服务器进行通信。
⦁ 如果一个认证方案采用多种认证方式，这些认证方式按配置顺序生效。比如，先配置了远端认证，随后配置了本地认证，那么在远端认证服务器无响应时，会转入本地认证方式。如果只在本地设备上配置了登录账号，没有在远端服务器上配置，AR2200认为账号没有通过远端认证，不再进行本地认证。
授权 ⦁ AAA授权功能赋予用户访问的特定网络或设备的权限。AAA支持以下授权方式：
⦁ 不授权：不对用户进行授权处理。
⦁ 本地授权：根据NAS上配置的本地用户账号的相关属性进行授权。
⦁ 远端授权：HWTACACS授权，使用TACACS服务器对用户授权。RADIUS授权，对通过RADIUS服务器认证的用户授权。RADIUS协议的认证和授权是绑定在一起的，不能单独使用RADIUS进行授权。
⦁ 如果在一个授权方案中使用多种授权方式，这些授权方式按照配置顺序生效。不授权方式最后生效。
计费 ⦁ 计费功能用于监控授权用户的网络行为和网络资源的使用情况。AAA支持以下两种计费方式：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b14c42bc7c671d4f53d7cb9ec1f87be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ab1041846885586013cc39afabb008f/" rel="bookmark">
			02_02_广度优先搜索（Breadth-First Search，BFS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		广度优先搜索（Breadth-First Search，BFS） 广度优先搜索（Breadth-First Search，BFS）介绍： 是一种图遍历算法，其原理是逐层遍历图的节点。BFS从起始节点开始，先访问起始节点的所有邻居节点，然后再逐层访问其他邻居节点。
广度优先搜索（Breadth-First Search，BFS）原理： 选择一个起始节点，并将其标记为已访问。将起始节点放入队列（通常是使用队列数据结构实现BFS）。当队列不为空时，执行以下步骤：
● 从队列中取出一个节点作为当前节点。
● 访问当前节点，并进行相应的操作。
● 将当前节点的所有未访问的邻居节点加入队列，并标记为已访问。如果队列为空，表示已经遍历完所有节点，算法结束。 Java 代码实现： package com.algorithm.graph; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; public class BFS { /** * 测试方法 * * @param args todo */ public static void main(String[] args) { /** * 创建有 6 个节点的图对象 */ BFSGraph graph = new BFSGraph(6); /** * 添加节点 */ graph.addEdge(0, 1); graph.addEdge(0, 2); graph.addEdge(1, 3); graph.addEdge(2, 4); graph.addEdge(2, 5); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ab1041846885586013cc39afabb008f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4db82dc6984bc7c7cea1243deeede5d/" rel="bookmark">
			富士期货CTA策略及常用代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CTA策略是指Commodity Trading Advisor （商品交易顾问）所采用的投资策略。CTA策略是一种基于程序化交易和算法模型的投资方法，旨在通过分析市场数据和趋势，识别投资机会并制定交易决策。
CTA策略通常基于技术分析、统计学模型和市场趋势等因素，以寻找价格波动和市场趋势中的利润机会。CTA策略可以应用于多种资产类别，包括股票、外汇、期货、期权等。
常见的CTA策略包括但不限于以下几种：
均值回归策略：基于资产价格回归到其历史均值的趋势，当价格偏离均值时，会采取相反的交易方向。
动量策略：基于资产价格的趋势，当价格上涨或下跌趋势明显时，会采取相同的交易方向。
趋势跟踪策略：基于资产价格的趋势，当价格处于上升或下降趋势时，会持续持有相同的交易方向。
统计套利策略：通过同时买入和卖出相关资产，利用价格关系和统计学原理来获得套利机会。
事件驱动策略：基于特定事件的发生和市场反应，通过分析事件与资产价格之间的关系，以获得交易机会。
均值回归策略代码：
import numpy as np
import pandas as pd
def mean_reversion_strategy(data, lookback_period, threshold):
# 计算价格均值和标准差
mean = data.rolling(window=lookback_period).mean()
std = data.rolling(window=lookback_period).std()
# 计算价格偏离度（z-score）
z_score = (data - mean) / std
# 根据价格偏离度生成交易信号
signal = np.where(z_score &gt; threshold, -1, np.where(z_score &lt; -threshold, 1, 0))
# 将交易信号向前移动一天，避免未来数据偏差
signal = pd.Series(signal, index=data.index).shift(1)
return signal
# 示例数据
price_data = pd.Series([100, 95, 105, 90, 110, 85, 115, 80, 120, 75])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4db82dc6984bc7c7cea1243deeede5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23cd3849e39c54ae453a4c0082e16f4b/" rel="bookmark">
			蓝桥杯嵌入式——LCD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝桥杯嵌入式——LCD 配置程序编写 配置 cubeMX
根据下图，将对应的引脚设置为OutPut电路原理图
导入 LCD 相关文件，将下面的文件发到 bsp 文件夹中。
程序编写 初始化
在main函数里，/* USER CODE BEGIN 2 * /和/ * USER CODE END 2 */之间初始化LCD. //初始化LCD LCD_Init(); LCD_Clear(Black);//清除为白色 LCD_SetBackColor(Black);//黑色背景 LCD_SetTextColor(White);//白色字体 常用函数 void LCD_DisplayChar(u8 Line, u16 Column, u8 Ascii);//输出字符 void LCD_DisplayStringLine(u8 Line, u8 *ptr);//输出字符串 上面是用来显示字符，下面是用来显示字符串的。不管是显示字符还是字符串，都需要指定显示的行数。从Line0到Line9都是可用的。显示字符时还需要指定列。LCD一个字符为24x16,LCD屏幕的宽度是范围是0~319，一个字符的占到了16，一行可以显示20个字符，因此将一个字符a显示在第—行第一列需要这么写:
void LCD_DisplayChar(Line0, 319 - 16, 'a'); 空白的部分也可以用空格表示（不要用Tab键，本人用Tab背景色会有点奇怪，一行可以显示20个字符）
void LCD_DisplayStringLine(Line2, (uint8_t *)" hello "); 格式化输出
导入“stdio.h”,使用sprintf(); #include &lt;stdio.h&gt; char buf[30] ; sprintf((char *) buf,"%02d : %02d : %02d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23cd3849e39c54ae453a4c0082e16f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9c6dac9eb3646cdf0dc52e6305170e/" rel="bookmark">
			在低配Windows上部署原版llama.cpp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在大语言模型的部署，通常都需要大的GPU才能实现，如果是仅仅想研究一下，大语言模型的算法，我们是很想能够直接在我们的工作电脑上就能直接运行的，llama.cpp就是很好的实现。
LLaMa.cpp使用int4这种数值格式，其显著降低了内存需求，并且在大多数硬件上其性能严重受到内存限制。LLaMa.cpp使用原始C ++的项目来重写LLaMa（长格式语言模型）推理代码。这使得可以在各种硬件上本地运行LLaMa，包括Raspberry Pi。
在使用一些优化和量化技术来量化权重的情况下，LLaMa.cpp使得大型语言模型可以在本地的多种硬件上运行，而无需昂贵的GPU。内存带宽往往是推理的瓶颈，通过量化使用更少的精度可以减少存储模型所需的内存。
下载源码 LLaMa.cpp 的项目地址在：https://github.com/ggerganov/llama.cpp
只要用git命令就能下载下来：
git clone https://github.com/ggerganov/llama.cpp 准备编译工具 LLaMa.cpp 是cpp 跨平台的，在Windows平台下，需要准备mingw 和Cmake。
mingw 进入 powershell 下，输入如下的命令安装 mingw ：
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser iex "&amp; {$(irm get.scoop.sh)} -RunAsAdmin" scoop bucket add extras scoop bucket add main scoop install mingw Cmake Cmake 的下载地址：https://cmake.org/download/
下载二进制安装版本：
到这里，Windows上的编译工具已经齐全了。
编译LLaMa.cpp 编译LLaMa.cpp也非常的方便，进入刚下载的源码目录。
cd llama.cpp 编译：
cmake . -G "MinGW Makefiles" cmake --build . --config Release 没碰到问题的话，在bin的目录下就会生成几个可执行的exe。
可执行的exe虽然多，但是用到的主要有两个，一个是quantize.exe，一个是main.exe。
有了程序以后，我们还差一个模型。
模型下载 在huggingface 放着很多的开源模型，为了简单和性能，使用的是LLaMA-7B模型，下载地址在：https://huggingface.co/nyanko7/LLaMA-7B/tree/main
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9c6dac9eb3646cdf0dc52e6305170e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa37b662a4c7fc5ef17cdf38c76c8afe/" rel="bookmark">
			基于STM32使用DHT11温湿度模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、DHT11模块介绍
1、原理图
2、通信时序（单总线）
2.1、通信总过程
2.2、起始信号及DHT11应答
2.3、数字1信号的应答时序
2.4、数字0信号的应答时序
2.5、数据格式
二、使用步骤
1.使用CubeMX进行配置（基于stm32f407zgt6）
2.编写相关函数
​编辑3、实验结果
三、代码分享
总结
前言 DHT11模块是一种基于数字信号输出的简单温湿度传感器，它能够测量环境的温度和湿度，并将数据以数字信号的形式传输给控制主板，如Arduino，stm32，8051等微控制器。
DHT11模块由温湿度传感器、微处理器以及一些电子元器件组成。该模块采用单线总线通讯方式，具有非常高的可靠性、稳定性和精度。该模块的温度测量范围为0-50摄氏度，湿度测量范围为20%-90% RH（产品不一样范围也有所变化）。
DHT11模块广泛应用于温湿度监控、气象观测、空气质量检测、智能家居、农业、医疗等领域。在Arduino等开源硬件平台上，使用DHT11模块可以方便快捷地实现温湿度数据的采集和处理。
一、DHT11模块介绍 1、原理图 这是我买的模块的图片以及原理图，初始的模块是有四个引脚，一般NC也是要接地的。这个只给出了三个引脚并且在每个引脚上都标出了VCC、DATA、GND所以一定要注意接线的问题！！！不要反接了，商家说的接反必烧！！！
在模块上面还有一个电源指示灯，当你正确接线的时候就会亮但不代表你这个模块没有问题。我出现过灯是亮的但是读出的数据都是错的，所以当你试了很久很久能够确定自己写的代码没有错时请不要怀疑！也有可能是模块的问题！！！
然后就是注意VCC的电压范围是3.3V-5V（具体的型号可以不同，要仔细一点看商家的介绍）
2、通信时序（单总线） 2.1、通信总过程 黑色加粗是代表使用的微控制器（stm32）的处理，也就是我们程序的拉低拉高。浅棕色就是代表DHT11。
2.2、起始信号及DHT11应答 图中画出的圈1主要是微控制器（stm32）发起的起始信号，stm32拉低总线持续18ms以上然后再拉高20-40us。因为后面需要接收DHT11的信号，所以在发送完起始信号之后就要改变总线的模式为输入模式，以便后续的读数据。
图图画出的圈2主要是DHT11的回应（通过这个可以判断是否有这个外设存在），DHT11先拉低总线80us，然后再拉高80us，我们需要先判断stm32在释放总线后是否被DHT11拉低，然后再判断是否被拉高。两段都判断了才能证明DHT11真正存在。
2.3、数字1信号的应答时序 总线先被拉低50us左右，然后再拉高26-28us。 具体操作再后续的代码讲解中。
2.4、数字0信号的应答时序 总线先被拉低50us左右，然后再拉高70us左右。 具体操作再后续的代码讲解中。
2.5、数据格式 一次完整的数据传输为40bit,高位先出。
数据格式:8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据+8bit校验和
最后的校验位是前面四个数据的总和，用于验证接收到的数据是否正确。
二、使用步骤 1.使用CubeMX进行配置（基于stm32f407zgt6） 后续代码生成步骤省略，要注意的是存储的路径中不能有中文！！！今天刚出现识别不了中文导致不能打开Keil。
自此关于工程的配置以及搭建已经全部完成，剩下的就是编写模块的代码。 2.编写相关函数 由于HAL库没有封装延时us级的函数，所以需要自己写一个，有很多写法比如使用新的定时器等。
这里使用的是操作寄存器的方法进行对printf的重定向，有很多种不同的方法，能用就行。
编写的.h文件，进行了一些宏定义操作便于后续引脚的修改。
注意：在上面所示代码中注释掉的printf千万不能有，因为printf会消耗较长时间对于时序来说是致命的！！！ 3、实验结果 复位会出现一次数据错误，原因在于初始化和转换之间的间隔太短了，加一个20ms左右的延时即可。
三、代码分享 由于网盘分享文件不能过多，所以只选择分享了模块代码、dht11的文档。
https://www.aliyundrive.com/s/NkP7y9m3e6B
总结 个人感觉dht11对于stm32的学习还是有必要使用并且学习，在许多项目中也会有用到。本次文章是我学习完之后进行的一次总结，如有错误请指出，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2413716193d952d7e57fabd6fd68c99/" rel="bookmark">
			Redis介绍以及Linux下的Redis安装(超级详细，傻瓜式教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis简介 Redis（ Remote DicƟ onary Server ）， 即远程字典服务。 Redis是用 C 语言编写的完全开源的、遵守 BSD 协议的、高性能的 key-value 数据库 BSD是 ” Berkeley Software Distribution ” 的缩写，意思是“伯克利软件发行版”。 BSD开源协议是一个给予使用者很大自由的协议。可以自由地使用，修改源代码，也可以将 修改后的代码作为开源或者专有软件再发布。 BSD 鼓励代码共享，但需要尊重代码作者的著 作权。 BSD 由于允许使用者修改和重新发布代码，也允许使用者在 BSD 代码上开发商业软 件，因此 BSD 是对商业集成很友好的协议。 我们先通过一个电商业务场景来对redis有一个整体的认识 1. 商品基本信息（名称、价格、厂商），存放于MySQL 2. 商品附加信息（描述、详情、评论），存放于MongoDB 3. 图片信息，存放于分布式文件系统 4. 搜索关键字，ES、 Lucene 、 solr 5. 热点信息，高频，波段性 存放于redis (1) 比如2020年初，“口罩”就是热点信息 (2) 比如情人节前后，“玫瑰花”、“巧克力”就是热点信息 整体的模型图看起来就是下面这个样子 redis的特点 1. 单线程，Redis是单线程的（使用了多路复用技术，就是一个线程管理多个连接），所 以 Redis 的所有单个操作都是原子性的。多个操作也能由事务来保证原子性（通过 MULTI 和 EXEC 这两个指令），因此在 redis 层面无需考虑并发所带来的影响。 2. 性能极高，读110000/s，写 81000/s （硬件达标，才能出现这个结果） 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2413716193d952d7e57fabd6fd68c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0698a42cad3d752cd6af889f42f09a39/" rel="bookmark">
			MidJourney使用教程：一 第一次怎么用Midjourney
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实际我是先写的prompts提示这部分，觉得Midjurney使用的方式，市面上已经有一大把文章了，另一方面觉得也没什么可写的。注册一个discard账号写个prompts描述出图就可以了，但其实有很多点其实忽略掉。比如图出来了，这四幅图底下的U1到U4，V1到V4什么意思？还有就是公共频道，那么多人用，自己的图还没完全出完，就被顶到上面去了，有没有什么好的方式，有一个自己的“独享的”空间？为什么这4个图一体的，怎么下载到这4副图自己喜欢的那张图？这边我就是以问题和回答的形式来解答这些，初次使用MidJourney这些问题。
Midjourney和diiscard什么关系，为什么用Midjourney还要注册discard？
discard是一个社交平台，midjourney是在上面以一个聊天机器人的形式，提供AI绘图服务给大家用。
你想体验你就要注册discard，注册成功后，还要添加MidJourney服务器。通过“加号”按钮来添加midjourney服务器，输入midjourney
进入midjourney服务器，选择一个newbise开头的房间，在底部消息栏输入 /image 你的图片描述 ，开启你的第一个AI生成图。
一般一个图两分多钟，需要等一下。
Midjourney返回的图片下方的，U和V是什么，有什么作用？
我们获得一个图，如下一只赛博朋克风格的老鼠
U的意思放大图片，U1/U2/U3/U4分别指的是放大四张图片中的某一张图片。
V的意思采用图片的构图形式，重新生成一组类似的图片，V1/V2/V3/V4的顺序与U的顺序一样
咱们看看效果：
U
V
怎么创建一个自己的Midjourney服务器，有一个自己的独享的空间？
创建一个服务器，还是那个“加号”，
创建成功后，你要把MidJourney机器人引到你创建的服务器，找到之前的Midjourney服务器，随便找一个出图的房间，找到侧面成员栏，找到Midjourney机器人点击，选择“添加服务器”到自己的新建的服务器上，这样就可以在你自己的服务器输出图片。
如何下载想要的图片？免费额度用完了，midjourney这个收费是怎么样的？
因为四张图片是连在一起，想要下载需要大图，就是通过U来获取自己的大图，点击图片然后右键“图片另存为”。
由于免费的额度是有限的，输入几个质量可能就不够用了。所以可以采用花钱办会员的方式来，具体的办理会员入口，需要登陆midjourney，选择“Purpase Plan”
选择“年付”和“月付”
以上就是，初次使用Midjourney的一些具体操作。
我的公众号“我是坑货”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f478e1080af73a86a672632a0d7d03/" rel="bookmark">
			8254常规接口实验（汇编与接口技术课程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、实验目的二、实验内容实验一实验二实验三 四、实验编程提示五、实验步骤六、思考题 前言 北交大本科必修课程——8254汇编与接口技术常规实验。
一、实验目的 1、掌握8254和微机接口的连接方法，了解8254的基本工作原理和编程方法。
2、理解8254定时/计数器的各种工作方式的特点；通过观察实验波形直观地了解8254几种工作方式的异同。
二、实验内容 实验一 将8254计数器0设为工作方式0，计数器初值设置为N(N&lt;0FH）。将实验台上单脉冲接到CLK0上，手动逐个输入单脉冲，用L0和示波器观察OUT0电平变化（输入N+1个脉冲后OUT0变高电平,L0亮）
思路：
1、首先我们要对8254进行初始化，向命令端口283H输入方式命令00010000，来选择计数器0，只写低字节，工作方式0，二进制计数
2、在向计数器0送计数初值3（这个数由自己决定）
实验现象：
电灯泡：电灯泡L0开始时是处于熄灭状态的，当我们手动给4（N+1）个脉冲后，电灯泡变亮并持续保持亮的状态。
示波器：示波器开始时处于低电平，但当我们手动给4（N+1）个脉冲后示波器变为高电平并不再变化。
结果分析：
方式0在手动给第一个脉冲时才将初值寄存器中的数值放到减一计数器中，在第二个脉冲到来的时候才开始减一，所以才会出现电灯泡和示波器在N+1个脉冲后才变亮和变为高电平的现象。并且方式0在计数结束后out信号一直处于高电平，所以电灯泡和示波器才保持常亮和高电平的状态不改变。
代码如下：
code segment start : mov dx, 283h; 命令口地址 mov al, 00010000b; 计数器0；只写低字节；2方式；二进制 out dx, al; 初始化 mov dx, 280h; 选择计数器0 mov ax, 03h; 计数器初值是3 out dx, al code ends end start 实验二 编写程序分别显示2，3工作方式下的波形。要求2方式的输出频率为1000Hz，3方式的输出频率为2000Hz。本实验使用8254的定时/计数器0，GATE0通过K1接到+5V或地，CLK0接1MHZ时钟脉冲，OUT0接示波器观测输出波形(连线见图1-2)。
方式二：
思路：
因为输入的脉冲频率为1MHZ，为了使示波器输出频率为1000HZ，我们可以计算出计数初值为1MHZ / 1000HZ= 1000，所以我们首先初始化，选择计数器0，先输入高字节再输入低字节，方式2，以二进制计数；然后向计数器输入计数初值1000。实验现象：
可以在示波器上观察到1000HZ的波形和数值代码如下 code segment start : mov dx, 283h; 命令口地址 mov al, 00110100b; 计数器0；先低字节再高字节；2方式；二进制 out dx, al mov dx, 280h; 选择计数器0 mov ax, 3e8h; 计数器初值1000 out dx, al; 先写低字节 mov al, ah; out dx, al; 再写高字节 code ends end start 方式3：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f478e1080af73a86a672632a0d7d03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf99249249429badcbf03f9df58675e/" rel="bookmark">
			[ADAS预研笔记]OpenPilot开源SDK研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整个openpilot项目可以分为以下几个模块：定位、决策、控制。
openpilot对于感知的实现原理类似于特斯拉，靠的是纯视觉的解决方案，但因为camera只有两颗（一颗用于拍摄实现的路况，另一颗用于监控驾驶员），所以openpilot支持也比较有限， 主要支持车道保持 、ACC巡航、自动辅助变道这三个功能。
其代码目录如下：
├── cereal # 用于所有日志的消息规范和LIB ├── common # openpilot中开发的类库功能 ├── docs # 文档 ├── opendbc # 显示如何解释汽车数据的文件，并以人类可读的方式对理解车辆CAN总线流量所需的信息进行编码。 ├── panda # CAN通信的代码 ├── third_party # 扩展第三方文件包 ├── pyextra # 扩展第三方python文件包 └── selfdrive # 驾驶汽车所需的代码 ├── assets # 用于用户界面的字体、图像和声音 ├── athena # 允许与应用程序app实现通信 ├── boardd # 守护进程与面板的通信 ├── camerad # 通过驱动程序从摄像头传感器捕获图像 ├── car # 用于读取状态和控制执行器的车辆特定代码 ├── common # 用于守护程序的共享C/C++代码 ├── controls # 规划和控制 ├── debug # 帮助您调试和执行汽车端口的工具 ├── locationd # 精确定位与车辆参数估计 ├── logcatd # Android logcat作为服务 ├── loggerd # 汽车数据记录器和上传器 ├── modeld # 驾驶和监控模型 ├── proclogd # 从proc记录信息 ├── sensord # IMU接口代码 ├── test # 单元测试、系统测试和汽车模拟器 └── ui # 用户界面 其结构如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf99249249429badcbf03f9df58675e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b933da5bcf3f2d4765eaec0d23683ae5/" rel="bookmark">
			终止正在运行的SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		终止正在运行的SQL（可以找出哪些SQL在运行，查询太慢且无法点中止的时候用，得另外开一个plsql程序kill进程）：
1、查SID,SERIAL#，找出需要终止的SQL代码
select b.sid,b.username,b.serial#,a.spid,b.paddr,c.sql_text,b.machine from v$process a,v$session b,v$sqlarea c
where a.addr=b.PADDR and b.sql_hash_value=c.hash_value
2、KILL进程
alter system kill session 'sid,serial#' --注意这里是单引号，不是括号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253c555ee228c6aa5dd0787c871a4ce0/" rel="bookmark">
			STM32使用内部参考电压提高ADC采集准确度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用ADC采集外部电压时，一般默认参考电压为MCU的供电电压，例如单片机供电电压为3.3V时，我们计算采集电压的公式为：
假设12位ADC 采集电压=（AD值/4096）*3.3； 但是如果因为某些原因导致的供电不稳定，而我们任然按照3.3V计算，ADC采集计算出来的电压就会出现误差。
在STM32手册中关于ADC的介绍中提到使用内部参考电压计算实际的VDDA电压。
使用内部参考电压计算实际的 VDDA 电压：
施加给微控制器的 VDDA 电源电压可能会有变化，或无法获得准确值。在制造过程中由 ADC 在 VDDA = 3.3 V 的条件下获得的内置内部参考电压 (VREFINT) 及其校准数据可用于评估实际 的 VDDA 电压。 以下公式可求得为器件供电的实际 VDDA 电压： VDDA = 3 V x VREFINT_CAL / VREFINT_DATA 其中：  VREFINT_CAL 是 VREFINT 校准值  VREFINT_DATA 是由 ADC 转换得到的实际 VREFINT 输出值 将电源相关的 ADC 测量值转换为绝对电压值：
如何使用内部参考电压 使用STM32CubeMX配置ADC是除了选取自己的需要的ADC通道，还要勾选Vrefint channel，这个通道也可以看做是一路ADC采集，用于后边的计算。
RANK分配，采用DMA模式时，定义数组时直接对应到数组。
使能DMA。
STM32手册中提到：VREFINT 的精确电压由 ST 在生产测试期间对每部件单独测量，储存于系统存储区。这个值是固定的，计算前我们需要将它读出来。
u16 ADC_Buffer[3];//定义u16数组 0.通道4 1.通道7 2.参考电压Vref u16 VREFT_CAL = 0;//内部基准 VREFT_CAL = *(uint16_t*)(VREFINT_CAL_ADDR);//读取内部基准 HAL_ADC_Start_DMA(&amp;hadc1,(uint32_t*)ADC_Buffer,3);//开启 ADC---DMA V= (3*VREFT_CAL*ADC_Buffer[0])/(ADC_Buffer[2]*4096); //校准后的通道4采集电压 以上就是STM32使用内部参考电压提高ADC采集准确度的方法，不过计算电压值，我还是喜欢自己再去实际校准得到一个系数。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/124/">«</a>
	<span class="pagination__item pagination__item--current">125/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/126/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>