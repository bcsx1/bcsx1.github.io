<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8087639cbeacdc90abb8a9f83c17041e/" rel="bookmark">
			Vue中等待两个异步请求完成解决方式记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue中等待两个异步请求完成可以使用Promise.all()函数。Promise.all()接收一个包含多个Promise对象的数组，并返回一个新的Promise对象，该对象在数组中所有的Promise对象都完成后才会被解决。以下是一个示例：
// 异步请求1 const promise1 = axios.get('/api/data1'); // 异步请求2 const promise2 = axios.get('/api/data2'); // 等待两个异步请求完成 Promise.all([promise1, promise2]).then(([response1, response2]) =&gt; { // 在这里处理两个请求的响应数据 }).catch(error =&gt; { // 处理错误 }); 在上面的示例中，我们首先定义了两个异步请求promise1和promise2，然后将它们作为参数传递给Promise.all()函数。在.then()回调函数中，我们可以访问两个请求的响应数据response1和response2，并进行相应的处理。如果任何一个请求失败，.catch()回调函数就会被调用来处理错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1afb87a1c83dfd76965a705d49ed45ab/" rel="bookmark">
			刚刚！2023年中科院分区表1区名单汇总，含21个大类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年期刊分区表共收录13818本杂志。综合性期刊64本、哲学261本、医学3783本、艺术学241本，心理学494本、物理与天体物理323本、文学584本、数学558本、生物学941本、历史学431、农林科学726本、材料科学371本、计算机科学502本、环境科学与生态学388本、化学389本、工程技术1032本、教育学269本、经济学414本、管理学432本。
以下是最新2023年分区升级版21个大类（一区期刊情况），仅为部分表单，资料仅供参考，版权属于中国科学院文献情报中心。
1 综合
2 材料
3 地球科学
4 工程
5 管理学
6 化学
7 环境
8 计算机科学
9 教育学
10 经济学
11 社会学
12 历史学
13 农林科学
14 生物
15 数学
16 文学
17 物理
18 心理学
19 医学
20 艺术
21 哲学
获取完整表单，可GZ“欧亚科睿学术”或添加胡编辑V
版权声明：蔚青学者、学之策、中国科学院文献情报中心、帕斯学库。分享只为学术交流，如涉及侵权问题请联系我们，我们将及时修改或删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca805c9da1f41e0e8600f513b17ee028/" rel="bookmark">
			【排序算法】多数元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.多数元素 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1：
输入：nums = [3,2,3]
输出：3
示例 2：
输入：nums = [2,2,1,1,1,2,2]
输出：2
提示：
n == nums.length1 &lt;= n &lt;= 5 * 104-109 &lt;= nums[i] &lt;= 109 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。
解法：
方法一 哈希表 思路
可以用哈希表来快速统计每个元素出现的次数。
算法
我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。
我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。
def func(list): counters = collections.Counter(list) return max(counters.keys(),key=counters.get) 这个方法：
时间复杂度：O(n)
空间复杂度：O(n)
方法二 排序 思路
如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为n/2的元素（下标从 0 开始）一定是众数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca805c9da1f41e0e8600f513b17ee028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dba569e318af44d114ea41a930b151c5/" rel="bookmark">
			R语言【base】——将单个 R 对象写入文件并将其还原的函数：saveRDS()，readRDS() 和 infoRDS()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Package base version 4.3.2
Parameters saveRDS(object, file = "", ascii = FALSE, version = NULL, compress = TRUE, refhook = NULL) readRDS(file, refhook = NULL) infoRDS(file) 参数【object】：要序列化的 R 对象。
参数【file】：连接或 R 对象保存或读取的文件名。
参数【ascii】：逻辑值。如果为 TRUE 或 NA，则写入 ASCII 表示；否则（默认），使用二进制表示。
参数【version】：要使用的工作区格式版本。NULL 表示当前默认版本（3）。唯一支持的其他值是 2，即从 R 1.4.0 到 R 3.5.0 的默认值。
参数【compress】：逻辑值，用于指定保存到指定文件时是否使用 "gzip" 压缩，或使用 "gzip"、"bzip2" 或 "xz" 中的一种来表示压缩类型。如果参数【file】是连接，则忽略。
参数【refhook】：钩子函数，用于处理引用对象。
saveRDS 和 readRDS 提供了将单个 R 对象保存到连接（通常是文件）并还原对象（很可能以不同的名称）的方法。这与 save 和 load 不同，save 和 load 是将一个或多个命名对象保存和恢复到环境中。它们被 R 本身广泛使用，例如用于存储软件包的元数据和存储 help.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dba569e318af44d114ea41a930b151c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7b58e2174f17b091a355fe5465bafbb/" rel="bookmark">
			区块链背后的秘密：从交易看故事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：shelly@footprint.network
在区块链的世界里，每一笔交易都是一个故事的开始。不只是数字的交换，更是用户行为、信念和决策的体现。
疯狂投机的背后，是短期的逐利还是长期的策略？协议分叉，真的分裂了社区吗？还是开启了新的探索？
解读这些交易，就像解锁一串串加密的密码。它们隐藏着策略、竞争、专业化和伙伴关系的线索。
区块链不仅仅是交易的平台，它更见证了加密经济的起伏。每一个决策、每一次流动，都构建了一个关于冒险、积累和失落的叙事。
据 Chainanalysis 的研究报道，超过 80% 的链上活动与各种应用有关，从 DeFi 到 NFTs，再到供应链和存储网络。这背后，是怎样的资金流和决策驱动？
为了深入了解，我们需要穿透抽象的协议量，揭示背后的真相。谁在推动这些活动？资金流如何轮换？哪些叙事正在崭露头角？
这正是 Footprint Analytics 所做的。作为多链数据的索引平台，它为我们提供了深入的颗粒化数据和洞察。从资金流的分类，到多维度的分析；从定制算法的开发，到各种应用领域的洞察。它帮助我们解读每一笔交易背后的故事。
以下是其一些关键功能：
1、根据背景对资金流进行分类
Footprint 对各种交易类型进行分类，标记跨交易、交换、质押、治理投票、NFT 铸造/销售等活动。这阐明了每笔交易的背景。
2、多维度的资金流向分析
多维度评估资金流向：特定代币、地址群组、整个协议或 DeFi、NFTs、bridges （链桥）等市场协议。甚至可以对结果或者行为提供聚合分析。
3、自定义算法开发
支持为聚类和分类构建定制的评分系统和机器学习模型，并使用 Footprint 上可用的各种数据集进行联表分析。根据您的需求定制资金流分析。
这些功能支持多种加密市场领域的应用：
1、市场情报
通过分析跨协议和跨链的资金流，了解整个生态系统迁移和开发人员、用户偏好的变化。
2、业务运营
通过用户钱包地址资金流研究用户活动和留存，为代币经济设计和衡量产品参与度提供信息。
3、风险管理
通过设定警报，检测异常活动和欺诈行为，如循环交易、投机操纵等可疑资金流动。
4、竞争对手基准测试
根据 TVL 组成、矿池多样化、锁定代币分析和用户钱包地址画像等指标，可以对不同协议的市场竞争力进行分析。
综上所述，区块链向作为一种中心化基础设施的演变，其大部分活动发生在应用层。而通过解读这些加密资金流向，我们将获得宝贵而可行的商业洞察力。
您可以通过访问我们的 网站 或 预约我们的客户经理会议，以了解更多解决方案。
Footprint Analytics 是一家区块链数据解决方案提供商。借助尖端的人工智能技术，我们提供 Crypto 领域首家支持无代码数据分析平台以及统一的数据 API，让用户可以快速检索超过 30 条公链生态的 NFT，Game 以及钱包地址资金流追踪数据。
产品亮点
面向开发人员的 Data APII
用于GameFi项目的 Footprint Growth Analytics (FGA) 大数据批量下载功能 Batch download
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7b58e2174f17b091a355fe5465bafbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583d4a899b46d87bf8c4d8cdd2ca7b18/" rel="bookmark">
			从3s到25ms！看看京东的接口优化技巧，确实很优雅！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 针对老项目，去年做了许多降本增效的事情，其中发现最多的就是接口耗时过长的问题，就集中搞了一次接口性能优化。本文将给小伙伴们分享一下接口优化的通用方案。
二、接口优化方案总结 1.批处理 批量思想：批量操作数据库，这个很好理解，我们在循环插入场景的接口中，可以在批处理执行完成后一次性插入或更新数据库，避免多次 IO。
//for循环单笔入库 list.stream().forEatch(msg-&gt;{ insert(); }); //批量入库 batchInsert(); 2. 异步处理 异步思想：针对耗时比较长且不是结果必须的逻辑，我们可以考虑放到异步执行，这样能降低接口耗时。
例如一个理财的申购接口，入账和写入申购文件是同步执行的，因为是 T+1 交易，后面这两个逻辑其实不是结果必须的，我们并不需要关注它的实时结果，所以我们考虑把入账和写入申购文件改为异步处理。如图所示：
至于异步的实现方式，可以用线程池，也可以用消息队列，还可以用一些调度任务框架。
3. 空间换时间 一个很好理解的空间换时间的例子是合理使用缓存，针对一些频繁使用且不频繁变更的数据，可以提前缓存起来，需要时直接查缓存，避免频繁地查询数据库或者重复计算。
需要注意的事，这里用了合理二字，因为空间换时间也是一把双刃剑，需要综合考虑你的使用场景，毕竟缓存带来的数据一致性问题也挺令人头疼。
这里的缓存可以是 R2M，也可以是本地缓存、memcached，或者 Map。
举一个股票工具的查询例子：
因为策略轮动的调仓信息，每周只更新一次，所以原来的调接口就去查库的逻辑并不合理，而且拿到调仓信息后，需要经过复杂计算，最终得出回测收益和跑赢沪深指数这些我们想要的结果。如果我们把查库操作和计算结果放入缓存，可以节省很多的执行时间。如图：
4. 预处理 也就是预取思想，就是提前要把查询的数据，提前计算好，放入缓存或者表中的某个字段，用的时候会大幅提高接口性能。跟上面那个例子很像，但是关注点不同。
举个简单的例子：理财产品，会有根据净值计算年化收益率的数据展示需求，利用净值去套用年化收益率计算公式计算的逻辑我们可以采用预处理，这样每一次接口调用直接取对应字段就可以了。
5. 池化思想 我们都用过数据库连接池，线程池等，这就是池思想的体现，它们解决的问题就是避免重复创建对象或创建连接，可以重复利用，避免不必要的损耗，毕竟创建销毁也会占用时间。
池化思想包含但并不局限于以上两种，总的来说池化思想的本质是预分配与循环使用，明白这个原理后，我们即使是在做一些业务场景的需求时，也可以利用起来。
比如：对象池
6. 串行改并行 串行就是，当前执行逻辑必须等上一个执行逻辑结束之后才执行，并行就是两个执行逻辑互不干扰，所以并行相对来说就比较节省时间，当然是建立在没有结果参数依赖的前提下。
比如，理财的持仓信息展示接口，我们既需要查询用户的账户信息，也需要查询商品信息和 banner 位信息等等来渲染持仓页，如果是串行，基本上接口耗时就是累加的。如果是并行，接口耗时将大大降低。
如图：
7. 索引 加索引能大大提高数据查询效率，这个在接口设计之出也会考虑到，这里不再多赘述，随着需求的迭代，我们重点整理一下索引不生效的一些场景，希望对小伙伴们有所帮助。
具体不生效场景不再一一举例，后面有时间的话，单独整理一下。
8. 避免大事务 所谓大事务问题，就是运行时间较长的事务，由于事务一致不提交，会导致数据库连接被占用，影响到别的请求访问数据库，影响别的接口性能。
举个例子：
@Transactional(value ="taskTransactionManager", propagation =Propagation.REQUIRED, isolation =Isolation.READ_COMMITTED, rollbackFor ={RuntimeException.class,Exception.class}) publicBasicResultpurchaseRequest(PurchaseRecordrecord){ BasicResult result =newBasicResult(); //插入账户任务 taskMapper.insert(ManagerParamUtil.buildTask(record,TaskEnum.Task_type.pension_account.type(),TaskEnum.Account_bizType.purchase_request.type())); //插入同步任务 taskMapper.insert(ManagerParamUtil.buildTask(record,TaskEnum.Task_type.pension_sync.type(),TaskEnum.Sync_bizType.purchase.type())); //插入影像件上传任务 taskMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/583d4a899b46d87bf8c4d8cdd2ca7b18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe49232ab81def258a96b7b7635c1f7a/" rel="bookmark">
			【Bootstrap学习 day2】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bootstrap5排版 使用标题标签&lt;h1&gt;-&lt;h6&gt;
可以使用类.h1-.h6来设置标题
&lt;div class="container"&gt; &lt;p class="h1"&gt;h1 Bootstrap 标题&lt;/p&gt; &lt;p class="h2"&gt;h2 Bootstrap 标题&lt;/p&gt; &lt;p class="h3"&gt;h3 Bootstrap 标题&lt;/p&gt; &lt;p class="h4"&gt;h1 Bootstrap 标题&lt;/p&gt; &lt;p class="h5"&gt;h1 Bootstrap 标题&lt;/p&gt; &lt;p class="h6"&gt;h1 Bootstrap 标题&lt;/p&gt; &lt;/div&gt; Display标题类
Bootstrap5还提供了使标题更突出的类，当我们需要标题突出时可以使用这些标题类。突出标题以更大的字体显示，并且会对其进行加粗。
&lt;div class="container"&gt; &lt;h1&gt;Display 标题 &lt;/div&gt; &lt;p&gt;Display标题可以输出更大更粗的字体样式.。&lt;/p&gt; &lt;h1 class="display-1"&gt;Display 1&lt;/h1&gt; &lt;h1 class="display-2"&gt;Display 2&lt;/h1&gt; &lt;h1 class="display-3"&gt;Display 3&lt;/h1&gt; &lt;h1 class="display-4"&gt;Display 4&lt;/h1&gt; 使用类突出显示段落
还可以通过在段落上添加类.lead来突出段落
&lt;p&gt;这是Bootstrap5中正常样式的段落。&lt;/p&gt; &lt;p class="lead"&gt;这是Bootstrap5中突出显示的段落。&lt;/p&gt; 自定义标题
我们可以使用带有类.text-muted class的标签来显示更小且颜色更浅的文本。
&lt;div class="container"&gt; &lt;h2&gt; 文本标题 &lt;small class="text-muted"&gt;更小且颜色更浅&lt;/small&gt; &lt;/h2&gt; &lt;/div&gt; 也可以添加类.small指定更小文本(为父元素的85%)
&lt;p class="small"&gt;这个段落字体更小&lt;/p&gt; &lt;p&gt;这是常规段落&lt;/p&gt; 文本对齐
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe49232ab81def258a96b7b7635c1f7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4e35807d1c5183a0fc113b0071999ce/" rel="bookmark">
			Java中的final关键字和static关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、final 关键字
（1）final 修饰变量、方法和类
（2）final 修饰的集合和不可变集合
2、static 关键字
（1）静态字段
（2）静态方法
这两个关键字编写代码时会经常用，正确的使用这些关键字，可以形成良好的编程习惯，保护好代码的封装性。
1、final 关键字 在Java中，利用关键字final指示常量，习惯上，常量名使用全大写。
关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。如果将实例字段定义为final，那么这样的字段必须在构造对象时初始化。也就是说，必须确保在每一个构造器执行之后，这个字段的值已经设置，开且以后不能再修改这个字段。
public class Test { //私有成员变量：此字段被构造函数赋值后不能再更改 private final Integer traversalDepth; //构造函数 public Test(Integer traversalDepth) { this.traversalDepth = traversalDepth; } } 在Java中，经常希望某个常量可以在一个类的多个方法中使用，通常将这些常量称为类常量(class constant)。可以使用关键字static final设置一个类常量。如果一个常量被声明为public，那么其他类的方法也可以使用这个常量。//一般情况下为保护封装性，都应该使内部成员变量为私有属性
（1）final 修饰变量、方法和类 对变量和基本数据类型使用 final：final 表示该变量或基本数据类型只能被赋值一次。一旦赋值后，就不能再改变其值。
对于引用类型，final 保证引用不会改变，但对象本身可以被修改。
public class Test { final int y; final Integer x; final List&lt;String&gt; list; //仍然可以往集合中添加元素 public Test(int y, Integer x, List&lt;String&gt; list) { this.y = y; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4e35807d1c5183a0fc113b0071999ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94584f48bd162a02e2e68f28a1bb0ec1/" rel="bookmark">
			算法设计与分析 | N皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。
输入 一个整数n（ 1 &lt; = n &lt; = 10 ) 输出 每行输出对应一种方案，按字典序输出所有方案。每种方案顺序输出皇后所在的列号，相邻两数之间用空格隔开。如果一组可行方案都没有，输出“no solute!”
样例输入 4 样例输出 2 4 1 3 3 1 4 2 分析：
N皇后问题使用回溯法进行解决，规则是：在 n × n 格的棋盘上放置 n 个皇后，任何 2 个皇后不放在 同一行 或 同一列 或 同一斜线 上。int Place(int* Column, int index)方法用来判断是否放的位置是在 同一行 或 同一列 或 同一斜线 上，如果是则返回0，反之返回1。这里定义逻辑序号从1开始，使用两个while来实现回溯，当Column_Num[index] 里面的index==n的时候，则判断输出Column_Num[n]。 代码：
//n皇后问题 #include&lt;stdio.h&gt; #include"stdlib.h" int Place(int* Column, int index) { int i; for (i = 1; i &lt; index; i++) { int Column_differ = abs(Column[index] - Column[i]); int Row_differ = abs(index - i); if (Column[i] == Column[index] || Column_differ == Row_differ) return 0; } return 1; } void N_Queue(int n) { int Column_Num[n + 1]; int index = 1; int i; int answer_num = 0; for (i = 1; i &lt;= n; i++) Column_Num[i] = 0; while (index &gt; 0) { Column_Num[index]++; while (Column_Num[index] &lt;= n &amp;&amp; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94584f48bd162a02e2e68f28a1bb0ec1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95694a19f748f5693c41d68d4faf12bb/" rel="bookmark">
			音频修复和增强软件：iZotope RX 10 (Win/Mac)中文汉化版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		iZotope RX 是一款专业的音频修复和增强软件，一直是电影和电视节目中使用的行业标准音频修复工具，iZotope能够帮助用户对音频进行制作、后期合成处理、混音以及对损坏的音频进行修复，再解锁更多功能之后还能够对电影、游戏、电视之中的音频进行美化、编辑、修复等操作。
主要特点包括： 声音修复：iZotope RX 可以去除不良噪音、杂音、吱吱声等，使音频变得更加清晰干净。
音频增强：iZotope RX 支持对音频进行音量调节、均衡器、压缩器、限制器等处理，使音频效果更加出色。
批处理：iZotope RX 支持批量处理多个音频文件，提高工作效率。
时频编辑：iZotope RX 具备强大的时频编辑功能，用户可以直观地编辑和处理音频信号。
跨平台兼容：iZotope RX 支持多种操作系统，包括Windows和Mac OS X。
接口友好：iZotope RX 的界面简单易用，用户可以快速上手并进行音频处理。
准确性高：iZotope RX 采用先进的算法和技术，能够精确地识别和修复不同类型的音频问题。
win版：https://soft.macxf.com/soft/3236.html?id=MzE5MTM%3D
mac版：https://www.macz.com/mac/8808.html?id=OTI2NjQ5Jl8mMjcuMTg3LjIyNC4xMTI%3D
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a43151b07ad23b8205d803ff3769cc0/" rel="bookmark">
			VS 报错 error C2447: “{”: 缺少函数标题(是否是老式的形式表?) 如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VS 报错 error C2447: “{”: 缺少函数标题(是否是老式的形式表?) 如何解决 问题描述：用的一个官网下载的SDK，其中一个项目不能运行，报了这个错误。 如下：
int main() { } 报错的位置就在int main()这一行。main函数的内容删掉了，因为删掉之后还是报错。
然后我把主函数都删掉，重新输入一遍：
int main() { } 再把main函数中间的内容复制回来，不错，问题解决了。
莫名其妙的bug
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/310760228e3aaaef5d094dfe64a6e330/" rel="bookmark">
			基于51单片机的倒车防撞监测预警系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、摘要 随着汽车工业的快速发展，汽车已经成为人们出行的主要交通工具。然而，由于驾驶员的疏忽和操作不当，倒车事故频发，给人们的生命财产安全带来极大的威胁。为了减少倒车事故的发生，本文设计了一种基于单片机的倒车防撞监测预警系统。该系统通过安装在汽车尾部的超声波传感器实时检测后方障碍物的距离，当距离小于设定的安全距离时，系统会发出声光报警提醒驾驶员注意，从而避免倒车事故的发生。
二、引言 倒车事故是汽车交通事故中最常见的一种，其主要原因是驾驶员对后方环境的误判和操作失误。为了解决这一问题，本文设计了一种基于单片机的倒车防撞监测预警系统。该系统采用超声波传感器作为检测器件，通过对后方障碍物的距离进行实时监测，当距离小于设定的安全距离时，系统会发出声光报警提醒驾驶员注意，从而避免倒车事故的发生。
三、系统设计 1. 硬件设计
本系统主要由超声波传感器、单片机、蜂鸣器和LED灯组成。超声波传感器用于检测后方障碍物的距离，单片机用于处理超声波传感器采集到的数据并控制蜂鸣器和LED灯的工作状态。
2. 软件设计
本系统的软件主要包括超声波测距程序、数据处理程序和报警程序。超声波测距程序用于控制超声波传感器发射和接收超声波信号；数据处理程序用于对接收到的超声波信号进行处理，计算出障碍物与汽车尾部的距离；报警程序用于判断距离是否小于设定的安全距离，如果小于安全距离，则控制蜂鸣器和LED灯发出声光报警。
四、系统测试与分析 为了验证系统的可行性和稳定性，我们对系统进行了实际测试。测试结果表明，本系统能够准确地检测后方障碍物的距离，并在距离小于设定的安全距离时发出声光报警，提醒驾驶员注意。同时，系统运行稳定，响应速度快，具有较高的实用价值。
五、结论 经过对基于单片机的倒车防撞监测预警系统设计的研究和实验验证，本文得出以下结论：
1. 本系统采用超声波传感器作为检测器件，能够实时、准确地检测汽车尾部与障碍物之间的距离。通过将测得的距离与设定的安全距离进行比较，可以实现对倒车过程中可能发生碰撞的预警。
2. 单片机作为系统的控制核心，负责处理超声波传感器采集到的数据，并根据数据处理结果控制蜂鸣器和LED灯的工作状态。通过对单片机程序的优化，实现了系统的低功耗和高效运行。
3. 本系统具有较高的实用价值，可以有效降低倒车事故的发生概率，保障驾驶员和周围行人的生命财产安全。同时，系统具有较好的扩展性，可以根据实际需求对硬件和软件进行优化和升级。
4. 在实际应用中，还需考虑一些因素对系统性能的影响，如环境噪声、传感器安装位置等。针对这些问题，可以通过采用数字滤波技术、自适应阈值算法等方法进行优化。
5. 未来研究可以在以下几个方面进行拓展：（1）结合其他传感器（如摄像头、激光雷达等），实现对汽车周围环境的全方位监测；（2）研究基于机器学习的智能预警算法，提高系统的预警准确性；（3）开发手机APP或其他移动终端设备，实现远程监控和控制功能。
代码展示如下：
#include &lt;reg52.h&gt; #include &lt;intrins.h&gt; typedef unsigned char uchar; typedef unsigned int uint; sbit Trig = P2^0; // 超声波模块触发引脚 sbit Echo = P2^1; // 超声波模块回声引脚 sbit Beep = P1^5; // 蜂鸣器引脚 sbit LED = P1^6; // LED灯引脚 uchar distance; // 存储测得的距离 void delay(uint z) { uint x, y; for (x = z; x &gt; 0; x--) for (y = 110; y &gt; 0; y--); } void UART_Init() { SCON = 0x50; // 设置串口工作方式1 TMOD = 0x20; // 设置定时器1工作方式2 TH1 = 0xFD; // 设置波特率为9600 TL1 = 0xFD; TR1 = 1; // 启动定时器1 ES = 1; // 开启串口中断 EA = 1; // 开启总中断 } void UART_SendByte(uchar dat) { SBUF = dat; while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/310760228e3aaaef5d094dfe64a6e330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa092bb2d1c541c774eca631087e6e0/" rel="bookmark">
			基于51单片机的多功能密码锁控制系统设计与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、摘要 随着科技的不断发展，人们对安全的需求越来越高，密码锁作为一种常见的安全设备，已经广泛应用于各个领域。本文主要研究了基于51单片机的多功能密码锁控制系统设计与应用。首先，对51单片机进行了简单的介绍，然后分析了密码锁的工作原理和设计要求。接着，详细介绍了基于51单片机的多功能密码锁控制系统的硬件设计和软件设计。最后，通过实际测试验证了系统的可行性和稳定性。
二、引言 密码锁是一种常见的安全设备，它可以根据用户输入的密码进行解锁。随着单片机技术的不断发展，基于单片机的密码锁已经成为了一种主流的解决方案。51单片机作为一种经典的单片机，具有性能稳定、资源丰富、易于开发等优点，因此在密码锁中得到了广泛的应用。
三、系统设计 3.1 系统总体设计
本系统主要由51单片机、按键输入模块、LCD显示模块、继电器控制模块等部分组成。按键输入模块用于用户输入密码；LCD显示模块用于显示系统状态和提示信息；继电器控制模块用于实现对门锁的控制。
3.2 硬件设计
（1）51单片机：本系统采用AT89S52单片机作为控制核心，具有较高的性价比和丰富的外设资源。
（2）按键输入模块：本系统采用矩阵键盘作为按键输入模块，可以实现多键输入。
（3）LCD显示模块：本系统采用1602液晶显示器作为LCD显示模块，可以实现中英文字符的显示。
（4）继电器控制模块：本系统采用电磁继电器作为执行元件，实现对门锁的控制。
3.3 软件设计
本系统的软件主要包括按键扫描程序、LCD显示程序和继电器控制程序。按键扫描程序用于检测用户输入的密码；LCD显示程序用于显示系统状态和提示信息；继电器控制程序根据按键扫描程序的输出结果控制继电器的开关状态，从而实现对门锁的控制。
四、系统测试与分析 为了验证系统的可行性和稳定性，我们对系统进行了实际测试。测试结果表明，本系统能够根据用户输入的密码进行解锁，实现了预期的功能。同时，系统运行稳定，响应速度快，具有较高的实用价值。
#include &lt;reg52.h&gt; #include &lt;intrins.h&gt; typedef unsigned char uchar; typedef unsigned int uint; sbit key1 = P3^0; sbit key2 = P3^1; sbit key3 = P3^2; sbit key4 = P3^3; sbit key5 = P3^4; sbit key6 = P3^5; sbit key7 = P3^6; sbit key8 = P3^7; sbit door_lock = P1^0; uchar password[8] = {1, 2, 3, 4, 5, 6, 7, 8}; // 设置密码为12345678 uchar input_password[8]; // 存储用户输入的密码 uchar input_index = 0; // 当前输入密码的位置 uchar correct_flag = 0; // 密码是否正确的标志位 void delay(uint z) // 延时函数 { uint x, y; for (x = z; x &gt; 0; x--) for (y = 110; y &gt; 0; y--); } void keyscan() // 按键扫描函数 { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffa092bb2d1c541c774eca631087e6e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/800838e28727cbe982d7606210935f33/" rel="bookmark">
			当 OpenTelemetry 遇上阿里云 Prometheus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01 背景 在云原生可观测蓬勃发展的当下，想必大家对 OpenTelemetry &amp; Prometheus 并不是太陌生。OpenTelemetry 是 CNCF（Cloud Native Computing Foundation）旗下的开源项目，它的目标是在云原生时代成为应用性能监控领域的事实标准，它提供了一套统一的 API 和 SDK，用于生成、收集和处理分布式系统的遥测数据。总而言之，OpenTelemetry 是一套观察性的标准，具有语言无关性，支持各种编程语言和框架，并可与多种观察平台集成。
而 Prometheus 作为目前最受欢迎的开源监控系统，并且已经被 Kubernetes、Envoy 等广泛使用的云原生项目所采用。虽然 Prometheus 的查询语言十分强大，但是其数据格式还是 Prometheus 自己定义的。因此，它只能与 Prometheus 服务器集成，不能与其他系统集成。
而 OpenTelemetry 承诺在 Trace、Log 和 Metric 之间创建一个统一标准，所以它的数据格式是统一的，并具有足够的灵活性与交互性，同时完全兼容 Prometheus，所以吸引越来越多的开发运维人员使用 OpenTelemetry 在承载 Trace &amp; Log 同时将其用于 Metric 的统计，与 Prometheus 生态进行结合，实现更好的观测监控。
本文以构建系统可观测（重点为指标监控体系）为切入点，对比 OpenTelemetry 与 Prometheus 的相同与差异，粗浅的谈下个人选择的一些观点与看法；后重点介绍如何将应用的 OpenTelemetry 指标接入 Prometheus 及背后原理，最后介绍阿里云可观测监控 Prometheus 版拥抱 OpenTelemetry 及相关落地实践案例，希望能更好的帮助读者更好的理解 OpenTelemetry 及与 Prometheus 的生态融合。
02 站在 OpenTelemetry 与 Prometheus 的十字路口 如果你作为研发运维人员在进行系统观测时，特别是构建指标监控体系时，会有很多困惑，到底选择 OpenTelemetry 还是 Prometheus。在回答这个问题之前我们首先需要明确的了解 OpenTelemetry 与 Prometheus 的同异。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/800838e28727cbe982d7606210935f33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74942bef2e1daafb98218f214dd113bf/" rel="bookmark">
			C语言 linux文件操作（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、linux文件权限1.1文件描述符1.2文件描述符的范围和默认值1.3打开文件和文件描述符1.4标准文件描述符1.5文件描述符的重定向和关闭1.6I/O 操作1.7使用文件描述符进行进程通信1.8资源限制 二、C语言文件读写2.1open 函数2.2 flags参数详解2.3 lseek 函数 一、linux文件权限 字符表示法 二进制 十进制 说明 r - - 100 4 仅可读 - w - 010 2 仅可写 - - x 001 1 仅可执行 r w - 110 6 可读可写 r - x 101 5 可读可执行 - w x 011 3 可写可执行 r w x 111 7 可读可写可执行 - - - 000 0 无权限 1.1文件描述符 在 Linux 系统中，文件描述符是用于访问文件、设备、套接字和其他 I/O 资源的抽象概念。它是一个非负整数，用于唯一标识一个打开的文件或者 I/O 通道。Linux 将所有的 I/O 资源（包括文件、管道、套接字等）都视为文件，并通过文件描述符进行访问。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74942bef2e1daafb98218f214dd113bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e700444309b2b9f3755072b047eda9/" rel="bookmark">
			百度营销发布“品牌智能体”，打造“五项全能”的品牌数字分身
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成式AI时代，品牌营销如何持续出彩？全能的品牌数字分身长什么样？12月27日，百度营销“品牌智能体生成式AI产品发布会” 在北京举行。会上，百度营销正式发布“品牌智能体”，全新的“品牌智能体”依托于百度生成式AI技术，具备感知、记忆、规划、行动、人格五大能力，致力于打造全能的品牌数字分身。
百度MEG销售业务平台行业五部总经理戴振开表示：品牌智能体会成为品牌与用户对话的新窗口，推动传统营销向AI营销转型，引领品牌营销进入新时代。百度品牌营销业务负责人陆毅明也认为，智能体是AI时代最佳应用载体，就好像PC时代的官网，移动互联网时代的APP一样。未来，每一个客户都应该拥有自己的智能体营销阵地。
此前，百度营销发布了全新品牌价值主张“生成商业新未来”，并在商业生态中推进了理念、技术、功能等全方位的重塑；在品牌营销侧，携手洋河、飞鹤等公司首创智能体开屏及品专产品，联合海尔、京东等品牌低成本生成爆款品牌方案。百度营销借助品牌智能体，正在打造品牌AGI时代最核心的经营阵地。
品牌智能体发布，打造“五项全能”的数字分身
全新发布的“品牌智能体”，具备感知、记忆、规划、行动、人格五大能力全面提升，重点打造品牌最懂用户的品牌数字分身。
其中，感知能力提升意味着智能体具备多模态的输入能力，可以催生AIGC多重玩法；记忆能力提升，意味着智能体具备长期记忆，更懂用户；规划能力提升，意味着可以引导人机多轮交互、拆解目标、生成决策；调用工具能力，可以为用户提供端到端的品牌服务体验；人格能力的提升，意味着更为写实、个性化的数字人成为品牌专属数字分身。
同时，品牌智能体也将带来场景的全新升级。
例如，智能体将生成新品牌专区、超级品专子卡和通用词品专，深度理解用户行为、意图，生成个性化内容，并规划用户决策路径，实现交互式需求激发；智能体还可以生成新展示广告，深度理解用户所属决策阶段，千人千面地推送品牌相关内容并进行需求激发。
除此之外，品牌智能体生成了品牌的新经营阵地。在品牌智能体和文心一言APP等新场景下，除了对话式交互，还支持图文、视频等多模态交互，通过双向深度交互，智能体能主动感知、规划并激发用户需求，引导用户加速消费决策。
赋能品牌营销全链路，洋河、飞鹤等率先入局
品牌智能体营销平台将赋能品牌从用户洞察、创意生成、媒介投放到效果验证，全链路实现生成式AI营销，成为品牌最核心的经营阵地。截至目前，已经有洋河、飞鹤、京东、海尔等多个品牌合作体验。
例如，百度联合洋河打造了AI Native全场景的营销事件，致敬航天事业，庆祝宇航员回归。百度帮助洋河品牌利用AI生成图和视频，搭建AI元宇宙品牌展馆，沉浸式互动引流，还搭建了线上AI互动界面和首个对话式航天科普活动，运用大模型能力实现航天科普知识智能对话。
一些品牌还通过品牌智能体营销用低成本打造出了“爆款”营销事件。如百度联合海尔兄弟，打造“有模有young” 生成式作画挑战赛，以海尔兄弟形象进行AI二创，趣味生图；618期间，百度为京东打造电商首个AI生成线下广告，减少了70%的海报制作周期，并降低了80%的海报制作成本。
同时，百度营销科学AIA也进行了全新升级，成为服务于“智能体商业”理念实践的重要营销方法论。
以飞鹤品牌为例，用户带着具体的使用场景和问题与智能体像朋友一样沟通，不仅话题更聚焦产品和购买，还通过多轮次的对话，与用户建立了更紧密的连接，对话内容也更有温度，这种体验是传统线上广告无法比拟的。通过营销科学AIA的洞察与分析，用户形象与诉求更加清晰明确；基于洞察，还可以帮助品牌打造更符合用户需求的传播策略，以及更丰富的营销玩法，为客户找到生意的新增量。
智能体如何“生成商业新未来”
在11月举办的2023百度热AI营销大会上，百度营销发布全新品牌价值主张——“生成商业新未来”。 百度集团副总裁、移动生态商业体系负责人王凤阳认为，随着用户需求表达方式的变迁，客户服务经营会向“智能体商业”的方向演变。对于“商业新未来”的发展方向，百度给出的答案就是“智能体商业”。
一方面，基于文心大模型的能力，所有企业都可以在百度拥有专属分身智能体，能够以最佳方式与用户进行自主交流，激发用户需求、提供极致服务；另一方面，百度营销以轻舸作为与客户交互的统一载体，可以深刻理解和满足客户需求。智能体与轻舸相互协作，形成正向循环，一起构建出“智能体商业”的生命力。
近期，智能体已经应用到一众品牌伙伴和文心一言APP等百度AI原生应用中。未来，智能体将协同品牌更好地满足用户需求，做到交互出彩、品牌出新、生意出效，改变行业仅仅关注运营流量的现状，更好地从用户需求出发，挖掘“流量”背后具体的“人”的需求，生成品牌经营的新未来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c62ce478ea866ae16f008db91b86c362/" rel="bookmark">
			Fiddler工具 — 2.补充：HTTP协议介绍（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HTTP协议介绍 HTTP协议是Hyper Text Transfer Protocol(超文本传输协议)的缩写，是用于从万维网(WWW:World Wide Web )服务器传输超文本（也可以说是资源）到本地浏览器的传送协议。
HTTP协议是基于TCP协议的应用层协议，它不关心数据在底层传输的细节（底层细节需要很多网络方面的知识，这里不扩展说明），主要是用来规定客户端和服务端的数据传输格式（就是定义一种标准），默认端口是80。
http是基于请求与响应模式的、无状态的、应用层的协议。
2、使用Fiddler抓取一个请求 开启Fiddler工具，在浏览器中发送一个HTTP请求，之后在Fiddler中就会抓取到该请求。
双击抓取的请求链接，在右侧窗口就会显示出该请求的请求报文和响应报文内容，如下图：
如果你想学习fiddler抓包，我这边给你推荐一套视频，这个视频可以说是B站播放全网第一的fiddler抓包教程，同时在线人数到达1000人，并且还有笔记可以领取及各路大神技术交流：798478386 2024备战金三银四，最新版fiddler抓包实战教程！_哔哩哔哩_bilibili2024备战金三银四，最新版fiddler抓包实战教程！共计8条视频，包括：1、fiddler和F12抓包对比、2、Fiddler工作原理、3、配置证书抓取https包等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV19j411J7oc/?spm_id_from=333.337.search-card.all.click
我们也可以一个请求保存到本地，
选中该HTTP请求，点击右键 —&gt; Save —&gt; Selected Sessions —&gt; as Text...
把该HTTP请求的请求报文和响应报文存储到一个text文件中。
===========请求报文：也就是客户端发给服务器的数据============= GET http://127.0.0.1:8000/api/departments/ HTTP/1.1 Host: 127.0.0.1:8000 Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.108 Safari/537.36 Upgrade-Insecure-Requests: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 =========响应报文：======================= HTTP/1.0 200 OK Date: Wed, 13 Jan 2021 14:59:00 GMT Server: WSGIServer/0.2 CPython/3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c62ce478ea866ae16f008db91b86c362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cca52d06bb00dd56489a13e7393f774f/" rel="bookmark">
			SuperMap Hi-Fi 3D SDK for Unreal游戏引擎打包常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：gsh 目录
前言
常见问题
1. UE打包报错：ERROR: No target name was specified on the command-line.
2. UE打包报错：ERROR: Expecting to find a type to be declared in a module rules named ‘XXX’
3. UE打包报错：Error: System.ArgumentException: An item with the same key has already been added. Key: PakLoader
4.UE打包报错：ERROR: More than one Game project found for project:
5. UE打包报错：uproject does not look like uproject file but no targets have been found!
6.使用超图UE插件对白膜进行材质贴图后打包成功后运行，但白膜没有材质贴图，如何解决。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cca52d06bb00dd56489a13e7393f774f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb012193fb506721c34eda6e3f0c0a8b/" rel="bookmark">
			自动备份B站Up主最新视频到百度网盘的Python脚本详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动备份B站Up主最新视频脚本详解（Win和Linux有些不同） 前言：
次篇文章启发于某些大胆的UP主（老马）的多次被封，并被下架一些视频。有些人并不能及时观看到，故写一个脚本自动下载最新视频。
🌀1.准备环境 Win和Linux都需要：
Python3 运行需要Selenium 操作浏览器(pip下载)BeautifulSoup4 解析出最新视频链接(pip下载)you-get 下载视(pip下载)bypy 上传百度网盘(pip下载)Chrome/FireFox/Edge… 一款主流浏览器（和其对应driver） Win额外：
Git(非必须) 参考文档及链接
Selenium With Python使用Selenium with Python — Selenium Python Bindings 2 documentation (selenium-python.readthedocs.io)
BeautifulSoup4使用Beautiful Soup Documentation — Beautiful Soup 4.4.0 documentation (beautiful-soup-4.readthedocs.io)
you-get使用github.com
bypy使用github.com
🅰️2.编写主脚本(Python) from selenium import webdriver #此处以FireFox为例，需要安装浏览器，和对应的geckodriver,(浏览器不同需要不同的driver) from selenium.webdriver.firefox.options import Options #切换浏览器操作，例：from selenium.webdriver.Edge.options(Edge浏览器) from bs4 import BeautifulSoup import time import subprocess from datetime import datetime print('---------') #记录Log文件 def DoLog(isSuccess): dt = datetime.now() strformat = dt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb012193fb506721c34eda6e3f0c0a8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/043bdc2b4d0b11f2395e779a675744a9/" rel="bookmark">
			qt获取多窗口中活动窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给活动窗口发送按键事件，直接上测试代码
QWidget *activeWindow; QList&lt;QWidget*&gt; topLevelWidgets = qApp-&gt;topLevelWidgets(); foreach (QWidget *widget, topLevelWidgets) { // 这是活动窗口 if (widget-&gt;isActiveWindow()) { activeWindow=widget; } } if (activeWindow) { // 输出当前活动窗口的标题 qDebug() &lt;&lt; "Active Window Title: " &lt;&lt; activeWindow-&gt;windowTitle(); // 创建一个按键事件 QKeyEvent keyEvent(QEvent::KeyPress, Qt::Key_A, Qt::NoModifier); // 发送按键事件到拥有焦点的窗口 QGuiApplication::sendEvent(activeWindow, &amp;keyEvent); } else { qDebug() &lt;&lt; "No active window."; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e0ded9185adb1fe9320457405a1d5c/" rel="bookmark">
			Spring@Scheduled定时任务与SQLSERVER distinct order by的错误吞噬
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
@Scheduled 提供的调度机制
遇到错误不会抛出
数据库SQL差异
@Scheduled 提供的调度机制 cronzonefixedDelayfixedDelayStringfixedRatefixedRateStringinitialDelayinitialDelayString 上面具体怎么用自己代码定位到API上去看注释说明。
遇到错误不会抛出 在SqlServer中执行一个查询，SELECT DISTINCT A from table order by createTime 类似这样的查询会提示createTime 没有包含到查询结果列问题。
此时 定时任务执行到这个错误的Sql语句代码处就结束了线程，等待下一次执行了，没有任何异常产生，真的有点怀疑是Spring及@Scheduled策略使用不当造成的。
经过排查确实不是@Scheduled使用策略问题，按照需要我用的是fixedDelay，只有当方法都执行完成才会去等待下一次调度任务处理。
数据库SQL差异 在MySQL中，不会要求排序列必须出现在distinct的查询结果集里面。而SqlServer是要求必须要出现在查询结果列。
MySql的截图：
SqlServer的截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10af7f744ca9caa6b7cf3b5c1669388f/" rel="bookmark">
			spring-session升级之坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 因为某些组件低版本存在漏洞问题，本次对项目的springboot版本从1.x升级到了2.x，因为其他相关的中间件也随着一起升级，在升级最后发现项目用户信息无法获取到了。
问题描述 接口获取用户信息报错，获取用户信息是通过spring-session-data-redis 中间件进行处理的。升级前spring-session的版本是1.3，升级到2.x之后就获取不到用户信息了。
问题代码：
((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest().getSession() 原因分析： 当然问题代码我们定位到了，是获取不到session，因为使用了spring-session中间件，因此问题肯定就出在从redis中获取失败了。（因为保存的用户信息是在另一个项目，这个项目是没有动的，所以我们能明确是从redis中获取用户信息失败了）
先说源码跟踪结论:
版本升级前的key生成逻辑为: “spring:session:” + namespace + “:”+“sessions:” + sessionId
升级后的key生成逻辑为：namespace + “:”+“sessions:” + sessionId
切换到版本升级前（spring-session 1.3），梳理redis获取用户信息逻辑：
debug getSession 进入到SessionRepositoryFilter 中getSession方法，具体代码如下
public SessionRepositoryFilter&lt;S&gt;..SessionRepositoryRequestWrapper.HttpSessionWrapper getSession(boolean create) { SessionRepositoryFilter&lt;S&gt;..SessionRepositoryRequestWrapper.HttpSessionWrapper currentSession = this.getCurrentSession(); if (currentSession != null) { return currentSession; } else { //获取sessionId，继续debug深入，会发现本项目使用的是HeaderHttpSessionStrategy实现类，配置的是header中的token作为requestedSessionId String requestedSessionId = this.getRequestedSessionId(); ExpiringSession session; if (requestedSessionId != null &amp;&amp; this.getAttribute(SessionRepositoryFilter.INVALID_SESSION_ID_ATTR) == null) { // debug本行代码会发现，这个地方就开始从redis获取用户信息了，所以下面一行的代码就非常的关键了 session = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10af7f744ca9caa6b7cf3b5c1669388f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c03800a9804d08622b221a15f0b2ff5/" rel="bookmark">
			基于51单片机的智能交通信号灯控制系统设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能交通信号灯控制系统是一种基于单片机的自动控制系统，主要用于实现道路交通信号灯的智能化管理。该系统可以根据实时交通流量、道路状况和行人需求等因素，自动调整信号灯的工作状态，从而提高道路通行效率，减少交通拥堵和事故发生。
设计一个基于单片机的智能交通信号灯控制系统，主要包括以下几个部分：
1. 硬件设计：包括单片机、传感器、执行器等部件的选择和连接。单片机是整个系统的核心，负责处理各种输入信号并控制输出设备。传感器用于检测交通流量、道路状况和行人需求等信息，执行器则用于控制信号灯的工作状态。
2. 软件设计：主要包括单片机程序的设计和编写。程序需要实现以下功能：
a) 数据采集：通过传感器采集实时交通流量、道路状况和行人需求等信息。
b) 数据处理：对采集到的数据进行处理，如滤波、放大等操作，以提高数据的准确性和可靠性。
c) 控制策略：根据处理后的数据，制定合适的控制策略，如红绿灯切换时间、优先级等。
d) 输出控制：将控制策略转换为信号灯的实际工作状态，如红灯、绿灯、黄灯等。
3. 系统调试与优化：在硬件和软件设计完成后，需要对整个系统进行调试和优化，以确保系统的稳定性和可靠性。调试过程中可能需要对硬件电路、传感器和执行器进行调整，对软件程序进行修改和完善。
4. 系统集成与测试：将各个模块集成到一个整体系统中，并进行全面的测试，以验证系统的性能和功能是否达到预期目标。测试过程中可能需要对系统进行多次调整和优化，以满足实际应用的需求。
总之，设计一个基于单片机的智能交通信号灯控制系统，需要充分考虑硬件和软件的设计、调试与优化以及系统集成与测试等方面的问题。通过合理的设计和优化，可以实现交通信号灯的智能化管理，提高道路通行效率，减少交通拥堵和事故发生。
#include &lt;reg52.h&gt; #include &lt;intrins.h&gt; typedef unsigned char uchar; typedef unsigned int uint; sbit red = P1^0; sbit yellow = P1^1; sbit green = P1^2; uchar traffic_light_state[3] = {0, 1, 2}; // 红绿黄状态数组 uchar current_state = 0; // 当前状态指针 void delay(uint z) { uint x, y; for (x = z; x &gt; 0; x--) for (y = 110; y &gt; 0; y--); } void main() { while (1) { red = 0; green = 1; yellow = 1; delay(1000); // 红灯亮1秒 red = 1; green = 0; yellow = 1; delay(500); // 黄灯亮半秒 red = 1; green = 1; yellow = 0; delay(500); // 绿灯亮半秒 current_state++; // 切换到下一个状态 if (current_state &gt;= 3) current_state = 0; // 如果到达最后一个状态，回到第一个状态 } } 这个示例代码实现了一个简单的红绿黄交通信号灯控制系统，通过循环切换红绿黄三种状态，实现交通信号灯的自动控制。实际应用中可能需要考虑更多的因素，如行人过街按钮、交通流量检测等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e865b5c7365e9761979a51210e6d6fba/" rel="bookmark">
			关于react
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.快速搭建开发环境 2.react渲染流程 3.1 jsx基础 概念 3.2 jsx基础 本质 3.3 jsx基础 jsx表达式 3.4 jsx基础 实现列表渲染 3.5 jsx基础 实现条件渲染 3.5 jsx基础 实现复杂的条件渲染 4. react中事件绑定 5.react组建基础使用 6.1 useState 6.2 useState修改状态的规则 7.基础样式控制 8.1评论案例–删除列表 8.2评论案例–tab切换 8.2评论案例–排序 $ npm i --save lodash //安装lodash import _ from 'loadsh';//引入loadsh 9.classnames优化类名控制 npm install classnames //安装classnames import classNames from 'classnames';//引入classnames 10.受控表单绑定 11.react中获取DOM 11.1 react中组件通信—父传子 //1. 父组件传递数据 - 在子组件标签上绑定属性 //2. 子组件接收数据 - 子组件通过props参数接收数据 //JSX //子组件 function Son(props){ return &lt;div&gt;{ props.name }&lt;/div&gt; } //父组件 function App(){ const name = 'this is app name' return ( &lt;div&gt; &lt;Son name={name}/&gt; &lt;/div&gt; ) } 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e865b5c7365e9761979a51210e6d6fba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b188a858143d2823c21b9c2b0555de23/" rel="bookmark">
			配置IPv6静态路由示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、静态路由简介 静态路由是一种需要管理员手工配置的特殊路由。
静态路由在不同网络环境中有不同的目的：
当网络结构比较简单时，只需配置静态路由就可以使网络正常工作。
在复杂网络环境中，配置静态路由可以改进网络的性能，并可为重要的应用保证带宽。
静态路由可在VPN实例中使用，主要用于VPN路由的管理。
2、静态路由基础 路由器根据路由转发数据包，路由可通过手动配置或使用动态路由算法计算产生，其中手动配置的路由就是静态路由。
与动态路由相比，静态路由配置简单、可控性高、使用带宽少，并且不占用CPU资源来计算和分析路由更新。但是当网络发生故障或者拓扑发生变化后，静态路由不会自动更新，必须重新手动配置。因此，静态路由不适用于大型和复杂的网络环境。一方面，网络管理员难以全面地了解整个网络的拓扑结构；另一方面，当网络的拓扑结构或链路状态发生变化时，路由器中的静态路由信息需要大范围地调整，这一工作的难度和复杂程度非常高。
静态路由有五个主要的参数：目的地址和掩码、出接口和下一跳地址、优先级。
3、出接口和下一跳地址 在配置静态路由时，根据不同的出接口类型，指定出接口和下一跳地址。
对于点到点类型的接口，只需指定出接口。因为指定发送接口即隐含指定了下一跳地址，这时认为与该接口相连的对端接口地址就是路由的下一跳地址。
对于NBMA（Non Broadcast Multiple Access）类型的接口（如ATM接口），配置下一跳IP地址。因为这类接口支持点到多点网络，除了配置静态路由外，还需在链路层建立IP地址到链路层地址的映射，这种情况下，不需要指定出接口。
对于广播类型的接口（如以太网接口），必须指定通过该接口发送时对应的下一跳地址。因为以太网接口是广播类型的接口，会导致出现多个下一跳，无法唯一确定下一跳。
4、静态路由优先级 对于不同的静态路由，可以为它们配置不同的优先级，优先级数字越小优先级越高。配置到达相同目的地的多条静态路由，如果指定相同优先级，则可实现负载分担；如果指定不同优先级，则可实现路由备份。
5、实验案例 实验拓扑： 1、S1配置 ##基础IP地址配置 [S1]vlan batch 10 20 [S1]ipv6 [S1]int Vlanif 10	[S1-Vlanif10]ipv6 enable [S1-Vlanif10]ipv6 add fc00:0:0:2001::1 64 [S1-Vlanif10]q [S1]interface Vlanif 20 [S1-Vlanif20]ipv6 enable [S1-Vlanif20]ipv6 add fc00:0:0:2010::1 64 [S1-Vlanif20]q [S1]int g0/0/1 [S1-GigabitEthernet0/0/1]port link-type trunk [S1-GigabitEthernet0/0/1]port trunk allow-pass vlan 20 [S1-GigabitEthernet0/0/1]q [S1]int g0/0/2 [S1-GigabitEthernet0/0/2]port link-type trunk [S1-GigabitEthernet0/0/2]port trunk allow-pass vlan 10 [S1-GigabitEthernet0/0/2]q 配置默认路由下一跳为S2交换机
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b188a858143d2823c21b9c2b0555de23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b151a3aedb4ad60ad7ad3ec4f0b20d5/" rel="bookmark">
			算法设计与分析 | 矩阵连乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 一个n*m矩阵由n行m列共n*m个数排列而成。两个矩阵A和B可以相乘当且仅当A的列数等于B的行数。一个N*M的矩阵乘以一个M*P的矩阵等于一个N*P的矩阵，运算量为nmp。
矩阵乘法满足结合律，A*B*C可以表示成(A*B)*C或者是A*(B*C)，两者的运算量却不同。例如当A=2*3 B=3*4 C=4*5时，(A*B)*C=64而A*(B*C)=90。显然第一种顺序节省运算量。
现在给出N个矩阵，并输入N+1个数，第i个矩阵是a[i-1]*a[i]
输入 第一行n(n&lt;=100)
第二行n+1个数
输出 最优的运算量
样例输入 3 2 3 4 5 样例输出 64 分析：
其实该题使用了动态规划来选出最优子结构，并且使用了以下等式：
先初始化m数组和s数组，这里使用了C++的函数memset():
void* memset(void* s, int c, size_t n);
参数解释：
- `s`：指向要填充的内存区域的指针。
- `c`：要设置的字符值（实际上是将其转换为对应的ASCII码或字节值）。
- `n`：要填充的字节数。
`memset`函数将`s`指向的内存区域的前`n`个字节用`c`指定的值进行填充。返回值是原始的`s`指针。
并且m矩阵里面其实填充的是矩阵的右上角的部分，如可以看作下图这样：
代码：
//矩阵连乘 #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; const int size = 101; int p[size]; int m[size][size], s[size][size]; int n; void matrixchain() { int i, r, j, k; memset(m, 0, sizeof(m)); memset(s, 0, sizeof(s));//初始化数组 for (r = 2; r &lt;= n; r++)//矩阵连乘的规模为r { for (i = 1; i &lt;= n - r + 1; i++) { j = i + r - 1; m[i][j] = m[i + 1][j] + p[i - 1] * p[i] * p[j];//对m[][]开始赋值 s[i][j] = i;//s[][]存储各子问题的决策点 for (k = i + 1; k &lt; j; k++)//寻找最优值 { int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; if (t &lt; m[i][j]) { m[i][j] = t; s[i][j] = k; } } } } } int main() { cin &gt;&gt; n; int i, j; for (i = 0; i &lt;= n; i++) cin &gt;&gt; p[i]; matrixchain(); cout &lt;&lt; m[1][n] &lt;&lt; endl; return 0; } 参考博文：动态规划之——矩阵连乘（全网最详细博文，看这一篇就够了！）_矩阵连乘问题-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f146d4b01985956e698ef6d82a658ef3/" rel="bookmark">
			算法与数据结构之算法基础（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是数据结构？
什么是算法？
1、算法的特性
1.1 五个特征
1.2 设计原则
1.3 评价算法的两个总要指标：时间复杂度和空间复杂度
2、时间复杂度分析
2.1 时间复杂度表示方法：大O表示法
2.2 时间复杂度如何分析
2.3 复杂度比较
2.4 时间复杂度分析
3、空间复杂度分析
什么是数据结构？ 就是一组能组在一起的集合对象。比如数组、链表、队列等。
什么是算法？ 就是解决问题的
1、算法的特性 1.1 五个特征 有穷性、确定性、可行性、有输入、有输出
while(true){}//死循环，不是算法 1.2 设计原则 正确性、可读性、健壮性（bug）：写出的代码很少有bug，且系统比较稳定
高效率与低存储：内存+CPU（内存占用最小，CPU占用最小，运算速度最快）
1.3 评价算法的两个总要指标：时间复杂度和空间复杂度 时间复杂度：运行一个程序所花费的时间，O()表示
空间复杂度：运行程序所需要的内存（尽可能避免出现OOM（内存溢出））
2、时间复杂度分析 2.1 时间复杂度表示方法：大O表示法 O(1),O(n),O(logn),O(nlogn),O(n^2),O(2^n)
2.2 时间复杂度如何分析 （1）找for、while、递归，而且要找循环量大的那一段
（2）有网络请求的地方（http，rpc远程调用，数据库请求）
就是测试时间：打印log，计算平均时间
2.3 复杂度比较 O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3)
2.4 时间复杂度分析 计算时间复杂度 往往是计算比较大的 而且是不确定的数，如果已经确定了，那么就不用计算了，也是我们说的常量。
常数级O(1)
public static void main(String[] args) { int a = 1; //1次 O(1) for(int i = 0 ;i &lt; 3;i++){//这里会运行几次？4次 在第4次的时候结束 跳出 i=3 (0 1 2 3) a = a + 1; //这里运行几次？ 3次 O(1)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f146d4b01985956e698ef6d82a658ef3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16ca3ea691b31f84debe7b0ac4e1d5a9/" rel="bookmark">
			Mybatis Java API - SqlSession
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正如前面提到的，​SqlSession​实例是MyBatis中最重要、最强大的类。它是您将找到执行语句、提交或回滚事务以及获取映射器实例的所有方法的地方。
`SqlSession` 类上有超过二十个方法，让我们将它们分成更易理解的组别。
Statement Execution Methods-语句执行方法 这些方法用于执行在SQL映射XML文件中定义的SELECT、INSERT、UPDATE和DELETE语句。它们相当直观，每个方法都接受语句的ID和参数对象作为输入，参数对象可以是基本类型（自动装箱或包装类）、JavaBean、POJO或Map。
&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement, Object parameter) &lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, Object parameter, String mapKey) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) selectOne和selectList之间的区别仅在于selectOne必须返回一个对象或null（没有结果）。如果返回多个对象，将抛出异常。如果不知道期望的对象数量，可以使用selectList。如果想要检查对象是否存在，最好返回一个计数（0或1）。selectMap是一个特殊情况，它被设计用于根据结果对象中的某个属性将结果列表转换为Map。由于并不是所有语句都需要参数，因此这些方法提供了无需参数对象的重载版本。
insert、update和delete方法返回的值表示受影响的行数。
&lt;T&gt; T selectOne(String statement) &lt;E&gt; List&lt;E&gt; selectList(String statement) &lt;T&gt; Cursor&lt;T&gt; selectCursor(String statement) &lt;K,V&gt; Map&lt;K,V&gt; selectMap(String statement, String mapKey) int insert(String statement) int update(String statement) int delete(String statement) 游标（Cursor）提供与列表（List）相同的结果，但它使用迭代器（Iterator）来惰性获取数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16ca3ea691b31f84debe7b0ac4e1d5a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02553a60db0b6437608f749daa684d4/" rel="bookmark">
			pytorch机器学习各种激活函数总结（不完整学习更新中~）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch各种激活函数总结 0.思维导图预览1. ReLU函数2. Sigmoid函数3. Softmax函数4. Tanh函数5.（学习后更新） 0.思维导图预览 1. ReLU函数 ReLU（Rectified Linear Unit）线性整流函数
其公式为：
f ( x ) = M a x ( 0 , x ) f(x)=Max(0,x) f(x)=Max(0,x)
它将小于零的输入映射为0，而将大于等于零的输入保持不变。在PyTorch中，可以使用torch.nn.ReLU类来表示。
ReLU函数求导简单方便；但是当反向传播过程中，权值更新小于0时，导致该处的导数始终为0，无法更新权值，会进入失活状态。
AlexNet就用的是ReLU函数
2. Sigmoid函数 Sigmoid函数将输入值压缩到0和1之间，在PyTorch中，可以使用torch.nn.Sigmoid类来表示。
其公式为：
f ( x ) = 1 1 + e − x f(x)=\frac{1}{1+\mathcal{e}^{-x}} f(x)=1+e−x1​
Sigmoid函数的优点是输出范围在(0, 1)之间，可以将输入映射到概率形式或者用于二分类问题中。
缺点是激活函数饱和时，梯度非常小，网络层数较深时容易出现梯度消失。
3. Softmax函数 Softmax函数将输入值转换为概率分布，用于多分类问题。在PyTorch中，可以使用torch.nn.Softmax类来表示。Softmax函数将原始的实数向量转换为表示概率分布的向量，使每个元素的取值范围≥0，并且所有元素的和等于1。
其公式为：
对于输入向量 z = ( z 1 , z 2 , … , z k − 1 ) \mathbf{z} = (z_1, z_2, \ldots, z_{k-1}) z=(z1​,z2​,…,zk−1​)，Softmax函数对应的输出向量 y = ( y 1 , y 2 , … , y n ) \mathbf{y} = (y_1, y_2, \ldots, y_n) y=(y1​,y2​,…,yn​) 的计算公式为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d02553a60db0b6437608f749daa684d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62369f6f846024e529b2d95c4ed8edb/" rel="bookmark">
			电气产品外壳常用材质PA、PC、PBT、ABS究竟是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在如今工业制造领域，各种改性塑料、复合材料以及轻质合金材料的运用日趋成熟。在电气领域，不同电气产品的外壳、组件材质采用不同材料，以同为科技（TOWE）电气产品为例，工业连接器系列产品采用PA6外壳材质、机柜PDU功能输出组件及智能开关插座系列产品采用PC合金材料、电源浪涌保护器则采用PBT外壳材质……那么，这些常见的电气产品所采用的不同材质分别是什么意思？使用起来分别有哪些优点？下面一起来看看吧！
1.ABS塑料材质 （1）ABS是丙烯腈(A)-丁二烯(B)-苯乙烯(S)的三元共聚物，其结合了三种组分的性能，是一种。强度高、韧性好、综合性能优良的树脂，用途广泛，常用作工程塑料。ABS材质具有较好的成型性能，可生产出各种形状和颜色的产品，在工业中应用极为广泛。（2）优点：ABS材料的综合性能较好，冲击强度较高，化学稳定性，电性能良好；有高抗冲、高耐热、阻燃、增强、透明等特性，可在大多数环境下使用；缺点：质量重、导热性能欠佳、可燃性高、易受溶剂腐蚀。（3）应用：电器外壳、电子产品零件、箱体零部件、仪表壳等。
2.PC材质 （1）PC塑料是分子链中含有碳酸酯基的高分子聚合物，根据酯基的结构可分为脂肪族、芳香族、脂肪族-芳香族等多种类型，是一种新型的热塑性塑料，透明度达90%，被誉为是透明金属。它刚硬而具有韧性，具有较高的冲击强度，高度的尺寸稳定性和范围很宽的使用温度、良好的电绝缘性能及耐热性和无毒性。（2）优点：PC材料是一种综合性能优良的非晶型热塑性树脂，具有优异的电绝缘性、延伸性、尺寸稳定性及耐化学腐蚀性，较高的强度、耐热性和耐寒性；还具有自熄、阻燃、无毒、可着色等优点；缺点：易受紫外线影响、不耐强酸强碱、价格较高。（3）应用：电机壳、电工用具、医疗器材、绝缘接插件、线圈框架、绝缘套管、信号继电器等。
3.PA材质 （1）聚酰胺俗称尼龙（Nylon），英文名称Polyamide（简称PA），是分子主链上含有重复酰胺基团—[NHCO]—的热塑性树脂总称，其主要品种有尼龙6、尼龙66、尼龙11、尼龙12、尼龙610、尼龙612、尼龙46、尼龙1010等。其中尼龙6、尼龙66产量最高，占尼龙产量的90%以上。PA材质在聚酰胺纤维基础上发展起来的，是最早出现能承受载荷的热塑性塑料，也是五大通用工程塑料中产量最大、品种最多、用途最广的品种。（2）优点：轻质高强度、耐磨耐腐蚀、耐高温性能、良好的机械性能、易于加工；缺点：易吸水、耐光性较差、不耐强酸、氧化剂、价格较昂贵、设计技术要求较严。（3）应用：用作各种机械和电器零件，其中包括轴承、齿轮、滑轮泵叶轮、叶片、高压密封圈、垫、阀座、衬套、输油管、贮油器、绳索、传动带、砂轮胶粘剂、电池箱、电器线圈、电缆接头等。
4.PBT材质 （1）PBT塑料是指聚对苯二甲酸丁二醇酯为主体所构成的一类塑料。聚对苯二甲酸丁二醇酯,又名聚对苯二甲酸四次甲基酯。简称PBT，其密度为1.30～1.38g/cm³，结晶熔点为220～267℃，具有优良的抗冲击性能。PBT和PET一起被称为热塑性聚酯，多用于热塑性工程聚合物绝缘子的电气和电子行业。
（2）优点：PBT材料具有优异的防污性、刚度比与耐冲击性、高韧性强度、易于加工、阻挡紫外线敷设、高电绝缘性能；
缺点：高温燃烧释放有毒物质、对水具有吸收性、价格较高。
（3）应用：集成电路插座、电器开关、熔断器、温控开关、保护器、电子电器、精密仪器部件等。
由上可知，在实际应用中，没有一种工程塑料的性能是完美，我们应当根据自身的实际需求和应用场景，来选择合适的产品材质，以达到更好的使用效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df6cd407acef5422a937c0b83d5dde19/" rel="bookmark">
			八数码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八数码问题
在3x3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数
字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题
是:给出一个初始状态和一个目标状态，找出一一种从初始转变成目标状态的移动棋子步数
最少的移动步骤。下图展示了其中一种可能的初始及目标状态(仅作示例)。要求: 初始状态目标状态1.能处理任意的初始状态和目标状态组合
2.如果可以找到从初始状态到目标状态的移动方法，依次输出移动步骤;否则，输出“无法完成”
提示:可以使用盲目搜索列举所有可能，再比较移动步数;也可以尝试《人工智能基础》课程讲述的启发式算法直接求解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8a41072c315290e551cc5d89884b49/" rel="bookmark">
			Python入门实战：python的下载、安装及环境配置详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**🌳🌳🌳****Python是一种具有简单性、易用性、高效率和广泛应用前景的通用编程语言。它被誉为“优雅”、“明确”、“简单”，并具有支持多种编程范式（如面向对象、函数式、脚本化）的能力。此外，Python还拥有庞大的第三方库和用户社区。在数据分析、机器学习、科学计算等领域有着广泛的应用。例如，pandas、numpy、matplotlib、scikit-learn、tensorflow、keras等。🌳🌳🌳
这篇博客的主要内容是Python语言的下载安装方式；
说明：本人的操作系统是win10 64位，我要下载64位python。
📝1.首先要在windows部署python环境
①.官网链接下载Python
根据你的 Windows 版本 （64位还是32位） 从Python 的官网下载对应的 Python 3.9 ，地址如下，以下为部分版本链接，可以根据个人需求安装对应版本。
这里插播一条：
操作系统的位数可通过以下操作确定：右击此电脑 -&gt; 点击属性 -&gt; 查看位数；一般是64位
Python 官网链接 https://www.python.org/
Python 3.9安装链接 https://www.python.org/downloads/release/python-390/ （Python Release Python 3.9.0 | Python.org）
Python 3.10安装链接 https://www.python.org/downloads/release/python-3100/ （Python Release Python 3.10.0 | Python.org）
②.进入 Python 官网 点击下载
③.进入下载 向下寻找特定版本这边小编选择的是 3.9
④.选择Windows 64位安装包
⑤.点击下载好的安装包
特别要注意勾上Add Python 3.9to PATH，然后“lnstall Now”即可完成安装.默认会安装到 C：\Python39 目录下.
⑥.安装完成后， 打开命令提示符窗口（方法是点击“开始”-“运行”-输入：“cmd”）
⑦.输入 “python” -&gt; 按回车键，若出现下图显示的信息，表明安装成功（命令行变为三个大于号）。
⑧.安装成功！！！
看都看到这里啦留个三连再走吧！！你们的支****持就是我的动力！！！
若显示下图的信息，则需要手动配置环境变量（参考下一节）。
原因是在安装Python时，没有选中“Add Python 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8a41072c315290e551cc5d89884b49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee84894a10611c9493efec17afbc2472/" rel="bookmark">
			STL——stack容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.stack基本概念 概念：stack是一种先进后出（First In Last Out,FILO）的数据结构，它只有一个出口。
栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为。
栈中进入数据称为——入栈（push）
栈中弹出数据称为——出栈（pop）
2.stack常用接口 构造函数：
stack&lt;T&gt; stk; ——//stack采用模板类实现， stack对象的默认构造形式stack(const stack &amp;stk);—— //拷贝构造函数 赋值操作：
stack&amp; operator=(const stack &amp;stk); ——//重载等号操作符 数据存取：
push(elem);—— //向栈顶添加元素pop(); ——//从栈顶移除第一个元素top(); ——//返回栈顶元素 大小操作：
empty();—— //判断堆栈是否为空size(); ——//返回栈的大小 #include&lt;iostream&gt; using namespace std; #include&lt;stack&gt; //栈stack容器 void test() { stack&lt;int&gt;s; //入栈 s.push(10); s.push(20); s.push(30); s.push(40); cout &lt;&lt; "栈的大小为：" &lt;&lt; s.size() &lt;&lt; endl; //只要栈不为空，查看栈顶，并且执行出栈操作 while (!s.empty()) { //查看栈顶元素 cout &lt;&lt; "栈顶元素为：" &lt;&lt; s.top() &lt;&lt; endl; //出栈 s.pop(); } cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee84894a10611c9493efec17afbc2472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/311a3790100934edf60b29c9a5a16042/" rel="bookmark">
			Git基础学习_p1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、Git手册学习2.1 Git介绍&amp;前置知识2.2 Git教程2.2.1 导入新项目2.2.2 做更改2.2.3 Git追踪内容而非文件2.2.4 查看项目历史2.2.5 管理分支🔺2.2.6 用Git来协同工作2.2.7 查看历史 三、结尾 一、前言 Git相信大部分从事软件工作的人都听说过，甚至用过。
它是一款版本控制软件，用于管理项目迭代更新。
但大部分时候，你可能只是用过。就我个人而言，能想起来并知道其用途的，就下面几个简单命令，
git init git pull git add git commit git push 还有git remote、git branch等命令会偶尔用一下，但使用时都得上网查询。
虽然大部分情况下，这已经够了。
但偶尔会出现一些特殊情况，可能是操作时序有误导致的冲突，可能是项目真的有损坏。
当然本文并不需要解决这些问题，只是想通过文档学习，对git流程、git基础有个更全面的了解。
我打算从git介绍、git简单命令、git文档教程入手，对git进行进一步学习。
二、Git手册学习 git，是一个傻瓜式的内容跟踪器（Linux内核的首席架构师，也是Git的主要开发者Linus Torvalds是这么说的）。
使用简介如下：
git [-v | --version] [-h | --help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] [--config-env=&lt;name&gt;=&lt;envvar&gt;] &lt;command&gt; [&lt;args&gt;] 这一长串的命令选项，可以看出其功能之强大，虽然这也不是给一般人用的。不过也别被吓到，根据八二定理，大部分情况下你只需要用到几条简单命令即可，而且现在有许多带GUI的git，图形化操作相对简单许多（即使如此，你还是需要了解Git基本流程）。
2.1 Git介绍&amp;前置知识 Git是一个快速、可扩展、分布式版本控制系统，具有异常丰富的命令集，提供高级操作以及对内部的完全访问。
文档建议从 gittutorial 开始学习，不过在这之前，还有一个非常重要的前置知识，那就是Git的二区一库。
二区是指，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/311a3790100934edf60b29c9a5a16042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9899bbfab9e93b5cbf7a082724c6f0d2/" rel="bookmark">
			Spring Boot 自动配置功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 自动配置功能介绍 Spring Boot 是一个流行的 Java 开发框架，它提供了许多便利的功能和工具，帮助开发者快速构建应用程序。其中一个最引人注目的特性是其强大的自动配置功能。
什么是自动配置？ 在传统的 Java 开发中，我们通常需要手动配置应用程序的各个组件和依赖项。这可能涉及到编写大量的配置代码，导致开发过程变得繁琐和复杂。Spring Boot 的自动配置功能旨在解决这个问题。
自动配置是 Spring Boot 在启动过程中根据应用程序的类路径和依赖关系，自动推断和配置应用程序所需的各种组件和功能。它通过约定大于配置的原则，为开发者提供了一种零配置或最小配置的开发体验。
自动配置的优势 使用 Spring Boot 的自动配置功能，开发者可以获得以下优势：
简化配置: 自动配置遵循一组默认规则，根据应用程序的需求自动配置各个组件。开发者不再需要手动编写大量的配置代码，可以专注于业务逻辑的实现。
快速入门: Spring Boot 提供了许多 Starter 依赖，这些依赖项预先配置了常用的组件和功能。开发者只需要添加适当的 Starter 依赖，即可快速搭建一个可运行的应用程序。
灵活性: 尽管 Spring Boot 提供了自动配置，但它也允许开发者通过自定义配置来覆盖默认行为。这使得开发者可以根据自己的需求进行微调和定制。
生态系统支持: Spring Boot 的自动配置功能与许多流行的第三方库和框架紧密集成。这意味着开发者可以轻松地集成各种功能，如数据库访问、消息队列、安全性等。
如何使用自动配置 使用 Spring Boot 的自动配置功能非常简单。只需遵循以下步骤：
添加 Spring Boot Starter 依赖到你的项目中。例如，如果你要构建一个 Web 应用程序，可以添加 spring-boot-starter-web 依赖。
在应用程序的主类上添加 @SpringBootApplication 注解。这个注解将启用自动配置，并扫描应用程序中的组件。
根据需要，可以添加其他的 Starter 依赖或自定义配置来扩展和定制应用程序的功能。
运行应用程序。Spring Boot 将根据你的依赖和配置，自动配置并启动应用程序。
总结 Spring Boot 的自动配置功能是它的一大亮点，极大地简化了 Java 应用程序的开发过程。它通过约定大于配置的原则，帮助开发者快速构建可运行的应用程序，同时保持灵活性和扩展性。如果你还没有尝试过 Spring Boot 的自动配置功能，我强烈建议你在下一个项目中尝试一下，体验它带来的便利和效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c35fc685af031292a208cc4852668902/" rel="bookmark">
			pytest文档内置fixture的request详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 request 是 pytest 的内置 fixture ， "为请求对象提供对请求测试上下文的访问权，并且在fixture被间接参数化的情况下具有可选的“param”属性。"这是官方文档对request的描述，可参考的文档不多。
一、FixtureRequest FixtureRequest 是来自 fixture 或者 测试用例的请求，它有访问测试上下文的权限, FixtureRequest_pytest.fixtures pytest documentation。
class FixtureRequest：请求对象提供对请求的测试上下文的访问，并且具有可选的 param 属性，以防设备被间接参数化。
fixturename：正在为其执行此请求的 fixture 名称。
scope：作用域字符串，“function”、“class”、“module”、“session”之一。
fixturenames：此请求中所有活动状态的 fixture 的名称。
node：基础集合节点（取决于当前请求范围）。
config：与此请求关联的 pytest 配置对象。
function：如果请求具有每个函数范围，则测试函数对象。
cls：类（可以是None），其中收集了测试函数。
instance：在其上收集测试函数的实例（可以是None）。
module：收集测试函数的Python模块对象。
fspath：收集此测试的测试模块的文件系统路径。
keywords：基础节点的关键字/标记词典。
session：Pytest会话对象。
addfinalizer(finalizer: 添加finalizer/teardown函数，以便在请求的测试上下文中的最后一个测试完成执行后调用。
applymarker(marker)：对单个测试函数调用应用标记。
如果不希望在所有函数调用上都有关键字/标记，则此方法非常有用。 参数：
marker -- A _pytest.mark.MarkDecorator 调用创建的对象 pytest.mark.NAME(...) .raiseerror(msg: Optional[str]) ：使用给定的消息引发FixtureLookupError。getfixturevalue(argname: str) 动态运行命名的fixture函数。 如果可能，建议通过函数参数声明fixtures。但是，如果您只能在测试设置时决定是否使用另一个fixture，那么您可以使用此函数在fixture或测试函数体中检索它。
引发：pytest.FixtureLookupError -- 如果找不到给定的固定装置。
折叠 二、request.param 前面讲fixture参数化的时候，有接触到 "request.param" 用于获取测试的请求参数，以下示例
1
2
3
4
5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c35fc685af031292a208cc4852668902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97cb786a2e42e5c74a7d34ade331239/" rel="bookmark">
			腾讯云轻量应用服务器详细配置教程(最新版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云轻量应用服务器开箱即用、运维简单的轻量级云服务器，CPU内存带宽配置高并且价格特别便宜，大带宽，但是限制月流量。轻量2核2G3M带宽62元一年、2核2G4M优惠价118元一年，540元三年、2核4G5M带宽218元一年，756元3年、4核8G12M带宽646元15个月等，还有8核16G18M和16核32G28M配置可选，腾讯云服务器网txyfwq.com分享腾讯云轻量应用服务器详细介绍、轻量服务器优缺点大全：
一：轻量应用服务器简介 轻量应用服务器（TencentCloud Lighthouse）是新一代开箱即用、面向轻量应用场景的云服务器产品，助力中小企业和开发者便捷高效的在云端构建网站、Web应用、小程序/小游戏、APP、电商应用、云盘/图床和开发测试环境，相比普通云服务器更加简单易用且更贴近应用，以套餐形式整体售卖云资源并提供高带宽流量包，将热门开源软件打包实现一键构建应用，提供极简上云体验。详细参考官方页面 https://curl.qcloud.com/8Eps6xac
腾讯云轻量应用服务器
二：轻量应用服务器购买指南 腾讯云轻量应用服务器购买指南，有两个入口，一个是在特价活动上购买，一个是在轻量应用服务器官方页面购买，特价活动上购买价格更便宜，轻量2核2G3M带宽服务器62元一年起。
购买入口1：轻量服务器特价活动入口 特价活动 https://curl.qcloud.com/oRMoSucP 活动上的轻量应用服务器价格便宜，轻量2核2G3M带宽62元一年、2核2G4M价格是118元一年，三年540元，2核4G5M带宽价格是218元一年，如下图：
腾讯云轻量应用服务器优惠价格
购买入口2：轻量服务器官方页面购买 轻量官方页面 https://curl.qcloud.com/8Eps6xac 然后点立即选购即可。
三：轻量应用服务器新手部署教程 腾讯云轻量应用服务器支持多种镜像应用模板，通过镜像可以一键部署所需环境，例如可以通过镜像的方式来一键部署宝塔Linux面板、WordPress、WooCommerce、OpenFaaS、SRS音视频服务器、Typecho、Cloudreve、Matomo、LAMP、Node.js、Cloud Studio、Theia IDE、Docker CE、K3s、长安链ChainMaker、宝塔Windows面板和ASP.NET等，如下图：
腾讯云轻量应用服务器镜像应用模板
使用腾讯云轻量应用服务器建站、搭建开发环境、搭建云盘、搭建电商平台、部署宝塔Linux面板、使用Lightwings构建应用等，教程https://curl.qcloud.com/ITm0yCyp
使用 WordPress 应用模板搭建网站使用 Typecho 应用模板搭建博客使用 Matomo 应用模板搭建网站流量统计系统使用 Theia IDE 应用模板搭建云端 IDE 环境搭建 LAMP 开发环境搭建 Node.js 开发环境搭建 ASP.NET 开发环境使用应用模板搭建 Docker 容器环境使用应用镜像实践 K3s 容器集群管理基于 Cloud Studio 搭建云端 IDE 环境使用 Cloudreve 应用模板搭建云盘使用 WooCommerce 应用模板搭建电商独立站搭建跨境电商店铺管理环境使用宝塔 Linux 面板管理服务器安装和配置宝塔 Linux 面板腾讯云专享版使用宝塔 Linux 面板快速迁移网站使用 Lightwings 构建应用使用 OpenFaaS 部署云函数使用 SRS 应用模板搭建个人直播间轻量应用服务器挂载 CFS 文件系统安装 Docker 并配置镜像加速源搭建 Ubuntu 可视化界面Linux 轻量应用服务器搭建 FTP 服务Windows 轻量应用服务器搭建 FTP 服务安装 SSL 证书Nginx 服务器证书安装Apache 服务器证书安装（Linux）Apache 服务器证书安装（Windows）使用互动直播房间服务应用模板快速搭建小直播后台 上述教程请移步：https://curl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f97cb786a2e42e5c74a7d34ade331239/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3856a71ad2d43f62c38e2e4db9775c72/" rel="bookmark">
			R语言【base】——dir.exists()和dir.create()目录和文件权限的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Package base version 4.3.2
Parameters dir.exists(paths) dir.create(path, showWarnings = TRUE, recursive = FALSE, mode = "0777") Sys.chmod(paths, mode = "0777", use_umask = TRUE) Sys.umask(mode = NA) 参数【path】：是一个字符向量，包含一个路径名。
参数【paths】：字符向量，其中包含文件或目录路径。
参数【showWarnings】：逻辑值。是否应显示失败警告？
参数【recursive】：逻辑值。是否应该创建路径中除最后一个元素之外的其他元素？如果为 TRUE，就像 Unix 命令 mkdir -p。
参数【mode】：在 Unix-alikes 上使用的模式：它将被 as.octmode 强制使用。对于 Sys.chmod，它将沿路径循环使用。
参数【use_umask】：逻辑值。模式是否应受 umask 设置的限制？
dir.exists 检查路径是否存在（与 file.exists 意义相同），并且是目录。
dir.create 会创建路径的最后一个元素，除非参数【recursive】= TRUE。路径分隔符尾部将被丢弃。在 Windows 环境下，路径指定中允许包含驱动器，除非路径是根目录，否则将相对于该驱动器上的当前目录进行解释。在 Windows 环境下，模式将被忽略。
Windows 的一个怪癖是，目录创建可能会报告成功，但创建的目录名却不一样，例如，dir.create("G.S.") 创建的是""G.S""。这是无记录的，具体情况尚不清楚（可能取决于 Windows 的版本）。此外，还要避免目录名尾部有空格。
Sys.chmod 设置一个或多个文件的权限。Windows 系统函数对参数【mode】的解释是非 POSIX 的，只支持设置文件的只读属性。因此，R 对参数【mode】的解释是，当且仅当 (mode &amp; 0200) == 0（以八进制解释）时，设置为只读。Windows 在某些文件系统（如 NTFS 版本）上有一个更为广泛的文件权限系统，与此系统调用无关。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3856a71ad2d43f62c38e2e4db9775c72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83ae707408d71ebe64e8eed1e5461f55/" rel="bookmark">
			前端基础：Vue搞笑白话文(工作之余瞎写)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、data:{}与data(){return{}}这两个是个什么鬼？ vue实例 new Vue({ el:'#app', data:{ name:'李四' } }) 组件实例 const aaa = Vue.extent({ data(){ return { name:'' } } }) 为什么Vue实例可以那么写而组件实例就不行了？原因就是因为在底层原理上，组件是可以复用的，如果你把组件搞成相互可以变化就完了，看一下下边这些代码。
let x1 = { a:1, b:2 } let x2 = {} x2 = x1 x1.a = 99 console.log('获取内容', x1, x2) 这是为什么呢？这个牵扯到我们引用类型的变量直接给另外一个人相当于地址给了其他人，你把门的钥匙给了其他人这怎么能行呢？咱们改造一下。
function x1() { return { a:1, b:2 } } let x2 = x1() let x3 = x1() x3.a = 99 console.log('获取内容', x3, x2) 可以了， 这么神奇呢，其实就是相当于把主人通过一个函数给，而非像之前的直接自己给，所以在it的世界中，我们想要复用，用function return就是可以了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83ae707408d71ebe64e8eed1e5461f55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7b28a15ba1001167a85a8d64c6e895/" rel="bookmark">
			链路层、网络层、传输层、应用层长度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：链路层、网络层、传输层、应用层长度
链接：https://blog.csdn.net/qq_41658597/article/details/120683870
目录 1、概述2、TCP、UDP数据包最大值的确定3、TCP、UDP数据包最小值的确定4、实际应用IP层 1、概述 首先要看TCP/IP协议，涉及到四层：链路层，网络层，传输层，应用层。 以太网（Ethernet）的数据帧在链路层 IP包在网络层 TCP或UDP包在传输层 TCP或UDP中的数据（Data)在应用层 它们的关系是 数据帧｛IP包｛TCP或UDP包｛Data｝｝｝
不同的协议层对数据包有不同的称谓，在传输层叫做段(segment)，在网络层叫做数据报(datagram)，在链路层叫做帧(frame)。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。
在应用程序中我们用到的Data的长度最大是多少，直接取决于底层的限制。我们从下到上分析一下：
1、链路层，由以太网的物理特性决定了数据帧的长度为(46＋18)－(1500＋18)，其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500(不包括帧头和帧尾)，即MTU(Maximum Transmission Unit)为1500； 2、网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480；　3、传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；
所以，在应用层，你的Data最大长度为1472。当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片fragmentation进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃。
从上面的分析来看，在普通的局域网环境下，UDP的数据最大为1472字节最好(避免分片重组)。
但在网络编程中，Internet中的路由器可能有设置成不同的值(小于默认值)，Internet上的标准MTU值为576，所以Internet的UDP编程时数据长度最好在576－20－8＝548字节以内。
MSS的主要作用是限制另一端主机发送的数据的长度，同时，主机本身也控制自己发送数据报的长度，这将使以较小MTU连接到一个网络上的主机避免分段。
MTU的含义: MAC帧内的数据(Payload)字段的最大长度。
2、TCP、UDP数据包最大值的确定 UDP和TCP协议利用端口号实现多项应用同时发送和接收数据。数据通过源端口发送出去，通过目标端口接收。有的网络应用只能使用预留或注册的静态端口；而另外一些网络应用则可以使用未被注册的动态端口。因为UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535。
MTU最大传输单元，这个最大传输单元实际上和链路层协议有着密切的关系，EthernetII帧的结构DMAC+SMAC+Type+Data+CRC由于以太网传输电气方面的限制，每个以太网帧都有最小的大小64Bytes最大不能超过1518Bytes，对于小于或者大于这个限制的以太网帧我们都可以视之为错误的数据帧，一般的以太网转发设备会丢弃这些数据帧。
由于以太网EthernetII最大的数据帧是1518Bytes这样，刨去以太网帧的帧头（DMAC目的MAC地址48bits=6Bytes+SMAC源MAC地址48bits=6Bytes+Type域2Bytes）14Bytes和帧尾CRC校验部分4Bytes那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值我们就把它称之为MTU。
链路层帧的大小 1500(不包括帧头、帧尾)
UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) =1472(Bytes)
TCP 包的大小就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)
注*PPPoE所谓PPPoE就是在以太网上面跑“PPP”。随着宽带接入（这种宽带接入一般为Cable Modem或者xDSL或者以太网的接入），因为以太网缺乏认证计费机制而传统运营商是通过PPP协议来对拨号等接入服务进行认证计费的，所以引入PPPoE。PPPoE导致MTU变小了以太网的MTU是1500，再减去PPP的包头包尾的开销（8Bytes），就变成1492。不过目前大多数的路由设备的MTU都为1500。
如果我们定义的TCP和UDP包没有超过范围，那么我们的包在IP层就不用分包了，这样传输过程中就避免了在IP层组包发生的错误；如果超过范围，既IP数据报大于1500字节，发送方IP层就需要将数据包分成若干片，而接收方IP层就需要进行数据报的重组。更严重的是，如果使用UDP协议，当IP层组包发生错误，那么包就会被丢弃。接收方无法重组数据报，将导致丢弃整个IP数据报。UDP不保证可靠传输；但是TCP发生组包错误时，该包会被重传，保证可靠传输。
UDP数据报的长度是指包括报头和数据部分在内的总字节数，其中报头长度固定，数据部分可变。数据报的最大长度根据操作环境的不同而各异。从理论上说，包含报头在内的数据报的最大长度为65535字节(64K)。
我们在用Socket编程时，UDP协议要求包小于64K。TCP没有限定，TCP包头中就没有“包长度”字段，而完全依靠IP层去处理分帧。这就是为什么TCP常常被称作一种“流协议”的原因，开发者在使用TCP服务的时候，不必去关心数据包的大小，只需讲SOCKET看作一条数据流的入口，往里面放数据就是了，TCP协议本身会进行拥塞/流量控制。
不过鉴于Internet(非局域网)上的标准MTU值为576字节，所以建议在进行Internet的UDP编程时，最好将UDP的数据长度控制在548字节 (576-8-20)以内。
3、TCP、UDP数据包最小值的确定 在用UDP局域网通信时，经常发生“Hello World”来进行测试，但是“Hello World”并不满足最小有效数据(64-46)的要求，为什么小于18个字节，对方仍然可用收到呢？因为在链路层的MAC子层中会进行数据补齐，不足18个字节的用0补齐。但当服务器在公网，客户端在内网，发生小于18个字节的数据，就会出现接收端收不到数据的情况。
以太网EthernetII规定，以太网帧数据域部分最小为46字节，也就是以太网帧最小是6＋6＋2＋46＋4＝64。除去4个字节的FCS，因此，抓包时就是60字节。当数据字段的长度小于46字节时，MAC子层就会在数据字段的后面填充以满足数据帧长不小于64字节。由于填充数据是由MAC子层负责，也就是设备驱动程序。不同的抓包程序和设备驱动程序所处的优先层次可能不同，抓包程序的优先级可能比设备驱动程序更高，也就是说，我们的抓包程序可能在设备驱动程序还没有填充不到64字节的帧的时候，抓包程序已经捕获了数据。因此不同的抓包工具抓到的数据帧的大小可能不同。下列是本人分别用wireshark和sniffer抓包的结果，对于TCP 的ACK确认帧的大小一个是54字节，一个是60字节，wireshark抓取时没有填充数据段，sniffer抓取时有填充数据段。
4、实际应用 用UDP协议发送时，用sendto函数最大能发送数据的长度为：65535- IP头(20) - UDP头(8)＝65507字节。用sendto函数发送数据时，如果发送数据长度大于该值，则函数会返回错误。
用TCP协议发送时，由于TCP是数据流协议，因此不存在包大小的限制（暂不考虑缓冲区的大小），这是指在用send函数时，数据长度参数不受限制。而实际上，所指定的这段数据并不一定会一次性发送出去，如果这段数据比较长，会被分段发送，如果比较短，可能会等待和下一次数据一起发送。
也就是说以链路数据帧的长度必须在46-1500字节之间,这个1500字节被称为链路层的MTU(最大传输单元)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de7b28a15ba1001167a85a8d64c6e895/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/417816280920124d652610b706b551d6/" rel="bookmark">
			IntelliJ IDE 插件开发 | （四）开发一个时间管理大师插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章 IntelliJ IDE 插件开发 |（一）快速入门IntelliJ IDE 插件开发 |（二）UI 界面与数据持久化IntelliJ IDE 插件开发 |（三）消息通知与事件监听IntelliJ IDE 插件开发 |（四）开发一个时间管理大师插件 前言 在上篇文章的结尾提到本文将参考 VS Code 中 TimerMaster 插件的实现效果来实现一个在 IDEA 中统计编码情况的插件，TimerMaster 的效果如下：
本文最终实现的插件效果如下（增加了 CV 操作和代码提交的统计😎）：
由于本文涉及到大部分知识都是在前几篇文章中介绍过的，因此本文只对关键功能点和实现方式进行介绍，一些基础知识和配置就不再讲解，该插件的完整代码已上传到GitHub。
实现思路 在开发前，正如前言中提到的，是参考 TimerMaster 的实现效果。因此首先确认了要实现的功能如下：
可以统计当天、昨天、过去七天和每天平均的代码活动。统计项包括编辑器使用/活跃时间、添加/删除的代码行数、总的键入数、扩展增加了 CV(懂得都懂) 和代码提交活动的统计。通过点击右键菜单项后在控制台进行展示。 对于第一点，主要通过本地持久化数据进行实现，当天数据和历史数据分别进行存储(选择了 JSON 格式进行存储)，然后按需取用进行统计即可。
对于第二点，涉及的功能较多，这里分开进行介绍：
编辑器使用/活跃时间
增加一个对项目生命周期的监听器，在启动事件中注册一个定时任务，每隔 n 秒(可配置)将使用时间增加 n 秒。增加一个对文档和游标位置的监听器，只要有文档操作或者游标的移动都认为是活跃状态，然后更新最新操作时间，在定时任务中会将当前时间和最新操作时间进行比较，如果不大于 m 秒(可配置)就认为编辑器处于活跃状态，并将活跃时间增加 n 秒。
添加/删除的代码行数、总的键入数
通过增加对文档的监听器，根据变更内容中的换行数目得到添加/删除的代码行数，同时根据变更内容长度是否为 1 或者为空白符来决定是否增加键入数。
CV 统计
增加一个对复制粘贴事件的监听器，分别在复制和粘贴事件中增加相应的次数。
代码提交统计
监听自带 GIT 插件提供的 PUSH 事件监听器，在提交完成事件中增加对提交提交次数的统计。
对于第三点，只需要增加一个 action 并绑定到右键菜单，然后通过 ToolWindowFactory 获取到控制台视图来输出计算得到的结果即可。
根据个人需求，统计每天最早/最晚运行时间、活跃时间段、数据云存储等也很容易实现，本文就不进行拓展了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/417816280920124d652610b706b551d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8489895bce5c31a8eda67c2bc5e1ec88/" rel="bookmark">
			发明专利如何挖掘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发明专利如何挖掘 本文将介绍如何挖掘发明专利，如何在生活中，工作中，有效结合研发工作，挖掘发明专利，从而对知识产权进行保护。
文章目录 发明专利如何挖掘一、发明专利是什么？二、如何挖掘总结 一、发明专利是什么？ 发明专利要求发明具有新颖性、创造性和实用性。新颖性要求发明在申请日前未被公开披露过；创造性要求发明具有相对于现有技术的显著进步；实用性要求发明可以在工业上应用。
发明专利可以涵盖各种技术领域，例如机械、电子、化学、生物等。它可以保护各种发明，包括新产品、新工艺、新装置、新材料等。
二、如何挖掘 对于发明专利，我先提一下自己的几个观点：
1.首先，大部分的发明专利都属于微创新，并不是完全独特，完全独创的东西，对于已有方案，已有方法的优化也包括在内。当然如果可以做到完全创新就更好了
2.第二，发明并非需要实现，新颖合理的想法也可以申请
3.一般来说，一个发明专利要提供多个创新点，较深入细致的提出创新点，所以要求大家悉知，精准的挖掘亮点
对于挖掘发明专利可以通过以下几个步骤进行：
1.这一点我觉得最为重要，因为专利申请是要付费的，没有良好的专利布局，进行专利申请无法有效形成企业的竞争优势。 因此第一点是确定领域：首先确定你想要挖掘的发明专利的领域，可以是特定的技术领域，行业或市场领域。
数据收集：收集相关的专利数据库和文献，例如专利数据库、科技文献数据库等。这些数据库可以提供已经授予的专利以及已发表的科技文献，来了解当前领域的技术发展和市场状况。
分析和筛选：根据你的研究目标，对收集到的专利和文献进行分析和筛选。可以使用关键词搜索，筛选出与你的研究领域相关的专利和文献，并对其进行详细阅读和分析。
评估创新性：对筛选出的专利进行创新性评估，确定是否存在已有解决方案或相似技术。可以使用专利检索工具，如专利家等，来检索已有相关专利，并对其进行比较和评估。
可行性评估：对挖掘到的发明专利进行可行性评估。评估其技术可行性、商业可行性和法律可行性等方面，确定其是否具有商业化和实施的潜力。
价值评估：对挖掘到的发明专利进行价值评估，确定其在市场上的价值和潜在收益。可以考虑专利的技术先进性、市场需求、竞争状况等因素。
保护专利：如果确定挖掘到的发明专利具有商业化和实施的潜力，可以考虑申请专利保护，以保护你的创新成果。
商业化和实施：最后，根据评估结果决定是否商业化和实施挖掘到的发明专利。可以考虑找到合作伙伴、投资者或进行自主开发等方式来推动专利的商业化和实施。
总结 希望小伙伴们对于专利申请中的问题可以大家一起讨论，这里提供下我的微信号SpringWa1tz，有问题大家一起讨论，哈哈哈，完成工作指标
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6f47ac52da6f6cfca5ca8074d8de6c1/" rel="bookmark">
			JVM系列-方法区、堆区、栈区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Java 中，内存主要分为方法区、堆区和栈区，每个区域负责不同类型的数据和任务。以下是它们的主要特征：
1. 方法区（Method Area） 方法区是 JVM 的一部分，用于存储类的元数据信息、静态变量、常量池等。在 Java 8 及之前的版本，永久代（PermGen）被用作方法区的一部分，用于存储类的元数据和静态变量。在 Java 8 及之后的版本，永久代被元空间（Metaspace）取代。Metaspace 是堆外内存的一部分，用于存储类的元数据信息。 2. 堆区（Heap） 堆区是用于存储对象实例的内存区域。所有通过 `new` 关键字创建的对象都存储在堆区中。堆区分为年轻代和老年代。年轻代包括 Eden 区和两个 Survivor 区，用于存储新创建的对象。老年代用于存储经过多次垃圾回收后仍然存活的对象。堆区的大小可以通过 JVM 启动参数进行调整。 3. 栈区（Stack） 栈区是线程私有的，用于存储方法的局部变量、操作数栈、方法出口等。每个线程都有自己的栈。栈中的局部变量包括基本数据类型和对象引用。当一个方法被调用时，会创建一个栈帧，栈帧中包含了方法的局部变量和执行信息。栈是一个后进先出（LIFO）的数据结构，方法的调用和返回都是通过栈来实现的。 需要注意的是，方法区、堆区和栈区的划分是一种逻辑上的概念，在具体的 JVM 实现中可能有所不同。不同的 JVM 实现可能采用不同的内存管理机制和结构。例如，一些 JVM 实现可能对方法区的内存管理采用永久代，而另一些可能使用元空间。
（来源：chatgpt的回答）这些要怎么记得住呢，看了很多遍内存的介绍，都记不住。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/869b5319529901f4620853f90d519e6a/" rel="bookmark">
			数据可视化能为我们带来哪些好处？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在信息爆炸的时代，数据量呈指数级增长，企业和个人都面临着处理大量信息的挑战。在这个背景下，数据可视化崭露头角，成为解决复杂数据呈现和理解难题的得力工具。那么，数据可视化究竟能为我们带来哪些好处呢？
首先，数据可视化让抽象的数据变得直观而生动。通过图表、图形、热力图等方式，数据可视化将枯燥的数字呈现得形象生动，让人一目了然地理解数据的趋势和关联关系。这不仅让决策者更容易理解复杂的数据，也让普通人能够参与到数据分析中来，提高了信息的传递效率。其次，数据可视化有助于发现隐藏在数据背后的模式和趋势。通过对数据进行可视化分析，人们可以更容易地发现关键的数据模式，从而做出更明智的决策。这对于企业优化运营、改进产品设计、提高市场竞争力都具有重要作用。
此外，数据可视化提高了沟通效率。面对大量的数据，传统的文字报告难免显得啰嗦沉闷。而通过图表和图形的展示，复杂的数据变得简单易懂，有效提升了信息传递的效果。在企业会议、学术研究、市场报告等场景下，数据可视化成为信息传递的得力助手。数据可视化还有助于及时发现问题。通过实时监控仪表盘，人们可以迅速发现异常情况，及时采取行动。这在企业管理、网络安全等领域都有着积极的作用，帮助人们更敏锐地感知和解决问题。
最后，数据可视化为创新提供了新的可能性。通过将数据以新颖的方式可视化呈现，人们能够发现之前未曾想到的关系和规律，从而激发新的创意和解决方案。这对于推动科学研究、产品创新等方面都有积极的推动作用。
这里惯例推荐一下山海鲸可视化这款数据可视化软件，它的数据可视化相关编辑功能全部可以免费使用，并且没有任何限制，甚至如果你制作的是纯二维项目，那么私有化部署也是完全免费的。那么三维项目呢？尽管三维项目无法像二维项目一样免费部署，但是仍然可以免费编辑制作，只是最终导出后会存在水印。不过与同类产品相比，山海鲸可视化的免费化程度可以说是相当高了。
综合来看，数据可视化不仅是信息时代的必然产物，更是我们理解和应对数据时的得力工具。它的出现让数据变得更加生动、直观，为我们带来了更高效、更精准的信息处理体验。在未来，随着技术的不断进步，数据可视化必将为我们开启更广阔的数据探索之旅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f78a2a8f063c38fbd7279fe2e886f75/" rel="bookmark">
			中间件系列 - Redis入门到实战(原理篇)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学习视频： 黑马程序员Redis入门到实战教程，深度透析redis底层原理+redis分布式锁+企业解决方案+黑马点评实战项目
中间件系列 - Redis入门到实战
本内容仅用于个人学习笔记，如有侵扰，联系删除
学习目标
Redis数据结构Redis网络模型Redis通信协议-RESP协议 1 Redis数据结构 1.1 动态字符串 我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。
不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：
获取字符串长度的需要通过运算非二进制安全不可修改 Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。
例如，我们执行命令：
那么Redis将在底层创建两个SDS，其中一个是包含“name”的SDS，另一个是包含“虎哥”的SDS。
Redis是C语言实现的，其中SDS是一个结构体，源码如下：
例如，一个包含字符串“name”的sds结构如下：
SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：
假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：
如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；
如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。
1.2 intset IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。
结构如下：
其中的encoding包含三种模式，表示存储的整数大小不同：
现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是INTSET_ENC_INT16，每部分占用的字节大小为：
encoding：4字节
length：4字节
contents：2字节 * 3 = 6字节
我们向该其中添加一个数字：50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。
以当前案例来说流程如下：
升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组倒序依次将数组中的元素拷贝到扩容后的正确位置将待添加的元素放入数组末尾最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4
源码如下：
小总结：
Intset可以看做是特殊的整数数组，具备一些特点：
Redis会确保Intset中的元素唯一、有序具备类型升级机制，可以节省内存空间底层采用二分查找方式来查询 1.3 Dict 我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。
Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）
当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1=v1，假设k1的哈希值h =1，则1&amp;3 =1，因此k1=v1要存储到数组角标1位置。
Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）
Dict的扩容
Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。
Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发哈希表扩容：
哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f78a2a8f063c38fbd7279fe2e886f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fce429ab7b627d261e568f6dfa6111a/" rel="bookmark">
			VSCODE : SSH远程配置&#43;免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH基础配置 填入地址，回车
ssh user@host-or-ip 然后选择默认的配置，回车，得到以下结果：
点击链接
选择远程的系统
输入密码
免密登录 生成SSH密钥：
首先，确保你已经在本地生成了SSH密钥。你可以使用以下命令生成SSH密钥： (base) ubuntu@ubuntu-3090x2:~$ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/home/ubuntu/.ssh/id_rsa): /home/ubuntu/.ssh/id_rsa already exists. Overwrite (y/n)? n (base) ubuntu@ubuntu-3090x2:~$ cd /home/ubuntu/.ssh (base) ubuntu@ubuntu-3090x2:~/.ssh$ ls authorized_keys id_rsa id_rsa.pub known_hosts 创建authorized_keys文件： cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 将SSH私钥下载到本地并添加到VSCODEconfig： Host ************ HostName ************ User ubuntu IdentityFile "C:\Users\using\Documents\remote\id_rsa" 经过以上操作即可免密登录了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7d8f8a22d7aa693294e76aac35ba5c/" rel="bookmark">
			【MIS_231228】使用ARMA预测疫情后某医药股的股价
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import random import string from datetime import datetime def generate_random_string(length=3): characters = string.ascii_uppercase return ''.join(random.choice(characters) for _ in range(length)) def generate_timestamped_string(separator='_'): timestamp = datetime.now().strftime('%y%m%d') # %H%M%S random_part = generate_random_string(length=3) return random_part+separator+timestamp timestamped_string = generate_timestamped_string() print('【{0}】'.format(timestamped_string)) 【Talk is cheap】
import warnings import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] # 显示中文 plt.rcParams['axes.unicode_minus'] = False # 显示负号 warnings.filterwarnings("ignore") %matplotlib inline ... # 绘制ACF和PACF图 plot_acf(df['Close_diff'].dropna()) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c7d8f8a22d7aa693294e76aac35ba5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f478c3f6e45266227733eca409f0bdfe/" rel="bookmark">
			2023级大一Java基础期末考试口试题题库——15题随机问3题。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023级大一Java基础期末考试口试题题库——15题随机问3题。
随机数字工具包：https://download.csdn.net/download/feng8403000/88660080
朗读问题音频包：https://download.csdn.net/download/feng8403000/88672185
1、java的jdk默认安装路径是哪里？
C:\Program Files\Java\jdk1.8.0_181\bin
2、javac编译后的文件后缀名是什么，叫做什么文件？
.class，字节码文件。
3、java的八种基本数据类型有那些，String是什么类型？
byte short int long float double boolean char
String是引用类型
4、请表达一下数据类型的相互转化什么时候用强转，什么时候可以直接赋值？
强转（强制类型转换）：
当你需要将一个基本数据类型转换为对象类型或反之，或者将一个数据类型与该类型的字面量兼容但实际上具有不同数据类型的变量进行转换时，可以使用强转。使用强转时，你需要确保转换的结果不会导致数据丢失或溢出。
例如，如果你有一个Integer对象，并且你希望将其转换为int类型，你可以使用强制类型转换（Integer obj = 42; int i = (int) obj;）。这将把Integer对象的值转换为int类型。
直接赋值：
当你将一个对象赋值给另一个相同类型的对象时，可以直接赋值。Java会自动执行类型转换，无需显式地进行强制类型转换。
例如，如果你有一个Integer对象，并且你希望将其赋值给一个int变量，你可以直接进行赋值（int i = 42; Integer obj = 42;）。在这种情况下，Java会自动将Integer对象的值转换为int类型并存储在变量i中。
需要注意的是，当使用强转时，需要确保转换的类型兼容且不会导致数据丢失或溢出。如果类型不兼容或存在溢出风险，则应避免使用强转，并考虑使用其他方法进行处理。
此外，对于某些特定类型（如String），可以直接将基本数据类型赋值给对应的字符串字面量变量（如int i = “42”;），Java会自动将基本数据类型的值转换为对应的字符串表示形式并存储在字符串字面量变量中。
5、java运算符中优先级最高的符号是？
()
6、请说明一下符号&amp;&amp;与||的具体作用以及区别。
用于逻辑运算，判断是否符合逻辑。
&amp;&amp;是代表与，前后两个表达式的结果必须是true，返回结果才是true，否则返回false。
||是代表或，前后两个表达式只要有一个是true结果就是true，只有两个都是false才返回false。
7、循环四要素都有什么，以及对应的作用请详细说明一下？
1、初始值：确定循环的初始条件
2、表达式：决定何时结束循环
3、循环体：具体的执行内容
4、迭代器：进入到下一次循环
8、请简述什么情况下for循环会出现死循环？
1、表达式无法终止
2、迭代器没有变化
9、请说一下循环控制语句有那些关键字，对应关键字的作用是什么？
break与continue
break的意思是终止循环， 跳出循环的作用域。
continue的意思的停止当前循环， 跳出到下次循环的表达式。
10、数组的下标从哪个数字开始计算？
0
11、冒泡排序的内部循环表达式是什么？
length-1-i
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f478c3f6e45266227733eca409f0bdfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d8d5d8e983587dd5e2025b43b25484/" rel="bookmark">
			20231228在Firefly的AIO-3399J开发板的Android11的Firefly的AIO-3399J开发板的DTS配置单前置摄像头ov13850
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20231228在Firefly的AIO-3399J开发板的Android11的Firefly的AIO-3399J开发板的DTS配置单前置摄像头ov13850
2023/12/28 12:30
开发板：Firefly的AIO-3399J【RK3399】
SDK：rk3399-android-11-r20211216.tar.xz【Android11】
Android11.0.tar.bz2.aa【ToyBrick】
Android11.0.tar.bz2.ab
Android11.0.tar.bz2.ac
https://wiki.t-firefly.com/AIO-3399J/prepare_compile_android.html
AIO-3399J产品规格书 立即购买
AIO-3399J 采用 RK3399 六核(A72x2+A53x4) 64 位处理器，主频高达1.8GHz，集成了四核 Mali-T860 GPU，性能优异。
1、简略步骤：
rootroot@rootroot-X99-Turbo:~/3TB$ cat Android11.0.tar.bz2.a* &gt; Android11.0.tar.bz2
rootroot@rootroot-X99-Turbo:~/3TB$ tar jxvf Android11.0.tar.bz2 rootroot@rootroot-X99-Turbo:~/3TB$ mv Android11.0 61Android11.0
rootroot@rootroot-X99-Turbo:~/3TB$ cd 61Android11.0
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ cd u-boot
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ ./make.sh rk3399
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ cd ..
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ cd kernel/
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ make ARCH=arm64 rockchip_defconfig android-11.config -j36
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ make ARCH=arm64 BOOT_IMG=../rockdev/Image-rk3399_Android11/boot.img rk3399-firefly-aio.img -j36
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ source build/envsetup.sh rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ lunch
42. rk3399_Android11-userdebug
Which would you like?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95d8d5d8e983587dd5e2025b43b25484/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/608d1308dd5ccc2e2164585a80acf949/" rel="bookmark">
			【BXZ_231228】使用Sklearn Kmeans及RFM对淘宝客户进行分类关怀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import random import string from datetime import datetime def generate_random_string(length=3): characters = string.ascii_uppercase return ''.join(random.choice(characters) for _ in range(length)) def generate_timestamped_string(separator='_'): timestamp = datetime.now().strftime('%y%m%d') # %H%M%S random_part = generate_random_string(length=3) return random_part+separator+timestamp timestamped_string = generate_timestamped_string() print('【{0}】'.format(timestamped_string)) 【Talk is cheap】
import warnings import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] # 显示中文 plt.rcParams['axes.unicode_minus'] = False # 显示负号 warnings.filterwarnings("ignore") %matplotlib inline ... Index(['买家会员名', '买家实际支付积分', '买家实际支付金额', '买家应付货款', '买家应付邮费', '买家支付宝账号', '买家支付积分', '买家服务费', '买家留言', '修改后的sku', '修改后的收货地址', '分阶段订单信息', '卖家服务费', '发票抬头', '含应开票给个人的个人红包', '天猫卡券抵扣', '定金排名', '宝贝总数量', '宝贝标题 ', '宝贝种类 ', '店铺Id', '店铺名称', '异常信息', '总金额', '打款商家金额', '支付单号', '支付详情', '收货人姓名', '收货地址', '新零售交易类型', '新零售发货门店id', '新零售发货门店名称', '新零售导购门店id', '新零售导购门店名称', '是否上传合同照片', '是否上传小票', '是否代付', '是否手机订单', '是否是O2O交易', '物流公司', '物流单号 ', '特权订金订单id', '确认收货时间', '联系手机', '联系电话 ', '订单付款时间', '订单关闭原因', '订单创建时间', '订单备注', '订单状态', '运送方式', '返点积分', '退款金额', '数据采集时间'], .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/608d1308dd5ccc2e2164585a80acf949/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/7/">«</a>
	<span class="pagination__item pagination__item--current">8/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/9/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>