<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f9c1231357be8c483f7f0abd9b47a98/" rel="bookmark">
			【工具】1664- Codeium：强大且免费的AI智能编程助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注 “AI 工具派”
探索最新 AI 工具，发现 AI 带来的无限可能性！
Chris 今天给大家带来一款非常好用强大的 AI 智能编程助手，如果你还在苦于无法使用 Github Copilot 这类插件，不妨试试 Codeium，免费好用~
Codeium 是一款免费、强大的 AI 智能编程助手，能够支持绝大部分主流编程语言和 IDE，每周会持续更新，具备快速响应和出色的代码建议能力。
利用 AI 技术，Codeium 能够学习用户的代码风格，快速补全代码，甚至在用户输入一段注释时，能自动生成相应代码，帮助用户提升开发效率，更快地开发高质量产品。
Codeium 还支持智能搜索功能，让用户迅速解决代码问题，类似于 Github Copilot。
1. Codeium 能做什么？ 使用自然语言开发程序
对于不熟悉的开发语言或代码库，只需使用自然语言输入注释，Codeium 即可完成接下来的工作，让你免除学习语言的烦恼。
减少编写重复代码
自动处理与编写重复的模板代码相关的工作，让你专注于重要的开发工作，节省大量时间，同时还能确保生成的代码质量。
高效地查找和使用 API
Codeium 已经阅读了大量文档，你可以很方便地使用 Codeium 插入正确的 API 调用代码满足自己的需求。
自动生成单元测试代码
Codeium 还能自动生成单元测试代码，确保你不会遗漏任何边缘情况，让测试驱动开发变得更加容易。
2. Codeium 有什么特点？ 「由人工智能驱动的代码自动生成」
Codeium 自动生成代码的速度比想象的要快，这可以帮助你很好的节省时间，让你可以更高效的开发产品。
「非常智能的 AI 搜索功能」
Codeium 的智能搜索功能，让你不要再与笨拙的正则表达式博弈了，Codeium 的 AI 搜索能力可以帮你查找与你的目的相关的文件和代码。
「由人工智能驱动的聊天」
你可以从 Codeium 聊天中获得帮助，比如生成代码模版、重构代码、添加文档、解释代码、建议错误修复等等。
3. Codeium 支持哪些 IDE？ 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f9c1231357be8c483f7f0abd9b47a98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1f635fcdb0c1aa05a092eb45158c5d/" rel="bookmark">
			vue3、vite，正确安装 Prismjs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{ "vue": "^3.2.37", "vite": "^3.1.0" } 安装依赖 npm install prismjs -S npm install vite-plugin-prismjs -D 在 vite.config.js 里配置 import { defineConfig } from 'vite' import { prismjsPlugin } from 'vite-plugin-prismjs' export default defineConfig({ plugins: { prismjsPlugin({ // ['json', 'css'] 按需引入，'all' 所有语言 languages: 'all', // 配置行号插件 plugins: ['line-numbers'], // 主题名 theme: 'coy', css: true }) } }) PS：原本是照着网上的 import prismjs from 'vite-plugin-prismjs' 但结果报错 prismjs is not a function
然后看了下源码（选中包名，按 ctrl，然后点击访问本地代码）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e1f635fcdb0c1aa05a092eb45158c5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85b9912599d746af07d2ac9171365db/" rel="bookmark">
			设计模式之单例模式（七种方法超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式之单例设计模式 简介1.单例模式的实现1.1 饿汉式饿汉式-方式1（静态变量方式）饿汉式-方式2（静态代码块方式） 1.2 懒汉式懒汉式-方式1（线程不安全）懒汉式-方式2（线程安全）懒汉式-方式3（双重检查锁）懒汉式-方式4（静态内部类方式）补充：饿汉式-方式3 (枚举方式) 2.单例模式存在的问题2.1 单例模式被破坏● 序列化反序列化破坏单例模式● 反射破坏单例模式 2.2 原因分析2.3 问题解决● 序列化、反序列方式破坏单例模式的解决方法● 反射方式破解单例的解决方法 关于枚举类单例模式为什么不会被破坏 简介 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象，也就是说不能使用new关键字来创建对象。
1.单例模式的实现 单例设计模式分类两种：
​ 饿汉式：类加载就会导致该单实例对象被创建。
​ 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建。
1.1 饿汉式 饿汉式-方式1（静态变量方式） 这种方法通过将对象的实例设置为静态的方式，保证了该对象的实例，永远只有一份,且该对象的创建在类加载的时候就会立即创建在jvm内存中的方法区，在程序运行期间永久存在，所以当我们的对象太大的时候就会造成一种资源的浪费。
代码示例：
/** * 饿汉式 * 静态变量创建类的对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance = new Singleton(); //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } 饿汉式-方式2（静态代码块方式） 在方式2中，对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样。
/** * 饿汉式-方法2 * 在静态代码块中创建该类对象 */ public class Singleton { //私有构造方法 private Singleton() {} //在成员位置创建该类的对象 private static Singleton instance; static { instance = new Singleton(); } //对外提供静态方法获取该对象 public static Singleton getInstance() { return instance; } } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d85b9912599d746af07d2ac9171365db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e31a7ba22ba6cedead772022c6efc7/" rel="bookmark">
			设计模式之原型模式（对象深拷贝与浅拷贝）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式之原型模式 原型模式1. 概述2. 结构3. 实现3.1 浅克隆的实现3.2 深克隆（使用重写clone方法的方式）3.3 深克隆（利用序列化的方式） 4. 补充（new 对象与克隆的区别） 原型模式 1. 概述 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象，通俗点说就是对象的拷贝，而这种拷贝又可以分为深拷贝与浅拷贝，往后我们会深入叙述。
2. 结构 原型模式包含如下角色：
抽象原型类：声明一个可以克隆自己的方法，通常是一个接口。具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。访问类：使用具体原型类中的 clone() 方法来复制新的对象。 3. 实现 原型模式的克隆分为浅克隆和深克隆，也就是深拷贝与浅拷贝。
浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于基本类型，就会拷贝基本类型的值，但是对于非基本类型属性，就会拷贝指向原有对象的内存地址，并不会开辟新的内存空间。
深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址，而是开辟新的内存空间保存数据。
3.1 浅克隆的实现 Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口就是一个抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。现在我们新建一个教师类来实现 Cloneable 接口，并实现他的clone()方法，而后我们来测试浅拷贝。
代码如下：
Teacher（具体的原型类）：
public class Teacher implements Cloneable{ private String name; //实现克隆的方法 @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } Client（测试访问类）：
public class Client { public static void main(String[] args) throws CloneNotSupportedException { Teacher teacher = new Teacher(); Teacher teacher1 = (Teacher) teacher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e31a7ba22ba6cedead772022c6efc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9b7316b3d86f0a1f0e9689a38c5e0ab/" rel="bookmark">
			Git 储藏(stash)详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 单次储藏及应用多次储藏及应用对特定范围文件进行储藏 此文在阅读前需要有一定的git命令基础，若基础尚未掌握，建议先阅读这篇文章Git命令播报详版
在平常的工作中，当我们在单独拉取的功能分支中进行开发时，遇到线上出现bug需要进行紧急修复，我们需要切换到主分支，进行代码的修复。但是我们直接在本地切换到主分支，则会提示当前文件的改动会丢失。
那该怎么办呢？合理的方式应该是将功能分支的代码临时存储在某个位置，当我们切回到当前分支，读取该存储，将之前的改动恢复。
在git中，就有git stash这样的命令，完美的解决了这个问题，其将当前未提交的修改(即工作区和暂存区的修改)先暂时储藏起来。
然后我们可以通过git stash list来查看储藏记录。之后通过git stash pop命令将之前最近一次储藏的修改取出来，继续之前的工作，并同时将该储藏从储藏记录列表中删除
单次储藏及应用 我们在当前分支，添加test.md文件。
查看文件状态
git status 输出： On branch master Your branch is up to date with 'origin/master'. Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.md nothing added to commit but untracked files present (use "git add" to track) 添加test.md到储藏区，使之能被git进行追踪
git add test.md 查看文件状态
git status 输出： On branch master Your branch is up to date with 'origin/master'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9b7316b3d86f0a1f0e9689a38c5e0ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df90c5b877d4d3f9a2f6b3bbbe6019de/" rel="bookmark">
			PTA Python实验3 分支结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
7-1 求三个数中的最大值
7-2 温度转换
7-3 成绩判断 7-4 计算BMI并判断
7-5 运输打折问题
7-1 求三个数中的最大值 作者 python备课组
单位 福州大学至诚学院
输入三个整数，找出三个数中的最大数。
输入格式: 分三行输入三个整数。注意：
输入使用input()，不要增加额外的提示信息input 函数返回值是字符串, 可以使用 int(input()) 或 eval(input()) 来进行转换 输出格式: 直接输出
输入样例: 23 56 19 输出样例: 56 a=eval(input()) b=eval(input()) c=eval(input()) if(a&gt;b): if a&gt;c: print(a) else: print(c) else: if c&gt;b: print(c) else: print(b) 7-2 温度转换 作者 翁恺
单位 浙江大学
根据华氏和摄氏温度定义，转换公式如下：
C=1.8F−32​F=1.8C+32 这里，C表示摄氏温度，而F表示华氏温度。
如果输入的温度用最后一个字母标识摄氏或华氏，如：
32C67.2F 请写程序根据温度的单位换算成另一种温度。
输入格式: 一个温度值，可能带有小数点，最后用大写字母C或F表示摄氏或华氏温度。
输出格式: 一个温度值，可能带有小数点，最后用大写字母C或F表示摄氏或华氏温度。
输入样例: 32C 输出样例: 89.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df90c5b877d4d3f9a2f6b3bbbe6019de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2facfe575c7157b88450efe6e71eb6a3/" rel="bookmark">
			从虚断，虚短分析基本运放电路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从虚断，虚短分析基本运放电路 运算放大器组成的电路五花八门，令人眼花瞭乱，是模拟电路中学习的重点。在分析它的工作原理时倘没有抓住核心，往往令人头大。为此本人特搜罗天下运放电路之应用，来个“庖丁解牛”，希望各位看完后有所斩获。
遍观所有模拟电子技朮的书籍和课程，在介绍运算放大器电路的时候，无非是先给电路来个定性，比如这是一个同向放大器，然后去推导它的输出与输入的关系，然后得出Vo=(1+Rf)Vi，那是一个反向放大器，然后得出Vo=-Rf*Vi……最后学生往往得出这样一个印象：记住公式就可以了！如果我们将电路稍稍变换一下，他们就找不着北了！
今天，教各位战无不胜的两招，这两招在所有运放电路的教材里都写得明白，就是“虚短”和“虚断”，不过要把它运用得出神入化，就要有较深厚的功底了。
虚短和虚断的概念
由于运放的电压放大倍数很大，一般通用型运算放大器的开环电压放大倍数都在80 dB以上。而运放的输出电压是有限的，一般在 10 V～14 V。因此运放的差模输入电压不足1 mV，两输入端近似等电位，相当于 “短路”。开环电压放大倍数越大，两输入端的电位越接近相等。
“虚短”是指在分析运算放大器处于线性状态时，可把两输入端视为等电位，这一特性称为虚假短路，简称虚短。显然不能将两输入端真正短路。
由于运放的差模输入电阻也很大，一般通用型运算放大器的输入电阻都在1MΩ以上。因此流入运放输入端的电流往往不足1uA，远小于输入端外电路的电流。故 通常可把运放的两输入端视为开路，且输入电阻越大，两输入端越接近开路。“虚断”是指在分析运放处于线性状态时，可以把两输入端视为等效开路，这一特性 称为虚假开路，简称虚断。显然不能将两输入端真正断路。
在分析运放电路工作原理时，首先请各位暂时忘掉什么同向放大、反向放大，什么加法器、减法器，什么差动输入……暂时忘掉那些输入输出关系的公式……这些东东只会干扰你，让你更糊涂﹔也请各位暂时不要理会输入偏置电流、共模抑制比、失调电压等电路参数，这是设计者要考虑的事情。我们理解的就是理想放大器（其实在维修中和大多数设计过程中，把实际放大器当做理想放大器来分析也不会有问题）。
好了，让我们抓过两把“板斧”------“虚短”和“虚断”，开始“庖丁解牛”了。
1）反向放大器： 图1
图一运放的同向端接地=0V，反向端和同向端虚短，所以也是0V，反向输入端输入电阻很高，虚断，几乎没有电流注入和流出，那么R1和R2相当于是串联的，流过一个串联电路中的每一只组件的电流是相同的，即流过R1的电流和流过R2的电流是相同的。
流过R1的电流：I1 = (Vi - V-)/R1 ………a
流过R2的电流：I2 = (V- - Vout)/R2 ……b
V- = V+ = 0 ………………c
I1 = I2 ……………………d
求解上面的初中代数方程得Vout = (-R2/R1)*Vi
这就是传说中的反向放大器的输入输出关系式了。
2）同向放大器： 图2
图二中Vi与V-虚短，则 Vi = V- ……a
因为虚断，反向输入端没有电流输入输出，通过R1和R2 的电流相等，设此电流为I，由欧姆定律得： I = Vout/(R1+R2) ……b
Vi等于R2上的分压， 即：Vi = IR2 ……c
由abc式得Vout=Vi(R1+R2)/R2 这就是传说中的同向放大器的公式了。
3）加法器1： 图3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2facfe575c7157b88450efe6e71eb6a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543c8aae147bbb011b32880a71eeccf9/" rel="bookmark">
			uniapp微信小程序图片预览PreviewImage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明 功能：点击图片预览大图，并且可以通过滑动查看不同图片的预览大图。
点击预览大图后：
二、上代码 参考uniapp官方文档 其提供了预览大图的函数uni.previewImage(OBJECT).
//放大查看推荐图片 enlargePicture(index) { console.log("放大查看图片") const imgUrl = this.imgList; //图片列表，this.imgList是一个图片链接的数组。 // this.enlargedImage = imgUrl; uni.previewImage({ loop: true, urls: imgUrl, //可以展示imgUrl 列表中所有的图片 current: index //首先当前index对应图片，左右可以切换其他序号的图片 }); }, 以下是各个参数的含义：
current : 类型是String/Number 为当前显示图片的链接/索引值，不填或填写的值无效则为 urls 的第一张。建议填写。
urls : 类型是Array&lt;String&gt;，必填项，是需要预览的图片链接列表。该列表中有多少个元素就可以预览多少的对应图片。
indicator : 类型是 String，非必填项，是图片指示器样式，可取值：“default” - 底部圆点指示器； “number” - 顶部数字指示器； “none” - 不显示指示器。 App
loop : 类型是 Boolean，非必填项，指是否可循环预览，默认值为 false 。
longPressActions : 类型是Object，非必填项，是长按图片显示的操作菜单，如不填默认为保存相册。
success : 类型是 Function，非必填项，是接口调用成功的回调函数。
fail : 类型是 Function ，非必填项，是接口调用失败的回调函数 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/543c8aae147bbb011b32880a71eeccf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/556e1bcb8d38d7c682c448bad3f62727/" rel="bookmark">
			python量化—因子数据获取与处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
因子数据获取
策略外获取因子数据
1）方法一：利用 get_factor_by_code 获取因子数据（单个股票）
2）方法二：利用 get_factor_by_day获取因子数据（单天）
3）方法三：利用 get_factor_by_factor 获取因子数据（单个因子）
案例：单因子数据获取及处理
1）导入库
2）定义数据处理函数
3）获取因子数据
4）因子数据处理
因子数据获取 Auto-Trader获取数据有两种方式： 1） 策略外获取因子数据 即不采用平台的回测框架，可直接获取数据，主要是将获取的数据做相应的研究。 2） 策略内获取因子数据 即采用平台的回测框架，以设定的频率不断刷新获取相应的因子数据，主要是用于策略回测。 策略外获取因子数据 1）方法一：利用 get_factor_by_code 获取因子数据（单个股票） 获取单个股票，在一段时间内多个因子的数据。 # 导入atrader库： from atrader import * # 方法一：获取平安银行20160101到20160701这段时间 PE、PB因子 数据（单个股票）： factor_data1 = get_factor_by_code(factor_list=['pe' , 'pb'], target='SZSE.000001', begin_date='2016-01-01', end_date='2016-07-01') # 打印输出结果： print(factor_data1) 2）方法二：利用 get_factor_by_day获取因子数据（单天） 获取单天，多个股票，多个因子的数值。 # 方法二：获取平安银行、万科在20160601这天的PE、PB因子 数据（单天）： factor_data2 = get_factor_by_day(factor_list=[‘pe' , 'pb'], target_list=['SZSE.000001','SZSE.000002'], date='2016-06-01') # 打印输出结果： print(factor_data2) 3）方法三：利用 get_factor_by_factor 获取因子数据（单个因子） 获取一段时间，多标的的单个因子数据。 # 方法三：获取平安银行、万科在20160101到20160701这段时间 的PE因子数据（单个因子）： factor_data3 = get_factor_by_factor(factor=‘pe' , target_list=['SZSE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/556e1bcb8d38d7c682c448bad3f62727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f057de231f810de2324bf85f1a0ca8c4/" rel="bookmark">
			关于Vue中使用全屏容器无法占满屏幕以及样式不生效问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来看示例问题
App.vue文件
global.css文件
网页效果
可以看到即使设置了宽度和高度为100%都无法占满屏幕，而且容器还超出了屏幕，上拉才可以看到下边框。查看网上解决方法：
1.height设置为100vh， 或者设置为calc（100vh - 0.9rem)。（无效） 2.新建并引入css文件修改样式。 （上面以尝试，无效）。
3.margin，padding设置为0。（上面尝试，无效）
最后在开发者面板找到问题，在渲染成html页面后，边框组件高度宽度会被加上确定的数值，当宽度和高度超出屏幕可是区域时，出白边以及滑动条，无法占满屏幕。
由此可知，只需要自己设置样式覆盖掉默认添加上的样式（宽高）即可，那么经过尝试发现，可以使用 !important来提高自己样式的权重这样就可以实现width：100%和height：100%占满屏幕。
占满效果如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2295594003e64693f3c87dc9bd384ee7/" rel="bookmark">
			网络杀伤链模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络杀伤链模型是指在网络攻击中，攻击者利用多个环节的漏洞或弱点，将攻击进行下去的一种攻击模型。这种模型通过多个环节的攻击，可以快速地达到攻击的目的，从而给受攻击方带来巨大的损失。以下是网络杀伤链模型的详细介绍。
网络杀伤链模型主要由以下几个环节组成：
1、情报收集和侦察
攻击者通过各种手段，获取目标系统的相关信息，如IP地址、操作系统类型、漏洞信息、人员组织结构等。这些信息可以帮助攻击者更好地了解目标系统，从而更容易地发起攻击。
2、漏洞扫描和利用
攻击者利用情报收集环节获得的漏洞信息，对目标系统进行漏洞扫描，并利用已知的漏洞进行攻击。攻击者可以利用各种工具或脚本，快速地扫描系统中存在的漏洞，并尝试利用这些漏洞进行攻击。
3、系统访问和权限提升
攻击者在成功利用漏洞后，会尝试访问目标系统，获取更高的权限。攻击者可以利用各种手段，如暴力破解、社会工程学、恶意软件等，获取目标系统的访问权限，并尝试提升自己的权限，以更好地控制目标系统。
4、数据窃取和篡改
攻击者在成功访问系统后，可以尝试窃取敏感数据，如个人信息、信用卡信息等。攻击者也可以篡改数据，如植入木马、病毒等恶意软件，以控制系统、窃取信息或破坏数据完整性。
5、命令和控制
攻击者在成功窃取数据或控制系统后，会尝试通过远程控制工具，对目标系统进行远程控制。攻击者可以通过命令和控制，进行各种恶意活动，如远程操控、发起DDoS攻击等。
网络杀伤链模型是一种非常危险的攻击模型，因为攻击者可以在每个环节上不断扩大攻击范围和影响，从而使攻击变得更加复杂和难以控制。因此，企业需要采取一系列措施来防止网络杀伤链模型的攻击，包括但不​
不限于以下几个方面：
1、安全意识教育
企业应该定期开展安全意识教育，让员工了解网络攻击的危害性和防范知识，提高员工的安全意识和防范能力。安全漏洞修复企业应该定期对系统进行安全漏洞扫描和修复，及时补充最新的安全补丁，以防止攻击者利用已知漏洞进行攻击。
2、访问控制和权限管理
企业应该实行访问控制和权限管理机制，确保只有授权人员能够访问系统，从而避免未经授权的访问和恶意活动。
3、安全监测和响应
企业应该部署安全监测和响应机制，及时发现和响应安全事件，包括异常登录、异常访问、恶意软件感染等，从而遏制攻击的扩散。
4、数据备份和恢复
企业应该定期备份重要数据，确保在攻击发生后能够及时恢复数据，减少数据丢失和损失。
总之，网络杀伤链模型的攻击威胁非常严峻，企业需要采取多种防范措施，从不同的环节进行防范，以确保系统的安全性和可靠性。只有在做好防范工作的前提下，企业才能够避免成为攻击者的目标，保障企业的信息安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53009206fa426ccbbcbc8023d472750a/" rel="bookmark">
			SpringBoot定时任务@Scheduled的多线程使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、@Scheduled注解简介 @Scheduled是Spring框架中的一个注解，它可以用于配置定时任务，使得方法可以按照规定的时间间隔定时执行。在使用该注解时，我们可以指定任务的执行时间、循环周期、并发数等参数，从而实现定时任务的功能。在Spring Boot中，@Scheduled注解可以直接应用于方法上。
二、@Scheduled的多线程机制 在Spring Boot中，@Scheduled注解是基f于Java的ThreadPoolExecutor和ScheduledThreadPoolExecutor实现的。当我们配置了一个定时任务后，Spring Boot会首先创建一个ScheduledThreadPoolExecutor线程池，并将定时任务添加到该线程池中等待执行。然后，在指定的时间到来之后，线程池会为该定时任务分配一个线程来执行。如果该定时任务还未执行完毕，在下一个周期到达时，线程池会为该任务再次分配一个线程来执行。通过这种方式，@Scheduled可以非常方便地实现周期性的定时任务f于Java的ThreadPoolExecutor和ScheduledThreadPoolExecutor实现的。当我们配置了一个定时任务后，Spring Boot会首先创建一个ScheduledThreadPoolExecutor线程池，并将定时任务添加到该线程池中等待执行。然后，在指定的时间到来之后，线程池会为该定时任务分配一个线程来执行。如果该定时任务还未执行完毕，在下一个周期到达时，线程池会为该任务再次分配一个线程来执行。通过这种方式，@Scheduled可以非常方便地实现周期性的定时任务。
三、@Scheduled的多线程问题 虽然@Scheduled注解非常便捷，但是它也存在一些多线程的问题，主要体现在以下两个方面：
定时任务未执行完毕时，后续任务可能会受到影响 在使用@Scheduled注解时，我们很容易忽略一个问题：如果定时任务在执行时，下一个周期的任务已经到了，那么后续任务可能会受到影响。例如，我们定义了一个间隔时间为5秒的定时任务A，在第1秒时开始执行，需要执行10秒钟。在第6秒时，定时任务A还没有结束，此时下一个周期的任务B已经开始等待执行。如果此时线程池中没有足够的空闲线程，那么定时任务B就会被阻塞，无法执行。
多个定时任务并发执行可能导致资源竞争 在某些情况下，我们可能需要编写多个定时任务，这些定时任务可能涉及到共享资源，例如数据库连接、缓存对象等。当多个定时任务同时执行时，就会存在资源竞争的问题，可能会导致数据错误或者系统崩溃。
四、@Scheduled加入线程池来处理定时任务 为了避免上述问题，可以将@Scheduled任务交给线程池进行处理。在Spring Boot中，可以通过以下两种方式来将@Scheduled任务加入线程池：
使用@EnableScheduling + @Configuration配置ThreadPoolTaskScheduler @Configuration @EnableScheduling public class TaskSchedulerConfig { @Bean public TaskScheduler taskScheduler() { ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.setPoolSize(10); scheduler.initialize(); return scheduler; } } 复制代码 在上述代码中，我们通过配置ThreadPoolTaskScheduler来创建一个线程池，并使用@EnableScheduling注解将定时任务开启。其中，setPoolSize方法可以设置线程池的大小，默认为1。
使用ThreadPoolTaskExecutor @Configuration @EnableScheduling public class TaskExecutorConfig { @Bean public ThreadPoolTaskExecutor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(10); executor.setMaxPoolSize(50); executor.setQueueCapacity(1000); executor.setKeepAliveSeconds(60); executor.setThreadNamePrefix("task-executor-"); return executor; } } 复制代码 在上述代码中，我们通过配置ThreadPoolTaskExecutor来创建一个线程池，并使用@EnableScheduling注解将定时任务开启。其中setCorePoolSize、setMaxPoolSize、setQueueCapacity、setKeepAliveSeconds等方法可以用于配置线程池的大小和任务队列等参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53009206fa426ccbbcbc8023d472750a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee52ea116d50d55fb87194327366b790/" rel="bookmark">
			Python中的pass语句详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：永劫
一、概述
在本文中，我们将详细介绍Python中的pass语句，包括其定义、作用以及使用场景。pass语句在Python编程中是一个实用的占位符，它可以让程序运行在某些特定的情况下，而不引发任何错误。
二、pass语句的定义
pass是一个特殊的Python语句，它的作用是什么也不做。当你在编写代码时，可能需要一个占位符来表示尚未完成的代码块。这时候，你可以使用pass语句作为暂时的占位符。
三、pass语句的作用
占位作用：当你编写一个函数或类，但还没有实现具体功能时，可以使用pass语句作为占位符，以避免语法错误。
控制流程：在循环或条件语句中，pass语句可以用作空的执行体，使得控制流程继续进行。
四、pass语句的使用场景
以下是一些pass语句的使用场景：
1.在函数中
def example_function(): pass 2.在类中
class ExampleClass: pass 3.在循环中
for i in range(5): if i == 3: pass else: print(i) 4.在条件语句中
x = 10 if x &gt; 5: pass else: print("x &lt;= 5") 五、总结
Python中的pass语句是一个实用的占位符，用于表示尚未完成的代码块。它可以在函数、类、循环和条件语句中使用，以避免语法错误和控制流程。希望本文能帮助你更好地理解和使用pass语句。
六、pass语句与其他占位语句的比较
此外，除了pass语句外，Python中还有其他占位语句，如continue和break。下面我们来比较一下这些语句的作用和用法。
pass
pass语句是一个空操作语句，表示什么也不做。它常用于占位，以避免语法错误。在执行到pass语句时，程序不会有任何操作，直接跳过并继续执行下一条语句。
continue
continue语句用于循环中，表示跳过本次循环的剩余部分，直接开始下一次循环。continue语句常用于在循环中忽略特定条件下的执行体。
break
break语句用于循环中，表示立即终止当前循环，跳出循环体。break语句常用于在满足特定条件时，提前结束循环。
七、pass语句的注意事项
虽然pass语句在Python编程中非常实用，但在使用过程中，还是需要注意以下几点：
不要滥用pass语句。在代码开发过程中，pass语句可以作为临时占位符，但在最终代码中，应尽量避免使用pass语句，以免影响代码的可读性和执行效率。
pass语句不能替代continue和break语句。虽然pass语句在循环中也能起到控制流程的作用，但它的功能并不等同于continue和break语句。在需要跳过循环或提前结束循环的场景中，应使用相应的continue和break语句。
八、实际案例
以下是一个实际案例，展示了pass语句在实际开发中的应用：
假设我们需要开发一个学生管理系统，其中有一个Student类。在开发初期，我们可能只需要定义类的结构，而不需要实现具体功能。这时，我们可以使用pass语句作为占位符：
class Student: def __init__(self, name, age): self.name = name self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee52ea116d50d55fb87194327366b790/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3ed1f02af4b330703382d67a0f0833/" rel="bookmark">
			antd 实现表头配置显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		antd 实现表头配置显示
import React, { useState } from 'react'; import { Table, Button, Modal, Checkbox } from 'antd'; const columns = [ { title: '姓名', dataIndex: 'name', key: 'name', }, { title: '年龄', dataIndex: 'age', key: 'age', }, { title: '地址', dataIndex: 'address', key: 'address', }, ]; const data = [ { key: '1', name: '张三', age: 18, address: '北京市', }, { key: '2', name: '李四', age: 20, address: '上海市', }, { key: '3', name: '王五', age: 22, address: '广州市', }, ]; const HeaderConfigTable = () =&gt; { const [visible, setVisible] = useState(false); const [checkedColumns, setCheckedColumns] = useState(columns.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3ed1f02af4b330703382d67a0f0833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4add001e62edeadecf083dc3e82aca38/" rel="bookmark">
			一个可以直接运行的WEB录音机，在WEB上实现录音并播放，也可以用来测试麦克风（增加了音频下载功能）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"&gt; &lt;meta name="apple-mobile-web-capable" content="yes"&gt; &lt;title&gt;WEB录音机&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick="record()"&gt;开始录音&lt;/button&gt; &lt;button onclick="stopRecord()"&gt;停止录音&lt;/button&gt; &lt;button onclick="bofangRecord()"&gt;播放录音&lt;/button&gt; &lt;button onclick="recordClose()"&gt;关闭录音&lt;/button&gt; &lt;audio class="audio-node" autoplay&gt;&lt;/audio&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; function record() { window.navigator.mediaDevices.getUserMedia({ audio: { sampleRate: 44100, // 采样率 channelCount: 2, // 声道 volume: 2.0 // 音量 } }).then(mediaStream =&gt; { console.log(mediaStream); window.mediaStream = mediaStream beginRecord(window.mediaStream); }).catch(err =&gt; { // 如果用户电脑没有麦克风设备或者用户拒绝了，或者连接出问题了等 // 这里都会抛异常，并且通过err.name可以知道是哪种类型的错误 console.error(err); }); } function beginRecord(mediaStream) { let audioContext = new (window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4add001e62edeadecf083dc3e82aca38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839069f5cdd268c3123a658bfde6a333/" rel="bookmark">
			Android类似微信首页的页面开发教程(Kotlin)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提条件 安装并配置好Android Studio
Android Studio Electric Eel | 2022.1.1 Patch 2
Build #AI-221.6008.13.2211.9619390, built on February 17, 2023
Runtime version: 11.0.15+0-b2043.56-9505619 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
Windows 11 10.0
GC: G1 Young Generation, G1 Old Generation
Memory: 1280M
Cores: 6
Registry:
external.system.auto.import.disabled=true
ide.text.editor.with.preview.show.floating.toolbar=false
ide.balloon.shadow.size=0
Non-Bundled Plugins:
com.intuit.intellij.makefile (1.0.15)
com.github.setial (4.0.2)
com.alayouni.ansiHighlight (1.2.4)
GsonOrXmlFormat (2.0)
GLSL (1.19)
com.mistamek.drawablepreview.drawable-preview (1.1.5)
com.layernet.plugin.adbwifi (1.0.5)
com.likfe.ideaplugin.eventbus3 (2020.0.2)
gradle-wrapper.properties
#Tue Apr 25 13:34:44 CST 2023
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/839069f5cdd268c3123a658bfde6a333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2146feff9246d0fc0797ddbec758c4f4/" rel="bookmark">
			深入理解Python的input()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文将详细介绍Python中的input()函数的用法，并通过实例代码进行解释说明。
作者：永劫
来源：CSDN博客
一、input()函数简介
Python的input()函数是一个内置函数，用于从用户接收输入。当程序运行到input()函数时，会暂停并等待用户输入一些文本，用户输入的文本将作为函数的返回值。这使得我们可以在程序中获取用户的输入，以便根据输入执行相应的操作。
二、input()函数语法
input()函数的基本语法如下：
input(prompt=None) 其中，prompt参数是可选的，它表示在等待用户输入之前显示的提示信息。
三、input()函数实例
下面我们通过几个实例来详细介绍input()函数的用法。
示例1：基本用法
# 获取用户输入的文本 user_input = input("请输入一些文本：") print("你输入的文本是：", user_input) 示例2：获取数字输入
由于input()函数返回的是字符串类型，因此如果需要获取数字类型的输入，我们需要进行类型转换。
# 获取用户输入的整数 integer_input = int(input("请输入一个整数：")) print("你输入的整数是：", integer_input) # 获取用户输入的浮点数 float_input = float(input("请输入一个浮点数：")) print("你输入的浮点数是：", float_input) 示例3：多个输入值
如果需要获取多个输入值，我们可以使用split()函数配合input()函数实现。
# 获取用户输入的多个整数 integer_list = list(map(int, input("请输入多个整数，用空格隔开：").split())) print("你输入的整数列表是：", integer_list) 四、总结
本文详细介绍了Python中的input()函数的用法，包括基本用法、获取数字输入以及多个输入值的获取。通过学习本文，你应该能够在自己的Python程序中灵活运用input()函数获取用户输入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8b125506167d059a263f4ea2ae5719b/" rel="bookmark">
			git把一个分支上的某次修改同步到另一个分支上,并解决git cherry-pick 冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 我们在工作中经常会碰到好几个同事共同在一个分支上开发，一个项目同时会有好几个分支，我们在feature上开发的功能时，有可能某个需求需要提前发布，这个时候我们已经在feature A上开发完成，但是需要在master上发布。这个时候该怎么办呢？ 我们是不是可以直接将feature A上的commit 合并到master上，然后一键发布就可以啦？ 这个时候可能存在代码冲突。今天我们就带着这个疑问一起解决这个问题。
场景 分支： pg-datasourcemysql-prod-datasource
我们需要将在分支pg-datasource上的7f0bea1b上的这次commitId提交同步到mysql-prod-datasource上。
使用git cherry-pick 7f0bea1b 使用这个命令时我们发现发生了错误，原来是存在冲突。
使用git status 查看状态 这里我们发现这里高速我们有三个有文件存在冲突没有merged。
我们使用git diff，查看具体的冲突 当然我们可以直接到文件中去查看，有冲突的文件是红色标记
我们可以到文件里面将冲突合并。
冲突合并后，将文件添加到提交 添加后，文件就是从红色改变到正常状态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d06e6e531075edeedf8790518c838f13/" rel="bookmark">
			Mac如何安装：node的多版本管理工具（nvm 或 n）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、nvm 安装3个步骤如下（前提：需将电脑之前单独下载的node先删除）：
（1）在Mac的根目录的终端中输入以下命令下载nvm（版本为0.37.0）：
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.37.0/install.sh | bash
（2）查看nvm是否安装成功的命令：
nvm --version
（3）使用nvm安装某个版本的node即可：（注意：安装node的同时系统也会自动安装对应的npm）
nvm install v12.22.0 或 nvm install 14.10.0
二、n 官网文档：n - npm
// 常用命令 npm install n -g // 全局安装 n n &lt;version&gt; // 安装node版本，如 n 14.10.0 其他扩展 1. 使用nvm install xx 安装node的时候，报错：“clang: error: no such file or directory: 'CXX=c++'”
答：在终端先输入命令：arch -x86_64 zsh， 然后再输入安装node的命令：nvm install xxx 即可。
2. 常用Mac终端命令：
切换到系统根目录：cd
切换到nvm目录：cd .nvm
查看node的安装目录路径：which node
参考网址： 如何锁定前端项目node和pnpm版本 - 简书nvm安装node失败解决方法：nvm install node fails to install on macOS Big Sur M1 Chip · Issue #2350 · nvm-sh/nvm · GitHub 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40091e92d7d06dbc6f3eef16f0c4dacd/" rel="bookmark">
			【大学生校园网搭建项目（内附pkt文件）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大学生校园网搭建项目（内附pkt文件） 摘 要
随着信息技术的飞速发展，我国教育化行业的信息化建设更加深入的展开。教育信息化基本特点是数字化、网络化、智能化和多媒体化主要基础设施是学校的校园网和一些区域性的教育信息网络和数据中心校园网已经成为各大高校重要的基础设施之一，是创办全国一流高校必不可少的物质条件。
本论文主要从校园网建设的需求分析、校园网建设目标、校园网络规划设计中涉及到的网络技术、规划设计方法、组网技术要求、网络设计要求、方案整体设计、网络设备选型、网络规划、与服务系统到校园网应用系统等方面进行了比较详细的分析与描述，以使在建设或规划中的校园网络具备较高的整体性能，对准备建设校园网和进行网络升级的学校具有一定的参考价值。
关键词:网络设计;校园网;布线系统设计
目录
1 大学校园网网络的设计背景 2 大学校园网网络的需求分析 2.1 网络建设环境调查与分析 2.1.1 总体建设目标 2.1.2 网络布局 2.2 各部门用户的需求 3 大学校园网网络的总体设计 3.1 网络逻辑拓扑、布线方案的设计 3.1.1 网络设计依据 3.1.2 网络逻辑拓扑方案的设计 5
3.2 划分子网 3.2.1 子网地址的划分 3.2.2 各子网中IP地址的分配 4 大学校园网网络的设备选型及调试 4.1 交换机的选择 4.2 路由器的选择 5 网络测试 5.1 设备的连接 5.2 配置客户端主机、服务器主机、路由器接口的IP地址、掩码和网关等参数 5.2.1 配置过程 5.2.2 测试过程与结论 6 服务器的配置及管理 6.1 WWW服务器的配置 6.1.1 配置过程 6.2 FTP服务器的配置 6.2.1 配置过程 6.2.2 FTP服务器的管理 6.3 DHCP服务器的配置 6.3.1 配置过程 6.3.2 DHCP服务器的管理 6.4 DNS服务器的配置 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40091e92d7d06dbc6f3eef16f0c4dacd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9f160a0341cbe3b8d747157190a324/" rel="bookmark">
			【Python】ddddoc进行OCR识别和目标检测 ——识别验证码和滑块（安装部署&#43;测试代码注释详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 安装部署gitee已经上传完整项目requiremen.txt插件作者更新地址 项目结构第一部分 OCR识别部分第二部分 目标检测部分总结 欢迎关注 『Python』 系列，持续更新中
欢迎关注 『Python』 系列，持续更新中
安装部署 gitee已经上传完整项目 requiremen.txt coloredlogs==15.0.1 flatbuffers==23.3.3 humanfriendly==10.0 mpmath==1.3.0 numpy==1.24.2 onnxruntime==1.14.1 opencv-python==4.7.0.72 packaging==23.0 Pillow==9.5.0 protobuf==4.22.1 pyreadline3==3.4.1 sympy==1.11.1 插件作者更新地址 作者官方更新地址，但是requirement.txt有点问题，最好用我打包好的解压即用，但是后续获取项目更新用作者的。
https://github.com/sml2h3/ddddocr 项目结构 你的项目 ddddocr（存放插件文件）test_pic（存放验证码测试图片）venv（如果你要配置虚拟环境的话）requirements.txt（venv 安装第三方库时用到）你的测试代码.py（import ddddocr 调用方法） 第一部分 OCR识别部分 # @Time : 2023/4/8 22:14 # @Author : 南黎 import ddddocr #1.初始化一个实例，配置识别模式默认为OCR识别 ocr = ddddocr.DdddOcr() #2.读取图片 with open("test_pic/OCR_yzm.png", 'rb') as f: image = f.read() #3.给ocr实例传入image图片进行识别,得到ocr内容 ocr_result = ocr.classification(image) print(ocr_result)#iepv 验证码
识别结果
第二部分 目标检测部分 # @Time : 2023/4/9 8:17 # @Author : 南黎 import ddddocr import cv2 #1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f9f160a0341cbe3b8d747157190a324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfed6bf29db4b434a1ea3930f96dca92/" rel="bookmark">
			CTF-新手misc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wires hark 流量分析使用题目得到密码，由于是网站登录，打开之后过滤http 清除看到login，点开
得到flag{ffb7567a1d4f4abdffdb54e022f8facd}
荷兰宽带数据泄露 下载之后是bin后缀的二进制文件，使用RouterPassview搜索关键字username和password，最终flag是username
后门查杀 下载之后是个HTML文件，按照描述有后门且答案是MD5，使用D盾扫出来，在搜索pass密码即可
文件中的秘密 打开下载是一个图片，题目中得知就在文件上下功夫了，用stegsolve扫描文件就找到了是不是很简单。
flag{870c5a72806115cb5439345d8b014396}
LSB 下载文件是一个图片，这类型的无非就是隐藏提取信息，还是使用上面那个神器，发现类似二维码，在色素红绿蓝打开0，然后导出png,就得到了一个二维码，然后扫描就可以了。
flag{1sb_i4_s0_Ea4y}
rar 下载之后解压是一个压缩包，
解压之后得到flag
被嗅探的流量 流量分析题
用wireshark 分析，题目描述文件传输。http.request.method==POST，直接过滤POST，HTTP追踪流，在图片末尾找到flag{da73d88936010da1eeeb36e945ec4b97}
题干是抓取了一段文件传输的数据， 过滤http contains flag 找到关键字flag
Qr 打开是一个二维码
使用在线工具扫描，这是个签到题吧，起初我想的复杂了，并没有分离出东西
镜子里面的世界 旧活新整，改一下颜色值为0，得到flag{st3g0_ saurus_wr3cks}
Ningen 以下是描述文件，直接binwork分离出一个压缩包文件，接着破解
打开就得到了flag{b025fc9ca797a67d2103bfbc407a6d5f}
小明的保险箱 步骤和上面一样分离出压缩包，破解密码就得出答案了
flag{75a3d68bf071ee188c418ea6cf0bb043}
爱因斯坦 图片题，分离出来一个压缩包，刚开始没破解出来，以为是伪加密，改了一下没成功
在图片属性有一串字母，把它输上去，打开一个文本就得到flag{dd22a92bf2cceb6c0cd0d6b83ff51606}
easycap 题目没有描述只给网络这个单词，打开wires hark只有tcp协议找到最后看到了FIN过滤点开就看到FLAG:385b87afc8671dee07550290d16a8071
隐藏的钥匙 原题描述：路飞一行人千辛万苦来到了伟大航道的终点，找到了传说中的One piece，但是需要钥匙才能打开One Piece大门，钥匙就隐藏在下面的图片中，聪明的你能帮路飞拿到钥匙，打开One Piece的大门吗？ 注意：得到的 flag 请包上 flag{} 提交
下载是个路飞图片，想着能分离出来东西，也确实分离出来了
到这里再也没有信息了，上网查了一下，纯无语，用010直接搜索就行了，我搜索的时候发现编码不对，用编辑器编辑utf-8搜索flag在base解码就行flag{377cbadda1eca2f2f73d36277781f00a}
另外一个世界 图片题放到010里面在最后有二进制结尾，其实前面也没找到什么有用信息，每八位一组编码ascll解码得到flag{koekj3s},还有就是二进制转文字的工具是什么。
FLAG 下载之后是图片放到Stegsolve发现了PK尝试压缩以下，打开显示报错，解压之后放到虚拟机运行得到flag{dd0gf4c3tok3yb0ard4g41n~~~}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b581ba477463813250754774d6f4aeb4/" rel="bookmark">
			Python爬虫：BeautifulSoup库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Beautiful Soup的简介 Beautiful Soup是python的一个库，最主要的功能是从网页抓取数据。官方解释如下：
1、Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序
2、Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了
3、Beautiful Soup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度
安装BeautifulSoup 1、BeautifulSoup4通过PyPi发布，所以如果你无法使用系统包管理安装，那么也可以通过easy_install或pip来安装。包的名字是beautifulsoup4这个包兼容Python2和Python3
2、 pip install BeautifulSoup4==4.0.1
安装解析器 1、Beautiful Soup支持Python标准库中的HTML解析器，还支持一些第三方的解析器。其中一个是lxml
2、根据操作系统不同，可以选择pip方法来安装lxml：pip install lxml
各种解析器优缺点 Beautiful Soup支持Python标准库中的HTML解析器，还支持一些第三方的解析器，如果我们不安装它，则 Python 会使用 Python默认的解析器，lxml 解析器更加强大，速度更快，推荐安装(pip install lxml)
解析器使用方法优势劣势Python标准库 BeautifulSoup(markup, “html.parser”) Python的内置标准库、执行速度适中、文档容错能力强Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差lxml HTML 解析器BeautifulSoup(markup, “lxml”) 速度快、文档容错能力强需要安装C语言库lxml XML 解析器BeautifulSoup(markup, [“lxml”, “xml”])或BeautifulSoup(markup, “xml”)速度快、唯一支持XML的解析器需要安装C语言库html5lib BeautifulSoup(markup, “html5lib”) 最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档、不依赖外部扩展 速度慢 BeautifulSoup简介 1、将一段文档传入BeautifulSoup 的构造方法，就能得到一个文档的对象(beautifulsoup对象)。同时也可以传入一段字符串或一个文件句柄
2、首先，文档被转换成Unicode，并且HTML的实例都被转换成Unicode编码
3、然后Beautiful Soup选择最合适的解析器来解析这段文档，如果手动指定解析器，那么Beautiful Soup会选择指定的解析器来解析文档
例1：
# 导入所需第三方库 from bs4 import BeautifulSoup # 这里先用一个简单的HTML数据为例 htmlData = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b581ba477463813250754774d6f4aeb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f0c40e516eac8f0545a828a1d98361c/" rel="bookmark">
			centos编译mysql5.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以用户test编译mysql5.7为例。
安装依赖包 sudo yum install gcc gcc-c++ ncurses ncurses-devel cmake bison -y 下载mysql5.7源码并解压 cd ~/software wget https://cdn.mysql.com//Downloads/MySQL-5.7/mysql-boost-5.7.42.tar.gz tar xf mysql-boost-5.7.42.tar.gz 编译mysql5.7源码 cd mysql-5.7.42/ mkdir build cd build cmake .. -DCMAKE_INSTALL_PREFIX=$HOME/software/mysql \ -DMYSQL_DATADIR=$HOME/software/mysql/data \ -DDEFAULT_CHARSET=utf8 \ -DDEFAULT_COLLATION=utf8_general_ci \ -DMYSQL_TCP_PORT=3306 \ -DMYSQL_UNIX_ADDR=$HOME/software/mysql/tmp/mysql.sock \ -DWITH_MYISAM_STORAGE_ENGINE=1 \ -DWITH_INNOBASE_STORAGE_ENGINE=1 \ -DDOWNLOAD_BOOST=1 \ -DWITH_BOOST=../boost/boost_1_59_0/ \ -DWITH_INNODB_MEMCACHED=ON make &amp;&amp; make install 编写配置文件 mkdir ~/software/mysql/data ~/software/mysql/tmp -p 创建~/.my.cnf文件并写入以下内容
[client] port=3306 socket=/home/test/software/mysql/data/mysql.sock [mysqld] character-set-server=utf8 collation-server=utf8_general_ci skip-name-resolve user=mysql port=3306 basedir=/home/test/software/mysql datadir=/home/test/software/mysql/data tmpdir=/home/test/software/mysql/tmp socket=/home/test/software/mysql/data/mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f0c40e516eac8f0545a828a1d98361c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e7a1a012fabc4c0c16539b06f28af57/" rel="bookmark">
			统计某一字符或字符串在另一个字符串中出现的次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：使用match()方法 // 统计某一字符或字符串在另一个字符串中出现的次数 function countStr(str,target) { let count = 0 if (!target) { return count } else { // str.match(target) 若数值匹配到，则返回的是一个数组。若匹配不到，则返回null while(str.match(target)) { str = str.replace(target, '') count++ } return count } } console.log(countStr('22abcfh ab cabc','abc')) // 2 方法二：使用正则 RegExp 对象用于规定在文本中检索的内容
RegExp 是正则表达式的缩写
当您检索某个文本时，可以使用一种模式来描述要检索的内容。RegExp 就是这种模式。
function countStr(str, target) { if (!target) { return 0 } else { console.log(str.match(new RegExp(target, 'g'))) // ["abc", "abc"] return str.match(new RegExp(target, 'g')).length } } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e7a1a012fabc4c0c16539b06f28af57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb1611890d86498f158552e8a0eb2dd/" rel="bookmark">
			echarts---多个柱子一组的柱状图 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在公司做项目的时候，直接用官网现成的模板，柱子显示不出来，可能与项目中的某些配置冲突了才导致的；根据其他的模板，修改之后，可以实现相同的效果：
&lt;div id="myChart1" style="width: 1000px;height: 300px;margin: 0 auto"&gt;&lt;/div&gt; import * as echarts from 'echarts' methods:{ drawLine(){ // 基于准备好的dom，初始化echarts实例 let myChart1 = this.$echarts.init(document.getElementById('myChart1')) // 绘制图表 myChart1.setOption({ title: { text: '损耗电量统计分析图', }, tooltip: { trigger: 'axis', axisPointer: { // 坐标轴指示器，坐标轴触发有效 type: 'shadow' // 默认为直线，可选为：'line' | 'shadow' } }, legend: { data: ['供电量（单位：kWh）', '售电量（单位：kWh）', '耗损电量（单位：kWh）'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis: [ { type: 'category', data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月','8月','9月','10月','11月','12月'] } ], yAxis: [ { type: 'value' } ], series: [ { name: '供电量（单位：kWh）', type: 'bar', data: [1258470.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cb1611890d86498f158552e8a0eb2dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ac18fa57718345a9a0f4f4c5fa3ab8/" rel="bookmark">
			Springcloud微服务Docker部署实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础镜像 基础镜像先使用官方的openjdk:11镜像，之后看情况自制对应的镜像。
拉取镜像 docker pull openjdk:11 默认是Debian的大小为654MB，需要自制成Centos7的。
制作CentOs7镜像 拉取CentOs:7.9.2009镜像
docker pull centos:7.9.2009 Dockerfile文件
# 基础镜像 FROM centos:7.9.2009 # 创建java文件所放目录 RUN mkdir /usr/local/java # 将jdk压缩文件复制到镜像中，它将自动解压缩tar文件 ADD jdk-11.tar.gz /usr/local/java/ # 设置环境变量 ENV JAVA_HOME /usr/local/java/jdk-11 ENV PATH $JAVA_HOME/bin:$PATH 生成镜像
docker build -t openjdk-centos7:11 . 生成镜像大小为604MB
微服务镜像 整体目录结构如下：
├── .env ├── docker-compose.yml ├── Dockerfile └── service ├── aec-service-user-1.0.jar ├── config │ ├── application-mqtt.yml │ ├── application-rabbitmq.yml │ ├── application-service.yml │ ├── application-user.yml │ └── application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75ac18fa57718345a9a0f4f4c5fa3ab8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aecc904a46862ea97dde71f4ad3b8d1/" rel="bookmark">
			学习笔记（2）RT-Thread使用硬件定时器(HWTIMER)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章使用的是芯片是STM32ZET6。
参考的RT-Thread开发文档：HWTIMER设备 (rt-thread.org)
首先我们可以打开board.h文件，查看配置硬件定时器需要哪些步骤。
和使用其他外设一样，使用硬件定时器主要分为4步。
1：在RT-Thread Settings中开启硬件定时器:
2:打开board.h文件，并且将
#define BSP_USING_TIM
#define BSP_USING_TIM2 取消掉注释。（由于我使用的为定时器2，所以将其修改为TIM2）
3：打开CubeMx,进行配置定时器的配置。
生成文件后将stm32f1xx_hal_msp.c中的HAL_TIM_Base_MspInit函数复制到board.c中.
拷贝过去以后，发现编译报错说函数重复定义，只需要双击报错语句，就会自动跳转到报错的地方，将重复函数删除即可。
4：打开driver目录下的stm32f1xx_hal_conf_bak.h文件，将HAL_TIM_MODULE_ENABLED取消掉注释。
这样我们就配置好了定时器2。 假如说程序报错说我们没有TIM_CONFIG,那我们可以打开tim_config.h文件，在TIM2_CONFIG前面加入TIM1_CONFIG.(rt-thread好像没有TIM1_CONFIG所以需要自己加），里面的参数和TIM2_CONFIG相同，需要将TIM2改成TIM1,但是会有其他的一些问题，所以我们用硬件定时器的话我们就用有的TIM2、3、4、5）就行了。
随后我们在main.c中进行函数的编写。这里我参考了官方文档。程序如下：
/* * 程序清单：这是一个 hwtimer 设备使用例程 * 例程导出了 hwtimer_sample 命令到控制终端 * 命令调用格式：hwtimer_sample * 程序功能：硬件定时器超时回调函数周期性的打印当前tick值，2次tick值之差换算为时间等同于定时时间值。 */ #include &lt;rtthread.h&gt; #include &lt;rtdevice.h&gt; #define HWTIMER_DEV_NAME "timer2" /* 定时器名称 */ /* 定时器超时回调函数 */ static rt_err_t timeout_cb(rt_device_t dev, rt_size_t size) { rt_kprintf("this is hwtimer timeout callback fucntion!\n"); rt_kprintf("tick is :%d !\n", rt_tick_get()); return 0; } static int hwtimer_sample(int argc, char *argv[]) { rt_err_t ret = RT_EOK; rt_hwtimerval_t timeout_s; /* 定时器超时值 */ rt_device_t hw_dev = RT_NULL; /* 定时器设备句柄 */ rt_hwtimer_mode_t mode; /* 定时器模式 */ rt_uint32_t freq = 10000; /* 计数频率 */ /* 查找定时器设备 */ hw_dev = rt_device_find(HWTIMER_DEV_NAME); if (hw_dev == RT_NULL) { rt_kprintf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aecc904a46862ea97dde71f4ad3b8d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af41ff7b35c35bf1c8244401499a7a2d/" rel="bookmark">
			Netty(一)深入Hotspot源码与Linux内核理解NIO与Epoll
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入Hotspot源码与Linux内核理解NIO与Epoll 前言介绍Netty 的介绍Netty 的应用场景理解阻塞和同步关键字初始BIO、NIO、AIOBIO(Blocking IO)缺点：应用场景： NIO(Non Blocking IO)应用场景：NIO非阻塞代码示例存在的问题 NIO 有三大核心组件：Channel(通道)， Buffer(缓冲区)，Selector(多路复用器)Epoll函数详解Redis线程模型 AIO(NIO 2.0) BIO、 NIO、 AIO 对比：为什么Netty使用NIO而不是AIO？ 同步异步与阻塞非阻塞(段子) 前言介绍 在Java中，提供了一些关于使用IO的API，可以供开发者来读写外部数据和文件，我们称这些API为Java IO。IO是Java中比较重要知识点，且比较难学习的知识点。并且随着Java的发展为提供更好的数据传输性能，目前有三种IO共存；分别是BIO、NIO和AIO。
学习完这三种IO之后会去学习Netty,本人也是抱着学习的目标来写这些文章的。如果有任何不对的地方还望指正
Netty 的介绍 Netty 是由 JBOSS 提供的一个 Java 开源框架，现为 Github 上的独立项目。Netty 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 IO 程序。Netty 主要针对在 TCP 协议下，面向 Client 端的高并发应用，或者 Peer-to-Peer 场景下的大量数据持续传输的应用。Netty 本质是一个 NIO 框架，适用于服务器通讯相关的多种应用场景。
要透彻理解 Netty，需要先学习 NIO，这样我们才能阅读 Netty 的源码。 Netty 的应用场景 互联网行业 互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。
典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框 架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af41ff7b35c35bf1c8244401499a7a2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ae08158a2a983d108497d742fc1408/" rel="bookmark">
			uniapp日历插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日历插件 效果图一、使用方法二、组件编写，两个文件、直接上代码month.vuecalendar.vue 效果图 一、使用方法 &lt;template&gt; &lt;view&gt; &lt;view class="" @click="open"&gt; &lt;text&gt;展示日历{{value[0]}}-{{value[1]}}&lt;/text&gt; &lt;/view&gt; &lt;calendar v-if="show" @change="change" @close="close" :show.sync="show" v-model="value" :option="dateOption"&gt;&lt;/calendar&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { dateOption: { formatter:'yyyy/mm/dd',//默认为时间戳 minDate:'2023/01/05', //默认为当前日期往前6个月 maxDate: '2023/11/11',//默认为当前日期往后6个月 dateNum: 2, //选择的日期个数，可选值1，2， 默认为2 minRange: 0, //两个日期的间隔天数，默认为0 startText: '开始', //第一个日期的文字显示，默认‘开始’ endText: '结束',//第一个日期的文字显示，默认‘结束’ }, value: [], show: false, } }, methods: { open(){ this.show = true; }, // value值发生变更，可选 change(){}, // 关闭日历事件触发，可选 close(){} } } &lt;/script&gt; 二、组件编写，两个文件、直接上代码 month.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ae08158a2a983d108497d742fc1408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3a64d295212620a952e4d8685c57452/" rel="bookmark">
			Android性能优化之利用LeakCanary检测内存泄漏及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android性能优化之利用LeakCanary检测内存泄漏及解决办法 什么是内存泄漏？ 有些对象只有有限的生命周期。当它们的任务完成之后，它们将被垃圾回收。如果在对象的生命周期本该结束的时候，这个对象还被一系列的引用，这就会导致内存泄漏。随着泄漏的累积，app将消耗完内存。
内存泄漏造成什么影响？ 它是造成应用程序OOM的主要原因之一。由于android系统为每个应用程序分配的内存有限，当一个应用中产生的内存泄漏比较多时，就难免会导致应用所需要的内存超过这个系统分配的内存限额，这就造成了内存溢出而导致应用Crash。
什么是LeakCanary？ leakCanary是Square开源框架，是一个Android和Java的内存泄露检测库，如果检测到某个 activity 有内存泄露，LeakCanary 就是自动地显示一个通知，所以可以把它理解为傻瓜式的内存泄露检测工具。通过它可以大幅度减少开发中遇到的oom问题，大大提高APP的质量。
本篇不介绍如何使用LeakCanary，关于LeakCanary使用参考以下文章：
1.LeakCanary: 让内存泄露无所遁形 2.LeakCanary 中文使用说明
LeakCanary捕获常见内存泄漏以及解决办法 1.）错误使用单例造成的内存泄漏 在平时开发中单例设计模式是我们经常使用的一种设计模式，而在开发中单例经常需要持有Context对象，如果持有的Context对象生命周期与单例生命周期更短时，或导致Context无法被释放回收，则有可能造成内存泄漏，错误写法如下：
public class LoginManager { private static LoginManager mInstance; private Context mContext; private LoginManager(Context context) { this.mContext = context; } public static LoginManager getInstance(Context context) { if (mInstance == null) { synchronized (LoginManager.class) { if (mInstance == null) { mInstance = new LoginManager(context); } } } return mInstance; } public void dealData() { } } 弱我们在一个Activity中调用的，然后关闭该Activity则会出现内存泄漏。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3a64d295212620a952e4d8685c57452/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a44b686e397a44fc8cd787bf52f8de5/" rel="bookmark">
			短视频平台-小说推文（QQ阅读拉新）推广任务详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务详情（众拾网络公众号） QQ阅读通知: 接口内测阶段，小程序QQ阅读暂时下线提词功能，具体上线时间待通知。不影响已有词以及回填功能。请知悉。
《QQ阅读爆款书单》 https://uzhyprsxpa.feishu.cn/sheets/shtcnd7HT1rZFhy mBJL4PjAim5d?from=from copylink
复制到浏览器打开
QQ阅读 1.1 关键词 QQ阅读关键词审核时间
周一~周五(周末可提词，结果周一出)注意:
1.关键词字数:4-8个字
2.关键词不可涉黄、涉政，不可蹭已有流量词、符号，字母，空格，标点等不合规行为
3.一个关键词仅能对应一个内容链接:一个内容链接可以对应多个关键词;
4.关键词审核通过，且自己搜索后内容对应才可以作品发布;
5.关键词具有唯一性，多人不能重复使用;
6.永久有效(3个月内如无搜索则会失效，有的话就持续有效)
1.2 回填 一个关键词回填一次;
发布视频当天晚上21:00点之前回填(视频链接)
1.3 订单 第三天晚上可查(22:00点之前)，周末不更新，顺延到周一;
1.4 结算 单价8元，周结(每周末开始打款，预计2-3天内到账);
联系我立即做任务吧~
QQ阅读拉新推广教程 一．抖音账号如何绑定小程序
打开小程序，点击“我的”，点击“我的账号”，再点击“新增账号”进入到账号绑定界面
​
​
​
​
​
二.关键词如何添加：
点击立即做项目，点击新增关键词，输入好所有信息之后点击确认即可
​
​
三．审核中的关键词如何查看
点击审核中就可以看见申请的关键词正在审核
四．已驳回关键词如何查看及关键词如何修改
点击已驳回就能看见被驳回的关键词， 点击重新编辑即可进入修改
查看不通过的原因是什么，然后再重新修改，修改好之后点击确认即可
五．审核通过的关键词如何查看
点击审核通过，这里就能看见通过的关键词，关键词通过就可以去发布作品了
​
六．点击我的发布 里面有 待发布 已发布 所有作品
1. 待发布是通过的关键词可以去发布
2. 已发布是该关键词去抖音平台发布成功并且回填了
3. 所有作品是QQ阅读拉新你申请的关键词审核通过的作品
​
七．关键词如何回填
点击立即做项目，再点击审核通过，在点击立即发布回填
​
​
​
八．任务详情查看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a44b686e397a44fc8cd787bf52f8de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56cc6b1b040837c05621ddf59dfe4b72/" rel="bookmark">
			uni-app 用户记住账号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.页面显示
&lt;view style="margin-top: 20rpx;"&gt; &lt;checkbox-group&gt; &lt;label style="color: #977556;font-weight: bold;font-size: 20px;"&gt; &lt;checkbox value="psw" :checked='rememberPsw' @tap="rememberPsw =! rememberPsw" color="#09CC86" /&gt; 记住账号 &lt;/label&gt; &lt;/checkbox-group&gt; &lt;/view&gt; 2.data全局定义
rememberPsw: true, //记住账号 3.将记住账号内容放在本地缓存中
if (_this.rememberPsw) { uni.setStorageSync('loginName', _this.loginName); } else { uni.removeStorageSync('loginName'); _this.loginName = ""; } 4.页面加载完成后获取本地缓存中的用户名/账号
mounted() { //页面加载完成，获取本地存储的用户名及密码 const loginName = uni.getStorageSync('loginName'); if (loginName) { this.loginName = loginName; } else { this.loginName = ""; } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdde9b0f48ffc24aa2b479e779db5931/" rel="bookmark">
			[C&#43;&#43;] 查找无序数组的中位数（利用大小顶堆实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、思路 中位数无非就是在一组数最中间的位置，或者中间的两个数的平均值，可以想象利用一个大顶堆在左边，小顶堆在右边，则左边的堆顶元素是比较小的数的最大值，而右边大顶堆的堆顶元素是比较大的数的最小值，那么中位数就夹在两个堆顶元素的中间，也就是两个堆顶元素的平均值（数组长度为偶数，两个堆大小相等），或是元素数量比较多的堆的堆顶元素（数组长度为奇数，两个堆大小自然不相等，多出来的那个堆的堆顶元素自然就是中位数）。
具体实现：遍历数组中的每个元素，将逐个元素分别加入大顶堆或小顶堆（若当前元素进入大顶堆排好序后将堆顶元素交给小顶堆，则下一个元素进入小顶堆排好序后将堆顶元素交给大顶堆，如此循环直至遍历整个数组）。利用一个大顶堆和一个小顶堆互相交换堆顶元素，实现每轮大顶堆中的最大值交给右边的小顶堆，或小顶堆的最小值交给左边的大顶堆，从而将中位数夹住。完成查找无序数组的中位数。
二、代码 #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; int SearchMiddle(int c[], int len){ // 查找中位数函数 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; maxpq; // 声明一个最大优先队列 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; minpq; // 声明一个最小优先队列 for(int i = 0; i &lt; len; ++i){ if(maxpq.size() == minpq.size()){ // 若大顶堆长度等于小顶堆长度，则将小顶堆的堆顶元素给大顶堆 minpq.push(c[i]); maxpq.push(minpq.top()); minpq.pop(); } else{ // 若大小顶堆长度不相等，则将大顶堆的堆顶元素给小顶堆 maxpq.push(c[i]); minpq.push(maxpq.top()); maxpq.pop(); } } // 如果数组长度为偶数，返回两个堆顶元素之和的平均值，若为奇数，则返回大顶堆的队头元素（因为最后一个入队的元素会加入大顶堆） return len % 2 == 0 ? (maxpq.top() + minpq.top()) / 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdde9b0f48ffc24aa2b479e779db5931/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eac66a587546c9f70ffb4bb8aed03bb2/" rel="bookmark">
			Blinker点灯科技函数意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 attach()
BlinkerButton.attach()
注册按键的回调函数, 当收到指令时会调用该回调函数
icon()
BlinkerButton.icon()
设置按键中显示的图标(icon), 图标列表及对应图标名称见
color()
BlinkerButton.color()
设置按键中显示图标的颜色, HTML颜色表
text()
BlinkerButton.text()
设置按键中显示的名字或者描述
BlinkerButton.text(text1)
一段描述文字
BlinkerButton.text(text1, text2)
两段描述文字
print()
BlinkerButton.print()
发送按键当前的状态(多用于开关模式下反馈开关状态), 并将以上设置一并发送到APP
void button1_callback(const String &amp; state) { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));//LED BLINKER_LOG("get button state: ", state); //获取BUTTON 信息 Button1.icon("icon_1"); // 设置按键中显示的图标(icon) Button1.color("#FFFFFF");// 设置按键中显示的图标的颜色 Button1.text("Your button name or describe");// 设置按键中显示的文本 Button1.print("on");// 发送按键当前的状态 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce44ef2dedc83bd6d96511e1832acbc2/" rel="bookmark">
			v-model的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		v-model 是 Vue.js 框架提供的一个指令，用于实现表单元素与 Vue 实例数据之间的双向数据绑定。
它的原理是：
在模板中使用 v-model 指令绑定表单元素的 value 属性（例如 input、textarea、select 等）到 Vue 实例中的一个属性。
当用户在表单元素中输入内容时，该元素的 value 值会被更新，并触发 oninput 事件。
Vue.js 监听该元素的 oninput 事件，并通过新旧值的比较来确定数据是否发生了变化。
如果数据已经发生变化，则更新 Vue 实例中绑定的属性值，从而实现数据的双向绑定。
如果用户在表单元素中按下回车键或者失去焦点，则该元素的 onchange 事件也会触发。Vue.js 同样监听该事件，并在事件处理函数中将表单元素的值同步到 Vue 实例中。
综上，v-model 的双向绑定原理就是通过在模板中绑定表单元素的 value 属性和监听表单元素的 input 和 change 事件来实现的。它可以大大简化开发人员对表单数据的处理和管理，使得代码更加简洁易读。
假设我们有一个 Vue 实例，其中有一个属性 message，它绑定了一个 input 元素的 value 值。我们可以使用 v-model 指令来实现该元素与 Vue 实例中 message 属性的双向绑定，如下所示：
&lt;template&gt; &lt;div&gt; &lt;input type="text" v-model="message"&gt; &lt;p&gt;您输入的是：{{ message }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { message: '' } } } &lt;/script&gt; 在上述代码中，我们使用 v-model 指令将 input 元素的 value 绑定到了 Vue 实例的 message 属性上。当用户在 input 元素中输入内容时，该元素的 value 值会被更新，并触发 input 事件。Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce44ef2dedc83bd6d96511e1832acbc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90bd22e183c533a3949f08df752278d9/" rel="bookmark">
			java防止重复提交的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了防止重复提交，可以采用以下几种方法：
1. 令牌机制（Token）
在表单中添加一个隐藏字段，用于存放一个随机生成的令牌（Token）。当用户提交表单时，将令牌一起提交到服务器。服务器接收到请求后，首先检查令牌是否存在，如果不存在则拒绝请求；如果存在，则将令牌从服务器中移除，并处理请求。这样，即使用户多次提交表单，由于令牌已经被移除，后续的请求都会被拒绝。
2. 使用POST-REDIRECT-GET（PRG）模式
在处理完POST请求后，服务器不直接返回响应，而是返回一个重定向（REDIRECT）到GET请求的响应。用户的浏览器会根据重定向地址发起一个新的GET请求，服务器再返回最终的响应。这样，即使用户刷新页面，也只会重复发起GET请求，而不会重复提交表单。
3. 使用AJAX异步提交
通过AJAX异步提交表单，可以在不刷新页面的情况下将数据发送到服务器。在提交成功后，可以禁用提交按钮，防止用户多次点击。
4. 在服务器端设置限制
在服务器端可以设置一定的限制，例如限制同一个用户在一定时间内只能提交一次表单。这可以通过记录用户的IP地址和提交时间来实现。
5. 使用浏览器缓存
在响应头中设置`Cache-Control`为`no-store`，可以禁止浏览器缓存页面。这样，当用户刷新页面时，浏览器会重新请求页面，而不是直接从缓存中加载。这可以降低重复提交的风险。
综合以上方法，可以有效地防止重复提交。在实际应用中，可以根据具体需求选择合适的方法。
常用的java防止重复提交代码：
1. 前端防止重复提交
在前端页面中，可以通过禁用提交按钮或者在提交时添加遮罩层来防止用户重复提交。例如：
```javascript
// 禁用提交按钮
$('form').submit(function() {
$('input[type=submit]', this).attr('disabled', 'disabled');
});
// 添加遮罩层
$('form').submit(function() {
$('body').append('&lt;div class="overlay"&gt;&lt;/div&gt;');
});
```
2. 后端防止重复提交
在后端代码中，可以通过生成唯一的token来防止重复提交。例如：
```java
// 生成token
String token = UUID.randomUUID().toString();
request.getSession().setAttribute("token", token);
// 验证token
String clientToken = request.getParameter("token");
String serverToken = (String) request.getSession().getAttribute("token");
if (clientToken == null || !clientToken.equals(serverToken)) {
// token不一致，说明重复提交
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90bd22e183c533a3949f08df752278d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0583f39226e22e285db8967dfbe27746/" rel="bookmark">
			uni-app--JavaScript 正则验证手机号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //设置正则表达式的手机号码格式 规则 ^起点 $终点 1第一位数是必为1 [3-9]第二位数可取3-9的数字 \d{9} 匹配9位数字 if (!(/^1[345789]\d{9}$/.test(手机号))) { uni.showToast({ title: '手机号码格式不正确', icon: 'none' }) //失败执行操作 } else { //成功执行操作 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6e3529e93066b84dba1d7f3c005c2ec/" rel="bookmark">
			Docker启动nginx服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker启动nginx服务
Docker启动nginx服务，搭建静态资源服务器。
[Docker 启动nginx服务]
1、先启动空的nginx服务
2、将docker nginx服务的配置文件拷贝到本地要挂载的目录下
3、删除之前的空nginx服务，重新启动nginx服务，且挂载本地目录
4、编辑本地挂载目录下的配置文件nginx.conf
5、重启服务，访问更新后的配置文件路由的资源
docker pull nginx docker run -d --name my_nginx nginx (base) hay@192 nginx_web_demo % pwd /Users/hay/Documents/nginx_web_demo # 本地先创建需要的对应的文件夹conf、static、logs,拷贝文件到本地目录 (base) hay@192 nginx_web_demo % docker cp my_nginx:/etc/nginx/nginx.conf $PWD/conf (base) hay@192 nginx_web_demo % docker cp my_nginx:/etc/nginx/conf.d $PWD/conf # 停止且删除空nginx服务 (base) hay@192 nginx_web_demo % docker stop d7db8c091314 (base) hay@192 nginx_web_demo % docker rm d7db8c091314 #进入nginx服务，可以使用whereis、which 查看nginx服务的配置位置 whereis nginx /etc/nginx/nginx.conf # 重新创建nginx服务，且(使用-v)设置挂载本地的目录(本地配置文件和静态资源) (base) hay@192 nginx_web_demo % docker run -d -p 80:80 \ --name my_nginx \ -v /Users/hay/Documents/nginx_web_demo/static:/usr/share/nginx/html \ -v /Users/hay/Documents/nginx_web_demo/conf/nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6e3529e93066b84dba1d7f3c005c2ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b2894166c93c86ab4f55900943640d/" rel="bookmark">
			Spring Boot 如何引用配置文件内容 ？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot 应用程序通常使用属性文件来配置应用程序的行为。这些属性文件可以包含应用程序所需的各种配置信息，如数据库连接字符串、端口号、日志级别等。
Spring Boot 应用程序可以通过 @Value 注解或 @ConfigurationProperties 注解从属性文件中获取配置项的值：
1. @Value 注解:
@Value 注解可以用来注入一个给定属性的值，例如：
@Value("${myapp.db.url}") private String dbUrl; 这个例子中，${myapp.db.url} 表示属性文件中名为 myapp.db.url 的属性的值。Spring Boot 在启动时会读取属性文件，并将其值注入到 dbUrl 字段中。
2. @ConfigurationProperties 注解:
@ConfigurationProperties 注解可以用来将属性文件中的多个属性绑定到一个 POJO 对象上，例如：
@Configuration @ConfigurationProperties(prefix = "myapp") public class MyAppProperties { private String dbUrl; private int port; // getter and setter methods } 在这个例子中，@ConfigurationProperties(prefix = "myapp") 指定了属性文件中所有以 myapp 开头的属性都会绑定到该类的字段上。Spring Boot 在启动时会读取属性文件，并将所有符合条件的属性值绑定到 MyAppProperties 类的相应字段上。
然后可以在其他 Spring Bean 中注入 MyAppProperties 对象，并使用其字段的值来配置应用程序的行为。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad800a31097d2b4ed69474c7eeb770ff/" rel="bookmark">
			同一台电脑管理多个ssh key
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况下，我们在本地电脑生成的密钥都是 id_rsa 和 id_rsa.pub ，git 默认情况下也只会读取这个私钥，所以我们需要修改一些配置来支持多个SSH Key。
本文基于Linux系统，Windows系统类似
第一步：生成ssh公私钥 ljh@pc:~/.ssh$ ssh-keygen -t rsa -C "xxx@qq.com"
Generating public/private rsa key pair.
Enter file in which to save the key (/home/ljh/.ssh/id_rsa): id_rsa_gitlab
第二步：把生成的key添加到ssh-agent里面 ssh-agent是一个私钥的管理工具，当我们需要通过不同的私钥去连接不同的服务器时，需要我们手动输入私钥密码，ssh-agent可以免去这项工作，那么我们需要将新的key 添加到ssh-agent里面管理，可以通过ssh-add命令，首先我们看下里面有哪些key：
ljh@pc:~/.ssh$ ssh-add -l
2048 SHA256:xxx /home/ljh/.ssh/id_rsa (RSA)
默认情况下id_rsa已经存在里面，那么我们此时应该把上面新建的key也添加到里面：
ljh@pc:~$ ssh-add /home/ljh/.ssh/id_rsa_gitlab
Identity added: /home/ljh/.ssh/id_rsa_gitlab (/home/ljh/.ssh/id_rsa_gitlab)
第三步：配置config,关联本地与远程的key 在.ssh/ 目录里创建一个config文件，通过配置信息告诉git什么情况下使用新的key：
ljh@pc:~/.ssh$ touch config
ljh@pc:~/.ssh$ vim config
添加下面内容：
# github
Host github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_github
User ljh
# gitlab
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad800a31097d2b4ed69474c7eeb770ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b0750367a8b204ace8b37c6062c777/" rel="bookmark">
			MySQL数据库——MySQL LIMIT：限制查询结果的条数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当数据表中有上万条数据时，一次性查询出表中的全部数据会降低数据返回的速度，同时给数据库服务器造成很大的压力。这时就可以用 LIMIT 关键字来限制查询结果返回的条数。
LIMIT 是 MySQL 中的一个特殊关键字，用于指定查询结果从哪条记录开始显示，一共显示多少条记录。
LIMIT 关键字有 3 种使用方式，即指定初始位置、不指定初始位置以及与 OFFSET 组合使用。
指定初始位置 LIMIT 关键字可以指定查询结果从哪条记录开始显示，显示多少条记录。
LIMIT 指定初始位置的基本语法格式如下：
LIMIT 初始位置，记录数
其中，“初始位置”表示从哪条记录开始显示；“记录数”表示显示记录的条数。第一条记录的位置是 0，第二条记录的位置是 1。后面的记录依次类推。
注意：LIMIT 后的两个参数必须都是正整数。
例 1
在 tb_students_info 表中，使用 LIMIT 子句返回从第 4 条记录开始的行数为 5 的记录，SQL 语句和运行结果如下：
mysql&gt; SELECT * FROM tb_students_info LIMIT 3,5; +----+-------+---------+------+------+--------+------------+ | id | name | dept_id | age | sex | height | login_date | +----+-------+---------+------+------+--------+------------+ | 4 | Jane | 1 | 22 | F | 162 | 2016-12-20 | | 5 | Jim | 1 | 24 | M | 175 | 2016-01-15 | | 6 | John | 2 | 21 | M | 172 | 2015-11-11 | | 7 | Lily | 6 | 22 | F | 165 | 2016-02-26 | | 8 | Susan | 4 | 23 | F | 170 | 2015-10-01 | +----+-------+---------+------+------+--------+------------+ 5 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b0750367a8b204ace8b37c6062c777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8377ad8c5f9b098636ed5441c870018f/" rel="bookmark">
			windows下jar包部署并设置开机自启动bat脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows下jar包部署并设置开机自启动bat脚本 1. jar包部署1.1 批处理文件编写格式1.2 新建bat文件，进行编辑 2. 设置开机自启动bat脚本2.1 新建vbs文件2.2 在系统启动目录下添加上面的启动文件 1. jar包部署 1.1 批处理文件编写格式 @echo off start javaw -Dfile.encoding=UTF-8 -jar xxx.jar exit 这里的javaw加w表示后台启动解决乱码问题：加上 -Dfile.encoding=UTF-8延迟五秒: ping -n 5 127.0.0.1 &gt; nul 1.2 新建bat文件，进行编辑 例：新建start.bat，内容如下：
@echo off start "xxl-job-admin" javaw -Dfile.encoding=UTF-8 -jar C:\xxx\xxl-job-admin-1.0-SNAPSHOT.jar ping -n 5 127.0.0.1 &gt; nul start "program" javaw -Dfile.encoding=UTF-8 -jar C:\xxx\saasjingcheng-program-1.0-SNAPSHOT.jar exits 此时，双击该bat脚本即可启动jar包；但是下次开机时，无法自动启动，还是需要双击该脚本，如何设置开机自启动继续看下面的方法。
2. 设置开机自启动bat脚本 2.1 新建vbs文件 例：新建start.vbs，内容如下：
set ws=WScript.CreateObject("WScript.Shell") ws.Run "start.bat文件的路径 /start",0 2.2 在系统启动目录下添加上面的启动文件 2.2.1. 组合键“win + R”打开“运行”，输入“ shell:startup ”并按回车键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8377ad8c5f9b098636ed5441c870018f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f3e6b8991cd3f6208fd4c399fc268e4/" rel="bookmark">
			求一个数的所有质因子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ）
示例：
输入：180 输出：2 2 3 3 5 思路：从2开始遍历，能除尽就是质因子。
#include&lt;iostream&gt; using namespace std; int main(){ long num; cin &gt;&gt; num; long i = 2; while (i * i &lt;= num) { if (num % i == 0) { num /= i; cout &lt;&lt; i &lt;&lt; " "; } else { i++; } } if (num != 1) cout &lt;&lt; num &lt;&lt; " "; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2103b13b2a75a8cd056ee2ba8ade6fc3/" rel="bookmark">
			merge和rebase的区别-Git实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言什么是分支？演示（新建分支，切换分支，合并分支，删除分支）演示（回退版本、分支）idea更新代码时的两个选项Merge the incoming changes into the current branch与Rebase the current branch on top of the incoming changes结论：效果图（如何实操）操作流程 Git多次Commit合并为一次提交 前言 实操git管理工具，主要演示如何实现新建分支，提交分支，合并分支到主干，删除分支，管理分支功能。并且详细了解部分功能的区别。git安装与基础使用
什么是分支？ 顾名思义，在git中，分支指的是从主线上分离出来进行另外的操作，既不影响主线，主线又可以继续干它的事，它可用来解决临时需求；当分支做完事后可合并到主线上，而分支的任务完成可以删掉了。
通过分支可以使不同的团队各自作业，在关键节点上合并，平时互不干扰，也可以个人与团队并行作业，亦或者不同功能并行前进。
演示（新建分支，切换分支，合并分支，删除分支） 1、选择新建分支
2、输入分支名称
勾选下面的 checkout branch 表示新建分之后直接切换到相应分支。不勾选则默认当前分支
显示本地存在两个分支
3、提交到远程仓库进行管理
选择要远程仓库管理的分支-Push（刚刚我们新建的只存在本地，所以要先提交到远程仓库）
Push之后，就可以看到本地和远程都有了我们的两个分支；
如果是别人新建的远程分支你要同步到本地，选择Checkout as new local branch即可
4、合并分支
合并指的是另一个分支上的commit作用到当前的分支上来。
比如：我创建的xiaocao分支，原来是和master主分支代码完全相同的，但是我修改了xiaocao分支上的代码，所以需要合并到主分支master上去。
4.1 首先把修改后的代码分支（xiaocao），提交到远程仓库
4.2 切换到master分支
4.3 选择merge 进行合并分支
合并完成，我们就可以在master 本地看到我们改动的代码了；
这只是本地，并没有提交到远程分支，我们还需要再Push 一下。
4、删除分支
勾选下面的 Delete tracking local branch xiaocao as well 表示同时删除本地分支
提交成功！演示新建分支，切换分支，合并分支，删除分支就完成了
我想一定有很多人疑惑下面这张图片的命令有哪些作用吧，有帮助请一键三连，就是给我最大的动力。
Checkout ： 顾名思义就是切换当前分支进行开发（例如：目前我在主分支main上，想要切换到uat分支开发，点击Checkout即可）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2103b13b2a75a8cd056ee2ba8ade6fc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d4bd900114ae031881e0654dfb0faa/" rel="bookmark">
			设计模式之工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式之工厂模式 概述需求分析实现需求的工厂模式1. 简单工厂模式1.1 结构1.2 实现1.3 简单工厂类优缺点1.4 扩展 2. 工厂方法模式2.1 概念2.2 结构2.3 实现2.4 优缺点 3. 抽象工厂模式3.1 概念3.2 结构3.3 实现3.4 优缺点3.5 使用场景 4. 模式扩展JDK源码解析-Collection.iterator方法 概述 在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重。
所谓耦合严重就是在我们已经创建了对象的地方，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。
而所谓的工厂模式其实就是一个只负责创建对象的工厂，我们不需要跟每个对象打交道，只需要跟工厂说你需要那个对象就可以了，彻底和对象解耦。
如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦。
需求分析 先来看需求：
设计一个咖啡店点餐系统。
设计一个咖啡类（Coffee），并定义其两个子类
（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；
再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。
实现需求的工厂模式 简单工厂模式
工厂方法模式
抽象工厂模式
1. 简单工厂模式 简单工厂实际上并不是一种设计模式，反而比较像是一种编程习惯，因为这种模式并没有严格的实现了我们与对象之间的解耦，并且违反了开闭原则。
1.1 结构 简单工厂包含如下角色：
抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。
具体产品 ：实现或者继承抽象产品的子类
具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。
1.2 实现 现在我们就使用简单工厂类来实现我们的咖啡点餐系统。
咖啡类代码如下：
public abstract class Coffee { public abstract String getName(); //加糖 public void addsugar() { System.out.println("加糖"); } //加奶 public void addMilk() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04d4bd900114ae031881e0654dfb0faa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1123c4531282b114f68171b080f62225/" rel="bookmark">
			RabbitMQ基础及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 了解RabbitMQ的基本概念及应用
AMQP核心概念 AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。
二、AMQP模型
转载自 深入理解AMQP协议_一剑何风情的博客-CSDN博客
安装及入门 1
核心API 高级特性、 集群架构实操 SpringBoot应用 MQ组件的封装与应用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c74390ea3719027c0730f83f744a25/" rel="bookmark">
			麒麟系统下QT运行一端时间内存占满的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 链接：https://hpzwl.blog.csdn.net/article/details/128671382
解决 这就是Qt常规的方法，发布时，可使用屏蔽宏，屏蔽调所有的qDebug和qWarn输出。
在.pro文件中添加宏定义;
DEFINES += QT_NO_WARNING_OUTPUT DEFINES += QT_NO_DEBUG_OUTPUT 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d7a4ed5acb412dc28328728cd5c0244/" rel="bookmark">
			KAFKA高性能原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统正常文件读取，如下：
进行了4次拷贝，如果是10次消费，则需要40次拷贝
kafka则进行了 zero copy，使用page cache,内核缓存级别处理，10次消费只需要11次拷贝，如下
如果消费速度相当则kafka只使用到内存，无需缓存数据到磁盘，还有多节点消费
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11aadcc93e605817d1271ad5b3973f61/" rel="bookmark">
			nginx安装及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
一、安装Nginx
nginx.conf 核心配置文件
二、操作
1.Nginx 日志切割
手动
自动
root 与 alias假如服务器路径为：/home/imooc/files/img/face.pngroot 路径完全匹配访问配置的时候为：
location 的匹配规则
2.nginx跨域配置支持
3.Nginx 防盗链配置支持
三、upstream指令
upstream 指令参数 max_conns
upstream 指令参数 slow_start
upstream 指令参数 down、backup
upstream 指令参数 max_fails、fail_timeout
Keepalived 提高吞吐量
负载均衡 ip_hash
总结
前言 经常遇到的nginx问题及命令---------至主动之人！
一、安装Nginx 1. 去官网http://nginx.org/下载对应的nginx包，推荐使用稳定版本
2. 上传nginx到linux系统
3. 安装依赖环境
(1)安装gcc环境 yum install gcc-c++ (2)安装PCRE库，用于解析正则表达式 yum install -y pcre pcre-devel (3)zlib压缩和解压缩依赖， yum install -y zlib zlib-devel (4)SSL 安全的加密的套接字协议层，用于HTTP安全传输，也就是https yum install -y openssl openssl-devel 4. 解压，需要注意，解压后得到的是源码，源码需要编译后才能安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11aadcc93e605817d1271ad5b3973f61/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/148/">«</a>
	<span class="pagination__item pagination__item--current">149/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/150/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>