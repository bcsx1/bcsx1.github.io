<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e2aa8353762a650a2da8a2536539ed/" rel="bookmark">
			Instant Neural Graphics Primitives with a Multiresolution Hash Encoding以及源码浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 现存的一些新视图合成的训练过程和渲染速度都比较慢，其原因是因为query point需要使用MLP编码，而且在一个采样空间中，存在很多无效的query point也要计算其density和color，从而出现很多冗余计算。
作者针对这个问题，提出了基于哈希的特征提取方式，通过反向求导更新哈希表中的特征向量。
作者陈述了非哈希式的优化方法的弊端，即便像八叉树等方法可以将训练缩短至几分钟，但仍有多余计算，可以进一步精简。
方法 作者提出了多分辨率哈希索引，每个分辨率有独立的哈希表，将索引出来的特征全部concat之后送入MLP，得到的重建效果和之前的方法无异，而且训练速度和渲染速度更快。将参数量最多降低至20倍。
该方法其实很简单。Nerf是将世界坐标和视线方向通过MLP编码得到特征，然后使用两个独立的MLP将特征映射为密度和颜色；hash encoding则直接根据世界坐标x去索引方格8个角落的特征，然后三线性插值得到x的特征。所谓的哈希表其实就是类似于nn.Embedding的东西，可以通过整数进行索引一个指定维度的特征。
比较复杂的可能就是这是个多分辨率表结构，每个多分辨率都有独立的哈希表。分辨率的大小从一个coarse level到fine level，用一个b 作为scale。然后将多分辨率表中检索到特征concat到一起，得到所谓的哈希编码特征。
该特征可以用很多应用，比如论文列举了4个应用
Gigapixel Image ApproximationSigned Distance FunctionsNeural Radiance CachingNeural Radiance and Density Fields (NeRF) 源码浅析 论文地址
官方代码
hashNerf
torch-NGP
hash表的建立
self.embeddings = nn.ModuleList([nn.Embedding(2**self.log2_hashmap_size, \ self.n_features_per_level) for i in range(n_levels)]) 三线性插值
def trilinear_interp(self, x, voxel_min_vertex, voxel_max_vertex, voxel_embedds): ''' x: B x 3 voxel_min_vertex: B x 3 voxel_max_vertex: B x 3 voxel_embedds: B x 8 x 2 ''' # source: https://en.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e2aa8353762a650a2da8a2536539ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4779442cb0398c73bfdead01e18d85fa/" rel="bookmark">
			【Java 设计模式】创建者模式 之建造者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建造者模式 §1 定义§2 角色§3 类图§4 单车案例§4.1 类图§4.2 实现 §5 优缺点 §1 定义 建造者模式将一个复杂对象的构建与装配分离，实现构建与装配的解耦，如：单车（复杂对象）由车座、车架等配件组装而成，建造者模式将这些配件和使用配件组装成单车的过程分开，一步一步组装成单车，用户只需要指定单车的配件即可，无须知道配件的具体细节。 §2 角色 产品类（Product）：待创建的复杂对象，如：单车。抽象建造者类（Builder）：定义装配复杂对象需要使用到的组件，不涉及具体部件的创建，如：车架、车座等。具体建造者类（ConcreteBuilder）：实现或继承 Builder，完成复杂对象各个部件的创建。指挥者类（Director）：使用具体建造者创建的复杂对象的组件，负责将各个组件装配成复杂对象，如：使用车架、车座等配件装配出一辆单车。 §3 类图 §4 单车案例 §4.1 类图 §4.2 实现 // 产品类: 单车 public class Bike { private String frame; private String seat; public String getFrame() { return frame; } public void setFrame(String frame) { this.frame = frame; } public String getSeat() { return seat; } public void setSeat(String seat) { this.seat = seat; } } // 抽象建造者类 public abstract class Builder { protected Bike mBike = new Bike(); public abstract void buildFrame(); public abstract void buildSeat(); public abstract Bike createBike(); } // 具体建造者类: 摩拜单车 public class MobikeBuilder extends Builder { @Override public void buildFrame() { mBike.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4779442cb0398c73bfdead01e18d85fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3570ef95cfd4118c35532e37dc7e815e/" rel="bookmark">
			01.卷积和高斯【计算机视觉】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积和高斯 卷积图片的类型二值化图灰度图彩色图 为什么使用卷积？卷积的定义卷积的计算边缘填充边缘填充的作用边缘填充的方式 几种特殊的卷积核带来的效果 高斯振铃现象如何解决振铃现象--高斯内核（模板）高斯函数的定义高斯模板的性质 噪声高斯噪声椒盐噪声高斯滤波&amp;中值滤波总结 卷积 图片的类型 二值化图 （Binary）灰度图 （Gray Scale）彩色图（Color） 二值化图 二值化图每一个像素值不是1就是0
灰度图 灰度图的像素值是（0~255），只有一个通道（单通道），RGB都相等。
彩色图 彩色图RGB都有值，是三个通道的，如果用向量【组】来表示的话，彩色图的特征是灰度图的三倍。
为什么使用卷积？ 拿到下面的图片，我们应该怎样对他进行去燥呢？
让我们把每个像素替换成其邻域的加权平均数，进行去燥，这种方法由此可以引出卷积。
卷积的定义 卷积的计算 卷积操作其实就是每次取一个特定大小的矩阵F（蓝色矩阵中的阴影部分），然后将其对输入X（图中蓝色矩阵）依次扫描并进行内积（加权平均）的运算过程。
卷积需要先进行翻转再计算，而相关不需要翻转，但由于很多情况下卷积核都是对称矩阵，所以就省略了这一步。
边缘填充 边缘填充的作用 作用1：图形的像素不是靠位置来规定重要程度，但越里面的像素卷积次数越多，故我们需要进行边缘填充，将本来应该是边缘的像素变成不是边缘的像素。作用2：当卷积量过大时，避免图像边缘的大部分信息都丢失作用3：输入和输出的大小应该保持一致 边缘填充的方式 0填充镜像填充重复填充 几种特殊的卷积核带来的效果 （不考虑边界填充）
用这个卷积核来计算得到的是原图，无变化
用这个卷积核来计算得到的是 原图左移一个像素 。 故任何一个平移操作都可以用卷积来实现。
用这个卷积核来计算得到的是 平滑/去噪 。
用这个卷积核来计算得到的是 锐化 。
高斯 振铃现象 图像处理中，对一幅图像进行滤波处理，若选用的频域滤波器具有陡峭的变化，则会使滤波图像产生“振铃”，所谓“振铃”，就是指输出图像的灰度剧烈变化处产生的震荡，就好像钟被敲击后产生的空气震荡。如下图：
如何解决振铃现象–高斯内核（模板） 高斯模板的特点：离中心权值越大，离分散权值越小，故可以解决振铃现象。
高斯函数的定义 当定义好 σ \sigma σ以后， G σ G_\sigma Gσ​就可以求出，进而可以得到该图片的滤波核，然后进行归一化，最后得到高斯核。
一般我们将滤波核的大小和 σ \sigma σ定为以下关系：H,W = 2× σ \sigma σ+1，比如 σ \sigma σ=1，则大小为7×7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3570ef95cfd4118c35532e37dc7e815e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd736921e2a0bb6dc61b94f8520c6b24/" rel="bookmark">
			回文链表(详解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode HOT 100回文链表 想完全理解这道题还请先转入反转单链表【图文详解】掌握反转链表的思想
问题描述: 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
思路方法解读: 当我们遇到回文问题会想到，在数组里面我们可以用两个指针一个从头一个从尾开始遍历到中间，进行比较，那对于链表的操作是复杂的，我们可不可以将链表的值复制在数组里，对数组进行操作？答案是可以的。我们可以将链表的值复制到新申请的数组当中，利用双指针在数组中进行判断，因为需要新的数组空间上有了开销，那么这种方法一定不是最好的。
给出代码:
class Solution { public: bool isPalindrome(ListNode* head) { vector&lt;int&gt; vals; while (head != nullptr) { vals.emplace_back(head-&gt;val); head = head-&gt;next; } for (int i = 0, j = (int)vals.size() - 1; i &lt; j; ++i, --j) { if (vals[i] != vals[j]) { return false; } } return true; } }; 这种方法时间上需要遍历整个数组因此时间复杂度为O(n),空间上利用了辅助空间新数组因此也为O(n)。
如果想到了上面的方法，在面试时往往是不够的，我们需要考虑如果缩减他的时间或空间复杂度。时间上好像没有好的办法，我们都需要遍历链表，但是空间上我们想想如何不申请额外辅助空间，在原本链表上进行操作呢?
我们如果可以改变链表的部分指向，然后利用双指针进行比较呢?
力扣官方给出的思路是:
找到前半部分链表的尾节点。反转后半部分链表。判断是否回文。恢复链表。返回结果。 使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd736921e2a0bb6dc61b94f8520c6b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbaab4854ab0b1ce9287b07bdfdf2a0/" rel="bookmark">
			vmware虚拟机运行几分钟后越来越卡，最后卡死的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
在VMware下运行虚拟机，刚启动的时候不卡，用着用着越来越卡，最后大概在十几分钟的时候完全卡死，鼠标键盘输入都无效，挂起后继续运行能回到刚启动的状态，但是十几分钟后又卡死。。。。。
由于课程需要用到vmware虚拟机，但是使用过程中发现怎么会这么卡，我大一大二用的时候也不卡呀，而且固定十几分钟就会卡死实在是让人有点受不了，于是开始上网找办法（噢，一开始我以为是虚拟机版本的问题，我还把vmware16重装了一遍。。。然并卵），但是网上一搜虚拟机卡顿出来的都是说多给虚拟机分配一些内存处理器资源，试了，没用，然后有有的说，开启打印机服务，开启虚拟化服务什么的，都没用，我甚至把kali，ubuntu等虚拟机文件挪到了另一个盘上，重新打开，还是没用，虚拟机还是到了固定时间直接卡死。
后来，看到一篇csdn博客，里面的问题描述跟我的不能说毫无区别，只能说是一模一样啊！那个博主给出的解决办法是更新windows10系统，这个问题是由windows10自身的一个bug产生的，（区我把windows的自动更新关闭了）what？更新一下windows就行了？抱着试一试的心态试了一下，成了，虚拟机再也没有卡过了。。。。。哭了
windows自动更新还是得打开啊。。。。。
2022.11.2更新：
。。。哭了，昨天解决的问题今天电脑开机又是老样子，说明不是windows系统的问题，仔细想了想，昨天除了更新windows系统我还重启了电脑（Windows更新完毕要求我重启的，我电脑用完一般点休眠键）于是我试了一下重启电脑，done！问题解决
你是不是也跟我一样电脑用完都是点这个休眠键？
这样好像会导致一些问题，下次电脑开机的时候丢失了一些东西，具体原理我也不太懂，所以，每次用完电脑要真正关机才行
2022.11.27更新：
发现好像也不是电脑开关机的问题，但是当我把虚拟机重新装了一次之后，这个问题就消失了，所以应该不是vmware的问题，应该是虚拟机文件的问题。
下图中标红的是会卡死的虚拟机，标绿的是我新安装的虚拟机，不会卡死。
所以，重装一下虚拟机文件吧，这是解决问题最快的方法了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd74b288a9ed59ce40de3e1a6b0f40f4/" rel="bookmark">
			使用HutoolUtil工具包之树结构工具TreeUtil 快速处理数据树形结构数据，很好很强大！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专属小彩蛋：前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站（前言 - 床长人工智能教程）
数据准备 CREATE TABLE `content_file_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL COMMENT '名称', `parent_id` bigint(20) DEFAULT NULL COMMENT '所属分类', `order_num` int(11) DEFAULT NULL COMMENT '排序序号', `level` int(11) DEFAULT NULL COMMENT '第几分类，从1开始', `gmt_create` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `gmt_modify` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最近更新时间', PRIMARY KEY (`id`), KEY `level_idx` (`level`), KEY `parent_id_idx` (`parent_id`), KEY `name_idx` (`name`) ) ENGINE=InnoDB AUTO_INCREMENT=68 DEFAULT CHARSET=utf8 COMMENT='文件分类管理' 方案一： 一般情况下，我们自己写递归代码的方式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd74b288a9ed59ce40de3e1a6b0f40f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af2006d5a2c465e235bbdf97ae2919e6/" rel="bookmark">
			JAVA实现FTP多文件下载，说一说ftpClient.retrieveFileStream方法遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专属小彩蛋：前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站（https://www.captainai.net/spark）
问题描述：在搭建好的ftp服务器上面 ，每天定时任务 从 /拍照保存目录/1/{摄像头序列号}/{日期}/{xxx.jpg} 下载 摄像机拍摄的图片，并同步上传到fastDfs 文件系统，并同步到数据库中
1.第一步，获取ftp连接
2.第二步，不断的切换目录到存放有图片文件的目录下。
3.第三步，调用ftpClient.retrieveFileStream获取 远程文件的输入流，并写出。
4.第四步,也就是在实现此功能时遇到的坑，在每次执行完下载操作之后，completePendingCommand()会一直在等FTP Server返回226 Transfer complete，但是FTP Server只有在接受到InputStream 执行close方法时，才会返回。所以一定先要执行close方法。不然在第一次下载一个文件成功之后，之后再次获取inputStream 就会返回null。
,
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77921124ae6867ba14ab7fe46fe940ed/" rel="bookmark">
			抖音跳转微信小程序源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抖音跳转微信小程序源码 一两万买来的抖音跳转微信小程序源码 现在没做直播了，分享给大家
演示效果：
下载地址： https://gitee.com/dot2-com/douyin-kapian
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2305ee995a6f263242dc3ae19df52b3d/" rel="bookmark">
			动态库静态库的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、动态库以及静态库区别
静态库是函数和数据编译进一个二进制文件里面（.lib文件），在使用静态库链接成可执行程序的时候，链接器会复制静态库内的函数和数据进可执行程序里面(.EXE文件)，所以在加载库的时候不需要加载相应的库函数
动态库往往是提供两个文件，一个是引入库文件(.lib)和一个DLL(.dll)文件，但是引入库文件(.lib)只是包含DLL文件的导出函数以及函数的变量名符号，而DLL文件里包含了所有的函数以及数据，假如调用动态库是在编译到可执行程序的时候才会调用没有数据以及函数的复制，所以在发产品的时候需要加上相应的动态库
2、动态链接库加载函数的两种方法：
第一种是静态链接方式，在这种方式下，动态链接库中的所有数据代码都将拷贝到调用程序的代码空间中去，此时它和调用程序本身的函数没有什么区别；
第二种是动态链接方式，在这种方式下，动态链接库中的数据代码是在需要的时候才拷贝到内存中去的；
两种方式都可以将外部（动态链接库中的）代码资源提供给调用者使用，但前者是全局的，虽随时可以使用，但会增加内存；而后者是局部的，虽节省了内存，但会增加调用时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8c5ba834db1167e23e0c086d540aa95/" rel="bookmark">
			推荐模型-上下文感知-2010：因子分解机（FM）【POLY2的改进版】【隐向量特征交叉】【为每个特征学习一个隐权重向量，特征交叉时使用两个特征隐向量的内积作为交叉特征的权重】【2012-14年主流】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FM（Factorization Machines，因子分解机）早在2010年提出，作为逻辑回归模型的改进版，拟解决在稀疏数据的场景下模型参数难以训练的问题。并且考虑了特征的二阶交叉，弥补了逻辑回归表达能力差的缺陷。
《原始论文：Fast context-aware recommendations with factorization machines》
Steffen Rendle et al. “Factorization Machines.” in ICDM 2010.
GitHub参考代码：Recommend-System-tf2.0/FM/
FM 作为推荐算法广泛应用于推荐系统及计算广告领域，通常用于预测点击率 CTR（click-through rate）和转化率 CVR（conversion rate）。
FM、FFM模型只具备二阶特征交叉的能力。Deep Crossing模型可以通过调整神经网络的深度进行特征之间的“深度交叉”，这也 是 Deep Crossing名称的由来。
一、概述 1、辛普森悖论 在对样本集合进行分组研究时，在分组比较中都占优势的一方，在总评中 有时反而是失势的一方，这种有悖常理的现象，被称为“辛普森悖论”。下面用一个视频推荐的例子进一步说明什么是“辛普森悖论”。
假设表2-1和表2-2所示为某视频应用中男性用户和女性用户点击视频的 数据。
从以上数据中可以看出，无论男性用户还是女性用户，对视频B 的点击率 都高于视频A ,显然推荐系统应该优先考虑向用户推荐视频B。
那么，如果忽略性别这个维度，将数据汇总（如表2・ 3所示）会得出什么 结论呢？
在汇总结果中，视频A 的点击率居然比视频B 高。如果据此进行推荐， 将得出与之前的结果完全相反的结论，这就是所谓的“辛普森悖论”。
在 “辛普森悖论”的例子中，分组实验相当于使用“性别” + “视 频 id” 的 组合特征计算点击率，而汇总实验则使用“视频id” 这一单一特征计算点击率。 汇总实验对高维特征进行了合并，损失了大量的有效信息，因此无法正确刻画数 据模式。
2、LR（逻辑回归）的缺陷 逻辑回归模型表达能力不强的问题，会不可避免地造成有效信息的损失。
在 仅利用单一特征而非交叉特征进行判断的情况下，有时不仅是信息损失的问题， 甚至会得出错误的结论。
著名的“辛普森悖论”用一个非常简单的例子，说明了 进行多维度特征交叉的重要性。
逻辑回归只对单一特征做简单加权，不具备进行特征交叉生成高维组合特征的能力，因此表达能力很弱，甚至可能得出像“辛普森悖论”那样的错误结论。
因此，通过改造逻辑回归模型，使其具备特征交叉的能力是必要和迫切的。
3、POLY2模型一特征交叉的开始 针对特征交叉的问题，算法工程师经常采用先手动组合特征，再通过各种分析手段筛选特征的方法，但该方法无疑是低效的。
更遗憾的是，人类的经验往往 有局限性，程序员的时间和精力也无法支撑其找到最优的特征组合。因此，采用 P0LY2模型进行特征的“暴力”组合成了可行的选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8c5ba834db1167e23e0c086d540aa95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45b0919315a0be31a892910ae0197f74/" rel="bookmark">
			RGB彩色图、Depth深度图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💦彩色图，深度图——》信息缺乏。如，颜色相近导致位置信息丢失
💦深度图——》相近深度的物体，因为颜色或纹理的丢失，导致难区分
深度图并不可以直接使用， 因为深度图只能反映出了物体在三维空间中一个方向上的信息，即拍摄场景中各个点到相机的距离。这个信息并不全面，直接使用会丢失其余两个维度的信息。 💦彩色图和深度图，采集的是同一个场景，反应的是不同方面的特性。具有强相关性。
彩图和深度图的边界具有尖锐的信息变化。
仅依靠彩图可对边界进行区分：深度信息变化扮演补充信息和加强边界的角色。
红框：依靠彩图就可以区分前景与背景
篮框：前景与背景颜色相似，边缘颜色相近。仅利用颜色分割效果不理想。利用深度信息，深度差异可以弥补彩色信息的不足。
仅利用彩色信息做过分割面临同样的困境，比如Turbopixel、Ncut、SLIC等，很难对颜色相近的物体进行区分。————促使我们联合彩色信息和深度信息进行分割
深度图，不可直接用，需要将深度图的单维深度信息转化为空间的三维位置信息。
首要工作：深度信息转换为三维信息，然后利用具体位置来设计分割算法。
物体在世界坐标系中都会存在着各自的三维坐标，这个三维坐标代表了物体在空间中的位置，是绝对且唯一的。
深度相机采集深度图，通过相机内参矩阵，可以将图中每一个像素的位置对应到世界坐标系中，也就是，通过内参矩阵的变化，实现二维到三维空间的映射。
假设：空间坐标系、相机坐标系——》方向一致； 已知相机内参
(x,y) 来表示图像中一个像素的位置信息
d 来表示该像素点对应的深度信息
( X,Y,Z) 来表示该像素点的三维坐标————》通过这样的转换，我们就可以获得图像中每一个像素点在空间坐标系中对应的三维坐标。
fx 和 fy分别是 x 轴和 y 轴方向的焦距
γ 是这两个坐标轴之间的斜率
(x0,y0 )是相机的基准点位置坐标
聚类实现的空间=彩色信息+位置信息 共同组合的空间中实现的
基本维度=彩色空间3个维度+位置空间3个维度=6个维度
但是，由于深度图在边界位置具有离散特性+最终图像是在二维空间展示，所以加入图像二维坐标（x，y）到距离度量中（为了保证视觉上二维分割结果的连贯性）。
综上，距离度量实质是Lab--XYZ--xy 总共8个维度的度量空间。
分析：
lab：是像素在 CIELAB 彩色空间中的彩色矢量。这个空间有更 为宽广的颜色取值，因而不同颜色的离散程度更高，有利于衡量不同颜色之间的距离
XYZ:像素在重建三维空间中的坐标
xy：像素在图像中的坐标
————
描述这八个维度的参数实质代表的是不同性质的信息，因而不可以 直接用八维空间的欧式距离来度量像素间的距离
将[ Lab] ，[XYZ ] 和[xy ] 分别归一化到[0,1]之间使得不同分量之间的差异有相同的衡量区间
————
原因：深度传感器不完善，导致相邻深度层之间转变不是完美阶跃，而是有一种渐变的过渡段。
导致：二维到三维映射过程中，相邻物体边界处会产生一些离散的过渡点；过渡点对分割产生干扰
结果：边界参差不齐
解决：引入了像素在图像位置中 的二维距离dxy，通过二维图像位置的约束，来弱化这些带噪的三维空间点带来 的不良效果，使得分割结果看起来更为整洁
步骤：
1.利用图像计算每一个对应点的三维坐标
2.权重参数α 和 β（8维空间的距离计算做准备
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45b0919315a0be31a892910ae0197f74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f674da3c785b15c9d7ae1e189b8e3e/" rel="bookmark">
			Java-进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、进程是什么
特点
PCB-描述
组织
二、进程调度的特性
进程状态
优先级
上下文-读档 存档
记账信息
前言 由于CPU进入了多核心时代,这就要求了程序员如果要充分发挥出CPU的运算效率,就必须采用并发编程,进程这个概念也就被引入了。
提示：以下是本篇文章正文内容，下面案例可供参考
一、进程是什么 进程是程序依次动态执行的过程,它对应了从代码加载、执行到执行完毕的过程.这个过程也是进程本身从产生、发展到消亡的过程。一个进程可分为两个部分，分别为要执行的指令和执行指令时所需的各种系统资源，如CPU、内存等。
进程是包含线程的. 每个进程至少有一个线程存在，即主线程。进程中的每个线程执行不同的任务，这样就达到了多任务处理的目的。
特点 进程消耗资源（创建、销毁、调度）多，速度慢。
在操作系统内部，进程是操作系统进行资源分配的基本单位。
进程是操作系统对一个正在运行的程序的一种抽象，可以看作是一种资源，并且是由操作系统内核负责管理（描述+组织）的。
PCB-描述 由于操作系统一般由C/C++编写，所以使用了C语言的结构体来描述进程，那么这个结构体就称为了PCB（Process Control Block）。
PCB包括：pid 进程的身份标识符。内存指针 指向所在内存。文件描述符表 硬盘上的文件等资源。
组织 可以简单认为是通过双向链表将多个PCB串连在一起。 二、进程调度的特性 进程状态 就绪状态：随时都能到CPU上执行。
运行状态：正在CPU上执行。
阻塞状态：在这一段时间内，无法到CPU上执行。
优先级 进程有优先级，操作系统调度进程也是按照优先级顺序来进行工作的。
上下文-读档 存档 操作系统在进行进程切换的时候，会把进程执行的中间状态记录，当下次再次调用到这个进程的时候，会恢复到上次的状态。保存上下文，是此时CPU寄存器的值，保持到内存中（PCB）。回复上下文，是把内存中的值读出，写回寄存器。
记账信息 操作系统统计每一个进程在CPU上占用的时间和执行的指令数目，据此来判断下一阶段的调度。
那么，以上就是本文的全部内容了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/558079b5903a4dd41ccd43b5e3f7d44e/" rel="bookmark">
			Dice loss和交叉熵损失在二分类语义分割中的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dice loss
引用：Dice Loss 最先是在VNet 这篇文章中被提出，后来被广泛的应用在了医学影像分割之中。
语义分割，X表示gt分割图，Y表示pred分割图
优点：对正负样本不平衡问题有很好效果，但会使模型训练的loss不稳定（尤其是当正样本为小目标时）
交叉熵
矩阵计算形式
上述操作等价于
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fcaec9ee1626d19665dd9e15075e75d/" rel="bookmark">
			【Java 设计模式】创建者模式 之原型模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原型模式 §1 定义§2 角色§3 三好学生案例§3.1 浅克隆实现§3.1.1 浅克隆定义§3.1.2 类图§3.1.3 实现 §3.2 深克隆实现§3.2.1 深克隆定义§3.2.2 实现 §1 定义 将一个已经创建好的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。 §2 角色 抽象原型类：定义具体原型类需要实现的 clone 方法，对于 Java 来说，具体原型类直接实现 Cloneable 接口重写 clone 方法即可，无需再重新定义抽象原型类。具体原型类：实现抽象原型类的 clone 方法。访问类：使用具体原型类中的 clone 方法复制新对象。 §3 三好学生案例 班级里有多名同学获得了三好学生的奖状，除了奖状上的获奖人姓名不一样外，其他都是一样的，使用原型模式复制出多个三好学生奖状，然后修改奖状上的名字。 §3.1 浅克隆实现 §3.1.1 浅克隆定义 创建一个新的对象，新对象的属性和原型对象的完全相同，对于非基本类型的属性，仍然指向原型对象所指向的对象的内存地址。 §3.1.2 类图 §3.1.3 实现 // 具体原型类: 奖状 public class Citation implements Cloneable { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public void show() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fcaec9ee1626d19665dd9e15075e75d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e733a23bc78a94f6e3621e41cd41b4/" rel="bookmark">
			答案解析（C语言版本）——第五届“传智杯”全国大学生计算机大赛（初赛）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
A-莲子的软件工程学
输入输出样例 输入 #1
输出 #1 输入 #2
输出 #2
输入 #3
输出 #3
代码解析如下
B-莲子的机械动力学
输入输出样例 输入 #1
输出 #1 输入 #2
输出 #2
代码解析如下
D-莲子的物理热力学
​编辑输入输出样例 输入 #1
输出 #1 输入 #2
输出 #2
输入 #3
输出 #3
代码解析如下
E-梅莉的市场经济学
输入输出样例 输入 #1
输出 #1 代码解析如下
A-莲子的软件工程学 输入输出样例 输入 #1 -1 2 输出 #1 1 输入 #2 0 -4 输出 #2 0 输入 #3 -12345 -54321 输出 #3 -12345 代码解析如下 #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e733a23bc78a94f6e3621e41cd41b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99c0bb418e35bb7b80c0e3c59557796e/" rel="bookmark">
			GAMES101 梳理 / 个人向图形学笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Games101 前言 对闫令琪老师在GAMES101课程讲的东西进行梳理，主要是为了把所有知识点过一遍，说明白why、how、what的问题，不涉及具体的线性代数、计算机、物理、信号处理、数值处理等具体知识。加了一些其他地方看来的资料。
本人菜鸟，如果哪里不对，欢迎指正！
Lecture2 线性代数 Lecture3-4 坐标变换 1、二维的坐标变化 2、三维的坐标变化 model：把模型从本地坐标转换成世界坐标。
view：把世界坐标转换成观察坐标。先把相机放到某一位置，在保持相机的方向，把相机移动到原点。
projection：包括正交投影和透视投影。正交投影：无视z坐标，移动到原点；透视投影：把平截头体压缩成立方体，再进行正交投影。经过这一步得到标准化坐标。
*在一般的图形学渲染管线里，mvp都是发生在几何阶段的，具体过程是，先进行mv矩阵变换，然后对顶点进行着色（包括法向量、纹理坐标、颜色等），之后投影矩阵变换，得到一个标准化立方体（正交投影得到标准立方体好理解，但其实透视投影得到的也是标准立方体，经过压缩之后的），之后经过视锥剔除这一步操作，避免不必要的时间消耗，此时得到的还是标准化立方体，顶点的坐标还是三维的，然后经过视口变换，得到对应屏幕大小的二维图像，此时的顶点包括所有需要的信息（包括法向量、纹理坐标、颜色等）。然后进入光栅化阶段，先进行三角形处理，对顶点与顶点之间做插值，然后做光栅化，对应到像素，然后做shadding（包括纹理映射），对像素着色，之后做可视化处理、alpha测试、模板测试等，上屏到显示设备。
*矩阵相乘的顺序是从右往左，矩阵变换的顺序应该是——缩放、旋转、平移。
为什么引入齐次坐标？ 区分向量和点，更易于表示仿射变换
*仿射变换就是线性的几何变换加上一个平移，包括旋转、缩放、平移、切变。
Lecture5-6 Rasterization 光栅化 1、光栅化设备介绍 为什么模型用三角形？ 最基本的几何平面；保证是平面；容易进行插值操作（重心坐标）
2、怎么判断三角形和像素的关系？ 实际上就是用像素对图像进行采样，会出现锯齿（aliasing）。
解决方法：出现锯齿，进行反走样（antialiasing），先进行模糊操作再进行采样。
为什么模糊操作可以反走样？采样就相当于在时域用冲激函数对原函数做乘积，而采样频率越低，冲激函数频率越低，在频域的表现，冲激函数频率越高。而频域的原函数对冲激函数进行卷积操作，相当于对原函数图像的重复，冲激函数频率越高，越容易出现混叠。模糊操作消去了高频信号，高频信号便不容易混叠。
*傅里叶变换，时域与频域，高频与低频，卷积算子。 *时域的卷积相当于频域的乘积，时域的乘积相当于频域的卷积。
真正的反走样不好算。可能是因为进行滤波之后不好判断三角形和像素的关系？ 现实点的解决方法：
1、提高分辨率，就不关图形学的事儿了；
2、MSAA（multisampling AA)/超采样，把一个像素变成多个像素进行采样，得到的值求平均，还是用一个像素来表现，近似了模糊的操作，并没有提高分辨率，缺点是效率问题（问了老师，老师把antialising叫做反混淆，实际指的可能就是MSAA？）；
3、FXAA（fast approximate AA），图像处理层面，对生成的锯齿图去锯齿；
4、TAA（temporal AA），把MSAA对样本的处理分布在时间上。
5、超分辨率/超采样/DLSS（deap learning super sampling）
*这一块的前提好像就是模型的复杂度/图像的分辨率足够，采样点不足。如果采样点足够多，就不会出现锯齿现象！
Lecture7-9 shading shading：给物体施加材质的过程。包括光照和texture。
可见性，Z-buffering Blinn-Phong反射模型 specular高光：与观察方向有关
diffuse漫反射：与观察方向无关，光线打过来，均匀地反射到四面八方。
ambient环境光：可以设置为常数
这里的光线考虑衰减，I/r^2，实际衰减的是irradiance（单位面积的光的power）
shading frequency 对面shading（flat）
对vertex做shading（gouraud）
对像素做shading（phong shading）
图形渲染管线 三维空间顶点经过mvp矩阵变换，变成屏幕空间的顶点。
屏幕空间的顶点，经过三角形处理，组成三角形。
三角形经过光栅化，变成fragment。
fragment经过shading，计算光照、纹理映射（比如采用布林冯模型、微表面模型，就在此处进行相应的计算），变成fragment。
带材质的fragment经过framebuffer（比如深度处理），变成屏幕上的图像。
*具体过程是，先进行mv矩阵变换，然后对顶点进行着色（包括法向量、纹理坐标、颜色等），之后投影矩阵变换，得到一个标准化立方体（正交投影得到标准立方体好理解，但其实透视投影得到的也是标准立方体，经过压缩之后的），之后经过视锥剔除这一步操作，避免不必要的时间消耗，此时得到的还是标准化立方体，顶点的坐标还是三维的，然后经过视口变换，得到对应屏幕大小的二维图像，此时的顶点包括所有需要的信息（包括法向量、纹理坐标、颜色等）。然后进入光栅化阶段，先进行三角形处理，对顶点与顶点之间做插值，然后做光栅化，对应到像素，然后做shadding（包括纹理映射），对像素着色，之后做可视化处理、alpha测试、模板测试等，上屏到显示设备。
材质映射 *重心坐标，用来做插值 texture magnification 如果纹理太小怎么办？纹理上一个texel被图像上多个pixel包含，texel不够用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99c0bb418e35bb7b80c0e3c59557796e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e87f688c8356d1355af9372c680e18/" rel="bookmark">
			SQL中常用的聚合函数，知道这些就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在实际表的查询中，有时候不是简单的查些数据，而是需要对数据进行一些汇总，此时就要用到聚合函数。经常用到的聚合函数只有五种，只要掌握了就能够应对很多场景的需求。
1.count（）函数。
count（）函数统计数据表中所包含的总行数，或者根据分组条件返回每个分组中的总的行数。其使用方法主要有两种。
# count(*)返回的是总行数，不管是否有空值 select count(*) from books; # count(字段)返回的指定列不为空的行数 select count(word) from books; # 以上两种写法虽然没有很大区别但是用了count的不同用法所以导致返回的数目可能有所不同，因为选定的字段可能含有空值。 2.sum（）函数。
sum（）是一个求和函数，返回的指定列的总和。sum可以和group by搭配使用，返回的是每个分组的总和。需要注意的是sum函数在计算时会列值为null的行。
# 算出不同种类的书的价格 select name,sum(price) from books group by name; 3.avg（）函数。
avg（）函数是计算返回的是所有行数数据的平均值。可以和where或者和group by搭配使用。
# 求出科幻类书籍的价格的平均值 select avg(price) from books where name = '科幻'; 4.max（）函数
max（）函数返回的是指定列的值最大的一个数据。也可以和group by搭配使用。
# 查询出每个不同类别中价格最高的书 select name,max(price) from books group by name; 5.min（）函数。
min（）函数和max正好相反，返回的是最小值的数据。
# 查询出每个不同类别中价格最低的书 select name,min(price) from books group by name; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27adfaaedb20deab8c7b3ab3b7839af5/" rel="bookmark">
			pwm死区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		- 整流： 交流变直流， 用电桥， 交流+不动， 负部分反向， 不能同时 +电流 和 - 电流 同时流通 整流 2路不能同时导通！！！！！！
逆变器
如下图，2路pwm,电平反的，为什么，如果2路pwm都是高，短路在逆变器中，理论上可以做到，一路拉高的时候另外一路拉低，实际不行，这个时候需要死区，如下图
存在不可能一路拉高，一个拉低，立刻变化， 下图TOUT0_DZ 拉低，n拉高，拉高等一下，等第一路 TOUT0_DZ 拉低给一段时间，在拉高， TOUT0_DZ 那么已经拉高了，后面也是 ，
TOUT0_DZ 要拉高，等一下，等下面这个拉低才
如何理解死区： 就是这个时间内我变化了，可能另外一个路没有变过来，短路，死亡，那么这个时间点我等一下，保证另外一路电路已经电平变化完成
例子理解： A和B不可能同时为高， A 为高， B为低， B要拉高，A没有来的及拉低，短路，
B拉高等一下， A拉低首先，给一点时间， 保证A拉低了，B在拉高OK pwm中的死区，开启，保证2路生产出来的pwm不存在短路，用户不用操心死区问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097a85bd2a1fcb58641776a2d0f8041d/" rel="bookmark">
			PHPer 开始使用 Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出于工作需要，新项目要开始使用 Java 进行开发，注意力就要从 PHP 转移到 Java 上来。个人觉得这是一个挺好的机会，能接触被广泛使用的另一种开发语言和生态。
虽说语言之间存在许多相似之处，但真正落地的过程肯定会存在不少的曲折，希望站在小白的角度，用一系列文章记录这个过程。
Java 版本用哪个 关于 Java 版本，虽然此时最新的版本已经来到了 Java 19，LTS 版本也到了 Java 17，但还是保守的选择了 Java8 版本，主要是考虑：
遇到问题更方便检索高版本的新特性目前不是亟需官方支持到 2030 年 官网 JDK8 下载地址
解决命令行输出中文乱码 日常使用的 Win10 系统，装好 JDK 后，Terminal 中执行 Java 发现有中文乱码现象：
进一步查看 powershell 窗口属性，以及系统区域：
可以看到，Powershell 使用了 UTF-8 编码显示，但系统使用的时中文（GBK，cmd 中使用 GBK 输出不乱码）。Java 默认使用系统编码输出，这就产生了编码不一致，因此出现乱码。两个解决办法：
修改系统编码为 UTF8（即勾选系统区域中 Beta 版） 该方法会影响整个系统，对于某些使用中文的应用程序可能存在问题 指定 Java 编码 仅影响 Java 临时指定编码：
java "-Dfile.encoding=UTF-8"	还可以可通过 JAVA_TOOL_OPTIONS 环境变量指定：
JAVA_TOOL_OPTIONS="-Dfile.encoding=UTF-8" 使用该环境变量，相当于在每次 JVM 执行，都传了参数过去。执行命令时也会打印到控制台：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a7605665933683ad651df1b5f0bb79/" rel="bookmark">
			减小方差之对偶变量法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72ba960aac2129faebe56a06f760bd5/" rel="bookmark">
			ADC测试杂谈二：matlab操作串口向FPGA发信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 何以解忧，唯有串口。
相关文章：
ADC测试杂谈一：配置基于matlab+quartus的测试环境
之前提到，FPGA的JTAG相比MCU的UART，读取数据的速度更快。但是matlab似乎只能通过JTAG收信，而不能通过JTAG向FPGA发信。为了便于通过FPGA向芯片写一些配置信息，我们采用UART串口来向FPGA发送信息。
一、串口的Verilog简易实现 UART协议的基本原理是接收端通过一个16倍速的高频时钟对发送端的数据进行过采样，当检测到一个起始码后，就开始接收8位数据。Verilog代码如下：
//Author: Jiao //Date: 2017 //clk is 50e6 clk50. module newart( input dat, input clk, output ex0, output reg [7:0]bufout); reg ck; reg [7:0]buftmp; reg [7:0]count; reg enout; reg enout2; reg enout3; wire ck1; wire rst0; reg rst1; reg [8:0]count1;//325 freq divide; reg [7:0]count2;//180 times,make the ck high; wire dat0; assign rst0=enout2; always@(posedge clk) begin count1&lt;=count1+1; count2&lt;=count2+1; if(count1==0)begin ck&lt;=0; count2&lt;=0; end else begin if(count1==324) count1&lt;=0; if(count2==180) begin ck&lt;=1;count2&lt;=0;end end end always@(negedge rst0 or negedge dat0)//it seems that it is a edge detect,however it is a level driven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f72ba960aac2129faebe56a06f760bd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90c5828fb12785d9fe654d63e97be45/" rel="bookmark">
			使用nginx搭建一个RTMP流服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 前言 RTMP（Real Time Messaging Protocol）称为实时消息传送协议，它是 Adobe 公司为 Flash 播放器和服务器之间传输音视频开发的私有协议。RTMP 属于应用层协议，传输层需要靠 TCP 来保证消息的可靠性，更多 RTMP 相关的内容可以参考雷博士的这篇博客。
nginx 不仅可以搭建一个高性能 Web 服务器，还有很多扩展模块，例如 nginx-rtmp-module，默认情况下安装 nginx 是不包含该模块的，需要先将 nginx-rtmp-module 下载到本地，然后在安装 nginx 的时候指定 ./configure --add-module=nginx-rtmp-module的路径，如果你对安装 nginx 不熟悉，建议参考这篇博客。
二. 搭建RTMP流服务器 安装好加入 nginx-rtmp-module 的 nginx 后，我们需要修改 nginx.conf 文件加入与 RTMP 相关的配置，该配置文件默认在安装路径下的 conf 文件夹里。
rtmp { server { listen 1935; chunk_size 4096; application live { live on; record off; allow play all; play /opt/vod; } } #server { # listen 1936; # chunk_size 4096; # application vod { # # } #} } nginx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f90c5828fb12785d9fe654d63e97be45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52506ec95b2d2eee912e9572c075106c/" rel="bookmark">
			STM32F103c8t6的外部触发（ETR）引脚
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们单说定时器→时钟源选择-&gt;外部触发模式（ERT)的触发引脚。
根据STM32F103c8t6的引脚定义表：TIM1有ETR引脚PA12，TIM2有ETR引脚PA0，但是TIM3和TIM4的ETR引脚呢？
要知道STM32F103c8t6有四个定时器，分别为：
TIM1 高级定时器
TIM2 通用定时器
TIM3 通用定时器
TIM4 通用定时器
为何单单就TIM2有ETR引脚？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fec7fa76a1e6ae220777a57ffbc9241/" rel="bookmark">
			18、在微信小程序中引入 vant UI组件库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在 小程序的根目录下，引入vant
npm i @vant/weapp -S --production
2、删除 app.json 文件中的 "style":"v2"
3、在 project.config.json 文件的 setting 中添加：
"packNpmManually": true, "packNpmRelationList": [ { "packageJsonPath": "./package.json", "miniprogramNpmDistDir": "./" } ], 4、构建 npm 包，侧边栏目录中会新增一个文件夹 miniprogram_npm 存放的是vant 组件
5、在需要的页面中引入 vant 组件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c638014ea08a354f7ea75e1d64a3586/" rel="bookmark">
			在CentOS 7.7 x86_64上为python 2.7.5安装pip的靠谱方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的虚拟机是CentOS 7.7 x86_64系统，对应的python默认版本是2.7.5，但是没有安装pip，不方便安装第三方模块。
我想为为它安装pip工具，发现现有的安装方法都行不通了，比如先安装easy_install，再通过easy_install安装pip的方法
echo '=======install setuptools ============'
wget --no-check-certificate https://bootstrap.pypa.io/ez_setup.py
python ez_setup.py
echo '=======install pip =========='
easy_install-2.7 pip
pip -V
它会报下面的错误
下面是正常的安装方法
wget https://bootstrap.pypa.io/pip/2.7/get-pip.py
sudo python get-pip.py
pip -V
如果直接使用官方镜像源，通常会报“网络不可达等错误，pip Failed to establish a new connection: [Errno 101] 网络不可达”
更改官方源镜像
pip --default-timeout=100 install numpy -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
pip --default-timeout=100 install pillow -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com
pip国内源
阿里云镜像：https://mirrors.aliyun.com/pypi/simple/
清华大学镜像：https://pypi.tuna.tsinghua.edu.cn/simple/
腾讯镜像：https://mirrors.cloud.tencent.com/pypi/simple
豆瓣镜像：https://pypi.doubanio.com/simple/
中科大镜像：https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/
全局设置方法
pip config set global.index-url https://mirrors.aliyun.com/pypi/simple
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c638014ea08a354f7ea75e1d64a3586/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4be94b8c7d7c1714a402180f1c8df29f/" rel="bookmark">
			vue发送post请求到SpringBoot后端，但后端接收不了参数的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.解决方法：要处理一下请求参数，按下面的写法处理参数就行。
// 监听switch开关状态的改变 stateChange(warehouserInfo) { var params = new URLSearchParams(); params.append('id', warehouserInfo.id); params.append('whStatus', warehouserInfo.whStatus) this.$http .post('/warehouse/updateStatus', params) .then((res) =&gt; { if (res.data.code == 200) { this.$message.success('更新数据状态成功'); } else { warehouserInfo.whStatus = !warehouserInfo.whStatus; this.$message.error('更新数据状态失败!'); } }) .catch(function (error) { console.log(error); }); }, 2.后端
@PostMapping("/updateStatus") public CommonResult updateStatus(Integer id, Integer whStatus){ Boolean result = warehouseService.updateStatus(id,whStatus); if (result){ return CommonResult.success(result); }else { return CommonResult.failed(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8fd3571acba24951fd4e6a6fb005179/" rel="bookmark">
			NeRF&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 NERF++：分析和改进神经辐射场，这篇论文主要对了NeRF进行了解读，以及介绍了关于背景重建的方法
首先讨论了辐射场及其潜在的模糊性，即形状辐射模糊性，并分析了NeRF在避免此类模糊性方面的成功。其次，解决了将NeRF应用于360° 的参数化问题捕捉大规模、无界3D场景中的对象。
1、形状-亮度模糊（SHAPE-RADIANCE AMBIGUITY） 对于在一个场景数据下训练好的Nerf表示，其空间的几何表示可能是错误的，但仍然可以在训练样本上渲染出正确的结果，简单来说，由于损失函数只是要求预测颜色与原图接近就行，所以即使训练体积密度σ 是错误的，也能在训练集得到较为的结果
通常情况下，对于任意的、不正确的形状，可以表明存在一系列辐射场，可以完美地解释训练图像，但不能很好地推广到新的测试视图。也就是说在测试数据上的表面图像不能做到像训练集的结果一样。而NeRF中避免了这样的情况。论文中提出以下两点作为解释：
1、不正确的几何结构迫使辐射场具有更高的固有复杂性（即，高得多的频率），NeRF中对位置和观看方向进行了10维以及4维的编码，并且这种编码不是一起输入网络的，观看方向的编码相对维度底，只与颜色有关，体密度只和位置编码有关，这样能适应高频的信号，表面光场通常会更平滑。
作者测试过如果位置和观看方向都是L=10的维度编码，得到的表面要比论文中的方式模糊。
2、NeRF的特定MLP结构隐含地编码了表面反射率之前的平滑BRDF。BRDF:双向反射分布函数,定义光线在不透明表面反射的四次元函数,用来定义给定入射方向上的辐射照度如何影响给定出射方向上的辐射率。
总结来说，网络的设计，让位置的维度更高，权重更大，约束网络不会将形状输出的真实偏差较大，并且观看方向较低维能保证不影响体密度，只进行颜色的计算。
2、逆球面参数化方程（INVERTED SPHERE PARAMETRIZATION） 远景存在的问题：Nerf在建模室外场景时，对于远景，如果不对其进行建模，则会造成背景误差，如果对其建模，由于尺度问题会造成前景的分辨率下降，这似乎成了一个二选一的问题，下图a是远景模糊，b是前景分辨率下降
论文中通过简化自由视图合成的反向球体参数化来解决这一限制。
首先将场景空间划分为两个体积，一个内部单位球体和一个外部体积，该外部体积由覆盖内部体积的互补部分的倒置球体表示。内部体积包含前景和所有摄影机，而外部体积包含环境的其余部分。
分为两部分通过两个NeRF进行渲染
外部的远景NeRF，应用了一个反向球体参数化，首先，通过令∣ o + ta d ∣=1就可以求得点 a 的坐标，同理点 b = o + tb d 可以通过d T ( o + t b d ) = 0求得，经过几何求解 w = arcsin|b| - arcsin（|b| / r），然后再对a反向进行渲染即可得到p的方向x’,y’,z’。
下图是一些坐标表示
这部分推导可以看这篇文章
光线追踪积分分为两部分，前半部为单位圆内积分，后半部分为单位圆外积分。公式也需要分成两部分
NeRF网络分为前景与背景网络，分别进行训练，训练输出不透明度与颜色值，根据离散化的公式计算相应的RGB和深度权重，计算预测RGB值与真实值欧式距离，再转换为psnr值，进行梯度回传，训练网络。
学习链接
https://blog.csdn.net/weixin_44292547/article/details/126355820 https://blog.csdn.net/weixin_50973728/article/details/126133816 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25adc4f268e68537e438e5df769bff7c/" rel="bookmark">
			在CentOS 7.7 x86_64上安装python3.11.0实录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整个安装过程基本上参照原来的博文
https://blog.csdn.net/tao_627/article/details/105674448
但是这里有新的注意点就是，ssl使用了新的openssl11库，与原来的安装方法有较大差异，特此将我的采坑记录于此，以作备忘！大家只需要按照我的记录顺序执行，就能顺利安装完成。
1.安装依赖包
yum groupinstall "Development Tools"
yum -y install zlib-devel bzip2-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel uuid-devel
yum install -y openssl-devel openssl11 openssl11-devel
yum -y install libffi-devel
yum -y install zlib*
这里需要强调几点：
a.如果一开始安装Development Tools就出错，请改为执行下面的命令
yum groups mark install "Development Tools"
yum groups mark convert "Development Tools"
yum groupinstall "Development Tools"
详见我的博文
https://blog.csdn.net/tao_627/article/details/128045133
b.如果你只是安装普通的openssl库，将会看到下面的错误：
To find the necessary bits, look in setup.py in detect_modules() for the module's name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25adc4f268e68537e438e5df769bff7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8269ef140f5f1b6c9e851cbee1477e2e/" rel="bookmark">
			17、微信小程序——城市定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、https://lbs.qq.com/miniProgram/jsSdk/jsSdkGuide/jsSdkOverview 2、 申请开发者密钥（key）：申请密钥 3、 开通webserviceAPI服务：
腾讯位置服务——控制台 -&gt;应用管理 -&gt; 我的应用 -&gt;添加key-&gt; 勾选WebServiceAPI -&gt; 保存
4、下载微信小程序JavaScriptSDK，微信小程序 JavaScriptSDK v1.2
5、安全域名设置，
在小程序管理后台 -&gt; 开发 -&gt; 开发管理 -&gt; 开发设置 -&gt; “服务器域名” 中设置request合法域名，添加 https://apis.map.qq.com
6、 在 地图所在页面的 index.js 中设置
// 引入SDK核心类，js文件根据自己业务，位置可自行放置 var QQMapWX = require('../../libs/qqmap-wx-jssdk.js'); var qqmapsdk; Page({ onLoad: function () { // 实例化API核心类 qqmapsdk = new QQMapWX({ key: '申请的key' }); }, }) 7、获取当前定位的城市信息 wx.getLocation()
&lt;button bindtap="getLoaction"&gt;定位&lt;/button&gt; &lt;view&gt; {{city}} &lt;/view&gt; 如果有报错，重启编辑器
data: { city:"" }, getLoaction() { var that=this wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8269ef140f5f1b6c9e851cbee1477e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7bc728dc4af458b9a886d95c090d04a/" rel="bookmark">
			诊断数据库ODX—数据库框架（基于ISO22901详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、ODX数据库自身架构是什么？二、ODX数据库架构具体组成部分和含义总结 前言 车载诊断现阶段应用的诊断数据库大体分为三种：
CDD（Vector私有格式）；
ODX全球通用诊断数据库格式；
DEXT（基于AUTOSAR友好交互的诊断数据库.ARXML格式）。
CDD与ODX本身文件载体是XML，类似根目录形式，工程师日常在用文本打开（e.g. Notepad++），通过搜索也是可以找到对应的诊断描述内容，只是可读性特别差而已。
因此本文基于ISO22901（自身在外企做过此协议收费培训讲师），详细分析下ODX数据库的具体格式框架，辅助认识该数据库。
一、ODX数据库自身架构是什么？
在UML建模后，对诊断的层级结构进行形象描述。当MCD-3D Server对于诊断数据库ODX的调用逻辑取决于ODX数据库架构。
本文基于ISO 22901协议中对ODX架构进行分享。
在ODX层级结构中，内容（值）继承是诊断层之间关系的核心。如下图：
通过上图，清晰说明了继承的层架结构和方向。关于ODX内部层级：
PROTOCOL
FUNCTIONAL-GROUP
BASE-VARIANT
ECU-VARIANT
ECU-SHARED-DATA
每一个层级只能继承一组 特定的其他类型诊断层，一个诊断层不能继承同一个类型的诊断层。在图中，层级较高的诊断层属性更“General”，层级较低的诊断层属性更“Special”：
注：只有如下类的对象可以进行值传递（继承）：
⎯ DIAG-COMM (its specializations),
⎯ DIAG-VARIABLE,
⎯ GLOBAL-NEG-RESPONSE,
⎯ DOP-BASE (its specializations),
⎯ TABLE,
⎯ FUNCT-CLASS,
⎯ VARIABLE-GROUP,
⎯ ADDITIONAL-AUDIENCE,
⎯ STATE-CHART,
⎯ UNIT-GROUP;
注：
1、只有具有HANDLE属性的类的对象才能进行值传递，具有HANDLE属性对象聚合了其他也具有HANDLE属性的对象，则完整的聚合将被继承，即始终是聚合最外层对象（具有HANDLE属性）是值传递的主题。
2、值继承是为DIAG-LAYER的不同实例之间的对象定义的，因此只有在DIAG-LAYER中定义的类才可以继承。这些类的对象在选定的DIAG-LAYER的D-server API上可查询，查询结果将是该层可见的对象列表。
3、同一类的所有对象在每一个DIAG-LAYER中都应该有一个唯一的SHORT-NAME，即使这些对象不是在这个DIAG-LAYER中定义而是继承的。并且对于SHORT-NAME，当从更“General”层继承的对象可以被更“Special”层所覆盖，从而保证每一个Class的SHORT-NAME的唯一性。对于整个ODX数据库，只有覆盖对象可见（Tester可以通过SHORT-NAME进行诊断内容识别并调用）。
BASE-VARIANT对象通过聚合PROTOCOL-REF对象来创建到PROTOCOL对象的值继承关系。该对象又通过使用《odxlink》引用PROTOCOL对象。
继承层次详情可参考下图：
BASE-VARIANT 对象通过聚合 PROTOCOL-REF 对象来建立到 PROTOCOL 对象的值继承关系，该对象又通过使用 &lt;&lt;odxlink&gt;&gt; 引用 PROTOCOL 对象。
一对 DIAG-LAYER 对象之间可能存在本节中描述的值继承关系。 禁止同一对对象同时存在两种关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7bc728dc4af458b9a886d95c090d04a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f520bc37ca3c72092dfbfadff1c395c1/" rel="bookmark">
			idea导入项目时无法识别出maven项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用idea导入maven项目的时候，有时会出现无法识别maven项目的情况。尤其是在多路径下的maven项目。
1.如图：空空如也，找不到maven项目
2.解决办法：回到上一步，点击勾选Search for projects recursively，大意是递归搜索项目，可以理解为在全部路径逐级搜索.maven文件（个人理解哈）
3.勾选之后，点击下一步就可以看到识别出maven项目了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50287c13f676724482079c72b1a9d4b9/" rel="bookmark">
			陀螺仪与加速度计的姿态融合——互补滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章我们来讲讲如何将陀螺仪和加速度计的数据结合起来，获取更准确的姿态数据，使用的是互补滤波的方法。
阅读本文需有一定的知识基础，可以参见作者以前MPU6050的两篇文章：《MPU6050陀螺仪和加速度计数据的获取和校准》、《MPU6050官方DMP的移植和使用》，以及了解四元数的一些基本概念。
1）为什么要进行姿态融合 在之前的文章里，我们讲过一些陀螺仪和加速度计的知识，我们知道，陀螺仪可以获取载体的角速度，由角速度积分，就能得到角度，也就得到了载体的姿态。但是，陀螺仪给出的角速度存在测量误差、噪声和漂移，经过积分运算之后，会形成累积误差，这个误差会随着时间延长越来越大，最终导致偏差太大而无法使用。
另一方面，加速度计可以测量到地球的重力，当载体静止或者匀速运动时，重力的方向就是竖直向下的，通过测量重力加速度的方向，可以获取当前载体的俯仰角、滚转角。但是加速度计容易受到高频噪声的干扰，动态响应慢，只在长时间内数据比较有效。
因此，一般我们使用加速度计的数据来修正陀螺仪，以加速度计获取的实时姿态角来修正陀螺仪的累积误差，就能在短时间和长时间内都能获取比较满意的姿态信息。
我们以下图为例，Z轴向上，约定绕X轴旋转的角度为滚转角；绕Y轴旋转的角度为俯仰角，绕Z轴旋转的角度为偏航角。
那么，滚转角（绕X轴转）和俯仰角（绕Y轴转）发生变化时，MPU6050测出来的重力加速度g的方向相对于载体也会发生变化。而加速度计测出来的重力加速度g的方向是实时的，不会受长时间计算累加的影响。所以，我们可以用加速度计测到的g的方向，来修正陀螺仪积分得到的滚转角和俯仰角。
而偏航角（绕Z轴转）变化时，MPU6050测到的重力加速度g方向是不会变化的，所以g的方向不能用来修正偏航角。要想修正偏航角，需要测量地磁偏角的传感器信息。
这个用加速度计或磁力计来修正姿态角的过程，一般称为数据融合，有多种方法实现。在之前的文章中，我们使用MPU6050芯片官方提供的DMP库直接获取了融合后的数据；但是这只适用于特定厂家的芯片，而更通用的方法是使用互补滤波或者卡尔曼滤波来实现，本节要讲的就是使用互补滤波的方法，来进行数据融合。
(注意，由于没有引入磁力计的数据，本文使用互补滤波的方法只是修正了俯仰角和滚转角的信息，无法修正偏航角，后续有机会再讲解如何用磁力计修正偏航角)
2)互补滤波的原理 假如我们有两种途径测量某个信号，测得的结果一个带有高频噪声，一个带有低频噪声。我们为了获取更准确的信号，可以把它们的噪声分别滤掉，再合并，就得到了没有噪声的原始信号。具体操作如下图所示：
这就是互补滤波最基础的理论。
为了使得最后相加的重构信号与我们想要的信号尽量相等，一般要求F1(s)+F2(s) = 1。
具体到我们的实际问题，姿态信息可以通过陀螺仪角速度积分得到，也可以通过加速度计实时测量得到；而且，陀螺仪积分得到的姿态主要包含低频噪声（零偏、累积误差），加速度计得到的姿态主要包含高频噪声。使用互补滤波正好可以融合二者的姿态信息。
依据上面这个框图，我们可以想到以下的姿态融合方法：
图中ω是角速度，n1和n2为噪声，θ’为融合后的角度。
当我们把滤波器简化为最简单的一个比例系数时，有如下形式：
姿态角 = k*陀螺仪姿态角 + (1-k)*加速度计姿态角
(其中0&lt;k&lt;1，k的选择，取决于我们更相信陀螺仪的数据，还是更相信加速度计的数据)
你可能会很惊讶，这不就是个加权平均吗？就这也能滤波？
别急，它确实没有滤波，但我们先理解一下，再慢慢深入。
我们看看等式右边的两项，由于k小于1，所以陀螺仪姿态角的低频噪声被缩小了k倍；同样，1-k也小于1，所以加速度计姿态角的高频噪声被缩小了1-k倍；二者相加，姿态角的倍数仍为1，而高频和低频的噪声都被缩小了。虽然这个“滤波”效果有点弱，但是这样我们至少得到了一个高频、低频都比原始信号稍好一些的姿态信息，这就实现了高频和低频信号的互补。
实际上，当使用了有效的高通和低通滤波器时，噪声的影响会被进一步减弱。
前人的研究已经帮我们总结出了通用的公式，就是低通滤波器为LPF=C(s)/(C(s)+s)，高通滤波器HPF=s/(C(s)+s)。选用不同的C(s)可以形成不同滤波效果。
把算法化成框图的形式，如下图所示：
上面这个框图对于理解互补滤波的原理比较直观，但是等效为下图这种形式时，更接近于编程实现的思想：（有兴趣的可以推导一下，两种框图是等效的）
当选择不同的C(s)时，可以获得不同的滤波效果，C(s)为常数时，就是一阶滤波器；C(s)为a+b/s时就是二阶滤波器。
3）互补滤波用于姿态融合的编程实现 当求解姿态角时，必须要有一些四元数的知识，可以认为四元数等价于滚转角、俯仰角、偏航角。之所以要使用四元数，是因为它可以简化姿态更新的计算过程。基本上现在网上的开源代码都是以四元数来表征姿态角的。本文不去深究四元数的理论，只是拿来使用。
我们来看一下最经典互补滤波算法是如何实现的，这段代码被广泛应用在开源四轴飞行器上，它的核心部分如下：
ax、ay、az是加速度计测得的三个方向的加速度，gx、gy、gz是陀螺仪测得的三个方向的角速度。
首先，将ax、ay、az进行单位化，因为我们只需要使用它们求角度，不关心它们的大小，单位化的操作就是第65~68行，其中sqrt函数是求平方根：
norm = sqrt(ax*ax + ay*ay + az*az);
ax = ax / norm;
ay = ay / norm;
az = az / norm;
然后，第72~74行，是依据当前的姿态来计算重力加速度；静止或匀速直线运动时，重力产生的加速度在地面东北天坐标系的xyz三个方向上分量是[0,0,g]，再乘以姿态转换矩阵，就得到了机体坐标系下的加速度：
用四元数表示的姿态转移矩阵是：
所以，转换矩阵的最后一列，就是在载体坐标系下的加速度（忽略了倍数g）：
vx = 2*(q1q3 - q0q2);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50287c13f676724482079c72b1a9d4b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47544d1c7d9c65e3afe20a35b00817ca/" rel="bookmark">
			【Java 设计模式】创建者模式 之抽象工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽象工厂模式 §1 概念§2 角色§3 甜品店案例§3.1 类图§3.2 实现 §4 优缺点 §1 概念 产品族：华为既有华为手机，也有华为电脑、华为平板，华为手机、华为电脑和华为平板属于一个产品族，因为他们都是华为品牌。产品等级：有华为手机，也有苹果手机、小米手机，他们属于一个产品等级，因为他们都是手机，属于手机等级。抽象工厂模式和工厂方法模式的区别在于，工厂方法模式中的工厂创建的具体产品属于同一个产品等级，如：咖啡工厂可以制作美式咖啡、拿铁咖啡，但是不能制作甜点；而抽象工厂模式中的工厂创建的具体产品属于同一个产品族，如华为工厂只生产华为手机、华为电脑、华为平板等，不能生产苹果手机、苹果电脑等。 §2 角色 抽象产品：定义产品的规范，描述产品的特性和功能，抽象工厂模式可能存在多个抽象产品，如：咖啡、甜点等。具体产品：实现或继承抽象产品的子类，如：咖啡有美式咖啡、拿铁咖啡，甜点有提拉米苏、抹茶慕斯。抽象工厂：提供创建产品的接口，可以创建不同产品等级的产品，如：甜品工厂既可以制作咖啡，也可以制作甜点。具体工厂：实现抽象工厂接口，完成对某一个产品族产品的生产，如：美式风味甜品工厂制作美式咖啡和抹茶慕斯，意大利风味甜品工厂制作拿铁咖啡和提拉米苏。 §3 甜品店案例 某个甜品店，既可以出售咖啡，也可以出售甜点。 §3.1 类图 §3.2 实现 // 抽象产品: 咖啡 public abstract class Coffee { public abstract String getName(); public void getMilk() { System.out.println("加牛奶"); } public void addSugar() { System.out.println("加糖"); } } // 抽象产品: 甜点 public abstract class Dessert { public abstract void show(); } // 具体产品: 美式咖啡 public class AmericanCoffee extends Coffee { @Override public String getName() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47544d1c7d9c65e3afe20a35b00817ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482202cd0bffb51c353c5b684f3e875e/" rel="bookmark">
			通过Python Pandas分析数据上涨下跌趋势的方法：求离散数据的差分、导数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际工作中，我们经常需要分析一组数据的历史走势/趋势情况，比如要从产品数据库中筛选出销量处于上升趋势的产品，或者从股票历史数据库中筛选出一直处于上涨的股票。 那么可以通过分析计算该组数据的差分来模拟求出该组数据走势线的导数，然后通过求导的差分/导数情况判断该组数据的走势情况。从高等数学的导数知识我们知道，如果一个函数的导数大于零，那么该函数在这个区间的趋势处于上升状态，反之，在导数小于0时，函数曲线处于下降状态，而在导数等于0时，函数曲线处于上涨和下降的转折点。通过计算函数有几个零点，可以知道曲线上涨和下降的变化情况，而通过判断导数是大于零还是小于零，我们就能知道曲线是上涨还是下降。
由于产品销售数据或者股价数据都是离散值，而且无法根据这些数据推导出曲线函数，所以直接通过函数求导的方法来判断数据是上涨还是下降是行不通的。但是我们可以求数据的差分并除以步长来近似模拟计算导数。为了演示好看，下面以一组离散正弦数据来进行示例，选正弦函数是因为数据有上下波动趋势，而且正弦函数的导数为余弦函数。
说明：我使用的是Jupyter Notebook环境，方便数据显示
Python里处理数据通常使用Pandas库和Numpy库，计算离散数据的方法就可以使用numpy的方法：
#计算数组a的差分，参数a是一个数组，n是代表几阶差分默认是1，axis是代表按行还是列计算 numpy.diff(a, n=1, axis=-1, prepend=&lt;no value&gt;, append=&lt;no value&gt;) 也可以直接使用Pandas库的方法：
#Pandas库计算差分的方法,periods参数是指定几阶差分，默认是1阶，axis是代表按行还是列计算，默认是按列。按行就改为1 DataFrame.diff(periods=1, axis=0) 先导入相关的库，并设定参数：
#coding utf-8 import pandas as pd import numpy as np from matplotlib import pyplot as plt plt.rcParams['font.sans-serif']=['SimHei'] #图中文字体设置为黑体 用numpy生成一组模拟正弦离散数值：
x_len=50 #x_len表示模拟生成多少组数据，这个值越大，生成的曲线越接近真实的正弦函数，可以通过修改这个值的大小来对比模拟效果 x = np.linspace(-np.pi*2, np.pi*2, x_len) 计算数据x的步长：
#导数的公式为dy/dx,当dx接近无线小时，就是函数在x处的导数。因为我们要处理的数据是离散数值，这里仅做一个模拟计算，不要求精确度 #差分取dy=f(x2)-f(x1),即y2-y1， dx=x2-x1,模拟导数=dy/dx, #计算dx,也就是x的步长step，这里通过将数组x的最大值减去最小值再除以x数组长度的方法来计算，简单理解就是每个x坐标轴上的间隔 step=(np.max(x)-np.min(x))/len(x) 使用Pandas生成包含x和y（np.sin(x)）及y的一阶差分数据的数据表：
df=pd.DataFrame(data={'x':x,'y':np.sin(x)}) #通过numpy.sin函数计算出x对应的正弦值y，并生成一个pandas数据表 df["y的差分"]=df["y"].diff() #计算y列的差分 使用matplotlib汇总图表：
#汇总对比图 plt.figure(figsize=(20,8)) #设定图画大小 plt.plot(x,df['y'],label='正弦函数sin(x)') plt.plot(x,df.diff(periods=1)['y'],label="1阶差分dy") #绘制1阶差分曲线 plt.plot(x,df.diff(periods=1)['y']/step,label="'1阶差分模拟导数y'") #通过将1阶差分除以步长step得出模拟导数值 plt.plot(x,np.cos(x),label='cos(x)') #用余弦函数做对比 plt.title('离散数据差分和模拟导数',fontsize=16) plt.xlabel('X') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/482202cd0bffb51c353c5b684f3e875e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c61b2c5bc1d9da3985be580dd379d4a/" rel="bookmark">
			用c&#43;&#43;实现特殊约瑟夫问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述: 编号为1…N的N个小朋友玩游戏，他们按编号顺时针围成一圈，从第一个人开始按逆时针次序报数，报到第M个人出列；然后再从下个人开始按顺时针次序报数，报到第 K 个人出列；再从下一个人开始按逆时针次序报数，报到第 M 个人出列；再从下个人开始按顺时针次序报数，报到第K个人出列……以此类推不断循环，直至最后一人出列。请编写程序按顺序输出出列人的编号。
输入格式: 输入为3个正整数，分别表示 N、M、K，均不超过1000
输出格式: 输出为一行整数，为出列人的编号。每个整数后一个空格。
输入样例:
6 3 5
输出样例:
5 3 1 2 4 6
根据题目逐句分析问题要如何实现
编号为1…N的N个小朋友玩游戏，他们按编号顺时针围成一圈
这个很简单，我们创建一个数组（或者链表），用for循环逐个编号即可
要注意的是由于题目要求编号围成一圈，我们要使用圆圈数组
好吧，这具体叫什么数组我也不知道，或许叫循环数组？总之就是将数组的头部和尾部连接起来，具体要怎么实现呢？
当上溢时，我们用%符号取余实现，当下溢出时，我们讲地址加上数组的长度实现
if (ptr &gt;= lenth) return ptr % lenth;//上溢解决 else if (ptr &lt; 0) return ptr + lenth;//下溢解决 //ptr为当前操作的数组地址，lenth为数组长度 我们写出顺时针报数和逆时针报数时更新操作指针ptr的代码
int NiCircle(int ptr,int lenth) { //对指针值进行修改使得其不断逆时针循环 ptr--; if (ptr &gt;= lenth) return ptr % lenth;//上溢解决 else if (ptr &lt; 0) return ptr + lenth;//下溢解决 else return ptr; } int ShunCircle(int ptr, int lenth) { //对指针值进行修改使得其不断顺时针循环 ptr++; if (ptr &gt;= lenth) return ptr % lenth;//上溢解决 else if (ptr &lt; 0) return ptr + lenth;//下溢解决 else return ptr; } 从第一个人开始按逆时针次序报数，报到第M个人出列；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c61b2c5bc1d9da3985be580dd379d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf41d2df1555536e28fa0b5446992bfd/" rel="bookmark">
			java科学计数法转普通数字字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 BigDecimal bigDecimal = new BigDecimal(6.679587147109759E-6); String s = bigDecimal.toPlainString() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75a879ba86268d2885029cd37a3116c/" rel="bookmark">
			华为OD机考-构建输入和输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD机考-ACM模式下创建输入 概述：下文列举机考过程中常见输入的构造方法，如字符串、多维数组等，并对用到的函数进行详细讲解，最后通过真题实操巩固知识点。 一、机考中常见的输入 1. 输入字符串 # 输入一行字符串 str1 = input() print(str1) # 运行程序输入 hello ~566~ 输出：hello ~566~ 2. 输入一个或多个数字 方法1：分别输入整数a，b # 输入整数a # 输入整数b，求a+b # 方法1：先输入a,在输入b a = int(input()) b = int(input()) print(a + b) C:\Users\JUNE\AppData\Local\Continuum\anaconda3\python.exe C:/python基础语法练习/csdn.py 4 3 7 Process finished with exit code 0 方法2：使用MAP函数在一行同时输入a，b，以空格分开 #方法2：输入a b（在一行） a,b = map(int,input().split()) print(a + b) C:\Users\JUNE\AppData\Local\Continuum\anaconda3\python.exe C:/python基础语法练习/csdn.py 4 6 10 Process finished with exit code 0 3. 输入多个数据（一维数组） 博主对列表操作比较熟练，因此会在输入过程中将输入转换为列表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c75a879ba86268d2885029cd37a3116c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de0982d2bc6f866970722364c913308f/" rel="bookmark">
			基于webrtc的数据传输研究总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是webrtc WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。
一个简单的例子 PyWebRTC 这里简单介绍一个例子。在这个例子中，建立WebRTC连接的过程如下图所示：
这是一个简单基于python实现的服务端响应用户请求的例子。当客户端（Client）发起请求，服务器端（Server）与Client建立WebRTC连接，并把流媒体资源库中的demo-instruct.wav音频通过WebRTC连接的方式传输到Client，在Client这一端可以实时听到音频的播放。
RTCPeerConnection webrtc的P2P连接依赖于实现在两端主体程序中的RTCPeerConnection对象（pc_client和pc_server），它们需要经历两个阶段的协商，才能建立连接。
媒体协商 媒体协商要做的事情，是让彼此了解对方的多媒体能力（上图中红色标记的步骤）。例如：webrtc默认使用V8编码和解码，如果Client不支持V8解码，如果没有媒体协商过程，那么即便是连接成功，Server把视频数据发给Client，对方也无法播放。进一步，如果Client支持VP8、H264多中编码格式，而Server支持VP9、H264，如果要保证两端的正常的编码、解码，最简单的办法是取它们的交集，H264。
媒体协商的过程在代码层实际上是交换了各自的sdp信息，这个过程也叫 offer/answer 过程（可能是因为Client端的sdp信息由createOffer()方法创建，而Server的sdp信息由createAnswer()方法创建）。在这个例子中，这个过程大致为，首先由Client通过普通http请求的方式将自身sdp信息Post给Server，然后Server将自身sdp信息作为响应返回给Client，它们各自使用以下语句，来设置自身的sdp，和对方的sdp。
#用于设置自身的多媒体特征sdp pc.setLocalDescription() #用于设置对方的多媒体特征sdp pc.setRemoteDescription sdp的具体格式可以分成三个部分，*号表示的是可选的。如下：
Session description v= (protocol version) o= (originator and session identifier) s= (session name) i=* (session information) u=* (URI of description) e=* (email address) p=* (phone number) c=* (connection information -- not required if included in all media) b=* (zero or more bandwidth information lines) [...One or more time descriptions ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de0982d2bc6f866970722364c913308f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57111839b93e9994d0cf3910fd16e09/" rel="bookmark">
			[echarts]echarts的canvas画布大小与容器大小不一致的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="wrap" style="width:300px;height:300px;"&gt; &lt;!-- echarts容器 --&gt; &lt;div id="echarts" style="width: 100%;height:100%;"&gt;&lt;/div&gt; &lt;/div&gt; 场景描述：如上所示布局，我的echarts容器大小设置的宽高都是100%，为了让他占满整个wrap盒子;
解决方法1：所以设置echarts宽高为100%
设置宽高百分比之后如果canvas依然是100px或者没有占满图表容器:
解决方案2：利用resize设置width、height
// 获取wrap盒子的宽高 let width = document.getElementById('wrap').clientWidth() let height= document.getElementById('wrap').clientHeight() // 渲染echart图表的方法 drawchart() { let charts = echarts.init(document.getElementById('chart')) // 每次渲染之前都要clear一下，因为图表数据不是一成不变的，当重新调接口获取数据后就要重新渲染，如果不clear，有可能造成图表不变或图表叠加渲染等情况 charts.clear()	let option = { ... } // 一般这一步是写charts.resize()，让图表根据当前屏幕尺寸自适应，但是当前canvas画布大小与容器大小不一致，而容器大小已经设置了百分比，所以可以在resize里面手动设置宽高，使其占满整个wrap盒子 charts.resize({ //width: width, //height: height, // es6解构 width, height }) // 渲染图表 charts.setOption(option) } 解决方案3：利用v-if，这种情况多发在el-tab el-collapse
&lt;el-collapse v-model="activeName" accordion&gt; &lt;el-collapse-item name="1"&gt; &lt;ZLine :chart="'cpuUse'+index" :title="item?.metricName" :data="item?.metricPoints" :zoom="zoom" :ref="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d57111839b93e9994d0cf3910fd16e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913e32bf7945ab527635df8a1af534c2/" rel="bookmark">
			【嵌入式知识12】使用PWM实现LED呼吸灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次实验使用TIM3和TIM4，分别输出一个PWM波形，PWM的占空比随时间变化，去驱动外接的一个LED以及最小开发板上已焊接的LED（固定接在 PC13 GPIO端口），实现2个 LED呼吸灯的效果。
本文目录 一、PWM脉冲调制简介1. PWM是什么2. PWM脉冲调制基本原理3. 占空比计算4. PWM的优点 二、CubuMX配置定时器输出PWM1. 芯片选择2. 时钟配置3. 配置定时器使输出PWM4. 工程项目导出 三、代码编写1. TIM1_channel1初始化2. 回调函数 四、总结五、参考资料 一、PWM脉冲调制简介 1. PWM是什么 PWM（Pulse Width Modulation）即脉冲宽度调制，简称脉宽调制。它是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术；它是一种模拟控制方式，根据相应载荷的变化来调制晶体管基极或MOS管栅极的偏置，来实现晶体管或MOS管导通时间的改变，从而实现开关稳压电源输出的改变。
实际上，PWM是使用脉冲占空比拟合不同波形，即通过对一系列脉冲的宽度进行调制，来等效地获得所需要波形（含形状和幅值）。如图，可以用一系列等幅不等宽的脉冲来代替一个正弦半波。
2. PWM脉冲调制基本原理 PWM就是对逆变电路开关器件的通断进行控制，使输出端得到一系列幅值相等的脉冲，用这些脉冲来代替正弦波或所需要的波形。也可以这样理解，PWM是一种对模拟信号电平进行数字编码的方法。通过高分辨率计数器的使用，方波的占空比被调制用来对一个具体模拟信号的电平进行编码。
如果要改变等效输出正弦波幅值，按同一比例改变各脉冲宽度即可。 若把拟合的波形改成呼吸特性曲线，即可得到控制呼吸灯使用的 PWM 波形，要生成拟合的 PWM波形，通常使用计算法和调制法，本文中使用计算法：根据拟合波形的频率、幅值和半周期脉冲数，准确计算 PWM 波各脉冲宽度和间隔，据此控制开关器件的通断，就可得到所需 PWM 波形。
如果要改变PWM输出波形的宽度，就要改变比较寄存器 CCRx 的值，想要输出不通宽度来拟合正弦波，则需要CCRx的值呈现如下图的变化趋势，即要生成一张CCRx的数值表，按周期变化将表中元素的值赋给CCRx。
3. 占空比计算 PWM 信号中要注意的重要一点是时间周期和频率始终是固定的。只有脉冲 ON的 时间和 OFF的 时间（占空比）不同。通过这种技术，我们可以调制给定的电压。方波信号和 PWM 信号之间的一个区别是方波信号具有相同的 ON 和 OFF 时间（50% 占空比），而 PWM 信号具有可变占空比。方波可以看作是占空比为 50%（ON 时间 = OFF 时间）的 PWM 信号的特例。
可以使用以下公式计算占空比：
4. PWM的优点 PWM从处理器到被控系统信号都是数字形式的，无需进行数模转换。这样可以是信号保持数字形式，将噪声影响降到最低。噪声只有在强到足以将逻辑1改为逻辑0或者逻辑0改为逻辑1时，才会对数字信号产生影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913e32bf7945ab527635df8a1af534c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b87878e5070ac4b990968c56d4faaef/" rel="bookmark">
			Qt解决中文显示乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我相信所有用过Qt都遇到过中文乱码问题。下面列出了我经常用的几种解决方法。
方法一 #include "QtUtf8.h" #include &lt;QTextCodec&gt; // 添加头文件 QtUtf8::QtUtf8(QWidget *parent) : QMainWindow(parent) { ui.setupUi(this); QTextCodec* codec = QTextCodec::codecForName("GBK");//添加编码格式 ui.label-&gt;setText(codec-&gt;toUnicode("林夕爱吃面皮肉夹馍"));//使用方式 } 方法二 该方法有点复杂，懒人请跳过。
Step1：使用Notepad++打开对于的文件将编码格式转成UTF-8-BOM编码。
Step2：使用QStringLiteral（“中文字符”）
#include "QtUtf8.h" #include &lt;QString&gt; // 添加头文件 QtUtf8::QtUtf8(QWidget *parent) : QMainWindow(parent) { ui.setupUi(this); ui.label-&gt;setText(QStringLiteral("林夕爱吃面皮肉夹馍"));//使用方式 } 方法三 我最喜欢的方法没有之一。最爱。太方便了。万物皆可u8
#include "QtUtf8.h" QtUtf8::QtUtf8(QWidget *parent) : QMainWindow(parent) { ui.setupUi(this); ui.label-&gt;setText(u8"林夕爱吃面皮肉夹馍");//使用方式 } 效果图 方法四 最近把环境升级了一下，发现Qt6版本不能使用方法一中的方法了。所以，我又找到了一种一刀切的方法。
就是将Qt Create 的环境全部改为utf-8，但是这样存在一个弊端就是会有编码不是utf-8的项目就会存在打不开的问题。这个时候就需要手动将 xxx.pro文件通过方式二将其修改为utf-8再进行打开。
设置系统默认编码 1、第一步 任意打开一个项目，点击左侧的项目。
2、点击左上角的Manage Kits… 按钮。
3、点击左侧的环境
4、将Text codec for tools 设置为utf-8 即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b87878e5070ac4b990968c56d4faaef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70e0253008c66992f7c6e9313f608449/" rel="bookmark">
			使用 VS2022 内置 Git 异常，报错“长度不能小于0” 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 针对所有程序针对特定程序局域网配置 关于使用 VS2022 内置 Git 异常，报错“长度不能小于0”的问题 需要在注册表（regedit）中增加项 针对所有程序 路径 [计算机\HKEY_LOCAL_MACHINE\SOFTWARE\TEC\Ocular.3\agent\config] 下新增
[字符串值] hookapi_disins
[数值数据] 1
可直接运行命令行添加注册表
&gt; REG ADD HKEY_LOCAL_MACHINE\SOFTWARE\TEC\Ocular.3\agent\config /v hookapi_disins /d 1 针对特定程序 路径 [计算机\HKEY_LOCAL_MACHINE\SOFTWARE\TEC\Ocular.3\agent\config] 下新增
[字符串值] hookapi_filterproc_external
[数值数据] cmd.exe;powershell.exe;git.exe;idea64.exe;devenv.exe
局域网配置 这个是ipguard的后端控制台的页面，如果运维组配置以后就能彻底解决每个用户的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33a135e04743f57de45cbac2b5ee865a/" rel="bookmark">
			批处理文件遍历所有子目录批量移除文件名和目录名中特殊字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从网上下载到的某些资源（感谢那些无私奉献学习资源的人），文件名或目录名有一些特殊字符，如何批量移除呢？
本文介绍利用批处理脚本，遍历指定目录以及指定目录下的所有子目录批量移除文件名和目录名中特殊字符的方法。方便快捷绿色省心~~
遍历当前目录以及所有子目录批量处理 批处理脚本内容 创建一个后缀为 .bat 或 .cmd 的批处理文件，内容如下：
@echo off setlocal enabledelayedexpansion chcp 65001 :: 如果要指定绝对路径，用以下两行，注释 set path=. 所在行。也就是用以下两行代替 set path=. 这一行。 :: set path="C:\temp\test" :: cd "/d %path%" set path=. :: echo.&amp;set /p path=please input path: :: 删除特殊字符，记得替换成你自己需要删除的 set adv=【我是特殊字符】 :: echo.&amp;set /p adv=please input to be delete characters: call:renameFiles for /f "delims=" %%i in ('dir /ad/b/s "%path%"') do ( cd %%i call:renameFiles ) echo. echo 处理完毕 echo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33a135e04743f57de45cbac2b5ee865a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeff093347646c0fdbde68db2faf4305/" rel="bookmark">
			vue的cookies:vue-cookies 设置,获取及删除指定的cookies
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装： npm install vue-cookies --save 引用
main.js中设置
// vue-cookies配置 import cookies from 'vue-cookies' Vue.prototype.$cookies = cookies; vue-cookie使用 1、设置cookie
this.$cookies.set(keyName, value[, expireTimes[, path[, domain[, secure]]]]) //return this // 简洁使用 this.$cookies.set('key','value', '过期时间,按秒计'); // 示例 this.$cookies.set('username',response.data.username, '张三'); 2、获取cookie
this.$cookies.get(keyName) // return value 3、删除cookie
this.$cookies.remove(keyName); 4、判断cookie中是否有指定的key
this.$cookies.isKey(keyName) 5、获取所有cookie
this.$cookies.keys() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8647c636291240c685509b80947a2bab/" rel="bookmark">
			蚂蚁集团获得Spider冠军，登上两项NL2SQL权威榜单榜首
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日前，蚂蚁集团凭借在语义解析领域提出的中间表征语言PQL，超越了Meta、Allen Institute for AI、微软、达摩院、耶鲁大学、上海交通大学等研究机构和科技企业，以78.5分的成绩获得了NL2SQL国际权威榜单Spider的第一名，刷新了该任务的业界记录。
近年来，运用人工智能技术提高结构化数据利用效率成为了业界研究热点，NL2SQL(Natural Language to SQL)是一种自动将用户输入的自然语言转成数据库可操作SQL查询语句的技术，可以有效提高人机交互效率，实现基于数据库的自动问答能力，因此在对话系统、商业智能等场景有重要应用价值。
Spider数据集由耶鲁大学提出，是业界公认的NL2SQL领域难度最大的大规模跨领域评测榜单，共涵盖138个不同的领域，包含10181个问题、5693个复杂SQL查询语句、200个多表数据库，自2018年提出至今，Spider吸引了众多国际领先机构参加测评，榜单排名竞争激烈。此次摘下冠军，显示出蚂蚁集团在NL2SQL技术上的领先性。
在本次评测中，蚂蚁集团智能服务团队联合蚂蚁财富、搜索等蚂蚁NLP研究小组共同设计了中间表征语言PQL，这是一种能同时兼容表格与图谱查询的中间语言，相比SQL，它能以更简洁的语法来表征自然语言问题，对问题中存在的关键推理路径进行对齐，并合并查询图中存在冗余或同义结构，从而有效提升模型对推理路径的识别准确性。
近几年，蚂蚁集团在NL2SQL方向上深入多项研究，并结合NL2SQL、对话管理等技术提供结构化表格的多轮对话问答能力，目前这一技术已经在蚂蚁财富智能理财助理"支小宝"、客服等多个场景应用，可以将用户求助自动转化为背后数据库查询，实现复杂问题的理解和回答。例如，当投资者遇到无法快速找到目标基金的问题时，“支小宝”可以通过NL2SQL的技术能力及丰富的金融领域数据，来帮助投资者解决，让投资者不仅能直接用“所属板块、基金经理、涨跌幅、夏普比” 等超过200种条件进行查询，还可以自由组合条件，实现“所想即所得”的用户体验。据了解，目前“支小宝"共累计回复了超过1亿次金融问答类理财问题，对该类问题的准确识别率达到了93%。
根据公开信息，去年6月，蚂蚁集团智能服务算法团队和支小宝团队登上了NL2SQL领域另一权威榜单WikiSQL的榜首。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd63e53f333709d746e2c62342328be/" rel="bookmark">
			Git多模块分支管理（新建模块分支、合并模块分支到远程分支）图形化操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 需求基于主分支master_test新建模块分支branch_crm模块分支合并代码到主分支 需求 目前有主分支 master_test然后有模块 crm 需要单独拉分支本文展示图形化操作（可git 命令代替） 基于主分支master_test新建模块分支branch_crm 切换到主分支master_test
基于主分支master_test新建模块分支branch_crm 推送分支到远程
这个时候远程仓库就已经有了新分支 模块分支合并代码到主分支 在模块分支branch_crm开发新需求代码后
推送新需求代码到模块分支branch_crm远程分支
更新主分支master_test代码到模块分支branch_crm
有冲突就解决冲突，不要更改别的模块的代码
推送代码到模块分支branch_crm远程分支(模块分支branch_crm就有了主分支master_test最新的代码)
创建merge请求 合并到主分支master_test
pycharm操作
也可以用pycharm切换到master_test分支，创建合并请求
然后推送
gitliab 操作
更改分支
主要不要勾选删除原分支
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3af502379c737669e2f8b4d594b24ea/" rel="bookmark">
			AxMath pj 并添加到WPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AxMath并添加到WPS pj添加到WPS pj 链接：https://pan.baidu.com/s/1oDlEPO3hIqpB-gP9V53BvQ
提取码：n9pa
添加到WPS WPS -&gt; 开发工具 -&gt; 加载项 -&gt; 添加 -&gt; 选择文件路径
这个路径我建议大家下载一个软件叫Everything，在里面搜索 AxMath.dotm 这个文件，然后把文件路径添加进去就ok了
直接这样用不了，点击之后也不好使，因此需要下载wps vba
之后就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f6603e29ccc7827e7ae44f5d368e85/" rel="bookmark">
			15、微信小程序登录详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、登录流程 1、获取临时登陆凭证 code （code —— 限频接口），wx.login()
2、前端向服务器发送 ajax 请求（ wx.request() ），该请求需要携带三个参数：code、appid、appsecret，目的是获取唯一标识符 token，在api 文件夹下新建 login.js
3、前后端交互
3.1 对于一个新用户，程序内部没有可提供的 appsecret，用户需先注册才能获得appsecret
3.2 用户登录，此时程序内部将只需传入 code appid两个参数，同时服务器发送内部请求，将根据用户传入的 appid 来找相应的appsecret
3.3 用户根据 code appid appsecret 实现登录
4、前端将用户唯一标识符 token 保存在本地，此后所有个人相关的业务都需要用到 token，若没有token，则需要跳转到 登陆页面获取
api——request.js
import baseUrl from './baseUrl' function request(config) { return new Promise((resolve, reject) =&gt; { wx.request({ url: baseUrl + config.url, timeout: 5000, method: config.method, // 在微信小程序中，get、post、delete、put 传参都是 data data: config.data, //如果需要传参 success(res) { resolve(res) }, fail(error) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f6603e29ccc7827e7ae44f5d368e85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4302486a332972e5432f3cbaeba6b92e/" rel="bookmark">
			html一个案例学会所有常用HTML(H5)标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
HTML5声明
HTML框架
head头部
声明编码格式
告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面。
移动端适配 网站标题
网站正文
网站内容的组成 文字有关标签
音频视频标签
表单标签与input属性
前言 HTML没有什么难度，无论对于大一开始学的，或者大二进行重新复习都是一样，只要踏实下来就那么稳稳的敲个几遍也就记住了，这里面我没有涉及table标签，因为这个标签有层级结构，当大家掌握到基本入门的时候我再说table，因为到了web前后端考试的时候才会涉及到table的遍历，当然，这个也是分语言的，如果是java就是jsp，但是如果是.NET就会是ASP，我们会根据不同的语言进行讲解，jsp的el表达式遍历table，asp的GridView与repeater都会给大家比较细致的讲解。
超链接我也没添加在这里，就一个【a】字母，这篇文章主要让大家记住一些常用标签的单词，很简单的我就没添加，因为后面用的多，用着用着就都会了。大家踏实一些，将之前落下的补充上，后面都能顺利的听懂整堂的内容了，祝大家都可能顺利的通过考试。
HTML5声明 &lt;!DOCTYPE html&gt; HTML框架 &lt;!-- lang="en"代表英文，"zh"代表中文 --&gt; &lt;html lang="en"&gt; &lt;/html&gt; head头部 &lt;head&gt; &lt;/head&gt; 声明编码格式 &lt;meta charset="UTF-8"&gt; 告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面。 &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 移动端适配 &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; 网站标题 &lt;title&gt;My First HTML Page&lt;/title&gt; 网站正文 &lt;body&gt; &lt;/body&gt; 网站内容的组成 &lt;!-- 1、文字 --&gt;
&lt;!-- 2、图片 img --&gt;
&lt;!-- 3、音频.mp3 --&gt;
&lt;!-- 4、视频.mp4 --&gt;
&lt;!-- 5、表单 --&gt;
文字有关标签 &lt;!-- 正斜杠/ 反斜杠\ --&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4302486a332972e5432f3cbaeba6b92e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112dbdc0bf3e08d315bc017d93f1feb0/" rel="bookmark">
			【技术科普】支持H.265视频网页Web播放的EasyPlayer.js设计理念与功能计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 EasyPlayer.js网页播放器对于H.265支持的研发差不多整整一年了，回想到2019年国庆前后，从用户现场反馈来的需求：目前市面上大部分的IPC摄像机或者NVR录像机设备，都默认H.265编码格式了，无法修改设备的编码格式以适应平台，因为设备已经被多个平台接入和引用了，经过了多番的调研，最终确定了EasyPlayer.js的研发初衷：
Easy系列视频产品（EasyCVR、EasyDSS、EasyGBS、EasyNTS、EasyNVR）需要降低视频设备的接入门槛，需要支持H.265视频编码格式的接入。
H.265不仅仅是在设备端需要，在客户端播放、流媒体分发、云端存储，都需要支持H.265；
否定了服务端H.265转码H.264的方案，一方面是性能消耗巨大，另一方面是转码方案非视频云服务所为；
于是，我们分了两条线支持H.265，一条是视频服务端、一条是播放端，整体确定了我们的H.265支持方案：
视频云服务端、边缘设备端，都不需要经过转码，原生支持H.265视频编码格式，视频直播输出协议包括，直播协议：rtmp、http-flv、hls、rtsp，录像回放协议：hls，其中ts和RTP都有H.265的标准支持，flv的H.265支持采用的是国内CDN联盟的标准。
视频播放端，经过多方调研，对于H.265视频的Web网页播放，采用WebAssembly（wasm）解码播放的方式支持，对于H.264编码格式，走原有MSE或者H5播放路径，这样一方面支持了H.265，另一方面又保障了H.264播放的性能；
播放器在wasm模式与H5模式的切换上，采用播放器内置解析器的方式，不从服务端额外增加字段判别编码格式；
经过一年多的研发与迭代，如今，EasyPlayer.js已经非常好地在Easy全系列中得到应用，并且让人兴奋的是：Easy系列的产品已经开始反哺EasyPlayer.js了。
EasyNVR边缘网关服务中的EasyPlayer.js： EasyGBS国标GB/T28181流媒体服务中的EasyPlayer.js： EasyDSS流媒体视频直播/点播服务中的EasyPlayer.js： EasyCVR安防视频云服务平台中的EasyPlayer.js： EasyPlayer.js立足于安防互联网领域，对于H.265视频编码的支持，完美地解决了安防与互联网之间串联的一个最大障碍，EasyPlayer.js不仅具备了互联网所需要的全平台、全终端、多屏展示的功能，而且还具备了安防视频所需要的低延时、高效率、重连、追帧、丢包容错等功能，集合了TSINGSEE团队多年的安防视频播放器研发的成功经验，完美地移植到了互联网视频播放！
EasyPlayer.js得到了Easy系列开源和商业产品的反哺后，将会加速EasyPlayer.js的迭代进程，后续EasyPlayer.js功能上，将围绕着几个方面推进：
更多音视频编码格式和参数的支持；更灵活的调用，尤其是在iOS这样的平台上的低延时直播；后flash时代，对于RTMP协议的支持； 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/205/">«</a>
	<span class="pagination__item pagination__item--current">206/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/207/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>