<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9758da0c643ffd36ff8ff42c880123bf/" rel="bookmark">
			Golang 深入浅出map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上很多博客都对map的内部实现讲了很多，很多人可能看完都绕晕了，看完可能装载因子是多少，扩容倍率是多少还是没搞清楚。没错我就是这样子，QAQ。
直接给出结果，装载因子6.5，扩容倍率是2倍，采用拉链法。这个拉链法并不是传统意义上的数组加链表，而是数组桶加数组链表的形式。接下来我们一步一步简单说明好了。
map的创建，一般是通过make来初始化的，编译时会将make替换为如下的runtime makemap。可以看到，它返回的是一个叫做hmap的指针，这也是为何说map是一个指针，所以参数传递放心大胆的传，内部的修改一样会影响外部的。
func makemap(t *maptype, hint int, h *hmap) *hmap { ... } 那么hmap长啥样呢？
type hmap struct { count int flags uint8 B uint8 noverflow uint16 hash0 uint32 buckets unsafe.Pointer oldbuckets unsafe.Pointer nevacuate uintptr extra *mapextra } count 是map的元素个数flags 代表当前map的状态，是否处于写入的状态等，比如在给map的key赋值的时候，该值会被标记为写入，那么此时并发的去写入这个map时候，我们就会得到concurrent map writes这样的panic，就是通过这个标记来实现的。hash0 是计算hash时的随机数种子，在创建map时确定。B是用来计算桶的个数的，桶的个数2^B次方，而B最大为256，而桶的结构为bmap，其一共可以装载8个key value，此外每个桶，还有overflow，表示溢出桶，不多说这个。扩容就是通过将B加1，那么B加1当然就是桶的数量翻倍了。buckets 当前的桶指针，每次需要扩容时将生成新的桶，将hmap的桶指针指向新桶即可。而原来的桶将会被oldbuckets持有。oldbuckets 扩容后原有的桶，被oldbuckets指向。为什么要保留旧的桶呢？这是扩容时，不需要一次性的将旧有元素拷贝到新桶内，而是通过每次访问key时候，如果发现它在旧桶内，就将它搬迁到新桶，这样就比较平滑。不会因为一次性搬迁导致系统的CPU突然上升不稳定，这种扩容方式在Redis里也较为常见。nevacute 在扩容时使用，用于标记当前桶中nevacute的数据都已经转移到新桶中了。extra 是一个数组指针，指向溢出桶的数组。 这里先提一嘴map的访问方式，访问map中的元素呢，他是通过计算key的hash值，然后与桶的数量2^B取余（其实是hash(key)&amp;2^B）取余， 得到key所在的桶的位置。桶buckets其实是一个数组，因此得到桶的位置后，我们就去桶里去比较这个key，从而获取值。
我们看一下桶的结构bmap.
type bmap struct { topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr overflow uintptr } 桶内其实也是三个8元素的数组，其中topbits内存储的是，key的hash值高8位，然后以当前位置+8就得到keys的位置，再加8就得到values的位置。我们存储一个kv时候，就是先存储它的hash值高8位，然后在存储kv到相应的位置。如果存储数据到某个桶的时候，这个桶已经8个元素了，此时map并不扩容，而是将其存储到溢出桶中。溢出桶也是一个bmap。我们回到存储的过程，此时就需要将数据存储到overflo中去。但overflow是一个指针，它指向一个溢出桶的bmap。这个溢出桶bmap在哪里呢，它在hmap的extra中，extra是*mapextra。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9758da0c643ffd36ff8ff42c880123bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2bd91903d57852ed59a4328f3a1bece/" rel="bookmark">
			React组件拆分总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5w原则
.1.（when）什么时候应该拆分组件
当出现：
代码量大，所有内容集中在一起相同组件无法复用业务开发分工不明确，开发人员要关心非业务的代码改代码时，可能会影响其他业务，牵一发动全身(耦合)任何一个操作都导致整个应用重新render 目的：提高可读性、可维护性，解耦
2.(how)如何拆分组件
把相关联的东西放一起（按功能、业务）
横向（按业务、功能模块划分）纵向（应用、系统层级划分） 经典案例：
不拆分 登录组件处理了2件事情:
渲染登录表单记录用户输入和登录状态，向后台发送登录请求 class Login extends Component { constructor(props) { super(props) this.state = { account: '', password: '', status: 'init', } } handleAccountChange(e) { this.setState({account: e.target.value}) } handlePasswordChange(e) { this.setState({password: e.target.value}) } handleLoginClick() { this.setState({ status: 'ing' }) request('/login', { params: { account: this.state.account, password: this.state.password, } }).then(() =&gt; { this.setState({status: 'succ'}) }).catch(() =&gt; { this.setState({status: 'fail'}) }) } render() { return ( &lt;div&gt; &lt;input placeholder="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2bd91903d57852ed59a4328f3a1bece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90cd84a0c89aef8319524f0672f6bfa0/" rel="bookmark">
			vue&#43;el-cascader设置默认选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue+el-cascader设置默认选项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83bf65e5f5c66cb901e2614300b57c4a/" rel="bookmark">
			vmware关闭侧通道缓解(windows端)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 shutdown the vm ossettingsoptions中文设置 shutdown the vm os 建议打开虚拟机操作系统,在系统中执行关机指令外部关机(power off) (会导致数据丢失) settings options virtual Machine Settings -&gt;options-&gt;advanced
中文设置 关闭前要把虚拟机关机(从挂起状态转为关机状态才能设置)!!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c797dab69cb713b5ee032e607133fac/" rel="bookmark">
			数据结构——循环队列操作集（C/C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; #define N 100 typedef struct{ int *base;//指首元素,初始化动态分配空间 int front;//下标队头 int rear;//下标队尾 }SqQueue; //判断队空队满有第三种方式：预留一个空间不存。 //队空：front==rear,(rear+1)%N==front循环队列中，尾指针的下一个是首元素则满 void initQueue(SqQueue &amp;Q){ Q.base=new int[N]; if(!Q.base) return; Q.front=Q.rear=0; return; } int Queuelength(SqQueue Q){//循环队列取队长 return ((Q.rear-Q.front+N)%N); } void Enqueue(SqQueue &amp;Q,int e){//入队 if((Q.rear+1)%N==Q.front) return;//判断是否队满 Q.base[Q.rear]=e;//都是先赋值再移动指针 Q.rear=(Q.rear+1)%N; return; } void Outqueue(SqQueue &amp;Q,int &amp;e){//出队e,返回删除的元素 if(Q.front==Q.rear) return ;//判断是否为空 e=Q.base[Q.front];//出队首元素 Q.front=(Q.front+1)%N; } int gethead(SqQueue Q){//取队头 if(Q.front!=Q.rear)//不为空 return Q.base[Q.front]; } int main() { return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8decbc0fb519ded227511dc588a8a2/" rel="bookmark">
			C#中WriteLine与Write ReadLine与ReadKeyR与Read的区别：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WriteLine和Write的区别： WriteLine：打印一行信息，打印结束后自动换行；
Write：打印信息，打印信息后不自动进行换行；
ReadLine和ReadKey和Read的区别： ReadLine：从起一行读取信息输入，直到按下回车键才结束输入信息，不包括换行符；
Read：读取键盘输入的第一个字符，返回ASCII值。按下回车键退出
Console.WriteLine("在下一行输入："); int ASCII=Console.Read(); Console.WriteLine("ASCII="+ ASCII); string str=Console.ReadLine(); Console.WriteLine("Read获取第一个字符后的字符串="+str); 结果如下：
ReadKey()：终端检测 当在按下键盘任意一个按键时命令完成，并在屏幕上显示按下的字符；
当ReadKey后面的参数是true是，按下的字符不会显示
ReadKey().KeyChar： 必须用char类型的变量接收，返回的是输入的字符
Console.WriteLine("下面ReadKey输入显示输入内容："); Console.ReadKey(); Console.WriteLine("\n下面ReadKey隐藏输入内容："); Console.ReadKey(true); Console.WriteLine("\n下面进行Console.ReadKey().KeyChar输入："); char c = Console.ReadKey().KeyChar; Console.WriteLine("\n刚才KeyChar输入了：" + c); 运行结果：
在程序中，一般会使用：Console.ReadKey(true);
对按下的键执行命令，而不显示按键内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f66f36f395010e0b5c409167621c46c2/" rel="bookmark">
			笔记2：VC&#43;&#43; socket通信实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VC++ socket通信实例
网络中进程之间如何通信 首要解决的问题是如何唯一标识一个进程，在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的ip地址可以唯一标识网络中的主机，而传输层的协议+端口可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。
Socket是什么 socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）。
说白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。
名词解释 网络协议 为了进行网络中的数据交换（通信）而建立的规则、标准或约定；
协议 = 语义 + 语法 + 规则；
不同层具有各自不同的协议，上层使用下层提供的服务，实际通信在最底层完成；对等层实体之间虚拟通信。
TCP协议： 面向连接的可靠的传输协议；
UDP协议： 面向无连接的不可靠的传输协议；
端口 一种抽象的软件结构。
应用程序通过系统调用与某端口建立连接后，传输层传给端口的数据都被响应的进行所接收，相应进程发给传输层的数据都通过该端口输出；
端口用一个整数型标示符来表示。端口号跟协议相关，TCP/IP传输层的两个协议TCP和UDP是完全独立的两个软件模块，因此各自的端口号也相互独立。
端口使用一个16位的数字来表示，它的范围是0~65535, 1024以下的端口号保留给预定义的服务。例如：http使用的是80端口。
socket(套接字) windows sockets只支持一个通信区域：网际域（AF_INET），这个域被使用网际协议簇通信的进程使用。
C/S 模式 客户机向服务器提出请求，服务器接收到请求后，提供相应的服务。网络通讯的标准模式；
socket(套接字的模式) 流式套接字（SOCK_STREAM）：面向连接可靠的数据传输服务，按顺序接收。例如：TCP/IP数据包式套接字（SOCK_DGRAM）：无连接服务。接收顺序混乱。例如：UDP原始套接字（SOCK_RAM） 基于TCP（面向连接可靠）的socket编程 序号服务器客户端1创建socket创建socket2绑定IP和端口绑定IP和端口3设置Socket为监听模式4收到客户Connect请求，返回一个新的对应于此次连接的Socket Accept向服务区发起connect请求5与客户端进行通信，发送指令或数据与服务器进行通讯，send/recv6等待其他客户的请求…7关闭Socket关闭Socket Socket的基本操作 socket 所需的头文件 #include &lt;winsock2.h&gt;
socket 套接字 int socket( nt domain,	// 协议域 int type, // socket类型 int protocol);	// 协议 ); socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。
正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：
• domain：即协议域，又称为协议族（family）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f66f36f395010e0b5c409167621c46c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e2a6627a6c7b510f9fd9c5da9586703/" rel="bookmark">
			hutool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是hutool
Hutool 是一个 Java 工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，
导入安装
&lt;dependency&gt;
&lt;groupId&gt;cn.hutool&lt;/groupId&gt;
&lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
&lt;version&gt;5.7.21&lt;/version&gt;
&lt;/dependency&gt;
加密解密功能
对称加密
在对称加密算法中，加密和解密使用的是同一把钥匙，即：使用相同的密匙对同一密码进行加密和解密；
非对称加密
非对称加密有两个钥匙，及公钥（Public Key）和私钥（Private Key）。公钥和私钥是成对的存在，如果对原文使用公钥加密，则只能使用对应的私钥才能解密；因为加密和解密使用的不是同一把密钥，所以这种算法称之为非对称加密算法。
优缺点
对称加密：
优点：算法简单，加密解密容易，效率高，执行快。
缺点：相对来说不算特别安全，只有一把钥匙，密文如果被拦截，且密钥也被劫持，那么，信息很容易被破译。
非对称加密：
优点：安全，即使密文被拦截、公钥被获取，但是无法获取到私钥，也就无法破译密文。作为接收方，务必要保管好自己的密钥。
缺点：加密算法及其复杂，安全性依赖算法与密钥，而且加密和解密效率很低。
HtmlUtil（HTML 工具类）
定时任务
时间为：分 时 天 月 星期
导出Excel 配置
&lt;dependency&gt;
&lt;groupId&gt;cn.hutool&lt;/groupId&gt;
&lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
&lt;version&gt;5.0.7&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
&lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;
&lt;version&gt;5.1.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;
&lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt;
&lt;version&gt;3.17&lt;/version&gt;
&lt;/dependency&gt;
直接写在到某个盘符
示例:
@RequestMapping("/xiazai")
public String xiazai(){
List&lt;Emp&gt; emps=empService.findAll();
List&lt;Emp&gt; rows = CollUtil.newArrayList(emps);
// 通过工具类创建writer
ExcelWriter writer = ExcelUtil.getWriter("d:/writeBeanTest.xlsx");
// 合并单元格后的标题行，使用默认标题样式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e2a6627a6c7b510f9fd9c5da9586703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad721fbcbec29bd412a7100c592bbd4d/" rel="bookmark">
			数据结构——哈希表（Hash表）、哈希碰撞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 哈希表（也叫散列表），是根据键（Key）直接访问在内存存储位置的数据结构。就是一种以 键-值(key-value) 存储数据的结构，我们只要输入key，就可查找到其对应的值。
hash函数就是根据key计算出该存储地址的位置，hash表就是基于hash函数建立的一种查找表。
当使用hash表查询时，就是使用hash函数将key转换成对应的数组下标，并定位到该下标的数组空间里获取value，这样就充分利用到数组的定位性能进行数据定位。
2.哈希碰撞 当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希碰撞，也叫哈希冲突。
哈希冲突解决方案： （1）链地址法：在冲突的地方通过链表来解决
优点：处理形式简单，没有数据堆积，平均查找时间相对较短
缺点：如果哈希冲突比较大，卡槽存储的数据可能就会比较多
（2）线性探测法：
线性探测函数：H(i)=i或者H(i)=i*c(c是常量)
随机探测：H(i)=randon(i)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a76b1069338e85ab7a9bde50030480/" rel="bookmark">
			coco姿态估计性能评价标准-AP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		coco2017是当前最主流的多人姿态估计benchmark，官网的Evaluate已对coco的评价标准做了详细的解释，本文只对其二次整理。
Overview 首先coco的姿态估计要求对目标进行检测和定位他们的keypoint，测试过程中目标的定位结果是不提供的，这非常符合常理。
其次coco对姿态估计的评价主要参考了coco的目标检测评价，在目标检测评价中，IOU是预测结果与GT之间的相似度度量标准，有了这个值之后，我们就可以设定阈值，计算出AP（average precision）AR（average recall）这些指标。
那么同理，对于姿态估计来说，如果也能找到一个衡量预测和GT之间的相似性的标准的话，那就可以套用目标检测的评价了。这个相似性度量标准就是OKS。
无论是目标检测还是姿态估计，coco评价都是以object为单位进行的，而不是图的数量。
OKS 那么什么是OKS？
OKS的全称为Object Keypoint Similarity，它的计算公式如下：
O K S = ∑ i e x p [ − d i 2 2 s 2 k i 2 δ ( v i &gt; 0 ) ] ∑ i δ ( v i &gt; 0 ) OKS=\frac{\sum _{i}exp\left [\frac{-d_{i}^{2}}{2s^{2}k_{i}^{2}}\delta (v_{i}&gt;0) \right ]}{\sum _{i}\delta (v_{i}&gt;0)} OKS=∑i​δ(vi​&gt;0)∑i​exp[2s2ki2​−di2​​δ(vi​&gt;0)]​
OKS定义为一个目标与它的GT的keypoint相似度，其中 i i i为关键点的个数
d i 2 d_{i}^{2} di2​表示关键点 i i i预测值与GT之间的欧氏距离
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a76b1069338e85ab7a9bde50030480/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e33352bd2b6e3668878ce0ef1b2e66/" rel="bookmark">
			Jvm笔记1：类加载机制和双亲委派模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM笔记1 1、代码是怎么运行起来的？2、类加载过程？3、JVM什么情况下初始化一个类？4、类加载器4.1 启动类加载器4.2 扩展类加载器4.3 应用类加载器4.4 自定义类加载器 5、双亲委派模型5.1 什么叫双亲委派模型？5.2 双亲委派模型的好处？5.3 tomcat需要破坏双亲委派模型的原因？ 1、代码是怎么运行起来的？ Java代码文件编译成".class"后缀的字节码文件
类加载器会把编译好的字节码文件加载到JVM中去
JVM基于自己的字节码执行引擎，执行加载到内存中的类
2、类加载过程？ 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 加载: 类加载器会把编译好的字节码文件加载到JVM。验证: 根据Java虚拟机规范，验证加载的".class"文件内容是否符合规范。准备: 给类以及类静态变量、属性等分配一定的内存空间，赋予初始化0或null。解析：将常量池中符号引用替换成直接引用。初始化：核心阶段，针对类静态变量、属性等号（=）后代码的执行以及对静态代码块的代码执行。
3、JVM什么情况下初始化一个类？ 类实例创建：new创建实例对象、反射生成类实例对象等，而不是main函数启动或spring启动时初始化。main方法依赖：main函数启动时即创建。子类初始化：初始化类的过程中，若发现该类的父类未初始化，那么会先初始化父类，然后再初始化该类。 4、类加载器 4.1 启动类加载器 BootStrap ClassLoader，Jvm启动的时候，首先会依托类加载器去加载我们在机器上安装在Java目录下lib文件夹的核心类。
4.2 扩展类加载器 Extension ClassLoader，Java目录下lib/ext文件夹的类需要该类加载器去加载，来支撑系统的运行。
4.3 应用类加载器 Application ClassLoader，负责加载“ClassPath”环境变量路径下的所指定的类，也就是我们写的Java代码类。
4.4 自定义类加载器 除以上类以外，根据自己需求自定义类的加载器。
5、双亲委派模型 5.1 什么叫双亲委派模型？ Java的类加载器是存在层级结构的，结构如下图：
基于这个层级结构，我们来了解一个重要概念：双亲委派模型
核心：向上委派，父类优先加载，否则下推加载权利给子类
当Java虚拟机需要加载一个User类，此时应用类加载器不会自己去加载该类，而是会咨询父类（扩展类加载器）可否加载？
扩展类收到咨询后也不会去加载该类，而是咨询父类（启动类加载器）可否加载？
启动类加载器收到后，如果能加载就会加载该User类。若不能加载，就会下推加载权利给子类，也就是扩展类加载器。
扩展类加载器收到加载权利后，若能加载User类就会启动加载，若不能加载也会继续下推加载权利到子类，也就是应用类加载器，从而让应用类加载器启动加载该User类。
5.2 双亲委派模型的好处？ 避免同一类重复加载：因为类加载是向上委托的，确保了一个类只会被加载一次避免Java的核心Api被篡改：父类以及加载过了，自定义的类已经不起作用了，有一定的安全性。 5.3 tomcat需要破坏双亲委派模型的原因？ tomcat中的需要支持不同web应用依赖同一个第三方类库的不同版本，jar类库需要保证相互隔离；
同一个第三方类库的相同版本在不同web应用可以共享
tomcat自身依赖的类库需要与应用依赖的类库隔离
需要支持jsp修改后不用重启tomcat即可生效,为了上面类加载隔离和类更新不用重启，定制开发各种的类加载器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43b1b10caac4dae2130253b455336b85/" rel="bookmark">
			博途使用多重背景数据块&#43;SCL&#43;UDT实现过程控制标准化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博途的多重背景数据块, 类似于C# 中的单例模式. 通过一个静态变量即可访问到目标对象的所有方法.
UDT为用户定制数据类型, 可以使用结构体等方法, 使编程结构化和简单化.
以电机控制为例.
1, 先做一个电机控制的模版…
Input	IStartBtn	Bool	false	非保持 IStopBtn	Bool	false	非保持 IResetBtn	Bool	false	非保持 IEmergencyBtn	Bool	false	非保持 IContact	Bool	false	非保持 IAi1	Int	0	非保持 Output	QRunning	Bool	false	非保持 QMonitorStatus	Int	0	非保持 QAo1	Real	0.0	非保持 Static	StRunFlag	Bool	false	非保持 StAlarmFlag	Bool	false	非保持 StMotorStatus	Int	0	非保持 IEC_Timer_0_Instance	TON_TIME	非保持 UpperiLimit	Real	0.0	非保持 LowLimit	Real	0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43b1b10caac4dae2130253b455336b85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179210dec672366c570ede2a9eb311f8/" rel="bookmark">
			R语言reshape包加载出现环境参数错误的解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序中突然出现 library(reshape)
错误: package or namespace load failed for ‘reshape’ in library.dynam(lib, package, package.lib):
没有这个DLL ‘plyr’：是不是没有为此架构安装？
此外: Warning message:
程辑包‘reshape’是用R版本4.1.2 来建造的 。
重新安装plyr包后，出现：
library(reshape)
错误: package or namespace load failed for ‘reshape’ in get(Info[i, 1], envir = env):
lazy-load database 'D:/Program Files/R/R-4.1.0/library/plyr/R/plyr.rdb' is corrupt
此外: Warning messages:
1: 程辑包‘reshape’是用R版本4.1.2 来建造的 2: In get(Info[i, 1], envir = env) : internal error -3 in R_decompress1
针对这种情况，我参考了链接r - ggplot2 fails to load - Stack Overflow，主要操作方法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/179210dec672366c570ede2a9eb311f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0d41b1699d8246d0311cb11e1577792/" rel="bookmark">
			汽车软件V流程开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.系统需求分析
调研并输出系统需求文档
2.系统架构设计
通常和第一步并行，并在系统需求文档中体现。第1和第2步都是系统层级的，下面应该分软件和硬件两个分支，这里我们只关注软件这个分支。
3.软件需求分析
输出软件需求文档，这部分工作通常是由软件部门负责人完成。
4.软件架构分析
输出软件方案设计文档，该部分工作由软件开发人员完成
5.软件设计及单元测试
输出软件详细设计文档和软件
如果是基于模型开发的，需要经历模型-&gt;c代码的过程，期间伴随着MIL测试、SIL测试，以上测试统称为单元测试。
如果是基于C代码开发的，需要进行单元测试，注意这里的单元测试不叫SIL测试。
单元测试工作由软件开发人员完成。
6.软件集成和集成测试
集成测试的主要关注点是系统能够成功编译，实现了主要的业务功能，系统各个模块之间数据能够正常传输等。
到这一步硬件应该有样板了，这部分测试通常需要搭建一个简易的台架，可以在把软件交给测试部门人员前，进行主要的功能测试。
这部分工作是由软件集成人员和硬件开发人员配合完成。如果集成工作由底层软件开发人员兼职的话，集成测试需要底层软件开发人员、应用层软件开发人员以及硬件开发人员共同完成。
7.软件功能测试
验证整个系统是否满足需求规格说明。通常这一步做HIL测试，测试人员基于软件需求进行测试。
8.系统集成测试和系统测试
这一步是在搭建好整个系统后进行调试和测试的。汽车相关的项目要在车上调试。这个阶段通常是由应用层软件开发工程师完成，后期软件稳定了，由标定工程师进行标定工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f81eb1757679a6358a9ef54c9ff359a/" rel="bookmark">
			NotADirectoryError: [WinError 267] 目录名称无效和OSError: [Errno 22] Invalid argument:解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于这类错误可能是由os.mkdir()创建目录时引发的错误，也可能是其他类型引起的。现在我来说一下这两个问题的解决办法。
本人是因为爬取网页是提取title作为目录名出错。
首先我们要知道目录的格式，目录或者文件名中是不能包含下列字符的：
\ / : * ？ " &lt; &gt; |
那么我们要做的就是去除目标字符串（目录）中包含的上述符号。
这里有两种做法
方法一：
创建一个清楚符号的函数
def remove_fuhao(string): # 创建函数 list = [] # 创建一个空列表用于储存处理后的字符 for item in string: # 从目标字符串逐个提取数字或文本 if item.isdigit() or item.isalpha(): list.append(item) # 将符合的字符加入到list中 em = "".join(list) return em # 返回em也就是处理完成的字符 string = "a*b.c/d ,e?" remove_fuhao(string) # 返回的em为 abcde # 如果调用print(string) # 结果为 abcde # 这个函数便将字符串中的符号清除 方法二：
使用python内置函数replace()
# replace的简单用法 replace("被替换的", "替换成的") str = "ab'cd!" a = str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f81eb1757679a6358a9ef54c9ff359a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a191d5d3df836e68ced495b263a9fbca/" rel="bookmark">
			JSR303数据校验 Spring统一异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSR303进行数据校验 1.给Bean添加校验注解
可以多个注解校验
@NotBlank(message = "品牌名不能为空") private String name; //不能为空 + 自定义规则 @NotEmpty @Pattern(regexp = "!/^[a-zA-Z]$/",message = "检索首字母必须是一个字母") private String firstLetter; //不能为空 + 最小值 @NotEmpty @Min(value = 0,message = "排序最小值是0") private Integer sort; Tips：@JsonInclude(JsonInclude.Include.NON_EMPTY) 标注的字段返回不为空时才会返回
2.在提交数据时开启数据校验功能
/** * 保存 * @Valid 注解告诉springmvc需要校验 */ @RequestMapping("/save") public R save(@Valid @RequestBody BrandEntity brand) { brandService.save(brand); return R.ok(); } 3.校验错误时会有默认的响应
在被校验的Bean后紧跟BindResult 可以获取校验结果
/** * 保存 * @Valid 注解告诉springmvc需要校验 * BindingResultresult 封装了校验结果 */ @RequestMapping("/save") public R save(@Valid @RequestBody BrandEntity brand, BindingResultresult) { brandService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a191d5d3df836e68ced495b263a9fbca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8781cce5ff54a3a25ecd680fbcde0b3/" rel="bookmark">
			MyBatis(三)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MyBatis的核心配置文件 在resources目录下的mybatis-config.xml文件
名称：我们可以自己定义，推荐大家使用【mybatis-config.xml】
位置：IntelliJ IDEA中通过Maven创建项目，一般都保存在src/main/resources目录下。
文件中的配置元素及其属性
MyBatis的核心配置文件是一个xml文件
文件头：&lt;?xml version="1.0" encoding="UTF-8"?&gt;
约束文件 ：&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
根元素 &lt;configuration&gt;
引入“.properties”资源文件 &lt;properties&gt;
属性：
resources： 引入资源文件应该放在（）
1.src/main/resources
如果被引入的“xxxx.properties”资源文件放在src/main/resources目录下的子文件夹中，我们应该“子文件夹名称\xxxx.properties”。
在核心配置文件中可以通过"${}"得到资源文件中的数据值。
配置MyBatis的数据库连接环境 &lt;environments&gt;
default属性:默认值是development。
数据库连接环境的配置值 &lt;environment&gt; id属性：与 &lt;environments&gt;的default属性值相同。
配置数据库的事务管理器。 &lt;transactionManager&gt;
environment的子元素type属性:指定具体的事务管理器 type属性的取值有3个 JDBC---直接使用了JDBC 的事务提交和事务回滚设置。MANAGED---不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。让其他的容器框架【Spring】来管理事务
默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。
&lt;transactionManager type="MANAGED"&gt;
&lt;property name="closeConnection" value="false"/&gt;
&lt;/transactionManager&gt;
3.NOTE--如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器， 因为Spring 模块会使用自带的管理器来覆盖前面的配置。 具体的数据源 &lt;dataSource&gt;
type属性:设置是否使用数据连接池技术
type属性的取值有3个: POOLED---使用数据连接池技术，避免了创建新的连接实例时所必需的初始化和认证时间。使得并发 Web 应用快速响应请求的流行处理方式。
UNPOOLED---不使用数据连接池技术，每次被请求时打开和关闭连接。
JNDI---使用数据连接池技术，这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8781cce5ff54a3a25ecd680fbcde0b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb640ec9634c02294a43d2729126621b/" rel="bookmark">
			pandas报错：A value is trying to be set on a copy of a slice from a DataFrame 解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pandas使用索引+列名修改元素值报错：
df.loc[0]['keywords']='key' A value is trying to be set on a copy of a slice from a DataFrame
解决办法：
使用 DafaFrameming.loc[索引,列名]=‘value’ 的方式处理：
df.loc[0,'keywords']='key' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af90fb20b52505a146a50a7d45a3065/" rel="bookmark">
			不可重复读幻读的危害复现和MySQL的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不可重复读幻读的危害复现和MySQL的解决方案 前言问题引发的纠纷解析■ 事务一致性■ 一般人的理解误区 危害复现■ 不可重复读业务例子后果 ■ 幻读的业务例子业务例子后果 mysql解决方案解决不可重复读■ 测试MySQL默认情况下的业务结果■ 图解原理 解决幻读（快照读）■ 测试MySQL默认情况下的业务结果■ 原理■ 结论 解决幻读（当前读）■ 测试MySQL默认情况下的业务结果（单列索引）■ 测试MySQL默认情况下的业务结果（无索引）■ 测试MySQL默认情况下的业务结果（组合索引）组合索引树结构图 ■ Insert改为update MySQL RR异常事务例子业务例子■ 测试RR业务结果 最后 前言 事务的隔离级别分为读未提交RU、读已提交RC、可重复读取RR、序列化。概念不必多说，随处可搜，而危害很难搜到文章描述。主要原因还是主流数据库已经帮我们处理好了这些头痛的问题，并且业务上也很难有这种需求复现，所以会的以为大家都会，不会的搜遍全网也是一头雾水。正好有空讲这个问题总结一下，让有缘人有所参考。
问题引发的纠纷 当年正好是我在调优MySQL和大表分页的一段时间，延伸开来理解些东西，也是想从实际业务出发去理解事务问题，例如不可重复读和幻读的危害。本以为一搜就能找到，但是搜来搜去，花了大半天的功夫也没得到答案，很多答案也是废话连篇，搞得相当恼火。相当早的一个网红词汇描述叫做“砖家”来描述他们。
如下
点进头像一看，企业认证阿里。这。。。再扇自己两巴掌。
然后突然间我就顿悟了，给出了答案，后面的解决方案也是有误，隔了一个多月重新回复了。
解析 ■ 事务一致性 上面这大佬跟和尚念经一样一直嘀咕事务一致性。他说的有错吗？没有错。那为什么这么让人讨厌呢？
因为事务通过原子性、隔离性、持久性来保证一致性。
什么意思呢？意思就是保证事务一致性是最终目标，它由aid来保证c，也就是说他在讲废话了。
他讲解错是因为违反了原则，危害就是违反原则。本末倒置了，应该是会发生错误而制定了原则，而错在哪却讲不出来，揪着原则不放。
■ 一般人的理解误区 为什么很多人抓破脑袋也想不出不可重复读的危害呢？
原因就是被误导了
搜索不可重复读，基本都是类似下面这个描述
不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。
这个描述有错吗？没错。错在后半句这个描述只是一个子集。正确的描述应该为
不可重复读，是指在数据库访问中，一个事务范围内两个查询的相同记录却返回了不同数据。
这样是不是就豁然开朗了，大家理解成了用一条SQL语句执行两次，而真正的业务想必不太可能会这么搞，所以一时间想不通危害。而不同的语句查到不同版本的同一条记录这是非常有可能发生的。
危害复现 沿用当年的例子，详细分析。
■ 不可重复读 业务例子 银行做活动。事务a查询某地区余额1000以下送一包餐巾纸，生成名单。事务b小明余额500，存了1000，变成1500。事务a查询1000到2000送一桶油，生成名单，这样小明收到了2个礼品。
后果 两份名单都有小明，小明很开心，偷偷地告诉了亲朋好友一起薅羊毛，行长总觉得哪里不对劲哭晕在厕所。
■ 幻读的业务例子 业务例子 银行做活动。事务a查询某地区余额1000以下送一包餐巾纸，生成名单。事务b新增了一个新用户小明，并存款500。事务a查询1000到2000送一桶油，生成名单，这样小明没有收到礼物，而同时注册的小李存了1500却收到了一桶油。
后果 小李发了个盆友圈：今天办了张卡，送了桶油，真开心。
小明：？？？退卡，我要换银行。
例子业务可能很难触发，但肯定是有概率的，以上就是不可重复读和幻读的危害。
mysql解决方案 不可重复度加入行锁;查出1000以下的名单锁住，小明存1000的操作就得等送油的名单生成，这就保证了小明不会收到两个礼品；幻读行锁无法解决，就得表锁，让新增用户等事务a结束才执行。
这是我当时最早的一个回复，非MySQL方案。有毛病吗？没毛病，错误不会发生了。但是性能大打折扣，动不动就悲观锁，用户要砸银行了。数据库要是这么搞还有人敢用吗。所以现在主流的MySQL，InnoDB引擎引入了MVCC版本号机制和Next key lock来解决这些问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8af90fb20b52505a146a50a7d45a3065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0bbf98e004870d99f6c2946f34a2310/" rel="bookmark">
			MongoDB测试案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB requires PHP 7.0 or higher.安装php扩展不在此赘述。
1.php原生MongoDB驱动：
$manager = new MongoDB\Driver\Manager("mongodb://127.0.0.1", ['username' =&gt; 'myuser', 'password' =&gt; 'mypass', 'authSource' =&gt; 'mydb']); $readPreference = $manager-&gt;getReadPreference(); $filter = ['tabid' =&gt; ['$lt' =&gt; 123]]; $options = [ 'sort' =&gt; ['_id' =&gt; 1], ]; $query = new MongoDB\Driver\Query($filter, $options); $cursor = $manager-&gt;executeQuery('mydb.mycoll', $query); //第一个参数填写不对会报错：not authorized on db;别问我怎么知道的，说多了都是泪 foreach ($cursor as $document) { print_r($document); } 2.composer 安装mongodb/mongodb第三方库
composer require mongodb/mongodb
测试代码：
require('./vendor/autoload.php'); $client = new MongoDB\Client( 'mongodb://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0bbf98e004870d99f6c2946f34a2310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8440ff8ca9dbf1bf47df0d0c5dae24a/" rel="bookmark">
			Redis的单线程和高性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的单线程 Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。
Redis 使用单线程原因 单线程编程容易并且更容易维护；Redis 的性能瓶颈不再 CPU ，主要在内存和网络；多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。 Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令；
Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ccd99fd13c5f2bf52595fc498dae1ab/" rel="bookmark">
			HTML 调用打印机打印指定区域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接上代码
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;打印页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是不打印部分&lt;/h1&gt; &lt;div class="print" style="text-align:center; margin-top: 30px"&gt; &lt;div id="printArea"&gt; &lt;div&gt;......文本打印区域......&lt;/div&gt; &lt;div&gt;......文本打印区域......&lt;/div&gt; &lt;div&gt;......文本打印区域......&lt;/div&gt; &lt;div&gt;......文本打印区域......&lt;/div&gt; &lt;div&gt;......文本打印区域......&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;input type="button" media="print" value="打印" onclick="printArea()"&gt; &lt;input id="btnPrintFull" type="button" value="全屏打印"&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function printArea(){ //设置body隐藏，并设置打印区域为可见 document.body.style.visibility='hidden'; document.getElementById('printArea').style.visibility='visible'; window.print(); location.href='打印测试.html' return false; }&lt;/script&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce1368c1fb567a6073dd0f0a513a08c/" rel="bookmark">
			yum: command not found-服务器安装yum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新购买的云服务器默认是没有安装yum的，python默认也是2.0+的版本，这就让很多初学者难以安装各类服务，但是服务器默认会安装apt-get，
这时候可以更新下版本
sudo apt-get update 然后直接安装yum即可
sudo apt-get install yum 重点说明：注意你的系统是centos还是Ubuntu，Ubuntu是不支持yum的，可以直接用wget！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e6f8ff4a47f48b81eb3fb5eb2ead19/" rel="bookmark">
			Unity中访问 URL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、第一种：使用URL直接连接 将此连接方法写在需要连接的时候即可，比如下面写在Button点击事件里；这种方式是跳出unity打开浏览器
public void ConnectUrl() { Application.OpenURL("http://www.baidu.com"); } 二、第二种：使用www访问URL VS显示www已过时
这种方式是跳出unity打开浏览器
public void ConnectUrl() { WWW www = new WWW("http://www.baidu.com");//外部HTML和本地HTML都可 Application.OpenURL(www.url); } 三、第三种：使用UnityWebRequest 访问URL 这种方式是跳出unity打开浏览器
浏览器HTML //新版UnityWebRequest public void ConnectUrl1() { UnityWebRequest unityWebRequest = new UnityWebRequest("https://www.csdn.net/"); Application.OpenURL(unityWebRequest.url); } 本地HTML //使用绝对路径 public void ConnectUrl1() { UnityWebRequest unityWebRequest = new UnityWebRequest("file:///F:/a/b/c/d/Assets/Vuplex/WebView/Documentation/index.html"); Application.OpenURL(unityWebRequest.url); } //使用相对路径 public void ConnectUrl2() { UnityWebRequest unityWebRequest = new UnityWebRequest(Application.dataPath + "/Resources/index.html"); Application.OpenURL(unityWebRequest.url); } ./是当前目录. ./是父级目录/是根目录 四、第四种：使用Embedded Browser插件 这种方式是在unity里打开URL
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22e6f8ff4a47f48b81eb3fb5eb2ead19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba22dfc88d25b75db5b9820f4242705/" rel="bookmark">
			unity列表，水平，垂直，循环滚动列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建垂直滑动列表 在canvas下创建Scroll View，取消勾选 Scroll View 的 Horizontal 属性，并删除Scroll View子物体 Scrollbar Horizontal(只创建垂直滑动列表)
给Content添加 Veritical Layout Group和Content Size Fitter组件
将列表中需要显示的物体添加到Content中
批量生成滑动列表的内容
using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; /* * 脚本挂载在Scroll View上 */ public enum ScrollDir { BottomToTop = 1, TopToBottom = 2, LeftToRight = 3, RightToLeft = 4 } public class GenerateSlidingList : MonoBehaviour { public Button itemPrefab;//要添加到列表的预设体按钮 public Transform contentTransform;//容器Content public Scrollbar scrollbar;//滑动条,Hierarchy面板上的Scrollbar Vertical public VerticalLayoutGroup layoutGroup;//Content上的Vertical Layout Group组件 List&lt;Button&gt; lists = new List&lt;Button&gt;();//按钮列表，用于存放按钮组件 string[] array = new string[] { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ba22dfc88d25b75db5b9820f4242705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b41df3a61fc00a04d295de938f96733e/" rel="bookmark">
			libcurl CURLOPT_WRITEFUNCTION注意事项(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NAME CURLOPT_WRITEFUNCTION - set callback for writing received data
SYNOPSIS DESCRIPTION Pass a pointer to your callback function, which should match the prototype shown above.
This callback function gets called by libcurl as soon as there is data received that needs to be saved. ptr points to the delivered data, and the size of that data is size multiplied with nmemb.
The callback function will be passed as much data as possible in all invokes, but you must not make any assumptions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b41df3a61fc00a04d295de938f96733e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d6e79ff7e63f67ac60ed2014ca69ee/" rel="bookmark">
			xshell6和xftp6安装后无法打开提示升级到最新版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Xshell 6 提示 “要继续使用此程序,您必须应用最新的更新或使用新版本” 解决办法：
使用二进制编辑器 UltraEdit 修改nslicense.dll文件
文件位置：xshell 安装根目录
具体步骤
步骤1：下载UltraEdit编辑器
步骤2：使用UltraEdit编辑器打开nslicense.dll文件
步骤3：搜索“7F 0C 81 F9 80 33 E1 01 0F 86 81”
步骤4：修改“86”为“83”
步骤5：保存文件 重新打开xshell发现已经可以使用
二、安装xftp6后，在xshell6上快捷使用xftp也是报错 同上将 xftp6根目录中的nslicense.dll文件打开搜索“7F 0C 81 F9 80 33 E1 01 0F 86 81”改“86”为“83”即可使用
参考文章 http://t.zoukankan.com/haolb123-p-14915346.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfac82f16cc6e155d480a0de7f005fd/" rel="bookmark">
			RPC框架实战之手写RPC框架 第四章 个人总结复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四章 增加Kryo序列化器，上一章中使用JSON序列化器有一个问题，就是如果反序列化的是对象中有Object类型的属性，反序列化会出错，通常会把Object属性直接反序列化为String类型，因此还需要其他参数辅助序列化，并且JSON序列化器是基于字符串（JSON串）的，占用空间大并且速度慢。
Kryo是一个快速高效的Java对象序列化器，特点就是高性能、高效、易用。它是基于字节的序列化，对空间利用率高，在网络传输时可以减小体积，并且在序列化时记录属性对象的类型信息，因此在反序列化时不会出现类型错误的情况。
引入依赖 需要引入Kryo依赖
&lt;dependency&gt; &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt; &lt;artifactId&gt;kryo&lt;/artifactId&gt; &lt;version&gt;4.0.2&lt;/version&gt; &lt;/dependency&gt; 这里把Kryo作为默认的序列化器来使用，这里使用过switch的方式根据用户传入的编号返回对应的序列化器，这样其实不太友好，如果序列化器多的话，用户还要记忆每个序列化器对应的编号，后续可能会优化序列化器的使用方式。
public interface CommonSerializer { byte[] serializer(Object object); Object deserialize(byte[] bytes, Class&lt;?&gt; clazz) throws Exception; int getCode(); static CommonSerializer getByte(int code) { switch (code) { case 0: return new KryoSerializer(); case 1: return new JsonSerializer(); default: return null; } } } KryoSerializer 接下来就是序列化器的实现了
public class KryoSerializer implements CommonSerializer { private static final Logger logger = LoggerFactory.getLogger(KryoSerializer.class); /** * 因为kryo不是线程安全的，因此多线程的情况下可以考虑使用ThreadLocal或者池化 */ private static final ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bfac82f16cc6e155d480a0de7f005fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/275ff89ea21b3ec90c44efeaefd9b89a/" rel="bookmark">
			RPC框架实战之手写RPC框架 第三章 个人总结复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 使用Netty传输数据，使用效率更高的Nio方式传输数据，因为原先使用的是传统BIO方式，现在为了支持Netty方式，需要抽象出接口，增加扩展性，这样也满足了设计模式六大原则中的依赖倒置原则。
抽象为接口 RpcServer和RpcClient抽象为接口
NettyServer实现RpcServer，NettyClient实现RpcClient
public interface RpcClient{ Object sendRequest(RpcRequest rpcRequest); } public interface RpcServer{ void start(int port); } 导入Netty的依赖 &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.70.Final&lt;/version&gt; &lt;/dependency&gt; NettyServer类 public class NettyServer implements RpcServer { private static final Logger logger = LoggerFactory.getLogger(NettyServer.class); /** * 启动并监听对应的端口，等待客户端的连接并处理数据 * * @param port */ @Override public void start(int port) { NioEventLoopGroup bossGroup = new NioEventLoopGroup(); NioEventLoopGroup workGroup = new NioEventLoopGroup(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/275ff89ea21b3ec90c44efeaefd9b89a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/798bbe1ffbdacc40a513689d932e9f95/" rel="bookmark">
			Metashape导出深度图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Metashape在生成模型的时候会在工程目录下生成“depth_maps”文件夹，里面有“data0.zip”、“data1.zip”、…，但是我们自己并不熟悉其中数据组成的情况，难以直接使用，需要Python脚本来实现。详情参考：Exporting depth maps
脚本来源于Exporting depth maps
这里也粘贴出其源码 ，脚本命名为“export_depth_maps_dialog.py”
# Exports depth map of each camera. # # This is python script for Metashape Pro. Scripts repository: https://github.com/agisoft-llc/metashape-scripts import Metashape from PySide2 import QtGui, QtCore, QtWidgets try: import numpy as np except ImportError: print("Please ensure that you installed numpy via 'pip install numpy' - see https://agisoft.freshdesk.com/support/solutions/articles/31000136860-how-to-install-external-python-module-to-metashape-professional-package") raise class ExportDepthDlg(QtWidgets.QDialog): def __init__ (self, parent): QtWidgets.QDialog.__init__(self, parent) self.setWindowTitle("Export depth maps") self.btnQuit = QtWidgets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/798bbe1ffbdacc40a513689d932e9f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae240edf09d313c2c5fbbb070247146/" rel="bookmark">
			问题PermissionError [Errno 13] Permission denied解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题:PermissionError: [Errno 13] Permission denied: … 原因：设置的Path没有文件，只是目录 解决方法：去找自己设置的Path底下是否还有一层文件夹 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba193f5b9cd290f96aa253dc705026ad/" rel="bookmark">
			windows动态库和静态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梳理下项目中常用的动态库、静态库使用方式。
静态库 静态库工程生成一个静态库lib文件。
参考文献6制作lib后，有三种方式去使用：
使用comment 显式调用，这样不用在visual studio 链接器-&gt;输入-&gt;附件依赖库里面配置依赖库，由于没有指定依赖库路径所有需要显示填写路径。使用comment 显式调用，同时需要在链接器-&gt;常规-&gt;附加库目录中配置依赖库路径。由于使用了comment所以不用在visual studio 链接器-&gt;输入-&gt;附件依赖库里面配置。隐式调用，需要在链接器-&gt;常规-&gt;附加库目录中配置依赖库路径，同时在链接器-&gt;常规-&gt;附加库目录中配置依赖库路径。 #include &lt;iostream&gt; #include "Mylib.h" // 工程配置里面设置头文件包含路径 //#pragma comment(lib,"../Debug/staticlib.lib") // 指定路径，当前路径为vcxproj文件所在路径 //#pragma comment(lib,"staticlib.lib") //工程配置里面可以配置，就可以不填写路径了;(链接器附加库目录中配置) // 可以在visual studio里面配置 using namespace std; int main(int argc, char **argv) { STATIC_LIB::PrintHello(); system("pause"); return 0; } 动态库 动态库工程生成一个引入库lib文件和dll文件。对一个DLL文件来说，其引入库文件（.lib）包含该DLL导出的函数和变量的符号名，而.dll文件包含该DLL实际的函数和数据。动态库的引入库文件和静态库文件有着本质的区别。
代码里面设置导出符号：
//MyLib.h #pragma once #ifndef _STATIC_LIB_H_ #define _STATIC_LIB_H_ #include &lt;iostream&gt; namespace STATIC_LIB { extern "C" __declspec(dllexport) void __cdecl PrintHello(); } #endif // MyLib.cpp #include "MyLib.h" extern "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba193f5b9cd290f96aa253dc705026ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50992d1c344ddbef356639aba556bf97/" rel="bookmark">
			cpp模板总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结下c++模板相关的基础知识，便于查阅。
模板： 模板定义以关键字template开始，后跟一个模板参数列表，这是一个逗号分隔的一个或者多个模板参数的列表，用小括号和大括号包围起来。
模板是个半成品，模板编译通过但是使用错误仍然会报错；
可以将模板看作是编译期函数；
运行期函数的参数要为一个对象（不能是模板）；编译期函数的参数可以是模板；
声明： 模板声明必须包含模板参数：
// 声明但是不定义compare和Blob template&lt;typename T&gt; int compare(const T&amp;, constT&amp;); template&lt;typename T&gt; class Blob; 与函数参数相同，声明中的模板参数的名字不必与定义中相同，但是一个给定模板的声明和定义必须有相同数量和种类的参数：
//声明 template&lt;typename T&gt; T calc(const T&amp;, const T&amp;); template&lt;typename U&gt; U calc(const U&amp;, const U&amp;); // 定义 template&lt;typename Type&gt; Type calc(const Type&amp; a, const Type&amp; b) { /*...*/ } 以上三个calc都指向相同的函数模板。
函数模板： template&lt;typename T&gt; void Swap(T&amp;a, T&amp;b) { T tmp; tmp = a; a = b; } 上边就定义了一个变量交换的函数模板，在使用函数模板时有两种方式:
int a = 10, b = 20; Swap(a, b) // 自动类型推导调用 Swap&lt;int&gt;(a, b) // 指定类型显式调用 在调用一个函数模板时，编译器用函数实参来为我们推断模板实参，在调用Swap时，编译器使用实参的类型来确定绑定到模板参数T的类型，这里编译器会推断出模板的实参为int，并将它绑定了模板参数T。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50992d1c344ddbef356639aba556bf97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd08b33f6dacd178239b07a879a54f90/" rel="bookmark">
			静态变量初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态变量的初始化分为两个过程，一个是静态初始化，一个是动态初始化。
静态初始化在系统加载后执行第一条语句之前就已经完成。所以，可以认为所有的静态初始化过程是同步完成的。
动态初始化，则在main函数之前完成，对于同一个编译单元内的静态变量，动态初始化顺序等同于定义顺序，而对于跨编译单元的静态变量，初始化顺序未定义。
静态数据有两种：已初始化数据和未初始化数据。
在映像文件里,它们分别被放入 data 段和 bss段。只有 data 段的已初始化的数据才会真正被放入映像文件。
int a=5;//data 段 int b; //bss 段 一个静态定义的对象，却永远会被放在 bss 段，无论是否用初始化表达式。
Foo a; // bss 段 Foo b = Foo(); // bss 段 这是因为，对象的初始化依靠其构造函数的执行，所以一个对象的初始值是无法在编译时确定的。
静态对象被放在 bss 段，加载时首先被清零。
然后，程序在进入 main 函 数之前，静态对象的构造函数会被调用。
但跨编译单元的静态变量的初始化顺序是未定义的。
#include &lt;iostream&gt; using namespace std; struct MyHello { MyHello() { cout&lt;&lt;"MyHello"&lt;&lt;endl; } }; int hello() { //调用了hello函数后才初始化; static MyHello myHello; return 0; } struct Hello { Hello() { cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd08b33f6dacd178239b07a879a54f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/143cb68f280a1c0f2df476681b50b7fd/" rel="bookmark">
			C&#43;&#43;中将字符串转换为数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中将字符串转换为数字
法一：
int t = s[len - 1]-'0';//减去一个 '0' 是 将最后一位字母转换成数字 例如：这个判断基偶性就是为了防止越界所以将数组转换为数组传入，再将最后一位字母转换位数字判断其基偶性
#include&lt;iostream&gt; using namespace std; int main() { int n; cin &gt;&gt; n; string s; while (n--) { cin &gt;&gt; s; int len = s.length(); int t = s[len - 1]-'0';//减去一个 '0' 是将最后一位字母转换成数字 if (t % 2 == 0) { cout &lt;&lt; "even" &lt;&lt; endl; } else cout &lt;&lt; "odd" &lt;&lt; endl; } } 法二：
#include&lt;iostream&gt; #include&lt;cstdlib&gt; using namespace std; int main() { int n; double db; n = atoi("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/143cb68f280a1c0f2df476681b50b7fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe98a24fa2267e9af9e158441dcceaf/" rel="bookmark">
			从键盘输入一个字符串，分别统计其中的字母，数字和其他字符的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 printf("请输入一个字符串\n"); char a[100]; int num1 =0,num2 =0,num3 = 0; gets(a); for (int i = 0;a[i]!='\0'; i++){ if (a[i] &gt; '0'&amp;&amp;a[i] &lt; '9') num1++; else if ((a[i] &gt;='a'&amp;&amp;a[i]&lt;= 'z') ||(a[i] &gt;= 'A'&amp;&amp;a[i]&lt;='Z')) num2++; else num3++; } printf("数字个数是%d,字母个数是%d，其他字符的个数是%d\n", num1, num2, num3); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e9d1500b134eb999b2f0150ca295ad0/" rel="bookmark">
			Linux C 基于epoll的多人聊天室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确认需求 实现的功能包含
1、私聊
2、群聊
3、打印在线信息
4、退出系统
需要注意 1、service中不能有重复名
2、发送的消息，如果对方不存在服务器需要给客户端返回错误信息
3、其他需要实现的功能，文件传输，聊天记录保存可根据自己完善。
4、代码只供参考阅读，一些可能存在的bug需要自己去修改
特此申明 作者自己本身也会进行完善代码和功能，对代码有问题，有更好想法的朋友欢迎评论区留言！！！希望共同学习，一起进步！
源码 头文件（也没封装啥，只是偷个懒，养成好习惯） epoll_service_test.h #ifndef NETWORK_EPOLL_SERVICE_TEST_H #define NETWORK_EPOLL_SERVICE_TEST_H #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;pthread.h&gt; #include &lt;sys/epoll.h&gt; #include &lt;string.h&gt; #include &lt;ctype.h&gt; #include &lt;stdlib.h&gt; #endif //NETWORK_EPOLL_SERVICE_TEST_H 服务器 epoll_service_test.c #include "epoll_service_test.h" #define MAX 1024 //定义消息结构体 typedef struct message{ char type;//消息类型 char name[30];//客户端姓名 char dst_name[30];//目的客户姓名 char text[MAX];//消息内容 }MSG; MSG msg;//定义全局消息变量进行消息的接收和发送 //定义存储客户端信息链表 typedef struct client_list{ char name[30];//客户端的姓名 int cfd;//对应的在树上的套接字 struct client_list *next; }linklist,*linkList ; //定义头节点，设置为全局变量 linkList H; //创建头节点函数 linkList head_init(){ linkList h=(linkList)malloc(sizeof(linklist)); bzero(h,sizeof(linklist)); h-&gt;next=NULL; return h; } //创建结点插入函数 void insert_client(linkList H,MSG msg,int cfd){ linkList p=(linkList)malloc(sizeof(linklist)); bzero(p,sizeof(linklist)); strncpy(p-&gt;name,msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e9d1500b134eb999b2f0150ca295ad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ed6c87c7325b8fb79425a21d276e329/" rel="bookmark">
			SNMP(简单网络管理协议)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SNMP的概述
1、网络管理协议简称为网管协议。
2、网络管理协议是管理程序和代理程序之间进行通信的规则。
3、网络管理员利用网络管理协议，通过管理站对网络中的被管设备进行管理。
4、需要注意的是，网管协议本身不管理网络。
二、SNMP的工作形式
1、简单网络管理协议SNMP中的管理程序和代理程序按客户——服务器方式工作。
管理程序运行SNMP客户程序，向某个代理程序发出请求(或命令) ,代理程序运行SNMP服务器程序，返回响应(或执行某个动作)。
在网管系统中，往往是一个(或少数几个)客户程序与很多的照务器程序进行交互。如下图所示：
三、SNMP的管理功能
1、“读”操作，用get报文来检测各被管对象的状况。
2、“写” 操作，用set报文来改变各被管对象的状况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a19e7f6ea4366d6c11b84f293177241/" rel="bookmark">
			刚毕业的表弟年薪40w......程序员薪资天花板？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前不久，“腾讯2022校招-应届毕业生年薪 40 万”刷屏了…
尽管互联网大厂的薪资高不算什么新鲜事儿，但这个热搜仍然让我大受震撼。
腾讯校招官网显示，2022届腾讯校招开放技术、产品、设计等岗位共计 78 个，且以IT岗为主。
另据各大招聘平台统计数据，腾讯2022届研发岗应届生基础月薪在1.7万-2.3万之间，签字费（针对优秀人才的额外奖励）3万，股票依据不同等级从6万到20万不等，就算是最低等级的“白菜包”，年薪总包也远超40万元。
职业发展 作为一个代码打工仔，对于绝大部分程序员来说，想要成为牛逼的真正挣钱程序员的路还很长，一刻都不能懈怠。
我们无法从HR角度，或者技术leader的角度来臆测哪种状态的面试更能获取面试官青睐。但通过我们积攒的大量的面试经验，大家多少可以推断一些成为有竞争力的程序员的一些必要条件。
大佬云集、资料丰富 当初我在字节认识一个非常非常资深的前辈，他到字节比我早三年，但因为各种原因级别不是很高。我当时问他，既然你对现状如此不满，为什么不想着离开寻找更好的机会呢？
他沉思了片刻跟我说，他说我现在在这里虽然待着不顺心，但是我接触到的人都是非常优秀的。我遇到问题，还可以和你们讨论讨论。我如果出去了，我要是再遇到问题，可能连一个讨论的人都没有。
我当时听听只是觉得有道理，现在再回想起来，感受非常深刻。三观、格局、能力，能够进入大公司的，这三个方面一般都不会太差。别的不说，就拿个人能力而言，我曾出国出差过几个月，有幸见识了许多各种海外名校的同事，和他们学习交流人工智能，这真的让我AI有了更深层次的认识。
除了优秀的同事之外，大公司里往往还有丰富的内部文档和资料。我当时在字节内部看到了很多优秀的文章，也有很多优秀的技术沙龙和分享。现在想起来两年下来，也没有去过几次，文章和资料看得也不算多，现在想想颇为遗憾。别的不说，就拿推荐领域而言，近些年质量不错的论文往往都来源于大公司尤其是国内的大公司，以腾讯、华为和头条为主。除了公开的论文，公司内部还有很多技术相关的资料和文档，这些真的可以说是有价无市，非常珍贵。
文中所展示的资料全部都是免费分享，扫一扫下方CSDN官方认证微信二维码即可【保证100%免费】 Python 知识手册
Linux 知识手册
爬虫查询手册
而且，这些资料不是扫描版的，里面的文字都可以直接复制，非常便于我们学习：
数据分析知识手册：
机器学习知识手册：
金融量化知识手册：
岗位内推、学习交流 我们大量需要前端岗位、python岗位、Java 岗位、Android 和 iOS 的开发岗位，工作地点：北京字节，欢迎校招社招扫描下方二维码找我内推
如果你觉得自己学习效率低，缺乏正确的指导，可以加入资源丰富，学习氛围浓厚的CSDN官方技术圈一起学习交流吧！
Python资料、技术、课程、解答、咨询也可以直接点击下面名片，添加官方客服斯琪↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78e5899bf0e2c9214de57fc902bbd57f/" rel="bookmark">
			C&#43;&#43;： 情侣最美身高差（团体程序设计天梯赛）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目概述：
专家通过多组情侣研究数据发现，最佳的情侣身高差遵循着一个公式：（女方的身高）×1.09 =（男方的身高）。如果符合，你俩的身高差不管是牵手、拥抱、接吻，都是最和谐的差度。
下面就请你写个程序，为任意一位用户计算他/她的情侣的最佳身高。
输入格式：
输入第一行给出正整数N（≤10），为前来查询的用户数。随后N行，每行按照“性别 身高”的格式给出前来查询的用户的性别和身高，其中“性别”为“F”表示女性、“M”表示男性；“身高”为区间 [1.0, 3.0] 之间的实数。
输出格式：
对每一个查询，在一行中为该用户计算出其情侣的最佳身高，保留小数点后2位。
编程：
#include&lt; iostream&gt;
using namespace std;
int main()
{
int n;
cin &gt;&gt; n;
char a;
double h;
for (int i = 0; i &lt; n; i++)
{
cin &gt;&gt; a &gt;&gt; h;
if (a == ‘F’)
printf("%0.2f\n", h * 1.09);
else
printf("%.2f\n", h / 1.09);
}
}
上机实践：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf061166d7384b0c569ea08087ec6e7/" rel="bookmark">
			snmp弱口令及安全加固
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		snmp弱口令及安全加固 弱口令检测
nmap –sU –p161 –script=snmp-brute ip //查找snmp弱口令 弱口令利用
nmap -sU -p161 --script=snmp-netstat ip//获取网络端口状态 nmap –sU –p161 –script=snmp-sysdescr ip //获取系统信息 nmap -sU -p161 --script=snmp-win32-user ip //获取用户信息 其他利用方式
snmputil walk ip public .1.3.6.1.2.1.25.4.2.1.2//列出系统进程 snmputil walk ip public.1.3.6.1.2.1.25.6.3.1.2 //列出安装的软件 snmputil walk ip public .1.3.6.1.2.1.1 //列出系统信息 snmputil get ip public .1.3.6.1.4.1.77.1.4.1.0 //列出域名 snmputil walk ip public.1.3.6.1.4.1.77.1.2.25.1.1 //列系统用户列表 安全加固
定位：通过存在snmp弱口令的端口，定位进程ID和进程名 判断：通过开放该服务的运行进程，判断这个进程是否和业务相关，是否需要 对外提供服务，只对哪些远程主机提供服务。 配置：若判断的结果与业务不相关，是没有用处的服务。则关闭端口，kill PID简单暴力没烦恼；若判断的结果与业务有关，服务不能关闭。那就去除弱口令+白名单；若判断的结果与业务相关，服务不能关闭，且弱口令还不能修改，那就白名单控制; 配置口令
windows 方法1： 开始—&gt;程序—&gt;管理工具—&gt;服务—&gt;SNMPService—&gt;属性—&gt;安全 1.修改社区名称(snmp密码) 2.配置白名单 重启服务 方法2： 开始- &gt; 运行- &gt; regedit 打开注册表 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdf061166d7384b0c569ea08087ec6e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8db117c0e9d31ebe9c3a0ea1759f876/" rel="bookmark">
			k8s安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在以下网页中搜索nginx kubebiz官方地址
2.找到yaml后选择版本，并调整yaml配置 可以用以上的yaml，注意命名空间要改成自己的
也可以使用下面的json
{ "apiVersion": "apps/v1", "kind": "Deployment", "metadata": { "name": "nginx", "namespace": "命名空间", "labels": { "env": "test", "name": "nginx" } }, "spec": { "replicas": 1, "selector": { "matchLabels": { "env": "test", "name": "nginx" } }, "template": { "metadata": { "name": "nginx", "labels": { "env": "test", "name": "nginx" } }, "spec": { "containers": [ { "name": "nginx", "image": "nginx:1.17.9" } ] } } } } 3.打开k8s仪表盘，创建nginx 也可以使用命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66faed5622c73a6e6030574d2865cd3e/" rel="bookmark">
			python 获取Ctrl&#43;c 信号并处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import signal # 自定义信号处理函数 def my_handler(signum, frame): global stop stop = True print("终止") # 设置相应信号处理的handler signal.signal(signal.SIGINT, my_handler) #读取Ctrl+c信号 # signal.signal(signal.SIGHUP, my_handler) # signal.signal(signal.SIGTERM, my_handler) stop = False while True: try: #读取到Ctrl+c前进行的操作 if stop: # 中断时需要处理的代码 break #break只能退出当前循坏 #中断程序需要用 raise except Exception as e: print(str(e)) break 补充：
键盘和shell的交互：
Ctrl-c Kill foreground process 常用 ;送SIGINT信号，默认进程会结束，但是进程自己可以重定义收到这个信号的行为。
Ctrl-z Suspend foreground process;送SIGSTOP信号，进程只是被停止，再送SIGCONT信号，进程继续运行。
Ctrl-d Terminate input, or exit shell 常用 有时也会使程序退出，例如没有参数的cat命令，从终端读一行显示一行，知道Ctrl+D终结输入并终结进程;不是发送信号，而是表示一个特殊的二进制值，表示 EOF。
Ctrl-s Suspend output
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66faed5622c73a6e6030574d2865cd3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83868ad02c23069b0a48671d35bd547a/" rel="bookmark">
			对话状态最追踪(DST)相关方法和论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Open Vocabulary-based DST 基于开放词表的状态解码器直接从对话中找出或者生成槽值 运行在MultiWOZ 2上的Open Vocabulary-based DST模型，包括TRADE、DSTreader、COMER、NADST、ML-BST等等
一般思想是运行autoregressive generation算法来生成槽值。
TRADE模型体现了encoder-decoder framework的潜力，但在计算上效率不高，因为它在每一turn为全部slots生成values。
COMER模型通过使用hierarchical decoder，一定上解决了TRADE的上述缺陷。hierarchical decoder，层次堆叠的解码器，以分层的方法解码domains, slots, and values，把当前轮对话状态本身生成为target sequence。此外，它们第一次提出了ICT的概念，以衡量不同DST模型对话状态预测的efficiency。COMER同样在slot values子集上生成，但是由于没有利用上一轮的对话状态信息，所以性能还是不如我们的模型。
DSTreader将DST建模为阅读理解任务，提出了DST Reader模型，从输入中提取槽值。 由于DST需要跟踪abstractive values as well as extractive ones，因此它们的完全提取方法受到限制。 在DST中加入一个槽位携带模块（slot carryover module），对是否将槽位的值从先前的对话状态转移到当前的对话状态做出二值决定，这个概念很重要。也相当于加入是否update的判断。
DS-DST企图结合使用Open Vocabulary和fixed Vocabulary，结果却依然在fixed-vocabulary based DST上转圈圈。
NADST和ML-BST的模型比较有争议，这里略过。
span 抽取式 DST 基于文本跨度（text span）的解码器，通过在对话历史文本中选取子序列的方式，直接从对话历史中抽取槽值。
将对话文本序列 看作一段篇章（passage），针对每一个槽位 ，构建一个问题（question）去询问当前对话中的某一个槽位的槽值是什么，如“what is the value for slot i?”； 若状态操作类型为 ，则从对话中选取子序列的开始位置和结束位置，得到的子序列即为槽值。 混合方法 使用两种状态解码器分别处理可枚举槽位和不可枚举槽位。DSTC8，平安人寿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed6d78f42e8725c35973aca27a04234/" rel="bookmark">
			unity从物品栏拖出物体，安装到指定位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从物品栏拖出物体，安装到指定位置 一、创建垂直滑动列表-物品栏二、从物品栏拖出物体三、左键移动物体+近距离安装 一、创建垂直滑动列表-物品栏 二、从物品栏拖出物体 创建Resources文件夹，在Resources文件夹下创建Prefabs文件夹将要生成的实例物体放入Prefabs文件夹里增加一个Button和Image在Button下添加代码，str写实例名字，image选择合适的Image代码如下 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; /* * 左键从UI处拖出生成物体 */ public class DragSpawn : MonoBehaviour, IPointerDownHandler { public string str;//Resources文件夹下物体的名字 public Image image;//拖动之后的形状，删掉image即是无形状 private GameObject objDragSpawning;//正在拖拽的物体 private bool isDragSpawning = false;//是否正在拖拽 private void Start() { image.enabled = false;//开始image不显示 } void Update() { if (isDragSpawning) { //刷新位置 Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);//发出从摄像机到点击坐标的射线 objDragSpawning.transform.position = ray.GetPoint(10);//ray.GetPoint(distance)沿着射线在distance距离单位的点 //拖动时的image image.enabled = true; image.transform.position = Input.mousePosition; //拖动物体在鼠标为松开时不显示 objDragSpawning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed6d78f42e8725c35973aca27a04234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aafdae58473a7c861cd576c8b5c3c924/" rel="bookmark">
			Rust 闭包fn,Fn,FnMut,FnOnce 和move关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		struct ABC&lt;B,C,D&gt; where B: Fn(),	//可以捕获 引用 C: FnMut(),	//可以捕获 可变引用 D: FnOnce()	//可以捕获 移动 { A:fn(),//不能捕获环境 B:B, C:C, D:D, } fn main() { let mut a=String::from("aaa"); let mut f = ABC{ A:||{ // println!("{}",&amp;a);//报错,fn类型不能捕获环境 }, B:||{ // println!("{}",&amp;a);//aaa }, C:||{ // let a=&amp;mut a; // *a = String::from("bbb"); }, D:||{ a;//所有权移动进函数 }, }; println!("{}",a);//报错,没有所有权 } 作为参数
fn f&lt;F&gt;(f:F) where F:Fn() { f(); } fn main() { f(||{}); } 作为返回值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aafdae58473a7c861cd576c8b5c3c924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e494bacb298d6fec9f8ddc72dd6f8b/" rel="bookmark">
			2020第十一届蓝桥杯大赛软件类国赛 C/C&#43;&#43; 大学 B 组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成绩是国二中游，赛场上填空题写了第1,2,5题，第2题大意错了，编程题写了第7，8，10题，第7题对了样例，后两题不知道可以对多少，总分有50左右吧。
试题 A: 美丽的 2 本题总分：5 分
【问题描述】
小蓝特别喜欢 2，今年是公元 2020 年，他特别高兴。
他很好奇，在公元 1 年到公元 2020 年（包含）中，有多少个年份的数位中包含数字 2？
签到题。答案563
#include&lt;cstdio&gt; using namespace std; int n,m,ans; int main() { int i,j; for(i=1;i&lt;=2020;i++){ j=i; while(j){ if(j%10==2){ ans++; printf("%d ",i); break; } j/=10; } } printf("\n%d",ans); return 0; } //563 试题 B: 扩散 本题总分：5 分
【问题描述】
小蓝在一张无限大的特殊画布上作画。
这张画布可以看成一个方格图，每个格子可以用一个二维的整数坐标表示。
小蓝在画布上首先点了一下几个点：(0, 0), (2020, 11), (11, 14), (2000, 2000)。
只有这几个格子上有黑色，其它位置都是白色的。
每过一分钟，黑色就会扩散一点。具体的，如果一个格子里面是黑色，它就会扩散到上、下、左、右四个相邻的格子中，使得这四个格子也变成黑色（如果原来就是黑色，则还是黑色）。
请问，经过 2020 分钟后，画布上有多少个格子是黑色的。
我的是bfs从四个点搜索的，看网上大部分的答案不是这个：11157392。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8e494bacb298d6fec9f8ddc72dd6f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbcea887f7211eb08ece716a1b1a277f/" rel="bookmark">
			【计算机组成原理】动态RAM（DRAM）的三种刷新方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态RAM共有三种刷新方式：集中刷新，分散刷新，异步刷新
刷新的实质：先将原信息读出，再由刷新放大器形成原信息重新写入的再生成的过程
为什么要进行刷新：存储单元被访问是随机的，有些存储单元可能长时间的不被访问，不进行存储器的读写操作，其存储单元内的原信息就可能会丢失。
刷新是一行行进行的，必须在刷新周期内
刷新周期：对DRAM的所有存储单元恢复一次原状态的时间间隔
刷新间隔：两次刷新的起始时间差（某行从第一次刷新到第二次刷新的等待时间）
行刷新间隔：两行刷新的起始时间差
刷新时间：规定的一个周期内刷新的总时间
刷新一行的时间是等于存取周期的。因为刷新的过程与一次存取相同，只是没有在总线上输入输出。
集中刷新 集中刷新：在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新（用专门的时间进行全部刷新）
例对128×128的矩阵的存储芯片进行刷新，存储周期为0.5μs，刷新周期为2ms（再刷新到这里）
刷新：是对信息读出再写入 所以所需要的时间也是0.5μs
2ms的刷新周期，占得存取周期个数为：
2000μs÷0.5μs=4000（个）
共有128行要进行刷新，则刷新占128个存取周期，则刷新的时间为：
128×0.5μs=64μs
读写或维持的时间：
2000μs-64μs=1936μs
读/写或维持的存储周期为：
4000-128=3872（个）
当用64μs进行集中刷新是，此时不能进行任何的读/写操作，故将这64μs称为“死区”或“死时间”
“死时间”所占的比率也称为“死时间率”
则集中刷新的“死时间率为”
128÷4000×100%=3.2%
优点：速度高
缺点：存在死区，死时间长
分散刷新 分散刷新：是指对每行存储单元的刷新分散到每个存储周期内完成（对某一行某芯片进行读写操作后，紧接着刷新 包含在了读写周期内）
例：对128×128的矩阵的存储芯片进行刷新，读/写周期为0.5s（读一次或写一次），
将刷新分散到存储周期内完成 ，则存储周期就包含了刷新时间
此时，存储周期（存储器进行两次独立的存储器操作 读或写）为
t=0.5μs+0.5μs=1μs
刷新（刷新以行算）一行的时间为1μs，全部刷新完的时间为：
128×1μs=128μs
此时比2ms小的多 在刷新到此处隔128μs
优点：无死区
缺点：存取周期长，整个系统的速度降低了
异步刷新 异步刷新：前两种方式的结合，缩短了死时间，充分利用了最大刷新间隔为2ms的特点（只要在2ms内对这一行刷新一遍就行）
例：对128×128的矩阵的存储芯片进行刷新，存储周期为0.5s，刷新周期为2ms
2ms内对每行刷新一遍：
2000μs÷128≈15.6μs
即每隔15.6μs刷新一行，每行的刷新时间仍然为0.5μs。刷新一行就停一个存储周期，“死时间缩短为0.5μs”（15.6μs内刷新一行 其他全用来读写）
这种方案克服了分散刷新许独占0.5μs用于刷新，使存取周期加长且降低系统速度的缺点，又不会出现集中刷新的访问“死区”问题，从根本上提高了工作效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b7af1397deb73b82873e9b20f0a855c/" rel="bookmark">
			强化学习中的两种探索-平衡策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		强化学习中的两种探索-平衡策略 ε-greedy方法UCB（Upper Confidence Bound）方法 为了解决强化学习中的一个经典问题：exploration and exploitation tradeoff 即：到底我们应该花精力去探索从而对收益有更精确的估计，还是应该按照目前拥有的信息，选择最大收益期望的行为？
这样看上去可能不好理解，一个小例子帮助理解:
假如你想在淘宝上买一本书，你一输入书的名字就看到，第一个链接的价格为10元，第二个链接为9.9元，第三个为11元，此时你有两个选择，直接买9.9元的书，因为这是你目前看到最便宜的价格。这就是exploitation。但是现实中你并不会这么做，至少大部分人不会这么做，大家应该都会继续把列表往下翻，你有可能还会找到8元的价格，这个价格显然更加划算，但你付出了更多的时间精力。这就是exploration。 更多的exploration可能会得到更多的收益，但会花费更大的精力，直接exploitation虽然节省精力，但不一定得到更多的收益，这样就会存在exploration 和 exploitation 的平衡问题。
ε-greedy和UCB就是exploration and exploitation tradeoff中两种常用的策略。
1.ε-greedy方法 a = { a r g m a x q ( a ) ， 1 − ε 随 机 ， ε a=\begin{cases} argmaxq(a) ，&amp; 1-ε \\ 随机， &amp; ε \end{cases} a={argmaxq(a)，随机，​1−εε​
以1-ε 的概率选择q值大的动作，以ε的概率选择随机动作
例子：
a1a2a3当前时刻q(a1)=0.2q(a2)=0.3q(a3)=0.6下一时刻q(a1)=0.2q(a2)=1.5q(a3)=0.3 如果我们根据贪婪策略的话，会选择q值大的那个动作，即a3。但下一时刻q值就会变化，因此根据贪婪策略我们的最终收益只会是0.6+0.3=0.9。
但根据ε-greedy方法，当前时刻也有ε的概率选择到动作a2，最终的收益为0.3+1.5=1.8，显然最终的收益比贪婪策略得到的要高。
代码实现：
def choose_action(self, policy, **kwargs): if np.random.random() &lt; kwargs['epsilon']: action = np.random.randint(1, 4) else: action = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b7af1397deb73b82873e9b20f0a855c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f25aa4dae48363e1e87ddd0bb99595/" rel="bookmark">
			文件上传&#43;CTF题目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概念：路径的关系一句话木马 文件上传绕过：1.绕过js代码：2.绕过服务端（MIME类型）3.绕过黑名单绕过白名单图片马文件上传后利用蚁剑进行连接后门 CTFshow客户端验证前端js验证CTFshow-web157 服务端验证文件头content-type字段校验（image/gif）ctfshow-web152文件内容头校验（GIF89a）后缀名黑名单校验后缀名白名单校验 重点：利用.user.ini配置文件进行绕过ctfshow153 利用.htaccess来绕过CTF题目 路径截断绕过与普通截断绕过（验证后缀名）短标签绕过web154，155web156web157，158，159160 操作系统解析漏洞绕过windowslinux CMS,编辑器漏洞重点：服务器解析漏洞iis漏洞apachenginxtomacat session文件包含绕过session与cookie的区别文件上传加条件竞争web162，163 二次渲染PNG二次渲染jpg二次渲染 概念： web客户端在上传文件时，没有对上传文件的内容，扩展名等进行过滤。
路径的关系 区别相对路径中一些符号表示 ../表示上一目录 ./表示当前目录 /表示根目录 一句话木马 1.&lt;?php eval($_POST[1]);?&gt; 2.&lt;script language='php'&gt;eval($_POST[1]);&lt;/script&gt; 3.&lt;?php fputs(fopen("shell.php","w"),"&lt;?php eval($_POST[1]);?&gt;")?&gt; 文件上传绕过： 1.绕过js代码： （1）一般的web网页前端在上传文件时，都会利用js代码对文件的扩展名。也就是说，如果对文件的扩展名进行过滤了，可能是js代码的作用了。
（2）方法:
利用火狐的"about：config"来禁用js代码执行。 先使用可以使用的扩展名进行上传，利用bp抓包，改数据包扩展名，再放包。 2.绕过服务端（MIME类型） （1）服务端是在数据包传输过去后再进行响应，所以不能通过绕过js的方法，进行绕过
（2）一般是通过查看http上传的文件的Content-type来进行检测。
（3）方法：bp改变数据包，将数据包的content-type进行改变为合法的内容。
（4）一般合法的content-type：
超文本标记语言.html:text/html 普通文本.txt文件：text/plain PDF文件：application/pdf word文档：application/msword png/gif：application/png/gif .avi:video/msavi 3.绕过黑名单 1. 通过改变后缀大小写的方式来进行绕过 2. 通过双写来绕过：如果代码中对扩展名直接解析过滤为空格，说明就可以通过绕过。 3. 可以将php写成php5,php7，phtml等没有在黑名单的后缀 4. 可以在末尾加上 “空格” 5. 加末尾加上点`.` 6. 加上`::$DATA ` 7. 空格，点，::$DATA相结合 绕过白名单 所谓白名单，只允许一些合法的jpg通过 可以采用%00截断来截断字符，可以绕过
1.php%00.jpg 图片马 windows制造图片马：
copy 1.png \b + 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95f25aa4dae48363e1e87ddd0bb99595/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/296/">«</a>
	<span class="pagination__item pagination__item--current">297/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/298/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>