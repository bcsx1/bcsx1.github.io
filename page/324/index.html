<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7483e4c3194ddaab3e135bdc02c7a37/" rel="bookmark">
			树莓派4B部署Intel Realsense T265相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬件：树莓派4B 8G内存
系统：Ubuntu 20
最初我是参照这篇博客树莓派上部署英特尔深度相机IntelRealsense T265（他人8月7日刚写的）我树莓派上librealsense realsense-ros最后是实际按照这个来装的，也装成了！_TYINY的博客-CSDN博客进行配置的，但是由于环境等很多地方并不一致，所以有小问题，这里写博客整理一下。
1.安装Intel Realsense SDK 别人博客里说是要扩大swap分区，以免编译时内存不够，不过我用的是8G版本的树莓派，所以不存在这个问题。
1.1.安装依赖 sudo apt-get install git cmake libssl-dev libusb-1.0-0-dev pkg-config libgtk-3-dev libglfw3-dev libgl1-mesa-dev libglu1-mesa-dev 1.2.下载Realsense SDK git clone https://github.com/IntelRealSense/librealsense.git 如果网络不好，就用下面这个镜像源。
git clone https://github.com.cnpmjs.org/IntelRealSense/librealsense.git 1.3.编译准备 cd librealsense mkdir build &amp;&amp; cd build cmake .. 这里值得一提的是，我运行cmake时没有自行设置参数，而在参考博客中，设置了很多参数，最后事实是我不能运行相机。
1.4.编译与安装 make sudo make install 这里就不要make -j8之类的了，树莓派CPU能力有限，发热还很严重，就用单核慢慢编译吧。我自己实验的是大概花了一个多小时编译。
1.5.设置udev规则 此外，教程和博客里都还提到了设置udev规则，我不太确定这步的作用，可以先运行一下。
sudo ./scripts/setup_udev_rules.sh 2.验证安装 首先插上T265相机（注意是USB 3.0接口），然后运行下面这个代码。
rs-enumerate-devices 只要能输出信息，而不是说没有设备插入，那就是成功了。如果不行的话，只能再想想办法了。
附录 如果还有不清楚的，可以参考librealsense在GitHub上的文档
https://github.com/IntelRealSense/librealsense/blob/master/doc/installation.md
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7459442252d03ecaca426836dcace180/" rel="bookmark">
			2021-10-14
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springBoot2 整合redis之后频繁报超时错误 org.springframework.dao.QueryTimeoutException: Redis command timed out; nested exception is io.lettuce.core.RedisCommandTimeoutException: Command timed out after 10 second(s) at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:70) at org.springframework.data.redis.connection.lettuce.LettuceExceptionConverter.convert(LettuceExceptionConverter.java:41) at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:44) at org.springframework.data.redis.FallbackExceptionTranslationStrategy.translate(FallbackExceptionTranslationStrategy.java:42) at org.springframework.data.redis.connection.lettuce.LettuceConnection.convertLettuceAccessException(LettuceConnection.java:273) at org.springframework.data.redis.connection.lettuce.LettuceStringCommands.convertLettuceAccessException(LettuceStringCommands.java:799) at org.springframework.data.redis.connection.lettuce.LettuceStringCommands.get(LettuceStringCommands.java:68) at org.springframework.data.redis.connection.DefaultedRedisConnection.get(DefaultedRedisConnection.java:266) at org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:57) at org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:60) at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:228) at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:188) at org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:96) at org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:53) .... at java.lang.Thread.run(Thread.java:748) Caused by: io.lettuce.core.RedisCommandTimeoutException: Command timed out after 10 second(s) at io.lettuce.core.ExceptionFactory.createTimeoutException(ExceptionFactory.java:51) at io.lettuce.core.LettuceFutures.awaitOrCancel(LettuceFutures.java:119) at io.lettuce.core.FutureSyncInvocationHandler.handleInvocation(FutureSyncInvocationHandler.java:75) at io.lettuce.core.internal.AbstractInvocationHandler.invoke(AbstractInvocationHandler.java:79) at com.sun.proxy.$Proxy192.get(Unknown Source) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7459442252d03ecaca426836dcace180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7042cc79eedac263cdc828103beff8/" rel="bookmark">
			组合逻辑电路毛刺产生原因及消除办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、毛刺产生原因（竞争与冒险） 1.1 竞争 有两种情况会产生竞争：门电路两个输入信号同时向相反的逻辑电平跳变或同一信号经不同路径到达终点的时间有先有后的现象。
例1：信号 A、B 不可能突变，需要经历一段极短的过渡时间。而门电路的传输时间也各不相同，故当A、B同时改变状态时可能在输出端产生虚假信号。
例2：同一信号经不同路径到达终点的时间有先后（或者两个不同信号变化不同步）
结果，在t1-t2 时间内，电路输出端产生了Y=1的尖峰脉冲，不符合静态下，Y恒为0的逻辑关系：
1.2 竞争-冒险 根据上面举的两个例子，由于竞争而在电路输出端可能产生尖峰脉冲的现象就成为竞争-冒险。
组合逻辑电路的竞争-冒险现象会导致输出结果难以预料，因此要采取措施消除这种现象。
竞争与冒险是数字电路中存在的一种现象。由于元器件质量和设备工艺已达到相当高的水平，因而数字电路的故障往往是竞争与冒险引起的，所以要研究它们。在一个复杂的数字电路的设计阶段，就完全预料电路中的竞争与冒险是困难的，有一些要通过实验来检查。下面将说明组合数字电路中竞争与冒险的基本概念和确定消除它的一些基本方法。
竞争：在组合电路中，信号经由不同的途径达到某一会合点的时间有先有后，这种现象称为竞争。
冒险：由于竞争而引起电路输出发生瞬间错误现象称为冒险。表现为输出端出现了原设计中没有的窄脉冲，常称其为毛刺。
竞争与冒险的关系：有竞争不一定会产生冒险，但有冒险就一定有竞争。
二、如何消除组合逻辑电路的毛刺 1、发现并消除互补相乘项 2、增加乘积项以避免互补项相加 3、输出端并联电容器 4、引入时序逻辑，用寄存器多输出信号打一拍，这其实也是时序逻辑优于组合逻辑的特性 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71b21a2028a0e734cc9020b950ce10c0/" rel="bookmark">
			win10 获取 uni push ios 接入证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接入步骤
接入苹果iOS(APNs) - Uniapp推送 - GoEasy文档
使用win版本的openssl
windows下IOS证书制作 - Childhood Memory - 博客园
制作IOS证书主要有一下几个步骤
1.下载安装openssl
2.生成my.key和my.certSigningRequest 文件
cd C:\Program Files\OpenSSL-Win64\bin\ set RANDFILE=.rnd set OPENSSL_CONF=C:\Program Files\OpenSSL-Win64\bin\openssl.cfg openssl genrsa -out my.key 2048 openssl req -new -key my.key -out my.certSigningRequest -subj "/emailAddress=myemail@sample.com,CN=Common Name,C=CN" 注意：myemail@sample.com 为邮箱地址
上传my.certSigningRequest 到 苹果开发者官网
把下载的aps.cer文件 放到与my.certSigningRequest 同目录
3.生成my.p12文件
openssl x509 -in my.cer -inform DER -out my.pem -outform PEM openssl pkcs12 -export -inkey my.key -in my.pem -out my.p12 -password pass:123456 这样就生成了密码为123456，文件名为my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71b21a2028a0e734cc9020b950ce10c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83aba32b07dbecbe226b6eee37b5c126/" rel="bookmark">
			antdesign 组件样式按需导入，vite插件，vite-plugin-style-import
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //vite.config.ts { plugins: useVitePlugins(viteEnv, isProduction) } export function useVitePlugins(viteEnv: ViteEnv, isProduction: boolean) { const { VITE_USE_IMAGEMIN, VITE_BUILD_COMPRESS, VITE_BUILD_COMPRESS_DEL_SOURCE_FILE, } = viteEnv; const vitePlugins: (Plugin | Plugin[])[] = [ // have to vue(), // have to vueJsx(), ]; // vite-plugin-svg-icons //vitePlugins.push(configSvgIconsPlugin(isProduction)); // vite-plugin-style-import vitePlugins.push(configStyleImportPlugin(isProduction)); // vite-plugin-style-import // vitePlugins.push(ThemePlugin()); //vite-plugin-imagemin 一直不成功 // isProduction &amp;&amp; VITE_USE_IMAGEMIN &amp;&amp; vitePlugins.push(configImageminPlugin()); // rollup-plugin-gzip // isProduction &amp;&amp; vitePlugins.push( // configCompressPlugin(VITE_BUILD_COMPRESS, VITE_BUILD_COMPRESS_DEL_SOURCE_FILE), // ); return vitePlugins; } import styleImport from 'vite-plugin-style-import'; export function configStyleImportPlugin(isProduction: boolean) { //生产和开发先用一样的 const styleImportPlugin = styleImport({ libs: [ { libraryName: 'ant-design-vue', esModule: true, resolveStyle: (name) =&gt; { // 组件样式按需加载，无需全局引入 return `ant-design-vue/es/${name}/style/index` }, }, ], }); return styleImportPlugin; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6d8b0628e68dfcf2c5124961f380aed/" rel="bookmark">
			Mapreduce,mapper任务无输出以及相关问题解决，日志的正确用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题提出 1.输出空文件之前遇到过ArrayIndexOutOfBoundsException-&gt;数组越界的错误，解决也很简单：加上判断语句 。其实当时是有些怀疑是不是读取数据错误了，但是考虑可能是最后一行空值数据被读到了导致出现的这个错误，就没往下想。
2).在执行MR任务时，mapper和reducer都正常运行，但是hdfs输出文件为空。（任务是关于MR执行排序任务的）
数据如下：
排查经历 1.查看core-site.xml是不是路径(hadoop.tmp.dir属性)配置错误了，导致数据放错了位置。然而 不是
2.因为没有报错所以排除了是集群的问题。然后就是考虑的是可能程序错误了，但是一直没有发现错误。期间也尝试过重写输入文本，重写MR程序，重新打包等操作。
3.注意到了命令行MR程序执行结束后留下的信息：
Mapper的输出为空（Map output records=0）
这说明错误完全是出现在mapper阶段
尝试使用了程序经典的输出语句标志位，但是因为没找到它的输出，就暂时放弃了。本来想使用hadoop本地模式运行MR并使用Debug的方式查找错误的，感觉有些复杂就舍弃了。最后网上查询了如何查看MR程序的println输出(方法末尾附上）后，发现了问题。
这里需要查看logs文件（如果添加了历史服务器，则可以直接查看历史服务器的map任务，找到最新执行的任务，查看logs文件。没有则见最后查询logs日志的方法）
println输出结果如下：
可以发现得到的每一行数据都没有问题但是得到的数组长度始终为1，说明map任务中的split函数（以“\t”拆分）并没有将数据拆分。查看输入文件发现，间距很小。怀疑是间隔符的问题。但是在vim编辑输入文件时发现确实\t间距就是很小。多次尝试之后，发现结果：
vim编辑器并不很好适应所有外部文件复制的\t，很可能将其看为空格了。如果出现这种情况要么将数据拿出来使用记事本重新添加\t再复制到vim编辑器中，要么直接使用vim编辑器将间隔修改为\t
修改结束后：MR任务正常运行
Map输出如下：
MR运行结果如下：
小结 1.重点学会看logs日志文件，从日志文件中我们可以发现很多错误，也可以很好帮助我们解决问题。
2.遇到错误的时候，先考虑自己翻译下错误，不要忙着找文章看是什么错误（之前我就是…），比如数组越界异常ArrayIndexOutOfBoundsException，翻译过来就很好理解错误在哪里了。
3.使用好MR程序添加println输出的tip，可以提示自己那些位置出错了，快速反应。
补充查看日志 有历史服务器（JobHistoryServer）的：
找到最新执行完的MR程序点击history查看
1.
3.
4.
向下翻就可以找到我们添加的输出结果，如果不想使用本地的集群运行模式通过debug找错的，可以使用这个方法。
无历史服务器的：
打开hdfs web界面，打开/tmp/logs/目录找到用户的最新log文件，如图：
将文件下载下来搜索stdout,一直下一个就可找到相应的输出结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc37cecb6c627fd3deedcbe0e6bb38bc/" rel="bookmark">
			2021-10-13pop_front()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C ++ STL中列出pop_front()函数 在本文中，我们将讨论C ++中pop_front()函数的工作，语法和示例。
什么是STL中的列表 列表是一种数据结构，允许按时间顺序在任意位置进行插入和删除。列表被实现为双向链接列表。列表允许非连续的内存分配。与数组，向量和双端队列相比，列表在容器中的任何位置执行元素的插入提取和移动效果更好。在列表中，对元素的直接访问很慢，并且列表与forward_list相似，但是转发列表对象是单个链接列表，并且只能迭代转发。
什么是pop_front() pop_front()是C ++ STL中的内置函数，在头文件中声明。pop_front()用于从列表容器的开头弹出（删除）元素。该函数删除列表容器的第一个元素，意味着该容器的第二个元素成为第一个元素，并且该容器中的第一个元素从该容器中删除。此功能将容器的尺寸减小1。
语法 void pop_front (); 此函数不接受任何参数
返回值 此函数不返回任何内容，只是从容器中删除/弹出第一个元素。
示例 #include &lt;bits/stdc++.h&gt; using namespace std; int main(){ //创建一个列表 list&lt;int&gt; myList; //将元素插入列表 myList.push_back(1); myList.push_back(2); myList.push_back(3); myList.push_back(4); //应用pop_front()函数之前列出 cout&lt;&lt;"List contains : "; for(auto i = myList.begin(); i != myList.end(); i++) cout &lt;&lt; *i &lt;&lt; " "; //删除第一个元素 myList.pop_front(); //从前面删除元素后的列表 cout&lt;&lt;"\nList after removing an element from front: "; for (auto i = myList.begin(); i !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc37cecb6c627fd3deedcbe0e6bb38bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbeb6846767fb6daf6e833b7f7c462ae/" rel="bookmark">
			小白——C语言变量的定义小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、定义多个数据类型相同的变量时，可以用逗号(英文输入法状态下的）隔开每个变量。
例如：int i, j, k;
相当于 int i; int j; int k;
2、int i, j = 10;
相当于 int i; int j = 10;
3、int i, j = 10, k = 15;
相当于 int i; int j = 10; int k = 15;
4、错误的定义方法
int i, int j;
修改：int i, j;
int i; int j; (实际写代码时会写成两行）
以上两种修改方法都是正确的。
5、变量名
变量名需要是有意义的，如果变量名没有意义，需要添加注释。
6、写注释的优点
有利于自己回看代码时快速理解代码。
有利于他人读懂你的代码，增强代码的可读性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfae79eb4043439cd9761caf0b230062/" rel="bookmark">
			AppsFlyer 研究（十三）SRN平台对接-Google Adwords对接配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AppsFlyer 研究（十三）SRN平台对接-Google Adwords对接配置
Google Adwords对接配置
Google Ads界面仅允许iOS和Android设备用户配置广告。对于来自其他平台用户：例如 Windows Phone 的用户，只能使用落地页。
步骤如下：
1、配置 Google Ads MCC, 获得 LINK ID
详细操作请查看 AppsFlyer 研究（十一）配置 Google Ads MCC 获取 LINK ID
2、在AF 后台设置 Google Ads
配置步骤如下：
(1)、点击配置-&gt;合作伙伴配置，打开渠道配置页面
（2）、搜索Google Ads(Adwords ) ，如果置顶可见，则跳过此步骤
（3）、找到 Google Ads(Adwords )， 并点击，进入Google Ads 配置页面
（4）、在渠道对接标签页面启用合作伙伴权限，配置 LINK ID
（5）、配置归因窗口期 ，建议按照AF 推荐进行配置
点击型激活窗口配置为 7 天
浏览性激活窗口配置为 1天
（6）、配置应用内回传事件
（7）、点击“成本”标签页，启用“获取点击和曝光数据”
（8）、点击“保存”按钮
3、在Google Ads MCC 后台配置统计应用转化
详细操作，请查看AppsFlyer 研究（十二）Google Ads MCC 配置统计应用转化
4、在Google Ads MCC 授权 Link ID 给代理账号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfae79eb4043439cd9761caf0b230062/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e21dbd48448064d932146105b2f8568e/" rel="bookmark">
			python篇---定时器删除文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建文件夹 # -- coding: utf-8 -- import os import time import os def create(addr): for i in range(1, 100): #范围是你需要的数字范围，我创建的是名为1~100的文件夹 os.makedirs(addr+'/'+str(i)) #str(i)前后可加你需要的前缀和后缀 time.sleep(2) addr = 'C:/Users/YYQ/Desktop/img'#你需要创建文件夹的目录 create(addr) 定时删除文件夹里的内容 # -- coding: utf-8 -- import os import shutil from apscheduler.schedulers.blocking import BlockingScheduler sched = BlockingScheduler() img_path = "C:/Users/YYQ/Desktop/img" def run_task(filepath): del_list = os.listdir(filepath) for f in del_list: file_path = os.path.join(filepath, f) if os.path.isfile(file_path): os.remove(file_path) elif os.path.isdir(file_path): shutil.rmtree(file_path) @sched.scheduled_job('cron', day_of_week='*', hour='*', minute='*', second='*/5') def scheduled_job(): run_task(img_path) if __name__ == '__main__': sched.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e21dbd48448064d932146105b2f8568e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576ed937f6d43222df34fbc1c415c03a/" rel="bookmark">
			input 输入框 在自动填充时，背景颜色问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题:
自动填充前： 自动填充后：
可以看出，自动填充后，input背景颜色变成了别的颜色,
解决办法：
方法一：纯色阴影覆盖底色 input:-webkit-autofill { box-shadow: 0 0 0 1000px #333333 inset; -webkit-text-fill-color: #fff; } 填充后的效果
注意：
这个方法有个问题，就是input 输入框，不能有 圆角(border-radius)，而且只适用于纯色背景框。
可以看到，两边有明显的白色
方法二： 设置透明 input:-internal-autofill-previewed, input:-internal-autofill-selected { -webkit-text-fill-color: #807c7c; transition: background-color 5000s ease-out 0.5s; } 效果：
方法三： 利用动画延迟 input:-webkit-autofill, input:-webkit-autofill:hover, input:-webkit-autofill:focus, input:-webkit-autofill:active { transition-delay: 99999s; transition: color 99999s ease-out, background-color 99999s ease-out; -webkit-transition-delay: 99999s; -webkit-transition: color 99999s ease-out, background-color 99999s ease-out; -webkit-text-fill-color: #807c7c; } 效果：
推荐使用第二种或第三种.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8e3ef785c260808805ad82ab1c7c28/" rel="bookmark">
			k8s中pod的镜像拉取、重启策略和资源限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 k8s中pod的镜像拉取、重启策略和资源限制 拉取镜像策略资源限制Pod重启机制 拉取镜像策略 apiVersion：v1 kind: Pod metadata: name:mypod spec： containers： -name:nginx image:nginx:1.14 imagePullPolicy:Always #IfNotPresent:默认值，镜像在宿主机上不存在才会拉取 # Always：每次创建Pod都会重新拉取一次镜像 # Never：Pod永远不会主动拉取这个镜像 资源限制 Pod重启机制 apiVersion：v1 kind: Pod metadata: name:mypod spec： containers： -name:nginx image:nginx:1.14 imagePullPolicy:Always #IfNotPresent:默认值，镜像在宿主机上不存在才会拉取 # Always：每次创建Pod都会重新拉取一次镜像 # Never：Pod永远不会主动拉取这个镜像 restartPolicy:Never #Always:当容器终止退出后，总是重启容器，默认策略 #onFailure: 当容器异常退出（退出状态码非0）时，才重启容器 #Never：当容器终止退出，从不重启容器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00f350782872b05d477768d9e122197/" rel="bookmark">
			tensorflow加载boston数据集及数据集的解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#2021.10.13 HIT ATCI LZH #数据集为boston房价与周边环境等因素，参照网上的例子 import tensorflow as tf from tensorflow.python.ops import init_ops from tensorflow.python.training import optimizer import numpy as np import matplotlib.pyplot as plt #加载boston房价数据集 boston = tf.contrib.learn.datasets.load_dataset('boston') X_train, Y_train = boston.data, boston.target #对数据集的格式进行解析 print('数据加载成功！') print('boston.type is',type(boston)) print('X_train.type =', type(X_train)) print('X_train.ndim =',X_train.ndim) print('X_train.shape =',X_train.shape) print('X_train.dtype =',X_train.dtype) print('X_train 的行数 m = {0}, 列数 n = {1}'.format(X_train.shape[0],X_train.shape[1])) print('Y_train.type =', type(Y_train)) print('Y_train.ndim =',Y_train.ndim) print('Y_train.shape =',Y_train.shape) print('Y_train 的行数 m = {0}, 列数 n = None'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00f350782872b05d477768d9e122197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a72ab3a65465d3827f50ba9fd8fb7f0d/" rel="bookmark">
			使用开源poi 实现 Word转Pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：添加maven依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;fr.opensagres.xdocreport&lt;/groupId&gt; &lt;artifactId&gt;fr.opensagres.poi.xwpf.converter.pdf-gae&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.deepoove&lt;/groupId&gt; &lt;artifactId&gt;poi-tl&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 第二步：代码 package org.example; import fr.opensagres.poi.xwpf.converter.pdf.PdfConverter; import fr.opensagres.poi.xwpf.converter.pdf.PdfOptions; import org.apache.poi.xwpf.usermodel.XWPFDocument; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.nio.file.Files; import java.nio.file.Paths; public class Test { public static void main(String[] args) { try { //读取word文档 XWPFDocument document = null; try (InputStream in = Files.newInputStream(Paths.get("D:\\test.docx"))) { document = new XWPFDocument(in); } catch (IOException e) { e.printStackTrace(); } //将word转成pdf PdfOptions options = PdfOptions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a72ab3a65465d3827f50ba9fd8fb7f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cba6328bcc0bfe0d0528dacc145a53da/" rel="bookmark">
			测试云服务器是否打开相应端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 服务器A 在服务器A上启动一个端口监听，比如 7050端口，默认情况下下面监听的是一个tcp的端口
nc -l 7050 服务器B 在服务器B telnet 服务器A此端口，如下显示表示B机器可以访问A机器此端口
telnet 101.226.22.240 7050 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c6d67216ec1705f42fa9bf077d1ef14/" rel="bookmark">
			C# wpf 实现窗口按比例缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概述 做客户端有时为了让界面适用各种不同的系统分辨率，让界面内控件布局大小始终保存比例是一种方法。一般可以使用配置文件做不同分辨率的适配实现，或者通过代码根据不同的分辨率重新计算控件大小及位置实现。在wpf有一种更简单的方法，使用viewbox。
方法 ViewBox可以自动缩放其内部的元素，无论是控件、容器、文本都可以按比例自动缩放。想要实现整个窗口按比例缩放需要如下步骤：
ViewBox作为一级容器
一级容器即&lt;Window&gt;标签下第一个元素设置二级容器大小
将窗口本身需要的容器设在ViewBox标签下，即成为二级容器，设置其大小。这个大小通常是设计图上的窗口大小。需要注意的是，二级容器大小必须大于等于适配的所有分辨率，比如适配的最大分辨率是1080p，则二级容器大小至少设为1080p。二级容器大小为基准布局
其他控件大小都将相对于二级容器来布局。 代码如下：
下面代码中，窗口是按照1920x1080设计的，但实际的窗口只有640x360，但其显示的效果控件比例始终是一样的。
&lt;Window x:Class="WpfApp1.MainWindow" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:local="clr-namespace:WpfApp1" mc:Ignorable="d" Title="MainWindow" Height="360" Width="640"&gt; &lt;Viewbox&gt; &lt;Grid Width="1920" Height="1080"&gt; &lt;Border CornerRadius="20" Width="1280" Height="720" Background="#666666"&gt;&lt;/Border&gt; &lt;/Grid&gt; &lt;/Viewbox&gt; &lt;/Window&gt; 效果 上述代码的显示效果如下
窗口大小640x360
窗口大小1280x720 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85347e9f8f01d3d29f64001d1fcdc15d/" rel="bookmark">
			SpringBoot——Thymeleaf常见属性-条件判断th:if、th:unless、th:switch、th:case
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Thymeleaf常见属性 先来说说Thymeleaf常见的属性
1 th:action 定义后台控制器的路径，类似&lt;form&gt;标签的 action 属性，主要结合 URL 表达式,获取动态变量
2 th:method 设置请求方法&lt;form id="login" th:action="@{/login}" th:method="post"&gt;......&lt;/form&gt;
3 th:href 定义超链接，主要结合 URL 表达式,获取动态变量
4 th:src 用于外部资源引入，比如&lt;script&gt;标签的 src 属性，&lt;img&gt;标签的 src 属性，常与@{}表达式结合使用，在 SpringBoot 项目的静态资源都放到 resources 的 static 目录下。
放到 static 路径下的内容，写路径时不需要写上 static
5 th:id 类似 html 标签中的 id 属性&lt;span th:id="${hello}"&gt;aaa&lt;/span&gt;
6 th:name 设置名称 &lt;input th:type="text" th:id="userName" th:name="userName"&gt;类似 html 标签中的 value 属性，能对某元素的 value 属性进行赋值&lt;input type="hidden" id="userId" name="userId" th:value="${userId}"&gt;
7 th:attr 该属性也是用于给 HTML 中某元素的某属性赋值，好处是可以给 html 中没有定义的属性动态的赋值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85347e9f8f01d3d29f64001d1fcdc15d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83d94de37af444ba4efc954309ecb13e/" rel="bookmark">
			Maven企业级应用(四) 之依赖管理机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、依赖引入的方式 可以用如下方式引入依赖
&lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;scope&gt;&lt;/scope&gt; &lt;optional&gt;&lt;/optional&gt; &lt;/dependency&gt; 那么问题来了，比如感觉自己可能需要一个什么东西，怎么知道要引入哪些依赖呢？
如果是要用某个比较重要的技术，比如elasticsearch，spring，mybatis，等等，开源项目，直接到官网里面去，里面会告诉你如何在java里面引入maven依赖另外可能在开发的过程中，也许还需要一些小依赖，比如log4j，slf4j，jackson，mysql connector驱动等，甚至连官网都不用去了，直接百度。
百度：maven + 你需要的依赖名称，比如log4j 下面两个方式，走国外的网站去搜索，速度较慢
sonatype nexus：http://repository.sonatype.org
mvnbrowser：http://www.mvnbrowser.com
2、依赖声明的三要素，坐标 groupId、artifactId、version，就够了，type很少用
声明了三要素，一个坐标唯一定位了一个依赖的某个版本的jar包，maven会自动到远程的中央仓库里面去，给我们去找，下载到本地来，在打包的时候，就会自动使用。
3、依赖范围 &lt;scope&gt;&lt;/scope&gt; maven有三套classpath，classpath就是项目中用到的各种依赖的路径，jvm在运行的时候需要去classpath下面加载对应的类
maven在编译源代码的时候有一套classpath；在编译测试代码以及执行测试代码的时候，有一套classpath；运行项目的时候，有一套classpath；依赖范围会控制依赖包与这三种classpath的关系。
简单来说，不同的依赖范围，会导致那个依赖包可能在编译、测试或者打包运行的时候，有时候可以使用，有时候不能够使用。
compile:默认的范围。对编译、测试和运行的classpath都有效。一般都是用这种scopetest：仅仅对于编译以及运行测试代码的classpath有效，编译或者运行主代码的时候无效，仅仅测试代码需要用的依赖一般都会设置为这个范围，比如junit。一些测试框架，或者只有在测试代码中才会使用的一些依赖，会设置为test。这个的好处在于，在打包的时候这种test scope的依赖是不会放到最终的发布包里去的从而减少了发布包的体积。provided：编译和测试的时候有效，但是在运行的时候无效，因为可能环境已经提供了。比如servlet-api，一般就是这个范围，在运行的时候，servlet容器会提供依赖。servlet-api是用来开发java web项目的，可能你在开发代码和执行单元测试的时候，需要在pom.xml里面声明这个servlet-api的依赖，因为要写代码和测试代码。但是最终打完包之后，放到tomcat容器里面去跑的时候，是不需要将这个servlet-api的依赖包打入发布包中的，因为tomcat容器本身就会给你提供servlet-api的包。runtime：测试和运行classpath有效，但是编译代码时无效，比如jdbc的驱动实现类，比如mysql驱动。因为写代码的时候是基于javax.sql包下的标准接口去写代码的。只有在测试和实际运行的时候需要用这个包，但是编译的时候只要javax.sql接口就可以了，不需要mysql驱动类。一般我们声明mysql驱动的时候，不会设置为runtime，因为也许你开发代码的时候会用到mysql驱动特定的api接口，不仅仅只是用javax.sql。 4、传递性依赖 由于有的依赖可能有其他的依赖，其他的依赖也可能有依赖，以此类推。在纯手工时期，我们可能只加了第一层依赖，运行报错后接着加入第二层依赖，以此类推，这样极其麻烦。
maven的传递性依赖，是指maven自动递归解析所有的依赖，然后负责将依赖下载下来。所有层级的依赖，都会成为项目的依赖，不需要我们手工干预。不管有多少层级。所有的依赖都会下载下来。
比如我们的项目依赖了junit, junit又依赖了A,A又依赖了B。此时如果我们的项目对junit的依赖范围是test，junit对A的依赖范围为compile，那么我们的项目对A的依赖范围为test。
具体情况如下表：第一列是一级依赖，第一行是二级依赖
compiletestprovidedruntimecompilecompileruntimetesttesttestprovidedprovidedprovidedprovidedruntimeruntimeruntime 有可能依赖是不会传递的，就是可能有些多层级的依赖，是不会成为我们项目的依赖的。
比如说我们的项目依赖A，范围是compile。A又依赖B，范围是test。此时我们的项目是不会依赖B，因为A只有在测试的时候才会用到B，我们的项目依赖A是生产用的，我们去依赖B干嘛呢？B是给A测试的。
5、依赖调解 maven会自动解析所有层级的依赖，给我们自动下载所有的依赖，但是也可能会出现依赖冲突的问题
比如A-&gt;B-&gt;C-&gt;X(1.0)，A-&gt;D-&gt;X(2.0)，A有两个传递性依赖X，不同的版本。此时就产生了依赖冲突的问题，那么maven就会用依赖调解的机制来解决这种问题。此时就会依赖调解，采用就近原则，离A最近的选用，就是X的2.0版本。
如果A-&gt;B-&gt;X(1.0)和A-&gt;D-&gt;X(2.0)，路径等长呢？那么此时maven会选择第一声明原则，哪个依赖在pom.xml里先声明，就用哪个。
6、可选依赖 &lt;optional&gt;true&lt;/optional&gt; 此时依赖传递失效，不会向上传递
如果A依赖于B，B依赖于C，B对C的依赖是optional，那么A就不会依赖于C。反之，如果没有optional，根据传递性依赖机制，A会依赖于C。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe44a8cde16315f996f65c726c0eccf/" rel="bookmark">
			vue-cli 4.x 配置 htmlWebpackPlugin.options.title
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 vue.config.js 中添加配置：
// 修改或新增html-webpack-plugin的值，在index.html里面能读取htmlWebpackPlugin.options.title chainWebpack: config =&gt;{ config.plugin('html').tap(args =&gt; { args[0].title = '你想要设置的title'; return args; }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2167b65e9763e3f83f75d77583f200f/" rel="bookmark">
			MySQL的执行过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL 数据库主要分为两个层级：服务层和存储引擎层 服务器层：server 层包括连接器、查询缓存、分析器、优化器、执行器，包括大多数 MySQL 中的核心功能所有跨存储引擎的功能也在这一层实现，包括存储过程、触发器、视图等。存储引擎层：存储引擎层包括 MySQL 常见的存储引擎，包括 MyISAM、InnoDB 和 Memory 等，最常用的是 InnoDB，也是现在 MySQL 的默认存储引擎。存储引擎也可以在创建表的时候手动指定。 二、SQL 语句的执行过程 连接器：需要 MySQL 客户端登录，需要一个“连接器“来连接用户和 MySQL 数据库，“mysql -u 用户名 -p 密码” 进行 MySQL 登录，在完成 TCP 握手 后，连接器会根据输入的用户名和密码验证登录身份。若错误 会提示 Access
denied for user。若成功，MySQL 会根据权限表中的记录来判定权限。 查询缓存：MySQL 在得到一个执行请求后，会首先去 查询缓存 中查找，是否执行过这条 SQL 语句，之前执行过的语句以及结果会以 key-value 对的形式，被直接放在内存中。key 是 查询语句，value 是查询的结果。如果通过
key 能够查找到这条 SQL 语句，直接返回 SQL
的执行结果。若存在缓存中，就会继续后面的执行阶段。执行完成后，执行结果就会被放入查询缓存中。优点是效率高。但是查询缓存不建议使用， 因为在
MySQL 中对某张表进行了更新操作，那么所有的查询缓存就会失效，对于更新频繁的数据库来说，查询缓存的命中率很低。需要注意：在
MySQL8.0 版本，查询缓存功能就删除了，不存在查询缓存的功能了 分析器: 分为词法分析和语法分析 1). 词法分析：首先，MySQL 会根据 SQL 语句进行解析，分析器会先做 词法分析，你写的 SQL 就是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串是什么，代表什么。 2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2167b65e9763e3f83f75d77583f200f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f01c2bfeb239346fbb10f8293c26937/" rel="bookmark">
			Tof原理及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引言 ToF（Time of flight）是飞行时间法，它是一种深度测量的方法，精度为厘米级。因为其原理简单，小型化，测量距离范围较大，抗干扰能力较强，而得到广泛的应用，比如，微软的Kinect 2.0，Iphone 12手机的ToF相机，无人驾驶都应用到了ToF技术。下面就对ToF的基本原理，优缺点，影响ToF精度的因素这几方面展开描述。
2. 原理 ToF的基本原理是通过连续发射光脉冲（一般为不可见光）到被测物体上，然后接收从物体反射回去的光脉冲，通过探测光脉冲的飞行（往返）时间来计算被测物体离相机的距离。下图是飞行时间法深度测量基本原理示意图。
ToF根据调制方法的不同，可以分为两种：脉冲调制（Pulsed Modulation）和连续波调制（Continuous Wave Modulation）。由于脉冲调制是直接测量飞行时间，因此也称为dToF（直接ToF）（Lidar，也叫激光雷达，就是dToF），连续波调制是通过相位差来计算飞行时间，因此也称为iToF。
2.1 脉冲调制（dToF） 脉冲调制直接根据脉冲发射和接收的时间差来测算距离。下图是脉冲调制测距的示意图：
脉冲调制方案的照射光源一般采用方波脉冲调制，这是因为它用数字电路来实现相对容易。接收端的每个像素都是由一个感光单元（如光电二极管）组成，它可以将入射光转换为电流，感光单元连接着多个高频转换开关（下图的G0，G1）可以把电流导入不同的可以储存电荷(下图S0，S1)的电容里。
相机上的控制单元打开光源然后再关闭，发出一个光脉冲。在同一时刻，控制单元打开和关闭接收端的电子快门。接收端接收到的电荷S0被存储在感光元件中。
然后，控制单元第二次打开并关闭光源。这次快门打开时间较晚，即在光源被关闭的时间点打开。新接收到的电荷S1也被存储起来。具体过程如下图所示。
因为单个光脉冲的持续时间非常短，此过程会重复几千次，直到达到曝光时间。然后感光传感器中的值会被读出，实际距离可以根据这些值来计算。
记光的速度为c，tp为光脉冲的持续时间， S0表示较早的快门收集的电荷， S1表示延迟的快门收集的电荷，那么距离d可以由如下公式计算：
最小的可测量距离是：在较早的快门期间S0中收集了所有的电荷，而在延迟的快门期间S1没有收集到电荷，即S1 = 0。代入公式会得出最小可测量距离d=0。
最大的可测量的距离是：在S1中收集了所有电荷，而在S0中根本没有收集到电荷。然后，该公式得出d= 0.5 x c × tp。因此最大可测量距离是通过光脉冲宽度来确定的。例如，tp = 50 ns，代入上式，得到最大测量距离d = 7.5m。
优点：
测量方法简单，响应较快
由于发射端能量较高，所以一定程度上降低了背景光的干扰
缺点：
发射端需要产生高频高强度脉冲，对物理器件性能要求很高
对时间测量精度要求较高
环境散射光对测量结果有一定影响
2.2 连续波调制（dToF） 实际应用中，通常采用的是正弦波调制。由于接收端和发射端正弦波的相位偏移和物体距离摄像头的距离成正比(见后面推导)，因此可以利用相位偏移来测量距离。下图是连续波调制原理示意图：
其实相移偏移来测量距离相位差的方法与四步相移法的推导基本一样。下图是发射的正弦波和接收的正弦波的示意图：
连续正弦波调制测量方法，具体的推导过程如下。序号1-9对应下图的公式1-9。
假设发射的正弦信号s(t)振幅是a，调制频率是f
经过时延 △t后接收到的信号为接收r(t)，衰减后的振幅为A，强度偏移（由环境光引起）为B
四个采样时间间隔相等，均为T/4
根据上述采样时间可以列出四个方程组
从而可以计算出发射和接收的正弦信号的相位偏移△φ
据此可以根据（6）中公式计算物体和深度相机的距离d
接收信号的衰减后的振幅A的计算结果
接收信号强度偏移B的计算结果，反映了环境光
A, B的值间接的反应了深度的测量精度，深度测量方差可以用公式9近似表示。
优点：
相位偏移（公式5）中的(r2-r0)和(r1-r3)相对于脉冲调试法消除了由于测量器件或者环境光引起的固定偏差。
可以根据接收信号的振幅A和强度偏移B来间接的估算深度测量结果的精确程度（方差）。
不要求光源必须是短时高强度脉冲，可以采用不同类型的光源，运用不同的调制方法
缺点：
需要多次采样积分，测量时间较长，限制了相机的帧率
需要多次采样积分，测量运动物体时可能会产生运动模糊。
注意：ToF相机每次从发射端发出调制光，接收端其实是像相机一样，有一个感光元件，上面有很多像素点，每个像素点经过上述过程都可以得到一个对应的距离，所有的像素点测量的距离就构成一幅深度图，如下图所示，左边是原图，右边是对应的深度图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f01c2bfeb239346fbb10f8293c26937/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0deab4a1602ee64ac50781e5ee430154/" rel="bookmark">
			springboot操作数据库表的blob字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		太艰难了，终于把它搞定了！
1，实体类
public class TUser { private String username; private String password; private byte[] headimage; public TUser() { } public TUser(String username, String password, byte[] headimage) { this.username = username; this.password = password; this.headimage = headimage; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public byte[] getHeadimage() { return headimage; } public void setHeadimage(byte[] headimage) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0deab4a1602ee64ac50781e5ee430154/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f4ccaeb386be7cd8b4b4470667864a/" rel="bookmark">
			重构、合并项目经验总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、多模块项目精简、合并时建议先简单粗暴的合并，不要一开始就重命名package，等合并后启动无报错时可以重新reactor-&gt;rename，这样可以将类及依赖其的文件一起修改。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1f89ebd982ccbfce606bd00683abeb/" rel="bookmark">
			Matconvnet完全安装及踩坑实录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matconvnet安装 注意：版本要匹配，不匹配会出现各种各样的不可预见的错误：matlab2020b、VS2019、cuda10.1、cudnn7.6.0
下载matlab2020a: https://pan.baidu.com/s/1FieKSkX8nudFl4c1BZCfvQ 提取码：8888
先安装cuda，cuda和cudnn的版本要先去查阅matlab具体匹配的版本，不可以高了或低了，不然需要修改一堆的配置文件，很麻烦。
下载cuda: link
下载cudnn: link
在安装VS，安装2019以下的版本即可，2019，2017，2015都可以，社区版的就很OK。
下载VS2019社区版: https://pan.baidu.com/s/1sf7vYpLyUFkG5We5G69qlg 提取码：6666
安装步骤略，参加其他博客。
下载matconvnet： link
将下载下来的matconvent解压：
解压后的文件夹放入matlab安装路径下的toolbox文件夹，我的是G:\matlab\toolbox
从matlab软件打开matconvnet-1.0-beta25文件夹或者命令行输入cd G:\matlab\toolbox\matconvnet-1.0-beta25
将matconvnet-master文件夹及子文件夹添加到matlab的路径中
双击打开matconvnet-1.0-beta25\matlab\vl_compilenn.m
命令行输入mex -setup C++ 选择编译的软件
如果是只编译cpu版本，直接点击运行或是在命令行输入vl_compilenn都可以，
如果是编译gpu版本，则需在命令行输入
vl_compilenn('enableGpu',true,'cudaRoot','G:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.1','cudaMethod' ,'nvcc','enableCudnn',true,'cudnnRoot','G:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.1','verbose',1,'debug',true) 注意：括号内的第一个’G:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.1’为你的cuda的安装路基，如果你是安装在C盘，或是你的cuda不是10.1，都要修改，第二个’G:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v10.1’为cudnn的安装路径，也要和你的cudnn安装路径匹配。
开始编译vl_compilenn.m文件，在编译的过程中，不可避免会碰到各种错误，这时可以在刚才双击打开的vl_compilenn.m文件中加入断点，看是哪里出错了，将出错的地方一一修改即可。
踩坑记录 错误一：
单击 (line_615)
在614行加入断点，可以看到是出现上述错误是英文nvcc_cmd在配置system函数时出错，导致status不能返回0报错；而检查nvcc_cmd的具体参数可以发现配置信息有误，文件夹不存在或名字不对。我这里是修改367行：
更改为
即将路径的文件夹由distcomp改为parallel。因为distcomp文件夹在新版的matlab中没有gpu\extern\include文件了，移到parallel文件夹了；
还有就是647行的cl_path要改成你自己的VS2019安装路径，不然会找不到VS2019，导致配置失败。
错误二：
解决办法：https://blog.csdn.net/u014292102/article/details/80331481
修改第359行和622行：
再编译，成功！！
测试：
vl_testnn('gpu', true) 测试成功！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8804ca5f498fa13ae4f7246ac76318be/" rel="bookmark">
			C&#43;&#43;变量和基本类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本内置类型 算术类型分为两类:整型(包括字符和布尔类型在内)和浮点型
1. 不同平台下基本类型的字节数 类型16位平台32位平台64位平台char111short222int244long448long long/88指针248float444double888 数据类型long long 是在C++11中新定义的。
2. 算数类型的最小尺寸 算术类型分为两类:整型(包括字符和布尔类型在内)和浮点型
类型含义最小尺寸bool布尔类型未定义char字符8位wchar_t宽字符16位char16_tUnicode字符16位char32_tUnicode字符32位short短整型16位int整型16位long长整型32位long long长整型64位float单精度浮点数6位有效数字double双精度浮点数10位有效数字long double扩展双精度浮点数10位有效数字 3. 数据类型选择的经验准则 当知晓数值不可能为负时，选用无符号类型使用int执行整数运算，short常常太小，long和int一般尺寸一样。如果int不够，用long long。在算数表达式中不要使用char或bool，使用char特别容易出问题。如果要使用一个不大的整数，那么明确执行为signed char或unsigned char。执行浮点数运算用double，float通常进度不够而且两者计算代价相差无几。Long double一般没有必要，且消耗不容忽视。 4. 有符号类型和无符号类型 无符号类型赋值超出其范围，结果是取模后的值。如unsigned char c = -1; //假设char占8bit，c的值为255有符号类型赋值超出其范围，结果未定义。如signed char c2 = 256; //假设char占8bit，c2的值未定义切勿混用带符号类型和无符号类型。算数表达式中既有无符号数又有带符号数，带符号的数会转换成无符号的数 5.初始化与赋值 初始化和赋值是两个完全不同的操作。
定义于任何函数体外的之外的变量被初始化成0定义于函数体(块作用域)内的内置类型的对象如果没有初始化，则其值未定义。养成初始化内置变量的习惯。类的对象如果没有显式地初始化，则其值由类确定。 6. 声明与定义 声明使得一个名字为程序所知，定义会申请存储空间，还可能为其赋初始值(分离式编译) 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量对于复杂的声明语句，可以从变量名从右往左理解变量能且只能被定义一次，但是可以被多次声明 7. C++关键字 8. const 8.1 初始化 默认状态下，const对象仅在文件内有效。
在编译的过程中，编译器会把所有用到该const变量的地方都替换成相应的值。所以编译器必须知道变量的初始值,如果存在多个文件的情况下，每个文件必须知道const的初始值（const对象也必须初始化）。但由于默认状态下，const对象仅在文件内有效，当多个文件同时出现同名的const变量时，其实就相当于分别定义了不同的变量。
如果想只定义一次怎么做呢？
只需要无论是声明还是定义都标记extern关键字即可。
//file1.cpp extern const i=1; //file2.cpp extern const i; 如果想要在多个文件之间共享const 对象，必须在变量之前添加extern关键字
引用 引用:
引用的类型都系要和与之绑定的对象严格匹配，而且引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起
const引用
允许任何表达式作为初始值,只要改表达式的结果能转换成引用类型即可。尤其允许为一个引用绑定非常量的对象、字面值，甚至一个表达式
8.2 const引用 定义：把引用绑定到const对象上，即为对常量的引用(reference to const)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8804ca5f498fa13ae4f7246ac76318be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83965bf018005a458d1cc33718a62516/" rel="bookmark">
			北大软微拟录取名单公布：逐鹿群雄，是谁收割了战场？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		北大软微，全称北京大学软件与微电子学院，是由北大软件学院和北大国家集成电路人才培养基地合并成立的新型学院。目前，主要以培养软件工程、集成电路工程、项目管理、电子与通信工程4个领域的工程硕士为主体，每年能够培养一千名左右的工程硕士研究生。以下为刚刚发布的2022级推荐免试研究生拟录取情况：
北京大学2022年软件与微电子学院拟录取推荐免试硕士研究生公示名单
恭喜以上同学成功上岸！
可以看到，2022级推免研究生拟录取人数为156人，较去年减少5人。
在这156名佼佼者中，有75%的同学来自985院校，24%的同学来自211院校，1%的同学来自其他院校。其中985与211人数之比与去年基本一致，而来自其他院校的同学人数仅为去年的1/4！可见今年的保研竞争更为激烈，双非院校的同学需要更多的勇气和更大的毅力才能脱颖而出！
接下来让我们一起来看一下北大软微各方面的详情介绍吧！
1、专业设置
2021年学院招生专业为电子信息（专业硕士），硕士点设有：软件工程、网络安全、智能科技、集成电路、电子通信、金融科技、计算机技术，均为全日制培养。
(1)软件工程：包括软件开发、系统软件、云计算与服务工程等。
(2)智能科技：包括智能计算、大数据技术与应用、自然语言处理等。
(3)网络安全：包括网络与系统安全、大数据与云安全、软件安全等。
(4)集成电路：包括集成电路设计与EDA、集成电路器件与制造、智能系统集成技术等。
(5)电子通信：包括智能无人系统、嵌入式智能系统等。
(6)金融科技：包括金融大数据、创新与创业投资管理等。
(7)计算机技术：包括数字艺术与技术、增强与虚拟现实、语言信息工程等。
(8)软件工程实验班：包括人机物融合操作系统、高可信云计算平台、智慧化行业应用软件等（依托软件工程国家“双一流”学科，与软件工程国家工程研究中心、信息学院软件研究所联合培养）。
(9)集成电路实验班：包括智能芯片与未来计算、先进微纳器件与集成、微纳传感器与智能系统等（依托国家集成电路产教融合创新平台，与信息学院微纳电子学研究院联合培养）。
2、师资力量
软微学院有两位院士：杨芙清院士、王阳元院士。杨院士作为软微学院的理事长、名誉院长，王院士作为北大微电子学科开创人，两位院士同时也是北大信科学院的教授。此外，软微学院还聘有26位教授、21位副教授、35位校内双聘教师、12位客座教授以及46位校外兼职教师，在软件技术与服务工程、微纳电子与嵌入式系统、金融信息与管理技术和新型交叉领域各有专长。
软微学院的一部分老师同时也在北大信科学院任职，信科学院的实力大家有目共睹，而这些老师能在信科任职，更说明了软微也是有一定科研实力的。同时也意味着，如果学生在这些老师名下读研，有机会接触到信科学院的资源。
岛主整理了一份名单，这些软微学院的老师，同时也在信科学院任职：
信科学院计算机科学技术系： 软件研究所：陈向群、王捍贫、麻志毅、黄罡、陈钟计算语言学研究所：常宝宝网络与信息系统研究：严伟
信科学院微纳电子学系：黄如、汪国平、刘力锋、于敦山、张兴、冯建华、吴文刚、王新安、张大成、王漪、刘晓彦 信科学院电子学系: 现代通信研究所：宋令阳、杨光临、吴建军、李正斌、焦秉立、段晓辉、程玉华量子电子学研究所：陈徐宗、陈景标 信科学院基础实验教学研究所：刘志敏 3、面向就业的培养模式
学院提出了“面向产业，培养人才；面向需求，建设学科；面向领域，凝炼方向”的发展规划，研究生培养主要以就业为导向。软微的就业水平在北大各院系中排第三，技术类的就业不输其他大学的计算机学硕。
很多学院不允许学生在校期间外出实习，而软微的大部分导师在学生研二时就放开实习了，学生通过积累大厂实习经验，在就业时提高竞争力。并且，在北大这样的环境中，周围都是人才，大家都在共同努力一起进步，能力和眼界在无形之中得到了提高。北大学历、实习经历再加上个人能力，毕业时往往能拿到不错的offer。
软微技术类学生未来就业的去向包括但不仅限于：华为、阿里巴巴、腾讯、百度、京东、Google、Facebook、IBM、Intel、NVIDIA等单位，这样的就业质量完全对得起北大的金字招牌了。
由于软微的特点是学科交叉，技术类、金融类的学生共同培养，就像一个创业团队的孵化基地，很多优秀的学生选择了直接创业。毕业后进入学长学姐所在的创业公司也是一个不错的选择。
另外，如果想要报名选调生、考公务员，北大的学历也是一块敲门砖。很多单位也只要清北复交的学生，不用担心因为学历被刷掉简历。
有的同学可能会担心，如果自己想做科研，软微会是一个合适的去处吗？在前文中，岛主针对软微的师资力量进行了分析，一部分导师同时也在信科学院带学生，而这类老师通常学术能力较强，手头常年有科研项目，实验室常年满员。这样好的资源，相信对于志在科研的同学来说，是一个不错的选择。
4、实习机会多、岗位质量高
本身软微的培养模式是面向就业的，一般老师也都同意学生外出实习，平日里学生的科研压力也会相对小一些。在北京，互联网大厂多，实习机会多，再加上北大这块招牌，学生出去找实习是蛮有优势的。计算机方向的学生很多都去了诸如华为、腾讯、百度、微软、美团、京东、快手、新浪等企业进行实习，金融方向的学生能够拿到中信、中信建投、中金、华泰以及各大银行总部管培的实习机会。
在这样的氛围下，可以从学长学姐和同学那里获取内推机会、求职经验，共同交流薪资待遇、工作环境，大家一起交流、共同进步，这将是一笔很宝贵的资源。
来到北京，进到北大这个平台，所接触的人、见识的东西是大不相同的。周围的同学不仅学术能力优秀、技术水平过人，更能玩得转学生工作，大众面前进行演讲汇报也落落大方、毫不怯场。在与大佬们合作的过程中，能学到很多，更能开阔眼界。
● 校区不在本部，会有什么影响？
软微学院位于大兴区，乘坐地铁+公交前往本部大概需要1.5小时，校车通勤40min。有的同学可能会担心，校区偏远，平时的学习氛围会不会不如本部？会不会享受不到本部的各类资源？
岛主认为，小伙伴们不必过于担心。据学长学姐说，最开始在本部给软微分了地方，不过领导考虑到本部地皮少，所以才去了大兴。在大兴单独建一个校区，空间更大，各类设施一应俱全，学生也更能静下心来做研究。到了研二研三，可以在本部分宿舍，也可以在外面租房子住，离本部更近，实习也更方便。
软微全日制学生入学会发正规的学生证、学生卡，权限跟本部学生没有不同。一方面，可以享受本部和大兴校区的各种资源设施，另一方面，可以参加本部的各类活动，有机会接触到业内顶尖资源，和业内优秀人才交流合作。当然，未来毕业也是发放北大研究生的毕业证、学位证，能够享受到北大校友圈这一宝贵的资源。
● 学费较高
软微电子信息专业硕士的学费为3万元/年，学习年限为3年，也就是研究生期间学费总额是9万元。
相比于科学学位硕士，这个费用的确有些偏高。不过前文中岛主也提到了，软微的导师大部分开放实习，而互联网企业的实习工资也是很高的，实习过程中也能攒下一笔起步资金，一定程度上可以抵消学费带来的经济压力。更何况，计算机行业的工资有多高大家也都清楚，花三年的学费，换未来高薪的工作和光明的发展前途，这不失为一个收益很高的投资选择。
5、结语
总的来说，北大软微平台好、水平高，能为学生提供顶尖的发展平台，其面向就业的培养模式造就了一批又一批优秀的人才，同时也为志在科研的学生提供了充足的资源。软微的保研生源逐年走高，学生大部分来自于985、211高校，是保研时一个性价比很高的去处。
以上就是对于北大软微的名单分析的院校介绍，欢迎小伙伴们在下方留言，表达自己上岸的喜悦呀！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e022f14d03202dc6a2646e14b9e9ae/" rel="bookmark">
			QGIS解决shp乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常我们导入shp文件到QGIS中属性会乱码，解决方法：
打开【设置】-【选项】-【数据源】，勾选“忽略shp文件编码”
接着导入shp文件。
此时右键图层【打开属性表】会发现依旧是乱码，不用担心
此时双击图层，在打开的属性对话框中，点击【源】-编码选择【utf-8】-【apply】
再次打开属性表
成功！
此时最好导出该shp文件，保存下来，方便下次使用。
如果我们把这个shp文件导入geoserver中，记得编码选择【utf8】，否则geoserver发布的geojson也会是乱码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e70a36f8968a93198867261d1b154d/" rel="bookmark">
			关于Integer的空指针异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Integer的空指针异常 问题来源 当用Integer来接收数据后，需要将数据与0进行比较，看是不是0，但是如果Integer接收的数据是null的时候，就会报空指针异常。
public static void main(String[] args) { Integer a = null; System.out.println(0 == a); } 原因分析 Integer是包装类型，而我们直接写的0是int类型，属于基本类型，所以在比较的时候会自动进行拆箱操作，将Integer转换成int，此时因为变量是null，所以就会空指针异常。
如果我们给0做一个装箱操作，此时就不会有空指针异常了.
所以在使用包装类型与基本类型进行比较的时候，需要先对包装类型的数据进行判空的处理，防止出现空指针异常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b045ab3893af624bcf6442ec8309a57/" rel="bookmark">
			语音合成接口整理_各平台语音合成接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前语音合成接口比较成熟，可以使用的平台也比较多，使用方式和价格也打不相同。
一、腾讯云（推荐）
功能：
1.基础语音合成API（短文本合成API）
2.长文本语音合成API
3.实时语音合成API
在线文档：https://cloud.tencent.com/product/tts
价格方案：先看免费，收费情况点击去官网
语音合成免费额度为800万字符，仅支持通用与实时语音合成接口。免费资源包自您领取成功后起三个月内有效，一个账号只能领取一次。
二、百度云
功能:
基础语音合成API（短文本合成API）
在线文档：
在线语音合成_高度拟人的语音合成服务-百度AI开放平台
价格方案：先看免费，收费情况点击去官网
语音合成接口免费额度如下：
接口服务认证状态免费并发免费调用次数有效期基础音库未认证5并发5000180天基础音库个人认证10并发50000180天基础音库企业认证100并发100000000180天精品音库未认证2并发50015天精品音库个人认证3并发200015天精品音库企业认证5并发500015天 三、阿里云
功能：
1.基础语音合成API（短文本合成API）
2.长文本语音合成API
在线文档：
https://ai.aliyun.com/nls/tts?spm=5176.12061031.J_8058803260.49.1adf6822QTztuA
价格方案：
没有免费使用，短文本合成Api首年1元；长文本Api首年 2.2元 10万字。
四、其他
讯飞开放平台：
功能：
1.实时语音合成API
在线文档：
在线语音合成_免费试用-讯飞开放平台
价格方案：
新用户50万次，有效期1年。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60273584b1dca27fba495978c1d0a436/" rel="bookmark">
			Spring错误排查（AOP）Exception in thread “main“ org.springframework.beans.factory.BeanCreationException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'Service' defined in class path resource [Bean.xml]: BeanPostProcessor before instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.aop.aspectj.AspectJPointcutAdvisor#0': Cannot create inner bean '(inner bean)#34cd072c' of type [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice] while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name '(inner bean)#34cd072c': Resolution of declared constructors on bean Class [org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60273584b1dca27fba495978c1d0a436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c23068c92a14f46b4d7f4f02864346d/" rel="bookmark">
			ubuntu根目录扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 虚拟机修改磁盘大小，查看磁盘 sudo fdisk -l 从上图看到，磁盘容量已经识别为100G，但分区表记录的容量仍然是50G（红色字体提示）
2. 修复分区表 查看分区情况，会立即提示空间未全部使用，提示输入Fix修复分区表
sudo parted -l 3. 扩容分区 sudo cfdisk 上下选中要扩容的分区，左右选择Resize后回车，会自动填写可用的总容量，也可以手动写入扩容后的总容量，回车后选择Write再次回车保存，退出。
我这里是分配99G全部
保存输入yes后按q退出
4. 扩容文件系统 此时可看到磁盘已经扩容，但文件系统大小仍然是扩容前的
sudo pvs lsblk 重置pv大小，再次查看大小容量已经变为更新了
sudo pvresize /dev/sda3 sudo pvs sudo pvdisplay sudo vgdisplay free空间分配
sudo lvextend -l +100%free /dev/mapper/ubuntu--vg-ubuntu--lv 更新文件系统，查看已经成功扩容
sudo resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d90fdc8eabe2c456619ad10f3e2b1b2c/" rel="bookmark">
			vs：更改现有pdb和二进制文件搜索路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文件地址：在调试器中设置符号 (.pdb) 和源文件 - Visual Studio (Windows) | Microsoft Docs
程序数据库 ( .pdb) 文件（也称为符号文件）将项目源代码中的标识符和语句映射到已编译应用中的相应标识符和说明。 这些映射文件将调试器链接到源代码，以进行调试。
使用标准调试生成配置从 Visual Studio IDE 生成项目时，编译器会创建相应的符号文件。 本文介绍如何在 IDE 中管理符号文件，例如，如何在调试器选项中指定符号的位置，如何在调试时检查符号加载状态，以及如何在代码中设置符号选项。
有关符号文件的详细说明，请参阅以下内容：
了解符号文件和 Visual Studio 符号设置
为什么 Visual Studio 要求调试器符号文件必须与同时生成的二进制文件完全匹配？
符号文件的工作方式 .pdb 文件保存调试和项目状态信息，使用这些信息可以对应用的调试配置进行增量链接。 在调试时，Visual Studio 调试器使用 .pdb 文件来确定两项关键信息：
要在 Visual Studio IDE 中显示的源文件名和行号。在应用中停止的断点位置。 符号文件还会显示源文件的位置，以及要从中检索它们的服务器（可选）。
调试器只会加载与在生成应用时创建的 .pdb 文件完全匹配的 .pdb 文件（即原始 .pdb 文件或副本） 。 这样的完全重复是必需的，因为即使代码本身未更改，应用的布局也可能会更改。
提示
要在项目源代码之外调试代码（如项目调用的 Windows 代码或第三方代码），则必须指定外部代码的 .pdb 文件（也可以是源文件）的位置，这些文件必须与应用中生成的文件完全匹配。
符号文件位置和加载行为 在 Visual Studio IDE 中调试项目时，调试器将自动加载位于项目文件夹中的符号文件。
备注
在远程设备上调试托管代码时，所有符号文件必须位于本地计算机上，或者位于调试器选项中指定的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d90fdc8eabe2c456619ad10f3e2b1b2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a4ecacac9ec4c5c116ff8bb38415ea/" rel="bookmark">
			3.SVG坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3. Coordinates 坐标系 SVG 的世界是一幅无限的画布(infinite canvas)。在本章，我们将弄清楚，如何告诉浏览程序，你对 canvas 的哪一部分感兴趣，它的尺寸是多少，以及如何定位该区域的点。
The Viewport 视窗 文档打算使用的 canvas 区域称为视窗(Viewport)。你通过 &lt;svg&gt; 元素的 width 和 height 属性确定 viewport 的尺寸。每个属性的值可以是单纯的一个数字，在这种不带单位的情况可以是只是，数字被认为是以像素为单位。也就是用户坐标系(user coordinates)中指定的单位。你也可以用一个数字，后面跟一个单位标识符(unit identifier),来指定 width 和 height，单位可以是下面中的一个:
em 默认字体的字体大小(font size)，通常相当于文本行的高度。
ex 字母 x 的高度
px Pixels 像素(在 CSS2-supporting 图形中，每英寸有 96 像素: 96 pixels per inch)
pt Points(一英尺的七十二分之一： 1/72 of an inch)
pc Picas(一英尺的六分之一: 1/6 of an inch)
cm Centimeters 厘米
mm Millimeters 毫米
in Inches 英寸
可能的 SVG viewport 声明包含下面的代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5a4ecacac9ec4c5c116ff8bb38415ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/732efef899c6da85fd09613ea79126ed/" rel="bookmark">
			前端实习生入职后都做什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入职第一天：
入职后会收到项目的git信息(包括git地址，个人账号和密码)，会有一个公司邮箱，登录企业微信，钉钉关联手机号，用来每日上下班打卡。
熟悉项目：
了解公司项目开发使用的编辑器，熟悉编辑器，登录git查看项目结构目录，把项目源代码clone下来，然后运行查看项目。先熟悉一下代码，熟悉项目使用的技术栈，比如我现在做的项目框架是vue+element。所以您至少得先了解一下vue的基础知识，vue路由啦，数据绑定啦，生命周期函数啦之类的.element是基于vue的组件，开发时候可参考element官方文档.然后您还得熟悉项目配置信息，连接后台的接口等等.
//element算是一个API
学习使用git推送和拉取代码
了解每次写完代码以后，要提交代码在编辑器上怎么操作。如果这个前端开发是多人开发，那么您每次写代码之前需要从git上拉取已经合并好的代码。
工作中要养成的习惯：
1.如果有bug请写一个文档，描述这个bug，标题，思路。
2.每天干了什么要及时记录
解决bug的思路：
1、首先完整地描述问题
2、把报错信息或者图片展示出来
3、写自己对这个bug的思路和理解
4、解决方案
5、相关知识点复现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c56cd89f78b0cbfaea2eecae60b3c7/" rel="bookmark">
			第三章 基于遗传算法的BP神经网络优化算法（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3.1理论基础 3.1.1 BP神经网络概述 来源 BP神经网络：即back propagation神经网络，名字源于在网络训练的过程当中，调整网络权值的算法是 误差的反向传播（back propagation）的学习算法。
地位 BP网络是前馈网络的核心部分，是人工神经网络中应用最广泛的算法，但同时也存在着一些缺陷，例如学习收敛速度太慢、不能保证收敛倒全局最小点，网络结构不易确定。另外，网络结构、初始连接权值和阈值的选择对网络训练的影响很大，但是又无法准确获得，针对这些特点利用采用遗传算法对神经网络进行优化。
概述 输入：Xi
输出：Yt
隐含层输出为S：Sj指的是隐含层的第j个输出，计算公式为输入Xi与权值Wij的乘积之和减去阈值 Θ j \Theta _{j} Θj​得到的差作为传递函数f的参数输入，得到一个函数值为Sj。
输出层的输出Y：同样是由前面隐含层的输出S与权值Vij乘积之和减去阈值 γ t \gamma_{t} γt​得到的差作为传递函数g的参数输入，得到一个函数值为Yt。
BP神经网络的算法工作流程：
简单来说，BP神经网络和所有的机器学习内容相似，都是由使用者自己准备输入数据X与期望输出Y，然后讲X、Y都置入BP神经网络中，经过不断地拟合得到一个输出函数f(x)。再由使用者准备一组新的X、Y，由f(x)函数计算输出f(X)，看这个输出与期望的输出Y之间的误差是否大，误差越小说明拟合效果越好。然后就可以使用这个f(x)来进行实际问题的应用了。
3.1.2 遗传算法的基本要素 遗传算法的基本要素主要包括染色体编码方法、适应度函数、遗传操作和运行参数。
①染色体编码是指个体的编码方法，目前包括二进制法，实数法等。二进制法是指把个体编码成为一个二进制串，实数法是指把个体编码成为一个实数。
②适应度函数是指根据进化目标编写的用于计算个体适应度值的函数，通过适应度值函数计算每个个体的适应度值，用于选择操作等。高适应度值的个体往往生存下来的可能性就更大。
③遗传操作指的是选择操作、交叉操作和变异操作。
④运行参数是遗传算法在初始化时确定的参数，主要包括群体大小M、遗传代数G、交叉概率Pc和变异概率Pm。
本案例使用sheffield遗传算法工具箱进行遗传算法的编写。
3.2案例背景 3.2.1问题描述 本文以拖拉机的齿轮工具箱为背景，介绍使用基于遗传算法的BP神经网络进行齿轮箱故障的诊断。由于绝大多数齿轮箱故障都是由齿轮故障造成的，所以这里只研究齿轮故障的诊断。
网络的输入是一个15维的向量，因为这些数据具有不同的量纲和量级，所以在输入神经网络之前首先进行归一化处理。表3-1和表3-2列出了归一化之后的齿轮箱状态样本数据。
从表中可以看出三种故障模式，因此可以采用如下的形式来表示输出。
无故障：（1，0，0）
吃根裂纹：（0，1，0）
断齿：（0，0，1）
3.2.2解题思路及步骤 1、算法流程 遗传算法优化BP神经网络主要分为：BP神经网络结构确定、遗传算法优化权值和阈值、BP神经网络训练及预测。其中BP神经网络的拓扑结构是根据样本的输入/输出参数个数确定的，这样就可以确定遗传算法优化参数的个数，从而确定种群个体的编码长度。也即是：输入/输出参数个数——&gt;遗传算法优化参数的个数——&gt;种群个体的编码长度。
神经网络的权值和阈值一般通过随机初始化为[-0.5,0.5]区间的随机数，这个初始化参数对网络训练的影响会很大，但是又无法准确获得，对于相同的初始权重值和阈值，网络的训练结果是一样的，引入遗传算法就是为了优化出最佳的初始权值和阈值。
结语 前期准备工作到此就差不多了，下一章将详细探讨使用matlab的程序实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84f997de6e3eed733e213a3d27abdc58/" rel="bookmark">
			bus Hound使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bus Hound 使用详解 功能选择栏Capture界面Sava界面Setting界面Device界面Help界面EXIT界面 功能选择栏 下面将一一介绍每个功能的功能以及用法
Capture界面 这个功能是用来捕捉选中的设备（在Device里选择）的数据包。接下来将介绍每一列数据的含义
Device：设备号，用来标识USB设备
Address：这个一直为空，具体为什么我也没弄懂，官方的解释如下
Length：显示本次传输的数据长度，以Byte为单位
Phase：用于描述传输数据的类型，所有的类型和解释如下图（我这里是ISOC，即异步数据传输）
Data：捕捉到的具体数据，这里最大显示的长度是12字节（这个可以在Setting中修改，后面做详解）
Description：如果Phase为OUT或IN的话，将DATA的内容按照ASCII码转换后显示在这里。如果是其他类型，会按照对应协议这次传输进行说明。
Delta：每一段数据传输完成的的时间间隔，以毫秒为单位。
Cmd.Phase.Ofs(rep):
三个数据中的第一个表示命令(Cmd)，从1开始统计，每当设备收到一条新的命令就加1。
第二个表示Phase在本次(Cmd)中的位置，每次有一个数据或者状态就加1。
第三个表示数据在这一个Phase当中的位置。
Data：顾名思义就是日期，即这一段数据传输完成的日期
Time：这一段数据传输完成的具体时间
Driver：进行这一操作的驱动
Sava界面 该界面可以将捕捉到的数据包保存到文件中，可以选择txt文本文件或者zip压缩包格式保存，文本文件如下图
Setting界面 Capture Capacity：捕捉数据的最大存储容量，如果可以看到多一些数据的话，不妨可以设置大一点
Max Record Length：一次捕捉最大的数据量，对应Capture界面中Data列数据长度
Stop When：停止捕捉数据的条件
第一行：驱动的选择以及对应的说明，对应Capture界面的Driver列
第二行：传输数据类型的选择以及对应的说明，对应Capture中Parse列
第三行：勾选在Capture界面中显示的内容
Device界面 这里列出了所有的USB设备，勾上哪个设备就会去捕捉哪个设备的数据包，双击设备或者选中设备然后点右下方的Send Commands按钮，会进入发送命令界面，如下图
Help界面 这个界面就不用多说了，就是官方提供的使用说明，如果英语不好不建议直接阅读
EXIT界面 顾名思义，这个按钮就是用来退出软件的，跟直接点击窗口右上角的 X 号一样效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f02bb72fe9dc27f732cb3b3be6aeb1d9/" rel="bookmark">
			计算机图像处理之几何畸变矫正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		透视变换 三维几何变换的透视变换简介一点透视变换其他变换非矩形像素坐标的转换（课外扩展）图像卷绕（课外扩展） 应用实例——几何畸变的校正几何畸变校正流程1) 几何畸变的描述2) 已知gu(x，y)和gv(x，y)的解析表达式直接法：间接法： 例子 学习要求 三维几何变换的透视变换简介 把空间坐标系中的三维物体或对象转变为二维图像表示的过程称为投影变换。根据视点（投影中心）与投影平面之间距离的不同， 投影可分为平行投影和透视投影， 透视投影即透视变换。
平行投影：视点（投影中心）与投影平面之间的距离为无穷大；而对于透视投影（变换），此距离是有限的。
与平行投影相比，透视投影的深度感更强，看上去更真实，但透视投影不能真实地反映物体的精确尺寸和形状。
对于透视投影，不平行于投影面的平行线的投影会聚集到一个点，这个点称为灭点(Vanishing Point)。坐标轴方向的平行线在投影面上形成的灭点又称为主灭点。因为有x,y和z三个坐标轴，所以主灭点最多有3个。
一点透视变换 其他变换 图像几何变换的一个重要应用是消除由于摄像机导致的数字图像的几何畸变。
通过计算机图像处理系统将几何失真的图像恢复到正常状态， 即为图像畸变的几何校正。
几何变换的另一个应用是对相似的图像进行配准以便进行图像比较， 典型的应用是利用图像相减来检测运动或变化。
非矩形像素坐标的转换（课外扩展） 图像卷绕（课外扩展） 图像卷绕是通过指定一系列控制点的位移来定义空间变换的图像变形的处理技术， 非控制点的位移则通过控制点进行插值处理。
图像卷绕操作一般包括控制点选择及插值处理两个部分，其处理过程如图4-39所示。
应用实例——几何畸变的校正 ① 图像空间像素坐标的几何变换——空间变换
② 变换后的标准图像空间的各像素灰度值的计算——灰度值计算
几何畸变校正流程 建立校正函数，即建立几何校正的数学模型；再利用已知条件确定模型参数；最后利用模型对图像进行几何校正。
1) 几何畸变的描述 2) 已知gu(x，y)和gv(x，y)的解析表达式 希望从几何畸变图像g(u,v) 去恢复基准几何坐标的图像f(x,y)。
直接法： 得到 g(u， v) →f(x，y) 一幅校正图像。
这样得到的校正图像，其象素分布是不规则的，会出现象素挤压、疏密不均等现象，不能满足要求。因此最后要对不规则图像通过灰度内插生成规则的栅格图像。
间接法： 间接成图法首先从空白的输出图像阵列（校正后的图像）
出发建立空间转换关系。（x,y）→（u，v）
则得到校正图 f(x，y)=g(u，v)。
由于计算的（u， v）不一定刚好位于畸变图像的某个像素中心上， 所以必须经过灰度插值确定（u， v）的灰度值。
例子 实际应用中常使用多项式来表达校正前后相应控制点对之间的坐标关系。 重采样成图法采用的二元多项式数学模型为
实际中常利用一次多项式、 二次多项式和三次多项式进行几何校正。
利用上述技术， 对具有桶形畸变和透视畸变的图像进行几何畸变校正的结果如下图：
学习要求 1）熟悉各种图像几何变换矩阵表示，明确在正反变换下的图像像素位置的对应，以及变换结果图像像素值的确定方法（最近邻、双线性插值，有兴趣的同学可探讨更多的高阶插值方法）
2）编程实现图像缩放、图像平移、图像旋转、图像复合变换
3）编程实现几何畸变的校正方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2580fbc73ed2f9819209f8c955405018/" rel="bookmark">
			IP路由基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由概述 路由基础概念 通过IP地址可以寻找到网络中唯一的网络节点，每一个IP都有自己的网段，这些网络可能发布再世界各地，共同组成全国的网络。
路由转发：网络中网关和路由器根据收到的IP报文的目的地址选择合适的路径，将报文转发到下一跳路由，直到报文到达最后一跳的路由二层寻址将报文转发给目的网络主机。
中间节点选择的路径所依赖的表为路由表。
路由条目明确的出接口以及下一条，这两项信息将明确指出IP报文转发到相应的吓一跳设备上。
路由条目生成 路由信息获取方式 直连路由：直接接口所在网段的路由，由设备自动生成。
静态路由：由网络管理员手工配置条目
动态路由：路由器通过动态协议（ospf、is-is、BGP）学习到路由
查看IP路由表 display ip routing-table destination/Mask:网络地址与网络掩码
Proto（Protocol）：此路由协议类型
Pre（Preference）：路由协议的优先级
Cost：路由开销
Nexthop：表示对本路由而言，到达此路由指向的目的网路吓一跳地址。
interface：此路由的出接口
路由优先级 当路由器到达目的网路有多条路径的时候，（这些路由的目的网络地址异界网路掩码都相同），路由器会比较条目的优先级，优先级值最小的优先。路由来源的优先级值（Preference）越小代表加入路由表的优先级越高
优先级最高的路由将添加进路由表。
正常情况下 直连路由的优先级为0 并且不可以认为更改，静态路由的优先级为60。OSPF内部优先级为10、外部优先级为150。
RTA通过静态、动态路由协议学习到相同的路由条目，比较路由协议优先级，OSPF优先。OSPF的路由条目将被加入到路由表。
路由来源路由类型默认优先级直连直连路由0静态静态路由60动态路由ospf内部路由10-ospf外部路由 度量值 当路由器通过某种路由协议发现多条到达同一目的网路路由时（拥有相同的可有优先级）度量值将作为路由优选的依据之一。
路由度量值表示到达路由所指目的地址的代价。
一些常用的度量值有：跳数、宽带、时延、代价、负载、可靠性
度量值越小越优先，度量值最小的路由将会添加到路由表中。
度量值很多时候被称为开销值（cost）。
路由转发 最长匹配原则 当路由收到IP数据包时，会将数据包的目的IP地址与自己本地路由表中的所有路由表项进行逐为比较，知道找到匹配度最长的条目。
当路由收到一个数据包时，会在自己的路由表中查询数据包的目的IP地址，如果能够找到匹配的路由表想，则依据表项所指的出接口以及吓一跳来转发数据，如果没有匹配表项，则丢弃此数据包。
路由器的行为时逐跳，数据包从源到目的沿路径每一个路由器都必须有关目的网段的路由，否则会造成丢包。数据通信往往是双向，因此要关注流量的往返（往返路由）。 静态路由 静态路由有网路管理人员手动配置，配置方便，对系统要求低，适合于拓扑结构简答并且稳定的小型网路。
缺点就是不能自动适应网路拓扑的变化，需要人工干预。
静态路由的配置 关联吓一跳IP的方式 ip route-static ip-address {mask|mask-length} nexthop-address 关联接口的方式 ip route-static ip-address {mask|mask-length} interface-type interface-number 关联出几口与吓一跳IP方式 ip route-static ip-address {mask|mask-length} interface-type interface-number nexthop-address 在创建静态路由时，可以同时指定接口和下一跳，对于不同的出接口类型，也可以只指出接口或只指定下一跳。对于点到点接口，必须指定出接口。
对于广播接口（如以太网接口）和VT接口，必须指定下一条。
缺省路由 缺省路由时一种特殊的路由，当报文没有在路由表中找到匹配的具体路由表项才使用路由，如果报文的目的地址不能与路由表的任何目的地址相匹配，那么此报文将选取缺省路由进行转发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2580fbc73ed2f9819209f8c955405018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38c5e4027fb24d2c3e4082470504f75c/" rel="bookmark">
			C语言各种指针的定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各种指针的定义: 1.一个整形数: int a;
2.一个指向整形数的指针: int *a;
3.一个指向指针的指针，它的指向的指针指向一个整形数: int **a;
4.一个有10个整形数的数组: int a[10];
5.一个有10个指针的数组，每个指针指向一个整形数: int *a[10];
6.一个指向有10个整形术的数组的指针: int (*a)[10];
7.一个指向指针的指针，被指向的指针指向一个有10个整形数的数组: int(**a)[10];
8.一个指向数组的指针，该数组有10个整形指针： int *(*a)[10];
9.一个指向函数的指针，该函数有一个整形参数并返回一个整形数: int (*a)(int);
10.一个有10个指针的数组，每个指针指向一个函数，该函数有一个整形参数并返回一个整形数:
int (a[10])(int);
11.一个函数的指针，指向的函数的类型是有两个整形参数并且返回一个函数指针的函数，返回函数指针指向有一个整形参数且返回整形数的函数: int ((*a))(int,int)(int);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28dbd47ab4fe771998d25d06d96620f5/" rel="bookmark">
			计算机网络原理-第七章：无线与移动网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 无线网络1.1 无线网络基本结构1.2 无线链路与无线网络特性 2 移动网络2.1 移动网络基本原理2.2 寻址2.3 移动节点的路由选择 3 无线局域网 IEEE 802.113.1 IEEE 802.11 体系结构3.2 IEEE 802.11 的 MAC 协议3.3 IEEE 802.11 帧 4 无线局域网 IEEE 802.114.1 蜂窝网络体系结构4.2 蜂窝网络中的移动性管理 5 移动 IP 网络5.1 代理发现5.2 向归属代理注册 1 无线网络 1.1 无线网络基本结构 无线网络基本组成主要包括以下几个部分：
1.2 无线链路与无线网络特性 无线链路标准的两种主要特性为：
无线链路与有线链路的主要区别：
信号强度的衰减：电磁波在穿过物体时强度减弱。干扰：在同一个频段发送信号的电波将互相干扰。多径传播：多径传播使得接收方收到的信号变得模糊隐藏终端 2 移动网络 2.1 移动网络基本原理 2.2 寻址 移动网络实现移动节点寻址的基本策略包括间接路由选择和直接路由选择。
2.3 移动节点的路由选择 ⏳ 间接路由选择：
由归属代理转发数据给外部代理。
⏳ 直接路由选择：
由通信代理通过归属代理获得转交地址，直接发送到外部代理。
3 无线局域网 IEEE 802.11 IEEE 802.11 标准小结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28dbd47ab4fe771998d25d06d96620f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6232925b53868e9742298fcb4024c00e/" rel="bookmark">
			leetcode热题HOT-100道题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode刷题记录 题目 题目 LeetCode 热题 HOT 100 关于树的题目
652 寻找重复的子树
序列化二叉树 只能前序或后续遍历 利用map记录每个根节点的序列化字串 若系列化字串数量大于2就是重复的子树
112 路径总和
递归实现 若当前节点为叶节点且targetSum等于当前节点 返回ture 否则return 用或语句递归左右子树
113 路径总和 II 求路径 和剑指 Offer 34. 二叉树中和为某一值的路径一样
和路径总和解法相似
深度优先遍历 若当前节点为叶节点且targetSum等于当前节点 记录当前路径
在递归中先将节点值加入路径 然后递归左右子树 再移出当前节点值
437 路径总和 III 求路径等于targetSum的数量
两个递归
主函数递归到每一个节点 以当前节点为根节点递归寻找路径总和
第二个递归函数和 112 路径总和差不多（不要求是叶节点） 当targetSum等于当前节点值 记录路径数量
337 打家劫舍 III 动态规划
以根节点为子树的最高金额有两种情况 选根节点的值 不选根节点的值
选根节点的值 左右节点的值就不能选
不选根节点的值 左右节点的值可选可不选 取最大值
后续遍历
236 二叉树的最近公共祖先
面试经典题 递归实现 递归函数返回当前以root为根的子树是否包含 p q 返回root
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6232925b53868e9742298fcb4024c00e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80a02d54c9a8d560f2879a841c63537a/" rel="bookmark">
			Vue 路由使用 params 传递参数失败 获取不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决 使用 params 传递参数 必须 加上 name
{path:'/blog',name:'blog',params:{is:true}} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a516be0b2244d090fda1a4d9f53a62/" rel="bookmark">
			【机器学习实验二】k-NN算法—改进约会网站以及手写体数字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、改进约会网站
1、项目背景
2、数据收集
3、在约会网站中使用k-近邻算法的流程
4、代码实现
二、手写体数字识别 1.了解手写体数字识别
2、手写体数字识别思路
3.1、导入模块
3.2、引入训练样本文件和测试样本文件，定义一个读取数据的转换数据的函数
3.3、定义一个字段转列表的函数
3.4、定义相似度函数
3.5、编写识别函数
3.6、调用
3.7、运行结果
一、改进约会网站 1、项目背景 我的朋友海伦一直使用在线约会网站寻找适合自己的约会对象。尽管约会网站会推荐不同的人选，但她并不是喜欢每一个人。经过一番总结，她发现自己交往过的人可以进行如下分类：
不喜欢的人魅力一般的人极具魅力的人 海伦认为，尽管发现了这些规律，仍无法将约会网站推荐的匹配对象归入恰当的分类，她希望借助我们的分类软件更好的帮助她将匹配的对象划分到确切的分类中。
2、数据收集 海伦收集约会数据已经有了一段时间，她把这些数据存放在文本文件datingTestSet.txt中，每个样本数据占据一行，总共有1000行。
海伦收集的样本数据主要包含以下3种特征：
每年获得的飞行常客里程数
玩视频游戏所消耗时间百分比
每周消费的冰淇淋公升数
3、在约会网站中使用k-近邻算法的流程 （1）收集数据：提供文本文件，即datingTestSet.txt。
（2）准备数据：使用Python解析文本文件。
（3）分析数据：使用Matplotlib画二维扩散图。
（4）测试算法：使用文本文件的部分数据作为测试样本，计算错误率。
（5）使用算法：错误率在可接受范围内，就可以运行k-近邻算法进行分类。
4、代码实现 #-*- coding:utf-8 -*- import matplotlib.lines as mlines import matplotlib.pyplot as plt import numpy as np import matplotlib as mpl import operator ''' #准备数据，从文本文件中解析数据 ''' def file2matrix(filename): #打开文件 with open(filename,'r') as fr: # 读取文件所有内容 arrayOLines = fr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a516be0b2244d090fda1a4d9f53a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68db09b90e77c6438b2de9b06ec65a58/" rel="bookmark">
			Python基础教程：判断列表中是否存在某元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成员运算符
运算符描述in如果在指定的序列中找到值返回 True，否则返回 Falsenot in如果在指定的序列中没有找到值返回 True，否则返回 False 实例：
lista=[1,'5','s','cf'] if 1 in lista: print('1 在列表lista中') if '1' in lista: print('"11" 在列表lista中') if 'cf' in lista: print('cf 在列表lista中') if 'ss' in lista: print('ss 在列表lista中') 输出：
1 在列表lista中 cf 在列表lista中 is 与 ==区别：
is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等
''' 学习中遇到问题没人解答？小编创建了一个Python学习交流QQ群：531509025 寻找有志同道合的小伙伴，互帮互助,群里还有不错的视频学习教程和PDF电子书！ ''' a=1 b=1 lista=[1,'5','s','cf'] listb=[1,'5','s','cf'] if a is b: print('a=b') if listb is lista: print('lista is listb') if lista == listb: print('lista=listb') 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68db09b90e77c6438b2de9b06ec65a58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52f9b56fadfe18c44a0acf9f3b6426ea/" rel="bookmark">
			Pytorch 深度学习运行代码简单教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch 是一个机器深度学习框架，易于上手，个人感觉比 tensorflow要友好。
Pytorch的深度学习程序分三个模块，实现三个功能，分别是取数据、建模型、运行程序。一般是分三个.py文件写，当然也可以写在一个文件里。我喜欢写成三个文件，这样看着比较方便点，而且Pytorch把这三个功能都写的挺好的，自己用的时候继承稍微改一下就好了。
其实深度学习的最终目标，就像求 y = f ( x ) y = f(x) y=f(x) 这个公式中 f ( x ) f(x) f(x) 的最佳参数一样：
首先我们会有很多很多的 ( x , y ) (x, y) (x,y)，它们都是一一对应的 (尽量不要出现一个 x x x对应多个 y y y，这样会让 f ( x ) f(x) f(x) 捉摸不透的)，那么我们第一个文件就是如何把 ( x , y ) (x, y) (x,y) 弄成一对一对的，送入到 f ( x ) f(x) f(x) 里。 ( x , y ) (x, y) (x,y) 解决了，接下来就是定义 f ( x ) f(x) f(x) 的形式了，具体是怎么表达的，比如 f ( x ) = 2 x f(x)=2x f(x)=2x …， 所以就需要另一个文件来定义 f ( x ) f(x) f(x) 了，就是所谓的模型了。现在我们手头上有了成对的 ( x , y ) (x, y) (x,y) 了，也有了确定结构的 f ( x ) f(x) f(x) 。最后就是让两者联系起来，把 ( x , y ) (x, y) (x,y) 送入到 f ( x ) f(x) f(x)里，接着得到结果，求 目标 y y y 和 预测 y y y 之间的差距，一般就是平方差之类的，然后拿着这个差值去进行更新 f ( x ) f(x) f(x) 里的参数，也就是后向传播。 1、数据处理 继承Dataset就可以了，直接上代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52f9b56fadfe18c44a0acf9f3b6426ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54682b258124446ca16b3bc9ddcce3a8/" rel="bookmark">
			openwrt使用godaddy的api实现动态域名解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容转自：分享一个通用的godaddy_DDNS_shell脚本 - OPENWRT专版 - 恩山无线论坛 - Powered by Discuz!本脚本针对ipv6，v4也支持，只需在gdip的解析步骤稍作修改即可。废话不多说，直接开搞。一、拥有一个godaddy注册的域名，至于为什么选择godaddy除了你懂的原因，还 ...恩山无线论坛https://www.right.com.cn/forum/thread-1317904-1-1.html
先进入godaddy的nds解析页面，新建一条A条目用于登入你的主机；
再进入developer.godaddy.com/keys 创建key和Secret并记录下来,注意，Environment需要选择“Production”；；
然后编辑一个xxx.sh文件，内容如下：
#!/bin/sh #这里是你购买的域名 mydomain="domain.xyz" #这里是dns配置中的名称 myhostname="router" #这里key和Secret之间注意有个冒号 gdapikey="你的key:你的Secret" logdest="local7.info" #另外注意，我这里的ipv4地址，所以使用的是A类型解析，如果是ipv6那么下面所有的A需改为AAAA #这里的地址也是为ipv4服务，ipv4地址为https://api.ipify.org, #ipv6为myip=`curl -6 "https://api6.ipify.org"` #也可自行使用别的地址 myip=`curl -s "https://api.ipify.org"` #从ip服务器获取ip # myip=`ip route show | grep pppoe-wan | awk 'NR==2 {print $9}'` #从本地获取pppoe-wan口的ip dnsdata=`curl -s -X GET -H "Authorization: sso-key ${gdapikey}" "https://api.godaddy.com/v1/domains/${mydomain}/records/A/${myhostname}"` #这里最后的2-9是针对性取得ipv6的字符，dnsdata中的返回字符串是一个json格式，需对齐解析。 # gdip=`echo $dnsdata | cut -d ',' -f 1 | tr -d '"' | cut -d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54682b258124446ca16b3bc9ddcce3a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb8816fa178de2b70c6c48ca77c7803/" rel="bookmark">
			数据建模的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据建模的步骤 1.收集数据2.准备输入数据3.分析输入数据4.训练算法5.测试算法6.使用算法 1.收集数据 一般通过公司自建的数据库系统获取数据，也可以使用开源的数据，常用的工具mysql，hive，Excel等，存储数据的媒介。
2.准备输入数据 一般的机器学习模型对输入数据的类型有着严格的格式要求，如在svm中object需要转化为int，把数据改造成可以输入模型的数据。常用的工具pandas，numpy。
3.分析输入数据 此步骤一般用于分析数据的分布，以及数据的缺失情况，异常情况，确保数据的质量。如果工作的内容是数据分析为主，则第三步是重点，直接人工进行数据分析。常用的工具pandas，matplotlib。
4.训练算法 通过数据建立模型，一般常用的模型有svm，随机森林，xgboost，神经网络等，按照输入的数据和需要的输出数据为标准设计算法。常用工具sklearn，TensorFlow。
5.测试算法 建立好模型之后当然要评估它的好与坏，对于已经知道目标值的的监督算法，必须已知用于评估算法的目标变量值；对于无监督学习，也必须用其他的评测手段来检验算法的成功率。然后根据实际问题进行改正。常用工具sklearn，TensorFlow。
6.使用算法 模型上线到实际的应用场景，然后进行正常的工作。此时如果碰到新的问题则进行改进。
参考资料：机器学习实战 peter harrington
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b7420b41e80ef3da9b220ea4f618e2/" rel="bookmark">
			以太网链路聚合与交换机堆叠、集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以太网链路聚合与交换机堆叠、集群 链路聚合技术原理与配置基础原理手工模式LACPDU（Link Aggregation Control Protocol Data Unit）系统优先级接口优先级最大活动接口数选举过程负载分担 配置命令 链路聚合技术原理与配置 基础原理 设备之间存在多条链路时，由于STP的存在，实际只会有一条链路转发流量，设备间链路带宽无法提升。也就是说有4条冗余链路，由于STP的原因 只用一条链路为转发状态，其他三条链路为阻塞，导致与3条链路带宽浪费。而链路聚合就是解决这个问题，将多个物理接口捆绑为一个逻辑接口，可以在不进行硬件升级的情况下，达到增加链路带宽的目的。
• 链路聚合接口可以作为普通的以太网接口来使用，与普通以太网接口的差别在于：转发的
时候链路聚合组需要从成员接口中选择一个或多个接口来进行数据转发。
• 一个聚合组内要求成员接口以下参数相同：
▫ 接口速率
▫ 双工模式
▫ VLAN配置：接口类型都是Trunk或者Access，如果为Access接口的default VLAN需要
一致，如果为Trunk接口，接口放通的VLAN、缺省VLAN需要一致。
手工模式 手工模式：Eth-Trunk的建立，成员接口的加入均由手动模式配置，双方系统之间不使用LACP进行协商。
正常情况下所有的链路都是活动链路，此模式下所有活动链路都参加与数据转发，平均分担流量，如果某条活动链路故障，链路聚合组自动在剩下的活动链路中分担流量。
当聚合的两端设备中存在一个不支持LACP协议时，可以使用手动模式。
但是手工方式并不推荐 ，因为手工模式下，设备间没有报文交互，因此只能通过管理员人工确认。
而且手动模式下，设备只能通过物理层判断对端接口是否正常工作。
LACPDU（Link Aggregation Control Protocol Data Unit） LACP模式下采用LACP协议的一种链路聚合模式，设备通过链路聚合控制协议数据单元进行交互，通过协议协商确保对端是同一台设备，同一个聚合成员接口。
LACPDU报文中包含设备的优先级、mac地址、接口优先级、接口号。
系统优先级 LACP模式下，两端设备所选择的活动接口数目必须相同，否则链路聚合组会无法建立，此时可以使用其中一端成为主动端，另一端根据主动端选择活动接口。
通过系统LACP优先级确定主动端，值越小优先级越高。
系统默认的优先级都是32768，当优先级一样的时候会比较MAC地址选择主动段。
接口优先级 选择出主动端后，两端都会以主动端的接口优先级选择活动接口，优先级高的接口将优先选择为活动接口，接口LACP优先级指越小，优先级越高。和上面一样 优先级默认为32768 当优先级一样的时候比较接口编号。
最大活动接口数 LACP牧师支持最大活动接口数，当实际的端口数大于最大活动端口后，会将超出的端口设置为非活动端口，将其作为活动端口的备份端口。交换机只在活动端口的接口中发送、接受报文。当活动端口的链路发生故障的时候，可以从非活动的端口中选择出优先级最高的一条变为活动端口，使其实际总带宽不变，业务不间断转发。
选举过程 首先根据上面的 系统优先级 接口优先级 最大活动接口 等参数进行选举，首先确定主动端，然后由主动端确定活动端口 然后由主动端通知被动端 哪些端口为活动端口。
负载分担 基于包的负载分担 将包发为几段 再将其分别分派到各端口 发生，但是可能因为网络的原因会出现乱序，需要重新组装基于流的负载分担 直接将整块流传送 • 如果报文的IP地址变化较频繁，那么选择基于源IP、目的IP或者源目IP的负载分担模式更有 利于流量在各物理链路间合理的负载分担；
• 如果报文的MAC地址变化较频繁，IP地址比较固定，那么选择基于源MAC、目的MAC或源 目MAC的负载分担模式更有利于流量在各物理链路间合理的负载分担。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b7420b41e80ef3da9b220ea4f618e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c58e70d70fa4c4f30f56c34914399b67/" rel="bookmark">
			域名解析到非80端口，个人网站搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题来源 今天网站的备案终于通过的，兴冲冲地去搞域名解析，结果发现域名解析到ip之后，默认访问的是80端口，而自己部署的网站设置的端口是9528（反正是非80端口），网上找了下各种答案，发现要把域名解析到非80端口的几种方法都不太行，其中有的是说改成 域名加端口访问，直接报 Invalid Host header，而另外一种是做url转发，需要两个域名，且两个域名都需要备案，我晕。
2 解决方案 改为用 nginx做代理转发，nginx默认的80端口访问，域名解析的时候还是按照 直接解析到ip，然后在主机上部署 nginx，
server { listen 80; server_name blakeyi; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://localhost:9528/; } vi /usr/local/webserver/nginx/conf/nginx.conf 编辑你的conf文件（改成你的路径）
在 location这里 映射到你自己的端口就行了
3 其他问题 在centos主机上安装nginx的时候总是报错，一般来说是 PCRE安装的问题，
直接 yum install -y pcre pcre-devel 好像不太行，得手动安装，或者需要找到PCRE的安装位置，然后在安装nginx的时候指定路径
./configure --prefix=/usr/local/webserver/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.35
具体见 菜鸟教程 其他的很多安装教程有问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f59dac6d757f27d6c0e0e3b2f01405f/" rel="bookmark">
			【C语言】实现n的阶乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用C语言实现输入某一个函数实现n的阶乘，此次为个人练习，若有错误敬请提出。
自然数 n 的阶乘写作 n!。n!=1×2×3×...×n。例如：4!= 1 × 2 × 3 × 4 = 24.
要求:利用while或者for循环计算n！的值，且正整数n，1≤n≤10。
首先，规定正整数范围是1~10，则使用if语句判断正整数n是否属于该范围内，若属于则进行for循环或while循环。for循环和while循环实现n的阶乘思路大致一样。
for循环大致思路：①定义一个变量i，i附初始值为1，使i进行自增，直到i小于等于n为止停止循环。②定义一个变量j，j附初始值为1，目的是为了存放i自增的值，循环体内容为：j=j*i 目的是为了将乘积进行存放。
while循环大致思路：①while表达式中判定循环停止的标准是i&lt;=n，循环体只需要添加i自增就可。
方法一：使用for循环
代码如下： #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(){ int i,n,j=1; scanf("%d",&amp;n); if(n&gt;1&amp;&amp;n&lt;10){ for(i=1;i&lt;=n;i++){ j=j*i; } printf("%d\n",j); } return 0; } 方法二：使用while循环
代码如下： #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(){ int n,i=1,j=1; scanf("%d",&amp;n); if(n&gt;1&amp;&amp;n&lt;10){ while(i&lt;=n){ j=j*i; i++; } printf("%d\n",j); } return 0; } 运行结果： 输入2 时，所以输出的值为“2”，如下所示：
2 2 输入5 时，所以输出的值为“120”，如下所示：
5 120 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/323/">«</a>
	<span class="pagination__item pagination__item--current">324/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/325/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>