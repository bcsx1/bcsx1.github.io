<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbde008c1f903f1b0586aa31bacf4f19/" rel="bookmark">
			sqliteorm的sync_schema介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 迁移功能 在迁移过程中，没有明确的上下函数。取而代之的是sqlite_orm提供的sync_schema函数，它负责将实际的db文件模式和你在make_storage调用中指定的模式进行比较，如果有什么不一样，它就会改变或放弃/创建模式。 storage.sync_schema(); // or storage.sync_schema(true); 注意事项 请注意，sync_schema并不能保证数据会被保存。它只是试图保存数据。下面你可以看到sync_schema在调用时遵循的规则列表。如果db中存在多余的表 它们将被忽略（而不是丢弃）。每一个来自存储的表与它的db模拟和比较如果表不存在，则创建如果表存在，它的列与来自db的table_info进行比较，并且如果保存为false，如果db中存在不存在的列（多余的），表将被丢弃并重新创建，并且表将被复制到没有多余列的临时表中，源表将被丢弃，如果保存为true，复制后的表将被重命名为源表（sqlite删除列技术）。它的默认值是false。要注意的是，将它设置为true可能会花费时间来复制表的行。如果存储空间中的列在db中不存在，那么将使用'ALTER TABLE ... ADD COLUMN ... "命令，表的数据不会被删除，但是如果任何添加的列是空的，但没有默认值，表将被删除并重新创建。如果有任何列存在于db和storage中，但由于任何属性（type, pk, notnull）的不同，表将被删除并重新创建（dflt_value没有被检查，因为默认值可能有歧义，请注意）。最好的做法是在创建存储后立即调用这个函数。 参考链接 sqlite_orm 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c3125efd392d198d4e3364e547192b/" rel="bookmark">
			自动化测试，Selenium模块的简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
使用Selenium模块的前置条件 **
1)安装Python和PyCharm
2) 安装Selenium（Selenium是Python的一个第三方包）
保证你的电脑连接好了外网，进入cmd命令行窗口，输入：pip install selenium
检验是否安装成功:进入Python交互环境（在cmd命令行窗口输入python），输入import selenium 不报错即安装成功。
pip install selenium 3）获取浏览器版本对应的驱动，并将驱动路径添加到系统环境变量Path里
下面我们就使用Selenium模块进行自动化操作了 打开PyCharm，新建一个python文件
from selenium import webdriver #引用 dr= webdriver.Chrome() #启动浏览器为谷歌浏览器 dr.get("https://www.baidu.com/") #打开网址 通过xpath定位页面元素，用于给selenium模块进行定位：
1）选择需要定位的网页位置——搜索框，鼠标右键然后点击检查
2）确认位置
3）鼠标右键 —— Copy —— Copy full Xpath
得到的xpath元素：
/html/body/div[1]/div[1]/div[5]/div/div/form/span[1]/input 使用所得到的xpath元素
#在搜索框输入“CSDN” dr.find_element_by_xpath("/html/body/div[1]/div[1]/div[5]/div/div/form/span[1]/input").send_keys("CSDN") 接着查找下一个需要定位的网页位置——百度一下，方法同上，得到xpath元素
得到的xpath元素：
/html/body/div[1]/div[1]/div[5]/div/div/form/span[2]/input 使用所得到的xpath元素
#点击“百度一下”按钮 dr.find_element_by_xpath("/html/body/div[1]/div[1]/div[5]/div/div/form/span[2]/input").click() 接着查找下一个需要定位的网页位置——CSDN官网，方法同上，得到xpath元素
得到的xpath元素：
/html/body/div[1]/div[3]/div[1]/div[3]/div[1]/h3/a[1] 使用所得到的xpath元素
#进入CSDN官网 dr.find_element_by_xpath("/html/body/div[1]/div[3]/div[1]/div[3]/div[1]/h3/a[1]").click() 最后关闭浏览器
dr.quit() 完整代码：
from selenium import webdriver #引用selenium模块 dr= webdriver.Chrome() #启动浏览器为谷歌浏览器 dr.get("https://www.baidu.com/") #打开网址 #在搜索框输入“CSDN” dr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1c3125efd392d198d4e3364e547192b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24ae16fdd8b144e8c5afeac1f3d404b7/" rel="bookmark">
			【2019/IJCAI】AddGraph: Anomaly Detection in Dynamic Graph Using Attention-based Temporal GCN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章链接：https://www.ijcai.org/Proceedings/2019/0614.pdf
源码链接：未公布
TL;DR 论文结合GNN提出了动态图中半监督的边异常检测模型 AddGraph，同时考虑了节点的结构，属性和时序特征。对于标签数据不足的问题，在训练过程中采用了 negative sampling 和 margin loss 两个技巧。在两个真实数据集的实验中取得了较好的效果。
Problem Definition 论文中的方法主要用于推荐系统中的异常操作检测，举个例子：异常的用户想自己的物品被推荐，那怎么办，那就找几个人疯狂点自己的东西的同时点那些本身就已经是popular的item，这样就会让自己的物品和popular的有相似的特征等，就会增加这些物品的被推荐的rank。这同时会产生很多新的edge，这些都是异常的edge。如下图所示：
异常模式特征：当异常的用户频繁执行操作时，用户和物品间的边会组成一个 dense subgraph，这种异常的特征模式就需要被检测出来；
Algorithm / Model AddGraph 的整体架构如下图所示：
主要分为三部分：
GCN for content and structural features.GRU with attention to combine short-term and long-term states.Anomalous score computation for edges. GCN 给定 t t t 时刻图流中的一个 snapshot G t = ( V t , E t ) \mathcal{G}^{t}=\left(\mathcal{V}^{t}, \mathcal{E}^{t}\right) Gt=(Vt,Et) 、对应的邻接矩阵 A t A^t At 和 t − 1 t-1 t−1 时刻的节点隐含状态矩阵 H t − 1 ∈ R n × d \mathbf{H}^{t-1} \in \mathbb{R}^{n \times d} Ht−1∈Rn×d，那么当前时刻的节点状态矩阵可以通过 GCN 来更新，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24ae16fdd8b144e8c5afeac1f3d404b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf84dd04fc5ce7252e85041a8c0a1b9c/" rel="bookmark">
			【2015/IE】Variational Autoencoder based Anomaly Detection using Reconstruction Probability
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文首发于个人站点：基于变分自编码器重构概率的异常检测模型
个人公众号：「DreamHub」
文章链接：Variational Autoencoder based Anomaly Detection using Reconstruction Probability
源码链接: https://github.com/Michedev/VAE_anomaly_detection
论文总体结构
Abstract 提出了一种基于重构概率的异常检测方法可变自动编码器。
IntroductionBackgroud
2.1 Anomaly detection：介绍异常检常用几个方法。
2.2 Autoencoder and anomaly detection: 介绍自编码器(autoencoder) 如何进行异常检测。
2.3 Variational Autoencoder：介绍 VAE 的核心内容、VAE 与 AE 的区别 以及 VAE 训练算法。Proposed method
3.1 Algorithm： 总体介绍基于 VAE 模型的异常检测算法。
3.2 Reconstruction Probability：介绍上述算法中用的 reconstruction probability。
3.3 Difference from an autoencoder based anomaly detection： 介绍两种算法的区别。Experimental Results
实验部分用到了两个数据集 KDD cup 1999 与 MNIST，并与其他算法进行的比较。 1. Introduction 内容包括：
三两句介绍异常的定义、异常检测的意义。从光谱异常检测技术中引出基于重构误差的检测方法，并指出基于 PCA 的方法属于这种方法。从降维的角度引出自编码器(Autoencoder)，并说明这样的好处：更好提取特征、更高的隐藏层能够获取一些抽象特征。提出基于 VAE 的异常检测算法，并说明其优点：与自动编码器和PCA相比，VAE的优势在于它提供了一个概率度量，而不是作为异常分数的重建误差，我们称之为重建概率。概率比重建误差更具原则性和客观性，不需要模型特定的阈值来判断异常。 2 Background 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf84dd04fc5ce7252e85041a8c0a1b9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f706ad080dfc64898e6356cb86e872/" rel="bookmark">
			次短路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 次短路径求次短路的方式1、起点终点各跑一遍最短路，然后枚举中间点 2、边更新最短路边记录次短路 次短路径 求次短路的方式 顾名思义,就是除最短路最外的最短路径，求次短路的方法一般有两种，第一种是从起点跑一遍最短路，终点跑一遍最短路，然后枚举中间点，第二种则是在求最短路时顺便去维护次短路，下面将分别进行详细说明
下面代码都是以poj3255作为例题传送门
1、起点终点各跑一遍最短路，然后枚举中间点 先说一个结论，节点x到节点y的次短路可以看作
min( mindis(x,k1) + length(k1,k2) + mindisn(k2,y) ) &amp;&amp; != dis(x,y)
这里的miindis为x到各点的最短路径,mindisn为y到各点的最短路径，也就是说，我枚举每一条边，然后加上起点到这个边的一点的最短路径 + 终点到这个边另一点的最短路径，找到最小且不等于最短路的路径即为次短路径，但是注意，这种做法仅限于无向图，因为我们默认终点到各个点的最短路也是各个点到终点的最短路径，而且这种方式还是比较消耗时间的，毕竟要跑两遍最短路
code
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; typedef long long ll; const int inf = 0x7fffffff;//用于比较 const int INF = 0x3f3f3f3f;//用于计算 const int maxn = 5e5 + 5; const int mod = 1e9 + 7; const int dir8[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; const int dir4[4][2] = {{-1,0},{1,0},{0,-1},{0,1}}; struct node { int v,w,next; }edge[maxn &lt;&lt; 2]; int head[maxn],cnt,n,m; int dis[maxn],dis2[maxn],disn[maxn]; void addedge(int a,int b,int val) { cnt++; edge[cnt].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f706ad080dfc64898e6356cb86e872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/360d7164205c069474694e49d8c2012d/" rel="bookmark">
			SAP 中System ID / Aplication server / Instance / Client的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAP 系统的组成部分：
1）、数据库
2）、一个或多个应用服务器实例( java / abap ) instance
3）、中央服务实例( central services )，一般是消息服务器message server，或者enquene 服务器；
每个系统都有唯一的系统标识，进入用户的windows安装目录，使用系统变量%windir%可以确定具体位置,找到文件sapmsg.ini文件，文件内容格式如下： [Message Server] PRD=192.168.0.26，PRD就是System ID，后面则是IPV4的地址。
应用服务器实例-Aplication server instance：SAP系统的代码运行在SAP应用服务器实例上,是一台物理的服务器,上面除了操作系统,还有SAP Netweaver 这套平台级别的软件。应用服务器可以通过工具启动，关闭和控制。每个应用服务器实例通过主机号、系统标识和实例号组合成为标识，
应用服务器实例按照用途分为不同类型：
1）、ABAP服务器实例：运行SAP系统ABAP代码的服务器，进行不同的工作进程，如：对话进程、后台JOB、打印任务等。
2)、ABAP SAP Central Services instances( ASCS )-中央服务实例，每个SAP系统可以由多个ABAP服务器实例组成，但只能有一个ASCS实例，每个中央服务实例包含一个消息服务器和一个Enequeue服务器，前者用于协调多个ABAP服务器的通信和负载均衡，后者负责SAP业务中锁的管理。 如下图：
根据SAP系统功能的不同，还存在其他可选的应用服务器实例，比如专注于企业级搜索实现(Enterprise Search)的TREX服务器实例，以及Web Dispatcher实例等等。
组登陆和客户登陆的区别：
当我们选择组登陆的时候，选择的System ID会自动带出message server的地址，如果带不出就是未配置消息服务器，请更改sapmsg.ini文件，选择了System ID选择Group/Server出现乱码报错，是system32\drivers\etc下的service文件出错，找别人能用的拷贝一下。
不同的System ID都连接的是同一个message server，同一个host。
不同的系统标识代表着在ERP不同的环境：PRD/DEV/QAS等，但是PRD可以拥有多台不同的应用服务器实例，这样其中一台应用服务器死机不会影响其他服务器，同时message server控制着这些实例之间的负载平衡。
使用事务码：SM51,可以查看应用服务器实例的名称和主机名，当前登录的以01结尾。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9da234d38e5ea468129325a0485f26/" rel="bookmark">
			软件工程法律法规_本科软件工程论文答辩问题及回答解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文答辩是毕业前的最后一项程序，只有顺利通过答辩审核，才能获得毕业证书。那么如何才能通过答辩考验呢？
答辩评审老师会提出哪些问题呢？如何正确回答老师提问呢？
本文以“软件工程本科论文答辩问题及回答解析“为例，为同学们总结了23个常见问题及回答模板，助你顺利通关。　一、软件工程本科论文答辩问题汇总
1、你的软件工程论文采用了哪些与本专业相关的研究方法？
2、论文中的核心概念是什么？用你自己的话高度概括。
3、你选题的缘由是什么？研究具有何种现实指导意义？
4、论文中的核心概念怎样在你的文中体现？
5、从反面的角度去思考：如果不按照你说的那样去做，结果又会怎样？
6、论文的理论基础与主体框架存在何种关联？最主要的理论基础是什么？
7、质性研究与访谈法、定性研究、定量研究、调查研究、实证研究的区别？
8、经过你的研究，你认为结果会是怎样？有何正面或负面效果？
9、你的论文基础何种研究视角？是管理学、教育学、心理学还是社会学视角？
10、论文研究的对象是个体还是群体？是点的研究还是面的研究？
11、研究的应然、实然、使然分别是什么？
12、论文中的结论、建议或策略是否具有可行性和操作性？
13、研究对象是否具有可比性？研究框架是否符合论文规范（而不是写书的逻辑）！
14、自己为什么选择这个课题？
15、研究这个课题的意义和目的是什么？
16、全文的基本框架、基本结构是如何安排的？
17、全文的各部分之间逻辑关系如何？
18、在研究本课题的过程中，发现了那些不同见解？对这些不同的意见，自己是怎样逐步认识的？又是如何处理的？
19、论文虽未论及，但与其较密切相关的问题还有哪些？
20、还有哪些问题自己还没有搞清楚，在论文中论述得不够透彻？
21、写作论文时立论的主要依据是什么？
22、论文和系统有哪些不足之处？
23、论文有何创新之处？
二、如何回答论文答辩中的问题？
下面挑选了9个导师最爱问的、提问频率最高的问题，做出解析：　1、选择这个课题的原因是什么？
回答解析：首先从主观入手，每篇论文都对应着相应的专业，可从当前该专业的社会大致情况来简要分析，其次可以结合自己的实习经历来分析（实习过程中对该专业有了更深的社会认识，发现了一些问题等），最后，可以说是与指导老师进行深入沟通交流后选择该课题。　2、该课题研究的意义和目的？
回答解析：这一问题一般在开题中就有提及，正文中也有相关小节说明，只需要对其加以总结提炼即可，需要注意的是，一定要逻辑清楚，条理分明，不可想到哪儿说到哪儿，东拼西凑会给考核老师留下不好的印象。　3、全文基本结构、框架是怎么设计的？
回答解析：该问题的回答并非是让您将论文大纲讲述一遍，而是对整个文章的一个综合说明，比如：全文按照“总--分--总”的结构展开论述，开头从总体上论述XXXX的特点等大背景，之后“提出XXXXX问题”,再根据问题提出XXXXX对策，最后是总结陈述，各部分相互间存在逻辑联系，相互配合，成为整体的有机组成部分（该结构是最为常见的结构，您需要依照自身文章实际情况做具体分析）　4、全文各个部分之间的逻辑关系是怎样的？
回答解析：该问题的回答与论文大纲相结合，比如：全文的逻辑关系是，首先交代大背景--对XXX现状加以论述说明--提出XXX当前存在的问题--分析原因--提出相应的对策建议--对全文进行总结说明　5、在研究该课题过程中，是否发现了不同的见解？自己是如何逐步认识这些见解的？又是进行处理的？
回答解析：该问题切忌回答“并未发现不同见解”.首先必须要肯定，对于该课题存在诸多不同的见解（此处需要对各类不用见解加以总结阐述，分列成条，比如传统观念认为XXXXXXX,现代观念认为XXXXX），其次，阐明自己是如何看待这些不同见解的（记住，不能完全否定或肯定某一种见解，各个不同见解都提出一些自己的看法，不管对错，只要不离谱即可），最后，处理不同见解，一是在论文写作中是怎么处理的（你是用什么“见解”,也就是理论作为理论基础展开研究的），二是自己在平常学习研究中如何处理（依旧不能完全肯定或否定某一种见解，取其精华去其糟粕！）　6、课题研究中有那些问题是没有涉及的，但却是与课题研究密切相关的？
回答解析：任何一篇文章，无论字数多少，不可能将所有涉及到的问题全部研究清楚，所以，需要您选择一到两个和该课题联系紧密的问题，并对其做精简的概述（概述，不是长篇大论，一定要精简）　7、还有什么问题是你自己还未研究透，论文研究还不够深入透彻的？
回答解析：该问题需要您结合自己文章的实际情况来回答（但注意和问题分开），该问题是论文已经提到或已经进行了相关说明，但不够深入！（这是考核老师想知道您是否对自己的研究课题有一个正确的认识）　8、该课题研究的创新点是什么？
回答解析：创新点一般来说有两种，第一种：该课题之前从未有人研究过；第二种：该课题的研究切入点、视角独特（一般来说，大部分的论文创新点都是第二种，结合自己论文实际情况，有逻辑，有条理的说明即可）　9、该课题研究存在哪些不足？
回答解析：该问题的回答可结合问题展开，按照以下步骤：第一，XXXXX;第二，XXXXX.（如果实在不知道，那么可以结合其它专业来说，比如您是软件工程专业，那么肯定要涉及到专业计算机知识，您可以说“由于对计算机专业知识学习欠缺，在研究过程中XXX部分还有待进一步深入研究”等，因为任何论文的写作，都必须要涉及到其它专业的知识点，独木不成舟）
三、软件工程本科论文答辩前的准备
学员要想顺利通过答辩，并在答辩时真正发挥出自己的水平，就必须在论文答辩前做好充分的准备。　1、提交相关材料
答辩学员在论文答辩前半个月，将经过指导老师审定并签署过意见的毕业论文终稿一式三份、开题报告、实践指导过程记录（即网上设计指导交流系统发言帖子页面，无需打印内容）等材料交给答辩委员会。　2、调整好心态
学员在答辩前，要做好充分心理准备，正确估计自己，克服盲目自卑、紧张、胆怯心理，树立自信心。只有充满自信，沉着冷静，才会在答辩时有良好的表现。　3、携带必要的资料和用品
学员参加答辩，要准备好参加论文答辩所需携带的资料和用品：
（1）论文终稿
（2）主要参考资料
（3）记录用稿纸和笔　4、列出论文答辩的简要提纲
在论文答辩前，学员应该反复阅读、审查自己的论文，列好论文答辩的简要提纲。论文答辩提纲包括选题的意义、论文的结构安排、论文的主要论点、论据、写作体会等。提纲尽量简洁明了，列出框架、要点即可。　5、全力消化自己所写的论文
首先，熟悉主体部分和结论部分的内容，掌握论文的基本观点和主论的基本依据；其次，明确论文中所使用主要概念的确切涵义，以及所运用基本原理的主要内容；再次，仔细审查、反复推敲文章中有无谬误、片面、模糊不清甚至是自相矛盾之处，有无与党的方针政策和国家法律法规相抵触的内容等。6、了解和掌握与自己所写论文相关联的知识和材料
如自己所研究的这个论题学术界的研究已经达到了什么程度？目前存在着哪些争议？有几种代表性观点？各有哪些代表性着作和文章？自己倾向哪种观点及理由？重要引文的出处和版本；论证材料的来源渠道；论文的主要参考文献等。　7、弄清论文还有哪些应该涉及或解决但因力所不及而未能论及的问题
对这些内容，学员答辩前都要认真思考、并有所准备，这样在答辩时就可以做到心中有数，从容作答。　8、弄清自己论文的弱处
毕业答辩前，学员还要对自己论文中的弱点问题，要做到心中有数，在思想上和材料上加以准备。答辩时如果答辩教师针对这类弱点问题提问，学员就能沉着应对，深入阐述，在一定程度上弥补论文的不足。　9、事先做好“答辩预习”
学员可根据论文内容，设想五六个问题，采取自问自答的方式，自我检验，对论文基本观点能作脱稿复述，对论文所涉及的相关问题应有一个大致的估计和相应的准备。坚信熟能生巧，功到自然成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d9da234d38e5ea468129325a0485f26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90b247c9d644c8a1dd625d898c3cd64/" rel="bookmark">
			不可重复读和幻读有什么区别区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、不可重复读 在同⼀个事务中执⾏同⼀个读取操作,但是结果不⼀致。
二、幻读 同样的事务操作，在前后两个时间段内执⾏对同⼀个数据项的读取，可能出现不⼀致的结果。
tip：不可重复读和幻读两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。
三、使用锁机制解决问题 3.1 使用悲观锁机制解决这两种问题
在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会 发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。
3.2 使用乐观锁机制解决这两种问题
在MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。
乐观锁：
相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。乐观锁大多是基于数据版本（ Version ）记录机制实现，也有部分使用CSA机制实现。 数据版本：
一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数。当线程A要更新数据值时，在读取数据的同时也会读取version值，当数据被修改时，version值会加一，在提交更新时，若刚才要提交的数据版本号大于数据库表当前版本号时才会更新，否则认为是过期数据。 tip： MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。
CAS算法
即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数
需要读写的内存值 V，进行比较的值 A，拟写入的新值 B
当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956b6e9b0f3d1ad697609b949041d48b/" rel="bookmark">
			springboot-mybatis常用方法整理（like&#43;转义&#43;批量新增sql组装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.like &lt;select id="selectByCondition" resultMap="BaseResultMap"&gt; &lt;if test=" supplierName != null "&gt;&lt;bind name="namecnd" value="'%' + _parameter.supplierName + '%'" /&gt;&lt;/if&gt; &lt;if test=" address != null "&gt;&lt;bind name="addresscnd" value="'%' + _parameter.address + '%'" /&gt;&lt;/if&gt; select &lt;include refid="Base_Column_List" /&gt; from onecity_supplier where isdelete =0 &lt;if test=" supplierName != null "&gt; and supplier_name like #{namecnd} &lt;/if&gt; &lt;if test=" address != null "&gt; and address like #{addresscnd} &lt;/if&gt; &lt;if test=" creator != null "&gt; and creator = #{creator} &lt;/if&gt; &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/956b6e9b0f3d1ad697609b949041d48b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10c836164b248b743c7a09035d8adde/" rel="bookmark">
			vue中的router-view父子组件传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		router-view父子组件传参 一、父组件传值给子组件二、子组件往父组件传值 一、父组件传值给子组件 父组件传递：
&lt;router-view :projectId="projectId"&gt;&lt;/router-view&gt; 在data里存储的参数
data(){ return { projectId:'xxxxxxxx' } } 子组件接收:
export default { props:['projectId'], watch: { projectId: function (val) { console.log(val); // 接收父组件的值 } }, } 二、子组件往父组件传值 子组件传值:
this.$emit('updateProjectId','xxxxxx') 父组件接收
&lt;router-view class="systemContent" @updateProjectId="updateProjectIdParent"&gt;&lt;/router-view&gt; 注意：子组件发送的updateProjectId方法要与父组件绑定的updateProjectId方法同名
updateProjectIdParent(msg){ this.selectArr.push(msg) }, 这样一个简单的router-view父子传值就完成了，其实router-view父子组件传值与普通的组件一样，只是让人迷惑，认为这是路由组件可能会有所不同。所以碰到拿捏不定，可以大胆的去尝试~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3653876d88683dfd2b0aabf16c8729ec/" rel="bookmark">
			环境变量path不小心删掉如何恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境变量path不小心删掉恢复方法： 1. 快捷键“windows+r”调出“运行窗口”。
2.输入"regedit"并点击“确认”。
路径：计算机\HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment
3. 打开注册表编辑器，点击“HKEY_LOCAL_MACHINE”。
4.点击 “SYSTEM”。
“
5. 点击“ControlSet001”。
6. 点击“Control”。
7. 点击“Session Manager”。
8.点击“Environment”找到右边的“path”。
9. 然后点击path右键鼠标，点击“修改”。
10. 复制数值数据。
11. 然后在系统变量中新建path将复制内容粘贴到变量值，然后确认。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9891f80bb40c6957794406f4b8a50fcb/" rel="bookmark">
			桥接模式和路由模式区别_光猫如何修改为桥接模式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，进入到光猫里面需要用到光猫的超级账户和超级密码才能到登录到如下文所示的页面。
提示：不建议大家随意改参数哈，如果不懂光猫里面的参数则不要随意改动，保持默认就行，一旦改不正确或错误改动，则直接影响上网，直接会导致无法上网、看电视。
光猫上网有两种方式：
(1)桥接
(2)路由
1.简单的来说，如果将光猫配置为第一种方式“桥接”，则路由器的上网方式需要配置为“pppoe拨号”(输入运营商的宽带账号和密码)。
2.如果配置为第二种方式--“路由”方式，则路由器需要将上网方式设置为“动态ip”上网，这样路由器就能从光猫获取到ip地址，即可上网。
当然也可以关闭光猫的dhcp服务器，则路由器就需要设置“静态ip上网”。
详细：很喜欢这个数字，光猫路由器这么玩比较有意思！
光猫(路由模式)：
这两种模式可以互换，觉得喜欢哪种就用哪种
其实，我感觉俩种没什么区别，唯一一点就是，不用宽带账号密码拨号，在某些情况下是非常好的。
比如，家里路由器坏了，换一个也方便，直接插上就行，如果是路由器拨号则还需要输入宽带账号和密码，则如果忘记了宽带账号和密码，则可能会影响上网。
再次提醒，不懂参数，请勿所以改动哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab8eb51b3e3a3bd17aa2b7c60a69f60d/" rel="bookmark">
			数学绘图工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数学绘图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d758bdcfefe874cf1ef0c5bb659c4ace/" rel="bookmark">
			一分钟将Vue移动端项目一键打包成app（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语：
在vue项目开发完成后，我们就可以把项目打包成一个手机app，是不是很神奇，而且是一键生成，不需要操作。
1，把vue项目打包成dist目录 我们先将项目目录下config文件内index.js中
assetsPublicPath修改为 assetsPublicPath: ‘./’
然后打包成dist文件夹，在cmd输入以下命令
npm run build 1 你就可以得到下面这个文件夹
2，下载Hbuilder 地址：http://www.dcloud.io/
然后在Hbuilder中打开dist目录，我们可以得到下图
3，打包成app 接着我们右击这个dist目录，选择转化为移动app
这时候就会出现一个manifest.json，点击
这里你可以选择启动图配置，选择你喜欢的启动图，也可以跳过。
大部分的设置都可以默认，跳过
最后
对了，因为vue项目没办法检测这个手机物理返回键，所以我们可以在index.html文件中修改一下，很简单
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=utf-8&gt;&lt;meta name=viewport content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"&gt;&lt;title&gt;123&lt;/title&gt;&lt;link href=./static/css/app.8203cae5dd59c366dbd3e59555e22b0b.css rel=stylesheet&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=app&gt;&lt;/div&gt;&lt;script type=text/javascript&gt;document.addEventListener('plusready', function(a) { //等待plus ready后再调用5+ API： 在这里调用5+ API var first = null; plus.key.addEventListener('backbutton', function() { //监听返回键 //首次按键，提示‘再按一次退出应用’ if (!first) { first = new Date().getTime(); //获取第一次点击的时间戳 // console.log('再按一次退出应用');//用自定义toast提示最好 // toast('双击返回键退出应用'); //调用自己写的吐丝提示 函数 plus.nativeUI.toast("双击退出", {duration:'short'}); //通过H5+ API 调用Android 上的toast 提示框 setTimeout(function() { first = null; }, 1000); } else { if (new Date().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d758bdcfefe874cf1ef0c5bb659c4ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ffe0b4af4211b64a034d24bfbd529a6/" rel="bookmark">
			【Git/Github】向已有仓库上传文件/文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 已有仓库：
文章目录 一、直接拖动文件上传1. 打开远程仓库点击upload2. 点击或拖动文件/文件夹上传 二、通过git命令上传第一种：在原本地仓库新增的文件1. 初始化2. 将新增的文件/文件夹添加到暂存区3. 提交暂存区到本地git仓库4. 推送到远程仓库5. 刷新github页面即可 第二种：在其它文件夹内的文件1. 初始化2. 下载远程仓库的代码，并合并3. 将新增的文件/文件夹添加到暂存区4. 提交暂存区到本地git仓库5. 创建并切换分支（要和远程仓库一致）6. 将本地库添加到远程库（本地库与远程库建立连接）7. 推送到远程仓库8. 刷新页面即可 一、直接拖动文件上传 1. 打开远程仓库点击upload 2. 点击或拖动文件/文件夹上传 二、通过git命令上传 第一种：在原本地仓库新增的文件 1. 初始化 2. 将新增的文件/文件夹添加到暂存区 3. 提交暂存区到本地git仓库 4. 推送到远程仓库 5. 刷新github页面即可 第二种：在其它文件夹内的文件 1. 初始化 2. 下载远程仓库的代码，并合并 3. 将新增的文件/文件夹添加到暂存区 4. 提交暂存区到本地git仓库 5. 创建并切换分支（要和远程仓库一致） 6. 将本地库添加到远程库（本地库与远程库建立连接） 7. 推送到远程仓库 8. 刷新页面即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6b6330a37601432602719ed6eafd60/" rel="bookmark">
			python 时间相减_python处理时间加减
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用python做数据统计分析时，原始日志文件中用户访问的时间不对，
需要往后延8小时，记录一下：&gt;&gt;&gt; import datetime
&gt;&gt;&gt; pageTime = ‘2014-05-11 16:44:12‘
&gt;&gt;&gt; pageTime
‘2014-05-11 16:44:12‘
1.把pageTime字符串类型转换成datetime时间类型：&gt;&gt;&gt; dt = datetime.datetime.strptime(pageTime, "%Y-%m-%d %H:%M:%S")
&gt;&gt;&gt; dt
datetime.datetime(2014, 5, 11, 16, 44, 12)
2.把dt加上8小时：&gt;&gt;&gt; d = dt + datetime.timedelta(hours=8)
&gt;&gt;&gt; d
datetime.datetime(2014, 5, 12, 0, 44, 12)
3最后把datetime类型的时间转换成字符串类型的时间：&gt;&gt;&gt; nTime = d.strftime("%Y-%m-%d %H:%M:%S")
&gt;&gt;&gt; nTime
‘2014-05-12 00:44:12‘
原文：http://xieyusong.blog.51cto.com/4615779/1410610
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d067007e9fdb96f5502d75f8fbc02e/" rel="bookmark">
			微博原生视频统一文件服务接口文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		discovery 接口说明：统一文件服务根据上传类型分配初始化init、上传upload、重试check接口及bypass属性
接口地址：
http://i.multimedia.api.weibo.com/2/multimedia/discovery.json
请求参数：
参数名是否必须类型参数说明uidYLong上传用户IDstatusNString网络环境typeYString上传文件类型， 'video';'pic';'image'sizeYLong上传文件大小， 单位B 请求HEADER参数：
参数名是否必须类型参数说明UANString客户端型号 返回结果：
类型：json返回值： key类型说明init_urlString根据上传类型分配的init地址upload_urlString根据上传类型分配的upload地址check_urlString根据上传类型分配的check地址bypassStringbypass类型 示例：
succ:
{"init_url":"http://multimedia.api.weibo.com/2/multimedia/init.json","upload_url":"http://multimedia.api.weibo.com/2/multimedia/upload.json","check_url":"http://multimedia.api.weibo.com/2/multimedia/check.json","bypass":"multimedia.video"} {"error":"miss required parameter (zise), see doc for more info.","error_code":10016,"request":"/2/multimedia/discovery.json","http_code":400} init 上传初始化 接口说明： 通过上传文件信息换取分配的上传ID以及分片大小
接口地址：
http://i.multimedia.api.weibo.com/2/multimedia/init.json
请求参数：
参数名是否必须类型参数说明typeYString上传文件类型， 'video';'pic';'image'checkYString上传文件MD5lengthYLong上传文件大小nameYString上传文件名称createtypeNString上传文件来源， 拍摄上传: 'shooting'; 本地文件上传：'localfile'uidYLong上传用户IDstatusNString网络环境 请求HEADER参数：
参数名是否必须类型参数说明UANString客户端型号 返回结果：
类型：json返回值： key类型说明urlTagString“1”， 兼容旧协议保留fileTokenString分配的uploadIdlengthLong分配的分片大小， 单位KB 示例： succ:
{"urlTag":"1","fileToken":"1408178459.447.fff3b5d66e54fa4c2bdf43f8348d5.r11833","length":64} fail:
{"error":"miss required parameter (name), see doc for more info.","error_code":10016,"request":"/2/multimedia/init.json","http_code":400} upload分片上传 接口说明：根据init分配的filetoken和分片大小， 分片上传文件，文件上传完整后， 自动进行合并、转码、发微博操作
接口地址：
http://i.multimedia.api.weibo.com/2/multimedia/upload.json
请求参数：
参数名是否必须类型参数说明uidYLong上传用户IDstatusNString网络环境filetokenYStringinit分配的上传IDstartlocYLong分片在文件中的起始字节ksectioncheckYString分片MD5 返回结果：
类型：json返回值： key类型说明succString分片上传结果："true" 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8d067007e9fdb96f5502d75f8fbc02e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4388ad1a8c628d7e73b09cfa376ed68c/" rel="bookmark">
			机器学习基础环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 机器学习基础环境搭建 新建AI虚拟环境 机器学习基础阶段会用到Matplotlib、Numpy、Pandas等库，为了统一版本号在环境中使用，将所有的库及其版本放到了文件requirements.txt当中，然后统一安装
新建AI虚拟环境 mkvirtualenv ai requirements.txt
matplotlib==2.2.2 numpy==1.14.2 pandas==0.20.3 tables==3.4.2 jupyter==1.0.0 每个包安装的过程中，尽量指定稳定版本进行安装
安装
pip install -r requirements.txt 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced15179b7f949a2ca753d9f56d56e04/" rel="bookmark">
			C语言：使用函数统计指定数字的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个统计整数中指定数字的个数的简单函数。
函数接口定义：
int CountDigit( int number, int digit ); 其中number是不超过长整型的整数，digit为[0, 9]区间内的整数。函数CountDigit应返回number中digit出现的次数。
裁判测试程序样例：
#include &lt;stdio.h&gt; int CountDigit( int number, int digit ); int main() { int number, digit; scanf("%d %d", &amp;number, &amp;digit); printf("Number of digit %d in %d: %d\n", digit, number, CountDigit(number, digit)); return 0; } /* 你的代码将被嵌在这里 */ 输入样例：
-21252 2 输出样例：
Number of digit 2 in -21252: 3 int CountDigit( int number, int digit ) { int time=0; if(number&lt;0) //这里将负数全部转正，方便办事 { number*=-1; } do { if(number%10==digit) { time++; } number/=10; }while(number&gt;0);//这里用do whlie，当number==0时也可以让time++ return time; } 这题俺本来是用的whlie()，然后当number，digit全为0时，答案出错了。。慵懒滴俺又不想再加个if语句，于是就改成do while()啦(✪ω✪)！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6118dda4052dbdd8a91e8ebcc0d2b87/" rel="bookmark">
			local variable ‘xxx’ referenced before assignment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在函数外面定义了一个变量 ，然后在函数里面引用这个变量，并改变它的值。
可以使用全局变量关键字globle来解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478d13e6caf750c66a3e548779bf315f/" rel="bookmark">
			python描述对象静态特性的数据为_夫妻关系包括夫妻的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【填空题】锲而舍之,____________; ______________;______________。
【单选题】自顶向下设计主要由下列哪个语法元素实现? ‪‪‪‪‪‪‫‪‪‪‪‪‪‫‪‪‪‪‪‫‫‪‪‪‪‪‪‪‪‪‪‪‪‫‪‪‪‪‪‪
【单选题】欲将两数中较小的数返回,应定义的匿名函数为:
【单选题】对于需要几个单位共同负担的一张原始凭证上的支出,应根据其他单位负担部分为其提高( )。
【单选题】关于文件关闭的 close() 方法,哪个选项的描述是正确的? ‪‪‪‪‪‪‫‪‪‪‪‪‪‫‪‪‪‪‪‫‫‪‪‪‪‪‪‪‪‪‪‪‪‫‪‪‪‪‪‪
【多选题】当事人请求返还按照习俗给付的彩礼的,人民法院应当予以支持的情形有 ( )
【单选题】关于大括号 {} ,以下描述正确的是:
【单选题】以下关于 Python 函数说法错误的是: ‪‪‪‪‪‪‫‪‪‪‪‪‪‫‪‪‪‪‪‫‫‪‪‪‪‪‪‪‪‪‪‪‪‫‪‪‪‪‪‪ def func(a,b): c=a**2+b b=a return c a=10 b=100 c=func(a,b)+a
【单选题】下列选项中,哪一项不是面向对象程序设计的基本特征:
【单选题】k = 10 while k &gt; 1 : print (k) k -=1 哪个选项给出了上述程序的循环次数? ‪‪‪‪‪‪‫‪‪‪‪‪‪‫‪‪‪‪‪‫‫‪‪‪‪‪‪‪‪‪‪‪‪‫‪‪‪‪‪‪
【单选题】The couple wanted to adopt the black boy they had been _______.
【单选题】哪个选项不能改变 turtle 画笔的运行方向? ‪‪‪‪‪‪‫‪‪‪‪‪‪‫‪‪‪‪‪‫‫‪‪‪‪‪‪‪‪‪‪‪‪‫‪‪
【单选题】根据我国《婚姻法》的规定,请求变更抚育费的权利主体是 ( )
【填空题】积土成山,________;____________,______________。
【单选题】李军于 1990年与孙静结婚,1991年李军以个人名义向其弟借款10万元购买商品房一套,夫妻共同居住。2003年,李军与孙静离婚。李军向其弟所借的钱,离婚时应如何处理?( )
【多选题】关于婚姻成立的形式要件,当代各国有不同的立法例,其种类主要有 ( )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/478d13e6caf750c66a3e548779bf315f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c90961bf87b34309de3edf612012d48/" rel="bookmark">
			防火墙USG6000-eNSP基础配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防火墙USG6000-ENSP基础配置
以USG6000为例，通过真机浏览器来登录该防火墙web管理界面。
一、防火墙搭建
1、打开eNSP，拖一台USG6000V
2、开机，会弹出“导入设备包”对话框
3、将USG6000V.zip解压后，进行添加即可
4、导入设备包后，就可以正常启动了，开机时间比较长，耐心等待
二、首先配置虚拟网卡
三、eNSP中新建拓扑左边设备栏目中找到云Cloud拖到右边空白处，对云右键设置配置如下：
**注意：**是先增加一个端口，邦定信息为UDP，再加一个端口，邦定信息为配置好的虚拟网卡，端口映射设置双向通道。
四、拖出一个USG6000V的防火墙，做基础配置
步骤1：用防火墙的GigabitEthernet0/0/0 端口和云连接，启动防火墙，进入视图。
注意：防火墙启动后需要输入用户名，默认用户名是admin密码Admin@123
步骤2：登录成功后，提示更改密码：选择“y”，进入更改密码的配置中，更改密码为：admin@123
步骤3：与could相连的接口（g0/0/0）配置IP地址
&lt;USG6000V1&gt;system-view //进入系统视图模式
Enter system view, return user view with Ctrl+Z.
[USG6000V1]int g0/0/0 //进入接口g0/0/0
[USG6000V1-GigabitEthernet0/0/0]ip add 192.168.110.2 24 //配置与cloud同网段的IP地址
检查IP地址配置信息
步骤4：物理机ping防火墙的IP地址（192.168.110.2），无法ping通，因为是防火墙接口IP，需要配置相应策略方可ping通
步骤5：开启防火墙的WEB服务及检查
[USG6000V1]web-manager enable //默认web服务已启用
[USG6000V1]display arp //查看是否有arp信息
[USG6000V1]display ip in brief 确保GigabitEthernet0/0/0的IP是192.168.110.2/24
，且两个端口的状态都为up，物理主机ping192.168.110.2测试不通，反馈请求超时request timeout，解决方案：
[USG6000V1]interface GigabitEthernet 0/0/0 //进入该接口
[USG6000V1-GigabitEthernet0/0/0]service-manage ping permit //此接口允许PING通过
[USG6000V1-GigabitEthernet0/0/0]service-manage enable
测试：物理机ping防火墙
[USG6000V1]interface GigabitEthernet 0/0/0
[USG6000V1-GigabitEthernet0/0/0]service-manage https permit //启用的HTTPS服务
注：以上配置，可以通过web访问防火墙USG6000了，在真实主机浏览器的地址栏上输入https://192.168.110.2:8443/来登录防火墙web管理界面（建议采用谷歌、火狐浏览器访问）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c90961bf87b34309de3edf612012d48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/212d19af2082d0c468e55eeb46aacee3/" rel="bookmark">
			STC12程序烧录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STC12例程
STC12串口下载器
添加STC12系列选型
KEIL4IDE&amp;注册机
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d45d557dbb4b7e5bbfc7353ebd92ef2/" rel="bookmark">
			子网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题： 网络地址：192.168.10.0 子网掩码：255.255.255.128（/25） 解： 1.地址类型：c类 网络号位数：24 主机号位数：7 子网号位数：1 2.子网数=2^1=2 3.主机数=2^7-2=126 4.子网地址：192.168.10.0 192.168.10.128 5.广播地址：192.168.10.127 192.168.10.255 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e154a4106b14daa93267f48f62910c2/" rel="bookmark">
			package.json中^和~的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 webpack 项目的package.json 文件列出了项目所依赖的插件和库，同时也给出了对应的版本说明，但是在版本说明前面还有个符号：’^’（插入符号）和’~’（波浪符号），总结了下他们之间的区别：
例如：
‘~’（波浪符号）:他会更新到当前minor
version（也就是中间的那位数字）中最新的版本。放到我们的例子中就是：“exif-js”:
“~2.3.0”，这个库会去匹配更新到2.3.x的最新版本，如果出了一个新的版本为2.4.0，则不会自动升级。波浪符号是曾经npm安装时候的默认符号，现在已经变为了插入符号。‘^’（插入符号）: 这个符号就显得非常的灵活了，他将会把当前库的版本更新到当前major
version（也就是第一位数字）中最新的版本。放到我们的例子中就是：“vue”: “^2.2.2”,
这个库会去匹配2.x.x中最新的版本，但是他不会自动更新到3.0.0。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef2bdddff4c82ffad3597ecfeeedf152/" rel="bookmark">
			关于Java序列化的10个面试问题,总结的比较到位。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://www.msedt.com/infoflow/details/1057 面试一点通丨全球首个面试资源社区
大多数商业项目使用数据库或内存映射文件或只是普通文件， 来满足持久性要求， 只有很少的项目依赖于 Java 中的序列化过程。无论如何,这篇文章不是 Java 序列化教程或如何序列化在 Java 的对象， 但有关序列化机制和序列化 API 的面试问题, 这是值得去任何 Java 面试前先看看以免让一些未知的内容惊到自己。
对于那些不熟悉 Java 序列化的人, Java 序列化是用来通过将对象的状态存储到带有.ser 扩展名的文件来序列化 Java 中的对象的过程, 并且可以通过这个文件恢复重建 Java对象状态, 这个逆过程称为 deserialization。
什么是 Java 序列化？ 序列化是把对象改成可以存到磁盘或通过网络发送到其他运行中的 Java 虚拟机的二进制格式的过程, 并可以通过反序列化恢复对象状态. Java 序列化API给开发人员提供了一个标准机制, 通过 java.io.Serializable 和 java.io.Externalizable 接口, ObjectInputStream 及ObjectOutputStream 处理对象序列化. Java 程序员可自由选择基于类结构的标准序列化或是他们自定义的二进制格式, 通常认为后者才是最佳实践, 因为序列化的二进制文件格式成为类输出 API的一部分, 可能破坏 Java 中私有和包可见的属性的封装.
如何序列化？ 让 Java 中的类可以序列化很简单. 你的 Java 类只需要实现 java.io.Serializable 接口, JVM 就会把 Object 对象按默认格式序列化。 让一个类是可序列化的需要有意为之。 类可序列会可能为是一个长期代价， 可能会因此而限制你修改或改变其实现.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef2bdddff4c82ffad3597ecfeeedf152/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152528c6c15d80d1eed6b1e07189e501/" rel="bookmark">
			开发者营地 | Glide: 源码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文聚焦于Glide的源码，基于Glide4.11.0
一、简介 Glide的GitHub
Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。
1. 简单使用 1、添加依赖：
repositories { google() jcenter() } dependencies { implementation 'com.github.bumptech.glide:glide:4.11.0' annotationProcessor 'com.github.bumptech.glide:compiler:4.11.0' } 2、添加网络权限
&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 3、一句代码加载图片到ImageView
Glide.with(fragment).load(url).into(imageView); 稍微进阶一点的用法，参数设置
RequestOptions options = new RequestOptions() .placeholder(R.drawable.ic_launcher_background) .error(R.mipmap.ic_launcher) .diskCacheStrategy(DiskCacheStrategy.NONE) .override(200, 100); Glide.with(this).load(url).apply(options).into(imageView); 2. 对比 Glide：
多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video）生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求）高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力）高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半） Fresco：
最大的优势在于5.0以下(最低2.3)的bitmap加载。在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem区)大大减少OOM（在更底层的Native层对OOM进行处理，图片将不再占用App的内存）适用于需要高性能加载大量图片的场景 3. 进阶使用 关于Glide的详细使用请查看这个官方 中文文档，这里就不赘述了。
4. 源码详解综述 本文着重分析Glide的核心流程源码：
第二章分析Glide的核心流程：包括with()、load()和into()
Glide的其他部分源码后续在其他同系列文章中进行分析。
二、核心流程 Glide 默认是配置了内存与磁盘缓存的，所以这里我们先假设禁用内存和磁盘缓存，来分析核心流程。缓存相关的放到后面分析。
代码表示如下：
Glide.with(this) .load(url) .skipMemoryCache(true) // 禁用内存缓存 .diskCacheStrategy(DiskCacheStrategy.NONE) // 禁用磁盘缓存 .into(imageView); 1. with() with()有6个重载方法，均返回RequestManager，如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/152528c6c15d80d1eed6b1e07189e501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a4c181a35bd7cf5ccfaebe7ae0edf4/" rel="bookmark">
			Linux下网卡绑定 bond
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux下双网卡绑定
linux操作系统下双网卡绑定有七种模式。
现在一般的企业都会使用双网卡接入，这样既能添加网络带宽，同时又能做相应的冗余，可以说是好处多多。而一般企业都会使用linux操作系统下自带的网卡绑定模式，当然现在网卡产商也会出一些针对windows操作系统网卡管理软件来做网卡绑定（windows操作系统没有网卡绑定功能 需要第三方支持）。
一、 网卡绑定原理
多网卡绑定一方面能够提高网络吞吐量，另一方面也可以增强网络高可用。
从软件的角度来看，多网卡绑定实际上只需要提供一个额外的bond驱动程序即可，通过该虚拟网卡驱动程序可以将实际多块网卡屏蔽，对TCP/IP协议层而言只存在一个Bond网卡。
linux有七种网卡绑定模式：0. round robin，1.active-backup，2.load balancing (xor)， 3.fault-tolerance (broadcast)， 4.lacp， 5.transmit load balancing， 6.adaptive load balancing。
Linux 多网卡绑定网卡绑定mode共有七种(0~6) bond0、bond1、bond2、bond3、bond4、bond5、bond6常用的有三种
mode=0：平衡负载模式，有自动备援，但需要”Switch”支援及设定。
mode=1：自动备援模式，其中一条线若断线，其他线路将会自动备援。
mode=6：平衡负载模式，有自动备援，不必”Switch”支援及设定。
需要说明的是如果想做成mode 0的负载均衡,仅仅设置这里options bond0 miimon=100 mode=0是不够的,与网卡相连的交换机必须做特殊配置（这两个端口应该采取聚合方式），因为做bonding的这两块网卡是使用同一个MAC地址.
从原理分析一下（bond运行在mode 0下）：mode 0下bond所绑定的网卡的IP都被修改成相同的mac地址，如果这些网卡都被接在同一个交换机，那么交换机的arp表里这个mac地址对应的端口就有多 个，那么交换机接受到发往这个mac地址的包应该往哪个端口转发呢？正常情况下mac地址是全球唯一的，一个mac地址对应多个端口肯定使交换机迷惑了。所以 mode0下的bond如果连接到交换机，交换机这几个端口应该采取聚合方式（cisco称为 ethernetchannel，foundry称为portgroup），因为交换机做了聚合后，聚合下的几个端口也被捆绑成一个mac地址.我们的解 决办法是，两个网卡接入不同的交换机即可。mode6模式下无需配置交换机，因为做bonding的这两块网卡是使用不同的MAC地址。
七种bond模式说明：
第一种模式：mod=0 ，即：(balance-rr) Round-robin policy（平衡抡循环策略）
特点：传输数据包顺序是依次传输（即：第1个包走eth0，下一个包就走eth1….一直循环下去，直到最后一个传输完毕），此模式提供负载平衡和容错能力；但是我们知道如果一个连接或者会话的数据包从不同的接口发出的话，中途再经过不同的链路，在客户端很有可能会出现数据包无序到达的问题，而无序到达的数据包需要重新要求被发送，这样网络的吞吐量就会下降
第二种模式：mod=1，即： (active-backup) Active-backup policy（主-备份策略）
特点：只有一个设备处于活动状态，当一个宕掉另一个马上由备份转换为主设备。mac地址是外部可见得，从外面看来，bond的MAC地址是唯一的，以避免switch(交换机)发生混乱。此模式只提供了容错能力；由此可见此算法的优点是可以提供高网络连接的可用性，但是它的资源利用率较低，只有一个接口处于工作状态，在有 N 个网络接口的情况下，资源利用率为1/N
第三种模式：mod=2，即：(balance-xor) XOR policy（平衡策略）
特点：
基于指定的传输HASH策略传输数据包。缺省的策略是：(源MAC地址 XOR 目标MAC地址) % slave数量。其他的传输策略可以通过xmit_hash_policy选项指定，此模式提供负载平衡和容错能力
第四种模式：mod=3，即：broadcast（广播策略）特点：在每个slave接口上传输每个数据包，此模式提供了容错能力
第五种模式：mod=4，即：(802.3ad) IEEE 802.3ad Dynamic link aggregation（IEEE 802.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7a4c181a35bd7cf5ccfaebe7ae0edf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d69d2f8a7a0b5fbd09bc17f2797c09/" rel="bookmark">
			Mac下的winscp替代者 FileZilla
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Windows下做开发运维的小伙伴，应该有一部分像我这样喜欢 用 winscp去管理远程服务器的文件吧。图形化管理确时好用，界面布局也符合操作习惯。刚用Mac 不知道用sftp软件好。
方式一： Mac 下推荐使用 FileZilla 我找了一圈感觉用的比较舒服的就是这款软件了。
https://www.filezilla.cn/
特点：
易于使用多协议支持
FileZilla支持FTP、FTPS、SFTP等文件传输协议支持中文免费使用跨平台Windows下也可以用 使用简介 方式二： Intellj IDEA 自带 如果你电脑上已经安装IDEA那么可以使用这种方式。我偶尔也会用，多一种选择。如果你也是coder可以用这个，功能也很强大，甚至可以自动上传，自动部署项目。这里就不展开了，有兴趣自己研究吧，这里只是告诉大家idea 有这个功能。
具体功能在 Tools =》 Start SSH Session 之中，可以远程管理文件，也可以远程shell。也是挺不错的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320b85bed71452ff9236c8cf2e82d0f2/" rel="bookmark">
			jQuery回到顶部插件jQuery GoUp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用方法非常简单
引用jquery库和jquery.goup.min.js到你的页面
&lt;script src="http://libs.baidu.com/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="jquery.goup.min.js"&gt;&lt;/script&gt; 在调用下插件就OK了。
&lt;script type="text/javascript"&gt; $(document).ready(function () { $.goup({ trigger: 100, bottomOffset: 150, locationOffset: 100, title: 'This is a Demo', titleAsText: true }); }); &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d19eae82c000c84123d102c2e56776/" rel="bookmark">
			sitk医疗图像分割评价指标Dice，hausdorff distance
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 医疗图像分割评价指标主要有三个，包括掩码相似度指标Dice，Jaccard，Overlap和边界距离指标hausdorff distance，平均hausdorff distance。掩码相似度指标很好理解，hausdorff distance指的是两个掩码边界像素的最近距离集合中的最大值。
sitk代码很简单，可以计算二维和三维的指标。
gt = sitk.GetImageFromArray(gt, isVector=False) my_mask = sitk.GetImageFromArray(my_mask, isVector=False) hausdorffcomputer = sitk.HausdorffDistanceImageFilter() hausdorffcomputer.Execute(gt&gt;0.5, my_mask&gt;0.5) AvgHD = hausdorffcomputer.GetAverageHausdorffDistance() HD = hausdorffcomputer.GetHausdorffDistance() dice_dist = sitk.LabelOverlapMeasuresImageFilter() dice_dist.Execute(gt&gt;0.5, my_mask&gt;0.5) dice = dice_dist.GetDiceCoefficient() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878ea878684708e2cdb38afee044267f/" rel="bookmark">
			类激活图Cam和GradCam原理解读，代码实例讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上关于类激活图Cam以及梯度类激活图的讲解很多，但都不是非常全面，这里我就全面的介绍一下两者的原理，并讲解代码实现过程，最后通过一个实例进行演示。
CAM: CAM
Grad-CAM：Grad-CAM
类激活图cam（class activation map）通过可视化的热力图将模型认为最显著的结果显示出来，因此可用于解释模型预测的结果。卷积神经网络的最后一层卷积层包含了最丰富的空间和语义信息，于是Cam充分利用了最后一层卷积的特征，并将后面的全连接层和softmax层替换成了GAP层（全局平均池化），用特征图所有像素的均值代替整个特征图的值。每个特征图 A k A^k Ak都有一个对应的权重 w k c w_k^c wkc​，与GAP后的特征图求加权和就能得到相应类别C的类激活图，同时也能得到对应的预测得分 Y c Y^c Yc（softmax之前）。
C a m c = ∑ k w k c × A k Cam^c=\sum\limits_k w_k^c\times A^k Camc=k∑​wkc​×Ak
可以看到，其实Cam实现并不难，但有个很大的缺陷，由于添加了GAP改变了网络模型，与原始训练好的模型不同。所以还需要对改变的模型进行训练得到相应的权重，大大限制了应用场景。
于是就有了Grad-CAM，它使用梯度的全局平均来计算权重，不需要修改模型，自然也不需要重新训练。经过严格的数学推导，权重为
我们只关心那些有正向作用的像素点，所以加了ReLU。
从公式中可以看出，我们只要对类别C的预测得分进行反向传播得到梯度，并求全局平均就能计算出相应的权重，因此不需要修改模型。
下面我们结合代码进行讲解，GitHub上的GradCam非常多，我挑了其中一个，讲解其中关键的代码。
由于需要计算前向传播的特征和反向传播的梯度，所以介绍前需要先了解hook函数，可以不改变主体情况下，提取网络中间的输出。这里我就不详细介绍了，详情可以看这个博客
hook函数和CAM类激活图
此代码添加前向传播的特征和反向传播的梯度
def _register_hook(self): for (name, module) in self.net.named_modules(): if name == self.layer_name: self.handlers.append(module.register_forward_hook(self._get_features_hook)) self.handlers.append(module.register_backward_hook(self._get_grads_hook)) 在计算完GradCam后，需要释放hook，否则计算会越来越慢。
def remove_handlers(self): for handle in self.handlers: handle.remove() 这里就是计算类激活图的关键代码了，结合上述公式可以很快的理解。
def __call__(self, inputs, index): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878ea878684708e2cdb38afee044267f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f18886cd2001ab284e113a04f2abc16/" rel="bookmark">
			2020-12-14 微信支付一面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.web安全措施 web服务一些主要的安全防护措施：
两层物理隔离 外网——内网，业务层——数据层
安装必要的杀毒软件
启用IP白名单，仅允许白名单的IP主机访问
使用Https进行通信，使用tls加密，而不是直接使用http
登录授权，生成唯一的session id /token进行后续操作、接口访问
敏感数据进行加密或编码
系统软件启用License授权，随时检测授权是否过期，而不是开启软件才检测
系统软件进行代码保护，启用加密或加壳防止软件被反编译
——单片机里面的烧录的程序，推荐启用加密，或者启用读保护，防止程序被不法人员使用
KMS(Key management system)
引入密钥管理系统 纯软件的密钥管理系统/软硬件结合的密钥管理系统
End to end security communication
采用端对端加密通信，中间所有节点只负责透传，不保存任何通信信息
启用对称加密/非对称加密进行通信
https://blog.csdn.net/u012842630/article/details/89857386
2.安全验证措施有哪些 略
3.如何应对反爬 设置get请求中的User-Agent和Referer字段
User-Agent是检查用户所用客户端的种类和版本。Referer是检查此请求由哪里来，通常可以做图片的盗链判断。控制资源爬取速度，尽量避免触发网站反爬使用IP代理池，每次运行时随机挑选一个做访问IP
网站常常会针对IP访问频率统计，设置一个阈值，当超过这个阈值时，网站就会判断这个IP访问太过频繁，会短时间甚至永久性地禁止该IP地址的访问 。 4.单元测试 gtest的大致使用方法：
为每个待测试类分别创建测试文件，并在该文件实现单元测试代码
创建包含main函数的文件，从此处运行所有的单元测试
编译链接运行即可
在具体编写测试代码时：
TEST函数的第一个参数为测试套件名称，第二个参数为测试套件内的测试用例名称，都是用户自定义
gtest会依据测试套件名称对测试结果分组，所以如果是关联的测试，应该把它们的第一个参数设置为相同。
不同的测试套件可以有相同的测试用例名称
https://blog.csdn.net/guotianqing/article/details/104055221
5.建筑学院项目 略
6.移动语义，以及STL哪些不允许移动？ 复制构造：
在对象被复制后临时对象和复制构造的对象各自占有不同的同样大小的堆内存，就是一个副本。
移动构造：
就是让这个临时对象它原本控制的内存的空间转移给构造出来的对象，这样就相当于把它移动过去了，转移了所有权。
复制构造和移动构造的差别：
这种情况下，我们觉得这个临时对象完成了复制构造后，就不需要它了，我们就没有必要去首先产生一个副本，然后析构这个临时对象，这样费两遍事，又占用内存空间，干脆将临时对象原本的堆内存直接转给构造的对象就行了。 当临时对象在被复制后，就不再被利用了。我们完全可以把临时对象的资源直接移动，这样就避免了多余的复制构造。
什么时候该触发移动构造呢？
如果临时对象即将消亡，并且它里面的资源是需要被再利用的，这个时候我们就可以触发移动构造。
std::move
std::move函数可以以非常简单的方式将左值转换为右值引用。
通过std::move，可以避免不必要的拷贝操作。
https://blog.csdn.net/shenhang_/article/details/105713347
C ++ 11“不可移动”类型
例如，std :: mutex没有移动构造函数。
主要是因为我不认为他们应该移动。在一些操作系统中，互斥体可能被建模为句柄(所以你可以复制它们)，但是IIRC一个线程互斥体被原地操作。如果你要重新定位，任何线程安全正在飞出窗口(其他线程如何知道互斥体刚刚改变了它的内存地址…)
http://www.voidcn.com/article/p-bvggejgl-bsu.html
7.C++程序加速 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f18886cd2001ab284e113a04f2abc16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a710a992813bb68b5d47a58ba6d43ed0/" rel="bookmark">
			第5章 插叙:进程API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		5.1 fork系统调用 p1.c代码:
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main(int argc, char *argv[]) { printf("hello world (pid:%d)\n", (int) getpid()); int rc = fork(); if (rc &lt; 0 ) { fprintf(stderr, "fork failed\n"); exit(1); } else if (rc ==0) { // child (new process) printf("hello, I am child (pid:%d)\n", (int) getpid()); } else { printf("hello, I am parent of %d (pid:%d)\n", rc, (int) getpid()); } return 0; } 输出:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a710a992813bb68b5d47a58ba6d43ed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b57a8301b636c2a9e6372340f77e27/" rel="bookmark">
			C语言将字符转化为数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、可以直接使用字符‘0’减去数字即可转化。
示例如下：
#include
int main()
{
char c=‘0’;
int num=0;
num = int(c - ‘0’);
}
2、用函数atoi可以把字符转为数字。#include
int main()
{
char c=‘0’;
int num =aroi©;
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1df9fbef1e8a78f0cbb1ca050ad55d/" rel="bookmark">
			卸载ufw-小白实操记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以删除或者禁用 ufw ，不存在任何问题。 它不会影响你的iptables 配置。 UFW ( 非复杂防火墙) 只是为了简化使用iptables的一些配置而开发。
1 禁用ufw 要禁用 UFW，可以键入以下内容：
sudo ufw disable 2 卸载ufw 如果要删除它，可以输入以下命令：
sudo apt-get remove ufw 清除依赖包
sudo apt-get purge ufw 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5296766ae6ed79290f2aa14189e7e209/" rel="bookmark">
			IOC注入技术之运行时注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOC技术主要内容：
1.运行时注入， eventBus，springMVC，xUtils
2.源码时注入， android studio插件
3.编译时注入， butterknife，dagger2
需要的基础知识：泛型，反射，注解，动态代理
反射的核心：利用加载到JVM内存中的字节码获取对象的信息，并调用相关反射API进行创建对象，调用方法等操作。
核心思想 IOC是一种设计思想与设计模式要区分开 IOC是原来由程序代码中主动获取资源的方式，转变为由第三方获取资源并使原来的代码被动接收资源的方式，以达到解耦的效果，称为控制反转。
一张图解释下IOC：
手写实现运行时注入核心原理 布局的注入 @Target(ElementType.TYPE)//ElementType.TYPE表示这个注解是用在类上面的 @Retention(RetentionPolicy.RUNTIME)//三种注解类型：java--&gt;class--&gt;runtime public @interface ContentView { int value(); } 控件的注入 private static void injectView(Object context) { Class&lt;?&gt; clazz = context.getClass(); Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) { ViewInject viewInject = field.getAnnotation(ViewInject.class); if (viewInject != null) { int valueId = viewInject.value(); //运行到这里，每个按钮的ID已经取到了 //注入就是反射执行findViewById方法 try { Method method = clazz.getMethod("findViewById", int.class); //View view = mainActivity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5296766ae6ed79290f2aa14189e7e209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb15dae6dbbcc850a10ea9ad338b3c73/" rel="bookmark">
			@Value失效原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/825cc0d75c00c41e2e1c151341af34c2/" rel="bookmark">
			史上最全多线程知识体系脑图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af9c745f5da29b1b18c8499223cf370/" rel="bookmark">
			二分归并排序_一张图搞懂归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归并排序的特点是: 先拆分, 再排序。
而使用柱状递归树图可以让你非常清晰地感受到归并排序的这个特点。
1 柱状递归树图 什么是柱状递归树图呢?
柱状递归树图 就是 柱状图+树图 组合而成:
先上一张归并排序的效果图快速预览下:
柱状图可以很好地把数字的大小排列体现出来。
树图就可以把每次递归之后, 数字的大小排列变化很好地体现出来。
递归的本质就是树！
这张图中每一个柱状图都表示一次递归后的结果, 我们可以非常直观地看到递归的模样!
希望看完本文后, 再提起归并排序时, 首先出现在你脑海里的,会是一个柱状递归树的动画 : )
下面先说归并排序的递归实现方式: 先递归二分, 再排序合并。
2 递归实现 照例我们先对一个长度为16的乱序数组进行归并排序
let data = [13, 11, 7, 4, 9, 8, 15, 6, 5, 3, 14, 2, 10, 1, 16, 12] 使用递归的实现方式，我们先对数组进行二分。
把数组中16个元素先分出8个来, 再从8个中分出4个，一直递归地对左边的数组二分下去：
直到还剩下1个数字时, 递归终止，也就是下图这种情况。
终止递归后, 回到上一层, 开始对右半部分的数组进行二分操作。
直到右边的数组也剩下1个数字时, 递归终止，也就是下图这种情况。
如果我们对整个数组递归地执行二分操作，执行结束之后， 就是下图的效果：
说多无益, 直接看动图:
从动画可以反推出代码应该是下面这样的:
function mergeSortSplit(array) { if ('还剩下1个数字时') return let mid = '先求array中间值' ​ mergeSortSplit('array左半部分') mergeSortSplit('array右半部分') // 先忽略排序合并 // mergeLeftAndRight('array左半部分', 'array右半部分') } 理解了递归二分，接下来讲讲归并排序的第二步，排序合并。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0af9c745f5da29b1b18c8499223cf370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63eee64892606b46f33d3123f20b08f9/" rel="bookmark">
			电线直径对照表_最新电线规格与直径对照表，国标电线平方数和直径一览表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电线的平方数对应的直径是测量该电线是否合格的检测之一，下面胜华电气小编就来介绍下电线规格与直径对照表。
一、电线规格与直径对照表
1、国标电线规格与直径对照表(BV硬线)
2、电线规格与直径对照表(BVR软线)
正规合格的产品铜芯的电线1平方毫米能承载6-8安培的电流，一般不要超过6安培就比较安全。
日常很多电源线是2.5mm2的线。说得就是线的垂直横切面为2.5平方毫米。一般能承受15安培，乘以电压220伏那就是能接3.3千瓦。
国标GB4706.1-1992/1998规定的电线负载电流值(部分)
铜芯线截面积 直径 允许长期电流
2.5 mm2 1.78mm 16A~25A
4 mm2 2.2mm 25~32A
6 mm2 2.78mm 32~40A
铝芯线截面积 直径 允许长期电流
2.5 mm2 1.78mm 13A~20A
4 mm2 2.2mm 20~25A
6 mm2 2.78mm 25~32A
二、电线直径换算公式：
注：以上导体直径指BV 塑铜线换算方法：
知道电线的平方，计算电线的半径用求圆形面积的公式计算：
电线平方数(平方毫米)＝圆周率(3.14)×电线半径(毫米)的平方
知道电线的平方，计算线直径也是这样，如：
2.5方电线的线直径是：2.5÷ 3.14 = 0.8，再开方得出0.9毫米，因此2.5方线的线直径是：2×0.9毫米＝1.8毫米。
知道电线的直径，计算电线的平方也用求圆形面积的公式来计算：
电线的平方＝圆周率(3.14)×线直径的平方／4
电缆大小也用平方标称，多股线就是每根导线截面积之和。
电缆截面积的计算公式：
0.7854 × 电线半径(毫米)的平方 × 股数
如48股(每股电线半径0.2毫米)1.5平方的线：
0.785 ×(0.2 × 0.2)× 48 = 1.5平方
免责声明：文中部分内容来源于网络，如有侵权，请联系小编删除。
看完之后觉得对大家有帮助的话麻烦多多转发，收藏，让更多的人能学到这些专业知识，非常感谢大家，如果有更好的建议意见麻烦评论区留言，我会挨个回复，谢谢大家。
请关注“装修工艺大师”每天推送关于装修文章，让您快速的了解装修，学会装修。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2893712f7694eefbc6a36eff2e7b479/" rel="bookmark">
			2500-使用MyBatis操作MySQL进行批量更新的踩坑点‘multi-statement not allow‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原则上一条SQL只更新一条数据库操作，但有时需要批量操作数据，特别是一些DML语句，在操作数据库时，数据库会报出异常，不允许混合语句，此时需要额外配置进行兼容。
例如：
Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'update purchase_instrument_bill_detail SET out_count = '1', ' at line 8 Caused by: java.sql.SQLException: sql injection violation, multi-statement not allowcom.alibaba.druid.wall.WallFilter.check(WallFilter.java:714) atcom.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:240) atcom.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:448) atcom.alibaba.druid.filter.FilterAdapter.connection_prepareStatement(FilterAdapter.java:928) 解决方案：
数据库连接加参数连接池需要配置 1. 数据库连接加参数 添加参数allowMultiQueries=true
可解决数据库连接层面的异常问题，指定连接数据库时，可执行混合SQL。
参考连接配置: jdbc:mysql:// d a t a s o u r c e .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2893712f7694eefbc6a36eff2e7b479/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d1990b1e2f1bef8a8ab940bbaac0504/" rel="bookmark">
			SAP与SFTP文件传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FTP服务器与SAP之间文件传输，这种方式有很多的实施案例。假设SAP中的数据要放到FTP服务器，可以通过点对点的方式，将数据形成文件放在应用服务器的某一路径下，然后使用标准的FTP函数进行文件传输；也可以通过PI进行数据集成，PI有专门的FTP adapter。
这些是FTP相关的一些报表：
RSFTP001 - SAPFTP 版本检查
RSFTP002 - 执行 FTP 命令
RSFTP003 - 测试
RSFTP004 - FTP 复制
RSFTP005 - SAPFTP 检查
RSFTP006 - FTP 命令清单
RSFTP007 - Test FB:FTP_SERVER_TO_r3 / FTP_R3_TO_SERVER 读取FTP数据到R3 / R3数据写入FTP。
RSFTP008 - Test FB:FTP_CLIENT_TO_R3 / FTP_R3_TO_CLIENT 读取FTP数据到客……
那如果是SFTP呢？现在企业对数据的安全越来越重视，SFTP协议是在FTP的基础上对数据进行加密，使得传输的数据相对来说更安全。不过SAP目前没有像FTP一样的函数可以调用，来通过SFTP协议传输文件，只能借助工具，比如PI；还有一种方法是使用SM49执行外部脚本，今天就来说一下这种方式。
实现的方法大概就是：首先在AL11的某个路径下建个文件夹，然后在此文件夹下创建个.sh文件，里面编辑SFTP脚本。然后在SM49创建外部操作命令，挂接上AL11下创建的.sh文件。最后通过ABAP代码触发事件，实现执行.sh命令行的操作。
1、在OS服务器创建文件夹
2、在此文件夹下创建.sh文件，并维护命令脚本，示例文件
使用记事本创建文件，先保存在本地，然后使用CG3Z上传到步骤1创建的文件夹下。
3、执行事务码SM49，创建外部操作命令，并维护上新创建的文件
4、在程序中调使用函数SXPG_COMMAND_LIST_GET来执行外部操作命令，示例代码如下（代码中是弹出选择框让用户选择使用哪个外部命令）
*&amp;---------------------------------------------------------------------* *&amp; Report ZTESTJI003 *&amp; *&amp;---------------------------------------------------------------------* *&amp; *&amp; *&amp;---------------------------------------------------------------------* REPORT ztestji003. DATA: BEGIN OF command_list OCCURS 0. INCLUDE STRUCTURE sxpgcolist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d1990b1e2f1bef8a8ab940bbaac0504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c487db674f1d5f40ed7f62a8c610297/" rel="bookmark">
			生物信息学算法之Python实现|Rosalind刷题笔记：011 DNA六框翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开放阅读框（Open Reading Frame, ORF）是由起始密码子开始，直到终止密码子结束，中间不含有其他终止密码子的核酸序列。由于 DNA 是双链结构，任何一条链都可以作为模板合成 RNA；并且又因为遗传密码是三联体，由三个核苷酸决定一个氨基酸，因此对于一段 DNA 序列，有六种可能的阅读框（正向三个，反向三个）。通常情况下，六种阅读框只有一种是正确的：一般是翻译得到最长氨基酸序列的阅读框。
图源：rosalind.info 给定： Fasta 文件中一条长度不超过 1kb 的 DNA 序列。
需得： 不同的由 ORF 翻译而来的蛋白序列。返回翻译的蛋白序列时可以是任意顺序。
示例数据 &gt;Rosalind_99 AGCCATGTAGCTAACTCAGGTTACATGGGGATGACCCCGCGACTTGGATTAGAGTCTCTTTTGGAATAAGCCTGAATGATCCGAGTAGCATCTCAG 示例结果 MLLGSFRLIPKETLIQVAGSSPCNLS M MGMTPRLGLESLLE MTPRLGLESLLE Python 实现 Open_Reading_Frames.py
import sys import pysam table = """TTT F CTT L ATT I GTT V TTC F CTC L ATC I GTC V TTA L CTA L ATA I GTA V TTG L CTG L ATG M GTG V TCT S CCT P ACT T GCT A TCC S CCC P ACC T GCC A TCA S CCA P ACA T GCA A TCG S CCG P ACG T GCG A TAT Y CAT H AAT N GAT D TAC Y CAC H AAC N GAC D TAA Stop CAA Q AAA K GAA E TAG Stop CAG Q AAG K GAG E TGT C CGT R AGT S GGT G TGC C CGC R AGC S GGC G TGA Stop CGA R AGA R GGA G TGG W CGG R AGG R GGG G"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c487db674f1d5f40ed7f62a8c610297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52db66011bb152b526bca75e1b03f91c/" rel="bookmark">
			springboot初始化加载数据_小程序 echarts图表初始化与加载动态数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在小程序中，根据需求有时候需要添加多个echarts图表进行动态数据的显示。
但是动态数据是异步加载的，不能确定究竟是数据加载完成在前，还是echarts图表初始化完成在前，因此会出现图表上无数据显示控制台却有数据获取的情况发生。
使用绑定事件监听函数addEvent（），当完成事件再进行通知callEvent（）可参考例子
外部封装方法 function endInitData() { event.callEvent("endInitData") } function getDataServer(url, data, cb) { wx.request({ url: url, data: data, method: 'POST', header: { 'content-type': 'application/json' }, success: (res) =&gt; { cb(res) }, fail: () =&gt; { wx.showToast({ title: '请求超时！', mask: true, duration: 3000 }) } }) } 应当将echarts的初始化以及数据绑定两者进行一个状态是否完成的判定，则需要分别设置一个状态值，完成是设置值为1
var initDataFlag = 0 var initFlag = 0 在当前页面的js中，进行对数据的请求 //设置一个函数 var url =	'请求的地址' function fillChart(chart, option) { var reqData = data } proData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52db66011bb152b526bca75e1b03f91c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9898fb1f03f4ef652d2e445d0217de0e/" rel="bookmark">
			java.lang.NoSuchMethodError 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NoSuchMethodError 原因和处理方案 NoSuchMethodError 找不到方法错误。
java.lang.NoSuchMethodError异常出现可能有以下几种情况：
1）首先看下异常代码位置，是否存在该方法；
2）如果是web项目查看是否是tomcat缓存问题，清一下服务器tomcat的缓存问题；
3）查看是否是因为java环境变化导致；
4）方法签名是否发生改变，若发生改变，则需要把所有应用到该方法的文件一起替换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76a3ff930a635ae04050a4f308ff2800/" rel="bookmark">
			sitk切片序列重采样归一化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于扫描机器的差异，不同HRCT的切片序列层厚和切片间距离都不同。在进行自己的算法前需要将所有序列进行归一化，或者我们只想要其中的部分图片，这时就要对序列进行重采样。
代码其实也很简单，下面的代码可以将Z轴的spacing更改为10mm，如果想更改X，Y方向的，只要改前面的两个参数即可。
def ImageResample(sitk_image, is_label = True): ''' sitk_image: new_spacing: x,y,z is_label: if True, using Interpolator `sitk.sitkNearestNeighbor` ''' size = np.array(sitk_image.GetSize()) spacing = np.array(sitk_image.GetSpacing()) new_spacing = np.array([spacing[0], spacing[1], 10]) #切片间距离变为10mm new_size = size * spacing / new_spacing new_spacing_refine = size * spacing / new_size new_spacing_refine = np.array([float(s) for s in new_spacing_refine[0]]).tolist() new_size = np.array([int(s) for s in new_size[0]]).tolist() resample = sitk.ResampleImageFilter() resample.SetOutputDirection(sitk_image.GetDirection()) resample.SetOutputOrigin(sitk_image.GetOrigin()) resample.SetSize(new_size) resample.SetOutputSpacing(new_spacing_refine) #线性差值或者邻近差值 if is_label: resample.SetInterpolator(sitk.sitkNearestNeighbor) else: #resample.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76a3ff930a635ae04050a4f308ff2800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/060287cdb02cc8f7d97eec40cc7d20ba/" rel="bookmark">
			sitk三维体数据与二维切片互转（nii.gz转dcm和dcm转nii.gz）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在对医学图像数据进行处理时，通常我们会将原始的dicom序列转换为三维的体数据nii.gz格式，便于后序的处理。处理完后，可能又要转换为一张张dicom切片。其实使用sitk对nii.gz和dcm进行互转非常方便，几行代码就能搞定。
dcm转nii.gz file_path = './lung_img' #dicom存放文件夹 series_IDs = sitk.ImageSeriesReader.GetGDCMSeriesIDs(file_path) series_file_names = sitk.ImageSeriesReader.GetGDCMSeriesFileNames(file_path) series_reader = sitk.ImageSeriesReader() series_reader.SetFileNames(series_file_names) image3D = series_reader.Execute() sitk.WriteImage(image3D, './lung_img.nii.gz') nii.gz转dcm filedir = './lung_img.nii.gz' outdir = './lung_img/' if not os.path.isdir(outdir): os.mkdir(outdir) img = sitk.ReadImage(filedir) img = sitk.GetArrayFromImage(img) for i in range(img.shape[0]): select_img = sitk.GetImageFromArray(img[i]) sitk.WriteImage(select_img,outdir+str(img.shape[0]-i)+'.dcm') 由于nii.gz不包含所有的头信息，因此转为dicom文件不会有所有的头信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e088976cb549a1e49320cae76e9a9a88/" rel="bookmark">
			ITK-snap进行分割区域标注、三维显示及改变显示颜色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行医学图像器官分割时，无论我们是用传统方法还是深度学习，最后肯定要用到手动分割的区域作为金标准来验证我们方法的精度。但是手动标注器官的轮廓是十分耗时的，这里我介绍一个比较简单的标注方法，以肺分割作为例子。
我们使用ITK-snap作为分割标注工具。
当切片间距离比较小时，比如1mm，一个患者的完整HRCT序列通常在200张以上，如果让医生一一进行分割区域标注是非常耗时乏味的。因此，我们可以使用最简单的阈值法比如OSTU，加上基本的形态学操作对肺进行粗分割得到粗略的分割掩码，在此基础上再手动的对分割结果进行精分割，就能快速的得到一批金标准。
假设我们要对以下这张切片进行手动标注
首先打开粗分割结果，segmentation—&gt;open segmentation。
由于这个掩码值为255，所以我们选择255的画笔进行修补，画笔大小和形状都可以修改，左键画图，右键去除。
假设下图为手动分割结果
最后将分割后的结果保存即可，segmentation—&gt;save XXX as。
ITK-snap不能直接对原图进行三维显示，只能显示分割结果。因此我们首先打开原图，然后载入分割结果。然后在左下角将Continuous Update打钩就可以显示三维分割结果了。
有的时候分割结果可能有多个器官，我们需要进行不同颜色的显示，或者我们想改变某个分割器官的显示颜色。
只要打开label editor，改变激活标签的颜色就行，比如我这里的激活标签是Label 255。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446ca61eb793a8236449a468caf69f36/" rel="bookmark">
			leetcode学习笔记169 Majority Element
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode学习笔记169 问题方法1方法2方法3 问题 Majority Element
Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
Example 1:
Input: [3,2,3]
Output: 3
Example 2:
Input: [2,2,1,1,1,2,2]
Output: 2
方法1 用map来统计每个数字的出现次数.
时间复杂度 O ( n ) O(n) O(n).
空间复杂度 O ( n ) O(n) O(n).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/446ca61eb793a8236449a468caf69f36/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/397/">«</a>
	<span class="pagination__item pagination__item--current">398/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/399/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>