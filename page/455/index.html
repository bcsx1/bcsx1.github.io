<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130026b8256a5edc0ce1cbb52f3cf002/" rel="bookmark">
			mui返回键事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mui.plusReady(function() {
//处理逻辑：2秒内，连续两次按返回键，则退出应用 var first = null; mui.back = function() { plus.webview.show("Checkmessage.html"); //必须先show再close
plus.webview.currentWebview().close();
};
})
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36c3485e448f60ab67047dfae01c9ef6/" rel="bookmark">
			c#中BitConverter.ToString生成的字符串如何还原成byte数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		str = str.Replace( "- ", " ");
byte[] data = new byte[str.Length / 2];
for (int i = 0; i &lt; str.Length / 2; i++)
{
data[i] = Convert.ToByte(str.Substring(i * 2, 2), 16);
}
data 数组为还原的数组
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/206beb6f1b2a51cbcf05b14e2aa72b71/" rel="bookmark">
			信息安全与密码学博士：应该掌握的52个知识--（1）、当前盘点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息安全与密码学博士：应该掌握的52个知识，是英国Bristol大学密码安全工作组提出的一个概念。参考：http://bristolcrypto.blogspot.com/ 工作组将52个问题分为 9个方面，包括：计算机工程方面；理论计算机科学方面；数学背景；基本密码机制与协议；密码实现详情；安全定义和证明；数学攻击；实际攻击；高级协议与构造。对自己来说，
有些问题是可以回答的，比如 1-5，9, 17-18等，
有些是生涩的，比如 33-45的数学攻击和实际攻击。
有些是有待研究的，比如
T22-- 蒙哥马利算法表示数乘；T23 --C语言执行蒙哥马利算法；T19-- Shamir秘密共享方案；T50-- 基于BLS的配对签名方案；T46-- 菲亚特-沙米尔（Fiat-Shamir）变换？ 后面需要将每个内容写篇文章。立个Flag！
附录：52 Things.
Computer Engineering ([E]) 计算机工程方面
Number 1：What is the difference between the following? 下列处理器有什么差异？
A general-purpose processor.
A general-purpose processor with instruction-set extensions.
A special-purpose processor (or co-processor).
An FPGA.
Number 2：What is the difference between a multi-core processor and a vector processor? 多核处理器和矢量处理器的差异是什么？
Number 3：Estimate the relative computational and storage capabilities of.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/206beb6f1b2a51cbcf05b14e2aa72b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/022fa1fa649cfe1feb2454730efe4bca/" rel="bookmark">
			moment.js使用笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		moment.js是一个专门用来处理时间的函数库，可以在浏览器和node.js环境中使用。
安装：npm i moment --save
使用：
import moment from 'moment' const moment = require('moment')
这里引入的moment其实就是一个函数，会根据传入的参数返回一个moment实例
moment实例实际上就对Date对象的一层包装
moment实例有大量的方法可以使用，足以满足日常业务需求。
一.创建moment实例
1 根据当前日期创建实例：moment();
2 根据date对象创建实例：moment(new Date());
3 根据字符串创建实例：moment('2018--10--10' ,'YYYY--MM--DD');第一参数为时间字符串，第二参数为该时间的格式
如果一个字符串是符合ISO 8601 标准的时间字符串，则不需要传入第二个参数，如：moment('2018-10-10')
时间的格式参考官网http://momentjs.cn/docs/#/parsing/
第二个参数也可以是时间格式的数组，用于处理格式可能存在多样的情况
moment("29-06-1995", ["MM-DD-YYYY", "DD-MM", "DD-MM-YYYY"]); // uses the last format
moment("05-06-1995", ["MM-DD-YYYY", "DD-MM-YYYY"]); // uses the first format
4 根据毫秒数创建实例：moment(Number)
5 根据时间戳创建实例 : moment(Number)
6 复制一个moment ： moment （Moment）或者 var a= moment(); var b= a.clone()
二.根据moment实例获取我们想要的格式数据
var mom= moment();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/022fa1fa649cfe1feb2454730efe4bca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ae28f64bfa7d2f6276a93f34a703ac/" rel="bookmark">
			【UE4 AI】AI Move To寻路转向时解决突变、使得平滑过渡的方法（含C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
修改效果对比
问题阐述
蓝图解决设置
C++解决设置
修改效果对比 修改前存在突变 修改后存在过渡(参数可调) 问题阐述 通过观察NPC的寻路不管使用 行为树的Move To任务节点 还是 蓝图中的AI移动到节点，在寻路目标点与当前NPC朝向角度存在差距时，都会有明显的旋转突变，速度过快导致角色瞬间转向下个目标点的方向，使得动画十分突兀。即使通过控制台命令Slomo 0.1放慢10倍观察，也十分明显。
为测试编写的简单的AI寻路逻辑（可忽略） 因而这一定是对于旋转未做类似Lerp的平滑过渡处理，通过百度发现很难找到想要的答案，于是在UE4 AnswerHub、Google、Unreal Forum、Youtube类似网站寻找国外大牛的解决方案，毕竟国外游戏开发环境好(安利给入坑的小白一条解决问题的方式)。
蓝图解决设置 修改寻路的Character蓝图类下——CharacterMovement组件中——Rotation Settings内的参数。
如你所见，勾选Orient Rotation to Movement，根据提示需要去掉Pawn下默认为true的Use Conroller Rotation Yaw。
大功告成，现在执行你的AI可以看到过渡效果。如果不确定是否有效，可以将Rotation Rate下的Z变换设为0，若NPC不能转向，则说明修改是有效的。
C++解决设置 在你的AI Character类的构造器下，修改如下参数
//Make AI rotate smoothly(avoid snapping) bUseControllerRotationYaw = false; //prepare for orient rotation to movement GetCharacterMovement()-&gt;bOrientRotationToMovement = true; float YawRotateRate = 360.f; GetCharacterMovement()-&gt;RotationRate = FRotator(0, 0, YawRotateRate); 注意使用GetCharacterMovement函数时，需要添加下面的头文件
#include "GameFramework/CharacterMovementComponent.h" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180619e528bfb3075aae71e0a7040727/" rel="bookmark">
			【夯实Java基础】（一）Java入门时的知识你还记得吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 java，javac，javadoc，jar命令区别JVM虚拟机Java基础编译原理Java跨平台原理Java程序注释Java编码规范 开发工具API 应用程序接口变量和数据类型选择结构循环结构什么是装箱？什么是拆箱？数据结构 java，javac，javadoc，jar命令区别 java 通知虚拟机运行一个.class文件
javac编译 用来把.java文件编译为.class文件
javadoc命令是用来生成自己API文档的
它从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签作注释，在程序编写完成后，通过Javadoc就可以同时形成程序的开发文档了。
jar是随 JDK 安装的，在 JDK 安装目录下的 bin文件夹下
是用来打包的，有许多具体的参数，通常JAR文件是一种压缩文件，并且与常见的Zip文件兼容。
JVM虚拟机 .java文件使用javac编译成.class文件
.class文件可以运行在多个操作系统对应的jvm
虚拟机jvm基于操作系统给不同的操作系统配置对应的运行环境。
环境变量：
JAVA_HOME:方便找安装目录
CLASSPATH：lib目录下的dt.jar，lib.jar，rt.jar
path：bin;jre\bin
Java基础编译原理 java语言的"编译期"分为前端编译和后端编译两个阶段。前端编译是指把*.java文件转变成*.class文件的过程；后端编译(JIT, Just In Time Compiler)是指把字节码转变成机器码的过程。
在编译原理中, 将源代码编译成机器码, 主要经过下面几个步骤:
Java跨平台原理 java是一种一种跨平台语言，能够实现一次编译，到处运行，其中java的跨平台性主要是依靠JVM实现的。
注意：java是跨平台的，但是JVM不是跨平台的
我们编译好java源程序之后，要想在不同的操作系统上运行，只需安装相应的JVM即可。Java程序通过JVM 才具有跨平台的特性，但JVM本身并不是跨平台的。也就是说，不同操作系统的JVM是不同的，Windows平台的JVM不能用在Linux中，反之亦然。
简而言之，也就是说，不同的平台本身有着不同的JVM，是JVM成就了Java的跨平台特性。
Java程序注释 在Java注释中基本包括单行注释多行注释。
单行注释：使用“//”开头，在后面添加文字注释。多行注释：使用“/”开头以“/”结尾。文档注释：使用“/**”开头，以“*/”结束。也是多行注释。 编写注释的原因：用以说明某段代码的作用，便于程序员阅读，便于代码的后期维护和升级。
Java编码规范 开发工具 Java编码规范问题可以参考以下这篇博客
《阿里java开发手册》
API 应用程序接口 API(Application Programming Interface)，应用程序编程接口。
Java API是一本程序员的字典 ，Java API是JDK中提供给我们使用的类。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。
API的使用步骤：
打开帮助文档。点击显示，找到索引，看到输入框。你要找谁？在输入框里输入，然后回车。看包。java.lang下的类不需要导包，其他需要。看类的解释和说明。学习构造方法。使用成员方法。 变量和数据类型 十进制和二进制：0和1
22 byte 0001 0110 -22 byte 0001 0001 0110 -22 int 0001 0000 0000 0000 0000 0000 0000 0001 0110 符号：- 符号位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180619e528bfb3075aae71e0a7040727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb6e1a0b4fe01d14769e9117a95cc839/" rel="bookmark">
			springcloud项目引入另一个项目的Jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于最近项目重构，新的框架调用接口由原来的http请求转换成feign请求，引入了相关模块的Jar包之后，在本项目中不能够找到相应的类，报错如下：
引入jar包如下：
一开始没有使用systemPath和scope属性，但是加上了依然报错
经过排查发现是由于项目模块没有注册到consul上去；
注册上去后，我还是遇到了上面类找不到的错误，解决方法添加类扫描：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8412944c960d5d61e49d12186c15b0a4/" rel="bookmark">
			java创建XML文件到本地并写入数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建XML，添加内容，然后写入到本地。 采用DOM（JAXP Crimson解析器）处理，Java提供了四种处理方法，这里选取其一
//整体思路, //创建文档构建器工厂 DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); //创建一个文档构建器，此处需要try,catch处理一下 DocumentBuilder db = factory.newDocumentBuilder(); // 创建xmldoc文档对象，用来创建节点。 Document xmldoc = db.newDocument(); // 创建books根节点 books = xmldoc.createElement("books"); // 将books根节点添加到xmldoc上 xmldoc.appendChild(books); //然后就是在根节点下添加新的节点，先创建新节点，给新节点添加文本属性，或者创建文本节点，将文本节点添加到新节点上。 theBook = xmldoc.createElement("book"); // --- 另外还想加一个属性id，值为B01 ---- theBook.setAttribute("id", "B01"); theElem = xmldoc.createElement("name"); //给新节点添加文本属性 theElem.setTextContent("哈里波特"); //创建文本节点，将文本节点添加到新节点上。 //theElem.appendChild(xmldoc.createTextNode("哈里波特2")); //theBook 下添加theElem节点 theBook.appendChild(theElem); //books根节点下添加theBook节点 books.appendChild(theBook); 可以将每次创建新节点，添加到父节点上的步骤封装起来，便于代码复用
// 添加子节点到该节点上（父节点对象，子节点名称，子节点文本） public void addChildElement(Element element, String child_ele_name, String text) { Document doc = element.getOwnerDocument(); Element sub_element = createLeafElement(doc, child_ele_name, text); element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8412944c960d5d61e49d12186c15b0a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da8539964ac4513871557705dce7f27/" rel="bookmark">
			通过 Tomcat 配置  访问静态  资源 （图片文件等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平常在做项目的时候，我们需要经常访问一些资源，下面推荐比较简单的一种方式，通过Tomcat 简单配置就可以实现其功能，下面介绍不走方法。 1 首先 找到 Tomcat 中的server.xml 文件 2 修改 server.xml 配置 文件 在 Host 节点 中 增加如下 配置 &lt;Context path="/download" docBase="D:\bf\" reloadable="true" debug="0" crossContext="true"/&gt;
path 为访问的路径 ，docBase 为静态资源的路径 ，reloadable="true" 代表实时更新资源目录文件。
3 D: bf 目录下 有如下静态资源
4 启动 Tomcat 5 访问 静态资源 访问 http://localhost:8080/download/20181101170220.png 效果如下 到此结束 下篇讲解通过 nginx 访问静态资源。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24c7773c32f51e2a39ff3aa841abeec/" rel="bookmark">
			AS plugins插件ButterKnife、GsonFormat错误Marketplace plugins are not loaded.Check the internet connection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近更新了一下Android studio3.5.2，想加入插件
Android ButterKnife Zelezny 和 GsonFormat 结果plugins 中显示无法连接网络 。
marketplace plugins are not loaded.Check the internet connection and refresh
我就上网查资料，上面说Appearance&amp;Behavior-&gt;System Settings-&gt;Updates-&gt;User secure connection安全验证开启，因为访问不到：https://plugins.jetbrains.com/ 导致搜不到插件。我把这个关掉，没有任何效果。 然后还有设置自动获取HTTP代理 还有说把防火墙关掉， 点击更改设置，点击允许其他应用，选择Androidstudio 64位（具体根据自己的系统） 我这些操作都做了之后，但是没管用，不管用，还是无法联网。最后推荐一个办法： 以GsonFormat为例 去plugins官网把插件下载下来，然后添加本地插件。 去https://plugins.jetbrains.com/androidstudio 搜索出GsonFormat在AS中选择本地插件导入导入后确定重启就行了。 这样就行了。有什么问题可以评论一下。
注：Plugins官网：https://plugins.jetbrains.com/androidstudio GsonFormat：https://plugins.jetbrains.com/plugin/7654-gsonformat/ Android ButterKnife Zelezny:https://plugins.jetbrains.com/plugin/7369-android-butterknife-zelezny/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e7233ade438a2caa112e4a8e0398491/" rel="bookmark">
			java对象和map相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景：
做前后端交互的时候，前端传输过来的数据自动封装成javabean，而当将这些数据以属性名-值的形式传输都其他地方时，需要使用map将这些属性存储起来，而当属性过于多的时候，多个map.put()就会显得代码冗余，所以，同意可以借助工具类
import java.beans.BeanInfo; import java.beans.IntrospectionException; import java.beans.Introspector; import java.beans.PropertyDescriptor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.HashMap; import java.util.Map; public class BeanToMapUtil { /** * 将一个 Map 对象转化为一个 JavaBean * * @param type * 要转化的类型 * @param map * 包含属性值的 map * @return 转化出来的 JavaBean 对象 * @throws IntrospectionException * 如果分析类属性失败 * @throws IllegalAccessException * 如果实例化 JavaBean 失败 * @throws InstantiationException * 如果实例化 JavaBean 失败 * @throws InvocationTargetException * 如果调用属性的 setter 方法失败 */ public static Object convertMap(Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e7233ade438a2caa112e4a8e0398491/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0428d8483333ff62b0e594c73e9d97a/" rel="bookmark">
			安卓图形之MPAndroidChart3.0详解一——折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 前言1.1 基本使用1.1 默认样式1.2 属性设置Description设置Legend设置YAxis 设置XAxis 设置LineDataSet 设置 补充 1 前言 此篇文章主要讲解MPAndroidChart中 折线图 的基本使用，和一些常用方法的总结。以下均为个人总结。如有错误或者不妥之处，望在评论区留言。
1.1 基本使用 MPAndroidChart中的折线图主要由四部分组成
标题(Description)图例(Legend)X轴(XAxis)Y轴(YAxis)数据源(LineData)
后续操作基本都是对这四部分进行处理 1.1 默认样式 下面展示的效果图只填充数据，不添加任何样式的折线图，效果如下图：
XML布局文件
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.github.mikephil.charting.charts.LineChart android:id="@+id/lc" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;/RelativeLayout&gt; java代码
public class Frag_1 extends Fragment { private LineChart lc; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return inflater.inflate(R.layout.frag_1,null); } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0428d8483333ff62b0e594c73e9d97a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349920a0ab1cc02c3fc2384babe8ea1b/" rel="bookmark">
			设计模式—单例模式 / DCL失效问题 / 暴力破解单例 (反射/序列化)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式 杂谈前提饿汉模式：懒汉模式：线程不安全线程安全 双重锁懒汉模式(Double Check Lock)静态内部类模式枚举单例 杂谈 和同学在聚会的时候聊起设计模式，聊完之后发现我对自己的设计模式的看法貌似存在误解，当我看到设计模式的外衣，我就误以为我已经发现了它的内在！
原因是聊到—单例模式的时候，我就觉得，这有啥好讲的，不就是%&amp;&amp;……&amp;%，那么简单吗，结果同学问了我 DCL失效问题 是什么？静态内部类是线程安全的吗？为什么？…然后，就没有然后了…
发现一篇贼六的博客，引用了~(中间加上点自己的观点，也顺便排版了一下，强迫症标识有点受不了博主的排版)，后续暴力破解单例为原创，可供大家参考。
原文链接：https://blog.csdn.net/mnb65482/article/details/80458571
前提 首先我们要先了解下单例的四大原则：
构造私有。以静态方法或者枚举返回实例。确保实例只有一个，尤其是多线程环境。确保反序列换时不会重新构建对象。 我们常用的单例模式有：
饿汉模式、懒汉模式、双重锁懒汉模式、静态内部类模式、枚举模式，我们来逐一分析下这些模式的区别。
饿汉模式： public class SingleTon{ private static SingleTon INSTANCE = new SingleTon(); private SingleTon(){} public static SingleTon getInstance(){ return INSTANCE; } } public class SingleTon{ private SingleTon INSTANCE = null; static { INSTANCE = new SingleTon(); } private SingleTon(){} public static SingleTon getInstance() { return this.INSTANCE ; } } 饿汉模式在类被初始化时就已经在内存中创建了对象，以空间换时间，故不存在线程安全问题。
懒汉模式： 线程不安全 public class SingleTon{ private static SingleTon INSTANCE = null; private SingleTon(){} public static SingleTon getInstance() { if(INSTANCE == null){ INSTANCE = new SingleTon(); } return INSTANCE； } } 线程安全 public class SingleTon{ private static SingleTon INSTANCE = null; private SingleTon(){} public static synchronized SingleTongetInstance() { if (INSTANCE == null) { INSTANCE = new SingleTon(); } return INSTANCE ; } } 懒汉模式在方法被调用后才创建对象，以时间换空间，在多线程环境下存在风险
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349920a0ab1cc02c3fc2384babe8ea1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69ee4a852bc1aa86563bf5cd86d8189e/" rel="bookmark">
			Eclipse安装插件的常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eclipse安装插件的常用方法，可分为在线安装和离线安装两种。
在线安装 Install New Software 一般知道插件的地址用这种方法安装：
直接在Work with里输入插件地址，或者通过Add添加插件的地址，方便以后更新：
Name：给插件起个名
Location：输入插件的网络地址
也可以选择Local：表示通过本地已解压的插件文件夹安装
也可以选择Archive：表示通过本地的插件jar或压缩文件安装
Eclipse Marketplace 一般知道插件名称，并且可以正常访问Eclipse官方市场，可以通过这种方法安装：
输入插件的名称或者插件名的几个字来模糊查找，选择要安装的插件，单击Install：
离线安装 复制粘贴 一般插件已下载到本地，可以使用这种方法安装，可以分为2种：
1：把下载的插件解压放到Eclipse文件夹dropins内：
插件内：
2：把下载的插件解压后，把插件的features文件夹内的文件复制到Eclipse文件夹features内：
把插件的plugins文件夹内的文件复制到Eclipse文件夹plugins内：
使用link文件 一般插件已下载到本地，并且自己管理，可以使用这种方法安装：
在Eclipse文件夹下创建links文件夹：
在links文件夹内新建插件的link文件，文件内是插件的路径：
path=D:\\Apps\\Eclipse\\eclipse-plugs\\checkstyle
在插件文件夹内新建新增插件checkstyle文件夹，接着新建eclipse文件夹，把插件解压后的features和plugins复制到eclipse文件夹内：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f8beab8ff74f640b636f2f26b775b43/" rel="bookmark">
			Http协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的RFC，其中著名的RFC 2616定义了HTTP 1.1。
http协议的作用及特点 HTTP是一个客户端和服务器端请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。（我们称）这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels）。尽管TCP/IP协议是互联网上最流行的应用，HTTP协议并没有规定必须使用它和（基于）它支持的层。 事实上，HTTP可以在任何其他互联网协议上，或者在其他网络上实现。HTTP只假定（其下层协议提供）可靠的传输，任何能够提供这种保证的协议都可以被其使用。
通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如"HTTP/1.1 200 OK"，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。
通过HTTP或者HTTPS协议请求的资源由统一资源标示符（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。
1.基于请求/响应模型的协议。请求和响应必须成对，先有请求后有响应
2.http协议默认端口:80
3.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
4.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
5.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
6.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
协议功能 HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。
HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网/内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。
我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。
http协议的版本 HTTP/1.0,发送请求，创建一次连接，获得一个web资源，连接断开
HTTP/1.1，发送请求，创建一次连接，获得多个web资源，连接断开
Http协议的组成 Http协议由Http请求和Http响应组成，当在浏览器中输入网址访问某个网站时， 你的浏览器会将你的请求封装成一个Http请求发送给服务器站点，服务器接收到请 求后会组织响应数据封装成一个Http响应返回给浏览器。即没有请求就没有响应。
http请求包括:请求行、请求头、请求体
http响应包括:响应行、响应头、响应体
HTTP请求报文 HTTP请求报文由3部分组成（请求行+请求头+请求体）：
请求行：
例如：POST /chapter17/user.html HTTP/1.1
格式：请求方式 资源路径 协议/版本
请求行必须在http请求格式的第一行。
get请求:
将请求参数追加在url后面，不安全
url长度限制get请求方式数据的大小
没有请求体
一般的HTTP请求大多都是GET。
post请求：
请求参数在请求体处，较安全。
请求数据大小没有显示
只有表单设置为method=“post”才是post请求，其他都是get请求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f8beab8ff74f640b636f2f26b775b43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c98722b820022169b77ec123138593/" rel="bookmark">
			mybatis添加返回主键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis添加返回主键 两种方法
&lt;!--返回主键方法一--&gt; &lt;insert id="save" parameterType="baidu.com.pojo.THobby" useGeneratedKeys="true" keyProperty="hid"&gt; insert into t_hobby set hobby=#{hobby} &lt;/insert&gt; 执行完添加方法—— 获取主键的时候 直接
thobby.getId 就能直接获取
方法二：
相当于执行了两个sql语句
&lt;!--放回主键方法二--&gt; &lt;!--添加方法--&gt; &lt;insert id="save" parameterType="baidu.com.pojo.THobby" &gt; &lt;selectKey keyProperty="hid" resultType="int" order="AFTER"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into t_hobby set hobby=#{hobby} &lt;/insert&gt; 如果不行就加一个线程 Thread.sleep(“100”);
最好用第一个方法 简单易操作
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf33b430a5303694f31734c11af84552/" rel="bookmark">
			1064 关于用navicat保存设置外键的表时报错 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题纠结了本人两天时间，最终终于解决了。但是，在本人解决的过程中，在网上查找的前辈们的解决方法，都是通过修改SQL预览那里的代码解决的。但是呢，本人由于初学数据库的知识点，所以对于代码那里还是不能理解的。所以，在本人通过外键那里的设置，解决了这个问题后，本人便迫不及待地来分享下解决这个问题的方法，希望能帮助到正在焦头烂额查找解决方法的同学！
首先，本人先来展示一下报错的界面信息：
那么，我们该如何解决呢？
其实很简单：
我们在设置外键时，除了“名”这一列手动输入以外，其他的列全部都要通过下拉菜单选择，如下图中的所有列，都要通过下拉菜单选择：
因为我们在这里设置外键，navicat会自动生成代码，如果后面几列再手动输入的话，无疑生成的代码很容易出错！
那么，这个问题的解决方法就讲解完了，，若是还有其他相关问题，请在下方评论区提出，本人将在看到后查阅，有了最恰当的解决方法后会回复！
若对这篇博文有任何疑问或者意见以及建议，请在下方评论区提出，本人将尽早予以讲解以及答复，喜欢的同学请留下你们的赞，谢谢！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7553d9a25b8c3fc6bf1bc35a48a37be9/" rel="bookmark">
			图像位深度 8位 16位 24位 32位区别对比 RGB 真彩色 基本概念：（大小，深度，通道）位深度数据类型转换原理 Mat数据读取（opencv里的imread）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位深度 位深度是指在记录数字图像的颜色时，计算机实际上是用每个像素需要的二进制数值位数来表示的。计算机之所以能够显示颜色，是采用了一种称作“位”( bit ) 的记数单位来记录所表示颜色的数据。当这些数据按照一定的编排方式被记录在计算机中，就构成了一个数字图像的计算机文件。“位”( bit )是计算机存储器里的最小单元，它用来记录每一个像素颜色的值。图像的色彩越丰富，“位”就越多。每一个像素在计算机中所使用的这种位数就是“位深度”。
黑白二色的图像是数字图像中最简单的一种，它只有黑、白两种颜色，也就是说它的每个像素只有1位颜色，位深度是1，用2的一次幂来表示；考虑到位深度平均分给R, G, B和Alpha，而只有RGB可以相互组合成颜色。所以4位颜色的图，它的位深度是4，只有2的4次幂种颜色，即16种颜色或16种灰度等级 ) 。8位颜色的图，位深度就是8，用2的8次幂表示，它含有256种颜色 ( 或256种灰度等级 )。24位颜色可称之为真彩色，位深度是24，它能组合成2的24次幂种颜色，即：16777216种颜色 ( 或称千万种颜色 )，超过了人眼能够分辨的颜色数量。当我们用24位来记录颜色时，实际上是以2^（8×3），即红、绿、蓝 ( RGB ) 三基色各以2的8次幂，256种颜色而存在的，三色组合就形成一千六百万种颜色。
示例：8位颜色的图，位深度就是8，用2的8次幂表示，它含有256种颜色 ( 或256种灰度等级 )。
更通俗的讲，8位颜色的图，每个存储1个像素一般可存放8位二进制。也就是8个01进行排列组合，排列组合的结果有2的8次幂=256种颜色。我们把每个像素可表示颜色的2的幂指数称为深度。
位深度及通道表示方法 CV_&lt;bit_depth&gt;(S|U|F)C&lt;number_of_channels&gt; 1--bit_depth---比特数---代表8bite,16bites,32bites,64bites---举个例子吧--比如说,如 如果你现在创建了一个存储--灰度图片的Mat对象,这个图像的大小为宽100,高100,那么,现在这张 灰度图片中有10000个像素点，它每一个像素点在内存空间所占的空间大小是8bite,8位--所以它对 应的就是CV_8 2--S|U|F--S--代表---signed int---有符号整形 U--代表--unsigned int--无符号整形 F--代表--float---------单精度浮点型 3--C&lt;number_of_channels&gt;----代表---一张图片的通道数,比如: 1--灰度图片--grayImg---是--单通道图像 2--RGB彩色图像---------是--3通道图像 3--带Alph通道的RGB图像--是--4通道图像 为什么要数据类型转换 OpenCV中默认加载图像imread函数的返回是通道顺序为BGR色彩色图像，范围是0~255之间，数据类型是CV_8UC的每个通道占一个字节。但是实际上我们在图像处理过程把像素值看成了数据对待，数据处理与计算过程中就会产生各种浮点数据、正数或者负数，如果我们不对字节数据进行提前转换就会导致精度丢失问题或者数据溢出问题，最终就无法达成图像处理算法想要的结果。最后再说一次，图像是特殊的数据！套用一句很经典的话就是，理论上理论与实践是一致的，实际上理论与实践之间还有有点距离，这个就要靠工程人员经验解决。
opencv里的位深度 在使用opencv的imread函数读取图像时，由于后面我没加flag参数，读取的图像全部被默认转换成通道顺序为BGR色彩色图像，范围是0~255之间，数据类型是CV_8UC的每个通道占一个字节，用print(image.dtype)打印数据类型都是uint8，如果要查看原图像信息，可能需在imread函数后加上特定flag，参见：
python opencv imread(filename, flags=None) 读取图像 flags cv::ImreadModes 参数上哪看去？
后来实测，加了flag也看不到……
不管是用cv.imread()函数读取8位图片（右键图片属性可看到的那个），还是24位图片，还是读取后将图片转换成灰度图，打印dtype数据类型都是uint8，其中打印读取的8位图片和24位图片都是三层数组，打印转换成灰度图的则是一层数组，根据各个文章中介绍的8位图bgr：2+3+3的位分配，猜测opencv在读取的时候将其映射map转换到24位即8+8+8上了，只是猜测，日后有待考证！
测试代码 # -*- encoding: utf-8 -*- """ @File : test_191123_图像的位深度.py @Time : 2019/11/23 9:49 @Author : Dontla @Email : sxana@qq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7553d9a25b8c3fc6bf1bc35a48a37be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74792faf9c74d56f68d7007f26a3d067/" rel="bookmark">
			curl库的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 libcurl作为是一个多协议的便于客户端使用的URL传输库，基于C语言，提供C语言的API接口，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP这些协议，同时支持使用SSL证书的安全文件传输：HTTP POST, HTTP PUT, FTP 上传, 基于HTTP形式的上传、代理、Cookies、用户加密码的认证等多种应用场景。另外，libcurl是一个高移植性的库，能在绝大多数系统上运行，包括Solaris, NetBSD, FreeBSD, OpenBSD, Darwin, HPUX, IRIX, AIX, Tru64, Linux, UnixWare, HURD, Windows, Amiga, OS/2, BeOs, Mac OS X, Ultrix, QNX, OpenVMS, RISC OS, Novell NetWare, DOS等。
使用流程 函数说明 1. curl_global_init CURLcode curl_global_init(long flags);
描述：该函数只能用一次，但在调用curl_global_cleanup 函数后仍可再用。若该函数没有在调用curl_easy_init函数前调用，其会被libcurl自动调用。so多线程下，应主动调用该函数，以免在线程中执行curl_easy_init函数前被libcurl多次自动调用。
注意：libcurl是线程安全的，但curl_global_init是不能保证线程安全的。因此需在主线程调用该函数，而不是在每个线程中调用。
参数：flags值的解释如下
CURL_GLOBAL_ALL //初始化所有的可能的调用。
CURL_GLOBAL_SSL //初始化支持 安全套接字层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74792faf9c74d56f68d7007f26a3d067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527b6cf6c08944db2cab3110fc1042bc/" rel="bookmark">
			kali更新失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kali更新失败
阅读目录
今天更新kali时失败，出现如下问题：
复制代码
root@kali:~# apt-get update
Get:1 http://mirrors.aliyun.com/kali kali-rolling InRelease [30.5 kB]
Err:1 http://mirrors.aliyun.com/kali kali-rolling InRelease
The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository devel@kali.org
Reading package lists… Done
W: GPG error: http://mirrors.aliyun.com/kali kali-rolling InRelease: The following signatures were invalid: EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository devel@kali.org
E: The repository ‘http://mirrors.aliyun.com/kali kali-rolling InRelease’ is not signed.
N: Updating from such a repository can’t be done securely, and is therefore disabled by default.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/527b6cf6c08944db2cab3110fc1042bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8714d9337e2382d7004d710c1b81f06/" rel="bookmark">
			J-Link驱动安装和JLINK下载Hex程序使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官下载地址：https://www.segger.com/downloads/jlink/JLink_Windows_beta.exe
CSDN地址：https://download.csdn.net/download/c1063891514/11989473
下载完成安装：
打开应用--D:\Program Files (x86)\SEGGER\JLink\JFlash.exe
使用说明
创建项目：
随便选择，直接点击OK（后面还会选择）
进行设置
选择相应的芯片
连接设备
选择工程文件.hex
下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b73c10a805f0d070cde86fefa631caf0/" rel="bookmark">
			反射机制（5）—— 反射机制 和 properties文件的联合使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本专题《详解 反射机制》之前的博文中，本人将所有有关 反射机制的基本使用方式都讲解完了，但是，为什么本人还要用一片博文来展示 反射机制 和 properties文件的联合使用 呢？
答曰：反射机制和properties文件或是和XML文件的联动，是我们后期学习中框架那里的核心。所以，本人先来浅浅地讲解一下基本使用方法：
反射机制 和 properties文件的联合使用： 那么，现在，本人通过一个例子来实现一下“反射机制”：
在本人开始根据以上的知识来举例之前，先借用一下本人在上篇博文中的知识来编写一个properties文件（相关知识点请观看本人博文——《Properties 解析》）：
class.properties:
class=com.mec.complex.Complex 那么，现在本人肯定要引用一下我们在上一篇博文中所做的解析properties文件的“工具”类：
PropertiesParser.java:
package com.mec.util.Properties; import java.io.IOException; import java.io.InputStream; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Properties; import java.util.Set; public class PropertiesParser { private static final Map&lt;String, String&gt; propertyMap ; static { propertyMap = new HashMap&lt;&gt;(); } //上面的代码，等价于： //private static final Map&lt;String, String&gt; propertyMap = new HashMap&lt;&gt;(); public PropertiesParser() { } public static void loadProperties(String path) { InputStream is = PropertiesParser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b73c10a805f0d070cde86fefa631caf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac23d4f101f5b3a66404c6cbd0c608e/" rel="bookmark">
			自定义View一：绘制-Canvas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、概念 画布，通过画笔绘制几何图形、文本、路径和位图等。
2、常用API 常用API分为绘制、变换、状态保存和恢复
2.1 绘制颜色 1.	canvas.drawColor(Color.GREEN); 2.2 绘制集合图形 //绘制点 float[] pts = {200, 300, 200, 400, 200, 500}; canvas.drawPoints(pts, mPaint); //绘制线 canvas.drawLine(200, 200, 200, 400, mPaint); //绘制矩形 RectF rect = new RectF(100, 100, 400, 400); canvas.drawRect(rect, mPaint); //绘制圆角矩形 canvas.drawRoundRect(rect, 20, 20, mPaint); //绘制圆 canvas.drawCircle(200, 200, 100, mPaint); //绘制椭圆 canvas.drawOval(rect, mPaint); //绘制圆弧 canvas.drawArc(rect, -180, 180, true, mPaint); 2.3 绘制文本 canvas.drawText(text, 50, 50, mPaint); Path path = new Path(); path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac23d4f101f5b3a66404c6cbd0c608e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3fc64a9f396c35f453c285e72586b5b/" rel="bookmark">
			第七篇：ICMP与ping
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ICMP报文在第三层，封装在IP包里。
ICMP报文有很多的类型，不同的类型有不同的代码。
ICMP查询报告报文：
类型为8代表请求报文
类型为0代表应答报文
代码为0：无论请求报文还是应答报文，代码都为0
上图为ICMP请求，type为8，code为0，描述信息为ICMP Echo request
上图为应答，Type为0，Code为0，描述信息为ICMP Echo reply
差错报文类型：
类型为3：终点不可达
类型为4：源抑制
类型为5：重定向
类型为11：超时
终点不可达：
A &lt;-&gt; 路由器 &lt;-&gt; B
主机A向主机B发送数据包，会经过路由器，如果此时路由器出现了问题，那么路由器接收到数据包之后不会发送给B，而是把这个数据包丢弃并发送一个终点不可达的数据报文。
代码0-15表示终点不可达的错误可能有16种，其中网络不可达代码为0，主机不可达为1，协议不可达为2，端口不可达为3，
源抑制：
类型为4
IP协议是面向无连接的，没有流量控制机制，数据在传输过程种事非常容易造成拥塞的现象。
而ICMP源抑制报文就是给IP提供一种流量监控机制。这个报文的作用就是通知数据包在拥塞时被丢弃了，另外还会警告源主机流量出现了拥塞情况。
超时：
超过网络包的生存时间，但数据包还没有发送到。
路由重定向：
ICMP数据包在传输过程中选择最优路径进行传输。
假如主机A的IP地址为192.168.1.1，主机B的地址为192.168.1.2，它们在同一个子网中，如果ApingB，数据包是如何传输的？
ping执行的时候，源主机会先构建一个ICMP请求数据包，ICMP数据包包含多个字段，最主要的是类型字段和顺序号，对于请求数据包而言，类型字段为8，顺序号主要是用于区分连续ping的时候发出的多个数据包。每发出一个数据包，顺序号就会加1.
然后，ICMP协议将数据包连同地址192.168.1.2交给IP层，IP层中包含了源地址，目的地址，ICMP数据。
再接下来，交给MAC层，如果不知道192.168.1.2的MAC地址是什么，则需要先发送ARP协议，获取到MAC地址之后，组成一个整的数据包发送出去。
同样，192.168.1.2机器接收到数据包之后，层层解包，回复ICMP应答包，类型为0.
参考：
https://blog.csdn.net/qq_35733751/article/details/80053091
趣谈网络协议
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f985cae73753276ea33a5957e8147a32/" rel="bookmark">
			git 拉取和获取 git pull和git fetch 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git提交用push，对应的拉取用pull，但是又有一个获取fetch，拉取和获取有啥区别？
pull 从远程拉取最新版本到本地仓库，并会自动合并。
fetch 从远程拉取最新版本到本地仓库，不会自动合并。
即：pull = fetch + 合并
实际使用中 ，使用git fetch 更安全，在merge之前可以看清楚更新情况，再决定是否合并。
由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作，它就是 git pull。
git fetch 不会做的事
git fetch 并不会改变你本地仓库的状态。它不会更新你的 master 分支，也不会修改你磁盘上的文件。
理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。
所以，你可以将 git fetch 的理解为单纯的下载操作。
参考：
https://blog.csdn.net/qq_33314107/article/details/79727668
https://www.jianshu.com/p/b37ff443de15
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f41516d22ecd396bc4383e25df5ae8/" rel="bookmark">
			通过指针访问二维数组的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面总结了一下通过指针访问二维数组的三种方法，里边涉及指针、指针数组、数组指针、指向指针的指针以及二维数组的应用，愿对于大家理解和使用指针有所参考和帮助。
程序如下：
#include &lt;stdio.h&gt; int main() { int i, j; int score[3][4] = { {65,67,70,60}, {80,87,90,81}, {90,99,100,98}}; //第一种方法，二维数组当成一维数组来访问 int *p; printf("方法1，二维数组当成一维数组来访问：\n");//换行 p = score[0];//或者&amp;score[0][0]，都可以。 for(i = 0; i &lt; 3 * 4; i++) printf("%4d,", *(p + i)); printf("\n");//换行 //第二种方法，通过数组指针来访问 int (*pr)[4];//数组指针 printf("\n方法2，通过数组指针来访问：\n");//换行 pr = score; for(i = 0; i &lt; 3; i++) { for(j = 0; j &lt; 4; j++) printf("%4d,", *(*(pr + i) + j)); printf("\n");//换行 } //第三种方法，通过指向指针的指针+指针数组来访问 int **pt;//指向指针的指针 int *ptt[3];//指针数组 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9f41516d22ecd396bc4383e25df5ae8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca056c58bf69edb23968585b5bb95fc/" rel="bookmark">
			fetch请求两次接口问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.w3cways.com/2280.html
https://segmentfault.com/q/1010000008693779
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983447b560698af51ea4227a586bc37b/" rel="bookmark">
			使用Openoffice实现并发多进程word文档转换预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境介绍
javaopenoffice 4.1.6springboot整合开发 二、代码实现
pom文件依赖
在pom文件中添加项目依赖：
&lt;!-- https://mvnrepository.com/artifact/org.jodconverter/jodconverter-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jodconverter&lt;/groupId&gt; &lt;artifactId&gt;jodconverter-core&lt;/artifactId&gt; &lt;version&gt;4.0.0-RELEASE&lt;/version&gt; &lt;/dependency&gt; 关键代码
注意修改libreoffice安装路径，linux默认在/opt/libreoffice6.3；windows根据自定义安装地址确定
package com.chenlei.worddemo.util; import java.io.*; import java.util.*; import java.util.concurrent.*; import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; import java.util.regex.Pattern; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import org.jodconverter.OfficeDocumentConverter; import org.jodconverter.office.DefaultOfficeManagerBuilder; import org.jodconverter.office.OfficeException; import org.jodconverter.office.OfficeManager; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; /** * 利用jodconverter(基于OpenOffice服务)将文件(*.doc、*.docx、*.xls、*.ppt)转化为html格式或者pdf格式， * 使用前请检查OpenOffice服务是否已经开启, OpenOffice进程名称：soffice.exe | soffice.bin * * @author lcx */ @Component public class Doc2HtmlUtil { @Value("${BASE_PATH}") private String BASE_PATH; @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983447b560698af51ea4227a586bc37b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67211d69d996c6ec68ffe122d3e6d99e/" rel="bookmark">
			shiro  redis使用json序列化器之后异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shiro使用redis做缓存，并且使用了
Jackson2JsonRedisSerialize 替换默认序列化 我这边就会出一下异常 这个异常原因 应该是泛型 反序列化出问题 在redistemple 里面 加
// 使用Jackson2JsonRedisSerialize 替换默认序列化(默认采用的是JDK序列化) Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); 2.存储时候 加上 TimeUnit.xxx 不然存储的 值 前面一串 空格 或者 二进制 哎 记录一下 给我们这类 菜鸟程序员 少跳坑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3986229e1c3da8a7e5cb17866da03994/" rel="bookmark">
			笔记：kubernetes，scheduler，framework，plugins
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蚂蚁金服kubernetes方向招聘
阅读kubernetes调度代码的时候，看到这个pacakge：
pkg/scheduler/framework 网上相关的资料很少，废了老半天的劲儿终于找到，这里记录一下
scheduler framework
https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md 这块儿的目录结构如下
../framework/ ├── BUILD ├── plugins #系统中所有的调度插件，不同类型的调度插件需要实现不同的接口，接口的定义在interface.go中 │ ├── BUILD │ ├── default_registry.go #基于 │ ├── default_registry_test.go │ ├── defaultpodtopologyspread │ ├── examples │ ├── imagelocality │ ├── interpodaffinity │ ├── migration │ ├── nodeaffinity │ ├── nodelabel │ ├── nodename │ ├── nodeports │ ├── nodepreferavoidpods │ ├── noderesources │ ├── nodeunschedulable │ ├── nodevolumelimits │ ├── podtopologyspread │ ├── requestedtocapacityratio │ ├── serviceaffinity │ ├── tainttoleration │ ├── volumebinding │ ├── volumerestrictions │ └── volumezone └── v1alpha1 ├── BUILD ├── cycle_state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3986229e1c3da8a7e5cb17866da03994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8169ff1d018de2e3d655aac083a67a28/" rel="bookmark">
			MSP430f5529模拟IIC协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MSP430f5529模拟IIC协议 读取数据之前需要释放总线，被这问题卡了好久
#include "msp430f5529.h" //P8.1 SCL //P8.2 SDA #define SCL_HIGH P8OUT|=BIT1 #define SCL_LOW P8OUT&amp;=~BIT1 #define SDA_HIGH P8OUT|=BIT2 #define SDA_LOW P8OUT&amp;=~BIT2 #define SDA_OUT P8DIR|=BIT2 #define SDA_IN P8DIR&amp;=~BIT2 #define SCL_OUT P8DIR|=BIT1 #define SDA P8IN&amp;BIT2 void IIC_start(); void IIC_stop(); void IIC_writebyte(unsigned char IIC_byte); unsigned char IIC_readebyte(); unsigned char IIC_testACK(); void IIC_masterACK(); void IIC_masterNACK(); void IIC_start() { SDA_OUT; SCL_OUT; SCL_HIGH; SDA_HIGH; __delay_cycles(10); SDA_LOW; __delay_cycles(10); SCL_LOW; } void IIC_stop() { SDA_OUT; SCL_OUT; SCL_LOW; SDA_LOW; __delay_cycles(10); SCL_HIGH; __delay_cycles(10); SDA_HIGH; __delay_cycles(10); } void IIC_writebyte(unsigned char IIC_byte) { unsigned char i; SDA_OUT; SCL_OUT; SCL_LOW; __delay_cycles(10); for(i=0;i&lt;8;i++) { if(IIC_byte&amp;0x80) //写1 SDA_HIGH; else //写0 SDA_LOW; __delay_cycles(10); SCL_HIGH; __delay_cycles(10); SCL_LOW; __delay_cycles(10); IIC_byte&lt;&lt;=1; //循环左移，取最高位 } } unsigned char IIC_readebyte() { unsigned char i,k=0; SDA_IN; //SDA设置为输入 SCL_OUT; SCL_LOW; __delay_cycles(50); for(i=0;i&lt;8;i++) { SCL_HIGH; k=k&lt;&lt;1; if(SDA) k|=1; SCL_LOW; __delay_cycles(50); } SDA_OUT; //SDA设置为输出 __delay_cycles(50); return k; } unsigned char IIC_testACK() { SCL_LOW; //SDA_IN; //SDA设置为输入 //SDA_UP; __delay_cycles(50); SCL_HIGH; __delay_cycles(50); SCL_LOW; //SDA_OUT; //SDA设置为输出 __delay_cycles(50); return 1;	} void IIC_masterACK() { SDA_OUT; SCL_OUT; SCL_LOW; SDA_LOW; SCL_HIGH; __delay_cycles(5); SCL_LOW; __delay_cycles(5); } void IIC_masterNACK() { SDA_OUT; SCL_OUT; SCL_LOW; SDA_HIGH; __delay_cycles(5); SCL_HIGH; __delay_cycles(5); SCL_LOW; __delay_cycles(5);	} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a7ab0b55477425915f99784855ce23/" rel="bookmark">
			Spring Batch 入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、应用场景 在银行、电信等一些大型的企业应用上，经常需要处理大批量的数据。比如，银行的交易流水文件的处理等。这些大批量数据的处理有一些共同点，从文件或数据库中读取数据，进行加工处理，再写入到文件或数据库中。Spring Batch 正是完成这样的功能。Spring Batch 的出现，让我们可以专注业务编程，而不去关心批量如何执行。
Spring Batch 的主要功能：
1、与quartz整合，实现定时批任务处理；当然，spring batch 内部也有集成调度框架，不过没有quartz强大。
2、可以并行处理批任务；
3、可以按顺序定义相关的处理步骤；
4、支持事务；
5、支持对批任务的失败重试；
.......
二、基本架构 官网上，spring batch 的架构图如下：
简单点说，JobRepository 用于存放批处理的结果，不管成功或者 失败，都会保存在JobRepository 中。JobRepository 可以是内存，也可以是数据库。
而JobLauncher则用于启动一个批任务。
Job、step需要程序员自己定义，一个job可以有多个step，而一个step下，又分别包含一个ItemReader、ItemProcessor、ItemWriter，这三个接口用于读取文件（或数据库）、处理读取的内容（对数据进行加工）、处理后的写入操作（可以简单打印，也可以进行持久化）。
有些简单的批处理任务，可以不要中间的ItemProcessor，这表示读取到的文件可以直接给ItemWriter进行输出或持久化。
下面用一个简单的小程序展示以上这几个类及接口的使用。
三、入门程序 以下展示一个Spring Batch 的简易程序。主要的业务场景是：从文件中读取出学生的信息，根据学生的成绩生成学生的成绩等级，然后打印输出。
项目的目录结构如下：
主要的java类介绍： 其中Bootstrap 是启动类，Student是学生pojo类，StudentProcessor是处理学生信息的处理器类，StudentWriter 是输出学习信息的类。
下面是源代码及解析。
1、首先，配置一个批处理的上下文job-context.xml，配置一个jobRepository，以及jobLauncher。transactionManager 是一个事务管理器。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"&gt; &lt;!-- JobRepository存储执行期的元数据，提供两种默认实现,一种是存放在内存中,默认实现类为:MapJobRepositoryFactoryBean(即下面的配置)、 另一种是存入数据库中,可以随时监控批处理Job的执行状态,查看Job执行结果是成功还是失败,并且使得在Job失败的情况下重新启动Job成为可能。 --&gt; &lt;bean id="jobRepository" class="org.springframework.batch.core.repository.support.MapJobRepositoryFactoryBean"&gt;&lt;/bean&gt; &lt;bean id="jobLauncher" class="org.springframework.batch.core.launch.support.SimpleJobLauncher"&gt; &lt;property name="jobRepository" ref="jobRepository"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="transactionManager" class="org.springframework.batch.support.transaction.ResourcelessTransactionManager"/&gt; &lt;/beans&gt; JobRepository存储执行期的元数据，提供两种默认实现,一种是存放在内存中,默认实现类为:MapJobRepositoryFactoryBean(即本示例的配置)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28a7ab0b55477425915f99784855ce23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435d387dc26b4c2138affea5c1641837/" rel="bookmark">
			nginx通过获取环境变量实现动态IP代理配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案一（推荐）： 转：https://blog.csdn.net/jiangqian6481/article/details/78310247
方案二： 下载nginx镜像 使用官方带perl模块（ngx_http_perl_module）的nginx镜像
docker pull nginx:perl 修改配置 nginx.conf配置
user root; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; //环境变量 env PROXY_HOST; env PROXY_IP; load_module modules/ngx_http_perl_module.so; events { use epoll; worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; #运用perl获取环境变量赋值 perl_set $PROXY_HOST 'sub { return $ENV{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/435d387dc26b4c2138affea5c1641837/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0668a32470d30add1e2463d01b2166a/" rel="bookmark">
			Epoll原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		epoll原理解析：https://blog.csdn.net/armlinuxww/article/details/92803381
elect、poll、epoll优缺点：https://blog.csdn.net/qq_35433716/article/details/82588619
epoll原理图解：https://blog.csdn.net/qq_35433716/article/details/85345907
epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ebd3b110894a5814f96a24054974ba/" rel="bookmark">
			PodWorkers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蚂蚁金服kubernetes方向招聘
PodWorkers是最终“同步”pod状态的一块逻辑，
“同步”在这里的含义是：确保kubelet所在节点的Pod状态和etcd中的状态一致，该增加的增加，该删除的删除，该更新的更新。
“同步”动作的触发有几个方式：
（1）通过文件、apiserver、http方式监听到的变化
（2）定时器触发，例如每隔10s
PodWorkers的入口是UpdatePod
type podWorkers struct { // key是pod的ID，value是一个chan，会有一个gorouting监听该chann // 死循环一般的处理该Pod上的所有变动 podUpdates map[types.UID]chan UpdatePodOptions // 记录每个pod对应的gorouting当前的工作状态 isWorking map[types.UID]bool // 每个Pod对应的gorouting处理完相关逻辑之后，会把Pod的ID塞入 // workQueue。定时器会触发kubelet，kubelet会从workQueue里 // 获取需要同步的Pod，然后调用PodWorkers的UpdatePod方法， // 触发新一轮的同步 workQueue queue.WorkQueue } 简单的示意图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a01121819ad025928d9d41becf0218/" rel="bookmark">
			动手学PyTorch | (14) 模型构造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		让我们回顾⼀下在(多层感知机的简洁实现)中含单隐藏层的多层感知机的实现方法。我们⾸先构造Sequential实例，然后依次添加两个全连接层。其中第一层的输出⼤小为256，即隐藏层单元个数是256;第二层的输出⼤小为10，即输出层单元个数是10。我们在其他小节中也使用了Sequential类构造模型。这⾥我们介绍另外⼀种基于Module类的模型构造方法：它让模型构造更更加灵活。
目录
1. 继承Module类来构造模型
2. Module的子类
3. 构造复杂的模型
4. 小结
1. 继承Module类来构造模型 Module类是nn模块⾥提供的一个模型构造类，是所有神经⽹络模块的基类，我们可以继承它来定义我们想要的模型。下⾯继承Module类构造本节开头提到的多层感知机。这⾥定义的MLP类􏰀重载了Module类的__init__函数和forward函数。它们分别用于创建模型参数和定义前向计算。前向计算也即正向传播。
import torch from torch import nn class MLP(nn.Module): # 声明带有模型参数的层，这里声明了两个全连接层 def __init__(self, **kwargs): # 调用MLP父类Block的构造函数来进行必要的初始化。这样在构造实例时还可以指定其他函数 # 参数，如“模型参数的访问、初始化和共享”一节将介绍的模型参数params super(MLP, self).__init__(**kwargs) self.hidden = nn.Linear(784, 256) # 隐藏层 self.act = nn.ReLU() self.output = nn.Linear(256, 10) # 输出层 # 定义模型的前向计算，即如何根据输入x计算返回所需要的模型输出 def forward(self, x): a = self.act(self.hidden(x)) return self.output(a) 以上的MLP类中无须定义反向传播函数。系统将通过⾃动求梯度⽽⾃动⽣成反向传播所需的backward函数。
我们可以实例化MLP类得到模型变量net。下⾯的代码初始化net并传入输入数据X做一次前向计算。其中，net(X)会调用MLP继承自Module类的__call__函数，这个函数将调⽤MLP类定义的forward函数来完成前向计算。
X = torch.rand(2, 784) #每行代表一个样本的特征向量 net = MLP() print(net) net(X) 注意，这⾥并没有将Module类命名为Layer（层）或者Model（模型）之类的名字，是一个可供⾃由组建的部件。它的子类既可以是⼀个层(如PyTorch内置的Linear类),⼜可以是⼀个模型(如这里定义的MLP类)，或者是模型的一个部分。我们下面通过两个例子来展示它的灵活性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a01121819ad025928d9d41becf0218/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d238fd3427b2a4fd3bbcb52201e8644d/" rel="bookmark">
			OkHttp 3.14.x 源码解析-拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文OkHttp源码基于3.14.x,版本下载地址：okHttp 3.14.x
前言 上一篇文章OkHttp 3.14.x 源码解析-执行流程我们分析了OKHttp的整体执行流程，也从中提到了OKHttp会调用各拦截器来获取响应数据，但是并没有展开来讲，所以这篇文章我们将来详细分析各个拦截器的职责。
从上篇文章我们知道OKHttp有七大拦截器，按添加顺序为：
应用拦截器：可在构造okHttpClient对象时通过addInterceptor配置重试，重定向拦截器：RetryAndFollowUpInterceptor桥接拦截器：BridgeInterceptor缓存拦截器：CacheInterceptor：连接拦截器：ConnectInterceptor网络拦截器：可在构造okhttpClient对象时通过addNetworkInterceptor配置服务请求拦截器：CallServerInterceptor 其中第1个应用拦截器和第6个网络拦截器为自定义配置，在这里我们将假设用户没有自定义配置拦截器，故不分析这两个拦截器，下面将按顺序详细分析其它五个拦截器。
一、RetryAndFollowUpInterceptor 由于这里我们假设没有加入自定义拦截器，所以RetryAndFollowUpInterceptor将成为责任链中最先被调用的拦截器，这个拦截器的主要作用就是负责失败重试以及重定向，我们先看看RetryAndFollowUpInterceptor的intercept方法
RetryAndFollowUpInterceptor#intercept
@Override public Response intercept(Chain chain) throws IOException { //当前请求 Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; //重点关注这个Transmitter类 Transmitter transmitter = realChain.transmitter(); //重定向的次数 int followUpCount = 0; //记录上一个请求 Response priorResponse = null; while (true) {//启动循环 //会创建ExchangeFinder对象，在连接池中会提到 transmitter.prepareToConnect(request); if (transmitter.isCanceled()) { throw new IOException("Canceled"); } Response response; boolean success = false; try { //执行责任链下一结点的proceed方法，其实就是执行BridgeInterceptor的intercept response = realChain.proceed(request, transmitter, null); success = true; } catch (RouteException e) { //路由异常，尝试恢复，如果再次失败则抛出异常 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d238fd3427b2a4fd3bbcb52201e8644d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f55b13c26043f60724d7865d017136/" rel="bookmark">
			面试官如何考察你的思维方式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.两种思维方式
在求职面试中，经常会考察这种问题：
北京有多少量特斯拉汽车？ 某胡同口的煎饼摊一年能卖出多少个煎饼？ 深圳有多少个产品经理？ 一辆公交车里能装下多少个乒乓球？ 一个正常成年人有多少根头发？
这类估算问题，被称为费米问题，是以科学家费米命名的。为什么面试会问这种问题呢？
这类问题能把两类人清楚地区分出来。
一类是具有文科思维的人，擅长赞叹和模糊想象，它主要依靠的是人的第一反应和直觉，比如小孩天生就会看到的东西进行赞叹。 另一种就是具有理科思维的人，擅长通过逻辑推理、分析的能力解决具体问题。这种思维不是人天生的，需要经过长期的训练。
公司招聘人需要的是经过长期训练，能把事情做成，具有严密逻辑推理、分析能力的人，所以费米问题可以考察出一个人有什么样的思维方式。
2.如何回答费米问题？
一般人拿到费米问题这样的题目就会感觉摸不着头脑，不知道怎么解决，干脆凭感觉瞎猜一个数字。
这其实忽视了面试官考察的目的，他不是要你一个确定的数字，而是想看到你面对问题的分析思路。
所以，你需要把自己的思路说出来，来证明你的思维方式是理科思维，而不是一上来凭感觉胡说八道的人。
回答费米问题，要用到我们之前讲过的“逻辑树分析方法”，将一个复杂的问题拆解成子问题，然后逐一解决。
3.案例
有人曾经问科学家费米：“芝加哥有多少位钢琴调音师？”
什么是钢琴调音师呢？
为了保持钢琴音的准确性，需要定期由专业人员检查，调整不准确的音。从事这类工作的人被称为钢琴调音师。有一部分非常好看的电影就叫《调音师》。
这个问题我们使用逻辑树分析方法来拆解成子问题。
钢琴调音师数量=全部钢琴调音师1年的总工作时间/ 一位调音师每年工作时间。
所以，我们可以把这个问题拆解为2个子问题：
1）全部钢琴调音师1年的总工作时间
2）一位钢琴师每年工作时间
“全部钢琴调音师1年的总工作时间”又可以拆解成3个子问题解决：
1）芝加哥有多少架钢琴？
2）钢琴每年要调几次音？
3）调一次得多长时间？
现在我们一个一个去解决这些子问题。
1）第一个子问题：芝加哥有多少架钢琴？
这个不知道。我们再把它拆分。首先需要知道芝加哥有多少人，其次需要知道拥有钢琴的人所占的一个比例。
芝加哥的人口上网可以查出来大概有250万。
有钢琴的人占的比例是多少？不知道，但是我们可以猜一下，钢琴对普通家庭来说比较贵，而且钢琴占地比较大不方便放在家里，所以我们猜家庭拥有钢琴的比例是1%。
为什么是1%，不是5%呢？因为1%通常表示概率最低，有的机构拥有钢琴数量比个人多点，比如音乐学院，所以我们再猜个数字，大概是2%左右。
有了这些数据，做个简单的计算，可以算出芝加哥大概有5万架钢琴。
2）第二个子问题：钢琴每年要调几次音？
钢琴调音师属于稀缺行业，人肯定不多，钢琴它也不像吉他需要频繁地调音，估计是一年一次。3）第三个子问题：调一次得多久？
大概猜两小时吧。
4）第四个子问题：一位调音师每年工作多长时间呢？
美国每年有四个星期是假期，一年大概有50个星期。一周工作5天，按每天8小时的工作时间来算。这三个数相乘，就可以算出一位调音师每年工作时间是2000个小时。
但是钢琴调音师要四处跑呀，肯定要在路上花时间的，所以减去大概20%的时间，所以调音师每年大概工作1600个小时（2000小时-2000小时*20%）。
现在我们把4个子问题汇总一下。全部钢琴调音师1年的总工作时间是3个子问题的数字相乘，也就是5万架钢琴每年需要调一次音，每次调音需要两小时，一共就是10万小时，调音师每年工作1600小时。
我们再用全部钢琴调音师1年的总工作时间 除以 一位调音师每年工作时间，就得到了62.5。再四舍五入，费米预测芝加哥大概有63位调音师。
这个答案准不准呢？后来费米找到了一张芝加哥调音师的名单，上面一共有83人，有不少的人名还是重复的。要知道，费米是估算出来的，已经相当准了。
4.总结
公司通过“费米问题”来判断一个人是不是有逻辑思维能力，日常我们也可以通过有意识的做“费米问题”来改善逻辑思维能力。
解决“费米问题”的办法是使用逻辑树分析方法，将一个复杂的问题拆分成一个一个小问题。从而将没有思路的问题变成条理清晰的思路。
现在留一个思考题，你可以把分析思路写到留言区：
估算北京有多少量特斯拉汽车？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c7a7bbfd576d9938d1198f8eb817570/" rel="bookmark">
			红外人脸识别和3D结构光人脸识别有什么区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人脸识别技术有静态和动态人脸识别之分，也有2D和3D人脸识别之分，还有可见光和红外光人脸识别之分。其中红外人脸识别和3D人脸识别的结构光人脸识别的媒介是红外光。那么，由畅视智能与大家分享红外人脸识别和3D结构光人脸识别有什么区别？
红外人脸识别组件是由红外泛光灯与IR摄像头组成，输出一张红外IR图，通过红外泛光灯，可以在黑暗中成像红外图，因此其适用范围远大于普通的RGB摄像头，并且不容易被自然光环境干扰。在识别方面还是2D人脸识别，对于活体检测因为近红外成像的特点，可以通过不同材质的红外光反射率进行相应的活体检测，可以对于屏幕视频或者是照片这些类型的攻击有很强防御能力，如果是其他材质的攻击要看红外人脸识别的算法设计。
3D结构光人脸识别是在红外的基础上，增加一个红外点阵发射器，输出的图包括一张红外IR图和一张深度图，不管是深度图还是IR图都是利用红外光的光源，因此可以在在黑暗环境中使用，并且不易被自然光环境干扰。3D结构光的人脸识别的活体检测这块，是通过引入深度图，是使用IR和深度两个人脸图像进行3D的活体检测。而且可以在红外人脸识别防范的攻击算法基础上，加入的深度图携芾深度信息，能够有效防范平面攻击，比如说照片、视频、纸张面具弯曲等材质的攻击，还可以结合红外IR图对表面材质的检测，能防范大部分的普通材质的面具、模型等攻击。
在人脸识别算法上，3D结构光的人脸识别应用的安全性能可以弥补2D人脸识别，随着对人脸识别算法的提升，红外人脸识别在应用也会有更高的安全性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cf2702015785e6ea33ee3c771b5e3a1/" rel="bookmark">
			oracle中的字符串处理的特殊字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、用escape定义转义字符 在sql中我们可以使用‘%’、‘_’等通配符进行模糊查询，比如下面，会查询到所有ename以A开头的所有人员：
09:59:47 SCOTT@vbox88in*SQL&gt;select * from emp1 where ename like 'A%'; EMPNO ENAME JOB MGR HIREDATE SAL COMM DEPTNO ---------- ---------- --------- ---------- ------------------- ---------- ---------- ---------- 7499 ALLEN SALESMAN 7698 1981-02-20 00:00:00 1600 300 30 7876 ADAMS CLERK 7788 1987-05-23 00:00:00 1100 20 而如果要匹配的字符串中含有‘%’、‘_’等通配符呢，我们要怎么查询，比如有下面t2表：
NAME ------------------------------------------------------------ hyman h_man _man h%man 我如果要查name以’h%'开头的数据，要怎么编写sql语句？按照通常的思路：
10:13:24 SCOTT@vbox88in*SQL&gt;select * from t2 where name like 'h%%'; NAME ------------------------------------------------------------ hyman h_man h%man 这显然不是我们预期的结果，要实现这一查询功能，我们可以借助escape关键字，将任意一个字符定义成一个转义字符，比如：
10:18:25 SCOTT@vbox88in*SQL&gt;select * from t2 where name like 'h!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cf2702015785e6ea33ee3c771b5e3a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8fd853ef1f8df529619ce9fee8d8cff/" rel="bookmark">
			在Python中进行加减乘除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节我们讲到了在Python中打印字符串，而字符串必须要使用单引号或双引号包围。
本节我们讲一下在Python中如何使用数字。
在Python中打印数字是不需要使用引号的，我们来看一下例子：
加减乘除计算 Python中不仅可以直接打印数字，还能对数字进行像数学中的加减乘除计算。我们来看一下：
字符串和数字的区别 上图中类似print(3 + 8)输出11，这是计算结果。
如果我们将其中的3 + 8用引号引起来，则会被解释为字符串，并按原样输出。
我们一起来看一下：
动手练习 1.输出一个数值1000。
2.使用Python来计算69和48相加的结果。
3.使用Python计算100加60，减10，除以5，乘以2的结果。
4.输出字符串9 * 7。
参考：https://www.9xkd.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a20c8c4cb91bb9677bcbc103c8f95ed/" rel="bookmark">
			Unity UGUI不规则区域点击的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Unity UGUI不规则区域点击的实现 一篇比较全面的文章 链接: 文章. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/740577d4e0da8e16d120b3a7455591a5/" rel="bookmark">
			PTA：7-8 简单的猜数字游戏[2]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-8 简单的猜数字游戏[2] (15 分) 猜数字游戏是令游戏机随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”）、小了（“Too small”），还是相等（“Lucky You!”）。如果猜到，则结束程序。如果超过7次都没有猜到，则提示“Game Over”，并结束程序。
输入格式:
输入第一行中给出一个不超过100的正整数，代表游戏机产生的随机数。 从第二行起，每行给出一个用户的输入，直到猜中或者超过7次还没有猜中。
输出格式:
每次在一行中输出相应的猜测结果，直到输出猜对的结果“Lucky You!”或“Game Over”则结束。
输入样例1:
12
50
25
12
输出样例1:
Too big
Too big
Lucky You!
输入样例2:
60
50
75
58
64
63
62
61
输出样例2:
Too small
Too big
Too small
Too big
Too big
Too big
Too big
Game Over!
程序清单：
#include&lt;stdio.h&gt; int main() { int a,b,n; scanf("%d",&amp;a); for(n=1;n&lt;=7;n++) { scanf("%d",&amp;b); if(a==b) { printf("Lucky You!"); break; } else if(b&gt;a) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/740577d4e0da8e16d120b3a7455591a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b5b73523cbd60b391ac20013ef6c23/" rel="bookmark">
			Ubuntu下NFS服务器的安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、NFS服务的简介 NFS 是 Network File System 的缩写，是Sun公司于1984开发的一种分布式文件系统协议。它的核心功能就是可以通过网络，让不同的客户端，可以彼此访问共同的文件系统，来实现文件的共享。像许多其他的协议，建立在开放的网络计算的远程过程调用（RPC）之上。NFS是在RFC中定义的开放标准，允许任何人实现该协议。
NFS 服务器可以让客户端将网络远程的 NFS 服务器分享的目录，直接挂载到本地端的机器当中。本地端的机器通过直接读写挂载的目录，就可以同步到NFS服务器之上。
版本更迭 NFS V2
2是NFS最早实现的版本之一，基于UDP协议实现了一个无状态的服务器版本。仅仅支持32位的系统，且不大于2GB的文件。
NFS V3
3的版本在2的基础之上做了大量的改进。支持了大于2GB的文件读写，使用了TCP协议来进行数据交互，支持了客户端的异步读写来提高文件系统的性能（同时也会产生我们头疼的一致性问题）
NFS V4
4的版本提高了安全性，通过TCP协议实现了一个有状态的服务器版本，通过锁租约的机制来实现多客户端的读写同步。在4.1版本引入了pNFS，通过类似于一个HDFS架构来提供并行的一个分布式文件系统。
二、系统环境 系统平台： Ubuntu 14.04
NFS Server IP： 192.168.1.2
iptables关闭： Firewall is disable.（NFS端口使用在默认情况下是不固定，所以若配置NFS服务器需要搭配防火墙使用的话，请配置固定端口）
SELINUX=disabled
三、NFS服务器的安装 NFS的安装只需要安装rpcbind与nfs-server就可以对外提供服务了。
rpcbind
NFS 服务都是通过 RPC 来具体实现的，所以要正常使用NFS服务，需要启动 rpcbind来实现端口的映射工作 。执行如下命令，安装并启动rpcbind
sudo apt-get install rpcbind nfs-kernel-server
提供nfs服务器的软件，提供文件系统的完整功能。这里要提醒一下，NFS服务器会直接使用到内核的模块，所以内核必须要支持 NFS 才行。如果操作系统的版本是自行编译的内核的话，需要注意编译NFS的内核支持。
sudo apt-get install nfs-kernel-server 四、NFS服务器的配置 NFS服务器的主要配置文件就是：/etc/exports。不过这个配置文件不一定会存在，可能需要使用 vim 主动新建这个文件。
/etc/exports文件由以下选项构成：
共享的目录 主机名或IP(参数1,参数2...参数N) 每一行最前面是要分享出来的目录，目录可以依照不同的权限分享给不同的主机。若权限参数不止一个时，则以逗号 (,) 分开。且主机名与小括号是连在一起的喔！其中参数是可选的，当不指定参数时，nfs将使用默认选项。默认的共享选项是 sync,ro,root_squash,no_delay ，当主机名或IP地址为空时，则代表共享给任意客户机提供服务。
下面是一些NFS共享的常用参数：
访问权限选项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b5b73523cbd60b391ac20013ef6c23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f00ce847d90cb6850957c312e7ddf094/" rel="bookmark">
			Python 的日志学习——logger模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.cnblogs.com/yyds/p/6901864.html
Python之日志处理（logging模块）
本节内容 日志相关概念logging模块简介使用logging提供的模块级别的函数记录日志logging模块日志流处理流程使用logging四大组件记录日志配置logging的几种方式向日志输出中添加上下文信息参考文档 一、日志相关概念 日志是一种可以追踪某些软件运行时所发生事件的方法。软件开发人员可以向他们的代码中调用日志记录相关的方法来表明发生了某些事情。一个事件可以用一个可包含可选变量数据的消息来描述。此外，事件也有重要性的概念，这个重要性也可以被称为严重性级别（level）。
1.日志的作用 通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。
简单来讲就是，我们通过记录和分析日志可以了解一个系统或软件程序运行情况是否正常，也可以在应用程序出现故障时快速定位问题。比如，做运维的同学，在接收到报警或各种问题反馈后，进行问题排查时通常都会先去看各种日志，大部分问题都可以在日志中找到答案。再比如，做开发的同学，可以通过IDE控制台上输出的各种日志进行程序调试。对于运维老司机或者有经验的开发人员，可以快速的通过日志定位到问题的根源。可见，日志的重要性不可小觑。日志的作用可以简单总结为以下3点：
程序调试了解软件程序运行情况，是否正常软件程序运行故障分析与问题定位 如果应用的日志信息足够详细和丰富，还可以用来做用户行为分析，如：分析用户的操作行为、类型洗好、地域分布以及其它更多的信息，由此可以实现改进业务、提高商业利益。
2.日志的等级 我们先来思考下下面的两个问题：
作为开发人员，在开发一个应用程序时需要什么日志信息？在应用程序正式上线后需要什么日志信息？作为应用运维人员，在部署开发环境时需要什么日志信息？在部署生产环境时需要什么日志信息？ 在软件开发阶段或部署开发环境时，为了尽可能详细的查看应用程序的运行状态来保证上线后的稳定性，我们可能需要把该应用程序所有的运行日志全部记录下来进行分析，这是非常耗费机器性能的。当应用程序正式发布或在生产环境部署应用程序时，我们通常只需要记录应用程序的异常信息、错误信息等，这样既可以减小服务器的I/O压力，也可以避免我们在排查故障时被淹没在日志的海洋里。那么，怎样才能在不改动应用程序代码的情况下实现在不同的环境记录不同详细程度的日志呢？这就是日志等级的作用了，我们通过配置文件指定我们需要的日志等级就可以了。
不同的应用程序所定义的日志等级可能会有所差别，分的详细点的会包含以下几个等级：
DEBUGINFONOTICEWARNINGERRORCRITICALALERTEMERGENCY 3.日志字段信息与日志格式 本节开始问题提到过，一条日志信息对应的是一个事件的发生，而一个事件通常需要包括以下几个内容：
事件发生时间事件发生位置事件的严重程度--日志级别事件内容 上面这些都是一条日志记录中可能包含的字段信息，当然还可以包括一些其他信息，如进程ID、进程名称、线程ID、线程名称等。日志格式就是用来定义一条日志记录中包含那些字段的，且日志格式通常都是可以自定义的。
说明：
输出一条日志时，日志内容和日志级别是需要开发人员明确指定的。对于而其它字段信息，只需要是否显示在日志中就可以了。
4.日志功能的实现 几乎所有开发语言都会内置日志相关功能，或者会有比较优秀的第三方库来提供日志操作功能，比如：log4j，log4php等。它们功能强大、使用简单。Python自身也提供了一个用于记录日志的标准库模块--logging。
二、logging模块简介 logging模块定义的函数和类为应用程序和库的开发实现了一个灵活的事件日志系统。logging模块是Python的一个标准库模块，由标准库模块提供日志记录API的关键好处是所有Python模块都可以使用这个日志记录功能。所以，你的应用日志可以将你自己的日志信息与来自第三方模块的信息整合起来。
1. logging模块的日志级别 logging模块默认定义了以下几个日志等级，它允许开发人员自定义其他日志级别，但是这是不被推荐的，尤其是在开发供别人使用的库时，因为这会导致日志级别的混乱。
日志等级（level）描述DEBUG最详细的日志信息，典型应用场景是 问题诊断INFO信息详细程度仅次于DEBUG，通常只记录关键节点信息，用于确认一切都是按照我们预期的那样进行工作WARNING当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的ERROR由于一个更严重的问题导致某些功能不能正常运行时记录的信息CRITICAL当发生严重错误，导致应用程序不能继续运行时记录的信息 开发应用程序或部署开发环境时，可以使用DEBUG或INFO级别的日志获取尽可能详细的日志信息来进行开发或部署调试；应用上线或部署生产环境时，应该使用WARNING或ERROR或CRITICAL级别的日志来降低机器的I/O压力和提高获取错误日志信息的效率。日志级别的指定通常都是在应用程序的配置文件中进行指定的。
说明：
上面列表中的日志等级是从上到下依次升高的，即：DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL，而日志的信息量是依次减少的；当为某个应用程序指定一个日志级别后，应用程序会记录所有日志级别大于或等于指定日志级别的日志信息，而不是仅仅记录指定级别的日志信息，nginx、php等应用程序以及这里要提高的python的logging模块都是这样的。同样，logging模块也可以指定日志记录器的日志级别，只有级别大于或等于该指定日志级别的日志记录才会被输出，小于该等级的日志记录将会被丢弃。 2. logging模块的使用方式介绍 logging模块提供了两种记录日志的方式：
第一种方式是使用logging提供的模块级别的函数第二种方式是使用Logging日志系统的四大组件 其实，logging所提供的模块级别的日志记录函数也是对logging日志系统相关类的封装而已。
logging模块定义的模块级别的常用函数
函数说明logging.debug(msg, *args, **kwargs)创建一条严重级别为DEBUG的日志记录logging.info(msg, *args, **kwargs)创建一条严重级别为INFO的日志记录logging.warning(msg, *args, **kwargs)创建一条严重级别为WARNING的日志记录logging.error(msg, *args, **kwargs)创建一条严重级别为ERROR的日志记录logging.critical(msg, *args, **kwargs)创建一条严重级别为CRITICAL的日志记录logging.log(level, *args, **kwargs)创建一条严重级别为level的日志记录logging.basicConfig(**kwargs)对root logger进行一次性配置 其中logging.basicConfig(**kwargs)函数用于指定“要记录的日志级别”、“日志格式”、“日志输出位置”、“日志文件的打开模式”等信息，其他几个都是用于记录各个级别日志的函数。
logging模块的四大组件
组件说明loggers提供应用程序代码直接使用的接口handlers用于将日志记录发送到指定的目的位置filters提供更细粒度的日志过滤功能，用于决定哪些日志记录将会被输出（其它的日志记录将会被忽略）formatters用于控制日志信息的最终输出格式 说明： logging模块提供的模块级别的那些函数实际上也是通过这几个组件的相关实现类来记录日志的，只是在创建这些类的实例时设置了一些默认值。
三、使用logging提供的模块级别的函数记录日志 回顾下前面提到的几个重要信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f00ce847d90cb6850957c312e7ddf094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfcf75d0a7000e0c4d2fadf98892ca6b/" rel="bookmark">
			生信-使用NCBI进行目的基因的引物设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用NCBI进行目的基因的引物设计 全文概述 利用生信工具进行目的基因的引物设计，使用了NCBI进行筛选与设计引物，使用 idtdna对筛选出的DNA进行检查。本文分享了如何筛选出高质量的基因引物，帮助想通过生信进行引物设计的学生、从业者找出合适的基因，毕竟购买引物也比较烧钱，避免设计出的基因质量偏低。
NCBI查找基因 1.查询目的基因：https://www.ncbi.nlm.nih.gov/nuccore/?term=zbed3
备注：这里需要注意的是，要找到合适的目的基因！如果找智人，一般会是NM开头
2.选择其中一个数据连接：https://www.ncbi.nlm.nih.gov/nuccore/NM_001329564.2，选择Pick Primers
3.进入：
设计-筛选设置 4.根据一些实验经验调节一些关键参数：
1）Primer Parameters-PCR product size：设置为75-300
2）Exon/intron selection- Exon junction span：设置必须跨越外显子（Primer must span an exon-exon junction），避免污染
3） Advanced parameters - Primer Parameters：GC建议在40%-60%之间
5.点击Get Primers
6.跳转页面
https://www.ncbi.nlm.nih.gov/tools/primer-blast/primertool.cgi?ctg_time=1561727583&amp;job_key=v7VgKRZ5G9E86w3uAI4p3HqVOO5XhiPzVg
7.挑选合适的primer pair，其中product length最好是在150附近（不是绝对）
设计-DNA检查 8.注册idtdna进行dna分析，https://sg.idtdna.com/calc/analyzer
9.抽取其中一个primer pair
Primer pair 6 Sequence (5’-&gt;3’)Template strandLengthStartStopTmGC%Self complementaritySelf 3’ complementarityForward primerACAGCAACACAGAAGACCGTPlus2060462359.8250.003.003.00Reverse primerCCAGTAAGCTTGCCATTGAGCMinus2174972959.8752.386.003.00Product length146Exon junction737/738 (reverse primer) on template NM_001115114.1 Products on intended target
NM_001115114.1 Danio rerio glyceraldehyde-3-phosphate dehydrogenase (gapdh), mRNA
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfcf75d0a7000e0c4d2fadf98892ca6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d496d605610398d4e368b77868e0146/" rel="bookmark">
			汇编语言程序设计（第二版） 刘慧婷 王庆生 主编 课后参考答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汇编语言程序设计（第二版） 刘慧婷 王庆生 主编 课后参考答案 第一章 1.1 什么是机器语言？什么是汇编语言？简述汇编语言的特点。 机器语言就是用二进制编码组成的机器指令的集合和一组使用机器指令的规则。汇编语言是对机器指令中的操作码用英文单词的缩写描述，对操作数用标号、变量、常量描述。
汇编语言的特点：
（1）与机器有关：移植性差，但可直接控制硬件。
（2）程序效率高。
（3）局限性：受指令的限制，如考虑存储单元等。
（4）调试困难。
1.2 汇编程序与汇编源程序的区别是什么？ 汇编源程序是指用汇编语言编写的程序，而汇编程序特指将汇编源程序汇编成目标文件的编译程序。
1.3 把下列十进制数转换为二进制数和十六进制数。 （1）67 （2）34 （3）254 （4）123 答：（1）1000011,43 （2）100010， 22
（3）1111 1101，FE （4）111 1011，7B
1.4 把下列二进制数转换为十六进制数和十进制数。 (1)01101101 (2)10110010 (3)111111 答：（1）6D，109 （2）B2,178， （3）3F，63
1.5 作下列十六进制数的运算，并转换为十进制数校核。 (1)5A+64 (2)86-49 (3)123-9A (4)43×2B 答：（1） BE （2）3D （3） 89 （4） B41
1.6 根据补码定义把下列十进制数表示为8位二进制补码。 (1) 64 (2) -24 答：（1）0100 0000 （2）[10011000]原=[1110 1000]补
第二章 2.1 简述计算机系统组成。 答：计算机由中央处理器CPU，存储器，输入系统，输出系统组成，由系统总线连接在一起。CPU包括运算器和控制器，运算器执行指令，控制器负责计算机的控制。存储器是计算机的记忆部件，以二进制形式存放程序和数据。输入输出系统包括大容量存储器，如硬盘，以及其他外设，如鼠标，键盘，显示器等。
2.2 简述16位机的各类寄存器的主要作用。 答：（1）数据寄存器：Ax，Bx，Cx，Dx； AX：作为累加器，是算术运算的主要寄存器。在乘除等指令中存放操作数，在I/O指令中使用它与外部设备传送信息。BX：当通用寄存器使用，在计算存储器地址时，作基址寄存器使用。CX：当通用寄存器使用，此外常用来保存计数值，当计数器使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d496d605610398d4e368b77868e0146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d73d7864df4bc1870d16cbccdf3d338a/" rel="bookmark">
			python--查看函数帮助文档及快捷键使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看函数帮助文档的方法 鼠标放在要查找的函数上，点击工具栏view
选择：Quick Definition (快捷键 ctrl+shift+I)
或者Quick Documentation(快捷键ctrl +Q)
快捷键不好用的原因 如crtl+c ctrl+v无法正常使用
file—&gt;setting—&gt;plugins :取消勾选 IdealVim
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58357545c44f45ae1a35df22e9172408/" rel="bookmark">
			TLB、PCID与ASID的故事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TLB、PCID与ASID的故事 最近学习过程中了解到TLB和PCID、ASID等概念，突然发现自己将TLB与Cache的概念容易搞混。于是深入了解这几个名词和关系，本周做一些总结。本文的各部分内容分布如下：
TLB的引入TLB与CachePCID和ASID的引入与作用 一、TLB的引入 1.1 二级页表的地址访问 让我们想象这样的应用场景：CPU执行指令时，直接访问的是虚拟地址，若想获取到内存的真实数据时，需要先将虚拟地址转化为物理地址，然后由CPU访问物理地址指向的内存空间，读取内存数据。
上述过程中，虚拟地址到物理地址的转化过程是有较大的性能消耗的。我们以二级页表为例分析地址转换过程中对内存的访问。接下来我们分析地址转化过程中涉及到的组件以及访问内存的次数：
内存：存放大量的页目录表、页表
MMU：利用硬件实现虚拟地址到物理地址的转换。完成以下四步，不需要编写指令指示MMU去做。（前提是操作系统要维护页表项的正确性，每次分配内存时填写相应的页表项，每次释放内存时清除相应的页表项，在必要的时候分配或释放整个页表）
取出保存在TTB寄存器(translation table base register)的第一级页表(translation table)的基地址，这个基地址指的是PA，也就是说页表是直接按照这个地址保存在物理内存中的。以TTB中的内容为基地址，以VA[31:20]为索引值在一级页表中查找出一项，该页表项中保存着第二级页表(coarse page table)的基地址，这同样是物理地址，也就是说第二级页表也是直接按这个地址存储在物理内存中的。以VA[19:12]为索引值在第二级页表中查出一项，这个表项中就保存着物理页面的基地址。有了物理页面的基地址之后，加上VA[11:0]这个偏移量(2^12=4KB)就可以取出相应地址上的数据。 这四步被称作Translation Table Walk。这个过程中访问内存中一级页面、内存中二级页面、物理页面，一次寻址其实是三次访问物理内存。这里提供一个快速计算内存访问次数的方法：
多级页表的访问次数(假设无快表)：N级页表访问一个逻辑地址需要N+1次内存访问。 1.2 TLB的引入 由1.1可知，多级页表的访问需要较大的开销。TLB（translation lookaside buffer，又称转换后援缓冲器、转换旁路缓冲区、快表）的引入可以减少多级页表对内存的访问。对TLB的介绍如下：
TLB是关联的快速内存。TLB条目由两部分组成：键（标签）和值。当关联内存根据给定值查找时，它会同时与所有键进行比较。TLB是MMU中的一块高速缓存，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，执行Translation Table Walk，这样就减少了页表查询导致的处理器性能下降。 1.3 TLB机制下的地址访问 在引入TLB之后，TLB和页表共同提供地址映射资源。此时，CPU访问虚拟地址的硬件操作顺序如下（可参考下图）：
CPU内核发出虚拟地址请求读数据，TLB(translation lookaside buffer)接收到该地址。 如果TLB里缓存了当前虚拟地址的页表项就不必做translation table walk了。如果TLB中没有缓存，就去物理内存中读出页表项保存在TLB中。将页号和帧号增加到TLB中。 如果TLB中的条目已满，那么操作系统会选择一个来替换。 页表项中不仅保存着物理页面的基地址，还保存着权限和是否允许cache的标志。MMU首先检查权限位，如果没有访问权限，就引发一个异常给CPU内核。然后检查是否允许cache。 如果允许cache就启动cache和CPU内核互操作，则以虚拟地址为索引到cache中查找是否缓存了要读取的数据。 如果cache中已经缓存了该数据（称为cache hit）则直接返回给CPU内核。如果cache中没有缓存该数据（称为cache miss），则发出PA从物理内存中读取数据并缓存到cache中，同时返回给CPU内核。但cache并不是只去CPU内核所需要的数据，而是把相邻的数据都去上来缓存，这称为一个cache line。 如果不允许cache，那直接发出PA从物理内存中读取数据到CPU内核。 二、TLB与CPU Cache 2.1 CPU Cache相关 CPU Cache的引入是为了缩小CPU和RAM之间的速度不匹配，高速缓存单元插在分页单元和主内存之间（可参考1.3图或2.1图，由于Cache的位置不一定，因此两图都可作为参考），它包含一个硬件高速缓存内存和一个高速缓存控制器。高速缓存内存存放内存中真正的行。高速缓存控制器存放一个表项数组，每个表项对应高速缓存内存中的一个行。
2.2 TLB与Cache的比较 阅读几篇文章之后，本人对CPU Cache和TLB进行以下比较。实际上，TLB也可以认为是页表的Cache。
三、ASID与PCID的引入与作用 由于TLB保存的是进程的一部分页表，操作系统中存在多个进程，每个进程都由自己虚拟地址空间。那么在进程切换的时候，TLB中存放的到底是切换之前的进程页表？还是切换之后的进程页表？为了避免冲突，操作系统在进程切换的时候会进行TLB刷新。下述内容是与TLB刷新有关的问题。
3.1 Global TLB和non-global TLB 现代OS都将地址空间分为内核空间和用户空间。内核空间ring 0访问，用户空间ring 3访问。内核空间内容基本各个进程（包括内核线程）都差不多，内核地址空间是一样的，因此对于这部分地址翻译，无论进程如何切换，内核地址空间转换到物理地址的关系是永远不变的，在进程的时候，不需要清掉。对于用户空间，各个进程的内容都不太一样，保留只会造成混乱，需要清掉。
在这种思路引导下，CPU在加载CR3的时候，只会清掉不带Global标志的用户空间页表TLB，而不会动带有global标志的内核页表项。一个新的进程会开始一个半新的TLB，效能提高不少。
3.2 ASID 类似于Global TLB和non-global TLB的思想。有的TLB在每个TLB条目中还保存地址空间标识码（address-space identifier，ASID）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58357545c44f45ae1a35df22e9172408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea1e22d490fda2661689823464e770ec/" rel="bookmark">
			qt报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Could not find a package configuration file provided by “Qt5” with any of the following names: 解决方法：在CMakeLists.txt文件加上以下路径
set(CMAKE_PREFIX_PATH "C:/Qt/Qt5.13.1/5.13.1/msvc2015_64/lib/cmake/Qt5") 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/454/">«</a>
	<span class="pagination__item pagination__item--current">455/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/456/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>