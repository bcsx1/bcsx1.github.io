<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec9824e91243e7200f27b4bca73690d/" rel="bookmark">
			回文链表，给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题记：
给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
示例 1：
输入：head = [1,2,2,1]
输出：true
示例 2：
输入：head = [1,2]
输出：false
提示：
链表中节点数目在范围[1, 105] 内
0 &lt;= Node.val &lt;= 9
进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？
题目来源：
作者：LeetCode
链接：https://leetcode.cn/leetbook/read/top-interview-questions-easy/xnv1oc/
来源：力扣（LeetCode）
解决方法：
一：反转后半部分链表
这题是让判断链表是否是回文链表，所谓的回文链表就是以链表中间为中心点两边对称。我们常见的有判断一个字符串是否是回文字符串，这个比较简单，可以使用两个指针，一个最左边一个最右边，两个指针同时往中间靠，判断所指的字符是否相等。
但这题判断的是链表，因为这里是单向链表，只能从前往后访问，不能从后往前访问，所以使用判断字符串的那种方式是行不通的。但我们可以通过找到链表的中间节点然后把链表后半部分反转，最后再用后半部分反转的链表和前半部分一个个比较即可。这里以示例2为例画个图看一下。
最后再来看下代码
public boolean isPalindrome(ListNode head) { ListNode fast = head, slow = head; //通过快慢指针找到中点 while (fast != null &amp;&amp; fast.next != null) { fast = fast.next.next; slow = slow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec9824e91243e7200f27b4bca73690d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82eb8672d4ff987cc1272f34219c756d/" rel="bookmark">
			“已放弃 (核心已转储)“解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入：
python demo/image_demo.py demo/demo.jpg configs/swin/mask_rcnn_swin_tiny_patch4_window7_mstrain_480-800_adamw_1x_coco.py weights/mask_rcnn_swin_tiny_patch4_window7_1x.pth 报错：
load checkpoint from local path: weights/mask_rcnn_swin_tiny_patch4_window7_1x.pth
/home/cf206/Swin-Transformer-Object-Detection/mmdet/datasets/utils.py:64: UserWarning: "ImageToTensor" pipeline is replaced by "DefaultFormatBundle" for batch inference. It is recommended to manually replace it in the test data pipeline in your config file.
warnings.warn(
QObject::moveToThread: Current thread (0x55ed0093b9b0) is not the object's thread (0x55ecfb125c50).
Cannot move to target thread (0x55ed0093b9b0)
qt.qpa.plugin: Could not load the Qt platform plugin "xcb" in "/home/cf206/anaconda3/envs/lane_seg/lib/python3.8/site-packages/cv2/qt/plugins" even though it was found.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82eb8672d4ff987cc1272f34219c756d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f29ae1924fdc22380a2411f962d0ea/" rel="bookmark">
			基于边缘计算AidLux的自动驾驶智能预警应用方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上传源码至AidLux（具体操作见前面AIGC帖子）
配置环境：
cd YOLOP/YOLOP
pip install -r requirements.txt
pip install torch1.8.1 torchvision0.9.1 -i https://pypi.mirrors.ustc.edu.cn/simple/
pip install onnxruntime -i https://pypi.mirrors.ustc.edu.cn/simple/
进行推理：
python tools/demo.py --source inference/images
报错进行如下操作，不报错不用看
pip install opencv_python==4.5.4.60 -i https://pypi.mirrors.ustc.edu.cn/simple/
环境配置完成
推理结果
运行预警系统：
python forewarning.py
报错：
解决中文报错后重新运行：
结果：
基于人工智能与边缘计算AidLux的自动驾驶智能预警应用方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f47a8c118cc46f8021b3ea9fedd2a2d/" rel="bookmark">
			卸载、安装mmcv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 卸载mmcv
pip uninstall mmcv pip uninstall mmcv-full 安装mmcv
pip install mmcv-full==1.4.0 -f https://download.openmmlab.com/mmcv/dist/cu101/torch1.8/index.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d50ccc15203d5fc4b5c186559a97ca6/" rel="bookmark">
			Linux命令 安装升级相关命令(一) (持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux命令常用命令持续更新 声明：本人菜鸟一枚，系统是ubuntu22.04,资料均是在网上和书上收集的.如有不对的地方，勿喷，欢迎大佬指出． sudo apt-get update 更新命令
apt-get 命令是 Ubuntu 系统中的包管理工具，可以用来安装、卸载包，也可以用来升级包
语法格式：
apt-get [options] command
sudo apt-get upgrade 升级命令
该命令，将本地已安装的软件与下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。如果你的软件都是最新版本，会提示：
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
apt list --upgradeable
列出可更新的软件包的列表
apt list --installed
列出已经安装的软件包
sudo apt install &lt;package_name&gt;
安装指定的软件命令,如果安装多个包，直接在后面添加包名即可
sudo apt update &lt;package_name&gt;
更新指定包的命令
sudo apt show &lt;package_name&gt;
显示软件包具体信息,例如：版本号，安装大小，依赖关系等等;
sudo apt remove &lt;package_name&gt;
删除软件包命令
sudo apt autoremove
清理不再使用的依赖和库文件
注意： 对于这个命令，请谨慎使用！
sudo apt purge &lt;package_name&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d50ccc15203d5fc4b5c186559a97ca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8afdc7eb65510454fe716fe3a75dbab4/" rel="bookmark">
			安装和配置VNC服务器的法则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道，作为一个系统管理员，大多数时间是通过网络管理服务器的。在管理服务器的过程中，大多数情况下我们只是用 SSH 来完成我们的管理任务。VNC 允许我们开启一个远程图形会话来连接我们的服务器，这样我们就可以通过网络远程访问服务器的图形界面了。
VNC 服务器是一个自由开源软件，它可以让用户可以远程访问服务器的桌面环境。另外连接 VNC 服务器需要使用 VNC viewer 这个客户端。
一些 VNC 服务器的优点：
远程的图形管理方式让工作变得简单方便。剪贴板可以在 CentOS 服务器主机和 VNC 客户端机器之间共享。CentOS 服务器上也可以安装图形工具，让管理能力变得更强大。只要安装了 VNC 客户端，通过任何操作系统都可以管理 CentOS 服务器了。比 ssh 图形转发和 RDP 连接更可靠。 那么，让我们开始安装 VNC 服务器之旅吧。我们需要按照下面的步骤一步一步来搭建一个可用的 VNC。
那么，让我们开始安装 VNC 服务器之旅吧。我们需要按照下面的步骤一步一步来搭建一个可用的 VNC。
首先，我们需要一个可用的桌面环境（X-Window），如果没有的话要先安装一个。
注意：以下命令必须以 root 权限运行。要切换到 root ，请在终端下运行“sudo -s”，当然不包括双引号（“”）。
1. 安装 X-Window 首先我们需要安装X-Window，在终端中运行下面的命令，安装会花费一点时间。
# yum check-update # yum groupinstall "X Window System" ### # yum install gnome-classic-session gnome-terminal nautilus-open-terminal control-center liberation-mono-fonts ### 设置默认启动图形界面 # unlink /etc/systemd/system/default.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8afdc7eb65510454fe716fe3a75dbab4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/511680b903043d4d6606fe766ad70607/" rel="bookmark">
			sqlserver2014安装经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐安装包
推荐安装教程
避雷安装包
sqlserver的卸载
Microsoft工具站
sqlserver2014安装过程中出现的问题及解决办法
一. 推荐安装包 百度网盘：链接：https://pan.baidu.com/s/15jglFPKRXTBasn0uVruRoA
提取码：aaaa
二.推荐安装教程 教程链接
三.避雷安装包 安装包链接
原因：由于该安装包缺少数据库实例，所以安装完以后会发现没有本地服务器。（解决办法：需要自己写数据库实例–类似于有些软件一样，只给最基本的功能，剩下的都得自己装，vs code编辑器就是，需要什么装什么。这个过程类似于配置环境，通俗来讲就是再找一个实例的安装包安装一下）
四.sqlserver的卸载 一.可以借助360软件管家卸载
二. 1.用"Win+R"快捷键打开“运行”对话框，在对话框中输入"services.msc"命令，然后找到所有跟Sql Server有关的服务，并且停止这些服务。（一定要先停止服务再卸载，否则后续卸载文件过程中会失败）。
2.进入控制面板，点击“程序卸载”。
3.在列表中找到“Microsoft SQL Server2014(64位)“，右击选"卸载”(或双击)。
4. 在程序列表中找到"Microsoft SQL Server 2012 Native Client"，此项是数据库的客户端，右击选"卸载"(或双击)。
5.用"Win+R"快捷键打开“运行”对话框，在对话框中输入"regedit"命令。
6.删除相关的文件夹
7.卸载完成后需要重启电脑，否则会导致下一次的安装失败。
五.Microsoft工具站 工具站链接
六.sqlserver2014安装过程中出现的问题及解决办法 说明：安装过程中的很多问题即解决办法上述视频里都有详细介绍，这里只作为补充。
问题：安装过程中页面闪退
原因：之前下载的sqlserver没卸载干净，需要把之前的彻底卸载干净。此外还应注意电脑的自动更新是否打开。selserver安装前需将电脑的自动更新打开。（打开方式：用"Win+R"快捷键打开“运行”对话框，在对话框中输入"services.msc"命令，找到"Windows Update"，并将它的启动类型由"手动"改成"自动"
问题：解决办法：1.删除三个文件夹：MSAS12.MSSQLSERVER、MSSQL12.MSSQLSERVER、
Reporting Services
注意：因为每个人的安装目录不同，一般默认安装的话就在c:/program file/Microsoft sql server或者c:/program file(x86)/Microsoft sql server找就可以了
2.点击重新运行显示通过即可。
问题：SQL Server 2014安装程序已在运行,无法同时启动多次。请完成当前安装操作，然后重新运行安装程序。
原因：这好像是在卸载过程中遇到问题，解决办法好像是要先把sqlserver相关的所有服务暂停，然后再卸载。具体记不太清了😭
如果出现问题，欢迎批评指正啊
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43a6eca71ddc9507e7a9cb4e0e5bbef8/" rel="bookmark">
			SuperMap iObjects Java 之 SpringBoot 部署 GIS 服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 背景2. 环境准备2.1. 系统环境2.2. 开发环境 3. 技术栈3.1. SuperMap iObjects Java3.2. SpringBoot3.3. Swagger 4. 新建 SpringBoot 项目5. 配置 Swagger 模块6. 配置 SuperMap iObjects Java 组件7. GIS 功能实现8. 总结 1. 背景 SuperMap iObjects Java 是面向 GIS 应用系统开发者的组件式 GIS 开发平台，具有强大的地理数据管理、编辑、显示、分析等功能，并且其具有极强的易用性和丰富的帮助资源，适宜快速开发大型 GIS 应用系统。
本文主要介绍如何以 SuperMap iObjects Java 组件为功能基础，结合 SpringBoot 开源框架快速搭建 GIS 后台服务。
2. 环境准备 2.1. 系统环境 操作系统支持说明Windows✔Windows 平台推荐硬件配置要求：处理器： 2.00 GHz以上内存要求： 2 GB硬盘容量： 100 GBLinux✔Linux平台最低硬件配置要求：CPU： 1.00 GHz （x86 架构）内存： 512 MB硬盘空间： 40 GB 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43a6eca71ddc9507e7a9cb4e0e5bbef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49dd45e3ef979b8140abfbb922d6ec1e/" rel="bookmark">
			使用ZAP的爬虫功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1. 环境配置-kali linux中firefox配置为127.0.0.1 8080
2. 环境配置-kali linux中OWASP ZAP也配置为127.0.0.1 8080
3. 先在kali linux中打开firefox浏览器，在浏览器中打开靶场
4. 再在kali linux中打开OWASP ZAP
5. 接着，在firefox中刷新Bodgeit页面，此时ZAP中就可以看到相应的记录。
6. 对bodgeit单击右键，从下拉菜单选择 Attack(攻击) | Spider(爬行) 7.对bodgeit单击右键，从下拉菜单选择 Attack(攻击) | Spider(爬行)
8. 如果想分析单个文件的请求和响应，点击Sites选项卡，查看里面的文件和文件夹。
总结
前言 与其他爬行器一样，ZAP的爬行功能会跟随它在每一页找到的链接，包括在请求的范围内和它内部的链接。此外，此蜘蛛遵循“robots.txt”和“sitemap.xml”文件中包含的表单响应、重定向和URL，然后存储所有请求和响应以供以后分析和使用。 在爬行一个网站或目录之后，可能希望使用存储的请求来执行一些测试。使用ZAP的功能，将能够做以下事情，其中包括：  重复修改一些数据的请求  执行主动和被动漏洞扫描  输入模糊变量，寻找可能的攻击向量  在浏览器中打开请求
1. 环境配置-kali linux中firefox配置为127.0.0.1 8080 配置完后，先关闭firefox.
2. 环境配置-kali linux中OWASP ZAP也配置为127.0.0.1 8080 配置完后，先关闭ZAP
3. 先在kali linux中打开firefox浏览器，在浏览器中打开靶场 点击进入Bodgeit靶机
4. 再在kali linux中打开OWASP ZAP 5. 接着，在firefox中刷新Bodgeit页面，此时ZAP中就可以看到相应的记录。 6. 对bodgeit单击右键，从下拉菜单选择 Attack(攻击) | Spider(爬行) 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49dd45e3ef979b8140abfbb922d6ec1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d324fcd6a094f618cfec86ff1e0647/" rel="bookmark">
			【灾报警主机联网问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		火灾报警主机联网问题一直是各消防项目中的难点，特别是管廊等长距离通讯中，如何保证通讯信号长期稳定可靠的运行是需要工程重点解决的问题，而LCAN-FOBR系列环网冗余式CAN光纤转换器提供二路光通道和一路CAN通道，实现CAN与光纤之间的双向数据智能转换。
消防火灾报警系统中，系统可靠性是重要性能指标，所以布网时，一般会构建冗余环网，当一台设备或一段线路出现问题时，不影响系统中其它设备的正常运行。为消防火灾报警系统专业提供组网设备，LCAN-FOBR系列环网冗余型CAN光端机（CAN光纤转换器）支持冗余环网的搭建。
LCAN-FOBR系列CAN光纤转换器支持中继模式；中继模式下，CAN波特率可任意设置，支持不同速率的CAN网络互联、延长通信距离和CAN网络中继扩容等功能。
环网冗余型LCAN-FOBR允许光纤最大衰减25dBm，降低安装现场光纤熔接难度；支持外置式终端电阻开关；支持批量配置：可以先安装，然后将任意光端机的USB口接到电脑，电脑上打开配置软件完成CAN波特率的批量配置。LCAN-FOBR两个设备之间光纤传输距离支持最大40公里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a34a4cbcf83c2903512990ca977ae26/" rel="bookmark">
			HCIP-7.4交换机STP生成树协议原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HCIP-7.4交换机STP生成树协议原理 1、什么是交换机生成树？2、STP生成树2.1、标准生成树基本计算过程(802.1D)2.2、STP的基本概念2.3、 BPDU格式及字段说明2.4、 STP的选举原则2.4.1 配置案例说明2.4.2 华为设备的COST值 2.5、端口状态描述2.6、cost值修改2.6.1、非根桥设备接口下的cost值修改：2.6.2、根设备接口下的优先级修改：2.6.3、优先级发生改变可能的临时环路 2.7、BPDU（Configuration BPDU）桥接协议数据单元2.7.1、配置BPDU的作用2.7.2、TCN（拓扑改变通知） 1、什么是交换机生成树？ 在网络中交换机等交换设备会对广播数据帧进行泛洪操作。如果出现环路，网络就会产生大量不断无效，循环的广播流，发生了“广播风暴”。交换设备的负载迅速增加，导致正常的数据帧传输受到了抑制，便会导致信道的拥塞，其结果往往是延时或丢帧，甚至网络瘫痪。
生成树协议就是用来防止2层循环的，通过在网络上修剪出一棵无环的树形拓扑网来解决交换网络中的环路问题。
生成树协议的分类：
公有协议：STP、RSTP、MSTP。思科可用协议：PVST、PVST+、RPVST、MST。STP约等于PVST、RSTP约等于RPVST 、MST=MST。 现在国内网络中主要使用的是MSTP，也是华为设备默认的生成树协议。在学习MSTP先要学习STP，STP是生成树协议的基础，包括大量基础的概念和理论。
2、STP生成树 STP（Spanning Tree Protocol，生成树协议）是根据IEEE 802.1D 标准建立的，用于在局域网中消除数据链路层物理环路的协议。运行该协议的设备通过彼此交互信息发现网络中的环路，并有选择的对某些端口进行阻塞，最终将环路网络结构修剪成无环路的树型网络结构，从而防止报文在环路网络中不断增生和无限循环，避免设备由于重复接收相同的报文所造成的报文处理能力下降的问题发生。
STP采用的协议报文是BPDU（Bridge Protocol Data Unit，桥协议数据单元），也称为配置消息，BPDU中包含了足够的信息来保证设备完成生成树的计算过程。STP即是通过在设备之间传递BPDU来确定网络的拓扑结构。
基本思想：就是要生成一个稳定的树形拓扑网。
2.1、标准生成树基本计算过程(802.1D) 树的根是一台称为根桥的交换机(Root Bridge,简称为根交换机)。
从根交换机开始，逐级形成一棵树，交换机为树的节点，链路为树枝。
根交换机定时发送配置报文，非根交换机接收配置报文并转发给下一级。
整个交换网络有且只有一个根交换机每个非根交换机有且只有一个根端口每个Lan（segment）有且只有一个指定端口其他接口称之为未指定端口（或者Alternative 端口）。
生成树基本计算过程－选举根交换机
信息和参数被封装在配置BPDU（Configuration Bridge Protocol Data Unit）中，在交换机之间（trunk模式）传递。
BPDU是指桥接协议数据单元，泛指交换机之间运行的协议交互信息时使用的数据单元。配置BPDU是BPDU的一种。根桥每间隔Hello Time（默认2秒）时间周期性发出BPDU。
生成树计算的第一步是选举根交换机，根交换机的选举基于交换机标识（Bridge ID）。
交换机标识由两部分组成：两字节长度的交换机优先级和六字节长度的MAC地址。
交换机优先级是可以配置的，取值范围是0～61440，默认值为32768。
网络中交换机标识最小的成为根交换机，首先比较优先级，如果优先级相同则比较MAC地址，值越小越优先。
Bridge ID BID=优先级+MAC地址。
2.2、STP的基本概念 STP协议中定义根交换(Root Bridget)、根端口(Root Port)、指定端口(Designed Port)和路径开销(Path Cost)等概念，目的就在于通过构造一颗自然树的方法达到阻塞冗余环路的目的，同时实现链路备份和路径最优化。用于构造这棵树的算法称为生成树算法(Spanning Tree Algorithm)。
根桥（Root Bridge）：具有最小桥ID的交换机是根桥(Root Bridge,简称为根交换机)。请将环路中所有交换机当中最好的一台设置为根桥交换机，以保证能够提供最好的网络性能和可靠性。
桥ID（Bridge Identifier）：桥ID是桥的优先级和其MAC地址的综合数值，其中桥优先级是一个可以设定的参数。桥ID越低，则桥的优先级越高，这样可以增加其成为根桥的可能性。
指定桥（Designated Bridge）：在每个网段中，到根桥的路径开销最低的桥将成为指定桥，数据包将通过它转发到该网段。当所有的交换机具有相同的根路径开销时，具有最低的桥ID的交换机会被选为指定桥。
根路径开销（Root Path Cost）：一台交换机的根路径开销是根端口的路径开销与数据包经过的所有交换机的根路径开销之和。根桥的根路径开销是零。
桥优先级（Bridge Priority）：是一个用户可以设定的参数，数值范围从0到32768。设定的值越小，优先级越高。交换机的桥优先级越高，才越有可能成为根桥。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a34a4cbcf83c2903512990ca977ae26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80dc1c34c4f96b1b05c3f3c20348302/" rel="bookmark">
			运算符的优先级记忆口诀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、记忆口决 “单算移关与，异或逻条赋”
2、解释 单：单目运算符，自增（++）、自减（--）、逻辑非（！）、按位反（~）、取地址（&amp;）、取值（*） 算：算术运算符，乘(*)、除(/)、求余(%)级别高于加(+)、减(-) 移：移位运算符，按位左移(&lt;&lt;)、按位右移(&gt;&gt;) 关：关系运算符，小于(&lt;)、大于(&gt;)、大于等于(&gt;=)、小于等于(&lt;=) 高于 等于(==)、不等于(!=) 与：按位与运算符(&amp;) 异：按位异或运算符(^) 或：按位或运算符(|) 逻：逻辑运算符，逻辑与(&amp;&amp;)高于逻辑或(&amp;&amp;) 条：条件运算符(?:) 赋：赋值运算符(*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、|=、!=、=) 3、举例 #include &lt;stdio.h&gt; /* 时间：2022-04-06 18:50 作者：sgbl888 功能：学习关系运算符、逻辑运算符 知识点： 1、C语言用1表示真，用0表示假 2、关系运算符有：&gt; 、&lt; 、 &gt;= 、 &lt;= 、!= 、== 3、逻辑运算符有：!取反、&amp;&amp;与、||或 4、除了!取反运算符，运算优先级为：自增自减&gt;取反&gt;算术&gt;关系&gt;逻辑&gt;赋值 */ int main(){ //关系运算符,跟数学是一样的 printf("%d\n", 1 &gt; 2); //结果为1，也就是真 printf("%d\n", 1 &lt; 2); printf("%d\n", 1 &gt;= 0); printf("%d\n", 1 &lt;= 1); printf("%d\n", 1 != 1); //结果为0，也就是假 printf("%d\n", 1 == 1); printf("-----------------\n"); //逻辑运算符 printf("%d\n", (2 &gt; 0) &amp;&amp; (0 &lt;= 10) ); //结果为1，即 真 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80dc1c34c4f96b1b05c3f3c20348302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c2f527e3608406c5ba92d63326b3fc/" rel="bookmark">
			Python3，如何实现CPU的并行计算，那还不简单，5种方式，这篇就搞定。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多进程实现CPU并行计算 1、引言2、实战2.1 多进程模式2.1.1 定义2.1.2 multiprocessing2.1.3 模式2.1.4 适用场景2.1.4 代码示例 2.2 执行方法2.2.1 多线程并发执行2.2.2 进程池2.2.3 消息队列2.2.4 内存共享2.2.5 异步IO 3、总结 1、引言 小屌丝：鱼哥，你上一篇《Python3，掌握这几种并行处理，轻轻松松提升for循环速度》写的很赞， 我还想继续深入并行计算。
小鱼：那你的意思，哪一篇写的不深呗？
小屌丝：我可没有那个意思。
小鱼：我也没说你是哪个意思。
小屌丝：我就是想着你能不能再讲一讲，关于如何实现CPU并行计算。
小鱼：我屮艸芔茻…你这是有啥心思？
小屌丝：我… 我没有。
小鱼：如实说来，或许，我还能讲一讲。
小屌丝：当真？
小鱼：当真…
小屌丝：就是，我要在公司分享一些技术，就涉及到 如何实现CPU并行计算方面的姿势 . 知识。
小鱼：这样啊， 那你直接说就好了。 我又不是特别喜欢黑桃A。
小屌丝：… 整，整，整吧。
2、实战 2.1 多进程模式 这里，我们主要以Python中的额多进程模式进行讲解。
2.1.1 定义 在Python中，多进程模式是指同时运行多个进程来执行任务的一种编程模式。Python提供了多个模块来支持多进程编程，其中最常用的是multiprocessing模块。 2.1.2 multiprocessing 使用multiprocessing模块可以创建和管理多个进程，每个进程都有自己独立的内存空间和执行环境。通过将任务分配给不同的进程，可以实现并行执行，提高程序的运行效率。 2.1.3 模式 在多进程模式下，每个进程都有自己的主程序流程，可以独立执行任务。进程之间可以通过进程间通信（IPC）机制来进行数据交换和同步操作。 2.1.4 适用场景 多进程模式适用于需要充分利用多核处理器或执行耗时任务的场景。通过将任务分配给多个进程，可以充分利用系统资源，提高程序的运行效率。 2.1.4 代码示例 代码示例
# -*- coding:utf-8 -*- # @Time : 2023-07-01 # @Author : Carl_DJ import multiprocessing def worker(num): "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c2f527e3608406c5ba92d63326b3fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/365f696cc44b894a29155470e6bc01a7/" rel="bookmark">
			python判断列表中是否有某个数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用count（）方法 #根据出现次数判断是否存在某个数字 my_list = [1, 2, 4, 4, 4, 5] for num in range(4,7): if my_list.count(num) &gt; 0: print("{} is in the list".format(num)) else: print("{} is not in the list".format(num)) #4 is in the list # 5 is in the list # 6 is not in the list 2.使用in方法： my_list = [1, 2, 4, 4, 4, 5] for num in range(4,7): if num in my_list: print("{} is in the list"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/365f696cc44b894a29155470e6bc01a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a875a01406a3fd0b69c0bc016b7a24fc/" rel="bookmark">
			10-261 删除马齐的购物记录。分数 10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 delete from t1 where 条件
2、delete t1 from t1 where 条件
3、 delete t1 from t1,t2 where 条件
10-261 删除马齐的购物记录。
分数 10
全屏浏览题目
切换布局
作者 白彦辉
单位 赤峰学院
题干: 删除马齐的购物记录。
提示：不是删除会员马齐，而是删除他的购物记录。
表结构: 定义表结构的SQL语句如下：
CREATE TABLE customer(
cid CHAR(4) PRIMARY KEY,
cname VARCHAR(20) NOT NULL,
sex CHAR(1) DEFAULT '女',
phone CHAR(11) UNIQUE
);
CREATE TABLE recorder(
id INT PRIMARY KEY AUTO_INCREMENT,
cid CHAR(4),
gid CHAR(4),
quantity INT NOT NULL,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a875a01406a3fd0b69c0bc016b7a24fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85df3ddca17af96a879405192cd49f7e/" rel="bookmark">
			10-257 查询与“陆毅”同一个系的同学姓名分数 5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10-257 查询与“陆毅”同一个系的同学姓名
分数 5
全屏浏览题目
切换布局
作者 sy
单位 宁波财经学院
本题目要求编写SQL语句，
检索出students表中与“陆毅”同一个系的同学姓名。
提示：请使用嵌套查询语句作答。
表结构: 请在这里写定义表结构的SQL语句。例如：
CREATE TABLE students ( sno char(7) , sname char(8) NOT NULL, class char(10), ssex char(2), bday date , bplace char(10) , IDNum char(18) , sdept char(16), phone char(11), PRIMARY KEY (sno) ) ; 表样例 请在这里给出上述表结构对应的表样例。例如
students表：
snosnameclassssexbdaybplaceIDNumsdeptphone1311104李嘉欣13英语1女1994-05-28山西太原330204199405281056人文学院159000022111311105苏有明13英语1男1995-04-16内蒙古包头330204199504162036人文学院159000022221711101赵薇17物流1女1999-02-11安徽合肥330203199902110925经管学院159000011771711102陆毅17物流1女1999-02-17上海330203199902170017经管学院15900001188 输出样例: 请在这里给出输出样例。例如：
sname赵薇 select a.sname from (select sname from students where sdept = (select sdept from students where sname='陆毅'))a where a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85df3ddca17af96a879405192cd49f7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ef9685c408dd12f313cf14b35a8d29/" rel="bookmark">
			Vue前端框架大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 框架类 Web 名称Vue描述Element UI2饿了么Element Plus3饿了么Ant Design 12蚂蚁金服Ant Design 23蚂蚁金服Ant Design 33蚂蚁金服Arco Design3字节跳动View UI2View UI Plus3AT-UI2 H5 名称Vue描述Vant 22Vant 33Vant 43FrozenUIQQMint UIMand Mobile滴滴Cube-UI滴滴VuxNut-UI京东Ant-UI蚂蚁金服-支付宝Thor UI 微信小程序 名称Vue描述WeUI微信VantiViewLin UIWuxThor UI 组件类 拖拽 名称Vue描述sortable.jsDraggable2基于并提供Sortable.js的所有功能Draggable3基于并提供Sortable.js的所有功能 二维码 名称Vue描述QRCode.js非官方文档vue-qrcode非官方文档vue-qr非官方文档 富文本 名称Vue描述wangEditor 5TinyMCE 在线Excel 名称Vue描述X-SpreadsheetLuckysheet 播放器 名称Vue描述videojs-playerckplayer 录音 名称Vue描述js-audio-recorder 验证码 名称Vue描述SimCaptcha 语法高亮 名称Vue描述highlightjs 流程图 名称Vue描述GoJS 抽奖 名称Vue描述lucky-canvas基于 JS + Canvas 实现的【大转盘 &amp; 九宫格 &amp; 老虎机】抽奖NutUI-Bingo京东的抽奖组件 文件预览 名称Vue描述docx-previewWord预览luckyexcelExcel预览kkFileView各种文档图片视频预览，需后端部署 右键菜单 名称Vue描述Vue Contextmenu2Vue 原生实现右键菜单组件, 零依赖vue3-menus3 图表类 名称Vue描述echarts一个基于 JavaScript 的开源可视化图表库echarts社区echarts社区echarts DemoPPChartAntV蚂蚁集团全新一代数据可视化解决方案 网站模板 名称描述模板之家免费下载教程Ngx-AdminGentelellavue-element-adminAdminLTE 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd3c3bfa1c1aba748c1b9c8fbd536c0/" rel="bookmark">
			文件上传到OSS，显示进度条信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let fmData = new FormData()
fmData.append("host", res.host)
fmData.append("key", fileUrl)
fmData.append("policy", res.policy)
fmData.append("OSSAccessKeyId", res.accessid)
fmData.append("success_action_status", 200)
fmData.append("callback", res.callback)
fmData.append("signature", res.signature)
fmData.append("file", fileInfo)
if (window.XMLHttpRequest) {
xhr = new XMLHttpRequest()
} else if (window.ActiveXObject) {
xhr = new ActiveXObject("Microsoft.XMLHTTP")
}
try {
xhr.onreadystatechange = function () {
if (xhr.readyState == 4) { // todo
}
}
// 进度条
xhr.upload.onprogress = function (e) {
if (e.lengthComputable) {
// e.loaded 已传输的字节
// e.total 需传输的总字节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdd3c3bfa1c1aba748c1b9c8fbd536c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb042ecf66de93a0ff6947fc61a34bd/" rel="bookmark">
			2022网络系统管理-A模块网络构建-样题1-解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 拓扑一、基础配置二、有线网络配置三、无线网络配置四、出口网络配置 拓扑 一、基础配置 1.根据附录1、附录2，配置设备接口信息。
在做配置之前需要先配置VSU
S6: switch virtual domain 1 switch 1 switch 1 priority 150 switch 1 description S6 port-member interface TenGigabitEthernet 0/49 port-member interface TenGigabitEthernet 0/50 switch convert mode virtual //在用户视图配置，yes回车后设备自动重启 设备重启后S6就是master，重命名位VSU S7: switch virtual domain 1 switch 2 switch 2 priority 120 switch 2 description S7 port-member interface TenGigabitEthernet 0/49 port-member interface TenGigabitEthernet 0/50 switch convert mode virtual 根据地址规划表配置即可，需要在S1和S2创建无线用户vlan60
2.所有交换机和无线控制器开启SSH服务，用户名密码分别为admin、admin1234；密码为明文类型,特权密码为admin。
enable service ssh-server username admin passowrd 0 admin1234 crypto key generate rsa //yes然后回车 line vty 0 4 transport input ssh login loca enable password admin 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffb042ecf66de93a0ff6947fc61a34bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7f3df470c35b6a967cbda3f60d6ca9/" rel="bookmark">
			Postgresql基于repmgr（1主2从&#43;1witness）实现自动和手动故障切换的集群安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境:
Os:Centos 7
DB:13.8
下载安装介质
下载地址:
源码下载地址: https://www.postgresql.org/ftp/source/
二进制下载地址(新版本的没有二进制下载,只能使用源码安装):https://www.enterprisedb.com/download-postgresql-binaries
我这里下载的介质是:
postgresql-13.8.tar.gz安装依赖包
yum install readline
yum install gcc
yum -y install -y readline-devel
yum install zlib-devel源码安装 卸载旧版本的postgres yum remove postgresql*
验证是都卸载完毕 rpm -qa | grep postgresq
[root@host134 soft]# tar -xvf postgresql-13.8.tar.gz
[root@host134 soft]# cd postgresql-13.8
[root@host134 soft]# mkdir -p /opt/pg13 ##这里是指定安装目录
[root@host134 soft]#./configure --prefix=/opt/pg13
[root@host134 soft]# make
[root@host134 soft]# make install 4.创建相应的用户
[root@localhost opt]# groupadd postgres
[root@localhost opt]# useradd -g postgres postgres 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d7f3df470c35b6a967cbda3f60d6ca9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33ade5ca44065de2a63cea21939ccea/" rel="bookmark">
			PyCharm 2023.2 EAP 4 已发布！Python开发工具速看！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新推出的 PyCharm 2023.2 EAP 4 包含新的 AI 助手、对网关开发容器的支持以及 UI 增强等更新。
重要提醒: PyCharm EAP 版本尚未经过全面测试，可能不稳定。
EAP 英文是 Early Access Program，相当于是内测版本，可以提前体验新功能。
图片
新版本下载地址
https://www.jetbrains.com/pycharm/nextversion/
图片
2. AI 助手
AI 助手由 JetBrains AI 服务提供支持，并结合了 OpenAI 的功能以及 JetBrains 自己的小型模型。
PyCharm EAP 4 提供了一些初始的人工智能驱动的功能，包括集成的人工智能聊天、文档自动生成、命名建议和 commit 提交消息的自动生成。
要访问这些 AI 功能，你需要使用 JetBrains 帐户登录 JetBrains AI 服务。JetBrains AI 服务的可用性可能会稍微没那么完美。
图片
3. 对开发容器的支持
PyCharm 现在支持 Dev Containers，允许你使用容器作为功能齐全的开发环境来编辑、构建和运行你的项目。
开发容器可以通过 SSH 连接远程运行，也可以使用 Docker 在本地运行。
要使用此功能，要确保你的电脑上安装了 Docker。
在 Welcome 页面中，选择 Remote Development 部分中的 Dev Containers 选项，并提供 Git 仓库地址来设置连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33ade5ca44065de2a63cea21939ccea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7233b11d34b74c5ac4ea614f8910f93a/" rel="bookmark">
			如何用 pandas 对数据进行预处理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据分析和机器学习的过程中，将数据进行预处理是一个非常重要的步骤。Pandas 是一个流行的 Python 数据分析库，它提供了许多功能来帮助数据预处理。下面是一些常见的数据预处理技巧，可以用 Pandas 实现：
1. 导入数据
使用 Pandas 的 `read_csv()` 函数可以轻松地从 CSV 文件中读取数据并将其存储在 DataFrame 中。例如：
import pandas as pd df = pd.read_csv('data.csv') 2. 处理缺失值
在数据中，可能会有一些缺失值。使用 Pandas 的 `fillna()` 函数可以将缺失值替换为指定的值。例如，以下代码将 DataFrame 中所有缺失值替换为 0：
df.fillna(0, inplace=True) 3. 删除重复行
有时候，数据集中可能会有重复的行。使用 Pandas 的 `drop_duplicates()` 函数可以轻松删除这些重复的行。例如：
df.drop_duplicates(inplace=True) 4. 处理异常值
异常值是指与其他值相差较大的值。可以使用 Pandas 的 `clip()` 函数来限制数据的范围。例如，以下代码将 DataFrame 中所有小于 0 的值替换为 0，所有大于 100 的值替换为 100：
df = df.clip(lower=0, upper=100) 5. 数据类型转换
有时候，数据集中可能会有错误的数据类型。使用 Pandas 的 `astype()` 函数可以将数据类型转换为正确的类型。例如，以下代码将 DataFrame 中所有字符串类型的列转换为整数类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7233b11d34b74c5ac4ea614f8910f93a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b0054a80aeee5d81fbb7d51a2c548f/" rel="bookmark">
			DFS深度优先搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、DFS的概念DFS的定义DFS的搜索方式DFS采用的数据结构DFS的特点 二、DFS的实战应用1.排列数字2.n-皇后问题 一、DFS的概念 DFS的定义 DFS（Depth-First Search）深度优先搜索，是一种常用的图遍历算法，用于在图或树数据结构中遍历所有节点。
DFS的搜索方式 深度优先搜索从一个起始节点开始，沿着一条路径尽可能远地访问节点，直到到达不能继续前进的节点，然后返回上一层继续探索其他路径。这个过程是递归的，通过不断地深入进入节点的子节点，直到遍历完整个图。
DFS采用的数据结构 深度优先搜索使用栈（Stack）数据结构来保存需要探索的节点。每次访问一个节点时，将其标记为已访问，并将其未访问的邻居节点压入栈中。然后从栈中弹出一个节点，继续访问该节点的未访问邻居节点，直到栈为空。
空间复杂度： O ( n ) O(n) O(n)
DFS的特点 DFS不保证找到最短路径。因为它首先沿着一条路径尽可能远地深入。如果需要找到最短路径，可以考虑使用其他算法，如广度优先搜索（BFS）或 Dijkstra 算法。一般最小步数、最短距离、最小操作次数等问题采用BFS。思路奇怪或是对空间要求高的使用深度优先搜索（DFS）。
DFS 在解决许多图论问题和遍历问题上非常有用，如查找图中的路径、连通性检测、拓扑排序等。它也可以应用于树的遍历，例如先序遍历、中序遍历和后序遍历。
二、DFS的实战应用 1.排列数字 题目描述：
给定一个整数 n n n，将数字 1 ∼ n 1∼n 1∼n 排成一排，将会有很多种排列方法。
现在，请你按照字典序将所有的排列方法输出。
输入格式：
共一行，包含一个整数 n n n。
输出格式：
按字典序输出所有排列方案，每个方案占一行。
数据范围：
1 ≤ n ≤ 7 1≤n≤7 1≤n≤7
输入样例：
3 输出样例：
1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 实现思路
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b0054a80aeee5d81fbb7d51a2c548f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac1ee7a4cf521bb76c4fe775e97de02/" rel="bookmark">
			zookeeper之znode节点与acl权限设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		zookeeper之znode节点与acl权限设置 zookeeperznode节点节点类型节点属性节点监听 客户端命令行查看所有命令命令说明 acl权限设置scheme认证模型permission权限位acl相关命令ACL使用示例 客户端工具ZooInspectorPrettyZoo zookeeper ZooKeeper是Apache软件基金会的一个软件项目，是一个分布式的，开放源码的分布式应用程序协调服务。它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。
ZooKeeper是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式 锁和分布式队列等功能
官网：http://ZooKeeper.apache.org/
快速开始：http://zookeeper.apache.org/doc/current/zookeeperStarted.html
API地址：https://zookeeper.apache.org/doc/
数据结构
ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode，每个ZNode都可以通过其路径唯一标识
zookeeper提供的名称空间非常类似于标准文件系统，key-value 的形式存储。名称key由斜线 / 分割的一系列路径元素，zookeeper名称空间中的每个节点都是由一个路径标识。
znode节点 节点类型 持久化目录节点（PERSISTENT）：客户端与zookeeper断开连接后，该节点依旧存在
# 默认创建的就是持久节点 create /test 持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）：客户端与zookeeper断开连接后，该节点依旧存在，Zookeeper会给该节点按照顺序编号
# 创建序号节点 create -s /test # 返回创建的实际路径 Created /test0000000001 create -s /test # 返回创建的实际路径2 Created /test0000000002 临时目录节点（EPHEMERAL）：客户端与zookeeper断开连接后，该节点被删除
# 创建临时节点， 断开会话 在连接将会自动删除 create -e /temp 临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL）：客户端与zookeeper断开连接后，该节点被删除，Zookeeper会给该节点按照顺序编号
create -e -s /temp/seq 节点属性 查看节点属性：stat /znode
状态属性描述cZxid创建节点时的事务ID，每次修改状态都会产生一个事务ID。事务ID是 ZooKeeper 中所有修改总的次序。
每次修改都有唯一的 zxid，如果 zxid1 小于 zxid2，那么 zxid1 在 zxid2 之前发生。ctime创建节点时的时间mZxid最后修改节点时的事务IDmtime最后修改节点时的时间pZxid表示该节点的子节点列表最后一次修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响该ID（注意，只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响pzxid）cversion子节点版本号，子节点每次修改版本号加1dataversion数据版本号，数据每次修改该版本号加1aclversion权限版本号，权限每次修改该版本号加1ephemeralOwner创建该临时节点的会话的sessionID。如果该节点是持久节点，那么这个属性值为0dataLength该节点的数据长度numChildren该节点拥有子节点的数量，只统计直接子节点的数量 节点监听 客户添加-w参数可实时监听节点与子节点的变化，并且实时收到通知。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac1ee7a4cf521bb76c4fe775e97de02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64c82b0f826668bd8d2cd01c477f07c5/" rel="bookmark">
			mmdetection自定义数据集训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 源码下载，本文基于v3.0版本 2.选模型训练
2.1 先生成后面用于编译的配置文件
2.2.1 修改coco.py
2.2.2 修改class_names.py
3. 训练配置
4. 训练过程展示
1. 源码下载，本文基于v3.0版本 GitHub - open-mmlab/mmdetection: OpenMMLab Detection Toolbox and Benchmark
安装环境依赖参考官方教程 GET STARTED — MMDetection 3.0.0 documentation 2.选模型训练 本文使用deformable_detr模型进行训练
D:/deep_learn/OpenMMlab/mmdetection-main/configs/deformable_detr/deformable-detr_r50_16xb2-50e_coco.py 2.1 先生成后面用于编译的配置文件 什么都不管，先编译一次，获得模型的配置文件，传入上面的模型文件路径
配置完成后编译，当然会编辑不通过，但是tools会生成工作目录
下面的就是模型的配置文件，需要修改次文件来训练自定义数据集，将其改名。复制一份到
D:/deep_learn/OpenMMlab/mmdetection-main/configs/deformable_detr/
改名后复制后的结果显示
2.2 更改配置文件 训练自己定义的数据集需要修改3个地方，需要修改的如下：
数据集需要coco格式的，关于数据集的制作可看下面链接 有手就行的自定义制作coco、voc、yolo格式数据集_Evan_qin_yi_quan的博客-CSDN博客
""" 自定义数据集训练，需要修改3个地方 1. D:\deep_learn\OpenMMlab\mmdetection-main\mmdet\datasets\coco.py 中修改类别名字 2. D:\deep_learn\OpenMMlab\mmdetection-main\mmdet\evaluation\functional\class_names.py的coco_classes类中修改类别名字 3. my-deformable-detr_r50_16xb2-50e_coco.py 修改数据集路径，和 num_class 2023.06.29 """ 2.2.1 修改coco.py 2.2.2 修改class_names.py 都是把原来的类别名字注释掉，换成自己的类别名字 2.2.3 修改my-deformable-detr_r50_16xb2-50e_coco.py文件
本文以deformable-detr网络为例，所以修改此文件，使用其它网络模型的参考my-deformable-detr_r50_16xb2-50e_coco.py文件的制作方法。
首先是看看自定义数据集文件目录结构，数据集名字coco-data
修改deformable-detr_r50_16xb2-50e_coco.py文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64c82b0f826668bd8d2cd01c477f07c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50784afba94daf6eb6a6b26fbec0ec2/" rel="bookmark">
			obsidian栏宽调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 obsidian栏宽调整 问题：由于屏幕分辨率和大小不同，obsidian中间的栏宽往往不是自己希望的宽度
解决方法：
在.obsidan\themes\Blue Topaz\文件夹下会有themes.css文件，因为我的主题是Blue Topaz，所以我的主题文件夹是这个，根据自己具体使用的主题选择不同的文件夹，如果你的主题是Dark Mossm，那么你的主题文件夹是.obsidian\themes\Dark Moss\，效果如下图：
然后通过 vscode 打开themes.css文件，搜索--file-line-width，然后将其后面的数值改成自己期望的数值。
关闭vscode，就能发现 obsidian 中的栏宽已经变更。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a883290ffc2e8facdefca29016a28e/" rel="bookmark">
			【Java】Java中的异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、什么是异常1.1 异常的概念1.2 异常的分类 二、异常的体系结构三、异常的处理3.1 异常的抛出3.2 异常的捕获与处理3.3 异常的处理流程 四、自定义异常类4.1 自定义异常类的规则4.2 自定义异常案例 一、什么是异常 1.1 异常的概念 在Java中，异常（Exception）是指程序执行过程中可能出现的不正常情况或错误。它是一个事件，它会干扰程序的正常执行流程，并可能导致程序出现错误或崩溃。
异常在Java中是以对象的形式表示的，这些对象是从java.lang.Throwable类或其子类派生而来。Throwable是异常类层次结构的根类，它有两个主要的子类：java.lang.Exception和java.lang.Error。
Exception（异常）：java.lang.Exception是表示可检查异常的基类。可检查异常是指在编译时需要显式处理的异常。Exception类及其子类用于表示程序运行过程中可能出现的外部条件、错误或其他可恢复的情况。例如，文件未找到、网络连接中断、输入格式错误等。开发人员需要通过捕获或声明这些异常来确保在程序中进行适当的异常处理。
Error（错误）：java.lang.Error是表示严重问题或系统级错误的基类。错误是指那些程序通常无法处理或恢复的情况，例如内存溢出、堆栈溢出、虚拟机错误等。与异常不同，错误不需要在程序中显式处理，因为它们通常表示了无法解决的问题。
异常在Java中通过抛出（throw）和捕获（catch）的方式进行处理。当程序执行到可能引发异常的代码时，可以使用throw语句手动抛出异常对象。然后，可以使用try-catch语句块来捕获异常，并在catch块中提供相应的异常处理逻辑。在catch块中，可以根据异常的类型执行适当的操作，如日志记录、错误报告或异常处理。如果异常没有在当前方法中被捕获处理，它将继续向上级调用栈传播，直到找到合适的异常处理代码或导致程序终止。
1.2 异常的分类 在Java中，异常可以按照其类型进行分类。下面是Java中异常的主要分类：
可检查异常（Checked Exceptions）：可检查异常是指在编译时会被检查的异常，程序必须显式地处理它们，否则编译器会报错。可检查异常通常表示程序在运行过程中可能出现的外部条件或错误。例如，文件不存在、网络连接问题等。可检查异常是Exception类（及其子类）的实例。
运行时异常（Runtime Exceptions）：运行时异常也被称为非检查异常（Unchecked Exceptions）。这些异常在编译时不会被强制检查，而是在程序运行时才会抛出。运行时异常通常表示程序内部的错误或逻辑错误，例如，空指针引用、除以零等。运行时异常是RuntimeException类（及其子类）的实例。
错误（Errors）：错误表示Java虚拟机（JVM）本身出现的严重问题，通常无法恢复或处理。错误可能是内存溢出、堆栈溢出等严重问题。与异常不同，错误一般不应该被捕获和处理，因为它们指示了无法解决的问题。错误是Error类（及其子类）的实例。
这些异常类型的区别在于编译器对它们的检查方式以及程序员对它们的处理要求。可检查异常在编译时要求显式处理，要么通过try-catch块捕获并处理，要么通过在方法签名中声明该异常并由调用者处理。运行时异常可以选择捕获和处理，但不是强制要求。而错误通常不应该被捕获和处理。
二、异常的体系结构 在Java中，异常类的体系结构是通过继承关系组织的。以下是Java异常类的体系结构图及其说明：
Throwable是异常类体系结构的根类。它是所有异常类的超类，直接或间接地派生了Error和Exception两个主要子类。
Error表示严重的问题或系统级错误，它们通常是由Java虚拟机（JVM）本身引起的，例如内存溢出、堆栈溢出等。程序通常无法恢复或处理这些错误。
Exception是表示可检查异常的基类。它包括两个主要的分支：
RuntimeException是运行时异常的基类，它表示程序内部错误或逻辑错误。这些异常通常是由编程错误引起的，例如空指针引用、除以零等。运行时异常在编译时不会被强制检查，因此可以选择捕获和处理它们，但也可以选择不处理。
Exception的其他子类表示其他可检查异常，例如输入/输出异常（IOException）、SQL异常（SQLException）等。这些异常在编译时会被强制检查，程序必须显式地处理它们，否则会导致编译错误。
Java异常类体系结构的组织方式使得开发人员可以根据异常的类型和性质来选择适当的异常类来表示和处理不同类型的异常情况。这种结构使得异常处理更加灵活和可扩展，并且提供了一致的异常处理机制。
三、异常的处理 3.1 异常的抛出 在Java中，异常的抛出是通过使用throw关键字来实现的。throw关键字用于抛出一个异常对象，将异常传递给调用者或上层调用栈。
以下是异常的抛出示例：
public class Example { public static void main(String[] args) { try { int result = divide(10, 0); // 调用自定义方法 System.out.println("结果：" + result); } catch (ArithmeticException e) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8a883290ffc2e8facdefca29016a28e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9898b822a77c54b2ed8daeca20a8a74/" rel="bookmark">
			hive报错Directory xxx could not be cleaned up.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前情提要 之前建立过数仓，因为对数据不满意，于是把hdfs上的表全删除，打算从头再创建一次数据。
在执行hdfs_to_ods的脚本时，总是报错Directory xxx could not be cleaned up.
错误原因 之前建立过数仓，hive存储在数据库中的元数据记录了之前数仓的表的结构，比如分区，而在删除hdfs上存储的hive表时，元数据对应的内容并没有删除，所以在第二次同步数据时，hive在覆盖加载分区表时，他以为分区有数据，但却无法清理分区（实际文件已经被删除）而导致的错误
解决办法 在hive中对相关的表使用alter table xxx drop partition(dt='9999-12-31')
因为表比较多，我写了一个shell脚本，各位可以做为参考
#!/bin/bash 参数=$1 dele(){ sql="" for i in $*; do sql=$sql"alter table 数据库名.$i drop partition(分区字段='$参数');"#$参数 外不一定要加单引号，我的是日期字段，所以需要加单引号 done hive -e "$sql" } dele "表1" "表2" "表3" 使用方式为
在~/bin下vim 文件名.sh按i进入插入模式，复制代码并修改相应数据按esc退出插入模式，输入:wq后退出文件对文件增加执行权限chmod +x 文件名.sh执行文件 文件名.sh 参数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82c25945a7e8f7f25fd732df887b4ae6/" rel="bookmark">
			接口签名验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.appId和secretKey定义
appId=APPID
secretKey =cfq4189auoo13y17ur9n2rl7v2tkz3iq
2.sign获取算法
md5（secretKey+参数json字符串+timestamp+secretKey）后的大写字母。
/** * 参数按key进行排序 * @param obj * @return */ public static String getParamStr(Object obj, List&lt;String&gt; ignoreKey) { if (obj == null) { return null; } Map&lt;String, Object&gt; map = object2Map(obj); if (map == null || map.isEmpty()) { return null; } //升序排序 Map&lt;String, Object&gt; sortMap = new TreeMap&lt;&gt;(String::compareTo); sortMap.putAll(map); StringBuilder signStr = new StringBuilder(); for (Map.Entry&lt;String, Object&gt; entry : sortMap.entrySet()) { //跳过参数 if (CollectionUtils.isNotEmpty(ignoreKey) &amp;&amp; ignoreKey.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82c25945a7e8f7f25fd732df887b4ae6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4c849b963e41643ca60f8aa495263b2/" rel="bookmark">
			Vue2 系列：vue.config.js 参数配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. publicPath 默认值：'/'
说明：部署应用包时的基本 URL，例：https://www.my-app.com/my-app/，则设置 publicPath 为 /my-app/
提示：1. 当使用基于 HTML5 history.pushState 的路由时 2.当使用 pages 选项构建多页面应用时。
2. outputDir 默认值：'dist'
说明：打包目录。
提示：目标目录在构建之前会被清除 (构建时传入 --no-clean 可关闭该行为)。
3. assetsDir 默认值：''
说明：放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。
注意：从生成的资源覆写 filename 或 chunkFilename 时，assetsDir 会被忽略。
4. indexPath 默认值：'index.html'
说明：指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径。
5. pages 默认值：undefined
说明：在 multi-page 模式下构建应用。每个“page”应该有一个对应的 JavaScript 入口文件。
注意：其值应该是一个对象，对象的 key 是入口的名字，value 是：1.一个指定了 entry, template, filename, title 和 chunks 的对象 (除了 entry 之外都是可选的)；2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4c849b963e41643ca60f8aa495263b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbdca46662c0749d5f46e8697e18134/" rel="bookmark">
			有手就行的自定义制作coco、voc、yolo格式数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 准备工作
2. 开始打标注 3. 转换为coco格式
4. 转换为voc格式 5. 转换为yolo格式
1. 准备工作 （1）安装软件labelme，自行安装，不再说明。
（2）准备好原始图片，本文以10张图片如下图所示，用labelme软件打标签
2. 开始打标注 首先打开labelme软件 ，然后打开目录，定位到你数据源所在的文件夹
用矩形框打标注，这里只标注两个类别：mask、person
打完标注后保存图片，保存后得到的json文件名字要和图片名字一次，点击NextImage继续下一张图片打标注，直至所有图片打完标注。
待所有10张图片打完标签，得到如下结果，接着需要根据json文件分别转换为coco、voc、yolo格式的数据集。
3. 转换为coco格式 转换cooc格式，把上面的json文件复制到原来的图片文件夹source-ing中,因为需要把图片划分为训练集和验证集。
下面是转换代码json -&gt; coco
import os import json import numpy as np import glob import shutil import cv2 from sklearn.model_selection import train_test_split np.random.seed(41) classname_to_id = { "mask": 0, #改成自己的类别 "person": 1 } class Lableme2CoCo: def __init__(self): self.images = [] self.annotations = [] self.categories = [] self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edbdca46662c0749d5f46e8697e18134/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552f107c32a204c23113d1a922a8aa98/" rel="bookmark">
			大专生能进大厂吗？程序员初学者想进大厂有哪些建议？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两天收到一位同学的私信问我：大专生跨专业学编程做程序员，有机会进大厂吗？刚好在知乎也看到了类似的问题，便一起回答了吧。
首先说结论：我认为，大专生程序员进大厂，不仅有机会，甚至机会很大！
编程其实是个更注重应用的行业，在日常工作中，很多技术大牛们能够行云流水般打出一连串让人瞠目结舌的高级代码，更多时间靠的是大量严谨的逻辑锻炼和实践经验，而不是一张证明他在某处求学数年的纸质学历文凭。
不畏将来，不念过去 身边有个朋友就是专科学历，现在就职字节跳动。看到这个问题后，特意找他聊了聊，他给出的非常全面的建议，让我心服首肯，整理了一下分享给大家。以下建议同样适用于想进大厂深造的初中级程序员，建议大家收藏起来：
1、工作之余搞一个成人本科，最起码简历可以写最高学历本科，年轻时候贪玩埋下的苦果必然是要付出代价的。
2、算法数据结构一定要自己好好学，多刷leetcode，不仅能锻炼你的思维逻辑，也是面试中非常重要的加分项。
3、多积攒工作经验，冲击大厂前，尽量去一个某行业的独角兽小厂历练，一定要跟紧流行技术，公司一定要有庞大的用户基础，才能碰到各种各样的问题，才会对自己有提升。
4、在小厂要有自己的想法，对架构的设计要有自己的思考，不懂要多和架构师聊，多了解设计思想和实现原理。
5、积攒3-5年经验，期间可以出去面试，不只是为了跳槽，是多了解外面的公司、市场需要什么样的人才，自己哪些方面需要提升，对自己有一个查漏补缺的过程。
6、广交同行业的朋友，因为在后面你想进大厂的时候会给你提供很大的帮助。尽量走内推渠道。因为你海投大厂在HR晒简历时候就会被筛掉。很多大厂内推是可以直接把简历扔到用人部门的。
7、在第一次冲击大厂的时候尽量找些边缘部门投递，核心部门尽量不要尝试。不是太悲观，竞争那是相当惨烈，你几乎毫无竞争力可言，牛逼的人太多了。
明处亮相、暗处努力 职场上有句老话：优秀的人往往有一些相似的特质，而拉胯的人则各有各的拉胯。
首先说说明处亮相、暗处努力。这句话其实很好理解，明处亮相是说我们在做事的时候要正大光明，有底气有勇气，也就是高调做事的意思。我在职场当中曾经听说过很多传说，最传奇的一次是之前在阿里妈妈的时候，听说有一位P5运营小姐姐为了一个需求，每次被拒绝就找上一层的领导，一直找到了整个部门P11的老大。这个案例给我非常震撼，我想换了绝大多数人是没有这个勇气的，即使非常坚信自己一定是正确的。
再来说说暗处努力：毫无疑问，不论是努力学习提升我们的业务、技术能力，还是努力把一件事情做好，都是必不可少的。但个人努力是一件相对比较私人的事情，不宜放上台面来说。一方面整天聊起自己看了哪些论文，学了哪些技术可能会让人觉得你凡尔赛，或者是刺痛一些已经躺平的咸鱼老人，会让他们对你产生不喜。另一方面如果自己不小心事情办出了纰漏，也很容易让人怀疑，你口口声声说自己努力、学习了很多，怎么还这么菜。
所以说宣扬自己如何如何努力是一件挺没有必要的事情，我还是觉得在职场上怀才就像怀孕，时间久了总是会被看出来的。
保持热度、持续燃烧 对于新人而言，刚刚进入职场往往都是想要大干一场，做出一番事情来的。但这股热情能够延续的时间往往不会很长，因为努力奋斗了一段时间之后，发现自己依然藉藉无名，升职加薪之类的事情好像也比较远，很多人这个时候就会开始懈怠了。老实说我之前也曾经懈怠过一段时间，觉得做什么都没有意思，经过了好一番周折才调整过来。
所以我觉得新人最重要的其实不是展示自己，也不是多么积极主动，多做很多事情。涸泽而渔的做法不太可取，除非你天生就是非常热情、动力十足的人。短时间内的亮相、发光发热意义并不大，持久才是王道。
作为一个新人，你只有多干活，把更多的业务揽在自己手里，你才会成为团队的核心。那么有一天你在技术上遇到问题，你放心，你的头会比你还着急， 你都不用去请教他，他都会主动来帮助你解决问题。 这又是跟技术头学习的好机会。你要相信能做领导的都不傻，谁在踏实干活，谁在溜肩耍滑，领导心里都很清楚。你好好干，领导会把更多核心的功能教给你，你会有更多的机会，学习更多的知识。 福利待遇也会优先给你。
在职场当中保持温度保持热情，但不过分炙热。这样我们行动的时候才会像是施展才华，我们静下来又像是已经逞心如意。相反，如果过度表现往往会引人不快，觉得你太过度表现自己，抢了别人风头。
注重成长，日积月累 新人刚入职场，一片新奇，过去的知识和经历派不上用场。很多事物不懂，充满了未知，可能也没有一个很好的领路人指点，只能靠自己摸索，的确不太容易。但反过来说，职场中的好学生其实并不一定成绩好，能够自己从环境和其他人身上学到自己想要的，才是真正的好学生。
不断学习提升 我自己做Python开发已经是第8个年头了，见证了太多人的起起落落，印象很深一个同事，跳槽阿里薪资直接double，但也看到很多人镀着“大厂”的金四处碰壁，终究还是倒在了技术上！
以下分享一下我几年来具体的学习路线及笔记文档，希望能帮助到有心提升技术的朋友！
最后 如果只是寻找Python的新手入门项目，网上随便搜索一下出来的结果是非常多的。但是这并没有太多的意义，因为这些项目并不一定适合每一个人。而在明确自己想要从事的方向之前，合适与不合适也无从谈起，所以希望大家都可以先明确自己的方向，之后再找到对应的进阶道路则要容易得多。所以如果你之前只是想要学好Python这门语言，但是又没有考虑过方向相关的话，我建议你可以思考一下这方面的问题。
【最新Python全套从入门到精通学习资源，文末免费领取！】
Python技术资源分享 如果你对Python感兴趣，学好 Python 不论是就业、副业赚钱、还是提升学习、工作效率，都是非常不错的选择，但要有一个系统的学习规划。
小编是一名Python开发工程师，自己整理了一套 【最新的Python系统学习教程】，包括从基础的python脚本到web开发、爬虫、数据分析、数据可视化、机器学习等。
如果你是准备学习Python或者正在学习，下面这些你应该能用得上：
1、Python所有方向的学习路线 Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
2、学习软件 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
3、精品书籍 书籍的好处就在于权威和体系健全，刚开始学习的时候你可以只看视频或者听某个人讲课，但等你学完之后，你觉得你掌握了，这时候建议还是得去看一下书籍，看权威技术书籍也是每个程序员必经之路。
4、入门学习视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
5、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
6、清华编程大佬出品《漫画看学Python》 用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
7、Python副业兼职与全职路线 这份完整版的Python全套学习资料已经上传至CSDN官方，朋友们如果需要可以点击下方链接或扫描下方二v码都可以免费获取【保证100%免费】
最新全套【Python入门到进阶资料 &amp; 实战源码 &amp;安装工具】
以上全套资料已经为大家打包准备好了，希望对正在学习Python的你有所帮助！
如果你觉得这篇文章有帮助，可以点个赞呀~
我会坚持每天更新Python相关干货，分享自己的学习经验帮助想学习Python的朋友们少走弯路！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ee99840c8bae9ccdfb23717c35fd6d/" rel="bookmark">
			微信小程序原生代码，自定义导航栏&#43;tabs吸顶&#43;锚点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新优化动态内容，滑动tabs选项定位不准确问题,以及性能问题 效果图 需求说明：在产品详情页较多。 例如刚进入页面自定义导航栏为空（图一）， 当滑动到tabs吸顶后自定义导航栏出现（图二）， tab点击锚点跳转。使用scroll-view 跟 scroll-into-view，虽然可以完成锚点跳转，但是会页面锚点直接顶到顶部。 图一 图二
使用到的API： wx.pageScrollTo
wx.createSelectorQuery
Github地址：https://github.com/Dgg1997/tabs-sticky 所有代码： wxml： &lt;view wx:if="{{scrollTopNew + navT+navH &gt;= stickyTopHeight}}" style="width: 100%;height: {{navT+navH}}px;background: #fff;position: fixed;z-index: 999;top: 0;display: flex;justify-content: center;"&gt; &lt;text style="margin-top: {{navT}}px;line-height: {{navH}}px;"&gt;产品详情&lt;/text&gt; &lt;/view&gt; &lt;!-- 占位 --&gt; &lt;view class="top-main"&gt;&lt;/view&gt; &lt;view class="tabs" id="tabs" style="{{oneFixed}}"&gt; &lt;block wx:for="{{list}}" wx:key="index"&gt; &lt;view id="{{index}}" bindtap="tabChange" class="tab-item tab-item-{{index}} {{ index== currentIndex ? 'active' : ''}}" data-index="{{index}}" data-key="{{ item.key }}"&gt; {{item.title}} &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7ee99840c8bae9ccdfb23717c35fd6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc5b9bf6ff18993d2357db10a6037c7/" rel="bookmark">
			实现对一个元素的滚动条进行平滑滚动至顶部的动画效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.elementUI中的平滑滚动至顶部的动画效果代码
const cubic = value =&gt; Math.pow(value, 3); const easeInOutCubic = value =&gt; value &lt; 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2; const el = this.el; const beginTime = Date.now(); const beginValue = el.scrollTop; const rAF = window.requestAnimationFrame || (func =&gt; setTimeout(func, 16)); const frameFunc = () =&gt; { const progress = (Date.now() - beginTime) / 500; if (progress &lt; 1) { el.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fc5b9bf6ff18993d2357db10a6037c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974aca62df3e336064fd1f405e2716b7/" rel="bookmark">
			良心推荐！Python爬虫高手必备的8大技巧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要快速学习爬虫，最值得学习的语言一定是Python，Python应用场景比较多，比如：Web快速开发、爬虫、自动化运维等等，可以做简单网站、自动发帖脚本、收发邮件脚本、简单验证码识别脚本。
爬虫在开发过程中也有很多复用的过程，今天就总结一下必备的8大技巧，以后也能省时省力，高效完成任务。
基本抓取网页 get方法
import urllib2 url = "http://www.baidu.com" response = urllib2.urlopen(url) print response.read() post方法
import urllib import urllib2 url = "http://abcde.com" form = {'name':'abc','password':'1234'} form_data = urllib.urlencode(form) request = urllib2.Request(url,form_data) response = urllib2.urlopen(request) print response.read() 使用代理IP
在开发爬虫过程中经常会遇到IP被封掉的情况，这时就需要用到代理IP；在urllib2包中有ProxyHandler类，通过此类可以设置代理访问网页，如下代码片段：​​​​​​​
import urllib2 proxy = urllib2.ProxyHandler({'http': '127.0.0.1:8087'}) opener = urllib2.build_opener(proxy) urllib2.install_opener(opener) response = urllib2.urlopen('http://www.baidu.com') print response.read() Cookies处理
cookies是某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据(通常经过加密)，python提供了cookielib模块用于处理cookies，cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。微信搜索公众号：架构师指南，回复：架构师 领取资料 。
代码片段：​​​​​​​
import urllib2, cookielib cookie_support= urllib2.HTTPCookieProcessor(cookielib.CookieJar()) opener = urllib2.build_opener(cookie_support) urllib2.install_opener(opener) content = urllib2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/974aca62df3e336064fd1f405e2716b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6d5068948e2e05c41a90c8f50feed8/" rel="bookmark">
			Elasticsearch exception [type=index_not_found_exception, reason=no such index [**]]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		org.elasticsearch.ElasticsearchStatusException: Elasticsearch exception [type=index_not_found_exception, reason=no such index [People]] at org.elasticsearch.rest.BytesRestResponse.errorFromXContent(BytesRestResponse.java:178) ~[elasticsearch-7.17.4.jar:7.17.4] at org.elasticsearch.client.RestHighLevelClient.parseEntity(RestHighLevelClient.java:2484) ~[elasticsearch-rest-high-level-client-7.17.4.jar:7.17.4] at org.elasticsearch.client.RestHighLevelClient.parseResponseException(RestHighLevelClient.java:2461) ~[elasticsearch-rest-high-level-client-7.17.4.jar:7.17.4] at org.elasticsearch.client.RestHighLevelClient.internalPerformRequest(RestHighLevelClient.java:2184) ~[elasticsearch-rest-high-level-client-7.17.4.jar:7.17.4] at org.elasticsearch.client.RestHighLevelClient.performRequest(RestHighLevelClient.java:2137) ~[elasticsearch-rest-high-level-client-7.17.4.jar:7.17.4] at org.elasticsearch.client.RestHighLevelClient.performRequestAndParseEntity(RestHighLevelClient.java:2105) ~[elasticsearch-rest-high-level-client-7.17.4.jar:7.17.4] at org.elasticsearch.client.RestHighLevelClient.search(RestHighLevelClient.java:1367) ~[elasticsearch-rest-high-level-client-7.17.4.jar:7.17.4] at org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate.lambda$count$13(ElasticsearchRestTemplate.java:393) ~[spring-data-elasticsearch-4.4.1.jar:4.4.1] at org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate.execute(ElasticsearchRestTemplate.java:582) ~[spring-data-elasticsearch-4.4.1.jar:4.4.1] at org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate.count(ElasticsearchRestTemplate.java:393) ~[spring-data-elasticsearch-4.4.1.jar:4.4.1] at org.springframework.data.elasticsearch.repository.query.ElasticsearchPartQuery.execute(ElasticsearchPartQuery.java:113) ~[spring-data-elasticsearch-4.4.1.jar:4.4.1] at org.springframework.data.repository.core.support.RepositoryMethodInvoker.doInvoke(RepositoryMethodInvoker.java:137) ~[spring-data-commons-2.7.1.jar:2.7.1] at org.springframework.data.repository.core.support.RepositoryMethodInvoker.invoke(RepositoryMethodInvoker.java:121) ~[spring-data-commons-2.7.1.jar:2.7.1] at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.doInvoke(QueryExecutorMethodInterceptor.java:160) ~[spring-data-commons-2.7.1.jar:2.7.1] at org.springframework.data.repository.core.support.QueryExecutorMethodInterceptor.invoke(QueryExecutorMethodInterceptor.java:139) ~[spring-data-commons-2.7.1.jar:2.7.1] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.21.jar:5.3.21] at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:97) ~[spring-aop-5.3.21.jar:5.3.21] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.3.21.jar:5.3.21] at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215) ~[spring-aop-5.3.21.jar:5.3.21] at com.sun.proxy.$Proxy62.findByNameAndAge(Unknown Source) ~[na:na] at com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd6d5068948e2e05c41a90c8f50feed8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55b37a8915baae8038a4d92ae56f8945/" rel="bookmark">
			axios请求失败重试请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		axios请求失败重试请求 axios请求失败重试请求1.安装2.挂载实例3.执行4.原因 axios请求失败重试请求 用于http请求失败异常情况时，自动进行请求重试
1.安装 import axios from 'axios'; import axiosRetry from 'axios-retry'; 2.挂载实例 const service = axios.create({ baseURL: "http://127.0.0.1:7002",//配置接口地址 timeout: 20 * 1000,//请求超时时间，单位毫秒（这里配置的20秒） }) axiosRetry(service, {//传入axios实例 retries: 3, // 设置自动发送请求次数 retryDelay: (retryCount) =&gt; { return retryCount * 1000; // 重复请求延迟（毫秒） }, shouldResetTimeout: true, // 重置超时时间 retryCondition: (error) =&gt; { console.log("error", error.message) //true为打开自动发送请求，false为关闭自动发送请求 return true }, onRetry: function (retryCount,) { //记录执行次数 console.log('err', retryCount) }, }); 3.执行 let s = await service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55b37a8915baae8038a4d92ae56f8945/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33bffcf9ebdaf9e52a7ef332e978ef0/" rel="bookmark">
			亲身经历提醒大家，工作千万不要太快做完，快了领导就会认为你很能干，把最急、最难的任务分给你！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		职场上，如何合理把握工作节奏？
一位网友用亲身经历提醒大家：
上班的时候千万不要搞太快了，搞快了领导就会认为你很能干，分任务的时候，永远把最多、最急、最难、最复杂的业务都交给你。然后别人搞完都下班了，唯独你一个人坐那加班，真是讽刺！
许多网友都有共鸣，有人说，搞太快了，领导不会认为你很能干，只会认为这活太简单了，而且那些没活的人还会给领导说坏话。
有人说，太真实了，能者多劳，鞭打快牛，说明管理水平低。
有人说，干得越多，错得越多，一出问题就是你的责任，绩效就扣没了。反而是那些干得少的人给老板感觉不怎么出问题，很稳。
有人说，搞太快，晚上不加班，领导会觉得你工作不饱和，绩效好不了。
有人说，自己就是在上家干活过快，最后摸鱼被抓，背了低绩效，被裁了。
有人说，自己报工作时间都翻倍，一天能做完的工作都报两天。
也有人说，楼主自己选择当卷王，赖谁？
有人说，领导要的是整个项目结果，你能处理肯定给你，不然给了别人，项目拖了，怎么办？
有人说，不要觉得干活累、干得多，升职加薪就是应得的。不管被分配到什么活，都有预期成果和工作量。如果跟领导反馈做不完，需要更多人力，领导硬要你加班，那是他的问题，但如果你接了没有反馈时间问题，做得很急，还出错了，那就是你的问题。
有人说，万一搞慢了，领导可能会pua你，让你强行加班，不给你调休。
有人说，靠谱的领导确实会把工作安排给这样的员工，但绩效也会排在前面，有更多的升职机会，不好吗？
有人说，领导给你分活是好事，干的活都是领导看见的，总比给领导嫡系打工，让嫡系去汇报好把？
有人说，一直做最核心最复杂的工作，不让别人做，就成了壁垒了。
有人说，要珍惜这样的机会，技术成长快，一到两年技术就能提升一大截，然后直接跳大厂。
总之，要适可而止，不要沉溺于职场表演。
还有人说，不能太慢，也不能太快，只要工资和产出匹配就行。
一位网友说，能承担更多重要的工作是好事，但不能是重复的脏累活，可以看三个标准：是否能学到新知识，是否能获得晋升，是否能得到更多的钱。如果三样都没有，就果断摸鱼或者走人。
在工作时，提高工作效率和工作能力，提升工作质量，这种做法本身没错，但如果效率过高、干得越快，就容易产生各种各样的问题：
首先是“鞭打快牛”的问题。你干得越多，干得越好，领导就会给你安排更多复杂、困难的任务。干得越多，错得越多，最后自己费了半天劲，还没有那些干得少的同事绩效高、晋升快。
其次，干得太快可能背上“卷王”的名号，引起同事不满，导致大家排挤你，形成不良的职场环境和同事关系。
第三，工作节奏太快，容易让自己压力过大，影响身体和心理健康，得不偿失。
所以在职场中一定要学会有所保留，不要过度追求“快”，无论在什么行业，都有“枪打出头鸟”的危险。这么说并不是让大家偷懒、不负责任，而是要适当把握工作节奏和效率，不能太快也不能太慢，不要让自己成为一头蒙着眼睛只会推磨的驴子，最后导致“卸磨杀驴”的悲剧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d05ce799463a49e78ed5e170e092f4b3/" rel="bookmark">
			【ArcGIS】使用ArcMap进行北京1954-120E坐标转WGS84坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 在进行青岛地市GIS数据迁移，涉及坐标转换，经过几天摸索终于找到迁移方法
投影坐标系 北京1954-120E坐标
对应为高斯-克吕格投影
300000 3000001
0 0（青岛本地坐标）
增量:-300000 -3000001（此处为示例，实际不是此）
参考：ArcGIS中提供的北京54与wgs84坐标转换方法及参数
一、坐标移动 原始提供数据为arcgis的gdb格式，先转换为shp文件，此处不赘述
然后打开ArcMap，新建个空白图层，右键Add Data（添加数据），将转换为shp的文件加载到图层里
默认是没有编辑器的，点击旁边这个下三角，设置
弹窗把编辑器选中，添加进去
加载后点击编辑器-开始编辑，
会提示是否可以编辑，这个是可以的，gdb格式和数据库存储的是不允许编辑的，shp可以，所以前面先转了shp，这里点继续
选择数据，如果整体移动，需要选择所有，数据量大的话会很久，这里示范选了部分
选中后，点击编辑器-move（移动）
弹窗输入移动坐标，这里要输入相反的值，原值是负，还原回去需要为正
点击回车开始移动，数据量大实际会长，移动后定位还是原位置，但是数据已经跑到移动后位置了
移动完，点击Save Edits(保存编辑),然后StopEditing（结束编辑）即可完成移动
二、坐标转换 坐标还原后，需要进行坐标转换，54坐标系转84坐标系
点击工具
数据管理工具-投影和转换-投影
DataManagementTools-Projections and Transformations-Project
进入投影参数界面
第一个InputDataset or Feature Class输入要转换的文件，这里选择后，坐标系显示为Unknown，需要进行手动选择坐标系，第三个为输出位置，有个默认值，这里可以自己选择输出为shp还是新建gdb输出到gdb文件里
点击第二个InputCoordinate System（optional）坐标系输入54模糊搜索出北京54坐标系，这里选我们的120E
第四个Output Coordinate System选择需要转换的坐标系
选完后输入转换参数，这里输入的为系统自带的 Beijing_1954_To_WGS_1984_2
直接输入就行，如果前面定义过其他投影这里可以输入，这里直接使用自带的发现就可以
输入后，点击下方空白处就会自己加进去，不提示告警，点击ok
投影过程中下方会出现投影进行中的提示，投影完成会弹窗
也可以点击Results查看投影详情
ArcMap转换的话会自动加载进来，可以看到数据已经转为WGS84格式的经纬度了
常用坐标系可以收藏：
引用 以下为引用复制：
ArcGIS中提供6个地方的转换方式适用范围：
下面的转换方法 Geocentric translations 和 Position Vector transformation 在ArcEngine中都有相应的 GeoTransform 。其中Position Vector transformation 就是布尔沙模型。
1、Beijing_1954_To_WGS_1984_1
内蒙古自治区，陕西省，山西省，宁夏回族自治区，甘肃省，四川省，重庆市
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d05ce799463a49e78ed5e170e092f4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0519bf93a8b629248636825669d27c75/" rel="bookmark">
			【机器学习】数据挖掘实战-信用卡欺诈建模全流程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号：尤而小屋
作者：Peter
编辑：Peter
今天给大家分享一篇关于机器学习建模实战的文章：基于机器学习树模型的信用卡欺诈检测。
导入库 首先导入建模所需要的各种库，包含：可视化、数据预处理、特征工作、模型评估等
In [2]:
import pandas as pd import numpy as np import matplotlib import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline plt.rcParams["font.sans-serif"]=["SimHei"] #设置字体 plt.rcParams["axes.unicode_minus"]=False #正常显示负号 import plotly.graph_objs as go import plotly.figure_factory as ff from plotly import tools from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot init_notebook_mode(connected=True) import gc from datetime import datetime from sklearn.model_selection import train_test_split from sklearn.model_selection import KFold from sklearn.metrics import roc_auc_score from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0519bf93a8b629248636825669d27c75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38c89373479102edcf3e4dc0a0f19e1/" rel="bookmark">
			终极解决：Error: error:0308010C:digital envelope routines::unsupported
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、报错 启动vue项目，报错如下：
2、报错原因 出现这个错误是因为 node.js V17版本中最近发布的OpenSSL3.0, 而OpenSSL3.0对允许算法和密钥大小增加了严格的限制，可能会对生态系统造成一些影响.
在node.js V17以前一些可以正常运行的的应用程序,但是在 V17 版本可能会抛出这个异常。
3、解决方案 3.1版本降级，解决报错 尝试卸载Node.js 17+版本并重新安装Node.js 16+版本，然后再重新启动
这个方法，测试有效，但我推荐的是第二个办法。
3.2设置参数，解决报错 在执行运行项目命令之前，先运行这个命令：
Linux &amp; Mac OS：
export NODE_OPTIONS=--openssl-legacy-provider windows命令提示符:
set NODE_OPTIONS=--openssl-legacy-provider 这样就可以解决了，亲测有效。
唯一不足，是每次启动项目都要运行，所以，我们可以把它配置一下。也就是第三种方法。
3.3 修改配置文件，解决报错（推荐） 根据你的系统类型，选择一个上面的命令，如，我是Mac系统，我就用：
export NODE_OPTIONS=--openssl-legacy-provider 然后，找到项目的package.json文件，把自己对应的命令，加上&amp;&amp;，写到启动项目的配置里面（构建写不写都可以），即可。
例1：脚手架 "scripts": { "serve": "export NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve", "build": "export NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service build" }, 例2：Vue-Element-Admin "scripts": { "dev": "export NODE_OPTIONS=--openssl-legacy-provider &amp;&amp; vue-cli-service serve", //略... }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f59a372a6c12fd6ca4d81ad9c4c790/" rel="bookmark">
			剑指 offer 数组算法题：最小的K个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
分析：
排序法，排序后取前 k 个。
分区法，以k为界限，遍历后半部分元素，若当前元素大于前 k 个元素中的最大值 max ，当前元素替换掉最大值 max。
大根堆法，维护一个 k 个 大小的大根堆，现将前k个元素入堆，然后遍历其余元素，若当前元素小于堆顶，就将堆顶元素弹出，当前元素入堆即可（堆的实现参考）。
求解：
// 排序法 function getLeastNumbers1(arr: number[], k: number): number[] { arr.sort((a, b) =&gt; a - b); return arr.slice(0, k); } // 分区法 function getLeastNumbers2(arr: number[], k: number): number[] { const len = arr.length; // 数组长度不大于 k，直接输出该数组 if (len &lt;= k) return arr; const indexOfMax = (arr: number[]): number =&gt; arr.reduce((prev, curr, i, a) =&gt; (curr &gt; a[prev] ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f59a372a6c12fd6ca4d81ad9c4c790/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff9a897b2b9a08c7706717ddaea2d2b/" rel="bookmark">
			python用flask将视频显示在网页上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意我们的return返回值必须是以下之一，否则会报错
from flask import Flask, render_template, Response import cv2 app = Flask(__name__) @app.route('/') def index(): return render_template('index.html') def gen(camera): while True: success, image = camera.read() if not success: break ret, jpeg = cv2.imencode('.jpg', image) frame = jpeg.tobytes() yield (b'--frame\r\n' b'Content-Type: image/jpeg\r\n\r\n' + frame + b'\r\n') @app.route('/video_feed') def video_feed(): camera = cv2.VideoCapture(0) return Response(gen(camera), mimetype='multipart/x-mixed-replace; boundary=frame') if __name__ == '__main__': app.run() 运行后输入路由
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a79a72186eb2de6a1a0999c41fc762f1/" rel="bookmark">
			Vue UI 组件库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7.1.常用UI组件库 7.1.1.移动端常用UI组件库 VantCube UIMint UINutUI 7.1.2.PC端常用UI组件库 Element UIIView UI 7.2.element-ui基本使用 安装 element-ui：npm i element-ui -S src/main.js
import Vue from 'vue'; import App from './App.vue'; // 完整引入 import ElementUI from 'element-ui'; // 引入ElementUI组件库 import 'element-ui/lib/theme-chalk/index.css'; // 引入ElementUI全部样式 Vue.use(ElementUI); // 使用ElementUI Vue.config.productionTip = false; new Vue({ el: '#app', render: h =&gt; h(App) }) src/App.vue
&lt;template&gt; &lt;div&gt; &lt;br/&gt; &lt;el-row&gt; &lt;el-button icon="el-icon-search" circle&gt;&lt;/el-button&gt; &lt;el-button type="primary" icon="el-icon-edit" circle&gt;&lt;/el-button&gt; &lt;el-button type="success" icon="el-icon-check" circle&gt;&lt;/el-button&gt; &lt;el-button type="info" icon="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a79a72186eb2de6a1a0999c41fc762f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665f362137207c6c66052c7e4ab97ecd/" rel="bookmark">
			chatgpt赋能python：三种python遍历数组的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种python遍历数组的方法 在python编程中，数组遍历是一项重要而常用的操作。下面我们将介绍三种常见的遍历数组的方法并分析其优缺点，来帮助您更好地理解和应用python数组遍历。
1. for循环遍历 for循环是一种最常见的遍历数组的方法，它通过循环迭代来访问数组中的每一项。
arr = [1, 2, 3, 4, 5] for i in arr: print(i) 优点 代码简单易懂。通过简单的循环语法即可实现数组的遍历。灵活性高。可根据实际需求自由调整循环次数和数组顺序。 缺点 相较于其他方法，速度较慢。在大规模数组遍历时，for循环方法的效率较低。 2. while循环遍历 while循环也是一种可行的数组遍历方法。在循环条件中通过数组长度来控制循环次数，实现数组的遍历。
arr = [1, 2, 3, 4, 5] i = 0 while i &lt; len(arr): print(arr[i]) i += 1 优点 具有循环计数器i，可用于处理其他复杂的逻辑。可对数组进行任意操作，具有较高的灵活性。 缺点 在循环过程中需要手动控制计数器i，容易出现死循环等错误。while循环语法相对复杂，容易引发其他代码错误。 3. 迭代器遍历 迭代器是python中一种高效遍历集合（包括数组）的方式。通过使用迭代器，可以在不影响数组本身的情况下访问数组中的元素。
arr = [1, 2, 3, 4, 5] iter_arr = iter(arr) while True: try: print(next(iter_arr)) except StopIteration: break 优点 高效。使用迭代器遍历数组比传统的for循环和while循环要快得多。可避免数组下标越界等错误。当到达最后一个元素时，会自动停止遍历。 缺点 对新手来说，可能难以理解迭代器是如何工作的。在一些特殊情况下可能不如传统的for循环和while循环易于使用。 结论 对于python数组遍历，以上三种方法都是可行的。传统的for循环遍历最直观，容易理解，最适合初学者使用。而while循环相比for循环，更加灵活，支持自定义计数器和其他逻辑控制。迭代器遍历速度最快，而且访问数组元素时更加安全，不太容易出错。不同的遍历方法适用于不同的场景和问题，开发者们可以根据实际需求灵活选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/665f362137207c6c66052c7e4ab97ecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c30c404c62ba911533c4affd9c6782/" rel="bookmark">
			多进程共享内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个6进程并发的共享内存的例子，5个子进程对共享内存写入不同数据，第6个进程负责读取数据另外5个进程全部写入的数据。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;unistd.h&gt; #define SHM_SIZE 1024 #define NUM_PROCESSES 6 // 创建共享内存段 int create_shared_memory() { int shmid; // 调用shmget函数创建共享内存段 shmid = shmget(IPC_PRIVATE, SHM_SIZE, IPC_CREAT | 0666); if (shmid == -1) { perror("shmget"); exit(1); } return shmid; } // 将共享内存段映射到当前进程的虚拟地址空间 char* attach_shared_memory(int shmid) { char* shmaddr; // 调用shmat函数将共享内存段映射到当前进程的虚拟地址空间 shmaddr = (char*)shmat(shmid, NULL, 0); if (shmaddr == (char*)-1) { perror("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c30c404c62ba911533c4affd9c6782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/077601e2fbf61c748e2017eb0999cbca/" rel="bookmark">
			一款开源、免费、小众的任务日程管理神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 推荐给大家一款开源免费的任务日程管理工具ToDoList，是适合职场人尤其是程序员的经典任务管理软件，使用好的话会让大家在工作中事半功倍。
1.软件介绍 ToDoList是一款小众但功能强大的开源免费任务管理软件，它可以帮助你把要做的事情一项一项地列出来，类似思维导图。
其强大之处在于可以管理多人协同工作，你可以根据具体情况设置任务的优先级别、任务完成度、任务提醒等，再复杂的工作，也能一目了然，大大提高你的工作效率。
而且这款软件短小精悍，界面设计简洁直观，初级用户也能够快速上手。
2.软件功能 任务树 如上图所示，你所有的工作项目都列在其中，可以编辑任务名称、颜色、最新状态、完成进度、是否需要提醒、最后完成时间、是否已完成等等。
侧面还有备注，可以进行简单文本和富文本编辑，简单方便。
列表视图 列表视图展现每个人任务的目前现状属性细分。它们只是相同基本任务数据的替代表示，具有不同的查看和操作相同内置属性的方式。
可以使用活动任务视图下的选项卡在这些视图之间切换，也可以使用“菜单栏&gt;视图&gt;下一个任务视图”在视图之间循环切换。
燃尽图 燃尽图显示一个图形，以直观方式显示一段时间内打开的任务数。
这有助于项目经理评估项目进展和完成情况。
所选任务可以按任何字段筛选，以按类别、标记、日期、人员、状态等生成视图。
甘特图&amp;思维导图 还能展现甘特图和思维导图
词云 词云主要是展现你的任务列表中的关键词汇总，并且将出现频率最高的词最大化，以此类推。
这样，你就知道你的主要工作重心在哪儿了！
3 试用感受 界面清爽，操作简单。
下载地址：
https://www.codeproject.com/Articles/5371/ToDoList-8-1-An-Effective-and-Flexible-Way-to-Keep
往期推荐： Vue+SpringBoot 集成 PageOffice 实现在线编辑Word、excel文档 1.5k star，搭建一个属于自己或团队的WIKI知识管理系统！ 一款现代化、开源的 Linux 服务器运维管理面板 一款开源、免费的微信管家系统，助你快速搭建微信应用！ 禁止乱用：一款牛逼的去马赛克工具，已开源 简单、漂亮、容易上手的开源 SAAS 多租户快速开发平台，已开源 开源一个客户管理系统 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1573f141041e0e18138fbeb6e1fc3e/" rel="bookmark">
			记一次在使用EntityFramework Core 进行模糊查询时遇到的问题以及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		临近期末了，老师想要我们完成一个期末项目以对本学期的学习进行一个汇总考核。在期末项目中，我使用了前端框架为vue全家桶(vue + vuex / pinia + vue-router + axios)，ui框架有Element UI、Vant、Vuetify,以及一些各种能使开发更加方便快捷也更接近实际生产需求的npm包；后端使用了.net core 6版本的 asp.net core WebApi 搭配上furion实现后端接口,orm框架有EntityFramework Core、Dapper，SignalR作为通信框架，以及automapper等适用于生产环境的包;数据库使用了微软的Sql Server ，使用redis 作为一个缓存中间件以及消息队列的模拟，以及使用了mongodb作为文件管理。本篇文章我们着重讲解一下在使用EntityFramework Core中可能会遇到的问题以及解决方案。
首先介绍一下EntityFramework Core（EF Core）:
Entity Framework Core是微软推出的一种开源的ORM（对象关系映射）框架，它可以帮助我们轻松地将数据库中的数据转换成对象，同时也可以将对象保存回数据库中。
相比于传统的SQL查询，使用Entity Framework Core可以更加方便地进行数据操作，而且它的学习曲线也比较平缓，适合我们进行学习和使用。
在Entity Framework Core中，我们可以通过定义实体类来映射数据库中的表，通过定义实体类的属性来映射表中的列。我们可以通过查询语句来获取数据，并且可以使用Lambda表达式来进行条件筛选和排序。此外，Entity Framework Core还支持多线程和并发操作，可以更好地满足大规模数据操作的需求。
总的来说，Entity Framework Core是一种易学、高效的数据访问框架，可以帮助我们更加方便地进行数据库操作。
在写期末项目时遇到了一些小问题，其中比较值得说一下的就是EFcore模糊查询和多表查询时遇到的两个问题，下面我们来复现一下这个问题：
查询的表结构如下:
当我要进行多表连接模糊查询时，代码如下：
public async Task&lt;IActionResult&gt; Get(string key) { try { int page = 1; int limit = 15; var ef = new CmsContext(); int offset = (page - 1) * limit; var li = await (from a in ef.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1573f141041e0e18138fbeb6e1fc3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3251df51091a27c6c55003e1ae935d/" rel="bookmark">
			spark的安装与部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、spark是什么？
二、知识回顾
1.启动zookeeper。
2.启动hdfs和yarn。
3.通过jps查看是否启动成功。
4.进入MySQL。
5.进入hive之后验证 6.启动hbase.
7.查看进程
8.进入hbase并测试是否正常
三、spark的安装与部署
1.安装Scala
2.安装与部署spark
总结
前言 为了避免MapReduce框架中多次读写磁盘带来的消耗，以及更充分地利用内存，加州大学伯克利分校的AMP Lab提出了一种新的、开源的、类Hadoop MapReduce的内存编程模型Spark。
一、spark是什么？ Spark是一个基于内存的大数据并行处理框架，其最初由加州大学伯克利分校的AMP Lab研发，现已成为Apache软件基金会的顶级项目之一。Spark不仅提供了可扩展、高容错、高性能的分布式数据处理，还提供了内存级的数据处理。
机器学习的Spark由4个主要组件组成，包括提供交互式数据查询的Spark SQL、实时计算的Spark Streaming、MLlib和图处理的GraphX
Spark与Hadoop类似，但又与Hadoop的数据处理方式不同。
1.Spark的中间结果并没有保存在HDFS中，而是存放在内存中;
2.Spark简化了数据处理流程，从而避免了不必要的排序所带来的开销
3.Hadoop仅支持Java一种编程语言，而Spark的API支持多种编程语言，包括Scala、Java、 Python和R.
二、知识回顾 1.启动zookeeper。 2.启动hdfs和yarn。 3.通过jps查看是否启动成功。 4.进入MySQL。 5.进入hive之后验证 6.启动hbase. 7.查看进程 8.进入hbase并测试是否正常 三、spark的安装与部署 1.安装Scala 1&gt;使用WinSCP软件将下载的Scala安装包上传到master0虚拟机的“/opt/packages” 目录下，然后执行以下命令进入该目录:
# cd /opt/packages 2&gt;执行以下命令，将解压到目录“/opt/programs”下
# tar -zxvf scala-2.12.11.tgz -C /opt/programs 3&gt;修改文件“/etc/profile”配置Scala环境变量
# vim /etc/profile 4&gt;在文件末尾加入以下内容
export SCALA_HOME=/opt/programs/scala-2.12.11 export PATH=$PATH:$SCALA_HOME/bin 5&gt;然后执行以下命令，刷新profile文件，使修改生效:
# source /etc/profile 6&gt;执行“scala -version”命令，若能输出以下版本信息，则说明安装成功:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd3251df51091a27c6c55003e1ae935d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1684bd043047e0b043c3c5f511ef0f92/" rel="bookmark">
			redis 限流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1代表通过，0代表不通过
lua脚本一 local key = KEYS[1] local limit = tonumber(ARGV[1]) local timeout = tonumber(ARGV[2]) local current = redis.call('get', key) if not current or tonumber(current) &lt; limit then current = redis.call('incr', key) if tonumber(current) == 1 then redis.call('expire', key, timeout) end return 1 end return 0 lua脚本二 local key = KEYS[1] local limit = tonumber(ARGV[1]) local timeout = tonumber(ARGV[2]) local current = redis.call('incr', key) if tonumber(current) == 1 then redis.call('expire', key, timeout) end if tonumber(current) &gt; limit then return 0 end return 1 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/120/">«</a>
	<span class="pagination__item pagination__item--current">121/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/122/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>