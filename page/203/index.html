<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872fe2ce029a828c191b03d20b719ff3/" rel="bookmark">
			vivado创建层次原理图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：在进行数字系统设计过程中，随着复杂度的增加，原理图也会越来越大。这时候我们想到了使用IP打包的方式把相同功能用一个模块来表示，模块之间使用接口来通信。但是如果IP的数量本身就已经很多的时候，还需要对相关联的各个IP再次打包。如果是RTL设计，那么可以简单的使用module再次封装一次。但是在原理图设计中有类似的方法吗，可以采用层次原理图的方式。
1，例如设计中有3个加法器，怎么创建层次原理图呢。
2， 使用select Aera把三个加法器选中,点击create hierarchy
总结：解决了复杂电路设计时的层次问题，避免了使用去使用RTL代码的形式去重构原理图的弊端，实现了完全用原理图设计的初衷，保证了系统设计风格的统一完整性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be1af93a1928ad3875173d403dd510cd/" rel="bookmark">
			BGP基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BGP基本原理 建议食用原文，有图
原文链接
BGP概述
BGP（Border Gateway Protocol，边界网关协议）是一种用于自治系统间的动态路由协议
BGP可以进行路由优选，路由环路避免、高效率的传递机制、维护大量路由的能力、触发更新等。 BGP协议特性
BGP协议 BGP是自治系统外部路由协议，用来在AS之间传递路由信息
路径矢量路由协议，从设计上笔迷拿了环路的发生
由TCP协议承载，端口号为179
支持CIDR和路由聚合
路由附带丰富的属性
只发送增量路由更新
路由过滤和路由策略
基本术语
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-U7MJBzvu-1670224823634)(image/image_jzSX-fMhC5.png)]
BGP Speaker：运行BGP路由协议的路由器
Router ID
BGP对等体：相互之间存在TCP连接、相互交换路由信息的BGP发言者之间互称对等体。
IBGP对等体：同一自治系统的BGP对等体称为IBGP对等体
EBGP对等体：处于不同自治系统的BGP对等体之间称为EBGP对等体
对等体
EBGP对等体
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ATNGDb8K-1670224823636)(image/image_AH9rBsJUCT.png)]
处于不同AS的BGP对等体为EBGP对等体，通常情况下EBGP对等体是物理上直连
BGP发言者从EBGP对等体获得的路由会向他所有BGP对等体通告（包括EBGP和IBGP）
IBGP对等体
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-U9yEmg6n-1670224823636)(image/image_6kjB0pDnjT.png)]
处于同一个AS的BGP对等体为IBGP对等体
从IBGP获得的路由不想它的IBGP对等体发布
IBGP全连接
BGP会话是基于TCP的点到点单播连接
BGP发言者从IBGP对等体获得路由不向其他IBGP对等体发布
BGP消息及状态机
BGP消息种类 消息类型消息作用描述Open用于建立BGP对等体之间的连接关系Keepalive周期性地想BGP对等体发出Keepalive消息，用来爆出链接的有效性Update携带的是路由更新（删减、增加）信息Notification当BGP检测到错误状态是，就会想对等体发出Notification消息，之后BGP连接会立即被关闭Route-refresh要求对等体重新发送指定地址族的路由信息 Open消息： Open消息是TCP连接建立后发送的第一个消息，用于建立BGP对等体之间的连接关系并进行参数协商。内容包括BGP版本号、所属AS、路由器ID、Hold Time值、认证信息等信息
**Keepalive 消息: **BGP 会周期性地向对等体发出 Keepalive 消息，主要作用是让 BGP邻居知道自己的存在，保持邻居关系的稳定性; 还有一个作用是对收到的 Open 消息的回应。其消息格式中只包含消息头，没有附加其他任何字段。长度共 19 个字节,消息中只有标记、长度、类型，不包括数据域。
**Update 消息: **Update 消息用于在对等体之间交换路由信息。它既可以发布可达路由信息，也可以撤销不可达路由信息;一条 Update 消息可以通告一类具有相同路径属性的可达路由，同时 Update 消息还可以携带多条不可达路由。
Notification 消息: Notification 消息的作用为错误通知。BGP 发言者如果检测到对方发过来的消息有错误或者主动断开 BGP 连接,都会发出 Notification 消息来通知 BGP邻居，并关闭连接且回到 idle 状态; 如果收到邻居发来的 Notification 消息，也会将连接状态变为 idle。Notification 消息的内突包括错误代码和错误子代码及错误数据等信福
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be1af93a1928ad3875173d403dd510cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bbb23578dddb1d597ad556c04ed58ff/" rel="bookmark">
			python 有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数?都是多少?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a = [] count = 0 for i in range(1,5): for j in range(1,5): for x in range(1,5): if i != j and i !=x and j !=x: a.append(str(i)+str(j)+str(x)) count += 1 print( a,'一共有%d个不重复的数字' % count,sep='\n') print( '一共有%d个不重复的结果' % len(a)) ['123', '124', '132', '134', '142', '143', '213', '214', '231', '234', '241', '243', '312', '314', '321', '324', '341', '342', '412', '413', '421', '423', '431', '432'] 一共有24个不重复的数字 一共有24个不重复的结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f70eef8cbe6b8be46929ba8d4043885/" rel="bookmark">
			ctrlz删除的文件怎么恢复?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们工作时经常会用到各种快捷键，以便于我们更快的完成工作，但好用是好用，在我们电脑操作时，这很容易出现失误。不小心按了Ctrl+Z撤销，导致重要文件丢失。一旦遇到这样的事，建议在操作以上按键的同时按住CTRL+y，恢复因撤销而丢失的文件。但由于各种情况，不少小伙伴都无法及时操作，那么ctrlz删除的文件怎么恢复呢?
遇到这样的问题，不要慌，不要急，也不要写到丢失文件的位置。可以先按ctrl+y恢复取消。但要想恢复就需要知道自己用了多少次Ctrl+z，然后可以多次按Ctrl+Y。
如果我们误按了Ctrl+Z键，又进行了其他操作，以至于无法通过上面的方法恢复，这时候就需要尝试借助专业的数据修复工具进行修复。
失易得数据恢复软件可用于删除、误操作、系统问题、硬盘问题等造成的数据丢失。以及用于恢复丢失的文档、照片、视频、压缩文件等。下面我们来看看详细的恢复步骤吧!
第一步：运行失易得数据恢复软件，选择“误删除文件”或者“深度恢复”功能进入。
第二步：选择我们要恢复文件所在的磁盘，点击下一步。
第三步：选择我们要恢复的文件，然后点击进行扫描。
第四步：等待扫描完毕，找到我们要恢复的文件进行预览，确认是我们要恢复的文件后，勾选要恢复的文件，点击恢复按钮，选择文件要保存的路径，即可恢复成功。
如果恢复后碰到文件损坏:数据在丢失过程中可能会被损坏，损坏的文件在恢复后容易出现打不开、空白、乱码的情况。这时就需要借助失易得文档修复。
如果恢复后碰到文件覆盖:当数据丢失后再写入，会造成数据覆盖。恢复后容易打开，打开空白，乱码。这时就需要借助失易得文档修复。
以上就是关于ctrlz删除的文件怎么恢复的方法，如果您仍然对Ctrl+Z的解决方案有疑问，可以与我们联系。希望这个分享能够对大家有一定的帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ea94e3b2af81f73b6f9ee1ba48d380/" rel="bookmark">
			C# 时间精确到毫秒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UTC时间转指定时差精确到毫秒
//UTC时间 DateTime dt = new DateTime(2018, 3, 31, 2, 30, 10, 33); //转北京时间，毫秒精确后两位 string str = dt.AddHours(8).ToString("yyyy/MM/dd h:mm:ss.ff");//2018-3-31 10:30:10.33 //格林尼治标准时间，毫秒精确后三位 string str = dt.AddHours(0).ToString("yyyy/MM/dd h:mm:ss.fff");//2018-3-31 2:30:10.033 dt.AddHours(value) value是时间差
备注：HH为24小时制，hh为12小时制。下面示例图：
c++时间精确到毫秒
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb01b65fcb517e8ffaeb8c726334dbc/" rel="bookmark">
			TDengine3.0：解决高基数问题的时序数据库设计思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小 T 导读： 数据集的高基数（High-Cardinality）问题一直困扰着诸多主流的时序数据库（Time Series Database，TSDB）产品。一些数据库管理系统，在基数较低时表现良好；但是随着基数的增加，数据库的表现也会变差，这就给数据库管理员带来了很大的挑战，他们需要通过相关设计降低基数，避免与之相关的问题。
TDengine 3.0 是第一个解决了高基数问题的时序数据库，本文将分享其设计思路。
何谓高基数问题？ 讲到高基数问题，首先，我们要理解什么是基数（Cardinality）。基数可以定义为一个数据集中值的数量。数据集不同，基数可以很高，也可以很低。比如，如果是布尔数据，它的值只能是 true 或 false，则该数据集的基数为 2。但是如果是像设备 ID 这样的数据集，其基数就非常大了。
对于时序数据，事情就更复杂了。时序数据总会关联一些元数据，比如标签。因此，一个系统的基数就是每个标签的基数的叉乘。比如，以智能电表为例，它会关联设备 ID、城市 ID、厂商 ID 和模型 ID 等标签。几百个城市，百万级设备，再加上不同的厂商、模型，基数轻松超过百亿级。
高基数有什么问题呢？这会增加定位一个唯一的值所需要的时间。对于数据库而言，延迟与基数直接相关。许多时序数据库，如 InfluxDB、OpenTSDB 和 Prometheus，都采用了键值存储模型，其中的键是由标签组合唯一识别的。这种模式有个副作用，它会极大增加数据集的基数。
那 TDengine 3.0 是如何解决高基数问题的呢？下面我们一起看一下它的几个核心设计。
数据模型：一个数据采集点一张表 特有的数据模型，是 TDengine 的一大核心设计，即“一个数据采集点一张表”。也就是说，TDengine 建议为数据采集点创建一张单独的表。一般情况下，一个设备就是一个数据采集点；但是在更复杂的情况下，一个设备可能包含多个数据采集点，而且不同的采集点有不同的采集频率。
在设计上，TDengine 使用一致性哈希来确定哪个虚拟节点（vnode）负责存储特点表（table）的数据。在 vnode 内部，系统会构建索引，以提升定位 table 的速度。随着表数量的增多，TDengine 会创建更多 vnode，尽量减少定位到某个 table 的时间，并支持系统轻松伸缩。
这种设计保证了向任何一个表插入数据或从任何一个表查询数据的延迟，即使表的数量呈指数增长。因此，延迟不受 TDengine 中高基数的影响。
将元数据与时序数据分离 通过“一个数据采集点一张表”的设计，TDengine 可以保证单一表的延迟。但是，现实世界的具体应用往往需要聚合多个表或设备中的数据。这是 TDengine 在设计上要面对的一个主要挑战。
为了解决这个问题，TDengine 引入了超级表（supertable）。与标准的数据库不同，超级表允许应用程序将一组标签关联到每个表。TDengine 会将这些标签与采集到的时序数据分开存储：使用 B 树为标签建立索引，将其保存到元数据存储中；而时序数据保存在一个单独的时序数据存储中。元数据存储中的每张表只有一行数据，而且可以根据需要更新。在时序数据存储中，每个表都有许多行数据，而且数据集会随着时间的推移而增长，直到其生命周期结束。
为了聚合多个表的数据，应用程序可以通过标签来过滤。当执行时，TDengine 首先搜索元数据存储，并获得满足过滤条件的表的列表，然后再来获取存储在时序数据存储中的数据块，并完成聚合过程。
首先扫描元数据存储，因为这个数据集比时序数据存储的规模要小得多，TDengine 就可以提供非常高效的聚合能力。这个过程可以用下图表示。
分布式存储元数据 在 TDengine 2.x 的设计中，表的元数据，比如模式和标签，都存储在管理节点（mnode）上。如果创建的表的数量达到千万级，这就会成为 TDengine 的一个瓶颈：过滤这么多标签的延迟会明显增加了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb01b65fcb517e8ffaeb8c726334dbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28826b46c4fb018e4a1a4329d02a6850/" rel="bookmark">
			Hadoop面试题及参考答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、什么是Hadoop及其组件2、Hadoop的守护进程3、Hadoop的YARN/HDFS/MapReduce分别包含哪些组件，每个组件的职能是什么？3.1 YARN：Yet Another Resource Negotiator，是一种新的Hadoop资源管理器3.2 HDFS：分布式文件管理系统3.3 MapReduce：分布式计算框架，采用Master/Slave架构，1个JobTracker带多个TaskTracker 4、一个MapReduce任务在提交阶段是如何对输入数据进行分片划分的？5、MapReduce里的Combiner是做什么用的？什么情况下需要，和Reduce的区别是什么？6、MapReduce的Shuffle过程包含了哪几个阶段，分别做了什么工作？Shuffle的数据量是由什么决定的？7、什么是推测机制，它是如何解决计算慢节点问题的？8、HDFS是如何实现容错机制的？如果NameNode挂了会怎么样，DataNode挂了会怎么样？9、HDFS的一次读数据请求经历了怎样的过程？一次写请求经历了怎样的过程？10、YARN的产生解决了什么样的调度问题？11、YARN是如何做计算资源的调度的，有哪些策略？ 1、什么是Hadoop及其组件 Hadoop是一个开源分布式计算平台架构，基于apache协议发布，由java语言开发。主要包括
HDFS(分布式文件管理系统)MapReduce(分布式计算框架)Hive(基于Hadoop的数据仓库)Pig(基于Hadoop的数据流系统)HBase(一个分布式面向列的数据库)Spark(快速和通用计算的Hadoop数据引擎)ZooKeeper(分布式协作服务) 2、Hadoop的守护进程 NameNode(元数据服务器)
主节点，存储文件的元数据（文件名，文件目录结构，文件属性——生成时间，副本数，文件权限），以及每个文件的块列表和块所在的DataNode等SecondaryNameNode(辅助元数据服务器)
用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据快照DataNodes(块存储)
在本地文件系统存储文件块数据，以及块数据校验JobTracker(任务调度)
负责接收用户提交的作业，负责启动、跟踪任务执行，每个 DataNode有一个TaskTracker，它们执行实际工作。TaskTrackers(任务执行)
负责执行由JobTracker分配的任务，管理各个任务在每个节点的执行情况。 3、Hadoop的YARN/HDFS/MapReduce分别包含哪些组件，每个组件的职能是什么？ 3.1 YARN：Yet Another Resource Negotiator，是一种新的Hadoop资源管理器 ReasourManager
负责资源管理的，整个系统有且只有一个 RM ，来负责资源的调度。它也包含了两个主要的组件：定时调用器(Scheduler)以及应用管理器(ApplicationManager)。ApplicationMaster
每当 Client 提交一个 Application 时候，就会新建一个 ApplicationMaster 。由这个 ApplicationMaster 去与 ResourceManager 申请容器资源，获得资源后会将要运行的程序发送到容器上启动，然后进行分布式计算。NodeManager
NodeManager 是 ResourceManager 在每台机器的上代理，负责容器的管理，并监控他们的资源使用情况(cpu，内存，磁盘及网络等)，以及向ResourceManager/Scheduler 提供这些资源使用报告。Container
Container是YARN集群中资源的抽象，将NM上的资源进行量化，根据需要组装成一个个Container，然后服务于已授权资源的计算任务。计算任务在完成计算后，系统会回收资源，以供后续计算任务申请使用。Container包含两种资源：内存和CPU，后续Hadoop版本可能会增加硬盘、网络等资源。 3.2 HDFS：分布式文件管理系统 NameNodeSecondaryNameNodeDataNode 3.3 MapReduce：分布式计算框架，采用Master/Slave架构，1个JobTracker带多个TaskTracker JobTrackerTaskTrackerMapTaskReduceTask 4、一个MapReduce任务在提交阶段是如何对输入数据进行分片划分的？ 通过InputSplit()函数来处理，设置分片数量为Math.max(minSize,Math.min(goalSize, blockSize))，一个数据片分配一个map任务。
5、MapReduce里的Combiner是做什么用的？什么情况下需要，和Reduce的区别是什么？ Combiner主要是在map完成后，reducer之前对数据做一次聚合，以减少数据传输的IO开销。
数据格式转换
map: (K1, V1) → list(K2, V2)combine: (K2, list(V2)) → list(K2, V2)reduce: (K2, list(V2)) → list(K3, V3)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28826b46c4fb018e4a1a4329d02a6850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0348f54e5106d0669aee33e1e67ee3a7/" rel="bookmark">
			Python随机选择列表中的某个数/随机选择范围中的某个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. uniform( ) random.uniform(x, y) 方法将随机生成一个浮点数，它在 [x,y] 范围内。
也就是说，是从一个范围里选择一个浮点数。
# _*_ coding: utf-8 _*_ import random random.uniform(x, y) # _*_ coding: utf-8 _*_ from random import uniform uniform(x, y) from random import uniform print(uniform(6,7)) # 6.304576901378101 x -- 随机数的最小值，包含该值。y -- 随机数的最大值，不包含该值。返回一个浮点数 2. choice() random.choice()方法用于从序列中获取一个随机元素，list, tuple, 字符串都可以使用
也就是说，从一个列表里选择一个元素
在列表中随机挑选一个数
from random import choice List=[1,2,3,4] choice(List) print(choice(List)) # 第一次运行：4 # 第二次运行：1 在集合中随机挑选一个数
from random import choice Set=set([1,2,3,4,5]) choice(list(Set)) print(choice(list(Set))) # 第一次运行：4 # 第二次运行：3 在字符串列表里随机挑一个字符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0348f54e5106d0669aee33e1e67ee3a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495b58973b133b75160b21ff083d0edc/" rel="bookmark">
			C&#43;&#43;三大特性剖析（经典面试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		都知道三大特性是封装继承和多态
封装：
封装其实是三个特性里面比较概念化的东西，也最容易理解
官方一点的说法就是能够避免很好保护类中的数据，从而保证数据安全，因为仅向外面暴露访问、交互接口，而把具体的细节隐藏起来。
这里注意一点，class成员默认访问权限和struct有什么不同？
class:private struct：public
继承：
继承的话涉及的知识点就比较多了
首先是他的定义一定要理解清楚：让某种类型对象获得另⼀个类型对象的属性和⽅法，它可以使⽤现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进⾏扩展
将⼈定义为⼀个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉等公共⽅法，在定 义⼀个具体的⼈时，就可以继承这个抽象类，既保留了公共属性和⽅法，也可以在此基础上 扩展跳舞、唱歌等特有⽅法。
继承这里还存在一个“切片”的行为，官方一点就是派生类对象可以赋值给基类的对象 / 基类的指针 / 基类的引用，注意：基类对象不能赋值给派生类对象，基类的指针或者引用可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是基类的指针是指向派生类对象时才是安全的
其次继承中的子类成员将屏蔽父类对同名成员的直接访问（变量和函数）
还有一些小知识点：
1.友元关系不能继承
2.基类定义了static静态成员，则整个继承体系里面只有一个这样的成员，无论派生了多少个子类
最后就是菱形继承：
这里通过面试问题来讲一讲
1. 什么是菱形继承？菱形继承的问题是什么？
一个子类有两个或以上直接父类时称这个继承关系为多继承，菱形继承是多继承的一种特殊情况。菱形继承有数据冗余和二义性的问题
2. 什么是菱形虚拟继承？如何解决数据冗余和二义性的
虚拟继承可以解决菱形继承的二义性和数据冗余的问题。虚拟继承通过使用虚基表和两个虚基表指针，利用虚基表中存的偏移量，用指针来标识会发生冗余和二义性的数据
3. 继承和组合的区别？什么时候用继承？什么时候用组合？
public继承是一种is-a的关系。也就是说每个派生类对象都是一个基类对象。
组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。
继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见 。继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高
实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。
多态：
这里首先要提出的就是如何理解多态？
同⼀事物表现出不同事物的能⼒，即向不同对象发送同⼀消息，不同的对象在接收时会产⽣不同的⾏为（重载实现编译时多态，虚函数实现运⾏时多态）允许你将⽗对象设置成为和⼀个或更多的他的⼦对象相等的技术，赋值之后，⽗对象就可以根据当前赋值给它的⼦对象的特性以不同的⽅式运作
构成多态的两个条件
1. 必须通过基类的指针或者引用调用虚函数
2. 被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写
这里还应该知道虚函数重写的两个例外1.协变2.析构函数的重写
多态的原理需要重点理解一下
虚函数表
/ /这里常考一道笔试题：sizeof(Base)是多少？ class Base { public: virtual void Func1() { cout &lt;&lt; "Func1()" &lt;&lt; endl; } private: int _b = 1; }; 除了_b成员，还多一个__vfptr放在对象的前面(注意有些平台可能会放到对象的最后面，这个跟平台有关)，对象中的这个指针我们叫做虚函数表指针(v代 表virtual，f代表function)。 一个含有虚函数的类中都至少都有一个虚函数表指针，因为虚函数的地址要被放到虚函数表中，虚函数表也简称虚表。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495b58973b133b75160b21ff083d0edc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517141843e15f677f16e5b08a77e9bf4/" rel="bookmark">
			Python列表追加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、extend() a = [1,2] b = [3,4] a.extend(b) print(a) # [1, 2, 3, 4] a = [1,2] b=3 c=4 a.extend((b,c)) print(a) # [1, 2, 3, 4] 2、a+b a = [1,2] b = [3,4] print(a+b) # [1, 2, 3, 4] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3234cdb4700e9cbefd328275b5809a0/" rel="bookmark">
			音视频开发--音视频基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		音视频基础 一、音视频录制原理 视频录制流程
1、准备摄像头
2、图像帧阶段
从摄像头采集视频数据（图像帧），采集数据格式：YUV或者RGB，YUV和RGB细分的话还包括YUV 4:4:4、YUV 4:2:2、YUV 4:2:0等，RGB细分的话还包括RGB565、RGB555、RGB24、RGB32、ARGB32等格式.
3、图像处理阶段
我们采集完数据之后，就可以对采集到的数据进行处理了。例如：曝光、色度、温和度、色差等等。都可以在这个阶段做。
4、图像帧队列阶段
处理后的图像帧，会暂存放到图像帧队列中，等待视频编码器来对数据进行编码；
5、视频编码阶段
如果图像帧队列中有数据的话，视频编码器就会进行处理。如果不做编码的话，视频的体积是非常大的，而此阶段的技术也是非常多的，还可以称之为压缩。
6、视频包队列阶段
将压缩完的数据，暂存到视频包队列；
7、复用器
复用器进行音视频封装（例如：封装成mp4等）
8、写入到文件。
音频录制流程
1、准备麦克风
2、采样帧阶段
从麦克风采集的音频数据，采集的音频数据又称为PCM，采样帧的概念：采多少数据作为一帧去做编码压缩
3、音频处理阶段
为什么要做音频处理，有时候你要对你这个声音，如果你要想做一些变音，比如你这个声音比较尖锐，那你想把它把它压的稍微低沉一点，那这个时候就是可以做这个音频处理。
4、采样帧队列阶段
处理后的采样帧，会暂存放到采样帧队列中，等待采样编码器来对数据进行编码；
5、音频编码阶段
音频编码器从采样帧队列读取处理好的采样帧进行压缩。
6、音频包队列
将压缩完的数据，暂存到音频包队列；
复用器（音视频封装）
将音频包队列中的数据和视频包的数据进行封装，按照一定的规则写到文件中。
时钟
为了音视频同步，在采集采样帧和图像帧同时加上一个时间戳。
二、音视频播放原理 音视频播放原理：实际上是音视频录制的逆向过程。，如果你是按照MP4的格式写到文件里面去，那你现在在播放的时候，那你就按照MP4的规则把这个音频跟视频分离出来，那我们再往下面去看，你可以看到也是同样存在这种队列，存在这种队列有什么用呢，这实际上他这队列就是先把数据放到队列里面去，然后等待，我们解码线程去从队列里面去获取数据的音频跟视频都是一样的，然后我们解码后，那我们也会去继续放到帧队列里面去呢，帧队列为什么还放在帧队列里面，因为我们后面还要做一个音视频同步控制，所以我们要先把数据稍微缓存一下，缓存一下，然后再去通过音视频同步的时候，我们才真正的把它拨到这个喇叭或者这个显示器里面来，但是还有一点要注意的是，比如我这边音频，你是可以做音频处理，就可以做一些音效处理，比如你可以调这个重低音呢，那就可以做这个音频的，做音频的一个算法处理，那比如你要把这个图像这个亮度，把这种色彩给调一下，那你就可以用这个图像处理这样子的一个模块，还有一个点就是这个音视频同步这一块，有的时候是在音频处理和图像处理后进行时间同步。
三、图像基础概念 像素：像素是一个图片的基本单位，例如2500×2000的照片就是指横向有2500个像素点，竖向有2000个像素点，总共是500万个像素，也俗称500万像素照片。
分辨率：是指图像的大小或尺寸。
常见的分辨率：
360P(640x360)、720P(1280x720)、1080P(1920x1080)、4K(3840x2160)、8K(7680x4320)
位深：我们看到的彩色图片，都有三个通道，分别为红(R）、绿(G)、蓝(B)通道。（如果需要透明度则还有alpha分量）通常每个通道用8bit表示，8bit能表示256种颜色，所以可以组成256256256=16,777,216 = 1677万种颜色。这里的8bit就是我们讲的位深。每个通道的位深越大，能够表示的颜色值就越大，比如现在高端电视说的10bit色彩，即是每个通道用10bit表示，每个通道有1024种颜色。102410241024约为10,7374万色=10亿色， 是8bit的64倍。常见的颜色还是8bit居多。
帧率：在1秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。比如25fps表示一秒有25张图片。
常用帧率：
电影帧率一般是 24fps（帧每秒）；
电视剧一般是25fps；
监控行业常用 25fps；
音视频通话常用15fps；
帧率越高，画面越流畅，需要的设备性能也越高。
码率：视频文件在单位时间内使用的数据流量。比如1Mbps。对于同一个原始图像源的时候，同样的编码算法，则码率越高，图像的失真就会越小，视频画面就会越清晰。但是在外在因素（例如光线不足）作用下，分辨率小的视频有可能比分辨率大的视频清晰。
Stride跨距：
YUV
YUV：“Y”表示明亮度，也就是灰阶值，“U”和“V”表示的则是色度。
YUV排列方式
YUV是一个比较笼统地说法，针对它的具体排列方式，可以分为很多种具体的格式：
打包（packed）格式：将每个像素点的Y、U、V分量交叉排列并以像素点为单元连续的存放在同一数组中，通常几个相邻的像素组成一个宏像素（macro-pixel）
平面（planar）格式：使用三个数组分开连续的存放Y、U、V三个分量，即Y、U、V分别存放在各自的数组中。
YUV采样表示法
YUV采用A:B:C表示法来描述Y,U,V采样频率比例，下图中黑点表示采样像素点Y分量，空心圆表示采样像素点的UV分量。主要分为 YUV 4:4:4、YUV 4:2:2、YUV 4:2:0 这几种常用的类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3234cdb4700e9cbefd328275b5809a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7600d78593059ef29d460094d1b12bd9/" rel="bookmark">
			1. 简明误差卡尔曼滤波器（ESKF）及其推导过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简明误差卡尔曼滤波器（`ESKF`）及其推导过程简介`ESKF`基本过程及优点`ESKF`参数含义连续时间上的 `ESKF`状态方程误差状态方程推导误差状态的旋转项误差状态的速度项完整误差变量的运动学方程 离散时间上的`ESKF`运动学方程`ESKF`的运动过程`ESKF`的更新过程`ESKF`的误差状态后续处理小结 1. 简明误差卡尔曼滤波器（ESKF）及其推导过程 简介 本文主要介绍一种特殊正交群 SO(3) \text{SO(3)} SO(3) 上的ESKF(Error State Kalman Filter, 误差卡尔曼滤波器)（有时也叫做流形上的ESKF）推导过程。
ESKF基本过程及优点 在现代的大多数IMU系统中，人们往往使用误差状态卡尔曼滤波器（Error State Kalman Filter, ESKF），而非原始状态的卡尔曼滤波器。大部分基于滤波器的LIO或VIO实现，都使用ESKF作为状态估计方法。
相比于传统KF，ESKF的优点如下：
在旋转的处理上，ESKF的状态变量可以采用最小化的参数表达，也就是使用三维变量来表达旋转的增量。而传统的KF则需要使用四元数（ 4 4 4维）或更高维的表达（旋转矩阵， 9 9 9维）,要不就得采用带奇异性的表达方式（欧拉角）。ESKF总是在原点附近，距离奇异点较远，并且也不会由于离工作点太远而导致线性化近似不够的问题。ESKF的状态量为小量，其二阶变量相对来说可以忽略。同时大多数雅可比矩阵在小量情况下变得非常简单，甚至可以用单位阵代替。误差状态的运动学也相比原状态变量要来的更小，因为我们可以把大量更新部分放到原状态变量中。 在ESKF中，我们通常把原状态变量称为名义状态变量（Norminal State），把ESKF中的状态变量称为误差状态变量（Error State）。
ESKF整体流程如下：
当IMU测量数据到达时，首先将其积分后，放入名义状态变量中。由于这种做法没有考虑噪声，其结果自然会快速漂移。于是我们希望把误差部分作为误差变量，放入ESKF中。ESKF内部会考虑各种噪声和零偏的影响，并且给出误差状态的一个 高斯分布 描述。同时ESKF本身作为一种卡尔曼滤波器，也具有预测过程和修正过程。其中 修正过程 需要依赖 IMU 以外的传感器观测。在修正后，ESKF可以给出 后验的误差高斯分布。随后，我们将这部分误差放入名义状态变量中，并把ESKF置零，这样就完成了一次循环。 ESKF参数含义 连续时间上的 ESKF状态方程 我们设ESKF的真值状态为：
x t = [ p t , v t , R t , b a t , b g t , g t ] T x_t = [p_t, v_t,R_t,b_{at},b_{gt},g_t]^\text{T} xt​=[pt​,vt​,Rt​,bat​,bgt​,gt​]T
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7600d78593059ef29d460094d1b12bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a05a020f3016873e096305a11b8a69/" rel="bookmark">
			信息收集之外网信息收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从个人的角度去简单整理下打点前的信息收集那些事。从信息收集本质上来说多数内容都是大同小异，遇到坚壁时，不用死磕，毕竟条条大路通罗马。（大佬们也可以说说看法~向各位大佬学习！！） Tell Me 想要构建一个"上帝视野"，前期的信息收集工作是必不可少的，无论是了解一个人、一项业务、还是深入一个系统等，都需要“信息”。大佬曾说过，渗透测试的本质是信息收集，而个人直观感受就是“意料之外，情理之中”。
本文就简单整理下打点前的信息收集那些事。从信息收集本质上来说多数内容都是大同小异，遇到坚壁时，不用死磕，毕竟条条大路通罗马。
红队知识点大致流程：
外网信息收集——&gt;打点——&gt;权限维持——&gt;提权——&gt;内网信息收集——&gt;横向移动——&gt;痕迹清理
打点关键资产数据信息：
找出网站真实IP，挖掘相邻网段、绕过安全设备
判断目标是否为蜜罐
定位内网IP和系统
定位关键的应用系统
定位关键企业信息
外网信息收集 对于外网信息收集主要有几点：ip、域名、企业等资产信息以及相应端口/服务、指纹、敏感信息、社工碰撞等易受攻击面信息。
tips：
挂代理池，走负载均衡，防止被锁IP。
确定目标后，析缕分条，找到突破及利用点。
关于打点时隐匿：
攻击前：虚拟机做全局代理、浏览器隐私模式或Tor，脚本、账号啥的非本人
攻击后：Rootkit……
0x00 常用工具、资源简记： 工具、网站备注爱站、站长工具Whois、备案号、权重、公司名称等天眼查、企查查、搜狗搜索引擎公司注册域名、微信公众号、APP、软件著作权等ZoomEye、Shodan、FOFA、0.Zone、quake网络空间资产搜索引擎ENScanGo、ICP备案主域名收集OneForAll、Layer、Rapid7的开源数据项目、ctfr、EyeWitness子域名收集Kscan、ShuiZe_0x727、ARL灯塔、Goby自动化、批量信息收集Bufferfly、Ehole资产处理、信息筛选dnsdb、CloudFlairCDN相关VirusTotal、微步、ip2domainC段、域名/ip情报信息Nmap、Masscan端口服务信息Google Hacking、dirsearch、URLFinderWEB站点信息、api接口等wafw00fwaf识别云悉、潮汐、WhatWeb在线CMS识别七麦、小蓝本APP资产ApkAnalyserApp敏感信息乌云漏洞库、CNVD、waybackurls历史漏洞、历史资产等n0tr00t/Sreg、reg007个人隐私信息GitDorker资产信息、源码泄露theHarvester、Snov.io邮箱信息收集OSINT开源情报和侦擦工具开源情报资源导航anti-honeypot、Honeypot Hunter蜜罐识别 0x01 主域名信息 域名用来代替IP使其更容易被用户找到、记住。
对于"非用户"来说，可通过域名信息获取：主域名、存活站点、关联信息、钓鱼信息。为漏洞挖掘提供数据支撑。
1. ICP备案 国内服务器线上运营都必须先办理ICP备案后才能上线。
备案信息查询：
ICP备案查询
https://beian.miit.gov.cn/#/Integrated/index
公安部备案查询
备案反查主域名
反查可分为备案域名查询和未备案域名查询。
备案域名查询
第三方站点
ICP备案查询-站长工具
SEO综合查询
公安部备案查询
企业信息查询网站
未备案域名查询
已知网站信息获取（如，网站站点导航可能会包含未备案的站点）
网络空间引擎进行证书、图标关联搜索。例如：fofa指定搜索规则 is_domain=true，即表示只返回域名*(个人感觉国外shodan、国内fofa)*。
2. Whois whois是用来查询域名的IP以及所有者等信息的传输协议。
通过whois信息可以获取注册人的关键信息。如注册商、联系人、联系邮箱、联系电话，也可以对注册人、邮箱、电话反查域名，也可以通过搜索引擎进一步挖掘域名所有人的信息。深入可社工、可漏洞挖掘利用。
站长之家
http://whois.chinaz.com
Bugscanner
http://whois.bugscaner.com
国外BGP
https://bgp.he.net
who.is
https://who.is/
IP138网站
https://site.ip138.com/
域名信息查询-腾讯云
https://whois.cloud.tencent.com/
ICANN LOOKUP
https://lookup.icann.org/
狗狗查询
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24a05a020f3016873e096305a11b8a69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a5ee6c48766ad3837e58533ae40fa0/" rel="bookmark">
			mac安装rabbitmq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 brew updata brew install rabbitmq RabbitMQ安装后的路径为：/usr/local/Cellar/rabbitmq/3.11.4 (版本根据安装版本确定) 进入该目录(/usr/local/Cellar/rabbitmq/3.11.4)之后 cd /sbin ./rabbitmq-server 此时在浏览器输入http://localhost:15672即可进入rabbitmq控制终端登录页面，默认用户名和密码为 guest/guest.
命令 rabbitmq-plugins enable rabbitmq_management //启动rabbitmq rabbitmq-plugins disable rabbitmq_management //关闭rabbitmq rabbitmqctl list_users 查看有哪些用户 添加账户 rabbitmqctl add_user admin 123 设置用户角色 rabbitmqctl set_user_tags admin administrator 设置用户权限 rabbitmqctl set_permissions -p "/" admin ".*" ".*" ".*" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/323f789bf09872693c6e746741f70455/" rel="bookmark">
			STM32F4_HAL库_串口阻塞/中断/DMA三种方式发送数据的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、串口阻塞发送 串口阻塞发送的意思就是，发送一段数据，在没有发送完所有数据之前，一直停留在此发送函数（可设定阻塞时间），这个过程中会阻塞别的程序运行；
1.1、配置 HAL库的配置分为两个层次，一个是HAL库内部调用的、与MCU硬件相关的初始化xxx_MspInit，一个是我们外部调用的初始化xxx_Init；
这两个初始化函数配置完，就可以进行阻塞式的串口发送了，很简单。
1.1.1、HAL_UART_MspInit HAL_UART_MspInit，MCU硬件初始化，需要开启RCC串口时钟、RCC的GPIO端口时钟、配置GPIO的模式；
(还有个反初始化HAL_UART_MspDeInit，这里就不说了)
void HAL_UART_MspInit(UART_HandleTypeDef* huart) { GPIO_InitTypeDef GPIO_InitStruct; if(huart-&gt;Instance==DEBUG_USARTx){ /* 时钟使能 */ DEBUG_USART_RCC_CLK_ENABLE(); DEBUG_USARTx_GPIO_ClK_ENABLE(); /* 串口外设功能GPIO配置 */ GPIO_InitStruct.Pin = DEBUG_USARTx_Tx_GPIO_PIN; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = DEBUG_USARTx_AFx; HAL_GPIO_Init(DEBUG_USARTx_Tx_GPIO, &amp;GPIO_InitStruct); GPIO_InitStruct.Pin = DEBUG_USARTx_Rx_GPIO_PIN; HAL_GPIO_Init(DEBUG_USARTx_Tx_GPIO, &amp;GPIO_InitStruct); } } 1.1.2、MX_DEBUG_USART_Init MX_DEBUG_USART_Init，串口协议初始化，波特率、数据宽度、停止位、串口模式的配置；
void MX_DEBUG_USART_Init(void) { husart_debug.Instance = DEBUG_USARTx; husart_debug.Init.BaudRate = DEBUG_USARTx_BAUDRATE; husart_debug.Init.WordLength = UART_WORDLENGTH_8B; husart_debug.Init.StopBits = UART_STOPBITS_1; husart_debug.Init.Parity = UART_PARITY_NONE; husart_debug.Init.Mode = UART_MODE_TX_RX; husart_debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/323f789bf09872693c6e746741f70455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f782f1802a2edca18315544d7296feea/" rel="bookmark">
			【torch.nn.Sequential】序列容器的介绍和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 torch.nn.Sequential简单介绍构建实例参数列表字典 基本操作参考 torch.nn.Sequential 简单介绍 nn.Sequential是一个有序的容器，该类将按照传入构造器的顺序，依次创建相应的函数，并记录在Sequential类对象的数据结构中，同时以神经网络模块为元素的有序字典也可以作为传入参数。
因此，Sequential可以看成是有多个函数运算对象，串联成的神经网络，其返回的是Module类型的神经网络对象。
构建实例 参数列表 以参数列表的方式来实例化 print("利用系统提供的神经网络模型类：Sequential,以参数列表的方式来实例化神经网络模型对象") # A sequential container. Modules will be added to it in the order they are passed in the constructor. # Example of using Sequential model_c = nn.Sequential( nn.Linear(28*28, 32), nn.ReLU(), nn.Linear(32, 10), nn.Softmax(dim=1) ) print(model_c) print("\n显示网络模型参数") print(model_c.parameters) print("\n定义神经网络样本输入") x_input = torch.randn(2, 28, 28, 1) print(x_input.shape) print("\n使用神经网络进行预测") y_pred = model.forward(x_input.view(x_input.size()[0],-1)) print(y_pred) 利用系统提供的神经网络模型类：Sequential,以参数列表的方式来实例化神经网络模型对象 Sequential( (0): Linear(in_features=784, out_features=32, bias=True) (1): ReLU() (2): Linear(in_features=32, out_features=10, bias=True) (3): Softmax(dim=1) ) 显示网络模型参数 &lt;bound method Module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f782f1802a2edca18315544d7296feea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2b9a41a379f20523de4c10c7c1433c/" rel="bookmark">
			Python列表索引获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、字符串索引获取 1、.find() #字符串 stringA = "huo qu suo yin" #获取o的索引并打印 index_o = stringA.find("o") print(index_o) 2 进程已结束,退出代码0 只适用于字符串，并且只能输出最近位置的索引，不能输出全部
2、.index() #字符串 stringA = "huo qu suo yin" #获取o的索引并打印 index_o = stringA.index("o") print(index_o) #列表 listA = ["o", "u" , "i"] #获取u的索引并打印 index_u = listA.index("u") print(index_u) # 2 # 1 # 进程已结束,退出代码0 适用于字符串和列表，并且只能输出最近位置的索引，不能输出全部
3、re.finditer() #引用正则表达式模块 import re #字符串 stringA = "huo qu suo yin" #获取所有o元素的索引 list_index = [i.start() for i in re.finditer("o",stringA)] print(list_index) [2, 9] 进程已结束,退出代码0 可以返回字符串中多个重复字符的索引
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2b9a41a379f20523de4c10c7c1433c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d25c809efcb8650ffbad830a5388d28/" rel="bookmark">
			判断单链表是否为回文链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。要求用 O(n) 时间复杂度和 O(1) 空间复杂度解决。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ /* 1.先遍历整个链表得出长度len 2.再将fast节点移至链表的中间 3.反转链表的后半段 4.对比链表的前半段和反转后的后半段链表值，出现不相等的就表示不是回文链表，否则就是回文链表 */ class Solution { public: ListNode* reverseList(ListNode* head) { ListNode *node = nullptr; while(head) { ListNode* tmp = head-&gt;next; head-&gt;next = node; node = head; head = tmp; } return node; } bool isPalindrome(ListNode* head) { int len = 0; ListNode* node = head; while(node) { len++; node = node-&gt;next; } ListNode* fast = head; for(int i = 0; i &lt; len/2; i++) { fast = fast-&gt;next; } ListNode* new_head = reverseList(fast); while(head &amp;&amp; new_head) { if(head-&gt;val !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d25c809efcb8650ffbad830a5388d28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378f454742a8e2ec6dc7bb7ecd449775/" rel="bookmark">
			Ubuntu18.04 LTS Miniconda 安装 换源 新建虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装 登录清华TUNA镜像源，找到miniconda。TUNA镜像网站
选择Miniconda3-latest-Linux-x86_64.sh安装。可以点击直接下载安装包，也可以使用wget在服务器上下载。本教程采用wget下载
在服务器上输入如下命令下载到服务器
wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh 下载完成后，输入如下命令安装
sudo bash Miniconda3-latest-Linux-x86_64.sh 输入密码后，直接回车
进入这个界面后，按下q键
进入这个界面后，输入yes然后回车
这里，直接回车。回车后就等待解压完成
接着，输入yes，然后回车
然后执行source .bashrc。
在命令行输入conda并回车，出现这个界面就表示安装成功了
最后sudo rm Miniconda3-latest-Linux-x86_64.sh删除安装包
换源 先说一下为什么需要换源，这里的源可以理解为安装包的下载源，anaconda官网的源在境外，下载速度较慢，比较容易出现安装软件时出现网络连接问题。所以把官方的下载源替换国内镜像的下载源即可。国内的镜像源做得好的有很多，我使用的是清华tuna的镜像源，本教程也是根据tuna官方提供的教程换源。
tuna官方换源教程：TUNA 换源
接下来开始换源。
在服务器中输入conda config --set show_channel_urls yes
然后sudo vi .condarc打开文件
删除这一行
粘贴如下内容
channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 保存退出后，执行conda clean -i
然后执行conda config --show-sources 。出现如下图所示内容就表示换源成功了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/378f454742a8e2ec6dc7bb7ecd449775/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71990a3a94684513f9bc172e6e4b0a9a/" rel="bookmark">
			根据出生日期计算年龄——基于Python的datetime库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 基于出生日期，计算到指定日期时的年龄。
2. 计算逻辑 给定出生日期，次年的同月同日及以后满1岁，否则不足1岁。
例如：1995年5月17日生，到1996年5月17日及以后则满1岁，到1996年5月16日时则不足1岁。
3. Python代码 from datetime import datetime def age_calc(birth_date, end_date): # change the type of date to datetime birth_date = datetime.strptime(birth_date, '%Y-%m-%d') end_date = datetime.strptime(end_date, '%Y-%m-%d') # compute the difference of day, month and year day_diff = end_date.day - birth_date.day month_diff = end_date.month - birth_date.month year_diff = end_date.year - birth_date.year # compute age based on the diffference of day, month and year if day_diff &gt;= 0: if month_diff &gt;= 0: years_old = year_diff else: years_old = year_diff - 1 else: if month_diff &gt;= 1: years_old = year_diff else: years_old = year_diff - 1 return years_old 其中birth_date和end_date均为‘yyyy-mm-dd’的日期字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71990a3a94684513f9bc172e6e4b0a9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75698e20b72493ad6d6b7f416c64b05b/" rel="bookmark">
			神经网络与深度学习 作业11：优化算法比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 编程实现图6-1，并观察特征
2. 观察梯度方向 3. 编写代码实现算法，并可视化轨迹 4. 分析上图，说明原理
（1）为什么SGD会走“之字形”？其它算法为什么会比较平滑？
（2）Momentum、AdaGrad对SGD的改进体现在哪里？速度？方向？在图上有哪些体现？
（3）仅从轨迹来看，Adam似乎不如AdaGrad效果好，是这样么？
（4）四种方法分别用了多长时间？是否符合预期？
（5）调整学习率、动量等超参数，轨迹有哪些变化？
5. 总结SGD、Momentum、AdaGrad、Adam的优缺点 SGD
Momentum AdaGrad Adam 6. Adam这么好，SGD是不是就用不到了？ 参考资料 1. 编程实现图6-1，并观察特征 import numpy as np from matplotlib import pyplot as plt from mpl_toolkits.mplot3d import Axes3D def func(x, y): return x * x / 20 + y * y def paint_loss_func(): x = np.linspace(-50, 50, 100) # x的绘制范围是-50到50，从改区间均匀取100个数 y = np.linspace(-50, 50, 100) # y的绘制范围是-50到50，从改区间均匀取100个数 X, Y = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75698e20b72493ad6d6b7f416c64b05b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b149775810c06f762b80fcda9be6a79/" rel="bookmark">
			npm sill idealTree buildDeps 安装踩坑指南（详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
已通过nvm安装node 18.8
需要运行
npx create-react-app demo01 首次提醒npm版本过低，但是更新npm失败，并且不再报错（安装其他包同样不报错）
且换源无果（更换淘宝源、清除缓存没效果），
使用ping http://registry.npm.taobao.org/ 检测网络也正常
0. 删除.npmsrc 、清除缓存 参考文章：
前端 - npm 的配置文件 .npmrc
运行npm install 安装失灵，一直卡在sill idealTree buildDeps没有反应_堂吉诃德明的博客
不想看原文直接尝试： 通过如下指令获得用户配置文件目录， 删除.npmrc文件
npm config get userconfig 通常是在 C：/users/xxx/
清除缓存方法： 会出现警示（大佬可以解答一下这么做的风险）
npm cache clean --force 1. 更换淘宝源（老生常谈） npm config set registry http://registry.npm.taobao.org/ npm config get registry 默认链接：https://registry.npmjs.org/ （可同理用npm config set registry “url” 重置）
2. 清除代理（已按方法0操作成功 但又报错read ECONNRESET） 参考：npm install卡在sill idealTree buildDeps没有反应，安装失灵_JohannaYe的博客-CSDN博客
npm config get proxy npm config rm proxy npm config rm https-proxy 其他建议： 检查node和npm版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b149775810c06f762b80fcda9be6a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29611fa5bc4baa28d73f466b72cb01a1/" rel="bookmark">
			commons-math3-3.6.1-包简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		commons-math3-3.6.1-包简介 完整中文文档、中英对照文档下载请移步：commons-math3-中文文档、中英对照文档-CSDN下载 1. 开源组件说明 jar包名称：commons-math3-3.6.1.jar
Maven 依赖：
&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-math3&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;/dependency&gt; 完整中文文档、中英对照文档下载请移步：commons-math3-中文文档、中英对照文档-CSDN下载 2. 该组件包结构即说明 Apache Commons Math 3.6.1 API 程序包 程序包说明org.apache.commons.math3 Common classes used throughout the commons-math library. 在整个公共数学库中使用的常见类别。
org.apache.commons.math3.analysis Parent package for common numerical analysis procedures, including root finding, function interpolation and integration. 父包用于常见的数值分析过程，包括根查找，功能插补和集成。
org.apache.commons.math3.analysis.differentiation This package holds the main interfaces and basic building block classes dealing with differentiation. 此包裹拥有处理差异化的主要接口和基本构建块类。
org.apache.commons.math3.analysis.function The function package contains function objects that wrap the methods contained in Math, as well as common mathematical functions such as the gaussian and sinc functions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29611fa5bc4baa28d73f466b72cb01a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85ec8cf9d76bf40a23f78d6503dd7f6/" rel="bookmark">
			服务器硬件及RAID配置实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
服务器
服务器硬件
服务器常见故障
1.系统不停重启进入不了系统
2.卡在开机界面右下角有FA B2 H8
3.系统安装不上
4.如何进入服务器的bios
5.一般进入阵列卡的快捷键
6.网络不通
7.硬盘不识别
管理口
RAID
RAID磁盘阵列介绍
RAID功能实现
RAID实现的方式
磁盘阵列配置
删除raid
全局热备
删除全局热备
局部热备
实现软raid
服务器 服务器硬件 cpu、主板、内存、硬盘、网卡、电源、raid卡、风扇、远程处理卡
硬盘尺寸：
目前生产环境中主流的两种类型的硬盘：3.5和2.5寸硬盘
2.5寸硬盘可以通过使用硬盘托架后适用于3.5寸硬盘的服务器
但是3.5寸没法转换成2.5寸
服务器常见故障 1.系统不停重启进入不了系统 排查是否硬件故障，系统盘是否损坏（硬盘灯红色，黄色，绿色）
查看系统第一启动项是哪种方式（硬盘 网络网卡 光驱 U盘）bios
是否双系统？双系统
硬盘主板背板是否有问题
服务器开机较慢请耐心等待3分钟，不是起不来
uefi和legacy
UEFI+GPT分区，只可安装win8/win10，开机快，效率高
Legacy+MBR分区，安装任何系统，开机慢，无法支持超过2T的硬盘
传统BIOS运行流程 开机→bios初始化→bios自检→引导操作系统→进入系统 UEFI运行流程 开机→UEFI初始化→引导操作系统→进入系统 2.卡在开机界面右下角有FA B2 H8 如何排查内存
国内机器一般可内存最小化测试
国外机器有些需要保持双通道运行（添加，减少）dell成对出现
对半测试内存条，8 4 4 2 2 1 1
3.系统安装不上 该机器是否支持该系统
驱动是否合适或是否已打驱动官网 客服
系统镜像是否可用
使用的U盘，光驱是否正常？光驱 外接光驱
客服（如已过保？）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f85ec8cf9d76bf40a23f78d6503dd7f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b8f9fd5f2c016bed9b44fb093e8b672/" rel="bookmark">
			排序的知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列
思维导图：
目录
一、基本概念
1.定义
2.排序的基本操作
3.排序时间复杂度
4.排序方法的稳定性
二、排序的类别
1.直接插入排序
2.希尔排序（缩小增量排序）
3.冒泡排序 4.快速排序
5.简单选择排序
6.堆排序
7.归并排序
​编辑 8.基数排序
a.多关键字排序(最低位优先法LSD)
b.链式基数排序
三、总结
一、基本概念 1.定义 排序：将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。
内部排序：在排序期间数据对象全部存放在内存的排序。
外部排序：在排序期间全部对象个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序。
2.排序的基本操作 比较：比较两个关键字的大小。
移动：将记录从一个位置移动到另一个位置。
3.排序时间复杂度 排序的时间复杂度可用算法执行的记录关键字比较次数与记录移动次数来衡量。
4.排序方法的稳定性 如果在记录序列中有两个记录r[i]和r[j], 它们的关键字 key[i] == key[j] , 且在排序之前, 记录r[i]排在r[j]前面。如果在排序之后, 记录r[i]仍在记录r[j]的前面, 则称这个排序方法是稳定的, 否则称这个排序方法是不稳定的。
二、排序的类别 1.直接插入排序 稳定性：稳定
时间复杂度：
最优情况是正向排序 – O(n)最差是逆向排序，每次插入都需要比较已完成数列元素的个数 – O(n^2) 空间复杂度：O(1)
过程：
注：可理解为打扑克整理牌的时候
2.希尔排序（缩小增量排序） 希尔排序是对直接插入排序的优化。当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就 会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。若待排记录序列为正序时，则时间复杂度可提到值O(n)。稳定性：不稳定 过程：
•首先取一个整数 gap &lt; n(待排序记录数) 作为间隔, 将全部记录分为 gap 个子序列, 所有距离为 gap 的记录放在同一个子序列中 •在每一个子序列中分别施行直接插入排序。 •然后缩小间隔 gap, 例如取 gap = gap/2 •重复上述的子序列划分和排序工作，直到最后取gap = 1, 将所有记录放在同一个序列中排序为止。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b8f9fd5f2c016bed9b44fb093e8b672/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c457bc7d35869997421d414809bac009/" rel="bookmark">
			c&#43;&#43; 与 java的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++ Vs java c++集合放的是赋值的数据，java集合放的是引用
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; class Node{ public: int data; Node(int _data){ data = _data; } }; int main(){ vector&lt;Node&gt; vec; Node n1(2); vec.emplace_back(n1); vec[0].data = 3; cout &lt;&lt; n1.data &lt;&lt; endl; // 2 原来不变 return 0; } package com.kcl; import java.util.ArrayList; import java.util.List; class Node{ public int data; Node(int data){ this.data = data; } } public class Test { public static void main(String[] args) { Node n1 = new Node(2); List&lt;Node&gt; list = new ArrayList&lt;&gt;(); list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c457bc7d35869997421d414809bac009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b036b858573be2cd6130704f8b82134/" rel="bookmark">
			Qt 百分比进度条显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QProgressDialog process; process.setRange(0, face_szie); process.setModal(true); process.setWindowIconText(tr("get face information ...")); for (int i = 0; i &lt; face_szie; i++) { TopoDS_Face current_face = workpiece_show_faces.at(i).face; get_FaceInfo_from_TopoFace(current_face,i); process.setValue(i); process.setLabelText(tr("got %1 faces ...").arg(i)); process.show(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/921a107d52d0a4ff74ed9d6d6ca4dfb7/" rel="bookmark">
			【cmake实战六】如何使用编译的库（动态库dll）——windows系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【cmake实战六】如何使用编译的库（动态库dll）——windows系统 一、文件目录1、main.cpp2、CmakeLists.txt3、haha 二、构建、编译、运行1、构建（新建build目录，在build目录下执行）2、编译3、运行 三、知识讲解1、LoadLibrary2、FreeLibrary3、GetProcAddress4、__declspec5、extern "C" 四、问题1、去掉extern “C" 会发生什么？？？2、是否有办法去掉extern “C"3、为啥c++就需要extern "C"，在4、参考问题3的答案，问题2的另外一种方法 一、文件目录 1、main.cpp #include&lt;iostream&gt; #include&lt;windows.h&gt; using namespace std; void loadDll(string dllname, HMODULE&amp; handle) { //handle = (handle_t)::LoadLibrary(dllname.c_str()); handle = (HMODULE)::LoadLibrary(dllname.c_str()); } bool freeDll(HMODULE&amp; handle) { bool re = FreeLibrary(handle); return re; } int main() { cout&lt;&lt;"hello world"&lt;&lt;endl; //handle_t handle = nullptr; HMODULE handle = nullptr; loadDll("C:\\Users\\jx\\Desktop\\test06\\lib\\Debug\\haha.dll", handle); if (nullptr == handle) { cout &lt;&lt; "fail to load dll" &lt;&lt; endl; } cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/921a107d52d0a4ff74ed9d6d6ca4dfb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f39376451720f99536cea4654971f79/" rel="bookmark">
			Ubuntu云服务器搭建饥荒联机版服务器教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu服务器搭建饥荒联机版服务器教程 为方便各位小伙伴开荒，弄了一个dst-admin的开源项目，方便小伙伴搭建服务器。 本教程主要介绍的是如何安装dst-admin饥荒管理平台，使用他来快速的部署和管理饥荒。参考地址：https://github.com/qinming99/dst-admin；饥荒服务器我推荐使用腾讯的星星海，性能提升30%，活动链接：https://curl.qcloud.com/UEtsthzh
docker版本部署请参考：点击查看 环境要求 1.Ubuntu服务器一台，Ubuntu 16.04 18.04已经测试，20版本的不行注意，其他操作系统请使用docker版本
2.Java环境jdk1.8
3.需要用到的工具 dst-admin.jar 安装包，shell连接工具，推荐使用国产的 FinalShell 下载地址
安装步骤： 在腾讯云控制台修改服务器防火墙，开放端口 为减少一些不必要的麻烦，建议开放所有端口，包括了入站和出站
腾讯云服务器安全组开放端口教程：点击查看
阿里云服务器安全组开放端口教程：点击查看
Ubuntu安装jdk1.8 先使用shell连接工具连接到服务器，执行以下命令，安装openjdk
#更新软件源 sudo apt-get update #安装openJDK1.8 sudo apt-get install -y openjdk-8-jdk #查看版本 java -version 显示 "openjdk version "1.8.0_252"就表示安装完成 下载最新版的dst-admin.jar安装包 下载地址 #进入到home目录 cd ~ #下载安装包 wget http://clouddn.tugos.cn/release/dst-admin-1.5.0.jar -O dst-admin.jar 启动dst-admin java -jar dst-admin.jar 出现了Completed initialization表示启动成功，按Control+C键结束进程
安装饥荒客户端 启动完成的dst-admin将释放两个脚本：install.sh 用于安装客户端 ,dstStart.sh 用于管理饥荒管理平台
#执行安装饥荒客户端安装程序,期间可能需要输入密码，这一步必须执行成功 ./install.sh 重启dst-admin 执行管理脚本dstStart.sh，注意jar包的名称必须为dst-admin.jar不然找到文件，输入3重启服务
#执行管理脚本 ./dstStart.sh 安装完成此时我们就可以登陆到我们的饥荒管理平台对服务器进行管理了
登陆饥荒管理后台设置自己的服务器 在浏览器输入我们的访问地址登陆管理后台，地址为服务器的公网IP（云服务都有提供），加端口号，即：http://xx.xx.xx.xx:8080，输入用户名admin 密码123456 即可登陆，登陆成功开始设置服务器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f39376451720f99536cea4654971f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430b809b018f7a9e70130c04ddbb0633/" rel="bookmark">
			c&#43;&#43; 静态库，动态库的制作和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.什么是库？2.静态库的制作1.静态库的命名规则2.静态库的制作与使用1.静态库的制作2.静态库的使用 3.动态库的制作1.动态库的命名规则2.动态库的制作与使用1.动态库的制作2.动态库的使用3.动态库加载失败的原因 4.静态库和动态库的对比1.程序编译成可执行文件的过程：2.静态库的制作过程3.动态库的制作过程5.静态库的优缺点6.动态库的优缺点 1.什么是库？ 库文件是计算机上的一类文件，提供给使用者一些可以直接拿来使用的变量、函数或者类。库是特殊的一种程序，编写库的程序和编写一般的程序区别不是很大，只是库不能单独运行。库文件有两种：静态库和动态库（共享库），区别是：静态库在程序的链接阶段被复制到了程序中，动态库在链接阶段没有被复制到程序中，而是在程序运行时由系统动态的加载到内存中提供给程序调用。库文件的好处：1.代码保密 2.方便部署和开发 2.静态库的制作 1.静态库的命名规则 linu下：libxxx.a
lib:.库文件的前缀(固定的)
xxx:库的名字，可以自己起
.a:后缀，固定windows下：libxxx.lib 2.静态库的制作与使用 1.静态库的制作 gcc获得.o文件将.o文件打包，使用ar工具(archive)
ar rcs libxxx.a xxx.o xxx.o
r：将文件插入到备存文件中
c:建立备存文件
s:索引 示例:将如下shape-test.cpp 文件编译成静态库
head.h
#pragma once #include &lt;iostream&gt; #include &lt;string&gt; extern int add(int x, int y); extern int mutil(int x, int y); extern int subtract(int x, int y); extern int div(int x, int y); add.cpp
#include "head.h" int add(int x, int y) { return x + y; } subtract.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430b809b018f7a9e70130c04ddbb0633/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238c557a4a9f90741c17c4af4692667d/" rel="bookmark">
			rabbitmq延迟队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、springboot整合rabbitmq
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; 配置文件
spring: rabbitmq: host: "192.168.100.245" port: 5672 username: "admin" password: "123" 2、队列和交换机声明
@Configuration public class TtlQueueConfig { public static final String X_EXCHANGE = "X"; public static final String QUEUE_A = "QA"; public static final String QUEUE_B = "QB"; public static final String QUEUE_C = "QC"; public static final String Y_DEAD_LETTER_EXCHANGE = "Y"; public static final String DEAD_LETTER_QUEUE = "QD"; public static final String DELAYED_QUEUE_NAME = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238c557a4a9f90741c17c4af4692667d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a93e8c16444c06dec67fb5d4aa655f28/" rel="bookmark">
			19、用 vscode 写 uni-app项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建项目：
vue create -p dcloudio/uni-preset-vue my-project 选择项目模板：默认模板
安装组件语法提示
npm i @dcloudio/uni-helper-json 导入 HBuilderX 自带的代码块
从 github 下载 uni-app 代码块，放到项目目录下的 .vscode 目录下
运行项目：
npm run serve
参考：
VSCode中如何开发uni-app？（教程分享）-VSCode-PHP中文网
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e9358ee705d198db361209dce65187/" rel="bookmark">
			python T检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		T检验通常分为三种：单样本T检验、双样本T检验、配对样本T检验原理可以参考：一文详解t检验本文主要介绍使用python实现T检验的过程，内容主要是参考这篇博文：利用python库stats进行t检验 文章目录 一、单样本T检验二、独立样本t检验（双样本T检验）三、配对样本T检验 一、单样本T检验 目的：检验单样本的均值是否和已知总体的均值相等
前提条件：
（1）总体方差未知，否则就可以利用 Z Z Z 检验（也叫 U U U 检验，就是正态检验）；
（2）正态数据或近似正态；
（3）连续变量
原假设和备择假设：
H 0 : 样 本 均 值 （ X ‾ ） 和 总 体 均 值 （ μ ） 相 等 H 1 : 样 本 均 值 （ X ‾ ） 和 总 体 均 值 （ μ ） 不 相 等 \begin{aligned} &amp; H_{0}: 样本均值（\overline{X}）和总体均值（ \mu ）相等\\ &amp; H_{1}: 样本均值（\overline{X}）和总体均值（ \mu ）不相等 \end{aligned} ​H0​:样本均值（X）和总体均值（μ）相等H1​:样本均值（X）和总体均值（μ）不相等​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04e9358ee705d198db361209dce65187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47eab68feee0e59748df2d68bce6dfd9/" rel="bookmark">
			【樱花飘落的速度是每秒5厘米】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 我们都知道，BFS的性质可以运用在边权为1的最短路求解中。
单源边权值为1的最短路(实在不行只能自己打一个模板了)
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;cstring&gt; using namespace std; const int N=110; const int INF=0x3f3f3f3f; int h[N],e[N],ne[N],idx; int n,m; int dist[N]; bool st[N]; queue&lt;int&gt; q; void add(int a,int b){ e[idx]=b;ne[idx]=h[a];h[a]=idx++; } //求编号为1的点到编号为2的点的最短距离，数据假设满足条件 int bfs(){ q.push({1}); st[1]=true; while(q.size()){ int t=q.front(); q.pop(); if(t==2) break; for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; if(!st[j]&amp;&amp;dist[j]&gt;dist[t]+1){ dist[j]=dist[t]+1; st[j]=true; q.push(j); } } } if(dist[2]==INF) return -1; else return dist[2]; } int main(){ cin&gt;&gt;n&gt;&gt;m; memset(dist,0x3f,sizeof dist); for(int i=0;i&lt;m;i++){ int x,y; cin&gt;&gt;x&gt;&gt;y; add(x,y); add(y,x); } cout&lt;&lt;bfs(); return 0; } 重点不是这个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47eab68feee0e59748df2d68bce6dfd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51d94e7db837efee61fd7e9cdbc0bda7/" rel="bookmark">
			CMake中target_link_libraries的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMake中的target_link_libraries命令用于指定链接给定目标和/或其依赖项时要使用的库或标志。来自链接库目标的使用要求将被传播(propagated)。目标依赖项的使用要求会影响其自身源代码的编译。其格式如下：
target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...) # general form target_link_libraries(&lt;target&gt; &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...) # Libraries for a Target and/or its Dependents target_link_libraries(&lt;target&gt; &lt;item&gt;...) # Libraries for both a Target and its Dependents target_link_libraries(&lt;target&gt; &lt;LINK_PRIVATE|LINK_PUBLIC&gt; &lt;lib&gt;... [&lt;LINK_PRIVATE|LINK_PUBLIC&gt; &lt;lib&gt;...]...) # Libraries for a Target and/or its Dependents (Legacy) target_link_libraries(&lt;target&gt; LINK_INTERFACE_LIBRARIES &lt;item&gt;...) # Libraries for Dependents Only (Legacy) 1.general form: 命名的&lt;target&gt;必须由诸如add_executable或add_library之类的命令创建，并且不能是ALIAS target。如果策略CMP0079未设置为NEW，则target必须已在当前目录中创建。重复调用相同的&lt;target&gt;会按调用顺序追加项目(Repeated calls for the same &lt;target&gt; append items in the order called)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51d94e7db837efee61fd7e9cdbc0bda7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841a6a87f451e4de2beeb54e5d94d7a3/" rel="bookmark">
			视觉SLAM十四讲ch4笔记——李群与李代数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 视觉SLAM十四讲ch4——李群与李代数4.1 李群李代数基础4.2 指数映射和对数映射4.2.1 s o ( 3 ) ↔ S O ( 3 ) so(3) \leftrightarrow SO(3) so(3)↔SO(3)4.2.2 s e ( 3 ) ↔ S E ( 3 ) se(3) \leftrightarrow SE(3) se(3)↔SE(3)4.2.3 小总结： s o ( 3 ) ↔ S O ( 3 ) so(3) \leftrightarrow SO(3) so(3)↔SO(3)、 s e ( 3 ) ↔ S E ( 3 ) se(3) \leftrightarrow SE(3) se(3)↔SE(3)的转换关系 4.3 李代数求导与扰动模型4.3.1 引入李代数的原因4.3.2 李代数求导方法4.3.3 小结 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/841a6a87f451e4de2beeb54e5d94d7a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bbb7f472ea28d385a0f64acc0634d20/" rel="bookmark">
			ES集群配置安全认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个ES节点的配置文件里加上：
xpack.security.enabled: true 然后重启所有ES节点，重启完成后，访问http://192.168.1.3:9200/_cat/health?v，可以看到要求输入用户名密码。而此时我们还没设置密码，下面开始设置密码：
[root@es1 ~]# cd /usr/share/elasticsearch/bin [root@es1 bin]# ./elasticsearch-setup-passwords interactive Initiating the setup of passwords for reserved users elastic,apm_system,kibana,logstash_system,beats_system,remote_monitoring_user. You will be prompted to enter passwords as the process progresses. Please confirm that you would like to continue [y/N]y Enter password for [elastic]: Reenter password for [elastic]: Enter password for [apm_system]: Reenter password for [apm_system]: Enter password for [kibana]: Reenter password for [kibana]: Enter password for [logstash_system]: Reenter password for [logstash_system]: Enter password for [beats_system]: Reenter password for [beats_system]: Enter password for [remote_monitoring_user]: Reenter password for [remote_monitoring_user]: Changed password for user [apm_system] Changed password for user [kibana] Changed password for user [logstash_system] Changed password for user [beats_system] Changed password for user [remote_monitoring_user] Changed password for user [elastic] 可以看到，我们修改了6个用户的密码，设置完成后，再次访问http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bbb7f472ea28d385a0f64acc0634d20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc76ec20689a5628c5665fd136a5f980/" rel="bookmark">
			在web编程的时候，浏览器控制台会出现加载源映射失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在web编程的时候，浏览器控制台会出现加载源映射失败的问题
DevTools failed to load source map: Could not load content for chrome-extension://cfhdojbkjhnklbpkdaibdccddilifddb/browser-polyfill.js.map:
System error: net::ERR_FILE_NOT_FOUND
原因分析：
这是因为浏览器所安装的扩展插件导致的，cfhdojbkjhnklbpkdaibdccddilifddb显示的是对应插件的ID。 解决办法：
这里以Chrom为例，找到设置里面的扩展程序，将问题显示对应的插件关闭或者删除即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a20ea695a397d3ca7dcfb5b334886aef/" rel="bookmark">
			【抓包工具】配置：Fiddler 配置手机/平板抓包 https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、fiddler 准备
二、fiddler 设置
（1）打开 Options 窗口
（2）HTTPS 设置
（3）Connections 设置
（4）fiddler 证书需安装至根证书
三、APP 抓包时的手机代理设置
（1）环境准备
（2）手机代理设置
（3）手机 fiddler 证书安装
一、fiddler 准备 查看我的另一博文 ：【抓包工具】win 10 / win 11：Fiddler 下载、安装、配置
二、fiddler 设置 （1）打开 Options 窗口 1. 点击 fiddler 的安装目录中的 fiddler.exe 文件，打开 fiddler 软件。
2. 找到 tools 菜单，选中 Options... ，单击打开 Options 设置页面。
（2）HTTPS 设置 1. 点击打开：Options → HTTPS，默认已勾选 Capture HTTPS CONNECTs 。
2. 勾选：Decrypt HTTPS traffic ；
下拉列表选择：...from all processes；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a20ea695a397d3ca7dcfb5b334886aef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bd322145d2c0cb49c2b7e6b701ad1bc/" rel="bookmark">
			excle自动查找，自动匹配数据；查找对比两个相同的但顺序错乱的表格内容。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		office高级应用 分类：excel
函数：VLOOKUP
功能：excle自动查找，自动匹配数据；查找对比两个相同的但顺序错乱的表格内容。
例1：
第一张表的内容是：姓名，年龄
第二张表的内容是：姓名（打乱了），年龄（需填写）
如果领导叫你把表二年龄填上去。.我们就可以用VLOOKUP命令快速搞定。
命令格式：=VLOOKUP(查找值，数据表，序列数，匹配条件)
查找值：就是我们需要用这个值，到其他表格里去查找，相应的值。
数据表：就是提供被查找数据的表，一般格式为（列$行：列￥行）
序列数：表示最终要显示的那一列的数据。
匹配条件：False|true，
设置好后向下拖动鼠标。
例如：
=VLOOKUP(A9,A$2:B$7,2,FALSE)
大功告成。
#####################有用点个赞呗！！！###############################
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e101d6a727d117565fa9b11820376f5/" rel="bookmark">
			Proxy与Reflect详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 现在国内的两大框架：vue、react。对于这两个框架，相信大家多多少少都接触过，对于vue而言，有一个很重要的特点，那就是响应式。vue2的响应式采用的是ES5的Object.defineproperty对数据进行劫持。而vue3则是采用ES6的Proxy对数据进行劫持。想要了解vue3的响应式就必须了解Proxy。
一、Proxy的认识 Proxy是ES6新增的，它是一个类，是用于帮助我们创建一个代理对象，如果我们需要监听对象的操作，那么我们可以通过Proxy先创建一个代理对象，之后对该对象的所有操作都通过代理来完成。他与Object.defineProperty最大的区别就在于Object.defineProperty直接监听对象的属性，proxy是监听整个代理对象。
二、Proxy的基本使用 创建一个对象
const obj = { name:'cj', age:18 } 再创建Proxy代理对象
const objProxy = new Proxy(obj,{}) 参数一：需要代理的对象 参数二：捕获器，对代理对象的属性进行访问、赋值等操作的时候触发，与Object.defineproperty的存取描述符类似。如果为空对象，就只有set、get这两个默认捕获器，并且不会有过多的操作，get捕获器就直接返回访问属性的值，set捕获器就将新的值赋值给访问属性。
示例：
const objProxy = new Proxy(obj,{}) console.log(objProxy.name) //'cj' console.log(objProxy.age) //18 objProxy.name = 'wx' objProxy.age = 20 //对代理对象操作后，代理对象就会对原对象进行操作 console.log(obj.name) //'wx' console.log(obj.age) //20 注意：Proxy只能代理对象（Object、Function、Array），非对象值无法进行代理。Proxy也只能够代理对象的基本操作，无法代理对象的复合操作。什么是基本操作？什么又是复合操作？
const obj = { name:'cj', bar(){ console.log('bar') } } const objProxy = new Proxy(obj,{}) function foo() { console.log('foo') } const fooProxy = new Proxy(foo,{ apply(){ //apply是对函数调用进行拦截 //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e101d6a727d117565fa9b11820376f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d17b2c46d7cb899f93bcb579e23b2bb/" rel="bookmark">
			详解 Intersection Observer API ( 交叉观察器 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、介绍二、兼容性三、内置方法/属性四、使用五、相关链接 一、介绍 Intersection Observer API 提供了一种方法可以监听目标元素是否展示到视口（viewport），常见的需求场景：
图片懒加载滚动动画… 上述的需求，以往一般监听 scroll 事件，利用 getBoundingClientRect()方法获取目标元素的位置信息。由于监听 scroll 事件，不断地触发回流，对性能有一定的影响，不过可以通过函数节流解决，但是 getBoundingClientRect() 方法对性能造成的影响无法有效优化的。
！！！所以，浏览器为了解决上述难题，推出了IntersectionObserver API ，由于方法是异步的，不影响主线程的执行效率。
二、兼容性 兼容市面的主流浏览器，总体来说乐观，不过为了代码的严谨，简单判断下：
if (window?.IntersectionObserver) { let io = new IntersectionObserver(callback, options) io.observe(targetElement) } 三、内置方法/属性 let io = new IntersectionObserver(entries =&gt; { // IntersectionObserverEntry 作为一个参数返回 console.log(entries) }, { root: null, rootMargin: '0px 0px', threshold: [0.5, 1] }) // 开始监听 io.observe(targetElement) // 停止监听 io.unobserve(targetElement) // 结束监听器 io.disconnect() 以上我们可以看到，IntersectionObserver 接收一个回调函数，和一个对象options作为参数。
IntersectionObserverEntry 实例作为entries参数被传递到回调函数，提供此时元素的相关信息。
查看 entries 具有哪些属性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d17b2c46d7cb899f93bcb579e23b2bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a248c87c1cda8a6a2d2d65893cef2c74/" rel="bookmark">
			Mysql进阶学习（五）连接查询（包含sql92标准和sql99标准）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql进阶学习（五）连接查询（包含sql92标准和sql99标准） 一、进阶6：连接查询（一）、sql92标准1、等值连接1.1 等值连接简介案例1：查询女神名和对应的男神名案例2：查询员工名和对应的部门名 1.2、为表起别名查询员工名、工种号、工种名 1.3、两个表的顺序是否可以调换查询员工名、工种号、工种名 1.4、可以加筛选案例1：查询有奖金的员工名、部门名案例2：查询城市名中第二个字符为o的部门名和城市名 1.5、可以加分组案例1：查询每个城市的部门个数案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资 1.6、可以加排序案例：查询每个工种的工种名和员工的个数，并且按员工个数降序 1.7、可以实现三表连接？案例：查询员工名、部门名和所在的城市 2、非等值连接案例：查询员工的工资和工资级别 3、自连接案例：查询 员工名和上级的名称 测试1测试2 （二）、sql99语法1、内连接1.1、等值连接案例1.查询员工名、部门名案例2.查询名字中包含e的员工名和工种名（添加筛选）案例3. 查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）案例4.查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）案例5.查询员工名、部门名、工种名，并按部门名降序（添加三表连接） 1.2、非等值连接案例1：查询员工的工资级别案例2：查询工资级别的个数&gt;20的个数，并且按工资级别降序 1.3、自连接案例1：查询员工的名字、上级的名字案例2：查询姓名中包含字符k的员工的名字、上级的名字 2、外连接2.1.引入：查询男朋友 不在男神表的的女神名2.2.左外连接案例：查询哪个部门没有员工 2.3.右外连接2.4.全外连接 3、 交叉连接4、本小节作业 （三）、 sql92和 sql99对比 一、进阶6：连接查询 本文设计的数据库为girls库，请提前存储
含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询
笛卡尔乘积现象：表1 有m行，表2有n行，结果=m*n行
发生原因：没有有效的连接条件
如何避免：添加有效的连接条件
分类：
按年代分类： sql92标准:仅仅支持内连接 sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接 按功能分类： 内连接： 等值连接 非等值连接 自连接 外连接： 左外连接 右外连接 全外连接 交叉连接 SELECT * FROM beauty; SELECT * FROM boys; 查询女生对应的男神名
SELECT NAME,boyName FROM boys,beauty WHERE beauty.boyfriend_id= boys.id; （一）、sql92标准 1、等值连接 1.1 等值连接简介 ① 多表等值连接的结果为多表的交集部分
②n表连接，至少需要n-1个连接条件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a248c87c1cda8a6a2d2d65893cef2c74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af6c08f753c49d4c6ddf529b3b860bb/" rel="bookmark">
			node实现文件上传(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、FormData对象：
以对象的方式来表示页面中的表单，又称为表单对象。以key-value的方式来保存数据，XMLHttpRequest对象可以轻松的表单对象发送的服务器端
​ （1）是一个构造函数：new FormData()
（2）常用的API：
​ FormData.append(key，value)：追加数据。向formdata中追加key-value
​ FormData.get(key)：获取key对应的值
​ FormData.delete(key)：删除key对应的值
​ FormData.has(key)：判断formdata中是否有key
2、node使用formidable模块实现文件上传
​ （1）安装：npm install formidable(终端输入)
​ （2）创建Formidable.IncomingForm对象：本质是一个表单对象
​ let form = new Formidable.IncomingForm()
​ （3）Formidable.IncomingForm对象的属性：
​ form.encoding ： 设置字符集
​ form.uploadDir：设置上传文件的保存路径
​ form.keepExtensions：true，表示上传时保留原来的扩展名
（4）Formidable.IncomingForm对象的方法：
​ form.parse(request, [callback])：转换请求中的表单数据
​ （5）Formidable.File对象的属性
​ size：上传文件的大小
​ path：上传文件的路径
​ type：上传文件的类型
​ name：上传的文件名
举个例子
上传图片：将图片文件上传到服务器端的指定目录将图片文件名和服务器的地址进行拼接将拼接后的图片的路径响应给客户端，在div中显示出来 ---客户端
-----服务器端
4、文件上传需要注意的问题
​ （1）前端FormData对象作用：用于保存上传文件的信息。格式：key-value
​ （2）后台formidable模块的作用：使用parse方法来解析前端的formdata对象
（3）上传过程中前后端的对应关系
二、Express实现文件下载
1、使用res对象(响应对象)的download方法即可（该方法效率低）
三、遍历下载文件夹下的文件，拼接成一个下载的url，传递到前端
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae8b857eb64c2008087ffc110a8ef8a5/" rel="bookmark">
			太硬核！用大数据技术预测足球胜率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点个关注👆跟腾讯工程师学技术
引言| 足球作为世界第一运动，充满了速度和力量的结果，团队与谋略的对抗。人们也说，足球是圆的，恰恰也表明了足球比赛的不可预知性，一切结果都皆有可能。强如巴萨，也有可能被联赛副班长逆转，弱如第三世界的朝鲜队也可闯进世界杯八强。天气、场地、球星、战术、伤病、裁判，每一个因素都可能会影响一场比赛的结果。有言道，在足球比赛里，不到最后一刻，你永远不知道事情的结果。对于足彩爱好者来说，不仅在欣赏足球荡气回肠、悬念丛生的魅力，更是在与博彩公司进行一场心理与策略的博弈（其实是为了投注赚钱）。彩民看基本面，算计博彩盘口、统计历史战绩，只希望在投注前猜中比赛结果。
伟大的福尔特博·普利迪特说过：球无假球，盘皆假盘，信息的不对称才是造成贫富差距的根本原因。在这大数据时代，能否在数据的帮助下，减少这种信息的不对称，从而成功地对足球比赛进行预测？本文从数据层面出发，通过挖掘足球比赛相关的数据特征，结合机器学习的模型方法，对足球比赛的胜、平、负结果进行预测。进一步根据预测结果指导足彩单场竞猜的投注，以期实现有效盈利，甚至是稳定盈利的投注方法。
挖掘足球比赛数据特征
构建预测模型
预测比赛结果概率（胜、平、负）
分析足彩投注策略
在使用本文提出的投注策略下，对英超2015赛季100场比赛，投注了其中20场比赛。若均为单注投注（2元一注），投注20场比赛可盈利22.18元,盈利率达到55%！下面将以2015年的欧洲五大联赛数据为例，详细地介绍如何通过数据和简单的机器学习方法，构建一个实用有效的足彩预测系统。
足彩预测 “我们可以把宇宙现在的状态视为其过去的果以及未来的因。如果一个智者能知道某一刻所有自然运动的力和所有自然构成的物件的位置，假如他也能够对这些数据进行分析，那宇宙里最大的物体到最小的粒子的运动都会包含在一条简单公式中。对于这智者来说没有事物会是含糊的，而未来只会像过去般出现在他面前。”——法国数学家皮埃尔·西蒙·拉普拉斯
1. 2. 一、数据特征 那究竟如何才能做到先知先觉，事先一窥足球比赛的结果呢？对于足球比赛，是否存在一种合理有效的预测方法，进而在足球彩票投注中实现较为稳定的盈利呢？
拉普拉斯提出的拉普拉斯妖是机械决定论的典型代表，他认为只要拥有宇宙所有力的分布和物体状态，便可以通过一个牛逼的AI去预测未来的所有，然而这样的论断被薛定谔的那只猫给否定了。拉普拉斯妖虽然有其自身的局限性，但在宏观动力学中原则上仍是适用的。就像布拉德·皮特主演的电影《MoneyBall》讲述的真实故事，一支屌丝球会通过数据分析，挖掘出合适的球员，最终组合成一支总薪金低却能与豪门洋基竞争冠军的球队。影响一场足球比赛结果的因素千千万，不管是普通球迷还是职业足球评论家都可以提出一系列的影响因子，球队排名、历史战绩、攻防数据、近期表现、主场优势、红牌裁判等等。
现有业界的足球比赛预测方法众多，下面简要介绍下常见的几种方法：
1.基于进球数预测方法。基于进球数预测的方法[1]把比赛结果的预测转化为利用泊松分布模型估计对战双方的攻防能力，进而通过进球数预测比赛最终的结果。
2.基于概率回归模型。论文[2]提出由多个不同的解释变量来组成一个概率回归模型，主要考虑球队水平、近期表现、比赛重要程度、主客队位置距离等。
3.利用贝叶斯网络进行预测。主要采用与比赛相关的主观和客观数据对贝叶斯网络的进行训练建模，进而对比赛结果进行预测。
参考多篇关于football prediction的论文，其预测比赛利用的数据主要分为两方面，一是球队基本面信息，二是公开的赔率盘口。这里的足彩预测实现主要也是考虑了这两方面的数据。
球队基本面信息 球队基本面信息由比赛双方球队在球队实力、赛前状态、对战历史、场地效应、攻防能力这五个方面组成。我们把这主队客队在这五个方面的能力量化为17维的连续特征。
赔率盘口 球队基本面信息很容易理解，而赔率盘口与足球比赛的结果有什么具体的联系呢？赔率的基本条件是概率，但又不仅仅是概率。简单来说，博彩公司对某场比赛进行一系列科学的分析和判断后，得出胜、平、负三种结果，赢面大的一方，相应的赔率自然就低，赢面小的一方，其赔率就相对的高。概率的高低并非对应最终的结果，但一旦形成市场行为，博彩公司便将概率转化为赔率去销售。公开的赔率数据为了切合市场预期和体现它的存在价值，势必要或多或少与实际比赛概率产生联系，从而去迎合大众投注心理，而最终形成的赔率则是包含着庄家市场预期值、比赛信息以及结果概率的综合体。
赔率是两支球队实力的体现
赔率基于比赛结果的基本概率
赔率融合了庄家的市场预期
可以看到，博彩公司公开的赔率本身蕴含了比赛相关的信息，但掺杂了庄家的市场期望和闲家的投注倾向，附着了许多商业利益。赔率从最初开出到比赛开始都有可能发生变化，当博彩公司获得更多的信息时，会依据球队动态和投注倾向做出一定的调整。有经验的彩民常常通过观察不同博彩公司的初始赔率以及赔率的变化来决定自己的投注。不同的比赛赔率不尽相同，赔率从初赔到终赔变化多样，而我们希望通过机器学习的方法让模型代替人去理解这其中的含义，进而预测足球比赛的结果。
二、数据的准备 这里以欧洲五大联赛的预测为示例，下面我们针对欧洲五大联赛进行数据折挖掘和准备。
针对杯赛，如欧洲杯、美洲杯、世界杯等的预测方法类似，但面临的数据问题有些许的不同，该问题将在本节最后部分做简单的讨论。
需要的数据主要有：
1.比赛的主要信息：联赛、主队、客队、比分
2.赔率信息：各博彩公司对比赛给出的欧洲赔率（胜、平、负）
通过抓取，现已获得从2010年至2015年欧洲五大联赛比赛的信息，以及17家主流博彩公司公开的赔率信息。各个联赛具体数据情况如下：
球队基本面信息特征可以通过对历史联赛积分排名以及球队参赛信息统计得到，共17维球队特征。对于赔率而言，由于每家博彩公司在开赛前给出的最终赔率并没有统一的时间标准，故现版本只采用各主流博彩公司公开的初次胜、平、负赔率，17家博彩公司共51维赔率特征。
三、预测模型 非线性模型 现有比赛数据从2010年7月27日开始累积，其中包含了五个完整的赛季以及2015年的赛季数据。以英超联赛为例，我们从前五个赛季中各随机选择55场比赛以及最新赛季的90场比赛，共365场组成测试集合，其余数据作为训练集合。比赛数据中存在一些强弱对抗且爆冷的比赛，我们认为这样的数据为奇异的样本在训练过程中进行了剔除，得到1339场的训练集合。
在线性LR模型下，英超联赛的测试集的预测准确率为38.18%，而在SVM模型下准确率提升为51.23%。SVM模型对比赛胜、平、负预测结果的预测的混淆矩阵如下：
根据英超联赛的预测结果来看，SVM模型的预测准确率比LR模型的预测准确率提高了13.05%，我们猜测非线性模型在足球比赛结果的预测上具有更好的表现。我们采用同样的训练集和测试集，尝试了多个不同的非线性模型。
由实验结果我们发现，除了法甲联赛，其他联赛在非线性模型，尤其是随机森林（RandomForest）模型上都具有较好的效果，预测准确率达到了53%以上。但是为什么唯独法甲联赛的预测准确率相对其他联赛更低呢？
从球迷的角度来看，相比其他四大联赛法甲联赛本身竞争力较低，球员中以非洲为代表的第三世界外援比例高，比赛战术性和纪律性都较弱，比赛常常依靠明星球员的个人表现。香农理论证明了熵与信息内容的不确定程度有等价关系，也就是物体的信息熵越大，混沌程度越高，其信息的不确定性就越大。对于足球比赛来说，对战双方实力越为接近，比赛结果的偶然性则越大，想要准确地预测比赛结果也就越为困难。
球队在每场比赛中的真实实力是很难去人为衡量的，在这里我们简单地把球队的联赛积分排名作为球队实力的一个衡量标准。在联赛中，根据球队积分排名的一个波动情况衡量整个联赛的混沌程度。计算方法如下：
1.根据联赛积分排名，排名第1的球队得20分，第2名的球队得19分，以此类推，第20名的球队得1分，降级球队得0分；
2.计算每支球队在近10个联赛赛季的排名方差；
3.由每支球队的排名方差的平均值计算得到联赛的混沌程度得分。
联赛混沌程度得分
由以上方法计算得到的结果可以看到，法甲的混沌程度得分远高于其他的四大联赛，和球迷在感性上的认识是一致的，这就导致了利用同样的数据信息，对法甲的预测准确率远低其它的四大联赛。
到此为止，我们在采用随机森林模型对英超联赛能取得53.42%的预测准确率，除了进一步挖掘更多的特征，还有没有方法可以进一步提高准确率呢？下面我们先来看下现有的特征在随机森林模型下对目标值的作用权重。
其中最后17维特征为球队基本面特征，其余的为赔率特征。在随机森林模型下，球队基本面特征普遍的作用权重偏低，对目标结果的影响有限，特征作用更大的主要存在于赔率特征向量中。
DNN模型 特征是机器学习系统的原材料，对模型最终的效果影响是最大的。如果原始数据可以通过合适的特征更好地表达出来，哪怕是简单的模型也可以达到更高的精度。然而特征工程是一个枯燥而费力的工作，同时要求需要有大量的经验和专业知识。对于足球比赛而言，普通球迷与专业足球分析师观察的点可能完全不一样。手工选择和处理特征很大程度上需要依靠专业经验，甚至是运气，同时需要耗费大量的时间。近年来大热的Deep learning恰好可以解决这样的问题。Deep learning的另一个名字叫做 unsupervised features learning，即非监督的特征学习方法。它最为强大的地方就在于，在包含众多隐含层的神经网络中，可以利用其中的某一层的输出当作是输入数据的另一种表达形式，能够更准确地“表达”和“理解”事物的特征，从而有效地提升预测的准确性。
传统的Neural Network在训练过程中采用back propagation的方式进行，即根据当前输出和label之间的误差，利用梯度下降法调整前面各层的参数，直至模型收敛。但在实际工程中存在明显的缺点：
1.容易收敛到局部最小值，陷入局部最优。
2.训练数据不足时，容易过拟合。
3.要求训练数据为有标签的数据。
4.训练速度慢，计算性能要求高。
为了解决多层神经网络在训练过程中存在的问题，Hinton提出了另一种训练方法，无监督逐层训练greedy layer-wise training。训练方法主要分为两大步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae8b857eb64c2008087ffc110a8ef8a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7aa5366ae0de5f5b2f8623e6e389375/" rel="bookmark">
			matlab产生FIR IP核(Xilinx)所需要的coe文件(系数文件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xilinx的FIR IP核产生的.coe文件的格式如下： radix = RADIX;
coefdata = VECTOR;
RADIX为数据进制类型，包括十进制、二进制、十六进制。
VECTOR为数据，数据以"，"为间隔进行分开，最后以"; "结尾。
下面以产生匹配滤波器的系数为例： 信号位线性调频信号，信号取反共轭（因为这里原信号为对称信号，所以只需要共轭）后得到匹配滤波器的冲激响应，取实部得到I通道的滤波器，取虚部得到Q通道的匹配滤波器，这里以Q通道的滤波器系数产生为例。
matlab代码如下：
fs = 20e6; % sample frequency 采样率 B = 4e6; T = 16e-6; %时宽 C = 3e8; K = B/T; t_wav = ([1:T*fs]-T*fs/2)/fs; wav_ref = exp(-1i*pi*K*t_wav.^2); %信号取反共轭 wav_ref = wav_ref(1:2:end); wav_ref_cos=round((2^(14-1)-1)*real(wav_ref)); %转换成定点数 wav_ref_sin=round((2^(14-1)-1)*imag(wav_ref)); %产生coe文件 fid = fopen('fir_q.coe','w'); fprintf(fid,'radix = 10;\n'); fprintf(fid,'coefdata =\n'); y=zeros(1,256); for i=1:1:160 y(i)=wav_ref_sin(i); if i == 160 fprintf(fid,'%d;',y(i)); else fprintf(fid,'%d,',y(i)); end if mod(i,8)==0 &amp;&amp; i ~= 0 fprintf(fid,'\n'); end end fclose(fid); 因为最后存入ROM的是二进制文件，所以首先将数据从浮点数转换成定点数，N_ADC为数据的位数，M_ADC为数据的个数，为了使数据更加直观，coe文件中一行有8个数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7aa5366ae0de5f5b2f8623e6e389375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7630148777e48d95a7fe1145af0de51b/" rel="bookmark">
			Unity鼠标显示的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示鼠标 //锁定鼠标后再解锁，鼠标将自动回到屏幕中心
Cursor.lockState = CursorLockMode.Locked;
Cursor.lockState = CursorLockMode.None;
//显示鼠标
Cursor.visible = true;
隐藏鼠标
//锁定鼠标后再解锁，鼠标将自动回到屏幕中心
Cursor.lockState = CursorLockMode.Locked;
Cursor.lockState = CursorLockMode.None;
//显示鼠标
Cursor.visible = true;
有的时候你会发现设置显示鼠标也没有，这时候你要看是否在其他地方读取鼠标输入然后顺手隐藏鼠标了，比如第一人称游戏，通过读取鼠标移动来旋转视角，这种时候一般会隐藏鼠标。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc2865a3c59c7b00ba8e477f2c02cc6/" rel="bookmark">
			java关于地图经纬度的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，坐标体系 wgs坐标系是国际上通用的坐标系，也称地球坐标系，gps和北斗系统都使用的是wgs坐标系。谷歌地图使用的是wgs坐标系（中国部分除外），openstreetmap使用的也是这种坐标系
gcj02坐标系是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系，也称火星坐标系，谷歌中国地图、搜搜中国地图、高德地图采用的是GCJ02地理坐标系。
BD09坐标系：即百度坐标系，GCJ02坐标系经加密后的坐标系，由百度公司独创，百度地图使用的就是这个坐标系。
应用中大多使用wgs坐标系，我们在计算经纬度的时候，使用wgs坐标系。
二，坐标计算 引用jar包
&lt;dependency&gt; &lt;groupId&gt;org.gavaghan&lt;/groupId&gt; &lt;artifactId&gt;geodesy&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; 以下计算使用的都是WGS84坐标系
1，计算两点坐标的距离
2，已知其中一点坐标、角度方向、距离，计算另一点坐标
这里的角度方向就是上图中的a角，正北方向是0，正东方向是90
public class JingWeiDuTest { public static void main(String[] args) { //计算两点坐标的距离 getDistance(114.008919919000230, 22.727150549443284, 114.008919967000230, 22.727150537443284,3); //已知起点坐标、角度方向、距离(示例3.2mm)，计算另一个坐标的经纬度 getGlobalCoordinates(114.008919919000230, 22.727150549443284, 90, 0.0032); } /** * 根据经纬度，计算两点间的距离、方位、反方位 * @param longitudeFrom 第一个点的经度 * @param latitudeFrom 第一个点的纬度 * @param longitudeTo 第二个点的经度 * @param latitudeTo 第二个点的纬度 * @param accurate 保留小数点几位 */ public static void getDistance(double longitudeFrom, double latitudeFrom, double longitudeTo, double latitudeTo,int accurate) { GlobalCoordinates source = new GlobalCoordinates(latitudeFrom, longitudeFrom); GlobalCoordinates target = new GlobalCoordinates(latitudeTo, longitudeTo); //创建GeodeticCalculator，调用计算方法，传入坐标系、经纬度得到GeodeticCurve，用GeodeticCurve获取距离、方位、反方位 GeodeticCurve geodeticCurve = new GeodeticCalculator().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bc2865a3c59c7b00ba8e477f2c02cc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b03ab2da4a0d4e9ab62723004ad32a8/" rel="bookmark">
			Minio报“SignatureDoesNotMatch”异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、场景
二、直接通过内网进行访问文件（完美）
三、通过Nginx代理访问（扑街）
异常信息
四、我的解决方式
成果
一、场景 为MinIO Server设置Nginx代理，于是根据minio中文网站的教程进行部署。
为MinIO Server设置Nginx代理 | Minio中文文档
错误时Nginx的配置
二、直接通过内网进行访问文件（完美） 三、通过Nginx代理访问（扑街） 异常信息 &lt;Error&gt;
&lt;Code&gt;SignatureDoesNotMatch&lt;/Code&gt;
&lt;Message&gt;
The request signature we calculated does not match the signature you provided. Check your key and signing method.
&lt;/Message&gt;
&lt;Key&gt;
topic/admin/6315e4be-bf46-41a5-b12f-0f21f9abffb7蘑菇.JPEG
&lt;/Key&gt;
&lt;BucketName&gt;pybbs&lt;/BucketName&gt;
&lt;Resource&gt;
/pybbs/topic/admin/6315e4be-bf46-41a5-b12f-0f21f9abffb7蘑菇.JPEG
&lt;/Resource&gt;
&lt;RequestId&gt;172CEDF3D4379A1F&lt;/RequestId&gt;
&lt;HostId&gt;558e9c66-8741-4e97-9e42-ce8bb05401e9&lt;/HostId&gt;
&lt;/Error&gt;
四、我的解决方式 成果 原因：不详，如果哪位顿悟了，记得留言给我！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1c9bb224f406d5d67f61abe1cf4cec/" rel="bookmark">
			Ubuntu 20.04 server永久关闭swap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一
编辑/etc/fstab ，sudo vim /etc/fstab，找到如下行
找到/dev/disk/by-uuid/28b306c5-92e4-4180-966d-cdedfbce3a4d /boot ext4 defaults 0 1
修改为如下图，并(/swap.img none swap sw 0 0) 将如下行注释，即在行首添加#
重启系统并验证
sudo swapon --show 方法二：
首先检查是否启用了Swap分区：
sudo swapon --show
如果启用了Swap分区，会看到Swap分区文件的路径及其大小。
也可以通过free命令进行检查：
free -h
如果启用了Swap分区则会显示Swap分区的总大小和使用情况。
运行以下命令以禁用Swap分区
sudo swapoff -a
然后删除Swap分区文件：
sudo rm /swap.img
接下来修改fstab文件，以便在系统重新启动后不会重新创建Swap分区文件。 注释或删除/etc/fstab的：
/swap.img none swap sw 0 0
再次运行sudo swapon –show检查是否已禁用，如果禁用的话该命令应该没有输出。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/202/">«</a>
	<span class="pagination__item pagination__item--current">203/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/204/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>