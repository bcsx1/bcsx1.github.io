<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e00b61dd7676a08ee0590b98424293e/" rel="bookmark">
			vsomeip用例不能连接/tmp/vsomeip-0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.
2021-10-30 11:52:51.308093 [info] Parsed vsomeip configuration in 0ms
2021-10-30 11:52:51.309115 [info] Using configuration file: "/etc/vsomeip.json".
2021-10-30 11:52:51.309454 [info] Configuration module loaded.
2021-10-30 11:52:51.309645 [info] Initializing vsomeip application "World".
2021-10-30 11:52:51.309885 [info] Instantiating routing manager [Proxy].
2021-10-30 11:52:51.310282 [info] Client [ffff] is connecting to [0] at /tmp/vsomeip-0
2021-10-30 11:52:51.310622 [info] Application(World, ffff) is initialized (11, 100).
2021-10-30 11:52:51.311284 [info] Starting vsomeip application "World" (ffff) using 2 threads I/O nice 255
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e00b61dd7676a08ee0590b98424293e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80be6033754f7ab686112ba953fc803/" rel="bookmark">
			js 图片url转文件格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
由于项目需求，需要将图片 url 转成文件格式上传到服务器，百度过后，发现大多都是将 url 利用 canvas 转成 base64，再转成文件格式，这里存在一个跨域问题，需要图片那边的服务器允许跨域才可以。
话不多说，上代码：
handleImportFile() { let img = "https://img.alicdn.com/imgextra/i2/35353105/O1CN01t6ic7y1Yo8UtlM9ah_!!0-saturn_solar.jpg_468x468q75.jpg_.webp";//这里是淘宝上随便找的一张图片 let _ = this let imgRes _.getBase64(img, (dataURL) =&gt; { imgRes = _.dataURLtoFile(dataURL,'xxx.jpg'); console.log(imgRes) }); }, getBase64(url, callback) { //通过构造函数来创建的 img 实例，在赋予 src 值后就会立刻下载图片，相比 createElement() 创建 &lt;img&gt; 省去了 append()，也就避免了文档冗余和污染 var Img = new Image(), dataURL = ""; Img.src = url + "?v=" + Math.random(); // 处理缓存,fix缓存bug,有缓存，浏览器会报错; Img.setAttribute("crossOrigin", "Anonymous"); // 解决控制台跨域报错的问题 Img.onload = function () { //要先确保图片完整获取到，这是个异步事件 var canvas = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b80be6033754f7ab686112ba953fc803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72372ba79f43112c99524a47cdbffdc0/" rel="bookmark">
			使用和风天气接口获取天气信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中使用到了获取天气相关信息，这里我使用了和风天气接口来实现此功能
和风天气接口API：API开发文档 | 和风天气开发平台
一：获取实时天气 1：接口地址 商业版：https://api.qweather.com/v7/weather/now?
开发版：https://devapi.qweather.com/v7/weather/now?
2：请求参数 key：用户认证key
location：需要查询地区的经纬度(经度,纬度)
3：返回数据 // 北京实况天气 // 商业版 https://api.qweather.com/v7/weather/now?location=101010100&amp;key=你的KEY // 开发版 https://devapi.qweather.com/v7/weather/now?location=101010100&amp;key=你的KEY { "code": "200", "updateTime": "2020-06-30T22:00+08:00", "fxLink": "http://hfx.link/2ax1", "now": { "obsTime": "2020-06-30T21:40+08:00", "temp": "24", "feelsLike": "26", "icon": "101", "text": "多云", "wind360": "123", "windDir": "东南风", "windScale": "1", "windSpeed": "3", "humidity": "72", "precip": "0.0", "pressure": "1003", "vis": "16", "cloud": "10", "dew": "21" }, "refer": { "sources": [ "Weather China" ], "license": [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72372ba79f43112c99524a47cdbffdc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9826c82070652c2bed4eb5474a119947/" rel="bookmark">
			【Mysql】Can‘t connect to MySQL server on ‘localhost:3306‘ (10061) 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想启动Mysql连接时遇到了这个报错信息，可能是Mysql服务没有启动。
解决方法 win+R打开命令行输入 services.msc进入服务管理在服务中寻找Mysql服务，找到并打开
方法二 以管理员运行cmd输入下方命令 net start mysql 在我解决过程中，并没有在服务管理页面找到mysql服务，如果你也和我一样，按照下面的步骤来就可以了。
以管理员运行cmd进入Mysql文件夹下的bin目录，输入以下命令 mysqld.exe install 安装成功
这个时候再进入服务管理就可以看到Mysql服务了，点击启动即可
如果解决了你的问题，点个赞吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d006e65f04356732db81760a414f3cc/" rel="bookmark">
			Android sdkmanager not found. Update to the latest Android SDK and ensure that the cmdline-tools are
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android sdkmanager not found. Update to the latest Android SDK and ensure that the cmdline-tools are installed to resolve this.
解决方案：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e24eb0a6374331a99310cdf80c190296/" rel="bookmark">
			【算法入门】递归计算年龄 C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		递归计算年龄 有五个人围坐在一起，问第五个人多大了，他说标的四个人大2岁；问四个人多大了，他说比第三个人大2岁，依次类推，前一个人始终比后一个人小2岁，已知第一个人10岁，求第n个人的年龄。
要求：利用递归
输入：第几个人 n
输出：此人年龄
分析： 按照写递归的思路，先找简单逻辑关系，再设定一个递归出口。
第一个人10岁。（出口）第二个人起比第一个人大2岁，以此类推。（关系式） #include &lt;stdio.h&gt; int s(int n) { int age; if(n==1) age=10; //出口 else if(n!=1){ age=s(n-1)+2;//第二个人比前一个人大两岁 } return age;	} int main(){ int m; scanf("%d",&amp;m); printf("%d",s(m)); return 0; } 运行结果如下：
总结：这道题作为一道递归基础题目可按照写递归程序的基本方法解出。先设定递归出口，再找出重复的逻辑关系式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0329ee0d42fad3a405000a1fd90c51/" rel="bookmark">
			总结一下前端实现水印的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天项目中要给页面添加水印,在这里总结下实现水印的方法
1:给图片增加水印(react版本的水印组件) svg方式,无dom的插入操作
import React, { useEffect, useState } from 'react'; export default function WaterMark(props) { // 获取水印数据 const { blogName, age } = { blogName: 'superTiger', age: 22, }; const boxRef = React.createRef(); const [waterMarkStyle, setWaterMarkStyle] = useState('180px 120px'); const [isError, setIsError] = useState(false); const { src = '//hbimg.huabanimg.com/4148fde6995768d0370232e775a9b050c2b9c5ccdbe7-hfuvQn_fw658/format/webp', text = `${blogName}-${age}`, } = props; // 设置背景图和背景图样式 const boxStyle = { backgroundSize: waterMarkStyle, backgroundImage: `url("data:image/svg+xml;utf8,&lt;svg width=\'100%\' height=\'100%\' xmlns=\'http://www.w3.org/2000/svg\' version=\'1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd0329ee0d42fad3a405000a1fd90c51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65656cca2f39ae72b93a92212818543a/" rel="bookmark">
			阻止浏览器默认事件【单按键、组合键】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单按键禁用 document.onkeydown = function (e) { var ev = window.event || e; var code = ev.keyCode || ev.which; // 禁止F5刷新 if (code == 116) { if(ev.preventDefault) { ev.preventDefault(); } else { ev.keyCode = 0; ev.returnValue = false; } } } 组合键禁用 将此函数放在mounted或者created中，可以实现对整个页面的监听。模拟组合键，设置多个code。
keyCodeForEvent() { // let self = this; let code = 0; let code2 = 0; document.onkeydown = function (e) { let evn = e || event; let key = evn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65656cca2f39ae72b93a92212818543a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096dadbf92f0b6a04e504abe357da6ed/" rel="bookmark">
			如何给node_module中的包打补丁?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中遇到个问题,需要修改源码才能解决
现在一般如下解决方案:
fork别人的代码到自己仓库，修改后，从自己仓库安装这个插件。下载别人代码到本地，放在src目录，修改后手动引入。提issue或者mr，等待作者修改 这三种方案都比较暴力以及繁琐，都不是最优解
最优解：patch-package 1.安装patch-package npm install patch-package --save-dev
或者
yarn add patch-package postinstall-postinstall(npm安装不需要postinstall-postinstall依赖)
2.修改package.json文件,增加命令 "postinstall": "patch-package"
3.修改node_modules中源码 稍后举有栗
4.手动执行命令创建补丁文件 npx patch-package package-name
至此: 补丁文件生成了，根目录下面会多一个文件夹：patches
文件下面是以package-name + version 命名的文件
例子说明：鲁大师源码来一波 这里修改loadsh.cloneDeep
使用cloneDeep 找到cloneDeep在node_modules中的源码部分并修改 页面呈现 开始打补丁 运行`npx patch-package lodash`
出现这句话就说明打补丁成功了
查看补丁 根目录下面多出一个文件夹
还原源码修改 npx patch-package
源码还原之后,发现我们添加的输出依然存在,说明我们给鲁大师补丁成功了
至此：就是给源码打补丁
注意：
patch是锁定版本号的，如果升级了版本，patch内容将会失效，所以要锁定package.json中的版本号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f64fd8c6caa6cc35ae8cc43a5af489/" rel="bookmark">
			CANTATA 9.5版本正式发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年十一月，Cantata 9.5发布。此版本扩展了代码变更管理的能力，提供了新的变更影响分析，有利于更加有效的变更测试；增加了非Eclipse环境的新建工程；安装方式由之前的运行安装程序改为tar/zip安装包。
新的工程向导
对于那些使用非Eclipse环境工具链构建的代码来说，在Cantata中建立Eclipse测试工程是比较耗时的事情。用户不得不需要在Eclipse工程中设置他们本来的工具链，由于往往缺少头文件路径、预处理宏等原因，此过程要重复多次构建-设置-构建的步骤。
Cantata 9.5通过一个新的Cantata Testing Project向导自动化完成上述准备工作，该向导自动检测和导入构建系统的设置，支持如下工具链：
CMake
GreenHills MULTI
IAR Embedded Workbench
Keil uVision
Make
Microsoft Visual Studio
NXP CodeWarrior Development Studio
从非Eclipse环境导入的头文件路径和预定义宏能在标准的工程属性中看到。
新的变更影响分析
之前版本现存的Cantata Code Change Analysis功能被Cantata 9.5中新的Impact Analysis替代，功能得到增强，为代码变更确认和基于变更的测试提供完整的解决方案。
作为更有效的回归测试策略，基于变更的测试的概念是，对那些发生了变化的代码或者构建方式发生变化的代码，只执行测试的一个子集。
当代码变更时，找到受其影响的Cantata单元和集成测试并且仅仅运行这一部分测试，此种能力大大提高了确保没有引入回归错误的时间效率。当工程师想要快速验证代码变更或构建选项的变更没有引入回归错误时，或者在持续集成过程中代码分支被检入时快速执行适当的测试时，此功能是非常有效的。
Cantata 9.5为单元或集成测试的所有部件使用了一个内置的Checksum，对任意给定的测试，它是唯一的。这些部件包括Cantata测试脚本、脚本包含的任何测试数据头文件、被测代码及其头文件、以及Cantata Makefile和用于构建测试的Cantata选项。测试的每一次运行，这些测试部件的资产和唯一的Checksum都会更新。这是一种综合的受控的测试基线，它允许识别所有收到影响的Cantata测试，无论哪一个变更对其产生影响。
这种影响分析允许定期执行持续集成样式的构建，而无需每次完全重新运行每个测试。回归测试由此成为基于变更的测试。Cantata 9.5的另外一个增强是，只重新运行之前失败的测试，允许进一步完善有效的回归测试策略。
除了所有测试可执行输入组件都由唯一哈希标识外，测试执行结果也同样由Checksum控制。除了支持影响分析和基于变更的测试外，这意味着Canta测试的所有元素都提供了测试状态的安全证据，以符合管理生命周期数据的安全标准要求。
Cantata 9.5测试组件由校验和唯一锁定，用于影响分析和测试证据安全
内置的目标部署库
Cantata 9.5增强了目标部署编辑器的功能，包含了新的Deployment Resources组件。这个数据库包含数千个Cantata目标设置选项，用于交叉编译器、芯片架构、内存设置、语言扩展等。这个库是从数百个在QA Systems注册的完整Cantata目标部署中创建的。在未来的每个版本中，此库都将使用所有已注册的Cantata目标部署的新设置进行更新，以便所有用户都能从使用Cantata的嵌入式平台配置不断增长的安装基础中获益。
可以在树状视图中浏览目标设置选项，也可以通过内置库直接匹配和选择每个选项的上下文，以了解在以前的目标部署中如何成功配置该特定选项。
这个新的内置库与部署编辑器工作流的各种改进相结合，使用户在更新其构建工具链或执行环境或创建其变体时，可以轻松地维护现有提供的Cantata目标部署。
新的Zip/Tar安装
在以前的版本中，安装Cantata时使用InstallAnywhere安装程序偶尔会面临来自用户防火墙和防病毒软件的限制。此外，安装程序修改的Windows环境变量可能会无意中影响用户的其他工具。Cantata 9.5通过将安装程序替换为单个.zip（适用于Windows）或.tar.gz（适用于Linux）存档文件以供用户提取，从而解决了这些问题。这种新方法还提供了更快地将Cantata安装到Dockers和虚拟机中，以支持自动连续集成和并行回归测试。
更新了平台支持版本
Cantata的每个版本都有支持平台的变化。
Cantata紧密地与Eclipse®的IDE环境以及Eclipse-Ready®插件集成。
Cantata 9.5建立在Eclipse 2019-12版本（Eclipse 4.14）上，也可以作为从Luna（4.4）版本直到Eclipse 2021-03（4.19）版本的Eclipse-Ready插件来安装。
在Windows上支持Microsoft Visual Studio 2017和GCC 8.2版本，在Linux上支持GCC 11.2版本。
更多详情请访问http://qa-systems.cn/，或发送邮件至 contact@watertek.com 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f64fd8c6caa6cc35ae8cc43a5af489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3fb1d64c0bebe56e6bb9fadce3ec5a5/" rel="bookmark">
			常见验证码漏洞总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0X00 介绍
0X01 验证码分类
0X02 常见验证码漏洞
0X03 修复建议
0X00 介绍 验证码（CAPTCHA）作为人机区分的手段，在计算机安全领域发挥着不可小觑的作用。缺少验证码，攻击者可通过暴力破解的方式非法接管用户账户，或对网站进行任意用户注册等。设置验证码就是为了防止自动化攻击，但是如果没有设计好的话就形同虚设，所以了解验证码的原理及产生漏洞的原因有助于更加全方位的提高网站的安全指数。
验证码的机制原理：
Step1：客户端发起请求。
Step2：服务端响应并创建一个新的SessionID同时生成随机验证码。
Step3：将验证码和SessionID一并返回给客户端。
Step4：客户端提交验证码连同SessionID给服务端。
Step5：服务端验证验证码同时销毁当前会话，返回给客户端结果。
0X01 验证码分类 1.1 图片验证码
目前最常见的验证方式，通过在图片上随机产生数字、英文字母、汉字或者问题，一般有四位或者六位验证码字符。通过添加干扰线，添加噪点以及增加字符的粘连程度和旋转角度来增加机器识别的难度。但是这种传统的验证码随着OCR技术的发展，能够轻易的被破解。
1.2 手机短信验证码
通过发送验证码到用户手机进行验证是否为本人操作。大型网站尤其是购物网站，都提供有手机短信验证码功能，可以比较准确和安全地保证购物的安全性，验证用户的正确性，是最有效的验证码系统。某些验证码接入商提供手机短信验证码服务，各网站通过接口发送请求到接入商的服务器，服务器发送随机数字或字母到手机中，由接入商的服务器统一做验证码的验证。
1.3 行为式验证码
是通过用户的某种操作行为来完成验证。例如：拖动式验证码、点触式验证码和旋转式验证等。
拖动式验证码：类似于手机的滑动解锁，根据提示用鼠标将滑块拖动到指定的位置完成验证。 点触式验证码：同样根据文字提示，点击图片中与文字描述相符的内容完成验证。
旋转式验证：用户需拖动图块将图片旋转还原为正确，方可完成验证。适用于对安全要求非常高的业务场景。 1.4 语音验证码
是通过语音电话直接呼叫用户手机或固定电话播报验证码，解决短信验证码到达率及政策性问题。常用于网站、移动客户端、银行金融等用户身份验证，以及支付确认等安全性要求更高的即时服务。
1.5 视频验证码 是验证码中的新秀，视频验证码中随机数字、字母和中文组合而成的验证码动态嵌入MP4，flv等格式的视频中，增大了破解难度。验证码视频动态变换，随机响应，可以有效防范字典攻击、穷举攻击等攻击行为。
0X02 常见验证码漏洞 2.1 漏洞的形成
目前大多数的验证码漏洞形成总结起来两点，验证码生成机制或验证机制存在缺陷引发的问题。
2.2 通用设计缺陷
2.2.1 验证码无效
有验证码模块，但验证模块与业务功能没有关联性，此为无效验证，无论输入什么都判断验证码正确，形同虚设。这种情况非常少，一般在新上线的系统中或者一些小站点比较常见。
2.2.2 验证码由客户端生成、验证
验证码由客户端js生成并且仅仅在客户端用js验证，通过抓包看是否有验证码字段或者是关闭js看能否通过验证。
2.2.3 验证码有回显
验证码在html或COOKIE中显示，或输出到response headers的其他字段，可被直接查看。
2.2.4 验证码固定
也叫验证码重复使用(重用)。是指验证码没有设使用期限，在验证码首次认证成功后没有删除session中的验证码，使得该验证码可被多次成功验证，从而造成危害。
Eg：填写正确登录信息和验证码然后抓取提交数据包，重复提交该数据包，登录成功则存在验证码重复使用问题。 2.2.5 验证码可爆破
服务端未对验证时间、次数作出限制，存在爆破的可能性。简单的系统存在可以直接爆破的可能性，但做过一些防护的系统还得进行一些绕过才能进行爆破。 burpsuite对纯数字验证码爆破时间估计：
对于4位纯数字验证码：从0000~9999的10000种可能用多线程在5分钟内跑完并不是很难。 对于6位纯数字验证码：六位数的验证码1000000位，单从爆破时间上来看就比4位数的多100倍。
2.2.6 验证码可猜测
由于验证码设置比较简单，可能只有数字或字母组成，也可能是其设定范围有限，导致验证码的数量一共就那么几个，内容可以被猜测。经常出现在图片验证码问题集场景。
2.2.7 验证码可绕过
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3fb1d64c0bebe56e6bb9fadce3ec5a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e878b50d97e98351ea791b6f713eae29/" rel="bookmark">
			virtualbox打开镜像失败The VirtualBox Linux kernel driver is either not loaded or not set up correctly.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考dpkg:处理软件包 xxx (--configure)时出错_郑斌的博客-CSDN博客 已解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd072c45caf064f17f1757d18cfec238/" rel="bookmark">
			安装kali linux虚拟机网络与主机桥接无法上网的问题以及在安装与选择时发生卡顿以及ssh远程控制与连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kali安转与选择时卡顿的原因是，安装解压的数据量太大，电脑硬件支持不了，有两种方法解决
1.减少选择的安装软件包，最后一行large是大量的软件包，有很多用不到的，可以取消勾选
2.不使用镜像ios文件安装虚拟机，而是直接下载导入kali的虚拟机，步骤如下：首先进入kali官网（kali千万要在官网上下载，其他很多盗版都存在后门，黑客被黑就很搞笑），以下是官方网站，然后点击virtualization,选择你所安装好的虚拟机，我这里下载的是vbox的，下载好直接打开ova文件就可以了，省去了ios镜像导入和配置的步骤还是很方便的，但是默认下载安装的是英文版本的,所以需要再对kali进行中文化（kali中文化看我上一个文章2021版kali linux中文化教程）。
下面开始进行kali的ssh远程控制，
首先开始对kali进行网络配置，net是最简单的网络配置（属于单向的，依赖于主机的网络，主机不能对虚拟机通信，kali和主机共享一个ip，要是没有对xshell或ssh的使用，可以选择net）
想要使用xshell控制kali的就要使用桥接（桥接是双向的，虚拟机有自己的独立ip可以设置静态ip，桥接时虚拟机或者主机没有网络的情况，1。主机有网，虚拟机桥接之后没有反应，kali终端输入ifconfig，查看ip网络发现没有网，其他各个配置都没有问题，因为在学校校园网下以及许多公网下对网络都会有限制，只是你开手机热点给主机，然后再ping主机的IP地址，发现已经可以进行传输。我就是因为这个原因找了好久的原因，一年前桥接linux就遇到这种情况，最后怀疑是电脑太辣的问题hh。2主机ping不通百度，连不上网，但是桥接的kali能上网，让我很头疼，最后发现我的网络代理打开了，将它关闭就可以上网了，这里很懵，提一个问题希望大神解答：ssh需要用到代理吗，为什么我的代理在ssh之后会自动打开。我用过在抓包和爬数据时使用代理，并且抓包代理是自动打开的，爬虫是挂载vpn代理上对网站爬取，ssh会自动开启代理就不懂了。）
最后是ssh远程控制
首先下载apt源，用源安装apt install ssh，安装完系统重启systemctl，命令启用systemctl enable ssh ，写不下去了，甩个链接去看吧，Kali Linux开启ssh服务设置自启_卿's Blog-CSDN博客
桥接和主机模式
桥接ip都要在同一个网段（局域网）否则虚拟机ping不通，主机模式相当于虚拟机也是独立的电脑，有自己的网段ip。net转换模式就不用再说了吧。
mac的ssh连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe9d0d015524183bc8f42b631c5d066/" rel="bookmark">
			全基因组haplotype基因型分析软件：GHap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，emm，”G“是”Genome-Wide"的缩写。
R语言 GHap 包用于从"定相后（phased）的SNP数据"构建全基因组haplotype，及对其频率、基因型等进行分析。Haploview和Plink等软件可以分析haplotype block，但似乎无法输出各个样本的haplotype基因型，也就无法进行很多下游的分析，如基于haplotype-based GWAS，GHap包填补了这个空白。
对Haplotype的定义方法有很多，常用的方法有以下两种：
使用LD进行定义，参考 ”Gabriel S B, Schaffner S F, Nguyen H, et al. The structure of haplotype blocks in the human genome[J]. Science, 2002, 296(5576): 2225-2229“
使用滑窗(sliding-windows)进行定义，有固定的也有可变长度的，有重叠的也有非重叠的。
还有其它，如用diversity进行定义的方法。
具体哪种方法更好，没有定论，但总的认为都比单SNP能提供更多的信息，即作关联分析（GWAS）或基因组选择（GS）的power更高。
参考：
Lorenz A J, Hamblin M T, Jannink J L. Performance of single nucleotide polymorphisms versus haplotypes for genome-wide association analysis in barley[J]. PloS one, 2010, 5(11): e14079
安装 library(BiocManager) BiocManager::install('GHap') 使用 输入文件格式 需要三个文件，后缀分别为.samples,.markers,.phase。
因为从V2.0开始，软件要先转换为二进制，所以最好文件前缀一致，方便后续操作，如：test.samples, test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe9d0d015524183bc8f42b631c5d066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2acf4ebfff288f1f94137ce2e8ff0f2c/" rel="bookmark">
			微信小程序组件的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目开发中组件的封装可以减少代码的重复率，简化页面的逻辑与代码的整洁，没人会喜欢一个两、三千行的代码文件，难开发不说，维护起来更加困难，对下个开发者来说，不敢更改之前“复杂的代码”，只会越改越多，第三个开发者就“*，**，***”。然而，如果你封装了一个两千行的组件，那你还不如写一个三千行的文件，二者没有任何区别。组件，何为组件，组件就是给开发者带来遍历的模块，我们可以理解为组件就是一个外部“纯粹”的页面，我们可以在需要的地方引用他，给他传值，他便会返回我们所需要的值，“纯粹的组件”----传事件或者值，返回相对应的值，没有复杂的逻辑，如果你在一个组件中带有非常复杂的逻辑，那么你的组件复用率只会越来越低，变的难以维护。避免前人写代码后人骂的情况发生（虽然都会挨骂，哈哈哈，我都有时候自己骂自己写的什么玩意。）。
一、微信小程序组价（详解）
这是一个弹窗组件大家也可以拿去用
wxml文件
//wxml部分 &lt;view class="mask"&gt; &lt;view class="success" style="top:{{top}}"&gt; &lt;view class="success_a"&gt; &lt;view wx:if="{{people}}"&gt;收货人：{{people}}&lt;/view&gt; &lt;view wx:if="{{phone}}"&gt;手机号：{{phone}}&lt;/view&gt; &lt;view wx:if="{{address}}"&gt;地址：{{address}}&lt;/view&gt; &lt;view wx:if="{{distribution}}" class="give"&gt;{{distribution}}&lt;/view&gt; &lt;view wx:if="{{center}}" class="center"&gt;{{center}}&lt;/view&gt; &lt;/view&gt; &lt;view class="_button"&gt; &lt;view bindtap="hideDeliver" style="border-right:1px solid #E5E5E5;"&gt;取消&lt;/view&gt; &lt;view bindtap="goToDelivery" style="color: #5576AA;"&gt;确定&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; js.文件
//js文件 // pages/components/springFrame/springFrame.js Component({ /** * 组件的属性列表 */ //接收参数 properties: { people:{ type:String, value:"" }, phone:{ type:String, value:"" }, address:{ type:String, value:"" }, distribution:{ type:String, value:"" }, center:{ type:String, value:"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2acf4ebfff288f1f94137ce2e8ff0f2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0547a1c0faee59b8eb93dc86154ba6fa/" rel="bookmark">
			vue-echarts 中文版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue-ECharts Apache ECharts 的 Vue.js 组件。
使用 Apache ECharts 5，同时支持 Vue.js 2/3。 💡 注意 💡 若您准备从 vue-echarts ≤ 5 的版本迁移到新版本，请在升级 v6 前阅读 [迁移到 v6] 部分文档。没准备好的话，可以继续阅读老版本的文档。前往 → 安装 &amp; 使用 npm &amp; ESM npm install echarts vue-echarts 要在 Vue 2 下使用 vue-echarts，需要确保 @vue/composition-api 已经安装： npm i -D @vue/composition-ap 如果你在使用基于 Vue 2 的 NuxtJS，那么还需要安装 @nuxtjs/composition-api： npm i -D @nuxtjs/composition-a 然后在 nuxt.config.js 的 buildModules 选项中添加 @nuxtjs/composition-api/module。 Vue3 import { createApp } from 'vue' import ECharts from 'vue-echarts' import { use } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0547a1c0faee59b8eb93dc86154ba6fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3752d60872ffcbf7fdfc52538a8f8d70/" rel="bookmark">
			roketmq安装与启动，测试收发消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安装与启动roketmq使用RocketMQ原生API收发消息 安装与启动roketmq 安装roketmq
启动name server命令：
# 进入 rocketmq 目录 cd /usr/local/rocketmq/ # 启动 name server nohup sh bin/mqnamesrv &amp; # 查看运行日志, 看到"The Name Server boot success."表示启动成功 tail -f ~/logs/rocketmqlogs/namesrv.log 启动broker命令：
# 启动 broker, 连接name server: localhost:9876 nohup sh bin/mqbroker -n localhost:9876 &amp; # 查看运行日志, 看到"The broker[......:10911] boot success."表示启动成功 tail -f ~/logs/rocketmqlogs/broker.log 启动管理界面：
在root目录下执行
nohup java -jar rocketmq-console-ng-1.0.1.jar --server.port=8080 --rocketmq.config.namesrvAddr=localhost:9876 &amp; 访问http://192.168.64.141:8080
使用RocketMQ原生API收发消息 依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt; &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt; &lt;version&gt;4.7.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3752d60872ffcbf7fdfc52538a8f8d70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a40870c563eb1849a9138af384442a0/" rel="bookmark">
			mybatis的优缺点，理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis是什么？ mybatis是一个半自动的ORM持久层框架，内部封装了JDBC，mybatis是通过XML或注解的方式将需要执行的statement配置，支持定制化sql，存储过程以及高级映射。
mybatis的优点： 1.简单易学，容易上手（相比较于hibernate）,基于sql编程。
2.JDBC相比减少50%以上的代码量，不需要手动开启连接。
3.与各种数据库兼容。（因为他与JDBC连接数据库）。
4.提供了许多第三方插件。（分页插件，逆向工程）。
5.能够与spring很好的集成。
6.mybatis相当灵活，不会对现有程序影响，sql写在XML中，从程序代码中彻底分离出来，解除了sql与程序耦合，重用
7.提供XML标签，支持编写sql语句。
8.提供映射标签，支持对象与数据库的orm字段关系映射。
mybatis的缺点： 1.框架比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询还得自己写，工作量大，不易修改。
2.二级缓存机制不佳。
3.sql语句依赖数据库，导致数据库移植性差，不能随意更换数据库。
mybatis与hibernate的区别比喻： mybatis：机械工具，使用方便，拿来就用，但工作还要自己来作，不过工具是活的，怎么用有我自己来来决定。
hibernate：智能机器人，但研究它（学习，熟练度）的成本很高，工作可以摆脱他了，但权限于他能做的事。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b29b0d29ba68dd4c63ec20402b91fc/" rel="bookmark">
			Apollo学习笔记（13）Lattice Planner与OBVP问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是学习了深蓝科技相关课程与阅读了相关文献后，整理所得。
论文为A computationally efficient motio primitive for quadrocopter trajectory generation。
Lattice Planner算法的根本目标就是从车辆当前的位置，结合地图、定位、障碍物等信息，通过采样并搜索出一条设定的目标 cost function 值最小的一组坐标。这就和BVP问题很相像了，都是知道起始状态信息和最终信息（部分也可以），求解出满足要求的多阶曲线。如下图所示，
初始时刻为t=0，终点时刻t=T，起点终点信息知道后，目标就是找到一条五次样条曲线使得车辆在满足约束条件和目标cost方程的情况下找到一条满足的路径。设最终的样条曲线方程为
x ( t ) = c 5 t 5 + c 4 t 4 + c 3 t 3 + c 2 t 2 + c 1 t + c 0 x(t)=c_{5}t^{5}+c_{4}t^{4}+c_{3}t^{3}+c_{2}t^{2}+c_{1}t+c_{0} x(t)=c5​t5+c4​t4+c3​t3+c2​t2+c1​t+c0​
给定的初始位置和终点位置分别为a和b，则有下式，
[ a b 0 0 0 0 ] = [ 0 0 0 0 0 1 T 5 T 4 T 3 T 2 T 1 0 0 0 0 1 0 5 T 4 4 T 3 3 T 2 2 T 1 0 0 0 0 2 0 2 20 T 3 12 T 2 6 T 2 0 0 ] [ c 5 c 4 c 3 c 2 c 1 c 0 ] \begin{bmatrix} a \\ b \\ 0 \\ 0 \\ 0 \\ 0 \\ \end{bmatrix}= \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ T^5 &amp; T^4 &amp; T^3 &amp; T^2 &amp; T &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\ 5T^4 &amp; 4T^3 &amp; 3T^2 &amp; 2T &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 2 &amp; 0 &amp; 2 \\ 20T^3 &amp; 12T^2 &amp; 6T &amp; 2 &amp; 0 &amp; 0 \\ \end{bmatrix}\begin{bmatrix} c_{5} \\ c_{4} \\ c_{3} \\ c_{2} \\ c_{1} \\ c_{0} \\ \end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎡​ab0000​⎦⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎡​0T505T4020T3​0T404T3012T2​0T303T206T​0T202T22​0T1100​110020​⎦⎥⎥⎥⎥⎥⎥⎤​⎣⎢⎢⎢⎢⎢⎢⎡​c5​c4​c3​c2​c1​c0​​⎦⎥⎥⎥⎥⎥⎥⎤​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b29b0d29ba68dd4c63ec20402b91fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c2f3a6caec56e88023a87a229d8925/" rel="bookmark">
			FPGA开发技巧：Modelsim仿真.do文件详细解析 原创 特权同学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPGA开发技巧：Modelsim仿真.do文件详细解析 原创 特权同学 FPGA快乐学习 以《FPGA边码边学 视频教程》“Lesson06 分频计数器设计”中的sim102为例。 sim102的compile.do文件如下。 vlib work vmap work work #library #vlog -work work../../library/artix7/*.v #IP #vlog -work work../../../source_code/ROM_IP/rom_controller.v #SourceCode vlog -work work ../design/vlg_design.v #Testbench vlog -work work testbench_top.v vsim -voptargs=+acc work.testbench_top #Add signal into wave window do wave.do #run -all 脚本详细说明： vlib work vlib为Modelsim命令，work是一个新建的文件夹名称。该命令将在compile.do所在文件夹中新建一个名为work的物理目录。如图所示。
vmap work work vmap是Modelsim命令，后面两个work都是文件名。前面一个work是vlib命令所创建的物理文件夹名（此文件夹必须用vlib命令事先定义好，才能被引用），后面一个work表示在Modelsim的Library窗口中创建了一个名为work的库文件夹。此命令输入后，将在Modelsim的Library窗口中创建了一个名为work的库文件夹（逻辑目录），其对应的物理目录是vlib创建好的名为work的文件夹。
vmap命令输入后，如图所示。
创建work文件夹的目的，是为了后续编译的文件都可以存放在这个文件夹下，Modelsim的work Library里可以看到编译文件名称，而这些编译文件实际是存放在vlib创建的work文件夹下。
vlog -work work ../design/vlg_design.v vlog -work work testbench_top.v vlog -work是Modelsim命令。此命令编译Verilog源码，将编译得到的结果放到名为work的逻辑库里面。该命令主要用于编译设计文件、测试脚本、调用的IP核文件及其相应的仿真库文件等。
文件名称中，如果直接跟着.v文件，表示与compile.do文件同一个文件夹路径下。../表示向上一个文件夹目录。
vsim -voptargs=+acc work.testbench_top vsim是Modelsim命令，表示启动仿真。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c2f3a6caec56e88023a87a229d8925/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9defeb737dfde60ee3334cc615451ec/" rel="bookmark">
			使用 OpenCV 和 Python 从视频中快速提取帧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**更新（2020 年 7 月）：**我现在使用并建议使用Decod在 Python 中更快地加载视频。您可以进一步查看原始的 OpenCV 版本。😃
速度比较。来自Decod的 Github 页面。
下面是一个如何使用 Decod 提取帧的示例脚本。它与 OpenCV 版本有相似之处，但更快、更简洁、更简单。请注意，它根据参数使用批量收集或顺序读取来提取帧every。我已将阈值设置为25和total阈值 ，1000因为这适合我的系统的内存限制和 CPU 能力。
import cv2 # still used to save images out import os import numpy as np from decord import VideoReader from decord import cpu, gpu def extract_frames(video_path, frames_dir, overwrite=False, start=-1, end=-1, every=1): """ Extract frames from a video using decord's VideoReader :param video_path: path of the video :param frames_dir: the directory to save the frames :param overwrite: to overwrite frames that already exist?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9defeb737dfde60ee3334cc615451ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61ddacafe565e950ac83cc922ca8872/" rel="bookmark">
			Java基础：异常的概念及处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常 异常表示在程序运行中出现的错误，也就是在方法进行运算的时候出现的问题。例如运算异常或者数组下标不存在等异常。语法异常在编译时就无法通过，不属于异常的范围。
异常出现之后通常程序会停止运行并且在控制台描述异常的具体内容，Java存在容错性的特点，也就是说在程序运行中允许出现异常，并且在出现异常之后仍继续运行。
异常对象 Java将程序中可能出现的异常通过类的方式进行了描述，所有的异常都可以进行记录和抛出，所以最终极的类Throwable，表示可抛出的。
Throwable：所有异常的根类，表示可抛出的异常。 Exception：表示程序运行中因语法或运算导致的异常，这类异常通常可以避免。 RuntimeException：运行时异常，运行中才可以发生的异常，也叫未检查异常。其他异常：在编译时可以抛出的异常，进行异常的预判并让调用者察觉此异常的发生，也叫已检查异常。 Error：错误，通常指计算机虚拟机或者内存内部所发生的空间错误或其他不可预知也不可避免的异常。 异常的处理 异常的处理可以采用抛出或者捕获的方式，抛出表示将异常的处理交给调用者，当前方法内并不对异常进行处理。捕获表示在当前方法进行异常的处理，异常一旦发生时没有办法解决的，通常捕获所做的就是对异常所导致的结果的弥补。
如果语句出现了异常的抛出，那调用者就必要对其进行捕获或者继续抛出，否则将在语法上出现问题。其中RuntimeException会在程序运行中出现，所以并不能被预判，如果没有进行捕获或者抛出也是不会出现异常的。但运行时异常仍可以进行捕获或者抛出，并且也有可能会在程序运行过程中出现问题。
例如使用N除以0，这句话并不会被Java认为是一个异常，所以并不会提示这句话存在语法错误，但是在运行时就会出现运行时异常。
抛出 抛出就是将此方法中出现的异常对象抛出给调用者，由调用者感染异常并处理异常。使用关键字throws写在方法的声明上，后跟抛出的异常的对象类型，可以写多个，并用逗号分开。抛出异常并没有防范措施，也没有补救措施，是消极的处理异常方式。把解决和弥补异常的责任交给调用者。当语句出现异常后，语句下面的代码不会执行了，而是创建异常对象，向外抛出让当前程序停止。在方法上抛出异常是可以连续抛出的，多个异常对象的类型用,隔开。在调用位置处理异常的时候，也是要对所有抛出的异常进行处理的。 //抛出一个异常，空指针是Exception的子类可以多态 public static void test(Dog d) throws Exception{ d.eat();//这里的d引用很可能是一个空指针 } //在主函数上抛出异常，因为调用方法时可能会出现异常 //因为main函数是虚拟机调用的，所以此异常将抛给虚拟机 public static void main(String[] args) throws Exception { test(null);//此处可能会出现异常，以为调用的方法抛出了异常 } 在主函数中，异常在进行感染和传播的过程中并不会被解决或者捕获，而是在虚拟机中触发异常，导致程序的停止。
捕获 异常的抛出可能是因为被调用者声明了所抛出的异常，这将导致调用者需要对异常进行处理。有两种选择：将异常持续抛出直到虚拟机，这样的方式会导致程序的停止，实际上与普通的发生异常没有区别、再一种就是对被调用者出现的异常进行捕获，并做弥补措施，这可以让出现异常的语句出错而不会感染到方法内其他的代码。
首先将可能会出现异常的代码，或者调用被调用者抛出异常的调用语句放到try代码块中。将可能会出现的异常对象放到catch代码块的代码块的小括号中。当try中出现异常，创建异常的位置则创建异常对象，然后由catch进行对象的捕获并在catch代码块中做补救措施。try代码块就算是出现了异常，catch将其捕获后继续执行下面的代码，程序不会停止。如果try没有异常发生，就不会出现异常对象，catch也不会启动。（ry和catch只有一个会执行到底。捕获的方式是积极的处理异常的方式。虚拟机认为，try块和catch块都有可能执行不完，如果方法有返回值，那就要在两个代码块中都有返回。或者在try catch的外部执行返回。在进行某一语句的异常捕获时，如果此语句报出的异常为Exception类型，那极有可能是Exception子类的多态的结果。所以语句所抛出的异常类型实际以异常对象的类型为主，而不以抛出的异常的引用类型为主。 public static void main(String[] args){ try { test(null);	//可能会出现异常的语句，写在try中 } catch (Exception e) {	//出现异常后，异常对象将向e引用进行赋值 System.out.println("出现了异常");	//执行补救代码 e.printStackTrace();	//打印异常栈，显示异常出现在哪里，感染的路线 } System.out.println("执行下面的代码"); //即使上面的程序出现了异常，此处的代码也会执行 } public static void test(Dog d) throws Exception{ d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61ddacafe565e950ac83cc922ca8872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956b8fbd3b6920a7cfb16f11cfd22f16/" rel="bookmark">
			服务器修改主机名字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器修改主机名字 在ubuntu系统中永久修改主机名字，之需要修改/etc/hostname文件，在文件中输入新的主机名并保存该文件就可以。
第一步：修改/etc/hostname
sudo vim /etc/hostname
第二步 修改主机名
第三步 重启系统。
修改成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/140210100630b74b669bf7d39136298d/" rel="bookmark">
			剑指offer13题-在O(1)时间内删除链表节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、输入是val: ListNode 解法 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def deleteNode(self, head: ListNode, val: ListNode) -&gt; ListNode: if not (head and val): return False if val.next != None: tmp = val.next val.value = tmp.value val.next = tmp.next elif head == val: head = None else: node = head while node.next!=val: node = node.next node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/140210100630b74b669bf7d39136298d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0624b850547da7f9ce7a20d469766783/" rel="bookmark">
			头歌JAVA数据结构答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头歌JAVA数据结构答案 一、Java数据结构-循环链表的设计与实现
第1关 单循环链表的实现—链表的添加、遍历
package step1; /** * Created by sykus on 2018/1/15. */ public class MyCircleLinkedList { private Node head;//头结点, 不存数据 private Node tail;//尾结点, 指向链表的最后一个节点 private int size; public MyCircleLinkedList() { head = new Node(Integer.MIN_VALUE, null); head.next = head; tail = head; size = 0; } /** * 添加到链表尾部 * * @param item */ public void add(int item) { /********** Begin *********/ Node node = new Node(item, tail.next); tail.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0624b850547da7f9ce7a20d469766783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac359f0d00ce415b689a4e8d3fa1fcb/" rel="bookmark">
			http各版本简单的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一个版本：http0.9 只支持GET请求，并且不支持请求头。
只支持传输纯文本内容，不支持图片等格式文件。
第二个版本：http1.0 新增POST等请求方式，并且每次通信都要包含请求头。
不仅支持传输纯文本内容，还可以根据content-type选择多种数据格式，比如视频，音频，图片等。
新增状态码，缓存等功能。支持缓存使得在一定时间内访问同一个网站可以直接访问缓存。
缺陷：每次tcp连接后只能发送一个请求，服务器响应后就会关闭这次连接。想要再次请求数据需要再一次tcp三次握手链接，这样很消耗性能，并且随着页面东西越来越多，这个问题越来越突出。
第三个版本：http1.1 改善http1.0的缺陷：增加了持续连接，每次tcp连接后，可以一直发送请求与响应，客户端与服务器可以主动关闭连接，很大的提高了http的效率。
新增PUT、PATCH、OPTIONS、DELETE请求方式。
新增管道机制（之前请求一次之后，等待响应完成才可以下一次请求；管道机制允许多个请求同时发出，但还是会按照顺序一一响应）。
请求头信息新增Host字段，用于指定域名。
第四个版本：http2.0 头信息和数据体都必须二进制，1.1版本头信息是文本，数据体可以是二进制也可以是文本。
新增了头信息压缩机制。
新增多工机制：运用多路复用的的战术，从1.1版本的同时多请求但一一响应变为同时多请求但不用按顺序一一回应，解决了队头堵塞的问题
新增服务器推送机制：允许服务器没有收到请求就向客户端发送资源，即当我们请求部分资源时服务器可以把相关的可能用到的其他资源一起发回客户端，客户端可以存在本地，需要这些资源时可以直接访问，节省时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfcb4edfff62077d0e34ee1e791f443e/" rel="bookmark">
			分享两个个Android源码在线查看网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AndroidXRef， AOSPXRef想看哪个版本的安卓源码都可以哟！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb59853657cf866c70f52ef480a50ba/" rel="bookmark">
			JS中[感叹号]function(){}()的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这种写法，是一种`立即执行函数`的写法，即IIFE等设计模式。这种函数在函数定义的地方就直接执行了。
理解IIFE设计模式的关键是要认识到，在ES6之前，JavaScript仅具有函数作用域(因此缺少块作用域),并通过闭包内部的引用传递值。ES6之后情况已不再如此，因为JavaScript的ES6版本使用let和const关键字实现了块作用域。
(function(){})()是匿名函数，主要利用函数内的变量作用域，避免产生全局变量，影响整体页面环境，增加代码的兼容性。
(function(){})是一个标准的函数定义，但是没有赋值给任何变量。所以是没有名字的函数，叫匿名函数。没有名字就无法像普通函数那样随时随地调用了，所以在他定义完成后就马上调用他，后面的括号()是运行这个函数的意思。
如下几种写法作用是相同的:
!function () { /* ... */ }(); ~function () { /* ... */ }(); -function () { /* ... */ }(); +function () { /* ... */ }(); void function () { /* ... */ }(); (function (){/*...*/}()); (function (){/*...*/})(); 所以: !function(){}写法和(function(){})()是相同的
!function(){}()
1.函数后的();表示要执行这个函数;
2.而();要求前面必须是一个表达式。(最后有js表达式的定义)。
3.所以"!"的作用是将function(){}函数体转为一个函数表达式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92fccf73639daee6f01b92afba302d3a/" rel="bookmark">
			第五章 循环结构程序设计练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		填空题5
#include&lt;stdio.h&gt;
int main()
{
int k, x;
for (k = 0, x = 0; k &lt;= 9 &amp;&amp; x != 10; k++) {
x = x + 2;
}
printf("%d,%d", k, x);
return 0;
}
1.定义整数k,x;
2.k=0,x=0
3.判断k&lt;=9&amp;&amp;x!=10，若k&lt;=9&amp;&amp;x!=10,执行3,4,5否则转6；
4.x=x+2
5.k++
5.输出k,x的值
填空题6
#include&lt;stdio.h&gt;
int main()
{
char c;
for (c = getchar(); getchar() != '#'; c = getchar())
putchar(c);
return 0;
}
1.定义字符c
2.c = getchar()
3.判断getchar() != '#'，若getchar() !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92fccf73639daee6f01b92afba302d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c77356d9f81a4dfa26947f2b1fc668d6/" rel="bookmark">
			PyCharm大学生教育账户激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、如果你是在校大学生，注册JetBrain账号以后可以选择教育认证
免费教育许可证 - 社区支持
大学邮件地址渠道（有的学校不行）或者官方文件渠道（上传学生证或者学信网截图）
二、一周内给你反馈结果，然后你登录JetBrains账号后就可以看到教育认证了，一年申请一次
三、接下来去PyCharm里面激活
遇到一个问题，就是我下载了官方安装包，我直接点击安装包，他会有一个卸载旧版本的提示，然后我选择卸载后装了新的，结果装好后，双击PyCharm按钮，启动不了，网上资料查阅后一直没解决，最终我的解决办法是：
以管理员的方式启动命令行，输入pycharm，然后双击桌面PyCharm按钮可以启动，不过提示是管理员的模式，别人说命令行还不能关闭（但我关闭了照样还是可以启动，仍然是管理员模式）。然后我又关闭，点击激活，输入自己的JetBrains账号，自动浏览器登录，完了就授权激活成功。
最终在Help-Register里面可以看到如下结果：
备注
自己电脑一直登录不了JetBrains Account
原因是C:\Windows\System32\drivers\etc 下面的hosts文件中有一行“0.0.0.0 account.jetbrains.com” 删除掉即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177a2387f63b8f636370411a437b70b7/" rel="bookmark">
			Python如何将txt文件录入Excel表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的手头有一个写满数据的txt文件，如何将它录入Excel表格呢？
调用python中专门用于处理Excel表格的函数库 xlwt，建议大家打开CMD输入
pip3 install xlwt 检查一下是否安装了这个函数库。没安装的会自动安装。
建一个python文件，库调用，主函数，自定义函数都先写好
import xlwt def writeinexcel(): if __name__ == "__main__": writeinexcel() 打开.txt文件
import xlwt def writeinexcel(): f = open('bZhanRank.txt','r',encoding='utf-8') #打开数据文本文档，注意编码格式的影响 if __name__ == "__main__": writeinexcel() 新建一个Excel表格
import xlwt def writeinexcel(): f = open('bZhanRank.txt','r',encoding='utf-8') #打开数据文本文档，注意编码格式的影响 wb = xlwt.Workbook(encoding = 'utf-8') #新建一个excel文件 ws1 = wb.add_sheet('first') #添加一个新表，名字为first if __name__ == "__main__": writeinexcel() 进行一下预处理,用上write函数
import xlwt def writeinexcel(): f = open('bZhanRank.txt','r',encoding='utf-8') #打开数据文本文档，注意编码格式的影响 wb = xlwt.Workbook(encoding = 'utf-8') #新建一个excel文件 ws1 = wb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177a2387f63b8f636370411a437b70b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a83aafee5f26c16f0c0e809f47a389f/" rel="bookmark">
			select标签如何设置默认选中的选项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法有两种。
第一种通过&lt;select&gt;的属性来设置选中项，此方法可以在动态语言如php在后台根据需要控制输出结果。
&lt; select id = "sel" &gt;
&lt; option value = "1" &gt;1&lt;/ option &gt;
&lt; option value = "2" selected = "selected" &gt;2&lt;/ option &gt;
&lt; option value = "3" &gt;3&lt;/ option &gt;
&lt;/ select &gt;
第二种为通过前端js来控制选中的项: &lt; script type = "text/javascript" &gt;
function change(){
document.getElementById("sel")[2].selected=true;
}
&lt;/ script &gt;
&lt; select id = "sel" &gt;
&lt; option value = "1" &gt;1&lt;/ option &gt;
&lt; option value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a83aafee5f26c16f0c0e809f47a389f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/873f787b318d43b19c7f07a7bda20d40/" rel="bookmark">
			SPI通信协议详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SPI协议基本概念 SPI接口
（1）SPI（Serial Peripheral interface）是一种同步串行传输规范，也是单片机外设芯片串行外设扩展接口，该接口是一种高速，全双工，同步的通信总线，并且在芯片的管脚上占用4根线
（2）SPI接口主要应用在EEPROM，Flash，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间
（3）SPI由一个主设备和一个或多个从设备组成，主设备启动一个与从设备的同步通讯，从而完成数据的交换
（4）SPI接口由MOSI（串行数据输出），MISO（串行数据输入），SCLK（串行移位时钟），/SS（从设备使能信号），四种信号构成
（5）MOSI（串行数据输出），MISO（串行数据输入），SCL（串行移位时钟）都是公用的，只有SS（从设备使能信号）不是公用的，每增加一个从设备，那么就要增加一个SS使能信号，从而实现寻址的功能，当你的引脚不够用的时候，最好使用IIC（只有两根线）
引脚描述
MOSI：主设备数据输出，从设备数据输入
MISO：主设备数据输入，从设备数据输出
SCLK：时钟信号，由主设备产生
/SS：从设备使能信号，由主设备控制。当有多个从设备的时候，每个从设备都有一个片选接入到主设备机中，当我们的主设备和某个从设备通信时，需要将从设备对应的片选信号拉低或拉高
SPI接口特点
（1）SCLK信号线只由主设备控制，从设备不能控制信号线，同样，在一个基于SPI的设备中，至少有个主设备
（2）与普通的串行通信不同，普通的串行通讯一次连续传输至少8位数据（UART，但是还有一个起始位，一个停止位，还有校验位（可有可无）），而SPI允许数据一位一位的传送，甚至允许暂停，因为SCLK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据，也就是说，主设备通过对SCLK时钟线的控制可以完成对通讯的控制
（3）SPI还是一个数据交换协议：因为SPI的数据输入和输出线独立，所以允许同时完成数据的输入和输出。不同的SPI设备的实现方式不尽相同，主要是数据改变和采集的时间不同，在时钟信号上沿或下沿采集有不同的定义。
移位传输
在SCLK的控制下，两个双向移位寄存器进行数据交换
（4）在点对点的通信中，SPI接口不需要进行寻址操作，且为全双工通信，显的简单高效。在多个从设备的系统中，每个从设备需要独立的使能信号，硬件上比IIC系统要稍微复杂，SPI的一个缺点；没有指定的流控制，没有应答机制确认是否接收到数据
SPI的工作模式 概述
SPI通信有4种不同的模式，不同的从设备可能在出厂时就是配置为某种模式，这个不能更改，但我们的通信双方必须是工作在同一模式下，所以我们可以对我们的主设备的SPI模式进行配置，通过CPOL（时钟极性）和CPHA（时钟相位）来控制我们的主设备的通信模式：
时钟极性CPOL是用来配置SCLK的电平出于空闲态或者有效态，时钟相位CPHA是用来配置数据采样是在第几个边沿
CPOL=0；表示当SCLK = 0时，处于空闲态，所以有效态就是SCLK处于高电平
CPOL=1；表示当SCLK = 1时，处于空闲态，所以有效态就是SCLK处于低电平
CPHA=0；表示数据采样是在第1边沿，数据发送在第2个边沿，也就是奇数边沿被采样
CPHA=1；表示数据采样是在第2边沿，数据发送在第1个边沿，偶数边沿被采样
（1）起始信号：NSS信号线由高变低，是SPI通讯的起始信号
（2）借宿信号：NSS信号由低变高，是SPI通讯的停止信号
（3）数据传输：SPI使用MOSI以及MISO信号来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据，且数据输入输出时同时进行的。SPI每次传输数据可以8位或16位为单位，每次传输的单位数不受限制
通信模式的设置
由于CPOL以及CPHA的不同状态，SPI分成了四种模式，主机与从机需要工作在相同的模式下才可以正常通信，因此通常主机要按照从机支持的模式去设置
STM32F4-SPI控制器特性 STM32F4的MOSI以及MISO都连接到数据移位寄存器上，数据移位寄存器的数据来源于接收缓冲区与发送缓冲区
（1）通过写SPI的“数据寄存器DR”把数据填充到发送缓冲区
（2）通过读“数据寄存器DR”可以获取接收缓冲区中的内容
（3）其中数据帧长度可以通过“控制寄存器CR1”的“DFF位”配置为8位或16位模式，配置“LSBFIRST位”可选择MSB先行还是LSB先行
内部SPI设置 STM32F429有高达6个SPI（45Mbits/s），其SPI接口提供两个主要功能：支持SPI协议和I2S音频协议。默认情况下，选择的是SPI功能。可通过软件将接口从SPI切换到I2S。
串行外设接口SPI可与外部器件进行半双工/全双工的同步串行通信。该接口可配置为主模式，在这种情况下，它可为外部器件提供通信时钟SCLK。该接口还能够在多主模式下工作
它可用于多种用途，包括基于双线的单工同步传输，其中一条可作为双向数据线，或使用CRC检验实现可靠通信
片选接到了主控制逻辑芯片上面，主控制逻辑芯片又连接到了MOSI和MISO上面，时钟引脚接到了我们的波特率发生器上面，波特率是由SPI_CR1上面产生的，
单个主器件/单个从器件应用
主模式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/049393a1a041c2403016964b499cb231/" rel="bookmark">
			博客迁移公告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近新搭了自己的个人博客, 所以本博客将暂停更新, 近期会把一些写的自我感觉良好的文章加工修改一下搬迁到新的博客, 以及一些近期写的关于项目和源码的分析文章.
博客传送门: cu1universe.icu 欢迎来玩! 也可以把一些有意思的算法或者源码 题目也可(只不过太菜了可能不会) 发到该文章评论区, 会定期看下, 如果有时间和精力就会学习并发布到个人博客里 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9482aceda946968a0cfa184cfb50b09c/" rel="bookmark">
			Mybatis Plus 驼峰命名 Unknown column ‘last_name‘ in ‘field list‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error querying database. Cause: java.sql.SQLSyntaxErrorException: Unknown column ‘last_name in ‘field list’ mybatis Plus中查询是按照默认的驼峰命名来做实体类和数据库字段之间的映射的， 比如：
实体类中 ：usersId
驼峰转化为下划线 _
数据库中： users_id
而这个错误是由于没有按照驼峰命名的规范导致的，举例
实体类中：
private Integer usersId;
安装默认的驼峰命名规范， mybatisplus在查询的时候默认的是查询users_id, 所以数据库的字段名字应该为：users_id
如果不想进行转换， 可以直接关闭驼峰命名。
mybatis-plus.configuration.map-underscore-to-camel-case=false
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2becbb753218243615be0fe05f8cb465/" rel="bookmark">
			指针表示数组的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、一维数组及其指针表示：
一般会定义一个指针指向一个数组的首地址，定义完成之后，指针指向的地址和数组的首地址一致。
当需要通过指针表示数组具体值的时候，需要在指针前加上*，表示取该地址所存放的具体值
2、二维数组及其指针表示方式
2.1 定义指针表示二维数组
由于数组元素的地址是连续的，因此指针p连续向后取值即依次指向a[0][0]、a[0][1]、a[1][0]、a[1][1]、a[2][0]、a[2][1]，这里6=3*2;
归纳一下，arr[i][j]可以表示为*(p+i*2+j)，其中2是每行的元素个数，如：
arr[0][1] &gt;&gt; *(p+0*2+1)=*(p+1)
arr[1][1] &gt;&gt; *(p+1*2+1)=*(p+3)
arr[2][0] &gt;&gt; *(p+2*2+0)=*(p+4)
2.2 定义指针数组表示二维数组
首先，我们必须搞懂二维数组的表示方式，在一维数组（这里指int类型）中，可以把一维数组看成一行数字，二维数组呢？不就是多行数字吗？所以二维数组就是多个一维数组组成的；
比如定义一个二维数组arr[3][2]，可以看成三个一位数组arr1[2]，arr2[2]，arr3[2]，每个数组包含两个元素，对应的数组名称分别是arr1=arr[0]，arr2=arr[1]和arr3=arr[2]，这三个一维数组就是二维数组 arr 的三个元素；
在一位数组中，我们知道数组名称是数组的首元素地址，因此二维数组名称arr其实表示的是其首元素arr[0]的地址：
因此arr + i = &amp; arr [ i ]，arr [ i ] = *( &amp; arr [ i ] ) = * ( arr + i )
同理，由于arr[ 0 ]，arr[ 1 ]和arr[ 2 ]均是一维数组的名称，因此arr[ 0 ]，arr[ 1 ]和arr[ 2 ]均可表示其对应一维数组的首元素地址，也就是arr [ i ] = &amp; （arr[ i ]） [ 0 ] = &amp; arr[ i ] [ 0 ]：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2becbb753218243615be0fe05f8cb465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/040e4f3489d53ea891bfcc9920fc9e20/" rel="bookmark">
			干货总结！Kafka 面试大全（万字长文，37 张图，28 个知识点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全文总计 1.2 万字、28 个知识点。35 张原理、流程图。提纲如下：
正文 ⭐ 1、 什么是 kafka ？
Kafka 起初是由 Linkedin 公司采用 Scala 语言开发的一个多分区、多副本且基于ZooKeeper协调的分布式消息系统，现己被捐献给 Apache 基金会。目前 Kafka 已经定位为一个分布式流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用。
⭐ 2、kafka 的架构描述一下？
如下图所示：
Kafak 总体架构图中包含多个概念：
（1）ZooKeeper：Zookeeper 负责保存 broker 集群元数据，并对控制器进行选举等操作。
（2）Producer：生产者负责创建消息，将消息发送到 Broker。
（3）Broker: 一个独立的 Kafka 服务器被称作 broker，broker 负责接收来自生产者的消息，为消息设置偏移量，并将消息存储在磁盘。broker 为消费者提供服务，对读取分区的请求作出响应，返回已经提交到磁盘上的消息。
（4）Consumer：消费者负责从 Broker 订阅并消费消息。
（5）Consumer Group：Consumer Group 为消费者组，一个消费者组可以包含一个或多个 Consumer 。
使用 多分区 + 多消费者 方式可以极大 提高数据下游的处理速度，同一消费者组中的消费者不会重复消费消息，同样的，不同消费组中的消费者消费消息时互不影响。Kafka 就是通过消费者组的方式来实现消息 P2P 模式和广播模式。
（6）Topic：Kafka 中的消息 以 Topic 为单位进行划分，生产者将消息发送到特定的 Topic，而消费者负责订阅 Topic 的消息并进行消费。
（7）Partition：一个 Topic 可以细分为多个分区，每个分区只属于单个主题。同一个主题下不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的 日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的 偏移量（offset）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/040e4f3489d53ea891bfcc9920fc9e20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a89e593ab30fce4ad55092927efb2c0/" rel="bookmark">
			防抖和节流的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两者都降低事件发生的频率，防抖是将多次执行（触发）变为每隔一段触发一次，第一次触发完都清空定时器并重新计时，以此来防止屏幕产生抖动；节流是将多次执行变为每隔一段时间执行，降低执行的频率，还是会执行多次，不过不会频繁触发，用户体验会好一些，例如我们上下电梯，滚动条的滚动
结合应用场景 防抖(debounce)
input输入框搜索的时候，用户在不断输入值时，用防抖来防止屏幕抖动。
窗口大小的调整，只要调整完毕，就不会再次要求调整窗口
定时器中的防抖函数
inputEle.addEventListener("keyup", (function(e){ //这是一个自运行函数 var t = null; return function(){ //真正的事件函数在这里 clearTimeout(t); //每次触发，都把前面的定时器关闭，尽管第一次定时器并不存在 t = setTimeout(function(){ //开启新的定时器 //ajax(...); 发送请求到服务器 }, 300); } })()) 节流(throttle)
鼠标不断点击触发，mousedown(单位时间内只触发一次)，不会频繁触发，用户会觉得狠烦，比如0.5毫秒就弹框一次和0.1毫秒就弹框一次，后者看起来会好一些
监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断，慢慢的触发，向下滚动滚动条
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1719562091b54ce8d5b22ca4a33536c/" rel="bookmark">
			解决Android开发问题：Installed Build Tools revision XX is corrupted. Remove and install again using the SDK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章讲的很详细： https://zhuanlan.zhihu.com/p/393889946
在加上一步，这里也要改成相应的版本：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ca99c7235bf1aad8a22ea97084dd003/" rel="bookmark">
			Wps的两种论文标注参考文献
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.插入脚注 效果图
2.文献索引
假设是文献收集齐的这种情况，咱们第一步排序好，点击开始，进入编号。 假设咱想要这种格式的
接着选中你的文献区域去进行这个编码编辑.... 第二步，点击引用，再点击交叉引用，然后在你要标记的正文部分开始标注。
注意这里引用类型与引用内容选项一定都不要选错。
然后的到的效果是这样的
我们想把它变小弄到右上角或者右下角可以通过
咱们最终的效果图
参考资料
wps参考文献怎么标注 如何在WPS中添加论文参考文献_编号
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905ee31ec3e85783210f49b96dc3d978/" rel="bookmark">
			Anaconda中安装并运行tensorflow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Anaconda中安装并运行tensorflow 创建环境
选择自己喜欢的名字和需要的python环境进行创建
这里我创建了一个名字为tensorflow的虚拟环境，蓝色框住的地方为这个虚拟环境的路径，记住，有用的！
现在这样就是在创建中了，先别急，等等先
出现了自己创建的这个就好了，已经创建成功了下载tensorflow
在tensorflow下载官网进行下载
打开之后点击这里
出现的是这样的界面，选择自己需要的python版本的tensorflow，python版本需要与tensorflow对应，否则会导致异常甚至无法进行安装。。。
箭头指向的的是window系统版本的分别对应不同的版本python3.7选择cp37，依次类推，直接点击链接下载即可
3.进行安装
将下载好的tensorflow复制到刚刚标蓝色的地方（肯定不记得了吧），再放一下图
照着你们这个地方进去，找到这个虚拟环境的位置
这个地方就能找到你们自己刚刚创建的虚拟环境
打开你这个新建的虚拟环境（就是这个tensorflow文件夹）
然后把你刚刚下载好的tensorflow的whl文件放进去，标蓝色的地方就是我复制的。
然后复制进去之后打开自己的Anaconda Prompt
当前我的python版本是3.7.4，是anaconda自带的一个环境（base是环境的名字，此时为自带的ana环境）
激活刚刚创建的tensorflow环境 conda activate 自己环境的名字 前面就变成了刚刚创建的虚拟环境，表示环境激活成功
查看python版本
python --version 与刚刚的版本不太一致，说明达到了创建两个不同python版本的环境的目的，相同也没事，能用就行，继续往下
进入到自己虚拟环境所在的地方，现在进去这个地方之后就开始安装了
在安装之前要更新一下的pip与pip的镜像源，否则会非常非常非常的慢
更新pip
python -m pip install --upgrade pip 加入清华镜像源
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 好了，这样你的下载速度就非常的快了，如果还是很慢，那说明你要升级宽带了
现在开始安装tensorflow了
pip install tensorflow-2.7.0-cp37-cp37m-win_amd64.whl 后面的文件是你自己下载与自己python所对应的版本，注意修改为自己 的文件名字
下面很多下载包的细节就不展示了
直接上安装好的截图
这样就安装成功了
验证一下，自己的tensorflow版本是2.7.0，这就完毕了。
接下来就是使用了：
回到anaconda这里
这个jupyter notebook给安装一下，
然后Launch打开使用就行了。后续再补。。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6852b3e85eca861240aad8bba5e68c97/" rel="bookmark">
			js声明变量的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS 声明变量的三种方式
（1）使用变量步骤：a.声明--&gt;b.赋值--&gt;3.调用
正确用法：
&lt;script type="text/javascript"&gt; // 方式一：声明和赋值不分离 var correctUsage = "正确使用变量的方式一"; alert(correctUsage); //能够弹出来该变量所对应的值 // 方式二：声明和赋值分离 var correctUsage2; correctUsage2 = "正确使用变量的方式二"; alert(correctUsage2); &lt;/script&gt; 错误用法：
&lt;script type="text/javascript"&gt; var correctUsage; // 错误一： 没有赋值就使用 alert(correctUsage); //underfined // 错误二：没有赋值就拼接字符串 correctUsage += "没有赋值就改值"; alert(correctUsage); //undefined没有赋值就改值 &lt;/script&gt; （2）变量的产生与死亡
已使用var关键词声明表里为例
2.1 声明在函数外部的变量
产生：js加载到该变量所在行时产生
死亡：js代码加载完毕，变量死亡
2.2声明在函数内部的变量
前提：该变量所在的函数被调用
产生：js执行到该变量所在行时产生
死亡： 该变量所在的函数执行行结束
举例：
情景一：函数只声明，不调用
&lt;script type="text/javascript"&gt; function test(){ var aa = "test"; aa +="只声明，但不调用该函数时，该函数会不会执行？"; //添加内容 alert(aa); aa = "该函数的变量不会执行！"; alert(aa); } &lt;/script&gt; 说明：上面2个alert不会执行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6852b3e85eca861240aad8bba5e68c97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6362f6bffa4b6785554643a5ee8bfb53/" rel="bookmark">
			浅谈JavaScript、ES5、ES6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是JavaScript
JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能。（好吧，概念什么最讨厌了）
动态：
在运行时确定数据类型。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。
弱类：
计算时可以不同类型之间对使用者透明地隐式转换，即使类型不正确，也能通过隐式转换来得到正确的类型。
原型：
新对象继承对象（作为模版），将自身的属性共享给新对象，模版对象称为原型。这样新对象实例化后不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。
PS：新对象指函数，模版对象是实例对象，实例对象是不能继承原型的，函数才可以的。
JavaScript由三部分组成：
1. ECMAScript（核心）
作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象
PS：*不完全兼容的实现
2. DOM（文档对象模型）
DOM把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。
PS：DOM也有级别，分为DOM1、DOM2、DOM3，拓展不少规范和新接口。
3. BOM （浏览器对象模型）
支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。
PS：BOM未形成规范
什么是ES5
作为ECMAScript第五个版本（第四版因为过于复杂废弃了），浏览器支持情况可看第一副图，增加特性如下。
1. strict模式
严格模式，限制一些用法，'use strict';
2. Array增加方法
增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法
PS： 还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now
3. Object方法
Object.getPrototypeOf
Object.create
Object.getOwnPropertyNames
Object.defineProperty
Object.getOwnPropertyDescriptor
Object.defineProperties
Object.keys
Object.preventExtensions / Object.isExtensible
Object.seal / Object.isSealed
Object.freeze / Object.isFrozen
PS：只讲有什么，不讲是什么。
什么是ES6
ECMAScript6在保证向下兼容的前提下，提供大量新特性，目前浏览器兼容情况如下：
ES6特性如下：
1.块级作用域 关键字let, 常量const
2.对象字面量的属性赋值简写（property value shorthand）
var obj = { // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Method definitions toString() { // Super calls return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6362f6bffa4b6785554643a5ee8bfb53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daf9473551725306e87b38442894c011/" rel="bookmark">
			网游客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网游客户端 前言一、项目的创建1.创建Windows窗体应用2.窗体设计 二、代码实现1.进入游戏按钮2.确认按钮3.背景音乐的添加4.背景图片的添加4.主要代码 效果演示完整代码参考文章 前言 本次使用的网游是一款名为金庸梦的文字游戏，游戏是运行在在控制台上的
一、项目的创建 1.创建Windows窗体应用 2.窗体设计 二、代码实现 1.进入游戏按钮 private void button10_Click(object sender, EventArgs e) { try { //向指定的IP地址的服务器发出连接请求 tcpClient.Connect("10.1.230.41", 3900); listBox1.Items.Add("连接成功！"); stream = tcpClient.GetStream(); byte[] data = new byte[1024]; //判断网络流是否可读 if (stream.CanRead) { int len = stream.Read(data, 0, data.Length); string msg = Encoding.Default.GetString(data, 0, data.Length); string str = "\r\n"; char[] str1 = str.ToCharArray(); string[] msg1 = msg.Split(str1); for (int j = 0; j &lt; msg1.Length; j++) { listBox1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daf9473551725306e87b38442894c011/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e10aaab804dd41e1e8d43001e7e297b/" rel="bookmark">
			swiper的默认箭头样式要怎么更改？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在项目中使用到了轮播图的轮子swiper，但是下面的自带箭头真的是丑爆了：
是这种蓝色的，极其丑
修改的办法： 先给上siwper的代码：
在最外层的wrapper中加入以下的样式：
让导航的箭头的size为0
接下来自己去网上找个箭头的图，比如iconfont，像下面这样就行了：
即箭头的图片当作背景图就好了
最终效果：
完美解决！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3e3aee22f434abdd0bde0b7dec1398/" rel="bookmark">
			springboot项目设置project Structure---＞Artifacts(部署的jar文件)以及怎么打jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、第一步，打开project Structure,点击+号
第二步选择箭头所指
第三步
第四步
第五步
然后选择ok，然后就可以去build项目的jar包了
第一步
第二步
然后build好的jar文件就在这里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648f89db3824ee423501f3fc4abe37da/" rel="bookmark">
			DOM操作的常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、DOM操作的常用API有哪些？ 节点查找API document.getElementById ：根据ID查找元素，大小写敏感，如果有多个结果，只返回第一个；document.getElementsByClassName ：根据类名查找元素，多个类名用空格分隔，返回一个 HTMLCollection 。注意兼容性为IE9+（含）。另外，不仅仅是document，其它元素也支持 getElementsByClassName 方法；document.getElementsByTagName ：根据标签查找元素， * 表示查询所有标签，返回一个 HTMLCollection 。document.getElementsByName ：根据元素的name属性查找，返回一个 NodeList 。document.querySelector ：返回单个Node，IE8+(含），如果匹配到多个结果，只返回第一个。document.querySelectorAll ：返回一个 NodeList ，IE8+(含）。document.forms ：获取当前页面所有form，返回一个 HTMLCollection ； 节点创建API createElement创建元素createTextNode创建文本节点cloneNode 克隆一个节点createDocumentFragment 节点修改API appendChildinsertBeforeinsertAdjacentHTMLElement.insertAdjacentElement()removeChildreplaceChild 节点关系API 1、父关系API parentNode ：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment； parentElement ：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element元素，如果不是，则返回null；
2、子关系API children ：返回一个实时的 HTMLCollection ，子节点都是Element，IE9以下浏览器不支持；
childNodes ：返回一个实时的 NodeList ，表示元素的子节点列表，注意子节点可能包含文本节点、注释节点等；
firstChild ：返回第一个子节点，不存在返回null，与之相对应的还有一个 firstElementChild ；
lastChild ：返回最后一个子节点，不存在返回null，与之相对应的还有一个 lastElementChild ；
3、兄弟关系型API previousSibling ：节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。
nextSibling ：节点的后一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。
previousElementSibling ：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。
nextElementSibling ：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。
元素属性型API 1、setAttribute 给元素设置属性：
2、getAttribute 3、hasAttribute
样式操作API（面试考点） 1、直接修改元素的样式 elem.style.color = 'red'; elem.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/648f89db3824ee423501f3fc4abe37da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758f02ac07261f7381375514ec7f5e17/" rel="bookmark">
			NCS(成都新电)java-8-10k-已拿offer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号还有更多
是个做外包的外企
首先会填写个人资料和用英文提问的信息主要问一下工作经历和接不接受出差，技术笔试题全英文，全是选择题，最后会让写一篇英文小作文，要求2000字左右，主要是关于个人情况和技能相关。
接下来就是一面 一面会问项目有关的问题，主要问参与参与项目设计没有，怎么设计项目，会有一些简单的关于项目框架的问题。
二面，二面首先会先让用英语做自我介绍，二面会比一面的基础技术问题要多一些，但还是比较简单。
主要问了这些
mybatis#和$什么区别
aop和ioc
spring设计模式
自己用过哪些设计模式
jvm的内存模型
讲一讲java集合，几种类型什么场景用
hashmap和hashtable区别
线程的生命周期
最后会做一套笔试题，笔试题主要考察的是java基础和sql，大概分布是java有20道单选题sql有10道单选题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a6bd64b846f86d938479308139c229/" rel="bookmark">
			【centos的 “/dev/vda1“ 导致服务全线崩溃】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos的 "/dev/vda1" 导致服务全线崩溃 微信公众号还有更多 一大早发现测试环境验证码用不了，看了下授权服务发现报错。
mysql执行SQL语句时报错:[Err] 3 - Error writing file ‘/tmp/MYP0G1B8’ (Errcode: 28 - No space left on device)
百度说是临时文件目录不够，后去执行sql语句查看mysql临时目录，发现mysql连不上了，后来同事发现gitlab也不行了，好像是所有服务都崩溃了。。
估计可能磁盘满了，因为之前遇到过一次问题。
使用 df -h 命令查看 发现/dev/vdal 已经百分百
使用 du -sh * 命令查看占用比较大的文件或目录，看了三遍发现最大的就是30多M，百分之就是都是几十K，根本不可能满阿
后来百度到有个deleted的文件（僵死文件。这些文件实际上已经被删除，但是有服务程序在使用这些文件，导致这些文件一直被占用，无法释放磁盘空间，使用如下命令可以查看死文件占用情况），lsof |grep deleted 使用这个命令查看
进程名 PID USER FD 文件类型 大小(字节) 索引节点 文件名 [(状态)]
java 3311 AuSP 8w REG 253,0 778 10879268 ***.log (deleted)
果不其然一堆文件没有释放
直接 kill -9 ‘进程的PID’
再次使用df -h查看发现确实少了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c19a4b4653a9c524b88678c79d6040/" rel="bookmark">
			用Python写出自己的出生日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/314/">«</a>
	<span class="pagination__item pagination__item--current">315/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/316/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>