<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e0307459820b7d9a8f566ce7762369/" rel="bookmark">
			查看ios 应用程序性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要
前言
性能概括
CPU内存监控
内存监控
磁盘监控
网络监控
GPU
fps
摘要 本篇博文将介绍一款重量级性能测试工具——克魔助手，针对iOS应用程序的性能监控进行详细介绍。通过克魔助手，开发者可以方便地查看应用程序的CPU、内存、GPU性能情况，以及网络监控和抓包等功能，帮助优化应用的性能。本文将重点介绍克魔助手的各项性能监控功能，并附带示例截图，帮助读者更好地了解和使用该工具。
前言 软件的性能是评价一个软件质量的重要指标，尤其在今天这个时代，性能已成为大型项目不可或缺的考虑因素之一。对于用户量极大的软件，如网银系统、在线购物商城等，更是必须保证其高效稳定的性能。在这种背景下，克魔助手作为一款专为苹果手机iOS应用开发设计的辅助工具，提供了丰富的性能监控功能，帮助开发者优化应用的性能。
性能概括 在克魔助手中，可以自定义选择列，并点击 “开始监听” 来查看应用程序的性能情况。以下是一些示例截图：
CPU内存监控 克魔助手提供了分析内存占用、查看 CPU 实时活动数据以及追踪特定应用程序的功能，让开发者可以更好地了解应用程序的运行情况。 以下是一些示例截图：
同样，克魔助手还提供了内存、GPU 性能监控、网络监控等功能，开发者可以查看实时数据活动和追踪应用程序的特定功能。 如下：
内存监控 以下是内存监控的示例截图：
磁盘监控 以下是磁盘监控的示例截图：
网络监控 以下是网络监控的示例截图：
GPU 以下是 GPU 监控的示例截图：
fps 以下是帧率（FPS）监控的示例截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/669d721e08e6138b1c9aa5f17308d0e6/" rel="bookmark">
			自定义开机启动，win10开机启动某个软件？ 例如邮箱outlook
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 自定义开机启动， win10开机启动某个软件？ 例如邮箱outlook 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5417deabc67fbb6a92ce81dfbfe9a28/" rel="bookmark">
			如何理解Vcpkg？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何理解Vcpkg？ https://learn.microsoft.com/zh-cn/vcpkg/get_started/overview
vcpkg 是 Microsoft 和 C++ 社区维护的免费开放源代码 C/C++ 包管理器。 它于 2016 年推出，可帮助开发人员将项目迁移到较新版本的 Visual Studio。 vcpkg 已演变成 Windows、macOS 和 Linux 上开发人员使用的跨平台工具。 vcpkg 拥有大量开放源代码库和企业就绪功能，旨在通过支持任何构建和项目系统来促进开发过程。
为什么使用 vcpkg？ 超过 2200 个开放源代码库可供选择，您也可以创建自己的代码库适用于 Windows、macOS 和 Linux 的一致的跨平台体验可以根据需要从源生成依赖项，使用框中的 70 多个配置和针对特定要求的无限自定义从源生成依赖项避免包与您的项目之间出现 ABI 不兼容问题防止依赖项关系图中的版本冲突和菱形依赖问题可用于企业级项目。 许多行业的 C/C++ 开发人员依赖此工具，包括：财务、游戏、嵌入式/IoT、半导体、防御以及 Microsoft 内部的项目对于 MSBuild 和 CMake 用户：自动与生成环境集成，打造无缝获取依赖项的体验 vcpkg 与其他包管理器的比较 vcpkg 与 NuGet 的比较 NuGet 是 .NET 包管理器，通常用于 C/C++ 开发，尤其适用于同时包含 .NET 项目的 MSBuild 解决方案。 一般情况下，Microsoft C++ 团队不建议使用 NuGet 进行 C/C++ 开发，因为 NuGet 存在以下限制：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5417deabc67fbb6a92ce81dfbfe9a28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09beec942017c5ad607e9f5095b116a0/" rel="bookmark">
			WIBUCM64.dll 是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WIBUCM64.dll 是什么 WibuCm64.dll 被视为一种 CodeMeter Library 文件。 它最常用于由 GetData 开发的 CodeMeter。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8be6e87a022b363b9c111f088256b4b/" rel="bookmark">
			python中的魔法函数及pytorch中forward()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 中的魔法函数 本节参照 python杂记——魔法方法 进行总结和梳理。
魔法方法（magic methods）：python 中的魔法方法是指方法名以两个下划线开头并以两个下划线结尾的方法，因此也叫 Dunder Methods (Double Underscores)，常用于运算符重载。
魔法方法会在对类的某个操作时后端自动调用，而不需要自己直接调用。例如，创建一个类A的对象，a=A()，python就会自动调用__new__()和__init_()函数
类函数__init__()的理解 在创建类后，类通常会自动创建一个__init__()方法。该方法是一个特殊的方法，类似 JAVA 语言中的构造方法。每当创建一个类的新实例时，Python 都会自动执行它。init() 方法必须包含一个参数，并且必须是第一参数。self 参数是一个指向实例本身的引用，用于访问类中的属性和方法。在方法调用时会自动传递实际参数 self。因此，当__init__()方法只有一个参数时，在创建类的实例时，就不需要指定参数了。
在__init__()方法中，除了 self 参数外，还可以自定义一些参数，参数间使用逗号“,”进行分隔。例如，init(self, a, b)，但是在实例化类时，需要指定 a 和 b 这两个参数。
初始化和构造相关的魔法函数：
方法名描述__new__(cls, other)在实例化一个对象的时候被调用__init__(self, other)用于初始化对象，被__new__方法调用__del__(self)对象的析构方法 集合相关的魔法函数：
方法名描述__len__(self)被内置方法len()调用, 返回容器的长度, 可变和不可变的容器类型都需要实现__getitem__(self, key)在使用key访问成员时调用, object[key]__setitem__(self, key, value)给集合中key值赋值时被调用, object[key] = value__delitem__(self, key)被del 调用, 例如: del object[key]__contains__(self)在执行in()或者not in时被调用__reversed__(self)被内置方法reversed()调用, 翻转序列的顺序__missing__(self)在字典的子类中使用,当试图访问字典中不存在的key时被调用 类函数__getitem__()的理解 在python中__getitem__(self,key)方法被称为魔法方法，这个方法返回所给键对应的值。
当对象是序列时，键是整数。当对象是映射时（字典），键是任意值。
在定义类时，如果希望能按照键取类的值，则需要定义__getitem__()方法。如果给类定义了__getitem__()方法，则当按照键取值时，可以直接返回__getitem__()方法执行的结果。
pytorch 中 forward() 函数 本节参考 #深入探究# PyTorch中的 forward() 方法详解 进行的总结梳理。
使用 PyTorch 进行模型训练时，不需要显式地调用 forward 函数，只要在实例化一个对象中传入对应的参数就可以自动调用 forward 函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8be6e87a022b363b9c111f088256b4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a084c528923d857d66612f9e4417755d/" rel="bookmark">
			算法基础day2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前缀和
#include &lt;iostream&gt; using namespace std; const int N=100010; int n,m; int a[N],s[N]; int main() { scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+a[i]; while(m--) { int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",s[r]-s[l-1]); } return 0; } 二维前缀和
#include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; const int N=1010; int n,m,q; int a[N][N],s[N][N]; int main(){ scanf("%d %d %d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ scanf("%d",&amp;a[i][j]); } } for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//求前缀和 } } // for(int i=1;i&lt;=n;i++) // for(int j=1;j&lt;=m;j++) // cout &lt;&lt; s[i][j]&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a084c528923d857d66612f9e4417755d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12feb587cc3c0520916adc6331fe6c6b/" rel="bookmark">
			如何用克鲁斯卡尔算法求解最小生成树？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、克鲁斯卡尔（Kruskal）概述二、克鲁斯卡尔（Kruskal）的基本思路三、克鲁斯卡尔（Kruskal）实战（一）并查集（Union-Find）算法（二）力扣解题思路 一、克鲁斯卡尔（Kruskal）概述 克鲁斯卡尔（Kruskal）算法也是求连通网的最小生成树的另一种方法。
关于最小生成树相关概念不了解的可以看——Prim算法：如何快速求解最小生成树？-CSDN博客
克鲁斯算法重点需要解决以下问题：
对图的所有边按照权值大小进行排序。将边添加到最小生成树时，如果当前最小权值的这条边添加进去，没有导致形成回路，那么就把边添加进树中。否则，不将边添加进树中，继续遍历下一条边。 Kruskal算法和Prim算法有什么区别？
Kruskal算法是基于边进行的贪心算法，而Prim算法是基于节点进行的贪心算法。
在时间复杂度方面，Kruskal算法的时间复杂度为O（ElogE），而Prim算法是O（ElogV），其中E为边，V为顶点
二、克鲁斯卡尔（Kruskal）的基本思路 下面就根据一个修路问题根据上面两点模拟一下克鲁斯卡尔解题的基本思路，根据Kruskal算法找出下面图的最小生成树
首先，收集图中的边进行排序，这里的话就不做了，因为我们一眼就能看出来。
然后找出权值最小的边，如果将这条边添加到集合中不会导致形成环，则将这个边收集起来，可见，这里权值最小的边为EF。
接着，重复上述步骤，从除去CD的边外，找到最小权值并不形成环的边收集，继续收集CD
重复上述步骤，收集DE
接下来就要注意了，除了CD EF ED三条边外，最小的边就是CE，但是收集CE会导致出现环，于是放弃收集CE。
考虑收集CF，由于CF收集后也会导致环，于是放弃CF，收集BF，BF满足算法思路。
以下就是最后收集到的最小生成树。
三、克鲁斯卡尔（Kruskal）实战 了解了思路之后，就需要进行实战操作了，同样的针对1584. 连接所有点的最小费用 - 力扣（LeetCode）使用Kruskal算法进行解决。
为了保证生成树不包含环，这里需要使用Union-Find 算法，下面先简单介绍一下。
（一）并查集（Union-Find）算法 并查集数据结构（也称为联合-查找数据结构或合并-查找集）基于数组实现的一种跟踪元素的数据结构，这些元素被划分为多个不相交（非重叠）的子集。
它提供了近乎恒定的时间操作（以逆阿克曼函数为界）来添加新集合、合并现有集合以及确定元素是否在同一个集合中。除了推荐算法、好友关系链、族谱等，并查集在的算法中扮演着关键角色，用于寻找无向边加权图的最小生成树。
上面引用了小傅哥的文章——考你个并查集，你竟然抠脚！ - 掘金 (juejin.cn)，有兴趣可以自己看看。
我就用上面图的案例介绍一下怎么使用Union-Find算法找出是否会形成环。
假如现在打算将顶点5和顶点8相连，那么我们可以根据数据找到顶点5和顶点8各自的父节点。
由数组可知，顶点5的父节点是顶点3，顶点8的父节点是顶点7
同理可推顶点3的父节点是顶点1，顶点7的父节点是顶点6
继续推，顶点1的父节点是顶点6。
这说明顶点5与顶点8是存在相连的路径的，如果顶点5与顶点8直接相连，那么肯定会形成环。
（二）力扣解题思路 定义一个对象Edge表示边，算法开始之前初始化一个Edge集合，存储的是每一条边的顶点和边长度并且初始化一个并查集数据结构，集合中index为i的位置存储的是i，这表示每个节点的父节点都是自己，说明没有相连。将收集到的Edge边按照边长度从小到大进行排序遍历每一条边，找到这条边两个顶点对应的父节点，如果他们的父节点不相同，说明将这条边收集也不会形成环收集每一条边的同时，收集结果res，并且给顶点a赋值一个新的父节点b，顺序调转过来也没关系。遍历完成后，res就是最小费用结果了。 class Solution { /** * 交并集的根节点集合 */ List&lt;Integer&gt; path = new ArrayList&lt;&gt;(); /** * 边 */ class Edge { int a; int b; int length; public Edge(int a, int start, int length) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12feb587cc3c0520916adc6331fe6c6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab14867adfaa5e399a2d40894e0fa47f/" rel="bookmark">
			2020年认证杯SPSSPRO杯数学建模B题(第一阶段)分布式无线广播全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年认证杯SPSSPRO杯数学建模 B题 分布式无线广播 原题再现： 以广播的方式来进行无线网通信，必须解决发送互相冲突的问题。无线网的许多基础通信协议都使用了令牌的方法来解决这个问题，在同一个时间段内，只有唯一一个拿到令牌的通信节点才能发送信息，发送完毕后则会将令牌传递给其他节点。但我们考虑这样的一个无线网：每个通信节点都是低功率的发射器，并且在进行着空间上的低速连续运动 (无法预知运动方向及其改变的规律)，所以对一个节点而言，只有和它距离在一定范围之内的节点才能收到它的信号，而且节点会 (在未声明的情况下) 相互接近或远离。每个节点需要不定期地、断续地发送信息，但会时刻保持收听信息。发送和收听工作可以同时进行。在这个通信网络中，完全没有网络的基础设施，而且每个节点只需要把自己的信息广播出去，需要此条信息的节点只需要被动收听即可，并不需要点对点地持续交换信息。所有信息只能使用同一个频率发送，一旦有两个或多个节点的广播发生冲突，能同时收听到它们的节点就都能监听到冲突。
第一阶段问题： 我们假设发送每条信息所占用的时间都是等长的。所有的节点都拥有同样的内置算法，并拥有一个校准过的高精度时钟。请建立合理的数学模型并解决如下问题。
1. 请构造一个合理的指标来描述网络的整体通信效率。
2. 在每个节点需要发送信息时，请设计一个方案来选择发送的时间段。如果发送信息时发现存在冲突，如何自动调整重发的时间段，才能使网络的整体通信效率尽可能高? 可能需要分情况 (例如分轻载/重载等不同情形，或其他分法) 来考虑问题。
整体求解过程概述(摘要) 目前，网络技术得到迅速发展，但在无线网络通信系统的分布式环境下节点之间信息的传输行为较为复杂。因此，对无线网通信效率的研究具有一定的意义。本文针对在给定的无线网环境，提取能够反映网络的整体通信效率的指标，对指标进行定量分析后建立回归模型来描述网络的整体通信效率。
针对问题一：分析无线网中的环境，由通信节点是低速连续运动，其运动可以看作布朗运动的形式；节点是否接收到信息与通信距离有关；对某节点发送、接收、产生冲突信息的计数采用叠加原理。把无线网通信的节点放在三维空间里面研究，根据动态节点间的距离，对某时段各节点发送信息、接收信息、发生通信冲突进行研究，得到冲突率、时延率、吞吐率和承载率四个指标。分别将四个指标与通信效率进行相关性分析，再通过回归分析，建立通信效率的回归模型。即得到由四个指标生成的线性组合来表示网络的整体通信效率。
通过仿真模拟，得到多组关于通信效率与冲突率、时延率、吞吐率和承载率的数据，运用线性回归模型的程序求解出回归模型的回归系数，即得到网络的整体通信效率模型。在对模型进行实例验证，进一步说明模型的可行性和准确性。
针对问题二：当发送信息时发现存在冲突，在相同条件下去研究如何调整重发时间段来使网络通信效率尽可能高。由于网络的承载能力和冲突之间有着显著性的特征，在研究问题二的模型时分轻载和重载进行讨论。以轻载为例，通过建立有通信冲突的最小连通支配集来确定节点通信冲突的点集，通过分离冲突域、建立独立子集来尽可能和减小通信冲突。结合问题一中的通信效率模型，对指标进一步刻画，找到通信效率的最大值，从而解出对应的的时间段，由完成这一过程所需要的的时间与时间段做处理，可得到重发的时间段。即通过相应算法，结合问题一的模型，网络系统可自动调整重发时间段。
采用 MATLAB软件, 对节点数为 10 的通信网络进行仿真动态模拟，可得到存在冲突时，高通信效率下所对应重发的时间段。
本文最后，对问题一和问题二建立的模型及求解进行了优缺点分析，以及对模型的展望进行了说明。
问题分析： 本题主要的工作就是建立一些合理的指标并且找到指标之间的关系建立一个能够描述网络的整体通信效率的模型，为了尽量避免冲突，需设计一个方案来提高网络的整体通信效率。
问题一的分析
需要构造一个合理的指标来描述网络的整体通信效率。首先，把网络上的节点放到空间直角坐标系上考虑，节点的运动遵循布朗运动的形式，由此我们根据节点的动态坐标得到节点间的距离 d 并给定一个通信距离 D，当 d ≤ D 时，则两个节点之间可以互相通信，反之则不能进行互相通信；其次，我们再找出描述网络的整体通信效率的相关指标，有冲突率、时延率、吞吐率和承载率；然后，我们根据建立的四个指标与通信效率之间建立多元线性回归分析模型来描述网络的整体通信效率；最后，为了验证模型的准确性，我们把模型带到具体通信网络的实例中进行计算和分析。
问题二的分析
节点发送信息时可能发现存在冲突，这种冲突尽可能少就更有利于通信效能的提高。通过建立有通信冲突的最小连通支配集来确定节点冲突的点集；通过分离冲突域，建立独立子集来尽可能减小通信冲突，均通过相应的算法来实现。网络在运作的过程中，所承载的能力对通信冲突存在不一样的影响，此时，对网络的承载能力分为轻载和重载进行分类讨论。结合第一问建立的模型，在指标明确的情况下，找出尽可能高的通信效率，从而找到对应的时间，与初始时间一处理即可得到调整后的时间段。相应的可以做动态仿真模拟，在轻载或是重载下，冲突域的改变，可以调整出不同的时间段，使通信效率尽可能高。
模型假设： (1) 假设每个节点都有相同的内置算法；
(2) 假设每个节点的通信距离始终相等，即为常数；
(3) 假设在没有广播冲突的前提下，节点一旦接收到消息就一定是接收到完整的信息；
(4) 假设不考虑某节点未完成接收已知的所需信息时不会发送其他信息；
(5) 假设发送每条信息这一操作所占用的时间是等长的且忽略不计；
(6) 假设计算网络中信息传播的最大时间与实际网络中信息传播的最大时间之间存在的误
差几乎为 0。
论文缩略图： 全部论文请见下方“ 只会建模 QQ名片” 点击QQ名片即可 部分程序代码：(代码和文档not free) clc,clear all hang=1; ss=zeros(7*5,4); %length(number) rrate=zeros(7*5,6); for number=[10:50:300,300] x=2*rand(number,1)-1; y=2*rand(number,1)-1; z=2*rand(number,1)-1; for rate=[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab14867adfaa5e399a2d40894e0fa47f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6c4e2482f3f8fa8e12a05b6251bfcc3/" rel="bookmark">
			如果SSE推送不稳定，是不是可以考虑切换成WebSocket，各自有什么优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面对 Server-Sent Events (SSE) 推送不稳定的情况时，可以考虑切换到 WebSocket。SSE 和 WebSocket 都是现代Web应用中用于实现实时通信的技术，但它们有各自的优缺点和最适用的场景。
Server-Sent Events (SSE) 优点 简单性：SSE 在使用上比 WebSocket 更简单，特别是在仅需要单向通信（服务器到客户端）的场景中。内置重连机制：SSE 自带自动重连功能，这在处理临时网络中断时非常有用。HTTP兼容：SSE 基于标准的HTTP协议，更容易与现有的Web基础设施和中间件兼容。 缺点 单向通信：SSE 仅支持服务器到客户端的单向通信。如果需要双向通信，则需要另外的技术（如WebSocket）。浏览器支持：尽管大多数现代浏览器支持 SSE，但某些浏览器（如旧版本的IE）不支持。网络不稳定性：在网络不稳定的环境下，SSE 可能会表现出不稳定性，尤其是在需要频繁重连的场合。 WebSocket 优点 全双工通信：WebSocket 支持全双工通信，允许服务器和客户端之间进行实时的双向数据传输。更高的控制水平：WebSocket 提供更高水平的控制，包括手动处理连接、断开和消息传输。更低的延迟：由于是一个更轻量级的协议，WebSocket 通常具有比 SSE 更低的网络延迟。 缺点 实现复杂性：相对于 SSE，WebSocket 在实现上更复杂，特别是在处理连接管理和错误处理方面。没有内置的重连机制：WebSocket 没有内置的重连机制，需要在客户端手动实现。可能的兼容性问题：一些网络代理和防火墙可能不支持或限制 WebSocket 连接。 总结 当你的应用主要需要从服务器到客户端的单向实时数据流，并且希望实现简单时，SSE 是一个好选择。如果需要更复杂的双向通信，或者在面对网络问题时需要更强的控制和稳定性，WebSocket 可能是更好的选择。 在决定使用哪种技术时，重要的是考虑你的具体需求，包括通信的方向性、实时性需求、以及你愿意投入多少精力去管理连接的复杂性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9af4ec41ca5728d11f3563d7d88ad54/" rel="bookmark">
			2020年认证杯SPSSPRO杯数学建模A题(第一阶段)听音辨位全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020年认证杯SPSSPRO杯数学建模 A题 听音辨位 原题再现： 把若干 (⩾ 1) 支同样型号的麦克风固定安装在一个刚性的枝形架子上 (架子下面带万向轮，在平地上可以被水平推动或旋转，但不会歪斜)，这样的设备称为一个麦克风树。不同的麦克风由于位置不同，录制到的声音往往也有细微的不同，所以通过对多支麦克风接收到的声音进行对比分析，可以得到更多的有关声源的信息。我们假设每个麦克风都是全向的，也就是单麦克风无法分辨声源的方向。
现在有一个地面、墙壁和天花板都是光滑大理石的大厅，大厅内空旷而安静。在大厅里只有一个走动的人，发出清晰的脚步声。我们准备在大厅里安放一个麦克风树，希望通过检测声音来进行一些测量，包括尽量准确地实时确定这个人的位置，也包括测量这个大厅的某些几何参数。请你建立合理的数学模型，设计一个成本尽量低、而且可以达到使用要求的麦克风树。要求给出每支麦克风的相对位置以及相对于地面的高度，至于枝形架子的具体力学结构则不需要考虑。
第一阶段问题： 根据已知和所求信息的不同，这个问题可以有不同的复杂程度。我们需要在以下两种情形中对麦克风树进行合理的设计，并给出对接收到的声音信号进行分析的算法。
1. 已知大厅的平面形状是矩形，地面和天花板都是水平的。假设我们已知大厅轮廓的准确尺寸 (长 × 宽 × 高)。但在实际施工中，由于操作和设备所限，在麦克风树放置在地面上的时候，无法精确测量放置点的坐标以及水平的旋转角度。我们希望确定此人的位置。
2. 大厅轮廓的尺寸未知，其余条件同上。我们希望确定此人的位置，并尽量准确地确定大厅的轮廓尺寸 (长 × 宽 × 高)。
整体求解过程概述(摘要) 本文针对麦克风阵列接收声源信号以获得声源实时位置及如何测量大厅几何参数的问题进行分析研究，通过分析比较，最终确定以十字形麦克风阵列为核心，以声达时间差和能量分析为方法的优化模型。
针对于问题一，我们将从两个方面拆解问题并给出分析过程，其中包括麦克风阵列的选择和优化定位模型的建立。
第一个方面是关于麦克风阵列的选择，我们首先建立了一维线性阵列模型，在对线性模型的计算改进的基础上建立了二维面阵模型其中包括方形阵列模型、等边三角形阵列模型、圆形阵列模型。接着我们对三个模型进行了合理的理论推导与证明，通过实验计算出原始位置与测定位置之间的误差，并分析其结果得出平均误差，证明出方形阵列为最适宜阵列模型。最后结合实际应用与实现的难易程度进行分析，且由于方形阵列可以近似看为十字形阵列，因此本文将十字形阵列确定为最优阵列的选择。
第二个方面是关于定位模型的建立，由于考虑到声源传播模式可以分为近场与远场，我们对远近场区分的常用公式进行了声源在近远场的比对分析，但因为在本题中可以忽略远近场的影响，于是在理想状态下，可以根据信号时延性进行计算以得到声源位置。阵元间距问题，我们通过给出一定的声源频率，结合声速与波长的关系，给出合适的阵元间距。最后，通过声源的位置信息，确定了以四个麦克风数量为基准的麦克风矩阵定位模型，再进行逐步分析增加，最终确定麦克风最优个数。
针对于问题二，我们需要解决如何在大厅几何参数未知的情况下，测定大厅的体积及实时确定人的位置。由于大厅几何参数未知，我们首先利用声音会逐渐减弱的特性确定了在仅有扩散衰减情况下的声音衰减模型。通过分析确定无法忽略吸收衰减和散射衰减对模型的影响，于是对模型进行了优化提出了衰减系数a 。接下来，我们设计了一个实验通过利用 matlab 进行 power 幂函数方程拟合以测定在室内环境下衰减系数的值。其次，由于未确定大厅几何参数会对定位模型造成一定的影响，因此以声达时间差来确定大厅的定位模型无法精确得出大厅的大小，所以我们选择二选其一声音强度(能量法)来帮助对未知大厅大小的定位模型的建立。通过得出声强级和传播距离的关系，设计出合理的麦克风安置方法。考虑到麦克风接收声源信息的误差会导致不同麦克风对声源位置的估计产生偏差，因此使用蒙特卡罗算法进行近似处理，从而通过计算可以得到的合理声源位置。
最后，本文对所有问题的模型进行了客观合理的评价，并且对建立的数学模型进行了改进分析，使得模型的应用面更加广泛。
问题分析： 对于问题一：已知平面是矩形的大厅且已知大厅轮廓的准确尺寸，在理想情况下，如何建立起一个在刚性的枝形架子上的麦克风树，忽略了近远场的影响及声音的传输损失，通过分析各种阵列的优缺以选择建立最优的一个成本尽量低、而且可以达到使用要求麦克风阵列和确定阵元的数量给出每支麦克风的相对位置以及相对于地面的高度，能实时确定发出清晰声源（脚步声）的人的位置。
对于问题二：现实中往往并不能准确知道大厅的几何参数，并且无法忽略声音传输的损失。由于以上原因，我们可以首先在大厅体积未知的情况下，在问题一解决的基础上，用已经建立的模型下寻找借助声源传播求解大厅的几何参数，然后将建立一个新的模型,对结果分别进行预测，并将结果进行比较，于是可以得出在非理想情况下，如何实时确定人的位置。
模型假设： 1. 在远场模型中，因为声源信息到麦克风阵列的幅度差较小，忽略不计。
2. 忽略鞋和体型等因素，一个正常人脚步声的频率在 20 Hz ～40 Hz 。
3. 不考虑环境的噪声影响以及室内混响的影响。
4. 在第一问中，忽略远场和近场对麦克风阵形的影响。
5. 麦克风的品质（即对信息的收集能量）不随实验时间的进行而下降。
6. 持续行走发出的脚步声的声强级（分贝）不发生改变，始终为 50 分贝。
论文缩略图： 全部论文请见下方“ 只会建模 QQ名片” 点击QQ名片即可 部分程序代码：(代码和文档not free) clear;clc; v=340;z=11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9af4ec41ca5728d11f3563d7d88ad54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13f5345f405dd7acb19630e5378f897b/" rel="bookmark">
			『言善信』Fiddler工具 — 3.补充：HTTP协议介绍（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4、НТТР响应报文 （1）НТТP响应报文说明 HTTP响应报文主要由状态行、消息报头、空一行、响应正文4部分组成。
HTTP响应报文协议格式：
在Fiddler中抓取的请求中，在响应报文中，点击raw选项就可以看到如下信息。
如果你想学习fiddler抓包，我这边给你推荐一套视频，这个视频可以说是B站播放全网第一的fiddler抓包教程，同时在线人数到达1000人，并且还有笔记可以领取及各路大神技术交流：798478386 2024备战金三银四，最新版fiddler抓包实战教程！_哔哩哔哩_bilibili2024备战金三银四，最新版fiddler抓包实战教程！共计8条视频，包括：1、fiddler和F12抓包对比、2、Fiddler工作原理、3、配置证书抓取https包等，UP主更多精彩视频，请关注UP账号。https://www.bilibili.com/video/BV19j411J7oc/?spm_id_from=333.337.search-card.all.click
下面一一说明：
（2）响应行 响应行分为三部分：
HTТP协议版本：HTTP/1.1是现在比较常用的版本。
状态码（Status Code）
用以表示网页服务器HTTP响应状态的3位数字代码。
状态码描述1XX信息，服务器收到请求，需要请求者继续执行操作。2XX成功，操作被成功接收并处理。3XX重定向，需要进一步的操作以完成请求。4XX客户端错误，请求包含语法错误或无法完成请求。5XX服务器错误，服务器在处理请求的过程中发生了错误。 下面是常见的HTTP状态码：
200 - 请求成功。301 - 资源（网页等）被永久转移到其它URL。404 - 请求的资源（网页等）不存在。500 - 内部服务器错误。 HTTP状态码列表:
状态码状态码英文名称中文描述100Continue继续。客户端应继续其请求101Switching Protocols切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200OK请求成功。一般用于GET与POST请求201Created已创建。成功请求并创建了新的资源202Accepted已接受。已经接受请求，但未处理完成203Non-Authoritative Information非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本204No Content无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档205Reset Content重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域206Partial Content部分内容。服务器成功处理了部分GET请求300Multiple Choices多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择301Moved Permanently永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302Found临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI303See Other查看其它地址。与301类似。使用GET和POST请求查看304Not Modified未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源305Use Proxy使用代理。所请求的资源必须通过代理访问306Unused已经被废弃的HTTP状态码307Temporary Redirect临时重定向。与302类似。使用GET请求重定向400Bad Request客户端请求的语法错误，服务器无法理解401Unauthorized请求要求用户的身份认证402Payment Required保留，将来使用403Forbidden服务器理解请求客户端的请求，但是拒绝执行此请求404Not Found服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面405Method Not Allowed客户端请求中的方法被禁止406Not Acceptable服务器无法根据客户端请求的内容特性完成请求407Proxy Authentication Required请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权408Request Time-out服务器等待客户端发送的请求时间过长，超时409Conflict服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突410Gone客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置411Length Required服务器无法处理客户端发送的不带Content-Length的请求信息412Precondition Failed客户端请求信息的先决条件错误413Request Entity Too Large由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息414Request-URI Too Large请求的URI过长（URI通常为网址），服务器无法处理415Unsupported Media Type服务器无法处理请求附带的媒体格式416Requested range not satisfiable客户端请求的范围无效417Expectation Failed服务器无法满足Expect的请求头信息500Internal Server Error服务器内部错误，无法完成请求501Not Implemented服务器不支持请求的功能，无法完成请求502Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应503Service Unavailable由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中504Gateway Time-out充当网关或代理的服务器，未及时从远端服务器获取请求505HTTP Version not supported服务器不支持请求的HTTP协议的版本，无法完成处理 （3）响应头（Response Header） 常见响应头属性如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13f5345f405dd7acb19630e5378f897b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc52b0a08b9e6c78421d30570d4d1c66/" rel="bookmark">
			leetcode贪心算法题总结(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节目录 1.最长回文串2.增减字符串匹配3.分发饼干4.最优除法5.跳跃游戏II6.跳跃游戏7.加油站8.单调递增的数字9.坏了的计算器 1.最长回文串 最长回文串
class Solution { public: int longestPalindrome(string s) { //计数一：用数组模拟哈希表 int hash[127] = {0}; for(auto x:s) { hash[x]++; } //统计结果 int ret = 0; for(auto x:hash) { ret += x/2*2; } return ret&lt;s.size()?ret+1:ret; } }; 2.增减字符串匹配 增减字符串匹配
class Solution { public: vector&lt;int&gt; diStringMatch(string s) { //贪心 //遇到I，选择当前能选择的最小的数 //遇到D，选择当前能选择的最大的数 int left = 0,right = s.size(); vector&lt;int&gt; ret; for(auto ch:s) { if(ch == 'I') ret.push_back(left++); else ret.push_back(right--); } ret.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc52b0a08b9e6c78421d30570d4d1c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce60413a3af4ea09b4e1f31fe4dda139/" rel="bookmark">
			从产品价值到流量变现模型，AI应用商业化破局的两大关键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AGI时代，伴随着人工智能技术的不断发展，全球AI应用市场快速升温。据SensorTower最新数据显示，2023年上半年，全球AI应用下载量同比增长114%，突破3亿次，收入同比增长175%。不可置否，随着通用模型能力迭代的速度加快，全球AI应用市场的百花齐放将为各行业发展带来全新的机遇与可能。但回归产品及商业价值本身，狂欢的背后，AI应用商业化破局或将成为人工智能从通用走向行业的核心点之一。
作为国内率先在出海营销领域布局AIGC战略的企业国际化智能营销服务商，今年7月，易点天下发布了首个AIGC数字营销创作平台KreadoAI，并以此为依托，在AI应用的商业化方向探索上逐步沉淀出了一套具有可复制性的方法论。今天将以KreadoAI的商业化路径设计为例，看AI应用厂商如何从产品价值到流量变现模型，实现商业化破局获取长效增长。
从传统互联网到移动互联网，每一次新的技术革命，都会带来产业的升级，但对于产品的开发设计来说，底层的商业化逻辑从未改变。在此前刚刚结束的《企业快成长人工智能技术创新论坛》上，易点天下高级产品总监 Aodi Zhang 分享到：“无论是在PC时代、移动互联网时代，还是当下的AI时代，对于任何产品来说，摆脱商业化困境的核心还是要回归流量与变现模型。尤其自GPT引发全球新一轮AI应用浪潮以来，用全新的视角重新审视用户需求，进行产品设计和商业模式的创新尤为重要。”
结合KreadoAI的商业化路径设计，针对如何将AI技术与实际应用场景结合塑造商业价值的问题，Aodi Zhang认为以下两点至关重要。
KEY TAKEAWAYS 01
产品力永远是核心，技术只是为了更好地解决用户需求
AI最终要回归市场价值，企业与AI的融合并非更换赛道，而是要从自身擅长的领域出发结合AI优势，探索出更有竞争力的产品。以KreadoAI为例，预计到2025年，全球电商交易规模将达到8.3万亿美元，其中创意素材成本在电商GMV占比超过1%。而对于出海赛道上的电商企业而言，传统数字内容的生成效率已成为新时代的瓶颈，不仅成本高昂，效率低下，更在跨境领域面临脚本创作难、多语言无法兼顾、真人演员选择少、小语种沟通困难、试错成本高等痛点，KreadoAI的价值在于实现了AI技术、服务解决方案场景、营销数据的闭环。在千人千面的个性化营销时代，只有持续关注用户需求，紧跟变化，才能真正创造价值。
KEY TAKEAWAYS 02
找到优势行业有效场景+AI，用数据增长模型驱动商业化落地
对于当下阶段的绝大多数AI应用来说，只有持续满足用户需求，才能不断获得收益，只有持续盈利的产品，才能站稳脚跟。KreadoAI商业化成功的第一步在于，以”热点买量+关键词+成为内容生产素材+强产品力”的引爆公式，获得了第一轮流量的正向增长，全球注册用户数突破60W+。但从产品的长效增长角度来看，AIGC正以其强大的信息获取能力、数据处理能力、逻辑推理能力和内容创作能力，不断推动着数字内容生产流程和范式和变革，通过以AI数据洞察模型、预估模型、预算分配模型为依托的数据增长模型平台驱动商业化落地，将是AI应用商业化破局的新的方向与趋势。目前，由易点天下自主研发的出海营销数据增长模型平台“数眼智能”已进入全面内测阶段，预计明年Q1正式面向市场发布。
新一轮人工智能浪潮下涌现出的AI应用正逐步进入到商业化的阶段，AI应用商业化的“成败”也从一定程度上决定了本轮AI浪潮的前景。作为一家以技术驱动发展的营销科技公司，易点天下将持续推动AI技术的普惠化，通过“AI+营销”的全链路解决方案与“AI+行业”的全场景解决方案的不断探索，将生成式 AI 技术从理论研究和实验中引入应用场景，全面助力出海企业提高营销效率和内容创作效率，构建全新用户体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a93dd3385ca76543b21d41478714078e/" rel="bookmark">
			（2023，控制解缠，特征合并，LLM，DDIM）Make-A-Storyboard：具有解缠和合并控制的故事板通用框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Make-A-Storyboard: A General Framework for Storyboard with Disentangled and Merged Control
公众：EDPJ（添加 VX：CV_EDPJ 或直接进 Q 交流群：922230617 获取资料）
目录
0. 摘要
1. 方法
1.1 上下文提示处理
1.2 解耦概念控制
1.3 对扩散中特征合并的观察
1.4 平衡感知合并
2. 结果
S. 总结
S.1 主要贡献
S.2 方法
0. 摘要 故事可视化旨在生成与故事提示相一致的图像，通过角色和场景之间的视觉一致性反映故事书的连贯性。然而，当前的方法完全集中于角色，忽视了上下文相关场景之间的视觉一致性，导致独立的角色图像而缺乏图像间的一致性。为了解决这个问题，我们提出了一种名为 Storyboard 的故事可视化新呈现形式，灵感来自电影制作，如图 1 所示。具体而言，Storyboard 将故事逐一展开为场景的视觉表示 [24]。在 Storyboard 的每个场景中，角色在同一位置进行活动，需要视觉上一致的场景和角色。对于 Storyboard，我们设计了一个通用框架，称为 Make-A-Storyboard，它对上下文相关角色和场景的一致性进行解耦控制，然后将它们合并以形成和谐的图像。广泛的实验证明了：1）有效性。该方法在故事对齐、角色一致性和场景相关性方面的有效性；2）泛化性。我们的方法可以无缝集成到主流的图像定制方法中，赋予它们故事可视化的能力。
1. 方法 我们提出了一种名为 Storyboard 的故事可视化的新表现形式。Storyboard 涉及以逐场景的形式将给定的故事进行可视化。在每个场景中，合成的图像应保持场景和角色的一致性。为了实现这一点，我们设计了一个通用的框架，如图 2 所示，称为 Make-A-Storyboard。
1.1 上下文提示处理 如图 2 左侧所示，我们使用了一个 LLM 来处理考虑句子之间上下文相关性的故事提示。首先，LLM 根据给定的主题编写故事，然后将故事分为 N 个离散的句子，表示为 T。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a93dd3385ca76543b21d41478714078e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/236f5e1c572a478af7e9aee38027bf49/" rel="bookmark">
			安卓版本与鸿蒙不再兼容，鸿蒙开发工程师招疯抢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期鸿蒙的风口是越传越火了，互联网大厂纷纷开始急招华为鸿蒙开发工程师。这是一个新的信号。在Android和iOS长期霸占市场的今天，鸿蒙的崛起无疑为整个行业带来了巨大的震动。
11月10日，网易更新了高级/资深Android开发工程师岗位，职位要求参与云音乐多端多os的产品(Android、鸿蒙等)研发迭代。
11月8日，美团发布了鸿蒙高级工程师、鸿蒙基建工程师等多个鸿蒙开发相关岗位。
今日头条招聘Android开发工程师也提及岗位需要“负责今日头条Android、鸿蒙系统等新技术方向调研，技术难点攻克，提供业务未来发展的技术能力储备”。
不少平台正在计划推出鸿蒙版 App。一位在线服务公司的产品经理表示，“目前 App 的安卓版本与鸿蒙不兼容，鸿蒙 App 已经在开发中了。”
对于程序员来说，掌握鸿蒙开发技能，无疑是为自己的未来多了一份保障。而且，按照目前的趋势，鸿蒙开发的前景非常广阔。
根据华为公布的围绕鸿蒙生态链的建设中可以看到，越来越多企业级开发者正加速融入鸿蒙生态，其中阿里、腾讯、美团等率先做出表态，未来的软件应用开始转向鸿蒙系统，同时支付宝、小红书、哗哩哗哩、建设银行、交通银行、招商银行信用卡、滴滴出行、同程旅行等26家国内科技企业将围绕鸿蒙生态系统布局。
另外，在目前已经推出的鸿蒙版应用中，暂时还没有发现像微信、抖音、支付宝等这样的几乎必备的APP。
开发 据行业内广泛认可，鸿蒙系统HarmonyOS是华为全力打造的作品，旨在解决外部因素带来的干扰，实现自主掌控，目标主要是增强技术实力。
然而，开发手机操作系统从来都不是一项简单的任务，它需要人才、技术、应用和软件开发者的多层协同合作，否则就会面临在竞争中容易起步，但难以持续发展的挑战。
手机操作系统的研发不仅仅是简单的软件开发任务，还需要找到一个合适的商业模式来实施。鸿蒙的独立开发思路，摒弃了AOSP代码，并极力推崇原生应用开发，对于习惯于安卓软件开发的开发者来说，也将面临不小的挑战。必须确保开发者能够从中获得收益，让用户习惯于使用鸿蒙的原生软件，才能实现良性循环，促进鸿蒙生态的进一步扩展。
由于需要投入大量时间和精力来开发和维护新版本的应用，加上市场对应用需求不足以看到持续投入的价值，这导致了原生鸿蒙应用数量不够。
人才 根据公开信息显示，鸿蒙系统采用了全自研的底座架构，摒弃了传统的AOSP代码，只支持鸿蒙内核和鸿蒙系统应用。另外，HarmonyOSNEXT只能使用Hap格式的安装包，不再兼容安卓应用。
根据华为公布的数据，截至今年8月，已经有超过7亿台设备运行着鸿蒙操作系统。考虑到互联网生态中流量的重要性，大型厂商不太可能舍弃这一方面。然而，鸿蒙设备无法与安卓应用兼容。
换个说法，大厂们目前愿意开发适配鸿蒙5.0的产品，实际上是因为鸿蒙5.0不会对安卓应用开放，也就意味着无法继续使用安卓平台的应用。为了不损失一部分的用户流量，大厂只能选择这样做，可谓是无奈之举。
随后的11月8日，美团首先发布了鸿蒙高级工程师、鸿蒙基建工程师等多个相关职位。网易、新浪、去哪儿等互联网大公司也更新了多个鸿蒙相关的招聘信息，钉钉还发布了鸿蒙开发工程师岗位，月薪范围在2万元到5万元之间。
原生应用专为特定操作系统平台开发，比移植应用更加优化，可以提供更好的用户体验。在鸿蒙生态崛起的过程中，原生应用吸引人才布局是关键一步，所以大厂们发布了大量的招聘需求，以填补鸿蒙生态建设中的人才缺口。
在人才培养方面，华为也在提前做好准备，与产业界、科研机构和高等学府合作，进行全方位的投资。
那么作为一个鸿蒙（HarmonyOS）开发工程师，以下是你可能需要学习的一些关键技能和知识：
因为全文内容太多，这里节选一些经典部分让大家对此有一定的了解。并分成了七大专类，大家可以根据自己情况有选择性有针对性得学习。
有了鸿蒙开发学习路线，自然学习文档也是少不了的，耗时一星期整理出了 《鸿蒙 OS应用开发》（共计892页）的学习手册
《鸿蒙 (Harmony OS)开发学习手册》：鸿蒙实战经验分享：鸿蒙零基础入门开发宝典！
入门必看
1. 应用开发导读(ArkTS)
2. 应用开发导读(Java)
HarmonyOS 概念
1. 系统定义
2. 技术架构
3. 技术特性
4. 系统安全
如何快速入门？
1. 基本概念
2. 构建第一个ArkTS应用
3. 构建第一个JS应用
4. ……
开发基础知识
1. 应用基础知识
2. 配置文件
3. 应用数据管理
4. 应用安全管理
5. 应用隐私保护
6. 三方应用调用管控机制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/236f5e1c572a478af7e9aee38027bf49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da23584609efe675de845d64ffd0a2f/" rel="bookmark">
			SQL面试题挑战14：每年的在校人数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题：SQL解答： 问题： year表示学生入学年度，num表示对应年度录取学生人数，stu_len表示录取学生的学制；说明：例如录取年度2018学制是3年，表示该批学生在校年份为20182019、20192020、2020-2021，在算每年的在校人数时，2018/2019/2020/2021年份都需要算上。
以下是示例数据：
id year num stu_len 1 2018 2000 3 2 2019 2000 3 3 2020 1000 4 3 2020 2000 3 根据以上示例计算出每年的在校人数
SQL解答： 由于需要计算每年的在校人数，所以先要造出连续的年份。然后与源表进行关联，关联条件保证年份在入学年份和结束年份之间即可。
with temp as ( select 2018 as year,3 as stu_len,2000 as num union all select 2019 as year,3 as stu_len,2000 as num union all select 2020 as year,4 as stu_len,1000 as num union all select 2020 as year,3 as stu_len,2000 as num ) select t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1da23584609efe675de845d64ffd0a2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92fcefc791282dafa590a801f1771154/" rel="bookmark">
			【论文解读】用于概念标定的逻辑强化大模型LEFT（NeurIPS 2023）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：投稿 作者：橡皮
编辑：学姐
论文链接：https://arxiv.org/abs/2310.16035
开源代码：https://github.com/joyhsu0504/LEFT
摘要： VisProg 和 ViperGPT 等最新研究成果巧妙地组成了视觉推理的基础模型--利用大型语言模型（LLM）生成可由预先训练的视觉语言模型执行的程序。然而，它们只能在有限的领域（如二维图像）中运行，无法充分发挥语言的通用性：像 "左 "这样的抽象概念也可以基于三维、时间和动作数据，如向左移动。这种有限的泛化能力源于这些纯推理方法无法学习或调整预先训练好的模型以适应新的领域。我们提出了逻辑增强基础模型（LEFT），这是一个统一的框架，可以通过一个可区分的、与领域无关的、基于一阶逻辑的程序执行器，学习跨领域的概念基础和推理。LEFT 有一个 LLM 解释器，可输出以通用逻辑推理语言表示的程序，该语言可在所有领域和任务中共享。然后，LEFT 的执行器通过可训练的特定领域基础模块执行程序。我们展示了 LEFT 在四个领域中灵活学习概念的能力： 二维图像、三维场景、人体动作和机器人操作。它在各种任务中都表现出强大的推理能力，包括那些复杂的、在训练过程中未见过的任务，而且可以轻松地应用到新的领域。
图 1：LEFT 是一个统一的概念学习和推理框架，可跨领域地使用模块化概念，并通过基础模型灵活地在不同任务中使用概念进行推理。
1.引言 语言的力量在于其基于抽象的概括能力。一个单一的概念，如 "左"，可以跨领域使用：在感知中，我们可以从椅子的三维点云中识别出左腿；在导航中，我们可以绕过街区尽头的咖啡馆左转回家；在操作中，我们可以在盘子的左边挑选并放置一个杯子。左图在每个领域都有特定的基础，但概念符号本身作为一种抽象概念，是跨领域复杂和多步骤推理的基础。
用于视觉推理的机器系统也受益于概念学习与推理的分离。最近，VisProg和 ViperGPT等模型利用大型语言模型（LLM）来生成基于语言查询的程序。例如，要回答 "猫的颜色是什么？"，程序首先会定位猫的位置，然后查询猫的颜色。这些程序使用预先定义和训练好的视觉语言模型（如开放式词汇分割模型）进行定位和问题解答。这些作品在基于图像的推理方面表现出色，但令人惊讶的是，尽管语言似乎免费提供了通用性，但在其他领域的成功案例却不多。
要让可视化推理系统跨领域发挥作用，还剩下什么？我们发现现有方法存在两个关键缺陷。首先，这些方法仅限于推理，完全依靠预先训练好的模型来解释程序执行过程中的 "左 "等概念。因此，在数据稀缺的领域（如三维、人类运动或机器人动作），预训练模型（如果有的话）的表现并不理想。因此，我们需要可训练的系统来学习特定领域的基础概念，以便跨领域执行。不幸的是，这些可视化推理模型也无法做到可训练，因为它们存在第二个缺陷：它们依赖于一个不可分的程序执行器来组成这些基础模块。因此，尽管三维场景和机器人动作的基础可能不同于二维图像，但这些模块无法通过在这些领域的额外训练进行调整。
为了解决这些问题，我们提出了逻辑增强基础模型（LEFT），这是一种学习跨领域概念基础和推理的模型。LEFT 还利用 LLMs 进行语言解析；但与之前的工作不同的是，LEFT 具有可训练的概念基础模块，这些模块可从领域数据中学习，并通过一个可微分的、与领域无关的、基于一阶逻辑的程序执行器来实现。受之前通过可微分执行将符号程序与深度模型相结合的研究成果的启发，我们的设计不再需要人工设计特定领域的语言，而且有利于跨领域泛化。具体来说，LEFT 的 LLM 解释器将语言查询作为输入，解决文本歧义，并输出以一阶逻辑通用推理语言表示的非歧义程序，该程序可跨领域和任务共享。然后，LEFT 的执行器利用可学习的特定领域基础模块执行逻辑程序，这些模块由 LLM 生成的概念自动初始化。
LEFT 采用模块化结构，具有跨领域的高性能和数据效率优势。在单个领域内，LEFT 利用 LLM 解释器的一般推理能力，并通过通用一阶逻辑执行器有效地重新组合所学到的基础概念，从而将 "0-shot "泛化为未见过的复杂任务。LEFT 可被视为 VisProg 和 ViperGPT 的通用框架；在可获得预训练模型且不需要训练的领域（如二维图像），LEFT 同样可以仅用于推理。
我们在四个不同领域和七项任务上验证了 LEFT 的性能，包括二维问题解答、三维指代表达理解、时序推理和机器人操作。在性能和数据效率方面，通用 LEFT 模型明显优于之前针对特定任务的单一方法，其性能可与之前的神经符号方法相媲美，而且无需针对每个领域预先定义程序实现。重要的是，统一的 LEFT 框架可以进行跨领域的概念学习，并能在三个具有挑战性且从未见过的推理任务中实现零转移。相比之下，仅基于 LLM 的推理方法和一般视觉语言模型则无法实现泛化。
2.相关工作 基于LLM的分解框架。我们的框架集成了神经网络、逻辑推理和用于常识推理的大型语言模型。第一组相关文献研究基于LLM的方法。受 LLM 成功的启发 ，最近的许多工作提出了利用 LLM 将基于文本的任务分解为对现有模型的 API 调用序列的框架 。与 LEFT 相比，这些方法仅使用 LLM 和 API 模型进行推理，并且仅限于语言领域，无需学习模态基础。例如，LLM可能能够推理从语言推断出的对象类别，但它无法识别当前场景中的候选对象，或生成机器人动作来移动对象。 Gupta 和 Kembhavi以及 Surís 等人在图像上执行程序，但假设 API 可以访问一组可用模块，无需进一步培训。相比之下，LEFT 通过训练每种模态的概念嵌入来学习跨不同领域的模块化概念，而不需要任何预定义和预训练的模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92fcefc791282dafa590a801f1771154/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2dc5d5bef33b9f962c48f6b0943fa45/" rel="bookmark">
			前端通过iframe进行传值的方式：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 iframe项目里面的代码：
let postObj = { name: '张三', age: 12 } window.parent.postMessage(JSON.stringify(postObj), '*') // *的意思是嵌入这个iframe项目的所有地址的项目都能拿到这个数据 接收：
window.addEventListener('message', (event) =&gt; { // event.data 就是iframe传递过来的数据 }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c545f700b71291ac0b7885e489fafbf1/" rel="bookmark">
			SQL面试题挑战13：分组topN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 问题：SQL解答： 问题： 下面是某个班级的成绩表，需要筛选出每个科目前2名的学生信息。如果分数一样，名次是并列的，后面的同学名次就不连续。比如有2个同学是第一名，那么下一个同学的名次就是第3名，呈现1,1,3的名次排列。
stu_id stu_name subject score 1001 张三 语文 90 1001 张三 数学 80 1001 张三 英语 70 1002 李四 语文 90 1002 李四 数学 75 1002 李四 英语 80 1003 王五 语文 80 1003 王五 数学 70 1003 王五 英语 60 SQL解答： 非常典型的分组topN的问题，是面试经常被问到的。直接使用开窗函数排名即可，注意下row_number、rank、dense_rank三个开窗函数不同场景下的使用。
with temp as ( select 1001 as stu_id,'张三' as stu_name,'语文' as subject,90 as score union all select 1001 as stu_id,'张三' as stu_name,'数学' as subject,80 as score union all select 1001 as stu_id,'张三' as stu_name,'英语' as subject,70 as score union all select 1002 as stu_id,'李四' as stu_name,'语文' as subject,90 as score union all select 1002 as stu_id,'李四' as stu_name,'数学' as subject,75 as score union all select 1002 as stu_id,'李四' as stu_name,'英语' as subject,80 as score union all select 1003 as stu_id,'王五' as stu_name,'语文' as subject,80 as score union all select 1003 as stu_id,'王五' as stu_name,'数学' as subject,70 as score union all select 1003 as stu_id,'王五' as stu_name,'英语' as subject,60 as score ) select stu_id ,stu_name ,subject ,score from ( select stu_id ,stu_name ,subject ,score ,rank() over(partition by subject order by score desc) as rk from temp ) t1 where rk&lt;=2; ---结果： stu_id	stu_name	subject	score	1001 张三 数学 80	1002 李四 数学 75 1002 李四 英语 80	1001 张三 英语 70	1001 张三 语文 90 1002 李四 语文 90 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efcaa2b0dddf0e4854bb70520ca1466e/" rel="bookmark">
			Python UI 开发用哪个好？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 如果是原生支持的、不愿意折腾，那自然是Tkinter，默认就内置的GUI库，不需要额外做任何配置。
如果希望借助第三方工具包，那么我觉得PyQt、Kivy都不是我最喜欢的选择，因为我更加青睐DearPyGui。
DearPyGui是一款用C/C++开发的Python GUI工具包，它具有快速、强大、少依赖等突出优势。
目前这个项目在GitHub已经10.8k+ star了。
那么，DearPyGui相对而言，具备哪些优势？
具体的可以概括为如下几点：
现代化外观：在外观和UI设计方面， DearPyGui相对于其他工具更加现代化，视觉效果更好性能出色：它用C/C++开发，而且支持GPU渲染，性能很出色操作稳定：操作非常稳定流畅，而且支持异步函数快速绘图：在60 fps下显示超过100万数据点，支持缩放和平移节点编辑器：直观的用户交互内置演示：提供很好的学习支撑，能够快速学习所有功能开发者工具：主题和资源检查，运行时指标，调试器跨平台：支持Windows，Linux，MacOS 通过以上8点特性，使得DearPyGui无论是在基本能力方面，还是在开发者支持方面，相对于以往的GUI工具都要简单很多，也非常友好。
下面就以具体的使用案例介绍一下它如何使用。
安装 DearPyGui安装很简单，和其他Python工具包一样，可以直接通过pip命令安装：
pip install dearpygui or pip3 install dearpygui 使用 先来看一段具体的实现代码：
import dearpygui.dearpygui as dpg dpg.create_context() dpg.create_viewport() dpg.setup_dearpygui() def save_callback(): print("Save Clicked") with dpg.window(label="Example Window"): dpg.add_text("Hello world") dpg.add_button(label="Save", callback=save_callback) dpg.add_input_text(label="string") dpg.add_slider_float(label="float") dpg.show_viewport() dpg.start_dearpygui() dpg.destroy_context() 下面来介绍一下上面代码。
首先，前4行代码倒入DearPyGui工具包，然后进行视图初始化。
其次，是一个名为save_callback的回调函数，后面会绑定到按钮button上使用。
然后，就是打开一个窗口，依次添加了文本、按钮、输入框、滑动条4种常用组件。
最后，就是把显示视图。
下面看一下效果：
可以看得出来，它的使用方式是非常清晰，很容易理解的，不需要过多关注额外的内容就可以轻松实现一个GUI开发。
这个是比较简单的场景，在更为复杂的GUI开发方面它也同样可以轻松应对，下面看几个示例：
可以看得出来，无论是静态GUI还是动态的，它实现效果都很好，而且外观也很好看。
所以，现在做GUI开发我都是首选DearPyGui。
最后，码字不易，点个赞支持一下原创内容吧～
-END-
Python入门全套学习资料附带源码： Python全套学习路线 （以下所有资料文末免费领取）
Python零基础入门视频 Python项目源码 Python入门到进阶电子书籍和实战案例 👉100道Python练习题👈 检查学习结果。
👉面试刷题👈 资料领取 上述这份完整版的Python全套学习资料已经上传CSDN官方，朋友们如果需要可以微信扫描下方CSDN官方认证二维码输入“领取资料” 即可领取
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efcaa2b0dddf0e4854bb70520ca1466e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ab5014da7c0bc079cc4f636026429d/" rel="bookmark">
			Python如何进行内存管理？什么是垃圾回收机制?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python语言中，内存管理是由Python解释器自动处理的，它使用了一种称为垃圾回收的机制来管理内存。那么什么是垃圾回收机制?Python中如何进行内存管理?我们通过这篇文章来介绍一下。
Python使用垃圾回收机制来管理内存。垃圾回收机制是一种自动化的内存管理技术，它可以自动识别和回收不再使用的内存。Python中的垃圾回收机制有两种方式：引用计数和循环垃圾收集。
引用计数是Python中最简单、最基本的内存管理机制。它的原理是通过计数来管理内存。当对象被创建时，Python会为该对象创建一个引用计数。每当有一个变量引用该对象时，其引用计数就会加1。当该变量不再引用该对象时，其引用计数就会减1。当引用计数为0时，该对象就被认为是垃圾，Python会自动回收该对象的内存。
循环垃圾收集是Python中的另一种内存管理机制。它的原理是通过检测和回收不再使用的内存。当一个对象不再有任何引用时，它就变成了垃圾。但是，有些对象之间可能存在循环引用，即两个或多个对象之间相互引用。这种情况下，引用计数就无法判断是否回收这些对象。这时，Python就会启动循环垃圾收集机制来检测和回收这些对象。
扩展阅读：Python的内存分配机制
Python中的内存分配机制分为两种方式：固定大小内存池和动态内存分配。
固定大小内存池是Python的一种内存分配机制。Python将内存分成不同大小的块，并将这些块存放在内存池中。当程序需要分配内存时，Python会从内存池中获取一块内存，并分配给程序。当程序不再使用这块内存时，Python会将这块内存归还给内存池。
动态内存分配是Python的另一种内存分配机制。当程序需要分配内存时，Python会从操作系统中获取一块内存，并分配给程序。当程序不再使用这块内存时，Python会将这块内存归还给操作系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ed830d5e367c3fb5e7e5291c8beb8e/" rel="bookmark">
			uniapp门店收银，点击右边商品，商品会进入左边的购物车，并且，当扫码枪扫描商品条形码，商品也会累计进入购物车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果： 代码： &lt;template&gt; &lt;view class="container"&gt; &lt;view class="top" style="height: 10%; margin-bottom: 20rpx; box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.2);"&gt; &lt;view class="box" style="flex: 1; background-color: #4CAF50; display: flex; "&gt; &lt;/view&gt; &lt;view class="box" style="flex: 2; background-color: #4CAF50;"&gt; &lt;view class="inner-box" style="background-color: #fafafa; margin: 20rpx 20rpx 15rpx 20rpx; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;" @click="toUrl(`/pages/menstore/shouyin`)"&gt; &lt;view class="sub-inner-box"&gt; &lt;image src="/static/money.png" class="icon"&gt;&lt;/image&gt; &lt;text class="icon-text"&gt;收银&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class="inner-box" style="background-color: #fafafa; margin: 20rpx 20rpx 15rpx 20rpx; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4ed830d5e367c3fb5e7e5291c8beb8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d1f0566e30ecc397baaf171930020f/" rel="bookmark">
			vue-cli3/webpack打包时去掉console.log调试信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、terser-webpack-plugin是什么？二、使用配置vue-cli项目 前言 开发环境下，console.log调试信息，有助于我们找到错误，但在生产环境，不需要console.log打印调试信息，所以打包时需要将console.log调试信息过滤清除。
一、terser-webpack-plugin是什么？ 该插件使用 terser 来压缩 JavaScript。
terser-webpack-plugin是用来压缩 js 的，开发环境的console.log、debugger 等用来调试的信息，打包时都需要这个插件。
webpack v5 开箱即带有最新版本的 terser-webpack-plugin。如果你使用的是 webpack v5 或更高版本，同时希望自定义配置，那么仍需要安装 terser-webpack-plugin。如果使用 webpack v4，则必须安装 terser-webpack-plugin v4 的版本。
如果是vue-cli3的话，默认安装了terser-webpack-plugin，如果没安装下面可以直接复制。
npm install terser-webpack-plugin --save-dev 二、使用配置 vue-cli项目 vue-cli项目默认是基于webpack打包工具的，但是项目的配置文件是vue.config.js,其他项目在webpack.config.js配置
代码配置如下：
//vue.config.js const TerserPlugin = require('terser-webpack-plugin') module.exports = { configureWebpack: { optimization: { minimizer: [ new TerserPlugin({ terserOptions: { compress: { drop_console: true // 注释console } } }) ] } }, } 如果上面的配置文件无效可以试试下面的配置，参数不同，可能是因为版本不同，我的是webpack4，vue-cli3.
//vue.config.js const TerserPlugin = require('terser-webpack-plugin') module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75d1f0566e30ecc397baaf171930020f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d19d8de594b0460f6a8cedf228453827/" rel="bookmark">
			什么是shell?什么是Linux shell？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux操作系统中，shell是一个非常重要的存在，它是一个解释器，可以保护系统内核不被篡改的软件，一般所使用的系统中默认启动的shell是bash。那么什么是shell?shell变量分为哪几类?具体内容请看下文：
什么是shell?
Shell是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。
Shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。
什么是Linux shell?
Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。
实际上Shell是一个命令解释器，它解释由用户输入的命令并且把它们送到内核。不仅如此，Shell有自己的编程语言用于对命令的编辑，它允许用户编写由shell命令组成的程序。Shell编程语言具有普通编程语言的很多特点，比如它也有循环结构和分支控制结构等，用这种编程语言编写的Shell程序与其他应用程序具有同样的效果。
什么是shell脚本?
shell脚本，是一种为shell编写的脚本程序。
业界所说的shell通常都是指shell脚本，但是shell和shell script是两个不同的概念。
shell变量分为哪几类?
运行shell时，会同时存在三种变量：
1、局部变量：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
2、环境变量：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行，必要的时候shell脚本也可以定义环境变量。
3、shell变量：shell变量是由shell程序设置的特殊变量，shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e97dcf9640822b504a636ac18e97f7a/" rel="bookmark">
			【Week-P3】CNN天气识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、环境配置二、准备数据三、搭建网络结构四、开始训练五、查看训练结果六、总结6.1 不改变学习率的前提下，将训练epoch分别增加到50、60、70、80、90（1）epoch = 50 的训练情况如下：（2）epoch = 60 的训练情况如下：（3）epoch = 70 的训练情况如下：（4）epoch = 80 的训练情况如下：（5）epoch = 90 的训练情况如下： 6.2 在epoch=50、60、70、80、90的基础上修改固定学习率为动态学习率（1）epoch = 50 的训练情况如下：（2）epoch = 60 的训练情况如下：（3）epoch = 70 的训练情况如下：（4）epoch = 80 的训练情况如下：（5）epoch = 90 的训练情况如下： 🍨 本文为🔗365天深度学习训练营 中的学习记录博客🍖 原作者：K同学啊 | 接辅导、项目定制 🍺本文基础要求：
（1）本地读取并加载数据。
（2）测试集accuracy到达93%
🍻拔高：
（1）测试集accuracy到达95%
（2）调用模型识别一张本地图片
一、环境配置 # 1. 设置环境 import sys from datetime import datetime import torch import torch.nn as nn import torchvision.transforms as transforms import torchvision from torchvision import transforms, datasets import os,PIL,pathlib,random print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e97dcf9640822b504a636ac18e97f7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01733cc510b3c024322f4a607979c8b8/" rel="bookmark">
			新字符设备驱动框架代码搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 简介 前面一篇文章简单了解了，新字符设备驱动框架涉及的函数。文章地址如下：
新字符设备驱动所涉及的函数-CSDN博客
本文来使用 新字符设备驱动框架来实现字符设备的注册与卸载。
二. 新的字符设备驱动框架搭建 1. 创建工程 首先，创建文件夹。这里我的驱动代码都放在 ubuntu系统 /home/wangtian/zhengdian_Linux目录下，进入 /Linux_Drivers 目录下，创建文件夹为 3_newchrled：
wangtian@wangtian-virtual-machine:~/zhengdian_Linux/Linux_Drivers$ mkdir 3_newchrled
将 2_led工程下的 .vscode及其以下文件，拷贝到 3_newchrled 文件夹下（.vscode及其以下文件中配置了 所调用的 Linux内核源码路径）：
wangtian@wangtian-virtual-machine:~/zhengdian_Linux/Linux_Drivers/3_newchrled$ cp ../2_led/.vscode/ ./ -rf 将 2_led工程下的 Makefile文件拷贝到 该工程下：
wangtian@wangtian-virtual-machine:~/zhengdian_Linux/Linux_Drivers/3_newchrled$ cp ../2_led/Makefile ./ 更改 Makefile文件中涉及编译目标名 obj-m的所指向的名：
obj-m := newchrled.o 通过 vscode打开 3_newchrled 文件夹。在 3_newchrled文件夹下创建 newchrled.c 文件。
可以参考 2_led实验的代码，在 newchrled.c加入 头文件， 寄存器的物理地址，映射后的虚拟地址指针，以及 led的开关灯宏：
#include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/uaccess.h&gt; #include &lt;linux/io.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01733cc510b3c024322f4a607979c8b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84af3ae09b22b795f9e7f127d1faec28/" rel="bookmark">
			【JavaWeb】day01-HTML&amp;CSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day01-HTML&amp;CSS HTML 图片标签：&lt;img&gt;
src：指定图像URL（绝对路径/相对路径）width：图像宽度（像素/相对于父元素的百分比）height：图像高度（像素/相对于父元素的百分比） 标题标签：&lt;h1&gt; - &lt;h6&gt;
水平线标签：&lt;hr&gt;
&lt;body&gt; &lt;!-- img标签： src：图片资源路径 width：宽度(px:像素; %:相对于父元素的百分比) height：高度(px:像素; %:相对于父元素的百分比) 路径书写方式： 绝对路径： 1.绝对磁盘路径：D:\Desktop\JavaWeb学习\HTML\img\news_logo.png &lt;img src="D:\Desktop\JavaWeb学习\HTML\img\news_logo.png"&gt; 2.绝对网络路径：https://i2.sinaimg.cn/dy/deco/2012/0613/yocc20120613img01/news_logo.png 相对路径： ./ 当前目录 ../ 上一级目录 --&gt; &lt;img src="img/news_logo.png"&gt; 新浪政务 &gt; 正文 &lt;h1&gt;焦点访谈：中国底气 新思想夯实大国粮仓&lt;/h1&gt; &lt;hr&gt; 2023年03月02日 21:50 央视网 &lt;hr&gt; &lt;/body&gt; 超链接：&lt;a&gt; href：指定资源访问的urltarget：指定在何处打开资源链接 _self：默认值，在当前页面打开_blank：在空白页面打开 &lt;a href="http://gov.sina.com.cn/" target="_self"&gt;新浪政务&lt;/a&gt; &lt;style&gt; a:hover { color: #FF6600; /* 鼠标悬停时改变颜色 */ } a { color: black; text-decoration: none; /* 去除下划线 */ } &lt;/style&gt; 视频标签：&lt;video&gt;
src：规定视频urlcontrols：显示播放控件width：播放器宽度height：播放器高度 音频标签：&lt;audio&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84af3ae09b22b795f9e7f127d1faec28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b475eefe9a3ccb29a25c993514e9bc9/" rel="bookmark">
			[足式机器人]Part4 南科大高等机器人控制课 CH12 Robotic Motion Control
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供学习使用
本文参考：
B站：CLEAR_LAB
笔者带更新-运动学
课程主讲教师：
Prof. Wei Zhang
课程链接 ：
https://www.wzhanglab.site/teaching/mee-5114-advanced-control-for-robotics/
南科大高等机器人控制课 Ch12 Robotic Motion Control 1. Basic Linear Control Design1.1 Error Response1.2 Standard Second-Order Systems1.3 Second-Order Response Characteristics1.4 State-Space Controller Design 2. Motion Control Problems2.1 Robotic Motion Control Problem2.2 Variations in Robot Motion Control 3. Motion Control with Velocity/Acceleration as Input3.1 Velocity-Resolved Control3.2.1 Velocity-Resolved Joint Space Control3.2.2 Velocity-Resolved Task Space Control 3.2 Acceleration-Resolved Control3.2.1 Acceleration-Resolved Control in Joint Space3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b475eefe9a3ccb29a25c993514e9bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c653b2cb3d11c625655821dc9f592e/" rel="bookmark">
			什么是安全漏洞？主要分为哪几类？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞，是指在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而可以使攻击者能够在未授权的情况下访问或破坏系统。漏洞的出现，不仅会造成个人隐私信息泄露，还涉及到我们的财产安全，那么网络安全漏洞的种类分为哪些?接下来小编就带大家认识一下吧。
第一：软件漏洞
任何一种软件或多或少都存在一定的脆弱性，安全漏洞可视作已知系统脆弱性。这种安全漏洞可以分为两种：一种是由于操作系统本身设计缺陷带来的漏洞，它将被运行在这个系统上的应用程序所继承;另一种是应用软件程序安全漏洞，比较常见，更要引起广泛关注。
第二：结构漏洞
网络中忽略了安全问题，没有采取有效的网络安全措施，使网络系统处于不设防的状态;另外，有一些重要网段中，交换机和集线器等网络设备设置不当，造成网络流量被不法获取。
第三：配置漏洞
网络中忽略了安全策略的制定，即使采取了网络安全措施，但由于安全配置不合理或不完整，安全没有发挥作用。在网络发生变化后，没有及时更改系统内部安全配置而造成安全漏洞。
第四：管理漏洞
网络管理者不小心造成的安全漏洞，比如管理员口令太短或者长期不更改密码，造成口令攻击;两台服务器共同使用一个用户名或者口令，如果一个服务器被入侵，另外一个服务器也很危险。
第五：信任漏洞
过分信任外来合作者的机器，一旦这个机器被入侵，则网络安全受到严重危险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2f8b3176d897704ec79e112dd912e4/" rel="bookmark">
			二叉树之堆的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
堆排序
思路详解
Ⅰ 建堆
Ⅱ 利用堆的删除思想来进行排序 功能接口
向上调整算法
向下调整算法
主函数
运行结果展示
TOP - K问题
思路详解
Ⅰ 用数据集合中前K个元素来建堆
Ⅱ 用剩余的N-K个元素依次与堆顶元素来比较，不满足则替换堆顶元素
功能接口
建小堆所需的向上调整算法
向下调整算法
创建数据集合的文件创建接口
堆排序接口
TOP-K
运行结果展示
结语
堆排序 所谓堆排序，即是使用堆的思想来进行排序。
在堆中，我们逻辑上想象他是一棵树，但实际在物理上它是一个数组。
思路详解 Ⅰ 建堆 如果我们要将数据升序排列，那我们需要建大堆，如果降序排列，则建小堆。
升序：建大堆；
降序：建小堆。
Ⅱ 利用堆的删除思想来进行排序 以升序为例，假设此时我们已经完成了大堆的创建。
还记得堆是如何删除的吗？
我们将堆顶与堆尾互换，然后删除堆尾，再向下调整。
但在堆排序中，我们互换之后并不删除堆尾，只是不再对堆尾进行操作。
试想，一个大堆，堆顶元素自然是最大的数据，当我们交换堆顶堆尾，最大的元素就到了堆尾，我们不再对其进行操作，逻辑上将其暂时剥离数组，随后再进行向下调整。循环往复。
我们来画图看看：
功能接口 有关堆的一些基础特性可查看我的另一篇文章。数据结构之树 --- 二叉树-CSDN博客
向上调整算法 该接口建堆时使用。
//小堆 void SmaADjustUP(int* a, int child) { int parent = (child - 1) / 2; while (child &gt;= 0) { if (a[child] &lt; a[parent]) { swap(&amp;a[child], &amp;a[parent]); child = parent; parent = (parent - 1) / 2; } else break; } } 向下调整算法 void SmaADjustDown(int *a,int size,int parent) { int child = parent * 2 + 1; while (child &lt; size) { if (child+1 &lt; size &amp;&amp; a[child] &gt; a[child + 1]) { child = child + 1; } if (a[child] &lt; a[parent]) { swap(&amp;a[child], &amp;a[parent]); parent = child; child = parent * 2 + 1; } else break; } } 当然，只使用向下调整算法也是可以的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2f8b3176d897704ec79e112dd912e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/807301ce1296b12c3a1692f112c14e2c/" rel="bookmark">
			百度地图再vue中的引入方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用方式一 1.在public-&gt;index.html引入
&lt;script src="http://api.map.baidu.com/api?v=2.0&amp;ak=你的ak&amp;callback=initBMap"&gt;&lt;/script&gt; ak=自己的密钥
2.若是vue2.0就是lib/webpack.base.conf.js加入以下代码，若是vue3.0就在最外层创建一个这个文件
module.exports = { //百度地图配置 externals: { BMap: "BMap" } }; 3.在vue文件 mounted挂载
&lt;div id="map" ref="map"&gt;&lt;/div&gt;
mounted() { // const _this = this; var map = new window.BMap.Map("map"); map.centerAndZoom(new window.BMap.Point(121.450474, 31.194434), 20); // 初始化地图,设置中心点坐标和地图级别 //添加地图类型控件 map.addControl( new window.BMap.MapTypeControl({ mapTypes: [window.BMAP_NORMAL_MAP, window.BMAP_HYBRID_MAP] }) ); map.setCurrentCity("上海"); // 设置地图显示的城市 此项是必须设置的 map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放 var point = new window.BMap.Point(121.450474, 31.194434, 15); var marker = new window.BMap.Marker(point); // 创建标注 map.addOverlay(marker); // 将标注添加到地图中 //点击标注 marker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/807301ce1296b12c3a1692f112c14e2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8faef587163917dbeca042f651cfdf63/" rel="bookmark">
			CSS新手入门笔记整理：CSS3属性表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本样式 属性
属性值
说明
text-shadow
数值 文本阴影
text-stroke
数值 文本描边
text-overflow
ellipsis（文本溢出时，显示省略号，隐藏多余的文字）clip（文本溢出时，不显示省略号，裁切多余的文字） 文本溢出
word-wrap
normal（自动换行）break-word（强制换行） 强制换行
word-break
normal（自动换行）break-all（允许在单词内换行）keep-all（只能在半角空格或连字符处换行） @font-face
字体 嵌入字体
颜色样式 属性
属性值
说明
opacity
0.0完全透明1.0完全不透明 透明度
rgba(R, G, B,A)
RGBA颜色
oackground:linear-gradient(方向, 开始颜色, 结束颜色)
线性渐变
ackground:radial-gradient(位置，开始色，结束色)
径向渐变
边框样式 属性
属性值
说明
border-radius
px/em /百分比
圆角效果
box-shadow
数值
边框阴影
border-colors
色值
多色边框
border-image
url（图片路径）
边框背景
背景样式 属性
属性值
说明
background-size
数值
背景大小
background-origin
border-box（从边框开始平铺）padding-box（从内边距开始平铺）content-box（从内容区开始平铺） 背景位置
background-clip
border-box（从边框开始剪切）padding-box（从内边距开始剪切）content-box（从内容区开始剪切） 背景剪切
CSS3变形 属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8faef587163917dbeca042f651cfdf63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d64f129889ba82c6c84776c64922d97/" rel="bookmark">
			MySQL：报错:1130-host ... is not allowed to connect to this MySql server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错:1130-host ... is not allowed to connect to this MySql server
1、改表法 可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 "mysql" 数据库里的 "user" 表里的 "host" 项，从"localhost"改称"%"
mysql -u root -pvmwaremysql&gt; use mysql; mysql&gt; update user set host = '%' where user = 'root'; mysql&gt; select host, user from user; 2、授权法 例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话
GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; FLUSH PRIVILEGES; 如果你想允许用户myuser从ip为192.168.1.6的主机连接到mysql服务器，并使用mypassword作为密码
GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'192.168.1.3' IDENTIFIED BY 'mypassword' WITH GRANT OPTION; FLUSH PRIVILEGES; 如果你想允许用户myuser从ip为192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d64f129889ba82c6c84776c64922d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26c437ebb15fce2a4c42915ad122b432/" rel="bookmark">
			一文详解Cookie以及Selenium自动获取Cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 以后数据获取途径以及数据资产绝对会是未来核心要素生产工具和资源之一，每个大模型都离不开更加精细化数据的二次喂养训练。不过现在来看收集大量数据的方法还是有很多途径的，有些垂直领域的专业数据是很难获取得到的，靠人力去搜寻相当费时费力，而且处理起来也很麻烦，关键是不能准确的获取强相关数据就对项目开展妹太大帮助。之前本人一直从事的是大数据算法工作，对数据获取和收集这方面也有不错的技术开展，目前将开展新的技术专栏，将把深耕到数据收集和获取这方面的技术展现复盘。
1.什么是Cookie 很多时候我们发现如果我们这网页上面登录过账号，下次再访问该网站就会发现不用再输入密码账号就能登录了。想象一下你去一家咖啡店。第一次去，你告诉店员你的名字和你喜欢的咖啡类型。店员记住了这些信息。下次你再去，店员看到你就知道你叫什么名字，也知道你喜欢什么咖啡，于是直接为你准备了你喜欢的咖啡。
在这个例子中，咖啡店就像一个网站，你就像是访问网站的用户。你提供的名字和咖啡偏好就像是你在网站上输入的信息。咖啡店员记住你的信息，这就像网站在你的电脑上存储Cookie一样。所以，Cookie就是网站为了记住用户的偏好或者身份信息而存储在用户电脑上的小型数据文件。这样，下次你访问同一个网站时，它可以快速地识别你，并根据存储的信息定制内容，就不用再次账号登录了。
在了解到了cookie具有什么样的功能以后，我们再来对cookie更加深入的了解。
2.Cookie的作用和数据形式 有时候浏览网站会出现：
的弹窗提示，根据弹窗提示其实我们就能够看出cookie的一些作用：能够发现我们的需求，还能分析我们的流量和网站使用情况，也就是监视我们用户的浏览习惯和活动。广告商还能使用Cookie来收集关于我们的信息，以显示更相关的广告。这是基于你的浏览历史和其他在线行为，所以这就是为什么我们之前搜了某某用品，某宝某东就直接开始推送了，还有视频网站某书和某站也会陆续推送相关视频。当然如果你开了无痕模式，那么浏览器也不会保存cookie。
总结一下cookie的作用，有以下几点：
身份认证和会话管理：当你登录一个网站后，该网站会使用Cookie来记住你的登录状态，这样你就不必在每次访问新页面时都重新登录。个性化设置：网站利用Cookie存储个性化设置，比如语言偏好、主题选择等，以便在你下次访问时提供相同的定制体验。追踪和分析：网站使用Cookie来追踪用户的浏览习惯和活动。这对于网站改进其内容和结构、提供更加个性化的体验非常有用。广告定位：广告商使用Cookie来收集关于你的信息，以显示更相关的广告。这是基于你的浏览历史和其他在线行为的。过期时间：Cookie可以设置不同的过期时间。有些在关闭浏览器时就会消失（会话Cookie），而另一些则会在特定日期后才会消失（持久性Cookie）。隐私和安全：虽然Cookie对提升网站体验很重要，但它们也引发了隐私和安全上的担忧。用户通常可以在浏览器设置中管理Cookie，包括删除和禁用它们。第三方Cookie：除了由网站直接设置的Cookie（第一方Cookie）外，还有第三方Cookie，通常由广告商和分析服务提供商设置，用于跨网站追踪用户行为。 了解以上几点之后，我们再来看看cookie具体存储的数据格式是怎么样的。每个浏览器对于cookie的存储和设置都不一样，以火狐浏览器为例，直接在浏览器搜索设置就可以看到：
在下方可以看到浏览器存储的cookie：
点击管理数据
如果经常浏览某个网站，我这里是bilibili，就会发现存储的cookie占用内存特别多，也就是存储你的个性行为特别多。那么如何查看一个cookie呢？
根据步骤来，以CSDN为例，输入F12进入开发者模式，点击存储，在界面左边都能看到存储的Cookie：
一般cookie是一段不超过4KB的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。有些服务端设置都cookie很复杂，关键字段就很多，有些就非常简单。
3.cookie属性 我们现了解cookie保存的数据都有哪些属性
(1)Name/Value：名称和值设置Cookie的名称及相对应的值，对于认证Cookie，Value值包括Web服务器所提供的访问令牌。
(2)Domain属性：指定了可以访问该 Cookie 的 Web 站点或域。Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在Domain属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。
(3)Path属性：定义了Web站点上可以访问该Cookie的目录，一般csrToken就有此属性。
(4)Expires属性：设置Cookie的生存期。有两种存储类型的Cookie：会话性与持久性。Expires属性缺省时，为会话性Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效；持久性Cookie会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。
(5)Secure属性：指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的[证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。由于许多用户缺乏安全意识，因而仍可能连接到Pharming攻击所伪造的网站
(6)HTTPOnly 属性 ：用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头
这都是每一条cookie元素所自带的属性，那么我们再聚焦于cookie的名称一般都有哪些含义。
4.Cookie名称 Cookie的名称（Name）是用来唯一标识不同的Cookie。名称可以根据Cookie的用途来命名，以下是一些常见的Cookie名称和它们的用途：
名称(Name)用途session_id/PHPSESSID用于标识用户的会话。这种类型的Cookie通常用于登录后保持用户状态。user_id /uid用来标识特定用户，可能用于跟踪或个性化。remember_me通常与长期登录功能有关，用于记住用户的登录状态。token /auth_token用于存储身份验证令牌，通常用于API调用或维持登录状态。preferences /settings保存用户设置和偏好，例如界面主题、语言设置等。cart/shopping_cart对于电商网站，用来跟踪用户的购物车内容。analytics /tracking_id用于网站分析和用户跟踪，可能用于统计用户访问行为。csrftoken/ XSRF-TOKEN于跨站请求伪造（CSRF）保护。ads/ ad_id广告相关的跟踪，用于个性化广告显示。locale/ language存储用户的语言偏好。cookie_consent/ consent记录用户对Cookie使用的同意。 以上基本是cookie包含的所有标识了，当然也有很多网站的cookie有更多其他的业务或者是其他笔记防范爬虫等机制，下面我们来利用Python Selenium来获取我们当前的cookie。
5.获取Cookie 获取Cookie的方法特别多，可以用Web浏览器中的JavaScript，可以通过document.cookie属性来访问当前页面的Cookie。也可以在HTTP请求头中接收Cookie。例如，在PHP中，可以通过$_COOKIE全局数组访问Cookie；在Node.js中，可以通过HTTP请求对象的headers.cookie属性访问。或者Python的Requests, Node.js的Axios等。这里展示如何用浏览器自动化工具Selenium来提取浏览器的cookie。如果对selenium不了解的推荐去看博主写的selenium详细介绍的博客。
首先引入库：
from selenium import webdriver cookie登入前和登入后所存储的是不一致的，所以我们可以前后两次获取cookie看哪些值是存在变动的，这次获取的是csdn博客cookie。
def password_login(self): self.driver = webdriver.Firefox() self.driver.get("https://blog.csdn.net/") cookieBefore = self.driver.get_cookies() time.sleep(2) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26c437ebb15fce2a4c42915ad122b432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f565da213d94e06b598ce46d619ff76/" rel="bookmark">
			flink 实时写入 hudi 参数推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据湖任务并行度计算
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a4492316809ad2e51ad6a492ee5441/" rel="bookmark">
			大创项目推荐 深度学习中文汉字识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 数据集合2 网络构建3 模型训练4 模型性能评估5 文字预测6 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 深度学习中文汉字识别
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 数据集合 学长手有3755个汉字（一级字库）的印刷体图像数据集，我们可以利用它们进行接下来的3755个汉字的识别系统的搭建。
用深度学习做文字识别，用的网络当然是CNN，那具体使用哪个经典网络？VGG?RESNET？还是其他？我想了下，越深的网络训练得到的模型应该会更好，但是想到训练的难度以及以后线上部署时预测的速度，我觉得首先建立一个比较浅的网络（基于LeNet的改进）做基本的文字识别，然后再根据项目需求，再尝试其他的网络结构。这次任务所使用的深度学习框架是强大的Tensorflow。
2 网络构建 第一步当然是搭建网络和计算图
其实文字识别就是一个多分类任务，比如这个3755文字识别就是3755个类别的分类任务。我们定义的网络非常简单，基本就是LeNet的改进版，值得注意的是我们加入了batch
normalization。另外我们的损失函数选择sparse_softmax_cross_entropy_with_logits，优化器选择了Adam，学习率设为0.1
​
#network: conv2d-&gt;max_pool2d-&gt;conv2d-&gt;max_pool2d-&gt;conv2d-&gt;max_pool2d-&gt;conv2d-&gt;conv2d-&gt;max_pool2d-&gt;fully_connected-&gt;fully_connected def build_graph(top_k): keep_prob = tf.placeholder(dtype=tf.float32, shape=[], name='keep_prob') images = tf.placeholder(dtype=tf.float32, shape=[None, 64, 64, 1], name='image_batch') labels = tf.placeholder(dtype=tf.int64, shape=[None], name='label_batch') is_training = tf.placeholder(dtype=tf.bool, shape=[], name='train_flag') with tf.device('/gpu:5'): #给slim.conv2d和slim.fully_connected准备了默认参数：batch_norm with slim.arg_scope([slim.conv2d, slim.fully_connected], normalizer_fn=slim.batch_norm, normalizer_params={'is_training': is_training}): conv3_1 = slim.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66a4492316809ad2e51ad6a492ee5441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51c6e03d05f5c737bcdeb67d4cf2c30a/" rel="bookmark">
			数据结构与算法之美学习笔记：42 | 动态规划实战：如何实现搜索引擎中的拼写纠错功能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言如何量化两个字符串的相似度？如何编程计算莱文斯坦距离？如何编程计算最长公共子串长度？解答开篇 前言 本节课程思维导图：
利用 Trie 树，可以实现搜索引擎的关键词提示功能，这样可以节省用户输入搜索关键词的时间。实际上，搜索引擎在用户体验方面的优化还有很多，比如你可能经常会用的拼写纠错功能。
当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。作为一名软件开发工程师，你是否想过，这个功能是怎么实现的呢？
如何量化两个字符串的相似度？ 要解答开篇的问题，我们就要先来看，如何量化两个字符串之间的相似程度呢？有一个非常著名的量化方法，那就是编辑距离（Edit Distance）。
顾名思义，编辑距离指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。
根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有莱文斯坦距离（Levenshtein distance）和最长公共子串长度（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。
而且，莱文斯坦距离和最长公共子串长度，从两个截然相反的角度，分析字符串的相似程度。莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。
关于这两个计算方法，我举个例子给你说明一下。这里面，两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4。
如何编程计算莱文斯坦距离？ 了解了编辑距离的概念之后，我们来看，如何快速计算两个字符串之间的编辑距离？我现在就给你展示一下，解决这个问题，我的完整的思考过程。
这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合多阶段决策最优解模型。
我们前面讲了，贪心、回溯、动态规划可以解决的问题，都可以抽象成这样一个模型。要解决这个问题，我们可以先看一看，用最简单的回溯算法，该如何来解决。
回溯是一个递归处理的过程。
如果 a[i]与 b[j]匹配，我们递归考察 a[i+1]和 b[j+1]。
如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：
可以删除 a[i]，然后递归考察 a[i+1]和 b[j]；可以删除 b[j]，然后递归考察 a[i]和 b[j+1]；可以在 a[i]前面添加一个跟 b[j]相同的字符，然后递归考察 a[i]和 b[j+1];可以在 b[j]前面添加一个跟 a[i]相同的字符，然后递归考察 a[i+1]和 b[j]；可以将 a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]。
代码如下： private char[] a = "mitcmu".toCharArray(); private char[] b = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51c6e03d05f5c737bcdeb67d4cf2c30a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0dfa904b455879019b694ed3a61991b/" rel="bookmark">
			Conda 创建环境python3.10.12 并链接上vscode,进行远程的开发python‘项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在远程 Ubuntu 服务器上使用 Conda 创建一个特定版本的 Python 环境（例如 Python 3.10.12），并通过 VS Code 进行远程开发，您可以按照以下步骤操作：
步骤 1: 在远程服务器上创建 Conda 环境 打开远程服务器的终端：
如果您已经在服务器上，直接打开终端。如果您是通过 SSH 连接到服务器的，首先登录到服务器。
创建新的 Conda 环境：
使用 Conda 创建一个新环境，并指定 Python 版本为 3.10.12。您可以给环境指定一个名字，比如 myenv：
conda create -n myenv python=3.10.12 激活新环境：
创建环境后，激活该环境：
conda activate myenv 安装所需的 Python 包：
在您的新环境中安装任何所需的包。例如，安装 NumPy 和 Pandas：
conda install numpy pandas 步骤 2: 设置 VS Code 进行远程开发 确保安装了 Remote - SSH 扩展：
如果您还没有在 VS Code 上安装 Remote - SSH 扩展，请安装它。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0dfa904b455879019b694ed3a61991b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4eca86804de86e9d384b8e50db13e3a/" rel="bookmark">
			ubuntu安装conda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Ubuntu 系统上安装 Anaconda 是一个直接的过程。Anaconda 是一个流行的 Python 和 R 数据科学及机器学习平台，它包括了许多科学计算和数据处理的库。以下是在 Ubuntu 上安装 Anaconda 的步骤：
1. 下载 Anaconda 安装脚本 首先，需要从 Anaconda 的官方网站下载安装脚本。
访问 Anaconda 官网。滚动到 “Anaconda Installers” 部分，并下载适用于 Linux 的 Anaconda 安装程序。或者，您可以使用 wget 在终端中直接下载。找到适用于 Linux 的安装脚本链接，并使用类似以下的命令：wget https://repo.anaconda.com/archive/Anaconda3-2023.09-0-Linux-x86_64.sh 确保链接指向最新版本。 2. 运行安装脚本 在下载完成后，运行安装脚本。
赋予脚本执行权限：chmod +x Anaconda3-2023.09-0-Linux-x86_64.sh 运行安装脚本： sh Anaconda3-2023.09-0-Linux-x86_64.sh
跟随屏幕上的指示完成安装。 ### 3. 接受许可协议 在安装过程中，您需要阅读并同意许可协议。 ### 4. 选择安装位置 安装程序会提示您选择安装位置。您可以接受默认位置或指定新位置。 ### 5. 初始化 Anaconda 在安装的最后阶段，安装程序会询问您是否将 Anaconda 添加到您的 PATH 环境变量。建议您同意这一操作，以便在终端中直接使用 Anaconda。 ### 6. 重新加载终端或重新登录 安装完成后，您可能需要重新加载您的终端或注销并重新登录，以使更改生效。 ### 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4eca86804de86e9d384b8e50db13e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f70fcb8a2647aa800080431f0f3b9f09/" rel="bookmark">
			o2o生活通全开源尊享版&#43;多城市切换&#43;企业付款&#43;交友IM&#43;平台快报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建教程
1.把 pigo2ov282.sql 文件里面的网址 test.souho.net 全部批量替换为你的自己的
2.使用 phpmyadmin 导入 pigo2ov282.sql 到你的数据库（直接访问/phpmyadmin 即可）
3.修改数据库文件/conf/db.php 里的数据库连接信息（请勿使用记事本和写字板修改文件）
4.网站后台：/admin.php
5.配置好伪静态！必须配置好，否则静态页面全部无法访问！！！
（程序默认只有 Apache 的伪静态规则，如需在 iis 等其它环境下使用请自行转换成对应规则）
6.登陆后台之后清空缓存！
其它说明：
手机版访问地址：/wap.php
如要使用多城市，需要使用独立服务器且必须设置泛域名解析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/607961bd4e24a8baab3486d3dc6c99c3/" rel="bookmark">
			分享一个电子元器件数据手册查询的网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接：Datasheet catalog for integrated circuits, diodes, triacs, and other semiconductors, view
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe0865053c3be530ce70f5a96f6feed/" rel="bookmark">
			关于softlockup和rcu stall错误分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理： 软锁需要开启CONFIG_LOCKUP_DETECTOR内核选项，源码kernel/watchdog.c。 情况宋宝华的博文：Linux内核为什么会发生soft lockup？-CSDN博客 watchdog_timer_fn ：per_cpu 定时器回调 判断(softlockup_completion) 已经completion ？ yes:	stop_one_cpu_nowait //借用stop_machine 内核线程来工作(migration/X)，工作函数softlockup_fn cpu_stop_queue_work //将cpu_stop_work 插入， wake_up_q //并唤醒 wake_q_head关联的stop_machine内核线程(migration/X) no: 检测是否超过20s ？ 工作函数：softlockup_fn static int softlockup_fn(void *data) { __this_cpu_write(soft_lockup_hrtimer_cnt, __this_cpu_read(hrtimer_interrupts)); __touch_watchdog(); complete(this_cpu_ptr(&amp;softlockup_completion)); //complete return 0; } 文章提到：在开启 CONFIG_PREEMPT=y 的时候，且没有关闭本地irq的时候，在内核中断el1_irq：
SYM_CODE_START_LOCAL_NOALIGN(el1_irq) kernel_entry 1 gic_prio_irq_setup pmr=x20, tmp=x1 enable_da_f mov x0, sp bl enter_el1_irq_or_nmi irq_handler #ifdef CONFIG_PREEMPTION ldr x24, [tsk, #TSK_TI_PREEMPT] // get preempt count alternative_if ARM64_HAS_IRQ_PRIO_MASKING /* * DA_F were cleared at start of handling.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe0865053c3be530ce70f5a96f6feed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccb0caff6b8478e58de46bac53a25db3/" rel="bookmark">
			＜router-view＞ can no longer be used directly inside ＜transition＞ or ＜keep-alive＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报警截图： 报警信息： vue-router.mjs:35 [Vue Router warn]: &lt;router-view&gt; can no longer be used directly inside &lt;transition&gt; or &lt;keep-alive&gt;. Use slot props instead: &lt;router-view v-slot="{ Component }"&gt; &lt;transition&gt; &lt;component :is="Component" /&gt; &lt;/transition&gt; &lt;/router-view&gt; 解决办法 照着浏览器提示，改一下就行 &lt;router-view v-slot="{ Component }"&gt; &lt;transition name="el-zoom-in-top"&gt; &lt;component :is="Component" /&gt; &lt;/transition&gt; &lt;/router-view&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580f86275682a30039cf4c6835a39179/" rel="bookmark">
			2012年第一届数学建模国际赛小美赛B题大规模灭绝尚未到来解题全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2012年第一届数学建模国际赛小美赛 B题 大规模灭绝尚未到来 原题再现： 亚马逊是地球上现存最大的雨林，比地球上任何地方都有更多的野生动物。它位于南美洲大陆的北侧，共有9个国家：巴西、玻利维亚、厄瓜多尔、秘鲁、哥伦比亚、委内瑞拉、苏里南、法属圭亚那和圭亚那。这类信息需要更加普及，因为砍伐森林正成为森林生存的危险。虽然伐木和森林清理在短期内可能有利可图，但从长远来看，这对亚马逊来说是一种危险。
近年来，森林砍伐率下降到创纪录的低点，巴西50%以上的雨林现在处于某种形式的保护状态。但栖息地丧失的影响需要时间来显现。伦敦帝国理工学院的生态学家罗伯特·埃沃斯说：“砍伐树木并不会直接杀死一只鸟。这些鸟实际上需要很多时间才能死亡。它们都挤进了剩下的栖息地。然后，死亡率会逐渐增加。
要求：
模拟森林砍伐的影响以及在不久的将来是否会发生大规模灭绝。
使用您的模型来估计未来20年内有多少物种将灭绝，请考虑以下四种情况：“一切照旧”，或很少监管治理”，或某种规定根据巴西政府的目标，到2020年将森林砍伐减少80%；到2020年“结束森林砍伐”。
写一份20页的报告（不包括汇总表），介绍你的模型和你对毁林滞后影响的分析。一定要包括政府在确保生态安全方面应该扮演的角色。
整体求解过程概述(摘要) 近年来，在丰富的热带雨林中，特别是在亚马逊河流域，森林砍伐率达到了前所未有的水平，导致生态环境发生变化，许多物种因丧失生活习惯而灭绝。由于亚马逊在巴西的面积最大，本文以巴西的数据为基础进行讨论。到目前为止，已经有许多关于森林砍伐的影响和大灭绝估计的研究。然而，现有的研究大多基于一个方面，为了更深入地探讨这些问题，我们考虑了典型相关分析方法来讨论毁林对经济和生态的影响，并利用偏最小二乘回归方法（PLS）建立了回归函数。
通过求解模型，得到一组典型变量（见方程（1.1）和（1.2）），说明森林砍伐对经济的影响最大，其次是畜牧业。结果表明，当地经济发展的需要，特别是农业经济发展的需要，是热带雨林砍伐的外部驱动因素。基于PLS得到的方程表明，森林砍伐使CO2排放量和濒危物种数量增加，人均可再生淡水资源减少，对生态环境造成严重破坏，对许多野生动物构成巨大威胁。
随后，对于近期是否会发生大灭绝的问题，首先采用非线性函数对毁林曲线进行拟合，拟合函数可以在方程（3.4）中观察到，利用该函数可以预测巴西未来的毁林情况。结合该结果和方程（3.3），预测2014年濒危物种数量为508种，仅比2009年增加1种。考虑到这一点，我们得出结论，在未来可能不会有大规模灭绝。
最后，为了估计未来20年有多少物种将灭绝，我们建立了一个DECS模型来估计未来的灭绝。首先，利用建立的PLS方法计算巴西亚马逊河流域的剩余森林面积。其次，利用微分方程模型计算了时间（t）可能发生的绝灭和“绝灭债”。最后，我们选择计算机模拟的模型来计算在不同的四种情况下灭绝的物种数量。结果表明，BAU、GOV、SR、EOD的灭绝物种分别为13、11、9、7（见表11）。
模型假设： （1） 亚马逊未来不会发生大火灾。
（2） 未来亚马逊不会发生物种入侵。
（3） 所有数据都是合理的。
（4） 巴西的环境不会受到其他因素的污染。
（5） 这个词只有一个意思。
（6） 巴西的经济不会受到其他国家的严重影响。
问题分析： 由于60～70%的森林被用于养牛，20～30%的森林被用于农业，1～10%的森林被用于伐木[5]。因此，森林砍伐的影响可以通过草原、农业用地和伐木用地的每一种影响来表示。为了衡量森林砍伐对经济的影响，选择了三个指标——GDP、出口和耕地面积。然后得到两组变量。其次，可以考虑典型相关分析来分析毁林对经济的影响，而对于生态影响，则采用PLS方法进行分析。
通过观察森林砍伐随时间的变化，可以直观地看出，近十年来，巴西的生态环境日益恶化。考虑到这一点，我们选择建立一个基于偏最小二乘回归（PLS）的模型来分析毁林与生态环境的相关性。
为了估计未来20年有多少物种将灭绝，我们提出了一种估计未来灭绝的技术。首先，我们考虑使用PSL来计算巴西亚马逊地区的剩余森林面积。其次，利用微分方程和计算机模拟两种方法计算物种灭绝和物种灭绝。
模型的建立与求解整体论文缩略图 全部论文请见下方“ 只会建模 QQ名片” 点击QQ名片即可 部分程序代码：(代码和文档not free) data ex; Input x1-x3 y1-y3@@; cards; 12393.68 4374.24 1458.08 6017 551 5764 24018.06 9825.57 2547.37 5084 582 5796.7 37727.3 16832.18 3482.52 4608 604 5828 52565.94 25865.78 5006.28 5525 731 5900 76734.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/580f86275682a30039cf4c6835a39179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cfbb8928fba970ad1e9751a90b7786d/" rel="bookmark">
			【Vue】事件修饰符详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✨ 专栏介绍 在当今Web开发领域中，构建交互性强、可复用且易于维护的用户界面是至关重要的。而Vue.js作为一款现代化且流行的JavaScript框架，正是为了满足这些需求而诞生。它采用了MVVM架构模式，并通过数据驱动和组件化的方式，使我们能够更轻松地构建出优雅而高效的Web应用程序。在本专栏中，我们将深入学习Vue.js的核心概念、组件开发、状态管理、路由和性能优化等方面的知识。无论你是初学者还是有一定经验的开发者，通过学习Vue.js，你将能够构建出令人印象深刻的用户界面，并提升自己在Web开发领域的竞争力。让我们一起开始Vue.js之旅吧！
文章目录 ✨ 专栏介绍引言作用使用方式使用示例阻止事件冒泡：阻止默认行为：使用事件捕获模式：只有当事件是从触发元素自身触发时才触发回调：只触发一次回调： 总结😶 写在结尾 引言 Vue事件修饰符是Vue.js框架提供的一种功能，用于在处理DOM事件时提供更多的控制和便利性。它们可以用来改变事件的行为，例如阻止默认行为、阻止事件冒泡、只触发一次等。本文将介绍Vue事件修饰符的作用、使用方式以及使用示例，并对其在各种场景下的应用进行总结。
作用 Vue事件修饰符可以帮助开发者更方便地处理DOM事件，提供了一些常见的操作选项，以满足不同场景下的需求。通过使用这些修饰符，我们可以轻松地控制事件的行为，从而提高代码的可读性和可维护性。
使用方式 在Vue中，我们可以通过在DOM元素上添加修饰符来改变事件处理函数的行为。修饰符是通过点号（.）来表示的，并且需要紧跟在指令后面。下面是一些常见的Vue事件修饰符：
.stop：阻止事件冒泡。.prevent：阻止默认行为。.capture：使用事件捕获模式。.self：只有当事件是从触发元素自身触发时才触发回调。.once：只触发一次回调。.passive：告诉浏览器该事件的默认行为是被passive的，可以提升滚动性能。 使用示例 阻止事件冒泡： &lt;div @click.stop="handleClick"&gt; &lt;button @click="handleButtonClick"&gt;按钮&lt;/button&gt; &lt;/div&gt; 在上面的示例中，当点击按钮时，点击事件不会冒泡到父元素上，只会触发按钮自身的点击事件。这对于需要在父元素和子元素上都有点击事件时非常有用，可以避免不必要的触发。
阻止默认行为： &lt;a href=" https://www.example.com " @click.prevent="handleClick"&gt;链接&lt;/a&gt; 在上面的示例中，当点击链接时，页面不会跳转到链接指定的URL，而是触发自定义的handleClick方法。这对于需要在不跳转页面的情况下执行一些操作时非常有用。
使用事件捕获模式： &lt;div @click.capture="handleClick"&gt; &lt;button @click="handleButtonClick"&gt;按钮&lt;/button&gt; &lt;/div&gt; 在上面的示例中，当点击按钮时，先触发父元素的点击事件处理函数，然后再触发子元素自身的点击事件处理函数。这对于需要先处理父元素再处理子元素的情况非常有用。
只有当事件是从触发元素自身触发时才触发回调： &lt;div @click.self="handleClick"&gt; &lt;button @click="handleButtonClick"&gt;按钮&lt;/button&gt; &lt;/div&gt; 在上面的示例中，当点击按钮时，不会触发父元素的点击事件处理函数，只会触发按钮自身的点击事件处理函数。这对于需要在特定元素上触发事件时非常有用。
只触发一次回调： &lt;button @click.once="handleClick"&gt;按钮&lt;/button&gt; 在上面的示例中，当点击按钮时，handleClick方法只会被调用一次。这对于需要只执行一次操作的情况非常有用。
总结 通过使用Vue事件修饰符，我们可以更方便地处理DOM事件，并且根据需要改变事件的行为。无论是阻止事件冒泡、阻止默认行为、使用事件捕获模式、只有当事件是从触发元素自身触发时才触发回调还是只触发一次回调，Vue事件修饰符都提供了简洁而强大的方式来满足不同场景下的需求。
😶 写在结尾 前端设计模式专栏
设计模式是软件开发中不可或缺的一部分，它们帮助我们解决了许多常见问题，并提供了一种优雅而可靠的方式来构建应用程序。在本专栏中，我们介绍了所有的前端设计模式，包括观察者模式、单例模式、策略模式等等。通过学习这些设计模式，并将其应用于实际项目中，我们可以提高代码的可维护性、可扩展性和可重用性。希望这个专栏能够帮助你在前端开发中更好地应用设计模式，写出高质量的代码。点击订阅前端设计模式专栏
Vue专栏
Vue.js是一款流行的JavaScript框架，用于构建用户界面。它采用了MVVM（Model-View-ViewModel）的架构模式，通过数据驱动和组件化的方式，使开发者能够更轻松地构建交互性强、可复用的Web应用程序。在这个专栏中，我们将深入探讨Vue.js的核心概念、组件开发、状态管理、路由和性能优化等方面的知识。我们将学习如何使用Vue.js构建响应式的用户界面，并探索其强大的生态系统，如Vue Router和Vuex、Pinia。通过学习这些内容，你将能够成为一名熟练的Vue.js开发者，并能够应用这些知识来构建复杂而高效的Web应用程序。点击订阅Vue专栏
JavaScript（ES6）专栏
JavaScript是一种广泛应用于网页开发和后端开发的脚本语言。它具有动态性、灵活性和易学性的特点，是构建现代Web应用程序的重要工具之一。在这个专栏中，我们将深入探讨JavaScript语言的基本语法、DOM操作、事件处理、异步编程以及常见算法和数据结构等内容。此外，我们还将介绍ES6（ECMAScript 2015）及其后续版本中引入的新特性，如箭头函数、模块化、解构赋值等。通过学习这些内容，你将能够成为一名熟练的JavaScript开发者，并能够应用这些知识来构建出高质量和可维护的Web应用程序。点击订阅JavaScript（ES6）专栏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba78150d1b62cd3e4e0797f0ef1f6a1/" rel="bookmark">
			“所有代码，都是技术债务！”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多开发团队在推进项目时，都会不断强调“尽量减少技术债务”，对此，本文作者 Paul McMahon 表示：别费劲了，你写的每一行代码，最终都是技术债务。
原文链接：https://www.tokyodev.com/articles/all-code-is-technical-debt
作者 | Paul McMahon，TokyoDev 创始人
译者 | ChatGPT 责编 | 郑丽媛
出品 | CSDN（ID：CSDNnews）
技术债务，这个概念最初由沃德·坎宁安（Ward Cunningham）提出，指的是通过紧急的软件开发来获得暂时的速度提升，但代价是放慢未来的开发速度。 这好像一笔贷款：通过贷款，你可以借到钱更快地完成某件事——对于技术债务而言，这就好比你获得了最初的开发动力；一旦贷款，你就需要支付利息——在技术债务中，利息就是未来开发速度会减缓；当你还清贷款本金时，利息就会减少——放到技术债务中，这就类似于重构，你需要花大把时间改进代码以加快未来的开发速度。
与金融债务一样，技术债务也可以是一种有用的工具，有时短期收益会大于长期后果。然而，就像背负过多的金融债务会导致破产一样，技术债务积累过多也会导致产品开发陷入停滞。
如果你曾从零开始创建一个新应用程序，那么你一定体验过在没有任何技术债务的情况下开展项目的美妙感觉。在初次创建应用程序时，你可以以惊人的速度开发新功能，无需担心对现有用户的影响，只需专注于实现新功能即可。
然而随着应用程序的成熟，开发速度将不可避免地减慢，尤其是发展不佳的产品更是如此。而即使是一个实现得很好的产品，随着你向应用程序添加的代码越多，开发速度仍然会随时间减慢——因此，我将所有的代码视为技术债务。
只要增加新设定，就会增加技术债务
随着应用程序的成熟，它会积累一系列基本设定。当你开始一个新项目时，由于此前没有任何功能，代码库中没有内置任何设定，因此添加新功能时只需关注如何实现功能即可。然而，一旦项目有了第一个功能，你就永远需要考虑迄今为止开发的所有功能对未来开发的影响。
我将根据自己创建社区活动平台 Doorkeeper（一个社区活动平台，帮助网络活动、研讨会的组织者吸引参与者并管理注册）的经验，举例说明核心设定导致的技术债务是如何积累的。
刚开始我们创建 Doorkeeper 的初衷，是为了帮助当地网络活动 Mobile Monday Tokyo 更顺利地完成注册和签到过程。对于这个活动，当时组织者只需要一个简单的注册流程：注册参加活动以及取消注册。
在扩展 Doorkeeper 以满足其他组织者需求的过程中，我们发现许多组织者对出席人数有硬性限制。为了满足新组织者的需求，我们决定添加一个限制参与人数的选项。
在现有的“人们可以注册参与活动”的设定基础上，我们对活动的参与人数进行了限制，但还需要考虑当有人试图注册一个人数已满的活动时会发生什么。最简单的解决方案是在人数已满时阻止用户注册，但我们认为这会给潜在参与者带来不好的体验，同时也无法向组织者反馈活动的受欢迎程度。因此，我们采用了候补名单功能，如果有人想注册但活动人数已满，他们将加入候补名单。如果有参加活动的人取消了注册，那么候补名单上的第一个人就可以替补上去。
在这之后，我们为 Doorkeeper 添加的下一个功能是预购门票。如果我们唯一的设定是“人们可以注册参与活动”，那么这个功能直接就能实现，因为它是建立在这个设定之上的——但实际情况是，我们还需要考虑其他可能性。
根据不同活动，有的组织者可能不太希望预购门票的参与者取消活动。此外，他们可能还想要制定某种取消政策，即根据参与者取消的时间，他们可获得部分退款。考虑到取消预购门票涉及到各种边缘案例，且大多数组织者都不想让参与者轻易取消，所以我们在设计这项功能时，不允许参与者自行取消存在预购门票的活动。相反，他们需要联系组织者，然后由组织者决定如何处理这种情况。
此外，由于活动的注册人数有限，我们还需要一些机制来确保预购门票的人能够得到活动名额。为此，我们将注册流程分为两步：首先是输入注册信息，然后是付款。如果在开始填写初始表单和提交之间活动名额已满，那这些人将加入候补名单。
接着，考虑到存在已提交注册表单但未完成付款的情况，我们增加了在一定时间后自动取消未付款订单的功能；除此之外，对于需要预购门票的活动，我们也不能给从候补名单中移出的替补人员立即出票，因为他们需要返回网站完成付款…… 正如你所看到的，随着我们需要考虑迄今为止添加的所有设定的影响，添加新功能这件事变得越来越复杂。
有时候，功能会带来负面价值
要让一个功能为产品增值，它就必须对用户有用。可是当功能给产品带来的技术债务大于其为产品增加的价值时，这些功能就会产生负面价值。
我见过的一个经常产生负面价值的功能是应用本地化。简单来说，本地化就是将应用程序翻译成多种语言。除了翻译之外，其中涉及到的挑战还有很多，但现在让我们简单地考虑本地化：拥有一组特定语言字符串的词典。
首先，这意味着你不能在应用程序中硬编码字符串，从而增加一个额外的抽象层。虽然这并不会增加太多开销，但开发人员仍需时刻牢记。接着，你需要在开发过程中引入一个翻译步骤。假设你手下开发人员的母语与应用支持的语言并不相通，那他们很难自己编写字符串，而需要依赖翻译人员。当然你也可以自己解决这个问题，但这仍会使所有未来的开发工作都变得缓慢。
如果应用本地化能带来大量价值，那么这种额外的开销就不是问题。但我经常看到一些应用程序在本地化方面敷衍了事，就希望其他国家的人开始使用它——然而，事实并非如此。除非你愿意在应用支持的语言中，进行出色的本地化工作并大力推广你的应用程序，否则本地化将不会创造大量价值。于是最终，你会得到一个产生技术债务比其价值更大的功能。 代码的价值，并非与生俱来
作为开发者，我们很容易认为编写代码就是在创造价值。然而，软件的真正价值来自于它对用户的实用性，而不是我们的代码质量：写得不好却能执行实用任务的代码，比写得很好却做了无用功的代码更有价值。
正因如此，我们需要确保我们正在开发有价值的功能。传统开发过程中，会假定存在一个无所不能的产品负责人，他会以某种方式了解功能的相对价值，但实际情况并非如此。
我希望你能与这种厉害的产品负责人合作，并对你正在从事的工作为何具有价值有了清晰的了解。但如果没有，你就应该主动反击，试着找出他们认为该功能有价值的原因，并对其进行验证。确保我们实现的功能是有足够价值的，以此减少未来其造成的技术债务过重的可能性。
功能一旦添加，就会永久存在
我们之所以要对那些不能产生足够价值的功能保持高度警惕，部分原因在于：一旦添加了某项功能，它几乎就会一直存在下去。
即使事后发现该功能的性能不如预期中好，通常的做法也是什么也不做，因为人们往往有沉没成本谬误：即使这个功能今天看来没什么用，保不齐将来可能会有用。 除此之外，不采取任何行动也有其他合理原因，毕竟移除一项功能也是有成本的，既要耗费大量的开发精力来清理删除，还可能会让客户不高兴。因此，一旦在产品中添加了某项功能，它几乎就会一直存在。
为了避免技术债务，不要编写代码
避免技术债务的唯一可靠方法，就是先不写代码。作为开发者，我们的第一反应总是通过编码来解决问题，但这并不总是最佳策略。很多时候，我们需要抛开这种本能。
举一个我个人的例子，我曾经营过一个职位信息平台，帮助国际开发者在日本找工作。一开始，我只是简单发布我发现的职位，但后来我听到了太多类似的成功故事，我觉得公司会愿意为此付费。作为其中一部分，我想在公司收到申请之前，对其进行一些基本的垃圾邮件筛选。
为此，我开始使用 Ruby on Rails 构建一个筛选系统。然而，经过大约一天的开发后，我意识到建立一个比让应聘者直接发送电子邮件更好的系统相当复杂。我需要复制电子邮件中的所有功能：附件、应聘者与公司之间的沟通等等。此外，我还需要确保系统正常运行，监控日志等。
然而，我真正需要的只是一种在邮件发送到公司之前对其进行审核的方法。因此，我没有继续实施自己的方案，而是用 Google 应用程序的“群组”功能为每家公司建立了一个邮件列表。虽然这不是最佳的技术解决方案，但最终我创造的价值本身就与技术无关，后来我的时间也更多花在了帮助公司和求职者找到最佳人选/雇主。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ba78150d1b62cd3e4e0797f0ef1f6a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/205af5e81bc69e23668eff36918e9ae4/" rel="bookmark">
			代码量锐减 80%，一次祖传代码重构实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此前，团队接管并重构了十多年前的搜索链路中的 Query 理解祖传代码，代码量减少 80%，性能、稳定性、可观测性都得到大幅度提升，且支持自研云和业务机房双环境部署。本文将分享重构过程中碰到的代码坏味道，并分析这样写的动机、预防和拯救措施。
作者 | 龙鑫 责编 | 夏萌
出品 | 腾讯云开发者
有一次，我和我妈一起打扫房间，我问我妈：什么时候书房变成了杂物间，堆满了垃圾？
我妈说：我有一次懒得扔纸箱，就把纸箱扔到了书房，然后慢慢就这样了。
我尴尬的笑了笑：那你为什么不定期打扫？扔掉那些你不用的东西？
我妈：前面一直将就着，就等你放假了一起打扫。
我：😁
代码也是如此，十一年的老代码，从某次懒得扔垃圾开始，坏味道便逐渐开始充斥着整个项目。
经过三个月大扫除，我和小伙伴重构了这个迭代十一年的老模块。重构的过程，不仅是对坏味道的清除，对老模块的重新设计，也是一场与十一年前老同事跨越时空的对话。本文将分享重构过程中碰到的代码坏味道，以第一人称分析当初这样写的动机及对应的预防和拯救措施。
背景
1.1 接手
在一次组织架构调整后，我们组接手了链路搜索的几个底层基础模块—— QU（Query 理解）相关的三个模块，其中包括本次重构对象 Query Optimizer ，负责根据用户在搜索系统中输入的 Query（查询语句）产出切词、词权、紧密度、意图识别结果。QO 在搜索链路中的上下游关系如下图所示：
1.2 为什么重构 面对一份10年陈的祖传代码，我们选择重构的原因主要如下：
迭代效率低：新增一个简单的算子需要 3 人天，效率低下。
稳定性较差：不定期出现 P99 毛刺。
启动速度慢：服务启动需要 18 分钟。
内存浪费多：单进程需 114 G 内存。
排查工具少：缺少多项监控和 trace 跟踪能力。
GCC 老旧 ：使用 GCC 4.8，无法使用现代 C++。
无法部署到自研云：无法和腾讯域下的类似能力做合并。
基于上述原因，也缘于我们热爱挑战、勇于折腾，我们决定在项目完全接手后启动重构计划。
后面的内容将分享老代码中的坏味道，当初这样写的动机、对应的预防和拯救措施及优化之后的效果。
重复的代码
2.1 示例
下面代码为 gbk 与 utf8 格式的互相转换函数。两个函数之间除了变量输入顺序不一样，其他都是一样的。
2.2 动机 我懒得提取公共代码。CV 大法最简单，最快速。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/205af5e81bc69e23668eff36918e9ae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af139068a01180c12ad290a2e96b1cba/" rel="bookmark">
			数据库（五）数据库设计 | 实体关系模型ER model 映射基数 弱实体集 实体关系设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 实体关系模型 ER模型ER model1.1 E-R模型结构1.1.1 实体和实体集1.1.2 属性1.1.3 关系集合 1.2 ER关系图绘制1.2.1 实体集绘制1.2.2 关系集绘制 2 映射基数 Mapping Cardinalities2.1 映射基数类型2.1.1 一对一2.1.2 一对多2.1.3 多对一2.1.4 多对多 2.2 全部或部分参与约束2.3 最小最大基数约束 3 弱实体集4 ER模型转换为关系模式Relation Schema4.1 强实体集表示4.2 弱实体集表示4.3 关系集合表示 5 实体关系设计6 扩展E-R特征6.1 IS-A 继承 参考 ER 图是什么？这一篇让你搞懂 ER 图！ - 知乎 (zhihu.com)
数据库设计核心就是
1 理解用户需求
2 使用E-R关系模型，绘制E-R图
3 将E-R关系模型转换为数据库表
本节核心在第二部分到第三部分
1 实体关系模型 ER模型ER model 1.1 E-R模型结构 E-R模型实际上是由多个实体集（含有不同属性）和联系集组成
1.1.1 实体和实体集 实体 Entity 是一个物体，客观存在并且相互区别
​ 比如一个学生，一个公司
实体集合 Entity Sets 具有相同属性的实体的集合
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af139068a01180c12ad290a2e96b1cba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b7498210b6eae83ca2ae7ef463c74c5/" rel="bookmark">
			Linux用户登出或者终端关闭后继续运行的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nohup 是一个 POSIX 命令，它的名称来源于“no hang up”的缩写。这个命令的基本用途是运行一个命令，使得该命令在用户登出或者终端关闭后继续运行。nohup 命令通常与后台运行的命令（使用 &amp; 符号）结合使用，以便在终端关闭后继续执行长时间运行的进程。
基本语法：
nohup command [arguments] &amp; command 是你想要运行的命令，[arguments] 是传递给该命令的任何参数。&amp; 将命令放入后台执行。
例如，如果你在一个 SSH 会话中启动了一个长时间运行的脚本或者服务，并且你不希望在你断开连接时该进程被终止，你可以使用 nohup。
示例命令：
nohup python my_script.py &amp; 这将启动 my_script.py 脚本，并且不会在用户登出时中断。
nohup 默认会将标准输出（stdout）和标准错误（stderr）重定向到一个名为 nohup.out 的文件中，除非另外指定。如果你想要将输出重定向到不同的文件，你可以这样做：
nohup python my_script.py &gt; output.log 2&gt;&amp;1 &amp; 在这个例子中，标准输出和标准错误都被重定向到 output.log 文件中。
请注意，使用 nohup 并不阻止进程接收到系统发送的其他信号，比如系统关机时发送的 SIGTERM。为了更精细地控制进程在后台运行的行为，可以使用像 screen 或 tmux 这样的终端复用器，或者考虑将任务编写为系统服务，使用 systemd 或 upstart 等系统级别的工具来管理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f5bc8b6cc6740afc0e879c38f0c78a/" rel="bookmark">
			八皇后问题（C语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解题意 在一个8x8的棋盘上放置8个皇后，使得任何两个皇后都不能处于同一行、同一列或同一斜线上。问有多少种方法可以放置这8个皇后？
解决这个问题的目标是找到所有符合要求的皇后摆放方式，通常使用回溯算法来求解。回溯算法会尝试所有可能的摆放方式，一旦发现某个摆放方式会导致冲突（即两个皇后在同一行、同一列或同一斜线上），就立即回溯到上一步，尝试其他的摆放方式。
八皇后问题的解法有很多种，其中一个经典解法是使用递归和剪枝。在递归过程中，算法会尝试在每一行放置一个皇后，并检查是否与前面放置的皇后发生冲突。如果发生冲突，就回溯到上一行重新放置皇后。如果没有发生冲突，就将该摆放方式加入到结果集中。为了避免重复计算，可以使用一个数组来记录已经放置的皇后所在的行和列，以便在回溯时跳过已经计算过的摆放方式。
放置皇后的地方置为1，其余置为0. 代码如下（示例）：
#include &lt;stdio.h&gt; int cnt=0;//解法个数 int qq[8][8]={0}; void cout_cheek(int aa[][8],int n){//输出二维数组 for(int i=0;i&lt;n;i++){ for(int j=0;j&lt;n;j++){ printf("%d ",aa[i][j]); } printf("\n"); } printf("\n"); } int notdanger(int qq[][8],int n,int k){//判断某位置是否安全 for(int i=0;i&lt;n;i++){ if(qq[i][k]==1) return 0;//该列 } for(int i=n,j=k;i&gt;=0&amp;&amp;j&gt;=0;i--,j--){//左上角 if(qq[i][j]==1) return 0; } for(int i=n,j=k;i&gt;=0&amp;&amp;j&lt;8;i--,j++){//右上角 if(qq[i][j]==1) return 0; } return 1; } void queen(int qq[][8],int n){ if(8==n){ cnt++; printf("第%d种答案：\n",cnt); cout_cheek(qq,8); }else{ for(int k=0;k&lt;8;k++){ if(notdanger(qq,n,k)){ qq[n][k]=1; queen(qq,n+1); qq[n][k]=0; } } } } int main(){ queen(qq,0); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f5bc8b6cc6740afc0e879c38f0c78a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/2/">«</a>
	<span class="pagination__item pagination__item--current">3/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/4/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>