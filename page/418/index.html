<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf14db6641df9f3fb793f2531983d16/" rel="bookmark">
			还在为DST模型刷不动而感到苦恼吗？来试试无监督DST吧，DSI等你来战！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍一篇西湖大学联合哈尔滨工业大学 SCIR 实验室和北京理工大学发表于 IJCAI 2020 的论文 Dialogue State Induction Using Neural Latent Variable Models。
论文链接：
https://www.ijcai.org/Proceedings/2020/0532.pdf
代码链接：
https://github.com/taolusi/dialogue-state-induction
PPT链接：
https://taolusi.github.io/qingkai_min/assets/pdf/20-ijcai-dsi_slides.pdf
视频链接：
https://www.bilibili.com/video/BV1fV41127tq
对话状态跟踪模块是任务型对话系统中的核心部件，目前主流的对话状态跟踪的方法需要在大量人工标注的数据上进行训练。然而，对于现实世界中的各种客户服务对话系统来说，人工标注的过程存在代价高、标注慢、错误率高以及难以覆盖数量庞大的不同领域等问题。
基于这些问题，我们提出了一个新的任务：对话状态推理，目标是从大量无标注的客服对话记录中自动挖掘对话状态，并提出了两个基于神经隐变量的模型来实现无监督的对话状态推理，同时我们在下游的对话生成任务中进行了验证，实验结果表明，相比于缺少对话状态的对话系统，使用我们推理得到的对话状态可以获得更好的表现。
背景
1.1 任务型对话系统
任务型对话系统（task-oriented dialogue system）的目标是协助用户完成特定的任务，比如订机票、打车、日程管理等。
一个典型的任务型对话系统可以分为四个模块：自然语言理解（natural language understanding, NLU）、对话状态追踪（dialogue state tracking, DST）、策略学习（dialogue policy）以及自然语言生成（natural language generation, NLG），在这个过程中需要跟各种各样的数据库进行查询甚至更新等操作。
▲ 图1 任务型对话系统
（图片来源于：Gao J, Galley M, Li L. Neural approaches to conversational AI[C]//The 41st International ACM SIGIR Conference on Research &amp; Development in Information Retrieval. 2018: 1371-1374.）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf14db6641df9f3fb793f2531983d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d9d6c4a79109e76e4831ba3312cb405/" rel="bookmark">
			Hbase（二）Client客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于使用HBase的业务方来说，从HBase客户端到HBase服务端，再到HDFS客户端，最后到HDFS服务端，这是一整条路径，其中任何一个环节出现问题，都会影响业务的可用性并造成延迟。因此，HBase的业务方需要对HBase客户端有较好地理解，以便优化服务体验。而事实上，由于HBase本身功能的复杂性以及Region定位功能设计在客户端上，导致HBase客户端并不足够轻量级。
1、　HBase客户端实现 HBase提供了面向Java、C/C++、Python等多种语言的客户端。由于HBase本身是Java开发的，所以非Java语言的客户端需要先访问ThriftServer，然后通过ThriftServer的Java HBase客户端来请求HBase集群。对其他语言的客户端，推荐使用ThriftServer的方式来访问HBase服务。
这里主要探讨HBase社区Java客户端。
下面通过一个访问HBase集群的典型示例代码，阐述HBase客户端的用法和设计，代码如下所示：
public class TestDemo { private static final HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility(); public static final TableName tableName = TableName.valueOf("testTable"); public static final byte[] ROW_KEY0 = Bytes.toBytes("rowkey0"); public static final byte[] ROW_KEY1 = Bytes.toBytes("rowkey1"); public static final byte[] FAMILY = Bytes.toBytes("family"); public static final byte[] QUALIFIER = Bytes.toBytes("qualifier"); public static final byte[] VALUE = Bytes.toBytes("value"); @BeforeClass public static void setUpBeforeClass() throws Exception { TEST_UTIL.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d9d6c4a79109e76e4831ba3312cb405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877525f51447d73dab6523aa92a27508/" rel="bookmark">
			现代互联网网络拓扑的简单描述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、边缘部分 以家庭的联网网络拓扑为例，各种终端设备通过有线或者无线的方式连接到路由器，
路由器与当地的网关进行连接，网关再连接到当地的地区ISP（网络服务提供商）。
再以企业的联网网络拓扑为例，多个终端与就近的路由器进行连接，
路由器再与就近的网关进行连接，网关之间也可以相互连接，
再经过统一网关与地区ISP进行连接。
二、核心部分 各个地区的ISP连接到就近的主干ISP，
主干ISP再通过国际路由器连接到别国的主干ISP
三、边缘部分结合核心部分的网络拓扑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096bc637df434c0434fb2925a1c574d4/" rel="bookmark">
			计算机网络的层次结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、层次结构设计的基本原则 假设有计算机A和计算机B，通过计算机网络连接起来，则计算机网络需要解决的问题有：
1、保证数据通路的顺畅；
2、识别目的计算机，A怎么识别到B，B又是怎么识别到A；
3、查询到目的计算机的状态：是否在线，是否能够接收数据；
4、数据是否错误；
计算机网络涉及的问题是繁多、复杂的，采用分层的设计分别取解决不同的问题。
设计的基本原则有：
1、各层之间相互独立，层与层之间的耦合度是非常低的；
2、每一层有足够的灵活性；
3、各层之间完全解耦；
二、OSI七层结构 每一层分别完成不同的工作
1、应用层：
为计算机用户提供接口和服务
2、表示层：
数据处理（编码解码、加密解密等）
3、会话层：
管理（建立、维护、重连）通信会话
4、传输层：
管理端到端的通信连接
5、网络层：
数据路由（决定数据在网络上的路径）
6、数据链路层：
管理相邻结点之间的数据通信
7、物理层：
数据通信的光电物理特性
OSI本来想成为全球计算机都遵循的标准，但是其在市场化的过程中困难重重，
而TCP/IP在全球范围成功运行；
OSI并没有成为广为使用的标准模型。
三、TCP/IP四层模型 1、应用层：
包括OSI七层模型中应用层、表示层、会话层的职能；
包括HTTP，FTP，SMTP，POP3等协议；
2、传输层：
包括OSI七层模型中传输层的职能；
包括TCP/UDP协议；
3、网络层：
包括OSI七层模型中网络层的职能；
包括IP协议；
4、网络接口层：
包括OSI七层模型中数据链路层、物理层的职能；
包括Ethernet、PPP协议等；
假设计算机A和计算机B通过一个路由器连接起来了，
如果A要去连接B，则先要与路由器进行通信，路由器不涉及传输层和应用层，
根据网络层的数据进行转发到B
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66fa5d4707e67db6c762e85c905e2950/" rel="bookmark">
			计算机网络发展简史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、互联网的发展历史 第一阶段：
单个网络ARPANET，为了将就近的几台计算机连接起来；
因为刚开始的时候计算机比较昂贵，所以数量较少。
计算机通过连接交换机就可以进行信息的交互
第二阶段：
随着计算机的普及，计算机逐渐进入普通人的家庭、学校、实验室等，单个网络ARPANET已经不能满足计算机之间的通信的需求了；
随之产生了三级结构互联网，可以把美国主要的大学、研究所、实验室中的计算机都连接起来；
由主干网、地区网、校园网构成，主要还是应用于美国国内
第三阶段：
随着计算机普及全球，计算机数量起飞了；
出现了多层次ISP互联网，用于全球的计算机之间的连接；
ISP指的是Internet Service Provider：网络服务提供商，
在中国，著名的网络服务提供商有：中国电信、中国移动、中国联通等；
主干ISP（包括全球各大网络提供商）：中国的主干ISP可以连接美国、欧洲的主干ISP；
地区ISP：主要负责不同地区的网络服务的提供，如北京移动、广东移动等，各地区之间的ISP也可以相互连接和通信；
到了多层次ISP阶段，全球的互联网就算是真正地连接起来了
二、世界主干网络的线路图 https://live.infrapedia.com
中国通过海底电缆来连接不同的区域
三、中国互联网的发展历史 第一阶段：
1980年开始互联网实验；
第二阶段：
1989年建立第一个公共网络；
第三阶段：
1994年接入国际互联网，实现了国际网络的互通；
中国建立的用于进行国际交换的公用计算机网络：
中国电信互联网CHINANET
中国联通互联网UNINET
中国移动互联网CMNET
中国教育与科研计算机网CERNET
中国科学技术网CSTNET
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47052605111d65c30acb4a1dc2e9f8e0/" rel="bookmark">
			cocoapods-ybin二进制源码映射使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 随着项目业务的不断迭代和新增，每个业务线负责不同的功能模块，组件化势必是需要进行的工作。业界内，无论是哪种组件化方案，目的是一样的，分离业务和功能。
组件化虽好，但是组件化只是将不同的业务分离或者不同的功能分离和分层，实际上还是在一个代码池里每次 build 需要进行编译、汇编、链接等过程。每次编译的占用的时间还是挺奢侈的，在编译速度上并没有提升。pod install 来回切换二进制和源码也更是一件可行不可取的开发模式。
cocoapods-ybin 解决二进制和源码之间的映射问题，无需来回切换源码，实现二进制断点可进入源码进行调试。实现原理是简单的，但区别于 Android 里的 aar 或 jar 内的 Class 文件。
cocoapods-ybin 满足以下几个诉求考虑实现：
小而好用、低成本接入与二进制库的制作和存储无关，只需二进制库和源码存储位置即可映射同时支持多项目并行开发只存储一份源码无需频繁的 clone 代码 二、先睹为快 cocoapods-ybin-demo 示例效果视频，示例代码地址
https://img.58cdn.com.cn/dist/rn/course/ybin_demo_small.mp4
三、安装 3.1 直接安装 $ sudo gem install cocoapods-ybin 3.2 使用 Gemfile 管理 pod 版本 添加 cocoapods-ybin 到 Gemfile 文件
gem 'cocoapods-ybin' 3.3 安装校验 执行命令 pod --help 查看当前 pod 版本 ybin 是否安装成功。
$ pod --help 四、使用教程 打开示例项目 ocoapods-ybin-demo 示例代码 的 Podfile 目录。示例项目使用了 Bundler 对 pod 的版本进行了控制，实际项目根据所需选择是否采用，与本插件无关联，请酌情选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47052605111d65c30acb4a1dc2e9f8e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b15580d2774b730d88d8ac417e39c2b/" rel="bookmark">
			Hadoop格式化时报错：-bash: hdfs: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-bash: hdfs: command not found 问题解决方案 问题 搭建Hadoop环境各种配置顺顺利利，等到我想要进行hdfs namenode -format格式化时电脑报错：
-bash: hdfs: command not found 解决方案 配置环境检查完后发现没有执行生效环境变量，输入
source /etc/profile 后格式化成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c74b2054abdb324aaa9e9ad8f5876f/" rel="bookmark">
			this.$nextTick
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如 给a 复制了一个href属性，然后 a.click(),正常来讲应该下载一个excel，但是下载了一个页面。
所以加这个，我写的惠氏 项目的 价格管理 的 下载模板哪
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c6f5146f74f939ddbdbea9e9d0853c/" rel="bookmark">
			GAMES101 作业1 闫令琪图形学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次作业的任务是填写一个旋转矩阵和一个透视投影矩阵。给定三维下三个 点 v0(2.0,0.0,−2.0),v1(0.0,2.0,−2.0),v2(−2.0,0.0,−2.0), 你需要将这三个点的坐 标变换为屏幕坐标并在屏幕上绘制出对应的线框三角形 (在代码框架中，我们已 经提供了 draw_triangle 函数，所以你只需要去构建变换矩阵即可)。简而言之， 我们需要进行模型、视图、投影、视口等变换来将三角形显示在屏幕上。在提供 的代码框架中，我们留下了模型变换和投影变换的部分给你去完成。 如果你对上述概念有任何不清楚或疑问，请复习课堂笔记或询问助教。 以下是你需要在 main.cpp 中修改的函数（请不要修改任何的函数名和其他 已经填写好的函数，并保证提交的代码是已经完成且能运行的）：
• get_model_matrix(float rotation_angle): 逐个元素地构建模型变换矩 阵并返回该矩阵。在此函数中，你只需要实现三维中绕 z 轴旋转的变换矩阵， 而不用处理平移与缩放。
• get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar):使用给定的参数逐个元素地构建透视投影矩阵并返回 该矩阵。
• [Optional] main(): 自行补充你所需的其他操作。
2
当你在上述函数中正确地构建了模型与投影矩阵，光栅化器会创建一个窗口 显示出线框三角形。由于光栅化器是逐帧渲染与绘制的，所以你可以使用 A 和 D 键去将该三角形绕 z 轴旋转 (此处有一项提高作业，将三角形绕任意过原点的 轴旋转)。当你按下 Esc 键时，窗口会关闭且程序终止。
#include "Triangle.hpp" #include "rasterizer.hpp" #include &lt;eigen3/Eigen/Eigen&gt; #include &lt;iostream&gt; #include &lt;opencv2/opencv.hpp&gt; constexpr double MY_PI = 3.1415926; Eigen::Matrix4f get_view_matrix(Eigen::Vector3f eye_pos) { Eigen::Matrix4f view = Eigen::Matrix4f::Identity(); Eigen::Matrix4f translate; translate &lt;&lt; 1, 0, 0, -eye_pos[0], 0, 1, 0, -eye_pos[1], 0, 0, 1, -eye_pos[2], 0, 0, 0, 1; view = translate * view; return view; } Eigen::Matrix4f get_model_matrix(float rotation_angle) { Eigen::Matrix4f model = Eigen::Matrix4f::Identity(); // TODO: Implement this function // Create the model matrix for rotating the triangle around the Z axis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c6f5146f74f939ddbdbea9e9d0853c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1525f56d2e7545da970916df38c8a0a/" rel="bookmark">
			vueX的五个属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vueX简单来说就是一个状态管理库，用来统一管理和维护各个vue组件的可变化状态，用来存储一些数据，相当于vue组件中的data，作用是全局的
vueX有五个核心概念
state、getters、mutations、actions、modules
1.state：vuex的基本数据，用来存储需要变更的变量。
2.geeter：可以理解为store的计算属性。
3.mutations：用来修改提交store中的数据，每个mutation斗鱼一个字符串的时间类型（type）和一个回调函数（handler），这个回调函数就是需要实际进行状态修改的地方，但是前提是不许要是同步（如需异步操作可用到actions）
4.action：action提交的是mutation，不能直接变更状态，action可以包含任意异步操作
5.modules：将vueX中的store进行模块化，使每个模块都拥有自己的的state、mutation、action、getter。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e21b3760fd4fa3697070f34c378aafa/" rel="bookmark">
			Flutter 请求数据转model
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次我们说一下，Flutter网络请求返回的数据如何转model
Flutter的model和安卓、iOS完全不一样，他的生成比较复杂，没有iOS、安卓那么灵活和方便
Flutter生成model文件首先需要去一个网站
https://caijinglong.github.io/json2dart/index.html
1、打开这个网站后根据版本选择版本，第一个黄框目前选择V1.x.x
2、第二个黄框根据是我们想要起名的model类名称（首字母必须大写），但是我们要使用红色框中的黑色框的名称，看到这里大家应该都看明白了，我们黄框的内容最好不要带有下划线，因为黑色框中的内容自动进行专为小写并加下划线。
3、就是复制粘贴了，把我们借口请求返回 所有数据全部复制到左边的输入框中。而右边的输入款中会自动生成model内容
4、我要就要粘贴黑色框中的类名去Flutter中创建model了，创建完model后我们要把右侧输入框中的内容复制到model中。到此model基本创建完了。
5、第四步完成以后程序会报错，因为model生成后此model还需要一个.g.dart文件，这个文件我们不需要任何其他操作，自需要在编译器的控制台中敲一下下面的命令行既可以
命令行：
flutter packages run build_runner build 如果这个不行，我就需要使用下面的命令行
flutter packages pub run build_runner build --delete-conflicting-outputs 到此model基本就都完事了,其实Flutter的一个model实际是两个类.dart和.g.dart文件
下面给大家看个例子：
首先是network_time_data.dart
import 'package:json_annotation/json_annotation.dart'; part 'network_time_data.g.dart'; @JsonSerializable() class NetworkTimeData extends Object { @JsonKey(name: 'code') String code; @JsonKey(name: 'data') Data data; NetworkTimeData(this.code,this.data,); factory NetworkTimeData.fromJson(Map&lt;String, dynamic&gt; srcJson) =&gt; _$NetworkTimeDataFromJson(srcJson); Map&lt;String, dynamic&gt; toJson() =&gt; _$NetworkTimeDataToJson(this); } @JsonSerializable() class Data extends Object { @JsonKey(name: 'time') int time; Data(this.time,); factory Data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e21b3760fd4fa3697070f34c378aafa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a379472a55456ce7355443610725f11/" rel="bookmark">
			八个游戏角色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		For many years, gamers were just people who played games, differentiated mostly by what system they used to enjoy their hobby. The true “hardcore” gamers played on PC, the realm of flight simulators, grand strategy titles, and classic Sierra-style point-and-click adventure games. Everyone else played on consoles like Atari or Nintendo where bouncy platformers and adventure games ruled the day. Fast forward to the Nintendo Wii where the idea of the “casual” gamer really took off, denoting people like your neighbors and grandparents who had never played games before but could suddenly wrap their minds around Wii’s intuitive motion controls.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a379472a55456ce7355443610725f11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/480adf87b4cb6c42e97c96fb04777055/" rel="bookmark">
			二叉树的所有路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的所有路径 给定一个二叉树，返回所有从根节点到叶子节点的路径。
说明: 叶子节点是指没有子节点的节点。
示例 输入: 1 / \ 2 3 \ 5 输出: ["1-&gt;2-&gt;5", "1-&gt;3"] 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 题解 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {string[]} */ var binaryTreePaths = function(root) { if(!root) return []; var target = []; var dfs = function(root, tmp){ if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/480adf87b4cb6c42e97c96fb04777055/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f00c2ebe4d2018e291919c964b207cab/" rel="bookmark">
			2020-09-03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 非常简单的Bootstrap时间组件（月-日-时-分）可自由组合 贴效果图： 原本只有选择 时-分，在此基础上修改源码添加了，月-日（1-31天）。
整体js与css比较简单，进行自我修改源码也时分方便，在这里感谢原作者。
转载于https://blog.csdn.net/weixin_30526593/article/details/95480363
开始： 先引入bootstrap依赖：
&lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt;
&lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt;
在引入timepicker文件
&lt;link rel="stylesheet" href="css/timepicker/timePicker.css"&gt; &lt;script src="js/timepicker/jquery-timepicker.js"&gt;&lt;/script&gt; js与css网盘 连接：
链接：https://pan.baidu.com/s/13prm_DA9EiQCf1ceYkVIrA
提取码：rqa9
复制这段内容后打开百度网盘手机App，操作更方便哦
注册，调用
$("#day_input").hunterTimePicker();//显示时-分 $("#month_input").hunterTimePickerD();//显示日子，1-31 注意： hunterTimePicker（）；方法是原方法，调用后显示的时-分，
hunterTimePickerD（）；方法是我修改源码增加的方式，调用后显示图一，1-31天
html代码略，比较简单。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50c5104c96f8a8a2ef5a404226220a4/" rel="bookmark">
			robotstudio中喷绘组件的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在最近的仿真出现喷绘组件没有按照程序的设定来走，出现开头多一段，结尾少一段的情况，这种情况应该是robotstudio的bug而不是工程的问题，解决的方案是延迟开始，延迟结束。函数是waittime（），个人经验是延迟 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77ebab401ea05385f71098d9056cb52f/" rel="bookmark">
			Oracle重命名sys或system操作记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle等保中有条要求：应重命名或删除默认账户，修改默认账户的默认口令。
给的建议是修改sys,system默认账户名称，避免使用常见用户名称；
以下记录了两种方法来实现上面的要求：Oracle重命名sys操作记录
方法一：通过用户的信息是存储在user$实体表中的id来修改 1.1、首先获取用户的id select username,user_id from dba_users where username='SYS'; USERNAME	USER_ID ------------------------------ ---------- SYS	0 或者： select user#,name from user$ where name='SYS'; USER# NAME ---------- ------------------------------ 0 SYS 1.2、更新user$表中的记录(注意：在更新的时候，新的名字SYSA必须为大写) SQL&gt; update user$ set name='SYSA' where user#=0; 1 row updated. SQL&gt; commit; Commit complete. SQL&gt; alter system checkpoint; System altered. SQL&gt; alter system flush shared_pool; System altered. SQL&gt; conn sysa/sys as sysdba Connected. 方法二：通过修改Oracle的隐含参数，_enable_rename_user来开启Oracle的rename功能 2.1、查看_enable_rename_user SQL&gt; select t1.ksppinm,t2.ksppstvl,t1.ksppdesc from x$ksppi t1,x$ksppcv t2 where t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77ebab401ea05385f71098d9056cb52f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c066b59df050eccc22844dec36be6d5/" rel="bookmark">
			数学建模学习笔记（二）：图论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅对部分与数学建模相关且陌生的问题进行学习和整理。
一、网络最大流问题
1. 线性规划模型
最大流问题可以写为如下的线性规划模型：
2. 寻找最大流的标号法（Ford-Fulkerson）
（1）标号过程 （2）增流过程 （代码实现-Lingo）
二、最小费用最大流问题
1. 线性规划模型
其中， 2. 求最小费用流的一种迭代方法
（1）求出从发点到收点的最小费用通路
（2）对该通路分配最大可能的流量: （3）作该通路上所有边的反向边,令 （4）重复上述步骤，直到发点和收点的全部流量等于指定的为止
三、旅行商问题（TSP）
一名推销员准备前往若干城市推销产品，然后回到驻地。如何为他设计一条最短的旅行路线（从驻地出发，每个城市恰好经过一次，最后返回驻地）？
1. 修改圈近似算法
首先求一个Hamilton圈C，然后适当修改C以得到具有较小权的另一个Hamilton圈。
2. 数学规划模型
设城市的个数为，两个城市与之间的距离为，=0或1（走过城市到城市的路与否）
四、计划评审方法（PERT）和关键路线法（CPM）
PERT和CPM是网络分析的重要组成部分，广泛用于系统分析和项目管理。
1. 计划网络图的数学规划问题
V: 所有的事件集合 A: 所有作业的集合
2. 关键路线与计划网络的优化
(1)计划网络优化的数学表达式
: 事件i的开始时间 : 作业(i,j)的计划时间 : 完成作业(i,j)的最短时间 : 要求完成的天数
: 作业(i,j)可能减少的时间 : 作业(i,j)缩短一天工期增加的费用
(2)完成作业期望和实现事件的概率
通常，对完成一项作业可以给出三个时间上的估计值：最乐观的估计值(a),最悲观的估计值(b),最可能的估计值(m)
: 完成作业（i，j）的实际时间，相应的数学期望和方差为：
五、钢管订购和运输
要铺设一条输送天然气的主管道，请制定一个主管道钢管的订购和运输计划，使总费用最小。
数学规划模型：
从生产商到的最小购运费（出售价与运输费之和） 从钢厂运到节点的钢管量
从节点向左铺设的钢管量 从节点向右铺设的钢管量 第家钢厂的最大供应量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d77fddc486080836f4e453f097ff7732/" rel="bookmark">
			上取整与下取整的解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 向上取整, 运算称为 Ceiling，用数学符号 ⌈⌉ （上有起止，开口向下）表示,。
向下取整, 运算称为 Floor，用数学符号 ⌊⌋ （下有起止，开口向上）表示。
注意，向上取整和向下取整是针对有浮点数而言的; 若整数向上取整和向下取整， 都是整数本身。
四舍五入：更接近自己的整数； 把小数点后面的数字四舍五入
即：如被舍去部分的头一位数字小于五，则舍去; 如大于等于五，则被保留部分的最后一位数字加1向上取整：比自己大的最小整数；向下取整：比自己小的最大整数； System.out.println(Math.ceil(1.1));//上取整 比自己大的最小整数 System.out.println(Math.floor(1.1));//下取整 比自己小的最大整数 System.out.println(Math.ceil(3));//整数时等于自己 System.out.println(Math.floor(3));//整数时等于自己 System.out.println("================="); System.out.println(Math.ceil(-1.1));//上取整 比自己大的最小整数 System.out.println(Math.floor(-1.1));//下取整 比自己小的最大整数 System.out.println(Math.ceil(-3));//整数时等于自己 System.out.println(Math.floor(-3));//整数时等于自己 运行结果： 2.0 1.0 3.0 3.0 ================= -1.0 -2.0 -3.0 -3.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bcc64424f0296200b5a25aa04f28dd7/" rel="bookmark">
			C语言--线索二叉树创建与遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线索二叉树就是把左或者右孩子为空的位置，设置为前驱或者后继
因为中序遍历第一个元素是C，没有前驱，最后一个元素F也没有后继，所以我们设置一个头结点，C的前驱和F的后继都指向投节点，头节点的前驱为根节点，后继为最后一个元素F。
#include"stdio.h" #include"stdlib.h" //线索标志位 //link表示指向左右孩子 //thread表示指向前驱后继 enum{link, thread}; //二叉树结构体 struct btree { char data; struct btree *lchild, *rchild; int ltag, rtag; }; //全局变量，指向刚访问过的结点 struct btree *pre; //用户按照前序遍历方式创建二叉树 void create_btree(struct btree **T) { char c; *T = (struct btree *)malloc(sizeof(struct btree)); scanf("%c", &amp;c); if(' ' == c) { *T = NULL; } else { (*T)-&gt;data = c; //线索标志位全部初始化为link (*T)-&gt;ltag = link; (*T)-&gt;rtag = link; create_btree(&amp;(*T)-&gt;lchild); create_btree(&amp;(*T)-&gt;rchild); } } //中序遍历二叉树，更改线索标志位以及前驱后继 void inthread(struct btree *T) { if(T) { inthread(T-&gt;lchild); //如果左孩子为空，线索标志位改为thread，lchild指向前驱 //中序遍历二叉树的第一个结点的前驱为头结点 if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bcc64424f0296200b5a25aa04f28dd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a340d118d4fd96e711febadb88b5861e/" rel="bookmark">
			C&#43;&#43;接口工程实践：有哪些实现方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：程序开发的时候经常会使用到接口。众所周知，C++语言层面并没有接口的概念，但并不意味着C++不能实现接口的功能。相反，正是由于C++语言没有提供标准的接口，导致实际实现接口的方法多种多样。那么C++有哪些实现接口的方法呢，不同的方法又适用于哪些场景呢？本文分享在C++接口工程实践上的一些探索心得。 一 接口的分类 接口按照功能划分可以分为调用接口与回调接口：
调用接口 一段代码、一个模块、一个程序库、一个服务等（后面都称为系统），对外提供什么功能，以接口的形式暴露出来，用户只需要关心接口怎么调用，不用关心具体的实现，即可使用这些功能。这类被用户调用的接口，称为调用接口。
调用接口的主要作用是解耦，对用户隐藏实现，用户只需要关心接口的形式，不用关心具体的实现，只要保持接口的兼容性，实现上的修改或者升级对用户无感知。解耦之后也方便多人合作开发，设计好接口之后，各模块只通过接口进行交互，各自完成各自的模块即可。
回调接口 系统定义接口，由用户实现，注册到系统中，系统有异步事件需要通知用户时，回调用户注册的接口实现。系统定义接口的形式，但无需关心接口的实现，而是接受用户的注册，并在适当的时机调用。这类由系统定义，用户实现，被系统调用的接口，称为回调接口。
回调接口的主要作用是异步通知，系统定义好通知的接口，并在适当的时机发出通知，用户接收通知，并执行相应的动作，用户动作执行完后控制权交还给系统，用户动作可以给系统返回一些数据，以决定系统后续的行为。
二 调用接口 我们以一个Network接口为例，说明C++中的调用接口的定义及实现，示例如下：
class Network { public: bool send(const char* host, uint16_t port, const std::string&amp; message); } Network接口现在只需要一个send接口，可以向指定地址发送消息。下面我们用不同的方法来定义Network接口。
虚函数 虚函数是定义C++接口最直接的方式，使用虚函数定义Network接口类如下：
class Network { public: virtual bool send(const char* host, uint16_t port, const std::string&amp; message) = 0; static Network* New(); static void Delete(Network* network); } 将send定义为纯虚函数，让子类去实现，子类不对外暴露，提供静态方法New来创建子类对象，并以父类Network的指针形式返回。接口的设计一般遵循对象在哪创建就在哪销毁的原则，因此提供静态的Delete方法来销毁对象。因为对象的销毁封装在接口内部，因此Network接口类可以不用虚析构函数。
使用虚函数定义接口简单直接，但是有很多弊端：
虚函数开销：虚函数调用需要使用虚函数表指针间接调用，运行时才能决定调用哪个函数，无法在编译链接期间内联优化。实际上调用接口在编译期间就能确定调用哪个函数，无需虚函数的动态特性。 二进制兼容：由于虚函数是按照索引查询虚函数表来调用，增加虚函数会造成索引变化，新接口不能在二进制层面兼容老接口，而且由于用户可能继承了Network接口类，在末尾增加虚函数也有风险，因此虚函数接口一经发布，难以修改。 指向实现的指针 指向实现的指针是C++比较推荐的定义接口的方式，使用指向实现的指针定义Network接口类如下：
class NetworkImpl; class Network { public: bool send(const char* host, uint16_t port, const std::string&amp; message); Network(); ~Network(); private: NetworkImpl* impl; } Network的实现通过impl指针转发给NetworkImpl，NetworkImpl使用前置声明，实现对用户隐藏。使用指向实现的指针的方式定义接口，接口类对象的创建和销毁可以由用户负责，因此用户可以选择将Network类的对象创建在栈上，生命周期自动管理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a340d118d4fd96e711febadb88b5861e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85770b26df2eec24608e892d7412307f/" rel="bookmark">
			文本表示（三）—— fasttext 词向量调用代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型训练 分类算法（二）—— FastText
原理介绍 分类算法（二）—— FastText（原理介绍）
词向量调用代码：
import fasttext model_path = 'vec.bin' # model是分类模型训练得到的model model=fasttext.load_model(model_path) w = model.get_word_vector('词向量') print(len(w)) sentence_w=model.get_sentence_vector('️韩国百年大学药科学教授组倾力研发内含多肽成分延缓衰老') print(len(sentence_w)) print(sentence_w) ----------------------------------------
发现了一篇比较好的文章
https://blog.csdn.net/sinat_26917383/article/details/83041424 貌似可以直接训练fasttext的词向量，且包含word2vec和glove词向量训练链接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b24742f5987e7389ca1e849c7c42ac/" rel="bookmark">
			Navicat 连接 oracle library is not loaded的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Navicat 连接oracle 数据库报了如上错误，百度了下，需要替换一个oci.dll文件，不过网上找的基本都不管用，在这里分享一下我的。
百度链接：
链接：https://pan.baidu.com/s/1R03FQWOc6gFkRaG9mXl75Q 提取码：8888 复制这段内容后打开百度网盘手机App，操作更方便哦--来自百度网盘超级会员V4的分享 下载之后直接解压就可以，然后在Navicat 软件中设置一下此文件夹下的oci.dll文件指向目录，具体看截图
确认保存之后记得重启软件才可以生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a8d9ffa2a8b59ce609928b035cd088/" rel="bookmark">
			秋招面试  建信融通一面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java 中的基本数据类型
String 的不可变性以及为什么
JVM 的执行流程
什么时候会GC
什么是STW， STW发生的时刻
方法区存放的是什么
元空间会不会内存溢出
双亲委派机制
垃圾回收算法
分代垃圾回收
什么时候会进入老年代
单例模式
synchronized的用法
介绍volatile
介绍内存屏障
介绍Java中的引用
介绍spring ioc \ aop
介绍spring中两种动态代理的区别
介绍Joinpoint
介绍 beanfactory \ factorybean
介绍hashmap的源码
介绍死锁
怎么处理死锁
MYSQL 事务之间怎么处理死锁
介绍数据结构 平衡二叉树、二叉排序树查找元素的时间复杂度
如何遍历二叉树、求二叉树的深度
如何判断一个链表中存在一个环
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc5457db9218400e30ebbaad8369368d/" rel="bookmark">
			Ubuntu18.04安装gtsam因子图步骤及踩坑忠告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18.04安装gtsam因子图步骤及踩坑忠告 我尝试安装gtsam库一天，最终把坑填了，都是泪啊啊。。。。
一、官网上的安装步骤(失败经验，可跳过) 1、首先安装依赖项：Boost，Cmake，gcc（其中gcc系统一般自带）
Prerequisites:
Boost &gt;= 1.43 (Ubuntu: sudo apt-get install libboost-all-dev) CMake &gt;= 3.0 (Ubuntu: sudo apt-get install cmake) A modern compiler, i.e., at least gcc 4.7.3 on Linux. 以下是可选项：（我只选了第一项）
Optional prerequisites - used automatically if findable by CMake:
Intel Threaded Building Blocks (TBB) (Ubuntu: sudo apt-get install libtbb-dev) Intel Math Kernel Library (MKL) (Ubuntu: installing using APT) See INSTALL.md for more installation information Note that MKL may not provide a speedup in all cases.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc5457db9218400e30ebbaad8369368d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ed935e5a7db5d350d117b774a04d7e/" rel="bookmark">
			触发器型PFD与传统型PFD性能仿真对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		触发器型PFD与传统型PFD性能仿真对比 1.电路结构1.1传统型电路结构1.2 触发器型电路结构 2.电路仿真2.1仿真电路模型2.2 死区时间：2.3鉴相范围::2.4功耗仿真2.5 最高工作频率 3.问题 鉴频鉴相器中为了保证鉴相范围，主要有两种PFD可以在理想情况下实现 − 2 π -2\pi −2π到 2 π 2\pi 2π的鉴相范围。 传统的PFD和边沿触发型的PFD 1.电路结构 1.1传统型电路结构 参考文献：宽带CMOS分数频率合成器的研究与实现——黄福青 东南大学博士论文
1.2 触发器型电路结构 参考文献：A High Speed and Low Power Phase-Frequency Detector and Charge - pump
此电路在仿真对比的时候，没有采用图中为伪nor结构，采用静态CMOS逻辑的或非门，并且加入了delaybuffer，来消除死区。
2.电路仿真 2.1仿真电路模型 两种PFD采用相同的测试电路，电源电压0.7V。输出负载50fF。
2.2 死区时间： 输入同频同相时钟信号30MHz，脉冲的上升沿50%到下降沿50%为脉冲宽度。
传统型经过加入delay后UP和DN 脉宽约为333ps，即为复位延迟时间。
触发器型经过加入delay buffer后复位延迟为300ps
两者的复位延迟时间比较意义不大，都可以通过调节delay buffer延时获得。
2.3鉴相范围:: 两个电路理论上均可以实现 − 2 π -2\pi −2π到 2 π 2\pi 2π的鉴相范围，但由于鉴相盲区的存在，无法实现理想的鉴相范围。
仿真方法：仿真时在fref 端和fdiv 端同时输入30MHz 的方波信号，设置fref的初相（度数以延时表达）为1/fref，fdiv的初相（度数以延时表达）为(360+a)/(360*fdiv)，a 为变量，并对a 进行变量扫描，扫描范围为（-400，400），步长为5，选取VUP-VDN 的平均值VPFD做为输出，即可得到PFD 的鉴相鉴相特性曲线。参数设置如下：
传统型仿真结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ed935e5a7db5d350d117b774a04d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0083d95ad1eca69c0de9144acff567/" rel="bookmark">
			记一次面试算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目是这样的：
假设我们爬虫团队采集到了天猫的行业信息，例如：
industry_list = [
{
“parent_ind” : “女装”,
“name” : “连衣裙”
},
{
“name”: “女装”
},
{
“parent_ind” : “女装”,
“name” : “半身裙”
},
{
“parent_ind” : “女装”,
“name” : “A字裙”
},
{
“name”: “数码”
},
{
“parent_ind” : “数码”,
“name”: “电脑配件”
},
{
“parent_ind” : “电脑配件”,
“name”: “内存”
},
]
为了取用方便，我们希望可以将其转换为树状格式，例如：
{
“数码”: {
“电脑配件”: {
“内存” : {}
},
“女装” : {
“连衣裙”: {},
“半身裙”: {},
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d0083d95ad1eca69c0de9144acff567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90aacf54c1ff0ed76633663903cee502/" rel="bookmark">
			第七章 存储系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第七章 存储系统 文章目录 第七章 存储系统7.1 存储系统的层次结构7.1.1 存储系统的层次结构概述7.1.2 存储系统的性能参数7.1.3 三级存储系统7.1.4 存储层次的四个问题 7.2 Cache的基本知识7.2.1 基本结构和原理7.2.2 映像规则7.2.3 查找算法7.2.5 替换算法7.2.6 写策略7.2.7 Cache性能分析7.2.8 改进Cache性能 7.3 降低Cache的不命中率7.3.1 三种类型的不命中7.3.2 增加Cache块大小7.3.3 增加Cache容量7.3.4 提高相联度7.3.5 伪相联Cache7.3.6 硬件预取7.3.7 编译器控制的预取7.3.8 编译优化7.3.9 牺牲Cache 7.4 减少Cache的不命中开销7.4.1 采用两级Cache7.4.2 让读不命中优先于写7.4.3 写缓冲合并7.4.4 请求字处理技术7.4.5 非阻塞Cache技术 7.5 减少命中时间7.5.1 容量小，结构简单的cache7.5.2 虚拟cache7.5.3 cache访问流水化7.5.4 踪迹cache7.5.5 cache优化技术总结 链接： https://pan.baidu.com/s/1WyftXZzso0_ePWaMDDCUPw 提取码：hu2b 7.1 存储系统的层次结构 7.1.1 存储系统的层次结构概述 7.1.1从单级存储器到多级存储器
1．从用户的角度来看，存储器的三个主要指标:
容量、速度和价格（指每位价格）
2．人们对这三个指标的要求
容量大、速度快、价格低
3.三个要求是相互矛盾的
速度越快，每位价格就越高;容量越大，每位价格就越低;容量越大，速度越慢。 多级存储层次
程序访问的局部性原理
7.1.2 存储系统的性能参数 平均每位价格C1
命中率H
平均访问时间T（A）
7.1.3 三级存储系统 “Cache一主存”和“主存一辅存”层次
从主存的角度来看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90aacf54c1ff0ed76633663903cee502/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75836da7f7ed493e00c158e73c792ea/" rel="bookmark">
			2020-09-02利用Ajax请求数据并在模态框展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台代码，注意返回值类型是单个结果集，不是集合，如果返回了集合需要遍历否则前台无法解析集合只能解析json
@RequestMapping("getPersonById") public void getPersonById(Integer person_id, HttpServletResponse response, Model model) throws IOException { Persondesc alarmTask1=personService.getPersonById(person_id); model.addAttribute("alarmTask",alarmTask1); String alarmTask = JSON.toJSONString(alarmTask1); response.getWriter().write(alarmTask); } 前台展示代码
&lt;div class="modal fade" id="queryInfo" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal" aria-hidden="true"&gt;&amp;times;&lt;/button&gt; &lt;h4 class="modal-title" id="myModalLabel"&gt;详细信息&lt;/h4&gt; &lt;/div&gt; &lt;form action="${pageContext.request.contextPath }/productServlet?type=info" method="post"&gt; &lt;div class="modal-body"&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;description&lt;/span&gt; &lt;input type="text" class="form-control" placeholder="description" id="description" readonly="readonly"&gt; &lt;/div&gt; &lt;br /&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt;skill&lt;/span&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75836da7f7ed493e00c158e73c792ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76bd1256b6f5ad2098442f412fcfbb99/" rel="bookmark">
			winfrom界面美化（cskin）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.cskin控件的引用
2.可能会产生闪屏的问题
附： private void SetStyles()
{
base.SetStyle(
ControlStyles.UserPaint |
ControlStyles.AllPaintingInWmPaint |
ControlStyles.OptimizedDoubleBuffer |
ControlStyles.ResizeRedraw |
ControlStyles.DoubleBuffer, true);
base.UpdateStyles();
base.AutoScaleMode = AutoScaleMode.None;
}
闪屏会减轻很多
3.引用之后可以放到工具箱进行拖拽使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f22b086831e61132216bd1dd6549f208/" rel="bookmark">
			Android性能优化之SparseArray
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是性能优化？几种数据结构比较线性数据结构顺序表与链表Hash表HashMapSparseArrayHashMap 与 SparseArray HashMap 和 SparseArray性能对比内存时间 什么是性能优化？ 一款app除了要有令人惊叹的功能和令人发指交互之外，在性能上也应该追求丝滑的要求，这样才能更好地提高用户体验。
几种数据结构比较 线性数据结构 顺序表与链表 Hash表 HashMap SparseArray HashMap 与 SparseArray HashMap 和 SparseArray性能对比 内存 两个按钮操作，分别执行：添加100000（10万）个数字到HashMap和SparseArray中。然后查看内存使用情况。
final int LENGTH = 100000; btnHashMap.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new AsyncTask() { @Override protected Object doInBackground(Object[] objects) { for (int i = 0; i &lt; LENGTH; i++) { hashMap.put(i, new byte[10]); } return null; } }.execute(); } }); btnSparseArray.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new AsyncTask() { @Override protected Object doInBackground(Object[] objects) { for (int i = 0; i &lt; LENGTH; i++) { sparseArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f22b086831e61132216bd1dd6549f208/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91ec65dbba3ebb64e1e49483be59eb9/" rel="bookmark">
			cython使用方法（不是 CPython）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cython概览 参考文献：Cython的用法以及填坑姿势
为什么用cython（注意区别于 CPython） 因为项目需要，需要优化已有的Python代码。目前Python代码的执行过程是将Python代码转变成一行行指令，然后解释器解释指令的执行，调用到C代码层。如果去掉指令解释这个阶段，直接进入C代码层，效率就比较高了。如果用之前所述的使用Python C API将Python代码改造为C代码并作为Python的内建模块，工作量极其大，也不能保证其正确性，所以这种方法不太现实。而Cython库正好符合这种场景需求，将已有的Python代码转化为C语言的代码，并作为Python的built-in模块扩展。
Cython语言使得Python语言的C扩展与Python本身一样简单。Cython语言是Python语言的一个超集（几乎所有的Python代码是有效的），但Cython还支持可选的静态类型来调用C函数，使用C++类和声明快C类型变量和类的属性。这允许编译器从Cython代码生成非常高效的C代码。
这使得Cython编写外部C / C++库代码的理想语言，和快速的C模块，提高Python代码的执行速度。
Cython 可以让我们方便地：
用 Python 的语法混合编写 Python 和 C/C++ 代码，提升 Python 速度调用 C/C++ 代码 cython相关文件类型 需要了解的几种Python文件类型介绍：
.py ： python的源代码文件.pyx ： python的c扩展文件(cython使用该类型的文件，代码要符合cython的规范).pyc： Python源代码import后，编译生成的字节码.pyo： Python源代码编译优化生成的字节码。pyo比pyc并没有优化多少，只是去掉了断言.pyd： Python的动态链接库(Windows平台).so ： Python的动态链接库(Linux平台) .py, .pyc, .pyo 运行速度几乎无差别，只是pyc, pyo文件加载的速度更快，不能用文本编辑器查看内容，反编译不太容易
cython工作流程 pyx文件是python的c扩展文件，代码要符合cython的规范，用什么编辑器写都行。
上面的pyx文件还仅仅是源代码文件，要想被python调用、要想运行，仅仅写了源代码还是不够的。具体来说，还要转成.c或者.c++的文件，并且再进一步转成.pyd或.so文件，pyd或so文件才是可以直接使用的文件。
cython基本使用方法 （1）在使用Cython编译Python代码时，务必要安装C/C++编译器（windows可以直接安装Visiual Studio 的开发环境）
（2）安装Cython库：
pip install Cython
（3）编写.pyx文件，如test.pyx（或者直接写.py也可以？只要文件里不使用cpython独有的语法，而是使用纯python语法）
def say_hello(): print "hello world" def say_hello():
print "hello world"
（4）编写.setup文件
from distutils.core import setup from Cython.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f91ec65dbba3ebb64e1e49483be59eb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2545139f5f380624cad1bd2d1d95cb51/" rel="bookmark">
			python 在不同层级目录import 模块的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python包含子目录中的模块方法比较简单，关键是能够在sys.path里面找到通向模块文件的路径。
下面将具体介绍几种常用情况:
（1）主程序与模块程序在同一目录下:
如下面程序结构:
`-- src
|-- mod1.py
`-- test1.py
若在程序test1.py中导入模块mod1, 则直接使用import mod1或from mod1 import *;
（2）主程序所在目录是模块所在目录的父(或祖辈)目录
如下面程序结构:
`-- src
|-- mod1.py
|-- mod2
| `-- mod2.py
`-- test1.py
若在程序test1.py中导入模块mod2, 需要在mod2文件夹中建立空文件__init__.py文件(也可以在该文件中自定义输出模块接口); 然后使用 from mod2.mod2 import * 或import mod2.mod2.
（3）主程序导入上层目录中模块或其他目录(平级)下的模块
如下面程序结构:
`-- src
|-- mod1.py
|-- mod2
| `-- mod2.py
|-- sub
| `-- test2.py
`-- test1.py
若在程序test2.py中导入模块mod1和mod2。首先需要在mod2下建立__init__.py文件(同(2))，src下不必建立该文件。然后调用方式如下:
下面程序执行方式均在程序文件所在目录下执行，如test2.py是在cd sub;之后执行python test2.py
而test1.py是在cd src;之后执行python test1.py; 不保证在src目录下执行python sub/test2.py成功。
import sys
sys.path.append("..")
import mod1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2545139f5f380624cad1bd2d1d95cb51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4250b81c9c478465e0e43478a739c3d8/" rel="bookmark">
			第八章 输入输出系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第八章 输入输出系统 文章目录 第八章 输入输出系统8.1 I/O系统的性能8.2 I/O系统的可靠性，可用性，可信性8.3 廉价磁盘冗余阵列8.3.1 RAID08.3.2 RAID18.3.3 RAID28.3.4 RAID38.3.5 RAID48.3.6 RAID58.3.7 RAID68.3.8 RAID10和RAID018.3.9 RAID的实现和发展 8.4 总线8.4.1 总线的设计8.4.2 总线标准和实例8.4.3 与CPU的连接 8.5 通道处理机8.5.1 通道的作用和功能8.5.2 通道的工作过程8.5.3 通道种类8.5.4 通道流量分析 链接： https://pan.baidu.com/s/1WyftXZzso0_ePWaMDDCUPw 提取码：hu2b 8.1 I/O系统的性能 1.输入/输出系统简称I/0系统
它包括:
I/O设备I/O设备与处理机的连接 2.I/0系统是计算机系统中的一个重要组成部分
完成计算机与外界的信息交换给计算机提供大容量的外部存储器 3．按照主要完成的工作进行分类:
存储I/0系统（本章内容）通信I/O系统 4.人们对I/0系统的作用和性能没有给予足够的重视.
人们更多地关注: CPU的性能
​ 许多人甚至认为CPU的速度就是计算机的速度。
I/O设备通常被称为外围设备。
​ (外围的就似乎没那么重要了）
5.系统的响应时间(衡量计算机系统的一个更好的指标)
从用户输入命令开始，到得到结果所花费的时间。
由两部分构成: I/0系统的响应时间 CPU的处理时间
6.误区:使用多进程技术可以忽略I/O性能对系统性能的影响
多进程技术只能够提高系统吞吐率，并不能够减少系统响应时间。进程切换时可能需要增加l/0操作。可切换的进程数量有限，当I/0处理较慢时，仍然会导致CPU处于空闲状态。 8.2 I/O系统的可靠性，可用性，可信性 1．处理器性能已经很高，人们更加关注系统可靠性。
2．反映外设可靠性能的参数有:
可靠性（Reliability)可用性（Availability)可信性（Dependability) 3.系统的可靠性:系统从某个初始参考点开始一直连续提供服务的能力。
用平均无故障时间MTTF来衡量。(Mean Time To Failure)
MTTF的倒数就是系统的失效率。
如果系统中每个模块的生存期服从指数分布，则系统整体的失效率是各部件的失效率之和。
4.系统的可用性:系统正常工作的时间在连续两次正常服务间隔时间中所占的比率。
5.系统的可信性:服务的质量。即在多大程度上可以合理地认为服务是可靠的。（不可以度量）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4250b81c9c478465e0e43478a739c3d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d8c84c20d934680b4d2cb83e9b7459/" rel="bookmark">
			String字符串的存储原理（学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String字符串的存储原理（学习笔记） 关于Java JDK 中内置的一个类：java.lang.String
1.String表示字符串类型，是引用数据类型，不是基本的数据类型。
2.使用双引号括起来的都是String对象。比如：“abc”，“java”，这就是两个String对象。
3.String 类是不可变类，也就是说 String 声明对象以后，将不可修改，“abc"从出生到死亡，不可能变成"abcd”，“ab”。
4.Java中，使用双引号括起来的字符串，都直接存储在"方法区"的“字符串常量池中”。
这么做的原因：字符串在实际的开发中使用的太频繁，为了执行效率，所以把字符串放到了方法区的字符串常量池当中。
5.除了双引号的构造方法，还可以通过new的方式来创建字符串对象，如使用：String s3=new String("xy")；来创建字符串对象。
​ 两种构造方式有何不同，用以下例子来说明：
例1.用双引号创建字符串对象 public class StringTest01{ public static void main(String[] args){ String s1 ="abcdef"; String s2="abcdef"+"xy"; } } 来画一下这个程序的内存图：
大框表示JVM虚拟机。里面分为三个部分，方法区，堆和栈。 2. 首先会在方法区进行类加载，包括StringTest01.class，String.class，代码片段，静态变量等。
3. 执行main方法，main方法会压栈，生成main方法栈帧。
4. 执行main方法的第一句，在方法区的字符串常量池生成String对象"abcdef"，其内存地址，比如0x1234。
5. 将字符串"abcdef"的内存地址0x1234赋值给了s1，String s1表示一个引用，s1这个局部变量中存放的是"abcd"的内存地址，而不是"abcd"字符串本身。所以在mian方法栈中出现了一个局部变量s1，存储"abcdef"的内存地址0x1234。
执行main方法的第二句，第二句是一个字符串的拼接String s2="abcdef"+"xy"; 因为"abcdef"已经在字符串常量池中有了，所以不用再新建，那么会在常量池中创建字符串对象“xy”。
但是注意：此时没有一个引用指向字符串对象"xy"!
由于拼接的操作，在字符串常量池中，字符串对象“abcdef”和字符串对象“xy”进行拼接，生成了新的字符串对象“abcdefxy”，假设它的内存地址是0x2356。 将字符串"abcdefxy"的内存地址0x2356赋值给了s2，String s2表示一个引用，s2这个局部变量中存放的是"abcdefxy"的内存地址，而不是"abcdefxy"字符串本身。所以在mian方法栈中出现了一个局部变量s2，存储"abcdefxy"的内存地址0x2356。 结论:这两行代码最终创建了3个字符串对象，都存放在字符串常量池中，栈帧中的两个变量存放的是字符串在字符串常量池的内存地址。
例2：用new方式创建字符串对象 我们在例1的基础上创建s3:
public class StringTest01{ public static void main(String[] args){ String s1 ="abcdef"; String s2="abcdef"+"xy"; String s3 = new String("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d8c84c20d934680b4d2cb83e9b7459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6bad60c2559f25869f4fb4e2a6cf5b/" rel="bookmark">
			超全！！hive时间戳函数unix_timestamp，from_unixtime
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 时间戳是数据库常用的存放日期的形式之一，表示从 UTC 时间’1970-01-01 00:00:00’开始到现在的秒数，与常规时间格式如 ‘2020-09-01 00:00:00’可以相互转换。时间戳分为10位的时间戳和13位的时间戳,10位就是存放的秒数，13位就是存放的毫秒数。
（1）unix_timestamp
a. 语法：unix_timestamp() 返回值：返回当前时间戳 举例：hive&gt;select unix_timestamp(); &gt;1598951117 b. 语法：unix_timestamp(string data) 返回值：返回data对应的时间戳，data的格式必须为yyyy-MM-dd HH:mm:ss 举例：hive&gt;select unix_timestamp('2020-09-01 09:00:00'); &gt;1598922000 c. 语法：unix_timestamp(string date, string format) 返回值：返回data对应的时间戳，date 格式由 format 指定。 （2）from_unixtime
语法：from_unixtime(int/bigint timestamp) 返回值：返回timestamp对应的日期，格式为yyyy-MM-dd HH:mm:ss 举例：hive&gt;select from_unixtime(1598951117); &gt;2020-09-01 17:05:17 对于13位的时间戳，转换前需要除以1000
举例：hive&gt;select from_unixtime(cast(1598951117034/1000 as bigint),'yyyy-MM-dd HH:mm:ss') &gt;2020-09-01 17:05:17 举例：hive&gt;select from_unixtime(ceil(1598951117034/1000),'yyyy-MM-dd HH:mm:ss') &gt;2020-09-01 17:05:17 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546c8a24b7c8d9638982fec2907680c1/" rel="bookmark">
			电商销售数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景与目标 2.数据准备 3.数据清洗 4.具体目标分析 5.案例结论 1.背景与目标 对一家全球超市4年（2011年-2014年）的零售数据进行数据分析
数据分析的目标：
* 分析每年销售额增长率
* 各个地区分店的销售额
* 销售淡旺季
* 新老客户数
* 利用RFM模型标记用户价值
2.数据准备 数据来源于数据科学竞赛平台，总共51290条数据，24个字段。
导入数据 import pandas as pd data= pd.read_csv('./dataset2011-2015.csv',encoding='ISO-8859-1') print('源数据的形状为：',data.shape) # print(data.head()) # data.head() data.info() 画图时兼容中文字体 import pandas as pd import numpy as np import matplotlib as plt import matplotlib as mpl # 设置字体 #rcParams 修改mat 配置文件 #了解 mpl.rcParams['font.sans-serif'] = ['SimHei'] # 导入数据，并将列名中文化 ''' csv常见编码格式:UTF-8、GBK 、ISO-8859-1 ''' #ISO-8859-1 编码格式 utf-8 gbk df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/546c8a24b7c8d9638982fec2907680c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0850f76ea6699708d128c58a17c71818/" rel="bookmark">
			JavaScript常见类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 值转换为
字符串转换为
数字转换为
布尔值转换为
对象undefined“undefined”NaNfalsethrows TypeErrornull“null”0falsethrows TypeErrortrue“true”1new Boolean(true)false“false”0new Boolean(false)“”(空字符串)0falsenew String("")“1.2”(非空，数字）1.2truenew String(“1.2”)“one”(非空，非数字）NaNtruenew String(“one”)0“0”falsenew Number(0)-0“0”falsenew Number(-0)NaN“NaN”falsenew Number(NaN)Infinity“Infinity”truenew Number(Infinity)- Infinity“-Infinity”truenew Number(-Infinity)1(无穷大，非零）“1”truenew Number(1){}(任意对象)true[]（任意数组）“”0true[9](1个数字元素）“9”9true[‘a’]（其他数组）使用join()方法NaNtruefunction(){}(任意函数）NaNtrue 字符串转换为数字 以数字表示的字符串可以转换为数字，允许在开始和结尾处带有空格。但在开始和结尾处的任意空格都不会被当成数字直接量的一部分，进而造成字符串转换为数字的结果为NaN. 转换和相等性 下面的比较结果均是true:
null == undefined	// 这两值被认为相等 "0" == 0	// 在比较之前字符串转换成数字 0 == false	// 在比较之前布尔值转换成数字 "0" == false	// 在比较之前字符串和布尔值都转换成数字 Notes:
一个值转换为另一个值并不意味着两个值相等。undefined == false // false "=="运算符从不试图将其操作数转换为布尔值“===“恒等运算符在判断相等时不做任何类型变换 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a020acb15d9f9e7b234513e236146515/" rel="bookmark">
			介绍版本控制分类Git/Svn Git特性与基础用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 了解版本控制软件的作用了解版本控制系统的分类Git的特性初始化 Git 仓库的命令查看文件状态的命令一次性将文件加入暂存区的命令将暂存区的文件提交到 Git 仓库的命令 版本控制软件(⭐⭐⭐) 概念 版本控制软件是一个用来记录文件变化，以便将来查阅特定
版本修订情况的系统，因此有时也叫做“版本控制系统”
通俗的理解 把手工管理文件版本的方式，改为由软件管理文件的版本；
这个负责管理文件版本的软件，叫做“版本控制软件”
使用版本控制软件的好处 操作简便：只需识记几组简单的终端命令，即可快速上手常见的版本控制软件**易于对比：**基于版本控制软件提供的功能，能够方便地比较文件的变化细节，从而查找出导致问题的原因**易于回溯：**可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态**不易丢失：**在版本控制软件中，被用户误删除的文件，可以轻松的恢复回来**协作方便：**基于版本控制软件提供的分支功能，可以轻松实现多人协作开发时的代码合并操作 版本控制系统的分类(⭐⭐⭐) 本地版本控制系统 单机运行，使维护文件版本的操作工具化
特点： 使用软件来记录文件的不同版本，提高了工作效率，降低了手动维护版本的出错率
缺点： ① 单机运行，不支持多人协作开发
② 版本数据库故障后，所有历史更新记录会丢失
集中化的版本控制系统 联网运行，支持多人协作开发；性能差、用户体验不好
典型代表 SVN
特点： 基于服务器、客户端的运行模式
① 服务器保存文件的所有更新记录
② 客户端只保留最新的文件版本
**优点：**联网运行，支持多人协作开发
缺点： ① 不支持离线提交版本更新
② 中心服务器崩溃后，所有人无法正常工作
③ 版本数据库故障后，所有历史更新记录会丢失
分布式版本控制系统 联网运行，支持多人协作开发；性能优秀、用户体验好
典型代表：Git
特点： 基于服务器、客户端的运行模式
① 服务器保存文件的所有更新版本
② 客户端是服务器的完整备份，并不是只保留文件的最新版本
优点：
① 联网运行，支持多人协作开发
② 客户端断网后支持离线本地提交版本更新
③ 服务器故障或损坏后，可使用任何一个客户端的备份进行恢复
Git基础概念 什么是 Git Git 是一个开源的分布式版本控制系统，是目前世界上最先进、最流行的版本控制系统。可以快速高效地处理从很小到非常大的项目版本管理。
特点：项目越大越复杂，协同开发者越多，越能体现出 Git 的高性能和高可用性！
Git 的特性(⭐⭐⭐) Git 之所以快速和高效，主要依赖于它的如下两个特性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a020acb15d9f9e7b234513e236146515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efe49548c51ed1007b08cbbcdaccbbd2/" rel="bookmark">
			配置nginx代理grafana实现域名访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的： 通过Nginx服务器对grafana进行代理，实现通过https://域名/grafana在公网进行访问
实践过程： 1、修改Nginx配置(nginx.conf)文件，添加访问grafana的配置，配置时注意proxy_pass后面一定要有符号 /（目的是去掉/grafana/以匹配本身）
vi /usr/local/nginx/conf/nginx.conf server { listen 443 ssl; server_name example.com; ssl_certificate cert/example.com.pem; ssl_certificate_key cert/example.com.key; location / { root html; index index.html index.htm; } location /grafana/ { root html; index index.html index.htm; proxy_pass http://192.168.31.90:3000; proxy_redirect default; proxy_max_temp_file_size 0k; proxy_connect_timeout 30; proxy_send_timeout 60; proxy_read_timeout 60; proxy_next_upstream error timeout invalid_header http_502; } } 2、修改grafana服务器的配置文件(grafana.ini)，注意需要去掉行前的注释符号 “;”
[server]段涉及以下三处需要更改：
[server] domain = 填写你的域名地址 root_url = %(protocol)s://%(domain)s:%(http_port)s/grafana/ serve_from_sub_path = true 3、reload Nginx并重启grafana服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efe49548c51ed1007b08cbbcdaccbbd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4597ce92a757d2a07910805825f63d7/" rel="bookmark">
			可穿戴技术发展阶段_可穿戴技术如何改变我们与身体的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可穿戴技术发展阶段
It’s no secret that wearable tech has gained traction over the past years. Its buyers have turned devices like the Apple Watch into a staple that everyday tech is no longer just your computer and phone. But so far, wearing certain devices has been more of a brand statement than a health tracker.
我T的什么秘密，可穿戴技术已经获得牵引在过去几年里。 它的购买者已将Apple Watch等设备变成一种必需品，使日常技术不再仅仅是您的计算机和电话。 但是到目前为止，佩戴某些设备已不仅仅是健康追踪器，更是一种品牌声明。
In theory, these devices can give us major health indicators that, in turn, could help us improve the whole health sector by monitoring or even preventing diseases.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4597ce92a757d2a07910805825f63d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c0a775845580f617d6a950ce9a9d1d/" rel="bookmark">
			【遥感导论】各种分辨率的含义与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （是几何特征）
温度分辨率 指区分地面微小温度差异的能力。现代资源遥感中所用的热红外扫描仪，温度分辨率大都在0.1-0.5℃之间。 辐射分辨率 像元：扫描图像中最小的可分辨面积，地面上最小的探测记录单位。DN值：像元灰度的数字数据，记录的是像元内地物的平均辐射值。随地物的成份、结构、状态、表面特征而变化。DN m a x _{max} max​代表了辐射量量化的等积，值越大，越能区别辐射量微小差异的像元，即辐射分辨率越大。辐射分辨率：遥感信息或仪器所能分辨的最小辐射度差。（又称辐射灵敏度） 时间分辨率 空间分辨率 对陆地卫星来说，空间分辨率就是地面分辨率，大致上相当于传感器探测地面的瞬时视场的大小。地面分辨率可以理解为在图像上显示出地面上的最小地物的尺寸（也就是像元）的大小。一般讲，凡是大于分辨率的地物可较为容易辨认；小于分辨率的地物辨认就比较困难。但能够辨认还与地物间的反差、地物形状有关，反差大，或线性地物，即使大小或宽度＜地面分辨率，有时可识别 地面分辨率（m） 【在热红外图像特征中】
取决于扫描仪瞬时视场角的大小和航高。瞬时视场角：扫描仪的扫描光学系统在任一瞬间向地面张开的立体角。瞬时视场：瞬时视场角所包括的地面范围。总视场：扫描带的地面宽度。总视场角：瞬时视场角从遥感平台到地面扫描带外侧所构成的夹角。瞬时视场的线度（直径）就是扫描仪能分辨的地面最小目标的尺寸——地面分辨率。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e38b1ea74a73d0c1c2a4dd3ce747aa/" rel="bookmark">
			Kindeditor x-ms-asf-plugin无法播放视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WechatIMG125.jpeg 环境 KindEditor 4.1.7
Google Chrome Version 85.0.4183.83 (Official Build) (64-bit)
问题 2020-08-31_5f4c9ee944d5d.png 使用 Kindeditor 编辑器上传的视频，在浏览器中无法播放，原因是 x-ms-asf-plugin 插件不支持。
解决 修改 kindeditor-min.js function mb(a) { if (/\.(rm|rmvb)(\?|$)/i.test(a)) return "audio/x-pn-realaudio-plugin"; if (/\.(mp4)(\?|$)/i.test(a)) return "video/mp4"; if (/\.(swf|flv)(\?|$)/i.test(a)) return "application/x-shockwave-flash"; return "video/x-ms-asf-plugin" } 因为 kindeditor-min.js 的代码是经过压缩的，不便于查看。进行代码美化排版一下，找到 mb 方法，增加一行if (/\.(mp4)(\?|$)/i.test(a)) return "video/mp4";，完整代码如上。
再次上传查看 Screen Shot 2020-08-31 at 3.29.02 PM.png 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc14a81b08f82bb6e7fcdf7d34a4c504/" rel="bookmark">
			分布式场景下的唯一订单号的生成方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用雪花算法生成订单号
package com.test; /** * Twitter_Snowflake&lt;br&gt; * SnowFlake的结构如下(每部分用-分开):&lt;br&gt; * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt; * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt; * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt; * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt; * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt; * 加起来刚好64位，为一个Long型。&lt;br&gt; * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 */ public class SnakGenerateOrderNo { // ==============================Fields=========================================== /** 开始时间截 (2018-07-03) */ private final long twepoch = 1530607760000L; /** 机器id所占的位数 */ private final long workerIdBits = 5L; /** 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); /** 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); /** 序列在id中占的位数 */ private final long sequenceBits = 12L; /** 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /** 工作机器ID(0~31) */ private long workerId; /** 数据中心ID(0~31) */ private long datacenterId; /** 毫秒内序列(0~4095) */ private long sequence = 0L; /** 上次生成ID的时间截 */ private long lastTimestamp = -1L; //==============================Constructors===================================== /** * 构造函数 * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnakGenerateOrderNo(long workerId, long datacenterId) { if (workerId &gt; maxWorkerId || workerId &lt; 0) { throw new IllegalArgumentException(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc14a81b08f82bb6e7fcdf7d34a4c504/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c104cce4dc02f04aca4ac1fe0de7a3a/" rel="bookmark">
			TP5.0 关于validate验证器add和edit验证规则不统一的复杂情形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TP5.0 关于validate验证器add和edit验证规则不统一的复杂情形 在validate验证，这里不提模型中验证和控制器中验证，说的是validate类，也是官方推荐的验证方式
问题是，在add中使用一套，在edit中有些字段得不一样怎么办，这时候就想到了validate中的场景scene验证，简单的edit验证，在scene里就能实现，这里记录的是复杂的情形，直接上代码
第一种方法：
add时：
1 //添加管理员表 2 $result = $this-&gt;model-&gt;validate('app\admin\validate\jq\org\Admin') 3 -&gt;validateFailException(true)-&gt;allowField(true)-&gt;save($params); 4 if ($result === false) { 5 $this-&gt;error($this-&gt;model-&gt;getError()); 6 } edit时：
1 //这里需要针对username做唯一验证 2 $adminValidate = \think\Loader::validate('app\admin\validate\jq\org\Admin'); 3 $adminValidate-&gt;rule([ 4 'username' =&gt; 'require|unique:admin,username,' . $row-&gt;id, 5 'password' =&gt; 'regex:\S{32}', 6 ]); 7 $result = $row-&gt;validate('app\admin\validate\jq\org\Admin')-&gt;allowField(true)-&gt;validateFailException(true)-&gt;save($params); 8 if ($result === false) { 9 $this-&gt;error($row-&gt;getError()); 10 } 第二种方法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a59f35fc4374c8f3b604cda8c01112f2/" rel="bookmark">
			C语言--循环链表打印拉丁方阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（新手上路）
拉丁方阵（英语：Latin square）是一种 n × n 的方阵，在这种 n × n 的方阵里，恰有 n 种不同的元素，每一种不同的元素在同一行或同一列里只出现一次。
#include "stdio.h" #include "stdlib.h" //链表结构体 struct List { int data; struct List *next; }; // 创建循环链表 void createlist(struct List **L, int n) { struct List *p; struct List *r; int i = 1; (*L) = (struct List *)malloc(sizeof(struct List)); (*L)-&gt;data = 0; (*L)-&gt;next = NULL; r = (*L); for(i = 1; i &lt;= n; i++) { p = (struct List *)malloc(sizeof(struct List)); p-&gt;data = i; p-&gt;next = NULL; r-&gt;next = p; r = p; } r-&gt;next = (*L)-&gt;next;	} int main() { struct List *L; struct List *p; int n = 0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a59f35fc4374c8f3b604cda8c01112f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f603dcad36aa28235bf586e43f4ff32b/" rel="bookmark">
			nacos dubbo grpc 注册错误 dom name can only have these characters: 0-9a-zA-Z-._:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改nacos源码 com.alibaba.nacos.naming.core.Service.java private static final String SERVICE_NAME_SYNTAX = "[0-9a-zA-Z@\\.:_:$-]+"; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f88c11c212df7944b6f59d464e51f72a/" rel="bookmark">
			解决升级gradle4.0.0因AndResGuard导致不能运行的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 gradle提示错误 No such property: variantConfiguration for class: com.android.build.gradle.internal.variant.ApplicationVariantData 解决方法 AndResGuard版本升级至1.2.18
项目根目录的build.gradle
classpath 'com.tencent.mm:AndResGuard-gradle-plugin:1.2.18' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a43fd8a1c68e05b221e0eae4562520/" rel="bookmark">
			yolov3和yolov4损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolov3和yolov4损失函数 yolov3损失函数loss公式loss代码 yolov4损失函数loss公式loss代码 yolov3损失函数 loss公式 其中：
网格共有KxK个，每个网格产生M个候选框anchor，每个anchor经过网络会得到相应的bounding box，最终形成KxKxM个bounding box，如果box内noobj，则只计算该box的置信loss。
1.回归loss会乘以一个(2-wxh)的比例系数，用来加大对小box的损失。
其中box_loss_scale=(2-wxh)；object_mask其实是个置信度，如果有目标则为1，没有目标为0；对于wh_loss采用回归方法；而对于xy_loss，上述公式采用回归方法，xi和yi hat其实是取了sigmoid之后的值，而在keras版本中，采用了交叉熵，因为raw_pred是经过model的卷积输出，如果采用sigmoid+方差，容易梯度消失，收敛较慢，所以采用二值交叉熵binary_crossentropy更容易计算。
2.置信度loss损失函数采用交叉熵，分为两部分：obj和noobj，其中noobj的loss还增加了权重系数lambda，这是为了减少noobj计算部分的贡献权重。
3.分类loss损失函数采用交叉熵，当第i个网格的第j个anchor box负责某一个真实目标时，那么这个anchor box所产生的bounding box才会去计算分类损失函数。
loss代码 box_loss_scale = 2 - y_true[l][...,2:3]*y_true[l][...,3:4] # raw_true_xy = [13x(x_true-1),13x(y_true-1)] (&lt; 0) # raw_pred[..., 0:2] = [pred_x,pred_y] # binary_crossentropy = [13x(x_true-1),13x(y_true-1)]xlog([pred_x,pred_y])+(1-[13x(x_true-1),13x(y_true-1)])xlog(1-[pred_x,pred_y]) xy_loss = object_mask * box_loss_scale * K.binary_crossentropy(raw_true_xy, raw_pred[...,0:2], from_logits=True) wh_loss = object_mask * box_loss_scale * 0.5 * K.square(raw_true_wh-raw_pred[...,2:4]) confidence_loss = object_mask * K.binary_crossentropy(object_mask, raw_pred[...,4:5], from_logits=True)+ (1-object_mask) * K.binary_crossentropy(object_mask, raw_pred[...,4:5], from_logits=True) * ignore_mask class_loss = object_mask * K.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5a43fd8a1c68e05b221e0eae4562520/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4846895fad785db8ca5bf8849b2b5559/" rel="bookmark">
			分治的典型应用：归并排序（C&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分治的基本概念 分治，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。
分治法，将问题分（divide）成一些小的问题也就是子问题然后递归求解，而治(conquer)则是将分所得到的各个解合并在一起，即分而治之。
归并排序 归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
举个实例，比如有一个待排序数组{6,3,4,2,7,8,1,9,5,10}，归并排序图解如下：
如图所示，归并排序是一个递归加分治的思想完成的，对于数组问题，总的来说就是把左子数组排好序再把右子数组排好序，最后对左右有序数组进行归并（即一起排序的过程）。
代码如下：
/* s:start m:middle e:end */ #include&lt;iostream&gt; using namespace std; int a[10] = {6,3,4,2,7,8,1,9,5,10}; int b[10]; void Merge(int a[],int s,int m,int e,int tmp[]) { //将数组 a 的局部 a[s,m]和 a[m+1,e]合并到 tmp,并保证 tmp有序，然后再拷贝回 a[s,m] int pb=0; int p1=s,p2=m+1; while(p1 &lt;= m &amp;&amp; p2 &lt;= e) { if(a[p1] &lt;= a[p2])//如果是if(a[p1] &lt; a[p2])那么归并排序就不稳定了 tmp[pb++]=a[p1++]; else tmp[pb++]=a[p2++]; } while(p1 &lt;= m) { tmp[pb++]=a[p1++]; } while(p2 &lt;= e) { tmp[pb++]=a[p2++]; } for(int i=0; i&lt;e-s+1; ++i) a[s+i]=tmp[i]; } void MergeSort(int a[],int s,int e,int tmp[]) { //通过二分(折半)划分子序列并且通过递归不断的去划分 if(s&lt;e)//当子序列中只有一个元素时结束递归 { int m=s+(e-s)/2; MergeSort(a,s,m,tmp);//左子序列 MergeSort(a,m+1,e,tmp);//右子序列 Merge(a,s,m,e,tmp);//左右子序列合并并保证有序 } } int main() { int size=sizeof(a)/sizeof(int); MergeSort(a,0,size-1,b); for(int i=0; i&lt;size; i++) cout &lt;&lt; a[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4846895fad785db8ca5bf8849b2b5559/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112aeea411b3b9746bb11566f61e067d/" rel="bookmark">
			LeetCode刷题实战2：用链表模拟加法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法的重要性，我就不多说了吧，想去大厂，就必须要经过基础知识和业务逻辑面试+算法面试。所以，为了提高大家的算法能力，这个公众号后续每天带大家做一道算法题，题目就从LeetCode上面选 ！
废话不多说，让我们一起来看看题目吧，今天要讲的是一道经典的算法题，虽然不难，但是很有意思，我们一起来看下题目：
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
https://leetcode.com/problems/two-sum/
翻译
给定两个非空的链表，代表两个非负整数。这两个整数都是倒叙存储，要求返回一个链表，表示这两个整数的和。
样例
Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/112aeea411b3b9746bb11566f61e067d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/417/">«</a>
	<span class="pagination__item pagination__item--current">418/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/419/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>