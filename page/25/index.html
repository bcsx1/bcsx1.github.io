<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d541cbc62e807fddf9b005d3ed26599/" rel="bookmark">
			Easy Excel 学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习官方地址：Easy Excel官方
maven依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; 做个标记，后续加测试类
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f70baef92fc3d056a2f316cdc823830/" rel="bookmark">
			【C&#43;&#43;】继承和运算符重载练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运算符重载 #include &lt;iostream&gt; using namespace std; #include &lt;string&gt; class Money { public: Money(int y = 0, int j = 0, int f = 0); Money operator+(Money &amp;); void Display(string); private: int yuan, jiao, fen; void Optimize(); }; void Money::Optimize() { if (fen &gt;= 10) { jiao++; fen -= 10; } if (jiao &gt;= 10) { yuan++; jiao -= 10; } } Money::Money(int y, int j, int f) { yuan = y; jiao = j; fen = f; Optimize(); } Money Money::operator+(Money &amp;c2) { return Money(yuan + c2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f70baef92fc3d056a2f316cdc823830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4e18d9ffc71a5ea10b7163e95dcac2/" rel="bookmark">
			Linux服务器一个端口对应两个进程号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景说明 由于项目部署需要，自己将一个使用fasterAPI开发的接口服务程序部署在了Ubuntu系统服务器上，并使用nohup命令将该服务在后台挂起，从而显示运行的进程号。等待第二天需要优化代码重启服务的时候发现，根据自己的服务端口号去查询进程的时候发现居然有两个进程号，不知道是什么原因。
分析 在 Linux 系统中，一个端口对应两个进程号的情况可能是因为网络地址转换（NAT）或负载均衡器的使用。
1.NAT：在一些网络环境中，多个主机共享同一个公共 IP 地址。当请求到达公共 IP 地址上的某个端口时，NAT 设备会将请求转发给内部网络的不同主机。因此，一个端口可能会对应多个进程号，每个进程号对应一个内部主机。
2.负载均衡器：负载均衡器是一种用于分发网络请求的设备，它将请求分发给多个服务器，以实现负载均衡和高可用性。当负载均衡器接收到请求时，它会将请求转发给后端服务器集群中的某个服务器。因此，一个端口可能会对应多个进程号，每个进程号对应一个后端服务器。
在这两种情况下，由于请求被转发到多个不同的主机或服务器上，因此会出现一个端口对应多个进程号的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b9ae87f6a1ba7f3a53e10c42a3dabd/" rel="bookmark">
			小白--将笔记本上的代码或者项目上传到github上去教程（使用git命令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、操作教程二、常见问题1. 问题12. 问题23. 问题34. 问题45. 问题5 三、注意1. git命令行界面中的粘贴和复制快捷键2. git config文件查看、增加和删除2. 在git bash上安装 Git LFS3. 使用Git LFS上传大文件4. Git安装教程5. Git LFS安装教程6. Git LFS上传大文件步骤教程7. 使用Github的PC客户端上传项目 一、操作教程 https://blog.csdn.net/Elon15/article/details/125705706?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170340591716800215092652%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170340591716800215092652&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-1-125705706-null-null.142v96pc_search_result_base1&amp;utm_term=%E5%B0%86%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0github%E4%B8%8A%E7%9A%84%E6%95%99%E7%A8%8B&amp;spm=1018.2226.3001.4187
二、常见问题 1. 问题1 问题：
解决方案：
https://blog.csdn.net/weixin_65793170/article/details/129088831?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Author%20identity%20unknown%20%20***%20P&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-0-129088831.nonecase&amp;spm=1018.2226.3001.4187
2. 问题2 问题：
解决方案（1）：
https://blog.csdn.net/m0_63230155/article/details/132070860?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170341895516800186516853%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=170341895516800186516853&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-1-132070860-null-null.142v96pc_search_result_base1&amp;utm_term=fatal%3A%20unable%20to%20access%20https%3A%2F%2Fgithub.com%2FSmile-QT%2FFIHN.git%2F%3A%20Failure%20when%20receiving%20data%20from%20the%20peer&amp;spm=1018.2226.3001.4187
解决方案（2）：
关闭科学上网工具
3. 问题3 问题：
解决方案：
4. 问题4 问题：
$ git push -u origin master
fatal: unable to access ‘https://github.com/Smile-QT/FIHN.git/’: Failed to connect to github.com port 443 after 21529 ms: Couldn’t connect to server
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22b9ae87f6a1ba7f3a53e10c42a3dabd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbdfea22c33628d4f6f737dafba6b01/" rel="bookmark">
			谷歌 SGE 和生成式 AI 在搜索中：2024 年会发生什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024 年，Google 的搜索生成体验将如何影响营销？探索 AI 驱动的搜索趋势、SERP 中的 SGE、自然流量影响等。
最初，Labs 中的 Google 搜索生成体验 （SGE） 实验预计将于 2023 年 12 月“结束”。但随着谷歌实验室网站的最新重新设计，许多人注意到SGE的结束日期已经消失了。
这对 Google SGE 和搜索中生成式 AI 的未来意味着什么？以下是我们对 Google SGE 的了解，以及我们在 2024 年搜索中对生成式 AI 的期望。
消费者需要人工智能驱动的搜索 根据一项针对美国 2,205 名成年人的调查，人们最感兴趣的人工智能产品是搜索。
人工智能产品列表中还包括人工智能驱动的智能助手、购物推荐和广告。（2023年2月）
超过 25% 的用户信任 AI 驱动的搜索结果、品牌推荐和广告 同一项调查揭示了美国成年人对人工智能搜索的信任程度，包括公正的搜索结果、推荐的品牌和广告相关性。
同样值得注意的是，近三分之一的人工智能搜索用户认为结果是事实。
29% 的成年人会转向 AI 驱动的搜索 关于采用人工智能驱动的搜索，40%的千禧一代愿意转向像Google SGE这样的体验。
谷歌的首要任务：人工智能搜索的演变 在 7 月份的第二季度财报电话会议上，谷歌首席执行官桑达尔·皮查伊 （Sundar Pichai） 将生成式 AI 搜索的发展描述为谷歌的首要任务之一。
本季度，随着搜索生成体验（SGE）的推出，我们迎来了下一个重大发展，它利用生成式AI的强大功能使搜索更加自然和直观。到目前为止，用户反馈非常积极。
SGE 回答问题并为搜索用户提供新的路径。
它可以更好地回答人们今天向我们提出的问题，同时还可以解锁搜索可以回答的全新类型的问题。
例如，我们发现生成式人工智能可以在人们探索主题或项目时将这些点连接起来，帮助他们在购买或预订旅行之前权衡多种因素和个人偏好。
我们将这种新体验视为探索网络的另一个起点，使用户能够更深入地了解某个主题。我为我们进步背后的卓越工程感到自豪。
谷歌的目标是继续提高搜索中人工智能响应的速度。
自 5 月发布以来，我们提高了服务效率，将生成 AI 快照所需的时间缩短了一半。随着时间的推移，我们将提供更快的响应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cbdfea22c33628d4f6f737dafba6b01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32fa9da91acdbed35a78ffa4b5aa108/" rel="bookmark">
			Java框架基础--maven，http，postman
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven Maven 提供了一个标准的构建生命周期和一组约定的目录结构，以简化和规范项目的构建过程。它主要用于 Java 项目，但也可以用于其他类型的项目。提高了项目的可维护性、可重复性和一致性，简化了构建和依赖管理的复杂性，使得开发者能够更专注于项目的业务逻辑。
项目管理： Maven 管理项目的构建、报告和文档等方面。通过 Maven，可以轻松地创建、构建和维护项目。
依赖管理： Maven 能够管理项目的依赖关系，通过配置文件（通常是 pom.xml）中的依赖信息，自动下载并集成所需的库和框架。
构建工具： Maven 提供了一个强大的构建工具，支持常见的构建任务，如编译、测试、打包、发布等。通过定义插件和目标，可以定制构建过程。
标准化： Maven 强调约定大于配置的原则，推崇一致的项目结构和构建方式，使得不同项目之间更容易共享和理解。
生命周期管理： Maven 定义了一组标准的构建生命周期，包括清理、编译、测试、打包、部署等阶段，简化了构建过程的管理。
插件体系： Maven 的插件机制使得开发者可以扩展构建过程，引入各种功能，满足特定项目的需求。
简化项目配置： Maven 使用 XML 格式的配置文件（pom.xml）来描述项目信息、依赖和构建配置。这种声明式的配置方式相对简洁，降低了配置的复杂度。
HTTP协议 HTTP（Hypertext Transfer Protocol）是一种用于传输超文本的应用层协议。它是一种无状态协议，意味着每个请求都是独立的，服务器不会存储关于之前请求的任何信息。HTTP是构建在TCP/IP协议之上的，用于在客户端和服务器之间传输数据。
以下是HTTP协议的一些关键特点和基本概念：
请求和响应： HTTP协议定义了客户端和服务器之间的通信方式。客户端发送HTTP请求，服务器接收并处理请求，然后发送HTTP响应作为回应。
无状态性： HTTP是一种无状态协议，每个请求都是独立的，服务器不会保留有关之前请求的信息。这意味着服务器无法知道当前请求是与之前的请求有关的。
URI（Uniform Resource Identifier）： 客户端通过使用URI来标识请求的资源。URI包括URL（Uniform Resource Locator）和URN（Uniform Resource Name）两种形式，其中URL是URI的一种常见形式，用于定位资源的具体位置。
方法（Methods）： HTTP定义了一些请求方法，包括常见的GET、POST、PUT、DELETE等。每个方法表示对资源的不同操作。
状态码： 服务器在响应中返回一个状态码，用于指示请求的结果，例如200表示成功，404表示未找到资源，500表示服务器内部错误等。
头部（Headers）： 请求和响应中可以包含头部信息，用于传递关于请求或响应的元数据。例如，Content-Type头部指定了请求或响应中的主体数据类型。
主体（Body）： 请求和响应中可能包含主体，用于传递实际的数据。例如，在POST请求中，表单数据通常包含在请求主体中。
Cookie： HTTP支持使用Cookie来在客户端和服务器之间保持状态信息。服务器可以通过Set-Cookie头部将Cookie信息发送给客户端，客户端在后续请求中通过Cookie头部将这些信息发送回服务器。
安全性： HTTP本身是不安全的，因为它在传输过程中不加密数据。为了增加安全性，可以在HTTP上叠加安全层，形成HTTPS（HTTP Secure）。
优点：速度快。
缺点：多次请求间不能共享数据。
HTTP协议是Web上数据通信的基础，它使得不同计算机之间能够通过互联网进行通信，并支持现代Web应用程序的开发和交互。
HTTP-请求协议 HTTP-响应协议 TCP协议 TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输层协议，用于在网络上可靠地传输数据。TCP是互联网协议套件中的一个重要组成部分，它负责确保数据在网络中的可靠传输，同时提供流控制和拥塞控制机制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f32fa9da91acdbed35a78ffa4b5aa108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074635f5b9759ffe6e378be7db3eff0f/" rel="bookmark">
			sqlilabs第三十四三十五关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Less-34（POST - Bypass AddSlashes()) 手工注入 和sqlilabs第三十二三十三关-CSDN博客一样只是变成post
但是注意一下get方式是会经过url编码的，但是post是不会编码的，我们可以使用utf-8转换成utf-16或者utf-32(利用%bb)
（写掉了单引号后面发现了）
接下来就是和之前一样了（注意1=1也可以成功）
注意查字段的时候需要使用盲注
自动注入 和之前一样的只是变成了post
sqlmap -u http://192.168.21.149/Less-34/ -data 'uname=1&amp;passwd=1&amp;submit=Submit' --tamper /usr/share/sqlmap/tamper/unmagicquotes.py --batch Less-35（GET - Bypass Add Slashes (we dont need them)Integer based) 手工注入 数字注入那就简单
和之前一样了sqli-labs第一二关-CSDN博客和sqlilabs第三十二三十三关-CSDN博客的组合
自动注入 一样的没什么好说
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2204e42be744ea2f11b1583789ebe46/" rel="bookmark">
			OAuth2授权码模式---详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OAuth2简介 是一个业界标准的授权协议（authorization protocol），这里的授权是以委派代理（delegation）的方式。可以这样理解，OAuth 2.0提供一种协议交互框架，让某个应用能够以安全地方式获取到用户的委派书，这个委派书在OAuth 2.0中就是访问令牌（access token），随后应用便可以使用该委派书，代表用户来访问用户的相关资源。
在OAuth 2.0的协议交互中，有四个角色的定义，
资源所有者（Resource Owner）：顾名思义，资源的所有者，很多时候其就是我们普通的自然人（但不限于自然人，如某些应用程序也会创建资源），拥有资源的所有权。资源服务器（Resource Server）：保存着受保护的用户资源。应用程序（Client）：准备访问用户资源的应用程序，其可能是一个web应用，或是一个后端web服务应用，或是一个移动端应用，也或是一个桌面可执行程序。授权服务器（Authorization Server）：授权服务器，在获取用户的同意授权后，颁发访问令牌给应用程序，以便其获取用户资源。 从一个简单的应用场景谈起 为了方便讨论，我们假设有一个用户Michael，他在一个资源服务器上保存着他自己的账号信息，例如微信账号的姓名、头像等。某个应用程序在用户登录时，需要获取Michael的这些账号信息。
Michael在资源服务器上保存的账号信息是受保护的，为了让应用程序能够获取Michael的账号信息，需要提供用户的访问密码。有一个简单的方法是，在应用服务器和资源服务器之间共享同一访问密码，当Michael登录输入密码后，应用程序复制Michael的登录密码并向资源服务器请求访问，获取Michael的账号信息。这是早些时候比较常见的跨应用授权访问方法。
这样子做有很大的安全隐患，主要有如下三个方面的问题，
用户在应用程序和资源服务器需要保持一致的密码无法控制应用程序的权限，应用程序需要的是读权限，但是拿到用户密码后，获取到的却是用户的所有访问权限用户的密码会被应用程序获取到，有用户密码泄露的风险，一旦应用程序多了，安全风险不可控 在简单的应用场景里，在应用程序和资源服务器之间保持一致的密码是可行的，这也确实能够带来一定的便利，至少用户不用记多套用户名和密码，但账号和密码的独立性无法得到保证，应用程序可以直接接触到用户密码等敏感信息，账号的安全性也无法控制。
为了解决第1个问题，用户Michael在应用程序和资源服务器可以使用不同的密码登录，有一个可行的方法是，让用户输入两次密码，第一次输入密码为了登录应用程序，第二次让Michael输入其在资源服务器的登录密码，以便应用程序获取资源服务器的账号信息。
这样就需要用户输入两次密码，给用户的使用带来很大的不便，而且这个方案依然存在第2和第3的问题。
为了解决第2个问题，限制应用程序访问资源服务器的权限，我们可以让用户在资源服务器申请一个只读的受限密码，该受限密码只用来读取用户信息，无法用来进行编辑和删除操作，用户输入这个只读密码给应用程序，让应用程序读取用户在资源服务器上的信息。
这个方法解决了上述提到的第3个问题，但是这个key是一个通用的读权限，权限范围很大，其和用户没有任何关联。在很多时候，我们还是需要用户级别上的受限权限控制。
能否有一个方案，在不影响用户的使用便利性，并且颁发一个在用户级别上的可控权限key？可以考虑的是，用户动态按需地向资源服务器申请读权限key，然后颁发给应用程序，用于应用程序去申请访问用户的信息，该受限密码在颁发后有一定的时效性，甚至可以指定其只能被使用一次。这样子的话，解决问题1、2和3的条件都得到满足。
这个方案已经很接近于OAuth 2.0在设计之初所提供的授权方案，不一样之处的是，受限密码的颁发交给了独立的安全组件：授权服务器。
这里马上就要介绍OAuth 2.0的基本授权方式：授权码模式。
OAuth 2.0基本授权流程：授权码模式 让我们看看在增加授权服务器之后，OAuth 2.0的一个基本授权流程，
如图所示，授权流程场景可以描述为如下几个步骤，
用户在应用程序中，应用程序尝试获取用户保存在资源服务器上的信息，比如用户的身份信息和头像，应用程序首先让重定向用户到授权服务器，告知申请资源的读权限，并提供自己的client id。到授权服务器，用户输入用户名和密码，服务器对其认证成功后，提示用户即将要颁发一个读权限给应用程序，在用户确认后，授权服务器颁发一个授权码（authorization code）并重定向用户回到应用程序。应用程序获取到授权码之后，使用这个授权码和自己的client id/secret向认证服务器申请访问令牌/刷新令牌（access token/refresh token）。授权服务器对这些信息进行校验，如果一切OK，则颁发给应用程序访问令牌/刷新令牌。应用程序在拿到访问令牌之后，向资源服务器申请用户的资源信息资源服务器在获取到访问令牌后，对令牌进行解析（如果令牌已加密，则需要进行使用相应算法进行解密）并校验，并向授权服务器校验其合法性，如果一起OK，则返回应用程序所需要的资源信息。 这个授权流程在OAuth 2中被称为授权码模式（authorization code grant），其命名的原因是，应用程序使用授权码来向授权服务器申请访问令牌/刷新令牌。
可以看到，在整个过程中应用程序没有接触到用户的密码。
授权码和令牌都是一个唯一标识的值，其各个意义为，
授权码：即用户的委派书，代表着用户的受限权限，有时效性访问令牌：用于应用程序每次向资源服务器访问时提供，有时效性，如果安全性比较高的话，则每个访问令牌可以被设置为只用一次，或者对令牌设置一个有效期，在有效期可以反复使用。刷新令牌：用于应用程序向授权服务器申请新的访问令牌，在访问令牌失效或过期的时候，重新获取新的访问令牌。 注意的是，访问令牌对于应用程序来说是透明的，应用程序无需关注访问令牌所带的任何信息，只需在访问资源服务器时带上它。但是资源服务器需要知道访问令牌的组成和加密方式，资源服务器需要解析或解密这个访问令牌，查看并校验里面的信息。
授权服务器和访问令牌，前者为授权的颁发，后者为授权的载体，两者实现了动态按需地代理权限分发，这也是OAuth 2.0解决方案在授权上所带来的创新变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf73f1e603e937880bc76f0d0244f13a/" rel="bookmark">
			【unity学习笔记】2.脚本组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脚本组件 一、添加组件
相同的功能写成一个组件（外形可通过点击cube修改）
1.添加组件
（1）系统提供的组件
检查器→添加组件→输入rigidbody（刚体）→选择
（2）系统没提供组件
创建c#脚本：在assets中点击右键→创建→c#脚本→将其拖动到对象的检查器中。
二、操作组件
1.重置组件
2.复制粘贴组件
1.复制新组件：复制组建后，随便找一个组件菜单，点击三个点→选择粘贴为新组件。
2.复制组件值：修改组件数值→复制组件→选择另一个对象的相同组件→粘贴组件值。
三、编写（系统未自带）组件功能
1.右键创建c#，双击进入编写。
2.注意visualstudio进行编写。注意：类名应和组件名一致，否则重命名。
四、脚本的生命周期
start方法
在update之前调用一次，在onenable之后调用，可以在此设置一些初始值。update方法
每帧调用一次。其他方法
|awake|最早调用|
|onenable |组件激活后调用 |
|fixedupdate |固定频率调用 |
|lateupdate |update调用完一次后紧跟着调用一次 |
|ondisable |与onenable相反，组件未激活时调用 |
|ondestroy |被销毁后调用一次 | 执行大致先后顺序：awake&gt;onenable&gt;start&gt;update
五、当有多个脚本如何按顺序执行
编辑→项目设计→脚本执行顺序→点“+”选择脚本：数值越小越靠上
六、标记对象
1.标签：可以重复（玩家、敌人）
2.图层：（区分地面层、玩家敌人层）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2226ac80ea8a311e88e2df667568a1a/" rel="bookmark">
			CentOS安装MongoDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS安装MongoDB 文章目录 CentOS安装MongoDB1. 安装并运行2. 创建用户/密码3. 测试语句4. 允许外网访问 1. 安装并运行 在 CentOS 上安装 MongoDB，你可以按照以下步骤进行：
导入 MongoDB 的 GPG 密钥：
sudo rpm --import https://www.mongodb.org/static/pgp/server-5.0.asc 创建 MongoDB 的 YUM 存储库文件 /etc/yum.repos.d/mongodb-org-5.0.repo，并使用文本编辑器打开它：
sudo vi /etc/yum.repos.d/mongodb-org-5.0.repo 在文件中添加以下内容：
[mongodb-org-5.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/5.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-5.0.asc 保存并关闭文件。
安装 MongoDB：
sudo yum install -y mongodb-org 启动 MongoDB 服务：
sudo systemctl start mongod 设置 MongoDB 开机自启动：
sudo systemctl enable mongod 检查 MongoDB 服务状态：
sudo systemctl status mongod 如果一切正常，你应该会看到 MongoDB 服务已经运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2226ac80ea8a311e88e2df667568a1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316238d52ccd3b80be86d0cb7f97bc13/" rel="bookmark">
			骑砍战团MOD开发(14)-module.ini配置项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #大地图边界 map_max_y map_max_x map_min_y map_min_x map_max_distance #大地图地貌(沙漠/树林/河流) map_desert_tree_types map_steppe_tree_types map_snow_tree_types map_tree_types map_min_elevation map_max_elevation map_river_speed_y map_river_speed_x map_river_direction map_sea_speed_y map_sea_speed_x map_sea_wave_rotation map_sea_direction #mod资源加载 load_module_resource load_mod_resource load_resource_nofast load_resource scan_module_sounds scan_module_textures #战场提示 maximum_number_of_notification_messages #战场规模 battle_size_max battle_size_min #存档名称 module_name(C:\Users\Administrator\Documents\Mount&amp;Blade Warband Savegames) #大地图可视范围 seeing_range #角色详情页展示武器熟练度选项 display_wp_firearms display_wp_throwing display_wp_crossbows display_wp_archery display_wp_polearms display_wp_two_handed display_wp_one_handed #全伤 no_friendly_fire_for_bots #属性/技能/武器熟练度加点 attribute_required_per_skill_level weapon_points_per_level attribute_points_per_level skill_points_per_level #shift键控制摄像机aperture光圈大小,视野范围 normal = 75 shift = 37 disable_zoom #是否允许下蹲动作 can_crouch apply_all_ammo_damage_modifiers shorter_pistol_aiming use_scene_unloading use_texture_degration_cache use_case_insensitive_mesh_searches fix_gamma_on_dx7_operation_colors reduce_texture_loader_memory_usage timid_modifier_speed_bonus meek_modifier_speed_bonus ai_decide_direction_according_to_damage disable_force_leaving_conversations consider_weapon_length_for_weapon_quality use_strict_pathfinding_for_ships disable_disband_on_terrain_type far_plane_distance add_set_neighbors_to_tangent_flag_to_shader disable_moveable_flag_optimization dont_supress_initial_warnings give_performance_warnings screenshot_format crush_through_treshold extra_penetration_factor_reduction extra_penetration_factor_soak auto_compute_party_radius level_boundary_multiplier show_troop_upgrades_button air_friction_bullet air_friction_arrow works_with_version_max works_with_version_min dont_load_regular_troop_inventories auto_create_note_indices show_party_ids_instead_of_names has_accessories_for_female disable_high_hdr disable_attack_while_jumping can_use_scene_props_in_single_player has_multiplayer has_single_player has_tutorial lance_pike_effect_speed has_forced_particles restrict_attacks_more_in_multiplayer can_adjust_camera_distance sync_ragdoll_effects horses_rear_with_attack horses_try_running_away use_phased_reload can_run_faster_with_skills can_reload_while_moving use_crossbow_as_firearm can_objects_make_sound use_advanced_formation show_multiplayer_gold show_quest_notes show_faction_color limit_hair_colors disable_food_slot starting_day starting_month starting_year num_hints compatible_savegame_module_version compatible_module_version module_version player_wounded_treshold hero_wounded_treshold regulars_xp_multiplier hero_xp_multiplier player_xp_multiplier base_companion_limit skill_prisoner_management_bonus skill_leadership_bonus blood_multiplier track_spotting_multiplier shield_penetration_factor shield_penetration_offset fall_damage_multiplier couched_lance_damage_multiplier horse_charge_damage_multiplier damage_interrupt_attack_threshold_mp damage_interrupt_attack_threshold damage_interrupt_attack_treshold mission_object_prune_time multiplayer_walk_enabled melee_damage_speed_power missile_damage_speed_power armor_reduction_factor_against_blunt armor_reduction_factor_against_pierce armor_reduction_factor_against_cut armor_soak_factor_against_blunt armor_soak_factor_against_pierce armor_soak_factor_against_cut time_multiplier compatible_with_warband 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c086c3745cc591cb2f3b85a49c039e5b/" rel="bookmark">
			全网最详细最基础的网络安全入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写这篇文章的初衷是很多朋友都想了解如何入门/转行网络安全，实现自己的“黑客梦”。文章的宗旨是：
1.指出一些自学的误区
2.提供客观可行的学习表
3.推荐我认为适合小白学习的资源.大佬绕道哈！
第一阶段：基础操作入门
入门的第一步是学习一些当下主流的安全工具课程并配套基础原理的书籍，一般来说这个过程在1个月左右比较合适。
第二阶段：学习基础知识
在这个阶段，你已经对网络安全有了基本的了解。如果你学完了第一步，相信你已经在理论上明白了上面是sql注入，什么是xss攻击，对burp、msf、cs等安全工具也掌握了基础操作。这个时候最重要的就是开始打地基！
所谓的“打地基”其实就是系统化的学习计算机基础知识。而想要学习好网络安全，首先要具备5个基础知识模块：
1.操作系统
2.协议/网络
3.数据库
4.开发语言
5.常见漏洞原理
学习这些基础知识有什么用呢？
计算机各领域的知识水平决定你渗透水平的上限。
【1】比如：你编程水平高，那你在代码审计的时候就会比别人强，写出的漏洞利用工具就会比别人的好用；
【2】比如：你数据库知识水平高，那你在进行SQL注入攻击
的时候，你就可以写出更多更好的SQL注入语句，能绕过别人绕不过的WAF；
【3】比如：你网络水平高，那你在内网渗透的时候就可以比别人更容易了解目标的网络架构，拿到一张网络拓扑就能自己在哪个部位，拿到以一个路由器的配置文件，就知道人家做了哪些路由；
【4】再比如你操作系统玩的好，你提权就更加强，你的信息收集效率就会更加高，你就可以高效筛选出想要得到的信息
【——全网最全的网络安全学习资料包分享给爱学习的你——】
1.网络安全多个方向学习路线
2.全网最全的CTF入门学习资料
3.一线大佬实战经验分享笔记
4.网安大厂面试题合集
5.红蓝对抗实战技术秘籍
6.网络安全基础入门、Linux、web安全、渗透测试方面视频
👉[[[CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源》免费分享]]]（安全链接，放心点击）
第三阶段：实战操作
1.挖SRC
挖SRC的目的主要是讲技能落在实处，学习网络安全最大的幻觉就是觉得自己什么都懂了，但是到了真的挖漏洞的时候却一筹莫展，而SRC是一个非常好的技能应用机会。
2.从技术分享帖（漏洞挖掘类型）学习
观看学习近十年所有0day挖掘的帖，然后搭建环境，去复现漏洞，去思考学习笔者的挖洞思维，培养自己的渗透思维
3.从b站观看一些有用的视频
b站还是有些视频对你的实战和提升技术有帮助的，也可以去b站是私聊up领取实战课件
4.靶场练习
自己搭建靶场或者去免费的靶场网站练习，有条件的话可以去购买或者报靠谱的培训机构，一般就有配套的靶场练习
第四阶段：参加CTF比赛或者HVV行动
推荐：CTF
CTF有两点：
【1】接近实战的机会。现在网络安全法很严格，不像之前大家能瞎搞
【2】题目紧跟技术前沿，而书籍很多落后了
【3】如果是大学生的话，以后对找工作也很有帮助
如果你想打CTF比赛，直接去看赛题，赛题看不懂，根据不懂的地方接着去看资料
推荐：HVV（护网）
HVV有三点：
【1】也能极大的锻炼你，提高自身的技术，最好是参加每年举行的HVV行动
【2】能认识许多圈内的大佬，扩大你的人脉
【3】HVV的工资也很高，所以参加的话也能让你赚到不少钱
【4】和CTF比赛一样如果是大学生的话，以后对找工作也很有帮助
相关网站推荐
1、FreeBuf
国内关注度最高的全球互联网安全媒体平台，爱好者们交流与分享安全技术的社区，网络安全行业门户。
2、看雪
看雪论坛是个软件安全技术交流场所，为安全技术爱好者提供一个技术交流平台和资源。
3、吾爱破解
吾爱破解论坛是致力于软件安全与病毒分析的非营利性技术论坛。
4、阿里云先知社区
一个开放型技术平台。
5、腾讯玄武安全实验室
各种CVE漏洞。
推荐书籍入门
《白帽子讲Web安全》 2012
《Web安全深度剖析》2015
《Web安全攻防 渗透测试实战指南》2018进阶
《WEB之困-现代WEB应用安全指南》 2013
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c086c3745cc591cb2f3b85a49c039e5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1c883f3f6f91b28a20c4cfd365663b/" rel="bookmark">
			电脑提示vcruntime140.dll找不到怎么办，解决vcruntime140.dll丢失的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在使用Windows系统运行特定程序或软件的时候，有时会遇到"vcruntime140.dll丢失"的问题。这个动态链接库（DLL）文件在程序的正常运行中起着关键的作用，因此出现该错误往往会导致程序无法启动或运行异常。在本文中，我们将探讨关于vcruntime140.dll丢失的问题，并为大家提供解决这一问题的有效方法，帮助大家轻松应对vcruntime140.dll丢失的困扰。
一.具体与vcruntime140.dll错误消息相关的问题 在启动程序或运行特定软件时，可能会遇到以下与vcruntime140.dll相关的错误消息之一：
"vcruntime140.dll无法继续执行代码"错误。
这个错误消息意味着系统无法找到或加载vcruntime140.dll文件，导致程序无法正常运行。
二.如何手动解决 "vcruntime140.dll无法继续执行代码" 错误 以下是手动解决错误消息中提到的 "vcruntime140.dll无法继续执行代码" 错误的步骤：
检查操作系统架构，确定使用的是32位还是64位操作系统。
确认vcruntime140.dll文件是否存在于系统目录中（通常位于C:\Windows\System32）。
使用系统文件检查工具（SFC）执行修复： 打开命令提示符（以管理员身份运行）。
输入命令 "sfc /scannow" 并按下回车键。等待扫描和修复过程完成。
注册DLL文件：
打开命令提示符（以管理员身份运行）。
输入命令 "regsvr32 vcruntime140.dll" 并按下回车键。等待注册过程完成。
使用dll修复工具的详细解决步骤： 在浏览器顶部输入：dll修复.site， 点击进入后将工具进行启动。
DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
启动完成后将工具进行使用，使用完成后点击页面中的一键修复，一键修复和手动修复都可以将丢失的vcruntime140.dll文件进行修复。
修复的方式比较简单，但是不同的是一键修复是修复vcruntime140.dll文件同时也将电脑中的其他的dll文件一起修复。而手动修复只能在页面中搜索vcruntime140.dll，只能修复你所搜索的vcruntime140.dll文件进行修复。
验证程序完整性的详细解决步骤： 验证程序完整性可以帮助修复和还原系统文件，以下是详细的步骤：
打开命令提示符（以管理员身份运行）。
输入命令 "sfc /verifynow" 并按下回车键。等待验证过程完成。
如果有任何被破坏的文件，系统会自动修复。
重新安装或修复Visual C++ Redistributable的详细解决步骤： 重新安装或修复Visual C++ Redistributable可以解决与vcruntime140.dll相关的错误。以下是详细的解决步骤：
在控制面板中打开 "程序和功能"。
找到并选择已安装的Visual C++ Redistributable程序。
选择 "修复" 或 "卸载" 选项，根据需要进行操作。
按照提示完成修复或重新安装过程。
手动下载并替换vcruntime140.dll文件的详细解决步骤： 注意：为了安全起见，请确保从官方或可靠的来源下载vcruntime140.dll文件，并且文件的版本与系统匹配。以下是手动下载并替换vcruntime140.dll文件的步骤：
在官方或可靠的来源下载正确版本的vcruntime140.dll文件。
确定操作系统架构（32位或64位）。
将下载的vcruntime140.dll文件放置在正确的系统目录中（通常是C:\Windows\System32）。
确保备份原始的vcruntime140.dll文件，以防发生任何问题。
重新启动电脑以使更改生效。
三.知识准备和预防vcruntime140.dll丢失措施的重要性 在解决和避免vcruntime140.dll错误方面，准备良好的知识和采取预防措施至关重要。以下是一些重要的准备和预防措施：
了解操作系统的架构和基础知识。
注意及时更新操作系统和软件，以确保系统和依赖的组件是最新的。
定期备份系统文件，以便在出现问题时能快速恢复。
只从官方或可靠的来源下载DLL文件，避免下载不受信任的文件或软件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1c883f3f6f91b28a20c4cfd365663b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0049b9e814b2c5ea87c3142e7ab78b9/" rel="bookmark">
			vue2 封装年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父页面
&lt;template&gt; &lt;div&gt; &lt;div class="heard-style"&gt; &lt;div class="year-style"&gt; &lt;date :date="date" @dateT="beginFunctionFn" @beginD="kickFunctionFn" @endDate="finishFunctionFn" :yearS="yearS" :yearE="yearE" &gt;&lt;/date&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import date from './components/index' //日期 var yearlistAPI = [ 2024, 2023, 2022, 2021, 2020, 2019, 2018, 2017, 2016, 2015, 2014, 2013, 2012, 2011, 2010, 2009, 2008, 2007, 2006, 2005, 2004, 2003, ] export default { data() { return { date: [], yearS: '', yearE: '', } }, components: { date, }, created() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0049b9e814b2c5ea87c3142e7ab78b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f54237ceea38ec29bfd263e5772ad74/" rel="bookmark">
			编写fastapi接口服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FastAPI是一个基于 Python 的后端框架，该框架鼓励使用 Pydantic 和 OpenAPI (以前称为 Swagger) 进行文档编制，使用 Docker 进行快速开发和部署以及基于 Starlette 框架进行的简单测试。
step1：安装必要库 pip install fastapi uvicorn step2：构建代码 创建main.py脚本文件，然后引入FastAPI模块，就可以构建接口了
from fastapi import FastAPI, Query app = FastAPI() @app.post("/路由") def hello(): return {"Hello": "World"} @app.post('/路由') async def function( try: * except: * return {'Hello': World} 这只是一个简单示例，也可以用get等替换post
step3：运行接口 和其他的模块不一样的是，FastAPI需要运行指定命令来运行api服务：
需要在当前目录下执行下面的命令，他会主动去找到main入口：
uvicorn main:app --reload step4：更多指南 欢迎参考官网：https://fastapi.tiangolo.com/
Other：自己写了个接口 是GitHub上一个开源的给图片添加盲水印的项目blind_watermark
from fastapi import FastAPI from fastapi.responses import FileResponse import subprocess from fastapi.middleware.cors import CORSMiddleware from fastapi import Form from blind_watermark.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f54237ceea38ec29bfd263e5772ad74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7eb93a6999baf7208f762daeda298074/" rel="bookmark">
			基于Scrapy的IP代理池搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
如何构建ip代理池
1. 确定代理IP源
2. 创建Scrapy项目
3. 定义代理IP爬虫
4. 编写网页解析逻辑
5. 检测代理IP的可用性
6. 存储可用的代理IP
7. 运行爬虫
总结
前言 在网络爬虫过程中，使用代理IP可以有效地解决IP被封禁的问题。为了更好地使用代理IP，我们可以搭建一个IP代理池，动态地维护可用的代理IP列表。本文将介绍如何使用Scrapy框架搭建一个简单的IP代理池。
Scrapy是一个功能强大的Python爬虫框架，它提供了灵活的方式来定义爬虫、提取数据并进行持久化操作。我们将使用Scrapy框架来实现一个简单的爬虫，从代理IP网站上获取免费的代理IP，并检测代理IP的可用性，最后将可用的代理IP存储到数据库中。
如何构建ip代理池 1. 确定代理IP源 为了获取可用的代理IP，我们需要找到一些代理IP源。这些源可以是免费的或者付费的，我们可以选择一些常见的代理IP源，比如站大爷代理ip、蝶鸟ip等。
2. 创建Scrapy项目 我们首先需要创建一个Scrapy项目。在终端中运行以下命令：
scrapy startproject proxy_pool 这将在当前目录下创建一个名为proxy_pool的Scrapy项目。
3. 定义代理IP爬虫 在项目中创建一个名为proxyspider的爬虫。在终端中运行以下命令：
cd proxy_pool scrapy genspider proxyspider example.com 这将在spiders目录下创建一个名为proxyspider的爬虫文件。
在proxyspider.py文件中添加以下代码：
import scrapy class ProxySpider(scrapy.Spider): name = 'proxyspider' start_urls = ['http://example.com'] def parse(self, response): # 网页解析逻辑 4. 编写网页解析逻辑 根据代理IP源的网页结构，编写解析网页的逻辑。以西刺代理为例，它的代理IP列表在一个table标签下的tr标签中。我们可以使用XPath表达式来提取IP和端口号。
在parse方法中添加以下代码：
def parse(self, response): proxies = response.xpath('//table[@id="ip_list"]/tr[position()&gt;1]') for proxy in proxies: ip = proxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7eb93a6999baf7208f762daeda298074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe98b033f1a85c925bcc6541701ba5f/" rel="bookmark">
			自定义删除无依赖文件的webpack插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件原理 通过自定义webpack插件，利用执行完成编译的封存阶段后，产生的产物module.fileDependencies，生成依赖的文件组。通过读文件的方式，将待扫描的文件组和有依赖关系的文件进行对比。最终暴露出项目中，不存在依赖关系的文件，并可配置将其全部删除。
代码实现 1、自定义webpack插件，配置options。遍历stats.compilation.fileDependencies，存储依赖文件。 const fs = require('fs'); const path = require('path'); class UnDependencClearPlugin { constructor(options = {}) { this.options = options; this.entry = options.entry || 'src'; // 入口 this.include = options.include || ''; // 包含哪些文件'.vue|.js' this.exclude = options.exclude || ''; // 排除哪些文件夹 ['src/assets', 'src/views'] this.isDelete = options.isDelete || false; // 是否主动删除文件 this.originFile = []; // node读取的源文件目录 处理过include及exclude 后的数据 最全的数据 this.dependenciesFile = []; // webpack依赖数据 处理过include及exclude 后的数据 依赖数据 this.noUseFile = []; // 可删除的数据 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe98b033f1a85c925bcc6541701ba5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c9d0fef9dc98838d3832742ca41ead/" rel="bookmark">
			骑砍战团MOD开发(13)-module_scripts常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.NPC在酒馆的出现
调用刷新脚本: (call_script, "script_update_companion_candidates_in_taverns"), 重写刷新脚本: #script_update_companion_candidates_in_taverns # INPUT: none # OUTPUT: none ("update_companion_candidates_in_taverns", [ (try_begin), (eq, "$cheat_mode", 1), (display_message, "str_shuffling_companion_locations"), (try_end), (try_for_range, ":troop_no", companions_begin, companions_end), (troop_set_slot, ":troop_no", slot_troop_cur_center, -1), (troop_slot_eq, ":troop_no", slot_troop_days_on_mission, 0), (troop_slot_eq, ":troop_no", slot_troop_occupation, slto_inactive), (neg|troop_slot_ge, ":troop_no", slot_troop_prisoner_of_party, 0), (store_random_in_range, ":town_no", towns_begin, towns_end), (try_begin), (neg|troop_slot_eq, ":troop_no", slot_troop_home, ":town_no"), (neg|troop_slot_eq, ":troop_no", slot_troop_first_encountered, ":town_no"), (troop_set_slot, ":troop_no", slot_troop_cur_center, ":town_no"), (try_begin), (eq, "$cheat_mode", 1), (str_store_troop_name, 4, ":troop_no"), (str_store_party_name, 5, ":town_no"), (display_message, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87c9d0fef9dc98838d3832742ca41ead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6760b7b5e0368aad17e331e8faf66a/" rel="bookmark">
			什么是实时操作系统（RTOS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实时操作系统（Real-time operating system, RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。
实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。
经常跟实时操作系统一起讲的，还有嵌入式操作系统这个概念，但实际上这是完全不同的两种东西，虽然大多数实时操作系统都是嵌入式操作系统，但嵌入式操作系统并不全都是实时的。
对于实时操作系统有一些常见的误区，比如：速度快，吞吐量大，代码精简，代码规模小等等。其实这些都不算是实时操作系统的特性，别的操作系统也可以做到。
只有“实时性”才是RTOS的最大特征，其它的都不算是。
维基百科上关于实时性的定义：
实时运算（Real-time computing）是计算机科学中对受到“实时约束”的计算机硬件和计算机软件系统的研究，实时约束像是从事件发生到系统回应之间的最长时间限制。实时程序必须保证在严格的时间限制内响应。 实时操作系统中都要包含一个实时任务调度器，这个任务调度器与其它操作系统的最大不同是强调：严格按照优先级来分配CPU时间，并且时间片轮转不是实时调度器的一个必选项。
提出实时操作系统的概念，可以至少解决两个问题：
早期的CPU任务切换的开销太大，实时调度器可以避免任务频繁切换导致CPU时间的浪费。在一些特殊的应用场景中，必须要保证重要的任务优先被执行。 在这样的背景下，实时操作系统就被设计出来了，典型的实时操作系统有VxWorks，RT-Thread，uCOS，QNX，WinCE等。
实时任务调度器是实时操作系统的一个必选项，但不代表只要设计出来一个实时调度器就足够了。事实上设计一个实时调度内核并不是一个多么复杂的任务，实时操作系统的特性是在整个操作系统的设计思路上都要时刻关注实时性。
这些设计思路包括：
1. 实时的消息、事件处理机制。
常规的操作系统中，消息队列都是按照FIFO（先进先出）的方式进行调度，如果有多个接受者，那么接受者也是按照FIFO的原则接受消息（数据），但实时操作系统会提供基于优先级的处理方式：两个任务优先级是分别是10和20，同时等待一个信号量，如果按照优先级方式处理，则优先级为10的任务会优先收到信号量。
2. 提供内核级的优先级翻转处理方式
实时操作系统调度器最经常遇到的问题就是优先级翻转，因此对于类似信号量一类的API，都能提供抑止优先级翻转的机制，防止操作系统死锁。
3. 减少粗粒度的锁和长期关中断的使用
这里的锁主要是指自旋锁(spinlock)一类会影响中断的锁，也包括任何关中断的操作。在Windows和Linux的驱动中，为了同步的需要，可能会长期关闭中断，这里的长期可能是毫秒到百微秒级。但实时操作系统通常不允许长期关中断。
对于非实时操作系统来说，如果收到一个外部中断，那么操作系统在处理中断的整个过程中可能会一直关中断。但实时操作系统的通常做法是把中断作为一个事件通告给另外一个任务，interrupt handler在处理完关键数据以后，立即打开中断，驱动的中断处理程序以一个高优先级任务的方式继续执行。
4. 系统级的服务也要保证实时性
对于一些系统级的服务，比如文件系统操作：
非实时系统会缓存用户请求，并不直接把数据写入设备，或者建立一系列的线程池，分发文件系统请求。但实时系统中允许高优先级的任务优先写入数据，在文件系统提供服务的整个过程中，高优先级的请求被优先处理，这种高优先级策略直到操作完成。 这种设计实际上会牺牲性能，但实时系统强调的是整个系统层面的实时性，而不是某一个点（比如内核）的实时性，所以系统服务也要实时。
由于应用场景的差异，会出现有些用户需要实时性的驱动，有些用户需要高性能的驱动，因此实时操作系统实际上要提供多种形式的配置以满足不同实时性需求的用户。
5. 避免提供实时性不确定的API
多数实时操作系统都不支持虚拟内存（page file/swap area），主要原因是缺页中断（page fault）会导致任务调度的不确定性增加。实时操作系统很多都支持分页，但很少会使用虚拟内存，因为一次缺页中断的开销十分巨大（通常都是毫秒级），波及的代码很多，导致用户程序执行的不确定性增加。
实时操作系统的确定性是一个很重要的指标，在某些极端场景下，甚至会禁用动态内存分配（malloc/free），来保证系统不受到动态的任务变化的干扰。
6. 提供针对实时系统调度的专用API
比如ARINC 653标准中就针对任务调度等作出了一系列的规定，同时定义了特定的API接口和API行为，这些API不同于POSIX API，如果实时系统要在航空设备上使用，就可能需要满足ARINC 653的规范。
7. 降低系统抖动
由于关中断等原因，通常情况下，操作系统的调度器不会太精确的产生周期性的调度，比如x86早期的默认60的时钟周期（clock rate），抖动范围可能在15-17ms之间。
但一个设计优秀的实时操作系统能把调度器的抖动降低到微秒甚至百纳秒一级，在像x86这种天生抖动就很大的架构上，降低系统抖动尤其重要。
8. 针对实时性设计的SMP和虚拟化技术
SMP（多核）场景的实时调度是很困难的，这里还涉及到任务核间迁移的开销。
针对SMP场景，多数实时操作系统的设计都不算十分优秀，但比起普通操作系统来说，其实时性已经好很多了。
同时实时操作系统的虚拟化能从hypervisor层面上提供虚拟机级别的实时调度，虚拟机上可以是另外一个实时系统，也可以是一个非实时系统。
从以上的特点上看，前面提到的常见的错误认识：速度快，吞吐量大，代码精简，代码规模小，都不是实时操作系统的特征：
非实时操作系统也可以很快，实时操作系统也可能很慢；
通常来说实时操作系统的吞吐量会大一些，但非实时系统也可以做到吞吐量更大；
实时操作系统一般都比非实时操作系统要小，但规模大的实时操作系统也是存在的；
而且由于可能需要针对不同用户提供不同等级的实时服务，实时操作系统可能并不是那么精简的……
由于设备性能的发展，原来很多实时性要求高的场景，已经切换到普通的操作系统了。
Linux在嵌入式设备上的推广，使用实时操作系统的很多设备已经改用Linux了，因为硬件性能的提升会让系统延迟降低到一个用户可以接受的程度。
但在某些特定的场景下，比如工业自动化、机器人、航空航天、军工领域等，仍然对实时操作系统有需求，并且应该会长期存在。
同时，由于实时操作系统的特性，它并不是一个应用场景广泛的系统，一些人认为学嵌入式就是学实时操作系统，这种认识其实是不正确的，现在嵌入式开发，不一定需要在实时操作系统下完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30b9e22571fdd1bb224fb3d29632cede/" rel="bookmark">
			Android wifi — WiFi空口包交互过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android wifi — WiFi空口包交互过程 0. 前言1. 探测阶段1.1 Probe Request1.2 Probe Response 2. 认证阶段2.1 Authentication Req2.1.1 Shared Key2.2.2 Open System2.2.3 对比Shared Key &amp; Open System 3. 关联阶段3.1 Association Request3.2 Association Rsponse 4. EAPOL 0. 前言 本文通过抓取的WiFi空口包，简要分析下WiFi的连接过程。
连接三步骤
探测（Probe Request、Probe Response）认证（Authentication）关联（Association Request、Association Response） 如下图可见，WiFi连接过程可大致分为 探测/扫描（Probe）-&gt; 认证（Authentication） -&gt; 关联（Association） -&gt; EAPOL 四个阶段。其中EAPOL不是必要阶段，当加密方式为none或wep时，没有此阶段。下面逐一分析各个阶段。
1. 探测阶段 STA 发送 Probe Req 帧，携带 SSID 表明欲加入的网络，携带 Supported Rates 表明自身的能力。
AP 回复 Probe Rsp 帧，这是 AP 的义务，(AP 允许此 STA 连接的情况下)也携带 Supported Rates 表明自身的能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30b9e22571fdd1bb224fb3d29632cede/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16154dab44f4e68d7e467f8340d0ae48/" rel="bookmark">
			【VS】如何把wpf项目打包成exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要将WPF项目打包为.exe文件，您可以使用Visual Studio的发布功能。以下是一些简单的步骤：
打开您的WPF项目。在Visual Studio的顶部菜单栏中，选择“生成”（Build）选项，然后选择“发布”（Publish）。在发布页面中，选择“目标”（Target）为“文件夹”（Folder）。选择一个文件夹路径作为发布目标文件夹。配置其他发布选项，例如配置文件、依赖项等。点击“发布”（Publish）按钮，开始发布过程。发布完成后，您将在指定的目标文件夹中找到生成的.exe文件。 这样，您就可以将WPF项目打包为可执行文件（.exe），可以在其他计算机上运行。请注意，生成的.exe文件可能需要依赖于特定的运行时环境，您可能需要在其他计算机上安装相关的.NET Framework版本或其他依赖项。
检查安装Access 数据库所需的文件 检查安装Access 数据库所需的文件，并在没有安装时自动安装，您可以执行以下步骤：
首先，确定所需的 Access 数据库文件是什么。通常，Access 数据库需要在计算机上安装 Microsoft Access 或 Microsoft Office 套件。
您可以使用 Registry 类从 Windows 注册表中检查是否安装了 Microsoft Access。以下是一个示例代码片段：
using Microsoft.Win32; bool IsAccessInstalled() { bool isInstalled = false; try { using (RegistryKey key = Registry.ClassesRoot.OpenSubKey("Access.Application")) { isInstalled = key != null; } } catch (Exception ex) { Console.WriteLine("检查 Access 安装时出错：" + ex.Message); } return isInstalled; } 上述代码检查是否存在名为 “Access.Application” 的注册表项，如果存在，则表示已安装 Microsoft Access。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16154dab44f4e68d7e467f8340d0ae48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6bbb5d2cac2b1eb50912864e8c5522e/" rel="bookmark">
			蓝牙技术在物联网中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，蓝牙技术在物联网领域发挥了重要的作用。作为一种无线通信技术，蓝牙能够实现低功耗、短距离的数据传输，因此广泛应用于各种物联网设备中。本文将介绍蓝牙技术在物联网中的应用，以及它对我们生活带来的便利和改变。
蓝牙技术的发展历史：
蓝牙1.0：蓝牙技术最早于1994年由爱立信公司提出，并在1999年发布了蓝牙1.0规范。蓝牙1.0规范支持最基本的蓝牙功能，如数据传输和音频通信。蓝牙2.0：在2004年，蓝牙2.0规范发布，引入了增强数据传输速度和安全性的特性。蓝牙2.0还引入了蓝牙增强数据速率（EDR）技术，使得数据传输速度提高了3倍。蓝牙3.0：蓝牙3.0规范于2009年发布，引入了高速蓝牙技术。高速蓝牙技术通过使用Wi-Fi技术来实现更快的数据传输速度。蓝牙3.0还支持传统蓝牙和低功耗蓝牙两种模式。蓝牙4.0：蓝牙4.0规范于2010年发布，是蓝牙技术发展史上的一次重大革新。蓝牙4.0将传统蓝牙、低功耗蓝牙和高速蓝牙技术合并为一个规范，可以组合或单独使用。低功耗蓝牙技术使得蓝牙设备的电池寿命得到了显著提升，适用于物联网和传感器等低功耗设备。蓝牙5.0：蓝牙5.0规范于2016年发布，引入了更快的数据传输速度和更远的覆盖范围。蓝牙5.0还增加了支持多个设备同时连接的能力，提供了更好的用户体验。 一、蓝牙技术在家居领域的应用
在智能家居系统中，蓝牙技术被广泛应用于各种设备之间的连接和控制。比如，通过蓝牙可以实现智能门锁和手机之间的连接，使我们能够通过手机随时远程开关家门；蓝牙还可以用于智能家电设备的连接，如智能电视、智能音箱等，通过手机与这些设备连接后，我们可以实现远程控制、音频传输等功能。
二、蓝牙技术在交通领域的应用
在交通领域，蓝牙技术被应用于车载系统和交通设施中，以提高交通的安全与效率。比如，通过蓝牙，车辆可以与交通信号灯、停车场等设施进行连接，及时获取交通信息和路况，从而帮助驾驶员选择更优的行驶路线和停车位置；同时，车辆之间也可以通过蓝牙通信，实现实时的交通信息分享和协同行驶，从而减少交通拥堵和事故的发生。
三、蓝牙技术在健康医疗领域的应用
蓝牙技术在健康医疗领域的应用也逐渐增多。通过蓝牙连接，医疗设备可以与患者的移动设备（如手机、手环等）进行数据传输和监测。比如，患者可以通过佩戴蓝牙设备实时监测身体指标并传输给医疗机构，医生可以根据数据进行远程诊断和治疗，提供精细化的医疗服务；同时，蓝牙技术也可以应用于智能药盒、智能药瓶等，记录用药情况并提醒患者按时服药。
四、蓝牙技术在智能城市建设中的应用
在智能城市建设中，蓝牙技术被广泛应用于公共设施和城市管理。例如，蓝牙技术可以用于公共交通工具的定位和调度，提高公交的运行效率和服务体验；蓝牙技术还可以应用于智能路灯、智能垃圾桶等设施，实现远程控制、能源节约和智能管理。
总之，蓝牙技术在物联网中的应用带来了许多便利和改变。它将各种设备通过低功耗、短距离的无线通信连接在一起，使得我们能够更加智能地控制和管理这些设备。随着物联网的不断发展和创新，蓝牙技术的应用也将越来越广泛，为我们的生活带来更多便利和智能化的体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683ffa7ff6e969c2f4c9fb1ea399f561/" rel="bookmark">
			【maven】正式版本和快照版本详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Maven 中，"正式版本"和"快照版本"是两种不同的版本类型，它们的主要区别在于版本号和发布周期。
一、定义 正式版本（Release）： 正式版本是项目的一个稳定、有序的发布版本，用于生产环境部署。版本号通常不包含任何特殊标识，例如 1.0.0 或 2.3.1。一旦发布了正式版本，其版本号不会更改。每个正式版本都是一个独立的、可靠的构建。 快照版本（Snapshot）： 快照版本表示项目的一个开发中或不稳定的版本，可能包含最新的开发进展。版本号通常包含 -SNAPSHOT 后缀，例如 1.0.0-SNAPSHOT。快照版本可以是不稳定的，可能会频繁更改。每次构建时都生成新的快照版本，代表最新的开发状态。 二、使用场景： 正式版本： 适用于生产环境，具有稳定的 API 和功能。快照版本： 适用于开发和测试阶段，开发人员可以及时获取最新的构建结果，但不适合用于生产环境。 在 Maven 项目的 pom.xml 文件中，正式版本和快照版本的声明方式有所不同：
&lt;!-- 正式版本 --&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!-- 快照版本 --&gt; &lt;version&gt;1.0.1-SNAPSHOT&lt;/version&gt; 配置正式版本和快照版本打包部署地址的代码为：
&lt;project&gt; &lt;!-- 其他项目配置 --&gt; &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;my-repo&lt;/id&gt; &lt;url&gt;https://example.com/maven-repo&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;my-snapshot-repo&lt;/id&gt; &lt;url&gt;https://example.com/maven-snapshot-repo&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; &lt;!-- 其他项目配置 --&gt; &lt;/project&gt; 需要注意的是，快照版本可能包含尚未稳定的功能或可能更改的 API，因此在生产环境中应该谨慎使用。发布正式版本是为了提供一个经过测试和验证的稳定版本。详细解释参考另一篇文章《【maven】pom.xml 文件详解》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f3d6d3cadecc8865b474b2ba53a4e8/" rel="bookmark">
			User maven 通过什么命令能查到那个包依赖了slf4j-simple-1.7.36.jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 Maven 项目中查找哪个包依赖了 slf4j-simple-1.7.36.jar，您可以使用 Maven 的依赖树命令 mvn dependency:tree。这个命令会展示项目所有依赖的层次结构，包括传递依赖（即一个依赖的依赖）。然后，您可以搜索或过滤输出来找到特定的依赖。
在命令行中，您可以执行以下命令来查找包含 slf4j-simple 的依赖项：
mvn dependency:tree -Dincludes=org.slf4j:slf4j-simple 这个命令将只显示与 slf4j-simple 相关的依赖项。
如果您想查看整个依赖树，然后手动搜索 slf4j-simple，可以执行：
mvn dependency:tree | grep 'slf4j-simple' 请注意，这些命令可能需要在包含项目 pom.xml 的目录中执行。通过分析输出，您可以确定是哪个项目或哪个依赖项间接地添加了 slf4j-simple 依赖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1baa0ad84aa4de6a0122bc25152d63b/" rel="bookmark">
			W5100S-EVB-Pico评估版介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 简介2 硬件资源2.1 硬件规格2.2 引脚定义2.3 工作条件 3 参考资料3.1 Datasheet3.2 原理图3.3 尺寸图（单位：mm）3.4 参考例程 4 硬件协议栈优势 1 简介 W5100S-EVB-Pico是一款基于树莓派RP2040和全硬件TCP/IP协议栈以太网芯片W5100S的MCU评估板，其工作原理与树莓派Pico板基本相同，但通过W5100S增加了以太网。
2 硬件资源 2.1 硬件规格 RP2040 微控制器，配备2MByte Flash 双核 Arm Cortex-M0 + @ 133MHz芯片内置 264KB SRAM 和 2MB 的板载闪存通过专用 QSPI 总线支持最高 16MB 的片外闪存30 个 GPIO 引脚，其中 4 个可用作模拟输入 1.8-3.3V IO 电压 (注意：Pico IO电压固定为3.3V) 12位500ksps模拟数字转换器（ADC）丰富的外设 2 × UART, 2 × I2C, 2 × SPI, 16 × PWM 通道1 × Timer 和 4 x alarms, 1 × RTC 8个树莓派可编程 I/O（PIO）状态机，用于自定义外围设备支持灵活且可编程的高速IO支持模拟SD卡和VGA等接口 W5100S 全硬件TCP/IP协议栈 支持丰富的协议: TCP, UDP, UDP协议上的WOL, ICMP, IGMPv1/v2, IPv4, ARP, PPPoE硬件协议栈不受网络攻击，安全稳定 4个独立的硬件socket，各路通信互不影响16KB片上缓存供TCP/IP包处理高速SPI接口 Micro-USB接口，用于供电和传输数据（通过拖放烧录程序）3针ARM串行线调试(SWD)端口内置10 / 100 以太网 PHY全/半双工，10/100速率自动协商内置RJ45(RB1-125BAG1A)内置LDO (LM8805SF5-33V) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1baa0ad84aa4de6a0122bc25152d63b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/065c73553ea2a69f2d9d09d16433643b/" rel="bookmark">
			2015年第四届数学建模国际赛小美赛C题科学能解决恐怖主义吗解题全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2015年第四届数学建模国际赛小美赛 C题 科学能解决恐怖主义吗 原题再现： 为什么人们转向恐怖主义，特别是自杀性恐怖主义？主要原因是什么？这通常是大问题和小问题的结合，或者是一些人所说的“推拉”因素。更大的问题包括疏远、共同的愤怒或愤慨（例如，对某些外交政策）、沮丧、幻灭、行动带来的受害感，或者在叙利亚，其他国家的不作为。小问题，“诱惑”包括转变的感知好处——例如冒险、兴奋、友爱、归属感、成为更大事物的一部分等等。理解的关键不只是问人们为什么转变，而是问他们如何转变，以及招聘人员在这个过程中使用什么策略。有效的招聘人员会使用他们武库中的任何工具来吸引某人，无论是说服他们有义务去为他人而战，还是说服他们，参与为他们提供了一条摆脱羞辱和伤害的途径，招聘人员会提醒年轻人，否则他们注定要在家里面对。激进主义，以及它与招聘的关系（以及我们如何应对）是一个不断变化的系统。有些极端的特质并不象它们看起来对社会适应或幸福感那样对身体健康不利，即使在对严重紊乱的受试者进行检查时也是如此。事实上，有些性状越严重，就越有利于吸引更多的配偶，甚至产生更多的后代。这将把这些特征描述为通向健康的危险捷径，与其说是由于失败，不如说是由于基因为了自我延续而做出的曲折。为什么今天有人加入，和为什么三年前有人可能加入同一个组织是不同的。理想主义，有助于吸引一个人到恐怖主义往往与现实冲突的经验，新成立的新兵。诱捕（在心理意义上）发展迅速，新兵必须以某种方式应对这种幻灭。你默许它，然后继续前进，也许是拥抱思想内容，或者在同志情谊中寻求安慰。或者你挣扎着试图隐藏它，直到你能出来。一些恐怖分子报告说，早在他们能够脱离恐怖主义之前，幻想就破灭了。他们报告说有一种窒息感——因为害怕报复（恐怖分子或国家）而无法离开，同样害怕在运动中与他们关系密切的人发现他们的幻灭。我们需要做得更好，不仅为那些一开始就走上恐怖主义道路的人提供“出口”，而且为那些陷入困境并希望在为时已晚之前逃离的人提供“出口”。我们需要了解他们的某些心理特征。
考虑两个问题。第一：你是谁？在你买的东西、你穿的衣服、你开（或拒绝开）的车方面，你和你的同龄人有什么不同？是什么让你在你的基本心理方面与众不同，让你做你所做的事，说你所说的事，感受你所感受到的事？第二个问题：你如何使用互联网？
虽然这些问题看起来似乎不相关，但事实并非如此。很明显，你上网的内容可以暗示你的某些心理特征。花很多深夜玩高赌注网络扑克？你很可能是个冒险者。喜欢在YouTube上发布自己唱卡拉OK的视频吗？显然是个外向的人。选择在网络游戏中扮演异性角色？你想得到其他玩家的关注或更友善的对待。但是你的互联网使用机制如何呢？你给别人发电子邮件、在线聊天、流媒体、玩游戏或多任务（从一个应用程序或网站切换到另一个应用程序或网站）的频率是多少？这些行为——无论其内容如何——也能预测心理特征吗？
假设我们可以监控一些人的互联网使用情况。我们不知道人们在互联网上看到了什么（例如，没有压力的人——一个死亡赠品），而仅仅知道他们是如何使用互联网的。这些数据类别都没有提供人们访问的网站、电子邮件或聊天内容或下载的文件类型的具体信息——它们只是表明人们使用不同类别网络资源的程度，以及人们同时使用多种资源的倾向差异。
任务1：建立一个数学模型，得到一个风险指数，这样我们就可以评估每个被监控人员使用它的情况。
任务2：专家们用“大数据”来表示大量的信息。我们将获得大量的监测数据，请开发一系列的统计技术，以有效、快速和自动的方式对其进行分类。
任务3：如果奥巴马总统问你关于反恐的建议，你会告诉他什么？他应该怎么处理ISIS？
整体求解过程概述(摘要) 对于任务一，我们从被监控人群的互联网使用数据中提取六个特征。另外，对数据进行了矢量化和归一化处理，为以后的模型定量分析奠定了良好的基础。然后，考虑到我们可能无法获取恐怖分子的互联网使用数据，基于这六个特征分别建立了具有先验知识的模型和不具有先验知识的模型。并基于特征间欧氏距离对每个被监测人的风险指数进行评估。最后，考虑了缺失数据的处理。
对于任务二，利用一种高效、快速、自动的聚类算法，基于互联网使用数据，采用无监督分类对被监控人员进行分类。然后根据任务一中建立的模型对每个群体的风险指数进行评估。
对于任务三，我们从四个方面提出了综合解决方案。首先，根据前面计算的风险指数，识别出具有潜在恐怖倾向的人。对他们进行监控，帮助他们走出不良心理，从源头上消除恐怖主义倾向。其次，根据社会网络分析的中心性，找出恐怖组织中的关键人物。通过打击这些人，可以达到有效瓦解恐怖组织的目的。第三，通过对黑社会性质组织的分析，找出黑社会性质组织的“出逃点”，帮助他们走出恐怖主义的阴影。最后，通过关联规则分析，挖掘出恐怖主义攻击的规则，从而采取有效的反恐措施。此外，本文还利用实际数据对关联模型进行了验证。最后，总结上述四项措施，为奥巴马总统提出一个全面的反恐建议。
在完成这三个任务之后，我们讨论了我们的模型对实际数据的鲁棒性。最后得出科学可以解决恐怖主义的结论。
模型假设： 可以得到恐怖分子网络使用特征的数据。
恐怖分子的网络使用特征具有一定的分布规律。
个体抑郁对恐怖倾向有决定性影响。
我们可以得到更丰富的数据，不仅包括互联网使用特征，还包括个人的社会关系。
我们可以了解恐怖组织内部详细的网络数据。
在社会网络中，中心性指数最高的网络起着关键作用。
问题重述： 我们的工作
一些恐怖分子报告说，他们有一种窒息感，因为害怕报复而无法离开，同样害怕他们的幻灭被运动中与他们关系密切的人发现。因此，我们需要更好地提供救援措施，不仅是为那些走上恐怖主义道路的人，而且也为那些陷入困境并希望在为时已晚之前逃离的人。心理特征是解决这一问题的关键，可以通过网络使用习惯来体现。在不提供互联网使用内容的情况下，我们发送电子邮件、聊天、在线、流媒体或多任务（从一个应用程序或网站切换到另一个）的频率也可以预测心理特征。根据这些上网习惯，我们可以预测用户的心理特征，为反恐做一些工作。
任务一
基于网络使用情况，分别建立有先验知识和无先验知识的模型，对每个被监控人使用网络的风险指标进行评估。利用恐怖分子的先验知识，对恐怖分子的网络使用习惯按流量平均包数、点对点使用、聊天、电子邮件、流持续时间熵、ftp和远程文件使用6个指标进行聚类。然后根据六个指标与恐怖分子标准的相似度来评价被监控人的风险指数。
在没有恐怖分子网络使用数据的情况下，直接利用上述六个指标对风险指数进行评估。在排名之后，我们可以预测哪些人可能是恐怖分子，或者哪些人可能正在走向恐怖主义。
任务二
专家们用“大数据”这个词来表示海量的信息，比如数十亿人随时在电脑、智能手机和其他电子设备上共享的信息。我们将获得大量的监控数据，但为了使用这些海量数据，我们必须了解它们。因此，我们使用快速聚类算法对这些大数据进行有效、快速和自动的分类。然后利用模型一或模型二计算聚类中心的各风险指标。在已有恐怖分子网络使用先验数据的情况下，可以计算出聚类中心的风险指数，然后根据模型1中的分类标准对其进行分类，预测其是否为恐怖分子。
任务三
如果奥巴马总统征求反恐建议，我们会告诉他，我们需要在更多的科学研究上进行长期投资。具体建议如下：
在模型1、模型2和模型3的基础上，通过心理分析对恐怖分子进行预测，并对预测出来的恐怖分子采取预防措施。
在社会网络分析的基础上，通过计算节点中心度，可以预测恐怖分子组织中可能的领导者，并对其进行监控和打击。
在已有数据的基础上，利用关联规则分析可以预测恐怖分子在未来一段时间内可能遭受的攻击。政府和安全官员可以根据这些预测采取相关行动。
模型的建立与求解整体论文缩略图 全部论文请见下方“ 只会建模 QQ名片” 点击QQ名片即可 部分程序代码：(代码和文档not free) clc,clear xj=[6 2 2 0 5 4 3 0 2 4 5 3 1 0 4 3 3 2 0 5 5 3 0 1 3 0 2 3 2 3 6 2 0 1 5 5 1 3 2 4 4 1 1 0 6 2 2 1 0 0]; xj=xj'; xjm(1,:)=mean(xj); xjd(1,:)=std(xj); xj=zscore(xj); A=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/065c73553ea2a69f2d9d09d16433643b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3030c1ee48724a798d9e3efcb54cef28/" rel="bookmark">
			Linux上iPortal 配置80端口的http
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：yx
文章目录 前言方法一、配置使用外置ES1、关闭启用 iPortal 内置的 ES2、修改80端口3、启动外置ES4、启动iPortal5、结果验证 方法二、更改 Linux 系统配置1. 安装 Authbind2. 启用端口的读取和执行权限3. 在 Apache Tomcat 上启用 Authbind4. 重启iPortal5. 结果验证 前言 大家知道Linux上边启动Elasticsearch（以下简称：ES）需要普通用户，不能是root用户，因此在Linux上边启动iPortal时需要以非root用户去启动，但是有的项目又需要以80端口去启动，由于Linux普通用户，不能使用小于1024的端口，因此如果在Tomcat的server.xml里面配置端口为80的话，HTTP服务器启动会失败。那对于这种情况该如何处理呢，一起来看看吧！
方法一、配置使用外置ES 注：如果您自己搭建了 ES服务器，可以直接用搭建好的。这里以iPortal自带的ES为例
1、关闭启用 iPortal 内置的 ES 修改 %SuperMap iPortal_HOME%/webapps/iportal/WEB-INF 目录下的 iportal.xml 配置文件，具体配置项如下：
&lt;IportalConfig&gt; ... &lt;modulesConfig&gt; &lt;searchModuleConfig class="com.supermap.server.config.BuildinSearchConfig"&gt; &lt;enable&gt;true&lt;/enable&gt; &lt;reindexAllResources&gt;true&lt;/reindexAllResources&gt; &lt;startElasticSearch&gt;false&lt;/startElasticSearch&gt; &lt;port&gt;8192&lt;/port&gt; &lt;/searchModuleConfig&gt; &lt;/modulesConfig&gt; ... &lt;/IportalConfig&gt; &lt;enable&gt;：是否启用搜索服务。默认值： true。注意：此参数必须设置为 true。&lt;reindexAllResources&gt;：是否重新索引已有 iPortal 资源。重建索引后，此配置会自动设置为 false。&lt;startElasticSearch&gt;：是否启用 iPortal 内置的 ES。默认值：true。如果您希望使用自己搭建的 ES 服务器，需要将该值设置为 false。&lt;port&gt;：搜索服务的端口。默认值：8192。 其中需要修改 &lt;startElasticSearch&gt;参数为false。配置完成后，需重启 iPortal 生效。
2、修改80端口 修改 Tomcat 配置文件%SuperMap iPortal_HOME%/bin/conf/server.xml，如下：
&lt;Connector port="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3030c1ee48724a798d9e3efcb54cef28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5657f8f68ed01e28141de6d7146f1f43/" rel="bookmark">
			【WPF】使用Settings文件来存储和读取持久化变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在WPF中，可以使用Settings文件来存储和读取持久化变量。下面是一个示例：
在Visual Studio中打开你的WPF项目。在Solution Explorer中，右键单击项目，选择"Properties"。在属性窗口中，选择"Settings"选项卡。在Settings文件中，添加一个新的设置项。可以为该设置项指定名称、类型和默认值。 例如，假设你想要存储一个持久化的字符串变量：
名称：MyVariable类型：string默认值："Default Value" 设置完成后，可以使用以下代码在应用程序中存储和读取该变量：
// 存储变量 Properties.Settings.Default.MyVariable = "New Value"; Properties.Settings.Default.Save(); // 读取变量 string myValue = Properties.Settings.Default.MyVariable; 在上述示例中，我们使用Properties.Settings.Default来访问Settings文件中的变量。要存储变量，我们将新值赋给MyVariable属性，并调用Save()方法来保存设置。要读取变量，我们可以通过访问MyVariable属性来获取其值。
请注意，存储的变量在应用程序关闭后仍然可用，并且在下次打开应用程序时保持不变。但是，如果你需要在应用程序运行时动态更改变量的值，那么你需要在设置之前调用Properties.Settings.Default.Reload()方法来重新加载设置。
避免只读 根据你提供的代码片段，LanIP属性是只读的，意味着它只能用于获取某个设置项的值，而不能用于设置它。
在WPF的Settings文件中，可以通过以下方式创建只读的设置项：
[global::System.Configuration.UserScopedSettingAttribute()] [global::System.Diagnostics.DebuggerNonUserCodeAttribute()] public string LanIP { get { return ((string)(this["LanIP"])); } } 在上述代码中，UserScopedSettingAttribute和DebuggerNonUserCodeAttribute是可选的属性，用于提供额外的元数据和调试信息。
要设置设置项的值，你需要在Settings文件中添加一个可写的设置项。例如：
[global::System.Configuration.UserScopedSettingAttribute()] [global::System.Diagnostics.DebuggerNonUserCodeAttribute()] public string LanIP { get { return ((string)(this["LanIP"])); } set { this["LanIP"] = value; } } 在上述代码中，我们添加了一个set访问器，允许你设置LanIP的值。使用该设置项时，可以通过LanIP属性来获取和设置该设置项的值。
请注意，在更改设置项的值后，你需要调用Save()方法来保存设置，以便在应用程序关闭后保持更改。
使用 string ip = Properties.Settings.Default.LanIP;
要判断一个字符串是否是有效的IP地址，可以使用IPAddress.TryParse()方法。在你的代码中，可以使用以下方式完成：
string ip = Properties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5657f8f68ed01e28141de6d7146f1f43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bce79ea1c74b982280acec1df82762f/" rel="bookmark">
			uniapp项目在微信开发工具里打开报错Error:app.json:在项目根目录未找到app.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uni-app 项目我们在微信开发工具里面打开报错
编译报错：[ app.json 文件内容错误] app.json: app.json 未找
1、运行项目之前，我们这里使用的是HBuilder X 这个软件运行的。 打开这个软件，导入你的小程序的项目
2、在左上角找到运行，运行到小程序模拟器–微信开发者工具（第一个即可） 运行完成会发现多了一个文件夹
3、在回到微信开发者工具运行导入指定文件对应的路径，点至mp-weixin，一般为项目中unpackage–&gt;dist–&gt;dev–&gt;mp-weixin；我们的项目就可以了，此时我们 的项目便可以启动啦 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a653d5628836b09cafc6dce58543838/" rel="bookmark">
			2023年国赛高教杯数学建模E题黄河水沙监测数据分析解题全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023年国赛高教杯数学建模 E题 黄河水沙监测数据分析 原题再现 黄河是中华民族的母亲河。研究黄河水沙通量的变化规律对沿黄流域的环境治理、气候变化和人民生活的影响，以及对优化黄河流域水资源分配、协调人地关系、调水调沙、防洪减灾等方面都具有重要的理论指导意义。
附件 1 给出了位于小浪底水库下游黄河某水文站近 6 年的水位、水流量与含沙量的实际监测数据，附件 2 给出了该水文站近 6 年黄河断面的测量数据，附件 3 给出了该水文站部分监测点的相关数据。请建立数学模型研究以下问题：
问题 1 研究该水文站黄河水的含沙量与时间、水位、水流量的关系，并估算近 6 年该水文站的年总水流量和年总排沙量。
问题 2 分析近 6 年该水文站水沙通量的突变性、季节性和周期性等特性，研究水沙通量的变化规律。
问题 3 根据该水文站水沙通量的变化规律，预测分析该水文站未来两年水沙通量的变化趋势，并为该水文站制订未来两年最优的采样监测方案（采样监测次数和具体时间等），使其既能及时掌握水沙通量的动态变化情况，又能最大程度地减少监测成本资源。
问题 4 根据该水文站的水沙通量和河底高程的变化情况，分析每年 6-7 月小浪底水库进行“调水调沙”的实际效果。如果不进行“调水调沙”，10 年以后该水文站的河底高程会如何？
附件 1 2016-2021 年黄河水沙监测数据
附件 2 黄河断面的测量数据
附件 3 黄河部分监测点的监测数据
附录 说明
(1) “水位”和“河底高程”均以“1985 国家高程基准”（海拔 72.26 米）为基准面。
(2) 附件中的“起点距离”以河岸边某定点作为起点。
整体求解过程概述(摘要) 黄河是中国的母亲河，其水资源和水沙情况的准确监测对于维护国家生态安全和水资源管理至关重要。本文分析了位于小浪底水库下游黄河某水文站近六年的水位、水流量与含沙量的实际检测数据，基于时间序列预测模型，建立了含沙量预测模型，并分析了该水文站水沙通量的突变性、季节性和周期性等特性，为水文站制定了未来两年最优的采样监测方案，最后分析了“调水调沙”对该水文站河底高程的影响。
针对问题一，本文使用了线性回归模型，来探讨在特定水文站观测到的黄河水的含沙量与时间、水位和水流量之间的关联关系。以描述这些时间、水位和水流量与含沙量之间的关系，并确定各自的系数，从而更好地理解这些因素对含沙量的影响。并给出了水位、流量和含沙量随时间变化的示意图。
针对问题二，采用滑动窗口分析，我们能够识别和量化水沙通量时间序列中的突变点，从而揭示数据中的异常变化。接着，我们进行季节性分解，将时间序列数据分解成长期趋势、季节性成分和周期性成分，以更全面地理解水沙通量的季节性和周期性特征。
针对问题三，根据问题二得出的水沙通量变化规律，使用 ARIMA 模型对未来两年该水文站的水沙通量变化趋势进行预测。采用遗传算法，并结合预测的水沙通量变化趋势，为该水文站制定了未来两年的采样监测方案。
针对问题四，根据 8-5 月（第二年）该水文站的水沙通量和河底高程变化，对6-7 月未进行调水调沙情况进行预测，使用 DID 方法比较其与进行调水调沙之后的差异，以此来分析调水调沙的实际效果，并预测了 10 年后不进行调水调沙情况下河底高程的变化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a653d5628836b09cafc6dce58543838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bcd57a474cc3154a53c49fb0de71dd7/" rel="bookmark">
			kafka相关面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是Kafka，它主要用于什么场景？ Kafka是一个分布式流处理平台，由LinkedIn开发并于2011年开源，目前是Apache软件基金会的一个顶级项目。Kafka被设计来允许应用程序高效地处理实时数据流，并具备以下的核心功能：
发布和订阅流数据：如同消息队列或企业消息系统，Kafka允许应用程序发布数据流到主题，并订阅主题以接收数据流。存储流数据：Kafka可以在分布式环境中长时间存储数据流，即使数据已被消费。处理流数据：Kafka提供了流处理的能力，允许实时处理进入的数据流。 Kafka经常被用于以下场景：
事件驱动架构 Kafka可以用来构建事件驱动的应用，其中系统组件通过事件进行通信，而不是直接调用彼此的接口。
实时数据管道 它可以将数据从一个系统或数据源无缝地传输到另一个系统，通常用于实时数据集成和流式ETL（提取、转换、加载）过程。
日志聚合 Kafka可以收集不同应用和系统的日志和监控数据，然后将这些数据传输到中央日志处理或监控系统。
流式处理 Kafka配合Kafka Streams或其他流处理库（如Apache Flink或Apache Storm）可以进行复杂的实时数据分析和处理。
消息队列 Kafka常常作为一个大规模的消息队列使用，它可以处理高吞吐量的消息传递。
解耦服务 在微服务架构中，Kafka可以解耦服务之间的依赖关系，使得系统易于扩展和维护。
常见的应用案例包括： 实时分析（如监测用户活动）实时推荐引擎分布式日志记录数据湖的实时数据摄取跨多个位置的数据复制背压管理（当消费者比生产者慢时，Kafka可以存储未处理的消息） 由于其高性能、可伸缩性、容错性和低延迟特性，Kafka非常适合需要处理高速、高容量数据流的应用场景。
2、Kafka中的Topic是什么？ 在Kafka中，主题（Topic）是一个核心概念，它代表了一个消息的类别或者名称。可以将其视为一个消息传递的频道，生产者（Producers）向主题发送消息，而消费者（Consumers）则从主题读取消息。Kafka中的数据都是围绕主题进行组织和传输的。
每个Kafka主题可以被细分为一个或多个分区（Partitions），这为主题提供了水平的可扩展性，并允许并行处理。每个分区是一个有序不变的消息序列，它通过使用偏移（Offset）来唯一标记每条消息。
这里有一些关于Kafka主题的关键点：
持久性：Kafka的主题是持久化的，意味着消息被持久存储到磁盘上，并且可以根据配置来保留一定时间或直到达到某个大小上限。可伸缩性：主题可以跨多个Broker和分区分布，这样可以在集群中横向扩展处理能力。复制：为了提高数据的可靠性和容错性，每个主题可以被配置成多个副本，这些副本分布在不同的Broker上。消费者群组：消费者可以以群组的形式来消费同一个主题，确保每个消息只被群组中的一个消费者处理，或者通过不同的消费者群组来实现消息的广播。排序：在单个分区内，消息是有序的，按照它们被发送到分区的顺序来排序。如果需要跨分区全局顺序，则需要额外的设计考虑。 主题通常根据使用情况或数据逻辑来命名，如“订单”、“用户日志”、“支付”等，这样相关的信息就可以按分类发布和订阅。这种模型为数据的分布式处理提供了极大的灵活性和可扩展性。
3、Kafka中的Producer和Consumer 在Kafka生态系统中，生产者（Producer）和消费者（Consumer）是两个基本的概念，它们定义了数据如何进入和离开Kafka。
Kafka Producer 生产者是发送消息到Kafka主题的客户端应用程序。生产者负责创建消息，然后将它们发布到一个或多个Kafka主题。在Kafka中，消息只是一个记录的数组，包含一个键（key）、一个值（value）和可选的头信息（headers）。
生产者可以决定将消息发送到主题的哪个分区，通常是基于消息键的哈希值，或者如果消息没有键，则通过轮询分区。这决定了消息的分发方式，影响了消费者如何消费消息。Kafka生产者API提供了底层的细节隐藏和自动重试机制，简化了消息发送流程。
生产者示例（Java）：
import org.apache.kafka.clients.producer.KafkaProducer; import org.apache.kafka.clients.producer.ProducerRecord; Properties props = new Properties(); props.put("bootstrap.servers", "localhost:9092"); props.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer"); props.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer"); KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props); String topic = "my-topic"; String key = "my-key"; String value = "my-value"; ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(topic, key, value); producer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bcd57a474cc3154a53c49fb0de71dd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66133ecb148bbadb3ba9e41e513bb2c/" rel="bookmark">
			mysql如何分析sql是否成功使用索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考gpt https://www.askchat.ai?r=237422
在MySQL中，可以通过使用EXPLAIN语句来分析SQL查询是否成功使用了索引。EXPLAIN语句可以返回有关查询执行计划的信息，包括索引使用情况。
以下是使用EXPLAIN语句分析SQL语句是否成功使用索引的步骤：
打开MySQL客户端或者使用图形化工具登录到MySQL数据库。在MySQL命令行或者查询编辑器中，输入以下语句并替换为你要分析的SQL语句：EXPLAIN SELECT * FROM table_name WHERE condition; 请将table_name替换为你要查询的表名，condition替换为你要应用的查询条件。执行上述EXPLAIN语句，MySQL将返回一列包含查询执行计划的结果集。在结果集中，关注以下列： id：标识查询中的每个操作步骤，多个步骤的查询会有多行。select_type：表示查询的类型，例如SIMPLE表示简单查询，SUBQUERY表示子查询等。table：表示查询操作涉及的表名。type：表示访问表的方式，常见的值包括ALL（全表扫描）、INDEX（使用了索引）、range（使用了范围索引）等。possible_keys：表示可能使用的索引。key：表示实际使用的索引。key_len：表示使用的索引的长度。ref：表示使用索引进行查找的参考值。rows：表示估计需要扫描的行数。Extra：表示其他额外的信息，例如是否使用了临时表、是否使用了文件排序等。 通过观察type列和key列，你可以判断查询是否成功使用了索引。如果type的值是ALL，表示全表扫描，没有使用索引。如果type的值是index，表示使用了索引。同时，确保key列中显示了实际使用的索引。
请注意，分析EXPLAIN结果需要一定的经验和理解。如果需要进一步了解如何优化查询性能和索引使用，请考虑深入学习MySQL的查询优化和索引相关的知识。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3537f902c3175cdfcf187849ddcc0021/" rel="bookmark">
			AI时代下，如何看待“算法利维坦”？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT的浪潮从2022年袭来后，至今热度不减，呈现出蓬勃发展的趋势。AI+家居、医疗、教育、金融、公益、农业、艺术…AI真的已经走进了生活的方方面面，我们仿佛已经进入了AI时代，势不可挡。人工智能水平如此之高，不禁感慨背后算法的强大。当技术发展过快，带来的有便捷、焦虑、困惑等诸多思考。强大的智能算法带来社会效益的同时，也附带着不可避免的社会风险，即算法利维坦，从而影响着一个国家的上层建筑。
一、何为算法利维坦？ 有1才能有1+1，有利维坦才能有算法利维坦。
提问：什么是“利维坦”？
回答：霍布斯，将因主权观念而能够支配一切、宛如魔神一般几乎拥有无限权力的主权国家，称为“利维坦”——至尊的巨灵。
是霍布斯“无限政府”设计图的体现，本质上属于政治概念。霍布斯是这样解释主权国家底层逻辑的：把所有人的权力和力量托付给某个特定的人，或者能够集合大家意志的多人集合体。简单地说就是，人类缔约建立的为人类提供安全和秩序的强大机构。
这里，可将主权国家看作一个权力的集装箱。（以上，略显枯燥生疏的大段背景可自行跳过。省时又省流， hhh…）
而算法利维坦，就是随着技术自主性的日益凸显，算法嵌入政治体系，深刻影响政治价值、权力。是一种“利维坦”的智能形态。人们极其依赖于利维坦提供的安全，会因为缺乏对其制约而受其约束。那么，对于算法利维坦，人们则可能会因享受技术的便利而逐渐沦为其附庸。使得算法利维坦具有权力让渡的半契约逻辑，算法时代的公民可能基于生活便利和政治安全的目的将自己的权力让渡于算法权力，从而导致公民处于弱势地位。
二、ChatGPT的运行机制是什么？ 当下，ChatGPT无疑是最火的AI代表。
ChatGPT属于生成式AI，一款遥遥领先的人工智能语言模型。
“预训练+微调”为其基本的算法逻辑，整体架构遵从“基础语料+预训练+微调”，强大的算力是其运行的动力，海量数据为其训练的基础。（浅浅带过一下，非本文重点）
现象级走红的背后，更有对ChatGPT算法的忧虑，因其算法权力行使和运行全过程均处于黑箱状态。再次回到前文“算法利维坦”的论述逻辑。
三、当下AI发展过快引发的争议 有思考，就会有问题，有问题，就会有疑虑，有疑虑就会有争议。
同样，以ChatGPT为例，对社会就业、伦理、法律…方方面面的争议铺天盖地地袭来。
这里，可以简单讨论一下，TA 令人诟病的地方，毕竟GPT也还存在很多问题。
1.有些领域内专业性不够，深入程度不够。毕竟是基于海量数据训练，搜集到的数据中存在的偏颇等问题，同样会吸收，可能导致生成的内容不够合理。例如，借助其写代码，会发现它到处都是瑕疵、不能细看。
2.推理可信度。 常见表现为驴头不对马嘴的对话。
3.可解释性差。 黑盒特性导致它难以自证，看似合理而难寻其迹。在严谨、精细要求领域难以应用。
…
这些是ChatGPT自身的客观问题，同时，也存在社会现象反响更高层次的问题。
从小写作文就知道讲“科技是把双刃剑”，义务教育诚不欺我。
1.类ChatGPT的大语言模型，带来语言对话便捷的同时，也可能存在同搜索引擎一样搜集过多个人信息和隐私的问题。
2.产生类似人类记忆失误的“幻觉”现象。过多训练数据的投喂，ChatGPT并没有明辨是非的能力，它可能以不容置疑的语言胡说八道。
3.引发法律问题。AI基于大量信息自动生成语言，尤其是人文社科领域，更是难辨真假，知识产权认定和保护更是难上加难。
4.威胁社会安定。在搜集信息的过程中，可能会挖掘政府等重要部门的机密信息，甚至出现操纵舆情的现象。
当时，它横空出世，不少人见识到它的本事后，都开始担忧自己会不会被取代，引发了一种人心惶惶的气氛。虽
它的确存在不完美的地方，但是，它才发展几年？未免太小看科技的发展速度了。
这些都是小打小闹，就连国家层面，算法都不曾缺席。
西方现已进入了智能选举的新时代，其政治选举已上升到了数据资源和算法技术的较量。对选民进行算法瞄准、精准挖掘，以科技的手段操控着选民的心理和行为，（联系到生活实际，可以参考某音里大数据精准推送给你的视频。）使得算法瞄准渐渐地走向了民主政治的对立面。
可以看到，算法利维坦下，我们大众是处于弱势地位的。
四、如何寻求正解？ 2021年9月，安东尼奥·古特雷斯秘书长公布了关于《全球数字契约(Global Digital Compact)》的倡议;
2023年5月，联合国发布了政策简报“全球数字契约——为所有人创造开放、自由、安全的数字未来”。
随着时代的进步，AI的飞跃式发展，我们应该更重视冰山水面下那剩下的八分之七。
结语 马克思早已告诉我们真理，”经济基础决定上层建筑，上层建筑反作用于经济基础。“
日新月异的当下，数字法治应该究竟应该如何去制约算法利维坦，如何去保障我们的权益，仍须静待花开。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff6327c17f757a0b1e0c80a17e9fbcb4/" rel="bookmark">
			微信小程序预览pdf，修改pdf文件名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录微信小程序预览pdf文件，修改pdf名字安卓和ios都可用。 1.安卓和苹果的效果 2.需要用到的api 1.wx.downloadFile wx.downloadFile 下载文件资源到本地。客户端直接发起一个 HTTPS GET 请求，返回文件的本地临时路径 (本地路径)，单次下载允许的最大文件为 200MB。
2.wx.openDocument wx.openDocument 新开页面打开文档。
3.代码实现 downPdf(){ let that = this wx.showLoading({ title: "资源下载中...", }); const fileName = '测试一下' //下载文件资源到本地 wx.downloadFile({ url: that.pdfUrl, //后端返回的pdf路径 filePath:`${wx.env.USER_DATA_PATH}/${fileName}.pdf`,//自定义pdf文件名 success: function(res) { const filePath = res.filePath || res.tempFilePath wx.openDocument({ showMenu:true, //分享按钮 filePath: filePath, success: function(res) { wx.hideLoading(); } }) } }) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ff984f85de6c6eca0dfeec297cbc80/" rel="bookmark">
			真实案例扫描APP开发——基于实例分割实现拍照文档实时边缘检测（C&#43;&#43;/JNI实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这是一个安卓NDK的项目，想要实现的效果就是拍照扫描，这里只涉及到的只有边缘检测，之后会写文档滤镜、证件识别与证件1比1打印，OCR、版面分析之后的文档还原。我的开发环境是Android Studio 北极狐，真机是华为mate 30 pro，系统是HarmonyOS 4.0.0, NDK 是21.1.6352462这个版本，可实现CPU与GPU、NPU推理，推理速度与精度可以按真机去匹配，测试的效果不输于当前市面上排APP市场靠前的几个商业应用。实现的效果如下，有书本和单开页面两种效果，运行速度可以看看下面的视频：
手机拍照扫描边缘检测效果
一、边缘检测 1.传统方法 传统的边缘检测方案的难度和局限性：
阈值参数的依赖： Canny算法的检测效果依赖于一系列阈值参数的设置，这包括高阈值和低阈值。这些阈值通常是经验值，需要通过调试和实验来确定。引入额外步骤可能导致引入新的阈值参数，使得调参更为复杂。
阈值参数数量的限制： 阈值参数的数量不能太多，因为过多的参数会增加调试的复杂性，难以准确设置。同时，过多的参数可能降低算法的鲁棒性，使其在不同场景下难以表现理想效果。
算法鲁棒性的问题： 尽管存在一系列阈值参数，最终只有一组或少数几组固定的组合。这可能导致算法在某些场景下的鲁棒性受到影响，使得在一些情况下边缘检测效果不理想。
边缘图上的数学模型复杂： Canny算法在边缘图上建立复杂的数学模型，这增加了算法的实现难度。对于某些情况，算法可能无法提供令人满意的边缘检测结果。
综合而言，Canny算法在实际应用中需要仔细调参，并且其性能可能受到特定场景的限制。在某些复杂情况下，可能需要考虑其他边缘检测方法或进一步改进以提高算法的鲁棒性。
传统的检测分割方法计算成本较低，但效果相对较差，往往难以满足我们的要求。相反，深度学习为主的端到端检测分割方法计算成本较高，通常需要GPU进行计算，但其效果卓越。目前，实际应用中基本上都采用以深度学习为主的端到端分割算法，这使得图像分割在实际落地应用中取得了显著的进展。
2.图像分割 图像分割是将一幅数字图像划分为多个组成部分（一系列像素或超像素）的过程。分割的目标是通过简化和/或变换图像，使其转换为更有意义和更易于分析的内容表示。图像分割通常用于定位图像中目标和边界（如线和曲面）的位置。更准确地说，图像分割是为图像中的每个像素分配标签，其中具有相同标签的像素具有相似的特征。在图像分割领域中有多种技术，包括基于区域的分割技术、边界检测分割技术和基于聚类的分割技术。
图像分割领域的一些经典算法：
阈值技术： 该技术的主要目的是确定图像的最佳阈值。强度值超过阈值的像素被分配为1，其余像素的强度值被分配为零，从而形成二值图。选择阈值的方法包括Otsu、k均值聚类和最大熵法。
运动与交互分割： 该技术基于图像中的运动进行分割。其思想是在假设目标是运动的情况下找出两幅图中的差异，从而确定目标位置。
边界检测： 包括多种数学方法，其目的是标记图像中亮度变化剧烈或具有不连贯性的区域中的点。边界检测通常是其他分割技术的前提步骤，因为区域边界和边之间存在很高的关联性。
区域增长方法： 建立在相邻像素具有相似像素值的假设上。该方法比较每个像素与其相邻像素，如果满足相似性标准，则像素被划分到一个或多个相邻点组成的聚类中。相似性标准的选择对结果影响很大，容易受到噪声的影响。
此外，还有其他一些未在上文中提及的图像分割方法，如双聚类方法、快速匹配法、分水岭变换法等。这些方法在不同的应用场景中具有各自的优势和适用性。
二. Enet实例分割 1. 算法简介 ENet算法旨在实现快速的语义分割，同时考虑了分割的准确性和实时性能。其基本网络结构为编码-解码结构，通过下采样实现像素级的分类和上采样实现图像目标的定位。为了提高实时性，ENet采用了一些策略来减少计算量和提高采样速度。
在下采样层，滤波器操作扩大了图片的感受野，允许网络收集更多的目标上下文信息。然而，在图像语义分割中，下采样操作有两个缺点：
空间信息的损失： 由于特征图分辨率的降低，导致了空间信息的损失。
模型尺寸和计算量增加： 对于整张图像的像素分割，需要输入和输出具有相同的分辨率，因此在进行下采样操作后同样需要上采样与之匹配，这增加了模型尺寸和计算量。
对于第一个问题，FCN算法融合不同编码层产生的特征图，但这会增加网络的参数量，不利于语义分割的实时性。对于第二个问题，SegNet算法通过在最大池化层中保存特征元素索引，在解码器中进行搜索，实现解码特征的稀疏上采样图。然而，下采样仍然会损害目标空间信息的精度。
2、ENet算法网络结构 ENet算法在设计上采用了一些关键策略，以实现高效的实时语义分割：
初始化模块设计： ENet在初始化模块中采用了一个池化操作和一个步长为2的卷积操作并行，然后将结果特征图进行合并。这种设计旨在在网络早期使用较小尺寸和较少数量的特征图，从而大大减少了网络的参数量，提高了网络的运行速度。
扩张卷积的下采样： 在下采样过程中，ENet算法使用了扩张卷积（Dilated Convolution），这有助于平衡图像分辨率和图像感受野。扩张卷积允许在不降低特征图分辨率的同时扩大图像目标的感受野，提高了对更广泛上下文信息的学习能力。
不对称的编码器-解码器结构： ENet的结构不同于对称的结构，它包含了一个大的编码器和一个小的解码器。这样的设计有助于降低ENet网络的参数量，同时保持了对输入图像的有效表示。这种不对称结构的设计是为了更好地平衡模型的复杂性和实时性能。
3. 网络实现代码 import torch.nn as nn import torch class InitialBlock(nn.Module): def __init__(self, in_channels, out_channels, bias=False, relu=True): super().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4ff984f85de6c6eca0dfeec297cbc80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/951ec8007782671d6765230ceb3020bb/" rel="bookmark">
			2015年第四届数学建模国际赛小美赛B题南极洲的平均温度解题全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2015年第四届数学建模国际赛小美赛 B题 南极洲的平均温度 原题再现： 地表平均温度是反映气候变化和全球变暖的重要指标。然而，在以前的估计中，在如何界定土地平均数方面存在一些方法上的差异。为简单起见，我们只考虑南极洲。请建立一个数学框架，用以根据气象站温度计数据定义和估计平均表面温度，并描述南极温度随时间的变化。
所需数据可从附件或公布的数据库获取，如英国南极调查局网站：https://legacy.bas.ac.uk/met/reader/.
整体求解过程概述(摘要) 为了探索南极洲的平均温度，我们分别建立了三个不同的模式。第一个模型是南极的温度分析模型。第二个模型是南极洲平均地表温度分析框架。第三个模型描述了南极温度随时间的变化。
在第一个模型中，完成数据采集任务，获得24828组数据，并进行数据预处理，获得5884组数据。同时，为了获得有效的数据，通过对站点信息的分析，定义了评价数据可用性的指标。然后分析了各因子对温度的贡献，建立了时间、纬度、经度、站压、风速、风向等因子对南极温度的多元线性回归模型。变量的系数依次为0.013、-0.509、-0.065、0.286、-0.431和0.050。模型的拟合优度为0.499。通过对第一个模型的分析，明确了各因素的作用，得到了各有效因素的贡献信息。
在第二个模型中，通过插值确定地表平均温度，建立多元非线性回归模型和BP神经网络模型。通过对温度、气压和风场数据进行插值，得到特定时间段的平均地面数据。同时，考虑到第一类模型拟合优度较低，采用多元非线性回归方法。因此，我们构造了时间的正弦周期函数，并用Levenberg-Marquardt方法对数据进行拟合。得到了时间、气压、风速和风向的线性项系数分别为0.019、0.008、-0.053和0.006的十参数函数的拟合结果。模型的拟合优度为0.626。此外，针对BP神经网络在非线性拟合方面的优越性，本文还训练了BP神经网络模型。通过对100组数据的检验，六隐层BP神经网络模型的拟合优度为0.802。
在第三个模型中，我们定义了一个非线性回归模型，利用一个5参数的正弦周期函数来获取南极温度随时间变化的信息。周期项系数为-6.283，线性关系为0.185。模型的拟合优度为0.707。分析了年平均气温随年份的变化规律，得出年平均气温的斜率为0.038。这意味着南极洲的平均气温每十年上升0.38℃。对模型进行了检验，平均绝对误差为1.527℃。
总之，南极洲的平均温度与某些因素有关。气温呈周期性变化，并随年份变化缓慢上升。
模型假设： 我们假定站点的经纬度是恒定的。
网站提供的黑色、蓝色和绿色数据均有效。
网站的红色数据无效。
问题重述： 在这个问题上，我们只需要考虑南极洲。在此基础上，提出了一个由气象站温度计数据定义和估算南极平均温度的数学框架，并描述了南极温度随时间的变化。从这个问题给我们的网站上，我们可以得到很多南极不同站点的数据，这些数据来自SCAR阅读器项目。这些数据包括20世纪中叶至21世纪初不同月份的气温、平均海平面气压（MSL压力）、气压、风速和风向。然而，我们所得到的数据仅仅反映了站点周围的温度，不能反映整个南极洲的平均温度。因此，我们采用插值法来计算平均表面温度。
模型的建立与求解整体论文缩略图 全部论文请见下方“ 只会建模 QQ名片” 点击QQ名片即可 部分程序代码：(代码和文档not free) clear; clc; data = []; %load data sheet1-44 %Observatory latitude and longitude data latitude = [67.8,90,62.5,71.5,78,77.9,62.2,80,52,66.3,68.6,63,66.7,63.4, ... 65.4,62.1,40.4,62.2,54.3,75.5,62.2,62.2,69.5,54.5,64.2,66.5,46.8, ... 62.4,67.6,77.9,66.5,67.7,70.7,70.8,63.3,60.7,67.5,74.8,68.1,77.9, ... 60.7,69,78.5,69.4]; longitude = [-67.9,0,-59.7,24.1,-38.8,-34.6,-58.9,-120,169,110.5,78, ... -60.7,140,-57,-64.4,-58.4,-9.9,-59,-36.5,-26.4,-58.6,-58.7,159.4, ... 158.9,-56.7,93,37.8,-58.9,62.9,166.7,93,45.9,-8.4,-11.8,-57.9,-44.7, ... -68.1,-136.9,-67.1,166.7,-45.6,-39.6,106.9,76.4]; height = [26,2835,5,931,50,256,16,1515,19,42,13,8,43,13,11,20,54,10,3,30, ... 4,11,304,8,198,30,24,10,16,24,30,40,50,119,10,6,16,124,4,16,6,21,3490 ,18]; %Station Pressure for the presence of 11 observation stations start year %and Temperature discrepancies (Station_Pressure night) dif_1 = [0,0,0,0,0,10,0,0,0,0,0,0,38,36,0,0,46,0,0,0,8,0,0,0,25,55,0, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/951ec8007782671d6765230ceb3020bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/456656992bfbecc39fcf6a9b4e5d5d9d/" rel="bookmark">
			python简单小游戏代码100行,python小游戏代码大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，给大家分享一下python简单小游戏代码100行，很多人还不知道这一点。下面详细解释一下。现在让我们来看看！
download: python小游戏代码
1、python 编写一个彩票游戏？ 按照题目要求编写燃悔中的Python程序如下
import random
numlist=random.sample(range(0,10),5)
while numlist[0]==0:
numlist=random.sample(range(0,10),5)
num=int(''.join([str(i) for i in numlist]))
inputnum=int(input("输入号："))
bonus=0
count=0
if inputnum==num:
bonus=10000
else:
for i in set(str(inputnum)):
if int(i) in numlist:
count+=1
bonus=1000*count
print("彩票号：%d" % num)
print("奖皮山金：前唤%d元" % bonus)
(注意源代码的缩进)
2、请用PYTHON编一个小游戏，如五子棋，连连看，贪吃蛇，扫雷，计算器等等 按照题目要求编写燃悔中的Python程序如下
import random
numlist=random.sample(range(0,10),5)
while numlist[0]==0:
numlist=random.sample(range(0,10),5)
num=int(''.join([str(i) for i in numlist]))
inputnum=int(input("输入号："))
bonus=0
count=0
if inputnum==num:
bonus=10000
else:
for i in set(str(inputnum)):
if int(i) in numlist:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/456656992bfbecc39fcf6a9b4e5d5d9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84529bf5dcd4a599b2a9159e30482865/" rel="bookmark">
			牛客周赛(Round 25)题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目A链接
题解:定义long long类型变量，遍历一遍出结果
#include&lt;stdio.h&gt; int main(){ int n; scanf("%d",&amp;n); long long a[1001]; for(int i=0;i&lt;n;i++) scanf("%lld",&amp;a[i]); char s[n]; scanf(" %s",&amp;s); long long ans=0; for(int i=0;i&lt;n;i++){ if(s[i]=='F'){ if(a[i]/100&gt;5) ans+=a[i]/100; else ans+=5; }else{ ans+=a[i]; } } printf("%lld",ans); } 题解: 求两个最大乘积之和，优先使乘积最大，而不是和最大，将两个乘积其中之一最大，另一个最小就行。定义long long类型变量，遍历一遍出结果，每次循环乘积都取余一次，最后和取余一次，防止溢出。
#include&lt;stdio.h&gt; int a[100000]; int b[100000]; long long yu=1000000007; int main(){ int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); for(int i=0;i&lt;n;i++) scanf("%d",&amp;b[i]); long long ans1=1,ans2=1; for(int i=0;i&lt;n;i++){ if(a[i]&lt;b[i]){ ans1*=b[i]; ans2*=a[i]; }else{ ans1*=a[i]; ans2*=b[i]; } ans1%=yu; ans2%=yu; } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84529bf5dcd4a599b2a9159e30482865/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1064b6521407ebe1463364e16ea13e6/" rel="bookmark">
			three.js使用精灵模型Sprite渲染森林
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果： 源码：
&lt;template&gt; &lt;div&gt; &lt;el-container&gt; &lt;el-main&gt; &lt;div class="box-card-left"&gt; &lt;div id="threejs" style="border: 1px solid red"&gt;&lt;/div&gt; &lt;div class="box-right"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 引入轨道控制器扩展库OrbitControls.js import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js"; import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js"; export default { data() { return { name: "", scene: null, camera: null, renderer: null, mesh: null, geometry: null, group: null, material: null, texture: null, }; }, created() {}, mounted() { this.name = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1064b6521407ebe1463364e16ea13e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8993810bb922d3180ecefbf5e3aaab06/" rel="bookmark">
			Isaac Sim 仿真机器人urdf文件导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程展示如何在 Omniverse Isaac Sim 中导入 urdf
一. 使用内置插件导入urdf 安装urdf 插件 方法是转到“window”-&gt;“Extensions”
搜索框中输入urdf, 并启用
通过转至Isaac Utils -&gt; Workflows -&gt; URDF Importer菜单来访问 urdf 扩展。 表格中的 1,2,3 对应着上图中的1,2,3 位置说明
导入选项 Merge Fixed Joins-合并固定关节：合并由固定关节连接的链接，以便关节仅应用于移动的关节。合并的框架仍将显示为它们合并到的父框架的子框架。
Replace Cylinders with Capsules-固定底座链接：选中后，机器人的底座将固定在世界坐标中的位置。
Fix base link-导入惯量张量：直接从 urdf 检查负载惯量。如果 urdf 未指定惯性张量，则将使用恒等式并按比例因子进行缩放。如果未选中，Physx 将自动计算。非对角惯性矩阵分量将用于计算主轴表示以及对角线。
Stage Units Per Meter- 每米舞台单位：Omniverse Kit 默认长度单位是厘米。您可以在此处设置比例因子以匹配 URDF 中使用的单位。目前，URDF 导入器仅支持统一的全局缩放。scale在未来的版本中将可以对不同的轴和特定的网格部分应用不同的缩放（即使用URDF 网格标签下的参数）。如果您scale的 URDF 中有一个参数，您可能需要手动调整 URDF 中的其他值，以便所有参数都采用相同的单位。
Link Density 链接密度：如果链接没有给定质量，则使用此密度（以 Kg/m^3 为单位）根据链接体积计算质量。值 0.0 也可用于告诉物理引擎自动计算密度。
Joint Drive Type-关节驱动类型：默认关节驱动类型，值可以是None、Position和Velocity。
Joint Drivre Strenght-关节驱动强度：驱动强度是位置驱动的关节刚度，或速度驱动关节的阻尼。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8993810bb922d3180ecefbf5e3aaab06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c9d6bbb1eb781903682724c377c73f/" rel="bookmark">
			【leetcode100-020】【矩阵】旋转图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题干】
给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
【思路】
怎么还整上小学奥数题了（不是对角翻转+水平/垂直翻转的方法太不general了，浅写一下，没什么思路好讲的。来想想真的在旋转的方式：看到原地的要求，感觉以行列为单位旋转不太合适，写了一下果然非常丑，大量的重复点位和区间改变；嗯？重复点位？按点来好像就不重复了；把原矩阵分成四块，每四个对应点位转一圈，坐标转换belike： temp=matrix[row][col]
matrix[row][col]=matrix[n−col−1][row]
matrix[n−col−1][row]=matrix[n−row−1][n−col−1]
matrix[n−row−1][n−col−1]=matrix[col][n−row−1]
matrix[col][n−row−1]=temp
分块示意懒得画了看看官解的图吧。 【题解】
翻转：
class Solution { public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); // 水平翻转 for (int i = 0; i &lt; n / 2; ++i) { for (int j = 0; j &lt; n; ++j) { swap(matrix[i][j], matrix[n - i - 1][j]); } } // 主对角线翻转 for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; i; ++j) { swap(matrix[i][j], matrix[j][i]); } } } }; 分块旋转：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c9d6bbb1eb781903682724c377c73f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1115124b6a3cc067af22225f683f47d2/" rel="bookmark">
			分布式信号量（Redis）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是信号量 信号量，由并发编程领域的先锋人物Edsger Wybe Dijkstra提出的一种解决同步不同执行线程的方法。
信号量（英语：semaphore）又称为信号标，是一个同步对象，用于保持在0至指定最大值之间的一个计数值。当线程完成一次对该semaphore对象的等待（wait）时，该计数值减一；当线程完成一次对semaphore对象的释放（release）时，计数值加一。当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态。semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态。
简单理解，如果我们把工作区理解为一座房子，那信号量就是房子的入场券，券的数目是固定的，所有需要进入房子的人都需要拿到券，离开房子时需要返还券，未能拿到券的人可以选择等待或者直接离开。由于券是固定的，保证同时进入房子的人最多就是券的个数。当券的个数限制为1时，那么这个信号量就是互斥锁。
在单机场景下，进程内的信号量可以满足生产需求，但是在分布式场景下，面对多进程间的协同工作机制，可能就需要构建分布式的信号量来满足需求了。
因为涉及到多节点之间的协同工作，必须要一个可靠的中间件作为协调中心调度这一切。Redis拥有极快的响应速度和强大的数据结构，很适合作为这个调度中心。
实现思路 思路1：利用列表实现
获取、释放和计数机制 实现信号量的第一步就是需要有获取、释放以及计数的机制，考虑到这些特点，首先想到的就是列表这一数据结构。我们可以构建一个列表，保持列表的长度不变，作为信号量的大小。具体操作有：
初始化：初始化信号量时需要初始化列表，并往其中放入信号量大小的数据。为保证原子性，只能由一个客户端写入，其他客户端直接返回（可以用SETNX保证，PS：其他客户端返回进行获取信号量操作时，可能此时列表并未设置成功，可能导致数据的不一致，可能需要分布式阻塞锁等方式阻塞其他客户端以保证一致性）；获取：Redis的LPOP/RPOP天然匹配信号量的tryAcquire，而BLPOP/BRPOP正好对应阻塞获取；释放：自然是将列表中的数据PUSH回去；计数：列表的数目表示信号量的大小。 信号量的过期机制
为了防止因客户端崩溃导致信号量无法释放问题，我们需要记录每个获取到信号量的客户端获取的时间，并当那些超过过期时间的客户端释放，即将其PUSH回列表。但是需要考虑的是，和初始化操作相同，此时应该保证只有一个客户端在做这件事。
记录客户端获取时间，可以直接使用redis的基本的字符串数据结构即可。 思路2：利用有序集合实现
获取、释放和计数机制 我们构建一个有序集合，这个有序集合的member即为各个客户端的身份信息，其score即为获取的时间，这样我们可以根据获取时间的先后排序，只有排名比信号量大小要小的客户端被允许拿到信号量，这样即可实现。具体操作有：
初始化：不需要对redis服务端做任何操作，只需要返回各自客户端需要初始化的一些参数；获取：首先向有序集合中添加一个member，若能获取到信号量，则返回成功；若获取不到，对于非阻塞获取，直接返回失败即可；对于阻塞获取，我们可以使用BRPOP实现阻塞等待；释放：需要删除有序集合中的member；当然还应该对等待列表中pPUSH一个值以使得等待列表能够尝试继续获取信号量；计数：有序集合天然支持排序。 信号量的过期制度
如果有序集合的score对应的即是获取的时间，那么每次获取信号量之前去除一下超时的客户端。 方案对比
以上叙述了两种实现信号量的简易方案，可以简单比较如下：
初始化：利用列表实现的信号量初始化时需要初始化服务端，且为了保证数据一致性，需要保证：只有一个客户端在初始化，且最好其他客户端等待此客户端初始化完全后才能工作（可能需要分布式锁实现）；而利用有序集合实现的客户端则不需要；保证信号量大小不变：利用列表实现时，由各个客户端保证信号量大小，不管是过期信号量的回收还是正常释放，都是由客户端将列表元素PUSH回去，虽然分布式锁等机制能够保证安全，但是依然存在风险以及性能损耗；而有序集合实现时，由服务端保证数据的一致性，客户端唯一需要做的就是比较获取到的分数是否符合要求。 综上所述，我们采取有序集合的方式实现分布式的信号量。
方案和代码实现（Golang） 在上述思路的前提下，我们可能还需要做到以下几点。
公平的计数方式
虽然上述思路中选择将各个客户端的时间信息作为score，但是考虑到各个主机的系统时间的差异，所以以时间戳作为score可能并不是很公平。
考虑到此，我们在redis服务端维护一个自增的计数变量，每次发出请求需要对其自增，并以获取到的自增值作为score传入有序集合中。
考虑到并发，假设目前信号量池中只有一个信号量，若客户端A首先获取了自增量，客户端B随后获取了自增量，按照道理此时应该是客户端A获取到信号量，但是假如客户端B比客户端A早加入有序集合，那么此时客户端B将拿到信号量，因为其自增量属于第一位，其后客户端A再加入有序集合，也将获取到信号量，因为其score比B还小，这将导致拿到信号量的客户端多于信号量大小。所以我们必须保证获取自增量和加入有序集合是一个原子操作，这里，我们可以用lua脚本实现。
代码实现如下，其中r.ownerKey表示有序集合，r.incrKey表示自增量，r.identifyId()表示客户端的唯一标识，我们使用hostname-pid-goroutineId作为唯一标识，r.permit表示信号量大小。
var acquireScript = redis.NewScript(` local cnt = redis.call("INCR", KEYS[2]) redis.call("ZADD", KEYS[1], cnt, ARGV[1]) print(ARGV[4]) local res = redis.call("ZRANK", KEYS[1], ARGV[1]) if res &gt;= tonumber(ARGV[2]) then return 0 else return 1 end `) func (r *RedisSem) TryAcquire() bool { keys := []string{r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1115124b6a3cc067af22225f683f47d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97160aa9e909b9b8bde6462cdb2ab6c1/" rel="bookmark">
			vue3实现打字机的效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： vue3项目中实现打字机的效果。 实现效果： 实现步骤： 1、安装插件 npm i vue3typed 2、main.js中配置 import vuetyped from 'vue3typed' const app = createApp(App) // 挂载打字机的全局方法 app.use(vuetyped) 3、界面使用 &lt;vuetyped :showCursor="false" :smart-backspace="false" :strings="writeTextArr" :type-speed="15"&gt; &lt;div class="typing" /&gt; &lt;/vuetyped&gt; &lt;script setup&gt; const writeTextArr = ref([ "张庚生于1911年，生长在中国旧戏改良、新剧登场这个充满博弈的文化环境中，其思想中既有中国传统戏曲影响下的中国美学理想,又有中国人睁眼看世界的民族视野，并贯穿其研究事业的始终。", ]); &lt;/script&gt; 4、api文档 。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac4bdeadad77cdf3c1b2857671962d8/" rel="bookmark">
			生产问题（十三）谷歌Protobuf误修改系统全局时区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 最近其他组出了个线上问题，导致用户的时间出现问题，影响用户出行，后来才发现是谷歌的Protobuf会更改系统全局时区。不过有一说一，感觉jdk的问题更大。
Protobuf（Protocol Buffers）是一种轻量级的数据序列化格式，由Google开发。它可以用于将结构化数据序列化为二进制格式，以便在不同的系统之间进行数据交换和存储。Protobuf具有高效、紧凑和可扩展的特点，可以在多种编程语言中使用。它通常用于网络通信、数据存储和配置文件等方面。
二、时区结构 一开始这个问题看的作者非常迷惑，因为报告写的是修改了机器时区，什么意思？调用了操作系统对应时区的api？不可能吧，这种代码在哪里都不会给他用的，review要被喷死，再看看。
哦，原来是jvm时区的TimeZone里面的全局变量被改了。这个不能叫做机器时区，就是个全局的时区变量。
在看问题之前先要看看时区的结构，不然不了解全局的时区变量在哪里。
1. TimeZone（时区）：TimeZone 类用于表示不同地区的时区信息。它提供了获取和设置时区偏移量、获取时区名称等方法。通过 TimeZone 类，你可以将日期和时间转换为特定时区的表示形式。
2. Calendar（日历）：Calendar 类是一个抽象类，用于处理日期和时间的计算和操作。它提供了获取和设置年、月、日、时、分、秒等日期和时间字段的方法。Calendar 类还提供了一些方便的方法，如计算两个日期之间的差异等。通过 Calendar 类，你可以执行日期和时间的各种操作。
3. GregorianCalendar（公历）：GregorianCalendar 类是 Calendar 类的一个具体实现，用于处理公历日期和时间。它继承了 Calendar 类的功能，并提供了更多的方法和功能。GregorianCalendar 类支持闰年、月份天数等公历特性。
一旦使用 TimeZone 类初始化了一个时区对象，该时区对象的偏移量和其他属性是固定的，不会随着时间的推移而变化。时区对象的属性在初始化时被确定，并且不会自动更新。
不过时区对象的属性可以通过调用 TimeZone 类的方法来进行更改。例如setRawOffset() 方法来更改时区的原始偏移量，或者通过 setDSTSavings() 方法来更改夏令时的偏移量。
三、分析-构造函数 这其实是错误的方向，想直接看Protobuf问题的可以直接跳到第四章，不过作者认为错误的方向也是有必要的，因为不管是一时的还是长期的错误方向，既然它能使经验丰富的开发人员产生错误的想法，他就一定是有价值的。
就像很多学校研究，其实不一定能研究出什么对的，但是可以排除很多的错误的方向，并且在很多方面为别人提供避雷指引。
出问题的代码
public sType() { this.sDate = new GregorianCalendar(1，0，1，0，0，0)； this.sDate.setTimeZone(ZoneInfo.getTimeZone("UTC")); } 这是框架生成的一个构造方法，相对于在不为空的情况下给你时间一个默认值，默认值是0时区。
按道理说这样只是一个局部变量，为什么会对TimeZone的全局变量造成影响呢？只能说明在这段代码里面，把一个局部变量和全局变量做了关联，使用同一个引用，然后局部变量被修改，映射到了全局变量上面。
这里拿到timezone的全局变量
全局变量传递
这时候Calendar的局部变量与TimeZone的全局变量同一个引用
这里传入了TimeZone的全局变量，然后给到了Calendar那个局部变量
第二行setTimeZone把Calendar的局部变量改为0时区，但是这时候TimeZone的全局变量和Calendar局部变量引用相同，全局变量也被修改
这里会把局部变量的引用直接换成入参
TimeZone的这个全局变量和局部变量绑定了，所以改局部变量就会改全局变量
有的同学看着这个应该就会有想法了，因为引用关联是会有影响，但是需要修改引用的值。直接替换引用对于第一个全局变量是不产生影响的
四、分析-Protobuf 需要先写个demo，结合目前的情况，是因为类里面有个GregorianCalendar类型的字段，然后这个类被Protobuf序列化存到redis，又在其他时候被反序列化拿出来用。那么demo就很清晰了：
private static final DefaultIdStrategy ID_STRATEGY = ((DefaultIdStrategy)RuntimeEnv.ID_STRATEGY); private static &lt;T&gt; byte[] serialPojoByClass(T value) { byte[] result = null; Class&lt;T&gt; clazz = (Class&lt;T&gt;)value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac4bdeadad77cdf3c1b2857671962d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd862e2b2c9034f9267ede326c4b06c4/" rel="bookmark">
			基于多反应堆的高并发服务器【C/C&#43;&#43;/Reactor】（中）Dispatcher模块的实现思路和定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（四）Dispatcher模块的实现思路
关于dispatcher，它应该是反应堆模型里边的核心组成部分，因为如果说这个反应堆模型里边有事件需要处理，或者说有事件需要检测，那么是需要通过这个poll、epoll 或者 select来完成的。dispatcher有三个组成部分，它们并不是互相依存的，而是互斥的。就是我们在选择的时候，只能任选其一。不管使用哪一个，都可以往这个模型里边添加一个新的待检测事件，或者说把一个已经检测的事件从这个检测模型里边删掉。还有一种情况，就是把一个已经被检测得到文件描述符它的事件进行修改，比如原来是读事件，现在改成读写。也就是说这三种处理方式，每一种处理方式它们都对应一套处理函数，它们都对应一套处理函数。需要解决的问题：如果我们在程序中使用后，在调用这些接口的时候，是不是需要做一个判断？就是在程序中判断
if(使用的模型是poll){ 调用处理方式 } else if(使用的模型是epoll){ 调用处理方式 } else if(使用的模型是select){ 调用处理方式 } 因为这三种处理方式对应的是一套函数，所以在调用添加函数的时候需要做这样的一个的判断；在做删除的时候也需要做这样的一个判断，在做修改操作的时候，也需要做这样的判断。也就意味着咱们编写的程序是非常的冗余。
if() { ... } else if() { ... } else if() { ... } 怎么去精简呢？有没有一种解决方案可以让代码写起来非常精简呢？
对应的解决方案就是使用回调函数 Dispatcher提供了一系列的接口：
init():做数据初始化add():添加一个事件节点remove():删除一个事件节点modify():修改一个事件节点 dispatch():用于事件检测的，对于poll来说，就是调用poll函数，对于epoll来说，就是调用epoll_wait函数，对于select来说，就是调用select函数。通过调用dispatch函数就能够知道检测的这一系列的文件描述符集合里边到底是哪一个文件描述符它所对应的事件被触发了，找到了这个被触发事件的文件描述符，就需要基于它的事件去调用文件描述符注册好的读函数或者是写函数了。
clear():内存释放。第一部分：对文件描述符的关闭，第二部分：对申请的堆内存的释放。可以把Dispatcher设计成是一个结构体，里边有六个成员，类型都是函数指针。函数指针指向的是函数的地址，它指向了这个函数的地址之后，就可以对地址对应的函数进行调用了。首先保存一个函数的地址，然后在适当的时机去调用这个地址对应的函数。因为函数名就是地址。
假设说我们把这个函数指针已经做了初始化，什么时候进行调用呢？比如说客户端和服务器新建立了连接，那么就得到了一个用于通信的文件描述符。得到了通信的文件描述符，就需要调用add方法。这个add方法它是一个函数指针，它肯定指向一个对应的处理函数，那么这个任务函数动作是什么我就执行对应的那个动作。假设说某一个通信的文件描述符客户端断开了连接，那么就需要把这个文件描述符从检测的模型上删除（poll、epoll、select），remove也是一个函数指针，指向一个实际的函数，只要能够找到这个函数，就可以调用这个函数，把对应的文件描述符从检测的模型上删除。 关于poll，也是一样的，分别是pollInit,pollAdd,pollDelete,pollModify,pollDispatch,pollClear。这些函数它们还是函数指针吗？就不是了吧，这是实实在在的函数，但是这个函数的函数原型也就是它的返回值以及参数。需要和上边dispatch这个模型，里边定义的函数，指针的类型是相同的，这样的话，才能够让这个指针指向这个函数的地址。也就说，下边这一系列函数主要是给谁呢？给上边的这个dispatch结构体里边的函数指针进行实例化的，就是做初始化的。关于epoll，也是一样的，分别是epollInit,epollAdd,epollDelete,epollModify,epollDispatch,epollClear。select呢，也一样的，只不过是前缀不一样 当把下边的这三个模型里边的函数分别实现了之后，就看用户的选择了。
如果用户选择epoll，那么我们就使用epoll的这组函数去给上面的函数指针进行初始化。如果用户选择select，那么就用这组函数的地址去给这个函数值呢？进行初始化、如果用户选择poll，那么就用这组函数的函数名或者是函数地址 其实都是一样的。给上面的函数指针做初始化。初始化好了之后，在上层调用的时候，只需要使用dispatch这个结构体里边的这些函数指针的名字，就可以对下边这些已经实现了的函数进行调用了。处理思路说明白之后，再来看一个细节。对于poll这个模型来说，如果他要处理一系列的文件描述符， 前提条件是需要先把它们存储起来，要存储到一个结构体里边。在调用poll函数的时候，需要用到一个结构体类型
#include &lt;poll.h&gt; int poll(struct pollfd *fds, nfds_t nfds, int timeout); struct pollfd { int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */ }; fds是struct pollfd类型，这个参数是一个传入传出参数。在调用这个函数之前，需要先把结构体定义出来，然后对结构体进行初始化，告诉他我要检测的文件描述符的值是什么，以及要检测这个文件描述符的什么事件。当我们通过poll函数委托内核去检测这一系列的文件描述符集合的时候，内核检测到了某些文件，描述符对应的这个事件被触发了。那么，它就会把这个事件写入到revents里边。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd862e2b2c9034f9267ede326c4b06c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5fff1988c3c17027669294dc8d29b5/" rel="bookmark">
			计算机视觉基础（13）——深度估计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本节是计算机视觉的最后一节，我们将学习深度估计。从深度的概念和度量入手，依次学习单目深度估计和双目/多目深度估计，需要知道深度估计的经典方法，掌握深度估计的评价标准，注意结合对极几何进行分析和思考。
一、深度的概念和度量方式 1.1 深度的概念 深度指场景中物体表面到相机的距离，即图中𝑷 (𝑐)点的𝑍 (𝑐)坐标 采用深度图(Depth Map)表征，图中每点的取值代表对应像素的深度值 1.2 深度的度量方式与设备 1.2.1 结构光 结构光：将特殊结构图案（如离散光斑、条纹、编码结构光等）投影到空间物体表面上，用另一个相机观察在三维物理表面成像的畸变情况，进行图像匹配比较并计算出深度 属于主动光探测方案 技术成熟、便携、低延时，适用于较近距离 1.2.2 ToF Time-of-Flight (ToF)：向目标连续发送光脉冲，用传感器接收从物体返回的光，通过探测光脉冲的往返飞行时间测距 属于主动光探测方案 适用于较远距离，传感器复杂、成本高、深度图稀疏 1.2.3 双目视觉 双目视觉技术:利用两个标定好的RGB摄像头采集图像，通过匹配对应点，获取的二维图像像素点的深度 属于被动光探测方案 精度依赖于双目匹配算法，易受到光照变化等因素影响，适用于较近距离但是，遇到重复纹理、⽆边缘特征时，识别的效果就会很差 二、计算机视觉中的深度估计问题 深度估计：设计计算机视觉算法，根据输入图像，估计出对应的深度图。
根据输入图像的数目分为单目深度估计(Monocular)、双目深度估计(Binocular)、多视角立体视觉 (Multi-View Stereo, MVS)。
与基于传感器硬件的解决方案相比，软件算法的深度估计方案成本较低
三、深度估计的应用 3.1 自动驾驶、机器人导航 3.2 3D重构(三维建模、三维地图、3D打印) 3.3 增强现实 3.4 单目3D拍照 3.5 浅景深渲染 3.6 RGB-D 语义分割/目标检测/视觉跟踪 将深度作为额外的辅助信息应用在传统视觉任务中RGB-D：RGB-D 语义分割/目标检测/视觉跟踪
四、单目深度估计 4.1 单目深度估计的概念 • 目标：利用能够反映深度的线索/提示信息(Cues)，从单幅图像中预测出对应的深度图 • 对弱纹理等挑战区域具有更强的鲁棒性 • 单目深度估计本身具有较强挑战性
4.2 单目深度线索 4.2.1 近大远小 近大远小：对常见物体的尺寸有大致的估计，根据其在图像中的大小，判断相对位置/距离
4.2.2 纹理的丰富程度 纹理丰富程度：近距离的区域更为清晰，纹理也较为丰富。
4.2.3 遮挡关系 遮挡关系：被遮挡的背景物体距离较远，前景距离较近 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b5fff1988c3c17027669294dc8d29b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd84847ae8403df55db2eac9125e1487/" rel="bookmark">
			hive高级查询（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-- 分组查询
SELECT sex,SUM(mark) sum_mark
FROM score
GROUP BY sex
HAVING sum_mark &gt; 555;
SELECT sex,sum_mark
FROM(
SELECT sex,SUM(mark) sum_mark
FROM score
GROUP BY sex
) t
WHERE sum_mark &gt; 555;
SELECT AVG(gid),SUM(gid)/COUNT(gid) FROM student;
SELECT COUNT(gid),COUNT(DISTINCT gid) FROM student;
SELECT collect_list(gid),collect_set(gid) FROM student;
+------------+--------+--+
| _c0 | _c1 |
+------------+--------+--+
| [1,1,2,2] | [1,2] |
+------------+--------+--+
SELECT collect_list(gid),collect_list(DISTINCT gid) FROM student;结果同上
-- 窗口排名函数
SELECT *,
ROW_NUMBER() OVER(ORDER BY id) rn
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd84847ae8403df55db2eac9125e1487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/549c9f26ca61650ed9be842502842af3/" rel="bookmark">
			Linux——计算机网络基础概论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、网络基本概念 1、定义 网络是由若干结点和连接这些结点的链路组成，网络中的结点可以是计算机，交换机、 路由器等设备。
网络设备有：交换机、路由器、集线器传输介质有：双绞线、同轴电缆、光纤连接网络的目的：资源共享。 2、简单的网络示意图 3、IP地址
（1）定义
IP 地址就是给因特网上的每一个主机（或路由器）的每一个接口分配的一个在全世界 范围内唯一的标识符。
（2）分类
IP 地址有分 IPV4 和 IPV6 两种类别格式。
①IPV4 是类似”A.B.C.D”的格式，它是 32 位 的，用“.”分成四个段，每个段是 8 个位（值为 0-255），用 10 进制表示。
②IPV6 地址是 128 位，格式类似”XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX”，用“:“分成 8 个 段，每个段 16 个位，用 4 个 16 进制数表示。
IPV4 地址示例: “192.168.31.1” IPV6 地址示例：“2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b“ 接下来描述的 IP 地址默认都指的是 IPV4 的地址。为了便于寻址，了解目标主机的位 置，每个 IP 地址由网络号和主机号两个部分构成。
同一个物理网络上所有的主机都使用同 一个网络号，只是主机号不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19dfcb4991e4cd408c8996f3ad6bfd9/" rel="bookmark">
			计算机视觉基础（12）——图像恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们将学习图像恢复相关知识。主要有图像恢复的定义、评价标准和实现图像恢复的方法。图像恢复任务包括图像去噪、去模糊、图像超分辨率、图像修复等；评价标准有峰值信噪比和结构相似性；图像超分辨的方法有传统方法和基于深度学习的方法：传统方法包括了基于插值的方法和基于字典学习，而深度学习方法有很多，包括SRCNN，VDSR等。
一、图像恢复的定义 1.1 图像恢复的意义 由于环境的⼲扰（速度过快、天⽓原因、识别噪声等）导致的图像退化：
图像恢复与图像分割区别在于：图像分割是提取⾼级特征；而图像恢复的意义是做图像的理解。
1.2 图像恢复任务的定义 1.2.1 通用的简单退化模型 1.2.2 图像去噪 加性噪声有：
拍摄噪声(shot noise)：服从泊松分布 读取噪声(read noise)：服从高斯分布 暗电流噪声(Dark noise)：和器件本身有关 注意区分图像去噪与图像去模糊的区别：前者使⽤滤波，后者是叠加
1.2.3 图像去模糊 1.2.4 图像超分辨率 这部分内容将在本人第三部分进行详细阐述。
1.2.5 图像修复 1.2.6 图像分离 1.2.7 病态问题 二、图像恢复的评价标准 常用评价标准有峰值信噪比（PSNR）和结构相似性（SSIM），注意区分二者的优缺点：
三、图像超分辨率 3.1 图像超分辨率任务的定义 从低分辨率图像恢复原始的高分辨率图像： 产生逼真的、有细节的图像——内容、细节真实性忠实于低分辨率图像的内容——内容匹配性 3.2 传统图像超分辨率方法 3.1.1 基于插值的方法 3.1.2 基于字典学习 基于一对互相对应的外部字典，分别对应高清图像空间和低清图像空间 3.3 基于深度学习的图像超分辨率方法 3.3.1 SRCNN &amp; VDSR 3.3.2 ESPCN &amp; SRResNet 3.3.3 Perceptual loss 3.3.4 Texture matching loss 3.3.5 SRGAN 3.3.6 SFTGAN 3.4 数据集采集 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19dfcb4991e4cd408c8996f3ad6bfd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e76d85b47d11ca9d49489b2bc04c28c/" rel="bookmark">
			卷积神经网络基础与补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考自 up主的b站链接：霹雳吧啦Wz的个人空间-霹雳吧啦Wz个人主页-哔哩哔哩视频这位大佬的博客 https://blog.csdn.net/m0_37867091?type=blog CNN的历史发展：
这一点老师上课的时候也有讲到，BP的出现对CNN的发展至关重要
卷积的特性：关于具体体现在哪，上课老师的ppt讲的非常的明白
目的：进行特征提取，减少训练过程中需要的参数数量
下面这种图也是非常的好，对于理解卷积的过程有很好的理解
需要注意的是：
1.卷积核的chanel和输入矩阵的阿chanel是一致的
2.根据卷积的过程也可以知道最后输出矩阵的chanel是卷积核的个数
反向传播中误差的计算：softmax/sigmoid
一般是用 交叉熵损失 （Cross Entropy Loss）来计算误差
权重的更新 常用优化器：SGD优化器（Stochastic Gradient Descent 随机梯度下降）
缺点：1. 易受样本噪声影响；2. 可能陷入局部最优解 改进：SGD+Momentum优化器 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/24/">«</a>
	<span class="pagination__item pagination__item--current">25/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/26/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>