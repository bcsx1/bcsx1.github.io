<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a029531e0951a67a8c9dcceb84eb65/" rel="bookmark">
			Deepfacelab实现视频换脸——使用体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为在哔哩哔哩看到很多运用Ai换脸获得大量播放量的视频，于是自己也想尝试一下。
软件：Deepfacelab 一款由国外大佬开发的便于普通人使用的半可视化换脸软件，大概的流程就是：
将data_dst(目标视频，要被换脸的)和data_src(源视频，提供人脸素材的)分解成帧画面；对两份帧画面素材进行人脸提取；用模型对素材进行训练，这一步是最花费时间的；将训练好的人脸合成到目标帧画面上；将合成的帧画面合成视频。 使用方法 图片展示 使用流程 workspace是用来存放素材的，将目标视频(data_dst)和源视频(data_src)放在workspace目录下所有bat文件点击即可运行，一些参数需要自行设置。1是用来清空workspace，基本用不到。跟手动删除差不多。2是将data_src分解成帧，存放在workspace/data_src目录下。3是将data_dst分解成帧，存放在workspace/data_dst目录下。2、3运行结束之后，运行4) data_src extract faces S3FD best GPU.bat即可提取源视频的人脸。之后运行4.2.2) data_src sort by similar histogram.bat来对人脸进行相似分类排序。因为我们需要进入workspace/data_src/aligned目录下对不清晰、有遮挡的人脸进行删除。运行5) data_dst extract faces S3FD best GPU.bat和5.2) data_dst sort by similar histogram.bat来对data_dst进行和上面两步一样的操作，对workspace/data_dst/aligned目录下图片进行筛选时，能看清脸的尽量不要删除，否则会造成跳帧，只需要删除非目标人脸或者完全看不清的，颠倒的。这时候就到了最费事费电脑的一步了，就是训练模型。序号6共有8个模型可供选择。H64是最轻巧的，对硬件要求最低的，效果也是最差的。SAEHD是对硬件要求最高的，效果也是最好的，训练也是最慢的。具体可查看百度或者文末提供的一些网站。训练好之后就是合成，将训练好的人脸合成到目标人脸上，6用的是什么模型，7就用哪个来合成，具体参数也可看文末网站。最后运行8) converted to mp4.bat即可生成视频。 项目地址 作者项目地址 https://github.com/iperov/DeepFaceLab
适合会编程，配置python环境的人使用 可视化项目 https://pan.baidu.com/s/1Vcj6xSNvtaLuRzcjyRqz7w
提取码: sk1k
为截图所示的版本 云上版本 https://github.com/chervonij/DFL-Colab
谷歌colab版本，云端运行 参考网址 https://www.deepfacelabs.com/https://www.deepfaker.xyz/https://www.bilibili.com/read/cv5106662?from=search 来自博客：https://www.ndmiao.cn/index.php/archives/113/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267ee47b2ffbf41dc80725be8ddb1a29/" rel="bookmark">
			转载：bolt cms V3.7.0 xss和远程代码执行漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：bolt cms V3.7.0 xss和远程代码执行漏洞 漏洞环境搭建漏洞分析XSS成因分析远程代码执行成因分析 漏洞测试xss远程代码执行 影响版本防御方案 漏洞环境搭建 github上下载对应版本，这里下载3.7.0.
https://github.com/bolt/bolt/releases 解压后需要重命名以下文件：
mv .bolt.yml.dist .bolt.yml mv composer.json.dist composer.json mv composer.lock.dist composer.lock mv src/Site/CustomisationExtension.php.dist src/Site/CustomisationExtension.php 为了快速搭建这里使用phpstudy，开启apache和mysql
点击网站，创建站点，选择好php版本并创建数据库，记住域名、数据库名称、用户名和密码
配置数据库app/config/config.yml。填好数据库名称、用户名和密码然后保存
然后浏览器访问http://上面自己设置的域名/public即可到安装页面，第一次需要设置管理员账号和密码
http://上面自己设置的域名/public http://上面自己设置的域名/public/bolt # 管理地址 漏洞分析 XSS成因分析 该漏洞存在于vendor/bolt/bolt/src/Controller/Backend/Users.php。有两个变量 u s e r 和 user和 user和userEntity用于存储和使用以显示此代码中的用户数据。 u s e r E n t i t y 在 传 递 给 userEntity在传递给 userEntity在传递给form-&gt;isValid（），这表明 u s e r 有 未 编 码 的 输 入 和 user有未编码的输入和 user有未编码的输入和userEntity是具有编码的输入。也就是说使用 u s e r 未 对 用 户 输 入 编 码 ， 使 用 user未对用户输入编码，使用 user未对用户输入编码，使用userEntity可以对用户输入编码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/267ee47b2ffbf41dc80725be8ddb1a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b455ae36a6981a2565613c4e9bd36d/" rel="bookmark">
			markdown中图片左对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		markdown中图片实现左对齐 左对齐在图片前面输入空格即可。
右对齐需要使用css样式、
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f018dba9a09aa9dae069d2447bca986b/" rel="bookmark">
			NoSQL之SpringBoot整合Neo4j
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. Spring Boot中整合Neo4j 我们上一章节简单介绍了Neo4j及其安装配置过程，这节带大家学习在Spring Boot中整合Neo4j.
1. 创建web项目 我们按照之前的经验，创建一个web程序，并将之改造成Spring Boot项目，具体过程略。
2. 添加依赖包 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-neo4j&lt;/artifactId&gt; &lt;/dependency&gt; 3. 创建配置文件 #neo4j spring: data: neo4j: uri: bolt://localhost:7474 username: neo4j password: neo4j 4. 创建Neo4j的配置类 注解@EnableNeo4jRepositories用来开启Neo4j的仓库功能；
注解@EnableTransactionManagement用来支持事务。
package com.yyg.boot.config; import org.neo4j.driver.AuthTokens; import org.neo4j.driver.Driver; import org.neo4j.driver.GraphDatabase; import org.neo4j.driver.Session; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.neo4j.repository.config.EnableNeo4jRepositories; import org.springframework.transaction.annotation.EnableTransactionManagement; /** * @Author 一一哥Sun * @Date Created in 2020/4/10 * @Description Description */ @Configuration @EnableNeo4jRepositories(basePackages = "com.yyg.boot.repository") @EnableTransactionManagement public class Neo4jConfig { @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f018dba9a09aa9dae069d2447bca986b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5ef890c6a199e45525f35f66be145c/" rel="bookmark">
			Vue 调用录音以及录音上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		h5调用调用手机麦克风实现科大讯飞语音转写服务 1）安装2）代码3）Nginx配置解决跨域的问题4）兼容性问题 做一个H5页面，在微信端打开，调取手机麦克风进行录音，因为一些原因不打算用微信的JSSDK提供的音频接口，录音调用以及录音上传调用了Recorder，这里给出github链接 https://github.com/xiangyuecn/Recorder。 试了好几个录音调用的工具包，这个是唯一能用的。要注意的一点是，录音调用必须要用https请求，不然没有办法请求到麦克风权限。
1）安装 通过 npm/cnpm 进行安装 npm install recorder-core
2）代码 import Recorder from 'recorder-core' import 'recorder-core/src/engine/wav' import 'recorder-core/src/engine/mp3-engine' //由于大部分情况下ios-weixin的支持需要用到amr解码器，应当把amr引擎也加载进来 import 'recorder-core/src/engine/beta-amr' import 'recorder-core/src/engine/beta-amr-engine' data() { rec: Recorder({ type:"wav",sampleRate:16000,bitRate:16 ,onProcess:function(buffers,powerLevel,bufferDuration,bufferSampleRate){} }) }, mounted() { var recOpen=function(){//一般在显示出录音按钮或相关的录音界面时进行此方法调用，后面用户点击开始录音时就能畅通无阻了 that.rec.open(function(){ console.log("已打开录音，可以点击开始了");	//rec.start() 此处可以立即开始录音，但不建议这样编写，因为open是一个延迟漫长的操作，通过两次用户操作来分别调用open和start是推荐的最佳流程 },function(msg,isUserNotAllow){//用户拒绝未授权或不支持 // clearTimeout(t); console.log((isUserNotAllow?"UserNotAllow，":"")+"无法录音:"+msg, 1); }); }; recOpen(); }, methods: { /**开始录音**/ recStart(){//打开了录音后才能进行start、stop调用 this.rec.start(); }, /**结束录音**/ recStop(){ this.rec.stop((blob,duration) =&gt; { // var voiceToTextRes = "" this.showRecordingBox = false console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa5ef890c6a199e45525f35f66be145c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9a6b3f01b5c712cd97c1d216ebd44d/" rel="bookmark">
			vue-router_多个router-view以及传参问题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.多个router-view的问题 一个页面可以配置多个router-view，加上name属性使之区分，在路由配置中需要将component变为components，代码如下
&lt;template&gt; &lt;div id="app"&gt; &lt;div id="nav"&gt; &lt;router-link to="/"&gt;Home&lt;/router-link&gt; | &lt;router-link to="/about"&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;router-view/&gt; &lt;router-view name="compA"&gt;&lt;/router-view&gt; &lt;router-view name="compB"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; import Vue from 'vue' import VueRouter from 'vue-router' Vue.use(VueRouter) const routes = [ { path: '/', name: 'Home', components: { default: () =&gt; import('../views/Home.vue'), compA: () =&gt; import('../components/ComponentOne.vue'), compB: () =&gt; import('../components/ComponentTwo.vue') } }, { path: '/about', name: 'About', components: { compA: () =&gt; import('../components/ComponentThree.vue'), compB: () =&gt; import('../components/ComponentTwo.vue') } } ] const router = new VueRouter({ mode: 'history', base: process.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9a6b3f01b5c712cd97c1d216ebd44d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47bdb4be5161709e9c430519d896392/" rel="bookmark">
			如何理解数列极限和收敛性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何理解数列极限和收敛性 数列极限说来其实都不陌生，但往往到了高数的这段内容的时候许多人就会觉得非常头疼了。
定义：设 { x n } \left\{x_{n}\right\} {xn​} 为一数列,如果存在常数 a a a, 对于任意给定的正数 ε \varepsilon ε ( 不论它多么小 )，总存在正整数 N N N, 使得 当 n &gt; N n&gt;N n&gt;N 时, 有以下不等式成立：
∣ x n − a ∣ &lt; ε (1) \left|x_{n}-a\right|&lt;\varepsilon \tag{1} ∣xn​−a∣&lt;ε(1)
那么就称 a a a 是 { x n } \left\{x_{n}\right\} {xn​} 的极限。记作：
lim ⁡ n → ∞ x n = a (2) \lim _{n \rightarrow \infty} x_{n}=a \tag{2} n→∞lim​xn​=a(2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c47bdb4be5161709e9c430519d896392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c882dfcfca5c31a41551dac097e7c0d3/" rel="bookmark">
			如何从高德获取地铁数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 本文讲讲如何在高德获取地铁数据及后期处理，以北京为例。
实现 获取数据 打开高德地铁，按下F12打开调试模式，切换到network面板，如下：
点击右键，“Open in new tab”，在新窗口中打开。
将页面另存为json数据格式。
数据处理 将拿到的数据写代码转换成两个geojson数据，一个是站点数据，一个线路数据。
站点数据处理 $.get('data/subway.json', function (res) { var geojson = { 'type': 'FeatureCollection', 'features': [] }; res = res['l']; var stations = {}; for (var i = 0; i &lt; res.length; i++) { const r = res[i]; var kn = r['kn']; var ln = r['ln']; var cl = r['cl']; var ls = r['ls']; var st = r['st']; var lineInfo = { kn: kn, ln: ln, cl: cl, ls: ls }; for (let j = 0; j &lt; st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c882dfcfca5c31a41551dac097e7c0d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94183b35a74a85d5ba2fb15ac088ce92/" rel="bookmark">
			VS中使用Intel编译器后编译软件报错：type name is not allowed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用VS2019的IDE并结合intel C++ compiler 19.1（集成于intel parallel studio xe 2020），发现当包含&lt;iostream&gt;后编译软件，会报type name is not allowed错误。找了很久原因，最后终于发现是版本没有对应上，VS使用的库版本太新了，且Windows的SDK也太新了，Intel编译器还未支持。如下图所示。
此处我的VS默认使用的平台版本是V142，且SDK用的最新的，这里需要往后改，先改平台版本，在平台版本选项中逐个往下找，并测试(如果发现平台版本只有一个，说明你安装VS的时候没有安装其他版本，那你可以重新配置VS并安装一下其他版本)。注意，改平台版本的话，也要跟着改SDK版本，也是逐个往下找最终可用的即可。
比如我这里只要改成这样的配置就可以了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f9044770603b62a465b20f445894d5/" rel="bookmark">
			uniapp或微信开发    使用 swiper 组件 实现 3d 轮播   中间大图另外两张小图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		话不多说上图 html部分
&lt;swiper :autoplay="true" :current="currentIndex" :circular="true" previous-margin="80rpx" next-margin="80rpx" :interval="3000" :duration="100" @change="swierChange" &gt; &lt;swiper-item v-for="(item,i) in 5" :key="i"&gt; &lt;image src="../../static/images/banner.png" class="slide-image" :class="currentIndex === i?'active':''"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; script部分
data(){ return{ currentIndex: 0 } } methods:{ swierChange(e){ this.currentIndex = e.detail.current }, } css部分
.slide-image { position: absolute; height: 200rpx; width: 570rpx; border-radius: 15rpx; z-index: 5; opacity: 0.7; top: 18%; margin: 0 20rpx; } swiper { height: 430rpx; } .active { opacity: 1; z-index: 10; height: 316rpx; width: 572rpx; top: 7%; transition: all 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73f9044770603b62a465b20f445894d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3436ff6f917ae1b3ac58e5ad0ef93ea2/" rel="bookmark">
			unity-Embedded Browser 3.0.0 PC版嵌入网页，网页输入中文的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Embedded Browser 3.0.0这个插件使unity可以嵌入网页，但是在网页中是不能输入中文的，解决办法如下
找到插件中的PointerUIGUI.cs文件,更改此处
默认的是off，不开启，将其转为On就可以输入中文了。
6666
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db0a22f62f9c583acdadd34cea86ad8e/" rel="bookmark">
			基于DQN算法解决Cart-Pole问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于DQN的方法解决Cart-Pole问题 本文主要是对莫烦的DQN程序进行理解及注释，供自己理解以及向大家提供参考
import torch # 导入torch import torch.nn as nn # 导入torch.nn import torch.nn.functional as F # 导入torch.nn.functional import numpy as np # 导入numpy import gym # 导入gym # 超参数 BATCH_SIZE = 32 # 样本数量 LR = 0.01 # 学习率 EPSILON = 0.9 # greedy policy GAMMA = 0.9 # reward discount TARGET_REPLACE_ITER = 100 # 目标网络更新频率 MEMORY_CAPACITY = 2000 # 记忆库容量 env = gym.make('CartPole-v0').unwrapped # 使用gym库中的环境：CartPole，且打开封装 (若想了解该环境，请自行百度) N_ACTIONS = env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db0a22f62f9c583acdadd34cea86ad8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afaa62e75bd9565c6ea10c8648af0a79/" rel="bookmark">
			关于css的display:flex inline block inline-block和float
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.解释一下display的几个常用的属性值，inline ， block， inline-block
inline（行内元素）: 使元素变成行内元素，拥有行内元素的特性，即可以与其他行内元素共享一行，不会独占一行. 不能更改元素的height，width的值，大小由内容撑开. 可以使用padding上下左右都有效，margin只有left和right产生边距效果，但是top和bottom就不行. block（块级元素）: 使元素变成块级元素，独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度. 能够改变元素的height，width的值. 可以设置padding，margin的各个属性值，top，left，bottom，right都能够产生边距效果. inline-block（融合行内于块级）: 结合了inline与block的一些特点，结合了上述inline的第1个特点和block的第2,3个特点. 用通俗的话讲，就是不独占一行的块级元素。如图: 图一:
图二：
两个图可以看出，display：inline-block后块级元素能够在同一行显示，有人这说不就像浮动一样吗。没错，display：inline-block的效果几乎和浮动一样，但也有不同，接下来讲一下inline-block和浮动的比较。
2.inline-block布局 vs 浮动布局
a.不同之处：对元素设置display：inline-block ，元素不会脱离文本流，而float就会使得元素脱离文本流，且还有父元素高度坍塌的效果 b.相同之处：能在某程度上达到一样的效果 我们先来看看这两种布局：
图一：display：inline-block
图二：对两个孩子使用float：left，我在上一篇浮动布局讲过，这是父元素会高度坍塌，所以要闭合浮动，对box使用overflow：hidden，效果如下：
乍一看两个都能做到几乎相同的效果，（仔细看看display：inline-block中有间隙问题，这个留到下面再讲）
c.浮动布局不太好的地方：参差不齐的现象，我们看一个效果：
图三：
图四：
从图3,4可以看出浮动的局限性在于，若要元素排满一行，换行后还要整齐排列，就要子元素的高度一致才行，不然就会出现图三的效果，而inline-block就不会。
3.inline-block存在的小问题：
a.上面可以看到用了display:inline-block后，存在间隙问题，间隙为4像素，这个问题产生的原因是换行引起的，因为我们写标签时通常会在标签结束符后顺手打个回车，而回车会产生回车符，回车符相当于空白符，通常情况下，多个连续的空白符会合并成一个空白符，而产生“空白间隙”的真正原因就是这个让我们并不怎么注意的空白符。
b.去除空隙的方法：
1.对父元素添加，{font-size:0}，即将字体大小设为0，那么那个空白符也变成0px，从而消除空隙
现在这种方法已经可以兼容各种浏览器，以前chrome浏览器是不兼容的
图一：
c.浏览器兼容性：ie6/7是不兼容 display：inline-block的所以要额外处理一下：
在ie6/7下：
对于行内元素直接使用{dislplay:inline-block;}
对于块级元素：需添加{display:inline;zoom:1;}
4.总结:
display：inline-block的布局方式和浮动的布局方式，究竟使用哪个，我觉得应该根据实际情况来决定的：
a.对于横向排列东西来说，我更倾向与使用inline-block来布局，因为这样清晰，也不用再像浮动那样清除浮动，害怕布局混乱等等。
b.对于浮动布局就用于需要文字环绕的时候，毕竟这才是浮动真正的用武之地，水平排列的是就交给inline-block了。
转载于http://www.cnblogs.com/Ry-yuan/p/6848197.html
flex布局
flex-direction属性决定主轴的方向（即项目的排列方向）。
.box {
flex-direction: row | row-reverse | column | column-reverse;
}
它可能有4个值。
row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性
默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afaa62e75bd9565c6ea10c8648af0a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f562818a071fb2dda8584a7ec4bab27/" rel="bookmark">
			input输入框禁止自动获取上次的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		autocomplete=“off”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e0e1fca2584a2c6603f2d2bb0e438ba/" rel="bookmark">
			【vivado使用】第6篇：报错：[Labtoolstcl 44-513] HW Target shutdown. Closing target: localhost......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vivado打开hardware manage -&gt; open target后，突然对开发板进行断电，就会报错：
然后之后每次进行代码编译，综合，执行之后，就会提示error：
很明显就不是代码本身问题，要么不用管，要么关掉vivado，重新打开项目工程就行了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b568932b0fe83f20fa77c38d49c523/" rel="bookmark">
			Python-学习中遇到的问题及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TypeError: argument should be integer or bytes-like object, not 'str' 解决办法：在字符串前加上b
欢迎加入技术讨论群，无广告，纯技术，欢迎各位大佬，也欢迎新手，群内禁止歧视新手，大佬自愿回答问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4453b5cf77359712f5ff026a28a8c465/" rel="bookmark">
			会计学原理学习笔记——第三章——账户与复式记账（3.4生产准备业务核算——材料采购业务核算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、材料采购业务核算简介 （一）材料的种类
材料按其在生产过程中的作用，可分为原料及主要材料、辅助材料、外购半成品（外购件）、修理用备件、包装材料、燃料等。
（二）采购成本
买价和采购费用（包括运费、装卸费、运输途中的合理损耗、入库前的挑选整理费用和购入材料负担的税金等，但增值税除外）。
二、账户设置 （一）“在途物资”账户
本账户属于资产类账户，核算企业采用实际成本进行材料日常核算，货款已付尚未验收入库的购入材料或商品的采购成本。其借方登记企业购入材料、商品的金额；贷方登记所购材料、商品到达验收入库的成本。
（二）“原材料”账户
该账户属于资产类账户，核算企业库存各种材料的增减变动及其结存情况。
其借方登记已验收入库材料的成本；贷方登记发出库存材料的成本。
（三）“预付账款”账户
该账户属于资产类账户，核算企业按照购货合同预先付给供应单位的款项。
其借方登记按合同规定预付给供应单位的货款和补付的货款；贷方登记收到所购货物的应付金额和收到退回多付的货款。
（四）“应付票据”账户
该账户属于负债类账户，核算企业对外发生债务时所开出承兑的商业汇票，包括银行承兑汇票和商业承兑汇票。其贷方登记企业开出、承兑汇票或以承兑汇票抵付货款的金额；借方登记已支付的到期汇票金额。
三、材料采购业务的总分类核算 （一）立即付款
【例3—13】2018 年12 月10 日，江南服装股份有限公司为一般纳税人 ，向宏信公司购买一批甲材料，收到宏信公司开出的增值税专用发票，数量240 000 千克，单价11.60 元，价款2 784 000 元，增值税额445 440 元，运输费96 000 元，增值税额9 600 元，均以银行存款付讫，材料已验收入库。
借：在途物资——甲材料 2 880 000
应交税费——应交增值税（进项税额） 455 040
贷：银行存款 3 335 040
（二）赊购
1、因商业信用产生的赊购
【例3—14】2018 年12 月12 日，江南服装股份有限公司向雨辰公司购进乙材料300 000 千克，单价5.80 元，价款1 740 000 元，增值税278 400 元，运输费60 000 元，增值税6000 元，已收到雨辰公司开出的增值税专用发票，款项尚未支付，材料已入库。
借：在途物资——乙材料 1 800 000
应交税费——应交增值税（进项税额） 284 400
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4453b5cf77359712f5ff026a28a8c465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e7643b558123e350205cbfbd57d5cd9/" rel="bookmark">
			C语言-C语言教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考 嗨客网 C语言 教程
C语言教程 什么是编程语言 编程语言（programming language），是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。
也可以说，计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动。
编程语言也俗称 “计算机语言”，种类非常的多，总的来说可以分成机器语言、汇编语言、高级语言三大类。
什么是程序 程序就是完成某个功能的指令的集合。
我们对计算机下达的每个命令都称为指令，它对应着计算机执行的一个基本动作。我们告诉计算机按照某种顺序完成系列指令，这一系列指令的集合称为程序。
什么是编程 编程是编写程序的中文简称，就是让计算机代为解决某个问题，对某个计算体系规定一定的运算方式，使计算体系按照该计算方式运行，并最终得到相应结果的过程。
为了使计算机能够理解人的意图，就必须将需解决的问题的思路、方法和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令去工作，完成某种特定的任务。这种人和计算体系之间交流的过程就是编程。
主流编程语言 B语言 B 语言之父：Ken Thompson（肯.汤普森）。
B 语言是贝尔实验室开发的一种通用的程序设计语言，它是于 1969 年前后 Ken Thompson（肯.汤普森）在 Dennis Ritchie 丹尼斯.里奇（Dennis Ritchie）的支持下设计出来。
B 语言得名于汤姆森的妻子 Bonnie，它是一门开发于 60 年代中期的语言，现在使用者已经很少了。
C语言 C 语言 之父：Dennis Ritchie（丹尼斯·里奇）。美国著名计算机专家、C 语言发明人、UNIX 之父。在 1969-1973 年期间发明了 C 语言和 Unix 操作系统。
到了 70 年代，诞生了一门非常重要的语言，这就是今天的大名鼎鼎的 C 语言。
C 语言之父是美国著名的计算机专家。丹尼斯.利奇。 在开发 C 语言的时候其实是以 B 语言为基础。之所以发明 C 语言，实际上是因为这两个人，刚刚的 B 语言之父肯.汤普森和丹尼斯.里奇，一块写了一个操作系统，就是 Unix 系统。在写 Unix 系统的过程中，需要一种便利的语言，而 B 语言又达不到这个要求，所以丹尼斯.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e7643b558123e350205cbfbd57d5cd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981546450ba37717934c2a24ec36ceeb/" rel="bookmark">
			vscode远程开发免密输入设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 上一篇vscode远程开发配置，设置完后，需要每次输入密码，如果觉得太繁琐，可以通过设置密钥的方式实现免密，具体设置步骤如下：
1、在本地生成公私钥 其中，-t rsa表示生成密钥类型为rsa, -b表示生成多少位的密钥，如果不设置的话，默认生成的rsa密钥长度为2048。密钥生成路径默认是c:\Users\xxx\.ssh ，其中私钥文件为id_rsa，公钥文件为id_rsa.pub。一般默认回车即可。
2、上传公钥文件到服务器 id_rsa.pub上传到服务器的 ~/.ssh/目录。如果~/.ssh/目录下不存在authorized_keys， 则将id_rsa.pub更名为authorized_keys。
~/.ssh$ mv id_rsa.pub authorized_keys 如果~/.ssh/目录下存在authorized_keys，则追加id_rsa.pub到authorized_keys中。
:~/.ssh$ cat id_rsa.pub &gt;&gt; authorized_keys 这个就可以免密远程登陆了。
3、设置私钥 如果私钥路径与.ssh/config不一致，需要在config中设置私钥路径, 如果路径一致，则无需另外设置私钥路径。
Host aaa HostName bbb User yyy IdentityFile "C:\Users\xxxx\.ssh\id_rsa" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d0e0a18e3e9f4f49bddbc71a241a04/" rel="bookmark">
			PMP 第8章 项目质量管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一序 本文属于PMP学习笔记系列。本章包含3个过程，相对较少。视频共12个。
8.0 理解质量管理 质量管理过程包含：
规划质量过程：先定义管理质量的原则、工具方法和标准。
管理质量： QA
控制质量： QC
等级与质量 高等级不是高质量，低等级不一定是问题，但低质量是个问题。举例：百达翡丽与电子表。
插播一条广告，“没人能拥有百达翡丽,只不过为下一代保管而已”。几千块的课，介绍几千万的表，太超值了。
精确度与准确度 精确度是指样本之间距离小，聚合度高。准确度是是指测量值与预期值（目标）距离小。
质量管理的5个层次 质量管理的发展过程：
工匠自控-》专职质检-》QC质量控制-》QA质量控制-》DFX，TQM
质量管理的发展趋势 1. 客户满意L代表人物：朱兰
核心思想：符合要求、适于使用。
朱兰三部曲： 改进、计划、控制，定义了登机和质量的区别和联系。
2 持续改进
代表人物：戴明 。提出了著名的戴明环（PDCA），举例：海尔砸冰箱
计划plan、执行do、检查check、处理act.不是循环一次，而是周而复始。
相关的质量标准有6西格玛（就是标准分布的6个标准差，99.99966%）精益，精益6西格玛。
3 管理层的责任
质量出了问题，管理层应当承担主要责任。
4 与供应商持续合作，互利共赢
质量成本COQ 包括为预防质量不合格，或者纠正不合格（返工等）二发生的成本。容易从两类选项出考题。
克劳斯比:“零缺陷”之父
田口玄一
质量特性值偏离目标值越大，损失越大，质量太差不行，太好也不行。
老师举例了HiFi的玄学，“万元以下听个响”，举例了摄影，为了更好一点的效果，硬件器材高昂的代价。
8.1 规划质量管理 矩阵图matrix Diagram 寻找工艺与质量之间的关系。
流程图 sipoc 模型
8.2 质量管理 QA和QC
面向X的设计 DfX 以宜家家居举例，用户的机制体验。
根本原因分析 RCA 结构化、系统化的问题处理法。寻找再次可能发生类似事故的潜在原因。
举例：三鹿奶粉事件，为了提振信心，从牧草、奶牛、加工等全链条分析。
因果图（鱼骨图、石川图） 石川馨：QCC之父
问题陈述放在鱼骨的头部，作为起点，顺着鱼骨（大刺-毛刺）追溯问题来源，回推到根本原因。
直方图 直方图分析：
双侧无余量型、余量过于富裕型、平均值偏离型
散点图 通过变量之间相关性分析质量问题产生的原因，又称为相关图。
核对单 checklist 具体列出各检查项，用来合适一系列步骤是否已经执行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7d0e0a18e3e9f4f49bddbc71a241a04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9ebc759e1f604c9f9b6c1bad4d3322/" rel="bookmark">
			ASPICE总结2——软件详细设计与软件测试过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件详细设计在ASPICE中代号是SWE3,处于V模型的左侧； 软件测试则包含软件单元测试（SWE4）,软件集成测试（SWE5）以及软件合格性测试（SWE6）三部分，处于V模型的右侧。下面我会比较详细地介绍一下各过程域的实施要点和迎审会面对的主要问题。
软件详细设计
软件详细设计要准备的第一份交付件就是：软件详细设计文档！文档的输入是软件的需求，内容应该涵盖数据结构定义，全局变量和宏定义描述，动态行为描述（任务/中断/需求方案分析等），每个函数的实现（输入/输出/返回/伪码等）,详细设计评估（关键性、复杂性、交互性等维度）。严格意义上来讲，应该是先做好详细设计，再写实际的代码。但是！其实我们是先代码后详设，或者说两者融为一体的，因为人力不够，时间也不够，只能走捷径。需要注意的就是写伪码的时候别写的跟源码一样，别露馅了。对于这一点，其实各OEM应该也心里有数，不会揪着不放。
在软件详细设计写完并进行了评审之后（评审记录要留好），就可以进行代码相关的一系列动作了。
首先，写代码的时候就要注意对编程规范的遵循，如果OEM还有KGAS的要求，那就尤其要上心了：代码圈复杂度要小于等于10，嵌套层数不大于4等等。多提一句，KGAS中的编码规范非常苛刻以至于很多都违反人性，比如一个函数只能一个return等，但是这些是可以跟OEM沟通协商的，达成书面协议哪些可以不遵循。
代码写完的写一个动作是静态代码扫描。一般采用持续集成工具（如Jenkins等）实现自动扫描，在汽车领域一个重要的扫描项就是MISRA C编码规范的扫描。如果有违规的特殊情况，可以进行备注。实际上从静态扫描已经开始属于单元验证部分的内容了，单元验证一般来说包括几个行为：静态代码扫描，代码检视，单元测试，静态代码扫描和代码检视的结果也应该在单元验证报告中体现，但是由于其与代码紧密相关，所以一并叙述。每次静态代码扫描的结果同样需要保存作为“呈堂证供”。
下一趴，代码检视。单元验证计划里应该有代码检视的checklist，最后需要有代码检视报告。比较easy的一个环节。代码检视完成后，就可以将代码上库了，我们采用的是git管理。测试计划
叫测试计划也行，叫测试策略也中（河南口音）。内容有点多，本文先不写，下次找机会。单元测试
单元测试属于白盒测试，也就是说可以参考代码的。但是KGAS要求设计用例的时候不能看代码！要先黑盒后白盒！就是说测试用例设计的一开始要参照详细设计文档来设计，如果发现有分支或语句覆盖率满足不了，那再来参照代码。说是这么说，做呢…有可能不是这么做哈哈哈，实际上我设计用例的时候都是对着代码设计的。
再来赘述一句没用的，KGAS要求单元测试用例设计人员与开发人员不能是同一个，用例执行人员和用例设计人员不能是同一个，要交叉。说是这么说，做呢…我就不说了。
测试用例设计文档要指明每个测试用例使用的设计方法，是等价类，边界值，需求分析还是错误猜测；还有用例的设计人员，用例的预置条件，用例的目的，用例的输入和预期输出。我觉得测试用例设计是让我头最大的一步，主观上相当排斥。
单元测试用例整体来说设计还是比较简单的，用例数目主要是取决于函数中if语句的数目。单元测试用例评审要重点评一下用例是否设计完整等，最后同样要保留评审记录（别嫌我烦，评审记录真的很重要）。
用例评审完就开始执行，执行就有可能出错，出错你就惨了哈哈哈。首先要针对错误提单，要解决这个BUG，你得从详细设计开始改，改完详设做评审，改完代码做扫描检视+评审，最后再来一波回归测试，一套组合拳下来，保准你这辈子再也不想发现BUG。你以为这是最惨的吗？不是的，集成测试发现问题才叫惨，那集成测试发现问题是最惨的吗？你又错了，合格性测试发现问题更惨？还有吗？还有吗？系统集成测试，系统合格性测试，一级更比一级惨！总而言之，越往后越惨，要是问题到客户那里、上车了才发现，饭碗可能就丢了。It’s never too late to discover BUGs!
最后，写单元测试报告，把测试过程，测试时间/活动等进行总结，子过程的结果汇总起来，进行缺陷与遗留问题分析。然后，单元测试报告评审（别忘了保留记录）。 写到这，我已经不想继续敲下去了，因为今天敲够了。测试计划，集成测试与合格性测试，改天吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd8e07ac9ed2de913298038211d66ed/" rel="bookmark">
			python&#43;Django&#43;Mysql&#43;协同过滤电影推荐系统简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该系统为基于协同过滤算法的Django电影推荐系统， 点击跳转 详情介绍如下所示。
技术介绍 前端: bootstrap3 + jquery.js后端: django 2.2.1 + djangorestframework（负责api部分）数据库: mysql5.7 / sqlite3算法: 基于用户的协同过滤/基于物品的协同过滤 数据集介绍 豆瓣数据集 基于requests的python爬虫去抓取豆瓣电影的电影信息，包含图片信息，总共2250部。
数据属性:
id,title ,image_link ,country ,years ,director_description,leader,star ,description,all_tags,imdb,language,time_length
评分: 附带随机生成数据的脚本，可以随机生成指定数目的用户和用户的评分
movielens数据集 movielens 100k数据集+图片
数据维度: movieId,title,genres,picture
电影数量: 37544
评分数量: 93202+
movielens数据集+图片+用户数据和评分数据+csv存储
功能介绍 电影展示，电影搜索，标签分类 标签分类 用户的登录，注册，修改信息 用户注册界面 用户登录界面 用户个人信息 用户注册代码 用户对电影的打分，收藏和电影的详情页面 基于user和Item的协同过滤推荐算法，为用户推荐想看的电影 用户推荐界面 用户推荐部分代码 物品推荐界面 物品推荐部分代码 后台管理系统，可以进行电影信息的增删改查 数据库模型代码 算法介绍 冷启动问题解决 在用户首次注册的时候会为用户提供感兴趣的标签选择界面。然后在用户未进行打分的情况下，会为用户推荐喜欢标签的电影。
推荐算法改进----结合标签的协同过滤推荐 在冷启动页面用户选择标签后将用户对这些标签标签的喜爱值设为5。
在用户为电影打分后，会根据此电影的标签来更新用户对标签喜爱值得分。
在根据协同过滤得到为用户推荐的电影后，如果推荐的电影数量不足15部，则从用户喜爱的标签中选取一部分电影来填充
更新标签喜爱值的策略将用户对电影的打分值减三然后加到喜爱值表中。
基于用户的协同过滤 算法: 协同过滤， 根据用户的打分来进行推荐。从所有打分的用户中找出和当前用户距离最近的n用户，然后从n个用户打分的电影中找15个当前用户未看过的电影。
最近距离算法通过协同过滤来实现。
推荐算法—协同过滤 - 简书 此项目采用的是皮尔逊相关系数来计算相似度。采取基于用户模型的的协同过滤(Neighbor-based Collaborative Filtering)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd8e07ac9ed2de913298038211d66ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e384356691aa41e6c18dc782bbdd5f/" rel="bookmark">
			kong&#43;elasticsearch监控所有请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kong+elasticsearch监控所有请求 Kong文章系列
Kong系列（一）——Kong安装Kong系列（二）——Kong组件使用Kong系列（三）——Kong插件[IP Restriction]使用Kong API网关使用笔记 上面是写了一些Kong基础使用的文章，如果对Kong还不太熟悉可以参考阅读。
本篇文章的内容是使用elasticsearch记录Kong的所有请求，最终目的是通过elasticsearch + kibana对所有请求做进一步分析，不过这篇文章暂时没有kibana部分，因为笔者还没有研究，所以这篇文章主要是将kong的请求信息转存到elasticsearch.
目标 通过Kong提供的插件【HTTP Log】，将指定的Service或者Route的请求转发到指定的HTTP URL 构建Web服务，接收Kong转发的请求信息，并附加其他信息保存(如果是对Kong比较熟，可以直接定制HTTP Log插件) 将构建的请求信息保存到elsticsearch 通过kibana对数据进行分析 原理 操作步骤 配置HttpLog插件 给指定的service配置http-log
curl -X POST http://localhost:8001/services/c9beb237-7e85-49b3-8561-0082fc8086ea/plugins \ --data "name=http-log" \ --data "config.http_endpoint=http://172.11.22.10:10150/http_log/post" \ # 配置的代理地址 --data "config.method=POST" \ --data "config.timeout=1000" \ --data "config.keepalive=1000" 请求发送的json数据为
{ "request": { "method": "GET", "uri": "/get", "url": "http://httpbin.org:8000/get", "size": "75", "querystring": {}, "headers": { "accept": "*/*", "host": "httpbin.org", "user-agent": "curl/7.37.1" }, "tls": { "version": "TLSv1.2", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e384356691aa41e6c18dc782bbdd5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cfdd42d67648caf6371e65bd8b7b56/" rel="bookmark">
			【前端 VUE】vue 角色权限使用 hasPermission
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		main.js 设置全局变量
Vue.prototype.$hasPer = hasPermission;
设置权限函数 export function hasPermission(perm) {
let permissionBtns = store.getters.btnPermissions ? JSON.parse(store.getters.btnPermissions) : [] let btnName = permissionBtns.map(res =&gt; {
return res.name
})
return btnName.indexOf(perm) &gt; -1
}
页面使用 传入判断的字段 order 检测权限显示或影藏
&lt;div v-if="$hasPer('order')"&gt;&lt;/div&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b3b62d4f105502b5e330c19460dc84/" rel="bookmark">
			R语言基础图形绘制——箱线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R语言绘制箱线图 简介1. 基础函数—`boxplot()`2. `ggplot()`函数 简介 箱线图主要是通过四分位数描述数据分布，通过最大值，上四分位数，中位数，下四分位数，最小值五处位置描述数据分布情况。箱线图能够显示出可能为离群点（范围±1.5*IQR以外的值，IQR表示四分位距，即上四分位数与下四分位数的差值）的观测。
从箱线图中，可以大致推断出数据的集中或离散趋势。
下图清楚展示了箱线图的组成部分。
1. 基础函数—boxplot() boxplot() 是一个泛型函数，目前支持两种参数类型：公式和数据。
用法
## S3 method for class 'formula' boxplot(formula, data = NULL, ..., subset, na.action = NULL, xlab = mklab(y_var = horizontal), ylab = mklab(y_var =!horizontal), add = FALSE, ann = !add, horizontal = FALSE, drop = FALSE, sep = ".", lex.order = FALSE) ## Default S3 method: boxplot(x, ..., range = 1.5, width = NULL, varwidth = FALSE, notch = FALSE, outline = TRUE, names, plot = TRUE, border = par("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b3b62d4f105502b5e330c19460dc84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/618c75de1cc3ef8900fa0e26430c6140/" rel="bookmark">
			C&#43;&#43;程序内存模型-new运算符  在堆区开辟内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 上篇文章已经介绍了堆区和栈区
详细介绍一下new
C++中利用new操作符在堆区开辟数据
堆区开辟的数据，由程序员手动开辟，释放用操作符delete
利用new创建的数据，会返回该数据对应类型的指针
更详细的new的用法请见这
#include&lt;iostream&gt; using namespace std; //利用new关键字在堆区创建数组 //new的基本用法 int *fun(){ int *a=new int (10); return a; } void test(){ int *s/*因为在堆区创建的数据会返回该数据对应类型的指针，所以用指针变量接收*/=new int[10];//代表数组有10个元素 //如何利用new创建数组 for(int i=0;i&lt;10;i++){ s[i]=i+100; } for(int i=0;i&lt;10;i++){ cout&lt;&lt;s[i]&lt;&lt;endl; } } int main(){ int *p=fun(); cout&lt;&lt;*p&lt;&lt;endl; //释放堆区数字 delete p; //cout&lt;&lt;*p&lt;&lt;endl;//编译器会报错，因为已经释放，不能再访问 test(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/345c7d3c6ac651900a053726be3d5ff4/" rel="bookmark">
			80V超高压线性降压LDO仅2uA的待机功耗且具有固定极可调输出电压规格 极适用物联网产品模块供电等高压转低压低功耗应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YB203H系列 80V超高压线性降压LDO仅2uA的待机功耗且具有固定极可调输出电压规格 极适用物联网产品模块供电等高压转低压低功耗应用.
YB203H概述系列是一组CMOS技术实现的三端低功耗高电压稳压器。输出电流为 200mA 且允许的输入电压可高达 80V。具有几个固定的输出电压，范围从 2.1V 到 12.0V。CMOS 技术可确保其具有低压降和低静态电流的特性。最高耐压100V.尽管主要为固定电压调节器而设计，但这 IC 可与外部元件结合来获得可变的电压和电流。
特性
· 低功耗
·低压降
·较低的温度系数
·支持80V输入,最高耐压100V
·静态电流2μA
·大电流输出:200mA
·输出电压精度:±2%
·封装类型:TO92.SOT89和SOT23.3
·输出无上电过冲
YB203H可以在70V输入的时候,输出5V-10mA
YB203H可以在8V输入的时候,输出5V-200mA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d3a91da3d9aa331bccfbad62385db7/" rel="bookmark">
			WIN2008 IIS未被授权访问所请求的资源。请考虑授予 ASP.NET 请求标识访问此资源的权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WIN2008 IIS未被授权访问所请求的资源。请考虑授予 ASP.NET 请求标识访问此资源的权限
web应用程序发布到iis的时候会出现对文件夹的访问被拒绝。
对路径“…”的访问被拒绝。
说明: 执行当前 Web 请求期间，出现未处理的异常。请检查堆栈跟踪信息，以了解有关该错误以及代码中导致错误的出处的详细信息。
异常详细信息: System.UnauthorizedAccessException: 对路径“…”的访问被拒绝。
ASP.NET 未被授权访问所请求的资源。请考虑授予 ASP.NET 请求标识访问此资源的权限。ASP.NET 有一个在应用程序没有模拟时使用的基进程标识(通常，在 IIS 5 上为 {MACHINE}/ASPNET，在 IIS 6 上为网络服务)。如果应用程序正在通过 模拟，则标识将为匿名用户(通常为 IUSR_MACHINENAME)或经过身份验证的请求用户。
要将 ASP.NET 访问权限授予某个文件，请在资源管理器中右击该文件，选择“属性”，然后选择“安全”选项卡。单击“添加”添加适当的用户或组。突出显示 ASP.NET 帐户，选中所需访问权限对应的框。
当你在地址栏内输入被访问拒绝的地址，通常能够打开该文件，出现这种问题主要和该文件的安全设置以及ASP.NET 访问有关。解决方法如下：中右击该文件，选择“属性”， 然后选择“安全”选项卡如图1 所示
图1
单击“添加”按钮，弹出“选择用户或组”对话框见图2，选择asp.net用户，
图2
单击“确定”按钮，返回属性框，单击“应用”按钮即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b2a8f2b76d437be0c88c6cf2b7f9f6/" rel="bookmark">
			tensorflow2.3实践 猫狗识别(详细步骤注释及93%的准确率)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统
ubuntu 20.04
IDE
pycharm(社区版)
ps:建议专业版,真能避免许多麻烦
代码
import tensorflow as tf import matplotlib.pyplot as plt import pathlib import random #提取所有文件路径 data_dir = '/...../test' data_root = pathlib.Path(data_dir) all_image_path = list(data_root.glob('*/*')) all_image_path = [str(path) for path in all_image_path] #乱序 random.shuffle(all_image_path) #记录总数,以备后用 image_count = len(all_image_path) #编码标签 #Cat 0 Dog 1 label_names = sorted(item.name for item in data_root.glob('*/')) label_to_index = dict((name,index) for index,name in enumerate(label_names)) #给图片贴标签 #pathlib.Path('..../2.jpg').parent.name 返回上一级目录名称 all_image_label = [label_to_index[pathlib.Path(p).parent.name] for p in all_image_path] #图片预处理函数 def load_preprosess_image(image_path,image_label): #读取图片 img_raw = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b2a8f2b76d437be0c88c6cf2b7f9f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f345454a130603f7620e627a55e558/" rel="bookmark">
			会计学原理学习笔记——第三章——账户与复式记账（3.2资金筹集业务的核算——借入资本的核算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、借入资本定义 借入资本是指通过银行或其他金融机构等渠道，采用银行借款、发行债券、商业信用融资等方式筹措获得的债务资本。
二、银行借款借入资本的核算内容 （一）取得借款
（二）持有期内应支付的借款利息
（三）到期归还借款本金和利息
三、借款的分类 （1）银行借款按偿还期限的长短可分为短期借款和长期借款。
（2）银行借款按付息方式
可分为三种：按月付息、分期付息（如，按季、半年、年付息）、到期一次付息。
四、账户设置 （1）“短期借款”账户
本账户属于负债类账户，核算企业向银行或其他金融机构借入的期限在一年以下（包括一年）的各种借款。其贷方登记借入的各种短期借款本金；借方登记短期借款本金的归还。
（2）“长期借款”账户
本账户属于负债类账户，核算企业向银行或其他金融机构借入的期限在一年以上的各种借款。其贷方登记借入长期借款的本金及利息；借方登记偿还的本金。
（3）“应付利息”账户
本账户属于负债类账户，核算企业按照合同约定支付的利息，包括吸收存款、分期付息到期还本的长期借款、企业债券等应支付的利息。其贷方登记按合同利率计算确定的应付未付利息；借方登记实际支付的利息。
（4）“财务费用”账户
本账户属于损益类账户，核算企业为筹集生产经营资金等而发生的费用，包括利息支出（减利息收入）、汇兑损失（减汇兑收益）以及相关的手续费等。其借方登记企业发生的财务费用；贷方登记发生的应冲减财务费用的利息收入、汇兑收益。
五、借入资本的总分类核算 直接借入资本按借款期限长短可分为短期借款和长期借款，主要核算包括借入本金、发生借款利息和归还本金三方面的内容。
（1）短期借款核算
【例3—4】2018 年12 月1 日，江南服装股份有限公司由于生产经营需要，向银行取得借款240 万元，期限为6 个月，年利率4.5%，合约规定利息在在借款到期时支付，所得借款存入银行。
借：银行存款 2 400 000
贷：短期借款 2 400 000
【例3—5】2018 年12 月31 日，江南服装股份有限公司计提本月银行短期借款利息9 000 元。
借：财务费用——利息费用 9 000
贷：应付利息 9 000
【例3—6】2019 年6 月1 日，公司以银行存款归还到期的6 个月借款本金2 400 000 元和利息费用54 000 元。
借：短期借款 2 400 000
应付利息 54 000
贷：银行存款 2 454 000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51f345454a130603f7620e627a55e558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c049c6db2bfa1260dc123b5a8312092e/" rel="bookmark">
			Java操作ElasticSearch相关内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java连接ES 创建Maven工程 导入依赖 &lt;dependencies&gt; &lt;!-- 1. elasticsearch--&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;6.5.4&lt;/version&gt; &lt;/dependency&gt; ​ &lt;!-- 2. elasticsearch的高级API--&gt; &lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt; &lt;version&gt;6.5.4&lt;/version&gt; &lt;/dependency&gt; ​ &lt;!-- 3. junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; ​ &lt;!-- 4. lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.22&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建测试类，连接ES public class ESClient { ​ public static RestHighLevelClient getClient(){ ​ // 创建HttpHost对象 HttpHost httpHost = new HttpHost("192.168.199.109",9200); ​ // 创建RestClientBuilder RestClientBuilder clientBuilder = RestClient.builder(httpHost); ​ // 创建RestHighLevelClient RestHighLevelClient client = new RestHighLevelClient(clientBuilder); ​ // 返回 return client; } ​ } Java操作索引 创建索引 代码如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c049c6db2bfa1260dc123b5a8312092e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da1a5192ce9692371ccc52185cb97d18/" rel="bookmark">
			count(*)的理解（mysql45讲）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		count函数的运行机制 问题count（*）的实现方式TABLE_ROWS自己计数的方式用缓存系统保存计数在数据库保存计数 不同的count现在的优化器只是给count(*)做了取行数的优化，其他的count都会进行判断，大大的耗时count深度解析 按照效率排序 问题 在开发系统的时候，你可能需要计算一个表的行数，比如一个交易系统的所有变更记录总数，这时候就会使用select count(*) from t来解决，随着系统记录数越来越多，这些语句执行也会越来越慢，这是个啥原因呢？
count（*）的实现方式 在不同的Mysq存储引擎上，count(*)有不同的实现方式
MyISAM引擎把一个表的总行数存在了磁盘上，因此执行count(*)的时候直接返回这个数InnoDB引擎执行count(*)的时候需要把数据一行一行的从引擎里读出来，然后累积计数 当然，如果加了Where条件的话，MyISAM也是不能返回这么快的
为什么InnoDB不跟MyISAM一样，也把数字存起来呢？
因为即使是在同一个时刻的多个查询，由于多版本并发控制的原因，InnoDB表应该返回多少行也是不确定的 But, InnoDB表肯定不是简单的一行一行的取，由于它是索引组织表，它对count(*)还是有优化的
主键索引树的叶子节点是数据，普通索引树的叶子节点是主键ID,InnoDB在做扫描的时候，会选择最小的索引树进行扫描 TABLE_ROWS 在mysql中使用如下命令可以有一个返回值TABLE_ROWS（或者ROWS）用于显示当前这个表有多少行，这个命令执行的还挺快的
mysql&gt; show table status; +-------+--------+---------+------------+-------+----------------+-------------+-----------------+--------------+-----------+---------------------+---------------------+-------------+------------+-------------------+----------+----------------+---------+ | Name | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length | Index_length | Data_free | Auto_increment | Create_time | Update_time | Check_time | Collation | Checksum | Create_options | Comment | +-------+--------+---------+------------+-------+----------------+-------------+-----------------+--------------+-----------+---------------------+---------------------+-------------+------------+-------------------+----------+----------------+---------+ | SUser | InnoDB | 10 | Dynamic | 0 | 0 | 16384 | 0 | 32768 | 0 | NULL | 2020-08-08 22:14:39 | NULL | NULL | latin1_swedish_ci | NULL | | | | t | InnoDB | 10 | Dynamic | 10122 | 35 | 360448 | 0 | 327680 | 0 | NULL | 2020-08-10 22:20:47 | NULL | NULL | latin1_swedish_ci | NULL | | | | user | InnoDB | 10 | Dynamic | 11 | 1489 | 16384 | 0 | 0 | 0 | 1290839374338056202 | 2020-08-08 09:22:10 | NULL | NULL | latin1_swedish_ci | NULL | | | +-------+--------+---------+------------+-------+----------------+-------------+-----------------+--------------+-----------+---------------------+---------------------+-------------+------------+-------------------+----------+----------------+---------+ 3 rows in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da1a5192ce9692371ccc52185cb97d18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6988b760fcd45cc8abb1ed6f409100b/" rel="bookmark">
			会计学原理学习笔记——第二章——账户设置与借贷记账法（2.5会计科目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		借贷记账法是以“借”、“贷”作为记账符号，以“有借必有贷，借贷必相等”作为记账规则的一种复式记账法。
借贷记账法在会计核算应用中包括记账符号、账户结构、记账规则、会计分录、试算平衡几个方面的内容。
一、记账符号 （一）记账符号的特定涵义
记账符号是用以指明经济业务记录方向而规定使用的符号，用来记录经济业务的增减变化方向。
（二）记账符号的作用。
第一，表明记账方向。记账方向是记录经济业务发生而引起的会计要素的增减数额。
第二，表明指标增减。通过假设，经济业务发生引起的会计要素增减变化就可以对应地记录在账户指标中，并形成对应关系。
第三，表明账户性质。在一般情况下，资产类账户的余额方向在借方；负债和所有者权益类账户的余额方向在贷方，所以记账符号可以表明账户的性质。
二、账户结构 （一）资产、负债和所有者权益类账户的结构
资产类账户的借方（左边）登记其增加额，贷方（右边）登记其减少额，余额一般在借方。
而负债、所有者权益类账户由于不资产类账户的性质刚刚相反，则其借方（左边）登记其减少额，贷方（右边）登记其增加额，余额一般在贷方。
（二）收入、费用和利润类账户的结构
费用类账户与资产类账户同在公式左边，则其基本结构应与资产类账户相同，即借方（左边）记录其金额增加额，贷方（右边）记录其金额减少额或转销数。
收入类账户借方（左边）记录其金额减少额或转销数，贷方（右边）记录其金额增加额。收入类账户和费用类账户本期发生额在月末应全部转入利润类账户，所以月末无余额；但成本类账户本期发生额月末不得转入利润类账户，所以月末一般有余额。利润类账户平时有期末余额，但在年末应将期末余额全部转入利润分配账户，所以年末无余额。
三、记账规则 （一）借贷记账法的记账规则
在借贷记账法下，对于任何一项经济业务，都必须同时在两个或以上账户进行登记，其中一个（或几个）账户在借方登记，另一个（或几个）账户一定在贷方登记，且记入借方账户的金额不记入贷方账户的金额必定相等。
因此，借贷记账法的记账规则是：有借必有贷，借贷必相等。
（二）借贷记账法的记账规则原理
1．复式记账法原理
根据复式记账原理规定，对任何一项经济业务都必须在两个或两个以上相互联系的账户中以相等的金额进行登记。
2．借贷记账法原理
借贷记账法是以会计恒等式为基本依据来计算每一个账户经济指标的，登记账户金额时要求对每个账户中涉及金额的增减必须以相反的方向进行记录。
3．对应关系原理
在借贷记账法下，经济业务发生后必然涉及到借贷方两类账户，这两类账户存在着应借、应贷的关系，这种关系称之为账户的对应关系；存在着相互对应关系的账户，称之为对应账户。
（三）借贷记账法的记账规则举例
[例2—1]江南机械制造有限公司在2017 年8 月份发生以下几项经济业务，以此分析发生的经济业务所涉及的账户、记账方向及金额。
（1）8 月6 日收到股东A 追加投入的资本500 万元，款项已存入银行。
这项业务应同时记入“银行存款”账户的借方和“实收资本”账户的贷方，且其金额均为500 万元。
资产类账户（增加额）借方 &lt;------&gt; 所有者权益类账户（增加额）贷方
（2）8 月10 日以存款70 万元归还欠供货单位购货款。
这项业务应同时记入“应付账款”账户的借方和“银行存款”账户的贷方，且其金额均为70 万元。
负债类账户（减少额）借方 &lt;------&gt; 资产类账户（减少额）贷方
（3）8 月15 日从银行提取现金5 000 元备用。
这项业务应同时记入“库存现金”账户的借方和“银行存款”账户的贷方，且其金额均为5 000 元。
资产类账户（增加额）借方 &lt;------&gt; 资产类账户（减少额）贷方
（4）8 月20 日向银行借入短期款项，直接偿还欠供应单位的货款660 000 元。
这项业务应同时记入 “应付账款”账户的借方和“短期借款”账户的贷方，且其金额相等均为660 000 元。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6988b760fcd45cc8abb1ed6f409100b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28b65094592db0799f6a2bf1c4efc852/" rel="bookmark">
			Spring的核心Spring-core
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.通过Maven获取Spring-core的架包以及依赖包 在pom.xml文件中。 &lt;!-- Spring依赖1：spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring依赖2：spring-beans --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.2.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring依赖3：spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; **注意：**Spring的三个依赖必须使用相同版本
2.Spring-core概念： Spring-cord相当于一个创建并管理bean的容器：
创建：底使用反射技术创建bean的实例管理：容器中的每个bean，spring容器默认按照单例模式管理。设计：使用工厂设计模式（BeanFactory） &lt;!--默认采用单例的方式管理Bean 默认状态下，获取该bean多次为同一个对象--&gt; &lt;!--单例模式：scope默认为：singleton 只会创建一个对象 prototype 会创建多个对象--&gt; &lt;!--init-method属性：用于声明初始化方法--&gt; &lt;!--destroy-method属性：用于声明销毁方法--&gt; &lt;bean id="messageServiceBean" class="com.apesource.service.impl.MessageServiceImpl" scope="prototype" init-method="init" destroy-method="destroy"/&gt; 两种获取Spring容器的方式：
ClassPathXmlApplicationContext:在classpath路径下加载xml配置文件，完成Spring容器的加载；或者采用注解方式时，需要在xml配置文件中使用&lt;context:component-scan /&gt;完成类扫描。ApplicationContext context = new ClassPathXmlApplicationContext("spring-config2.xml"); AnnotationConfigApplicationContext:基于注解配置的Spring容器加载方式。ApplicationContext context = new AnnotationConfigApplicationContext("com.apesource"); 3.IOC（Inverse Of Control）与DI（Dependency Injection） IOC和DI分别指的是控制反转和依赖注入，将项目中的类（组件）交给Spring容器管理，按照组件之间彼此的依赖关系（采用xml配置文件或者注解或者Javaconfig），完成组件之间的注入，降低组件之间的耦合。
三种注入方式：
属性setter注入 &lt;!--1.属性注入--&gt; &lt;property name="messageService" ref="messageServiceBean"/&gt; 构造注入（使用有参构造方法进行注入）&lt;!--2.构造方法注入--&gt; &lt;constructor-arg name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28b65094592db0799f6a2bf1c4efc852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0be805a4ede6e8d958e58347ba1c79bf/" rel="bookmark">
			使用curl发送post请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用curl发送post请求例子：
curl -H "Content-Type:application/json" -X POST -d '{"data":"xxxx"}' '接口地址' -H：请求头类型
-X ：请求方式
-d 或者–data ：请求参数
作为后端开发，难免在生产环境会出现按钮没权限或是定时任务里调用接口失败后需要重新调用的情况，就可以使用curl,直接在生产的服务器上直接调用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47bb6212abfe1980cf86444621cddff3/" rel="bookmark">
			VS2017MFC使用Teechart绘制图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载注册Teechart5.ocx TeeChart5.ocx 文件可以访问 https://pan.baidu.com/s/1EI65DOJgdQKl2603MBq0Pw 进行下载
注册过程
1）准备好 TeeChart5.ocx 文件；
2 ） 32 位 系 统 将 其 放 在 C:\Windows\System32 目 录 下 ， 64 位 系 统 将 其 放 在 C:\Windows\SysWOW64 目录下，
3）在该目录下以管理员身份运行命令提示符（可以在该目录下找到 cmd.exe，以管理员身 份运行即可），通过 regsvr32 命令注册该控件，64 位系统注册过程如下。
注册命令
1:regsvr32TeeChart5.ocx
2:regsvr32C:\Windows\SysWOW64\TeeChart5.ocx 注册成功会弹出以下提示：
二、新建MFC工程
右键-&gt;插入ActiveX控件
选择TeeChart Pro Activex control v5
添加TeeChart控件之后，右击控件，选择添加变量，vs会自动给我们引入CTchart1这个类
有的小伙伴可能会报以下的错
找到报错的地方 ，注释掉就好了
但是只有CTchart1这个类，我们是远远不够的，需要添加teechart其他相关的类
我暂时只添加CSeries这个类
在工程的.h文件中引入 #include “CSeries.h”
接下来进行测试
画折线图 CSeries data1; data1 = (CSeries)m_Teechart.Series(0); int count_line = 0; //在画线之前把图形清除一下，否则会覆盖，清除可用CSeries的函数Clear(); //但是当添加多个Series后要对所有Series都clear，这是很蛋疼的， //因为你有时都不知道有多少个Series，这样可以先获得Series的总数在clear代码如下 count_line = m_Teechart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47bb6212abfe1980cf86444621cddff3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2c4d28888dd2c91177cd153163ce9a8/" rel="bookmark">
			RSA非对称加密算法的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密和解密使用的是两个不同的密钥，这种算法叫作非对称加密算法。反之，用相同的密钥去加密和解密就是对称加密算法。
非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey)
公开密钥和私有密钥是一对如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。 优点：其安全性更好，非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，而对称加密需要在交互前将密钥告诉对方。
缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。
在非对称加密中使用的主要算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。
在对称加密中使用的主要算法有：DES（Data Encryption Standard）、3DES（Triple DES）、AES（Advanced Encryption Standard）、Blowfish等。
RSA算法原理(来自百度百科)
RSA公开密钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。
RSA的应用场景：
在跟银行，税局等金融行业交互过程中经常用到。
下面说一种对称加密和非对称加密配合使用的例子：
客户端采用RSA非对称加密去对对称加密需要的key进行加密处理。再用未加密的密钥key，使用对称加密算法对需要传输的数据进行对称加密。
最终将非对称加密后的key和对称加密后的数据都传输给服务端。
服务端接收到数据后，就可以先采用非对称解密获取到原始的key，再使用这个key对称解密，获取到原始的数据。
其好处有两个：
非对称加密解密花费时间长，故只对对称加密需要的key进行加密处理，提升性能；加密需要的key采用非对称加密，可确保key的安全性。 DESEncrypt.java
import com.sun.org.apache.xml.internal.security.utils.Base64; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.DESKeySpec; public class DESEncrypt { public DESEncrypt() { } public static String getDESKey() { try { KeyGenerator keyGenerator = KeyGenerator.getInstance("DES"); keyGenerator.init(56); SecretKey generateKey = keyGenerator.generateKey(); byte[] encoded = generateKey.getEncoded(); String encodeHexString = toHexString(encoded); return Base64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2c4d28888dd2c91177cd153163ce9a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45cfd5deecf76a06a127da60fdda160/" rel="bookmark">
			第6章函数-3 使用函数统计指定数字的个数 (20分)【Python版本】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求实现一个统计整数中指定数字的个数的简单函数。
CountDigit(number,digit )
其中number是整数，digit为[1, 9]区间内的整数。函数CountDigit应返回number中digit出现的次数。
函数接口定义： 在这里描述函数接口。例如： CountDigit(number,digit ),返回digit出现的次数 裁判测试程序样例： /* 请在这里填写答案 */ number,digit=input().split() number=int(number) digit=int(digit) count=CountDigit(number,digit ) print("Number of digit 2 in "+str(number)+":",count) 输入样例： 在这里给出一组输入。例如：
-21252 2 输出样例： 在这里给出相应的输出。例如：
Number of digit 2 in -21252: 3 【Python参考代码】 #By yangbo 2020.08.11 def CountDigit(number,digit): num =str(number) dig = str(digit) return num.count(dig) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbc98750962d932ab9efe330ce3cee5/" rel="bookmark">
			The container name “/xx“ is already in use by container “xx“. You have to remove (or rename) that
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题 D:\Users\chengyq&gt;docker run -d --name clickhouse-server --ulimit nofile=262144:262144 -p 8123:8123 -v //D/clickhouse/config.xml:/etc/clickhouse-server/config.xml --volume=//D/clickhouse:/var/lib/clickhouse yandex/clickhouse-server docker: Error response from daemon: Conflict. The container name "/clickhouse-server" is already in use by container "c1760937eac6d9838fa356daa30a03acd16c7c7709eeb9c6677b18b98ff19abc". You have to remove (or rename) that container to be able to reuse that name. See 'docker run --help'. 提示：容器名被占用，需要移除或重命名这个容器名
2、解决办法 D:\Users\chengyq&gt;docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 先查看所有的容器
D:\Users\chengyq&gt;docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 77156067410e spoonest/clickhouse-tabix-web-client "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fbc98750962d932ab9efe330ce3cee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e658ce6dfce92193407297e6db2d308d/" rel="bookmark">
			[Leetcode][第93题][JAVA][复原IP地址][剪枝][回溯]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】[中等] 【解答思路】 1. 递归 回溯剪枝 复杂度
class Solution { static final int SEG_COUNT = 4; List&lt;String&gt; ans = new ArrayList&lt;String&gt;(); int[] segments = new int[SEG_COUNT]; public List&lt;String&gt; restoreIpAddresses(String s) { segments = new int[SEG_COUNT]; dfs(s, 0, 0); return ans; } public void dfs(String s, int segId, int segStart) { // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案 if (segId == SEG_COUNT) { if (segStart == s.length()) { StringBuffer ipAddr = new StringBuffer(); for (int i = 0; i &lt; SEG_COUNT; ++i) { ipAddr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e658ce6dfce92193407297e6db2d308d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97bc895a5bdac07923d195dacb9b74da/" rel="bookmark">
			嵌入式-ARM-学习总结（2）：点亮LED，我是嵌入式点灯工程师！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入式-ARM-学习总结（2）：点亮LED，我是嵌入式点灯工程师！ 一、通过GPIO控制点亮LED1.LED点亮的原理：2.GPIO是什么 一、通过GPIO控制点亮LED 首先说一下LED这个外设，相信都是从点灯开始的，从51，到stm32，到fpga，到现在这篇写的ARM。LED作为一个简单的，直观的外设，可以让新手快速切入到对于开发板内部的理解。
1.LED点亮的原理： D26是指示电源状态，只要上电就会常亮。
D22：GPJ0_3
D23：GPJ0_4
D24：GPJ0_5
D25：PWMTOUT1(GPD0_1)
正级已经为3.3V固定，如果想要LED变亮，就需要哪个引脚属0。
2.GPIO是什么 GPIO:general purpose input output 通用输入输出
软件操作硬件的接口是：寄存器。
这个时候需要查阅所用开发板的数据手册。
通过硬件手册(上图)，控制LED的是GPJ0
查阅数据手册可知，GPJ0相关的寄存器有以下：
GPJ0CON(GPJ0 control):GPJ0控制寄存器，用来配置各引脚的工作模式 GPJ0DAT(GPJ0 data):当引脚配置为input/output模式时，寄存器的相应位和引脚的电平高低相对应。
GPJ0PUD(pull up down):控制引脚内部弱上拉、下拉
GPJ0DRV(driver):配置GPIO引脚的驱动能力
GPJ0CONPDN(记得是低功耗模式下的控制寄存器）
GPJ0PUDPDN (记得是低功耗模式下的上下拉寄存器）
在驱动LED点亮时，应该将GPIO配置为output模式。
所以实际上想要控制LED，实际上要控制的寄存器是GPJ0CON和GPJ0DAT，步骤是
操控GPJ0CON寄存器中，选中output模式操控GPJ0DAT寄存器，相应的位设置为0 GPJ0_3对应的位为bit12~bit15,譬如给bit12～bit15写入0b0001，GPJ0_3引脚就成为输出模式了。
根据数据手册，GPJ0CON（0xE0200240）寄存器和GPJ0DAT（0xE0200244）寄存器地址为上图。
点亮LED代码：
_start: // 第一步：把0x11111111写入0xE0200240(GPJ0CON)位置 ldr r0, =0x11111111	// 从后面的=可以看出用的是ldr伪指令，因为需要编译器来判断这个数 ldr r1, =0xE0200240	// 是合法立即数还是非法立即数。一般写代码都用ldr伪指令 str r0, [r1]	// 寄存器间接寻址。功能是把r0中的数写入到r1中的数为地址的内存中去 // 第二步：把0x0写入0xE0200244(GPJ0DAT)位置 ldr r0, =0x0	//如果要想改变LED点亮的状态，即可修改0x0来控制哪个LED的亮灭 ldr r1, =0xE0200244 str r0, [r1]	// 把0写入到GPJ0DAT寄存器中，引脚即输出低电平，LED点亮 flag:	// 这两行写了一个死循环。因为裸机程序是直接在CPU上运行的，CPU会 b flag	// 逐行运行裸机程序直到CPU断电关机。如果我们的程序所有的代码都 // 执行完了CPU就会跑飞（跑飞以后是未定义的，所以千万不能让CPU // 跑飞），不让CPU跑飞的办法就是在我们整个程序执行完后添加死循环 流水灯：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97bc895a5bdac07923d195dacb9b74da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8954b2c9a3c2805fcc0eb99ad50a400/" rel="bookmark">
			深入理解Object.prototype.toString方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解Object.prototype.toString方法 ECMAScript 3ECMAScript 5ECMAScript 6ECMAScript 7附言 ECMAScript 3 在toString方法被调用时,会执行下面的操作步骤:
获取this对象的[[Class]]属性的值.（第一步）
计算出三个字符串"[object ", 第一步的操作结果Result(1), 以及 "]"连接后的新字符串.（第二步）
返回第二步的操作结果Result(2). （第三步）
[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的
[[Class]] 一个字符串值,表明了该对象的类型.
所有内置对象的[[Class]]属性的值是由本规范定义的.
所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.
[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值。
ECMAScript 5 在ECMAScript 5中，Object.prototype.toString()被调用时，会进行如下步骤：
1 如果 this是undefined ，返回 [object Undefined] ；
2 如果 this是null ， 返回 [object Null] ；
3 令 O 为以 this 作为参数调用 ToObject 的结果；
4 令 class 为 O 的内部属性 [[Class]] 的值；
5 返回三个字符串 “[object”, class, 以及"]" 拼接而成的字符串。
[[Class]]是一个内部属性，值为一个类型字符串，可以用来判断值的类型。
有这么一段详细的解释：
本规范的每种内置对象都定义了 [[Class]] 内部属性的值。宿主对象的 [[Class]] 内部属性的值可以是除了 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8954b2c9a3c2805fcc0eb99ad50a400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4267af5ae59c1d6de43542e79bfb074c/" rel="bookmark">
			window.open(‘‘, ‘_self‘)；作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		if ("IE" == mb) { alert("后台系统暂不支持该浏览器，建议使用谷歌或火狐浏览器"); window.opener = null; window.open('', '_self'); window.close(); } 作用：关闭窗口时不弹出提示弹窗
其中的原理：
window.open('','_self',''); =&gt;本窗口打开
window.opener=null; 父窗体置为null
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0ce39fef797bba475ddc7ca26eb734/" rel="bookmark">
			严重 [http-nio-8080-exec-1] org.apache.catalina.core.ApplicationDispatcher.invoke Servlet.service() fo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		严重 [http-nio-8080-exec-1] org.apache.catalina.core.ApplicationDispatcher.invoke Servlet.service() for servlet [jsp] threw exception org.apache.jasper.JasperException: /WEB-INF/views/front1/user/login.jsp (line: [3], column: [0]) The absolute uri: [http://java.sun.com/jsp/jstl/core] cannot be resolved in either web.xml or the jar files deployed with this application
错误内容 10-Aug-2020 12:38:35.805 严重 [http-nio-8080-exec-1] org.apache.catalina.core.ApplicationDispatcher.invoke Servlet.service() for servlet [jsp] threw exception org.apache.jasper.JasperException: /WEB-INF/views/front1/user/login.jsp (line: [3], column: [0]) The absolute uri: [http://java.sun.com/jsp/jstl/core] cannot be resolved in either web.xml or the jar files deployed with this application at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c0ce39fef797bba475ddc7ca26eb734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ba32d321bfe768e98f443a85ca4bc4/" rel="bookmark">
			faceswap介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网介绍地址：https://forum.faceswap.dev/viewtopic.php?t=146
介绍
很多人在开始交换脸时会不知所措，而且犯了很多错误。错误是好的。这是我们学习的方法，但有时在潜入之前对所涉及的过程有一点了解会有所帮助。
在这篇文章中，我将详细阐述我们如何训练模型。有几个型号，有许多选项。我不会覆盖一切， 但希望这会给你足够的， 作出明智的决定， 你自己。如果您尚未生成用于训练的面孔集，请立即停止，然后前往提取指南现在生成它们。
本指南中有很多背景
信息。我建议你熟悉一切。机器学习是一个复杂的概念，但我试图把它分解为尽可能简单易懂。对神经网络的工作原理有一个基本的了解，以及它从查看中获得的数据类型，将大大提高您成功交换的机会。
我将为本指南使用 GUI，但 cli 的前提完全相同（GUI 中存在的所有选项在 cli 中
可用）。
什么是培训？ 概述
在高层次上，培训正在教我们的神经网络 （NN） 如何重新创建面部。大多数型号主要由两部分组成： 编码器- 这具有将人脸负载作为输入，并"编码"它们为"矢量"形式的表示。需要注意的是，它不是学习您输入到它的每一面的精确表示，而是尝试创建一种算法，该算法可用于以后尽可能紧密地重建面与输入图像。解码器- 这具有将编码器创建的矢量并尝试将其表示回面的工作，尽可能与输入图像匹配。 为什么 1. png （7.17 Kib） 查看 92560 次
有些模型的构造略有不同，但基本前提保持不变。
NN 需要知道它如何做编码和解码
面。它使用 2 个主要工具来做到这一点： 损耗- 对于输入模型的每批面，NN 将查看它试图通过当前编码和解码算法重新创建的面，并将其与输入的实际面进行比较。根据它认为它做得如何，它将给自己一个分数（损失值），并将相应地更新其权重。权重- 模型评估其重新创建面的绩效后，将更新其权重。这些馈入编码器/解码器算法。如果它在一个方向上调整了重量，但觉得它在重建面部方面做得比以前差，那么它知道权重正向错误方向移动，因此它会以相反的方式调整它们。如果它感觉它有所改善，那么它知道不断调整的重量的方向，它去。 why2.png (22.21 KiB) Viewed 92560 times
然后，模型会多次重复此操作，多次根据其损失值不断更新其权重，理论上会随着时间的推移而提高，直到它到达一个点，你觉得它已经学会足够的有效重新创建面，或者损失值停止下降。
现在，我们拥有了神经网络做什么以及如何学会创建人脸的基础知识，这如何适用于人脸
交换？您可能已经注意到，在上述细分中，此 NN 学习如何拍摄一个人的面部负载，然后重建这些面孔。这不是我们想要的...我们想拿一大堆脸， 重建别人的脸。为此，我们的 NN 做几件事： 共享编码器- 当我们训练我们的模型时，我们喂它两组脸。A 集（我们要替换的原始面）和 B 集（我们希望在场景中放置的交换面）。实现此目的的第一步是共享 A 和 B 集的编码器。这样，我们的编码器正在为 2 个不同的人学习单个算法。这一点非常重要，因为我们最终将告诉我们的神经网络，采取一张脸的编码，并解码到另一张脸。因此，编码器需要查看并了解交换所需的两组面。切换解码器- 训练模型时，我们训练 2 个解码器。解码器 A 正在拍摄编码向量并尝试重新创建面 A。 解码器 B 正在拍摄编码向量并尝试重新创建面 B。当涉及到最终交换面时，我们切换解码器，因此我们馈送模型面 A，但通过解码器 B 传递它。由于编码器已对两组面进行训练，因此模型将编码输入的 A 面，但随后尝试从解码器 B 重建它，从而导致交换的面从我们的模型输出。 why3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43ba32d321bfe768e98f443a85ca4bc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc7820baa6d336b6bb5c09995c7cbac/" rel="bookmark">
			音频分离Spleeter的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		音频分离Spleeter的安装 1.环境依赖及建立（需要已安装anaconda）1.0 项目源地址（github地址）1.1 创建虚拟环境1.2 激活虚拟环境1.3 conda 安装spleeter1.4 下载一个示例音乐1.5 将该音乐分离为两部分1.5.1 报错：No module named numba.decorators1.5.2 解决方案： 1.6 下载分类模型1.6.1报错ValueError:Can't load save_path when it is None.1.6.2 解决方案：1.6.3 继续运行1.6.4 查看分离结果 2. 参考 音轨分离软件 spleeter，只需输入一段命令就可以将音乐的人声和各种乐器声分离，支持 mp3、wav、ogg 等常见音频格式。 Spleeter 基于 TensorFlow 开发，本身运行速度非常快。分离过程可以在 GPU 或 CPU 上执行。在 GPU 上运行，如果它将音频文件分成四个音轨，可以比实时速度快 100 倍。 作为一位研究音频的学生，还是忍不住来接触了一下，接触后自觉 该模型也确实不错 ，不然也不可能在短短几周在github标星上千。总而言之，就是 向大佬学习 。 1.环境依赖及建立（需要已安装anaconda） 1.0 项目源地址（github地址） 具体内容可以参看原作者的github地址：
spleeter项目github链接
1.1 创建虚拟环境 conda create -n spleeter python=3.7 1.2 激活虚拟环境 conda activate spleeter 激活之后是这样的：
1.3 conda 安装spleeter conda install -c conda-forge spleeter 这里要安装的文件还是比较多的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cc7820baa6d336b6bb5c09995c7cbac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9758a6aa9ebd0bd28e56f80b8e1ab8d1/" rel="bookmark">
			fMRI之dpabi处理经验（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fMRI dpabi处理经验（一） dpabi用以处理fMRI、MRI数据非常好的matlab工具箱，下载地址：dpabi。下面来介绍下我在学习使用的过程中遇到的问题及操作吧。
fMRI处理常见问题 打开matlab后再命令窗口输入dpabi打开界面，fMRI使用dparsf界面：
脑区划分 ，点击Define ROI，进入后默认有9种脑区划分模板（各种自带模板介绍网址http://mrirc.psych.ac.cn/RfMRIMapsDataSharingStructure），Remove不需要的，保留需要的，也可以通过“+Mask”添加；（ps：贴一个搜集到的脑区划分模板资料网址：http://ftp.nmr.mgh.harvard.edu/pub/dist/freesurfer/tutorial_packages/centos6/fsl_507/doc/wiki/Atlases.html）
（http://neuro.debian.net/pkgs/fsl-harvard-oxford-atlases.html）我也是初学者，搜集到的资料很少，如果各位有其他的网址、资料恳请在评论区留言，感谢！Reorient T1* 在选择这一项后，在处理过程中会跳出手动定位界面，需将定位十字点在前联合上，具体位置如下：
如果影像中头部很歪斜可以调整俯仰角等，或直接略过 ； MRI处理常见问题 VBM 功能，可以通过VBM处理T1*数据，选择如图VBM（unified）可以先筛查一下那些图不能用，然后使用VBM（New segment），这个好像是结果与每一个影像数据有关，所以一定提前筛查好；
FWHM 一般默认为[4 4 4]但是，MRI时常用[6 6 6]，这个我也不是很懂，等我去学一学在补充上这块的知识；
MRI脑区划分后提取灰质白纸体积MRI也可以脑区划分后，计算不同脑区的灰质、白质体积（或者密度），但是不能直接在VBM界面内。如图3：
选中ROI signal extractor后，在define ROI中添加脑区模板即可。注意！！！，这里面的define ROI前需要改一下 voxe size，即重采样， 看看自己的数据体素大小是否和脑区划分模板的大小相同；查看方法：spm_vol_nifti()用这个命令（例如：spm_vol_nifti(‘mwc1mprage.nii’，记得影像文件和命令在一个目录下)，可以看到你处理完的图像（上一步结果里，mwc1是灰质、mwc2是白质，都是在标准空间下的，所以做体积、密度都用这个）的dim（可以理解为分辨率），如图4；若处理得到的图像是[121 145 121]，而脑区模板,aii的是[181 217 181],181=121*1.5,所以可以将脑区模板，例如aii重采样成“voxel size：[1.5 1.5 1.5]”,方法是点击“Image reslicer”，将aii所在文件夹add进去，勾选“reference”，并参考自己所得到的影像文件；（注意：ROI signal extractor，里add direction，文件夹里至少两个文件）；
##########这是一个更新的分界线#########原谅我垃圾的排版####
解决原始nifti数据图像头是旋转90度的或者说镜像的，与dpabi给的默认主视图、俯视图、等等头部方向不一致的问题：
大神给我的解决方案：关于reorient这一步，如果原始文件的头朝向跟标准朝向（即大脑模板的朝向）不一致的话，建议一定要做，否则会导致后续在头动校正、组织分割的过程中报错或者无法配准或者分割失败的情况。具体操作的话，如果人数比较少，你可以在spm里面自己手动调整，如果多的话，我印象中spm的cat12工具包中有一个reorient的工具可以进行批量处理（dpabi中应该也有，但我不太确定是否有独立的code）。
还没动手尝试，成功了再回来更新。 楼主转行了，影像没基础太难了，不干了！！去搞脑电去了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/742763586d732a9ad9bec8118a70d490/" rel="bookmark">
			c# IntPtr 指针详理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c# IntPtr 指针详理解 IntPtr是什么 C#中的IntPtr类型称为“平台特定的整数类型”，它们用于本机资源，如窗口句柄。
资源的大小取决于使用的硬件和操作系统，但其大小总是足以包含系统的指针（因此也可以包含资源的名称）。
所以，调用的API函数中一定有类似窗体句柄这样的参数，那么当您声明这个函数时，您应该将它显式地声明为IntPtr类型。
It’s a class that wraps a pointer that is used when calling Windows API functions. The underlying pointer may be 32 bit or 64 bit, depending on the platform.
用在哪 （1）C#调用WIN32 API时
（2）C#调用C/C++写的DLL时（其实和1相同，只是这个一般是我们在和他人合作开发时经常用到）
怎么用 示例： //在一个C#程序中调用Win32API mciSendString函数控制光盘驱动器，这个函数的函数原型是： MCIERROR mciSendString( LPCTSTR lpszCommand, LPTSTR lpszReturnString, UINT cchReturn, HANDLE hwndCallback ); //首先在C#中声明这个函数： [DllImport("winmm.dll")] private static extern long mciSendString(string a,string b,uint c,IntPtr d); //然后用这样的方法调用： mciSendString("set cdaudio door open"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/742763586d732a9ad9bec8118a70d490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a7b23076f9345cddc81fa2f0a719ee/" rel="bookmark">
			CentOS7 yum源安装EPEL/ELRepo扩展仓库步骤详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接 https://www.jianshu.com/p/1dce9ff6f4af
yum search +软件名 yum search php 查看php可用的包 yum -y install php56u 安装5.6版本 yum -y install php56u-mbstring 安装mbstring扩展 一、EPEL库 EPEL 是 yum 的一个软件源, 里面包含了许多基本源里没有的软件了。EPEL, 即 Extra Packages for Enterprise Linux 的简称, 是为企业级 Linux 提供的一组高质量的额外软件包, 包括但不限于 Red Hat Enterprise Linux (RHEL), CentOS and Scientific Linux (SL), Oracle Enterprise Linux (OEL). 但在我们在使用 epel 时是需要安装它才可以了, 下文来介绍 CentOS7/RHEL7 安装 EPEL 步骤
2 为 CentOS7/RHEL7 安装 EPEL 仓库 2.1 方法一 : 命令安装
yum -y install epel-release 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a7b23076f9345cddc81fa2f0a719ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/304276906bd039bccd1d2ef7b2a61376/" rel="bookmark">
			python合并excel的多个sheet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介openpyxl方式pandas方式 简介 因为，每天都会有的大量excel报表汇总处理任务，所以写了一个脚本来处理。
就是找出每一个excel中特定的sheet，把这些sheet的特定列读取出来合并到一个sheet中。
因为每一个sheet的数据都不太一样，所以稍微麻烦一点，下面使用openpyxl方式和pandas两种方式来处理。
openpyxl方式 使用openpyxl方式要自己实现合并逻辑，要麻烦一些。值得注意的是，在excel中可能有公式，读取excel的时候可以使用下面的方式：
load_workbook(data_file_path, data_only=True)
使用data_only=True,就可以得到公式计算之后的值，而不是公式本身，因为公式本身合并在另一个sheet中，公式可能就无效，甚至不对了。
下面给一个示例代码，仅供参考：
""" pip install openpyxl """ from openpyxl import load_workbook from openpyxl import Workbook import os import re # 模板文件 TEMPLATE_FILE = r'H:\合并\合并模板.xlsx' # 合并结果文件 RESULT_FILE = r'H:\合并\结果.xlsx' # 数据文件目录 DATA_ROOT_DIR = r"H:\合并" # 文件名称正则 DATA_FILE_REG = r"(.*?)-合同导入台账\d{8}.xlsx" # 获取要处理的文件 def get_deal_file_map(): file_sn_map = {} fs = os.listdir(DATA_ROOT_DIR) for f in fs: match = re.match(DATA_FILE_REG, f) if match: city = match.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/304276906bd039bccd1d2ef7b2a61376/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/420/">«</a>
	<span class="pagination__item pagination__item--current">421/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/422/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>