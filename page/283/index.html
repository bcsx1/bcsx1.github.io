<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251b52fa7d1c09834c1453688467acc0/" rel="bookmark">
			C语言-break与continue语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、break语句 break语句是强制结束循环，例如for循环中使用break：
for (表达式1;表达式2;表达式3){ 语句1; break; 语句2; } 其流程图如下：
从流程图可以看到，若使用break语句，将直接结束循环，执行for的下一条语句，不再执行循环体中位于其后的其他语句了。而流程图中break的判断框一般是与if搭配使用，代表若条件满足，则执行break跳出循环；若条件不满足，则不执行break语句，执行循环体后面的语句。 从流程图中可以看到，循环有2个出口，分别是表达式2的值为“假”或执行了break语句，这两个条件有一个满足都会结束循环，有时候需要判断循环时如何结束的。
例1：判断素数 输入正整数m，判断它是不是素数。
#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { int i, limit, m; printf("Enter a number:"); scanf("%d", &amp;m); if (m &lt;= 1){	/*小于等于1的数不是素数*/ printf("No!\n"); } else if (m == 2){	/*2是素数*/ printf("%d is a prime number!\n", m); } else {	/*其他情况：大于2的正整数*/ limit = sqrt(m)+1; for (i=2; i&lt;=limit; i++){ if (m%i == 0){ break;	/*若m能被某个i整除，则m不是素数，提前结束循环*/ } } if (i &gt; limit){	/*若循环正常结束，说明m不能被任何一个i整除*/ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/251b52fa7d1c09834c1453688467acc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89a6ef1c8c0eb6811566c4e9eec07a8f/" rel="bookmark">
			批量删除文件名部分文字，详细图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么批量删除文件名部分文字？不管是日常工作还是在学习中，我们经常需要用到电脑整理文件，也经常对文件名进行修改，例如删除文件名中的某些文字，只需要右击文件，然后点击“重命名”进行删除修改即可，是比较简单的操作。如果有大量的文件名中都包含某部分文字，现在需要批量删除文件名中的这部分文字，你知道如何处理吗？
这就涉及电脑批量重命名的相关操作技巧了，据我所知，知道如何操作的人并不多，所以学会这个技能是多么的重要。今天小编就来教你如何一键批量删除文件名部分文字，请看详细的图片教程，一起操作，相信你可以在一分钟内学会。
借助的工具：优速文件批量重命名
请看详细的操作步骤：
步骤1，先打开电脑，然后再打开已经安装好了的“优速文件批量重命名”工具软件，点击首页左边的【文件重命名】功能，再进入内页进行下一步操作。
步骤2，进入内页后点击左上方【添加文件】蓝色按键，将需要修改名称的文件全部导入到软件中，导入完成后文件名会显示在软件上。
步骤3，进行重命名设置，命名方式选择“删除”；删除类型选择“自定义内容”；然后在下一行输入需要删除的相同部分文字，这时候在右边可以对新文件名进行预览，检查效果。
步骤4，设置没有问题后点击右上角【开始重命名】红色按键，启动软件，当软件弹出“重命名成功”的提示时，说明所有文件名已经修改完成。
步骤5，从上面的结果可以看到，原本所有文件名称中的“资料”两个字被全部删除了。
批量删除文件名中的部分文字，看似一个简单的工作任务却能难倒不少小伙伴，如果没有学会这个电脑技巧，不管有多少文件名称需要去修改，都能在几十秒内完成操作，简直就是提高办公效率的利器。上面关于“批量删除文件名部分文字”的详细图片教程相信大家都看得懂吧，快去试一试吧，看看效果如何。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e646f9486be0f243a450ce7a83a4378b/" rel="bookmark">
			KORNIA与torch 版本存在依赖关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KORNIA 0.58对应torch 1.7
以上对应1.8
可以多下载几个多次安装，直到支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/495a2b36c82bf3a2d7d6fd1c372f377d/" rel="bookmark">
			c&#43;&#43;: Logger日志信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念： 日志可以记录正常软件运行过程中出现的信息和错误的信息，当我们定位问题，就打开相应的日志去查看，查找；
日志的作用： 在软件开发周期中，不管是前台后台，系统一般会采用一个持久化的日志系统来记录运行情况。
在代码中嵌入log代码信息，主要记录下列信息：
（1）系统运行异常信息。
（2）系统运行状态信息。
（3）系统运行性能指标。
日志级别： 一般分5个级别：
ERROR（错误）：此信息输出后，主体系统核心模块不能正常工作，需要修复才能正常工作。WARN（警告）：此信息输出后，系统一般模块存在问题，不影响系统运行。INFO（通知）：此信息输出后，主要是记录系统运行状态等关联信息。DEBUG（调试）：最细粒度的输出，除却上面各种情况后，你希望输出的相关信息，都可以在这里输出。TRACE（跟踪）：最细粒度的输出，除却上面各种情况后，你希望输出的相关信息，都可以在这里输出。 logger日志系统的实现： 在src下的include增加头文件：logger.h；将logger.h，logger.cpp添加到项目中；设置logger.cpp的预编译头选项为“不使用预编译头”；即一个自实现的日志文件系统，由log.h和log.cpp构成 在log.h文件中定义宏：
//定义宏 LOG_INFO("xxx %d %s", 20, "xxxx") //可变参，提供给用户更轻松的使用logger #if(ENABLE_LOGGING) #define log_info() Logger(Logger::LogLevel::Info) #define log_warning() Logger(Logger::LogLevel::Warning, "Warning") #define log_error() Logger(Logger::LogLevel::Error, "Error") #define log_debug() Logger(Logger::LogLevel::Debug, "DEBUG", __FILE__, __LINE__) #define log_noendl Logger::Noendl() #define log_nospace Logger::Nospace() #else #define log_info() NoLogger() #define log_warning() NoLogger() #define log_error() NoLogger() #define log_debug() NoLogger() #define log_noendl 0 #define log_nospace 0 class NoLogger { public: template&lt;typename T&gt; NoLogger&amp; operator&lt;&lt;(const T&amp; val) { return *this; } }; #endif 在log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/495a2b36c82bf3a2d7d6fd1c372f377d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cb6cb92fc64d93af582c8fe56023ef4/" rel="bookmark">
			Altium Designer将原理图导出到PDF时部分引脚名称消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DXP -&gt; Preferences -&gt; Schematic -&gt; General 下的 “Render Text with GDI+”，把选项前面的对勾去掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e7feff9782a86b00c7f218f7e66070/" rel="bookmark">
			基于DnCNN的图像和视频去噪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“小白学视觉”，选择加"星标"或“置顶”
重磅干货，第一时间送达 简介
随着数字图像数量的增加，对高质量的图像需求也在增加。然而，现代相机拍摄的图像会因噪声而退化。图像中的噪声是图像中颜色信息的失真，噪声是指数字失真。当在夜间拍摄时，图像变得更嘈杂。该案例研究试图建立一个预测模型，该模型将带噪图像作为输入并输出去噪后的图像。
深度学习的使用
这个问题是基于计算机视觉的，CNN等深度学习技术的进步已经能够在图像去噪方面提供最先进的性能，用于执行图像去噪的模型是DnCNN（去噪卷积神经网络）。
数据集
BSD300和BSD500数据集均用作训练数据，BSD68用于验证数据。由于数据有限，每个图像使用了4次，即缩放到[1.0,0.7,0.8,0.7]。
每个缩放图像被分割成50x50的块，步幅为20。每个贴片都添加了一个标准偏差在[1,55]之间的高斯噪声。数据生成代码如下所示：
#Fix Noise stddevs = np.random.uniform(1, 55.0, 125000)[:, np.newaxis, np.newaxis, np.newaxis] noise = np.random.normal(loc = 0, scale=stddevs, size=(125000, 50, 50, 3)).astype(np.float16) def get_dataset(img_path): def image_generator(): patch_size = 50 stride = 20 index = 0 for scale in [1, 0.9, 0.8, 0.7]: for path in img_path: true_img = cv2.imread(path) for i in range(0, true_img.shape[0] - patch_size + 1, stride): for j in range(0, true_img.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e7feff9782a86b00c7f218f7e66070/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d165b11b970f92fb918ea719932877d8/" rel="bookmark">
			实战案例：使用机器学习算法预测用户贷款是否违约?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，最近一张"因疫情希望延缓房贷"的截图在网上流传，随即引起网友们的热议！
当借款人从贷款机构借钱而不能如期还贷款时，就可能会发生贷款违约。拖欠贷款不仅会上报征信，还可能有被起诉的风险。
为更好的管控风险，贷款机构通常会基于用户信息来预测用户贷款是否违约，今天我将使用示例数据集来给大家讲解预测贷款违约的工作原理，原创不易，喜欢本文记得点赞、关注、收藏，完整版数据和代码文末获取。
【注】文末提供技术交流群
数据 数据中包含每个客户的人口统计特征和显示他们是否会拖欠贷款的目标变量。
首先，我们导入库并加载数据集。
import numpy as np # linear algebra import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv) import matplotlib.pyplot as plt import seaborn as sns %matplotlib inline sns.set_theme(style = "darkgrid") data = pd.read_csv("/kaggle/input/loan-prediction-based-on-customer-behavior/Training Data.csv") data.head() 探索数据集 首先，我们从了解数据及数据分布开始
rows, columns = data.shape print('Rows:', rows) print('Columns:', columns) 输出
Rows: 252000 Columns: 13 我们看到数据有252000行和 13 个特征，其中 12 个是输入特征，1 个是输出特征。
现在我们检查数据类型和其他信息。
data.info() 输出
RangeIndex: 252000 entries, 0 to 251999 Data columns (total 13 columns) # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Id 252000 non-null int64 1 Income 252000 non-null int64 2 Age 252000 non-null int64 3 Experience 252000 non-null int64 4 Married/Single 252000 non-null object 5 House_Ownership 252000 non-null object 6 Car_Ownership 252000 non-null object 7 Profession 252000 non-null object 8 CITY 252000 non-null object 9 STATE 252000 non-null object 10 CURRENT_JOB_YRS 252000 non-null int64 11 CURRENT_HOUSE_YRS 252000 non-null int64 12 Risk_Flag 252000 non-null int64 dtypes: int64(7), object(6) memory usage: 25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d165b11b970f92fb918ea719932877d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce11de134761b3a55bff8755b4124b4e/" rel="bookmark">
			matlab中将数据导出到Excel表格、.txt、.xml等文件中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本人应用例子 导出效果：第一行为提示，所以在设置表格行数时需要+1，如上图
matlab官网例子 load patients.mat T = table(LastName,Age,Weight,Smoker); T(1:5,:) ans=5×4 table LastName Age Weight Smoker ____________ ___ ______ ______ {'Smith' } 38 176 true {'Johnson' } 43 163 false {'Williams'} 38 131 false {'Jones' } 40 133 false {'Brown' } 49 119 false 将表 T 写入到名为 patientdata.xlsx 新电子表格文件中的第一张工作表，并从单元格 D1 处开始。要指定您想要写入到的工作表部分，请使用 Range 名称-值对组参数。默认情况下，writetable 将表变量名称写入为电子表格文件中的列标题。
filename = 'patientdata.xlsx'; writetable(T,filename,'Sheet',1,'Range','D1') 将不带变量名称的表 T 写入名为 'MyNewSheet' 的新工作表。要写入不带变量名称的数据，请将名称-值对组 WriteVariableNames 指定为 false。
writetable(T,filename,'Sheet','MyNewSheet','WriteVariableNames',false); matlab常用的相关函数 将 matlab中的数组导出到Excel表格、.txt、.xml等文件中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce11de134761b3a55bff8755b4124b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78718d7ec1246dc7b937057edea1db49/" rel="bookmark">
			计算机组成原理学习笔记之溢出的判定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		溢出可分为由定点数运算产生的溢出和由浮点数运算所产生的溢出。
对于定点数来说
但对于浮点数来说
其上溢和下溢的概念和定点数是不同的
对于溢出的判断方法
1.采用一位符号法
即参加运算的两个数符号相同，进行运算后的结果符号改变，则发生了溢出
2. 采用双符号法（模4补码）
运算结果
00 无溢出
01 正溢出
10 负溢出
11 无溢出
3. 采用一位符号法
若符号位进位与最高数值位进位相同 无溢出
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/571f0f2780e9404c17218b1c44699cf3/" rel="bookmark">
			超详细前端八股文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在掘金看到一篇特别好的前端八股文，链接：https://juejin.cn/post/7016593221815910408
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a293c326d03295c9aff50c6bf4d816/" rel="bookmark">
			Kubernetes实战入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过本篇文章记录如何在Kubernetes集群中部署一个nginx服务，并且能够对其进行访问
1、Namespace Namespace是Kubernetes系统中的一种非常重要的资源，它的主要作用是用来实现多套环境的资源隔离或者多租户的资源隔离
默认情况下，Kubernetes集群中的所有Pod都是可以相互访问的，但是我们再实际过程中很可能不想让两个Pod之间进行相互的访问，那么此时就可以将两个Pod划分到不同的namespace下。Kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的“组”，以方便不同的组的资源进行隔离使用和管理。(多套环境资源隔离)
可以通过Kubernetes的授权机制，将不同的Namespace交给不同的租户进行管理，这样就实现了多租户的资源隔离。此时还能结合Kubernetes的资源配额机制，限定不同租户所能占用的资源，例如CPU的使用量，内存的使用量等等，以实现租户可用资源的管理。（多租户的资源隔离）
在Kubernetes集群启动之后，是会默认创建几个Namespace的
[root@master ~]# kubectl get ns NAME STATUS AGE default Active 2d19h #所有未指定Namespace的对象都会被分配在default空间 kube-node-lease Active 2d19h #集群节点之间的心跳维护，从v1.13开始引入 kube-public Active 2d19h #此命名空间下的资源可以被所有人访问（包括未认证用户） kube-system Active 2d19h #所有由Kubernetes系统创建的资源都处于这个命名空间 下面可以来看看Namespace资源的具体操作：
# 1、查看所有Namespace [root@master ~]# kubectl get ns NAME STATUS AGE default Active 2d19h dev Active 19h kube-node-lease Active 2d19h kube-public Active 2d19h kube-system Active 2d19h # 2、查看指定的Namespace 命令：kubectl get ns &lt;NSname&gt; [root@master ~]# kubectl get ns dev NAME STATUS AGE dev Active 19h # 3、指定输出格式 命令：kubectl get ns &lt;NSname&gt; -o &lt;格式参数&gt; # Kubernetes支持的格式有很多，比较常见的是wide、JSON、yaml [root@master ~]# kubectl get ns dev -o yaml apiVersion: v1 kind: Namespace metadata: annotations: kubectl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a293c326d03295c9aff50c6bf4d816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67978b80f99fb08bd92d44e39ddc88a6/" rel="bookmark">
			Rust基础-关于Option
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Option是Rust的为了解决函数返回null问题而产生的。结构如下
pub enum Option&lt;T&gt; { None, Some(T), } 正常返回Some(T)，否则返回None。
举个栗子如下
fn main() { let a=double(1); let b=double(-1); println!("a= {}",a.expect("@@@here is panic")); println!("a= {}",a.unwrap()); //以下两行都会出错,一个unwrap得到的None，引发panic，一个是给panic做个自定义的标记，方便定位 //println!("a= {}",b.unwrap()); //println!("b= {}",b.expect("@@@here is panic")) ; } fn double(x:i32)-&gt;Option&lt;i32&gt;{ match x&gt;0 { false =&gt; None, true =&gt; Some(x+x), } } 例子很简单，如果小于0抛出none，否则双倍输出。
1、unwrap内部对返回的Result进行了模式匹配，如果是Ok/Some，则返回Ok/Some的值，如果是Err/None，则直接调用panic！
2、expect是当得到None而panic时，加一段自定义的信息方便定位。
unwrap它有4个变种能灵活调整代码：
unwrap_or(self, default: T)：如果是Ok/Some，则返回Ok/Some的值，如果是Err/None返回给定的default
unwrap_or_default(self) ：如果是Ok/Some，则返回Ok/Some的值，如果是Err/None返回Ok/Some相应类型的默认值
unwrap_or_else&lt;F&gt;(self, f: F) ：传入一个闭包，如果是Ok/Some，则返回Ok/Some的值，如果是Err/None则执行这个闭包。
unwrap_unchecked(self)：不检查返回，报错不执行panic，直接扔给操作系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577963c46d2c3cccac4bd8db7ee4af17/" rel="bookmark">
			01:谁考了第k名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述
在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。
输入
第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。
其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。
输出
输出第k名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩）
样例输入
5 3
90788001 67.8
90788002 90.3
90788003 61
90788004 68.4
90788005 73.9
样例输出
90788004 68.4
分析及代码：
分析：这道题主要用到struct结构体以及swap函数，将输入的学生数据进行排序后直接输出。
#include &lt;bits/stdc++.h&gt; using namespace std; struct Stu{ int num; double score; }; int main() { int n,k; cin&gt;&gt;n&gt;&gt;k; Stu a[100]; for(int i=1;i&lt;=n;++i) { cin&gt;&gt;a[i].num&gt;&gt;a[i].score; } for(int i=1;i&lt;n+1;++i) { for(int j=i;j&gt;1;j--) { if(a[j].score&gt;a[j-1].score) { swap(a[j],a[j-1]); //对数据进行排序 } else { break; } } } printf("%d %g",a[k].num,a[k].score); //printf输出学号和成绩 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ed1763a299cdbd715932514864583d6/" rel="bookmark">
			java单例模式的几种写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一 package singleton; /** * 饿汉式 * 类加载到内存中，就实例化一个单例，JVM保证线程安全 * 筋单安用，推荐使用！ * 唯一缺点：不管用到与否，类装载时就完成实例化中 */ public class SingletonWay1 { public static final SingletonWay1 INSTANCE = new SingletonWay1(); private SingletonWay1(){}; public static SingletonWay1 getInstance(){return INSTANCE;} public void m(){ System.out.println("m()"); }; public static void main(String[] args) { SingletonWay1 instance = SingletonWay1.getInstance(); SingletonWay1 instance1 = SingletonWay1.getInstance(); System.out.println(instance == instance1); } } 方法二 package singleton; public class SingletonWay2 { public static SingletonWay2 INSTANCE; private SingletonWay2(){} public static synchronized SingletonWay2 getInstance() { if (INSTANCE==null) { return INSTANCE = new SingletonWay2(); } else { return INSTANCE; } } public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { new Thread(new Runnable() { @Override public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ed1763a299cdbd715932514864583d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81fa307a446071ca035230592233cf77/" rel="bookmark">
			软件工程总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件工程概述
计算机软件
计算机软件分为十类：系统软件、应用软件、工程/科学软件、嵌入式软件、产品线软件、Web应用、人工智能软件、开放计算、网络资源、开源软件。
软件工程基本原理
7条基本原理：用分阶段的生命周期计划严格管理、坚持进行阶段评审、实现严格的产品控制、采用现代程序设计技术、结果应能清楚地审查、开发小组的人员应少而精、承认不断改进软件工程实践的必要性。
软件生存周期
软件生存周期包括可行性分析与项目开发计划、需求分析、设计（概要设计和详细设计）、编码、测试、维护。
软件过程
能力成熟度模型（CMM）分为5个级别：初始级、可重复级、已定义级、已管理级、优化级。
能力成熟度模型集成（CMMI）分为阶段式模型和连续模式模型。
阶段式模型类似CMM，有5个等级：初始的、已管理的、已定义的、定量管理的、优化的。
连续式模型有6个等级：未完成的、已执行的、已管理的、已定义级的、定量管理的、优化的。
二、软件过程模型
瀑布模型
优点：容易理解、管理成本低；强调开发的阶段性早期计划及需求调查和产品测试。
缺点：客户必须能够完整、正确和清晰地表达他们的需要。需求或设计中的错误往往只有到了项目后期才能够被发现，对于项目的风险的控制能力较弱，从而导致项目常常延期完成，开发费用超出预算。
增量模型
优点：具有瀑布模型的所有优点。此外，第一个可交付版本所需要的成本和时间很少；开发由增量表示的小系统所承担的风险不大；由于很快发布了第一个版本，因此可以减少用户需求的变更；运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。
缺点：如果没有对用户的变更需求进行规划，那么产生的初始增量可能会造成后来的增量的不稳定；如果需求不像早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布；管理发生的成本、进度和配置的复杂性可能会超出组织的能力。
演化模型
典型的演化模型有原型模型和螺旋模型。
原型模型
原型可以分为3种：探索型原型、实验型原型、演化型原型。
探索型原型：弄清目标的要求、确实希望的特性、并探讨多种方案的可行性。
实验型原型：验证方案或算法的合理性，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠等。
演化型原型：将原型作为目标系统的一部分，通过对原型的多次改进，逐步将原型演化成最终的目标系统。
螺旋模型
螺旋周期分为4个步骤：制订计划、风险分析、实施工程、用户评估。
喷泉模型
优点：提高软件项目的开发效率，节省开发时间。
缺点：需要大量的开发人员，不利于项目的管理，要求严格管理文档，审核难度加大。
基于构件的开发模型
基于构件的开发模型本质上是演化模型，需要以迭代方式构建软件。不同之处在于，基于构件的开发模型采用预先打包的软件构件开发应用系统。
形式化方法模型
统一过程模型
统一过程模型是一种“用例和风险驱动、以架构为中心、迭代并且增量”的开发过程，由UML方法和工具支持。
统一过程定义了4个技术阶段及其制品：
起始阶段：生命周期目标。
精化阶段：生命周期架构。
构建阶段：初始运作功能。
移交阶段：产品发布。
敏捷方法
敏捷方法有5种：极限编程、水晶法、并列争求法、自适应软件开发、敏捷统一过程。
极限编程由价值观、原则、实践和行为4个部分组成。
敏捷统一过程（AUP）迭代执行以下活动：建模、实现、测试、部署、配置及项目管理、环境管理。
三、需求分析
软件需求
软件需求包括：功能需求、性能需求、用户或人的因素、环境需求、界面需求、文档需求、数据需求、资源使用需求、安全保密需求、可靠性需求、软件成本消耗与开发进度需求、其他非功能性需求。
需求分析原则
必须能够表示和理解问题的信息域。
必须能够定义软件将完成的任务。
必须能够表示软件的行为
必须划分描述数据、功能和行为的模型，从而可以分层次地揭示细节。
分析过程应该从要素信息移向细节信息。
需求工程
需求工程可以分为6个阶段：需求获取、需求分析与协商、系统建模、需求规约、需求验证、需求管理。
四、系统设计
系统设计的基本任务分为概要设计、详细设计两个步骤。
概要设计
设计软件系统总体结构、数据结构及数据库设计、编写概要设计文档、评审。
详细设计
对每个模块进行详细的算法设计、对模块内的数据结构进行设计、对数据库进行物理设计、其他设计、编写详细设计说明书、评审。
五、系统测试
系统测试与调试
系统测试遵循的原则：
应尽早并不断地进行测试。
测试工作应该避免由原开发软件的人员或小组承担。
在设计测试方案时要确定输入数据和预期输出结果。
在测试程序时不仅要检验程序，还要检验程序是否做了不该做的事。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81fa307a446071ca035230592233cf77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad6220b01ce28c3553d2ad52a2c54d29/" rel="bookmark">
			第五章 if语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#第五章if语句 #5.1简单实例 cars=['audi','bmw','subaru','toyota'] for car in cars: if car=='bmw': print(car.upper()) else: print(car.title()) Audi BMW Subaru Toyota #条件测试 #“==”根据条件测试的值为true或者false #5.2.1检查是否相等 car='bmw' car=='bmw' True car='audi' car=='bmw' False #5.2.2检查是否相等时不考虑大小写 #在Python中检查是否相等时区分大小与，例如，两个大小与不同的值会被视为不相等： car='Audi' car=='audi' False #如果大小写无关紧要，而只想检查变量的值，可将变量的值转换为小写，再进行比较： car='Audi' car.lower()=='audi' True #函数lower()不会修改存储在变量car中的值 car='Audi' print(car.lower()=='audi') print(car) True Audi #5.2.3检查是否不相等 #!=表示不等于 requseted_topping='mushrooms' if requseted_topping !='anchovies': print('hold the anchovies ') hold the anchovies #5.2.4比较数字 age=18 age==18 True answer=17 if answer !=42: print('that is not the correct answer,please try again!') that is not the correct answer,please try again!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad6220b01ce28c3553d2ad52a2c54d29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7624f7a2aa6425e9ed76216736ed3fc/" rel="bookmark">
			实现一个简单的顺序表（Java代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本篇文章，主要写一些关于顺序表的简单操作。在介绍顺序表的简单操作前，先来了解什么是顺序表？顺序表的简单操作又有那些呢？增删改除算不算呢？下面让我们一起来了解一下吧！
将表中元素一个接一个的存入一组连续的存储单元中，这种存储结构是顺序结构。采用顺序存储结构的线性表简称为“ 顺序表”。
现在来定义一个表。当elem没有初始化的时候，默认为null；而usedSize没初始化时被默认为0。
public class MyArrayList { //实现顺序表代码 public int[] elem; public int usedSize; public MyArrayList() { this.elem = new int[5]; //数组里有五个元素 } } 接下来让我们看看第一步：打印顺序表
public void toString() { for (int i = 0; i &lt; this.usedSize; i++) { System.out.print(this.elem[i] + " "); } } 第二步：增加新元素，新增元素的时候，默认在数组的最后面新增。但是增加元素的时候，需要判断数组容量是否是满的，如果数组所开辟的空间已经放满了元素，则需要扩容。
public void add(int data) { //1.判断是不是满的 if (isFull()) { //扩容 this.elem = Arrays.copyOf(this.elem, 2 * this.elem.length); } this.elem[this.usedSize] = data; this.usedSize++; } private boolean isFull() { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7624f7a2aa6425e9ed76216736ed3fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a5117fb7dd327e50797d7b4e22b07ef/" rel="bookmark">
			create-react-app降低react的版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react最近不是出18了吗
但问题是很多的库都还不支持
而且工作中不会使用特别新的技术
但用create-react-app创建的项目默认为react18版本
这里我们降版本只需要一行命令
npm install react@17.x react-dom@17.x --save 这里有个坑,这两个要同时降!!!,只改一个会报错!!!
顺便提醒一下,报错虽然长,但可以用翻译软件翻译一下,我这里也是通过看翻译之后的报错才注意到这个问题.本来很简单的问题,我搞了一个多小时
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b014c9059661eea63f2eb368becbb96/" rel="bookmark">
			串行通信简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、串行通信与并行通信
计算机与外界的数据交换称为通信，通信分为并行通信和串行通信两种基本方式。
并行通信
串行通信
并行通信：并行通信指各个数据位同时进行传送的数据通信方式，因此有多少个数据位，就需要多少根数据线。并行数据的特点是传送速度快、效率高，但成本高，通常只适合30m距离内的数据传送。
串行通信：串行通信指各个数据按传送位顺序进行传输，最少只需要两个传输线即可完成。其传输速度慢、效率低，但传输距离远，而且可以使用现有的通信通道（如电话线、各种网络等），在集散控制系统等远距离通信中使用很广。
二、串行通信分类—异步通信和同步通信
串行通信按照串行数据的时钟控制方式分为异步通信和同步通信。
1.异步通信
在异步通信中，数据通常以字符（或字节）为单位组成字符帧传送。字符帧由发送端逐帧发送，通过传输线被接收设备逐帧接收。发送端和接收端可以由各自的时钟来控制数据的发送和接收，两个时钟源彼此独立，互不同步。
发送端和接收端依靠什么来协调数据的发送和接收呢？也就是说，接收端怎么会知道发送端何时开始发送和何时发送结束呢？这个是由字符帧格式规定的。平时，发送线为高电平（逻辑1），每当接收端检测到传输线上发送过来低电平逻辑0（字符帧的起始位）时，就知道发送端已经开始发送，每当接收端接收到字符帧中的停止位时，就知道一帧字符信息已发送完毕。
在异步通信中，字符帧格式和波特率是两个重要指标，由用户根据实际情况选定。如下是异步通信的字符帧格式。
（1）字符帧
字符帧格式也称为数据帧，由起始位、数据位、奇偶校验位和停止位4部分构成。
① 起始位：位于字符帧开头，只占1位，始终为逻辑0低电平，用于向接收设备表示发送端开始发送一帧信息。
② 数据位：紧跟起始位之后，用户根据情况可以取5位、6位、7位和8位，低位在前高位在后。若所传数据位ASCII字符，则常取7位。
③ 奇偶校验位：位于数据位之后，仅占1位，用于表征串行通信中采用奇校验位还是偶校验，由用户根据需要决定。
④ 停止位：位于字符帧末尾，为逻辑高电平1，通常可取1位、1.5位或2位，用于向接收端表示一帧字符信息已发送完毕，也为发送下一帧字符做准备。
（2）波特率
波特率的定义为每秒钟传送二进制数码的位数（又称为比特数），单位是b/s。波特率是串行通信的重要指标，用于表征数据传输的速度。波特率越高，数据传输速度越快，和字符的实际传输速率不同。字符的实际传输速率是指每秒内所传字符帧的帧数，和字符帧格式有关。每位数据的传输时间定义为波特率的倒数。波特率还与信道的频带有关。波特率越高，信道频带越宽。所以，波特率也是衡量信道频宽的重要指标。通常，异步通信的波特率为50~9600b/s。波特率不同于发送时钟和接收时钟，常是时钟频率的1/16或1/64。
异步通信的优点是不需要传送同步脉冲，字符帧长度也不受限制，故所需设备简单。缺点是字符帧中因包含起始位和停止位而降低了有效数据的传输速度。
2.同步通信
同步通信是一种连续串行传送数据的通信方式，一次通信只传送一帧信息。此处的信息帧和异步通信中的字符帧不同，通常含有若干个数据字符，如下图所示。
他们均由同步字符、数据字符和校验字符CRC三部分组成。
同步字符：同步字符位于帧结构开头，用于确认数据字符的开始（接收端不断对传输线采样，并把采样到的字符和双方约定的同步字符比较，只有比较成功后才会把后面接收到的字符加以存储）。
数据字符：数据字符在同步字符之后，个数不受限制，由所需传输的数据块长度决定。
校验字符CRC：校验字符有1~2个，位于帧结构末尾，用于接收端对接收到的数据字符的正确性进行校验。
同步通信的数据传输速率较高，通常可达56Mb/s或更高。同步通信的缺点是要求发送时钟和接收时钟保持严格同步，故发送时钟除应和发送波特率保持一致外，还要求把它同时传送到接收端去。
三、串行通信的制式—半双工和全双工
在串行通信中，数据是在两个站之间传输的。按照数据传输方向，串行通信可分为半双工和全双工两种制式。
1. 半双工制式
在半双工制式下，A站和B站之间只有一个通信回路，故数据或者由A站发送被B站接收，或者由B站发送被A站接收。因此，A、B两站之间只需要一条信号线和一条接地线。
2. 全双工制式
在全双工制式下，A、B两站间有两个独立的通信回路，两站都可以同时发送和接收数据。因此，全双工方式下A、B两站之间至少需要三条传输线：一条用于发送，一条用于接收，一条用于信号地。
四、常见串行通信接口
通信标准引脚说明通信方式通信方向 UART
（通用异步收发器）
TXD：发送端
RXD：接收端
GND：公共地
异步通信全双工 单总线
（1-wire）
DQ：发送/接收端异步通信半双工SPI SCK:同步时钟
MISO：主机输入，从机输出
MOMI：主机输出，从机输入
同步通信全双工I2C SCL：同步时钟
SDA：数据输入/输出端
同步输出半双工 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2278655ee54ecd8d07befb1ae2f6e90e/" rel="bookmark">
			iOS架构:MVC, MVP, MVVM以及VIPER
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里可以看到幻灯片
你可能在阅读这篇文章之前已经问过自己一些问题，比如说：
谁应该拥有联网请求：Model还是Controller, 或者viewModel, presenter？
谁该处理数据(包括服务器数据,本地数据),谁该处理展示逻辑?
针对这些问题的不同回答就产生了不同的架构.
为什么要纠结选择什么架构呢？
假如有一天，你在调试一个实现了几十种功能的庞大的类时，你会发现自己很难找到并修复你的类中的任何错误。并且，很难把这个类作为一个整体来考虑，因此，你总会忽略一些重要的细节。如果你的应用程序中已经出现了这种情况，那么很有可能：
这类是UIViewController类。UIViewController直接存储和处理你的数据你的UIView中几乎没有做任何事情Model仅仅是一个数据结构单元测试覆盖不了任何内容 即使你遵循了苹果的指导方针并实现了苹果的MVC模式，这种情况还是会发生的，所以不要难过。苹果的MVC有点问题，这个我们稍后再谈。
让我们定义一个优秀系统结构的特征：
1.角色间职责的清晰分配（分布式）。
2.可测试性通常来自第一个特性（不必担心：使用适当的系统结构是很容易的）。
3.使用方便，维护成本低。
为什么要采用分布式
当我们想弄清楚某些事情是如何运作时，采用分布式能让我们的大脑思路清晰。如果你认为你开发越多，你的大脑就越能理解复杂性，那么你是对的。但这种能力不是线性的，很快就会达到上限。因此，克服复杂性的最简单方法是按照单一职责原则在多个实体之间划分职责。
为什么要可测试
对于那些已经习惯了单元测试的人来说，这通常不是问题，因为在添加了新的特性或者要增加一些类的复杂性之后通常会失败。这意味着测试能够降低应用程序在用户的设备上发生问题的概率，那时修复也许需要一个星期（审核）才能到达用户。
为什么要易用性
这并不需要回答，但值得一提的是，最好的代码是从未编写过的代码。因此，你拥有的代码越少，你拥有的bug就越少。这意味着编写更少代码的愿望决不能仅仅由开发人员的懒惰来解释，你不应该偏爱看起来更聪明的解决方案而忽视它的维护成本。
MV(X) 简介 现在我们在架构设计模式上有很多选择：
MVCMVPMVVMVIPER 他们中的三个假设将应用程序的实体大体分成3类：
Models — 负责保存数据或数据访问层，操纵数据，例如“人”或“提供数据的人”。Views — 负责表示层（GUI），iOS环境下通常以“UI”前缀。Controller/Presenter/ViewModel — Model和View之间的中介，一般负责在用户操作View时更新Model，以及当Model变化时更新View。 这种划分能让我们：
更好地理解它们（如我们所知）重用它们（尤其是View和Model）独立地进行测试（单元测试） 让我们从MV(X)开始，稍后在回到VIPER：
MVC 曾经
在讨论苹果对MVC的看法之前，让我们先看看传统的MVC。
传统的MVC
在上图的情况下，View是无状态的。一旦Model被改变，Controller就会简单地渲染它。
虽然在iOS应用用传统的MVC架构也可以实现，但这并没有多大意义，由于架构问题 ——三个实体是紧耦合的，每个实体和其他两个通信。这大大降低了可重用性——这可不是你希望在你的应用程序看到的。出于这个原因，我们甚至不想编写规范的MVC示例。
传统的MVC似乎不适用于现代IOS开发。
苹果的MVC 愿景：
Cocoa MVC
Controller是View和Model之间的中介，这样他们就解耦了。最小的可重用单元是Controller，这对我们来说是个好消息，因为我们必须有一个来放那些不适合放入Model的复杂业务逻辑的地方。
从理论上讲，它看起来很简单，但你觉得有些地方不对，对吧？你甚至听到有人说MVC全称应该改为Massive View Controller（大量的视图控制器）。此外，为View controller减负也成为iOS开发者面临的一个重要话题。
如果苹果只接受传统的MVC并改进了它，为什么会出现这种情况呢？
实际情况：
事实上的Cocoa MVC
Cocoa MVC鼓励人们编写大规模的视图控制器，而且由于它们涉及View的生命周期，所以很难说它们（View和Controller）是分离的。
虽然你仍有能力将一些业务逻辑和数据转换成Model，但你没办法将View从Controller中分离。在大多数时候所有View的责任是把事件传递给Controller。
ViewController最终演变成一个其他人的delegate和data source，通常负责分派和取消网络请求, 处理数据, 把服务器数据转换成UI需要的数据…你明白的。
你见过多少这样的代码？：
var userCell = tableView.dequeueReusableCellWithIdentifier("identifier") as UserCell userCell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2278655ee54ecd8d07befb1ae2f6e90e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd229f1a0bb6a2443f31127c77887b0/" rel="bookmark">
			hadoop上文件下载不了如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【背景】我在centos 7 环境下刚安装好 hadoop3.0, 运行完 wordcount例子，想看一下数据结果(当然可以直接用命令cat看)，但是点下载的时候发现不行，在点开yarn上的log,发现也不行。于是想起来windows host文件没有加上IP和主机名
【解决方法】
将Windows环境中下面地址的host文件最后添加IP和主机名
C:\Windows\System32\drivers\etc 添加好后就可以下载了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7288fbdfa060b80d22603e966c723d00/" rel="bookmark">
			Python wordcloud库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		认识wordcloud库 wordcloud是优秀的词云展示第三方库
-词云以词语为基本单位，更加直直观和艺术的展示文本
如图：
wordcloud库的安装 pip install wordcloud 如果安装不成功就看看一波三折的wordcloud库安装_华泽的花的博客-CSDN博客吧
wordcloud库的常规方法 w=wordcloud.WordCloud()
w.generate(txt)向WordCloud对象w中加载文本txt,
&gt;&gt;&gt;w.generate("Pyrhon and WordCloud")w.to_file(filename)将词云输出为图像文件，.png或.jpg格式
&gt;&gt;&gt;w.to_file("outfile.png") 词云绘制步骤 -步骤1：配置对象参数
-步骤2：加载词云文本
-步骤3：输出词云文件
import wordcloud c=wordcloud.WordCloud() c.generate("wordcloud by Python") c.to_file("pywordcloud.png") 运行生成一个新图片文件
图片默认像素高400像素，宽200像素
配置对象参数 w=wordcloud.WordCloud(&lt;参数&gt;)
width指定词云对象生成图片宽度，默认400像素
&gt;&gt;&gt;w=wordcloud.WordCloud(with=600)height指定词云对象生成图片的高度，默认200像素
&gt;&gt;&gt;w=wordcloud.WordCloud(height=400)min_font_size指定词云中字体的最小字号，默认4号
&gt;&gt;&gt;w=wordcloud.WordCloud(min_font_size=10)max_font_size指定词云中字体的最大字号，根据高度自动调节
&gt;&gt;&gt;w=wordcloud.WordCloud(max_fond_size=20)font_step指定词云中字体字号的步进间隔，默认为1
&gt;&gt;&gt;w=wordcloud.WordCloud(font_step=2)font_path指定字体文件的路径，默认None
&gt;&gt;&gt;w=wordcloud.WordCloud(font_path="msyh.ttc")max_words指定词云显示的最大单词数量，默认200
&gt;&gt;&gt;w=wordcloud.WordCloud(max_word=20)stop_words指定词云的排除列表，即不显示的单词列表
&gt;&gt;&gt;w=wordcloud.WordCloud(stop_word={"python"})mask指定词云形状，默认为长方形，需要引用imread()函数
&gt;&gt;&gt;from scipy.misc import imread
&gt;&gt;&gt;mk=imread("pic.png")
&gt;&gt;&gt;w=wordcloud.WordCloud(mask=mk)background_color指定词云图片的背景颜色，默认为黑色
&gt;&gt;&gt;w=wordcloud.WordCloud(background_color="white") 应用实例 #英文实例 import wordcloud txt="life is short,you need python" w=wordcloud.WordCloud(\ background_color="white") w.generate(txt) w.to_file("pywcloud.png") #中文实例 import jieba import wordcloud txt="程序语言设计是计算机能够理解和识别用户操作意图的一种交互式体系，\ 他按照特定规则组织计算机指令，使计算机能够自动运行各种运算处理。" w=wordcloud.WordCloud(width=1000,font_path="msyh.ttc",height=700) w.generate(" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7288fbdfa060b80d22603e966c723d00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/382bbcbc38f179980e39b1fd0c0386ac/" rel="bookmark">
			pycharm中设置以pytest运行用例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.进入设置
2.选择pytest运行器后点击apply和ok
3.上一步设置完成后，由于缓存原因还不能以pytest形式运行，所以要进行缓存的清除
4.右击就会出现以pytest运行的指令，点击运行即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0735d63f584db8575444371cb52ae76e/" rel="bookmark">
			光流估计算法RAFT的论文和代码阅读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RAFT论文和代码阅读 RAFT: Recurrent All-Pairs Field Transforms for Optical Flow
Zachary Teed and Jia Deng
ECCV2020 best paper
摘要 We introduce Recurrent All-Pairs Field Transforms (RAFT), a new deep network architecture for optical flow. RAFT extracts per-pixel features, builds multi-scale 4D correlation volumes for all pairs of pixels, and iteratively updates a flow field through a recurrent unit that performs lookups on the correlation volumes. RAFT achieves state-of-the-art performance. On KITTI, RAFT achieves an F1-all error of 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0735d63f584db8575444371cb52ae76e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847152cc3e569cbd06e7177104765472/" rel="bookmark">
			CGAL学习记录——多种几何形状同时检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CGAL同时检测多种几何物体 效果展示代码结果 效果展示 代码 代码可直接运行
#include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;CGAL/Point_set_3.h&gt; #include &lt;CGAL/property_map.h&gt; #include &lt;CGAL/IO/read_points.h&gt; #include &lt;CGAL/Point_with_normal_3.h&gt; #include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt; #include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt; // Type declarations. typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel; typedef Kernel::Point_3 Point; typedef Kernel::FT FT; typedef std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt; Point_with_normal; typedef std::vector&lt;Point_with_normal&gt; Pwn_vector; typedef CGAL::First_of_pair_property_map&lt;Point_with_normal&gt; Point_map; typedef CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt; Normal_map; typedef CGAL::Shape_detection::Efficient_RANSAC_traits &lt;Kernel, Pwn_vector, Point_map, Normal_map&gt; Traits; typedef CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt; Efficient_ransac; typedef CGAL::Shape_detection::Cone&lt;Traits&gt; Cone; typedef CGAL::Shape_detection::Cylinder&lt;Traits&gt; Cylinder; typedef CGAL::Shape_detection::Plane&lt;Traits&gt; Plane; typedef CGAL::Shape_detection::Sphere&lt;Traits&gt; Sphere; typedef CGAL::Shape_detection::Torus&lt;Traits&gt; Torus; typedef CGAL::Point_set_3&lt;Kernel::Point_3&gt; Point_set; int main(int argc, char** argv) { //加载点云 Pwn_vector points; if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847152cc3e569cbd06e7177104765472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935813c2321ec8f8f0e65cab1efbb4ee/" rel="bookmark">
			CGAL学习记录——ransac多平面分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CGAL-RANSAC多平面分割 前言一、效果展示二、代码 前言 本节主要实现CGAL中RANSAC方法的平面分割功能
已添加到QT+PCL中：QT+PCL+CGAL实现多平面分割 一、效果展示 二、代码 拷贝直接运行 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;CGAL/property_map.h&gt; #include &lt;CGAL/IO/read_points.h&gt; #include &lt;CGAL/Point_set_3.h&gt; #include &lt;CGAL/Point_with_normal_3.h&gt; #include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt; #include &lt;CGAL/Shape_detection/Efficient_RANSAC.h&gt; // Type declarations. typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel; typedef Kernel::Point_3 Point; typedef std::pair&lt;Kernel::Point_3, Kernel::Vector_3&gt; Point_with_normal; typedef std::vector&lt;Point_with_normal&gt; Pwn_vector; typedef CGAL::First_of_pair_property_map&lt;Point_with_normal&gt; Point_map; typedef CGAL::Second_of_pair_property_map&lt;Point_with_normal&gt; Normal_map; typedef CGAL::Shape_detection::Efficient_RANSAC_traits &lt;Kernel, Pwn_vector, Point_map, Normal_map&gt; Traits; typedef CGAL::Shape_detection::Efficient_RANSAC&lt;Traits&gt; Efficient_ransac; typedef CGAL::Shape_detection::Plane&lt;Traits&gt; Plane; typedef CGAL::Point_set_3&lt;Point&gt; Point_set; int main(int argc, char** argv) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935813c2321ec8f8f0e65cab1efbb4ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f9943f3a07b7d6bf1c57de435f03df0/" rel="bookmark">
			VxWorks7 Workbench4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本软件用于实时操作系统的技术研究学习。这里分享给大家学习开发使用。下载后自自行购买License解压密码即可。注：供个人和技术研究学习，非商业用途。
链接：https://pan.baidu.com/s/1NfBYzyjNop_VJqYxKMB1kA?pwd=1001 提取码：1001 安装 1.将安装包安装到任意盘符目录，如：G:\SoftwareInstallationLocation\VxWorks7。
2.解压安装包，解压后得到如下图所示安装文件：
3.按照安装导向安装即可。
4.将windriver_license.lic文件拷贝到安装目录下的子目录License目录下，如下如：
使用 启动软件
启动后的界面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7352fb33514f2bc18c112e9d1415de87/" rel="bookmark">
			获取当前日期时间字符串-C&#43;&#43;/python/bash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取当前日期时间字符串-C++/python/bash C++pythonbash语法 C++ #include &lt;string&gt; #include &lt;ctime&gt; std::string GetCurrentTimeString() { std::time_t now = std::time(nullptr); std::tm* ptm = std::localtime(&amp;now); char buffer[32] = {0}; std::strftime(buffer, 32, "%Y-%m-%d-%H-%M-%S", ptm); return std::string(buffer); } int main() { printf("%s\n", GetCurrentTimeString().c_str()); return 0; } python import datetime def GetCurrentTimeString(): return datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S") if __name__ == "__main__": print(GetCurrentTimeString()) bash #!/bin/bash date_str=$(TZ=UTC-8 date '+%Y-%m-%d-%H-%M-%S') echo $date_str 语法 待更新
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c08cf1ffc27ad0cb65c074d540477d35/" rel="bookmark">
			编程语言druid数据库连接池的配置类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程语言druid数据库连接池的配置类 package org.fh; import com.alibaba.druid.support.http.StatViewServlet; import com.alibaba.druid.support.http.WebStatFilter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * 说明：druid数据库连接池的配置类(必须与启动类包目录同级) * 作者：FH Admin * from：fhadmin.cn */ @Configuration public class DruidConfiguration { @Bean public ServletRegistrationBean statViewServlet() { // 创建servlet注册实体 ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); // 设置ip白名单 //servletRegistrationBean.addInitParameter("allow", "127.0.0.1"); // 设置ip黑名单，如果allow与deny共同存在时,deny优先于allow //servletRegistrationBean.addInitParameter("deny", "192.168.0.1"); // 设置控制台管理用户 //servletRegistrationBean.addInitParameter("loginUsername", "druid"); //servletRegistrationBean.addInitParameter("loginPassword", "fhadmin"); // 是否可以重置数据 servletRegistrationBean.addInitParameter("resetEnable", "false"); return servletRegistrationBean; } @Bean public FilterRegistrationBean statFilter() { // 创建过滤器 FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); // 设置过滤器过滤路径 filterRegistrationBean.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c08cf1ffc27ad0cb65c074d540477d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4429de15e3a47ee35df3178e541a13/" rel="bookmark">
			VUE h5移动端设置每个页面的头部title
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 router.js 中需要在每一个路由下面多添加一个 meta:{title:‘主页’}，比如：
{ path: '/login', name: 'login', meta:{index:1,title: '登陆/注册'}, component: () =&gt; import('./views/Login.vue') }, { path: '/', //个人中心 name: 'personalCenter', meta:{index:2,title:'个人中心'}, component: () =&gt; import('./views/PersonalCenter.vue'), }, { path: '/personalInformation',//个人信息 name: 'personalInformation', meta:{index:3,title:'个人信息'}, component: () =&gt; import('./views/PersonalInformation.vue') }, 然后在 main.js里面添加以下代码即可：
import router from './router' /* 路由发生变化修改页面title */ router.beforeEach((to, from, next) =&gt; { if (to.meta.title) { document.title = to.meta.title } next() }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe1f6ad381782954e530c969f1986e8/" rel="bookmark">
			【python练习】随机生成20个学生的成绩并判断这20个学生成绩的等级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import random def fuc(a, b): num = [] for i in range(20): num.append(random.randint(a, b)) num.sort() A = [] B = [] C = [] for j in num: if 90 &lt; j &lt;= 100: A.append(j) elif 80 &lt; j &lt;= 90: B.append(j) else: C.append(j) return f'二十位学生成绩为{num}；\n其中等级A学生{len(A)}位,等级B{len(B)}位，等级C{len(C)}位' print(fuc(0, 100)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5d3c5acb1be9a14e70e20d23eeca5c/" rel="bookmark">
			BP神经网络的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、简介二、BP神经网络的网络流程1.结构2.流程3.实例4.优缺点 总结 前言 BP(back propagation)神经网络是1986年由Rumelhart和McClelland为首的科学家提出的概念，是一种按照误差逆向传播算法训练的多层前馈神经网络，是应用最广泛的神经网络模型之一。
一、简介 BP神经网络是一种多层的前馈神经网络，其主要的特点是：信号是前向传播的，而误差是反向传播的。就是在模拟过程中（这是一个循环，我们在训练神经网络的时候是要不断的去重复这个过程的）收集系统所产生的误差，并且返回这些误差到输出值，之后用这些误差来调整神经元的权重，这样生成一个可以模拟出原始问题的人工神经网络系统。
BP神经网络应用的主要方面：
预测：电力运行负荷、血红蛋白浓度、房价、股市、水资源需求、风俗、地质灾害等
评价：城市安全、河流健康、教学质量、网络安全、水环境、生态风险灾害损失等
图像处理：图像降噪、图像分类、图像压缩、图像校正、图像分割图像加密等
仿真：移动机器人避障仿真、物流交通仿真、无人机自适应仿真、工业控制仿真等
二、BP神经网络的网络流程 1.结构 BP神经网络由输入层、输出层和若干个隐藏层（一层或者多层）构成，每一层可以有若干节点。层与层之间节点连接状态通过权重来体现。
（a）为一个隐藏层
（b）三个隐藏层
2.流程 实线为正向传播，虚线为反向传播。
将训练样本与权重进行计算，得到输出结果，输出结果与期望输出结果进行比较，得到满意的结果，就训练完成，然后进行测试（再给它一个输入，看它的输出）；如果结果不满意，我们需要进行调整，对权重进行调整（样本不可调整）。
BP神经网络过程分为两个阶段，第一阶段是信号的前向传播。从输入层经过隐含层，最后到达输出层；第二阶段是误差的反向传播。从输出层到隐含层，最后到输入层，依次调节隐含层到输出层的权重和偏置，输入层到隐含层的权重和偏置。
正向传播就是指数据从输入端输入后，沿着网络的指向，乘以对应的权重之后在加和，再把结果作为输入在激活函数中进行计算，将计算结果作为输入传递给下一个节点。依次计算，直到得到最终的输出。
反向传播是指将输出的结果与理想的输出结果进行比较，将输出结果与理想输出结果之间的误差进行网络进行反向传播的过程。具体是不断对网络上各个节点的所有权重进行调整，权重调整的方法采用梯度下降法。
梯度下降法：
就是一个人在山顶，以最快的速度到达山脚，是每一步下降最快的路，变化最快，这个就理解为梯度（矢量）。梯度为正，上升最快；梯度为负，下降最快。梯度是偏导数组成的矢量。
3.实例 看到的一个具体实例，进行理解
反向传播就列举这两个进行理解。
4.优缺点 优点：
1.自学习和自适应能力强
2.非线性映射能力较强；实质上BP网络实现了从输入到输出的映射功能，数学理论上证明三层神经网络就能够以任意精度逼近任何非线性连续函数，适用于求解内部机制复杂问题。
3.有一定容错能力
缺点：
1.容易陷入局部最优；用图像去理解
2.收敛速度慢
3.BP神经网络结构选择不一
总结 以上就是对BP神经网络的学习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5158a83fc3fd110716384214d3db29/" rel="bookmark">
			JAVA 进程线程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程和进程 一、进程 进程是指运行中的程序，比如我们使用QQ，就启动该进程分配内存空间.进程是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自升的产生，存在和消亡的过程 二、线程 线程是由进程创建的，是进程的一个实体一个进程可以拥有多个线程 一个想线程还可以创建它的子线程 三、其他概念 单线程：同时允许执行一个线程
多线程：同一个时刻，可以执行多个线程
比如：QQ可以打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件 并发：同一个时刻，多个任务交替执行，造成"貌似同时"的错觉，简单的说，单核CPU实现的多任务就是并发
并行：同一个时刻，多个任务同时执行。多核CPU可以同时执行
也可能出现：并行和并发，并存在的情况 四、线程的基本使用 在Java中线程来使用有两种方法
基础Thread类，重写run方法
实现Runnable接口，重写run方法
案例一 ![image-20220327105831422](!
)
package com.hspedu.threaduse; /** * @author DL5O * @version 1.0 * 通过继承Thread 类创建线程 */ public class Thread01 { public static void main(String[] args) throws InterruptedException { //创建Cat对象，可以当做线程使用 Cat cat = new Cat(); //启动线程，调用start的时候还调用run方法 cat.start();//最终执行 -&gt; cat的run方法 //cat.run(); //如果这样写，run方法就是一个普通的方法， // 是由主线程调用了，并没有真正的开线程， // 会阻塞在这里，执行完毕后才会继续执行下面的代码 //说明：当main线程启动一个子线程thread-0，主线程不会阻塞, // 即不会等待cat.start执行完毕后再往下执行 //主线程中如果后面还有代码的话，还会继续执行 //这时我们的主线程和主线程 是交替执行的 System.out.println("继续执行~~,"+Thread.currentThread().getName()); for (int i = 0; i &lt; 60; i++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c5158a83fc3fd110716384214d3db29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fdcde11f5c3e7454f146c6c65a1acb/" rel="bookmark">
			【定量分析、量化金融与统计学】统计推断基础（5）---一类错误与二类错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 这是这个系列的最后一篇，我们讲一讲什么是一类错误，什么是二类错误。这个系列统计推断基础5部分分别是：
总体、样本、标准差、标准误【定量分析、量化金融与统计学】统计推断基础（1）---总体、样本、标准差、标准误样本均值分布、中心极限定理、正态分布【定量分析、量化金融与统计学】统计推断基础（2）---样本均值分布、中心极限定理、正态分布点估计、区间估计【定量分析、量化金融与统计学】统计推断基础（3）---点估计、区间估计假设检验【定量分析、量化金融与统计学】统计推断基础（4）---假设检验（T或者Z检验）I型误差，II型误差 二、一类错误与二类错误 概念： 第一类错误：原假设是正确的，却拒绝了原假设。
第二类错误：原假设是错误的，却没有拒绝原假设。
我们举三个例子来说明这个问题：（例1，例2来自百度百科《统计学》中“第一类错误”和“第二类错误”分别是指什么？_百度知道）
例1：判决问题 假设检验比作法庭判案，我们想知道被告是好人还是坏人。
原假设是“被告是好人”，备择假设是“被告是坏人”。
法庭判案会犯两种错误：
如果被告真是好人，而你判他有罪，这是第一类错误(错杀好人)；如果被告真是坏人，而你判他无罪，这是第二类错误(放走坏人)。 例2：误诊问题 假设我们从某个指标一组检测结果判断某个人是否是肝病病人。
原假设：健康人，备择假设：肝病病人。
那么，当这组数据表明应该拒绝原假设，那么，我们可能会犯第Ⅰ类错误，将健康人误诊为肝病病人（图中黄色部分）。但是如果我们接受了原假设，认为该人为健康人，我们有可能会犯第II类错误，将肝病病人认为是健康人（图中红色部分）,因为有一部分肝病病人该指标的表现和正常人类似，从数据无法判断。
例3： 1类错误就是你对一个男人说：你怀孕了 H0：没怀孕
H1：怀孕了
2类错误就是你对一个孕妇说：你没怀孕
H0：没怀孕
H1：怀孕了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769df065dd485665374878c9f0bccb0d/" rel="bookmark">
			mybatis-plus使用报错：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将baomidou中的mybatis去掉，重新引入
&lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.8&lt;/version&gt; &lt;/dependency&gt; ``` 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc1c35f3053946465aea5ebd15f1cf54/" rel="bookmark">
			【usb】安卓usb网络共享（RNDIS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RNDIS简介 微软官方对RNDIS的介绍说白了，就是将安卓设备作为一个网卡，通过USB连接到电脑上，供电脑上网。 二、使用指导 首先为了验证电脑上网确实走的是usb。先把你电脑上的网卡及网线拔了，wifi关了。并且确保此时电脑无法上网。然后把手机通过USB线连接到电脑上，在手机的设置里面搜索USB，找到类似USB共享网络，并打开开关。然后电脑就可以正常上网啦，试下看看能否打开百度。 三、补充说明 我们在讨论RNDIS，但是上述使用指导里面好像没有看到RNDIS的字眼呀，这是咋回事？ 以华为手机为例，首先打开开发者模式（设置-&gt;关于手机，连续点击版本号），然后就会有提示您已处于开发者模式。然后进入开发人员选项(设置-&gt;系统和更新-&gt;开发人员选项)。找到选择USB配置，因为我们已经设置了USB共享网络，所以这里就已经是RNDIS了。 通过测试发现，USB共享网络开关打开之后，USB配置就会被自动设置成RNDIS。如果我们手动在把USB配置改成其他的。就算USB共享网络开关是打开的，电脑也是没法上网的。 四、常见问题 手机打开USB共享网络开关了，电脑还是没法上网。 打开电脑设备管理器,应该可以看到类似下面红框中RNDIS的网卡。如果没有这个或者有显示其他设备和黄色感叹号的。可能是没有安装驱动，建议进行驱动修复。
在查看控制面板\网络和 Internet\网络连接，应该有如下的虚拟网卡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d645dca16986628fe789428c88523df7/" rel="bookmark">
			python float 精度 处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		way1:Decimal 示例代码：
from decimal import Decimal numStr = '1.13' print('====a', Decimal(numStr) * Decimal('1e8')) print('====b', Decimal(numStr) * Decimal(1e8)) print('====c', Decimal(float(numStr)) * Decimal('1e8')) print('====d', Decimal(float(numStr)) * Decimal(1e8)) 输出结果：
示例代码输出结果： ====a 1.13E+8 ====b 113000000.00 ====c 112999999.9999999893418589636 ====d 112999999.9999999893418589636 示例1说明： numStr 1.13 × 1e8期望值是113000000.00，而实际计算过程中因为float精度问题会导致计算结果出现偏差。具体原因可以看文末的参考。示例1是使用Decimal计算的结果对比，可以看出如果要得出期望值时，可以考虑使用b输出结果的计算方式。
way2:round 示例代码：
numStr = '1.13' a = float(numStr)*1e8 print('====a', a) print('====b',round(a)) print('====c', round(a,2)) print('====d', round(a,3)) print('====e', '%.3f'%a) 输出结果：
示例代码输出结果： ====a 112999999.99999999 ====b 113000000 ====c 113000000.0 ====d 113000000.0 ====e 113000000.000 示例2说明： 示例2是使用round() 方法返回浮点数a的四舍五入值。也可以得到期望值113000000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d645dca16986628fe789428c88523df7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56862ea2b15870af45c79aa5fdfb3f95/" rel="bookmark">
			使用imgaug进行语义分割数据集增强
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用imgaug批量进行图像增强，实现图片和标签mask同步转换，基于三波段png格式遥感影像数据集 给定数据集路径和输出路径，将增强的数据集存到指定的路径。
对每张图片，在imgaug转换序列中随机选取5种转换方法。
imgaug如何使用，参考了其他博文：
用于医学图像分割的数据增强方法 —— 标准 imgaug 库的使用方法
Python 第三方模块之 imgaug （图像增强）
import imgaug.augmenters as iaa # 导入iaa import cv2 import glob import os import numpy as np if __name__ == '__main__': img_dir = '/train/images/'	# 图片文件路径 msk_dir = '/train/masks/'	# 标签文件路径 img_type = '.png' img_tmp_dir = '/tmp/images/'	# 输出图片文件路径 msk_tmp_dir = '/tmp/masks/' img_list = os.listdir(img_dir) msk_list = os.listdir(msk_dir) for i in range(len(img_list)): img_name = img_list[i] msk_name = msk_list[i] img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56862ea2b15870af45c79aa5fdfb3f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cbf15a196762ec545c993e8b71f2956/" rel="bookmark">
			数字IC设计工程师需要清楚的signoff点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名数字IC设计工程师，虽然核心工作是设计，但其他相关工作亦很重要，亦需要了解。下面简单的给出从设计开始到流片前的多个步骤使用的工具和相关的signoff点。
阶段0：准备好相应的版本控制工具和文档存储共享工具
版本控制工具：GIT，输入为RTL代码
文档资料存储共享工具：SVN，输入为RTL的设计相关文档
阶段1：RTL设计文档编写阶段
使用的工具：基本的办公软件
输入为算法文档、算法程序、协议等
输出为RTL设计文档，模块操作流程和约束等文档
注：一般情况下先是对算法或者协议之类的进行学习；然后根据学习的东西编写RTL的设计文档和模块的相关验证操作流程文档，如果能请组内人员一起review，则更好；然后才是RTL代码的设计。这里给出一个简单的RTL设计文档的例子，实际使用时可根据情况完善。
RTL设计文档至少需要包含如下这些部分：
1 文档标题，版本号，作者，修订历史记录（修改者信息，版本号，修订内容，修订日期—），文档目录，图目录，表目录等；
2 模块整体设计要实现的功能以及模块在整体工程中的位置结构
3 模块整体设计所采用的设计思路和实现原则
4 整体组织结构，整体的控制流、数据流和顶层IO接口设计原则和方案
5 整体验证思路和方案，包括验证的数据配置和流程图
6 各个子单元的设计思路，包括了子单元的设计框图，IO端口名称及其作用和测试波形描述
7 关键节点的位置、作用以及测试波形的描述
总体来说文档编写的原则包括：先写总体方案，然后描述详细的设计方案，两者缺一不可；要包含为了提高测试覆盖率和验证设计系统结构的方案；时序描述应逐级开展，首先完成顶层的时序设计，然后对单个模块进行描述。
阶段2：RTL代码阶段
使用的工具有：Verilog语言、文档编辑器VIM、spyglass语法检查工具
输入是来自与算法的spec文件或者相应的协议
需要达到的标准：1 符合代码的编写规范；
2 spyglass lint检查中出现的error需要为0，并确认warning没有问题；
3 完成spyglass cdc的检查和确认；
4 spyglass lint/dft报告中确认除第三方IP外无blackbox，error为0，确认warning没有问题，没有使用既带rest又带set的寄存器；
5 能实现模块的主要功能；（这一点可以放在阶段3中，不过这一步应有设计者完成）
阶段3：仿真验证阶段
使用的工具有：VCS、Verdi、SystemVerilog、UVM
输入为：RTL代码，验证操作流程文档、算法代码
需要达到的输出标准：1 功能覆盖率100%；
2 代码覆盖率（分支覆盖率、FSM——状态机的覆盖率、翻转覆盖率）100%，如果有部分覆盖率没有达到100%，需要算法和IC设计给出相应的合理说明；
3 相关的验证文档和验证结果报告文档；
阶段4：综合阶段
使用的工具为：Design Compiler
输入为：RTL代码、.db的库文件、SDC约束文件
输出标准要求：1 综合时的corner需要包含高温和低温的ss；
2 读取RTL设计文档时没有error，并确认存在的warning无影响；
3 确认link log中没有unresolved（没有解析的），没有error；
4 读取约束文件时没有error，并确认warning没有影响；
5 检查时序，确认没有uncontrained endpoint，没有timing loop；
6 查看时序报告，确认没有时序违反，尤其是setup time的时序违反，没有与memory相关的min pulse/period违反；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cbf15a196762ec545c993e8b71f2956/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f712e1cde321f2a8f663c6f16be8be33/" rel="bookmark">
			超级详细的注释C语言简单实现童年小游戏：贪吃蛇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
记得小时候还没有现在超级高端的智能手机，当时的诺基亚类型的老人机是我的最爱，而里面的贪吃蛇小游戏我总是能玩很久，所以今天就用C语言简单实现一下贪吃蛇这一个小游戏吧。
一、 准备工作：
1、VS2019简单配置：
我感觉只要与小游戏相关的那些函数你多多少少都要用到easyx的所以不妨给你们弄一下怎么配置，不然很多小伙伴会问为啥我的编译器运行会有一堆报错！！！
如何配置：EasyX头文件的配置。参考这篇博文，可以说简单易懂了！！！
二、实现逻辑：
1、贪吃蛇初始化为三个节点
2、吃一个食物贪吃蛇增加一个节点也就是size：
这里运用判断蛇头坐标与食物坐标是否在食物大小的半径范围内若是则吃若不是则不吃，当然肯有一些小伙伴会问为什么不直接判断坐标重合则吃掉食物呢？嘿嘿嘿，这里坐标就是一个点，你要让两个点在一块屏幕上重合的难易程度可想而知。
3、贪吃蛇不能吃自己的身体
贪吃蛇不能吃自己的身体，这里直接使用的snake_check函数中一个判断去判断蛇头的坐标是否与除了蛇头以外的蛇尾坐标是在蛇身的半径范围内与吃食物比较类似
4、贪吃蛇不能直接从上到小掉头而是需要拐一个弯
利用条件语句实现：
三、直接上代码吧，因为我都在代码里注释的都有：
#include&lt;stdio.h&gt; #include&lt;conio.h&gt; #include&lt;graphics.h&gt; #include&lt;time.h&gt; #include&lt;stdlib.h&gt; #include&lt;Windows.h&gt; /* 作者：有·意思 实现内容：贪吃蛇小demo 制作时间：2022/4/8 代码不足：没有实现图形化界面，仅仅实现了贪吃蛇的基本逻辑 */ /* 操作：大写的WSAD分别对应上下左右 或者小写的wsad分别对应上下左右 */ //窗口的大小 #define WID 480 //宽度 #define HIGHT 640 //高度 #define SNAKE_NUM 500 //蛇的最大程度 #define FOOD_NUM 1 //定义一个反向的枚举常量 enum FANG { UP, DOWN, LEFT, RIGHT, }; //蛇的属性（结构体） struct Snake { int size;//蛇的大小 int fang;// 蛇的放向 int speed;//蛇的移动速度 POINT location[SNAKE_NUM];//蛇的坐标POINT就是一个定义了xy的坐标结构体可以直接使用 }snake; //食物的结构体 struct Food { bool eat;//食物是否被贪吃蛇吃掉 POINT location[FOOD_NUM]; }food; void initgame()//初始化函数 { initgraph(HIGHT, WID);//初始化窗口 srand((unsigned)time(NULL));//产生随机数 //初始化贪吃蛇的： snake.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f712e1cde321f2a8f663c6f16be8be33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da809b5d82a93a6328993f871f321f77/" rel="bookmark">
			Could not find com.android.tools.build:gradle 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		repositories 也设置了
下载 gradle-6.8.1-all.zip
setting -》 gradle -》 use gradle from 选择 ‘gradle-wrapper.propertiers’
setting -》 gradle -》 gradle user home 选择解压 gradle-6.8.1-all.zip 后的目录
下面关键的来了
dependencies {
classpath ‘com.android.tools.build:gradle:4.0.0’
}
这个是插件版本，并不是你的 gradle 的版本，
插件跟gradle版本对比看如下链接：
https://developer.android.google.cn/studio/releases/gradle-plugin.html
我之前一直把插件版本跟 gradle 写成一样，结果怎么都是报 Could not find com.android.tools.build:gradle 错误。希望你避免踩坑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e380be04ca9e3a58e0b8b69de3f78e0/" rel="bookmark">
			CRC32校验原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CRC即循环冗余校验(Cyclic Redundancy Check)：是数据通信领域中最常用的一种差错校验码，其特征是信息字段和校验字段的长度可以任意选定。
CRC校验实用程序库：在数据存储和数据通讯领域，为了保证数据的正确性，就不得不采用检错的手段。
CRC码校验原理：
发送端：发送端根据信息字段与生成多项式生产呢个CRC码，CRC码作为数据发送给接收端，同时也会把计算出的校验字段的数据一同发送(注：目的是如果接受端检测到发送的数据是正确的，接收端能够从CRC码中提取出信息字段的数据)。
接收端：接收到CRC码数据后，检测接收到的数据是否正确，方法：将CRC码数据与生成多项式进行模2除，如果余数为0，则说明接收到的数据是正确的。然后，从CRC码中提取出信息字段的数据。
实现方法：
1、发送端生成CRC码方法：
CRC码是由两部分组成的，前部分是信息字段，就是需要校验的信息，后部分是校验字段，如果CRC码共长n个bit，信息字段长k个bit，就称为(n，k)码。它的编码规则是：
首先将信息字段值(k bit)左移r位(k+r=n)
运用一个生成多项式g(x) (也可看成二进制数) 模2除上面的式子，得到的余数就是校验字段值。
生成的CRC码值为：信息字段值+校验字段值(单位：位bit，次序：高位到低位)，例如字段值为1001，校验字段值为110，则CRC码为1001110
2、接收端验证过程：略；
CRC32校验算法-C实现：&gt; 提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
/***************************************************** ** Name : crc32.c ** Description : CRC32 Checking ******************************************************/ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #define BUFSIZE 1024*4 static unsigned int crc_table[256]; const static char * program_name = "crc32"; static void usage(void); static void init_crc_table(void); static unsigned int crc32(unsigned int crc, unsigned char * buffer, unsigned int size); static int calc_img_crc(const char * in_file, unsigned int * img_crc); static void usage(void) { fprintf(stderr, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e380be04ca9e3a58e0b8b69de3f78e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a697d2b3ba7727bad075a3f2dc7aed/" rel="bookmark">
			微信电脑版的加密dat文件怎么转成jpg图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
微信电脑版聊天过程收发的图片，都是加密保存的，一般人即使找到这些文件，也是看不了的。
这些图片文件一般会占用巨大的硬盘空间，假如想清理掉无用的图片，来节省硬盘空间，如何留下有用的图片文件，又是个大问题，或者说想看看孩子有没有看不健康的东西，这种情况如何处理。
本文介绍一种在不登录微信的情况下，查看微信的聊天图片的方法。 如何找到文件
要找到文件比较容易，如果微信能登录，可以通过以下几步找到
如果微信已经不能登录，可以打开【此电脑】-【文档】-【WeChat Files】，这个文件夹下会看到一些微信号命名的文件夹，图片就在这些文件夹里，点击进入后就是上面的第4步。
如果文档里没有，只能在其它地方找找了，文件夹的名字一般就是【WeChat Files】
文件如何转换
进入【Image】文件夹后，里面有不少日期文件夹，当月产生的聊天图片都会在相应月份的文件夹里
这里需要准备一个转换工具，叫做《天才小网管DAT转JPG》（点击这里下载），也可以在本文章末尾参考资料中可找到
转换工具下载到电脑中后，解压，然后双击主程序打开。
软件打开后界面：
第一个格子选择到上面找到的文件夹的月份的文件夹，也可以粘贴进去，第二个格子选择要保存的文件夹，像下面这样：
最后点击“一键转换”，等待软件转换完成就可以了：
转换完成后，在保存的文件夹里有转换完成的图片，可以直接双击打开
这样可以人工检查和删除没用的图片，留下重要的图片，这时就可以删除整个文件夹的DAT文件了。
如果这些重要的图片还需要在微信聊天窗口中，那可以这样，把这些文件放到原来的DAT文件夹中，然后按文件名排序，这样同名的DAT文件和JPG文件会挨在一起，把没有成对的DAT文件删除就可以了，这样即删除了没用的图片，又不影响在微信中查看重要图片。
如果你看的是别人家的微信的图片，不是为了省空间，那就不用折腾上面这步了。
参考资料 微信电脑版的加密dat文件怎么转成jpg图片-软件应用-非常361微信电脑版的加密dat文件怎么转成jpg图片是非常361中一篇关于软件应用的文章，欢迎您阅读和评论,非常361https://www.very361.com/post/33.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d10d4530f617866fa30b9ab7600a2e7/" rel="bookmark">
			qt 3d 飞行模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c75a93ef3ddbaef5e533d3b4a24f575f/" rel="bookmark">
			一文读懂交叉熵损失函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进行二分类或多分类问题时，在众多损失函数中交叉熵损失函数较为常用。
下面的内容将以这三个问题来展开
什么是交叉熵损失以图片分类问题为例，理解交叉熵损失函数从0开始实现交叉熵损失函数 1，什么是交叉熵损失
交叉熵是信息论中的一个重要概念，主要用于度量两个概率分布间的差异性
p(x)表示样本的真实分布，q(x)表示模型所预测的分布
**交叉熵能够衡量同一个随机变量中的两个不同概率分布的差异程度，在机器学习中就表示为真实概率分布与预测概率分布之间的差异。交叉熵的值越小，模型预测效果就越好。
交叉熵在分类问题中常常与softmax是标配，softmax将输出的结果进行处理，使其多个分类的预测值和为1，再通过交叉熵来计算损失。**
2，以图片分类问题为例，理解交叉熵损失函数
Fashion-MNIST数据集是一个包含60000衣服，鞋子等图片的数据集，也是实验图像分类算法经常用的数据集。具体图片类别及其标签如下
这里，我们就以在这个数据集上的图片分类问题为例，理解交叉熵损失函数。
假设某个场景如下：对于我们设计的用于图片分类的卷积神经网络的训练还没有完成，此时，终止我们的训练，显然，各种层的参数已经保留。从数据集中任选一张图片（类别已经被记录），输入我们的神经网络，结果输出的是一个包含10个数据的一维张量，这10个数据分别对应10种物品的概率。不妨记为
q=[0.1058, 0.1043, 0.0988, 0.1066, 0.0875, 0.0881, 0.1027, 0.1046, 0.1057, 0.0958]
很显然，这个预测结果有点糟糕，不过主要是因为网络没有训练好。同时我们也已知道这个图片的真实类别为4，这时记
p=[0,0,0,0,1,0,0,0,0,0]
带入交叉熵损失函数，计算如下：
loss= -(0xlog(0.1058)+0xlog(0.1043)+0xlog(0.0988)+0xlog(0.1066)+1xlog(0.0875)+0xlog(0.0881)+0xlog(0.1027)+0xlog(0.1046)+0xlog( 0.1057)+0xlog(0.0958))=2.4361
这个结果就是我们的交叉熵损失，当然，我们希望越小越好，这意味着我们的神经网络较为成功。
其实，这个神经网络的训练过程就是对于输入的60000个数据（这里全部作为训练集，没有设置测试集），进行预测，计算损失，更新权重不断使得损失减小，循环往复。最终在训练很多轮后，使得损失足够小，分类的精度足够的高。那么我们可以认为这个神经网络在这个数据集上有较为不错的效果。
3，从0开始实现交叉熵损失函数
当然，pytorch中已经有这个函数，叫做 CrossEntropyLoss()。当然这个函数的输入不是一组概率，而是一组数据，可正可负。
这个函数先对输入的数据进行softMax操作 ，将其转换为概率，再与标签数据按上面的交叉熵损失函数计算。
也就等价于softMax+上面定义的函数（log+NLLLOSS)。
所以我们的交叉熵损失函数实现如下：
softmax:
def soft_max(data): t1=torch.exp(data)#对所有数据进行指数运算 s=t1.sum(dim=1) #按行求和 shape=data.size() m=shape[0]#获取行数 n=shape[1] for i in range(m): t1[i]=t1[i]/s[i] return t1 cross_entropyloss
def cross_entropyloss(input,target): shape=data.size() m=shape[0]#获取行数 output=-torch.log(input[range(m),target.flatten()]).sum()/m print(input[range(m),target.flatten()]) return output 比较：
#自己编写 data=torch.tensor([[-1,0.5,2],[-1,0.5,3]]) t1=soft_max(data)#将预测数据转换为概率！！！ #此处为重点 t2=cross_entropyloss(t1,torch.tensor([1,2])) print(t2) ------------------------------------------ #PyTorch中的原函数 crossentropyloss=nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c75a93ef3ddbaef5e533d3b4a24f575f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c10e37dc56addcb8350426d2990f47/" rel="bookmark">
			CSDN（markdown模式下）如何调整图片大小以及如何调整位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 下面我将以如下图片为例来为大家讲解如何操作。
尝试过在CSDN（markdown模式下）插入图片的兄弟们一定知道，插入的图片默认是霸占整个宽度的，这样就会导致图片过于大，达不到预期效果。可恼的是在此模式下你是无法像word那样通过鼠标的拖动来实现图片的放大和缩小；且功能栏里还没有调整位置操作，无法实现图片的居中、向左、向右、两端对齐。那么如何操作呢？分享给大家两种方法。
第一种 在图片链接后添加指令（注意：在“=”前应当添加一个空格）。
首先我们先插入一个图片，就可得到如上图所示的图片及以及图片的链接。在连接的末尾添加一段指令就可实现调整位置的操作了（我标注箭头的地方）。
居中对齐操作：#pic_center
向左对齐操作：#pic_left
向右对齐操作：#pic_right
如若想调整图片的尺寸那在之前指令后面加上“ =200x”就行，其中这个200x指的是图像宽200像素，高的大小会自动按比例缩放；当然，也可同时改变宽和高的大小“ =200x200”，但会破坏比例。
效果如下：
第二种 把图片的链接放如&lt;img src=" XXX " width="30%"&gt;这样的指令中。
搞到图片的链接
红线划出的就是该图片链接，复制该链接然后删除该图片，套进&lt;img src=" XXX " width="30%"&gt;公式中就可达到改变图片大小的目的了。
但此方法只能实现图的居中，无法左右对齐，即：&lt;center&gt;&lt;img src=" XXX " width="30%"&gt;&lt;/center&gt;。
效果如下：
希望多大家有帮助，谢谢！！！
如果这份博客对铁们有所帮助，或能够使你产生共鸣的，请不要吝啬你的点赞和关注哟，谢谢！！！
如果有什么疑问或不同的见解，欢迎评论区留言欧 &gt;_&lt;…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebed4dd9e18f4f7b4ffd3435181be261/" rel="bookmark">
			如何在VS上创建C语言程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开你所下载的VS编译器（2013、2019、2022都一样），我所演示的是VS 2019。
打开后跳出此界面，然后点击创建新项目。（我这选择的是黑色背景，如你是白色的没什么大碍）
点击空项目，然后选择下一步。
输入项目名称，选择存放位置，点击创建。
鼠标右击源文件，选中添加，点击新建项。
输入名称且后缀改为“ .c ”,然后点击添加。
然后就可以写代码了。
如果这份博客对铁们有所帮助，或能够使你产生共鸣的，请不要吝啬你的点赞和关注哟，谢谢！！！
如果有什么疑问或不同的见解，欢迎评论区留言欧 &gt;_&lt;…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57216be284f56dc6d40a95268e277eac/" rel="bookmark">
			R语言入门（23）-数据处理之reshape2包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、rbind与cbind函数
二、merge函数
三、reshape2包
melt函数
dcast、acast函数
一、rbind与cbind函数 cbind：将m列数据与n列数据合并，最终得到一个m+n列的数据。
使用前提是：cbind（x，y）中的矩阵x，y的行数必需相同。
rbind：将m行数据与n行数据合并，最终得到一个m+n行的数据。
使用前提是：cbind（x，y）中的矩阵x，y的列数必需相同。
#我们使用R自带的airqualty做演示 &gt; airquality ozone solar.r wind temp month day 1 41 190 7.4 67 5 1 2 36 118 8.0 72 5 2 3 12 149 12.6 74 5 3 4 18 313 11.5 62 5 4 5 NA NA 14.3 56 5 5 6 28 NA 14.9 66 5 6 7 23 299 8.6 65 5 7 8 19 99 13.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57216be284f56dc6d40a95268e277eac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184603127fd50e0850ab1ae446101a6f/" rel="bookmark">
			利用反射为一个只含有setter和getter普通方法的Person类生成一个MyPerson.java文件。之前没做，现在自己动手打一遍，对反射更加熟练了，动态之美。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述:我已经事先写好了一个Person类如下
包含各个属性的setter和getter方法，以及构造器，现在我要编写一个Generate类，传入Person类的全路径，通过反射获取Person的结构，并写一个MyPerson.java文件，除了类名改为MyPerson，其余属性，方法与Person类一模一样，也就是复制。
public class Generate { private String classFullPath;//存放Person类的全路径 private Class clazz;//Person类的Class对象 private StringBuilder sb = new StringBuilder();//整个MyPerson.java文件的内容 public Generate(String classFullPath) { this.classFullPath = classFullPath; try { clazz = Class.forName(classFullPath); } catch (ClassNotFoundException e) { System.out.println("传入类的全路径错误"); } } } class StringUtil { /** * 传入全路径：xxx.xxx.name ，得到名字name */ public static String getName(String fullName) { int index = fullName.lastIndexOf("."); return fullName.substring(index+1); } } 准备好后，开始编写各个方法
1.packgee 包名以及class 类名｛ 每一个.java文件第一行都要写当前包名，
/** * 写包名：package 包名 */ public void getPackageDesc() { String name = clazz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/184603127fd50e0850ab1ae446101a6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a0e37ebf7ed1c2798005a6f1ece91f7/" rel="bookmark">
			用指针访问二维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言用指针访问二位数组通过指针访问二维数组的不同形式==*a和a 是两个完全不同的概念：====为什么不能用*p=a==二维数组元素的访问的四种方式：1、通过下标访问数组元素2、通过数组首地址访问数组元素3、通过指针访问数组元素（以一维数组的角度“看待”二维数组”）4、通过指针访问数组（以二维数组的角度“看待”数组） 指向字符串的二维数组 实例：学生成绩思考 （如果看不懂，请回退往前再看） 二维数组作为函数的参数1、以一维数组的角度“看待”二维数组2、以二维数组的角度“看待”一维数组 课后练习答案方法一：用二维数组的方式看待程序：方法二： 用一维数组的方式看待程序： 前言 如何理解二维数组？我们以二维的方式理解二维数组，他在存储时却是一维的。
用指针访问二位数组 例：int a[3] [4] = {1,3,5,7,9,11,13,15,17,19,21,23};
a[0] [0]a[0] [1]a[0] [2]a[0] [3]a[1] [0]a[1] [1]a[1] [2]a[1] [3]a[2] [0]a[2] [1]a[2] [2]a[2] [3] 我们想象的二维数组的存储方式：3行4列
a[0] [0]a[0] [1]a[0] [2]a[0] [3]a[1] [0]a[1] [1]a[1] [2]a[1] [3]a[2] [0]a[2] [1]a[2] [2]a[2] [3] 我们认为前四个是一个以a[0]为数组名的一位数组，共有四个int元素
中间四个是名为a[1]的一维数组
最后四个是名为a[2]的一维数组
通过指针访问二维数组的不同形式 *a和a 是两个完全不同的概念： a看待这个数组认为这个数组是一维数组，它自身加一会转向下一个一维数组即a+1
*a指向的是每个元素都是整数的一维数组所以就认为 *a+0 指向的就是整数，加一就是下一个整数
为什么不能用*p=a int x,*p; double y,*q; p=&amp;x; q=&amp;y; p=q;//是错的 //p是指向四个字节为存储单元的地址 //q是指向八个字节为存储单元的地址 //两者不可以等价 二维数组元素的访问的四种方式： 1、通过下标访问数组元素 int a[3][4]; for (int i=0; i&lt;3; i++) for (int j=0; j&lt;4; j++) a[i][j] = i+j; int a[3][4]; for (int i=0; i&lt;3; i++) for (int j=0; j&lt;4 ;j++) *(*(a+i)+j)=i+j; 2、通过数组首地址访问数组元素 对于二维数组元素a[i] [j], “【】”实际上是变址运算符，即将元素a[i] [j]的存储地址转换为a[i] + j。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a0e37ebf7ed1c2798005a6f1ece91f7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/282/">«</a>
	<span class="pagination__item pagination__item--current">283/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/284/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>