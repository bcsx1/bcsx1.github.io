<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a675b4f64d08af441acd091c1a0e4f7f/" rel="bookmark">
			微信小程序两个非父子组件之间实时通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：解决a页面数据变化，b页面实时响应的问题
解决办法：
在app。js中定义有一个全局变量，对这个变量进行监听
globalData: { APIBaseURL: "", // api基础URL imageBaseURL: "", // 图片基础URL socketURL: "", // socket基础URL authorization: "", // 登录态 account: '', recondNum:-1, }, //app 全局属性监听 watch: function (method) { var obj = this.globalData; Object.defineProperty(this, "globalData", { //这里的 globalData对应 上面 globalData configurable: true, enumerable: true, set: function (item) { //动态赋值，传递对象，为 globalData 中对应变量赋值 obj.recondNum = item.recondNum; method(value); }, get: function () { //获取全局变量值，直接返回全部 return obj; } }) }, 2.在a页面中将获取到的数据变量赋值给定义的全局变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a675b4f64d08af441acd091c1a0e4f7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18684843248ce71e3cef93c42dc525b/" rel="bookmark">
			剑指 Offer 51. 数组中的逆序对
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		### 解题思路
利用归并排序算法:
由于用于归并的两个序列是已序的,所以在进行两辆比对时,序列A中的一个数大于序列B中的一个数,那么序列A中这个数的后面所有数都大于这个数
### 代码
class Solution { public: int res = 0; vector&lt;int&gt; temp; int mergeSort(vector&lt;int&gt;&amp; nums,int l,int r){ if(l &gt;= r) return 0; int mid = (l + r) &gt;&gt; 1; int t1 = mergeSort(nums,l,mid); int t2 = mergeSort(nums,mid+1,r); int p1 = l,p2 = mid+1,k=0; int t3 = 0; while(p1 &lt;= mid &amp;&amp; p2 &lt;= r){ if(nums[p1] &gt; nums[p2]){ temp[k++] = nums[p2++]; t3 += mid-p1+1; } else temp[k++] = nums[p1++]; } while(p1 &lt;= mid) temp[k++] = nums[p1++]; while(p2 &lt;= r) temp[k++] = nums[p2++]; for(int i = l,j=0;i &lt;= r;i++,j++) nums[i] = temp[j]; return t1 + t2 + t3; } int reversePairs(vector&lt;int&gt;&amp; nums) { temp = vector&lt;int&gt;(nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b18684843248ce71e3cef93c42dc525b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/badf7ce8d464554a6d956962dddf35b6/" rel="bookmark">
			python快速开启一个http服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：
在我们工作中，经常遇到需要从远程服务器下载一些文件在本地分析(如tcpdump 抓的包)或者分享一些自身电脑安装包给同事，以下方法可能是一种很好的方式
1. 进入文件目录，执行
python3执行：python3 -m http.server
python2执行： python2 -m SimpleHTTPServer
2. 浏览器页面访问即可下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05be917b965408050ad679719f65d533/" rel="bookmark">
			@Valid使用详解以及自定义注解的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@Valid注解用于校验 一.@Valid注解的基本使用: 步骤1：将@Valid注解直接加在变量user之前，并且传入BindingResult对象(也可不传入)，用于获取校验失败情况下的反馈信息，如下代码
@RestController @RequestMapping("/user") public class UserController { @PostMapping public User create (@Valid @RequestBody User user, BindingResult bindingResult) { if(bindingResult.hasErrors()){ System.out.println(bindingResult.getFieldError().getDefaultMessage()); return null; } System.out.println(user.getId()); System.out.println(user.getUsername()); System.out.println(user.getPassword()); user.setId("1"); return user; } } 步骤2：然后在 User 类中添加验证信息的要求
@Data public class User { private String id; private String username; @NotBlank(message = "密码不能为空") private String password; } @NotBlank 注解所指的 password 字段，表示验证密码不能为空，如果为空的话，上面 Controller 中的 create 方法会将message 中的"密码不能为空"返回。
二.数据验证的规则 @Entity ：表明是一个实体类 @Table(name="xxx")不加name默认是类名小写 @Id 主键注解 @GeneratedValue（）主键生成策略 @Column（name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05be917b965408050ad679719f65d533/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48088215ebaf9818267963ac7b0baf13/" rel="bookmark">
			java之学习记录 7 - 2 - 分布式文件系统—FastDFS介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 场景概述 天猫，淘宝等购物网站，大量的图片和视频，文件太多，如何存储？ 用户访问量大又如何保证下载速度？分布式文件系统就是解决这些问题的！ 1.1 什么是文件系统 文件数据是如何存储的？？ 1.2 分布式文件系统 一台电脑存储量有限，并且并发吞吐量也有限，如何提高性能？ 一吨货物，我要运送到吐鲁番： 1个人运，不敢想象 50个人运，太难了； 500个人运，每个人都很轻松； 这就是分布式吗？ 答：这里面有集群的概念，也有分布式的概念，二者不要混淆，面试常问的经典题目 分布式：不同的业务模块部署在不同的服务器上或者同一个业务模块分拆多个子业务，部署不同的服务器上。解决高并发的问题； 集群：同一个业务部署在多台服务器上，提高系统的高可用 例如： 小饭馆原来只有一个厨师，切菜洗菜备料一手抓。客人越来越多，一个厨师忙不过来，只能再请一个厨师，两个厨师都能炒菜，也就是两个厨师的作用是一样的，这样，两个厨师的关系就是“集群”； 为了让厨师专心炒菜，把菜炒到极致，又请了配菜师负责切菜，备料等工作。厨师和备菜师的关系是“分布式”； 一个备菜师忙不过来，要提供两份食材给两个厨师，又请了一个备菜师，两个备菜师的关系又是“集群”。 1.3 主流的分布式文件系统 1.3.1 HDFS (Hadoop Distributed File System)Hadoop 分布式文件系统； 高容错的系统，适合部署到廉价的机器上； 能提供高吞吐量的数据访问，非常适合大规模数据应用； HDFS采用主从结构，一个HDFS是由一个name节点和N个data节点组成； name节点储存元数据，一个文件分割成N份存储在不同的data节点上。 1.3.2 GFS Google File System 可扩展的分布式文件系统，用于大型的，分布式的，对大量数据进行访问的应用； 运行于廉价的普通硬件上，可以提供容错功能； 它可以给大量的用户提供总体性能较高的服务； GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver（分块服务器）组成； 一个文件被分割若干块，分散储存到多个分块server中 1.3.3.FastDFS 由淘宝资深架构师余庆编写并开源； 专为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务； HDFS，GFS等都是通用的文件系统，他们的优点是开发体验好，但是系统的复杂度较高，性能也一般； 相比之下，专用的分布式文件系统体验差，但是复杂度低，性能也高，尤其fastDFS特别适合图片，小视频等小文件，因为fastDFS对文件是不分割的，所以没有文件合并的开销； 网络通信用socket，速度快。 1.4 工作原理 fastDFS包含Tracker Server和Storage Server； 客户端请求Tracker Server进行文件的上传与下载； Tracker Server调度Storage Server最终完成上传与下载。 Tracker （译：追踪者） 作用是负载均衡和调度，它管理着存储服务（Storage Server），可以理解为：“大管家，追踪者，调度员”； Tracker Server可以集群，实现高可用，策略为“轮询”。 Storage （译：仓库; 贮存器） 作用是文件存储，客户端上传的文件最终存储到storage服务器上； storage集群采用分组的方式，同组内的每台服务器是平等关系，数据同步，目的是实现数据备份，从而高可用，而不同组的服务器之间是不通信的； 同组内的每台服务器的存储量不一致的情况下，会选取容量最小的那个，所以同组内的服务器之间软硬件最好保持一致。 Storage Server会连接集群中的所有Tracker Server，定时向他们汇报自己的状态，例如：剩余空间，文件同步情况，文件上传下载次数等信息。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48088215ebaf9818267963ac7b0baf13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66005c7653b865b4513115b7e73e06ed/" rel="bookmark">
			三分钟熟悉进制转换与位运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信搜索【NO编程】，关注这个不一样的公众号。
个人网站：www.newobject.cc
版权声明：本文为原创文章，转载请注明出处。
进制和位运算简介 进制也叫进位制，是一种记数方法，也称进位计数法，利用这种记数法可以使用有限的数字符号来表示所有的数值。
一种进制中可以使用的数字符号的数目称为这种进位制的基数，若一个进制的基数为 N，则可称之为 N 进制，即表示数值时满 N 进一。
在生活中最常用的是十进制，使用 10 个阿拉伯数字 0 到 9 进行记数。而在电子计算机领域，内部使用的是二进制，电路的状态通过 0 和 1 表示来实现记数。八进制和十六进制计算机领域也较为常用，尤其十六进制。
位运算则是在程序中对二进制数的一元和二元运算操作。
在 JDK 以及框架源码中都存在进制转换和位运算的身影，作为开发人员应该熟悉基本的进制转换和位运算（最起码得能看懂吧）。
进制转换 例如，十进数的 13，二进制的 1101，他们表示相同的数值，只是不同的表现形式而已，那么不同进制之间如何相互转换呢？
十进制转换 N 进制，可以通过“短除法”求余数然后倒序得到转换结果，一个十进制数转换为 N 进制就除以 N，例如：
将十进制数 123 转换为二进制。
结果：1111011
将十进制数 123 转换为十六进制。
结果：7b
N 进制转为十进制可以通过“按位权展开法”来转换，即在 N 进制中，每个位置的数字乘以进制的基数为底的所处位置序号(从 0 开始)为指数的整数次幂，然后相加。例如：
将二进制数 1111011 转换为十进制。
1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66005c7653b865b4513115b7e73e06ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c194ae89247830f4a6a5e26d21487e65/" rel="bookmark">
			c&#43;&#43;11的move forward(二)特殊使用规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通用引用版本和右值引用版本的一些异同比较 假定要实现一个person类，并且实现一个设置person name的方法setName。
第一种，通用引用版本(对通用引用使用std::forward)
class person { public: template&lt;class T&gt; void setName(T&amp;&amp; name) { name_ = std::forward&lt;T&gt;(name); } private: std::string name_; }; 第二种，重载左值引用和右值引用版本
class person { public: void setName(const std::string&amp; name) { name_ = name; } void setName(std::string&amp;&amp; name) { name_ = std::move(name); } private: std::string name_; }; （1）非const左值引用只能绑定到非const左值；
（2）const左值引用可绑定到const左值、非const左值、const右值、非const右值；
（3）非const右值引用只能绑定到非const右值；
（4）const右值引用可绑定到const右值和非const右值。
两种版本比较：
万能引用版本传入参数不能是const。如果传入的name参数是不可更改的，const左值引用版本会更符合。
更正：以上理解错误。根据模板类型推导，万能引用版本如果传入const左值引用，T和ParamType都会被推到为const左值引用类型。无论是const左值引用还是非const左值引用传入后都为const左值引用类型。而万能引用版本非const左值引用传入参数还是非const左值引用。所以重载左值版本只是为了将传入的参数加上const属性限制。
考虑一种使用场景：
person p; p.setName("abc"); 如果是通用引用版本，字符串"abc"是一个右值，T会被推导为const char*类型，parmtype推导为const char* &amp;&amp;类型，直接将字符串"abc"传入函数，调用std::string的赋值操作，期间没有产生std::string的临时对象。
如果是重载右值引用的版本，字符串"abc"会首先构造一个临时string对象传入，然后调用string的移动赋值操作（右值版本的赋值操作符）。最后还有一次临时string的对象析构。这样的开销肯定要比通用引用版本的开销要大。
c++11 stl中容器新增的emplace_方法其实就是用的万能引用版本。
例如vector的emplace_back方法：
template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c194ae89247830f4a6a5e26d21487e65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b27513a40022f99c91c9379599313a7/" rel="bookmark">
			java capture http_JPCAP：使用Java来sniffer网络数据包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JPCAP：使用Java来sniffer网络数据包
前几天在CSDN社区上看到有人提到用JPCAP可以实现Java抓包的功能，也就是sniffer的功能，很是激动，就下载了一个。发现网上到处流传的那个版本无法使用，就自己实验了一下，把我的例子给贴出来共享一下。
我这个例子只用了基本的功能，由于我发现JPCAP本身带的例子选择网络接口卡时有问题，前面一大部分是选择用本机的哪个网络接口卡来抓包，在Windows 2000下调试通过，可以通过修改相应的端口号抓到关注的某种应用层协议的包，也可以把相应的注释打开看到Raw Packet，并把抓到的包的内容同时显示在控制台上和保存在capture.txt文件里，每次抓包的结果用“****”号作了分割。呵呵，发现这是进行网络实验很好的素材。
JPCAP可以从http://www.sf.net/projects/jpcap上下载，在不同操作系统平台上上运行需要本地库支持，即Windows下需要安装WinPCAP(到http://www.winpcap.org下载)，Linux下需要libcap。
编译和运行下面程序的批处理文件run.bat内容
javac -cp lib\jpcap.jar;. CapturePacketTest.java
java -Djava.library.path=lib -cp lib\jpcap.jar;. CapturePacketTest
下面是测试程序：
// CapturePacketTest.java
import net.sourceforge.jpcap.capture.*;
import net.sourceforge.jpcap.net.*;
import java.util.*;
import java.io.*;
public class CapturePacketTest implements RawPacketListener,PacketListener{
//public Vector CaptureVec = new Vector();
public static FileOutputStreamfos = null;
public static void main(String[] args)throws Exception{
// Print copyright info
System.out.println();
System.out.println("Capture Ethernet packet Ver 0.01, author yanqlv(maomao).");
System.out.println("Copyright (c) 2005 yanqlv of Luoyang Normal College, all Rights Reserved.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b27513a40022f99c91c9379599313a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e303a245bee3bb11fa80e4db00609d69/" rel="bookmark">
			Python初学9——函数的定义与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、函数的定义与使用
1.1 函数的理解与定义
1.1.1 理解
1.1.2 定义（ def、return ）
1.1.3 举例
1.2 函数的使用及调用过程
1.3 函数的参数传递
1.3.1 可选参数传递（可选参数放在后）
1.3.2 可变参数传递（ *b ）
1.3.3 名称方式传递参数
1.4 函数的返回值
1.5 局部变量和全局变量
1.5.1 规则1（ global ）
1.5.2 规则2
1.6 lambda函数
二、“七段数码管显示时间”实例
步骤1：绘制一个七段数码管
步骤2：将一串数字和字母，绘制成数码管
步骤3：获得当前系统时间，绘制对应的数码管
总结
一、函数的定义与使用 1.1 函数的理解与定义 1.1.1 理解 函数是一段具有特定功能、可重复使用的语句组，函数主要是为了降低编程难度和代码复用。
1.1.2 定义（ def、return ） def &lt;函数名&gt;(&lt;参数(0个或多个)&gt;) :
&lt;函数体&gt;
return &lt;返回值&gt;
函数定义时，所指定的参数是一种占位符。参数是输入，函数体是处理，返回值是输出函数定义后，若不调用该函数，则该函数不会被执行 1.1.3 举例 案例：计算n!
图1-1 1.2 函数的使用及调用过程 函数定义出来后，只有对其进行调用，该函数才会被执行。
调用时要给出实际具体的参数，实际参数将替换函数定义中的参数。函数调用后，会得到返回值 图1-2 1.3 函数的参数传递 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e303a245bee3bb11fa80e4db00609d69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25326ab1ffe9111c2568b7d796bda373/" rel="bookmark">
			我的世界国际版仿java版材质包_我的世界国际版如何更换材质包和光影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
光影复支持的安装
光影支持组件：制optifine，官网2113：网页链接。进入后点5261击右上角的downloads连接，下载最新4102版本(黄框所示为1653目前最新版本)：
下载完成后直接用java打开，点install等待其下载完毕，重启正版启动器。在启动器启动选项一栏中点“新建”。
在版本中下拉，找到新增的optifine的版本，保存再使用该配置进入游戏。光影支持组件安装完毕。
资源包的更换
在游戏主菜单点“选项”-“资源包”-“打开资源包文件夹”，将资源包粘贴在该文件夹内，然后重新进入“资源包”界面，右侧会出现你粘贴进的资源包，点击其图标即可将其应用，左侧为已应用的资源包，显示优先级从上到下。例如，Pure BDcraft：
点“完成”，等待其加载新材质，更换即告完成，无须再次更换。
光影包的安装
主菜单-“选项”-“视频设置”-“光影”，点“打开光影包文件夹”，将光影包如材质包一样粘贴进去，然后无须退出光影界面即可通过点击新增的光影文件名应用，一次仅可应用一个。例如：
点击“完成”，加载宣告完毕。
希望该回答会对你有所帮助！
(本来排版挺好的，结果百度自动把换行符去除了，现在仅能使用回车换行，行距较大，见谅！)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90d1818ed27981673a6475333ae8421c/" rel="bookmark">
			vue WebWorker的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webworker 我们知道javascript是单线程，当主线程遇到大量计算或者复杂的业务逻辑时，会对我们的页面造成不好的用户体验。
webworker 很好的解决了这个问题，我们可以在主线程开启一个worker线程执行任务而不干扰用户界面（主线程）
worker描述 感觉还是有点抽象，举个例子。
那撸多（鸣人）这个5s真男人跟佩恩打架，开启了仙人模式，然而他的查克拉不够用，只能维持五秒钟仙人模式，他自己又不能一边打架一边聚集查克拉。这可怎么办？出了穿甲装的佩恩，一刀一个那撸多
这个时候那撸多灵机一动，想起了那个延时保健的小药丸…
咳咳，当然不是，我们大男主利用影分身在看不见的地方凝聚查克拉，凝聚完毕接触分身能量回到主体，嗯来劲了。成功打败佩恩
这里的影分身就相当于worker的作用，一个在你看不见的地方（其实是在浏览器中）默默工作的奉献者。在合适的时候将结果回传给主线程，然后消失，像是没来过一样
worker api使用 主线程中
Worker.onerror：指定 error 事件的监听函数。 Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。 Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。 Worker.postMessage()：向 Worker 线程发送消息。 Worker.terminate()：立即终止 Worker 线程。 示例
//实例化一个线程 let myworker = new Worker('worker.js') //向worker线程 发送信息 myworker.postMessage({name:'kk',finshed:false}) //接受worker线程 myworker.onmessage = (event)=&gt;{console.log(event.data)} //关闭worker线程 worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。 myWorker.terminate(); ``` 在worker.js中 ```js //监听接收 主线程的参数 onmessage = function(event){ // you can start ajax let result = ... //将计算结果回传给主线程 postMessage(result); //workers 也可以调用自己的 close 方法进行关闭 close(); //self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90d1818ed27981673a6475333ae8421c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ffeedd496d54e83c53fbb7cdb857562/" rel="bookmark">
			R语言基础绘图——dot plot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一步步绘制和美化dot plot 简介开始1. 查看数据并转换为长数据格式2. 绘制基础图形3. 添加errorbar和pointrange4. 修改颜色和坐标轴主题5. 加注释 总结 简介 作为文章中经常出现的一种图形，dot plot 可以展示点的分布和统计变化之后的数据均值等特征值。以下是一篇已发表的文章中的图，今天我们将构造数据，一步步实现它。
开始 1. 查看数据并转换为长数据格式 library(tidyverse) library(magrittr) data %&lt;&gt;% pivot_longer(cols = wt:mz_ko) 2. 绘制基础图形 data %&gt;% ggplot(aes(group, value, fill = name)) + geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.9)) 3. 添加errorbar和pointrange data %&gt;% ggplot(aes(group, value, fill = name)) + geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.9)) + stat_summary(fun.data=mean_sdl, fun.args = list(mult=1), geom="errorbar", color="black", width = .07, position = position_dodge(.9), size = .8) data %&gt;% ggplot(aes(group, value, fill = name)) + geom_dotplot(binaxis='y', stackdir='center', position=position_dodge(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ffeedd496d54e83c53fbb7cdb857562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c67416ea60c736ae8b191d4b478e05/" rel="bookmark">
			基于Tensorflow2的YOLOV4 网络结构及代码解析（3）——yolo_head部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者以tensorflow2代码作为基础，解析yolovV4的网络结构。 继上篇《基于Tensorflow2的YOLOV4 网络结构及代码解析（2）——NECK部分》博文后继续解析yoloV4的yolohead
本篇博客主要介绍两个个方面：
1.yolo解码 2.门限筛选和非极大值抑制 在进入yolo_head之前，先看一下源码中的参数配置以及一些语法细节，代码如下：
if self.eager: self.input_image_shape = Input([2,],batch_size=1) inputs = [*self.yolo_model.output, self.input_image_shape] outputs = Lambda(yolo_eval, output_shape=(1,), name='yolo_eval',arguments={'anchors': self.anchors, 'num_classes': len(self.class_names), 'image_shape': self.model_image_size, 'score_threshold': self.score, 'eager': True, 'max_boxes': self.max_boxes})(inputs) self.yolo_model = Model([self.yolo_model.input, self.input_image_shape], outputs) 这段代码中，有几个值得注意的地方：
1.inputs = [*self.yolo_model.output, self.input_image_shape]中“*”的用法：
*号的意思表示将列表解开，当作独立的参数传入函数。**的意思是将字典解开，当作独自的参数传入函数。上面代码意思就是将3个model.output的Tensor和Input生成的Tensor组成inputs列表
2."Lambda"的用法：
此处的Lambad不是python自带的lambda语法。他更应该理解为自定义层的一种简便写法，生成层对象，适用于简单的操作。因此，源码可以理解为将诸如anchors,num_class,image_shape等参数传给yolo_eval函数，得到1维结果
3.eager模式：
tf1.5之后引入eager模式，到了tf2之后默认采用eager模式。之前调试tf的时候，需要先构建好完整的图后再run.这样debug的时候极其麻烦，更不利于自定义层的创建。而通过eager模式，做一步便可以看到结果，调试难度大大降低。
完成传参后进入“yolo_eval"函数，该函数实现了解码，非极大值抑制，门限删选等一系列工作。
for l in range(num_layers): _boxes, _box_scores =yolo_boxes_and_scores(yolo_outputs[l],anchors[anchor_mask[l]], num_classes, input_shape, image_shape) 该函数中调用了”yolo_head“和”yolo_correct_boxes“。它们的作用是将特征图解码和对应到原图上的位置和尺寸。
该函数代码中，利用变量anchor_mask对anchor进行配置（可能为了美观，在anchor初始时未调整顺序）。anchor与特征图相对于关系为:
# 13x13的特征层对应的anchor是[142, 110], [192, 243], [459, 401] # 26x26的特征层对应的anchor是[36, 75], [76, 55], [72, 146] # 52x52的特征层对应的anchor是[12, 16], [19, 36], [40, 28] yolo解码: box_xy, box_wh, box_confidence, box_class_probs = yolo_head(feats, anchors, num_classes, input_shape) 函数"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c67416ea60c736ae8b191d4b478e05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7817a2bea850dd40e5e2f3abe5c4732/" rel="bookmark">
			【回顾】对SQL调优的初步理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、一般情况下的SQL优化 对于单表查询的SQL，如果跑的慢，十有八九是因为那个SQL没有使用索引，第一步可以先去查看MySQL的执行计划，看看哪个SQL有没有用到索引，如果没有，就改写一个SQL让它去用上索引，或是额外再加一个索引。
二、执行计划 如何查看执行计划？如：
explain select * from table; 得到的结果为：
table | type | possible_keys | key | key_len | ref | rows | Extra table：那个表
type：走的是全表扫描还是索引？如何走的索引
possible_keys：显示可能使用的索引
key：实际使用的索引
key_len：使用索引的长度
ref：联合索引的哪一列被用了
rows：一共扫描和返回了多少行
Extra：如using filesort（需要额外进行排序）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78459903117ac2e33a6d5fb1cd4e9979/" rel="bookmark">
			202012-2期末预测之最佳阈值 [c&#43;&#43;]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 202012-2期末预测之最佳阈值 [c++]题目描述解法一（暴力）解法二（排序+线性算法） 202012-2期末预测之最佳阈值 [c++] 题目描述 202012-2期末预测之最佳阈值
解法一（暴力） #include &lt;iostream&gt; using namespace std; int main() { int n; int i,j; int y[100000],result[100000]; int sum = 0; int max_count = 0; int max_index = 0; int count_i = 0; cin &gt;&gt; n; for (i = 0; i &lt; n; i++){ cin &gt;&gt; y[i]; cin &gt;&gt; result[i]; } for (i = 0; i &lt; n; i++){ // 对于每个预测值y，计算他们的预测准确率 count_i = 0; for (j = 0; j &lt; n; j++){ // 遍历每一个y统计预测准确的数量 if (y[j] &gt;= y[i] &amp;&amp; result[j] == 1 || y[j] &lt; y[i] &amp;&amp; result[j] == 0){ count_i += 1; } } if (count_i &gt; max_count || count_i == max_count &amp;&amp; i &gt; max_index){ max_index = i; max_count = count_i; } } cout &lt;&lt; y[max_index]; return 0; } 结果超时了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78459903117ac2e33a6d5fb1cd4e9979/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc40df6d424cb034f310d16f77a2076/" rel="bookmark">
			skywalkerch的博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		skywalkerch的个人博客
skywalkerch
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1b4f2bcc8f76203ab380b7797abe57/" rel="bookmark">
			深度学习工程师能力模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习机器学习和深度已经有一段时间了，花费了不少精力和时间。那么，离实用阶段还有多远呢？先来看看以下深度学习工程师能力模型。
参考文章：https://www.cnblogs.com/wintersun/p/12900627.html
深度学习工程师能力评估标准主要面向软件相关行业的企业员工及社会人士，能力级别分为初级、中级、高级三个级别。深度学习工程师能力评估要素主要包括专业知识、工程能力、业务理解与实践共3大类、9小类。其中，专业知识包括编程基础、机器学习基础、神经网络基础、深度学习基础；工程能力包括代码规范能力、算法模型实现能力、工程开发与架 构设计能力；业务理解与实践包括行业及业务知识、业务应用能力。
初级中级高级基本要求能够熟练开发、修改和运行深度学习代码，并进行工程化层面上的改造；具有将初等复杂的应用问题初步转化为适当的机器学习问题，并予以解决的能力。能够对自然语言处理、计算机视觉、语音三大领域中的任一类任务，通过调优使得该任务上的模型达到特定的需求指标；熟悉机器学习算法的原理及不同算法间的差异，能够对中等复杂的应用问题进行合理选型、设计相应的指标完成全流程构建并解决问题。应能够深入分析自身业务或同类业务的需求，了解产品特性和研发关键点，理解算法本质，能够合理组合、改造并创新模型来解决更加复杂的应用问题。编程基础应具备程序开发经历和经验。具体要求包括：
a) 能够较为熟练地使用编程语言（以 Python 为例）；
b) 能够使用编程语言处理文本数据、图片数据及语音数据等；
c) 能够按照文档说明使用矩阵运算包和机器学习包（以numpy，sklearn为例） ；
d) 能够使用高级语言开发实现给定需求。应熟练掌握算法开发。具体要求包括：
a) 充分理解编程语言（以 Python 和 C++为例）的特性，并能熟练开发；
b) 熟练进行各种数据处理和复杂的数学运算（以使用 numpy 为例）；
c) 能够针对并行处理数据或计算提供技术解决方案；
d) 能够混合使用脚本语言结合高级语言（以 Python 及 C++语言为例）调用合适的第三方工具，开发完整的机器学习任务。应能够提出业务技术方案，解决特定技术问题。具体要求包括：
a) 对机器学习应用开发过程中遇到的技术难题能够提供技术解决方案；
b) 对矩阵计算和计算程序的开发技术选型有一定的判断和见解；
c) 有机器学习应用开发经验。机器学习基础应具备机器学习模型使用经验。具体要求包括：
a) 熟悉三种以上监督学习算法的原理；
b) 具备机器学习模型的使用及调优经验。应熟练掌握机器学习算法的开发及优化。具体要求包括：
a) 能够准确地判断应用任务是否适合用机器学习技术解决；
b) 能够快速判断并选择所需要的模型；
c) 具备机器学习模型的使用及调优经验。应具备独立进行模型选择、设计、开发的能力。具体要求包括：
a) 能够在面对用户需求和业务需求时，将其准确转换为机器学习语言、算法及模型；
b) 能够对机器学习技术要素进行组合使用，并具备建模能力；
c) 根据业务实际需求，具备技术选型能力；
d) 在标准算法基础上，具备组合多种机器学习技术要素进行模型设计及调优的能力。神经网络基础应对神经网络有一定的理解。具体要求包括：
a) 能够理解基础神经网络模型的原理并完成运行；
b) 能够对关键参数（如数据策略、网络中的核心模块、参数规模、优化算法、损失函数、正则项等）建立起自己的理解，并能对参数调整的结果进行预判；
c) 能够按照一定的指导原则对神经网络进行调优。应能够进行神经网络模型调研与开发。具体要求包括：
a) 具备神经网络模型使用及实战经验；
b) 能够调研及运行深度的神经网络模型，当需要进行参数调整和适配到自身的应用问题时，对关键参数（数据策略、网络中的核心模块、参数规模、优化算法、损失函数、正则项）能提出解决方案；
c) 能够按照论文及技术资料实现新模型，并验证其效果。应能自主开发神经网络算法。具体要求包括：
a) 能够充分地理解各种新型模型和相关技术资料；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d1b4f2bcc8f76203ab380b7797abe57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdcf09ad02f9c181f2e04697c22938a4/" rel="bookmark">
			【高级开发进阶】17.1 扩展篇：redis安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址：http://redis.io/download
安装步骤：
# 安装gcc yum install gcc
# 把下载好的redis-5.0.3.tar.gz放在/usr/local文件夹下，并解压 wget http://download.redis.io/releases/redis-5.0.3.tar.gz tar xzf redis-5.0.3.tar.gz cd redis-5.0.3
# 进入到解压好的redis-5.0.3目录下，进行编译与安装 make
# 修改配置 daemonize yes #后台启动 protected-mode no
#关闭保护模式，开启的话，只有本机才可以访问redis
# 需要注释掉bind #bind 127.0.0.1（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）
# 启动服务 src/redis-server redis.conf
# 验证启动是否成功 ps -ef | grep redis
# 进入redis客户端 src/redis-cli
# 退出客户端 quit
# 退出redis服务： （1）pkill redis-server （2）kill 进程号 （3）src/redis-cli shutdown
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6a06d45b8fbe7e8e9776866e87c0518/" rel="bookmark">
			苹果mac隐藏文件夹怎么显示？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用苹果mac电脑的时候，经常需要查看隐藏的文件夹，那我们应该如何显示mac电脑中被隐藏的文件夹呢?今天小编就来告诉mac用户多个方法来解决这个问题。
macOS Big Sur(macos11新系统)正式版
方法一、
直接按下键盘上的【command+shift+.】，这时候就可以在mac系统中就会自动显示隐藏的文件夹了。
方法二、
1.打开【Spotlight】，在搜索栏中输入【终端】，打开终端功能;
2.在终端中输入【defaults write com.apple.finder AppleShowAllFiles TRUE】，按下回车，之后输入【killall Finder】，按下回车;
3.在输入以上两条指令以后，我们就可以在finder中查看灰色的文件和文件夹了。这些就是之前在mac电脑中被隐藏的文件夹。
以上就是mac系统中显示查看隐藏文件夹的方法了，希望对各位小伙伴们有所帮助。更多Mac教程请关注‘Mac.orsoon.com’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a5a098a5c8251d46232f3d9ccd9d3f/" rel="bookmark">
			CBC模式解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://blog.csdn.net/chengqiuming/article/details/82288851
最近工作中跟银行对接，接口传输的报文需要进行加密，看了下是AES算法，不过文档提到工作模式为CBC，那么这个CBC到底是个啥？这里有篇文章讲得比较明白，所以转载下。
一 什么是CBC模式
CBC模式的全称是Cipher Block Chaining模式（密文分组链接模式），之所以叫这个名字，是因为密文分组像链条一样相互连接在一起。
在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。
CBC模式加解密过程如下：
我们来比较一下ECB模式与CBC模式的区别
ECB模式只进行了加密，而CBC模式则在加密之前进行了一次XOR。
二 初始化向量
当加密第一个明文分组时，由于不存在“前一个密文分组”，因此需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组”，这个比特序列称为初始化向量（Initialization Vector），通常缩写为IV，一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。
三 CBC模式的特点
明文分组在加密之前一定会与“前一个密文分组”进行XOR运算，因此即使明文分组1和明文分组2的值是相等的，密文分组1和2的值也不一定是相等的。这样一来，ECB模式的缺陷在CBC模式中就不存在了。
加密过程：在CBC模式中，无法单独对一个中间的明文分组进行加密。例如，如果要生成密文分组3，则至少需要凑齐明文分组1、2、3才行。
解密过程：假设CBC模式加密的密文分组中有一个分组损坏了。在这种情况下，只要密文分组的长度没有发生变化，则解密时最多只有2个分组受到数据损坏的影响。见下图：
假设CBC模式的密文分组中有一些比特缺失了，那么此时即便只缺失1比特，也会导致密文分组的长度发生变化，此后的分组发生错位，这样一来，缺失比特的位置之后的密文分组也就全部无法解密。见下图：
四 对CBC模式的攻击
假设主动攻击者的目的是通过修改密文来操纵解密后的明文。如果攻击者能够对初始化向量中的任意比特进行反转（将1变成0，将0变成1），则明文分组中相应的比特也会被反转。这是因为在CBC模式的解密过程中，第一个明文分组会和初始化向量进行XOR运算。见下图。
但是想对密文分组也进行同样的攻击就非常困难了。例如，如果攻击者将密文分组1中的某个比特进行反转，则明文分组2中相应比特也会被反转，然而这一比特的变化却对解密后的明文分组1中的多个比特造成了影响，也就是说，只让明文分1中所期望的特定比特发生变化是很困难的。
五 填充提示攻击
填充提示攻击是一种利用分组密码中填充部分来进行攻击的方法。在分组密码中，当明文长度不为分组长度的整数倍时，需要在最后一个分组中填充一些数据使其凑满一个分组长度。在填充提示攻击中，攻击者会反复发送一段密文，每次发送时都对填充数据进行少许改变。由于接收者（服务器）在无法正确解密时会返回一个错误消息，攻击者通过这一错误消息就可以获得一部分与明文相关的信息。这一攻击并不仅限于CBC模式，而是适用所有需要进行分组填充的模式。
2014年对SSL3.0 造成了重大影响POODLE攻击实际上就是一种填充示攻击。
六 对初始化向量（IV）进行攻击
初始化向量（IV）必须使用不可预测的随机数。然而在SSL/TLS的TLS1.0版本协议中，IV并没有使用不可预测的随机数，而是使用上一次CBC模式加密时的最后一个分组。为了防御攻击者对此进行攻击，TLS1.1以上的版本中改为了必须显示传送IV。
七 CBC模式应用
确保互联网安全的通信协议之一SSL/TLS，就是使用CBC模式来确保通信机密性的，如使用CBC模式三重DES的3DES_EDE_CBC以及CBC模式256比特AES的AES_256_CBC等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88813df91eda5ae214cc23fffe4f933b/" rel="bookmark">
			badbody下_BadboyInstaller下载-录制脚本工具Badboy下载2.2.5 官方最新版-西西软件下载...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Badboy是专门录制测试脚本的工具，Badboy录制脚本的方法比较方便易懂，Badboy-2.2.5是最新版可以配合Jmeter使用，快速录制脚本且可以保存为JMeter支持的脚本。badboy测试工具是一个强大WEB测试工具，badboy测试工具通过协议包进行数据交换，响应速度非常快，这款软件非常的简介，安装环境不受任何限制，操作简单不需要输入代码，通过强大HTTPS加密进行模拟录制。推荐需要的网站进行测试的朋友可以下载。
安装步骤：
1、下载Badboy安装包，
2、双击“BadboyInstaller-2.2.5.exe”，点击运行
3、点击“I Agree”
4、选择安装路径
5、选择“是”
6、安装成功，点击“Close”
7、双击图标，启动成功
使用方法：
主要用于Jmeter的压力测试。打开bodboy工具，点击工具栏上的红色按钮，在地址栏中输入需要测试页面的URL地址 ，脚本录制完成后，点击工具栏中黑色按钮停止录制 。
这款软件非常的简介，安装环境不受任何限制，操作简单不需要输入代码，通过强大HTTPS加密进行模拟录制。推荐需要的网站进行测试的朋友可以下载。
图文教程：
JMeter打开BadBoy录制脚本
点击File-Open。
选择刚刚导出的JMeter脚本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f58ed686deee04a3e4714dd59f25a830/" rel="bookmark">
			虚拟机搭建Hadoop集群环境-CentOS篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Linux环境安装虚拟机环境准备虚拟机克隆修改虚拟机IP修改主机名创建普通用户重启虚拟机使用Xshell远程访问 集群搭建安装 JDK安装 Hadoop关闭防火墙其它节点虚拟机克隆配置 SSH 无密钥登录编写文件集群分发脚本修改Hadoop配置为集群配置 集群时间同步 Linux环境安装 具体步骤参考博客。
虚拟机环境准备 虚拟机克隆 在前一步骤中准备好安装了CentOS 7 的虚拟机，克隆一个虚拟机出来，过程如下图：
修改虚拟机IP 克隆完成后，启动bigdata-101虚拟机，使用root用户登录，修改虚拟机的IP地址
编辑/etc/sysconfig/network-scripts/ifcfg-ens33文件，修改成如下内容：
vim /etc/sysconfig/network-scripts/ifcfg-ens33 # 修改内容如下 TYPE=Ethernet BOOTPROTO=static # 设置静态IP NAME=ens33 DEVICE=ens33 ONBOOT=yes IPADDR=192.168.1.101 # 自定义IP地址 PREFIX=24 GATEWAY=192.168.1.2 DNS1=192.168.1.2 设置虚拟机虚拟网络编辑器，编辑-&gt;虚拟网络编辑器-&gt;VMnet8-&gt;更改配置： 将子网IP按下图调整，最后点击 NAT 设置： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210222181122128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTIwNzUzODM=,size_16,color_FFFFFF,t_70) 设置VMnet8 属性，保证默认网关、首先DNS服务器和Linux环境配置一致 修改主机名 查看当前主机名
hostname 执行vim /etc/sysconfig/network,输入以下内容：
HOSTNAME=bigdata101 执行 vim /etc/hosts，加入以下内容：
192.168.1.101 bigdata101 192.168.1.102 bigdata102 192.168.1.103 bigdata103 创建普通用户 创建一个普通用户用于日常操作，用户名为bigdata，为方便学习记忆，密码也可设置为bigdata：
# 添加用户 useradd bigdata # 设置密码 passwd bigdata 给新添加的 hadoop用户配置 root 权限：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f58ed686deee04a3e4714dd59f25a830/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d29c0258a4c0e153dc2d6c9674ac988/" rel="bookmark">
			在vue中使用this.$refs报错undefined找不到子组件的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近遇见个问题 在父组件调用子组件的方法时报错undefined
这种情况一般都是父组件调用子组件方法的时候，dom还没更新成功
可以使用 this.$nextTick
这个方法作用是当数据被修改后使用这个方法会回调获取更新后的dom再渲染出来
比如我要调用子组件passwordmodal的show方法
this.$refs.passwordmodal.show(username); 可以改成上
this.$nextTick(()=&gt;{ this.$refs.passwordmodal.show(username); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a915f4b6c57d7d9055113c30d1ba49db/" rel="bookmark">
			Primer设计PCR引物的方法，在线引物设计网站汇总整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PCR引物设计原则
1、引物长度一般在15-30bp。
引物长度一般为15-30bp，常用的为18-27bp，但不应大于38bp，因为过长会导致其延伸温度大于74℃，不适于Taq DNA聚合酶进行反应；
2、引物GC含量一般为40%-60%。
引物GC含量一般为40%-60%，以45-55%为宜，GC含量过高或过低都不利于引发反应。上下游引物GC含量和Tm值要保持接近；
3、引物所对应的模板序列的Tm值最好在72℃左右。
Tm值在72℃左右可使复性条件最佳，至少要在55-80℃之间。Tm值的计算有多种方法，如按公式Tm＝4(G+C)＋2(A+T)，在Oligo软件中使用的是最邻近法(the nearest neighbor method)；
4、引物3’端的碱基一般不用A。
引物3’端的碱基一般不用A，因为A在错误引发位点的引发效率相对比较高。
5、引物3’端出现3个以上的连续碱基，如GGG或CCC，也会使错误引发机率增加。
6、引物3’端的互补、二聚体或发夹结构也可能导致PCR反应失败。
7、如扩增编码区域，引物3’端不要终止于密码子的第3位，因密码子的第三位易发生简并，会影响扩增特异性与效率；
8、引物5’端可以修饰。
引物5’端序列对PCR影响不太大，因此常用来引进修饰位点或标记物。
9、碱基要随机分布，且引物自身和引物之间不能有连续4个碱基的互补。
文章剩余内容&lt;&lt;&lt;&lt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd0394ea586effa12a82eb576a45be21/" rel="bookmark">
			Xcode项目找不到真机和模拟器，只显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xcode项目找不到真机和模拟器，只显示My Mac。如下图所示
解决方法一：
点击工程打开targets-》Build Settings -》Architectures-》Base SDK 选中ios即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8da3b8744919a41f2fab75b113901203/" rel="bookmark">
			java pair对_Java元组中的Pair类是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaTuples中的Pair类只能包含2个元素。JavaTuples库包含Pair类。
以下是声明-public final class Pair
extends Tuple
implements IValue0
, IValue1
首先让我们看看使用JavaTuples所需的工具。要在JavaTuples中使用Pair类，您需要导入以下包-import org.javatuples.Pair;
它的一些功能包括-类型安全
可序列化
可比
可迭代的
一成不变的
注-下载和运行JavaTuples程序的步骤如果使用Eclipse IDE在JavaTuples中运行Pair Class，则右键单击Project→Properties→Java Build Path→Add External Jars并上传下载的JavaTuples jar文件。
让我们看看如何在Java中创建一个对元组。以下是一个例子-
示例import org.javatuples.Pair;
public class Demo {
public static void main(String[] args) {
Pair p = new Pair("Chinese", "French");
System.out.println("Result = " + p);
}
}
输出结果Result = [Chinese, French]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adcd3a0fc180d69f5fd35a07771bdfc3/" rel="bookmark">
			N沟道与P沟道增强型MOS管电压、原理、导通条件！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		N沟道增强型场效应管的工作原理
工作原理：
1、栅源电压V(GS)的控制作用:
当V(GS)=0V时，因为漏源之间被两个背靠背的PN结隔离，因此，即使在D、S之间加上电压, 在DS间也不可能形成电流。当 0&lt;V(GS)&lt;V(T) (开启电压)时，通过栅极和衬底间的电容作用，将栅极下方P型衬底表层的空穴向下排斥，同时，使两个N区和衬底中的自由电子吸向衬底表层，并与空穴复合而消失，结果在衬底表面形成一薄层负离子的耗尽层。漏源间仍无载流子的通道。管子仍不能导通，处于截止状态。
当V(GS)&gt;V(T)时，衬底中的电子进一步被吸至栅极下方的P型衬底表层，使衬底表层中的自由电子数量大于空穴数量，该薄层转换为N型半导体，称此为反型层。形成N源区到N漏区的N型沟道。把开始形成反型层的V(GS)值称为该管的开启电压V(T)。这时，若在漏源间加电压V(DS)，就能产生漏极电流I(D)，即管子开启。V(GS)值越大，沟道内自由电子越多，沟道电阻越小，在同样V(GS) 电压作用下,I(D)越大。这样，就实现了输入电压V(GS)对输出电流I(D)的控制。
2、漏源电压V(GD)对沟道导电能力的影响:
当V(GD)&gt;V(T)且固定为某值的情况下，若给漏源间加正电压V(DS)则源区的自由电子将沿着沟道漂移到漏区，形成漏极电流I(D)，当I(D)从DS流过沟道时，沿途会产生压降，进而导致沿着沟道长度上栅极与沟道间的电压分布不均匀。源极端电压最大，为V(GS) ，由此感生的沟道最深；离开源极端，越向漏极端靠近，则栅—沟间的电压线性下降，由它们感生的沟道越来越浅；直到漏极端，栅漏间电压最小，其值为： V(GD)=V(GS)-V(DS) , 由此 感生的沟道也最浅。可见，在V(DS)作用下导电沟道的深度是不均匀的，沟道呈锥形分布。若V(DS)进一步增大，直至V(GD)=V(T)，即V(GS)-V(DS)=V(T)或V(DS)=V(GS)-V(T)时，则漏端沟道消失，出现预夹断点。
当V(S)为0或较小时，V(GD)&gt;V(T)，此时VDS 基本均匀降落在沟道中，沟道呈斜线分布。当VDS增加到使VGD=VT时，漏极处沟道将缩减到刚刚开启的情况，称为预夹断。源区的自由电子在VDS电场力的作用下，仍能沿着沟道向漏端漂移，一旦到达预夹断区的边界处，就能被预夹断区内的电场力扫至漏区，形成漏极电流。当VDS增加到使VGD&lt;VT时，预夹断点向源极端延伸成小的夹断区。由于预夹断区呈现高阻，而未夹断沟道部分为低阻，因此， VDS增加的部分基本上降落在该夹断区内，而沟道中的电场力基本不变，漂移电流基本不变，所以，从漏端沟道出现预夹断点开始， ID基本不随VDS增加而变化。
原理：两来种沟道都自是利用多数载流子的定向移动来导电，N沟道的多数载流子是电子，p沟道是空穴，当沟道中有电场时，就会有大量载流子，形成通路，，电场消失，沟道消失。
增强型场效应管是高电平导通（高电平时形成沟道），耗尽型是低电平导通。
场效应管(FET)是场效应晶体管(field-effect transistor)的简称，由于它仅靠半导体中的多数载流子导电，也称为单极性场效应管，是一种常见的利用输入回路的电场效应来控制输出回路电流的一种电压控制性半导体器件，场效应管不但具有双极性晶体管体积小、重量轻、寿命长等优点，而且输入回路的内阻高达107~1012Ω，噪声低，热稳定性好，抗辐射能力强，且比后者耗电省，这些优点使之从20世纪60年代诞生起就广泛地应用于各种电子电路之中。
P沟道增强型场效应管导通条件
P沟道增强型场效应管的导通条件是栅极电位低于漏极电位。
栅极电位比漏极电位低得越多，shu就越趋于导通。一般低于漏极电位15V就可以完全导通。压差太大就会形成栅极击穿。想关闭就要把栅极电位拉回漏极。
结型场效应管只有（耗尽型）；MOS管有（增强型）和（耗尽型）。
增强型：就是UGS=0V时漏源极之间没有导电沟道，只有当UGS&gt;开启电压(N沟道)或UGS&lt;开启电压(P沟道)才可能出现导电沟道。
耗尽型：就是UGS=0V时,漏源极之间存在导电沟道。
什么是N沟道增强型MOS管的开启电压？如何判断MOS管所处的工作状态？
NMOS增强型，ugs(th)一般是正数，最常见的是在2-4V之间，正常导通时的UGS一定大于Ugs(th)，因此也一定是一个正数。电压在范围内一般就导通，电压值不够不导通。
开启电压就是阈值电压，使得源极和漏极之间开始形成导电沟道所需的栅极电压，MOS管是由加在输入端栅极的电压来控制输出端漏极的电流。你可以通过检测电流来判断工作状态。
模电场效应管N沟道增强型MOS管当Ugd增大时为什么会出现预夹断？
前面出现沟道那段想必你已经很熟悉了。这个问题，你最好把模电书拿出来，翻到MOSFET的结构那张图shu。对于N沟道增强型MOSFET而言，只要UGS&gt;UGS(th)，就会出现反型层，也就是在S、D两个高浓度掺杂区之间出现N区，N沟道由此得名。
然后在UDS之间加了电压，这里你注意，D是连接电源正极，根据电子带负电的特性，既然D是正极，在电场力作用下，反型层中的电子就会被吸引到电源正极D，越靠近S，电场能量越小，吸引力越弱，这就导致了反型层在D端比较窄，而在S端比较宽的情况，如果UDS继续增大，电场越强，吸引电子能力越强，反型层靠近D端的自由电子最终被全部吸引到D区，这样在靠近D端的地方就出现了载流子浓度极低的情况，也就是夹断区出现了。
N沟道增强型MOS管与P沟道增强型MOS管主要区别是什么?
1.N沟道MOS管与P沟道MOS管工作原理相似，不同之处仅在于它们形成电流的载流子性质不同，因此导致加在各极上的电压极性相反。应用得最多的是N沟道增强型MOS管
2.N沟道增强型MOS管的工作原理:
N沟道增强型MOS管与N沟道耗尽型MOS管在开启电压上的差别是什么？
1、NMOS增强型，ugs(th)一般是正数，最常见的是在2-4V之间，正常导通时的UGS一定大于Ugs(th)，因此也一定是一个正数。
2、耗尽型的不称为ugs(th)，而是ugs(off)，也就是夹断电压，这个值通常是一个负数。也就是说，只要UGS&gt;UGS(off)就可以导通，这个数值就不好说了，可以是负数，也可以是0，也可以是正数。
转载：http://www.tdldz.com/newsData_824.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b17df0417876375d0e398b2098835d8/" rel="bookmark">
			Java中遍历Map的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谈谈java中遍历Map的几种方法 java中的map遍历有多种方法，从最早的Iterator，到java5支持的foreach,再到java8 Lambda，让我们一起来看下具体的用法以及各自的优缺点
先初始化一个map
public class TestMap { public static Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); } keySet values 如果只需要map的key或者value，用map的keySet或values方法无疑是最方便的
// KeySet 获取key public void testKeySet() { for (Integer key : map.keySet()) { System.out.println(key); } } // values 获取value public void testValues() { for (Integer value : map.values()) { System.out.println(value); } } keySet get(key) 如果需要同时获取key和value，可以先获取key,然后再通过map的get(key)获取value
需要说明的是，该方法不是最优选择，一般不推荐使用
// keySet get(key) 获取key and value public void testKeySetAndGetKey() { for (Integer key : map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b17df0417876375d0e398b2098835d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40bb9b68959f3c0b784090d941a9ed3/" rel="bookmark">
			Malformed UTF-8 data
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NCC打开单据问题 Malformed UTF-8 data
找到ncchome目录下的 miscellaneous.xml 文件，全部设置成false
路径：ncchome\hotwebs\nccloud\WEB-INF\config
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d702af882ed9e429b1aaf1d8090fd794/" rel="bookmark">
			通用adb的默认路径在哪里？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装了Android 的SDK后，会带有默认的adb工具，可用于普通的Android真机调试，那么这个adb的默认路径一般是：
C:\Users\你的电脑用户名\AppData\Local\Android\Sdk\platform-tools
如图显示位置： 使用通用adb进行调试的步骤： 一、全选路径 如图：
二、输入cmd 如图：
三、点击回车键 如图，会弹出命令窗口，此时即可输入adb命令了
附加通用adb工具下载地址： https://download.csdn.net/download/weixin_42433094/15416877
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980726d2e10830dea7819d99d8e600bc/" rel="bookmark">
			Arcgis Engine 10.4详细安装步骤和资源下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：安装前请先安装安装Visual Studio 2013或者安装Visual Studio 2015，因为ArcGIS Engine10.4兼容Visual Studio 2013或者Visual Studio 2015。我这里提供下载链接：
https://download.csdn.net/download/wangzhonglin258/15416783
下面是安装步骤:
1.打开LicenseManager文件夹中Setup.exe开始安装，全部next默认选择，等待安装完成。完成后点击stop按钮停掉服务，不要关闭窗口
2.复制破解文件文件夹中License10.4下的bin文件夹到：C:\Program Files (x86)\ArcGIS\License10.4，全部覆盖文件。点击上一步窗口中的start按钮重新启动服务
3.打开Desktop文件夹中Setup.exe开始安装，全部next默认选择，等待安装完成。安装完成后在弹出的窗口中改为下图中的样子:
4.复制破解文件文件夹中Desktop10.4下的bin文件夹到：C:\Program Files (x86)\ArcGIS\Desktop10.4，全部覆盖文件。
5.打开Engine文件夹中Setup.exe开始安装，全部next默认选择，等待安装完成。
6.复制破解文件文件夹中Engine10.4下的bin文件夹到：C:\Program Files (x86)\ArcGIS\Engine10.4，全部覆盖文件。
7.打开ArcObjectsSDKNet文件夹中Setup.exe开始安装，全部next默认选择，等待安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3ff4fcec20ba8d17f30df992f88b27/" rel="bookmark">
			r语言 面板数据回归_在R语言中进行面板数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在R语言中进行面板数据分析
面板数据(Panel Data)是截面数据与时间序列数据综合起来的一种数据类型。它有时间序列和截面两个维度，当这类数据按两个维度排列时，是排在一个平面上，与只有一个维度的数据排在一条线上有着明显的不同，整个表格像是一个面板,所以把panel data译作“面板数据”。
面板数据模型的选择通常有三种形式：
第一种是混合估计模型(Pooled Regression Model)。如果从时间上看，不同个体之间不存在显著性差异；从截面上看，不同截面之间也不存在显著性差异，那么就可以直接把面板数据混合在一起用普通最小二乘法(OLS)估计参数。
第二种是固定效应模型(Fixed Effects Regression Model)。如果对于不同的截面或不同的时间序列，模型的截距不同，则可以采用在模型中添加虚拟变量的方法估计回归参数。该模型刻画了不同个体的特殊影响，而且这个影响不随样本变化。
第三种是随机效应模型(Random Effects Regression Model)。如果固定效应模型中的截距项包括了截面随机误差项和时间随机误差项的平均效应，并且这两个随机误差项都服从正态分布，则固定效应模型就变成了随机效应模型。该模型刻画了不同个体的特殊影响，但这个影响会随样本变化。
首先载入程序包和数据
library(plm)
将数据转成可处理的面板格式，特别要注意标明个体名和时间名
pgr
先用混合估计模型进行估计
gr_pool
model = "pooling")
再用固定效应模型进行估计
gr_fe
model = "within")
如果要判断固定效应模型是否比混合估计模型更好，可采用F检验
pFtest(gr_fe, gr_pool)
最后我们用随机效应模型进行估计
gr_re
model = "random", random.method = "swar")
summary(gr_re)
要判断随机效应模型是否与固定效应模型有区别，可采用Hausman检验
phtest(gr_re, gr_fe)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd3733e7a1f35d491e67b13e27ce485/" rel="bookmark">
			在vue页面使用JQuery ajax的token过期的主动处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是旧项目的的优化需求 1.需要vue逐步替代jsp页面,jsp使用的是iframe,vue使用的是路由映射,同在tab框里面
2.旧版jsp代码有处理token过期的删除loginToken和跳转到登录页
3.而新版没有做token过期的处理
需求:完成vue页面的token过期处理 vue页面还是使用JQuery的ajax请求,这个是之前项目移植的,不要问为什么不用axios,我也不知道
所以并没有办法使用axios封装好的请求拦截器
有利条件: 1.在getUserInfo接口可以获取到token具体过期的事件,并且已经存到Cookies里面了
2.可以使用JQuery封装ajax的$.ajaxSetup中的beforeSend方法(发送请求之前的回调函数,返回)
使用的ajax全局的请求代码 import CONF from './config'; import util from './util'; // 主动处理vue页面token超时问题 export default function beforeSend() { $.ajaxSetup({ beforeSend(xhr) { let outTime; // 判断当前网页token是否过期 const userInfo = JSON.parse(window.localStorage.getItem('value')); const loginToken = util.getCookie('loginToken'); if (userInfo &amp;&amp; loginToken) { // 本地有用户信息并且有token const loginExpireTime = new Date(userInfo.loginExpireDate).getTime(); //限定的时间戳 const newTime = new Date().getTime(); //现在的时间戳 outTime = newTime &lt; loginExpireTime; if (outTime) { return true; } else { util.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cd3733e7a1f35d491e67b13e27ce485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8c6a2b1bbe2385627711daf7c2e0c9a/" rel="bookmark">
			全面解读数据中台、数据仓库和数据湖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方 "云祁QI"关注, 星标或置顶一起成长
如今，随着诸如互联网以及物联网等技术的不断发展，越来越多的数据被生产出来。据统计，每天大约有超过2.5亿亿字节的各种各样数据产生。这些数据需要被存储起来并且能够被方便的分析和利用。
随着大数据技术的不断更新和迭代，数据管理工具得到了飞速的发展，相关概念如雨后春笋一般应运而生，如从最初决策支持系统(DSS)到商业智能(BI)、数据仓库、数据湖、数据中台等，这些概念特别容易混淆，本文对这些名词术语及内涵进行系统的解析，便于读者对数据平台相关的概念有全面的认识。
1.1 数据库 关系数据库本质上是一个二元关系，说的简单一些，就是一个二维表格，对普通人来说，最简单的理解就是一个Excel表格。这种数据库类型，具有结构化程度高，独立性强，冗余度低等等优点，一下子就促进了计算机的发展。
1.2 操作型数据库和分析型数据库 随着关系数据库理论的提出，诞生了一系列经典的RDBMS，如Oracle，MySQL，SQL Server等。这些RDBMS被成功推向市场，并为社会信息化的发展做出的重大贡献。然而随着数据库使用范围的不断扩大，它被逐步划分为两大基本类型：
操作型数据库 主要用于业务支撑。一个公司往往会使用并维护若干个操作型数据库，这些数据库保存着公司的日常操作数据，比如商品购买、酒店预订、学生成绩录入等；
分析型数据库 主要用于历史数据分析。这类数据库作为公司的单独数据存储，负责利用历史数据对公司各主题域进行统计分析；
那么为什么要'分家'？在一起不合适吗？能不能构建一个同样适用于操作和分析的统一数据库？答案是NO。一个显然的原因是它们会'打架'…如果操作型任务和分析型任务抢资源怎么办呢？再者，它们有太多不同，以致于早已'貌合神离'。接下来看看它们到底有哪些不同吧。
1.3 操作型数据库 VS 分析型数据库 因为主导功能的不同(面向操作/面向分析)，两类数据库就产生了很多细节上的差异。这就好像同样是人，但一个和尚和一个穆斯林肯定有很多行为/观念上的不同。
接下来本文将详细分析两类数据库的不同点：
数据组成差别 - 数据时间范围差别 一般来讲，操作型数据库只会存放90天以内的数据，而分析型数据库存放的则是数年内的数据。这点也是将操作型数据和分析型数据进行物理分离的主要原因。
数据组成差别 - 数据细节层次差别 操作型数据库存放的主要是细节数据，而分析型数据库中虽然既有细节数据，又有汇总数据，但对于用户来说，重点关注的是汇总数据部分。
操作型数据库中自然也有汇总需求，但汇总数据本身不存储而只存储其生成公式。这是因为操作型数据是动态变化的，因此汇总数据会在每次查询时动态生成。
而对于分析型数据库来说，因为汇总数据比较稳定不会发生改变，而且其计算量也比较大(因为时间跨度大)，因此它的汇总数据可考虑事先计算好，以避免重复计算。
数据组成差别 - 数据时间表示差别 操作型数据通常反映的是现实世界的当前状态；而分析型数据库既有当前状态，还有过去各时刻的快照，分析型数据库的使用者可以综合所有快照对各个历史阶段进行统计分析。
技术差别 - 查询数据总量和查询频度差别 操作型查询的数据量少而频率多，分析型查询则反过来，数据量大而频率少。要想同时实现这两种情况的配置优化是不可能的，这也是将两类数据库物理分隔的原因之一。
技术差别 - 数据更新差别 操作型数据库允许用户进行增，删，改，查；分析型数据库用户则只能进行查询。
技术差别 - 数据冗余差别 数据的意义是什么？就是减少数据冗余，避免更新异常。而如5所述，分析型数据库中没有更新操作。因此，减少数据冗余也就没那么重要了。
现在回到开篇是提到的第二个问题'某大公司Hadoop Hive里的关系表不完全满足完整/参照性约束，也不完全满足范式要求，甚至第一范式都不满足。这种情况正常吗？'，答曰是正常的。因为Hive是一种数据仓库，而数据仓库和分析型数据库的关系非常紧密(后文会讲到)。它只提供查询接口，不提供更新接口，这就使得消除冗余的诸多措施不需要被特别严格地执行了。
功能差别 - 数据读者差别 操作型数据库的使用者是业务环境内的各个角色，如用户，商家，进货商等；分析型数据库则只被少量用户用来做综合性决策。
功能差别 - 数据定位差别 这里说的定位，主要是指以何种目的组织起来。操作型数据库是为了支撑具体业务的，因此也被称为'面向应用型数据库'；分析型数据库则是针对各特定业务主题域的分析任务创建的，因此也被称为'面向主题型数据库'。
2.1 概述 数据仓库就是为了解决数据库不能解决的问题而提出的。那么数据库无法解决什么样的问题呢？这个我们得先说说什么是OLAP和OLTP。
2.2 OLTP和OLAP 2.2.1 OLTP OLTP（OnLine Transaction Processing 联机事务处理） 。简单一些，就是数据库的增删查改。举个例子，你到银行，去取一笔钱出来，或者转账，或者只是想查一下你还有多少存款，这些都是面向“事务”类型的操作。这样的操作有几个显著的特点:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8c6a2b1bbe2385627711daf7c2e0c9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de7febf089a7787245c122522fb264af/" rel="bookmark">
			C&#43;&#43;正则表达式（匹配、搜索、替换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++正则表达式（匹配、搜索、替换）
C++ regex C++11
Vs2019 编写
具有特殊意义的元字符
\：\字符能够改变字符原本的含义
：字符指示字符串的头，且要求字符串以字符开头，不占位。^表示一个真正的^符号。
： ： ：字符指示字符串的尾，且要求字符串以字符结尾，不占位。$表示一个真正的$符号。
、()：分组，大正则中包含小正则。可以改变默认的优先级。在模式中可以使用\1来表示第一组已然捕获到的东西。
\b：指示字符串的边界（头/尾/空格左/空格右），字符\b要求边界的左边是字符，\b字符要求边界的右边是字符。
.：表示一个除了\n以外的任意一个字符。.表示一个真正的.符号。
|：字符串1|字符串2表示一个字符串，该字符串是字符串1、字符串2中的一个。|在正则中的优先级比较混乱，所以建议加上足够多的括号来分组。
[]：[字符1字符2字符3…]表示一个字符，该字符是字符1、字符2、字符3……中的某一个。中括号中出现的所有字符都是代表本身意思的字符（没有特殊含义），如[.]只能匹配.符号，而不能匹配任意符号。
[^字符1字符2字符3…]表示一个字符，该字符不是字符1、字符2、字符3……中的任何一个
[a-z]表示一个字符，该字符是a、b、c……z中的某一个
[^a-z]表示一个字符，该字符不是a、b、c……z中的任何一个
\w：表示一个字符，该字符是数字、字母、下划线中的某一个。等价于[(0-9)(a-z)(A-Z)(_)]
\W：表示一个字符，该字符不是数字、字母、下划线中的任何一个。等价于[]
\d表示一个字符，该字符是0、1、2……9中的某一个
\D表示一个字符，该字符不是0、1、2……9中的任何一个
\s表示一个字符，该字符是空白符（空格、制表符、换页符）2、代表出现次数的
量词元字符
：字符要求字符出现0到多次
+：字符+要求字符出现1到多次
?：字符?要求字符出现0次或1次
{n}：字符{n}要求字符出现n次
{n,}：字符{n,}要求字符出现n到多次
{n,m}：字符{n,m}要求字符出现n到m次。
#include &lt;regex&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; // 正则匹配 void RegexMatch(string source_string, regex regex_string) { if (regex_match(source_string, regex_string)) { cout &lt;&lt; " regex " &lt;&lt; source_string &lt;&lt; endl; } else { cout &lt;&lt; " not regex "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de7febf089a7787245c122522fb264af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/187758d95e5ba106ec07f85b2ebef539/" rel="bookmark">
			java线程协作_Java多线程之线程协作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java多线程之线程协作
一、前言
上一节提到，如果有一个线程正在运行synchronized 方法，那么其他线程就无法再运行这个方法了。这就是简单的互斥处理。
假如我们现在想执行更加精确的控制，而不是单纯地等待其他线程运行终止，例如下面这样的控制。
● 如果空间为空则写入数据；如果非空则一直等待到变空为止
● 空间已为空时，“通知”正在等待的线程
此处是根据“空间是否为空”这个条件来执行线程控制的。Java 提供了用于执行线程控制的wait 方法、notify 方法和notifyAll 方法。wait 是让线程等待的方法，而notify 和notifyAll 是唤醒等待中的线程的方法。
二、等待队列——线程休息室
在学习wait、notify 和notifyAll 之前，我们先来学习一下等待队列。所有实例都拥有一个等待队列，它是在实例的wait方法执行后停止操作的线程的队列。打个比方来说，就是为每个实例准备的线程休息室。
在执行wait 方法后，线程便会暂停操作，进入等待队列这个休息室。除非发生下列某一情况，否则线程会一直在等待队列中休眠。当下列任意一种情况发生时，线程便会退出等待队列。
● 有其他线程的notify方法来唤醒线程
● 有其他线程的notifyAll方法来唤醒线程
● 有其他线程的interrupt方法来唤醒线程
● wait方法超时
下面以图配文依次谈谈wait、notify 和notifyAll。而关于interrupt 方法和wait 方法的超时，将会在后面的篇幅中谈谈。
三、wait 方法——将线程放入等待队列
wait(等待)方法会让线程进入等待队列。假设我们执行了下面这条语句。
obj.wait();
那么，当前线程便会暂停运行，并进入实例obj的等待队列中。这叫作“线程正在obj 上wait”。如果实例方法中有如下语句(1)，由于其含义等同于(2)，所以执行了wait() 的线程将会进入this 的等待队列中，这时可以说“线程正在this 上wait”。
wait();　(1)
this.wait(); (2)
若要执行wait方法，线程必须持有锁(这是规则)。但如果线程进入等待队列，便会释放其实例的锁。整个操作过程如下图所示。
关于等待队列
等待队列是一个虚拟的概念。它既不是实例中的字段，也不是用于获取正在实例上等待的线程的列表的方法。
获取锁了的线程A执行wait方法：
线程A进入等待队列，释放锁：
线程B能够获取锁：
四、notify 方法——从等待队列中取出线程
notify(通知)方法会将等待队列中的一个线程取出。假设我们执行了下面这条语句。
obj.notify();
那么obj 的等待队列中的一个线程便会被选中和唤醒，然后就会退出等待队列。
整个操作过程如下所示。
获取锁了的线程B执行notify方法：
线程A退出等待队列，想要进入wait的下一个操作，但刚才执行notify方法的线程B任持有着锁
刚才执行notify的线程B释放了锁
退出等待队列的线程A获取锁，执行wait的下一步操作
同wait 方法一样，若要执行notify 方法，线程也必须持有要调用的实例的锁(这是规则)。
执行notify 后的线程状态：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/187758d95e5ba106ec07f85b2ebef539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beb4f548803e6a872edcaea2c7044d57/" rel="bookmark">
			Bootstrap方法在R语言中的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bootstrap本意是拎着靴带让自己跳起来，在统计学中是一种重采样的方法，通常在样本量小的时候，可以从中不断再次抽样。
1. Bootstrap 简单应用 Bootstrap bias偏差 &amp;variance 方差 library(bootstrap) bslogc&lt;-function(x,B){ n&lt;-length(x) thetastar&lt;-replicate(B,{xstar&lt;-sample(x,n,replace = T) median(xstar)} ) thetastar } x &lt;- diabetes$logCpeptide hist(x, freq = FALSE, main = "Histogram of diabetes data") median(x) bscpep&lt;-bslogc(x,1000) hist(bscpep,freq = FALSE, breaks = 7,main = "Histogram of bootstrap diabetes medians") var(bscpep) bias&lt;-mean(bscpep)-median(x) Bootstrap correlation samplecorr &lt;- function(data, B) { n &lt;- nrow(data) res &lt;- numeric(B) for(i in 1:B) { ind &lt;- sample(n, n, replace = TRUE) bs_data &lt;- data[ind, ] res[i] &lt;- cor(bs_data[ , 1], bs_data[ , 2]) } res } cor(law) cor(law[ , 1], law[ , 2]) bs_law &lt;- samplecorr(law, 10000) hist(bs_law, freq = FALSE, main = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beb4f548803e6a872edcaea2c7044d57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c5e8cb983c409a097e4d81125e6563/" rel="bookmark">
			Java中泛型如何使用，这篇文章教会你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中泛型的使用 一、什么是泛型？二、泛型的好处三、泛型的定义与使用1.定义使用含有泛型的类2.定义和使用含有泛型的方法3.定义和使用含有泛型的接口 四、泛型通配符1.泛型通配符的使用2.泛型通配符的高级使用----受限泛型 一、什么是泛型？ 1.泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型。
2.泛型也可以看作是一个变量，用来接收数据类型（注意接收的是数据类型）。
E e:Element 元素 T t:Type 类型 例如：ArrayList集合在定义的时候，不知道集合中都会存储什么类型的数据，所以类型使用泛型。
public class ArrayList&lt;E&gt; { public boolean add(E e) {} public E get(int index){} } 创建集合对象的时候，就会确定泛型的数据类型
二、泛型的好处 创建集合对象,使用泛型
好处:
避免了类型转换的麻烦,存储的是什么类型,取出的就是什么类型；把运行期异常(代码运行之后会抛出的异常),提升到了编译期(写代码的时候会报错)； 弊端:
泛型是什么类型,只能存储什么类型的数据； private static void show01() { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("abc"); list.add(1);//报错：add(java.lang.String)in ArrayList cannot be applied to (int) //使用迭代器遍历list集合 Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()){ String s = it.next(); System.out.println(s+"-&gt;"+s.length()); } } 创建集合对象,不使用泛型
好处: 集合不使用泛型,默认的类型就是Object类型,可以存储任意类型的数据；
弊端: 不安全,会引发异常；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c5e8cb983c409a097e4d81125e6563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e7f428a26a9e44baee13ba2aaa8f29/" rel="bookmark">
			Windows下DM服务报错“读取描述失败，错误代码：2” 处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日在连接自己Windows下DM数据库时，发现报错“网络通信异常”，因为现象发生在本机，所以直接去查看DM服务，发现服务是“停止运行”的状态，尝试启动服务时发现无法启动，看到描述为“读取描述失败，错误代码：2”，尝试进行重新注册服务也是直接失败，于是使用下面的方法进行解决，并且重新成功启动了数据库。
操作过程如下：
1、首先在打开cmd窗口，以管理员身份运行，可以直接点击win+x键，直接使用管理员身份运行，输入以下命令：sc delete 服务名，如下图所示：
2、删除无效的服务之后开始重新注册数据库服务，打开数据库配置助手，选择“注册数据库服务”
3、选中自己原库的dm.ini文件，点击“打开”
4、这一步点击“完成”
5、等待数据库服务注册完成，并且启动，此时可以看到下图中，在任务管理器中查看到的服务是“正在运行”状态
6、重新打开管理工具，连接数据库，发现可以正常连接，至此整个处理流程结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9feee46c9f88dd96a7d85370a48a169/" rel="bookmark">
			java if语句例子_实例学习if语句用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们前面学习了java中的for循环和do
while语法及原理的相关内容，同样是java三大控制语句之一的选择语句，在实际的项目开发中使用频率也非常高，今天我们来学习选择语句中if语句用法和相关内容，都是属于java中的基本知识，java零基础的朋友们可以一起来学习下面的内容。
If语句属于java中的选择语句，选择语句又称为分支语句，if语句用法是比较简单的，它通过对给定的条件进行判断，从而决定执行两个或多个分支中的哪一支。因此，在编写选择语句之前，应该首先明确判断条件是什么，并确定当判断结果为“真”或“假”时应分别执行什么样的操作/算法。
If语句的一般形式如下：
if(表达式)语句1
[else语句2]
if语句中的“表达式”可以是关系表达式、逻辑表达式，甚至是数值表达式。其中最直观、最容易理解的是关系表达式，关系表达式就是两个数值进行比较的式子。if语句的编写方式归纳为以下四种，如下图所示：
If语句使用例子一：业务背景：根据用户输入不同的数字来判断用户不同性别，当输入1时性别为男，当输入0时性别为女，输入其它则不合法。
java.util.Scanner scan = new java.util.Scanner(System.in);
System.out.print("请输入数字：");
int i = scan.nextInt();
if(i == 1){
System.out.println("性别：男");
}else if(i == 0){
System.out.println("性别：女");
}else{
System.out.println("对不起，您输入不合法！");
}
If语句使用例子二：
对这个代码的解释：定义一个变量a初始值为3，利用if...else语句来判断，如果a除以2的余数为0则运行：
System.out.println(a+" 是偶数");
System.out.println(a+" 不是奇数");
反之运行：
System.out.println(a+" 是奇数");
System.out.println(a+" 不是偶数");
If语句使用例子三：业务背景：键盘接收一个学生的成绩，范围在[0-100]，根据成绩判断等级，[90-100]等级为“优秀”，[80-90)等级为“良好”，[70-80)等级为“中等”，[60-70)等级为“及格”，[0-60)等级为“大笨蛋”，输入其它数字表示成绩不合法。
java.util.Scanner scan = new java.util.Scanner(System.in);
System.out.print("输入考试成绩：");
int score = scan.nextInt();
String grade = "大笨蛋";
if(score &lt; 0 || score &gt; 100){
grade = "对不起，您输入的成绩不合法！";
}else if(score &gt;= 90){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9feee46c9f88dd96a7d85370a48a169/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a0496d21899f74993df01fb6d7abab5/" rel="bookmark">
			java 拼接 html_拼接字符转的转义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在程序中经常会写到字符串的拼接，最常见的一中方式就是把拼接的字符串返回到页面上，然后让浏览器渲染成html代码。
现在es6已经用的不少了，但是因为一些原因，有的项目只能用最原始的加号“+”拼接，所以就会出现一种情况；请看下面的代码：
1 var stringify_json =JSON.stringify(rowObject);2 var str2 = 1;
1 str +="";2 functiondel_id(a,b){3 console.log(a);4 console.log(b);5 }
上面是代码的生命，这个时候是没有问题的，你把str直接返回到页面，页面是可以正常的解析的，点击这个按钮也是能打印的；下面是打印的结果
打印的结构是没有任何问题的。但是当我们把str2换成字符串的时候，就发现页面开始报错了。
也就是上面的代码改成str2 = "string"的时候，页面开始报错了；下面是错误的信息，和页面的渲染结果；
发现这个并不是按照字符串拼接上去的， 所以js认为这个是方法，所以就出现上上面的错误了。
所以我们在拼接的时候，就需要给这个string两边加上引号，所以就有了下面的代码：
1 str +="";
然后再页面上的渲染就是这样的了。
也就是说，html解析器在解析到string前面的引号的时候，就认为这一段就完成，所以页面也就直接报错了，也就是说，咱们需要把拼接上的单引号，变成双引号；
下面的截图是我的编辑器的，我直接把上面代码中的单引号改成双引号的。
编辑器直接把str2不当成一个变量了。这个肯定是不行的了，所以这个时候就需要用上咱们的转移字符 "" 了；
1 str +="";
这个是加上转移字符之后的，也就是说，后面的引号，不当成是咱们拼接的东西，而是就是简单的表示自己是个引号。这样的话，我们就可以正常的打印了。
----------------华丽的分割线-----------------------------
现在已经有很多项目是用es6细的了，es6有更优美的拼接字符串的方式；请参见下面的链接
这篇文章写的不错。大家可以自行查阅；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95fa7ac44fc52fc8cfad54a14f579eb3/" rel="bookmark">
			C#如何生成dll文件，并在项目中引用dll文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步生成dll文件
首先我们要先创建一个工程：
我们在工程中先添加一个控制台项目：
其次我们在创建一个类库项目：
在类库项目中的类，我们写上函数，类和函数都必须用public来修饰。其中namespace后面的名称
就是后面调用dll时，在程序中需要using的名称。
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace MyTest { public class Class1 { public void show() { Console.WriteLine("Hello Wrold!"); } } } 写完后我们右击该项目属性，看输出类型是否为类库。
选中项目，点击栏目中的生成菜单，点击红框中的生成。
生成的dll文件在这个目录下。
第二步：
引用该dll文件。
选中第一步中创建的控制台工程的---&gt;引用----&gt;添加引用，选择浏览，到刚刚的目录下去找dll文件。：
添加成功后，我们可以在引用目录下看到我们引用的dll：
接下来就是引用dll文件，打开控制台程序类，先添加using，如图所示。
然后在main函数中就可以直接调用dll文件中的类了。
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using MyTest; namespace ConsoleApplication1 { class Program { static void Main(string[] args) { Class1 cl = new Class1(); cl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95fa7ac44fc52fc8cfad54a14f579eb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdeb093d4aa2a5e28dc41069890c5126/" rel="bookmark">
			java 防重复提交_Java中如何避免重复提交请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方蓝字关注我们
一、背景
我们在使用系统过程中，经常碰到这种情况：网页响应很慢，提交请求后发现没反应，然后就会反复点击提交按钮。查看后台日志后发现一个同样的请求提交了多次，后果就是轻则导致产生多条重复数据，重则直接导致程序异常。那么，有没有什么办法可以避免这种问题呢？
二、产生原因
导致重复请求的原因很多，大体为以下几种：多次点击提交按钮
反复刷新页面
点击浏览器后退按钮，导致重复提交表单
浏览器重复的HTTP请求
Nginx重发等三、解决方案
1、前端控制
前端提交请求后，在等待结果返回前将提交按钮禁用，可以阻止人为的反复点击操作。但是这种方式只能控制页面，如果通过工具多次提交请求，那就只能通过后端来实现限制了。
2、借助本地锁实现
这种方式主要通过自定义注解、springaop、guavacache来生成本地锁，达到防止重复提交的效果。
接下来介绍下具体实现：
引入guava依赖
Guava是谷歌开源的Java库，这个库提供用于集合，缓存，支持原语，并发性，常见注解，字符串处理，I/O和验证的实用方法，对JDK工具做了很好扩展。
自定义LocalLock注解
编写自定义注解，用于需要控制重复提交的方法上。
自定义注解切面
编写自定义注解的aop拦截器具体实现，读取有LocalLock注解的方法，解析注解中定义的key值在本地缓存中是否存在，若存在则提示重复请求，若为第一次请求则将key存入本地缓存中。
控制层实现
在需要限制重复提交的方法上加入@LocalLock注解，其中key值为自定义的存入缓存中的key。
效果展示
启动应用，访问上面的/query请求查看效果。
正常访问一下，结果如下：
接下来，在正常访问过程中，重复点击提交，可以看到已达到限制效果。
四、总结
对于重复提交请求的问题，我们单纯的只从前端或后端控制，带来的用户体验都不是最好的。只有两者结合起来，才能在确保功能正常的前提下，保证用户体验效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa79e6a8d547991a4454ee2133f503c3/" rel="bookmark">
			java动态语言_Java动态语言类型支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
首先，Java是一门静态语言。但是JVM希望扩展成可以支持动态语言。JDK从1.7开始，引入了新的字节码指令：invokedynamic从而扩展了对于动态语言的支持。
MethodHandle
这是动态语言支持的方法句柄。
Java7在JSR 292中增加了对动态类型语言的支持，使得java也可以像C语言那样将方法作为参数传递。
在java.lang.invoke包中MethodHandle作用类似于反射中的Method类，但它比Method类要更加灵活和轻量级。
Reflection是java api层面的反射调用，而MethodHandle则是jvm层面支持调用。因此Reflection是重量级，MethodHandle则是轻量级的。
具体方法调用实例：
1.创建MethodType对象，指定方法的签名(即方法参数以及方法返回值的类型)。
2.在MethodHandles.Lookup中查找类型为MethodType的MethodHandle
3.传入方法参数并调用MethodHandle.invoke或者MethodHandle.invokeExact方法。
具体代码实现：
public class Demo10 {
public String toString(String test) {
return "test" + test;
}
public static void main(String args[]) throws Throwable {
Demo10 demo10 = new Demo10();
MethodHandle mh = getString();
//调用具体方法
String str = (String) mh.invokeExact(demo10, "dsasdasd");
System.out.println(str);
MethodHandle methodHandle = mh.bindTo(demo10);
String value = (String) methodHandle.invokeWithArguments("sdsadsad");
System.out.println(value);
}
public static MethodHandle getString() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa79e6a8d547991a4454ee2133f503c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42976eb46643f53017cc50a6447a1e1/" rel="bookmark">
			vue过渡&amp;动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://cn.vuejs.org/v2/guide/transitions.html
一、概述 Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具：
在 CSS 过渡和动画中自动应用 class可以配合使用第三方 CSS 动画库，如 Animate.css在过渡钩子函数中使用 JavaScript 直接操作 DOM可以配合使用第三方 JavaScript 动画库，如 Velocity.js 二、过渡的类名 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 &lt;style type="text/css"&gt; .content{ width: 200px; height: 200px; background: blue; } .fade-enter-active, .fade-leave-active { transition: opacity 1.5s; } .fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ { opacity: 0; } .slide-enter-active, .slide-leave-active { transition: all 1.5s; } .slide-enter, .slide-leave-to /* .fade-leave-active below version 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a42976eb46643f53017cc50a6447a1e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4e134ff3223dcc5bb2529b5b739e6a/" rel="bookmark">
			温度检测模块 DS18B20 数据解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. DSB18B20结构框图解析
2. 64-bit ROM（发送时低位优先）
3. 16-bit 温度寄存器
4. 8-bit 配置寄存器
5. 8-bit CRC校验
6.DSB18b20命令格式
7.DSB18b20通信实例实测
1. DSB18B20结构框图解析 2. 64-bit ROM（发送时低位优先） 表1 ROM结构 8bit 48bit 8bit CRC编码 序列号 家族码（唯一） b63 ~ b56 b55 ~ b8 b7~b0 注释：家族码也是产品系列编码，DS18B20 为 0x28，DS1822 为 0x22。
3. 16-bit 温度寄存器 16bit温度寄存器由符号位和数据位组成，根据配置寄存器的设置，决定数据寄存器的数据位。
例如：DS18B20默认配置寄存器为12位，则数据位为b0~b10， b11为符号位。
0000 0 000 1010 0010 （0x00A2）=&gt; 0xA2 * 0.0625 = 10.125℃。
1111 1 111 0101 1110 （0xFF5E）=&gt; 对数据位取反码后加1，得到数据 0xA2，则温度为 -10.125℃。
0000 0 000 0000 1000 （0x0008）=&gt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b4e134ff3223dcc5bb2529b5b739e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd23cf50d905b9fafd035b458180c5f7/" rel="bookmark">
			java访问路径_各种项目访问路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、普通动态web项目JSP访问问题
项目结构：
其中index.jsp的访问路径是：
http://localhost:8080/struts2/index.jsp
即：
http://localhost:8080/项目名/jsp文件名.jsp
demo1.jsp的访问路径是：
http://localhost:8080/struts2/demo1/demo1.jsp
即：
http://localhost:8080/项目名/WebContent下面的所有文件夹名/demo1.jsp
上面两种访问方法都可以默认去掉项目名来访问，需要在我们发布项目的tomcat配置文件server.xml里面进行如下修改：
进行上面的修改之后上面两种访问路径既可以改为：
http://localhost:8080/index.jsp
http://localhost:8080/demo1/demo1.jsp
2、maven项目下面的JSP访问：
项目结构：
上面的webapp文件夹下面的所有jsp文件访问方法和第一种动态web项目WebContent下面的的jsp访问完全一样
3、SpringBoot项目JSP访问路径：
项目结构：
SpringBoot项目其实就是特殊的maven项目，她的jsp访问路径默认去掉项目名，骑她和maven完全一样
4、WEB-INF文件夹下面的jsp
WEB-INF是Java的WEB应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。
jsp文件放在WEB-INF目录下就必须要通过请求才能访问，WEB-INF中的jsp就是无法通过地址栏访问的，所以安全。
5、SpringBoot项目Controller访问：
访问路径：
http://localhost:9091/control/hello
即：
http://localhost:9091/control映射路径/hello方法映射路径
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d193f3550bd901eb42be013d74299f43/" rel="bookmark">
			Javadoc 使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多程序对Javadoc都不重视，认识不到Javadoc的作用，很多人都是这样认为的：“我只要写好功能就够了，写Javadoc太浪费时间，也没啥作用，还不如用写Javadoc的时间再多些个功能呢！”，我们知道注释是为了解释代码的作用的，是为了将来给自己或者别人快速了解代码的，在方法内一般用行注释//的比较多，是针对一小块代码做出解释的，而Javadoc的作用是针对整个方法或者整个类做一个简要的概述的，使得别人不通过看具体方法代码就能知道某个方法或者某个类的作用和功能。写了Javadoc的在别人使用到类时，将鼠标悬停到类上或者方法上，javadoc会以提示信息显示出来，这样开发者在跳进源代码中就能知道类或者方法的作用。说到这里可能还是有很多人不能认同这种观点，还是认识不到Javadoc的作用。我们看一下Spring框架，随便打开一个文件可以看到一般注释内容都要比代码量多，有的时候注释量占整个文件内容的2/3。有人还是认为Spring是大框架，每个Java项目都在用他们写的好事应该的，我们公司自己的项目就我们公司几个人看，没必要花时间去写多余的Javadoc，那你是不是该这么认为了Spring大厂中的顶尖大牛都这么做，我们小菜鸟是不是对自己要求更严格一些，向大牛去学习呢？！假如在公司A程序员写了Javadoc，B程序员只写功能不写Javadoc不写注释，那么一般会认为A程序员会比B程序员做的好。认识不到Javadoc的作用就像认识不到设计模式的作用一样，很多人都认识不到设计模式的作用，认为将简单问题复杂化，你看一下每个大框架都会用到多种设计模式，如果只知道写增删改查，再工作几年仍然不会有提高。
一：简介 Javadoc用于描述类或者方法的作用。Javadoc可以写在类上面和方法上面。
https://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html
二：写在类上面的Javadoc 写在类上的文档标注一般分为三段：
第一段：概要描述，通常用一句或者一段话简要描述该类的作用，以英文句号作为结束第二段：详细描述，通常用一段或者多段话来详细描述该类的作用，一般每段话都以英文句号作为结束第三段：文档标注，用于标注作者、创建时间、参阅类等信息 第一段：概要描述 单行示例：
package org.springframework.util; /** * Miscellaneous {@link String} utility methods. * */ public abstract class StringUtils { 123456 多行示例：
package java.lang; /** * Class {@code Object} is the root of the class hierarchy. * Every class has {@code Object} as a superclass. All objects, * including arrays, implement the methods of this class. */ public class Object {} 1234567 在注释中出现以@开头东东被称之为Javadoc文档标记，是JDK定义好的，如@author、@version、@since、@see、@link、@code、@param、@return、@exception、@throws等。
1. @link：{@link 包名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d193f3550bd901eb42be013d74299f43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918f368a2022ef583eacbe5db2723306/" rel="bookmark">
			java store()_Java Properties store()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Properties store()方法
java.util.Properties.store(OutputStream out,String comments) 将属性写入OutputStream对象。
1 语法
public void store(OutputStream out,String comments)
2 参数
out：输出流。
comments ：属性列表的描述。
3 返回值
返回此属性列表中指定键的前一个值；如果没有，则返回null。
4 示例
package com.yiidian;
/**
* 一点教程网： http://www.yiidian.com
*/
/**
* java.util.Properties.store(OutputStream out,String comments)方法的例子
*/
import java.io.IOException;
import java.util.*;
public class Demo {
public static void main(String[] args) {
Properties prop = new Properties();
// add some properties
prop.setProperty("Height", "200");
prop.put("Width", "1500");
// print the list
System.out.println("" + prop);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/918f368a2022ef583eacbe5db2723306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7f2d28fa0da62804cc00bcdbd347f1d/" rel="bookmark">
			[Java基础]网络编程概念汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 网络编程网络编程概述网络编程三要素IP地址端口协议UDP协议TCP协议 网络编程 网络编程概述 计算机网络：
是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。
网络编程：
在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换。
网络编程三要素 IP地址
要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识。
端口
网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识。
协议
通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议。
IP地址 IP地址是网络中设备的唯一标识。
IP地址分为两大类：
IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每 个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多。IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题。 DOS常用命令：
ipconfig：查看本机IP地址。ping IP地址：检查网络是否连通。 特殊IP地址：
127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用。 端口 设备上应用程序的唯一标识。
端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败(启动失败，修改端口号)。
协议 计算机网络中，连接和通信的规则被称为网络通信协议。 UDP协议 用户数据报协议(User Datagram Protocol)UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输。例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议。 TCP协议 传输控制协议 (Transmission Control Protocol)
TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。
三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。
第一次握手，客户端向服务器端发出连接请求，等待服务器确认。
第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。
第三次握手，客户端再次向服务器端发送确认信息，确认连接。
完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/381/">«</a>
	<span class="pagination__item pagination__item--current">382/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/383/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>