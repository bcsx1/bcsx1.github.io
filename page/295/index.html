<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe280f0e820529a484de5875cfe3312c/" rel="bookmark">
			明码 C&#43;&#43; 蓝桥杯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 16 64 16 64 34 68 127 126 66 -124 67 4 66 4 66 -124 126 100 66 36 66 4 66 4 66 4 126 4 66 40 0 16 4 0 4 0 4 0 4 32 -1 -16 4 32 4 32 4 32 4 32 4 32 8 32 8 32 16 34 16 34 32 30 -64 0 0 -128 64 -128 48 -128 17 8 1 -4 2 8 8 80 16 64 32 64 -32 64 32 -96 32 -96 33 16 34 8 36 14 40 4 4 0 3 0 1 0 0 4 -1 -2 4 0 4 16 7 -8 4 16 4 16 4 16 8 16 8 16 16 16 32 -96 64 64 16 64 20 72 62 -4 73 32 5 16 1 0 63 -8 1 0 -1 -2 0 64 0 80 63 -8 8 64 4 64 1 64 0 -128 0 16 63 -8 1 0 1 0 1 0 1 4 -1 -2 1 0 1 0 1 0 1 0 1 0 1 0 1 0 5 0 2 0 2 0 2 0 7 -16 8 32 24 64 37 -128 2 -128 12 -128 113 -4 2 8 12 16 18 32 33 -64 1 0 14 0 112 0 1 0 1 0 1 0 9 32 9 16 17 12 17 4 33 16 65 16 1 32 1 64 0 -128 1 0 2 0 12 0 112 0 0 0 0 0 7 -16 24 24 48 12 56 12 0 56 0 -32 0 -64 0 -128 0 0 0 0 1 -128 3 -64 1 -128 0 0 运行限制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe280f0e820529a484de5875cfe3312c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6727c470c423296e4760d470fb5eb70c/" rel="bookmark">
			python&#43;selenium之弹窗处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景：补发之前的欠账，17年的时候写在本地，一直未上传
这个是python+selenium之弹窗处理
#coding=utf-8 from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains import time driver = webdriver.Firefox() driver.get('http://www.baidu.com') ele = driver.find_element_by_link_text(u"设置")	ActionChains(driver).move_to_element(ele).perform() time.sleep(2) ele1 = driver.find_element_by_link_text(u"搜索设置")	ele1.click() ele2 = driver.find_element_by_class_name('prefpanelgo') time.sleep(2) ele2.click() time.sleep(2) #接受告警框 driver.switch_to_alert().accept() time.sleep(4) #等等4秒 driver.quit() #关闭浏览器 ''' driver.switch_to_alert().text() 返回告警框的文字 driver.switch_to_alert().accept()接受告警框 driver.switch_to_alert().dismiss()解散现在告警框 driver.switch_to_alert().send_keys(keysToSend) 发送文本至告警框 ''' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92693f78d8dc83f6356a08c52a8aadea/" rel="bookmark">
			python&#43;selenium之截图处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景：补发之前的欠账，17年的时候写在本地，一直未上传
这个是python+selenium之截图处理
#coding=utf-8 from selenium import webdriver import time driver = webdriver.Firefox() driver.get('http://www.baidu.com') driver.find_element_by_id("kw").send_keys("selenium") driver.find_element_by_id("su").click() time.sleep(4) #等等4秒 driver.get_screenshot_as_file("C:\\Users\\Administrator\\Desktop\\baidu_img.jpg") driver.quit() #关闭浏览器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/759de71f2d425d3982a8db83220502ae/" rel="bookmark">
			Java多线程（2万字深入理解多线程，有实例代码辅助理解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程 线程概述线程的创建1. 继承Thread类2. 实现Runnable接口3. 实现Callable接口4. 使用线程池 线程的调度线程的生命周期线程同步1. 方法一：同步代码块2. 方法二：同步方法3. 方法三：Lock(锁)：4. 对比三种方法5. 典型例题6. 线程死锁问题 线程通信两个方法sleep()方法和wait()典型例题 读完本文大概需要30分钟左右，本文有大量的实例代码和典型例题帮助大家理解java多线程。虽然多线程比较难以理解，仅靠一篇文章恐怕搞不定。但读完本文最起码能让你搞懂java多线程的70%以上，至于熟练运用，还是得大量的练习为基础。
码字不易，望三连~~~
线程概述 问题引入：
单线程的程序往往功能十分有限，例如：开发一个服务器程序，这个服务器程序需要向不同的客户端提供服务，不同的客户之间应该互不干扰，否则这个程序将不会被接收。 单线程程序只有一个顺序执行流，多线程则可以包括多个顺序执行流，多个线程之间互不干扰。
程序（program）：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。
进程（process）：是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期
如：运行中的QQ，运行中的MP3播放器程序是静态的，进程是动态的进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程（thread）：进程可进一步细化为线程，是一个程序内部的一条执行路径。（4种方式创建多线程）
若一个进程同一时间并行执行多个线程，就是支持多线程的线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小一个进程中的多个线程共享相同的内存单元/内存地址空间–&gt;它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患 单核CPU：是一种假的多线程，因为频率很高，所以我们感觉不到。
一个java程序，其实至少有三个进程：
① main()方法主进程。
② gc()垃圾回收线程。
③ 异常处理线程，异常会影响主线程。
并发与并行：
并发：多个CPU同时执行多个任务。比如：多个人同时做不同的事并行：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事 多线程程序的优点： 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。提高计算机系统CPU的利用率改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 何时需要多线程： 程序需要同时执行两个或多个任务。程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。需要一些后台运行的程序时 线程的创建 1. 继承Thread类 （1）多线程的创建：方法一：继承Thread类
步骤：
创建一个继承于Thread类的子类重写Thread类的run方法–&gt;将此线程执行的操作声明在run()中。创建子类对象通过子类对象调用start()方法： 注意：
①启动线程。
②start方法会自动调用当前线程的run方法。不能直接调用run方法。
③不能让已经start的线程再去执行，会报异常。需要再去创建一个线程对象，通过这个对象再start。
class Test extends Thread{ @Override public void run() { for(int i=0;i&lt;100;i++) { if(i%2==0) { System.out.println("偶数："+i); } } } } public class Demo1 { public static void main(String[] args) { Test test = new Test(); test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/759de71f2d425d3982a8db83220502ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/881b8d018ccb9b4e2e40afc4cfc19bb5/" rel="bookmark">
			cadence数模混合仿真反标sdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数模混合IC设计时经常要调用一些Verilog模块（最简单的例如SPI接口），在前仿时一般直接用rtl代码来仿真，但是后仿时要关注因寄生带来的延迟，避免这些额外的延迟导致时序错误，因此不能简单地采用RTL来仿真。
一般有两种办法：1是采用由RTL综合得到的门级电路来仿真，这种方法比较简单，但是缺点是规模较大，而且只包括门延迟不包括因版图导致的线延迟；如果想要仿真更精细，就要对该这部分门电路提取寄生参数；
另一种方式是利用sdf文件（standard delay format）来进行仿真。后端工具在布局布线时会自动提取出每个模块之间的延迟，并生成一个sdf文件。这样我们可以在行为级（而不是晶体管级）直接仿真得到其时序特性。其主要步骤介绍如下：
1：编译sdf文件 后端工具生成的sdf文件是不能被cadence识别的，需要先用ncsdfc命令编译，编译后自动生成.X后缀的文件。
每个sdf文件都会包括两组延迟模型，一组maximum一组minimum。
2：在config中调用Verilog文件 假定前仿时已经建好了config，其中的数字模块为spi_test。在前方时该模块调用的view为functional，后仿时设置其view为external HDL。
在ADE界面中，simulation –&gt;option --&gt;AMS simulator中点击include option，将综合后的门级Verilog代码以及标准单元库的Verilog代码include进来。
注：此时如果不添加sdf文件，仿真效果和前仿真完全相同；
3、编写sdf command file 之前已经编译生成了.X后缀的sdf文件，sdf command file的作用就是指定延迟文件的位置，log文件的位置、反标的对象以及采用maximum/minimum。
一个例子如下图：
这里的scope需要额外说明！假如你的testbench电路命名为sim_post_rtl，电路里代码的位置为I1.I2.I_dig，则需要写成 SCOPE = sim_post_rtl.I1.I2.I_dig 的形式。如果写错的话，仿真日志里会提示”没有找到被反标的对象“。
4、调用sdf command file 在ADE界面中，simulation –&gt;option --&gt;AMS simulator中点击SDF，在sdf command file中选择刚刚写好的sdf command file即可，不需要做其他配置。
5、一些bug 按照如上步骤进行仿真后，在simvision中即可看到数字单元的延迟。有时仿真器会产生莫名其妙的x或z状态，为了避免这种错误，数字模块的输入引脚尽可能采用Verilog直接配置。
例如：1信号不要用一个AVDD net提供，而是做一个testbench.v，在其中定义assign vx=1.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/949f69001fc73939801f0c9a69965408/" rel="bookmark">
			【时间序列】使用 Auto-TS 自动化时间序列预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Auto-TS 是 AutoML 的一部分，它将自动化机器学习管道的一些组件。这自动化库有助于非专家训练基本的机器学习模型，而无需在该领域有太多知识。在本文中，小编和你一起学习如何使用 Auto-TS 库自动执行时间序列预测模型。
什么是自动 TS？ 它是一个开源 Python 库，主要用于自动化时间序列预测。它将使用一行代码自动训练多个时间序列模型，这将帮助我们为我们的问题陈述选择最好的模型。
在 python 开源库 Auto-TS 中，auto-ts.Auto_TimeSeries() 使用训练数据调用的主要函数。然后我们可以选择想要的模型类型，例如 stats、ml 或FB prophet-based models （基于 FB 先知的模型）。我们还可以调整参数，这些参数将根据我们希望它基于的评分参数自动选择最佳模型。它将返回最佳模型和一个字典，其中包含提到的预测周期数的预测（默认值 = 2）。
Auto_timeseries 是用于时间序列数据的复杂模型构建实用程序。由于它自动化了复杂工作中涉及的许多任务，因此它假定了许多智能默认值。5.但是我们可以改变它们。Auto_Timeseries 将基于 Statsmodels ARIMA、Seasonal ARIMA 和 Scikit-Learn ML 快速构建预测模型。它将自动选择给出指定最佳分数的最佳模型。
Auto_TimeSeries 能够帮助我们使用 ARIMA、SARIMAX、VAR、可分解（趋势+季节性+残差）模型和集成机器学习模型等技术构建和选择多个时间序列模型。
Auto-TS 库的特点 它使用遗传规划优化找到最佳时间序列预测模型。
它训练普通模型、统计模型、机器学习模型和深度学习模型，具有所有可能的超参数配置和交叉验证。
它通过学习最佳 NaN 插补和异常值去除来执行数据转换以处理杂乱的数据。
选择用于模型选择的指标组合。
安装 pip install auto-ts # 或 pip install git+git://github.com/AutoViML/Auto_TS 依赖包，如下依赖包需要提前安装 dask scikit-learn FB Prophet statsmodels pmdarima XGBoost 导入库 from auto_ts import auto_timeseries 巨坑警告 根据上述安装步骤安装成功后，很大概率会出现这样的错误：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/949f69001fc73939801f0c9a69965408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be6d2732a1998e9691665bfab07b961/" rel="bookmark">
			全网最全的 MySQL 索引优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击关注公众号，利用碎片时间学习
一、分页查询优化 很多时候我们业务系统实现分页功能可能会用如下sql实现：
select * from employees limit 10000,10; 表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。这是典型的深度分页问题。
分页场景优化技巧 1、根据自增且连续的主键排序的分页查询 首先来看一个根据自增且连续主键排序的分页查询的例子：
select * from employees limit 90000,5; 该 SQL 表示查询从第 90001开始的五行数据，没添加单独 order by，表示通过主键排序。我们再看表 employees ，因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据，如下：
select * from employees where id &gt; 90000 limit 5; 查询的结果是一致的。我们再对比一下执行计划：
EXPLAIN select * from employees limit 90000,5; EXPLAIN select * from employees where id &gt; 90000 limit 5; 显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3be6d2732a1998e9691665bfab07b961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb8eb26c94c8ca5cab841cd1be3ef36/" rel="bookmark">
			解决QSqlQuery::exec: database not open
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QSqlQuery::exec: database not open 一、问题说明二、解决办法三、出现原因 一、问题说明 在使用自定义数据连接后，发生了数据库连接成功，但是查询失败
Succeed to connect local database. QSqlQuery::exec: database not open QSqlError("", "Driver not loaded", "Driver not loaded") 如下问题代码
QSqlDatabase::addDatabase("QSQLITE", localDBName); QSqlDatabase loaclDB = QSqlDatabase::database(localDBName); loaclDB.setDatabaseName("GraduationDesign.db"); bool openflag = loaclDB.open(); if (!openflag) { qDebug() &lt;&lt; "Error: Failed to connect local database." &lt;&lt; loaclDB.lastError(); } else { qDebug() &lt;&lt; "Succeed to connect local database." ; } //问题出在query QSqlQuery query; query.exec("SELECT UserInfo_TB.ID, UserInfo_TB.UserName FROM UserInfo_TB;"); if(!query.exec()) { qDebug()&lt;&lt;query.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bb8eb26c94c8ca5cab841cd1be3ef36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d91804c6130cece001de7c7728b724ea/" rel="bookmark">
			Mixed spaces and tabs no-mixed-spaces-and-tabs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不能混合使用 空格 和 tab 键
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85e901e26911d9fbcf4015b4d7740a6/" rel="bookmark">
			Android热线修复学习之路，来了解一下大厂的热修复技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在线上的BUG一直是令很多Android工程师所发愁的问题，可能就是那么几行代码，会让自己所研发的APP损失惨重，所以，热修复完美的解决了这些问题。下面就是我整理总结的一些热修复知识点和大厂热修复的一些相关资料。
一、什么是热修复？ 热修复就是一个APP上线发布以后，发现自身存在很多BUG，想要修复这些BUG，但是如果重新推出一个版本、发布、再供用户下载，那样所用的时间就太久了，不利用户体验，所以热修复就出来了，他可以在用户所下载的APP里发布一个插件，他可以在不发布新版本的前提下，修复APP的BUG，这就叫热修复。
二、热修复的优势 三、热修复机制 dexElements的数组
/** * List of dex/resource (class path) elements. * Should be called pathElements, but the Facebook app uses reflection * to modify 'dexElements' (http://b/7726934). */ private final Element[] dexElements; 热修复就是利用dexElements的顺序来做文章，当一个补丁的patch.dex放到了dexElements的第一位，那么当加载一个bug类时，发现在patch.dex中，则直接加载这个类，原来的bug类可能就被覆盖了
看下PathClassLoader代码
public class PathClassLoader extends BaseDexClassLoader { public PathClassLoader(String dexPath, ClassLoader parent) { super(dexPath, null, null, parent); } public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) { super(dexPath, null, libraryPath, parent); } } DexClassLoader代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e85e901e26911d9fbcf4015b4d7740a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5feac6f6b0502fcf2aecc60ef16b9efb/" rel="bookmark">
			开发中常见的架构模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.分层架构
分层架构是较为常见的单体架构之一。
该模式的基本思想是将应用程序的逻辑划分为若干层，每层都封装的特定的角色。例如：持久层负责应用程序与数据库引擎之间的通信；业务层负责处理应用程序中具体的业务逻辑等等。
2.驱动架构
驱动架构的思想是将应用逻辑解耦为单一用途的事件处理组件，以异步方式接收和处理事件。这是一种较为收欢迎的分布式异步架构模型，以高扩展性和适应性出名。
3.微内核架构（插件架构）
微内核架构中的设计模式包含两大部分：核心系统和插件模块。
最典型的例子如WEB浏览器，它相当于核心系统，可以让你无限地安装扩展程序。
4.微服务架构
微服务架构由单独部署的服务组成，每个服务最好豆油一个单一的责任。这些服务彼此之间相互独立也相互依赖，当其中一个服务出现故障时，其他服务不会因此中断。
5.基于空间的架构（云架构）
云架构的主要思想是分布式共享内存，以缓解经常发生在数据库层面的问题。
通过使用内存数据处理大部分操作，这样就可以避免在数据库中进行额外的操作，从而避免未来可能由此产生的任何问题，例如：如果你的用户活动数据实体发生了变化，你不需要改变一堆代码来持久化和从数据库中检索这些数据。
基本的方法是将应用程序分离成处理单元，可以根据需求自动扩大和缩小，数据将在这些单元之间进行复制和处理，无需持久化到中央数据库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/753eb30a1d01c55ebde7e9cba4dbd9a7/" rel="bookmark">
			Gitlab与Jenkins构建CICD环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 1、CI 持续集成 持续集成：持续集成(continuous integration)是指开发者在代码开发过程中，可以频繁将代码部署集成到主干，并进行自动化测试
持续交付：是指在持续集成的基础之上，将代码部署到预生产环境
持续部署：在持续交付的基础之上，把部署到生产环境的过程自动化
2、持续集成流程 1、开发者将新版本 push 到 Gitlab
2、Gitlab 随后触发 jenkins master 节点进行一次 build。(或者通过 web hook 定时检测)
3、jenkins master 节点将这个 build 任务分配给若干个注册的 slave 结点中的一个，这个 slave 结 点根据一个事先设置好的脚本进行 build。这个脚本可以做的事情很多，比如编译，测试，生成测试报告等等。这些原本需要手动完成的任务都可以交给 jenkins 来做
4、我们在 build 中要进行编译，这里使用了分布式编译器 distcc 来加快编译速度
3、CICD流程 gitlab 创建代码项目 &gt;&gt;&gt; gitlab 部署公钥 &gt;&gt;&gt; jenkins 安装插件 &gt;&gt;&gt; 创建新项目 &gt;&gt;&gt; 绑定私钥 &gt;&gt;&gt; 添加触发器 &gt;&gt;&gt; 测试部署 &gt;&gt;&gt; 增加 Build Pipeline 插件以流程图的形式展示各个 Job 的顺序
4、Jenkins Jenkins 概述：是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能
官方地址：Jenkins
5、GitLab和GitHub的区别 相同点:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/753eb30a1d01c55ebde7e9cba4dbd9a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a2b4cdad0aa4ac627ca7faf47b0ee65/" rel="bookmark">
			最多能创建TCP连接个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TCP连接个数受端口号、文件描述符、线程资源、内存资源、CPU资源的限制。
端口号： 系统用一个四元组来唯一标识一个TCP连接：{local ip, local port,remote ip,remote port}
在local ip, local port固定、不考虑ip地址分类的情况下，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。
实际可用端口范围可以如下查看：
[root]# cat /proc/sys/net/ipv4/ip_local_port_range 1024 65000 文件描述符： 每建立一个TCP连接，操作系统分配一个文件描述符，linux 对可打开的文件描述符的数量分别作了三个方面的限制：
系统级：当前系统可打开的最大数量，通过 cat /proc/sys/fs/file-max 查看
用户级：指定用户可打开的最大数量，通过 cat /etc/security/limits.conf 查看
进程级：单个进程可打开的最大数量，通过 cat /proc/sys/fs/nr_open 查看
file-max 表示系统级别的能够打开的文件句柄的数量。是对整个系统的限制，并不是针对用户的。
ulimit -n 控制进程级别能够打开的文件句柄的数量。提供对shell及其启动的进程的可用文件句柄的控制。这是进程级别的。
对于服务器来说，file-max和ulimit都需要设置，否则会出现文件描述符耗尽的问题。
线程资源： 按照每个连接，启动一个线程的方式，TCP连接个数受线程个数限制，可以用IO复用方式，一个线程管理多个TCP连接。
内存资源： 每个TCP连接本身，以及这个连接所用到的缓冲区，都是需要占用一定内存。
CPU资源： 这个很好理解。
参考文献： 限制服务器最大并发连接数如何优雅的处理 accept 出现 EMFILE 的问题 TCP连接数和文件描述符耗尽分析设置Linux打开文件句柄/proc/sys/fs/file-max和ulimit -n的区别最多能创建多少个TCP连接？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07af4f4d8e24fb49c61bce2f36e98328/" rel="bookmark">
			CMake Build工程模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： ​ CMake是一个比make更高级的编译配置工具，它可以根据不同平台、不同的编译器，生成相应的Makefile或者vcproj项目。通过编写CMakeLists.txt，可以控制生成的Makefile，从而控制编译过程。
​ 我们经常使用CMake自动生成的Makefile来构建项目生成目标文件，安装文件。本文主要介绍几种常见的工程结构及对应的CMakeList文件的写法。
case1： 入门例子，所有文件都在同一个文件夹下。
源代码来自于：https://github.com/yanxicheung/CMakeNote/tree/main/CMakeDemo/case1
目录结构： . ├── CMakeLists.txt ├── main.cpp ├── MathFunctions.cpp └── MathFunctions.h CMakeLists: # CMake 最低版本号要求 cmake_minimum_required (VERSION 2.8) # 项目信息 project (Demo2) # 查找目录下的所有源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 指定生成目标 add_executable(Demo ${DIR_SRCS}) case2： 多个目录，多个文件，使用一个CMakeLists的例子。
源代码来自于：https://github.com/yanxicheung/CMakeNote/tree/main/CMakeDemo/case2/quantity
目录结构： . ├── CMakeLists.txt ├── include │ ├── Amount.h │ └── Length.h ├── source │ └── Length.cpp └── test ├── LengthTest.cpp └── main.cpp CMakeLists: # 设置工程名称 project(quantity) cmake_minimum_required(VERSION 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07af4f4d8e24fb49c61bce2f36e98328/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e7c7d0e80506811f29fa65c176143a/" rel="bookmark">
			重写与重载的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重写与重载的区别 重写(Override)
从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。
重写返回的数据
返回值: 子类返回值[层次] &lt;= 父类返回值[层次]
重写 总结： 1.发生在父类与子类之间 2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private) 4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常
重载(Overload) 在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。 重载 总结： 1.重载Overload是编译时多态性的一种表现 2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准
重载（Overload）和重写（Override）的区别？ 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c23e1aedfb79ab155ec8f4f32105017/" rel="bookmark">
			Android 12软件安装后闪退，请添加android:exported=“true“属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 12软件安装后闪退，在模拟器安装出现以下提示：
此时要在AndroidManifest.xml文件的activity、service、provider、receiver组件增android:exported属性，true和false的选择请自行查阅资料。Android 12只支持64位的apk安装包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da96b596c6e1b2a3bee1ccf3511345b/" rel="bookmark">
			低版本Ubuntu升级为高版本libc6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20220304更新 最近因git lfs需要更新libc6版本到2.32以上，遇到了一些问题，在此更新记录
总结经验就是：安装libc6需要找与系统相对接近的版本去更新，否则会出现系统异常。
从libc6的版本看，20.04的版本对应的libc6版本最高也是libc6_2.31-0ubuntu9.7_amd64
如果要安装2.32以上，能看到的也就是 libc6_2.33-0ubuntu5_amd64或者 libc6_2.34-0ubuntu3_amd64（和更高）
而据悉，Ubuntu20.10的包就是libc6_2.34-0ubuntu3_amd64
ubuntu 16.04
Ubuntu16.04的libc6是libc6_2.23-0ubuntu3_amd64，这个一下子升级到libc6_2.34-0ubuntu3_amd64，也是可以。
后果就是连sudo都不能用了。系统还能开机，但是login都直接失败了。
我尝试使用U盘系统启动，进入/lib/x86_64-linux-gnu目录使用sudo ln -snf 修改libc6的so链接，将安装后的指向2.34版本修改为指向原来的2.23版本
重启直接报kernel异常了。
最后还是备份数据重装系统了。这次如愿了，直接安装了想要的20.04版本
ubuntu 20.04
Ubuntu20.04的libc6也并非就顺利的是2.32以上了，而是libc6_2.31-0ubuntu9_amd64
直接安装libc6_2.34-0ubuntu3_amd64也是可以的，跟Ubuntu16.04一样有一个auto config的提示，所以安装命令如下：
sudo dpkg --auto-deconfigure -i libc6_2.34-0ubuntu3_amd64.deb
安装是有个restart service的提示（图不是重点，不要装这个版本）
之后再安装git lfs也是ok的了，没有再提示需要2.32版本以上了。
但是这样安装libc6_2.34-0ubuntu3_amd64有一些其他库不完整，导致apt-get install时一直提示异常。
因此我又降版本安装了libc6_2.33-0ubuntu5_amd64系列库文件，安装2.33就不需要加–auto-deconfigure，也没有界面提示了。一切看似顺利，git lfs也成功安装运行了，apt-get install运行也正常了。
此问题本该到此结束，但因为我系统安装其他如g++时提示了libc-dev等版本不匹配。所以我把git lfs卸载了，把libc6又降到libc6_2.31-0ubuntu9.7_amd64，把一些编译所需的工具安装完成，编译正常了。
所以后续在把整个系统升级到21.04以上之前，我只能按需切换libc6的版本了。
20210721 记录 GLIBCXX_3.4.20 not found
GXXABI_1.3.9 not found
GLIBCXX_3.4.21 not found
ldd --version 查看当前版本
ldd (Ubuntu GLIBC 2.23-0ubuntu10) 2.23
Copyright © 2016 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da96b596c6e1b2a3bee1ccf3511345b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c2d8af469acf055950bf81e7b84034/" rel="bookmark">
			JVM基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java虚拟机 虚拟机的组成:
虚拟机主要是由：
jvm运行时数据区、类加载器、执行引擎
三个子系统组成！
JVM的生命周期：
*启动。启动一个Java程序时，一个JVM实例就产生了， 任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点。 启动了几个main函数就启动了几个java应用，同时也启动了几个java的虚拟机 *运行。main()作为该程序初始线程的起点，任何其他线程均由该线程启动。 *消亡。当程序中的所有非守护线程都终止时，JVM才退出； 若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。 当在电脑上运行一个程序时，就会运行一个java虚拟机 ，java虚拟机总是开始于main方法，main方法是程序的起点。 java的线程一般分为两种：守护线程和普通线程。守护线程是java虚拟机自己使用的线程， 比如GC线程就是一个守护线程，当然你可以把自己的线程设置为守护线程， 注意：main方法启动的初始线程不是守护线程。 只要java虚拟机中还有普通线程在执行，java虚拟机就不会停止， 如果有足够的权限，你可以调用exit（）方法终止线程。 1、jvm运行时数据区 jvm运行时数据区主要分为五部分:
方法区、堆、虚拟机栈、本地方法栈、程序计数器；
1.1 程序计数器 当前线程所执行的字节码的行号指示器
指向当前线程正在执行的字节码指令，线程是私有的。
其特点是：
如果正在执行java方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址，
如果正在执行Native方法，则这个计数器为空（undefined），此内存区域是唯一一个在java虚拟机中没有规定任何OutOfMemoryError异常情况的区域。
使用场景：A线程先获取CPU时间片执行，当执行到一半的时候，B线程过来了，且优先级比A线程的高，所以处理器又去执行B线程了，把A线程挂起，当B线程执行完了以后，再回过头来执行A线程，这时就需要知道A线程已经执行的位置，也就是查看A中的程序计数器中的指令。
1.2 堆 Java对象存储的地方：
特征：线程共享
Java堆是虚拟机管理的内存中最大的一块。Java堆是所有线程共享的区域。在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。存放new生成的对象和数组。Java堆是垃圾收集器管理的内存区域，又叫“GC堆”。可以通过-Xmx和-Xms控制堆的大小 1.3 虚拟机栈 虚拟机栈是Java执行方法的内存模型。
每个方法被执行的时候，都会创建一个栈帧，把栈帧压入栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈。
(1）栈帧：栈帧存储方法的相关信息，包含局部变量数表、返回值、操作数栈、动态链接 a、局部变量表：包含了方法执行过程中的所有变量。局部变量数组所需要的空间在编译期间完成分配，在方法运行期间不会改变局部变量数组的大小。 b、返回值：如果有返回值的话，压入调用者栈帧中的操作数栈中，并且把PC的值指向 方法调用指令 后面的一条指令地址。 c、操作数栈：操作变量的内存模型。操作数栈的最大深度在编译的时候已经确定（写入方法区code属性的max_stacks项中）。 操作数栈的的元素可以是任意Java类型，包括long和double，32位数据占用栈空间为1，64位数据占用2。 方法刚开始执行的时候，栈是空的，当方法执行过程中，各种字节码指令往栈中存取数据。 d、动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接。 (2)线程私有 1.4 本地方法栈 调用本地native的内存模型
Native 方法就是一个java调用非java代码的接口，该方法的实现由非java语言实现。Native方法用native修饰，没有方法体，因为方法体中的实现是非java语言的。
有时java需要调用操作系统的一些方法，而操作系统基本都是C语言写的，这时就需要使用到Native方法了。 Native方法关键字修饰的方法是一个原生态的方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI（Java Native Interface）接口调用其他语言来实现对底层的访问。 线程独享/私有。
1.5 方法区 用于存储已被虚拟机加载的类信息、常量、静态变量，即时编译后的代码等数据。
线程共享；
运行时常量池；
A、是方法区的一部分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c2d8af469acf055950bf81e7b84034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ed737edb137eea8be1b7a25b2dd180/" rel="bookmark">
			时序动作检测《BMN: Boundary-Matching Network for Temporal Action Proposal Generation》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时序动作检测SSAD《Single Shot Temporal Action Detection》_程大海的博客-CSDN博客_时序动作检测
时序动作检测《BSN: Boundary Sensitive Network for Temporal Action Proposal Generation》_程大海的博客-CSDN博客
时序动作检测《BMN: Boundary-Matching Network for Temporal Action Proposal Generation》_程大海的博客-CSDN博客
《Non-local Neural Networks》个人总结理解_程大海的博客-CSDN博客
时序动作检测《BSN++: Complementary Boundary Regressor with Scale-Balanced Relation Modeling for ……》_程大海的博客-CSDN博客
温馨提示：本文仅供自己参考（勿捧杀），如有理解错误，有时间再改！
BMN算法是对BSN算法的改进，有关BSN算法的详细介绍，请参考上一篇文章。一个高质量的proposal生成方法应当具备生成的proposal长度灵活可变、proposal边界精确、proposal可靠的置信度。
BSN算法的缺点：
1、BSN算法中PEG模块对于候选proposal的特征构建和置信度评估是分开进行的，效率低
2、在BSN算法中的TEM模块对每个时刻采用局部上下文信息进行特征建模，proposal特征的构建缺少丰富的时序上下文信息
3、BSN算法中包含多个处理步骤：视频特征提取、TEM、PGM、PEM等，是一个多阶段的算法模型，不是一个统一的网络模型
视频特征提取
BMN算法中对于视频的形式化定义以及视频时序特征的提取方法和BSN算法相同。
Boundary-Matching Mechanism
在BM机制中，一个proposal被表示为一对开始边界点和结束边界点，然后将这个（开始，结束）转换为（开始，持续时长），然后使用一个二维的BM置信度图来表示所有可能的proposal的（开始，持续时长）对，其中横轴表示proposal的不同开始时间点，纵轴表示proposal的持续长度。在BM机制中，首先定义一个BM层用来从输入的特征序列中生成BM特征图，在BM特征图中，包含每个proposal丰富的特征和上下文信息，然后对于BM特征图使用卷积层来计算得到BM置信度图。
BM置信度图
BM置信度图要点解释：
1、BM置信度图上每一行上的proposal具有相同的持续时间，不同的开始时间位置
2、BM置信度图上每一列上的proposal具有相同的开始时间位置，但是具有不同的持续时间长度
3、BM置信度图上平行于45度线上的proposal具有不同的开始时间点和持续时间长度，但是具有相同的结束时间点
4、BM置信度图的右下角区域的proposal是无效的，因为此区域的proposal的开始时间+持续时间可能会超过视频的总时长
假设将BM置信度图表示为，对于置信度图中的任一proposal的坐标，位于第行，第列，其对应的proposal表示为, 表示这个proposal以为开始位置，持续时间，以为结束位置的置信度。通过BM置信度图，可以生成所有可能的proposal的预测置信度值。
Bounding-Matching Layer（BM层）
Bounding-Matching Layer模块将提取到的视频特征序列转换为BM置信度图。首先，定义提取到的视频特征序列为，对于每个proposal ，在其开始时间和结束时间范围内，采样N个点特征点，得到每个proposal的特征，对每个proposal 都进行同样的采样过程，就得到了BM特征图：
其中，是原始特征序列的输入通道数，是在每个proposal上的采样点数，是定义的proposal最大持续时长超参数，是输入的原始特征序列长度。
BM特征采样需要解决的问题：
1、如何在开始时间和结束时间范围内采样N个特征点，这些特征点可能不会刚好落在整数位置上，需要定义非整数位置的特征点采样方法，（BSN算法中采用的是线型插值均匀采样，类似于RoI Align，这种计算方式这能对每个proposal进行单独计算，效率低）
2、如何同时提取BM置信度图上所有proposal的特征点，以提高计算效率
proposal特征采样实现方法：
首先对于proposal 的边界进行扩充，，为起始边界点，为结束边界点，，对该区间进行均匀采样N个点，并且生成采样点对应的权重矩阵，然后根据每个均匀采样点的权重以及与之对应的时序特征加权计算每个采样点的特征，权重矩阵计算公式如下：
对于在proposal片段内采样的N个点，假如第n个采样点,那么表示这个采样点落在时间序列和之间，通过采样点的小数部分来衡量采样点和时间序列和之间的靠近程度，并使用和的加权结果来表示位置的采样结果，的小数部分越大，表明离越远，时刻的权重就越小，时刻t+1的权重就越大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ed737edb137eea8be1b7a25b2dd180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d24d5fae4be64b241dd943a13657015d/" rel="bookmark">
			深度学习之空洞卷积(Dilated/Atrous Convolution)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空洞卷积 Convolution with holes 是在标准的卷积映射（convolution map ）里注入空洞，以此来增加感受野（ reception field），捕获多尺度上下文信息。
空洞卷积实际卷积核大小K：
K=k+(k-1)(r-1) k为原始卷积核大小;
r(dilation rate)为空洞卷积参数空洞率---kernel的间隔数量，标准卷积r=1。当r=2时，3×3卷积核尺寸扩大为3+(3-1)*(2-1)=5,即5×5；r=4,扩大为9×9。
感受野计算公式：​
1）2层3*3的卷积核卷积操作之后的感受野是5*5，其中卷积核（filter）的步长（stride）为1、padding为0;3层3*3的卷积核卷积操作之后的感受野是7*7，其中卷积核（filter）的步长（stride）为1、padding为0。
2）3层r=[1,2,4]的连续空洞卷积，感受野为15*15。
总结1：
现在网络模型的优化改进，其中的一个趋势就是用小卷积核来代替大卷核。从感受野的角度来看，两个3*3的卷积核串联相当于一个5*5卷积核的感受野，三个3*3的卷积核串联相当于一个7*7的卷积核感受野。所以用小卷积核来代替大卷积核想要实现同样的语义抽象等级，网络层数需要更深。大卷积核从极限的角度计算量会比小卷积核计算量大。同时，多个小卷积核串联相比于单个大卷积核来说非线性程度往往更高。此处原文链接：https://blog.csdn.net/zyazky/article/details/80967931
总结2：
空洞卷积的感受野是呈指数增长的，而感受野的大小象征了网络对全局特征的学习情况。而空洞卷积也存在两个严重缺陷：1. 空洞率过大会导致采样稀疏性，虽然利于捕获全局信息，但对于小目标的学习不利，因此常采用堆叠的空洞卷积；2. 网格化gridding效应，若堆叠的空洞率相同或存在大于1的公约数，如r=[2,2,2],对于中间的红色像素点而言，随着层数的增加，与其一同参与运算的只有蓝色标记的像素点（深浅表示利用程度），会丢失局部信息，造成网格化效应。
​
空洞卷积的典型应用实例ASPP
空洞金字塔池化ASPP（Atrous Spatial Pyramid Pooling），是DeeplabV2在V1的基础上，采用不同空洞率的空洞卷积并行采样，如下图所示，用于融合多尺度信息。V3通过引入1*1卷积和全局平均池化,添加了BN层改进了ASPP。
class ASPPNOBN(nn.Module): def __init__(self, in_channel=2048, depth=1024): super(ASPPNOBN, self).__init__() self.mean = nn.AdaptiveAvgPool2d((1, 1)) # (1,1)means ouput_dim self.conv = nn.Conv2d(in_channel, depth, 1, 1) self.atrous_block1 = nn.Conv2d(in_channel, depth, 1, 1) self.atrous_block6 = nn.Conv2d(in_channel, depth, 3, 1, padding=6, dilation=6) self.atrous_block12 = nn.Conv2d(in_channel, depth, 3, 1, padding=12, dilation=12) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d24d5fae4be64b241dd943a13657015d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5433d91e0d06a93ecb14e4bfa5ff75a/" rel="bookmark">
			免费好用的钉钉内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.什么是内网穿透？
内网穿透简单来说就是将内网外网通过natapp隧道打通,让内网的数据让外网可以获取。比如常用的办公室软件等，一般在办公室或家里，通过拨号上网，这样办公软件只有在本地的局域网之内才能访问，那么问题来了，如果是手机上，或者公司外地的办公人员，如何访问到办公软件呢？这就需要natapp内网穿透工具了。运行natapp隧道之后，natapp会分配一个专属域名/端口,办公软件就已经在公网上了,在外地的办公人员可以在任何地方愉快的访问办公软件了~~
2.什么是钉钉内网穿透？
钉钉是阿里巴巴集团一个非常厉害的部门，他们鉴于很多开发者在临时体验开发时往往没有公网域名或者公网IP，于是开发了这个内网穿透工具，提供了一个公网代理服务，目的是方便开发测试。钉钉内网穿透使用起来非常方便，只需要简单的2个步骤
一.在GitHub上下载
鉴于国内访问GitHub网站的速度非常慢，我给大家提供一个镜像网站，GitHub镜像站
在里面搜索 ”钉钉内网穿透“
接下来就下载它
下载完成后，咱们就可以看到被解压后的文件夹了
二.配置windows
选择windows_64,用快捷方式打开命令行窗口
打开自己项目，让它在本地服务器上跑起来，（这个没有的话，你就要自己去搭建项目了）
由于我的服务器端口是8080,下面的端口我就写成8080了
把下面这行代码运行在windows_64的命令行窗口上
ding -config=ding.cfg -subdomain=abcde 8080 得到这个结果，就说明可以了
于是你在手机上输入下面的网址都能够访问了（前提是响应式开发的~~~）
http://abcde.vaiwan.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d61dd30917a1e96db1e36dd931065c05/" rel="bookmark">
			人体姿态估计 Android端 ncnn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去年由于一些原因，需要在手机端部署人体姿态估计模型，早就写完了，但由于一些原因一直没有记录下来。大致的过程是，经过一番百度，找到了一个名为ncnn的框架，然后参考ncnn-android-yolox的实现，完成了人体姿态估计模型在移动端的部署。代码已开源：ncnn-android-pose，采用的目标检测器是旷视开源的YOLOX。
效果 用坤坤打篮球的经典视频测试了一波，感觉还不错？
环境 这里需要配置的环境是Android端的OpenCV和ncnn框架，其实只需要下载这两个东西，然后将CMakeLists中的两个路径修改以下即可。我的CMakeLists.txt主要部分如下所示：
cmake_minimum_required(VERSION 3.10) set(OpenCV_DIR ${CMAKE_SOURCE_DIR}/opencv-mobile-4.5.4-android/sdk/native/jni) find_package(OpenCV REQUIRED core imgproc) set(ncnn_DIR ${CMAKE_SOURCE_DIR}/ncnn-20211208-android/${ANDROID_ABI}/lib/cmake/ncnn) find_package(ncnn REQUIRED) add_library(ncnnyolox SHARED yoloxncnn.cpp yolox.cpp slpn.h slpn.cpp ndkcamera.cpp) target_link_libraries(ncnnyolox ncnn ${OpenCV_LIBS} camera2ndk mediandk) 下载ncnn和opencv的Android版本即可。注意这里还要下一下ncnn的Windows版本或Linux版本，取决于你自己模型的平台，将onnx模型转为ncnn的param和bin文件。onnx模型的生成在我前面的博客都有。
模型转换 首先要把onnx模型转换为ncnn支持的param和bin文件，运行下面的命令即可：
onnx2ncnn.exe a.onnx a.param a.bin 后面就是你模型的名字了，我是在Windows下转换的。
然后采用量化工具进行一下量化，这里参考的是ncnn量化，可以对模型的参数大小进行一些优化。然后就生成了模型的bin和param文件，就可以利用它们进行推理了。
代码 其实采用ncnn的好处是，你可以在Windows或者Linux环境下用C++预先调试好代码，再在Android Studio上用JNI的方法，直接把调试好的C++代码复制过去就行了。总的来讲，这部分代码就是ncnn的模型前向推理过程加上我之前博客写的人体姿态估计的前后处理部分。具体可以参考我的开源代码实现，主要是在SLPNet.cpp中。推理部分主要代码如下：
// 载入模型 int SLPNet::load(AAssetManager* mgr, const char* modeltype, int _target_size, const float* _mean_vals, const float* _norm_vals, bool use_gpu) { slpnet.clear(); blob_pool_allocator.clear(); workspace_pool_allocator.clear(); ncnn::set_cpu_powersave(2); ncnn::set_omp_num_threads(ncnn::get_big_cpu_count()); slpnet.opt = ncnn::Option(); #if NCNN_VULKAN slpnet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d61dd30917a1e96db1e36dd931065c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61b70a4b8f92058c0cf217866afb2365/" rel="bookmark">
			设计模式之使用Java 流式过滤实现过滤器模式【链式过滤】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用流式过滤器处理过滤用户所在的省、市、年龄、性别等。重点是后面的链式过滤器。
目标过滤User @NoArgsConstructor @AllArgsConstructor @Builder @Data public class User { private String id; private String name; private String provinceCode; private String cityCode; private int age; private int gender; } 定义过滤器接口 public interface FilterService&lt;T&gt; { /** * 过滤器方法 * @param list * @param value * @return */ List&lt;T&gt; filter(List&lt;T&gt; list,String value); } 定义各种过滤器实现 public class AgeFilter implements FilterService&lt;User&gt; { @Override public List&lt;User&gt; filter(List&lt;User&gt; list,String value) { int age = Integer.parseInt(value); return list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61b70a4b8f92058c0cf217866afb2365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df67d6709fd188f2aa8a2c6b1e4c1481/" rel="bookmark">
			【vue】深入理解 vue model 属性：用于弹框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入理解 vue model 属性：用于弹框 一、文章综述作用背景 二、主要内容三、参考资料 一、文章综述 作用 帮助理解 model 用法，额外提到 computed 的 set 方法；弹框写法。
背景 阅读同事的代码，发现弹框写法跟我不一样，接触到了 model 属性，在朋友的讲解下，理解了 model 和 computed 的用法。
二、主要内容 &lt;template&gt; &lt;a-modal v-model="modalVisible" title="Test" okText="Confirm" @ok="modalVisible = false" destroyOnClose &gt; &lt;span&gt;{{sum}}&lt;/span&gt; &lt;/a-modal&gt; &lt;/template&gt; &lt;script&gt; export default { props: { visible: Boolean, add1: Number, add2: Number }, model: { prop: 'visible', event: 'update:visible' }, computed: { modalVisible: { get () { return this.visible }, set (val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df67d6709fd188f2aa8a2c6b1e4c1481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf946709ed5422fabf4a271f1db1818/" rel="bookmark">
			使用Vue搭建前端项目架构《转载》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建Vue项目基础框架
1.使用vue cli脚手架创建项目的基础框架
具体vue的配置如下：
2.配置.gitignore文件=&gt;在提交到GitHub时不要提交node modules文件
二、创建GitHub仓库
1.在GitHub上创建仓库
2.clone仓库到本地
3.将上面使用vue cli创建的项目基础框架文件复制到上面仓库目录中
4.选择性push代码（也可以后面的工作完成后再push）
三、完善项目架构
前期工作：
1.安装axios（向后台异步请求数据）
npm install --save axios vue-axios 然后在main.js中引入并使用
//引入axios import axios from 'axios' import VueAxios from 'vue-axios' //使用axios Vue.use(VueAxios, axios) 2.安装element-ui组件
npm i element-ui -S 然后在main.js中引入并使用
//引入axios import ElementUI from 'element-ui'; import 'element-ui/lib/theme-chalk/index.css'; //使用axios Vue.use(ElementUI); 3.在根目录下创建.env.development开发环境配置文件，将开发环境的后端接口地址配置在这里
NODE_ENV = development VUE_APP_API_URL=http://81.70.223.139:8091//后端接口地址 然后我们配置各种文件进行封装，在src目录下创建utils文件夹：
1.在utils文件夹中创建request.js，配置request文件，对axios进行二次封装，主要封装两个拦截器，请求(require)拦截器和响应(response)拦截器，不要忘了在main.js中引入=&gt;import "@/utils/request.js";
（1）请求拦截器=&gt;在请求发送前进行必要操作处理，相当于是对每个接口里相同操作的一个封装
// 请求拦截器 axios.interceptors.request.use( (config) =&gt; { config.baseURL = process.env.VUE_APP_API_URL; let tokenInfo = getToken(); if (tokenInfo) { // tokenInfo = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf946709ed5422fabf4a271f1db1818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f15a9fa1743166777a1ac5e5cbc8d48/" rel="bookmark">
			让html img图片垂直居中的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种让img元素图片在盒子内垂直居中的方式教程，依据代码与文章教程熟习掌握并加以应用。
一、使用flex完成垂直居中
操纵css flex实现垂直居中。flex或许不是完成垂直居中最好的选择，由于IE8,9其实不赞成它。
那时，为了用flex实现垂直居中，我们起首要竖立一个包裹着图片的div元素，日后给它定义一些根基属性。
如下图片img宽度为（设置为）100px，高度为100px。
HTML代码部份：
&lt;div class="flexbox"&gt; &lt;img src="1.jpg" alt=""&gt; &lt;/div&gt; CSS代码一部分：
body{ background:#999} .flexbox{width: 300px;height: 250px;bac千克round:#fff;display: flex;align-items: center} .flexbox img{width: 100px;height: 100px;align-items: center;} 功效：
阅读器运行造诣：实现图片垂直居中布局
诠释：
1、为了用flex完成垂直居中，我们首先要建树一个包裹着图片的div元素，今后给它定义一些基础底细属性。
2、div元素的display属性设置装备摆设为flex。
3、div增加其它一条属性align-items: center;
二、操作Display: table;完成img图片垂直居中
html代码：
&lt;div class="tablebox"&gt; &lt;div id="imgbox"&gt; &lt;img src="1.jpg" alt=""&gt; &lt;/div&gt; &lt;/div&gt; CSS代码：
.tablebox{width: 300px;height: 250px;bac千克round: #fff;display: table} #imgbox{display: table-cell;vertical-align: middle;} #imgbox img{width: 100px} 评释：
1、起首咱们先要建设一个div元素以及其它一个采集图片的div元素，从此咱们开始配置它的名目。
2、给img父元素设置display属性为table
3、把包裹图片的那个div元素的display属性设置为table-cell
4、为了实现垂直居中，咱们其时要做的即是给包裹图片的div元素配置vertical-align: middle;属性
把稳：要是你也想完成程度居中，你可以给最外层的div元素增进text-align: center属性，寄望不是id=”img”的div
三、用绝对定位完成垂直居中（举荐-兼容性好）
HTML代码：
&lt;div class="posdiv"&gt; &lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f15a9fa1743166777a1ac5e5cbc8d48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ebe625f6585037d8536a71a0d0f94d/" rel="bookmark">
			Vue 订单(查询&#43;展示&#43;收货地址)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 获取订单列表数据 新建文件
index.js中配置路由
{ path: '/orders', component: () =&gt; import ('../components/order/Orders.vue') }, 是否付款列使用elemenui =》Tab标签
提示信息是否可移入 :enterable="false" &lt;template&gt; &lt;div&gt; &lt;!-- 面包屑导航--&gt; &lt;el-breadcrumb separator-class="el-icon-arrow-right"&gt; &lt;el-breadcrumb-item :to="{ path: '/home' }"&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;订单管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;订单列表&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;!-- 卡片试图--&gt; &lt;el-card&gt; &lt;el-row :gutter="20"&gt; &lt;el-col :span="8"&gt; &lt;el-input placeholder="请输入订单编号" v-model="queryInfo.query" clearable&gt; &lt;el-button slot="append" icon="el-icon-search"&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;!--订单列表--&gt; &lt;el-table :data="orderList" border stripe&gt; &lt;el-table-column label="序号" type="index"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="订单编号" prop="order_number"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="订单价格(元)" prop="order_price"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="是否付款" &gt; &lt;template slot-scope="scope"&gt; &lt;el-tag effect="dark" size="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7ebe625f6585037d8536a71a0d0f94d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d8aef529734f496d33d428bd104cdd9/" rel="bookmark">
			数仓建模与数据采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数仓分层： ODS （源数据层）
存的数据内容 需要进行大数据分析的业务关联数据以hive表形式展现，存储在hdfs文件系统特点：导入数据的过程一定不能改变原有的数据内容 数据从哪里来 sqoop是从oracle业务系统中导入的数据 DWD （数据明细层）
存的数据内容 所有业务系统表的明细数据（分区数据） 数据从哪里来 从ods层按分区导入的数据 DWS （维度层 DIM）
存的数据内容 存储维度层数据：日期维度，地理区域各个不同粒度的维度数据…以orc格式存储数据（压缩：snnapy） 如何看压缩格式的性能 压缩速度解压速度存储大小 数据从哪里来 从DWD层进行ETL抽取数据到dws层 DWB （事实层）
存的数据内容 存储事实指标数据 数据从哪里来 从DWD层进行ETL抽取的数据 ST （ADS / APP 数据应用层) 宽表
存的数据内容 数据应用层,存储dwd，dws聚合后的数据，接近分析指标结果数据 数据从哪里来 从dwd + dws层数据聚合之后，作为st来源 DM （数据集市层，宽表）
存的数据内容 存储以部门划分，业务需求划分的数据 数据从哪里来 数据从dw层抽取过来（重度汇总数据） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd8bf13a77a1573bbab7dc1289e84e3f/" rel="bookmark">
			python网络编程基础，进程，线程介绍。有代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程 IP，端口，协议(TCP) 创建进程： import multiprocessing 密集计算用进程 aa=multiprocessing.Process(target=函数名) 创建进程对象 传实参给函数的两种方式，元组，和字典 aa=multiprocessing.Process(target=coding,args=('ddddd',)) aa=multiprocessing.Process(target=music_,kwargs={'shijian':5}) aa.daemon=True 设置守护主进程，必须在start前设置，监听主进程，主进程结束，子进程也立马结束 aa.terminate() 子进程自己结束自己 aa.start() 开始运行进程并调用函数 aa.join() 等待执行，主进程等待aa进程执行完之后，再继续往下执行 操作进程： import os bb=os.getpid() 获取当前进程id cc=multiprocessing.current_process().pid 获取当前进程id dd=os.getppid() 获取父进程id os.kill(pid,9) 杀死当前进程，9是确认杀死 注意点：进程之间的全局变量是不共享的，当创建并运行子进程后，子进程会复制一份主进程的所有代码，那这时在子进程修改全局变量主进程并不会被修改。这时候只是进程之间的全局变量名一样，但操作的不是同一进程里面的全局变量 ###### 线程是进程中的任务 进程有id 线程没有id，但是可以返回线程对象 IO密集用线程 创建线程 ： import threading aa=threading.Thread(target=函数名) 创建线程对象 aa.start() 启动线程 创建线程并传参给函数，与进程一样 args=元组，kwargs=字典 print(threading.current_thread()) 获取线程对象 aa.daemon=True 主线程守护,主线程结束，子线程也结束 aa.join() 主线程等待当前线程执行完成 注意点：执行时无序的，线程之间共享全局变量，但有可能会有错误。 aa=threading.Lock() 创建互斥锁，能解决线程全局变量共享出错的问题 aa.acquire() 上锁 aa.release() 解锁 互斥锁把全局变量放在锁之间，没解锁，就是死锁，代码会卡死
​ 只要是网络程序都会用到socket来完成，所有网络通讯
TCP
ww=socket.socket(socket.AF_INET,socket.SOCK_STREAM) 创建socket连接对象 可执行多任务服务器代码
import socket import threading def chuli(newser_socket,ipadd): while True: straa = newser_socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd8bf13a77a1573bbab7dc1289e84e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066eb7dadb782832ea0adfb14498f4d8/" rel="bookmark">
			YOLO系列算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 YOLO系列算法yolo算法Yolo算法思想Yolo的网络结构网络输入网络输出7X7网格30维向量 Yolo模型的训练训练样本的构建损失函数模型训练 模型预测yolo总结 yoloV2预测更准确（better）batch normalization使用高分辨率图像微调分类模型采用Anchor Boxes聚类提取anchor尺度边框位置的预测细粒度特征融合多尺度训练 速度更快（Faster）识别对象更多 yoloV3算法简介多尺度检测网络模型结构先验框logistic回归yoloV3模型的输入与输出 yoloV4总结 YOLO系列算法 学习目标
知道yolo网络架构，理解其输入输出知道yolo模型的训练样本构建的方法理解yolo模型的损失函数知道yoloV2模型的改进方法知道yoloV3的多尺度检测方法知道yoloV3模型的网络结构及网络输出了解yoloV3模型先验框设计的方法知道yoloV3模型为什么适用于多标签的目标分类了解yoloV4模型 YOLO系列算法是一类典型的one-stage目标检测算法，其利用anchor box将分类与目标定位的回归问题结合起来，从而做到了高效、灵活和泛化性能好，所以在工业界也十分受欢迎，接下来我们介绍YOLO 系列算法。
yolo算法 Yolo算法采用一个单独的CNN模型实现end-to-end的目标检测，核心思想就是利用整张图作为网络的输入，直接在输出层回归 bounding box（边界框） 的位置及其所属的类别，整个系统如下图所示：
首先将输入图片resize到448x448，然后送入CNN网络，最后处理网络预测结果得到检测的目标。相比R-CNN算法，其是一个统一的框架，其速度更快。
Yolo算法思想 在介绍Yolo算法之前，我们回忆下RCNN模型，RCNN模型提出了候选区(Region Proposals)的方法，先从图片中搜索出一些可能存在对象的候选区（Selective Search），大概2000个左右，然后对每个候选区进行对象识别，但处理速度较慢。
Yolo意思是You Only Look Once，它并没有真正的去掉候选区域，而是创造性的将候选区和目标分类合二为一，看一眼图片就能知道有哪些对象以及它们的位置。
Yolo模型采用预定义预测区域的方法来完成目标检测，具体而言是将原始图像划分为 7x7=49 个网格（grid），每个网格允许预测出2个边框（bounding box，包含某个对象的矩形框），总共 49x2=98 个bounding box。我们将其理解为98个预测区，很粗略的覆盖了图片的整个区域，就在这98个预测区中进行目标检测。
只要得到这98个区域的目标分类和回归结果，再进行NMS就可以得到最终的目标检测结果。那具体要怎样实现呢？
Yolo的网络结构 YOLO的结构非常简单，就是单纯的卷积、池化最后加了两层全连接，从网络结构上看，与前面介绍的CNN分类网络没有本质的区别，最大的差异是输出层用线性函数做激活函数，因为需要预测bounding box的位置（数值型），而不仅仅是对象的概率。所以粗略来说，YOLO的整个结构就是输入图片经过神经网络的变换得到一个输出的张量，如下图所示：
网络结构比较简单，重点是我们要理解网络输入与输出之间的关系。
网络输入 网络的输入是原始图像，唯一的要求是缩放到448x448的大小。主要是因为Yolo的网络中，卷积层最后接了两个全连接层，全连接层是要求固定大小的向量作为输入，所以Yolo的输入图像的大小固定为448x448。
网络输出 网络的输出就是一个7x7x30 的张量（tensor）。那这个输出结果我们要怎么理解那？
7X7网格 根据YOLO的设计，输入图像被划分为 7x7 的网格（grid），输出张量中的 7x7 就对应着输入图像的 7x7 网格。或者我们把 7x7x30 的张量看作 7x7=49个30维的向量，也就是输入图像中的每个网格对应输出一个30维的向量。如下图所示，比如输入图像左上角的网格对应到输出张量中左上角的向量。
30维向量 30维的向量包含：2个bbox的位置和置信度以及该网格属于20个类别的概率
2个bounding box的位置 每个bounding box需要4个数值来表示其位置，(Center_x,Center_y,width,height)，即(bounding box的中心点的x坐标，y坐标，bounding box的宽度，高度)，2个bounding box共需要8个数值来表示其位置。2个bounding box的置信度 bounding box的置信度 = 该bounding box内存在对象的概率 * 该bounding box与该对象实际bounding box的IOU，用公式表示就是： Pr(Object)是bounding box内存在对象的概率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/066eb7dadb782832ea0adfb14498f4d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b01c7d2caea9190fe4f32817612cb19/" rel="bookmark">
			C&#43;&#43;11标准库(第二版)笔记整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.C++编译环境的组成：
C语言兼容库：头文件带.h，是C++编译器提供商为推广自己的产品，而提供的C兼容库（不是C++标准库提供的），内置的C库。C++标准库：如string cstdio(注意不带.h)是C++标准库提供的。使用时要用using namespace std编译器扩展库：这是针对不同的编译器而独有扩展，例如g++和vc++,他们在这一板块就不同。C++标准库语法模块：C++标准语法的支持C++扩展语法模块：同样是针对不同的编译器而独有的扩展语法 2.C++标准库
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-U2lveYxw-1646271445999)(F:\C++\C++库\image-20220301092740399.png)]
(1)流输入/输出
iostream：支持标准流cin、cout、cerr和clog的输入和输出，还支持多字节字符标准流wcin、wcout、wcerr和wclog。
iomanip：提供操纵程序，允许改变流的状态，从而改变输出的格式。
ios：定义iostream的基类。
istream：为管理输出流缓存区的输入定义模板类。
ostream：为管理输出流缓存区的输出定义模板类。
sstream：支持字符串的流输入输出。
fstream：支持文件的流输入输出。
iosfwd：为输入输出对象提供向前的声明。
streambuf：支持流输入和输出的缓存。
cstdio：为标准流提供C样式的输入和输出。
cwchar：支持多字节字符的C样式输入输出。
(2)数值操作
complex：支持复杂数值的定义和操作。
valarray：支持数值矢量的操作。
numeric：在数值序列上定义一组一般数学操作，例如accumulate和inner_product。
cmath：这是C数学库，其中还附加了重载函数，以支持C++约定。
cstdlib：提供的函数可以提取整数的绝对值，对整数进行取余数操作
(3)诊断功能
stdexcept：定义标准异常。
cassert：定义断言宏，用于运行时检查。
cerrno：支持C样式的错误信息
(4)语言支持功能
cstddef：定义宏NULL和offsetof以及其它标准类型size_t和ptrdiff_t。与对应的标准C头文件的区别是，NULL是C++空指针常量的补充定义(C++11中已有关键字nullptr），宏offsetof接受结构或者联合类型参数，只要没有成员指针类型的非静态成员即可。
limits：提供与基本数据类型相关的定义。例如，对于每个数值数据类型，它定义了可以表示出来的最大值和最小值以及二进制数字的位数。
climits：提供与基本整数数据类型相关的C样式定义，C++样式定义在中。
：提供与基本浮点型数据类型相关的C样式定义，C++样式定义在limits中。
cstdlib：提供支持程序启动和终止的宏和函数，还声明了许多其他杂项函数，例如搜索和排序函数，从字符串转换为数值等函数。cstdlib与对应的标准C头文件stdlib.h不同，定义了abort(void)。abort()函数还有额外的功能，它不为静态或自动对象调用析构函数，也不调用传给atexit()函数的函数。它还定义了exit()函数的额外功能，可以释放静态对象，以注册的逆序调用用atexit()注册的函数。清除并关闭所有打开的C流，把控制权返回给主机环境。
new：支持动态内存分配。
typeinfo：支持变量在运行期间的类型标识。
exception：支持异常处理，是处理程序中可能发生的错误的一种方式。
cstdarg：支持接受数量可变的参数的函数。即在调用函数时，可以给函数传送数量不等的数据项。定义了宏va_arg、va_end、va_start以及va_list类型。
csetjmp：为C样式的非本地跳跃提供函数，在C++中不常用。
csignal：为中断处理提供C样式支持。
(5)字符串处理
string：为字符串类型提供支持和定义，包括单字节字符串(由char组成)的string和多字节字符串(由wchar_t组成)。
cctype：单字节字符类别。
cwctype：多字节字符类别。
cstring：为处理非空字节序列和内存块提供函数。不同于对应的标准C库头文件，C样式字符串的一般C库函数被返回值为const和非const的函数对替代。
cwchar：为处理、执行I/O和转换多字节字符序列提供函数，不同于对应的标准C库头文件，几个多字节C样式字符串操作的一般C库函数被返回值为const和非const的函数对替代。
cstdlib：为把单字节字符串转换为数值、在多字节字符和多字节字符串之间转换提供函数。
(6)容器类模板
vector：定义vector序列模板，是一个大小可以重新设置的数组类型，比普通数组更安全、更灵活。
list：定义list序列模板，是一个序列的链表，常常在任意位置插入和删除元素。
deque：定义deque序列模板，支持在开始和结尾的高效插入和删除操作。
queue：为队列(先进先出)数据结构定义序列适配器queue和priority_queue。
stack：为堆栈(后进先出)数据结构定义序列适配器stack。
map: map是一个关联容器类型，允许根据键值是唯一的，且按照升序存储。multimap类似于map，但键不是唯一的。
set：set是一个关联容器类型，用于以升序方式存储唯一值。multiset类似于set，但是值不必是唯一的。
bitset：为固定长度的位序列定义bitset模板，它可以看作固定长度的紧凑型bool数组。
array：（TR1）固定大小数组，支持复制。
forward_list：（c++11）单向列表，支持快速随机访问。
unordered_set：（TR1)无序容器set，其元素随机存放。multiset类似于set，但是值不必是唯一的。
unordered_map：（TR1)无序容器map，其键值随机存放。multimap类似于map，但键不是唯一的
(7)迭代器
iterator:给迭代器提供定义和支持
(8)算法
algorithm：提供一组基于算法的函数，包括置换、排序、合并和搜索。
cstdlib：声明C标准库函数bsearch()和qsort()，进行搜索和排序。
ciso646：允许在代码中使用and代替&amp;&amp;
3.C++标准库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b01c7d2caea9190fe4f32817612cb19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5faa9a72f9658d523602e29b44abbf70/" rel="bookmark">
			C语言实现二叉排序树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.二叉排序树的定义 二叉排序树，又称二叉查找数树，一颗二叉树或者是空二叉树，或者是具有如下性质的二叉树：
a.左子树上所有结点的关键字均小于根结点的关键字；
b.右子树上所有结点的关键字竣大雨根结点的关键字。
c.左子树和右子树又各是一颗二叉排序树。
——&gt;左子树结点值&lt;根结点值&lt;右子树结点值
进行中序遍历，可以得到一个递增的有序遍历
代码如下：
//二叉排序树结点 typedef struct BSTNode{ int key; struct BSTNode *lchild, *rchild; }BSTNode, *BSTree; //在二叉排序树中查找值为key的结点 BSTNode *BST_Search(BSTree T, int key){ while(T!=NULL&amp;&amp;key!=T-&gt;key){	//若树空或等于根结点值，则结束循环 if(key&lt;T-&gt;key) T=T-&gt;lchild;	//小于，则在左子树上查找 else T=T-&gt;rchild;	//大于，则在右子树上查找 } return T; } 2.二叉排序树的查找 若树非空，目标值与跟结点比较：
a.若相等，则查找成功
b.若小于跟结点，则在左子树上查找，否则在右子树上查找。
c.查找成功，返回结点指针：查找失败返回NULL
代码如下：
//二叉排序树结点 typedef struct BSTNode{ int key; struct BSTNode *lchild, *rchild; }BSTNode, *BSTree; //在二叉排序树中序寻找值为key的结点（非递归） BSTNode *BST_Search(BSTree T, int key){ while(T!=NULL&amp;&amp;key!=T-&gt;key){	//若树空或等于根结点值，则结束循环 if(key&lt;T-&gt;key) T=T-&gt;lchild;	//小于，则在左子树上查找 else T=T-&gt;rchild;	//大于，则在右子树上查找 } return T; } //在二叉排序树中查找值为key的结点（递归） BSTNode *BSTSearch(BSTree T, int key){ if(T==NULL) return NULL; if(key==T-&gt;key) return T; else if(key&lt;T-&gt;key) return BSTSearch(T-&gt;lchild, key);	//在左子树中找 else return BSTsearch(T-&gt;rchild, key); //在右子树中找 } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5faa9a72f9658d523602e29b44abbf70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34695664e1c878649315d8c39e26db1a/" rel="bookmark">
			MyBatis笔记目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 视频教程链接：【尚硅谷】2022版MyBatis教程（细致全面，快速上手）
视频p数笔记链接简介p01-051 - MyBatis简介MyBatis历史、MyBatis特性、MyBatis下载、和其它持久化层技术对比（这部分和官方笔记内容差不多）p06-142 - 搭建MyBatis示例开发环境、创建maven工程、建立sql表单、创建MyBatis核心配置文件、创建Mapper接口、创建MyBatis的映射文件、通过junit进行测试、加入log4j日志功能p15-183 - 核心配置文件参数详解1、environment：设置数据库环境 2、transactionManager：设置事务管理方式 3、${} + properties：动态写入信息 4、typeAlias/package：设置某个类型的别名 5、mappers：引入映射文件 6、配置文件注释汇总p19-294 - MyBatis获取参数值设置配置文件模板、MyBatis获取参数值的两种方式、@Param源码分析p30-335 - MyBatis的各种查询功能查询一个实体类对象、查询一个list集合、查询单个数据、查询一条数据为map集合、查询多条数据为map集合p34-376 - 特殊SQL的执行模糊查询、批量删除、动态设置表名、添加功能获取自增的主键p38-477 - 映射关系自定义映射resultMap，处理一对多/多对一映射关系，处理属性字段一致性，MyBatis懒加载p48-558 - 动态SQLif/where/trim/choose/foreach/sql片段includep56-619 - MyBatis缓存一级缓存/二级缓存/二级缓存相关配置/缓存查询顺序/第三方缓存EHCache整合示例p62-6410 - MyBatis逆向工程根据SQL表单自动创建pojo、mapper接口、映射文件p65-6611 - 分页插件的配置及使用分页插件的配置及使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7edd00cddd62812d83596069111e66d7/" rel="bookmark">
			【MyBatis笔记】11 - 分页插件的配置及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、分页插件配置（1）添加依赖（2）配置分页插件 2、分页插件的使用测试 视频教程链接：https://www.bilibili.com/video/BV1VP4y1c7j7?p=65&amp;spm_id_from=pageDriver
1、分页插件配置 （1）添加依赖 &lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; （2）配置分页插件 在MyBatis的核心配置文件中配置插件
&lt;plugins&gt; &lt;!--设置分页插件--&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt;&lt;/plugin&gt; &lt;/plugins&gt; 2、分页插件的使用 （1）在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能
pageNum:当前页的页码
pageSize:每页显示的条数
（2）在查询获取list集合之后，使用PageInfo pageInfo = new PageInfo&lt;&gt;(List list, int navigatePages)获取分页相关数据
list:分页之后的数据
navigatePages:导航分页的页码数
（3）分页相关数据
PageInfo{
pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8,
list=Page{count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30, pages=8, reasonable=false, pageSizeZero=false},
prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true, hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8, navigatepageNums=[4, 5, 6, 7, 8]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7edd00cddd62812d83596069111e66d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81772e15658540d6f7665b204a1b315d/" rel="bookmark">
			关于ClickHouse数据迁移备份解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# ck数据导出 echo 'select * from xxxx' | curl 127.0.0.1:8123?database=xxx -ck:123456 -d @- &gt; test.sql # 数据导入 cat test.sql | clickhouse-client -h 127.0.0.1 -u ck --password 123456 --query="INSERT INTO xxxx FORMAT TabSeparated" 1、分区字段和排序字段不同也可以使用
2、7000w数据用了不到5分钟同步完毕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10b587efd770574e9bf88fb50620719/" rel="bookmark">
			Faster-RCNN网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Faster-RCNN网络 学习目标
熟悉FasterRCNN目标检测的思想知道anchor（锚框）的思想掌握RPN网络是如何进行候选区域的生成的掌握ROIPooling的使用方法知道fasterRCNN的训练方法 在R-CNN和Fast RCNN的基础上，在2016年提出了Faster RCNN网络模型，在结构上，Faster RCNN已经将候选区域的生成，特征提取，目标分类及目标框的回归都整合在了一个网络中，综合性能有较大提高，在检测速度方面尤为明显。接下来我们给大家详细介绍fasterRCNN网络模型。网络基本结构如下图所示：
Faster RCNN可以看成是区域生成网络(RPN)与Fast RCNN的组合，其中区域生成网络(RPN)替代选择性搜索来生成候选区域，Fast RCNN用来进行目标检测。
网络工作流程 FasterRCNN的工作流程是：
1、特征提取：将整个图像缩放至固定的大小输入到CNN网络中进行特征提取，得到特征图。
2、候选区域提取：输入特征图，使用区域生成网络RPN，产生一些列的候选区域
3、ROIPooling: 与Fast RCNN网络中一样，使用最大池化固定候选区域的尺寸，送入后续网络中进行处理
4、目标分类和回归：与Fast RCNN网络中一样，使用两个同级层:K+1个类别的SoftMax分类层和边框的回归层，来完成目标的分类和回归。
Faster R-CNN的流程与Fast R-CNN的区别不是很大，重要的改进是使用RPN网络来替代选择性搜索获取候选区域，所以我们可以将Faster R-CNN网络看做RPN和Fast R-CNN网络的结合。
接下来我们来看下该网络预训练模型的使用过程，模型源码位置：fasterRCNN中，如下图所示：
detection文件夹中是模型，数据的实现，weights中包含网络的预训练模型。接下来我们按照以下步骤进行目标检测：
1、获取数据和加载预训练网络
2、获取RPN网络生成的候选区域
3、获取网络的目标检测结果
首先导入相应的工具包：
# 获取VOC数据使用 from detection.datasets import pascal_voc # 绘图 import matplotlib.pyplot as plt import numpy as np # 模型构建 from detection.models.detectors import faster_rcnn import tensorflow as tf # 图像展示 import visualize 遇到的问题1：ModuleNotFoundError: No module named ‘cv2’
解决方法：pip install -i https://pypi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a10b587efd770574e9bf88fb50620719/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980e5dc96f929afed361292f53da3db0/" rel="bookmark">
			模拟客户端和服务端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import org.junit.jupiter.api.Test; import java.io.*; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; /** * 服务端和客户端在本例中都有本机（127.0.0.1）充当 */ public class TcpTest { /** * 模拟客户端： * 发送本地图片到服务器，并接受服务器发过来的确认消息，打印在控制台 * 可循环上传 * 多线程处理客服端的上传请求 */ @Test public void client() { Socket socket=null; FileInputStream fi=null; try { InetAddress inetAddress=InetAddress.getLocalHost(); socket=new Socket(inetAddress,8888); OutputStream so = socket.getOutputStream(); fi=new FileInputStream(new File("src/xn/socketTest/1.jpg")); byte[] bytes=new byte[1024]; int len; while ((len=fi.read(bytes))!=-1){ so.write(bytes,0,len); } socket.shutdownOutput(); InputStream si = socket.getInputStream(); byte[] bytes1=new byte[20]; int len1; while ((len1=si.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/980e5dc96f929afed361292f53da3db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed4fa4f516b921947061907507eed2f0/" rel="bookmark">
			Android 11中相册使用 PictureSelector:picture_libraryv2.5.8出现等待选择框不消失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android 11中相册使用
implementation com.github.LuckSiege.PictureSelector:picture_library:v2.5.8 出现等待弹框不消失如下图所示： 解决办法升级到
implementation com.github.LuckSiege.PictureSelector:picture_library:v2.6.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658f22abcb6afa1979371f1e76a438af/" rel="bookmark">
			3 Java 基础__不同数据类型之间的运算及进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本数据类型之间的运算规则： 这里只讨论七种数据类型间的运算，不包含Boolean类型。
自动类型转换:
范围由低到高：
byte 、char、 short --&gt; int --&gt; long --&gt; float --&gt; double
容量小的数据类型的变量和容量大的数据类型的变量一起运算，结果自动提升为容量大的数据类型。
特别的，当byte、short、char三种类型的变量做运算时结果为int类型（eg:short 和short做运算用int接受）。
强制类型转换：
/* 强制类型转换 1，需使用强转符（） 2，强制类型转换可能导致精度损失 */ class VariableTest2 { public static void main(String[] args) { double d1=12.9; int i1=(int)d1; //截断操作，只取整数部分 System.out.println(i1); } } 变量运算规则的两个特殊情况
编码情况一：
①情形一：（编译通过） class VariableTest2 { public static void main(String[] args) { long l=123213; //没有以 l结尾，竟然没有报错 System.out.println(l); } } 末尾少加l没有报错，原因是123213这个数默认是int型了，int型赋值给long型，属于自动类型转换。所以不报错。
②情形二：（编译不通过）
class VariableTest2 { public static void main(String[] args) { long l=123213; //没有以 l结尾，竟然没有报错 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658f22abcb6afa1979371f1e76a438af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18fa61849f2619eb84cd60de4faa556/" rel="bookmark">
			cpu、进程、线程、多线程的一个简单解释（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 dljd（linux） 1、线程：一种程序可有同时有多条执行线路在执行，线程是一个程序其中正在执行的一条执行线路；
说明：
线程就是一个程序的执行线路。我们写一段程序，你要让它执行，它总得有一个执行的线路。什么线路？就是你写的那段程序，由一行一行的代码组成，它从哪行代码开始执行，然后依次执行接下来的各行代码，最后到哪行代码结束程序，这就是线路，也叫线程。
当然，我们说一个程序可以“同时”开很多条不同执行的线路，哪怕开始的是同一行或同几行代码，中间也都可以“同时”分开成多条不同的执行线路，这就是多线程，多线程广义上强调的是“同时”。
2、进程：一个程序的执行，一个进程占用一个端口。
说明：
就是你写一段程序，这个程序肯定包含多行代码。我们整段程序启动运行时，肯定有很多执行线路（线程）同时运行着。这些同时的多条线路（多线程）的运行，合在一起就是一个进程的执行。比如说含有main()方法的一段程序，从main()方法开始运行就表示一个进程正在开始运行了。当然在main()方法的运行过程中，可以同时创建并执行很多条线路（线程）。但整体来看，这么多线路（线程）的运行，合在一起就是一个进程的运行。
那我们说进程最重要的一个标志是什么？标志是：一个进程的运行，那么这个进程会占用一个端口，即一个进程一般会占用一个端口。那一个线程的运行会不会占用一个端口？不会，因为线程是进程里边同时执行的一条线路。
那我们电脑上一般都会运行哪些进程呢？电脑上运行一个软件，其实就是运行一段程序。那程序的运行，就要有一个入口程序（如java程序的运行入口就是main()方法）。那么一个软件的入口程序被启动运行，那么就表明一个进程的运行，也就表明一个端口会被占用。我们电脑上，都会启动运行很多的软件，那么这些软件对应的程序都是进程，都会占用一个端口。比如mysql的入口程序一旦启动运行，那么电脑中就会启动一个mysql的进程，这个进程占用的端口是3306；比如tomcat的入口程序一旦启动运行，那么电脑中就会启动一个tomcat的进程，这个进程占用的端口是8080；
3、守护进程
服务的别名 —— 守护进程（就是守护linux正常运行的，为linux系统提供一些必要的支撑）。
服务是什么？服务本质上就是进程。进程是什么？就是一个程序的运行。也就是说，服务其实也是程序。那为什么不把服务和进程管理归为一块呢？因为服务和普通的进程还是有区别的。服务是支持Linux运行的一些必要程序，本质上也是进程，叫守护进程。守护进程通常默默地运行在后台，为应用程序提供必要支撑，比如sshd、防火墙等。
服务主要是linux后台使用的进程(程序），即守护进程，比如sshd、防火墙等。防火墙这个进程是linux后台使用的进程，做为linux后台的一个服务用的，为了支撑linux正常运行而启用的进程，程序员基本上不使用。守护进程一般不是前台用户使用的，是linux自己要使用的一些进程。sshd服务，是linux专门用来接收和处理外界发过来的远程连接请求用的；如果外界发送远程连接请求，并且linux的sshd服务接收到远程连接请求并建立连接以后，这时外界通过建立好的连接把linux命令发送到linux中，这时linux就会执行外界发送过来的这个命令，同时linux可以把命令的执行结果返回给外界请求者。
3、在window中对进程的管理
在任务管理器里面正在运行的进程（一个运行的程序，一段运行的代码）列表，如下图：
一个进程对应一个程序，一个程序对应一段代码。为什么说一个进程就是一个程序呢？从图中可以看出，一个进程大都对应一个Xxx.exe文件。Xxx.exe文件， 称为可执行程序。Xxx.exe文件怎么来的？都是开发好的程序，然后打包成Xxx.exe文件。我们一双击执行Xxx.exe文件，表明一个进程的运行，表明需要占用一个端口。
在windows的任务管理器中，我们可以对进程进行查看、结束等操作。
3、linux中对进程的管理
linux中也会有很多进程运行着，这些进程也都会占用端口，ps指令：
如上图所示，Linux中的bash进程是什么？bash进程其实就是命令行终端。命令行终端为什么一打开就是黑色的，命令行终端上为什么能敲命令；敲完命令后，为什么还可以执行；执行完命令后，还可以打印出东西来；等等这些问题，都bash进程给我们完成的，其实就是bash程序，底层对应一段代码。
还有ps这个进程，我们在终端输入ps命令并执行，后台也是对应一个进程》对应一个程序》对应一段代码。回顾一下我前面讲过“一个命令，后台都对应一个可执行文件.sh》对应一个程序》对应一个进程”。
二 转载 进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。
最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。
1.
计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。
2.
假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。
3.
进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。
4.
一个车间里，可以有很多工人。他们协同完成一个任务。
5.
线程就好比车间里的工人。一个进程可以包括多个线程。
6.
车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。
7.
可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。
8.
一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。
9.
还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。
10.
这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突。
不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。
11.
操作系统的设计，因此可以归结为三点：
（1）以多进程形式，允许多个任务同时运行；
（2）以多线程形式，允许单个任务分成不同的部分运行；
（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。
（完）
参考文献：阮一峰的网络日志 进程与线程的一个简单解释 进程与线程的一个简单解释 - 阮一峰的网络日志
什么是线程？
把一个进程比喻为一个车间，那么线程就是车间里面的一条条流水线。一个车间可以有多条流水线，流水线属于车间。一个车间的工作过程是一个进程，一个流水线的工作过程是一个线程。进程是操作系统资源分配的最小单位（生产科3号车间负责生产3万件包装纸箱），线程是cup调度的最小单位（3号车间里面的每一条生产线负责生产纸箱这个具体的任务）。
多线程的概念？
就是一个进程中存在多条线程。多线程是数据共享的（共享进程中的空间地址啥的），就是3号车间有多条流水线，都共用了一个车间的资源。
多线程的应用举例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e18fa61849f2619eb84cd60de4faa556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaff966c2885b2b5a2f197b114f6d3c9/" rel="bookmark">
			Etcd集群搭建报publish error: etcdserver: request timed out解决方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需要删除原集群下的所有成员
命令：
1.进入到保存到保存etcd集群的包：cd /var/lib/etcd
2.调用删除命令：rm -rf *
注：如果删不掉输入 pwd 就可以了
然后再启动就可以运行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5acf5b5182edf1c040c9ddc2d01dfb81/" rel="bookmark">
			二进制、八进制、十六进制之间的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、二进制转换成八进制 规则：从低位开始,将二进制数每三位一组，转成对应的八进制数即可。
案例：请将 ob11010101 转成八进制
ob11(3)010(2)101(5) =&gt; 0325
二、二进制转换成十六进制 规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。 案例：请将 ob11010101 转成十六进制 ob1101(D)0101(5) = 0xD5
三、八进制转换成二进制 规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。
案例：请将 0237 转成二进制
02(010)3(011)7(111) = 0b10011111
四、十六进制转换成二进制 规则：将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。
案例：请将 0x23B 转成二进制
0x2(0010)3(0011)B(1011) = 0b001000111011
五、进制介绍（补充） 对于整数，有四种表示方式：
二进制：0,1 ，满 2 进 1. 以 0b 或 0B 开头。
十进制：0-9 ，满 10 进 1。
八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。
十六进制：0-9 及 A(10)-F(15)，满 16 进 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5acf5b5182edf1c040c9ddc2d01dfb81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ace9cd142865a2341a0a95ed11c548cf/" rel="bookmark">
			线程创建方式的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种线程创建方式 继承 Thread 类重写 run 方法实现Runnable接口的run方法使用Callable和Future创建线程 继承 Thread 类重写 run 方法 线程创建方式创建过程优势劣势继承 Thread 类重写 run 方法1）创建实例，此时该线程未被启动执行。MyThread thread= new MyThread ();
2）调用该实例的start方法启动线程 thread .start();，达到就绪状态（已经获取了除CPU资源的其他资源），等待获取CPU资源才会处于运行状态。
3）run方法执行完毕，线程处于终止状态。1）run() 方法获取当前线程直接使用 this ，无需使用 Thread. currentThread() 方法。1）Java 不支持多继承，如果继承了 Thread 类， 那么就不能再继承其他类。
2）任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码，而 Runnable 则没有这个限制 。
3）任务没有返回值 实现 Runnable 接口 run 方法 线程创建方式创建过程优势劣势实现Runnable 接口 run 方法1）创建实例RunableTask task ＝new RunableTask ()，此时该线程未被启动执行。
2）使用创建的task对象作为任务创建了一个线程并启动它 new Thread(task) .start()1）可以 RunableTask 添加参数进行任务区分，达到不共用一个task逻辑
2）可以继承其他类1）任务没有返回值 使用Callable和Future创建线程 // 创建任务类 public stat class CallerTask implemets Callable&lt;返回类型&gt; { @Override public 返回类型 call() throws Exception{ return 返回类型值; } } // 具体使用： // 创建异步任务 FutureTask&lt;返回类型&gt; futureTask ＝new FutureTask&lt;&gt;(new CallerTask()) ; // 启动线程 new Thread(futureTask).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ace9cd142865a2341a0a95ed11c548cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5715b19d4b73d58d44ad8f2edf31e25c/" rel="bookmark">
			Linux 时间校正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 时间校正 问题描述解决过程检查是否是时区问题校正系统时间 问题描述 某次打开虚拟机，突然发现时间比实际时间快了8个小时。
解决过程 检查是否是时区问题 timedatectl 时区是东八区，没有问题。
校正系统时间 sudo ntpdate cn.pool.ntp.org 执行该命令后，系统时间就会被校正。
此时还要查看硬件时间，使用sudo clock --show可查看，如果硬件时间还是快8个小时，还需要让硬件时间根据系统时间同步（如果不同步，重启后系统时间还会快8个小时），执行命令sudo clock --systohc。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75caa868fcfbe6e576c13ffbc6843299/" rel="bookmark">
			@Validated 自定义注解校验请求参数符合枚举值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注解类：
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Constraint(validatedBy = {EnumValueValidator.class}) public @interface EnumValueCheck { /** * 错误消息 * @return 。 */ String message() default "枚举不合规范"; /** * 枚举列表 * @return 值 */ int[] existList() default {}; /** * 枚举值方法名称 * @return . */ String valueMethodName() default ""; /** * 枚举类 * @return 。 */ Class&lt;?&gt; enumClass() default Object.class; /** * 约束注解在验证时所属的组别 * @return . */ Class&lt;?&gt;[] groups() default {}; /** * 约束注解的有效负载 * @return .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75caa868fcfbe6e576c13ffbc6843299/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74805c370c958f383d83c747d06de194/" rel="bookmark">
			学习率调整之stepLR
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在PyTorch的torch.optim包提供了非常多的可实现参数自动优化的类（SGD、Adam..）及学习率调整的类lr_scheduler
class torch.optim.lr_scheduler.stepLR(optimizer, step_size,gamma=0.1,last_epoch=-1)
参数：
optimizer ---要更新学习率的优化器
step_size --- 每经step_size个epoch,更新一次学习率lr
gamma --- 更新lr的乘法因子
last_epoch --- 默认为-1表示从头开始训练
代码示例：
import torch.nn as nn
import torch.optim as optim
from torch.optim import lr_scheduler
from cnn_finetune import make_model
'''模型定义'''
model = make_model(model_name='vgg16', pretrained=True, num_classes=2,input_size= 224,224))
lr = 0.1
optimizer = optim.Adam(model.parameters(), lr=lr) # 用Adam优化算法更新权重
criterion = nn.CrossEntropyLoss() # 损失函数
scheduler = lr_scheduler.StepLR(optimizer, 8, gamma=0.1, last_epoch=-1)
for epoch in range(25):
optimizer.zero_grad()
optimizer.step()
print("第%d轮的学习率：%f"%(epoch, optimizer.param_groups[0]['lr']))
scheduler.step()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74805c370c958f383d83c747d06de194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506a2162e2657c7cf4570b151e29f698/" rel="bookmark">
			python---递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 递归函数：
函数在内部调用自身本身。
递归函数特性：
必须有一个明确的结束条件；
每次进入更深一层递归时，问题规模相比上次递归都应有所减少
相邻两次重复之间有紧密的联系，前一次要为后一次做准备
递归效率不高，递归层次过多会导致栈溢出(需注意)
# 递归遍历列表 list_test = ['a', 'b', ['aa', 'bb', ['aaa', 'bbb', 'ccc', ['aaaa', 'bbbb'], 'ddd'], 'cc', 'dd'], 'c', 'd'] def recurision_test(list_test): for list_i in list_test: # 使用isinstance判断是否为匹配的类型 ''' isinstance(param1, param2) param1: 需要判断的数据 param2: 是否为此类型 ''' if isinstance(list_i, list): recurision_test(list_i) else: print(list_i) if __name__ == '__main__': recurision_test(list_test) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f00097bb018998fc137ecc4ba571d62c/" rel="bookmark">
			智能优化算法（源码）-海鸥优化算法（SOA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取更多资讯，赶快关注上面的公众号吧！
文章目录 生物学泛型数学模型迁徙（探索）攻击（利用） 海鸥优化算法是印度学者Gaurav Dhiman于2018年提出的一种受生物启发的智能优化算法，该算法的主要灵感来自于自然界中海鸥的迁徙和攻击行为，这些行为经过数学建模和实现，可以在给定搜索空间中进行探索和利用。扫码关注公众号，后台回复“海鸥”或“SOA”可以获取Matlab代码。
生物学泛型 一般来说，海鸥是群居性的，它们用自己的智慧来寻找并攻击猎物。海鸥最重要的是它们的迁徙和攻击行为。迁徙被定义为海鸥从一个地方到另一个地方的季节性迁移，以寻找最丰富食物来源，以提供足够的能量。该行为可描述为：
在迁徙过程中，它们成群结队地迁徙。海鸥的初始位置不同，以避免相互碰撞；在一个群体中，海鸥可以朝着最适合生存的海鸥的方向前进；其他海鸥可以根据最适合的海鸥更新它们的初始位置。 海鸥在迁徙过程中，会经常攻击其他候鸟，在攻击过程中，它们可以做出螺旋形的自然运动，如图1所示。
数学模型 迁徙（探索） 在迁移过程中，海鸥优化算法模拟了海鸥群如何向一个位置移动到另一个位置。在这个阶段，海鸥应该满足三个条件:
避免碰撞：为了避免与邻居(即其他海鸥)的碰撞，引入了额外的变量 A A A,用于计算新搜索代理的位置，如图2所示：
C ⃗ s = A × P ⃗ s ( x ) (5) \vec{C}_{s}=A \times \vec{P}_{s}(x)\tag{5} C s​=A×P s​(x)(5)
其中， C ⃗ s \vec{C}_{s} C s​表示与其他搜索代理不发生碰撞的搜索代理的位置， P ⃗ s \vec{P}_{s} P s​表示搜索代理的当前位置， x x x表示当前迭代次数， A A A表示给定搜索空间中搜索代理的移动行为。
A = f c − ( x × ( f c / Max iteration ) ) (6) A=f_{c}-\left(x \times\left(f_{c} / \text { Max }_{\text {iteration }}\right)\right)\tag{6} A=fc​−(x×(fc​/ Max iteration ​))(6)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f00097bb018998fc137ecc4ba571d62c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23eace57bab79ab65eed3d10bcd873e3/" rel="bookmark">
			flink checkpoint配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果都设置了，则代码中会覆盖flink-conf.yaml中的配置
代码中设置 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
// 开启checkpoint 每5000ms 一次
env.enableCheckpointing(5000);
// 设置有且仅有一次模式 目前支持 EXACTLY_ONCE/AT_LEAST_ONCE env.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);
// 设置checkpoint的存储位置
env.getCheckpointConfig().setCheckpointStorage("hdfs:///flink/checkpoints");
// 设置savepoint的存储位置
env.setDefaultSavepointDirectory("hdfs:///flink/checkpoints");
// 设置checkpoint的超时时间 即一次checkpoint必须在该时间内完成 不然就丢弃
env.getCheckpointConfig().setCheckpointTimeout(600000);
// 设置两次checkpoint之间的最小时间间隔
env.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);
// 设置并发checkpoint的数目
env.getCheckpointConfig().setMaxConcurrentCheckpoints(1);
// 开启checkpoints的外部持久化 这里设置了 清除job时保留checkpoint
// 目前代码不能设置保留的checkpoint个数 默认值时保留一个 假如要保留3个
// 可以在flink-conf.yaml中配置 state.checkpoints.num-retained: 3
env.getCheckpointConfig().enableExternalizedCheckpoints(CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);
flink-conf.yaml中配置 execution.checkpointing.interval: 5000
execution.checkpointing.mode: EXACTLY_ONCE
state.backend: filesystem
state.checkpoints.dir: hdfs:///flink/checkpoints
state.savepoints.dir: hdfs:///flink/checkpoints
execution.checkpointing.timeout: 600000
execution.checkpointing.min-pause: 500
execution.checkpointing.max-concurrent-checkpoints: 1
state.checkpoints.num-retained: 3
execution.checkpointing.externalized-checkpoint-retention: RETAIN_ON_CANCELLATION
此处附上官网更多配置项：
https://nightlies.apache.org/flink/flink-docs-release-1.14/docs/deployment/config/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23eace57bab79ab65eed3d10bcd873e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c263e7cc6900fbbda05c87ba7c4696/" rel="bookmark">
			JS轮播图（左右箭头切换、按钮切换、自动轮播）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const LEFT = Symbol(), RIGHT = Symbol(), FINISH_TIME = 200; var arr = [ { date: "22/Feb.2022", title: "2021旅行记忆｜一起点亮这个世界的1%", src: "./img/a.jpg", }, { date: "21/Feb.2022", title: "我是周末种草官|天堂应是书店和图书馆的模样", src: "./img/b.jpg", }, { date: "20/Feb.2022", title: "【欧亚行迹】土耳其回忆录", src: "./img/c.jpg", }, { date: "19/Feb.2022", title: "我的2021年 | 心怀远方，热爱可抵岁月漫长", src: "./img/d.jpg", }, { date: "18/Feb.2022", title: "哈尔滨 | 有一场看雪的跨年仪式感", src: "./img/e.jpg", }, ]; var list = [], pos = 0, direction = LEFT, x = 0, bool = false, speed = 50, autoBool = false, //false表示鼠标还未离开 time = FINISH_TIME; var imgCon, carousel, prev; init(); function init() { carousel = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c263e7cc6900fbbda05c87ba7c4696/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/294/">«</a>
	<span class="pagination__item pagination__item--current">295/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/296/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>