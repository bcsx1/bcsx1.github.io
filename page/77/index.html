<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bef311fe85d7834d8237456cca066fb/" rel="bookmark">
			Flutter系列控件之动画Animation笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Flutter中有哪些类型的动画？如何使用动画库中的基础类给widget添加动画？如何为动画添加监听器？该什么时候使用AnimatedWidget与AnimatedBuilder?如何使用Hero动画？ 精心设计的动画会让用户界面感觉更直观、流畅，能改善用户体验。 Flutter的动画支持可以轻松实现各种动画类型。许多widget，特别是Material Design widgets， 都带有在其设计规范中定义的标准动画效果，但也可以自定义这些效果。
在Flutter中有哪些类型的动画？ 在Flutter中动画分为两类：基于tween或基于物理的。
补间(Tween)动画：在补间动画中，定义了开始点和结束点、时间线以及定义转换时间和速度的曲线。然后由框架计算如何从开始点过渡到结束点。基于物理的动画：在基于物理的动画中，运动被模拟为与真实世界的行为相似。例如，当你掷球时，它在何处落地，取决于抛球速度有多快、球有多重、距离地面有多远。 类似地，将连接在弹簧上的球落下（并弹起）与连接到绳子上的球放下的方式也是不同。 如何使用动画库中的基础类给widget添加动画？ 在为widget添加动画之前，先让我们认识下动画的几个朋友：
Animation：是Flutter动画库中的一个核心类，它生成指导动画的值；CurvedAnimation：Animation的一个子类，将过程抽象为一个非线性曲线；AnimationController：Animation的一个子类，用来管理Animation；Tween：在正在执行动画的对象所使用的数据范围之间生成值。例如，Tween可生成从红到蓝之间的色值，或者从0到255； Animation 在Flutter中，Animation对象本身和UI渲染没有任何关系。Animation是一个抽象类，它拥有其当前值和状态（完成或停止）。其中一个比较常用的Animation类是Animation&lt;double&gt;。
Flutter中的Animation对象是一个在一段时间内依次生成一个区间之间值的类。Animation对象的输出可以是线性的、曲线的、一个步进函数或者任何其他可以设计的映射。 根据Animation对象的控制方式，动画可以反向运行，甚至可以在中间切换方向。
Animation还可以生成除double之外的其他类型值，如：Animation&lt;Color&gt; 或 Animation&lt;Size&gt;；Animation对象有状态。可以通过访问其value属性获取动画的当前值；Animation对象本身和UI渲染没有任何关系； CurvedAnimation CurvedAnimation将动画过程定义为一个非线性曲线。
final CurvedAnimation curve = new CurvedAnimation(parent: controller, curve: Curves.easeIn); 注: Curves 类定义了许多常用的曲线，也可以创建自己的，例如：
class ShakeCurve extends Curve { @override double transform(double t) { return math.sin(t * math.PI * 2); } } AnimationController AnimationController是一个特殊的Animation对象，在屏幕刷新的每一帧，就会生成一个新的值。默认情况下，AnimationController在给定的时间段内会线性的生成从0.0到1.0的数字。 例如，下面代码创建一个Animation对象：
final AnimationController controller = new AnimationController( duration: const Duration(milliseconds: 2000), vsync: this); AnimationController派生自Animation&lt;double&gt;，因此可以在需要Animation对象的任何地方使用。 但是，AnimationController具有控制动画的其他方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bef311fe85d7834d8237456cca066fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7afd9e8177e46bbe4982b6a16c23017c/" rel="bookmark">
			Epoch和episodes的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Epoch” 和 “episode” 是两个不同的概念，通常在不同领域中使用。
Epoch（周期）：
Epoch 是一个在机器学习和深度学习中常用的术语，通常用于表示训练数据集中的一个完整遍历。在每个 epoch 中，整个训练数据集会被用来更新模型的权重，通常通过随机梯度下降或其他优化算法。一次 epoch 包含多次迭代，每次迭代使用数据集的一个不同子集（也可能是全部数据）来进行训练。Epoch 的数量通常是一个超参数，可以在训练过程中调整，以获得最佳的模型性能。 Episode（回合）：
Episode 通常出现在强化学习领域。它表示一次完整的任务尝试，其中代理（如一个机器学习智能体）与环境互动，执行一系列动作，直到达到任务的终止条件。在每个 episode 结束后，代理可以收集奖励信号和学习经验，以改善其策略。Episodic 强化学习通常适用于任务具有明确开始和结束点的情境，例如在游戏中走迷宫或完成特定任务。 总结来说，“epoch” 主要用于描述机器学习中的训练周期，而 “episode” 主要用于描述强化学习中的任务尝试。这两个概念在不同领域中具有不同的含义和用途。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8510653526865d6dd79e4a17956ff9/" rel="bookmark">
			Spring Security实现多种方式认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要提供两种示例的认证方式，之后如果还有其它需要认证的方式可以效仿
1、认证构成 主要把认证代码分成4部分：
1、token携带需要认证的信息
2、provider提供认证服务
3、config配置需要提供的认证服务
4、业务代码中的认证
2、第一种认证方式DaoAuthenticationProvider 用户名密码认证，这是由spring security提供的最常用的认证方式，我们主要只需要关注三个类UserDetails用户信息实体类，UserDetailService自定义实现类获取用户信息，PasswordEncoder根据用户密码加载用户信息的加密方法。
1、config配置 import org.springframework.context.annotation.Bean; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.dao.DaoAuthenticationProvider; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.web.servlet.config.annotation.EnableWebMvc; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import com.xyqq.app.user.impl.UserDetailsServiceImpl; @EnableWebSecurity @EnableWebMvc public class WebMvcConfig extends WebSecurityConfigurerAdapter implements WebMvcConfigurer { @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Bean @Override public UserDetailsService userDetailsService() { return new UserDetailsServiceImpl(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { DaoAuthenticationProvider daoAuthProvider = new DaoAuthenticationProvider(); daoAuthProvider.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8510653526865d6dd79e4a17956ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/938db45fd4d66a33eac43f4a9bb27171/" rel="bookmark">
			接口EMC设计（五）——电源接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、电源接口 电源接口毋庸置疑是每个产品的必备接口，是非常重要和必不可少的部分 。本文主要针对EMC部分进行说明，直流和交流端口设计大同小异，在不同应用场景下选择不同等级的器件满足试验要求。 二、电源接口电路结构 电源接口设计可能会影响的EMC问题有：雷击浪涌、干扰问题、辐射问题等，常见的要求有传导抗扰度试验、辐射试验、雷击浪涌试验、脉冲群试验等。
1） 接口可能带出单板内部的干扰，通过线缆形成对外辐射导致辐射发射测试超标；
2） 雷雨天气、插拔过程中产生的大能量浪涌或静电可能导致产品异常。
针对上述风险，我们设计电源接口防护电路拓扑结构如下。
1、电路设计分析 1） MOV1~MOV3为压敏电阻，由于压敏电阻通流量大，因此结电容比较大，用在交流电源口漏电流比较大，因此需要配合气体放电管GDT1~GDT2使用，延长器件使用寿命，并且防止失效着火风险；
2） C1、C3为Y电容，主要滤除共模干扰；C2为X电容，主要滤除差模干扰；与电感L1共同构成一级滤波电路，可根据测试等级需求，计算插损合理选择所需的滤波电路级数；
3）设备外壳为金属时，FG可靠连接到金属外壳上。 2、PCB布局要点 1）先防护，后滤波。根据电路插损要求选择一级或多级防护，第一级防护器件应在滤波器件之前，防止滤波器件在浪涌、防雷测试中损坏；
2） GDT、MOV、TVS管元器件要靠近板边或者连接器端，使瞬态电流回路所占空间以及其生成的阻抗尽可能的小；
3） 防护电路下方不走线，该区域干扰较大。 三、总结 接口EMC设计系列对常用的几个接口的EMC防护设计进行了简要说明，其实原理都是相通的，但是产品和应用场景是各异的，故器件参数选择也应根据实际测试来调整。该系列到此就告一段落，下一个系列再见~~~
码字不易，谢绝转载~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88fb44e2859c539fbb10e34c1f678431/" rel="bookmark">
			Linux系统部署MySQL（图文详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、卸载原有的MySQL 1.查看默认版本的mysql 如果没有，可跳过这个步骤 rpm -qa | grep mariadb 2.卸载 rpm -e --nodeps mariadb-libs 二、下载MySQL 1.官网下载需要的mysql包 这里小编就不做详细解释了，详细可参考：​​​​​​http://t.csdnimg.cn/rVo63
2.上传mysql 使用rz将mysql上传至指定目录
rz 3.解压 使用tar -xf 解压mysql包
tar -xf xxx 命令 包名 解压完成后查看目录
ll 4.安装软件包 使用rpm -ivh安装软件包
rpm -ivh xxx 命令 软件包名 小编这里在安装最后一个软件出现报错，在网上查找到解决方法，在后面添加--force --nodeps就安装成功了 参考文章：http://t.csdnimg.cn/rV1IW
--force --nodeps 5.下载工具软件 1.下载软件
yum install -y perl-Module-Install. noarch yum clean all yum makecache 2.安装net-tools
yum -y install net-tools 3.再次安装
yum install -y perl-Module-Install. noarch 6.删除原来的mysql日志数据 删除日志文件 cd /var/lib/mysql &amp;&amp; rm -rf .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88fb44e2859c539fbb10e34c1f678431/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd88cc70a219258f56d66deee582638/" rel="bookmark">
			【AI】深度学习——循环神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经元不仅接收其他神经元的信息，也能接收自身的信息。
循环神经网络（Recurrent Neural Network，RNN）是一类具有短期记忆能力的神经网络，可以更方便地建模长时间间隔的相关性
常用的参数学习可以为BPTT。当输入序列比较长时，其计算时间和空间要求随时间线性增长，可以使用带截断的BPTT，只计算固定时间间隔内的梯度回传
RNN可以近似任何非线性动力系统及图灵机，但会存在梯度爆炸和小时问题，也即长程依赖问题。从模型角度的改进，最有效改进方法为引入门控机制，如GNU和LSTM网络，也可以使用时钟循环神经网络、乘法RNN以及引入注意力机制
LSTM 网络是目前为止最成功的循环神经网络模型，通过引入线性连接来缓解长程依赖问题，成功应用在很多领域，如语音识别、机器翻译、语音模型以及文本生成。人们不断尝试对其进行改进来寻找最优结构，比如减少门的数量、提高并行能力等
LSTM的线性连接和门控机制能有效避免梯度消失问题，也运用于深层前馈网络中，如残差网络和告诉网络，都是引入线性训练非常深的卷积网络。对于循环网络，这种机制也可以运用于非时间维度上
RNN还可以轻易扩展为两种更广义的网络模型：递归神经网络和图网络
递归神经网络是一种在有向无环图上的简单的图网络，比较有名的图网络模型包括图卷积网络（Graph Convolutional Network，GCN），图注意力网络（Graph Attention Network，GAT）、消息传递神经网络（Message Passing Neural Network，MPNN）
文章目录 2.1 模型2.1.1 给网络增加记忆能力延时神经网络有外部输入的非线性自回归模型自回归模型(AR)有外部输入的非线性自回归模型 循环神经网络应用 2.1.2 简单循环网路SRN循环神经网络的计算能力循环神经网络的通用近似定理图灵完备 2.1.3 应用到机器学习序列到类别模式同步的序列到序列模式异步的序列到序列模式 2.2 学习2.2.1 参数学习随时间反向传播算法计算偏导数 ∂ L t ∂ u i j \frac{\partial \mathcal{L}_t}{\partial u_{ij}} ∂uij​∂Lt​​计算 ∂ L t ∂ U \frac{\partial \mathcal{L}_t}{\partial U} ∂U∂Lt​​参数梯度 实时循环学习算法BTPP&amp;RTRL 2.2.2 长程依赖问题 2.3 模型改进2.3.1 改进方案梯度爆炸梯度消失 2.3.2 基于门控的循环神经网络门控机制门控循环单元网络长短期记忆网络记忆参数更新LSTM网络的变体 2.4 扩展形式2.4.1 深层循环神经网络堆叠循环神经网络双向循环神经网络 2.4.2 扩展到图结构递归神经网络图神经网络 2.5 应用生成语言模型作词机机器翻译看图说话写字对话系统 2.1 模型 给神经网络增加记忆功能循环神经网络应用到机器学习 2.1.1 给网络增加记忆能力 为了处理时序数据，并利用其历史信息，需要让网络具有短期记忆能力
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd88cc70a219258f56d66deee582638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ce76f5c5b09265d038c598feadf5f0/" rel="bookmark">
			编程书籍目录(持续更新中)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录(持续更新中) 《C++Primer Plus》(第六版)
《C Primer Plus》(第五版)《鸟哥的Linux私房菜》《精通Oracle 10g PL/SQL编程》《UNIX环境高级编程》(第二版)《UNIX网络编程》《C和指针》《C专家编程》《Python 核心编程》(第二版）《Python 核心编程》(第三版）《编程珠玑》(第二版)《编译原理》(中文版)《C#网络编程技术教程》《DirectX 9.0 3D_游戏设计入门》《深入理解Java内存模型》《WCF揭秘》《深入理解计算机系统》（第二版）《深入理解C++11》《C#设计模式》《C#图解教程》《Linux窗口程序设计 Qt4精彩实例分析》《零基础学SQL》《Python编程:从入门到实践》《算法设计技巧与分析》(阿苏外耶)《Visual C#.NET 网络核心编程》《C#入门经典》(第5版）《C#高级编程》(第7版)《C#与.NET4高级程序设计》(第5版)《Linux高性能服务器编程》《Linux内核设计与实现》(第三版)《Python程序设计基础》《Python网络编程基础》《Python基础教程》(第二版）《Python开发技术详解》《Python编程金典》《Python学习手册》(第4版)《Python3程序开发指南》(第二版)《Python自动化运维:技术与最佳实践》《Python性能分析与优化》《Python程序员指南》《Unix编程艺术》《Go语言实战》《OpenGL游戏编程》《泛型编程与STL》《梦断代码》《大话数据结构》(中文版)《Python深度学习》《深入Linux内核架构》(中文版)《树莓派Python编程入门与实战》《C程序设计语言》(第2版. 新版)《计算机网络》(第四版)《计算机程序设计艺术》《轻量级Django》《算法导论》(第二版)《算法与数据结构》(谢柏青)《C#软件项目开发全程剖析》《C#字符串和正则表达式参考手册》‍《GNU/Linux编程指南》(第二版)《Hadoop技术内幕：深入解析YARN架构设计与实现原理》《WCF服务编程》(中文版)《WPF编程宝典》《算法概论》《C#COM+编程指南》《C大学教程》(第五版)《Python高级编程》《SQL基础教程》(第3版)《精通正则表达式》(第三版)《图解TCP/IP》(第5版)《MySQL核心技术手册》(第二版)《ASP.NET开发实战宝典》《C++ GUI Qt 4编程》(第二版)《Python生物信息学数据管理》《C++/Qt设计模式》(第2版)《Qt Creator快速入门》《QT高级编程》《Qt及Qt Quick开发实战精解》《Qt中的C++技术》《深度学习入门:基于Python的理论与实现》《Hadoop权威指南》(第三版）《PyQt5快速开发与实战》《Python自然语言处理》《TCP-IP协议族》(第四版)《Python编程》(第4版全)《Web开发新体验_ASP.NET.3.5.MVC架构与实战》《POSIX多线程程序设计》(中文版)《父与子的编程之旅：与小卡特一起学Python》《SQL SERVER2005数据库基础及应用技术教程与实训》《Windows应用高级编程—C#编程篇》《C程序设计语言》(中文版)《ASP.NET网站设计实例通》《程序员实用算法》《C 程序设计教程》( 第二版)《《数据结构》算法实现及解析》《Hadoop权威指南》(第二版）《算法设计手册》(第2版)( 英文版)《解析极限编程：拥抱变化》(第2版)《Java RESTful Web Service实战》《圈圈教你玩USB》《GNU+make中文手册》《Flask Web开发：基于Python的Web应用开发实战》《Microsoft Visual C# 2010 Step by Step》《C++ Concurrency In Action》《像程序员一样思考》《数字逻辑与计算机设计基础》 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea669e61cbe9ff38fb4e42b49b324a3/" rel="bookmark">
			开源ESP32智能小车机械臂控制板Baize_Carboard(支持mixly)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 采用esp32做主控的Baize_Carboard，支持4路直流电机或者两路步进电机的控制，也可以用于控制两路直流闭环电机。输入电压范围5-12V，有时候电压5V起不来，要高一点。可以用于学习arduino或者ros编程，同时也可以将ros于arduino结合。
资料下载 最新代码在这里：GitHub - Allen953/BaizeCarboard: a pcb board for ros smart car
程序源码 首先打开3.Software这个文件夹，找到如下路径，可以看到有两个程序例程，一个是控制板子上的led灯的，一个是控制步进电机的。
3D模型 3D模型如下
充电芯片CS5090E芯片手册http://www.szczkjgs.com/UploadFiles/fujian/3834/CS5090.pdf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5896ee857c6d3df419f57615ca3de6/" rel="bookmark">
			Cannot use ‘**‘ (type any) as the type string
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 场景再现 addr := viper.Get("redis.addr") password := viper.Get("redis.password") db := viper.Get("redis.db") RedisCache = redis.NewClient(&amp;redis.Options{ Addr: addr, // Cannot use 'addr' (type any) as the type string Password: "", DB: 0, }) 2. 原因分析 类型不正确
3. 解决办法 转成对应的类型即可
.(string) .(int) addr := viper.Get("redis.addr") password := viper.Get("redis.password") db := viper.Get("redis.db") RedisCache = redis.NewClient(&amp;redis.Options{ Addr: addr.(string), Password: password.(string), DB: db.(int), }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d6bbfad3708271be48aaa9631c4e21f/" rel="bookmark">
			windows 10LTSC安装微软应用商店（理论上适用于所有windows10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LTSC-Add-MicrosoftStore-2019.zip官方版下载丨最新版下载丨绿色版下载丨APP下载-123云盘123云盘为您提供LTSC-Add-MicrosoftStore-2019.zip最新版正式版官方版绿色版下载,LTSC-Add-MicrosoftStore-2019.zip安卓版手机版apk免费下载安装到手机,支持电脑端一键快捷安装https://www.123pan.com/s/hcAqVv-luHWd.html提取码:Jyfx
下载后解压
右键以管理员身份运行Add-Store.cmd
等待完成即可
安装完成后打开商店更新即可正常使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e15bc1b49492d57187e96fce9c8a345/" rel="bookmark">
			Docker容器与虚拟化技术：DaoCloud账户注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、实验
1.DaoCloud
一、实验 1.DaoCloud （1）概念
DaoCloud是企业级容器云平台，它提供了一套容器集群解决方案，Daocloud可以管理你的计算资源，包括物理机和公有云环境，你可以在DaoCloud平台上部署并管理所有的 Docker 应用。 DaoCloud平台的特点是标准化、企业级和开放性。
（2）官网
https://www.daocloud.io/
（3）注册
http://account.daocloud.io/signin
(4) 进入注册页面填写
（5） 也可以与其他已有账户进行关联
（6）完成注册后登录
（7）启动加速器（右上角）
（8）执行其提示的命令
该命令会从DaoCloud下载一个脚本，并将配置写入/etc/docker/daemon.json中（其实就是把registry-mirrors改成了DaoCloud自己的镜像源）。
命令如下，选择适合自己系统的版本,然后Copy（复制）
vim /etc/docker/daemon.json { "registry-mirrors": ["http://你的编号.m.daocloud.io"] } （9）重启docker服务
systemctl restart docker.service 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90deb63eec310e56e082265a51c1fbc7/" rel="bookmark">
			oppo A57刷机包更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ozip转zip方便把官网下载的ozip包转换为可刷机的zip
sdat2img-master方便发烧友制作system.img详情请看redmi.txt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f24ac890e6070a1eeda7dd1f15e3df/" rel="bookmark">
			C&#43;&#43;---类型转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中的类型转换 在学习C语言的时候，如果赋值运算符左右两边的类型不同。或者在调用函数的时候，形参和实参类型不匹配，或者返回值类型与接收返回值类型不一致的时候，就需要发生类型转换。
C语言中总共有两种类型转换方式：隐式类型转换和显式类型转换。
隐式类型转换：编译器在编译阶段自动进行，能转就转，不能转就报错。显式类型转换：需要自己处理 void Test () { int i = 1; // 隐式类型转换 double d = i; printf("%d, %.2f\n" , i, d); int* p = &amp;i; // 显示的强制类型转换 int address = (int) p; printf("%x, %d\n" , p, address); } C++的类型转换 C++兼容C语言，C语言中的类型转换放到C++中也可以使用，并且C++提出了自己的类型转换风格。
cast-name&lt;type&gt;(expression) type是要转换的目标类型，expression是要转换的值。
C++强制类型转换 标准C++为了加强类型转换的可视性，引入了四种命名的强制类型转换操作符。
static_cast、reinterpret_cast、const_cast、dynamic_cast static_cast 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可用static_cast，但它不能用于两个不相关的类型进行转换。
int main() { double d = 12.34; int a = static_cast&lt;int&gt;(d); cout &lt;&lt; a &lt;&lt; endl; return 0; } reinterpret_cast reinterpret_cast操作符通常为操作数的位模式提供较低层次的重新解释，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3f24ac890e6070a1eeda7dd1f15e3df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b5a22ca84f5e9d72736255b3b20a44/" rel="bookmark">
			机器学习——学习路线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Pytorch Pytorch安装Pytorch基础Pytorch项目实践 二、机器学习 1、监督学习 线性回归 均方差损失推导梯度下降法归一化正则化Lasso回归&amp;岭回归多项式回归 线性分类 逻辑回归多标签分类交叉熵损失Softmax回归SVM支持向量机 决策树 剪枝与后剪枝随机森林AdaboostGBDTXGBoost 2、无监督学习 降维 PCA主成分分析SVD奇异值分解LDA线性判断分析 聚类 KMeans聚类与变量密度聚类层次聚类图聚类GMM高斯混合模型 3、概率图模型 朴素贝叶斯HMM隐含马尔可夫模型最大熵模型最大熵马尔可夫模型CRF条件随机场 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbaf07fb20dc549e8c7fc3a19851d054/" rel="bookmark">
			手把手教你用Python绘制神经网络图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接下来教大家如何使用 Python 中的 networkx 库，绘制美观且标准的神经网络。会根据指定的层和节点数量，绘制不同结构的神经网络。 networkx 库可以用来创建和操作图类型的数据结构，其中包括无向图、有向图、带权图等等。
神经网络可以看做是一种图数据结构，因此可以使用networkx库创建，并进行可视化的操作。
简单示例：绘制一个2层的神经网络 首先，需提前安装好networkx库，然后在代码中导入 networkx 和 matplotlib。然后使用 DiGraph 创建一个有向图G。
我们要绘制的网络，包括了5个节点，第1层的节点编号为1、2，第2层的是3、4、5，我们使用add_edge，从1向3、4、5，从2向3、4、5，连接一条边。
为了让绘制的图像看起来像一个神经网络，我们需要为这5个节点设置坐标。创建字典pos，字典的key是节点的名称，字典的value，是节点所在位置。
最后使用nx.draw函数进行绘制。
其中G是要绘制的图，
pos是图中节点的坐标，
with_labels = True，代表绘制节点的名称
node_color和edgecolor是节点和边的颜色
linewidths和width是节点和边的粗细
node_size是节点的大小
# 在代码中导入networkx 和 matplotlib import networkx as nx import matplotlib.pyplot as plt G = nx.DiGraph() # 使用DiGraph创建一个有向图G # 网络包括了5个节点 # 第一层的节点编号为1、2，第2层的是3、4、5 G.add_edge(1, 3) # 从1到3 G.add_edge(1, 4) # 从1到4 G.add_edge(1, 5) # 从1到5 G.add_edge(2, 3) # 从2到3 G.add_edge(2, 4) # 从2到4 G.add_edge(2, 5) # 从2到5 # 创建字典pos，字典的key是节点的名称 # 字典的value，是节点所在位置 # 1号和2号节点在一列 # 3、4、5在一列 # 因此设置1和2的x坐标为0；3、4、5的为1 # 同一组中的节点，可以均匀的分布在同一列上 # 所以我们将1和2的y坐标，设置为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbaf07fb20dc549e8c7fc3a19851d054/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452ba835a70777b78d97044f879c3d67/" rel="bookmark">
			fastjson的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NID: 412B-A1L1-UTILS
Title: fastjson的使用
Tags: #fastjson #json #alibaba #文档
原类型目标类型方法序列化Object 任意Java对象StringString str = JSON.toJSONString(Object data);Object 任意Java对象byte[]byte[] bytes = JSON.toJSONBytes(Object data);反序列化String具体Java对象目标类 targetObj = JSON.parseObject(String jsonStr,目标类.class)StringJSONObjectJSONObject jsonObj = JSON.parseObject(String jsonStr);byte[]JSONObjectJSONObject jsonObj = JSON.parseObject(byte[] bytes);JSONObject具体Java对象jsonObj.toJavaObject(目标类.class)JSONObject具体Java对象jsonObj.getObject(“属性名”,目标类.class);JSONObjectListList&lt;目标类&gt; list = jsonObject.getObject(“属性名”,new TypeReference&lt;List&lt;目标类&gt;&gt;(){});StringJSONArrayJSONArray jsonArray = JSON.parseArray(String jsonStr);JSONArray具体Java对象目标类 targetObj = jsonArray.getObject(index, 目标类.class);JSONArrayListList&lt;目标类&gt; list = jsonArray…toJavaList(目标类.class); 0.fastjson介绍 fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean
FASTJSON v2是FASTJSON项目的重要升级，目标是为下一个十年提供一个高性能的JSON库。通过同一套API
和FASTJSON 1相比，性能有非常大的提升，解决了autoType功能因为兼容和白名单的安全性问题支持JSON/JSONB两种协议，JSONPath 是一等公民。支持全量解析和部分解析。支持Java服务端、客户端Android、大数据场景。支持Kotlin支持JSON Schema https://alibaba.github.io/fastjson2/json_schema_cn支持Android支持Graal Native-Image 相关文档查看本文引用
1.导入依赖: 按需选择以下的一种
1.普通 在fastjson v2中，groupId和1.x不一样，是com.alibaba.fastjson2：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt; &lt;artifactId&gt;fastjson2&lt;/artifactId&gt; &lt;version&gt;2.0.41&lt;/version&gt; &lt;/dependency&gt; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452ba835a70777b78d97044f879c3d67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad095d93fd944ea0b4cad141727e500/" rel="bookmark">
			python特别篇—github基本操作手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开始使用 1.1 “Hello world” 1.1.1 github介绍 GitHub是一个基于Git版本控制系统的代码托管平台。它提供了一个在线的代码仓库，使开发者可以将自己的代码存储在云端，并与其他开发者进行协作。GitHub不仅仅是一个代码托管平台，还提供了许多其他功能，如问题跟踪、项目管理、代码审查、持续集成等。开发者可以通过GitHub分享自己的开源项目，也可以在上面找到其他人的开源项目并参与贡献。
GitHub入门需要了解的操作：
创建和使用存储库启动和管理新分支对文件进行更改并将其作为提交推送到 GitHub打开并合并拉取请求 1.1.2 创建存储库 存储库通常用于组织单个项目。存储库可以包含文件夹和文件、图像、视频、电子表格和数据集 - 您的项目需要的任何内容。通常，存储库包括一个自述文件，一个包含有关项目信息的文件。
点击主页上的“+”号：
选择New repository表示创建一个新的仓库。选择“Import repository”表示引入一个外部版本控制系统中的代码库完整地迁移到GitHub上，并保留其完整的历史记录。 1.1.3 创建分支 GitHub的分支是用于在项目中独立开发和管理不同功能或修复的副本。它允许团队成员在不影响主分支（通常是master分支）的情况下并行工作，并在完成后将更改合并回主分支。
以下是关于GitHub分支的一些重要概念和操作：
主分支（master分支）：主分支是项目的默认分支，通常用于发布稳定的版本。在主分支上进行的更改会直接影响项目的稳定性。
创建分支：您可以通过在项目页面上点击 "Branch: master" 按钮并输入新分支的名称来创建一个新分支。这将创建一个基于主分支的副本，您可以在该分支上独立进行开发。
切换分支：您可以通过在项目页面上点击 "Branch: master" 按钮并选择要切换的分支来切换到不同的分支。这将切换您的工作目录以查看和编辑特定分支的文件。
合并分支：一旦您在分支上完成了更改，您可以将其合并回主分支或其他分支。您可以使用 "Pull Request" 功能创建一个请求，请求将您的更改合并到目标分支中。项目的其他成员可以审查您的更改并提供反馈。
解决冲突：当多个分支对同一文件进行了不同的更改时，会发生冲突。在合并分支时，如果存在冲突，您需要解决这些冲突才能成功合并。您可以手动编辑文件以解决冲突，或者使用合并工具来自动解决冲突。
删除分支：一旦分支的工作完成，您可以删除它。在分支页面上，点击 "Delete branch" 按钮即可删除分支。请注意，删除分支后，分支上的更改将无法恢复。
分支是GitHub中重要的协作和版本控制工具，它使团队成员能够独立工作并将更改有序地合并到项目中。
操作方法：
打开要创建分支的项目页面。点击页面右上角的 "Branch: master" 按钮，这将打开一个下拉菜单。在下拉菜单中输入新分支的名称，并点击 "Create branch" 按钮。这样就已经创建了一个新分支。可以在新分支上进行更改，而不会影响主分支。 1.2 Git工具 1.2.1 git介绍 Git是一个分布式版本控制系统，最初由Linus Torvalds开发，用于管理和追踪文件的变化。它可以记录文件的修改历史，并且可以轻松地在不同的分支之间切换。
Git的主要特点包括：
分布式：每个开发者都可以拥有自己的本地代码仓库，可以在本地进行开发和提交，而不需要依赖中央服务器。这样可以提高开发效率，并且即使服务器出现故障，代码也不会丢失。
高效性能：Git的设计目标是快速和高效。它使用了一种称为“快照”的方式来存储文件的变化，而不是每次都保存完整的文件副本。这样可以减少存储空间的占用，并且在处理大型项目时也可以提高速度。
强大的分支管理：Git具有强大的分支管理功能，可以轻松地创建、合并和删除分支。这使得团队成员可以并行开发不同的功能，而不会相互干扰。
完整的历史记录：Git会记录每次提交的详细信息，包括修改的文件、修改的内容以及提交者的信息。这样可以方便地追踪和回溯代码的变化，以及查找问题的根源。
支持多种协作方式：Git支持多种协作方式，包括基于SSH的远程仓库、基于HTTP协议的远程仓库以及通过电子邮件进行的协作。这使得开发者可以根据自己的需求选择适合的方式进行协作。
1.2.2 git使用 git工作流：
使用git的方式：
命令行GUI界面（可以直接在官网下载） IDE插件（拓展） 命令行工具 （因为涉及到隐私信息，就没有界面的截图了）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad095d93fd944ea0b4cad141727e500/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66de92bd7e49567fe02ec458f72fffd2/" rel="bookmark">
			CentOS7 k3s安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 官方文档 https://docs.k3s.io/zh/quick-start
1 安装 curl -sfL https://get.k3s.io | sh - # 或 curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh - INSTALL_K3S_VERSION：安装指定版本
curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | INSTALL_K3S_VERSION=v1.26.9+k3s1 sh - 2 命令行支持tab自动补全 echo 'source &lt;(kubectl completion bash)' &gt;&gt; ~/.bashrc 断开连接，再次连接，即可生效
如果报错：-bash: _get_comp_words_by_ref: command not found
安装bash-completion：
yum -y install bash-completion source /usr/share/bash-completion/bash_completion 3 验证 部署一个 nginx 进行测试
#部署nginx kubectl create deployment nginx --image=nginx:1.18-alpine #暴露端口 kubectl expose deployment nginx --port=80 --type=NodePort kubectl get pod,svc 防火墙放行对应端口即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66de92bd7e49567fe02ec458f72fffd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c69836e48a58bf3e9e76b8c838480c7/" rel="bookmark">
			【CTF笔记】初识 ZIP 伪加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本博文以两道题目为例，浅谈关于zip伪加密的一些内容。
题一： 从网站中下载下来一个ee2f7f26-5173-4e7a-8ea4-e4945e6f04ff.zip压缩包文件，根据题目提示，这是个zip伪加密，因此有以下两种做法，
法一： 将压缩包通过QQ发给好友，再用手机打开查看，不一定每次都行
法二： 先来了解一下zip的组成 一个 ZIP 文件由三个部分组成： 压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志
a.压缩源文件数据区： 50 4B 03 04：这是头文件标记（0x04034b50） 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密，奇数加密，偶数无加密） 08 00：压缩方式 5A 7E：最后修改文件时间 F7 46：最后修改文件日期 16 B5 80 14：CRC-32校验（1480B516） 19 00 00 00：压缩后尺寸（25） 17 00 00 00：未压缩尺寸（23） 07 00：文件名长度 00 00：扩展记录长度 6B65792E7478740BCECC750E71ABCE48CDC9C95728CECC2DC849AD284DAD0500
b.压缩源文件目录区: 50 4B 01 02：目录中文件文件头标记(0x02014b50) 3F 00：压缩使用的 pkware 版本 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密，奇数加密，偶数无加密） 08 00：压缩方式 5A 7E：最后修改文件时间 F7 46：最后修改文件日期 16 B5 80 14：CRC-32校验（1480B516） 19 00 00 00：压缩后尺寸（25） 17 00 00 00：未压缩尺寸（23） 07 00：文件名长度 24 00：扩展字段长度 00 00：文件注释长度 00 00：磁盘开始号 00 00：内部文件属性 20 00 00 00：外部文件属性 00 00 00 00：局部头部偏移量 6B65792E7478740A00200000000000010018006558F04A1CC5D001BDEBDD3B1CC5D001BDEBDD3B1CC5D001
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c69836e48a58bf3e9e76b8c838480c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b340f342ceb364c0f8cd5fdbd9ba07e/" rel="bookmark">
			App门户页面设计与开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.作业目标
2.技术说明
activity
xml
fragment
recycleview
3.关键代码解析
1.顶部top.xml
2.底端bottom.xml
3.中间内容四个fragment
4.activity_main1.xml
4.最终结果
5.实验小结 6.全部代码
1.作业目标 根据课程内容设计一个App的门户框架，需要实现3-4个tab切换效果，在任一tab页中实现列表效果
2.技术说明 activity Activity 是一个应用组件，用户可与其提供的屏幕进行交互，以执行拨打电话、拍摄照片、发送电子邮件或查看地图等操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上。
xml XML 代表可扩展标记语言。XML 是一种非常流行的格式，通常用于在 Internet 上共享数据。
fragment Fragment表示应用界面中可重复使用的一部分。fragment 定义和管理自己的布局，具有自己的生命周期，并且可以处理自己的输入事件。fragment 不能独立存在。它们必须由 activity 或其他 fragment 托管。fragment 的视图层次结构会成为宿主的视图层次结构的一部分，或附加到宿主的视图层次结构。
recycleview RecyclerView是Android 5.0推出的，是support-v7包中的新组件,它被用来代替ListView和GridView，并且能够实现瀑布流的布局，更加高级并且更加灵活，提供更为高效的回收复用机制，同时实现管理与视图的解耦合。
3.关键代码解析 1.顶部top.xml &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:id="@+id/textView1" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="#000000" android:text="微信" android:textAlignment="center" android:textColor="@color/white" android:textSize="34sp" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/LinearLayout&gt; 将LinearLayout的高设置为wrap_content，表示适配内容长度，防止遮挡页面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b340f342ceb364c0f8cd5fdbd9ba07e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f5073b8a3f7c11f768df7c3a285760/" rel="bookmark">
			Android 开发之颜色的透明度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 之前在Android 开发中经常会使用到颜色的透明度，但是自己经常记不住，所以这边我通过其他人的描述自己记录一下。
Android 如果想要在color.xml 中显色不同颜色的透明度我们一般会在颜色的前面加上它的透明度，如 #80FFFFF 标色为 50%透明的白色。透明度的颜色如下所示。
透明度百分比16进制值0%FF1%FC2%FA3%F74%F55%F26%F07%ED8%EB9%E810%E611%E312%E013%DE14%DB15%D916%D617%D418%D119%CF20%CC21%C922%C723%C424%C225%BF26%BD27%BA28%B829%B530%B331%B032%AD33%AB34%A835%A636%A337%A138%9E39%9C40%9941%9642%9443%9144%8F45%8C46%8A47%8748%8549%8250%8051%7D52%7A53%7854%7555%7356%7057%6E58%6B59%6960%6661%6362%6163%5E64%5C65%5966%5767%5468%5269%4F70%4D71%4A72%4773%4574%4275%4076%3D77%3B78%3879%3680%3381%3082%2E83%2B84%2985%2686%2487%2188%1E89%1C90%1A91%1792%1493%1294%0F95%0D96%0A97%798%599%3100%0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf074455c5f0c75b20949f1bc61f00ee/" rel="bookmark">
			经典算法-----八皇后问题（回溯算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
八皇后问题
1.问题简介
1.2思路剖析
1.3递归和回溯
代码实现
​编辑
1.递归回溯解决
能否放置数组
完整代码：
2.非递归回溯解决
前言 今天我们学习一个新的算法，也就是回溯算法，就以八皇后问题作为示例，这是一个非常有意思的问题，下面就一起来看看吧。
八皇后问题 1.问题简介 八皇后问题（英文：Eight queens），是由国际象棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。
问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。
高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。计算机发明后，有多种计算机语言可以编程解决此问题。
看完这个问题描述之后，看上去好像很简单的样子，不就是去摆放棋子嘛，但是当你用编程去写的话就是另外一码事了，压根就不知道从哪里下手。 1.2思路剖析 还记得在此之前我发布了一个关于迷宫问题的解法吗？（链接：经典算法-----迷宫问题（栈的应用）-CSDN博客）对于迷宫问题是利用栈的回溯算法解决的，当走到死路的时候就往回走，回到上一个位置换一个方向来走，那摆放皇后也是一样的，当下一个无法摆放的时候，那就回到上一个，然后重新摆放上一个皇后再去看看下一个能不能摆放，如果还是不能摆放的话，那就回到上上一个，直到回到第一个皇后，全部重新摆放……
1.3递归和回溯 递归
对于递归算法，我觉得掌握递归是入门数据结构与算法的关键，因为后面学习很多操作涉及到递归，例如链表的一些操作、树的遍历和一些操作、图的dfs、快排、归并排序等等。
而递归的主要特点如下：
自己调用自己递归通常不在意具体操作，只关心初始条件和上下层的变化关系。递归函数需要有临界停止点，即递归不能无限制的执行下去。通常这个点为必须经过的一个数。递归可以被栈替代。有些递归可以优化。比如遇到重复性的可以借助空间内存记录而减少递归的次数 回溯 算法界中，有五大常用算法：贪心算法、分治算法、动态规划算法、回溯算法、分支界限算法。回溯算法是五大算法之一，虽然有时候复杂度回挺高的，但是回溯算法可以简化去解决很多问题，就向处理套娃问题一样，如果让人去想那就太费脑子了，如果直接去通过递归回溯那计算机回很快解决出来。前面说到的递归，本身来看好像跟八皇后问题的解决没有太大的关系，但是加上回溯就是不一样啦。下面看代码分析吧 代码实现 既然都知道了解决算法思路，那我也不装了，直接上代码！！！！！！
1.递归回溯解决 能否放置数组 问题来了，怎么去看这个位置能不能放皇后呢？这里就需要几个标致数组去解决，如下所示：
#define num 8 //定义皇后的数量 int* place = (int*)malloc(sizeof(int) * num);//这个表示是放置皇后的标志 int* y_flag = (int*)malloc(sizeof(int) * num);//这个数组是表示放了皇后之后此时的纵列是能否可以放皇后的标志 int* d1 = (int*)malloc(sizeof(int) * (2 * num - 1));//这个是表示放皇后之后的上对角线能否放的标志 int* d2 = (int*)malloc(sizeof(int) * (2 * num - 1));//这个是表示放皇后后下对角线能否放皇后的标志 //以上的标志数组，其中1表示可以放，0表示不可以放 对于上对角线d1，我们可以去通过这个位置的行位置（第n行）来减掉当前的纵位置（第col列），得到的结果如下图所示，问题来了，我数组的下标不可以是负数呀，所以我们可以在这个前提下加上当前的棋盘长度（长度为num），公式为：n-col+num，最后得到的结果就是下标为0~14的数组啦。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf074455c5f0c75b20949f1bc61f00ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a7db31aebed33ce6ff9255eb865e6a/" rel="bookmark">
			SQL Server 创建表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		切换数据库，判断是否存在 --切换数据库 use DBTEST --判断表是否存在 --创建的所有表都可以在sys.boject中找到，所以这里在sys.objects中查找是否有名字为department的表并且type为U 即用户生成的表 if exists(select * from sys.objects where name='department'and type='U') drop table department; sys.objects中保存了所有表的各种信息，其中name字段保存的表名，type保存的对象类型；具体字段信息请看☞sys.objects (Transact-SQL)
创建部门表 --部门表 create table department ( --部门编号，主键用于唯一标识不同的数据的 --identity定义自增起点和自增步长 DepartmentId int primary key identity(1,1), --部门名字 --varchar 代表字符型，长度为50 DepartmentName nvarchar(50), --部门描述 --描述可能会比较长，这里使用text DepartmentRemark text ) primary key: 表示的主键，主键可以唯一地辨别事物的属性。通过主键能够查询出表中一条完整的记录，同时使用主键能防止表中出现重复的记录，避免了数据的冗余。identity（1,1）：定义了自增的起点和步长，这里从1开始自增，步长为1，即下一个为2 在创建DepartmentName时，使用的nvarchar,简单说下char、varchar、nvarchar的区别
char: char(10)可以存储十个字节，无论里面存储的数据是否有十个字节都会占用十个字节varchar: varchar(10)最多占用十个字节,如果里面存储2个字节则占用2个字节，最多存放十个字节nvarchar: char varchar text都可以加一个n,代表unicode，表示对中文友好；例如：varchar(100),可以存储100个字母或者50个汉字
nvarchar(100),可以存储100个字母或者100个汉字 当文本较长，如几千字节时可以使用text
创建职级表 --建职级表 create table [Rank]`在这里插入代码片` ( RankId int primary key identity(1,1), RankName nvarchar(50) not null, RankRemark text ) 当想要创建的表名是关键字，可以使用‘[] ’扩起来 创建员工表 --员工表 create table people ( PeopleId int primary key identity(1,1),--员工工号 DepartmentID int references department(DepartmentId),--部门编号 RankID int references [Rank](RankId),--员工职级 PeopleName nvarchar(50) not null,--员工姓名 PeopleSex nvarchar(1)default('男') check (PeopleSex='男'or PeopleSex='女'),--员工性别 PeopleBirth smalldatetime not null,--员工生日 PeopleSalary decimal(12,2) check(PeopleSalary &gt;=1000 and PeopleSalary &lt;=10000000),--员工薪水 PeoplePhone varchar(20) not null,--员工电话号码（唯一） PeopleAddress varchar(300), PeopleAddTime smalldatetime default(getdate())--自动记录当前时间 ) DepaermentID和RankID：使用了References 写外键关系，当添加员工的部门信息的时候，只能填写已经存在的部门，使用外来键对DepartmentID进行约束PeopleSex：限制只能输入(男/女) 其他的输入不进去，使用check进行约束，使用default默认设置为‘男’PeopleSalary: sql server中有float但是没有double；这里使用decimal（12,2）去约束PeopleSalary12代表总长度，2代表小数点后两位，使用check对薪水范围进行约束，这里限制在[1000,10000000]PeoplePhone :电话号码是唯一的， 使用Unique(独特的、唯一的) 进行约束PeopleAddTime： 添加此员工信息的时间，这里使用getdate()去自动获取当前的时间 date、datetime、smalldatetime的区别 date :存储年月日，存储范围是从1月1日(0001-01-01)到12月31日(9999-12-31)存储格式为YYYY-MM-DD。datetime 可以存储年月日时分秒;存储范围从1753年1月1日到9999年12月31日，精确到毫秒级,存储格式为YYYY-MM-DD HH:MI:SS[.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17a7db31aebed33ce6ff9255eb865e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3863d4e7be21a837403ec6fa18af9c78/" rel="bookmark">
			稚晖君项目复刻：L-ink门禁卡(1)——环境搭建与第一个项目创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		行文目录 前言其他文章正文开始STM32CubeMX安装STM32CubeMX安装L0的固件支持包Clion安装OpenOCD安装MinGw安装arm-none-eabi-gcc安装Clion配置 创建STM32工程创建STM32CubeMX工程更改芯片型号 参考文献 前言 其实关于稚晖君的L-ink门禁卡在我本科阶段就已经刷过好几次了，我也是从那次视频开始认识稚晖君大佬的，在此先十分感谢大佬提供的项目思路和开源资料（说起来稚晖君大佬也算我某种程度上的前辈了）。
这是我第一次尝试做嵌入式项目，将过程记录在本系列博客中，本篇为第一部分。众所周知，工欲善其事，必先利其器，STM32开发我之前用的是MDK5，那已经是大一到大二期间的事情了，后面笔者接触了pycharm，IDEA等jetbrain公司的IDE后，真的深深被这种IDE戳中了，恰巧，本次稚晖君的项目也是用的jetbrains另一个用来编写C++的编译器Clion，因此本篇就来手把手教大家配置Clion，STM32CubeMX进行32开发。
其他文章 正文开始 STM32CubeMX安装 STM32CubeMX直接去官网下载即可：STM32CubeMX下载地址。来到官网后，我们看到下图的界面，点击Get Software获取下载位置。
点击之后会跳转到下面选择版本，这里我下载的是win版的6.9.0。点击后会有个许可证同意，点击Accept就开始下载其setup.exe文件，如下图所示
之后我们就会得到一个zip文件，解压后就会在文件夹里面发现setup文件，双击该setup文件。就会出现安装界面。按照下图所示的步骤进行安装即可。
上面点击完Done即完成安装辽。
STM32CubeMX安装L0的固件支持包 由于本次开发使用的MCU是STM32L051K8，因此需要再STM32Cube里下载L0的固件支持包。
打开刚刚安装好的STM32Cube，点击INSTALL/REMOVE。
我们向下找到STM32L0，勾选框中内容并install，第一次需要各位登录一下，没有账号的就注册一下，最后有一个必填的ZIP/POSTNUM（具体是什么有点记不清了），直接填写邮编地址就行了。下图是已经下载完的样子。
至此我们又离成功近了一步，我们已经完成了STM32Cube的L0固件支持包
Clion安装 首先声明，大家支持正版，有能力还是请购买正版，学生也可以每年凭借学信网信息向jetbrains申请学生激活码，此处分享Clion的安装和po_jie，参考徐师兄源码站的教程，原文链接在文末参考文献[3]；
Clion下载可以直接去Clion的官网下载：Clion下载地址。建议下载2021以上的版本。进入官网后直接点击Download下载，下载后直接双击setup.exe进行安装即可。
按照如下的步骤安装即可，中间有安装选项，我们全选也可，按需勾选也可，笔者这里是全部勾选。
安装完成后关闭Clion，我们需要去下载破解工具，这里感谢公开bu_ding的前辈，可以关注公众号 徐公，回复CLion即可免费获取破解补丁。后续我会分享网盘链接，大家也可直接从网盘下载（但是链接不知道能活多久，前面的公众号比较稳妥）。
**注意事项：路径不要有中文！！！**下图是解压jetbira.zip后的样子。
打开 scripts 文件夹，先执行 uninstall-current-user.vbs的脚本文件，这一步是清楚已有的激活信息，保证后面的正常进行。
等到跳出Done弹框即说明成功了！！
之后再执行 install-current-user.vbs脚本，这一步时间比较长
需要等一段时间，等到出现第二个Done的弹框才算完成
之后我们打开Clion，输入激活码。激活码在如下文件夹中。
如果显示invalid并且Activate按钮点不了，可以重启电脑，在复制粘贴激活码
至此就有了一个很好用的C++IDE了。
OpenOCD安装 OpenOCD是用于对STM32进行下载仿真的工具，是一个开源软件包，其下载位置为：OpenOCD下载
我们回来到下面的界面，笔者习惯下最新的下一个版本（总觉得新版本可能会遇到奇奇怪怪的bug，而稍微旧一点的功能又新又稳定）。
点击后我们会下载.7z的压缩文件，我们找好地方解压就行了，之后需要在Clion中配置。解压后的文件目录如下图所示：
回到Clion，我们点击左上角的横杠，点击settings，如下图所示，我们也可以按下快捷键：Ctrl+alt+s打开settings。
记下来我们打开Build,Execution,Deployment -&gt; Embedded Evelopment，此时我们需要修改OpenOCD的位置和STM32Cube的位置，这两个位置就是我们上面刚安装的OpenOCD下的opencd.exe文件和STM32CubeMX.exe文件。
至此为止，Clion中也配置上了32的下载仿真工具并绑定了STM32Cube了。
MinGw安装 Clion需要MinGW环境配置ToolChain，MinGW的下载：MinGW下载地址
打开后我们进入如下的界面下载setup.exe，获取该下载器需要花费一些时间
双击setup.exe进行安装，按照如下步骤安装安装管理器
安装完成后，选择Basic Setup 选择组件进行安装，没安装的话是空白状态。我们要选中的话就右键选择Mark for Installation即可。选择完成即可看见图标中出现了一个箭头。要取消勾选也是右键，按Unmark
我们选中的如下所示，由于笔者已经安装过了，因此全是绿色的，我们这里是全勾选的，各位也可以按需勾选，勾选步骤如上所示。
勾选完成后左边框中会出现箭头，此时我们要安装需要找到左上角的installation，然后点击Apply Changes
点击Apply进行安装。
安装完成后出现如下页面，点击close关闭，此时我们就安装好minGW了。
接下来我们配置环境变量，打开系统属性找到环境变量
在系统变量中，选择Path进行编辑，
添加mingw安装路径下的bin文件夹
重启电脑，然后打开命令行，输入 gcc -v ，验证是否下载成功。注意，红框是版本，与我们上面minGW installation Manager的版本要一致，否则不是我们刚装的版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3863d4e7be21a837403ec6fa18af9c78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77128c950f6d408dceed0af9d06cbf94/" rel="bookmark">
			十进制转八进制（进制转换、C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.计算原理 十进制转八进制的基本步骤是将十进制不断取余8，直到不能再取为止，然后倒序输出每个余数，即是最后的八进制结果。
以下为示例图
2.问题描述 对于输入的任意一个非负十进制整数n(0=&lt;n&lt;100000)，打印输出与其等值的八进制数。
输入形式：非负十进制整数。
输出形式：相应十进制整数转换后的八进制正整数，若输入不符合要求，提示错误，重新输入。
3.代码实现 要实现这一功能，我们需要可以将余数存放于数组内，最后倒序输出数组即可输出结果，以下为具体代码。
#include &lt;bits/stdc++.h&gt; using namespace std; //进制转换函数 void transform(int num){ int store[100];//用于存储余数 int i=0; while(num!=0){ store[i]=num%8;	//取余顺序存入数组 i++; num/=8; } for(i=i-1;i&gt;=0;i--){	//倒序输出 cout&lt;&lt;store[i]; } } int main(){ int num; cin&gt;&gt;num; if(num&gt;0 &amp;&amp; num&lt;100000){ transform(num); cout&lt;&lt;endl; } else if(num==0){ cout&lt;&lt;0&lt;&lt;endl; } else{ printf("Error!\n"); cin&gt;&gt;num; transform(num); cout&lt;&lt;endl; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ca6d0fa42ffa0fc1a6e1e8fe7f4563/" rel="bookmark">
			Java两个线程使用最基础wait/notify轮流打印数字和字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 最基础的java线程协同工作题目，也是笔试常见题目。 题目要求两个线程轮流打印数字（1-26）和字符（a到z）。
代码 class PrintNumRunnable implements Runnable { final Object object; final static int MAX_LOOP = 26; public PrintNumRunnable(Object object) { this.object = object; } @Override public void run() { int count = 0; while (count++ &lt; MAX_LOOP) { synchronized (object) { try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.print(count); object.notify(); } }// end of while } } class PrintCharRunnable implements Runnable { final Object object; final static char MAX_CHAR = 'z'; public PrintCharRunnable(Object object) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ca6d0fa42ffa0fc1a6e1e8fe7f4563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fddb7087aedca6101c9e434f32bacbf/" rel="bookmark">
			Docker常用命令速查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Docker系统服务命令
2、Docker 查看
3、Docker操作
4、新建+启动命令
5、进入容器内部
1、Docker系统服务命令 启动docker： systemctl start docke停止docker： systemctl stop docke重启docker： systemctl restart docke查看docker状态： systemctl status docke开机启动： systemctl enable docker 2、Docker 查看 列出本地主机上的镜像 命令：docker images [OPTIONS]
OPTIONS说明：
-a :列出本地所有的镜像（含历史映像层）
-q :只显示镜像ID。
线上搜索镜像 docker search [OPTIONS] 镜像名字 例子：docker search mysql
查看镜像/容器/数据卷所占的空间 docker system df
列出当前所有正在运行的容器 docker ps [OPTIONS]
OPTIONS说明：
-a :列出当前所有正在运行的容器+历史上运行过的
-l :显示最近创建的容器。
-n：显示最近n个创建的容器。
-q :静默模式，只显示容器编号。
3、Docker操作 删除镜像 启动已停止运行的容器
docker start 容器ID或者容器名
重启容器 docker restart 容器ID或者容器名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fddb7087aedca6101c9e434f32bacbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df2ffcbbe90b2b842e09ff16ecee3509/" rel="bookmark">
			Docker的数据卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：原文地址docker-朱双印博客 (zsythink.net)
一个容器运行了一段时间，肯定会产生一些数据，比如日志、数据库数据、新改的配置文件、等等，如果这些数据文件存放在容器中，当我们删除容器时，这些数据也会被随之删除（因为这些数据存放在容器可读写层中，所以会随容器被删除），这可能并不是我们想要的结果，通常情况下，我们想要持久的保存这些数据，以便可以随时使用它们，那么，怎样做才能在删除容器时，仍然保留这些数据呢？在docker中，有一种存储数据的方法，叫做“数据卷”（后文简称卷，卷的英文为volume），借助“卷”，即可达到我们的目的。
那么什么是卷呢？
我们可以把“卷”理解成“宿主机中的目录”，当我们把某个卷和容器中的某个目录建立映射关系后，就相当于把宿主机中的某个目录和容器中的某个目录建立了映射关系。
举个例子：
假设现在有一个名为testA的卷，我们把testA卷和容器A中的/data目录进行了映射，映射后，运行容器A，容器A中的程序将日志写入到了容器的/data/A.log文件中，由于testA卷与容器A的/data目录是映射过的，所以我们可以在testA卷中，看到一个名为A.log的日志文件，testA卷中的A.log其实就是容器A中的/data/A.log，当我们删除容器A以后，testA卷中的A.log仍然存在于宿主机中，并不会随容器A被删除，也就是说，卷中的数据是独立于容器的生命周期之外的，卷能让我们将容器中的数据保存到宿主机上，从而确保我们即使删除了容器，对应的数据也能保存下来。
了解了什么是卷以后，就可以来实际动手操作一下了。
我们先来创建一个卷，使用如下命令，创建一个名为testA的卷
[root@cos7-1 ~]# docker volume create testA
testA
如你所见，docker volume命令就是专门用来管理卷的命令，上例中的create就是docker volume的子命令，docker volume create表示创建一个卷，执行上述命令后，使用ls子命令，可以查看当前主机中的卷，如下：
[root@cos7-1 ~]# docker volume ls
DRIVER VOLUME NAME
local testA
可以看到，在本地已经有一个名为testA的卷了，我们可以使用inspect子命令，查看对应卷的详细信息。
[root@cos7-1 ~]# docker volume inspect testA
[
{
"CreatedAt": "2022-05-07T00:05:37+08:00",
"Driver": "local",
"Labels": {},
"Mountpoint": "/var/lib/docker/volumes/testA/_data",
"Name": "testA",
"Options": {},
"Scope": "local"
}
上文说过，卷其实就是宿主机中的某个目录，从上述详细信息中可以看出，testA卷其实就是宿主机中的/var/lib/docker/volumes/testA/_data目录，在linux的docker主机中创建一个卷时，其对应的目录路径就是/var/lib/docker/volumes/卷名/_data
testA卷已经创建完成，但是没有任何容器使用这个卷，现在，我们来创建一个测试容器，让这个测试容器使用testA卷，创建容器的命令如下：
docker run -td --name testAcon --volume testA:/data alpine
上述命令表示创建一个名为testAcon的容器，将testA卷映射到testAcon容器的/data目录中，--volume选项就是用来映射卷和容器目录的，--volume testA:/data表示将testA卷映射到容器的/data目录，上例是基于alpine镜像创建的容器，alipine镜像中默认是没有/data目录的，当卷映射的目录在容器中不存在时，会自动在容器中创建对应的目录。
容器创建后，进入容器的/data目录，创建一个名为A.log的文件，如下
[root@cos7-1 ~]# docker exec -it testAcon sh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df2ffcbbe90b2b842e09ff16ecee3509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f1307c41a9ca317bcb9af0b8460f86/" rel="bookmark">
			mybatis返回自增主键值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于自增主键在某些业务中保存一个对象后，需要使用到这个主键完成后续的业务逻辑，就需要获取该主键值。
1、在接口中定义新增方法 int addStudent(Student student); 2、在mapper中配置新增配置 方式一：
&lt;insert id="addStudent" parameterType="Student" useGeneratedKeys="true" keyProperty="sid"&gt; insert into student(sname,sgender,sage,semail,sphoto) values (#{sname},#{sgender},#{sage},#{semail},#{sphoto}); &lt;/insert&gt; useGeneratedKeys: 表示开启获取自增主键值。
keyProperty：表示从表中取到主键值后赋给Student类中的哪个属性。
方式二：
&lt;insert id="addStudent" parameterType="Student"&gt; &lt;selectKey resultType="int" keyProperty="sid" keyColumn="sid" order="AFTER"&gt; select last_insert_id();//查询自增的主键值 &lt;/selectKey&gt; insert into student(sname,sgender,sage,semail,sphoto) values (#{sname},#{sgender},#{sage},#{semail},#{sphoto}); &lt;/insert&gt; keyColumn: 指定取数据库中哪一列的值（通常指主键列）。
keyProperty： 表示取出主键值后赋值Student对象的哪个属性。
resultType： 表示对象的属性类型
order：表示完后sql语句之前还是之后把主键值赋给实体类对应属性。
3、测试 两种方法测试结果相同
@Test public void t01() { SqlSession sqlSession = SqlSessionUtil.getSqlSession(); StudentDao studentDao = sqlSession.getMapper(StudentDao.class); Student student = new Student(0, "tom", "男", 18, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f1307c41a9ca317bcb9af0b8460f86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/657433f6e7daa506474f81184bfa66ed/" rel="bookmark">
			C&#43;&#43;11
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++11简介 在2003年C标准委员会曾经提交了一份技术勘误表(简称TC1)，使得C03这个名字已经取代了C98称为C11之前的最新C标准名称。不过由于C03(TC1)主要是对C98标准中的漏洞进行修复，语言的核心部分则没有改动，因此人们习惯性的把两个标准合并称为C98/03标准。从C0x到C11，C标准10年磨一剑，第二个真正意义上的标准珊珊来迟。相比于C98/03，C11则带来了数量可观的变化，其中包含了约140个新特性，以及对C03标准中约600个缺陷的修正，这使得C11更像是从C98/03中孕育出的一种新语言。相比较而言，C++11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率，公司实际项目开发中也用得比较多，所以我们要作为一个重点去学习。
小故事：
1998年是C标准委员会成立的第一年，本来计划以后每5年视实际需要更新一次标准，C国际标准委员会在研究C++ 03的下一个版本的时候，一开始计划是2007年发布，所以最初这个标准叫C++ 07。但是到06年的时候，官方觉得2007年肯定完不成C++ 07，而且官方觉得2008年可能也完不成。最后干脆叫C++ 0x。x的意思是不知道到底能在07还是08还是09年完成。结果2010年的时候也没完成，最后在2011年终于完成了C标准。所以最终定名为C11。
列表初始化{} 在C++98中，标准允许使用花括号对数组或者结构体元素进行统一的列表初始值设定。
struct A { int a; } int main() { int arr[] = {1, 2}; A a = {1}; return 0; } C++中定义了几种不同的初始化方式，现在我们要将一个int类型的变量a初始化为0.
int a = 0; int a = {0}; int a{0}; int a(0); int main() { int a = 0; int a1 = { 0 }; int a2{ 0 }; int a3(0); int arr[]{ 1,2,3 }; int arr1[5]{ 0 }; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; a1 &lt;&lt; endl; cout &lt;&lt; a2 &lt;&lt; endl; cout &lt;&lt; a3 &lt;&lt; endl; return 0; } 输出结果 0 0 0 0。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/657433f6e7daa506474f81184bfa66ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82681caff8b8c7923bfadd6f983236b/" rel="bookmark">
			C结构体内定义结构体，不能直接赋值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现像： 如下代码：
头文件：
typedef struct aBlinkGpioPinOutAbst_{ void (*initAsOutput)(void); void (*high)(void); void (*low)(void); }aBlinkGpioPinOutAbst; typedef struct aBlinkGpioAbst_{ #if GPIO_CONFIG_PA0 == GPIO_CONFIG_AS_OUTPUT aBlinkGpioPinOutAbst pa0; #elif GPIO_CONFIG_PA0 == GPIO_CONFIG_AS_INPUT aBlinkGpioPinInAbst pa0; #elif GPIO_CONFIG_PA0 == GPIO_CONFIG_AS_DOUBLE aBlinkGpioPinDoubleAbst pa0; #endif aBlinkGpioPinOutAbst* test; }aBlinkGpioAbst; C文件：
aBlinkGpioPinOutAbst pt; aBlinkGpioAbst gpio = { .pa0 = pt, }; 结果报错如下：
分析： 结构体应该代表的是一片内存，应该像基本类型一样可以直接赋值呀，为什么会出错？
使用如下初始化：
aBlinkGpioPinOutAbst pt; aBlinkGpioAbst gpio = { .test = &amp;pt, }; 可以编译了：
但是代价要使用-&gt;而不是.来调用。
解决： 使用
void x_aBlinkGpioInit(){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a82681caff8b8c7923bfadd6f983236b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502a4aeb020cac1bc0c059cf58972c58/" rel="bookmark">
			python画分组柱状图的模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要特征：
1、分组柱状图
2、能显示组内两个柱子差额百分比
3、纵坐标对数刻度
4、图例分列
代码及其注释：
import numpy as np import matplotlib.pyplot as plt # 需要画图的数据 data1 = [31.3313839,81.4741246,535.6064253,6615.067486,84241.35153] data2 = [33.592789,92.7759879,723.3740509,9606.228677,127541.5666] # 设置X轴标签 #labels = [1000,10000,100000,1000000,10000000] labels_ = ['3','4','5','6','7'] #用来为坐标的常规坐标 还是 对数坐标做准备 fig, ax = plt.subplots(figsize=(6.4, 4.8))#用来控制图片的大小 #fig, ax = plt.subplots() # 设置柱状图参数 width = 0.35 #柱状图每个柱子的宽度,同时也是调整每组柱子之间的间隙 x = np.arange(len(labels_)) #用来指定每个柱子位置参数 # 绘制柱状图,正常坐标 ax.bar(x-width/2, (data1), width=width, label='CL_Tucker')#第一个参数是该柱子的中心位置的坐标 ax.bar(x+width/2, (data2), width=width, label='GTA') ax.set_yscale('log', basey=10)#设置柱子的纵坐标为对数刻度 #在需要的位置添加数据标签，添加提高的百分比 for j in range(len(data1)): differ = (data2[j] - data1[j]) / data2[j] x_pos = j-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/502a4aeb020cac1bc0c059cf58972c58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5498ef8e18da901261af8b8ed7f6cb6a/" rel="bookmark">
			如何更换 openEuler 系统中的 yum 软件源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言更换 yum 软件源步骤一、了解 yum 软件源所在位置二、使原有源失效 1. 使原本的源后缀不以 .repo 结尾 2. 清理原本的源文件 三、 添加源仓库离线添加a.直接更换已有的 repo 文件 b.从外部块设备处读取软件源 在线添加使用互联网上的 yum 源网站使用 FTP 服务器的 yum 源构建 Linux 版本的 yum 源 FTP 服务器 四、 取消软件自检（可选） 五、 清理系统 logo 包六、清理原本的 yum 软件源列表，重新生成新的 yum 软件源列表 检查 yum 软件源 是否存在想要安装的软件yum 源文件简单介绍 yum 安装命令 与 卸载软件的命令安装软件 卸载软件 总结 前言 yum 全称 Yellow dog Updater Modified，即黄狗升级器，作为 openEuler 中默认的安装软件程序，安装方式支持 本地安装和 在线安装。
其软件源可根据需要自行替换。
yum 适用的安装包: rpm 文件
yum 软件源: repo 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5498ef8e18da901261af8b8ed7f6cb6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bdea6cf037c10cc24a41bf092241a6e/" rel="bookmark">
			最新版nacos 2.2.3服务注册与发现版本依赖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最新版nacos的注册服务时配置文件写的是对的，但就是在nacos web页面无法看见服务，此时你需要注意你的依赖是否正确 spring: application: name: orderservice cloud: nacos: discovery: server-addr: 122.51.115.127:8848 父工程依赖：现在最新的spring boot是3.1.4，但是对应的spring cloud、com.alibaba.cloud并没有，也就是如果用了3.1.4在用nacos 服务无法注册，下面的版本是目前spring cloud、com.alibaba.cloud对应的最新的spring boot版本也是博主实验过的可行版本，官网spring cloud支持3.0.x,而com.alibaba.cloud目前是支持到3.0.2 &lt;!-- spring boot 依赖 spring boot版本管理 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring cloud alibbba 版本管理以及微服务组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2022.0.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring cloud 版本管理以及微服务组件 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;2022.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 子工程依赖 &lt;!-- nacos 服务的注册与发现。 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;/dependency&gt; 此时启动服务，查看控制台可以使用debug=true，查看服务启动的详情，我之前版本依赖错误一直不打印nacos相关的信息，如下再去看nacos web页面就能看见注册的服务了，我之前版本依赖错误一直不打印nacos相关的信息，如下再去看nacos web页面就能看见注册的服务了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d245870ccd6996258de40d9c47e79b92/" rel="bookmark">
			MATLAB online
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 MATLAB online（支持正版） 一、注册一个MATLAB账号 账号注册地址
点击登录(可能需要显示简体中文)
点击创建帐户
输入能正常收到邮件的邮箱(不一定要用谷歌邮箱)
点击仍然继续
设置密码(注意：邮箱和密码是登录凭证)。设置完密码，点击下一步
密码条件：
填写收到的验证码，仔细阅读在线服务协议，点击下一步
填写基本信息，按要求填写即可(尽量不要用真实的个人信息)，点击下一步
出现这个页面就说明注册成功了！
二、使用MATLAB online MATLAB online【这个链接和一开始的链接是一样的，建议收藏方便访问】
登录MATLAB帐号，点击立即免费使用
接下来就可以正常使用MATLAB了
三、总结 每月每号20个小时
​ 可以多注册几个账号，但保存的数据是不互通的
​ 谷歌邮箱的特性不能用：不能像注册chatGPT一样，一个邮箱注册多个账号
需要联网都说是online，正常国内网络即可
在线教程
学过编程基本上可以无压力速通，可以快速掌握基本语法
如果不是用谷歌邮箱，部分过程可能需要到邮件中完成。MATLAB online完全免费（支持正版）可以节省电脑大量空间，不用去下载几个G但不支持部分第三方(自写)插件(工具箱)。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd73fc06aa40cc9f2fac9cc17740b6a0/" rel="bookmark">
			GPIO子系统（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，简述 GPIO 资源是相对来说较为简单，而且比较通用（比如 LED 灯），而 Linux 的 GPIO 驱动属于 Linux Driver 中较为容易上手的部分，但是简单归简单，在 Linux 系统中，要使用 GPIO 资源，还是需要了解一些内容。
Linux Kernel 中对 GPIO 资源进行了抽象，抽象出一个叫做 Gpiolib 的东东，这个东东作为 GPIO 资源的管理核心存在：
中间层是 Gpiolib，用于管理系统中的 GPIO。Gpiolib 汇总了 GPIO 的通用操作，根据 GPIO 的特性，Gpiolib 对上（其他 Drivers）提供的一套统一通用的操作 GPIO 的软件接口，屏蔽了不同芯片的具体实现。对下，Gpiolib 提供了针对不同芯片操作的一套 framework，针对不同芯片，只需要实现 Specific Chip Driver ，然后使用 Gpiolib 提供的注册函数，将其挂接到 Gpiolib 上，这样就完成了这一套东西。
对于其他驱动来说，比如 LED 灯驱动，就需要用到通用的 Gpiolib 的函数来进行 I/O 口的操作。
2，Gpiolib相关数据结构分析 先分析数据结构，Gpiolib 其实就是围绕几个数据结构在做文章，数据结构以及抽象层次清楚了，代码自然很快。
数据结构主要定义在 include/linux/gpio/driver.h 和 /drivers/gpio/gpiolib.h 中
首先看一个数据结构，叫 struct gpio_chip （include/linux/gpio/driver.h）：
struct gpio_chip { const char *label; struct gpio_device *gpiodev; struct device *parent; struct module *owner; int (*request)(struct gpio_chip *gc, unsigned int offset); void (*free)(struct gpio_chip *gc, unsigned int offset); int (*get_direction)(struct gpio_chip *gc, unsigned int offset); int (*direction_input)(struct gpio_chip *gc, unsigned int offset); int (*direction_output)(struct gpio_chip *gc, unsigned int offset, int value); int (*get)(struct gpio_chip *gc, unsigned int offset); int (*get_multiple)(struct gpio_chip *gc, unsigned long *mask, unsigned long *bits); void (*set)(struct gpio_chip *gc, unsigned int offset, int value); void (*set_multiple)(struct gpio_chip *gc, unsigned long *mask, unsigned long *bits); int (*set_config)(struct gpio_chip *gc, unsigned int offset, unsigned long config); int (*to_irq)(struct gpio_chip *gc, unsigned int offset); void (*dbg_show)(struct seq_file *s, struct gpio_chip *gc); int (*init_valid_mask)(struct gpio_chip *gc, unsigned long *valid_mask, unsigned int ngpios); int (*add_pin_ranges)(struct gpio_chip *gc); int base; u16 ngpio; const char *const *names; bool can_sleep; #if IS_ENABLED(CONFIG_GPIO_GENERIC) unsigned long (*read_reg)(void __iomem *reg); void (*write_reg)(void __iomem *reg, unsigned long data); bool be_bits; void __iomem *reg_dat; void __iomem *reg_set; void __iomem *reg_clr; void __iomem *reg_dir_out; void __iomem *reg_dir_in; bool bgpio_dir_unreadable; int bgpio_bits; spinlock_t bgpio_lock; unsigned long bgpio_data; unsigned long bgpio_dir; #endif /* CONFIG_GPIO_GENERIC */ #ifdef CONFIG_GPIOLIB_IRQCHIP /* * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip inside the gpiolib * to handle IRQs for most practical cases.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd73fc06aa40cc9f2fac9cc17740b6a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c80d6510ed309a73bb4dd6669542803/" rel="bookmark">
			java基础学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NID:41A2-A1B-JAVASE
Title: java基础学习
Tags: #javase #郝斌
JAVA概述 java概述 1&gt;起源 sun公司Green项目hotjava浏览器 2&gt;java特点 简单易学： 没有c和c++的指针，内存申请和释放 安全性高： 强类型，垃圾回收机制，禁止非法内存访问。 跨平台： 作为一种网络语言，其源代码被编译成一种结构中立的中间文件格式。只要有Java运行系统的机器都能执行这种中间代码。 java源程序被编译成一种与机器无关的字节码格式，在Java虚拟机上运行。硬件操作系统编译器高级语言程序用户 多线程: 即能够使得一个程序同时执行多个任务 3&gt;java虚拟机JVM Java虚拟机(JVM)是一个虚构的计算机，它在实际的硬件和操作系统上运行，并且能够执行Java字节码。Java字节码是由Java编译器从Java源代码编译而来的。JVM是Java平台的核心组件，它使得Java程序能够以“一次编写，到处运行”的方式跨不同的硬件和操作系统平台执行。 JVM的主要组成部分包括： 类加载器(ClassLoader)：用于加载Java类文件(以.class为扩展名)到JVM中。它负责找到和加载类文件，以及管理和回收已加载的类。 执行引擎：用于执行Java字节码。它将字节码翻译成对应平台上的本地机器码，然后通过操作系统调用计算机硬件执行相应的指令。 垃圾回收器(Garbage Collector)：负责自动回收不再使用的内存空间，以释放内存资源供其他对象使用。这样可以避免内存泄漏和内存溢出等问题。 运行时数据区：用于存储Java程序在运行过程中所需的数据和元数据。它包括方法区、堆区、栈区、程序计数器等。 JVM通过这些组成部分来实现Java程序的跨平台运行和内存管理等重要功能。开发者只需要编写一次Java代码，然后将其编译成字节码，就可以在任何安装了JVM的设备上运行该程序，无需对源代码进行修改。 4&gt;JVM的平台相关性 java源代码与字节码是与机器无关的，故在装有不同操作系统的机器上，需要有专门为该操作系统开发的JVM,JVM是与机器有关的. 5&gt;java的应用领域 1、J2SE ,主要用来开发桌面应用软件 2、J2ME，嵌入式开发，像手机里的软件，掌上电脑 3、J2EE，属于网络编程，JSP等， 6&gt;学习目标 了解程序语言及发展历史，掌握语法规则，掌握常用类的使用掌握编程逻辑思维能力：会看懂程序，会调试程序，理解并应用面对对象的设计思想。为将来学习J2EE做准备 7&gt;环境变量的设置： 一,java 安装 1.下载java安装文件 安装目录自选但是要记住安装路径。C:\Program Files (x86)\Java 安装过程中 点击下一步即可 安装完成后打开cmd命令输入 java回车 java -version回车//注意此处在java之后有一个空格，如果正确会出现安装的版本 2.搜索：编辑系统环境变量 创建： 变量名：JAVA_HOME 变量值：jdk安装路径即可,例如我安装路径：C:\Program Files\Java\jdk-9.0.4 编辑第二个变量名：path 变量值：%java_home%\bin 环境变量配置名是固定的，但是值是根据你安装具体路径复制过来的。不要直接写别人的 8&gt;classpath的设置 为什么要设置path： 1、在dos的任何目录下我们都可以运行系统自带的命令； 2、要想在dos下运行用户自己的程序，则必须进入到改程序的当前目录下方课运行； 3、如果希望在dos的任何目录下都可以运行自己创建的程序，则需要我们自己手动设置操作系统自带的环境变量path. path的设置： 操作系统是利用path变量来寻找当前程序所存放的路径，并且以最先找到的为准。路径与路径之间用分号;分开。 9&gt;常见dos命令 cd \ 表示进入当前根目录下 cd A\B\C 表示当前目录下的A文件夹下的B文件夹下的C文件夹下面 E： 进入E盘根目录 dir 查看文件夹下文件信息 cls 清屏 javac name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c80d6510ed309a73bb4dd6669542803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85cd6945f1603bc6ab4730fae7c71f3/" rel="bookmark">
			Wireshark抓包：详解TCP四次挥手报文内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、详解tcp四次挥手 刚才用图解释了tcp四次挥手的过程。用wireshark抓一个包，进行详细的分析。
1.客户端发的第一个释放连接的请求 这是抓的包，然后过滤出来的，看下最后的阶段，是要开始释放一个链接了。这里是第一个fin，ack包:
不是说只有fin吗？为啥这里是fin，ack包?
双击点看看下：
tcp报文是一个可靠的协议，它的每一个数据包都要进行确认，每发一个数据包都有一个ack包。表示每发一个包，都要去确认一下的。
所以第一个fin，ack包，ack被标记了，其实也是对上一个报文数据的确认。
tcp是一个常规的，每个包都要去确认的这样一个协议。
2.服务器给客户端回应确认消息 只有ack位被标记了，其它位没有被标记，因为这就是一个确认消息。
ack包的序号是952。是因为客户端发的fin，ack包希望下一个包的序号是952（确认号是952）
3.服务器发给客户端释放连接的请求 再次发送一个fin，ack包，表示我也要释放连接。
fin，ack和ack包的序号、确认号是一样的。
因为还是一个服务器发的，所以确认号和序号是一样的。
4.客户端发确认消息 客户端也发了一个ack包。这个包的ack号等于上一个包的序号（seq=5002）加1，也就是5003。
这个是别人抓的包，意思都一样
这里就是用wireshark抓包给大家详细的看了下四次挥手的过程。fin，ack包—&gt;ack包----&gt;fin,ack包----&gt;ack包。
后面tcp连接就没有了。
二、完整看到全过程 这个是别人抓的包，可以看到全过程。这个是重点。
三次握手后，发起https的一个连接，中间发的都是正常的数据包，直到客户端发完数据包了，客户端发起一个fin，ack包开始四次挥手，直到连接结束了。
三、提示 以上内容是抓包整理的，2次抓包的内容有些区别，但是图片上写的技术内容准确无误。最后一张完整看到全过程的图片是本文的技术重点。学习时应活学活用，切勿死搬硬套。
最后： 为了回馈铁杆粉丝们，我给大家整理了完整的软件测试视频学习教程，朋友们 如果需要可以自行免费领取 【保证100%免费】 软件测试面试文档
我们学习必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有字节大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39edec11949e23e46deaf6190a7a4121/" rel="bookmark">
			01-10 周二 PyCharm远程Linux服务器配置进行端点调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01-10 周二 PyCharm远程Linux服务器配置 时间版本修改人描述2023年1月10日14:04:15V0.1宋全恒新建文档2023年2月6日11:03:45V0.2宋全恒添加快捷指令别名的实现方便虚拟环境的切换 简介 使用 PyCharm，您可以使用位于另一台计算机(服务器)上的解释器调试应用程序。
参考该博客
工具菜单 在使用PyCharm时，发现菜单栏中没有工具菜单栏，通过如下的方式进行配置。
配置过程 部署配置 这个步骤的主要目标是可以通过PyCharm自动将本地程序的变更同步到远程的Linux服务器，并且当本地文件和服务器的文件变更时，可以双向获取更新。
在工具菜单-&gt;部署-&gt; 配置，创建SFTP连接（远程文件传输协议）、配置映射和排除的路径
连接配置 配置过程如下：
这样连接配置就正常了，
映射配置 根路径配置 在连接配置时，注意根路径对于Linux服务器来说，为“/”即可，默认为"/root"，我的项目打算部署在路径/home/sqh/FastBuild目录下，则根路径为/即可。
映射配置 可以同时添加多个映射，在项目有多个子项目，分别部署到不同位置时。
排除的路径 本小节主要用于一些不需要的同步，比如说pycharm产生的.idea目录，或者在服务器上产生的日志文件，等不需要同步的内容可以采用这种方式进行过滤。
将项目部署到服务器 操作PyCharm部署项目到服务器的图示如下：
然后使用XShell连接34服务器，查看上传的文件目录
配置python解释器 在博客中，查看了上述两个方法进行远程调试，作者推荐第一种。简单浏览了一下第二种方式，需要下载pydevd-pycharm软件包，并且同时需要修改源程序，比较复杂，不再演示。有问题参考博客即可。
创建python虚拟环境 首先创建python虚拟环境，主要使用virtualenv实现的。
下载virtualenv软件 软件安装需要使用pip工具。
$ pip3 install virtualenv -i https://pypi.tuna.tsinghua.edu.cn/simple/ 创建虚拟环境 # cd /home/sqh/FastBuild $ virtualenv envname # 创建一个名字为envname的虚拟环境 $ virtualenv -p python2 envname # 如果安装了多个python版本，如py2和py3，需要指定使用哪个创建虚拟环境 # 注意，要指定python3.7以上的环境为FastBuild搭建环境 $ virtualenv -p /usr/local/dros/python/bin/python3 fastbuild # 下面的程序用于验证 (fastbuild) root@szfyd-alg02:/home/sqh/FastBuild# /usr/local/dros/python/bin/python3 -V Python 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39edec11949e23e46deaf6190a7a4121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cffb8978a71ce8eec01bde0ef33cd519/" rel="bookmark">
			[Python]黑色背景白色块滑动视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑色背景白色块滑动视频，单帧效果如下：
配置参数
1920 1080 400 400 300 60 1920x1080.avi
import numpy as np import cv2 as cv import os import sys width = 1920 height = 1080 rect_szx = 400 rect_szy = 300 sz_y_init = 400 fps = 24 width = int(sys.argv[1]) height = int(sys.argv[2]) sz_y_init = int(sys.argv[3]) rect_szx = int(sys.argv[4]) rect_szy = int(sys.argv[5]) fps = int(sys.argv[6]) file_name = sys.argv[7] # 创建指定宽高、3通道、像素值都为0的图像 img = np.zeros((height, width, 3), np.uint8) st_x = 0 st_y = 0 sz_x = 0 sz_y = 0 videoWriter = cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cffb8978a71ce8eec01bde0ef33cd519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be528869d0eb6981cc74f414da61c326/" rel="bookmark">
			stm32h743IIT6&#43;lwip&#43;yt8512c&#43;cubemx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cubemx自动生成代码，添加yt8512 bsp(正点原子移植修改的)，硬件：正点原子阿波罗v2
实在太忙了，不写教程了。。。
看源码吧。。。该有的注释都有
https://gitee.com/nupps/stm32_lwip_yt8512c.git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a641088c3387dcc6bd60fb2eda7ea3f/" rel="bookmark">
			CV2对图像做渐变模糊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一段小代码，供参考，在CV2中做一些边缘渐变的功能。
主要流程：
生成一个随机的mask，并归一化，使其作为另一张图片的权重。对mask做高斯模糊，实现边缘渐变。将加权mask与原始图片相乘。 import os import cv2 import glob import random import numpy as np class FakeMask: def __init__(self, prop=0.99): self.prop = prop # 做数据增强的概率 # 获取一个随机的mask，归一化后作为权重。 def _get_random_mask(self, angle=np.random.randint(45, 80), center=None, scale=1.3): height = 100 width = 100 image = np.ones((height, width, 3), dtype=np.float32) * 255 (h, w) = image.shape[:2] if center is None: center = (w // 2, h // 2) M = cv2.getRotationMatrix2D(center, angle, scale) h = int(random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a641088c3387dcc6bd60fb2eda7ea3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c72ffd1ee50f19ea0713e88e653e6a9c/" rel="bookmark">
			write javaBean error, fastjson version 1.2.68, class org.springframework.web.multipart.support.Stand
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口上传excel文件并解析到数据库中，结果运行的时候报错了
com.alibaba.fastjson.JSONException: write javaBean error, fastjson version 1.2.68, class org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile, fieldName : file, write javaBean error, fastjson version 1.2.68, class org.springframework.web.multipart.MultipartFileResource, fieldName : resource 解决：
把controller相关接口上的@LogAnnotation或其他切片日志注解去掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81cb3fceb6c488087acb1f8015bb11dd/" rel="bookmark">
			（2023|CVPR，中文，扩散，知识增强，去噪专家组合）ERNIE-ViLG 2.0：利用知识增强的去噪专家组合改进文本到图像扩散模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ERNIE-ViLG 2.0: Improving Text-to-Image Diffusion Model with Knowledge-Enhanced Mixture-of-Denoising-Experts
公众号：EDPJ（添加 VX：CV_EDPJ 或直接进 Q 交流群：922230617 获取资料）
目录
0. 摘要
1. 简介
2. 方法 2.1. 基础 2.2. 知识增强扩散模型 2.3. 去噪专家混合 3. 实验 3.1 实现细节
3.2 结果
3.3 分析 4. 相关工作
5. 风险、限制和未来工作 6. 结论
参考
附录
A. 训练细节
B. 详细的自动评估
D. 详细消融研究 D.1 知识增强消融 D.2 混合去噪专家消融 D.3 图像质量比较 S. 总结
S.1 主要贡献
S.2 架构和方法 0. 摘要 扩散模型的最新进展彻底改变了文本到图像生成的流行技术。 虽然现有的方法可以在文本条件下生成逼真的高分辨率图像，但仍有几个悬而未决的问题需要解决，这限制了图像保真度和文本相关性的进一步提高。 在本文中，我们提出了 ERNIE-ViLG 2.0，一种大规模中文文本到图像的扩散模型，通过以下方式逐步提升生成图像的质量：（1）将关键元素的细粒度文本和视觉知识融入到图像中 （2）在不同的去噪阶段使用不同的去噪专家。 通过所提出的机制，并在双语提示集 ViLG-300 上进行并排人工评估，ERNIE-ViLG 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81cb3fceb6c488087acb1f8015bb11dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b2a620d894f03c141b413fbb6ba90b/" rel="bookmark">
			java实现pgsql自动更新创建时间与更新时间的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：通过数据库自身实现 在 PostgreSQL 中，可以通过创建触发器来实现自动填充创建时间和更新时间。
1.首先，我们需要在表中添加两个字段：update_time 和 create_time ，分别表示创建时间和更新时间。
ALTER TABLE idc_order_record ADD COLUMN create_time TIMESTAMP DEFAULT (TO_CHAR((NOW() AT TIME ZONE 'Asia/Shanghai'), 'YYYY-MM-DD HH24:MI:SS')::timestamp), ADD COLUMN update_time TIMESTAMP DEFAULT (TO_CHAR((NOW() AT TIME ZONE 'Asia/Shanghai'), 'YYYY-MM-DD HH24:MI:SS')::timestamp); 2.然后，我们可以创建两个触发器，一个用于在插入行时自动填充 created_at 字段，另一个用于在更新行时自动填充 updated_at 字段。
CREATE OR REPLACE FUNCTION trigger_set_create_time() RETURNS TRIGGER AS $$ BEGIN NEW.create_time = TO_CHAR(NOW() AT TIME ZONE 'Asia/Shanghai', 'YYYY-MM-DD HH24:MI:SS'); RETURN NEW; END; $$ LANGUAGE plpgsql; CREATE OR REPLACE FUNCTION trigger_set_update_time() RETURNS TRIGGER AS $$ BEGIN NEW.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b2a620d894f03c141b413fbb6ba90b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/232c5ae026ada6fd5fab636b36034977/" rel="bookmark">
			自定义数据训练的rknn模型部署 踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己训练了一个只有2种类别的yolov8模型之后，部署到瑞芯微RKNN。
踩坑一：类别的变化 之前用COCO数据集训练的.pt模型转rknn后，output0的shape为8400 x 176.
而把自定义数据集训练的模型转rknn后，output0的shape为8400 x 98.
为什么会不一样？一度以为模型或代码有问题，拿图片测了下发现模型没问题，能检测出来。
分析一下8400x176，其中8400是proposal的个数，176是box相关的64+80个类别+32的mask coefficient.
现在类别变成了2，自然要变成64+2+32=98.
所以，如果后处理中用到类别数=80，画图中的类别标签用了80个的，这里需要修改一下。
踩坑二：模型转化（.pt 转 .rknn） 用转化后的rknn模型检测，只能检测出一种类别，另一种检测不出来。
于是从后处理出发找原因，
现输入图片中有两种物体，每种一个，理论上应该检测出2个物体。
先看NMS之前检测了多少个物体。
std::vector&lt;int&gt; picked; nms_sorted_bboxes(proposals, picked); //picked里面保存的是proposals的下标 int count = picked.size(); 这里NMS之前 picked.size() = 1, 说明NMS之前就只检测出一个，已经不对了。
回到NMS之前的处理，
这里选择较大概率的类别作为label，保存label, score和box坐标。
int label = -1; float score = -FLT_MAX; //找到最大score和对应的label for (int k = 0; k &lt; num_class; k++) { float confidence = deqnt_affine_to_f32(score_ptr[k], zp, scale); //反量化,int转float if (confidence &gt; score) { label = k; score = confidence; } } float box_prob = sigmoid(score); if (box_prob &gt;= thres) { //忽略一段处理过程 obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/232c5ae026ada6fd5fab636b36034977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75618ed806a3956303565d4ddf6f203e/" rel="bookmark">
			ADAS可视化系统，让自动驾驶更简单 -- 入门篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着车载芯片的升级、技术的更新迭代，可视化ADAS逐渐变成汽车的标配走入大家的生活中，为大家的驾车出行带来切实的便捷。那么你了解HMI端ADAS的实现过程吗？作为ADAS可视化系统的入门篇，就跟大家聊一聊目前较常见的低消耗的一种ADAS可视化实现方案。
ADAS显示场景中常见的显示元素有：障碍物、车道线、车道、导航线、路面标记、TT灯等，其中非常关键的两个显示元素是障碍物和车道线，对不了解ADAS的小伙伴来说，实现起来有一定的难度，本期我们就围绕这两个元素展开。
01 开始之前我们需要先明确ADAS的显示坐标系。ADAS的显示坐标系通常是以自车中心点或自车车尾中心点作为原点，自车正前方作为X轴正方向，自车右侧方向作为Y轴正方向（也有以自车左侧方向作为Y轴正方向的）。
描述障碍物显示的数据Struct_Obstacle通常有以下成员
► id --- 障碍物编号
► type --- 障碍物种类，如：汽车、卡车、单车、行人、防撞桶等
► pos_x --- 障碍物X轴方向坐标
► pos_y --- 障碍物Y轴方向坐标
► direction --- 障碍物方向
► color --- 障碍物颜色，通常用来表示碰撞风险等级，碰撞风险等级越高颜色越醒目
障碍物显示处理通常需要两个模块
► 数据处理模块
► 界面显示模块
由于实际场景中自车智驾系统检测到的周围的障碍物是动态变化的，所以障碍物数据通常是以动态数组vector转化的json字符串或protobuf整帧传输。数据处理模块对比接收到的前后两帧障碍物数据列表，后一帧数据列表中，
● 新出现的障碍物id对应的即为新出现的障碍物，需要在界面中新增显示出来；
● 消失的障碍物id对应的即为消失的障碍物，需要在界面中将其隐藏删除掉；
● 两帧数据列表中都存在的障碍物id对应的即为持续存在的障碍物，通常需要根据需求对其进行插值处理，以便在界面显示中顺滑地变化该障碍物的位置、角度等，避免闪烁跳变
（※关于插值：智驾系统通常每100ms发送一次障碍物数据，而界面的显示帧率通常仪表端为60FPS（即16.7ms刷新一次）、中控端为30ms（即33ms刷新一次），故而在智驾系统数据更新间隔内仪表端可插值5~6次，中控端可插值2~3次。根据需求按照实际的运行帧率进行插值即可。）
通过上述描述也可以看到，障碍物数据不能是单个障碍物单独发送，因为这样无法像上面那样在前后两个智驾系统发送周期中直观地判断各个障碍物的行为。
界面显示模块控制界面障碍物的动态显示、变化，根据数据处理模块传过来的数据，或动态地生成障碍物并显示、或动态地隐藏障碍物并销毁、或更新持续存在的障碍物显示状态。在当前的绝大多数ADAS项目中，障碍物通常由3D模型来显示，资源占用较高，动态生成、销毁障碍物可确保对系统资源的合理有效利用。
02 介绍完障碍物的实现方案，我们接着看下车道线的实现方案。
描述车道线显示的数据Struct_LaneLine通常有两种，
► 一种是连续的离散点数据，需要根据离散点动态生成相应的车道线模型并显示；
► 一种是三次函数（y=C3*x^3+C2*x^2+C1*x+C0）的四个系数，即C3、C2、C1、C0；
（※本文以第二种为例。）
此外其他的数据还有：
► id --- 车道线编号
► type --- 车道线种类，如：实线、虚线等
► color --- 车道线颜色
► pos_start/pos_end --- 起止位置等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75618ed806a3956303565d4ddf6f203e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70474b41b8f4a3bc68a41772ee5cd154/" rel="bookmark">
			yolov5s利用tensorRT部署并转dll文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先是生成tensorRT的engine文件：
Tensorrt的环境配置并生成tensorrt文件参考与以下的B站视频链接。
【手把手带你实战YOLOv5-部署篇】YOLOv5 TensorRT环境安装与配置_哔哩哔哩_bilibili
其中遇到了不少的问题，记录如下：
（1）AssertionError: Invalid CUDA '--device 0' requested, use '--device cpu' or pass valid CUDA device(s)
这个问题是说cuda不可用，最终发现就是cuda没有正确安装，要安装cuda的GPU版本， cudnn，并且torch和torchvision的版本都要与cuda对应，缺一不可。
（2）tensorrt: export failure 0.0s: No module named 'tensorrt'：问题是说tensorrt没有正确安装成功，但是我是根据视频的教程一步一步来的，于是我就想卸载重装，但是在终端中删除这个库的时候出现了错误，说我没装这个库，警告的信息如下。
WARNING: Ignoring invalid distribution -pencv-python (d:\anaconda3\lib\site-packages)
WARNING: Skipping tensorrt as it is not installed.
与是我发现这个是我base环境的位置，于是我换了个思路，在base环境中也用pip install的指令安装了对应版本的tensorrt发现能够正常运行了。
以上终于能够实现.pt模型转.engine文件。
2.在C++项目中调用.engine文件
首先要进行tensorRT、OpenCV的环境配置，这个找不到参考的文献了，就是配置一下项目的库目录、包含目录、以及附加依赖项。
在配置好环境之后，读取文件模型：
// 读取本地模型文件 std::string model_path_engine = model_path; std::ifstream file_ptr(model_path_engine, std::ios::binary); if (!file_ptr.good()) { std::cerr &lt;&lt; "文件无法打开，请确定文件是否可用！" &lt;&lt; std::endl; } size_t size = 0; file_ptr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70474b41b8f4a3bc68a41772ee5cd154/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c2f9a5352cc01a52a2e415afbece09/" rel="bookmark">
			腾讯云服务器网站搭建教程（太简单了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已经有了腾讯云服务器如何搭建网站？腾讯云服务器网以腾讯云服务器，借助宝塔面板搭建Web环境，然后使用WordPress博客程序搭建网站，大致分为三步，首先购买腾讯云服务器，然后在腾讯云服务器上部署宝塔面板，最后在宝塔面板上安装WordPress程序。
目录
腾讯云服务器搭建网站教程
轻量服务器应用镜像快速搭建WordPress网站
腾讯云服务器安装Web网站环境
SSH登录到腾讯云服务器
执行宝塔面板安装命令
在服务器上开通宝塔面板所需端口号
获取宝塔面板登录地址、账号和密码
安装LNMP环境
在宝塔面板添加站点
下载WordPress网站程序
上传网站程序到根目录
域名解析到云服务器IP地址
安装WordPress程序
腾讯云服务器搭建网站教程 腾讯云服务器可选云服务器或轻量应用服务器，云服务器购买后可以自行搭建Web网站所需的环境，也可以使用腾讯云官方提供的镜像，最后我们在搭建好环境的云服务器上安装WordPress程序，将域名解析到云服务器公网IP地址上，网站就可以上线了。
腾讯云服务器搭建网站，可选云服务器或轻量应用服务器，关于云服务器的选择参考：腾讯云服务器购买流程（两种入口），本文不多赘述。
轻量服务器应用镜像快速搭建WordPress网站 在腾讯云服务器的“镜像市场”中，可以选择已经带有Web环境的市场镜像。如果是轻量应用服务器，直接提供WordPress镜像，如下图：
轻量服务器应用镜像，可以领券：https://curl.qcloud.com/HmjGZiLu
如上图，如果是轻量应用服务器可以直接选择所需要的应用镜像，如宝塔镜像、WordPress、Discuz及LAMP等，一劳永逸。本文是以云服务器安装Linux纯净版操作系统为例，手动安装宝塔面板，然后在宝塔上安装WordPress程序。
腾讯云服务器安装Web网站环境 安装Web环境要根据网站程序而定，本文最终要搭建的WordPress网站程序，为WordPress安装LNMP环境Linux+Nginx+MySQL和PHP，腾讯云服务器网小编直接为云服务器安装宝塔面板，宝塔面板集成了LNMP环境，然后在宝塔上新建站点安装WordPress程序。
腾讯云服务器网使用的云服务器系统为TencentOS Server 3.1 (TK4)镜像，TencentOS Server是腾讯云推出的Linux操作系统，兼容CentOS生态及操作方式，所以在该台云服务器上执行宝塔面板CentOS安装命令即可。
SSH登录到腾讯云服务器 1、SSH登录到腾讯云服务器
在腾讯云服务器控制台，找到目标云服务器，点击右侧“登录”，如下图：
腾讯云服务器登录
腾讯云服务器网使用腾讯云Web网页自带的远程登录方式，输入云服务器root登录密码，登录。如果是SSH密匙登录，就选择密匙。
执行宝塔面板安装命令 2、执行宝塔安装命令，TencentOS使用CentOS命令即可：
yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 其他云服务器系统安装宝塔命令参考：腾讯云服务器安装宝塔Linux面板命令脚本一键执行
期间会提示如下：
Do you want to install Bt-Panel to the /www directory now?(y/n): y 回复一个字母“y”回车，腾讯云服务器即可自动安装宝塔Linux面板。
宝塔面板安装成功后，显示如下：
success ================================================================== Congratulations! Installed successfully! ================================================================== 外网面板地址: http://云服务器公网IP地址:8888/ec0215f6 内网面板地址: http://172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c2f9a5352cc01a52a2e415afbece09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b7cc3d5fffbfc3245453a225beb097/" rel="bookmark">
			【避坑指南】在安卓APP接入微信支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信支付涉及到两个平台，一个是微信开放平台，另一个是微信支付商户平台，需要在微信开放平台上创建应用，然后关联微信支付商户平台的商户号；微信支付只用到AppID和API密钥（微信商户平台(pay.weixin.qq.com)–&gt;账户中心–&gt;账户设置–&gt;API安全–&gt;设置API密钥），没有用到AppSecret；微信支付有两个过程，一个是发起预支付（即"统一下单"，详见https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1），另一个是正式支付（即"调起支付接口"，详见https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_12&amp;index=2），只有先发起预支付才能拿到prepayId，而且通过Post到https://api.mch.weixin.qq.com/pay/unifiedorder时报文需要是xml格式，预支付的结果也是通过xml回传；预支付的签名算法要和正式支付的签名算法一致，详见https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=4_3#，里面有个签名校验工具，可以看看自己计算出来的签名是否一致；预支付订单的传参中有个package="Sign=WXPay"的项，注意字符串分割时"Sign=WXPay"不要也被分割开了；运行报错 “ClassNotFoundException: com.tencent.xweb.pinus.sdk.JNIUtils” 但是检查过appId和签名都没问题，那就尝试一下在AndroidManifest中添加如下代码： &lt;!--包体可见性--&gt; &lt;queries&gt; &lt;package android:name="com.tencent.mm" /&gt; &lt;/queries&gt; 支付前弹出提示“签名不对，请检查签名是否与开放平台上填写的一致”，其实就是打包用到的keystore不对，一定要与微信开放平台上填写的包名和签名一致，如果你keystore不对，那么计算出来的签名也是错误的，在这个链接里可以下载一个apk签名生成工具，输入包名就能得到签名。https://developers.weixin.qq.com/doc/oplatform/Downloads/Android_Resource.html横屏APP拉起微信支付的瞬间闪退，logcat日志显示"Uninitialized ActivityThread, likely app-created Instrumentation, disabling AppComponentFactory"啥的，这个我也没找到解决办法，但是把横屏APP改成竖屏APP后，就不会闪退了，并且可以看到其他报错，感觉是因为微信支付是竖屏的，但是支付过程又出现了异常，导致窗体闪退。能拉起微信支付，但是弹窗提示“支付验证签名失败”，而且在上述第4步的工具中校验过签名没问题，那很大可能是统一下单和调起支付接口的参数字段名错了！比如二者都有的nonceStr字段，在统一下单叫“nonce_str”，在调起支付叫“noncestr”，非常恶心：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/76/">«</a>
	<span class="pagination__item pagination__item--current">77/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/78/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>