<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea3b78eba559d2d3c76da5ac3c2bbdb4/" rel="bookmark">
			Axis2 传输报 Read timed out 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中需要用Axis2给第三方批量上传数据，单个上传的时候没有问题。但一开多线程就有时候会抛出这个异常。
百度上说将 TimeOutInMilliSeconds 的值设大就行了，但我已经将之这个值设置为10分钟了，但还是会出现这个问题。最后发现是http过期了，因为Axis2底层也是http，解决办法就是将 http 的失效时间也进行增大。
ops.setProperty(HTTPConstants.SO_TIMEOUT, 600 * 1000); 延长http的失效时间后完美解决，具体代码如下
public static void sendS(String message, List&lt;Integer&gt; ids) throws IOException { try { ServiceClient serviceClient = new ServiceClient(); OMElement request = xmlStringToOM(message.toString()); Options ops = new Options(); ops.setTo(new EndpointReference("请求地址")); ops.setTransportInProtocol(Constants.TRANSPORT_HTTP); ops.setProperty(Constants.Configuration.ENABLE_MTOM, true); ops.setSoapVersionURI(SOAP12Constants.SOAP_ENVELOPE_NAMESPACE_URI); // 这里设置的是Axis2的失效时间 ops.setTimeOutInMilliSeconds(600 * 1000); // 这里设置http的失效时间 ops.setProperty(HTTPConstants.SO_TIMEOUT, 600 * 1000); serviceClient.setOptions(ops); serviceClient.engageModule(Constants.MODULE_ADDRESSING); //发送 OMElement response = serviceClient.sendReceive(request); responseDicoms(response, ids); serviceClient.cleanupTransport(); serviceClient.cleanup(); } catch (AxisFault e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea3b78eba559d2d3c76da5ac3c2bbdb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8447ea9b15c07466da994e3204433214/" rel="bookmark">
			echarts 全国各省市地图切换展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果如上图，开始默认为全国地图，选择省或者市渲染为对应的地图
index.html
&lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&amp;key=你的key&amp;plugin=AMap.MouseTool,AMap.PolyEditor,AMap.PlaceSearch,AMap.Autocomplete,AMap.Pixel,AMap.DistrictSearch"&gt;&lt;/script&gt; &lt;!-- UI组件库 1.0 --&gt; &lt;script src="https://webapi.amap.com/ui/1.0/main.js?v=1.0.11"&gt;&lt;/script&gt; mixin.js
import AMap from 'AMap'; import AMapUI from 'AMapUI'; export default { data() { return { district: null, country: {}, proObj: {}, provinceList: [ { id: '110000', name: '北京市' }, { id: '120000', name: '天津市' }, { id: '130000', name: '河北省' }, { id: '140000', name: '山西省' }, { id: '150000', name: '内蒙古自治区' }, { id: '210000', name: '辽宁省' }, { id: '220000', name: '吉林省' }, { id: '230000', name: '黑龙江省' }, { id: '310000', name: '上海市' }, { id: '320000', name: '江苏省' }, { id: '330000', name: '浙江省' }, { id: '340000', name: '安徽省' }, { id: '350000', name: '福建省' }, { id: '360000', name: '江西省' }, { id: '370000', name: '山东省' }, { id: '410000', name: '河南省' }, { id: '420000', name: '湖北省' }, { id: '430000', name: '湖南省' }, { id: '440000', name: '广东省' }, { id: '450000', name: '广西壮族自治区' }, { id: '460000', name: '海南省' }, { id: '500000', name: '重庆市' }, { id: '510000', name: '四川省' }, { id: '520000', name: '贵州省' }, { id: '530000', name: '云南省' }, { id: '540000', name: '西藏自治区' }, { id: '610000', name: '陕西省' }, { id: '620000', name: '甘肃省' }, { id: '630000', name: '青海省' }, { id: '640000', name: '宁夏回族自治区' }, { id: '650000', name: '新疆维吾尔自治区' }, { id: '710000', name: '台湾省' }, { id: '810000', name: '香港特别行政区' }, { id: '820000', name: '澳门特别行政区' } ], cityList: [], show: false, showFence: false, select: {}, selectCity: {} }; }, components: {}, mounted() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8447ea9b15c07466da994e3204433214/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea02f98c674fa7a5198b9f62c0d1c6ad/" rel="bookmark">
			现代卓越PMI-ACP串讲课笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一章 敏捷原则与思想 第二章 价值驱动交付 第三章 相关方参与 第四章 团队绩效 第五章 适应性规划 第六章 问题发现和解决 第七章 持续改进（产品、流程、人） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80776b185d6f4c329c76627c6f171428/" rel="bookmark">
			ERLANG中千奇百怪的语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天维护公司的一个老的项目，于是对ERLANG有了接触，开始接触的时候，对ERLANG的语法感到非常难以适应，来几个给大家猜猜试试看。
#state{socket = Socket, ref = Ref} = State
NewState = State#state{socket =&gt; Socket, ref =&gt; Ref }
NewState = State#state{socket := Socket, ref := Ref }
NewState = State#state{ref = Ref}
是不是感觉自己逻辑混乱了？是不是感觉自己智商遭受重击？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d951d3f4ad113dbbbda768a8669156d7/" rel="bookmark">
			js获取name属性相同的页面元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面元素：
&lt;input type="checkbox" name="oncheck" value="张三"/&gt; &lt;input type="checkbox" name="oncheck" value="李四"/&gt; &lt;input type="checkbox" name="oncheck" value="王五"/&gt; 获取页面元素的方式：
获取所有name属性相同的元素 var $all = $("input[name=oncheck]") 获取所有name属性相同，并且筛选出对象状态属性为checked的元素` var $allChecked = $("input[name=oncheck]:checked") 注意事项：
通过这种方式获取的是一个jQuery对象，这个对象是一个数组，而且数组中的元素是以dom对象的形式存在
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d7e83563c9907eddb0f12e6737ee0d/" rel="bookmark">
			代码合并问题：使用git的merge into current ，合并分支的时候需要注意的地方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这种问题，是因为粗心造成的，不过确实一不小心很容易犯，在此记录下，增强印象
场景：在test分支，使用git的merge into current ，将master分支合并到test（需求较多，以及解决线上紧急问题时，然后没来得及合并到test分支上，导致test和master分支相差太大，有必要合并一下），合并时爆出的冲突问题都已经解决了，但是编译的时候出错了，在解决后。
注意，我解决后，直接进行了push，因为merge的时候，git默认会commit，但是此时push的只是我merge的代码，编译出错修复的代码并没有push，因为我还没有commit，本地修改嘛，git不会自动的提交，所以需要再commit，然后push，再能解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aa964128504d05bc532479188540f88/" rel="bookmark">
			Xilinx MicroBlaze软核驱动DDR3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xilinx MicroBlaze软核驱动DDR3
说明：通过Vivado生成MicroBlaze工程导入SDK实现DDR3的读写。
环境：Vivado2018.3。
IP核：MicroBlaze。
参考手册：
pg142： AXI UART Lite v2.0
ug586：7Series_MIS
工程：DDR3
文章目录 1.DDR简介1.1DDR3地址 2. MicroBlaze简介3.MicroBlaze设计流程3.2 DDR Block Design 流程 4.SDK工程5.SDK DDR用指令分别访问 DDR、BRAM速度 1.DDR简介 MT41K256M16xx-125：
内存大小为512MB，数据接口为16bit。
为什么是512MB：256M空间，数据线为16bit，1Byte=8bit，256M×16bit=512M×8bit=512MB。
下图为型号参数的具体解析：
1.1DDR3地址 DDR3的内部是一个存储阵列，将数据“填”进去，你可以它想象成一张表格。和表格的检索原理一样，先指定一个行（Row），再指定一个列（Column），我们就可以准确地找到所需要的单元格，这就是内存芯片寻址的基本原理。对于内存，这个单元格可称为存储单元,那么这个表格（存储阵列）就是逻辑 Bank（Logical Bank，下面简称Bank）。 DDR3内部Bank示意图，这是一个NXN的阵列，B代表Bank地址编号，C代表列地址编号，R代表行地址编号。
以下列举了不同容量的DDR3地址：
注意以上单位为GBit。比如MT41K256M16TW-107容量为512MB=512×8Mbit=4096Mbit=4Gbit，就要看表2.11.4 4Gb中的256M×16。
2. MicroBlaze简介 MicroBlaze嵌入式软核是一个被Xilinx公司优化过的可以嵌入在FPGA中的RISC处理器软核，具有运行速度快、占用资源少、可配置强等优点，和其他外设IP核一起，可以完成可编程系统芯片(SOPC)的设计。
FPGA是可编程的硬件逻辑电路，MicroBlaze是一种处理器电路，使用MicroBlaze就相当于在FPGA内部做了一个CPU在里面，可以用C语言编写程序，在这个CPU上跑C语言的软件程序，FPGA偏向逻辑，做控制比较麻烦，CPU做控制比较方便。
3.MicroBlaze设计流程 新建Vivado工程…
3.2 DDR Block Design 流程 添加MicroBlaze IP：
Run Block Automation：
添加串口IP：
添加MIG IP(DDR控制IP)：
MIG介绍：详细请看FPGA_MIG驱动DDR3
如下图所示：FPGA用户逻辑↔MIG↔DDR3的端口连接示意图(可以理解MIG作为中间介质让我们间接的控制了DDR，简化了控制接口)：
配置MIG IP：双击mig_7series
Next:
根据自己板子型号选择：
DDR类型：
时钟配置说明：
1.Clock Period
即MIG对DDR接口的速率为800M*2=1600M(双沿)。
MIG输出到app接口上的时钟ui_clk为800M/4=200M。
UI时钟频率ui_clk为DDR时钟频率的1/4，也就是一个用户时钟周期(两个边沿)对应8个DDR时钟边沿。burst length可以理解为MIG连续操作DDR地址的个数，故在4:1时钟比例下，一个用户时钟周期正好对8个地址进行了读/写操作，256bit数据分8次（32bit）写入DDR中，即逻辑用户以时钟ui_clk写256bit数据至MIG，MIG控制器将以时钟ddr_clk向DDR写8次(32bit(数据位宽配置为32bit))数据。由此分析，在写数据时让app_wdf_end = app_wdf_wren即可，并且读/写操作时地址递增步长为8。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aa964128504d05bc532479188540f88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e1eef573eeb710a1b003a703337b8e3/" rel="bookmark">
			Ubuntu安装python3.7，并更新python默认指向为python3.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu默认的python版本一般为python 2.x，因此需要手动安装自己需要的版本，并且将python的指向更新为自己的版本。
1. 先查看当前python的指向
ls -l /usr/bin | grep python 因为我这里已经安装好了python 3.7.1，并更新了python的指向，默认应该是指向python 2.7。
2. 下载并解压安装包
# 下载安装包 $ wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz # 解压安装包 $ tar -zxvf Python-3.7.1.tgz 3. 进入到解压后的Python-3.7.1目录下
$ cd Python-3.7.1 4. 创建安装目录
在/usr/local/目录底下创建一个安装目录
$ sudo mkdir -p /usr/local/python3 5. 编译安装
顺序执行下面三个命令
$ ./configure --prefix=/usr/local/python3 --enable-optimizations $ make $ sudo make install 6. 删除python和pip的软链接
# 删除python软链接 $ rm -rf /usr/bin/python # 删除pip软链接 $ rm -rf /usr/bin/pip 7. 添加python和pip的软链接
# 添加python3的软链接 ln -s /usr/local/python3/bin/python3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e1eef573eeb710a1b003a703337b8e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00cd44d8208b5e9c9563f9a2284ee5a/" rel="bookmark">
			成功解决OSError: Error reading file ‘baidu.html‘: failed to load external entity “baidu.html“问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成功解决OSError: Error reading file ‘baidu.html’: failed to load external entity "baidu.html"问题
from lxml import etree #解析文件 def parse_file(): parser = etree.HTMLParser(encoding='utf-8') html= etree.parse('baidu.html',parser=parser) print(etree.tostring(html, encoding='utf-8').decode('utf-8')) if __name__ == '__main__': parse_file() 运行上面的代码所产生的问题：
OSError: Error reading file 'baidu.html': failed to load external entity "baidu.html" 代码本身没有任何问题，这和你放的文件位置有关系，当你要把需要解析的html文件和正在编写的.py文件放在同一个目录下以后再执行上述代码则不会报错
如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f26d0386d586d0bcaa905bb203e04d5f/" rel="bookmark">
			docker-compose: 未找到命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker-compose: 未找到命令 安装docker-compose1.从github上下载docker-compose二进制文件安装 安装docker-compose 1.从github上下载docker-compose二进制文件安装 sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 若是github访问太慢，可以用daocloud下载，下载文件到/usr/local/bin/docker-compose文件夹下：
sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 添加可执行权限
sudo chmod +x /usr/local/bin/docker-compose 测试安装结果
docker-compose --version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae74eb7264d3c9f358ee86f60df96145/" rel="bookmark">
			vue父组件通过$refs调用子组件方法时报undefined的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，vuejs怎样调用子组件里的方法？给引用过来的子组件加ref，然后选中这个ref就可以使用方法了： 参考：
https://www.jianshu.com/p/01c7e752684e
2，vue父组件通过$refs调用子组件方法时报undefined的问题 解决办法：
参考：
https://blog.csdn.net/m0_46156566/article/details/106476362
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72ff78f9f54ee71fb3cb87192c87728e/" rel="bookmark">
			关于springmvc 老项目的启动报错的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 老项目 第一次启动报错解决方案
问题一： 当spring mvc 项目出现 ibatis 或者 mybatis 中 driver 等配置文件没有引用 解决方法： 手动清除target包下所有文件，idea 工具下reimport项目，然后直接运行 问题二： spring mvc 结合zookeeper dubbo 项目出现 bean的重复注册等信息的话 解决方法： 手动清除服务提供者target包下所有文件，idea 工具下reimport项目，然后直接运行 问题三： 项目工程下依赖报红 解决方法： 1-父工程 clean ⇒ reimport ⇒ install 2-选择清除本地maven仓库或者将可以使用的maven仓库依赖进行替代 问题四： idea 项目下，所有root 目录工程下依赖没有，项目无法运行 解决方法： idea 工具下 打开 Project Structure ⇒ Module 1-工程是否被引入，未被引入的话引入项目 2-项目是否有重复的，重复的话清除重复信息，重新引入项目 Project Structure ⇒ Artifacts 1-查看war包是否有重复的，重复的删除 2-缺失的话，将打包后的war包引入 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a8739d452adf0597013adf6228afcf8/" rel="bookmark">
			Laya.HttpRequest数据post
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 let hr = new Laya.HttpRequest(); hr.send("https://ailevel.qq.com/METManage/uploadDataToFile", 'abc=123&amp;def=456', "post") hr.on(Laya.Event.COMPLETE, this, (msg)=&gt;{ console.log(" === post complete === ", msg); }) hr.on(Laya.Event.ERROR, this, (msg)=&gt;{ console.log(" === post error === ", msg); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfa098fe13d5807a4328a07e02982512/" rel="bookmark">
			openEuler，误删/卸载系统自带的python3.7，导致yum、dnf命令不可用/无法使用的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1-问题描述2-解决方法1.安装python3.72.安装yum相关包3.安装dnf相关包4.安装python3-dnf5.查看版本 3-参考文档 1-问题描述 openEuler20.03自带的python3为3.7版本，为了安装3.9版本，参考了一些文章，卸载了3.7版本与相关残余文件。
参考文章截图如下图所示，强烈建议没有遇到问题的小伙伴们不要去尝试！
这个方法可以卸载和系统没什么影响的python3，但是我用这个方法卸载了系统自带的那个。
但是openEuler依赖Python2.7、3.7环境。
结果就是yum、dnf命令不可用，找不到命令。
查看/usr/bin下的yum、dnf，指向的文件均为dnf-3，但是找不到该文件。
2-解决方法 全程使用rpm命令进行安装。
1.安装python3.7 rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-3.7.4-8.oe1.x86_64.rpm 检查安装结果
python3 -V
2.安装yum相关包 rpm -ivh --nodeps https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/yum-4.2.15-8.oe1.noarch.rpm rpm -ivh --nodeps https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/yum-metadata-parser-1.1.4-24.oe1.x86_64.rpm rpm -ivh --nodeps https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/yum-metadata-parser-help-1.1.4-24.oe1.x86_64.rpm rpm -ivh --nodeps https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/EPOL/x86_64/Packages/yum-langpacks-0.4.5-10.oe1.noarch.rpm 3.安装dnf相关包 rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/dnf-4.2.15-8.oe1.noarch.rpm rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/libdnf-0.37.2-2.oe1.x86_64.rpm 4.安装python3-dnf 为安装python3-dnf-4.2.15-8.oe1.noarch.rpm，需要先安装一些依赖包，然后再安装python-dnf。
rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-gpgme-1.13.1-5.oe1.x86_64.rpm rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-rpm-4.15.1-12.oe1.x86_64.rpm rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-libdnf-0.37.2-2.oe1.x86_64.rpm rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-libcomps-0.1.8-20.oe1.x86_64.rpm rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-hawkey-0.37.2-2.oe1.x86_64.rpm rpm -ivh https://repo.huaweicloud.com/openeuler/openEuler-20.03-LTS/everything/x86_64/Packages/python3-dnf-4.2.15-8.oe1.noarch.rpm 安装完成如下图所示。
5.查看版本 dnf --version yum --version 结果如下图，则证明安装完成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfa098fe13d5807a4328a07e02982512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f24c1abedf93f489b4b637dab714161/" rel="bookmark">
			堆排序 --- 向下调整算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉堆概念： 二叉堆是一种特殊的树结构，即一个父节点最多有两个子节点。且一个二叉堆一定是一个完全二叉树，即如果一个父节点有一个右孩子，则其一定有一个左孩子。
二叉堆又分为大堆和小堆：
（1）大堆：父节点上的数大于子节点上的数
（2）小堆：父节点上的数小于子节点上的数
代码实现： 该段代码实现重点在雨：向下调整算法、构造堆
--------------------------------------------------- ---------------------函数申明------------------------ typedef struct Heap { HpDataType* _array; int _size; int _capacity; }Heap; //向下调整算法 void AdjustDown(HpDataType* array, int size, int root); //向上调整算法 void AdjustUp(HpDataType* array, int child); //初始化堆 void InitHeap(Heap* pheap, int* array, int size); //销毁堆 void DestoryHeap(Heap* pheap); //堆尾插一个元素 void PushHeap(Heap* pheap, HpDataType x); //堆头删一个元素 void PopHeap(Heap* pheap); //取堆顶的一个元素 HpDataType TopHeap(HpDataType* x); --------------------------------------------------- ---------------------函数实现------------------------ //向下调整算法(时间复杂度为 log N ) [前提: 父亲下面的 子树 都是小堆或者大堆] void AdjustDown(HpDataType* array, int numsSize, int root) //[向下调整这里的numsSize 相当于给了一个调整的终止条件] //[向上调整可直接根据下标0来判断终止，因此参数要少一个] { int father = root ; //定义父节点 int child = father * 2 + 1; //定义左孩子 while (child &lt; numsSize) //一直向下调整到[父节点达到最下一层,即孩子节点下标越界] { //小堆[取两个孩子节点的更小值] if (child !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f24c1abedf93f489b4b637dab714161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf1d5e0c34c787610351528e3797fb2/" rel="bookmark">
			记录一次Unsupported Media Type解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者今天碰到一个问题，就是自身的一个接口被第三方的业务回调的时候出现了一个415的错误，也就是Unsupported Media Type。之后查了些资料，总结一下。
文章目录 一、415是什么错误？二、两种解决办法三、顺便记录一下常见的媒体格式类型 一、415是什么错误？ 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。
也就是说第三方发给己方服务器参数格式和服务器所要求的的参数格式不一样，比如第三方传的是’application/x-www-form-urlencoded;charset=UTF-8’（前端表单默认的格式，会将键值对的参数用&amp;连接起来，如果有空格，将空格转换为+加号；有特殊符号，将特殊符号转换为ASCII HEX值），而服务器需要的是json格式，这样就会出现415错误。
二、两种解决办法 主要有两种分别对应了服务端和客户端
服务端：调整接口接收参数的方式。比如要是接收的是json字符串格式的参数，就使用@RequestBody注解整体接收；接收用&amp;连接起来的参数则用@RequestParam注解一一接收。
客户端：调整上传参数的格式，按照接口需求的参数进行传递。
三、顺便记录一下常见的媒体格式类型 常见的媒体格式类型:
text/html ：HTML格式text/xml ：XML格式text/plain ：纯文本格式image/gif ：gif图片格式image/jpeg ：jpg图片格式image/png ：png图片格式 以application开头的媒体格式类型：
application/x-www-form-urlencoded ：form表单中默认的格式，form表单数据被编码为key/value格式发送到服务器。application/json ：JSON数据格式application/xml ：XML数据格式application/xhtml+xml ：XHTML格式application/atom+xml ：Atom XML聚合格式application/pdf ：pdf格式application/msword ：Word文档格式application/octet-stream ：二进制流数据（如常见的文件下载） 当然还有一个form表单中使用到的文件上传格式：multipart/form-data就不写到上述两类中去了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4bfaa07c748c55d8a3f0213e2593e7f/" rel="bookmark">
			2.9 /2.10算法时间复杂度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、常数阶O(1)
执行的次数恒定，不会随着n的变化发生变化，所以单纯的分支结构（不包含在循环结构中），其时间复杂度是O(1)。
2、线性阶O(n)
int i; for(i=0;i&lt;n;i++) { /*时间复杂度为O(1)的程序步骤*/ } 3、平方阶O(n2)/O(m*n)
int i,j; for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { /*时间复杂度为O(1)的程序步骤*/ } } int i,j; for(i=0;i&lt;m;i++) { for(j=0;j&lt;n;j++) { /*时间复杂度为O(1)的程序步骤*/ } } 4、对数阶O(logn)
int count=1; while(count&gt;n) { count=count*2; /*时间复杂度为O(1)的程序步骤*/ } 5、O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)&lt;O(n!)&lt;O(nn)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85a7ce9d15cfb4e9571f1a5e0daf20b/" rel="bookmark">
			VUE项目 ＜strong＞We‘re sorry but jingdongdaojia doesn‘t work properly without JavaScript enabled. Plea
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE项目 We’re sorry but jingdongdaojia doesn’t work properly without JavaScript enabled. Please enable it to continue.小白解决法 今天在做项目的时候，修改了一下router下的index.js文件，然后就报了这么个页面。其实也不是报错，就是页面全空。如图： 去网上翻了一圈，找到的结果如下 附上这位大神该条博客地址，如果我的方法解决不了，可以先去看看他的
都试了一个遍，发现没用。然后我去翻了文件目录，在默认的index.html中找到了一行非常眼熟的文字！
这就跟我的问题是一毛一样啊！！
我展开了大胆的猜想：肯定是我路径哪里没写对，所以项目用了默认的.(我的猜想是错的，最后能成功也是误打误撞！！！)
顺着这个思路，我去翻我的router目录下的index.js，果然是我犯了蠢！！！
我多加了括号，还不自知，编译器也没报错 ，就稀里糊涂的出了问题。修改过后，也能正常显示啦~
如图：
总结：
我真的太小白了，能解决全靠运气！
不知道有没有人跟我犯一样的错误，下回可以先找找这种细节问题。如果你没有去修改这么路由路径，之前能运行，后面一下子运行不了了，多半就是一些被忽视的小毛病
引以为戒！细心啊靓女！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e91c15ed14182eae97c817a5d88f08bf/" rel="bookmark">
			2.3 两种算法的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1+2+3+…+100 #include&lt;stdio.h&gt;
int main()
{
int i,m=0;
for(i=1;i&lt;=100;i++)
m=m+i;
printf("%d\n",m);
}
#include&lt;stdio.h&gt;
int main()
{
int m;
m=(1+100)*(100/2);
printf("%d\n",m);
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b3f5a56d108efdf53bf2e6002df2bec/" rel="bookmark">
			原生分页查询原理步骤解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、分页查询概述1.1、分页查询分类1.1.1、真分页1.1.2、假分页 1.2、分页效果 二、分页的设计2.1、分页需要传递的参数2.1.1、用户需要传入的参数2.1.2、分页需要展示的数据2.1.3、分页需展示的数据的来源 2.2、分页原理 三、分页查询实现3.1、访问流程3.2、分页参数的封装3.3、编写PageResult3.4、修改Mapper（Dao）3.5、修改Service以及ServiceImpl3.6、编写QueryObject3.7、编写测试类3.7、编写Servlet3.7、前台实现 一、分页查询概述 分页查询则是在页面上将本来很多的数据分段显示，每页显示用户自定义的行数。可提高用户体验度，
同时减少一次性加载，内存溢出风险。
1.1、分页查询分类 1.1.1、真分页 每次翻页从数据库中查询数据。
优点：不容易造成内存溢出。缺点：实现复杂，性能相对低。 1.1.2、假分页 一次性查询所有数据存入内存，翻页从内存中获取数据。
优点：实现简单，性能高。缺点：容易造成内存溢出。 1.2、分页效果 发送请求访问一个带有分页页面的数据，会发现其主要由两部分组成：
当前页的结果集数据，比如这一页有哪些商品信息。分页条信息，比如包含【首页】【上页】【下页】【末页】等。 二、分页的设计 2.1、分页需要传递的参数 2.1.1、用户需要传入的参数 currentPage：当前页，跳转到第几页，int 类型，设置默认值，比如 1。pageSize：每页最多多少条数据，int 类型，设置默认值，比如 10。 2.1.2、分页需要展示的数据 start：首页。prevPage：上一页。nextPage：下一页。totalPage：末页页码。totalCounts：总记录数。currentPage：当前页。pageSize：每页记录数。 2.1.3、分页需展示的数据的来源 来源于用户传入：
currentPage： 当前页，int 类型。
pageSize： 每页显示多少条数据，int 类型。
来源于两条 SQL 查询：
totalCount/rows： 数据总条数，int 类型。data/list： 每一页的结果集数据，List 类型。 来源于程序计算：
totalPage： 总页数/末页，int 类型。prevPage： 上一页，int 类型。nextPage： 下一页，int 类型。 2.2、分页原理 结果总数（totalCount/rows）和结果集（data/list）是来源于两条 SQL：
第一条SQL：查询总数，返回一个数字（总记录数）。 select count(*) from province 查询符合条件的结果集（返回一个结果集）。 # 他有两个参数，一个是起始页的页码，另一个是每页记录数 # start ：(currentPage - 1) * pageSize # pageSize： 前台给予 select * from province limit #{start} ,#{pageSize} 计算出其余的参数（总页数、上一页、下一页） // 分页数据通过这个构造器封装好 public PageResult(int currentPage, int pageSize, int totalCount, List&lt;T&gt; data) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b3f5a56d108efdf53bf2e6002df2bec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67df6f28c2217ebe4a52d87bed3be32b/" rel="bookmark">
			Android 11 调用手机系统摄像头新策略 IMAGE_CAPTURE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
android 11 调用系统摄像头有了新的策略，需兼容才可行
1、在Android11之前调用系统摄像头代码：
Intent captureIntent = new Intent("android.media.action.IMAGE_CAPTURE"); if (captureIntent.resolveActivity(this.getPackageManager()) != null) {} 2、在Android11之后，captureIntent.resolveActivity(this.getPackageManager())方法将返回null，导致调用相机失败。
Starting in Android 11, only pre-installed system camera apps can respond to the following intent actions: android.media.action.VIDEO_CAPTURE android.media.action.IMAGE_CAPTURE android.media.action.IMAGE_CAPTURE_SECURE If more than one pre-installed system camera app is available, the system presents a dialog for the user to select an app. If you want your app to use a specific third-party camera app to capture images or videos on its behalf, you can make these intents explicit by setting a package name or component for the intent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67df6f28c2217ebe4a52d87bed3be32b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/224644120339260c35847e7854ba9d2d/" rel="bookmark">
			Matlab编程用迭代有限差分求电势分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab编程用迭代有限差分求电势分布 题目要求 Matlab编程用迭代有限差分求电势分布，用程序画出等位线，求出电势以后用mesh()看2.5维分布，用旋转按钮来旋转2.5维立体图
分析： 此处的处理方法为有限差分迭代法，某点的电势 = 它周围四点电势的平均值， 在此思想下，我们可以写出如下程序，大致分析见如下代码及注释：
%设置矩阵大小，x:y = 10:5, 为方便处理边界条件，多加一行一列变为101、51 x_line=101;y_line=51; % v1和v2分别是一次迭代前的矩阵和迭代后的矩阵，先对它进行初始化 v1=zeros(y_line,x_line); for j=2:x_line-1 v1(y_line,j)=10;%设置边界条件 end v2=v1;m=1;t=0;k=0; %m即误差epsilon while(m&gt;0.00001) k=k+1 m=0; %对矩阵中的元素进行差分迭代 for i=2:y_line-1 for j=2:x_line-1; v2(i,j)=(v1(i,j+1)+v1(i+1,j)+v1(i-1,j)+v1(i,j-1))/4; t=(v2(i,j)-v1(i,j)); if(t&gt;m) m=t; end end end v1=v2; end subplot(1,2,1),mesh(v2) axis([0,x_line,0,y_line,0,10]) subplot(1,2,2),contour(v2,32) %可以认为mesh是2.5维， contour是2维 建议使用matlab中的实时脚本进行编辑，比较方便，可以得到结果为：
「含第二类边界条件的可以看我的另一篇文章：matlab差分迭代解决静电场边界问题（含第二类边界条件）https://blog.csdn.net/Mr_tea_milk/article/details/115328052」
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d306f6706c0bae6bf4962429a70bfd07/" rel="bookmark">
			下拉多选框multiple-select——2021-03-30
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下拉多选框插件multiple-select 取值回显
multiple-select插件网站：http://multiple-select.wenzhixin.net.cn/index.html?locale=zh_CN
用法：
1、动态添加选项、基本设置
注：二次定义下拉多选框时动态改变选项需先销毁再二次定义
$('#monthRepair').multipleSelect('destroy'); var option = [], monthValue = []; //替换原插件自带全选功能，实现全选复选框跟其他选项互斥 option.push({value: 'checkAll', text: '全年'}); for (var m = minm; m &lt;= maxm; m++) { var t = m &lt; 10 ? "0" + m + '月' : m + '月'; option.push({ value: m, text: t }); monthValue.push(m); } $('#monthRepair').multipleSelect({ allSelected: "全部", selectAllText: '全选', data: data //若不需要全选功能 //selectAll: false, //替换全选选项显示内容 formatSelectAll () { return '[全年]' }, //替换全选中是显示内容 formatAllSelected () { return '全年' }, }); 2、使用方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d306f6706c0bae6bf4962429a70bfd07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/262401b79298e4a712d89944197acaf1/" rel="bookmark">
			mybatis动态sql代码（增删改查）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态查询 方法一 if：如果条件成立则自动拼接内部关键字
where：
自动根据内部条件添加where关键字，如果内部条件为空则不添加where关键字，反之添加可以自动的去除前面的的多余的AND/OR关键字 SELECT * FROM student &lt;where&gt; &lt;if test="id != null"&gt; id = #{id} &lt;/if&gt; &lt;if test="name != null"&gt; and name = #{name} &lt;/if&gt; &lt;/where&gt; 方法二 prefix：如果内容不为空则拼接prefix中的内容
prefixOverrides：前缀覆盖，如果最前面是以AND/OR等关键字开头，则将该关键字替换为空格
suffix：后缀suffix给拼串后的整个字符串加一个后缀
suffOverrides：后缀覆盖，如果最后面是以AND/OR等关键字结尾，则将该关键字替换为空格
&lt;trim prefix="where" prefixOverrides="and" &gt; &lt;if test="id != null"&gt; and id = #{id} &lt;/if&gt; &lt;if test="name != null"&gt; and name = #{name} &lt;/if&gt; &lt;/trim&gt; 方法三 choose：相当于于java中的switch
when：相当于switch中的case
otherwise：相当于switch中的default
优先级：如果有多个则优先级为，从上到下，只执行一条
SELECT * FROM student &lt;where&gt; &lt;choose&gt; &lt;when test="id!=null"&gt; id = #{id} &lt;/when&gt; &lt;when test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/262401b79298e4a712d89944197acaf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/849ef816b0ecb5b358aef1c4ce2dcf34/" rel="bookmark">
			C&#43;&#43;中的引用‘&amp;‘和指针的区别，以及指针使用的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引用二、指针2.1 C++中指针使用的注意事项2.1.1 指针的危险 一、引用 C++中引用是用‘&amp;’符号表示的。引用在C++中不是对象（或者说某一类数据类型），他只是对变量起了一个别名。因此引用只能在声明的时候赋值。
int a = 10; int &amp;b = a; // 对a取一个别名叫b int &amp;c; //这显然是不允许的 c = a; // 这是不允许的 int &amp;d = 30; // 这是不允许的 b = 20; // 此时a的值也变为了20 别名的意思就是对对象取了一个另外的名字，因此用这个名字执行某些操作也就代表a去执行对应的操作，b改变，a也跟着改变了。就像一个人的名字叫张三，然后这个人又给自己取了一个别名叫张山。但是张三和张山依旧是同一个人。
二、指针 C++中指针就是指变量在内存中的地址，因此常称为指针变量。上述的‘&amp;’符号可以对变量取地址，而‘*’是取地址上存储的值，该符号称为解地址。
int a =1; int *b,*e; // 定义一个指针，因为没有初始化，所以该指针是不定值 b = &amp;a; // 将变量a的地址赋给b，此时b指向a的地址 *e = *b; // 将b指向的值，用‘*’解地址赋给e所指向的地址内存中 int c = 2; int* d = &amp;c; // 指针在定义时，就可以将c的地址初始化给d b = d; // 将d指向的地址赋给b，通常指针变量名即为指向 的地址 int* N = 0;// 将N指针初始化为空指针 int* N1 = nullptr;// 除了直接将指针赋值为0可以将指针设置为空指针外，还可以赋值为nullptr 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/849ef816b0ecb5b358aef1c4ce2dcf34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59a7bc9867fe33c9b3f26be2772181af/" rel="bookmark">
			程序员客栈(项目简介)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序员客栈(项目简介) Gitee地址：https://gitee.com/ShenJinyong/programmer-inn
一、介绍 程序员客栈的初衷是为了解决入门程序员没有一个很好的练手的项目的问题，她集齐各种市面上比较常见各种系统，比如：个人博客系统、员工管理系统和图书管理系统等。我希望她不仅能够巩固我所学知识，也希望她作为教程供后来人成长，未来的发展是希望她可以愈来愈完善，期待各位一起补充…
大家好！作为一名学生党，课堂学到的技术有限，而课后自学以简单的视频为主，各种博客为辅。总而言之，言而总之，所学终归有限。迷茫良久，兜兜转转，终于下定决心要开发一个自己的项目。其实，从有这个想法之后，有很多次都想开始，但是万事开头难。放弃了很多次，但一旦开始，除非不可抗拒因素，我会一直更新写下去。一方面是为了自己的技术真正的融合到实践中从而提升，另一方面是对技术的最求，为了自己未来的道路。程序员客栈是一个纯粹为教程而生的原型，可以视为一个简陋的带后台的门户网站。
在开发的过程中，脱离那种依葫芦画瓢式的学习，通过自己去看文档，真正的把知识理解并运用，建立起自己的知识体系，消除自己对未来的迷茫。当然，每个人的理解方式不同，希望大家可以友善白嫖，开源不易，欢迎Star。
二、软件架构 说明：程序员客栈有独立的前台、后台以及客户端
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-TJuQuB9r-1617019654960)(E:\Users\Jinyong\Desktop\系列文章\img\programer-inn.png)]
三、技术栈 在开发过程中还会不断用到一些新的技术，会慢慢补充
1.前端 Vue 2.后端 SpringBoot 微服务 3.数据库 MySQL 四、项目演示 1.项目地址 https://gitee.com/ShenJinyong/programmer-inn
2.项目演示 前台：https://gitee.com/ShenJinyong/programmer-inn/tree/master/programer-inn-client
后台：https://gitee.com/ShenJinyong/programmer-inn/tree/master/programer-inn-admin
用户名：admin密码：123456 后端：https://gitee.com/ShenJinyong/programmer-inn/tree/master/programer-inn-server
开源不易，欢迎Star
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94a3675597c832495f62226ed26ffba1/" rel="bookmark">
			零信任提升组织的数字安全性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 组织越来越多地实施零信任策略以增强其数字安全状况。根据《信息安全杂志》的统计，有15％的组织表示他们在2019年底之前实施了零信任策略。另有59％的参与者表示，他们打算在未来12个月内实施。
要了解为什么如此众多的组织涌向零信任，首先要深入了解零信任策略的好处。看看它如何帮助企业应对不断演变的数字安全挑战。只有这样，才有可能权衡零信任安全的优点和缺点，以便组织可以建立有效的零信任策略来满足其安全性和业务需求。
什么是零信任？ 零信任是一种以限制对敏感数据访问的法律为基础的数字安全方法。零信任通过默认情况下不信任任何用户、设备或帐户来实现这一点。这种方法要求安全团队验证并授权与企业内部以及整个企业之间的每个连接。
在这个框架中，零信任响应了数字安全挑战的演变，而不是传统的外围安全模型所能提供的。这样古老的安全理念基于这样一个假设：威胁来自网络外部，所有内部用户，设备和应用程序都可以被信任。随后，组织可以简单地部署防火墙，虚拟专用网络（VPN）和网络访问控制（NAC），以便将计算机犯罪分子拒之门外，同时为内部用户提供不受限制的网络访问权限。
但是，时代已经改变。许多组织已经经历了数字化转型的过程，在这些过程中，他们已经将部分资产迁移到了IT无法直接控制的云基础架构中。他们还将远程访问扩展到供应商，承包商，销售公司和全职员工，以寻求增强灵活性和适应未来业务挑战的能力。
COVID-19的出现就是一个例子。为了应对这种大流行，许多组织都要求其员工开始在家中工作以产生社会距离。由于无法访问办公室资源，这些远程工作的员工别无选择，只能使用家庭网络和设备完成工作。这种转变迫使企业将更多的工作负载迁移到云端，以容纳所有这些远程连接，这一举措引入了更多需要验证的一对一网络交互。
权衡零信任的优势和劣势 零信任的主要好处在于其从头开始建立信任的理念。安全团队主要授权哪些可以连接到业务，而不允许所有其他连接。通过此方法，安全专业人员可以获取与组织连接的所有内容的可见性并删除不受信任的访问点来减少组织的受攻击面。它还需要使用其他数字安全控件来提供上下文并限制该连接可以访问的内容，持续验证该连接的完整性。
然而，零信任安全确实伴随着许多挑战。其中许多障碍都是由有助于减少外围安全模型的相关性的相同发展造成的。组织不能简单地定义关于网络的内部/外部二进制文件中的信任。Threatpost建议扩展他们对信任的理解。这里有五个不同的方面：设备，用户，网络访问，应用程序和数据。
值得花一些时间探讨信任与以下各个方面之间的关系：
设备：安全团队无法保护他们所不知道的东西。尽管如此，他们需要有一种方法来建立环境中所有硬件和软件的库存。此外，他们必须具备能够根据安全策略监控和控制所有经批准的设备的能力。然后，他们可以利用这种能力来拒绝未经批准的设备。用户：一组凭据提供了对用户进行身份验证的方法。但是，黑客可以破坏用户名和密码，从而通过在受保护的系统上进行身份验证来冒充用户。因此，组织必须实施更安全的用户身份验证和标识方法，这些方法使用上下文和其他安全措施来帮助进一步尝试登录验证的个人。网络访问：用户一旦获得对系统的访问权限，就不应该获得外围安全模型所授予的相同类型的无限访问自由。否则，他们可能选择访问敏感资产，从而危害组织的数据。为了降低与内部威胁和其他数字攻击相关的风险，组织需要限制用户可以访问的内容。他们应特别限制用户只能访问其履行工作职责所需的那些网络资产。应用程序：组织必须确保用户可以从任何经批准的设备访问工作所需的应用程序。这个过程与第一点有关，即建立已知硬件和软件的库存。为了有效，该计划应考虑到承包商，供应商和其他第三方可能造成的临时连接。数据：最后，组织需要确保数据仍然受到保护。此步骤使他们不仅可以确保其数据的完整性，以便整个工作人员都可以使用正确的信息。它还要求安全团队实施解决方案，以防止黑客从网络外部获取正确的数据并将其用于恶意目的。 如何建立零信任网络 组织可以通过首先确定他们需要多少零信任来开始建立零信任策略。现实情况是，不可能在整个组织中实现100％的零信任。IT体系结构的变化；每天都会增加新的用户，应用程序和资源；业务目标不断发展。零信任应该专注于阻止你能做的事情，这样你就可以将安全工作集中在更复杂的问题上，而不必承担业务费用。
组织应对其安全工作具有战略性。在攻击面而不是保护面上建立零信任，即组织最有价值的数据，应用程序，资产和服务。客户的信用卡详细信息，受保护的健康信息，知识产权，工业资产，医疗设备和IoT设备通常属于此类。
如果组织希望建立提供足够保护水平的零信任网络，则组织必须了解流量在其网络中的移动方式。随后，他们的安全团队需要记录特定数据资源如何与其他资产进行交互。完成此步骤将产生上下文。从那里，安全团队可以开始创建新的安全策略并修改现有策略以适应零信任。
在此阶段，组织可以构建零信任网络的体系结构。他们应该首先使用下一代防火墙来实现微分段。这将允许他们隔离并安排其网段。它还将有助于限制攻击者滥用东西方流量以在整个网络中横向移动的目的，尽管这并不一定会阻止他们首先通过南北流量进入网络。创建了这些网段之后，组织便可以开始实施必要的安全控制以实施零信任。
Help Net Security指出，组织尤其应在此阶段部署六个安全控件：多因素身份验证（MFA），设备验证，最小特权原则，网络监控和基于属性的控制。下面提供了有关这些安全措施如何工作的更多信息。
MFA： 一组受损的凭据可能会使黑客具有将自己身份验证为受信任用户的能力。然后，他们可能滥用该用户的特权来在网络中移动并访问敏感资产。作为回应，组织应寻求实施MFA，以便在用户验证过程中增加另一个因素。在实施针对零信任的MFA时，组织应考虑在零信任策略内为所有远程接入点部署MFA，以及使用支持生物特征行为分析的MFA解决方案。设备验证： 组织不能固有地信任受信任用户访问的每台设备。即使用户可能值得信任，但他们的设备也可能构成安全风险。这就是为什么安全团队必须单独验证所有设备，以及提供对已批准资产状态的持续跟踪。最小特权原则： 并非每个用户都需要访问组织的财务记录。任何用户也不应事先授权审查本组织的知识产权。认识到这些现实，各组织应通过限制用户对其工作职能必不可少的网络访问来执行最低特权原则。网络监控： 有时网络中发生意外活动。这种行为本质上可能是良性的。但是，有可能是恶意活动的迹象。这就是组织需要通过记录和分析网络流量来实现网络可见性的原因。安全团队还应该使用诸如行为分析之类的工具，将异常的用户行为与已知的威胁指标相关联。基于属性的控制： 组织必须具有一种实时阻止可疑事件的方法，这一点很重要。这就是基于属性的控制的用处。通过基于与用户，资源，设备等相关联的属性创建安全策略，安全团队可以从根本上创建基于策略的访问，在其中执行自动化网络连接。社区参与： 随着组织继续微调其零信任安全控制，他们应该与所有用户和部门合作，创建考虑到他们的需求和偏好的安全策略。这应该是一个过程，而不是一个明确的行动方针。组织应不断修订安全策略，以应对威胁形势的发展以及企业及其员工不断变化的安全需求。作为正在进行的过程的一部分，组织还应该使用安全意识培训计划来教育所有用户这些安全措施。 有了这些基本控制措施，组织就可以最终确定其零信任治理模型。这就要求他们使用监控解决方案和自动化功能，以便他们能够尽快响应事件。还需要随着组织需求的变化以及网络的不断发展，不断衡量，审查和改进其零信任网络。
与时俱进 组织可以信任网络中存在的任何东西的时代已经一去不复返了。零信任伴随着公平的挑战。但是组织不必为了开始实现它的好处而一次实现这个原则的许多方面。与任何安全措施一样，归结为每个组织如何确定优先级并实施其零信任策略，以及如何随着时间的推移并以最能支持其业务增长的方式推进该策略。
文章来源: https://securityintelligence.com/articles/zero-trust-boost-digital-security/
关于我们 「龙归科技」 是一个专注于低代码赋能企业级信息化服务提供商。核心创始人团队来自绿盟安全、红帽开源操作系统、知名游戏玩蟹科技、知名开源社区等专家共同创立。
「龙归科技」 致力于让中国每一个企业拥有专属的自动化办公操作系统，助力企业或政府拥抱 （Cloud Native First）云原生优先战略，帮助客户构筑以「身份与应用」为中心的现代化 IT 基础设施！从而实现 「数字化转型」 及 「软件行业工业化生产」 ！
主打产品：ArkOS方舟操作系统：一个企业级办公自动化操作系统 ，结合自研低代码应用开发平台，构建产业生态，专注为各类企业与组织机构打造一体化全栈云原生平台。系统自带应用包括：ArkID 统一身份认证，ArkIDE，ArkPlatform，App Store 等产品。截至目前，公司已经获得 15个 软件著作权、2个发明专利，并与2020年11月份，获得北京海淀区中关村国家高新技术企业认定。
相关链接： 官网：https://www.longguikeji.com/
文档：https://docs.arkid.longguikeji.com/
开源代码仓库地址：
https://github.com/longguikeji
https://gitee.com/longguikeji
历史文章
登录的轮子，你还在造？企业级单点登录——信息化体系建设基础远程办公，你准备好了吗？企业信息化，怎样才算数？龙归科技 | 对未来的若干猜测龙归科技 | 企业办公自动化的未来龙归科技 | 软件的成本下降 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6da8452c3f00af94808360351832c0f/" rel="bookmark">
			QR码原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整篇文章中所有截图插入进来的表和图片都用黄色文本做了标记，其他没有直接插入进来的表和图片请在下方链接资源中查找：
资源一：QRCode国家标准.doc
资源二：QRCode 二维码编码解码标准附录.pdf
简介：QR 码是二维码的一种，QR来自英文 “Quick Response” 的缩写，即快速反应的意思，源自发明者希望 QR 码可让其内容快速被解码。它是在1994年由日本的原昌宏研究小组发明的，最初应用在汽车生产、追溯方面，如今已成为众多二维码种类中应用最为广泛的一种。
QR码的显著优点：
1.存储内容大
QR码存储内容的多少与其版本有关，版本越高其可存储的内容也就越多，看上去也就越复杂。
有关QR版本与存储量可参考链接资源一中的表7~11
2.存储内容类型丰富
QR码支持存储多种语言和数字、字母，如中文、英文、德文、韩文等，由于QR码是日本研发的二维码，因此更适合处理日文字母和汉字。在日语处理方面，每一个全角字母和汉字都用13bit的数据处理，效率较高，与其他二维码相比，可以多存储20%以上的信息。
3.占用空间小
QR码在二维空间中处理数据，在处理相同信息量的条件下，QR码所占空间为条形码的十分之一左右。另外QR码还有一种类型叫Micro QR码，可以在更小空间内处理存储数据。
4.抗污损能力强
QR码具有“纠错功能”。即使编码变脏或破损，也可在一定程度上恢复数据。它提供了4种纠错等级，随着纠错等级的提高，可恢复的码字比例也随之增加。有关QR码纠错特性可参考链接资源一中的表13~22。
5.容易读取
每一个版本的QR码中都有三个寻像图形，因此无论从哪个方向进行扫码，都可以不受背景样式的影响，实现快速稳定的读取。
6.支持数据合并功能
QR码可以将数据分割为多个编码，最多支持16个QR码。使用这一功能，还可以在狭长区域内打印QR码。另外，也可以把多个分割编码合并为单个数据。
文章目录 QR码版本QR码的结构寻像图形&amp;位置探测图形位置探测图形分隔符定位图形校正图形格式信息版本信息扩展图形 QR码的编码流程数据分析数据编码纠错编码构造最终信息在矩阵中布置模块掩膜格式和版本信息 QR码版本 QR码共有40种版本（版本1~版本40），其中版本1的模块数为21×21，随后每增加一个版本，每边的模块数各增加4，因此版本40的模块数为177×177。
QR码的结构 一个 QR 码可以分为两个部分：功能图形和编码区域。
为了更加方便的说明QR码每个部分的结构，这里用版本7来进行展示。
版本7的模块数为45×45，行列数坐标均从0开始计算。
图1：QR码为版本7时的结构
寻像图形&amp;位置探测图形 作用：协助扫描软件定位 QR 码并转换坐标系。
寻像图形包括三个相同的位置探测图形，分别位于整个图形中的左上角、右上角、左下角，每个位置探测图形由7×7个模块组成。符号中其他地方遇到类似图形的可能性极小，因此可以在视场中迅速地识别可能的 QR 码符号。当版本号越高时，寻像图形在整个图案中所占比例越小。
寻像图形在图1中呈现为黑色区域。
位置探测图形分隔符 作用：区分功能图形和编码区域。
每个位置探测图形和编码区域之间有宽度为 1 个模块的分隔符。位置探测图形分隔符在图1中显示为灰色区域，此区域应全为空白，不能填入数据。
定位图形 作用：确定符号的密度和版本，提供决定模块坐标的基准位置。
定位图形在图1中显示为茶色区域，水平和垂直的定位图形分别始于第6行和第6列（行、列由0开始计数）。
！！! 但是由于坐标（6，6）在前者已经用黑色表示为位置探测图形，所以在此没法再用茶色表示。但是请记住，（6，6）才是定位图形的开始坐标。另外，第6行和第6列中有6个水绿色的部分也是定位图形。
定位图形由深色与浅色模块交替组成，其开始和结尾都是深色模块。
校正图形 作用：在图像有一定程度损坏的情况下，译码软件可以通过它同步图像模块的坐标映像。
校正图形的数量视符号和版本号而定，版本1没有校正图形，版本2及以上均含有校正图形。
校正图形的具体位置参考链接资源二的附录E。
例如在版本7中，中心模块行/列坐标值为6，22，38。则表示中心模块可能出现在（6，6），（6，22），（6，38），（22，6），（22，22），（22，38），（38，6），（38，22），（38，38）这几个位置中。由于（6，6），（6，38），（38，6）这三个位置都摆放了位置探测图形。所以中心模块只可能出现在剩下的6个坐标中。
校正图形在图1中显示为水绿色区域，它是固定的参照图形，每个校正图形由5×5模块组成。因此只要知道了中心模块的坐标即可推出校正图形的具体位置。
格式信息 作用：用于存放纠错等级和掩模信息。
格式信息在图1中显示为深蓝色区域，是一个 15 位数据，由 2位纠错指示符 + 3位掩模图形参考 + 10位纠错码组成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6da8452c3f00af94808360351832c0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/349c5dcc2d2fa80cf474f4f7d9986b4f/" rel="bookmark">
			android 11.0 增加控制状态栏和导航栏的接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		增加控制状态栏和导航栏的接口，代码如下
.../statusbar/NavigationBarController.java | 6 +- .../phone/NavigationBarFragment.java | 9 +- .../statusbar/phone/PhoneStatusBarView.java | 7 +- .../systemui/statusbar/phone/StatusBar.java | 31 +++- packages/apps/Settings/AndroidManifest.xml | 61 ++++++- .../ShellSettingsBroadcastReceiver.java | 163 ++++++++++++++++++ 6 files changed, 262 insertions(+), 15 deletions(-) mode change 100644 =&gt; 100755 frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/NavigationBarController.java mode change 100644 =&gt; 100755 frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/NavigationBarFragment.java mode change 100644 =&gt; 100755 frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBarView.java mode change 100644 =&gt; 100755 frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java create mode 100755 packages/apps/Settings/src/com/android/settings/ShellSettingsBroadcastReceiver.java diff --git a/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/NavigationBarController.java b/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/NavigationBarController.java old mode 100644 new mode 100755 index 8c24c540e7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/349c5dcc2d2fa80cf474f4f7d9986b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c93eb048f1c42b63a042300daced06f0/" rel="bookmark">
			Shiro——Bug篇——AuthenticationException 异常无法自定义返回值结果集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 刚接触到公司的项目时候，项目内没有权限框架这一块，后面项目成型之后引进权限框架shiro。 问题描述： 引进shiro后续发现一些问题，抛出AuthenticationException异常后，未能统一自定义返回结果集，前端未能接收到之前约定的状态码，导致token过期之后，结果集是shiro内部抛出的，后面导致前端访问后台所有的接口抛出次异常。
后续在全局自定义捕获器内增加此异常的捕获，发现根本捕获不了；在网上找了很久，都没有发现很好的解决方案，我都准备把shiro换成security（在security内可以实现AuthenticationEntryPoint接口， 重写commence方法后，返回项目内统一的结果集），后续想到一种方式，准备再挣扎一下 o(╥﹏╥)o 。
{ "timestamp": "2021-03-29 13:15:44", "status": 500, "error": "Internal Server Error", "message": "token非法无效!", "path": "/knowledgeBaseContent/list" } 异常信息：org.apache.shiro.authc.AuthenticationException: token非法无效! 原因分析： AuthenticationException 异常时Shiro内部进行抛出的，全局异常捕获器在 Filter 之后执行，不能正常进行补捕获，只能在 Filter内部进行处理。
解决方案： 项目内部集成shiro时，自定义Filter继承了BasicHttpAuthenticationFilter，重写登录认证的时候进行返回结果集的处理，通过ServletResponse 返回统一的结果集就行了 ，下面贴代码。、
JwtFilter——自定义Filter /** * 执行登录认证 * * @param request * @param response * @param mappedValue * @return */ @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { try { executeLogin(request, response); return true; } catch (Exception e) { /*自定义返回结果集*/ ServletUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c93eb048f1c42b63a042300daced06f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf6d84e74afdbbf342226fa1ea43910/" rel="bookmark">
			AndroidRecyclerview嵌套Recyclerview滑动冲突的解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当Recyclerview嵌套recyclerview滑动子布局是本应该是子布局在滑动，现象却是父布局在滑动。出现这种情况的原因就是事件没有分发到子view。解决这个问题就需要了解android事件分发的机制。
1.Android事件分发的机制 Android事件分发机制要研究的对象是MotionEvent即点击事件。点击事件就是手指触摸到屏幕出现的一系列事件
ACTION_DOWN:手指刚接触到屏幕
ACTION_MOVE:手指在屏幕上移动
ACTION_UP：手指从屏幕上离开的瞬间
点击事件的分发也就是MotionEvent的传递。产生MotionEvent后将其传递给一个具体的View.
public boolean dispatchTouchEvent(MotionEvent ev)
用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回的结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法影响，表示是否消耗当前事件。
public boolean onInterceptTouchEvent(MotionEvent ev)
在dispatchTouchEvent(MotionEvent ev)方法内部调用，用来判断是否拦截某个事件，那么在同一个事件系列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。
public boolean onTouchEvent(MotionEvent ev)
在dispatchTouchEvent(MotionEvent ev)方法中调用，用来处理点击事件，返回的结果表示是否消耗当前事件，如锅不消耗，这在同一个事件系列中，当前View无法再接收到事件。
当一个点击事件产生后，他的传递顺序是Activity-&gt;window-&gt;view.事件经过activity window，传给顶级view,顶级view再将事件按照传递规则传给子view
2.解决方法 通过以上了解基本知道子Recyclerview不会滑动是因为父Recyclerview消耗了点击事件。所以要解决该问题就是让父Recyclerview将事件传递下来。
1.自定义父Recyclerview让其不要拦截事件。
重写onInterceptTouchEvent()方法。`public class ParentRecyclerView extends RecyclerView {
public ParentRecyclerView(@NonNull Context context) { super(context); } public ParentRecyclerView(@NonNull Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public ParentRecyclerView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); } //return false 不拦截，继续分发下去 @Override public boolean onInterceptTouchEvent(MotionEvent e) { return false; } }`
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf6d84e74afdbbf342226fa1ea43910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53d40bf8eeaacbf52257113acf8c6354/" rel="bookmark">
			Computed property “value1“ was assigned to but it has no setter.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写 Vue 项目时出现了以上报错信息，特此记录
computed: { value1() { return this.value }, } 意思是说：我在计算属性里修改 value1 这个属性时，没有使用 setter ，导致报错
改成以下写法即可
computed: { value1: { get() { return this.value }, set(value) { } }, } 此时属性值已不再是函数写法，变成了对象，其中必须包含 getter 和 setter 两个方法
我使用 getter 先获取到了传过来的 value 值，然后当 value 值发生变化后，由 setter 方法时时改变 value1 的值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/063094b42fa3767323e9beb693acb6cc/" rel="bookmark">
			cisco |  internet搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引导 拓扑图步骤内网1.把端口打开2.使用vtp划分vlan交换机之间改为trunk将三层交换机设为server，普通交换机设为client创建vlan将client的普通交换机的端口划分到各自的vlan中跨vlan互相ping一下 外网1.给端口配上ip地址2.在路由器上将网络发布出去（动态路由） 使内网能ping通外网添加两个重要的网段在路由表上NET技术 拓扑图 步骤 内网 1.把端口打开 打开前
打开后
Switch(config-if)#no shutdown //开启端口 2.使用vtp划分vlan 交换机之间改为trunk Switch(config-if)#switchport mode trunk 需要改变的端口:
show running-config(检查一下端口是否已经改为trunk)
将三层交换机设为server，普通交换机设为client 创建vlan 检查一下(三层交换机和client的普通交换机都要检查一下），如果发现vlan缺少要及时检查哪里出了问题
Switch#show vlan 将client的普通交换机的端口划分到各自的vlan中 依旧要用show vlan来检查一下是否划分成功
注意：VLAN 2的端口直接在三层交换机上划分即可
跨vlan互相ping一下 哟！ping不通
这里很多人的问题是三层交换机没有打ip routing来启动三层交换机的路由功能。
跑个包看看
好像找到原因了，vlan的网关忘记设置了
在三层交换机上进行
Switch(config)#interface vlan 10 Switch(config-if)#ip address 192.168.8.1 255.255.255.0 \\其他vlan配置类似 再ping一下
果不其然
Switch(config)#ip routing //启动三层交换机的路由功能 Switch(config)#int f0/3 Switch(config-if)#no switchport //交换机是二层设备，这个命令能对f0/3进行IP地址设置 Switch(config-if)#ip address 172.16.2.1 255.255.255.0 //这样vlan2应该就能被ping通了 至此，内网配置差不多就结束了。
外网 1.给端口配上ip地址 要注意的是，三层交换机上要配置ip地址的端口需要no switchport命令。另外，路由器之间要使用ppp协议。
Router(config-if)#encapsulation ppp Switch(config-if)#no switchport 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/063094b42fa3767323e9beb693acb6cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533cf7392f5265a53d93e3288b2d210a/" rel="bookmark">
			Swagger和SpringFox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swagger和SpringFox 最受欢迎的API文档规范之一是OpenApi，以前称为Swagger。
它允许您使用JSON或YAML元数据描述API的属性。
它还提供了一个Web UI，它可以将元数据转换为一个很好的HTML文档。
此外，通过该UI，您不仅可以浏览有关API端点的信息，
还可以将UI用作REST客户端 - 您可以调用任何端点，指定要发送的数据并检查响应。
它非常方便。
然而，手动编写此类文档并在代码更改时保持更新是不现实的。
这就是SpringFox发挥作用的地方。
它是Spring Framework的Swagger集成。
它可以自动检查您的类，检测控制器，它们的方法，它们使用的模型类以及它们映射到的URL。没有任何手写文档，只需检查应用程序中的类，
它就可以生成大量有关API的信息。
多么酷啊？最重要的是，每当您进行更改时，它们都会反映在文档中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75a93fc2a09df0ec4b0818df5fd8a15d/" rel="bookmark">
			假设检验的P值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假设检验的P值 统计学中的假设检验P值相信很多人很困惑
真正的大师 话说的都很简单，不容易理解。还有的正话反说，感觉故意给人造成麻烦。
像上边的拒绝为真错误的实际概率
其实是 拒绝为真导致犯错的实际概率。
在我理解就是
P值就是 原假设正确的概率。比如P值是0.05，就是5%的概率原假设正确。
或者说拒绝原假设从而犯错的概率。比如P值是0.05，就是有5%的概率，因拒绝原假设从而犯错。拒绝带来的犯错概率很小，所有要拒绝。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96202878d9fd6cfb8496e11d5702cb59/" rel="bookmark">
			关于Go语言中的迭代变量的分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 迭代变量的使用，在立即执行的函数中，一般是不会显现问题的，但是在延迟执行的函数中，就会出现致命的问题。
立即执行的情况 当然，这种例子有很多，这里举一个非常简单的例子分析一下。场景需求：将silce内的数字迭代输出即可。
package main import "fmt" func main() { var numsSilces []int for i:=0; i&lt;10; i++ { numsSilces = append(numsSilces, i) } for _, num := range numsSilces { fmt.Println(num) } } 这样的程序运行无任何问题，输出0-9
延迟执行的情况 一般说到延迟运行，在Go语言中，使用较多的是defer这个关键字，这里主要是以较为特殊的例子进行说明。代码见下：
package main /** 主要涉及到go语言中的迭代变量的捕获 */ import "fmt" func main() { var handles []func() var numsSilces []int for i:=0; i&lt;10; i++ { numsSilces = append(numsSilces, i) } for _, num := range numsSilces { handles = append(handles, func() { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96202878d9fd6cfb8496e11d5702cb59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa25ed22ef47b3cf3633bef3c27651e/" rel="bookmark">
			BGP------BGP工作原理、BGP属性及选路原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BGP工作原理 一、BGP报文 1.open报文 作用：建立邻居、协商参数
open报文只在邻居建立时发送，不会周期发送
内容： version：BGP版本My AS：自身的AS号hold time：超时时间 180S，取最小的数值 BGP Identifier：BGP的router id拓展能力参数 多协议能力支持(Multiprotocol extensions capability) IPv4(主地址簇/AFI) 单播（子地址簇/sub AFI） 默认支持：ipv4-family unicast组播（子地址簇/sub AFI）VPNV4（子地址簇/sub AFI）ipv4-family vpnv4 需要配置mpls vpn后会出现 IPV6(主地址簇) 单播（子地址簇/sub AFI） 路由刷新能力(Route refresh capability) 默认支持是否支持4字节AS号(Support for 4-octet AS number capbility) 华为设备默认支持ORF出方向路由过滤 (需要手工配置) 影响BGP邻居建立的因素 1.version需一致
2.My AS：收到报文中的My AS与在BGP进程下配置的该peer的as-number一致
3.BGP Identifier不能一致
4.扩展能力参数
IPv4(主地址簇/AFI)需一致路由刷新能力不影响4字节AS号不影响 5.认证
2.keepalive报文 作用： 维护邻居关系，用于对open报文的确认
发送间隔：60S 超时时间：180S
HOLD TIME时间决定keepalive报文的存活时间
3.update报文 作用：BGP路由更新报文，用以更新BGP路由信息 或者 撤销BGP路由信息
携带丰富的路径属性描述路由(origin、AS path等)
发送方式：
邻居建立成功后
触发更新：network、import路由进入BGP
收到路由刷新报文(router refresh报文)
携带：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa25ed22ef47b3cf3633bef3c27651e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c085f1603e1bc3572460c5c815b21d84/" rel="bookmark">
			浏览器中的Network中有请求但是没有到后台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 浏览器中的Network中有请求但是没有到后台 记录一个奇怪的问题在上周 做一个前后端分离的项目是 前端有请求即 network中有请求记录但是请求没有到后台 前度刷新一下页面 这个请求才能到后天 这里注意一下 这个项目是在本地环境中启动的 所以不存在 cdn 缓存 而且这个请求 的响应里还有一个请求的的当前时间 也就是说每次请求 响应的数据都有所不同 但是还是出现的 这个问题 .
最后发现禁用缓存后发现没有了这个问题
最终的处理方案是
禁用缓存 headers: {‘Cache-Control’: ‘no-cache’} axios
axios.get('你的接口', {headers: {'Cache-Control': 'no-cache'}}) 或
const http = axios.create({ headers: {'Cache-Control': 'no-cache'} }) ajax
反正大同小异自己去试
ajax.get('你的接口', {headers: {'Cache-Control': 'no-cache'}}) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0643622ce29b9240b336b55048fd2b4d/" rel="bookmark">
			4-Web安全——通过x-forward-for获取真实ip（入侵溯源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料：44-http协议
x-forward-for是http请求的一个字段，该字段表示客户端的IP地址，一般称为“XXF”头，服务端通过这个头可以知道客户端的真实或代理IP。x-forward-for字段虽然没有写入RFC标准，但已经应用到http协议中成为一个实施标准了。
x-forward-for字段的格式为：
x-forward-for:client1,proxy1,proxy2,proxy3 该字段的ip地址值以逗分隔，其中client1代表真实的客户端的ip地址，代理服务器每成功收到一个请求，就把请求来源IP地址添加到右边，最末端的服务器收到http请求得到这样一个ip地址列表：client1,proxy1,proxy2,proxy3，可以这个http请求经过了三个代理服务器，最左边的ip就是真实的客户端ip地址。
在进行入侵溯源的时候往往可以通过x-forward-for字段溯源到攻击者的真实ip地址。
但事实上攻击者并不会这么容易暴露自己的真实ip，攻击者会在一开始就修改x-forward-for字段在最前面伪造一个ip地址wzip。最终得到的ip是这样的：x-forward-for:wzip,clientip,proxy1,proxy2,proxy3。
由于x-forward-for字段最左边的ip就是真实的客户端ip地址，我们在进行溯源时得到的客户端“真实ip”是wzip，并不是真正的clientip，从而掉进攻击者的陷阱。
那如何溯源到攻击者真实的ip呢？
我们知道http的整个请求过程中需要经过客户端--&gt;代理服务器1---&gt;代理服务器2--&gt;最终的服务器。从安全的角度来说，最不安全的因素就是人，在这个过程中：
客户端不可控的
代理服务器是可控的
最终的服务器可控
对应的解决方案就是对代理服务器和最终的服务器进行防御，我们可以通过nginx的http模块的X-Forwarded-For对最外层的代理服务器进行配置：
proxy_set_header X-Forwarded-For $remote_addr; remote_addr表示对x-forward-for字段中的ip地址进行覆盖，就是最外层代理服务器不信任客户端的 X-Forwarded-For 输入，直接覆盖，而不是追加。
非最外层的 Nginx 服务器，配置：
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_add_x_forwarded_for表示对x-forward-for字段里的ip地址内容进行追加。
而在最终的服务器里我们可以根据代理服务器的数目来进行获取真实ip地址，例如上面这个例子中的代理有三层，假设得到的ip地址为：
x-forward-for:wzip,client1,proxy1,proxy2,proxy3 从右开始排除三个代理服务器的ip，最终确定client1就是攻击者真实的ip地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfaf68c8af45c68c28a6da0b8c88b2dc/" rel="bookmark">
			SAR ADC和sigma delta ADC的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0、ADC基本概念
1、SAR的描述
2、sigma delta ADC（Σ-Δ ADC）的行为描述
3、优劣对比
4、应用场景区别
0、ADC基本概念 ADC，即analog to digital converter，模拟到数字的转换器，简称模数转换器。
为什么需要ADC？因为现实的世界中，电信号是连续的，例如心电信号，或者声音信号，这些连续的信号被称为“模拟信号”。
图1：心电信号
图2：声音信号
然而这种连续的信号是无法被计算机处理的，计算机只认识0和1组成的“数字信号“。ADC就充当了这样一个桥梁，将“模拟信号”转换为计算机能识别的“数字信号”。举个例子，当前的心电电压为1.2V（实际没有这么高），ADC可能会得到一个1001的结果；下一个时刻，心电电压为1.3V，ADC可能会得到1010的结果。
ADC的性能一般有两方面的体现，一是速度，或者叫采样率，例如100KSPS（kilo samples per second），就代表每秒能够对外部信号转换多少次。二是精度，或者说位数，常见的8位到32位都有。8位ADC，就代表该ADC有2^8=256个分辨台阶，16位ADC，就代表该ADC有2^16=65536个台阶，精度远远高于8位的ADC。
假如规定整个电压范围为10V，则8位ADC的步长为10V/256=39mV，16位ADC的步长为150uV。这样，假如信号变化了150uV，16位ADC的量化结果马上就发生了变化，而8位的ADC仍然无动于衷，对它而言信号并没有改变。
工业上常见的两种ADC，分别是SAR和sigma delta ADC，下面将简单描述并对比。
1、SAR的描述 SAR，就是successive approximation register（逐次逼近，寄存器），其主要的思想是逐次逼近，它名字里之所以有“register”，是因为在“逐次逼近”的过程中，结果都存放在寄存器里。
直观模型
以称体重举例子来说明逐次逼近。我家的体重秤是砝码式的，我有一组砝码：200斤，100斤，50斤，25斤，12.5斤，6.25斤。
图3：SAR的示意图
一个260斤的胖子上去了，我首先放200斤的砝码，不够；
再加100斤的砝码，超了；拿掉100斤，加50斤，现在总共250斤的砝码，不够；
继续加一个25斤的，超了；卸掉25斤，加上12.5斤…
类似于这样，最终我知道这个胖子大概在200+50+6.25到200+50+12.5之间。如果我有更精细的砝码，可以量的更准。
在电路中，一般用电容来做这些砝码。当精度较高时，需要的电容面积会很大。例如一个18位的ADC，需要18个不同的“砝码”，在电路中就对应1C，2C，4C，…2^17C，总共需要262144份电容，占据很大的面积。
2、sigma delta ADC（Σ-Δ ADC）的行为描述 sigma：Σ在数学中代表积分（求和），delta：Δ代表差分（求差），这两种过程是Σ-Δ ADC中的主要操作。
直观上理解Σ-Δ ADC，考虑一个“测量纸厚度”的过程。假如有一把尺子，尺子上标注了0，1cm，2cm，3cm…也就是说，尺子的精度是1cm。
这样的尺子显然不能量纸的厚度，因为纸太薄了。可是如果我堆了1000张纸，我用这把尺子量出大概有9cm厚，那么就知道，一张纸的厚度是9cm/1000。
在电路中是一个类似的过程，假如有一个1V的信号，为了做出“1000张纸”的效果，就要转换1000次来得到一个结果。具体的过程要复杂一点，此处略过不提。
3、优劣对比 从速度上看，SAR ADC的速度一般要快一些（这里不和一些新架构的Σ-Δ ADC对比），因为SAR ADC的过程是逐次逼近，理想情况下要得到18位的精度，进行18次逐次逼近的过程就可以了。
Σ-Δ ADC要慢很多，以上述“测量纸的厚度”为例，1000张纸放一起量等效为在电路中进行1000次转换，得到的精度为1/1000，对应于10位的精度。如果要得到18位的精度，需要更多的转换次数，也就需要更长的时间。
Σ-Δ ADC虽然慢，但是可以看出，提高它精度的一个有效方法就是延长时间，提高次数（更有效的方法是提高阶数，略去）。前面说过，1000次量化对应于1/1000的精度，那么10000次？100000次？精度显然就更高。
而SAR ADC提高精度的方法就是增加“砝码”也就是电容的数量，这首先大大增加了芯片的面积；另一方面，位数提高之后，电容的误差也更多了，例如16位的ADC，期望的电容比例为1:2:4:….:16384:32768，但是16384份电容很难做到精确的16384，版图中的寄生，制造过程中的偏差有可能让16384偏成了16300，这样就很难达到所期望的16位精度，因为，“砝码”就是错的。这种情况下，需要比较复杂的校准过程。
总结起来，SAR容易做的更快，但是要达到很高的精度并不容易。Σ-Δ ADC虽然比较慢，但是容易达到较高的精度。
4、应用场景区别 两种ADC的特性决定了其应用场景。SAR应用于速度要求较快的场景，例如数控机床，必须快速判断当前电机的位置，并做出及时的反馈。举一个反例，数控切割作业时，当自动化刀头已经移动到了材料表面，经过1000次量化后，Σ-Δ ADC才发现刀头已经接触材料了，这时机床说不定已经怼坏了。
图4：数控切割机
另一个是电力系统保护。电网中有时需要对电流进行监测，防止大电流烧毁电线。同样地，如果响应速度不够快，这边都着火了那边才发现：过流了！这种场景下一般都需要SAR ADC。
还有一个特殊的场景，负压测量。能够测量负压的Σ-Δ ADC并不多，而SAR ADC有较多的选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfaf68c8af45c68c28a6da0b8c88b2dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c346ecc6dcafb5b68c656c166c446bfa/" rel="bookmark">
			python之字典的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		api序列：
len 表示字典长度str 字典打印成字符串type 字典类型判断clear 清空字典copy 复制字典fromkeys 以序列作为key重新创建一个字典，value值为默认序列值get 返回指定key的value，如果key不存在，则返回默认值in 判断key是否存在，是则返回True，否则返回Falseitems 返回可遍历的的元组，元组的元素为(key,value)形式keys 返回字典的所有key值setdefault 如果key存在，则返回其对应的value，否则将该key和默认值插入到字典中，并返回默认值update 更新字典（合并字典）values 返回字典里面所有的values遍历字典 for（k,v） in 字典.items():修改字典某一项 字典["key"] =value删除字典的某一项 del 字典["key"] 测试：
#-*- coding: utf-8 -*- #字典 #1、字典的创建 d1={"one":1,"two":2,"three":3}#字面量句法 d2=dict(one=1,two=2,three=3) d3=dict([("one",1),("two",2),("three",3)]) d4=dict({"one":1,"two":2,"three":3}) d5=dict(zip(["one","two","three"],[1,2,3]))#zip并行解包 print(d1==d2==d3==d4==d5)#True print(d1) #2、python内置函数（len，type，str） # 计算字典的长度 ss=len(d1) print(ss) #以字符方式输出字典,即将字典转换成字符串 ss1=str(d1) print(ss1) # 判断类型 ss2=type(d1) print(ss2) #清空字典 d5.clear() print(d5) #复制字典 d6=d4.copy() print(d6) #以序列作为kye创建一个新字典，value为所有键对应的初始值 dre={"name":"huitao","age":13} tup=[1,2,3,4] dre_n=dre.fromkeys(tup,"vale") print(dre_n) #返回指定key的value，如果key不存在，则返回默认值 vv=dre.get("name","呵呵") #如果name不存在，则返回去（“呵呵”） print(vv) # in 判断key是否存在，是则返回True，否则返回False res= "name" in dre print(res) #items 返回可遍历的的元组，元组的元素为(key,value)形式 sw=dre.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c346ecc6dcafb5b68c656c166c446bfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a74fa77b692c35c17c07d4c1b18dd2f9/" rel="bookmark">
			FPGA丨设计行缓存(linebuffer)生成像素矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、行缓存介绍 一幅图像是由一个个像素点构成的，对于一幅480*272大小的图片来说，其宽度是480，高度是272。在使用FPGA进行图像处理时，最关键的就是使用FPGA内部的存储资源对像素行进行缓存与变换。
由于在图像处理过程中，经常需要对图像进行开窗。如在进行卷积操作时，我们需要将开窗得到的如3X3大小的局部图像数据与卷积核进行卷积运算，从而完成处理。而开窗操作需要使用行缓存来实现，因此下面就介绍一下行缓存是什么。
假如我们需要3X3的窗口，那么我们就需要设计3行行缓存。因为正常情况下，大多图像数据都是一行一行的，先从左到右，然后从上到下将每一个像素数据输出。如果不加处理，那么我们是不能得到3X3的图像窗口的，我们的最终目的应该是让一帧图像的三行数据对齐之后同时输出，这样我们才能得到3X3的图像窗口！！！
为了实现3行行缓存，由上图可知，我们就需要3个fifo。整体的思路就是，第一行数据依次输入进来写入fifo1，当写到第一行最后一个数据时，开始从fifo1依次读出数据然后写入fifo2，依次类推！！！就这样，当第四行数据到来的时候，此时三个fifo会同时输出数据，而输出的数据正是前三行数据且是对齐的。
二、程序设计 1、line_buffer
`timescale 1ns/1ps module line_buffer ( rst_n, clk, din, dout, valid_in, valid_out ); parameter WIDTH = 10;//数据位宽 parameter IMG_WIDTH = 480;//图像宽度 input rst_n; input clk; input [WIDTH-1:0] din; output [WIDTH-1:0] dout; input valid_in;//输入数据有效，写使能 output valid_out;//输出给下一级的valid_in，也即上一级开始读的同时下一级就可以开始写入 wire rd_en;//读使能 reg [8:0] cnt;//这里的宽度注意要根据IMG_WIDTH的值来设置，需要满足cnt的范围≥图像宽度 always @(posedge clk or negedge rst_n) begin if(!rst_n) cnt &lt;= {9{1'b0}}; else if(valid_in) if(cnt == IMG_WIDTH) cnt &lt;= IMG_WIDTH; else cnt &lt;= cnt +1'b1; else cnt &lt;= cnt; end //一行数据写完之后，该级fifo就可以开始读出，下一级也可以开始写入了 assign rd_en = ((cnt == IMG_WIDTH) &amp;&amp; (valid_in)) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a74fa77b692c35c17c07d4c1b18dd2f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403b102ceeb647ab0db48220c40e2109/" rel="bookmark">
			AD  模块化布局规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个里面的交叉选择模式一定要选中，
作用是：在原理图里选的器件在PCB中会有相应的器件被选中
CTRL + A 全选 按快捷键MS可以整体移动PCB画板的位置
快捷键TC 如果有不知道 的器件就可以通过这个快捷键确定其在原理图的位置
但最好是将PCB 和原理图水平或垂直分布放置，不然可能会出现闪过的现象
按照原理图把所有的模块都分开后，可以看到线很乱，快捷键DC
设置一个电源类，将所有的电源类都加进去
然后在Panels 中执行PCB 会出现这个界面
然后如图所示，隐藏电源的连线，以此来确定都有哪些是连接到电源的
把整体区分成各个模块单元，把所有的器件通过快捷键摆放到一个区
然后再把相对应的电源线进行关闭，只查看信号线的信号流向 ，再具体布局
联合：选中需要联合的器件，单击右键进行联合
如上图所示：
右键可以先将所有的信号线隐藏
可以先按信号流向去进行摆动，然后看具体的应用位置合不合适，需要流出多大的距离
器件名称会影响视觉，选中丝印，右键，查找相似对象
查找相似对象，然后将string type 改为same 然后确定，就会出来一个框
把上图的相应的两个改为相同的参数值
然后快捷键A 将所有的器件文本都定位在器件中间
高亮是CTRL + 左键
取消高亮也是相同的
布局 信号流向原则，还有就是美观度
查找网络视频上说可以用CTRL + F 但实际操作后发现是整体移动
摆放器件的时候，原理图和PCB 垂直分布直接进行框选摆放会方便很多
可以先放置好，然后再进行优化
如上图右下角所示，摆放器件，先大后小原则 就近原则
上面所说的查找网络CTRL + F的快捷键是在原理图中进行查找的
再进行总结下：
1.首先所有的器件基本都是围绕底座上的插针来连线的，也可以直接将其作为布局的起点
2.在放置好插针后，别忘记对其进行整体联合，可以利用角的
如上图，就是中间的丝印重合之处，利用快捷键M
选中右边的器件，使其向右偏离0.5mm,图中设置是错误的
左边的插针也是相同的操作 然后对齐联合
3.关闭电源线，按照其他信好线的方向将其放在合适的位置，然后判断其作用以及原理，会有什么因素的影响，再对其进行细致的摆放
4.摆放过程中器件的原则 就近原则 先大后小原则 及其所起到的作用
信号的流向是否合理都要考虑到
5.都摆放完毕后，再对其进行优化和调整
在完成这些的过程中，要最大可能的实现对快捷键的使用，这样才能提高画板的速度
注意上面在视频中提到的快捷键
每天都要练习
该看第29课了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ca4238a0b923820dcc509a6f75849b/" rel="bookmark">
			1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728d90f9107ec666d1338846f6e236b6/" rel="bookmark">
			MySQL入门命令(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础命令 查看服务器下的所有数据库
show database; 创建数据库
create database 数据库名 删除数据库
Drop database 查看当前使用的数据库
select database(); 进入指定的数据库
use 数据库名 创建表
create table 表名(表的所有列的定义和约束); &gt; 例子： &gt; create table books( &gt; bid int primary key, &gt; title varchar(80) unique not null, &gt; author varchar(20), &gt; price float not null, &gt; publisher varchar(100) default '人民教育出版社', &gt; stocks int not null, &gt; publishdate date &gt; ); 查看表的详细结构
alter table 表名 修改操作; 例子: alter table 表名 add column 表名 varchar(1000);	#修改表：增加一列 alter table 表名 drop column 表名;	#修改表：删除一列 alter table 表名 column 表名 varchar(50) not null;	修改表：修改列、重命名 查看表的详细结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728d90f9107ec666d1338846f6e236b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8ceb1b6358bd6aa330fff73dfff131/" rel="bookmark">
			JVM原理 | TLAB是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TLAB (Thread Local Allocation Buffer) 1.概述 TLAB ( Thread local Allocation Buffer ) 本地线程分配缓存 , 这是一个线程专用的内存分配区域, 可以解决内存分配冲突的问题;
虚拟机参数 -XX:UseTLAB 在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率
TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，也可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小
2. TLAB的本质 其实是三个指针管理的区域：start，top 和 end，每个线程都会从Eden分配一块空间，例如说100KB，作为自己的TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配。
TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。 从这一点看，它被翻译为 线程私有分配区更为合理一点
当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的。但是如果分配一次以后内存还是不够的话, 则直接移入Eden区
3.TLAB的缺点 : TLAB通常很小，所以放不下大对象。
TLAB空间大小是固定的，但是这时候一个大对象，我TLAB剩余的空间已经容不下它了。(比如100kb的TLAB，来了个110KB的对象)TLAB空间还剩一点点没有用到，有点舍不得。(比如100kb的TLAB，装了80KB，又来了个30KB的对象)
所以JVM开发人员做了以下处理，设置了最大浪费空间。 当剩余的空间小于最大浪费空间，那该TLAB属于的线程在重新向Eden区申请一个TLAB空间。进行对象创建，还是空间不够，那你这个对象太大了，去Eden区直接创建吧！当剩余的空间大于最大浪费空间，那这个大对象请你直接去Eden区创建，我TLAB放不下没有使用完的空间。 Eden空间够的时候，再次申请TLAB没问题 ; 但是如果不够，Heap的Eden区要开始GC
TLAB允许浪费空间，导致Eden区空间不连续，积少成多。以后还要人帮忙打理
4. 扩展 4.1 创建对象的内存分配 编译器通过逃逸分析判断对象是在栈上分配还是堆上分配，如果是堆上分配则进入下一步。（开启逃逸分析需要设置jvm参数）如果tlab可以放下该对象则在tlab上分配，否则进入下一步。重新申请一个tlab，再尝试存放该对象，如果放不下则进入下一步。在eden区加锁，尝试在eden区存放，若存放不下则进入下一步。执行一次Young GC。Young GC后若eden区仍放不下该对象，则直接在老年代分配。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f592a6dc77b9822b0bc295ae2bc87b7f/" rel="bookmark">
			Windows快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows快捷键 复制 Ctrl+c粘贴 Ctrl+v全选 Ctrl+A剪切 Ctrl+x撤销 Ctrl+2保存 Ctrl+s关闭窗口 Alt+F4永久删除 Shift+Delete打开搜索窗口 windows键+R打开我的电脑 windows+E打开任务管理器 Ctrl+Shift+Esc切换应用 windows+Tab 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/716cf2d31f0d5f78a6c89d2204c86705/" rel="bookmark">
			Can not set int field to null value错误解决：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询数据库记录报错：
错误信息：
Can not set int field /*某个类的属性*/ to null value 不能设置int类型的属性为null值
原因就是：数据库中有类型为int的字段未赋值
改了之后，执行成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49da911e4ed9b7f0e69357238107648f/" rel="bookmark">
			手机录音并上传至服务器php,js实现录音 并将录音文件保存至服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【实例简介】后端程序 实现了保存录音文件功能，为php开发
【实例截图】
【核心代码】
无标题文档 function f_getURL(){
var url = "acceptfile.php";
return url;
}
function f_getMAX(){
return 60;//最长录音时间
}
function f_getMIN(){
return 10; //最小录音时间
}
function f_complete(filename){
alert(filename);
/*if (typeof(SUPER_REPLY) != 'undefined') {
if (wysiwyg) {
editdoc.body.innerHTML = '[audio]rec/' filename '[/audio]';
} else {
editdoc.value = '[audio]rec/' filename '[/audio]';
}
}*/
var test=jQuery('#fastpostmessage').val() '[audio]' filename '[/audio]';
alert(test);
jQuery('#fastpostmessage').val(test);
/*if (jQuery('.pnpost').css('display') == 'none') {
jQuery('#fastpostform').submit();
}*/
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8487645c6a354260e9a2e36395a27a17/" rel="bookmark">
			视觉心理物理学（2）matlab与ptb3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		典型的心理物理实验通常通过各种显示设备向观察者显示刺激（常将处理过的特殊数字图像作为刺激），通过交互设备（键盘、鼠标、按键盒等）接收被试者反应。
通过matlab及psychtoolbox3工具包完成实现所需的刺激呈现、应答接收、以及数据拟合处理......
Psychtoolbox的维基网址为http://psychtoolbox.org/wiki 该网站中提供了一个论坛，以及供用户下载和安装Psychtoolbox的软件包以及系统要求的版本信息。
Psychtoolbox网站上概述和介绍，以及各种教程http://psychtoolbox.org/PsychtoolboxTutorial 读者还可以使用MATLAB中的帮助功能访问与工具箱函数的文档介绍页面。
图像（正弦光栅、外部噪声图像和纹理等）通常在文件或计算机内存中以数字形式保存为位图或像素图——位或像素（图像元素）的空间映射表示图像在x，y处每一点的颜色。
图像的位图是具有相应行数和列数的二维像素阵列。每个像素元素给出图像中对应行和列位置中的像素强度值。图像像素通常被存储为1,4,8,16,24,32,48或64位/像素。位/像素的数值被称为颜色深度。
（1）正弦波是视觉心理物理学中的基本图形。Gabor是一个由二维高斯（正常或钟形）函数窗口化的正弦波，具有明确的空间频率范围，并包含在窗口化的空间中，它是视觉研究中最常用的刺激之一。
l(x,y)=l0 (1.0±csin{2 π f [ysin(θ)+xcos(θ)]}) 正弦波方程
l(x,y)=l0 (1.0±csin{2 π f [ysin(θ)+xcos(θ)]}×exp[ ]) Gabor的方程 l（x，y）是图像中位置（x，y）处像素的灰度级，l0是平均灰度级，f是正弦波的频率（1 /像素），θ是正弦波的倾斜角
效果图（中）生成matlab代码（右） meshgrid 函数用来生成网格矩阵，可以是二维网格矩阵
（2）白噪声图像
噪声图像通常用于改变图像质量或终止视觉处理。常用高斯白噪声（即是每个像素的值均从均值等于中值或中性灰度、标准差为可实现强度值范围中一部分的正态分布中随机抽取）
（3）滤波图像
我们常需要不同空间频率的图像刺激，通过matlab设计不通滤波器可实现不同图像的处理。
1. imread 读取图像，得到矩阵map和相应的颜色映射M 如 [M,map] = imread ( 'Church.jpg','jpeg' ) ;% M is a true color image in a 1944x2896x3 matrix showImage (M,' ' ) ;%显示图片
2. rgb2gray 灰度变换（将真实的RGB图像转换为灰度图像）、函数可以保留亮度信息的同时，消除有关色彩的色调和饱和度的信息 [M,map] = imread ( 'Church.jpg','jpeg') ; M2 = rgb2gray(M) ; showImage (M2,'grayscale' ) ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8487645c6a354260e9a2e36395a27a17/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/373/">«</a>
	<span class="pagination__item pagination__item--current">374/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/375/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>