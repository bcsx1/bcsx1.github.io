<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb7b2c4d4b674410045cd26dbe0ff6d/" rel="bookmark">
			C语言条件编译#if_#elif_#ifdef_#ifndef
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如要开发一款产品，开始的程序一般会利用前面已开发完毕的程序，但是程序的时钟可能不是我们需要的，时钟的变化会导致串口波特率的产生偏差，这时候我们可以利用宏来选择
/************系统时钟频率定义，主要用于配置UART波特率**********/ #if (SYSCLK_SRC == IRCH) #define FOSC	(3686400) #elif (SYSCLK_SRC == PLL) #define PLL_Multiple	6	//PLL倍频倍数 #define FOSC	(3686400*PLL_Multiple) #else #define FOSC	(3686400) #endif #if、#elif、#else 和 #endif #ifndef都是预处理命令，整段代码的意思是：如果宏 SYSCLK_SRC 与IRCH相同，就保留第3 行代码，删除第 5、6、8 行代码；如果宏 SYSCLK_SRC 与 PLL相同，就保留第 5 、6 行代码；如果所有的宏都为假，就保留第 8 行代码。
这些操作都是在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。
这种能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能。
#if 的用法 #if/后面接的是表达式, 这个表达式的结果必须为一个数值(任意数值皆可，但不能为空)
#if 的一般格式：
#if 整型常量表达式1 程序段1 #elif 整型常量表达式2 程序段2 #else 程序段4 #endif 意思是：如果“表达式1”的值为真（非0），就对“程序段1”进行编译，否则就计算“表达式2”，如果“表达式2”结果为真的话就对“程序段2”进行编译，为假的话就继续往下匹配，直到遇到值为真的表达式，或者遇到 #else。这一点和 if else 非常类似。
需要注意的是，#if 命令要求判断条件为“整型常量”，也就是说，表达式中不能包含变量，而且结果必须是整数；而 if 后面的表达式没有限制，只要符合语法就行。这是 #if 和 if 的一个重要区别。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cb7b2c4d4b674410045cd26dbe0ff6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff660961ee58e62b9f7758b802770fb3/" rel="bookmark">
			Linux平台上Wireshark无网络接口权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # sudo usermod -a -G wireshark your_name # setcap cap_net_raw,cap_net_admin+eip /usr/sbin/dumpcap 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061bb631aed17785d182e3599c51a35b/" rel="bookmark">
			【软件工程】重要知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件工程概述 软件工程的诞生 1968年北大西洋公约组织的计算机科学家在联邦德国召开国际会议，讨论软件危机问题。在这次会议上正式提出并使用了“软件工程”这个名词，一门新兴的工程学科就此诞生了。
软件危机 ① 对软件开发成本和进度的估计常常很不准确。
② 用户对“已完成的”软件系统不满意的现象经常发生。
③ 软件产品的质量往往靠不住。
④ 软件常常是不可维护的。
⑤ 软件通常没有适当的文档资料。
⑥ 软件成本在计算机系统总成本中所占的比例逐年上升。
⑦ 软件开发生产率提高的速度，既跟不上硬件的发展速度，也远远跟不上计算机应用迅速普及深入的趋势。
产生原因：一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关。
重要的原因之一：在软件开发的不同阶段进行修改需要付出的代价是很不相同的。在早期引入变动，涉及的面较少，因而代价也比较低；在开发的中期，软件配置的许多成分已经完成，引入一个变动要对所有已完成的配置成分都做相应的修改，不仅工作量大，而且逻辑上也更复杂，因此付出的代价剧增；在软件“已经完成”时再引入变动，当然需要付出更高的代价。
软件是程序、数据及相关文档的完整集合。
1983 年 IEEE（电气和电子工程师协会）为软件下的定义是：计算机程序、方法、规则、相关的文档资料以及在计算机上运行程序时所必需的数据。
七条基本原理 ①用分阶段的生命周期计划严格管理
②坚持进行阶段评审
③实行严格的产品控制
④采用现代程序设计技术
⑤结果应能清楚地审查
⑥开发小组的人员应该少而精
⑦承认不断改进软件工程实践的必要性
十大领域 ①软件需求（software requirements）
②软件设计（software design）
③软件构建（software construction）
④软件测试（software testing）
⑤软件维护（software maintenance）
⑥软件配置管理（software configuration management）
⑦软件工程管理（software engineering management）
⑧软件工程过程（software engineering process）
⑨软件工程工具和方法（software engineering tools and methods）
⑩软件质量（software quality）
问题 一、什么是软件？有何特点？
目前对软件比较公认的解释是：软件是程序，支持程序运行的数据以及与程序有关的文档的完整集合。
程序：按事先设计的功能和性能要求执行的指令序列文档：与程序开发，维护和使用有关的图文材料 文档分为三大类：开发文档、用户文档、管理文档文档的作用：记录、通信和交流、管理和维护 数据：使程序能正常操纵信息的数据结构 软件的特点：
软件是逻辑的，而不是物理的产品软件是由开发化或者工程化形成的，没有明显的制造过程软件在运行和使用期间，不存在硬件那样的磨损和老化问题，但存在退化问题，所以需要维护软件 软件的故障率是由于软件修改呈现锯齿状，因为软件修改可能带来新的错误 大多数软件是自定的，软件开发尚未完全摆脱手工的方式软件成本相当昂贵软件本身比较复杂 二、什么是软件危机？如何解决？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/061bb631aed17785d182e3599c51a35b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c16f439a02a314cdd79d9a1924d68a1a/" rel="bookmark">
			SpringBoot集成javafx在TableView使用Pagination分页及自定义分页，表格行编辑及弹窗编辑，全选/反选，删除与批量删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.相关jar包依赖如下 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.roskenet&lt;/groupId&gt; &lt;artifactId&gt;springboot-javafx-support&lt;/artifactId&gt; &lt;version&gt;2.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;version&gt;2.6.7&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;!-- 必须使用对应版本，否则会出现循环依赖问题 --&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.需要用到javafx的xml &lt;?xml version="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c16f439a02a314cdd79d9a1924d68a1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fb9d08bfa981dcb75cad8c9841823f9/" rel="bookmark">
			mmdetection 训练时报错: Permission denied: ‘C:\\Users\\Admin\\AppData\\Local\\Temp\\tmp06sdogpt.py‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 mmdet 训练时使用 resume_from 参数时 , 会报错:
File "D:\Anaconda3\envs\hzmd\lib\site-packages\mmcv\utils\config.py", line 251, in fromfile cfg_dict, cfg_text = Config._file2dict(filename, File "D:\Anaconda3\envs\hzmd\lib\site-packages\mmcv\utils\config.py", line 137, in _file2dict Config._substitute_predefined_vars(filename, File "D:\Anaconda3\envs\hzmd\lib\site-packages\mmcv\utils\config.py", line 112, in _substitute_predefined_vars with open(filename, 'r') as f: PermissionError: [Errno 13] Permission denied: 'C:\\Users\\Admin\\AppData\\Local\\Temp\\tmp06sdogpt.py' 这是因为 mmcv\utils\config.py 的 _file2dict() 函数想在C盘创建临时文件，但是PyTorch没有在C盘创建文件的权限，因此造成了PermissionError.解决的办法是在D盘创建一个Temp文件夹,让_file2dict()在D盘创建临时文件，就不会有PermissionError了.因此对_file2dict(filename, use_predefined_variables=True)这个函数进行了修改, 修改函数开头的一段如下:
@staticmethod def _file2dict(filename, use_predefined_variables=True): filename = osp.abspath(osp.expanduser(filename)) # 新加入部分 filenames = filename.split('\\') if filenames[0] == 'C:': filename = 'D:\\Temp\\' +filenames[-1] f = open(filename, 'w') f.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fb9d08bfa981dcb75cad8c9841823f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b0e6cf6328ea75b5ebd025940e8edb/" rel="bookmark">
			深度学习及mmdetection学习理解笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于mmdet源码 mmdetection 的网络配置中, type参数都是实例化的类名, 后面的都是对于的类初始化参数
参考: MMCV 核心组件分析(五): Registry
详解 MMDetection 使用技巧和源码实现。
关于卷积 1x1 的layer用来减少或增加输入的特征的channel, 比如resnet 中残差结构中的第一层需要减少channel, 第三层增加channel, 有几个卷积核输出就有几个channel
3*3卷积 主要作用是减少网络参数, 增大有效感受野, 增加了局部上下文信息, 一般图像尺寸会减小
Resnet的理论及源码讲解 MMDetection Faster R-CNN 源码详解（一）
pytorch图像分类篇：6. ResNet网络结构详解与迁移学习简介
关于 FPN 的讲解 实际是对高低层的特征图进行融合, 然后在 目标检测网络中, 针对不同的特征层再进行 RPN(提出建议框)
参考: 1.1.2 FPN结构详解
特征融合中的拼接和相加 element-wise sum 即矩阵元素对位相加
concat 拼接一般是在 通道上channel 上拼接, 结果是通道数增加, 一般在后面需要再加上一层卷积以减少通道数, 但同时这增加了参数量以及计算量
注意力机制 SELayer 的理解 2017 Squeeze，Excitation，Scale为SENet模块主要构成,
Squeeze: 把H×W×C的矩阵压缩到了1×1×C，每个通道的信息都用该通道的全局平均池化值来表示
Excitation: 激活, 对通道建模, 全连接层-&gt;Relu激活-&gt;全连接层
Scale: 就是一个简单的加权操作, 在经过 Excitation第二个全连接层后得到的输出是经过 sigmoid激活的权重值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3b0e6cf6328ea75b5ebd025940e8edb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e22296ca4d6670d7c93e95ff75a3aca4/" rel="bookmark">
			【双符号位判决法】定点数上溢，下溢的判别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上溢、下溢： 上溢：两个数进行运算，得到的结果的绝对值超过最大表示范围。定点整数之间只会发生上溢
下溢：两个浮点数运算，得到的结果的绝对值超过最小的表示范围。只有浮点数的运算会发生下溢
看图：
双符号位判决法： 通过两位符号位来判断运算结果为上溢还是下溢。
先说结论：
01——上溢
10——下溢
分析：
01——​​​​​​​上溢：
首先我们知道双符号位的最高位表示的始终是结果的正负值，所以可以肯定的是，参与运算的两个数都是正数。因为两个正数的运算结果超出了数值位的表示的最大范围，所以数值位进位到符号位了，说明，其绝对值超过了表示的最大范围，为上溢。
10——下溢：
首先确定这两个数是负数，这个两个数的运算结果超过了数值位的最小范围，所以数值位上的1被借走了，说明其绝对值超过了表示的最小范围，为下溢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dc6c7ce5a784eebb19b8a53ce6bef82/" rel="bookmark">
			RocketMQ发送消息的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.rocketQM有三种发送方式：
同步发送：等待返回结果
异步发送：立即返回，使用回调函数
一次性发送：只发送一次，不关心发送结果
2.DefaultMQProducer同步发送
DefaultMQProducer.send(msg); public SendResult send(msg,CommunicationMode.SYNC,(SendCallback)null,timeout); 2.DefaultMQProducer异步发送
DefaultMQProudcer.send(msg,sendCallback); sendDefaultImpl(msg,CommunicationMode.ASYNC,sendCallback,timeout) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d717f3cb5b9afc369b0a1b0e0ed037/" rel="bookmark">
			Modelsim的tcl命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 前言二. 命令总结三. 脚下留心：1.Enable optimization2.restart3.路径3.1绝对路径3.2相对路径3.3直接include 4.↑的使用 四. do文件1. file.do2. wave.do 五. bat文件六. 交互式命令1.force-repeat指令1.1指令格式：1.2指令功能：1.3栗子： 2.force指令2.1指令格式： 3.run指令3.1指令格式：3.2指令功能： 4.force-cancel指令4.1指令格式:4.2指令功能：执行period周期时间后取消force命令； 5.view 一. 前言 最近学习了modelsim的tcl命令，可以直接在transcript窗口通过命令来执行操作，更重要的是通过.do文件可以不打开modelsim就生成一些波形文件（例如.vcd等），方便后续使用（debussy调试波形）。
注：
本文偏总结性，先去了解一下基础知识再来看效果更佳~ 文中也有几篇可以参考~
此外，本文不会讲解ModelSim的图形界面使用的，有需要的同学请自行百度。
二. 命令总结 总结了一下tcl中常见命令(都加了注释)，大家不要担心看不懂和不会用，我后面会讲解在Windows中怎么使用脚本（即五、bat文件）来进行编译Verilog代码，你不需要记住所有的命令，想用什么的时候直接来这里搜搜看就行。现在先大体浏览一下即可:
#Quit last sim quit -sim #Create the work library vlib work #vmap the work lib vmap work work #include the head files vlog +incdir+ YOURPATH sfifo_def.v #eg: vlog +incdir+ sfifo_def.v # Compile the verilog files vlog -work work sfifo.v vlog -work work sfifo_tb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d717f3cb5b9afc369b0a1b0e0ed037/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e0ff95b6df3d4d7647a923f9b1a4fe7/" rel="bookmark">
			Kotiln基础语法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kotlin不仅支持编写在虚拟机上运行，而且还是一门跨平台的通用型语言，我们可以用Kotlin开发各种类型的原生应用，如Android，macOS，Windows，Javascript应用。
Kotlin能脱离虚拟机层，直接编译成可以在Windows，Linux和macOS平台上运行的原生二进制代码。
一、变量 变量声明
//Int类型可以省略，自动推导 var max: Int = 5 //var 可读可写 //val 可读不可写 常用内置数据类型
类型描述示例String字符串”Hello World“Char单字符‘A’Booleantrue/falsetrue falseInt整数5Double小数3.14List元素集合Set无重复元素的集合Map键值对集合 二、编译时常量 编译时常量只能在函数之外定义，因为编译时常量必须在编译时赋值，而函数都是在运行时才调用，函数内的变量也是在运行时赋值，编译时常量要在这些变量赋值前就已存在
编译时常量只能时常见的基本数据类型：String、Int、Double、Float、Long、Short、Byte、Char、Boolean
const val MAX = 100 三、查看Kotlin字节码 两种方式
1.Shift键两次，输入Show Kotlin
2.Tools-&gt;Kotlin-&gt;Show Kotlin Bytecode
Decompile可以反编译成java代码
四、Kotlin的引用类似与基本数据类型 Java有两种数据类型：引用类似与基本数据类型
Kotlin只提供引用类型这一种数据类型，出于更高性能的需要，Kotlin的编译器会在Java字节码中引用基本数据类型
五、range表达式 //range val age = 0 //0 .. 3 大于等于0小于等于3 if(age in 0 .. 3){ println("婴幼儿") //4 .. 12 大于等于4小于等于12 }else if(age in 4 .. 12){ println("少儿") }else{ println("青少年") } //其他写法 if(age !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e0ff95b6df3d4d7647a923f9b1a4fe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee9a4227acb05afe70d90f899dac49f/" rel="bookmark">
			AWVS的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装： 文件下载路径：
链接：https://pan.baidu.com/s/1LjvSKwe6ur-TfnWQWlsJ-Q 提取码：jsp5 AWVS的使用： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/529f087f04a2660cfb7b826aa6922db9/" rel="bookmark">
			微擎框架——wampServer安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 微擎部署 1.下载相关软件 这里采用的php集成环境是WampServer64,这个软件要科学上网，这里我给大家分享个百度云。
离线安装源码：https://gitee.com/we7coreteam/pros.git WampServer64：https://pan.baidu.com/s/1Y1G8O65ymVTYtUPX4prEJg 提取码：7198 2.部署 增加一个Alias目录，点击【Add an alia】，然后直接输入文件名，我这里取名为we7Study，然后按一下回车，再输入练习目录，这里我指定【d:we7Study】，然后再回车就会多一个目录。把下载好的微擎源码，放到刚刚的目录下即可。
name C:/xxx/xxx 3.安装微擎 浏览器输入localhost，找到并点击刚刚创建的alias（站点），这里采用的是离线安装源码，所以直接输入下方代码接口，注意站点名要和自己的同步。数据库方面采用wampServer64自带的数据库，默认密码不能为空，所以要提前修改，修改数据库的代码如下。
http://localhost/we7Study/install.php #修改数据库代码如下(PASSWORD后面跟的是密码，这里我改成root) use mysql update user set authentication_string=PASSWORD('root') where user='root'; flush privileges; quit 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa942b34d52917a76793fb07d839f58b/" rel="bookmark">
			元素等待的三种方式（隐式等待、显示等待、强制等待）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 隐式等待显示等待强制等待如何选用等待方式 隐式等待 # 隐式等待：设置一个超时时间，在这个时间内，不断的寻找元素，超时找不到就抛出异常 driver.implicitly_wait(10) """ 执行逻辑： 当代码执行元素定位操作的时候，若找得到元素，则继续执行 若找不到元素，则等待0.5秒，然后再找一次，若还是找不到，则又等0.5秒再找 如此循环，直到找到元素，若找到元素，则继续往下执行代码 若达到最大超时时间，还是不能找到元素，则抛出 timeout 异常 """ 优缺点
一次声明，终生有效–对其后执行的每一行元素定位都有效
所以，通常在创建 driver 之后就去申明隐式等待，需页面全部加载完成再执行，相对浪费时间 显示等待 # 显示等待：设置一个超时时间和一个元素查找条件，在这个时间内，不断寻找元素，超时找不到就会报错 ele = WebDriverWait(driver, 10, 1).until( ec.visibility_of_element_located( ( By.CSS_SELECTOR, "body &gt; section &gt; div.left-side.sticky-left-side &gt; div.left-side-inner &gt; ul &gt; li:nth-child(2)") ) ) # 显示等待这一大段，最终就会返回你想寻找的元素（若超时找不到，也会报timeout异常 优缺点
不需要页面全部加载完成，相对节省时间代码量多 强制等待 time.sleep(3) # 等待3秒，不论元素是否找到，执行下一步 如何选用等待方式 申明一个隐式等待，全局通用对于一些加载特别缓慢的元素，设置显示等待，适当为其增加等待时间当显示等待与隐式等待同时出现的时候，取时间更多的一个生效 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20cf429187ebdc6c4d145e4aa33b314/" rel="bookmark">
			Arrays 类学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、定义
二、常用方法
1、Arrays.sort()排序
2、Arrays.sort()部分排序
3、Arrays.asList(T...a)方法
4、Arrays.toString(int[] a)
5、Arrays.fill(Objects, Object)
6、Arrays.equals()
7、Arrays.binarySearch()
8、Arrays.binarySearch()
一、定义 Arrays类位于 java.util 包中，有关数组的一些操作
使用时的包:
import java.util.Arrays 二、常用方法 1、Arrays.sort()排序 1）方法
public static void sort(T[] a) 2）使用（默认升序排序）
int a[] = new int[]{15, 4, 3, 5, 7, 1}; System.out.print("排序前："); for (int i : a) { System.out.print(i + " "); } System.out.println(); Arrays.sort(a); System.out.print("排序后："); for (int i : a) { System.out.print(i + " "); } System.out.println(); 3）结果
排序前：15 4 3 5 7 1 排序后：1 3 4 5 7 15 4）降序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e20cf429187ebdc6c4d145e4aa33b314/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1373585f11b4bb616f4ad470339be7b0/" rel="bookmark">
			7-129 最佳情侣身高差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、题目要求 专家通过多组情侣研究数据发现，最佳的情侣身高差遵循着一个公式：（女方的身高）×1.09 =（男方的身高）。如果符合，你俩的身高差不管是牵手、拥抱、接吻，都是最和谐的差度。
下面就请你写个程序，为任意一位用户计算他/她的情侣的最佳身高。
输入格式： 输入第一行给出正整数N（≤10），为前来查询的用户数。随后N行，每行按照“性别 身高”的格式给出前来查询的用户的性别和身高，其中“性别”为“F”表示女性、“M”表示男性；“身高”为区间 [1.0, 3.0] 之间的实数。
输出格式： 对每一个查询，在一行中为该用户计算出其情侣的最佳身高，保留小数点后2位。
输入样例： 2 M 1.75 F 1.8 输出样例： 1.61 1.96 二、代码 #include&lt;stdio.h&gt; int main(){ int n; scanf("%d", &amp;n); char c; double h; for(int i=0;i&lt;n;i++){ scanf(" %c %lf",&amp;c,&amp;h); if (c=='M') printf("%.2f\n", h / 1.09); else printf("%.2f\n", h * 1.09); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b4400dc020027394a332dc4f85bba6/" rel="bookmark">
			差量更新问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
升级后台配置了差量更新，但是用户设备检测到的是全量更新，测试设备检测到的是差量更新
原因：
差量更新需要具备的条件：
1、升级后台配置了差量更新的链接
2、设备对应的目录下有base包
用户设备和测试设备的不同：
测试设备 一般都是删除了固件本身的安装包，然后手动安装对应的测试包，所以对应的目录下有需要的base包
用户设备是升级到新固件，新的固件中对应目录下没有对应的base包，程序找不到对应的包，所以只能检测到全量更新
测试为什么没有发现这个问题：
1、在测试过程中没有覆盖到升级固件之后就测试差量升级或者恢复出厂设置后进行差量更新
2、对差量升级的逻辑的实现细节不清晰，没有和开发进行充分的沟通，不清楚具体的实现逻辑
后续处理：
处理结果：该问题无法解决
固件升级后没有base包，目前不能让硬件方直接预置在对应的目录下，因为硬件方会对固件本身做一些处理，导致安装包的md5 与 本身发送给硬件方的安装包md5不一致，所以不建议预置安装包到固件中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99098fe377432d028417084abd0b8473/" rel="bookmark">
			vue中使用nodejs接口向后台post传参，后端无法获取参数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后台是node+express框架 ，配置如下： //导入express模块 const express = require('express') const bodyParser = require('body-parser') //创建express服务器实例 const app = express() const joi = require('joi') //导入cors中间件 const cors = require('cors') //将cors注册为全局中间件 app.use(cors()) //通过如下的代码，配置解析 application/x-www-form-urlencoded 格式的表单数据的中间件： app.use(express.urlencoded({extended:false})) //封装全局请求回调函数 app.use((req,res,next)=&gt;{ res.cc=((err,status=1)=&gt;{ res.send({ status, message:err instanceof Error? err.message:err }) }) next() }) app.use(bodyParser.json()) //一定要在路路由前配置解析token的中间件 const expressJWT = require('express-jwt') const config = require('./config') // 使用 .unless({ path: [/^\/api\//] }) 指定哪些接口不需要进行 Token 的身份认证 app.use(expressJWT({secret:config.jwtSecreKey}).unless({ path: [/^\/api\//] })) // 导入并注册登录用户路由模块 const userRouter = require('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99098fe377432d028417084abd0b8473/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6268ff46fae9e33af7181b1fa596f5f7/" rel="bookmark">
			在sublime3中运行Python文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到Tools/Build System/New Build System打开，
{
"cmd": ["D:/anaconda 3/python.exe","-u","$file"],
"file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)",
"selector": "source.python",
"env": {"PYTHONIOENCODING": "utf-8"}
}
注意：cmd需要修改python.exe路径
将以上代码替换原代码
{
"shell_cmd": "make"
}
原路径保存，命名为Python3.sublime-build
现在找到python文件
ctrl + B 就可运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9afcc656669fbac9af9d2ff647be6351/" rel="bookmark">
			postman中springboot上传文件Missing initial multi part boundary
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果在postman中设置了Context-type为multipart/form-data以及file设置，如下图：
而我的调用的上传方法仅仅只是用了@RequestMapping("/xxxx")，并且使用MutipartFile，如下图：
的时候，可能遇到的错误信息如下(报错信息看加粗与下划线部分就行了)
org.springframework.web.multipart.MultipartException: Failed to parse multipart servlet request; nested exception is java.io.IOException: Missing initial multi part boundary
at org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.handleParseFailure(StandardMultipartHttpServletRequest.java:124)
at org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.parseRequest(StandardMultipartHttpServletRequest.java:115)
at org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.&lt;init&gt;(StandardMultipartHttpServletRequest.java:88)
Caused by: java.io.IOException: Missing initial multi part boundary
at org.eclipse.jetty.util.MultiPartInputStreamParser.parse(MultiPartInputStreamParser.java:613)
at org.eclipse.jetty.util.MultiPartInputStreamParser.getParts(MultiPartInputStreamParser.java:482)
at org.eclipse.jetty.server.MultiParts$MultiPartsUtilParser.getParts(MultiParts.java:112)
at org.eclipse.jetty.server.Request.getParts(Request.java:2382)
at org.eclipse.jetty.server.Request.extractContentParameters(Request.java:529)
at org.eclipse.jetty.server.Request.getParameters(Request.java:430)
at org.eclipse.jetty.server.Request.getParameterMap(Request.java:1068)
at javax.servlet.ServletRequestWrapper.getParameterMap(ServletRequestWrapper.java:203)
at javax.servlet.ServletRequestWrapper.getParameterMap(ServletRequestWrapper.java:203)
at javax.servlet.ServletRequestWrapper.getParameterMap(ServletRequestWrapper.java:203)
at javax.servlet.ServletRequestWrapper.getParameterMap(ServletRequestWrapper.java:203)
at com.hsjry.channel.guard.biz.oauth2.filter.ParameterHttpServletRequest.getParameterMap(ParameterHttpServletRequest.java:47)
其实，从上面的错误信息们就可以看到，大概就是是说multipart少了对参数boundary的初始化，其实就是boundary这个参数没有给值。解决的方式其实很简单，只需要将Context-type的设置的值后边加上分号，再加上boundary=ebf9f03029db4c2799ae16b5428b06bd1，完整的就是multipart/form-data;boundary=ebf9f03029db4c2799ae16b5428b06bd1，boundary里的值你可以随便改，
或者设置成：
然后，这样你就可以成功上传文件了，当然postman中也可以下载文件，只需要点击"Send“右下角的小三角形，选择一下就可以了：
当然，有的人说啥post们中不需要指定Content-Type的值，说啥上传文件的时候会自动识别，反正我试过了，并不可行。这里如果不设置Content-Type的话，后台会报Current request is not a multipart request的异常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e9b906057e55ac8740890f12d0a32f6/" rel="bookmark">
			Pycharm中pytest模式作用及设置方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytest作用 自动发现测试用例 testloader
断言方便 ，自定义错误提示 assert 正则匹配
灵活运行指定的测试用例，指定模块，制定测试类，测试用例 -k 标签化，回归 正向 冒烟 登陆
环境管理灵活。
丰富的插件，测试报告，插件介绍 allure(比较成熟的测试报告体系，unittest不支持这个插件)
和unittest / nose兼容，pytest中标签、生成allure、分析最慢的测试用例和unittest兼容
设置方式 要退出这种模式，
第一步：点击顶部运行键——选择‘Edit configuration’，第二步：可以看到左侧Python下有两个文件夹，如果进入了test模式，就会有‘Python test’一栏，第三步：选定Python test，这时点击上面的‘-’号去掉这栏下的文件即可。
然后确定，再次右键代码，就可以执行run模式了 pytest好处
pytest设置方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565b926e0ff33c040b4d1381fbe147b0/" rel="bookmark">
			ASP.NET Core5.0 SignalR CORS 跨域处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ASP.NET Core5.0 SignalR CORS 跨域处理
1.在Asp.Net Core 3.0 SingalR 以前的版本配置跨域处理参考：
ASP.NET Core SignalR CORS 跨域处理_天马3798的博客-CSDN博客_signalr 跨域
核心代码：
//注册signalr--指定跨域方案 app.UseCors("any").UseSignalR(route =&gt; { route.MapHub&lt;NoticeHub&gt;("/ws_notice"); }); 2.在Asp.Net Core 3.0 后路由配置使用了 UseEndpoints 终结点方式，以前的方法UseSignalR不在支持。
3.新版使用 MapHub 绑定集线器，使用RequireCors 配置跨域处理。
4.在Asp.Net Core 3.0 后SingalR启动方式也发生了变化，详情见下面文章连接。
二、新版解决方案：
1.设置CORS
//设置跨域访问 services.AddCors(options =&gt; { //登录用户使用 options.AddPolicy("any", builder =&gt; { builder.WithOrigins( "http://crm.muzixiaohua.com/", "http://localhost:55329", "http://192.168.0.105", "http://localhost:64151", "http://localhost:8080", "http://localhost:8081", "http://localhost:8082", "null") .AllowAnyMethod() .AllowAnyHeader() .AllowCredentials(); }); //公开使用 options.AddPolicy("all", builder =&gt; { builder.WithOrigins("*") .AllowAnyMethod() .AllowAnyHeader(); }); }); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/565b926e0ff33c040b4d1381fbe147b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdbaebb4d565f3f2f1d33fe416351bb/" rel="bookmark">
			中奖？从概率算起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要一夜暴富，最快的方法莫过于买彩票中大奖。那么今天我们就使用计算机从头捋一下彩票。
我们以双色球为例，彩票的中奖规则如下，一等奖二等奖因为奖金浮动不好计算，我们就按保底来看。
规则
奖金
一等奖
6+1
500W
二等奖
6
6000
三等奖
5+1
3000
四等奖
5+0 或 4+1
200
五等奖
4+0 或 3+1
10
六等奖
2+1 或 1+1 或 0+1
5
想要科学地分析，需要两个工具，其一是概率计算，其二是数学期望。
网上有很多人用返奖率来作为彩票的获奖概率和数学期望，我觉得很有问题。虽然双色球返奖率高达51%，但这其实是将各个奖项平均的结果。就像我的工资和马云的工资一平均，那我也是亿万富翁，这明显无法很好地展示出我的真实情况。
所以我们有必要单独计算各种获奖概率和数学期望。在33个红球中选6个，在16个蓝球中选1个，用组合数来进行计算，就是C(6,33)C(1,16)=1107568x16=17721088。
买一注的数学期望公式：( 中奖奖金 ) * p + ( - 本金 * (1 - p ) ）
我们根据下面组合数内容编写程序如下，来获取概率与期望相关的信息。
概率买一注中奖的数学期望期望为0时的概率需提高倍数一等奖0.000000056-1.71785016811608850.00000047.09二等奖0.00000085-1.99491961215925340.00033393.67三等奖0.0000091-1.97255676400907220.0006772.88 四等奖0.00043-1.91228585964924940.009922.8五等奖0.0078-1.90690752170521360.166721.48六等奖0.06 -1.58775217413287480.28574.85 如果我们将中奖概率提升至数学期望为0时的概率以上，比如我们把六等奖的概率从6%提升至30%，是不是就可以赚钱了？不，仅仅看到数学期望还不够，我们还需要另一个神器保驾护航，那它是什么呢？我们下一期见分晓。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89fd24089ae2fa1ef61df8c16f8a02ab/" rel="bookmark">
			快慢指针解决回文问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快慢指针解决回文问题 数组或字符串方法求解 class Solution { public: bool isPalindrome(ListNode* head) { vector&lt;int&gt;num; while(head){ num.push_back(head-&gt;val); head = head-&gt;next; } int k = (num.size()+1)/2,len = num.size(); for(int i=0;i&lt;k;i++) if(num[i] != num[len-i-1])return false; return true; } }; class Solution { public: bool isPalindrome(ListNode* head) { string s=""; while(head){ s += head-&gt;val; head = head-&gt;next; } int k = s.length(); for(int i=0;i&lt;(k+1)/2;i++) if(s[i] != s[k-i-1])return false; return true; } }; 快慢指针 快慢指针中的快慢是指移动的步长，及每次向前移速度的快慢。例如：快指针每次沿链表向前移动2，慢指针每次向前移动1。
算法过程 找到中间结点并翻转前半部分奇数节点特殊处理判断是否回文返回结果 class Solution { public: bool isPalindrome(ListNode* head) { ListNode *fast=head,*slow=head; ListNode *p,*pre=NULL;//用于翻转前半部分 while(fast &amp;&amp; fast-&gt;next){ p=slow; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; p-&gt;next=pre; //先移动再断连接翻转，若先翻转再移动，slow、fast将找不到next pre=p; } if(fast)slow=slow-&gt;next;//奇数个节点 while(pre &amp;&amp; slow){ if(pre-&gt;val !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89fd24089ae2fa1ef61df8c16f8a02ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cff2bddc6b910c77c1c3da760c1f752/" rel="bookmark">
			Python 基础测试题（含答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 选择题：每小题 2 分，共 20 题，总分 40 分。 1、 下列标识符命名中， 符合规范的是（ ）。
A、 1_a B、 for C、 年龄 D、 a#b
2、 下列标识符中，不是 Python 支持的数据类型的是 （ ）。
A、 char B、 int C、 float D、 str
3、 下列选项中，不是 Python 关键字的选项是（ ）。
A、 with B、 int C、 del D、 for
4、 表达式 3 and 4 的结果为（ ）。
A、 3 B、 4 C、 True D、 False
5、 表达式 eval(“500/10”)的结果为（ ）。
A、 “500/10” B、 500/10 C、 50 D、 50.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cff2bddc6b910c77c1c3da760c1f752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7652521170a8f5ca7c128b23e422f698/" rel="bookmark">
			解决python jsonify日期数据小8小时的时区问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 flask.jsonify在调用dumps后，如果数据里有日期类型的， 就会把时间减去8小时，从UTC转换成GMT，为了解决这个问题， 就重写了json.JSONEncoder的default方法， 直接将date类型的数据转换成字符串即可，然后在序列化的时候， 指明序列化类名就可以了
class MYJSONEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, datetime): return obj.strftime('%Y-%m-%d %H:%M:%S') if isinstance(obj, date): return obj.strftime('%Y-%m-%d') return super(MYJSONEncoder, self).default(obj) # data就是需要返回的且含有date类型的数据 ret = eval(json.dumps(data, cls=MYJSONEncoder)) return make_response(jsonify(ret), 200) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27f59b258b50ddaafe9304b174acbb3a/" rel="bookmark">
			微信小程序之登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、登录流程时序
1.1、wx.login(Object object)
1.1.1、功能描述
1.1.2、参数
1.1.3、object.success 回调函数
1.2、auth.code2Session
1.2.1、请求地址
1.2.2、请求参数
1.2.3、返回值
2、使用微信登录
2.1、小程序端js文件
2.2、云函数端js文件
3、获取手机号码
3.1、小程序端代码
3.2、云函数端js文件
小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。详情查看：微信官方文档-小程序登录
1、登录流程时序 说明
调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。调用 auth.code2Session 接口，换取 用户唯一标识 OpenID 、 用户在微信开放平台帐号下的唯一标识UnionID（若当前小程序已绑定到微信开放平台帐号） 和 会话密钥 session_key。 之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。
注意事项
会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。临时登录凭证 code 只能使用一次 1.1、wx.login(Object object) 1.1.1、功能描述 调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户在当前小程序的唯一标识（openid）、微信开放平台帐号下的唯一标识（unionid，若当前小程序已绑定到微信开放平台帐号）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成
1.1.2、参数 属性类型默认值必填说明timeoutnumber否超时时间，单位mssuccessfunction否接口调用成功的回调函数failfunction否接口调用失败的回调函数completefunction否接口调用结束的回调函数（调用成功、失败都会执行） 1.1.3、object.success 回调函数 属性类型说明codestring用户登录凭证（有效期五分钟）。开发者需要在开发者服务器后台调用 auth.code2Session，使用 code 换取 openid、unionid、session_key 等信息 1.2、auth.code2Session 注意：这个作用于服务端，不要在客户端调用
登录凭证校验。通过 wx.login 接口获得临时登录凭证 code 后传到开发者服务器调用此接口完成登录流程
1.2.1、请求地址 GET https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code 1.2.2、请求参数 属性类型默认值必填说明appidstring是小程序 appIdsecretstring是小程序 appSecretjs_codestring是登录时获取的 codegrant_typestring是授权类型，此处只需填写 authorization_code 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27f59b258b50ddaafe9304b174acbb3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954fa77f2f42ec88b9a9b77d9ae02e82/" rel="bookmark">
			MATLAB R2022a 安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab 2022破解版可以帮助您进行矩阵运算、绘制函数和数据、实现算法、创建用户界面、连接其他编程语言的程序等,主要应用于工程计算、控制设计、信号处理与通讯、图像处理、信号检测、金融建模设计与分析等领域。
安装教程详解
1.MATLAB R2022下载完成后打开，双击InstallForMacOSX进行安装。
2.弹出一个MATLAB R2022安装程序，在高级选项里选择我有文件安装密钥
3.选择是，同意MATLAB R2022 协议，点击下一步
4.选择已有许可证的文件安装密钥，然后将安装密钥复制到安装界面，再点击下一步(安装密钥：50874-33247-14209-37962-45495-25133-28159-33348-18070-60881-29843-35694-31780-18077-36759-35464-51270-19436-54668-35284-27811-01134-26918-26782-54088)
5.返回镜像包，将license文件夹拖到桌面
6.点击浏览，选择刚才拖到桌面的桌面的license，点击open
7.点击下一步
8.选择安装路径为Applications，点击下一步
9.选择要安装的产品，然后点击下一步
10.点击开始安装
11.正在安装，时间稍微有点长，请耐心等待！
12.matlab 2022破解版安装完成，点击关闭
13.返回matlab mac破解版镜像包打开MATLAB破解补丁。
14.将左侧的libmwservices.dylib拷贝到lmgrimpl文件夹，点击替换。
lmgrimpl路径：/Applications/MATLAB_R2022a/bin/maci64/matlab_startup_plugins/lmgrimpl 注意！如果用户没有关闭sip会出现【libmwservices.dylib】已损坏，无法打开软件。你可以关闭sip或者按下面教程进行也可以！
首先我们将【libmwservices.dylib文件】拖到桌面。
然后在终端输入【sudo xattr -r -d com.apple.quarantine】，然后在命令后面加一个空格，就是点一下空格键，然后将桌面的【libmwservices.dylib】拖到终端命令的后面，然后点击回车键！
完成后，将【libmwservices.dylib文件】拖到lmgrimpl文件夹即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1163bf81dfb77e2ca97eab11adb1d436/" rel="bookmark">
			如何使用evo工具评估LeGO-LOAM跑KITTI数据集的结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何使用evo工具评估LeGO-LOAM跑KITTI数据集的结果 下载KITTI数据集安装kitti2bag修改LeGO-LOAM代码utility.himageProjection.cpptransformFusion.cpp 安装evo最终结果 下载KITTI数据集 官方链接：KITTI官网
我们只用得到点云数据集和groundtruth，也就是odometry data set (velodyne laser data, 80 GB)和odometry ground truth poses (4 MB)，不过我自己也没下成功那个80G的包，而是在raw data选项卡里找了00-10对应的包来下，要下的是包的scnced+rectified data与calibration两项，如图：
这里给出groundtruth的00-10对应的数据集的名字（图来自CSDN博主学无止境的小龟）：
安装kitti2bag 这个工具是用来把我们上一步中下的KITTI数据集转化成bag文件形式，直接pip安装就行。
pip install kitti2bag 把上一步中的数据集解压并如下合并：
（那个bag文件是我生成的，不用管）
然后在2011_09_30所在文件夹（即当前文件夹下）运行：
kitti2bag -t 2011_09_30 -r 0018 raw_synced 注意标号一定是要和你下的数据集的号对应，比如我这里就是0018（之前没注意这个就总运行错误，排查半天发现命令没打对）。
成功之后就会把文件夹转化成kitti_2011_09_30_drive_0018_synced.bag。
修改LeGO-LOAM代码 utility.h 原代码中是设置为16线的，不适配KITTI数据集的64线，以及其他一些参数也需要修改，所以在原代码中修改如下：
// VLP-16 //extern const int N_SCAN = 16; //extern const int Horizon_SCAN = 1800; //extern const float ang_res_x = 0.2; //extern const float ang_res_y = 2.0; //extern const float ang_bottom = 15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1163bf81dfb77e2ca97eab11adb1d436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73045e0f5813b05c26fd22f11c15933b/" rel="bookmark">
			Python切片总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.切片定义 定义： 切片是指对操作的对象截取其中一部分的操作。字符串、列表、元组都支持切片操作。
语法： 切片的语法：[起始:结束:步长]，其中步长可有可无。
注意： 选取的区间属于左闭右开型，即从”起始”位开始，到”结束”位的前一位结束（不包含结束位本身)。
step: 步长，默认取值是 1 ，可以为负数，默认方向是从左往右，负数代表从右往左 。 二.切片操作 1.切割获取单个值
&gt;&gt;&gt; a=[1,2,3,4,5,6,7,8,9] &gt;&gt;&gt; a[0] 1 &gt;&gt;&gt; a[5] 6 &gt;&gt;&gt; 2.切割完整对象
&gt;&gt;&gt; a [1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; a[:] [1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; a[::] [1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; a[::-1]#-1 从右往左 [9, 8, 7, 6, 5, 4, 3, 2, 1] 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73045e0f5813b05c26fd22f11c15933b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee2503d5ca4051d646d72cd13e075180/" rel="bookmark">
			triton部署 python backend 输入字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：
最近在做智能对话项目，用triton进行模型的部署和管理。
triton 除了部署模型外，还支持.py文件的推理。根据项目需求，需要将自定的python代码，作为模型部署到triton中，且模型的输入是文字。输出的结果是分词结果。
准备：
1.triton 21.12镜像
2.容器中安装 LAC库。百度分词库。
pip install lac -i https://mirror.baidu.com/pypi/simple
操作：
1、在模型仓库下，创建如图所示的目录结构；
lac – 模型名称，在配置文件，客户端输入时，都需要指定
model.py – 服务端，具体的代码实现
config.pbtxt – 模型的配置文件
2、config.bptxt
name: "lac" # 模型名称 backend: "python" input [ { name: "INPUT0" #输入名称 data_type: TYPE_STRING #当输入为字符串时，配置该格式 dims: [ 1 ] #输入的维度为一维，即字符串 } ] output [ { name: "OUTPUT0" data_type: TYPE_STRING #输出格式 dims: [ 1 ] } ] instance_group [ { kind: KIND_CPU } ] 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee2503d5ca4051d646d72cd13e075180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2199a94e5c4f8a3628a49f835206b6/" rel="bookmark">
			数据库连接不上可能存在的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://qastack.cn/server/186057/mysql-creating-a-user-that-can-connect-from-multiple-hosts
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59af18882a8f9d94e681416cc90c0b41/" rel="bookmark">
			QT实现窗口置顶、置顶状态切换、多窗口置顶优先关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们使用QT进行界面开发时，可能会遇到需要将窗口置顶的情况。最常见的就是，需要制作一个悬浮工具栏，悬浮菜单，甚至是悬浮的画板。这就意味这我们需要将这个窗口置顶于“系统”以及我们自己“软件”的窗口之上。
其实实现的方法很简单，就是在创建这个窗口类的时候，在构造函数中的加一个Qt::WindowFlags
枚举标识
Widget::Widget(QWidget *parent) : QWidget(parent,Qt::Widget | Qt::WindowStaysOnTopHint) , ui(new Ui::Widget) { ui-&gt;setupUi(this); } Qt::WindowStaysOnTopHint的意思就是窗口置顶的意思，设置了之后就能一直悬浮在桌面上面了。
有关其他的枚举标识，可以参考这个。Qt::WindowFlags枚举类型解析 像取消顶部工具条、无边框、弹窗化什么的，都可以实现。
现在有一种情况是，我们需要灵活切换窗口的置顶状态，那就可以直接调用相关的设置接口来实现。setWindowFlags（）；
具体的话是这样：
void Widget::on_pushButton_clicked() { if(!istop) { Qt::WindowFlags m_flags = windowFlags(); setWindowFlags(m_flags | Qt::WindowStaysOnTopHint); show(); qDebug()&lt;&lt;"always top"; }else{ //Qt::WindowFlags m_flags = windowFlags(); //setWindowFlags(Qt::Widget); setWindowFlags(NULL); show(); qDebug()&lt;&lt;"no always top"; } istop=!istop; } setWindowFlags(Qt::Widget);和setWindowFlags(NULL);都可以取消置顶状态，只要重新设置就可以了。但这样设置之后，窗口是默认不显示的，所以需要show一下。但show的时候，窗口会有明显的闪烁。这个还没能很好的解决。
另外还要一个问题，两个置顶窗口之间的优先级无法设置和判定，也就是说用同样的方法设置两个置顶窗口，他们之间的拖动，是可以覆盖住对方的，取决于当前焦点点击再哪个窗口里面。
这个问题，在某些场合里面是互斥违和的。
目前有一种方法是，把a对象设置成b对象的父类，那么b对象就始终置顶与a对象
Widget::Widget(QWidget *parent) : QWidget(parent,Qt::Widget | Qt::WindowStaysOnTopHint) , ui(new Ui::Widget) { ui-&gt;setupUi(this); son_widget_1 = new QWidget(this); son_widget_2 = new QWidget(son_widget_1); son_widget_1-&gt;setWindowFlags(Qt::Dialog | Qt::WindowStaysOnTopHint); son_widget_2-&gt;setWindowFlags(Qt::Dialog | Qt::WindowStaysOnTopHint); son_widget_1-&gt;setWindowTitle("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59af18882a8f9d94e681416cc90c0b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4cf5f675051889172afe991a98ec789/" rel="bookmark">
			【密码加密方式——Md5&#43;盐】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		密码加密方式——Md5+盐 一、Md5介绍1、Md5介绍2、特点 二、Md5 + 盐加密介绍1、介绍2、优点3、示例 一、Md5介绍 1、Md5介绍 MD5简介：MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现
2、特点 主流编程语言普遍已有MD5实现。MD5算法具有以下特点：
*压缩性：任意长度的数据，算出的MD5值长度都是固定的。
*容易计算：从原数据计算出MD5值很容易。
*抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
*强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被"压缩"成一种保密的格式（就是把一个任意长度的字节串变换成一定长的16进制数字串）。
二、Md5 + 盐加密介绍 1、介绍 Md5+盐值加密，简单来说就是通过MD5加密方式把密码，通过某些特定的秘钥值【即：盐】进行加密、生成加密后的字符串。
2、优点 *易理解，使用方便，性能高。
*根据实际业务可把相应的key按照业务要求自定义盐。扩展性强。
*安全性更高
3、示例 1、根据特定字符串随机生成盐
/** * 随机盐值 */ private static final String CONSTANT = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; /** * 获取随机长度字符串(盐值) * @param length * @return */ public static String getStringNumRandom(int length){ Random random = new Random(); StringBuilder stringBuilder = new StringBuilder(length); for (int i=0;i&lt;length;i++){ stringBuilder.append(CONSTANT.charAt(random.nextInt(CONSTANT.length()))); } return stringBuilder.toString(); } 2、加密验证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4cf5f675051889172afe991a98ec789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1df61604c6c30109760c67574c8cec/" rel="bookmark">
			国标28181：libosip2&amp;libeXosip2编译使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		libosip2与libeXosip2 libosip2
GNU libosip2库是是SIP - rfc3261的一个实现。该库旨在为多媒体和电信软件开发人员提供一个简单而强大的接口，以便在其应用程序中启动和控制基于SIP的会话oSIP是跨平台的。 libeXosip2
libosip2主要与·libeXosip2库一起使用，后者为用户代理实现提供了更简单的API。
eXosip2不是GNU项目的一部分。该协议主要用于VoIP电话应用程序(端点或会议服务器)，但对于希望建立会话(如多人游戏)的任何应用程序也可能有用。 eXosip是Osip2的一个扩展协议集，它部分封装了Osip2协议栈，使得它更容易被使用。使用sip 协议建立多媒体会话是一个复杂的过程，exosip 库开发的目的在于隐藏这种复杂性。正如它的名称所表示的，eXosip2 - the eXtended osip Library，它扩展了osip 库，实现了一个简单的高层API。通过使用exosip，我们可以避免直接使用osip 带来的困难。需要注意，exosip 并不是对osip 的简单封装包裹，而是扩展。Osip 专注于sip 消息的解析，事务状态机的实现，而exosip 则基于osip 实现了call、options、register、publish 等更倾向于功能性的接口。当然，这些实现都是依赖于底层osip 库已有的功能的。两者区别
osip:不带传输层（socket自己管理） exosip带传输层（socket协议栈管理）osip:无SSL exosip:有SSLosip:只提供线程函数封装（让用户自己决定）exosip运行时直接带线程(默认有，直接提供会话的状态机的运行线程_eXosip_thread) osip/eXosip已经在多家SIPit进行了测试，并验证了与大多数供应商的合规性。
下载 osipexosip 这里有个问题，从4.0.0版本开始，API接口函数和之前有一些改动。我这里下载的是5.3.0
libexosip2-5.3.0.tar.gzlibosip2-5.3.0.tar.gz 编译 将上面下载的源码包解压后加入工程
当前工程目录如下：
其余部分为RTP对接，具体可以参考C/C++编程：GB28010对接之jrtplib从编译到使用，不过不看前文也没有影响
编写脚本
我们在export中再加入两个脚本，用来编译libosip2和libexosip2
build_osip.sh内容如下：
#!/bin/bash currentPath=$(pwd) libPath=$(pwd)/../libosip2-5.3.0 if [ -d "./libosip" ]; then rm -rf libosip fi mkdir libosip cd libosip installPath=$(pwd) cd ${libPath} ./configure --prefix=${installPath} make make install cd ${currentPath} # 执行make时遇到问题，找了篇帖子解决了，原因不详细 // TODO 研究 # aclocal-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f1df61604c6c30109760c67574c8cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423d0b454acfe3aeebc4ff3011c05cda/" rel="bookmark">
			linux环境下questasim 10.7的安装步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux环境:centos6.8系统
Questasim 10.7安装包
questasim_10.7_linux64.part2.rar_questasim_10.7_linux64-Linux文档类资源-CSDN下载
questasim_10.7_linux64.part1.rar_questasim_10.7_linux64-Linux文档类资源-CSDN下载
多种modelsim版本下载地址
http://www.csit-sun.pub.ro/ise/Mentor_Graphics/
安装步骤：
1、安装Questasim 10.7，这个和windows下是一样的。
2、将crack文件夹中的patch_2020 和 sfk 两个文件，复制到安装目录的questasim/linux_x86_64/mgls/lib下
3、给sfk文件权限755 chmod 755 sfk
4、使用sfk更改文件（root用户），此操作会更改两个文件。
./sfk rep -yes -pat -bin /5589E557565381ECD00000008B5508/31C0C357565381ECD00000008B5508/ -bin /5589E557565381ECD8000000E8000000005B81C3/33C0C357565381ECD8000000E8000000005B81C3/ -bin /41574989FF415641554154554889CD534489C3/33C0C389FF415641554154554889CD534489C3/ -dir /usr/questasim
5、返回crack文件夹下，修改license.rc文件
第一行：修改成自己主机名和mac地址
第二行：mgcld &lt;安装目录&gt;/linux_x86_64
转载地址：linux环境下questasim 10.7的安装步骤_hhh_fpga的博客-CSDN博客_questasim安装
6、生成license文件 ./mgcrypt.exe -i license.src -o mentor.dat
7、将mentor.dat复制到安装目录下
8、更改mentor.dat文件：dos2unix ./mentor.dat
9、修改变量设置
export PATH=$PATH:/usr/questasim/linux_x86_64
export LM_LICENSE_FILE=/usr/questasim/mentor.dat
alias lmim="lmgrd -c /usr/questasim/mentor.dat"
10、执行配置环境
source ~/.bashrc
11、启动许可（每次开机都需要）
lmim
12、启动Questasim 10.7、
Vsim
完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce6d4e2046dfe84a676aaa1582d3fd9/" rel="bookmark">
			牛客：计算糖果（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 题名：计算糖果题目描述：输入描述：输出描述：示例：解题思路：代码：原题链接：[计算糖果](https://www.nowcoder.com/questionTerminal/02d8d42b197646a5bbd0a98785bb3a34) 题名：计算糖果 题目描述： A,B,C三个人是好朋友,每个人手里都有一些糖果,我们不知道他们每个人手上具体有多少个糖果,但是我们知道以下的信息： A - B, B - C, A + B, B + C. 这四个数值.每个字母代表每个人所拥有的糖果数.
现在需要通过这四个数值计算出每个人手里有多少个糖果,即A,B,C。这里保证最多只有一组整数A,B,C满足所有题设条件
输入描述： 输入为一行，一共4个整数，分别为A - B，B - C，A + B，B + C，用空格隔开。 范围均在-30到30之间(闭区间)。
输出描述： 输出为一行，如果存在满足的整数A，B，C则按顺序输出A，B，C，用空格隔开，行末无空格。 如果不存在这样的整数A，B，C，则输出No
示例： 解题思路： 这道题的实质是一道数学题。从题目描述中可以看出，我们知道以下四个表达式的值：
表达式①：A-B=a；
表达式②：B-C=b；
表达式③：A+B=c；
表达式④：B+C=d；
当①+③可以得到：A=(a+c)/2；
当②+④可以得到：B1=(b+d)/2；
当③-①可以得到：B2=(c-a)/2；
当④-②可以得到：C=(d-b)/2；
此时，如果B1不等于B2，那就说明不存在符合题意的A、B、C整数值，若相等，就可以直接输出符合题意的A、B、C整数值。
代码： import java.util.*; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int a = in.nextInt(); int b = in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ce6d4e2046dfe84a676aaa1582d3fd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2a4f53232347a51784c3d5448b83e92/" rel="bookmark">
			python实现你出生到现在的天数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只需要修改第一个括号里的日期为你的生日，修改第二个括号里的日期为现在的时间，即可算出你出生的天数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6dc8aa66016d747d9f35c64eb090211/" rel="bookmark">
			NLP-D30-自注意力机制&amp;Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		—0526在啃黄瓜，已经看了一会沐沐叻。
1、Trandformer 看着看着简直要喷黄瓜了hhhhhhhh。
Tranformer也挺简单的，我一张ppt就讲完了。
不过这张ppt做的挺好的hhhh
-------0600看完了transformer，但对应代码还没看，看了多头的代码。打算先code一下。
越来越觉得数学美了（主要是自己渐渐能看懂了），美就美在明确、简洁。
2、多头注意力 我只想说，ipad+pencil真的是学习dl神奇。维度之间的事情，用笔画一画就可以解决了。
—0720
数学推导太爽了！！收拾宿舍去！
----0816回来把的多头注意力的代码写完了、趴一会，去看看夏一部分了。
–0830开始开始！
3\多头自注意力机制 其实就是把q，和k-v都换成是自己。
刚刚的多头注意力，q是x，k-v是y。也就是q和k-v不一样。
—0905听着听着感觉代码量好大哇~但也正是提高的机会呢！
4、Transformer 1\Transformer 完全基于注意力机制，没有任何卷积或者循环神经网络的操作。
这段文字好精华啊
总结一下：
1、编码器两个模块：多头注意力+逐位前馈网络
（1）多头注意力是自注意力，后面再加上残差和规范化（layer-normalization）,而且输入和输出的shape是相同的，这样可以保证能够重复n次。
（2）逐位前馈网络
这个其实就是两层全连接，为了解决3位其中不确定的n的问题，也就是全连接啦
2、解码器三个模块：
（1）掩蔽多头注意力:和encoder比，多了掩蔽，主要是因为我们不能提前知道后面的东西.用mask实现就好。后面进行残差+layer_normalization
（2）【new-old】这个模块是encoder中么有的，但是在seq2seq模型里还是比较常见的。这个模块的Attention不是自注意力，而是普通的注意力。Q选取刚刚的masked-multi-attention的输出，而K-V选取编码器的输出。后面再加上残差和layer-normalization。
（3）第三个模块还是逐位前馈网络，实现一个三个维度的全连接。
最后通过一个FC得到结果。
5\疑问：基于位置的前馈网络，还是不懂为啥，不过李沐大大也没解释hhhhhhhhhh说，就是个全连接hhhhh 他的意思莫非是展开了，然后用一个mlp直接一起处理不同sample的steps？然后这个MLP的输入信息是还有sequence信息的？？？一会再查查叭。
啊这。。查了一下，好像就也只是。。。简单全连接的感觉
6、层规范化 在自然语言处理任务中，输入的通常是变长序列，批量规范化，不如层规范化好。
层规范化，就是基于特征维度进行规范化，也就是说，不同batch的seq长度可能不同，虽然认为pre了相同长度，但还是有pad存在，所以不同sample之间不好做规范化，可以一句话内自己进行规范，也就是层规范化。
7\num_hiddens num_hiddens（如标号2所示）的数量就是X的dim【2】（如标号1所示）的大小——也就是用多少个neuron表示一个token。为了做n层，输入输出的shape应该是相同的，所以最后的第三位也要转换成num_hiddens那么大（如标号3所示）
**
补充：其实这个num_hiddens就是embedding的那个num_hiddens，也就是表示一个token的神经元的个数啦。 我感觉这里ffn的第一个参数写的是input而不是num_hiddens可能是随意写的，或者是为了后期的灵活性？至少从现在看来，他这里的使用ffn_num_input的大小都和num_hiddens是一样的，（因为最初shi的输入是经过embedding来的，最后一维度大小为num_hiddens；后面的输出由于ffn的output的大小为num_hiddens，所以后面的第三维度的大小也都为num_hiddens）。这里看，着实没有必要单独写这个ffn_num_input，不知道是不是为了后期操作呢？？？ **
对输入嵌入进行缩放 pos_encoding是做一个位置码+原来x的embedding的操作，但我感觉是embedding时做了scale，导致的X的每个量太小了，再加上pos又都在-1和1之间，会导致pos占主导地位，而本身X的信息不matter，所以先把X放大些，调整一下和pos信息的比例。
—1024休息一下下。。
TransformerEncoder测试 TransformerEncoder之所以传入的是二维的（batch,steps），是因为我们在这个TransformerEncoder里面内置了embedding层，可以将其变为num_hiddens个。
-------1051去打饭干饭啦！！！！！！
-------1356
看一个小时，争取把bert看完，就去做核酸啦~
本来这里有点不清楚，又看了一遍，懂了。
在预测的时候，我们的注意力是去看之前的输入和现在的输入，
我们在这里把他们cat起来，然后赋给key_values。一点点叠。
i表示第i个块，所以每个块都是分别叠的。
—1549做完核酸回来啦~顺便快把bert的代码视频看完了！！！棒棒！！！先看完最后一点
----1554顺便把微调看了叭！！但我感觉自己基本也知道啦！
—1622感觉要下雨了诶，想去跑个步！！！BERT微调也看完了哦！！一会把两课的QA看了！
—1829外面太阳好大，一会再去跑步。
—1838两个Q&amp;A都看完啦~敲敲代码啦
8decoder的第二个attention做了类似于seq2seq的连接 从代码上看，应该是n个encoder和decoder对应的之间都做了query的。 因为在decoder里面之间forloop了num_layers个blk，每个blk都是三个模块，第二个模块介绍一个attention。
刚开始传过来encoder的state；
然后返回decoder i=1的state；
下次再更新为i=2的state
额鹅鹅鹅这么看，就相互查了1次呀。
9EncoderDecoder复习 主要是在forward中运行encoder，得到enc_outputs,再放入decoder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6dc8aa66016d747d9f35c64eb090211/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e1746276a1a0c9fbdb959f2e222791/" rel="bookmark">
			在 JavaScript 中将字符串转换为数字的 7 种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用 parseInt() parseInt()解析一个字符串并返回一个整数。允许空格。仅返回第一个数字。
这种方法虽然有一个限制。如果您解析十进制数，它将四舍五入到最接近的整数值，并将该值转换为string。可能需要使用parseFloat()方法进行文字转换。
myString = '129' console.log(parseInt(myString)) // expected result: 129 a = 12.22 console.log(parseInt(a)) // expected result: 12 2. 使用 Number() Number()可用于将 JavaScript 变量转换为数字。我们可以用它来转换字符串太数字。
如果该值不能转换为数字，NaN则返回。
Number("10"); // returns 10 Number(" 10 "); // returns 10 Number("10.33"); // returns 10.33 3. 使用一元运算符 (+) 一元加号运算符 ( +) 在其操作数之前并计算其操作数，但如果尚未将其转换为数字，则尝试将其转换为数字。
const x = 25; const y = -25; console.log(+x); // expected output: 25 console.log(+y); // expected output: -25 console.log(+''); // expected output: 0 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88e1746276a1a0c9fbdb959f2e222791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43be22c50c6ffae64f2296e48318cd47/" rel="bookmark">
			二叉树的前序中序后序遍历java代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前序遍历概述 前序遍历（VLR） 是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。
若二叉树为空则结束返回，否则：
（1）访问根结点。
（2）前序遍历左子树。
（3）前序遍历右子树 。
需要注意的是：遍历左右子树时仍然采用前序遍历方法。
2.二叉树 3.遍历过程 前序遍历首先访问根节点
前序遍历节点输出1
​然后访问左子树2，遍历输出左子树当前节点
前序遍历节点输出1 2
然后左子树任然按照前序遍历的方法首先访问左子树4，左子树首先输出4，发现4为叶子节点，没有左子树和右子树，回到上一步指向左子树2
前序遍历节点输出1 2 4
左子树2根据前序遍历已经访问了根节点和左子树，接下来访问左子树2的右节点5（注意这里递归到4这个叶子节点后，会返回到2开始继续前序遍历，所以其实指针的指向顺序是4-&gt;2-&gt;5）
前序遍历节点输出1 2 4 5
1.当前5为叶子节点没有左子树和右子树，所以指针回到2节点
2.发现2节点已经输出，2的左子树和右子树也遍历完成，所以根据递归继续返回，指针从2回到1
3.发现1节点和左子树都已经遍历，根据前序遍历的规则，最后遍历右子树，指针向右子树移动指向3节点
前序遍历节点输出1 2 4 5 3
之后分别遍历节点3的左节点和右节点
前序遍历节点输出1 2 4 5 3 6 7
4.代码实现 @Test public void testBinaryTree(){ int[] array = {1,2,3,4,5,6,7};//1 2 4 5 3 6 7 前序 4 2 5 1 6 3 7 中序 4 5 2 6 7 3 1 后序 //创建一个ArrBinaryTree binaryTree binaryTree = new binaryTree(array); binaryTree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43be22c50c6ffae64f2296e48318cd47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be8667cb0f02ca1726a1af11d8bc7966/" rel="bookmark">
			怎样提高报表呈现的性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报表的性能很重要，是一个总被谈及的问题，跑的慢的报表用户体验恶劣，无法忍受。解决这些慢的性能问题，也成了项目方和工程师头疼的事情。一出状况，就得安排技术好的，能力强的工程师去救火，本来利润就薄，还得不断的追加人工成本，而且工程师有时候也无能为力，并不是所有的性能问题都能靠程序员能力解决的
这个总会让人头疼的问题没办法解决吗？没有好的方法去提升性能了吗？
解决这个问题之前，我们得先理清楚问题的根源，是什么导致了报表的性能问题，找到根源，我们才能对症下药，才能治本
报表性能问题出在什么环节？ 报表的呈现周期中，大致可以分为下图的4个环节，4个环节都有可能造成报表的性能问题，但概率较高的是前两个环节，数据准备和数据传输（图中黄色电池电量图，代表了出问题的程度）
所以解决报表的性能问题，就得首先重点看前两个环节，虽然说这俩环节严格意义上讲其实并不属于报表的功能范畴，而是数据源本身的问题，但是用户不会去管，也分不清楚是谁的原因导致报表慢的，所以不管是实施方还是报表工具本身，得在这两方面有优化的能力才能解决这俩问题
数据准备的问题和优化 报表中展现的数据大部分情况下并不是从数据来源中直接取就可以，大都需要经过计算处理加工，准备好以后，才能被报表工具来使用
这些数据准备，多数是用SQL或存储过程来做的，一些涉及库外数据来源和计算的，可能会用其他的高级语言去处理
当这个过程出现性能问题时，首先要做的是去优化这些数据准备的代码，比如优化SQL或存储过程，完成同样运算的SQL可能有不同的写法，有可能会有相当大的性能差异（比如把EXISTS换成JOIN就能快得多）。但仍然有不少时候，即使SQL已经做了几轮优化，性能仍然起不来，这时候通常就要考虑升级硬件了，扩容数据库做集群或者升级服务器配置等，不过这又会带来额外高昂的成本
还有个办法是使用开源的SPL来替代SQL做数据准备
上面说到的，有时候经过多轮优化的SQL仍然跑不快，这是因为SQL本身有局限性，缺乏很多数据类型和基础运算，很多高性能算法都无法描述，结果只能使用较慢的算法，用了这么多年，虽然很多数据库和大数据平台都在工程上对这些慢的算法有所优化，但也只能针对简单的场景，情况复杂之后数据库的优化器依旧会“晕”掉，并没有从根本上解决SQL局限性的问题
而SPL是一种拥有全新高效算法的计算语言，可以从根本上解决各类SQL局限性导致的性能难题
我们通过一个简单小例来看一下SPL比SQL的算法高效在哪里
比如要在 1 亿条数据中取出前 10 名，用SQL算就会涉及大排序，大排序就会影响性能， 其实我们是可以想出不用大排序的算法的，但SQL无法描述，那就只能指望数据库优化器了，简单情况下，很多商用数据库确实都能优化，使用不必大排序的算法，性能通常也很好，但情况稍微变复杂一些，比如要在每个分组中取前 10 名，要用到窗口函数和子查询，这时候优化器就又无能为力了，又得乖乖去大排序，慢慢的算了
SPL则不然，SPL离散数据集中有普遍集合的概念，TopN 这种运算被认为是和 SUM 和 COUNT 一样的聚合运算，只不过返回值是个集合，用SPL去做个这个计算的时候就不需要做大排序了
有了这样更高效的算法，那速度自然就快了，性能自然也就好了
除了新的高效的算法以外，数据的存储对于性能也非常重要，好算法要有合适的存储机制配合才能生效，SPL也有自己更高效的存储方式，高性能二进制文件存储，相对于普通的数据库存储，SPL的二进制存储和SPL的高效算法配合，性能会更好，使用SPL存储后，可以把原来需要缓存的计算过程变成不需要了，原来要遍历多遍的运算变成只遍历一次甚至不用遍历了，减少硬盘访问量也是非常有效的性能提升手段
报表涉及的数据，基本都是历史数据，必要的时候，把这些数据换一种更高效的方式存储，可行性也是很大的
下面是几个用SPL来优化数据准备的实际案例，有需要的可以详细看一下
开源 SPL 提速保险公司团保明细单查询 2000+ 倍
开源 SPL 提速银行资金头寸报表 20+ 倍
开源 SPL 提速银行 POS 机交易报表 30+ 倍
开源 SPL 提速资产负债表 60 倍
通过这些实际案例可以看出，使用SPL实现了高效的算法后，在SQL无法解决的性能问题中，可能获得数倍以至数十甚至上百倍的性能提升
到这里我们可能会想，解决个性能问题还得把原先的SQL甚至是存储方式都舍弃，全部用新的SPL重新做,这也太费劲了，代价太大了吧
是的，小问题是没这个必要折腾，但是遇上重病那就只能用猛药来医了，当现有的SQL已经无法再继续优化，性能问题已经没办法解决时，那就只能尝试用新的办法来解决了
而且体会过更高效的算法以后，使用新技术估计也不会再是一种迫不得已的选择了，而是会变成更主动自愿的拥抱了
另外一些报表工具已经集成了开源的SPL了，比如润乾报表，直接用这样的工具来做报表，解决起问题来也更直接方便一些
数据传输的问题和优化 报表项目大部分都是JAVA应用，基本都得通过JDBC来取数、做数据传输，有时候我们会发现，SQL很简单，数据库负担也很轻，但数据传输到报表却需要很长时间，传输完成后，报表也算的很快，那就可以判定，就是有些数据库的JDBC取数太慢，导致了性能问题
这是DB本身的问题，怎么优化？
我们动不了厂商的JDBC，那就只能曲线救国，单线程取的慢，如果数据库允许，我们可以尝试多线程并行取，如果报表工具有并行取数的功能，那问题就迎刃而解了，但由于并行取数涉及的数据分段方法和数据库及取数语法需要较复杂代码控制，也不容易做成报表功能，所以目前的报表工具基本都不支持并行取数，那就又得再外围实现了
外围实现，可以是自己用java等高级语言去写，但是会复杂一些，工作量也不小，也可以用现成的计算工具去做，比如前面提到的SPL就可以轻松支持并行计算，下图就是SPL并行取数的代码，写起来还是很简单的，也容易理解
在数据库负担不重时，并行取数几乎可以让传输效率得到线性的提升
附上一个并行取数和单线程取数的性能测试对比，感兴趣的同学可以去看看
JDBC 取数到底有多慢
同样的，如果报表工具中集成了SPL，那也就可以通过并行取数来提升性能了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be8667cb0f02ca1726a1af11d8bc7966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846982bc0362516c0b0bb6c8af3cd05c/" rel="bookmark">
			ubuntu 系统使用过程中发现桌面突然放大，屏幕跟着鼠标走
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu 系统使用过程中发现桌面突然放大，屏幕跟着鼠标走 解决方法：
Alt+鼠标滑轮 可以缩放桌面，问题解决
附：dconf reset -f / 可以将桌面恢复到默认配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4ea1cbfaf98bd3d15f4ab9cecdf5d42/" rel="bookmark">
			windows service 2019安装mysql5.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、mysql下载压缩包。
https://downloads.mysql.com/archives/community/
2、解压文件到安装位置
3、配置环境变量
新建用户变量
变量名：MYSQL
变量值：mysql解压位置
修改用户Path变量：
%MYSQL%bin
4、新建my.ini配置文件
在mysql文件夹中创建my.ini文件
配置如下
[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置连接端口 port = 3306 # 设置mysql的安装目录 basedir="C:\mysql-5.7.37-winx64" # 设置mysql数据库的数据的存放目录 datadir="C:\mysql-5.7.37-winx64\data" #设置5.7版本group by 合法性的检查 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [WinMySQLAdmin] C:\mysql-5.7.37-winx64\bin\mysqld.exe # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB [mysqld] explicit_defaults_for_timestamp=true 5、管理员启动cmd,运行命令
跳转mysql安装位置bin目录下
5.1、安装mysql
输入命令：
mysqld -install
出现找不到MSVCP120.dll的问题。
问题解决1：
下载MSVCP120.dll、MSVCR120.dll文件，放到C:\Windows\System32中。
链接：https://pan.baidu.com/s/1UiUbvuOB1xoNbKG4zdmd-Q?pwd=1849 提取码：1849
问题解决二：下载VC++2019
VC++2019运行库最新版是一款来自微软官方出品的C++开发软件。VC++2019运行库软件集成了微软Windows视窗操作系统应用程序接口(Windows API)、三维动画DirectX API。在安装之前，该脚本将检查并删除现有的不兼容的Visual C ++运行时，包括原始EXE或MSI安装程序，具体可以自行测试。
注：会杀进程，线上服务器谨慎使用。影响线上系统稳定行，可能导致系统崩溃。
链接：https://pan.baidu.com/s/1rnP3Y64XgYy-rmMtctJw0g?pwd=1849 提取码：1849
问题解决，运行
mysqld -install 5.2、启动mysql。输入命令
net start mysql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4ea1cbfaf98bd3d15f4ab9cecdf5d42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505a59b1c5277c3a8b6baf069372a556/" rel="bookmark">
			FreeRTOS系列|FreeRTOS简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. RTOS简介 RTOS全称为 Real Time Operation System，即实时操作系统。RTOS强调的是实时性，又分为硬实时和软实时。硬实时要求在规定的时间内必须完成操作，不允许超时；而软实时里对处理过程超时的要求则没有很严格。RTOS的核心就是任务调度
RTOS的多个工作流如下图示：
RTOS工作原理如下图示：
RTOS通用组件如下图示：
RTOS的特点：
更好的事件实时处理机制更高效利用CPU资源通用的任务管理框架 2. FreeRTOS介绍 FreeRTOS是RTOS的一种，尺寸非常小，可运行于微控制器上。微控制器是尺寸小，资源受限的处理器，它在单个芯片上包含了处理器本身、用于保存要执行的程序的只读存储器（ROM或Flash）、所执行程序需要的随机存取存储器（RAM），一般情况下程序直接从只读存储器执行
微控制器用于深度嵌入式应用，一般都有非常明确、专门的工作。尺寸的限制以及专用的终端应用等性质，令其很少能使用完整的RTOS实现。因此FreeRTOS仅为内核提供了实时调度功能、任务间通信、时序和同步原语。更准确地说，它是一个实时内核，或实时执行器。命令控制台界面、网络栈等额外的功能可作为附加组件
在实际使用FreeRTOS的时候我们需要根据自已的需求来配置FreeRTOS，不同架构的MCU在使用的时候配置也不同，下面介绍FreeRTOS配置文件详解
内核配置一 参数名称参数说明USE_PREEMPTION定义调度器模式CPU_CLOCK_HZ定义CPU的主频TICK_RATE_HZ定义系统时钟节拍数MAX_PRIORITIES定义可供用户使用的最大优先级数MINIMAL_STACK_SIZE定义空闲任务的栈空间大小MAX_TASK_NAME_LEN定义任务名最大的字符数USE_16_BIT_TICKS系统时钟节拍计数使用TickType_t数据类型定义IDLE_SHOULD_YIELD用于使能与空闲任务同优先级的任务 内核配置二 参数名称参数说明USE_MUTEXES用于使能互斥锁USE_RECURSIVE_MUTEXES用于使能递归互斥锁USE_COUNTING_SEMAPHORES用于使能计数信号量QUEUE_REGISTRY_SIZE用于设置可以注册的信号量和消息队列个数USE_APPLICATION_TASK_TAG用于使能任务标记ENABLE_BACKWARD_COMPATIBILITY用于使能新版本对老版本的兼容特性USE_PORT_OPTIMISED_TASK_SELECTION用于优化优先级列表中药执行的最高优先级任务的算法USE_TICKLESS_IDLE用于使能tickless低功耗模式USE_TASK_NOTIFICATIONS使能任务间直接的消息传递，包括信号量、事件标志组和消息邮箱 内存管理 参数名称参数说明MEMORY_ALLOCATION定义内存分配模式TOTAL_HEAP_SIZE定义动态内存分配总长度HEAP_NUMBER定义动态内存管理方式 任务运行信息获取配置 参数名称参数说明GENERATE_RUN_TIME_STATS用于使能任务运行状态参数统计USE_TRACE_FACILITY使能此配置将添加额外的结构体成员和函数USE_STATS_FORMATTING_FUNCTIONS用户配置宏定义 configUSE_TRACE_FACILITY 和configUSE_STATS_FORMATTING_FUNCTIONS都为 1 的时候，将使能函数 vTaskList() 和 vTaskGetRunTimeStats()，如果两者中任何一个为 0，那么这两个函数都将被禁能 软件定时器 参数名称参数说明USE_TIMERS用于使能软件定时器 中断优先级 参数名称参数说明LIBRARY_LOWEST_INTERRUPT_PRIORITY用于配置 FreeRTOS 用到的 SysTick 中断和 PendSV 中断的优先级LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY定义了受 FreeRTOS 管理的最高优先级中断 函数Include配置 参数名称参数说明vTaskPrioritySet设置任务优先级uxTaskPriorityGet获取任务优先级vTaskDelete任务删除vTaskCleanUpResources清理任务资源vTaskSuspend任务挂起vTaskDelayUntil任务绝对延时vTaskDelay任务延时xTaskGetSchedulerState获取调度器状态xTaskResumeFromISR在中断中恢复任务xQueueGetMutexHolder获取互斥锁持有者pcTaskGetTaskName获取任务名称uxTaskGetStackHighWaterMark获取任务堆栈信息xTaskGetCurrentTaskHandle获取当前任务句柄eTaskGetState获取任务状态xEventGroupSetBitFromISR在中断中设置事件标志组xTimerPendFunctionCall定时器挂起后回调函数xTaskAbortDelay终止任务延时xTaskGetHandle获取任务句柄 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/964e30f6168abae1e777b9820067ca96/" rel="bookmark">
			异步执行，ExecutorService的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当一个接口，需要返回多个数据，且每个数据获取的逻辑较为复杂，执行时间较长，那么如果同步去获取的话，这个接口的响应时间会很长，如果异步执行则会快很多
@Override public Result location() throws Exception { //创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(3); //创建计数器 CountDownLatch countDownLatch = new CountDownLatch(3); //执行线程1 Future&lt;List&lt;Map&gt;&gt; lowerLevel = executorService.submit(() -&gt; { try { return 结果1; }finally { //使latch的值减1，如果减到了0，则会唤醒所有等待在这个latch上的线程。 countDownLatch.countDown(); } }); //执行线程2 Future&lt;List&lt;Map&gt;&gt; upperLevel = executorService.submit(() -&gt; { try { return 结果2； } finally { countDownLatch.countDown(); } }); //执行线程3 Future&lt;Map&gt; areaLocationGeoJson = executorService.submit(() -&gt; { try { return 结果3； } finally { countDownLatch.countDown(); } }); //使当前线程进入同步队列进行等待，直到latch的值被减到0或者当前线程被中断，才会被唤醒。 countDownLatch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/964e30f6168abae1e777b9820067ca96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dba5239a74e4a89f6133922acade4b3/" rel="bookmark">
			【论文向】文本纠错近年论文汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【论文向】文本纠错近年论文汇总 目录 【论文向】文本纠错近年论文汇总2020《基于Transformer增强架构的中文语言纠错方法》2020《MaskGEC: Improving Neural Grammatical Error Correction via Dynamic Masking》2021《基于字词粒度噪声数据增强的中文语法纠错》2019 《A two-stage model for chinese grammatical error correction》2020《Heterogeneous Recycle Generation for Chinese Grammatical Error Correction》 注：论文阅读笔记仅帮助大家快读了解、知晓论文的创新点、重点等，如需详细掌握请点击上方标题自行阅读，在此是存在一定博主和读者偏见的，有任何问题欢迎留言指正补充或讨论。
2020《基于Transformer增强架构的中文语言纠错方法》 将语法纠错看作翻译任务，在Transformer结构上提出了一种动态残差结构，结合到了编码器端与解码器端（每一层均为注意力操作+归一化+FFN+归一化）就是将不同层的输出乘上不同的系数wi然后求和 以及 构造了错误数据用于数据增强。数据集：Lang-8、HSK、NLPCC2018
2020《MaskGEC: Improving Neural Grammatical Error Correction via Dynamic Masking》 模型使用Transformer，主要是对输入句进行五种噪声方案：填充符替换、随机替换、字频替换、同音词替换、混合替换，可生成多种“错误-正确”句子对，解决了训练语料库小的问题。
2021《基于字词粒度噪声数据增强的中文语法纠错》 首次提出融合字、词的噪声数据增强方法，仅用transformer模型在NLPCC2018达到sota。并在transformer模型中提出了一种 源端词的Dropout方法，在源端数据经过词嵌入层将随机把一部分词向量置为0（即sentence-&gt;Input Embedding-&gt;Dropout Src-&gt;Positional Embedding-&gt;Encoder）。基于此，在源端以概率Psrc筛选出要被丢弃的单词，将词向量设为0。同时对未被丢弃的其他词向量做出相应补偿，以1/(1-Psrc)的倍率放缩。通过这样方法，模型没有得到完整源端输入，泛化能力更强。噪声增强的方法是针对四大类：冗余、缺词、选词和词序（以及综合）进行词粒度再字粒度的双重噪声化，再累加得到最终的噪声语料。
2019 《A two-stage model for chinese grammatical error correction》 CGEC的sota，采用迭代生成的方式来解决一次预测下来不能完全解决句子中所有错误的问题，这样会使同一个模型被反复使用使得错误修正有局限性。
使用拼写检查模型+Transformer来迭代生成，本文使用的拼写检查模型是5-gram语言模型来获得原始句子的最高概率。具体而言，用jieba分词后，对于每个单词w，如果不在词典D中则用[SCS]替换以生成替换单词，用语言模型从候选单词集中寻找最有可能使得5-gram句子最高概率的词进行替换。
2020《Heterogeneous Recycle Generation for Chinese Grammatical Error Correction》 在上一篇多轮同模型的迭代生成基础上，本文基于多轮不同模型的效果更优的假设。将同时利用NMT和序列编辑模型两种优势。NMT适合重写整句，如改序、多词替换；而序列编辑模型适用于小问题，如移除一个词、添加一个符号
本文贡献：
1 多模型融合系统达到sota，且无需大量训练数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dba5239a74e4a89f6133922acade4b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ffc805a9b5079e0ab411f3cf603fa0/" rel="bookmark">
			【论文向】NAACL2022 汉语纠错多源、多参考数据集MuCGEC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【论文向】MuCGEC: a Multi-Reference Multi-Source Evaluation Dataset for Chinese Grammatical Error Correction 原文地址： MuCGEC: a Multi-Reference Multi-Source Evaluation Dataset for Chinese Grammatical Error Correction
目录 【论文向】MuCGEC: a Multi-Reference Multi-Source Evaluation Dataset for Chinese Grammatical Error Correction一 Introduction二 Data Annotation三 Analysis of Our Annotated Data四 Benchmark Models五 Experiments on NLPCC18-Orig Data六 Evaluation Metrics七 Related Works八 ConclusionsAcknowledgements 注：论文阅读笔记仅帮助大家快读了解、知晓论文的创新点、重点等，如需详细掌握请点击上方标题自行阅读，在此是存在一定博主和读者偏见的，有任何问题欢迎留言指正补充或讨论。
博客顺序完全参照论文顺序书写
一 Introduction GEC语法错误修正 定义问题为，给定可能有错误的文本内容，返回正确的文本。
中文CGEC数据集仅有两个公开的，NLPCC18和CGED。而中文CGEC数据集缺乏多源参考，且数据集源于单一文本。为此，MUCGEC采用多参考、多源数据集，共7063个句子，每个句子约2.3条参考、并提出了两个使用预训练模型的baseline：Seq2Edit、Seq2Seq，且使用了模型集成的方法。
二 Data Annotation 2.1 多源数据部分：重新标注了NLPCC18的测试集、从CGED-2018和CGED-2020测试集中筛选错误句子、通过语言学习平台Lang8，随机选取字符长度30到60的2000个句子。最终，总计获得了7137句，并且抛弃原有的错误标注而重新按照本文的标注准则进行标
2.2 标准范式重新部分：标注GEC数据的方式主要有两种 error-coded 和 direct rewriting：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1ffc805a9b5079e0ab411f3cf603fa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/866dd6f7d586646ac108ebd1ca695ca7/" rel="bookmark">
			剑指 Offer 04. 二维数组中的查找(python)二分法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：
先写一个二分查找函数，二分查找函数的返回写成中间数的索引。
步骤如下：
1、先二分查找第一列（如果有的话），返回第一列小于等于target的索引。
2、如果对应值不为target，就开始使用二分法遍历索引值前的每一行（如果有的话）。
class Solution: def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -&gt; bool: line_list = [] #判断不空 if len(matrix) == 0: return False for i in range(len(matrix)): #判断不空 if len(matrix[i]) == 0: continue line_list.append(matrix[i][0]) row_sign = divide_sick(line_list,target) if len(matrix[row_sign]) == 0: return False if matrix[row_sign][0] == target: return True else: for j in range(row_sign + 1): #判断不空 if len(matrix[j]) == 0: continue line_sign = divide_sick(matrix[j],target) if matrix[j][line_sign] == target: return True return False def divide_sick(a,target): min_num = 0 max_num = len(a) mid_mun = int(len(a)/2) while min_num !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/866dd6f7d586646ac108ebd1ca695ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2c04eb8dace31b9cc4d9a51efb6e6bc/" rel="bookmark">
			linux中的.和..
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在表示路径时，.表示当前目录 … 表示上层目录
除此之外.还能够表示source命令
例如
. ../../test.sh 表示source上上层目录的test.sh文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952d4b8b1f61f436a9d0f0e560bac82b/" rel="bookmark">
			GAMES101-计算机图形学-作业8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最后一次了，断断续续终于炫完了入门课，泪目
你应该修改的函数是:
• rope.cpp 中的Rope::rope(…)
• rope.cpp 中的void Rope::simulateEuler(…)
• rope.cpp 中的void Rope::simulateVerlet(…)
Rope::rope(…)：
直接初始化完事
Rope::Rope(Vector2D start, Vector2D end, int num_nodes, float node_mass, float k, vector&lt;int&gt; pinned_nodes) { // TODO (Part 1): Create a rope starting at `start`, ending at `end`, and containing `num_nodes` nodes. // Comment-in this part when you implement the constructor // for (auto &amp;i : pinned_nodes) { // masses[i]-&gt;pinned = true; // } Vector2D step = (end - start) / (num_nodes + 1); for (int i = 0; i &lt; num_nodes + 2; i++) { Mass* nodeCur = new Mass(start + i * step, node_mass, false); this-&gt;masses.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/952d4b8b1f61f436a9d0f0e560bac82b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/267/">«</a>
	<span class="pagination__item pagination__item--current">268/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/269/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>