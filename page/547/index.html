<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1facdce84bf02fab6ab83a18d7f4d740/" rel="bookmark">
			UVAlive - 3938 —— &#34;Ray, Pass me the dishes!&#34; 【线段树】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://acm.hust.edu.cn/vjudge/problem/viewProblem.action?id=22105
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;string&gt; #define INF 0x3f3f3f3f #define lson rt&lt;&lt;1, l, m #define rson rt&lt;&lt;1|1, m+1, r using namespace std; typedef long long LL; const int MAXN = 524288 + 5; int n; struct P { LL d, sum, head, tail; int l, r, head_bound, tail_bound; } p[MAXN &lt;&lt; 1]; void pushup(int rt) { int L = rt&lt;&lt;1, R = rt&lt;&lt;1|1; if(p[L].d &gt;= p[R].d) { p[rt].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1facdce84bf02fab6ab83a18d7f4d740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/defe2e61f3386681e32760674633cf3d/" rel="bookmark">
			Eclipse中项目Project Explorer视图与Package Explorer视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题是这样的：
自己在本地环境搭建了个maven项目，然后上传到SVN服务器上去。
然后从SVN上下载项目，进行测试svn上代码是否导入IDE工具正常。
结果看，总是别扭：
后来才知道是视图的缘故：
如果你没有这个视图，这么找：
window---》show view---&gt;other----&gt;java----&gt;Package Explorer
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/739693b7989d23743d16f54e799f2889/" rel="bookmark">
			ARM汇编指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ARM 汇编程序的由机器指令，伪指令和宏指令组成。伪指令不像机器指令那样在处理器运行期间由机器执行，而是汇编程序对源程序汇编期间由汇编程序处理。在前面的指令集章节中，我们已经接触了几条常用到的伪指令，如ADR 、ADRL、LDR、NOP 等，把它们和指令集一起介绍是因为它们在汇编时会被合适的机器指令代替，实现真正机器指令操作。宏是一段独立的程序代码，它是通过伪指令定义的，在程序中使用宏指令即可调用宏。 当程序被汇编时，汇编程序将对每个调用进行展开，用宏定义取代源程序中的宏指令。 A.4.1 符号定义伪指令 符号定义伪指令用于定义ARM 汇编程序的变量，对变量进行赋值以及定义寄存器名称，该类伪指令如下： 全局变量声明：GBLA、GBLL 和GBLS。 局部变量声明：LCLA、LCLL 和LCLS。 变量赋值： SETA、SETL 和SETS。 为一个通用寄存器列表定义名称：RLIST。 为一个协处理器的寄存器定义名称：CN。 为一个协处理定义名称： CP。 为一个VFP 寄存器定义名称：DN 和SN。 为一个FPA 浮点寄存器定义名称：FN。 GBLA、GBLL、GBLS 全局变量声明伪指令。 GBLA 伪指令用于声明一个全局的算术变量，并将其初始化为0。 GBLL 伪指令用于声明一个全局的逻辑变量，并将其初始化为{FALSE}。 GBLS 伪指令用于声明一个全局的字符串变量，并将其初始化为空字符串“”。 伪指令格式： GBLA variable GBLL variable GBLS variable 其中：variable 定义的全局变量名，在其作用范围内必须惟一。全局变量的作用范围为包含该变量的源程序。 伪指令应用举例如下： GBLL codedbg ;声明一个全局逻辑变量 codebg SETL {TRUE} ;设置变量为{TRUE} … LCLA、LCLL、LCLS 局部变量声明伪指令，用于宏定义的体中。 LCLA 伪指令用于声明一个局部的算术变量，并将其初始化为0。 LCLL 伪指令用于声明一个局部的逻辑变量，并将其初始化为{FALSE}。 LCLS 伪指令用于声明一个局部的字符串变量，并将其初始化为空字符串“”。 伪指令格式： LCLA variable LCLL variable LCLS variable 其中：variable 定义的局部变量名。在其作用范围内必须惟一。局部变量的作用范围为包含该局部变量只能在宏中进行声明及使用。 伪指令应用举例如下： MACRO ;声明一个宏 SENDDAT $dat ;宏的原型 LCLA bitno ;声明一个局部算术变量 … bitno SETA 8 ;设置变量值为8 … MEND SETA、SETL、SETS 变量赋值伪指令。用于对已定义的全局变量，局部变量赋值。 SETA 伪指令用于给一个全局/局部的算术变量赋值。 SETL 伪指令用于给一个全局/局部的逻辑变量赋值。 SETS 伪指令用于给一个全局/局部的字符串变量赋值。 伪指令格式： variable_a SETA expr_a variable_l SETL expr_l variable_s SETS expr_s 其中：variable_a 算术变量。用GBLA、LCLA 伪指令定义的变量。 expr_a 赋值的常数。 variable_l 逻辑变量。用GBLL、LCLL 伪指令定义的变量。 expr_l 逻辑值,即{TRUE}或{FALSE}。 variable_s 字符串变量。用GBLS、LCLS 伪指令定义的变量。 expr_s 赋值的字符串。 伪指令应用举例如下： GBLS ErrStr … ErrStr SETS “No,semaphone” … RLIST RLIST 为一个通用寄存器列表定义名称。伪指令格式如下： name RLIST {reglist} 其中：name 要定义的寄存器列表的名称。 reglist 通用寄存器列表。 伪指令应用举例如下： LoReg RLIST {R0-R7} ;定义寄存器列表LoReg … STMFD SP!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/739693b7989d23743d16f54e799f2889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6e0949b57df513a19e53388008711f/" rel="bookmark">
			Python-OpenCV 处理视频（三）（四）（五）： 标记运动轨迹 运动检测 运动方向判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00. 光流 光流是进行视频中运动对象轨迹标记的一种很常用的方法，在OpenCV中实现光流也很容易。
CalcOpticalFlowPyrLK 函数计算一个稀疏特征集的光流，使用金字塔中的迭代 Lucas-Kanade 方法。
简单的实现流程：
加载一段视频。
调用GoodFeaturesToTrack函数寻找兴趣点。
调用CalcOpticalFlowPyrLK函数计算出两帧图像中兴趣点的移动情况。
删除未移动的兴趣点。
在两次移动的点之间绘制一条线段。
代码示例：
import cv2.cv as cv capture = cv.CaptureFromFile('img/myvideo.avi') nbFrames = int(cv.GetCaptureProperty(capture, cv.CV_CAP_PROP_FRAME_COUNT)) fps = cv.GetCaptureProperty(capture, cv.CV_CAP_PROP_FPS) wait = int(1/fps * 1000/1) width = int(cv.GetCaptureProperty(capture, cv.CV_CAP_PROP_FRAME_WIDTH)) height = int(cv.GetCaptureProperty(capture, cv.CV_CAP_PROP_FRAME_HEIGHT)) prev_gray = cv.CreateImage((width,height), 8, 1) #Will hold the frame at t-1 gray = cv.CreateImage((width,height), 8, 1) # Will hold the current frame prevPyr = cv.CreateImage((height / 3, width + 8), 8, cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba6e0949b57df513a19e53388008711f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3e8baf70ae84986cf5df5cdac942921/" rel="bookmark">
			大量POI点展示的一种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：
不论是在Arcgis for js还是Openlayers中，当POI点比较多的时候，在前台页面的展示在效率上是一大问题。经过一段时间的研究，发现百度地图在这一问题上的处理思路比较好：将要展示的POI点在服务器端生成图片，页面只调用图片的话效率会比较高。本文讲述如何在java后台实现POI点在服务器端的实时生成以及在Openlayers2的展示。
实现后效果：
技术难点：
要实现POI点在服务器端的生成，难点在与如何通过前台请求的参数计算出坐标点的屏幕坐标。为此参了网上的一篇文章解决了此问题，文章内容如下：
地理坐标定义规则：X轴(代表经度)向右递增，Y轴(纬度)向上递增，就好比小学学过的平面坐标。向左、向下的规则。屏幕坐标定义规则：X轴向右递增，Y轴向下递增。 可以看出，地理坐标和屏幕坐标的区别仅仅只是在于Y轴递增方向是相反的(这就是不同)。 这里强调一点的就是为了保证精度，地理坐标的度*3600换算成秒，所有的取值用double来计算，最后的结果再转换成int。 1 已知道屏幕的高(y)和宽(h)，地理坐标区域的范围(maxLon，minLon，maxLat，minLat)，这里我们知道了这些已知的参数。 2 我们可以算出每像素所代表的经度和纬度(有人称这个为比例因子)。 公式：scaleX = ((maxLon-minLon)*3600)/h ----------X轴上每像素代表的经度秒数； 公式：scaleY = ((maxLat-minLat)*3600)/y ----------Y轴上每像素代表的纬度秒数； 这两个比例因子就是两个坐标系之间的关系。 3 很简单的一步了，那就是算出该地理坐标区域中的任何一点(lon,lat)在屏幕上的坐标了。 公式：screenX = lon*3600/scaleX；---------屏幕坐标X轴坐标 公式：screenY = lat*3600/scaleY； ---------屏幕坐标Y轴坐标 还有最后一步，那就是我们要把该地理区域占满占个屏幕该怎么办呢? 4 接着我们需要该地理区域占满占个屏幕该怎么办呢 公式：minX = minLon*3600/scaleX；区域左边置最左端 公式：minY = minLat*3600/scaleY； 区域上面置最上端 5 当地地理范围区域占满整个屏幕时，我们需要用到第三步计算出来的 screenX和screenY两个参数，该区域中的任何一点的公式如下： 公式：X = screenX - minX = (lon - minLon)*3600/scaleX； 公式：Y = screenMaxLat - screenLat = (maxLat - lat)*3600/scaleY； 6 总结： 经纬度转屏幕坐标的最终公式如下： 公式：X = (lon - minLon)*3600/scaleX； 公式：Y = (maxLat - lat)*3600/scaleY； 接着我们由上面的公式可以推出屏幕坐标转经纬度坐标公式如下： 公式：lon = X * scaleX/3600 + minLon； 公式：lat = maxLat - y* scaleY/3600； 编码实现： 后台POI图片的实时生成用了一个servlet实现，前台调用用WMS来调用，具体代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3e8baf70ae84986cf5df5cdac942921/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/080e51d0711f183197752aaff308d5b4/" rel="bookmark">
			opencv图像拼接，即把两个矩阵合并为一个(vconcat和hconcat)、Mat成员函数size（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mat类的成员函数 size（） 当我们用size（）获取一个矩阵的行数和列数时，要注意这个函数返回的结果行和列是相反的。 如
Mat ab(30,15,Cv_32fC1); ab.rows；//返回的结果将是（15,30）； opencv如何将两个矩阵按行或者按列合并 在Matlab中将两个矩阵合并非常方便，按行合并，如A=[B C]。按列合并如A=[B ;C] 以前用自己写的函数，今天逛外国人论坛发现了vconcat和hconcat函数，用于矩阵的合并与图像的拼接。
vconcat（B,C，A）; // 等同于A=[B ;C] hconcat（B,C，A）; // 等同于A=[B C] 以下方法是2016 05 16日前的方法，自己写的函数，现在找到了opencv的函数vconcat和hconcat,可以放弃下面的方法了。 在opencv中貌似并不存在这样的函数，因此，写了两个函数，分别用于合并矩阵。
Mat comMatR(Mat Matrix1,Mat Matrix2,Mat &amp;);//函数声明 Mat comMatC(Mat Matrix1,Mat Matrix2,Mat &amp;);//函数声明 //comMatR(conbine matrix as row):combine Matrix1 and Matrix2 to MatrixCom as row ,just as the matlab expression :MatrixCom=[Matrix1 Matrix1] Mat comMatR(Mat Matrix1,Mat Matrix2,Mat &amp;MatrixCom) { CV_Assert(Matrix1.rows==Matrix2.rows);//行数不相等，出现错误中断 MatrixCom.create(Matrix1.rows,Matrix1.cols+Matrix2.cols,Matrix1.type()); Mat temp=MatrixCom.colRange(0,Matrix1.cols); Matrix1.copyTo(temp); Mat temp1=MatrixCom.colRange(Matrix1.cols,Matrix1.cols+Matrix2.cols); Matrix2.copyTo(temp1); return MatrixCom; } //comMatR(conbine matrix as col):combine Matrix1 and Matrix2 to MatrixCom as rows ,just as the matlab expression :MatrixCom=[Matrix1;Matrix1] Mat comMatC(Mat Matrix1,Mat Matrix2,Mat &amp;MatrixCom) { CV_Assert(Matrix1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/080e51d0711f183197752aaff308d5b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c5ff575453aaeff73fbd17fdfe642ae/" rel="bookmark">
			Android TextView长按复制文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 其实现在新的Android开发只需要增加一行代码就可以实现这个功能，在布局文件的TextView控件属性中增加这么一句就行：android:textIsSelectable="true"
但查询资料说只有 android sdk 11起才支持，v11以下则不行了。我测试了一下在Android4没问题，2.3的系统不行，大家可以根据需求针对性测试下。 Android学习交流群：523487222 （欢迎加入，一起学习进步）
点击链接加入群【Android学习群】 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00761f250f5c94fb024dd61ec3b48421/" rel="bookmark">
			《电路基础》电阻|电容|电感公式备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ψ(psai 普西 角速)φ(fai 佛爱 磁通)ω(欧米伽 角速)ξ(ksi 克西) 电阻：
U=ri P=ui W=pt W= ∫pdt
电容：
q=Cu i=dq/dt=C(du/dt) 电感：
u=dψ/dt ψ = Li u = dψ/dt = L(di/dt) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d079115683618e56342cfbd7bdd0aa5b/" rel="bookmark">
			线段树模版—A Simple Problem with Integers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		D - A Simple Problem with Integers Time Limit:5000MS Memory Limit:131072KB 64bit IO Format:%I64d &amp; %I64u Description
给出了一个序列，你需要处理如下两种询问。
"C a b c"表示给[a, b]区间中的值全部增加c (-10000 ≤ c ≤ 10000)。
"Q a b" 询问[a, b]区间中所有值的和。
Input
第一行包含两个整数N, Q。1 ≤ N,Q ≤ 100000.
第二行包含n个整数，表示初始的序列A (-1000000000 ≤ Ai ≤ 1000000000)。
接下来Q行询问，格式如题目描述。
Output
对于每一个Q开头的询问，你需要输出相应的答案，每个答案一行。
Sample Input
10 5 1 2 3 4 5 6 7 8 9 10 Q 4 4 Q 1 10 Q 2 4 C 3 6 3 Q 2 4 Sample Output
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d079115683618e56342cfbd7bdd0aa5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82cbcf88df109d1afd70c06ca92384d2/" rel="bookmark">
			[置顶]苹果刷机相关开源代码(如iRecovery等)收集汇总（不断更新中...）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面截图是在下面开源代码下使用VS2015修改部分代码后适配而成，可以在Windows平台上运行， 下载连接： http://pan.baidu.com/s/1i4zKGx3。 打开调试开关：
================================================================================================
About=====libirecovery is a cross-platform library which implements communication toiBoot/iBSS found on Apple's iOS devices via USB. A command-line utility is alsoprovided.The software is completely open-source, the source code is released under theterms of the LGPL 2.1. The full license text can be found in the LICENSE file.This is a fork of an older version from http://www.openjailbreak.org/ and isment to be used with idevicerestore from the libimobiledevice project.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82cbcf88df109d1afd70c06ca92384d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db64957d1aba33b9cf100a1dd1f2dae/" rel="bookmark">
			VS2013配置WTL91_5321_Final
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上关于WTL的文章，尤其是中文的文章不多，根据收集的资料整理出了VS2013安装WTL的方法。1、下载。文件很小的，地址：http://sourceforge.net/projects/wtl/files/latest/download2、解压安装包。找到“VS安装目录\VC\VCWizards\AppWiz”这个目录，如我电脑上就是“Microsoft Visual Studio 12.0\VC\VCWizards\AppWiz”，在这个目录下新建“WTL”目录，将压缩包里的WTL91_5321_Final\AppWiz 中的 Files文件夹 和 setup.js 解压到新建的“WTL”目录。3、执行安装。在命令行下执行：wscript "C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\VCWizards\AppWiz\WTL\setup.js" 执行完会提示应用程序向导安装成功。4、解压include目录。在”Microsoft Visual Studio 12.0\VC“目录下建立“WTL”目录，将压缩包里的 WTL91_5321_Final下的 include文件夹 解压到新建的“WTL”目录。5、将WTL的include目录添加到VS2013中去。找到“VS安装目录\VC\VCWizards\default.vcxproj”这个文件，如我电脑上就是“Microsoft Visual Studio 12.0\VC\VCWizards\default.vcxproj”，打开该文件，定位到文件末尾，在&lt;/Project&gt;之前添加如下内容：&lt;PropertyGroup&gt; &lt;IncludePath&gt;$(VCInstallDir)\WTL\include;$(IncludePath)&lt;/IncludePath&gt; &lt;/PropertyGroup&gt; Done.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd905a9f194849f11a6c7e04af266b6a/" rel="bookmark">
			寻找二叉树两个节点的最低公共祖先
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从root开始遍历，如果n1和n2中的任一个和root匹配，那么root就是LCA。 如果都不匹配，则分别递归左、右子树，如果有一个 key（n1或n2）出现在左子树，并且另一个key(n1或n2)出现在右子树，则root就是LCA. 如果两个key都出现在左子树，则说明LCA在左子树中，否则在右子树。 /* 只用一次遍历解决LCA */#include &lt;iostream&gt;using namespace std;struct Node{struct Node *left, *right;int key;};Node* newNode(int key){Node *temp = new Node;temp-&gt;key = key;temp-&gt;left = temp-&gt;right = NULL;return temp;}// 返回n1和n2的 LCA的指针// 假设n1和n2都出现在树中struct Node *findLCA(struct Node* root, int n1, int n2){if (root == NULL) return NULL;// 只要n1 或 n2 的任一个匹配即可// (注意：如果 一个节点是另一个祖先，则返回的是祖先节点。因为递归是要返回到祖先的 )if (root-&gt;key == n1 || root-&gt;key == n2)return root;// 分别在左右子树查找Node *left_lca = findLCA(root-&gt;left, n1, n2);Node *right_lca = findLCA(root-&gt;right, n1, n2);// 如果都返回非空指针 Non-NULL, 则说明两个节点分别出现了在两个子树中，则当前节点肯定为LCAif (left_lca &amp;&amp; right_lca) return root;// 如果一个为空，在说明LCA在另一个子树return (left_lca !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd905a9f194849f11a6c7e04af266b6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45c4c61a2d786d7e8585ecf8b0c723a/" rel="bookmark">
			MFCButton Memory leak(内存泄露问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://m.blog.csdn.net/blog/haoekin/8851219 1.无法显示右边箭头的问题
无论怎么折腾都没显示不出来，微软给的示例又能显示，度娘和谷歌也都不知道，经过不断地探索总算找到解决办法了：在rc2文件中加上下面的内容即可
#ifndef _AFXDLL
#include "afxribbon.rc" // Ribbon and control bars
#endif
当然，要想按钮有XP的风格，还需要在App类的InitInstance中加上
CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));
然而这样在关闭程序时会发现有内存泄漏，输出窗口中出现如下内容：
Init CriticalSection spin count CDLPShareMemConfig::Close()CDLPShareMemConfig::Close()TSWebDownLoadProtect.dll is Load failedTSWebMon.dat is Load failedDetected memory leaks!
Dumping objects -&gt;
f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\afxvisualmanagerwindows.cpp(35) : {487} client block at 0x001C9318, subtype c0, 376 bytes long.
a CMFCVisualManagerWindows object at $001C9318, 376 bytes long
Object dump complete.
显然，这是由于RUNTIME_CLASS(CMFCVisualManagerWindows)动态创建了一个CMFCVisualManagerWindows的实例没有释放，不知道CMFCVisualManager在搞什么，在吃SHI吗，还需要我们手动释放，既然它不作为，那我们只有自己干了，在ExitInstance中加上CMFCVisualManagerWindows::DestroyInstance();就好了
2. 多字节编码下堆破坏
如果你建的项目是使用的Unicode编码，那么在Debug模式下没有问题，Release模式下同样会出现堆破坏的错误，程序根本没法启动！如果是多字节编码，那么对不起，任何模式都不行，不知道MFC怎么搞的！
没办法，总得知道原因出在哪里吧，找到MFC的源码（源码怎么找相信大家都知道，就在VS安装目录下\VC\atlmfc\src\mfc下面，查找包含CMFCMenuButton字符串的文件，怎么搜索不用我说了吧，在Win7下改一下搜索选项就可以了），在OnDraw里面打断点，发现问题出在CMFCButton::OnDraw那一行，继续调CMFCButton::OnDraw，发现问题出在GetWindowText，用一个大一点的缓冲区来存获得的文本吧，发现文本后面被填入了"\0 MFCMenuButton"，乖乖，多出这么长一截，堆能不被破坏吗？
解决办法有两个：
（1）重载CMFCMenuButton，自己实现OnDraw（可以将CMFCButton和CMFCMenuButton的OnDraw合并起来），在GetWindowText那里自己分配一个大一点的缓冲区就行了；这种办法太笨拙了，不推荐。
（2）不写任何代码，直接将Button控件拖入到对话框中，添加变量时变量类型改成CMFCMenuButton就可以了，只不过需要自己设置按钮的一些属性。
好了，就这么多，如果谁有更好的解决办法请指教！
http://blog.csdn.net/polytechnic/article/details/5698397
本来应该不会有这篇四的，但因为发现了 bug，所以要 patch 一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45c4c61a2d786d7e8585ecf8b0c723a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51af225231698c47125811eb219f3bb3/" rel="bookmark">
			pcap文件格式及文件解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一部分：PCAP包文件格式 一 基本格式：
文件头 数据包头数据报数据包头数据报......
二、文件头：
文件头结构体
sturct pcap_file_header
{
DWORD magic;
DWORD version_major;
DWORD version_minor;
DWORD thiszone;
DWORD sigfigs;
DWORD snaplen;
DWORD linktype;
}
说明：
1、标识位：32位的，这个标识位的值是16进制的 0xa1b2c3d4。
a 32-bit magic number ,The magic number has the value hex a1b2c3d4.
2、主版本号：16位， 默认值为0x2。
a 16-bit major version number,The major version number should have the value 2.
3、副版本号：16位，默认值为0x04。
a 16-bit minor version number,The minor version number should have the value 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51af225231698c47125811eb219f3bb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52157ba0e67774905a12cf9a2079b250/" rel="bookmark">
			苹果系列机型专业刷机，解锁，解ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如有软件开发需求，请留言或在猪八戒网主页留言 http://home.zhubajie.com/8506525/，常年接收c、c++(vs2010、RAD studio xe5\RAD studio 2010\c++ builder 2010)\c#\python\linux shell等软件开发类项目， 热烈欢迎咨询洽谈。
下面是前不久做的一个项目：
运行效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aff28ea7cb2800a952c0c31ed9fba503/" rel="bookmark">
			c# winform 关于DataGridView的一些操作（很全，绝对够用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://heisetoufa.iteye.com/blog/405317 设置字段名 设置字段值 设定单元格表示 Error图标 设定当前单元格 取得当前单元格内容 取得当前单元格的列 Index 取得当前单元格的行 Index 向下一行 向上一行 取消 DataGridView1 为只读 设置 DataGridView1 为只读 设置 DataGridView1 的第2列整列单元格为只读并变色 设置 DataGridView1 的第3行整行单元格为只读并变色 设置 DataGridView1 的[0，0]单元格为只读并变色 设置 DataGridView1 的第2列整列单元格为只读并变色 设置 DataGridView1 的第3行整行单元格为只读并变色 设置 DataGridView1 的[0，0]单元格为只读并变色 设置用户不能手动给 DataGridView1 添加新行 设置用户可以手动给 DataGridView1 添加新行 禁止DataGridView1的行删除操作。 允许DataGridView1的行删除操作。 DataGridView1的第一列隐藏 DataGridView1的第一行隐藏 DataGridView1的第一列显示 DataGridView1的第一行显示 列头隐藏 行头隐藏 列头显示 行头显示 删除名为"Column1"的列 删除第四列 删除第三行 禁止用户改变DataGridView1的所有列的列宽 禁止用户改变DataGridView1的所有行的行高 允许用户改变DataGridView1的所有列的列宽 允许用户改变DataGridView1的所有行的行高 禁止用户改变DataGridView1的第一列的列宽 禁止用户改变DataGridView1的第一列的行宽 第一列的最小列宽设定为 100 第一行的最小行高设定为 50 禁止用户改变列头的高度 禁止用户改变行头的宽度 设定包括Header和所有单元格的列宽自动调整 设定包括Header和所有单元格的行高自动调整 第一列自动调整 设定列头的宽度可以自动调整 设定行头的宽度可以自动调整 让 DataGridView1 的所有列宽自动调整一下。 让 DataGridView1 的第三列的列宽自动调整一下。 让 DataGridView1 的所有行高自动调整一下。 让 DataGridView1 的第一行的行高自动调整一下。 列头高度自动调整 行头宽度自动调整 DataGridView1的左侧2列固定 DataGridView1 的上3行固定 改变DataGridView1的第一列列头内容 改变DataGridView1的第一行行头内容 改变DataGridView1的左上头部单元内容 改变DataGridView1的第二列列头内容 当前单元格是否选择的判断 获取剪切板的内容，并按行分割 是否是列头 按 Tab 分割数据 行头设定 单元格内容设定 DataGridView的行索引+1 设定单元格的ToolTip内容 设定列头的单元格的ToolTip内容 设定行头的单元格的ToolTip内容 DataGridView 的 ContextMenuStrip 设定 列的 ContextMenuStrip 设定 列头的 ContextMenuStrip 设定 行的 ContextMenuStrip 设定 单元格的 ContextMenuStrip 设定 列头的ContextMenuStrip设定 行头的ContextMenuStrip设定 如果单元格值是整数时 当"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aff28ea7cb2800a952c0c31ed9fba503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28563ed796215bbcf05f954dab3a9881/" rel="bookmark">
			Effective-OC 10.在既有类中使用关联对象存储自定义数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EOC中介绍与案例
有时候需要在对象中存放相关的信息 这时候我们通常会从对象所属的类中继承一个子类，然后改用这个子类对象。然而并非所有的情况都能这么做。有的时候 类的实例可能是由某种机制创建的，而开发者无法令这种机制创建出自己写的子类的实例，OC中有一强大的特性可以解决这个问题 就是“关联对象”
可以给某对象关联许多其他的对象 这些对象通过“键”来区分。存储对象值得实惠 可以指明“存储策略”，用以维护相对应的“内存管理语义”。存储策略由名为objc_AssociationPolicy的枚举所定义。以下是该枚举的取值 同时列出了与之等效的@property属性：假如关联对象成为了属性 那么它就会具备对应语义。
关联类型 等效的@property属性
OBJC_ASSOCIATION_ASSIGN assign
OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic,retain
OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic,copy
OBJC_ASSOCIATION_RETAIN retain
OBJC_ASSOCIATION_COPY copy
下列方法可以管理关联对象。
void objc_setAssociatedObject(id object, void* key, id value, objc_AssociationPolicy policy) 此方法以给定的键和策略为某对象设置关联对象值。
id objc_getAssociatedObject(id object, void* key) 此方法根据给定的键从某对象中获取相应的关联对象值。
void objc_removeAssociatedObjects(id object) 此方法移除指定对象的全部关联对象。
我们可以把某对象想想成NSDictionary 把关联到该对象的值 理解为字典中的条目，于是存取关联对象的值就相当于在NSDictionary对象上调用[object setObject:object valueforkey:key]和[object objectForKey:key]方法。然而两者之间有个重要的区别：设置关联对象的时候使用的键(key)是不透明的指针，如果在两个键上调用isEqual:方法的返回值YES 那么NSDictonary认为二者相等 然而对于关联对象 想让两个键匹配到同一个值 则二者必须是完全相同的指针才可以。因此 在设置关联对象值时，通常使用静态全局变量做键。
关联对象的用法举例：
开发时用到UIAlertView类，该类提供了一种标准视图。可以向用户展示警告信息。当用户按下按钮关闭这个视图时，需用代理方法来处理这个动作 但是要想设置好这个代理机制 需要把创建警告视图和处理按钮动作的代码分开。
如：
-(void)showAlertView { UIAlertView * alert = [[UIAlertView alloc]initWithTitle:@"问题" message:@"你要做什么" delegate:self cancelButtonTitle:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28563ed796215bbcf05f954dab3a9881/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0634ea2a81c105abf4fd258d280c367/" rel="bookmark">
			java执行流程图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02fba7d0b24194e727ca260475c50ae0/" rel="bookmark">
			caffe python layer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文链接：http://blog.csdn.net/thesby/article/details/51264439 caffe的大多数层是由c++写成的，借助于c++的高效性，网络可以快速训练。但是我们有时候需要自己写点输入层以应对各种不同的数据输入，比如你因为是需要在图像中取块而不想写成LMDB，这时候可以考虑使用python直接写一个层。而且输入层不需要GPU加速，所需写起来也比较容易。
python层怎么用 先看一个网上的例子吧（来自http://chrischoy.github.io/research/caffe-python-layer/）
layer { type: 'Python' name: 'loss' top: 'loss' bottom: 'ipx' bottom: 'ipy' python_param { # the module name -- usually the filename -- that needs to be in $PYTHONPATH module: 'pyloss' # the layer name -- the class name in the module layer: 'EuclideanLossLayer' } # set loss weight so Caffe knows this is a loss layer loss_weight: 1 } 这里的type就只有Python一种，然后top，bottom和常见的层是一样的，module就是你的python module名字，一般就是文件名，然后layer就是定义的类的名字。
python层怎么写 这里就以 Fully Convolutional Networks for Semantic Segmentation 论文中公布的代码作为示例，解释python层该怎么写。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02fba7d0b24194e727ca260475c50ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030e971131e7be0b0efd18ec21e81125/" rel="bookmark">
			oracle update select (更新查询的sql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1).update tableName set (a,b,c)=(select a,b,c from ida where ida.id=tableName.id);
(2).update tableName t1 set a=(select t2.a from ida t2 where t1.id=t2.id),b=(select t2.b from ida t2 where t1.id=t2.id),c=(select t2.c from ida t2 where t1.id=t2.id)
(3) 每条数据执行为：UPDATEtableName SET (A,B,C)=(select A,B,C from tableName where id=''xxxxxx) WHERE id='xxxxxxx'
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baff6a89a0ec57332f7214f73002f64d/" rel="bookmark">
			mysql删除数据表内容后id 自动递增字段不是从1开始的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何让主键ID重新从1开始？
我们在测试数据的时候，经常ID会越来越大，正式上线后ID就会变的很大，如果我们把ID字段删除重新建立是可以的，不过也比较麻烦，那么我们怎么让主键ID从1开始呢。
大家都知道删除文档以后我们再添加文档还是会以删除前的id向后顺延
如何让它的id从1开始呢？有一个方法很简单，删除数据表的内容的时候不进数据表里面删除，而是直接鼠标选中该表然后右键选择清空表，以后添加的数据主键ID又会从1开始。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1adfe25c62f9fb9379d04227fa0ed223/" rel="bookmark">
			2011年北京大学计算机研究生机试真题（题解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		九度OJ题目传送门：2011年北京大学计算机研究生机试真题
鸡兔同笼 题目描述 一个笼子里面关了鸡和兔子（鸡有2只脚，兔子有4只脚，没有例外）。已经知道了笼子里面脚的总数a，问笼子里面至少有多少只动物，至多有多少只动物。
输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，每行一个正整数a (a &lt; 32768)
输出 输出包含n行，每行对应一个输入,包含两个正整数，第一个是最少的动物数，第二个是最多的动物数，两个正整数用一个空格分开 如果没有满足要求的答案，则输出两个0。
样例输入 2 3 20
样例输出 0 0 5 10
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; int main() { int n, a; scanf("%d", &amp;n); while(n--){ scanf("%d", &amp;a); int t1 = a/2; int t2 = a/4; int maxn = 0, minn = 0; for(int i = 0; i &lt;= t1; i++){ for(int j = 0; j &lt;= t2; j++){ if(i*2+j*4==a){ if(minn==0) minn = i+j; if(i+j&gt;maxn) maxn = i+j; if(i+j&lt;minn) minn = i+j; } } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1adfe25c62f9fb9379d04227fa0ed223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a416915084aab2d856ef87f591368f5c/" rel="bookmark">
			清橙网A1110. 街道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试题来源 NOIP1997 普及组 问题描述 设有一个N＊M（l≤ N≤50， l≤ M≤ 50）的街道。n和m表示横竖街道数。
规定行人从A(1,1)出发，在街道上只能向东或北方向行走。
N＝3，M=3的街道图，从A出发到达B共有6条可供行走的路。
若在N＊M的街道中，设置一个矩形障碍区域（包括围住该区域的街道和点）不让行人通行。
此矩形障碍区域用2对顶点坐标给出,前图中的2对顶点坐标为:(2，2),(8，4),此时从 A出发到达B的路径仅有两条。
程序要求：
任务一：给出N，M后，求出所有从A出发到达B的路径的条数。
任务二：给出N，M，同时再给出此街道中的矩形障碍区域的2对顶点坐标(X1,y1), （X2，Y2），然后求出此种情况下所有从A出发到达B的路径的条数。
如果答案太大，输出最后20位。
输入格式 第一行两个数n和m。
第二行为X1,Y1,X2,Y2.如果是任务一，则第二行为4个0.
输出格式 输出走路方案数。
样例输入 3 3 0 0 0 0 样例输出 6 样例输入 50 50 2 2 49 49 样例输出 2 数据规模和约定 1&lt;=N,M&lt;=50 #include&lt;cstdio&gt; #include&lt;algorithm&gt; #define maxn 60 #define l 10000000000 using namespace std; struct number{ long long d1,d2; //存储方案的后20位 }f[maxn][maxn]; int n,m; int flag[maxn][maxn]; //障碍标记 void start(){ long long s; f[1][1].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a416915084aab2d856ef87f591368f5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b097844f0e73e140f76cb8aba02e616a/" rel="bookmark">
			Redis源码分析——SDS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis中基于C字符串构建了一种新的简单动态字符串SDS，作为对象的一种底层实现方式。它保存了C风格字符串以’\0’结尾的惯例，可以使用C字符串函数。由于SDS中保存了字符串的长度，所以可以以O(1)的时间复杂度获取长度而不是C字符串的O(n)。C字符串容易溢出的缺点也改进掉了，因为SDS操作时如果空间不够，会重新分配空间。对于空间的管理，SDS中使用预分配和懒惰释放的方式，减少对内存空间的反复分配和释放，提高了效率。SDS也是二进制安全的，他的长度是由长度字段保证的，字符数组中可以存放任意字符。
当前SDS源码已经读完，也做了注释，代码有1k多，逻辑都比较简单，现在把头文件注释放上。
/* SDSLib, A C dynamic strings library * * Copyright (c) 2006-2010, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt; * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * * Redistributions of source code must retain the above copyright notice, * this list of conditions and the following disclaimer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b097844f0e73e140f76cb8aba02e616a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09887b5754df4b2a82348ce6e801932b/" rel="bookmark">
			C语言中变长参数的函数的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们定义一个函数时，有可能无法确定参数的个数，这是就需要用到变长参数函数，就想标准C函数printf一样。一般这样声明：
void func(char* form, ...);
前面至少有一个确定的参数。函数体内如何获取这些参数呢？这就需要用到几个宏以及了解他们的原理。
函数参数是以数据结构——栈的形式存取,从右至左入栈。因此，从理论上说，我们只要探测到任意一个变量的地址，并且知道其他变量的类型，通过指针移位运算，则总可以找到其他的变量。
&lt;stdarg.h&gt; 中定义了几个重要的宏：
typedef char* va_list;
void va_start ( va_list ap, prev_param );/* ANSI version */
type va_arg ( va_list ap, type ); void va_end ( va_list ap ); va_list 是一个字符指针，可以理解为指向当前参数的一个指针，取参必须通过这个指针进行。
&lt;Step 1&gt; 在调用参数表之前，定义一个va_list 类型的变量，(假设va_list 类型变量被定义为ap)；
&lt;Step 2&gt; 然后应该对ap 进行初始化，让它指向可变参数表里面的第一个参数，这是通过 va_start 来实现的，第一个参数是 ap 本身，第二个参数是在变参表前面紧挨着的一个变量,即“...”之前的那个参数；
&lt;Step 3&gt; 然后是获取参数，调用va_arg，它的第一个参数是ap，第二个参数是要获取的参数的指定类型，然后返回这个指定类型的值，并且把 ap 的位置指向变参表的下一个变量位置；
&lt;Step 4&gt; 获取所有的参数之后，我们有必要将这个 ap 指针关掉，以免发生危险，方法是调用 va_end，他是输入的参数 ap 置为 NULL。通常va_start和va_end是成对出现。
例如：
int demo(char msg, ...) { /*定义保存函数参数的结构*/ va_list argp; int argno = 0; char para; /*argp指向传入的第一个可选参数，msg是最后一个确定的参数*/ va_start(argp, msg); while (1) { para = va_arg(argp, char); if (strcmp(para, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09887b5754df4b2a82348ce6e801932b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5b76e55d1d9a521287d4363d20a1fc0/" rel="bookmark">
			一个C语言函数声明和定义的编译问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看Redis代码，看到SDS字符串时，有个地方很诡异，代码如下：
static inline size_t sdslen(const sds s) { struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); return sh-&gt;len; } static inline size_t sdsavail(const sds s) { struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr))); return sh-&gt;free; } sds sdsnewlen(const void *init, size_t initlen); sds sdsnew(const char *init); sds sdsempty(void); &lt;span style="color:#ff0000;"&gt;size_t sdslen(const sds s);&lt;/span&gt; sds sdsdup(const sds s); void sdsfree(sds s); size_t sdsavail(const sds s); sds sdsgrowzero(sds s, size_t len); sds sdscatlen(sds s, const void *t, size_t len); sds sdscat(sds s, const char *t); sds sdscatsds(sds s, const sds t); sds sdscpylen(sds s, const char *t, size_t len); sds sdscpy(sds s, const char *t); 先是定义了一个内联函数，然后又声明了一个同名的函数，这样不会有问题吗？ 根据验证，说明后面的声明是无效的，sds.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5b76e55d1d9a521287d4363d20a1fc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ea7b78e26b78dfdd0e96ff95cd5b17e/" rel="bookmark">
			解决 swap file “*.swp”already exists！问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Linux 下的 vim 编辑过程中，由于某种原因异常退出正在编辑的文件，再次编辑该文件时，会出现如下提示：
使用vim编辑文件实际是先 copy 一份临时文件并映射到内存给你编辑， 编辑的是临时文件， 当执行：w 后才保存临时文件到原文件，执行：q 后才删除临时文件。
每次启动检索是否有临时文件， 有则询问如何处理，就会出现如上情景。
解决办法：
将隐藏的 *.swp 文件删除即可，原先的文件便可再次编辑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54aa3507770b2191628b7ef63c0dcaa9/" rel="bookmark">
			jquery.qrcode.js生成二维码插件&amp;转成图片格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.qrcode其实是通过使用jQuery实现图形渲染，画图，支持canvas（HTML5）和table两种方式，
github源码地址：
https://github.com/jeromeetienne/jquery-qrcode
参数说明：
render : "canvas",//设置渲染方式 width : 256, //设置宽度 height : 256, //设置高度 typeNumber : -1, //计算模式 correctLevel : QRErrorCorrectLevel.H,//纠错等级 background : "#ffffff",//背景颜色 foreground : "#000000" //前景颜色 2.使用实例：
插件引用
&lt;script src="../Js/jquery-1.11.3.min.js"&gt;&lt;/script&gt; &lt;script src="../Js/jquery-qrcode-master/jquery.qrcode.min.js"&gt;&lt;/script&gt;简单实例1： &lt;div id="code"&gt;&lt;/div&gt; &lt;script&gt; //任意字符串 生成二维码 //默认使用Canvas画图 $('#code').qrcode('http://blog.csdn.net/u011127019'); &lt;/script&gt; 简单实例2：
&lt;div id="code"&gt;&lt;/div&gt; &lt;script&gt; //table 模式兼容 IE低版本 $('#code').qrcode({ render: 'table', width: 100, height: 100, text: 'http://blog.csdn.net/u011127019' }); &lt;/script&gt;简单实例3（中文支持）： 我们试验的时候发现不能识别中文内容的二维码，通过查找多方资料了解到，jquery-qrcode是采用charCodeAt()方式进行编码转换的。而这个方法默认会获取它的Unicode编码，如果有中文内容，在生成二维码前就要把字符串转换成UTF-8，然后再生成二维码。
&lt;div id="code"&gt;&lt;/div&gt; &lt;script&gt; //如果内容中有中文，在生成二维码钱就要把字符串转换成utf-8 function toUtf8(str) { var out, i, len, c; out = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54aa3507770b2191628b7ef63c0dcaa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/340ada0938368ee9b0addfce054eafea/" rel="bookmark">
			单步调试 step into/step out/step over 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		step into：单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）；
step over：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。有一点,经过我们简单的调试,在不存在子函数的情况下是和step into效果一样的（简而言之，越过子函数，但子函数会执行）。
step out：当单步执行到子函数内时，用step out就可以执行完子函数余下部分，并返回到上一层函数。
下面以 pycharm IDE 为示例作简要说明：
点击 pycharm 右上部爬虫按钮进入调试状态，程序在第14行断点处停止，按 F5（step into）进入 add() 函数，按 F7（step out） 执行完add()函数余下部分，返回入口函数 debug_test() 继续执行，按 F6(step over) 直接将 divide() 函数执行完。最后单步执行至入口函数结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/648391e7eb2ecd971119d394beb1d3cd/" rel="bookmark">
			CSS中font-style的属性有Italic oblique,它们俩的区别是什么呢?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS中font-style的属性有Italic oblique,它们俩的区别是什么呢? chenzwp 10级 分类： 互联网 被浏览960次 2013.03.08 它们俩的效果都是倾斜,在浏览器上我没看出它们的不同.但两个属性还是不一样的吧.都什么时候用呢?有什么不同? cherryluck519 采纳率：53% 11级 2013.03.08 要搞清楚这个问题，首先要明白字体是怎么回事。一种字体有粗体、斜体、下划线、删除线等诸多属性。 但是并不是所有字体都做了这些，一些不常用的字体，或许就只有个正常体，如果你用Italic，就没有效果了~这时候你就要用Oblique. 可以理解成Italic是使用文字的斜体，Oblique是让没有斜体属性的文字倾斜！ 明白了把？ 另外附上CSS2.0上边的解释你参考下： italic和oblique都是向右倾斜的文字, 但区别在于Italic是指斜体字，而Oblique是倾斜的文字，对于没有斜体的字体应该使用Oblique属性值来实现倾斜的文字效果. {
font-style标签说明 HTML的i标签定义了斜体显示的字体,此标签已经被w3c抛弃.XHTML的em标签,在多数浏览器中也是显示了斜体,这是没有必要的,因为em标签本身是强调的意思.真正符合标准网页设计的显示斜体文字的方法是使用font-style:italic; CSS属性.由于有一些字体本身没有斜体样式,所以有时斜体显示将被忽略. } 转载于:https://www.cnblogs.com/feng12345/p/5418166.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e6d67f0c0030b3ed8a1eae68ff8514/" rel="bookmark">
			java实现解压（zip和rar文件）实例-解决中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实现说明：
在下面引入的包中可以看出：
1）压缩、解压zip是用到的apache 的zip包，需要在引入jar包（jar-ant.rar）；
2）压缩、解压rar需要用到的是junrar，这里需要引入第三方jar包，我用到的是junrar-0.7.jar
下面的两个方法是实现解压文件的实例，压缩文件的实现其实也很简单，大家可以查查实现方式，在此我还是不关心压缩文件（相对来说用的少）
import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.InputStream; import java.util.Enumeration; import org.apache.tools.zip.ZipEntry; import org.apache.tools.zip.ZipFile; import com.github.junrar.Archive; import com.github.junrar.rarfile.FileHeader; /** * * @author liuBf * 类说明:解压文件公用类 * */ public class UnZipOrRarUtils { /*** 这里用到了synchronized ，也就是防止出现并发问题 ***/ public static synchronized void untar(String tarFileName, String extPlace) throws Exception { unRarFile(tarFileName, extPlace); } public static synchronized void unzip(String zipFileName, String extPlace) throws Exception { unZipFiles(zipFileName, extPlace); } /** * 解压zip格式的压缩文件到指定位置 * * @param zipFileName * 压缩文件 * @param extPlace * 解压目录 * @throws Exception */ @SuppressWarnings("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2e6d67f0c0030b3ed8a1eae68ff8514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0335d6a15acda25f9572271415ec9262/" rel="bookmark">
			win7 启动修复（windows错误修复） 关闭的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个磁盘重启还原的功能（只还原系统盘），但是在win7发现一个问题，就是系统重启还原后，系统启动的时候会提示： win7 启动修复（windows错误修复）。而且默认选项是：启动修复（推荐），另一个选项才是： 正常启动WINDOWS。很显然我们不需要修复，只需要正常启动windows。出现这个问题的原因应该是系统启动过程中认为上次系统是突然断电关闭系统的。具体详询原因没有进一步探索，我主要是禁止出现这样的提示，通过了解，知道了win7 的bcdedit命令可以完成这个功能
关闭当前系统提示：
bcdedit /set {current} bootstatuspolicy ignoreallfailures
开启当前系统提示：
bcdedit /set {current} bootstatuspolicy displayallfailures
更多的相关命令自己搜索一下就能找到。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d9f4a97ec98646104a8dfb618bc330/" rel="bookmark">
			进程间8种通信方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程通信： 每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。
1 匿名管道通信 匿名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
// 需要的头文件 #include &lt;unistd.h&gt; // 通过pipe()函数来创建匿名管道 // 返回值：成功返回0，失败返回-1 // fd参数返回两个文件描述符 // fd[0]指向管道的读端，fd[1]指向管道的写端 // fd[1]的输出是fd[0]的输入。 int pipe (int fd[2]); 通过匿名管道实现进程间通信的步骤如下：
父进程创建管道，得到两个⽂件描述符指向管道的两端父进程fork出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。 详细可参考文章：进程间的通信方式——pipe（管道）
2 高级管道通信 高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
3 有名管道通信 有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
4 消息队列通信 消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
5 信号量通信 信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
6 信号 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
7 共享内存通信 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42d9f4a97ec98646104a8dfb618bc330/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2c2a37e04ca78e5f039d5e18b519963/" rel="bookmark">
			Android 版本与 Bluetooth 版本之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自ifeegoo的个人博客，原文地址《Android：Bluetooth 的打开和关闭》 http://www.ifeegoo.com/android-turn-on-and-turn-off-bluetooth.html
Android 版本与 Bluetooth 版本之间的关系
摘要：Android 版本与 Bluetooth 版本之间是否存在必然关系？答案是否定的。不同版本的 Android 系统是否有针对不同版本的 Bluetooth 模块提供官方的 API 供开发者调用，这个才是关键。
最近开始 Bluetooth 开发，一直纠结一个问题：
Android 版本与 Bluetooth 版本之间是否存在必然关系？例如：Android 4.3 版本的手机上的 Bluetooth 模块一定是支持 BLE (Bluetooth Low Energy) 的吗？ 答案是否定的，比如说有一个设备厂商，在自己的 Android 4.3 系统的设备上移除了 Bluetooth 模块，或者在自己的 Android 4.3 系统设备上的 Bluetooth 模块仍然采用的是 Bluetooth 2.1 ，这种情况在理论上来说是有可能的。当然，正常情况下，设备厂商如果要在自己的 Android 4.3 系统设备上提供 Bluetooth 模块的话，一定会考虑到自己的 Bluetooth 版本和当前设备的 Android 系统版本之间的关系，这是针对设备的普通使用者和开发者考虑的问题。当然，如果说设备厂商生产了一款 Android 1.6 系统的设备，在上面采用了 BLE 模块，当然由于 Android 1.6 系统没有对 BLE 操作的 API。如果说所有 Android 1.6 系统不支持的对 BLE 模块的操作，都自己开发相应的 API，也是可以完成在 Android 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2c2a37e04ca78e5f039d5e18b519963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18486c713b000c8b72cfd85fa328bc56/" rel="bookmark">
			数据产品设计专题（1）- 数据产品设计方法论之互联网思维
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景
昨天和几个PM探讨一款数据产品的设计，发现很多有趣的地方，记录下来，算是笔记吧。该PM的产品的设计文档示意如下图所示：
该PM设计的设计论述可以归纳为：
1.本产品提供功能1、2、3....;
2.本产品功能x提供数据指标1、2、3...;
3.本产品...
围绕该PM的方案，几个PM展开了比较深入的PK，PK的焦点聚焦在以下几个问题；
二、点评和争议话题归纳
1.用户是谁？
2.用户痛点是什么？
3.用户的什么问题，可以通过该产品的使用得到解决？
4.指标来源是什么？为什么需要这些指标？指标的使用者是谁？
5.数据来源是什么？哪些数据是可获取的？获取方式是什么？获取周期和频率是什么？
6.产品的时间节点如何？分几个阶段，何时完成？
三、互联网思维与数据产品设计
互联网思维可以说是一个已经烂大街的概念，批评者众，人云亦云者众，而深思熟虑理性评判者稀。笔者在此引入互联网思维之于数据产品设计的应用，算是探索，亦是为互联网思维正名。之前博文曾经提到，基于商业本质看互联网思维的应用，示意图图下所示：
互联网思维不同实例是作用在商业活动不同环节的，具体到数据产品设计，笔者认为需要重点引入的是：
1.用户思维：站在用户的视角看需求，而非设计者自己的视角看产品；
2.痛点思维：产品到底能够解决用户的什么问题；
3.迭代思维：理想与现实的平衡点；
明确以上三点，之前点评中所有的问题，都会有明确的答案。
四、总结
业务产品&amp;数据产品设计面临的最大问题就是标准问题，为什么的问题？我们需要构建一套理论，来回答诸如之前点评中提到的问题，这套方法体系需要实践和探索来进行验证，本文算是v0.01的初始版吧。后续以此做一个定向专题，来探讨相应的方法论框架体系，希望更多的人参与进来。新建了一个QQ群（目前只有群主1人）：数据产品交流群 218256601，作为讨论和交流的空间，希望有更多的人参与进来，共同完成这套体系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f322d5b2567679c0bfe5b1f698bbbf0/" rel="bookmark">
			unhandled exception: Cannot load libssl.so.0.9.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 安装HANA SP11 revions 112 on SLES 12 SP1, error: unhandled exception: Cannot load libssl.so.0.9.8
分析：这个问题是因为SLES12 自带的libssl是1.0的版本，而HANA要访问的版本是0.9.8，这导致HANA没法找到
解决：建两个软链接
ln -s /lib64/libcrypto.so.1.0.0 /usr/lib64/libcrypto.so.0.9.8
ln -s /lib64/libssl.so.1.0.0 /usr/lib64/libssl.so.0.9.8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6376c37a08badedda2e63fac6ba4e5f0/" rel="bookmark">
			通过一个MVC  HtmlHelper扩展实例，简单说明扩展步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扩展Submit
using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.Mvc; namespace TestMvcHelper { public static class HtmlExtensions { public static MvcHtmlString Submit(this HtmlHelper helper, string value) { var builder = new TagBuilder("input"); //使我们创建的标签名字设为input builder.MergeAttribute("type", "submit"); //添加属性 type="submit" builder.MergeAttribute("value", value); return MvcHtmlString.Create(builder.ToString(TagRenderMode.SelfClosing)); } } } 上述实例说明
(1)、在使用TagBuilder需要引入命名空间System.Web.Mvc。
(2)、Submit方法名是对应视图中调用的名称。 (如：@Html.Submit("提交") )
(3)、this HtmlHelper helper 将Submit方法添加到HtmlHelper中，value是传过来的提交按钮上的文字。
(4)、var builder = new TagBuilder("input"); 设置标签名字设为input。
(5)、builder.MergeAttribute("type", "submit") 设置标签属性type="submit"。
(6)、builder.MergeAttribute("value", value); 设置标签提交按钮Value值。
(7)、TagRenderMode.SelfClosing 表示用于呈现自结束标记（例如，&lt;input /&gt;）的模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6376c37a08badedda2e63fac6ba4e5f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1a220668a91cc5f5e4d0d69bd609be7/" rel="bookmark">
			librtmp免openssl和zlib单独编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通常情况下我们只会用rtmp协议测试直播流，很少直接测试rtmps等需要加密的协议，为了加快开发速度可以简单的编译librtmp不用依赖 openssl 和zlib。
笔者使用的linux环境编译，windows下的和这个差不多已有其他开发者记录了编译过程。
1、首先修改rtmp_sys.h文件。
在文件中找到#ifdef _WIN32在其前面增加一句#define NO_CRYPTO，同时找到/* USE_OPENSSL */这个注释，修改为#elif defined(USE_OPENSSL) 或者直接注释掉#else的内容。
2、修改Makefile文件。
这里主要去除编译时对openssl和zlib动态库的依赖，在Makefile中找到$(CC) $(SO_LDFLAGS) $(LDFLAGS) -o $@ $^ $&gt; $(CRYPTO_LIB)这一行把最后的$(CRYPTO_LIB)删除。
这样就可以编译一个没有依赖的rtmp库，需要注意的是这样编译出来的库只能使用rtmp协议，如果你需要加密协议这个方法就不能用了。
﻿﻿ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d9f6ca1540f8eb4bb4349964e952661/" rel="bookmark">
			确定主机字节序的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小端（little-endian）字节序：将低序字节存储在起始地址。 大端（big-endian）字节序：将高序字节存储在起始地址。 主机字节序：某个给定系统所用的字节序。
short 数据，占2个字节，给它赋值0x0102。 若采用的大端法，则其低地址端应该存放的是0x02； 若采用的小端法，则其低地址端应该存放的是0x01； 通过联合体来获得其高低地址的数据。
参考《Unix网络编程.卷1》P64
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671f85346fbe4daf327f338eda0b2244/" rel="bookmark">
			Yast: SSL certificate problem, verify that the CA cert is OK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用Yast更新软件的时候发现没法更新，发现连不上SMT SERVER, 总是报错说：
SSL certificate problem, verify that the CA cert is OK
SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed
解决办法：
1)删掉旧的CA rm /var/lib/CAM/YaST_Default_CA
rm /srv/www/htdocs/smt.crt
2)创建新的CA smt.crt并且导出到/srv/www/htdocs/使用yast ca_mgm
3)查看openssl x509 -in /srv/www/htdocs/smt.crt -text
4)下载SMT SERVER的证书：
/usr/lib/suseRegister/bin/clientSetup4SMT.sh --host smtserver
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28dd4849192fd0a0852809e34765251c/" rel="bookmark">
			fatal error C1083: 无法打开预编译头文件  正确解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误：fatal error C1083: 无法打开预编译头文件：“Debug/DistanceMeasure.pch”: No such file or directory 这种错误是不存在预编译的.pch文件，即没有创建。 网上各种方法都是不使用预编译，其实这样做是不对的，这样会降低编译的效率。 问题解决在第三步，前两步是配置问题 有以下几步： 1：在工程的预编译头属性设置为使用预编译头（使用/Yu） 预编译头文件为 stdafx.h 2： 在 每个cpp文件 的开头都加入这个头文件 #include"stdafx.h" 3: 点击stdafx.cpp文件右键属性设置其预编译头为 “创建(/YC)” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2087c1e134c0bfc3e3df8359239e256c/" rel="bookmark">
			堆排序（向下调整建堆后再排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; using namespace std; void AdjustDown(int[] , int , int ); void BuildMaxHeap(int A[], int len) { for (int i = len / 2; i &gt;= 1; i--)//从完全二叉树的最后一个非叶子节点开始调整建立大根堆 { AdjustDown(A, i, len); } } void AdjustDown(int A[], int k, int len) { int temp = A[k];//保存当前结点的值 for (int i = 2 * k; i &lt;= len; i = i * 2)//从其右孩子开始 { if (i &lt; len &amp;&amp; A[i] &lt; A[i + 1])//如果有两个孩子，找到两个孩子中最大孩子的下标 i++; if (temp &gt;= A[i]) break;//已经是该结点大于其两孩子结点，不用再继续比较了 else { A[k] = A[i];//将大的向上调整 k = i;//移到当前结点的最大孩子结点处作为新的起始结点，再继续向下比较 }	} A[k] = temp;//找到了最终的位置并放入 } void HeapSort(int A[], int len)//堆排序：每次将堆顶元素和最后一个元素交换，再将剩余i-1个元素调整为新的堆，重复到堆只有一个元素 { BuildMaxHeap(A, len); for (int i = len; i &gt;= 1; i--)//从堆的最后一个元素开始交换 { swap(A[i], A[1]);	//每次堆顶元素和堆的最后一个元素交换	AdjustDown(A, 1, i - 1);//将剩余i-1个元素调整为新的堆 }	} int main() { int A[9] = {0,53,17,78,9,45,65,87,32};//为了方便下标为i时左右孩子的下标为2i，2i+1，数组从1开始存储 HeapSort(A, 8); for (int i = 1; i &lt;= 8; i++) cout &lt;&lt; A[i] &lt;&lt; endl; system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2087c1e134c0bfc3e3df8359239e256c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/501800674831022fd3f2008fac48a8b9/" rel="bookmark">
			css 2D变形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 旋转rotate 旋转rotate()函数 通过指定的角度参数使元素相对原点进行旋转。它主要在二维空间内进行操作，设置一个角度值，用来指定旋转的幅度。 如果这个值为 正值 ，元素相对原点中心 顺时针 旋转；如果这个值为 负值 ，元素相对原点中心 逆时针 旋转。 transform:rotate(-20deg); 缩放动画scale scale()函数 让元素根据中心原点对对象进行缩放; 1、 scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放） 如： transform: scale(1.5,0.5); 如果第二个参数没有设置，则第二个参数等于第一个参数 2、scaleX(x)元素仅水平方向缩放（X轴缩放） 如： transform: scale(2,1); 高 度不变， 宽 度变成之前的2倍 3、scaleY(y)元素仅垂直方向缩放（Y轴缩放） 如： transform: scale(1,2); 宽度不变，高度变成之前的2倍 注：参数值为正数值放大元素；负数值先翻转元素，再缩放元素；0.01~0.99之间缩小元素 位移 translate() translate()函数可以将元素向指定的方向移动，类似于position中的relative。或以简单的理解为，使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。 1、translate(x,y)水平方向和垂直方向同时移动 （也就是X轴和Y轴同时移动） 2、translateX(x)仅水平方向移动（X轴移动） 3、translateY(Y)仅垂直方向移动（Y轴移动） 实例演示：通过translate()函数将元素向Y轴下方移动50px,X轴右方移动100px。 transform: translate(100px,50px); 倾斜 skew() 扭曲skew()函数能够让元素倾斜显示。它可以将一个对象以其中心位置围绕着X轴和Y轴按照一定的角度倾斜。这与rotate()函数的旋转不同，rotate()函数只是旋转，而不会改变元素的形状。skew()函数不会旋转，而只会改变元素的形状。 1、skew(x,y)使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）；
2、skewX(x)仅使元素在水平方向扭曲变形 （X轴扭曲变形）； 3、skewY(y)仅使元素在垂直方向扭曲变形（Y轴扭曲变形） 矩阵 matrix() matrix() 是一个含六个值的(a,b,c,d,e,f)变换矩阵，用来指定一个2D变换，相当于直接应用一个[a b c d e f]变换矩阵。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵，我在这里只是简单的说一下CSS3中的transform有这么一个属性值，如果需要深入了解，需要对数学矩阵有一定的知识。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c28e4653e2861dcaa725f5861f0557c/" rel="bookmark">
			字符串匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 假设两个字符串中所含有的字符和个数都相同我们就叫这两个字符串匹配，比如：abcda和adabc,由于出现的字符个数都是相同，只是顺序不同，所以这两个字符串是匹配的。要求高效。
#include "iostream" #include "string" using namespace std; const int N=256; bool ifMatch(string s1,string s2) { int a[N]={0}; if(s1.size()!=s2.size()) return false; else { for(int i=0;i&lt;s1.size();i++) { a[(int)s1[i]]++; a[(int)s2[i]]--; } for(int j=0;j&lt;N;j++) { if(a[j]!=0) return false; } } return true; } void test() { string s1="abcdeab"; string s2="bedbaac"; string s3="abadeab"; cout&lt;&lt;ifMatch(s1,s2)&lt;&lt;endl; cout&lt;&lt;ifMatch(s1,s3)&lt;&lt;endl;	} int main() { test(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71350950f09c0f6ce42438bd61a4adec/" rel="bookmark">
			[ERP]IQC,IPQC,PQC,FQC,OQC是什么意思?是干什么的?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IQC,IPQC,PQC,FQC,OQC是什么意思?是干什么的? 需要懂什么和会什么
IQC、IPQC、PQC、FQC、OQC，这个是品质管理的5个阶段，也是5个工种，分别负责不同阶段的品质管控。
IQC进料检验(Incoming Quality Control供应商品保部).主要是控制来料的品质管控
电子元器件IQC来料检验标准:电阻,电容,二/三极管,IC,晶振电感 http://www.pinzhi.org/thread-3026-1-1.html
什么是AQL? AQL抽样标准-品质抽样检验标准: MIL-STD-105E http://www.pinzhi.org/thread-256-1-1.html
IPQC制程品管(In Process Quality Control Section)针对制程上的品质管控(某些公司的IPQC会握有稽核的权力) IPQC是什么意思?IPQC工作职责和IPQC工作流程 http://www.pinzhi.org/thread-452-1-3.html
IPQC工作职责：IPQC检验流程图 http://www.pinzhi.org/thread-3028-1-1.html
PQC半成品检验Process Quality Control
FQC终检(Final Quality Control成品检验)在产品出货之前需做最后检验才可出货
OQC出货检验(Out-going Quality Control出货品保课)针对成品要出货的物品品质管控
OQC工作职责和作业指导：OQC出货检验流程图 http://www.pinzhi.org/thread-3027-1-1.html
一般情况下，绝大部分的公司在QC布置方面，只有IQC，IPQC和OQC，也有的会有FQC，有的是把IPQC和FQC合二为一，即只有IPQC，没有FQC.
IQC：一间公司生产线原材问题多不多要看IQC IPQC：一间公司生产线制程品质问题要看IPQC OQC：一间公司客诉、客退问题多不多要看OQ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c804afcc2b58a2f46f7f0a1b9011c4/" rel="bookmark">
			MVC通过扩展HtmlHelper实现RadioButtonList
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ RadioButtonList在Web页面应用非常广泛，在传统的ASP.NET aspx中系统自带有RadioButtonList控件，但是在MVC Razer中没有提供，下面介绍通过扩展HtmlHelper实现RadioButtonList的方法
public static class RRadioButtonListelper { public static MvcHtmlString RadioButtonList(this HtmlHelper helper, string name) { return RadioButtonList(helper, name, helper.ViewData[name] as IEnumerable&lt;SelectListItem&gt;, new { }); } public static MvcHtmlString RadioButtonList(this HtmlHelper helper, string name, IEnumerable&lt;SelectListItem&gt; selectList) { return RadioButtonList(helper, name, selectList, new { }); } public static MvcHtmlString RadioButtonList(this HtmlHelper helper, string name, IEnumerable&lt;SelectListItem&gt; selectList, object htmlAttributes) { IDictionary&lt;string, object&gt; HtmlAttributes = HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes); HtmlAttributes.Add("type", "radio"); HtmlAttributes.Add("name", name); StringBuilder stringBuilder = new StringBuilder(); int i = 0; int j = 0; foreach (SelectListItem selectItem in selectList) { string id = string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c804afcc2b58a2f46f7f0a1b9011c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc2ce844e715083ac41dbb27d7a8cfaf/" rel="bookmark">
			Vi命令简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。
1. vi的基本概念：
基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：
1) 命令行模式command mode）
控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insertmode下，或者到 last line mode。
2) 插入模式（Insert mode）
只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。
3) 底行模式（last line mode）
将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。
注：一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。
2. vi的基本操作
1）进入vi
在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面：
$ vi myfile 注：进入vi之后，是处于「命令行模式（command mode）」，要切换到「插入模式（Insert mode）」才能够输入文字。
2）切换至插入模式（Insert mode）编辑文件
在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。
3）Insert 的切换
在插入模式中，按「Esc」进入到命令行模式。
4）退出vi及保存文件
在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如：
: w filename （输入 「w filename」将文章以指定的文件名filename保存）
: wq (输入「wq」，存盘并退出vi)
: q! (输入q!， 不存盘强制退出vi)
3. 命令行模式（commandmode）功能键
1）插入模式
按「i」切换进入插入模式「insert mode」，按"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc2ce844e715083ac41dbb27d7a8cfaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ac020311a98920f8f0b223cdc08d1a/" rel="bookmark">
			笛卡尔的情书r=a(1-sinθ)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php $width = 600; $height = 650; header("Content-type: image/gif"); $img = imagecreate($width, $height); $bg_color = imagecolorallocate($img, 0, 0, 0); $red = imagecolorallocate($img, 255, 0, 0); for ($i = 0; $i &lt;= 100; $i++) { for ($j = 0; $j &lt;= 100; $j++) { $r = M_PI / 50 * $i * (1 - sin(M_PI / 50 * $j)) * 40; $x = $r * cos(M_PI / 50 * $j) * sin(M_PI / 50 * $i) + $width / 2; $y = -$r * sin(M_PI / 50 * $j) + $height / 6; imagesetpixel($img, $x, $y, $red); } } imagegif($img); imagedestroy($img);exit; 效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2a9ede2067addf6c6b04a0d6a283345/" rel="bookmark">
			[Unity热更新]tolua# &amp; LuaFramework(七)：lua使用DOTween
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关链接：
http://blog.csdn.net/u010665359/article/details/50950989
http://blog.csdn.net/u010665359/article/details/51013433
在lua中使用DOTween
1.先下载一些东西：http://pan.baidu.com/s/1pLOSxx5
2.在Assets\LuaFramework\Editor下建两个文件夹，分别命名为LuaExtensions和Wrap，然后在LuaExtensions文件夹内放入ToLuaFile.cs和ToLuaFileExport.cs，然后点击菜单栏Lua/Export ToLuaExtendFile，如无意外就会看到：
3.将项目中的ToLuaExport.cs进行一些修改，当然你可以不修改，直接将下载的ToLuaExport.cs替换原来的，注意最好备份。要修改的地方用红色标明了：
static void SaveFile(string file)
{ using (StreamWriter textWriter = new StreamWriter(file, false, Encoding.UTF8))
{ StringBuilder usb = new StringBuilder();
usb.AppendLineEx("//this source code was auto-generated by tolua#, do not modify it");
foreach (string str in usingList)
{
usb.AppendFormat("using {0};\r\n", str);
}
usb.AppendLineEx("using LuaInterface;");
if (ambig == ObjAmbig.All)
{
usb.AppendLineEx("using Object = UnityEngine.Object;");
}
if (NeedDotweenNamespace())//给导出dotween的文件新增dotween的命名空间
{
usb.AppendLine("using DG.Tweening;");
}
usb.AppendLineEx();
textWriter.Write(usb.ToString());
textWriter.Write(sb.ToString());
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2a9ede2067addf6c6b04a0d6a283345/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d928a14816394e257f2d465ef8fdee/" rel="bookmark">
			基于遗传算法的BP神经网络优化算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遗传算法优化BP神经网络分为BP神经网络结构确定、遗传算法优化和 BP神经网络预测3个部分。其中,BP神经网络结构确定部分根据拟合函数输入输出参数个数确定 BP神经网络结构,这样就可以确定遗传算法的优化参数个数，进而确定遗传算法个体的编码长度。因为遗传算法优化的参数是 BP神经网络的初始权值和阈值,只要网络的结构已知，权值和阈值的个数就已知了。种群中的每个个体都包含了一个网络所有权值和阈值,个体通过适应度函数计算个体适应度值,遗传算法通过选择、交叉和变异操作找到最优适应度值对应的个体。BP神经网络预测用遗传算法得到最优个体对网络进行初始权值和阈值的赋值,网络经训练后预测样本输出。神经网络的权值和阈值一般是通过初始化为【-0.5,0.5】区间的随机数，这个初始化参数对网络训练的影响很大，但是又无法准确获得，对于相同的初始权重值和阈值，网络的训练结果是一样的，引入遗传算法就是为了优化出最优的初始权值和阈值。
遗传算法优化BP神经网络的算法流程如下：
遗传算法的基本要素包括染色体编码方法、适应度函数、遗传操作和运行参数。其中染色体编码方法是指个体的编码方法,目前包括二进制法、实数法等。二进制法是指把个体编码成为一个二进制串,实数法是指把个体编码成为一个实数串。适应度函数是指根据进化目标编写的计算个体适应度值的函数,通过适应度函数计算每个个体的适应度值,提供给选择算子进行选择。遗传操作是指选择操作、交叉操作和变异操作。运行参数是遗传算法在初始化时确定的参数,主要包括群体大小 M,遗传代数G,交叉概率Pc和变异概率Pm。（下面都是引用的MATLAB智能算法30个案例里面的内容，太多了，偷了个懒） 下面是函数实现的代码部分：
clc
clear all
close all
%% 加载神经网络的训练样本 测试样本每列一个样本 输入P 输出T，T是标签
%样本数据就是前面问题描述中列出的数据
%epochs是计算时根据输出误差返回调整神经元权值和阀值的次数
load data
% 初始隐层神经元个数
hiddennum=31;
% 输入向量的最大值和最小值
threshold=[0 1;0 1;0 1;0 1;0 1;0 1;0 1;0 1;0 1;0 1;0 1;0 1;0 1;0 1;0 1];
inputnum=size(P,1); % 输入层神经元个数
outputnum=size(T,1); % 输出层神经元个数
w1num=inputnumhiddennum; % 输入层到隐层的权值个数
w2num=outputnumhiddennum;% 隐层到输出层的权值个数
N=w1num+hiddennum+w2num+outputnum; %待优化的变量的个数
%% 定义遗传算法参数
NIND=40; %个体数目
MAXGEN=50; %最大遗传代数
PRECI=10; %变量的二进制位数
GGAP=0.95; %代沟
px=0.7; %交叉概率
pm=0.01; %变异概率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d928a14816394e257f2d465ef8fdee/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/546/">«</a>
	<span class="pagination__item pagination__item--current">547/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/548/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>