<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00154d7fa600d0428cae7f61ebf83d69/" rel="bookmark">
			C&#43;&#43;中的指针、数组和指针算术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数组中第一个元素的地址与数组地址 *：取值运算符 &amp;：取址运算符
int a[3]={1,2,3};
int *p1=a; //指针p1指向数组中第一个元素，此时p1+1将指向数组中第二个元素
int *p2=&amp;a; //指针p2指向数组的头，此时p2+1将指向跳过此数组全部长度的下一位置
数组名就代表数组中第一个元素的地址，p1和p2存储的地址相同，但表达的含义不同，即+1时指针指向的也不同。
二、字符串指针 对于C风格的字符数组来说，char数组名、char指针和用双引号括起的字符串都视为字符串中第一个字符的地址。
char *p="study"; //合法
三、使用new动态分配数组 int *p=new int; delete p;
int *pm=new int[10];
delete [] pm; //对数组delete时要带上[]
使用new将会在程序运行时分配一个合适的内存，并将该内存的地址传给p。使用new后一定要有一个delete与之对应。
在编译时就给数组分配内存称为静态联编，而使用new在程序运行阶段创建数组称为动态联编。
使用静态联编时，必须在编写程序时指定数组的长度，而动态联编将在程序运行时确定数组长度。
四、指针数组和数组指针 指针数组：int *p[10]; p优先和[]结合，即p是个数组，数组中每个元素都是int *类型
数组指针：int (*p)[10];
优先括号，即p是个指针，它指向一个数组元素为int类型的数组
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f974c4685dff2e0e3943c3a142aaca9/" rel="bookmark">
			JMeter接口压测之参数配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全局参数设置
作用：改动少，使用范围广
常见的全局参数：hostname,IP,端口，协议等定义为全局变量
Thread Group --Config Element–User Defined Variables
配置：
hostname :localhost
port:9090
protocol:http
配置完成后，可在每个http request 使用对应的参数变量名
${hostname}
${port}
${protocol}
CSV数据导入
使用场景：
多用户操作
配置数据量过大
创建CSV格式文件：
注意：CSV数据之前用英文逗号分割
No,username,password
1,user01,pwd
2,user02,pwd
…
配置&amp;导入：
添加：Thread Group --Config Element–CSV 数据文件设置
配置变量名对应到数据列
引用变量
在HTTP Request请求中配置参数变量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a005f0ec44c2c17f796d7c50022c92a4/" rel="bookmark">
			gitee、Everything、TortoiseGit工具分享及注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github、gitee简介
gitee是基于Git的代码托管和研发协作平台，在上面可以托管个人或者公司的代码和开源项目。目前许多大公司喜欢用。
国外的是github，github网址：https://github.com/ (网络要求高/访问慢，个人不是很推荐)
国内的是gitee，gitee网址：https://gitee.com/ （访问速度快，个人推荐）
这里我给大家整理了一下，百度网盘自取：
链接：https://pan.baidu.com/s/1fnB1Xlq6U1bhFbw9XrEuHg 提取码：23bt
Everything工具 gitee-代码托管和研发协作平台（支持开源） TortoiseGit(小乌龟) 首先介绍Everything工具 Everything是一个搜索软件，将它安装在我们的电脑中可以便捷快速的帮我们找到目标文件，且Everything所占内存空间不大。点击安装（.exe）后，一直同意默认选项即可。安装成功后，会出现下图，例如：
gitee-代码托管和研发协作平台（支持开源） 在安装gitee之前呢，我们需要先注册一个gitee账号,网址：https://gitee.com/。在右上角点击注册账号。
注册完毕后，我们就可以点击下载gitee。
点击安装（.exe）后出现下列界面：
点击Next，出现下图：
注意，尽量不要改动默认途径，因为接下来的TortoiseGit(小乌龟)软件会和gitee默认放在同一个文件夹中，改动后，可能会存在一点问题，当然了，TortoiseGit会自动寻找gitee路径，我这里为了避免麻烦就直接选用默认路径。仅供参考。
一直Next,直到出现下图：
后面一直默认即可，安装好后，右击鼠标，当出现列图标，即安装成功
TortoiseGit(小乌龟) 介绍我们的第三个软件—TortoiseGit（也叫小乌龟下载完成后，会出现一个乌龟的图像），为什么要下载这个软件呢，因为下载完gitee，点开gitee，会出现下图界面，这是需要输入操作命令的，小乌龟是一个图形显示化软件，安装这个之后，我们就可以使用图形化界面。
双击安装之后，点击Next即可。
这个只有英文版，所以我们就用英文版即可。
之后会出现这个界面，不要改动路径，它会自动寻找到存放gitee的文件夹，只要把它和gitee放同一文件夹即可。
之后会出现下列界面，需要我们填写账号姓名和邮箱，这个时候我们要返回gitee网页，在&lt;个人主页&gt;中复制我们的名字（记住名字是@符号后面的字符，只需复制@后面的字符到Name输入框中即可，不要有多余的空格）。在&lt;个人设置&gt;中点开邮箱管理-我的邮箱地址，复制你的邮箱即可。
然后一直同意默认即可，安装完成后，右击鼠标，出现下列图标即安装成功。
期间，有些朋友可能是因为第一次安装，所以需要输入验证，但没有什么关系，按照他的指令要求来就可以了。
好的，这次的分享就到这里，如有不当之处，还望指正，欢迎一起探讨学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43dd28fb4277b2d51b70003b05166018/" rel="bookmark">
			树和二叉树相关的练习（选择题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、二叉树
二、堆 三、遍历二叉树 一、二叉树 某二叉树共有 399 个结点，其中有 199 个度为 2 的结点，则该二叉树中的叶子结点数为（ ）。
A. 不存在这样的二叉树
B. 200
C. 198
D. 199
下列数据结构中，不适合采用顺序存储结构的是（ ）。
A. 非完全二叉树
B. 堆
C. 队列
D. 栈
在具有 2n 个结点的完全二叉树中，叶子结点个数为（ ）。
A. n
B. n + 1
C. n - 1
D. n / 2
一棵完全二叉树的节点数位为 531 个，那么这棵树的高度为（ ）。
A. 11
B. 10
C. 8
D. 12
一个具有 767 个节点的完全二叉树，其叶子节点个数为（）。
A. 383
B. 384
C. 385
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43dd28fb4277b2d51b70003b05166018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3cb2ec5bc3c042ce9b96b069deafd9/" rel="bookmark">
			Chatgpt在训练过程中过拟合的表现和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT是一个基于GPT-2模型的聊天机器人，它需要在大量的对话语料库上进行训练以获得有用的表现，在训练大模型（例如ChatGPT）时，随着训练集的增加，过拟合问题就可能出现。
通常，过拟合会导致模型在训练数据上表现非常出色，但在测试数据（或未见过的数据）上表现不佳，这是因为训练数据太多而导致了模型过于复杂。
以下是可能出现的情况：
模型的权重系数非常大，使得模型泛化能力变得弱。模型在训练集上表现非常好，但在测试集上表现明显变差。模型过度依赖于训练集的特殊特征，而忽略了泛化到更广泛的数据上的能力。模型对噪声、异常值和样本数量较少非常敏感，并且容易产生误分类模型可能在被误分类的情况下变得非常自信，因为它过度拟合于训练集，从而导致模型出现过拟合。 以下是一些ChatGPT进行训练时避免过拟合问题的常见方法：
数据集增强(Data Augmentation)
数据集增强是指对原始数据进行转换，生成更多种类的数据，以扩大数据集。这样可以让模型在更多的数据上进行训练，从而提高模型的泛化能力和鲁棒性。ChatGPT可以通过复制、删除、随机替换、替换为近义词等方法进行数据集扩充。
Dropout
Dropout是一种在训练过程中随机忽略一些神经元的技术。这种技术可以减少网络的过拟合，因为神经元的随机忽略会使得网络不会在任何一个特定的特征上过分的依赖，因此可以减少网络的过分拟合。
Early stopping
Early stopping是指在训练过程中，不断评估模型的性能，在一定的步骤后停止训练。这可以帮助模型避免过拟合，因为模型提前停止训练时，模型能够获得最佳的泛化性能表现。
Regularization
正则化是一种通过在损失函数中添加额外的惩罚来惩罚一些复杂度较高的模型。正则化可以促使网络获得更好的泛化性能，其中L1和L2正则化最为常见。
数据集分割
数据集分割可以将数据集划分为训练集、验证集和测试集等，以便在训练过程中评估模型的性能，并检验模型在新数据上的表现能力。通过根据训练集来调整模型超参数、验证模型的性能，并使用测试集评估模型的泛化能力。
减少模型的复杂性
防止模型对训练数据的过度拟合，例如减少隐藏层节点数、减少模型参数等。
增加数据量
增加训练数据，提升训练数据数量和质量，增强模型泛化能力，至少要保证训练数据规模不会导致欠拟合，帮助模型学习泛化能力
用集合数据的方法
如交叉验证验证模型性能，综合考虑所有训练和验证数据的性能来选择模型和调整参数，提前检测和解决出现的过拟合问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7408cddd2ac435a7757eb4667ae4dd6/" rel="bookmark">
			【usb】linux内核USB键盘驱动解析--普通键值上报及转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概况 建议阅读前置文章【usb】linux内核USB键盘驱动解析–特殊键值上报及转化以Linux5.10内核中USB键盘驱动为例进行解析：https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.10.tar.gz文件路径：linux-5.10/drivers/hid/usbhid/usbkbd.c本次我们主要分析第120~139行的这个for循环。 二、探索 for循环变量i范围是2-7，是因为普通键值存放在数组的第2-7个元素。第一个存放的是特殊键值，第二个保留。kbd-&gt;old[i] &gt; 3这个判断是因为，0-3几个键值是保留的没有对应的物理按键。所以我们不需要关注。具体说明见hut1_4第10节。 if (kbd-&gt;old[i] &gt; 3 &amp;&amp; memscan(kbd-&gt;new + 2, kbd-&gt;old[i], 6) == kbd-&gt;new + 8) { if (usb_kbd_keycode[kbd-&gt;old[i]]) input_report_key(kbd-&gt;dev, usb_kbd_keycode[kbd-&gt;old[i]], 0); 上面这段代码，首先memscan的功能是 在一块内存中查找一个字符，也就是在kbd-&gt;new + 2这块内存中查找字符kbd-&gt;old[i]。6表示kbd-&gt;new + 2这块内存大小为6。如果找到了则返回该字符地址，否则返回该内存块末尾地址+1。所以这段代码的意思是，在新报上来的键值中查找旧的键值，如果没有找到，并且if (usb_kbd_keycode[kbd-&gt;old[i]])旧的键值为有效键值，那么就上报旧的键值已释放（按键已松开/抬起）。 if (kbd-&gt;new[i] &gt; 3 &amp;&amp; memscan(kbd-&gt;old + 2, kbd-&gt;new[i], 6) == kbd-&gt;old + 8) { if (usb_kbd_keycode[kbd-&gt;new[i]]) input_report_key(kbd-&gt;dev, usb_kbd_keycode[kbd-&gt;new[i]], 1); 这段代码逻辑和上面的差不多，在旧的键值中查找新的键值，如果没有找到这个新的键值，并且这个新的键值是有效的，那么就上报该新键值被按下。 三、总结 在kbd-&gt;old中保存了上次报上来的键值，kbd-&gt;new中是本次报上来的键值。如果上次报了某键值，但是本次没报，说明该按键被释放了，所以上报案件旧释放事件。如果上次没有报某按键而这次报了，说明该按键是这次被按下了，所以要上报按键按下事件。 四、参考资料 hut1_4
memscan(9) — linux-manual-4.8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ee5d24d5404bf62ab98e1722f633c6/" rel="bookmark">
			计算机操作系统实验 ( Win平台实现 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近学校安排计算机操作系统实验, 在学习过程中整理了一些代码和内容, 再次记录和分享一下, 希望能帮到各位. 若有问题欢迎交流代码运行环境是 vscode 配置的 C/C++ 环境和 DEV C++ 实验一: 创建进程 所涉及函数 PS: win平台相关的函数都可以在微软官网查到具体内容和案例 ( 虽然有的跑不起来 )
子进程程序 在这里要注意, 先使用 DEV C++ 把子进程编译成可执行文件 ( .exe ), 父进程才能基于该文件创建子进程, 结合CreateProcess()函数中参数的定义即可知道.
#include&lt;stdio.h&gt; #include&lt;windows.h&gt; int main() { printf("子进程开始运行...\n\n"); const char *something = "这是一句话。"; FILE *fp; if(fp = fopen("D:\\test.txt","w+")) //以可读写方式打开文件 { printf("文件打开成功!\n\n"); fwrite(something,strlen(something),1,fp); //将something写入文件中 fwrite("\n这是另一句话。",strlen("\n这是另一句话。"),1,fp); //将另一句话写入文件中 printf("写入数据成功!\n\n"); fclose(fp);//关闭文件 fp = fopen("D:\\test.txt","r"); //以只读方式打开文件 printf("当前文件中的内容如下：\n"); char ch=fgetc(fp); //取第一个字符 while(ch!=EOF) //当该字符不为文件结束标志时 { putchar(ch); //输出该字符 ch=fgetc(fp); //继续从文件中获取字符 } fclose(fp); //关闭文件 } else printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ee5d24d5404bf62ab98e1722f633c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff5b1b0137d64e5d21c0fb8e3fd8ada3/" rel="bookmark">
			js做一个简单的计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; *{ margin: 0; padding: 0; } div{ width: 300px; border: 1px solid #666; margin: 0 auto; text-align: center; } textarea{ /* 取消右下角标识，禁止拖拽 */ resize: none; width: 100%; border: 0; outline: 0; border-bottom: 1px solid #666; height: 100px; font-size: 35px; } button{ width: 30%; height: 50px; margin: 2px 0px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;textarea id="txt" readonly&gt;&lt;/textarea&gt; &lt;button&gt;1&lt;/button&gt; &lt;button&gt;2&lt;/button&gt; &lt;button&gt;3&lt;/button&gt; &lt;button&gt;4&lt;/button&gt; &lt;button&gt;5&lt;/button&gt; &lt;button&gt;6&lt;/button&gt; &lt;button&gt;7&lt;/button&gt; &lt;button&gt;8&lt;/button&gt; &lt;button&gt;9&lt;/button&gt; &lt;button&gt;0&lt;/button&gt; &lt;button&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff5b1b0137d64e5d21c0fb8e3fd8ada3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/660fe8bf6b3289a37d73a676b48925bb/" rel="bookmark">
			c&#43;&#43;多线程编程 Trap 2: std::promise多次set_value引发的灾难
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 学习多线程编程过程，因为编写代码不够严谨并且对std::promise与std::future的了解不够到位，造成了这次程序崩溃。
问题报错信息如下：
（最近老是搞崩程序啊，流泪啊。。。）
示例代码如下：
void promise_future_example() { auto meaning = [](std::promise&lt;int&gt;&amp; prom) { //first set value by promise, note: only set value once by promise prom.set_value(42); //many codes //... //error: second set value by promise prom.set_value(41); }; std::promise&lt;int&gt; prom; std::future&lt;int&gt; result = prom.get_future(); std::thread(meaning, std::ref(prom)).detach(); std::cout &lt;&lt; "the meaning of the life: " &lt;&lt; result.get() &lt;&lt; std::endl; } 原因分析： 这次遇到的问题，还是因为对std::promise的了解的不到位，当然如果遇到代码量超多的情况，也可能会发生这种问题，就是在一个任务（线程）中连续调用两次或多次std::promise::set_value()函数，这是造成本次程序崩溃的根因所在。
基础很重要，细心同样重要，不然这个问题就不会发生了。。。
解决方案： 在线程函数中去除多余的std::promise::set_value()函数调用即可。
（解决方案多简单，定位问题老费劲了。。。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc3fffbb078b526c48a8df269b04cbb/" rel="bookmark">
			谈谈SpringBoot（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. SpringBoot依赖管理 1.1 父依赖 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; 点击进去，看父依赖的父依赖
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.7.8&lt;/version&gt; &lt;/parent&gt; 再点击进去，会看到全局的版本管理，声明了开发中几乎所有常用jar包的版本
spring-boot-dependencies里面规定当前依赖的版本 用的 key
&lt;properties&gt; &lt;activemq.version&gt;5.16.5&lt;/activemq.version&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt; &lt;appengine-sdk.version&gt;1.9.98&lt;/appengine-sdk.version&gt; &lt;artemis.version&gt;2.19.1&lt;/artemis.version&gt; &lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt; &lt;assertj.version&gt;3.22.0&lt;/assertj.version&gt; &lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt; ........ &lt;mysql.version&gt;8.0.32&lt;/mysql.version&gt; ........ &lt;/properties&gt; 1.2 修改jar的版本 比如，如何修改mysql版本呢？当前版本是8.0.32，那么改成8.0.31？
&lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 根据全局的版本管理中的mysql的key进行设置
&lt;properties&gt; &lt;mysql.version&gt;8.0.31&lt;/mysql.version&gt; &lt;/properties&gt; 注意：
1、引入依赖默认都可以不写版本
2、引入非版本仲裁的jar，要写版本号
2. 容器功能 2.1 组件添加 2.1.1 @Configuration @Configuration //告诉Springboot这是一个配置类，它本身也是一个组件 public class MyTestConfig { //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。 //返回的值，就是组件在容器中的实例 @Bean public Employee emp(){ Employee zhangsan = new Employee(1,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbc3fffbb078b526c48a8df269b04cbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b612ba4517348ca0fc41ab82df99d1/" rel="bookmark">
			Spring boot中使用属性配置设置功能参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.使用背景
2.使用方式
(1)使用@value注解
(2)直接将配置文件中的内容注入到实体类中
3.总结
1.使用背景 在Spring boot项目中，常常通过配置文件来设置一些项目中要使用的一些内容，比如说要访问系统的url，一些系统中用到的参数，通过配置文件来定义的好处是一旦内容发生改变，不需要修改代码，只需要修改配置文件，重新启动服务即可。
2.使用方式 (1)使用@value注解 配置文件中定义了一些属性
student: studentId: 10 studentName: 小李 studentNo: 01 import org.springframework.beans.factory.annotation.Value; @Value("${student.studentId}") private Integer studentId; @Value("${student.studentName}") private String studentName; @Value("${student.studentNo}") private String studentNo; @Test public void test2(){ System.out.println(studentId); System.out.println(studentName); System.out.println(studentNo); } (2)直接将配置文件中的内容注入到实体类中 配置文件中定义了一些属性
student: studentId: 10 studentName: 小李 studentNo: 01 创建实体类来接受配置文件中的属性
package com.example.demo.domain; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; /** * @author linaibo * @version 1.0 * Create by 2022/12/2 22:20 */ @Data @ConfigurationProperties(prefix = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b612ba4517348ca0fc41ab82df99d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5325724fda20fe715ad6d3443347833d/" rel="bookmark">
			JavaSE --- 用java实现选择排序和二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.选择排序 //选择排序 public class Test1 { public static void main(String[] args) { //1.定义数组 int[] arr = {5,1,3,2}; //2.定义一个循环控制选择几轮，arr.length - 1 for (int i = 0; i &lt; arr.length-1; i++) { //3.定义内部循环控制选择几次 for(int j = i + 1; j&lt;arr.length; j++ ){ //当前位：arr[i] //如果有比当前为数据更小，则交换 if(arr[i] &gt; arr[j]){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } System.out.println(Arrays.toString(arr)); } } 2.二分查找 //二分查找 //也有官方api，直接调用Arrays.binarysearch(数组，key值) public class Test2 { public static void main(String[] args) { //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5325724fda20fe715ad6d3443347833d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61084a527e7fda6a83267d3795e9ed10/" rel="bookmark">
			python中的保留小数的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 引入 在数学的计算中我们经常需要来保留小数,但是有的保留小数的方法我们却是不知道如何去使用的,下面我来介绍三种方法.你会通过代码来更清楚的了解他们的使用方法.
二.使用% 的方法来进行保留小数位 1 使用数字 print('%.3f'%1.3443) print('%.3f'%1.3444) print('%.3f'%1.4445) print('--------分割线-------------') print('%.3f'%1.4446) print('%.3f'%1.3447) 结果: 1.344 1.344 1.444 --------分割线------------- 1.445 1.345 结论:所以,你发现了什么?好像不是四舍五入的样子呢,怎么变成了四舍六入了?对就是四舍六入
2 使用变量 a=1.34445 print('%.3f'%a) print('%.4f'%a) print('%.5f'%a) print('%.6f'%a) print('%.3f'%a) 结果: 1.344 1.3444 1.34445 1.344450 1.344 总结:没有覆盖,但是% 会补零.
三.使用format 的方法来进行保留小数位 1 使用数字 print(format(1.34445,'.4f')) print(format(1.34445,'.5f')) print(format(1.34445,'.3f')) print('--------分割线-------------') print(format(1.3443,'.3f')) print(format(1.3444,'.3f')) print(format(1.3445,'.3f')) print(format(1.3446,'.3f')) print(format(1.3447,'.3f')) 结果: 1.3445 1.34450 1.345 --------分割线------------- 1.344 1.344 1.345 1.345 1.345 结论:所以,你发现了什么?这个好像是四舍五入的样子呢,所以fromat 是四舍五入的.
2 使用变量 a=1.34445 print(format(a,'.4f')) print(format(a,'.5f')) print(format(a,'.6f')) print(format(a,'.3f')) 结果: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61084a527e7fda6a83267d3795e9ed10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cdd264f09d4c17f79cbc781586ea35b/" rel="bookmark">
			使用 WeightedRandomSampler 解决数据样本不均衡的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 数据集样本不均衡。
例如，一个二分类任务，标签为 0 的数据占了 90%，标签为 1 的数据却只占 10%，用全部原始数据训练模型很可能导致模型带有一定的 ”偏见“，也可能会导致模型训练效率很慢。
使用 WeightedRandomSampler 均衡数据 PyTorch 官方文档：torch.utils.data.WeightedRandomSampler
以下即是 PyTorch 官方文档给出的说明：
可以看到官方文档中给了代码示例：
&gt;&gt;&gt; list(WeightedRandomSampler([0.1, 0.9, 0.4, 0.7, 3.0, 0.6], 5, replacement=True)) [4, 4, 1, 4, 5] &gt;&gt;&gt; list(WeightedRandomSampler([0.9, 0.4, 0.05, 0.2, 0.3, 0.1], 5, replacement=False)) [0, 1, 4, 3, 2] 结合这个示例解释一下各个参数：
weights：用来采样的权重序列，并且并不要求这个序列的加和为 1。
比如第一个示例中的 [0.1, 0.9, 0.4, 0.7, 3.0, 0.6]，就表示取第 0 个样本的权重（可以理解为概率，但不等同）为 0.1，取第 1 个样本的权重为 0.9，…，取第 4 个样本的权重为 3.0，…，很明显，取第 4 个样本的概率最大，然后是 第 1 个、第 3 个、第 5 个、第 2 个、第 0 个。num_samples：采样的数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cdd264f09d4c17f79cbc781586ea35b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d65bfb8e2afbee489dea880145c508fb/" rel="bookmark">
			JavaSE --- 正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.调用方法 //: 判断是否匹配正则表达式，匹配返回true，不匹配返回false。regex表示的是正则表达式
public boolean matches(String regex)
2.匹配模式 2.1字符类（默认匹配一个字符）： [abc]匹配只包含是a，b或c[^abc]匹配不包含abc的任何字符[a-zA-Z]匹配a到z，A到Z的所有字符[a-d[m-p]]匹配a到d，或m通过p[a-z&amp;&amp;[def]匹配d,e,或f(交集)[a-z&amp;&amp;[^bc]匹配a到z，除了b和c[a-z&amp;&amp;[^m-p]] 匹配a到z，除了m到p 2.2预定义的字符类（默认匹配一个字符）： . （可能看不清，这是英文字符的点号）任何字符\d一个数字: [0-9]\D非数字: [0-9]\s一个空白字符: [\t\n\xoB\A\r]\S非空白字符: [A\s]\w[a-zA-Z_0-9] 英文、数字、下划线\W[a\w]一个非单词字符 2.3贪婪的量词（配合上面的规则可以匹配多个字符） X?X，一次或根本不X*X，零次或多次X+X，一次或多次X{n}X，正好辣n次X{n,}X，至少n次X{n,m}X，至少n但不超过m次 3.正则表达式在字符串方法中的使用 3.1按照正则表达式匹配的内容进行替换，返回一个新字符串 public String replaceAll(String regex,String newStr)
3.2按照正则表达式匹配的内容进行分割字符串，返回一个字符串数组 public Stringl] split(String regex)
4.利用正则表达式爬取内容 以下是一个简单的泛分析例子，一般的编写顺序都是依照以下顺序
public class RegexDemo05 { public static void main(String[] args) { //带匹配或者爬取的字符内容 String rs = "来学校hoaihfaooiasfjaio，电话020-43422424，或者联系邮箱"; //1.定义爬取规则，字符串形式 String regex = "\\w{1,30}|(400-?\\d{3,9}-?\\d{3,9})"; //2.把规则编译成匹配对象 Pattern pattern = Pattern.compile(regex); //3.得到一个内容匹配器对象 Matcher matcher = pattern.matcher(rs); //开始找 while(matcher.find()){ String rs1 = matcher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d65bfb8e2afbee489dea880145c508fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7027517ff3083cee56e6f5c97e933cc7/" rel="bookmark">
			微信小程序使用腾讯地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序使用腾讯地图 方法 第一步：登录或者注册腾讯地图官方（地址：https://lbs.qq.com/）
第二步：在创建sdk；
创建方法：进入控制面板后显示创建sdk，点击之后输入名称和选择应用场景后点击设置选择web和小程序后输入APPID后点击确定就好。
第二步：在微信小程序开发管理页面里面的域名管理里面输入合法域名：(https://apis.map.qq.com)就提交就可以。
第三步：在腾讯地图官方网站上下载相关的sdk 就可以。
第四步：在下载的压缩文件夹里面找到（qqmap-wx-jssdk.js）文件引入到相关页面。
引入方法：（index.js文件来描述）
// 引入进来腾讯地图的sdk var address = require('../../components/address/qqmap-wx-jssdk'); var myaddres; 使用方法：
第一步：
data: { adress:'未获取您的位置', }, /** * 提高腾讯地图来获取当前位置 */ AddressLocation(){ // new address 是获取上面的路径（var address = require('../../components/address/qqmap-wx-jssdk');） var myaddress = new address({ key: '4RQBZ-K6JA5-VKWIH-I6LK2-7NV53-UAFM2' }); myaddress.reverseGeocoder({ success: (res)=&gt;{ this.setData({ adress:res.result.address_reference.landmark_l2.title }) } }) let adress = this.data.adress }, /** 下面调用获取地址： */ onLoad: function (options) { var that = this; that.AddressLocation(); }, 效果图 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j9dUPTSw-1680339800754)(C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230401164948835.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7027517ff3083cee56e6f5c97e933cc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0a6e2955478abb0c262b9f797e1c472/" rel="bookmark">
			一致性利器-幂等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		幂等基本概念 幂等的数学概念 幂等是一种数学中的概念，其主要有两个定义：
如果在一元运算中， x x x为某集合中的任意数，如果满足 f ( x ) = f ( f ( x ) ) f(x) = f(f(x)) f(x)=f(f(x))，那么该 f f f运算具有幂等性，比如绝对值运算 a b s ( a ) = a b s ( a b s ( a ) ) abs(a) = abs(abs(a)) abs(a)=abs(abs(a))就是幂等性函数。如果在二元运算中， x x x为某集合中的任意数，如果满足 f ( x , x ) = x f(x,x) = x f(x,x)=x，前提是 f f f运算的两个参数均为 x x x，那么我们称 f f f运算也有幂等性，比如求大值函数 m a x ( x , x ) = x max(x,x) = x max(x,x)=x就是幂等性函数。 幂等在开发中的概念 在数学中幂等的概念或许比较抽象，但是在开发中幂等性是极为重要的。可以理解为，对于同一个系统，在同样条件下，一次请求和重复多次请求对资源的影响是一致的，就称该操作为幂等的。比如说如果有一个接口是幂等的，当传入相同条件时，其效果必须是相同的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0a6e2955478abb0c262b9f797e1c472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31fea9a15e32ce0d15f1719b8aa4cf68/" rel="bookmark">
			Leetcode 1200. Minimum Absolute Difference
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章作者：Tyan
博客：noahsnail.com | CSDN | 简书
1. Description 2. Solution **解析：**Version 1，先对数组排序，数字对的差值最小值一定出现在两个相邻的数字之间，遍历数组，依次计算两个相邻数字之间的差值，如果差值小于最小值，则将当前数字放入一个新的结果数组中，更新最小值，如果差值等于最小值，则将当前数字对放入到结果数组中，如果大于，则不进行任何操作。
Version 1 class Solution: def minimumAbsDifference(self, arr: List[int]) -&gt; List[List[int]]: arr.sort() res = [] min_value = float('inf') for i in range(len(arr)-1): diff = arr[i+1] - arr[i] if diff &lt; min_value: min_value = arr[i+1] - arr[i] res = [[arr[i], arr[i+1]]] elif diff == min_value: res.append([arr[i], arr[i+1]]) return res Reference https://leetcode.com/problems/minimum-absolute-difference/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5686dcbfe7f8cf70c893cd9922d667d8/" rel="bookmark">
			Leetcode 1984. Minimum Difference Between Highest and Lowest of K Scores
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章作者：Tyan
博客：noahsnail.com | CSDN | 简书
1. Description 2. Solution **解析：**Version 1，先对数组排序，K个数的最小差值一定出现在相邻的K个数中，每K个有序数，其最大的差值为两边的数字，依次遍历计算相邻K个数的差值，取最小值即可。
Version 1 class Solution: def minimumDifference(self, nums: List[int], k: int) -&gt; int: nums.sort() diff = nums[k-1] - nums[0] for i in range(0, len(nums)-k+1): diff = min(diff, nums[i+k-1] - nums[i]) return diff Reference https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1660d51b3a01912360355fa17e9e565e/" rel="bookmark">
			Leetcode 561. Array Partition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章作者：Tyan
博客：noahsnail.com | CSDN | 简书
1. Description 2. Solution **解析：**Version 1，先对数组排序，遍历数组，每两个数一组可以取得最大和，只统计第一个值。
Version 1 class Solution: def arrayPairSum(self, nums: List[int]) -&gt; int: nums.sort() res = 0 for i in range(0, len(nums), 2): res += nums[i] return res Reference https://leetcode.com/problems/array-partition/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d989b38782ccc45de1803367d8ff570/" rel="bookmark">
			Android super.img 镜像解包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在 Android 10 及更高版本上支持了"动态分区"，所以 ROM 包中看不到了传统的 system.img 等镜像。支持的动态分区包括：
SystemVendorProductSystem ExtODM 所以在 super.img 都可能包括以上分区的镜像文件。
具体信息可以查看官方文档 动态分区
声明 以下步骤环境均是 Linux 环境。
具体解包步骤 super.img 的解包必须两个工具 simg2img 和 lpunpack。其中 simg2img 可以在线安装，执行命令后可以按照提示自行安装即可。lpunpack 需要自己下载源码进行编译。lpunpack 生成后是通用的，所以下载别人编译好的 lpunpack 也是可以的，但是需要添加依赖的相关 so 库。注意工具和 so 库是配套的，请一起使用。不要自己混搭工具和 so 库。
下载好的 so 库文件放入 usr/lib/ 目录下即可也可以编辑 .bashrc 文件将 so 库所在目录路径加入到 LD_LIBRARY_PATH 中，命令如下
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库所在目录路径 关于库路径的添加有多种方式，不止上面两种，大家可以搜索相关资料，按照自己的喜好来。
1. 编译 lpunpack 工具 按照以下命令编译即可
source build/envsetup.sh make lpunpack 生成文件所在目录：out/host/linux-x86/bin
2. 将 super.img 从 Android sparse image 转换为 raw image 命令：simg2img SUPER_IMAGE OUTPPUT_FILE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d989b38782ccc45de1803367d8ff570/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd985d8cbabadbe3bec79936e1aa346/" rel="bookmark">
			【计算机毕业设计】201论坛系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统截图（需要演示视频可以私聊） 摘 要 如今的时代，是有史以来最好的时代，随着计算机的发展到现在的移动终端的发展，国内目前信息技术已经在世界上遥遥领先，让人们感觉到处于信息大爆炸的社会。信息时代的信息处理肯定不能用之前的手工处理这样的解决方法，必须采用计算机来处理这些信息，因为传统方法对应计算机处理的信息效率上真的相差甚远。
本次使用Java技术开发的论坛系统，就是运用计算机来管理论坛帖子信息，该系统是可以实现版主管理，新闻信息管理，论坛帖子管理，用户管理，留言版管理等功能。
论坛系统使用计算机处理相关信息，主要是在数据的传输上能达到即可传递，数据不管是想要获取或者输入，都可以及时反馈，极大的提高了效率，使用的MySQL数据库也能让数据更能安全的存储。
关键词：论坛系统；版主；帖子
目 录 摘 要 Abstract 第一章 绪论 1.1 研究背景 1.2 研究意义 1.3 研究内容 第二章 开发环境与技术 2.1 Java语言 2.2 JDK简介 2.3 Eclipse开发工具 2.4 Spring Boot框架 第三章 系统分析 3.1可行性分析 3.1.1运行可行性分析 3.1.2技术可行性分析 3.1.3经济可行性分析 3.2系统流程分析 3.3 系统性能分析 3.3.1系统的安全性 3.3.2系统易维护性 3.3.3系统可扩展性 3.4系统功能分析 第四章 系统设计 4.1界面设计原则 4.2功能模块设计 4.3数据库设计 4.3.1数据库E-R图 4.3.2 数据库表结构 第五章 系统实现 5.1 管理员功能实现 5.1.1 版主管理 5.1.2 用户管理 5.1.3 留言版管理 5.2 版主功能实现 5.2.1 论坛管理 5.2.2 新闻信息查看 5.2.3 个人信息 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecd985d8cbabadbe3bec79936e1aa346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef13ace741ebf7218235ef0c328f320a/" rel="bookmark">
			Nginx 代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优质博文：IT-BLOG-CN
一、正向代理（了解） 现实生活中客户端无法直接向服务端发起请求的时候 ，我们就需要代理服务器。正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径（例如：教学环境时，同学们使用的计算机就不能访问百度，只能通过老师的计算机作为代理服务器来获取信息）。正向代理还可以使用缓冲特性(由mod_cache提供)减少网络使用率。代理可以实现客户端与原服务器之间的通信，Nginx也可以实现相应的代理服务。
正向代理针对的是客户端，架构如下：客户端与代理服务器属于同一个LAN，对互联网透明。
二、反向代理 反向代理Reverse Proxy方式是以代理服务器来接收internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。正向代理是针对你的客户端，而反向代理是针对服务器的。反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。
【1】保证内网的安全，可以使用反向代理提供WAF（Web应用防护系统）功能，阻止web攻击大型网站，通常将反向代理作为公网访问地址，web服务器是内网。web服务器与代理服务器属于同一个LAN，对客户端透明。
【2】负载均衡，通过反向代理服务器来优化网站的负载
三、Nginx 的反向代理 【1】Nginx通过配置conf/nginx.conf文件中的proxy_pass属性，实现代理站点的配置（准备工作：启动一个Tomcat）
upstream proxy_test { #server 后配置需要代理的服务器地址 server 192.168.88.130:8080; } server { listen 80; server_name virtual.test.com; location / { #将上述 upstream 中配置的 server 名赋值到此处 proxy_pass http://proxy_test; index index.html; } } 【2】代理后，通过访问http://virtual.test.com/虚拟域名（需要配置本机的HOSTS文件），反向代理到Tomcat
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab52508eaaff539de18d9e15ef390c7f/" rel="bookmark">
			雪花算法-java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
👏作者简介：我是笑霸final，一名热爱技术的在校学生。
📝个人主页：个人主页1 || 笑霸final的主页2
📕系列专栏：计算机基础专栏
📧如果文章知识点有错误的地方，请指正！和大家一起学习，一起进步👀
🔥如果感觉博主的文章还不错的话，👍点赞👍 + 👀关注👀 + 🤏收藏🤏
目录 一、初识雪花算法二、为什么需要分布式id三、手写雪花算法3.1实现时间戳3.2 代码分析3.3整体代码 一、初识雪花算法 雪花（snowflake）:大自然中找不到几乎完全一样的雪花。
Snowflake，雪花算法是由Twitter开源的分布式ID生成算法，以划分命名空间的方式将 64-bit位分割成多个部分，每个部分代表不同的含义。
组成部分
第1位占用1-bit，是符号位通常不使用。第2位开始的41-bit是时间戳。可表示2^41个数，每个数代表毫秒 可表示69年。中间的10-bit位可表示机器数，即2^10 = 1024台机器。最后12-bit位是自增序列，可表示2^12 = 4096个数。 二、为什么需要分布式id 在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。
在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。如在美团点评的金融、支付、餐饮、酒店、猫眼电影等产品的系统中，数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求；特别一点的如订单、骑手、优惠券也都需要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。
三、手写雪花算法 实现雪花算法主要要实现3个数字
now 生成id的时间戳workId 机器编号id 一般分为 工作ID + 数据中心IDn 序列号(同一时间内生成的第几个id从0开始) 步骤
先获取当前毫秒时间戳比较当前时间戳和前一个时间戳如果时间戳相同 则序列号+1 如果不同 则序列号sequence=0 【注意范围】最后一次生成的时间戳更新为当前的时间戳。将当前时间戳左翼22位， 机器编码id左移12位 ，序列号用或运算拼接起来【左移 右边补0】 3.1实现时间戳 获取指定时间的时间戳
public class MyGetTime { public static void get() throws ParseException { // 创建一个日期格式化对象 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); // 设置指定的日期时间 String dateTime = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab52508eaaff539de18d9e15ef390c7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b387cfd378328f0df6028effeb0899e/" rel="bookmark">
			（六）大数据实战——hadoop集群实现免密登录和文件互传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本节内容我们主要介绍一下hadoop集群服务器之间实现免密登录和文件互传的功能，这样更加方便我们使用hadoop服务器实现服务器之间的相互登录和文件的相互传输。集群之间的访问不在需要授权就可以实现相互访问。
正文 SSH免密登录 ①分别在hadoop101、hadoop102、hadoop103的home目录下执行ssh命令
#生成ssh连接的公私钥 ssh-keygen -t rsa ②将hadoop101的免密公钥拷贝到自身服务器和hadoop02与hadoop103的服务器上，实现hadoop101免密登录自身服务器hadoop102与hadoop103服务器
命令：
#将公钥拷贝到hadoop101机器上 ssh-copy-id hadoop101 #将公钥拷贝到hadoop102机器上 ssh-copy-id hadoop102 #将公钥拷贝到hadoop103机器上 ssh-copy-id hadoop103 ③同上操作，在hadoop102也执行此项操作
④同上操作，在hadoop103上执行此项操作
⑤测试免密登录，hadoop集群之间实现互相访问
服务器之间文件互传 ①使用scp实现文件互传
#scp命令语法 scp -r $dir/$filename $user@$host:$dir/$filename # -r 递归 # $dir 要拷贝的文件路径 # $filename 拷贝文件的名称 # $user 目的地用户 # $host 主机地址 # $dir 目的地路径 # $filename 目的地文件名称 ② 使用rsync 远程同步工具实现文件共享
- rsync 主要用于备份和镜像。具有速度快、避免复制相同内容和支持符号链接的优点。
- rsync 和 scp 区别：用 rsync 做文件的复制要比 scp 的速度快，rsync 只对差异文件做更 新。scp 是把所有文件都复制过去。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b387cfd378328f0df6028effeb0899e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/562b872c8aa2ac934b41411c7d2041ab/" rel="bookmark">
			Linux系统中查看CPU或内存信息的常用指令：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、查看CPU信息： top：实时显示系统中各个进程的资源占用情况，包括CPU占用率、内存占用率等。htop：类似于 top，但是显示更为详细的信息，支持鼠标操作。cat /proc/cpuinfo：查看CPU的详细信息，包括CPU型号、主频、核数等。 2、查看内存信息： free：显示系统内存使用情况，包括空闲内存、已用内存、缓存等。top：实时显示系统中各个进程的内存占用情况，可以按照内存占用率排序。vmstat：显示系统的虚拟内存统计信息，包括内存、磁盘、CPU等。cat /proc/meminfo：查看内存的详细信息，包括总内存大小、空闲内存、缓存等。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7608837c0a7058be50dbc4d201e5f9a/" rel="bookmark">
			RocketMQ安装配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装配置jdk8 1.1将文件jdk-8u212-linux-x64.tar.gz上传到/root目录 1.2.解压缩jdk压缩文件 执行解压缩命令
# 将jdk解压到 /usr/local/ 目录
tar -xf jdk-8u212-linux-x64.tar.gz -C /usr/local/
# 切换到 /usr/local/ 目录, 显示列表, 查看解压缩的jdk目录
cd /usr/local
ls
1.3.配置jdk环境变量
修改 /etc/profile 配置文件, 配置环境变量
vim /etc/profile
# 在文件末尾添加以下内容:
export JAVA_HOME=/usr/local/jdk1.8.0_212
export PATH=$JAVA_HOME/bin:$PATH
修改完后,让环境变量立即生效
source /etc/profile
2.安装RocketMQ
2.1下载rocketmq二进制文件
Index of /apache/rocketmq (bit.edu.cn)
2.2解压缩rocketmq文件
rocketmq解压到/usr/local/目录
unzip rocketmq-all-5.1.0-bin-release.zip -d /usr/local/ # 修改一下文件夹名，改成 rocketmq 方便使用
mv /usr/local/rocketmq-all-4.7.0-bin-release /usr/local/rocketmq 2.3配置环境变量ROCKETMQ_HOME和PATH
vim /etc/profile
# 在文件末尾添加以下内容:
export ROCKETMQ_HOME=/usr/local/rocketmq
export PATH=$ROCKETMQ_HOME/bin:$PATH
修改完后,让环境变量立即生效
source /etc/profile
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7608837c0a7058be50dbc4d201e5f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce7700866e3be01087d1d372987dfafc/" rel="bookmark">
			【返回顶部】vue 实现返回顶部功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、返回顶部代码 methods:{ backTop(){ // 开个定时器返回顶部时缓慢优雅一些，是 document.documentElement.scrollTop = 0 的升级版 const timer = setInterval(() =&gt; { // 页面顶部卷去高度 let scrollTop = document.documentElement.scrollTop // 高度控速 = 页面顶部卷去高度正值 / n ===&gt; n 越大，返回越慢 let ispeed = Math.floor(-scrollTop / 5); // 页面顶部卷去高度 + 高度控速 ===&gt; 和不为零，定时器一直开启（不明白的同志可以尝试同时打印 scrollTop 和 ispeed） document.documentElement.scrollTop = scrollTop + ispeed; // 页面顶部卷去高度 + 高度控速 ===&gt; 和为零返回顶部，清除定时器 if (scrollTop === 0) { clearInterval(timer); } }, 20) } 二、隐藏返回标志 export default { name:'Up', data(){ return { showBtn:false, } }, mounted() { window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce7700866e3be01087d1d372987dfafc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eb818c04ad3b4660e416da5cacbeef8/" rel="bookmark">
			2022年全国职业院校技能大赛：网络系统管理项目-模块A-真题 卷I 全套视频讲解及无线地勘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 考试说明任务描述任务清单（一）基础配置（二）有线网络配置（三）无线网络配置（四）出口安全配置附录1：拓扑图附录2：地址规划表附录3：设备清单表 考试说明 安全操作：竞赛过程安全操作，注意赛位电源线位置，操作时不要碰到，及时
进行设备配置保存，以防误碰电缆导致设备断电配置丢失情况。竞赛成果物提交确认：评分将以各参赛队提交的竞赛提交物为主要评分依据。
请按照 U 盘中答题卡要求创建和编辑竞赛成果物，确保答题卡截图信息清晰完
整，并在竞赛结束时提交，所有提交的内容必须按照“竞赛成果物提交要求”
进行命名并签署《竞赛成果提交确认单》。离场要求：竞赛结束时，所有设备保持运行状态，不要拆掉网络连接。禁止将
竞赛用的所有物品（包括试卷和草纸）带离赛场。竞赛成果提交物：请在 U 盘根目录建立“竞赛成果物”文件夹，文件夹中包含
以下内容： 网络构建答题卡.pdf“设备配置”文件夹：文件夹内包含 4 个文本文档，按网络设备类型分别
存放交换、路由、无线、出口网关设备配置记录集，文件命名为：Switch.txt、
Router.txt、Wireless.txt、EG.txt。 任务描述 集团公司业务不断发展壮大，满足公司业务发展需要，集团公司决定建设北
京总部与各地分部的信息化网络。你做为网络工程师前往火星集团完成网络规划
与建设任务，最终目标为：
1. 北京总部局域网内互联互通；
2. 各地分部局域网内互联互通；
3. 北京总部通过运营商专线业务与各分部间互联互通；
4. 各地分部通过运营商专线业务实现分部间互联互通；
5. 各地分部统一通过总部运营商宽带业务访问互联网资源；
6. 总部与分部间互访数据安全加密；
7. 分部与分部间互访数据安全加密。
任务清单 （一）基础配置 1.根据附录 1 拓扑图、附录 2 地址规划表及附录 3 设备清单表，完成设备连线及
设备接口信息配置；
2.所有设备采用 SSH 认证，设定用户名:admin，密码：987321Aa,特权密
码:Admin123!，密码呈现需加密；
3.S5设备启用SNMPv3功能;用户名Admin!@#(隶属组test)，认证方式为sha2-256，
认证密码为 Test!@#，加密算法为 aes128，加密密码为 Test$#@!;安全级别为认证
加密模式 priv;用户 admin 对 MIB 具有读写权限;交换机能够主动向 SNMP 服务器
172.16.0.254 发送验证加密的消息。
（二）有线网络配置 1.局域网二层网络部署 RSTP 防环协议；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9eb818c04ad3b4660e416da5cacbeef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8245d6bbf4856f4b9762f246cf4c18dc/" rel="bookmark">
			Flutter Android 混合开发之使用 FlutterBoost 4.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜了下全网 FlutterBoost教程大都还是老版本，所有有了这篇。
当前使用环境 FlutterBoost 4.2.1
Flutter 3.3.4
首先根据官方文章集成 FlutterBoost FlutterBoost 集成详细步骤
接下来开始填坑之旅 坑一: 此段代码在使用中会报个什么map转换错误，具体忘了。。。
Map&lt;String, Object&gt; map = settings.arguments as Map&lt;String, Object&gt; ; 改为
Map&lt;String, dynamic&gt; map = settings.arguments as Map&lt;String, dynamic&gt;; 坑二: 此段代码当 routerMap[settings.name] 为 null 时，会报错：type 'Null' is not a subtype of type '(RouteSettings, String?) =&gt; Route&lt;dynamic&gt;' in type cast。
Route&lt;dynamic&gt; routeFactory(RouteSettings settings, String uniqueId) { FlutterBoostRouteFactory func = routerMap[settings.name] as FlutterBoostRouteFactory; return func(settings, uniqueId); } 改为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8245d6bbf4856f4b9762f246cf4c18dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5be8d92c1c149e601aa1bf18d22ef9/" rel="bookmark">
			JS自执行函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自执行函数有三种写法
( function ( “ 参数 ” ) { " 函数方法 " ; } ) ( “ 给参数传的值 ” ) ( function ( " 参数 " ) { “ 函数方法 ” ; } ( " 给参数传的值 " ) ) function ( " 参数 " ) { " 函数方法 " ; } ( " 给参数传的值 " )　举个例子
var res1 = (function a(a,b){ console.log(a+b)//函数体内部的语句立即执行 return a+b })(1,2) console.log(res1) // 3 获取函数a的返回值 var res2 = (function b(n){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe5be8d92c1c149e601aa1bf18d22ef9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1db162503b21d7ac1d2136aedc71eb4/" rel="bookmark">
			Vue中为什么不建议使用index作为key？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、key的作用是什么？ key的作用众所周知，看一个demo就知道：
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;ul id="app"&gt; &lt;li v-for="(item,index) in list" :key="index"&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; new Vue({ el: '#app', data() { return { list: [1, 2, 3] } } }) &lt;/script&gt; &lt;/body&gt; 在vue中key可以没有，没有也可以运行并且不会报错，但是建议加上key。
另外，我们必须知道，vue中key运用的地方------配合v-for使用。key是vue中虚拟dom标记的唯一标识，通过这个key，diff算法能更加准确和快捷。不使用key的情况下，因为vue的就地更新会选择复用节点，之前的状态被保存，可能会产生一系列的bug。另外，key的唯一性可以被map数据结构充分利用，时间复杂度仅为o（1）。
简单来说，key是唯一标识，为了让diff算法更准确的找到需要被对比的两个节点。
二、什么是虚拟DOM？ 虚拟DOM结构就是一个对象而已，其中描述了每一层容器的特征。在beroreCreated执行的时候，DOM树并没有生成。
虚拟DOM光说肯定是不可理解的，那我们就用代码说话：
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;item v-for="(num,index) in list" :key="index":num="num":class=`item${num}`&gt;&lt;/item&gt; &lt;/ul&gt; &lt;button @click="change"&gt;change&lt;/button&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: '#app', data() { return { list: [1, 2, 3] } }, methods: { change() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1db162503b21d7ac1d2136aedc71eb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba8bd694858dfac64ce24b401c344f2f/" rel="bookmark">
			【基于linux_C语言源码开发ftp客户端发送jpg图片到ftp服务器】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于linux_C语言源码开发ftp客户端发送jpg图片到ftp服务器 状态轮询函数ftp上传数据线程ftp源码下载点这~~ 状态轮询函数 这个函数会每毫秒轮询一次数组各值的状态这样能确保ftp同时发送图片数量为MAX_FTP_UPLOAD_NUM（确保不会因同时发送太多张图片导致cpu使用率过高） void ftp_CheckGroup() { int i = 0; pthread_mutex_lock(&amp;gFtpmutex); for(i=0; i&lt;MAX_FTP_UPLOAD_NUM;i++) { if(STATUS_WAIT == gftpfileinfo[i].uploadstatus) { if(0 == ftp_CreateUploadTask(&amp;(gftpfileinfo[i]))) { gftpfileinfo[i].uploadstatus = STATUS_UPLOADING; } else { printf("%s %d error! clear file[%s] from ftp group!\n", __FUNCTION__, __LINE__, gftpfileinfo[i].filename); memset(&amp;(gftpfileinfo[i]), 0, sizeof(stftpupload)); } } } EXIT: pthread_mutex_unlock(&amp;gFtpmutex); } ftp上传数据线程 void* mrecord_ftp_uploadthread(void* param) {	// pthreadinfo_add((char *)__func__); char* tmp; int sockfd; int ret = 0; char acFolder[32]={0}; char dstPath[32]={0}; char dstFile[32]={0}; stftpupload* pstftpupload = param; if(0 == strlen(pstftpupload-&gt;filename)) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba8bd694858dfac64ce24b401c344f2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dd381089902f0fc7bab35b584bf8ebe/" rel="bookmark">
			@alifd/next react&#43;form&#43;table组合式写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近前端大佬用@alifd/next来写后台管理系统，给我分配了一些页面类似下面的页面
其中分公司、存储地址、存储区三级联动。table中每一项都可以进行删除。添加按钮的弹框的页面类似下面这个样子。
点击弹框的行，多选，全选都可以进行更新到第一张图的页面
遇到的问题 怎么控制这个table变化呢，怎么进行，输入框单独可以操作，下拉框单独。如果对一个数据元进行来回更改，那么页面的消耗就很大。等等问题，下面就来例举几个吧 实现 之前看了一下官方的field关于类似方案的例子，发现写的比较简洁。也不好操作。所以我就尝试form+table组合式写法魔改了一下
1，利用form对table进行包裹，因为form内嵌了field,这样应该就比较方便一些。 const fieldTable = Field.useField(); //初始化fieldTable &lt;Form field={fieldTable}&gt; &lt;Table.StickyLock size="medium" primaryKey="id" // 识别的唯一值 fixedHeader maxBodyHeight={400} //和fixedHeader结合，设置table盒子的高度 dataSource={dataSource} //数据源 columns={columns} // 列表 rowSelection={rowSelection} // 选择每一行的操作，默认多选 /&gt; &lt;/Form&gt; 选择rowSelection设置
const [selectedRowKeys, setSelectedRowKeys] = useState([]); const [selectedRows, setSelectedRows] = useState([]); const rowSelection = { selectedRowKeys, onChange: (_selectedRowKeys, _selectedRows) =&gt; { // 单选时的操作 setSelectedRowKeys(_selectedRowKeys); setSelectedRows(_selectedRows); }, onSelectAll: (selected, _selectedRows) =&gt; { //全选时的操作 setSelectedRowKeys(_selectedRows.map((item) =&gt; item.cid)); }, getProps: (record) =&gt; { // 禁用的☑️的操作 return { disabled: mode === 'view', }; }, }; 2，对columns进行封装，（删除了几个重复类型的，大致能懂应该） const columns = [ // 新增/编辑用到的id，itemId，不显示但是可以区分（用是否有itemId来区分是点击编辑时拿到的数据，还是编辑时新增还是新增时新增的数据） { width: '0px', // 不会显示在页面 dataIndex: 'id', align: 'center', lock: 'left', cell: (value, index, record) =&gt; { return &lt;div style={{ display: 'none' }}&gt;{FormChildItem(value, index, record, 'id')}&lt;/div&gt;; }, }, { width: '0px',// 不会显示在页面 dataIndex: 'itemId', align: 'center', lock: 'left', cell: (value, index, record) =&gt; { return &lt;div style={{ display: 'none' }}&gt;{FormChildItem(value, index, record, 'itemId')}&lt;/div&gt;; }, }, { title: '类型', dataIndex: 'wirType', align: 'center', lock: 'left', cell: (value, index, record) =&gt; { return value ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dd381089902f0fc7bab35b584bf8ebe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd694c546be48e97221fe0118f4cac11/" rel="bookmark">
			如何将应用上传到TestFlight
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何将应用上传到TestFlight
将应用上传至TestFlight分为以下几个步骤
1.下载上传工具，mac直接可以下载Transporter（https://apps.apple.com/cn/app/transporter/id1450874784?mt=12），window可以下载Appuploader（http://www.applicatier.net）
2.申请开发者账号，制作Bundleid，P12证书、描述文件
3.用制作好的证书打包ipa文件
4.登陆Appstore Connect（https://appstoreconnect.apple.com）创建应用
5.使用上传工具上传应用
第一步 上传工具下载
Mac版本可以直接可以下载Transporter（https://apps.apple.com/cn/app/transporter/id1450874784?mt=12），Window版本可以下载AppUploader（http://www.applicatier.net）
第二步 证书制作
1.注册审核开发者帐号，必须使用苹果手机下载 Developer，选择账户-&gt;现在注册，使用当前手机登陆的appleid注册，期间需要人脸识别，需要支付688元年费
2.账户注册后，使用Mac电脑打开苹果开发者网站https://developer.apple.com（如果使用的是Windows，可以参考如何用WIndows申请苹果证书）,使用刚刚注册的账号登陆
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
苹果开发者账号
3.选择 iOS Distribution (App Store and Ad Hoc) 类型，导入钥匙串（有关如何申请钥匙串可以参考 如何申请苹果钥匙串），下载cer证书
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
选择证书类型
4.双击cer证书，将证书安装到钥匙串中，打开钥匙串工具，选择证书导出p12文件
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
导出p12文件
5.进入identifiers新建App IDs
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
新建appid
6.进入profiles 创建描述文件，选择Appstore类型，选择上一步的证书和Appid，点击下载描述文件
第三步 打包ipa
使用上一步创建好的证书打包应用，导出ipa格式的文件
Xcode导出的注意选择Appstore类型
​
编辑切换为居中
添加图片注释，不超过 140 字（可选）
appstore类型
第四步 创建应用
登陆Appstore Connect https://appstoreconnect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd694c546be48e97221fe0118f4cac11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/529b0529f7c285f321a13f35ffbe87e1/" rel="bookmark">
			嵌入式软件分析时间--基本概念(一)：编译过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.编译过程总览
2.编译阶段
2.1 预编译
2.2 编译
3.汇编阶段
4.链接阶段
在考虑优化嵌入式软件性能时，我们需要知道源代码是是如何成为可执行文件这一个过程。
1.编译过程总览 上图很明显，可以看到，编译过程粗略可分为编译、汇编、链接等三个阶段。
下面我们来分析每一个阶段具体干了些什么事。
源码main.c
#include "Demo.h" #define VALUE (1) uint8 TestFun(void) { uint8 TestValue = VALUE; return TestValue++; } void main(void) { uint8 a; while(1) { a = TestFun(); } } 头文件 Demo.h
#ifndef DEMO_H_ #define DEMO_H_ #include "stdint.h" typedef unsigned int uint8; #endif 2.编译阶段 2.1 预编译 编译器预处理器分析代码，解析所有宏（#define），读取全部头文件（#include），紧接着分析条件编译（#if...#else...#endif）删除非活动代码，计算所有可以计算的值，例如常数宏计算。
所有"#"开头的都作为预处理语句；
现在我们使用指定arm-none-eabi-gcc -E main.c -o main.i，把预编译出了文件输出如下：
.... # 10 "gcc\\arm-none-eabi\\10.3.1\\include\\stdint.h" 2 3 4 # 4 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/529b0529f7c285f321a13f35ffbe87e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69258d3696881689450f6fab97b72d97/" rel="bookmark">
			8 FFmpeg从入门到精通-FFmpeg接口libavformat的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 FFmpeg从入门到精通-FFmpeg简介
2 FFmpeg从入门到精通-FFmpeg工具使用基础
3 FFmpeg从入门到精通-FFmpeg转封装
4 FFmpeg从入门到精通-FFmpeg转码
5 FFmpeg从入门到精通-FFmpeg流媒体
6 FFmpeg从入门到精通-FFmpeg滤镜使用
7 FFmpeg从入门到精通-FFmpeg中Linux设备操作
8 FFmpeg从入门到精通-FFmpeg接口libavformat的使用
9 FFmpeg从入门到精通-FFmpeg接口libavcodec的使用
10 FFmpeg从入门到精通-FFmpeg接口libavfilter的使用
文章目录 8.FFmpeg接口libavformat的使用 8.1 音视频流封装 8.2 音视频文件解封装 8.3 音视频文件转封装 8.4 视频截取 8.5 avio内存数据操作 8.6 小结 8.FFmpeg接口libavformat的使用 libavformat是FFmpeg中处理音频、视频以及字幕封装和解封装的通用框架，内置了很多处理多媒体文件的Muxer和Demuxer，它支持如AVInputFormat的输入容器和AVOutputFormat的输出容器，同时也支持基于网络的一些流媒体协议，如HTTP、RTSP、RTMP等。
8.1 音视频流封装 使用FFmpeg的API进行封装（Muxing）操作的主要步骤比较简单，流程如图所示。
如图所示，几个重要的步骤已经罗列出来了，下面分别进行详细的讲解。
（1）API注册
在较新的版本已经弃用了。
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; extern “C” { #include &lt;libavutil/channel_layout.h&gt; //用户音频声道布局操作 #include &lt;libavutil/opt.h&gt; //设置操作选项操作 #include &lt;libavutil/mathematics.h&gt; //用于数学相关操作 #include &lt;libavutil/timestamp.h&gt; //用于时间戳操作 #include &lt;libavformat/avformat.h&gt; //用于封装与解封装操作 #include &lt;libswscale/swscale.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69258d3696881689450f6fab97b72d97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b40908193fedd10bfc7a34071af0c51/" rel="bookmark">
			CXO是什么？医药板块龙头都有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		制药行业是当今最复杂、监管最严格的行业之一。新药的开发，从最初的发现到最终的批准，是一个漫长而昂贵的过程，需要许多不同专业人士的专业知识。而制药公司面临的主要挑战之一是平衡创新需求与成本效率需求，面对这个挑战，就要说下CXO医药外包行业发挥的作用了，下面是笔者整理的有关CXO医药信息共大家参阅了解。
什么是CXO？什么是医药外包？
CXO是医药外包简称，医药外包是指聘请外部组织来执行某些职能，否则这些职能将由制药公司在内部执行。这些功能的范围从药物发现和开发到制造和分销。通过外包这些职能，制药公司可以降低成本、提高效率并专注于核心竞争力。
什么是CXO板块？
CXO板块是指开展医药研发和制造外包业务的上市公司，CXO企业为医药企业提供的从新药研发到生产的各类外包服务，起降本增效的作用。CXO是医药外包赛道的总称，所谓医药外包是指CXO企业为医药企业提供的从新药研发到生产的各类外包服务。
CXO医药外包行业有哪些？医药行业CXO龙头都有哪些？
CXO医药外包行业主要分为CRO、CMO/CDMO、CSO三个环节，分别服务于医药行业的研发、生产、销售三大环节，可简单理解为研发外包、生产外包、销售外包。CXO企业为医药企业提供的从新药研发到生产的各类外包服务。目前国内医药行业cxo龙头主要有药明康德、泰格医药、康龙化成、凯莱英等企业。这些企业在医药行业的研发、生产、销售等环节都有较强的实力和影响力，是医药行业的佼佼者。更多CXO龙头企业可通过下面提到的药融云医药投融资数据库进行搜索查询。
CXO医药外包的类型
有几种类型的医药外包，每种都有其自身的优势和挑战：
医药研发 (R&amp;D) 外包：此类外包涉及外包新药的发现、开发和测试。这可以包括从基础研究到临床试验的一切。
医药制造外包：这种类型的外包涉及外包药品的生产。这可以包括从配方到包装和标签的一切。
医药分销外包：这种类型的外包涉及外包药品的分销。这可以包括从仓储到运输的一切。
医药监管外包：此类外包涉及外包监管合规活动。这可以包括从监管策略制定到监管提交的所有内容。
CXO医药外包的好处
医药外包有几个好处，包括：
降低成本：外包允许制药公司通过利用外部组织的专业知识来降低成本。这可以节省劳动力成本、基础设施成本和设备成本等方面的成本。
获得专业知识：外包使制药公司能够获得外部组织的专业知识。这可以提高质量、效率和创新。
增加灵活性：外包使制药公司的运营更加灵活。这可以帮助他们更快地响应市场或监管环境的变化。
改善风险管理：外包使制药公司能够通过多样化供应商基础和利用外部组织的专业知识来更有效地管理风险。
CXO医药外包的挑战
医药外包也带来了一些挑战，包括：
质量控制：外包会使制药公司难以控制其产品的质量。这可能会导致产品安全性和有效性问题。
知识产权保护：外包会使制药公司难以保护其知识产权。这可能会导致专利侵权和竞争优势丧失等问题。
沟通：外包会给不同组织之间的沟通带来挑战。这可能会导致协调和协作方面的问题。
法规遵从性：外包可能会对法规遵从性造成挑战。制药公司必须确保其外包合作伙伴遵守所有相关法规。
CXO 在医药外包中的作用
CXO 在确保医药外包计划取得成功方面发挥着关键作用。CXO 的一些主要职责包括：
战略制定：CXO 负责制定公司的整体外包战略。这涉及确定哪些功能应该外包，哪些应该保留在内部。
合作伙伴选择：CXO 负责选择外包合作伙伴。这涉及根据专业知识、成本和文化契合度等因素评估潜在合作伙伴。
合同谈判：CXO 负责谈判外包合同。这包括确保合同公平、公正并符合公司的目标。
绩效监控：CXO 负责监控外包合作伙伴的绩效。这涉及设置性能指标和进行定期审计。
风险管理：CXO 负责管理与外包相关的风险。这涉及识别潜在风险并制定减轻风险的策略。
CXO医药外包的最佳实践
为确保医药外包计划的成功，公司应遵循多项最佳实践，包括：
制定强大的外包战略：公司应制定符合其总体业务目标的强大外包战略。
选择合适的合作伙伴：公司应根据专业知识、成本和文化契合度等因素仔细评估潜在的外包合作伙伴。
谈判公平的合同：公司应该谈判公平的合同，以保护他们的利益，同时也为外包合作伙伴提供价值。
监控绩效：公司应定期监控外包合作伙伴的绩效，以确保他们达到绩效指标。
管理风险：公司应识别与外包相关的潜在风险，并制定减轻这些风险的策略。
医药行业除了CXO还有哪些？如何找到种子、天使投资机会？
药融云的投融资数据库无疑是医药行业的投资利器，将涉及面十分宽广的医药行业分为了65种概念、72个技术方向、168个应用场景、189个细分领域，能快速找到投资机会。
如72个技术方向就包括了3D打印、5G、AR、CT、DR、MRI、OCT 、POCT 、RPA、VR、Wifi、靶向技术、病理图像、仓储技术、超声、传感器、传输技术、纯化技术、存储技术、蛋白技术、分子诊断、服务机器人、辅助机器人、干细胞技术、核酸技术、核酸检测、合成生物学、基因编辑、基因工程、基因合成、基因技术、基因检测、机器人、机器学习、计算机视觉、康复机器人、抗黄/抗病违技术、可穿戴技术、冷藏、酶学工艺、免疫技术、免疫诊断、脑机接口、内窥镜、区块链、人工智能、人机交互、深度学习、生产技术、生化诊断、生物技术、手术机器人、体外诊断、外骨骼机器人、腕式可穿戴、微流控、微生物/病毒技术、微生物诊断、物联网、物流机器人、细胞技术、心电监测、心率传感器、血压传感器、液体活检、医学影像技术、移动支付、影像FFR、语音识别、运动传感器、智能硬件、自然语言处理等。
图片来源：药融云-医药投融资数据库 如何全面分析CXO医药外包企业？
通过药融云投融资数据库分别搜索CRO、CMO、CDMO、CSO，找出各领域的CXO企业，再用药融云-上市医药企业年报数据库，找到目标企业历年的年报数据库，分析了解企业的财务状况、经营情况、发展战略等信息。
图片来源：药融云-上市医药企业年报数据库
综上，医药外包为制药公司带来了显着的好处，包括节省成本、获得专业知识、提高灵活性和改进风险管理。然而，外包也带来了一些挑战，包括质量控制、知识产权保护、沟通和法规遵从性。CXO 在确保医药外包计划成功方面发挥着关键作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8878c3cad867ba37c2dcc14b364df0c/" rel="bookmark">
			Unity 场景鼠标移动、旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections;
using System.Collections.Generic;
using UnityEngine;
public class CameraMove : MonoBehaviour
{
private Camera mainCamera;
private Transform cameraTrans;
private int xAxisCoefficient = 1;
private int yAsixCoefficient = 1;
private string _mouseXString = "Mouse X";
private string _mouseYString = "Mouse Y";
private string _mouseScrollWheel = "Mouse ScrollWheel";
private Vector3 _currentMouseRotate = Vector3.zero;
public float fieldOfViewMin = 20.0f;
public float fieldOfviewMax = 100.0f;
public float moveSpeed = 3;
public float sensitivityDrag = 1;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8878c3cad867ba37c2dcc14b364df0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d79e36b4c0b41e6c5bd6abf14defa95/" rel="bookmark">
			UE4/UE5 Runtime下的Mesh合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，转载请注明出处。
StaticMesh的合并 前言类图Editor下的实现Runtime下的实现难点1，StaticMesh的RenderData转FMeshDescription难点2，StaticMesh构建复杂碰撞难点3，多Section的StaticMesh合并之后材质出错 插件封装，现有功能介绍以及后续计划参考文章 前言 引擎版本：4.27.2
合并的前提：在UE4.26.2之后，允许了在运行时构建UStaticmesh。之前的方式只支持编辑器下导入，
导入后转成UStaticMesh的RenderData进行渲染；
为什么要做合并：
需求的来源是软件我们想利用UE4.27.2的runtime下的udatasmith导入功能，
但是因为datasmith的设计初衷呢就是尽可能小的拆分模型，粒度很小。
所以有的udatasmith导入后会在关卡中有上万个，帧率极低。
所以才会有了该篇文章 在运行时来合并StaticMesh。
合批的优化方案如下
其实这里面是有很多可以做合批的。
所以，这里我就针对udatasmith导入这个功能，研究了一下合批的方案；
方案优点缺点1&gt;修改datasmith导入部分插件的代码效率最高不易维护2&gt;自己做一套效率低于方案1，易维护易维护3&gt;修改datasmith的导出插件不确定不易维护 使用哪一种方案？
方案1来讲的话，改DataSmith的源码，效率我认为是最好的。
为什么：
首先说方案1的做法：在一个个的actor还没有spawn，mesh还没有build，collsion，材质等这些信息还没有build之前， 我们提前过滤好哪些Mesh可以被合并，之后再spawn MeshActor，build StaticMesh的vertex，collision，material。
再说方案2的做法：所有的actor已经在世界中spawn出来了，StaticMesh的vertex，collision，material这些信息都已经build好了。再去过滤好哪些Mesh可以被合并，之后再spawn MeshActor，build StaticMesh的vertex，collision，material。
暂时实现了方案2
对比看的话，方案1是要比方案2效率高的。但方案1改起来比较麻烦，并且我认为不容易维护。看了一天之后，我先实现了方案2。
视频效果：Merge之后的帧率和DC明显提高跳转观看
UE4/UE5 Runtime下合并Mesh
类图 Editor下的实现 参考MergeActor Tool
利用编辑器下的MergeActorTool工具的功能，很快就能在编辑器下实现合并的逻辑。Standlone下也可以合并。
但是需要注意的是这个只能在编辑器下用，打包就歇菜。
编辑器下合并具体的代码如下，作为参考：
//编辑器下的合并方法 void UMyBlueprintFunctionLibrary::MergeMy(const TArray&lt;UPrimitiveComponent*&gt;&amp; ComponentsToMerge, UWorld* World, const FMeshMergingSettings&amp; InSettings, UMaterialInterface* InBaseMaterial, UPackage* InOuter, const FString&amp; InBasePackageName, TArray&lt;UObject*&gt;&amp; OutAssetsToSync, FVector&amp; OutMergedActorLocation, const float ScreenSize, bool bSilent /*= false*/, FString AppendName) { const IMeshMergeUtilities&amp; MeshUtilities = FModuleManager::Get().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d79e36b4c0b41e6c5bd6abf14defa95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e037009fb1c59265f9d87c2e60afb0d9/" rel="bookmark">
			【git】git stash详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【git】git stash详解 应用场景： 当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。
由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。
总的来说，git stash命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。
命令详解： 1 git stash 能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。
$ git status On branch master Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: src/main/java/com/wy/CacheTest.java modified: src/main/java/com/wy/StringTest.java no changes added to commit (use "git add" and/or "git commit -a") $ git stash Saved working directory and index state WIP on master: b2f489c second $ git status On branch master nothing to commit, working tree clean 2 git stash save 作用等同于git stash，区别是可以加一些注释，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e037009fb1c59265f9d87c2e60afb0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09bb789672878dd8434096a613e3304b/" rel="bookmark">
			【hive】时间相关函数的使用（时间戳函数unix_timestamp()/from_unixtime()、日期处理函数datediff()/date_sub()/date_add()等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、时间戳函数1、unix_timestamp()2、from_unixtime()3、unix_timestamp()与from_unixtime()结合使用总结 二、日期处理函数1、date_format()2、date_sub()3、date_add()4、datediff()5、last_day()6、next_day()7、add_months()8、其他相关函数总结 一、时间戳函数 1、unix_timestamp() unix_timestamp() 无参数调用，获取当前系统时间戳为10位的bigint类型数值，该数值只精确到秒。 select unix_timestamp(); &gt; 1680227307 unix_timestamp(string timestamp) 输入格式默认为“yyyy-MM-dd HH:mm:ss”，如不符合则返回null。 select unix_timestamp('2023-03-31 01:48:27') ; &gt; 1680227307 select unix_timestamp('2023-03-31'); &gt; NULL unix_timestamp(string date,string pattern) 将指定时间格式的字符串转化成时间戳，如不符合则返回null。 --固定日期转换成时间戳 select unix_timestamp('2023-03-31','yyyy-MM-dd'); &gt; 1680220800 select unix_timestamp('2023-03-31 01:48:27','yyyy-MM-dd HH:mm:ss'); &gt; 1680227307 select unix_timestamp('2023-03-31T10:02:41Z', "yyyy-MM-dd'T'HH:mm:ss'Z'"); &gt; 1680256961 select unix_timestamp('2023-03-31','yyyy-MM-dd HH:mm:ss') &gt; NULL unix_timestamp() - unix_timestamp()是两个时间转换为timestamp之后相减，timestamp单位是秒，相减之后是两个时间之间相差的秒数。 cast((unix_timestamp() - unix_timestamp()) % 60 as int) --是相差的秒数。
cast((unix_timestamp() - unix_timestamp()) / 60 as int) % 60 --是相差的分钟数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09bb789672878dd8434096a613e3304b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cda94bd389ec8ae5969124b98e35bf6c/" rel="bookmark">
			python实现用递归求最大公约数和最小公倍数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.最大公约数 def gcd(a,b): if a &lt; b: a , b = b, a if b == 0: return a else: gcd(b, a%b) 2.最小公倍数 有意思的时，最小公倍数 = 两个数相乘 / 最大公约数
def lcm(a, b): if a &lt; b: a, b = b, a c, d = a, b while d != 0: c, d = d, c % d #这里求的是最大公约数 return (a * b) // c # 两个数的乘积等于这两个数的最大公约数与最小公倍数的乘积。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f209a165d954c7e17b3f170a5f9c2b81/" rel="bookmark">
			多线程入门基础学习（超简单）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 多线程是java语言中最重要的一个知识点，重要到什么程度呢，可以说这是大家以后找工作面试时必定问的知识点。各种锁，各种线程并发与并行，常常让大家感觉脑瓜子疼。下面让我带领大家学习一些多线程的基础关键知识，让大家明白什么是多线程，并且会运用多线程，开启多线程的启蒙课。（注：本文只是多线程知识的基础入门学习，多线程的知识内容要写的话完全可以写成一本书）
一，线程是什么 说到程序，想必每个人都听说过，但是如果我问你：程序是什么？你该如何回答呢？想必一时半会表达不出来吧。所谓的程序用我们程序员的话来说就是一段静态的代码，静态对象。而正在运行的程序，或者说程序的一次执行过程，这种动态的过程就叫做进程。接下来让我们把进程进一步的划分，就是线程了。
线程可以说是进程的进一步细化，指的是程序内部的一条执行路径，一个进程中的多个线程共享相同的内存单元/内存地址空间—&gt;简单来说就是他们从同一堆中分配对象，可以访问相同的变量和对象。
那么java程序最少就几个线程呢？两个，分别是：
JVM GC垃圾回收机制（守护线程/后台线程）main 线程/main 线程组 二，创建新的线程方式 其实我们经常用的main()方法，他就是一个线程，准确的来说他是主线程
方式一： 写一个类继承Thread类，并且重写Thread类的run()方法 public class MyThread extends Thread{ @Override public void run () { System.out.println ("一个新的线程启动了"); } } 创建一个线程对象，并且这个对象调用start()方法 public class MyThread extends Thread{ @Override public void run() { System.out.println("一个新的线程启动了"); } public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); } } 运行结果如下
为什么调用start()方法，会运行run()方法 看到这里，你可能会纳闷：为什么调用的是start()方法，但是run()方法却被运行了。我门可以看一下start()方法的源码说明，可以知道start()就是一个开关，当我们打开它，JVM会自动调用run()方法。
那么我们可以不以直接调用run()方法呢？答案肯定是不可以，如果我们直接调用他，实际运行这个方法的就是主线程main了。我们可以写个代码验证一下
public class MyThread extends Thread{ @Override public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f209a165d954c7e17b3f170a5f9c2b81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ffe63fdd92329e436f746ed1d7e134/" rel="bookmark">
			JDBC方法封装：各种封装，带你体验封装的魅力
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们知道，JDBC就是java后台连接数据库的纽带，当这个纽带连接上后，我们可以使用java语句去操控数据库信息，这个系统化的连接方式我们经常会使用，如果每次都要重写一遍那么多行代码，未免太麻烦了，因此，可以写一个方法，方法体就是获得一个Collection实例，而不仅仅是获取连接可以封装，任何经常写的代码都可以封装。在需要使用他的时候只需要调用某个方法就能快速得到我们想要的数据简化代码，提高代码复用性。
一，封装getCollection方法 有个jdbc.properties文件，里面存储着驱动地址，url，username，password，如何获得该文件的这些创建Collection实例必备的信息，来获得连接呢
jdbc.properties文件位置在src目录下，或者resources资源目录下，jdbc.properties文件内容如下
driverClass=com.mysql.jdbc.Driver jdbcUrl=jdbc:mysql://localhost:3306/gp_01?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false username=root password=123456 public class JdbcUtils { private static String driverClass; private static String url; private static String username; private static String password; //静态代码块，静态代码块在类文件加载阶段一定执行！！！并且有且只执行一次，用于程序初始化，预处理操作 static { //1.获取properties文件 //JdbcUtils.class 反射知识，获得Class实例，即JdbcUtils类 //getClassLoader() 获得类加载器 InputStream resourceAsStream=JdbcUtils.class.getClassLoader().getResourceAsStream("jdbc.properties"); //2.创建Properties实例，底层是Map键值对存储 Properties properties = new Properties(); //3.加载properties文件 try { properties.load(resourceAsStream); } catch (IOException e) { e.printStackTrace(); } //4.将properties中的有效值提取出来 driverClass = properties.getProperty("driverClass"); url = properties.getProperty("jdbcUrl"); username = properties.getProperty("username"); password = properties.getProperty("password"); //5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ffe63fdd92329e436f746ed1d7e134/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97de14edda1a125a981df79fa46b941d/" rel="bookmark">
			GIS开发二：批量下载和拼接地图瓦片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、简介1.1 Web墨卡托投影1.2 经纬度坐标系1.3 瓦片定义1.4 瓦片编号1.5 瓦片和像素 1.6 瓦片计算公式1.7 网络地图服务（WMS）1.8 切片地图服务（TMS）1.9 切片地图web服务（WMTS）1.10 比例尺 2、地图瓦片数据源3、代码实现4、运行结果4.2 输出中国图4.3 输出局部图 1、简介 1.1 Web墨卡托投影 墨卡托投影，是正轴等角圆柱投影，又称等角圆柱投影，圆柱投影的一种，由荷兰地图学家墨卡托（G. Mercator）于1569年创拟。为地图投影方法中影响最大的。
用一张纸卷成圆柱，围住地球仪；然后在地球仪的球心放一个发光的灯泡，地球仪上的地图会在圆柱纸上形成投影；把这张纸平展开，就是我们常见平面世界地图。上面所讲的投影法叫墨卡托投影（Mercator Projection）。
地图学是一门严谨的科学，需要数学模型和精确的公式计算，再做近似处理，墨卡托投影数学模型如下：
当然，地形面积按墨卡托投影投射到平面后是有一定变形的，纬度越高，也就是越靠近两极变形越大。
Web墨卡托投影（又称球体墨卡托投影）是墨卡托投影的变种，它接收的输入是Datum为WGS84的经纬度，但在投影时不再把地球当做椭球而当做半径为6378137米的标准球体，以简化计算。
Web墨卡托取得了巨大成功，如今主流的Web地图几乎都是使用的Web墨卡托，如国外的 Google Maps，OpenStreetMap，Bing Map，ArcGIS 和 Heremaps 等，国内的百度地图、高德地图、腾讯地图和天地图等也是基于Web墨卡托（由于国内政策的原因，国内地图会有加密要求，一般有两种情况，一种是在 Web墨卡托的基础上经过国家标准加密的国标02坐标系，熟称“火星坐标系”；另一种是在国标的02坐标系下进一步进行加密，如百度地图的BD09坐标系）。
Web墨卡托投影还切掉了南北85.051129°纬度以上的地区，以保证整个投影是正方形的。Web墨卡托坐标系是非常适合显示数据，但是不适合存储数据的，通常我们使用WGS84 存储数据，使用Web墨卡托显示数据。
WEB GIS中常用的坐标系一般有两种，一种是以经纬度表示的WGS84坐标系（EPSG:4326），另一种为主流WEB地图厂商使用的WEB墨卡托投影（EPSG:3857）
Web墨卡托投影有两个相关的投影标准，经常搞混：
EPSG4326：Web墨卡托投影后的平面地图，但仍然使用WGS84的经度、纬度表示坐标；EPSG3857：Web墨卡托投影后的平面地图，坐标单位为米。 X and Y：
X goes from 0 (left edge is 180 °W) to 2zoom − 1 (right edge is 180 °E)Y goes from 0 (top edge is 85.0511 °N) to 2zoom − 1 (bottom edge is 85.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97de14edda1a125a981df79fa46b941d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7917ea489d18fb9baa260e8726404358/" rel="bookmark">
			Android Studio 修改代码不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在撸代码的时候发现一个奇怪的问题，修改代码并且保存后点击运行App，发现修改的代码未生效，网上搜了各种方法并未生效，后来尝试勾选这两个才可以，必须两个都勾选
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cec682f8d8fc9b2fb3cb93bdea135de/" rel="bookmark">
			postgresql pg_rewind 类似oracle的flashback&#43;基于scn的恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL 在操作的过程中，如果利用物理复制的过程中，另一台从库，或者主库由于某些原因，不再与主库同步，或者主库crash 起不来了，怎么办，如果在利用现在的主库或备库，弄出一个 twins 。
其实PG 早就想到这个问题了，PG有一个独特的命令 pg_rewind 可以帮助你，再造一个你。
我们看看pg_rewind能帮我们什么
pg_rewind 的工作原理有点类似rsync，它可以无缝的读取源目录与目的目录之间不同的数据块，而重复的数据块将不再被读取。这样的方式其实对于上面的问题是一个好的解决方案，因为如果主从复制，任何一方坏了，使用PG_REWIND 可以快速将你认为的数据完全的一方的数据同步到另一方，而不用做全量复制，这样最大的好处就是节省了时间。
当然如果大概率知道checksum的（包括MYSQL的binlog checksum ）大多可以想到，怎么知道这两边的数据是否一致，必须的校验块，postgresql 如果要使用pg_rewind 功能需要你做以下的一些设置
1 full_page_writes = on
2 wal_log_hints = on
3 hot_standby = on
4 如果你在初始化数据库集群（postgresql 单机也叫数据库集群，别和真正的集群的含义搞混）做了data checksum 也是可以的。
其主要的工作原理，在目的集群中对比源，与目的端之间的不同点，就是什么时候两个服务器之间的数据开始不同步的。通过知道这些不同点开始进行
1 使用文件系统的方式进行拷贝
2 使用libpq 建立连接的方式将数据进行拷贝
在拷贝数据文件的以外还需要拷贝事务提交的文件，pg_xact 以及配置文件等等。生成backup label 文件，并且指定开始要恢复的 wal 日志点，并应用恢复点以后的日志，并且还要刷新 pg_control 文件（在设置了检查点并刷新日志之后，检查点的位置将保存在文件pg_control中）,最后执行initdb -S 将数据刷入到磁盘后，关闭。
问题1 ，PG_REWIND 怎么识别两台PG 是曾经为primary 和 standby的管理
其实就是通过 database system identifier 来鉴别，同样的主从的 database system identifier 的编码是一致的。同时也要看version 与 catalog version number 是否一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cec682f8d8fc9b2fb3cb93bdea135de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b409b56ce425b049ef131435022c644a/" rel="bookmark">
			Python:基于Python爬虫技术的抢票程序及其实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		临近放假，相信我们每天都在群聊里或者朋友圈看到一些帮忙抢火车票的信息。看到朋友们抢回家的车票这么辛(bei)苦(can)，结合圈里一些前辈的指点，抱着学习的心态用Python做了一个简单的自动化抢票程序，抢到票之后通过绑定的邮箱（比如QQ）发通知。下面分享主要内容：
版本号 Python 3.6.5
编译器 PyCharm PRO 2018.1
浏览器 Google Chrome 71.0.3
首先，我们用到一个Splinter库：
相信做自动化测试、自动化爬虫的朋友都知道Selenium工具，它可以把人为驱动行为转化为机器执行，Splinter的药效跟它是一样的。我们可以进去cmd后用 pip install splinter
这个命令来安装。
然后，开始使劲地码：
1. 定义自动购票的类（初始化属性）
class Buy_Tickets(object): # 定义实例属性，初始化 def __init__(self, username, passwd, order, passengers, dtime, starts, ends): self.username = username self.passwd = passwd self.order = order # 车次，0代表所有车次 self.passengers = passengers # 乘客名 self.starts = starts # 起始地和终点 self.ends = ends self.dtime = dtime # 日期 self.login_url = 'https://kyfw.12306.cn/otn/login/init' self.initMy_url = 'https://kyfw.12306.cn/otn/view/index.html' self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b409b56ce425b049ef131435022c644a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd80116d930847e515caa49437578c7d/" rel="bookmark">
			ffmpeg-源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言编译便于调试、学习、分析ffmpeg、模块共享库调用API-获取MOV文件信息1.avformat_open_input分析2.avformat_find_stream_info分析3.av_dump_format分析4.avformat_close_input分析 调用API-分离MOV文件1.avcodec_find_decoder分析2.avcodec_get_name分析3.av_read_frame分析4.av_packet_unref分析 调用API-解码MOV文件1.avcodec_alloc_context3分析2.avcodec_parameters_to_context分析3.avcodec_open2分析4.av_frame_alloc分析5.avcodec_send_packet分析h264_decode_frame分析（不在显示调用API中）6.avcodec_receive_frame分析7.av_frame_unref分析8.av_frame_free分析9.最后将原始数据写入到文件 调用API-编码YUV文件ffmpeg对内存的释放处理 添加滤镜 前言 本文只是分析FFmpeg执行流程并不具有教学意义，都是以笔记形式记录，所得结论并不严谨，教学系列原理找官网。
面向源码学习FFmpeg框架：
为了方便调用ffmpeg api需要使用静态编译ffmpeg，一般开发大多数都是动态库为了节省应用内存，也有全静态的场景（嵌入式设备），就静态库 build/lib/libavcodec.a而言大小就有300+M
编译后的头文件、动态库都放在源代码工作路径，方便管理，但是需要手动的添加头文件、链接库、动态\静态链接执行库。
觉得麻烦可以直接将make install安装到默认用户环境目录下,在下面脚本中去掉--prefix=$(pwd)/build \参数就可以了。
编译便于调试、学习、分析ffmpeg、模块共享库 该脚本编译模块库为静态库，ffmpeg为静态链接，使用版本：4.2.2。仅适用于学习、调试FFmpeg API
#!/bin/bash ScriptVersion="1.0" unset file unset directory ff_version="ffmpeg-4.2.2" ff="${ff_version}.tar.bz2" static=1 shared=0 main(){ confirmation_info download_ffmpeg if [ "$static" == "1" ];then fetch_x264_static elif [ "$shared" == "1" ];then #Install x264 x265 depend(shared library) #apt install libx264-dev libx265-dev read -p "Are you already installed libx264-dev?[Y/n]" ok if [ "$ok" == "n" ];then exit;fi else exit fi build_ff } confirmation_info(){ local tips="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd80116d930847e515caa49437578c7d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/158/">«</a>
	<span class="pagination__item pagination__item--current">159/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/160/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>