<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d420a750586a54247a4b2ed3f342fcb/" rel="bookmark">
			文本数据导入HBASE库找不到类com/google/common/collect/Multimap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本数据导入HBASE库找不到类com/google/common/collect/Multimap 打算将文本文件导入HBASE库，在运行命令的时候找不到类 com/google/common/collect/Multima [hadoop@hadoop1 lib]$ hadoop jar /home/hadoop/hbase-0.94.6/hbase-0.94.6.jar importtsv Warning: $HADOOP_HOME is deprecated. Exception in thread "main" java.lang.NoClassDefFoundError: com/google/common/collect/Multimap at org.apache.hadoop.hbase.mapreduce.Driver.main(Driver.java:43) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.apache.hadoop.util.RunJar.main(RunJar.java:156) Caused by: java.lang.ClassNotFoundException: com.google.common.collect.Multimap at java.net.URLClassLoader$1.run(URLClassLoader.java:366) at java.net.URLClassLoader$1.run(URLClassLoader.java:355) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:354) at java.lang.ClassLoader.loadClass(ClassLoader.java:423) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) at java.lang.ClassLoader.loadClass(ClassLoader.java:356) ... 6 more 后来将$HBASE_HOME/lib下的包 guava-11.0.2.jar 复制到 $HADOOP_HOME/lib 下， 问题搞定。 [hadoop@hadoop1 lib]$ pwd /home/hadoop/hadoop-1.0.4/lib [hadoop@hadoop1 lib]$ cp /home/hadoop/hbase-0.94.6/lib/guava-11.0.2.jar . [hadoop@hadoop1 lib]$ hadoop jar /home/hadoop/hbase-0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d420a750586a54247a4b2ed3f342fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1c559433231e46c94f92c1ec9440a1c/" rel="bookmark">
			BufferedOutputStream和ByteArrayOutputStream区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自http://z276356445t.iteye.com/blog/1955400
也有一部分是自己加上去的，以备后用。
众所周知BufferedOutputStream是一个缓冲数据输出流接口, ByteArrayOutputStream则是字节数组输出流接口. 这2个输出流都是我们经常用到的, 它们都是OutputStream的子类,而什么时候选择用它们呢, 这个就要看你运用到什么应用场景下了. 下来先来看下源码吧. 1.BufferedOutputStream会首先创建一个默认的容器量, capacity = 8192 = 8KB, 每次在写的时候都会去比对capacity是否还够用, 如果不够用的时候, 就flushBuffer(), 把buf中的数据写入对应的outputStream中, 然后将buf清空, 一直这样等到把内容写完. 在这过程中主要起到了一个数据缓冲的功能. Java代码 public synchronized void write(byte b[], int off, int len) throws IOException { // 在这判断需要写的数据长度是否已经超出容器的长度了,如果超出则直接写到相应的outputStream中,并清空缓冲区 if (len &gt;= buf.length) { flushBuffer(); out.write(b, off, len); return; } // 判断缓冲区剩余的容量是否还够写入当前len的内容,如果不够则清空缓冲区 if (len &gt; buf.length - count) { flushBuffer(); } // 将要写的数据先放入内存中,等待数据达到了缓冲区的长度后,再写到相应的outputStream中 System.arraycopy(b, off, buf, count, len); count += len; } flushBuffer () 这个方法干了些什么呢, 来看看源码 Java代码 private void flushBuffer() throws IOException { if (count &gt; 0) { // 把写入内存中的数据写到构造方法里传入的OutputStream句柄里, 并把容量大小清楚 out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1c559433231e46c94f92c1ec9440a1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e136010798764ba28afcca6ac31ec0f3/" rel="bookmark">
			后缀树与最长回文子串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后缀树与最长回文子串
最长回文子串的问题: 回文串:正反一样的字符串.
如ABCDCBA,反过来是还是ABCDCBA.
回文子串:DABCAEA中有两个回文子串(不包括长度为1的),即ABCA,AEA.
长度ABCA&gt;AEA.
那么字符串DABCAEA的最长回文子串就是ABCA.
解决方法:
1. 遍历所有的子串.
长度N的字符串,共有2^N个子串,去除长度为0,1的,也有2^N-N-1个.遍历的时间复杂度是O(2^N),还要加上判断是否回文的函数.
2. 以某个字符为中心,向两边扩散寻找.
当某个字符为中心较短的子串不满足要求时,其更长的子串也不可能满足要求,减少了遍历算法中许多不必要的计算.
时间复杂度为O(N^2).
3. 后缀树
后缀树是解决许多字符串问题的利器.下面介绍后缀树.
Trie Trie树,又称字典树,单词查找树或者前缀树,是一个用于快速检索的多叉树. 典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计(@july)。如英文字母的字典树是一个26叉树,数字的字典树是一个10叉树.
Trie利用字符串的公共前缀来节省存储空间,并且能够以空间换时间.
盗用别人的一张图, 给出一组单词，inn, int, at, age, adv, ant, 我们可以得到下面的Trie：
根据上面的trie,我们可以
1. 计算任意某两个单词的最长公共前缀,就是我们待会要详细说明的LCA算法.
2. 快速计算某个单词的出现次数.也就是我们上面说的以空间换时间的方法,建树与查询同时进行,每次根据单词查询或新建节点,计数.时间复杂度为O(N*length),length表示字符串的平均长度.
后缀树 我们再通过trie,即前缀树,来引出后缀树.
后缀的含义:
对于字符串XMADAMYX,他的后缀是从后往前数的任意连续序列,如X,YX，MYX．．．XMADAMYX等都是其后缀，我们记作S[i],表示从第i个到最后的后缀.
S[1], XMADAMYX， 也就是字符串本身，起始位置为1
S[2], MADAMYX，起始位置为2
S[3], ADAMYX，起始位置为3
S[4], DAMYX，起始位置为4
S[5], AMYX，起始位置为5
S[6], MYX，起始位置为6
S[7], YX，起始位置为7
S[8], X，起始位置为8
接着,我们用上面trie的方法,把一个字符串的所有后缀建立trie.再盗用一张图.如下:
正如我们上面说的,一般trie是许多字符串生成的前缀树,而这里我们用一个字符串生成N个后缀子串,再用后缀子串生成trie.
上图中,有许多中间节点是多余的,我们要用最少的节点来表示,并且所有的后缀都是叶子节点,那么就做如下的压缩:
1. 每个节点可以存储多个字母.
2. 字符串后加一个结尾,如’$’,那么就不会有任意后缀是其他后缀的前缀,压缩的时候就不会有后缀被压缩掉.
于是,我们得到了压缩的后缀树:
继续盗图:
于是我们概括为 ( 后缀树=后缀子串们+ trie ).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e136010798764ba28afcca6ac31ec0f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cc951207f2b77d46b5a39ff53ab6885/" rel="bookmark">
			linux下对/sys/class/gpio中的gpio的控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在嵌入式设备中对GPIO的操作是最基本的操作。一般的做法是写一个单独驱动程序，网上大多数的例子都是这样的。其实linux下面有一个通用的GPIO操作接口，那就是我要介绍的 “/sys/class/gpio” 方式。 首先，看看系统中有没有“/sys/class/gpio”这个文件夹。如果没有请在编译内核的时候加入 Device Drivers —&gt; GPIO Support —&gt; /sys/class/gpio/… (sysfs interface)。 /sys/class/gpio 的使用说明： 01 gpio_operation 通过/sys/文件接口操作IO端口 GPIO到文件系统的映射 02 * 控制GPIO的目录位于/sys/class/gpio 03 * /sys/class/gpio/export文件用于通知系统需要导出控制的GPIO引脚编号 04 * /sys/class/gpio/unexport 用于通知系统取消导出 05 * /sys/class/gpio/gpiochipX目录保存系统中GPIO寄存器的信息，包括每个寄存器控制引脚的起始编号 base，寄存器名称，引脚总数 导出一个引脚的操作步骤 06 * 首先计算此引脚编号，引脚编号 = 控制引脚的寄存器基数 + 控制引脚寄存器位数 07 * 向/sys/class/gpio/export写入此编号，比如12号引脚，在shell中可以通过以下命令实现， echo 12 &gt; /sys/class/gpio/export 命令成功后生成/sys/class/gpio/gpio12目录，如果没有出现相应的目录，说明此引脚不可导出： 08 09 * direction文件，定义输入输入方向，可以通过下面命令定义为输出 10 echo out &gt; /sys/class/gpio/gpio12/direction 11 * direction接受的参数：in, out, high, low。high/low同时设置方向为输出， 并将value设置为相应的1/0。 12 * value文件是端口的数值，为1或0. 13 echo 1 &gt;/sys/class/gpio/gpio12/value
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cc951207f2b77d46b5a39ff53ab6885/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d7a60a17ccf405273c96f4c1ab71db9/" rel="bookmark">
			mysql将时间戳转成常用可读时间格式，sql时间戳转可视日期格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 mysql中一个表的一个时间列是int类型，现在想修改这个字段的值，打算可读日期时间格式转成int，然后修改那个值。 这个转换函数就是UNIX_TIMESTAMP，将可读的时间转换成int类型，具体用法： update xxx_table set xxx_time=UNIX_TIMESTAMP('2006-11-13 13:24:22') where ...... 同时介绍一个另一个转换函数：FROM_UNIXTIME，将将时间戳转成常用时间格式 select FROM_UNIXTIME(xxx_time) from xxx_table mysql将时间戳转成常用时间格式 在mysql中，一个时间字段的存储类型是int（11），怎么转化成字符类型，比方存储为13270655222，需要转化为yyyy -mm-dd的形式 使用 FROM_UNIXTIME函数，具体如下： FROM_UNIXTIME(unix_timestamp,format) 返回表示 Unix 时间标记的一个字符串，根据format字符串格式化。format可以包含与DATE_FORMAT()函数列出的条目同样的修饰符。 根据format字符串格式化date值。下列修饰符可以被用在format字符串中： %M 月名字(January……December) %W 星期名字(Sunday……Saturday) %D 有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y 年, 数字, 4 位 %y 年, 数字, 2 位 %a 缩写的星期名字(Sun……Sat) %d 月份中的天数, 数字(00……31) %e 月份中的天数, 数字(0……31) %m 月, 数字(01……12) %c 月, 数字(1……12) %b 缩写的月份名字(Jan……Dec) %j 一年中的天数(001……366) %H 小时(00……23) %k 小时(0……23) %h 小时(01……12) %I 小时(01……12) %l 小时(1……12) %i 分钟, 数字(00……59) %r 时间,12 小时(hh:mm:ss [AP]M) %T 时间,24 小时(hh:mm:ss) %S 秒(00……59) %s 秒(00……59) %p AM或PM %w 一个星期中的天数(0=Sunday ……6=Saturday ） %U 星期(0……52), 这里星期天是星期的第一天 %u 星期(0……52), 这里星期一是星期的第一天 %% 一个文字“%”。 所有的其他字符不做解释被复制到结果中。 如： SELECT FROM_UNIXTIME(1234567890, '%Y-%m-%d %H:%i:%S') 可以自己指定格式。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11c296d66696af52dd02383ae697df8/" rel="bookmark">
			Linux PS 命令详解(转)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。
要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。
ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。
kill 命令用于杀死进程。
linux上进程有5种状态:
1. 运行(正在运行或在运行队列中等待)
2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)
3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)
4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)
5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)
ps工具标识进程的5种状态码:
D 不可中断 uninterruptible sleep (usually IO)
R 运行 runnable (on run queue)
S 中断 sleeping
T 停止 traced or stopped
Z 僵死 a defunct (”zombie”) process
1．命令格式：
ps[参数]
2．命令功能：
用来显示当前进程的状态
3．命令参数：
a 显示所有进程
-a 显示同一终端下的所有程序
-A 显示所有进程
c 显示进程的真实名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b11c296d66696af52dd02383ae697df8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/279284e5e7f47c2c5f46d7e27e9368d6/" rel="bookmark">
			Unix系列shell程序编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*Shell是什么? 任何发明都具有供用户使用的界面。UNIX供用户使用的界面就是Shell(DOS的command熟悉吧，但UNIX的要强大的多)。 Shell为用户提供了输入命令和参数并可得到命令执行结果的环境。 为了不同的需要，UNIX提供了不同的Shell。现在的UNIX大部分都支持BourneShell，以下教程就以BourneShell(Bsh)为例，一步步的领略UNIX Shell的强大功能，占先其强大魅力，达到更方便灵活的管理、应用UNIX的目的。 1.UNIX内核和Shell的交互方法 启动UNIX时，程序UNIX(内核)将被调入计算机内存，并一直保留在内存中直到机器关闭。在引导过程中，程序 init将进入后台运行一直到机器关闭。该程序查询文件/etc/inittab，该文件列出了连接终端的各个端口及其特征。当发现一个活动的终端 时，init程序调用getty程序在终端上显示login等登陆信息。(username和passwd)，在输入密码后， getty调用login进程，该进程根据文件/etc/passwd的内容来验证用户的身份。若用户通过身份验证，login进程 把用户的home目录设置成当前目录并把控制交给一系列setup程序。setup程序可以是指定的应用程序，通常setup程序 为一个Shell程序，如:/bin/sh 即Bourne Shell（command出来了，呵呵）。 得到控制后，Shell程序读取并执行文件/etc/.profile以及.profile。这两个文件分别建立了系统范围内的和 该用户自己的工作环境。最后Shell显示命令提示符，如$。(这是以bsh为例，若是csh,为.cshrc,ksh为.kshrc,bash为.bashrc等等) 注不妨把/etc/.profile和.profile看成DOS的autoexec.bat 或 config.sys文件) 当shell退出时，内核把控制交给init程序,该程序重新启动自动登陆过程。有两种方法使shell退出，一是用户执行exit命令，二是 内核(例如root用kill命令)发出一个kill命令结束shell进程。shell退出后，内核回收用户及程序使用的资源。 用户登陆后，用户命令同计算机交互的关系为:命令进程---&gt;Shell程序---&gt;UNIX内核---&gt;计算机硬件。当用户输入一个命令，如$ls, Shell将定位其可执行文件/bin/ls并把其传递给内核执行。内核产生一个新的子进程调用并执行/bin/ls。当程序执行完毕后，内核取消 该子进程并把控制交给其父进程，即Shell程序。例如执行: $ps 该命令将会列出用户正在执行的进程，即Shell程序(下来详细说说，别急现在)和ps程序。若执行: $sleep 10 &amp; $ps 其中第一条命令将产生一个在后台执行的sleep子进程。ps命令执行时会显示出该子进程。 每当用户执行一条命令时，就会产生一个子进程。该子进程的执行与其父进程或Shell完全无关，这样可以使Shell去做其他工作。(Shell只是把用户的意图告诉内核，然后该干嘛干嘛) 现在windows有个计划任务(在固定的时间，日期自动执行某任务),其实UNIX很早就有这个功能了，也就是所谓的Shell的自动执行。一些UNIX 资源，如cron可以自动执行Shell程序而无需用户的参与，(这个功能好象在/var/spool/crotab目录里)。 Crontab 程序对于系统管理员来说是非常有用的。Cron 服务用于计划程序在特定时间（月、日、周、时、分）运行。我们以root的crontab 为例。根用户的 crontab 文件放在 /var/spool/crontab/root 中，其格式如下： (1) (2) (3) (4) (5)　(6) 0　0 *　* 3　/usr/bin/updatedb 1. 分钟 (0-60) 2. 小时 (0-23) 3. 日 (1-31) 4. 月 (1-12) 5. 星期 (1-7) 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/279284e5e7f47c2c5f46d7e27e9368d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8221e08202381f0a4ff812c4d2c9c4/" rel="bookmark">
			大小。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：MiB和MB，KiB和KB等的区别:
1KB(kilobyte)=1000byte, 1KiB(kibibyte)=1024byte
1MB(megabyte)=1000000byte, 1MiB(mebibyte)=1048576byte
硬盘生产商是以GB（十进制，即10的3次方=1000，如1MB=1000KB）计算的，而电脑（操作系统）是以GiB(2进制，即2的10次方，如1MiB=1024KiB）计算的，但竖内用户一般理解为1MB＝1024KB, 所以为了便于中文化的理解，翻译MiB为MB也是可以的。
同样根据硬盘厂商与用户对于1MB大小的不同理解，所以好多160G的硬盘实际容量按计算机实际的1MB＝1024KB算都不到160G，这也可以解释为什么新买的硬盘“缺斤短两”并没有它所标示的那么大。
宽带网络中,运营商们所说的1M带宽是指1Mbps(megabits per second，兆比特每秒)。bps是bit per Second的缩写，也就是每秒多少“位”(bit)的意思。是用来计算资料传输速率的单“位”。举例来说，电信局通常说的1M的宽，所使用的单位就是bps，我们都知道一个字节等于8位，而我们电脑的存储单位使用的是字节，也就是理论上每秒可以向硬盘下载1X1024/8=128KB/sec的数据。但这也只是理论上的速度。实际上则要再扣约12%的数据头信息（包Ethernet Header,IP Header,TCP Header,ATM Header等），各种各样的控制讯号。所以传输速度上限应112KB/sec左右，而不应该望文生义地理解为“每秒钟可以传送1M字节的数据。所以千万不要迷信广告，传输单位的写法上，B和b分别代表Bytes和bits，两者定义不同，差距是8倍
转载于:https://blog.51cto.com/leon1986/1337468
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83df86001839211d3fa7c5798f6f4c0/" rel="bookmark">
			机器学习基础unsupervised 和supervised学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、定义 引用维基百科和百度百科。 监督式学习 （英语 ：Supervised learning ），是一个机器学习 中的方法，可以由训练资料中学到或建立一个模式（函数 / learning model），并依此模式推测新的实例。 训练资料是由输入物件（通常是向量）和预期输出所组成。函数的输出可以是一个连续的值（称为回归分析），或是预测一个分类标签（称作分类）。（wikipedia）利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程，也称为监督训练或有教师学习。（baidu） 无监督学习/非监督式学习(unsupervised learning):设计分类器时候，用于处理未被分类标记的样本集。监督学习中在给予计算机学习样本的同时，还告诉计算各个样本所属的类别。若所给的学习样本不带有类别信息,就是无监督学习。（baidu） 非监督式学习 是一种机器学习 的方式，并不需要人力来输入标签。它是监督式学习 和强化学习 等策略之外的一种选择。在监督式学习中，典型的任务是分类和回归分析 ，且需要使用到人工预先准备好的范例。 一个常见的非监督式学习是数据聚类 。 百度百科和维基百科定义有点抽象，为了更为简明的在神经网络学习中进行表述，我们给出我们对监督学习和非监督学习的定义： 监督式学习：能够通过训练样本集或专家知识构建已知且确定的判定函数，并根据训练集和该判定函数形成模型改进策略，对模型参数进行不断改进，完成模型学习的过程称为监督式学习；如果无法从训练样本集或专家知识构建确定的判定函数，而通过训练集与一给定的判定函数进行模型参数不断改进，完成学习的过程称为非监督式学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c0849e6e6a38521aba0b5a8f39cc3f/" rel="bookmark">
			Axis2调用webservice Client
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Axis2调用webservice，很多人和网上都使用的RPCServiceClient进行调用webservice，但是有时候并不是一定都满足需求，接下来会展示下RPCServiceClient的简单使用，和当无法满足需求时候怎么使用serviceClient。
首先展示下RPCServiceClient的调用示例：
package com.zjhcsoft.eddmp.webService.dao; import org.apache.axiom.om.OMAbstractFactory; import org.apache.axiom.om.OMElement; import org.apache.axiom.om.OMFactory; import org.apache.axiom.om.OMNamespace; import org.apache.axis2.AxisFault; import org.apache.axis2.addressing.EndpointReference; import org.apache.axis2.client.Options; import org.apache.axis2.rpc.client.RPCServiceClient; import javax.xml.namespace.QName; /** * RPCServiceClient调用demo * User: Francis.Hu * Date: 13-12-4 * Time: 下午12:10 */ public class TestClass { public static void main(String[] args) { String url = "http://10.7.92.232:8080/SMS_Send_Service/services/smsSend"; String method = "send"; String serviceNameH = "SendSMS10***1"; String serviceVer = "1.**"; String consumer = "**"; String requestTime = "2001-12-17T09:30:47.0Z"; String destTermID = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c0849e6e6a38521aba0b5a8f39cc3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7eb23f5ae63a389ae0f18347662300b/" rel="bookmark">
			asp_异步无刷新分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LoadAllNews.ashx:
public void ProcessRequest(HttpContext context)
{
int pageSize = int.Parse(context.Request["pageSize"]??"5");
int pageIndex = int.Parse(context.Request["pageIndex"]??"1");
int total = 0;
context.Response.ContentType = "text/plain";
BLL.HKSJ_Main mainServer = new BLL.HKSJ_Main();
//var list=mainServer.GetModelList(" ");
//异步无刷新分页，必须加载当前页面，所以将上面语句进行修改
var list = mainServer.LoadPageMainByProc(pageSize,pageIndex,out total);
//分页的标签那都
string strPageNav= Common.LaomaPager.ShowPageNavigate(pageSize,pageIndex,total);
System.Web.Script.Serialization.JavaScriptSerializer javaScriptSerrializer = new System.Web.Script.Serialization.JavaScriptSerializer();
//string jsonStr = javaScriptSerrializer.Serialize(list);
//实现异步无刷新分页，则将上面的代码改为下面的
string jsonStr = javaScriptSerrializer.Serialize(new { NavStr = strPageNav, PageList = list });
context.Response.Write(jsonStr);
}
UserList.html:
function initTableList(requestData) {//为实现异步无刷新分页
//function initTableList() {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7eb23f5ae63a389ae0f18347662300b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/649f0205f365b59aa540f86bc1c364c5/" rel="bookmark">
			使用AST树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五章、使用AST树中间结果来计算表达式值 现在我们已经知道，通过创建ANTLR 语法文件 以及添加一些动作来实现一个“转换器”，这一章节将介绍另外一种方式来实现同样的功能，这需要额外用到一些树结构。我们将使用相同的grammar语法来创建一个中间数据结果，只是用树的创建规则来替换我们之前添加的一些动作。一旦，我们有了树结构，就可以用树解析器来解析树，并且执行一些动作。
ANTLR将会从grammar文件从创建一个树解析器。Parser grammar 会把输入的字符流转换成一个树结构，然后输解析器会对其解析求值。
尽管之前的方法更加直接，但是从语言规划来讲做得不够好。向grammar中添加方法调用、while循环，意味着，解析器要执行相同的代码多次。每当需要调用一个方法时，解析器需要重解析这个方法。因此相比较AST方法，之前的方法不够灵活，AST方法生成AST树来存储中间结果，再遍历树执行相关操作。很明显，重复遍历树比重复解析grammar效率更高。
一个中间结果通常是一棵树，树中节点不止是符号，还有表示符号间关系的节点。举例来说，下面的图表示了3+4这个表达式：
在许多例子中，你会看到树被表示成文本形式。比如，3+4可表示为（+ 3 4 ）。括号后面第一个符号是根节点，随后的事他的孩子。表达式3+4*5的一颗AST树，文本形似为 （+ 3 （* 4 5）），如下图所示：
正如我们看到的，AST树结构严格表示了操作优先级。这里，乘法必须先被执行，因为加法需要乘法的结果作为操作参数。
AST不同于解析树，解析树代表了解析规则。下图展示了本例子中的解析树：
解析树的叶子节点是输入符号，非叶节点是规则名。根节点prog表示，3+4是一个prog。更具体的说是一个stat，而stat是由expr组成。所以解析树，记录了recognizer如何与输入进行匹配的。
在实际中，让语法和树解耦是非常有用的。因此，AST树不受解析树的影响。一个语法通常会改变解析树的结构但不会影响AST,这对处理AST树的代码来说很有意义。
一旦生成好了AST树，你可以有多种方式访问它，来计算你要的结果。一般来说，我建议你使用tree grammar 来生成访问树的代码。
在下一章节，你将学习如何创建AST树，怎样通过一个tree grammar访问它，如何在tree grammar中设置动作。最会，你会得到一个和之前有一样功能的转换器。
创建ASTS 为ANTLR创建AST是很简单的。我们需要在解析grammar里面设置树的创建规则，来指明我们需要怎样创建树。相比之前方法加入action，这里的语法更小，能更快被读写。当我们使用选项：option=AST,每个语法规则，将返回一个树节点，或者一颗子树。最顶层规则返回的树，将是一颗完整的AST树。
一开始我们需要告诉ANTLR我们需要创建AST树：
grammar Expr;
options {
output=AST;
// ANTLR can handle literally any tree node type.
// For convenience, specify the Java type
ASTLabelType=CommonTree; // type of $stat.tree ref etc...
}
如果仅仅这样设置，将会创建一颗平坦的AST树，每个匹配字符，都是一个AST节点，而AST树就是这些节点组成的列表。为了指定树的结构，我们需要简单的指明，哪些字符需要被考虑为操作，哪些不需要放到树中。我们分别使用^ 和 !这两个后缀。
现在我们修改规则如下：
expr: multExpr (('+' ^|'-' ^) multExpr)*
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/649f0205f365b59aa540f86bc1c364c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5040313c6e85aa4e0b783ea3660e2774/" rel="bookmark">
			error LNK2005: &#34;enum TWindowAttr TWINDOWATTR&#34; (?TWINDOWATTR@@
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		error LNK2005: "enum TWindowAttrTWINDOWATTR" (?TWINDOWATTR@@3W4TWindowAttr@”
error LNK1169:找到一个或多个多重定义
问题造成的原因是，结构体或者函数体的定义放在了头文件中，在头文件中定义的话，就会造成所以包含该头文件的源文件，进行再次的定义，所以会出现重复定义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be391eed7fc6bc4d89f955b3f073d396/" rel="bookmark">
			linux 下载tftp报错 缺少库文件libssl0.9.8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行命令sudo apt-get install tftp tftpd 安装tftp就报错，其实报这个错误，安装什么都是安装不成功的，安装vim ，samba也是如此，纠结了半天就是不知道咋回事啊
vsftpd : Depends: libssl0.9.8 (&gt;= 0.9.8m-1) but it is not going to be installed
E: Unmet dependencies. Try 'apt-get -f install' with no packages (or specify a solution).
其实就是缺少库文件 libssl0.9.8
安装库文件libssl0.9.8 sudo apt-get install libssl0.9.8 安装这个依耐库文件成功之后，再执行sudo apt-get install tftp tftpd就成功了。
遇到这个问题纠结了很久，现在解决了，于是拿出来大家分享分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e6893c38e09eaf7ae598d1a506706a/" rel="bookmark">
			拓扑排序（Topological Sort）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0）拓扑排序
拓扑排序是对有向无圈图的顶点的一种排序，这个排序的结果是如果存在一条vi到vj的路径，那么排序中vi在vj的前面。
下图是一个有向无圈图的例子：
在这个有向无圈图中，1,6,5,7,4,2,3；1,6,5,7,2,4,3；这两组都是拓扑排序，我们可以看到这两种排序都满足拓扑排序的要求，比如说1-4的路径，可知1,7,4；1,6,5,4；1,6,7,4；1,6,5,7,4；这些路径的点都按照拓扑排序的要求排列。
1） 简单的拓扑排序算法
下面我们介绍一个简单的拓扑排序算法：
a）先找到一个没有输入边的点，输出这个点，然后去掉与这个点连接的所有边。
b）重复上面的步骤知道输出所有的点。
这里为了编程方便，我们要先定义一个叫做indegree的概念:
indegree: 顶点v包含的边（u，v）的个数。
注意是有向图的v包含的边（u，v）的个数。因此对于上图的点1，它的indegree=0，因为进入点1的边为0，点1的三条边全是指向外的。
所以通过引入indegree概念，上面的简单算法就可以用下面的方式表示
a） 查找indegree为0的点p
b） 对所有与p邻接的点的indegree = indegree -1；
c） 查找indegree为0的点（p除外），然后循环过程
下面是简单的拓扑排序算法的一段伪代码
void TopSort(Graph G) { int Num; Vertex V,W; for(Num=0;Num&lt;NumVertex;Num++) { V = FindNewVertexOfDegreeZero(); if(V==NotVertex) { Error("Graph has a cycle!"); break; } Output[V] = Num; for each W adjacent to V Indegree[W]--; } } 2） 拓扑排序的改进算法 上面的简单算法还是很简单的，也很好理解，那么为什么要改进上面的算法呢？这个主要是因为上面算法的时间复杂度为O(|V|^2)。 首先FindNewVertexOfDegreeZero()函数因为要找到indegree=0的点，所以需要遍历所有的点，因此时间复杂度为O(|V|)。而这个函数需要重复|V|次，因此上面的算法的时间复杂度为O(|V|^2)。因此我们需要做一些改进，来降低运行时间。
可以看到，这里可能能够进行改进的就是FindNewVertexOfDegreeZero()函数。当我们删除一个indegree=0的点后，只有与这个邻接的点的indegree才会减一，其他的点的indegree值不变，因此当我们需要在一次FindNewVertexOfDegreeZero时，不需要遍历所有的点，只需要遍历部分相关连的点就可以。
为了实现上面的思想，我们把indegree=0的点放到一个box中，因此FindNewVertexOfDegreeZero()函数只需要在这个box中寻找就好了。当一个点的indegree=0时，我们就把这个点输入到box中。
算法：
a） 把ndegree=0的点A放到一个Queue中；
b） 把点A出队，然后对所有的与A邻接的点的indegree减一；
c） 把新的ndegree=0的点入队；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07e6893c38e09eaf7ae598d1a506706a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd8b52e398c2b5d7c4b4442bed4d9782/" rel="bookmark">
			求深圳龙华富士康面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下周一去龙华富士康去面试，跪求面试题啊，要不要去面试，给点意见啊 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c8f24552f762db04ecd4185438e039/" rel="bookmark">
			c语言递归求n的阶乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.用循环
#include&lt;stdio.h&gt; int main() { int i,n,sum=1; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++) { sum*=i; } printf("%d!=%d",n,sum); getch(); return 0; } 2.用递归
#include&lt;stdio.h&gt; int factorial(int n){ if(n==0) return 1; return factorial(n-1)*n; } int main() { int n,sum=1; scanf("%d",&amp;n); printf("%d!=%d",n,factorial(n)); getch(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aea50071947f41797a45e1da3c35e09/" rel="bookmark">
			c语言字符转换成数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; int main(void) { char str[6]="123456"; int i=0,j=0; char temp[6]; int num=0; for(i=0;i&lt;str[i]!='\0';i++){ if(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9'){//为了保证是数字字符串 temp[j++]=str[i]; } } i=0; while(i&lt;j){ num=num*10+temp[i]-'0';//-'0'是因为'0'是字符串转换成数字必须减去ASCII码48，字符串0的ASCII码48也可以这样写num=num*10+temp[i]-48; //列如:0*10+49-48=1,1*10+50-48=12,12*10+51-48=123... i++; } printf("%d",num); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68de1a9c6bb8b0bc93578571bb18376c/" rel="bookmark">
			【机器学习笔记4】Stanford公开课Exercise 3——Multivariate Linear Regression
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stanford公开课Exercise 3原题地址：http://openclassroom.stanford.edu/MainFolder/DocumentPage.php?course=MachineLearning&amp;doc=exercises/ex3/ex3.html，下面是我完成的笔记。
第一部分，gradient descent方法
（一）原理回顾 简单重复一下gradient descent实现的过程，具体的看前面的文章（【机器学习笔记2】Linear Regression总结）：
1. h(θ)函数 （公式1）
2. J(θ)函数 （公式2）
向量化后简化为：
（公式3）
3.θ迭代过程 （公式4）
向量化后简化为：
（公式5）
4. Feature Scaling 将不同特征的取值转换到差不多的范围内，具体做法是：特征值减去该组特征值的均值，然后除以该组特征值的标准差，将所有特征值归一化至[-1,1]的范围。
（公式6）
（二）实现代码 %================================================================= % Exercise 3: Multivariate Linear Regression (gradient descent) % author : liubing (liubing80386@163.com) % %LB_c: 加载数据 =============== x = load("ex3x.dat"); y = load("ex3y.dat"); %LB_c: 矩阵x第一列加上全1 x = [ones(size(x)(1),1), x]; %============================== %LB_c: scaling(缩放到相同范围)，参考上面的（公式6） sigma = std(x);	%x按列求标准差 mu = mean(x);	%x按列求均值 %第2、3列scaling（第1列全为1，不用做） x(:,2) = (x(:,2) - mu(2)) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68de1a9c6bb8b0bc93578571bb18376c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67792385c22a56d41e678e1c7134f224/" rel="bookmark">
			Smack:处理传入的Packet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Smackt提供了一个灵活的框架来处理传入的Packt，使用两个构造器：
org.jivesoftware.smack.PacketCollector--一个类，它允许你同步等待新的数据包。
org.jivessoftware.smack.PacketListener--一个接口，用户异步通知你传入的packet。
一个packet listener使用事件类型编程，然而packet controller有一个packet结果队列，你可以做轮询和阻塞操作。所以，packet listener当你想无论何时一个packet传入的时候做一些动作的时候非常有用。所以，一个packet listener当你想等待一个指定的packt抵达的时候非常有用。packt collector和listener能使用一个Connection实例被创建。
org.jivesoftware.smack.filter.PacktFilter接口决定了哪个指定的packt被发送到PacktCollector或者PacktListener。许多预定义的过滤器能在org.jivesoftware.smack.filter包中被找到。
下面的代码片段演示了一个packet collector和一个packet listener的注册。
// Create a packet filter to listen for new messages from a particular // user. We use an AndFilter to combine two other filters. PacketFilter filter = new AndFilter(new PacketTypeFilter(Message.class), new FromContainsFilter("mary@jivesoftware.com")); // Assume we've created a Connection name "connection". // First, register a packet collector using the filter we created. PacketCollector myCollector = connection.createPacketCollector(filter); // Normally, you'd do something with the collector, like wait for new packets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67792385c22a56d41e678e1c7134f224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89351e4219283f9a5b130c83917ea086/" rel="bookmark">
			权限管理 (二) 实现中几个问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人在做每件事情的时候都会遇到各种问题和困难，当遇到困难时需要去主动解决否则会越积累越多也越不好解决，时间长了慢慢的让这种思维成为我们的习惯，它会让你受益一生。
写每篇博客都会有所收获和思想感触，不成熟的、成熟的、自己的或是借鉴别人的都可以拿过来写写，写博客和写散文类似若能达到形散神不散的地步，水平也就到一定境界了。
做权限这块时整体上知道了设计思路该如何实现，但是还是对于一些细节的控制不是特别理解，看了若干遍并查了查资料问了问别人讨论了一下清晰了很多，对于模糊的东西请教别人或者一起讨论对加深理解很有帮助，即使大家都不懂也可以交流一下各自的理解，也许你会从别人的思路中受到启发在与别人思想的碰撞中产生璀璨的火花。
下面说一下存在的几个问题：
多个角色授予一个用户的冲突问题
为模块授权，通过创建角色，并为该角色分配权限，然后便可以为用户分配角色了（可以为多个），从而达到复用和统一控制的目的。一个用户可以拥有多个角色，在给客户提供灵活方便的同时，问题来了——多个角色被授予同一个用户时出现授权冲突，比如：角色A对模块A有删除权限，但角色B对模块A的删除权限则被禁止，这时候，如果将角色A和角色B同时授予用户A，则会造成困扰，它应该是以角色A的授权为准，还是应该以角色B的授权为准？
办法总比问题多，那么我们应该考虑解决方案，并从中选择最优解。针对这个问题，可以考虑如下解决办法：
1.如果多个角色之间有授权冲突，则不允许将这些角色同时授予同一个用户，比如，在上述例子中，不允许将角色A和角色B同时授予用户A
2.允许将有授权冲突的角色同时授予同一个用户，但用户在某个时刻只能扮演其中的某个角色。在用户登陆后台管理界面之后，可以通过切换角色，来执行不同的操作！
3.允许将有授权冲突的角色同时授予同一个用户，对用户的这些角色来说，有优先级的概念，当将角色分配给用户的时候，应该设置它的优先级。同一个角色在不同的用户那里可能具有不同的优先级。当授权有冲突的时候，以优先级更高的角色授权为准。
前两种方法不够灵活，比较死板，过于强硬，而第三种方法比较人性化。
对每个模块操作的控制
需要控制每个模块的增删改查操作，如果需求变了也可能增加或者减少操作种类，常规想法是增加实体类属性或表字段来控制但是这种方式不灵活，因为数据库结构一旦定型是不会轻易修改，如果有用一个字段表示多个操作类型就可以解决这样的问题，我们用一个int类型表示，java中int类型占32bit这样可以用一个bit代表一种操作类型，bit的值0或1表示有效无效让操作种类和有效无效两个功能合二为一。
角色或模块给同一个用户授权的冲突问题
在给用户授权的时候主要是通过角色授予，也可以给用户单独授权，如果同一个或多个资源模块既给用户单独授权又通过角色授权就会产生冲突，如果解决该问题本OA中添加了一个字段“是否继承”，这里的继承第一遍看时不好理解，“继承”加了双引号显然不是父类子类一样的关系继承，这里的继承可以理解为是否使用对用户的单独授权，继承表示不使用单独授权而是查询用户所拥有角色的授权，使用从角色那里继承来得权限。
这是一个简单的权限管理，有关更多权限实现见下篇博客……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea590838d298fd41a2834640bc52a451/" rel="bookmark">
			CString转char数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其他类型相互转换，请参考：http://www.cppblog.com/robinson119/archive/2007/04/26/22870.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df03783f29c73760bdefc4406c86621/" rel="bookmark">
			智能终端应用程序测试内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能终端应用程序测试应该包括：功能测试、界面测试、性能测试、用户体验测试、安全性测试、Install/Uninstall/Update测试、兼容性测试、中断测试这几方面.
1、功能测试
根据软件说明或用户需求验证Application的各个功能实现，采用如下方法实现并评估功能测试过程：
1）采用时间、地点、对象、行为和背景五元素或业务分析等方法分析、提炼Application的用户使用场景，对比说明或需求，整理出内在、外在及非功能直接相关的需求，构建测试点，并明确测试标准（若用户需求中无明确标准遵循，则需要参考行业或相关国际标准或规则）。
2）根据被测功能点的特性列举出相应类型的测试用例对其进行覆盖，如：涉及输入的地方需要考虑等价、边界、负面、异常或非法、场景回滚、关联测试等测试类型对其进行覆盖。常用的测试方法有等价类，边界值，场景法，错误猜测法等。
3）在测试实现的各个阶段跟踪测试实现与需求输入的覆盖情况，及时修正业务或需求理解错误。
2、界面测试
测试用户界面(如菜单、对话框、窗口和其它可视控件)布局、风格是否满足客户要求，文字是否正确，页面是否美观，文字，图片组合是否完美，操作是否友好等。
UI 测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏览功能。确保用户界面符合公司或行业的标准。包括用户友好性、人性化、易操作性测试。
3、性能测试
评估Application的时间和空间特性
1）极限测试：在各种边界压力情况下（如电池、存储、网速等），验证Application是否能正确响应。
2）响应能力测试：测试Application中的各类操作是否满足用户响应时间要求
3）压力测试：反复/长期操作下，系统资源是否占用异常;
4）性能评估：评估典型用户应用场景下，系统资源的使用情况。
5）Benchmark测试： 与竞争产品的Benchmarking, 产品演变对比测试等。
4、用户体验测试
以主观的普通消费者的角度去感知产品或服务的舒适、有用、易用、友好亲切程度。通过不同个体、独立空间和非经验的统计复用方式去有效评价产品的体验特性，提出修改意见提升产品的潜在客户满意度。
5、兼容测试
主要测试内部和外部兼容性
1）与本地各类主流运用是否兼容
2）检验在各种网络连接下(WiFi、GSM、GPS、CDMA等)，Application的数据和运用是否正确。
3）与各种设备是否兼容（若有跨系统支持则需要检验是否在各系统下，各种行为是否一致）。
6、安全测试
借鉴于网络传输和Web应用的安全测试经验，将智能终端Application安全测试大概划分为以下几类:
1） 从数据的本地存储到数据的传输、处理以及远程访问等各个环节，基于相应的安全标准如PCI(Payment Card Industry)、OSSTMM(Open Source Security Test Methodology Manual)评估Application的安全特性。如采用开源的工具如Nikto等对Application进行穿透测试，以期发现安全问题；
2）借鉴在Web Application和网络安全测试的一些成功经验在智能终端Application测试中进行裁减或适配；检视Application的用户授权级别，数据泄漏，非法授权访问等;
3） 基于OWASP(Open Web Application Security) Top 10所述的原则对Application的输入有效性校验、认证、授权、敏感数据存储、数据加密等方面进行检测,以期发现潜在的安全问题;
4）基于各种通信协议或相应的行业安全标准检视Application是否满足相应的要求.
7、Install/Uninstall/Update测试
验证Application是否能正确安装、卸载及更新状况，以及操作过程和操作前后对系统资源的使用情况（Footprint）。如：
1）检测软件是否能正确安装卸载；
2）安装卸载过程是否方便；
3）位置和文件夹是否合理；组件是否正确注册或删除;
4）安装过程中出现中断（来电）或进程重启（显示变向）等异常情况下，安装是否正确，卸载时组件是否正确卸载；
5）评估安装/卸载Application及操作前后，CPU、Memory、Storage等系统资源的使用情况。
8、中断测试
针对智能终端应用的服务等级划分方式及实时特性所提出的测试方法，如：交互测试（Application在前/后台运行状态时与来电、文件下载、音乐收听等关键运用的交互情况）及跌落测试等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e7bec19a83962f5aa60ddaa9e3c7413/" rel="bookmark">
			Hibernate中Criteria的完整用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		criteria 英 [ kraɪˈtɪərɪə ] 美 [ kraɪˈtɪrɪə ] 标准
1， Criteria Hibernate 设计了 CriteriaSpecification 作为 Criteria 的父接口，下面提供了 Criteria和DetachedCriteria 。 2， DetachedCriteria Spring 的框架提供了getHibernateTemplate
().findByCriteria(detachedCriteria) 方法可以很方便地根据DetachedCriteria 来返回查询结
果。 DetachedCriteria 提供了 2 个静态方法 forClass(Class) 或 forEntityName(Name)
进行DetachedCriteria 实例的创建。 3， Criteria 和 DetachedCriteria Criteria 和 DetachedCriteria 的主要区别在于创建的形式不一样， Criteria 是在线的，是由
Hibernate Session 进行创建的；而 DetachedCriteria 是离线的，创建时无需 Session 。 使用DetchedCriteria
Criteria与Session绑定，其生命周期跟随着Session结束而结束，使用Criteria时进行查询时，每次都要于执行时期动态建立物件，并加入各种查询条件，随着Session的回收，Criteria也跟着回收。
Criteria 和 DetachedCriteria 均可使用 Criterion 和 Projection 设置查询条件。可以设
置 FetchMode( 联合查询抓取的模式 ) ，设置排序方式。对于 Criteria 还可以设置 FlushModel
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e7bec19a83962f5aa60ddaa9e3c7413/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1dc0ff8fe86e6bdd0984216deb2b518/" rel="bookmark">
			__THROW __nonnull
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		__THROW __nonnull ，不抛出异常和不让参数为空。
Linux 下的例子： /usr/lib/string.h string.h: char *strcpy (char *__restrict __dest, __const char *__restrict __src) __THROW __nonnull ((1, 2)); /usr/src/linux-2.6.0-test3/lib/string.c /** * strcpy - Copy a %NUL terminated string * @dest: Where to copy the string to * @src: Where to copy the string from */ char * strcpy(char * dest,const char *src) { char *tmp = dest; while ((*dest++ = *src++) != '\0') /* nothing */; return tmp; } 在 string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1dc0ff8fe86e6bdd0984216deb2b518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/693c84b70e50f17be212b06b3ffe0d07/" rel="bookmark">
			HDU1437—模拟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的模拟题。
枚举中间可能出现的天气。
#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;stdlib.h&gt; const int maxn = 1005; double mat[ 5 ][ 5 ]; void solve( int L,int R,int n ){ double ans[ 5 ],tp[ 5 ]; double res = 0; for( int i=1;i&lt;=n;i++ ){ if( i==1 ){ ans[ 1 ] = mat[ L ][ 1 ]; ans[ 2 ] = mat[ L ][ 2 ]; ans[ 3 ] = mat[ L ][ 3 ]; //printf("i = 1: %lf %lf %lf\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/693c84b70e50f17be212b06b3ffe0d07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf71ada65c962477a9520b3329cbb96e/" rel="bookmark">
			Qt学习-----finddialog的代码注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码来自http://www.informit.com/store/c-plus-plus-gui-programming-with-qt4-9780132354165
vs2008，Qt4.7.3
记录自己学习Qt4的过程，方便复习
//finddialog.h
#ifndef FINDDIALOG_H
#define FINDDIALOG_H
#include &lt;QDialog&gt;
//前置声明用于对话框实验的Qt类
class QCheckBox;
class QLabel;
class QLineEdit;
class QPushButton;
class FindDialog : public QDialog//声明FindDIalog 并且把他作为QDialog的子类
{
Q_OBJECT//对于定义了信号槽的类，类定义开始必须写宏Q_OBJECT
public:
FindDialog(QWidget *parent = 0);//parent 参数指定其父窗口组件，默认值为０，也就是空指针，没有父对象
signals://用户单击find时发出的两个信号signal关键字实际上是一个宏
void findNext(const QString &amp;str, Qt::CaseSensitivity cs);//Qt::CaseSensitivity 是一个枚举类型，它有两个值，Qt::CaseSensitive 和　Qt::CaseInsensitive
void findPrevious(const QString &amp;str, Qt::CaseSensitivity cs);
private slots://两个槽，
/*
？？？
实现他们需要访问整个对话框的所有子部件，所以保留指向他们的指针
*/
void findClicked();
void enableFindButton(const QString &amp;text);
/*
对以下的变量，使用了前置声明，因为他们都是指针，而且没必要在头文件就访问他们，因而编译程序无需这些类的完整定义
我们没有包含与这几个类相关的头文件，&lt;QLabel&gt;等，利用前置声明可以使得编译更快一些
*/
private:
QLabel *label;
QLineEdit *lineEdit;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf71ada65c962477a9520b3329cbb96e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63272ca4dd3c6770c0090535791c5fb3/" rel="bookmark">
			[总结]RTMP流媒体技术零基础学习方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要总结一些我在学习RTMP流媒体技术过程中积累的经验。也为后来学习RTMP流媒体技术的人们一个参考。本文力图从简到难，循序渐进的介绍RTMP流媒体技术的方方面面，先从应用说起，逐步深化剖析相关工程的源代码。看完本文的话应该会对RTMP流媒体技术有比较完整的了解。
0.背景知识 本章主要介绍一下RTMP流媒体技术都用在了哪里（在这里仅列几个我所知的，其实远比这个多）。说白了就是为了说明：RTMP是非常重要的。
使用RTMP技术的流媒体系统有一个非常明显的特点：使用 Flash Player 作为播放器客户端，而Flash Player 现在已经安装在了全世界将近99%的PC上，因此一般情况下收看RTMP流媒体系统的视音频是不需要安装插件的。用户只需要打开网页，就可以直接收看流媒体，十分方便。
目前使用RTMP技术的电视台有如下几个：
CNTV部分点播内容 中国教育电视台1直播（rtmp://pub1.guoshi.com/live/newcetv1）[失效]
中国教育电视台3直播（rtmp://pub1.guoshi.com/live/newcetv3）[失效]
香港电视台直播（rtmp://live.hkstv.hk.lxdns.com/live/hks）
北广传媒移动电视直播（rtmp://www.bj-mobiletv.com:8000/live/live1）
中石化网络电视台直播（rtmp://wowza.sinopectv.cn:1935/live/sinopec）[暂时无法访问]
东莞电视台（rtmp://ftv.sun0769.com/dgrtv1/mp4:b1）
绍兴新闻综合（rtmp://www.scbtv.cn/live/new）
使用RTMP技术社交直播平台：
六间房 9158 新浪秀场 可以这样概括一下：凡是想实现“无插件直播”的流媒体系统，都会使用RTMP。
1.RTMP在Flash流媒体系统中的使用 RTMP被Adobe开发出来，就是用于在其Flash平台的流媒体系统之间传递数据的。因此想要了解RTMP，需要首先了解Flash流媒体系统。
最简单的Flash流媒体系统由两部分组成：
客户端：Flash Player（一般只有这一种）
注：支持RTMP的基于Flash的播放器除了可以自己开发之外，还有现成的，比如说jwplayer，flowplayer等等。
服务器端：
1.Flash Media Server（FMS）：Adobe官方的流媒体服务器。毕竟是商业服务器，其性能应该是最强的，配置是最简单的，但是价格不菲，推荐作为入门学习使用。个人下载使用是不用花钱的。服务器端编程使用ActionScript语言。
官网：http://www.adobe.com/cn/products/adobe-media-server-family.html
可参考教程：
1.FMS开发者向导。这个教程讲的是FMS开发技术，是网友翻译的中文版，学习起来比较方便。这里有英文原版，内容更全：Flash Media Server Delevoper's Guide
注：FMS开发技术方面使用到了ActionScript，可以先找相关教程做一个初步的了解。主要使用Flash CSx进行开发。
2.FMS技术指南。这个教程主要是讲述FMS配置的，第2部分涉及到集群，负载均衡等内容，挺高端的。
2.Red5：开源流媒体服务器，基于Java的。曾经使用过，感觉也还算比较方便，如果商业应用，又买不起昂贵的FMS的话，使用也不错。服务器端编程使用Java语言。
官网：http://www.red5.org/
3.还有其他服务器，但目前我还没接触过
2.RTMPdump（libRTMP）的使用 这一章就要开始学习RTMP协议的处理了。
可以使用RTMPdump（libRTMP）进行学习。这是一个C++的开源工程。主要作用是下载RTMP流媒体。首先可以了解一下其使用方法：RTMPdump 使用说明
官网：http://rtmpdump.mplayerhq.hu/
3.RTMPdump（libRTMP）源代码分析 这一章开始学习RTMPdump（libRTMP）的源代码。学习它之前需要有Socket编程的基础。
首先学习《RTMP协议规范》
中文翻译版：http://download.csdn.net/detail/leixiaohua1020/6563059
英文原版：http://www.adobe.com/cn/devnet/rtmp.html
我对其部分内容做的简单分析：RTMP规范简单分析
其次从协议规范中，总结出RTMP协议建立连接的流程：RTMP流媒体播放过程
然后，下载一个windows下可以编译通过的RTMPdump工程（这个工程是很难得！）：rtmpdump vs2005版本
（当然，linux下会方便很多，因为RTMPdump就是在linux下开发完成的）
最后，通过调试工程，就可以基本掌握RTMP协议了，我写了一些分析RTMPdump（libRTMP）源代码的文章：
RTMPdump 源代码分析 1： main()函数RTMPDump（libRTMP）源代码分析 2：解析RTMP地址——RTMP_ParseURL()RTMPdump（libRTMP） 源代码分析 3： AMF编码RTMPdump（libRTMP）源代码分析 4： 连接第一步——握手（Hand Shake）RTMPdump（libRTMP） 源代码分析 5： 建立一个流媒体连接 （NetConnection部分）RTMPdump（libRTMP） 源代码分析 6： 建立一个流媒体连接 （NetStream部分 1）RTMPdump（libRTMP） 源代码分析 7： 建立一个流媒体连接 （NetStream部分 2）RTMPdump（libRTMP） 源代码分析 8： 发送消息（Message）RTMPdump（libRTMP） 源代码分析 9： 接收消息（Message）（接收视音频数据）RTMPdump（libRTMP） 源代码分析 10： 处理各种消息（Message）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63272ca4dd3c6770c0090535791c5fb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/536de198b273f3dae126dcf7f3fbc887/" rel="bookmark">
			printf()和scanf()中的控制字符串与转换说明符、转换说明修饰符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、printf()函数
1. （格式）转换说明符
2. （格式）转换说明修饰符
注：printf()中float和double统一用%f，没有%lf这种用法，long double用%Lf
二、scanf()函数
1. （格式）转换说明符
2. （格式）转换说明修饰符
三、printf()和scanf()的*修饰符
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86edbf69ac27608f7916bcdeb21fcfd8/" rel="bookmark">
			遍历/删除文件夹文件实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将【 C:\\Users\\HDaniel\\Desktop\\br 】文件夹下的所有jpg图片文件缩放到高度为100像素，再保存到工程目录下。 遍历文件夹： #include &lt;io.h&gt; #include &lt;Windows.h&gt; #include &lt;ctime&gt; #include &lt;fstream&gt; #include&lt;iostream&gt; #include "string.h" #include &lt;opencv2/opencv.hpp&gt; void mian { _finddata_t info[500];//该文件夹最多有500个文件 long handlefirst;//储存findfirst返回的句柄 int i=0;//计数器 handlefirst= _findfirst("C:\\Users\\HDaniel\\Desktop\\br\\*.jpg",&amp;info[0]);//找到文件夹中第一个文件，成功赋0，没有文件赋-1 if(handlefirst == -1)//没有文件 { cout&lt;&lt;"文件夹可能为空！"&lt;&lt;endl; } do { cout&lt;&lt;"文件名"&lt;&lt;info[i].name&lt;&lt;endl&lt;&lt;"正在缩放..."&lt;&lt;endl; char filename[200]; strcpy(filename,"C:\\Users\\HDaniel\\Desktop\\br\\"); strcat(filename,info[i].name); IplImage* img=cvLoadImage(filename,1); cvSaveImage("tst.jpg",img); IplImage* img_resize=cvCreateImage(cvSize(100,(int)((img-&gt;height)*100/(img-&gt;width))),img-&gt;depth,img-&gt;nChannels); cvResize(img,img_resize); cvSaveImage(info[i].name,img_resize); i++;//计数器自增 cvReleaseImage(&amp;img); cvReleaseImage(&amp;img_resize); }while(_findnext(handlefirst,&amp;info[i])==0); return 0; } 删除文件夹及所有内容： void myDeleteDirectory(CString directory_path) //删除一个文件夹下的所有内容 { CFileFind finder; CString path; path.Format("%s/*.*",directory_path); BOOL bWorking = finder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86edbf69ac27608f7916bcdeb21fcfd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d60d9bff1d21698fcd2dc1602d461ded/" rel="bookmark">
			手机识别项目之字符分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在OPENCV中运用K均值聚类算法： http://www.opencvchina.com/thread-1086-1-1.html； http://blog.csdn.net/xwu6614555/article/details/8568030； http://blog.csdn.net/chenxin_130/article/details/5877831 cvmat的理解： http://blog.csdn.net/rouruoyun/article/details/7259891 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f1640f7bd8a2631c8d24717b724586c/" rel="bookmark">
			图像几何变换：旋转，缩放，斜切
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在CSDN上看到一篇关于图像几何变换的文章，写得很好。收藏！ http://blog.csdn.net/xiaowei_cqu/article/details/7616044 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0c22cd4126e341cb744d219bab1c59/" rel="bookmark">
			关于inline---代替宏定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在c++中，为了解决一些频繁调用的小函数大量消耗栈空间或者是叫栈内存的问题，特别的引入了inline修饰符，表示为内联函数。 可能说到这里，很多人还不明白什么是栈空间，其实 栈空间就是指放置程序的局部数据也就是函数内数据的内存空间，在系统下，栈空间是 有限的，如果频繁大量的使用就会造成因栈空间不足所造成的程序出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。 下面我们来看一个例子：
#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; inline string dbtest(int a); //函数原形声明为inline即:内联函数 void main() { for (int i=1;i&lt;=10;i++) { cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; dbtest(i) &lt;&lt; endl; } cin.get(); } string dbtest(int a)//这里不用再次inline,当然加上inline也是不会出错的 { return (a%2&gt;0)?"奇":"偶"; }
上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部所有调用dbtest(i)的地方都换成了(i%2&gt;0)?"奇":"偶"这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗，而且没有了参数压栈，代码生成等一系列的操作,因此，效率很高 。
说到这里很多人可能会问，既然inline这么好，还不如把所谓的函数都声明成inline，嗯，这个问题是要注意的，inline的使用是有所限制的，inline只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句例如while switch，这是因为，内联函数的代码会在任何调用它的地方展开，如果函数太复杂，代码膨胀带来的恶果很可能会大于效率的提高带来的益处。并且不能内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。 说到这里我们不得不说一下在c语言中广泛被使用的#define语句，是的define的确也可以做到inline的这些工作，但是define是会产生副作用的，尤其是不同类型参数所导致的错误，由此可见inline有更强的约束性和能够让编译器检查出更多错误的特性，在c++中是不推荐使用define的。
其他：
1.内联函数最重要的使用地方是用于类的存取函数。在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个表达式涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现(因为无法将this指针放在合适的位置)。 inline 可以作为某个类的成员函数，当然就可以在其中使用所在类的保护成员及私有成员。 2.类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。
3.inline说明对编译器来说只是一种建议，编译器可以选择忽略这个建议。比如，你将一个长达1000多行的函数指定为inline，编译器就会忽略这个inline，将这个函数还原成普通函数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b5a30a3d49870aa32248718ea3ae24/" rel="bookmark">
			在word中，怎么插入一条水平线、粗线、波浪线、双直线、虚线  -------自动边框线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 生成 在编辑文档时，出于美观和醒目的需要，有时需要为文档添加一些分割线，如果利用特殊符号来输入，则可以达到事半功倍的效果。 如果你需要绘制双直线，只要连续输入三个或者三个以上的“＝” ，然后回车，双直线就自动生成了； 如果你需要绘制波浪线，只要连续输入三个或者三个以上的“～” ，然后回车，波浪线就自动生成了； 如果你需要绘制虚线，只要连续输入三个或者三个以上的“*” ，然后回车，虚线就自动生成了； 如果你需要绘制细直线，只要连续输入三个或者三个以上的“－” ，然后回车，直线就自动生成了； 如果你需要绘制实心线，只要连续输入三个或者三个以上的“＃” ，然后回车，实心线就自动生成了。 删除 如果不想自动变成分割线，则执行“工具→自动更正选项”命令，弹出“自动更正”对话框，击“键入时自动套用格式”选项卡，在“键入时自动应用”下取消“框线”复选框，确定即可。 如果自动生成框线，立即按backspace删除，或者按ctrl+Z。 修改 如果已经保存了，再打开想删除横线，先选中框线上面的文本（全选），执行“格式”菜单－“边框及底纹”命令，弹出对话框，击“边框”标签卡，在“设置”下面选“无”，确定即可。该方法也可用于修改边框颜色。 这个方法对页眉页脚里的那条默认的横线也适用。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bc82dabe1e33080717d1a05f439f987/" rel="bookmark">
			java中类名.class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类名.class是Class对象的句柄，每个被加载的类在jvm中都会有一个Class对象与之相对应，如果要创建新的对象，直接使用Class对象的局部class.forName就可以了，不需要用new 类名。
在java中，每个class都有一个相应的Class对象，当编写好一个类，编译完成后，在生成的.class文件中，就产生一个class对象，用来表示这个类的类型信息。获得Class实例的三中方式：
1.利用对象调用getClass()方法获取该对象的Class实例；
2.使用Class的静态方法forName()，用类的名字获取一个Class实例；
3.运用.calss的方式获取Class实例，对基本数据类型的封装类，还可以采用.TYPE来获取对应的基本数据类型的Class实例。
范例1：
calss ClassTest { public static void main(String[] args) { //利用对象调用getClass()方法获取该对象的Class实例 Point pt=new Point(); Class c1=pt.getClass(); System.out.println(c1.getName()); //结果:Point //使用Class的静态方法forName()，用类的名字获取一个Class实例 try { Class c2=Class.forName("Point"); System.out.println(c2.getName()); //结果:Point } catch(Exception e) { e.printStackTrace(); } //运用.calss的方式获取Class实例(类) Class c3=Point.calss; System.out.println(c3.getName()); //结果:Point //运用.calss的方式获取Class实例(基本类型) Class c4=int.calss; System.out.println(c4.getName()); //结果:int //运用.calss的方式获取Class实例(基本数据类型的封装类) Class c5=Integer.TYPE; System.out.println(c5.getName()); //结果:int Class c6=Integer.class; System.out.println(c6.getName()); //结果:java.lang.Integer //以下结果是： before new Point() loading point after new Point() loading Line //当new Point()的时候加载这个类，用forName构造实例的时候也加载该类。 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bc82dabe1e33080717d1a05f439f987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d995749da02ecf5fed86f65ec757d4/" rel="bookmark">
			Qt窗口屏幕居中显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置窗口居中显示
方法一：在窗口(QWidget类及派生类)的构造函数中添加如下代码：
#include &lt;QDesktopWidget&gt;
//.......
QDesktopWidget* desktop = QApplication::desktop(); // =qApp-&gt;desktop();也可以
move((desktop-&gt;width() - this-&gt;width())/2, (desktop-&gt;height() - this-&gt;height())/2);
//.......
重新编译后，该窗口启动时在屏幕居中的位置。
方法二：在调用show()函数后调用move()函数,j将窗口移动到屏幕中央。
#include &lt;QDesktopWidget&gt;
int main(int argc, char *argv[])
{
QApplication a(argc, argv);
MainWindow w;
w.show();
w.move ((QApplication::desktop()-&gt;width() - w.width())/2,(QApplication::desktop()-&gt;height() - w.height())/2);
return a.exec();
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f901f71e7eb0441ac5bc23e1fbb851b2/" rel="bookmark">
			用XAMPP搭建Web服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的集成软件包。
它可以在Windows、Linux、Mac OS X和Solaris四种操作系统下安装使用，并且支持多语言：英文、简体中文等。
1. 安装
http://www.apachefriends.org/zh_cn/xampp.html
一路Next即可。
2. 启动
启动Apache和MySql后，我们就可以通过http://localhost/ （或服务器主机地址）访问XAMPP了。如果浏览器里显示的是下面的页面，那么XAMPP安装成功了。
3.目录
熟悉apache配置的话，可以还会用到一下一些目录：
Web程序(PHP、Html)都放到 xampp\htdocs\ apache基础配置：xampp\apache\conf\extra\httpd.conf apache更多配置(如虚拟主机等)文件：xampp\apache\conf\extra\ php配置文件：xampp\apache\bin\php.ini 其中目录 xampp\htdocs\ 是我们最为常用的目录里。我们今后开发的html、javascript、CSS和其他一些资源文件都将放在这个目录或其子目录中。如果您将 test.html 文件放在这里，您可以通过 http://localhost/test.html 来访问它。php 或 cgi 文件也同样放在这里。其他的 WWW 子文件夹可以在 htdocs 目录下创建。例如将 test.html 放在 .\xampp\htdocs\new 路径下，您就可以在浏览器的地址栏中输入 http://localhost/new/test.html 来访问这个文件。
（From ： http://developer.nokia.com/Community/Wiki/%E7%94%A8XAMPP%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b39ca89dc3cac47b87d34da5e3b4a0aa/" rel="bookmark">
			慎用mysql max()函数，可通过走索引替换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql max() 函数的需扫描where条件过滤后的所有行：
在测试环境中重现：
测试版本：Server version: 5.1.58-log MySQL Community Server (GPL)
testtable表中的索引
mysql&gt; show index from testtable; +-----------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+ | Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | +-----------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+ | testtable | 0 | PRIMARY | 1 | id | A | 2 | NULL | NULL | | BTREE | | | testtable | 1 | key_number | 1 | number | A | 2 | NULL | NULL | YES | BTREE | | +-----------+------------+------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+ 对比的sql为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b39ca89dc3cac47b87d34da5e3b4a0aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a38f671fa71ee618a508248344274768/" rel="bookmark">
			YUM 提示 Segmentation fault （段错误）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用yum 更新软件时提示：
Segmentation fault
中文错误提示： 段错误 清楚是由于自己编译安装了zlib，并且修改/etc/ld.so.conf，加入/usr/local/zlib/lib ，
导致系统里面有两个版本的zlib，使用ldconfig -v|grep libz 可查看到两个版本的zlib，
libz.so.1 libz.so.1.2.3
libz.so.1 libz.so.1.2.7
于是，注释掉/etc/ld.so.conf里面的zlib：
include ld.so.conf.d/*.conf
#/usr/local/lib // 注释掉
执行一次 ldconfig，再yum update，完全恢复正常。
2016年12月5日：
报段错误，
移走/usr/local/lib/lib/libz_cc.so.1.2.7 到其他目录
yum clean yum install git
可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe8c46b637675ab1cb82413fe544faf6/" rel="bookmark">
			消除“Permission is only granted to system apps”错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在AndroidManifest.xml中使用了如下的配置：
&lt;uses-permission android:name="android.permission.INSTALL_PACKAGES" /&gt;
就会报错：Permission is only granted to system apps
原因如下：
此类权限仅授予系统级应用，可以修改下Link Error Checking项的安全级别；
In Eclipse: Window -&gt; Preferences -&gt; Android -&gt; Lint Error Checking
在ID列表中，找到ID = ProtectedPermission，设置Serverity低于Error，比如Warning级别就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/526c8299dc36eb4d12131709cf86c028/" rel="bookmark">
			经验风险与结构风险
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		偏差与方差(bias and variance) 在回归问题中,我们用一个简单的线性模型来拟合样本,称为线性回归,如图1;或者用更复杂,高维的函数来拟合,比如二次函数得到图2,六次函数得到图3.
我们可以看出来, 六次函数完美地拟合了六个点,误差为0.但是,当我们用这样的拟合模型来进行预测的时候,效果反而不好.
通过观察我们发现,二次的模型也许能够更好地拟合这些样本分布.
虽然1,3图都不能很好地拟合真实分布,但是他们的问题是很不一样的.
我们暂且称图1的问题为偏差(bias),图3的问题为方差(variance).
一般误差与经验误差 我们来定义如下几个概念:
1. 一般误差:
指的是,我们使用拟合的模型,在任意样本下,得到的误差.也就是模型的真实误差,也称一般误差.
2. 经验误差:
指的是训练样本的误差,也就是上图中拟合函数对于这几个点的误差.因为这些误差是基于训练样本的,也就是基于已知经验的,称为经验误差.
在机器学习中,我们当然希望拟合的模型能够在更大的集合上有最小的误差.
也就是说,机器学习的目标是,最小化一般误差.
可惜的是,最小化一般误差是NP难题.
于是一般的解决方法就是转而最小化经验误差(ERM).现在许多的机器学习方法也都是基于ERM的.比如概率学的最大释然原则,神经网络等等.
正如上面三幅图所描述的,第三幅图的经验误差是最小的(=0),但是其效果不见得是最好的.也就是说,用经验误差来代替一般误差貌似不是最优的.
ERM介绍 (Empirical risk minimization) 下面用数学语言来描述一般误差(General Risk),经验误差(Empirical Risk)的关系.看看用ER来代替GR有多大的可行性.
ERM合理性 首先是两个引理:
1. 联合概率:A1,Ak表示非独立的随机变量,他们的联合概率有如下性质:
2. 切比雪夫不等式:
Z1,Zm表示m个独立同分布(i.i.d)的随机变量,他们的均值表示为,而原分布的均值未知.
根据大数定理,样本均值收敛于一个以原分布均值为中心的高斯分布,随着m的不断增加,高斯分布的方差减小.
得到上述不等式,也就是切比雪夫不等式.
语言描述,就是:已知样本的均值与原分布均值的误差存在上限.
接着开始我们的证明
现在有n个拟合函数,记为H={h1,h2,…..hn};假设现在的H表示所有一次函数的集合.
ERM的做法是在这n个中,选择一个经验风险最小的h.
切比雪夫不等式的均值换成经验误差(ER)与一般误差(GR),就得到如下结论:
也就是,H中的任意拟合的经验误差都是其一般误差的较好估计,(注意不是最好的一般误差,是任意拟合自己的一般误差).
这个结论直观地来理解就是,训练样本是一般样本的一个子集,满足一般样本的分布. ER存在关于GR的一个上限.
继续来解读这个不等式.
变化不等式,得到:
,其中
K=|H|,也就是拟合函数的VC维.具体什么是VC维,可以进一步去了解,这里不赘述.现在我们简单地理解为拟合函数的维数.
上面证明归纳为:ER与GR的区别存在上限,这个区别随着m的增加而减小.
M也称为样本复杂度.
这个证明的另一种解释就是,想要ERM的误差在一定的范围,训练样本的个数m必须满足一定的大小要求.
上面表明任意拟合函数GR与ER之间的关系;而ERM选择经验风险最小的拟合.继续证明这种选择的正确性.
这个公式很重要,其中h^表示根据ERM原则,选择的有最小ER的h.
h*表示H中一般误差最小的h,也就是我们不解决NP难题之外的最好选择.
:最小经验误差的一般误差
:最小经验误差的经验误差
:最小一般误差的经验误差
:最小一般误差的一般误差
第一个不等式来至与切比雪夫不等式;
第二个来自于h^是我们选择的最小经验误差的拟合函数.
第三个不等式同样来至于切比雪夫不等式.
上面不等式给定了ERM选择与最优选择,他们的一般误差的差异最多不超过2r.
当然,上述的证明还有许多没写出来的,比如我们还要证明所有的经验误差与一般误差区别都很小的概率很大,即一致收敛.
OK,终于证明了.总结一下ERM合理性:
1. 经验误差存在上限,是其一般误差的比较好的估计,不会超过r
2. 选择最小经验误差的拟合函数,其与最佳一般误差函数的差异不会超过2r
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/526c8299dc36eb4d12131709cf86c028/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab8ec46be59983dd30566d0f1e23fd34/" rel="bookmark">
			Binder详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入分析AndroidBinder机制（远程对象访问）
介绍
Binder是什么？它可以叫作：IPC、RPC、线程迁移、远程对象访问，本文中理解它为远程对象访问更贴切些，简而言之就是一个进程能访问另一个进程中的对象，调用该对象的方法，就好像对象在自己的进程中一样，这种访问是同步的访问，当然Binder也能实现异步的通信。
Binder基于C/S架构：
Binder分为Java和C++两套实现，分别用于Java应用和Native应用开发，Java Binder实际上也是基于C++ Binder的一个封装，因此本文只分析C++ Binder。
服务分为2种：Native Service、Android Service。
Native Service：是在系统init阶段通过init.rc脚本建立的服务，完全在C++空间完成的服务。
Androids service：是系统二阶段（init2）初始化时建立的服务，是指在JVM空间完成的服务，虽然也要使用Navite上的框架，但是服务主体存在于Android空间，所有的Androids service都运行在一个进程中：systemsever进程。
实现原理
Binder本质上说就是一种数据传输方式，当通过服务代理调用服务对象的方法时，服务代理把参数序列化进行传输，服务对象反序列化取出参数，然后调用服务对象的方法。
进程间的通信是通过Android专门为Linux增加的一个设备（/dev/binder）来实现的。
本质上是使用了共享内存来进行通信，但该共享内存和我们平常理解会有一点不一样。
我们平常使用的共享内存是两个进程之间，即点到点的，如果有N个进程要两两通信而又不相互干扰，那么就必须有N*N个共享内存。Binder使用的共享内存是进程与binder设备之间，即binder做为一个中间者进行传递，类似会议电视的MCU。
使用了共享内存，在驱动中还是会有一次拷贝的，进程A向进程B传递数据时，数据会被驱动从进程A中拷贝到binder和进程B之间的共享内存中，然后进程B就可以直接读了。
通信过程：
所有要进行通信的进程都得打开/dev/binder设备
binder设备驱动会为每个进程分配一个数据结构binder_proc，每进程中的每个用到了binder通信的线程分配数据结构binder_thread。
binder设备驱动会为服务进程中的每个服务对象分配数据结构binder_node，它隶属于服务进程的binder_proc，是服务端相关的，binder_node中记录了服务对象在服务进程中的地址；会为客户进程中引用的每个服务分配binder_ref，是客户端相关的，binder_ref会指向客户进程引用的服务对象的binder_node。
binder设备驱动为客户进程引用的每个服务都会维护一个handle，它存在于binder_ref中（binder_ref.desc），它就像进程打开某个文件产生的文件描述符一样，进程每引用一个服务，就会分配一个最小未使用的整数作为handle。handle是客户进程相关的，多个进程引用同一个服务得到的handle并不是一样的。
当服务进程向ServiceManager注册服务时，会带上服务的名称字符串，驱动会为服务进程中的服务对象增加一个binder_node，归属于服务进程的binder_proc。
当把注册服务的请求发给ServiceManager时，ServiceManager也是服务对象的一个引用者，驱动会为ServiceManager增加一个binder_ref，指向服务对象的binder_node。驱动把binder_ref.desc（ServiceManager）作为handle返回给ServiceManager，ServiceManager保存此handle和服务名称字符串。
当客户进程向ServiceManager获取服务时，ServiceManager根据服务名称字符串找到服务对象在ServiceManager进程中的handle。在ServiceManager的应答的过程中，驱动根据此handle在ServiceManager进程的binder_proc找到对应的binder_ref，并根据它找到服务对象的binder_node。然后，驱动会为客户进程增加一个binder_ref，指向服务对象的binder_node，最后把binder_ref.desc（客户进程）作为handle返回给客户进程。
客户进程使用得到的handle向服务进程发起请求，驱动会在根据此handle在客户进程的binder_proc查找对应的binder_ref，并找到它指向的binder_node，并找到binder_node所属的binder_proc，最终驱动把请求放入服务进程的接收队列中。
服务进程收到请求后，从binder_node中找到服务对象的地址，然后调用该服务对象。所以，对于服务对象，在客户进程中表现出来的是handle，在服务进程中表现出来的是地址，驱动会对它们进行映射。
Binder框架
概览
框架的层次结构：
说明：
Bn代表服务端，Bp代表代理
ProcessState、IPCThreadState是进程、线程相关，是对Binder驱动的封装
Binder核心库又是对ProcessState、IPCThreadState的封装
C++ Binder框架是对Binder核心库和服务接口的封装
类关系图：
`
说明：绿色部分是用户编写应用程序需要实现的
IPCThreadState、ProcessState、Binder关系图：
对于Binder核心库：
IBinder：是一个接口，被BpBinder、Bbinder继承
BpBinder：客户端，内部有一个成员mHandle记录了远程服务对象的handle
BpRefBase：客户端，内部有一个成员指向BpBinder，采用的是Bridge设计模式，实际是是通过BpBinder来完成通信
Bbinder：服务端
对于C++ Binder框架：
Iinterface：主要是定义了asBinder()、纯虚函数onAsBinder()，asBinder()直接调用onAsBinder()，onAsBinder()分别在BnInterface、BpInterface中进行了实现，用于获取BnInterface、BpBinder的地址，即IInterface的作用是通过接口获取对应的Binder对象的本地地址/代理BpBinder的地址。
BpInterface&lt;XXX&gt;：是一个接口，一个模板类，是一个粘合类，即继承BpInterface&lt;XXX&gt;便等同于同时继承IXXX和BpRefBase。
BnInterface&lt;XXX&gt;：是一个接口，一个模板类，是一个粘合类
对于用户实现：
IXXX：是一个接口类，继承IInterface，定义服务的方法，即纯虚函数method_1()等，不能被实例化
BpXXX：是一个实现类，实现了IXXX中的纯虚函数，因为不是接口类，这个实现类不需要在接口中体现（即不需要在接口的头文件中体现，如：IMediaPlayer.h），它封装了IXXX的操作和BpBinder的操作；
BnXXX：仍是一个接口类，未实现IXXX中的纯虚函数，不能被实例化，需要一个真正工作的类来继承、实现它，这个类才是真正执行具体功能的类。BnXXX仅实现了虚函数onTransact()（在BBinder::transact()被调用）。
XXX：实现BnXXX，会有一个XXX::instantiate()函数来注册服务。
Binder驱动
源代码：
kernel\drivers\staging\android\binder.h
kernel\drivers\staging\android\binder.c
参见下文驱动源代码的分析
Binder Adapter
源代码：
frameworks\base\include\binder\IPCThreadState.h
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab8ec46be59983dd30566d0f1e23fd34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c1dffeb74c2af3c7a991338ae289557/" rel="bookmark">
			【php】获取http请求body数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在php中，我们习惯使用get/post方式获取参数值，但对于有些自定义http协议，会有特定的格式，php通过常规解析并不能获取这些数据。这时候我们可以通过获取body，用特定的格式去解析body来得到想要的数据。关键是怎么获取body。
通过查阅发现php有以下方法http_get_request_body，在实际使用时php并没有识别此方法（即此方法不可用）。但是在下面的注释中发现
&lt;?php
$body = @file_get_contents('php://input');
?&gt;
通过以上方法可以获取body值，在实际测试中也没问题。不过在php5中建议用HttpResponse，没仔细研究，应该也可以。
详细可参考http://www.php.net/manual/zh/function.http-get-request-body.php
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd09028957fee4ca2851d4b9a8cc82ad/" rel="bookmark">
			我的博客搬家了！ 新地址：http://www.cnblogs.com/jubincn/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选来选去，还是cnblog比较能满足我的需求，如果国内有免费workpress就好了。
http://www.cnblogs.com/jubincn/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e7d7f27c7b21f4d295c58256ba10cc3/" rel="bookmark">
			Android颜色值(RGB)所支持的四种常见形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android中颜色值是通过红(Red)、绿(Green)、蓝(Blue)三原色，以及一个透明度(Alpha)值来表示的，颜色值总是以井号(#)开头，接下来就是Alpha-Red-Green-Blue的形式。其中Alpha值可以省略，如果省略了Alpha的值，那么该颜色默认是完全不透明的。
Android的颜色值支持常见的四种形式如下所示：
#RGB:分别指定红、绿、蓝三原色的值（只支持0~f这16级颜色）来代表颜色。 #ARGB:分别指定红、绿、蓝三原色的值(只支持0~f这16级颜色)及透明度(只支持0~f这16级透明度)来代表颜色。 #RRGGBB:分别指定红、绿、蓝三原色的值（支持00~ff这256级颜色）来代表颜色。 #AARRGGBB:分别指定红、绿、蓝三原色的值(支持00~fff这256级颜色)及透明度(支持00~fff这256级透明度)来代表颜色。 上面四种形式中，A、R、G、B都代表一个十六进制的数，其中A代表透明度，R代表红色的数值，G代表绿色数值，B代表蓝色数值。 附录：关于RGB颜色查询对照表可以查看：RGB颜色查询对照表 转载于:https://www.cnblogs.com/android100/p/android-rgb4.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0bdccec1d3d2b4e3e78b951ab41bc1/" rel="bookmark">
			Unable to process Jar entry [COM/ibm/db2os390/sqlj/custom/DB2SQLJCustomizer.class]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
Unable to process Jar entry [COM/ibm/db2os390/sqlj/custom/DB2SQLJCustomizer.class] from Jar
[jar:file:/E:/DEVELOPER/workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp3/wtpwebapps/nwprj_v2/WEB-INF/lib/db2jcc.jar!/] for annotations
org.apache.tomcat.util.bcel.classfile.ClassFormatException: null is not a Java .class file
解决办法：
打开tomcat\conf\catalina.properties文件
tomcat.util.scan.DefaultJarScanner.jarsToSkip节点增加db2jcc.jar
然后重新启动tomcat，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e5ec39fe07acf000e258c5e1cbc008/" rel="bookmark">
			hbase存储结构及客户端访问hbase表的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要说明客户端访问/操作hbase表，先简要说明hbase表的存储结构。
Hbase最初有一个表，则一个表对应一个region，随着表增大，一个region会分为多个region，即一个表对应了多个region。Region是hbase存储的最小单位，不能分割，即一个region内的数据只能存在一个服务器，但是一个表的所有region可以分布在不同的server上(hregionserver)。如下图：
可见region分布分散，而记录table表的region分布信息的元数据存储在.META.中。这个表也会随着内容增加而分割为多个region，记录.META.的region的元数据存储在-ROOT-表中。最后由zookeeper记录-ROOT-表的位置信息。
所以，看出客户要访问hbase的某个表，要先通过zookeeper找到-ROOT-表，然后找到.META.表，最后找到table。如下图：
所以，我们要操作hbase的数据，第一步必须通过zookeeper。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/effb4e4ee25c69fd8ee51f901d16c23e/" rel="bookmark">
			FreeRTOS STM32移植笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 【1】其实说不上移植笔记，FreeRTOS已经移植至众多平台（MCU），包括MSP430，STM32等，这份笔记完全建立在官方代码的基础之上，简单的说就是修改一些设置从而完成一个呼吸灯实验。
【2】虽然有官方移植代码，但是官方移植版本为STM32的V2.X库，与现在流行的V3.5有比较大的区别。本笔记也是总结网上几篇学习笔记，主要说明如果使用V3.5库，需要做哪些修改。
【3】编译软件为IAR EWARM 6.5。
【相关博文】
【FreeRTOS学习笔记——任务间使用队列同步数据】——如何使用FreeRTOS队列。
【如何在FreeRTOS下实现低功耗——MSP430F5438平台】——如何通过空任务实现系统低功耗。
2.FreeRTOS需要哪些文件 FreeRTOS的文件结构非常简单，移植或者版本升级替换也非常方便。
1)与FreeRTOS内核有关的文件数量仅为3个，分别是list.c queue.c tasks.c
该文件位于FreeRTOS\Source
2)与内存分配有关的文件共有4个，分别是heap_1.c,heap_2.c,heap_3.c,heap_4.c。4个文件只需选择其中的1个，STM32选择heap_2.c。
该文件位于FreeRTOS\Source\portable\MemMang
3)与移植相关的代码包括port.c,portasm.s,portmacro.h。这些代码不但和编译器有关还和平台（MCU）有关。FreeRTOS先以编译器为大类，然后再以平台（MCU）为小类。在这里选择IAR编译器，平台为ARM_CM3。
该文件位于FreeRTOS\Source\portable\IAR\ARM_CM3
4)除了上述内容之外，还包括FreeRTOS内核相关的头文件。
该文件FreeRTOS\Source\include
3.必要的工程设置 开始之前需要引入V3.5库相关头文件，启动代码和CMSIS库。
在IAR中设置相关头文件的路径（应根据实际情况修改）
$PROJ_DIR$\CMSIS
$PROJ_DIR$\StdPeriph_Driver\inc
$PROJ_DIR$\User
$PROJ_DIR$\FreeRTOS\Source\include
$PROJ_DIR$\FreeRTOS\Source\portable\IAR\ARM_CM3
当然头文件的路径并不是绝对的，只要明确头文件在哪，设置正确路径即可。
除了设置C代码的相关头文件之外，还需要设置汇编代码的头文件路径，由于很少设置汇编代码头文件路径，往往初次移植FreeRTOS会在此处遇到一些“困难”。（当然也包括我）
由于portasm.s需要FreeRTOSConfig.h中的相关宏定义，所以要根据FreeRTOSConfig.h的位置来设置汇编代码的头文件路径，本例中FreeRTOSConfig.h位于User文件夹，所以设置如下图所示。
图1 设置ASM头文件搜索路径
4.修改启动代码 由于SVC_Handle,PendSV_Handle和SysTick_Handle在portasm.s中被重定义，所以需要在启动代码中修改这些中断向量的名称，并声明这些中断向量为外部函数。这也是初次使用FreeRTOS容易范的错误。具体修改如下所示。
图2 启动代码修改
请注意，在汇编代码中";"代表注释。EXTERN和C语言的extern含义相同——意为外部函数(变量)。
EXTERN __iar_program_start
EXTERN SystemInit EXTERN vPortSVCHandler ;@
EXTERN xPortPendSVHandler ;@
EXTERN xPortSysTickHandler ;@
PUBLIC __vector_table
声明vPortSVCHandler，xPortPendSVHandler和xPortSysTickHandler为外部函数。
vPortSVCHandler对应SVC_Handler xPortPendSVHandler对应PendSV_Handle
xPortSysTickHandle对应SysTick_Handle
5.代码实现 经过了以上修改之后，就可以轻松实现基于FreeRTOS的呼吸灯了。代码如下：
/* Standard includes. */ #include &lt;stdio.h&gt; /* Scheduler includes. */ #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/effb4e4ee25c69fd8ee51f901d16c23e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43b5cc590cbd2d79ce45065f7a667554/" rel="bookmark">
			java GUI中JTextField的requestFocus()方法获取不到焦点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，JFrame.pack()方法为适应屏幕大小的方法，所以，requestFocus（）方法必须要在pack（）方法之后调用，不然就会失效。
下面说说我经常用到的java gui中的一些方法吧！
1.JPanel.setBorder(BorderFactory.createTitledBorder("名字"));
2.JScrollPane.setViewportView(JTextArea);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/266c985851c1a0c0310237de2a36b79a/" rel="bookmark">
			keyword in Jpa
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Between findByStartDateBetween … where x.startDate between 1? and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/266c985851c1a0c0310237de2a36b79a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/563/">«</a>
	<span class="pagination__item pagination__item--current">564/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/565/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>