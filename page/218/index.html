<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d5b49d140a9f096cbd83d2d1dce9b0/" rel="bookmark">
			vue取消接口请求（最简版教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目实际开发中，会遇到需要主动取消后端接口请求的需求
常见的情况是：接口返回时间过长，用户在未返回之前就进入或返回了其他页面，此时需要取消进行中的请求，使逻辑更完整更加优雅。
直接复制关键代码，直接使用！ 接口js文件 注: 我是把所有请求封装在了单独的js文件中，注意关键代码即可 // 封装好的接口文件 import axios from 'axios' // 关键代码 const CancelToken = axios.CancelToken // 关键代码 //方法传参多加一个 that传进去 export function userLoginCA(data, that) { return request({ url: 'user/login', method: 'post', data, // 关键代码 cancelToken cancelToken: new CancelToken(function executor(c) { that.cancel = c }) }) } 页面中引用 import { userLoginCA } from '@/api/user' // 调用 userLoginCA 方法时除了需要的参数，记得传this进去 userLoginCA({ loginPath: this.loginCode.loginPath.CA, accountType: this.loginCode.accountType.NATURE },this) .then((res) =&gt; {}) .catch((res) =&gt; {}) } 在需要调用取消的地方 执行 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d5b49d140a9f096cbd83d2d1dce9b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa5d218398315b082f5f7e6bbaa2a1b6/" rel="bookmark">
			Android开发 ConstraintLayout布局的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我们先了解下约束布局的优势：
1.嵌套少，性能提高。因为View位置是互相关联的，所以不需要像线性布局一样需要有很多父类容器辅助View定位。
2.更快的编写xml布局，提高工作效率。熟练后可以使用Android studio快速拖拉组件来实现布局，但是前期建议好好了解ConstraintLayout的属性
3.View的定位灵活度更大，可以动态的跟随其他View的位置改变而改变。
4.可阅读性强，这点可能很多人会质疑:“一堆View平铺有什么阅读性啊”。 但是事实是，嵌套多层的线性布局或者相对布局反而更难以阅读，因为你需要关注父类布局提供的辅助定位信息。
学习定位属性 这里的定位属性指的是 layout_constraintTop_toTopOf 、layout_constraintTop_toBottomOf 、 layout_constraintStart_toEndOf 等等此类属性。
为了方便后续理解，这里说明下此类定位属性的意思。此类定位属性在文本上想表达的是 当前View 在 定位View 什么位置上。
这里举几个例子，例如：
layout_constraintTop_toBottomOf 这个属性的意思是 当前View的上边（Top）在 目标View的下边(Bottom)
layout_constraintTop_toTopOf 这个属性的意思是 当前View的上边(Top) 在 目标View的上边(Top)
这个时候估计有人会疑问，什么是当前View，什么是定位View啊。
当前View是指：你添加了 layout_constraintTop_toBottomOf 这个属性的View
定位View是指：app:layout_constraintTop_toBottomOf="@id/quit" 后面添加的id ，这里@id/quit 就是定位的View。 所以，使用约束布局还有一个特点就是基本上每一个View都要写上id。
layout_constraintTop_toBottomOf 当前View的Top在目标View的Bottom 效果图（注意图片中的箭头）:
xml
&lt;Button android:id="@+id/btn2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="50dp" android:text="按键2" app:layout_constraintTop_toBottomOf="@id/btn1" /&gt; 方便观看这里增加了上边距50dp
layout_constraintBottom_toTopOf当前View的Bottom在目标View的Top 效果图：
xml
&lt;Button android:id="@+id/btn2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="按键2" android:layout_marginBottom="50dp" app:layout_constraintBottom_toTopOf="@id/btn1" /&gt; layout_constraintLeft_toRightOf 与 layout_constraintStart_toEndOf 当前View的Left在目标View的Right layout_constraintLeft_toRightOf 与 layout_constraintStart_toEndOf 这2个属性其实都是一个意思，都是当前View的Left在目标View的Right。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa5d218398315b082f5f7e6bbaa2a1b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02118dcfe42d2ee34716293899f099fb/" rel="bookmark">
			你会求两个数的最大公约数吗（三种方法）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、枚举法
二、辗转相除法
三、更相减损法
前言 如何求两个数的最大公约数是非常经典的问题，求解的方法也有很多，本文主要介绍其中的三种方法，分别是：枚举法、辗转相除法和更相减损法。
一、枚举法 两个数的最大公约数一定小于或等于两数中较小的数，并且这两个数必定至少存在一个公因数 1，利用这两个条件，可以将两个数的最大公约数的所有可能都列举出来。
#include &lt;stdio.h&gt; int main() { int a = 0; int b = 0; int min = 0; scanf("%d%d", &amp;a, &amp;b); if (a &gt; b) min = b; else min = a; for (int i = min; i &gt; 0; i--) // i：min -&gt; 1 { if (a % i == 0 &amp;&amp; b % i == 0) { printf("的最大公约数为 %d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02118dcfe42d2ee34716293899f099fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32dbd101f9378cb71b6018232df9e539/" rel="bookmark">
			xml注入漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、先认识XML XML有两个先驱——SGML（标准通用标记语言）和HTML（超文本标记语言），这两个语言都是非常成功的标记语言。SGML多用于科技文献和政府办公文件中，SGML非常复杂，其复杂程度对于网络上的日常使用简直不可思议。HTML免费、简单，已经获得了广泛的支持，方便大众的使用。而XML（可扩展标记语言）它既具有SGML的强大功能和可扩展性，同时又具有HTML的简单性。
XML注入攻击也称为XXE（XML External Entity attack）漏洞，XML文件的解析依赖于libxml库，libxml 2.9及以前的版本默认支持并开启了外部实体的引用，服务端解析用户提交的XML文件时未对XML文件引用的外部实体（含外部普通实体和外部参数实体）进行合适的处理，并且实体的URL支持file://和php://等协议，攻击者可以在XML文件中声明URI指向服务器本地的实体造成攻击。
XXE漏洞一旦被攻击者利用，可以读取服务器任意文件、执行任意代码、发起DDos攻击。
在XML中引入外部实体一定要注意其安全性，需要进行严格的检查，或者禁止引入。
（1）对用户的输入进行过滤，如&lt;、&gt;、"、"、&amp;等。
（2）常见的XML解析方法有DOMDocument、SimpleXML、XMLReader，这三者都基于libxml库解析XML，所以均受影响。xml_parse()函数则基于expact解析器，默认不载入外部DTD，不受影响。可以在PHP解析XML文件之前使用libxml_disable_entity_loader(true)来禁止加载外部实体（对上述三种XML解析组件都有效），并使用libxml_use_internal_errors()禁止报错。
二、XML 与 HTML 的主要差异 XML 被设计为传输和存储数据，其焦点是数据的内容。
HTML 被设计用来显示数据，其焦点是数据的外观。
HTML 旨在显示信息 ，而 XML 旨在传输信息。
三 、DTD 文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。 DTD如果存在那么一定会被包裹在 DOCTYPE 声明中 ，DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。不过，XML对于标记的语法规定比HTML要严格地多
区分大小写，在标记中必须注意区分大小写，在XML中，&lt;TEST&gt;和&lt;test&gt;是两个截然不同的标记要有正确的结束标记，结束标记除了要和开始编辑在拼写和大小上完全相同，还必须在前面加上一个斜杠“/”。若开始标记&lt;test&gt;，结束标记则为&lt;/test&gt;。XML严格要求标记配对，HTML中的&lt;br&gt;、&lt;hr&gt;的元素形式在XML中是不合法的。当一对标记之间没有任何文本内容时，可以不写结束标记，在开始标记的末尾加上斜杠”/”来确认，例如：&lt;test /&gt; 这样的标记被称为“空标记”。标记要正确嵌套，在一个XML元素中允许包含其他XML元素，但这些元素之间必须满足嵌套性有效使用属性，标记中可以包含任意多个属性。在标记中，属性以名称/取值对出现，属性名不能重复，名称与取值之间用等号“=”分隔，且取值用引号引起来。 举子：&lt;衣服 品牌=“耐克” 类型=“T恤” &gt;
四、 XML基础 XML声明：&lt;?xml version="1.0" encoding="utf-8" ?&gt;
内部DTD声明：&lt;!DOCTYPE 根元素名称 [元素声明]&gt;
在DTD中定义属性：&lt;!ATTLIST 元素名 (属性名 属性类型 缺省值)*&gt;
外部实体声明：&lt;!ELEMENT 实体名称 SYSTEM “URI/URL”&gt;
xml包括xml声明、文档类型定义（可选）、文档元素，如下图所示：
五、XML文件引用DTD的方式 内部直接定义DTD 引用外部DTD 六、xml原理 七、xml分类 ① 普通xml攻击 （1）xml原理 XML注入攻击和SQL注入攻击的原理一样，利用了XML解析机制的漏洞，如果系统对用户输入"&lt;","&gt;"没有做转义的处理，攻击者可以修改XML的数据格式，或者添加新的XML节点，就会导致解析XML异常，对流程产生影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32dbd101f9378cb71b6018232df9e539/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935e4bdb51e78364c50965d1102a16ed/" rel="bookmark">
			HAL库函数中的HAL_I2C_Mem_Write /HAL_I2C_Mem_Read中的DevAddress解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在HAL库函数中的HAL_I2C_Mem_Write /HAL_I2C_Mem_Read两个函数的作用就是玩IIC设备中写入/读取多个直接的数据,
函数原型:
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout); HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout); 两个函传入的参数中都需要DevAddress, 以AT24C02为例,
/* * AT24C02 2kb = 2048bit = 2048/8 B = 256 B * 32 pages of 8 bytes each * * Device Address * 1 0 1 0 A2 A1 A0 R/W * 1 0 1 0 0 0 0 0 = 0XA0 * 1 0 1 0 0 0 0 1 = 0XA1 */ #define ADDR_24LCxx_Write 0xA0 #define ADDR_24LCxx_Read 0xA1 上面的这个是EEPROM设备的写地址和读地址,,一般是这种定义的,但是在野火的HAL案例中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935e4bdb51e78364c50965d1102a16ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a9debd5593b5b80680b497266b5b20/" rel="bookmark">
			使用python脚本实现对apk进行签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用python脚本实现对apk进行签名
场景：
1.检查apk中是否含有签名
2.若apk中带有签名时，对其进行二次签名（若重签名后的程序运行崩溃，则apk进行绑定证书或者含有签名校验）。
3.若apk中不带有签名，直接对其进行签名。
直接执行sign_apk函数，输入参数就可以运行。
if __name__ == "__main__": path1 = "D:\\apk\\demo.apk" name = os.path.basename(path1) sign_dirs = "D:\\sign_apk"" sign_path = os.path.join(sign_dirs, name) sign_apk(path1, sign_path) 1.sign_apk函数
若apk中已经带有签名，则使用jarsigner对apk签名会签名失败
所以先判断该apk中是否带有签名信息，若有签名，需要删除，若无签名，可以直接签名。
参数path:指apk的全路径，比如D:\apk\demo.apk
参数sign_path：指重新签名后的apk的全路径，比如D:\sign_apk\demo.apk
参数back_apk_path：值将原apk拷贝到指定的目录，比如D:\back_apk\
import os import subprocess import shutil import zipfile # 对android apk签名 def sign_apk(path, sign_path): name = os.path.basename(path) back_apk_path = "D:\\back_apk\\" pro_app_path = os.path.join(back_apk_path, name) # 将原程序拷贝到其他指定路径下，防止和原程序有冲突 shutil.copyfile(path, pro_app_path) # 参考meta_inf_check函数的代码 value = meta_inf_check(pro_app_path) if value is True: print("程序带有签名，需要删除清单，才能重新签名") ext = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a9debd5593b5b80680b497266b5b20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8045e2cb10e4086acc0e2f524e08649f/" rel="bookmark">
			RocketMQ 是怎么保证消息不丢失的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*大家项目中选择rocketMQ来作为消息中间件的原因很多都是为了保证消息不丢失吧，那rocketMQ是怎么做到的呢，应该如何做才能避免消息丢失，一起来看看吧～～
首先我们知道rocketmq的一个消息从生产到最终的消费过程需要经历总共三个阶段，或者说会经过三个地方，分别是producer的发送端、broker的持久化机制、以及consumer的消费端
从生产者producer的角度：消息生产之后传递到broker，如果消息未能正确的存储到broker中，算作消息丢失
从broker的角度：消息默认保存到broker的内存中，异步保存到磁盘上，如果发生宕机、磁盘崩溃会造成消息丢失
从消费者consumer的角度：消息完成了持久化之后，consumer拉取之后未能成功消费且未反馈给broker，这样算作消息丢失，可能消费过程异常或者网络抖动造成消息丢失
生产者角度：消费生产之后传递到broker，如果消息未能正确的保存到broker中，算作消息丢失
从生产者的角度，生产了消息就是要通过网络发送到broker，其实只需要保证一点，就是确认这个消息已经成功发送到broker上了
生产者只需要接收发送消息返回的确认响应即可，就可以代表消息发送成功
代码示例：
DefaultMQProducer mqProducer=new DefaultMQProducer("test");// 设置 nameSpace地址mqProducer.setNamesrvAddr("namesrvAddr");mqProducer.start();Message msg = new Message("topic" /* Topic */, "Captain".getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */);// 发送消息到Brokertry { SendResult sendResult = mqProducer.send(msg);} catch (Exception e) { e.printStackTrace();} 当然，发送消息也分为同步和异步两种，消息发送成功之后会返回下面这四种不同的响应状态
SEND_OK
消息发送成功，但是也并不意味这完全代表不会丢失消息，这还要取决于broker的刷盘方式
这个下面在broker方面会说，需要启动SYNC_MASTER或SYNC_FLUSH。（也就是同步）
FLUSH_DISK_TIMEOUT
如果Broker设置MessageStoreConfig的FlushDiskType = SYNC_FLUSH（默认为ASYNC_FLUSH），并且Broker没有在MessageStoreConfig的syncFlushTimeout（默认为5秒）内完成刷新磁盘，得到这个状态
也就是此时刷盘超时，未能在规定时间内落到硬盘上，检查设置是否合理、硬盘大小等情况
FLUSH_SLAVE_TIMEOUT
如果Broker的角色是SYNC_MASTER（默认为ASYNC_MASTER），并且从属Broker未在MessageStoreConfig的syncFlushTimeout（默认为5秒）内完成与主服务器的同步，返回这个结果
主从同步时间默认也是5秒，需要完成主从同步，这个下面在说broker的时候也会说到，你想啊，要是master挂了或者磁盘崩溃了，这是不是也不能百分百保证消息不丢失
SLAVE_NOT_AVAILABLE
如果Broker的角色是SYNC_MASTER（默认为ASYNC_MASTER），但没有配置slave Broker，返回这个状态
这个在保证消息绝对不丢失的情况下是不允许存在的，这个状态也是属于需要处理的，没有可靠的slave，也就意味着没有可靠的备份数据，所以这种情况也需要考虑
另外呢，上面还说了一种异步的消息发送方式，这种一般是用于链路较长，对于时间比较敏感的业务
这种情况下需要特别注意的就是我们需要设置消息发送完成的回调，这样才能更好的保证消息不丢失 采取事务消息的投递方式，并不能保证消息100%投递成功到了Broker，但是如果消息发送Ack失败的话，此消息会存储在CommitLog当中，但是对ConsumerQueue是不可见的
可以在日志中查看到这条异常的消息，严格意义上来讲，也并没有完全丢失
broker：消息默认保存到broker的内存中，异步保存到磁盘上，如果发生宕机、磁盘崩溃会造成消息丢失
顺序消费这个场景其实不是特别的常见，但是也是必不可少的，因为在某些业务场景下顺序是很关键的，保证消息的消费顺序也是很关键
消息到了broker之后，默认是优先保存到broker的内存中，然后立刻返回响应给生产者producer，然后broker自己定期将消息批量的异步的保存到硬盘上
有的小伙伴一小子就发现了问题不是那么简单，消息来了之后还没保存到硬盘，就直接返回了，broker直接宕机崩溃了，那这消息岂不无迹可寻了
这样的优点是提高交互的效率，同时减少IO的次数，问题就是会造成消息丢失
如果我们想要保证消息不丢失，那就需要保证消息成功保存到broker之后才可以返回，只需要将消息的保存机制修改为同步刷盘的方式，也就是只有消息保存到broker的磁盘成功之后，才会返回响应
## 默认情况为 ASYNC_FLUSH flushDiskType = SYNC_FLUSH 如果broker未能在规定的同步时间（默认5秒）完成刷盘，将返回FLUSH_DISK_TIMEOUT给生产者
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8045e2cb10e4086acc0e2f524e08649f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68fbb69acff4b3812726208b9594746/" rel="bookmark">
			50行代码的微信公众号抢号脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import re from selenium import webdriver from selenium.webdriver.chrome.service import Service from selenium.webdriver.common.by import By import time import random from tkinter import messagebox, Tk def PolledDoctor(url, browser, interval): while(1): browser.get(url) browser.implicitly_wait(10) names = browser.find_elements(By.CSS_SELECTOR, '.doctorname') status = browser.find_elements(By.CSS_SELECTOR, '.doctoryuyue.flex.flex-align-center.flex-pack-center') for i in range(len(names)): if names[i].text == 'xxx': index = i break names[i].click() browser.implicitly_wait(10) windows = browser.window_handles browser.switch_to.window(windows[-1]) try: knowing = browser.find_element(By.CSS_SELECTOR, '.knowimg') knowing.click() windows = browser.window_handles browser.switch_to.window(windows[-1]) except: print("No knowing blcok"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c68fbb69acff4b3812726208b9594746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df9c91dce7030f41d656954fa65c9805/" rel="bookmark">
			接口测试必备技能 - 加密和签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是加密以及解密？
加密：在网络上传输的原始数据（明文）经过加密后形成（密文）传输，防止被窃取。
解密：将加密还原成原始数据
2、加密方式分类？
对称式加密：对加密和解密使用的是同一个密钥
非对称式加密：非对称式加密需要两个密钥（双钥），分别叫公钥和秘钥，这两把秘钥可以互相加解密，公钥公开的，不需要保密，私钥是保密的。
01 加密方式详解 1、加对称密技术：
DES加密算法：加密安全性弱，一般应用于旧的系统里面
AES加密算法：一般用于前后端分离的接口加密
Base64加密算法：编码的方式
2、非对称加密技术（RSA加密算法）
RSA加密算法：最有影响力的加密算法
场景1：通过公钥加密
通过私钥解密
两个用户。A和B，B有双钥，A想要把一个数据报文通过加密的方式传给B。
① B把自己的公钥发送给A（公钥是公开的）
② A使用这个公钥把数据报文进行加密，加密完成传给B（加密后的密文通过网络传给B）
③ B使用自己的秘钥解密得到数据报文
场景2：私钥加密：数字签名
公钥解密：验证签名
数字证书由来：因为公钥是公开的不安全，所以需要第三方的CA（数字证书颁发机构）对公钥进行加密，加密后的东西就叫数字证书。数字证书包括：B用户基本信息以及B公钥的信息，部分证书也附有有效期。X509的标准
CA：双钥，通过私钥加密
验证签名：身份验证。
两个用户。A和B，B有双钥
① B把需要发送的数据报文通过私钥加密。
② B找到CA把自己的公钥做认证
③ CA就用自己的私钥对B的公钥和一些相关的信息一起加密，生成数字证书
④ CA就会把数字证书发给B
⑤ B将密文和数字证书都传给A
⑥ A用CA的公钥去解开数字证书，拿到B的公钥，在使用公钥解密密文，从而得到数据报文
Fiddler不能直接抓取https协议的数据报文，需要安装一个数字证书
https协议=http协议+SSL安全传输协议
SSL安全传输协议：安全套接层。
NetScape（B）研发，Fiddler（A），CA把数字证书发到网上，数字证书生成器。
3、MD5（完全不考虑解密，也叫做哈希算法，散列算法）
Postman举例：在Tests中 //获得当前时间戳 new times = new Date().getTime() //使用MD5加密 var miwen = CryptoJS.MD5("admin").toString().toUpperCase() Jmeter 函数助手：__digest ${__digest(MD5.admin,,,)} 02 接口签名 1、什么是接口签名？
使用用户名，密码，时间戳和所有的排序过的参数组合起来，再加密得到的字符串，字符串是唯一的有权访问第三方金融接口的鉴权码=sign接口签名。
2、为什么要做接口签名？
防伪装攻击
防篡改攻击
防存放攻击
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df9c91dce7030f41d656954fa65c9805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe7b7168e404d5853795f8a5ad225b4/" rel="bookmark">
			Linux 【gcc，make/makefile】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.gcc指令
2.动静态库
3.make/makefile
依赖关系 和 依赖方法
多个.c编译形成可执行程序
简写多个.c编译形成可执行程序
清理文件
一次形成多个可执行程序
底行模式下批量替换
gcc是一个专门用来编译链接c语言的编译器（g++ -&gt; c++,c都可以）
注意：linux中 uname -r查看版本内核，默认64位
1.gcc指令 1.gcc 文件名 （直接编译生成可执行程序）
2.gcc 要编译的文件名 -o 文件名字（后面的文件名是可执行程序文件）
3.gcc -o 文件名字 要编译的文件名（后面的文件名是可执行程序文件）
记忆：ESc -&gt; iso
预处理
指令: gcc –E test.c –o test.i
test.i文件内部 编译（生成汇编）
gcc –S test.i –o test.s
汇编（生成机器可识别二进制目标代码） gcc –c test.s –o test.o(可重定向目标文件)，该文件此时不可执行，只是把自己写的代码编译完成，代码中，例如printf方法没有和库关联起来
链接（生成可执行文件或库文件）
gcc test.o –o test
2.动静态库 一般链接的过程有两种方式：动态链接（动态库），静态链接（静态库）
Linux系统头文件目录：ls /usr/include 头文件中只有函数的声明，没有函数的实现，那么printf函数为何只需要包含头文件即可使用？
stdio.h头文件中printf声明 系统把这些函数实现放到名为 libc.so.6 的库文件中去（库所在路径ls /lib64/）
可以通过头文件找到函数的声明，在库中找到函数的实现，再把所写代码和库中代码地址相链接，形成可执行程序（程序依赖库文件）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe7b7168e404d5853795f8a5ad225b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2afa027582c66e42a28b42c99e8c76e0/" rel="bookmark">
			Java Web 开发详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Web基础 1、Web 概述 Web 在英文中的含义是网状物、网络。在计算机领域，它通常指的是后者，即网络。
像 WWW 是由 3 个单词组成的，即World Wide Web，中文含义是万维网。
他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为网站。我们通过输入网站的地址（即网址），就可以访问网站中提供的资源。
在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。资源可以分为静态资源和动态资源：
静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的 html、css、js、图片、多媒体等，都可以称为静态资源。
动态资源指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在 CSDN 上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的 JSP、servlet、php、ASP 等都是动态资源。
关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网；局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。
2、系统结构 根据基础结构划分：C/S 结构，B/S 结构两类。根据技术选型划分：Model1 模型，Model2 模型，MVC 模型、三层架构 + MVC 模型。根据部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。 1. C/S 结构
它指的是客户端——服务器的方式，其中 C 代表着 Client，S 代表着服务器。
C/S 结构的系统设计图如下：
2. B/S 结构
它指的是浏览器——服务器的方式，其中 B 代表着 Browser，S 代表着服务器。
B/S 结构的系统设计图如下：
3. 两种结构的区别及优略
两种结构的区别：
硬件环境不同：C/S 通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端；而 B/S 是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。
C/S 结构比 B/S 结构更安全，因为用户群相对固定，对信息的保护更强。
B/S 结构维护升级比较简单，而 C/S 结构维护升级相对困难。
优势：
C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2afa027582c66e42a28b42c99e8c76e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb5101e9fbbb62d840f7a51568897df8/" rel="bookmark">
			pycharm运行时报错ImportError: cannot import name ‘Bar‘ from ‘pyecharts‘（用pycharm绘制柱状图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行pycharm时报错：
Traceback (most recent call last):
File "D:\Python\lib\site-packages\IPython\core\interactiveshell.py", line 3444, in run_code
exec(code_obj, self.user_global_ns, self.user_ns)
File "&lt;ipython-input-2-d8ab1186c7cc&gt;", line 1, in &lt;module&gt;
runfile('D:/Pycharm/PythonProject/test.py', wdir='D:/Pycharm/PythonProject')
File "D:\Pycharm\pycharm\PyCharm 2022.2.1\plugins\python\helpers\pydev\_pydev_bundle\pydev_umd.py", line 198, in runfile
pydev_imports.execfile(filename, global_vars, local_vars) # execute the script
File "D:\Pycharm\pycharm\PyCharm 2022.2.1\plugins\python\helpers\pydev\_pydev_imps\_pydev_execfile.py", line 18, in execfile
exec(compile(contents+"\n", file, 'exec'), glob, loc)
File "D:/Pycharm/PythonProject/test.py", line 1, in &lt;module&gt;
from pyecharts import Bar
ImportError: cannot import name 'Bar' from 'pyecharts' (D:\Python\lib\site-packages\pyecharts\__init__.py)
typeerror: __init__() takes from 1 to 2 positional arguments but 3 were given
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb5101e9fbbb62d840f7a51568897df8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd8c706585c1a63db49414725835c81/" rel="bookmark">
			爬电距离、绝缘电阻、绝缘电压 之我见
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全 爬电距离、绝缘电阻、绝缘电压，这些都是为了“安全”而产生的约束名词。
定义 爬电距离 爬电距离指沿绝缘表面测得的两个导电零部件之间，在不同的使用情况下，由于导体周围的绝缘材料被电极化，导致绝缘材料呈现带电现象的带电区。
绝缘电阻 绝缘电阻（insulation resistance），是电气设备和电气线路最基本的绝缘指标
绝缘耐压 绝缘耐压可连续（例1分钟）加到输入端和输出端，输入端和底板，输出端和底板之间的最大交流或直流电压。
我的理解 爬电距离 见下图，紫色线条就是电气间隙，粗黑的是爬电距离，它们的表示方法是用长度表示。
作为电子工程是，那我们索要关系的地方就是，一般的PCB上面需要预留多大的间距，PCB默认是目前常规工艺方式，FR4+铜箔+绿油；如AC220V 家用电，那么爬电距离查表应该是2.5mm。
一次电路
主电路也叫一次电路，它是从电源到负载输送电能时电流所经过的电路。一次电路中的各种电气设备叫一次设备，它们包括了各种开关、断路器、接触器、熔断器和用电设备。
二次电路
辅助电路也叫二次回路，它是对主电路进行控制、保护、监视、测量的电路。二次回路中的各设备叫二次设备，它们包括各种控制开关（如按钮等），继电器、接触器的线圈和辅助触点、信号灯、测量仪表等。
绝缘电阻 定义很明确，设备外壳与电器线路之间的电阻值。如DC500V-100MΩ。，
绝缘耐压 根据相关标准设定好一个漏电流值，然后再被测端口施加电压，漏电流值随着施加电压的升高而增大，达到漏电流值时候的电压即为耐压值。
Viso ：2.1KV AC //直接测试，不通电工作
Vwfsi ：354 VDC //通电工作 ，基本隔离电压
Vwfri ：184VDC //通电工作，基本隔离电压失效后，仍然能安全隔离的电压值；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6315ab70c2fb8c3ca6a7d2da036db4/" rel="bookmark">
			堆，向下调整算法，向上调整算法，数组建堆，堆排序，Topk问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆 1.堆的基本概念，操作及实现1.1概念1.2操作---向下调整 2.堆的应用---优先级队列2.1操作---入队列2.2操作---出队列 3.堆排序4.Topk问题 1.堆的基本概念，操作及实现 1.1概念 1.概念：
堆逻辑上是一颗完全二叉树堆物理上是保存在数组中满足任意节点的值都大于其子树中节点的值叫做大堆，或者大根堆，特点arr[i]&gt;=arr[2i+1]&amp;&amp;arr[i]&gt;=arr[2i+2]满足任意节点的值都小于其子树中节点的值叫做小堆，或者小根堆，特点arr[i]&lt;=arr[2i+1]&amp;&amp;arr[i]&lt;=arr[2i+2]堆的基本作用是，快速找到集合中的最值 2.下标关系
已知双亲(parent)下标则：
左孩子(left)下标 = 2*parent+1;
右孩子(right)下标 = 2*parent+2;
已知孩子(不区分左右)（child）下标则：
双亲(parent)下标 = (child -1) / 2;
示例：
如下数组
其展开图如下
1.2操作—向下调整 前提：左右子树必须已经是一个堆才可以调整
说明：
array代表存储堆的数组usedSize 代表数组数据的个数parent 代表要调整位置的下标left 代表 parent 左子树下标right 代表 parent右子树下标child代表 parent 最大孩子的下标 过程：(以大堆为例)
1.parent 如果已经是叶子结点，则调整过程结束
1.判断parent位置有没有孩子2.因为堆是完全二叉树，没有左子树就一定没有右子树，所以判断是否有左子树3因为堆的数据结构是数组，所以判断是否有左子树即判断左子树下标是否越界，即left&gt;=size越界 2.确定 left 或 right，谁是 parent 的最大子树 child
1如果右子树不存在，则child=left2否则，比较 array[left]和 array[right] 值的大小，选择大的为child 3.比较array[parent]的值和array[child]的值，
如果array[parent] &gt; array[child],则满足堆的性质，调整结束
4.否则，交换array[parent] 和array[child]的值
5.然后因为child位置的堆的性质可能被破坏，所以把child视作parent，向下重复以上过程
以示例中的数组为例：调整前
向下调整完以后：
代码示例：
public TestHeap() { this.elem = new int[10];//10个0 } //将一个堆改为大堆 public void shiftDown(int parent) {//向下调整 int child = 2*parent+1; //进入这个循环 说明最起码你有左孩子 while (child &lt; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6315ab70c2fb8c3ca6a7d2da036db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619095ff8387c925663d2740df18c48c/" rel="bookmark">
			vue3中scrollTop不生效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天在写一个v3+ts的移动端项目时 有一个点击tab栏跳转至页面相对应位置的功能 ，使用scrollTop修改dom的位置不生效
最后查出来问题为需要设置scroll的盒子没有设置高度。。。。
scrollTop要生效的必要条件：
（1）盒子必须具有高度 高度不能为0
（2）设置该dom的overflow属性为auto || scroll
然后vue3通过
例 html部分
&lt;div ref='demo' @click='click'&gt; &lt; div&gt;
js部分
import { ref,nextTick} from 'vue';
const demo= ref(null) // 这行代码用来获取dom
const click=()=&gt;{
nextTick(()=&gt;{
dmeo._value.scrollTop= 0 //0为滚动到顶部 }) }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b3cb3608da11d12f4431dfff07e3cbf/" rel="bookmark">
			【python】之常用类型（包括进制）之间的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人主页：天寒雨落的博客_CSDN博客-C,CSDN竞赛,python领域博主
特别标注：仅为自己的学习记录笔记，方便复习和加深记忆，仅供借鉴参考！
目录
一、字符和整数之间的转换
1.整数转字符
chr(x)
2.字符转整数
ord(x)
二、将列表中的所有整数转换为字符串
列表名=[str(i) for i in 列表名]
列表名=list(map(str,列表名))
三、二进制、八进制、十进制、十六进制之间的转化
1.十进制数转为二进制 bin(x)
format(x,'b')
2.十进制转化八进制
oct(x)
print('%o' % x)
print(format(x,'o'))
3.十进制转化十六进制
hex(x) print('%x' %x)
format(x,'x')
4.二进制转化为十进制
int("二进制值",2)
5.八进制转化为十进制
int("八进制值",8)
6.十六进制转化为十进制
int("十六进制值",16)
一、字符和整数之间的转换 1.整数转字符 chr(x) char缩写，将整数x通过对照其ascll码转化为对应的一个字符
代码
x=65 print(chr(x)) 执行结果
2.字符转整数 ord(x) ordinal缩写，意思为序数词，将字符x转化为它对应的整数
代码
x='a' print(ord(x)) 执行结果
二、将列表中的所有整数转换为字符串 列表名=[str(i) for i in 列表名] 代码
list1=eval(input("请输入整数列表:")) list1=[str(i) for i in list1] print(list1) 执行结果
列表名=list(map(str,列表名)) 代码
list1=eval(input("请输入整数列表:")) list1=list(map(str,list1)) print(list1) 执行结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b3cb3608da11d12f4431dfff07e3cbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5a40786569caf74243c913b50abe87/" rel="bookmark">
			springmvc获取formdata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a57cb0da40ca2a53a76d76947e6a54/" rel="bookmark">
			Makefile快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译概述 编译基础： 使用GCC编译程序时可以分为4个阶段：
（1）预处理（pre-processing）-E.c----&gt;.i-I （Include）将源文件生成中间文件（2）编译（compiling）-S.i----&gt;.s将中间文件生成汇编（3）汇编（Assembling）-c.s—&gt;.o将汇编转换成机器代码（4）链接（Linking）.o—&gt;可执行文件-L（Link）汇集成可执行文件 基本用法： gcc 【options】 【filenames】
常用选项： -c只是编译，不生成可执行文件，将.c文件生成.o文件-o outputfile确定输出文件的名字为outputfile-g产生gdb所需要的符号信息，用于对源代码的调试-O优化编译链接，编译链接时间会比较慢-O2比-O更好的优化编译链接，编译链接时间会更加慢-Wall输出所有警告信息-w关闭所有警告信息-Idirname将dirname的内容加入到程序头文件目录列表中，在预处理阶段使用。I意指Include-Ldirmane将dirname的目录加入到程序的库文件搜索目录列表中，这是链接中使用的参数。L意指Link makefile： makefile文件和make工具一起使用，用于控制工程项目的编译和链接，也可以用来编写手册页和程序的安装。
make工具用于解释执行makefile文件中的内容。
makefile文件中通常包含源文件和目标文件的依赖关系以及从源文件生成目标文件的规则。
make工具可以根据makefile判断哪些文件需要被重新编译，目标文件的构建顺序等。
规则： 在讲述makefile之前，先来粗略地看一看makefile的规则。
target ... : prerequisites ... command ... ... target：可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。
prerequisites：生成该target所依赖的文件和/或target
command：该target要执行的命令（任意的shell命令），一定要以tab开头
这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。即prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。
这就是makefile的规则，也就是makefile中最核心的内容。
静态模式： 静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：
&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt; &lt;commands&gt; ... 例子如下：
objects = foo.o bar.o all: $(objects) $(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ 如果我们的 %.o 有几百个，静态模式规则可以写完一堆规则，实在是太有效率了。
同名目标： target1: dep1 target1: dep2 cmd2 这种情况下，这两个相同的target1会被合并成:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a57cb0da40ca2a53a76d76947e6a54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23893bea7fb962634a802ea61accf4a3/" rel="bookmark">
			马拉车（Manacher）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		马拉车（Manacher）算法 前言：马拉车算法与KMP算法都是解决字符串问题的经典算法，为什么把它们俩个放在一起呢？这是因为它们的思想都是用前面已知的信息去更新后面的信息。
马拉车（Manacher）算法 马拉车算法主要用于解决最长回文串的问题，并且是以 O ( n ) O(n) O(n)的时间复杂度解决。
马拉车算法的优势：
不用考虑字符串是单数还是双数可以以 O ( n ) O(n) O(n)的时间复杂度得到最长回文串的长度，并能找到它 具体步骤： 1.解决字符串单数与双数问题 因为单数的回文串最中间的位置是字符，双数的回文串是中间两个字符中间的位置。为了不考虑字符串是单数还是双数，要对原字符串进行预处理。
改造字符串
在字符串之间和串两端插入’#'，改造后无论原先是偶字符串还是奇字符串都会变成奇字符串，方便统一处理。
例如：
奇数串 aba #a#b#a#
偶数串 abba #a#b#b#a#
相关代码：
scanf("%s",a+1); int len1=strlen(a+1); int k=0; s[0]='$'; s[++k]='#'; for(int i=1;i&lt;=len1;i++){//主要消除奇偶的问题 s[++k]=a[i]; s[++k]='#'; } 2.算法流程 d [ i ] d[i] d[i]数组为以 i i i为中心的最长回文串的半径，比如说 a b a aba aba，以 b b b为中心的最长回文串的半径为 2 2 2，记作 d [ 2 ] = 2 d[2]=2 d[2]=2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23893bea7fb962634a802ea61accf4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9bcc113ec08597505c76bf5569fca6/" rel="bookmark">
			echarts数据可视化介绍&#43;常用的图表案例分析（值得收藏的干活）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		echarts是什么 echars官网
echars，由百度开发的是一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。
了解一下echarts的背景
作用：展示图表的（大数据可视化）百度，捐给Apache 免费开源竞品：heightCharts 和 D3 echarts优点
Echarts的优点比较明显体积小，免费、上手快，只需要有一些js基础，剩下的就是复制粘贴的事情，而且是国产的东西，文档看起来也比较方便，总体来说门槛比较低。
echarts使用步骤 获取 Apache ECharts
在 https://www.jsdelivr.com/package/npm/echarts选择 dist/echarts.js，点击并保存为 echarts.js 文件。 引入echarts.js文件 &lt;script src="js/echarts.min.js"&gt;&lt;/script&gt; 在body中创建个容器 &lt;div id="container"&gt;&lt;/div&gt; 实例化echarts var echart = echarts.init(document.getElementById("app")); 指定配置量和数据option // 4.1 创建一个实例 var echart = echarts.init(document.getElementById("container")) // 4.2 定义配置项 var option = { // 图表的标题 title: { text: "我的第一个图表" }, // 图表的提示 tooltip: {}, // 图例 legend: { data: ["睡眠时长"] }, // x轴线 xAxis: { data: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f9bcc113ec08597505c76bf5569fca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91fd8568cfb73591975e258120b27022/" rel="bookmark">
			阿里巴巴矢量图标库使用在线字体图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 官网 iconfont-阿里巴巴矢量图标库 字体图标的使用
2.1关于命名：初始化的icon名称都是拼音，大家需要改成合适的命名，如果在使用过程中发现icon名是拼音，你们就改过来。如果已经是英文，说明别人改过了，你直接用就行。
注意每次修改图标名称后都需要重新改一下生成并引入链接。注意：点击保存的时候，是点击保存，不要点击保存为副本。保存为副本会复制一个图标出来。
2.2.引入在线链接，先一下链接地址复制，然后然后放到前端public/index.html中引入，
引入js和css链接，只是文件名不一样而已
2.3icon的使用。
对于单色图标可以这样写，
&lt;i class="lea-icon lea-icon-file-word"&gt;&lt;/i&gt; 如果要修改样式,把它当做字体这样子写样式就可以了
.;ea-icon-file-word{ font-size:14px; color：“#eeeeee” } 如果是多色图标，则需要这样写
&lt;svg class="lea-icon"&gt; &lt;use xlink:href="#lea-icon-file-word"&gt;&lt;/use&gt; &lt;/svg&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ec0da8ea042e89034067371c655768/" rel="bookmark">
			踩坑update user set host =‘%‘ where user = ‘root‘；时报错ERROR 1356 (HY000): View ‘mysql.user‘ references
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天想自己搭建一个Liunx的Java环境玩一下但是发现： centOs7.6已经不支持MySQL，转为使用MariaDB作为数据库；
centOs8 已经停止维护过时了；
------------------------------------------------------------------
后来使用Navicat去连接MariaDB发现连接不上：
navicat连接MariaDB报错1130
后来查资料，看文档找到解决办法：
在修改MariaDB中 mysql.user 表
解决Navicat无法连接Linux环境中的Mariadb时，提示1130错误的问题_王京伟的博客-CSDN博客_mariadb 1130 =============== 后来始终更新报错：
在修改MariaDB中 mysql.user 表时,发生如下错误：
View 'mysql.user' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them 原因分析：
根据SQL响应异常来看,第一反应应该是表/字段/方法异常或者是权限异常,但是检查了用户权限与数据库结构后,排除了这两个问题
细看之下,发现了这个提示:`of view lack rights to use them`,这里面提到了`view`也就是视图,是不是说明,mysql.user不是一张表?于是google之
MariaDB官方资料说,mysql.user从10.4版本开始,不再是一张表而是一个视图
并且提供了一个新表mysql.global_priv来替代mysql.user,而且提供了一个新的命令:ALERT USER,所以,解决方案就来了!
解决方案： 1. 编辑mysql.global_priv表:
UPDATE mysql.global_priv SET Host='%' WHERE User='root'; 别忘了刷新一下权限:
flush privileges; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5800b8923ec8e58dc2954e32e0fbda2f/" rel="bookmark">
			数组~遍历~冒泡排序~二维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组：
1.数组的定义：内存中一块连续的存储单元，这些存储单元具有共同的名称、不同的索引（下标）
2.数组的声明：
1.数组的字面量：[ ]
2.var arr = [ ]声明数组.数组名为arr，数组没有元素
2.Array对象 new Array()
3.数组的属性：length--&gt;表示数组元素的个数。数组名：length
4.数组元素的索引（下标）--&gt;[n]：n为索引，从0开始到元素的个数减1
5.数组元素的访问：数组名【索引】
6.数组的遍历：不重复的访问数组的每个元素
（1）使用for循环遍历：
for(let i = 0;i &lt; a.length;i++){
console.log(a[i]);
}
（2）使用for...in循环：
for（index in 数组名）{
循环体语句
}
index：表示的是数组元素的索引
例如 for(let i in arr){
console.log(arr[i]);
}
（3）使用for...of循环：
​ for（ value of 数组名）{
循环体语句
}
value：表示数组元素
​
例如：for(let value of arr){
console.log(value);--&gt;依次将数组arr中的元素赋给value
}
for...of循环
for(value of 数组名){循环体语句}
使用for...of进行遍历
for(let value of arr){
console.log(value);--&gt;依次将数组arr中的元素赋给value
}
(5) forEach循环遍历数组元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5800b8923ec8e58dc2954e32e0fbda2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ea234aaf2c5c4aadce12db9c5417d3/" rel="bookmark">
			现代C&#43;&#43;新特性 新字符类型char16_t和char32_t
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文字版PDF文档链接：现代C++新特性(文字版)-C++文档类资源-CSDN下载
在C++11标准中添加两种新的字符类型char16_t和char32_t，它们分别用来对应Unicode字符集的UTF-16和UTF-32两种编码方法。在正式介绍它们之前，需要先弄清楚字符集和编码方法的区别。
字符集和编码方法 通常我们所说的字符集是指系统支持的所有抽象字符的集合，通常一个字符集的字符是稳定的。而编码方法是利用数字和字符集建立对应关系的一套方法，这个方法可以有很多种，比如Unicode字符集就有UTF-8、UTF-16和UTF-32这3种编码方法。除了Unicode字符集，我们常见的字符集还包括ASCII字符集、GB2312字符集、BIG5字符集等，它们都有各自的编码方法。字符集需要和编码方式对应，如果这个对应关系发生了错乱，那么我们就会看到计算机世界中令人深恶痛绝的乱码。不过，现在的计算机世界逐渐达成了一致，就是尽量以Unicode作为字符集标准，那么剩下的工作就是处理UTF-8、UTF-16和UTF-32这3 种编码方法的问题了。
UTF-8、UTF-16和UTF-32简单来说是使用不同大小内存空间的编码方法。
UTF-32是 简单的编码方法，该方法用一个32位的内存空间(也就是4字节)存储一个字符编码，由于Unicode字符集的 大个数为0x10FFFF(ISO 10646)，因此4字节的空间完全能够容纳任何一个字符编码。UTF-32编码方法的优点显而易见，它非常简单，计算字符串长度和查找字符都很方便；缺点也很明显，太占用内存空间。
UTF-16编码方法所需的内存空间从32位缩小到16位(占用2字节)，但是由于存储空间的缩小，因此UTF-16 多只能支持0xFFFF个字符，这显然不太够用，于是UTF-16采用了一种特殊的方法来表达无法表示的字符。简单来说，从0x0000～0xD7FF以及0xE000～0xFFFF直接映射到Unicode字符集，而剩下的0xD800～0xDFFF则用于映射0x10000～0x10FFFF的Unicode字符集，映射方法为：字符编码减去0x10000后剩下的20比特位分为高位和低位，高10位的映射范围为0xD800～0xDBFF，低10位的映射范围为0xDC00～0xDFFF。例如0x10437，减去0x10000后的高低位分别为0x1和0x37，分别加上0xD800 和0xDC00的结果是0xD801和0xDC37。
幸运的是，一般情况下0xFFFF足以覆盖日常字符需求，我们也不必为了UTF-16的特殊编码方法而烦恼。UTF-16编码的优势是可以用固定长度的编码表达常用的字符，所以计算字符长度和查找字符也比较方便。另外，在内存空间使用上也比UTF-32好得多。
后说一下我们 常用的UTF-8编码方法，它是一种可变长度的编码方法。由于UTF-8编码方法只占用8比特位(1字节)，因此要表达完数量高达0x10FFFF的字符集，它采用了一种前缀编码的方法。这个方法可以用1～4字节表示字符个数为0x10FFFF的Unicode(ISO 10646)字符集。为了尽量节约空间，常用的字符通常用1～2字节就能表达，其他的字符才会用到3～4字节，所以在内存空间可以使用UTF-8，但是计算字符串长度和查找字符在UTF-8中却是一个令人头痛的问题。表1-1展示了UTF-8对应的范围。
代码范围 十六进制UTF-8 二进制注释000000～00007F 128个代码0zzzzzzzASCII字符范围，字节由零开始 000080～0007FF 1920个代
码
110yyyyy 10zzzzzz第1字节由110开始，接着的字节由10开始 000800～00D7FF 00E000～
00FFFF 61440个代码
1110xxxx 10yyyyyy
10zzzzzz
第1字节由1110开始，接着的字节由10开始 010000～10FFFF 1048576
个代码
11110www 10xxxxxx
10yyyyyy 10zzzzzz
将由11110开始，接着的字节从10开始 使用新字符类型char16_t和char32_t 对于UTF-8编码方法而言，普通类型似乎是无法满足需求的，毕竟普通类型无法表达变长的内存空间。所以一般情况下我们直接使用基本类型char进行处理，而过去也没有一个针对UTF-16和UTF-32的字符类型。到了C++11，char16_t和char32_t的出现打破了这个尴尬的局面。除此之外，C++11标准还为3种编码提供了新前缀用于声明3种编码字符和字符串的字面量，它们分别是UTF-8的前缀u8、UTF-16的前缀u和UTF-32的前缀U：
char utf8c = u8'a'; // C++17标准 // char utf8c = u8'好'; char16_t utf16c = u'好'; char32_t utf32c = U'好'; char utf8[] = u8"你好世界"; char16_t utf16[] = u"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ea234aaf2c5c4aadce12db9c5417d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c01dc92a7bf376ed235b1cff8cd6f481/" rel="bookmark">
			网络安全学习-WEB安全常见漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注入类漏洞 SQL注入漏洞
定义
sql注入漏洞，就是将用户可控的数据拼接到了sql语句当中，一起提交到了数据库执行。
攻*击者通过注入语句，改变sql执行的逻辑，通过控制部分sql语句，攻击者可以查询到数据库钟任何自己需要的数据，利用数据库的一些特性们，可以直接获取数据库服务器的系统权限。
漏洞分类
Error-based SQL injection 报错型注入 Boolean-based blind SQL injection 布尔型注入 Time-based blind SQL injection 基于时间延迟注入 提交的参数类型
数字型 字符型 搜索型 示例-报错型
以上注入，又被叫做万能密码，可以实现一些网站用户登录
实例-bool型
在靶场环境，输入http://localhost:81/sqli/Less-8/?id=1打开该平台，这时会向数据库送人一条查询：
1.SELECT * FROM table_name WHERE id=1
显示如下界面
当攻击者使用嵌入(')的查询，即:
http://localhost:81/sqli/Less-8/?id=1’
黄色文本消失，也没有得到任何错误信息，使用其他攻击方式的情况于此相同。
攻击者可以通过盲注来进行验证，该注入查询返回的一定是TRUE或者FALSE。
再次验证是否为布尔型注入，插入判断语句：
http://localhost:81/sqli/Less-9/id=1 AND 1=1 --+
其中 --+在数据库中代表注释的意思
对应的后端数据库查询为：
1.SELECT * FROM table_name WHERE id=1’ AND 1=1
获取数据库名等信息
首先确定数据库中字符串长度，简单来说就是获取数据名的长度。
http://localhost:81/sqli/Less-9/id=1’ AND （length(database())=1 -+
确定页面没反应，则认为返回的是FALSE,意味着当前数据库名的长度不等于1
尝试判断数据库名的长度为2
http://localhost:81/sqli/Less-9/id=1’ AND （length(database())=2 --+
当尝试判断数据库名的长度为8的时候，
http://localhost:81/sqli/Less-9/id=1’ AND （length(database())=8 --+
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c01dc92a7bf376ed235b1cff8cd6f481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7db60d2eb9911e90f1054d7711b52f9/" rel="bookmark">
			liunx 查看公网ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 liunx 查看公网ip
curl ifconfig.me curl cip.cc curl ip.sb curl ipinfo.io curl ipinfo.io/ip curl icanhazip.com curl ipecho.net/plain curl curlmyip.com curl ip.appspot.com curl www.trackip.net/i 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5216ae9b3e5d23b3ae18cd6b0de69fd2/" rel="bookmark">
			Java判断Class 是否是基本类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码:
/** * 判断类型是否实基本类型或包装类型 * * @param clz 类 * @return true: 是 false: 不是 */ public static boolean isWrapClass(Class&lt;?&gt; clz) { try { return clz.isPrimitive() || ((Class&lt;?&gt;) clz.getField("TYPE").get(null)).isPrimitive(); } catch (Exception e) { return false; } } 测试代码:
public static void main(String[] args) { Class&lt;?&gt; aClass = Integer.class; Class&lt;?&gt; integerClass = int.class; Class&lt;? extends String&gt; aClass1 = "aa".getClass(); boolean wrapClass = isWrapClass(aClass); boolean wrapClass1 = isWrapClass(integerClass); boolean wrapClass2 = isWrapClass(aClass1); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5216ae9b3e5d23b3ae18cd6b0de69fd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbaa152e0ce94430d942c708d66cb34b/" rel="bookmark">
			ECharts实现数据可视化 “ 10分钟入门 “ 教程（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（起源！）ECharts介绍 官网链接：👉 Apache ECharts 👈 ECharts 是一个使用 JavaScript 实现的开源可视化库，涵盖各行业图表，满足各种需求。
ECharts 遵循 Apache-2.0 开源协议，免费商用。
ECharts 兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等）及兼容多种设备，可随时随地任性展示。
阅读本教程前，您需要了解的知识： 阅读本教程，您需要有以下基础：
HTML 教程
JavaScript 教程
第一个 ECharts 实例 注 释 超 详 细
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 01 导入js --&gt; &lt;script src="js/echarts.min.js"&gt;&lt;/script&gt; &lt;!-- 03 设置容器的样式 --&gt; &lt;style&gt; #container{ width: 800px; height: 600px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 02 创建个容器 --&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script&gt; //04 实例化echarts // 4.1 创建一个实例 var echart = echarts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbaa152e0ce94430d942c708d66cb34b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/243cb1a75820f11b0cbc18f64f3d58d3/" rel="bookmark">
			用java语言编写万年历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Scanner;//万年历
public class Demo12{
public static void main(String []args){
Scanner sc=new Scanner(System.in);
int year,month;
do{
System.out.println("请输入年份:");
year=sc.nextInt();
}while(year&lt;1900);
do{
System.out.println("请输入月份:");
month=sc.nextInt();
}while(month&lt;1 || month&gt;12);
int total=getTotalDays(year,month);
int weekDay=total%7;
System.out.println(year+"年"+month+"月1号离1900.1.1号共有"+total+"天 "+weekDay);
System.out.println("星期一\t星期二\t星期三\t星期四\t星期五\t星期六\t星期天");
int kongge=weekDay-1;
if(weekDay==0){
kongge=6;
}
for(int i=1;i&lt;=kongge;i++){
System.out.print("\t");
}
int days=getMonthDays(year,month);
for(int i=1;i&lt;=days;i++){
System.out.print(i+"\t");
if((kongge+i)%7==0){
System.out.println();
}
}
}
public static int getTotalDays(int year,int month){
int total=0;
for(int i=1900;i&lt;year;i++){
if(isRun(i)){
total+=366;
}else{
total+=365;
}
}
for(int k=1;k&lt;month;k++){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/243cb1a75820f11b0cbc18f64f3d58d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bce5c64e6024163c8075efd7ce2b166/" rel="bookmark">
			【正点原子STM32连载】第五十四章 手写识别实验 摘自【正点原子】MiniPro STM32H750 开发指南_V1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子MiniPro H750开发板
2）平台购买地址：https://detail.tmall.com/item.htm?id=677017430560
3）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-336836-1-1.html
4）对正点原子STM32感兴趣的同学可以加群讨论：879133275
第五十四章 手写识别实验 本章，我们将利用正点原子提供的手写识别库，在开发板上实现一个简单得数字字母手写识别。
本章分为如下几个小节：
54.1 手写识别简介
54.2 硬件设计
54.3 程序设计
54.4 下载验证
54.1 手写识别简介
手写识别，是指对在手写设备上书写时产生的有序轨迹信息进行识别的过程，是人际交互最自然、最方便的手段之一。随着智能手机和平板电脑等移动设备的普及，手写识别的应用也被越来越多的设备采用。
手写识别能够使用户按照最自然、最方便的输入方式进行文字输入，易学易用，可取代键盘或者鼠标。用于手写输入的设备有许多种，比如电磁感应手写板、压感式手写板、触摸屏、触控板、超声波笔等。本实验通过使用STM32板子自带得TFTLCD触摸屏(2.8/3.5/4.3/7寸)，可以用来作为手写识别的输入设备。接下来，我们将给大家简单介绍下手写识别的实现过程。
手写识别与其他识别系统如语音识别、图像识别一样分为两个过程：训练学习过程；识别过程。如图54.1.1所示：
图54.1.1 字母数字识别系统示意图
上图中虚线部分分为训练学习过程，该过程首先需要使用设备采集大量数据样本，样本类别数目为09，az，A~Z 总过62类，每个类别5~10个样本不等（样本越多识别率就越高）。对这些样本进行传统的八方向特征提取，提取后特征维数为512维，这对于STM32来说，计算量和模板库的存储量都是难以接收，所以需要运行一些方法进行降维，这里采用LDA线性判决分析的方法进行降维。所谓的线性判决分析，即是假设所有样本服从高斯分布（正态分布）对样本进行低维投影，以达到各个样本间的距离最大化。关于LDA（线性判别分析）的更多知识可以自行阅读（http://wenku.baidu.com/view/f05c731452d380eb62946d39.html）等参考文档。这里将维度降到64维度，然后针对各个样本类别进行平均计算的到该类别的样本模板。
而对于识别过程，首先得到触屏输入的有序轨迹，然后进行一些预处理，预处理主要包括重采样，归一处理。重采样主要是因为不同的输入设备不同的输入处理方式产生的有序轨迹序列有所不同。为了达到更好的识别结果我们需要对训练样本和识别输入的样本进行重采样处理，这里主要应用隔点重采样的方法对输入序列进行重采样；而归一化就是因为不同的书写风格采用分辨率的差异会导致字体太小不同，因此需要对输入轨迹进行归一化。这里把样本进行线性缩放的方法归一化为6464像素。
接下来进行同样的八方向特征提取操作。所谓的八方向特征就是首先将经过预处理后的6464输入进行切分成88的小方格，每个方格88个像素；然后对每个88个小格进行各个方向的点数统计。如某个方格内一共有10个点，其中八个方向的点分别为：1、3、5、2、3、4、3、2，那么这个格子得到的八个特征向量为[0.1, 0.3, 0.5, 0.2, 0.3, 0.4, 0.3, 0.2]。总共64个格子，于是一个样本最终能得到648=512维特征，更多八方向特征提取可以参考一下两个文档：
1，http://wenku.baidu.com/view/d37e5a49e518964bcf847ca5.html;
2，http://wenku.baidu.com/view/3e7506254b35eefdc8d333a1.html;
由于训练过程进行了LDA降维计算，所以识别过程同样需要对应的LDA降维过程得到最终的64维特征。这个计算过程就是在训练模板的过程中可以运算得到一个512*64维的矩阵，那么我们通过矩阵乘运算可以得到64维的最终特征值。
最后将这64维特征分别与模板中的特征进行求距离运算。得到最小的距离为该输入的最佳识别结果输出。
关于手写识别原理，我们就介绍到这里。如果想自己实现手写识别，那得花很多时间学习和研究，但是如果只是应用的话，那么就只需要知道怎么用就OK了，相对来说，简单得多。
正点原子提供了一个数字字母识别库，我们不需要关心手写识别是如何实现的，只需要知道这个库怎么用，就能实现手写识别。正点原子提供的手写识别库由4个文件组成：ATKNCR_M_V2.0.lib、ATKNCR_N_V2.0.lib、atk_ncr.c和atk_ncr.h。
ATKNCR_M_V2.0.lib和ATKNCR_N_V2.0.lib是两个识别用的库文件（两个版本），选择其中之一即可。ATKNCR_M_V2.0.lib用于使用内存管理的情况，用户必须自己实现alientek_ncr _malloc和alientek_ncr_free两个函数。而ATKNCR_N_V2.0.lib用于不使用内存管理的情况，通过全局变量来定义缓存区，缓存区需要提供至少3K左右的RAM。大家根据自己的需要，选择对应的版本。正点原子手写识别库资源需求：FLASH在52K左右，RAM在6K左右。
54.2 硬件设计
例程功能
开机的时候先初始化手写识别器，然后检测字库，之后进入等待输入状态。此时，我们在手写区写数字/字符，在每次写入结束后，自动进入识别状态，进行识别，然后将识别结果输出在LCD模块上，同时打印到串口。通过按KEY0可以进行模式切换（4种模式都可以测试），通过按KEY_UP，可以进入触摸屏校准（仅电阻屏需要校准，如果发现触摸屏不准，请执行此操作）。LED0闪烁用于提示程序正在运行。硬件资源
1）RGB灯 LED0 – PB4
2）独立按键 KEY0 – PA1、KEY1 – PA15
3）串口1 (PA9/PA10连接在板载USB转串口芯片CH340上面)
4）正点原子2.8/3.5/4.3/7/10寸TFTLCD模块(仅限MCU屏，16位8080并口驱动)
5）QSPI(PB2/PB6/PD11/PD12/PD13/PE2)
6）norflash(QSPI FLASH芯片,连接在QSPI上)
7）触摸屏(电阻式/电容式)
54.3 程序设计
54.3.1 程序流程图
图54.3.1 手写识别实验程序流程图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bce5c64e6024163c8075efd7ce2b166/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b99082af6b01b748d5f75975a6612b/" rel="bookmark">
			Redis安装与生产配置(全网最详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 享受优质模板，进行阅读——点击
对于不熟练的小伙伴，可以跳到详细安装方案，以下方案适用于我以及熟练的您~
#gcc,rpm rpm -Uvh *.rpm --nodeps --force; #redis tar -zvxf redis-5.0.2.tar.gz mkdir /data/redis cd redis-5.0.2 make PREFIX=/data/redis install cp redis.conf /data/redis/bin/ #redis生产配置 cp /data/redis/redis.conf /data/redis/6379.conf vi /data/redis/6379.conf ----------------------------------------- bind 0.0.0.0 port 6379 daemonize yes pidfile /var/run/redis_6379.pid requipass 123456 dir /data/redis/6379 appendonly yes ----------------------------------------- mkdir /data/redis/6379 #启动redis /data/redis/bin/redis-server /data/redis/6379.conf #确认启动 ps -ef | grep redis #访问 /data/redis/bin/redis-cli #配置开机自启,进入安装目录 cp /data/tmp/redis-5.0.2/utils/redis_init_script /etc/init.d/redis_6379 vi /etc/init.d/redis_6379 ------------------------------------------------ #在redis_6379脚本中，最上面，加入两行注释，并且修改redis_6379脚本的端口号（默认就是6379），修改相关启动路径配置 (该段不加) # chkconfig: 2345 90 10 # description: Redis is a persistent key-value database ------------------------------------------------ chkconfig --add redis chkconfig --list 温馨提示：df -h 如何挂载磁盘—点击前往
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27b99082af6b01b748d5f75975a6612b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37cffc1233b8cd437ebce1ec84fad1fe/" rel="bookmark">
			23模式---原型模式（浅拷贝和深拷贝）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原型模式是一种创建型设计模式，Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。
简单的说就是对象本身提供了一个可复制（克隆）的接口，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
这个就有两个疑问了，返回一个对象？
不是有单例模式吗？
因为单例模式返回的对象的同一个，而有些场景下虽然使用相同属性值的类，但是再某个方法中出现变化的时候，不希望影响其它对的属性值。举一个不巧当的例子，比如双胞胎出生后很多信息都相同，都是未婚，可以说属性值一样，但是有一天老二结婚了媳妇是小红，不能说老大立马也结婚，媳妇也是小红吧？简单的说就是单例模式无法满足所有遇见的问题。
不是有工厂模式吗？
举一个例子那就是抽象工厂类，以小米手机为抽象接口，然后生长的手机有不同的型号A,B,C。然后对用的工厂类有A,B,C等工厂。所以只要创建一个新的对象，就需要有新的工厂类，这个是工厂模式的优势，也是其也会让代码逻辑变复杂。
而克隆模式就是通过一个实例小米手手机对象克隆出需要的手机对象，然后根据ABC型号，来换对应ABC属性值即可。
这又产生了一个问题：既然通过实例克隆，然后再修改属性，那么我干嘛不直接通过new来实现，而通过克隆呢？不是故意让代码变得更繁琐吗？
不是的， 因为某些复杂的对象实例的时候拷贝（克隆）的效率一般对构造的效率要高，但是也不是所有的都是快的，比如简单逻辑拷贝（克隆）也就没有直接new的效率高。
因为java中自动拷贝功能，所以先试一下克隆对比构造的创建实例的效率：
先来一个简单逻辑的：
public class test implements Cloneable { public static void main(String[] args) throws CloneNotSupportedException { Long start1= System.currentTimeMillis(); Phone p=new Phone("小米",1999,"red"); for (int i = 0; i &lt;9999999 ; i++) { new Phone(p.getBrandname(),p.price,p.getColor()); } Long end1= System.currentTimeMillis(); System.out.println("new创建1万实例："+ (end1-start1)); Long start2= System.currentTimeMillis(); Phone p2=new Phone("小米",1999,"red"); for (int i = 0; i &lt;9999999 ; i++) { p2.clone(); } Long end2= System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37cffc1233b8cd437ebce1ec84fad1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63a30b3c5247db8f05e0a55620e1c75/" rel="bookmark">
			Windows命令行（cmd）指令合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CONVERT 将 FAT 卷转换成 NTFS。您不能转换 当前驱动器。 COPY 将至少一个文件复制到另一个位置。 DATE 显示或设置日期。 DEL 删除至少一个文件。 DIR 显示一个目录中的文件和子目录。 DISKCOMP 比较两个软盘的内容。 DISKCOPY 将一个软盘的内容复制到另一个软盘。 DOSKEY 编辑命令行、调用 Windows 命令并创建宏。 ECHO 显示消息，或将命令回显打开或关上。 ENDLOCAL 结束批文件中环境更改的本地化。 ERASE 删除至少一个文件。 EXIT 退出 CMD.EXE 程序(命令解释程序)。 FC 比较两个或两套文件，并显示 不同处。 FIND 在文件中搜索文字字符串。 FINDSTR 在文件中搜索字符串。 FOR 为一套文件中的每个文件运行一个指定的命令 FORMAT 格式化磁盘，以便跟 Windows 使用。 FTYPE 显示或修改用于文件扩展名关联的文件类型。 GOTO 将 Windows 命令解释程序指向批处理程序 中某个标明的行。 GRAFTABL 启用 Windows 来以图像模式显示 扩展字符集。 HELP 提供 Windows 命令的帮助信息。 IF 执行批处理程序中的条件性处理。 LABEL 创建、更改或删除磁盘的卷标。 MD 创建目录。 MKDIR 创建目录。 MODE 配置系统设备。 MORE 一次显示一个结果屏幕。 MOVE 将文件从一个目录移到另一个目录。 PATH 显示或设置可执行文件的搜索路径。 PAUSE 暂停批文件的处理并显示消息。 POPD 还原 PUSHD 保存的当前目录的上一个值。 PRINT 打印文本文件。 PROMPT 更改 Windows 命令提示符。 PUSHD 保存当前目录，然后对其进行更改。 RD 删除目录。 RECOVER 从有问题的磁盘恢复可读信息。 REM 记录批文件或 CONFIG.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f63a30b3c5247db8f05e0a55620e1c75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6927abe39d60a2042054bd53e335a536/" rel="bookmark">
			L1-043 阅览室(java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 题目描述 天梯图书阅览室请你编写一个简单的图书借阅统计程序。当读者借书时，管理员输入书号并按下S键，程序开始计时；当读者还书时，管理员输入书号并按下E键，程序结束计时。书号为不超过1000的正整数。当管理员将0作为书号输入时，表示一天工作结束，你的程序应输出当天的读者借书次数和平均阅读时间。
注意：由于线路偶尔会有故障，可能出现不完整的纪录，即只有S没有E，或者只有E没有S的纪录，系统应能自动忽略这种无效纪录。另外，题目保证书号是书的唯一标识，同一本书在任何时间区间内只可能被一位读者借阅。
输入格式： 输入在第一行给出一个正整数N（≤10），随后给出N天的纪录。每天的纪录由若干次借阅操作组成，每次操作占一行，格式为：
书号（[1, 1000]内的整数） 键值（S或E） 发生时间（hh:mm，其中hh是[0,23]内的整数，mm是[0, 59]内整数）
每一天的纪录保证按时间递增的顺序给出。
输出格式： 对每天的纪录，在一行中输出当天的读者借书次数和平均阅读时间（以分钟为单位的精确到个位的整数时间）。
输入样例： 3 1 S 08:10 2 S 08:35 1 E 10:00 2 E 13:16 0 S 17:00 0 S 17:00 3 E 08:10 1 S 08:20 2 S 09:00 1 E 09:20 0 E 17:00 输出样例： 2 196 0 0 1 60 2. 分析 将图书的书号作为键, 图书借出的时间作为值将借出的书存储再HashMap中, 然后还书的时候查询该书是否被借出, 若没有被借出, 则视为无效数据, 若被借出了, 现在需要还掉, 所以把该数据移出HashMap
这个很重要, 否则第一个测试点会通不过, 第一个测试点就是: 如果有多条借出数据, 以最后一条为准,如果有多条还书数据, 以第一条为准
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6927abe39d60a2042054bd53e335a536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe491074f13f1d3fb0d9d50182d83774/" rel="bookmark">
			easyUI pagination分页控件点击下一页后跳转到最后一页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 百度结果得知是 easyui 分页时如果是通过 pageNumber: ‘${page}’ 这种形式赋值时， easyui获取到的值是字符串类型的“1”，而不是int类型的1。 所以解决办法就是赋值时转化为int类型 parseInt('${page}')。 这种方法可以解决这个问题，但我不想每次都加一个这种转化，所以我直接找到easyui的源代码中加上了这个转换
在 jquery.easyui.min.js里面找到分页点击下一个的方法，在if判断中对_db.pageNumber进行转化 next:{iconCls:"pagination-next",handler:function(){ var _db=$(this).pagination("options"); var _dc=Math.ceil(_db.total/_db.pageSize); if(parseInt(_db.pageNumber)&lt;_dc){ $(this).pagination("select",parseInt(_db.pageNumber)+1); } }} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a4ee4ea59357804d121531a664c2af/" rel="bookmark">
			C语言将整数转换为字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言本身自带两个库函数 直接调
int sprintf(char *str, const char *format, ...);
int snprintf(char *str, size_t size, const char *format, ...);
参数解释
char *str -&gt; 想要存入的数组
const char*format -&gt; 类型
... -&gt; 整数
size_t size -&gt; 数组位置
举个例子
sprintf
int a=1111;
char str[10];
sprintf(str,"%d",a);
// 把整数a转换为字符串，存放在str中
printf("str=%s\n",str);
// 输出str=1111 snprintf
int a=1234567890;
char str[20];
snprintf(str,5,"%d",a);
// 把整数a转换为字符串，存放在str中
printf("str=%s\n",str);
// 输出str=1234
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d13e03f79e9136cca810b77bcb2e154a/" rel="bookmark">
			Runtime.getRuntime.exec()执行linux脚本导致程序卡死有关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：Runtime.getRuntime.exec()执行linux脚本导致程序卡死有关问题 - 走看看 Runtime.getRuntime.exec()执行linux脚本导致程序卡死问题
问题： 在Java程序中，通过Runtime.getRuntime().exec()执行一个Linux脚本导致程序被挂住，而在终端上直接执行这个脚本则没有任何问题。
原因： 先来看Java代码：
public final static void process1(String[] cmdarray) {
Process p = null;
BufferedReader br = null;
try {
p = Runtime.getRuntime().exec(cmdarray);
br = new BufferedReader(new InputStreamReader(p.getInputStream()));
String line = null;
while ((line = br.readLine()) != null) {
System.out.println(line);
}
p.waitFor();
} catch (Exception e) {
e.printStackTrace();
} finally {
if (br != null) {
try {
br.close();
} catch (IOException e) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d13e03f79e9136cca810b77bcb2e154a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91c82352b12d272adb095b9d880c6c3/" rel="bookmark">
			CenOS7各种自启动配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置spring boot开机自启动；编辑/lib/systemd/system/b2b2c.service [Unit] Description=B2B2C Server Documentation=https://xxxxx.com [Service] User=root Group=root Type=simple Restart=no KillMode=process ExecStart=/home/bbc-shop/jar_auto.sh #ExecStop=/home/bbc-shop/jar_auto.sh stop #ExecReload=/home/bbc-shop/jar_auto.sh restart RemainAfterExit=yes [Install] WantedBy=multi-user.target 上面的jar_auto.sh脚本如下：
#!/bin/bash #配置jdk的路径 export JAVA_HOME=/usr/java/jdk1.8.0_341-amd64 #此处为我的java环境路径，需要改为自己的JDK路径 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH #有时需要把jar包延时启动（比如博主不设置延时启动jar，nacos会提示拒绝连接） #延时30S运行jar包，需要延时启动则放开sleep注释行 （sleep+数字，表示延迟多少秒启动） #sleep 30 #有点奇怪，设置了延时有一个jar包起不来，此处延时仅供参考 #配置jar包启动的路径 日志生成路径 nohup表示静默启动 # 启动api，1g内存，可以根据服务器内存调整大小，推荐最低1G nohup java -jar -Xms1024m -Xmx1024m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -Dspring.profiles.active=prod /home/bbc-shop/java/yami-shop-api-0.0.1-SNAPSHOT.jar &gt; "/home/bbc-shop/java/log/api-console.log" &amp; # 启动商家端，512M内存，可以根据服务器内存调整大小，推荐最低512M nohup java -jar -Xms512m -Xmx512m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -Dspring.profiles.active=prod /home/bbc-shop/java/yami-shop-multishop-0.0.1-SNAPSHOT.jar &gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f91c82352b12d272adb095b9d880c6c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f065b9babedc70962226bf6cf9cdca8/" rel="bookmark">
			全屏展示 【前端实现】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全屏展示 1、css实现 &lt;div :class="{'full-screen': isFullScreen}"&gt; 全屏展示模块 &lt;/div&gt; // 全屏展示按钮 &lt;a href="javascript:;" class="open-full-screen" @click="viewFullScreen"&gt; &lt;i class="el-icon-full-screen" /&gt;全屏展示 &lt;/a&gt; &lt;a href="javascript:;" @click="closeFullScreen"&gt;关闭全屏&lt;/a&gt; &lt;script&gt; // 全屏展示 viewFullScreen() { this.isFullScreen = true; document.body.style = 'overflow: hidden'; }, // 关闭全屏 closeFullScreen() { this.isFullScreen = false; document.body.style = 'overflow: auto'; } &lt;/script&gt; &lt;style&gt; .full-screen { position: fixed; top: 0; left: 0; bottom: 0; right: 0; z-index: 2000; background-color: #fff; overflow-y: auto; } &lt;/style&gt; 2、js实现 RequestFullScreen / exitFullScreen
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f065b9babedc70962226bf6cf9cdca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9145dd1f5e398e42e92bc73c2059a793/" rel="bookmark">
			文件下载之文件中文名的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package cn.itcast.Utils; import sun.misc.BASE64Encoder; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; public class DownLoadUtils { public static String getFileName(String agent, String filename) throws UnsupportedEncodingException { if (agent.contains("MSIE")) { // IE浏览器 filename = URLEncoder.encode(filename, "utf-8"); filename = filename.replace("+", " "); } else if (agent.contains("Firefox")) { // 火狐浏览器 BASE64Encoder base64Encoder = new BASE64Encoder(); filename = "=?utf-8?B?" + base64Encoder.encode(filename.getBytes("utf-8")) + "?="; } else { // 其它浏览器 filename = URLEncoder.encode(filename, "utf-8"); } return filename; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e256b7409915cbfc929ba9e19f28f83/" rel="bookmark">
			SQL Server更新读写权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Use db GO sp_change_users_login 'update_one', 'writeperson', 'writeperson' GO sp_change_users_login 'update_one', 'browseperson', 'browseperson' GO 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f67b708bea27f93ab8b312b28bd6afa1/" rel="bookmark">
			CentOS 更改Python2到Python3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：查看原来的python版本及依赖： cd /usr/bin
ls python*
ls -al python*
结果显示python依赖于python2,python2依赖于python2.7。
第二步：备份原来的python： mv python python.bak
第三步：在ftp上下载需要安装的python包 网址https://www.python.org/ftp/python/。 第四步：在/usr/local创建python3文件夹。把下载好的python压缩包放进去，然后解压 wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz
tar -xvf Python-3.6.3.tgz
第五步：安装python： 进入到python目录下执行
./configure --prefix=/usr/local/python3Dir
make
make install
第六步：创建软连接： 进入到/usr/bin 执行
ln -s /usr/local/python3Dir/bin/python3 /usr/bin/python
第七步：修改yum中的python配置： vim /usr/bin/yum
修改第一行为#！/usr/bin/python，保存退出。
然后就可以正常使用了。
注意，如果使用yum安装软件的时候报错了，应该修改对应包的第一行参考第七步。都是python修改导致的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2ea2a223ac51275f17908b993b9defd/" rel="bookmark">
			DNN分类指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15cdee8521bc6f208974fd2ab7bc9b2e/" rel="bookmark">
			MySQL创建读写账号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、创建只读账号 GRANT Select ON *.* TO **readuser**@"%" IDENTIFIED BY "**readuser_123456**" %如果替换成ip，则为只有对应的ip可以连接
二、创建增删改查账号 GRANT Select,Update,insert,delete ON *.* TO **writeuser**@"%" IDENTIFIED BY "**writeuser_123456**" %如果替换成ip，则为只有对应的ip可以连接
三、删除账号 drop user xxx@"%" "%"表示任意非本地机器
四、MySQL账号授权命令说明 grant 权限 on 库名.表名 to 用户名@"host" identified by "密码"; host：指定该用户在哪个主机上可以登录，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登录，可以使用通配符%。
// 创建一个名叫user1，密码pigcms的账号，并赋予给它查询、插入、更新、删除（pigcms.* pigcms库所有表）的权限。 grant select, insert, update, delete on pigcms.* to user1@"%" Identified by "pigcms"; flush privileges; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04c640c6f9b76ad2fee84c88fa373c3e/" rel="bookmark">
			在STM32F4上移植LVGL8.2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么选择LVGL8.2版本 因为想使用NXP的GUI Guider进行开发，而目前他的版本支持只有7.10.1和8.2.0两个。
二，获取LVGL并移植 到下列地址下载：
LVGL的GITHUB仓库
选择8.2版本
三、新建工程 1.要求
有一个显示屏（分辨率大于100*100,后续GUI Guider要求），单片机能正常驱动。并有一个填充点函数，类似于LCD_Fill(uint16_t x,uint16_t y,uint16_t color);
最好编写一个色块填充函数，有利于提高速度。
2.复制LVGL驱动
2.1 单片机工程文件夹下面建立lvgl文件夹，用来存放驱动；
2.2将下载的8.2版本LVGL解压后，复制下列文件到单片机工程文件
2.3复制完成后，文件列表如下，注意删除文件名的“_template”后缀，porting文件夹里面的也要删除这个后缀：
2.4在单片机工程管理里面，建立管理目录：
其中GUI/LVGL，添加lvgl-&gt;src下的所有C文件。这个比较考验耐心，很多文件。
GUI/Porting，添加lvgl-&gt;porting文件夹里面的C文件。
GUI/APP，添加lv_config.h和lvgl.h头文件，添加完效果如下：
其中GUI/Generated先不管。
2.5修改lv_port_disp.c文件内容：
同时更新此文件包含的刷屏函数
/*Flush the content of the internal buffer the specific area on the display *You can use DMA or any hardware acceleration to do this operation in the background but *'lv_disp_flush_ready()' has to be called when finished.*/ static void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p) { /*The most simple case (but also the slowest) to put all pixels to the screen one-by-one*/ // int32_t x; // int32_t y; // for(y = area-&gt;y1; y &lt;= area-&gt;y2; y++) { // for(x = area-&gt;x1; x &lt;= area-&gt;x2; x++) { // /*Put a pixel to the display.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04c640c6f9b76ad2fee84c88fa373c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f0dcb896d77b1f3dfd5a80669654ec/" rel="bookmark">
			UOS多显卡配置以及kvm虚拟机配置多屏或多显卡备忘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没更新Blog了，最近打坦克世界使了点劲，正好上次的测试还没放上来，晚上有点时间给补上。
目录 UOS多显卡配置
KVM虚拟机配置多个屏幕
UOS多显卡配置 不知道为啥，默认DDE桌面是不支持在多个显卡上同时输出的，无论怎么配置xorg.conf,但通过测试发现可以在serverlayout里面添加
Option "Xinerama" "on" 选项，添加后，DDE桌面能在两边都显示。但这种情况下，无法用xrandr操作了。
其实在Linux下的多屏幕显示，多显卡以及无头显卡等的配置还真的比较复杂，包括多屏组合等。同样的效果还有不同的实现方式，包括不同的先开，还有不通的窗口管理器对不同的方式也有不一样的支持程度。所以，这就是开源的碎片化，有机会多整理一下这些配置。
KVM虚拟机配置多个屏幕 这个需求来源是因为我想在虚拟机里面测试一下多个屏幕和多个显卡的组合情况，默认机器用libvirt来管理，virt-manager做图形管理，这种情况下是没办法让虚拟机有多个显示屏的。
在我的UOS机器上，发现要让虚拟机支持多个屏幕，需要完成以下几个配置：
1. 显卡必须配置为virtio，其他类型不行。
2. 必须开启virt-manager xml编辑,虚拟机创建好后，默认显卡连接的显示器被配置为1个，需要修改xml为2个或者多个。如下图
3. 开启虚拟机后，不能用virt-manager自带的控制台查看虚拟机,必须用remote-viewer去连接spice端口 remote-viewer spice://IP:PORT 这种格式来查看
上图我由于没安装系统，所以，未启用第二显示器，如果在有操作系统的情况下，可以点出来2个屏幕窗口。
其他：根据其他资料，如果虚拟机为linux,虚拟机配置一个显卡，就可以配置出多个显示器来，但如果是windows，则需要配置多个显卡，才能配置出多个显示起来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/896a71f9bad4cb70b43a759c2391d2fc/" rel="bookmark">
			Linux系统 熟练掌握 shell环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熟练掌握 shell环境变量
shell就是用户与操作系统内核之间的接口，起着协调用户与系统的一致性和在用户与系统之间进行交互的作用。
shell支持具有字符串值的变量。shell变量不需要专门的说明语句，通过赋值语句完成变量说明并予以赋值。在命令行或 shell 脚本文件中使用Sname的形式引用变量name的值。
1.变量的定义和引用
在shell中，变量的赋值格式如下：
name-string
其中，name是变量名，它的值就是string，“=”是赋值符号。变量名是
以字母或下画线开头的字母、数字和下画线字符序列组成的。
通过在变量名（name）前加$字符（如$name）引用变量的值，引用的
结果就是用字符串string代替$name，此过程也称为变量替换。
在定义变量时，若string中包含空格、制表符和换行符，则sting必须用'string 或者"string"的形式，即用单（双）引号将其括起来。双引号内允许变量替换，而单引号内则不可以。
下面给出一个定义和使用shell变量的例子。
//显示字符常量
[ro0t@CentOS7-1 ~]# echo who are you
who are you
[rO0t@CentOS7-1 ~]# echo 'who are you'
who are you
[r00t@CentOS7-1 ~]# echo "who are you"
who are you
[root@CentOS7-1~]#
//由于要输出的字符串中没有特殊字符，所以’’和”"的效果是一样的，不用““但相当于使用了““
[root@CentOS7-1 ~]# echo Je t'aime
&gt;
//由于要使用特殊字符（'）,
//'不匹配，shel1认为命令行没有结束，回车后会出现系统第二提示符，
//让用户继续输入命令行，按“Ctrl+c”组合键结束
[root@CentOS7-1~]#
//为了解决这个问题，可以使用下面的两种方法[r00t@CentOS7-1 ~]# echo "Je t'aime"
Je t'aime
[root@CentOS7-1 ~]# echo Je t\'aime
2. shell变量的作用域
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/896a71f9bad4cb70b43a759c2391d2fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/119857725c3dd19377360bed661d461e/" rel="bookmark">
			Resnet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景介绍 2012开始，从Alexnet开始涌现出一大波神经网络，不断刷新着ImageNet榜单，很多论文揭示了网络深度与性能的关系，理论上，增加神经网络层数后训练的精度不应该会变差，但是没有具体的实验和工程方法可以实现，因为随着网络深度的增加，会伴随着梯度消失或梯度爆炸的问题，本文提出了一种深度残差模型(ResNet)，解决了深层模型难训练以及性能退化的问题。何恺明也因此摘得CVPR2016 Best Paper。
2. 动机 想要回答这个问题，逃不过的一个问题就是梯度消失（网络层数过多，求导时得到的梯度近似为围绕0 的高斯分布，无法继续找到最优解，在某个位置徘徊（鞍点）、以及梯度爆炸问题。）论文提到这两个问题已经通过normalized initialization方法和intermediate normalization layers有效缓解。
实际上在网络深度加深时，还有一个问题暴露出来，随着网络深度的加深，精度也开始下降。这不是因为overfitting（train error 低 test error 高）造成的，因为误差都很高，下图可以出56-layer的网络表现比20-layer的还差。
因此这是一个优化问题，论文证明了通过改变模型结构可以解决这个问题。
3. 基本模块Building Block 对于一个堆积层结构（几层堆积而成）当输入为x时其学习到的特征记为H(x)，现在我们希望其可以学习到残差F(x)=H(x)−x，这样其实原始的学习特征是 F(x)+x。之所以这样是因为残差学习相比原始特征直接学习更容易。当残差为0时，此时堆积层仅仅做了恒等映射，至少网络性能不会下降，实际上残差不会为0，这也会使得堆积层在输入特征基础上学习到新的特征，从而拥有更好的性能。残差学习的结构如图所示。这有点类似于电路中的“短路”，所以是一种短路连接（shortcut connection）。
公式可以定义为：
Y = F ( x , { W i } ) + x Y = \mathcal{F}(x,\{W_i\})+x Y=F(x,{Wi​})+x （1）
x , y x,y x,y表示输入和输出向量, F ( x , { W i } ) \mathcal{F} (x ,\{W_i\}) F(x,{Wi​})表示残差块学习到的特征，例如一个两层网络 ，
F = W 2 σ ( W 1 x ) \mathcal {F} =W_2 \sigma(W_1 x) F=W2​σ(W1​x), σ \sigma σ表示Relu函数。 F + x \mathcal{F} +x F+x表示逐元素相加的残差连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/119857725c3dd19377360bed661d461e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcbe43090ec25552b23b453d3eee3bad/" rel="bookmark">
			如何ping一个网段下的所有IP地址，并保存返回结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		循环的ping一个网段的所有IP地址
for /L %i in (1,1,255) do ping -n 1 -w 60 192.168.1.%i | find "回复" &gt;&gt;d:\pingall.txt -n：表示一次ping几次
-w：表示一次ping60毫秒
其中的
in (1,1,255) 和 192.168.1.%i表示ping的IP地址是从 192.168.1.1~192.168.1.255所有的IP地址都ping一遍
| find "回复" &gt;&gt;d:\pingall.txt 为管道命令，将输出的内容添加到d:\pingall.txt的文件中
例如返回结果为：来自 192.168.1.4 的回复: 字节=32 时间&lt;1ms TTL=64
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/207b189a1025dd4d3caf49d42e3fc32c/" rel="bookmark">
			Android 桌面小组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建桌面小组件 创建AppWidgetProvider类
创建一个AppWidgetProvider类，桌面小组件在更新、启用、停用和删除应用微件时收到广播。而AppWidgetProvider继承BroadcastReceiver，并且专门对小组件进行了一定的广播过滤，因此我们需要创建一个自定义的AppWidgetProvider类用来处理小组件相关的操作。 package com.example.widgetdemo import android.appwidget.AppWidgetManager import android.appwidget.AppWidgetProvider import android.content.Context import android.content.Intent import android.os.Bundle import android.util.Log const val TAG = "MyWidgetProvider" class MyWidgetProvider : AppWidgetProvider() { /** * 每次收到广播之后就会调用该函数，会在其他方法之前进行回调。一般可以不实现 * 默认的 AppWidgetProvider 实现会过滤所有应用微件广播并视情况调用上述方法 */ override fun onReceive(context: Context?, intent: Intent?) { super.onReceive(context, intent) Log.d(TAG, "invoke onReceive......") } /** * 调用此方法可以按 AppWidgetProviderInfo 中的 updatePeriodMillis 属性定义的时间间隔来更新应用微件 * 当用户添加应用微件时也会调用此方法，所以它应执行基本设置，如定义视图的事件处理脚本以及根据需要启动临时的 Service。 * 不过，如果您已声明配置 Activity，则当用户添加应用微件时不会调用此方法，但会调用它来执行后续更新。 * 由配置 Activity 负责在配置完成后执行首次更新。 */ override fun onUpdate(context: Context?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/207b189a1025dd4d3caf49d42e3fc32c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/217/">«</a>
	<span class="pagination__item pagination__item--current">218/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/219/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>