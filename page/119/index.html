<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2893589c4c1781d722f0fe447a96bf30/" rel="bookmark">
			插入排序（直接插入排序 折半插入排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接插入排序 void InsertSort(ElemType A[],int n) { int i,j; for(i=2;i&lt;=n;i++) if(A[i]&lt;A[i-1]) { A[0]=A[i]; for(j=i-1;A[0]&lt;A[j];--j) A[j+1]=A[j]; A[j+1]=A[0]; } } 折半插入排序 void BinInsertSort(int A[],int n) { int i,j,low,high,mid; for(i=2;i&lt;=n;i++) { A[0]=A[i]; low=1;high=i-1; while(low&lt;=high) { mid=(low+high)/2; if(A[0]&lt;A[mid]) high=mid-1; else low=mid+1; } for(j=i-1;j&gt;=high+1;j--) A[j+1]=A[j]; A[high+1]=A[0]; } } 运行源程序代码
//————————————直接插入排序算法————————————// void InsertSort(int A[],int n) { int i,j; for(i=2;i&lt;=n;i++) if(A[i]&lt;A[i-1]) { A[0]=A[i]; for(j=i-1;A[0]&lt;A[j];j--) A[j+1]=A[j]; A[j+1]=A[0]; } } //————————————折半插入排序算法————————————// void BinInsertSort(int A[],int n) { int i,j,low,high,mid; for(i=2;i&lt;=n;i++) { A[0]=A[i]; low=1;high=i-1; while(low&lt;=high) { mid=(low+high)/2; if(A[0]&lt;A[mid]) high=mid-1; else low=mid+1; } for(j=i-1;j&gt;=high+1;j--) A[j+1]=A[j]; A[high+1]=A[0]; } } void Disply(int A[],int n) { int i; for(i=1;i&lt;=n;i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2893589c4c1781d722f0fe447a96bf30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1e2750c57f3b0ff36b0dfdfdc9c5d76/" rel="bookmark">
			DPDK dpaa发包流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文以dpdk-github.qoriq-os-21.11-qoriq为例。
dpaa的发包最终调用的是dpaa_eth_queue_tx接口
1,图中nb_bufs是需要发送的包的个数，frames_to_send是一次能发的包的最大个数。
2，indirect应该是某种特殊包，暂未研究。
3，extbuf应该也是种特殊包处理，暂未研究。
4，对于分片包，因为一个分片包会分出两个mbuf（一个存放mac头+ip头大小的包，另一个存放分片包的数据），当时ls1043时，realloc_mbuf=1，所以会走rellocate_mbuf(会把两个mbuf合成一个mbuf).
5，当mbuf都转换为fd格式之后，通过qman_enqueue_multi进行入队操作，把数据包放到eqcr队列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d62f8893f41c937be9321f3d9fbb5fcb/" rel="bookmark">
			一文详解 C&#43;&#43; 日志框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者： 一去、二三里
个人微信号： iwaleon
微信公众号： 高效程序员
日志框架 日志框架 - 一个经过专门设计的实用程序，用于规范应用程序的日志记录过程。
日志框架可以自己编写（需要一定的能力哦），也可以由第三方（例如：log4cplus）提供。对于不同的日志框架，各自在实现方式上也有所不同。
虽然可以简单地“标准化”日志（例如：调用文件系统 API，将信息写入名为 log.txt 的文件），但是要成为一个严格意义上的框架，必须要超越标准化。也就是说，日志框架必须通过处理日志记录来标准化解决方案，从而暴露一个标准的 API。
没明白？那就再具体一些，设想一个日志框架，封装了三个主要部分：
当想要捕获程序的运行时信息时，首先要发出要记录的信息。然后格式化这些信息，最后决定将它输出到哪里。一般情况下，会输出到文件中，但是也可以将其输出到控制台、数据库，或者任何能够接收数据的地方。
如果有一系列代码，能够解决这些问题，那么就可以被看作是一个日志框架。
为什么不是 cout 使用日志，只为成为更好的攻城狮。
也许有人会问：既然 C++ 中有 cout，为什么还要使用日志呢？
无法否认，在使用像 C++、Java、PHP 这样的编程语言时，我们会经常将消息打印到控制台，因为这是开发、测试和调试程序的一部分。但倘若我们正在处理一个服务端程序，却无法看到其内部发生了什么，这时该怎么办？唯一的可见性工具是日志文件，如果没有日志，我们就不能进行任何调试，也无法知道程序内部在做什么。
尽管 C++ 中有相当方便的 cout 输出流，可以在控制台上打印一些信息，或者可以通过其他方式将这些信息重定向到文件中，但这对于实际的应用程序来说根本不够。尤其对于复杂的 C++ 程序来说，像 log4cplus 或任何其他日志框架能够提供了更多的灵活性，而这是 cout 不可能完成的。
在编写代码时，使用日志框架是一种很好的实践。即使像《代码整洁之道》这样的书籍，也建议学习像 Log4 这样的框架进行日志记录。所以，应尽可能的在生产代码中使用日志，而不是用 cout 来打印东西（这是不可接受的）。
使用日志的好处 日志是一个优秀系统不可或缺的组成部分。
对于很多人来说，日志的作用仅限于调试。其实不然，它在很多方面都非常有用。
日志是最好的诊断工具
绝大多数人都曾面临这样的困境 - 一旦程序出现问题，很长时间都找不出原因！
缺少日志，我们将不得不依赖于客户或技术支持，让他们描述在什么情况下发生了什么（很可能会存在一些误导）。随后我们需要通过开发环境重现问题，并进行各种调试，直至错误修复为止，然而这一般会耗费很长时间。但若有日志的帮助，我们便能迅速摆脱这种困境，可以很快地发现异常，并快速定位、解决问题！
日志让我们有机会监测模块的瓶颈
随着项目规模的增加，模块会越来越多，调优也变成了一场持久战。
通过记录某些操作所花费的时间，我们可以及时地检测模块的瓶颈，并针对性地对一些耗时操作做出优化。
日志有助于我们了解用户的行为
为了提高产品质量，提供个性化服务，就必须了解用户行为 - 他们做了什么，想要什么。
要搞清楚这些，当然要有数据，所以需要采集和分析用户的行为，而日志无疑是最主要的数据来源。
要不要重新发明轮子 不要去重新发明轮子 - 《麦肯锡方法》
既然已经对日志框架有了明确的了解，那么应该使用现有的日志框架，还是构建自己的日志框架呢？其实，这是一个老生常谈的问题了 - 要不要重新发明轮子？引用莎士比亚戏剧《哈姆雷特》中的一句名言：
To be or not to be - that is the question.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d62f8893f41c937be9321f3d9fbb5fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd8d8e2bf6c09de5c025ac1fc70fa3a/" rel="bookmark">
			Android bitmap压缩方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、质量压缩1.1、quality压缩1.2、RGB_565压缩 2、宽高压缩2.1、采样率压缩2.2、Matrix 缩放法2.3、bitmap.createScaledBitmap方法 前言 Bitmap所占用的内存 = 图片长度 x 图片宽度 x 一个像素点占用的字节数。
3个参数，任意减少一个的值，就达到了压缩的效果。
1、质量压缩 1.1、quality压缩 bitmap.compress(Bitmap.CompressFormat.JPEG, quality, byteArrayOutputStream );
主要是通过设置quality来降低质量，0-100范围。
PS：PNG格式会忽略这个参数，所以Bitmap.CompressFormat不可以选择PNG格式
/** * 压缩图片 * * @param bitmap * 被压缩的图片 * @param sizeLimit * 大小限制 * @return * 压缩后的图片 */ private Bitmap compressBitmap(Bitmap bitmap, long sizeLimit) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); int quality = 100; bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos); // 循环判断压缩后图片是否超过限制大小 while(baos.toByteArray().length / 1024 &gt; sizeLimit) { // 清空baos baos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cd8d8e2bf6c09de5c025ac1fc70fa3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690fe24777c45a077b1ec96cedf28069/" rel="bookmark">
			一：liunx环境部署onlyOffice
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、描述：
本文章通过docker在liunx环境下部署onlyOffice及依赖插件，部署的是7.1版本的onlyOffice，7.2及以上版本增加了jwt密钥验证比较麻烦（我没弄成功。。。）。
二、部署步骤：
1、通过docker拉去only Office镜像（可以在hub.docker.com公网查看拉去命令）：
docker pull onlyoffice/documentserver:7.1
2、通过docker拉取postgresql镜像（注意：必须9.6版本，高版本的密码验证策略不一样onlyOffice不支持）：
docker pull postgres:9.6
3、制作postgresql镜像容器（建立用户：postgres，密码：123456，库名：postgres的数据库用户）：
docker run --name postgres -e POSTGRES_PASSWORD=123456 -p 5432:5432 -v /home/postgresql/pgdata:/var/lib/postgresql/data -d postgres:9.6
4、制作only Office镜像容器（默认是80端口，这里映射成9050端口，可以按自己的改）：
sudo docker run -i -t -d -p 9050:80 \
-v /app/onlyoffice/DocumentServer/logs:/var/log/onlyoffice \
-v /app/onlyoffice/DocumentServer/data:/var/www/onlyoffice/Data onlyoffice/documentserver:7.1
5、查看docker容器（可查看到postgresql和onlyOffice都已启动）：
docker ps -a
6、通过Navicat工具在postgresql数据库增加onlyoffice用户及库（也可通过命令，但我不会），如下图：
先增加用户：用户名及密码都是：onlyoffice
再增加库：onlyoffice
7、在新增加的onlyoffice库里执行初始化sql（这个必须执行，不然集成到系统里时会一直显示：加载中。。。）：
8、修改onlyOffice配置文件local.json:
先用命令将配置文件下载下来（因为不能docker里不能直接编辑）：我下载到/usr/tmp/目录了.
docker cp 容器ID:/etc/onlyoffice/documentserver/local.json /usr/tmp/
修改配置文件local.json：按照postgresql数据库连接信息进行修改，注意dbHost要用服务器实际IP。如果不改在页面加载word或者excel文档时会一直显示加载中。
注意：如果用mysql数据库的话按照以下进行操作：
1、mysql的配置文件my.ini：（mysql8.0及以上版本需要此操作）
authentication_policy=caching_sha2_password
修改为：
authentication_policy=*
2、执行语句：（mysql8.0及以上版本需要此操作）
ALTER USER '用户'@'%' IDENTIFIED WITH mysql_native_password BY '密码';
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/690fe24777c45a077b1ec96cedf28069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb54073c102fa246bc6c8803bd475de/" rel="bookmark">
			前端VUE 启动时关闭生产提示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：You are running Vue in development mode.Make sure to turn on production mode when deploying for production.
解决:Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property：
productionTip 类型：boolean
默认值：true
用法：
设置为 false 以阻止 vue 在启动时生成生产提示。
刷新后查看控制台就没有了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac9ae46352a23b3aeba083f97814fa4f/" rel="bookmark">
			Android EditText的setOnEditorActionListener方法——监听软键盘按键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、控件EditText的setOnEditorActionListener方法的使用2、 android 软件盘事件响应：android: imeOptions 、KeyEvent、android: inputType2.1 EditorInfo2.2 KeyEvent2.3 android 输入类型：android:inputType 1、控件EditText的setOnEditorActionListener方法的使用 setOnEditorActionListener这个方法，并不是在我们点击EditText的时候触发，也不是在我们对EditText进行编辑时触发，而是在我们编辑完之后点击软键盘上的各种键才会触发。
通过 布局文件 中的imeOptions可以控制软件盘右下角的按钮显示为不同按钮。所以和EditorInfo搭配起来可以实现各种软键盘的功能。
imeOptions=”actionUnspecified” –&gt; EditorInfo.IME_ACTION_UNSPECIFIED
imeOptions=”actionNone” –&gt; EditorInfo.IME_ACTION_NONE
imeOptions=”actionGo” –&gt; EditorInfo.IME_ACTION_GO
imeOptions=”actionSearch” –&gt; EditorInfo.IME_ACTION_SEARCH
imeOptions=”actionSend” –&gt; EditorInfo.IME_ACTION_SEND
imeOptions=”actionNext” –&gt; EditorInfo.IME_ACTION_NEXT
imeOptions=”actionDone” –&gt; EditorInfo.IME_ACTION_DONE
布局中定义一个EditText控件
&lt;EditText android:id="@+id/ET_phonenumber" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_toLeftOf="@id/buttonAdd" android:hint="@string/enter_new_note" android:imeOptions="actionDone"// 这里和onEditorAction中actionId对应。 android:inputType="text"/&gt; 添加setOnEditorActionListener方法
ET_phonenumber.setOnEditorActionListener(new OnEditorActionListener() { @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) { if (actionId == EditorInfo.IME_ACTION_DONE) { // 按下完成按钮，这里和上面imeOptions对应 text.setText("Editing EditorInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac9ae46352a23b3aeba083f97814fa4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4b3259e1647b8246bd9d561d0f5af49/" rel="bookmark">
			JSON 工具类(java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cn.hutool.core.lang.Dict; import cn.hutool.core.util.ArrayUtil; import cn.hutool.core.util.ObjectUtil; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.exc.MismatchedInputException; import lombok.AccessLevel; import lombok.NoArgsConstructor; import java.io.IOException; import java.util.ArrayList; import java.util.List; /** * JSON 工具类 */ @NoArgsConstructor(access = AccessLevel.PRIVATE) public class JsonUtils { private static final ObjectMapper OBJECT_MAPPER = SpringUtils.getBean(ObjectMapper.class); public static ObjectMapper getObjectMapper() { return OBJECT_MAPPER; } public static String toJsonString(Object object) { if (ObjectUtil.isNull(object)) { return null; } try { return OBJECT_MAPPER.writeValueAsString(object); } catch (JsonProcessingException e) { throw new RuntimeException(e); } } public static &lt;T&gt; T parseObject(String text, Class&lt;T&gt; clazz) { if (StringUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4b3259e1647b8246bd9d561d0f5af49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86052bd8e3213e9c7b9b266ccd664ed1/" rel="bookmark">
			Python常用的numpy库详解!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python应用领域十分广泛，尤其是在数据分析和数学计算方面有着非常重要的作用，而Numpy库便是其中一个重要的工具。那么什么是numpy库?numpy库有哪些重要特点?本文为大家详细讲解一下。
Numpy库是一个专门用于科学计算和数值分析的Python插件。它提供了一种高效的多维数组对象，以及各种派生对象，用于数学函数的操作，并且能够高效地读写磁盘上的数据。
以下是Numpy库的重要特点：
1、快速的数组操作：numpy的核心是其数组对象，能够在Python中进行高效的操作。
2、丰富的科学计算库：Numpy是用于科学计算和数据分析的库，因此提供了大量高效的数学函数和算法，如线性代数、傅里叶变换、随机数生成等。
3、跨平台支持：numpy的代码可在多个操作系统和硬件上运行。
4、大规模数据集支持：numpy为大规模数据集处理提供了出色的支持。它可以处理多维度数据，支持数组的索引和切片，使得程序在处理大型跨越多个变量的数据集方面变得更加容易。
5、扩展库支持：numpy是一个支持丰富扩展库的库。许多其他的科学计算和数据分析工具都依赖于numpy库作为其基础。
在numpy库中，最重要的特点之一就是它的多维数组对象。这些对象被称为ndarray，是numpy库的核心数据结构。ndarray由两部分组成：由相同类型数据元素的N维数组与该数组相关的维度和形状。ndarray的维度和形状可以通过shape属性获得。ndarray类型的定义如下：
import numpy as np
arr = np.array([1,2,3,4,5]) #一维数组
print(arr)
#输出结果：
#[1 2 3 4 5]
可以看到，numpy数组的创建方式是通过Python列表的方式创建的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138a60d29acef7dde58947e38eb1e9a4/" rel="bookmark">
			快速上手 如何用 Vite 从零搭建前端项目？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		过前面的学习，我们已经知道了前端构建工具的意义，也明确了 Vite 相比于传统构建工具 Webpack 的优势。相信对于为什么要学习和使用 Vite 这个问题，你已经有了自己的答案。
回到实际的应用场景当中，我们应该如何使用 Vite 来搭建前端工程项目呢？这一节，我将和你一起近距离接触 Vite，学完本节你不仅能学会前端开发环境的搭建，更重要的是，你能上手使用 Vite 来初始化一个脚手架项目，并理解这个项目究竟是如何运行起来的。
环境搭建 首先需要的是代码编辑器和浏览器，我推荐安装VSCode和Chrome浏览器。
其次是安装 Node.js，如果你的系统中还没有安装 Node.js ，可以进入 Nodejs 官网下载相应的安装包进行手动安装；如果已经安装了 Node.js，你可以使用这个命令检查一下 Node.js 版本:
node -v 推荐 12.0.0 及以上版本，如果低于这个版本，推荐使用 nvm 工具切换 Nodejs 版本。
安装完 Nodejs 之后，包管理器npm也会被自动安装，你可以执行下面的命令来验证:
npm -v 当然，在现代的前端项目中，我非常不推荐使用 npm 作为项目的包管理器，甚至也不再推荐yarn(npm 的替代方案)，因为两者都存在比较严重的性能和安全问题，而这些问题在 pnpm 中得到了很好的解决，更多细节可以参考我的这篇博客: 关于现代包管理器的深度思考——为什么现在我更推荐 pnpm 而不是 npm/yarn? 。
因此，包管理器方面我推荐使用 pnpm，安装方式非常简单，输入如下命令即可:
npm i -g pnpm 由于默认的镜像源在国外，包下载速度和稳定性都不太好，因此我建议你换成国内的镜像源，这样pnpm install命令的体验会好很多，命令如下:
pnpm config set registry https://registry.npmmirror.com/ 项目初始化 在搭建了基本的开发环境之后，我们进入到项目初始化阶段。你可以在终端命令行中输入如下的命令:
pnpm create vite 在执行完这个命令后，pnpm 首先会自动下载 create-vite 这个第三方包，然后执行这个包中的项目初始化逻辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/138a60d29acef7dde58947e38eb1e9a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c9294bf85c848fff328d8db2f9e5e3d/" rel="bookmark">
			什么是模拟信号和数字信号？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 本篇文章也是从网上查阅了很多资料按照自己理解所整合的，主要作用于刚开始接触的人来理解这个概念。其中可能会存在一些不专业的名词或不合适的例子可以在评论区告诉我，我会及时做出改正。
二、信号 信号是信息的物理表现形式，信息则是信号的具体内容。
举个例子过马路我们看到红灯亮起时要停，绿灯亮起时要走。其中红绿灯的亮起代表了信号，而我们看到灯亮起后的行为就是信息。
个人理解：自然界中看到的东西本身是“没有什么含义”（人类没有给他定义前）的这种就是信号，当这种信号传输到我们的大脑后想到的内容就是信息
模拟和数字信号在物理界本身“没什么含义”。只是通过这些信号的变化我们得到了一些信息，用于计算或者做出行为等。这才有了“真正含义”。
三、模拟信号 模拟信号是指在一定周期内连续变化的信号。例如：电压或声波强度这些自然信号在一分钟内的变化。
信号强弱（振幅）与时间的关系图如下： 特性
1.时间连续，振幅值连续。从上图可以看出时间与振幅是连续变化的。2.时间可以无限细分，同样振幅也是无限细分的。3.自然界中的所有信号都是模拟信号。（自然界信号都与时间有关且连续可无限细分） 四、数字信号 我们知道自然界中的信号是连续可无限细分的。但是我们在实际计算中基本上用一些自然数、小数、实数、代数数、复数等等计算，即使是圆周率π（无限不循环小数）我们在计算时也几乎只用到3.1415926（高数中无穷大的数值也是用符号表示∞）。计算机也是如此，计算机想要一个“确切的数值”，这种无限细分的数值可没办法参与计算。所以需要将模拟信号离散化处理成数字信号。当然这种说法不是很严谨。但最重要的一点是数字信号采用0或1的二进制，其抗材料本身干扰和环境干扰的能力都比模拟信号强很多。下面举个例子来解释数字信号是离散化和抗干扰能力强的原因。
1.模拟信号转换数字信号的离散化处理 离散化后得到的数值是离散值，离散值就是孤立的点集，像区间，它在每一点上都是连续的，而像整数集，它的每一元素之间都有一点的距离。
是不是有点难懂，还是一样举个例子来看自然数中0，1，2，3....是离散值。原因很简单，0和1数字之间其实是可以无限细分的（0后跟小数点可以有无限位数 0.1、0.01、0.001......）。然而自然数定义中只能是整数所以这里将小于1的值都“归总到0这个自然数中”。所以说自然数是一个离散值。
在自然界中测量的能无限细分的数据是连续型的，一般人为定义无法细分的都是离散值。
将模拟信号转换为数字信号就是在一定周期内取一段数值并用0或1的二进制数表示。当我们“取其中某一部分的连续数值当成一个整数”时，这种行为就是离散化。
2. 数字信号抗干扰能力强 我们有一个3秒的乐谱（其中只有三个音符）。在山谷两边有两个人分别是小A和小B，小A负责唱乐谱中的音符，小B负责听乐谱并记录。如果小A五音不全，唱出的音与乐谱相差很多，那负责小B得到的乐谱肯定是不正确的。如果山谷中还有鸟鸣、瀑布等其他声音干扰，最终记录的乐谱相差会更大。
小A五音不全代表材料本身干扰。山谷中鸟鸣、瀑布等声音代表环境干扰。
​​​​​​​​​​​​​​
解决办法：
小A与小B事先约定用发音和不发音的组合来确定乐谱中的音符：音符1{不发音，不发音}、音符2{不发音，发音}，音符3{发音，发音}。并且每2秒记录一下。
小A在1~6秒中的发音图 这里我们把“不发音”当作0，“发音”当作1 ，每2秒作为一组进行整合可以得到如下图：
这样我们就知道整个乐谱是{【0，0】，【0，1】，【1，1】} 。根据原先的约定反推回去就能得到正确的音符。
在这个过程中，小A与小B的约定就是通信协议，每2秒为一个周期记录的数据为编码。即使小A五音不全(小A只要发音吼一声就可以记录准确的值)、山谷干扰音（环境干扰只会导致小A的声音高或低，不会影响到小A无法发音）都不会存在问题。这就是数字信号抗材料本身干扰和环境干扰的能力。
缺点： 会损失一些带宽，本来3秒的乐谱，通过转换需要6秒才能完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193993b35c4ee89eaadee928ff5b5aa8/" rel="bookmark">
			STL简介（十分钟快速了解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL基本概念 STL(Standard Template Library,标准模板库)
STL 从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator)
容器和算法之间通过迭代器进行无缝连接。
STL 几乎所有的代码都采用了模板类或者模板函数
STL六大组件 STL大体分为六大组件，分别是:容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器
容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。
算法：各种常用的算法，如sort、find、copy、for_each等
迭代器：扮演了容器与算法之间的胶合剂。
仿函数：行为类似函数，可作为算法的某种策略。
适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
空间配置器：负责空间的配置与管理。
容器：
STL容器就是将运用最广泛的一些数据结构实现出来
常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等
这些容器分为序列式容器和关联式容器两种:
序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置。 ​ 关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系
算法：
有限的步骤，解决逻辑或数学上的问题，这一门学科叫做算法(Algorithms)
算法分为:质变算法和非质变算法。
质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等
非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等
迭代器：
提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。
每个容器都有自己专属的迭代器
迭代器种类：
种类功能支持运算输出迭代器对数据的只写访问只写，支持++前向迭代器读写操作，并能向前推进迭代器读写，支持++、==、！=双向迭代器读写操作，并能向前和向后操作读写，支持++、--，随机访问迭代器读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器读写，支持++、--、[n]、-n、&lt;、&lt;=、&gt;、&gt;=输入迭代器对数据的只读访问只读，支持++、==、！= 常用的容器中迭代器种类为双向迭代器，和随机访问迭代器
每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素
STL- 常用容器 插入和删除提供的位置是迭代器！
尾插 --- push_back
尾删 --- pop_back
头插 --- push_front
头删 --- pop_front
string容器 string是C++风格的字符串，而string本质上是一个类
string和char * 区别：
char * 是一个指针
string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/193993b35c4ee89eaadee928ff5b5aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/047969db5f08b9976fa6511bc6904c3e/" rel="bookmark">
			在服务器部署Next.js、Node.js项目，并实现自动部署（伪CI\CD）超详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、配置服务器
1. 远程连接服务器
· 用服务商提供的远程连接
· 用MotaXterm来远程连接
​编辑​编辑​编辑
2. 登录实例
· 如何获取账号和密码
· 服务商远程连接方式：
· MotaXterm连接方式
三、项目准备与测试
1. 安装nodejs
· 进入安装目录
· 下载
· 解压
· 重命名文件夹
· 配置环境变量
· 检验是否安装成功
· 更换镜像与下载pnpm、yarn、cnpm
2.安装git并配置SSH
· 下载git
· 配置用户名和邮箱
· 配置SSH公钥
3. 上传nodejs项目
4. 配置安全组
5. 测试在互联网上能否访问成功
四、使用pm2持久化运行服务
1. 全局安装pm2
2. pm2常见命令
3. 运行Next.js 服务 （或者node.js）
· 修改package.json
· 输入命令持久化运行服务
· 在服务器上执行上述操作
五、自动部署
1. 引言与原理
2. 编写一个接口
3. 配置Webhooks
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/047969db5f08b9976fa6511bc6904c3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaddddb055b617a16b30ea487ee9dbad/" rel="bookmark">
			关于pytroch的随机数种子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于pytroch的随机数种子 训练产生不同结果的原因训练过程代码cudnn.benchmarkcudnn.deterministic 训练产生不同结果的原因 训练过程 在训练过程中，相同的训练集、测试集划分方式，相同的权重初始化，相同的超参数，但是每次训练结果不同，可能有以下几个原因：
Dropout的存在PyTorch、Python、Numpy中的随机种子没有固定训练数据集被随机打乱了顺序向上采样和插值函数/类的向后是不确定的(PyTorch的问题)
（注意：哪怕这些东西全部固定了，模型的结果依旧不能完全的复现出来，因为硬件设备的不同。） 代码 def set_seed(seed=1029): # 固定python和numpy的随机种子 random.seed(seed) # python random seed os.environ['PYTHONHASHSEED'] = str(seed) # hash random seed np.random.seed(seed) # Numpy random seed # 固定pytorch的随机种子 torch.manual_seed(seed) # pytorch CPU random seed torch.cuda.manual_seed(seed) # pytorch GPUrandom seed torch.cuda.manual_seed_all(seed) # pytorch if you are using multi-GPU. # torch.backends.cudnn.benchmark = True torch.backends.cudnn.deterministic = True # Cudnn cudnn.benchmark 其中torch.backends.cudnn.benchmark如果为Ture，将会让程序在开始时花费一点额外时间，为整个网络的每个卷积层搜索最适合它的卷积实现算法，进而实现网络的加速。它可以让内置的 cuDNN 的 auto-tuner 自动寻找最适合当前配置的高效算法，来达到优化运行效率的问题。
但是是有使用前提的，适用场景是网络结构固定（不是动态变化的），网络的输入形状（包括 batch size，图片大小，输入的通道）是不变的，其实也就是一般情况下都比较适用。反之，如果卷积层的设置一直变化，网络的输入数据在每次 iteration 都变化的话，会导致 cnDNN 每次都会去寻找一遍最优配置，这样反而会降低运行效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eaddddb055b617a16b30ea487ee9dbad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02a736a972dc0031624261b032898ca2/" rel="bookmark">
			java后台API接收json数据，转换json对象问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**public R&lt;Void&gt; add(@Validated(AddGroup.class) @RequestBody JSONObject jsonObject) {** //jsonObject对象（数组，对象，集合，普通字段） **Object productNameIds = jsonObject.get("productNameId");** **Long productNameId = Long.valueOf(String.valueOf(productNameIds));** //json对象转化为BO对象 Object vehicleObject = jsonObject.get("vehicleObject"); OrgProductParameterBo orgProductParameter = JSONUtil.toBean((JSONObject) vehicleObject, OrgProductParameterBo.class); //添加相机参数表 json数组转对象集合 JSONArray cameraParameterList = jsonObject.getJSONArray("cameraParameterList");//获取json数组 List&lt;OrgProductCameraParameterBo&gt; orgProductCameraParameterBos = cameraParameterList.toList(OrgProductCameraParameterBo.class); //多个集合对象转化为一个集合对象 Stream流方法 List&lt;OrgProductPinCameraParameterBo&gt; orgProductPinCameraParameterBosList orgProductPinCameraParameterBosList= Stream.of(orgProductPinCameraParameterBos,orgProductPinCameraParameterBos1,orgProductPinCameraParameterBos2,orgProductPinCameraParameterBos3).flatMap(Collection::stream).collect(Collectors.toList()); } vue3传递多个参数进行保存数据 index addProductImageParameter(form.value.paths,proxy.$route.params.id).then(response=&gt;{ if (response.msg === '操作成功') { proxy.$modal.msgSuccess('保存成功') openPicture.value=false } }) // 新增样品图参数 export function addProductImageParameter(paths,id) { //将请求该方法上传的两个参数合并为data json然后请求后端api const data={ paths, id } return request({ url: '/org/productImageParameter', method: 'post', data: data }) } 后台api public R&lt;Void&gt; add(@Validated(AddGroup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02a736a972dc0031624261b032898ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5de23243eaf3b8f62dcaae61ae420f/" rel="bookmark">
			[WinError 5] 拒绝访问。: ‘C:\\Windows\\system32\\config\\systemprofile\\AppData\\Roaming\\nltk_data‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在调试gpt,langchain,想用django布置到服务器，在本地运行没问题，在服务器runserver也正常，但最后一步，网站访问时一直报这个错，开始一直排查nltk这个库的原因，后面调整思路修改python.exe的权限，修改文件夹的权限，一直报错，看了大量的贴，都改成完全控制了，就是不行。
最后，正确解决方案:先选编辑，添加组和用户，添加Everyone,改成完全控制，就可以正常访问了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593956126205efa044a289f3403f7064/" rel="bookmark">
			WinFrom嵌入谷歌内核ChromiumWebBrowser
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新建WinFrom项目
新建用户控件：WebView.cs
引用相关dll
编写代码如下：
namespace ChromiumWebBrowser
{
public partial class WebView : UserControl
{
#region 初始化浏览器控件
public CefSharp.WinForms.ChromiumWebBrowser webBrower;
private bool _EnableRightMenu = false;
/// &lt;summary&gt;
/// 是否启用右键菜单
/// &lt;/summary&gt;
public bool EnableRightMenu
{
get { return _EnableRightMenu; }
set { _EnableRightMenu = value; }
}
public List&lt;Cookie&gt; cookieList = null;
public bool isEnabledJWT = false;
public string path;
/// &lt;summary&gt;
/// 初始函数
/// &lt;/summary&gt;
public WebView()
{
InitializeComponent();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/593956126205efa044a289f3403f7064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb70a63b4a12543c46faf08ccb3d039/" rel="bookmark">
			Android中设置颜色透明度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.布局中的xml设置
设置其属性:android:background="#AA9E9E9E",其中前两位为透明度，后六位为颜色。 2.在代码中用的话就是用Java代码设置是这样设置的
View v = findViewById(R.id.content);//找到你要设透明背景的layout 的id v.getBackground().setAlpha(100);//0~255透明度值 ，0为完全 3.从FF开始表示完全不透明，到00表示完全透明。左边的是透明百分比，右边是透明的代号，如果你想设置颜色透明50%，就是
#809E9E9E
100% — FF 99% — FC 98% — FA 97% — F7 96% — F5 95% — F2 94% — F0 93% — ED 92% — EB 91% — E8 90% — E6 89% — E3 88% — E0 87% — DE 86% — DB 85% — D9 84% — D6 83% — D4 82% — D1 81% — CF 80% — CC 79% — C9 78% — C7 77% — C4 76% — C2 75% — BF 74% — BD 73% — BA 72% — B8 71% — B5 70% — B3 69% — B0 68% — AD 67% — AB 66% — A8 65% — A6 64% — A3 63% — A1 62% — 9E 61% — 9C 60% — 99 59% — 96 58% — 94 57% — 91 56% — 8F 55% — 8C 54% — 8A 53% — 87 52% — 85 51% — 82 50% — 80 49% — 7D 48% — 7A 47% — 78 46% — 75 45% — 73 44% — 70 43% — 6E 42% — 6B 41% — 69 40% — 66 39% — 63 38% — 61 37% — 5E 36% — 5C 35% — 59 34% — 57 33% — 54 32% — 52 31% — 4F 30% — 4D 29% — 4A 28% — 47 27% — 45 26% — 42 25% — 40 24% — 3D 23% — 3B 22% — 38 21% — 36 20% — 33 19% — 30 18% — 2E 17% — 2B 16% — 29 15% — 26 14% — 24 13% — 21 12% — 1F 11% — 1C 10% — 1A 9% — 17 8% — 14 7% — 12 6% — 0F 5% — 0D 4% — 0A 3% — 08 2% — 05 1% — 03 0% — 00 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5ea61e571c2b6e76dbfb3d541a43008/" rel="bookmark">
			封装一个类似微信通讯录带有字母检索功能的vue组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我们直接使用scrollIntoView方法
该方法将调用它的元素滚动到浏览器窗口的可见区域
语法 element.scrollIntoView（）; // 等同于element.scrollIntoView(true)
element.scrollIntoView（alignToTop）; //布尔参数
element.scrollIntoView（scrollIntoViewOptions）; //对象参数
组件 分析一下功能就知道很简单了。
首先需要一个通讯录列表，其次是字母列表。
字母列表很简单。
第一种方法：直接用fromCharCode，for循环遍历拿到26个英文字母。
// 获取26个英文字母大写 for (var i = 0; i &lt; 26; i++) { this.letter.push(String.fromCharCode(65 + i)) } 但是这样的做法，有一个坏处就是，如果通讯录没有这么多呢？
换句话说，如果通讯录只有ABCDEFG这几个首字母的联系人，你把26个都弄上去有点不太合适。
第二种方法：也是相对简单的，直接从通讯录列表拿到字母。当然，这种方法需要后端给你对应的数据结构。并且得让他给你按首字母排序好，毕竟能少一事少一事。什么？他不干？打一顿他就听话了。
当然，我给出的数据结构你可以参考：
const peoArray = [ { key: "A", list: [ { name: "安吉", }, { name: "安吉", }, ], }, { key: "B", list: [ { name: "爸爸", }, { name: "芭比", }, ], }, { key: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5ea61e571c2b6e76dbfb3d541a43008/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec5785b8365f83db7cb0b7e6e20da1a4/" rel="bookmark">
			Linux如何创建用户、新增用户、创建新用户、删除用户（adduser、deluser）（useradd、userdel）、获取用户列表、查看家目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 新增用户1.1 adduser1.2 useradd（1）不使用任何参数选项创建用户：sudo useradd tt（2）为用户指定参数的useradd命令20230428 关于useradd -m 2. 删除用户2.1 deluser2.2 userdel3. 相关文件 3. 获取用户列表4. 查看家目录查看所有用户家目录查看本地用户家目录查看指定用户家目录 本文主要包含两部分内容： 新建一个用户允许该用户以管理员身份执行命令（在使用服务器的时候，不建议给予普通用户管理员权限）
注：本文基于Ubuntu系统的主机名为HPZ640-1，用户名为mqk，进行创建与删除的新用户名为tt创建用户 创建用户有两条命令：adduer和useradd，对应着两条删除用户的命令：deluser和userdel。
这两种命令之间的区别：
adduser：会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。
useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。
1. 新增用户 1.1 adduser wq@DESKTOP:~$ sudo adduser tt [sudo] password for mqk: 正在添加用户"tt"... 正在添加新组"tt" (1006)... 正在添加新用户"tt" (1006) 到组"tt"... 创建主目录"/home/tt"... 正在从"/etc/skel"复制文件... 输入新的 UNIX 密码： 重新输入新的 UNIX 密码： passwd：已成功更新密码 正在改变 tt 的用户信息 请输入新值，或直接敲回车键以使用默认值 全名 []: 房间号码 []: 工作电话 []: 家庭电话 []: 其它 []: 这些信息是否正确？ [Y/n] y 这样在创建用户名时，就创建了用户的主目录以及密码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec5785b8365f83db7cb0b7e6e20da1a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08d07470f5c95348834bc9399d334d5b/" rel="bookmark">
			Vue3内置组件KeepAlive
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网（推荐直接去看，有例子）：https://cn.vuejs.org/guide/built-ins/keep-alive.html
基本使用 &lt;KeepAlive&gt; 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。
&lt;!-- 非活跃的组件将会被缓存！ --&gt; &lt;KeepAlive&gt; &lt;component :is="activeComponent" /&gt; &lt;/KeepAlive&gt; 包含/排除 &lt;KeepAlive&gt; 默认会缓存内部的所有组件实例，但我们可以通过 include 和 exclude prop 来定制该行为。这两个 prop 的值都
可以是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两种类型的一个数组：
&lt;!-- 以英文逗号分隔的字符串 --&gt; &lt;KeepAlive include="a,b"&gt; &lt;component :is="view" /&gt; &lt;/KeepAlive&gt; &lt;!-- 正则表达式 (需使用 `v-bind`) --&gt; &lt;KeepAlive :include="/a|b/"&gt; &lt;component :is="view" /&gt; &lt;/KeepAlive&gt; &lt;!-- 数组 (需使用 `v-bind`) --&gt; &lt;KeepAlive :include="['a', 'b']"&gt; &lt;component :is="view" /&gt; &lt;/KeepAlive&gt; 它会根据组件的 name 选项进行匹配，所以组件如果想要条件性地被 KeepAlive 缓存，就必须显式声明一个 name 选项。
tip: 在 3.2.34 或以上的版本中，使用 &lt;script setup&gt; 的单文件组件会自动根据文件名生成对应的 name 选项，无需再手动声明。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08d07470f5c95348834bc9399d334d5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837b702c7d03707c688fc13042273fb6/" rel="bookmark">
			【原创】Python脚本新浪微博群抢早鸟&#43;夜猫（2023.7.5可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微博粉丝群每天看着大家抢鸟，真的好羡慕哇！但是早鸟得早上5点，这也太难了吧~
作为一名热爱 coding 的计科生，我想看看使用编程知识试试能不能破解万年抢不到的魔咒~~
开发者文档 首先我找到了微博开发者文档，成功开通了这个服务。
微博开发者文档 API
可惜翻了很久，发现官方并没有给在群里定时发送消息的 API
自己写一个吧 没办法，那就试试自己写一个吧
1. 首先新建一个测试群 2. 然后分析发送消息的请求 确定 url：https://api.weibo.com/webim/groupchat/send_message.jsonheader 载荷 3. postman 测试接口 成功了~ 现在接口已经拿到了😏
4. 写脚本环节 遇到的问题及解决方案： 因为 cookie 会过期，所以我设置了整点访问一次。可以持久化 cookie，更新它的 expire time。
整点发送消息会一秒钟发送多条消息，因为死循环获取到的时间是同一秒内的：
因此发送一条消息后，需要休眠一阵子，我这里设置了 2 min。
time.sleep(120) 5. 部署到云服务器上 6. 测试 大功告成！
早鸟
夜猫
代码自取 https://github.com/kiwi6185/weibo_zaoniaoyemao
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4902657267a5749c63e60ed8442e65ee/" rel="bookmark">
			More than one file was found with OS independent path ‘lib/xxx/xxxx.so‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题:
APP在使用过程中,遇到高版本的android系统,地图开始出现不兼容问题,升级后arcgis版本后,运行编译时出现异常
More than one file was found with OS independent path 'lib/armeabi-v7a/libc++_shared.so'. If you are using jniLibs and CMake IMPORTED targets .... 分析:
依赖so重复
解决:
1,更改module app build.gradle文件,将报错的so文件添加下,报几个加几个
packagingOptions { pickFirst 'lib/xxxx/xxxx.so' } sourceSets { main { jniLibs.srcDirs = ['libs'] } } 2,添加后sync now一下,若没有出现提示,通过build-clean project,rebuild project之后就会出现提示,
必须sync,应该就没问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb43550ecadeff83992170f029e1ee0/" rel="bookmark">
			用Stream流处理重复数据，多种方式去重list，可整体去重或按某个属性去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、String 集合去重，例如List&lt;String&gt; @Test public void listDistinctByStreamDistinct() { //数据准备 List&lt;String&gt; strList = new ArrayList&lt;String&gt;() {{ add("A"); add("A"); add("B"); add("B"); add("C"); }}; //控制台打印原始数据 System.out.println("去重前："); for (String s : strList) { System.out.println(s); } List&lt;String&gt; collectList = strList.stream().distinct().collect(Collectors.toList()); //控制台打印原始数据 System.out.println("去重后："); for (String s : collectList) { System.out.println(s); } } //控制台日志如下： /* 去重前：AABBC 去重后：ABC */ 2、实体对象集合去重，例如List&lt;Student&gt; /** * 定义一个实体类 */ @Data public class Student { private String stuNo; private String name; } @Test public void listDistinctByStreamDistinct() throws Exception { //假设List&lt;Student&gt;数据已经准备好了,命名为studentList System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb43550ecadeff83992170f029e1ee0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60d81603d13ee4c0a8300fb73c73b80/" rel="bookmark">
			基于JavaSpringBoot&#43;Vue&#43;uniapp微信小程序实现鲜花商城购物系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝30W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和毕业项目实战✌
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
目录
1 前言介绍：
2 主要技术：
2.1微信小程序介绍
2.2 Vue技术介绍
2.3 Spring Boot框架
3 功能设计：
3.1 系统架构图
3.2 登录时序图
4 功能实现：
4.1 小程序端：
4.1.1 用户登录:
4.1.2 前台首页：
4.1.3 鲜花商品：
4.1.4 鲜花详情：
4.1.5 订单信息：
​4.1.6 购物车信息：
4.1.7 个人中心：
4.2 管理员端：
4.2.1 后台登录：
​4.2.2 用户管理：
4.2.3 鲜花管理：
4.2.4 订单管理：
4.2.5 公告管理： 5 代码参考：
5.1 花店文件上传
5.2 花店商品订单
6 论文参考：
7 系统总结：
8 其他案例：
9 源码获取：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b60d81603d13ee4c0a8300fb73c73b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60bac276e05162415142c5797d14530b/" rel="bookmark">
			JS - 日期格式化封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		const REGEX_FORMAT = new RegExp("([^\]]+)|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS", "gi") const formatDate = (value, format = 'YYYY-MM-DD') =&gt; { if (!value) return '' // ios 和 mac 系统中，带横杆的字符串日期是格式不了的，这里做一下判断处理 if (typeof value === "string" &amp;&amp; new Date(value).toString() === "Invalid Date") { value = value.replace(/-/g, "/"); } const date = new Date(value) const year = date.getFullYear() const month = date.getMonth() const days = date.getDate() const day = date.getDay() const hours = date.getHours() const minutes = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60bac276e05162415142c5797d14530b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c845e7819eb2caa45e73fe0cf8c5b237/" rel="bookmark">
			Job for sshd.service failed because the control process exited with error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos修改了sshd.config的端口信息，于是执行了systemctl restart sshd.service，可是提示Job for sshd.service failed because the control process exited with error。
1、查看SElinux允许的ssh的端口号
$ sudo semanage port -l | grep ssh
ssh_port_t tcp 22
发现SELinux允许的ssh的端口号和ssh配置文件中设置的端口号不一致。
2、解决方法
使用semanage工具添加ssh端口号
sudo semanage port -a -t ssh_port_t -p tcp 6322
3、重启
sudo systemctl restart sshd.service
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd57400276b665ef3eedfa7f91696a38/" rel="bookmark">
			SVN的介绍、搭建和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. SVN(Subversion)的作用 对数据进行备份对代码进行还原协同修改,多人可以同时修改同一文件多版本项目文件管理历史记录，追溯问题代码的编写人和编写时间，恢复到历史版本权限控制 2. 基于CentOS7系统的SVN服务器端环境搭建 2.1 安装服务器端程序 ### 安装SVN服务器端 yum install -y subversion ### 查看版本信息这里是确认是否正确安装 svn --version 2.2 创建并配置版本库 ### 创建SVN的根目录 mkdir -p /var/svn/repository ### 创建N个项目目录 cd /var/svn/repository/ mkdir pro_oa mkdir pro_erp ### 创建某个项目对应的版本库 cd /var/svn/repository/pro_oa/ svnadmin create /var/svn/repository/pro_oa/ 2.3 配置SVN对应的服务 ### 设置SVN服务开机自启动 systemctl enable svnserve.service ### 指定默认根目录 vim /etc/sysconfig/svnserve OPTIONS="-r /var/svn/repository" ### 永久关闭selinux vim /etc/selinux/config SELINUX=disabled ### 防火墙允许访问默认端口3690 firewall-cmd --zone=public --add-port=3690/tcp --permanent firewall-cmd --permanent --add-service=telnet firewall-cmd --reload ### 修改pro_oa项目下的配置文件 cd /var/svn/repository/pro_oa/conf cp svnserve.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd57400276b665ef3eedfa7f91696a38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2209d7e21399d133b51d0798bf23300f/" rel="bookmark">
			vue自定义全局组件添加，vue组件全局自动添加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue自定义全局组件添加，vue组件全局自动添加 文章目录 vue自定义全局组件添加，vue组件全局自动添加组件（confirm.vue）全局引入js(confirm.js)main.js(注入)使用 组件（confirm.vue） &lt;template&gt; &lt;div :class="{'pop-up':true,'show':show}"&gt; &lt;div class="popup-mask" v-if="hasMark"&gt;&lt;/div&gt; &lt;transition name="bottom"&gt; &lt;div class="popup-note bottom"&gt; &lt;div class="pop-content"&gt; &lt;div class="pop-tit"&gt; {{title}} &lt;/div&gt; &lt;p class="pop-note hasTitle"&gt; &lt;span class="msg" v-html="msg"&gt;&lt;/span&gt; &lt;/p&gt; &lt;div class="btn-wrapper" v-if="type == 'alert'" @click.stop="alertClick"&gt; &lt;span class="btn btn-block yes-btn"&gt;{{alertBtnText}}&lt;/span&gt; &lt;/div&gt; &lt;div class="btn-wrapper" v-if="type == 'confirm'"&gt; &lt;span @touchstart.prevent="noClick" class="btn"&gt;{{noBtnText}}&lt;/span&gt; &lt;span @touchstart.prevent="yesClick" class="btn yes-btn"&gt;{{yesBtnText}} &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { title: { type: String, default: '提示' }, msg: { type: String, default: '' }, type: { type: String, default: 'alert' }, alertBtnText: { type: String, default: '我知道了' }, yesBtnText: { type: String, default: '确定' }, noBtnText: { type: String, default: '取消' }, hasMark: { type: Boolean, default: true } }, data() { return { promiseStatus: null, show: false } }, methods: { confirm() { let _this = this; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2209d7e21399d133b51d0798bf23300f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98899299c7ba98242e35ee1c3ab8161/" rel="bookmark">
			【Java导出PDF】Aspose-words导出PDF指南:Java导出带图片模板PDF(亲测实用)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Aspose-words导出PDF指南:Java导出带图片模板PDF 大家好，好久不见啊，俺最近也是忙来忙去导致写博客越来越少，正好开发过程中遇到一个需求是需要导出PDF，还要按照模板样式导出，还要处理图片问题，这俺就抓抓脑壳了，实不相瞒，俺之前就接触过Excel导出，这一次也算自己学习提升了，俺浏览了很多资料，最终锁定了Aspose.Words，但是Aspose.Words俺发现CSDN和博客园很多博主写的不是很清晰，所以今天俺就来分享一波这个需求点使用Aspose.Words导出PDF遇到的坑及如何导出。
一 Jar包介绍 Aspose.Words是一个商业.NET类库，可以使得应用程序处理大量的文件任务。Aspose.Words支持Doc,Docx,PDF等不同格式，使用该类库可以在不使用Microsoft.Word的情况下生成、修改、转换和打印文档。在项目中使用Aspose.Words可以有以下好处。
今天我分享的是使用Aspose.Words在Java中进行PDF导出及图片的导出，maven依赖如下
&lt;dependency&gt; &lt;groupId&gt;com.luhuiguo&lt;/groupId&gt; &lt;artifactId&gt;aspose-words&lt;/artifactId&gt; &lt;version&gt;23.1&lt;/version&gt; &lt;/dependency&gt; 二 导出步骤 我们先来看一下这个导出的空白模板
观察这个模板我们可以看到这里有realName,addr,图片1,图片2,以及巡防打卡四个地方需要处理，首先，执行看效果。
我们需要做的是 把这个模板Word先保存，然后放到我们的项目里面，比如俺这里把他放到了Resources目录下
闲话少说，上代码！！
@ApiOperation("测试PDF导出") @GetMapping("/api/ffp/dict/PDFTest") public ApiResult&lt;Boolean&gt; PDFTest(HttpServletResponse response,@RequestParam Long id) throws Exception { FfpFileInfo fileInfo = ffpFileInfoService.getById(id); if (ObjectUtil.isEmpty(fileInfo)) { return ApiResult.error(602, "文件不存在"); } String base64 = baseS3Service.downloadWithBase64(fileInfo.getFileKey()); byte[] bytes = Base64.getDecoder().decode(base64); ClassPathResource classPathResource= new ClassPathResource("/templateFile/demo.docx"); InputStream inputStream = classPathResource.getInputStream(); Document document=new Document(inputStream); Map paramsMap = new HashMap(); paramsMap.put("realname","Spring不止春天"); paramsMap.put("addr","四川"); PdfUtils.replaceText(paramsMap,document); PdfUtils.replaceBookMarkImage( bytes,document); String name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98899299c7ba98242e35ee1c3ab8161/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17826284c96cc035e393c3c3a5a4fd68/" rel="bookmark">
			threejs使用Sprite精灵图结合射线实现点击Sprite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面元素 &lt;div ref="container" style="width: 100%;height: 100%;overflow: hidden;"&gt;&lt;/div&gt; 添加精灵图 // 创建纹理加载器 let sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load("图片路径"), sizeAttenuation:false // false的话 不随着相机拉远而变小 })) sprite.position.set(1,1,1)//精灵图添加的位置 sprite.scale.set(0.12, 0.12, 1)//精灵图大小 sprite.name = ”jinglingtu“//精灵图名称 // 将精灵添加到场景中 scene.add(sprite) 实现点击事件 // 点击事件处理函数 const onClick = (event) =&gt; { console.log(event) // 获取点击位置的屏幕坐标 const mouse = new THREE.Vector2(); mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; // 通过射线检测点击位置是否与精灵图相交 const raycaster = new THREE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17826284c96cc035e393c3c3a5a4fd68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d825990e3532be538a566682df6f45/" rel="bookmark">
			谷歌浏览器取消更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 谷歌浏览器使用一段时间后，浏览器总是弹出Chrome版本太旧，需要更新的弹窗，尤其在内网，极不方便。本人不太喜欢更新软件，总是置之不理，直接叉掉。可是浏览器每隔几分钟就弹出来一次，特别麻烦。之前一直是通过外网下载安装包，然后拷到内网安装更新浏览器来解决这个问题。可以仅仅一个多月，又出现了这种问题。现分享一种方式可以避免弹出更新弹窗，以供各位流畅使用，不必再为弹窗烦恼。
具体操作如下： 桌面找到谷歌浏览器图标，右键点击属性，在如下图所示位置上添加命令，然后点击确定，重新打开浏览器，就不会再弹出版本太旧的弹窗了，永久有效。
--disable-background-networking 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9562ed6447719396cd786c6c4ca9669c/" rel="bookmark">
			Unity 读取外配-第三集-网络下载形式读取外部图片（简单但详细版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：我有一个文件夹，里面有好多好多图片，我想软件自己读出来
一、具体逻辑 1.写出你希望读取的文件夹的地址
2.读取这个文件夹里所有的文件名称
3.把这个文件夹里名称中和图片有关的文件名找出来
4.用代码在unity里创建一个图片
5.用加载的图片替换掉创建的这个图片，并调整大小
二、逻辑实现部分 读取部分（1,2,3条）： void Start() { string[] fileName ; //建一个string存所有的名字 //获取应用里"streamingAssetsPath/0"文件夹下得文件名称 fileName = Directory.GetFiles((Application.streamingAssetsPath + "/0")); //如果获取到了，把和图片有关的挑出来 if (fileName.Length != 0) { for (int i = 0; i &lt; fileName.Length; i++) { //获取文件的后缀，把是图片的挑出来并加载出来 string tmp = Path.GetExtension(fileName[i]); if (tmp == ".jpg" || tmp == ".png" || tmp == ".gif" || tmp == ".bmp") { StartCoroutine(ReadPictureName(fileName[i])); //加载的方法，在下文 } } } } 加载图片部分（4条）： 加载图片部分（5条）： //加载图片 public Image image;//在外面创建的图片拖进来 IEnumerator ReadPictureName(string url) { //“在url这个地址下有个图片，请下载下来”这件事写成一个要求 UnityWebRequest request = UnityWebRequestTexture.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9562ed6447719396cd786c6c4ca9669c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91baa129a75b93fafa23e39bae4b56d0/" rel="bookmark">
			linux安装网卡驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7系统安装过程
启动后进入界面，需要修改一些东西：
如果是UEFI的话是e进入编辑install centos，ctrl+x运行；
如果是LEGACY的话是tab进入编辑install centos，enter运行；
修改为vmlinuz initrd=initrd.img linux dd quiet 查看centos文件名，我安装时名称为sdc4，下图是sdc4为U盘iso名称。
之后重启，同样的方法将
vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 quiet 改为：vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdc4 quiet
便顺利进入安装界面。
然后是进行各类选择配置，顺利安装好。
3、网卡驱动安装
安装好了之后使用命令ifconfig查看，在终端可以发现只有一个lo连接而没有eth0，找不到网络接口，网上查找判断是网卡驱动没装好。
查看网卡型号命令：
lspci | grep -i eth
显示是：Intel corporation device 15b8
然后在Intel官网发现并没有15b8的型号，于是 Google下发现对应型号是： http://cateee.net/lkddb/web-lkddb/E1000E.html
vendor: 8086 ("Intel Corporation"), device: 15b8 ("Ethernet Connection (2) I219-V")
然后在Intel官网下载I219驱动文件：https://downloadcenter.intel.com/zh-cn/product/82187/-I219-
在下载文件里选择e1000e-3.3.3.tar.gz，使用命令：tar xvzf e1000e-3.3.3.tar.gz 解压，之后 cd src/ 然后make 提示缺少kernel-headers 和 kernel-devel，于是进入了一个深坑。
文件准备
应该是之前安装CentOS7的时候没有选择完整安装，导致缺少了很多rpm。于是从制造的启动U盘里找到了kernel-headers 和 kernel-devel文件，安装时候提示缺少gcc。。。
GCC安装
gcc从官网下载了gcc-4.9.2下载 ftp://mirrors.kernel.org/gnu/gcc/gcc-4.9.2/gcc-4.9.2.tar.bz2
解压命令：
tar -xvf gcc-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91baa129a75b93fafa23e39bae4b56d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf03345bef03e98b6d60c1a4b1bf59f/" rel="bookmark">
			TypeError: a bytes-like object is required, not ‘str‘，如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python编程中，当我们在处理文件或网络传输等场景时，有时可能会遇到以下错误信息：“TypeError: a bytes-like object is required, not ‘str’”。这个错误通常表示我们传递了一个字符串对象而不是字节对象，导致了类型不匹配。如下所示，我们对字段进行base64编码时，出现了报错：
在本文中，我们将探讨这个错误的原因，并提供解决办法。
问题原因 这个错误通常出现在以下场景：
文件操作时，尝试将字符串写入二进制文件。网络传输中，尝试将字符串发送给需要字节数据的方法或函数。加密和哈希等操作时，尝试对字符串进行操作而不是字节数据。 这些场景要求我们提供字节对象而不是字符串对象，因为字节对象是原始的二进制数据，而字符串对象是文本数据。
解决方法 要解决这个错误，我们需要将字符串转换为字节对象。下面是几种常见的解决办法：
encode()方法 字符串对象提供了一个名为encode()的方法，可以将字符串编码为字节对象。我们可以使用指定的编码格式将字符串转换为字节数据。例如，将字符串转换为UTF-8编码的字节对象：
str = 'fcbayern forever no.1.' byte_data = str.encode(encoding='utf-8') target = base64.b64encode(byte_data) print(target) ############# 输出结果如下： b'ZmNiYXllcm4gZm9yZXZlciBuby4xLg==' 在上述代码中，我们使用encode()方法将字符串对象string转换为UTF-8编码的字节对象byte_data。
使用字节字面量 在Python 3中，我们可以使用字节字面量b''来表示字节对象。我们可以直接在字符串前面加上b前缀来创建字节对象。例如：
str = 'fcbayern forever no.1.' byte_data = b'fcbayern forever no.1.' target = base64.b64encode(byte_data) print(target) 在上述代码中，我们使用字节字面量b"Hello, world!"创建了字节对象byte_data。
bytes()函数 使用bytes()函数将字符串转换为字节对象。我们可以将字符串和指定的编码格式作为参数传递给bytes()函数。例如：
str = 'fcbayern forever no.1.' byte_data = bytes(str, encoding='utf-8') target = base64.b64encode(byte_data) print(target) 在上述代码中，我们使用bytes()函数将字符串对象string转换为UTF-8编码的字节对象byte_data。
注意事项 在进行字符串到字节对象的转换时，需要确保指定的编码格式与数据的实际编码相匹配。如果不确定数据的编码格式，可以使用sys.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf03345bef03e98b6d60c1a4b1bf59f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9d2fa4673d65f7469a6369bc12f31c/" rel="bookmark">
			高云下载器出现No devices found错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高云下载器出现No devices found错误 点击Edit-&gt;Cable Setting-&gt;USB Cable Setting
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8683ec8b7643f23a73b53a76e72612ee/" rel="bookmark">
			图像处理——过程全解析，配图超详细！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“小白学视觉”，选择加"星标"或“置顶”
重磅干货，第一时间送达 摘自先进测控之家《长着眼睛的机械手》
课题摘要——
利用图像处理技术，在50*50CM的区域内识别出5枚硬币（硬币位置任意），并且控制机械手逐一拾取5枚硬币，然后把5枚硬币逐一叠放到指定位置（指定位置随机）。
图像处理过程详解
——LabVIEW Vision Assistant
硬币位置识别算法分析与设计
硬币的识别是本系统软件设计最为关键的一步，只有识别的稳定、精确才能控制机械手拾取硬币。硬币的最主要特征为圆形、银白色、直径约为25mm。设计识别算法时也是主要依据这几个特征进行选择相应的算法模块，才能很好的区分周围环境的杂物。处理的总思想：先采集含硬币的图片,进行一系列的滤波、分割、填补后把除圆形外的杂物排除，再用硬币模版搜索整幅图像来确定是否有和硬币一样大小的圆形。找到圆形后选择输出其中心坐标。下面详细介绍利用Vision Assistant来快速搭建识别硬币的算法，并输出像素坐标。
1.1 导入图片
打开Vision Assistant并单击左上角的图片按钮，导入一幅图片。
在图中我们可以看到五枚硬币，并且还有坐标轴、圆圈等杂物，总之现在的图像是杂乱的，如果用当前的图像直接去搜索硬币无法做到稳定，因为当光照等外部条件改变时背景的白色和硬币的白色在像素值上非常接近很难进行识别。为此在搜索硬币前必须进行一定的阀值滤波。把硬币外形显示出来，也就是靠颜色去匹配较难，但靠外形匹配容易而且稳定。
1.2 转换RGB
图片中的图像是RGB的，要先把图片转成单色的，这样更利于识别和后续算法的处理。在软件界面的左下部分的Processing Functions中单击选择Color。再选择Color Plane Extraction这一函数模块。
处理后我们看到硬币暗淡了许多，这样更有利于下一步的分割。
1.3 阀值滤波
在Processing Functions中选择Groyscale，再选择Threhold。该函数的功能是选择阀值以内的图像并且用红色表示出来。如下图所示。
在look for选择，默认是Bright Object，所以白色的背景变成了红色，也就是白色为选择处理的内容。硬币相对背景而言是较黑的，所以应该在此项选择Dark Object。
可以看到较黑的硬币变成了红色被选中，同时可以调节Threhold Range这一滑调控件来调节阀值，直到满足硬币被选中变红色这一要求为止。然后点击OK完成本步骤。这是点击OK后的效果图，
图中除硬币外还有很多的杂物也被标注红色了，这是不希望看到的。
1.4 移除小杂物
在processing function中选中Binary，再继续选中ADV.Morphology这一函数模块。这一函数包含移除小物体、大物体、补全图像漏缺等功能。进入界面后选中Remove small things ，选中后可以看到图中轴坐标上的阿拉伯数字被移除了。
1.5 移除边缘杂物
再选择一次ADV.Morphology这一函数模块，再点击Remove border object。把图像中的边缘去掉，去掉后的效果如下图所示。
1.6 补漏洞
再选择一次ADV.Morphology这一函数模块，再点击Full holes，从下图中可以看到，五枚硬币全部变为无漏洞的红色。至此五枚硬币的外形已经很完整的提取出来，下一步就是要判断这五个外形是不是要找的硬币。
1.7 二值化图像
在processing function中选择grayscale中的lookup table这一函数模块。该函数的功能为把图像进行二值化处理，最后输出像素为0或1的图像，便于后续处理。在弹出的界面中选择equalize这一选项，可以看到图像立即变成了黑白图像。白色部分即为刚刚被红色标出来的硬币轮廓。
1.8 查找圆形
这是整个图像处理中最为关键的一步，LabVIEW vision提供了很多方法来查找具有一定外形的物体，比如shape detection、pattern matching等函数。而本系统采用的是share matching这一函数，因为顾名思义这个函数的功能是根据给定外形去查找图像中是否有相同外形的物体。它的适应性更强更稳定。在processing functionz中选择share matching这一函数模块。
进入界面后单击create template，弹出选择界面，选择图中任意一个圆形作为识别的模版即可。然后单击finish，即可完成识别模版选择。
模版选择好后，自动识别出五枚硬币，并且用绿色方框标注出来，下方显示的是对应的硬币的中心坐标。例如第一枚硬币的中心坐标在图中蓝色方形取阅，它的中心x坐标为235，中心y轴坐标是94。如下图所示。
到这一步硬币识别已经成功了，但是坐标还没有输出给LabVIEW程序框图，后续的电机控制也就无法进行。为此必须选择坐标输出给后续的VI。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8683ec8b7643f23a73b53a76e72612ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aa8a3f0931f882124970ead4f601f28/" rel="bookmark">
			Android 实现透明度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发时，UI上的一些布局总需要设置他是有一定的透明度的，有些UI不会给AHEX的代码，只有无透明度的HEX颜色代码，我也懒得去算，每次都要去网上查，所有今天自己总结一份，下次懒得再去找了。
1.颜色Code前加十六进制的透明度
100%为完全不透明，00%为完全透明
100% — FF 99% —- FC 98% —- FA 97% —- F7 96% —- F5 95% —- F2 94% —- F0 93% —- ED 92% —- EB 91% —- E8 90% —- E6 89% —- E3 88% —- E0 87% —- DE 86% —- DB 85% —- D9 84% —- D6 83% —- D4 82% —- D1 81% —- CF 80% —- CC 79% —- C9 78% —- C7 77% —- C4 76% —- C2 75% —- BF 74% —- BD 73% —- BA 72% —- B8 71% —- B5 70% —- B3 69% —- B0 68% —- AD 67% —- AB 66% —- A8 65% —- A6 64% —- A3 63% —- A1 62% —- 9E 61% —- 9C 60% —- 99 59% —- 96 58% —- 94 57% —- 91 56% —- 8F 55% —- 8C 54% —- 8A 53% —- 87 52% —- 85 51% —- 82 50% —- 80 49% —- 7D 48% —- 7A 47% —- 78 46% —- 75 45% —- 73 44% —- 70 43% —- 6E 42% —- 6B 41% —- 69 40% —- 66 39% —- 63 38% —- 61 37% —- 5E 36% —- 5C 35% —- 59 34% —- 57 33% —- 54 32% —- 52 31% —- 4F 30% —- 4D 29% —- 4A 28% —- 47 27% —- 45 26% —- 42 25% —- 40 24% —- 3D 23% —- 3B 22% —- 38 21% —- 36 20% —- 33 19% —- 30 18% —- 2E 17% —- 2B 16% —- 29 15% —- 26 14% —- 24 13% —- 21 12% —- 1F 11% —- 1C 10% —- 1A 9% —- 17 8% —- 14 7% —- 12 6% —- 0F 5% —- 0D 4% —- 0A 3% —- 08 2% —- 05 1% —- 03 0% —- 00 他是如何计算的？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aa8a3f0931f882124970ead4f601f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d4538433c6d63f515e025f101e8c9dc/" rel="bookmark">
			VUE从后台拿到数据后，数据出现__ob__: Observer的情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我这个场景是从后台拿到数据，然后使用高德api的折线轨迹，结果轨迹第一条显示为__ob__: Observer，查资料说是异步的原因，但是我使用promise抛出结果，回调使用，还是不行，后面搜了下，使用JSON.parse(JSON.stringify(data))解决了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d30f8966e67e2775d8d5fd047c18dd9/" rel="bookmark">
			我的新书《Flink大数据分析实战》出版啦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本书基于Flink1.13.X最新版本编写，作为Flink的入门书，主要使用函数式编程语言Scala进行讲解，知识面比较广，涵盖了当前整个Flink生态系统主流的大数据开发技术。内容全面，以实操案例为主，理论为辅，一步一步手把手对常用的Flink流处理、批处理、图计算等系统进行了深入讲解。
全书一共7章，第1章讲解了Flink的基础知识，包括Flink应用场景、主要组件、编程模型等，最后通过一个单词计数示例带领读者快速体验了Flink应用程序的编写；第2~3章讲解了Flink的多种运行时架构、任务调度原理、数据分区以及Flink集群的安装部署，同时包括Flink命令行操作、应用程序提交、常用Shell命令等；第4~7章讲解了Flink流式计算DataStream API、关系型计算Table&amp;SQL API以及图计算框架Gelly等的基础知识、架构原理，同时包括常用Shell命令、API操作、内核源码剖析，并通过多个实际案例讲解各个框架的具体应用以及与Hadoop生态系统框架Hive、Kafka的整合操作。
本书可作为Flink新手入门的指导书籍，也可作为大数据开发人员的随身手册以及大数据从业者的参考用书。即使没有任何大数据基础的读者也可以对照书中的步骤成功搭建属于自己的Flink大数据集群，是一本真正的提高读者动手能力、以实操为主的入门书籍。读者学完本书可以独立使用Flink进行大数据项目的开发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c5b56d092a7a2ca1e99b5dcc0073437/" rel="bookmark">
			chatgpt赋能python：用Python简化股票分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用Python简化股票分析 股票交易是许多人的投资方式。但是，对于初学者来说，了解如何进行股票分析可能是一项艰巨的任务。幸运的是，Python编程语言提供了一种简洁的方式，使得这项任务变得更轻松。
什么是股票分析？ 股票分析是指使用各种指标和方法，对股票市场的数据进行审查和研究。股票分析的主要目的是为了帮助投资者做出明智的投资决策。股票分析通常分为两种类型：基本分析和技术分析。
基本分析：主要关注公司的财务数据和业务前景以及行业趋势等基本因素。技术分析：基于市场数据，关注趋势和价格模式，帮助识别买卖机会。 利用Python进行股票分析 Python能够帮助我们简化股票分析。使用Python，可以通过一些简单的命令和函数快速完成股票分析的任务。以下是Python中一些主要的股票分析库：
pandas：pandas是数据分析库，可以轻松地加载、处理、分析和处理数据集。pandas可以帮助我们处理股票交易数据，例如股票价格和成交量，然后将它们转换为易于分析的格式。
numpy：numpy是数值计算库，可用于执行各种数学和统计计算。它可以帮助我们计算各种技术指标，例如收盘价的移动平均线、相对强弱指数等。
matplotlib：matplotlib是一个绘图库，可以用于绘制各种图表，例如折线图、柱状图和饼图等。使用matplotlib，可以可视化数据，以更好地理解数据的趋势和模式。
使用Python进行简单的技术分析 我们将演示如何使用Python进行简单的技术分析。在这个例子中，我们将使用pandas、numpy和matplotlib库。我们将从Yahoo金融获取股票数据。以下是我们的代码：
import pandas as pd import numpy as np import matplotlib.pyplot as plt # 从Yahoo金融获取股票数据 data = pd.read_csv('https://finance.yahoo.com/quote/AAPL/history?p=AAPL') # 将DataFrame的‘Date’列转换为日期格式 data['Date'] = pd.to_datetime(data['Date']) # 将‘Date’列设置为索引 data.set_index('Date', inplace=True) # 计算20日移动平均线和50日移动平均线 data['MA20'] = data['Close'].rolling(window=20).mean() data['MA50'] = data['Close'].rolling(window=50).mean() # 绘制移动平均线 plt.plot(data['Close']) plt.plot(data['MA20']) plt.plot(data['MA50']) plt.show() 我们首先导入了必要的库。然后，我们从Yahoo金融获取了苹果公司（AAPL）的历史股价数据。我们将DataFrame的‘Date’列转换为日期格式，并将‘Date’列设置为索引。接着，我们计算了20日移动平均线和50日移动平均线，并将它们添加到DataFrame中。最后，我们使用matplotlib绘制了图表，显示移动平均线和收盘价。
结论 Python是一种强大的编程语言，可以帮助我们简化股票分析的过程。通过使用Python，我们可以轻而易举地加载、处理和分析股票交易数据，并计算各种技术指标。此外，我们还可以可视化数据，以更好地理解股票市场的趋势和模式。如果你想入门股票分析，Python是值得学习的工具。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
🧡AI职场汇报智能办公文案写作效率提升教程 🧡 专注于AI+职场+办公方向。
下图是课程的整体大纲
下图是AI职场汇报智能办公文案写作效率提升教程中用到的ai工具
🚀 优质教程分享 🚀 🎄可以学习更多的关于人工只能/Python的相关内容哦！直接点击下面颜色字体就可以跳转啦！ 学习路线指引（点击解锁）知识定位人群定位🧡 AI职场汇报智能办公文案写作效率提升教程 🧡进阶级本课程是AI+职场+办公的完美结合，通过ChatGPT文本创作，一键生成办公文案，结合AI智能写作，轻松搞定多场景文案写作。智能美化PPT,用AI为职场汇报加速。AI神器联动，十倍提升视频创作效率💛Python量化交易实战 💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b4773ea618b4512030b0fa4cbd911f/" rel="bookmark">
			构造函数（C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引入构造函数二、构造函数1.构造函数的介绍2.构造函数的特性 总结 一、引入构造函数 观察下面我们声明的这个日期类，我们可以调用Init函数对成员变量进行初始化，但每次初始化的时候我们都需要重复调用，因而为了代码的简洁就引入了构造函数。
class Date { public: void Init(int day, int month, int year) { _day = day; _month = month; _year = year; } private: int _day; int _month; int _year; }; 二、构造函数 1.构造函数的介绍 构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，以保证每个数据成员都有 一个合适的初始值，并且在对象整个生命周期内只调用一次。
构造函数名字中虽然含有构造两个字，但不是开辟空间来创建对象，而是在创建对象的同时对成员变量进行初始化。
2.构造函数的特性 构造函数的语法
1、名称与类名相同
2、无返回值类型 class Date { Date()//可以含有参数 { } }; 对象实例化时编译器自动调用对应的构造函数。构造函数可以重载 #include &lt;iostream&gt; using namespace std; class Date { public: Date() { cout &lt;&lt; "Date()" &lt;&lt; endl; } Date(int day, int month, int year) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b4773ea618b4512030b0fa4cbd911f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcfe4ce16ac1135284a38d6c6ebf27cf/" rel="bookmark">
			单片机USB应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、USB简介二、USB Slave实验2.1 OTG及读卡器实验简介2.2 USB Slave移植2.2.1 文件移植2.2.2 工程添加 2.3 代码修改2.3.1 usb_bsp.c修改2.3.2 usbd_desc.c2.3.3 usbd_usr.c修改2.3.4 usbd_storage_msd.c修改 2.4 配置选项2.5 实验测试函数 三、USB Host实验3.1 U盘实验简介3.2 USB Host移植3.2.1 文件移植3.2.2 工程移植 3.3 代码修改3.4 Host 测试函数 一、USB简介 USB ，是英文 Universal Serial BUS（通用串行总线）的缩写，而其中文简称为“通串线，是一个外部总线标准，用于规范电脑与外部设备的连接和通讯。是应用在 PC 领域的接口技术。USB 接口支持设备的即插即用和热插拔功能。
标准 USB 共四根线组成,除 VCC/GND 外，另外为 D+和 D-，这两根数据线采用的是差分电压的方式进行数据传输的。在 USB 主机上，D-和 D+都是接了 15K 的电阻到地的，所以在没有设备接入的时候，D+、D-均是低电平。而在 USB 设备中，如果是高速设备，则会在 D+上接一个 1.5K 的电阻到 VCC，而如果是低速设备，则会在 D-上接一个 1.5K 的电阻到 VCC。这样当设备接入主机的时候，主机就可以判断是否有设备接入，并能判断设备是高速设备还是低速设备。
STM32F407 系列芯片自带有 USB OTG FS（全速）和 USB OTG HS（高速），其中 HS 需要外扩高速 PHY 芯片实现。STM32F407 的 USB OTG FS 是一款双角色设备 (DRD) 控制器，同时支持从机功能和主机功能，完全符合 USB 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcfe4ce16ac1135284a38d6c6ebf27cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8e620751b49df21da831875cd4df94/" rel="bookmark">
			JDK的安装与环境配置，及JDK不同版本的切换使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先，我们进入下载JDK的官网Java Downloads | Oracle 中国https://www.oracle.com/cn/java/technologies/downloads/
这里有很多不同的JDK版本，想要下载哪个版本都可以，通常使用最多的版本为JDK8版本，我们这里以JDK8版本为例，想要下载其他版本可以点击Java archive,里面有全部的版本。
2.下载JDK
我们在首页往下滑就可以找到JDK8版本
然后向下划
找到自己的系统，我这里是Windows，如果自己电脑是64位的就下第二个，如果是86位的就下第一个。当然，在全部版本里也有32位的。点击之后会出现如下情况
这时不能下载， 点击对勾，再点击下载会跳转到登录界面
我们需要先创建账户，创建账户也可以在首页右上角进行创建，创建账户需要输入正确的邮箱地址，并记住自己的密码，其他信息可以不真实。然后会给你邮箱发个邮件，你需要确认一下，然后就可以下载了。
下载完后，如果是压缩包，只需解压到你想要放的位置即可，如果需要安装，则一直点击下一步即可，可修改存放地址，你可以在任何盘建一个文件夹，把它放进去，这里我建的文件夹叫JDK，放的是D盘。
可重复此步骤下载多个不同版本的JDK，可以把它们放在同一个文件夹内。
3. 配置环境变量
我们可以右击此电脑，点击属性，找到高级系统设置。（或者打开设置——系统——关于——高级系统设置）
点击环境变量
进入之后点击新建
填入如下信息CLASSPATH和%JAVA_HOME%lib;.;
再次点击新建变量名为JAVA_HOME
其中变量值为你JDK存放的地址，可点击浏览目录找到JDK即可自动生成地址，或者找到JDK所在位置，将地址复制黏贴过来。
然后找到path
点击编辑
如果你需要使用并安装多个JDK，要把第一行删掉，如果只用一个JDK则不需要删掉。
然后点击新建，输入一个点，在新建一个输入%JAVA_HOME%\bin。
这样我们的JDK环境变量就配置好了。
如果安装了多个JDK，你要使用哪个，就把JAVA_HOME的变量值改成你所要使用的JDK的地址即可，如果放在一个文件夹内，只改版本号即可。
感谢大家观看，希望能给大家带来帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0ac2921c1c728627a3d7870a3dd72b1/" rel="bookmark">
			JavaScript 实现字符串转JSON对象的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. javascript函数eval()2. 浏览器自带对象JSON，JSON.parse()3. jQuery插件，$.parseJSON()4. ajax请求获取json数据时，$.getJSON()$.getJSON() 是简写的 Ajax 函数，等价于： 在很多时候我们都需要将数据转换为JSON的格式去进行请求，这里就给大家介绍几种转JSON的方法 1. javascript函数eval() 语法：
var obj = eval ("(" + txt + ")"); //必须把文本包围在括号中，这样才能避免语法错误 eval()定义：eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。
由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。
注意：当字符串中包含表达式时，eval() 函数也会编译并执行，转换会存在安全问题。
2. 浏览器自带对象JSON，JSON.parse() 语法：
var obj = JSON.parse(text[, reviver]) //text:必需， 一个有效的 JSON 字符串。解析前要确保你的数据是标准的 JSON 格式，否则会解析出错。 //reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。 JSON.parse()比eval()安全，而且速度更快
支持主流浏览器：Firefox 3.5，IE 8，Chrome，Opera 10，Safari 4。
注意：IE8兼容模式，IE 7，IE 6，会存在兼容性问题。
3. jQuery插件，$.parseJSON() 语法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0ac2921c1c728627a3d7870a3dd72b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d848953127cbd4ff040a7a036f42396/" rel="bookmark">
			Application loader - 上传ipa工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Application loader上传ipa工具
下载后可直接放在application目录中，直接打开即可使用，或者放在Xcode/Contents/Applicattion目录中也可，这样的话就可以通过Xcode之前常用的方式打开进行ipa的上传了
下面是下载地址：
Application loader下载地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a55c6728123bfdf3865f535c91a5f30/" rel="bookmark">
			Torch 模型 onnx 文件的导出和调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Open Neural Network Exchange (ONNX，开放神经网络交换) 格式，是一个用于表示深度学习模型的标准，可使模型在不同框架之间进行转移
Torch 所定义的模型为动态图，其前向传播是由类方法定义和实现的
但是 Python 代码的效率是比较底下的，试想把动态图转化为静态图，模型的推理速度应当有所提升
Torch 框架中，torch.onnx.export 可以将父类为 nn.Module 的模型导出到 onnx 文件中，最重要的有三个参数：
model：父类为 nn.Module 的模型args：传入 model 的 forward 方法的变量列表，类型应为 tuplef：onnx 文件名称的字符串 import torch from torchvision.models import resnet50 file = 'resnet.onnx' # 声明模型 resnet = resnet50(pretrained=False).eval() image = torch.rand([1, 3, 224, 224]) # 导出为 onnx 文件 torch.onnx.export(resnet, (image,), file) onnx 文件可被 Netron 打开，以查看模型结构
基本用法 要在 Python 中运行 onnx 模型，需要下载 onnxruntime
# 选其一即可 pip install onnxruntime # CPU 版本 pip install onnxruntime-gpu # GPU 版本 推理时需要借助其中的 InferenceSession，其中较为重要的实例方法有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a55c6728123bfdf3865f535c91a5f30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51268d4396fdfaa629048c1ecd05e96d/" rel="bookmark">
			浅谈 chatGpt php源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT是一种由OpenAI训练的大型语言模型，它基于Transformer架构，使用海量的文本数据训练，可以生成人类易于理解的文本，并回答用户提出的问题。
与之前的语言模型相比，ChatGPT具有更强的自然语言处理能力，可以更好地理解上下文和语境，可以生成更自然的回复，还可以根据用户的需求提供建议和帮助。
ChatGPT的主要优势在于其接受了更加专业的训练，可以更好地处理特定的任务，如对话生成、文本摘要等。同时，ChatGPT也具有更高的计算能力和数据容量，可以处理更复杂的任务，并且能够更快地生成结果。
总之，ChatGPT是一种强大的语言模型，它可以帮助人们快速获取信息、提高沟通效率，同时也为自然语言处理和人工智能领域的发展提供了新的思路和方向。
本文没有源码 需要请看转载
转载 http://www.yinmeihua.xyz/index.php?m=home&amp;c=View&amp;a=index&amp;aid=93&amp;admin_id=1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce8a8fd5b99ce78b37834497151d5a54/" rel="bookmark">
			U盘安装linux系统遇到问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		root does not exist
u盘安装CentOS7,提示 /dev/root does not exist, could not boot的解决方法
￼
Q576097966
原创
关注
1点赞·10210人阅读
安装centos 7，提示 “/dev/root does not exist, could not boot”，这个问题是安装程序没有找到U盘的原因。
解决方法如下：
1.
首先U盘启动，选择安装centos 7，一直等，最终进入命令行：
dracut:#
dracut:# cd /dev
dracut:/dev# ls
查看你的U盘，一般是第二块硬盘sdb4。
如果还不确定，记下sdb3之后的几块盘，就拔出U盘，
#ls 几次
看看少了哪一个盘，一般就看不到sdb4了，如果看不到sdb4了，那我们的U盘就是sdb4, 否则就是少了的那一块盘。
2.重新插入U盘，这里我们以U盘是sdb4为例：
ctrl+alt+del重启电脑，选择install centos7.
按下Tab键，
将vmlinuz initrd=initrd.imginst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet 改为：vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sdb4 quite
3.按下enter 键进入安装界面，就可以顺利开始安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/499fb7a4b7c9617c8d7d45ba1b0603d8/" rel="bookmark">
			centos安装MySQL8完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 卸载mariadb
2. 下载
3. 安装
4. 若安装失败、卸载、重新安装
5. 启动
6. 修改密码
7. 设置mysql远程链接
1. 卸载mariadb 因centos7默认安装了mariadb, 会造成依赖冲突，按下列方式进行卸载：
rpm -qa | grep mariadb #如果出现 mariadb-libs-5.5.68-1.el7.x86_64 #执行 rpm -e mariadb-libs --nodeps 2. 下载 wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.31-1.el7.x86_64.rpm-bundle.tar #下载完后创建目标文件夹，将其解压 cd /opt mkdir mysql tar -xvf mysql-8.0.31-1.el7.x86_64.rpm-bundle.tar -C /opt/mysql #然后会出现以下几个安装包 mysql-community-client-8.0.31-1.el7.x86_64.rpm mysql-community-client-plugins-8.0.31-1.el7.x86_64.rpm mysql-community-common-8.0.31-1.el7.x86_64.rpm mysql-community-debuginfo-8.0.31-1.el7.x86_64.rpm mysql-community-devel-8.0.31-1.el7.x86_64.rpm mysql-community-embedded-compat-8.0.31-1.el7.x86_64.rpm mysql-community-icu-data-files-8.0.31-1.el7.x86_64.rpm mysql-community-libs-8.0.31-1.el7.x86_64.rpm mysql-community-libs-compat-8.0.31-1.el7.x86_64.rpm mysql-community-server-8.0.31-1.el7.x86_64.rpm mysql-community-server-debug-8.0.31-1.el7.x86_64.rpm mysql-community-test-8.0.31-1.el7.x86_64.rpm 这个数据源不能用了，我将下载后文件放在了我的资源里。如果还是get不到可以私信我，我看见的话发给你。 3. 安装 yum install -y perl.x86_64 rpm -ivh mysql-community-common-8.0.33-1.el7.x86_64.rpm --force --nodeps rpm -ivh mysql-community-libs-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/499fb7a4b7c9617c8d7d45ba1b0603d8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/118/">«</a>
	<span class="pagination__item pagination__item--current">119/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/120/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>