<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58316cd3e63c2ab7c812975788c96682/" rel="bookmark">
			JVM调优命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jps：显示系统内所有的jvm进程
jps -q ：只输出进程ID
jps -m：输出jvm进程启动时传递给main函数的参数
jps -l：输出主类的全名，如果执行的是jar包，则输出jar路径
jps -v：输出jvm进程启动时jvm的参数
jstat：用于监视虚拟机各种运行状态信息，可以显示jvm进程中的类转载、垃圾回收，JIT编译等运行数据
jstat -compiler pid：输出JIT编译过的方法数量耗时等
jstat -class pid：监视类装载、卸载数量、总空间以及耗费的时间
jinfo：实时查看调整虚拟机的各项参数
jinfo -flags pid：打印jvm参数
jinfo -flag name=value pid：设置jvm参数
jmap：用于生成heap dump文件，查询finalize执行队列、Java堆和永久代的详细信息
jmap -dump:live,format=b,file=heap.bin pid：dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名，dump文件可以通过eclipse MemoryAnalyzer进行软件分析
jmap -heap pid：打印堆详细信息
jmap -histo pid：打印堆中对象统计信息，包括类、实例数量和合计容量
jstack：用于生成jvm当前时刻的线程快照，可以定位线程出现长时间停顿的原因
jstack -l pid：除堆栈外，显示关于锁的附加信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a206109d19706bef134979d8a565307a/" rel="bookmark">
			立创eda 新手可能会出现的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闲的无聊 看见好多人都用立创eda说是很好用 就也来用这个画个图来看看
确实挺好上手的 对于新手来说比AD好用很多（这个几乎全是中文的）
发现图画好后有很多小问题，
1.如果端口不与其他端口相连接 一定要在其后边加一个非连接标识，不然会报错的！
2.可能是立创eda库的问题，具体问题我也不太清楚，有的封装的器件不能与其他器件相连接
这个封装是0805的，可以与其他器件相连
这个封装是RES_0805的，但是试了好多次都不能与其他器件相连
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4127a2111114efd420de1e8022b3f7dd/" rel="bookmark">
			APT（Advanced Persistent Threat）--------高级持续性威胁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		APT（Advanced Persistent Threat）--------高级持续性威胁。 利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。APT攻击的原理相对于其他攻击形式更为高级和先进，其高级性主要体现在APT在发动攻击之前需要对攻击对象的业务流程和目标系统进行准确的收集。在此收集的过程中，此攻击会主动挖掘被攻击对象受信系统和应用程序的漏洞，利用这些漏洞组建攻击者所需的网络，并利用0day漏洞进行攻击。
1.概述
APT（Advanced Persistent Threat）--------高级持续性威胁。 利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。APT攻击的原理相对于其他攻击形式更为高级和先进，其高级性主要体现在APT在发动攻击之前需要对攻击对象的业务流程和目标系统进行准确的收集。在此收集的过程中，此攻击会主动挖掘被攻击对象受信系统和应用程序的漏洞，利用这些漏洞组建攻击者所需的网络，并利用0day漏洞进行攻击。
1.1.攻击特点
1）.极强的隐蔽性
对此可这样理解，APT攻击已经与被攻击对象的可信程序漏洞与业务系统漏洞进行了融合，在组织内部，这样的融合很难被发现。例如，2012年最火的APT攻击“火焰(Flame)”就是利用了MD5的碰撞漏洞，伪造了合法的数字证书，冒充正规软件实现了欺骗攻击。
2）.潜伏期长，持续性强
APT攻击是一种很有耐心的攻击形式，攻击和威胁可能在用户环境中存在一年以上，他们不断收集用户信息，直到收集到重要情报。他们往往不是为了在短时间内获利，而是把“被控主机”当成跳板，持续搜索，直到充分掌握目标对象的使用行为。所以这种攻击模式，本质上是一种“恶意的商业间谍威胁”，因此具有很长的潜伏期和持续性。
3）.目标性强
不同于以往的常规病毒，APT制作者掌握高级漏洞发掘和超强的网络攻击技术。发起APT攻击所需的技术壁垒和资源壁垒，要远高于普通攻击行为。其针对的攻击目标也不是普通个人用户，而是拥有高价值敏感数据的高级用户，特别是可能影响到国家和地区政治、外交、金融稳定的高级别敏感数据持有者、 甚至各种工业控制系统。
4）.利用0day攻击
在APT攻击中，经常使用0day对目标发起攻击。很多APT中不惜使用多个高级的0day，所以在APT攻击中利用0day也是一个非常重要的特点。
2.现有的检测技术
目前，很多企业采用多种网络安全防御技术检测攻击，如采用网络防火墙、IDS、应用防火墙、日志审计等措施，然而这些检测已知漏洞攻击的方式难以有效的发现APT攻击 。
2.1.传统网络防火墙
第一代网络防火墙可以控制对网络的访问，管理员可以创建网络访问控制列表（ACLs）允许或阻止来自某个源地址或发往某个目的地址及相关端口的访问流量。传统的防火墙无法发现APT攻击，不论这些攻击来自防火墙内部的还是外部，因为防火墙只是基于网络层和会话层的攻击，而APT攻击一般都基于更高的协议层次， 防火墙无法对这些流量和攻击进行进一步的细分，只能通过ACL列表做一个最简单的控制。
状态检测防火墙是防火墙技术的重大进步，这种防火墙在网络层的ACLs基础上增加了状态检测方式，它监视每一个连接状态，并且将当前数据包和状态信息与前一时刻的数据包和状态信息进行比较，从而得到该数据包的控制信息，来达到保护网络安全的目的。它能根据TCP会话异常及攻击特征阻止网络层的攻击，通过IP分拆和组合也能判断是否有攻击隐藏在多个数据包中。然而，状态防火墙无法侦测很多应用层的攻击，如果一个攻击隐藏在合法的数据包中，它仍然能通过防火墙到达应用服务器 2.2.入侵检测系统（IDS）
入侵检测系统是一个典型的探测设备。它不跨接多个物理网段（通常只有一个监听端口），无须转发任何流量，只需要在网络上被动的、无声息的收集它所关心的报文即可。对收集来的报文，入侵检测系统提取相应的流量统计特征值，并利用内置的入侵知识库，与这些流量特征进行智能分析比较匹配。根据预设的阀值，匹配耦合度较高的报文流量将被认为是进攻，入侵检测系统将根据相应的配置进行报警或进行有限度的反击。
入侵检测系统使用特征识别技术记录并报警潜在的安全威胁。只是基于已知漏洞进行检测，不能对未知的攻击进行报警。目前大多数攻击特征数据库都是网络层的攻击。此外，可以通过加密，TCP碎片攻击以及其他方式绕过入侵检测系统的防御。
2.3.防病毒网关
防病毒网关是一种网络设备，用以保护网络内（一般是局域网）进出数据的安全。主要体现在病毒杀除、关键字过滤（如色情、反动）、垃圾邮件阻止等功能，同时部分设备也具有一定防火墙（比如划分VLAN）的功能。
对于企业网络，一个安全系统的首要任务就是阻止病毒通过电子邮件与附件入侵。当今的威胁已经不单单是一个病毒，经常伴有恶意程序、黑客攻击以及垃圾邮件等多种威胁。网关作为企业网络连接到另一个网络的关口，就象是一扇大门。一旦大门敞开，企业的整个网络信息就会暴露无遗。从安全角度来看，对网关的防护得当，就能起到“一夫当关，万夫莫开”的作用。反之，病毒和恶意代码就会从网关进入企业内部网，为企业带来巨大损失。基于网关的重要性，企业纷纷开始部署防病毒网关，主要的功能就是阻挡病毒进入网络。
这种网关防病毒产品能够检测进出网络内部的数据，对HTTP、FTP、SMTP、IMAP四种协议的数据进行病毒扫描，但所有的检测基本都基于文件类型，并且只能根据特征匹配已知的病毒木马攻击，对于利用0day进行的APT攻击就无能为力。 3.安全需求
目前针对企业、政府、金融、工业等攻击越来越多，也别是针对一些重要部门的攻击，不惜使用大量的0day和花费大量的时间对一个目标进行深度长期的攻击。而这块的检测手段有限，目前的设备无法有效的发现这些安全攻击事件。所以我们需要一种能检测此类攻击的设备。
4.WEB威胁深度检测
Web流量和应用进行深度检测，提供了全面的入侵检测能力。 能解码所有进入的请求，检查这些请求是否合法或合乎规定；仅允许正确的格式或RFC遵从的请求通过。已知的恶意请求将被阻断，非法植入到Header、Form 和URL中的脚本将被阻止。APT攻击(网络战)预警平台还能进行Web地址翻译、请求限制、URL格式定义及Cookie安全。
实现阻止那些的攻击如跨站点脚本攻击、缓冲区溢出攻击、恶意浏览、SQL注入等。
5.APT产品能力和价值
5.1.预警重要信息系统发生的安全事件
5.1.1.及时发现网站存在WEBSHELL后门被利用的行为
APT不仅可以从流量中发现WEBSHELL页面，还可及时预警活动的WEBSHELL利用行为，同时定位到网站服务器、路径和具体页面，帮助进一步快速解决问题。
5.1.2.快速预警高危恶意代码样本传播
一些高危的恶意代码通常杀毒软件是无法处理的，一旦进入内网影响较大，比如一些包含shellcode、勒索病毒的样本，APT产品可以快速的发现并预警这些攻击。
5.1.3.对内部主机被控制回连的行为进行监控
APT内置了一部分黑IP黑域名库，同时通过沙箱提取样本中包含的C&amp;C IP/URL，实现动态的自学习更新黑IP黑域名库，监控内部主机存在被控制回连的行为。
5.2.完善核心系统安全防护能力
5.2.1.发现各种隐蔽威胁
通过深度和全面的行为分析能力，可以发现网络中的隐蔽攻击威胁，避免内网出现恶意代码传播和感染等危害。
5.2.2.分析当前安全防护的弱点
当前安全防护的产品都是基于特征的，极易出现绕过和漏掉的攻击，通过及时发现漏掉的这些威胁，可以分析当前安全防护的弱点。
5.2.3.完善安全防护策略
FW、IPS等安全设备在部署的时候通常都是默认策略，极为容易出现漏掉的攻击，APT可以发现并分析攻击的数据包特征，持续完善当前安全防护策略。
5.3.对攻击进行取证溯源分析
安恒APT产品不仅可以分析出当前存在的威胁，还可以记录威胁的来源、攻击手段、攻击过程、攻击目标、攻击影响等信息，实现对攻击的过程分析和溯源分析，确定内部主机的遭受的威胁程度。
5.3.1.记录详细的攻击行为
通过对攻击威胁的详细分析和行为记录，不仅可以快速发现威胁，并可对威胁的详细行为进行记录，便于进一步取证和追溯。
5.3.2.发现并定位僵尸主机
一旦出现极易被感染为僵尸主机，且难以发现，APT可以发现由内向外的异常流量，定位内网存在的僵尸主机，可以定位到具体的IP、MAC、区域等信息。
5.3.3.对攻击进行跟踪溯源
根据被攻击者遭受的所有威胁进行关联，跟踪所有对被攻击者发起的威胁信息和攻击源信息，发现其中的高危攻击。
5.4.感知安全威胁趋势规律
基于统一智能威胁分析平台，可以实现安全威胁统一分析，感知当前的安全威胁趋势和规律，通过可视化的方式进行展现，便于及时快速的掌握当前的安全动态和威胁指数。
5.4.1.全面的威胁指数分析
通过对主机威胁、文件威胁和邮件威胁多个纬度的威胁分析，形成不同纬度的当前威胁指数，实现全面的威胁动态分析。
5.4.2.安全趋势和规律分析
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2127319a4808609076fa4e39d1ff0256/" rel="bookmark">
			常见软件架构方式的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建软件架构方式他的一个区别,我们以那些架构方式作为一个比较的点呢,一个是MVC架构,还有一个是RPC架构, 还有一个SOA架构,还有一个是微服务架构,我们先来看第一种架构方式,MVC架构,我们首先看一个图 四种架构的表现形式,在这个图当中呢,分别画出了四种架构方式,第一种就是MVC架构, 第二种RPC架构,第三种SOA,第四种微服务,我们先来看MVC架构,其实MVC架构就是我们之前讲的单体架构, 他最大的特点是把所有的功能,都整合到了一个应用当中,并且操作数据库只是单一的数据库,以但数据库为准, 所谓的典型的MVC架构,其实MVC架构就是一个单体架构,那么对于单体架构的项目,他代表性的技术有哪些呢,如果 我的项目是基于单体架构去做的开发,我可以用哪些技术去完成单体架构的项目呢,咱们来看一下,代表技术,比如说 我们Struts2,还有SpringMVC,还有Spring,还有Mybatis,其实这些都可以做为单体架构的一个开发,由于我们之前讲过了 单体架构,我们再来看第二种,RPC架构,我们先来看这个图,除了MVC架构以外,后面的这三种架构方式,其实他们都有一个 共同的特征,在他们的架构方式当中,会有服务的这种概念,RPC中有服务,SOA当中有服务,微服务当中有服务,其实这三种 架构方式,我们可以统称为面向服务架构,但是由于在不同的架构当中,因为服务的治理上会有区别的,所以我们面向服务的 方式当中,分为了三种架构方式,一个是RPC,一个是SOA,一个是微服务,我们再来看第一个RPC,那么什么是RPC架构呢,这里我们 把RPC解释一下,大家并不陌生,RPC是单词的简写,那三个单词呢,Remote Procedure Call,直译过来是什么呢,远程过程调用, 那么这个远程过程调用是什么呢,他其实是通过网络,去获得请求服务的一种技术,他是一种通过网络从远程计算机程序上请求 服务,而不需要了解底层网路技术的一种协议,这是RPC的一种解释,那我们再看这个图,其实RPC和SOA和微服务,最大的一个区别 就是,我们的应用是直接来调用服务的,而服务和服务之间是没有通信通道的,这是他的一个特点,也就是服务和服务之间是 隔离的,服务和服务之间是无法建立通信的,因为他们最终都要通过应用来触发,这是他的一个特点,如果我们的应用真的是通过 RPC架构来架构的话,那么我们常用的技术可以选择什么呢,我们来看一下,一个是Thrift,这个Thrift是什么呢,是一个RPC通信, 然后Thrift有一个比较强大的代码生成引擎,而且这个技术是支持跨平台和语言的调用的,支持C++,Java,Python,Ruby这些主流 语言,Thrift他都是支持的,所以说这个技术还是比较强大的,Facebook把它挂在Apache下,如果我们想要了解一下,查一下 相关的资料,这是Thrift技术,除此之外还有一个Hessian,这个Hessian是什么呢,可能有的同学也了解,Hessian是一个轻量级的 RPC工具,是一款基于HTTP协议的RPC框架,他的使用是非常简单的,他提供了一个RMI的一个功能,采用的是二进制的RPC协议, 而且它是非常轻量级的,速度是非常快的,所以他是PRC架构技术的一个选择,常见的RPC框架是挺多的,这是RPC的一个架构, 然后再来看,除了RPC以外呢,还有微服务,那么SOA服务又是什么演变过来的呢,其实这个图就是我们项目进化的一个方式, 演化方式,MVC最终可以演化成RPC,PRC有可以演化成SOA和微服务,那么其实RPC这种方式呢,他有一些问题,有什么问题呢, RPC的服务非常多,我们这个服务的节点特别多,这个时候你会发现,用RPC方式去架构的时候,服务是非常难管理的,而且服务的 注册与发现,服务的治理已经服务的网关,还有像服务的容错,还有分布式的配置中心,还有服务的跟踪等等,所以都是已将非常 麻烦的事,当服务的质量上升到几百个的时候,那么每个服务容量的评估,还有服务的资源浪费,还有IP的暴露等等,都非常 难管理,所以说这个时候,如果你的服务量过多,其实RPC的架构方式就显得力不从心了,那如果我们的服务真的有这么多的话, 怎么去解决呢,我们可以换其他的架构方式,比如像SOA架构,或者微服务架构都可以,那我们来看SOA架构,那么SOA是什么呢, SOA也是单个单词的简写,Service Oriented Architecture,直译过来就是面向服务的架构,我们来看一下,SOA架构和RPC架构 最大的区别就是,在他的架构方式当中,多了一个层,原来RPC是直接调用服务,现在我们的应用是去调用ESB,ESB才去调用 服务,是这样的一个过程,那么ESB是什么呢,是需要先了解一下,其实ESB也是三个单词的简写,哪三个单词呢,Enterprise Service Bus,直译过来就是企业服务总线,那么其实企业服务总线是什么呢,其实就是一个服务的中介,它主要是提供 服务与服务之间的交互,我们再来看这个图,在RPC这种架构模式下,服务和服务之间是没有消息交互通道的,但是SOA架构 则不然,我们所有的服务都集成到ESB下,集成到消息服务总线下,那么就相当于给每个服务建立了一个消息通道,然后 ESB的服务总线,进行治理,这是SOA比RPC更智能的一个体现,那么ESB包含了哪些功能呢,简单的了解一下,ESB包含的功能 如负载均衡啦,还有流量控制,还有加密处理,还有服务的监控,异常处理,还有监控告急,等等这样的一些功能,所以他的主要 技术特点就是来治理服务,对于服务的处理方式上是比较多的,在这里给大家罗列了几个,什么负载均衡,服务的监控等等, 这些都是企业的服务总线可以做到的,所以相比RPC这种架构方式,对于服务的治理这一块,更加容易一些,这是SOA架构, 那么我们看一下他的代表技术有哪些,比如有一个叫Mule的,那么它是一个什么用的技术呢,它是一个以JAVA为核心的 框架,他提供服务中介,数据转换,消息路由啊,服务创建和托管,当然这个技术有一个缺点,他并不是开源的,那么也就 意味着他是一个付费产品,如果我们的项目采用Mule作为我们的ESB的话,我们需要花钱购买的,我们再来介绍一个技术, WS02,他也是一个企业服务组件,他具备以下的特点,快速,轻巧,关键一点它是完全开源的,也就是他是一个完全免费的 服务组件,然后是各种设施的基础搭建,技术框架和相关工具,还有内置了服务支持,服务器决策管理功能等等,所以WSO2 也是非常强大的,关键一点相比Mule它是免费产品,提供ESB平台的技术,最后一个就是微服务架构,还是看这个图,其实我们 会发现微服务的方式,跟SOA的方式是及其相似的,他中间也有一层,但是在微服务架构方式当中,这一层就不叫服务组件了, 他叫注册中心,其实注册中心就是治理服务的一种方式,那么这个注册中心呢,相比于企业总线,它会更轻量一些, 换句话说你也可以理解为,轻量的一个替代方案,我们还是把笔记先说一下,什么是微服务呢,其实从宏观上来讲, 微服务就是一个轻量级的服务治理方案,如果我们的项目是采用微服务的方式的话,我们可以用哪些技术来做微服务呢, 比如他的代表技术有哪些呢,比如SpringCloud,还有Dubbo,他的注册中心会用什么来实现呢,我们不是=说注册中心是用来 替换服务总线的吗,那么注册中心我们可以用什么呢,像Apache的Zookeeper,还有SpringCloud自带的eureka注册中心, 这些都是可以用来做主从中心的,所以通过对着四种架构个一个讲解,有什么区别相信大家应该已经理解了,应该并不是 一个很复杂一个事,我们主要讲这四种方式的最大区别,以及每个架构之间的一个特点 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f5aef569141c2e07fc81cd834b7dc8/" rel="bookmark">
			纯CSS实现侧边栏/分栏高度自动相等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		核心CSS代码为： margin-bottom:-3000px; padding-bottom:3000px; 注意：3000px是一个可变值，作用是保证两个元素足够长。
然后父元素添加：
overflow: hidden; 即可实现高度自动相等的效果
举例： 假设实现三栏分局，左右元素自适应中间元素高度：
#box { overflow: hidden; } #left { float: left; width: 200px; background-color: blueviolet; /* 下两行代码为让两侧高度与中间部分保持自适应 */ margin-bottom: -3000px; padding-bottom: 3000px; } #mid { height: 600px; margin-left: 210px; margin-right: 310px; background-color: red; } #right { float: right; width: 300px; background-color: yellowgreen; /* 下两行代码为让两侧高度与中间部分保持自适应 */ margin-bottom: -3000px; padding-bottom: 3000px; } 效果如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc06b9288131e2f9bcea16de1b7172e9/" rel="bookmark">
			以直流电机调速为例详解一种简单的PD调节器代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PID调节是自动控制领域的经典算法。主要有三个参数，即P：比例系数。I：积分系数。D：微分系数。
在PID调节过程中我们需要知道两个值：
1、系统当前状态值（即反馈），即电机转速的实际值。
2、期望值。即我们希望电机达到的转速。
在直流电机调速中一般采用PD调节器，即比例控制和微分控制。
可以设计一个函数：
// 功能：PD（比例，微分）调节器 // 参数1：measureValue，系统当前状态实际测量值，即当前的电机转速。 // 参数2：targetValue，希望系统达到的目标值，即希望电机达到的转速。 float PD_Adjust(float measureValue, float targetValue) { static float lastErr = 0; float Kp = 0.0f, Kd = 0.0f; float out, div, err; err = measureValue - targetValue; // 偏差 div = err - lastErr;	// 偏差的微分 out = Kp*err + Kd*div;	// 输出值计算 lastErr = err;	// 保存偏差 return out; } 应用到电机速度调节中即为：
// 此函数每隔20ms被调用一次，进行一次调节，即50Hz的控制频率。 void TimerInt_20ms(void) { static float motorCtrlValue = 0; motorCtrlValue += PD_Adjust(motorSpeed, 100);	// 计算输出值，目标100 motorSet(motorCtrlValue); // 输出到电机 } 在调节中，比例系数P的作用是正反馈，电机实际转速低于目标时，便增大输出值，否则减少输出值。微分系数D的作用是负反馈，当前后两次调节的计算出来的偏差值相差过大，即误差的微分过大时，给出一个反向控制量，防止系统调节过猛，起到减少超调量的效果。实际效果自己测试下便能感受出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc06b9288131e2f9bcea16de1b7172e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/442f2a5b0b98dcc569e576934ffb6207/" rel="bookmark">
			git从入门到放弃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git重要命令 一、本地操作 主要操作: git branch 分支：分支管理，创建分支git checkout 分支：切换分支git checkout – 文件：放弃修改文件，.放弃所有文件 git merge 分支：合并分支，在 Git 中合并两个分支时会产生一个特殊的提交记录，它有两个父节点。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”git rebase 分支：Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。Rebase 的优势就是可以创造更线性的提交历史。 提交树概念：HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。HEAD 总是指向当前分支上最近一次提交记录。可以通过git checkout切换到每个提交记录。分离head：分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。常见是这种形式：HEAD -&gt; master -&gt; C1git checkout 提交(hash值）：分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名，切换到具体的某一个提交记录。^相对引用：使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。使用 ^ 向上移动 1 个提交记录；使用 ~ 向上移动多个提交记录，如 ~3。（可以支持链式操作，^可以在父亲上进行选择）git checkout master^：master的第一个父节点，还可以使用master ^ ^，master~3等等。git branch -f master HEAD~3：使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。git reset HEAD~1:git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。git revert HEAD~1: 创建一个新的提交覆盖掉已经修改的部分。 自由修改提交树git cherry-pick &lt;提交号&gt;…抓取提交：将一些提交复制到当前所在的位置（HEAD）下面的话， Cherry-pick 是最直接的方式了。cheryy-pick比价适合知道hash值，如果不知道的话用交互式rebase：然后对于每个提交进行操作，在vim的文件中操作。 技巧提交一个记录：在测试分支上选择想要的提交进入主分支，cherry-pick修改中间的提交记录：git rebase -i 将提交重新排序，commit --amend 来进行一些小修改，git rebase -i 来将他们调回原来的顺序，最后我们把 master 移到修改的最前端。修改中间的提交记录: git checkout master，git cherry-pick 需要修改的提交，git commit --amend，git cherry-pick其他需要的提交 标签和描述标签git tag v1 c1：可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，比分支更好的可以永远指向这些提交的方法。描述离你最近的锚点（也就是标签）: __g 1，git commit --amend：修改 作用：通过创建一个新的提交替换当前分支的提示重复提交时候可以当做一次提交 2，git rebase：变基 作用一：合并分支：这个合并与git merge不同。merge后git提交的历史会变成多条，rebase会使得提交历史比较干净；作用方向也不同，git merge other 是当前分支主动去合并其他分支，git rebase target是将当前分支改变分支到目标；后续合并操作的方向也不同。作用二：提交清理。当提交很多东西后，不利于code review ，可以用git rebase -i HEAD~4合并4个提交。 3，git checkout：检出 作用一：切换分支，git checkout other分支作用二：分离head：切换提交位置，git checkout 提交id（关联.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/442f2a5b0b98dcc569e576934ffb6207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ed11d054ddfdd7e479e37cebaf8a47e/" rel="bookmark">
			优先队列PriorityQueue C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优先队列PriorityQueue C语言实现 基础知识构建优先队列创建判空判满插入查找最值删除摧毁 基础知识 堆
堆是用数组实现的二叉树，它的逻辑结构是二叉树，存储结构是数组，所以它没有左右孩子指针。
堆(优先队列)的结构体定义为： #define Type int typedef struct HeapStruct{ int capacity; int size; Type *eles; }PriorityQueue; capacity是堆的最大容量，创建时进行初始化；size是已使用的容量；eles是指针，用于对数据进行操作.
优先队列
优先队列是利用堆的性质实现的，分两种情况，大顶堆和小顶堆。以大顶堆为例，其性质是：
节点的左右孩子的值，都小于该节点的值左右孩子也都是大顶堆. 根据优先队列的性质可以看到，大顶堆的根节点即为序列的最大值，相应的小顶堆的根节点就是序列的最小值。那么我们将一组数输入到大顶堆中，然后依次输出根节点，便实现了堆排序，这样的堆就是常用的优先队列（PriorityQueue）。
这个过程中，我们主要做的是，每插入一个元素，都要将堆调整为优先队列，同样，每删除一个根节点，也要将堆重新调整。
构建优先队列 优先队列的操作包括：
创建/初始化判空/判满插入查找最值删除摧毁 创建 创建一个PriorityQueue结构体，并分配相应的内存，为指针eles分配capacity+1的内存。因为用数组来存储二叉树，父节点和子节点存储位置的关系是son = father/2，在插入操作中，从叶节点创建一个空穴，不断和父节点比较并上移，所以从子节点到父节点经常要取半i/2，为了操作方便，我们把数组的0号位置空出来不使用，将根节点放在i=1的位置上，因此在初始化时，分配capacity+1的内存。
PriorityQueue *init(int max_size){ //这里初始化init定义为指针函数，其返回值是指针，可以直接赋值给*pq PriorityQueue *pq = NULL; //pq为结构体指针 //检查输入大小的合法性 if(max_size &lt;= 0){ printf("max_size is illeagel!\n"); return NULL;	} pq = malloc(sizeof(PriorityQueue)); if(pq == NULL){ printf("malloc failed!\n"); return NULL; } //下标为0的位置保留，不使用 pq-&gt;eles = malloc((max_size+1)*sizeof(Type));//为数组eles分配max_size + 1的内存 if(pq-&gt;eles == NULL){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ed11d054ddfdd7e479e37cebaf8a47e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c90b0da4d27d3262aa3aa292cc6026ea/" rel="bookmark">
			缓存穿透、缓存击穿、雪崩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 缓存穿透是指 缓存 和 数据库 中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。
解决方案：
采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力缓存空值，key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击 缓存击穿是指缓存中没有但数据库中有的数据（某个数据，缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
解决方案：
设置热点数据永远不过期。加互斥锁。 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是， 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。
解决方案：
缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。设置热点数据永远不过期。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b4fb43fea76de892fbb47f430a14613/" rel="bookmark">
			mysql报错解决集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql报错解决集合 1.遇到报错ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement 重置密码set password = password(‘123456’);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11faa0c0007e78bcf92235992a156e83/" rel="bookmark">
			OpenCV三角测量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天尝试跟着视觉SLAM十四讲，敲一次三角测量。
但结果与书中例程相去甚远（测出的深度差了几十个数量级）。
查看opencv中的riangulatePoints头文件后发现，传入的projPoints1和projPoints2要为float型的，而我传入的是double型的，因此会出错。
以下为该函数的注释，注意@note项。
/** @brief Reconstructs points by triangulation.
@param projMatr1 3x4 projection matrix of the first camera.
@param projMatr2 3x4 projection matrix of the second camera.
@param projPoints1 2xN array of feature points in the first image. In case of c++ version it can
be also a vector of feature points or two-channel matrix of size 1xN or Nx1.
@param projPoints2 2xN array of corresponding points in the second image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11faa0c0007e78bcf92235992a156e83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d094412460c4be913fdc552777b653d/" rel="bookmark">
			原子类AtomicInteger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; public final int getAndUpdate(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(prev, next)); return prev; } public final boolean compareAndSet(int expect, int update) { return unsafe.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d094412460c4be913fdc552777b653d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4902ffcc03810f0c97a9823e488368e9/" rel="bookmark">
			IO多路复用模型之epoll实现机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：
当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。 与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。
目前支持I/O多路复用的系统调用有 select，pselect，poll，epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，pselect，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。
设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？
在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。
epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先的select/poll调用分成了3个部分：
1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)
2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字
3）调用epoll_wait收集发生的事件的连接
如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。
下面来看看Linux内核具体的epoll机制实现思路。
当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：
1
2
3
4
5
6
7
8
struct eventpoll{
....
/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/
struct rb_root rbr;
/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/
struct list_head rdlist;
....
};
每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。
而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。
在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：
1
2
3
4
5
6
7
struct epitem{
struct rb_node rbn;//红黑树节点
struct list_head rdllink;//双向链表节点
struct epoll_filefd ffd; //事件句柄信息
struct eventpoll *ep; //指向其所属的eventpoll对象
struct epoll_event event; //期待发生的事件类型
}
当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。
从上面的讲解可知：通过红黑树和双链表数据结构，并结合回调机制，造就了epoll的高效。
OK，讲解完了Epoll的机理，我们便能很容易掌握epoll的用法了。一句话描述就是：三步曲。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4902ffcc03810f0c97a9823e488368e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1361948f63da318813a2a1dfccc13476/" rel="bookmark">
			NullPointerException异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.NullPointerException异常出现的原因？
空指针就是空引用，java空指针异常就是引用本身为空，却调用了方法，这个时候就会出现空指针异常。
报空指针异常的原因有以下几种：
1字符串变量未初始化；
2接口类型的对象没有用具体的类初始化，比如：
List it；会报错
List it = new ArrayList()；则不会报错了
3当一个对象的值为空时，你没有判断为空的情况。你可以试着把下面的代码前加一行代码：
if(rb!=null &amp;&amp; rb!="")
改成：
if(rb==null);
if(rb!==null&amp;&amp;rb!="") 或者if("").equals(rb))
2.空指针的解决办法？
重点关注报错发生的所在行，通过空指针异常产生的两条主要原因诊断具体的错误。同时为了避免空指针的发生，最好在做判断处理时将“null”或者空值放于 设定的值之前。
常见空指针异常的简要分析：
（1）空指针错误
Java中的8种基本数据类型，变量的值可以有其默认值，加入没有对其正常赋值，java虚拟机是不能 正确编译通过的，因此使用基本的Java数据类型一般是不会引起空指针异常的。实际开发中，大多数的空指针异常主要与对象的操作相关。
下面列出可能发生空指针异常的几种情况及相应解决方案：
代码段1：
out.println(request.getParameter(“username”));
分析：代码段1的功能十分简单，就是输出用户输入"username"的值。
说明：看上去，上面的语句找不出什么语法错误，而且在大多数情况下也遇不到什么问题。但是，如果某个用户在输入数据时并没有提供表单 域"username" 的值，或通过某种途径绕过表单直接输入时，此request.getParameter(“username”)的值为空（注意不是空字符串，是空对象 null。），out对象的println方法是无法直接对空对象操作的，因此代码段1所在的JSP页面将会抛出 "Java.lang.NullPointerException"异常。而且即使对象可能为空时，也调用Java.lang.Object或 Object对象本身的一些方法如toString()， equal(Object obj)等操作。
代码段2：
String userName = request.getParameter(“username”);
If (userName.equals(“root”))
{…}
分析：代码段2的功能是检测用户提供的用户名，如果是用户名称为"root"的用户时，就执行一些特别的操作。
说明：在代码段2中，如果有用户没有提供表单域"username"的值时，字符串对象userName为null值，不能够将一个null的对象与另一 个对象直接比较，同样，代码段2所在的JSP页面就会抛空指针错误。
一个小技巧：如果要把某个方法的返回值与常量做比较，把常量放在前面，可以避免调用null对象的equals方法。譬如：
If (“root”.equals(userName))
{…}
即使userName对象返回了null对象，这里也不会有空指针异常，可以照常运转。
代码段3：
String userName = session.getAttribute(“session.username”).toString();
分析：代码段3的功能是将session中session.username的值取出，并将该值赋给字符串对象userName。
说明：在一般情况下，如果在用户已经进行某个会话，则不会出现什么问题；但是，如果此时应用服务器重新启动，而用户还没有重新登录，（也可能是用户关闭浏 览器，但是仍打开原来的页面。）那么，此时该session的值就会失效，同时导致session中的session.username的值为空。对一个 为 null的对象的直接执行toString()操作，就会导致系统抛出空指针异常。
代码段4：
public static void main(String args[]){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1361948f63da318813a2a1dfccc13476/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/186fa6836e69855f3204b193577fee77/" rel="bookmark">
			Bushound数据分析及使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发自 http://testssd.com/?/article/33 欢迎大家支持
Bushound是一款使用起来非常方便快捷的总线数据抓取工具，在我们的测试过成当中，经常会使用它来抓取数据及传输状态用于分析。在这里以usb数据传输为例，大概介绍一下Bushound的使用方法，以及一些典型异常情况的分析。
一、BusHound界面介绍
打开BusHound之后，显示的是这样的界面。当前所显示的界面为顶端界面选项当中的Capture窗口，这个窗口用于显示所有抓取到的数据。点击Stop时会停止数据抓取，这时点击Run，会清空当前数据并开始抓取数据。
这些是想要显示的内容，这些内容可以在Settings窗口下面的Columns to Display设置
选项当中有对应显示内容的解释，在这里就不一个个细说了。
在数据抓取时，不管有没有勾选相应内容，Bushound都会抓取所有Columns to Display当中选项的数据，只是不显示出来而已。如果在抓取完之后想要看相关数据的话，只需要将对应的选项勾选上即可。
在Settings当中可以设置需要显示的内容。
这些选项内容如果在抓取数据的时候没有勾选，那么Bushound是不会抓取的。
在Limits栏中可以设置预留给Bushond抓取数据的缓存空间
Capture Capacity表示缓存的总数据量，Max Record Length表示抓取一个数据包时缓存的数据的量(一条命令\一个状态\一次数据传输，都算一个数据包)。这个在需要的时候可以尽可能设置的大一些，这样抓取的数据比较全面，当数据缓存满了之后，若没有勾选下面的自动停止，则会清除掉所有数据，自动重新开始抓取。
在这个栏目里可以选择什么时候需要自动停止bushound的数据抓取。
Save窗口就是常见的数据保存
Device窗口，用于选择需要抓取的设备及协议层。当勾选到对应的设备那一项时，显示的是经过解析的SCSI协议，设备再上一层是原始的SCSI协议数据。
二、基本协议解析介绍
抓取最简单的的命令时，只需要像上图一样勾选相应设备前面的选项即可，这时抓到的数据主要由 CMD OUT IN组成
(这里我将Max Record length设为16)
CMD表示发送的命令，IN 和 OUT表示数据的读取和发送，关于CMD的含义，这里给出一个列表
这分列表从参考文档SCSI_Commands_Reference_Manual截取出来的，详细相关命令信息也可以从里面查找。
当在Device窗口中勾选了设备的上一层选项时，这时抓到的是SCSI的原始数据
可以看到数据明显多了很多，而且眼花缭乱..
我们一点点来解析一下
首先看第一行
这个就是2Ah写命令的原型，Byte[0:3]为小端数据 0x43425355，这个标志在叫做CBW，表示一次命令传输的开始，由Host下发。
Byte[4:7]为CBW Tag，用于给这一个数据包做一个标识。
Byte[8:11]表示命令之后将要传输的数据长度，这里为0x1000即时4096Bytes。
Byte[12]当中的Bit[7]用于表示传输方向，1为读取，0为发送(其他的暂时还没去看)。
Byte[13]表示操作的设备的Lun号，一个设备可以被分为多个分区，即多个Lun，这里用于表示命令是发送给设备的哪一个Lun的。
从Byte[15]开始，就是之前解析过后的CMD数据了，这里大概说一下重要位置的含义，从这里开始数据为大端数据
Byte[0] OpCode Byte[1] SubOpCode
Byte[2:5] Address 以Sector为单位
Byte[7:8] Length 以Sector为单位
需要注意的是，除了OpCode以外，其他位置的含义并不是固定的，只是在进行2Ah和28h数据传输过程中，这是比较典型的含义。
所以现在重新看下这一行命令，其用途就是，一条2A的写命令，地址为0x000057A0，长度为8 Sector
下一条就是这个2Ah写命令的数据传输，下发了4096 Bytes数据
我这里为了看起来方便，将抓取长度设成32bytes
再下一条
这是一个由Device发送给Host的数据，开头标识为0x53425355，叫做CSW，用于标志一条SCSI命令传输结束，Byte[4:7]为对应的CBW的Tag。
到此为止，一条SCSI命令就算分析完了，后面的依此类推即可。
后面抽时间再介绍异常状态分析吧
三、SCSI命令发送
打开Devices窗口，双击要发送命令的设备
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/186fa6836e69855f3204b193577fee77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3ecc38a16dbe140fab5ac51d75d378c/" rel="bookmark">
			kafka原理及面试套路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kafka原理及面试套路 一、 面试：1、列举kafka的使用场景2、Kafka消息是采用Pull模式，还是Push模式？3、 Kafka 与传统消息系统之间有三个关键区别4. Kafka中是怎么体现消息顺序性的？5、Kafka生产者客户端中使用了几个线程来处理？分别是什么？6、Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？7、 “消费组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据”这句话是否正确？如果不正确，那么有没有什么hack的手段？8、有哪些情形会造成重复消费？9、那些情景下会造成消息漏消费？10、KafkaConsumer是非线程安全的，那么怎么样实现多线程消费？11、当你使用kafka-topics.sh创建（删除）了一个topic之后，Kafka背后会执行什么逻辑？12、优先副本是什么？它有什么特殊的作用？13、Kafka 判断一个节点是否还活着有那两个条件？14.producer 是否直接将数据发送到 broker 的 leader(主节点)？15、Kafa consumer 是否可以消费指定分区消息？16、kafka 的 ack 机制17、kafka如何实现高吞吐1、顺序读写2、零拷贝3、文件分段4、批量发送5、数据压缩 二、 kafka原理及底层机制1、消息和批次2、模式（schema）3、主题和分区（topic和partition）4、生产者和消费者生产者：（发布者、写入者）消费者（订阅者、读者）消费者群组 5、broker和集群6、kafka生产环境注意事项垃圾回收器选择：（选择G1）数据中心布局：共享zookeeper 7、创建kafka生产者8、生产者的配置9、自定义序列化器10、从kafka读取数据11、kafka集群成员关系12、控制器13、kafka的复制14、分区的副本类型15、kafka集群的broker处理请求16、消费请求17、零复制技术18、kafka文件格式19、kafka的复制系数20、kafka构建数据管道21、kafka Streams 流处理 一、 面试： 1、列举kafka的使用场景 总结下来就几个字:异步处理、日常系统解耦、削峰、提速、广播
如果再说具体一点例如:消息,网站活动追踪,监测指标,日志聚合,流处理,事件采集,提交日志等
为什么选择Kafka?
吞吐量高，大数据消息系统唯一选择
2、Kafka消息是采用Pull模式，还是Push模式？ Kafka最初考虑的问题是，consumer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。
一些消息系统比如Scribe和Apache Flume采用了push模式，将消息推送到下游的consumer。这样做有好处也有坏处：由broker决定消息推送的速率，对于不同消费速率的consumer就不太好处理了。消息系统都致力于让consumer以最大的速率最快速的消费消息，但不幸的是，push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。最终Kafka还是选取了传统的pull模式。
Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。Pull模式下，consumer就可以根据自己的消费能力去决定这些策略
Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到t达。为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发
3、 Kafka 与传统消息系统之间有三个关键区别 Kafka 持久化日志，这些日志可以被重复读取和无限期保留
Kafka 是一个分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性
Kafka 支持实时的流式处理
4. Kafka中是怎么体现消息顺序性的？ kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。
整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.
但是分区越少，吞吐量越小，你这样一个topic分1个区，是把kafka当消息队列来用。
5、Kafka生产者客户端中使用了几个线程来处理？分别是什么？ 2个，主线程和Sender线程。
主线程负责创建消息，然后通过分区器、序列化器、拦截器作用之后缓存到累加器RecordAccumulator中。
Sender线程负责将RecordAccumulator中消息发送到kafka中.
6、Kafka中的分区器、序列化器、拦截器是否了解？它们之间的处理顺序是什么？ 分区器:根据键值确定消息应该处于哪个分区中，默认情况下使用轮询分区，可以自行实现分区器接口自定义分区逻辑
序列化器:键序列化器和值序列化器，将键和值都转为二进制流 还有反序列化器 将二进制流转为指定类型数据
拦截器:两个方法 doSend()方法会在序列化之前完成 onAcknowledgement()方法在消息确认或失败时调用 可以添加多个拦截器按顺序执行
调用顺序: 拦截器doSend() -&gt; 序列化器 -&gt; 分区器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3ecc38a16dbe140fab5ac51d75d378c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1e8f64879dcda948f96dcd23a44075b/" rel="bookmark">
			线性代数学习笔记——第七十七讲——用配方法化二次型为标准型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.标准二次型（标准型）
2. 用配方法化二次型为标准型示例1 （二次型中含有平方项）
3. 用配方法化二次型为标准型示例2 （二次型中不含平方项）
正惯性指数、负惯性指数、符号差的定义
4. 惯性定理：实二次型都可经可逆线性变换化为规范形，规范形是唯一的
5.二次型规范型的求解示例 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b152dd13e00d27bd7737423798b2dff/" rel="bookmark">
			html基础入门（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019.09.11 入门基础 CSS样式 CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。
语法
CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 selector {declaration1; declaration2; ... declarationN } 下列中，h1 是选择器，color 和 font-size 是属性，red 和 14px 是值。 h1 {color:red; font-size:14px;} 提示
如果值为若干单词，则要给值加引号：如果要定义不止一个声明，则需要用分号将每个声明分开。 例：
p { text-align: center; color: black; font-family: arial; } CSS样式属性 字体属性
font-family： 设置字体，网页中常用的字体有宋体、微软雅黑、黑体等 p{ font-family:"微软雅黑";} 1.一般网页都是14px以上的字体 2.偶数字体字号，ie6等老式浏览器支持奇数会有bug 3.各种字体之间用英文状态下的逗号隔开 4.当字体是英文是，且有空格$#的时候，用双引号括起来 5.尽量使用系统默认字体，保证任何用户的浏览器都能正确显示 font-style：设置字体风格
如设置斜体、倾斜或正常字体，其可用属性值如下： normal：默认值，浏览器会显示标准的字体样式。 italic：浏览器会显示斜体的字体样式。 oblique：浏览器会显示倾斜的字体样式。 font-variant ：设定小型大写字母
p {font-variant:small-caps;} font-weight ：设置字体的粗细,字体加粗除了用 b 和 strong 标签之外，可以使用CSS 来实现
font-weight的属性值有：normal,bold,lighter,100-900（100的整数倍） 700和boldr一样，400相当与normal font-size ：设置字体的大小
相对长度单位说明em相对与页面的尺寸px像素，最常用，推荐你使用绝对长度单位说明in英寸cm厘米mm毫米pt点 选择器 标签选择器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b152dd13e00d27bd7737423798b2dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/570d1d0b9b913f679830cd155863dca5/" rel="bookmark">
			1002 A&#43;B for Polynomials
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1002 A+B for Polynomials 题目
#include &lt;bits/stdc++.h&gt; using namespace std; int main() { int k; double a[1005]; int b; double c; memset(a, 0, sizeof a); cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { cin &gt;&gt; b &gt;&gt; c; a[b] += c; } cin &gt;&gt; k; for (int i = 0; i &lt; k; i++) { cin &gt;&gt; b &gt;&gt; c; a[b] +=c; } k = 0; for (int i = 0; i &lt; 1001; i++) { if (a[i]) { k++; } } cout &lt;&lt; k; for (int i = 1000; i &gt;= 0; i--) { if (a[i]) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/570d1d0b9b913f679830cd155863dca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84a80f53c0c628ca7bba7fa5240a8c53/" rel="bookmark">
			PAT 1001 A&#43;B Format
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1001 A+B Format Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).
Input Specification: Each input file contains one test case. Each case contains a pair of integers a and b where −10​6 ≤ a,b ≤ 10. The numbers are separated by a space.
Output Specification: For each test case, you should output the sum of a and b in one line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84a80f53c0c628ca7bba7fa5240a8c53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a67adab92ec284d7cb281d3de39914ea/" rel="bookmark">
			计算机网络（ISP，因特网组成，分组交换，计算机网络性能，网络体系机构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念 网络（network）：网络是由若干个节点（node)和链路（link)组成。路由器：把网络连接起来。互联网（Internet）：网络的网络(network of network)，世界上最大的网络。连网类型：点对点连接，总线连接，星型连接，环形连接主机（host):连接在互联网上的计算机 ISP 因特网服务提供者ISP（Internet Service Provider)：用户通过这个ISP接上网络ISP从因特网管理机构申请IP地址（把一大批IP地址批发给合格的ISP),用户从ISP中有偿申请一个IP,获取使用权，就可以通过该ISP接入互联网（即上网）。根据提供服务的覆盖面积大小和所拥有的IP地址数目的不同，ISP分为不同层次。 互联网交换点IXP （Internet eXchange Point）：亦称为IX，IXP互联网交换中心（IXP、IX）即负责这些不同的网络之间互相通信的交换点，是互联网的关键基础设施，由一个或者多个网络交换机组成。主要功能： 主要功能就是允许两个网络直接连接并交换分组，而不需要通过第三个网络转发分组。（两个主机可以通过IXP提供的端口，在两个地区ISP之间在数据链路层用高速链路直接连接和对等地交换分组，而不用通过上层的ISP)，快速高效。 因特网组成 边缘部分 边缘部分由所有连接在因特网的主机（host)组成。 用户可以使用主机实现通信和资源共享。称为端系统（endsystem)，利用核心部分提供的服务，使得众多的主机之间可以通信交换和共享信息。
计算机之间通信 运行在两个主机之间的的两个程序（进程）进行通信，进程就是“运行中的程序”。
通信方式：
客户-服务器方式（C/S方式）： 服务器（server) ：服务提供方服务器程序： 一种专门提供某种服务的程序，可同时处理多个远地或本地客户的请求。系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自多个客户通信请求，不需要知道客户端的地址。 需要由强大的硬件和高级的操作系统支持。客户端（client）：服务请求方客户端程序： 被用户调用后运行，通信时主动向远地服务器发起通信(请求服务），需要知道服务器地址。不需要特殊的硬件和复杂的操作系统。 一旦建立连接，通信是双向的，客户端和服务器都可以发送和接收数据。 对等方式（P2P方式，peer-to-peer） 只要都运行了对等连接的软件（P2P软件），它们就可以进行对等的连接通信，两个主机通信时不区分服务请求方和服务提供方，对等连接的每个主机都是客户端和服务器。P2P文件共享：连接双方都可以下载对方存储在硬盘中的共享文档。对等连接工作方式可支持多个对等用户同时工作。 核心部分 核心部分由大量的网络和连接这些网络的路由器组成。为边缘部分提供服务（提供连通性和交换）。在因特网的核心部分的路由一般是由高速链路连接，边缘部分的主机则通过较低速率的链路连接到核心部分。使得边缘部分的任意一台主机都可以与其他主机进行通信。
路由器（router）：实现分组交换(packet switching)的关键部件，任务转发收到的分组到其他网络，进行分组交换的。 交换 （switching) :按照某种方式动态分配传输线路的资源。
电路交换 建立连接 -&gt;通话 -&gt;释放连接（资源），整个过程都始终占用端对端的通信资源。
分组交换 分组交换技术（Packet switching technology）：也称包交换技术。报文（message）：用户传送的整块数据发送报文前，将用户传送的整块数据划分成一定的长度，在每一个数据段前面加上一些必要的控制信息组成的首部（header），构成一个分组）packet），而分组的首部也称为包头。 分组是网络中传输的数据单元。分组的头部包含了目的地址和源地址等控制信息，使得每一个才能才能在因特网中独立地选择传输路径，并交付到分组传输的终点。分组交换的存储转发 交换过程 边缘主机先将整块数据划分为等长的数据段并组装成多个分组，并发送给路由器， 路由器接收到一个分组，将其缓存在路由器的内存（存储器），检查其首部，查找转发表，按照首部的目的地址，找到合适的接口，从合适的链路转发出去，把分组交付给下一个路由器，直到最终的最终的目的主机。
路由器存储的是分组而不是整个报文一个主机的多个进程（并行的程序）可以和不同的主机进行通信。分组交换过程中，不需要在传送之前占用端到端的通信资源，只需要在某一段链路传送时才占用该链路的通信资源。实现转储交换的分组交换，实质上就是采用在数据通信的过程中断续（或动态）分配传输带宽的策略。 计算机网络 一些相互连接（通信）的自治（独立运行）的计算机的集合
按网络作用范围分类
广域网 WAN(Wide Area Network)
因特网的核心部分，通过长距离运送主机所发送的数据。连接广域网的结点一般都是用高速链路。 城域网 MAN (Metropolitan Area Network) 作用范围一般是一个城市，距离5~50 km ,很多城域网用以太网技术。 局域网LAN(Local Area Network) 一般用微型计算机或者工作站通过高速链路连接，但是地理上范围较少（1km左右），一个学校内称为校园网，企业内称为企业网 个人区域网 PAN (Personal Area Network) 个人工作的地方把属于个人使用的电子设备通过无线技术连接起来的网络。（10m左右），也称为无线个人区域网。 按使用者分类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a67adab92ec284d7cb281d3de39914ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dedc3ab021b33a0b9fbb59914c15590/" rel="bookmark">
			soap-ws获取ws中的所有的接口方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		soap-ws获取wsdl中的所有的接口方法
示例wsdl文件如下，生成的过程可以参考https://www.cnblogs.com/chenyun-/p/11502446.html：
1 &lt;definitions xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsp1_2="http://schemas.xmlsoap.org/ws/2004/09/policy" xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://impl.chenyun.com/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://schemas.xmlsoap.org/wsdl/" targetNamespace="http://impl.chenyun.com/" name="WsImplService"&gt; 2 &lt;types&gt; 3 &lt;xsd:schema&gt; 4 &lt;xsd:import namespace="http://impl.chenyun.com/" schemaLocation="http://localhost:8081/Webservice?xsd=1"/&gt; 5 &lt;/xsd:schema&gt; 6 &lt;/types&gt; 7 &lt;message name="sayname2"&gt; 8 &lt;part name="parameters" element="tns:sayname2"/&gt; 9 &lt;/message&gt; 10 &lt;message name="sayname2Response"&gt; 11 &lt;part name="parameters" element="tns:sayname2Response"/&gt; 12 &lt;/message&gt; 13 &lt;message name="sayname"&gt; 14 &lt;part name="parameters" element="tns:sayname"/&gt; 15 &lt;/message&gt; 16 &lt;message name="saynameResponse"&gt; 17 &lt;part name="parameters" element="tns:saynameResponse"/&gt; 18 &lt;/message&gt; 19 &lt;portType name="WsImpl"&gt; 20 &lt;operation name="sayname2"&gt; 21 &lt;input wsam:Action="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0dedc3ab021b33a0b9fbb59914c15590/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33038e5bbae54bb4f1585ecfb26b376d/" rel="bookmark">
			协方差矩阵计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 协方差矩阵 X , Y X,Y X,Y是两个随机变量， X , Y X,Y X,Y的协方差 C o v ( X , Y ) Cov(X,Y) Cov(X,Y)定义为：
c o v ( X , Y ) = E [ ( X − μ x ) ( Y − μ y ) ] cov(X,Y) = E[(X-\mu_x)(Y-\mu_y)] cov(X,Y)=E[(X−μx​)(Y−μy​)]
其中：
E ( X ) = μ x ， E ( Y ) = μ y E(X)=\mu_x，E(Y)=\mu_y E(X)=μx​，E(Y)=μy​
2.协方差矩阵定义 矩阵中的数据按行排列和按列排列求出的协方差矩阵是不同的，这里默认数据是按行排列。即每一行是一个observation（样本），那么每一列就是一个随机变量（特征）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33038e5bbae54bb4f1585ecfb26b376d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bb58e82186640a2745e433316a9accb/" rel="bookmark">
			为Ubuntu安装指定版本的chrome浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在将基于selenium的web 自动化用例容器化时，遇到了chrome stable版本升级到76，但是基础镜像 python-3.7.3不兼容的情况。为了解决这个问题，需要为镜像安装指定版本(73)的google chrome。
修改后的DockerFile相关内容如下，
# chome RUN apt-get install software-properties-common -y RUN add-apt-repository "deb http://archive.ubuntu.com/ubuntu $(lsb_release -sc) main universe restricted multiverse" RUN apt-get update -y RUN apt-get install -y libglib2.0-0=2.50.3-2 \ libnss3=2:3.26.2-1.1+deb9u1 \ libgconf-2-4=3.2.6-4+b1 \ libfontconfig1=2.11.0-6.7+b1 RUN apt-get install python-selenium python3-selenium -y RUN wget http://security.ubuntu.com/ubuntu/pool/universe/c/chromium-browser/chromium-browser_73.0.3683.103-0ubuntu1_amd64.deb # 如果支持76+版本的chrome，可以直接使用以下命令安装stable版本 # RUN wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb RUN dpkg -i google-chrome-stable_current_amd64.deb --fix-missing; apt-get -fy install # chrome_driver, 注意版本对应 RUN cd /bin &amp;&amp; wget https://chromedriver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bb58e82186640a2745e433316a9accb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe8189623d021030e49dd478147d986f/" rel="bookmark">
			微信小程序wx.request封装与刷新token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跪求大佬们能对我这垃圾方法提一些意见或者给优化优化，我想把请求的部分提出来，关键是不知道怎么下手啊。
function ajax(method, url, data) { let that = this; let app = getApp(); let apiUrl = app.globalData.url; let time = wx.getStorageSync("expiredAt"); //过期时间 let newTime = Date.parse(new Date());// 当前时间 let userId = wx.getStorageSync("userId"); let token = wx.getStorageSync("token"); return new Promise((resolove, reject) =&gt; { if (!token) { // token不存在去重新登录 wx.redirectTo({ url: '/pages/login/index', }) } else { if (newTime - time &gt; 0) { // token 过期了 刷新token console.log("token过期") wx.request({ url: apiUrl + '/api/transfer/token/' + userId, header: { Authorization: token }, method: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe8189623d021030e49dd478147d986f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b174027ccf6f3f72ce2d64f3e91e808/" rel="bookmark">
			[回文系列] 回文数、最长回文子串、最长回文子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、验证回文数 LintCode：https://www.lintcode.com/problem/palindrome-number/description
题目描述：判断一个正整数是不是回文数。
回文数的定义是，将这个数反转之后，得到的数仍然是同一个数。
样例
例1：
输入：11
输出：true
例2：
输入：1232
输出：false
解释：
1232!=2321
注意事项
给的数一定保证是32位正整数，但是反转之后的数就未必了。因此，可以将int型数字转化为字符串来处理。
代码：
public class Solution { /** * @param num: a positive number * @return: true if it's a palindrome or false */ public boolean isPalindrome(int num) { // write your code here StringBuilder sb = new StringBuilder(); while(num != 0){ sb.append(""+num % 10); num = num / 10; } int i = 0, j = sb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b174027ccf6f3f72ce2d64f3e91e808/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff29a2fe7b83ef5de7d9e345c336b84/" rel="bookmark">
			C&#43;&#43;中的虚函数(表)实现机制以及用C语言对其进行的模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是转载的，正版是https://blog.twofei.com/496/
欢迎去看正版！
C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现 前言 大家都应该知道C++的精髓是虚函数吧? 虚函数带来的好处就是: 可以定义一个基类的指针, 其指向一个继承类, 当通过基类的指针去调用函数时, 可以在运行时决定该调用基类的函数还是继承类的函数. 虚函数是实现多态(动态绑定)/接口函数的基础. 可以说: 没有虚函数, C++将变得一无是处!
既然是C++的精髓, 那么我们有必要了解一下她的实现方式吗? 有必要! 既然C++是从C语言的基础上发展而来的, 那么我们可以尝试用C语言来模拟实现吗? 有可能! 接下来, 就是我一步一步地来解析C++的虚函数的实现方式, 以及用C语言对其进行的模拟.
C++对象的内存布局 要想知道C++对象的内存布局, 可以有多种方式, 比如:
输出成员变量的偏移, 通过offsetof宏来得到通过调试器查看, 比如常用的VS 只有数据成员的对象 类实现如下:
class Base1 { public: int base1_1; int base1_2; }; 对象大小及偏移:
sizeof(Base1)8offsetof(Base1, base1_1)0offsetof(Base1, base1_2)4可知对象布局:
可以看到, 成员变量是按照定义的顺序来保存的, 最先声明的在最上边, 然后依次保存!
类对象的大小就是所有成员变量大小之和.
没有虚函数的对象 类实现如下:
class Base1 { public: int base1_1; int base1_2; void foo(){} }; 结果如下:
sizeof(Base1)8offsetof(Base1, base1_1)0offsetof(Base1, base1_2)4和前面的结果是一样的? 不需要有什么疑问对吧?
因为如果一个函数不是虚函数,那么他就不可能会发生动态绑定,也就不会对对象的布局造成任何影响.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bff29a2fe7b83ef5de7d9e345c336b84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3f2a25e501f9f53e74d1cefea4d93e2/" rel="bookmark">
			Blender雕刻模块：2.81雕刻再升级！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于Blender 2.81 alpha版
刚下载了2.81Alpha版，简单试用了一下雕刻模块，发现了两个让人兴奋的变化：
笔刷终于可以像Zbrush那样自适应表面方向了 下图是2.80版的：
再看看2.81更新的：
重构网格(Remesh)功能 在N面板工具标签中多了重构网格的命令：
是基于体素的重构，体素越小，重构后的网格密度越大，而且我们可以看到，重构后的网格都是四边面：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0443c4a8c86e331890e82764889968ab/" rel="bookmark">
			11 中心极限定理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		独立同分布的中心极限定理 独立中心极限定理如下两图所示：
棣莫弗-拉普拉斯中心极限定理 此外，据wikipedia上的介绍，包括上面介绍的棣莫弗-拉普拉斯定理在内，历史上前后发展了三个相关的中心极限定理，它们得出的结论及内容分别是：
棣莫弗－拉普拉斯（de Movire - Laplace）定理是中心极限定理的最初版本，讨论了服从二项分布的随机变量序列。 它指出，参数为n, p的二项分布以np为均值、np(1-p)为方差的正态分布为极限。林德伯格－列维（Lindeberg-Levy）定理，是棣莫佛－拉普拉斯定理的扩展，讨论独立同分布随机变量序列的中心极限定理。 它指出，参数为n, p的二项分布以np为均值、np(1-p)为方差的正态分布为极限。林德伯格－费勒定理，是中心极限定理的高级形式，是对林德伯格－列维定理的扩展，讨论独立，但不同分布的情况下的随机变量和。 它表明，满足一定条件时，独立，但不同分布的随机变量序列的标准化和依然以标准正态分布为极限。 历史 1776年，拉普拉斯开始考虑一个天文学中的彗星轨道的倾角的计算问题，最终的问题涉及独立随机变量求和的概率计算，也就是计算如下的概率值，令 Sn=X1+X2+⋯+Xn, 那么
在这个问题的处理上，拉普拉斯充分展示了其深厚的数学分析功底和高超的概率计算技巧，他首次引入了特征函数(也就是对概率密度函数做傅立叶变换)来处理概率分布的神妙方法，而这一方法经过几代概率学家的发展，在现代概率论里面占有极其重要的位置。基于这一分析方法，拉普拉斯通过近似计算，在他的1812年的名著《概率分析理论》中给出了中心极限定理的一般描述：
[定理Laplace，1812]设 ei(i=1,⋯n)为独立同分布的测量误差，具有均值μ和方差σ2。如果λ1,⋯,λn为常数，a&gt;0,则有
这已经是比棣莫弗-拉普拉斯中心极限定理更加深刻的一个结论了，在现在大学本科的教材上，包括包括本文主要参考之一盛骤版的概率论与数理统计上，通常给出的是中心极限定理的一般形式：
[Lindeberg-Levy中心极限定理] 设X1,⋯,Xn独立同分布，且具有有限的均值μ和方差σ2，则在n→∞时,有
多么奇妙的性质，随意的一个概率分布中生成的随机变量，在序列和(或者等价的求算术平均)的操作之下，表现出如此一致的行为，统一的规约到正态分布。
概率学家们进一步的研究结果更加令人惊讶，序列求和最终要导出正态分布的条件并不需要这么苛刻，即便X1,⋯,Xn并不独立，也不具有相同的概率分布形式，很多时候他们求和的最终归宿仍然是正态分布。
在正态分布、中心极限定理的确立之下，20世纪之后，统计学三大分布χ2分布、t分布、F分布也逐步登上历史舞台：
如上所述，中心极限定理的历史可大致概括为：
中心极限定理理的第一版被法国数学家棣莫弗发现，他在1733年发表的卓越论文中使用正态分布去估计大量抛掷硬币出现正面次数的分布；
1812年，法国数学家拉普拉斯在其巨著 Théorie Analytique des Probabilités中扩展了棣莫弗的理论，指出二项分布可用正态分布逼近；
1901年，俄国数学家李雅普诺夫用更普通的随机变量定义中心极限定理并在数学上进行了精确的证明。
如今，中心极限定理被认为是(非正式地)概率论中的首席定理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/197847e4d8115e5d1917bc7a2e403442/" rel="bookmark">
			vue &#43; ElementUI 关闭对话框清空验证，清除form表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		清空form表单这么写
用resetFields()方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833a6c0dc3e31042a49f304b1b721abf/" rel="bookmark">
			pip报错：ImportError: cannot import name &#39;main&#39; from &#39;pip._internal&#39; (unknown location)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天下载python包时出现了一个错误：
C:\Users\admin&gt;pip3 install xlwt Traceback (most recent call last): File "d:\python\lib\runpy.py", line 193, in _run_module_as_main "__main__", mod_spec) File "d:\python\lib\runpy.py", line 85, in _run_code exec(code, run_globals) File "D:\python\Scripts\pip3.exe\__main__.py", line 5, in &lt;module&gt; ImportError: cannot import name 'main' from 'pip._internal' (unknown location) 可以首先执行 python -m ensurepip 然后执行 python -m pip install --upgrade pip 即可更新完毕。
C:\Users\admin&gt;python -m ensurepip Looking in links: C:\Users\Public\Documents\Wondershare\CreatorTemp\tmpexe8fan4 Requirement already satisfied: setuptools in d:\python\lib\site-packages (40.6.2) Collecting pip Installing collected packages: pip Successfully installed pip-18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833a6c0dc3e31042a49f304b1b721abf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9408f4502e91674fee4546c7ab5db3/" rel="bookmark">
			知乎上 40 个有趣回复，很精辟很提神
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源 |网络整理，版权归原作者所有，侵删。
1
交朋友的标准是什么？
Question - 出世的智者，入世的强者，
或者正常而阳光的普通人。
Answer - 2
有哪些可以令人清醒的句子？
Question - 你多学一样本事，
就少说一句求人的话。
Answer - 3
做哪些事情可以提升生活品质？
Question - 定期扔东西。
Answer - 4
结婚以后两个人在一起最重要的是什么？
Question - 就当这婚还没结。
Answer - 5
把学费拿来念书还是环游世界更合适？
为什么？
Question - 在没有充分的知识作为前提的情况下，
即使行了万里路，
也不过是邮差而已。
Answer - 6
你是如何强迫自己不断学习提升的？
Question - 看过更大的世界后，
就再也不甘心留在原地。
不甘心就是动力。
Answer - 7
你对自由的理解是什么？
Question - 说“不”的能力。
Answer - 8
你是如何走出人生的阴霾的？
Question - 多走几步。
Answer - 9
哪些技能，经较短时间的学习，
就可以给人的生活带来巨大帮助？
Question - 夸奖他人。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a9408f4502e91674fee4546c7ab5db3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa050d73cedca6b40ac97aa17f48a115/" rel="bookmark">
			Redis事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis事件 Redis服务器是一个事件驱动程序，服务器要处理以下两类事件：
文件事件 Redis服务器通过套接字与客户端连接，而文件事件就是服务器对套接字的操作的抽象。
时间事件 Redis服务器中一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。
文件事件 Redis基于Reactor模式开发了自己的网络事件处理器:这个处理器称为文件事件处理器:
文件事件处理器使用I/O多路复用程序来同时监听多个套接字,并根据套接字目前执行的任务来为套接字关联不同的事件处理器.当被监听的套接字准备好执行连接应答,读取,写入,关闭等操作时,与操作相对应的文件事件就会产生,这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件. 文件处理器分成四个组成部分,他分别是套接字,I/O多路复用程序,文件事件分派器,以及事件处理器.
I/O多路复用程序的实现 Redis的I/O多路复用程序的所有功能都是通过包装常见的select,epoll,evport和kqueue这些I/O多路复用函数库来实现,每个I/O多路复用函数在Redis源码中都对应一个单独的文件,比如ae_select.c,ae_epoll.c等.
因为Redis为每个I/O多路复用函数都实现了相同的API,所以I/O多路复用程序的底层实现是可以互换的.
时间事件 Redis的时间事件分为以下两类:
定时事件:让一段程序在指定的时间之后执行一次.周期性事件:让一段程序每隔指定时间就执行一次. 参考文献
《redis设计与实现》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f42975916fdae7eb81592d0b7970c71/" rel="bookmark">
			Windows下Nginx的启动、停止命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下Nginx的启动、停止等命令
在Windows下使用Nginx，我们需要掌握一些基本的操作命令，比如：启动、停止Nginx服务，重新载入Nginx等，下面我就进行一些简单的介绍。
1、启动：
C:\server\nginx-1.0.2&gt;start nginx或
C:\server\nginx-1.0.2&gt;nginx.exe
2、停止：
C:\server\nginx-1.0.2&gt;nginx.exe -s stop或
C:\server\nginx-1.0.2&gt;nginx.exe -s quit
注：stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。
3、重新载入Nginx：
C:\server\nginx-1.0.2&gt;nginx.exe -s reload
当配置信息修改，需要重新载入这些配置时使用此命令。
4、重新打开日志文件：
C:\server\nginx-1.0.2&gt;nginx.exe -s reopen
5、查看Nginx版本：
C:\server\nginx-1.0.2&gt;nginx -v
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1843a6852f3d49ad0f1e1804a8952db9/" rel="bookmark">
			JDBC连接SQLServer报“java.lang.ClassNotFoundException：com.microsoft.sqlserver.jdbc.SQLServerDriver”解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：用JDBC连接SQLServer时，报java.lang.ClassNotFoundException：com.microsoft.sqlserver.jdbc.SQLServerDriver。找不到驱动类，可明明下了依赖。
这时需要重新下载 sqljdbc4.jar ，然后把这个jar包放在java安装路径的lib\ext下面。
然后再IDEA中，点击右上角“Project Structure”
在“libraries”下添加刚刚保存的jar包，点击应用，然后再执行程序即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0720b30916c2863849f734a391d0be/" rel="bookmark">
			IDEA 的maven3.6.2bug Unable to import maven project
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		No implementation for org.apache.maven.model.path.PathTranslator was bound.
while locating org.apache.maven.model.path.PathTranslator
for field at org.apache.maven.model.interpolation.AbstractStringBasedModelInterpolator.pathTranslator(Unknown Source)
at org.codehaus.plexus.DefaultPlexusContainer$1.configure(DefaultPlexusContainer.java:350)
No implementation for org.apache.maven.model.path.UrlNormalizer was bound.
while locating org.apache.maven.model.path.UrlNormalizer
for field at org.apache.maven.model.interpolation.AbstractStringBasedModelInterpolator.urlNormalizer(Unknown Source)
at org.codehaus.plexus.DefaultPlexusContainer$1.configure(DefaultPlexusContainer.java:350)
2 errors
java.lang.RuntimeException: com.google.inject.CreationException: Unable to create injector, see the following errors:
No implementation for org.apache.maven.model.path.PathTranslator was bound.
while locating org.apache.maven.model.path.PathTranslator
for field at org.apache.maven.model.interpolation.AbstractStringBasedModelInterpolator.pathTranslator(Unknown Source)
at org.codehaus.plexus.DefaultPlexusContainer$1.configure(DefaultPlexusContainer.java:350)
No implementation for org.apache.maven.model.path.UrlNormalizer was bound.
while locating org.apache.maven.model.path.UrlNormalizer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b0720b30916c2863849f734a391d0be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13cfd5e0eb4d82143a1b12764e8accc/" rel="bookmark">
			我的超长综合面经 ---- 北京大学 黄晔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的超长综合面经 ---- 北京大学 黄晔
【序】 从9月底投简历开始，到12月23日最后一场面试，我走过了4个月的求职路。 从一开始，我在找的就不是一份工作，而是一份经历。所以我不厌其烦地做了60多个网申，参加了70多场笔试和面试。4个月里，我见过了近百个面试官，遇到了上千个面试者。 12月的时候，每个人都在问我，你还面啊。其实我只是想去看看，看看各个行业，看看各个公司，当然更重要的是，看看各个公司里的人。于是我的面经也不会把重点放在面试本身或面试技巧，而是记录一下这些难得的见闻、体会和感触，算是给我这个浩大的工程办个朴素的奠基仪式。 【第0篇】长篇大论前的简短综述 第一，汇报客观结果。网申的60多个公司中，32个通过了简历筛选，7家公司在进入面试流程后因为时间冲突或其它原因主动放弃，最后拿到了7张offer，另有3家公司通过了全部面试，但询问入职意向的时候拒绝了，也就没有见到offer letter的真面目。 最骄傲的point是从大二各种模拟面试、实习面试开始，一直保持群面的不败战绩，这次求职也一路所向披靡，可惜在最后一场打酱油的群面中第一次做了炮灰，默默地抹掉它吧…… 第二，对于求职的总体准备。 我基本上是一个以不变应万变的面试者，同一张简历，同一版本的自我介绍，以及简历背后同样的故事。所以我个人推荐的对于求职的总体准备是：第一，写一张美丽的简历（这是一门复杂的学问，详细说起来又是一篇长文）；第二，把简历中的每一句话都扩展成一个至少可以讲5分钟的引人入胜的故事；第三，准备一个有逻辑的自我介绍，能够恰到好处地“带领面试官读简历”（大部分面试官都是在你自我介绍的时间里第一次看简历）。把这三件事做好，就已经成功了一半，但把这三件事做好并不容易，我琢磨这三颗玉石琢磨了四个月，也没有磨到完美无暇。 与此同时，我有三张面具，对应我的三类目标行业或职位：第一，会计类，包括四大会计师事务所和实业公司里的财务岗位，这时候我是一个来自中国最高学府、学习刻苦、专业知识扎实的会计学生，做过许多相关实习，热爱会计工作，深知会计工作的意义；第二，咨询类，这时候我学习能力和适应能力极强，非常喜欢与人沟通，对任何事情都充满热情和兴趣；第三，快消类，这时候我对快消业有着长期以来的兴趣，喜欢在快速变化和充满挑战的世界里证明自己。物理上我也有三件不同的衬衫，对应咨询业的是一件纯白的衬衫，对应快消的是一件紫色的衬衫，胸前有缎带的花边，而居于中间的会计类，穿一件红白条纹的衬衫。 总体的准备是我的内在，三张面具只是面试时的状态和强调的重点，两者相辅相成。最后我发现，戴着第一张面具的时候最累最虚伪，这是后话了。 三个行业最终都有斩获，我想也就都有一点发言权。这个超长的综合面经将主要按这三类展开，会计类再细分成两篇，希望给对这些行业感兴趣的后来人一些帮助。 【第1篇】四大会计师事务所 本来我很有志向集齐四张offer letter，可惜德勤早早参透了我的阴谋，连简历都没让我过，所以也就只能永远地留下这个“三缺一”的遗憾了。 对于求职来说，四大是一个很好的练兵场，因为它们的招聘流程高度标准化，相对而言也是比较客观的，可以完整地体会网申（包括OQ）、笔试、群面、经理面试、合伙人面试，竞争者的整体水准也不错。不过，无论你抱着什么样的目的面试四大，都一定要事先大体了解一下审计是做什么的，否则面试官可能不会给你难堪，但是你自己会觉得很难堪…… 作为一份工作，四大被应届生讨论得很多，褒贬也尤为参差。建议每一个向往四大、有意向签四大的人，都尽量在入职前做一段时间的实习。像我，虽然一直对四大有接触有了解，在这个月的实习之后才真正对审计这份工作有了体会。它确实是比较特殊的一个角色，能做好的人也许有很多，但做得好同时能让自己感到享受的人，是需要一些过人之处的。 关于这四家之间的比较，我简单说些个人认识。首先，四家之间对于雇员来说并没有绝对的优劣，而寡头竞争是这个市场所必须的，他们不会相互看不起，不会相互贬低，对于求职者的最终选择也很尊重；第二，从我的接触来讲，对普华感情最深也最欣赏，总体而言做事更专业吧，客户质量的优势也很明显，对KP确实有一些不满，主要是它们家的HR对应聘者态度真不怎么样，不过据说对雇员很好，安永虽然现在外传非常动荡，在中国的客户质量也相对较差，但是我见到的staff都非常优秀，整体感觉甚至超过普华，这也许和人少有关系吧，德勤始终没缘分，连office都没去过，就不评价了。 下面说说拿到offer的三家的面试过程。
**安永** 最早拿到的是安永，暑期的SLP（Summer Leardership Program）。我本人非常喜欢这种一天搞定的面试流程，而安永把这一天安排得相当完美：在一天的时间里，密集地分布了公司介绍、经验分享、小游戏、茶歇和午饭，当然还有最重要的三轮面试。每张桌子6位同学，一个manager、一个senior manager、一个partner组成一个面试小组，在三张桌子之间轮换——对于每一个面试者来讲，在一天之内见过了三个级别的面试官，对于面试官来讲，一天之内“审阅”了18位面试者，所以对于双方都是效率极高的方式。三轮面试中的第一轮是团队合作的小游戏，我们当时是用气球做一个能承重一个人的沙发，这是一个ice-breaking的环节，同时是展现思维能力、团队协作能力、组织领导能力、沟通能力、时间管理能力的机会（很难全部展现，选择擅长和适合的角色）；第二轮是共同讨论一个社会话题，然后每个人就这个话题的一部分做英文演说，讨论的过程就像所有群面一样，个人演说就主要是对英文口语的考察了；第三轮是模拟审计，相当有意思的环节，先小组讨论，对数据进行分析，找出有问题的地方，然后分成两小组的人，一个小组把面试官当做客户，询问有问题的数据的背后原因，另一个小组把面试官当做审计组的manager，汇报分析和客户访谈的结果。我难以抑制对这个面试过程的欣赏，它的的确确是一个客观的、全面的、高效率的考察过程，而面试者也在一天时间里对公司和公司的人有了很深的认识和了解。 这一天给我最大的启示是，热爱一份工作的人，真的会从中得到快乐。审计工作枯燥辛苦，四大里才做两三年就面黄肌瘦的人俯拾即是，但我们见到的Senior Manager和Partner，都喜欢炫耀自己的年龄，因为他们看起来比实际年龄小得多。面试我的Partner是大中华区最资深的Par，他说他到现在依然亲自参与部分的审计工作，因为他真的很喜欢“挑别人的错”。 面试结果应该是当天就出来了，综合三个人的打分和意见。我自己当天感觉相当良好，一周之后，在Accenture的office里，一小群竹子旁边，接到了我人生第一个offer通知。我激动地给大家发短信，我不会是找不到工作的人了~ **毕马威** 大三暑假的时候，我申请了KP的Elite Program。这是一个非常适合大二同学的项目，通过笔试面试即可在暑期的末尾参加一个有工资的9天培训，之后可以在寒假参加年审阶段的实习，所以推荐看到这篇文章的大二同学积极关注啦。不过在我大三那年，作为这个项目的第一年，竟然把大三申请实习的同学也混入其中，表示相当不靠谱。 略去抱怨进正题。Elite Program是一个笔试一个群面。KP家的笔试一定要看笔经，因为卷子是多年重复使用的，更重要的是你的竞争者们都知道这个秘密，你不看就是不公平竞争了呵，另外KP的笔试难度适中的同时给予较大的时间压力，推荐大家找来练手。对于笔试的另外一个小建议就是千万不要寻求做完，事实上那份卷子并没有打算让你做完，最终决定你成绩的也是正确率，用我室友的话说，“交卷时你看到有人把答题卡涂满，就知道他（她）不会通过了。”之后的群面是8个人共同讨论决定一个预算方案的选取，对数字计算有一定的考察，不过大部分和正常的群面相似。这次群面KP的HR给我留下了很不好的印象，半个小时的群面，五分钟之后那位HR姐姐就斜躺在椅子上，几乎不听我们的讨论了……也许她是面试得太多，也许她当天身体不舒服，也许她已然心里有数，但那样的姿态还是让我对她的专业精神表示很失望。 最终我通过了Elite Program的筛选，但这对于大三的我显然没有吸引力，所以淡定地放弃了。不过得到了一个小小的好处，就是在全职招聘中免去了简历筛选和笔试环节。全职招聘我经历了颇为神奇的Manager面和Par面，很值得写一写。Manager面的时候，KP的要求是准备一个三分钟的演讲，介绍某一家公司的核心价值观以及它的产品是怎样体现核心价值观的，一个非常致命的限制是不允许准备任何视觉辅助（如PPT，handout之类），也即只能靠嘴说，另一个小的要求是中英文都需要准备，面试时由面试官随机要求。考虑这些因素，我想到我必须讲一个很容易理解的公司，不仅核心价值观很容易理解，产品也应当尽量生活化，以免用英文讲述时辞不达意。于是我最爱的迪士尼成为了我的不二选择，一来它的核心价值——“创造快乐”是不言而喻的，二来它的产品家喻户晓，而三条产品线（动画电影，游乐园，周边产品）相互平行各有千秋，说起来有滋有味又内容充实。这次面试的神奇之处在于，当我说到“Have you ever bought any consumer product from Disney? Maybe a watch, a cup or a handbag..."的时候，可爱的manager拉开袖子，正装之下的手腕上戴着一只可爱的Mickey手表~当时我简直惊讶地难以言表！后来的行为面试也相当顺利，尤其是我稍作准备的Why KP深得她心（有需要这个问题答案的同学可以悄悄话留言），于是顺利晋级Par面。 而我经历的KP Par面堪称这4个月来单面中的极品面。众所周知，KP有很多本地Par，所以我所听说的大部分同学都是大陆Par，至少是香港Par面的，但是我非常“受重视”地被分到了一个德国Par，通知我参加面试时，HR特别交代我要准备好英文。那天这位Par一定是无事可做，上来就让我谈这些年的生活，当我提到旅游的部分时，他兴奋地打开电脑，给我看他之前一周在迪拜旅游的照片，然后我们就聊起了迪拜，又从迪拜聊到了拉斯维加斯……大概就这样漫无边际地进行了四十分钟的闲聊，我已经相当疲惫，他的一句提问让我顿时清醒，“Do you have any question for me?” 熟悉面试的同学都知道，这意味着面试进入尾声，我想太好了终于快完了，随口问了一个问题，结果他完全忽略我的问题，说，我还是给你说说我们KP的组织架构吧，于是从审计组的matrix结构，说到每个组大致的业务，说到每年公司会有什么样的party什么样的活动……就这样，又20分钟过去了……之后他再一次很耐心地问我，“Do you have any other question?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13cfd5e0eb4d82143a1b12764e8accc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a71125cdf875c53729a407e8e6699f/" rel="bookmark">
			FFT傅里叶变换对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采用不同点数的FFT，效果完全不同，
代码如下，FFT的实现见另一篇文章
FFT需要输入时间序列和输出频域抽样点数相同。64点FFT指在0~采样率这段频谱采样64次。可以看到64根谱线。频谱精度=带宽/采样率 ，在频率轴上能得到的最小频率间隔=fs/N。
%% 验证设计的FFT,理解分析 clear all Fs = 1000; T = 1/Fs; L = 1000; t = (0:L-1)*T; x = sin(2*pi*50*t) + sin(2*pi*180*t); le = ceil(log2(length(x))); N = 2^le; subplot(1,2,1) plot(Fs*t(1:100),x(1:100)) %length(x) 1000 %N点代表FFT的点数 xfft = FFT(x,N); f = Fs/2*(0:length(xfft)/2)/(length(xfft)/2); subplot(1,2,2) plot(f,abs(xfft(1:length(xfft)/2+1))); %length(xfft) N 效果图 64点
128点
N=2^ceil(log2(length(x)))点
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce2946fd150499e086edaab21916878/" rel="bookmark">
			【vba】vba语言基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据类型
变量和作用域 （1）VBA允许使用未定义的变量，默认是变体变量
（2）在模块通用说明部分，加入Option Explicit语句可以强迫用户进行变量定义
（3）变量定义语句及变量作用域
一般变量作用域的原则是，那部分定义就在那部分起作用，模块中定义则在该模块那作用。
数组
数组必须用Global或Dim语句来定义：除了以上固定数组外，VBA 还有一种功能强大的动态数组，定义时无大小维数声明；在程序中再利用Redim语句来重新改变数组大小，原来数组内容可以通过加preserve关键字来保留。
如下例：
Dim array1() as double : Redim array1(5) : array1(3)=250 : Redim preserve array1(5,10) 对对象的赋值采用：set myobject=object 或 myobject:=object
以单引号或者Rem开头的行是注释。
书写规范
（1）VBA不区分标识符的字母大小写，一律认为是小写字母；（2）一行可以书写多条语句，各语句之间以冒号 : 分开；（3）一条语句可以多行书写，以空格加下划线 _ 来标识下行为续行 条件判断语句
If condition Then [statements][Else elsestatements] If condition Then [statements] [ElseIf condition-n Then [elseifstatements] ... [Else [elsestatements]] End If Select Case Pid Case “A101” Price=200 Case “A102” Price=300 …… Case Else Price=900 End Case Choose 函数?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ce2946fd150499e086edaab21916878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1e45e28f7962abed06b19520890f19/" rel="bookmark">
			【vba】vab自动化及宏命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以通过录制宏来学习代码如何操作表格宏的多种运行方式 F5运行宏设置快捷键设置菜单项 调用过程时，需要在过程名前面加上call添加引用：—工具—引用—调用特定工程里面的过程 Personal.Switches.FormulasOnOff 引用不再工程浏览器里面的过程方法。忽略任何改动，关闭工作表
Workbooks("Chap01.XLS").Close SaveChanges:=False清除单元格内容Range("A4").ClearContentsexcel对象继承关系
精确删除
Application.Workbooks("Chap02.xls").Worksheets("Sheet1") .Range("A4").ClearContents访问单元格的值
Range("A4").Value当前工作表里的图形
ActiveSheet.Shapes(2).Line.Weight偏移
ActiveCell.Offset(3, 2) ActiveCell.Offset(rowOffset:=3, columnOffset:=2) ActiveCell.Offset(columnOffset:=2, rowOffset:=3)改变A4内容
Range("A4").Value = 25设置当前单元格的字体
ActiveCell.Font.Name = "Times New Roman"设置当前单元格字体为粗体
ActiveCell.Font.Bold = True方法里面使用自变量 Application.GoTo _ Reference:=Worksheets("Sheet1").Range("P100"), _ Scroll:=True 下划线打断同一行的vba语句，下划线后面需要一个空格。不能再引号之内的文本之间添加连续符。vba错误 设置自动语法检测 快速注释对象浏览器使用对象编号访问对象
With ActiveSheet.Shapes(1)
这里的对象编号是不分对象类型的。MkDir “C:\Study” 新建文件夹RmDir "C:\Study"删除文件夹立即窗口类似于python的ide,ctrl+G快速打开 Worksheets("Sheet1").Activate Range("A1:A4").Select Range("A1:A4").Value = 55 Selection.ClearContents ActiveCell.Select 向立即窗口提问 Print ActiveWorkbook.Name ?Selection.Address ?12/3 ?3+2:?12*8 range和cell
Range(Cells(6, 1), Cells(10, 1)).Select
offset
Selection.Offset(2, 2).Resize(2, 4).SelectCTRL+方向键可以快速移动到下一个有数据的位置。
Selection.Rows.Count选区的行数
返回工作表中的信息，value返回计算后的值，formular返回使用的公式。
ClearContents－仅清除单元格或单元格区域内的数据工作簿和工作表操作办法
select 和active的区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db1e45e28f7962abed06b19520890f19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d969ac2231396c9cc506b0d6d0c46971/" rel="bookmark">
			【vba】循环语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vba里面的循环结构：Do…While, Do…Until, For…Next, For…Each, and While…Wenddo while Do While 条件 语句1 语句2 语句N Loop 示例 Sub ApplyBold() Do While ActiveCell.Value &lt;&gt;"" ActiveCell.Font.Bold = True ActiveCell.Offset(1, 0).Select Loop End Sub 状态栏显示时间 Sub TenSeconds() Dim stopme stopme = Now + TimeValue("00:00:10") Do While Now &lt; stopme Application.DisplayStatusBar = True Application.StatusBar = Now Loop Application.StatusBar = False End Sub do loop while,do单独放在一行，后面不要有内容。 Do 语句1 语句2 语句N Loop While 条件 Exit Do等同于breakdo until …loop当条件为假的时候不断进行循环 Do Until 条件 语句1 语句2 语句N Loop 另一种方式 Do 语句1 语句2 语句N Loop Until 条件 计算器变量 Sub DeleteBlankSheets() Dim myRange As Range Dim shcount As Integer shcount = Worksheets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d969ac2231396c9cc506b0d6d0c46971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254256477d9e25d4e918de4ec2ba9278/" rel="bookmark">
			lesson 2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#创建三角形
#include &lt;iostream&gt; //GLEW #define GLEW_STATIC #include &lt;GL/glew.h&gt; //GLFW #include &lt;GLFW/glfw3.h&gt; using namespace std; //创建一个窗口，定义窗口的宽高常亮 const GLint WIDTH = 800, HEIGHT = 600; //着色器语言，一长串字符串 //顶点着色器，小程序运行在GPU里 //着色器语言用的是330版本 const GLchar *vertexShaderSource = "#version 330 core\n" "layout(location=0) in vec3 position;\n"//location is 位置，in是输入,输入3维向量vec3，起名叫position "void main()\n" "{\n" "gl_Position=vec4(position.x,position.y,position.z,1.0f);\n"//glposition是着色器内部保留的变量不需声明，vec4是四维向量，齐次坐标系（x,y,z,1)，最后的1必须是1 //最后不是1,需做额外的处理 "}"; //片源着色器 //与顶点着色器版本一直 const GLchar *fragmentShaderSource = "#version 330 core\n" "out vec4 color;\n"//输出Out一个4维颜色变量 "void main()\n" "{\n" "color=vec4(1.0f,0.5f,0.2f,1.0f);\n" "}"; int main() { //初始化GLFW glfwInit(); //设置窗口 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);//设置OpenGL主版本3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/254256477d9e25d4e918de4ec2ba9278/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686cd29d92f6295625395526f1e356e1/" rel="bookmark">
			数据库-关系代数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关系运算及运算符 一、基本代数运算 1并 相同的合并成一列，不同的并起来成为RS
操作示意图：
2差 以R为基准，选择S没有的元组。S中R中没有的不算。
操作示意图：
3笛卡尔 关系R为n列，k1元组、关系S为m列，k2元组。R中每个k1与S每个k2组成新的关系。
4投影 5选择 二、扩展代数运算 1交 选择R和S相同的值。
操作示意图：
2连接 Θ相当与运算符，可以认为笛卡儿积是无条件连接，其他的是有条件连接。等值连接的条件就相当于θ=“=” Θ连接逻辑上是table之间先做笛卡儿积，再做对应选择操作
2.1等值连接 2.2自然连接 特殊的等值连接，要求两个关系中进行比较的分量必须相同属性组，将重复属性（字段）去掉
3除 同时从关系的水平方向和垂直方向同时运算
操作示意图：
4外连接 如果把舍弃的元组保存在结果关系中，而其他属性填空值（null）
4.1左外连接 把左边关系R中要舍弃的元组保留。先自然连接，成为ABCE。以左边的为基准，所以B列的b5没了。
4.2右外连接 把右边关系S中要舍弃的元组保留。先自然连接，以右边的S为基准，保留B列共同的值，R中的b4没有所以删除了。
4.3全外连接 不满足R.B=S.B 的元组保留。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b73c188d796a586f4296d221ecce64/" rel="bookmark">
			日历计算器C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求: 设计一个日期类，包含以下功能：
只能通过传入年月日初始化。可以加上或减去一个数字n，返回一个该日期后推n天之后的日期。重载加减大于等于等,使之可以进行对象间的比较 知识点: 类的应用运算符重载&lt;&lt;,+,-,&gt;,&lt;,!=,== #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; using namespace std; //设计一个日期类，包含以下功能： //1、只能通过传入年月日初始化。 //2、可以加上一个数字n，返回一个该日期后推n天之后的日期。 class Date { int m_year; int m_month; int m_day; public: Date(int year, int month, int day) : m_year(year), m_month(month), m_day(day) { } void settime(int year, int month, int day) { m_year = year; m_month = month; m_day = day; } void showtime() { cout &lt;&lt; m_year &lt;&lt; "-" &lt;&lt; m_month &lt;&lt; "-" &lt;&lt; m_day &lt;&lt; endl; } Date operator +(int delay) const; Date operator -(int delay) const; bool operator &lt;(const Date &amp; d) const; bool operator &gt;(const Date &amp; d) const; bool operator &lt;=(const Date &amp; d) const; bool operator &gt;=(const Date &amp; d) const; bool operator ==(const Date &amp; d) const; bool operator !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b73c188d796a586f4296d221ecce64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44f2a7b89e19635fa989db64571ac34f/" rel="bookmark">
			UE4中光照的常见问题和解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div class="mw-indicators mw-body-content"&gt; 中文 光照的常见问题和解决 From Epic Wiki &lt;div id="jump-to-nav" class="mw-jump"&gt; Jump to:	&lt;a href="#mw-head"&gt;navigation&lt;/a&gt;, &lt;a href="#p-search"&gt;search&lt;/a&gt; &lt;/div&gt; &lt;div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"&gt;&lt;div class="mw-parser-output"&gt;&lt;div id="toc" class="toc"&gt;&lt;div class="toctitle"&gt;&lt;h2&gt;Contents&lt;/h2&gt;&lt;span class="toctoggle"&gt;&amp;nbsp;[&lt;a role="button" tabindex="0" class="togglelink"&gt;hide&lt;/a&gt;]&amp;nbsp;&lt;/span&gt;&lt;/div&gt; 1 关于本指南2 一般照明 2.1 为什么我的阴影是黑色的？2.2 将 BSP 转换为静态网格时光照贴图设置无效2.3 如果我完全不想要光照贴图或游戏不需要光照贴图呢？2.4 用于单面网格的双侧照明，或者为何我的照明是穿过屋顶的？2.5 为何看起来与原来完全不同，即引擎比例调整2.6 为何我的照明上有一个红色的“X”？2.7 不合理的光照贴图 UV 布局2.8 后期处理全局光照设置的作用2.9 关节囊阴影 3 动态（可移动）照明 3.1 阴影渗透或错误的阴影质量 3.1.1 只有定向光：层叠阴影贴图设置：3.1.2 远处阴影3.1.3 调整层叠以获得更好的质量：3.1.4 所有动态照明（“照明”选项卡设置）： 3.2 为什么我的可移动照明在很远的距离透过网格照射出来？ 4 静态照明 4.1 光照贴图分辨率/阴影质量4.2 间接照明的阴影接缝/明暗差异4.3 构建照明时出现的“重叠 UV 错误”是什么意思？4.4 如何在编辑器中生成光照贴图 UV？4.5 如何使用静态照明控制全局光照？即反射的优点4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44f2a7b89e19635fa989db64571ac34f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74068235d9cd6b99160b21601a44565b/" rel="bookmark">
			色彩校正中的Gamma（人眼亮度感应的非线性）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2018年7月4日更新重要视频：《美术中灰色的物理光强——演示人眼亮度感知的非线性》
演示人眼亮度感知的非线性 各位网友好，您现在阅读的是2017年12月19日修改后的版本。如果您看过我之前的答案版本，我必须要指出新老答案版本的核心区别：我之前版本的答案认为 sRGB 标准中的 Gamma 校正的幂函数曲线来自于心理学上的韦伯-费希纳定律（Weber-Fechner Law）或斯蒂文思幂定律（stevens'power law）（这个观点是没啥问题的）。同时认为这条幂函数曲线和 CRT 显示器的物理属性毫无关系（这个“毫无关系”大大的有问题，说的太绝对了）。
我之前认为，既然眼睛的特性从心理学上讲是这条曲线，那我们通过实验是可以得到 Gamma=2.2 的 sRGB 标准的，和显示器的物理属性没有任何关系，你用蜡笔的灰度做实验也能得到这条曲线，而蜡笔反射的光，和显示器发出的光，必然没有本质区别，所以即使我们抛开电子产品，也能试验出这么一条 Gamma=2.2 曲线。Gamma 曲线就是把物理光强和美术灰度做了一个幂函数映射。如果媒介灰阶有限呢，比如8位每通道的图片，就必须要做这个映射，否则浪费存储空间。如果灰阶充裕，就不需要做这个映射，直接记录物理光强就可以，比如32位每通道的图片。
其实我之前的结论没有太大的问题，很简洁，也比较触及本质，很适合用来理解 Gamma，但是直到今年7月份我看到了 黄一凯 老师写的这个答案： 黄一凯：为什么线性渐变的填充，直方图的两头比中间高？，我才猛然意识到，眼睛的感知实在是太复杂了，即使做实验，估计也画不出来这么简洁的幂函数曲线，黄老师的答案中提到了，在 Photoshop 中，使用渐变工具，拉一条从黑到白的渐变，默认其实并不是标准的 0、1、2、3、4、5……254、255 这样的线性数列，而是在高光和暗部有进一步的调节，而如果严格的把灰阶线性排列开来，眼睛看上去未必是舒服的均匀从黑到白渐变。 图：黄一凯 我之前所有的探讨都是考察中灰点的映射关系，完全没想到 PS 在高光区和暗部的这些小调节，所以得知这个事实，是很颠覆我的认知的。既然人眼的感知曲线在电脑屏幕上都这么不简洁，那这个简洁的幂函数曲线怎么来的？我们就无法忽视显示器发展史了，看来这个幂函数的基因还是来自于 CRT 显示器，具体的数值 Gamma=2.2 是实验定下来的。眼睛的感受曲线，和 CRT 显示器的物理响应曲线能够基本吻合，这就是我们一直在说的那个美妙的巧合。
事实上，在提出 sRGB 标准的时候，相当大的程度上参考了当时市场上主流的摄影机、显示器、扫描仪已有的标准，同时也参考了韦伯定律，但有意思的是，这条 Gamma 校正的幂函数曲线似乎成为了默认的事情，直接就拿过来用，开始讨论 Gamma 应该是多少了，没有解释为什么是幂函数。参见1996年发表的 sRGB 色彩空间提议书：A Standard Default Color Space for the Internet - sRGB。所以我现在的观点是这样：Gamma=2.2 你可以说它由当时主流硬件设备的物理属性而来，因为提出这个标准，就是为了让大家在制造硬件和管理色彩方面有一个统一的方便的标准，是非常务实的，但是同时你不要忽视人的视觉感知习惯才是幕后大 boss，是发生这一切的本质原因。 知乎是个较真儿的地方，对就是对，错就是错，之前我的理解有问题，我要承认错误。我不敢说我今天的理解是正确的，但是既然想到了这些，我一定要分享出来。
以下是老答案：
我打算抛开计算机图像、显示器发展史等因素，从逻辑上推出Gamma产生的背后原因。
先上结论：
“Gamma”的产生，原因有二：
人眼对自然亮度感知是非线性的。我们用来记录/展示画面的媒介上，动态范围和灰阶预算是有限的。（无论纸张还是屏幕） 为了在灰阶预算有限的前提下，协调自然亮度和主观灰阶感受这二者的映射关系，Gamma就产生了。
第一节：韦伯定律
(注：存疑，解释请看第五节第一段，但不影响本文阅读，您可以按顺序先看下去)
韦伯定律，即感觉的差别阈限随原来刺激量的变化而变化，而且表现为一定的规律性，用公式来表示，就是△Φ/Φ=C，其中Φ为原刺激量，△Φ为此时的差别阈限，C为常数，又称为韦伯率。 解释成人人都懂的大白话就是：人对自然界刺激的感知，是非线性的，外界以一定的比例加强刺激，对人来说，这个刺激是均匀增长的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74068235d9cd6b99160b21601a44565b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95915ce7672b83b72290c81302a008fb/" rel="bookmark">
			UE4蓝图基础分类（3）分支和循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/niu2212035673/article/details/80148329 简述 在所有的开发语言中分支与循环都是必不可少的，它能有效的控制程序执行的流程，在蓝图中是由一些分支与循环节点来实现的。 点击右键 -&gt; Utilities -&gt; Flow Control 弹出一些标准的流程控制节点，如图 (一)、 Branch Branch是一个判断节点，当输入参数Condition为true时，程序走True分支，反之走false分支。 例如，当勾选Condition时，程序会走True分支并打印”True分支” 输出结果 (二)、Delay 延时节点，当程序执行到该节点时，会阻塞一段时间，然后运行，有点像sleep函数。 例如，设置延时三秒再打印数据，在延时期间不接受输入 输出结果，触发事件三秒后才打印 (三)、Do N 这个节点会控制执行的次数，如果超出设定的次数，节点将不会接收任何输入，除非对节点进行重置(Reset) 例如，设置执行次数N为3，那么节点最多执行三次 按“1”键触发，会输出当前直线的次数，超过三次，在按“1”键节点将不会执行 想要再次执行，必须对Do N节点进行重置，通过按“2”键重置，再次按“1”键节点才能执行 (四)、DoOnce
这个节点与Do N类似，相当于Do N中将N设置为1，还多了一个bool类型的输入参数Start Closed，默认为true，刚开始的时候节点是关闭的，需重置后才能执行。 例如，刚开始时，按“1”键节点不会执行，须按“2”键重置DoOnce节点， 再次按“1”键，节点才会执行,打印”Hello” (五)、DoOnce MultiInput
这个节点相对于DoOnce可以添加多个分支，同样，执行一次后需要重置才能再次执行 例如，给节点添加几个分支，节点执行时，根据输入分支执行对应的输出分支，按下“1”键时执行输入分支A ln对应的输出分支A Out，想要再次执行其他分支，必须按“1”键重置节点。反复执行 输出结果 (六)、FlipFlop
该节点有两个输出分支。 第一次调用时，将会输出A。 第二次调用时，输出B，并输出一个bool值，判断是否输出A，如果输出A，该值为true，反之为false。 例如，连接两个输出节点，并打印返回值Is A 多次按下“1”键，输出结果 (七)、ForLoop
这是一个循环节点，类使用for循环，通过设置起始下标(First Index)和结束下标(Last Index)来控制循环次数，每次循环都会输出当前循环的下标Index，循环结束后输出到Completed分支，结束循环 例如，将First Index设为0， Last Index设为100，并打印每次循环的Index值，最后打印”Completed” (八)、ForLoopWithBreak 这个循环节点在ForLoop节点的基础上添加了个输入分支Break，执行Break可以跳出当前循环 例如，当index为大于50时，循环结束。程序中每次循环会先判断index是否小于50，如果是，那么执行print string节点，打印index，否则执行ForLoopWithBreak节点中的Break分支，循环结束 输出结果 (九)、Gate 这个节点类似开关，有四个输入分支，Enter，Open，Close，Toggle, Enter为执行分支，只有从这个节点竟如才能执行输出 Open 打开，打开节点执行刘 Close 关闭，关闭节点执行流 Toggle 切换，在Open和Close两种状态将切换 Start Closed 默认关闭 例如，下面每个键对应一个输入节点，执行不同的操作 结果输出 (十)、MultiGate 每次执行，会从一个分支输出，输入值Is Random为Treu时输出分支是随机的，输入值Loop为True时，该节点可以多次循环，反之不行 例如，当Is Random和Loop都为flase时，四个输出分支将从小到大顺序输出，并且只能输出一轮 结果输出 当Is Random和Loop都设为True时，四个输出分支将随机输出，并且只能输出多轮 结果输出 (十一)、Retriggerable Delay 这个节点与Delay类似，唯一不同的是它可以再次触发 例如，设置触发时间为5秒，当节点触发后，再5秒之内再次触发，将重新开始计时 间隔5秒之内重复按下”1”键，Retriggerable Delay重复触发，计时再次归零，这样就无法输出 而Delay节点在触发后，不会再接收新的输入，只有时间到了，节点输出后才会接收输入 间隔5秒之内重复按下”1”键，以第一次触发的时间为准，计时5秒，结果输出 (十二)、Sequence 该节点可以连接多个输出，执行这个节点可以输出多个分支， 结果输出 (十三)、WhileLoop 该节点传入参数为bool类型，为ture是循环，flase是退出循环，类似while循环 例如，创建个integer类型的变量uVal，设置初始值为30，以uVal为参数传入，开始循环， 没次循环uVal将会减1，知道uVal小于等于零，退出循环，执行Comopleted 结果输出 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f091d27683eb14f6a090c3c61af75d21/" rel="bookmark">
			强化学习第二章总结: e-greedy算法，梯度上升算法，the 10-armed bandit problem
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习强化学习《Reinforcement Learning An Introduction》，总结第二章的知识，包含一个问题，两个算法。
问题：the 10-armed bandit problem
算法：e-greedy、剃度上升
仿真代码见附带资料：the 10-armed bandit problem
1. 问题描述：the 10-armed bandit problem 这是一个重复做选择的问题。一共有10个选择，重复选择1000次。
每次选择都会有奖励，奖励是符合固定的正态分布的。
所以做不同的选择，获得的奖励不同；每次做的选择，尽管选择相同，但奖励也不同。
你的目的是，连续做了1000次选择后，得到的回报总和越高越好。
这个图是一个特殊的 10-armed bandit problem。特殊之处在于 q ⋆ ( a ) q_\star (a) q⋆​(a)的值。
重要：10-armed bandit problem是一个系列问题的总称，每个特殊的10-armed bandit problem之间的不同之处在于 q ⋆ ( a ) q_\star (a) q⋆​(a)的值的不同。选择选项 a a a后，获得奖励是符合正态分布的 N ( q ⋆ ( a ) , 1 ) N(q_\star(a),1) N(q⋆​(a),1)。
2. 算法总结 2.1 算法1： ϵ − g r e e d y \epsilon-greedy ϵ−greedy algorithm 你是不知道 q ⋆ ( a ) q_\star(a) q⋆​(a)的具体值的，所以首先要对每个选择的行为值做个估计，因为这个估计值是在不断更新的，所以定义为 Q t ( a ) Q_t( a ) Qt​(a)，意思是在 t t t时刻，选择行为 a a a后，估计得到的奖励值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f091d27683eb14f6a090c3c61af75d21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9652d4b6d8abf340e3b5d6347ccd90ce/" rel="bookmark">
			mysq更新数据库错误：com.mysql.jdbc.MysqlDataTruncation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决Data truncation: Truncated incorrect DOUBLE value问题 出错现场： 更新数据库造成数据截断不正确的双值
### Error updating database. Cause: com.mysql.jdbc.MysqlDataTruncation: Data truncation: Truncated incorrect DOUBLE value: '2019-09-07' 错误原因： 在更新数据时，要修改的参数之间用and连接造成的
将and改为“，”逗号就好了。
&lt;update id="updateInventory" parameterType="java.util.HashMap"&gt; update inventory set &lt;if test="inventoryDate != null and '' != inventoryDate"&gt;inventoryDate=#{inventoryDate}&lt;/if&gt; &lt;if test="inventoryStatusId != null"&gt;and inventoryStatusId=#{inventoryStatusId}&lt;/if&gt; &lt;if test="userCount != null and '' != userCount"&gt;and userCount=#{userCount}&lt;/if&gt; &lt;if test="departNum != null and '' != departNum"&gt;and departNum=#{departNum}&lt;/if&gt; &lt;if test="assetTakePeople != null and '' != assetTakePeople"&gt;and assetTakePeople=#{assetTakePeople}&lt;/if&gt; &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9652d4b6d8abf340e3b5d6347ccd90ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fab38639bb3a67b62384af141b34fa3/" rel="bookmark">
			go语言range关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go特殊关键字range,配合for迭代切片
// 创建一个整型切片 // 其长度和容量都是 4 个元素 slice := []int{10, 20, 30, 40} // 迭代每一个元素，并显示其值 for index, value := range slice { fmt.Printf("Index: %d Value: %d\n", index, value) } /**********运行结果***************/ Index: 0 Value: 10 Index: 1 Value: 20 Index: 2 Value: 30 Index: 3 Value: 40 在迭代切片时,关键字range会返回两个值,一个索引位置和对应元素的一个副本.
for range提供了每个元素的副本
// 创建一个整型切片 // 其长度和容量都是4 个元素 slice := []int{10, 20, 30, 40} // 迭代每个元素，并显示值和地址 for index, value := range slice { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fab38639bb3a67b62384af141b34fa3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/462/">«</a>
	<span class="pagination__item pagination__item--current">463/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/464/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>