<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4734c19f13092f49b21c6e959a82de7/" rel="bookmark">
			微信上的音乐怎么传到计算机上,如何把微信的歌传到电脑上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用微信的朋友越来越多，有的用户在微信之间互相传送文件，但是不知道如何把手机微信上的文件传送或下载到电脑上，最火软件站小编就把传送文件到电脑的文件告诉大家。分为两个步骤，一是把文件发送到电脑，二是下载到电脑本地，其实有点啰嗦，自己看教程吧。
微信传送文件到电脑
1、首先，手机成功登录微信，然后在电脑上打开网页微信(http://wx.qq.com)扫一下登陆
不会登陆网页微信？请阅读电脑登录微信网页版教程：http://www.veryhuo.com/a/view/71942.html
2、手机上点击“文件传输助手”;
3、点击“+”号图标添加内容，如图：
4、若是图片、视频等文件，可以直接选择发送;
若是PDF、Word、音乐歌曲或其他非图片视频的文件，可以事先添加到“我的收藏”，然后再发送;
5、以手机中的图片为例：(如何直接将手机中的图片传给电脑?)
点击“从相册选择”;
6、选中相应图片，
点击“发送”;
电脑如何下载手机发送的文件?
1、登录微信网页版，然后单击“文件传输助手”，再单击手机微信传输的文件;
2、点击“下载”图标，如图：
3、点击“下载”，保存到电脑即可;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db1650280972d332da18d7bb8af43abb/" rel="bookmark">
			HTNL的默认样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去掉HTML标签默认样式 HTML标签的默认样式input标签textarea标签button按钮标签 HTML标签的默认样式 input标签 input的边框、内阴影
border:none;
input获取焦点时出现的蓝色边框
outline: none;
outline: medium;
textarea标签 textarea文本区域禁止拖动：resize: none;
button按钮标签 去掉边框属性、内部阴影
border: 0 none;
outline: none;
/取消button点击的默认样式/
button:focus{
border: 0 none;
outline: none;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d173c696a907074214c7dde71806bf13/" rel="bookmark">
			一张图看懂决策树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些问题
如果训练集有100万个实例，训练决策树大致的深度是多少？
通常来说，二元决策树训练到最后大体都是平衡的，如果不加以限制，最后平均每个叶节点一个实例。因此，如果训练集包含100万个实例，那么决策树的深度为20层。（实际上会更多一些，因为决策树通常不可能完美平衡。） 通常来说，子节点的基尼不纯度是高于还是低于其父节点?是通常更高/更低？还是永远更高/更低？
一个节点的基尼不纯度通常比其父结点低。CART算法分类每个节点的方法，就是使其子节点的基尼不纯度的加权之和最小。但是，如果一个子节点的不纯度远小于另一个，那么也有可能使子节点的基尼不纯度比起父节点高。 如果决策树对训练集欠拟合，尝试缩放输入特征是否为一个好主意？
决策树的优点之一就是他们不关心训练数据，是缩放还是集中。所以如果决策树不适合训练集，缩放输入特征，不过是浪费时间罢了。 快速入门版本
快速回顾版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e44f071c7376a8dd0d3f4b49b25cf34/" rel="bookmark">
			power supply是如何上报电池信息的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引文
作为一个内核初学者，经常容易进入“知其然但不知其所以然”的状态，在power supply子系统中就是这样，知道如何去添加一个属性prop，知道psy可以创建一堆文件节点，也知道上层是通过读取这些节点来获取供电信息的，但对于其中的细节，便知之甚少。最近深究其中，才逐步发现内核的奥妙所在。
二、Android供电系统框架
power supply(以下简称psy)是Linux中从供电驱动抽象出来的子系统，是Linux电源管理的重要组成部分。psy是一个中间层，在kernel中是属于设备驱动的一部分，psy的作用主要是向用户空间汇总各类供电的状态信息。抽象出来的各类信息称为property，比如供电设备是否连接就对应着POWER_SUPPLY_PROP_ONLINE。在驱动层，主要是两大模块，与电池相关的驱动和与充放电管理相关的驱动（对应图中的battery.c和charger.c）,这两大模块主要处理硬件相关的逻辑，在硬件状态发生变化时，会触发相关的中断，驱动层会调用相应的中断函数，并更新修改相应的psy节点值。驱动负责更新psy节点的状态，HAL层会去读这些节点，驱动在检测硬件、传感器信息变化会去更新节点值，而HAL层什么时候会去读取这些节点值呢？以及其中调用的流程是怎样的？今天就简单介绍下。
三、power supply子系统简介
1. 概述
psy子系统的基础是建立在设备驱动模型之上的，主要运用了其中的class、device、kobject、sysfs、uevent相关知识，也是驱动设备模型的一个具体应用。psy子系统中power_supply_class对应着系统中供电设备类，是一个抽象化的集合，对应着/sys/class/power_supply/目录，供电设备都在该目录之下，比如battery设备就对应该目录下一个子目录battery，而battery设备的一个属性则对应battery的一个文件节点，也对应着一个kobject。
2. 相关结构体
psy相关的定义在/include/linux/power_supply.h。
psy_desc是psy子系统中最重要的结构体，该描述符定义了psy的属性property，以及相关的set/get/is_writeable接口，is_writeable即文件节点的“w”权限，所有节点默认是可读的。从get函数可以看到调用该函数需要指定某个psy和psp（属性），结果保存在val中，值得一提的是，val是个union类型，可以传递int或char *。
struct power_supply表示一个psy供电设备，比如电池、AC、USB，一般可通过devm_power_supply_register函数注册成一个psy设备，在注册设备之前需要定义好该设备的psy_desc。
3. 相关接口函数
相关的函数主要在psy_core.c和psy_sysfs.c中，core主要负责设备状态变化逻辑，sysfs主要负责文件节点相关逻辑。
最重要的是power_supply_changed，在驱动中检测到硬件状态发生变化，会通过该函数调度起psy中的changed_work。该工作队列负责发送notifier（内核内不同模块之间）和通过uevent进行change上报。
__power_supply_register负责注册一个psy设备：
在sysfs中有个power_supply_uevent，该函数在psy class初始化时注册为设备节点的dev_uevent，在每一个psy目录下都有一个uevent节点，读取该节点即调用power_supply_uevent函数。该函数遍历当前设备下的所有属性并将结果保存在kobj_uevent_env中，结果以键值对的形式进行保存。
4. 调用流程
psy子系统主要调度的逻辑都在power_supply_changed_work中。跟踪这一调用流程可以在驱动中实现的get_property函数增加调用栈打印：
可以看到，在kobject_uevent_env函数中调用对应kset的uevent，会去遍历每一个属性节点（dev_uevent），之后，会通过netlink_broadcast函数进行广播（使用netlink机制），其中广播的字符串保存在sk_buff-&gt;data中，这一字符串以“action_string@devpath”进行拼接，其中action为kobject_action，而devpath则为该psy设备的设备路径。值得注意的是，使用uevent-netlink机制传递的字符串并不会包含psy属性节点的kobject_uevent_env键值对状态。
四、healthd简介
由于uevent机制仅将一个简单的字符串传递给了用户空间，而安卓系统建立在kernel之上，需要思考如何将设备属性的变化值及时更新到用户空间，于是就有了healthd服务，healthd目前已经更新到了2.1版本，其主要工作通过epoll_wait来监听kernel中的uevent事件。具体的函数调用流程图如下：
相关的代码路径主要是在：
/hardware/interfaces/health/；
/system/core/healthd/；
从service.cpp开始理一下调用流程，可以整理出上述的调用流程，黑色线条为初始化流程，红色线条为当psy-uevent上报后触发epoll之后的调用流程。与底层节点交互的逻辑都在BatteryMonitor中，在初始化过程中会初始化healthd_config结构体，用于保存psy属性节点的路径。
在监听循环MainLoop函数中，一个while(1)循环，调用epoll_wait()函数来监听uevent，收到事件之后会调用初始化时注册好的func（UeventEvent），该函数会通过uevent_kernel_multicast_recv接口去读取netlink发送的sk_buff-&gt;data，通过查找其中的字符串来判断事件是否为psy子系统发送的，如果不是的话，不会进行处理。进一步的处理流程主要是调用到BatteryMonitor中的updateValues，在该函数中会遍历读取psy属性节点，存储在HealthInfo结构体中，之后通过BinderHealth中注册好的回调函数IHealthInfoCallback通知BatterySerice，具体的通知函数为BinderHealth：OnHealthInfoChanged。
Healthd是一个根植于powersupply子系统，并采用了epoll监听底层节点的uevent事件，之后轮询底层属性节点的守护进程。在安卓R版本中，Healthd相关代码重构为libhealthloop和libhealth2impl，但为了保证向后兼容，可以看到在ScheduleBatteryUpdate()函数中调用了两次updateValues，这样会遍历两次底层节点造成了冗余。另外在psy-uevent机制中，也有一次属性节点的遍历，一共三次遍历，这就要求底层驱动在更新属性值时，不能加入耗时的IO操作，否则会影响系统性能。
五、总结
power supply架构的精髓是极大化的发挥了uevent和sysfs的作用，简单高效地抽象出了与硬件无关的关键信息，通过notify机制使得其他内核模块可以及时获取相关事件；Healthd通过epoll监听psy创建的节点uevent，之后再去遍历读取结果，这样是为了避免与kernel的耦合。psy和Healthd比较适合新手学习，能提供一个由外向内的视角去解读kernel，也能加深对设备驱动模型的理解。熟悉之后可以进行相关的逻辑扩展，也可以进一步学习usb模块与psy子系统的关系，也可以进一步探究涉及的notify、netlink、epoll等机制。
参考资料：
[1] Kernel源码：
https://elixir.bootlin.com/linux/latest/source/include/linux/power_supply.h
[2] health服务介绍：
https://source.android.com/devices/tech/health
[3] healthd源码：
https://cs.android.com/android/platform/superproject/+/master:hardware/interfaces/health/?hl=zh-cn
[4] psy_class介绍：
http://www.wowotech.net/pm_subsystem/psy_class_overview.html
[5] Android10.0电源框架源码分析
http://www.cjcbill.com/2020/03/01/battery-frame/
[6] uevent介绍：
http://www.wowotech.net/device_model/uevent.html
长按关注
内核工匠微信
Linux 内核黑科技 | 技术文章 | 精选教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e41eeea473684c1ddbdd94557358c17b/" rel="bookmark">
			基于simulink的UDP通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 本手册主要介绍如何使用simulink进行UDP通信。
软件版本 软件版本使用Matlab2017b，主要使用UDP send、UDP receive，其中，UDP send需要配合Byte Packing使用，UDP receive需要配合Byte Unpacking使用。
参数配置 为方便验证UDP收发模块，将UDP send、UDP receive放在同一个.slx文件中进行调试配置，如下图以发送6个double数据为例：
其中Byte Packing的配置如下：
Output port（packed）data type 选择uint8；
Input port（unpacked）data type（cell array）：
｛’double’, ’double’, ’double’, ’double’, ’double’, ’double’｝ （6个）
UDP send的配置如下：
Remote IP :为远程电脑的IP，这里因为是在一台电脑，所以设置为本机电脑的IP即可；
Remote IP port：为远程电脑的端口号。
UDP receive的配置如下：
Local IP Port：与UDP send的端口保持一致；
Remote IP：此为本机电脑的IP：
Receive buffer size（byte）：6个double共占48个字节，所以设置为48
Output Variable-size signal：不勾选
Byte Packing的配置如下：
output port（unpacked）data type（cell array）：
｛’double’, ’double’, ’double’, ’double’, ’double’, ’double’｝（6个）
output port（unpacked）dimensions（cell array）：
｛[1],[1],[1],[1],[1],[1]｝（6个）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e41eeea473684c1ddbdd94557358c17b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27d49ad133f58fca32343ee0e67421e3/" rel="bookmark">
			Axi memory mapped to PCI Express、uart和gpio IP核在vivado中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先了解了一下几个PCIE IP核，网上这样说（链接: [https://www.amobbs.com/thread-5693775-1-1.html]
7 Series Integrated Block for PCI Express，把PCIe的TLP包转换成AXI Stream信号，然后对TLP包进行解析，从而实现PCIe的通信接口；常用的应用解决方案可以采用移植Riffa，结合Riffa的上位机实现高速数据通信，其中我在板子上实现的PCIe2.0 x8的接口，可以达到大约3GB/s的通信速度。我对这套方案的理解是通信速度快，上位机开发简单，可以直接使用现成的驱动和封装的接口，同样缺点也有，比如只支持win7系统。另外由于Riffa是将PCIe接口转换成了类似于多个通道的形式，每个通道可以近似理解为FIFO接口，因此我对Riffa的理解是适合于传输大量数据，但是没有地址线的概念，因此如果要添加一些现成的接口，比如AXI协议的IP核，显得十分无力，缺乏相应的灵活性。
AXI Memory Mapped to PCI Express，相比于第一个IP核，这种方法就比较简单，可以做到不写一行代码的方式，实现PCIe的数据传输，通过添加 AXI Memory Mapped to PCI Express，然后再添加BRAM Controller，然后再添加一个单口RAM，在Vivado中点一下自动连接，生成接口，约束下时钟和复位信号，生成比特流文件，下载到板子上就可以发现新设备。然后在上位机上使用WinDriver生成驱动，就可以实现对RAM的读写。我对这种方案的理解是思路简单清晰，由于使用了AXI协议，因此可以使用现成的IP核，但是每次只能读取单个寄存器，我觉得这种通信方式在大数据量的传输上速度无法满足要求，效率不高。
如果在第二种方式上实现高速数据传输，通过查看相关的文档，我的理解是添加一个AXI接口的DMA控制器，然后通过读写寄存器的方式去配置DMA控制器，包括源地址核目的地址，然后启动DMA控制器。那么问题就来了，如果DMA控制器将BRAM设定为源地址，电脑主机设定为目的地址，那么读取BRAM的操作是可以完成的，但是写入电脑主机的操作是怎样一种形式，我的猜测是AXI Memory Mapped to PCI Express的IP拥有M_AXI核S_AXI，既AXI的主机核从机形式，主机的M_AXI接口对应了IP核配置中的PCIE：BARS，那么从机的S_AXI接口对应了IP核配置中的AXI：BARS。因此如果DMA控制器要实现往电脑主机内存里面写数据，就要由DMA控制器实现主机，通过S_AXI接口实现数据的转移。在这种操作之前，电脑主机的驱动上要申请一片连续的内存空间，并将这片内存的物理地址告诉FPGA中的DMA控制器，然后启动DMA控制器实现数据的转移。
同理，如果要实现电脑主机向FPGA板卡的数据转移，只是将源地址和目的地址切换下即可。
采用第二种IP核的方法，确实需要添加一个CDMA的IP核，然后通过AXI总线配置好CDMA的目的地址和源地址，参考Xilinx的XAPP1171，同时参考GitHub上XPDMA的开源代码，就是用的这种方法，然后配置电脑主机的物理地址和板卡的地址，启动CDMA中的SGDMA方式传输，将数据由电脑主机的内存转换到板卡的DDR3存储器中，即可完成数据的传递，实现高速率的传输，采用如下的方式：
PCIe x8
AXI width 128 bit
speed test (1 GB data read and write) Write: ~1050 MB/s Read: ~1170 MB/s
达到的速度已经很客观了，由于AXI Memory Mapped to PCI Express的IP核配置中，PCIe x8只能做到2.5GT/s的连接速度，也就是PCIe1.0的速度，因此如果采用5GT/s的PCIe2.0连接速度，上述所能达到的速率还能够再提升一倍，另外我觉得DDR3的带宽也是一种重要的影响因素，如果发送到片上的BRAM中，将能够实现更高的传输速度。
同时对于第三种IP核的使用进行了验证，搭建了一个测试工程，同样能够发现板卡，也能够实现对片上BRAM的读写操作，根据手册能够读取到DMA的相关信息，但是目前还不知道怎么使用，具体的使用方法还有待进一步研究，可以肯定的是采用第三中IP核方式，是能够实现PCIe x8的5GT/s连接速率，估计着能够达到的速度也在3GB/s左右。
我使用的比较功能比较简单，速度也没有太高的要求，就使用了相对简单的AXI Memory Mapped to PCI Express，具体的使用过程是：
1、使用Block Design设计，添加AXI Memory Mapped to PCI Express IP核，使能Bar0，空间选择1Mbytes。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27d49ad133f58fca32343ee0e67421e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5959b483b1e53a26a0a0f7d3ab8a35ea/" rel="bookmark">
			分享哈啰出行小程序架构演进之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天跟大家分享一下哈啰出行支付宝小程序的架构演进之路。
内容主要分四个部分。一是对支付宝小程序的简单介绍和我们的项目背景，二是我们遇到的问题和解决问题的思考，三是我们为了解决这些问题引出的哈啰小程序新架构，四是对未来的展望。
一、小程序介绍及背景
接触过支付宝小程序的同学可能不是太多，不过不要慌，你完全可以把支付宝小程序当成微信小程序，它们有非常相似的架构。都有一个大而全的IDE，如图，左中侧是一个类似 VS Code 的编辑器，右侧是小程序模拟器，顶部是配置和操作区域。通过这个IDE，开发者可以完成开发过程中的闭环操作。
小程序是一种特殊的网页应用，有一个至关重要的全局配置，用以声明小程序包含哪些页面、配置全局默认标题和样式等。配置页面时要直接声明页面文件的目录，不支持别名等功能。
二、问题和思考
在理想情况或较为简单的业务场景下，开发、发布流程比较简单。在快速迭代、敏捷开发和git flow开发规范的情况下，开发者需要为一个版本创建一个 release 分支，从 release 分支切出一个功能对应的 feature 分支进行开发，开发完成后合并代码，并使用 release 分支代码发布体验码进行测试，测试完成后使用此体验码进行发布。
但是这种纸上谈兵的模式是完全无法支撑哈啰出行小程序这种中大型规模小程序的开发的。实际情况是这样的：
哈啰出行小程序有十几个业务线同时在开发，对应十几个需求、几十位开发、几十个 feature 分支。复杂度到达一定量级后小程序的开发发布流程会成为灾难。比如人多后很容易同时在修改同一个文件或者分支间提交同步不及时从而引发 git 冲突问题，git 冲突问题是无法自动化解决的，非常依赖开发者对冲突代码的理解，大型的冲突很难得到妥善解决。没有什么git操作是比处理冲突更让人心情糟糕的，如果有，那就是……这边先卖个关子，后面我们会提到。再比如一个需求开发完成后，开发者需要生成体验码给测试同学测试，但是小程序的体验码是同一时间只能存在一个的，新的体验码会让旧体验码失效，而且体验码的发布是没有集中机制的，任何开发者都有权限通过上述 IDE 的操作区发布体验码。这些原因会造成体验码的使用不便，你不知道这个体验码有没有失效、是谁发布的、对应哪个分支的代码、有没有你要测试的功能、最新的体验码在哪。由此我们引出了两个问题，「代码分支冲突」和「发布流程失控」。
再来关注下我们的业务演变，这两个图分别是2018年v4版本和2019年v5版本的首页截图。
可以比较明显地看出，首页的业务tab从只有两个快速增加到超过五个。而实际上从2018年到现在的时间里，哈啰出行的业务规模快速膨胀，业务线数从2个到11个，开发者数从2个到20多个。对于一个野蛮生长的项目来说，突然承接这么多业务需求和功能，自然而然会出现业务代码耦合的问题。需求和功能增加意味着页面和组件的增加，也就是代码量的增加，这对体积敏感的小程序来说也是不小的负面影响。不仅不利于线上的用户体验，还会增加开发调试阶段开发者构建速度，拖慢构建效率。
这样我们又获得三个问题，「业务代码耦合」、「小程序体积过大」和「编译时间过长」。
回顾一下所有的问题，我们将其分为两类。「代码分支冲突」、「业务代码耦合」、「编译时间过长」属于代码及项目组织问题；「发布流程失控」和「小程序体积过大」属于发布流程松散的问题。两类问题有各自的解决方式。
对于代码及项目组织问题，我们的解决思路是分仓库。哈啰出行支付宝小程序的最大特点就是参与的业务线特别多，复杂度也是由此产生的。因为我们决定把每个业务线的代码拆到单独的仓库里。业务无关的代码，比如小程序入口、框架及登录和定位这种通用能力，还是保留在原来的基础仓库。自此形成了基础仓库为平台底座，业务仓库为可插拔模块的组织架构。
每个业务线被归到独立仓库后，就可以充分利用gitlab仓库的管理能力，从原先的只在唯一一个仓库进行所有业务线的分支管理，分解成在业务线的小仓库里自行进行同业务的分支管理，从而拆解分离了业务域，降低了分支管理的复杂度。同时业务线之间的代码权限也被仓库隔离开，实现了代码安全和数据安全。
现在代码是拆开了，但是运行时还是需要拼成一个完整的小程序的。那么要怎么做集成呢？我们主要考虑了两个方案。一是git submodule/git subtree，这个方案经过调研后很快被否决了，submodule 和 subtree 是相似的管理子仓库的方案，但是它们指令复杂，学习成本太高，操作失败没有友好的提示，不适合我们这种人员变动比较频繁的大型团队。前面提到没有什么git操作比处理冲突更让人心情糟糕，如果有那就是 submodule/subtree 了。第二种方案是 lerna，lerna 是近年来在开源社区比较流行的一个多包管理工具，知名的 babel、react 都在使用 lerna 管理仓库。但它还是不合适，lerna 注重多 package（npm概念上的包）架构的管理，而我们只是子仓库，而非多个 package。而且 lerna 提供的功能合指令优先，定制化比较困难，无法实现我们想要的一些功能，所以最终也没有选用 lerna。
最终我们决定自研构建工具来实现代码集成。有了自己的构建工具相当于增加了一层抽象层，增加了项目的自由度。有句话说得好，没有什么问题是不能通过增加一个抽象层解决的，如果有，就再增加一层。通过构建工具这层抽象层，我们实现了除了基础和核心的仓库代码集成之外的很多功能和特性。其中比较重要的功能叫做增量构建。含义是能动态指定需要构建的业务线。我们的业务线比较多，而一个业务线的同学通常只在本业务线内进行开发，我们小程序体积比较大，构建预览起来比较慢，而且不支持也更新，每次保存代码后都需要重新构建一次，开发过程较为痛苦。而增量构建能实现仅构建平台仓库和一个业务线的代码，从而减小小程序体积，加快构建预览速度，提升开发体验。
在介绍增量构建原理前，我们先简单理解一下分型的概念。分型是一个数学上的概念，表示宏观、介观或微观尺度上，物理结构的相似性。在小程序的项目配置和目录结构上，也存在着抽象意义上分型概念的存在，即小程序配置中声明分包与页面的嵌套结构与文件系统中业务仓库与页面代码位置的嵌套结构是一致的。如果能同时动态控制两个结构就能实现动态控制小程序的内容，这也就是增量构建的原理。
我们来身临其境体会下增量构建是怎么使用的。开发者使用构建工具的命令行功能通过参数的形式指定要构建的对象，命令行工具拼装参数传递给构建工具核心，构建工具根据参数有选择地仅将构建目标的代码移动到产物文件夹，并生成相应分型结构的小程序配置，最后开发者使用小程序ide打开产物文件夹。
构建工具也带来一些小插曲。在开发中难免会有组件跨仓库互相调用的情况，若依赖的组件没有被构建进来小程序是无法运行的。对此我们在构建时分析依赖的组件所在的仓库是否在本次构建列表中，如果没有则只能移除对此组件的依赖。此外对于页面跨仓库跳转时，我们对跳转 api 加了一层 hook，运行时判断目标页面是否被构建进来，如果没有则重定向到兜底的404页面。
构建工具真的有用吗？我使用了MacBook Pro16 GB 2133 MHz LPDDR3 1.4 GHz 四核Intel Core i5的测试机器进行了基准测试。全量构建的产物体积是33.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5959b483b1e53a26a0a0f7d3ab8a35ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d601040241960ebe43093fdef8d735bf/" rel="bookmark">
			手机html端悬浮球,大屏手机绝配！一款轻巧强大的悬浮球App
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多智能手机用户，特别是iPhone用户，很喜欢使用悬浮球。不过和iPhone相比，安卓上的悬浮球可丰富多彩得多。安卓原生并不自带悬浮球的功能，但诸多悬浮球App，却提供了丰富多彩的方案。加之安卓机的屏幕普遍较大，点击Home键返回键比较困难，悬浮球App更有必要了。今天，笔者就来为大家介绍一款体验不错的悬浮球App“fooView”，一起来看看吧。软件名称：FV浮动阅览器
软件版本：0.7.1
软件大小：5.04MB
软件授权：免费
适用平台：Android
据介绍，这款fooView悬浮球App的开发者早期曾经参与过ES文件管理器的开发，水平还是值得信赖的。这款fooView悬浮球App的使用很简单，开启后，会有简单的使用说明，同时也会有授权界面。没错，fooView需要先授权，才能够发挥作用，它需要请求悬浮窗、通知栏以及返回键的权限，按照提示开启即可。
开启后需要先授权，按照提示授权即可
这个fooView悬浮球App的功能还是比较强大的，它的功能包括返回键、Home键、切换App、呼出通知栏以及截屏。具体要怎么用呢？拖动悬浮球稍微向侧边滑动然后放手，可以充当返回键的功能；而如果一直滑动到屏幕另一侧才放手，则会实现Home键的功能。类似的操作在很多悬浮App都有，不过这款fooView还多了上下滑动的操作。向上滑动放手，可以呼出fooView应用本身的界面，而向下则能够呼出通知中心，还是挺不错的。
会有操作提示，可以通过滑动实现Home键、返回键、开启App以及通知中心的功能
fooView悬浮球App的一大卖点，就是App本身带有一个浏览器。向上滑动呼出App本体，其主界面就是一个浏览器。根据笔者测试，这个浏览器其实是WebView套壳实现的。它的速度和界面都还不错，有一些天气信息之类的实用页面。此外，这个浏览器也支持多标签页面等常见功能，但笔者觉得大部分人还是会选择平时惯用的浏览器，fooView的这个浏览器聊胜于无吧。而在App界面中，通过侧滑菜单，可以对一些功能、外观进行设置，例如更换悬浮球图标、位置以及改变搜索引擎等。
fooView可以充当浏览器，是通过套壳系统WebView实现的
在App中可以设置悬浮球的大小、样式、位置等等
除了滑动能够实现操作外，fooView悬浮球点按的时候，也有另外的功能！例如，长按悬浮球，会呼出一个扇形的菜单。这个菜单的内圈显示的是最近开启过的App，可以方便地在最近使用的App间切换，可以当成是安卓的多任务按钮。除了可以显示最近使用的App外，外围的圈圈还能够提供天气、便签、电话等快捷按钮，还是挺不错的。
能够切换最近使用的App，甚至带有应用管理功能
fooView还有一个相当不错的截屏功能，只要把悬浮球滑动到其他位置，不松手让悬浮球停留一阵子，就可以呼出截屏功能了。这个截屏是可以任意选择区域截屏的，完成截屏后，不仅仅可以保存成为图片，还能够自动识别图片上的文字，进而复制或者乃至翻译，相当给力。
支持区域截屏，如果截屏部分有文字，还能够自动识别文本，供用户复制或者翻译
总的来说，这是一款功能可圈可点的悬浮球App。fooView悬浮球App可以用来取代安卓机的Home键、返回键和多任务键，此外还有额外的浏览器、截屏等功能，可谓是非常实用。如果你正在使用大屏幕安卓机，手指常常够不到按钮，不妨试试这款fooView悬浮球App吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5976be5959b8c94095294e59eb3510b8/" rel="bookmark">
			c&#43;&#43; 调用modnet--实现实时超准语义分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近又有一个算法火了，不知道你们看到没？直接看效果！
效果这么稳定的人像 Image Matting 算法真的不多，并且还能进行实时处理！
处理视频、图像，不在话下。人在家中坐，录段视频，你就可以把自己放到世界各地的美景中。
这类的抠图 AI 算法，已经出现过不少，但这一款确实让人觉得很惊艳。
废话不多话，直接python用起来，相关代码可以去github下载（是GPU的和cpu的都有）
cpu的先实验
""" Inference ONNX model of MODNet Arguments: --image-path: path of the input image (a file) --output-path: path for saving the predicted alpha matte (a file) --model-path: path of the ONNX model Example: python inference_onnx.py \ --image-path=demo.jpg --output-path=matte.png --model-path=modnet.onnx """ import os import cv2 import argparse import numpy as np from PIL import Image import onnx import onnxruntime if __name__ == '__main__': # define cmd arguments parser = argparse.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5976be5959b8c94095294e59eb3510b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf18dc9b64a0d2a2a2806b66df9f4a69/" rel="bookmark">
			台式计算机声音输出方式在哪里,电脑声音无法找到输出设备怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们日常使用电脑的时候有时候会把声音外放，正常的时候是能够播放出来的，但偶尔会出现系统提示“无法找到声音输出设备”，这时候我们电脑的声音就无法播放了，视频的声音和音乐的声音都无法播放，那么电脑声音无法找到输出设备该怎么解决呢？
方法一：
1、按下【Win+R】组合键打开运行，输入：services.msc 点确定打开服务。
2、找到【Windows Audio】服务，双击打开。
3、该服务未启动的话将其启动，若以启动则先停用，停用后再启用即可。
方法二：
1、在任务栏小喇叭上单击右键，选择【播放】;
2、选择默认的设备作为默认通信设备，单击右键点击“属性”。
3、切换到【增强】选卡，将会里面的所有特效的勾选都去掉，点击应用—确定。
方法三：
1、在开始菜单上单击右键，选择“设备管理器”。
2、展开【音频输入和输出】，在下面的声卡设备上单击右键，选择【属性】。
3、点击【驱动程序】选卡，点击下面的【回退驱动程序】按钮，完成回退驱动后重启win10系统即可。
方法四：
1、首先检查驱动，没办法，最问题首先查驱动，如果驱动没有问题的话，执行以下操作。
2、按下键盘上的组合键【WIN】+【X】打开菜单，然后按下【O】键，打开【电源管理】。
3、然后进入此项【选择电源按钮的功能】。
4、然后点击此项【更改当前不可用的设置】。
5、点击了以后，在下方将【启用快速启动】取消勾选。然后保存，重启电脑。即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534e5682f6ff47c229ce29a112eceb69/" rel="bookmark">
			QT Ubuntu18安装qt&#43;vtk-6.3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu18安装qt+vtk-6.3 1.Qt5.1.0安装2.vtk6.3安装2.1 下载2.2 build and make2.3 配置QT 3.QT+VTK试运行3.1 新建工程，配置头文件和库的路径3.2 拖入一个VTK控件(我创建的是带窗体的工程)3.3 编译、运行、显示如下： 4.问题总结5.参考链接5.1 安装5.2 使用 1.Qt5.1.0安装 Qt下载地址：http://download.qt.io/
我的版本：https://download.qt.io/archive/qt/5.1/5.1.0/
注1：亲测高版本(5.14)与vtk6.3不兼容 (vtk cmake配置缺少web模块)
注2：安装时如需注册登录，断网即可跳过
(ROS)https://ros-qtc-plugin.readthedocs.io/en/latest/_source/How-to-Install-Users.html
2.vtk6.3安装 2.1 下载 vtk下载地址： https://vtk.org/download/
我的版本：https://gitlab.kitware.com/vtk/vtk/-/tree/v6.3.0
之所以执着于6.3 是因为我ubuntu中已安装了6.3且别的库依赖于6.3
2.2 build and make cd /path/to/VTK(解压位置)
mkdir build
cd build
cmake -DVTK_QT_VERSION:STRING=5 \ -DQT_QMAKE_EXECUTABLE:PATH=/home/gy/Qt5.1.0/5.1.0/gcc_64/bin/qmake \ -DVTK_Group_Qt:BOOL=ON \ -DCMAKE_PREFIX_PATH:PATH=/home/gy/Qt5.1.0/5.1.0/gcc_64/lib/cmake \ -DBUILD_SHARED_LIBS:BOOL=ON \ .. 由于testing数据下载很慢，所以我使用cmake-gui 取消BUILD_TESTING 显示如下：
然后执行
make
sudo make install
2.3 配置QT 将编译好的libQVTKWidgetPlugin.so 复制到QtCreatord的plugins/designer目录下 可参考以下操作
find ./ -name libQVTKWidgetPlugin.so cp .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534e5682f6ff47c229ce29a112eceb69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f651c65d158fbce4faa1555bbc617297/" rel="bookmark">
			STL常见面试题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一．Vector原理
1.vector是动态数组，所以和数组一样拥有一段连续的内存空间，并且起始地址不变。
2.因为vector地址空间是连续的，所以能高效的进行随机访问，时间复杂度为o(1)。
3.在vector中插入和删除元素，需要对现有元素进行复制、移动，时间复杂度为o(n)。
4.如果vector中存储的对象很大，或者构造函数复杂，那么插入等开销会很大。因为拷贝现有对象时需要调用拷贝构造函数。
二 vector扩容原理
1新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就会分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。注意不是在原来空间后直接增加空间
2对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。
3不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。
三 vector扩容为什么以2倍增长
1时间和空间的权衡，简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。
2 均摊添加每个元素的开销最小。
四 vector扩容为什么以1.5倍增长
理想分配方案是是在第N次分配的时候能重用之前N-1次释放的内存，如果按照1.5分配，1，1.5，3，4.5……当你需要分配4.5时，前面已分配5.5，你可以直接利用，把旧数据move过去。但选择两倍的增长比如像这样：1，2，4，8，16，32，… 每次需要申请的空间都大于用到前面释放的内存(4&gt;2+1)，无法重用。
五 vector常用接口：
• 清空vector可以使用成员函数c.clear()
• 判断vector是否为空，可以使用成员函数empty()，如果为空返回true，否则返回false
• vector输出最后一个元素的引用可以用back()成员函数，如果容器为空，则行为未定义
• vector输出第一个元素的引用可以用front()成员函数，如果容器为空，则行为未定义
• vector支持用下标访问元素，类似数组一样c[n]其中n是一个无符号整数，如果n大于容器的长度，那么行为未定义
• vector为了防止越界访问，其中有成员函数c.at(n)，返回下标为n的元素的引用。如果下标越界，那么抛出out_of_range的异常
• pop_back()成员函数用来删除vector中的最后一个元素，如果容器为空会出现未定义行为。
• c.erase(it)成员函数，删除迭代器it所指向的元素，返回一个指向被删除元素之后的迭代器，如果it指向最后一个元素，那么返回以为尾后迭代器（通常是end()）。若it就是end()，那么行为未定义。
• c.erase(beg,ed)删除[beg,ed)范围的元素，同时返回最后一个元素的后面的迭代器，如果ed就是尾后迭代器，那么还返回一个尾后迭代器。
• vector中begin和end函数返回的是什么？
begin返回的是第一个元素的迭代器，end返回的是最后一个元素后面位置的迭代器。前闭后开区间【）
• vector中的reserve和resize的区别
reserve是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以 提高效率，其次还可以减少多次要拷贝数据的问题。reserve只是保证vector中的空间大小（capacity）最少 达到参数所指定的大小n。reserve()只有一个参数。
resize()可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变。resize()可以有 多个参数。
• vector中的size和capacity的区别
size表示当前vector中有多少个元素（finish - start）;
capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage - start）;
• vector迭代器失效的情况
当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。 当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下 一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it)。
• 正确释放vector的内存(clear(), swap(), shrink_to_fit())
vec.clear()：清空内容，但是不释放内存。
vector().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。 vec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f651c65d158fbce4faa1555bbc617297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fdfad21463a17a81a0036cd3cd816f5/" rel="bookmark">
			【C/C&#43;&#43;】int,long和long long的区别；int 、long 占多少字节？VS 下int、long、long long占多少字节。X86和X64下的区别。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说理论 以前学的是long 在32位系统中4字节，64位系统中8字节。但是实际用的时候发现不是，现在总结一下：
对于long 来说：
OSarchsizeWindowsIA-324 bytesWindowsIntel 644 bytesWindowsIA-644 bytesLinuxIA-324 bytesLinuxIntel 648 bytesLinuxIA-648 bytesMac OSIA-324 bytesMac OSIntel 648 bytes 来源：Intel C++编译器在可变平台上的规则
VS下的测试： cout &lt;&lt; "sizeof(int)	"&lt;&lt; sizeof(int)	&lt;&lt; endl; cout &lt;&lt; "sizeof(long)	"&lt;&lt; sizeof(long)	&lt;&lt; endl; cout &lt;&lt; "sizeof(long long)	"&lt;&lt; sizeof(long long)	&lt;&lt; endl; cout &lt;&lt; "sizeof(float)	"&lt;&lt; sizeof(float)	&lt;&lt; endl; cout &lt;&lt; "sizeof(double)	"&lt;&lt; sizeof(double)	&lt;&lt; endl; cout &lt;&lt; "sizeof(int*)	"&lt;&lt; sizeof(int*)	&lt;&lt; endl; 1、X86 32位结果： sizeof(int) 4 sizeof(long) 4 sizeof(long long) 8 sizeof(float) 4 sizeof(double) 8 sizeof(int*) 4 1、X86 64位结果： sizeof(int) 4 sizeof(long) 4 sizeof(long long) 8 sizeof(float) 4 sizeof(double) 8 sizeof(int*) 8 可见windows下这几个变量只有指针是不同的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fdfad21463a17a81a0036cd3cd816f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c100b2099be0920e514ee0b8446c196/" rel="bookmark">
			Hadoop-HDFS的DataNode介绍及原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataNode DataNode工作机制 1、一个数据块在 DataNode 上以文件形式存储在磁盘上,包括两个文件,一个是数据本
身,一个是元数据包括数据块的长度,块数据的校验和,以及时间戳。
2、DataNode 启动后向 NameNode 注册,通过后,周期性(1 小时)的向 NameNode 上
报所有的块信息。
3、心跳是每 3 秒一次,心跳返回结果带有 NameNode 给该 DataNode 的命令如复制块数
据到另一台机器,或删除某个数据块。如果超过 10 分钟+30秒没有收到某个 DataNode 的心跳,则
认为该节点不可用。
4、集群运行中可以安全加入和退出一些机器。
数据完整性 DataNode 节点保证数据完整性的方法。
1、当 DataNode 读取 Block 的时候,它会计算 CheckSum。
2、如果计算后的 CheckSum,与 Block 创建时值不一样,说明 Block 已经损坏。
3、Client 读取其他 DataNode 上的 Block。
4、DataNode 在其文件创建后周期验证 CheckSum。
前两个是常见的奇偶校验，及看1的个数是偶数则校验位为0，个数为奇数则为1；接收到数据后重新计算1的个数并与校验位对比，正确则校验通过；但是这种校验只能校验出单点故障（即一个数据发生变化的情况），对于多点故障则无法正确校验。
Hadoop采用crc校验，能够精确校验出传输数据是否出现变化。
crc（循环冗余检验）：发送方机使用某公式计算出被传送数据所含信息的一个值，并将此值附在被传送数据后，接收方计算机则对同一数据进行相同的计算，应该得到相同的结果。如果这两个CRC结果不一致，则说明发送中出现了差错，接收方计算机可要求发送方计算机重新发送该数据。
掉线时限参数设置 &lt;!-- hdfs-site.xml --&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.heartbeat.recheck-interval&lt;/name&gt; &lt;value&gt;300000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.heartbeat.interval&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; 需要注意的是 hdfs-site.xml 配置文件中的 heartbeat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c100b2099be0920e514ee0b8446c196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e2378807b72185671021cff18d008b/" rel="bookmark">
			vs 配置 .pdb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 配置生成位置：
当前工程右键属性 -&gt; 配置属性 -&gt; 链接器 -&gt; 调试
右边 生成调试信息 选择是
生成程序数据库文件 选择刚才pdb目录+生成pdb文件名
配置加载pdb位置：
第一： 也是最简单的，就是直接将pdb文件放在执行文件的同一目录，那么vs就直接能找到了。
第二：设置pdb目录，然后加载。
即： vs菜单栏 工具-&gt;选项-&gt;调试-&gt;符号
然后在右边添加pdb目录路径就可以了
加载过程：
在原项目debug模式下 编译出 .pdb 和 .dll 文件。 注意：源文件和.pdb .dll 必须是同一个版本把文件替换到相应位置，.pdb文件同样拷贝到.dll同目录下。VS打开需要调试的源文件，然后附加到进程。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab80e40105480645f5cf58ee0e4e334/" rel="bookmark">
			python精确统计Gitlab统计代码的贡献量指标【作为开发KPI参考没毛病.....】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.需求分析与解决思路 **1.需求：** 需求是公司大领导想要了解每月研发提交的代码量，虽然本人也认为代码量不代表质量。可是现实总是如此的无奈，用量来衡量质量如此不可取的方法只会导致更加内卷。 **2.解决思路：** 工具： Gitstats :仓库代码统计工具之一,可以按git提交人、提交次数、修改文件数、代码行数、注释量在时间维度上进行统计，亦可按各文件类型进行简单的统计，非常方便，适合小团队代码统计分析。 当然还有其他优秀仓库代码统计工具，个人觉得不太友好的地方是需要clone下代码配合分析，不适合项目非常多的情况。 开发：Python3.x 如果项目，分支，用户很多的情况，先按照每个项目分析生产报告，后合并到一个总的excel报告中。 二.实现代码部分 **1.方法一: 先按项目分析生产单个cvs报告，再汇为一个cvs** #!/usr/bin/env python # coding=utf-8 import requests import os import json import threading import datetime """统计的时间区间-开始日期""" git_root_url = "http://blog.csdn.net/" """访问Token""" git_token = "blog.csdn.net" """统计结果的存储目录""" export_path = "./dist" """统计的时间区间-开始日期""" t_from = "2021-06-01" """统计的时间区间-结束日期""" t_end = "2021-07-01" """统计的时间区间-开始日期，datetime对象""" date_from = datetime.datetime.strptime(t_from, '%Y-%m-%d') """统计的时间区间-结束日期，datetime对象""" date_end = datetime.datetime.strptime(t_end, '%Y-%m-%d') """一个线程锁""" lock = threading.RLock() user_unknown = {} user_email_alias_mapping = {} user_email_name_mapping = {} class GitlabApiCountTrueLeTrue: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab80e40105480645f5cf58ee0e4e334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/685d3e23dc3016ed357faf42f2342718/" rel="bookmark">
			解析super.img镜像的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、从设备导出分区的方法
二、从pac包中提取img镜像
三、判断img镜像类型
四、sparse格式转为raw格式
五、解包super.img
六、解析出raw格式镜像（以system_a.img为例）
下面来详细分析
一、从设备导出分区的方法 以data分区为类，其它分区(如vendor，system，cache等)类似，当出现data分区引起的无法开机、开机定屏等问题时，按以下方法把data分区导出来：
1、手机如果发生黑屏和开机定屏等，直接掉电，不要重启手机
2、打开ResearchDownload工具，load一个对应项目的PAC包，把下载项全部取消，只保留FDL1和FDL2，如下图一样；
3、勾选”Active Read Flash”， 然后按下图所示填写， File里的路径和文件名随你自己定义，size填实际要读取的data分区十六进制大小，单位是字节，本例是0x80000000；如下图所示
4、再按正常烧录步骤来工具就可以开始镜像读取了；
5、烧录完即可从路径中拿到回读的镜像文件。
二、从pac包中提取img镜像 1、选择ResearchDownload工具的Load Package按钮，在弹出的对话框中选择要提取镜像的pac包
2、打开Download Settings按钮，取得列表框中FileName项对应的目录;
3、windows文件浏览器中找到该目录，目录里面的文件就是要提取的img文件，把需要提取的img文件拷贝出来；
注意：如过super.img在ResearchDownload中显示后缀为super.img.flag，则目录下就找不到super.img，需要换较低版本的ResearchDownload加载pac包，再重复上述操作。
如果是高版本，可以将bin/BinPack.ini 修改 MaxDataLength = 0 LoadPolicy = 0
三、判断img镜像类型 在pac包里面提取出来的img镜像文件，如userdata.img，system.img，super.img，有可能是sparse格式或raw格式，如果是sparse格式要先转成raw格式才能被读取；
通过file命令来判断其格式，在linux下面执行如下命令(以system.img)为例：
1、#file system.img
--&gt;system.img: data //如果显示是data，则为sparse格式
2、#file system.img //如果显示是类似下面的，则已经是raw格式
--&gt;system.img: Linux rev 1.0 ext4 filesystem data,UUID=da594c53-9beb-f85c-85c5-cedf76546f7a, volume name "system" (extents) (large files)
四、sparse格式转为raw格式 如果ext4的img镜像是sparse格式，要先转换为raw格式(如果已经是raw格式可以直接跳过这一步)：
通过simg2img工具转换，在windows和linux都有相应的版本，在命令行中执行如下命令：
#simg2img &lt;sparse_image_file&gt; &lt;raw_image_file&gt;
执行完之后，sparse格式的sparse_image_file 就被转换为raw格式的ext4镜像文件raw_image_file。
备注：Android源码目录sytem/core/libsparse下也有simg2img源码，可使用make simg2img指令编译，生成路径为out/host/linux-x86/bin/simg2img ，如果使用simg2img指令提示Bad magic或Invalid sparse file等信息，如下图所示，则可能说明该img不是sparse格式，可能已经是raw格式的。继续执行后续动作即可。---主要依赖out/host/linux-x86/bin/simg2img和out/host/linux-x86/lib64文件夹下面的so库文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/685d3e23dc3016ed357faf42f2342718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8617a1abfe1b7cf165365cbd5ccb5581/" rel="bookmark">
			linux查看服务器配置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、查看操作系统
二、查看cpu信息
1、所有信息 lscpu
2、查看逻辑cpu的数量
3、查看物理cpu的数量
4、查看每个物理cpu的内核数
5、每个物理CPU上逻辑CPU个数
6、判断是否开启了超线程：
三、查看内存信息
1、查看内存使用情况：free -h
2、查看内存详细信息 cat /proc/meminfo
四、查看磁盘信息
1、Linux下查看硬盘及分区信息 ：fdisk -l
2、查看磁盘使用情况：df -h
3、查看某个目录的大小：du -sh
4、查看某个目录下占用空间最多的文件或目录。
5、查看指定目录下的文件占用大小。
6、du命令详解
一、查看操作系统 1、查看操作系统的版本
命令：cat /etc/redhat-release 2、查看系统内核
命令：uname –a
二、查看cpu信息 1、所有信息 lscpu [root@tes ~]# lscpu Architecture: x86_64 ##cpu架构 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 4 ##总共有4核 On-line CPU(s) list: 0-3 Thread(s) per core: 2 ##每个cpu核，只能支持2个线程. Core(s) per socket: 2 ##每个cpu，有2个核 座： 1 ##总共有1个cpu NUMA 节点： 1 厂商 ID： GenuineIntel CPU 系列： 6 型号： 85 型号名称： Intel(R) Xeon(R) Platinum 8269CY CPU @ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8617a1abfe1b7cf165365cbd5ccb5581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fae6aae7cd38694c88b248732df0778d/" rel="bookmark">
			基于线性表和二叉排序树的低频词过滤系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;vector&gt;
#include&lt;time.h&gt;
#define NUM 5
using namespace std;
void Sort(vector&lt;vector&lt;char&gt;&gt; &amp;WordList,vector&lt;int&gt; &amp;WordNum,int n) { //将单词表中的单词按照出现频率从大到小排序
for(int i=0;i&lt;n;i++)
for(int j=i;j&lt;n;j++)
if(WordNum[i]&lt;WordNum[j]){
int temp=WordNum[i];
WordNum[i]=WordNum[j];
WordNum[j]=temp;
vector&lt;char&gt; Temp=WordList[i];
WordList[i]=WordList[j];
WordList[j]=Temp;
}
}
int repeat(vector&lt;vector&lt;char&gt;&gt; WordList,vector&lt;char&gt; word){ //判断单词表WordList中是否存在单词word,若存在则返回位置，否则返回0.
for (int i=0;i&lt;WordList.size();i++)
if(WordList[i]==word) return i+1;
return 0;
}
double Readword(ifstream &amp;infile,vector&lt;vector&lt;char&gt;&gt; &amp;WordList,vector&lt;int&gt; &amp;WordNum) { //存储文件中的单词及数量
double ASL=0; //平均查找次数
vector&lt;char&gt; word; //单词存储器
char ch; //字母存储器
int loction; int m; //记录单词在单词表中的位置
if(infile){
while((ch=infile.get())!=EOF){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fae6aae7cd38694c88b248732df0778d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e30592f457243dfb117be9aead996a63/" rel="bookmark">
			SSRF总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SSRF概述SSRF危害SSRF利用方式SSRF相关协议利用file(读取内网文件)http/https(扫描内网存活主机)dict(扫描内网端口,攻击服务)gopher(对多种服务进行攻击) SSRF中各类编程语言的限制phppythonjava SSRF修复方案SSRF绕过方式http基本认证30x跳转url解析问题127.0.0.1的多种形式dns rebindingWhen TLS Hacks You SSRF概述 SSRF是Server-side Request Forge的缩写，即服务端请求伪造。这个漏洞最大的特点是改变了大多数漏洞恶意请求从客户端发出的情况。通过利用具有SSRF漏洞的服务端向其他服务器获取数据这一功能，将恶意数据以SSRF服务器作为代理发出，进而攻击本地或者远程的目标。
SSRF的形成大多是因为服务端没有对目标地址做过滤和限制。
SSRF危害 信息收集
对外网，以及服务器所在内网进行端口扫描，获得banner等信息
对内网的Web资产进行指纹识别，获得企业内部的资产信息攻击服务
攻击运行在内网和服务器上的redis，memcache等服务
对内网的web服务进行攻击，如SQL注入，文件上传，储存型XSS等通过http请求就可构造的攻击获取文件
通过file协议对服务器本地文件进行读取命令执行
如果业务本身就存在与远程节点的连接管理功能(如对服务器的连接管理)，可能存在拼接指令造成rce SSRF利用方式 SSRF相关协议利用 协议名利用方式file如果SSRF有回显，可利用file协议去读取任意文件的内容http/https探测内网ip存活，Web资产的信息gophergopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shelldict泄露安装软件版本信息，查看端口，操作内网redis服务等 接下来以一段有缺陷的PHP代码为例探究各个协议的利用以及危害。
function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch); } $url = $_GET['url']; curl($url); file(读取内网文件) 读取内网服务器的文件
http/https(扫描内网存活主机) 一般是先想办法得到目标主机的网络配置信息，如读取/etc/hosts、/proc/net/arp、/proc/net/fib_trie等文件，从而获得目标主机的内网网段并进行爆破。
内网IP网段:
C类：192.168.0.0 - 192.168.255.255B类：172.16.0.0 - 172.31.255.255A类：10.0.0.0 - 10.255.255.255 dict(扫描内网端口,攻击服务) 可以通过dict协议根据响应时间和内容去扫描内网开放端口以及端口上运行的服务信息
ssrf.php?url=dict://192.168.52.131:6379 // redis ssrf.php?url=dict://192.168.52.131:80 // http ssrf.php?url=dict://192.168.52.130:22 // ssh gopher(对多种服务进行攻击) Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用TCP 70端口。但在WWW出现后，Gopher失去了昔日的辉煌。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e30592f457243dfb117be9aead996a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7b8a0dbafa15c8cc95ae130f3fe5608/" rel="bookmark">
			6-1 大整数求和（运算符重载）DeBug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; /* 请在这里填写答案 */ class BigInt{ public: string num; BigInt() {} BigInt(string nu) {num=nu;} friend ostream&amp; operator &lt;&lt;(ostream&amp; output,BigInt&amp;t); friend istream&amp; operator &gt;&gt;(istream&amp; input,BigInt&amp;t); friend BigInt operator + (BigInt&amp; r1,BigInt&amp; q1); }; void reverse(string&amp;r); void reverse(string&amp;r) { int len=r.size(); char c; for(int i=0;i&lt;len/2;i++) { c=r[i]; r[i]=r[len-i-1]; r[len-i-1]=c; } } BigInt operator + (BigInt&amp; r1,BigInt&amp; q1) { int l1,l2,i,k; char c; string r,q; char add[100]; add[0]='0'; r=r1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7b8a0dbafa15c8cc95ae130f3fe5608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab234ac895a540e09372ee36f951157/" rel="bookmark">
			Java集合类总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 List ArrayList：jdk1.2 使用 Ojbect[] 数组来存储数据，list当前大小通过变量size来记录扩容系数为1.5倍默认容量为10，使用无参构造函数初始化，内部数组指向DEFAULTCAPACITY_EMPTY_ELEMENTDATA，扩容时为15使用带参构造函数初始化指定容量为0，内部数组指向EMPTY_ELEMENTDATA，扩容时为1增删时都调用System.arraycopy函数指定初始容量初始化时，会初始化Object[]数组，但size仍为0，所以size()函数仍返回0，且set()函数会抛异常，必须进行add操作size才会变化 Verctor：jdk1.0 使用Object[]数组来存储数据，elementCount记录当前大小初始化时可指定扩容增长的固定值capacityIncrement，若固定值为0，则在扩容时，固定值动态为扩容前数据的大小，即认定扩容系数为2倍默认容量10内部所有关键方法都加了synchronized可以保证关键方法单独调用是线程安全，但若存在多个线程同时组合调用同一个方法，仍可能不安全，比如删除最后一个元素remove(size() - 1)，可能发生下标越界 LinkedList：jdk1.2 同时实现了List、Deque接口，所以可以拿来当成【数组、队列、栈】使用底层为双向链表结构，保存链表的头、尾节点，first、last指针，通过size变量记录长度 Map HashMap：jdk1.2 jdk1.8以前底层结构为数组+链表，jdk1.8及其以后为数组+链表+红黑树jdk1.8，数组为Node数组，链表与红黑树共用Node数据结构Node数组大小永远为2的N次方，默认大小为16，扩容的负载因子默认0.75哈希冲突的概率符合泊松分布，当负载因子在7~8时，冲突概率极低哈希值计算：先散列 hashCode(key) &gt;&gt;&gt; 16 ^ hashCode(key) ，将key的hashcode码的高16位与低16位进行【异或】运算；将散列后的值与【数组长度 - 1】做【与】运算当size达到当前容量与负载因子的乘积后，就扩容两倍，同时将原数组的Node复制到扩容后的数组，因为在旧数组（长度记为n）中同一下标的哈希值低【n - 1】位是相同的，扩容后需计算低【n】位，所以对同一下标的Node采用高位、低位链按第n位的值来划分key为null的永远在数组第0个下标上当链表长度为8时，若size小于64，就先进行一次扩容，扩容后将链表转红黑树当红黑树长度小于6时，退化为链表jdk1.7链表插入采用头插法，多线程下会造成环，jdk1.8改为尾插法jdk1.8不是线程安全的，会出现put覆盖 LinkedHashMap：jdk1.4 继承自HashMap，内部同时使用Entry扩展HashMap.Node结构，增加after、before指针信息来维护所有Node的插入顺序，形成一个双向链表内部保留head、tail两个指针，指向双向链表的头尾节点内部增加accessOrder标志位，false代表按插入顺序访问；true代表按最近访问顺序，最近访问的节点越靠近tail，越久没访问的节点约靠近head可用来实现LRU，设置accessOrder为true，并重写removeEldestEntry方法，return size() &gt; capacity TreeMap：jdk1.2 内部维护一个Entry节点，Entry结构包括key、value、left、right、parent、color由此可以看出其底层结构为一颗红黑树，同时与HashMap的区别在于，TreeMap间接实现了SortedMap接口，即key是有序的 HashTable：jdk1.0 底层维护数组+链表数组默认长度11，扩容时大小为2倍 + 1，并头插所有对外方法均使用sychronized修饰key或value不允许为null哈希冲突比hashmap严重 Set HashSet：jdk1.2 内部存储一个HashMap对象，仅使用map的key来存储元素，value一律应用内部定义的Present对象迭代是无序的 TreeSet：jdk1.2 底层默认使用TreeMap来初始化，内部通过NavigableMap来持有初始化时的TreeMap引用与HashSet类型，TreeMap的value一律应用内部定义的Present对象因为NavigavleMap继承了SortedMap，所以是有序的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969d000c9fe3cfe5a758630275938bb0/" rel="bookmark">
			6-3 客货两用车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错： 解决：使用虚基类 #include &lt;iostream&gt; using namespace std; /* 你提交的代码将被嵌在这里 */ /* 你提交的代码将被嵌在这里 */ // 类为汽车类，是公共基类，提供汽车的基本功能。包括： // 一个保护数据成员：speed(速度)。 // 两个公有成员函数：构造函数(初始化速度)和Show函数(显示速度)。 class CAR{ protected: double speed; public: CAR(double sp) :speed(sp) {cout&lt;&lt;"创建汽车("&lt;&lt;this-&gt;speed&lt;&lt;"公里/小时)"&lt;&lt;endl;} virtual void Show()const {cout&lt;&lt;"汽车: "&lt;&lt;this-&gt;speed&lt;&lt;"公里/小时"&lt;&lt;endl;} }; // BUS类为客车类，以公有方式继承CAR类，在汽车类的基础上增加客运功能。包括： // 一个保护数据成员：seat(载客量)。 两个公有成员函数：构造函数(初始化速度和载客量)和Show函数(显示速度和载客量)。 class BUS:virtual public CAR{ protected: int seat; public: BUS(double sp,int se) :CAR(sp),seat(se) { cout&lt;&lt;"创建客车("&lt;&lt;this-&gt;seat&lt;&lt;"人)"&lt;&lt;endl; } virtual void Show()const {cout&lt;&lt;"客车: "&lt;&lt;this-&gt;speed&lt;&lt;"公里/小时, "&lt;&lt;this-&gt;seat&lt;&lt;"人"&lt;&lt;endl;} }; // TRUCK类为货车类，以公有方式继承CAR类，在汽车类的基础上增加货运功能。包括： // 一个保护数据成员：load(载货量)。 两个公有成员函数：构造函数(初始化速度和载货量)和Show函数(显示速度和载货量)。 class TRUCK:virtual public CAR{ protected: double load; public: TRUCK(double sp,double lo) :CAR(sp),load(lo) { cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/969d000c9fe3cfe5a758630275938bb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819f4db9985eb6a6bf735264f8489be5/" rel="bookmark">
			引用与指针的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.引用和指针 指针:指针就是内存地址,指针变量是用来存放内存地址的变量.不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。
引用:引用不是新定义一个变量,而是给已存在变量取一个别名,编译器不会为引用变量开辟内存空间,它和它引用的变量共用同一块内存空间.
类型&amp; 引用变量名= 引用实体; 且引用类型必须和引用实体是同种类型的.
引用的主要用途是:修饰函数的形参和返回值.
在C++语言中,函数的参数和返回值的传递方式有三种:值传递,指针传递和引用传递.引用具有指针的效率,又具有变量使用的方便性和直观性.
实际上引用可以做的事,指针都可以做,为什么还要引用呢?
引用体现了最小特权原则,即给予程序元素完成其功能的最小权限. 指针能够毫无约束的操作内存中的任何东西,尽管功能强大,但是非常危险.
二.引用与指针的区别 初始化:引用在定义时必须初始化,指针则没有要求(尽量初始化,防止野指针)引用在初始化引用一个实体后,就不能再引用其它实体,而指针可以在任意时候指向一个同类型实体没有NULL引用,但是有nullptr指针在sizeof中含义不同: 引用结果为引用类型的大小,但指针始终是地址空间,所占字节个数(32位平台占4个字节)引用自加即引用的实体增加1,指针自加即指针向后偏移一个类型的大小有多级指针,但没有多级引用访问实体的方式不同,指针需要显式解引用,引用编译器自己处理引用比指针使用起来相对安全 三.引用的底层原理 在语言层面,引用的用法和对象一样.在二进制层面,引用一般都是通过指针来实现的,只不过编译器帮我们完成了转换.
可以通过定义引用和指针变量进行调试观察:
int main() { int a = 10; int *p1 = &amp;a; int&amp; p2 = a; return 0; } 通过编译器调试观察反汇编语言发现,引用和指针的反汇编语言是一样的(编译器帮我们将我们完成了转换).
底层实现:引用通过指针实现 (定义一个引用类型的变量相当于定义于一个指针类型的变量)
语法: 引用是别名,不是指针,没有发生拷贝(目前可以认为引用是指针的一层封装,更加简单化的指针)
注意:在语法概念上,引用就是一个别名,没有独立空间,和其引用实体共用同一块空间.但是在底层实现上实际是有空间的,因为引用是按照指针方式来实现的.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08346efb7d01e5ec92609d2f758265ff/" rel="bookmark">
			python 字典和列表嵌套用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中字典和列表的使用，在数据处理中应该是最常用的，这两个熟练后基本可以应付大部分场景了。不过网上的基础教程只告诉你列表、字典是什么，如何使用，很少做组合说明。
刚好工作中采集prometheus监控接口并做数据处理的时候，用了很多组合场景，列出几个做一些分享。
列表(List) 序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。
列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。
列表的数据项不需要具有相同的类型
特点就是：可重复，类型可不同
常用方式 创建一个列表，只要把逗号分隔的不同数据项使用方括号括起来即可。如下所示：
list1 = ['apple', 'banana', 2008, 2021] list2 = [1, 2, 3, 4, 5 ] list3 = ["a", "b", "c", "d"] ### 向list中增加元素 list1.append(3) ## ['apple', 'banana', 2008, 2021, 3] ### 使用extend用来连接list list1.extend([7, 8]) ##['apple', 'banana', 2008, 2021, 3, 7, 8] ### insert 将单个元素插入到list中 list3.insert(2, 'q') ##['a', 'b', 'q', 'c', 'd'] ### 获取列表的长度 print(len(list1)) ## 5 ### 遍历list for name in list1: print(name) extend(扩展)与append(追加)的看起来类似，但实际上完全不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08346efb7d01e5ec92609d2f758265ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b37eb629f6d87cd609b52ae32ce81938/" rel="bookmark">
			【Verilog 编程】基于FPGA的VGA字符显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、VGA介绍二、实验过程记录2.1 建立新工程2.2 新建verilog文件2.3 保存文件并编译2.4 配置管脚2.5 连接开发板并下载 三、总结 一、VGA介绍 VGA 的全称是 Video Graphics Array，即视频图形阵列，是一个使用模拟信号进行视频传输的标准。
早期的 CRT 显示器由于设计制造上的原因，只能接收模拟信号输入，因此计算机内部的显卡负责进行数模转换，而 VGA 接口就是显卡上输出模拟信号的接口。
如今液晶显示器虽然可以直接接收数字信号，但是为了兼容显卡上的 VGA 接口，也大都支持 VGA 标准。
详细内容见VGA百度百科
二、实验过程记录 2.1 建立新工程 这一步做过很多次了，详细步骤见我之前的博客
【Quartus-ll 】 D 触发器功能仿真及时序波形仿真的三种实现方式
2.2 新建verilog文件 点击【File】→【New…】
选择【Verilog HDL File】，然后点击【OK】
代码如下：
module VGA_test( OSC_50, //原CLK2_50时钟信号 VGA_CLK, //VGA自时钟 VGA_HS, //行同步信号 VGA_VS, //场同步信号 VGA_BLANK, //复合空白信号控制信号 当BLANK为低电平时模拟视频输出消隐电平，此时从R9~R0,G9~G0,B9~B0输入的所有数据被忽略 VGA_SYNC, //符合同步控制信号 行时序和场时序都要产生同步脉冲 VGA_R, //VGA绿色 VGA_B, //VGA蓝色 VGA_G); //VGA绿色 input OSC_50; //外部时钟信号CLK2_50 output VGA_CLK,VGA_HS,VGA_VS,VGA_BLANK,VGA_SYNC; output [7:0] VGA_R,VGA_B,VGA_G; parameter H_FRONT = 16; //行同步前沿信号周期长 parameter H_SYNC = 96; //行同步信号周期长 parameter H_BACK = 48; //行同步后沿信号周期长 parameter H_ACT = 640; //行显示周期长 parameter H_BLANK = H_FRONT+H_SYNC+H_BACK; //行空白信号总周期长 parameter H_TOTAL = H_FRONT+H_SYNC+H_BACK+H_ACT; //行总周期长耗时 parameter V_FRONT = 11; //场同步前沿信号周期长 parameter V_SYNC = 2; //场同步信号周期长 parameter V_BACK = 31; //场同步后沿信号周期长 parameter V_ACT = 480; //场显示周期长 parameter V_BLANK = V_FRONT+V_SYNC+V_BACK; //场空白信号总周期长 parameter V_TOTAL = V_FRONT+V_SYNC+V_BACK+V_ACT; //场总周期长耗时 reg [10:0] H_Cont; //行周期计数器 reg [10:0] V_Cont; //场周期计数器 wire [7:0] VGA_R; //VGA红色控制线 wire [7:0] VGA_G; //VGA绿色控制线 wire [7:0] VGA_B; //VGA蓝色控制线 reg VGA_HS; reg VGA_VS; reg [10:0] X; //当前行第几个像素点 reg [10:0] Y; //当前场第几行 reg CLK_25; always@(posedge OSC_50) begin CLK_25=~CLK_25; //时钟 end assign VGA_SYNC = 1'b0; //同步信号低电平 assign VGA_BLANK = ~((H_Cont&lt;H_BLANK)||(V_Cont&lt;V_BLANK)); //当行计数器小于行空白总长或场计数器小于场空白总长时，空白信号低电平 assign VGA_CLK = ~CLK_to_DAC; //VGA时钟等于CLK_25取反 assign CLK_to_DAC = CLK_25; always@(posedge CLK_to_DAC) begin if(H_Cont&lt;H_TOTAL) //如果行计数器小于行总时长 H_Cont&lt;=H_Cont+1'b1; //行计数器+1 else H_Cont&lt;=0; //否则行计数器清零 if(H_Cont==H_FRONT-1) //如果行计数器等于行前沿空白时间-1 VGA_HS&lt;=1'b0; //行同步信号置0 if(H_Cont==H_FRONT+H_SYNC-1) //如果行计数器等于行前沿+行同步-1 VGA_HS&lt;=1'b1; //行同步信号置1 if(H_Cont&gt;=H_BLANK) //如果行计数器大于等于行空白总时长 X&lt;=H_Cont-H_BLANK; //X等于行计数器-行空白总时长 （X为当前行第几个像素点） else X&lt;=0; //否则X为0 end always@(posedge VGA_HS) begin if(V_Cont&lt;V_TOTAL) //如果场计数器小于行总时长 V_Cont&lt;=V_Cont+1'b1; //场计数器+1 else V_Cont&lt;=0; //否则场计数器清零 if(V_Cont==V_FRONT-1) //如果场计数器等于场前沿空白时间-1 VGA_VS&lt;=1'b0; //场同步信号置0 if(V_Cont==V_FRONT+V_SYNC-1) //如果场计数器等于行前沿+场同步-1 VGA_VS&lt;=1'b1; //场同步信号置1 if(V_Cont&gt;=V_BLANK) //如果场计数器大于等于场空白总时长 Y&lt;=V_Cont-V_BLANK; //Y等于场计数器-场空白总时长 （Y为当前场第几行） else Y&lt;=0; //否则Y为0 end reg valid_yr; always@(posedge CLK_to_DAC) if(V_Cont == 10'd32) //场计数器=32时 valid_yr&lt;=1'b1; //行输入激活 else if(V_Cont==10'd512) //场计数器=512时 valid_yr&lt;=1'b0; //行输入冻结 wire valid_y=valid_yr; //连线 reg valid_r; always@(posedge CLK_to_DAC) if((H_Cont == 10'd32)&amp;&amp;valid_y) //行计数器=32时 valid_r&lt;=1'b1; //像素输入激活 else if((H_Cont==10'd512)&amp;&amp;valid_y) //行计数器=512时 valid_r&lt;=1'b0; //像素输入冻结 wire valid = valid_r; //连线 wire[10:0] x_dis; //像素显示控制信号 wire[10:0] y_dis; //行显示控制信号 assign x_dis=X; //连线X assign y_dis=Y; //连线Y parameter //点阵字模：每一行char_lineXX是显示的一行，共272列 char_line00=272'hFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF, //第1行 char_line01=272'h00000000000000000000000000000000000000000000000000000000000000000000, //第2行 char_line02=272'h00400C0000000000000000000000000000C008000000000000000000000000000000, //第3行 char_line03=272'h00700E0000000180000000000000000000E00C0000000000000000800180000000C0, //第4行 char_line04=272'h00600C00000003C0000000000000000000C01C0000000000000000FFFF80000001E0, //第5行 char_line05=272'h00600C3003FFFC000000000000000080008018000000000000800080018003FFFE00, //第6行 char_line06=272'h1FFFFFF8000180007FFE7FF003C80380008018007C1F03C803800080018000000000, //第7行 char_line07=272'h00600C0000018000180E18180E3803800104301018040E3803800080018000000000, //第8行 char_line08=272'h00600C00000180001802180C080803800FFE30381804080803800080018000000000, //第9行 char_line09=272'h00600C000001800018031806180802800C0C7FF818041808028000FFFF8000000000, //第10行 char_line0a=272'h007FFC000001800018011806300406C00C0C60300C08300406C00080018000000000, //第11行 char_line0b=272'h00600C000001800018001806300404C00C0CC0300C08300404C00080018000000018, //第12行 char_line0c=272'h00600C000001801018081806200004C00C0C80300C08200004C0008001800000003C, //第13行 char_line0d=272'h007FFC000001803818081806600004C00C0D00300C08600004C0008001803FFFFFFE, //第14行 char_line0e=272'h00600C003FFFFFFC1818180C60000C600C0D4030061060000C6000FFFF8000018000, //第15行 char_line0f=272'h00600C10000180001FF81818600008600C0E20300610600008600080010000018000, //第16行 char_line10=272'h00600C380001800018181FF0600008600C0C10300610600008600008200000418000, //第17行 char_line11=272'h3FFFFFFC0001800018081800600008600FFC1830073060000860000C382000718800, //第18行 char_line12=272'h003208000001800018081800603F1FF00C0C18300320603F1FF0080C307000E18600, //第19行 char_line13=272'h00618C000001800018001800600C10300C0C0C300320600C10300C0C307000C18300, //第20行 char_line14=272'h00C106000001800018001800600C10300C0C08300320600C1030060C30C001818180, //第21行 char_line15=272'h018101C00001800018001800300C10300C0C003001C0300C1030030C30C0038180C0, //第22行 char_line16=272'h030104FC0001800018001800300C30300C0C003001C0300C3030038C318003018060, //第23行 char_line17=272'h0C010E380001800018001800180C20180C0C003001C0180C2018018C330006018070, //第24行 char_line18=272'h187FF0000001800018001800180C20180C0C003001C0180C2018018C36000C018038, //第25行 char_line19=272'h6001000000018000180018000C1060180C0C003000800C106018008C380018018038, //第26行 char_line1a=272'h00010000000180007E007E0003E0F83E0C0C0030008003E0F83E000C301010018010, //第27行 char_line1b=272'h00010000003F800000000000000000000FFC0C60000000000000000C303820738000, //第28行 char_line1c=272'h00010060000F800000000000000000000C0C03E00000000000001FFFFFFC001F8000, //第29行 char_line1d=272'h1FFFFFF00007000000000000000000000C0801C00000000000000000000000070000, //第30行 char_line1e=272'h00000000000000000000000000000000000000800000000000000000000000020000, //第31行 char_line1f=272'h00000000000000000000000000000000000000000000000000000000000000000000; //第32行 reg[8:0] char_bit; always@(posedge CLK_to_DAC) if(X==10'd144)char_bit&lt;=9'd272; //当显示到144像素时准备开始输出图像数据 else if(X&gt;10'd144&amp;&amp;X&lt;10'd416) //左边距屏幕144像素到416像素时 416=144+272（图像宽度） char_bit&lt;=char_bit-1'b1; //倒着输出图像信息 reg[29:0] vga_rgb; //定义颜色缓存 always@(posedge CLK_to_DAC) if(X&gt;10'd144&amp;&amp;X&lt;10'd416) //X控制图像的横向显示边界：左边距屏幕左边144像素 右边界距屏幕左边界416像素 begin case(Y) //Y控制图像的纵向显示边界：从距离屏幕顶部160像素开始显示第一行数据 10'd160: if(char_line00[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; //如果该行有数据 则颜色为红色 else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; //否则为黑色 10'd162: if(char_line01[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd163: if(char_line02[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd164: if(char_line03[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd165: if(char_line04[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd166: if(char_line05[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd167: if(char_line06[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd168: if(char_line07[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd169: if(char_line08[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd170: if(char_line09[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd171: if(char_line0a[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd172: if(char_line0b[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd173: if(char_line0c[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd174: if(char_line0d[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd175: if(char_line0e[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd176: if(char_line0f[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd177: if(char_line10[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd178: if(char_line11[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd179: if(char_line12[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd180: if(char_line13[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd181: if(char_line14[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd182: if(char_line15[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd183: if(char_line16[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd184: if(char_line17[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd185: if(char_line18[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd186: if(char_line19[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd187: if(char_line1a[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd188: if(char_line1b[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd189: if(char_line1c[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd190: if(char_line1d[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd191: if(char_line1e[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; 10'd192: if(char_line1f[char_bit])vga_rgb&lt;=30'b1111111111_0000000000_0000000000; else vga_rgb&lt;=30'b0000000000_0000000000_0000000000; default:vga_rgb&lt;=30'h0000000000; //默认颜色黑色 endcase end else vga_rgb&lt;=30'h000000000; //否则黑色 assign VGA_R=vga_rgb[23:16]; assign VGA_G=vga_rgb[15:8]; assign VGA_B=vga_rgb[7:0]; endmodule 代码分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b37eb629f6d87cd609b52ae32ce81938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95ece637f57eb3f30c04edbd6a5d69c/" rel="bookmark">
			【机器学习】有关凸优化的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、计算几何是研究什么的？2、计算几何理论中（或凸集中）过两点的一条直线的表达式，是如何描述的？与初中数学中那些直线方程有什么差异？有什么好处？(按自己的体会)3、凸集是什么？ 直线是凸集吗？是仿射集吗？4、三维空间中的一个平面，如何表达？5、更高维度的“超平面”，如何表达？6、什么是“凸函数”定义？什么是Hessian Matrix 矩阵? 如何判别一个函数是凸函数？f(x)=x^3 函数是凸函数吗？7、什么是“凸规划”？如何判别一个规划问题是凸规划问题。下例是凸规划问题吗？8、 总结 1、计算几何是研究什么的？ 计算几何研究几何模型和数据处理的学科，讨论几何形体的计算机表示、分析和综合，研究如何方便灵活、有效地建立几何形体的数学模型以及在计算机中更好地存贮和管理这些模型数据。
2、计算几何理论中（或凸集中）过两点的一条直线的表达式，是如何描述的？与初中数学中那些直线方程有什么差异？有什么好处？(按自己的体会) 计算几何理论中（或凸集中）
且为n维空间的两个点则：
初中数学中
直线的两点式方程推导过程：
（1）设直线l上的两点P1、P2的坐标分别为(x1,y1)、(x2,y2)，且(x1≠x2)
所以直线l的斜率
（2）在直线l上任意取一点P（x，y）
将直线l的斜率K，P点的坐标代入直线的点斜式方程y-y0=k(x-x0)中得
即
为直线 l 的两点式方程。两者好处对比
3、凸集是什么？ 直线是凸集吗？是仿射集吗？ 凸集是什么
在凸几何中
凸集(convex set)是在凸组合下闭合的仿射空间的子集
更具体地说，在欧氏空间中
凸集是对于集合内的每一对点，连接该对点的直线段上的每个点也在该集合内。例如，立方体是凸集，但是任何中空的或具有凹痕的例如月牙形都不是凸集。直线是凸集吗
根据凸集定义，直线是凸集。是仿射集吗
仿射集亦称仿射流形、线性流形、仿射簇，是实线性空间中的一类子集。非空间射集 M 的维数定义为上述子空间 L 的维数。空集的维数定义为-1。维数分别为0、1，以及2的仿射集为点、直线和平面。
根据仿射集定义，当维数为1的仿射集为直线。 4、三维空间中的一个平面，如何表达？ 平面 Ax+By+Cz+D = 0 的法向量就是 x、y、z 的系数，也即（A，B，C）。
5、更高维度的“超平面”，如何表达？ 高维度超平面的定义
(1) 超平面是指n维线性空间中维度为n-1的子空间。它可以把线性空间分割成不相交的两部分。比如二维空间中，一条直线是一维的，它把平面分成了两块；三维空间中，一个平面是二维的，它把空间分成了两块。
(2) 法向量是指垂直于超平面的向量。
在
空间中，假如有法向量
过原点的平面内任意原点出发的向量x必然与之满足
如果平面沿着法向量的方向上下平移了，那么这个方程就不成立了。
我们假设平移之后平面经过
平面内任意一点记为 法向量记为
如下图。
不难看出，
在平面内，当然也就和法向量垂直。于是我们有：
化简后得：
即
由于其为常数项，令
于是超平面的公式可以写成：
这个结论同样适用于
空间；
无论超平面如何平移，系数始终是法向量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a95ece637f57eb3f30c04edbd6a5d69c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22f7ab596c3753479625190d77b4a666/" rel="bookmark">
			解决vue3.0中语法检出出现any等问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.解决在setup中使用props时出现如下图
出现上面问题可以找到tsconfig.json文件里面的
“strict”: true,
这个代码改成false
“strict”: false
这个问题就可以解决…
2.解决出现any语法等问题,找到tsconfig.json文件里面的
"noImplicitAny"参数,如果没有就自己创建,
然后设置
“noImplicitAny”: false
就可以解决出现any等的一些问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1499fd471a67031469614bfdb09e1903/" rel="bookmark">
			LPWAN——Sigfox实战经验介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.序 最近半年的时间一直在从事这方面的开发工作，到目前为止对于Sigfox有一定想法和经验，同时目前国内对于该技术的使用和应用还处在刚刚起步的阶段，很多博客对Sigfox的讲解是一个浅尝辄止的介绍，因此在很多时候的入门是一个及其不方便的过程，因此在这里做一些总结和分享。
2018年1月，在法国总统马克龙访华期间，Sigfox曾联合中国联通、法国KRG智慧养老公司与成都高新区宣布共同建设运营成都国际智慧养老服务示范社区，发展老人监护应用方案。
如有不足，欢迎各位在评论区指出探讨。
1.低功耗物联网及Sigfox背景介绍 1.1 LPWAN介绍 随着5G的逐渐成为一个越来越热的通信方式，其“对立面”——低功耗广域网络（LPWAN）也逐渐被广泛的应用。5G意味着更大的带宽，更快的数据传输速率以及更大的数据吞吐量，但与之对应的就是更高的成本，更多的对频谱资源的占用，和对空中无线资源的占用。而在很多时候往往不需要如此高的数据传输量，尤其是不需要如此高的成本，以Sigfox为例，其一套成熟的通信模块的BOM成本大约在3——5美金左右，在5G应用中，光一个基带芯片的成本就远高于此。
例如在智慧城市，智慧道路，智慧医疗，智慧物流等很多领域，往往不需要音频、视频等数据的传输，其传输的往往是终端传感器中所采集的数据以及一些简单的对数据的分析（这并非意味着这种情况就无法做大数据的分析，这些简单的终端数据通过无线的方式传输到基站，最终到达系统端，而系统主站可以对这些数据进行及其详尽的大数据的分析）。
由此可见LPWAN和5G这两种无线通信类型将在物联网这个大的世界中扮演着各自的角色，并最终都将汇合在万物互联的尽头。
1.2 Sigfox背景简介 Sigfox是由Sigfox公司所提出的一种通信网络，2009年成立于法国，该技术是一种连接低功耗设备的无线网络，主要用于低功耗物联网，这类应用需要连续地发送少量的数据。Sigfox希望建立第一个仅供用于物联网的全球蜂窝连接的公司，其基础设施完全独立于现有的网络（如电信移动网络）。
由于物联网连接使用低数据速率，Sigfox网络利用了超窄带，UNB技术。传输功耗水平非常低，而仍然能维持一个稳定的数据连接。Sigfox无线链路使用免授权的ISM射频频段。Sigfox网络中单元的密度(基于平均距离)，在农村地区大约30-50km，在城市中常有更多的障碍物和噪声距离可能减少到3-10km之间。整个Sigfox网络拓扑是一个可扩展的、高容量的网络，具有非常低的能源消耗，同时保持简单和易于部署的基于星型单元的基础设施。
以上的关于Sigfox的介绍是目前国内最常见的对Sigfox的简介，事实上，目前Sigfox的最主要的优势在于基于Sigfox可以实现终端设备与云端的直接连接，而避免了终端用户与运营商过多的沟通，极大地降低了终端客户这一部分的成本。由Sigfox公司与各地运营商进行协调，同时Sigfox公司将终端的硬件设备与芯片供应商合作，由终端芯片商提供底层的软硬件研发并形成库，而最终的终端用户只需基于这些库进行二次开发。Sigfox则通过系统后台和云端运营，从而实现盈利。
2. Sigfox无线通信介绍 Sigfox是连接传感器和设备的低成本，可靠，低功耗的解决方案。
Sigfox协议着重于：
Autonomy：极低的能耗，可确保多年的电池寿命。
Simplicity：不需要配置、连接请求。终端设备在几分钟之内即可启动并运行。
Cost efficiency：从设备中使用的硬件到我们的网络，Sigfox公司对每个步骤进行优化，以尽可能提高成本效益。
Small messages：网络中不会发送大数据量的媒体数据（例如音频、视频等），只有小的payload：最多12个字节。
Complementarity：由于其低成本和易于配置，因此还可以将Sigfox用作任何其他类型网络的辅助解决方案，例如：Wi-Fi，蓝牙，GPRS等。
2.1 Sigfox不同 RC的介绍 上图所示的为Sigfox目前在全球的网络部署的情况，实际上可以看到，目前Sigfox的部署主要集中在欧美地区及太平洋地区，而亚洲则主要有印度、日本、中国台湾地区等。
（顺便说一句，Sigfox官网中的用户注册页面令人很舒适）
Sigfox目前基于不同地区对于无线电频段的要求分为6个频段（RC）：
RC1：奥地利，比利时，保加利亚，克罗地亚，捷克共和国，丹麦，爱沙尼亚，芬兰，法国，德国，匈牙利，爱尔兰，意大利，拉脱维亚，列支敦士登，立陶宛，卢森堡，马耳他，荷兰，挪威，波兰，葡萄牙，罗马尼亚，塞尔维亚，斯洛伐克，斯洛文尼亚，西班牙，瑞典，瑞士，英国，法属圭亚那，法属波利尼西亚，瓜德罗普岛，马提尼克岛，毛里求斯，马约特岛，新喀里多尼亚，留尼汪岛，博茨瓦纳，肯尼亚，尼日利亚，阿曼，南非，斯威士兰，突尼斯，阿拉伯联合酋长国。
RC2：巴西，加拿大，墨西哥，波多黎各，美国。
RC3：日本。
RC4：阿根廷，智利，哥伦比亚，哥斯达黎加，厄瓜多尔，萨尔瓦多，危地马拉，洪都拉斯，尼加拉瓜，巴拿马，秘鲁，特立尼达和多巴哥，乌拉圭。澳大利亚，香港，印度尼西亚，马来西亚，新西兰，新加坡，台湾，泰国。
RC5：韩国。
RC6：印度。
事实上，为了保证Sigfox在不同的地区中都能够进行无线通信，Sigfox需要遵守当地的无线电通信的标准和要求，例如在欧洲地区的无线电设备指令（The Radio Equipment Directive,Red)2014\53\EU认证标准，在美洲地区的FCC认证等等。
因此也就产生了对于不同地区不同频段、上下行波特率以及EIRP等的标准，如下表所示。
–RC1RC2RC3RC4RC5RC6Uplink center frequency (MHz)868.130902.200923.200920.800923.300865.200Downlink center frequency (MHz)869.525905.200922.200922.300922.300866.300Uplink data rate (bit/s)100600100600100100Downlink data rate (bit/s)600600600600600600Sigfox recommended EIRP (dBm)162416241416 而除此之外，在不同的RC中，其上行的总带宽和下行的带宽事实上也是存在着很大的差异的，可能很多人都听说了Sigfox的超窄带技术，但是很多时候却没有对这个有明确的了解，事实上，如下表所示，在RC2和RC4中Sigfox的带宽是远大于192KHz的。
–RC1RC2RC3RC4RC5RC6Uplink low boundary868.030902.100923.100920.700923.200865.100Uplink high boundary868.230904.700923.300923.300923.400865.300Downlink low boundary869.425905.100922.100922.200922.200866.200Downlink high boundary869.625907.700922.300924.800922.400866.400 同时对于不同地区中还存在一些小的对于无线电通信的标准的要求，Sigfox也做出了对应的解决方案。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1499fd471a67031469614bfdb09e1903/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4fbe96d20d9f98923c3e205e2cf863/" rel="bookmark">
			Linux 软件 缺少库查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、使用ldd 命令查询软件缺少的库
[root@www lib64]# ldd /itron/tup/tools/EG700u/dtools linux-vdso.so.1 =&gt; (0x00007ffcf0d7e000) libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f0aecd5b000) libQt5Qml.so.5 =&gt; /itron/tup/tools/EG700u/lib/libQt5Qml.so.5 (0x00007f0aec8b0000) libQt5SerialPort.so.5 =&gt; /itron/tup/tools/EG700u/lib/libQt5SerialPort.so.5 (0x00007f0aed322000) libQt5Network.so.5 =&gt; /itron/tup/tools/EG700u/lib/libQt5Network.so.5 (0x00007f0aed171000) libQt5Xml.so.5 =&gt; /itron/tup/tools/EG700u/lib/libQt5Xml.so.5 (0x00007f0aec875000) libQt5Core.so.5 =&gt; /itron/tup/tools/EG700u/lib/libQt5Core.so.5 (0x00007f0aec2c3000) libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f0aebf47000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00007f0aebd31000) /lib64/ld-linux-x86-64.so.2 (0x00007f0aed129000) libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f0aebb15000) libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f0aeb911000) libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f0aeb60f000) libudev.so.1 =&gt; /lib64/libudev.so.1 (0x00007f0aeb3f9000) libz.so.1 =&gt; /lib64/libz.so.1 (0x00007f0aeb1e3000) libicui18n.so.55 =&gt; /lib64/libicui18n.so.55 (0x00007f0aead81000) libicuuc.so.55 =&gt; not found libglib-2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4fbe96d20d9f98923c3e205e2cf863/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8797f81e5a802b1f36a07e0a09c6fb62/" rel="bookmark">
			数字签名和数字证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本密码学知识 1、加密方法可以分为两大类：
一类是单钥加密（private key cryptography），还有一类叫做双钥加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。
历史上，人类传统的加密方法都是前一种，比如二战期间德军用的Enigma电报密码。莫尔斯电码也可以看作是一种私钥加密方法。在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。
在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。
目前，通用的单钥加密算法为DES（Data Encryption Standard），通用的双钥加密算法为RSA（ Rivest-Shamir-Adleman），都产生于上个世纪70年代。
2、双钥加密的原理如下：
a) 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。
b) 所有的（公钥, 私钥）对都是不同的。
c) 用公钥可以解开私钥加密的信息，反之亦成立。
d) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。
在双钥体系中，公钥用来加密信息，私钥用来数字签名。
3、数字证书颁发原因：
因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。目前，世界上最主要的数字服务认证商是位于美国加州的Verisign公司，它的主要业务就是分发RSA数字证书。
数字签名和数字证书 “数字签名”（digital signature）和"数字证书"（digital certificate）
参考网址：http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html
1、鲍勃有两把钥匙，一把是公钥，另一把是私钥。
2、鲍勃把公钥送给他的朋友们----帕蒂、道格、苏珊----每人一把。
情境一：
3、苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。
4、鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。
情景二：
（鲍勃回信，收信人需要确定两点：1、信确实是鲍勃发的；2、信的内容没有被改过）
5、鲍勃给苏珊回信，决定采用"数字签名"。他写完后先用Hash函数，生成信件的摘要（digest）。
6、然后，鲍勃使用私钥，对这个摘要加密，生成"数字签名"（signature）。
7、鲍勃将这个签名，附在信件下面，一起发给苏珊。
8、苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。
9、苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。
情境三
（如果有人在情境二的情况下，用自己的公钥替换了鲍勃的公钥，可以在苏珊不知道的情况下，冒充鲍勃给苏珊发信。因此，苏珊作为收信人还需要确定一点：自己手中的公钥确实是鲍勃的，确定公钥是没有被人替换的）
10、复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成"数字签名"，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。
11、后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找"证书中心"（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate）。
12、鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。
13、苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明"数字签名"是否真的是鲍勃签的。
（这就相当于苏珊不自己拥有鲍勃的公钥，通过第三方机构来间接获取鲍勃的公钥，因为第三方机构对鲍勃的公钥进行了加密，虽然人人都可以使用第三方机构的公钥对数字证书解密，却没办法再替换数字证书中鲍勃的公钥，因为对鲍勃的公钥加密只能由拥有私钥的第三方机构完成。此时，收信人苏珊便可以确信自己解开数字证书后获得的公钥的确是鲍勃的，没有人能够冒充鲍勃了）。
实例：
14、下面，我们看一个应用"数字证书"的实例：https协议。这个协议主要用于网页加密。
15、首先，客户端向服务器发出加密请求。
16、服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。
17、客户端（浏览器）的"证书管理器"，有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。
18、如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。
19、如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。
20、如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2827f107ad650d869833f0d60667dbb4/" rel="bookmark">
			MyBatis-Plus 常用注解详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@TableName
@TableId
主键专属
比如数据中的表中的字段是id
但是实体类是userId
那么就需要在userId上打上这个注解
用法
设置主键映射 value映射主键字段的名字
type 设置主键类型 主键的生成策略 (圈起来的重要)
1 数据库自增 AUTO
开发者无需赋值,自己根据当前表中id最大值自增+1
手动赋值的话还是使用数据库id中最大值+1 的方式赋予id
2 自动生成主键 使用雪花算法 NONE
配合新增使用 用的时候需要注意主键长度 但是3.20的时候是采取该字段最大值+1
1.数据类型改int为long
2.数据库表的长度要改
需要注意生成的长度否则会报错
Caused by: org.apache.ibatis.reflection.ReflectionException:
Could not set property 'id' of 'class com.lin.mybatisplus.pojo.User'
with value '1289924709438889985' Cause: java.lang.IllegalArgumentException: argument type mismatch
然后还需要修改数据类型,才能存进去
3 开发者手动赋值 INPUT
如果插入操作中,没有对id进行赋值,那么存进数据库中的将为0(long)
数据库一般会采取自增id的方式处理 当前数据库编号的值+1
如果给定值了,就用给定的值
4 ASSIGN_ID
等同于ID_ WORKER(3) ,ID_ WORKER STR(3) ，
使用mp自动赋值 采取雪花算法,但是3.20的时候是采取该字段最大值+1
5 ASSIGN_ID
等同于UUID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2827f107ad650d869833f0d60667dbb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164fc596b4f465b5f0bcfa96b4f82644/" rel="bookmark">
			Polkit (简体中文)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		翻译状态：本文是 Polkit 的翻译。上次翻译日期：2018-10-21。如果英文版本有所更改，则您可以帮助同步翻译。
来自 polkit 主页：
polkit 是一个应用程序级别的工具集，通过定义和审核权限规则，实现不同优先级进程间的通讯：控制决策集中在统一的框架之中，决定低优先级进程是否有权访问高优先级进程。
Polkit 在系统层级进行权限控制，提供了一个低优先级进程和高优先级进程进行通讯的系统。和 sudo 等程序不同，Polkit 并没有赋予进程完全的 root 权限，而是通过一个集中的策略系统进行更精细的授权。
Polkit 定义出一系列操作，例如运行 GParted, 并将用户按照群组或用户名进行划分，例如 wheel 群组用户。然后定义每个操作是否可以由某些用户执行，执行操作前是否需要一些额外的确认，例如通过输入密码确认用户是不是属于某个群组。
Contents 1安装 1.1身份认证组件2配置 2.1操作2.2认证规则2.3管理员身份认证3范例 3.1调试/输出3.2禁用挂起和休眠3.3跳过口令提示 3.3.1全局规则3.3.2针对特定的动作设置3.3.3Udisks3.4允许一般用户管理某个 systemd 单元4参阅 安装 安装 polkit 包。
身份认证组件 Polkit 的权限管理是基于用户或群组进行配置，而身份认证组件的作用就是让会话用户证明自己是某个用户或属于某个群组。
图形化环境Cinnamon、Deepin、GNOME、GNOME Flashback、KDE、LXDE、LXQt、MATE、theShell 和 Xfce 各自都已有认证组件。请按照下列清单确认安装了对应的身份认证组件，并且在登录时 自动启动 它。
其他桌面环境需要从下列实现中选用一种，polkit 软件包提供了一个名为“pkttyagent”的基于文本方式的认证代理，作为后备方案。
lxqt-policykit，提供了 /usr/bin/lxqt-policykit-agentlxsession，提供了 /usr/bin/lxpolkitmate-polkit，提供了 /usr/lib/mate-polkit/polkit-mate-authentication-agent-1polkit-efl-gitAUR，提供了 /usr/bin/polkit-efl-authentication-agent-1polkit-gnome，提供了 /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1polkit-kde-agent，提供了 /usr/lib/polkit-kde-authentication-agent-1ts-polkitagentAUR, 提供了 /usr/lib/ts-polkitagentxfce-polkit-gitAUR，提供了 /usr/lib/xfce-polkit/xfce-polkit 配置 警告： 不要更改包文件的默认权限，因其可能在软件包更新时被覆盖。
Polkit 定义了两种不同的内容：
操作（Actions）：在 /usr/share/polkit-1/actions 中定义，文件是 XML 格式，以 .policy 结尾。每个操作都有一个默认的权限集合（例如，你需要标识为管理员以使用 GParted 操作）。默认值是可以修改的，但是不应该通过修改操作文件实现。认证规则（Authorization rules）：用 JavaScript 语法定义，文件以 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/164fc596b4f465b5f0bcfa96b4f82644/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bec029d1b2c0936945ba9642a148535/" rel="bookmark">
			旧电脑怎么升级到新版Win10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 10 2020年5月更新是最新版的win10系统，相比以往的win10有了许多的改进，比如说新的Cortana应用、云端重置以及Linux 2的Windows子系统等等。而Windows搜索的改进，也是大幅度降低了CPU的高占用。
1.旧电脑真的可以升级使用吗？ 示例图
其实，针对这个问题，微软官方表示，只要电脑兼容，那么随时可以下载并安装使用最新版win10。
下面就一起来看一下Windows 10 2020年5月更新最低系统要求！
1、内存：64位电脑为2GB内存，32位电脑为1GB内存 2、存储空间：64位系统为20GB的空闲空间，32位系统为16GB的空闲空间 3、屏幕分辨率：最低800×600 4、图形系统：微软DirectX 9或更高版本，需支持WDDM 1.0 5、处理器：支持从旧到新的几乎所有Intel/AMD处理器、高通CPU骁龙850和8cx 那么，确认了旧电脑的配置还是可以安装使用最新版win10的话，如何升级2020新版Win10？
2.升级2020新版Win10 需要更新的朋友，可以进入Windows更新设置页面进行操作：
同时按住“win+i”打开设置页面，依次点击“更新安全”-“Windows更新”，点击“检查更新”，一旦出现了更新页面，就可以选择下载和安装。 示例图
3.注意事项 1.Wind10更新需要较大的空间来完成安装过程。如果空间不足，就可能导致更新失败，出现不明的错误更新代码的。 2.2020新版win10是分阶段推出的，用户会分批次的收到官方通过更新。所以，朋友们有可能暂时没收到更新通知。
4.下载地址 如果实在是不想等了，也可以自己去微软官网下载Windows10 v2004镜像进行安装。
示例图
5.镜像安装操作 镜像文件下载完毕之后，制作一个U盘winpe，就可以自己安装最新的win10了
要是安装新版win10后，发现旧电脑无法流畅运行win10的话，还可以退而求其次，下载并安装win10 LTSC版，不到4G的安装包，安装后的体积也就10G左右。
Win10系统好不好用，试试就知道啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/939104052950bbdd1a87a501674ccee8/" rel="bookmark">
			sql server全文索引 contains 中文检索部分失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中使用了sql server2012的全文索引，在利用CONTAINS(“需要比较的内容”, “查找的内容”)时，如果查找的内容是中文，会出现部分中文存在，但就是无法查到的问题
// 例如: 数据库中添加全文索引的字段为 content，字段下的内容有以下数据 第一条： "12岁，你好，123456,15587656129"； 第二条： "14岁，你，241244,15587656187"； 第三条： "32岁，好，233456,15587651245"； 第四条： "22岁，你好啊，233656,15587661245" // sql 里面这样写应该是可以查出 内容里面带 '你好' 的数据，也就是第一条和第四条，但查询返回的结果却是空的 contains(content,'"你好*"') // 但sql里面要是这样写，却是可以查询出第一条、第三条和第四条的数据，说明代码本身是没有问题的 contains(content,'"好*"') 解决办法 经测试发现可能是sqlserver创建全文索引的 断字符语言选的有问题，更改断字符语言后成功解决此问题。
1、首先选中创建全文索引的表，然后 右键—》全文索引–》属性–》列
2、断字符语言选中 Chinese (Macau SAR)，默认为 Simplified Chinese
3、点击确定，然后再次查询就能查到结果了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6001db69a6e78e0dd22f90f778b7d9f5/" rel="bookmark">
			git总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git常用命令 git init git初始化 git clone 'address' 把项目克隆到本地	git branch	查看本地分支 git branch -a	查看所有分支（本地和远程） git branch -d dev_name 删除本地分支 git branch --set-upstream-to=origin/src_self dev_self 本地分支与远程分支建联 git fetch 将远程最新内容拉到本地 git pull 将远程最新内容拉到本地，并合并到本地分支 git log 查看历史提交记录 git diff &lt;fileName&gt;	比较文件的不同，即暂存区和工作区的差异 （fileName查询指定文件） git status 查看仓库当前的状态，显示有变更的文件 git add 添加文件到暂存区 （. 表示添加所有， fileName 添加指定文件） git commit -m "注释"	提交暂存区到本地仓库 git push 推送到远程分支 git merge name 将其他分支代码合并到当前分支 git reset	回退版本 git reset --soft HEAD^ 撤销一次commit （详情应用场景1） git remote show origin 查看当前版本库分支对应关系 应用场景 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6001db69a6e78e0dd22f90f778b7d9f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11a9da019cf9bc3da19ab5993169617/" rel="bookmark">
			计算机显示器桌面变小,不知道按了什么电脑屏幕变小了怎么办_电脑屏幕设置在哪儿 - 驱动管家...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电脑屏幕变小了怎么调?下文将演示电脑屏幕变小设置方法，不知道按了什么键，电脑屏幕就变小了，还能不能够设置回来呢?让我们通过下文来了解吧。
第一步、把鼠标移动到电脑桌面空白处，右键鼠标选择“属性”。
第二步、在弹出来的框点击“设置”，在屏幕分辨率哪里的滚动条“向左或向右移动”移动到你觉适合为止，再点击“应用”查看效果。
第三步、调到适合自己桌面的效果后再点击“确定”即可更改分辨率。
显示器一般常见的屏幕分辨率比例、估计现在使用 4:3、 5:4的应该会少点，多见的是16:9，分辨率如下：
5:4的屏幕适应分辨率为【800×640、1280×1024】等;4:3的屏幕适应分辨率为【800×600、1024×768、1280×960、1400×1050、1600×1200、2048×1536】等;16:10的屏幕适应分辨率为【1280×800、1440×900、1680×1050、1920×1200】等;16:9的屏幕适应分辨率为【1280×720、1440×810、1680×945、1920×1080】等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7cdce5012a7c08ab07cd4be3ceedb91/" rel="bookmark">
			dw写HTML怎么设置背景颜色,dreamweaver cs6设置div背景颜色的具体操作教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有不少刚刚接触dreamweaver cs6的伙伴们，并不是很熟悉其中是怎么设置div背景颜色?本期为你们分享的文章就讲述dreamweaver
cs6设置div背景颜色的具体流程介绍。
dreamweaver cs6设置div背景颜色的具体操作教程
首先需要打开dreamweaver cs6软件，添加div标签，并设置类。之后新建CSS样式。
然后我们在CSS规则定义的窗口中，在分类找到【方框】，设定长宽均为400。
这时div标签创建完毕，接下来要做到是为它添加背景色。
接着我们在右边的CSS样式窗口中找到该div的CSS，修改CSS样式。然后在分类中找到【背景】
再选择自己想设定的背景色，点击确定。
背景色设置完成。
同样，也可以添加本地图片作为背景，如下图所示，找到图像文件。
背景图像设置完毕。
另外，设置背景图像下面一共有四个选项：no-repeat、repeat、repeat-x、repeat-y，分别为重复、不重复、重复于水平面、重复于垂直面。即根据实际情况，选择适合的选项。
相信你们看完了上文讲解的dreamweaver cs6设置div背景颜色的具体操作步骤，应该都明白了吧!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194c8c67ff18fda067fd18da9301fe56/" rel="bookmark">
			利用计算机的外存储器,计算机存储器的作用及分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储器是很多设备都需具备的主要器件，在计算机中，存储器同样发挥着重要作用。为增进大家对计算机存储器的了解，本文将对计算机存储器的作用以及计算机存储器分类予以介绍。
一、简介
计算机存储器指计算机的内部存储区域，以芯片格式和集成电路形式存在。计算机存储器应用于录音机或磁盘。术语“存储器”通常视为物理存储器的简称，作为保留数据的实际可能芯片。有些计算机也使用虚拟存储器，即在硬盘上扩展物理存储器。
存储器是计算机的记忆装置，它的主要功能是存放程序和数据。程序是计算机操作的依据，数据是计算机操作的对象。不管是程序还是数据，在存储器中都是用二进制的形式来表示的，并统称信息。
在计算机中，存储器容量以字节(Byte，简写为B)为基本单位，一个字节由8个二进制位(bit)组成。存储容量的表示单位除了字节以外，还有KB、MB、GB、TB(可分别简称为K、M、G、T，例如，128MB可简称为128M)。其中：1KB=1024B，1MB=1024KB，1GB=1024MB，1TB=1024GB。
二、计算机存储器作用
1、启动计算机。计算机从只读存储器(ROM)中加载数据，然后执行通电自检(POST)，确认所有主要的部件都运行正常。作为自检的一部分，存储器控制器会通过一个快速的读/写操作来检查所有的存储器地址，以确保存储器芯片中没有错误。读/写操作意味着将数据写到一个位上，然后再从该位上读取出来。
2、计算机从ROM加载基本输入/输出系统(BIOS)。BIOS提供有关存储设备、启动顺序、安全性、即插即用(自动设备识别)功能和其他一些项目的最基本的信息。
3、计算机将操作系统从硬盘加载到系统的RAM中。通常来说，只要计算机处于开启状态，就会在RAM中维护操作系统的关键内容。这样有助于CPU立即访问操作系统，从而提高整个系统的性能和功能。
4、当您打开某个应用程序时，就会将其加载到RAM中。为了节省RAM，很多应用程序最初只加载程序最基本的部分，然后再根据需要加载程序的其他部分。
5、在某个应用程序加载完之后，在该应用程序中打开使用的任何文件将会加载到RAM中。
6、当您保存某个文件或关闭应用程序时，该文件会被写入到指定的存储设备，然后从RAM中清除该文件和应用程序。
三、计算机存储器分类
1、内部存储器
内部存储器简称内存，分为只读存储器(ReadOnlyMemory，ROM)和随机存储器(RandomAccessMemory，RAM)两种。
内存大小会直接影响到计算机的运行速度。微型计算机上使用的RAM被制作成内存条的形式，一条内存芯片的容量有128MB、256MB、512MB、1GB、2GB等不同的规格。
2、外部存储器
外部存储器简称外存，用以存放系统文件、大型文件、数据库等大量程序与数据信息，它们位于主机范畴之外。常用的外部存储器磁盘存储器、光盘存储器和闪存盘(优盘)。
1)硬盘
一个硬盘一般由多个盘片组成，盘片的每一面都有一个读写磁头。硬盘在使用时，读写磁头在盘的中心和边缘之间做径向移动，同时轴心进行转动，从而能够快速地在盘片的双面进行读写数据。
硬盘的容量计算方法为：存储容=磁头数&amp;mes;柱面数&amp;TImes;扇区数&amp;TImes;每扇区字节数。
2)光存储器量
光盘和光盘驱动器构成光存储设备，是近年来颇受重视的一种外存设备，光存储器具有存储容量大、读取速度快、价格低、使用方便等优点，使用越来越普及。
蓝光(Blu—ray)或称蓝光盘(Blu—rayDisc，BD)利用波长较短(405nm)的蓝色激光读取和写入数据，并因此而得名，用以存储高画质的影音以及高容量的资料。
3、按在计算机中的作用分类
按照在计算机系统中的作用不同，存储器主要分为主存储器、辅存储器、缓冲存储器。
主存的主要特点是他可以和CPU直接交换信息。辅助存储器是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，他不能与CPU直接交换信息。两者相比，主存速度快、容量小。每位价格高;辅助存储器速度慢，容量大。每位价格低。缓冲存储器用在两个速度不同的部件中，例如，CPU与主存之间可设置一个快速缓存，起到缓冲作用。
如下是一张存储器的分类图：
责任编辑人：CC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a5260aac6d399c608ba599ebb2d4277/" rel="bookmark">
			linux之ssh命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssh是什么呢？👉百科上是这么说的
随便插张图
简单来说，在linux中SSH是非常常用的工具，通过SSH客户端我们可以连接到运行了SSH服务器的远程机器上，也就是说，我们可以通过ssh来远程控制我们的电脑或者服务器。那么ssh协议的优点就是数据传输是加密的，可以防止信息泄露，而且数据传输是压缩的，可以提高传输速度。
它的命令格式是👉 ssh [-p port] user@remote
user 是在远程机器上的用户名，如果不指定的话默认为当前用户
remote 是远程机器的地址，可以是IP/域名，或者是别名
port 是SSH Server监听的端口，如果不指定，就为默认值22
(使用exit退出当前用户的登录)
有关SSH配置信息都保存在用户家目录下的.ssh目录下
接下来，我们就来实际演示一下ssh命令的使用
首先我们需要两台linux系统的电脑来进行演示，所以我用虚拟机安装了两个linux的系统，分别命名为Deepin1和Deepin2（不得不说deepin真的是即好看又好用😄）
不过deepin操作系统默认ssh是没有开启的，我们需要手动将它开启。
第一步，在终端输入sudo apt-get install ssh安装ssh服务
第二步，在终端中输入sudo service ssh start开启ssh服务
注意：deepin1和deepin2都要执行上面两步来安装和开启ssh服务
安装并打开ssh之后，我们使用Deepin1来远程连接Deepin2，那么我们需要知道Deepin2的ip地址，在终端中输入ifconfig就可以知道当前机器的ip地址了，或者也可以直接把鼠标放到网络连接上，会直接显示出来。我这里Deepin2的IP地址为:192.168.56.132
然后，我们在Deepin1的终端中输入ssh -p 22 deepin2@192.168.56.132然后回车
这里-p 22可以省略，22表示ssh的端口号为22，deepin2为Deepin2的用户名，192.168.56.132为Deepin2的ip地址。
第一次连接，会弹出来是否连接的确认信息，我们输入yes确认，然后输入deepin2的密码并回车。出现如下界面就表示连接成功了。
连接成功后，我们尝试输入cd Desktop/切换到桌面目录，然后输入touch 123.txt在桌面下创建123.txt文件
我们再切换到Deepin2系统中，发现桌面上的确出现了一个新的文件123.txt，大功告成！
到这里ssh的基本操作其实已经演示完了，但是我们发现每次远程登陆的时候都需要重新输入密码，稍微有点麻烦，其实我们可以通过设置，进行免密码登录。
免密登录：
第一步，配置公钥。在Deepin1终端中执行ssh-keygen即可生成SSH钥匙，一路回车即可。
第二步，上传公钥到服务器。在Deepin1终端中执行ssh-copy-id -p port user@remotr（ssh-copy-id -p 22 deepin2@192.168.56.132）可以让远程服务器记住我们。
第三步，设置完成了，试一下是否能免密登录呢？
可以看到，当我们远程登陆deepin2时，并没有输入用户密码就登陆成功了！其实挺简单的不是吗？
作者：山间不知秋
链接：https://www.jianshu.com/p/b10c2b163100
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5421f50d8664fb3ab8d4eb3c0bc233b8/" rel="bookmark">
			【Socket网络编程】17. recv() 函数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		recv函数 int recv( SOCKET s, char *buf, int len, int flags); 参数说明 第一个参数指定接收端套接字描述符； 第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据； 第三个参数指明buf的长度；第四个参数一般置0。 同步Socket的recv函数的执行流程 当应用程序调用recv函数时：
recv先等待 SOCKET s 的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR；如果s的发送缓冲区中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区；如果s的接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕；当协议把数据接收完毕，recv函数就把s的接收缓冲区中的数据copy到buf中。（注意协议接收到的数据可能大于buf的长度，所以 在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的）， recv函数返回其实际copy的字节数。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。 默认 socket 是阻塞的，阻塞与非阻塞recv()返回值没有区分，都是
&lt;0 出错，
=0 连接关闭，
&gt;0 接收到的数据长度大小
返回值 成功执行时，返回接收到的字节数。另一端已关闭则返回0。失败返回-1，errno被设为以下的某个值 ： EAGAIN：套接字已标记为非阻塞，而接收操作被阻塞或者接收超时 EBADF：sock不是有效的描述词 ECONNREFUSE：远程主机阻绝网络连接 EFAULT：内存空间访问出错 EINTR：操作被信号中断 EINVAL：参数无效 ENOMEM：内存不足 ENOTCONN：与面向连接关联的套接字尚未被连接上 ENOTSOCK：sock索引的不是套接字 当返回值是0时，为正常关闭连接； 特别 返回值&lt;0时并且(errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN)的情况下认为连接是正常的，继续接收。
EAGAIN、EWOULDBLOCK、EINTR与非阻塞 EWOULDBLOCK：用于非阻塞模式，不需要重新读或者写EINTR：指操作被中断唤醒，需要重新读/写 如果出现EINTR即errno为4，错误描述Interrupted system call，操作应该继续。
EAGAIN：Linux - 非阻塞socket编程处理EAGAIN错误 在linux进行非阻塞的socket接收数据时经常出现Resource temporarily unavailable，errno代码为11(EAGAIN)。从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。这个错误不会破坏socket的同步，不用管它，下次循环接着recv就可以。
对非阻塞socket而言，EAGAIN不是一种错误。在VxWorks和Windows上，EAGAIN的名字叫做EWOULDBLOCK。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5421f50d8664fb3ab8d4eb3c0bc233b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd9d7cb671a6e059f401d464016e5f79/" rel="bookmark">
			OSGB数据的纹理压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境 OSG3.4.1 + VS2017
对osgb数据的压缩关键在于纹理的压缩，即可在writeNodeFIie方法中进行操作。
osgDB::writeNodeFile(*rootNode, f_path, new osgDB::Options("WriteImageHint=IncludeFile")); osg老版本中的 writeImageHint=IncludeFile 有缺陷(听一位大佬说的，osg3.6中修复)，我测试后发现，使用这个选项时，在你的vs项目文件夹中必须有 该osgb数据的纹理，才能写入成功并压缩数据，否则会运行失败（可以写出，但纹理会丢失）
解决办法是先获取osgb数据的纹理图像，以压缩形式写入到项目文件夹中，再调用
osgDB::writeNodeFile(*rootNode, f_path, new osgDB::Options("WriteImageHint=IncludeFile")); 此时写出的osgb数据大小会被压缩，且可以保持正常的纹理。
获取纹理并压缩写入的代码。
osg::Texture2D* tex2d = dynamic_cast&lt;osg::Texture2D*&gt;(geom-&gt;getStateSet()-&gt;getTextureAttribute(0, osg::StateAttribute::TEXTURE)); image = tex2d-&gt;getImage(); osgDB::writeImageFile(*image, "项目文件路径_0.jpg",new osgDB::Options("JPEG_QUALITY 70")); //jpg 压缩等级70 发现osgb的纹理图片都会以 osgb数据名称 加 _0结尾（目前没碰到过其它情况）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e2175c5b2a2be508af53260a2446dc/" rel="bookmark">
			用getPopupContainer解决Select ProFormSelect DatePicker ProFormDatePicker下拉框在滚动时偏移错位问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、Select使用getPopupContainer改变浮层渲染父节点
&lt;Select defaultValue="lucy" getPopupContainer={triggerNode =&gt; triggerNode.parentElement} onChange={handleChange} &gt; &lt;Option value="jack"&gt;Jack&lt;/Option&gt; &lt;Option value="lucy"&gt;Lucy&lt;/Option&gt;	&lt;/Select&gt; 2、ProFormSelect使用getPopupContainer改变浮层渲染父节点
&lt;ProFormSelect name="type" label="类型" placeholder="请选择" fieldProps={{ getPopupContainer: (triggerNode) =&gt; triggerNode.parentNode, }} /&gt; 3、使用ConfigProvider全局设置getPopupContainer
&lt;ConfigProvider getPopupContainer={(node) =&gt; { if (node) { return node.parentNode; } return document.body; }} &gt; &lt;App/&gt; &lt;ConfigProvider/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b1a17ee9780f8cbb0d37124775bfe2/" rel="bookmark">
			【Java】Constant expression required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在JDK1.8下使用switch...case...语句，switch条件为String类型，case值为枚举code取字符串。此时报编译错误：“Constant expression required”。
枚举类
@Getter @AllArgsConstructor public enum AEnum { A("A", "Desc of A"), B("B", "Desc of B"), C("C", "Desc of C"); private String code; private String desc; // ... } switch...case...代码
// ... String code = ...; switch (code) { case MyEnum.A.getCode(): // 此处报"Constant expression required" // 处理逻辑 break; default: // 处理逻辑 break; } // ... 原因分析 case的条件值必须得是常量（表达式）且case后的条件值不能重复（相同），而此时枚举getCode()获取的不是常量，且不同的枚举可以有相同的code。
@Getter @AllArgsConstructor public enum AEnum { A("A", "Desc of A"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b1a17ee9780f8cbb0d37124775bfe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/320196cc008264044295379b551fbc7e/" rel="bookmark">
			全志T507操作小技巧连载1-T507屏幕切换的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、硬件操作平台介绍
FETT507-C核心板集成全志T507四核车规级处理器设计开发，Cortex-A53架构，主频1.5GHz，集成G31 GPU，内存2GB DDR3L，存储8GB eMMC。整板工业级运行温宽，支持绝大部分当前流行的视频及图片格式解码，具有稳定可靠的工业级产品性能、低功耗以及丰富的用户接口等优势，搭载Linux、Android、Ubuntu*操作系统，适用于车载电子、电力、医疗、工业控制、物联网、智能终端等领域。
本文不再对硬件参数进行叙述，在参考本文进行软件开发前请阅读飞凌嵌入式提供的全志T507用户手册 ，路径为“用户资料\手册\硬件手册”，以了解产品命名规则和您所使用产品的硬件配置信息，这样有助于您对本产品的使用。
本文介绍了全志T507屏幕切换控制的两种方式。
二、屏幕切换
OKT507-C开发板支持MIPI DSI、HDMI、TV等多种屏幕接口，同时可以进行两个屏幕的同显和异显，可灵活指定HDMI接口支持4K输出。目前屏幕切换控制方式有两种：内核设备树指定；uboot菜单动态控制。
目前OKT507-C支持HDMI、LVDS 1280x800、LCD7 1024x600、LCD7 800x480电容屏、LCD7 800x480电阻屏。
1、 内核设备树指定
该方式不需要连接串口终端，系统镜像默认为所期望的配置选择，适合量产。但需要手工修改设备树，重新生成一次系统镜像。该方式优先级高于uboot屏幕选单。
设备树路径为：linux-4.9/arch/arm64/boot/dts/sunxi/OKT507-C-Common.dtsi
内核源码中，打开设备dts文件，找到如下节点：
该status节点默认disabled状态，需要改为okay使能节点。
用户根据需求更改设置参数，保存后，需要重新编译生成镜像。
参数说明：
disp_lcd_type：描述lcd接口类型；
disp_lcd_type
lcd接口类型
lcd7_800_480_cap
7寸800x480电容屏
lcd7_800_480_res
7寸800x480电阻屏
rgb24
7寸1024x600电容屏
lvds
10.1寸1280x800电容屏
lcd_resolution：描述lcd屏分辨率；
tv_resolution： 描述tv屏分辨率；
disp_dvi_hdmi_type：描述hdmi接口还是dvi接口；
hdmi_resolution： 描述hdmi或dvi接口屏分辨率；
uboot_disp_mode：描述显示类型0代表单显LCD，1代表单显hdmi，3代表异显，5代表同显
举例：
将T507配置成同显模式，主屏为电容屏1024x600，副屏为dvi接口屏1920x1080P60。
注意：
1. lcd_resolution和tv_resolution只能存在一个，默认使用lcd_resolution。
2.对于MIPI屏幕种类多，可能现有时序和控制字不能满足要求，需要自行更改dsi节点下的lcd0。但任何和显示相关的节点status属性，均按照默认处理，程序会自动控制。
2、uboot菜单动态控制
该方式在T507现有已支持屏幕的基础上不需要重新编译和烧写，即可切换屏幕。
1、屏幕控制一级菜单
在uboot自启动过程中串口终端按下空格键，即可弹出控制选项：
输入”0”：
输入”1”：开发板重启；
输入”2”：进入屏幕控制子菜单。
2、屏幕控制二级菜单
屏幕控制子菜单，如下图：
输入”0”：退出，返回上级菜单；
输入”1”：进入LCD屏显示参数配置；
输入”2”：进入HDMI屏显示参数配置；
输入”3”：进入TV显示参数配置；
输入”4”：进入显示模式配置子菜单
3、屏幕控制三级菜单
显示模式配置子菜单：
屏幕参数选择前，首先由屏幕控制二级菜单终端输入”2”，进入显示模式选择菜单，如下图：
终端输入数字1到7对应显示模式类型：
输入”0”代表单显，返回上级菜单；
输入”1”代表单显，LCD屏显示；
输入”2”代表单显，HDMI屏显示；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/320196cc008264044295379b551fbc7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b31dda9854b515658341ff756d917e88/" rel="bookmark">
			北大软微计算机技术考研专业课,【2019年最新招生目录】北京大学软微学院软件工程考研专业课如何备考 参...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：【2019年最新招生目录】北京大学软微学院软件工程考研专业课如何备考 参
大家好，我是姜老师。
今日有话说：
北京大学的软件与微电子学院今年改的感觉已经不能称之为微整形了，简直换了个头一般。
列举一下具体的变动情况：
1、软件工程学硕还是没有统考。
2、电子与通信工程和集成电路工程专业课又双叒叕变了，真的是让人猜不透的小妖精。参考书按照软微的尿性(虽然已经摸不清)应该是10月份会出，但是心脏病不好的小伙伴可以考虑换学校了！
3、计算机技术依然是个相亲相爱的大家庭，今年是11个方向，有考数三的，有考数一的，还有考计算机辅助翻译的。但是熟悉的秘方已经看不到太多熟悉的脸庞，不知道学院老是换方向的名字是啥意思！如果按照新华字典来换，能换到世界末日吧。
4、小伙伴们不要去找心心念的金融信息服务了，已经换成了不知道是不是原来滋味的金融科技了，数三只有两个方向了，取消了低碳管理，且考且珍惜。
5、软件工程专硕专业课也换了代码，希望只是换了代码！
6、工业设计工程也换了，真是特么的整个晋西北全乱了套了！英语一换成了英语二，这个赞！专业课代码全换，以前是614数字艺术基础和820命题创作，现在是653数字艺术基础+905命题创作，真的是改姓不换名，真是磨人的小妖精！至于学习，还是按照以前的来吧，因为也没别的法子！最起码代码后的东西还是没变的，范围应该不会有太大的变化。
7、工程管理硕士就不说了。
8、电影和美术这两个方向也是醉了，虽然都是跟数字牵扯关系的，但是具体以后研究什么真的是未可知。幸好考试内容和工业设计工程是一样的，可以按照之前工业设计工程来准备。
关于：如何继续备考
二、计算机技术01-07方向
注解：
2018年专业课考的是822计算机基础综合，参考书为下方：
正在准备的继续准备，不要动摇，就算是今年的专业课又换了，也别担心，机会会留给一直在准备的你！第一年嘛，难度都不是很大，虽然不知道改到哪一年是个头，但是只要能考进去，管他改成什么样呢！就目前而言，我还是认为软微是性价比超高的一个学院！
这个我们有辅导，不要问我什么重点，去年的就是重点！也不要问以后专业课会换成什么样，买什么鸡，吃什么蛋！这点风险都不敢冒，还扯什么社会主义接班人。
四、软件工程
软件工程专业还是和计算机技术的01-07方向相同，完全相同，所以准备的情况还是按照上面说的来准备就可以。
还有一点，软件工程没有非全日制了，以前招的非全挺多的，一下子取消了，还有点小失落。
这个我们有辅导，内容同上！返回搜狐，查看更多
责任编辑：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a36b963f9d04ef5726f01dc6d70c72d/" rel="bookmark">
			c&#43;&#43;含有string的结构体初始化崩溃问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		含有string的结构体初始化时，不能直接对结构体对象={0}操作，否则会引起崩溃，如
struct demo { std::string info_; int id; }; void main() { demo dev = { 0 }; } 运行时会直接崩溃掉。对结构体初始化或者使用memset或者采用 demo dev={"",0}，这样的形势来初始化，切记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e096133abd8d044cbe287155e2133ba6/" rel="bookmark">
			基于统计的语言模型-n元语法模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		n-gram模型概述 1、n-gram模型，也称为N元语法模型，是一种基于统计语言模型的算法，n表示n个词语，n元语法模型通过n个词语的概率判断句子的结构。
2、n元语法模型的算法思想：将文本里面的内容按照字节进行大小为N的滑动窗口操作，形成了长度时N的字节片段序列，每个字节片段称为gram。对所有gram的出现频度进行统计，并且按照事先设定好的阈值进行过滤，形成关键gram列表，也就是这个文本的向量特征空间，列表中的每一种gram就是一个特征向量维度。
3、该模型基于马尔科夫假设，第N个词的出现只与前面N-1个词相关，而与其它任何词都不相关，整句的概率就是各个词出现概率的乘积。这些概率可以通过直接从语料中统计N个词同时出现的次数得到。常用的是Bi-Gram（二元语法模型）和Tri-Gram（三元语法模型）。
4、n-gram模型常见的应用场景：输入法的提示、搜索引擎等
n-gram原理 1、马尔科夫假设
给定时间线上有一串事件顺序发生，假设每个事件的发生概率只取决于前1个或t (t &gt;1)个事件，那么这串事件构成的因果链被称作马尔可夫链。在语言模型中，第i个事件指的是w,作为第i个单词出现。也就是说，每个单词出现的概率只取决于前1个或t个单词:
举例，当n=2时，为二元语法模型（Bi-Gram），即每个单词出现的概率只与前1个单词有关，根据公式计算整个句子出现的概率P(S) 为句子中每个单词出现概率的乘积：
P ( S ) = P ( w 1 , w 2 , … , w n ) = P ( w 1 ) P ( w 2 ∣ w 1 ) P ( w 3 ∣ w 2 ) … P ( w n ∣ w n − 1 ) P(S) = P(w_1,w_2, \dots,w_n) = P(w_1)P(w_2|w_1)P(w_3|w_2)\dots P(w_n|w_{n-1}) P(S)=P(w1​,w2​,…,wn​)=P(w1​)P(w2​∣w1​)P(w3​∣w2​)…P(wn​∣wn−1​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e096133abd8d044cbe287155e2133ba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9771292323f56fca5b28a528b3aef869/" rel="bookmark">
			基于UDS协议的Bootloader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考上汽标准:SMTC 2 800 004 电控单元诊断开发的技术要求
一、概述
二、Bootloader要求 三、刷新流程
四、刷新示例
一、概述
Bootloader概述：使用UDS协议服务实现应用软件，应用数据（包括网络配置数据和标定数据）的更新。Bootloader主要用于：研发、生产、售后。
二、Bootloader要求 总体要求：
1.bootloader应支持刷新电控单元的应用软件、应用数据（包括网络配置数据和标定据）。
2.bootloader负责验证应用软件和应用数据是否正确。
3.当应用软件或应用数据丢失或需要更新时，电控单元须进行刷新以恢复功能
4.数据传输基于CAN 总线并满足 ISO 15765-2 和 ISO 14229-1 的要求
5.任何情况下电控单元都不应支持数据上传功能
6.应用软件、网络配置数据和标定数据应可单独进行刷新。引导加载程序禁止自更新
7.对于同一物流数据标识符，分别从应用软件和引导加载程序获取到的信息应相同 通信要求 1.引导加载程序应使用固定的 CAN ID，与增强型诊断的 CAN ID相同
2.诊断请求和应答报文的数据长度固定 8字节，不足填充0x00
3.网络层时序参数要求遵照ISO 15765-2定义
4.流控要求
5.应用层时序要求
安全要求 1.电控单元应保证从应用软件跳转至bootloader时的状态是安全的
2.测试设备应使用种子和密钥进行安全访问，以防止未授权刷新。
3.bootloader应使电控单元输入输出端口设置为安全状态
4.bootloader程序应被保护，不可刷新，在刷新失败时应能再次刷新
5.电控单元应将刷新计数存储于非易失性存储器，每次加1
6.电控单元应计算每个数据块CRC并在退出传输服务请求的肯定应答中返回CRC(CRC遵守CTII-16)
7.电控单元应对下载到存储器的数据进行完整性检查
8.电控单元应验证应用软件与引导加载程序是否兼容、应用数据与应用软件是否兼容
9.电控单元退出刷新会话时应根据软件完整性状态和软件兼容性状态的参数值更新软件有效标志位，都有效时置1，bootloader才能运行
会话管理要求 1.电控单元应在收到请求报文 DSC:02 后500 ms 内进入引导加载程序的刷新会话
2.流程
a) 电控单元运行在应用软件时接收到子功能为 0x02 的服务$10 请求报文，应置刷新入口标志位为真（1）并存储于非易失性存储器。
b) 电控单元复位。
c) 电控单元启动，进入引导加载程序的默认会话，并检查刷新入口标志位的值判断之前应用软件是否请求进入刷新会话。（刷新入口标志位判断需在启动时间20 ms 内完成。）
d) 若为真，电控单元进入刷新会话并将刷新入口标志清零。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9771292323f56fca5b28a528b3aef869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f94d9302785978e01ba68710ae06ae24/" rel="bookmark">
			【Python】判断列表中是否存在一个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		l = [1,2,3,4] t = 1 if t in l: print('True') else: print('False') 猜你喜欢：👇🏻
⭐【Python】统计字符串里某个字符或子字符串出现的次数
⭐【Python】find()函数居然还能指定搜索的起点和终点？
⭐【Python】查找目标值在列表中的索引序号
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/352/">«</a>
	<span class="pagination__item pagination__item--current">353/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/354/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>