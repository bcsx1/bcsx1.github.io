<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7497778c3588f2d5f945d1f088b37d/" rel="bookmark">
			Simcenter Amesim 2019.2与Matlab 2019b联合仿真-环境配置与例程联合仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前的LMS AMEsim被西门子收购后已经改叫Siemens Simcenter Amesim了。在本人博客中，已详细介绍了Simcenter Amesim 2019.1与Matlab 2017b联合仿真详细配置过程：点击查看。
本篇博文将继续介绍最新版本的Simcenter Amesim 2019.2与最新版本的Matlab 2019b进行联合仿真的配置过程。
1.编译器 要想进行Amesim与Matlab联合仿真，需要确定作为两者联合媒介的编译器（Compiler）。要想与Matlab进行联合仿真，最好使用Microsoft Visual C++作为二者的编译器。
由官方手册可以查询到Amesim 2019.2对软硬件的要求如下图：
其中比较关键两点信息：
系统必须是64位系统从Amesim 2019.2开始，新增了对Visual C++ 2015～2019的支持。（Amesim 2019.1只支持Microsoft Visual C++ 2010 ～ 2013） 从Matlab官方网页：https://ww2.mathworks.cn/support/requirements/previous-releases.html。我们可以看到Matlab 2019b支持Microsoft Visual C++ 2015～2019。
取两者交集，要使AMESIM 2019.2和Matlab 2019b通过Microsoft Visual C++进行联合仿真，则必须安装Microsoft Visual C++ 2015～2019中的版本。
这里，我们选择编译器为Visual Studio 2019 community。
2、软件安装 上面已经明晰，需要安装的软件为：
编译器：Visual Studio 2019 communityAmesim: Amesim 2019.2Matlab 2019b 安装顺序的话，并没有强制要求。VS2019和Matlab 2019b这两个孰先孰后无所谓。不过，建议先安装VS2019，再安装Matlab 2019b和AMESIM。因为安装Amesim时，它查询到已经安装有Visual Studio 编译器，它会把Visual Studio 安装目录下的部分文件复制到Amesim的安装目录下,省去不少事。尤其是，VS2019的目录结构跟以往VS版本有很大区别，自己再手动复制文件时容易搞糊涂。
1. 安装VS2019
下载并安装VS2019，注意，安装时需要勾选VC模块。安装目录可按默认，不过，建议不要带空格。本人安装时没注意，安装路径带了空格。。。
2. 安装Matlab 2019：
随意安装，但请注意：安装路径不要带中文！！！且最好不要带空格！本人安装在D:\Polyspace\R2019b
3. 安装AMESIM 2019.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7497778c3588f2d5f945d1f088b37d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804a87935361b2096f08f124dafaca2a/" rel="bookmark">
			【python】读取excel的行列内容，pandas，超详细！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用python处理excel的内容时，第一步当然是读取excel的内容。
import pandas as pd #1：读取指定行 print("----读取指定的单行，数据会存在列表里面----") df=pd.read_excel('测试.xlsx')#这个会直接默认读取到这个Excel的第一个表单 data=df.loc[0].values#0表示第一行 这里读取数据并不包含表头，要注意哦！ print("读取指定行的数据：\n{0}".format(data)) print("\n------读取指定的多行，数据会存在嵌套的列表里面----------") df=pd.read_excel('测试.xlsx') data=df.loc[[1,2]].values#读取指定多行的话，就要在loc[]里面嵌套列表指定行数 print("读取指定行的数据：\n{0}".format(data)) print("\n----------------读取指定的行列-----------------------") df=pd.read_excel('测试.xlsx') data=df.iloc[1,2]#读取第一行第二列的值，这里不需要嵌套列表 print("读取指定行的数据：\n{0}".format(data)) print("\n----------------读取指定的多行多列值-----------------------") df=pd.read_excel('测试.xlsx') data=df.loc[[1,2],['title','data']].values#读取第一行第二行的title以及data列的值，这里需要嵌套列表 print("读取指定行的数据：\n{0}".format(data)) print("\n-----------获取所有行的指定列----------------------------") df=pd.read_excel('测试.xlsx') data=df.loc[:,['title','data']].values#读所有行的title以及data列的值，这里需要嵌套列表 print("读取指定行的数据：\n{0}".format(data)) print("\n------------获取行号并打印输出---------------------------") df=pd.read_excel('测试.xlsx') print("输出行号列表",df.index.values) print("\n-------------获取列名并打印输出--------------------------") df=pd.read_excel('测试.xlsx') print("输出列标题",df.columns.values) print("\n------------获取指定行数的值---------------------------") df=pd.read_excel('测试.xlsx') print("输出值",df.sample(3).values)#这个方法类似于head()方法以及df.values方法 print("\n-----------获取指定列的值----------------------------") df=pd.read_excel('测试.xlsx') print("输出值\n",df['data'].values) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b381bca58957a3bffd4729537fe9baec/" rel="bookmark">
			深入理解Flutter的Listener组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 有过移动端开发经验的同学都知道，移动端的触摸事件是由手指按下、手指移动、手指抬起这些基本事件组成的。
在Flutter中，一切皆Widget。Widget本身并不具备识别触摸事件的功能。能识别触摸事件的Widget，必须经由Listener或GestureDetector组装起来。
而GestureDetector本质上还是由Listener组成的，所以我们先认识一下Listener。
Listener Listener在功能划分上属于功能型Widget，主要提供原始触摸事件的监听。下面看一下它的构造函数：
const Listener({ Key key, this.onPointerDown, this.onPointerMove, this.onPointerEnter, this.onPointerExit, this.onPointerHover, this.onPointerUp, this.onPointerCancel, this.onPointerSignal, this.behavior = HitTestBehavior.deferToChild, Widget child, }) 从构造函数中可以知道，Listener提供了多种触摸事件的监听，但我们经常用到的是onPointerDown、onPointerMove、onPointerUp，分别对应手指按下、手指移动、手指抬起这三个触摸事件。
child属性表示被包装的Widget。
behavior属性，这是Listener很重要的一个属性，也是本节着重讨论的，但是现在还轮不到他出场，在理解behavior属性之前，我们必须要认识一个概念，叫做命中测试(Hit Test)。
一、命中测试 当手指按下、移动或者抬起时，Flutter会给每一个事件新建一个对象，如按下是PointerDownEvent，移动是PointerMoveEvent，抬起是PointerUpEvent。对于每一个事件对象，Flutter都会执行命中测试，它经历了以下这几步：
1、从最底层的Widget开始执行命中测试，是否命中取决于hitTestChildren方法(它的children Widget是否命中测试)或hitTestSelf方法是否返回true。
2、循环最底层Widget的children Widget，分别执行child Widget的命中测试。child Widget是否命中也取决于hitTestChidren方法(它的children Widget是否命中测试)或hitTestSelf方法是否返回true。
3、从下往上递归地执行命中测试，直到找到最上层的一个命中测试的Widget，将它加入命中测试列表。由于它已命中测试，那么它的父Widget也命中了测试，将父Widget也加入命中测试列表。以此类推，直到将所有命中测试的Widget加入命中测试列表。
举个例子 为了更加形象的理解命中测试这个概念，我们看一下下面的例子。
Listener( child: ConstrainedBox( constraints: BoxConstraints.tight(Size(200, 200)), child: Center( child: Text('click me'), ) ), onPointerDown: (event) =&gt; print("onPointerDown") ) 它的展示效果如上图所示。 在Flutter中，每一个Widget实际上会对应一个RenderObject。对于上面代码来说，上图为Widget和RenderObject的对应关系。
1、当点击了Text时，它的命中测试列表是这样的： RenderParagraph-&gt;RenderPositionedBox-&gt;RenderConstrainedBox-&gt;RenderPointerListener，所以RenderPointerListener的handleEvent方法会被执行，最终在控制台会打印onPointerDown。
注意：触摸事件会循环命中测试列表，并分别执行它们的handleEvent方法。Flutter中几乎所有Widget对应的RenderObject都是直接或者间接继承自RenderBox，而RenderBox继承了HitTestTarget，并重写了handleEvent方法。
2、当点击了Text以外的区域时，它的命中测试列表就没有RenderPointerListener了。为什么呢？？？
Text以外的区域是ConstrainedBox的(为什么不是Center，因为Center的功能是帮助Text定位，它的区域和Text是一致的)。那ConstrainedBox对应的RenderConstrainedBox命中测试了么？很显然是没有的。
因为ConstrainedBox只有一个child，就是Center。Center对应的RenderPositionedBox没有命中测试，导致RenderConstrainedBox的hitTestChildren返回false，而它的hitTestSelf也返回false，所以RenderConstrainedBox没有命中测试。
而Listener也只有一个child，那就是ConstrainedBox，既然RenderConstrainedBox没有命中测试，那么RenderPointerListener相应的就没有命中测试，所以命中测试列表中是没有RenderPointerListener的。
所以控制台并不会打印onPointerDown。
说明：命中测试方法是RenderBox(RenderObject的子类)的hitTest方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b381bca58957a3bffd4729537fe9baec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb07a1f277428f893467da6772562b99/" rel="bookmark">
			启动tomcat报错 Unable to process Jar entry [module-info.class] from Jar...[xxx.xx.jar!\] for annotations
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Web 项目tomcat启动报错module-info.class 从git 上面拉下的项目，运行报错。
jdk、maven配置正常
tomcat启动遇见的问题： Unable to process Jar entry [module-info.class] from Jar [jar:file:项目发布后的路径/具体的某个jar包 !/] for annotation 猜测问题原因：
本地 tomcat 配置不一样。别人在新建的过程中缺少的东西自动做了填补，拉下来以后本地的tomcat缺少相应的jar包。
打开你的tomcat文件夹，找到conf -&gt; catalina.properties 文件，
在最后一个加入 ,\ ，然后再换行添加你缺少的，就是报错的时候提示的那个。
其实我们发现上面配置了很多 * ，猜测就是为了通配，而你如果不知道你自己这个需不需要通配，暂时不要理他，需要啥具体写上啥就行。
我的最后两个就是报错提示需要的。直接写上。重启 IDEA，问题解决。
如果能够帮到你，很荣幸。
我的公众号【iBroPro】，欢迎你来找我讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0786b5c1412cdfa529768cf02c9a4a20/" rel="bookmark">
			tensor中的view()、sequeeze()、resize()操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. view() tensor.view()方法可以调整tensor的形状，但必须保证调整前后元素总数一致。view不会修改自身的数据，返回的新tensor与原tensor共享内存，即更改一个，另一个也随之改变。
如：
import torch as t a=t.arange(0,6).view(2,3) print(a) b=a.view(-1,2) #当某一维是-1时，会自动计算它的大小 print(b) #输出 tensor([[0, 1, 2], [3, 4, 5]]) tensor([[0, 1], [2, 3], [4, 5]]) 在实际应用中，可能经常需要添加或者减少某一维度，这是sequeeze()和unsequeeze()这两个方法就派上了用场。
2. unsequeeze()和sequeeze() unsequeeze(dim)用来在维度dim上增加1维；sequeeze(dim)用来在dim上减少维度。
如：
import torch as t a=t.arange(0,6).view(2,3) print(a) b=a.view(-1,2) #当某一维是-1时，会自动计算它的大小 print(b) c=b.unsqueeze(1) #在第1维上，增加1 print(c.size()) d=c.squeeze(-2) #在倒数第二维上，减少1维 print(d.size()) #输出 tensor([[0, 1, 2], [3, 4, 5]]) tensor([[0, 1], [2, 3], [4, 5]]) torch.Size([3, 1, 2]) torch.Size([3, 2]) 3.resize() resize是另一种可用来调整size的方法，但与view不同，它可以修改tensor的尺寸。如果新尺寸超过了原尺寸，会自动分配新的内存空间，而如果新尺寸小于原尺寸，则之前的数据依旧会被保存下来。
如：
import torch as t a=t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0786b5c1412cdfa529768cf02c9a4a20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdc4c5309f5a5637b20bed2a94f33b24/" rel="bookmark">
			二叉树的路径之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
给定一个二叉树与正数sum，找出所有从根节点到叶节点的路径，这些路径上的节点值累加和为sum。
#include&lt;stdio.h&gt; #include&lt;vector&gt; using namespace std; struct TreeNode{ int val; TreeNode *left; TreeNode *right; TreeNode(int x):val(x),left(NULL),right(NULL){} }; class Solution{ public: vector&lt;vector&lt;int&gt; &gt; path_sum(TreeNode* root,int sum){ vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; path; int path_value=0; preorder(root,path_value,sum,path,result); return result; } private: //只有定义方法的时候才写数据类型，用的时候不用写 void preorder(TreeNode *node,int &amp;path_value,int sum,vector&lt;int&gt; &amp;path,vector&lt;vector&lt;int&gt; &gt; &amp;result){ if(!node){ return; } path_value+=node-&gt;val; path.push_back(node-&gt;val); if(!node-&gt;left&amp;&amp;!node-&gt;right&amp;&amp;path_value==sum){ result.push_back(path); } preorder(node-&gt;left,path_value,sum,path,result); preorder(node-&gt;right,path_value,sum,path,result); path_value-=node-&gt;val; path.pop_back(); } }; int main(){ TreeNode a(5); TreeNode b(4); TreeNode c(8); TreeNode d(11); TreeNode e(13); TreeNode f(4); TreeNode g(7); TreeNode h(2); TreeNode x(5); TreeNode y(1); a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdc4c5309f5a5637b20bed2a94f33b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd039f8b3ed69afedbf2e14718edcd9a/" rel="bookmark">
			Web前端之Flask框架--flask简介、Jinja2模板引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、flask简介1、架构简介2、什么是Flask3.Flask的优势 二、实现简单的Web网站1、Flask第一个网站2、设置动态路由 三、HTTP请求方法的实现1、HTTP请求常见的方式(get,post)的区别：2、模板渲染3.重定向和错误（redirect,error）4.不同方法实现用户登录1）get方法实现用户登录2）post方法实现用户登录 5.自定义错误页面6.flask的日志记录 四、静态文件介绍1、静态文件存储位置：2、调用方式： 五、会话session介绍六、消息闪现1、什么是消息闪现2、应用场景3、实现步骤 七、Jinja2模板引擎1、 什么是Jinja2模板引擎2、Jinja2语法1）变量显示语法：2）变量内置过滤器：3)如何自定义过滤器i、for循环:ii、if语句 4）宏操作i、如何定义宏：ii、如何调用宏 5)include包含操作6)模板继承i、如何定义模板：blockii、如何继承：extends 八、一个内容丰富的用户登录系统 一、flask简介 1、架构简介 当用户使用浏览器访问网站的页面信息时，会有如下的经历：
当用户通过浏览器提交一个请求时，首先将请求提交给NGINX服务器，然后经过中间人uWSGI转换协议，使请求能够提交给使用不同协议的Flask等，并进行处理，处理结束后再原路返回，将请求结果返回给用户。
其中：
NGINX服务器是一个Web服务器，一般企业前端会选择NGINX服务器，但是由于用户量很大，所以在NGINX的后端会有很多个阿帕奇服务器，使用超文本协议–HTTP协议后端中的Flask等使用的协议却不是HTTP协议，是WSGI协议uWSGI–wWeb,sServer,gGateway,iInterface.即前端服务的网关接口。uWSGI既可以与NGINX通信，也可以与Web通信，因此uWSGI作为一个中间人使NGINX和Flask可以通信。与NGINX通信的协议为http协议，与Web通信的协议为WSGI协议， Nginx (engine x) 是一个高性能的HTTP和反向代理 web服务器，同时也提供了IMAP/POP3/SMTP服务。（由一个俄罗斯人发明，可以接收的请求量达到了10k，因此更靠近用户）uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。http协议和nginx进行交流，WSGI协议和后端的python代码，wed框架进行交流。Framework即架构，它是一个语言开发软件，提供了软件开发的框架，使开发更具工程性、简便性和稳定性。常用的就是django和flask框架，flask用于小项目，django用于大项目。 2、什么是Flask Flask是一个Web框架, 就是提供一个工具库和技术来允许你构建一个Web应用程序.这个Web应用程序可以是一些Web页面,博客, wiki ,基于 Web 的日历应用或商业网站。
Flask依赖模块(还有一些别的，这里介绍一个):
web服务网关接口（Web Server Gateway Interface,缩写为WSGI
Werkzeug 一个WSGI工具包， 是为python语言定义的web服务器和web应用程序或框架之间的一种简单而通用的借口,其他语言也有类似的接口）jinja2模板引擎 3.Flask的优势 Flask属于微框架（ micro-framework )这一类别,微架构通常是很小的不依赖外部库的框架(安装时不会下载一些附带的依赖包，根据你实际使用的情况自己下载需要的包)。
框架很轻量更新时依赖小专注于安全方面的bug 二、实现简单的Web网站 1、Flask第一个网站 两个名词：
路由：
@app.route('') #根据选择的路径，判断采用哪个试图函数 视图函数：
def 函数名（）：#视图函数（函数名一定不能重复）：给用户返回查看的页面信息 代码：
from flask import Flask # __name__确定此flask项目的所在位置 app=Flask(__name__) # 实现首页：http://172.25.254.1:9999/(访问首页) @app.route('/') #路由：根据选择的路径，判断采用哪个试图函数 def index(): #视图函数（函数名一定不能重复）：给用户返回查看的页面信息 return '这是网站的首页' @app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd039f8b3ed69afedbf2e14718edcd9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e7140454bbdb107ba84e9c7f1db7b9/" rel="bookmark">
			整数数据类型smallint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.1 smallint说明1.2 测试环境说明1.3 加unsigned属性1.3.1 SQL模式开启严格模式1.3.2 SQL模式未开启严格模式 1.4 加zerofill属性1.4.1 SQL模式开启严格模式1.4.2 SQL模式未开启严格模式 1.5 不加unsigned和zerofill属性1.5.1 SQL模式开启严格模式1.5.2 SQL模式未开启严格模式 1.1 smallint说明 数据类型显示长度占用字节有符号无符号smallint加上unsigned/zerofill：5 不加unsigned/zerofill：62(16bit)-32768至327670至65535 ## 格式 id smallint(M) [unsigned] [zerofill] 字段名 数据类型(显示长度,建表时不指定) 无符号 无符号且前导零填充 ## 关于smallint最大数值是怎样得来的 smallint占用2字节,2字节占用16位，经过换算(2的16次方减1)就是65535 ## 关于加上unsigned后的说明 加上unsigned后就是无符号(范围是0~65535的整数,因为是整数,不会有符号"-",所以就是无符号) ## 关于加上zerofill后的说明 zerofill会把unsigned属性也给带上,这样就是无符号（范围是0~65535，显示长度就是5），同时还会进 行前导零填充（没有达到显示长度的数值，例如：你插入1，显示的是00001）。 ## 不加unsigned和zerofill的说明 字段后面不加上这两个属性中的任何一个,就表示是有符号(范围是-32768~32767,因为有符号"-",所有是有符号)。 1.2 测试环境说明 ## 数据库版本和默认的存储引擎 mysql&gt; select @@version,@@default_storage_engine; +------------+--------------------------+ | @@version | @@default_storage_engine | +------------+--------------------------+ | 5.7.28-log | InnoDB | +------------+--------------------------+ 1 row in set (0.00 sec) ## 创建chenliang库 mysql&gt; create database if not exists chenliang; Query OK, 1 row affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96e7140454bbdb107ba84e9c7f1db7b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5eb25614394064be3797907a3c28de5/" rel="bookmark">
			ziplist分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里直接贴ziplist.c中的作者的注释，从注释中我们可以直观的看到ziplist是用于存储string字符串的双向链表，其目的是更好地利用内存去存储数据，减少无用数据的比例。
/* The ziplist is a specially encoded dually linked list that is designed * to be very memory efficient. It stores both strings and integer values, * where integers are encoded as actual integers instead of a series of * characters. It allows push and pop operations on either side of the list * in O(1) time. However, because every operation requires a reallocation of * the memory used by the ziplist, the actual complexity is related to the * amount of memory used by the ziplist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5eb25614394064be3797907a3c28de5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbe3d1ea932eeb9828892c45e5c5062a/" rel="bookmark">
			蓝桥杯 ALGO-199 算法训练 奇异的虫群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算法训练 奇异的虫群
时间限制：1.0s 内存限制：256.0MB
问题描述
在一个奇怪的星球上驻扎着两个虫群A和B，它们用奇怪的方式繁殖着，在t+1时刻A虫群的数量等于t时刻A虫群和B虫群数量之和，t+1时刻B虫群的数量等于t时刻A虫群的数量。由于星际空间的时间维度很广阔，所以t可能很大。OverMind 想知道在t时刻A虫群的数量对 p = 1,000,000,007.取余数的结果。当t=1时 A种群和B种群的数量均为1。
输入格式
测试数据包含一个整数t，代表繁殖的时间。
输出格式
输出一行，包含一个整数，表示对p取余数的结果
样例输入
10
样例输出
89
样例输入
65536
样例输出
462302286
数据规模和约定
对于50%的数据 t&lt;=10^9
对于70%的数据 t&lt;=10^15
对于100%的数据 t&lt;=10^18
分析：设时刻A虫群和B虫群的数量分别为和，则根据题意有
写成矩阵形式，有
记作，其中。
#include &lt;stdio.h&gt; struct Matrix { long long int data[2][2]; }; struct Matrix mul(struct Matrix A, struct Matrix B) { struct Matrix ans; for (int i = 0; i &lt; 2; ++i) { for (int j = 0; j &lt; 2; ++j) { ans.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbe3d1ea932eeb9828892c45e5c5062a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e172bd6ff4193148e0617d2b307a75/" rel="bookmark">
			【Excel2019(八)：IF函数逻辑判断】【使用IF函数&#43;AND函数与OR函数】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇：【Excel2019(七)：认识公式与函数】【认识Excel公式(=+&amp; 连字符+比较符运算+引用+绝对引用)认识函数(总分+平均分+最大值+最小值+排名+使用定位工具)】
文章目录 使用IF函数基本使用及嵌套用IF函数处理运算错误 AND函数与OR函数AND函数OR函数 使用IF函数 基本使用及嵌套 专业类后加专业代号。理工 对号 LG，财经 对号 CJ，文科 对号 WK
公式展示
结果
600分含600显示第一批，400-600含400分显示第二批，400分以下落榜
公式展示
结果
用IF函数处理运算错误 公式展示
结果
AND函数与OR函数 AND函数 对于60岁以上（含）的男性员工给予1000元奖金
公式展示
OR函数 对于60岁以上或40岁以下的员工给予1000元奖金
公式展示
下一篇：【Excel2019(九)：Countif函数】【使用Countif函数+应用实例】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea050b524f78406881faacd94e489206/" rel="bookmark">
			Altium designer批量更改原件原理图和PCB库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候只有原理图和PCB文件，为了让原理图和PCB文件能够对的上，必须要加上库才行。为此分别将原理图和PCB文件导出库文件，然后在相互更新。
文章目录 1. 导出库文件1.1 导出原理图封装库1.2 导出PCB文件封装库 2.更改原件原理图2.1 修改全部原件2.2 修改相同原件的原理图 3.修改PCB库3.1 修改全部库3.2 修改部分库 4.进行匹配 1. 导出库文件 1.1 导出原理图封装库 选中对应的原理图文件，然后点击design-&gt;make schematic library
在点击上图的制作库后会弹出如下对话框，选择第一个表示相同的原件只导出一次，要不然会把说有原件都导出的。
1.2 导出PCB文件封装库 PCB文件同样的道理，不过这会不用出现上面弹出的对话框了。
2.更改原件原理图 2.1 修改全部原件 选择原理图中任意一个原件，然后什么都不要点，直接点击OK（左侧勾选Select Matching）
然后弹出的对话框，修改库文件即可
2.2 修改相同原件的原理图 如上面的操作，当点击任意原件查找类似原件时，需要添加相应的过滤规则，如下设置为原件名字相同的一类原件。同样会弹出上面第二个图的搜索结果，修改原理图即可。
3.修改PCB库 3.1 修改全部库 更新PCB库需要从原理图SCH中导入，选择需要更改PCB库的文件，然后tools-&gt;Footprint Manager。
在弹出的下面窗口，全部选择左侧原件，这样才能在右侧看到封装列表，然后全部选中右侧列表，点击validate进行验证，这时软件自己会找原件PCB库(最好把PCB库保存到工程路径下)
3.2 修改部分库 修改部分原件的话，只需要左侧原件选中即可，操作类似。
4.进行匹配 选中原理图，然后点击Design-&gt;update PCB Document XXXXXXXX.PcbDoc
如果不兼容的话，会弹出他们的差异报告，然后点击执行即可。下面是更新到PCB后，可以发现2者没有差异了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db03b5634ad25572eb21d1566f714cf2/" rel="bookmark">
			抽象数据类型（例用举例解释定义）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5b1773daf839b131e4e99e8d9104fc5/" rel="bookmark">
			FairyGUI中常用的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		素材管理 可以直接将图片（Gif）、声音(mp3)、动画、文字等素材从资源浏览器拖动到库中。 资源Url
UIPackage.getItemURL(“包名“，“资源名”) AudioClip clip = (AudioClip)UIPackage.GetItemAsset(“包名称”,”声音名称”);
菜单”编辑”-&gt;“创建位图字体”，（输入字符，显示对应图片） 多信息文本(GRichTextField)支持链接和图文混排。 用例： aTextField.text = “请去找王大锤”;
列表 （GList） AddChild : 增加一个项目。 AddChildAt ：在指定的位置增加一个项目。 RemoveChild : 删除一个项目。 RemoveChildAt ： 删除一个指定位置的项目。 RemoveChildren ： 删除一个范围内的项目，或者全部删除。 GList内建了对象池。 使用对象池后的方法： AddItemFromPool : 从池里取出（如果有）或者新建一个对象，添加到列表中 GetFromPool ： 从池里取出（如果有）或者新建一个对象 ReturnToPool : 将对象返回池里 RemoveChildToPool : 删除一个列表项目，并将对象返回池里 RemoveChildToPoolAt : 删除一个指定位置的项目，并将对象返回池里 RemoveChildrenToPool：删除一个范围内的项目，或者全部删除，并将删除的对象都返回池里 添加对象时不使用池，对象池将不断增大。 正确的做法：从池中创建对象。即使用AddItemFromPool或GetFromPool。
虚拟列表 GList.SetVirtual 使用GList.numItems设定列表项目的数量。注意与GList.numChildren区分，后者是当前列表容器的显示对象数量。 但要注意显示对象和列表项目的数量在数量上和顺序上都是不一致的，也就是GetChildAt(0)获得的显示对象并不等于列表的第一条项目。 列表滚动到目标位置(第500个)，调用GList.AddSelection(500) 虚拟列表只能通过numItems改变列表项目的数量，不允许使用AddChild或RemoveChild增删对象。例如如果要清空列表，必须要通过设置numItems=0，而不是RemoveChildren。 循环列表 GList.SetVirtualAndLoop()。
GList.ensureBoundsCorrect()通知GList立刻重排。（手动触发重新排列）
装载器 GLoader 运行时设置装载器内容的方式是： aLoader.url = “ui://xxxxx”; aLoader.url = “demo/aimage”; //这里加载的是路径为Assets/Resources/demo/aimage的一个贴图 例如，你希望从AssetBundle中获取资源，那么你可以扩展GLoader。首先编写你的Loader类，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5b1773daf839b131e4e99e8d9104fc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b03b3ff0e16c363888fe63925561522/" rel="bookmark">
			CM101S无法激活adb，U盘装机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.通过adb无法连接IP 此时检查后发现，也没有adb激活选项；此时常规的远程装机无法实现了。
| 2.大神指路 在其他网站发现了一种U盘装机过程，下载了相关固件。然后解压缩。
进一步，解压缩后，讲文件夹的文件全部copy到U盘根目录中，总共有4个文件。
3.pin1-pin2短接后通电 此时要注意，短接后通电后（红圈），屏幕是黑色的，此时短接坚持15s即可，然后放弃短接。不过此时屏幕还没有任何反应，仍然是黑屏，此时我们不用管它。大概1分钟以后，桌面就准备好了。此时我们关机，然后拔掉U盘，再次开机就正常了。
4.开机后的画面区别于当贝桌面 当时我们可以安装当贝桌面，后设置总是当贝桌面启动。
以后每次开机后，都是当贝桌面了。
不过我至今还是没发现怎么激活adb。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98fdb912ffefe7658234444bbbaa0e1f/" rel="bookmark">
			最详细的docker安装rocketMQ教程来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RocketMQ是一款分布式、队列模型的消息中间件，是由阿里巴巴设计的，具有以下特点：
支持严格的消息顺序
支持Topic与Queue两种模式
亿级消息堆积能力
比较友好的分布式特性
同时支持Push与Pull方式消费消息
历经多次天猫双十一海量消息考验
RocketMQ是纯java编写，基于通信框架Netty。
其实小编就冲着RocketMQ历经多次天猫双十一海量消息考验，就感觉应该选择他了，再加上有亿级消息堆积能力，这么强大的一个部件，一个新生的黑马！接下来带大家在centos7上用docker安装rocketMQ.
1. 安装 Namesrv 拉取镜像
docker pull rocketmqinc/rocketmq:4.4.0
在/usr/local 目录下新建文件夹 mq
命令： mkdir mq
启动容器
docker run -d -p 9876:9876 -v {自己的路径}/data/namesrv/logs:/root/logs -v {RmHome}/data/namesrv/store:/root/store --name rmqnamesrv -e "MAX_POSSIBLE_HEAP=100000000" rocketmqinc/rocketmq:4.4.0 sh mqnamesrv
如下图，我自己的路径为 /usr/local/mq 你自己可以自定义路径。替换路径即可
注意事项
{自己的路径} 要替换成你的宿主机想保存 MQ 的日志与数据的地方，通过 docker 的 -v 参数使用 volume 功能，把你本地的目录映射到容器内的目录上。否则所有数据都默认保存在容器运行时的内存中，重启之后就又回到最初的起点。
2. 安装 broker 创建 broker.conf 文件
1:在 {自己的路径}/conf 目录下创建 broker.conf 文件
进入之前/usr/local/mq目录下，输入命令mkdir conf 新建conf目录
接着在conf目录下输入命令touch broker.conf 新建文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98fdb912ffefe7658234444bbbaa0e1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fca874e0a03506173eee11aac5ff4659/" rel="bookmark">
			D 触发器 Multisim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/291075f0f7954d88ff28ff4b0e48b617/" rel="bookmark">
			（协议分析）通过抓包分析HTTP协议以及包中内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为网络安全往往需要一门脚本语言的支持，不然只能用着别人的工具。因此决定从学习编写一只爬虫开始，来入门python掌握一门脚本语言，学习爬虫，当然与http协议离不了关系，因此先分析一下http的工作流程
HTTP协议 1.什么是HTTP
http协议是超文本传输协议，它定义了浏览器和服务器之间的通信规则，http有两个程序实现，一个客户端程序，一个服务器程序，从层次结构上来看属于应用层的协议，使用tcp作为它的支撑运输协议，并且是一种无状态协议，以此来降低服务器的负荷
2.工作原理
HTTP：客户端与服务器端建立连接 -————客户端发出请求报文———— 服务器端发出应答报文
HTTPS：现在大多数页面使用HTTPS来进行数据的交流，因为HTTP报文都是明文的，一旦目标截取数据包，很有可能得到用户的账号密码
过程： 主机向服务器发送请求，想要建立连接—————服务器向主机返回一个公钥（公钥需要到认证中心申请，因此许多做黑产的页面只能使用http）——————主机收到公钥后，利用公钥对自己的请求报文进行加密——————服务器收到后利用自己的私钥进行解密
3.http请求
包括 请求行 请求头 请求内容
请求方式有get、post、put、delet等等
这里主要说下最常见的两种get和post post可以承载更多的发送信息
post请求 如图---------在百度 搜索123 后抓取到如上图的数据包
POST：请求方式以及使用的HTTP的版本
URI：统一资源标识符（注意URI和URL是两种不同的概念，但是可以把它当作url来理解，下面是对于两者区别的详细讲解）
https://www.jianshu.com/p/ba15d066f777
Request Version：版本信息
Request Method:请求方法
Host：表示向哪一台主机发送请求
Accept：告诉浏览器我可以接收哪些数据类型
Accept-Encoding:告诉浏览器，支持的压缩格式
User-Agent:客户机使用的浏览器以及版本信息
Cache Control:缓存控制
Connection:告诉服务器请求完后是断开还是保持连接
Content-Length:我可以接收的数据的长度
Full-Request URI：所请求的完整的URI
HTTP Request ：HTTP请求的进度
Response in frame 请求的帧
request请求 Request URI 以及请求的内容
Request path 所请求的路径
Referer：表示的含义是你是从哪个页面来到此页面的，服务器往往通过referer来防盗链
Cookie：http往往是种无状态协议，因此大部分页面使用cookies来对用户进行表示，从而实现登录功能
（这里出了点问题，因为现在的页面大都是https的包，导致我抓不到几个数据包，唉）
4.http响应 响应同样也包括 响应行 响应头 响应内容
Sever：服务器信息
Last-modified：上一次修改时间
状态码含义以及常见的状态码：我们可以通过状态码得到此次请求是否成功
1XX 表示信息 如
2XX 表示请求成功
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/291075f0f7954d88ff28ff4b0e48b617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfa81e188db63a922bc61480394dc1a/" rel="bookmark">
			Python面试题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例:
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 第一种解法：
class Solution(object): def twoSum(self, nums, target): if len(nums) &lt; 2: return for i in range(0, len(nums) - 1): for j in range(i + 1, len(nums)): if nums[i] + nums[j] == target: return [i, j] nums = [2, 7, 11, 15] s = Solution() 第二种解法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfa81e188db63a922bc61480394dc1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae480a3135b6f3413060bbd0f2f1cdc2/" rel="bookmark">
			vue echaets实现地图下钻功能和散点图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码实现如下
&lt;template&gt; &lt;div&gt; &lt;div ref="mapCountry" class="map-main" /&gt; &lt;div ref="mapProvince" class="map-main" /&gt; &lt;div ref="mapCity" class="map-main" /&gt; &lt;div ref="mapCounty" class="map-main" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import echarts from 'echarts' import 'echarts/map/js/china' import fuzhou from '@/assets/福州市.json' import longyan from '@/assets/龙岩市.json' import zhangzhou from '@/assets/漳州市.json' import xiamen from '@/assets/厦门市.json' import ningde from '@/assets/宁德市.json' import sanming from '@/assets/三明市.json' import nanping from '@/assets/南平市.json' import putian from '@/assets/莆田市.json' import quanzhou from '@/assets/泉州市.json' import cangshan from '@/assets/cangshan.json' // geojson.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae480a3135b6f3413060bbd0f2f1cdc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4fe39df6c293dabfa80bfa619060f2f/" rel="bookmark">
			vue项目中主要文件的加载顺序（index.html、App.vue、main.js）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先后顺序：
index.html &gt; App.vue的export外的js代码 &gt; main.js &gt; App.vue的export里面的js代码 &gt; Index.vue的export外的js代码 测试的页面代码块：
文件的加载先后顺序： Index.vue的mounted()中的输出没有执行。why？
--------------------------------------------------------------------------------------------------------------------------
每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的，所以我们试下延迟创建新的Vue实例的情况下加载的顺序。
这里主要修改的是App.vue和main.js的代码，index.html和Index.vue主要是添加执行的时间：
index.html &gt; App.vue的export外的js代码 &gt; main.js调用公共函数外的代码 &gt; App.vue公共函数的定时器外的代码 &gt; main.js调用公共函数内创建实例前的代码 &gt; App.vue的export里面的js代码 &gt; main.js调用公共函数内创建实例后的代码 &gt; App.vue公共函数的定时器内执行回调函数后的代码 &gt; Index.vue的export外的js代码 可以看到创建实例的前后，中间执行了一次App.vue中的mounted内的代码
引用地址：https://www.cnblogs.com/stella1024/p/10563091.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faa0f249b0fcf5a94097b80bb322bece/" rel="bookmark">
			遇到多个构造器参数时考虑用构建器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.sudy.alarm.test; //Builder Pattern public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder { //required parameters private final int servingSize; private final int servings; //optional parameters private int calories = 0; private int fat = 0; private int carbohydrate = 0; private int sodium = 0; public Builder(int servingSize, int servings) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faa0f249b0fcf5a94097b80bb322bece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1c14160acce78d0eaf51e13281411c/" rel="bookmark">
			PAT-B 1030 完美数列 (25分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。
现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
输入格式 输出格式 在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
输入样例 10 8
2 3 20 4 5 1 6 7 8 9
输出样例 8
注意 首先将数组从小到大进行排序，使用sort()函数。函数：使用二分法（题目N范围大，缩短时间）找到第一个大于满足x（long long 型，两个int相乘）数的下标返回值j：表示从a[i]开始的完美队列长度最长为 j - i 。 代码 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include "string" //#include "math.h" #include &lt;cstdlib&gt; #include&lt;algorithm&gt;//排序sort() using namespace std; int n,p; int a[100000]; int binarysearch(int i,long long x) { if(a[n-1] &lt;= x) return n; //如果整个数列最大数都小于x则， // 返回n 此时一直到最后都满足 int l=i+1,r=n-1,mid; while(l &lt; r) { mid = (r + l) / 2; if(a[mid] &lt;= x) l=mid+1; else r=mid; } //r == l return r; } int main() { cin&gt;&gt;n&gt;&gt;p; for (int i = 0; i &lt; n; ++i) { cin&gt;&gt;a[i]; } sort(a,a+n); //从小到达排序 //重点 int ans=0;// for (int i = 0; i &lt; n; ++i) { int j=binarysearch(i,(long long)a[i]*p);//long～ -- 两个int相乘 ans =max(ans,j-i); } cout&lt;&lt;ans; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a885991b9152be7c8492726afdd305e4/" rel="bookmark">
			浏览器之倍速播放法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为大家介绍三种浏览器（火狐、谷歌、360）的倍速方法，添加扩展程序即可，操作简便，详细操作方法可参考下文，欢迎大家一起学习，共同进步！
I. Firefox浏览器倍速播放 1.打开火狐浏览器，右上角有个“”的图标
2.点击后，选择-【附加组件】-弹出新标签页-在搜索框输入：【faster video】；弹出搜索结果,如下图所示
3.点击【faster video】-【添加到firefox】即可
4.添加完成后，刷新页面/重新打开浏览器，即会发现右上角会出现播放选择
5.播放视频时，选择相应的倍速即可
注：若操作失败，可能需要尝试禁止“flash”播放；或者更新adobe flash等
II.Google浏览器倍速方法 1.打开谷歌浏览器，点击右上角“”;【更多工具】-【扩展程序】搜索即可
或者直接在谷歌的应用商店里选择扩展程序进行搜索，如下图：
2.在搜索框输入【Video Speed Controller】；找到此扩展程序；添加即可。
添加扩展程序后，要记得打开【开发者模式】
3.成功添加后，右上角会显示：“”；点击也可进行倍速快捷键设置
注：①添加完成后，可以点击【扩展程序】，打开【开发者模式】；并且设置该程序【允许访问文件网址】
②搜索的扩展程序的时候，会出现同类型的多个扩展应用，大家也可自行进行尝试！
III.360浏览器倍速播放 1.先下载一个视频加速播放文件，这里还是用的【video speed controller】链接如下：
https://www.extfans.com/productivity/nffaoalbilbmmfgbnbgppjihopabppdk/
2.打开360浏览器，点击红色方框按钮，打开扩展页面后，将插件拖动进去
3.点击浏览器的设置按钮，找到安全设置——自动停用来源不明的扩展（将此选项√去掉）
4.设置成功后，播放视频测试即可。
【如有其它问题可联系我，文末留言或者关注公众号都可以哦~~】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1c074d77adc60cc308c6f79a282b7d2/" rel="bookmark">
			grep搜索文件内容和grep搜索.gz压缩文件的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里我们以搜索8723183为例
grep搜索压缩文件的内容
gzip -dc ./文件名.gz | grep “8723183” grep模糊搜索
gzip -dc ./*.gz | grep “8723183” 搜索非压缩文件
grep -rin “8723183” ./文件名.log 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506abe4f24cd8b05d1eef3249894424c/" rel="bookmark">
			【技术分享】机器学习模型可解释性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文原作者：陈亮，经授权后发布。
原文链接：https://cloud.tencent.com/developer/article/1523172
导语 模型可解释性方面的研究，在近两年的科研会议上成为关注热点，因为大家不仅仅满足于模型的效果，更对模型效果的原因产生更多的思考，这样的思考有助于模型和特征的优化，更能够帮助更好的理解模型本身和提升模型服务质量。本文对机器学习模型可解释性相关资料汇总survey。
综述 机器学习业务应用以输出决策判断为目标。可解释性是指人类能够理解决策原因的程度。机器学习模型的可解释性越高，人们就越容易理解为什么做出某些决定或预测。模型可解释性指对模型内部机制的理解以及对模型结果的理解。其重要性体现在：建模阶段，辅助开发人员理解模型，进行模型的对比选择，必要时优化调整模型；在投入运行阶段，向业务方解释模型的内部机制，对模型结果进行解释。比如基金推荐模型，需要解释：为何为这个用户推荐某支基金。
机器学习流程步骤：收集数据、清洗数据、训练模型、基于验证或测试错误或其他评价指标选择最好的模型。第一步，选择比较小的错误率和比较高的准确率的高精度的模型。第二步，面临准确率和模型复杂度之间的权衡，但一个模型越复杂就越难以解释。一个简单的线性回归非常好解释，因为它只考虑了自变量与因变量之间的线性相关关系，但是也正因为如此，它无法处理更复杂的关系，模型在测试集上的预测精度也更有可能比较低。而深度神经网络处于另一个极端，因为它们能够在多个层次进行抽象推断，所以他们可以处理因变量与自变量之间非常复杂的关系，并且达到非常高的精度。但是这种复杂性也使模型成为黑箱，我们无法获知所有产生模型预测结果的这些特征之间的关系，所以我们只能用准确率、错误率这样的评价标准来代替，来评估模型的可信性。
事实上，每个分类问题的机器学习流程中都应该包括模型理解和模型解释，下面是几个原因：
模型改进：理解指标特征、分类、预测，进而理解为什么一个机器学习模型会做出这样的决定、什么特征在决定中起最重要作用，能让我们判断模型是否符合常理。一个深度的神经网络来学习区分狼和哈士奇的图像。模型使用大量图像训练，并使用另外的一些图像进行测试。90%的图像被准确预测，这值得我们高兴。但是在没有计算解释函数(explainer function)时，我们不知道该模型主要基于背景：狼图像通常有一个下雪的背景，而哈士奇的图像很少有。所以我们不知不觉地做了一个雪地探测器，如果只看准确率这样的指标，我们就不会看到这一点。知道了模型是如何使用特征进行预测的，我们就能直觉地判断我们的模型是否抓住了有意义的特征，模型是或否能泛化到其他样本的预测上。模型可信性与透明度：理解机器学习模型在提高模型可信度和提供审视预测结果透明度上是非常必要的，让黑箱模型来决定人们的生活是不现实的，比如贷款和监狱刑法。另一个对机器学习结果可信度提出质疑的领域是药品，模型结果会直接决定病人的生与死。机器学习模型在区分恶性肿瘤和不同类型的良性肿瘤方面是非常准确的，但是我们依然需要专家对诊断结果进行解释，解释为什么一个机器学习模型将某个患者的肿瘤归类为良性或恶性将大大帮助医生信任和使用机器学习模型来支持他们工作。长久来看，更好地理解机器学习模型可以节省大量时间、防止收入损失。如果一个模型没有做出合理的决定，在应用这个模型并造成不良影响之前，我们就可以发现这一点。识别和防止偏差：方差和偏差是机器学习中广泛讨论的话题。有偏差的模型经常由有偏见的事实导致，如果数据包含微妙的偏差，模型就会学习下来并认为拟合很好。一个有名的例子是，用机器学习模型来为囚犯建议定罪量刑，这显然反映了司法体系在种族不平等上的内在偏差。其他例子比如用于招聘的机器学习模型，揭示了在特定职位上的性别偏差，比如男性软件工程师和女性护士。机器学习模型在我们生活的各个层面上都是强有力的工具，而且它也会变得越来越流行。所以作为数据科学家和决策制定者来说，理解我们训练和发布的模型如何做出决策，让我们可以事先预防偏差的增大以及消除他们，是我们的责任。 可解释性特质：
重要性：了解“为什么”可以帮助更深入地了解问题，数据以及模型可能失败的原因。分类：建模前数据的可解释性、建模阶段模型可解释性、运行阶段结果可解释性。范围：全局解释性、局部解释性、模型透明度、模型公平性、模型可靠性。评估：内在还是事后？模型特定或模型不可知？本地还是全局？特性：准确性、保真性、可用性、可靠性，鲁棒性、通用性等。人性化解释：人类能够理解决策原因的程度，人们可以持续预测模型结果的程度标示。 动机 在工业界中，数据科学或机器学习的主要焦点是更偏“应用”的解决复杂的现实世界至关重要的问题，而不是理论上有效地应用这些模型于正确的数据。机器学习模型本身由算法组成，该算法试图从数据中学习潜在模式和关系，而无需硬编码固定规则。因此，解释模型如何对业务起作用总是会带来一系列挑战。有一些领域的行业，特别是在保险或银行等金融领域，数据科学家通常最终不得不使用更传统的机器学习模型（线性或基于树的）。原因是模型可解释性对于企业解释模型所采取的每个决策非常重要。
残酷的现实是，如果没有对机器学习模型或数据科学pipeline如何运作的合理理解，现实中的项目很少成功。 现实中的数据科学项目，通常会有业务和技术两方面。数据科学家通常致力于构建模型并为业务提供解决方案。但是，企业可能不知道模型如何工作的复杂细节。
数据科学从业者将知道存在典型的模型可解释性与模型性能权衡。这里需要记住的一点是，模型性能不是运行时或执行性能，而是模型在决策中的准确程度。有几种模型，包括简单的线性模型甚至是基于树的模型，它们可以很容易地解释模型为获得特定的洞察力或预测而做出的决策，但是你可能需要牺牲模型性能，因为它们总是不能产生最好的结果是由于高偏差（线性模型）或高方差的固有问题，导致过度拟合（完全成长的树模型）。更复杂的模型，如集合模型和最近的深度学习模型系列通常会产生更好的性能，但被认为是黑盒模型，因为很难解释模型如何真正做出决定。
理解模型可解释性 模型解释作为一个概念仍然主要是理论和主观的。任何机器学习模型的核心都有一个响应函数，它试图映射和解释独立（输入）自变量和（目标或响应）因变量之间的关系和模式。当模型预测或寻找见解时，需要做出某些决定和选择。模型解释试图理解和解释响应函数所做出的这些决定，即what，why以及how。模型解释的关键是透明度，质疑能力以及人类理解模型决策的难易程度。模型解释的三个最重要的方面解释如下。
是什么驱动了模型的预测？我们应该能够查询我们的模型并找出潜在的特征交互，以了解哪些特征在模型的决策策略中可能是重要的。这确保了模型的公平性。为什么模型会做出某个决定？我们还应该能够验证并证明为什么某些关键特征在预测期间驱动模型所做出的某些决策时负有责任。这确保了模型的可靠性。我们如何信任模型预测？我们应该能够评估和验证任何数据点以及模型如何对其进行决策。对于模型按预期工作的关键利益相关者而言，这应该是可证明且易于理解的。这确保了模型的透明度。 在比较模型时，除了模型性能之外，如果模型的决策比其他模型的决策更容易理解，那么模型被认为比其他模型具有更好的可解释性。
可解释性的重要性 在解决机器学习问题时，数据科学家往往倾向于关注模型性能指标，如准确性，精确度和召回等等（毫无疑问，这很重要！）。这在大多数围绕数据科学和机器学习的在线竞赛中也很普遍。但是，指标只能说明模型预测决策的部分故事。随着时间的推移，由于环境中的各种因素导致的模型概念漂移，性能可能会发生变化。因此，了解推动模型采取某些决策的因素至关重要。
如果一个模型工作得很好，为什么还要深入挖掘呢？在解决现实世界中的数据科学问题时，为了让企业信任您的模型预测和决策，他们会不断提出“我为什么要相信您的模型？”这一问题，这一点非常有意义。如果一个人患有癌症或糖尿病，一个人可能对社会构成风险，或者即使客户会流失，您是否会对预测和做出决策（如果有的话）感到满意？也许不是，如果我们能够更多地了解模型的决策过程（原因和方式），我们可能会更喜欢它。这使我们更加透明地了解模型为何做出某些决策，在某些情况下可能出现的问题，并且随着时间的推移它有助于我们在这些机器学习模型上建立一定程度的信任。
了解预测背后的原因在评估信任方面非常重要，如果计划基于预测采取行动，或者选择是否部署新模型，那么这是至关重要的。无论人类是直接使用机器学习分类器作为工具，还是在其他产品中部署模型，仍然存在一个至关重要的问题：如果用户不信任模型或预测，他们就不会使用它。 这是我们在本文中多次讨论的内容，也是决定数据科学项目在行业中取得成功的关键区别之一。这推动了模型解释的必要性和重要性的紧迫性。
可解释性的标准 有一些特定的标准可用于分类模型解释方法。 Christoph Molnar，2018年“可解释的机器学习，制作黑箱模型可解释指南”中提到了一个很好的指南。
内在还是事后？内在可解释性就是利用机器学习模型，该模型本质上是可解释的（如线性模型，参数模型或基于树的模型）。事后可解释性意味着选择和训练黑匣子模型（集合方法或神经网络）并在训练后应用可解释性方法（特征重要性，部分依赖性图）。我们将更多地关注我们系列文章中的事后模型可解释方法。模型特定或模型不可知？特定于模型的解释工具非常特定于内在模型解释方法，这些方法完全依赖于每个模型的功能和特征。这可以是系数，p值，与回归模型有关的AIC分数，来自决策树的规则等等。与模型无关的工具与事后方法更相关，可用于任何机器学习模型。这些不可知方法通常通过分析（和输入的扰动）特征输入和输出对来操作。根据定义，这些方法无法访问任何模型内部，如权重，约束或假设。本地还是全局？这种解释分类讨论了解释方法是解释单个预测还是整个模型行为？或者如果范围介于两者之间？我们将很快谈论全球和地方的解释。 可解释性的范围 如何定义可解释性的范围和界限？一些有用的方面可以是模型的透明度，公平性和责任性。全局和局部模型解释是定义模型解释范围的明确方法。
全局可解释：就是试图理解“模型如何进行预测？”和“模型的子集如何影响模型决策？”。要立即理解和解释整个模型，我们需要全局可解释性。全局可解释性是指能够基于完整数据集上的依赖（响应）变量和独立（预测变量）特征之间的条件交互来解释和理解模型决策。尝试理解特征交互和重要性始终是理解全球解释的一个很好的一步。当然，在尝试分析交互时，在超过两维或三维之后可视化特征变得非常困难。因此，经常查看可能影响全局知识模型预测的模块化部分和特征子集会有所帮助。全局解释需要完整的模型结构，假设和约束知识。
局部解释：试图理解“为什么模型为单个实例做出具体决策？”和“为什么模型为一组实例做出具体决策？”。对于本地可解释性，我们不关心模型的固有结构或假设，我们将其视为黑盒子。为了理解单个数据点的预测决策，我们专注于该数据点并查看该点周围的特征空间中的局部子区域，并尝试基于该局部区域理解该点的模型决策。本地数据分布和特征空间可能表现完全不同，并提供更准确的解释而不是全局解释。局部可解释模型 - 不可知解释（LIME）框架是一种很好的方法，可用于模型不可知的局部解释。我们可以结合使用全局和局部解释来解释一组实例的模型决策。
模型透明度：为试图理解“如何根据算法和特征创建模型？”。我们知道，通常机器学习模型都是在数据特征之上利用算法来构建将输入映射到潜在输出（响应）的表示。模型的透明度可能试图了解模型的构建方式以及可能影响其决策的更多技术细节。这可以是神经网络的权重，CNN滤波器的权重，线性模型系数，决策树的节点和分裂。但是，由于业务可能不太精通这些技术细节，因此尝试使用不可知的局部和全局解释方法来解释模型决策有助于展示模型透明度。
可解释性的作用 对于想要了解模型如何工作的数据科学家来说，评估模型的准确性通常是不够的。数据科学家通常想知道模型输入变量如何工作以及模型的预测如何根据输入变量的值而变化。
机器学习算法和模型的工程应用中用到最多的主要是树类模型(lgb,xgb)和神经网络(cnn, rnn)，使用者往往习惯于很少去思考其中的含义和解释性。需要思考一个模型的哪些东西是可解释的？
所以有几个问题值得讨论：
哪些特征在模型看到是最重要的？关于某一条记录的预测，每一个特征是如何影响到最终的预测结果的？从大量的记录整体来考虑，每一个特征如何影响模型的预测的？ 为什么这些解释信息是有价值的呢：
调试模型用 一般的真实业务场景会有很多不可信赖的，没有组织好的脏数据。你在预处理数据时就有可能加进来了潜在的错误，或者不小心泄露了预测目标的信息等，考虑各种潜在的灾难性后果，debug的思路就尤其重要了。当你遇到了用现有业务知识无法解释的数据的时候，了解模型预测的模式，可以帮助你快速定位问题。指导工程师做特征工程 特征工程通常是提升模型准确率最有效的方法。特征工程通常涉及到到反复的操作原始数据(或者之前的简单特征)，用不同的方法来得到新的特征。有时候你完成FE的过程只用到了自己的直觉。这其实还不够，当你有上百个原始特征的时候，或者当你缺乏业务背景知识的时候，你将会需要更多的指导方向。如何创造出这样优秀的特征呢？如何找到最重要的特征的方法，并且可以发现两个特别相关的特征，当面对越来越多的特征的时候，这些方法就会很重要啦。指导数据采集的方向 对于网上下载的数据集你完全控制不了。不过很多公司和机构用数据科学来指导他们从更多方面收集数据。一般来说，收集新数据很可能花费比较高或者不是很容易，所以大家很想要知道哪些数据是值得收集的。基于模型的洞察力分析可以教你很好的理解已有的特征，这将会帮助你推断什么样子的新特征是有用的。指导人们做决策 一些决策是模型自动做出来的，虽然亚马逊不会用人工来决定展示给你网页上的商品，但是很多重要的决策是由人来做出的，而对于这些决定，模型的洞察力会比模型的预测结果更有价值。建立模型和人之间的信任 很多人在做重要决策的时候不会轻易的相信模型，除非他们验证过模型的一些基本特性，这当然是合理的。实际上，把模型的可解释性展示出来，如果可以匹配上人们对问题的理解，那么这将会建立起大家对模型的信任，即使是在那些没有数据科学知识的人群中。 方法 模型效果评估指标图
Confusion Matrix
一个完美的分类模型就是，如果一个客户实际上属于类别 good，也预测成good，处于类别 bad，也就预测成 bad。实际上一些是 good 的客户，根据我们的模型，却预测他为 bad，对一些原本是 bad 的客户，却预测他为 good。我们需要知道，这个模型到底预测对了多少，预测错了多少，混淆矩阵就把所有这些信息，都归到一个表里：
Sensitivity（覆盖率，True Positive Rate）= 正确预测到的正例数 / 实际正例总数；Recall (True Positive Rate，or Sensitivity) =true positive/total actual positive=d/c+d；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/506abe4f24cd8b05d1eef3249894424c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8bca6d9b5b237979ef778d7747a9ea/" rel="bookmark">
			GAN系列：论文阅读——Analyzing and Improving the Image Quality of StyleGAN（StyleGAN改进）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019.12的对styleGA进一步改善的论文，还是NVIDIA的。这篇论文主要从结构设计和训练方式上进行了改变，从而消除styleGAN中出现的artifacts。本文针对的artifacts主要两类：1）成水滴状的/blob-like artifacts：主要与结构设计有关，因此本文更改了normalize；2）与progressive growing的训练方法相关，因此本文更改了训练方式。
第一种artifacts呈现水滴形的模糊块，在生成图像中看起来尚不明显时在中间层的特征上就很清楚了。这种artifacts通常从64*64分辨率开始出现在每一张特征图上，并随着分辨率增加变得明显。具体如下图所示：
本文认为这种现象和styleGAN的生成器中的normalization有关，因为normalize调整了feature maps的统计信息，通过这种信号强度高的水滴块，生成器可以躲避复杂的数据生成，直接调整feature maps的统计信息。文中认为，AdaIN中的normalization是对每一个feature map单独操作的，损害了特征间的信息。博客：https://blog.csdn.net/WinerChopin/article/details/103538073 提出的看法是，AdaIN的normalization在feature maps间是独立的，但modulation又是所有feature maps共享参数，因此产生了数据分布的变化。同时，如下图所示：
第一行的feature maps在128*128时出现了水滴，但第二列没有。由于水滴的存在保证了数据的统计特性，第一列的其他位置像素值是平滑的，但第二列的特征就更清晰一些。然而在256*256时，第二列出现了多个水滴，控制了统计特性，导致最后生成图像有很大问题，然而第一列却效果较好。这说明生成图像的效果一定程度上依赖于水滴artifacts的生成，也就是说不能完全删除这种artifacts。那么如何调整水滴artifacts呢？文中的这个过程可以概括为把AdaIN+conv转化为conv，具体分析如下：
1. 研究styleGAN中生成器结构，从图a表示法换为图b表示法，内容结构未变：
其实就是把AdaIN拆分成normalization和modulation，把卷积的细节设计的权重w和偏置b表示了出来。在图b这种表示中发现，卷积中加上偏置b和随机噪声B是改变一张feature map整体均值的，这与紧接着的normalization中减去mean的操作作用是相反的，如果b+B使得均值增加了，后面的normalization就会减去它。因此对这两者进行了顺序调换，调换后再调整均值这种操作和加上偏置b+B其实作用相同，因此可以省去normalization包括modulation中的mean操作，使其通过学习偏置参数b实现（个人认为，其实就是mean和偏置b的作用会相互抵消，只用一个就够了）。更改后的结构如下图所示：
2. normalization中的std操作和Modulation中的std操作均可以附加在卷积核的操作上，进而实现对feature maps的改变，因此AdaIN+conv就可以变为单独的conv操作了，只不过卷积核发生了改变。这个过程中卷积核参数变化如下：
1）. 2）. 将std操作转移到卷积核参数上是基于i.i.d.的数据分布假设，因此这种操作是基于一定的假设，而不是完全基于实际的feature maps数据，导致之前的normalization和modulation变得不会过于严格，改善了水滴artifacts的影响。上述步骤1就是modulation对卷积核参数的影响，步骤2是normalization对卷积核的影响，因为对应这前一步的modulation，这回步骤2被称为demodulation。一些示意图如下：
水滴artifacts消失了并且全局信息都很清楚，这就是本文解决的第一个问题。
第二个问题是progressive training带来的shift invariance，就是随着图像角度的shift，生成的一些细节并未随着改变，导致了图像细节改变的不连续性，如下图所示：
脸的角度变了，然而牙齿基线却没变，这也太细节了。。。文中认为，progressive training导致生成结果对一些局部信息有偏好，在shift较小时这部分局部信息不改变，直到突然跳变到下一种，这就是所谓的unsmooth。progressive training导致每一分辨率的输出结果都是短暂的，但最后产生的图像会倾向于这个过程中出现频率最高的那个生成结果。而这个训练是一层层累积的，像素过低的时候不能生成牙齿眼球方向这些细节，生成器过渡到像素高又必须经过中间层，因此中间层使用率最高，产生的结果频率最高，因此中间层的结果经常出现在最后生成的图像中，导致了这些细节并未发生改变。为了解决这个问题，本文取消了渐进式训练，那么为了保证生成图像的质量，就需要更强大的生成器和判别器，因此尝试了9中结构改变：
分别对生成器和判别器尝试了原始结构，跳层连接/skip connection和残差结构。实验结果发现，生成器使用跳层连接更为合适，判别器使用残差结构更合适，因为判别器类似分类器，残差适合分类。最后改进的效果如下图：
这是两个主要创新，除此之外基于PPL的正则和large network上的研究，可以参考博客：
https://blog.csdn.net/WinerChopin/article/details/103538073
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8640c8702e2b900101cc44bc986ba8/" rel="bookmark">
			算法设计：2.向下取整、向上取整符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、向下取整、向上取整1.符号2.下标对半分 (p+q)/2（1）结论（2）例子 二、C/C++实现1.头文件2.例子 一、向下取整、向上取整 1.符号 向上取整, 运算称为 Ceiling，用数学符号⌈ ⌉ （上有起止，开口向下）表示。
等于大于自己的最小整数
向下取整, 运算称为 Floor，用数学符号⌊ ⌋ （下有起止，开口向上）表示。
等于小于自己的最大整数
2.下标对半分 (p+q)/2 （1）结论 向上取整： ⌈ ( p + q ) / 2 ⌉ \lceil{(p+q)/2}\rceil ⌈(p+q)/2⌉
奇数个数就是中间的值的下标偶数个数就是中间偏右的值的下标 向下取整： ⌊ ( p + q ) / 2 ⌋ \lfloor{(p+q)/2}\rfloor ⌊(p+q)/2⌋
奇数个数就是中间的值的下标偶数个数就是中间偏左的值的下标 （2）例子 将下标p,q（0,1,2）分两半：
向上取整⌈(p+q)/2⌉：结果是1向下取整⌊(p+q)/2⌋：结果是1 将下标p,q（0,1,2,3）分两半：
向上取整⌈(p+q)/2⌉：结果是2向下取整⌊(p+q)/2⌋：结果是1 二、C/C++实现 1.头文件 #include &lt;math.h&gt; // #include &lt;cmath&gt; 2.例子 #include &lt;iostream&gt; #include &lt;math.h&gt; using namespace std; int main() { /* 向上取整、向下取整、四舍五入 */ cout &lt;&lt; ceil(1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f8640c8702e2b900101cc44bc986ba8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366a5c96e946b3e0b10c664a56803b86/" rel="bookmark">
			基础编程题目集 7-32 说反话-加强版 (20分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述： 给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。
输入格式 给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。
输出格式： 每个测试用例的输出占一行，输出倒序后的句子，并且保证单词间只有1个空格。
输入样例： Hello World Here I Come
输出样例： Come I Here World Hello
基本思路 首先按行存入字符串，使用getline（）函数。
从后往前遍历整个字符串。
s[i]如果是空格跳4，否则是字母，跳5。
如果s[i]是空格，判断s[i+1]是否是字母，
若是字母，则说明一个单词已经遍历完了，头指针front指向i+1，此时s[front] 到s[tail-1]为切下来的一个单词。
若不是字母，则将尾指针tail前移到当前空格位置i，尾指针保持为离字母最近的空格位置。
如果是字母，判断是否遍历完字符串，
如果遍历完，此时i==0，判断是否字符串后面是否还有单词(输出的最后一个单词)，如果还有单词再打印出来。
注意事项 1.第一个单词前不能输出空格。 2.最后一个单词后不能输出空格。 3. 中间单词之间需要用空格隔开。 代码 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include "string" #include &lt;cstdlib&gt; #include&lt;algorithm&gt;//排序sort() using namespace std; int main() { string s; getline(cin,s); int times=0;//计算单词的个数 int front,tail=s.length(); for (int i = s.length()-1; i &gt;= 0; --i) { if(s[i]!=' ')//是单词 { if(i==0)//是否遍历完 { bool flag=false;//是否还有单词 for(int j = 0; j &lt; tail;j++) { if(s[j] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/366a5c96e946b3e0b10c664a56803b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/204bdd73e20aa974df047015ad678251/" rel="bookmark">
			Macbook Pro无法使用Logi Option连接蓝牙鼠标解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天，在Mac上想通过罗技官方的软件对M590鼠标进行自定义操作的时候，在蓝牙端口无法检测到已经连接在Mac的设备。
在罗技官网寻找解决方案也没有找到妥善的方式，但是发现问题出现的原因应该是在电脑端的“系统偏好设置-安全性与隐私-输入监视“中没有添加：Logi Options“和”Logi Option Daemon“，如下图：
在上图中，前两个是无法检测到蓝牙设备的主要原因。通过点击上图中的加号“+”，可以自行添加软件：
Deamon的文件地址在“/Library/Application Support/Logitech.localized/Logitech Options.localized”文件夹中。
Options的文件地址在“/Applications”文件夹中。
通过自定义添加这两个文件后，再打开Logi Options之后可以顺利检测到已经连接的蓝牙鼠标以及蓝牙键盘，这样就可以自定义设备的辅助按钮了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e8efe1b3e38c11058b1136a72015f37/" rel="bookmark">
			树的广度优先遍历（BFS）的Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BFS实现（Java） 在上一篇博客中，提到了DFS的实现和原理。BFS作为树的另外一种重要的遍历方式，其本质原理是层次遍历：一层一层向下，每一层又是从左向右遍历。那么，仔细分析这种遍历方法之后就会发现队列这种数据结构是其实现的关键所在。
那么问题来了，Java中并无集成的队列数据结构
不过，集合中的LinkedList可以很好地解决这个问题，通过add( )、remove( )函数可以很好地模拟队列这种先进先出的数据结构。具体的实现代码如下：
public static ArrayList&lt;Integer&gt; bfs(TreeNode root){ Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root==null){ return list; } queue.add(root); while (!queue.isEmpty()){ TreeNode t = queue.remove(); list.add(t.val); if(t.left!=null){ queue.add(t.left); } if(t.right!=null){ queue.add(t.right); } } return list; } 欢迎大家指正，一起讨论~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e44d0a8071c6118cf030c4542aef8f9/" rel="bookmark">
			AD altium designer 按照板子外形覆铜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AD全是自学，遇到问题baidu，关于覆铜，之前一直看的视频，全都是选了覆铜自己画线，费劲还画不准确，尤其是异型板子还要直线曲线切来切去，其实大部分时候都是板子所有部分都要覆铜，今天终于找到如何不画线直接按照板子外形覆铜了。
依次点选菜单栏的 工具- 多边形填充-多边形管理器。在出来的窗口中选择 从…创建新的多边形，出来的选项中，选板外形。
3.弹出覆铜的窗口中，选择好覆铜样式，连接的网络等。就OK了。 是不是不用画线感觉爽多了 ？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db1bcf321656bdcb5a842edf38a64ae/" rel="bookmark">
			快速了解时间敏感网络(TSN)_Part1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在过去的几年间，以太网凭借开放的协议、良好的扩展性以及较高的带宽等优势为自己在车载领域赢得了一席之地。随着车载应用范围的扩大，也有越来越多的以太网技术涌现出来。
今天我们就来聊一聊时间敏感网络（TSN），让大家快速了解这一技术。话不多说，大家坐稳扶好，我们这就开始啦~
TSN是什么？它能给我们提供什么？
TSN的全称是Time Sensitive Network即：时间敏感网络（TSN）。大家通过这个名字就大致可以看出其和网络上的时间，更准确的说是传输的延时有关。的确，服务时间敏感应用及系统，保证数据在准确的时间内快速的·抖动进行传输，是TSN的重要目的之一。
随着EE架构的升级，未来架构会向着Domain和Zonal型架构发展，除了影音娱乐域之外，以太网也会被应用到诸如车身域，底盘域，ADAS以及主干网上。更为复杂的应用场景，更多的数据类型将给我们的车载网络提出了更高的要求。
图1 Zonal架构举例 以图1的Zonal架构示意为例，系统在处理传感器数据，发布控制指令等过程中，对于网络提出了很多需求，诸如：
• 低延迟需求：
系统中涉及的一些安全相关类数据，有低延迟和高确定性的需求。
• 高鲁棒性需求：
安全相关类数据对于丢帧或者误传的容忍度很低。系统中对此类数据，通过复制发送和多通路发送来实现冗余处理，以提高系统的安全等级。
• 时间同步需求：
流媒体的同步播放，传感器的数据融合，控制指令的发布都需要车内节点的时钟同步来保证。
• 监控及安全需求：
TBOX的外来数据监控过滤，及车内关键节点数据监控过滤。
表1车载通信数据分类 同时，根据IEEE 的数据，未来车载数据可大致按照表1分类。我们在表中除了可以发现图1提出的需求之外，还可以看到安全相关类数据的延迟需求为小于1ms，而第一代时间敏感网络AVB无法满足这样的延迟需求（目前AVB仅能实现2ms的延时保证，而且AVB并不关注数据的确定性）。
因此为了满足日益增加的网络需求，TSN协议提供了对应的解决办法：
• 高等级的时钟同步 （Time-Sync）
• 更低的端对端延迟及确定性（Quality of Service）
• 高容错性及高系统鲁棒性（Redundancy）
• 安全机制（Security）
图2列举了不同功能下的各个TSN协议。其中，绿色勾选出来的协议是目前在车载方向应用意义较大的协议。我们会在后面的文章中详细地介绍各个协议的机制。
图2 车载TSN协议族 以上用一句话总结：TSN是以太网在车载领域获得更广泛应用的关键。
车载TSN的应用情况
TSN本身的技术成熟度不低，虽然TSN协议在车载领域是一个新的技术，但在工业自动化领域中TSN已经被广泛的应用。目前欧洲的一些大型OEM已经开始应用TSN技术，其中以自动驾驶和辅助驾驶及域间通信等功能为主。预计2022-2023年，将会有整车应用TSN的车型量产。
芯片厂商目前也对TSN协议族有着良好的支持情况，特别是今明两年量产的下一代产品，例如NXP的SJA1110和Marvell的88Q6113等，都将普遍支持TSN协议。
TSN协议介绍
通过上面的介绍，我们已经对TSN是什么有了一个初步的认识。下面我们更进一步，通过协议的机制介绍来了解一下TSN是如何运作的。
总体来看，TSN协议族主体是一个二层的协议，属于IEEE 802.1 协议体系（这里除了帧抢占的部分协议802.3bu以外）。因此其Payload形式可以更加灵活，不仅仅局限于IP数据帧，还可传输自定义的数据帧。同时其机制大部分通过硬件来实现，处理的延迟基本可以忽略不计。
IEEE 802.1AS-Rev 时钟同步机制
时钟同步机制通过节点间同步报文的发送，链路延迟的计算，时滞延迟的叠加最终实现各个节点与主时钟（Grandmaster）的时钟同步。主时钟会通过报文将自己的原始基准时间（now）告知系统中的其它节点。从主时钟发布时间基准到被其他节点收到，会经历一段时间（t）。以图3为例，主时钟与左下角的终端节点进行同步，主时钟从发布基准时间到被终端节点收到所经历的时间t包含：2段链路延迟（d1, d2）以及一个switch的时滞延迟（r1）。当终端节点收到基准时间的时候其实已经是T=now+d1+d2+r1，那么只要终端节点能够清晰的知道d1, d2和r1（通过同步报文交互实现的，这里就不做详细介绍了）并在收到时间基准的时候把自己的时钟设置成T，就完成了与主时钟的同步。同理，其余被同步节点的时钟计算也是一样的，只是同步链路上的时间t会有所不同。
图3 时钟同步应用示意 整个同步的过程基本沿用了IEEE 802.1AS中的机制。但是IEEE 802.1AS-Rev 在原有的同步机制上扩充了冗余机制。以图4为例冗余包括：
• 主时钟冗余：
现行主时钟（左上角）和热备份主时钟（右下角）实时同步，实时运行。一旦主时钟发生问题，控制器可切换到与备份主时钟同步。
• 时钟通路冗余：
每个主时钟维护两条时钟通路（深浅颜色区分），一条发生故障后，可切换至另一条通路。
因此图4中的同步网络总共维护了4个时钟域，相比IEEE 802.1AS车载中中仅维护一个时钟域的设计，Rev极大的提高了系统的可靠性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db1bcf321656bdcb5a842edf38a64ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/735b7acf275e2e10f38b9eb65e16b256/" rel="bookmark">
			JEECG上手使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面数据列表：Datagrid数据列表：AppendGrid数据列表：Online 报表配置用户选择框：UserSelectTag1. 效果图2. 实现代码3. 标签内部实现 导出 Excel: @Excel 注解1. 前端代码2. 后端代码 持久层注解: MiniDao 写在前面 由于之前的一个项目公司外包出去但是没有做好，于是公司打算自己做，使用的是 JEECG 框架，所以用这篇文章记录下使用这个框架的一些总结，刚开始只是随手记，遇到什么写什么，等内容差不多了再分类整理。
文章有点长，可以根据目录查看相应的模块。在文章的右侧工具栏可以快捷地查看目录:
文章写得还不全, 如果没能解决问题, 可以移步 JEECG 官方文档, 不过官方文档格式有些乱。
数据列表：Datagrid Datagrid是 JEECG 生成列表的通用解决方案之一，用户可以根据自己的需求自定义列表展示的效果：
官网文档 对各个参数介绍很详细，这边主要就贴下整体代码（代码生成的页面和上图无关，上图代码在框架的UserController.java类的user()中）：
&lt;!-- 需要引入相关的 tag --&gt; &lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %&gt; &lt;%@include file="/context/mytags.jsp" %&gt; &lt;t:base type="jquery,easyui,tools,DatePicker"/&gt; &lt;div class="easyui-layout" fit="true"&gt; &lt;div region="center" style="padding:0;border:0"&gt; &lt;!-- datagrid 标签中的相关属性说明 actionUrl: 获取数据的地址 rowStyler: 行样式 autoLoadData: 页面初始化的时候自动加载数据 --&gt; &lt;t:datagrid name="userList" checkbox="true" title="用户管理" actionUrl="userController.do?datagrid&amp;user.departId=${departId}" idField="id" sortName="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/735b7acf275e2e10f38b9eb65e16b256/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cdcb14815634d332a7f5baa94e6bbce/" rel="bookmark">
			mysql安装后无法使用mysql命令行的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql安装后，无法使用mysql命令行的问题解决
如： 执行mysql -uroot -p 找不到命令的问题
问题关键：没有配置mysql环境变量！ 这里写下mac电脑用dmg安装无法使用命令行的问题解决步骤
1.首先找到安装到目录
whereis mysql是看不了的因为你本身就没有配置变量
通过find去查找某个文件 find / -name mysql（你知道安装目录最好）
我这是dmg安装的这样看
点击进去查看
2.配置环境变量
注意：有些童鞋变量文件是只读的，无法保存！那么必须执行授权命令
sudo chmod -R 777 /etc/profile
输入你自己的电脑密码（这777是可读，可写，可执行）
vim /etc/profile 打开编辑（编辑直接按 i 插入 ）
环境变量文件添加mysql下bin目录
export PATH=$PATH:/usr/local/mysql/bin
(注意这里要添加你自己的安装目录)
保存退出： 按esc键 输入冒号： wq保存并退出
为了让文件立即生效执行source /etc/profile命令
3.验证mysql的命令是否可使用
打开命令行输入mysql -uroot -p 回车提示输入密码就是成功了
如图：
解释下上面的简单命令 uroot（是用户名为 root） -p（是password）
还可以指定连接的端口，我们这里用默认的3306端口连接
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f88f67ecc49e3fac67f6ace35aafa48/" rel="bookmark">
			centos7查看ip命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装完centos7后用ifconfig查看ip地址提示 ifconfig: 未找到命令，如下图：
经查找资料才发现centOs7没有ifconfig命令，想要查询ip地址需要输入指令：ip add
第二个inet即为虚拟主机的IP地址 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27a5b7303aceab4661f119fa639890a/" rel="bookmark">
			VMware安装系统时&#34;无法创建新虚拟机: 不具备执行此操作的权限&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VMware中安装操作系统时，遇到以下这种情况
问题主要出在虚拟机文件的位置选择上，不应该选在VMware安装的文件夹里，应该重新选择文件夹位置，可以自己新建位置，比如D:\CentOS 7。这样问题就解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bf08410b0fa600a8205995fcc4d204e/" rel="bookmark">
			Golang:中“静态”方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在纯面向对象语言Java 、Python等编程语言中有静态方法。于是有人就会问 Golang中是如何编写静态方法的呢？
答案：Golang 不支持静态方法，完全可以使用 独立func 的方式代替。 如果牵强附会的实现静态方法。如下两种解决问题的方法：
创建一个名为的独立包，并将该方法定义为包中的全局函数。这样，我需要为几个方法创建一个新包。此外，每当我需要这样的静态方法时，我必须定义新的包。定义的结构体StructA，其中包含方法 MethedA（）。另外，定义名为 MyStructA 的全局公共变量，该变量指向struct StructA 的实例。这样，当我需要这个方法时，我可以调用MyStructA.MethedA（）。 如上两种方式都有东施效颦之嫌。
还是按照Golang的一般套路，直接定制 MethedA() 。 纯函数完全可以替代面向对象中的静态方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cccc05f2fdd898d891115a12846eb071/" rel="bookmark">
			IntelliJ IDEA 常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e2818a5d351caed50b0d9fa2f1f728a/" rel="bookmark">
			【深度学习】1、常见模型优化算法原理与项目实践对比（PyTorch实践）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
简介
1、SGD(Stochastic Gradient Descent, SGD)
2、Momentum
3、NAG（Nesterov Accelerated Gradient，NAG）
4、Adagrad
5、RMSProp
6、Adadelta
7、Adam
8、AdaMax
9、Nadam
10、优化算法的使用
11、训练笔记
优化实践对比
简介 在传统的机器学习算法的实践中，优化总是重头戏，也是最考验功底的部分。深度学习得益于传统的有效方式，往往普通的随机下降优化算法就能取得不错的训练效果，优化的重要性相比于传统机器学习要弱一些，大部分从业者主要聚焦于应用或模型创新，而优化部分更多的工作只是调参。
实际上，深度学习优化方面的研究非常多，很多方法也非常有效，尤其在数据量比较大的时候，所以有必要掌握一些常见的优化算法。
1、SGD(Stochastic Gradient Descent, SGD) 随机梯度下降（Stochastic Gradient Descent, SGD）每次训练样本随机抽取一个样本计算loss和梯度并对参数进行更新，由于每次不需要遍历所有的数据，所以每次迭代速度快；但是这种优化算法比较弱，往往容易走偏，反而会增加很多次的迭代。随机梯度下降法有时可以用于在线学习（Online Learning）系统，可使系统快速学习到新的变化。
与随机梯度下降算法对应的还有批量梯度下降（Batch Gradient Descent，BGD），每次使用整个训练集合计算梯度，这样计算的梯度比较稳定，相比随机梯度下降法不那么容易振荡，但是因为每次都需要更新整个数据集，所以批量梯度下降法非常慢，而且无法放在内存中计算，更无法应用于在线学习系统。
介于随机梯度下降法和批量随机梯度下降法之间的是小批量随机梯度下降法（Mini-Batch Gradient Descent），即每次随机抽取m个样本，以它们的梯度均值作为梯度的近似估计值。
为了使得随机梯度下降获取更好的性能，学习率需要取值合理，并根据训练过程动态调整。如果学习率过大，模型就会收敛过快，最终离最优值较远；如果学习率较小，迭代次数就会很多，导致模型长时间不能收敛。
2、Momentum 动量（Momentum）是来自物理学中的定义，是力的时间积累效应的度量。动量的方法在随机梯度下降的基础上，加上了上一步的梯度：
其中γ是动量参数且γ∈[0,1]。动量的优化方法也可以写成如下的形式：
​由于上面两种的表达方式是一致的，所以选择第一种的表达方式。
​相比于随机梯度下降，动量会使相同方向的梯度不断累加，而不同方向的梯度则相互抵消，因而可以一定程度上客服“Z”字形的振荡，更快到达最优点。
3、NAG（Nesterov Accelerated Gradient，NAG） Nesterov 加速梯度于动量类似，也是考虑最近的梯度的情况，但是NAG相对超前一点，它先使用动量mt计算参数θ下一个位置的近似值θ+ηmt，然后在近似位置上计算梯度：
​NAG与动量法的区别就是，NAG算法会计算本轮迭代时动量到达的位置的梯度，可以说成“未来”的梯度。如果未来的梯度存在一定的规律，那么这些梯度就会有更好的利用价值。
​在实际的应用中，为了前向、后向计算统一，引入以下爱的变量：
将上面的两个公式代入，可以得到：
将上面的第一个公式代入第二个公式，就可以得到：
整理可以得到：
这样梯度计算就可以解决计算不一致的问题。
4、Adagrad ​Adagrad是一种自适应的梯度下降法，它能够针对参数更新的频率调整它们的更新幅度——对于更新频繁且更新量大的参数，适当减小他们的步长；对于更新不频繁的参数，适当增大它们的步长。这种方法的思想很适合一些数据分布不均匀的任务。
​具体的方法就是在之前的梯度下降法的基础上增加一个梯度的累积项作为分母，之前的梯度下降法的更新公式为：
而Adagrad变成：
其中⊙表示向量之间元素级的乘法，Gt就是Adagrad增加的内容。它是所有轮迭代的梯度平方和：
从公式可以看出，加入这一下项以后，参数的更新确实得到了一定的控制。对于经常更新的参数，Gt项的数值会比较大，因而它的参数更新量会得到控制；对于不经常更新的参数，由于Gt项的数值比较小，它的参数更新量会变大。
从算法里面可以看出，Adagrad依然存在一些缺陷，如果模型的参数数值保持稳定，那么参数的梯度值总体不会有太大的波动，而分母上的梯度积累项一直在积累，因此分母会不断变大，因此从梯度的趋势上分析，梯度总值会不断减小。虽然在实际训练中一般也会将学习率调小，但两者变小的程度不同，因此Adagrad可能会出现更新量太小而不易优化的情况。
5、RMSProp RMSProp利用滑动平均的方法来解决Adagrad算法中的问题。它的思路是让梯度积累值G不要一直变大，而是按照一定的比例衰减，这样其含义就不再是梯度的积累项了，而是梯度的平均值：
因为此时的G更像是梯度的平均值甚至期望值，因此在很多文献中会将G写成E[g2]。
6、Adadelta Adadelta考虑了一些更新量“单位”的问题。为了让“单位”匹配，Adadelta选择在分子上再增加一个项目，于是方法的概念公式变成：
其中RMS表示Root Mean Square，也就是“均方根”的意思。分母中的RMS[g]t展开与RMSProp相同：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e2818a5d351caed50b0d9fa2f1f728a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73619cef184c911ac62119c66c2e4337/" rel="bookmark">
			阻塞IO和非阻塞IO的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阻塞IO和非阻塞IO的区别 阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作。阻塞指的是用户空间程序的执行状态。传统的IO模型都是同步阻塞IO。再Java中，默认创建的socket都是阻塞的。
非阻塞IO，指的是用户空间的程序不需要等待内核IO操作彻底完成，可以立即返回用户空间执行用户操作，即处于非阻塞的状态，与此同时内核会立即返回给用户一个状态值。
简单来说：阻塞是指用户空间（调用线程）一直在等待，而不能干别的事情；非阻塞是指用户空间（调用线程）拿到内核返回的状态值就返回自己的空间，IO操作可以干就干，不可以干，就去干别的事情。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99078f8df0284f131cf27a2fcf27ce77/" rel="bookmark">
			Latex排版的时候把图片放在指定位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先引入宏包：\usepackage{float}
在需要插图的地方画图的时候加上一个[H]。
如：
\begin{figure}[H] \centering \includegraphics[scale=0.25]{CAE} \caption{The proposed auto-encoder}\label{CAE} \end{figure} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6975b439d8d1ddbe64c26c1388ac6d2/" rel="bookmark">
			Android Studio;Error:No such property: GradleVersion for class: JetGradlePlugin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景：从项目中拿到一个客户的demo工程，或者导入一个别人的工程，编译时出现 Error:No such property: GradleVersion for class: JetGradlePlugin：
原因：这是gradle的版本太高导致的
解决办法：
第一步：打开工程的build.gradle，注意不是app/build.gradle
第二步：修改dependencies
第三步：打开工程的gradle/wrapper/gradle-wrapper.properties:
第四步：修改distributionUrl，注意这个版本要和第二步中的版本对应，可参考下面改至相应版本，想了解更多关于gradle的知识可参考 Gradle的相关知识
注：如果还是不行，建议新建一个工程，我的话按照上面的步骤弄了好久还是没有用，于是把工程删了。重新解压出一个工程，重新按照上述操作就Ok了
如有不当，欢迎指正
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d3ce650140dded4fbe7080ca55c3fa/" rel="bookmark">
			java -方法入门 流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法入门 方法： 将一个功能抽取出来，把代码单独定义在一个大括号中，形成一个单独的功能
当我们需要这个功能的时候，就可以去调用，这样既实现了代码的复用性，也解决了代码的冗余问题定义： 修饰符 返回值类型 方法名 (参数) { 代码... return; } 方法名称的命名规则和变量名一样，使用小驼峰
方法体：也就是大括号中的，可以包含多条语句
注意事项：
1. 方法定义的先后顺序无所谓
2. 方法的定义不能产生嵌套包含关系 (定义一个方法中不能再定义一个方法，python可以)
3. 方法定义好后不会执行，如果需要执行，一定要进行方法的调用
调用 格式： 方法名称(); JShell脚本工具 jdk9.0以上才有
进入 cmd中输入JShell
退出: /exit
类似于 python的命令行输入语句后可以直接获取结果，不用编译
流程 顺序结构: 从上往下执行 public class Demo01Sequence{ public static void main(String[] args){ System.out.println("1"); System.out.println("2"); System.out.println("3"); System.out.println("4"); } } 判断结构 if语句 单if 语句
java if (关系表达式){ 语句体; }
流程图
public class Demo02If { public static void main(String[] args){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62d3ce650140dded4fbe7080ca55c3fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5da931eceb7d977cf69c6dfd4164fad8/" rel="bookmark">
			MATLAB 散点数据拟合曲线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Matlab是一个很强大的数据处理软件，是人们进行数据分析的得力助手。一般我们做社会调研或科学研究时，会得到很多实验数据。当需要研究两个变量之间的关系时，经常要用到曲线拟合。曲线拟合不仅能给出拟合后的关系式，还能用图形直观的展现出变量之间的关系。 其实用matlab做曲线拟合很便捷，下面将以两个变量(y=f(x))为例详细介绍。
1、运行Matlab软件。
在工作空间中存入变量的实验数据。具体如下：
可以直接用矩阵来存放数据，直接在命令窗口输入
x=[数据x1，数据x2，...,数据xn];
y=[数据y1，数据y2，...,数据yn];
当数据较多时，可以从excel，txt等文件中导入。
2、把数据存入工作空间后，在命令窗口中输入cftool,回车运行。
3、在这个拟合工具窗口的左边，选择变量，即分别选择x,y。
4、选择拟合的曲线类型，一般是线性拟合，高斯曲线，平滑曲线等，根据需要选择。
选择完后会自动完成拟合，并且给出拟合函数表达式。
5、点击菜单栏中的“file”，选择“print to figure"进行画图。
6、在图形窗口中，可以对图形显示模式进行修改，如添加标题，坐标名称等。
7、最后得到比较完整的图形曲线。点击”file"中的“save"进行保存。
这个过程中有一个注意事项：x和y的数据维度必须保持一致。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/189f77a66c8cddcc7c1d51a2bc645279/" rel="bookmark">
			Apache Tomcat 文件包含漏洞（CNVD-2020-10487，对应 CVE-2020-1938）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020 年 1 月 6 日，国家信息安全漏洞共享平台（CNVD）收录了由北京长亭科技有限公司发现并报送的 Apache Tomcat 文件包含漏洞（CNVD-2020-10487，对应 CVE-2020-1938）。攻击者利用该漏洞，可在未授权的情况下远程读取特定目录下的任意文件。目前，漏洞细节尚未公开，厂商已发布新版本完成漏洞修复。
一、漏洞情况分析
Tomcat 是 Apache 软件基金会 Jakarta 项目中的一个核心项目，作为目前比较流行的 Web 应用服务器，深受 Java 爱好者的喜爱，并得到了部分软件开发商的认可。Tomcat 服务器是一个免费的开放源代码的 Web 应用服务器，被普遍使用在轻量级 Web 应用服务的构架中。
2020 年 1 月 6 日，国家信息安全漏洞共享平台（CNVD）收录了由北京长亭科技有限公司发现并报送的 Apache Tomcat 文件包含漏洞。Tomcat AJP 协议由于存在实现缺陷导致相关参数可控，攻击者利用该漏洞可通过构造特定参数，读取服务器 webapp 下的任意文件。若服务器端同时存在文件上传功能，攻击者可进一步实现远程代码的执行。
CNVD 对该漏洞的综合评级为“高危”。
二、漏洞影响范围
漏洞影响的产品版本包括：
Tomcat 6
Tomcat 7
Tomcat 8
Tomcat 9
CNVD 平台对 Apache Tomcat AJP 协议在我国境内的分布情况进行统计，结果显示我国境内的 IP 数量约为 55.5 万，通过技术检测发现我国境内共有 43197 台服务器受此漏洞影响，影响比例约为 7.8%。
三、漏洞处置建议
IT之家了解到，目前，Apache 官方已发布 9.0.31、8.5.51 及 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/189f77a66c8cddcc7c1d51a2bc645279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f9f2525927b37f6570477e3ba82297/" rel="bookmark">
			走楼梯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 02 走楼梯 描述 树老师爬楼梯，他可以每次走1级或者2级，输入楼梯的级数，求不同的走法数
例如：楼梯一共有3级，他可以每次都走一级，或者第一次走一级，第二次走两级
也可以第一次走两级，第二次走一级，一共3种方法。
输入 输入包含若干行，每行包含一个正整数N，代表楼梯级数， 1 &lt; = N &lt; = 30 1 &lt;= N &lt;= 30 1&lt;=N&lt;=30
输出 不同的走法数，每一行输入对应一行输出
样例输入 5 8 10 样例输出 8 34 89 分析 ​ 我们可以使用递归来分解问题，使之逐步简化成更多的小问题。简而言之，我们是要发现问题之间的递推关系，一个问题是否可以分解成多种情况下的其他同类小问题，并逐步分化。然后我们要找到一个或者多个最简问题，这个最简问题就是分解的最终形式，其解必须显而易见，其也是递归的终止条件
​ 本题中，走N级台阶，可以从第一步开始分析。如果第一步走1级，则余下的走法是走剩下N-1级台阶的走法。同理如果第一步走2级，则余下的走法是走剩下N-2级的走法。我们可以发现递推关系： f ( n ) = f ( n − 1 ) + f ( n − 2 ) f(n)=f(n-1)+f(n-2) f(n)=f(n−1)+f(n−2)。最终只剩下2级台阶时，有2种走法。只剩下1级台阶时，有1种走法。
代码实现 #include&lt;iostream&gt; using namespace std; int main() { int f(int n); int n; while (cin &gt;&gt; n) { cout &lt;&lt; f(n)&lt;&lt;endl; } } int f(int n) { if (n == 1)return 1; else if (n == 2)return 2; else return f(n - 1) + f(n - 2); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c0a7dcc1f8bf97e4a4b4d84099a7488/" rel="bookmark">
			编译mqtt_client及遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译好mqtt_c 和 mqtt_cpp 的库之后，进行一下测试。
用VS2015编译的32位debug和release，并将c库和cpp库，所以用VS2015建一个win32控制台工程，空项目。
debug和release各自配置各自的lib路径。include和mqtt 都包含进去都是.h文件。
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; #include "mqtt\async_client.h" int main(int argc, char* argv[]) { const std::string TOPIC{ "hello" }; const std::string CLIENT_ID{ "user" }; const std::string ADDRESS{ "127.0.0.1:1883" }; //这里写服务器的IP const int QOS = 1; const char * PAYLOAD = { "Hello World!" }; // Create a client mqtt::async_client cli(ADDRESS, CLIENT_ID); mqtt::connect_options connOpts; connOpts.set_keep_alive_interval(20); connOpts.set_clean_session(true); try { std::cout &lt;&lt; "Connecting to the MQTT server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c0a7dcc1f8bf97e4a4b4d84099a7488/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0a8c447d9c3cd4bd9f49f27bf132794/" rel="bookmark">
			[论文解读]FCN&#43;与CNN的区别&#43;三大技术&#43;网络结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文下载地址 :https://arxiv.org/pdf/1411.4038.pdf
原作代码 :https://github.com/shelhamer/fcn.berkeleyvision.org
备注: 此文的FCN特指&lt;&lt;Fully Convolutional Networks for Semantic Segmentation&gt;&gt;论文中提出的结构，而非广义的全卷积网络。
一、介绍 1.1FCN 关于图像分割的算法,传统有很多(关于图像分割的历史), 而全卷积神经网络(FCN, FullyConvolutionalNetwork) 是第一次将端到端的卷积网络推广到了语义分割的任务当中，随后出现了很多成功的图像分割深度学习技术都是基于 FCN 实现的网络结构，比如 U-Net 等
1.2网络结构 FCN-32s
FCN-16s
FCN-8s
1.3 CNN 和 FCN 的区别 关于两者的区别, 这篇文章总结的不错
我们知道, 通常CNN网络在卷积层之后会接上若干个全连接层, 将卷积层产生的特征图(feature map)映射成一个固定长度的特征向量。以AlexNet为代表的经典CNN结构适合于图像级的分类和回归任务，因为它们最后都期望得到整个输入图像的一个数值描述（概率），比如AlexNet的ImageNet模型输出一个1000维的向量表示输入图像属于每一类的概率(“全连接层 + softmax归一化”的结构)。
下图中的猫, 输入AlexNet网络中, 经过后面的全连接层后得到一个长为1000的输出向量, 再加上softmax归一化后即可以表示输入图像属于每一类的概率, 其中在“tabby cat”这一类统计概率最高。
这个概率信息是1维的，即只能标识整个图片的类别，不能标识每个像素点的类别，所以这种全连接方法不适用于图像分割。
CNN一般用作图像级的分类,而FCN可以对图像进行像素级的分类，从而解决了语义级别的图像分割（semantic segmentation）问题。与经典的CNN在卷积层之后使用全连接层得到固定长度的特征向量进行分类（全联接层＋softmax输出）不同，FCN可以接受任意尺寸的输入图像，采用反卷积层对最后一个卷积层的feature map进行上采样, 使它恢复到输入图像相同的尺寸，从而可以对每个像素都产生了一个预测, 同时保留了原始输入图像中的空间信息, 最后在上采样的特征图上进行逐像素分类(最后逐个像素计算softmax分类的损失, 相当于每一个像素对应一个训练样本).如下图所示
(PACSAL数据集有20个类别+background=21)
简单的来说，FCN与CNN的区域在把于CNN最后的全连接层换成卷积层，输入一张原始图,输出的是一张已经Label好的图片,做到了端到端.
其实，CNN的强大之处在于它的多层结构能自动学习特征，并且可以学习到多个层次的特征：
较浅的卷积层感知域(感受野)较小，学习到一些局部区域的特征；较深的卷积层具有较大的感知域(感受野)，能够学习到更加抽象一些的特征。 这些抽象特征对物体的大小、位置和方向等敏感性更低，从而有助于识别性能的提高。下图CNN分类网络的示意图：
这些抽象的特征对分类很有帮助，可以很好地判断出一幅图像中包含什么类别的物体，但是因为丢失了一些物体的细节，不能很好地给出物体的具体轮廓、指出每个像素具体属于哪个物体，因此做到精确的分割就很有难度。
而传统的基于CNN的分割方法：为了对一个像素分类，使用该像素周围的一个图像块作为CNN的输入用于训练和预测。这种方法有几个缺点：
一是存储开销很大。例如对每个像素使用的图像块的大小为15x15，然后不断滑动窗口，每次滑动的窗口给CNN进行判别分类，因此则所需的存储空间根据滑动窗口的次数和大小急剧上升。二是计算效率低下。相邻的像素块基本上是重复的，针对每个像素块逐个计算卷积，这种计算也有很大程度上的重复。三是像素块大小的限制了感知区域的大小。通常像素块的大小比整幅图像的大小小很多，只能提取一些局部的特征，从而导致分类的性能受到限制。 而全卷积网络(FCN)则是从抽象的特征中恢复出每个像素所属的类别。即FCN从图像级别的分类进一步延伸到像素级别的分类。
CNN做图像分类、目标检测的效果已经被证明并广泛应用, 而很多成功的图像分割深度学习技术都是基于 FCN 实现
二、3 大技术 全卷积神经网络主要使用了三种技术：
卷积化（Convolutionalization）: 适应任意尺寸输入，输出低分辨率的分割图片。反卷积 : 低分辨率的图像进行上采样，输出同分辨率的分割图片跳跃结构（跳跃层、Skip Layer）: 结合上采样和上层卷积池化后数据，填补丢失的细节数据, 修复还原图像 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0a8c447d9c3cd4bd9f49f27bf132794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a81ed681dc8f3e346de25a2b308f112a/" rel="bookmark">
			python正则表达式(\S&#43;)和 \d&#43;的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在jenkins jaoco生成增量覆盖率功能时：
研读的一个python通过python-git获取diff时，碰到了这两个正则符号：(\S+)、(\d+)
https://github.com/raoweijian/jacoco-diff/blob/master/diff_processor.py
下面是找到的符号的说明：
\d+的出处：
https://books.google.com.hk/books?id=T5ncDgAAQBAJ&amp;pg=PA192&amp;lpg=PA192&amp;dq=re.match(%27@@+-%5Cd%2B,%5Cd%2B+%5C%2B(%5Cd%2B),%5Cd%2B+@@%27,+line):&amp;source=bl&amp;ots=FrgzHyhsYi&amp;sig=ACfU3U0Ex9AAolnnuDbQTzqw2mcvUHMkyQ&amp;hl=zh-CN&amp;sa=X&amp;ved=2ahUKEwjgm5u7muLnAhWS7GEKHZLSCDEQ6AEwBHoECAkQAQ#v=snippet&amp;q=%5Cd&amp;f=false
书名：Learning R Programming
下面是（\S+）的说明：
来源：https://www.ntu.edu.sg/home/ehchua/programming/howto/Regexe.html
摘录： 1.10 Example: Swapping Words using Parenthesized Back-References ^(\S+)\s+(\S+)$ and $2 $1 The ^ and $ match the beginning and ending of the input string, respectively. The \s (lowercase s) matches a whitespace (blank, tab \t, and newline \r or \n). On the other hand, the \S+ (uppercase S) matches anything that is NOT matched by \s, i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a81ed681dc8f3e346de25a2b308f112a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/446/">«</a>
	<span class="pagination__item pagination__item--current">447/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/448/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>