<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ada073b9de0cbeb739fa92fc23090f40/" rel="bookmark">
			JS中定义一个二维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JS中定义一个二维数组 方法一
var _TheArray = [["0-1","0-2"],["1-1","1-2"],["2-1","2-2"]];//定义了一个3*2的二维数组 方法二
var tArray = new Array(); //先声明一维 for(var k=0;k&lt;i;k++){ //一维长度为i,i为变量，可以根据实际情况改变 tArray[k]=new Array(); //声明二维，每一个一维数组里面的一个元素都是一个数组 } 方法三
var data = []; data.push(['华南'，‘广东’]); data.push(['华北'，‘河北’]); ...... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083e182451abdda274fcec6c96b573e4/" rel="bookmark">
			UML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 类关系 参考：http://blog.csdn.net/dragonpeng2008/article/details/6836448
关系: 泛化（Generalization）, 实现（Realization）, 关联（Association), 聚合（Aggregation）, 组合(Composition), 依赖(Dependency)
泛化（Generalization） 【泛化关系】：是一种继承关系, 表示一般与特殊的关系, 它指定了子类如何特化父类的所有特征和行为. 例如：老虎是动物的一种, 即有老虎的特性也有动物的共性. 【箭头指向】：带三角箭头的实线，箭头指向父类
实现（Realization） 【实现关系】：是一种类与接口的关系, 表示类是接口所有特征和行为的实现. 【箭头指向】：带三角箭头的虚线，箭头指向接口
关联（Association) 【关联关系】：是一种拥有的关系, 它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子 关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者
聚合（Aggregation） 【聚合关系】：是整体与部分的关系, 且部分可以离开整体而单独存在. 如车和轮胎是整体和部分的关系, 轮胎离开车仍然可以存在. 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 【代码体现】：成员变量 【箭头及指向】：带空心菱形的实心线，菱形指向整体
组合(Composition) 【组合关系】：是整体与部分的关系, 但部分不能离开整体而单独存在. 如公司和部门是整体和部分的关系, 没有公司就不存在部门. 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体
依赖(Dependency) 【依赖关系】：是一种使用的关系, 即一个类的实现需要另一个类的协助, 所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者
各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 下面这张UML图，比较形象地展示了各种类图关系： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a164e754815f06a20176407d67e745/" rel="bookmark">
			修改Eclipse因为系统权限异常：permission is only granted to system apps
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 permission is only granted to system apps 在AndroidManifest.xml中使用了如下的配置：&lt;uses-permission android:name="android.permission.INSTALL_PACKAGES" /&gt; 或者&lt;uses-permission android:name="android.permission.PACKAGE_USAGE_STATS" /&gt;就会报错：Permission is only granted to system apps。原因是此类权限仅授予系统级应用 解决方法如下： 依次点击菜单windows–&gt;perferences。如图所示： 展开“Android”菜单，点击“Lint Error Checking”。 找到ID = ProtectedPermission的选项并选择，然后设置Serverity低于Error，比如Warning级别就好了。如图所示： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c763fc95f781b350ccb9599ac8d5b2/" rel="bookmark">
			REMODE&#43;ORBSLAM运行配置（1）   把ORB编译成ROS工程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原版的ORBSLAM是一个cmake工程，由于项目的需要，我们要在其他ROS工程（简称A）和ORB工程进行通讯，即需要将这两个工程联编，这就有两个办法：
方法一：把A工程修改成一个cmake工程，然后和ORB联编，利用多线程完成通信。
方法二：把ORB修改成ROS工程，编程成一个节点，和A工程利用ros节点进行通信。
权衡了一下修改的复杂程度以及考虑到ROS的优点，选择了方案二。
下面开始记录修改步骤：
1：找一块地方，新建一个工程，简称ORB_ROS
1.1创建了如上的文件结构，并进入最内层src目录。所有的ros包都要放入到这里面进行编译。
baohua@baohua-ThinkPad-S5:~$ mkdir -p ORB_ROS/catkin_ws/src&amp;&amp;cd ORB_ROS/catkin_ws/src 1.2创建出ORB_SLAM包
baohua@baohua-ThinkPad-S5:~/ORB_ROS/catkin_ws/src$ catkin_create_pkg ORB_SLAM进入到ORB_SLAM包里，你会看到有两个文件： 一个是ROS版本的CMakeLists.txt，另一个是package.xml文件。这两个文件由catkin_create_pkg自动生产。但是，我们在执行catkin_creat_pkg ORB_SLAM时，里面什么都没有，所以我们要根据原来ORBSLAM工程的CMakeLists.txt修改包内的CMakeLists.txt，
另外，catkin_creat_pkg的指令格式其实是：catkin_creat_pkg &lt;package name&gt; [depend1]...[dependn] ,我们刚才创建ORB_SLAM时并没有添加任何ROS依赖depend，因为在生成package.xml后手动添加ROS依赖depend更方便。所以，我们还要根据新编译的工程将会对ROS的依赖修改package.xml文件。关于package.xml文件是什么，请参考ROSwiki。
2 将原来的ORB工程中除了其自身的CMakeLists后的其他文件拷贝进入第一步创建的ORB_SLAM包内。然后，修改包内的package.xml和CMakeLists.txt。
2.1 修改package.xml
package.xml文件有分为几个部分：分别是工程名版本信息，作者维护者信息，license，以及编译依赖(build_depend) 和运行依赖(run_depend)。
我们只关心编译依赖(build_depend) 和运行依赖(run_depend)，其他信息对编译代码没有什么影响。
&lt;!-- Dependencies which this package needs to build itself. --&gt; &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt; &lt;!-- Dependencies needed to compile this package. --&gt; &lt;build_depend&gt;roscpp&lt;/build_depend&gt; &lt;build_depend&gt;cmake_modules&lt;/build_depend&gt; &lt;!-- for FindEigen.cmake module --&gt; &lt;build_depend&gt;nav_msgs&lt;/build_depend&gt; &lt;build_depend&gt;std_msgs&lt;/build_depend&gt; &lt;build_depend&gt;visualization_msgs&lt;/build_depend&gt; &lt;build_depend&gt;sensor_msgs&lt;/build_depend&gt; &lt;build_depend&gt;image_transport&lt;/build_depend&gt; &lt;build_depend&gt;cv_bridge&lt;/build_depend&gt; &lt;build_depend&gt;tf&lt;/build_depend&gt; &lt;build_depend&gt;svo&lt;/build_depend&gt; &lt;build_depend&gt;svo_msgs&lt;/build_depend&gt; &lt;build_depend&gt;vikit_common&lt;/build_depend&gt; &lt;build_depend&gt;vikit_ros&lt;/build_depend&gt; &lt;!-- Dependencies needed after this package is compiled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c763fc95f781b350ccb9599ac8d5b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1da25b54a38398d999bd8d0c8b8eb506/" rel="bookmark">
			C# 获取毫秒时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 //获取时间戳 private string GetTimeStamp() { DateTime t = DateTime.Now; return t.ToString("yyyMMddhhmmssfff"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c21fb8eebbed979317cde6ba667ee71/" rel="bookmark">
			傅立叶变换学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空间域和频率域为我们提供了不同的视角． 在空域中． 函数的自变量（x, y）被视为二维空间中的一点， 数字图像J(x, y）即为一个定义在二维空间中的矩形区域上的离散函数：换一个角度， 如果将j(x, y）视为幅值变化的二维信号， 则可以通过某些变换手段（如傅立叶变 换、离散余弦变换、沃尔什变换和小波变换等〉在频域下对它进行分析．
本文主要包括以下内容 傅立叶变换的数学基础快速傅立叶变换本章的典型案例分析 美女与猫一－交换两幅图像的相位谱 频率域滤波一一与空间域滤波殊途同归 在多数情况下， 频率域滤波和空间域滤披可以视为对同一个图像增强问题的殊途同归的 两种解决方式． 而在另外一些情况下， 有些增强问题更适合在频域中完成（6.7节〉， 有些则 更适合在空域中完成． 我们常常根据需要选择是工作在空间域还是频率域， 并在必要时在这 两者之间相互转换． 傅立叶变换提供了一种变换到频率域的手段， 由于用傅立叶变换表示的函数特征可以完 全通过傅立叶反变换进行重建而不丢失任何信息， 因此它可以使我们工作在频率域而在转换 回空域时不丢失任何信息． 傅立叶变换在图像处理中的应用 理解了以下俩点：
图片是波，这个波可以看成N个正弦，余弦波的叠加 大自然中的各种信号的大部分信息都集中在低频，而且人眼对低频更敏感 就很容易明白傅立叶变换在图像处理中的应用。
在去噪上的原理和缺陷： 当图像出现的噪声是有规律的，相当于让某个频率波的幅度增大，把这个值减小，就是去掉这个频率的波，所以可以去噪，比如高斯噪声。当出现的噪声是没有规律的，随机出现的一些东西，FT是没有作用的。在图片压缩方面，根据傅立叶变换推导出的DCT有很重要作用。JPEG格式的图片就是用Huffman编码方式压缩图片的DCT的系数。 傅立叶变换基础知识 通俗解释 到底什么是傅立叶级数 如何理解傅里叶变换公式? 如果看了此文你还不懂傅里叶变换，那就过来掐死我吧
傅立叶级数 法国数学家傅立叶发现任何周期函数只要满足一定条件（狄利赫里条件〉都可以用正弦函数和余弦函数构成无穷级数，即以不同频率的正弦和余弦函数的加权和来表示，后世称为:傅立叶级数。 对于有限定义域的非周期函数，可以对其进行周期拓延从而使其在整个扩展定义域上为周期函数，从而也可以展开为傅立叶级数． 傅立叶级数的复指数形式 除上面介绍的三角形式外，傅立叶级数还有其他两种常用的表现形式，即余弦形式和复指数形式。借助欧拉公式，上述3种形式可以很方便地进行等价转化，本质上它们都是一样的。 复指数傅立叶级数即我们经常说的傅立叶级数的复数形式，因具有简洁的形式〈只需一个统一的表达式计算傅立叶系数〉，在进行信号和系统分析时通常令更易于使用：而余弦傅立叶级数可使周期信号的幅度谱和相位谱意义更加直观，函数的余弦傅立叶级数展开可以解释为f(x）可以由不同频率和相位的余弦披以不同系数组合在一起来表示，而在三角形式中相位是隐藏在系数Dn和bn中的。下面主要介绍复指数傅立叶级数，在后面的傅立叶变换中要用到的正是这种形式，关于余弦傅立叶级数的有关知识，感兴趣的读者请参考附录。 由式（6-4）和（6-5）可见，复指数傅立叶级数形式比较简洁，级教和系数都可以采用统一的公式计算．有关如何由式（6-1）推导出傅立叶级数复指数形式（6-4）的过程，由于这里我们感兴趣的井非傅立叶级数本身，因此不在正文中给出，详细的内容可参考附录。只要读者理解不同的展开形式其本质上是等价的，并对复指数形式的傅立叶级数展开建立了一个基本的形式上的认识就足以继续阅读和理解后述内容。 傅立叶变换 式（6-6）和式（6-7） 即为我们通常所说的傅立叶变换对，6.1节中提到的函数可以从它的反变换进行重建正是基于上面的傅立叶变换对。 由于傅立叶变换与傅立叶级数涉及两类不同的函数，在很多数字图像处理的书中通常对它们分别进行处理，并没有阐明它们之间存在的密切联系，这给很多初学者带来了困扰，实际上我们不妨认为周期函数的周期可以趋向无穷大，这样可以将傅立叶变换看成是傅立叶级数的推广。 仔细的观察式（6-6）和式（6-7），对比复指数形式的傅立叶级数展开公式〈式6-4）， 可以发现这里傅立叶变换的结果F(u）实际上相当于傅立叶级数展开中的傅立叶系数，而反变换公式（式6-7） 则体现出不同频率复指数函数的加权和的形式，相当于复指数形式的傅立叶 级数展开公式，只不过这里的频率u变为连续化，所以加权和采用了积分的形式。这是因为随着式（6－5)的积分上下限的T向整个实数定义域扩展，即T→∞，频率u则趋近于du （因为u= 1/T），导致原来离散变化的u的连续化． 显然，这是f(x,y）各个像素的灰度之和。而如果将系数1/MN放在正变换之前， 则F(O, 0)对应于原因像f(x, y） 的平均灰度。F(O, 0）有时被称作频谱的直流分量（DC）。 我们之前曾指出一维函数可以表示为正弦〈余弦〉函数的加权和形式：类似的， 二维函数f(x,y)可以分解为不同频率的二维正弦〈余弦〉平面波的按比例叠加。
幅度谱、相位谱和功率谱 幅度谱又叫频率谐，是图像增强中关心的主要对象，频域下每一点(u,v)的幅度F(u,v)可用来表示该频率的正弦〈余弦）平面放在叠加中所占的比例，如图6.4所示．幅度谱直接反映频率信息，是频域滤波中的一个主要依据。 相位谱表面上看并不那么直观，但它隐含着实部与虚部之间的某种比例关系， 因此与图像结构息息相关。 因为对于和空域等大的频域空间下的每一点(u,v)， 均可计算一个对应的|F(u,v)|和|U(u,v)|，所以可以像显示一幅图像那样显示幅度谱和相位谱。 冈萨雷斯版&lt;图像处理&gt;里面的解释非常形象：一个恰当的比喻是将傅里叶变换比作一个玻璃棱镜。棱镜是可以将光分解为不同颜色的物理仪器，每个成分的颜色由波长（或频率）来决定。傅里叶变换可以看作是数学上的棱镜，将函数基于频率分解为不同的成分。当我们考虑光时,讨论它的光谱或频率谱。同样, 傅立叶变换使我们能通过频率成分来分析一个函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c21fb8eebbed979317cde6ba667ee71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b47b7a6a8e5af55b38978664647bba2c/" rel="bookmark">
			cmake使用方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 基本使用 安装：下载二进制包后可直接解压使用
从源码安装则执行命令：./bootstrap; make; make install——尝试执行bootstrap失败
使用：cmake dir_path，生成工程文件或makefile文件
二、 概念 out-of-source build，与in-source build相对，即将编译输出文件与源文件放到不同目录中；
三、 基本结构 1，依赖CMakeLists.txt文件，项目主目标一个，主目录中可指定包含的子目录；
2，在项目CMakeLists.txt中使用project指定项目名称，add_subdirectory添加子目录
3，子目录CMakeLists.txt将从父目录CMakeLists.txt继承设置（TBD，待检验）
四、 语法 1. #注释
2. 变量：使用set命令显式定义及赋值，在非if语句中，使用${}引用，if中直接使用变量名引用；后续的set命令会清理变量原来的值；
3. command (args ...) #命令不分大小写，参数使用空格分隔，使用双引号引起参数中空格
4. set(var a;b;c) &lt;=&gt; set(var a b c) #定义变量var并赋值为a;b;c这样一个string list
5. Add_executable(${var}) &lt;=&gt; Add_executable(a b c) #变量使用${xxx}引用
6. 条件语句：
if(var) #var 非empty 0 N No OFF FALSE... #非运算使用NOT
…
else()/elseif() … endif(var)
7. 循环语句
Set(VAR a b c)
Foreach(f ${VAR}) …Endforeach(f)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b47b7a6a8e5af55b38978664647bba2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e68c65c3c88d32c81d14f5107fcb888c/" rel="bookmark">
			ROS节点与运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，先明确一下与节点相关术语的含义：
Nodes：节点，一个节点即为一个可执行程序，它可以通过ROS与其他节点通信，另外，一个catkin程序包里可以有很多节点。
Messages：消息，消息是一种ROS数据类型，用于订阅或发布到一个话题，是一个载体。
Topics：话题，节点可以向话题发布消息或可以向话题订阅消息，像通信中转站一样。
Master：节点管理器，ROS名称服务。
rosout：相当于std::cout
roscore：是在运行所有ROS程序前首先要运行的命令。
运行ros节点的方法：
一般有两种：
第一种：使用rosrun,在设置完环境变量后，可以使用包名来直接运行一个包内的节点。
用法：
$rosrun [package_name] [node_name] 注意：这种方法需要新打开一个终端 运行
$roscore 第二种：使用roslaunch
用法：
$roslaunch [package] [fliename.launch] launch是个文件，用launch文件来运行程序相对于rosrun的优点有两个
&lt;1&gt;可以向程序传参
&lt;2&gt;可以同时运行多个节点
launch文件结构
&lt;launch&gt; &lt;!--第1个节点--&gt; &lt;node pkg="" type="" name=""&gt; &lt;!--注释内容--&gt; &lt;para name="程序中的数值或布尔参数" value="" /&gt; &lt;para name="程序中的字符串参数" value=" " type="str" /&gt; ... &lt;node&gt; ... &lt;!--第n个节点--&gt; &lt;node pkg="" type="" name=""&gt; &lt;!--注释内容--&gt; ... &lt;node&gt; &lt;/launch&gt; 注意：
&lt;1&gt;pkg:应该填写实际工程中的包名
&lt;2&gt;type:填写对应CMakeLists里add_executable 生成的binary名字。
&lt;3&gt;name：这个随便写，只要符合ros命名规则就行，这个名字在运行时（roslunch 。。）会出现在终端里。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a8b5b25adafade5ee461917b0729e8/" rel="bookmark">
			ROS  catkin工作空间的程序包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 catkin程序包的组成
必须包含：
package.xml //提供程序包的元信息（包括包的依赖信息）
catkin版本的CMakeLists.txt 每个目录下只能有一个程序包，即程序包不能嵌套，也不能并行。
最简单的程序包
my_package/ -CMakeLists.txt -Package.xml2 catkin工作空间的程序包 一个catkin工作空间可能含有多个程序包，如下结构：
catkin_workspace/ -src -CMakeLists.txt //顶层CMakeLists,由catkin_init_workspace 提供 -Package_1 .. -CMakeLists.txt -Package.xml ... -Package_n .. -CMakeLists.txt -Package.xml 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d9ea30923010da54ca1b4f1eb4befff/" rel="bookmark">
			ROS 节点通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"节点(Node)" 是ROS中指代连接到ROS网络的可执行文件的术语。接下来，我们将会创建两个节点，一个是发布器节点("talker")，它将不断的在ROS网络中广播消息;另一个是接收节点("listener"),从ROS网络中接收("talker")节点发送的信息。
//发布节点
#include "ros/ros.h" #include "std_msgs/String.h" int main(int argc, char **argv) { ros::init(argc, argv, "talker");//创建发布消息的节点。名字为talker ros::NodeHandle n;//为这个进程的节点创建一个句柄。 ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;("chatter", 1000); /*告诉master我们将要在chatter topic上发布一个std_msgs/String的消息。这样master就会告诉所有 订阅了chatter topic的节点，将要有数据发布。第二个参数是发布序列的大小。在这样的情况下，如 果我们发布的消息太快，缓冲区中的消息在大于1000个的时候就会开始丢弃先前发布的消息。*/ ros::Rate loop_rate(10); /*ros::Rate对象可以允许你指定自循环的频率。它会追踪记录自上一次调用Rate::sleep()后时间的流 逝，并休眠直到一个频率周期的时间。在这个例子中，我们让它以10hz的频率运行。*/ int count = 0; /*roscpp会默认安装一个SIGINT句柄，它负责处理Ctrl-C键盘操作——使得ros::ok()返回FALSE。 ros::ok()返回false，如果下列条件之一发生： SIGINT接收到(Ctrl-C) 被另一同名节点踢出ROS网络 ros::shutdown()被程序的另一部分调用 所有的ros::NodeHandles都已经被销毁 一旦ros::ok()返回false, 所有的ROS调用都会失效。*/ while (ros::ok()) { /*我们使用一个由msg file文件产生的‘消息自适应’类在ROS网络中广播消息。现在我们使 用标准的String消息，它只有一个数据成员"data"。当然你也可以发布更复杂的消息类型*/。 std_msgs::String msg; std::stringstream ss; ss &lt;&lt; "hello world " &lt;&lt; count; msg.data = ss.str(); ROS_INFO("%s", msg.data.c_str()); chatter_pub.publish(msg);//现在我们已经向所有连接到chatter topic的节点发送了消息。 ROS_INFO("%s", msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d9ea30923010da54ca1b4f1eb4befff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc0539aeb7f6931b1bd56cd5e9cd260/" rel="bookmark">
			设计模式——策略模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 策略模式：分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者。
public abstract class Duck { FlyBehavior mFlyBehavior; QuackBehavior mQuackBehavior; public Duck() { } public void Fly() { mFlyBehavior.fly(); } public void Quack() { mQuackBehavior.quack(); } public abstract void display(); } public class GreenHeadDuck extends Duck { public GreenHeadDuck() { mFlyBehavior = new GoodFlyBehavior(); mQuackBehavior = new GaGaQuackBehavior(); } @Override public void display() {...} } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10eae57dc96a6f892921ccea02340993/" rel="bookmark">
			rabbitmq的web管理界面无法使用guest用户登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为项目需要，在本地主机上安装了rabbitmq(3.6.6),后发现，只有该主机能够通过guest登录管理控制台，别的主机登录后提示登录失败。查阅了下后，发现官方文档说：由于账号guest具有所有的操作权限，并且是默认账号，出于安全因素的考虑，guest用户只能通过localhost登录使用，并建议修改guest用户的密码以及新建其他账号管理使用rabbitmq。所以，解决方案就是新建用户。
1、 登录web控制台（http://localhost:15672/）进行配置用户
在安装Rabbitmq的主机上，打开chrome，登录，然后点击admin--&gt;user--&gt;add user;
2、 增加用户，增加一个用户名为root，密码为root，tag为administrator
点击Add user，表格中会增加root用户，如下图：
3、 点击表格中的root,在新出现的页面点击Set permission,赋予所有权限
点击set permission后，会出现
4、 配置%APPDATA%\RabbitMQ\rabbitmq.config文件为：
打开%APPDATA%\RabbitMQ\目录：直接在地址栏中输入%APPDATA%\RabbitMQ\
然后用记事本打开rabbitmq.config, 编辑成这样
内容如下：
[
{rabbit,[{tcp_listener,[5672],{loopback_user,["guest"]}}]}
].
保存后就可以访问了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7a269b9bf4ce2dd7922703f04f2570a/" rel="bookmark">
			Vitamio的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vitamio是一款android以及ios视频播放的开源框架。
一．使用步骤： （一）导入Lib的Module 1、从官网上http://vitamio.org/下载官方的ｄｅｍｏ后，直接解压，解压后会得到VitamioDemo 和VitamioBundle。VitamioBundle是作为一个Library存在的。 但是我从官网上下不到上面说的包和Demo，后面我是从它的GitHub来下载Lib文件，自己看它的API写的Demo。 Lib工程的一个地址：https://github.com/yixia/VitamioBundle/tree/v3.0
2、VitamioBundle导入工程 File -&gt; Import -&gt; Android -&gt; Existing Projects Into Workspace
3、由于VitamioBundle是一个Library 需要把VitamioBundle 设置成Is Library，在VitamioBundle 右键 –properties –Android –Is Library勾上 –Apply –OK。
4、VitamioDemo 右键 –properties –Android – Add –然后选择VitamioBundle –然后选择Apply –OK
（二）创建新工程，导入res–&gt;raw—&gt; libarm.so文件（lib中有） Test_cbr.mp3文件（Demo中用） （三）AndroidManifest设置 权限
&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt; 添加activity &lt;activity android:name="io.vov.vitamio.activity.InitActivity" android:configChanges="orientation|screenSize|smallestScreenSize|keyboard |keyboardHidden|navigation" android:launchMode="singleTop" android:theme="@android:style/Theme.NoTitleBar" android:windowSoftInputMode="stateAlwaysHidden" /&gt; 自己的activity加入
&lt;category android:name="android.intent.category.DEFAULT" /&gt; （四）初始化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7a269b9bf4ce2dd7922703f04f2570a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a0e97e59aa62f219c6a6631b836ff26/" rel="bookmark">
			错误处理（一）—— 被呼叫方拒绝接收呼叫。 (异常来自 HRESULT:0x80010001 (RPC_E_CALL_REJECTED))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在进行Word相关的开发时遇到了这个错误，在网上找了很多资料，发现就那么几个解决方案（方案3和方案4），但是都没有很好的解决这个问题。后面在stackoverflow看到一个歪果仁提供的一个思路（方案1），完美解决了这个问题。而后无意中浏览到了MSDN，发现原来微软早就提供了这个问题的解决方案（方案2），可以从根本上避免此类异常的发生，可恶的微软隐藏的这么深。下面特意把这些方案整理出来。
方案1 捕捉异常，利用委托（delegate）和泛型重复执行异常的方法。 这个方案可以很完美的解决该问题，主要的思路就是捕获异常。如果获取的异常为该异常重复调用发生异常的方法，知道能够顺利调用完成为止。这个方案定义了两类泛型函数，函数的参数是委托。我们调用时就是把我们可能抛出异常的方法放到委托中通过下面类似的泛型函数进行调用。
利用委托Action进行泛型的定义： public static void RunWithOutRejected&lt;T&gt;(Action&lt;T&gt; action, T t) { bool hasException; do { try { action(t); hasException = false; } catch (System.Runtime.InteropServices.COMException e) { if (e.ErrorCode == -2147418111) { hasException = true; } else { throw; } } catch (Exception) { throw; } } while (hasException); } 利用委托Func进行泛型的定义： public static T RunWithOutRejected&lt;T&gt;(Func&lt;T&gt; func) { var result = default(T); bool hasException; do { try { result = func(); hasException = false; } catch (System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a0e97e59aa62f219c6a6631b836ff26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b2925504f35d6bf69a27b08eb9062e0/" rel="bookmark">
			android删除表和清空表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 删除某一表: //删除某一个表 public void dropTable(SQLiteDatabase db){ db.execSQL("drop table tab_name"); } 清空某一表: //清空某一个表 public void deleteTable(SQLiteDatabase db){ db.execSQL("delete from tab_name"); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bddc1ded88ac9a460d14d337d164977e/" rel="bookmark">
			STM32中断优先级分组概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行STM32f103的时候，进行中断分组的相关概念 Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，因此STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下：
第0组：所有4位用于指定响应优先级
第1组：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级
第2组：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级
第3组：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级
第4组：所有4位用于指定抢占式优先级
可以通过调用STM32的固件库中的函数NVIC_PriorityGroupConfig()选择使用哪种优先级分组方式，这个函数的参数有下列5种：
NVIC_PriorityGroup_0=&gt; 选择第0组
NVIC_PriorityGroup_1=&gt; 选择第1组
NVIC_PriorityGroup_2=&gt; 选择第2组
NVIC_PriorityGroup_3=&gt; 选择第3组
NVIC_PriorityGroup_4=&gt; 选择第4组
接下来就是指定中断源的优先级，下面以一个简单的例子说明如何指定中断源的抢占式优先级和响应优先级： // 选择使用优先级分组第1组 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
// 使能EXTI0中断 NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQChannel; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // 指定抢占式优先级别1
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // 指定响应优先级别0 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure);
// 使能EXTI9_5中断 NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQChannel; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // 指定抢占式优先级别0 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; // 指定响应优先级别1 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure);
要注意的几点是：
1）如果指定的抢占式优先级别或响应优先级别超出了选定的优先级分组所限定的范围，将可能得到意想不到的结果；
2）抢占式优先级别相同的中断源之间没有嵌套关系；
3）如果某个中断源被指定为某个抢占式优先级别，又没有其它中断源处于同一个抢占式优先级别，则可以为这个中断源指定任意有效的响应优先级别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa097b9f96e362ab959b21e61304c25b/" rel="bookmark">
			tufao安装过程中Could not find a package configuration file provided by &#34;Qt5Core&#34;解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMake Warning at cmake/OpenCVFindLibsGUI.cmake:18 (find_package): By not providing "FindQt5Core.cmake" in CMAKE_MODULE_PATH this project has asked CMake to find a package configuration file provided by "Qt5Core", but CMake did not find one. Could not find a package configuration file provided by "Qt5Core" with any of the following names: Qt5CoreConfig.cmake qt5core-config.cmake Add the installation prefix of "Qt5Core" to CMAKE_PREFIX_PATH or set "Qt5Core_DIR" to a directory containing one of the above files. If "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa097b9f96e362ab959b21e61304c25b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ddf658759b2ef64eea9efa69459597/" rel="bookmark">
			被“需要”的无功功率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、相关概念 1、有功功率&amp;无功功率 直接消耗的电能，转变为机械能、热能、化学能或声能，利用这些能作功，这部分功率称为有功功率。 许多用电设备均是根据电磁感应原理工作的，如配电变压器、电动机等，它们都是依靠建立交变磁场才能进行能量的转换和传递。为建立交变磁场和感应磁通而需要的电功率称为无功功率。无功功率不消耗电能，只是在交流电的半个周期内暂时地将电能以磁场（感性无功）或电场（容性无功）的形式储存起来，然后再另外半个周期内将所储存的能量转换为电能。
2、感性无功功率&amp;容性无功功率 （1）感性无功功率：在用电设备中，凡是用绕组和磁铁组成的，在交流电路中产生电和磁交变的功能。在能量转换过程中，有部分磁能仍恢复到电能，那部分电流没有消耗有功功率，称为感性无功功率。在电感性负载的电路中，电流滞后电压一个角度Ψ，cosΨ称为功率因数。　（2） 容性无功功率：在电容器二块极板间产生充放电，电容电流不消耗有功功率，这个电流引起的功率称为容性无功功率。在电容性负载的电路中，电流超前电压一个角度Ψ，cosΨ也称为功率因数。
3、功率的正负之分。 功率的定义是单位时间所做功的一个标称量，但功率的正负不应以功率消耗为标准，所以对它而言的正负不是做工的正负，而是只做功体(功率产生单位)在做功的情况下是从外界吸收功率还是向外界输出功率。
二、无功补偿的基本原理 无功功率补偿的基本原理是把容性元件与感性元件并联接在同一电路，当容性元件释放能量时，感性元件吸收能量；而感性元件释放能量时，容性元件却在吸收能量，能量在两种负荷之间互相交换。这样，感性元件所需要的无功功率可由容性元件输出的无功功率中得到补偿，减少了电网电源向感性负荷提供、由线路输送的无功功率。由于减少了无功功率在电网中的流动，因此可以降低线路和变压器因输送无功功率造成的电能损耗。同理，容性元件产生的容性无功功率过多时，需要安装感性元件以就地平衡容性无功功率。例如，超高压输电网的线路空载或轻载时，线路电容能产生大量的无功功率，末端电压将高于始端电压，所以需要装设并联电抗器予以吸收。而在电压等级较低的配电网中存在大量的感性负载，所以通常需要配置大量的并联电容器进行无功补偿。
无功功率补偿的作用包括提高供配电系统功率因数，减少无功功率在电网中的流动，降低输电线路因输送无功功率造成的电能损耗，改善电网的运行条件。
三、被“需要”的无功功率 在交流电路中，纯电阻负载电流IR与电压U同相位，电感负载电流IL滞后电压，电容负载电流IC则超前于电压。据无功计算公式：Q=UIsinΨ，其中角度Ψ指电压U超前电流I的相位角。由于感性元件上电压相角超前电流相角，所以感性无功为正；同理由于容性元件上电压相角滞后电流相角，所以Ψ为负，进而容性无功为负，关键即在此。容性无功为负，那么容性无功即可以理解为负的感性无功，从而容性器件（如电容）上消耗的容性无功即可以理解为容性器件上产生了感性无功、发出了感性无功。相反地，感性元件（如电感）上消耗了感性无功，也可以理解为发出了容性无功。
电网中的电力负荷如电动机、变压器等，大部分属于感性电抗，一般称这些感性设备消耗无功功率，安装并联电容器、同步调相机等无功补偿设备是为感性负载提供所消耗的无功功率。而感性设备消耗了感性无功功率，也即是发出了容性无功功率，即所谓无功功率的损耗只是个说法而已，也可以说成是容性无功功率的产生。无功功率只是在容性负载和感性负载之间不断进行交换抵消，在与电网中基本上是没有损耗的。所以使用“消耗”的说法很难让人理解无功功率的存在形式以及无功补偿的原理。因此，根据部分人的提议，可以“消耗”改为“需要”。将“感性元件消耗感性无功，容性元件消耗容性无功”变成“感性元件需要感性无功，容性元件需要容性无功”。这样描述是不是让人更容易理解无功功率存在的原因和无功补偿过程的本质呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9cfe1a02d5781915f4492a048b6f51/" rel="bookmark">
			android汉字转拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		亲测有效，代码如下：
//获取的方法类 public class getPinyin { /** * 将中文转换成拼音 ，获取拼音，返回拼音加汉子首字母 * * @param name * @return */ public static String getNameLookupKeys(String name) { // TODO : Reduce the object allocation. HashMap&lt;String, String&gt; keys = new HashMap&lt;String, String&gt;(); ArrayList&lt;Token&gt; tokens = HanziToPinyin.getInstance().get(name); final int tokenCount = tokens.size(); final StringBuilder keyPinyin = new StringBuilder(); final StringBuilder keyInitial = new StringBuilder(); // There is no space among the Chinese Characters, the variant name // lookup key wouldn't work for Chinese.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9cfe1a02d5781915f4492a048b6f51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ee14092fafdd215c6a5d095359a2e59/" rel="bookmark">
			集合框架_集合的使用步骤图解、迭代器的原理及源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public iterface Iterator{ public abstract boolean hasNext(); public abstract Object next(); } public interface Iterable { Iterator iterator(); } public iterface Collection extends Iterable{ Iterator iterator(); } public iterface List extends Collection{ Iterator iterator(); } public class ArrayList implements List{ public Iterator iterator() { return new Itr(); } private class Itr implements Iterator { public boolean hasNext(){} public Object next(){} } } Collection c = new ArrayList(); c.add("hello"); c.add("world"); c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ee14092fafdd215c6a5d095359a2e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7582ccd2c3f4cfb27b330933017c33b/" rel="bookmark">
			JS中encodeURIComponent（URL）编码与decodeURIComponent（URL）解码详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1) encodeURIComponent(url) 函数
定义和用法 encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。
语法 encodeURIComponent(URIstring)
参数 描述 URIstring 必需。一个字符串，含有 URI 组件或其他要编码的文本。
返回值 URIstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。
说明 该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。
其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序
列替换的。
(1) decodeURIComponent(url) 函数
定义和用法 decodeURIComponent() 函数可把字符串作为 URI 组件进行解码。
语法 decodeURIComponent(URIstring)
参数 描述 URIstring 必需。一个字符串，含有 URI 组件或其他要解码的文本。
返回值 URIstring 的副本，其中的某些字符被十六进制的转义序列转换成对应的ACSII字符。
今天在使用js的jQuery的post向后台servlet传递拼接的字符串数据时，一些特殊的字符例如：“+、@、#、
$、%、&amp;、?、/”等无法传递到后台输出。
举个例子：
var str1="a+aa+bb@kk$dd";
var data="data1"="+str1+"+"&amp;"+"data2"+str2;
如果不进行编码，则通过js的jQuery的post或者使用window.self.location传递数据到后台，都会造成+、
@、$字符无法正常输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7582ccd2c3f4cfb27b330933017c33b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05ee5718ce72e4aaf851903bd385bcb5/" rel="bookmark">
			如何过滤List&lt;Map&lt;String,Object&gt;&gt; 中的重复Map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到一个问题，就是如何过滤一个List&lt;Map&lt;String,Object&gt;&gt; 中重复的Map,废话不多说，直接上代码.
//去除重复的Map //cfArraylist 表示重复的 List&lt;Map&lt;String，Object&gt;&gt; //listMap 表示去重复数据后的 List&lt;Map&lt;String，Object&gt;&gt; Map&lt;String, Map&gt; msp = new HashMap&lt;String, Map&gt;(); List&lt;Map&lt;String, Object&gt;&gt; listMap = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); //把list中的数据转换成msp,去掉同一id值多余数据，保留查找到第一个id值对应的数据 for (int i = 0; i &lt; cfArraylist.size(); i++) { Map map = cfArraylist.get(i); String key = (String)map.get("key"); map.remove("key"); msp.put(key, map); } //把msp再转换成list,就会得到根据某一字段去掉重复的数据的List&lt;Map&gt; Set&lt;String&gt; mspKey = msp.keySet(); for(String key: mspKey){ if(key == null) continue; Map newMap = msp.get(key); newMap.put("f_id", key); listMap.add(newMap); } 转载于:https://blog.51cto.com/7156680/1883108
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f49696b78e13993bd789a16c9a2f82d/" rel="bookmark">
			[乐意黎原创]Node.js 出现Error:Cannot find runtime &#39;node&#39; on PATH - Visual Studio Code中的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在调试 node.js时，出现 Error: Cannot find runtime 'node' on PATH，如下图所示.
网上找了好多办法，也没解决。 突然想起，自己安装时选择了 add to path, 应该是路径没有添加到系统环境里，找开变量窗口一看，果然如此。
应该是自己没有重启导致的，于是，重启。果真解决了。
唉，失误害人啊。。。。
乐意黎原创
本文地址：http://blog.csdn.net/aerchi/article/details/53665307
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b441dbcae49974b5f0a1f2c0932a3b12/" rel="bookmark">
			如何通俗解释Docker是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：刘允鹏 链接：https://www.zhihu.com/question/28300645/answer/67707287 来源：知乎 著作权归作者所有，转载请联系作者获得授权。 Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。
docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱。
1.不同的应用程序可能会有不同的应用环境，比如.net开发的网站和php开发的网站依赖的软件就不一样，如果把他们依赖的软件都安装在一个服务器上就要调试很久，而且很麻烦，还会造成一些冲突。比如IIS和Apache访问端口冲突。这个时候你就要隔离.net开发的网站和php开发的网站。常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小，小就意味着省钱了。
2.你开发软件的时候用的是Ubuntu，但是运维管理的都是centos，运维在把你的软件从开发环境转移到生产环境的时候就会遇到一些Ubuntu转centos的问题，比如：有个特殊版本的数据库，只有Ubuntu支持，centos不支持，在转移的过程当中运维就得想办法解决这样的问题。这时候要是有docker你就可以把开发环境直接封装转移给运维，运维直接部署你给他的docker就可以了。而且部署速度快。
3.在服务器负载方面，如果你单独开一个虚拟机，那么虚拟机会占用空闲内存的，docker部署的话，这些内存就会利用起来。
总之docker就是集装箱原理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f2c274f09ec5b97829a1236413ee484/" rel="bookmark">
			[宏哥传]02，王者归来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		宏哥我已经好久没发表过文章了，上一次还是8月份的。这期间发生什么事呢？就是找到了人生中的第一份工作，而且还沉迷了lol这个游戏。工作的压力还是有点大的，经常赶进度，当然这是游戏行业目前的状况了，所以为了减压，经常打游戏来减压，而lol又是一个很容易让人上瘾的游戏。就这样，以赶进度--打游戏的状态度过了好几个月，期间我也觉得这样的生活状态是不行的，但我就是陷入了这样的死循环中，不能自拔了。
我一直以为这样的状况至少会持续到毕业，或者是只有把工作辞了才能解脱，但是事情又发生了转机。大概就是从9月份开始，博客访问量像火箭一样上升，右上角总是有红点，评论，关注，求qq等等的。不管怎么说，一个陌生的，你未见过的人，看了你写的东西而留言和关注，总会有些小惊喜的。但这也不是宏哥我回归的主要原因，毕竟男男之间的友谊还是打动不了我的(本人不搞基)。主要是前天看了一个视频，哥的偶像说了一些很激动人心，很振奋人心的话，然后满满的消极情绪瞬间清空，留下了感动的眼泪。现在仔细想想，其实是自己对待工作和生活的态度不对，应该好好端正的。
那么，现在的工作状况是怎样的呢。现在宏哥所在的公司是不分客户端和服务端的，每个程序员都是双端开发的(lua和c++)，这样的好处就是可以完整地设计出一个功能，调试起来很方便，当然缺点也很明显，专业的东西应该留给专业的人士来负责，像我这样偏向前端的人去搞后端的，会比较坑的。。不过正是这样的开发模式，学到的东西会更多些。那么现在工作几个月了，学到了不少东西，人升级了，境界又高了一些，确实需要好好地总结一下，分享一下，所以宏哥我又回归鸟。
所以说现在的宏哥我，可谓是霸气回归，王者归来啊~突然发现自己写的这些情感类东西，总是先抑后扬的，先是灰色的情调，然后慢慢转红，越发强烈，逐渐迈向积极向上的方向，挺喜欢这样的风格的~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9249d1118f1bb1bf4fae8bea0d8d0ec/" rel="bookmark">
			[Unity热更新]lua常用库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
http://www.cnblogs.com/superchao8/archive/2011/06/20/2085023.html
http://blog.csdn.net/goodai007/article/details/8076141
http://www.cnblogs.com/whiteyun/archive/2009/08/10/1543139.html
0.使用Sublime Text3 配置Lua运行环境：
http://blog.csdn.net/albertsh/article/details/52297546
1.string
--string库中所有的function都不会直接操作原字符串，而是复制一份再进行操作 s = "[Abc]" print(string.len(s)) --5 print(string.rep(s, 2)) --[Abc][Abc] print(string.lower(s)) --[abc] print(string.upper(s)) --[ABC] --string.sub 截取字符串 --字符索引从前往后是1,2,...;从后往前是-1,-2,... print(string.sub(s, 2)) --Abc] print(string.sub(s, -2)) --c] print(string.sub(s, 2, -2)) --Abc --string.find(s, pattern, pos) 搜索字符串 --s 源字符串 --pattern 待搜索的模式串 --pos 从pos位置开始搜索 --找到则返回开始和结束的位置，否则返回nil s = "hello world" print(string.find(s, "hello")) --1 5 print(string.find(s, "l")) --3 3 print(string.find(s, "lll")) --nil -- . 任意字符 -- %s 空白符 -- %p 标点字符 -- %c 控制字符 -- %d 数字 -- %x 十六进制数字 -- %z 代表0的字符 -- %a 字母 -- %l 小写字母 -- %u 大写字母 -- %w 字母和数字 --上面字符类的大写形式表示小写所代表的集合的补集。例如，%A 非字母的字符 s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9249d1118f1bb1bf4fae8bea0d8d0ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe52ea616672ace3c4837985210c6343/" rel="bookmark">
			Java 时间, 日历类详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Java时间戳 在最早出现的 UNIX 操作系统考虑到计算机产生的年代和应用的时限，把1970年1月1日0点定义为时间纪元，这种定义时间的方式在计算机语言中广泛存在，Java就是其中之一。之所以使用Long数据类型来表示时间是因为Long类型可以表示足够大的数，进而可以表示未来更多的时间。
2. Java中日期时间的使用 主要涉及一下几个类：
java.util.Date java.text.DateFormat java.text.SimpleDateFormat java.util.Calendar java.util.GregorianCalendar 下面是对上述几个类逐个介绍：
2.1 java.util.Date 先看Java jdk文档的描述：
The class Date represents a specific instant in time, with millisecond precision.
意思是说Data类表示一个特定的时间瞬间，精确到毫秒。并且从 JDK 1.1 起，废弃了把日期转换为年、月、日、小时、分钟和秒值的方法，应该使用 Calendar 类实现日期和时间各字段之间的转换，使用 DateFormat 类来格式化和分析日期字符串。其实Date里的好多方法现在都已经被废弃。
例子：
public class DateDemo { public static void main(String[] args) { Date date = new Date(); String current = date.toString(); System.out.println("当前时间是："+current); long millisecond = date.getTime(); System.out.println("自格林威治时间(1970年1月1日0时0分0秒)起到现在的所经过的毫秒数："+millisecond); //setTime(long time)方法设置自日期1970年1月1日00:00:00 GMT后，来显示时间的毫秒。 date.setTime(1234567890); System.out.println("设置后的时间为："+date.toString()); //比较一个时间是否在另一个时间之前 Date date1 = new Date(); date1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe52ea616672ace3c4837985210c6343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c7851a64cdd442040c6ca2c993dc79b/" rel="bookmark">
			Mysql 中间件整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		外部评价 mysql-proxy是官方提供的mysql中间件产品可以实现负载平衡，读写分离，failover等，但其不支持大数据量的分库分表且性能较差。 Atlas：Atlas是由 Qihoo 360, Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在mysql-proxy 0.8.2版本的基础上，对其进行了优化，增加了一些新的功能特性。 alibaba.cobar：Cobar是阿里巴巴（B2B）部门开发的一种关系型数据的分布式处理系统，它可以在分布式的环境下看上去像传统数据库一样为您提供海量数据服务。 TDDL：淘宝根据自己的业务特点开发了TDDL（Taobao Distributed Data Layer 外号:头都大了 ©_Ob）框架，主要解决了分库分表对应用的透明化以及异构数据库之间的数据复制，它是一个基于集中式配置的 jdbc datasource实现，具有主备，读写分离，动态数据库配置等功能。
http://www.guokr.com/blog/475765/
待续…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a34b9476baf9210373312057025c2bb7/" rel="bookmark">
			JQuery.validationEngine表单验证插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、说明
JQuery.validationEngine表单验证控件功能强大，自带了样式显示模式：
1.字符类型：非空验证、最大长度、最小长度、相等判断、数字和空格、数字和英文字母
2.数字类型：数字、整数、最大值、最小值
3.日期类型：日期（yyyy-MM-dd/ yyyy/MM/dd等）、日期+时间、最小日期、最大日期、日期时间段
4.业务字段：url、email、phone、ipv4；ciaoca版扩展支持：qq、邮政编码、身份证、汉字。
5.Ajax后台验证：支持全局扩展定义，后台可定义消息内容，但是没有回调处理的扩展。
6.其他自定义扩展。
二、相关文档
1.Git源代码地址：https://github.com/posabsolute/jQuery-Validation-Engine
2.中文文档API参考：http://code.ciaoca.com/jquery/validation-engine/
3.中文优化版 Ciaoca下载
4.Asp.net Demo实例源代码地址：https://git.oschina.net/tiama3798/BootstrapBack_Demo/tree/JQuery.validationEngine
三、其他表单标签验证
1.引用：
&lt;link href="~/Scripts/validation/validationEngine.jquery.css" rel="stylesheet" /&gt; &lt;script src="~/Scripts/validation/jquery.validationEngine.js"&gt;&lt;/script&gt; &lt;script src="~/Scripts/validation/jquery.validationEngine-zh_CN.js"&gt;&lt;/script&gt; &lt;script src="~/Scripts/validation/jquery.validationEngine.js"&gt;&lt;/script&gt;2.HTMl： &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading"&gt; &lt;div class="panel-title"&gt;常用业务字段验证&lt;/div&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;form role="form" id="form1" class="demoform" action="#"&gt; &lt;div class="form-group"&gt; &lt;label class="control-label"&gt;分类：&lt;/label&gt; &lt;div class="select"&gt; &lt;select class="form-control validate[required]" name="type"&gt; &lt;option value=""&gt;==请选择==&lt;/option&gt; &lt;option value="1"&gt;一星级&lt;/option&gt; &lt;option value="2"&gt;二星级&lt;/option&gt; &lt;option value="3"&gt;三星级&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="control-label"&gt;多选框：&lt;/label&gt; &lt;div&gt; &lt;label class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a34b9476baf9210373312057025c2bb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac47880f3830344c3647363241737773/" rel="bookmark">
			c语言 如何用指针来处理字符串？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、字符指针1、字符指针输出字符串2、字符指针处理字符串3、字符数组与字符指针处理字符串有何不同 二、指针数组*指针数组的说明形式*三、指向指针的指针 读者，你好！ 如果你精通C，希望能得到你的斧正；如果你是初学者，希望能对你有所帮助。 加粗的是一些我认为比较重要的内容。 一、字符指针 1、字符指针输出字符串 为了更好的理解这部分内容，我们先看一个例子：
#include &lt;stdio.h&gt; int main() { char *ps ; ps = "C language!";	/*定义字符指针*/ printf("%s\n", ps); /*用字符指针PS来输出字符串的内容*/ return 0; } 运行结果为：
这个列子中，字符串“C language！”， 存储在连续的无名存储区中，通过语句ps = "C language!, 将无名储存区的首地址赋给指针ps，也就是说，指针变量ps 指向无名储存区域的首地址，而不是把无名储存区域的内容保存在ps中，
Clanguage!\0 ps^
2、字符指针处理字符串 还是从具体的列子出发：
#include &lt;stdio.h&gt; int main() { char *ps = "C language!"; int n = 2; ps = ps+2;	/*移动指针ps*/ printf("%s\n", ps); return 0;	} 运行结果：
这里初始化的时候把首地址赋给了ps , 后面操作ps= ps+2时，ps指向l 所在的空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac47880f3830344c3647363241737773/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88657f94818762c0d9a8e0a5b514a35c/" rel="bookmark">
			[置顶]
        pycurl检测网站性能，pycurl.*_TIME时间问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天使用python+pycurl来检测网站性能，使用curl_obj.getinfo(pycurl.*_TIME)来获取各个阶段运行时间
total_time = curl_obj.getinfo(pycurl.TOTAL_TIME) #传输结束所消耗的总时间 dns_time = curl_obj.getinfo(pycurl.NAMELOOKUP_TIME) #从发起请求到DNS解析完成所消耗的时间 connect_time = curl_obj.getinfo(pycurl.CONNECT_TIME) #从发起请求到建立连接所消耗的时间 redirect_time = curl_obj.getinfo(pycurl.REDIRECT_TIME) #从发起请求到重定向所消耗的时间 ssl_time = curl_obj.getinfo(pycurl.APPCONNECT_TIME) #从发起请求到SSL建立握手时间 pretrans_time = curl_obj.getinfo(pycurl.PRETRANSFER_TIME) #从发起请求到准备传输所消耗的时间 starttrans_time = curl_obj.getinfo(pycurl.STARTTRANSFER_TIME) #从发起请求到接收第一个字节的时间 最后发现，dns_time+connect_time+......+starttrans_time远远大于total_time。
查看man curl（pycurl基于curl开发的），发现各个阶段时间是从客户端发起URL请求时到某个阶段的时间差，而不是某个阶段开始时间到结束时间差。
为了求得某个阶段的执行时间，需要对这些值进行计算。
pycurl的各个阶段（根据pycurl.*_TIME统计）依次为
DNS解析--&gt;TCP连接--&gt;跳转【如有】--&gt;SSL握手【如有】--&gt;客户端准备--&gt;服务器响应--&gt;数据传输
代码如下：
#! /usr/bin/python #coding:utf-8 #-*- coding : utf-8 -*- import sys,pycurl request_url = sys.argv[1] curl_obj = pycurl.Curl() #创建一个curl对象 curl_obj.setopt(pycurl.CONNECTTIMEOUT, 5) #连接的等待时间,设置为0则不等待 curl_obj.setopt(pycurl.TIMEOUT, 5) #最大下載时间 curl_obj.setopt(pycurl.NOPROGRESS, 1) #是否屏蔽下载进度条,非0则屏蔽 curl_obj.setopt(pycurl.MAXREDIRS, 0) #指定HTTP重定向的最大数 curl_obj.setopt(pycurl.FORBID_REUSE, 1) #完成交互后强制断开连接,不重用 curl_obj.setopt(pycurl.FRESH_CONNECT,1) #强制获取新的连接,即替代缓存中的连接 curl_obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88657f94818762c0d9a8e0a5b514a35c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f5c6c17ddd7340f7d1f836d4d769e0/" rel="bookmark">
			Socket通信，实现单客户端和服务器交互的C/S结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建客户端程序：
package FirstPackages;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
public class Client {
public static void main(String args[]) {
try
{
Socket socket=new Socket("127.0.0.1",9000);//向本机的9000端口发出客户请求
System.out.println("客户端开启");
BufferedReader in=new BufferedReader(new InputStreamReader(System.in));//InputStreamReader是字节流通向字符流的桥梁，从底层流读取字节
//BufferedReader 从字符输入流中读取文本
PrintWriter os=new PrintWriter(socket.getOutputStream());//getOutputStream()返回此套接字的输出流
String readline;
readline=in.readLine();
while(!readline.equals("bye"))//若读入的字符串为bye，就停止循环
{
os.println(readline);//将读入的字符串输出到Server
os.flush();//刷新输出流，使Server马上收到该字符串
readline=in.readLine();
}
os.close();//关闭Socket输出流
socket.close();//关闭Socket
}catch(IOException e){System.out.println("error:"+e);}
}
}
然后创建服务器端程序：
package FirstPackages;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
public class Server {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0f5c6c17ddd7340f7d1f836d4d769e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bffb4cb153c36e182964b699ab1777d9/" rel="bookmark">
			针对于WebStorm工具开发React工程详细配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 WebStorm作为目前最流流行的前端IDE, 无论从运行速度还是开发的便捷性，无形之中提高了工作效率，目前比较火爆的React也越来越被众多开发人员所采纳，但是WebStorm下的React工程经常会出现很多警告以及转换提示，下面我就对此做一些整理，方便更多同志使用。
React Library支持 点击下载按钮，下来所需要的react library:
激活所选library, 应用即可
支持JSX语法 上截图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966164b4c138e4ff0cd05e0ed31cbbd5/" rel="bookmark">
			Qt第三方圆形进度条-及其改进
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#Qt第三方圆形进度条的改进 要实现一个圆形的进度条功能，在网上找到一个比较出名的第三方封装类：QRoundProgressBar，地址：sourceforge 的 QRoundProgressBar 功能封装的还是不错，提供了3种模式，线形、圆环、饼状。使用过程中发现圆环进度条对背景透明支持不够完善，内圆的背景无法实现透明，为了解决此问题，下面对此控件进行了一些修订，实现完整的圆形进度条。
#QRoundProgressBar目前存在的不足
QRoundProgressBar在带背景图片widget下使用StyleDonut样式时，内环背景无法透明
代码如下： 头文件:
class DRoundProgressBar; class QTimer; namespace Ui { class Widget; } class Widget : public QWidget { Q_OBJECT public: explicit Widget(QWidget *parent = 0); ~Widget(); public slots: void onTimeOut(); private: Ui::Widget *ui; QTimer* mTimer; DRoundProgressBar* mRoundBar; int mPresent; }; cpp:
#include "Widget.h" #include "ui_Widget.h" #include "DRoundProgressBar.h" #include &lt;QTimer&gt; Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget) { ui-&gt;setupUi(this); setAutoFillBackground(true); QPixmap img(":/img/BlueDialog_BK.png"); QPalette bkPalette; bkPalette.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/966164b4c138e4ff0cd05e0ed31cbbd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403fe08f95238df68132d48a58d2aec9/" rel="bookmark">
			RequireJS实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用data-main加载主文件
目录结构
引用代码：
&lt;script src="../scripts/require.js" data-main="../myjs/app.js"&gt;&lt;/script&gt; app.js代码： console.info('app.js开始执行'); console.info(require);执行结果： 二、使用初始化配置和指定id加载js实例
&lt;script src='../scripts/require.js'&gt;&lt;/script&gt; &lt;script&gt; //初始化配置 require.config({ baseUrl:'../myjs', paths:{ jquery:'../scripts/jquery' } }); //动态异步加载js require(['jquery'],function($){ $(function(){ $(document.body).css({ background:'#efefef' }); }); }); &lt;/script&gt; 加载顺序如下： 三、使用RequireJS构建模块实例
创建模块color.js定义颜色
//定义全局颜色 define('color', function() { return { color:'red', bgColor:'#efefef' }; }); 创建style.js定义设置样式
//使用RequireJS定义模块,指定依赖 define('style',['color','jquery'],function(color,$){ return { init:function(){ $(document.body).css({ color:color.color, background:color.bgColor }); } }; }); 创建require3.html 显示Demo
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src='../scripts/require.js'&gt;&lt;/script&gt; &lt;script &gt; //全局配置 require.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/403fe08f95238df68132d48a58d2aec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7636e49082faa2ccca9d065adc9fd11/" rel="bookmark">
			JS跨域（ajax跨域、iframe跨域）解决方法及原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。
要解决跨域的问题，我们可以使用以下几种方法： 1、通过jsonp跨域 2、通过修改document.domain来跨子域 3、使用window.name来进行跨域 4、使用HTML5中新引进的window.postMessage方法来跨域传送数据
详细内容： http://www.th7.cn/web/ajax/201503/88209.shtml
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5df8857a7b070ef4ade3718ab95a5f83/" rel="bookmark">
			用vi修改文件，保存文件时，提示“readonly option is set”的解决方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 This is a vim issue, not a file permission issue. If you did not have read permission on the file, you'd see a "Permission denied" error.Do you invoke vi/vim with the -R option? Are you calling view instead of vi or vim? Do you have set readonly in your .vimrc or in a file in ~/.vim/ftplugin?In vim you can enter :set noreadonly to unset the readonly flag.步骤：1.按Esc键2.输入 :set noreadonly3.然后就能正常保存了，你可以输入 :wq 来保存文件了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab51ac261c2e3d1dedd8bffb9a9e717/" rel="bookmark">
			Android多媒体应用开发系列(三) 使用MediaRecorder录音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		辛苦堆砌，转载请注明出处，谢谢！
下面开始使用MediaRecorder完成录音功能，在使用MediaRecorder前，首先应当了解MediaRecorder的状态图，按图索骥，没有问题！下面给出MediaRecorder的状态图（实际上贴不贴无所谓了，网上一找一大把）。
从状态图看出几点：
1.除了Release，其他状态下，都可以调用reset回到Initial状态；
2.Release是一个状态孤岛，进到Release状态之后，整个状态图终结；
3.从Initial才可以到达Release，所以需要reset后，才能release;
4.注意从Initial到Prepared的过程，中间需要很多配置接口，记得设置，由于MediaRecorder既可以录音也可以录像，录音和录像需要设置的不同。
有了这几点认知，就可以基于MediaRecorder封装我们自己的AudioRecorder了，之所以封装，是因为基于MediaRecorder还可以进行录像，到时候我们可以做VideoRecorder，实际上我也是这么打算的XD
package com.yjp.recorder; import android.media.MediaRecorder; import java.io.IOException; public class AudioRecorder { private MediaRecorder mRecorder; public AudioRecorder() { mRecorder = new MediaRecorder(); } public void ReleaseAudioRecorder() { resetAudioRecorder(); mRecorder.release(); mRecorder = null; } public void prepareAudioRecorder(String filePathname){ mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC); mRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT); mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT); mRecorder.setOutputFile(filePathname); try { mRecorder.prepare(); } catch (IOException e) { e.printStackTrace(); resetAudioRecorder(); } } public void startAudioRecorder() { try { mRecorder.start(); } catch (IllegalStateException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ab51ac261c2e3d1dedd8bffb9a9e717/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bd55a366b5f50fe297fb1b6e7a11dc8/" rel="bookmark">
			jenkins配置多job执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jenkins中配置multijob执行多任务的之间的依赖构建 安装插件Multijob plugin 系统管理-&gt;插件管理-&gt;可选插件 安装此插件 新建一个multijob任务 配置构建多任务执行，前提是必须在jenkins先建立好相关的job。job之间是独立的 此致配置完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e54aba311a4ca90db1e8a45fdc128224/" rel="bookmark">
			循环神经网络（RNN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.NN &amp; RNN 在神经网络从原理到实现一文中已经比较详细地介绍了神经网络，下面用一张图直观地比较NN与RNN地不同。从图1中可以看出，RNN比NN多了指向自己的环，即图1中的7,8,9,10节点及其连线。图2显示RNN展开的网络结构。
在传统的神经网络中，我们假设所有的输入（包括输出）之间是相互独立的。对于很多任务来说，这是一个非常糟糕的假设。如果你想预测一个序列中的下一个词，你最好能知道哪些词在它前面。RNN之所以循环的，是因为它针对系列中的每一个元素都执行相同的操作，每一个操作都依赖于之前的计算结果。换一种方式思考，可以认为RNN记忆了到当前为止已经计算过的信息。理论上，RNN可以利用任意长的序列信息，但实际中只能回顾之前的几步。
图1 图2 2.demo Character Language Model，通过预测下一个字符，从而产生整篇文章。代码：min-char-rnn.py
3.前向传播 图3 在图3中 4.后向传播 一共有T个时刻，参数求导如下：
对t时刻求导，需要用到前面k=1到t的信息：
[k,t]之间的求导，可以转换为[k+1,t]对前一时刻求导的乘积：
其中,对前一时刻进行求导：
所以，最终参数更新公式如下：
4.简单应用 from __future__ import print_function from keras.datasets import mnist from keras.models import Sequential from keras.layers import Dense, Activation from keras.layers import SimpleRNN from keras.initializations import normal, identity from keras.optimizers import RMSprop from keras.utils import np_utils batch_size = 32 nb_classes = 10 nb_epochs = 200 hidden_units = 100 learning_rate = 1e-6 clip_norm = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e54aba311a4ca90db1e8a45fdc128224/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3fe726b0e166fdd692d2723d9d4a95b/" rel="bookmark">
			Springboot 之 解决IDEA读取properties配置文件的中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://www.zslin.com/web/article/detail/47
问题描述 当在.properties的配置文件中有中文时，读取出来的总是乱码。比如我的application.properties配置文件的内容如下：
server.port=9090 test.msg=你好：Springboot 当在程序中读取test.msg值时总是会得到乱码，默认是以ISO-8859-1的字符编码读取，尝试的方法有：
1、添加配置
banner.charset=UTF-8 server.tomcat.uri-encoding=UTF-8 spring.http.encoding.charset=UTF-8 spring.http.encoding.enabled=true spring.http.encoding.force=true spring.messages.encoding=UTF-8 2、设置文件类型
将application.properites的文件类型修改为UTF-8的编码类型。
通过以上方法测试获取出来的值还是乱码。
· 解决办法 设置 File Encodings的Transparent native-to-ascii conversion为true，具体步骤如下：依次点击
File -&gt; Settings -&gt; Editor -&gt; File Encodings
将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。
代码文档地址：http://www.zslin.com/web/article/detail/12 代码仓库地址：https://github.com/zsl131/spring-boot-test/tree/master/study02
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f977e6d7a473da83767f4c64b281d9ea/" rel="bookmark">
			eCharts添加自定义geojson数据实现地图展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：
当初看到echarts的地图的时候感觉可以做点什么，但是一直米有实施，最近刚好用到了，就研究了研究，在echarts中添加了自定义的geojson数据，实现数据的地图展示。
geojson数据生成：
geojson数据的生成有很多种方式，在此介绍两种：1、通过gdal直接转换；2、通过geoserver生成。
1、通过gdal
通过gdal生成可参考文章GDAL的java环境配置以及将shp转换为json
2、通过geojson
在图层预览里面选择geojson即可，如下图。
展示实现：
实现代码如下：
&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;style&gt; html,body,#main{ padding: 0px; margin: 0px; height: 100%; overflow: hidden; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main"&gt;&lt;/div&gt; &lt;!-- ECharts单文件引入 --&gt; &lt;script src="../../plugin/echart/build/dist/echarts.js"&gt;&lt;/script&gt; &lt;script src="../../plugin/jquery/jquery-1.8.3.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; require.config({ paths: { echarts: '../../plugin/echart/build/dist' } }); require( [ 'echarts', 'echarts/chart/map' ], function (ec) { // 基于准备好的dom，初始化echarts图表 var myChart = ec.init(document.getElementById('main')); var cityMap = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f977e6d7a473da83767f4c64b281d9ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29441630d94e3357a79e838e1bba4a13/" rel="bookmark">
			Android网络框架xUtils的数据库操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xUtils:当前比较火的框架，并且用处也是比较多。
一．目前xUtils主要有四大模块： DbUtils模块：用于数据库的操作，也是需要注解方式指定表名和列名； ViewUtils模块：注解方式就可以进行UI，资源和事件绑定； HttpUtils模块：用于网络数据的请求； BitmapUtils模块：用于图片的下载和绑定视图；
本文主要讲解xUtils中的数据库的增删改查操作。
使用： AndroidStudio使用xUtils之前添加依赖就可以了： compile 'org.xutils:xutils:3.3.38' GitHub中的源码地址：https://github.com/wyouflf/xUtils3 二．DbUtils的使用示例 （一）添加依赖 compile 'org.xutils:xutils:3.3.38' （二）创建MyApp类继承Application package com.lwz.db; import android.app.Application; import org.xutils.DbManager; import org.xutils.x; /** * Application类， * 单例方法，数据共享， */ public class MyApp extends Application { /** * 实现单例，任何一个页面都能拿到这个类的数据和对象 */ private static MyApp instance; public static MyApp getInstance() { return instance; } @Override public void onCreate() { super.onCreate(); x.Ext.init(this);//注册xUtils instance = this; } /** * 获取数据库的管理器 * 通过管理器进行增删改查 */ public DbManager getDbManager() { DbManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29441630d94e3357a79e838e1bba4a13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/597e7ed3b31f4d6d7765cd7601943d01/" rel="bookmark">
			Spring中为什么要有@Bean注解？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二、注解分为两类：
1、一类是使用Bean，即是把已经在xml文件中配置好的Bean拿来用，完成属性、方法的组装；比如@Autowired , @Resource，可以通过byTYPE（@Autowired）、byNAME（@Resource）的方式获取Bean；
2、一类是注册Bean,@Component , @Repository , @ Controller , @Service , @Configration这些注解都是把你要实例化的对象转化成一个Bean，放在IoC容器中，等你要用的时候，它会和上面的@Autowired , @Resource配合到一起，把对象、属性、方法完美组装。
@Bean明确地指示了一种方法，什么方法呢——产生一个bean的方法，并且交给Spring容器管理；从这我们就明白了为啥@Bean是放在方法的注释上了，因为它很明确地告诉被注释的方法，你给我产生一个Bean，然后交给Spring容器，剩下的你就别管了 记住，@Bean就放在方法上，就是产生一个Bean 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b38f67e469bbe3ce29ac2dfb29b6977/" rel="bookmark">
			MNF变换相关概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小噪声分离变换（MinimumNoise Fraction Rotation，MNFRotation）
1.适用于高光谱遥感数据
2.用于判定图像数据的内在维数（即波段数）
作用：分离数据中的噪声，减少之后计算的需求量
本质：两次重叠的主成分变换
第一次变换（基于估计的噪声协方差矩阵）用于分离和重新调节数据中的噪声。？？？？？？
第一步导致了转换数据的噪声个体的变异和波段与波段的不相关。？？？？？？？？？？？
第二步是标准主成分变换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33ddea4666d294fdaf36887bc57ddce2/" rel="bookmark">
			台式机通过笔记本的WIFI上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我台式机和笔记本系统都是win7，其他的应该差不多。
笔记本WiFi上网，用网线将台式机和笔记本的“本地连接”设置为相同网段，然后用网线连接起来，确定网线没问题，可以ping一下。
笔记本：
右键“无线网络连接”，选择“属性”，在弹出的窗口中选择“共享”标签，勾选“红圈”所示选项，然后点击“确定”按钮。
此时会弹出提示框，如下图所示：
大概意思就是笔记本的“本地连接”（即有线连接）的IP地址会被改成192.168.137.1，此时与台式机的有线连接会断开。显然会断开，因为没人会把台式机设置成137网段。
点击“是”按钮，然后点击“确定”按钮，笔记本设置完成。
台式机：
将台式机的“本地连接”IP地址设置为自动获取，如下图“红圈”所示，这样台式机就能通过笔记本的WIFI上网了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a28fe3a4aa1bceedb04b9b06953b381/" rel="bookmark">
			JQuery的表单验证之JQuery.validate插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特别说明：
JQuery.validate默认情况下
1.J dateISO支持‘yyyy-MM-dd’格式
2.对于远程验证，服务器相应格式需要为true或者false，这样的话不能带其他参数
3.对于远程验证，没有进度条提示，这样不够友好。
4.默认不支持手机号，电话等
5.优点对于数字类型、字符串长度、是否相等、url、邮箱比较好用
6.支持select，checkbox，radio
7.支持代码模式和html标记模式，很方便自定义错误内容。
结论：对于远程验证的需求，很多时候还是要自己手写。
Demo源代码地址：http://git.oschina.net/tiama3798/BootstrapBack_Demo/tree/JQuery.validate/
一、代码验证模式简单Demo
关键引用：
&lt;script src="~/Scripts/validate/jquery.validate.min.js"&gt;&lt;/script&gt; &lt;script src="~/Scripts/validate/localization/messages_zh.min.js"&gt;&lt;/script&gt;HTMl代码： &lt;h2&gt;常用业务类型格式验证&lt;/h2&gt; &lt;div class="panel panel-success"&gt; &lt;div class="panel-heading"&gt; &lt;div class="panel-title"&gt; 前台验证表单后提交 &lt;/div&gt; &lt;/div&gt; &lt;div class="panel-body"&gt; &lt;form role="form" class="form-horizontal"&gt; &lt;div class="form-group"&gt; &lt;label class="col-sm-2 control-label"&gt;昵称：&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control " name="nickname" placeholder="请输入昵称3-10字符" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="control-label col-sm-2"&gt;博客地址：&lt;/label&gt; &lt;div class="col-sm-10"&gt; &lt;input class="form-control " name="blog" placeholder="个人博客地址" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label class="control-label col-sm-2"&gt;邮箱：&lt;/label&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a28fe3a4aa1bceedb04b9b06953b381/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436cf2eb335b967cab765021152b519c/" rel="bookmark">
			Bitmap和drawable的互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在代码时遇到了些问题，当发送网络请求获取图片数据将图片，但是返回的是bitmap数据但是设置background需要drawable才能用所以我需要将bitmap转换为drawable，写下此片总结方便以后查阅。有的情况不需要转类型，其实在我的案例中将图片设置match_parent，然后使用帧布局将图片当做背景也能实现效果。
一、Bitmap转Drawable
Bitmap bm=xxx; //xxx根据你的情况获取 BitmapDrawable bd=BitmapDrawable(bm);
Android开发网提示因为BtimapDrawable是Drawable的子类，最终直接使用bd对象即可。
二、Drawable转Bitmap
1，根据已有的Drawable创建一个新的Bitmap:
private Bitmap bitmap; private void drawableToBitamp(Drawable drawable) { int w = drawable.getIntrinsicWidth(); int h = drawable.getIntrinsicHeight(); System.out.println("Drawable转Bitmap"); Bitmap.Config config = drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565; bitmap = Bitmap.createBitmap(w,h,config); //注意，下面三行代码要用到，否在在View或者surfaceview里的canvas.drawBitmap会看不到图 Canvas canvas = new Canvas(bitmap); drawable.setBounds(0, 0, w, h); drawable.draw(canvas);} 2,直接从现有的Drawable中取出Bitmap:
private Bitmap bitmap; private void drawableToBitamp(Drawable drawable) { BitmapDrawable bd = (BitmapDrawable) drawable; bitmap = bd.getBitmap(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b5853f5c878ba1f07c31cb23ddce06/" rel="bookmark">
			STM32F0库应用技术笔记——iar工程建立&amp;时钟管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发环境 我目前是在如下开发环境下操作的， 软件
iar for arm开发工具STM32F0xx_StdPeriph_Lib_V1.5.0库 硬件
STM32F030F4P6最小系统板ST Link V2调试工具TTL转USB串口工具 创建iar for arm工程 拷贝库文件到工程 把STM32F0xx_StdPeriph_Lib_V1.5.0库中Libraries放到工程目录中。同时拷贝库中Projects\STM32F0xx_StdPeriph_Templates路径下以下三个文件到工程目录中
stm32f0xx_conf.h stm32f0xx_it.c stm32f0xx_it.h system_stm32f0xx.c 工程options...配置 C++ Compiler -&gt; Preprocessor -&gt; Additional include directiries:(one per line)配置如下，要注意的是CMSIS库头文件搜索路径设置为iar安装路径中最新的头文件，这是因为 iar 版本升级后，使用STM32F0xx_StdPeriph_Lib_V1.5.0中CMSIS老的库头文件编译会出错。
$PROJ_DIR$\ $TOOLKIT_DIR$\CMSIS\Include $PROJ_DIR$\..\..\Libraries\CMSIS\Device\ST\STM32F0xx\Include $PROJ_DIR$\..\..\Libraries\STM32F0xx_StdPeriph_Driver\inc C++ Compiler -&gt; Preprocessor -&gt; Defined symbols:(one per line)添加如下宏定义
USE_STDPERIPH_DRIVER STM32F030 Debugger -&gt; Setup -&gt; Driver中，选择ST-LINK， Debugger -&gt; Setup -&gt; Download中，复选框，选中Verify download以及Use flash loader(s)
组织工程文件 在工程中添加system_stm32f0xx.c，startup_stm32f030.s文件，在main.c文件中，添加#include "stm32f0xx_conf.h"，如下图所示， 工程创建完毕。 工程中如果需要使用某个驱动库，直接添加进图示STM32F0xx_StdPeriph_Driver组中， 如果需要使用到中断添加stm32f0xx_it.c到工程中即可。
接下来才正式进入主题。这里会从时钟管理，接口技术一步步建立库使用例程。在实际开发中，只需要拷贝+修改就可以快速完成功能模块开发。
STM32F0——时钟管理 概述 这一部分主要是配置系统时钟（CPU主频）及各总线时钟，包括了AHB，APB，IIC，USART,RTC等。在工程组织文件system_stm32f0xx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32b5853f5c878ba1f07c31cb23ddce06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3195f2bbe77badeda84ba9152ee84420/" rel="bookmark">
			Topological Sort拓扑排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机科学中有很多问题的本质就是一个排序的问题，排序中最简单直接的形式就是对一堆数字进行排序。但是还有一些情况和数字没有关系的，这些情况下也需要进行一定的排序。比如说，穿衣服的过程，你首先需要穿上内衣，然后才能穿上外套，继而才能带上手表等佩戴物。这些事情都是需要排序的，但是这些事情的排序就不是简单的数字排序，因为这里面压根就没有数字。 那么面对这样的问题，我们怎么排序呢？最容易想到的问题就是使用拓扑排序，英文是topological sort。拓扑排序的基本思想就是使用一个有向无环图（Directed Acyclic Graph，简称DAG）来描述，这个图大致的形状如下： 从图中可以看到，DAG图的特点如下： 1. 有向：所有节点之间的链接都是有方向的，所有的链接逻辑都必须和这个方向一致。比如上图中A点只能到C点，而C点不能到A点 2. 无环：所有的节点之间有向链接没有构成一个环 回到上面我们提到的问题，我们可以将首先需要做的事情放到只有扇出没有扇入的节点，也就是说，可以把穿内衣这件事情放到B点中。这就意味着，没有任务需要在B之前完成，只有B完成了，和B链接的点才能开始工作。 接下来的问题就是，我们怎么把这个图变成一个有序的序列呢？比如队列。这个问题就是拓扑排序的问题。通常来讲，这就是一个图的遍历过程，一般有两种方式：深度优先（Depth First Search，简称DFS）和链接关系队列。
DFS方式 首先，我们使用的是深度优先的方式，我们可以随意选择一个点，然后开始深度扫描，但是需要注意的是链接的方向，不能逆方向扫描。我们假设扫描一个点需要一个单位的时间，我们在扫描的时候会记录下每个点扫描开始的时间和扫描结束的时间（扫描结束的意思是，这个点可以达到的节点全部都扫描完毕），整体上扫描完毕的效果如下图： 上图中，每个节点上都有一个开始时间和结束时间，斜杠前面是开始时间，后面是结束时间。现在我们只关注结束时间，只要是结束时间越大的，就要越首先做。按照这个规则这里节点的操作顺序应该是这样： 我们从逻辑上思考一下，发现这个顺序是合理的。但是这个方式究竟是不是正确的呢？结论是正确的，我们可以使用严格的数学证明来证明这件事情，关于证明过程，这里就不详述了，大家可以参考相关数据结构或者算法的书即可。
链接关系队列 如果让我们人来分析这个图中的点操作顺序的话，我们应该会怎么考虑这件事情呢？我们肯定会首先寻找只有扇出没有扇入的节点，也只有这样的节点才意味着它没有先导操作，这一点很容易理解。因此，我们的第二种操作方式：链接关系队列，就是采用这个想法。 整体的操作过程是这样的：我们首先制作一个列表，这个列表中可以容纳图中所有的节点： 上图中，每个格中的数字代表下方字母在拓扑图中的扇入数目。我们的操作逻辑是：首先建立一个队列，然后将上图中的扇入数为0的节点首先入队。然后我们操作的顺序是从队首开始取出节点，取出之后就将这个节点从队列和拓扑图中删除（注意，连同这个节点的链接边也一同删除）。删除节点之后，我们就要重新计算上图表格中的链接数字，因为这个时候链接已经发生变化了。之后就再次选择扇入数目为0的节点加入队列，重复以上操作。那么最终队列出队的顺序就是我们最终的操作顺序，大家可以尝试自己操作一下，你会发现和上面的顺序是一样的。
复杂度分析 我们重点分析时间复杂度，我们假设拓扑图中有n个节点和m条边。下面我们首先分析下DFS的复杂度：DFS会遍历所有的节点和所有的边，因此复杂度很好分析那就是O(n + m)，这是一个线性时间，比较好的算法。 链接关系队列方式，首先需要init一个拥有n个节点的列表，并且需要遍历一遍图中的边逻辑；另外由于减少一个点的时候和他相邻的点是已知的并且这些点的扇入数是可以理解计算出来的，因此这个方式的时间复杂度也是O(n + m)，同样是一个线性时间。
参考资料 台湾国立清华大学在线资料：http://www.csie.ntnu.edu.tw/~u91029/DirectedAcyclicGraph.html#1
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/538/">«</a>
	<span class="pagination__item pagination__item--current">539/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/540/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>