<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a4832a3cbefe88d570dd87bd9d8605/" rel="bookmark">
			C&#43;&#43;标准库类型，bitset类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bitset类 std::bitset类的主要作用是提供一种简单而高效的方式来处理位数据。在某些情况下，位操作是非常有用的，例如在编写加密算法、压缩算法、图形处理等应用程序时。使用std::bitset，可以轻松地表示和操作二进制位，而不需要自己实现位运算。
std::bitset还可以用于位图操作。在计算机图形学中，位图是一种将图像表示为二进制位序列的方式，每个位代表图像中的一个像素。使用std::bitset，可以轻松地创建、修改和操作这些位图。
此外，std::bitset还可以用于位集合的表示和操作，例如在集合论、布尔代数和离散数学中。在这些领域中，位集合经常用于表示一个有限集合，其中每个元素由一个二进制位表示，该位对应的值为1表示元素存在，否则为0。
总之，bitset是一个十分有用的工具，可以方便地处理位数据，帮助我们更加高效地编写代码。
定义和初始化bitset bitset类是一个类模版，它类似于array类，具有固定的大小。当我们声明一个bitset类时，需要声明它包含了多少个二进制位，如：bitset&lt;32&gt; bit (1); //共32位，低位为1，其余位都为0。二进制位为 0000 0001
这个大小必须是一个常量。上例bit是一个含有32个位的bitset。我们可以用下标运算符去访问对应的位数。因此，bit包含从0到31，共32个二进制位。从编号0开始的二进制位被称为低位，编号到31结束的二进制位被称作是高位。
下面是一些常见的定义和初始化std::bitset对象的方法：
使用默认构造函数
std::bitset&lt;8&gt; bits; // 创建一个有8位的bitset，默认所有位的值都是0 使用整数类型初始化
std::bitset&lt;8&gt; bits1(0b10101010); // 创建一个有8位的bitset，初始化值为10101010（二进制） std::bitset&lt;8&gt; bits2(170); // 创建一个有8位的bitset，初始化值为170（十进制） 使用字符串初始化
std::bitset&lt;8&gt; bits1("10101010"); // 创建一个有8位的bitset，初始化值为10101010（二进制字符串） std::bitset&lt;8&gt; bits2("AA", 16); // 创建一个有8位的bitset，初始化值为AA（十六进制字符串） 复制初始化
std::bitset&lt;8&gt; bits1("10101010"); // 创建一个有8位的bitset，初始化值为10101010（二进制字符串） std::bitset&lt;8&gt; bits2 = bits1; // 使用bits1的值创建一个新的bitset 如果初始值的二进制位大于或小于bitset的小怎么办？ 当我们使用一个整形值来初始化一个bitset是时，这个值会被转换为 unsigned long long 类型，并被当做位模式来进行处理。我们的bitset的二进制位会去与这个值的二进制位从低位到高位去做一一对应。
如果bitset的二进制位多于这个值的二进制位数了话，则bitset中剩余的高位会被置为0。
如果bitset的二进制位少于这个值的二进制位数了话，则这个值超出bieset的最大位数的二进制位则会被舍弃。
例如我将一个十进制数15去赋值给一个bitset大小为8的类型：
bitset&lt;8&gt; bit (15); // 二进制序列为 0000 1111 int a = bit.to_ulong(); //a = 15 例如我将一个十进制数15去赋值给一个bitset大小为3的类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a4832a3cbefe88d570dd87bd9d8605/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/961d720c5198fe8e079900b584d23349/" rel="bookmark">
			蓝桥杯嵌入式--LCD屏幕使用提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前在专栏里已经介绍过LCD相关库文件的移植，今天来介绍一下对于LCD屏幕的使用技巧。
屏幕基本配置与函数 一、屏幕初始化 使用lcd前的必要步骤就是对LCD屏幕进行初始化操作，这也是一个容易忘记的操作。
LCD_Init();\\使用lcd前的必要步骤就是对LCD屏幕进行初始化操作 二、清屏 void LCD_Clear(u16 Color); 该函数的作用是把LCD屏幕上的内容清空，并且将屏幕颜色设置为传入的颜色参数。
三、清行 void LCD_ClearLine(u8 Line); 该函数作用是将屏幕上特定行的内容清空，不改变背景颜色，除非清空前设置了背景色。
四、设置背景与字体颜色 void LCD_SetTextColor(vu16 Color); //设置文本颜色 void LCD_SetBackColor(vu16 Color);//设置背景颜色 我对这两个函数的理解在于对于LCD函数的分类上。其实不难发现，LCD函数分为设置类与输出类两种。
一般来说都是设置对其后的输出产生影响，换句话说，大家不要想当然认为SetBackColor后屏幕的背景色就会整体变色，设置背景色只对后面的输出函数造成影响。
举个例子：
LCD_Init(); /* USER CODE END 2 */ LCD_Clear(Blue); LCD_SetBackColor(white);//设置背景色为白 LCD_SetTextColor(Black);//设置文本为黑 LCD_DisplayStringLine(Line4,(uint8_t*)"Hello World"); HAL_Delay(2000); LCD_SetBackColor(Black); //设置背景为黑 LCD_ClearLine(Line4); 刚开始
2s后
上面这个结果告诉我们：设置背景与字体颜色只对后面输出语句那一行起作用，并且如果不更新会一直保持之前的设置。
五、显示一行字符串 void LCD_DisplayStringLine(u8 Line, u8 *ptr) 这个函数大家用的最多了，但是我们需要注意，后面输入的参数为一个u8的指针,如果我们直接输出字符串，会出现报错，要在前面加上（uint8_t*）,如果传入的是一个uint8_t类型的数组，则不需要担心这个问题。
LCD_DisplayStringLine(Line2,(uint8_t*)" PASSWORD "); 并且要熟知，一行只能显示20个字符。
其实重点在于如何在字符串中传入参数。
sprintf函数 sprintf函数用于格式化输出，使用前需要包含头文件“stdio.h”
int sprintf( char *buffer, const char *format [, argument,...] ); sprintf(准备存储的数组名,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/961d720c5198fe8e079900b584d23349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77ff8001e2027b09db2375c3e7fbb5a/" rel="bookmark">
			Mac OS Wireshark 权限不足
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Mac OS Wireshark 权限不足 切换为root用户
sudo su root切换到/dev目录
cd /dev查看bpf文件的权限（Wireshark监控数据包需要有bpf的读权限）
ls -l | grep bpf
bpf文件的权限为：root用户具有读写权限，同组内其他用户无任何权限，组外其他用户无任何权限。
我之前是以自己的账户执行的Wireshark，自然没有bpf文件的读权限。
解决问题的方式有很多种，都是从权限着手，我这里选择的是放开bpf文件对组外其他用户的读权限。修改bpf文件的权限
chmod 604 bpf*
重启Wireshark即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/784b3a05f2ba89fb60befc6aff2c4b4f/" rel="bookmark">
			转行音视频开发，怎么做？需要学哪些技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一位大一读者留言，说“想转行音视频开发，怎么做？需要学哪些技术”
想说一句：真有眼光。
如今这个时代，想赚钱，一个共识是，得先选对赛道。有些行业和领域，终其一生的天花板也不过如此。但有的朝阳行业，你一进去就可以获得大量的机会，就是“ROI（投入产出比）”很高。
那就聊聊为啥从事音视频技术，未来会很赚钱。
要说音视频技术，在这两年迎来爆发期。首先 5G 的发展提供了硬件条件，又受疫情的影响，生活场景线上化，大量的线上办公、线上教育、线上娱乐等需求，让几亿人涌入各类线上互动平台。比如：
抖音和快手的短视频，需要应用图像处理和视频编码技术，如何在保持高画质的情况下，尽量减少视频文件的大小；
连麦直播需要 RTC 和直播技术，如何能够保证在各种网络状况下实现超低延时、降低卡顿率；
视频会议需要 RTC 和转码合流服务等技术，几十上百人的大型视频会议，如何保证流畅度、卡顿率、画质等指标等；
随着线上体验的增加，人们对互动中的音频体验要求也在提升。除了听得到、听得清，还得好听、音质还原度高等。例如，Facebook 改名 Meta 进军元宇宙，TWS 耳机支持了空间音频渲染和主动降噪等等。
可以说，音视频技术就如同空气和水，无处不在，未来充满无限可能。而且这些真实场景都强调实时互动，延迟必须控制在毫秒级别内，如果在这个过程中，出现延时高、卡顿、画面模糊、杂音大等情况，你可以想象会出现什么样的体验吗？别说李佳琪双 11 直播带货 100 亿了，正常打一把沟通流畅的王者荣耀都不一定。
其实，早在疫情初期，很多 SaaS 平台甚至大厂都出现过卡顿问题，主要对突如其来的流量没有做好充分准备，而如今大家都看到了线上的市场，自然对音视频技术人才的需求就多了。
所以不夸张地说，音视频开发是一片蓝海，人少，钱多。而且未来，会更加炙手可热。
这张图供参考。但也能看出来，整体薪资待遇比普通开发者要优厚很多。不仅如此，从网上随手一搜，就能看到某某安卓转音视频，真香了、突破就业危机等等。 如今除了大厂，很多小公司也在寻找音视频的人才，稍微好点的音视频人才可能同时 3～4 家公司抢着要。就是因为从业人才基数低，高端人才缺乏，最重要的是，音视频技术有开发门槛，不好培养，也很难自学。但这也意味着，你跟别人相比有技术上的核心竞争优势，有分水岭。
/ 快速入门音视频技术的方法，有吗？ / 本文福利， 免费领取C++音视频学习资料包、技术视频/代码，内容包括（音视频开发，面试题，FFmpeg ，webRTC ，rtmp ，hls ，rtsp ，ffplay ，编解码，推拉流，srs）↓↓↓↓↓↓见下面↓↓文章底部点击免费领取↓↓
音视频技术学起来并不容易，要懂的东西太多：音视频的采集、编码、传输、解码、渲染...等等，网上也少见体系化的资料。
但就像左耳朵耗子所说，“要去知识的源头学习”。对学习者来说，找到优质的信息源可以让你事半功倍，不是二手加工的，也不会有信息损失或有误。那么，怎样快速找资料及学习音视频开发呢？
可以从以下学习路线入手：
一、音视频开发基础 二、音视频进阶成长知识 ​三、流媒体客户端 ​四、流媒体服务器 五、WebRTC 项目实战 六、Android NDK开发 一、音视频开发基础 二、音视频进阶成长知识 三&amp;四、流媒体 五、WebRTC 项目实战 六、Android NDK开发 ↑↑上面的大纲是一条清晰的C++音视频开发学习路线。从易到难，从FFmpeg基础到音视频项目实践，了解更多关于音视频开发课程内容，↓↓↓↓↓见下面↓↓文章底部了解↓↓↓
音视频就业方向 相信很多伙伴在音视频工作方向这个十字路口，有过徘徊、迷茫。个人建议是选择自己喜欢的方向，如果还没找到自己所爱，努力去寻找，借用雷总的话“不要害怕做出选择”。一旦做出选择，就要把工作当做事业，不仅仅是为了工作而工作，借用乔布斯的话“Do what you love, love what you do”。把音视频工作方向总结为 9 个(可能不够准确，仅是个人观点)：直播、传输、算法、视频播放器、流媒体后端、短视频、音频播放、视频编辑、图像处理。具体方向如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/784b3a05f2ba89fb60befc6aff2c4b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1700df94459c2a6a559df05fb07bde87/" rel="bookmark">
			【转】Typora 安装包2021年11月最后一次免费版本的安装包下载V13.6.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载地址：
链接：https://pan.baidu.com/s/1GOw6o1rkqdNFEJFFy1BzFA
提取码：6666
版本号：13.6.1
事件：
Typora开始收费了，15天试用，上限3台设备。碰巧我是这个月刚刚安装的Typora，刚好下载了Win的安装包。Linux版本和Mac版本没有。
更新：2022年7月7日
今天发现这玩意要求我们强制更新：
我去淘宝买了一个，居然是吾爱破解发布的1.1.5版本。
不过嘛看来一下，改改注册表就能接着用啦。
1.
regedit打开：计算机\HKEY_CURRENT_USER\SOFTWARE\Typora
2. 修改IDate
比如修改为2077，这样再打开Typora就能成功运行了。
这样还没完，因为Typora又会偷偷把这个值修改过来，好大的官位，把他他乌纱帽给爷卸了：右键Typora-&gt;权限
这样它就乖乖就范了。
————————————————
版权声明：本文为CSDN博主「喵喵锤锤你小可爱」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42820594/article/details/121589887
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d612cd298d599447b00aa58827175f4a/" rel="bookmark">
			TOF传感器、摄像头传感器、超声波传感器、激光雷达、毫米波雷达
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、智能网联汽车关键技术
二、传感器总结
三、TOF传感器
四、摄像头传感器
五、超声波传感器
六、激光雷达
七、毫米波雷达
八、参考文献
该文是应用于自动驾驶的传感器的学习总结
————————————————————————————
一、智能网联汽车关键技术 环境感知、智能决策、控制执行是智能网联汽车的关键技术：
其中环境感知是通过各种传感器对车辆行驶环境进行动态感知，为决策模块提供输入，实现自动驾驶的基础。
不同的传感器来源就分成了2种感知形式：自主式环境感知、协同式环境感知。
环境感知：包括车辆的行驶路径、车辆周围的参与者、 驾驶状态和驾驶环境等：
行驶路径 结构化道路：检测车辆行驶路径的两侧车道线和各种车道标线；
非结构化道路：车辆的可行使区域
交通参与者 车辆周围的其他车辆、行人
地面可能影响车辆通过和安全的其他移动或静止物体
各种交通标志和交通信号灯等
驾驶状态 驾驶员自身状态
车辆自身行驶状态
车辆周围其他车辆行驶状态
驾驶环境 路面状况
道路交通拥堵情况
天气状况
对于动态对象，除识别外还需要进行轨迹跟踪 二、传感器总结 传感器选型主要有以下条件:
(1）扫描范围，决定了传感器对被感知的目标做出反应的时间;
(2）分辨率，传感器可以为车辆提供的环境细节;
(3）视场角分辨率，决定智能网联汽车需要多少传感器来覆盖感知的区域；
(4）感知目标数量，能够区分3D环境中的静态目标和动态目标的数量，并且确定需要跟踪的目标数量；
(5）刷新率，决定传感器信息更新的频率;
(6）可靠性和准确性，传感器在不同环境条件下的总体可靠性和准确性；
(7〉成本、尺寸和软件兼容性，这是环境感知传感器量产的技术条件之一；
(8）生成的数据量，它决定了车载计算单元的计算量，现在传感器偏向智能传感器，不仅仅是感知，还会分辨信息，把对车辆行驶影像最重要的数据传输给车载计算单元，从而减少其计算负荷。
三、TOF传感器 1、ToF是飞行时间（Time of Flight）的缩写，ToF传感器采用的是红外光，当光从物体上反射回传感器后，根据光的发射与反射的时间差，就可以计算出传感器与测量物体之间的距离；
2、ToF传感器也被称为“深度相机”（depth camera）或者ToF相机；
3、ToF传感器本身由两部分组成：第一部分是发射红外光的二极管，第二部分是特殊的光敏矩阵。传感器测量从物体反射回来的时间可以精确到纳秒级，ToF传感器还有一个重要特性使其成为一个3D传感器。那是因为ToF传感器不仅可以准确计算单个物体与传感器的距离，利用激光返回时间和波长的差异，还能对目标进行精确的数字三维（3D）表征，并直观地绘制出目标的各个特征，为我们提供一个三3D图像。
4、优势和不足：低功耗（3W）、小尺寸、精确快速的测量（纳秒级测量）、深度精度比2D摄像头高、远距离测量、安全性高、成本效益高、能接收动态信息更适合动态场景、可以在恶劣的光照条件下捕捉深度和红外图像；散射光带来的伪影（如果被测物体表面特别明亮且非常靠近ToF传感器，它们会将太多的光散射到接收器中，并产生伪影和不必要的反射）、多次反射带来测量的不确定性（当在拐角和凹面上使用ToF传感器时，光线可能会被多次反射，这些不必要的反射将给测量带来很大的不确定性）、环境光对测量带来不利影响（当在阳光明媚的户外使用ToF传感器时，高强度的阳光会导致传感器像素的快速饱和，从而无法检测到物体反射的实际光）；
5、ToF与LiDar的对比：
①激光雷达（LiDar）是激光探测和测距的缩写，这项技术使用一个激光器作为光源；LiDar使用光脉冲来测量飞行时间，LiDar激光雷达比ToF的测量速度更快且更加精确
②ToF传感器则利用连续波从反射和相移得到飞行时间（即远距离都不会大量衰减），ToF需要较少的专用设备，因此可以与更小、更便宜的设备一起使用
6、3D ToF相机在下一代汽车中具有巨大的应用潜力。该技术有助于车辆实时获得良好的环境感知，实现快速机动和避障，这也是自主驾驶不可或缺的能力。3D ToF还可以用来监控驾驶员和乘客的状态（眼球、动作、姿势、视线、安全带、物体遗留检测、物体分类和识别、移动支付，并在紧急情况下接管车辆的控制。3D ToF相机的手势检测可用于设置室内气候控制或切换到来电。ADI公司开发的ToF模块结合影像传感器和VGA ToF传感器模块与内建图像处理器方案，比传统音波检测具备更佳的检测角度，也更能准确测量物体跟汽车的距离。因此可为汽车倒车系统、开门防护系统、停车辅助系统及盲点侦测等应用提供更大范围的碰撞侦测预防。
7、3D ToF相机能提供实际场景中物体的高分辨率3D深度映射。与传统的2D成像相比，这是一个显著的优势，因为它提供了高度的可信度，可以根据精确的位置对人和物体进行分类。
四、摄像头传感器 1、摄像头传感器，顾名思义就是通过摄像头拍摄车辆周边场景，并以此来识别车辆、行人、行车线等的传感器。从拍摄到的影像可以检测出车辆及车灯、行车道的白线及标识、行人及自行车等。
2、摄像头传感器分为单镜头摄像头和多镜头立体摄像头两种。单镜头摄像头识别的是平面影像，而多镜头立体摄像头内置2个摄像头，除了可以识别立体物体，还可以测算到目标物体的距离。
3、摄像头传感器通过获取摄像头拍摄的车辆周边的实景画面，从实景画面中抽取场景特征信息、调整显像浓度，对画面进行预处理。根据预处理结果，更容易辨别对象的特征及形状、颜色等信息，从而提高检测速度。
4、目标物体处理流程：图像传感器通过图像处理识别对象物体，根据驾驶辅助ECU检测到的信息进行内容识别、判断、控制车辆。
5、检测车道：从经过处理的图像上抽取边缘画面（亮度变化大的区域），从边缘画面中找出行车线标记（车道两侧的实线及虚线，直道显示为直线），通过行车线标记测定车道。基于行车线信息获取车道中央位置、车辆行进方向及测算距离，从而识别、判断、控制车辆。
6、检测道路标识：从经过处理的图像上抽取对应的候补点，寻找由各点分布构成的直线、曲线、平面等任意图形，按照特定的模板推定标识。通过标识信息进行判断并控制车辆。
7、检测行人：人物图像由于体型、姿势、衣着等因素影响较难识别。因此，从图像中区分出静止的背景和运动的人物，需要根据模型化部位（手脚等较大部位的图形）以及统计性特征（全身图像等）进行识别，符合特征的则被判定为行人。根据车辆与行人间的位置关系及测算的距离，识别、判断、控制车辆。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d612cd298d599447b00aa58827175f4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0647ac22597bdc43887cb234dd8a23f8/" rel="bookmark">
			List＜Long＞转为String[]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List&lt;Long&gt;转为String[] ； Long类型的集合转化为Sting类型数组；
各种转....
List&lt;Long&gt; ids = ....
String[] array = ids.stream().map(x -&gt;x + "").collect(Collectors.toList()).toArray(new String[ids.size()]);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3306b5f223c03ed9e3e696ac9e556cc/" rel="bookmark">
			vue-element 封装loading
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TS封装
import { ElLoading } from "element-plus"; let loading: { close: () =&gt; void }; let flag: boolean = true; function openLoading() { if (flag) { loading = ElLoading.service({ customClass: "osloading", // *这里设置他的class名称 fullscreen: true, //是否全屏 lock: false, //是否锁定全屏滚动 body: true, // text: "加载中...", // spinner: "el-icon-loading", background: "rgba(255, 255, 255, 0.7)", }); flag = false; } setTimeout(function () { flag = true; }, 200); } function closeLoading() { if (loading !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3306b5f223c03ed9e3e696ac9e556cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb02a9af72a872cf236775cf594f1163/" rel="bookmark">
			蓝桥杯IDE问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日在蓝桥杯做题，代码在自己的Dev C++上运行正确，在洛谷在线IDE运行正确，但是在蓝桥杯IDE运行出错，并且将别人的题解粘贴在蓝桥杯IDE中也是错误结果，有人知道是为什么吗？？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b885b1451c165a9fe268f697910cddb/" rel="bookmark">
			如何实现双因素认证？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		增强数字安全的愿望引起了世界各国政府的关注，所有政府都希望保护消费者和企业。因此，许多人提出了立法，将两因素身份验证 (2FA) 作为 IT 系统的强制性要求。其实，在我国等级保护制度中等级保护第三级以上都要求完成双因素认证的，我们接下来看看国外有关双因素要求与实现。
强制执行 2FA 要求 2021 年 5 月 12 日，美国总统乔·拜登发布了一项行政命令，使 2FA 成为所有政府机构的法律要求 。联邦调查局、国土安全部和国家安全局等联邦机构有 180 天的时间对所有数据实施 2FA 保护。
在英国，面对外国机构日益增加的威胁，国家网络安全中心 (NCSC) 向英国企业发布了强有力的指导。建议中包括为其系统包含 2FA 登录保护。
类似的 2FA 要求在行业框架中也变得越来越普遍。支付卡行业数据安全标准 (PCI DSS) 的最新版本 现在需要 2FA 或多因素身份验证 (MFA) 来执行与帐户相关的任务，例如某些类型的支付。通过添加登录要求，提供商能够更好地保护其客户免受欺诈。
其他处理敏感个人信息的行业也在效仿。在美国，正在采取措施改进《健康保险流通与责任法案》(HIPAA)，以纳入 2FA 要求。通过使用二级身份验证加强对敏感患者数据的访问，提供者可以保护患者的机密性。
为什么 2FA 要求很重要？ 2FA 的主要好处是能够加强外围防御并降低恶意行为者访问公司或政府系统的风险。通过添加额外的身份验证层，用户能够更好地保护自己，企业可以帮助保护客户免受欺诈、身份盗用、勒索和其他损失。
在政府或行业层面强制实施 2FA 为数字落后者提供了一个令人鼓舞的推动力，以更新他们的访问控制系统，以造福于他们的用户和客户。 绕过 2FA 容易吗？ 很难绕过 2FA。如果无法直接访问用户的二级身份验证方法，例如智能手机、应用程序或硬件令牌，则几乎不可能完成 2FA 流程的第二阶段。这使得受 2FA 保护的系统更难被攻破，因此更加安全。
当您准备将 2FA 纳入您的数字安全协议时，您还应考虑其他几个问题，包括：
1) 如何满足2FA 要求？ 与任何安全控制一样，必须仔细规划 2FA 部署，以确保正确保护您的资产。您将面临的最大挑战之一是在旧系统上启用 2FA 并将该技术与您现有的环境集成。如果不解决这些问题，您的新防御措施就不可能像您希望的那样全面。
2) 哪些账户需要2FA？ 仅将 2FA 应用于管理员级别帐户或具有允许他们进行系统和安全配置更改的权限的帐户可能很诱人。但是，这种方法不足以解决 数据 访问权限。例如，您的销售经理可能无法添加防火墙规则，但他们可以访问客户数据库中受 GDPR 保护的个人信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b885b1451c165a9fe268f697910cddb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dbfd7eabff3213dfa09596fda8ae733/" rel="bookmark">
			Java guava框架 LoadingCache，CacheBuilder 本地小容量缓存框架学习以及总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Guava Cache本地缓存框架介绍 主要是一种将本地数据缓存到内存中，但数据量并不能太大，否则将会占用过多的内存，虽然框架本身已经做了相当的数据回收，但还是不可以滥用，需要符合以下优点场景，才是合适使用，访问内存的速度快于访问 redis 等数据库。
有点以及需求场景:
对性能有非常高的要求愿意消耗一些内存空间来提升速度预计到某些键会被多次查询缓存中存放的数据总量不会超出内存容量 关键点是：有频繁访问的数据，且这些数据本身占用内存量很少，将这些数据存储到该缓存框架中管理以提供性能。
提供的优势能力 缓存可以设置过期时间，并提供数据过多时的淘汰机制是线程安全的，支持并发读入和写入缓存获取不到时可以从数据源获取并加入到缓存中，GuavaCache 可以使用 CacheLoader 的load 方法控制，对同一个key，只允许一个请求去读源并回填缓存，其他请求阻塞等待可以查看缓存的加载获取信息等 使用以及方法 Maven 依赖：
&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;20.0&lt;/version&gt; &lt;/dependency&gt; 最简单的构建案例：
Cache&lt;String, Object&gt; cache = CacheBuilder.newBuilder().build(); cache.put("aaa", 156484); 与Map类似,获取时使用get() 方法即可获取到放入其中的数据。
通过 CacheBuilder 创建 Cache 对象，存储类似于Map 构建方法为链式构造，类似于 builder 建造者模式，返回均为当前对象本身，调用 build 方法后结束构造。
CacheBuilder.newBuilder() 后的一些构建参数方法介绍： initialCapacity：缓存的初始数据容量大小，一般要贴合实际否则会造成资源浪费
maximumSize：缓存中可包含最大 entry 数量，超过数量限制后淘汰 entry,接近最大值时淘汰不常用数据，设置为 0 时为不使用缓存的场景，用于测试数据加载
过期时间设置 expireAfterAccess：数据写入后被访问对象多久没被访问认为过期
expireAfterWrite： 数据被写入到缓存后一直未更新多久后过期
可以如下写：
Cache&lt;String, Object&gt; cache = CacheBuilder.newBuilder() .initialCapacity(5) .maximumSize(10) .expireAfterWrite(10, TimeUnit.MINUTES).build(); cache.put("154", "djawbdawd"); 过期时间单位通过 TimeUnit 后的控制，时分秒均可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dbfd7eabff3213dfa09596fda8ae733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9b1567f6dc10b23371a2492c5f94c4/" rel="bookmark">
			面向对象编程跟面向过程的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2分钟让你明白什么是面向对象编程 相信很多刚开始接触编程的小伙伴，对于什么是面向对象，什么是面向过程都是一脸懵逼的。
网上关于这两个的回答真的很多，但是都有一个共同特点：------------不容易懂。
让我们来看看某百科给出的定义:
是不是听不懂？？为了解决大家的疑惑，小编今天上网收集了一些资料，现在就简单通俗的为大家介绍一下到底什么是面向对象编程和面向过程编程
一、先来两小段通俗解释 面向过程（Procedure Oriented 简称PO ：如C语言）：
从名字可以看出它是注重过程的。当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些方法（每个方法看作一个过程），等方法执行完了，事情就搞定了。
面向对象（Object Oriented简称OO ：如C++，JAVA等语言）：
看名字它是注重对象的。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。
二、用3个例子说明两者的区别 例子一：
问题： 洗衣机里面放有脏衣服，怎么洗干净？
面向过程的解决方法：
1、执行加洗衣粉方法；
2、执行加水方法；
3、执行洗衣服方法；
4、执行清洗方法；
5、 执行烘干方法；
以上就是将解决这个问题的过程拆成一个个方法（是没有对象去调用的），通过一个个方法的执行来解决问题。
面向对象的解决方法：
1、我先弄出两个对象：“洗衣机”对象和“人”对象
2、针对对象“洗衣机”加入一些属性和方法：“洗衣服方法”“清洗方法”、“烘干方法”
3、针对对象“人”加入属性和方法：“加洗衣粉方法”、“加水方法”
4、然后执行
人.加洗衣粉
人.加水
洗衣机.洗衣服
洗衣机.清洗
洗衣机.烘干
解决同一个问题 ，面向对象编程就是先抽象出对象，然后用对象执行方法的方式解决问题。
例子二 ： 打麻将例子 你 我 他
面向过程： 打麻将 （你，我，他）
---------解决问题 拆成一个动作，把数据丢进去
面向对象： 我.打麻将（你，他） or 你.打麻将（我，他） or 他.打麻将(我，你)
---------解决问题 抽象出对象，对象执行动作 。
例子三：
最后在用一个网上常见的五子棋例子来说明一下：
面向过程的设计思路就是首先分析问题的步骤：
1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用不同的方法来实现。
面向对象的设计则是从另外的思路来解决问题。
整个五子棋可以分为1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。
可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。
三：面向过程与面向对象的优缺点： 小编在看了@十四期_李光 博客上解释的非常通俗易懂，分享给大家
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee9b1567f6dc10b23371a2492c5f94c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c4bc9e8189c63e66605f3111d6355f/" rel="bookmark">
			[已解决]requests.post(url,data)报ValueError:too  many  values  to  unpack (expected 2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中使用requests库请求接口时，报错ValueError:too many values to unpack (expected 2)，一直搜了两天，都没解决，故写此文，已做参考。
分析:此文面向的是requests.post的报错。
报错翻译:有太多的值无法解压缩，翻译过来，左边接收的变量和右面生成的值的个数对不上
解决:
1.我对request.post(url,data)中的data做了序列化处理，变成:request.post(url,json.dumps(data))，因为前后端通过json交互。
2.执行1操作后，http状态码成415，一般是请求头问题，故指定请求头
headers ＝｛“Content-Type”:“application/json”｝
代码为
result＝request.post(url,json.dumps(data),headers＝headers)
然后看看效果:
print(res)
print(res.text)
print(res.json)
code码为200，接口调通。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ff63b68e69c063c3221a496048a614/" rel="bookmark">
			Spring Batch快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spring Batch简介 在企业开发中可能会面临到一些需要处理较大数据量的场景，例如将一个表的全部数据导入到另一张表结构类似的表中、批量读取一个或多个文件内容并写入到数据库中，又或者将一张表的数据批量更新到另一张表中。Spring Batch可以快速的开发这种场景下的批处理应用程序。 Spring Batch提供了在处理大量数据时必不可少的可重用功能，包括 日志记录/跟踪、事务管理、作业处理统计信息、作业重新启动、跳过和资源管理。对于 大数据量和高性能的批处理任务，Spring Batch 同样提供了高级功能和特性来支持，例如 分区功能、远程功能等，大大简化了批处理应用的开发，将开发人员从复杂的任务配置管理过程中解放出来，让我们可以更多地去关注核心的业务的处理过程。总之，通过 Spring Batch 我们就能够实现简单的或者复杂的和大数据量的批处理作业。 1.1 Spring Batch结构图 JobRepository：用来注册job的容器
JobLauncher：用来启动Job的接口
Job：实际执行的任务，包含一个或多个Step
Step：包含ItemReader、ItemProcessor和ItemWriter
ItemReader：用来读取数据的接口
ItemProcessor：用来处理数据的接口
ItemWriter： 用来输出数据的接口
官网地址如下：
https://spring.io/projects/spring-batch
1.2 处理架构 任务的处理是在 Step 这个阶段定义的。在 Step 中，需要定义数据的读取、数据的处理、数据的写出操作，在这三个阶段中，数据的处理是真正进行数据处理的地方。具体 Step 的流程如下图所示：
Reader（架构图中的 Item Reader）：主要的任务是定义数据的读取操作，包括读取文件的位置、对读取首先要进行的划分（如以 ',' 作为分隔符）、将读取到的文件映射到相关对象的属性字段等
Process（架构图中的 Item Processor）：这里是真正对数据进行处理的地方，数据的处理逻辑都在这里定义
Writer（架构图中的 Item Writer）：这个阶段的主要任务是定义数据的输出操作，包括将数据写入到数据库等
1.2 Spring Batch数据库表格 当批处理作业需要操作数据库时，Spring Batch要求在数据库中创建好批处理作业的元数据的存储表格。如下，其中以batch开头的表，是Spring Batch用来存储每次执行作业所产生的元数据。而student表则是作为我们这个Demo中数据的来源： 下图显示了所有6张表的ERD模型及其相互关系（摘自官网）：
1.3 Spring Batch Sql脚本 在数据库中执行官方元数据模式SQL脚本：
-- do not edit this file -- BATCH JOB 实例表 包含与aJobInstance相关的所有信息 -- JOB ID由batch_job_seq分配 -- JOB 名称,与spring配置一致 -- JOB KEY 对job参数的MD5编码,正因为有这个字段的存在，同一个job如果第一次运行成功，第二次再运行会抛出JobInstanceAlreadyCompleteException异常。 CREATE TABLE BATCH_JOB_INSTANCE ( JOB_INSTANCE_ID BIGINT NOT NULL PRIMARY KEY , VERSION BIGINT , JOB_NAME VARCHAR(100) NOT NULL, JOB_KEY VARCHAR(32) NOT NULL, constraint JOB_INST_UN unique (JOB_NAME, JOB_KEY) ) ENGINE=InnoDB; -- 该BATCH_JOB_EXECUTION表包含与该JobExecution对象相关的所有信息 CREATE TABLE BATCH_JOB_EXECUTION ( JOB_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY , VERSION BIGINT , JOB_INSTANCE_ID BIGINT NOT NULL, CREATE_TIME DATETIME NOT NULL, START_TIME DATETIME DEFAULT NULL , END_TIME DATETIME DEFAULT NULL , STATUS VARCHAR(10) , EXIT_CODE VARCHAR(2500) , EXIT_MESSAGE VARCHAR(2500) , LAST_UPDATED DATETIME, JOB_CONFIGURATION_LOCATION VARCHAR(2500) NULL, constraint JOB_INST_EXEC_FK foreign key (JOB_INSTANCE_ID) references BATCH_JOB_INSTANCE(JOB_INSTANCE_ID) ) ENGINE=InnoDB; -- 该表包含与该JobParameters对象相关的所有信息 CREATE TABLE BATCH_JOB_EXECUTION_PARAMS ( JOB_EXECUTION_ID BIGINT NOT NULL , TYPE_CD VARCHAR(6) NOT NULL , KEY_NAME VARCHAR(100) NOT NULL , STRING_VAL VARCHAR(250) , DATE_VAL DATETIME DEFAULT NULL , LONG_VAL BIGINT , DOUBLE_VAL DOUBLE PRECISION , IDENTIFYING CHAR(1) NOT NULL , constraint JOB_EXEC_PARAMS_FK foreign key (JOB_EXECUTION_ID) references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID) ) ENGINE=InnoDB; -- 该表包含与该StepExecution 对象相关的所有信息 CREATE TABLE BATCH_STEP_EXECUTION ( STEP_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY , VERSION BIGINT NOT NULL, STEP_NAME VARCHAR(100) NOT NULL, JOB_EXECUTION_ID BIGINT NOT NULL, START_TIME DATETIME NOT NULL , END_TIME DATETIME DEFAULT NULL , STATUS VARCHAR(10) , COMMIT_COUNT BIGINT , READ_COUNT BIGINT , FILTER_COUNT BIGINT , WRITE_COUNT BIGINT , READ_SKIP_COUNT BIGINT , WRITE_SKIP_COUNT BIGINT , PROCESS_SKIP_COUNT BIGINT , ROLLBACK_COUNT BIGINT , EXIT_CODE VARCHAR(2500) , EXIT_MESSAGE VARCHAR(2500) , LAST_UPDATED DATETIME, constraint JOB_EXEC_STEP_FK foreign key (JOB_EXECUTION_ID) references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID) ) ENGINE=InnoDB; -- 该BATCH_STEP_EXECUTION_CONTEXT表包含ExecutionContext与Step相关的所有信息 CREATE TABLE BATCH_STEP_EXECUTION_CONTEXT ( STEP_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY, SHORT_CONTEXT VARCHAR(2500) NOT NULL, SERIALIZED_CONTEXT TEXT , constraint STEP_EXEC_CTX_FK foreign key (STEP_EXECUTION_ID) references BATCH_STEP_EXECUTION(STEP_EXECUTION_ID) ) ENGINE=InnoDB; -- 该表包含ExecutionContext与Job相关的所有信息 CREATE TABLE BATCH_JOB_EXECUTION_CONTEXT ( JOB_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY, SHORT_CONTEXT VARCHAR(2500) NOT NULL, SERIALIZED_CONTEXT TEXT , constraint JOB_EXEC_CTX_FK foreign key (JOB_EXECUTION_ID) references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID) ) ENGINE=InnoDB; CREATE TABLE BATCH_STEP_EXECUTION_SEQ ( ID BIGINT NOT NULL, UNIQUE_KEY CHAR(1) NOT NULL, constraint UNIQUE_KEY_UN unique (UNIQUE_KEY) ) ENGINE=InnoDB; INSERT INTO BATCH_STEP_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_STEP_EXECUTION_SEQ); CREATE TABLE BATCH_JOB_EXECUTION_SEQ ( ID BIGINT NOT NULL, UNIQUE_KEY CHAR(1) NOT NULL, constraint UNIQUE_KEY_UN unique (UNIQUE_KEY) ) ENGINE=InnoDB; INSERT INTO BATCH_JOB_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_EXECUTION_SEQ); CREATE TABLE BATCH_JOB_SEQ ( ID BIGINT NOT NULL, UNIQUE_KEY CHAR(1) NOT NULL, constraint UNIQUE_KEY_UN unique (UNIQUE_KEY) ) ENGINE=InnoDB; INSERT INTO BATCH_JOB_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_SEQ); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ff63b68e69c063c3221a496048a614/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55922401279735e5058767f714899b1/" rel="bookmark">
			温度传感器DS18B20【单总线时序结构】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DS18B20介绍 DS18B20是一种常见的数字温度传感器，其控制命令和数据都是以数字信号的方式输入输出，相比较于模拟温度传感器，具有功能强大、硬件简单、易扩展、抗干扰性强等特点
测温范围：-55°C 到 +125°C
通信接口：1-Wire（单总线）
其它特征：可形成总线结构、内置温度报警功能、可寄生供电
引脚及应用电路 内部结构框图 64-BIT ROM：作为器件地址，用于总线通信的寻址
SCRATCHPAD（暂存器）：用于总线的数据交互
EEPROM：用于保存温度触发阈值和配置参数
存储器结构 单总线介绍 单总线（1-Wire BUS）是由Dallas公司开发的一种通用数据总线
一根通信线：DQ
异步、半双工
单总线只需要一根通信线即可实现数据的双向传输，当采用寄生供电时，还可以省去设备的VDD线路，此时，供电加通信只需要DQ和GND两根线
单总线电路规范 设备的DQ均要配置成开漏输出模式
DQ添加一个上拉电阻，阻值一般为4.7KΩ左右
若此总线的从机采取寄生供电，则主机还应配一个强上拉输出电路
单总线时序结构（重点） 初始化：主机将总线拉低至少480us，然后释放总线，等待15~60us后，存在的从机会拉低总线60~240us以响应主机，之后从机将释放总线
发送一位：主机将总线拉低60~120us，然后释放总线，表示发送0；主机将总线拉低1~15us，然后释放总线，表示发送1。从机将在总线拉低30us后（典型值）读取电平，整个时间片应大于60us
接收一位：主机将总线拉低1~15us，然后释放总线，并在拉低后15us内读取总线电平（尽量贴近15us的末尾），读取为低电平则为接收0，读取为高电平则为接收1 ，整个时间片应大于60us
发送一个字节：连续调用8次发送一位的时序，依次发送一个字节的8位（低位在前）
接收一个字节：连续调用8次接收一位的时序，依次接收一个字节的8位（低位在前）
DS18B20操作流程 初始化：从机复位，主机判断从机是否响应
ROM操作：ROM指令+本指令需要的读写操作
功能操作：功能指令+本指令需要的读写操作
DS18B20数据帧 温度存储格式 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28383b4580cc1f95a2ef76df62787508/" rel="bookmark">
			Android布局优化-include、merge以及ViewStub使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、inlude 标签 inlude 标签用于 xml 复用，实现布局模块化，减少开发者工作量。
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;merge xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;TextView android:id="@+id/tv_title" android:layout_width="match_parent" android:layout_height="45dp" android:text="标题" android:gravity="center"/&gt; &lt;/merge&gt; &lt;!--layout_title.xml--&gt; &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".ui.UIOptimizeActivity"&gt; &lt;include android:id="@+id/include" layout="@layout/layout_title"/&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; include 的标签是否有效？
1、id：
a）在同一个 xml 下 include 两次 layout_title.xml 并对 include 标签分别设置不同的 id ，运行应用之后使用 layout inspector 查看，发现 Activity 中存在两个 id 为 tv_title 的 TextView（应该是 layout inspector 的问题），TextView 的 id 并没有发生改变.
b）将 merge 标签改为未设置 id 的 LinearLayout 运行之后使用 layout inspector 查看 发现 include 的 id 被添加到 LinearLayout 之上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28383b4580cc1f95a2ef76df62787508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae3b27d51d9a26bc92ed6d123502d1d7/" rel="bookmark">
			DC-DC产生负电压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的 产生一个负电压使用。
实现方法来源
方法 使用非同步整流DC-DC降压芯片实现，本次测试使用MP4560。
测试 空载 1A负载 电子负载接线
结论： 使用非同步整流DC-DC芯片可以产生负电压，带负载能力没有减弱。
非同步整流DC-DC芯片简单鉴别方法 检查电感跟前有没有哪个续流二极管，同步整流的芯片都没有续流二极管。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e4049e8857ced763578ae46dabb499/" rel="bookmark">
			CSS基础之动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动画
1）过渡：需要结合鼠标
动画：网页只要运行动画就可以立即生效。
创建动画的方式：（1）方式一：
from：起点 to：终点
@keyframes 动画的名字{ from{} to{} } (2) 方式二：
@keyframes 动画的名字{ 0%{} 100%{} } 如果一个元素的运动点位只有起点和终点,那么2种方式都可以
但是如果元素的运动点位有多个,那么必须使用百分比的方式,我们在0%和 100%之间可以写很多的百分点的.
使用动画（属性）:
1.动画的名字 animation-name(必须写的)
2.动画的运动时间 animation-duration(必须写的)
3.动画的延迟时间 animation-delay
4.动画的运动曲线 animation-timing-function
5.动画的运动次数 animation-iteration-count 写数字几就是运动几次 infinite无限次 运动
6.动画的运动反向 animation-direction
//normal====正常,从起点运动到终点
//reverse===反转,从终点运动到起点
//alternate===正反交替运动
//alternate-reverse====反正交替
7.动画的播放状态 animation-play-state
running===播放(运动),默认值
paused===暂停
这个效果需要结束鼠标一起使用
简写方式:animation:需要什么写什么.
注意:延迟时间一定要写在运动时间的后面,其他值没有书写顺序.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac7d89a401006a6c2a1594dfe8b3d875/" rel="bookmark">
			MicroPython开发esp32入门笔记--串口篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、串口简介二、串口通信1. UART协议层原理2. RS232，RS485，TTL电平的区别 三、 ESP32开发 - - 基于串口和MQTT协议1. 氮磷钾土壤传感器2. MicroPython 实现数据读取和发布的代码 总结 一、串口简介 串行接口简称串口，也称串行通信接口或串行通讯接口（通常指COM接口），是采用串行通信方式的扩展接口。串行接口 （Serial Interface）是指数据一位一位地顺序传送。其特点是通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。
二、串口通信 通用异步收发传输器(Universal Asynchronous Receiver/Transmitter)是串口通信的介质，通常称作UART，是一种异步收发传输器。
首先介绍以下同步和异步通信，同步是指，发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式；异步是指，发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。换句话说，同步通信是阻塞方式，异步通信是非阻塞方式。在常见通信总线协议中，I2C，SPI属于同步通信而UART属于异步通信。同步通信的通信双方必须先建立同步，即双方的时钟要调整到同一个频率，收发双方不停地发送和接收连续的同步比特流，就像你打电话一样双方要同时在电话两头然后才能沟通交流。异步通信在发送字符时，发送端可以在任意时刻开始发送字符，就像你给别人微信发消息留言，在UART通信中数据起始位和停止位是必不可少的，不然你不知道该接受哪些信息。
1. UART协议层原理 协议层中，规定了数据包的内容，它由起始位、主体数据、校验位以及停止位组成，通信双方的数据包格式要约定一致才能正常收发数据 。
波特率：异步通信中由于没有时钟信号，所以2个通信设备需约定好波特率，常见的有4800、9600、115200等。波特率的单位是每秒传送的位数。
通信的起始和停止信号：串口通信的一个数据包从起始信号开始，知道停止信号结束。数据包的起始信号由一个逻辑0的数据位表示，而数据包的停止信号可由0.5、1、1.5或2个逻辑1的数据位表示，只要双方约定一致即可。
有效数据：在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为8位或9位长。
数据校验：在有效数据之后，有一个可选的数据校验位。由于数据通信相对容易受到外部干扰导致传输数据出现偏差，可以在传输过程加上校验位来解决这个问题。校验方法有奇校验(odd)、偶校验(even)、0校验(space)、1校验(mark)以及无校验(noparity)。
奇校验要求有效数据和校验位中“1”的个数为奇数，比如一个 8 位长的有效数据为：01101001，此时总共有 4 个“1”，为达到奇校验效果，校验位为“1”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位。偶校验与奇校验要求刚好相反，要求帧数据和校验位中“1”的个数为偶数，比如数据帧：11001010，此时数据帧“1”的个数为 4 个，所以偶校验位为“0”。0 校验是不管有效数据中的内容是什么，校验位总为“0”，1 校验是校验位总为“1”。
2. RS232，RS485，TTL电平的区别 RS232电气特性
在RS-232-C中任何一条信号线的电压均为负逻辑关系，即逻辑“1”为-3到-15V;逻辑“0”为+3到+15V。
设备与PC机连接的RS-232接口，因为不使用对方的传送控制信号，只需要三条接口线，即“发送数据TXD”、“接收数据RXD”和“信号地GND”。RS-232传输线采用屏蔽双绞线。
RS485电气特性
采用差分信号负逻辑，逻辑"1”以两线间的电压差为-(2-6)V表示;逻辑"0"以两线间的电压差为+(2~6)V表示。RS485接口信号电平比RS-232-C降低了，就不易损坏接口电路的芯片， 且该电平与TTL电平兼容，可方便与TTL电路连接。RS-485的数据最高传输速率为10Mbps。
TTL电气特性
TTL电平信号被利用的最多是因为通常数据表示采用二进制规定，+5V等价于逻辑“1”，0V等价于逻辑“0”，这被称做TTL(晶体管-晶体管逻辑电平Transistor-Transistor Logic)信号系统，这是计算机处理器控制的设备内部各部分之间通信的标准技术。
三、 ESP32开发 - - 基于串口和MQTT协议 1. 氮磷钾土壤传感器 氮磷钾五插针土壤传感器采用RS485电平标准，可以较为精准地测量土壤的温度，含水量，电导率，PH值，以及土壤中氮、磷、钾的含量
土壤传感器可连接各种载有差分输入的数据采集器，数据采集卡，远程数据采集模块等设备，接线说明如下图：
为了用ESP32的串口读取土壤传感器测出的数据，我们需要准备一个RS485转TTL模块，接线的方式是将模块上的RXD接ESP32上的TXD引脚，将模块上的TXD接ESP32上的RXD引脚，将RS485电平标准转换为TTL电平，然后根据串口从机主机一收一发的通信原理进行传感器的数据读取
根据土壤传感器手册的数据读取原理，我们用ESP32的UART发送一串16进制数组，分别是地址、功能码、起始寄存器地址的高四位和低四位、寄存器长度高四位和低四位、CRC16的高四位和低四位，转成16进制数就是下面表格
地址0X01功能码0X03起始寄存器地址高0X00起始寄存器地址低0X00寄存器长度高0X00寄存器长度低0X07CRC16低0X44CRC16高0X09 若土壤传感器接收正确，将返回以下16进制数的数组，我们需要用UART读取16进制数的数组，然后我们还要将其转化为10进制数，并按照预定的计算式转化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac7d89a401006a6c2a1594dfe8b3d875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e377f160340076e712c3aba5fd3bbcd4/" rel="bookmark">
			漏洞修复中常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.rpm -Uvh *.rpm rpm -qa |grep 文件名查看版本 2.yum update 更新所有可以更新版本的软件包 rpm -qa XXX 查看XXX版本信息 3.yum update -y yum install -y yum localinstall(提前下载好rpm包) 4. 直接install会出现一些需要的依赖不满足时，可以采用以下命令： yum install XXX --skip-broken rpm -Uvh XXX.rpm --nodeps --force 5.不想提前下载安装包时可用 wget http://download.redis.io/releases/redis-6.0.3.tar.gz tar xzf tar包 进入解压目录，make 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e1aabd6e2b95fe2c1ceb18738599bd/" rel="bookmark">
			搭建Vue脚手架遇到的一些问题和问题的解决方案。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言：
第一次搭建Vue脚手架，和我想的一样并没有想的那么顺利，当我满怀期待去运行我写好的组件时，一串串红色的error，直击我的心灵，这也不禁让我想起了一首诗，雄关漫道真如铁，而今迈步从头越难关，哈哈哈，接下来看看我在搭建Vue脚手架并运行的过程中遇到了哪些问题吧！
一，在安装vetur插件之后，当我创建一个Vue文件时，在template里面单独写一段注释时，在一段解析过后，弹出两个警告。 解决方案：打开vscode里面的一个配置项就可以了。
二，当时我的组件是写在我的D盘，而搭建Vue脚手架是在Desktop上搭建的，在我搭建完毕后，把我的App.vue文件和其它组件文件也放到了相应的配置文件夹内，运行的时候给我报了两个错误 模块未找到:错误:无法解决(Can‘t resolve ‘xxx‘ in ‘D:\briup\vue_test\node_modules\send) 错误原因：组件引入 App.vue/其他组件 时出错了,首先仔细检查引入的文件名大小写及单词拼写是否正确!!!其次检查一下组件引入的路径是否正确，我这里就是因为从另一个路径复制过来，导致路径不正确。
错误路径：
改完之后的正确路径：
三，定义的文件名错误。 错误原因： 这里是你的vue文件名字不是它推荐的多单词形式，如schoolName。
解决方案：这里由于没有找到更好的解决方案，我只能被逼无奈按照他的要求给文件名改成小驼峰形式(schoolName)。
总结：搭建Vue前一定要看看搭建的是Vue2环境，还是Vue3环境，是不是你想要的环境。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74a68eccaf886daee7bd01a76812cc4/" rel="bookmark">
			算法题记录【华为od】单词倒叙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 思路分析 将字符串转变成数组,利用数组方法将单词倒叙,之后再拼接数组进行输出
代码解析 后话 只是记录，正在找工作中，各位老板缺前端的可以私信，会vue,react,ts,js，22届本科毕业，一年工作经验
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ebcbced4cf03432cc9fc1c024a56faf/" rel="bookmark">
			git初始化配置，以及常用操作验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、git下载、安装与配置1.1 下载与安装1.2 git配置 二、配置公钥三、创建版本库初始化3.1 创建本地库3.2 创建远程库 四、常用操作4.1 克隆代码：4.2 添加代码：4.3 提交代码：4.4 push代码：4.5、查看分支：4.6、切换分支：4.7、Pull代码：4.8、查看本地当前分支和远程那个分支对应： 参考与转载 一、git下载、安装与配置 1.1 下载与安装 1.1.1登录git官网：Git (git-scm.com)点击击图中红线圈出的Downloads,进入下载页面。
1.1.2根据自己系统，下载相应git软件（本人是win11）。
​​​​​​1.1.3 根据自己电脑，选择32位，或者64位的软件，本人选择64位安装版本。
1.1.4下载完成后，运行安装软件，一路默认下去，完成安装（本人修改了安装路径，其他一路默认）。
1.2 git配置 1.2.1 在桌面空白处右键点击：Git Bash Here
1.2.2配置用户名
git config --global user.name “your username”
注意：用户名可以随意命名，由于本人使用的是gitee,所以用户名与邮箱均与其一致，方面记忆和后续操作。
​​​​​​​1.2.3配置用户邮箱
git config --global user.email “your email address”
​​​​​​​1.2.4 查询是否设置成功
git config user.name
git config user.email
或者用如下一条命令也可以：
git config --list --global
注：之后就可以开始git之旅了，可以先在本地目录初始化仓库，然后推送到git托管平台（本人使用的gitee）。也可以先在网页端，建立远程仓库，拉取到本地目录，在目录中添加要编辑管理的代码文件，编辑、修改、测试后更新到git托管平台。
二、配置公钥 git配置公钥：GitLab配置ssh key - 阿豪聊干货 - 博客园
当前很多公司都选择git作为代码版本控制工具，然后自己公司搭建私有的gitlab来管理代码，我们在clone代码的时候可以选择http协议，当然我们亦可以选择ssh协议来拉取代码。但是网上很少找到如何用git客户端生成ssh key，然后配置在gitlab，我当时在做的时候苦于摸索，后来终于找到了解决方案，那么本文，我们就来聊一聊如何本地git客户端生成ssh key，然后配置在gitlab里，而后使用ssh协议进行提交和拉取git远程仓库的代码。 打开本地git bash,使用如下命令生成ssh公钥和私钥对
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ebcbced4cf03432cc9fc1c024a56faf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420031f729cafdb91f9c722bd1774515/" rel="bookmark">
			隐语容器部署指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、单机版本部署 docker 最新的版本请查看 secretflow tags
https://hub.docker.com/r/secretflow/secretflow-anolis8/tags
启动容器
docker run -itd secretflow/secretflow-anolis8:${version} 测试 进入容器 docker exec -it docker_hash bash 生成csv数据 import csv def write_id_to_csv(count): with open("id_{}.csv".format(str(count)), "w") as f: writer = csv.writer(f) writer.writerow(["id"]) for v in range(count): writer.writerow([str(v)]) 初始化spu并测试 单机容器下没有启动ray集群服务，只是ray本地调用 # 单机版，sf.utils.testing.cluster_def 建立SPU。请注意它只能在单机模式下使用，因为它使用了 127.0.0.1 作为默认ip。 import secretflow as sf sf.shutdown() sf.init(['alice', 'bob', 'carol'], num_cpus=8, log_to_driver=False) # 虚拟化三个逻辑设备 alice, bob = sf.PYU('alice'), sf.PYU('bob') spu = sf.SPU(sf.utils.testing.cluster_def(['alice', 'bob'])) # 求交 input_path = {alice: 'id_count.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/420031f729cafdb91f9c722bd1774515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e9425cb7fb8af916cff9c0f60ec279/" rel="bookmark">
			[刷题 java版] | 字节跳动2019算法笔试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.万万没想到之聪明的编辑
我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：
1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello
2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello
3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC
我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！
……
万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的……
请听题：请实现大锤的自动校对程序
数据范围：1≤n≤50 ，每个用例的字符串长度满足 1≤L≤1000 import java.util.Scanner; // 暴力求解 public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int a = in.nextInt(); while (a-- &gt; 0) { String s = in.next(); for (int i = 2; i &lt; s.length(); i++) { if (s.charAt(i) == s.charAt(i - 1) &amp;&amp; s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e9425cb7fb8af916cff9c0f60ec279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ded83f6c97c1b7d0e517dd5b2bd872a/" rel="bookmark">
			交换机与路由实验常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设置交换机特权密码在全局模式下： 设置加密密码：switch(config)#enable secret密码
设置明文密码：switch(config)#enable password 密码
设置交换机控制台密码在全局模式下 switch(config)#line console 0
switch(config-line)#password 密码
switch(config-line)#login
设置交换机Telnet密码 在全局模式下switch(config)#line vty 0 4 switch(config-line)#password 密码
switch(config-line)#login
交换机工作模式 1.配置模式切换
switch&gt; //普通用户模式
switch&gt;enable //进入特权用户模式
switch# //特权用户模式
switch#configure terminal //进入全局配置模式
switch(config)# //全局配置模式
switch(config)#interface f0/1 //进入接口配置模式
switch(config-if)# //接口配置模式
switch(config-if)# exit //返回上一级模式
switch(config)# switch#disable //退出特权模式
switch&gt;
switch(config-if)#end //直接返回特权模式
switch#
2.修改交换机的名字(Hostname)
switch#configure terminal switch(config)#hostname switch1 //修改交换机名字为“switch1”
3.设置交换机端口参数
switch1(config)#interface fastEthernet 0/1
switch1(config-if)#speed100 // 配置端口速率为100Mbps
switch1(config-if)#duplex half // 配置为半双工模式
switch1(config-if)#no shutdown //开启端口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ded83f6c97c1b7d0e517dd5b2bd872a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de814553cffa19ad20b278d5a9117987/" rel="bookmark">
			ubuntu18.04&#43;AX200无法找到wifi适配器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 用收拾开热点连接电脑，设置为USB网络共享 2. 安装backport-iwlwifi sudo apt install flex bison git clone https://git.kernel.org/pub/scm/linux/kernel/git/iwlwifi/backport-iwlwifi.git cd backport-iwlwifi sudo make defconfig-iwlwifi-public sudo make sudo make install 3. 安装iwlwifi git clone git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git cd linux-firmware/ sudo cp iwlwifi-* /lib/firmware/ 完成第3步后，重启就能看到wifi适配器了，但是还需要安装AX200驱动才能使用
4. 安装AX200 linux驱动 （1）首先需要去 Intel 官网上下载 Linux 版本的驱动：英特尔® 无线适配器的 Linux* 支持，
下载得：iwlwifi-cc-46.3cfab8da.0.tgz，
（2）解压并将文件copy到/lib/firmware/
tar -zxvf iwlwifi-cc-46.3cfab8da.0.tgz cd iwlwifi-cc-46.3cfab8da.0/ ls iwlwifi-cc-a0-46.ucode LICENSE.iwlwifi-cc.ucode README.iwlwifi-cc.ucode sudo cp * /lib/firmware 5. 重启 sudo reboot OK！重启后就可以连wifi啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49cb9fa7b5b80ec192c087394174fb1/" rel="bookmark">
			Jenkins实操--windows环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为Jenkins 是java 编写的，所以要先在本地环境安装 java JDK（必须是 17或者 9 版本的才兼容jenkins），然后安装Jenkins，然后以 管理员身份运行 powershell，进入到 Jenkisn 安装目录 执行命令：
java -jar jenkins.war --httpPort=8080（8080是 JK的默认端口，如果被占用可以尝试 其他 ：8888）
然后浏览器输入 ：http://localhost:8088/ 会出现如下界面：
然后是选择安装相关软件的 选择 —经典推荐安装包组合，和 自定义选择，我是选择推荐安装：
安装完之后创建用户：
保存完成，则所有的配置就完成了，后续启动JK只要后台运行，然后浏览器输入地址 就可以访问如下：
创建一个项目时 如果使用 github 仓库拉取代码，可能会因为代理设置不正确，导致报错：
git config --global http.proxy http://yourproxyaddress:port
go env -w GOPROXY=https://goproxy.cn,direct
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aadd0d375466eb477c884e2d9f68e26/" rel="bookmark">
			第四朵“云”！全托管的时序数据云平台 TDengine Cloud 正式支持阿里云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3 月 13 日，全托管的时序数据处理云服务平台 TDengine Cloud 正式支持阿里云，这是继 Microsoft Azure、AWS、Google Cloud 后 TDengine Cloud 上线的第四朵公有云。
在去年，TDengine 成功打造 TDengine Cloud 平台并率先上线海外云市场，目前已经发展有数百家注册企业。而国内的公有云支持工作也一直在如火如荼地推进，在 TDengine 研发小伙伴的不懈努力下，终于在今年 3 月，TDengine Cloud 在国内正式跟大家见面。
TDengine Cloud 是基于开源、高性能的时序数据库（Time Series Database,TSDB）TDengine 打造的具备弹性伸缩、Serverless 特性的时序数据处理服务。除高性能的时序数据库之外，它还具有缓存、订阅和流计算等系统功能，同时提供了便利而又安全的数据分享、基于角色的权限控制、多云数据复制、边云协同、IP 白名单等企业级功能。在时序数据的管理上，利用 TDengine Cloud，物联网、工业互联网、金融、IT 运维监控等领域企业可实现人力成本和运营成本的大幅降低。
下面详细介绍一下 TDengine Cloud 主要具备的三点优势：
极简的时序数据管理平台 除高性能、具有水平扩展能力的时序数据库外，TDengine Cloud 还提供缓存、数据订阅、流式计算等功能，无需再部署 Redis、Kafka、Spark/Flink 等第三方软件，大幅简化系统架构、降低运营成本。
便捷且安全的数据共享 TDengine Cloud 既支持将一个库完全开放，设置读或写的权限；也支持通过数据订阅的方式，将库、超级表、一组或一张表、或聚合处理后的数据分享出去。这种时序数据共享机制能够帮助企业各部门以及合作伙伴之间快速洞察业务运营的变化。
安全可靠的企业级服务 TDengine Cloud 提供数据定时备份、恢复，数据从运行实例到私有云、其他公有云或Region 的实时复制；为保证数据安全，还会提供基于角色的访问权限控制、IP 白名单、用户行为审计等功能，用 7*24 的专业技术服务保障 99.9% 的 Service Level Agreement。通过安全、专业、可靠的企业级服务，用户可以用最少的精力和成本完成数据管理，更加聚焦自身核心业务的发展。
TDengine 创始人&amp; CEO 陶建辉也一直在关注 TDengine Cloud 在国内云服务市场的推进工作，对于此次成功上线阿里云，他表示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aadd0d375466eb477c884e2d9f68e26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ac5d9d3edeb66e75df456605c9e077/" rel="bookmark">
			从微信小程序到抖音小程序：转换指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抖音小程序是一种新兴的小程序平台，与微信小程序类似，都是基于小程序框架的开发，不过两者的开发环境和API有所不同。如果你已经开发了一款微信小程序，想要将其转换为抖音小程序，可以按照以下步骤进行：
1.注册抖音小程序账号
首先需要注册一个抖音小程序账号，可以访问抖音小程序官网（https://microapp.bytedance.com/）注册账号，填写相关信息并进行实名认证。
2.安装开发工具
与微信小程序类似，抖音小程序也需要使用开发工具进行开发调试。可以访问抖音小程序官网下载最新版本的开发工具，安装并登录账号。
3.新建抖音小程序项目
在开发工具中，点击新建小程序项目，填写相关信息，选择抖音小程序的模板并创建。
4.导入微信小程序代码
将微信小程序代码文件夹复制到抖音小程序项目中，并根据抖音小程序的开发规范进行修改，例如修改app.js、app.json、app.wxss等文件中的配置信息。
5.修改API接口
抖音小程序的API接口与微信小程序有所不同，需要进行相应的修改。可以访问抖音小程序开发者文档（https://microapp.bytedance.com/docs）查看API接口的使用方式和文档。
6.调试和测试
在开发工具中对抖音小程序进行调试和测试，检查程序是否能够正常运行，是否有错误和问题。
7.提交审核
当抖音小程序开发完成后，需要将其提交审核。在开发工具中选择“上传”功能，填写相关信息并上传代码。上传成功后，可以在抖音小程序管理后台查看审核进度。
总之，将微信小程序转换为抖音小程序需要进行一些调整和修改，特别是API接口和开发环境等方面。开发者需要了解抖音小程序的开发规范和API接口，熟悉抖音小程序开发工具的使用，才能顺利地完成转换和开发工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54db88e0da94876f3ef10237b4a0c603/" rel="bookmark">
			HbuilderX运行出现npx browserslist@latest --update-db​
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的电脑是mac，HbuilderX版本是3.6.3
npm版本，7.21.0
node版本，v16.8.0
解决步骤。进入访达，找到HbuilderX应用，右键，显示包内容
2， 依次进入Contents &gt; HBuilderX &gt; plugins &gt; uniapp-cli
路径如下：/Applications/HBuilderX.app/Contents/HBuilderX/plugins
删除uniapp-cli下面的node——modules和package-lock.json文件
在uniapp-cli新建终端窗口（不知道怎么新建终端请看2.1）
2.1 新建终端
点击电脑左上角苹果标识，
进入 ‘系统偏好设置’ -&gt; '键盘' -&gt; '快捷键 -&gt; ‘服务’ 后
勾选“新建位于文件夹位置的终端标签页、窗口”
3，
在uniapp-cli新建终端窗口内输入npm i --legacy-peer-deps
回车
如果只输入 npm i 可能会出现报错：npm ERR! code ERESOLVE npm ERR! ERESOLVE could not resolve npm ERR! npm ERR! While resolving: uniapp-cli@3.6.3-2022091618 npm ERR! Found: webpack@5.76.2 npm ERR! node_modules/webpack npm ERR! peer webpack@"^5.1.0" from copy-webpack-plugin@11.0.0
如果出现权限问题，在前面加sudo
然后输入你的管理员密码
4，重新打开HbuilderX，运行，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b5cfecc6b3d7c0b34918bdfe47d679/" rel="bookmark">
			linux搭建ntp时间同步服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、NTP简介 NTP（Network Time Protocol，网络时间协议）用来使计算机时间同步的一种协议。它可以使计算机对其服务器或时钟源做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，WAN上几十毫秒）。对于服务器群集来说，这个是一个很重要的服务，因为群集需要保证每个服务器的时间是保持一致的，这样它们在执行同一个任务时才不会出现有的服务器有滞后的现象，这样群集的状态才是健康的。
我们在平时工作中可能会遇到内网环境中服务器因为不能联网而出现与正常时间不一致的情况，这时候可以采用搭建ntp时间同步服务器，让内网服务器以客户端的方式连接时间同步服务器，当然时间同步服务器要能连接外网，进行时间同步。
2、NTP原理 NTP的授时方式是Client—Server方式，客户端首先向服务端发送一个NTP 包，其中包含了该包离开客户端的时间戳T1，当服务端接收到该包时，依次填入包到达的时间戳T2、包离开的时间戳T3，然后立即把包返回给客户端。客户端在接收到响应包时，记录包返回的时间戳T4。从而计算出时间进行同步。
3、NTP服务端搭建 服务器规划：
192.168.149.20（能连接外网）
服务端192.168.149.21 （不能连接外网）客户端 （一）、NTP服务器端（192.168.149.20）安装
可以看到已经安装了ntp，大部分服务器都自带ntp服务
如果没有可以直接 yum -y install ntp进行安装
[root@node1 ~]# rpm -qa | grep ntp fontpackages-filesystem-1.44-8.el7.noarch ntp-4.2.6p5-29.el7.centos.2.x86_64 ntpdate-4.2.6p5-29.el7.centos.2.x86_64 （二）、配置NTP服务器端配置文件
下方是已经配好的，可以对照着修改
[root@node1 ~] vim /etc/ntp.conf # For more information about this file, see the man pages # ntp.conf(5), ntp_acc(5), ntp_auth(5), ntp_clock(5), ntp_misc(5), ntp_mon(5). driftfile /var/lib/ntp/drift # Permit time synchronization with our time source, but do not # permit the source to query or modify the service on this system.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b5cfecc6b3d7c0b34918bdfe47d679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce4edf2f7828c4aaf6805a30b5233cb/" rel="bookmark">
			Next.js入门｜一文带你梳理清楚 Next.js 的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面写了好几篇关于 Next.js 的文章，虽然都不长，但都是实际使用过程中的一些经验分享，不过这些文章对于不了解 Next.js 的人来说，可能很不友好，我也一直想重新梳理一下 Next.js 使用的方案。因此打算好好写一下 Next.js 相关运用，并整理到一个专栏，主要内容会从了解 Next.js 开始，然后逐渐搭建一个完整的项目模板，让没怎么接触过 Next.js 甚至 React 的小伙伴也能从中逐渐学习到一些东西，当然这个时间周期可能会比较长。感兴趣的可以关注一下作者。
大厂技术 高级前端 Node进阶 点击上方 程序员成长指北，关注公众号
回复1，加入高级Node交流群
前言 如果你用过 React 或者想尝试 React，那么建议你使用 Next.js 来搭建 React 项目，本篇文章将带你详细了解 Next.JS 主要的一些功能，看它能给我们带来什么样的能力，然后再谈一下对 React 单页应用的看法。
Next.js 可以带给我们什么？ Next.js 是一个 React web 应用框架，这是官方对自己的定义，然后它主要做的事情有以下几点：
完善的工程化机制
良好的开发和构建性能
智能文件路由系统
多种渲染模式来保证页面性能体验
可扩展配置
提供其他多方面性能优化方案
提供性能数据，让开发者更好的分析性能。
提供的其他常用功能或者扩展，比如使用 mdx 来编写页面的功能等等。
完善的工程化机制 你不需要自己去配置 webpack 方案，它已经内置了以下工程化基础：
babel 内置，支持JS代码向后兼容
postcss 内置，支持CSS代码向后兼容
browserslist 支持配置兼容的浏览器信息，配合 babel 和 postcss 工作。
TypeScript 可选择使用，保证代码的质量，以及可阅读性和可维护性。
eslint 可选择使用，检测代码格式，可自定义规则。vscode 编写代码，或者build打包时都会有提示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ce4edf2f7828c4aaf6805a30b5233cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d4e07c77ed619ea33a17df50fa8a72b/" rel="bookmark">
			ElasticSearch  Query_string &#43; match_phrase 在千亿级检索中的思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在舆情分析的应用场景中，数据规模通常在千亿以上。使用Elasticsearch 去构建搜索引擎，做相关的分析，面临着非常多的挑战。 先介绍一下，在舆情分析场景中，要用到的是 match phrase语法，针对文章做精准的句子匹配! 在这篇文章中： 1.我会先讲一下我们面临的挑战; 2.接着我会带着问题，分析一下 match phrase语法的检索过程； 3. 偏向底层的原理。 4.根据检索原理，考虑可以做哪些优化； 5.以及针对我们面临的挑战，我的一些优化方法。 目标 探索ES在千亿规模数据的检索场景下，句子精准匹配的性能优化方案。在实时交互的场景中，应对这么多的检索，达到注重3秒内的目标。本文会先讲一下，在舆情分析场景下使用ES做检索面临的诸多挑战。接着会对ES的检索原理做一个深度的拆解。
挑战背景 数据规模大，通常舆情分析，至少要在三个月的范围内做检索。加入将互联网上现有的所有的媒体数据拿到，是非常多的。例如微博、抖音、facebook、推特、等等。日均数据量假如都放在es中，可能少说也有N T（至少要在2T）。 假如在这样的数据规模中，三个月的数据就是 90 * N T 。通常我们会有一些数据是在一年范围内，甚至两年范围内做检索。那就是 365 * 2 * N T。这个规模去做实时交互，且想在个位数的秒级别中获取结果，需要非常多的计算资源。通常，一个es实例，可以高效的运行2T的数据。超过就性能会有下降。因为买不起机器，我们单台机器负载8T的数据。
要用到句子的精准匹配。通常在舆情检索场景中，用的并不是es的相关性检索，而是句子的精准匹配。这就不得不去使用ES中的 match_phrase 语法。去做句子的精准匹配。熟悉es的同学，应该会知道，es最擅长的是做term查询，其次是match 搜索，然后才是 match_phrase。 这就相当于是做的 like %中国%的检索。
检索条件复杂，检索的关键词多。通常要用很多的must 和must not，查询语句中包含多个操作符、子句和过滤器。也就是在一波检索中，可能要输出100+的检索词。所以这就不得不去使用 query string 搜索语法，且匹配的模式用 phrase（和match_phrase）一样的逻辑。
要命中全量的数据。在问答系统中，就像百度谷歌，只需要要返回与问题最相关的答案即可，通常在舆情场景下，要命中全量的数据。因为用户通常想要这个条件命中了多少条结果。
要有非常多的聚合分析。es聚合分析的性能并不高。因为它需要大量的CPU和磁盘的IO。在数据规模远超机器规模的情况下。整体的检索效果会非常的差。我有去考虑够其他类型的擅长做OLAP类型的数据库，例如CK，奈何它做句子匹配不太行。
在非结构化的数据中做检索。通常是在文章中做检索，而不是在某个字段中做检索。这回让检索变得格外的难。在做聚合分析的时候，像CK这样的数据库完全用不上。
实时交互。尽可能在3-5s内返回结果。以上问题，在实时交互的要求下，都变得格外严重。
总结一下：
说了这么多，就是资源不足。任何问题都可以通过加资源解决。问题是资源非常昂贵，所以我们要做的是，在有限的资源条件下，做无限的优化。
ES的 match_phrase的检索原理 先看看为什么match_phrase慢。
match_phrase 查询是 Elasticsearch 中的一种查询类型，它用于精确匹配包含一组特定词汇的文档。具体来说，match_phrase 查询会找到那些包含特定词组、并且词组中的单词以正确的顺序出现在文档中的文档。 es组织数据的方式只有一种，那就是切分词语，然后保存在倒排表中。理论上来说，性能最佳的一定是，根据一个词语，这个词语尽可能的短。然后做term查询。因为它只需要 match_phrase 查询的过程分析 Query Parsing：将用户输入的查询字符串解析为相应的查询语法。在解析的过程中，Elasticsearch会根据匹配类型、搜索字段、匹配条件等信息，生成相应的查询语句。例如，对于 match phrase 查询，Elasticsearch会生成一个 MatchPhraseQuery 对象，并将查询字符串作为参数传递给该对象。将查询语句解析成内部查询对象（Query Object），并进行语法和语义检查。在这个阶段，Elasticsearch会使用查询解析器（Query Parser）将查询语句解析成查询对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d4e07c77ed619ea33a17df50fa8a72b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e653237073c0a5036cbd5c11cb8e6333/" rel="bookmark">
			CSS基础之渐变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 渐变
1.线性渐变：多种颜色从一个方向到另外一个方向
注意：线性渐变如果加了浏览器的前缀，不加to，方向写的是起点；
不加浏览器的前缀，要加to，方向写的是重点，就只能运行在特定浏览器，针对浏览器实现效果不同
background: linear-gradient(to right,red ,green, blue); 2.径向渐变：让多种颜色向四周渐变
方式一：借助于方位词
方式二：借助于坐标，左上角为原点
注意：不加起点：默认中心，前缀可以不加；写了起点：必须加前缀，如果不加前缀，可能会导致效果出不来或者效果显示错误
1）径向渐变形状： 在长方形盒子中，渐变的形状默认是椭圆（圆形、椭圆两种效果）
在正方形盒子中，渐变的形状默认是圆型（只能显示出圆形）
更改形状，把形状单词写在颜色值之前即可
cricle=======圆
ellipsis=====椭圆
2）径向渐变的大小
closest-side：最近边
farthest-side：最远边
closest-corner：最近角
farthest-corner：最远边
3）重复性渐变
线性渐变：
background：repeating-linear-gradient（to right，red 0%，blue 20%，green 40%）； 径向渐变：
background：-webkit-repeating-radial-gradient（center，red 0%，green 20%，blue 50%）； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d6b56c19c8c5ba72682c3723dff7780/" rel="bookmark">
			多线程：实现三个线程轮流打印1-100的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 字节跳动笔试题 public class ThreadTest02 { public static void main(String[] args) throws InterruptedException { SynchronousQueue&lt;Integer&gt; one2two = new SynchronousQueue&lt;&gt;(); SynchronousQueue&lt;Integer&gt; two2three = new SynchronousQueue&lt;&gt;(); SynchronousQueue&lt;Integer&gt; three2one = new SynchronousQueue&lt;&gt;(); new Thread(new PrintTask(three2one, one2two)).start(); new Thread(new PrintTask(one2two, two2three)).start(); new Thread(new PrintTask(two2three, three2one)).start(); three2one.put(1); } } class PrintTask implements Runnable { private SynchronousQueue&lt;Integer&gt; in; private SynchronousQueue&lt;Integer&gt; out; public PrintTask(SynchronousQueue&lt;Integer&gt; in, SynchronousQueue&lt;Integer&gt; out) { this.in = in; this.out = out; } @Override public void run() { try { long id = Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d6b56c19c8c5ba72682c3723dff7780/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb1bd805dc982a33ed8997d6164748df/" rel="bookmark">
			pycharm unsupported Python 3.1报错：pycharm无法识别python 3.10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况概述： 本人电脑中的pycharm版本是2019的，在使用python3.10环境的时候，pycharm无法识别，出现如下错误：
网上说是因为python版本过高，无法兼容低版本的pycharm，解决方案分两种：要么降低python环境的版本，取消使用3.10，改用3.7或者3.8之类的版本；要么就是下载高版本的pycharm。这里我因为一些原因必须使用3.10，所以打算卸载pycharm2019，装更高版本的pycharm。
新的问题： 当我安装pycharm2022版本的时候，软件首次启动的界面中并没有免费试用30天的按钮，无法进入代码界面，除非激活或者是在线购买，所以卸载pycharm2022改装pycharm2021，然后2021版的也是这种情况，如下：
解决： 最后只能尝试pycharm2020版本的了，，，所幸2020版本的启动界面中有免费试用30天的按钮，然后点击进入代码界面，如下：
尝试在pycharm中使用3.10的python环境，如下：
可以正常使用！
点击进入pycharm官网，选择对应的pycharm版本下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5b408adf3830bedda7b1b4ead6b7d0/" rel="bookmark">
			【未解决】ubuntu系统上安virtualbox虚拟机装win10一路踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、情况说明
1、电脑Dell XPS 13 Linux系统ubuntu18.04
2、在ubuntu系统上安virtualbox虚拟机装win10系统，点击虚拟机start无法正常启动win10，会出现下图黑屏，无法调节设置里的显卡条。
（注：在ubuntu系统上安virtualbox虚拟机装win10系统这种操作本身不确定性因素非常多，所以具体原因排查起来很困难！有可能是对应的BIOS配置问题，也有可能是显卡问题！前辈给的建议是，不要这么样子的去安装内容！我们可以在win10系统中，安装虚拟机，然后在虚拟机中安装Linux操作系统！这种方式，出现的问题概率极低！）
二、安装过程遇到的问题及解决方法（上面黑屏是最后的问题，暂时解决不了所以放弃挣扎了）
1、安装虚拟机virtualbox见文章最下面的链接1
2、但点击虚拟机的Start时，会出现：
Kernel driver not installed (rc=-1908)
The VirtualBox Linux kernel driver is either not loaded or not set up correctly. Please reinstall virtualbox-dkms package and load the kernel module by executing
'modprobe vboxdrv'
as root.
......
问题接踵而至，在这个过程中的解决步骤如下，参考链接2、3：
（以下黄色亮底为实际操作或输入命令）
1）在终端以root身份执行：
sudo modprobe vboxdrv
2）vboxdrv 没有生效，是Linux内核专门用于驱动virtualBox驱动，叫做virtualbox-dkms
为当前内核重新安装一个驱动
sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms
3）提示进程被占用
于是重启电脑
在终端重新输入上面两条命令
4）提示dpkg was iterruoted,you must manually run ‘dpkg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f5b408adf3830bedda7b1b4ead6b7d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79a2916e6fa8ce703f962fa61c15b64a/" rel="bookmark">
			CSS基础之高度塌陷的三种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 相信很多小伙伴初学浮动，在页面布局的时候可能会出现这种现象，父元素身上没有设置高度，想让子元素撑起父元素，而给子元素添加浮动属性之后，父元素的高度为0的情况。
问题描述 高度塌陷：父元素没有设置高度，子元素浮动导致父元素高度受影响
原因分析： 这种情况是因为，给子元素添加浮动属性之后，子元素脱离文档流，不再占据位置，所以无法撑起父元素导致。快来看看以下的解决方案吧~
解决方案： 一、给出现高度塌陷的元素触发BFC（写overflow：hidden）
优点：简单
缺点：如果有一个元素定位到了大盒子外边，呢么这个元素就会被隐藏
二、隔墙法：给所有的浮动元素的后面创建一个空的div标签，写一个行内样式： clear：both；
优点：简单
缺点：会造成html代码冗余
三、万能清除法：（css）
.clear_fix::after { content: ""; display: block; width: 100%; height: 100%; overflow: hidden; visibility: hidden; clear: both; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991821244216da3e4c7e911581f35607/" rel="bookmark">
			Leetcode Day10 最长公共子序列&#43;字符串交织
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、最长公共子序列 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，“ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
【Link】
思路：很经典的dp题目了
class Solution { public: int longestCommonSubsequence(string text1, string text2) { int n1=text1.length(); int n2=text2.length(); vector&lt;vector&lt;int&gt; &gt;dp(n1+1,vector&lt;int&gt;(n2+1,0)); for(int i=1;i&lt;=n1;i++){ for(int j=1;j&lt;=n2;j++){ if(text1[i-1]==text2[j-1]){ dp[i][j]=dp[i-1][j-1]+1; }else{ dp[i][j]=max(dp[i-1][j],dp[i][j-1]); } } } return dp[n1][n2]; } }; 2、字符串交织 给定三个字符串 s1、s2、s3，请判断 s3 能不能由 s1 和 s2 交织（交错） 组成。
两个字符串 s 和 t 交织 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/991821244216da3e4c7e911581f35607/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4dfd7cbf5142395bdfefea387841eae/" rel="bookmark">
			机器学习算法基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 机器学习背景知识 1.1机器学习和深度学习 机器学习（machine learning）：从数据中自动分析获得规律，并利用规律对未知数据进行预测。
深度学习（deep learning）：是机器学习中神经网络算法的延伸， 相较于机器学习，深度学习能够提取数据更多的特征，并且能深入神经网络更多层。
1.2机器学习和人类思维 人类的学习过程：数据→信息→知识→智慧，其中智慧难以具体化。
机器学习的过程：信息→知识，需要的数据已经整理处理好。
1.3机器学习和深度学习知识框架 1.4数据挖掘 数据挖掘就是在大量的数据中通过算法搜索隐藏于其中信息的过程。在建模之前，可以把数据分为三个部分：训练集（traing data）、验证集（validation data）和测试集（test data），训练集是用来训练和构建模型，验证集是用来在模型训练阶段测试模型的好坏，测试集是等模型构建好之后，再用测试集来评估模型的好坏。
1.5监督学习、无监督学习和半监督学习 监督学习（supervised learning）：监督学习的算法下，使用的数据集都带有标签，监督学习是从标记的训练数据中来推断一个功能的机器学习任务。例如通过带有猫、狗标签的数据集中，构建一个模型用来区分猫和狗。
无监督学习（unsupervosed learning）：数据集在没有标签的前提下，通过构建模型将数据集中“相似”的数据集聚成几个类，然后再分类。
半监督学习：结合了监督学习和无监督学习，使用少量带有标签的数据集来训练和建模。
1.6回归、分类和聚类 回归：预测数据为连续性的数据。
分类：预测数据为类别性数据，并且类别已知（比如区分猫狗）。
聚类：预测数据为类别性数据，但是类别未知
第二章 线性回归及非线性回归 2.1一元线性回归 一元线性回归是一种机器学习算法，该分析方法只有一个自变量。
2.2代价函数 代价函数（loss function）是机器学习算法的理论基础，以一元线性回归y=kx+b为例：代价函数是f(k,b)，代价函数越大代表模型的预测性越差，而我们的目的是求k和b使代价函数最小。
损失函数的分类：（1）最小二乘法（2）极大似然法（3）交叉熵
最小二乘法：xi是目标值，yi是模型计算输出值
极大似然法：通过结果选出最近似的模型，即挑出似然值最大的概率模型
交叉熵：先把两个模型换成熵这个数值，再通过这个数值去比较不同模型之间的差异。（如果一个模型是高斯分布，另外一个模型是泊松分布，就需要引入中间参考量熵对这俩模型进行一个比较），交叉熵越小，两个模型越接近。(交叉熵公式和极大似然法公式一样)
交叉熵就是神经网络的概率模型与理想中的概率模型之间的差距的定量表达。
2.3梯度下降法 梯度下降法（gradient descent）是用来求“最小”代价函数的方法，通过该方法可以确定k,b的值，使模型保持局部最优解。
线性回归的代价函数是凸函数（convex），因此对于线性回归类问题我们可以采用梯度下降法得到全局最优解。
线性回归自变量为两个参数时的凸函数
tips（1）梯度下降法对于凸函数模型能够求出全局最优解；
（2）梯度下降法的学习率不能设置的过高，也不能设置的过低，对于非线性模型，梯度下降法找到的是局部最优解。
2.4（实战）梯度下降法实现一元线性回归 Numpy是python的开源数值计算拓展，可以用来处理和存储矩阵，支持大量的维度数组与矩阵运算，而Matplotlib是python的二维计算库。
将数据集文件data放在当前项目目录下，并通过numpy导入数据集，注意！！！数据集的格式，如果是utf-8编码，就要再导入数据集的语句后面加上encoding='utf-8'，同时数据集的Excel格式换成.CSV格式（因为.xsxl采用的是gbk编码）
设置学习率（手动随机设置），b和k从初始值等于0开始学习，迭代次数为50，目标是求computer_error（即损失函数）的最小值。
采用梯度下降法来更新参数，更新50次后，返回参数b和k。
上图为迭代0,、5、20、45次时，模型的拟合程度曲线，可以看出，随着迭代次数的增加，模型的效果越来越好，即损失函数不断变小。
2.5（实战）sklearn一元线性回归 sklearn是针对python语言的机器学习库，具有各种分类、回归和聚类算法，包括支持向量机、随机森林，梯度提升，k均值和DBSCAN。
np.newaxis是将数据集整合成需要sklearn需要处理的样子，model.fit将数据集带入了模型训练拟合回归。
2.6标准方程法 在求loss function的最小值时，不仅可以用梯度下降法，还可以用标准方程法（normal equation）。
通过求偏导即可求出J( )的最小值，下面给出一个例子：
其中特征X0是手动添加上去的，代表偏置值。整理后得到如下结果：
将loss function的函数形式转换为矩阵相乘形式，对矩阵求偏导需要观测该矩阵是分子布局还是分母布局，不同布局的求导方式不一样，下面网站给出了分子布局和分母布局的形式矩阵求偏导的公式：
化简到最后，出现了一个逆矩阵，一般来说，该矩阵可逆，若不可逆，相关计算软件也会通过计算“伪逆”的方法代替其逆，矩阵不可逆的可能原因如下：
综上，我们可以对比梯度下降法和标准分方程法的优缺点：
2.7（实战）标准方程法回归 （1）导入包
（2）载入数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4dfd7cbf5142395bdfefea387841eae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed3c55c13d5402c047950c1b4cf47dc/" rel="bookmark">
			OpenMVG与OpenMVS之OpenMVG编译运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、OpenMVG编译二、CMAKE编译三、运行测试四、总结 前言 主要介绍OpenMVG的编译，从https://github.com/openMVG/openMVG下载OpenMVG源码，也可以采用git来下载。
一、OpenMVG编译 1.1 安装git，https://git-scm.com/downloads，https://registry.npmmirror.com/binary.html?path=git-for-windows/，OpenMVG需要采用git命令行来更新三方库cereal。打开git cmd，进入到OpenMVG保存路径，执行如下命令。
git clone https://github.com/openMVG.git cd openMVG git submodule init git submodule update 1.2 OpenMVG依赖下载
https://github.com/openMVG/openMVG/tree/develop/src/dependencies，下载OpenMVG的三个依赖库，并解压到OpenMVG/src/dependencies目录下。
二、CMAKE编译 2.1 打开cmake-gui，设置源码目录为openMVG/src目录，并设置一个输出目录为openMVG_build以及安装目录，勾选OpenMVG_BUILD_EXAMPLES、OpenMVG_BUILD_TESTS即可编译。
2.2 点击Configure，直到没有红色条目，在点击Generate即可生成vs工程。
2.3 不同的VS版本，不同电脑编译的错误不同，在VS2015/x64的编译情况中，有些版本的OpenMVG编译并不能通过，本文章采用如下版本编译通过，CMakeLists.txt经过如下修改。
链接：https://pan.baidu.com/s/16AJJ8vNRpCIyF90s2Ap43A
提取码：z5mi
注释修改Eigen相关代码；注释掉 find_package(Ceres QUIET HINTS ${CERES_DIR_HINTS})注释掉if (DEFINED OpenMVG_USE_INTERNAL_JPEG)相关语句； 具体改动情况如下：
# ============================================================================== # Eigen # ============================================================================== # - external by default # - external if EIGEN_INCLUDE_DIR_HINTS is defined # - internal if Eigen not found # ============================================================================== #find_package(Eigen3 QUIET) #if (NOT Eigen3_FOUND) set(EIGEN_INCLUDE_DIR_HINTS ${CMAKE_CURRENT_SOURCE_DIR}/third_party/eigen) set(OpenMVG_USE_INTERNAL_EIGEN ON) find_package(Eigen QUIET) #else() # set(EIGEN_INCLUDE_DIRS ${EIGEN3_INCLUDE_DIR}) #endif() # ============================================================================== # Ceres # ============================================================================== # - external by default if CERES_DIR_HINTS or find_package found a valid Ceres # - internal if ceres not found (ceres-solver+cxsparse+miniglog) # ============================================================================== #find_package(Ceres QUIET HINTS ${CERES_DIR_HINTS}) if (NOT Ceres_FOUND) set(OpenMVG_USE_INTERNAL_CERES ON) set(CERES_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/third_party/ceres-solver/include ${CMAKE_CURRENT_SOURCE_DIR}/third_party/ceres-solver/internal/ceres/miniglog ${PROJECT_BINARY_DIR}/third_party/ceres-solver/config) FILE(READ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ed3c55c13d5402c047950c1b4cf47dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3084dd25c3c290dcf67f7591721596c2/" rel="bookmark">
			简单的AI（混合空间1D，AIMoveto，导航网格体）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		案例效果：
制作一个简单的可以随机移动的角色，使用简单的AIMoveto节点。默认状态下随机移动，按K会跟随玩家。并未使用到行为树、黑板等AI内容。
一、创建角色蓝图 导入骨骼网格体，摆放好位置和旋转朝向。
设置旋转，解决角色移动时旋转生硬的问题。
关闭对象“使用控制器旋转YAW”，打开移动组件中“使用控制器所需的旋转”
二、创建动画蓝图 这里通过混合空间1D做简单的移动，没做跳跃。
混合空间1D：僵尸的走比较慢，设置采样插值，实现idel和walk动作之间的过渡自然。
动画蓝图：
按以下配置好，将角色蓝图的骨骼装配上动画蓝图
三、角色蓝图逻辑 使用AIMoveto节点，该节点可以移动到位置或者对象，移动到对象的优先级更高。
这里要把 stop on overlap打勾，防止重叠。
角色蓝图中移动组件下的：最大行走速度要设置低点，避免移动出现明显漂移。
四、摆放导航网格体 五、设置跟随对象 新建target actor对象，并通过角色蓝图将其赋值。target actor的优先级更高，在其值存在时，僵尸会优先跟随对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859c1b69d172d2ba1c1a5ec042700c7f/" rel="bookmark">
			初学Java时常见的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java程序编译过程中遇到的问题 一、错误之缺少结尾符号“}”———解析时已到达文件结尾 一般是程序已经运行完了，还没有结尾，检查类中是否缺少结尾符号“}”或“；”
以上代码块中结尾处缺少一个“}”
在结尾处加上“}”
运行结果
二、错误之没有导入java.util包下的Scanner类——无法访问Scanner 原因：没有导入java.util包下的Scanner类，导入后才可以使用。
在public class Homeworka1上方写上：import java.util.Scanner;
运行结果：
三、编码错误——找不到符号 java中new的一个用法：输入数据要用new–实例化对象，创建内存，示例：Scanner reader=new Scanner (System.in);
Scanner是一个类，reader为创建的一个Scanner的对象，new就创建了这个实例，为其分配变量。
所以应将第990行改为:StringBuffer sb=new StringBuffer();
更改之后运行结果如下：
四、编码错误——非法的表达式开始 观察发现，第720行中两个等号之间多了一个空格，删去空格之后运行结果
两个连续的等号是等于运算符，不要写错了哦
五、编码错误——缺少方法主体或声明抽象 public static void main(String[ ]args);{句中的分号是不能要的，去掉即可。
运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/107d438c813719a0edf7f27b344ac0ae/" rel="bookmark">
			vlan中access和trunk的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 access的配置trunk的配置 access的配置 如图所示，PC 1、PC 2、PC 3、PC 4都在同一个网段中，现在想要通过一个交换机设置vlan将PC 1和PC 2分配在一个网段，PC 3和PC 4在一个网段，使得PC 1可以ping通PC 2但不能ping通PC 3、PC 4。 先给交换机划分成vlan 10 和vlan 20 两个端口
将e0/0/1和0/0/2分在vlan 10 中，e0/0/3和e0/0/4分在vlan 20中 ，因为是一个交换机，所以只需要用access。
实现PC 1可以ping通PC 2但不能ping通PC 3、PC 4。
trunk的配置 如图所示，图中有两个交换机，那么两个交换机之间需要用trunk来配置。
正常配置SW 1 和PC 1、PC 2
配置SW 2 和PC 3、PC 4
然后，进行交换机与交换机之间的配置（trunk）
进入SW 1进行配置
SW 2通上
配置完成，测试一下能不能ping通
如图所示，PC 1可以和PC 2 ping通，但不能和PC 3 ping 通。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d33fd1989bcbe27696303ef6ef12a29d/" rel="bookmark">
			Git 命令基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git git 命令的一些及基本操作
一、初始化配置 git --version git config --global user.name "Your Name" git config --global user.email "email@example.com" git config --list 查看当前配置信息 git status //查看状态 二、本地项目push 远程项目（空的仓库） echo "# home.geelevel.com-web" &gt;&gt; README.md echo "# airbnb" &gt;&gt; README.md git init //创建git git add . //添加文件到暂存区 git commit -m "first commit" //将暂存区内容添加到仓库中 git branch -M main //创建分支 git remote add origin (地址) //提交到远程仓库地址 git push -u origin main //提交上传到仓库 三、分支操作 //查看分支 git branch //创建分支 git branch name //切换分支 git checkout name //创建&amp;切换分支 git checkout -b name //将本地分支push到远程 git push --set-upstream origin zhuotest //合并某分支到当前分支 git merge name //查看远程分支 git branch -r //切换到远程分支 git checkout -b filetransfer origin/filetransfer //删除分支 git branch -d name //删除远程仓库分支 git push 地址 --delete name //查看文件的所有历史记录 git log -p video_window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d33fd1989bcbe27696303ef6ef12a29d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5164df45cd689a556f8439b612fe968e/" rel="bookmark">
			ubuntu扩容根目录磁盘容量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在VMware上编辑虚拟机设置，然后选择 硬盘（SCSI）-&gt; 扩展
一开始弹出的磁盘大小24Gb提示是我当前磁盘大小，我们在这个基础上扩容磁盘容量
修改目标扩容数字大小，要比原始大小数值24Gb要大
我将目标大小设置为60Gb
确认后提示扩展成功，但是需要登录到虚拟机里面进行分区和扩展；
登录ubuntu后检查看到当前的根目录空间仍然是24Gb，没变化.
而且目前根目录对应的磁盘设备分区是 /dev/sda5。
lsblk查看磁盘/dev/sda 显示共有3个分区，sda1, sda2, sda5
fdisk -l
结果显示当前/dev/sda 这个磁盘设备容量已经是60Gb了，不过它下面的3个分区
sda1,sda2,sda5 大小还是旧的：
接下来我们需要重新建立分区，并在重新建立分区的过程中，扩大分区的磁盘容量。
这里需要注意的是分区的时候我们建立主分区，扩展分区，和逻辑分区三种不同分区的时候，需要清楚他们之间的关系，其中：
磁盘总大小=主分区+扩展分区
扩展分区大小=逻辑分区1+逻辑分区2+逻辑分区3…
也就是说大类只区分两个，主分区和扩展分区，而逻辑分区又是被扩展分区在外层控制的，各个逻辑分区总和大小无法超过或者说大于扩展分区容量大小；
那么，我们从24Gb-&gt;60Gb扩容的时候有几点要注意：
1.保持主分区sda1 大小不变；2.扩展分区sda2大小覆盖到剩余的整个60Gb;3.只有在2基础上，逻辑分区sda5才能充分利用扩容的空间，从而实现根目录空间扩容； 方案有了，那么开始操作了：
fdisk /dev/sda
p (检查一下当前的分区）
d (删除分区sda5）
d (删除分区sda2)
p (查看一下当前分区）
可以看到，sda2 和sda5 分区信息已经没有了，然后新建分区：
n (重建扩展分区sda2)
e (注意这里要重建的是扩展分区，选项是e）
分区号数字：直接回车，使用默认值
第一个扇区：直接回车
Last sector：直接回车
n （重建逻辑分区sda5）
起始sector：使用默认sector数值，直接回车
Last sector : 直接回车
N (保持旧的ext4签名）
p (检查分区）
在确认Last sector的值的时候，默认会覆盖到所有的扩容空间，我们保持默认直接回车即可.
w (保存）
对于提示的告警
Failed to add partition 2 to system: 设备或资源忙
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5164df45cd689a556f8439b612fe968e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad27c232ae8f87ef174c52c3f59374a8/" rel="bookmark">
			离大谱，直接让chatG开发微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家好，最近chatgpt不是比较火嘛，小浅浅我也打算来凑凑热闹，通过一番魔法操作后，终于是搞定了账号环境这些东西，上手体验了一下之后发现确实不错，可以直接提需求给他，然后帮你出思路和写代码。我心想真不错呀，然后为了让没法魔法的小伙伴们也能体验一下这个东西的强大之处，所以打算写一个小工具，让大家也试试。于是就想到了微信的小程序。 好的，前言就交代到这了，接下来就是惊讶的事了，由于小浅浅我就是后端出身嘛，所以后端的接口三下五除二的就写完了。 然后开始写前端了，因为以前只接触过一点微信小程序的开发，所以就突发奇想，让chatGPT帮我写一个前端界面吧。以下的对话都是出自我和chatgpt的交流 首先只要跟他说出你想要什么，他就会提供一个开发思路
可以直接提供代码，并给出逻辑说明
不止可以写界面，还可以写js
最夸张的是你还可以提供更多的说明，让它按照你的思路改代码
以下就是我根据它给我出的代码实现的基于chatgpt-3实现的对话小程序
大家可以微信搜索“智能原始人”小程序来试试这个到底智能不🤣 好了说这么多我想表达的是啥呢？那就是这个界面丑跟我一点关系都没有，都是chatgpt写的🐶，如果想要后端代码的也可以私信我，我提供出来 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30074b3d668fb31c0822e6be8ce8ee0f/" rel="bookmark">
			最详细蓝桥杯嵌入式教程（四）：按键长按
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习完按键单击之后，我们来学习一下使用按键长按来实现控制。
首先先在h文件里面定义我们需要的变量。
然后，在c文件里面进行修改。
最后，就可以实现长按键控制了。
是不是非常简单，在此基础上我们还可以实现按键双击等效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2cd1ad046ff470976eee23281c91317/" rel="bookmark">
			谷歌浏览器书签还原—有vhdx备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		谷歌浏览器书签还原—有vhdx备份 前言还原最后 前言 旧版谷歌浏览器无法在线更新，下载最新的版本重装，书签全没了，恶心坏了。还好有备份系统，从备份中还原单个文件很快就解决了。
还原 ① 搜 bookmarks
用 Everything 搜索 bookmarks ，发现全部被覆盖了，包含bak版也覆盖了，用文件找回工具也没找到。
② 查找 vhdx
突然想起有用 备份与还原工具 备份过系统。
把隐藏的备份镜像显示出来
③ 装载 vhdx
有一个 vhdx 文件，双击装载。
打开计算机管理-存储-磁盘管理-分配盘符即可浏览文件夹，重复 ① 即可找回 bookmarks
最后 还好有备份系统，否则就麻烦了，定期备份系统可以免去很多麻烦。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/164/">«</a>
	<span class="pagination__item pagination__item--current">165/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/166/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>