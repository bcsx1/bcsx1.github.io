<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cb9b428dce0983063fff28ffa9b2f3e/" rel="bookmark">
			vue中使用excelJs导出excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		excelJs exceljJs文档：https://github.com/exceljs/exceljs/blob/master/README_zh.md
创建工作表 导入依赖
import ExcelJS from "exceljs"; import saveAs from "file-saver"; const workbook = new ExcelJS.Workbook(); // 添加工作表，可以添加多个工作表 const worksheet = workbook.addWorksheet("第一个工作表"); const worksheet2 = workbook.addWorksheet("第二个工作表"); 导出excel workbook.xlsx.writeBuffer().then((buffer) =&gt; { saveAs( new Blob([buffer], { type: "application/octet-stream" }), "第一个excel.xlsx" ); }); 操作工作表（常用的方法） 使用坐标转化为对应的单元格位置可查看
坐标转数组
1. 在单元格添加数据 worksheet.getCell("A1").value = "我是A1"; 2. 设置行高和列宽 // 设置行高 worksheet.getRow(1).height = 20; // 设置列宽 worksheet.getColumn(1).width = 20; 3.插入行 // 插入行 worksheet.insertRow(1, ["我是插入行"]); 4.合并单元格 // 合并单元格 worksheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cb9b428dce0983063fff28ffa9b2f3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34b73f275a25e34b0d7b63b18f271b78/" rel="bookmark">
			ADPCM(自适应差分脉冲编码调制)的原理和计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCM 是声音模拟信号数字化的一种基础技术, 就是把时间连续取值连续的模拟信号变换成离散取值的数字信号, 熟悉ADC(模拟数字转换)的应该很好理解, 过程就是采样, 量化和编码.
1. 采样 用固定的频率, 对模拟信号提取样本值, 人耳能够感觉到的最高频率为20kHz, 根据奈奎斯特采样定律, Nyquist rate, 只需要每秒进行40k次采样, 就能覆盖人耳的听觉范围, 也就是说采样高于40k每秒对于普通人来说, 听觉基本上没有提升了.
In signal processing, the Nyquist rate, named after Harry Nyquist, is a value (in units of samples per second or hertz, Hz) equal to twice the highest frequency (bandwidth) of a given function or signal. When the function is digitized at a higher sample rate (see § Critical frequency), the resulting discrete-time sequence is said to be free of the distortion known as aliasing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34b73f275a25e34b0d7b63b18f271b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff71ee31e49f8614dceb7a21f442a703/" rel="bookmark">
			【Java 设计模式】创建者模式 之工厂方法模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工厂方法模式 §1 角色§2 点咖啡案例§2.1 类图§2.2 实现 §3 优点§4 缺点 §1 角色 抽象产品：定义产品的规范，描述产品的特性和功能，如：咖啡。具体产品：实现或继承抽象产品的子类，如：美式咖啡，拿铁咖啡。抽象工厂：创建产品的接口，产品使用者通过它访问具体工厂的方法来获取产品，如：咖啡工厂。具体工厂：实现抽象工厂中的方法，创建具体产品，如：美式咖啡工厂制作美式咖啡，拿铁咖啡工厂制作拿铁咖啡。 §2 点咖啡案例 工厂方法模式将美式咖啡（具体产品）的创建工作延迟到美式咖啡工厂（具体工厂）进行，咖啡工厂（抽象工厂）会定义创建咖啡的方法，具体工厂来实现该方法。 §2.1 类图 §2.2 实现 // 抽象产品: 咖啡类 public abstract class Coffee { public abstract String getName(); public void addMilk() { System.out.println("咖啡加奶"); } public void addSugar() { System.out.println("咖啡加糖"); } } // 具体产品: 美式咖啡 public class AmericanCoffee extends Coffee { @Override public String getName() { return "美式咖啡"; } } // 具体产品: 拿铁咖啡 public class LatteCoffee extends Coffee { @Override public String getName() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff71ee31e49f8614dceb7a21f442a703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8317e43c147705e5f26d27f06a28946a/" rel="bookmark">
			模式匹配——枚举法的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 你有两个字符串，即pattern字符串和value字符串。 pattern字符串由字母"a"和"b"组成，用于描述字符串中的模式。例如，字符串"catcatgocatgo"匹配模式"aabab"（其中"cat"是"a"，"go"是"b"），该字符串也匹配像"a"、"ab"和"b"这样的模式。但需注意"a"和"b"不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。
二、解析 我们设 pattern 的长度为 ℓp​，value 的长度为ℓv​。根据题目描述，我们需要给字母 a和 b 分配不同的字符串值，使得将 pattern 中的字母替换成对应的字符串后，结果与 value 相同。
在分配字符串之前，可以先分配 a 和 b 对应字符串的长度。一旦确定了长度，那么我们只要将字符串value 按照 pattern中出现字母的顺序，划分成多个子串，并判断其中 a 对应的子串，以及 b 对应的子串是否相同即可。
具体地，假设 pattern中出现了 Ca​ 个 a 以及( ℓp—Ca)个 b，并且 a和 b 对应字符串的长度分别为 ℓa​ 和 ℓb​，那么必须要满足：
我们可以直接枚举 ℓa​ 的值.在遍历完成之后，如果匹配没有失败，我们还需要判断一下 a 和 b 是否对应了不同的子串。只有它们对应的子串不同时，才是一种满足题目要求的模式匹配。
细节，我们分析下面的方程式：
如果我们枚举 ℓa​，那么必须要求 Ca≠0，因为在 Ca=0 的情况下，原方程如果有解，那么一定有无数解（因为 ℓa​ 可以取任意值）。因此如果 Ca = 0，我们就必须枚举 ℓb​。这无疑增加了编码的复杂度，因为需要根据Ca的值选择对 ℓa或 ℓb 进行枚举，失去了统一性。并且，如果 ℓp−Ca也为 0，那么我们连 ℓb​ 都无法枚举。
总结一下，我们梳理一下判断的逻辑：
如果 pattern 为空，那么只有在 value 也为空时，它们才能匹配；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8317e43c147705e5f26d27f06a28946a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b56c5c3254e18e7e8b424cc58d7b481d/" rel="bookmark">
			win10家庭版安装Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先查看你的电脑里面是否是win10且没有Hyper-V，是的话，那这个教程就是给你的啦~
1、安装Hyper-v 首先将下面的内容复制到新建的txt中，将txt更名为Hyper-V.cmd,右键管理员运行这个文件
pushd "%~dp0" dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt for /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i" del hyper-v.txt Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL 最后等待一段时间，在命令行中输入Y，程序会帮你重启电脑，注意别关机。
重启完毕，打开控制面板控-&gt;程序-&gt;程序和功能,点击“启用和关闭Windows功能”，弹出窗口，可看到Hyper-V已添加，如图：
另外也可以以管理员身份运行cmd，输入systeminfo，若显示截图标红字段，表示Hyper-v已启用，如图：
这部分要是觉得写得不清楚可以看这个【传送门】
2、安装Docker 首先下载docker-installer:
国外下载地址国内下载地址
下载后直接运行即可，没有什么设置~
顺利的话可以直接打开docker食用了，不顺利的话，比如遇到如下报错：
需要下载更新包，下载完后双击运行即可。
如果还有bug可以参考这篇
没有的话，应该双击完docker图标就可以正常开启了，也可以选择用·docker version命令行验证如下：
成功安装UI如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/378b70a870d199a167bed6397235ff7b/" rel="bookmark">
			WebRTC 服务器搭建篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		First off All 服务器环境：采用的阿里云国内服务器，系统： Ubuntu 16.04 64位 。
各个服务所需要的编译环境图：
各个服务器对应所需编译平台
1.第一步，先更新下命令行工具，工欲善其身必先利其器，不更新回头出现莫名的错误me 不管。
apt-get update
2.第二步：我们先从房间服务器搭建开始入手，看上面的图，就知道，这个家伙是要用时node.js编译的，那必须安装各种node.js编译相关的插件
按如下步骤：
先安装两个工具库
sudo apt-get install git unzip golang
sudo apt-get install automake autoconf libtool
备注：不要用这种方法安装（apt-get nodejs 如果这么装会报各种版本不兼容）
使用这种方式下载官网 如：
wget https://nodejs.org/dist/v4.7.0/node-v4.7.0-linux-x64.tar.gz
并解压下
tar -xzf node-v4.7.0-linux-x64.tar.gz
要安装node js linux的环境就是方便 只需要配置下环境变量即可，方式如下
vim /etc/profile
里面加入
export PATH=/usr/webrtc/node-v4.7.0-linux-x64/bin:$PATH（备注这个地址是我自己的解压的地址，找到自己的node加压的bin目录设置进环境变量即可）
配置还环境变量以后，需要生效下，执行如下命令
source /etc/profile
下面我们可以测试下node js 环境是否正常了 命令行输入node 进入了就说明node js 安装成功了
下面还需要安装下npn（编译工具）（不用sudo安装npm）
npm -g install grunt-cli
安装python
sudo apt-get install python-webtest
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/378b70a870d199a167bed6397235ff7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815f3ebad60b208517969a8321eebb48/" rel="bookmark">
			php使用redis限制一个手机号短信发送次数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * 限制发送短信 */ public function limitSend($text, $redisKey, $redisKeyLimit) { if ($this-&gt;redis()-&gt;exists($redisKey) &amp;&amp; $this-&gt;redis()-&gt;exists($redisKeyLimit)) { //获取还剩多少时间 $redisValue = $this-&gt;redis()-&gt;get($redisKey); //获取发送次数 $limit = $this-&gt;redis()-&gt;get($redisKeyLimit); //还有时间&amp;发送次数小于10 if (!empty($redisValue) &amp;&amp; $limit &lt; 10) { //获取剩余有效时间 $limitTTl = $this-&gt;redis()-&gt;ttl($redisKeyLimit); //再设置，发送次数加1 $this-&gt;redis()-&gt;setex($redisKeyLimit, $limitTTl, $limit + 1); return $redisValue; } else { return false; } } else { // 5分钟超时 $this-&gt;redis()-&gt;setex($redisKey, 300, $text); $this-&gt;redis()-&gt;setex($redisKeyLimit, 300, 1); return $text; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/167b0f388038b0eb510b98311acc8495/" rel="bookmark">
			ArcGIS Pro发布影像切片的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在线法 传统方式，share as web layer方式即可发布切片服务。
离线法 大多数用户习惯于使用ArcMap在客户端生成切片，然后再发布的过程。此方法很占时间。今天介绍一种tpk（tile package）离线包发布切片的方式。此方式通过将tpk上传至portal后，可以在服务器端自动进行切片生成。省时省力。此为示例影像数据。坐标系4490。
生成切片缓存方案 本影像是4490坐标系，可以选择Pro自带的4490切片方案，也可以自定义生成切片缓存方案。这里采用自定义4490切片方案的形式。
管理切片缓存 选择输出缓存的位置和名称，输入数据源，以及切片方案。
生成完毕后会在指定目录下输出各级的切片方案。
输出切片缓存 输出缓存选择tpk即可。
输出完成。
验证 将tpk直接上传至portal中，查看切片服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0927226d9f83584e381a64c593bbbf4/" rel="bookmark">
			驱动——gpio子系统（LED灯的操控实验）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用GPIO子系统操控6盏LED灯的亮灭 1、编写设备树节点：
添加如下所示代码到stm32mp157a-fdmp1a.dts中根节点里面，给LED灯定义名字，并引用GPIO寄存器及相对应的引脚信息；
myleds{ myled1 = &lt;&amp;gpioe 10 0&gt;; myled2 = &lt;&amp;gpiof 10 0&gt;; myled3 = &lt;&amp;gpioe 8 0&gt;; myled4 = &lt;&amp;gpioz 5 0&gt;; myled5 = &lt;&amp;gpioz 6 0&gt;; myled6 = &lt;&amp;gpioz 7 0&gt;; }; 2、实现字符设备驱动并创建与LED灯相应的6个设备节点（具体详情见驱动——串口点灯实验内容）
3、获取设备树节点信息(获取方式不唯一，本次采用通过节点名字获取）
struct device_node *of_find_node_by_path(const char *path)
功能：获取设备树节点信息通过路径
参数: path：节点路径
返回值：成功返回目标节点的信息结构体地址，失败返回NULL
struct device_node *of_find_node_by_name(struct device_node *from, const char *name)
功能：通过节点名字获取节点信息
参数：from:已知设备树节点的首地址 （填NULL，默认从根节点解析）
name:设备树节点的名字 "myleds"
返回值：成功返回目标节点的信息结构体地址，失败返回NULL
4、根据GPIO子系统函数API对LED灯进行操作（子系统函数有新旧两个版本，本次采用新版本）
①在在设备树节点信息结构体中获取并申请要使用的gpio编号
旧版本：
int of_get_named_gpio(struct device_node *np, const char *propname, int index)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0927226d9f83584e381a64c593bbbf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a5e7ff3045584dee2d6d89b4ade50d/" rel="bookmark">
			c语言中的数学问题（含鸡兔同笼，乘法表，）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.鸡兔同笼问题 2.乘法表
1.鸡兔同笼同笼问题是熟知的问题了话不多说直接上例子
共有98只脚，386个头，问鸡与兔分别多少？ #include&lt;stdio.h&gt; int main() { int x; int y; for(x=1;x&lt;=98;x++) { for(y=1;y&lt;=98;y++) { if(2*x+4*y==386||x+y==98) { printf("鸡的数量为%d,兔的数量为%d\n",x,y); } } } } 这里用循环嵌套轻松解决问题，
2.乘法口诀表
#include&lt;stdio.h&gt; int main() { int sum; int i, j; for (i = 0; i &lt; 10; i++) { for (j = 0; j &lt; 10; j++) { if (j &lt;= i) { sum = i * j; printf("%d*%d=%d\t", i, j, sum); } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15a5e7ff3045584dee2d6d89b4ade50d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b46b8c5d9223fa1b4ffccdd968d61a/" rel="bookmark">
			Windows下PostgreSQL编译调试笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译前的准备 本笔记适用于个人开发者在单机单节点下PostgreSQL 13软件的安装与调试。
下载并配置编译环境 MSYS2是一个集成了MinGW、Cygwin等编译引擎的软件，同时集成了Shell命令以及编译环境配置等功能，专门用于在Windows平台下编译各类C/C++软件。
官方网站：https://www.msys2.org/
下载安装MSYS2，成功后打开MSYS2 MinGW x64，执行以下命令来安装gcc和gdb工具：
pacman -Syu pacman --needed -S mingw-w64-x86_64-gcc base-devel pacman --needed -S mingw-w64-x86_64-gdb 遇到选择时全都输入“y”即可。
下载并解压PostgreSQL源码 可通过PostgreSQL的官网下载。注意选择PostgreSQL 13版本（13.0到13.9均可，本人使用的是13.9版本）
官网地址：https://www.postgresql.org/ftp/source/
编译与安装 生成makefile文件 MSYS2 MinGW x64下的命令与Shell一致，C盘根目录对应的地址为“/c/”。
打开MSYS2 MinGW x64，进入PostgreSQL源码目录后执行以下命令：
./configure --host=x86_64-w64-mingw32 --prefix=/c/pg/installer/ -enable-debug 其中，–perfix指定了编译完成后的安装包生成的位置（以下简称为安装目录），如上述命令，本人的安装目录为C盘下pg下的installer目录。
编译完成后进入源码目录，修改src目录下的Makefile.global文件，找到以“CFLAGS = -Wall”以及“CXXFLAGS = -Wall”开头的两行，将这两行命令中的“-O2”参数去掉。（注意：以上Makefile.global的修改仅适用于PostgreSQL 13的源码）
编译并安装PostgreSQL 打开MSYS2 MinGW x64，进入PostgreSQL源码目录后执行以下命令：
make make install 初始化数据库 在Windows下的cmd命令行中进入安装目录下的bin中，执行：
initdb -D C:\pg\data 该命令创建了一个单机单节点的数据库服务器。其中“-D”参数指定了PostgreSQL数据库的配置文件位置。本人的为C盘下pg下的data目录。同一台机器中可能有多个配置文件，PostgreSQL服务器通过各自的配置文件进行区分。
如果不想每次都要进入安装目录下的bin中执行命令，可将该目录加入系统环境变量。
数据库注册（该步骤可跳过） 将数据库服务注册为Windows的系统服务，方便以后启停数据库服务。以下命令需要在有管理员权限的cmd中使用。
pg_ctl register -N pg -D "C:\pg\data" -w -S demand 参数解释如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1b46b8c5d9223fa1b4ffccdd968d61a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f6c163531b6f9164757bbf6628848c/" rel="bookmark">
			洛谷P5724 【深基4.习5】求极差 / 最大跨度值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【深基4.习5】求极差 / 最大跨度值 题目描述 给出 n n n 和 n n n 个整数 a i a_i ai​，求这 n n n 个整数中的极差是什么。极差的意思是一组数中的最大值减去最小值的差。
输入格式 第一行输入一个正整数 n n n，表示整数个数。
第二行输入 n n n 个整数 a 1 , a 2 … a n a_1,a_2 \dots a_n a1​,a2​…an​，以空格隔开。
输出格式 输出一个整数，表示这 n n n 个整数的极差。
样例 #1 样例输入 #1 6 1 1 4 5 1 4 样例输出 #1 4 提示 数据保证， 1 ≤ n ≤ 100 1 \leq n\leq 100 1≤n≤100， 0 ≤ a i ≤ 1000 0\le a_i \le 1000 0≤ai​≤1000。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6f6c163531b6f9164757bbf6628848c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c990f7bdc0c5f5cb18a8f8c3c9f696/" rel="bookmark">
			教你STM32做USB鼠标、键盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用CubeMX软件傻瓜式的配置，一键生成USB的HID驱动。
一、USB鼠标 1、CubeMX配置 ①、选择相对应的芯片 ②、配置时钟和Debug和debug ③、配置USB ④、生成代码 最好把这个也勾上，勾上以后每个外设配置不再都给你塞到main.c里，而是建一个.c.h,这样感觉舒服多了
2、编写应用层代码 USB协议还是挺复杂的，原理和底层我也搞不清楚，这东西也不是看几篇文章学个一两天就能搞明白的，我写这个也主要是为了好玩，没有深层去理解。
我们用的鼠标主要就四个属性：键位（左键、右键、中键），左右移动、上下移动、滑轮
这四个属性用一个长度为4的数组一并包含进来：
/* *MouseData[0]:低0位：左键 低1位：右键 低2位：中键 *MouseData[1]:1~127：右 --127~-1：左 *MouseData[2]:1~127：下 --127~-1：上 *MouseData[3]:1~127：上 --127~-1：下 （滑轮） */ char MouseData[4] = {0, 0, 0, 0}; 发送这些信息用这个函数：
USBD_HID_SendReport(&amp;hUsbDeviceFS,(uint8_t*)&amp;MouseData,sizeof(MouseData)); 主要代码：
memcpy(MouseDataT, MouseData, sizeof(MouseData)); key = KEY_Scan(1); //支持连续按下 switch(key) { case KEY0_PRES: MouseData[0] |= 0x01; break; case KEY1_PRES: MouseData[1] = 21; break; case WKUP_PRES: MouseData[3] = -12; break; default: MouseData[0] = 0; MouseData[1] = 0; MouseData[2] = 0; MouseData[3] = 0; } //如果有变化，发送 if(MouseData[0]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12c990f7bdc0c5f5cb18a8f8c3c9f696/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c40437f4ae18be2fd1fd9f4718750b5d/" rel="bookmark">
			vue项目中主要文件的加载顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue项目中主要文件的加载顺序
先后顺序：
index.html &gt; App.vue的export外的js代码 &gt; main.js &gt; App.vue的export里面的js代码 &gt; Index.vue的export外的js代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bccce551611917539247f338c2ff5084/" rel="bookmark">
			【Vue】安装打包vue-admin-template并解决报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装
1、 准备工作——查看node、npm、git、淘宝镜像、vscode是否安装完毕
2、安装——选择简洁模板
3、简单介绍相关文件并做相应处理
4、连接后端
5、代码管理
二、打包
三、安装报错 一、安装 1、 准备工作——查看node、npm、git、淘宝镜像、vscode是否安装完毕 查看node 和 npm的版本
$ node -v $ npm -v 查看git安装版本
$ git --version 设置淘宝镜像
$ npm config set registry https://registry.npm.taobao.org/ #设置淘宝镜像地址 $ npm config get registry #查看镜像地址 vscode编辑器以及插件，插件选择自己所需要的进行下载
vetur是基于单文件组件开发的支持插件；eslint是 基于代码校验的插件工具
//除此之外, eslint需要在vscode中进行一些参数的配置 { "eslint.enable": true, "eslint.run": "onType", "eslint.options": { "extensions": [ ".js", ".vue", ".jsx", ".tsx" ] }, "editor.codeActionsOnSave": { "source.fixAll.eslint": true } } 2、安装——选择简洁模板 git拉取基础项目模板
#拉取基础模板到hrsaas目录 $ git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bccce551611917539247f338c2ff5084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86329da9c6f3a5b615e0842fa8dbee90/" rel="bookmark">
			【嵌入式】教你如何在Linux设备上截图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、说明 在开发中的嵌入式产品，多为Linux系统的，采用的全志方案，图像一般从/dev/fb0或者/dev/disp送到显示终端的，如果直接cat这个设备，是可以将原始数据直接导出来的，但由于它只是一组数据，所以需要使用ffmpeg处理一下，就可以得到所需要的图片了。
例如：在R818 上经过了/dev/fb0送显，就可以使用以下命令先得到一个图像的原始数据：
adb shell "cat /dev/fb0 &gt; /tmp/a.raw" adb pull /tmp/a.raw ~/tmp/ 然后使用ffmepg命令转换成bmp图片，使用时需要注意， 268x800 为具体送显的尺寸大小(分辨率)，各个设备不一定一样，需要自行修改：
ffmpeg -vcodec rawvideo -f rawvideo -pix_fmt rgb32 -s 268x800 -i ~/tmp/a.raw -vf "transpose=1" -f image2 -vcodec bmp ~/tmp/a%d.bmp 附录 A、/dev/disp查看分辨率 cat /sys/class/disp/disp/attr/xres cat /sys/class/disp/disp/attr/yres 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f866347b387c32f0480d261d31cc9f/" rel="bookmark">
			云服务器ECS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云服务器ECS是阿里云提供的性能卓越、稳定可靠、弹性扩展的IaaS级别云计算服务。云服务器ECS免去了您采购IT硬件的前期准备，让您像使用水、电、天然气等公共资源一样便捷、高效地使用服务器，实现计算资源的即开即用和弹性伸缩。阿里云ECS持续提供创新型服务器，解决多种业务需求，助力您的业务发展。
同时，那么为什么要选择云服务器ECS呢，可以看看以下几点的优势
无需自建机房，无需采购以及配置硬件设施。分钟级交付，快速部署，缩短应用上线周期。快速接入部署在全球范围内的数据中心和边界网关协议BGP（Border Gateway Protocol）机房。成本透明，按需使用，支持根据业务波动随时扩展和释放资源。提供GPU和FPGA等异构计算服务器、弹性裸金属服务器以及通用的x86架构服务器。支持通过内网访问其他阿里云服务，形成丰富的行业解决方案，降低公网流量成本。提供虚拟防火墙、角色权限控制、内网隔离、防病毒攻击及流量监控等多重安全方案。提供性能监控框架和主动运维体系。提供行业通用标准API，提高易用性和适用性。 那么最后有什么疑问可以联系小编哈~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41eefacc7febb6828a6babed72c9bc6a/" rel="bookmark">
			crictl使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		crictl 是 CRI 兼容的容器运行时命令行接口。
crictl 是 CRI 兼容的容器运行时命令行接口。 你可以使用它来检查和调试 Kubernetes 节点上的容器运行时和应用程序。 crictl 和它的源代码在 cri-tools 代码库，本文将总结 crtctl 工具的使用方法。
安装 crictl
你可以从 cri-tools 发布页面 下载一个压缩的 crictl 归档文件，用于几种不同的架构。 下载与你的 kubernetes 版本相对应的版本。 提取它并将其移动到系统路径上的某个位置，例如/usr/local/bin/。
一般用法
crictl 命令有几个子命令和运行时参数。 有关详细信息，请使用 crictl help 或 crictl &lt;subcommand&gt; help 获取帮助信息。
crictl 默认连接到 unix:///var/run/dockershim.sock。 对于其他的运行时，你可以用多种不同的方法设置端点：
通过设置参数 --runtime-endpoint 和 --image-endpoint通过设置环境变量 CONTAINER_RUNTIME_ENDPOINT 和 IMAGE_SERVICE_ENDPOINT通过在配置文件中设置端点 --config=/etc/crictl.yaml 你还可以在连接到服务器并启用或禁用调试时指定超时值，方法是在配置文件中指定 timeout 或 debug 值，或者使用 --timeout 和 --debug 命令行参数。
要查看或编辑当前配置，请查看或编辑 /etc/crictl.yaml 的内容。
$ cat /etc/crictl.yaml runtime-endpoint: unix:///var/run/dockershim.sock image-endpoint: unix:///var/run/dockershim.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41eefacc7febb6828a6babed72c9bc6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05307f1b50c2906c14f9a5690dca0b47/" rel="bookmark">
			c语言选择法排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、选择排序法是什么？二、编程思路 1.讲解2.例子总结 前言 c语言中有很多排序方式，常见的有冒泡排序，选择排序，简单插入排序，希尔排序，快速排序等等，今天简单说一下选择排序吧～
一、选择排序是什么？ 选择排序就是通过反复地求最大值的方式实现排序的
二、编程思路 1.讲解 （1）首先将5个数存入一堆数组中；
（2）然后找出5个数中的最大数，放入a【0】中；
（3）再找出5个数中的第二大数，放入a【1】中；
（4）顺序以此类推，然后找出5个数中最小的，置于a【4】中，从而完成降序排序；
2.例子 代码如下（示例）：
先引用一段网上的动画清楚的展示：
#include&lt;stdio.h&gt; int main() { int arr[10]={1,3,6,5,2,4,8,9,7,0}; for(int i=0;i&lt;9;i++) { for(int j=i+1;j&lt;10;j++) { if(arr[i]&gt;arr[j]) { int t=arr[i]; arr[i]=arr[j]; arr[j]=t; } } } for(int i=0;i&lt;10;i++){ printf("%d\n",arr[i]); } } 方法和冒泡排序大体相同，还是外层for语句判断循环次数，内层比较两数比较
结果为0123456789
总结 选择排序和冒泡排序大体相似，原理都是循环嵌套，只是换了一个循环条件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30d8ecefed26a485c33ffe9c92bcdde/" rel="bookmark">
			【电路设计】AD快速敷铜技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
推荐一款 求职面试、刷题学习 的神器：👉点击跳转 ，快来看看吧！
​
参考帖子：http://bbs.eeworld.com.cn/forum.php?mod=viewthread&amp;tid=465056
建立一个工程，添加原理图和PCB文档，原理图上简单放置一个元器件，接上VCC和GND信号：
导入到PCB文档中去：
然后按照正常的方法进行辅铜，铜皮Net选择GND，不选择Remove Dead Copper（删除死铜）：
然后在整个板子的外围的一个正方形区域进行辅铜，效果如下：
不要太难看！！！
下面我们在辅铜选项上将Remove Dead Copper选项选上：
然后同样在整个板子的外围的一个正方形区域进行辅铜，效果如下：
这就可以了。解释一下Remove Dead Copper就是将没有连接上信号的铜皮区域（死铜）删除，所以电路板外围的那些铜皮就被删除了，只留下电路板内部的有效的铜皮。使用这种方法辅铜我们不用在板子上的每个角上连线画区域辅铜，这样很慢很慢，而且如果是圆形的板子我们还真没法辅铜。现在我们只要在电路板结构外围一片大一些的区域辅铜就行，不要太方便。
然后如果我们电路板上有某一块区域不想辅铜，可以在不想辅铜的区域在Keep Out Layer上绘制一块封闭的图形然后再进行辅铜，原理很简单，这块封闭区域中的铜皮成为了死铜被去掉了，所以实现了这个功能。
辅铜后的效果为：
nice！！！
推荐一款 求职面试、刷题学习 的神器：👉点击跳转 ，快来看看吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282231215971e0e4d348741f947dbda4/" rel="bookmark">
			Apollo 应用与源码分析：CyberRT-工具与命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 cyberRT包括一个可视化工具cyber_visualizer和两个命令行工具cyber_monitor和cyber_recorder。
注意：使用这些工具需要apollo docker环境
并且Cyber RT 中提供了一些命令工具，可以方便快捷的解决上述问题，本部分内容就主要介绍这些命令的使用，常用的通信相关命令如下：
cyber_node；cyber_channel；cyber_service；cyber_launch。 cyber_visualizer 概念 一个可视化仿真工具，用于在cyberRT中显示通道数据。
使用方法
username@computername:~$: source /your-path-to-apollo-install-dir/cyber/setup.bash username@computername:~$: cyber_visualizer 与Cyber_visualizer 交互
启动cyber_visualizer后，您将看到以下界面： 当数据通过Cyber RT中的通道时，所有通道的列表都显示在ChannelNames，如下图所示。例如，您可以使用Cyber RT的记录工具（cyber_recorder）从另一个终端重播数据，然后cyber_visualizer将接收所有活动频道（来自重播数据）的信息并显示它。 通过单击工具栏中的选项，您可以同时启用参考网格、显示点云、添加图像或显示多个相机的数据。如果您启用了ShowGrid选项，您可以通过双击ChannelNames下方Grid列表Color项来设置网格的颜色。默认颜色是灰色。您还可以编辑CellCount的值，以调整网格中的单元格数量。至于点云或图像，您可以通过其ChannelName子项和Action子项选择源通道，以播放或停止来自相应通道的数据。如下图所示，按钮部分的三个摄像头通道数据和顶部部分的一点云通道数据同时显示。 要调整三维点云场景中的虚拟摄像头，您可以右键单击点云显示部分。将弹出一个对话框，如下图所示。 点云场景支持两种类型的相机：Free和Target。（从上面的弹出式对话框中选择类型）您还可以直接在对话框中修改相机信息，以更改相机在点云场景中的观察状态。“步骤”项是对话框中的步进值。将鼠标放在相机通道的图像上，您可以双击左侧按钮以突出显示左侧菜单栏上的相应数据通道。右键单击图像以调出删除相机通道的菜单。播放和暂停按钮：单击Play按钮时，将显示所有频道。点按“Pause”按钮时，所有通道都将停止显示在工具上。 免费类型相机：对于点云场景中的此类相机，您可以通过按住鼠标左键或右键并移动它来更改相机的姿势。要更改相机的音高，您可以滚动鼠标滚轮。目标类型相机：对于点云场景中的这种类型的相机，要更改相机的视角，您可以按住鼠标左键，然后移动它。要更改相机与观测点的距离（默认观察点是坐标系原点（0，0,0）），您可以滚动鼠标滚轮。 cyber_monitor
启动命令行工具后，您会注意到它与cyber_visualizer相似。它通过拓扑自动收集所有通道的信息，并将其显示在两列（通道名称、通道数据类型）。
通道信息的默认显示为红色。但是，如果有数据流过通道，则通道的相应行将以绿色显示。如下图所示：
cyber_recorder
概念
Apollo Cyber RT提供的记录/播放工具。它提供了许多有用的功能，包括录制记录文件、播放记录文件、拆分记录文件、检查记录文件信息等。
运行
$ source /your-path-to-apollo-install-dir/cyber/setup.bash $ cyber_recorder usage: cyber_recorder &lt;command&gt;&gt; [&lt;args&gt;] The cyber_recorder commands are: info Show information of an exist record. play Play an exist record. record Record same topic. split Split an exist record.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/282231215971e0e4d348741f947dbda4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86ee1bbba0bea2e73b5fcdce6f7a89c8/" rel="bookmark">
			大一统的开发平台.NET 7来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.NET 作为一个免费的跨平台开放源代码开发人员平台，这些年在不断的升级完善。就在最近，史上最快最强的.net平台.NET 7于2022年11月8日正式发布, .NET 朝着更好的⾃⼰⼜迈进了⼀步！
那么，.NET 7 有什么新东西？
.NET 7 建立在 .NET 6 建立的基础之上，其中包括一组统一的基础库、运行时（runtime）和 SDK、简化的开发体验和更高的开发人员生产力，.NET 7 主要关注领域包括：
改进对云原生方案的支持
升级旧项目的工具
简化开发人员使用容器的难度
这次.NET 7的发布是第一次的大合并发布。.NET 7 最终将统一所有不同的 .NET 开发工具组件，使开发人员能够在相同的基础类库 （BCL）、运行时和编译器上构建所有类型的应用（桌面、移动、Web 等）。
除此外，小编还整理了10个自己经常看的.NET圈子权威的公众学习平台，希望大家找到一个适合自己的，好好利用，必将会有长足的进步。
dotNET跨平台 《dotNET跨平台》是国内首个以.NET程序员、技术文化、新闻为主题的公众号，拥有超过6.6万读者。在这里你可以谈微软.NET,Mono的跨平台开发技术，也可以谈谈其他的跨平台技术。在这里可以让你的.NET项目有新的思路，不局限于微软的技术栈，横跨Windows，Linux主流平台。
打开名片,再点击右上角绿色关注按钮：
玩转VS Code 作者是微软开发工具事业部的资深开发工程师，《Visual Studio Code 权威指南》作者。也是 VS Code 的代码贡献者，写过 20 多款 VS Code 插件，其中最热门的 Code Runner 有超过一千万下载量。VS Code、开发工具等技术内容，都可以在这里找到。带你玩转VS Code！
打开名片,再点击右上角绿色关注按钮：
分布式应用运行时
《分布式应用运行时》，专注于分享Dapr技术的资讯。Dapr 是一个可移植的、事件驱动的运行时，可运行在云平台或边缘计算中。支持多种编程语言和开发框架。
打开名片,再点击右上角绿色关注按钮：
dotNet编程大全 《dotNET编程大全》，这里专注dotnet工控上位机软件开发，主要分享WPF开发项目实例，你想学习Caliburn.Micro开发框架，热衷MVVM开发，这里有全网最全的项目开发实例，可以带你快速从入门到精通。ps: 后台回复“视频”，免费领取.net入门学习视频！
打开名片,再点击右上角绿色关注按钮：
Dotnet工控 《Dotnet工控》, 专注分享Dotnet编程经验，挖掘程序员优秀的学习资源，分享内容涵盖Winfrom、WPF，工业工控相关技术知识，关注我，一起进步！
打开名片，再点击右上角绿色关注按钮：
Dotnet9 《Dotnet9》，Dotnet9，专注ASP.NET Core网站开发、MAUI跨平台应用开发、WPF客户端开发，同时以 https://Dotnet9.com 网站分享一些技术类文章，欢迎交流、学习。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86ee1bbba0bea2e73b5fcdce6f7a89c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a71b154ec6c5da624d9bee1f73cd517b/" rel="bookmark">
			c语言中几种排序方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.冒泡法排序
思路：从第一数开始，和下邻数比较，大数下沉。
对n个数排序，需要进行（n-1）轮比较；
第1轮 要进行（n-1）次两两比较；
第2轮 要进行（n-2）次两两比较；
第i轮 要进行（n-i）次两两比较；
第（n-1） 要进行 1 次两两比较；
方法：进行内外for函数
内函数进行排序次数，一般是数组内的数据减一
外函数进行数字内的比较次数，一般是数组内的数据减一再减上面进行的排序次数，同时进行数据的比大小并赋值
例子：
#include&lt;stdio.h&gt; int main() { int arr[10]={1,3,6,5,2,4,7,9,0}; for(int i=0;i&lt;=9;i++) { for(int j=0;j&lt;=10-i-1;j++){ if(arr[j]&gt;arr[j+1]){ int c=arr[j]; arr[j]=arr[j+1]; arr[j+1]=c; } } } for(int i=0;i&lt;10;i++) {printf("%d\n",arr[i]); } } 代码运行的结果为001234579，因为数组里有十个数，但是只定义了九个数，所以那一个就为0。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ac3a2e2b6d4e0fe6c4eb0b34e76a7f3/" rel="bookmark">
			【计算机毕业设计】2.酒店预订管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统截图（需要演示视频可以私聊） 摘要 伴随着全球信息化发展，行行业业都与计算机技术相衔接，计算机技术普遍运用于酒店宾馆行业。实施计算机系统来管理可以降低酒店成本，使整个酒店的发展和服务水平有显著提升。
本论文主要面向酒店管理中出现的一些常见问题，将其与计算机管理系统结合起来。通过这个系统，管理员可以更加方便的管理；用户管理、房型管理、房间管理、客户管理、预定，有效的分配房间资源；可以清楚的了解每日经营情况，盘点每月营业额；以管理员帐号登录可以添加酒店基本信息和用户信息，可以有效的分配各用户的权限。计算机管理系统在酒店管理中的应用，可以很大程度上提高管理水平，使酒店获得更好的经济效益。
但是，这套系统实现的功能只是整个酒店经营管理中的一部分，系统中还存在一些不及之处，需要继续的创新，使其完美。
关键词： JSP技术；JAVA语言；MySQL数据库；房间管理
1绪论
1.1 研究的背景及意义
随着社会的迅速发展和酒店宾馆行业竞争的日益激烈，传统的人工管理方式已经不足以满足酒店管理者的需求，在计算机科学日益成熟的今天，酒店管理者已经意识到利用计算机对酒店经营的重要性。使用计算机来管理酒店会更加便捷，所以研发一个合适的酒店管理系统是必要的。按照酒店服务业的特征和实际情况，酒店管理系统应该突显前台管理，注重数据分析等功能，努力为管理员提供有效的管理方式。通过酒店管理系统系统，来描述如何制作一个能够科学管理酒店的系统。
1.2 研究的内容及技术路线
1.2.1研究现状 国外的服务业发展较为国内早了好多年，同时在多年的发展探索中，酒店的功能发展更加全面和多样化。酒店由一开始的简单的住宿到现在的休闲娱乐以及商务旅游等，向着更复杂功能更齐全的方向发展。随着这些酒店的全面发展，其对酒店的管理要求也随着提高，为了更方便地管理酒店，在计算机迅速发展的背景下，产生了酒店管理系统软件，在很大程度上减少了人力物力和财力，也同时使酒店的经营更加规范化，提高了服务的标准。
我国传统的管理方法以经验和理性相结合，管理者要保持理性和清醒，并在拥有实际操作经验基础上，真正领会其中的要领，注重的实际行动这个过程。因此，我国酒店更注重教育管理法、经济管理法等。而在需求性不明确这一现状所存在的问题主要影响着国内酒店信息管理技术开发，使酒店项目工程难度增加，经验管理不足，开发投资的总成本太高，缺乏创新和统一的行业规范，酒店推广阻力大，都是因为管理者没有对酒店特点进行宣传所以产生不利的因素，所以极大的影响了酒店的利润空间。
目前，现阶段市场上所呈现出的酒店管理系统，绝大部分是为大型的酒店企业进行设计的，优点是其管理功能普遍较为全面，但是其存在的不足也是较为明显的：许多功能并不适用于中小型的酒店企业。实际上，在当今国内市场中占据份额比例更大一块的却是中小型酒店企业，与之对应的却是适用于中小型企业的酒店管理系统数量非常少。
1.2.2 发展趋势
中国的服务业迅速发展，从九十年代开始酒店的供给量随着需求而快速增加，同时服务业的发展随着社会经济的发展而不断的变化，从各个方面满足现代人对酒店的需求。随着服务业的发展，对酒店管理系统的需求也随着提高。现在的连锁酒店，在各个省市都有其分店，甚至世界各地都有其分店，而每个酒店因为地点和文化的不同，都有其各自的特色。酒店管理系统在服务业的需求下发展起来的，它不仅要满足酒店基本的管理功能，也要满足每个酒店为了提高竞争力而提出的推陈出新，将酒店的特色和酒店的经营模式而显示出来，比如酒店推出的一系列活动生日打折、积分兑换等，这些都帮助酒店更好地吸引消费者，更好地经营，提高自身的竞争力。
同时我们也看到当前服务业不可忽视的现象，在预定技术、产品创新等上的滞后，随着本世纪IT技术等高新技术的更新，酒店的创新也尽显高科技的踪迹。行业信息化、网络化成为新的趋势，未来的酒店管理系统则更多地显现在智能方向上。
1.2.3研究内容拟解决的主要问题
主要需要解决的问题有四个：房间的预订、用户的入住与退房、用户的管理、经营的统计。
房间的预定 用户可以通过互联网或电话预定酒店，在网上了解酒店信息，并且预定房间，同时留下用户自己的基本信息（姓名，联系方式，预定时间）。
用户的入住和退房 用户在入住之前在酒店前台登记个人信息，包括用户证件、性别、联系方式、入住时间和押金。在用户退房时要记录退房时间，并且返还押金。
用户的管理 在系统中有两种角色权限：用户和管理员。用户可以登记和查看用户信息，不能查看酒店经营统计；管理员可以查看修改用户信息和客户信息，并且可以查看酒店经营统计情况。
经营的统计 建立每日营业报表和每月营业报表。
1.2.4技术路线
本课题采用文献法、案例分析法、调查法等研究方法。采用调查法，实地调查具体酒店对管理系统的需求，熟悉服务业务流程；采用文献法，查找相关文献，借鉴相关研究成果，学习相关技术；并采用案例分析法，通过了解目前市场上已有的相关管理系统的功能，了解其优点和缺点，再根据这些设计出更完善的酒店管理系统。 本课题研究过程如下：
1.进行系统的可行性分析和研究。
2.各个模块和数据库的分析和研究。
3.对系统进行详细设计。
4.构建数据库。
5.编写代码并实现各模块功能。
6.测试系统。
2相关技术概述
本系统使用Java编程语言，采用B/S结构，使用mysql数据库管理数据。
2.1 JSP简介 JSP(Java脚本页面)是Sun和许多参与建立的公司所提倡的动态web技术。将Java程序添加到传统的web页面HTML文件(*)。htm,*。Html)。
JSP这种能够独立使用的编程语言可以嵌入在html语言里面运行，正因为JSP参照了许多编程语言的特性，使得JSP在web的脚本技术当中也占有一定的重要位置，对于刚入门编程行业的初学者来讲，jsp这种编程语言不仅容易学习，而且还具备许多高级的特性[7]。在程序的开发过程中，使用jsp也不失为一种正确的选择，像表单数据的收集操作以及字符串信息的处理方面等等，jsp都能很轻松地解决，这样节省程序开发员开发设计的时间，JSP 最大的特点就是操作简单，并且具有很好的面向对象性，因此很多的系统开发设计都喜欢用jsp技术。同时，设计开发时，有两种选择，一种是面向过程，另一种是面向对象，或者也可以两种都使用，可以称为混和方式设计。
2.2 MySQL简介 网站的开发必须配套相应数据库，数据库具有一定的组织结构，能够存放和管理数据信息，在以前数据库的功能仅仅是数据保存和管理操作，但是时代的变迁和发展，现在的数据库演变成了数据处理的方式，数据库从最开始的简单存放数据表格信息到现在的能够存放成千上万数据的大型数据库，期间还是经历了许多的改革。
本次开发的酒店管理系统使用的数据库是MYSQL数据库，该数据库运行速度快，安全性能也很高，而且对使用的平台没有任何的限制，所以被广泛应运到系统的开发中。MySQL是一个开源和多线程的关系管理数据库系统，MySQL是开放源代码的数据库，具有跨平台性，虽然功能未必强大，导致很多人都了解这个数据库的基本应用，在数据库中，总共建立了10几个表，这里面每个表都是相对应的，都各自有各自的联系，数据库意义重大，如果没有数据库的链接，就没办法运行程序，这显然可以看见数据库与程序的重要性，是紧密相连接的[9]。
2.3 网站结构 本系统选用的是B/S结构。在此布局下，用户使用的界面彻底由浏览器来实现,可以广泛的，低成本的使用。
2.4 JAVA简介 Java主要采用CORBA技术和安全模型，可以在互联网应用的数据保护。它还提供了对EJB（Enterprise JavaBeans）的全面支持，java servlet API，JSP（java server pages），和XML技术。JAVA语言是一种面向对象的语言，它通过提供最基本的方法来完成指定的任务，开发者只需要知道一些概念就能够编写出一些应用程序。Java程序相对较小，其代码能够在小机器上运行。Java是一种计算机编程语言，具有封装、继承和多态性三个主要特性，广泛应用于企业Web应用程序开发和移动应用程序开发。
Java语言和一般编译器以及直译的区别在于，Java首先将源代码转换为字节码，然后将其转换为JVM的可执行文件，JVM可以在各种不同的JVM上运行。因此，实现了它的跨平台特性。虽然这使得Java在早期非常缓慢，但是随着Java的开发，它已经得到了改进。
2.5 Tomcat服务器 Tomcat属于一种轻型的服务器，所以说在中小企业中并不具有普适性。但是当程序员需要开发或调试JSP 程序时，则通常会将该服务器作为首选。对于一个仅具有计算机基础知识的人来说，计算机系统具有一个好的Apache服务器，可以很好的对HTML 页面进行访问。Tomcat 虽然是Apache的扩展，但是它们都是可以独立运行的，二者是不互相干扰的。当配置正确的时候，Apache服务器为HTML 页面的运行提供技术支持，Tomcat 的任务则是运行Servle和JSP 页面。Tomca也具有一定的HTML页面处理功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ac3a2e2b6d4e0fe6c4eb0b34e76a7f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f097df02a07144dcb9344ee53b3b50e5/" rel="bookmark">
			封装jQuery
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装一个叫jQuery的函数
function jQuery(selector) {
return new jQuery.fn.init(selector)
}
封装一个可以选择这个类的函数例如$("类名")可选择这个标签
jQuery.fn.init = function (selector) {
// 获取到选择列表
var list = document.querySelectorAll(selector);
// 当前对象的长度
this.length = list.length;
for (var i = 0; i &lt; list.length; i++) {
// 便利类别对this赋值
this[i] = list[i]
}
}
然后在通过全局，让这个定义的函数可以使用
// 如何让new init 产生对象拥有JQuery显示原型上的所有方法？
jQuery.fn.init.prototype = jQuery.fn;
// 全局对jQuery与$可以访问
window.$ = window.jQuery = jQuery
写一个click函数
思路是在jQuery里边的prototype里边写一个函数，通过用this来指向点击的这个元素，从而添加一个click事件
click(callback) {
//利用for循环来选择有几个一样的类，若为一个这选中，若为多个可利用for循环来各个添加click时间
for (var i = 0; i &lt; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f097df02a07144dcb9344ee53b3b50e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10046040f54588aace88b304924bd29e/" rel="bookmark">
			部署KVM虚拟化平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		####情景模拟####
公司部分 Linux 服务器利用率不高， 为充分利用这些 Linux 服务器， 可以部署 KVM， 在
物理机上运行多个业务系统。 例如， 在运行 Nginx 的服务器上部署 KVM， 然后在虚拟机上运
行 Tomcat。
KVM 自 Linux 2.6.20 版本后就直接整合到 Linux 内核， 它依托 CPU 虚拟化指令集（如
Intel-VT、 AMD-V） 实现高性能的虚拟化支持。 由于与 Linux 内核高度整合， 因此在性能、
安全性、 兼容性、 稳定性上都有很好的表现。
1、KVM原理简介
广义的 KVM 实际上包含两部分， 一部分是基于 LINUX 内核支持的 KVM 内核模块， 另一部
分就是经过简化和修改的 Qemu。
KVM 内核模块模拟处理器和内存以支持虚拟机的运行，Qemu 主要处理 I/O 以及为用户提
供一个用户空间工具来进行虚拟机的管理。 两者相互结合， 相辅相成， 构成了一个完整的虚
拟化平台。
请注意： Qemu 本身并不是 KVM 的一部分， Qemu 是一套完整的虚拟化解决方案， 是纯软
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10046040f54588aace88b304924bd29e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f679e4327b8bdec3dd81a1b570c458fa/" rel="bookmark">
			用html&#43;js&#43;css3实现整屏滚动fullpage功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在jquery库中看到有人封装了整屏滚动(fullpage)的插件，感觉还挺有意思，然后想了一下怎么用原生js 实现。
本文的实例讲述了原生javascript实现的全屏滚动功能。分享供大家参考，具体如下：
1. 计算当前浏览器屏幕高度，每次翻页显示的内容高度即为屏幕高度
2. 对鼠标滚轮事件进行监听，注意滚轮事件的浏览器兼容问题。
效果图如下：
目录
一、先看看页面布局
html部分
css部分
js部分
二、代码总结
一、先看看页面布局 html部分 &lt;div class="container"&gt; &lt;div class="section section1"&gt; &lt;h1&gt;第1屏&lt;/h1&gt; &lt;/div&gt; &lt;div class="section section2"&gt; &lt;h1&gt;第2屏&lt;/h1&gt; &lt;/div&gt; &lt;div class="section section3"&gt; &lt;h1&gt;第3屏&lt;/h1&gt; &lt;/div&gt; &lt;div class="section section4"&gt; &lt;h1&gt;第4屏&lt;/h1&gt; &lt;/div&gt; &lt;div class="section section5"&gt; &lt;h1&gt;第5屏&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class="controls"&gt; &lt;li class="active"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt; css部分 &lt;style&gt; * { padding: 0; margin: 0; } html, body { width: 100%; height: 100%; overflow: hidden; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f679e4327b8bdec3dd81a1b570c458fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fe1780230c4e21656ec6d423f7e9586/" rel="bookmark">
			G1D21-作业-AttacKG&amp;SVM&amp;kg_book&amp;偷懒哈哈哈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		唔~咖啡泡出来好好看呀！
一、写作业 第一件事是将昨天读的NER综述补充到作业之中~大概30min
50分钟，补充完了思维导图和文档，明确了下一步论文的阅读方向——NER的综述/网安NER具体技术类文章（找找最新的叭）。
二、AttacKG (一）重调代码 昨天代码跑起来啦，但是emm输出结果好奇怪hhh，本以为是源代码的bug，但看了哆啦a梦的blog，emm发现是自己的问题，再看看~预计1小时
1、重新装了coferee，不太管用 2、把图片放大看，好像没有那么荒凉，还是有字的 哈哈哈哈哈
要被蠢死啦hhhh
不过这也太丑了叭~
（二）改字体大小（小改代码） 借着这个机会，熟悉一下这里面的代码~
1、在main.py找到对应画图函数
2、跳进attackGrapg_generating
3、改draw就好啦
4、文本太长了emm全都重叠了
5、主要问题在于label太长了，好丑，之后再调，把节点调大了一点
6、现在觉得git真香哦~
—1402下午场的AttacKG,
（三）梳理代码 1、先磨下刀，看看别人是怎么复现一篇论文的 （1）先看.py文件的结构，一般分为数据预处理、增强、训练、测试
（2）放小批量数据debug，弄清模块之间的顺序，每个模块的大致功能，不需要弄清楚细节
（3）画出流程图，理清每个模块之间的关系。
https://blog.csdn.net/weixin_45638136/article/details/123772812
tips: (1)勤注释；输入、输出、功能，不熟练时加入输入输出维度
2、梳理.py结构 （1）惊奇地发现了一张图，比论文呢里的详细一点嘿嘿
（2）大致目录
preprocess是对报告的预处理
3、main.py running_mode = arguments.mode print(f"Running mode: {running_mode}") if running_mode == "iocProtection": # 什么是ioc_protection? #输入：报告； #功能：先使用"./ioc_regexPattern.json" 找到ioc，再用 "./ioc_replaceWord.json"将其换成对应类型（例如"DocumentFile": "document",）， #不太明白换了有什么用 #输出：replaced_text ioc_identifier = ioc_protection(report_text) elif running_mode == "nlpModelTraining": # NLP model training dataset's path， default 路径在../ AttacKG / NLP / Doccano / 20210813.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fe1780230c4e21656ec6d423f7e9586/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16ff8b43aa15fc7007c67f413743bf83/" rel="bookmark">
			头歌——数据结构与算法 - 查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第1关：实现折半查找 /************************************************************* date: April 2009 copyright: Zhu En DO NOT distribute this code. **************************************************************/ //折半查找的顺序表 实现文件 //每个结点的数据是关键码 // #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "BSlist.h" BSeqList* BSL_Create(int size) //创建一个顺序表 //与BSL_Free()配对 { BSeqList* blist=(BSeqList*)malloc(sizeof(BSeqList)); blist-&gt;pkey = (int*)malloc(sizeof(int)*size); blist-&gt;max=size; blist-&gt;len=0; return blist; } void BSL_Free(BSeqList* blist) //释放/删除顺序表 //与BSL_Create()配对 { free(blist-&gt;pkey); free(blist); } int BSL_FindKey(BSeqList* blist, int key) //在排序的顺序表中查找关键码值为key的结点，返回结点的编号 //返回值大于等于0时表示找到值为key的结点的编号，-1表示没有找到 { /*请在BEGIN和END之间实现你的代码*/ /*****BEGIN*****/ int l,h,m;//k是low，r是high，m是mid l=0; h=blist-&gt;len-1; while(l&lt;=h) { m=(l+h)/2; if(key==blist-&gt;pkey[m]) { return m; } else { if(key&lt;blist-&gt;pkey[m]) { h=m-1; } else { l=m+1; } } } return -1; /******END******/ /*请不要修改[BEGIN,END]区域外的代码*/ } int BSL_InsKey(BSeqList* blist, int key) //在排序的顺序表中插入一个值为key的结点 //返回值大于等于0时表示插入的位置, -1表示表满（无法插入） { if (blist-&gt;len&gt;=blist-&gt;max) return -1; int k, r, m; k=0; r=blist-&gt;len-1; //寻找插入位置 while (k&lt;=r) { m=(k+r)&gt;&gt;1; //m=(k+r)/2 if (key == blist-&gt;pkey[m]) return -2;若不允许插入已存在的值，则需要此行 if (key&lt;blist-&gt;pkey[m]) r=m-1; else k=m+1; } //插入位置为k, 腾出k号位置 for (r=blist-&gt;len; r&gt;k; r--) blist-&gt;pkey[r]=blist-&gt;pkey[r-1]; //key放入k号位置 blist-&gt;pkey[k]=key; blist-&gt;len++; return k; } int BSL_DelKey(BSeqList* blist, int key) //在排序的顺序表中删除值为key的结点, //存在值为x的结点则返回结点编号, 未找到返回－1 { int k=BSL_FindKey(blist, key); if (k&lt;0) return -1; int i=k; while(i &lt; blist-&gt;len-1) { blist-&gt;pkey[i] = blist-&gt;pkey[i+1]; i++; } blist-&gt;len --; return k; } void BSL_Print(BSeqList* blist) //打印整个顺序表 { if (blist-&gt;len==0) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16ff8b43aa15fc7007c67f413743bf83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fba0ef14adc3148a939f18a3b05eb711/" rel="bookmark">
			四旋翼无人机Matlab建模
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要分享一下四旋翼无人机的建模过程，然后在Matlab的simulink模块搭建起四旋翼无人机的模型，本篇文章主要参考了康日晖的《四旋翼无人机建模》与南京邮电大学周帆同学的硕士毕业论文，最后我会给出参考文章网址，有兴趣的同学可以看看。
一、无人机建模过程 1.坐标系建立 为了更好的描述无人机的姿态，需要建立两个坐标系：一是地面坐标系；二是机体坐标系。首先建立地面坐标系。
地面坐标系，顾名思义就是一种固定在地球表面的坐标系。在地面上任选一点O作为原点，X轴指向地球表面任意一个方向，Z轴沿着铅直方向指向天空，Y轴在水平面内与X轴垂直，指向通过右手法则来确定。飞行器的位姿，速度，角速度等都是相对于这一坐标系来衡量的，在这里，我们将地面坐标系记为{E-OXYZ}系，其图如下所示：
机体坐标系，很显然，该坐标系建立在飞行器上。原点o位于飞行器的质心处，对于四旋翼而言，其实为四旋翼中心；x轴在飞机的对称平面内，并且平行于飞行器的设计轴线，指向机头前方；y轴垂直于机身对称平面，并指向机身右方；z轴过o点并于xoy平面垂直，指向飞行器上方。该坐标系我们一般记为{B-oxyz}系，其示意图如下：
机体坐标系和地面坐标系之间的转换关系可以通过三个欧拉角进行描述，分别是俯仰角 θ \theta θ,横滚角 ϕ \phi ϕ,偏航角 ψ \psi ψ。记地面坐标系为E系，机体坐标系为B系，从地面坐标系变换到机体坐标系的变换过程如下：
1.{B}的初始方位与坐标系{E}重合，首先{B}绕 X E 轴 X_{E}轴 XE​轴,即地面坐标系的X轴旋转横滚角 ϕ \phi ϕ，得到新坐标系记作 B 1 B_{1} B1​
2.将 B 1 B_{1} B1​坐标系绕 Y E Y_{E} YE​轴，即地面坐标系的Y轴旋转俯仰角 θ \theta θ，得到新坐标系记作 B 2 B_{2} B2​
3.将 B 2 B_{2} B2​坐标系绕 Z E Z_{E} ZE​轴，即地面坐标系的Z轴旋转偏航角 ψ \psi ψ，得到新坐标系记作 B 3 B_{3} B3​，该坐标系就是我们飞行器运动后的机体坐标系
由于上述一系列坐标系变换都是相对于固定坐标系{E}旋转合成得到，因此可以通过左乘基本旋转矩阵得到机体坐标系{B}转换到地面坐标系{E}的旋转矩阵，计算公式如下：
B E R = R z ( ψ ) R y ( θ ) R x ( ϕ ) （ 1 ） _{B}^{E}\textrm{R}=R_{z}(\psi)R_{y}(\theta)R_{x}(\phi) （1） BE​R=Rz​(ψ)Ry​(θ)Rx​(ϕ)（1）其中 B E R _{B}^{E}\textrm{R} BE​R是机体坐标系B转换到地面坐标系{E}的旋转矩阵， R x , R y , R z R_{x},R_{y},R_{z} Rx​,Ry​,Rz​分别是绕x,y,z轴旋转的基本旋转矩阵，将(1)式展开
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fba0ef14adc3148a939f18a3b05eb711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833c21dc368eda0a393b821e98c09b74/" rel="bookmark">
			答案解析（C语言版本）——第五届“传智杯”全国大学生计算机大赛（练习赛）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
A [传智杯 #5 练习赛] 复读
输入输出样例 输入 #1
输出 #1 代码解析如下
B [传智杯 #5 练习赛] 时钟
输入输出样例
输入 #1
输出 #1
输入 #2
输出 #2
输入 #3
输出 #3
代码解析如下
C [传智杯 #5 练习赛] 平等的交易
输入输出样例
输入 #1
输出 #1
代码解析如下
D [传智杯 #5 练习赛] 清洁工
输入输出样例
输入 #1
输出 #1
输入 #2
输出 #2
输入 #3
输出 #3
输入 #4
输出 #4
代码解析如下
A [传智杯 #5 练习赛] 复读 输入输出样例 输入 #1 cc b a cc 0 输出 #1 ccba 代码解析如下 #include&lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833c21dc368eda0a393b821e98c09b74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9973516cbd3e0c682620210732ba080c/" rel="bookmark">
			com.vividsolutions.jts.io.ParseException: Expected EMPTY or ( but found ‘Z‘ (line 1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据中包含了Z点，将Z值去掉即可
需要使用Acrmap，解决方法传送门
MULTIPOLYGON Z转MULTIPOLYGON ArcMap_夏夜里的晚风。的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07fff1099094894e92194365ec6b6e11/" rel="bookmark">
			Pycharm菜单栏消失，（File 、view消失）快速调出来的方法。（Professional Edition 2022版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pycharm菜单栏消失后，如何快速调出来？ python版本如下：
Pycharm是2019版的
Pycharm菜单栏消失后如下图：
解决办法： 打开Pycharm，然后双击Shift键两次，在弹出的搜索框中输入“view”。再找到“View | Appearance：Main Menu”，将“OFF”状态调整为“ON”即可看到菜单栏了。
截图如下：
ps:设置菜单栏不显示的操作 勾选掉view→Appearance→Main Menu选项，菜单栏会消失。
后续补充：
针对2022专业版
截图如下：
PyCharm 2022.2.3 (Professional Edition)
Build #PY-222.4345.23, built on October 10, 2022
Licensed to cat method
You have a perpetual fallback license for this version.
Subscription is active until December 31, 2099.
Runtime version: 17.0.4.1+7-b469.62 amd64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
Windows 10 10.0
GC: G1 Young Generation, G1 Old Generation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07fff1099094894e92194365ec6b6e11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f01c7384c258762fc96ef43596a892ca/" rel="bookmark">
			nginx 验证配置文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 docker安装的nginx,
docker ps 1.进入容器
docker exec -it 3e7 bash 2.定位到 /opt/nginx/sbin，使用如下命令，如果配置文件正确，会出现如下提示
./nginx -t 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7016cbdfd7484404a4192dc61404486/" rel="bookmark">
			在linux上创建虚拟CAN，并简单执行一个CAN的读写程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建虚拟CAN接口 在Linux上能使用虚拟CAN接口之前，需要在终端执行以下三个步骤：
加载vcan内核模块: sudo modprobe vcan
创建虚拟CAN接口: sudo ip link add dev vcan0 type vcan
将虚拟CAN接口处于在线状态: sudo ip link set up vcan0
然后，通过命令ip addr | grep "can" 来验证是否可用并处于在线状态
也可以通过shell脚本来自动化实现以上步骤： 创建一个vcan.sh文件。然后将其标记为可执行文件: chmod +x ~/vcan.sh，之后执行这个文件 ./vcan.sh
#!/bin/bash # Make sure the script runs with super user priviliges. [ "$UID" -eq 0 ] || exec sudo bash "$0" "$@" # Load the kernel module. modprobe vcan # Create the virtual CAN interface. ip link add dev vcan0 type vcan # Bring the virutal CAN interface online.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7016cbdfd7484404a4192dc61404486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e174cd149e8554ad3bb3a7add82f0ea8/" rel="bookmark">
			13、微信小程序：上传图片到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、上传图片到服务器，有两个步骤： 1.1 拿到可上传的图片 wx.chooseImage
1.2 将图片上传到服务器 wx.uploadFile
2、代码实现 &lt;button bindtap="upload"&gt;点击上传&lt;/button&gt;
&lt;image src="{{imgPath}}" mode=""/&gt;
upload(){ var _this=this wx.chooseImage({ 拿几张图片 count 图片上传类型 sizeType 图片来源 sourceType success(res){//获取成功 wx.uploadFile({ 临时图片路径 filePath 服务器地址 url name timeout success(res){ let imgPath=baseUrl+JSON.parse(res2.data).data _this.setData({ imgPath }) } }) } }) } // 上传图片到服务器 upload() { var _this=this wx.chooseImage({ count: 1, //可上传的图片数量 sizeType: ['original', 'compressed'],//上传图片类型：原图、压缩图 sourceType: ['album', 'camera'], //图片来源：相册、照相机 success(res) { // 成功，将图片上传到服务器 console.log(res); // 拿取临时路径文件 let filePath = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e174cd149e8554ad3bb3a7add82f0ea8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61462a365cea18fdf7ae39e425fbd2b0/" rel="bookmark">
			洛谷P5733 【深基6.例1】自动修正
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【深基6.例1】自动修正 题目描述 大家都知道一些办公软件有自动将字母转换为大写的功能。输入一个长度不超过 100 100 100 且不包括空格的字符串。要求将该字符串中的所有小写字母变成大写字母并输出。
输入格式 输入一行，一个字符串。
输出格式 输出一个字符串，即将原字符串中的所有小写字母转化为大写字母。
样例 #1 样例输入 #1 Luogu4! 样例输出 #1 LUOGU4! 思路：判断输入的每个字符，只要是小写字母a到z就把他变成A到Z，其他字符不需要变，输出出来就可以了。
代码如下（编译器是dev，语言是C语言）：
#include&lt;stdio.h&gt; char a[101]; int i = 0; int main(){ gets(a); while(a[i]!=NULL){ if((a[i]&gt;=97)&amp;&amp;(a[i]&lt;=122)) a[i] = a[i]-32; i++; } puts(a); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5903fbd28ee32687808887c16046a7b3/" rel="bookmark">
			golang vscode debug 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装插件 Ctrl + Shift + P，搜索框输入「Go:Install/Update Tools」，全选后点ok进行安装。显示「All tools successfully installed.」则表示安装完成
.vscode 配置文件 launch.json { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 "version": "0.2.0", "configurations": [ { "name": "Launch Package", "type": "go", "request": "launch", "mode": "auto", "env": { "PATH":"/opt/compiler/gcc-8.2/bin/:/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/opt/bin:/home/opt/bin:/usr/local/go/bin:/usr/local/git/bin:/usr/local/sbin:/usr/sbin:/opt/bin:/home/opt/bin:/usr/local/go/bin:/usr/local/git/bin:/opt/bin:/home/opt/bin:/usr/local/go/bin:/opt/bin:/home/opt/bin:/usr/local/go/bin:/usr/local/git/bin:/opt/bin:/home/opt/bin:/usr/local/go/bin:/usr/local/git/bin", "GOROOT":"/usr/local/go", "GOPATH":"/Users/lwt/go" }, "program": "${workspaceRoot}/main.go" } ] } task.json { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5903fbd28ee32687808887c16046a7b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9de9e9ea66c33f501083c4933f8ddeb/" rel="bookmark">
			都要2023年了，不会还有人不知道redis为什么快吧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis作为一种常见的kv数据库，在实际中使用非常广泛，其最大的特点就是"快"，在系统中常被用来当做缓存快速获取想要数据。我们也会经常被问到，redis为什么这么快呢？兄弟们常常都是以下的回答：
redis基于内存redis是单线程redis采用阻塞式io和多路io复用优化了数据结构 相信许多的兄弟在刚刚毕业的时候都是这个回答，我当初也是如此。随着我们年龄的增长，以及对技术的不断了解。我们不能只局限于此，我将把这几点具体展开。
redis基于内存 这一点想必是大家最耳熟能详的一句话了。redis为什么快？因为基于内存！
不过也确实如此，MySQL的数据和索引都是持久化保存在磁盘上的，因此当我们使用SQL语句执行一条查询命令时，如果目标数据库的索引还没被加载到内存中，那么首先要先把索引加载到内存，再通过若干寻址定位和磁盘I/O，把数据对应的磁盘块加载到内存中，最后再读取数据。Redis把数据存在内存中，读写都直接对数据库进行操作，天然地就比硬盘数据库少了到磁盘读取数据的这一步。
不过redis快，基于内存是一个很重要的因素。不过不是全部的因素。
redis是单线程 在很久以前，当时秋招的我在背到这一条的时候其实是纳闷的。
redis单线程所以快？不应该是多线程来的快些吗？
多线程有时候确实比单线程快，但也有很多时候没有单线程那么快。比如并发时，并发是指多个进程指令在一个cpu中运行在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
在这种并发的情况下，就涉及到上下文切换的问题了。在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。redis的单线程模式就不需要上下文切换，提升了速度。避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。
redis采用非阻塞式io和多路io复用 非阻塞式io当用户进程发出 read 操作时，如果内核中的数据还没有准备好，那么它不会阻塞用户进程，而是立刻返回一个错误。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。当用户进程判断结果是一个错误时，它就知道数据还没有准备好，于是它可以再次发送read操作。
多路IO复用，有时也称为事件驱动IO。它的基本原理就是有个函数会不断地轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。
优化了数据结构 redis实现的数据结构，使得我们对数据进行增删查改操作时，Redis 能更加高效的处理。具体的数据结构主要有以下这些：
SDS Redis 是用 C 语言实现的，但是它没有直接使用 C 语言的 char* 字符数组来实现字符串，而是自己封装了一个名为简单动态字符串（simple dynamic string，SDS） 的数据结构来表示字符串，也就是 Redis 的 String 数据类型的底层数据结构是 SDS。
为啥要封装这样应该数据结构呢？
首先，之前c语音的char的数据结构有缺陷！char类型的数据结构在读取到\0的时候就看做字符串结束，这样会有两个问题：
要是字符串中含有\0时会提前结束。每次查询char类型的长度时，时间复杂度位0（n）C 语言的字符串是不会记录自身的缓冲区大小的，字符串操作函数不高效且不安全，比如可能会发生缓冲区溢出，从而造成程序运行终止。 Redis封装的SDS数据结构如下：
len记录所保存字符串的长度alloc，分配给字符数组的空间长度flags，SDS 类型，用来表示不同类型的 SDSbuf[]，字节数组，用来保存实际数据 因为 SDS 不需要用 “\0” 字符来标识字符串结尾了，而且 SDS 的 API 都是以处理二进制的方式来处理 SDS 存放在 buf[] 里的数据，程序不会对其中的数据做任何限制，数据写入的时候时什么样的，它被读取时就是什么样的。
不会发生缓冲区溢出，Redis 的 SDS 结构里引入了 alloc 和 leb 成员变量，这样 SDS API 通过 alloc - len 计算，可以算出剩余可用的空间大小，这样在对字符串做修改操作的时候，就可以由程序内部判断缓冲区大小是否足够用 。不够用时自动扩大空间大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9de9e9ea66c33f501083c4933f8ddeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f8e9e9b42127fb06cead78a85f23c22/" rel="bookmark">
			PyAutoGUI——让所有GUI都自动化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.简介
1.1 目的
1.2 例子
1.4 保护措施（Fail-Safes）
2 安装与依赖
3.速查表（小抄，Cheat Sheet）
3.1 常用函数
3.2 保护措施
3.3 鼠标函数
3.4 键盘函数
3.5 消息弹窗函数
3.6 截屏函数
4 常用函数
5 鼠标控制函数
5.1 屏幕与鼠标位置
5.2 鼠标行为
5.3 鼠标拖拽
5.4 缓动/渐变（Tween / Easing）函数
5.5 鼠标单击
5.6 鼠标按下和松开函数
5.7 滚轮滚动函数
6 键盘控制函数
6.1 typewrite()输入函数
6.2 press()，keyDown()和keyUp()函数
6.3 hotkey()函数
6.4 KEYBOARD_KEYS
7 消息弹窗函数
7.1 alert()函数
7.2 The confirm() Function
7.3 The prompt() Function
7.4 The password() Function
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f8e9e9b42127fb06cead78a85f23c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b7e4cf4c6b0b959baa226cd04e24ac/" rel="bookmark">
			深度学习基础学习-1x1卷积核的作用（CNN中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这里就不赘述卷积神经网络相关内容了，直接通过博主看的一些资料，自己进行了一些整合，大佬绕道。
对于1x1卷积核的作用主要可以归纳为以下几点
增加网络深度（增加非线性映射次数）升维/降维跨通道的信息交互减少卷积核参数（简化模型） 1、普通卷积 这里首先展示了一个我们最常见的卷积方式（通道数为1），一个5x5的图怕，通过一个3x3的卷积核提取特征得到一个3x3的结果。如果这里的卷积核是1x1的，那么效果如下
2、1x1卷积核作用 2.1 增加网络深度（增加非线性映射次数） 首先直接从网络深度来理解，1x1 的卷积核虽小，但也是卷积核，加 1 层卷积，网络深度自然会增加。
1x1卷积核，可以在保持feature map尺度不变的（即不损失分辨率）的前提下大幅增加非线性特性（利用后接的非线性激活函数），把网络做的很深。并且1x1卷积核的卷积过程相当于全连接的计算过程，通过加入非线性激活函数，可以增加网络的非线性，使得网络可以表达更复杂的特征。
具体来说，引用一下「frank909」博客的内容：
其实问题往下挖掘，应该是增加网络深度有什么好处？为什么非要用 1x1 来增加深度呢？其它的不可以吗？
其实，这涉及到感受野的问题，我们知道卷积核越大，它生成的 featuremap 上单个节点的感受野就越大，随着网络深度的增加，越靠后的 featuremap 上的节点感受野也越大。因此特征也越来越抽象。
但有的时候，我们想在不增加感受野的情况下，让网络加深，为的就是引入更多的非线性。
而 1x1 卷积核，恰巧可以办到。
我们知道，卷积后生成图片的尺寸受卷积核的大小和跨度影响，但如果卷积核是 1x1 ，跨度也是 1，那么生成后的图像大小就并没有变化。
但通常一个卷积过程包括一个激活函数，比如 Sigmoid 和 Relu。
所以，在输入不发生尺寸的变化下，却引入了更多的非线性，这将增强神经网络的表达能力
2.2、升维/降维 其实这里的升维、降维具体指的是通道数的变化，当我们确定了卷积核尺寸后，我们的height、width都不变，那么这里的维度具体指的就是channels。我们通过改变卷积核的数量来改变卷积后特征图的通道channels来实现升维、降维的效果。这样可以将原本的数据量进行增加或者减少
下面分别举两个例子就能明显看到效果
2.2.1 升维 2.2.2 降维 其实很明显的能看出来，无论是升维还是降维，我们都是通过改变卷积核的数量实现的，卷积后的特征图的通道数channels同卷积核的数量保持一致，这里其实不仅仅是1x1卷积核能实现这个功能，其他尺寸的卷积核也可以，那么我们为什么要选用1x1卷积核呢
2.2.3 使用1x1卷积核升维/降维的原因 当我们仅仅只是想要改变通道数的情况下，1x1卷积核是最小的选择，因为大于1x1的卷积核无疑会增加计算的参数量，内存也会随之增大，所以只想单纯的去提升或者降低特征图的通道，选用1x1卷积核最为合适， 1x1卷积核会使用更少的权重参数数量。
2.3 跨通道的信息交互 1x1卷积核只有一个参数，当它作用在多通道的feature map上时，相当于不同通道上的一个线性组合，实际上就是加起来再乘以一个系数，但是这样输出的feature map就是多个通道的整合信息了，能够使网络提取的特征更加丰富。
使用1x1卷积核，实现降维和升维的操作其实就是 channel 间信息的线性组合变化。
比如：在尺寸 3x3，64通道个数的卷积核后面添加一个尺寸1x1，28通道个数的卷积核，就变成了尺寸3x3，28尺寸的卷积核。 原来的64个通道就可以理解为跨通道线性组合变成了28通道，这就是通道间的信息交互。
注意：只是在通道维度上做线性组合，W和H上是共享权值的滑动窗口。
2.4 减少卷积核参数（简化模型） 下面仅以计算权重数为例子进行计算（不添加bias）
2.4.1 一层卷积添加1x1卷积核，分别计算权重数 （1）不使用1x1卷积核
（2）使用1x1卷积核
可以看到不使用1x1的卷积核是使用卷积核的10倍左右
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b7e4cf4c6b0b959baa226cd04e24ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b79130eddc3fa3c6b6f0a6098e9389a/" rel="bookmark">
			【mybatis】第二篇：@Select注解中加入字段判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
因需要链表操作，所以采用了@select注解来写sql，抛弃了传统的xml形式。
1.错误性示范代码 @Select({"&lt;script&gt;", "select a.*,b.uuid,b.denoter_name as denoterName,b.spelling,b.public_name as publicName from t_denoter_qrcode a right join t_bz_denoter b on a.denoter_uuid=b.denoter_uuid ", "where 1=1 ", "&lt;if test='qrcodeRequest.denoterAddress !=null and qrcodeRequest.denoterAddress!="" '&gt;" , " and a.address like concat('%',#{qrcodeRequest.denoterAddress},'%')" , "&lt;/if&gt; ", "&lt;if test='qrcodeRequest.denoterName !=null and qrcodeRequest.denoterName!="" '&gt;" , " and b.denoter_name like concat('%',#{qrcodeRequest.denoterName},'%') " , "&lt;/if&gt; ", "&lt;if test='qrcodeRequest.publicName !=null and qrcodeRequest.publicName!="" '&gt; " , " and b.public_name like concat('%',#{qrcodeRequest.publicName},'%')" , "&lt;/if&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b79130eddc3fa3c6b6f0a6098e9389a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3879bbe10b8307c4706026b961960f9d/" rel="bookmark">
			git commit 撤销操作详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git commit之后，想撤销commit 原文
写完代码后，我们一般这样
git add . //添加所有文件
git commit -m "本功能全部完成"
执行完commit后，想撤回commit，怎么办？
这样凉拌：
git reset --soft HEAD^
这样就成功的撤销了你的commit
注意，仅仅是撤回commit操作，您写的代码仍然保留。
说一下个人理解： HEAD^的意思是上一个版本，也可以写成HEAD~1
如果你进行了2次commit，想都撤回，可以使用HEAD~2
至于这几个参数： --mixed 意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作
这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的。
--soft 不删除工作空间改动代码，撤销commit，不撤销git add . --hard 删除工作空间改动代码，撤销commit，撤销git add . 注意完成这个操作后，就恢复到了上一次的commit状态。
顺便说一下，如果commit注释写错了，只是想改一下注释，只需要： git commit --amend
此时会进入默认vim编辑器，修改注释完毕后保存就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac16c5901c9d75f4956045a2e3d2f9a/" rel="bookmark">
			11、微信小程序——购物车
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、代码分析
1.1 dom结构分析
1.2 全选控制反选
1.3 反选控制全选
1.4、计算总价
1.4 加、减
2、效果、代码演示 1、代码分析 1.1 dom结构分析 购物车的组件结构主要由两部分组成：多选框部分( checkbox-group ) + 全选框部分( view )
1.2 全选控制反选 业务逻辑：
1、全选框（选中）——》 多选框（选中）、全选框（不选中）——》 多选框（不选中）
2、令复选框跟随全选框的状态变化——遍历数据，设置每条数据的 isChecked 状态
注意：因为无法直接操作数据，所以需要先行拷贝数据，再对其进行遍历（在本项目中，所有需要对数据进行遍历、筛选操作的步骤，都需要先拷贝数据）
allChecked(e){ console.log(e); //触发点击事件，拿到全选框的事件源对象 // 全选框： 状态为 true时，令其为 false，当状态为 false时，令其状态变为 true if(this.data.isAllChecked){ // 遍历数据，令复选框的状态跟随全选框变化 // 拷贝数据、遍历数据 let goodslist=JSON.parse(JSON.stringify(this.data.goods)) goodslist.forEach(item=&gt;item.isChecked=false) this.setData({ isAllChecked:false, goods:goodslist //重新渲染 }) }else{ let goodslist=JSON.parse(JSON.stringify(this.data.goods)) goodslist.forEach(item=&gt;item.isChecked=true) this.setData({ isAllChecked:true, goods:goodslist }) } }, 1.3 反选控制全选 业务逻辑：
1、多选框（全部选中）——》全选框（选中）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac16c5901c9d75f4956045a2e3d2f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef88b3f3a7b792cfe085ea60a5e2adb9/" rel="bookmark">
			vue3实现前端下载本地模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue3 需要在public下新建static文件夹 然后把模板文件放入static下
&lt;el-button type="primary" @click="handleExport()"&gt;下载文件模板&lt;/el-button&gt; const handleExport = () =&gt; { let a = document.createElement('a'); document.body.appendChild(a); a.href = '../static/muban.xlsx'; a.download = '模板' + '.xlsx'; a.style.display = 'none'; a.click(); document.body.removeChild(a); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/400e724f762dc3221e55ee2f4bb17187/" rel="bookmark">
			Vite是什么？怎么用Vite来创建一个前端项目?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Vite是一种新型的前端构建工具，能够显著提升前端开发体验，主要有以下特点：
使用原生ESM文件，无需打包轻量快速的热加载优化构建，可选单页应用或者库模式，配置构建灵活的API 常用框架项目模板 搭建第一个Vite项目，我这里使用NPM搭建，可选的有Yarn，pnpm。跟Vue类似，Vite也提供了很多的模板，用来创建不同框架的项目。目前支持的模板有：
vanlilla,vanlilla-tsvue,vue-tsreact,react-tspreact,preact-tslit,lit-tssvelte,svelte-ts 可以根据需要选择，带-ts的是TypeScript版本，没有的话就用的是JavaScript。
搭建项目 # template可以根据上面罗列的来选择不同的模板 npm create vite@latest my-app --template vue 根据提示，运行以下命令：
#进入到新建的项目根目录下 cd my-app #安装依赖 npm install #本地运行 npm run dev 在浏览器中打开上面的URL就表示成功的用Vite创建了一个新的项目。
Vite作为新的打包工具，能实现打包后比Webpack打包后更快速的访问。这个算是它的优势之一。
参考：https://cn.vitejs.dev/guide/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358f22874fa0fc71118c6d6899f82b46/" rel="bookmark">
			Java LTS版本——Java 8新特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java LTS(长期支持版本)，目前最新的有Java8，Java11，Java17。
今天来总结一下Java8版本中主要的新特性。供大家学习参考
Lambda表达式Stream流 APIForeach 方法日期时间APINoshorn JavaScript 引擎方法引用 StringJoiner 1.Lamba表达式 Lamba表达式是一个匿名的函数，可以通过像函数式编程的方式一样写代码。Lamba表达式能极大的简化我们的代码。
常见的写法：
不需要参数,返回10 ()-&gt;10 传入一个参数,返回a的平方 (a)-&gt;a*a 传入两个参数，并且返回它们的和 (a,b)-&gt;a+b 没有返回值的 (s)-&gt;System.out.println(s) 最常见的就是创建线程的写法：
public static void main(String[] args) { Runnable run1=new Runnable() { @Override public void run() { System.out.println("thread1 is running!"); } }; Runnable run2=()-&gt;{ System.out.println("thread2 is running!"); }; Thread t1=new Thread(run1); Thread t2=new Thread(run2); t1.start(); t2.start(); } 2. Stream流 API Stream流API提供了数据过滤，提取，转换的方法。和之前的InputStream流完全没有关系，Stream流是对管道中数据的处理。Stream流的数据来自集合，数组，I/O channel，产生器generator等，简化了Java集合的编程。
常用的操作：
filter(lambda):从流中排除某些元素
distinct():从流中去除重复的元素
limit(long maxsize):截断流，只保留给定数量的元素
skip(long n)跳过元素，返回跳过的元素流
sorted():产生新的流，按照顺序排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/358f22874fa0fc71118c6d6899f82b46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cf9b38c3461e5eae6c356af96b0b341/" rel="bookmark">
			磁力链接&#43;爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		磁力链接+爬虫_weixin_34307464的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2741d291efeeee74c248f156e8127336/" rel="bookmark">
			npm install / run报错缺少core-js模块【解决方案】【亲测有效】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在使用PanJiaChen的 vue-admin-template 或 vue-element-admin 模板时，npm install 或 run 时会报缺少core-js模块，如下图。
解决办法 在 https://www.npmjs.com/package/core-js 页面，点击 Homepage 的链接。
或者
直接点击https://github.com/zloirock/core-js跳转到GitHub中将文件down下来。
将文件的core-js-master\packages\core-js里的所有内容复制下来，将自己项目的node-modules 对应的 core-js 文件夹下的内容进行替换。
然后再次运行，就没有问题了。
参考 感谢博主的博文支持【https://blog.csdn.net/caixuanji/article/details/121267451】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7daa0aaadae87c0534d9c4e18b11669/" rel="bookmark">
			C语言一元线性回归方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void main() { float x[] = {0,5182,10391,15628,20791,26001,31228,36419,41683,46846,52083,57292,62263,67674,72966,83375}; float y[] = {0,5000,10000,15000,20000,25000,30000,35000,40000,45000,50000,55000,60000,65000,70000,80000}; int n; n = sizeof(x) / sizeof(x[0]); float a, b, b1, mxy, sum_x, sum_y, lxy, xiSubSqr; a = b = mxy = sum_x = sum_y = lxy = xiSubSqr = 0.0; for (int i = 0; i &lt; n; i++) { sum_x += x[i]; sum_y += y[i]; } float x_ave = sum_x / n; float y_ave = sum_y / n; for (int i = 0; i !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7daa0aaadae87c0534d9c4e18b11669/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/206/">«</a>
	<span class="pagination__item pagination__item--current">207/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/208/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>