<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04ec59d686767cd1911f39fff0e50b5/" rel="bookmark">
			JS将对象转为字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 对象转为字符串 使用JSON.stringfy() JSON.stringify()将javascript对象转换为通过Web服务器发送数据所需的字符串。
语法：
JSON.stringify(obj)
参数：可以是对象，数组。
const obj = { id: 0, name: '张三', age: 12 } const objToStr = JSON.stringify(obj) console.log('obj:', obj) // obj: {id: 0, name: '张三', age: 12} console.log('objToStr:', objToStr) // objToStr: {"id":0,"name":"张三","age":12} 参数为数组(对象数组)
var obj_to_str={ name: "GeeksForGeeks", city: "Noida", contact:2488 }; var myJSON = JSON.stringify(obj_to_str); console.log(myJSON) // {"name":"GeeksForGeeks","city":"Noida","contact":2488} 使用toString为什么不行 {}.toString();//报错，Unexpected token . ({}).toString();//[object Object] ({a:123}).toString();//[object Object] Object.toString();//"function Object() { [native code] }" function Person(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d04ec59d686767cd1911f39fff0e50b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb87db5ea9e07238651bb457dd4e34ba/" rel="bookmark">
			C#内建接口：IEquatable泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这节来讲一下泛型接口：IEquatable。
IEquatable泛型接口处于System.Runtime命名空间下，最早在.NET Framework 2.0中发布，只有泛型版本。像之前我们讲过的IComparable，IEnumerable接口，它们属于是1.0时期的内建接口，那时C#还没有泛型的概念，而2.0以后的版本，才有泛型的概念。之所以出现泛型接口，是因为通过泛型可以减少值类型的装箱，以及实现类型安全。
IEquatable中有什么？
我们先看一下IEquatable泛型接口中的元素：
这个接口里边只有一个方法：Equals，返回一个Bool值，从名称中我们可以得知，这个接口规定了一个用于和其它类型作比较的规范，所有实现了这个接口的类，我们就可以调用其Equals方法来跟自己做比较，当前，前提是得跟泛型类型一致，下面我将通过一段代码来演示其用法：
有这样一个测试类IEquatableTest，它有个Name属性，以及显示实现了IEquatable&lt;IEquatableTest&gt;接口得Equals方法（我个人觉得，为了与继承于Object的Equals方法做区分，您应该显示实现接口，避免在调用时出现歧义）。显式实现的Equals方法里边的内容是比较两个对象的Name是否相等。
下面我们在Main方法中写代码调用一下：
控制台输出结果为：False。
和Object.Equals的关系
我们都知道，Object本身就有个Equals方法，它默认是比较一个引用，如果两个对象是同一个引用即相等，如果这个默认比较不满足，我们通过重写这个方法，也能自定义比较功能。但是这个方法接受一个Object类型的参数，存在装箱和类型安全这样的问题，因此我们也有可能需要一个性能高一些的，并且类型安全的比较方法，为了规范代码，微软推出了IEquatable泛型接口。
我们可以认为Object的Equals是IEquatable的非泛型版本方法，但是在实际应用过程中，我还是推荐大家显式实现IEquatable，有一个良好的代码规范，会让人舒心，关于显示实现接口相关介绍请查看：接口(interface)。
END
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95580e26c6016a5fb34fa897ffdfd0f5/" rel="bookmark">
			IDEA快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、构建/编译`Ctrl + F9`：构建项目`Ctrl + Shift + F9`：重新编译当前类 二、文本编辑`Ctrl + X`：剪切`Ctrl + C`：复制`Ctrl + V`：粘贴`Ctrl + Alt + Shift + V`：粘贴为纯文本`Ctrl + Shift + V`：从历史选择粘贴`Ctrl + D`：复制行`Ctrl + Shift + C`：复制文件路径`Ctrl + Alt + Shift + C`：复制引用`Ctrl + S`：保存全部`Ctrl + Z`：撤销`Ctrl + Shift + Z`：重做`Tab`：缩进`Shift + Tabl`：取消缩进`Ctrl + Alt + I`：自动缩进行`Shift + Enter`：开始新行`Ctrl + Alt + Enter`：在当前行之前开始新行`Ctrl + Y`：删除行`Ctrl + Shift + U`：大小写转换`Ctrl + Alt + Shift + Insert`：创建临时文件`Shift + F4`：在新窗口中打开 三、光标操作`Ctrl + Left`：左移一个单词`Ctrl + Right`：右移一个单词`Home`：移动至行首`End`：移动至行尾`Ctrl + Shift + M`：移动至大括号`Ctrl + [`：移动至代码块开始`Ctrl + ]`：移动至代码块末尾`Alt + Down`：下一个方法`Alt + Up`：上一个方法`Ctrl + PageUp`：移动至页面顶部`Ctrl + PageDown`：移动至页面底部`PageUp`：向上翻页`PageDown`：向下翻页`Ctrl + Home`：移动至文件开头`Ctrl + End`：移动至文件末尾 四、文本选择`Ctrl + A`：全选`Shift + Left`：向左选择`Shift + Right`：向右选择`Ctrl + Shift + Left`：向左选择一个单词`Ctrl + Shift + Right`：向右选择一个单词`Shift + Home`：向左选择至行头`Shift + End`：向右选择至行尾`Shift + Up`：向上选择`Shift + Down`：向下选择`Ctrl + Shift + [`：选择至代码块开头`Ctrl + Shift + ]`：选择至代码块结尾`Ctrl + Shift + PageUp`：选择至页面顶部`Ctrl + Shift + PageDown`：选择至页面底部`Shift + PageUp`：向上翻页选择`Shift + PageDown`：向下翻页选择`Ctrl + Shift + Home`：选择至文件开关`Ctrl + Shift + End`：选择至文件结尾`Ctrl + W`：扩展选择`Ctrl + Shift + W`：收缩选择 五、代码折叠`Ctrl + NumPad+`：展开代码块`Ctrl + NumPad-`：折叠代码块`Ctrl + Alt + NumPad+`：递归展开`Ctrl + Alt + NumPad-`：递归折叠`Ctrl + Shift + NumPad+`：全部展开`Ctrl + Shift + NumPad-`：全部折叠`Ctrl + .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95580e26c6016a5fb34fa897ffdfd0f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/154164dffcfccb7e5d7ec69cd94e267d/" rel="bookmark">
			C&#43;&#43; 面试八股文总结 -- STL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL 1 请说说 STL 的基本组成部分 参考回答
标准模板库（Standard Template Library,简称STL）简单说，就是一些常用数据结构和算法的模板的集合。
广义上讲，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。
详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。
答案解析
标准模板库STL主要由6大组成部分：容器(Container)
是一种数据结构， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。
算法（Algorithm）
是用来操作容器中的数据的模板函数。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象， 函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。
迭代器（Iterator）
提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;
仿函数（Function object）
仿函数又称之为函数对象， 其实就是重载了操作符的struct,没有什么特别的地方。
适配器（Adaptor）
简单的说就是一种接口类，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor。
空间配制器（Allocator）
为STL提供空间配置的系统。其中主要工作包括两部分：
（1）对象的创建与销毁；（2）内存的获取与释放。
2 请说说 STL 中常见的容器，并介绍一下实现原理 容器可以用于存放各种类型的数据（基本类型的变量，对象等）的数据结构，都是模板类，分为顺序容器、关联式容器、容器适配器三种类型，三种类型容器特性分别如下：
顺序容器
容器并非排序的，元素的插入位置同元素的值无关。包含vector、deque、list，具体实现原理如下：
（1）vector 头文件
动态数组。元素在内存连续存放。随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。
（2）deque 头文件
双向队列。元素在内存连续存放。随机存取任何元素都能在常数时间完成（仅次于vector）。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。
（3）list 头文件
双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。
关联式容器
元素是排序的；插入任何元素，都按相应的排序规则来确定其位置；在查找时具有非常好的性能；通常以平衡二叉树的方式实现。包含set、multiset、map、multimap，具体实现原理如下：
（1）set/multiset 头文件
set 即集合。set中不允许相同元素，multiset中允许存在相同元素。
（2）map/multimap 头文件
map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, map根据first值对元素从小到大排序，并可快速地根据first来检索元素。
注意：map同multimap的不同在于是否允许相同first值的元素。
容器适配器
封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue，具体实现原理如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/154164dffcfccb7e5d7ec69cd94e267d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2052bbc491675c004cc62afea59cae2d/" rel="bookmark">
			Kotlin 委派(ReadOnlyProperty) 仿造viewModels 写一个viewBindings
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过委派机制和Kotlin的函数扩展，仿造viewModels 写一个viewBindings功能，辅助创建ViewBinding,同时在onDestroyView的回收ViewBinding 先看下怎么使用 // 一个简陋的MVP // DemoFragment 作为P的角色 // DemoViewModel 作为M的角色 // FragmentDemoBinding 作为View的角色 // 不需要继承BaseFragmentxxx，没有泛型约束，想用就用 class DemoFragment: Fragment(R.layout.fragment_demo) { //委托创建ViewModel private val viewModels by activityViewModels&lt;DemoViewModel&gt;() //仿造 activityViewModels()方法 委托创建ViewBinding // 会在Fragment生命周期 onDestroyView的时候销毁ViewBinding private val viewBindings by viewBindings&lt;FragmentDemoBinding&gt;() override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) //可以调用viewBindings 的方法了 viewBindings... } } 看下怎么实现的。 Fragment.viewBindings&lt;ViewBinding&gt;()方法的实现 /** * 对Fragment 扩展viewBindings方法 * 懒加载创建： * 自动判断root View 已经创建了。 * 那么使用ViewBinding::bind方法 * 如果没有则使用ViewBinding::inflater方法 * * 自动销毁： * 监听生命周期onDestroyView事件， * 把ViewBinding 置为 null * 防止内存泄漏 */ @MainThread inline fun &lt;reified T : ViewBinding&gt; Fragment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2052bbc491675c004cc62afea59cae2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998406fc5e3944b4c2856617d3afd5ff/" rel="bookmark">
			记第一次面试-护网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次面试-护网 因为是第一次面试，所以在准备的过程中有些摸不着头脑，面试过程中也很紧张
和同学一块报的面试，一开始以为自己先上，没想到同学先被叫上去了，然后就稍稍有了点心理准备，也知道了大概的流程
这里记录一下我自己的面试过程
本来是想自己写的，没想到兄弟帮我都总结好了(坏笑)，我直接粘上来吧
这次面试的结果虽然是失败的，但是从中我也了解到自己的不足，也知道了面试的大概流程和需要注意的地方，算是一次不错的经历吧，另外这次的面的厂商是青藤云，出去可以吹了，婉拒青藤云(bushi)
兄弟博客的链接https://blog.csdn.net/weixin_52125240/article/details/124363757?spm=1001.2014.3001.5502
倪师傅 1.自我介绍
2.有无安全设备的使用经验
我们是在校的学生，确实也没有接触过什么安全设备。问我们在学校有没有接触过什么设备。因为是在学校的机房面试，看到我们后面是一些设备，问我后面是一些什么设备。还问我们是哪些类型的设备。
3.问了人在哪，大几，接了几针疫苗，以前有没有护过网
人在南京，大二，打了三针，没有hw经验(废话都是)
4.了解过TOP10没有
1.SQL注入
2.失效的身份认证和会话管理
3.跨站脚本攻击XSS
4.直接引用不安全的对象
5.安全配置错误
6.敏感信息泄露
7.缺少功能级的访问控制
8.跨站请求伪造CSRF
9.实验含有已知漏洞的组件
10.未验证的重定向和转发
5.用过黑客工具吗，怎么利用这些工具。比如msf怎么利用的，什么情况用msf
Metasploit(MSF)是一个免费的、可下载的框架，通过它可以很容易地获取、开发并对计算机软件漏洞实施攻击。
它本身附带数百个已知软件漏洞，是一款专业级漏洞攻击工具
MSF所用功能主要可分为这几个模块，每个模块都有各自的功能领域，形成了渗透测试的流程
1、Auxiliary(辅助模块)
为渗透测试信息搜集提供了大量的辅助模块支持
2、Exploits(攻击模块)
利用发现的安全漏洞或配置弱点对远程目标系统 进行攻击，从而获得对远程目标系统访问权的代码组件。
3、Payload(攻击载荷模块)
攻击成功后促使靶机运行的一段植入代码
4、Post (后渗透攻击模块)
收集更多信息或进一步访问被利用的目标系统
5、Encoders(编码模块)
将攻击载荷进行编码，来绕过防护软件拦截
6.了解过这些工具的特征和原理吗
这个我是真不知怎么写了，无从下手，毕竟工具那么多，叫我一下子写出全部也是不太可能的。
7.了解免杀相关的，会注入木马，指的是哪一方面的木马，什么是免杀
免杀，又叫免杀毒技术，是反病毒，反间谍的对立面，是一种能使病毒或木马免于被杀毒软件查杀的软件。它除了使病毒木马免于被查杀外，还可以扩增病毒木马的功能，改变病毒木马的行为。免杀的基本特征是破坏特征，有可能是行为特征，只要破坏了病毒与木马所固有的特征，并保证其原有功能没有改变，一次免杀就能完成了。免杀技术也并不是十恶不赦的，例如，在软件保护所用的加密产品(比如壳)中，有一些会被杀毒软件认为是木马病毒；一些安全领域中的部分安全检测产品，也会被杀毒软件误杀，这时就需要免杀技术来应对这些不稳定因素。
问是免杀的木马还是随便做一下的
8.CS是什么东西，是用来干嘛的
在这里插入图片描述
Cobalt Strike 一款以Metasploit为基础的GUI框架式渗透测试工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，exe、powershell木马生成等。
9.有没有做过应急响应方面的事情，了解过理论知识，操作过命令没有
了解一点，叫我想到什么就说什么。回答的是安全事件的分级，回答了应急响应的流程(现搜的回答的)
10.溯源相关的有没有了解过，尝试说一下
回答的时候确实是没有了解过，我说的是自己看到的反制手段
网络攻击溯源技术通过综合利用各种手段主动地追踪网络攻击发起者、定位攻击源，结合网络取证和威胁情报，有针对性地减缓或反制网络攻击，争取在造成破坏之前消除隐患，在网络安全领域具有非常重要的现实意义。
我的面经 1.自我介绍
2.问了人在哪，大几，接了几针疫苗，以前有没有护过网
人在南京，大二，打了三针，没有hw经验(废话都是)
3.有没有使用过安全设备
和倪师傅问的问题类似的，但是很遗憾没有，硬件相关的操作还是太少了
4.应急响应有没有了解过，了解流程吗
应急响应大致可以分为五个部分，其基本流程包括收集信息、判断类型、深入分析、清理处置、产出报告。
5.说一下TOP10
1.SQL注入
2.失效的身份认证和会话管理
3.跨站脚本攻击XSS
4.直接引用不安全的对象
5.安全配置错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/998406fc5e3944b4c2856617d3afd5ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9288b56c343e1e981417ccfdd2c8eaeb/" rel="bookmark">
			uni-app知识点整理（2）- 全局配置和页面配置、tabbar、condition
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、globalStyle全局外观配置
1.1 简介
1.2 简单案例练习
二、页面配置
2.1 简单案例练习
三、配置tabbar
3.1 简介
3.2 简单案例练习
四、condition
4.1 简介
4.2 简单案例练习
一、globalStyle全局外观配置 1.1 简介 通过 globalStyle 进行全局配置
官方文档：globalstyle
用于设置应用的状态栏、导航条、标题、窗口背景色等
常用的globalStyle全局配置属性 属性类型默认值描述navigationBarBackgroundColorHexColor#F7F7F7导航栏背景颜色（同状态栏背景色）navigationBarTextStyleStringwhite导航栏标题颜色及状态栏前景颜色，仅支持 black/whitenavigationBarTitleTextString导航栏标题文字内容backgroundColorHexColor#ffffff下拉显示出来的窗口的背景色backgroundTextStyleStringdark下拉 loading 的样式，仅支持 dark / lightenablePullDownRefreshBooleanfalse是否开启下拉刷新，详见uni-app官方文档：页面生命周期。onReachBottomDistanceNumber50 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见uni-app官方文档：页面生命周期
1.2 简单案例练习 导航栏标题颜色修改为：white导航栏标题修改：测试案例导航栏背景色修改：#7bbfea开启下拉刷新下拉loading样式修改：light下拉显示出来的窗口的背景色修改：#ffaa00 // pages.json { "pages": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages { "path": "pages/index/index", "style": { // "navigationBarTitleText": "uni-app" } } ], "globalStyle": { "navigationBarTextStyle": "white", // 导航栏标题颜色修改为：white "navigationBarTitleText": "测试案例", // 导航栏标题修改 "navigationBarBackgroundColor": "#7bbfea", // 导航栏背景色修改 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9288b56c343e1e981417ccfdd2c8eaeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50fe21122a523f7cc0e9cf23a48d83e0/" rel="bookmark">
			（九）神经网络-搭建小实战和Sequential的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【声明】来源b站视频小土堆PyTorch深度学习快速入门教程（绝对通俗易懂！）【小土堆】_哔哩哔哩_bilibili
CIFAR10 model结构 import torch import torch.nn as nn from torch.nn import Conv2d, MaxPool2d, Flatten, Linear class MyModel(nn.Module): def __init__(self): super(MyModel, self).__init__() self.conv1 = Conv2d(3, 32, 5, padding=2) self.maxpool1 = MaxPool2d(2) self.conv2 = Conv2d(32, 32, 5, padding=2) self.maxpool2 = MaxPool2d(2) self.conv3 = Conv2d(32, 64, 5, padding=2) self.maxpool3 = MaxPool2d(2) self.flatten = Flatten() self.linear1 = Linear(1024,64) self.linear2 = Linear(64, 10) def forward(self,x): x= self.conv1(x) x = self.maxpool1(x) x = self.conv2(x) x = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50fe21122a523f7cc0e9cf23a48d83e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911905257bc74fb8ddb3e91af47742da/" rel="bookmark">
			1 hour docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 hour docker 是什么 Docker 是一个应用打包、分发、部署的工具。
你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。
打包、分发、部署 打包：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包
分发：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装
部署：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows/Mac/Linux。
Docker 部署的优势 常规应用开发部署方式：自己在 Windows 上开发、测试 --&gt; 到 Linux 服务器配置运行环境部署。
问题：我机器上跑都没问题，怎么到服务器就各种问题了
用 Docker 开发部署流程：自己在 Windows 上开发、测试 --&gt; 打包为 Docker 镜像（可以理解为软件安装包） --&gt; 各种服务器上只需要一个命令部署好
优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。
Docker 通常用来做什么 应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用快速安装测试/学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0Windows 上体验/学习各种 Linux 系统 重要概念：镜像、容器 镜像：可以理解为软件安装包，可以方便的进行传播和安装。
容器：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。
命令 docker run docker run [OPTIONS] IMAGE [COMMAND] [ARG...] options --detach , -d: 在后台运行容器并打印容器ID --publish , -p: 将容器的端口发布到主机（建立端口映射关系） --name: 为容器分配名称 --volume , -v: 绑定挂载卷（宿主机路径:容器路径） --network: 将容器连接到网络 --network-alias: 为容器添加网络范围的别名 实例 安装redis docker run -d -p 6379:6379 --name redis redis:latest 安装wordpress 新建文件docker-compose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911905257bc74fb8ddb3e91af47742da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ebf6da1d92866179f83dc0432fbe07/" rel="bookmark">
			时序模型：循环神经网络（RNN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 模型定义 循环神经网络（recurrent neural network, RNN）是一类专门设计处理不定长序列数据的神经网络。
与使用一种新计算1作为核心的卷积神经网络不同，循环神经网络仍使用特征的线性组合作为计算核心，并使用共享参数策略使模型能泛化不同长度的序列数据。
2. 循环神经网络的由来：从全连接神经网络（DNN）到循环神经网络（RNN） 2.1 全连接神经网络的不足 最初，研究者直接将时间序列看作特征向量，将序列每一时刻的观测作为一种特征输入全连接神经网络，来预测序列的标签。其Vanilla模型2 的结构如下图所示：
图1 前馈神经网络 { 输 入 层 : X = ( x 1 , x 2 , … , x n ) , X ∈ R n × d , x i ∈ R 1 × d 隐 藏 层 : Z = ϕ z ( X W x z + b z ) , W x z ∈ R d × h , b z ∈ R 输 出 层 : Y ^ = ϕ y ( X W z y + b y ) , W z y ∈ R h × q , b y ∈ R (2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6ebf6da1d92866179f83dc0432fbe07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23bdce87311a77a1ea78ac83cc18d0f/" rel="bookmark">
			【TCP/IP协议】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP/IP协议 文章目录 TCP/IP协议1. 应用层2. 传输层2.1 UDP协议2.2 TCP协议 3. 网络层3.1 地址管理3.2 路由选择 4. 数据链路层ARP协议 1. 应用层 应用层是我们作为程序猿最经常打交道的。在写代码的时候会有两方面：
使用现成的应用层协议，最常见的就是http自己约定一个应用层协议 对于第二点，我们实现一个简单的网络计算器。
自定义协议 请求格式为：num1;num2;operator(操作数1，操作数2 ，操作符)
客户端要求用户输入两个参与运算的整数，再输入一个要进行运算的方式(+ - * /)，客户端将这些信息发送给服务器，服务器将计算的结果返回给客户端。自定义协议具体的协议方式有很多种，这里我们使用最简单粗暴的方式(文本+分隔符)
服务器代码
public class CalcServer { private DatagramSocket socket = null; public CalcServer(int port) throws SocketException { this.socket = new DatagramSocket(port); } public void start() throws IOException { System.out.println("服务器启动"); while (true) { DatagramPacket requestPacket = new DatagramPacket(new byte[4096], 4096); socket.receive(requestPacket); String request = new String(requestPacket.getData(), 0, requestPacket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c23bdce87311a77a1ea78ac83cc18d0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ba4fcdda9b30065cd3688886867a7c/" rel="bookmark">
			文本生成：Transformer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 模型原理 Transformer是一种基于全连接神经网络的编码器-解码器（encoder-decoder）架构实现，它由输入模块、编码器模块、解码器模型和输出模型四部分组成。其结构如下图所示：
图1 Transformer模型 关于Transformer的基础知识介绍，网上已有许多公开的资料。读者可自行查阅学习。本文默认大家已具备Transformer相关的基础知识，文本将讨论其中值得注意的四个问题：
Transformer中有几种mask机制，它们是如何去除小批量样本padding操作引入的噪声的？自注意力机制为什么不直接使用输入的特征向量，而要使用其线性变换的结果来计算自注意力？什么是layer normal，为使用它而不使用batch normal？绝对位置编码和相对位置编码 1.1 Transformer中的mask机制 Transformer中有三种不同的mask机制：inputs padding mask、look ahead mask和outputs padding mask。
其中，inputs padding mask用于编码器和解码器中的Multi-Head Attention计算，通过与注意力得分矩阵元素对位相乘，使注意力全部集中于输入序列中有效位置的元素，从而消除输入序列padding值引入的噪声干扰。
look ahead mask用于解码器中Mask Multi-Head Attention计算，它在负责消除标签序列padding值引入的噪声干扰的同时，也是将文本生成循环能转为批量进行的保障：它在输入全量的标签序列时，利用mask矩阵实现仅预测时刻之前的部分序列被解码器端可见的效果；outputs padding mask用于动态损失函数计算，负责消除残差结构直连项，绕开Self-Attention层引入的标签序列padding值噪声干扰。所以look ahead mask与outputs padding mask共同作用，彻底消除了标签序列padding值引入的噪声干扰。
1.2 Self-Attention中输入特征向量线性变换的必要性 若不使用线性变换，则每个 token 对应的q，k，v向量都是一样的，那么此 token 对所有 token 所计算出的注意力分布中就只会集中于自己身上，对其他 token 的注意力会非常小。自注意力（Self-Attention）的作用就是筛选出其他 token 中有助于完成任务的特征信息，如果注意力分布不能关注到其他 token 的话，自注意力机制的作用也就丧失了。所以，自注意力机制需要使用输入特征向量的线性变换进行计算。
1.3 Layer Normalizationv.s. Batch Normalization layer normalization 和 batch normalization 都是样本归一化方法，即：每一条样本都经过(x-mean) / std。
它们的区别在于归一化计算所使用的均值（mean）和方差（std）不同，如下图所示：
图2 LN与BN中均值、方差的计算方法 其中batch normalization更适合处理图像数据的归一化问题，而layer normalization更适合处理序列数据的归一化问题。
1.4 位置编码 位置编码有两种方法：functional encoding和parametric encoding。其中，functional encoding：这个是指的是通过特定函数的方式，将输入的位置idx变换为embedding。而，parametric encoding：指的是通过embedding lookup的方式，让模型自己学习位置的embedding。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82ba4fcdda9b30065cd3688886867a7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/837edbebaa81bff55036bc0906d321f0/" rel="bookmark">
			解决 Error creating bean with name ‘dataSource‘ defined in class path resource 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如下：
java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:132) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:124) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:190) at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:132) at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:248) at org.springframework.test.context.junit.jupiter.SpringExtension.postProcessTestInstance(SpringExtension.java:138) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$8(ClassBasedTestDescriptor.java:363) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.executeAndMaskThrowable(ClassBasedTestDescriptor.java:368) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$invokeTestInstancePostProcessors$9(ClassBasedTestDescriptor.java:363) at java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:193) at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1384) at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:482) at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:472) at java.util.stream.StreamSpliterators$WrappingSpliterator.forEachRemaining(StreamSpliterators.java:313) at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:743) at java.util.stream.Streams$ConcatSpliterator.forEachRemaining(Streams.java:742) at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:647) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeTestInstancePostProcessors(ClassBasedTestDescriptor.java:362) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$instantiateAndPostProcessTestInstance$6(ClassBasedTestDescriptor.java:283) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateAndPostProcessTestInstance(ClassBasedTestDescriptor.java:282) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$4(ClassBasedTestDescriptor.java:272) at java.util.Optional.orElseGet(Optional.java:267) at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$5(ClassBasedTestDescriptor.java:271) at org.junit.jupiter.engine.execution.TestInstancesProvider.getTestInstances(TestInstancesProvider.java:31) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$prepare$0(TestMethodTestDescriptor.java:102) at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:101) at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:66) at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$2(NodeTestTask.java:123) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/837edbebaa81bff55036bc0906d321f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc7faeb40515c20bf6d13150965a308/" rel="bookmark">
			使用Java对Markdown与Html内容进行互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Java对Markdown与Html内容进行互转 一、Markdown转Html1.pom.xml引入2.测试类MarkdownToHtmlUtils.java 二、Html转Markdown1.maven的pom.xml引入如下2.测试类HtmlToMarkdownUtils.java 一、Markdown转Html 1.pom.xml引入 &lt;!--引入Markdown转HTML的插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atlassian.commonmark&lt;/groupId&gt; &lt;artifactId&gt;commonmark&lt;/artifactId&gt; &lt;version&gt;0.17.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--扩展 标题--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atlassian.commonmark&lt;/groupId&gt; &lt;artifactId&gt;commonmark-ext-heading-anchor&lt;/artifactId&gt; &lt;version&gt;0.17.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--扩展 表格--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atlassian.commonmark&lt;/groupId&gt; &lt;artifactId&gt;commonmark-ext-gfm-tables&lt;/artifactId&gt; &lt;version&gt;0.17.0&lt;/version&gt; &lt;/dependency&gt; 2.测试类MarkdownToHtmlUtils.java import java.io.IOException; import java.util.Collections; import java.util.List; import java.util.Map; import java.util.Set; import org.commonmark.Extension; import org.commonmark.ext.gfm.tables.TableBlock; import org.commonmark.ext.gfm.tables.TablesExtension; import org.commonmark.ext.heading.anchor.HeadingAnchorExtension; import org.commonmark.node.Link; import org.commonmark.node.Node; import org.commonmark.parser.Parser; import org.commonmark.renderer.html.AttributeProvider; import org.commonmark.renderer.html.AttributeProviderContext; import org.commonmark.renderer.html.AttributeProviderFactory; import org.commonmark.renderer.html.HtmlRenderer; /** */ public class MarkdownToHtmlUtils { /** * markdown格式转换成HTML格式 * @param markdown * @return */ public static String markdownToHtml(String markdown) { Parser parser = Parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bc7faeb40515c20bf6d13150965a308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1d88829b1e25ca186709776c60d37c/" rel="bookmark">
			【操作系统】CPU调度算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Modern Operating System》、《Operating Systems：Three easy pieces》阅读笔记
1 作业周转时间【turnaround time】？ 周转时间 = 完成时间 − 到达时间
也就是，每个进程从提出要求到完成的时间
2 先来先服务【FCFS】算法？ 按照进程就绪的先后顺序来使用CPU
优点：实现简单，公平
缺点：在长进程后面的短进程需要等待很长的时间，不利于用户体验
三个进程A,B,C同时到达
服务的先后顺序是A-&gt;B-&gt;C，那么
周转时间的计算为：
A：T = 100 - 0 = 100
B：T = 110 - 0 = 110
C：T = 120 - 0 = 120
则，平均周转时间 = （100 + 110 + 120）/ 3 = 110
3 短作业优先【SJF】算法？ 若运行时间可预知，那么运行时间最短的进程优先，非抢占式
优点：最短的平均周转时间
缺点：长进程可能会因为源源不断的短进程而饥饿
但是我们再来看另外一个例子：
A在 t = 0的时候到达，需要100s
而B、C在 t = 10的时候到达，各需要10s的执行时间
SJF的第一个例子的平均周转时间为50，而这里却上升到了103.33
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1d88829b1e25ca186709776c60d37c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/053e13e941ad0e7caa688bf20292c81c/" rel="bookmark">
			Mysql面试篇(二)InnoDB vs MyISAM &amp; 索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3. InnoDB vs MyISAM 😀InnoDB 索引分为聚簇索引与二级索引
聚簇索引：主键值作为索引数据，叶子节点还包含了所有字段数据，索引和数据是存储在一起的
二级索引：除主键外的其它字段建立的索引称为二级索引。被索引的字段值作为索引数据，叶子节点还包含了主键值
支持事务
通过 undo log 支持事务回滚、当前读（多版本查询）
通过 redo log 实现持久性
通过两阶段提交实现一致性
通过当前读、锁实现隔离性
支持行锁、间隙锁
支持外键
😀MyISAM 索引只有一种
被索引字段值作为索引数据，叶子节点还包含了该记录数据页地址，数据和索引是分开存储的
不支持事务，没有 undo log 和 redo log
仅支持表锁
不支持外键
会保存表的总行数
InnoDB 索引特点
聚簇索引：主键值作为索引数据，叶子节点还包含了所有字段数据，索引和数据是存储在一起的 ◉主键即 7369、7499、7521 等
二级索引：除主键外的其它字段建立的索引称为二级索引。被索引的字段值作为索引数据，叶子节点还包含了主键值
上图中 800、950、1100 这些是工资字段的值，根据它们建立了二级索引
上图中，如果执行查询 select empno, ename, sal from emp where sal = 800，这时候可以利用二级索引定位到 800 这个工资，同时还能知道主键值 7369
但 select 字句中还出现了 ename 字段，在二级索引中不存在，因此需要根据主键值 7369 查询聚簇索引来获取 ename 的信息，这个过程俗称回表
MyISAM 索引特点
被索引字段值作为索引数据，叶子节点还包含了该记录数据页地址，数据和索引是分开存储的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/053e13e941ad0e7caa688bf20292c81c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02e0f3d0f1b0faa6c37b2e22aca66abe/" rel="bookmark">
			sql中的substr()函数用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言：
五一闲来无事多更新几篇关于sql语句的文章吧，sql中要是想截取某个字段值作为匹配条件怎么办呢，这里可以使用substr()函数了。下面请看例子吧。
substr()函数
substr()函数用于截取对应字段指定长度。
SUBSTR(string ,pos,len) string:指定字符串 pos:规定字符串从何处开始，（这里的第一个位置是1而不是0）为正数时则从字段开始出开始，为负数则从结尾出开始。 len:要截取字符串的长度。（是从1开始计数而不是0） 示例：
现在我们举个例子，现在想通过时间字段得到每个小时15min/30min/45min/00min的数据，时间字段data_date(YYYY-MM-DD HH:mm) select * from meter_table where substr(data_date,15,2) in ('00','15','30','45') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0420dafc18637b7c4aae3ca293480d66/" rel="bookmark">
			思考，我为什么要用node.js搭建这个后端服务并且为什么用mongodb这个数据库？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：Node.js是什么？做服务端开发的
他是一个运行环境，他的目的就是让js可以和其他后端语言一样在服务器上运行
知道node之前我们需要先了解一下v8引擎
JavaScript是一门高级语言，计算机并不能直接读懂。所以我们需要所谓的引擎来将其转化成计算机所能理解的语言。v8引擎随着js的性能的提升，给开发着提供了便利
我通常说用node去搭建web服务端，那么我为什么要使用他去搭建web服务端？
我们在用浏览器访问服务器的时候，要是不想这个浏览器什么事都自己干，就交给这个服务器，那服务器一下子就会服务很多的浏览器，就不能死板的操作，那就进行同时开始几件事，哪件事情完事就关闭哪一件。总结-高效
Node.js是服务器的技术。我们都知道客户端提出服务请求，而服务器端负责处理请求并提供服务。而对于互联网来说，在Node.js之前JavaScript是一项完全的客户端技术，被用于浏览器中实现各种动画，对DOM的操作等等。而后端，服务端则是由PHP、Python、Ruby、Java等语言来实现。Node.js的出现，让前后端实现统一。
所以在这个项目中我通过node环境和express框架来搭建了web服务端。
二：我为什么要用mongodb这个数据库？
mongdb的优势就是文档储存
我们创建这个学员系统，需要是不是的加入字段，用mongdb和其他关系型的数据库相比，他更加的轻巧灵活，适合在规模性不大，事务性不强的场合下使用。他将数据储存一个文档，并且一个mongdb可以建立多个数据库（独立的）。
那么为什么通过mongoose连接数据库？
需要在程序层面来实现相应的业务以Mongodb为代表。
mongoose是mongoDB的一个对象模型工具，是基于node-mongodb-native开发的mongoDB的nodejs驱动，可以在异步的环境下执行。同时它也是针对mongoDB操作的一个对象模型库，封装了mongoDB对文档的一些增删改查等常用方法，让nodejs操作mongoDB数据库变得更加容易。
·安装mongoose
npm install mongoose
·引用mongoose
const mongoose = require('mongoose')
·使用mongoose连接数据库
mongoose.connect("mongodb://localhost/b0344sms-pro",{useNewUrlParser:true}).then(()=&gt;{
console.log("连接数据库成功");
app.listen("3002",()=&gt;{
console.log("服务器启动了。。。");
})
}).catch(error=&gt;{
console.log("连接数据库失败",error);
})
除了mongdb还有Oracle（关系型数据库管理系统，要求较高、数据规模大等应用场景）、
MySQL 是当下最流行的关系型数据
Redis（Redis是K-V型数据库的典型代表）
等大众熟知的数据库。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd36ae9d0e9983364a1b343824a4178/" rel="bookmark">
			UTM坐标转WGS84 EPSG设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先根据下面的图找到目标地区的编号，中国东部地区属于UTM Zone 50N
DMAP: UTM Grid Zones of the World
查找UTM 50N 的 EPSG 执行标准 Coordinate reference systems for "UTM zone 50N"
WGS 84 / UTM zone 50N
EPSG:32650
&gt;&gt;&gt; from pyproj import Proj,transform &gt;&gt;&gt; WGS84 = Proj(init='EPSG:4326') &gt;&gt;&gt; p = Proj(init="EPSG:32650") &gt;&gt;&gt; x,y = 526434.351935, 3522210.609046 &gt;&gt;&gt; transform(p, WGS84, x, y) (117.27936202563953, 31.835267862875163 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ac0ca608edaa736af7905de7ae4bd7/" rel="bookmark">
			京东零售数仓：从离线、实时到流批一体的演进之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一阶段
21世纪的第一个10年，企业级数据仓库从萌芽到发展，“IOTteradata” 占据了大部分市场，提供数据仓库建设从硬件、软件到实施的整体方案。
第二阶段
2010年-2020年，大数据平台阶段，移动互联网的飞速发展，带动大数据的发展，其中Hadoop生态技术开始大规模使用，基于Hadoop 分布式计算框架，使用相对廉价的PC服务器就能搭建大数据集群。
第三阶段
就是我们当前所处的阶段，经过前10年不断的积累，大数据在方法和组织的变革上也有了新的沉淀，主要体现在：
1）数据资产化
通过数据地图与数据血缘实现360°数据全链路追踪。
2）数据服务化
提供标准的数据服务，支持数据产品的灵活调用。
3）工具组件化
数据在采、存、算过程中涉及多业务线条、多场景，将这些场景与工具进行组件化沉淀，避免重复建设。
4）数据智能化
通过人工智能实现大数据的智能化应用。
在行业中，数据中台有非常多的开源技术可供选择，尤其是Hadoop生态圈，从数据整体流向来看各大层级的选型：
传输层
原始数据的抽取，Scribe和Flume作为非结构化日志接入，DataX作为结构化数据离线抽取，Kafka作为流式数据总线。
存储层
Hadoop文件系统HDFS，Alluxio基于内存的分布式文件系统。
计算层
离线计算主要是Hive、Spark、MR：多维分析引擎一般基于现有Clickhouse、Doris和ES：实时计算前些年Storm、Spark Streaming比较流行，现在基本都转到Flink。
调度
基于Airflow、Oozie或者开源的Dolphin-scheduler。
平台层
包括数据开发的基本运行环境和各类工具的组合，如ETL工具，模型设计工具，脚本开发工具，线上日志工具等等。
服务层
主要将公共数仓的公共模型数据对外包装并提供服务，包括数据服务平台，多维分析平台，即席查询平台。
应用层
基于数据服务的数据产品，另外数据安全、数据质量和数据治理总是贯穿始终。
二、京东零售大数据的发展过程
1、发展阶段
京东零售大数据发展的几个阶段如下：
1）第一阶段
业务驱动数据技术发展，业务野蛮生长，以解决业务痛点为核心，导致烟囱式诞生了一些小数据平台。
2）第二阶段
业务精细化运营，数据平台将多业务线条、多场景的能力进行沉淀，形成数据资产。
3）第三阶段
数据中台化建设已完成，数据驱动业务，通过数据挖掘、分析和人工智能，规模化的赋能业务，经过3个阶段的发展，百家争鸣的数据平台也逐步过渡到百花齐放的数据中台。
2、业务场景
京东有最全的线上零售全链路业务场景：
始于用户，平台提供订单、营销、流量场、财务结算、供应链及商品管理，后端有仓储和配送。
基于整个零售业务，构建全域的数据资产体系，使业务数据化，数据业务化，沉淀业务模型资产，反哺于业务。
3、面临的挑战
数仓建设过程中面临如下挑战：
烟囱式的开发，各自顾各自的业务，模型重复建设，口径不统一，给业务造成困扰也浪费了资源；
数据爆炸式的增长，硬件成本增长的边际效应越来越低；
海量数据，如何评估数据的价值，如何治理海量数据；
业务复杂度高，全渠道多业态带来的数据拓展的新挑战；
实时数据需求多，实时开发门槛高周期长；
数据时效性保障，数据指数级增长，但是时效不能增长。
4、核心需求
解决以上的挑战，我们需要有以下4个维度构建数仓核心能力：
1）数仓架构
从烟囱式的数据开发到统一的数仓分层架构，将烟囱式的通用数据模型层按职责重新划分为:维度层、基础数据层和公共数据层。
维度层
用户来分析数据的窗口，维度表中包含事实表中记录的特性。
基础数据层
数仓的核心层，负责统一的数据清洗、整合，实现各主题模型标准化，屏蔽业务系统干扰，保障基础数据的高可用。
公共数据层
数仓中使用率最高的：
-D：统一口径封装，提供各主题统一维度和指标的明细数据；
-S：统一口径封装，提供各主题统一维度和指标的聚合数据。
2）数据建模
提供统一的数据建模方法论和工具，规范建模过程，统一维度和指标管理。
数仓建模分两类视角，包括业务域视角和主题视角；
数据业务域根据零售的具体业务进行划分，层次和分类相对灵活，数据主题也就是咱们经常提到的数仓主题，如商品、流量、交易、用户等等；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ac0ca608edaa736af7905de7ae4bd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d09cd517cef6df468d8a3ac8a67f867a/" rel="bookmark">
			什么是量子计算机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		What is a quantum computer? Let’s talk a bit about what actually makes up a quantum computer. To facilitate this discussion, let’s briefly talk about what the term computer means.
DEFINITION
A computer is a device that takes data as input and does some sort of operations on that data.
There are many examples of what we have called a computer; see figure 1.1 for some examples.
Figure 1.1 Several examples of different kinds of computers, including the UNIVAC mainframe operated by Rear Admiral Hopper, a room of “human computers” working to solve flight calculations, a mechanical calculator, and a LEGO-based Turing machine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d09cd517cef6df468d8a3ac8a67f867a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5084b8279f0acfb029a6c430971c89f/" rel="bookmark">
			Java中如何判断文件或文件夹是否存在(File.exists)呢?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下文笔者讲述检测文件或文件夹是否存在的方法分享，如下所示:
实现思路： 使用file.exists()方法即可检测file对象是否为一个有效的路径或文件夹 exists语法: public boolean exists() 返回值说明 true:文件或文件夹已经存在 false:此路径不表示文件也不表示文件夹 异常说明 抛出SecurityException：SecurityManager.checkRead(String)时 则说明拒绝对目录的读取访问 public static void main(String[] args) throws Exception { //判断文件是否存在如果存在就删除，不存在就新建 String path = "D:\\java265.txt"; String filename = "testfile.txt"; File file = new File(path, filename); //判断文件或文件夹是否存在 boolean flag = file.exists(); if(flag) { //文件存在就要删除文件 file.delete(); } else { //文件不存在就要新建文件 file.createNewFile(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c49e7b9e3f47b33edc05ce8e58863ed/" rel="bookmark">
			Ubuntu配置Intel oneAPI DPC&#43;&#43;/C&#43;&#43; Compiler(icpc/icc)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu配置Intel oneAPI DPC++/C++ Compiler(icpc/icc) 首先从Intel的官方下载
https://www.intel.com/content/www/us/en/developer/articles/tool/oneapi-standalone-components.html#dpcpp-cpp
根据自己的OS选择即可，文件名后面带星号的为online在线安装的版本（相当于只是个下载器），这里我选择了offline即离线版本
下载完成后执行上一步下载的.sh文件，具体文件名根据你当时下到的版本改动一下，之后一路默认配置一直点next即可 sudo ./l_dpcpp-cpp-compiler_p_2022.0.2.84_offline.sh 完成安装后进入安装目录，这里根据你当前使用的用户可能安装路径有区别（如果未指定路径）
如果是sudo用户执行的，则目录应该在./opt/intel/oneapi，而如果是普通用户则应该是在$HOME/intel/oneapi下进入上述目录后，我们可以看到有一个名为setvars.sh的脚本，这是自动配置环境的，执行source setvars.sh intel64命令，需要注意的是如果你之后重启机器了需要再次执行该命令，网上也有如何解决source命令配置的环境如何做到写入profile一样永久效果的文章，不再赘述。如果你的机器是32位的，则后面的intel64参数可以修改为ia32最后用一次测试用例看看是否配置成功 #include &lt;CL/sycl.hpp&gt; int main() { // Creating SYCL queue cl::sycl::queue Queue; // Creating buffer of 4 ints cl::sycl::buffer&lt;cl::sycl::cl_int, 1&gt; Buffer(4); // Size of index space for kernel cl::sycl::range&lt;1&gt; NumOfWorkItems{Buffer.get_count()}; // Submitting command group to queue Queue.submit([&amp;](cl::sycl::handler &amp;cgh) { // Getting write only access to the buffer on a device auto Accessor = Buffer.get_access&lt;cl::sycl::access::mode::write&gt;(cgh); // Executing kernel cgh.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c49e7b9e3f47b33edc05ce8e58863ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4963a4a1e652abcd393a8f561a3c2248/" rel="bookmark">
			Anolis OS 7.9安装docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Anolis OS 7.9与docker简介 1、Anolis OS 7.9官方首页:龙蜥社区https://openanolis.cn/ 龙蜥操作系统(Anolis OS) 7 是龙蜥社区(OpenAnolis)发行的开源Linux发行版，与CentOS 7 100%兼容，
支持多计算架构，提供稳定、高性能、安全、可靠的操作系统。
龙蜥操作系统(Anolis OS) 7.9是继龙蜥操作系统(Anolis OS) 7系列后发布的第二个版本，
支持x86_64和aarch64架构，搭载双内核RHCK（RHEL Compatible Kernel）和 ANCK（OpenAnolis Cloud Kernel），
其中ANCK是由社区Cloud Kernel SIG组基于上游4.19 LTS kernel研发，提供对稳定，性能，隔离能力的增强，
和飞腾、海光、兆芯、鲲鹏芯片的完善支持。
2、docker官方首页:https://www.docker.com/ Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、 bare metal、OpenStack 集群和其他的基础应用平台。
二、安装 1、环境 AnolisOS7.9系统，并且当前操作用户已经切换为root用户。
2、安装 执行安装命令
yum -y install docker 系统将会自动下载安装docker以及相关依赖，直到控制台提示完毕！，即表示安装成功。
查看docker版本
docker version 结果如下所示，下面提示无法连接守护进程是因为目前docker服务还未启动。
[root@localhost ~]# docker version Client: Version: 1.13.1 API version: 1.26 Package version: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4963a4a1e652abcd393a8f561a3c2248/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813f6080738b3342b8aaf46783c1c155/" rel="bookmark">
			gVisor使用探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、gVisor引入背景二、gVisor简介1.架构图2.gVisor组件简介 三、使用1.安装2.配置3.go get方式安装4.作为docker runtime使用 前言 容器虽然带来了高效快捷的虚拟化，但是由于共用内核，容器的安全性也是最受关注的。gVisor是google引入的一套全新的容器安全解决方案，重新实现容器进程的每一个系统调用，其性能相比runc等下降了不少。本文主要介绍gVisor的基本概念及使用。
提示：以下是本篇文章正文内容，下面案例可供参考
一、gVisor引入背景 容器主要使用Linux kernel提供的name space和cgroup机制进行了访问控制及资源隔离，相比裸金属方式的虚拟化，由于容器共用hostos kernel，其性能获得较大提升，但是共享kernel带来的最大问题就是安全性无法获得保障。google引入了gVisor，其在name space和cgroup隔离的基础上添加了一层防护，旨在提供进程级的轻量虚拟化。
二、gVisor简介 1.架构图 gVisor提供了两种方式对容器进程的系统调用进行了拦截实现，它包含以下几个进程：
2.gVisor组件简介 1. runsc: 遵循OCI(Open Container Initiative)标准的容器runtime，它可以在docker或者kubernetes中使用。
2. Sentry:gVisor中最大的组件，可以将它视为“用户态内核”，Sentry实现了应用程序所需的所有内核功能，包括：系统调用、信号传递、内存管理和页面错误逻辑、线程模型等等。
3. Gofer：Gofer是一个标准主机进程，由每个容器启动，并通过套接字或共享内存通道通过9P协议与Sentry进行通讯。Sentry进程在受限制的seccomp容器中启动，无法访问文件系统资源。Gofer协调所有对这些资源的访问，提供额外的隔离级别。
4. Application: OCI运行时bundle中的普通Linux二进制文件，gVisior旨在提供一个与Linux v4.4相同的运行环境，因此应用程序应该能够无修改运行，gVisor目前没有实现每个系统调用，/proc、/sys文件系统也没有实现。
三、使用 1.安装 官方安装脚本:
( set -e ARCH=$(uname -m) URL=https://storage.googleapis.com/gvisor/releases/release/latest/${ARCH} wget ${URL}/runsc ${URL}/runsc.sha512 \ ${URL}/containerd-shim-runsc-v1 ${URL}/containerd-shim-runsc-v1.sha512 sha512sum -c runsc.sha512 \ -c containerd-shim-runsc-v1.sha512 rm -f *.sha512 chmod a+rx runsc containerd-shim-runsc-v1 sudo mv runsc containerd-shim-runsc-v1 /usr/local/bin ) 安装gVisor作为docker的runtime，使用如下命令:
/usr/local/bin/runsc install sudo systemctl reload docker docker run --rm --runtime=runsc hello-world 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/813f6080738b3342b8aaf46783c1c155/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/999d96a5696ff5be9fd5dfc49543223a/" rel="bookmark">
			PHPExcel 读取百万级、千万级Excel文件数据的方法，按每行读取数据，使用yield生成器技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、先将百万级别的excel 数据按每行读取，每读取一行记录一条，将其存储在yield生成器中，不占用内存，读一条取一条。
public static function actionExcelData() { set_time_limit(0); ini_set("memory_limit", "1024M"); $excelInfo['path'] = '/file/456.xlsx'; $inputFileType = IOFactory::identify($excelInfo['path']); $objReader = IOFactory::createReader($inputFileType); $worksheetNames = $objReader-&gt;listWorksheetNames($excelInfo['path']); #只读取表格数据，忽略里面的各种格式,否则会内存耗尽 $objReader-&gt;setReadDataOnly(TRUE); $objReader-&gt;setLoadSheetsOnly($worksheetNames[0]);#笔者此处加载第11个sheet $objPHPExcels = $objReader-&gt;load($excelInfo['path']); $maxCol = $objPHPExcels-&gt;getSheet(0)-&gt;getHighestColumn();#总列数 $maxCol = 'I'; $maxRow = $objPHPExcels-&gt;getSheet(0)-&gt;getHighestRow();#总行数 $a = 'A'; for ($i = 1; $i &lt;= $maxRow; $i++) { yield $objPHPExcels-&gt;getSheet(0)-&gt;rangeToArray('A' . $i . ':' . $maxCol . $i)[0];#读取一行 $a++; } } 2、遍历方法：
$titleExcels = self::getExcelTitle();#可以把$titleExcels 当做一个千万级别的数组，按每行的值作为数组的一个value。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9a2f0908d8120e9eaefc8beeaad38e/" rel="bookmark">
			OTSU大津法分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不带掩膜 C语言实现： int otsuThreshold(Mat &amp;frame) { const int GrayScale = 256; int width = frame-&gt;width; int height = frame-&gt;height; int pixelCount[GrayScale]; float pixelPro[GrayScale]; int i, j, pixelSum = width * height, threshold = 0; uchar* data = (uchar*)frame-&gt;imageData; //指向像素数据的指针 for (i = 0; i &lt; GrayScale; i++) { pixelCount[i] = 0; pixelPro[i] = 0; } //统计灰度级中每个像素在整幅图像中的个数 for (i = 0; i &lt; height; i++) { for (j = 0; j &lt; width; j++) { pixelCount[(int)data[i * width + j]]++; //将像素值作为计数数组的下标 } } //计算每个像素在整幅图像中的比例 float maxPro = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa9a2f0908d8120e9eaefc8beeaad38e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/127c3499ba5abe4ddaeacfc48f0f532f/" rel="bookmark">
			微信小程序 uni.uploadFile/wx.uploadFile一次性上传多个文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答案是无法实现。
原因：
uni.uploadFile的多文件仅在App和H5上支持，用在微信小程序不支持。
uniapp的官方文档
wx.uploadFile也一样：
微信的官方文档
解决方案：
需要后端调整接口，把上传文件的接口剥离出来。
第一步，实现独立上传文件并返回文件储存地址的接口
第二步，多次调用上传文件的接口得到文件储存地址/存储标识后合并到实际需要提交的表单数据中再提交即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774f8add18f8d3b5a4eed2f93f19fba3/" rel="bookmark">
			Java——商城后台（2.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书写规范：缩进 命名 注释 封装 1.、类别--查询列表--数据访问层 关于查询类别的列表，需要执行的SQL语句大致是：
select * from pms_category order by sort, id desc 为了封装查询列表时各类别数据，（只保证有用的数据 ，保证数据传输时节省流量，万一旧VO更改 会更加麻烦）应该在csmall-pojo的vo包中创建CategoryListItemVO类，
在类中添加最有必要性的属性：
@Data public class CategoryListItemVO implements Serializable { private Long id; private String name; private Long parentId; private Integer depth; private String icon; private Integer enable; private Integer display; } 在CategoryMapper.java接口中添加抽象方法：
/** * 查询类别的列表 * * @return 类别的列表，如果数据表中无数据，则返回长度为0的列表 */ List&lt;CategoryListItemVO&gt; list(); 在CategoryMapper.xml中配置SQL语句：
&lt;!-- List&lt;CategoryListItemVO&gt; list(); --&gt; &lt;select id="list" resultMap="ListResultMap"&gt; select &lt;include refid="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/774f8add18f8d3b5a4eed2f93f19fba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5adf8dd223627599223ea74c63094b6c/" rel="bookmark">
			leetCode_242. 有效的字母异位词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetCode_242. 有效的字母异位词 一、题目描述 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
示例 1: 输入: s = "anagram", t = "nagaram" 输出: true 示例 2: 输入: s = "rat", t = "car" 输出: false 二、思路 ① 将输入的s和t转化为char数组储存
② 对char数组进行排序
③ 判断排序后的两个数组是否相等
三、具体实现 class Solution { public boolean isAnagram(String s, String t) { if (s.length()!=t.length()){ return false; } char[] arr1 = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5adf8dd223627599223ea74c63094b6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d837a24fda1edddd90aa1c6b54f4e14/" rel="bookmark">
			pycharm专业版 配置pytest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 我是使用python的一个轻量框架flask，如果有跟我一样是用flask的xd不知道怎么测试的话，强烈建议flask官方文档，不用到处找教程了，看一看官方文档，就知道怎么搞了
配置 我用的是pycharm专业版，默认的测试模块是unittests，所以我们在设置里面修改一下，参考这个文章
点击那个扳手的图标，或者右上角运行图标旁边的，编辑配置都可以，然后在additional arguments这里添加想要添加的参数
我最后的配置是
--html=report.html --self-contained-html
--cov=C:/Users/cgy/Desktop/NewWaiMai --cov-report=html
第一个是pytest-html插件，这个会生成一个html报告，–self-contained-html是让他只生成一个html文件
第二个是pytest-cov，是测定覆盖率的插件，也会生成报告，但是是一个文件夹，里面的index.html就是覆盖率的报告了
这是两个插件相关的的文章
pytest-html
pytest-cov
pytest-html的报告没有allure的好看，所以可以下载allurepip install allure-pytest
然后命令行添加--alluredir, results
然后测试运行结束后，输入allure generate results -o reports
这里的results是存放测试生成的json文件的文件夹，reports是生成html报告的文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4f1ad8860af45cec902a01a3845808/" rel="bookmark">
			20年intel版mac升级Monterey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我今天就说一下20年的mac air intel版的适不适合升级最新的系统
我是20年上半年官网买的MacBook Air，十代i5处理器，256G的。最开始用的是原装的系统Catalina，系统流畅，打开应用速度很快，使用产生热量还小，几乎不怎么热。
后来出了一个测试系统 big sur，抱着试一试的心态下载了，图标很好看，是比Catalina好看许多，但是系统有bug，打开应用卡顿，而且好多应用不兼容，就没怎么用。
，在后来出了个Monterey，因为用big sur打开应用反应慢，而且出现卡顿啊，以及停止运行麻烦，就直接升级，升级后系统是流畅，但是打开几个网页风扇就嗡嗡响，发热严重，打字反应迟钝等等好多问题，最近有时间了把自己的电脑重置回Catalina，怎么说呢，虽然看着没那两个系统舒服，新功能没那两个多，但这个是和intel适用的，如果你是M1芯片 ，建议你升级新系统，如果是intel的，那Catalina就够用。不建议你升级最新的Monterey，因为intel芯片的用Monterey系统多少都有问题，如有共同问题的哥哥姐姐，欢迎提问。
以上纯属个人见解，不喜勿喷，谢谢。
下面附加一个恢复原系统的方法：
降级使用MacOS Recovery 注意⚠️：此过程类似于重新安装MacOS，而是下载计算机附带的MacOS版本。如果你的计算机已经很老了，那么它会下载仍然可用的最旧版本
确保你已完全备份，因为这会擦除你的启动磁盘：
1.备份电脑中重要的资料等等，备份完了然后关机。
2.启动电脑并立即按住Shift + Option + Cmd + R这时会出现一个小地球，然后连上Wi-Fi等待进度条完成
3.进入后点击磁盘工具，记得把所有盘都抹了
4.抹完了退出来点击重装macos，一直点击下一步、同意，最后等待即可。
注意⚠️：只适合重装你电脑购买时所带的系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58a58698ea2f693fda66b6dedb346393/" rel="bookmark">
			创建vue项目时遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、由于用户权限不足，无法加载文件，以管理员身份运行cmd也可以解决此问题。 解决方案：
（1）在终端中继续输入Set-ExecutionPolicy -Scope CurrentUser，执行命令后会显示如下
位于命令管道位置 1 的 cmdlet Set-ExecutionPolicy 请为以下参数提供值: ExecutionPolicy: （2）继续输入 RemoteSigned即可完成；
（3）再次输入vue create vue_yiqing时即可成功安装
二、版本更新问题 问题：
vue的版本存在更新，需要先卸载vue cli2,然后重新安装vue cli 3
解决方案：
1、首先我们需要卸载旧版本的vue cli：
npm uninstall vue-cli -g 2、然后重新安装vue cli
npm install -g @vue/cli 三、更新完版本后，要求更新npm 翻译：
新的补丁版本的npm可用！8.5.0 -&gt; 8.8.0更改日志：Release v8.8.0 · npm/cli · GitHub运行 npm install -g npm@8.8.0 进行更新！ 解决方案：运行 npm install -g npm@8.8.0更新 四、在项目目录下运行项目 原因：未在项目目录下运行
解决方案：将当前目录修改为项目目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb5d029d7eacf32fb2037d65c32878b6/" rel="bookmark">
			关于在Vue3项目中配置vw实现移动端适配，rem配置不成功的小伙伴不妨看看这篇文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，配置vw 在配置vw之前，我们先配置vue-cli3的搭建，安装步骤在我主页文章中，这里先不展示安装过程：链接 ↓↓↓
关于vue脚手架vue-cli搭建安装流程（内附图文）
二，创建项目 利用可视化视图的方式打开vue ui界面创建项目（这里我先创建好了）
用编译器打开刚创建的veu-applet中 下面是我的一个配置 ↓↓↓:
在vue-cli3中是没有.postcssrc.js的，需要自己创建。（我这里的vue.config.js文件是版本自动创建的）
创建完成文件后我们先安装插件
//一步一步安装 npm install postcss-import //转换CSS的工具 npm install postcss-url npm i postcss-aspect-ratio-mini postcss-px-to-viewport postcss-write-svg postcss-cssnext postcss-viewport-units cssnano --S npm i cssnano-preset-advanced --save-dev 安装完成后在package.json中查看是否安装成功 ↓↓↓
好！ 我们打开刚创建的 .postcssrc.js 文件完成配置
module.exports = { plugins: { "postcss-import": {}, autoprefixer: {}, "postcss-url": {}, "postcss-aspect-ratio-mini": {}, "postcss-write-svg": { utf8: false }, 'postcss-px-to-viewport': { unitToConvert: "px", viewportWidth: 375, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 812, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: 'vw', // 指定需要转换成的视窗单位，建议使用vw fontViewportUnit: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb5d029d7eacf32fb2037d65c32878b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16c2dc7153541e338dd6421bf00b0801/" rel="bookmark">
			面试官：spark任务如何调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果面试时被问到spark任务如何调优，我们该如何回答呐？
下面我们从四大方面回答这个问题，保证吊打面试官。
一、spark性能调优
1、分配更多的资源
比如增加执行器个数（num_executor）、增加执行器个数（executor_cores）、增加执行器内存（executor_memory）
2、调节并行度
spark.default.parallelism
3、重构RDD架构以及RDD持久化
尽量去复用RDD，差不多的RDD可以抽取成一个共同的RDD，公共RDD一定要实现持久化
4、广播变量
SparkContext.broadcast方法创建一个对象，通过value方法访问
5、使用kryo序列化
SparkConf中设置属性：spark.serializer: org.apache.spark.serializer.kryoSerializer
6、使用fastutil优化数据格式（代替java中的Array、List、Set、Map）
7、调节数据本地化等待时长
调节参数: spark.locality.wait
二、JVM调优
降低cache操作的内存占比 1.6版本之前使用的是静态内存管理
spark中堆内存被划分为两块：
一块是专门来给RDD作cache\persist持久化的 StorageMemory，另一块是给spark算子函数运行使用的，存放函数中自己创建的对象。
1.6版本之后采用统一内存管理机制
storage和execution各占50%，若己方不足对方空余可占用对方空间
可尝试调节executor堆外内存
spark.yarn.executor.memoryOverhead = 2048m
调节连接等待时长
spark.core.connection.ack.wait.timeout = 300
三、shuffle数据倾斜调优
1、预聚合源数据，对hive源表提前进行聚合操作，在hive聚合之后，spark任务再去读取
2、检查倾斜的key是否是脏数据，可以提前过滤
3、提高shuffle操作reduce的并行度
4、使用随机key实现双重聚合
5、将reduce端 join转换成map端 join
6、sample采样倾斜key，单独进行join后在union
7、使用随机数以及扩容表进行join
四、算子调优
1、使用mapPartition提升map类操作的性能
2、filter过后使用coalesce减少分区数量
3、使用foreachPartition优化写数据性能
4、使用repartition解决sparkSql低并行度的性能问题
5、reduceByKey替换groupByKey实现map读预聚合
关注微信公众号【飞哥大数据】，回复666 获取2022年100+公司面试真题，以及spark与flink面试题汇总
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714f1cf82c0407f5d24920e1dda02eb3/" rel="bookmark">
			网络编程一 ----linux,window的简单网络通信实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fff目录
1.Linux
代码
头文件
函数
结构体
Window
代码
头文件和库
函数
类型 Linux和window的差别总结
1.Linux 代码 服务端 ：
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt; int main(int argc,char*argv[]) { int sock_ser,sock_cli; struct sockaddr_in addr_ser,addr_cli; socklen_t len; int blk = 3;	char buffer[] = "hello world"; //参数个数不对直接退出 if(argc != 3) { printf("error %s: 参数错误\n",argv[1]); exit(1); } //初始化ip,port memset(&amp;addr_ser,0,sizeof(addr_ser)); addr_ser.sin_family = AF_INET; addr_ser.sin_port = htons(atoi(argv[2])); addr_ser.sin_addr.s_addr = inet_addr(argv[1]); //建立监听套接字 sock_ser = socket(AF_INET,SOCK_STREAM,0); if(sock_ser == -1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/714f1cf82c0407f5d24920e1dda02eb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c018164d0b8e5134c9043db28b5d414/" rel="bookmark">
			git统计项目代码修改行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git统计项目代码修改行数 1、前往git本地项目路径下
2、右键打开（Git Bash）工具
3、输入以下命令进行不同方式统计
根据用户名进行统计 git log --author="username" --pretty=tformat: --numstat | \ awk '{ add += $1; subs += $2; loc += $1 - $2 } END \ { printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc }' 根据时间段进行统计 git log --since=2022-01-01 --until=2022-12-31 --pretty=tformat: --numstat | \ awk '{ add += $1; subs += $2; loc += $1 - $2 } END \ { printf "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c018164d0b8e5134c9043db28b5d414/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52be1a8f5721a8388936e20065387cdf/" rel="bookmark">
			单链表循环队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// // queue_.cpp // Cycle // // Created by ljpc on 2018/5/30. // Copyright © 2018年 ljpc. All rights reserved. // #include "queue_.h" void creatCycleQueue(CycleQueue* que) // 创建一个循环队列指针que { que-&gt;size_ = 0; que-&gt;rear = NULL; } bool isEmpty(CycleQueue* que) // 判断队列que是否为空 // 若空返回 true 并在一行打印 The queue is Empty 末尾换行！！！ // 否则返回 false { // 请在这里补充代码，完成本关任务 /********** Begin *********/ if( que-&gt;size_ == 0) { printf("The queue is Empty\n"); return true; } else { return false; } /********** End **********/ } void enQueue(CycleQueue* que, int item) // 实现入队操作：将元素item加入队列que尾部 { // 请在这里补充代码，完成本关任务 /********** Begin *********/ struct Node *a; a = (Node*)malloc(sizeof(Node)); a-&gt;data = item; if (que-&gt;size_ == 0) { que-&gt;rear = a; que-&gt;rear-&gt;next = a; } else { a-&gt;next=que-&gt;rear-&gt;next; que-&gt;rear-&gt;next=a; que-&gt;rear=a; } que-&gt;size_++; /********** End **********/ } int deQueue(CycleQueue* que) // 实现出队操作：移除队列que首部元素，并返回元素值 { // 请在这里补充代码，完成本关任务 /********** Begin *********/ int a=que-&gt;rear-&gt;next-&gt;data; if(que-&gt;size_==1) { que-&gt;rear-&gt;next=NULL; que-&gt;rear=NULL; } else { que-&gt;rear-&gt;next=que-&gt;rear-&gt;next-&gt;next; que-&gt;size_--; } return a; /********** End **********/ } void printQueue(CycleQueue* que) // 打印队列 { while (isEmpty(que)==false) { int item = deQueue(que); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52be1a8f5721a8388936e20065387cdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/facb0d251fe891930d51d970aded7701/" rel="bookmark">
			vue如何实现弹幕功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章将为大家详细讲解有关vue如何实现弹幕功能，小编觉得挺实用的，因此分享给大家做个参考，希望大家阅读完这篇文章后可以有所收获。 （1）效果
如上图所示的效果，这里我们使用vue 制作。
(2)使用技术 vue + vue-baberrage
1.安装：
npm install vue-baberrage
2.引入
方式一：
import Vue from 'vue' import { vueBaberrage } from 'vue-baberrage' Vue.use(vueBaberrage) 方式二：
const vueBaberrage = request('vue-baberrage').vueBaberrage 方式三：
&lt;script src="./dist/vue-baberrage.js"&gt;&lt;/script&gt; 3.使用
HTML
&lt;div id="app"&gt; &lt;vue-baberrage :isShow= "barrageIsShow" :barrageList = "barrageList" :loop = "barrageLoop" &gt; &lt;/vue-baberrage&gt; &lt;/div&gt; JS
import { MESSAGE_TYPE } from 'vue-baberrage' export default { name: 'app', data () { return { msg: 'Hello vue-baberrage', barrageIsShow: true, currentId : 0, barrageLoop: false, barrageList: [] } }, methods:{ addToList (){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/facb0d251fe891930d51d970aded7701/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d531071293236538ca5545cf1e7927/" rel="bookmark">
			PTA-数据库作业题（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 所有的题目都是课后作业题，仅供学习参考使用
刚做完的自学作业，这一部分涉及有视图以及查询，针对PTA通过问题也会提到一些。 一、题目 10-1 查询xscj表中的学号，姓名，计算机三项信息，结果按计算机成绩的降序排列。 select 学号,姓名,计算机 from xscj order by 计算机 desc 稍微提一下，order by 默认升序，desc表示降序排列，asc表示升序排列，查找时按照在其后的优先级进行查找。 10-2 查询图书表中各出版社图书的数目，结果按图书数目降序排序 select 出版社,count(*) as 图书数目 from 图书 group by 出版社 order by 图书数目 desc 10-3 查询图书的条形码，书名，出版社和出版日期，要求结果按出版社升序排列，出版社相同的数据按出版日期降序排列 select 条形码,书名,出版社,出版日期 from 图书 order by 出版社 asc,出版日期 desc 10-4 查询选修了“0000008”课程的学生的学号及其成绩，查询结果按分数降序排列 select sno,score from sc where cno=0000008 order by score desc 10-5 查询成绩不及格的学生学号、课号和成绩，并按成绩降序排列 select sno,cno,score from sc where score &lt; 60 order by score desc 10-6 查询信息学院的男生信息，查询结果按出生日期升序排序，出生日期相同的按生源地降序排序 select * from students where sdept ='信息学院' and ssex='男' order by bday asc,bplace desc 10-7 检索出被学生选修的课程编号，结果按着课程编号降序排列 select distinct cno from score order by cno desc 10-8 查询商品表，先按商品分类升序排列，再按商品价格降序排列 select name,category_id,price from sh_goods order by category_id asc,price desc 10-9 统计每个学院的学生总人数，并按人数降序排列 select dept as 院部,count(*) as 总人数 from student group by dept order by count(*) desc 当聚合函数和非聚合函数同时使用的时候，需要使用 group by，其后跟非聚合函数即可，否则无意义 10-10 查询课程“Dp010004”的学生学号和成绩，并按成绩降序排列，成绩相同按学号升序排列 select StudentID,Grade from Grade where CourseID ='Dp010004' order by Grade desc,StudentID asc 10-11 查询zgda表中的工号，姓名，性别，职称4项信息，显示结果时首先按照女性在前的顺序，如果性别相同则按照职称的升序排列。 select 工号,姓名,性别,职称 from zgda order by 性别	desc,职称 asc 10-12 查询图书表中的图书的条形码和书名，要求结果按条形码升序排序 select 条形码,书名 from 图书 order by 条形码 asc 10-13 在读者表中查询全部读者信息，要求女性在前男性在后，同为女性读者的按账号升序排列 select * from 读者 order by 性别 desc,账号 asc 10-14 在员工表中查询所有男性员工的编号，姓名和入职日期，结果按员工编号升序排列 select 员工编号,姓名,入职日期 from 员工 where 性别='男' order by 员工编号 asc 10-15 在顾客表中查询青岛的顾客编号，公司名称和电话，结果按顾客编号升序排列 select 顾客编号,公司名称,电话 from 顾客 where 城市='青岛' order by 顾客编号 asc 10-16 检索所有选修了40008课的学生学号和成绩，查询结果按学号升序排列 select sno as 学号, grade as 成绩 from score where cno='40008' order by sno asc 10-17 查看2010年的销售记录，查询结果以销售日期升序排列 select * from recorder where year(sale_date)='2010' order by sale_date asc year 函数可以直接使用，之前的作业题里有显示如何表示时间 10-18 查询马齐的购物情况，查询结果以商品编号升序排列 select good.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03d531071293236538ca5545cf1e7927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed965d90d53e8af6cf22a267e2547f59/" rel="bookmark">
			Vue-admin-template中报错This dependency was not found和To install it, you can run: npm install score-js
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在运行的时候遇到了以下报错
This dependency was not found 没有发现此依赖关系:
下面提示重新安装core-js包
解决办法如下：
1.在文件中删除node_modules
2.输入 yarn add core-js
3.安装其他依赖 yarn
4.运行 yarn dev 启动
完美解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9188721febccda5c1a471ff2490b6616/" rel="bookmark">
			C&#43;&#43;语言程序设计——知识点复盘（第五章 数据的共享与保护）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
标识符的作用域
1、函数原型作用域
2、局部作用域
3、类作用域
4、命名空间作用域（文件作用域）
标识符的可见性
对象的生存期
1、静态生存期
2、动态生存期
例.变量的生存期与可见性
总结
类的静态成员
1、静态数据成员
例.具有静态数据成员的Point类
2、静态函数成员
1、友元函数
例.使用友元函数计算两点间的距离
2、友元类
例.B类是A类的友元类
共享数据的保护
常对象
常成员函数
常数据成员
常引用
多文件结构
C++程序的一般组织结构
外部变量
外部函数
编译预处理
1、#include指令
2、#define和 #undef指令
3、条件编译指令
4、defined操作符
标识符的作用域 是指一个标识符在程序正文中有效的区域。C++中包括以下几种作用域：
1、函数原型作用域 即声明函数原型时形式参数的作用范围，是C++程序中最小的作用域。
double area(double r);
上例中的左右括号之间就是r的作用域。
2、局部作用域 （1）函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止。
（2）函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止。（所谓块，就是一对大括号括起来的一段程序）
具有局部作用域的变量也称为局部变量。
3、类作用域 4、命名空间作用域（文件作用域） 一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的、不属于前面所述各个作用域的标识符，都属于该命名空间作用域。格式如下：
namesapce 命名空间名{ 命名空间内的各种声明(函数声明、类声明、...) } 在命名空间内部可以直接引用当前命名空间中声明的标识符，若需要应用其他命名空间的标识符，需要使用下面的语法：
using 命名空间名::标识符名; using namespace 命名空间名; 前一种形式将指定的标识符暴露在当前的作用域内，使得在当前作用域中可以直接引用该标识符；后一种形式将指定命名空间内的所有标识符暴露在当前的作用域内。
具有命名空间作用域的变量也称为全局变量。
标识符的可见性 即标识符的有效范围，表示从内层作用域向外层作用域“看”时能看到什么。程序运行到某一点，能够引用到的标识符，就是该处可见的标识符。
可见性的一般规则如下：
1、标识符要声明在前，应用在后。
2、在同一作用域中，不能声明同名的标识符。
3、在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响。
4、如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9188721febccda5c1a471ff2490b6616/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5933732695269c4c231d6fb136012bba/" rel="bookmark">
			数据结构课设&#43;校园导航系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
1. 设计目的
2.设计内容与要求
2.1设计内容
2.2课题要求
3.设计思路
3.1关键问题描述
3.2程序处理流程图
​4.实现过程
4.1功能实现
4.2 测试运行​
5.代码实现
前言 课程已经过大半,相信很多小伙伴们都要迎来大作业，最近时间比较紧，没有及时更新,就先把我之前写的校园导航系统放上来供大家参考,这几天我有时间会对其优化并加上界面增加些功能。
1. 设计目的 本课程设计的目的就是要达到理论与实际应用相结合,提高我们组织数据及其编写大型程序的能力，并培养积极的,良好的程序设计内容。设计中要求综合运用所学知识，通过分析，设计，编码，调试等各环节的训练，使我们更加深刻掌握数据结构和算法设计技术。
2.设计内容与要求 2.1设计内容 本课题主要实现对校园景点的导航，具体功能有学校地图查看、查看浏览路线、查看各地点间最短路径、景点信息查询、查询各地点间可行路径、打印临接矩阵、更改图信息、退出查询等功能。
2.2课题要求 设计校园平面图。其中具有代表性的地点至少含有12个，平面图中顶点表示校内代表性的地点，边上的权值表示两地点之间的距离；为实现校园导航系统子功能的管理，设计主控菜单；为来访客人提供图中任意地点相关信息的查询； 4.为来访客人提供图中任意两地点之间最短路线的查询，指点地点到其他所有地点最短路线的 查询
3.设计思路 3.1关键问题描述 （1）数据采集与地图测绘;
（2）如何建立图信息；
（3）如何存储景点信息；
（4）如何定义邻接表类型；
（5）如何解决各地点间最短路径问题；
(6) 如何在运行界面正确输入所需查询的信息；
关键问题解决方法： (1)数据采集与地图绘测
(2)如何建立图信息
利用邻接矩阵存储，其中图所用到的结构体为:
typedef char DataType; typedef int WeightType;
typedef struct //以下定义邻接矩阵类型
{
int number; //顶点编号
DataType xinxi; //顶点其他信息
}VertexType; //顶点类型 (3)如何存储景点信息
Typedef int WeightType;
typedef struct
{
WeightType G[MaxVertexNum][MaxVertexNum]; //邻接矩阵数组
int Nv; //顶点数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5933732695269c4c231d6fb136012bba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f28befd7a8bce6a3dbacb3631edf5d9d/" rel="bookmark">
			Python一个Android安卓自动化测试开源工具uiautomator2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境要求
二、介绍
三、库地址
四、安装
五、应用及操作
一、环境要求
python 3.6+
android 4.4+
二、介绍
uiautomator2 是一个可以使用Python对Android设备进行UI自动化的库。其底层基于Google uiautomator，Google提供的uiautomator库可以获取屏幕上任意一个APP的任意一个控件属性，并对其进行任意操作。
三、库地址
GitHub地址：
https://github.com/openatx/uiautomator2
https://github.com/openatx/uiautomator2/blob/master/README.md
四、安装
1、安装uiautomator2
pip install --pre uiautomator2
pip install pillow （如果需要截图，可安装这个库）
2、设备安装atx-agent
首先设备连接到PC，并能够adb devices发现该设备。
执行下面的命令会自动安装本库所需要的设备端程序：uiautomator-server，atx-agent，openstf / minicap，openstf / minitoucn
init就是所有USB连接电脑的手机上都安装uiautomator2 python -m uiautomator2 init
指定手机安装uiautomator2， 用 --mirror python -m uiautomator2 init --mirror --serial $SERIAL
嫌弃慢的话，可以用国内的镜像 python -m uiautomator2 init --mirror
最后提示success，代表atx-agent初始化成功。
3、安装weditor
有了这个，方便我们快速的识别手机上的元素，方便写代码
pip install -U weditor
安装好之后，就可以在命令行运行 weditor --help 确认是否安装成功了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f28befd7a8bce6a3dbacb3631edf5d9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07dd263c8184a5295daf715eddd14ffe/" rel="bookmark">
			Mybatis的关联映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关联映射
一对一
一对多、多对一
多对多
关联映射 关联关系是面向对象分析、面向对象设计最终的思想,Mybatis完全可以理解这种关联关系，如果关系得当，Mybatis的关联映射将可以大大简化持久层数据的访问。关联关系大致可以分为以下情况:
1、一对一，一个人只能有一张身份证，而一张身份证只能属于一个人；
2、一对多，一个客户对应多个订单
3、多对多，一篇新闻对应多种类型，一种类型对应多篇新闻
当然，还有更复杂的关系，同样在购物系统中，一个用户可以有多个订单，而一个订单只能属于一个用户，再加上商品的关系就是一对多夹杂多对多的关系，但是万变都不离其中。
一对一 用户表（tb_user）和身份证表（tb_card）
一个用户对应一张身份证
tb_user：
tb_card：
2、创建相应的实体类对象（用user去关联card）、mapper层接口和mapper文件 实体类对象
public class Card { private Integer cardId;//主键id private String cardCode;//身份证号 //省略相应的get/set和构造方法 } @Data @ToString public class User{ private Integer userId;//主键userId private String userName;//姓名 private String userGender;//性别 private Integer userAge;//年龄 private Card card;//人和身份证是一对一的关系 } mapper层接口:
@Repository public interface CardMapper { Card getCardById(Integer cardId); } @Repository public interface UserMapper { User getUserById(Integer userId); } mapper文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07dd263c8184a5295daf715eddd14ffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e451e4988e5e4eb30885915e6f420679/" rel="bookmark">
			SpringMVC---- SpringMVC 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 什么是springMVC?
2. 请求流程
3、开发步骤:
4、SpringMVC组件
5、SpringMVC注解解析
6、方法返回值
7、跳转方式
8、静态资源访问设置
1. 什么是springMVC? Spring Web MVC是一种基于Java的实现了MVC设计模式的、请求驱动类型的、轻量级Web框架,已经融合在 Spring Web Flow 中。
相比于MVC，M就是模型model，主要用于数据封装和业务逻辑处理，而V是view，叫视图，主要用于数据的展示，而C就是controller，控制器，主要用于分发和指派的一个工作。 )
2. 请求流程 第一步：发起请求到前端控制器(DispatcherServlet)
第二步：前端控制器请求HandlerMapping查找 Handler可以根据xml配置、注解进行查找,生成处理对象及处理器拦截器(如果有则生成)一并返回前端控制器
第三步：处理器映射器HandlerMapping向前端控制器返回Handler(抽象) 第四步：前端控制器调用处理器适配器去执行Handler
第五步：处理器适配器根据Handler规则执行不同类型的Handler(处理器(Controller),后端控制器)
第六步：Handler执行完成给适配器返回ModelAndView(模型视图)
ModelAndView是springmvc框架的一个底层对象
Model:即将被渲染的数据 包含了要在页面中展示的数据
View:跳转的页面(只包含页面名称:逻辑视图名) 例：index
第七步：处理器适配器向前端控制器返回ModelAndView
第八步：前端控制器请求视图解析器(ViewResolver)去进行视图解析(DispatcherServlet将ModelAndView传递给ViewResolver) 根据逻辑视图名解析成真正的视图(jsp)
在视图解析器中(拼接出完整的请求地址 例：jsp/book/index.jsp)
第九步：视图解析器向前端控制器返回具体View
第十步：前端控制器根据View进行视图渲染(即将模型数据填充至视图中)
视图渲染将模型数据(在ModelAndView对象中)填充到request域
第十一步：前端控制器向用户响应结果
3、开发步骤: 第一步：导入SpringMVC相关依赖
第二步：配置SpringMVC核心文件 spring-mvc.xml
第三步：配置SpringMVC核心控制器DispathcerServlet
第四步：创建Controller类和视图页面
第五步：使用注解配置Controller类中业务方法的映射地址
第六步：客户端发起请求测试
具体如下：
1、导入SpringMVC相关坐标
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ********************** JSTL依赖 ********************** --&gt; &lt;!-- 缺少下面的这两个jar包会报java.lang.NoClassDefFoundError: javax/servlet/jsp/jstl/core/Config--&gt; &lt;!-- 原因：org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e451e4988e5e4eb30885915e6f420679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6201f9257791ea6da0b7a1f778adde5/" rel="bookmark">
			vue中v-model的实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 v-model的实现原理其实很简单，可以理解为在input框里面通过v-bind动态绑定一个value，然后在input框里面通过@input方法去动态获取input输入的值，然后重新给变量赋值就可以，直接上代码。
&lt;template&gt; &lt;div class="home"&gt; &lt;div&gt;{{msg}}&lt;/div&gt; &lt;input type="text" v-bind:value="msg" @input="_input"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { created(){ }, name: 'Home', components: { }, data(){ return{ msg:"你好" } }, methods:{ _input(e){ console.log(e.target.value); this.msg=e.target.value } } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c987ba7b240ebab54ccf8e69a86887a5/" rel="bookmark">
			记录装禅道XAMPP过程中 遇到的端口问题（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 这里碰到了三个问题
一是Apache启动失败：
20:23:28 [Apache] Error: Apache shutdown unexpectedly.
20:23:28 [Apache] This may be due to a blocked port, missing dependencies,
20:23:28 [Apache] improper privileges, a crash, or a shutdown by another method.
20:23:28 [Apache] Press the Logs button to view error logs and check
20:23:28 [Apache] the Windows Event Viewer for more clues
20:23:28 [Apache] If you need more help, copy and post this
20:23:28 [Apache] entire log window on the forums
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c987ba7b240ebab54ccf8e69a86887a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a80b0349649bf5607ca7d44ddc08fc9d/" rel="bookmark">
			【CSS解决页面高度塌陷问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高度塌陷问题描述 1、页面高度塌陷问题(1)产生原因(2)正常标准流盒子(3)子盒子浮动(4)归纳总结 1.1、清除浮动本质1.2 、清除浮动的方法(1)方法一：额外标签法(2)方法二：给父级添加overflow属性方法①一个BFC的小知识 (3)方法三：使用after伪元素清除浮动(4)方法四：clearfix类解决高度塌陷（推荐） 1.3、一个常用布局框架实例 1、页面高度塌陷问题 (1)产生原因 我们都知道当元素浮动后，可以左右移动，直到遇到另一个浮动框或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。如果没有设置高度，那么包含框父元素默认是被子元素撑开的，当子元素设置浮动后，子元素会脱离文档流，父元素不被子元素撑开，就会出现父元素的高度塌陷问题；
(2)正常标准流盒子 子盒子是标准流，父盒子没有高度，但是会被撑开高度。
①代码如下：
&lt;style&gt; .s{ width:700px; background-color: antiquewhite; border: solid 3px red; } .s1{ width: 200px; height:100px; background-color: aqua; text-align: center; line-height: 100px; } .s2{ width: 150px; height:200px; background-color:blueviolet; text-align: center; line-height: 200px; } .s3{ width:250px; height: 150px; background-color: chartreuse; text-align: center; line-height: 150px; } &lt;/style&gt; &lt;body&gt; &lt;div class="s"&gt; &lt;div class="s1"&gt;1&lt;/div&gt; &lt;div class="s2"&gt;2&lt;/div&gt; &lt;div class="s3"&gt;3&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; ②页面如下：
(3)子盒子浮动 子盒子浮动，脱离标准流，父盒子没有高度，高度为零，不会被撑开盒子。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a80b0349649bf5607ca7d44ddc08fc9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de2d53f8c6bac3e301161e32a603334d/" rel="bookmark">
			Servlet[dispatcherServlet]的Servlet.init（）引发异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
javax.servlet.ServletException: Servlet[dispatcherServlet]的Servlet.init（）引发异常
org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException:
org.xml.sax.SAXParseException; lineNumber
错误描述：主要是在配置spring的配置文件时，引入的约束地址往往可能不对，需要自己检查一下
解决办法：修改spring配置文件的约束
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/275/">«</a>
	<span class="pagination__item pagination__item--current">276/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/277/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>