<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54631761eac10369da0b12ead74b7f70/" rel="bookmark">
			若依如何进行页面路由跳转，路由跳转时如何携带参数（超详细图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们经常会有这样需求，当我们在一个页面时，想要跳转到另一个页面，但是跳转的同时还需要携带参数。那么这种情况在若依系统中该如何做呢，下面我们来说一下。
文章目录 问题提出：一、创建目标页面的路由(也就是图2的路由)二、给按钮编写路由跳转方法，并携带参数三、在目标页面中拿到路由的参数并在页面进行展示四、注意事项 ： 问题提出： 我这里有个学生成绩展示的表格（如图1），当我单击查看详情时我想要跳转到另一个页面进行学生成绩的展示(如图2)。
图1 图2 一、创建目标页面的路由(也就是图2的路由) 1.1 首先找到前端src/router文件夹下的index.js页面
1.2 进入后在公共路由下，仿照上面路由的写法，新建一个目标页面的路由
如下图所示，我们新建了一个路由，路由的完整路由为，/student/studentScore
我们在新建一个路由后，就只需要修改如下这几个框出来的地方即可。
{ path: '/recipeAdvice', component: Layout, hidden: true, redirect: 'recipeAdvice', children: [ { path: 'recipeAdviceCard', component: () =&gt; import('@/views/soil/recipeAdvice/index'), name: 'recipeAdviceCard', meta: { title: '配方建议填写' } } ] } 了解内容：
{ path: '/recipeAdvice', component: Layout, hidden: true, redirect: 'recipeAdvice', children: [ { path: 'recipeAdviceCard', component: () =&gt; import('@/views/soil/recipeAdvice/index'), name: 'recipeAdviceCard', meta: { title: '建议卡填写' } } ] } 对这个路由内容的解析:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54631761eac10369da0b12ead74b7f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cdcb8768e371d2cabee2444692da8f6/" rel="bookmark">
			RK3568平台 查看内存的基本命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.free命令 free命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略。
Mem 行(第二行)是内存的使用情况。
Swap 行(第三行)是交换空间的使用情况。
total 列显示系统总的可用物理内存和交换空间大小。
used 列显示已经被使用的物理内存和交换空间。
free 列显示还有多少物理内存和交换空间可用使用。
shared 列显示被共享使用的物理内存大小。
buff/cache 列显示被 buffer 和 cache 使用的物理内存大小。
available 列显示还可以被应用程序使用的物理内存大小。
二.cat /proc/meminfo /proc/meminfo是了解Linux系统内存状态的主要接口，里面统计了当前系统各类内存的使用状况，需要注意的是：这是从内核的角度来统计。
User:/ # cat /proc/meminfo cat /proc/meminfo MemTotal: 7570916 kB MemFree: 221820 kB MemAvailable: 4699384 kB Buffers: 14280 kB Cached: 4655300 kB SwapCached: 48232 kB Active: 2825544 kB Inactive: 2688788 kB Active(anon): 802732 kB Inactive(anon): 196828 kB Active(file): 2022812 kB Inactive(file): 2491960 kB Unevictable: 142216 kB Mlocked: 142216 kB SwapTotal: 5242876 kB SwapFree: 4317088 kB Dirty: 512 kB Writeback: 0 kB AnonPages: 968372 kB Mapped: 1245556 kB Shmem: 14464 kB KReclaimable: 314272 kB Slab: 422852 kB SReclaimable: 118064 kB SUnreclaim: 304788 kB KernelStack: 70992 kB PageTables: 105056 kB NFS_Unstable: 0 kB Bounce: 0 kB WritebackTmp: 0 kB CommitLimit: 12174056 kB Committed_AS: 140385476 kB VmallocTotal: 263061440 kB VmallocUsed: 163212 kB VmallocChunk: 0 kB Percpu: 10592 kB CmaTotal: 262144 kB CmaFree: 76 kB IonTotalCache: 174480 kB IonTotalUsed: 275708 kB GPUTotalUsed: 137996 kB MemTotal：表示内存管理系统管理的总物理内存大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cdcb8768e371d2cabee2444692da8f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e12c9d1c19231a6f43e09c03ce43178/" rel="bookmark">
			unity鼠标控制参数大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 选中参数，变蓝了 拖动鼠标 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac99bc01bb503d272637094028b19b89/" rel="bookmark">
			Linux调试器--gdb的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux调试器--gdb的使用 1.背景知识2.使用gdb2.1进入gdb2.2退出gdb2.3查看代码2.4执行程序2.5打断点2.5.1在指定源文件里打断点：2.5.2在指定源文件里的函数处打断点 2.6查看断点2.7 删除断点2.8 启用与禁用断点2.9遇到断点后逐语句走2.10遇到断点后逐过程走2.11在调试时，查看变量的值2.12跳转到指定位置2.13运行当前函数完成2.14直接从一个断点跑到下一个断点2.15调用堆栈2.16 在调试中改变变量的值 1.背景知识 我们在运行我们的代码的时候有两种模式：Debug模式和Release模式。 一份代码要被调试，这份代码的发布模式必须是Debug 在Linux中我们使用gdb进行调试 安装gdb（这里我用的是CentOS 7.8）：
yum install -y gdb 在Linux系统中使用gcc编译代码，生成的可执行程序默认是Release模式的。 验证：这里，我们make/makefile编译我写好的test.c文件，生成可执行文件test。
在Linux中使用gcc的在Debug模式编译需要用到 - g 选型： gcc -o 生成可执行文件名 源文件名 -g 这里的 - g选项就是让，指定gcc编译器在Debug模式下，编译源文件。
更加形象的区分Debug模式与Release模式： 方法1：
在Debug发布的时候，一定要给可执行程序内部添加Debug信息，否则无法调试
因此导致：Debug形成的可执行文件的大小 &gt; Release形成的可执行文件
方法二：
使用指令：
readelf -S 可执行程序文件名 | grep -i debug 作用：在Linux中形成的可执行程序的格式是ELF格式，而 readelf -S 就是阅读可执行程序，后面的就是通过管道，将文件中的Debug信息筛选出来。如果有Debug信息说明可执行程序文件实在Debug模式下编译的，否则就是Release模式。
2.使用gdb 2.1进入gdb gbd调试的是可执行文件（debug模式下生成的）！！！
gdb 可执行程序 2.2退出gdb quit 2.3查看代码 list list也可以简写成 l 从代码的第一行查看：
list 0 或者 list 1（每次最多打印十行） 在gdb中会自动记录上一次的结果，如下图，在执行一次 list 0 后继续回车会接着打印剩下的代码，直到全显示为之
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac99bc01bb503d272637094028b19b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e5e923acba2ba20e1da05548e4d95b/" rel="bookmark">
			【Java开发】之获取客户端真实 IP 地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、应用场景 在投票系统开发中，为了防止刷票，我们需要限制每个 IP 地址只能投票一次；当网站受到诸如 DDoS（Distributed Denial of Service，分布式拒绝服务攻击）等攻击时，我们需要快速定位攻击者 IP；在渗透测试过程中，经常会碰到网站有 CDN（Content Distribution Network，内容交付网络），这时我们需要绕过 CDN 查找真实 IP； 二、获取客户端的 IP 地址 服务端获取客户端请求IP地址，常见的包括：remote_addr、x-forwarded-for、client-ip 等请求头参数：
remote_addr：指的是当前直接请求的客户端IP地址，它存在于tcp请求体中，是http协议传输的时候自动添加，不受请求头header的控制。因此，当客户端与服务器之间不存在任何代理的时候，通过remote_addr获取客户端IP地址是最准确，也是最安全。remote_addr无法伪造x-forwarded-for，即XFF，是很多代理服务器在请求转发时添加上去的。如果客户端和服务器之间存在代理服务器，那么通过remote_addr获取的IP就是代理服务器的地址，并不是客户端真实的IP地址。因此，需要代理服务器（通常是反向代理服务器）将真实客户端的IP地址转发给服务器，转发时客户端的真实IP地址通常就存在于XFF请求头中。client-ip：同XFF，也是代理服务器添加的用于转发客户端请求的真实IP地址，同样保存与请求头中。 在 Java 中，获取客户端 IP 最直接的方式就是使用 request.getRemoteAddr()。这种方式在中间没有代理的情况下，获取连接到服务器的客户端 IP 的最简单有效的方式。
但是目前互联网 Web 应用很少会将应用服务器直接对外提供服务，一般都会有一层 Nginx 做反向代理和负载均衡，有的甚至可能有多层代理。所以，在有反向代理的情况下，直接使用 request.getRemoteAddr() 获取到的IP地址是Nginx所在服务器的IP地址，而不是客户端的 IP。
为了解决上面的问题，很多 HTTP 代理会在 HTTP 协议头中添加 X-Forwarded-For 头，用来追踪请求的来源，X-Forwarded-For 的格式如下：
X-Forwarded-For: client1, proxy1, proxy2 X-Forwarded-For 包含多个 IP 地址，每个值通过逗号+空格分开，最左边（client1）是最原始客户端的IP地址，中间如果有多层代理，每一层代理会将连接它的客户端IP追加在 X-Forwarded-For 右边。
下面就是一种常用的获取客户端真实IP的方法：
public static String getRealIP(HttpServletRequest request) { String ip = request.getHeader("X-Forwarded-For"); if (ip != null) { ip = ip.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e5e923acba2ba20e1da05548e4d95b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d0e48ba3cfffbad63b94a207512e00/" rel="bookmark">
			计组03：20min导图复习 中央处理器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🐳前言 图源：文心一言
考研笔记整理，纯复习向，思维导图基本就是全部内容了，不会涉及较深的知识点~~🥝🥝
第1版：查资料、画思维导图~🧩🧩 编辑： 梅头脑🌸
参考用书：王道考研《2024年 计算机组成原理考研复习指导》
参考视频：5.1_CPU的功能和基本结构_哔哩哔哩_bilibili
🦮思维导图 ​
🌸思维导图为整理王道教材计算机组成原理 第5章中央处理器，如果看不清的话，可以试试存到本地然后放大~🌸博文后面会以大纲的形式复述一遍，面向复习，不会写得很详细，且可能有误；如果想仔细了解知识点，或许可以考虑以下两种方式~ 王道咸鱼老师的视频：5.1_CPU的功能和基本结构_哔哩哔哩_bilibili较为重要的内容有从网络找相关配图并给出原文链接，点击配图的链接可以传送到各位大佬博文，也很适合快速复习~ 📇目录 目录
🐳前言
🦮思维导图
📇目录
🐳中央处理器
🐋CPU的功能和基本结构
🐚组成
🐚功能
🐋指令执行过程
🐚指令周期
🐚备注
🐋指令周期的数据流
🐚取指周期【FE】
🐚间址周期【IND】
🐚执行周期【EX】
🐚中断周期【INT】
🐚指令执行方案
🐋数据通路的功能和基本结构
🐚功能
🐚基本结构
🐋控制器的功能和工作原理
🐚控制器的主要功能
🐚硬布线控制器【组合逻辑控制器】
🐚微操作控制器
🐋指令流水线
🐚提高处理机并行性
🐚指令的执行过程
🐚流水线的设计原则
🐚流水线的基本实现
🐚流水线的冒险与处理
🐚流水线的性能指标
🐚高级流水线技术
🐋多处理器的基本概念
🐚计算机体系
🐚硬件多线程
🐚多核处理器
🔚结语
🐳中央处理器 🐋CPU的功能和基本结构 🐚组成 控制器 功能 负责协调并控制计算机各部件执行的指令序列，包括取指令、分析指令和执行指令 类型 硬布线控制器微程序控制器 组成 程序计数器【PC】 功能 欲执行指令在主存中的存放地址，在取值周期末修改，可自增或执行无条件转移指令【例，JMP】位数 存储字长【PC存放的地址，指向存储器的存储单元；存储容量决定存储单元总数，编址与寻址方式决定每次访问几个存储单元】单位 精简指令集【RISC】：指令长度相同，以指令字为单位，也可以以字节为单位复杂指令集【CISC】：指令长度不同，以字节为单位备注1：PC自增 RISC，有时"+1"为地址增加1条指令长度【+指令字长/编址单位】，而非地址增加1个编址单位可通过自增硬件实现【图中标注PC+1】，或者使用多路选择器MUX连接ALU实现【15年考题】，或者使用加法器实现备注2：PC跳转 在一条无条件跳转指令【JMP】的指令周期内，PC的值被修改2次：PC自增(+指令字长/编址单位)与跳转PC跳转的目标地址=指令字长/编址单位 x（1+OFFSET偏移字段），其中OFFSET表示偏移指令条数指令译码器 仅对操作码字段进行译码，向控制器提供特定的操作信号指令寄存器【IR】 功能：保存当前正在执行的那条指令位数：取决于指令字长存储器地址寄存器【MAR】 存放要访问的主存单元的地址存储器数据寄存器【MDR】 存放向主存写入的信息或从主存读出的信息微操作信号发生器【CU】 根据IR的内容（指令），PSW的内容（状态信息）及时序信号，产生控制信号时序系统 产生各种时序信号，他们都由统一时钟分频得到 运算器 功能 接收从控制器从来的命令并执行相应的动作，对数据进行加工和处理 组成 算数逻辑单元【ALU】 备注：有可能和第2章 数据的表示和运算 以及第4章 指令系统 联合考试进行算数/逻辑运算逻辑元件​​​​​​​ 一条线路的通断 三态门：控制功能部件是否输出，控制信号为In、out结尾多条通路的选择 地址译码器：n位可控制2^n个设备多路选择器：n位可控制n个设备暂存寄存器 功能：暂存从主存读来的数据用途：CPU内部单总线方式，防止总线在两个输入端输入相同的信号累加寄存器【ACC】 通用寄存器，用于存放ALU运算的结果信息，可以作为加法运算的一个输入端，例，执行加法、乘法指令通用寄存器组 功能：用于存放操作数和各种地址信息等，可通过编程制定各种功能位数：取决于机器字长程序状态寄存器【PSW】 保存由算数逻辑运算指令或测试指令的结果而建立的各种状态信息，如进位【CY】、溢出【OV】控制信息，如允许中断【IF】，中断置位指令为CPU做出判断，如执行条件转移指令【IF、CMP】移位器 对操作数或运算结果进行移位运算计数器【CT】 控制乘除运算的操作步骤 🐚功能 指令控制：完成取指令、分析指令和执行指令的操作操作控制：管理并产生由内存取出的每条指令的操作信号，把操作信号送往相应的部件，控制部件按要求动作时间控制：为每条指令按时间顺序提供应有的控制信号数据加工：对数据进行算数和逻辑运算中断处理：对计算机运行过程中的异常情况和特殊请求进行处理 图源：CPU工作原理和电路图_百度知道
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43d0e48ba3cfffbad63b94a207512e00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95dc64b1ecb3789f8f87f7e227dc689c/" rel="bookmark">
			拓扑排序软件设计——ToplogicalSort_app（含有源码、需求分析、可行性分析、概要设计、用户使用手册）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拓扑排序软件设计 前言1. 需求分析2. 可行性分析2.1 简介2.2 技术可行性分析2.2.1 技术实现方案2.2.2 开发人员技能要求2.2.3 可行性 2.3 操作可行性分析2.4 结论 3. 项目报告3.1 修订历史记录3.2 软硬件环境3.3 需求分析3.4 详细设计3.4.1 类设计3.4.2 核心流程描述3.4.3 核心算法设计 4. 运行结果截图4.1 样例14.2 样例24.3 样例34.4 样例44.5 样例5 5. 测试5.1 测试样例15.2 测试样例25.3 测试样例35.4 测试样例45.5 测试样例5 6. 系统特色以及可扩展点6.1系统特色：6.2可扩展点： 4. 源代码部分4.1 项目层级4.2 运行环境4.3 项目核心代码4.3.1 拓扑排序算法TopologicalSort.cpp4.3.2 draw_diagram.py4.3.3 file_manager.py4.3.4 input_manager.py4.3.5 main_window.py4.3.6 topology_manager.py 4.4 GitHub仓库 5. 用户使用手册5.1 运行软件APP5.2 操作app 6. 结束语 前言 这篇博客可能会有点长，因为是一个课程的大作业，包含的内容比较多，这个项目的开发的时间在两周左右，所以这个软件指是一个简单又比较简陋的小桌面应用。
1. 需求分析 导入文件:
用户能够通过界面导入描述课程依赖关系的文本文件（.txt），文件格式为每行表示一个有向边的关系。
绘制拓扑排序图:
根据导入的课程依赖关系，能够绘制出对应的拓扑排序图，使用直观的图形方式展示课程间的依赖关系。
导出图像:
用户可以将绘制好的拓扑排序图导出为图片（.png格式），以便于保存和分享。
导出拓扑排序结果:
用户可以将拓扑排序的结果导出为文本文件（.txt格式），用于后续分析和处理。
展示C++程序输出:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95dc64b1ecb3789f8f87f7e227dc689c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/486e11d75f452ca443be703549fc5e1a/" rel="bookmark">
			LeetCode 513找树左下角的值 112路径之和 106从中序与后序遍历序列构造二叉树 | 代码随想录25期训练营day18
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 513 找树左下角的值 2023.11.11 题目链接代码随想录讲解[链接]
class Solution { public: //递归遍历 int maxdepth; int result; void traversal(TreeNode* root, int depth) { if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { if(depth &gt; maxdepth) { maxdepth = depth; result = root-&gt;val; } } if(root-&gt;left) { //traversal(root-&gt;left, depth+1); depth++; traversal(root-&gt;left, depth); depth--;//回溯一次 } if(root-&gt;right) { //traversal(root-&gt;right, depth+1); depth++; traversal(root-&gt;right, depth); depth--;//回溯一次 } } int findBottomLeftValue(TreeNode* root) { if(root == NULL) return 0; int depth = 1; traversal(root, depth); return result; //层序遍历 // int result = 0; // if(root == NULL) // return result; // queue&lt;TreeNode*&gt; que; // que.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/486e11d75f452ca443be703549fc5e1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81629148d8de7ce59168ddff4af23e0f/" rel="bookmark">
			Android13分享热点设置安全性为wpa3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android13分享热点设置安全性为wpa3 文章目录 Android13分享热点设置安全性为wpa3一、前言热点WPA3加密类型是需要底层硬件支持的。Wifi WPA3 和 热点 WPA3 是不一样的分享初衷 二、代码分析1、应用代码中热点设置WPA3 加密格式报错部分日志信息： 2、系统代码分析（1）热点重要工具类 ApConfigUtil.java（2）Wifi、热点服务实现具体逻辑类 WifiServiceImpl.java（3）继续热点重要工具类 ApConfigUtil.java（4）修改wifi相关res属性（5）WPA3 热点开启成功，但是其他设备无法连接日志（6）WPA1 热点开启成功，但是其他设备正常连接日志 三、Android加密类型介绍1、Android11 网络加密类型2、Android11 Wifi 加密类型代码中的定义3、Android13 Wifi 加密类型代码中的定义4、Android11 热点加密类型定义5、Android13 热点加密类型定义 四、总结1、热点开启流程2、WPA3 热点加密类型系统上层适配 一、前言 Android 网络加密类型WPA3，比WPA和WPA2 安全性强一下；
有些客户强制要求支持WPA3，那么就需要系统进行一些适配了。
Android手机上热点分享显示的安全性部分手机可以选择WPA3，
比如红米12（Android12），一加Ace2（Android13）；
但是其他很多手机都没有选择加密类型，比如Nova6（Android12）、红米（Android10），谷歌Piex4（Android13）。
从这里大致可以猜到：
热点WPA3加密类型是需要底层硬件支持的。 如果只是系统上层简单适配一下就行，估计大部分手机都是会支持WPA3热点的了。
并且热点WPA3 估计是Android11之后的系统才存在的加密类型，
查看了Android9的代码不存在相关属性的判断。
从Android11-13 系统Framework代码看，上层也是有相关属性需要适配，
但是发现上层适配后，可以打开WPA3加密类型的热点，
但是其他安卓设备无法连接这个WPA3加密类型的网络！
从日志看不出具体原因？底层/硬件需要如何适配也还不清楚。
Wifi WPA3 和 热点 WPA3 是不一样的 之前也有Wifi WPA3 加密类型相关分析：
https://blog.csdn.net/wenzhi20102321/article/details/126219495
这里大概介绍一下区别：
Wifi WPA3 ： 指的是Android设备 支持连接WPA3 类型的Wifi 网络，这个只需要适配连接Wifi 的应用代码即可；这个功能在Android11 之后，系统原生Framework和原生Settings默认都是支持的。
热点 WPA3 ：指的是热点开启的加密类型是WPA3，其他手机搜到这个热点，限制的加密类型是WPA3类型。这个适配要系统适配，有点麻烦。
分享初衷 在普通网址和CSDN上搜索了一下，暂时没有搜索到热点WPA3相关的分析，不管是上层的还是底层的相关适配都是空白的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81629148d8de7ce59168ddff4af23e0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/905525e4883d1157df6ccd3878338de3/" rel="bookmark">
			STL简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 函数
stackqueuepriority_queuevectordequelistsetmappairatatmake_pair[][]firsttop()front()top()front()front()front()secondback()back()back()back()begin()begin()begin()begin()end()end()end()end()运算符(=)运算符(=、&lt;=）运算符(=、&lt;=）运算符(=、&lt;=）push()push()push()push_back()push_back()push_back()pop()pop()pop()pop_back(）pop_back(）pop_back(）push_front()push_front()pop_front(）pop_front(）insert()insert()insert()insert()erase()erase()erase()erase()swap()swap()swap()swap()clear()clear()clear()clear()assign()assign()assign()empty()empty()empty()empty()empty()empty()empty()resize()与reserve()resize()resize()sort()sort()sort()size()size()size()size()size()size()size()remove()reverse()unique()splice()merge()emplacefindget_allocatorkey_complower_bound upper_bound count 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51a83ad89f2a37f344656e4d025554d1/" rel="bookmark">
			MySQL安装教程来了！超详细图文超详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先下载MySQL 下面提供几个可用的下载地址：
Mysql官网下载地址： MySQL :: Download MySQL Installer (Archived Versions)
华为MySQL镜像站 ： mirrors.huaweicloud.com/mysql/Downl…
网易云开源镜像站：mirrors.163.com/
在下载列表中选择需要安装的版本: 二、其次安装MySQL 1.在文件夹中双击mysql-installer-community-5.7.23.0.msi 2. 选择安装类型，这里我们选择自定义安装 3.选择安装的产品和功能 依次点开“MySQL Servers”、“MySQL Servers”、“MySQL Servers 5.7”、 **“MySQL Servers 5.7.23-X64**；然后点击绿色箭头将选中的版本移到右侧框中； 注：选择64位系统； 4.可以自定义安装路径和数据存放路径 修改完成之后点击OK（也可以默认在C盘）； 5.然后接下了直接下一步 到此处先选中“MySQL Server5.7.23”，若电脑中没有这个环境，会提示安装“Microsoft Visual C++ 2013”环境，点击“**Execute**”； 6.执行完 直接next 7.从上一步默认下一步，直到这个界面 选择安装类型，个人开发学习选择“Development Computer”；
Development Computer个人开发学习使用；
Server Computer用于FTP，email，web服务器等；
Dedicated Computer 用作MySQL服务器；
8.至此MySQL5.7安装完成！ 三、验证安装 1.打开电脑cmd命令行 输入以下命令 mysql -uroot -p安装时候设置的密码 2.出现’mysql’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 解决方法：
1.配置环境变量；到MySQL安装目录下，复制完整路径；
2.进入环境变量设置；
右击此电脑，选择属性，先点击“高级系统设置”，再点击“环境变量”；
在“系统变量”中选择“Path”，点击“编辑”；
然后点击“新建”，将MySQL的安装路径添加上去，之后点击“确定”；
3.验证环境变量是否配置好；
“window+R”键 弹出运行框，输入“cmd”进入window命令行；
4.再次输入以下命令；
mysql -uroot -p安装时候设置的密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51a83ad89f2a37f344656e4d025554d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c960e36ae4bbad2bacf592d7a4201339/" rel="bookmark">
			微信的聊天记录导出到网页中的最快方法，语音能听，图片视频能看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12-7
如果你有把微信的聊天记录导出到表格或者网页上的需求，适合看看本文章，本文的方法可以让你把微信的聊天记录导出备份，可以在完全脱离微信的情况下随时调取查看聊天数据。
本文介绍的软件可以导出两种格式的聊天记录备份文件，一种是表格，一种是网页。
导出表格的好处是文本紧凑，篇幅小，缺点是聊天记录中的图片、语音、视频、文件，不能直接打开，但是会帮你单独放到文件夹中。
导出到网页的估缺点和导出表格的正好相反，页面是啰嗦点，但是所有的内容都可以在一个页面上看完，可以看图片、听语音、播视频、开视频
以下是具体方法
首先准备好以下需要用到的东西：
1，一台电脑
2，有你微信的手机
3，你的微信
4，【微信聊天记录挖掘机】工具，点此获取
下面开始搞
首先是第一部分：迁移手机数据到电脑
注意，如果你已经是日常在电脑上使用微信了，那微信的数据都在电脑上，就不用看第一部分了，请直接看下面第二部分，也就是直接看电脑上的操作，不用再搞手机上的了。
一，电脑保持与手机处于同一WIFI或者同一网络下，然后电脑登录微信，电脑登录微信后，手机上的微信需要按以下操作，点右下角【我】-【设置】
二、然后点【聊天】
三、下一步点【聊天记录迁移与备份】，此处是以安卓为例，如果你是苹果手机，这里不一定有这个菜单，可能在其它菜单里，你自己找找看吧
四、然后选择【迁移】-【迁移到电脑】
五、如果你要迁移和导出所有的聊天记录，那下一个页面选择绿色的【迁移全部聊天记录】按钮，如果你只需要导出部分聊天的记录，那就选择【迁移部分聊天记录】，如下图
六、然后就开始迁移，需要一些时间，等待迁移完成后，进入第二部分的操作
第二部分，电脑上的操作
一、经过上面的步骤，数据已经到了电脑上，你可以找一个数据时间久远一点的人，手动过一遍数据，相当于让微信传到电脑上的内容做一次解析，这样导出才能完整，以下举例，在电脑版微信上找一个人，在他的窗口右上角点【菜单】-【聊天记录】
二、然后会打开下面的页面
三、在这个页面按住【page up】键，让数据快速地在这里过一遍，如果卡住，就反向滚一下鼠标，让它能继续滚，一直滚到顶
然后关掉微信，再重新登录微信，这一步非常重要，一定要重启微信才行。
四、然后就要操出数据导出软件来导出聊天记录了，获取【微信聊天记录挖掘机】软件，完整地对压缩包解压出来放在桌面，双击软件图标，打开软件
五、软件打开后，软件界面如下
六，第一个格子，是【微信个人数据文件夹】，这个文件夹怎么找到呢，很简单，点微信窗口左下角的【菜单】-【设置】
七、在打开的页面点【文件管理】-【打开文件夹】
八、电脑就会直接帮你打开个人数据文件夹了，如下图
九、复制这个文件夹的路径
十、把复制的这个路径粘贴到软件的【微信个人数据文件夹中】
然后第二个格子选择一个你想要保存聊天记录到哪里的文件夹
如果想导出网页，软件界面里有【保存为网页HTML文件】的选项，勾上它
然后点击【一键导出所有聊天记录】，最终如下
十一、稍等一下它导出，导出成网页后，就可以去导出的文件夹那里查看了，双击聊天记录文件，就可以看到聊天内容，其中语音可以在页面中直接播放
十二、视频也可以播放
十三、不过如果你的语音或者视频什么的，历史比较久远，数据已经没有了，那在播放这里就是灰色的，说明没有数据，不过这种情况比较少
十四、到这里，就介绍完全了，如果有需要可以试试看，并且软件还有不少其它的选项功能，按自己的需要选择即可，比如可以指定导出某个人或者某个群的，也可以选择只导出某个时间段的等等，有需要可以自己探索下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/823761dc6b19675d7b569d02db21b635/" rel="bookmark">
			JavaWeb——基于Spring Boot的图书数字化管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程设计总结
1 概述 1.1 项目开发背景 随着信息技术的快速发展，数字化管理已经成为各行各业提高效率和管理水平的重要手段。在图书管理领域，数字化管理系统可以有效地提高管理效率，提供更好的用户体验。本项目旨在开发一个基于Spring Boot的图书数字化管理系统，为管理员和读者提供便捷的操作和管理功能。
自动化管理需求：传统的图书管理往往涉及大量的人工操作，包括手动记录借还信息、图书分类整理和查询等。通过开发一个数字化管理系统，可以实现自动化的图书管理，减少人力成本和提高工作效率。提升用户体验：对于图书馆或图书管理机构而言，提供一个方便易用的系统可以提升用户的体验和满意度。数字化管理系统可以提供在线图书查询、预约借阅、自助借还等功能，方便用户快速获取所需图书，并且减少繁琐的手续。数据统计和分析：数字化管理系统可以收集和存储大量的图书相关数据，包括借还记录、读者偏好、图书馆资源利用情况等。通过对这些数据进行统计和分析，可以为图书馆管理者提供决策支持，例如优化图书采购、调整借阅规则、推荐相关图书等。安全和保护：数字化管理系统可以加强对图书和图书借阅信息的安全管理。通过权限控制和身份验证，确保只有授权人员可以进行借阅操作，并保护读者隐私和借阅记录的安全。 通过这个基于Spring Boot的图书数字化管理系统，管理员和读者可以在线完成相关操作和管理流程，提高了管理效率，提供了更好的用户体验。同时，系统还具备安全性高、易于扩展和维护等特点，为图书管理提供了新的解决方案。
1.2 开发工具 本项目采用Windows 10和IntelliJ IDEA进行系统开发。
1.3 采用的技术 本项目主要采用的技术有Java、MySQL、Maven、SpringBoot、Mybatis-Plus、MySQL、Vue3、ElementPlus等。
l Java：Java是一种广泛使用的编程语言，它适用于各种领域，包括桌面应用程序、移动应用程序、网络应用程序等。
l MySQL：MySQL是一种流行的开源关系数据库管理系统，它使用SQL语言作为查询语言，它被广泛应用于各种应用程序中，如Java、Python等。
l Maven：Maven是一个用于管理Java项目的工具，它可以帮助构建、打包和部署Java应用程序，它还可以管理项目的依赖关系。
l SpringBoot：SpringBoot是一个用于快速构建基于Spring框架的Java应用程序的工具，它通过自动配置和快速开发接口简化了Java开发。
l Mybatis-Plus：Mybatis-Plus是一个增强Mybatis的插件，它提供了更简单的API和更强大的功能，如全表操作、分页查询等，可以更方便地使用Mybatis进行数据库操作。
l Vue3：Vue3是Vue.js框架的最新版本，它提供了一个强大的API，用于构建可复用的组件，并使用虚拟DOM来实现快速、高效的渲染。
l ElementPlus：ElementPlus是Element UI的升级版，它提供了更多主题和组件，可以快速构建美观的Web应用程序界面。
1.4 项目成员 项目成员如表 1‑1 项目成员表 1‑1所示。
表 1‑1 项目成员
姓名
职位
负责范围
项目经理
负责设计系统架构，并整合资料
系统分析师
负责对系统的可行性进行分析，并编写实现与测试的内容
设计师
负责对前端页面的设计，并编写界面设计和数据库设计的内容
前端开发
负责前端开发，并编写概述以及开发日志
后端开发
负责后端开发，并编写接口设计
测试工程师
负责测试系统，并编写实验总结
运维工程师
负责运维系统，并编写系统分析的内容
2 系统分析 2.1 需求分析 基于Spring Boot框架的数字化图书管理系统的需求分析包括账号管理、图书管理、借阅关系管理和操作台统计信息显示等功能模块。系统需要提供普通用户界面和管理员界面，普通用户和管理员都能借阅图书，管理员能够管理用户账号。此外，系统应具备统计功能，能够实时显示网站访问次数、用户数量、借阅数量和图书总量等统计信息。通过SSM框架的技术实现，系统能够实现用户注册、登录、图书录入、借阅操作和管理功能，满足用户的数字化图书管理需求。
2.1.1 成本考虑
在开发数字化图书管理系统的需求分析中，成本考虑是一个重要因素。团队规模为七人、时间限制为一周，资金不计。成本考虑包括人力成本、开发工具和环境成本、项目管理成本、硬件和基础设施成本，以及培训和支持成本。在评估成本时，需要综合考虑团队投入工时、技能水平、开发工具和基础设施需求，确保在给定时间内能够实现核心功能，并根据实际情况进行权衡和决策。
2.1.2 技术考虑
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/823761dc6b19675d7b569d02db21b635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4c91453f2e27e7d0d37776b19e32865/" rel="bookmark">
			【C语言 | 预处理】C语言预处理详解(一) —— #define、#under、#if、#else、#elif、#endif、#include、#error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😁博客主页😁：🚀https://blog.csdn.net/wkd_007🚀
🤑博客内容🤑：🍭嵌入式开发、Linux、C语言、C++、数据结构、音视频🍭
🤣本文内容🤣：🍭介绍🍭
😎金句分享😎：🍭🍭
本文未经允许，不得转发！！！
目录 🎄一、概述🎄二、宏定义(#define、#under)✨2.1 数值宏常量✨2.2 字符串宏常量✨2.3 用 #define 宏定义表达式✨2.4 #under 🎄三、条件编译(#if、#else、#elif、#endif)🎄四、文件包含(#include)🎄五、#error 预处理🎄六、总结 🎄一、概述 ANSI标准的C语言预处理指令，见下表：
预处理名称意 义#define宏定义#undef撤销已定义过的宏名#include使编译程序将另一源文件嵌入到带有#include 的源文件中#if #if 的一般含义是如果#if 后面的常量表达式为 true， 则编译它与#endif 之间的代码，否则跳过这些代码。
命令#endif 标识一个#if 块的结束。 #else命令的功能有点象 C 语言中的 else ， #else 建立另一选择（在# if 失败的情况下）。
#elif 命令意义与 else if 相同，它形成一个 if else-if 阶梯状语句，可进行多种编译选择。 #else#elif#endif#ifdef用#ifdef 与#ifndef 命令分别表示“如果有定义”及“如果无定义”，是条件编译的另一种方法。#ifndef#line 改变当前行数和文件名称，它们是在编译程序中预先定义的标识符命令的基本形式如下：
#line number["filename"] #error 编译程序时，只要遇到 #error 就会生成一个编译错误提示消息，并停止编译 #pragma 为实现时定义的命令，它允许向编译程序传送各种指令例如，编译程序可能有一种选择，它支持对程序执行的跟踪。可用#pragma 语句指定一个跟踪选择。 另外 ANSI 标准 C 还定义了如下几个宏：
__LINE__ 表示正在编译的文件的行号
__FILE__ 表示正在编译的文件的名字
__DATE__ 表示编译时刻的日期字符串，例如： “25 Dec 2007”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4c91453f2e27e7d0d37776b19e32865/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1999ed723dc828b8b8d2454708937c7/" rel="bookmark">
			hive有经典的列转行，但行转列也不应该忽略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、行转列 行转列：将多个列中的数据在一列中输出
列转行：将某列一行中的数据拆分成多行
1、concat concat(string1/col, string2/col, …)
输入任意个字符串(或字段,可以为int类型等)，返回拼接后的结果
select concat(id,'-',name,'-',age) from student;
2、Concat_ws concat_ws(separator, str1, str2, …)
特殊形式的 concat()，参数只能为字符串，第一个参数为后面参数的分隔符
分隔符可以是与后面参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间;
select concat_ws('-', name, gender) from student;
3、collect_set（聚合，返回数组类型） collect_set(col)
将某字段进行去重处理，返回array类型；该函数只接受基本数据类型
select collect_set(age) from student;
4、同理，collect_list collect_set 与 collect_list 的区别就是set去重，list不去重
5、行转列常用函数还有 case when case when &lt;expr&gt; then &lt;result&gt;…else &lt;default&gt; end
if(expr, true_result, false_result)
case when 语句是SQL中的一个非常重要的功能，可以完成很多复杂的计算，相当于一个表达式，可以放在任何可放表达式的地方。
语法 case when 条件 then 结果 when 条件 then 结果 else end。else可不加，是缺省条件下的值，如果不加，有缺省情况则为NULL。CASE WHEN还可以和GROUP BY 语句搭配使用，用在sum,count,max等聚合函数内部。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1999ed723dc828b8b8d2454708937c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b8af0e5138c73cc8fc72e46535bda22/" rel="bookmark">
			ChatGLM两代的部署/微调/实现：从基座GLM、ChatGLM的LoRA/P-Tuning微调、6B源码解读到ChatGLM2的微调与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 随着『GPT4多模态/Microsoft 365 Copilot/Github Copilot X/ChatGPT插件』的推出，绝大部分公司的技术 产品 服务，以及绝大部分人的工作都将被革新一遍
类似iPhone的诞生 大家面向iOS编程 有了App Store现在有了ChatGPT插件/GPT应用商店，以后很多公司 很多人面向GPT编程(很快技术人员分两种，一种懂GPT，一种不懂GPT) 然ChatGPT/GPT4基本不可能开源了，而通过上篇文章《
LLaMA的解读与其微调：Alpaca-LoRA/Vicuna/BELLE/中文LLaMA/姜子牙/LLaMA 2》可知，国内外各大公司、研究者推出了很多类ChatGPT开源项目，比如LLaMA、BLOOM
第一部分 国内的GLM框架与类ChatGPT项目ChatGLM-6B 1.1 GLM: General Language Model Pretraining with Autoregressive Blank Infilling 1.1.1 GLM结构：微改transformer block且通过自定义attention mask兼容GPT BERT T5三种结构 在2022年上半年，当时主流的预训练框架可以分为三种：
autoregressive，自回归模型的代表是单向的GPT，本质上是一个从左到右的语言模型，常用于无条件生成任务（unconditional generation），缺点是无法利用到下文的信息autoencoding，自编码模型是通过某个降噪目标(如掩码语言模型，简单理解就是通过挖洞，训练模型做完形填空的能力)训练的语言编码器，如双向的BERT、ALBERT、RoBERTa、DeBERTa
自编码模型擅长自然语言理解任务（natural language understanding tasks），常被用来生成句子的上下文表示，缺点是不适合生成任务encoder-decoder，则是一个完整的Transformer结构，包含一个编码器和一个解码器，以T5、BART为代表，常用于有条件的生成任务 （conditional generation）
细致来说，T5的编码器中的注意力是双向，解码器中的注意力是单向的，因此可同时应用于自然语言理解任务和生成任务。但T5为了达到和RoBERTa和DeBERTa相似的性能，往往需要更多的参数量 这三种预训练模型各自称霸一方，那么问题来了，可否结合三种预训练模型，以成天下之一统？这便是2022年5月发表的这篇论文《GLM: General Language Model Pretraining with Autoregressive Blank Infilling》的出发点，它提出了GLM架构
首先，GLM框架在整体基于Transformer基础上，做了以下三点微小改动
论文中说的是，重新排列了层归一化和残差连接的顺序
we rearrangethe order of layer normalization and the resid-ual connection, which has been shown critical forlarge-scale language models to avoid numericalerrors (Shoeybi et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b8af0e5138c73cc8fc72e46535bda22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58348337fb3a65b61f00ca8087e0a010/" rel="bookmark">
			HBuilderX,uni-app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考:
uni-app官网
一，项目创建，运行 23年-uniapp多端零基础入门到项目实战
二，项目结构 node_modules ——放置项目的依赖文件 src ——放置开发的代码文件 pages ——放置页面文件 static ——放置静态文件 App.vue ——页面入口文件 env.d.ts ——.vue文件的类型说明文件 main.ts ——程序的入口文件，加载各种公共组件 manifest.json ——5+App拓展文件，打包app时要使用 pages.json ——全局配置文件，配置页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar等等 uni.scss ——uniapp的默认css样式 .gitignore ——git忽略文件 index.html ——项目总的入口文件 package.json ——项目依赖的描述文件 pnpm-lock.yaml ——锁定项目的依赖包版本 tsconfig.json ——TS的语法识别和执行配置文件 vite.config.ts ——编译工具vite的配置文件 1，配置导航页面 pages.json "tabBar": { "list": [ { "pagePath": "pages/index/index", "text": "⾸⻚" }, { "pagePath": "pages/mine/mine", "text": "我的" } ] } 2 页面跳转 a,组件式跳转 // 路径传递参数 ?title=hello &lt;navigator url="/pages/about/index?title=hello" open-type="navigate" hover-class="navigator hover"&gt; 去个⼈中⼼ &lt;/navigator&gt; // 接受参数 onLoad((option)=&gt;{ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58348337fb3a65b61f00ca8087e0a010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84951962de628573353d91709700ad4c/" rel="bookmark">
			hadoop-3启动报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ERROR: Attempting to operate on hdfs namenode as root ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation. Starting datanodes ERROR: Attempting to operate on hdfs datanode as root ERROR: but there is no HDFS_DATANODE_USER defined. Aborting operation. Starting secondary namenodes [localhost.localdomain] ERROR: Attempting to operate on hdfs secondarynamenode as root ERROR: but there is no HDFS_SECONDARYNAMENODE_USER defined. Aborting operation.
在/etc/profile.d/xxx.sh添加配置
#hadoop-3.1.0必须添加如下5个变量否则启动报错，hadoop-2.x貌似不需要
export HDFS_NAMENODE_USER=root
export HDFS_DATANODE_USER=root
export HDFS_SECONDARYNAMENODE_USER=root
export YARN_RESOURCEMANAGER_USER=root
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84951962de628573353d91709700ad4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c8821a1901252e39b3ab4b1374ea8bc/" rel="bookmark">
			【考研数据结构代码题4】求树中度为1的结点数（递归方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：用C语言描述树的孩子兄弟链表结构，并编写递归程序求树中度为1的结点数
难度：★★
算法思路：递归地遍历当前结点的左孩子子树与右兄弟子树，分别求二者中度为1的结点数记为h1,h2,若当前结点仅有1个结点，（即左孩子没有右兄弟时）那么总的度为1的结点数为sum1+sum2+1，否则为sum1+sum2 //树的左孩子右兄弟链表结构 typedef struct node{ int data; struct node *lchild,*rbro;//lchild表示左孩子，rbro表示右兄弟 }node; //统计树中度为1的结点树 int SumOneDegree(node *Tree){ int sum1,sum2;//分别代表当前结点左孩子、右兄弟子树中度为1的总结点数 //判空 if(!T){ return 0; }else{ sum1=SumOneDegree(Tree.lchild); sum2=SumOneDegree(Tree.rbro); //判断当前结点是否只有一个孩子，若是则度为1 if(Tree.lchild&amp;&amp;!Tree.lchild.rbro){ return (sum1+sum2+1); }else{ return (sum1+sum2); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091c166591005cc66f9462ea7b3cc7d0/" rel="bookmark">
			ST表与RMQ（倍增表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【概述】 RMQ : Range Maximum/minimum Query 这就是指区间最大或最小值（区间最值）
ST表：Spars Table，一种可以解决 RMQ 的，基于倍增的数据结构，利用 ST 算法预处理打出的表，称为 ST 表。
ST 算法：对于 RMQ 问题，给出 n 个数 m 次询问，每次询问区间最值，当 m 较小时，使用暴力即可解决，但随着 m 的增大，O(logn) 的的询问处理已经不够，需要 O(1) 的询问。而 ST 算法可以在 O(nlogn) 时间内进行预处理，然后在 O(1) 时间内回答每个查询，其实际上就是一种动态规划与打表的思想，缺点是不支持修改操作。
一、原理 要在 O(1) 求出区间的最值，一个很自然的想法是用动态规划处理的方法，用 dp[i][j] 来记录从i 个数开始，长度为j的区间的最大值，这样显然有状态转移方程：dp[i][j]=max(dp[i][j-1],a[i+j-1])。
dp[][]1234567891015577121212121215237712 1212121215　377121212121215　42121212121215　5121212121215　6166815　766815　84815　9815　1015　但这样预处理是 O(n*n) 的，所以还要进一步的优化。
1、预处理（创建ST表） max 函数满足一个性质：允许区间重叠，即 max(i,j)=max( max(i,k) , max(k,j) )，也就是说，可以由两个较小的有重叠的区间，直接推出一个大区间，从而减少维护的区间数量。
例如：有数组A 为：5 3 7 2 12 1 6 4 8 15 则下表为该数组的ST表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091c166591005cc66f9462ea7b3cc7d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e51fb1c1a878eb0d4864b7396dc0094/" rel="bookmark">
			STL详解（五） 双端队列容器deque
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、deuqe简介 １、deuqe概念 容器deque和vector非常相似，属于序列式容器。都是采用动态数组来管理元素，提供随机存取，并且有着和vector一样的接口。不同的是deque具有首尾两端进行快速插入、删除的能力。
２、Deque结构 如图1是deque的逻辑结构，从表面上看，deque具有连续性的存储空间，并支持随机存取功能。实际上deque并不是我们所看到的样子，其内部结构，如图2所示。
deque在实现上主要有以下两点：
1.由一段一段的定量连续空间构成，第一个区块朝某个方向扩展，最后一个区块朝相反方向扩展；
2.管理这些分段的定量连续空间，维护其整体连续的假象，并提供随机存取的接口；
图 1 deque的逻辑结构
图 2 deque的内部结构
３、Deque的能力 与vector相比，deque功能上的不同之处在于：
首尾两端都能快速的安插、删除元素，因此需要在两端安插、删除元素时，最好采用deque。 存在元素时，deque的内部结构会多一个间接过程，操作元素的效率会比vector低一些。迭代器需要在不同区块间跳转，所以必须是特殊的智能指针，非一般指针。deque不支持对容量和内存重分配时机的控制，除了首尾两端安插、删除元素外，其他地方安插、删除元素都将导致元素的pointer、reference、iterator失效。不过，deque的内存重分配机制优于vector，因为deque不必在内存重分配时复制所有的元素。deque的内存区块不再被使用时，会被释放。在建立vector容器时，一般来说伴随这建立空间-&gt;填充数据-&gt;重建更大空间-&gt;复制原空间数据-&gt;删除原空间-&gt;添加新数据，如此反复，保证vector始终是一块独立的连续内存空间；在建立deque容器时，一般便随着建立空间-&gt;建立数据-&gt;建立新空间-&gt;填充新数据，如此反复，没有原空间数据的复制和删除过程，是由多个连续的内存空间组成的。
使用区别：
1 如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector 2 如果你需要大量的插入和删除，而不关心随即存取，则应使用list 3 如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque
４、deque的操作函数： Deque的操作函数和vector操作函数基本一模一样，duque的各项操作只有以下几点和vector不同：
１、deque不提供容量操作( capacity()、reserve() )
２、deque提供push_front()、pop_front()函数直接操作头部
５、Deque的特点： １、支持随机访问，即支持[ ]以及at()，但是性能没有vector好。
２、可以在内部进行插入和删除操作，但性能不及list。
３、deque两端都能够快速插入和删除元素，而vector只能在尾端进行。
４、deque的元素存取和迭代器操作会稍微慢一些，因为deque的内部结构会多一个间接过程。
５、deque迭代器是特殊的智能指针，而不是一般指针，它需要在不同的区块之间跳转。
６、deque可以包含更多的元素，其max_size可能更大，因为不止使用一块内存。
７、deque不支持对容量和内存分配时机的控制。
８、在除了首尾两端的其他地方插入和删除元素，都将会导致指向deque元素的任何pointers、references、iterators失效。不过，deque的内存重分配优于vector，因为其内部结构显示不需要复制所有元素。
９、deque的内存区块不再被使用时，会被释放，deque的内存大小是可缩减的。不过，是不是这么做以及怎么做由实际操作版本定义。
１０、deque不提供容量操作：capacity()和reverse()，但是vector可以。
二、成员函数列表 c.assign(beg,end) 将[beg; end)区间中的数据赋值给c。
c.assign(n,elem) 将n个elem的拷贝赋值给c。
c. at(idx) 传回索引idx所指的数据，如果idx越界，抛出out_of_range。
c.back() 返回容器c的最后一个元素的引用。如果c为空，则该操作未定义。
c.begin() 传回迭代器中的第一个数据地址。
c.clear() 移除容器中所有数据。
c.empty() 判断容器是否为空。
c.end() 返回一个迭代器，它指向容器c的最后一个元素的下一位置。
c.erase(pos) 删除pos位置的数据，传回下一个数据的位置。
c.erase(beg,end) 删除[beg,end)区间的数据，传回下一个数据的位置。
c.front() 返回容器c的第一个元素的引用。如果c为空，则该操作为空。
get_allocator 使用构造函数返回一个拷贝。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e51fb1c1a878eb0d4864b7396dc0094/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bf9c429e1857c53f1b65032708d229/" rel="bookmark">
			linux 防火墙操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言一、 关闭iptables防火墙端口？二、关闭firewalld防火墙端口三、检查防火墙状态三、查看已经开放的端口四、检测已经开放的特定端口五、开放端口 前言 服务器安装宝塔后我的docker里面的minio服务突然不能用了，但是minio容器是正常的，经过各种排查发现我的linux 防火墙被打开了（本来是没有打开的，具体不知道原因，我怀疑是宝塔搞得鬼。。。。）。而且相关的端口并没有开放。排查花费了一点时间 所以记录一下。
在Linux操作系统中，防火墙是一项重要的安全措施，用于保护计算机免受未经授权的访问和恶意攻击。有时候，为了满足特定的网络需求或进行网络测试，我们可能需要关闭或者防火墙或特定的防火墙端口,防火墙工具有多种，如iptables和firewalld。下面将介绍如何使用防火墙。
一、 关闭iptables防火墙端口？ sudo iptables -A INPUT -p tcp --dport [端口号] -j DROP 上述命令将会向iptables防火墙添加一个规则，使得TCP协议、指定端口号的进入流量被丢弃。这样，该端口将会被关闭，并且无法访问。
如果您希望在重启系统后仍然保持该端口关闭状态，您可以保存iptables规则：
sudo service iptables save 二、关闭firewalld防火墙端口 sudo firewall-cmd --zone=public --remove-port=[端口号]/tcp --permanent sudo firewall-cmd --reload 第一条命令将会从firewalld防火墙中移除指定的TCP端口号，第二条命令将使更改生效
三、检查防火墙状态 systemctl status firewalld 三、查看已经开放的端口 firewall-cmd --list-ports sudo iptables -L-n| grep 端口号 四、检测已经开放的特定端口 sudo firewall-cmd --zone=public --query-port=80/tcp sudo iptables -L -n | grep 80 测试：
五、开放端口 如果发现没有我们需要的的端口 开启端口，例如此时需要8080端口
firewall-cmd --permanent --zone=public --add-port=8080/tcp sudo firewall-cmd --reload # 重新载入firewalld配置 sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 开放80端口 sudo service iptables save # 保存iptables配置 sudo service iptables restart # 重启iptables服务 在这里，--zone=public 表示添加到公共区域，--add-port=80/tcp 表示添加TCP协议的80端口， --permanent 表示将该规则持久化保存。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0668803b785c31a8c8cddefe99561bd/" rel="bookmark">
			STL详解（四） 优先对列容器priority queue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、优先队列priority_queue简介 priority_queue（优先队列）允许用户为队列中元素设置优先级，放置元素的时候不是直接放到队尾，而是放置到比它优先级低的元素前面。
priority_queue有三个模板参数：priority_queue&lt;Type, Container, Functional&gt;，其中后两个可以省略。
Type :为数据类型，
Container: 为保存数据的容器，必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector。
Functional :为元素比较方式。基本数据类型或已定义了比较运算符的类，可以直接用STL的less算子和greater算子——默认使用less算子，即小的往后排，大的往前排，大的先出队（出队时，序列顶的最大的元素出队）。
对于greater 算子大的往后排，小的往前排，小的先出队（出队时，序列顶的最小的元素出队）。
二、定义priority_queue对象 示例代码如下：
priority_queue&lt;int&gt; q1;
priority_queue&lt;pair&lt;int,int&gt;&gt; q2;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q3;//定义优先级小的先出队
三、成员函数列表及详细说明： empty() 如果队列为空返回真
pop() 删除队顶元素
push() 加入一个元素
size() 返回优先队列中拥有的元素个数
top() 返回优先队列队顶元素（队列中的front()变成了top()）
在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。
注意：priority queue和 queue不同的是，priority queue没有j back() 和 front() ，而只能通过top()或pop() ,访问队尾元素（也称堆顶元素），也就是优先级最高的元素。
1、int 类型比较（默认从大到小，大的先出）
#include &lt;bits/stdc++.h&gt; using namespace std; int main () {	priority_queue&lt;int&gt; q; q.push(1); q.push(5); q.push(3); q.push(9); q.push(2); cout&lt;&lt;q.top()&lt;&lt;endl; q.pop(); cout&lt;&lt;q.top()&lt;&lt;endl; system("pause"); return 0; } 结果为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0668803b785c31a8c8cddefe99561bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66d56cc703a903ad4325c1c2b5088742/" rel="bookmark">
			STL详解（二） 栈容器Stack
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Stack简介 stack 是容器适配器的一种。要使用 stack，必须包含头文件 &lt;stack&gt;。
stack就是“栈”。栈是一种后进先出的元素序列，访问和删除都只能对栈顶的元素（即最后一个被加入栈的元素）进行，并且元素也只能被添加到栈顶。栈内的元素不能访问。如果一定要访问栈内的元素，只能将其上方的元素全部从栈中删除，使之变成栈顶元素才可以。
容器适配器中的数据是以 LIFO 的方式组织的，这和自助餐馆中堆叠的盘子、箱子中的一堆书类似。下图展示了一个理论上的 stack 容器及其一些基本操作。只能访问 stack 顶部的元素；只有在移除 stack 顶部的元素后，才能访问下方的元素。
思考：１、如果进站的车厢序列为１２３，则可能的出站车厢序列是哪些？　会有312吗？
２、如果进站的车厢序列为123456，问能否得到135426和435612的出站序列？
1.stack对象的默认构造
stack采用模板类实现， stack对象的默认构造形式： stack &lt;T&gt; stkT; stack &lt;int&gt; stkInt; //一个存放int的stack容器。
stack &lt;float&gt; stkFloat; //一个存放float的stack容器。
stack &lt;string&gt; stkString; //一个存放string的stack容器。 //尖括号内还可以设置指针类型或自定义类型。
二、成员函数详解 stack&lt;int&gt; a;
1、a.push(6) 往栈头添加元素6
2、a.pop() 从栈头移除第一个元素
3、a.top() 提取最后一个压入栈元素
4、a.empty(); 判断堆栈a是否为空
5、a.size(); 返回堆栈a的大小
6、stack &lt;int&gt; b(a) 拷贝栈a给栈b
7、b=a 栈a赋值给栈b
１.stack的进栈与出栈方法：（push()与pop()）
stack.push(elem); //往栈头添加元素stack.pop(); //从栈头移除第一个元素 #include&lt;bits/stdc++.h&gt; using namespace std; void objPlay2() { stack&lt;int&gt; stkInt; stkInt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66d56cc703a903ad4325c1c2b5088742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d3411bfc9050cbc886c941b1741615/" rel="bookmark">
			STL详解（九） 映射容器map
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、map简介 1、 什么是Map Map是STL的一个关联容器，翻译为映射，数组也是一种映射。如：int a[10] 是int 到 int的映射，而a[5]=25,是把5映射到25。数组总是将int类型映射到其他类型。这带来一个问题，有时候希望把string映射成一个int ，数组就不方便了，这时就可以使用map。map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）。
map提供关键字到值的映射 ，其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个称为该关键字的值，由于这个特性.
普通 int 数组是 map&lt;int ,int &gt; a。字符到整型的映射，就是 map&lt;char ,int &gt; a，而字符串到整型的映射，就必须是 map&lt;string , int &gt; a。map的键和值也可以是STL容器，如 map&lt; set&lt;int&gt; ,string&gt; a,而且键和值都是唯一的。
map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。
map的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。对于迭代器来说，可以修改实值，而不能修改key。
2、map的功能 自动建立Key － value的对应。key 和 value可以是任意你需要的类型。 根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。 快速插入Key -Value 记录。快速删除记录根据Key 修改value记录。遍历所有记录。 3、使用map map对象是模板类，需要关键字和存储对象两个模板参数：
std:map&lt;int,string&gt; personnel;
这样就定义了一个用int作为索引,并拥有相关联的指向string的指针。为了使用方便，可以对模板类进行一下类型定义，
typedef map&lt;int,CString&gt; mapc
mapc enumMap;
二、 map的基本操作函数： begin() 返回指向map头部的迭代器
end() 返回指向map末尾的迭代器
rbegin() 返回一个指向map尾部的逆向迭代器
rend() 返回一个指向map头部的逆向迭代器
lower_bound() 返回键值&gt;=给定元素的第一个位置
upper_bound() 返回键值&gt;给定元素的第一个位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d3411bfc9050cbc886c941b1741615/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f237be2a04c1124a4fc3606117f1320/" rel="bookmark">
			用idea23做简单的javaweb项目（servlet）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我这里是想做一个日志，顺便把学的一个项目记录一下，适合小白，大佬勿喷，哈哈哈！
实验目标 1. 掌握Web程序中使用javabean实现业务逻辑
2. 熟练使用IDE开发Servlet应用
3. 掌握Servlet3.0的注解功能
实验分析 前端部分，通过编写静态页面 &lt;form&gt; 实现添加后台部分，即Servlet代码, 实现数据添加 实验内容 （1）实验目的与原理
掌握数据连接的基础知识
（2）实验内容与步骤
通过web页面实现用户与学生信息的录入与修改等功能；
首先把代码呈上
先创建一个StudentServlet.java文件
import javax.servlet.RequestDispatcher; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet("/StudentServlet") /*这里是一个很简单的注释，由是 Java Servlet 3.0 规范中引入的注解*/ public class StudentServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding("UTF-8");//这里是定义编码的规则 //这里就是一系列的定义变量，从下面的页面拿值过来 String name = request.getParameter("name"); String studentId = request.getParameter("studentId"); int age = Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f237be2a04c1124a4fc3606117f1320/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b3948f5a292d4fc433d84220f78013/" rel="bookmark">
			numactl 设置numa内存分配规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		numactl命令的主要功能用来绑核和绑numa内存，比如：
运行如下命令，通过strace来系统调用： strace numactl --membind=0,1 --cpunodebind=0,1 pwd 输出： ..... 设置进程的亲和性。 sched_setaffinity(0, 512, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ...]) = 0 省略 设置内存的分配规则 set_mempolicy(MPOL_BIND, [0x0000000000000003, 000000000000000000, 000000000000000000, 000000000000000000], 257) = 0 .... 上面对应了内核中具体的系统调用实现函数：
sched_setaffinity：sched_setaffinity //kernel/sched/core.c
set_mempolicy:do_set_mempolicy //mm/mempolicy.c
numactl分配的内存策略， 1. 缺省(default)：总是在本地节点分配（分配在当前进程运行的节点上）；
2. 绑定(bind)：强制分配到指定节点上；
3. 交叉(interleave)：在所有节点或者指定的节点上交织分配；
4. 优先(preferred)：在指定节点上分配，失败则在其他节点上分配。
numactl 设置内存策略的参数，互相冲突，只能选择一个 [ --interleave nodes ] [ --preferred node ] [ --membind nodes ] 内核也有对应的枚举类型，include/uapi/linux/mempolicy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b3948f5a292d4fc433d84220f78013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e70f4dc088058a5806e50ecec775c2f1/" rel="bookmark">
			Linux内核密码模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
密码算法介绍
Hash摘要算法
Cipher加解密算法
块密码算法
认证算法 MAC和HMAC
AEAD算法
Linux内核密码模块的基本构件
Linux内核密码模块介绍
如何使用Linux密码模块
用户层调用Linux内核密码模块的方法
cryptodev
AF_ALG
如何开发一个密码引擎驱动
开发一个密码引擎驱动的流程
以cbc(aes)算法为例的实际代码示例
密码算法介绍 密码算法主要是为了保护双方或者多方的通信，涉及到保密性、完整性和可认证性。
Hash摘要算法 Hash或Digest是属于完整性，根据指定输入得到“唯一”校验值，比如SHA1，MD5，等等。
针对HASH算法的三个标准：
1、尽可能少的碰撞出相同的摘要值
2、不可能根据摘要值重新生成原数据
3、一个小的修改就能生成完成不同的摘要值
Cipher加解密算法 要求使用一组或者几组数据来加密/解密数据
Cipher算法可以分为流密码算法和块密码算法，还可以分为对称密码算法和非对称密码算法。
其中流密码算法是对一串流数据加密，块密码算法需要限定数据大小的数据块；
其中对称密码算法是指加解密都使用相同的密钥，非对称密码算法加密使用公钥，解密使用私钥。有AES,RSA算法等
块密码算法 块密码算法只能对一小块数据进行加解密，我们需要找个方法来处理任意长度的数据，大部分的块密码算法都要求有Initialization Vector（IV）来混淆加密数据。此算法模式有ECB，CBC等。
认证算法 MAC和HMAC MAC代表消息认证码，用来认证发送者消息的机制，使用一组密钥和转化算法来生成认证码，使用HASH算法就叫HMAC。
AEAD算法 AEAD算法表示对数据进行认证加密，把认证，加密和摘要一步完成。
Linux内核密码模块的基本构件 Linux内核密码模块介绍 Linux密码模块的基本构件主要为两个结构体：struct crypto_alg和struct crypto_tfm。支持所有的算法，比如Cipher（加解密）、Hash（摘要）、AEAD（链式）、HMAC（认证）和Compression（解压缩）。
密码算法可以用一个基本算法构建的模块来表示，比如hmac(sha1)表示用SHA1摘要实现的HMAC算法，cbc(aes)表示使用AES的CBC模式，authenc(hmac(sha1),cbc(aes))表示使用AES-CBC加解密和SHA1做认证的链式算法，即一次完成加密和认证。
如何使用Linux密码模块 使用Linux密码模块的流程如下图所示：
左侧为流程分割，右侧为对应的实现函数。
用户层调用Linux内核密码模块的方法 用户层调用Linux内核密码模块的方法有两种，一种是cryptodev，另一种是AF_ALG。
cryptodev 据说性能超过AF_ALG使用内核密码模块内标准接口将设备暴露在/dev/crypto目录下使用ioctl函数设置密码运算上下文在OpenSSL里原生支持 AF_ALG 在Linux 2.6.38版本后支持主要通过netlink套接字实现 如何开发一个密码引擎驱动 开发一个密码引擎驱动的流程 1、Linux内核密码模块并不区分硬件引擎与软件实现
2、开发一个密码引擎就只是通过向密码模块子系统注册crypto_alg
3、辨别你想新增算法的类型并与相关的crypto_alg接口绑定，比如skcipher_alg,ahash_alg等等
4、实现xxx_alg接口内容并调用crypto_register_xxx()来向密码子系统注册
以cbc(aes)算法为例的实际代码示例 struct skcipher_alg xxx_cbc_aes_alg = { ... .base = { /* Name used by the framework to find who is implementing what.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e70f4dc088058a5806e50ecec775c2f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d42dcb28183e1376205f9ba781a042b/" rel="bookmark">
			linux 修改sshd_config报Directive xxx is not allowd within a Match block的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后续我又查了一些资料，发现Directive xxx is not allowd within a Match block这个问题，不论是什么服务，普遍都是一些新增的配置内容写的位置不对，顺序错了造成的问题。
将修改的配置放到最后执行就可以执行成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe0ad9783400cd4d26287207fb0f9e9/" rel="bookmark">
			【Java】本地开发环境正常、测试或生产环境获取的文件路径不对的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引 Java 中经常获取本地文件或者resource下的文件，要获取文件，首先要获得本地路径。
Java 本身或一些开源工具包都提供了很多获取路径的方法。但使用时经常遇到本地开发环境正常、测试或生产环境获取的文件路径不对的问题。
本文将列出几种常见的获取本地文件的方法，并对比它们在打包前后的差异。
示例代码 package com.xzbd; import java.io.File; public final class Application { public static void main(String[] args) { System.out.println("测试 Java 获取本地文件路径："); System.out.println("【User Home 路径】：\r\n\t" + getUserHome()); System.out.println("【User Dir 路径】：\r\n\t" + getUserDir()); System.out.println("【Resource 路径】：\r\n\t" + getResourcePath()); System.out.println("【Jar 路径】：\r\n\t" + getJarPath()); } public static String getJarPath() { String jarPath = Application.class.getProtectionDomain().getCodeSource().getLocation().getPath(); return new File(jarPath).getAbsolutePath(); } public static String getResourcePath() { String appPath = Application.class.getResource(File.separator).getPath(); return new File(appPath).getAbsolutePath(); } public static String getUserHome() { String userhome = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebe0ad9783400cd4d26287207fb0f9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e9cfafc8750f446ad6f543a1e63de0/" rel="bookmark">
			PPchart
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PPchart地址：https://ppchart.com/#/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b9fdfc37ccf122b7a428319e489c846/" rel="bookmark">
			Ubuntu ssh免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下ssh配置免密登录的过程。
1.服务器操作 （1）通过默认端口（22）登录服务器
（2）修改/添加端口
vi /etc/ssh/sshd_config 找到Port22处，可以添加或者修改端口，注意要把#去掉，下图是我添加了一个端口，可以用22和2023这两个端口登录了。
（3）重启一下ssh服务
service sshd restart （4）开启防火墙
sudo ufw enable （5）新端口加入防火墙
sudo ufw allow 23 （6）查看防火墙开放的端口
sudo ufw status （7）列出防火墙规则
sudo ufw show added （8）重启防火墙
sudo ufw reload 重启之后就能用新的ssh端口进行连接了。（1）（2）（3）的顺序可以和防火墙操作颠倒。
2.主机操作 ssh-keygen -t rsa -b 4096 ssh-copy-id -p 2023 xxx@xxx.xxx.xxx 可能会报错：
解决方法：
function ssh-copy-id([string]$userAtMachine, $args){ &gt;&gt; $publicKey = "$ENV:USERPROFILE" + "/.ssh/id_rsa.pub" &gt;&gt; if (!(Test-Path "$publicKey")){ &gt;&gt; Write-Error "ERROR: failed to open ID file '$publicKey': No such file"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b9fdfc37ccf122b7a428319e489c846/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb67904cb98c246107c1da921d252c7f/" rel="bookmark">
			万能在线预约小程序系统源码 适合任何行业在线预约小程序&#43;预约到店模式 带完整的搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好啊，源码小编又来给大家分享啦！随着互联网的发展和普及，越来越多的服务行业开始使用在线预约系统以方便客户和服务管理。例如，美发店、健身房、餐厅等都可以通过在线预约系统提高服务效率，减少等待时间，提升客户体验。下面小编来给大家介绍一款万能在线预约小程序系统源码。
以下是部分核心功能模板：
系统特色功能一览：
1.万能预约：本系统支持多行业门店预约，包括美发、美容、汽车服务等，消费者可以根据需要选择合适的门店进行预约。
2.实时更新：系统能够实时更新门店的服务状态、预约信息等，方便消费者及时了解门店动态，选择合适的时间进行预约。
3.个性化设置：消费者可以根据自己的需求，选择服务项目、服务时间、门店等，实现个性化预约。
4.提醒功能：系统提供提醒功能，提前提醒消费者进行预约，避免错过服务时间。
5.在线支付：系统支持在线支付功能，消费者可以在预约时选择支付方式并完成支付，减少到店支付的时间和麻烦。
页面展示：
源码下载地址：春哥技术博客——万能在线预约小程序源码系统
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4964f2529c94a31e5d92ea4a2a8b9b/" rel="bookmark">
			AT32F403A VGA(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、目的： 要用单片机实现VGA功能。
二、分析： VGA需要两根时钟信号线，分别为Hsync和Vsync。
在800*600的显示模式下，Hsync周期为26.4us，Vsync周期为16.579ms。
Hsync同步脉冲时间为3.2us，Vsync同步脉冲时间为0.106ms，而且都是高电平有效。
在AT32F403A里面，主从时钟的可以配置为主时钟输出时钟，从时钟使用主时钟输出的时钟做为计数脉冲。
三、代码 1、主时钟的配置为： void tmr_primary_mode_select(tmr_type *tmr_x, tmr_primary_select_type primary_mode)
tmr_type可以选择：
TMR1, TMR2, TMR3, TMR4, TMR5, TMR6, TMR7, TMR8
tmr_primary_select_type可以选择：
TMR_PRIMARY_SEL_RESET * - TMR_PRIMARY_SEL_ENABLE * - TMR_PRIMARY_SEL_OVERFLOW * - TMR_PRIMARY_SEL_COMPARE * - TMR_PRIMARY_SEL_C1ORAW * - TMR_PRIMARY_SEL_C2ORAW * - TMR_PRIMARY_SEL_C3ORAW * - TMR_PRIMARY_SEL_C4ORAW 2、从时钟的配置为： /*先择哪一个主时钟的输出做为输入时钟*/ void tmr_trigger_input_select(tmr_type *tmr_x, sub_tmr_input_sel_type trigger_select) /*子时钟模式，可以是编码，挂起，触发等等。这里选择TMR_SUB_EXTERNAL_CLOCK_MODE_A*/ void tmr_sub_mode_select(tmr_type *tmr_x, tmr_sub_mode_select_type sub_mode) /*开启同步模式*/ void tmr_sub_sync_mode_set(tmr_type *tmr_x, confirm_state new_state) 最后别忘记开起时钟
tmr_counter_enable(TMR3, TRUE);
四、效果： Hsync: Vsync: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9502ee36fb795b1a8a6a75b17db805f8/" rel="bookmark">
			Linux命令之find
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下命令为，清理 /data/logs文件夹下，30天前的log文件
find /data/logs -mtime +30 -name “.log.” -exec rm -f {} ;
参考：
https://www.cnblogs.com/90s-blog/p/15712981.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09bb0d4e08a1bdc656687e1a14cd2025/" rel="bookmark">
			Axure基础详解十八：气泡闪动效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果演示 说明 闪动的气泡在产品中是很常见的功能，用以动态的提示，在一些常见的大屏可视化中，均会以闪动的气泡作为一些提示符，进行动态的提示。
原理 从小到大，再从大到小的不断动态循环。
制作过程 组件 第一个添加了径向渐变填充，边缘颜色不透明度为0.
第二个上面是一个圆形，下面是一个圆环。
第三个元件库自带的“警告”图表。
设置交互 它们都是运用同一个交互
【载入时】设置大小使其变大。
【大小改变时】设置大小使其变小，触发【载入时】事件实现循环。
注意过度时间和中心点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9707565f394d74edc0422cb2cc91f9b/" rel="bookmark">
			CTF中的Misc解题思路（BUUCTF）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3、你竟然赶我走：
观察发现图片没什么特别之处，于是用010editor打开该图片，发现在结尾有flag。
4、二维码：
使用qrcode扫描后，结果如下：
将该答案输入，发现flag报错。然后，我们将该二维码放入010editor中发现其中有PK压缩包，即将文件后缀改为zip或rar，发现打开需要密码，且密码为四位纯数字，即可直接使用ARCHOR爆破即可。
5、大白 1：
根据提示和图片即可发现，图片的大小有问题，因此用010editor打开该图片修改图片的长和宽即可。
6、N种解决方法 1：
打开压缩包，发现是一个exe文件，但是无法打开，于是我们将文件后缀改为.txt打开发现有一串base64编码而成的字符串。
此时，我们发现这像是一个图片地址，我们直接将其拉入浏览器，得到一张图片，然后使用qrcode扫描得到二维码。或者使用base64转图片也可得到二维码。
7、乌镇峰会种图 1：
直接使用010editor打开，在结尾即可发现flag。
8、基础破解 1：
打开压缩包，发现需要密码，而且题目也说了是四位数的密码，即可直接使用ARCHPR进行破解得到密码。
9、wireshark 1：
直接打开流量包：
由题目可知，管理员的密码是flag，于是我们在流量包中直接查http.request.method==POST,发现只有一条过滤信息，我们打开后
发现有flag，直接复制即可。
10、文件中的秘密1：
依据题目，我们先去查看文件属性，然后在文件属性中发现了flag。
11、LSB1：
打开文件发现是一张图片，极可能是图片隐写
我们直接打开stegslove试一下，首先试下变换图片通道，发现图片上方出现一排模糊，但并没有有用信息。然后，我们尝试有analyse，发现信息开头有png。
然后，勾选save bin，将图片修改为png文件。打开图片，发现是一个二维码，然后使用扫描工具，即可得到flag。
12、Zip伪加密1：
打开压缩包，发现需要密码。根据题目意思，我们先用010editor打开文件，发现文件头和目录源中的标记都是09 00，一开始以为是真加密，于是尝试使用暴力破解，但是过了很长时间没出。因此，我觉得该方法失败。然后因为题目是伪加密，我尝试将两处都改成00 00，，最后打开发现可以打开，看见flag。
13、被嗅探的流量1：
先分别使用http流和TCP流追踪，看是否有flag。最后发现失败。
然后，我们先过滤，使用http.request.method==POST命令，然后在追踪http流，最后发现flag。
14、rar1：
根据题目意思，直接使用暴力破解，密码是四位数。即可得到flag。
15、qr：
根据题意，直接使用qrcode扫描工具就可以得到flag。
16、镜子里面的世界：
打开发现是一张图片，直接使用stegslove来打开该图片，然后点击date extract提取相应的内容。然后选择red0、green0、blue0，即可发现flag。
flag{st3g0_saurus_wr3cks}
17、ningen1：
打开压缩包发现是一个图片，但根据题意，发现本题涉及密码，应该是一个文件，于是使用010editor打开，发现里面隐藏了一个压缩包，然后将图片的后缀改成.zip。最后是用四位数的暴力破解即可得到flag。
18、小明的保险箱1：
打开发现是一张图片：
发现没什么线索，于是我们用010editor打开，发现里面有一个rar文件：
然后将文件后缀名改为.rar,再根据题目意思，保险箱密码是一个四位纯数字密码，因此直接使用暴力破解可得到flag。
19、爱因斯坦：
打开压缩包，发现一张图片，打开为：
发现图片没有什么东西，因此为我们猜测是否为图片隐写。所以我们用010editor打开发现里面有.zip压缩包：
我们将图片后缀名修改为.zip，发现需要密码。此时，我们再回过头去看图片，打开属性，发现备注：
因此，我们输入密码，顺利打开压缩包，得到flag。
20、easycap1：
打开文件，发现一串数据流，基本上都是TCP，因此我们直接使用TCP追踪流，直接得到flag。
21、隐藏的钥匙1：
打开文档，发现一张图片，什么信息都没有，于是我们用010editor打开，直接搜索flag，发现有结果：
发现要用base64解码，才能得到正确答案。
22、另外一个世界1：
打开文件，发现是一张图片：
还是没什么有用的东西，我们先用010editor打开图片，发现结尾有一串二进制数据。
然后我们先将数据转为16进制，然后再转为ASCII数据，得到flag。
23、FLAG1：
打开文档，发现是一张图片：
发现没有什么有用的东西，然后用010editor尝试，发现里面有一个.zip文件，然后将文件后缀改为.zip，发现改后缀名无效，因此，我们使用Linux命令string 文件名，即可得到hctf或直接使用ida即可得到hctf。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9707565f394d74edc0422cb2cc91f9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/144d6b3ec980762c7a8ccb5bda791792/" rel="bookmark">
			一台电脑安装多个mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.重点说明 【0.1】操作:
如果电脑以前安装过Mysql,且配置了Mysql的环境变量,就先把Mysql的环境变量给删除了(可以先用记事本临时保存一下),不确定是否配置过,就检查一下环境变量中的Path里面
重复:如果配置了环境变量一定要删除了!!!
最后是可以配置回来的,但安装过程中一定不要存在
【0.2】说明:(不想看可跳到1)
在同时配置多个mysql时,需要去执行mysql的一些安装命令,这些命令会在对应的要安装的Mysql的Mysql安装根目录\bin\文件夹下执行,以保证X版本执行的安装命令是作用于X,Y版本执行的安装命令是作用于Y。
如果在之前配置过了环境变量,环境变量中配置的是A版本的Mysql安装根目录\bin\,而我们都知道,环境变量一旦配置好,就是作用于全局的,也就是说如果配置了环境变量,即使在X版本的Mysql安装根目录\bin\下,执行安装命令,所配置的路径也不会是X的,而是A的,这样就会出问题。
1.下载地址 MySQL :: Download MySQL Community Server
2.版本选择 选择需要的版本号与操作系统(本文以Windows为例) 跳转到新页面,找到下面的"链接",点击即可下载
3.文件夹准备 原则上只要路径上没有中文即可,但比较推荐只更换盘符其余不变
选择一个盘(此处选择D盘) 创建D:/Program Files/MySQL/文件夹
将下载的压缩包解压到MYSQL下
手动创建my.ini文件和data文件夹
文件用途介绍(可跳过不看)
bin：该文件夹包含了MySQL的可执行文件， 如mysql.exe和mysqld.exe。 mysql.exe是MySQL客户端程序，用于连接和操作MySQL服务器； mysqld.exe是MySQL服务器程序，用于启动和管理MySQL数据库服务。 data: 解压完不存在的手动创建一个 该文件夹是MySQL数据库的默认存储路径，其中包含了所有数据库的数据文件和日志文件 每个数据库都有一个对应的文件夹，其中包含了该数据库的表和数据文件 etc: 没有的话不用创建(一会直接把my.ini配置在根目录下) 该文件夹包含了MySQL的配置文件，如my.ini（Windows）或my.cnf（Linux） 在配置文件中，可以设置MySQL服务器的参数，如端口号、字符集、缓存大小 lib：该文件夹包含了MySQL的动态链接库文件， 如libmysql.dll（Windows）或libmysqlclient.so（Linux） 这些库文件提供了MySQL的API接口，可以用于开发MySQL的客户端程序 share: 该文件夹包含了一些共享文件，如字符集文件和错误消息文件。 字符集文件定义了MySQL支持的字符集，错误消息文件包含了MySQL的错误码和错误信息 4.my.ini文件配置 文件如下:需要更改端口号两处,多个数据库之间的端口不能相同文件之间的路径只用/或者\\分割修改basedir修改datadir如果MySQL版本为5.7.X,在最后一行添加免登录检查 [mysqld] # 这里设置3306端口 port=3306 # 设置mysql的安装目录 basedir=D:/Program Files/MySQL/mysql-5.7.43-winx64 # 设置mysql数据库的数据的存放目录 datadir=D:/Program Files/MySQL/mysql-5.7.43-winx64/data # 允许最大连接数 max_connections=200 # 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统 max_connect_errors=10 # 服务端使用的字符集默认为UTF8 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB # 默认使用"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/144d6b3ec980762c7a8ccb5bda791792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b7caf82c88ee8522f11719e8b9b4a5/" rel="bookmark">
			Java实现日期排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
有一些日期，日期格式为“MM/DD/YYYY”。编程将其按日期大小排列。
样例输入
11/12/1999
10/21/2003
10/22/2003
02/12/2004
11/30/2005
12/31/2005
样例输出
11/12/1999
10/21/2003
10/22/2003
02/12/2004
11/30/2005
12/31/2005
代码如下：
//导包如下 import java.util.Scanner; import java.util.List; import java.util.LinkedList; import java.util.Iterator; import java.util.Collections; import java.util.Comparator; public class Main { public static void main(String[] args) { // TODO Auto-generated method stub Scanner scan=new Scanner(System.in); List&lt;String&gt; l=new LinkedList&lt;String&gt;(); while(scan.hasNext()) { String s=scan.next(); l.add(s); //修改排序方式 Collections.sort(l,new Comparator&lt;String&gt;() { public int compare(String o1, String o2) { if(Integer.parseInt(o2.split("/")[2])&lt;Integer.parseInt(o1.split("/")[2])) return 1; else if(Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22b7caf82c88ee8522f11719e8b9b4a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4d213d6a3b2cd1ddec1d43c46d892e/" rel="bookmark">
			LeetCode 515在每个树行中找最大值 116 117填充每个节点的下一个右侧节点指针(II) 104二叉树的最大深度 111二叉树的最小深度 | 代码随想录25期训练营day15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 515 在每个树行中找最大值 2023.11.8 题目链接代码随想录讲解[链接]
class Solution { public: vector&lt;int&gt; largestValues(TreeNode* root) { vector&lt;int&gt; result; if(root == NULL) return result; queue&lt;TreeNode*&gt; que; que.push(root); while (!que.empty()) { //用优先级队列，能默认排序从大到小 priority_queue&lt;int&gt; vec; int size = que.size(); while (size--) { TreeNode *temp = que.front(); que.pop(); vec.push(temp-&gt;val); if(temp-&gt;left) que.push(temp-&gt;left); if(temp-&gt;right) que.push(temp-&gt;right); } //将优先级队列top()最大值记录在答案中 result.push_back(vec.top()); } return result; } }; LeetCode 116 117填充每个节点的下一个右侧节点指针、II 2023.11.8 116题目链接116题目链接代码随想录讲解[链接]
class Solution { public: Node* connect(Node* root) { if(root == NULL) return root; queue&lt;Node*&gt; que; que.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d4d213d6a3b2cd1ddec1d43c46d892e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e459f146ba93812efffdd96911dbe676/" rel="bookmark">
			抖音短视频常用的scheme跳转协议地址，直播间Intent跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Scheme Android中的Scheme是一种页面跳转协议，和网站通过URL的形式访问一样，APP同样可以通过这种方式进行跳转，它可以很方便的满足我们在一些场景中的需求：
当应用接收到Push，点击通知栏消息跳转到特定页面，比如商品详情等。通过服务器下发的跳转路径，客户端可以根据路径跳转相应页面。应用跳转到其他APP指定页面。H5页面点击锚点，APP端跳转具体页面。 scheme是怎么得到的？ 通常是通过反编译、post/get抓包、度娘等方式获取的。
仅供学习研究，切勿用于非法用途。
本文包含哪些scheme 文章涵盖了某音脚本业务中常用的scheme
打开指定用户的个人主页私聊某人（打开指定用户的会话页）打开某个作品某音打开任意网页直接进入到直播间打开某用户的橱窗某音热点直播广场拍摄作品意见反馈卡券打榜添加直播商品关键字搜索等等等 例子(部分参数可省略) //跳转主页并关注: snssdk1180://user/profile/72673737181?refer=web&amp;gd_label=click_wap_profile_bottom&amp;type=need_follow&amp;needlaunchlog=1 snssdk1180://user/profile/72673737181?refer=web&amp;gd_label=click_wap_download_follow&amp;type=need_follow&amp;needlaunchlog=1 //打开视频： snssdk1180://aweme/detail/6683443624597916941?refer=web&amp;gd_label=click_wap_profile_feature&amp;appParam=&amp;needlaunchlog=1 //原声（同一个音乐的作品）： snssdk1180://music/detail/6680045787365247747?refer=web //热搜榜： snssdk1180://search/trending //最热视频: snssdk1180://search/trending?type=1 //音乐榜: snssdk1180://search/trending?type=2 //热搜（正能量）: snssdk1180://search/trending?type=3 //明星爱豆榜: snssdk1180://search/trending?type=4 //抖音Tik Tok内打开网址: snssdk1180://webview?url=http%3A%2F%2Fbaidu.com&amp;from=webview&amp;refer=web //抖音Tik Tok内打开网址（全屏）: snssdk1180://webview?url=http%3A%2F%2Fbaidu.com&amp;from=webview&amp;hide_nav_bar=1&amp;refer=web //抖音Tik Tok 个人中心 snssdk1180://user/profile/ //视频作品 snssdk1180://aweme/detail/ //个人主页 snssdk1180://user/profile/ scheme如何在脚本中调用 在auto.js中，可通过意图Intent对象来调用。
在按键精灵手机版中，可通过shell命令来调用。
以auto.js为例，只需将调用地址和参数，填入到下面的data中即可。
app.startActivity({ data: "snssdk1128://user/detail/111186289832", }); 以EasyClick为例，只需将调用地址和参数，填入到下面的url中即可。
utils.openActivity({ "uri":"snssdk1128://user/detail/111186289832", }); 注意 个别scheme地址随着app的更新，可能会发生变动。
如果有调用失效的情况，说明不可用了。
可用平台 scheme地址，是安卓脚本通用的。所以不限制使用平台，如按键精灵、autojs、EasyClick、webroobt等脚本平台都可以使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b9e99f29c3acd7560adef7b5d14fda/" rel="bookmark">
			新版HI3559AV100开发注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新版HI3559AV100开发注意事项
一、在Hi3559A上使用openCV VideoCapture开启.mp4影像档, isOpened一直得到false
在Hi3559A上已经cross compile ffmepg 4.1+openCV 3.4.4
但使用openCV VideoCapture开启.mp4影像档, isOpened一直得到false
请问要如何知道是什么原因无法开启影像档?
如何看到fail原因?
[code]#include
const HI_CHAR* videoFilename = “GOPR0178_REC.mp4”;
cv::VideoCapture cap(videoFilename);
if (!cap.isOpened()) {
printf(“Error opening video stream file (%s)(error:%d)\n”,videoFilename,cap.isOpened());
}
[/code]
答：将openCV 3.4.4换成3.4.6后，isOpened就回传ture了；
二、**在看demo时，怎么能知道demo是在DSP、A73MP（双核A73+双核A53）、A53up上运行。就运行检测的demo为，首先就是初始化VB、vi、vpss、vo，其中vb blocksize是根据视频帧大小获得来进行初始化的。**然后在MD初始化的时候又根据图像大小调用HI_MPI_SYS_MmzAlloc申请了内存，同时也申请了用来存放IVE_CCBLOB_S的内存空间，然后就是从VPSS获得数据，调用API进行运动检测。向请问一下，VB的内存是从什么地方申请的？HI_MPI_SYS_MmzAlloc又是从什么地方申请的内存？怎么知道运行检测在DSP上、还是arm上运行的？海思内存空间好像分为，OS自己的内存空间、MMA和多核共享的内存区域。
二、能用3559a的GPU做过实时渲染的么？性能能达到4K60么？
答：不能，时钟默认480M，怎么改时钟都改不了 详细SDK Chat：zhanggong345
三、Hi3559A怎么将数据存到DDR，想从摄像头获取视频数据，然后将视频数据（YUV格式）传给NNIE进行训练，在这个中间的过程希望建立一个调试步骤，将获取的数据保存到DDR，来看数据是否正确。但是不知道怎么将摄像头获取的数据保存到DDR中？
答：文件夹tmp就是DDR空间；你可以先参考:
\Hi3559AV100_SDK_V2.0.2.0\package\mpp\tools\vi_chn_dump.c
四、Hi3559a不支持BT656隔行输入吗？
VI 都只能逐行, 不支持隔行
五、HI3559av100 mipi dev 问题请教
SLVS 是2倍的关系。 但是 mipi 为什么也是2倍的关系那？
答：因为SAMPLE_COMM_VI_StartMIPI使用设定了LANE mode 7，所以每个sensor使用 4 lane；
六、用3559A进行目标检测，已经在开发板上实现了检测，但是只显示检测的坐标，怎么把整幅图都显示出来？
答：你可以参考sample_nnie_main.c程序做修改
/mpp/sample/svp/multi-core/nnie/sample_nnie_main.c
解压缩.tgz后，你要先执行sdk.unpack，才会有mpp, osdrv, osal, drv, hisyslink,…
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20b9e99f29c3acd7560adef7b5d14fda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c490cc80ce3679e1102c58d8c584c445/" rel="bookmark">
			嵌软工程师要掌握的硬件知识2：一文看懂什么是开漏和推挽电路（open-drain / push-pull）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文 / 黑猫学长
本文根据笔者个人工作/学习经验整理而成，如有错误请留言。
文章为付费内容，已加入原创侵权保护，禁止私自转载及抄袭。
文章所在专栏: 嵌软工程师要掌握的硬件知识
1 推挽（push pull）电路 1.1 理解什么是推挽电路 - 详细介绍
如图所示，Q3是个NPN型三极管，Q4是个PNP型三极管。
1）当Vin电压为正时，上面的N型三极管控制端有电流输入，Q3导通，于是电流从上往下通过，提供电流给负载。
经过上面的N型三极管提供电流给负载（Rload），这就叫「推」。
2）当Vin电压为负时，下面的三极管有电流流出，Q4导通，有电流从上往下流过。
经过下面的P型三极管提供电流给负载（Rload），这就叫「挽」
- 分类
如图所示，推挽电路分为：
（1）上N下P型
（2）上P下N型
对于上N下P型：
当Vin输入高电平时，Q1导通，Q2截止，输出高电平。
当Vin输入低电平时，Q1截止，Q2导通，输出低电平。
对于上P下N型则相反。
1.2 特点和作用 1、从上我们可以知道：推挽电路由两个三极管分别受两互补信号的控制, 即工作的状态总处于一个导通，另一个截止的状态（即：推挽输出既可以向负载灌电流，也可以从负载抽取电流），两个对称的开关管每次只有一个导通，所以开关损耗小，效率高。
因此，推挽电路适用于低电压大电流的场合，通常用来直接驱动功耗不大的数字器件，也广泛应用于功放电路和开关电源中。
2、推挽电路：可以输出高、低电平。其最大的特点也正是可以真正的输出高电平和低电平，在两种电平下都具有驱动能力。
3、推挽对比开漏，输出高电平时的驱动能力强很多。
为什么推挽比开漏驱动能力强？
https://blog.csdn.net/h1580824951/article/details/122165668
什么是驱动能力？
驱动能力是指输出电流的能力。如果负载电阻较小（内阻越小，负载越大），那么驱动这个负载的驱动能力就要较强。
例如IO输出为5V，驱动的负载内阻为10欧姆，于是根据欧姆定律可以正常情况下负载上的电流为0.5A（推算出功率为2.5W）。显然一般的IO不可能有这么大的驱动能力，也就是没有办法输出这么大的电流。于是造成的结果就是输出电压会被拉下来，达不到标称的5V。当然如果只是数字信号的传递，下一级的输入阻抗理论上最好是高阻，也就是只需要传电压，基本没有电流，也就没有功率，于是就不需要很大的驱动能力。
4、推挽输出也有自己的缺点，例如，如果当两个或多个推挽电路的输出连接在一起，一个输出高电平，即上面的MOS导通，下面的MOS闭合时；同时另一个输出低电平，即上面的MOS闭合，下面的MOS导通时。电流会从第一个引脚的VCC通过上端MOS再经过第二个引脚的下端MOS直接流向GND。整个通路上电阻很小，相当于发生短路，进而可能造成端口的损害。这也是为什么推挽输出不能实现" 线与"的原因。
2 开漏（open drain）电路 2.1 什么是开集（open collector）电路 1、要理解开漏电路，可以先了解一下什么是开集电路（OC）。开集电路中的“集”就是指三极管的集电极。
开集的意思，就是集电极C一端什么都不接，直接作为输出端口。
如上图所示左边的电路是开集（OC）输出最基本的电路，当输入为高电平时，NPN三极管导通，Output被拉到GND，输出为低电平；当输入为低电平时，NPN三极管闭合，Output相当于开路（输出高阻）。高电平时输出高阻（高阻、三态以及floating说的都是一个意思），此时对外没有任何的驱动能力。这就是开漏和开集输出最大的特点，如何利用该特点完成各种功能稍后介绍。这个电路虽然完成了开集输出的功能，但是会出现input为高，输出为低；input为低，输出为高的情况。
上图右边的电路中多使用了一个三极管完成了"反相"。当输入为高电平时，第一个三极管导通，此时第二个三极管的输入端会被拉到GND，于是第二个三极管闭合，输出高阻；当输入为低电平时，第一个三极管闭合，此时第二个三极管的输入端会被上拉电阻拉到高电平，于是第二个三极管导通，输出被拉到GND。这样，这个电路的输入与输出是同相的了。
2、开集电路结构是集电极开路输出的结构。集电极开路输出的结构如图1所示，右边的那个三极管集电极什么都不接，所以叫做集电极开路（左边的三极管为反相之用，使输入为“0”时，输出也为“0”）。对于图1，当左端的输入为“0”时，前面的三极管截止（即集电极C跟发射极E之间相当于断开），所以5V电源通过1K电阻加到右边的三极管上，右边的三极管导通（即相当于一个开关闭合）；当左端的输入为“1”时，前面的三极管导通，而后面的三极管截止（相当于开关断开）。
将图1简化成图2。图2中的开关受软件控制，“1”时断开，“0”时闭合。很明显可以看出，当开关闭合时，输出直接接地，所以输出电平为0。而当开关断开时，则输出端悬空了，即高阻态。这时电平状态未知，如果后面一个电阻负载（即使很轻的负载）到地，那么输出端的电平就被这个负载拉到低电平了，所以这个电路是不能输出高电平的。
图三中增加了1K的上拉电阻。如果开关闭合，则有电流从1K电阻及开关上流过，当我们要使用输入功能时，输出为1，而对于开关来说，就是高阻态了。
3、通常，开集电路需要外界上拉电阻使用，才能输出高电平，否则就不能输出高电平。
如图，如果要用这种电路带一个负载，比如一个LED，必须接一个上拉电阻：
当Vin没有电流，Q5断开时，LED亮。
当Vin流入电流，Q5导通时，LED灭。
2.2 什么是开漏电路 开集电路和开漏电路的关系
对于漏极开路（OD）输出，跟集电极开路输出是十分类似的。将上面的三极管换成场效应管（MOSFET）即可。这样集电极就变成了漏极，OC就变成了OD，原理是一样的。
开漏电路概念中提到的“漏”就是指MOS FET的漏极。
不管是开漏还是开集，都是和推挽相对于的一种模式，有些情况下，开漏电路和开集电路可以互换使用。所以很多时候，有些人也容易把开漏电路和开集电路，统一称为开漏电路（下文无特别说明，也统一称为开漏）。但是由于开漏使用的是场效应管，是电压控制元件，而开集电路使用三极管，是电流控制元件，所以开集电流有可能容易烧坏电路。这大概就是我们总是听到开漏电路而很少听到开集电路的原因吧？开集电路使用的也没有开漏电路使用的多。
- 场效应管简介
N型场效应管各个端口的名称：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c490cc80ce3679e1102c58d8c584c445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0557f2e74d82c6c3f7012dd3e051c6b/" rel="bookmark">
			Babylonjs学习笔记(九)——第一人称控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		书接上回，实现第一人称控制器！！！
以下步骤，缺一不可
相机相关设置 camera.applyGravity = true; // 应用重力
camera.checkCollisions = true; // 开启碰撞检测
const camera = new FreeCamera("camera",new Vector3(0,1,0)); camera.minZ = 0.5 // 相机的移动速度 camera.speed = 0.2 // 相机角度敏感值 camera.angularSensibility = 4000 // 将场景的重力应用于相机 camera.applyGravity = true; // 开启碰撞检测 camera.checkCollisions = true; // 定义相机的碰撞椭球 默认Vector3(0.5,1,0.5) camera.ellipsoid = new Vector3(0.5,1,0.5) // 修改控制器，使用wasd 控制 camera.keysUp.push(87); //w camera.keysLeft.push(65)//a camera.keysDown.push(83)//s camera.keysRight.push(68)//d // 相机添加控制器 可以使用方向键控制相机 camera.attachControl() 2. 定义场景重力
scene.collisionsEnabled = true; // 开启碰撞检测
scene.gravity = new Vector3(0, gravity / framesPersecond, 0) // 定义Y轴上的重力
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0557f2e74d82c6c3f7012dd3e051c6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3f7ae72567090e16ff0fc69ac18a3e/" rel="bookmark">
			uniapp da-tree插件 代码和结构分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 传送门：da-tree 树组件（支持单选、多选、无限级、主题色，Vue3版）
changelog.md
版本号+版本更新内容readme.md
概述、使用（导入方式）、demo、传参、事件、实例方法、平台差异化、开发人员信息、注意风险项（如未测试平台）props.ts 定义传参index.vue 1300行的树逻辑代码
scss:
动画、变量注入以及具体样式代码
template:
拍平单层渲染，做了虚拟树
js:
监听列表、选中、展开值，
遍历列表，获取一系列索引，加一些标识数据如层级等等，方便后续计算
初始化展开、选中；未展示的先不渲染
实现选中、展开值的双向绑定
处理单选和多选两种模式
处理同步和异步两种模式
处理树节点展开、收起；父子关联；
支持各种配置项 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f676219903e5ddbf08a792cae1fa0d/" rel="bookmark">
			编译libigl笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.最好需要翻墙软件，CMake时会随时下载依赖资源
2.error C3861: “_BitScanForward64”: 找不到标识符 win32修改成_BitScanForward
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed1e09a866e2adfc28ae165a87d27d7/" rel="bookmark">
			11-09 周四 CNN 卷积神经网络基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11-09 周四 CNN 卷积神经网络 时间版本修改人描述2023年11月9日09:38:12V0.1宋全恒新建文档 简介 学习一下CNN，卷积神经网络。使用的视频课程。视觉相关的任务：
人脸识别 卷积网络与传统网络的区别：
&lt;img alt=image-20231109094400591 src=https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fyanchenmochen%2Fimgs%2Fimgsimage-20231109094400591.png&amp;pos_id=img-Z35hmB60-1699522025179)&gt;
&lt;img alt=image-20231109094414779 src=https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fyanchenmochen%2Fimgs%2Fimgsimage-20231109094414779.png&amp;pos_id=img-08hzm0rf-1699522028665)&gt;
卷积神经网络是一个三维的数据，是h*w*c
整体架构 &lt;img alt=image-20231109094649673 src=https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fyanchenmochen%2Fimgs%2Fimgsimage-20231109094649673.png&amp;pos_id=img-AGVXtOFG-1699522031824)&gt;
输入层卷积层池化层全连接层 卷积层 调度卷积核是5*5*3，也是一个立方体的。
卷积神经网络也是使用一组权重参数进行加权求和得出的。
&lt;img alt=image-20231109094831385 src=https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fyanchenmochen%2Fimgs%2Fimgsimage-20231109094831385.png&amp;pos_id=img-pBCi31QD-1699522034969)&gt;
注： 上图仅演示了一个通道，图像是3通道。
相当于权重参数矩阵为:
&lt;img alt=image-20231109095218835 src=https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fyanchenmochen%2Fimgs%2Fimgsimage-20231109095218835.png&amp;pos_id=img-ZZahJ8Qu-1699522038141)&gt;
卷积神经网络的目的也是找到一组最佳的权重参数。
注： 卷积核的第三个维度一定要一样才行。卷积采用内积实现。Filter的尺寸一般为3， 5，7。 在进行卷积核的时候与卷积核的第三个维度数量相等。
&lt;img alt=image-20231109105238890 src=https://img-home.csdnimg.cn/images/20230724024159.png?origin_url=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2Fyanchenmochen%2Fimgs%2Fimgsimage-20231109105238890.png&amp;pos_id=img-41nSowP4-1699522038975)&gt;
5x5x3代表一个卷积核，该卷积核的深度为3，与输入的深度相同。得到一个特征图，深度与输入图相同。卷积核可以有多个，则可以得到多个特征图。即Feature W0， Feature W1, … 经过多个卷积核得到多个特征图feture picture。
如下图所示：
上图经过卷积层得到了28 * 28 * 6个特征图。
将经过卷积核卷积之后的图堆叠在一起，得到了特征图堆。并且，卷积应该经过多次，依次得到Low-level Feature， Mid-Level Feature， High-Level Feature。也就是说，一次卷积是不够的。
上图说明卷积核5 * 5 * 3得到的是一个值，一个立方体得到一个值。也就是说，一个图如果一个卷积核扫描完全部得到的是一个28 * 28 * 1的图。使用6个卷积核，则得到的卷积图是28 * 28 * 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ed1e09a866e2adfc28ae165a87d27d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da11c0e5585343e830ae09fff3c0ee12/" rel="bookmark">
			BGP（Next-Hop）实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Next-Hop属性。 Next_Hop属性记录了路由的下一跳信息。BGP的下一跳属性和IGP的有所不同，不一定就是邻居设备的IP地址。通常情况下，Next_Hop属性遵循下面的规则：
BGP Speaker在向EBGP对等体发布某条路由时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。
BGP Speaker将本地始发路由发布给IBGP对等体时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。
BGP Speaker在向IBGP对等体发布从EBGP对等体学来的路由时，并不改变该路由信息的下一跳属性。
Next-Hop属性会参考IGP cost进行选路。
2、BGP（Next-Hop）实验。 实验描述： 1、在R1和R2、R1和R3之间配置EBGP连接
2、在R2、R3、R4之间配置IBGP连接。
3、通过配置Next-Hop让R2把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。
4、通过配置ospf的cost值，让R4自由选路。
5、因为EBGP之间使用物理接口配置，所以不需要配置ttl属性。
实验拓扑： 1、R1配置。 ##基础IP地址配置 &lt;Huawei&gt;sys [Huawei]un in e [Huawei]sys R1 [R1]int g0/0/0 [R1-GigabitEthernet0/0/0]ip add 10.0.12.1 24 [R1-GigabitEthernet0/0/0]int g0/0/1 [R1-GigabitEthernet0/0/1]ip add 10.0.13.1 24 [R1-GigabitEthernet0/0/1]int loo0 [R1-LoopBack0]ip add 10.0.100.1 32 [R1-LoopBack0]q ##BGP配置 [R1]bgp 100 [R1-bgp]router-id 10.0.1.1 [R1-bgp]peer 10.0.12.2 as-number 200 [R1-bgp]peer 10.0.13.3 as-number 200 [R1-bgp]network 10.0.100.1 32 [R1-bgp]q //因为使用物理接口配置，所以不需要配置ebgp（ttl） 2、R2配置。 ##基础IP地址配置 &lt;Huawei&gt;sys [Huawei]un in e [Huawei]sys R2 [R2]int g0/0/0 [R2-GigabitEthernet0/0/0]ip add 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da11c0e5585343e830ae09fff3c0ee12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec818897c9cbbaee4f161a7c70a6521/" rel="bookmark">
			卫星测高重力与重力反演地形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卫星测高的原理
卫星测高是以装载雷达高度计的卫星为平台，主动向海面发射微波信号，接受经海表面反射的微波信号以获取海面高度、有效波高和后向散射等信息。
测高卫星在预先设定的轨道上围绕地球飞行可提供全天候、近实时、海量的卫星观测数据，其星下点轨迹具有往复性和高密度的特点。通过对卫星轨迹升弧段和降弧段的交叉点不符值进行处理，并采用相应的格网化内插方法可获得格网化大地水准面数据和垂线偏差数据，进而利甩逆Stokes公式、最小二乘配置以及逆Vening-Meinesz公式等方法可恢复海洋重力场。
本文采用的 1'×1'卫星测高重力异常 GravAlti_WHU 是联合 Geosat、ERS-1、ERS-2、Envisat、T/P、Jason-1、CryoSat-2 和 SARAL/AltiKa 等多颗卫星波形资料获取的垂线偏差信息反演的,如图1所示。数据处理过程中改进了波形重跟踪算法，选定了较优的沿轨重采样频率,在北太平洋海域、墨西哥湾海域与 NGDC(National Geophysics Data Center)船测数据之差的均方根约为 4 mGal(1 mGal=10-5 m/s),模型精度与 SIO V23.1 重力异常模型相当,优于 DTU10 重力异常模型。
图 1 全球海洋卫星测高重力异常模型 Grav_Alti_WHU 海底地形反演
根据海洋重力场信．息反演海底地形的基本原理可以描述为：依据地壳均衡理论，海底地形起伏及其均衡补偿物质的密度分布异常将会引起海面重力异常和重力异常垂直梯度等重力信息发生相应变化，因此可以说重力数据与海底地形在一定程度上具有一一对应的相关关系，基于Parker（1972）异常扰动位计算公式和Watts（1978）三个板块模型可以获得它们之间的地球物理关系。同时也可分析大量的重力和海深数据的统计特征，采用一定的数学方法构建它们之间的数学模型。利用重力异常和重力异常垂直梯度数据反演海底地形作为研究对象，围绕其理论、方法及其应用展开研究，以期为提高海洋开发能力，扩大海洋开发领域提供理论与技术支持。
（1）重力地质方法
重力地质方法（Gravity-Geologic Method，简称GGM）是一种常用的海底地形反演技术，最初被应用于冰河时期漂移沉积物下的基岩高度测量，由于陆地上地质层的密度变化大，使得该方法在陆地上的应用效果不佳。而在海底地形的探索方面，洋壳密度和海水密度的差异变化较小，通常认为海水内部密度不随深度变化。从而重力地质法（GGM）在反演海洋深度方面具有较高的可行性。
重力地质方法的实施关键在于密度差异常数的确定，一种方法为采用移去恢复技术建立海深模型，并通过数学方法构建模型海深值与船舶测量检核点之间的相关系数和均方差（ＲＭＳ）关系，利用密度差异迭代的方式获取最优的密度差异常数；另一种方法为采用频率域向下延拓方法，以参考海深面重力异常与海面重力异常之比作为密度差异常数。如今，重力地质方法依靠少数船测水深和卫星测高重力异常，便可间接获取相关海域海洋深度，与其他经典方法相比，该方法具有模型简单，易于计算的优点。
（2）导纳函数方法
重力导纳表征将海底地形转换为重力异常的能力。基于对Parker公式、Watts板块模型以及地壳均衡理论的研究，利用最新的全球地壳模型Crust1.0、“理论导纳”函数、“观测导纳”函数等相关知识，可以获取有关的海洋地球物理信息。在重力数据和海深数据频谱特征的统计分析基础上，采用相应的滤波技术对信号向下延拓过程中出现噪声放大的病态问题进行处理。可以以重力异常和重力异常垂直梯度为输入数据，分别建立不顾及均衡情况、考虑Ａｉｒｙ均衡、或者顾及地壳挠曲均衡三种不同模式的导纳函数模型。
导纳函数方法从海底地形起伏在海面对应区域产生扰动位的经典位势理论出发，经过傅里叶变换、极坐标积分变换、泰勒级数等一系列推导得到频率域内海底地形起伏计算海面重力异常的级数展开式，然后利用弹性板挠曲理论以及均衡模型最终建立了反演海底地形的导纳函数模型。该方法充分考虑了海底地形的地球物理环境，算法理论严密，但是解算相对复杂。
（3）Ｓ＆Ｓ方法
Ｓ＆Ｓ方法主要由Smith和Sandwell在１９９４年提出，相对于理论完备的导纳函数方法，在对大量的重力和海深数据的统计特征分析发现，重力异常或者重力异常垂直梯度经滤波并向下延拓后的结果与海底地形存在良好的线性关系。基于此，利用数学建模相关理论可以构建相关波段重力异常或者重力异常垂直梯度与海底地形的数学函数关系，获取重力数据与海底地形的比例系数，进而反演出相应波段的海底地形结果。
相对于重力地质方法和导纳函数方法而言，Ｓ＆Ｓ方法基于对大量的重力和海深数据统计分析，进而对数据进行数学建模。Ｓ＆Ｓ方法虽然不如导纳函数具有严密的理论推导，但是方法简单，具有较强的可操作性，同时比例系数的结果也在一定程度上反映了海底地形的某些地球物理特征。
（4）最小二乘配置方法
最小二乘配置是大地测量学中的经典方法，利用最小二乘配置方法推估海底地形要求事先知道海深与重力数据之间的自协方差函数和互协方差函数。根据重力场理论，可以采用Inverse模型、Gauss模型、Moritz模型拟合重力数据的协方差函数，但是海深与重力的协方差函数计算困难。此时，可以通过频率域功率谱密度函数（Power Spectral Density，简称PSD）模拟自协和互协方差函数，进而得到重力－海深在频率域内的转换函数，然后依据十次多项式拟合转换函数获得平滑的转换函数，最终解算相应波段的海深值。
国内利用卫星测高反演海底地形的成果
武汉大学李建成院士课题组是国内较早研究卫星测高技术应用研究的课题组之一。2014 年，课题组使用 1'×1'的 SIO V20. 1 重力异常垂直梯度数据，采用回归分析方法，联合
NGDC 发布的船测水深数据，构建了 75°S～70°N 范围 1'×1'的海底地形模型 BAT_VGG，其中反演区域以外的海底、陆地以及水 深 浅 于 100 m 海 域 的 地 形 数 据 来 源 于 SIOV15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec818897c9cbbaee4f161a7c70a6521/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/401017225e5455526877ccd052a76604/" rel="bookmark">
			GRBL源码详解步进电机的算法学习笔记（STM32）一篇带你学完GRBL算法初版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
GRBL源码中步进电机的算法学习笔记（STM32）
前言 GRBL源码中算法部分的学习是我在公司研发激光切割机（三轴）期间研究的一套关于步进电机驱动控制的常见算法，以下内容都以激光切割机来举例，话不多说直接上干货。（以下内容皆为个人理解，如有错误可以在评论区揪出，希望大家一同讨论，共同进步）
一、简看GRBL的工作流程 对于一台激光切割机来说，当你想要雕刻一个圆
第一步：（将指令或图片G代码通过串口发送给MCU）
首先从上位机LaserGRBL/lightburn软件解析想要雕刻的圆，然后上位机将解析后的数据通过串口发送给MCU，MCU判断串口收到的数据是G代码还是“$”指令（该部分对应的函数为： protocol_execute_line）。
在本次举例中，圆会被解析成G代码，所以MCU通过源码中的Gcode解释器（Gcode解释器在源码中对应的函数为：gc_execute_line），但如果是指令则通过源码system_execute_line这个函数进行处理
第二部：（将接受到的G代码进行分析，从而调用对应的算法函数进行处理）
注：本文暂时不讨论指令如何处理和G代码如何分析只讨论算法
当Gcode解释器解释到数据是圆的时候，将会先计算圆心的坐标，然后再调用mc_arc函数将圆拆分成一段段小的线段（算法部分也就是从mc_arc这个函数开始）
{
算法部分
1、mc_arc() —&gt; 将圆拆分成小线段，并计算线段的起点与终点的坐标
2、mc_line() —&gt; 将线段与线段之间的切换速度进行计算
3、planner_recalculate（） —&gt; 基于切换速度和前瞻算法，设定线段的最佳起始速度和结束速度
4、st_prep_buffer（）—&gt; 梯形算法，将速度换算成每一步需要的时间，最后将时间数据通过定时器，改变输出频率作用到步进电机
}
二、算法部分（所有算法解释内容目前只放在代码块中体现） 1.mc_arc 代码如下（示例）：
void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate, uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)//计算圆弧被拆分后，每一个坐标的位置并传送给mc_line() #endif { float center_axis0 = position[axis_0] + offset[axis_0];//position为当前位置坐标，offset为圆心相对于当前位置的偏移量 float center_axis1 = position[axis_1] + offset[axis_1]; float r_axis0 = -offset[axis_0]; //假设圆心为0时，当前位置的坐标 // Radius vector from center to current location float r_axis1 = -offset[axis_1]; float rt_axis0 = target[axis_0] - center_axis0;//假设圆心为0时，终点位置的坐标 float rt_axis1 = target[axis_1] - center_axis1; uint16_t segments; float theta_per_segment; float linear_per_segment; float cos_T,sin_T; float sin_Ti; float cos_Ti; float r_axisi; uint16_t i; uint8_t count = 0; // CCW angle between position and target from circle center.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/401017225e5455526877ccd052a76604/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/62/">«</a>
	<span class="pagination__item pagination__item--current">63/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/64/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>