<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d563cc055c2e28ef5bf3c1bbc0babac2/" rel="bookmark">
			jetson 系列 安装完jetpack/已安装 tensorrt 在虚拟环境中仍然报 no module named tensorrt ＞＞ 在虚拟环境建立软连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用虚拟环境时，需要考虑
cv2 和 tensorrt 是一样的
更新：cv2 应该是对的。
tensorrt的处理是错的，在 使用 trt时很多方法都找不到。正确的加入虚拟环境的方法：
https://www.bojankomazec.com/2019/12/how-to-install-tensorrt-python-package.html
cv2安装 – 与虚拟环境链接 为了使用TensorRT完成之后的识别功能，也为了推理的更快，我们当然必须要安装opencv
NVIDIA Jetson AGX Xavier学习笔记3——环境配置(pytorch、torchvision、cv2)
进行NVIDIA Jetson AGX Xavier开发组件刷机时已经自动安装了OpenCV，只需要将python虚拟环境链接到OpenCV库即可。
安装完成后，在虚拟环境中执行下列指令以确保python能正确调用cv2
python //进入python import cv2 cv2.__version__ //若安装成功且能正常调用，此处能输出安装的从v版本 quit() 实测在当前环境中 找不到 cv2 虚拟环境可以运行。使用base下的 python2 可以运行找到。
首先在终端执行以下指令查找编译好的cv2库文件的路径。
sudo find / -iname "*cv2*" // 得到路径 /usr/lib/python3.6/dist-packages/cv2/python-3.6/cv2.cython-36m-aarch64-linux-gnu.so 之后进入&lt;虚拟环境&gt; 的 site-packages文件夹下,并链接到查找到的cv2库文件路径即可。
cd /home/miniforge3/envs/&lt;virtual&gt;/lib/python3.6/site-packages # 其中virtual是我建立的虚拟环境名 ln -s /usr/lib/python3.6/dist-packages/cv2/python-3.6/cv2.cython-36m-aarch64-linux-gnu.so cv2.so 之后在这个环境中就可以正常验证了：
python //进入python import cv2 cv2.__version__ //若安装成功且能正常调用，此处能输出安装的从v版本 quit() //退出python 对于 tensorrt 也是 (base) agxxavier@agxxavier-desktop:~$ sudo find / -iname "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d563cc055c2e28ef5bf3c1bbc0babac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68968e18f6b864c04ace52167c0ca277/" rel="bookmark">
			孙陶然-36条军规
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第四十一讲：慎用空降兵
初创企业请职业经理人是死路一条
低半格进入，是空降兵融入公司的窍门（待遇可以另谈）
公司原有领导者对于空降兵应该扶上马送一程，主动设计一些方法，帮助空降兵建立起威信，被公司的老人接受，融入公司。
第四十二讲：企业成功之后不要折腾
折腾的表现：（拿理论上听起来很正确的东西，但是与企业的现实不符，强行执行时，对企业的正常运转产生了危害，所有的企业都需要进化，但进化一定是建立在现有的基础上逐步改良）
请能人 他以前熟悉的管理方法是否和你的企业契合，是否能融入企业，是否能够将企业现有的东西很好的掌握，然后带向新的方向他是否热爱你的企业，热爱你的产品和员工规范化：规章制度和流程是为企业的发展效率服务的制定战略：战略必须是在企业的现实基础上制定向未来发展的战略 原来企业的成功有其合理性，企业的根基不能变（组织架构，管理风格，管理方法，人才），在这个基础上取长补短，小步快跑，改良式的前进，保证企业的持续发展，成功之后冒然抛弃原来成功的各种做法，引入全新东西的风险是非常大的
第四十三讲：模仿不是创业的捷径
某种程度上说，模仿是大公司市场地位的红利（有品牌，有用户，有资金）
创新是小公司的杀手锏，创新才有小公司的生存机会
没一个未被满足的需求都是我们创新的机会，已经满足的需求可以通过创新，更好地满足需求（降低成本，提高效率，提高用户体验）
第四十四讲：企业经营的方方面面皆可创新
产权机制，激励机制，组织结构，销售渠道，产品价格，企业经营和管理的任何一个方面都可以创新
第四十五讲：创新光荣抄袭可耻
第四十六讲：什么是商业模式
商业模式：如何赚钱（什么产品，什么价格，怎么卖出去）
第四十七讲：什么是好商业模式
简单，重复消费，可以多角度挖掘用户价值的，有一定的门槛
简单的商业模式更容易成功，可以快速复制推广
第四十八讲：烧钱的商业模式不适合绝大多数创业者
适合烧钱的商业模式：
大众需求：潜在用户是海量的
高频需求：高频，粘性非常强的需求
第四十九讲：尽早验证自己的商业模式
验证：先在小规模范围内，真正的把收入和利润赚到手
有两类的商业模式，风险非常大：
理论上成立，但实际上不成立：综合性解决方案型商业模式，业务需要多个前提条件，如果需要三个以上的商业模式，基本上不成立超越逻辑的商业模式：如何让13亿人想买你的东西，如何让13亿人能买到你的东西 理论和真正实现，有非常大的差距
可以多次打磨
第五十讲：领导者要有预见性
比别人看的更远，更早一点看到未来
跳出画面看画，创始人应该跳出公司的琐事，更多的思考企业的未来，想到最好、最差的结果，推演应对各种结果的方法
第五十一讲：如何让自己有预见性（向前看，反复推演）
是一种能力，也是一种意识
高手对招看布局，布局是一个持续性的工作，时刻紧盯着市场，时刻向前看去预见未来
训练自己：想一下，一周之后，一个月之后，三个月之后，一年之后，这件事情会怎么样，这样会训练自己看的越来越远，预见是一个连续的过程，不断的向前看，不断矫正自己的预见
第五十二讲：永远要有B计划
B计划是在A计划执行不下去的时候执行，可以达到A计划类似的目标，以保证总目标的达成
自己负责的项目，下属负责的项目，人才备选都要有B计划，
提高领导能力的小工具：
向前看，有预见性向后看，会复盘，不断总结经验教训，在经历中提升自己的功力B计划，永远把命运把握在自己手里 第五十三讲：越是顺风顺水越要警惕风险
忘乎所以的几个表现：
高度自信，认为自己无所不能，摊子铺的很大，扩张速度很快，盲目扩张
开始不谦虚谨慎，认为自己很强，会逆着规律做事
关键是要冷静
反复的审视，自己的企业现在还存在那些问题，要把这些问题找出来，冷静的把这些问题补掉，冷静的去想，企业的下一步发展会是怎么样的，未来给自己带来最大威胁，会是在那个方向，出现问题应该怎么去应对
第五十四讲：要敢于冒险
创业和领导一个公司都要敢于冒险，小公司更多的是冒险，对大公司而言更多的是稳健经营。
敢于行动就已经有了7成的把握，大多数人努力程度之深，让我们的成功更本没有到比拼天赋的阶段。绝大数的人并不是特别努力，甚至没有开始行动，所以我们要超过他们并不需要天赋，只需要敢于行动就够了，
一百个人想做了一件事，只有五十人准备采取行动，有25人因为想到了各种各样的困难而没有行动，真正开始行动的100人里只有25人。
25个人中有一半的人遇到第一个困难就会放弃，只要敢于行动，敢于冒险，并且遇到困难坚持不放弃，就能做到12/100。
风险与机遇并存，有60%把握的事情就应该采取行动
公司大要追求稳，公司小要激进一点
第五十五讲：创业需要一个团队
团队是N-1，包括对你负责的所有人，管理学的理论：一个人的管理范围应该以不超过8个人为好，最多向你汇报的可以有10个人，这些人就是你的团队。
班子：可以和你一样，可以站到最高的位置上去思考全局问题的人，即团队之中有一部分可以和自己站在一样的高度对话，讨论全局的战略管理的几个人，班子成员一定是团队成员，团队成员不一定是班子成员
让团队成员感觉到自己是在自己的梦想而奋斗，因为有了公司的存在，自己才能有一个好的平台，创始人只是为了实现他们的梦想而保驾护航
第五十六讲：一把手和团队如何分工
民主不能保证事事正确，但是它可以避免错误的决策
领军人物和团队是 1和0的关系，没有领军人物，再好的团队也是0，有了领军人物的1或9，团队越强大，那这个队伍越强大。
听所有人的意见，跟少数人商量，一个人做决策。
老大要把所有的事情从头到尾想一遍，然后拿出自己的判断和决策。
任何时候老大都不能用团队的脑袋替代自己的脑袋，都不能用团队的深入讨论，代替自己的思考，直接拿团队的结论当做自己的结论，这是绝对不允许的，因为决策是一个系统性的思考，从头到尾的分析得出来的一个结论
领军人物要时刻清楚，我们既要谦虚，既要尊重团队的意见和建议，并广泛的和班子成员交流，吸取他们的思考精华，也要将自己的职责做好，系统梳理事情，拿出自己的判断。
第五十七讲：团队的基因
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68968e18f6b864c04ace52167c0ca277/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2042e33a41a7da47f9e7f19f04e7206d/" rel="bookmark">
			Jvm笔记3：JVM的垃圾回收机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、JVM堆内存分代模型2、年轻代、老年代、永久代垃圾回收机制？3、哪些对象不会被垃圾回收期回收4、JVM核心参数5、Java对象不同的引用类型的垃圾回收6、逃脱垃圾回收的最后一次机会finalize()7、小结 1、JVM堆内存分代模型 年轻代：对象创建之后很快就可以被回收。例如方法局部变量引用的对象，很可能方法调用结束后就没人引用了。老年代：对象是需要长期存在的。例如静态变量所引用的对象，它会随着Jvm的销毁而销毁，也就是整个生命周期都是存活的。永久代：存放类的一些信息，生命周期较长，大部分随着Jvm的销毁而销毁。 2、年轻代、老年代、永久代垃圾回收机制？ 年轻代：
A) 大部分对象会优先在年轻代分配内存
B) 当给一个新对象分配内存时，发现新生代内存不够分配时，会触发新生代的垃圾回收。老年代：
A) 新生代垃圾回收后，存活对象过多进入老年代
B) 躲过默认15次Young Gc的对象会进入老年代
C) 大对象（默认1M）创建时会直接进入老年代
D) 空间担保机制永久代：
A) 该类的实例对象已经在JAVA堆内被回收
B) 加载该类的ClassLoader已经被回收
C) 该类的Class对象没有任何引用 3、哪些对象不会被垃圾回收期回收 JVM使用了可达性分析算法来判定对象是否可以被回收：对于每个对象，一层层往上判定，看是否有一个GC Roots在引用它类的静态变量、方法的局部变量可以看做是GC Roots简单来说，一个对象只要被类的静态变量以及方法的局部变量所引用，那么该对象就无法被回收 4、JVM核心参数 -Xms: 最小堆内存-Xmx: 最大堆内存-Xmn: 堆新生代大小-XX:PermSize: 永久代大小-XX:MaxPermSize: 最大永久代-Xss: 每个线程栈大小 5、Java对象不同的引用类型的垃圾回收 强引用：例如类静态变量引用的对象，垃圾回收器不会回收此种对象软引用：被SoftReference&lt;&gt;软引用类型包裹的对象，垃圾回收器会在堆内存不足分配给新对象（即将 内存溢出）时进行回收弱引用：被WeakReference&lt;&gt;弱引用类型包裹的对象，垃圾回收器会在下一次垃圾回收时回收此种对象虚引用：很少用，可忽略 6、逃脱垃圾回收的最后一次机会finalize() 调用时机：当垃圾回收器要宣告一个对象死亡时，至少要经过两次标记过程：如果对象在进行可达性分析后发现没有和GC Roots相连接的引用链，就会被第一次标记，并且判断是否执行finalize( )方法，如果对象覆盖finalize( )方法且未被虚拟机调用过，那么这个对象会被放置在F-Queue队列中，并在稍后由一个虚拟机自动建立的低优先级的Finalizer线程区执行触发finalize( )方法，但不承诺等待其运行结束。目的：对象逃脱死亡的最后一次机会。假如对象重写了它的finalize()方法并把自己的实例赋给其它的GC Roots，那么该对象在垃圾回收时不会被回收。 7、小结 本文简单介绍了JVM堆内存的分代模型以及相对应的垃圾回收时机（比较粗糙，后面详细介绍）、程序运行时JVM核心参数、Java对象不同引用类型的垃圾回收、哪些对象不会被垃圾回收、以及逃脱垃圾回收的最后一次机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07103f75df29a878e22d03cb24a183b6/" rel="bookmark">
			Jvm笔记2：内存区域的划分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、背景2、方法区3、程序计数器4、栈4.1 栈概念4.2 入栈出栈 5、堆 6、对象的分配、引用与回收7、小结 1、背景 Jvm运行程序时，是需要内存空间来存储数据的，不同的内存空间存放不同的数据。Java代码的组成部分大概有：类、类属性、静态变量、方法，局部变量等组成。那么，这些组成部分都在Jvm哪些内存区域呢？ 2、方法区 主要存放“.class”文件加载进来的类，还会有常量池等一些数据在这块区域。JDK1.8之后，这块区域的名字也被叫做“Metasapce”（元数据空间），存放的依然是我们的类信息。
3、程序计数器 我们编写的.java文件最终会编译成.class字节码文件，字节码文件才是计算机识别的语言，而不是我们编写的代码。因此，我们编写的代码被编译成字节码文件后，会对应着计算机的各种指令。
Jvm加载类到内存后，会使用自己的执行引擎去执行代码编译出来的字节码指令。这时候，JVM就需要一块特殊的内存区域：程序计数器。
这个程序计数器是用来记录当前执行的字节码指令的位置，换句话说，是用来记录目前执行到哪一条字节码指令的。
众所周知，Java并非单线程的，而是多线程执行不同的代码指令。所以每个线程都会有自己的程序计数器，用来记录当前线程执行到哪一条指令了。
4、栈 4.1 栈概念 我们通常会在一些方法内定义一些局部变量，在JVM中有一块区域是是用来保存方法中的局部变量等数据的，这块区域就叫做虚拟机栈。
每个线程都会自己的虚拟机栈。如果线程执行了一个方法，就会对这个方法调用创建一个对应的栈帧，压入该线程的虚拟机栈；栈帧里会有这个方法的局部变量、操作数栈、动态链接、方法出口等。
4.2 入栈出栈 假如main()方法有局部变量x且调用了另一方法A，A方法也有一局部变量y且调用了另一个方法B，B方法也有一布局变量z。
当main线程执行方法main()时，会创建一个栈帧压入线程的虚拟机栈；当调用到方法A时，也会创建一个栈帧压入线程的虚拟机栈；当调用到B方法时，同样也会创建一个栈帧引入线程的虚拟机栈。
当B方法执行完毕，B方法对应的栈帧就会从虚拟机栈出栈；当A方法执行完毕，A方法对应的栈帧也会从虚拟机栈出栈；同样，main()方法执行完毕后，main方法对应的栈帧同样从虚拟机栈出栈。
5、堆 Java堆内存区域会放入类对象，例如A x = new A()这里的A类实例对象会存放到堆里。在线程执行main()方法时，会让main方法对应的栈帧的局部变量表里的一个引用类型变量“x”来存放A对象的地址。 6、对象的分配、引用与回收 方法的栈帧，在方法调用结束后会从线程的虚拟机栈中出栈。出栈后，方法的局部变量也随之销毁，而这时局部变量指向堆里的实例对象也就没有引用了，变成堆里的垃圾对象了。Java堆里的对象都是占用内存资源的，而我们Jvm作为系统的一个进程，分配着系统的一块内存，因此我们的资源是有限的。JVM的垃圾回收机制：Java后台有一个垃圾回收线程，它是低优先级的。在堆内存不足时，它就会对堆里垃圾对象回收释放内存。 7、小结 本文主要介绍了存放类的方法区、执行代码命令的程序计数器、Java虚拟机栈、Java堆这些内存区域的划分以及对象的分配、应用与回收。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49d0ac6d8756653a6177516034f096e7/" rel="bookmark">
			多线程笔记1：并发问题的产生及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习笔记 1、并发问题的产生1.1 内存模型1.2 CPU内存模型1.3 Java内存模型1.4 基于内存模型分析并发问题产生的根因 2、并发问题的解决方案 1、并发问题的产生 1.1 内存模型 想要了解并发问题产生的根源，首先我们需要了解一下内存模型的概念。我们都知道，我们程序是在Java虚拟机上运行的，Java虚拟机有自己的内存模型，而老大哥计算机CPU当然也有自己的内存模型。
1.2 CPU内存模型 计算机在运行程序的时候，每条指令都是在CPU上执行的，而CPU执行指令的过程中会涉及到数据的写入和读取问题，而计算机在运行过程中数据都是存储到主存（我们常说的内存）里的，CPU则从主存里读写数据进行计算。
但是这里会产生一个问题：CPU执行指令的速度是非常快的，比我们主存读取和写入数据速度快得多，这会导致CPU的执行效率大大下降。
因此，我们每个CPU都会自带一个高速缓存区，CPU每次读取运算数据的时候首先从主存里将数据复制到高速缓存区，然后CPU基于高速缓存区运算结束之后，CPU再从高速缓存区将数据刷新到主存里去，从而提升CPU的执行效率。
数据：主存 —复制— CPU高速缓存区 —计算—刷新— 主存
1.3 Java内存模型 Java内存模型和CPU内存模型有很多相似之处，区别在于Java内存模型屏蔽了不同操作系统与底层硬件的的访问差异，从而做到跨平台、多平台一致性。
Jvm启动之后，操作系统会为Jvm分配一块内存空间，它被称作为“主内存”。
而Java程序的工作是有线程完成的，每一个线程都有一小块内存，它被称作“工作内存”。Java线程在运行过程中，会从主内存中把数据复制到工作内存中，然后进行计算，计算完成后会从工作内存把数据刷新到主内存中。
1.4 基于内存模型分析并发问题产生的根因 读取：从主存中读取数据A=0计算：将A的值进行加1写入：将计算后的A值刷新到主存 分析： 多线程运行程序的时候，假设线程1和线程2同时从主存读取数据A=0到各自工作内存，然后基于工作内存进行计算，这时线程1和线程2的数据在各自工作内存中都是A=1，最后线程1和线程2将A值从各自工作内存刷新到主存中去。
奇怪的现象发生了：两次存入主存的A值都为1，但其实我们需要的结果是2，因为我们A计算了两次加1。
上述就是并发问题产生的根因。
2、并发问题的解决方案 显然易见，并发问题的产生是因为线程上述3个步骤的执行被其它因素（例如其它线程）打断。
因此，解决方案就出来了：上述3个步骤看做一个整体，运行过程中要么全部执行不被打断，要么全部不执行，问题就解决了。
这里需要引入一个并发中很重要的概念—原子性：一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
上述问题中，我们只要等线程1把3个步骤执行完，线程2再执行3个步骤，这样我们的并发问题就得到解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe878e0c2c0c3c987fd9a3bac52cf65/" rel="bookmark">
			数据分析之数理基础与概率统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 随机误差的分布是`正态分布（高斯分布）`中心极限定理和大数定律两类错误置信区间、置信度（置信水平）协方差是啥，怎么判断协方差正负辛普森悖论的例子ABtest1.在abtest的应用中 p值的意义，第一类和第二类错误的定义是什么？2.abtest的流程 幸存者偏差 随机误差的分布是正态分布（高斯分布） 根据中心极限定理，大量独立的随机变量之和趋向于某个稳定的分布，被称为正态分布（高斯分布）。那么大量的随机（随机就说明是独立的）误差之和就趋向于正态分布。
中心极限定理和大数定律 中心极限定理是说无论抽样分布(卡方、t、F)如何，均值服从正态分布。（正态分布是抽样分布的基础。三大抽样分布是从正态分布抽出的样本的分布。指的不是一个总体内所有变量的概率分布。而是针对一个总体N，用固定的样本容量进行多次抽样，得到的一个有关样本方差、均值的组合。）
而大数定律根本和正态分布无关，只是说样本大了抽样分布近似总体分布。比如说投硬币，投10000次，出现正反面的概率都近似于50%。而若投的次数少，则不会。
两类错误 第一类错误α叫弃真错误或显著性水平，即原假设为真时却被我们拒绝的概率；第二类错误β叫采伪错误，即原假设为伪我们没有拒绝的概率。在一定样本量的情况下，减小一类错误必然会增大另一类错误，在实践中我们一般会优先控制第一类错误，因为原假设是非常明确的。
一般第一类错误不超过5%，即在原假设为真的情况下接受原假设的概率要超过95%。
置信区间、置信度（置信水平） 在中心极限定理中，我们知道从总体中进行N次样本（一个样本中包含多个数据）抽取，N次样本的均值会围绕总体均值上下波动。因此，置信区间就是为总体的均值提供了一个可波动的范围，置信区间与置信度是相对应的。例如，在95%的置信度下，置信区间为【a,b】，可以近似的理解成抽取10000次样本，其中有9500次样本的均值能够落在【a,b】范围内。
详细内容见：理解置信区间、置信度
求解置信区间：
协方差是啥，怎么判断协方差正负 协方差在概率统计中用于衡量二个变量的总体误差，通俗解释就是用于衡量二个变量变化趋势的一致程度。当这二个变量变化趋势相同时，为正相关关系，协方差为正。当这二个变量变化趋势相反时，为负相关关系，协方差为负。协方差为0代表两个变量不相干。
从而导致协方差的大小不能真实反映二个变量的相关程度，因此引出相关系数来。
辛普森悖论的例子 ABtest 1.在abtest的应用中 p值的意义，第一类和第二类错误的定义是什么？ p值是假设检验中用于判断显著性的指标。第一类错误α叫弃真错误或显著性水平，即原假设为真时却被我们拒绝的概率；第二类错误β叫采伪错误，即原假设为伪我们没有拒绝的概率。
2.abtest的流程 选取指标-&gt;建立假设-&gt;计算样本量-&gt;假设检验
幸存者偏差 所统计的数据全都来源于幸存的人，因为失败出局者根本没机会给出回答。当样本中有数据缺失时可能出现幸存者偏差。在幸存者偏差这个问题中，我们观察到的样本是被筛选过的有偏样本。例如记者春运的时候在火车上问大家买票难不难，最终得到结论：春运买票很简单（忽略了没有买到票的人）。
解释：幸存者偏差，就是忽略了筛选条件，把经过筛选的结果当成随机结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82fb6fb1be9ae687268a3e8df4c75018/" rel="bookmark">
			locust监控界面的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		locust性能测试界面分为New test、Statistics、Charts、Failures、Exceptions、Download Data、Top七个部分。
1、New test 点击该按钮可对模拟的总虚拟用户数和每秒启动的虚拟用户数进行编辑。
Number of users to simulate：模拟的总虚拟用户数
Hatch rate (users spawned/second)：每秒启动的虚拟用户数
HOST：测试的地址
2、Charts 测试结果变化趋势的曲线展示图，分别为每秒完成的请求数（RPS）、响应时间、不同时间的虚拟用户数。
RPS
响应时间
不同时间的虚拟用户数
3、Statistics 类似于jmeter中Listen的聚合报告。
Type：请求类型，即接口的请求方法；
Name：请求名称；
requests：当前已完成的请求数量；
fails：当前失败的数量；
Median：响应时间的中间值，即50%的响应时间在这个数值范围内，单位为毫秒；
90%ile：90%的接口响应时间小于这个值的；
Average：平均响应时间，单位为毫秒；
Min：最小响应时间，单位为毫秒；
Max：最大响应时间，单位为毫秒；
average Size：平均每个请求的数据量，单位为字节；
current RPS（requests per second）：每秒钟处理请求的数量，即RPS。
4、Failures 失败请求的展示界面。即服务器原因导致无法处理请求。
5、Exceptions 异常请求的展示界面。
6、Download Data 测试数据下载模块， 提供三种类型的CSV格式的下载，分别是：Statistics CSV、responsetime CSV、failures CSV、exceptions CSV。
Statistics CSV
statistics csv的数据信息和前面Statistics的是一致的。
responsetime CSV
responsetime CSV和Statistics介绍的90%ile类似，更精确地显示响应时间在各区间分布情况。
7、Top 即头部的信息，包括host、slaves、RPS、failures等重要信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0948db4c9d07eab3c8e31693beeaf5f4/" rel="bookmark">
			怎样提升自己的理解力？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解力，解决的是关于知识输入的一系列问题。
那么问题来了，那么什么是理解力呢？这个理解力反应在那？
我们常说的理解力差，究竟会对我们的学习造成多大影响呢？ 一：什么是理解力？
我们这里不枯燥的讲理论，因为我这样说，很多同学可能对理解力差这个词还是没有什么概念，有的同学可能还会觉得，我不觉得我理解力差啊，我觉得我理解力还行啊。 那么你的理解力究竟怎么样，我们来做一个小小的测试，让你直观感受下你的理解力究竟怎么样。 我们来一起读篇文章，去试试，这个是我从咱们的历史教材里选出来的。 我来带你看一下~ 我把第二段也放出来，你稍微耐心看一下，我们后面是有目的的~
好了，我们就先看到这里吧，如果说：现在我让你快速的概括一下这两段，告诉我这两段讲了些什么，我想你应该是有点慌了，你心里应该是很空的。 你这里可以想一下，是不是这样... 可能你憋了半天，最后告诉我这是一篇关于工业革命的文章...... 或者你会说，这两段我读了，写的很枯燥，没什么意思。 其实你这句话就是在掩饰，你啥也没读懂，我们可以回想下我们读过的所有的书也好，听的课也好，你是不是除了读小说外，几乎都是这样。 那么我看到这篇文章的时候，我是怎么读的呢？
我是这样读的~ 我看到标题，我会先明确告诉自己，这是一篇讲工业革命起源，也就是工业革命是如何发生的文章。
首先第一句，我看到了多种条件和因素共同促成了最初的工业革命。
回想一下，你刚才看到这句什么反应？ 我大多数人是没什么感觉的，我看到这一句的时候是这样的，我的脑中会自动生成一个框架，大概是会有这么几个框框，然后他们共同导致了工业革命。 好，接着往下读，我们看到了其中之一的农业革命~ 这个时候我的脑中会自动补位，把农业革命填充到第一个圈中。
然后我们接着往下，它说粮食产量大大提高，释放了人口数量，这个是在进一步讲农业的。 然后继续往下，我们看到了：释放了消费力，也是进一步讲农业的。 然后往下看到了，释放了劳动力，也是讲农业的~ 好了，到这里，这一段就完了，整段说的就这么多东西。 好，到这里，这个套路你应该知道了，我们接下来快点过一下，再往下~ 我们看到了资本，也就是讲钱的因素的，资本下面，有支撑发展的银行、和信用体系、利润，商业氛围，搞钱重商的思想。 再往下，我们一眼就能看到资源因素，交通运输因素，市场因素...... 当你能把这些点抓出来以后，你就可以口述了，是这些条件和因素，共同促使了工业革命诞生。
好了，我们把这一系列的东西读出来，你现在感觉怎么样？ 试想一下，如果你在阅读的过程中，也能在脑中能出现这张图的时候，你还不能理解吗？还不能概括？还懵吗？ 我想，你当然不会这样，你可以非常清晰有逻辑的，迅速把这篇文章啃下来，并能转述给别人，你读到了什么。 事实上，我在读这些的时候，这些都是一眼抓的，真正阅读的时候，可能比这个演示还要快一些，我们很多人都说自己读书效率低，你这里可以想一下，当你能掌握了这种抓重点的能力以后，你觉得你觉得你这个读书效率怎么样？ 所以，我们就可以给理解力下个定义了，这个能迅速的在一堆信息中清晰、准确的抓住对方的意思重点的能力，并组合重点形成逻辑的能力，就是我们说的理解力，这种能力体现在学习中，可以造成两个人学习效率天和地的差异，这也是为什么同样的材料，很多人读十遍还稀里糊涂，但是高手读一遍就能做到可复述的原因。 那么问题来了，我们如何做到呢？怎么才能提振我们的理解力呢？ 二：如何提振理解力？
想要回答这个问题，我们就需要先了解一些背景知识，也就是我们的大脑是怎么思考的！ 你现在看到的这个是，来自于认知心理学 的一个描述我们大脑在认知思考的一套模型，这个模型在我们的招生文案中就已经提到过很多次了~ 这个模型的意思是说：当知识输入进来的时候，会先进入我们的思考区，我们的思考区会对知识进行一系列的操作，从而理解它。
然后通过大量思考加工后，知识会进入长期记忆，成为我们的知识储备。
在遇到问题的时候，我们的思考区会调用我们大脑已经有的知识储备去解决问题，完成整个思考闭环。
当然，可能我这样说有些抽象，我们不妨玩个游戏，我们先来做个小小的测试，看看这个过程是怎么发生的~ 首先呢：请你心算下这道小题~
你告诉我：7*8=多少？ 你可能会说 5×8=40、6×8=48、7×8=56 啊。 嗯，没问题，你能瞬间就能秒掉~ 那你秒到的这个过程发生了什么呢？ 这个时候，如果我们把大脑思考放慢，你会发现这么一个过程，首先你的思考区接到了我的问题指令，当你把我的问题解读出来以后，你会马上搜索你的长期记忆，然后找到 7*8=56，然后把这个答案返回，从而完成整个思考。 好了，我们先不管上道题，我们再来一道题，也是心算~ 请听题：请问 178*178=多少？
我敢保证，虽然你知道怎么得出答案，除非用一些特殊技巧，否则单凭心算你会发现你算不出来的。 但是如果给你纸笔，让你把记忆的负担全部转嫁到纸上，你只需要操作算式，你发现你是能算出来的。 通过这两个小测试，我们就能看出来，是什么影响了我们的理解力了。 第一个结论是背景知识：
这个背景知识，你可以理解成知识储备。 在上面那个小题中，我们之所以能迅速秒掉第一个，是因为我们自小就把小九九 背的滚瓜烂熟，因为我们脑子中有小九九这个背景知识，所以，我们的思考区是不需要进行任何额外思考，就可以直接从长期记忆中把它提取出来，这就是为什么我们能如此丝滑的把它秒掉的原因。 但是第二个小题，我们的脑子就没有背景知识，所以我们就没有办法很快说出，如果想要对这个问题快速回答，我们就需要耗费大量的脑力去学会和补全这个背景知识，我们可能秒掉它。 所以，你看到了，背景知识对我们理解力的影响极大，如果学习一个新知识点，有背景知识我们可以快速理解，但是没有背景知识，我们理解起来就会很慢。
这就是为什么我们上了高中以后，我们和哪些学霸一起上课，他们总是能学的如鱼得水，原因就是他们在初中的时候底子就打的很好，他们能迅速的把这些背景知识调入到工作记忆中，帮助理解更复杂的高中知识，但是我们这些学渣，因为初中的底子没打好，想要理解一个新的知识点就需要耗费大量的思考重新获取知识储备，于是这个距离越差越大。 所以掌握足够多的背景知识，具备一定的知识储备是我们理解力的核心因素。
但是掌握足够多的背景知识，真的不是我们这里听一节课就能解决的，它需要一个长期积累的过程，这里你先知道这个结论就行，这一点我们会留在后面的训练营会给出具体的精进思路，这里我们先不过多展开。 好了，上面你知道了影响我们理解力的第一个原因，除此之外，还有一个非常重要的原因，可以说，我们绝大多数的理解力问题，都出在了这里，这个原因就是： 工作记忆的局限性，也就是我们的思考区的思考空间有限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0948db4c9d07eab3c8e31693beeaf5f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc202c9280621346b71c4425970482aa/" rel="bookmark">
			VTK cmake 过程中找不到QT5目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： ubuntu 中VTK cmake 过程中找不到QT5目录
问题描述： cmake-gui 中，勾选VTK_Group_QT后，Configure报错：
By not providing "FindQt5.cmake" in CMAKE_MODULE_PATH this project has asked CMake to find a package configuration file provided by "Qt5", but CMake did not find one. Could not find a package configuration file provided by "Qt5" with any of the following names: Qt5Config.cmake qt5-config.cmake Add the installation prefix of "Qt5" to CMAKE_PREFIX_PATH or set "Qt5_DIR" to a directory containing one of the above files.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc202c9280621346b71c4425970482aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47532ff435146dbd3f1c50617ce85dbf/" rel="bookmark">
			【Linux】 command “yum” not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天试一下mint 说实在的 比centos 复杂
首先 yum命令竟然不能运行 提示command “yum” not found
怎么办 安装!
命令 sudo apt install yum 即可
然后升级 提示需要root 身份进行 su 按回车 发现切换不了
因为密码为空
必须为root设置密码
sudo passwd root
设置完密码 运行yum 行了 但是提示
没有已启用的仓库。 执行 “yum repolist all” 查看您拥有的仓库。 您可以用 yum-config-manager –enable &lt;仓库名&gt; 来启用仓库
具体参考https://blog.csdn.net/weixin_41931602/article/details/83211455
问题导读
1.rpm存在什么问题？
2.yum有什么优势？
3.apt-get与yum有什么相同之处？
经常会看到yum、apt-get、rpm，那么它们是什么？下面介绍一下。
rpm是由红帽公司开发的软件包管理方式，使用rpm我们可以方便的进行软件的安装、查询、卸载、升级等工作。但是rpm软件包之间的依赖性问题往往会很繁琐,尤其是软件由多个rpm包组成时。
Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。
rpm 是linux的一种软件包名称，以.rmp结尾，安装的时候语法为：rpm -ivh，rpm包的安装有一个很大的缺点就是文件的关联性太大，有时候装一个软件要安装很多其他的软件包，很麻烦，所以为此RedHat小红帽开发了yum安装方法，他可以彻底解决这个关联性的问题，很方便，只要配置两个文件即可安装，安装方法是：yum -y install ，yum并不是一中包，而是安装包的软件
简单点说, rpm 只能安装已经下载到本地机器上的rpm 包. yum能在线下载并安装rpm包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是rpm 工具所不具备的。
yum与apt-get的相同点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47532ff435146dbd3f1c50617ce85dbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eba80cbbffba4ebfc4abe1b215420f1b/" rel="bookmark">
			第40节 指北针实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 本节内容本节代码思路以下为全部代码 本节内容 受网友提问，本节实现一个指北针：
上面左下角的指北针由两部分组成，一部分是指针，一部分是底盘：
底盘动，指针在动，默认朝向Z轴负方向是北，朝向X轴正方向是东。你可以感受一下。其它的方向就是朝向Z正是南，朝向X轴负是西。有人问那Y轴呢？东西南北本来就是一个平面的概念，没有Y轴的事情，Y轴就像人站在平地上，头顶上的方向，相当于朝向天空。
本节代码 本节资源在如下链接/文件中的附件/按章节编号目录中：
【击此打开网盘资源链接】
也可以在本文末获取
思路 首先要实现HUD，在HUD的相机中添加表盘和指标，要注意以下几点：
HUD的相机的观察矩阵默认是单位矩阵，这样观察矩阵默认就是朝向Z轴负方向。 ... //设置HUD的关键步骤，其中设置了观察矩阵是单位矩阵 //以下是设置HUD的七步，正交投影，观察矩阵是单位矩阵，最后渲染，矩阵没有参考帧，不接受事件，只清除深度缓存保持透明 //设置视口大小 camera-&gt;setProjectionMatrix(osg::Matrix::ortho2D(0, 128, 0, 128)); camera-&gt;setReferenceFrame(osg::Transform::ABSOLUTE_RF); camera-&gt;setViewMatrix(osg::Matrix::identity()); camera-&gt;setClearMask(GL_DEPTH_BUFFER_BIT); camera-&gt;setRenderOrder(osg::Camera::POST_RENDER); camera-&gt;setAllowEventFocus(false); camera-&gt;setViewport(0, 0, 128, 128); ... 表盘要在远处，指标要在近处，因此我们给表盘的四个顶点的z值设置的是-0.2，给指针的四个顶点z轴值的是-0.1，这样指针离视点更近 ... //表盘的顶点 osg::Vec3Array* vertices = new osg::Vec3Array; geom-&gt;setVertexArray(vertices); vertices-&gt;push_back(osg::Vec3(0, 0, -0.2)); vertices-&gt;push_back(osg::Vec3(128, 0, -0.2)); vertices-&gt;push_back(osg::Vec3(128, 128, -0.2)); vertices-&gt;push_back(osg::Vec3(0, 128, -0.2)); ... //指针的顶点 osg::Vec3Array* vertices = new osg::Vec3Array; geom-&gt;setVertexArray(vertices); vertices-&gt;push_back(osg::Vec3(0, 0, -0.1)); vertices-&gt;push_back(osg::Vec3(128, 0, -0.1)); vertices-&gt;push_back(osg::Vec3(128, 128, -0.1)); vertices-&gt;push_back(osg::Vec3(0, 128, -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eba80cbbffba4ebfc4abe1b215420f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc16cf18e15a7ff27610eac208da45f/" rel="bookmark">
			Kibana如何添加索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES可以作为日志系统，要比专门去找对应的日志存档效率要高，直接通过搜索KQL或者Lucene（这里指的是Lucene的语法，实际上直接搜索关键词就可以了）。
但是我们在Kinaba上看到的索引（你也可以理解每一份对应的日志）上没有你想要的，你该如何去建立索引去查找日志，具体操作过程如下：
这里假设你的数据都已经添加进去或者是自动收集的，你要做的就是创建一个索引对应起来，能在discover里面能看到就可以。
点击管理，去添加索引
索引模式，去创建索引模式
找到你要的源（红框框住的地方），创建索引起个名字，完成即可
这时候你新建的索引就能在Discover的下拉框能找到
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f989c55ab8a7983475ac3fdc8db7ce30/" rel="bookmark">
			LocalDate获取每周第一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.time.DayOfWeek;
import java.time.LocalDate;
//获取当前时间
LocalDate now = LocalDate.now();
//获取当前时间所在周的第一天
LocalDate with = now.with(DayOfWeek.MONDAY);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1162ee409ca4af87f60eb6a9edd7d832/" rel="bookmark">
			Git最新版 2.28.0详细安装步骤及细节--让你安装不迷茫 (附加经验)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 个人博客地址：https://slcp.top ，欢迎各位光临。
开篇 天下没有免费的午餐，所以我们要尽情白嫖。
Git 最新版 2.28.0详细安装 下载 Git官网
可能有些小伙伴下载慢那么直接百度走起
选择操作系统 安装 根据如下步骤
从此刻起，如果想追求速度的小伙伴，那么一套龙服务走起来，直接next到安装完成，然后后面还有福利哦 Git安装完成了，但并没有结束哦。小伙伴们，应该还需要安装TortoiseGit，这我也给大家准备了 上一篇：程序员必知的IT网站–让你未来不迷茫
下一篇：TortoiseGit最新版2.10.0.2详细安装步骤及细节
相关文章Git详解之必知点----Git、本地仓库、远程仓库、IDEA集成Git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71922216dd00ef0f1e875887e9f3d65d/" rel="bookmark">
			手机浏览器中H5跳转微信小程序长按识别二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务需求： APP中订购课程后发送短信通知，用户点短信中连接进入H5，此时H5是手机浏览器中打开，不是微信生态所以放的客服二微码无法长按识别。如果能H5直接进入微信生态。微信这个接口只向一些大的合作企业提供些接口，我们想用只能网上买第三方的，看过几个第三方接口可以实现但是不稳定。
解决方案： H5这条路走不通，那么就看看小程序。小程序中虽然不能直接长按识别二维码，但是还好小程序有WEB_VIEW，引用H5做的二维码就可以识别。
web-view 承载网页的容器。会自动铺满整个小程序页面，个人类型的小程序暂不支持使用。
src:webview 指向网页的链接。可打开关联的公众号的文章，其它网页需登录小程序管理后台配置业务域名。
这个问题解决了，最重要的是怎么让H5在浏览器中打开直接跳转微信生态（打开小程序），下面看看小程序的这个函数接口
urlscheme.generate 获取小程序 scheme 码，适用于短信、邮件、外部网页、微信内等拉起小程序的业务场景。通过该接口，可以选择生成到期失效和永久有效的小程序码，有数量限制，目前仅针对国内非个人主体的小程序开放，详见获取 URL scheme。
HTTPS 调用 请求地址 POST https://api.weixin.qq.com/wxa/generatescheme?access_token=ACCESS_TOKEN 请求参数 属性类型默认值必填说明access_token / cloudbase_access_tokenstring是接口调用凭证jump_wxaObject否跳转到的目标小程序信息。is_expirebooleanfalse否生成的 scheme 码类型，到期失效：true，永久有效：false。注意，永久有效 scheme 和有效时间超过180天的到期失效 scheme 的总数上限为10万个，详见获取 URL scheme，生成 scheme 码前请仔细确认。expire_typenumber0否到期失效的 scheme 码失效类型，失效时间：0，失效间隔天数：1expire_timenumber否到期失效的 scheme 码的失效时间，为 Unix 时间戳。生成的到期失效 scheme 码在该时间前有效。最长有效期为1年。is_expire 为 true 且 expire_type 为 0 时必填expire_intervalnumber否到期失效的 scheme 码的失效间隔天数。生成的到期失效 scheme 码在该间隔时间到达前有效。最长间隔天数为365天。is_expire 为 true 且 expire_type 为 1 时必填 jump_wxa 的结构
属性类型默认值必填说明pathstring否通过 scheme 码进入的小程序页面路径，必须是已经发布的小程序存在的页面，不可携带 query。path 为空时会跳转小程序主页。querystring否通过 scheme 码进入小程序时的 query，最大1024个字符，只支持数字，大小写英文以及部分特殊字符：`!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71922216dd00ef0f1e875887e9f3d65d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5f41422e484dfa55e49cb30d70138df/" rel="bookmark">
			rtt面向对象oopc——0.类、对象及派生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rt thread源码路径
一、rtt的类与对象
rtt的对象控制块（struct结构体）就是类，
由对象控制块创建的变量就是对象。
形象化点，变量就是对象，变量的类型就是类。
rtt的基本操作单位是对象，任何对象都实质是根据结构体类型创建的一块内存。
二、rtt类的派生和继承关系图
如下rtt的官方图，虽不是很全面但极具代表性。
由图可见，基类（struct rt_object）是所有类的祖先。
三、rtt的各类及其定义所在位置
官方图画的并不是很全面，有些类没有画进去，需要补充下。如下是目前知道的类的派生和继承（目前只统计2个地方定义的类，后续再加）。
另外我把不同父类派生的子类分开统计了。
3.1 在rtt源码目录include / rtdef.h中定义了各基本大类。
第1代-rtt中所有类的祖先
（1）基类 struct rt_object
第2代-继承基类的
（1）定时器类 struct rt_timer
（2）线程类 struct rt_thread
（3）IPC基类 struct rt_ipc_object
（4）heap内存类 struct rt_memory
（5）memheap内存类 struct rt_memheap
（6）内存池类 struct rt_mempool
（7）设备基类 struct rt_device
第3代-继承IPC基类的
（1）信号量类 struct rt_semaphore
（2）互斥量类 struct rt_mutex
（3）事件类 struct rt_event
（4）邮箱类 struct rt_mailbox
（5）消息队列类 struct rt_messagequeue
3.2 在rtt源码目录components / drivers / include / drivers下的.h文件中定义的类。
该目录下很多.h文件，只是粗略统计，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5f41422e484dfa55e49cb30d70138df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c230cd3fe8b05c35ca107859454493/" rel="bookmark">
			FP、FN、TP、TN、精确率(Precision)、召回率(Recall)、准确率(Accuracy)是什么意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在机器学习领域中，用于评价一个模型的性能有多种指标，其中几项就是FP、FN、TP、TN、精确率(Precision)、召回率(Recall)、准确率(Accuracy)。这里我们就对这块内容做一个集中的理解。分为一和二，5分钟。
一、FP、FN、TP、TN 你这蠢货，是不是又把酸葡萄和葡萄酸弄“混淆“啦！！！
上面日常情况中的混淆就是：是否把某两件东西或者多件东西给弄混了，迷糊了。
在机器学习中, 混淆矩阵是一个误差矩阵, 常用来可视化地评估监督学习算法的性能.。混淆矩阵大小为 (n_classes, n_classes) 的方阵, 其中 n_classes 表示类的数量。
其中，这个矩阵的一行表示预测类中的实例（可以理解为模型预测输出，predict），另一列表示对该预测结果与标签（Ground Truth）进行判定模型的预测结果是否正确，正确为True，反之为False。
在机器学习中ground truth表示有监督学习的训练集的分类准确性，用于证明或者推翻某个假设。有监督的机器学习会对训练数据打标记，试想一下如果训练标记错误，那么将会对测试数据的预测产生影响，因此这里将那些正确打标记的数据成为ground truth。
此时，就引入FP、FN、TP、TN与精确率(Precision)，召回率(Recall)，准确率(Accuracy)。
以猫狗二分类为例，假定cat为正例-Positive，dog为负例-Negative；预测正确为True，反之为False。我们就可以得到下面这样一个表示FP、FN、TP、TN的表：
此时如下代码所示，其中scikit-learn 混淆矩阵函数 sklearn.metrics.confusion_matrix API 接口，可以用于绘制混淆矩阵
skearn. metrics. confusion_matrix( y_true, # array, Gound true (correct) target values y_pred, # array, Estimated targets as returned by a classifier labels= None, # array, List of labels to index the matrix. sample_weight= None # array-like of shape = [n_samples], Optional sample weights ) 完整示例代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c230cd3fe8b05c35ca107859454493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e30e23a737756e4bac75085c960c5c/" rel="bookmark">
			Flink集成Kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink集成Kafka Flink可以用于Kafka的生产者，也可以用于Kafka的消费者。
Flink作为生产者 需要创建FlinkKafkaProducer对象作为生产者向Kafka中发送消息
代码实现 public class MyFlinkKafkaProducer { public static void main(String[] args) throws Exception { // TODO 1. 获取执行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); env.setParallelism(4);//并行度的数量需要和Kafka主题中的分区数量一致，效率最高 // TODO 2. 创建数据源 DataStreamSource&lt;String&gt; socketSource = env.socketTextStream("localhost", 9001); // TODO 3. 创建FlinkKafkaProducer对象 Properties conf = new Properties(); conf.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,"hadoop102:9092,hadoop103:9092,hadoop104:9092"); FlinkKafkaProducer&lt;String&gt; flinkKafkaProducer = new FlinkKafkaProducer&lt;String&gt;("first", new SimpleStringSchema(), conf); // FlinkKafkaProducer&lt;String&gt; kafkaProducer1 = new FlinkKafkaProducer&lt;&gt;("hadoop102:9092,hadoop103:9092,hadoop104:9092", "first", new SimpleStringSchema()); // TODO 4. 绑定flinKafkaProducer对象 socketSource.addSink(flinkKafkaProducer); // TODO 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e30e23a737756e4bac75085c960c5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e0c32ed4b4ba63027bc01d29ae6e511/" rel="bookmark">
			CFW最新XSS漏洞，可远程执行代码控制电脑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 简介 1.CFW是什么
使用过机场的朋友应该都听过clash_for_windows，一款便于用户可视化操作和使用的软件。
2月23日，网友@Anthem-whisper通过github Issues向CFW作者提交了可导致远程代码执行的XSS漏洞。由于使用人数多，恶意利用该漏洞可导致被害者电脑植入木马病毒被远程控制，危害巨大。本文章用的是0.19.8版本，做简单的漏洞复现演示其危害，希望大家能赶快更新到最新版本免受被入侵。
2.漏洞产生原因：
CFW存在交互的地方就是导入的clash配置文件，通过往clash配置文件中插入“精心构建”的js代码，当CFW导入该配置文件后，会对其进行解析处理并渲染页面，将节点列表呈现在我们面前，但是由于没有对外部导入的clash配置文件进行安全检测并将非法字符转义处理，导致那段插入的js代码被执行，于是XSS漏洞就产生了。
虽然普通的浏览器页面存在XSS漏洞危害并不大，但通过Electron开发的CFW就不一样了，它可以直接读写电脑的文件，并且可以执行相关系统函数，导致危害性扩大。
3.影响版本
目前低于0.19.9的理论上都有此漏洞，软件作者加急修复更新了一个版本0.19.9，但是并未完全修复漏洞，于是同一日作者又发布了最新的修复版0.19.10
0x02 复现过程 1、制作一个含有xss恶意代码的yaml
关键代码填写在-name：xxxx 处
port: 7890 socks-port: 7891 allow-lan: true mode: Rule log-level: info external-controller: :9090 proxies: - name: a&lt;img/src="1"/onerror=eval(`require("child_process").exec("calc.exe");`);&gt; type: socks5 server: 127.0.0.1 port: "17938" skip-cert-verify: true - name: abc type: socks5 server: 127.0.0.1 port: "8088" skip-cert-verify: true proxy-groups: - name: &lt;img/src="1"/onerror=eval(`require("child_process").exec("calc.exe");`);&gt; type: select proxies: - a&lt;img/src="1"/onerror=eval(`require("child_process").exec("calc.exe");`);&gt; 2、导入.yaml文件后，点击Proxies，触发弹出计算器：
3、执行恶意代码上线CS
CS--&gt;Attack--&gt;Web Driver-by--&gt;Scripted Web Delivery(S) 0x03 修复 目前软件作者加急修复更新了一个版本，希望所有使用CFW的用户尽快升级到该版本并立即停用之前的版本，该漏洞存在于之前所有的CFW版本，考虑到CFW用户的基数，影响范围可以说是非常广了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d8eade75aaa6e9090fe38d3f0bfb1f7/" rel="bookmark">
			scala 裸写 json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 手写简单的json，可以用"""框起来 def TestJson(): Unit = { val campaign_id = 1 val cid = 2 print( s"""{"campaign_id":$campaign_id, "cid":$cid}""" ) } 用转义字符报错
s"{\"campaign_id\":$campaign_id, \"cohort_id\":$cohort_id}" ';' expected but string literal found. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efbda8a6b243940e83e4f7911a259076/" rel="bookmark">
			javaSE之Date类、DateFormat类以及Calendar类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Date类
位于java.util包下，表示特定的瞬间，如时间原点，精确到毫秒
时间原点（0毫秒）：1970年1月1日 00:00:00（中国属于东八区，会把时间增加8小时）
Date输出的格式举例为：Sun Aug 08 15:51:54 CST 2022
Date类中的很多方法都已经过时，被Calendar类中的相关方法替代，下面介绍仍在使用的
1.构造方法：
Date类的空参数构造方法：Date(); //获取当前系统的时间与日期
Date类的带参数构造方法：Date(long date); //把毫秒值转化为Date日期
2.相关方法：
public long getTime(); //返回自1970年1月1日 00:00:00以来Date对象表示的毫秒值
（ 功能上该方法等于：System.out.println(System.CurrentTimeMillis()); )
二、DateFormat类
位于java.text包下，是一个抽象类，不能直接使用，所要需要用到其子类java.text.SimpleDateFormat（日期时间格式化子类），该子类允许进行格式化（日期转文本）和解析（文本转日期）
DateFormat类相关方法：
public String format(Date date); //按照指定模式，把Date日期转化为符合模式的字符串
public Date parse(String source) throws PraseException; //把符合模式的字符串转化为Date日期
SimpleDateFormat类构造方法：
SimpleDateFormat(String pattern); //pattern参数即代表指定的模式
常用的模式规则：y——年 M——月 d——日 H——时 m——分 s——秒
pattern举例："yyyy-MM-dd HH:mm:ss" (模式中的字母不可改变，但连接字母的符合可以改变）
代码如下：
SimpleDateFormat sdf=new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");
Date date=new Date(); //获取当前系统的时间与日期
String str=sdf.format(date); //SimpleDateFormat子类调用父类format方法
Date d=sdf.parse("2022年2月28日 20时06分15秒"); //把符合模式的字符串解析为Date日期
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efbda8a6b243940e83e4f7911a259076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b372c8254bbb0e0b25f137bbf999c2d/" rel="bookmark">
			centos8重新配置yum源(Errors during downloading metadata for repository ‘AppStream‘)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos8重新配置yum源(Errors during downloading metadata for repository ‘AppStream’) 近期使用centos8yum安装发现使用不了，报错信息如下：
# yum 安装软件失败 [root@wangting ~]# yum install -y lrzsz CentOS-8 - AppStream 33 kB/s | 2.3 kB 00:00 Errors during downloading metadata for repository 'AppStream': - Status code: 404 for http://mirrors.cloud.aliyuncs.com/centos/8/AppStream/x86_64/os/repodata/repomd.xml (IP: 100.100.2.148) Error: Failed to download metadata for repo 'AppStream': Cannot download repomd.xml: Cannot download repodata/repomd.xml: All mirrors were tried 【原因】: 提示的url地址明显是官方的，却报错了Status code: 404，根据这个关键词显然是地址失效了 http://mirrors.cloud.aliyuncs.com 地址无法打开 去官方查看了一番，发现阿里云开发者社区又一篇公告： https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.48b31b115C6PIW 通知： CentOS 8操作系统版本结束了生命周期（EOL），Linux社区已不再维护该操作系统版本。建议您切换到Anolis或Alinux。如果您的业务过渡期仍需要使用CentOS 8系统中的一些安装包，请根据下文切换CentOS 8的源。 centos8（centos8官方源已下线，建议切换centos-vault源） wget -O /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b372c8254bbb0e0b25f137bbf999c2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/675ba3f8d8c2418d7fd3d1d289faecdd/" rel="bookmark">
			Java设计模式面试题及答案（持续更新。。。）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java面试题及答案(2022版)，每道都是认真筛选出的高频面试题，助力大家能找到满意的工作！
Java设计模式面试题及答案
下载链接：全部面试题及答案PDF 1.请列举出在 JDK 中几个常用的设计模式？ 单例模式（Singleton pattern）用于 Runtime，Calendar 和其他的一些类中。工厂模式
（Factory pattern）被用于各种不可变的类如 Boolean，像 Boolean.valueOf，观察者模式
（Observer pattern）被用于 Swing 和很多的事件监听中。装饰器设计模式（Decorator
design pattern）被用于多个 Java IO 类中。
2.什么是设计模式？你是否在你的代码里面使用过任何设计模式？ 设计模式是世界上各种各样程序员用来解决特定设计问题的尝试和测试的方法。设计模式是代码可用性的延伸
3.Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式 单例模式重点在于在整个系统上共享一些创建时较耗资源的对象。整个应用中只维护一个特定类实例，它被所有组件共同使用。Java.lang.Runtime 是单例模式的经典例子。从 Java5 开始你可以使用枚举（enum）来实现线程安全的单例。
4.在 Java 中，什么叫观察者设计模式（observer design pattern）？ 观察者模式是基于对象的状态变化和观察者的通讯，以便他们作出相应的操作。简单的例子就是一个天气系统，当天气变化时必须在展示给公众的视图中进行反映。这个视图对象是一个主体，而不同的视图是观察者。
5.使用工厂模式最主要的好处是什么？在哪里使用？ 工厂模式的最大好处是增加了创建对象时的封装层次。如果你使用工厂来创建对象，之后你可以使用更高级和更高性能的实现来替换原始的产品实现或类，这不需要在调用层做任何修改。
6.举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？ 装饰模式增加强了单个对象的能力。Java IO 到处都使用了装饰模式，典型例子就是Buffered 系列类如 BufferedReader 和 BufferedWriter，它们增强了 Reader 和 Writer 对象，以实现提升性能的 Buffer 层次的读取和写入。
7.在 Java 中，为什么不允许从静态方法中访问非静态变量？ Java 中不能从静态上下文访问非静态数据只是因为非静态变量是跟具体的对象实例关联的，而静态的却没有和任何实例关联。
8.设计一个 ATM 机，请说出你的设计思路？ 比如设计金融系统来说，必须知道它们应该在任何情况下都能够正常工作。不管是断电还是其他情况，ATM 应该保持正确的状态（事务） , 想想 加锁（locking）、事务（transaction）、错误条件（error condition）、边界条件（boundary condition） 等等。尽管你不能想到具体的设计，但如果你可以指出非功能性需求，提出一些问题，想到关于边界条件，这些都会是很好的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/675ba3f8d8c2418d7fd3d1d289faecdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3ade2128151ec039ddff952219046f/" rel="bookmark">
			WEB安全实战（带靶场）–暴力破解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WEB安全实战（带靶场）–暴力破解 靶场一：DVWA中的暴力破解 靶场二：靶场实验 暴力破解 暴力破解百度云链接（失效请在评论区通知）
链接：https://pan.baidu.com/s/1FcNFC27VFBfQy0ZMnB_TAg
提取码：1234
Brute Force（暴力破解） Brute Force是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一，如2014年轰动全国的12306“撞库”事件，实质就是暴力破解攻击，Web安全中的暴力破解也是利用尝试所有的可能性最终获取正确的结果。
靶场一：DVWA中的暴力破解 源码解析 if( isset( $_GET[ 'Login' ] ) ) { # 获取用户名和密码 $user = $_GET[ 'username' ]; $pass = $_GET[ 'password' ]; $pass = md5( $pass ); # 查询验证用户名和密码 $query = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';"; $result = mysql_query( $query ) or die( '&lt;pre&gt;' . mysql_error() . '&lt;/pre&gt;' ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { # 输出头像和用户名 $avatar = mysql_result( $result, 0, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd3ade2128151ec039ddff952219046f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f9f0dff741c0abe69c5454d7030d217/" rel="bookmark">
			网络协议与分析--GNS3安装及环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GNS3安装 GNS3安装包（全）百度云下载链接
https://pan.baidu.com/s/1D5XFut_JfBqUZa1leIQmpg
提取码：566c
Wireshark百度云下载链接
https://pan.baidu.com/s/1bDH4kpau8dKEOf_K-gVDAA
提取码：v1vl
文章目录 一、GNS3安装1 GNS3软件安装2 路由交换机配置文件导入 1 GNS3软件安装 1、双击打开
2、点击同意
3、默认选项
4、Npcap和Wireshark必须选缺一不可（安装下载慢也可自行下载–文章开头百度云链接）
5、选择安装路径
6、等待下载wireshark (可以先去喝杯咖啡等待一下下)
7、等待安装Solar
8、选择否
9、最后点击Fnish
———————————————————————
2 路由交换机配置文件导入 1、打开GNS3——Edit—Preferences（Ctrl+Shift+P）
2、选择IOS routers——New
3、选择New Image——Browse 4、导入下载好的c3660
5、后面全部直接下一步
6、导入完成，点击Apply应用
导入c3745此处选择模块接口WIC-2T
GNS3环境到此就配好了，具体的搭建使用见下一章
网络协议与分析–GNS3设备搭建与使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e033548c7fd62f7d193f2f4d941139c/" rel="bookmark">
			子网划分和掩码计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP 地址分类：
子网转换计算：
进制之间转换算法：
e.g. 掩码255.255.255.245换算成二进制写法
解法：
245=128+64+32+16+4+1=2^7+2^6+2^5+2^4+2^2+2^1
因此，转换成二进制的写法为 11111111.11111111.11111111.11110101
注意：二进制转十进制同理逆推。
子网划分：
1. 利用子网数目计算掩码子网划分： 公式：2^n=m
e.g.1 将C类地址192.168.30.0/24划分成4个子网，写出每个子网的地址范围和对应的子网掩码
解法： 4 个子网，即m=4。则n=2，表示掩码在默认基础上再向右借2位，最终子网掩码写为255.255.255.11000000=255.255.255.192，或者写成26
下面开始计算各个子网IP的范围：
子网掩码向右借2位，则所有的4种借位写法如下：
00000000=0
01000000=64
10000000=128
11000000=192
因此，每个子网的起始IP地址如下：
1）192.168.30.0
2）192.168.30.64
3）192.168.30.128
4）192.168.30.192
去掉每个网段的全0和全1位（因为0是网段号，1 是广播地址），则每个子网段的IP地址范围是：
1）192.168.30.1—192.168.30.62/26
2）192.168.30.65—192.168.30.126/26
3）192.168.30.129—192.168.30.190/26
4）192.168.30.193—192.168.30.254/26
2. 利用主机数目计算掩码
e.g.2 一个B类地址160.100.0.0/16划分成若干个子网，每个网段中最多有500台主机。计算子网掩码.
解法： 500台主机，则2^n≥500，n=9。因此主机位有9位，掩码写法为：
255.255.11111110.00000000=255.255.254.0/23
这个B类地址可以划分2^7=128个子网，掩码是255.255.254.0
注意：A类地址的主机数可以计算到2^24，B类可以到2^16，C类到2^8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c80bd587a26302c8873113d2d487ed6d/" rel="bookmark">
			leaflet-离线地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载MapTileDownloader
2、下载瓦片地图
3、将下载好的瓦片地图整理到一个文件夹下面
4、使用leaflet加载地图(引入leaflet.js文件)
&lt;style&gt; #map{ width: 600px; height: 500px; } &lt;/style&gt; ... &lt;div id="map"&gt;&lt;/div&gt; ... function getMap(){ var url = './tiles/{z}/{x}/{y}.png' //图片路径 var lmap = L.map('map').setView([28.177,112.88],17) L.tileLayer(url,{ zoom: 17 }).addTo(lmap); } 注：使用MapDownloader工具也可以下载，但是文件和图片的命名不一样，在加载图片路径时会找不到资源
1）MapDownloader文件：
2）MapTileDownloader文件：
5、实现加载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e92d982fa6c85c353ede71da8494afe/" rel="bookmark">
			蓝桥杯-D1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装python3.8.6 找IDEL找了好久，最后搜索出来了，发送到桌面快捷方式了。
二、基础练习 A+B问题 1、不知道怎么输入，看一下别人怎么写的。
2、输入用input,类型为str
3、用split分割，默认分割空格，第二个参数为分割次数。
4、sum（）内参数是可迭代的，如数组之类的。
三、基础练习 数列排序（复习） 1、还是不知道如何输入，看下别人怎么写的
input()应该是\n结束。
2、IDLE可以打印数组，但是打印nums.sort()返回值为None
3、print函数可以使用参数end=’ ’
4、下面的代码错了，因为没有转换为int型
n = int(input()) nums = input().split() print(nums.sort())nums.sort() for i in nums: print(i, end=' ') 5、更新后的代码，加了一个map映射.还是不对，应该是因为没有转换为list导致的。
n = int(input()) nums = map(int,input().split()) nums.sort() for i in nums: print(i, end=' ') 6、最后终于通过了。
n = int(input()) nums = list(map(int,input().split())) nums.sort() for i in nums: print(i, end=' ') 四、十六进制转八进制（复习） 1、还是丝毫无思路呀，python有什么快捷方法吗
2、进制转换知识点
进制换八进制oct(int(n,2))先将二进制换为十进制再将十进制换位八进制
二进制bin（）
十进制int()
八进制oct()
十六进制hex()
3、进制转换后记得先打印出来看看转换后的格式，然后再做处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e92d982fa6c85c353ede71da8494afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5595eb0b1340845ba5759959e92c5ff/" rel="bookmark">
			Comparable接口实现自然排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		商品类：
/** * 商品类 * @author * @create 2022-02-28-13:07 */ public class Goods implements Comparable{ private String name; private double price; public Goods() { } public Goods(String name, double price) { this.name = name; this.price = price; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5595eb0b1340845ba5759959e92c5ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/913b8903c0c77d20cb2af559dcc3c467/" rel="bookmark">
			Docker 下 Yapi 重置管理员账号/密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Yapi 服务已启动
[root@Tseng-HW ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bec094e7ec66 registry.cn-hangzhou.aliyuncs.com/anoy/yapi "node server/app.js" 6 weeks ago Up 13 minutes 0.0.0.0:3001-&gt;3000/tcp, :::3001-&gt;3000/tcp yapi f2348ddaafe9 mongo "docker-entrypoint.s…" 6 weeks ago Up 29 minutes 27017/tcp yapimongo [root@Tseng-HW ~]# 2、进入服务
[root@Tseng-HW ~]# docker exec -it yapi sh /api/vendors # 3、修改config.json文件，创建新的管理员账户
/api/vendors # cd .. /api # ls config.json init.lock log vendors /api # cat config.json { "port": "3000", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/913b8903c0c77d20cb2af559dcc3c467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c34f3d5d75ff4ea609dd83ae3755255/" rel="bookmark">
			HTML表格表单制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据表格的作用及组成
作用：显示数据，展示数据
组成：
&lt;table&gt;用于定义表格的标签
&lt;tr&gt;行
&lt;th&gt;内容&lt;th&gt;表头单元格
&lt;td&gt;内容&lt;/td&gt;单元格
&lt;td&gt;内容&lt;td&gt;单元格
....
&lt;tr&gt;
&lt;/table&gt;
1.&lt;table&gt;&lt;/table&gt;是用于定义表格的标签
2.&lt;tr&gt;&lt;tr&gt;标签用于定义表格中的行，必须嵌套在&lt;table&gt;&lt;/table&gt;标签里面
3.&lt;td&gt;&lt;/td&gt;用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;tr&gt;标签中
4.td代表表格数据（tabledata），即数据单元格的内容
5.&lt;th&gt;标签表示html表格的表头部分，一般位于第一行或第一列，表头单元格文本自动加粗
6.补充标签：&lt;thead&gt;&lt;/thead&gt;:用于定义表格的头部，&lt;thead&gt;标签内必须拥有&lt;tr&gt;标签，一般是位于第一行
&lt;tbody&gt;&lt;/tbody&gt;:用于定义表格的主体，主要用于放数据本体
7.以上标签都是放在&lt;table&gt;&lt;/table&gt;当中
2.表格的相关属性 width="宽" height="高"
border=“添加表格边框，表格边框大小”
cellspacing="单元格间距离"
cellpadding="单元格与内容之间的距离"
bgcolor="表格背景色“
align="表格对齐方式"（left/center/right）
合并单元格属性：
colspan="所要合并单元格列数”合并列，左右合并
rowspan="所要合并单元格行数”合并行，上下合并 3.合并单元格三部曲 1.先确定合并行还是合并列 2.找到目标单元格，写上合并方式=合并的单元格数量，比如：&lt;td colspan="2"&gt;&lt;/td&gt;
3.删除多余的单元格
表单制作
1.表单的作用：用来收集用户信息。
在html当中，一个完整的表单通常由，表单域、表单控件（也称为表单元素）、和提示信息3部分 组成
2.表单域：method提交方法 提交方式（post,get)
&lt;form action="#" name=“表单名称” method="post" &gt;
各种表单元素控件
&lt;/form&gt;
get和post的区别:
1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。 2. Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。 3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。 4. Get执行效率却比Post方法好。Get是form提交的默认方法。 3.文本框
&lt;input type ="text" value="默认值“ placeholder="输入框内容/ maxlength="限制输入数量 &gt;
4.密码框
&lt;input type="password"/ “ placeholder="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c34f3d5d75ff4ea609dd83ae3755255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c0629e57b428476871c58003d541f12/" rel="bookmark">
			STM32单片机初始化定时器卡死；HAL_TIM_Base_Start_IT卡死的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先给出结论：
将.S启动文件添加到工程里，不要使用IDE默认的启动文件。
细说：
环境：STM32F103VET6，IAR，HAL库
现像：TIM2，TIM3初始化到HAL_TIM_Base_Start_IT时，都会卡死到HardFault_Handler()里。
要将.S启动文件添加到工程里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23cce426fb33148057fb4a7eb774183c/" rel="bookmark">
			关于数据库优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于数据库优化 Why 首先是为什么要优化数据库:
1.所有的数据都储存在数据库当中,数据库的数据非常庞大,对数据库中的数据进行CRUD时的速度影响系统的相应速度.
2.系统运行与数据量成正比,就会影响数据库的查询等操作
3.mysql最终的数据需要放在磁盘中
How 我们知道了为什么优化数据库后,聊一聊怎么优化数据库
从以下几个方面:
1.设计数据库时:是否使用三范式,是否使用合适的数据类型,是否使用合适的储存引擎
2.数据可扩展:是否分表分库,读写分离
3.sql语句优化
###关于三范式:
####1NF:字段原子性
原子的意思就是最小,不可再分,在我们设计字段时尽量把字段设计为不可在分字段,比如,name,id,sex等
####2NF:消除对主键的部份依赖
在满足1NF的基础上来设计,主键在表中是由特殊意义的存在,我们尽量不适用主键来进行业务的操作,比如一个学生表中将id设为主键,可以在设置一个student_id这样的字段,这样就不用使用id主键来进行操作了
3NF:添加外键 在满足2NF的基础上来设计,要求表中的每一字段都与主键有直接的联系,而不是间接联系.
**注意:**N范式要遵循在N-1范式的基础上进行设计
sql语句优化 1.数据查询时尽量使用具体字段,尽量避免使用"*"
2.尽量使用VARCHAR,这样会节省空间
3.尽量避免在where条件查询中使用or链接,or可能引起索引失效
4.使用explain分析sql是否为最优,主要是查看该sql是否添加了索引
5.使用合适索引,注意索引不要加在null,一斤含有or的字段
6.索引不要太多,在5个以内
7.避免使用!=或者&lt;&gt;,可能会使索引失效
8.尽量使用数值代替字符串,比如0–‘女’,1–‘男’,这样会提高查询效率
9.优化like语句,like语句中只有,'条件%'这种会使索引生效
10.批量插入,提高效率,避免批量删除
11.尽量不要多表查询,控制在三张表之内
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9c5dc54a67e3a2bdf4f2e235b98685/" rel="bookmark">
			免杀工具BypassAv-web使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 介绍 nim 一键木马免杀项目，目前能完美过360、火绒等杀软。作者使用纯nim语言编写的shellcode记载器，代码基本是从之前c++版本平移过来，作者并没有提供部署教程，踩坑记录下。
0x02 使用教程 环境：ubuntu 20.4
安装：
# 下载代码库 cd /root git clone https://github.com/M-Kings/BypassAv-web.git # 起个Ubuntu的docker 安装docker : apt install docker.io docker run -itd -p 8001:8000 -v /root/BypassAv-web/:/root/BypassAv-web/ ubuntu # 进入docker容器，这里的4d是容器id，每次启动容器示例不一样，自己docker ps看一下 docker exec -it 4d bash # 安装必备组件 apt update apt install python3 python3-pip nim vim wget unzip mingw-w64 # 进入代码所在目录 cd /root/BypassAv-web/ # 创建两个必备目录，作者代码里并没有自动创建 mkdir files mkdir temp # 作者代码里写了绝对路径，所以要去改一下 # nim/views.py 84行 vim nim/views.py 原代码： yesxor = os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d9c5dc54a67e3a2bdf4f2e235b98685/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf31720f44495075280377b1e7c52a6b/" rel="bookmark">
			hadoop--ssh免密登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 免密登录原理：密钥对有个公钥和私钥，私钥不能给别人，公钥要给别人，公钥会放在已授权的文件里。流程： A服务器生成密钥对ssh-key-gen（公钥A和私钥A）；从服务器A将 密钥对 拷贝 到服务器B中存放公钥的文件夹中；服务器A的ssh访问服务器B，发送数据（数据用私钥A加密）；服务器B接收到数据，授权key中查找公钥A，并解密 数据；若在服务器B中找到A公钥，则采用A公钥 加密 的数据 返回 给 服务器A；服务器A接收到数据之后用A私钥解密数据。 配置ssh 使用命令pwd来到home目录；
使用命令ll -al查看home目录下的所有文件，找到.ssh文件；
命令cd .ssh/进入该目录并查看该目录下的文件，找到known_hosts；
由于之前对hadoop102和hadoop103启动了免密登录，所以可以在hadoop102和hadoop103中找到.ssh文件，但是在Hadoop104中未找到.ssh文件；
配置hadoop102无密访问hadoop103和hadoop104，输入ssh-keygen -t rsa生成密钥对，敲三次回车；
查看.ssh下生成的文件，生成了一个公钥文件id_rsa和一个私钥文件id_rsa.pub；
接通hadoop102和hadoop103，命令ssh-copy-id hadoop103把hadoop102的公钥给hadoop103，输入1次密码后续即可进行免密登录；
在hadoop102上输入命令ssh hadoop103开启免密登录，命令hostname可以查看当前主机号，退出登录用命令exit; hadoop102对hadoop104同理；hadoop103对hadoop102，hadoop103和hadoop104同理。
用户amelia对hadoop103和hadoop104做免密登录，执行免密发送a.txt，发送成功。
注意：要用到免密登录的用户，每一个都需要配置一下免密登录。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918aa20fc4bb4e30e59fcdd59d648d3f/" rel="bookmark">
			使用Sequential
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不使用Sequential import torch from torch import nn import torchvision from torch.nn import Conv2d, MaxPool2d, ReLU, Linear, Flatten from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter class MyModule(nn.Module): def __init__(self): super(MyModule, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=32, kernel_size=5, padding=2) self.maxpool1 = MaxPool2d(kernel_size=2) self.conv2 = Conv2d(in_channels=32, out_channels=32, kernel_size=5, padding=2) self.maxpool2 = MaxPool2d(kernel_size=2) self.conv3 = Conv2d(in_channels=32, out_channels=64, kernel_size=5, padding=2) self.maxpool3 = MaxPool2d(kernel_size=2) self.flatten = Flatten() self.linear1 = Linear(in_features=1024, out_features=64) self.linear2 = Linear(in_features=64, out_features=10) def forward(self, x): x = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/918aa20fc4bb4e30e59fcdd59d648d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f3104f0c713674889091475081370fa/" rel="bookmark">
			node&#43;express编写后端接口，部署到服务器上，并配置nginx&#43;ssl证书，实现https访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		零、开始前的准备 window 要装有 node和npm还有git工具服务器（阿里云或腾讯云都可）域名（备案过的） 以上准备没做好的请自行上网查询准备
一、在本地使用node+express编写后端接口 express简介及入门教程
1.新建一个项目文件夹 2.使用vscode打开 3.安装express框架 3.1初始化npm（出现提示后一直回车即可）
npm init 运行结果：
运行完之后会出现一个package.json的配置文件，说明初始化npm成功
4.安装express npm i express 5.一个test.js文件，编写一个简单的 get/post 接口 // 1.引入框架 // node项目采用 common.js，不能采用 import 引入，只能用 require 方式 const { response } = require('express') const express = require('express') // 2.创建应用 const app = express() // 3.创建路由规则 // get请求 app.get('/hello', (request, response) =&gt; { // 设置响应头 设置允许跨域 response.setHeader('Access-Control-Allow-Origin', '*') // 设置响应体 response.send('Hello node') }) // post请求 app.post('/server', (request, response) =&gt; { // 设置响应头 设置允许跨域 response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f3104f0c713674889091475081370fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb8805dd1ed8b17e1c67e042de768f28/" rel="bookmark">
			MySql时间处理及interval函数运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySql时间操作
1.interval的说明
1.1、当函数使用时，即interval(),为比较函数，如：interval(10,1,3,5,7); 结果4；
原理：10为被比较数，后面1,3,5,7为比较数，将后面四个依次与10比较，看后面数字组有多少个少于10，则返回其个数。前提是后面数字组为从小到大排列，否则返回结果0。
1.2、当关键词使用时，表示为设置时间间隔，常用在date_add()与date_sub()函数里，
如：interval 1 day ，解释为将时间间隔设置为1天
日期增加年，月，天，小时，分，秒
select date_add(日期, interval 1 day); 日期加天
select date_add(日期, interval 1 hour); 日期加小时
select date_add(日期, interval 1 minute); 日期加分
select date_add(日期, interval 1 second);日期加秒
select date_add(日期, interval 1 microsecond); 日期加微秒
select date_add(日期, interval 1 week); 日期加周
select date_add(日期, interval 1 month); 日期加月
select date_add(日期, interval 1 quarter); 日期加季度
select date_add(日期, interval 1 year); 日期加年
————————————————
版权声明：本文为CSDN博主「杨熤」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_44641729/article/details/103793995
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0b1b3700e37b4325db18f7f35c8e13e/" rel="bookmark">
			MatLab学习笔记一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于复杂的数值计算问题，可以利用计算机进行问题求解，即利用计算机运算速度快、计算机精度高的特点，通过重复执行简单的操作，完成复杂的计算。
科学计算(Scientific Computing)是利用计算机处理数值问题的方法。既有数学理论上的抽象性和严谨性，又有程序设计技术上的实用性和实践性。
科学计算与MATLAB语言的关系 数值问题——&gt;求解算法——&gt;程序实现——&gt;结果分析
MATLAB语言的主要功能 ①数值计算②符号计算③图形绘制④程序流程控制⑤工具箱
MatLab编程基础 一、M文件编辑器 1、创建M文件的方法
（1）在MatLab命令行运行窗口运行指令edit；
（2）单击MatLab主页中的新建脚本
（3）选择MatLab主页上的新建脚本图标
（4）右键当前文件夹框空白处，选择“新建”，点击脚本；
（5）使用快捷键CTRL+N；
2、打开已有的M文件
（1）在命令行运行窗口运行指令edit filename；
（2）使用文件夹窗口点击打开；
3、保存M文件
（1）使用菜单栏的保存按钮
（2）使用快捷键CTRL+S；
4、文件的执行
（1）在编辑器打开M文件，然后点击菜单栏的运行
（2）在命令行窗口输入M文件的文件名，注意：不包括后缀名；
二、控制流 1、if语句和switch语句的比较
if语句switch语句比较复杂，特别是嵌套使用的if语句可读性强，易于理解当比较字符串时要借助strcmp函数可直接比较不同长度的字符串可检测相等和不相等仅检测相等 2、循环结构
（1）for循环结构
语法：
for index = values statements end 案例：
s = 10; H = zeros(s) for c = 1:s for r = 1:s H(r,c) = 1/(r+c-1); end end (2)while循环结构
语法：
while expression statements end 案例：
求出Fibonacci数列中第一个大于9999的元素
function [i,z] = fibonacci() a(1) = 1; a(2) = 1; i = 2; while a(i) &lt; 10000 a(i+1) = a(i) + a(i-1) i = i+1; end z = a(i) end 三、控制流的其他指令 1、return指令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0b1b3700e37b4325db18f7f35c8e13e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d1c767ed2597058378990e10ca7432/" rel="bookmark">
			修改kali 终端背景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建一个目录
2.选择图片，修改透明度，点击应用即可
透明度可根据自己的喜好调整
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bc4efa3b0d97259e4578f51ebf6c3eb/" rel="bookmark">
			springboot聚合项目如何打jar包？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章参考了多篇博客，总结了父工程、含有启动类的子工程、不含启动类的子工程、含有mapper的子工程等多种形式的pom.xml配置及打包方式。
1.1 项目结构 该项目是一个pom聚合项目
1.2 在父工程的pom.xml中加上 &lt;packaging&gt;pom&lt;/packaging&gt;表示打包方式为聚合项目。build直接覆盖原来的build即可。
&lt;packaging&gt;pom&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;${java.version}&lt;/source&gt; &lt;target&gt;${java.version}&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.2&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;!--默认关掉单元测试 --&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1.3 在含有启动类的子工程中 含有启动类的子工程，需要指定启动类地址，打包完成后执行jar包就是执行该启动类。
&lt;packaging&gt;jar&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定该Main Class为全局的唯一入口 这里是启动类的地址 --&gt; &lt;mainClass&gt;org.javaboy.vhr.VhrApplication&lt;/mainClass&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt;&lt;!--可以把依赖的包都打包到生成的Jar包中--&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1.4 不含有启动类的子工程中 不含启动类的子工程，在中取消生成jar包，否则在使用maven进行打包的时候，一直提示“程序包xxx不存在，找不到符号”
&lt;packaging&gt;jar&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bc4efa3b0d97259e4578f51ebf6c3eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599089b199fb799861cfb35d05a46460/" rel="bookmark">
			Golang 基本类型字符串、数组和Slice
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串String 字符串的底层表示
type StringHeader struct { Data uintptr Len int } Data 指向底层的字符数组Len 表示字符串的长度 Go语言中，所有的文件都采用UTF-8编码，字符常量也是用的是UTF-8字符编码集。UTF-8 是可变长的编码方式，比如ASCII码 就用一个字节表示，中文就是3个字节表示。我记得ASCII的UTF-8编码是最高位为0。
使用range 轮询字符串，所出来的是utf-8编码的符文rune。比如"Hello你好"，它轮询的时候，就是挨个输出H e l l o 你 好。
字符串与字节数组的转换 a := "hello world" b := []byte(a) c := string(b) 当a通过[]byte转换为b后，可能会觉得Go会把StringHeader.Data指向的字符数组地址直接给到b，但不是，因为string是不可修改的，所以StringHeader.Data指向的字符数组是不能直接拿出来修改的。所以这里就牵涉到了复制，当字符串长度大于32字节，还需要申请堆内存，所以牵涉到大字符串转换的时候，要考虑一下对内存的影响，比如日志的函数内部就不可能直接将字符串转换为[]byte数组。所以要考虑如何用指针就能将其弄出来呢？需要熟悉unsafe.Pointer 和 uintptr转换，可以看这篇文章Go指针的使用限制以及unsafe.Pointer的突破之路
这里，我们先把Slice的底层结构给出来
type SliceHeader struct { Data uintptr Len int Cap int } type StringHeader struct { Data uintptr Len int } // 在了解Slice和String的底层结构表示后，也可以使用反射类型来构造 func string2bytes(s string) []byte { stringHeader := (*reflect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/599089b199fb799861cfb35d05a46460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb8a6774a69c6e90de6429ded753264/" rel="bookmark">
			3D重建几种表现形式——深度图，体素，点云，网格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度图（depth map） Depth map 深度图是一张2D图片，每个像素都记录了从视点（viewpoint）到遮挡物表面（遮挡物就是阴影生成物体）的距离，这些像素对应的顶点对于观察者而言是“可见的”。
以上图为例，下图为上图真实场景的depth图。
特点：不能体现3D物体的内部特征，被遮挡的部分无法表示，仅能表示物体相对于视点平面的垂直深度。
体素（voxel） 体素是3D空间中具有一定体积的点，相当于3D空间中的像素（可以参考乐高）。
特点：体素本身不含有位置信息，只谈论与其他体素的相对距离。 点云（Point Cloud） 点云模型往往通过3D激光扫描仪直接获得，故包含了最大量的原始信息。一般来说，点云包括有3D坐标信息，还可以带有色彩信息（RGB）或反射面强度信息。强度信息与物体的材质，粗糙度，反射率等有关，也与发射激光有关。
三角网格（mesh） 网格可以是多边形，而三角网格就是全部由三角形组成的多边形网格。任意多边形网格都能转换成三角网格。
三角网格存储三类信息：
顶点：每个三角形都有三个顶点，各顶点都有可能和其他三角形共享。.
边：连接两个顶点的边，每个三角形有三条边。
面：每个三角形对应一个面，我们可以用顶点或边列表表示面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14b46a0afaf6ea0b58b7036c05375d61/" rel="bookmark">
			unable to access https://github.com/....解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git config --global url."https://".insteadOf git://
可以把 git:// 替换成 https:// 方便使用 https 协议
相反的，如果想要将https 替换成 git，比如我们平时下载不到github的东西，提示 unable to access https://github.com/.......的时候就可以用
git config --global url."git://".insteadOf https://
这个方法来解决，意思就是将用git://替换https://
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2776aecb0c05c1df61e408caf647c1e9/" rel="bookmark">
			在 Windows 使 .NET 应用容器化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 先决条件一、安装 WSL2二、创建 .NET 应用三、创建 Dockerfile四、创建容器五、管理容器参考文档 先决条件 安装 .NET SDK 6.0
安装 Docker 社区版
一、安装 WSL2 # 此命令将启用所需的可选组件 &gt; wsl --install # 将 WSL 2 设置为默认版本 &gt; wsl --set-default-version 2 # 安装 Ubuntu-20.04 &gt; wsl --install -d Ubuntu-20.04 二、创建 .NET 应用 使用命令行创建项目
&gt; dotnet new console -o App -n DotNet.Docker Program.cs 应如下面的 C# 代码所示 ：
Console.WriteLine("Hello World!"); 将此文件替换为以下每秒计数一次的代码：
var counter = 0; var max = args.Length != 0 ? Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2776aecb0c05c1df61e408caf647c1e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6db19934291cd0ce4198d46fbaa426/" rel="bookmark">
			C&#43;&#43; 第一章绪论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1程序设计语言的发展 1.1.1机器语言 一条指令就是一个固定长度的由指令码和地址码组成的二进制位串，这就是计算机唯一可以读懂的语言，一般称为机器语言。
1.1.2汇编语言 汇编语言是人们比较习惯的符号来代替指令编码，用符号二进制地址表示参加操作的数据，这样大大减少了编程工作的困难，后来又改进为“宏汇编语言”，一条宏汇编指令可以代替多条机器指令。
使用汇编语言编程比使用机器语言编程要容易。
机器语言和汇编语言的共同缺点：
1.依赖于机器，可移植性差。
2.代码冗长，不易于编写大规模程序。
3.可读性差，可维护性差。
1.1.3高级语言 与汇编语言和机器语言相比，高级语言更接近人类的自然语言，当然计算机也不能直接识别高级语言编写的程序，要通过编译程序将高级语言编写的程序翻译成机器语言程序（这一过程称为编译），再让计算机运行。
1.2面向对象程序设计的特点 1.2.1.面向对象程序设计的基本概念 1.类
类描述了一组具有相同特性（数据元素）和相同行为（函数）的对象，如汽车，树，书，复数等都是类。
2.对象
对象是现实世界实际存在的事物，是类的一个具体实例，如某一辆汽车，某一棵树，某一本书都是一个对象。
3.属性
类中的特性（数据）称为类的属性，如汽车的颜色，最高时速，载重量等是汽车类的属性，不同的类具有不同的属性。
4.方法
类中的行为（函数）称为类的方法，如汽车类可以有加速方法，刹车方法，转向方法等。不同的类具有不同的方法。
1.2.2面向对象程序设计的特点 封装：是对象和类概念的主要特性。封装是把过程和数据包围起来，只提供一个接口供用户使用，这样提高了代码的安全性，以及使用的简便性。
继承：在c++里一个类可以通过另一个类派生而来，新类被称作派生类，原来的类被称作基类，派生类继承了基类的成员方法和变量，并且可以在类里增加自己的特性函数变量实现特定功能:比如:多人写文章入2021-09-22发布B 工 m而十加粗斜体标题无序有序插入预览帮助基类是圆，派生出圆柱类。这个过程就是类继承。
多态：多态是指允许不同类对象对同一消息做出反应，同一消息。
1.3C++语言的特点 C++是在C语言的基础上发展而来的，同时支持面向对象的程序设计，主要的特点有：
1.C++继承了 C语言的所有特点。包括语言简洁、紧凑，使用方便、灵活；拥有丰富的运算符；生成的目标代码质量高，程序执行效率高；可移植性好等。
2.对 C语言的某些方面进行了一定的改进。如引人 const 常量和内联函数，取代 C语言中的宏定义；引入 reference(引用)概念等。
3.支持面向过程和面向对象的方法。在 C++环境下既可以进行面向对象的程序设计，也可以进行面向过程的程序设计。C++完全支持面向对象的程序设计，包括数据封装、数据隐藏、继承和多态等特征。
1.4简单的C++程序 1.4.1 cout标准输出 使用 cout 进行输出的格式如下：
cout&lt; &lt;特輸出的內容 1&lt;待输出的內容 2…：
称符号&lt;&lt;为插人运算符，即将其后面的数据插入到输出数据流中。由于 cout 和捕人运算符&lt;&lt;都是在系统提供的头文件iostream.h 中声明的，因此要包含该头文件。
一般在头文件下加using namespace std；
在return 0前加system（“pause”）；
1.4.2 cin标准输入 使用 cin 输人数据的格式如下：
ein&gt;&gt;保存数据的变量 1&gt;&gt;保存数据的变量 2…；
符号&gt;&gt;称为提取运算符，即将输人数据流中的数据提取出来。由于 cin 和符号&gt;&gt;也都是在系统提供的头文件 iostream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd6db19934291cd0ce4198d46fbaa426/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee23794be797335121208d9487b9fb0d/" rel="bookmark">
			JVM基础 -＞ ⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？ ⾸先类加载器把字节码⽂件内容加载到⽅法区,当然类加载器这中间用双亲委派机制加载
然后再根据加载完方法区中的类信息在堆区为对象分配内存丶初始化零值丶设置对象头丶执行 init 方法
分配内存: 确定大小的内存从 Java 堆中划分出来初始化零值: 将分配到的内存空间都初始化为零,这样对象只定义,不初始化也可以用设置对象头: 对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等执行 init 方法: 最后就是调用构造方法了,初始化对象,完成创建 对象⾸先会分配在堆内存中新⽣代的Eden。
小对象分配在新⽣代的Eden。然后经过新生代GC，对象如果存活，就会进⼊S区。 在后续的每次GC中，如果对象⼀直存活，就会在S区来回拷⻉，每移动⼀次，年龄加1。多⼤年龄才会移⼊⽼年代？ 年龄最⼤15， 超过⼀定年龄后，对象转⼊⽼年代。 对象够大,分配在老年代 JDK 6 之前存在空间担保 -&gt; 老年代保证我会保留一个连续内存大小的内存空间 如果内存不够,你就可以FullGC,还不够内存溢出如果内存够,那就存进去 JDK 6 之后 -&gt; 老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小(动态年龄) 如果内存不够,你就可以FullGC,还不够内存溢出如果内存够,那就存进去 当创建对象的⽅法执⾏结束后，栈中的指针会先移除掉了,对象就没有GC Roots根节点的引用了
然后GC根据可达性分析法,判断对象是否可以被回收
最后GC线程调用合适的GC算法清理掉可回收的对象
点赞.靓仔!!!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66417629a22a6315466de0fd4e9a68fc/" rel="bookmark">
			Python第三方库turtle的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
前言
1.pip安装turtle库
2.绘图坐标系
3.turtle的画笔控制方法
4.turtle的图形绘制方法
5.简单应用示例
前言 turtle库用于绘制图形的内置函数库。turtle是海龟的意思，turtle绘图可以描述为海归爬行轨迹形成了绘制的图形，所以绘图十分直观
1.pip安装turtle库 打开cmd，输入 pip install turtle 2.绘图坐标系 turtle画布上默认为原点是画布中心，坐标原点是 (0,0)，X轴左右侧分别为后退和前进方向，Y轴上下两侧分别为左右两侧方向turtle.setup(width,height.top,left) 参数width和height表示绘图窗口的宽度和高度；如果参数是整数，则单位是像素；如果参数是小数，则表示与屏幕的比例。参数top和left表示窗口左边界和上边界与屏幕边界的距离，如果值是None，表示位于屏幕中央（一般情况下不设置这两个参数的值） 3.turtle的画笔控制方法 turtle的画笔控制方法主要是设置画笔的状态，如画笔的抬起和下落状态，设置的画笔的宽度和颜色等 turtle的画笔控制方法 方法功能turtle.pensize()/width设置画笔的宽度，若为空则返回当前画笔的宽度turtle.pendown()/pd()/down()放下画笔，即结束图形绘制turtle.penup()/pu()/up()提起画笔，用于移动画笔位置turtle.pencolor(colorstring)/pencolor((r,g,b))设置画笔颜色，第一个为颜色字符串，例（'blue'）；第二个为颜色值取值表示 4.turtle的图形绘制方法 这个方法包括画笔的前进方法，后退，方向控制等 turtle的图形控制方法 方法功能turtle.seth(angle)/setheading(angle)改变画笔绘制方向，angle是绝对方向的绝对值turtle.fd(distance)/forward(distance)控制画笔沿当前方向前进distance距离，distance的单位是像素，当值为负数时，表示向相反的的方向前进turtle.circle(radius,extents)用来绘制一个弧形，根据半径radius绘制extens角度的弧形turtle.left(angle)向左旋转angle角度turtle.setx(x)将当前x轴移动到指定位置，x的单位是像素turtle.sety(y) 将当前轴y移动到指定位置，y的单位是像素turtle.right(angle)向右旋转angle角度turtle.shape("name")设置画笔的形状，例：将name设置成‘turtle’turtle.speed(num)设置画笔的速度，num是一个整数turtle.hideturtle()隐藏画笔 5.简单应用示例 绘制蓝色螺旋代码 import turtle as tt '''绘制蓝色正方形螺旋''' tt.setup(400, 300) # 设置窗口大小 tt.pensize(1) # 设置画笔宽度 tt.pencolor('blue') # 设置画笔颜色 tt.shape('turtle') # 设置画笔形状 tt.speed(5) # 设置画笔速度 a = 5 #设置画笔起始位置 for i in range(40): a += 5 tt.left(90) tt.fd(a) tt.hideturtle() #隐藏画笔 tt.done() #放下画笔，结束绘制 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6260f999857f31de5c342ec0a0d9b2/" rel="bookmark">
			xml、DTD、schema、枚举
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
xml-概述
xml-标签的规则
xml-语法规则
xml-DOM解析思想
xml-解析的准备工作
xml-解析代码实现
DTD-入门案例-编写DTD
DTD-入门案例-引入DTD
DTD-约束-三种引入方式
DTD-语法规则-定义元素
schema-schema和dtd的区别
schema入门案例-编写schema
schema入门案例-引入schema
schema入门案例-定义属性
枚举-什么是枚举
枚举-定义格式
枚举的特点
枚举的方法
xml-概述 万维网联盟(W3C)
万维网联盟(W3C)创建于1994年, 又称W3C理事会, 是Web技术领域最具权威和影响力的标准机构
1994年10月在麻省理工学院计算机科学实验室成立, 建立者蒂姆·伯纳斯·李
到目前为止, W3C已经发布了200多项影响深远的Web技术标准及实施指南
1. 广为业界采用的超文本标记语言HTML
2. 可扩展标记语言xml
3. 帮助残障人士有效获得Web信息的无障碍指南WCAG等
什么是xml?
全称为EXtensible Markup Language, 是一种可扩展的标记语言
标记语言: 通过标签来描述数据的一门语言(标签有时也称之为元素)
可扩展: 标签的名字是可以自定义的
简单理解: xml文件是由很多标签组成的, 而标签的名字是可以自定义的
xml的作用?
1. 存储数据和传输数据 2. 作为软件的配置文件
xml-标签的规则 1. 标签由一对尖括号和合法的标识符组成
&lt;student&gt;
2. 标签必须成对出现
&lt;student&gt;&lt;/student&gt;
3. 特殊的标签可以不成对, 但是必须写结束标签
&lt;/address&gt;
4. 标签中可以定义属性, 属性和标签名用空格隔开, 属性值必须用引号引起来
&lt;student id="1"&gt;&lt;/student&gt;
5. 标签需要正确的嵌套
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc6260f999857f31de5c342ec0a0d9b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a26ff34f19d45ac3b2ab528b264f73/" rel="bookmark">
			RabbitMQ.基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：消息队列 1.举例分析：
小红希望小明多读书 , 常寻找好书给小明看 , 之前的方式是这样：小红问小明什么时候有空 , 把书给小明送去 , 并亲眼监督小明读完书才走 . 久而久之 , 两人都觉得麻烦 . 后来的方式改成了：小红对小明说「我放到书架上的书你都要看」 , 然后小红每次发现不错的书都放到书架上 , 小明则看到书架上有书就拿下来看 . 书架就是一个消息队列 , 小红是生产者 , 小明是消费者 . 带来的好处 1. 小红想给小明书的时候 , 不必问小明什么时候有空 , 亲手把书交给他了 , 小红只把书放到书架上就行了 . 这样小红小明的时间都更自由 . 2. 小红相信小明的读书自觉和读书能力 , 不必亲眼观察小明的读书过程 , 小红只要做一个放书的动作 , 很节省时间 . 3. 当明天有另一个爱读书的小伙伴小强加入 , 小红仍旧只需要把书放到书架上 , 小明和小强从书架上取书即可 4. 书架上的书放在那里 , 小明阅读速度快就早点看完 , 阅读速度慢就晚点看完 , 没关系 , 比起小红把书递给小明并监督小明读完的方式 , 小明的压力会小一些 . 消息队列特点 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24a26ff34f19d45ac3b2ab528b264f73/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/295/">«</a>
	<span class="pagination__item pagination__item--current">296/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/297/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>