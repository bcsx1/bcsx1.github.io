<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7d778f1913edfe480ffdb89ee022a0f/" rel="bookmark">
			LeetCode 117. 填充每个节点的下一个右侧节点指针 II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		117. 填充每个节点的下一个右侧节点指针 II 描述 给定一个二叉树：
struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。
初始状态下，所有 next 指针都被设置为 NULL 。
示例 示例1
输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），‘#’ 表示每层的末尾。
示例2
输入：root = []
输出：[]
链接 https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/
解题思路 思路一: 层次遍历 跟LeetCode 116. 填充每个节点的下一个右侧节点指针解题一模一样。
首先根元素入队当队列不为空的时候求当前队列的长度length依次从队列中取 length个元素进行处理， 先取出队列中的第一个节点node，当node不是最后一个时，将node.next指向队列的第一个，然后进入下一次迭代 /** * @param {Node} root * @return {Node} */ var connect = function(root) { if (root == null) return root; let queue = [root]; while(queue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7d778f1913edfe480ffdb89ee022a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a2fa9272e097c6cfcb4b254c76092e2/" rel="bookmark">
			Docker 搭建 ElasticSearch、Kibana 以及基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 Elasticsearch: 权威指南 | Elastic
二、使用Docker 搭建ES以及Kibana环境 拉取ES以及Kibana镜像：
// es和kibana保持一致，这里选择7.8.1版本 docker pull elasticsearch:7.8.1 docker pull kibana:7.8.1 ES部分搭建：
创建目录、配置文件、其他配置以及启动
1、目录部分：
// 创建配置项目录 -p ES/config cd ES // 创建数据存储目录 mkdir data1 mkdir data2 mkdir data3 // 这里是7.8.1版本，所以需要开启data1 data2 data3 777权限 chmod 777 data1 data2 data3 2、端口部分：
// 开启防火墙端口 firewall-cmd --add-port=9300/tcp firewall-cmd --add-port=9301/tcp firewall-cmd --add-port=9302/tcp 3、配置文件创建
// 使用vim命令分别创建es1.yml、es2.yml、es3.yml配置 // es1 cluster.name: elasticsearch-cluster node.name: es-node1 network.bind_host: 0.0.0.0 network.publish_host: 宿主机IP http.port: 9200 transport.tcp.port: 9300 http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a2fa9272e097c6cfcb4b254c76092e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f6c2e8a64d07b64a707aa1105359f7d/" rel="bookmark">
			MySQL无法启动服务--NET HELPMSG 3534
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题综述
安装完MySQL，使用 net start mysql 时，出现无法启动服务
二、解决思路
1. 查看一下错误日志
出现了问题，第一步先查看一下错误日志，使用 mysqld --console 打印错误信息，发现是 Failed to find valid data directory。发现是找不到数据库存储目录，即data 文件夹出了问题。
2. 删除data文件夹，暂停服务
1）手动删掉自己创建的data文件夹
2) 然后在管理员模式打开 命令提示符窗口（即cmd窗口），进入 bin 目录，移除自己的 MySQL 服务
3. 系统初始化，重启服务
在bin目录执行 mysqld --initialize-insecure 。程序会自动在MySQL安装根目录下，创建data文件夹以及对应的文件，会花费一点点时间。然后，重新安装和启动mysql服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67b89e7e223dcacfc0583d29a1cddb05/" rel="bookmark">
			C&#43;&#43;线程安全方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++有以下方法可以保护线程安全
1 互斥量。
2 读写锁
3 原子操作
4 条件变量
5 线程本地存储 一些函数调用如下：
1 互斥量
#include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;mutex&gt; std::mutex g_mutex; int g_counter = 0; void incrementCounter() { std::lock_guard&lt;std::mutex&gt; lock(g_mutex); ++g_counter; } int main() { std::thread t1(incrementCounter); std::thread t2(incrementCounter); t1.join(); t2.join(); std::cout &lt;&lt; "g_counter = " &lt;&lt; g_counter &lt;&lt; std::endl; return 0; } 2 读写锁
#include &lt;iostream&gt; #include &lt;thread&gt; #include &lt;shared_mutex&gt; std::shared_mutex g_mutex; int g_counter = 0; void incrementCounter() { std::unique_lock&lt;std::shared_mutex&gt; lock(g_mutex); //写锁 ++g_counter; } void readCounter() { std::shared_lock&lt;std::shared_mutex&gt; lock(g_mutex); //读锁，读锁可以共享 std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67b89e7e223dcacfc0583d29a1cddb05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e4e71eae1adf997f8b532b91defa78c/" rel="bookmark">
			SVN Unable to connect to a repository at URL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你尝试使用SVN连接到仓库时,如果出现“Unable to connect to a repository at URL”错误,有几个可能的原因:
原因分析
1. 仓库URL不正确:
确保你输入的仓库URL是正确的,语法如下:
http://hostname/path/to/repository
https://hostname/path/to/repository
svn+ssh://hostname/path/to/repository
如果URL包含密码,也要确保密码正确。
2. 网络连接问题:
这个错误通常是由于网络连接问题导致的,你可以:
- 检查网络连接是否正常,可以访问仓库服务器和其他主机。
- 如果使用http或https协议,检查是否被防火墙或代理阻止。你可能需要配置代理设置。
- 如果使用SSH协议,检查SSH密钥和认证配置是否正确。
- 使用telnet或nc尝试 basics 连接仓库服务器,检查服务端口是否开启。
3. 仓库权限问题:
如果网络连接正常,这个问题可能由于权限导致。你应该:
- 检查仓库访问权限配置,验证你的用户名和密码是否具有足够权限。
- 如果使用SSH协议,验证你的SSH密钥是否被服务端接受和信任。
- 验证文件系统权限设置是否允许SVN访问仓库目录。
4. 其他原因:
- 服务端的SVN版本较老,无法支持客户端版本。升级服务端SVN版本。
- 本地SVN缓存损坏,尝试清理本地缓存重试。
- 如果多用户同时访问,可能达到了最大连接数限制。联系系统管理员提高限制。
解决办法:
根据不同的原因,修复网络连接、URL、权限、版本或清理缓存等,然后重试SVN连接。
1. 右键点击本地副本，TortoiseSVN-&gt; Settings -&gt; Saved Data，
2. 点击个个“Clear”按钮，把本地缓存都清除了，点击“确定”；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f437e2a9fe10295a2b83adb833614491/" rel="bookmark">
			MVN打包微服务项目,无论如何打包引用的微服务项目都没有更新的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： MAVEN打包微服务项目
问题描述： MVN打包微服务项目，项目中有引用的微服务项目，引用的微服务项目做了修改，无论如何打包引用的微服务项目都没有更新的代码
原因分析： 代码没有更新，肯定是依赖没有重新加载，引用的本地仓库jar包不变，根本原因对MVN命令打包的本质不够了解:
mvn compile，编译类文件mvn install，包含mvn compile，mvn package，然后上传到本地仓库mvn deploy,包含mvn install,然后，上传到私服 解决方案： 前面打包都是用mvn：package命令，只是对于本项目打包，没有持久话到本地仓库，需要使用mvn：install命令打包，更新本地仓库.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93571ffd9a4200a1ba958849a3ef2551/" rel="bookmark">
			极光推送 - uniapp 使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		App.vue 中
//#ifdef APP-PLUS var jpushModule = uni.requireNativePlugin("JG-JPush"); //#endif export default { onLaunch: function() { // 极光推送 //#ifdef APP-PLUS jpushModule.setLoggerEnable(true); jpushModule.initJPushService() jpushModule.addConnectEventListener(result =&gt; { let connectEnable = result.connectEnable console.log("jpush连接", connectEnable) }) jpushModule.addNotificationListener(result =&gt; { let notificationEventType = result.notificationEventType let messageID = result.messageID let title = result.title let content = result.content let extras = result.extras console.log("通知", result) if (notificationEventType == "notificationOpened") { // 点击窗口通知栏推送的消息 跳转指定页面 // this.$toPage('/pages/index/message') setTimeout(function(){ uni.navigateTo({ url:'/pages/index/message' }) },1000) } // 10秒执行一次获取register_id 否则有可能初始化还没完成就获取 导致获取不到 setTimeout(() =&gt; { jpushModule.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93571ffd9a4200a1ba958849a3ef2551/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e5af9e23306cc2099d8a5971e109f37/" rel="bookmark">
			uniapp websocket连接 心跳机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 站内信 // 判断是否已连接 checkOpenSocket () { let that = this; uni.sendSocketMessage({ data: 'heartCheck', success: (res) =&gt; { return; }, fail: (err) =&gt; { // 未连接打开websocket连接 that.openConnection(); console.log('未连接打开websocket连接',err); } }); }, openConnection () { // 打开连接 uni.closeSocket(); // 确保已经关闭后再重新打开 uni.connectSocket({ url: SOCKTURL, // url 填写自己的websocket地址 success(res) { console.log('连接成功 connectSocket=', res); }, fail(err) { console.log('连接失败 connectSocket=', err); } }); uni.onSocketOpen((res) =&gt; { uni.sendSocketMessage({ data: JSON.stringify({ userCode: uni.getStorageSync('userCode') }), success: (res) =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e5af9e23306cc2099d8a5971e109f37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c7127748a0e2be547c3ee1a0541827/" rel="bookmark">
			可视化大屏自适应：autofit.js 一行搞定布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：德莱厄斯
原文：https://juejin.cn/post/7224015103481118757
2023-05-15 更新： 关于autofit.js 问答与解惑，请访问： autofit.js 问答和食用指南[1]
在线DEMO（非大屏项目）：farm.sino-eco.com/website/bin…[2] （autofit.js v1.1.2+）
可视化大屏适配/自适应现状 可视化大屏的适配是一个老生常谈的话题了，现在其实不乏一些大佬开源的自适应插件、工具但是我为什么还要重复造轮子呢？因为目前市面上适配工具每一个都无法做到完美的效果，做出来的东西都差不多，最终实现效果都逃不出白边的手掌心，可以解决白边问题的，要么太过于复杂，要么会影响dom结构。
三大常用方式 vw/vh方案
概述：按照设计稿的尺寸，将px按比例计算转为vw和vh
优点：可以动态计算图表的宽高，字体等，灵活性较高，当屏幕比例跟 ui 稿不一致时，不会出现两边留白情况
缺点：每个图表都需要单独做字体、间距、位移的适配，比较麻烦
scale方案
概述：也是目前效果最好的一个方案
优点：代码量少，适配简单 、一次处理后不需要在各个图表中再去单独适配.
缺点：留白，有事件热区偏移，下面介绍的autofit.js已经完全解决了此问题
rem + vw vh方案
概述：这名字一听就麻烦，具体方法为获得 rem 的基准值 ，动态的计算html根元素的font-size ，图表中通过 vw vh 动态计算字体、间距、位移等
优点：布局的自适应代码量少，适配简单
缺点：留白，有时图表需要单独适配字体
基于此背景，我决定要造一个简单又好用的轮子。
解决留白问题 留白问题是在使用scale时才会出现，而其他方式实现起来又复杂，效果也不算太理想，总会破坏掉原有的结构，可能使元素挤在一起，所以我们还是选择使用scale方案，不过这次要做出一点小小的改变。
常用分辨率 首先来看一下我的拯救者的分辨率：
它可以代表从1920往下的分辨率
我们可以发现，比例分别是：1.77、1.6、1.77、1.6、1.33... 总之，没有特别夸张的宽高比。
计算补齐白边所需的px 只要没有特别夸张的宽高比，就不会出现特别宽或者特别高的白边，那么我们能不能直接将元素宽高补过去？也就是说，当屏幕右侧有白边时，我们就让宽度多出一个白边的px，当屏幕下方有白边时，我们就让高度多出一个白边的px。
很喜欢CSGO玩家的一句话："啊？"
先想一下，如果此时按宽度比例缩放，会在下方留下白边，所以设置一下它的高度，设置多少呢？比如 scale==0.8 ，也就是说整个#app缩小了0.8倍，我们需要将高扩大多少倍才可以回到原来的大小呢？
QQ录屏20230420144111 emmm.....
算数我最不在行了，启动高材生
image-20230420143742913 原来是八分之十，我vue烧了。
当浏览器窗口比设计稿大或者小的时候，就应该触发缩放，但是比例不一定，如果按照scale等比缩放时，宽度从1920缩小0.8倍也就是1536，而高度缩小0.8也就是743，如果此时浏览器高度过高，那么就会出现下方的白边，根据高材生所说的，缩小0.8后只需要放大八分之十就可以变回原大小，所以以现在的高度743*1.25=928，使宽度=928px就可以完全充满白边！
思路是正确的，但是能不能再简单一点
是浏览器高度！我忽略了浏览器高度，我可以直接使用浏览器高度乘以1.25然后再缩放达0.8！就是 1 ！
也就是说 clientHeight / scale 就等于我们需要的高度！
我们用代码试一试（autofit.js初代核心代码）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97c7127748a0e2be547c3ee1a0541827/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f154a4ba3abaa82be37f79e78c1606/" rel="bookmark">
			numpy-stl实战3D建模【Python】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想象一下，我们需要用 python 编程语言构建某个物体的三维模型，然后将其可视化，或者准备一个文件以便在 3D 打印机上打印。 有几个库可以解决这些问题。 让我们来看看，如何在 Python 中从点、边和图元构建 3D 模型。 如何执行基本的 3D 建模技术：移动、旋转、合并、减去等。
推荐：用 NSDT设计器 快速搭建可编程3D场景。
我们将使用numpy-stl构建一个 Menger Sponge分形，将模型保存到 stl 文件，然后渲染图像。 在此过程中，我们简要了解了数据结构和术语。
所有示例均针对 Linux 操作系统提供。代码示例可以在 GitHub 存储库中找到。
1、Numpy-stl概述 在Numpy-stl中， 多边形网格的结构如下：
Vertices - 点列表。 每个点由三个数字描述——3 维空间中的坐标。
接下来，我们将使用 Jupyter notebook。示例：numpy_stl_example_01.ipynb
import numpy as np from myplot import plot_verticles vertices = np.array([ [-3, -3, 0], [+3, -3, 0], [+3, +3, 0], [-3, +3, 0], [+0, +0, +3] ]) plot_verticles(vertices = vertices, isosurf = False) 尽管只描述了顶点，但你已经可以看到如果将它们与三角形连接起来模型会是什么样子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01f154a4ba3abaa82be37f79e78c1606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255f031aa7051d6253507a09b32c1677/" rel="bookmark">
			Nginx安装部署——超级详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx安装部署【简单】 简介 Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。
同Tomcat一样，Nginx可以托管用户编写的WEB应用程序成为可访问的网页服务，同时也可以作为流量代理服务器，控制流量的中转。
Nginx在WEB开发领域，基本上也是必备组件之一了。
安装 Nginx同样需要配置额外的yum仓库，才可以使用yum安装
安装Nginx的操作需要root身份
安装yum依赖程序
# root执行 yum install -y yum-utils 手动添加，nginx的yum仓库
yum程序使用的仓库配置文件，存放在：/etc/yum.repo.d内。
# root执行 # 创建文件使用vim编辑 vim /etc/yum.repos.d/nginx.repo # 填入如下内容并保存退出 [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true [nginx-mainline] name=nginx mainline repo baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/ gpgcheck=1 enabled=0 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true 通过如上操作，我们手动添加了nginx的yum仓库
通过yum安装最新稳定版的nginx
# root执行 yum install -y nginx 启动
# nginx自动注册了systemctl系统服务 systemctl start nginx	# 启动 systemctl stop nginx	# 停止 systemctl status nginx	# 运行状态 systemctl enable nginx	# 开机自启 systemctl disable nginx	# 关闭开机自启 配置防火墙放行
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255f031aa7051d6253507a09b32c1677/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ebae3adad4b4f9d35390653a29a54f/" rel="bookmark">
			C语言——航班信息管理系统（双向链表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该系统采用双向链表实现，设计效果如下图所示。系统管理的信息有：航班号、出发地、目的地、起飞时间和票价。实现的功能包括录入航班信息、根据航班号删除对应的航班信息、根据航班号修改（更新）该班次的票价、根据航班号查询该航班的信息，以及显示所有的航班信息。
1. main.c文件
#include "flight.h" int main() { int n; //功能选择 Info_t information; //航班信息 char destFlight[16]; //航班号 float price; //票价 //1.创建头结点 Manager_t *manager= Flight_Create(); while (1) { //2.显示系统界面 Flight_Interface(); //3.功能（操作）选择 printf("请根据对应序号选择功能："); scanf("%d",&amp;n); //4.执行对应的操作 switch (n) { case 0: //退出系统 printf("已退出系统！！！\n"); return 0; case 1: //录入航班信息 printf("请输入航班号："); scanf("%s",information.flight_number); printf("出发地："); scanf("%s",information.departure); printf("目的地："); scanf("%s",information.destination); printf("起飞时间："); scanf("%s",information.take_off_time); printf("票价："); scanf("%f",&amp;information.price); Flight_TailInsert(manager,information); break; case 2: //删除航班信息 printf("请输入要删除的航班信息的航班号："); scanf("%s",destFlight); Flight_FlightNumberDel(manager,destFlight); break; case 3: //修改航班票价 printf("请输入要修改票价的航班号："); scanf("%s",destFlight); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6ebae3adad4b4f9d35390653a29a54f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d3b8b8c4f5520485892f72cc666866/" rel="bookmark">
			上传本地文件到HDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.rj;
import java.io.IOException;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.junit.Before;
import org.junit.Test;
public class Hdfs_hellos {
FileSystem fs = null;
@Before
public void init() throws IOException{
Configuration conf = new Configuration();
conf.set("fs.defaultFS","hdfs://192.168.200.13:8020");
System.setProperty("HADOOP_USER_NAME","root");
fs=FileSystem.get(conf);
}
@Test
public void testFileExsits() throws IllegalArgumentException,IOException
{
if(fs.exists(new Path("/tmp")))
{
System.out.println("File exists!");
}
else {
System.out.println("Error!!!");
}
}
@Test
public void upfiletohdfs() throws IOException{
Path src = new Path("D:/0205210113.txt");
Path dst = new Path("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85d3b8b8c4f5520485892f72cc666866/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a37bbf6a502fc11af799878212fc057/" rel="bookmark">
			HBase应用场景和最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HBase 作为 Apache 基金会的 Hadoop 项目的一部分，将 HDFS 作为文件存储系统，使用 MapReduce 进行分布式的数据批量处理（非实时数据批量处理）、利用Zookeeper提供协同管理服务，为 Hadoop 提供海量数据管理服务，因此，HBase也是在一个服务器集群上运行的。
HBase主要适用于海量明细数据（十亿、百亿）的随机实时查询，如日志明细、交易清单、轨迹行为等。因此，实时数据查询和处理是HBase主要功能，用来进行数据实时计算的是Flink或sparkstreaming。
1. HBase优点 HBase=Hadoop Database，是一个高可靠性、高性能、面向列、高扩展性、稀疏的、由行键列键和时间戳进行索引的多维有序映射的分布式存储数据库。HBase与Hadoop的关系密不可分，HBase利用HDFS作为其文件存储系统、利用MapReduce来处理HBase中的海量数据、利用Zookeeper提供协同管理服务。
1.高容量、高性能、高扩展性
HBase 的单表可以有百亿行、百万列，可以在横向和纵向两个维度插入数据，具有很大的弹性，容量极高。
当关系型数据库的单个表的记录在亿级时，查询和写入的性能都会呈现指数级下降，这种庞大的数据量对传统数据库来说是一种灾难，而 HBase 在限定某个列的情况下对于单表存储百亿甚至更多的数据，保持高性能。
HBase可以通过部署廉价的服务器集群实现大规模数据存储，扩展性极高。
2.列存储
关系型数据库是面向行存储的，而HBase数据库面向列存储，如下图所示：
行存储，表的所有数据都放在一起，方便数据的插入与更新；但对于表数据查询，行存储会读取所有数据进行查询，但列存储只需要读取相应的查询列。因此，列存储对数据的交互式查询非常友好。
3.稀疏性
在关系型数据库中，每一列的数据类型和大小都必须事先定义，提前占用固定的存储空间。因此，当数据为NULL值时，依然会占用存储空间。
而 HBase 中的数据都是以字符串形式存储，为空的列并不占用存储空间，因此 HBase 的列存储解决了数据稀疏性的问题，在很大程度上节省了存储开销。
4.高可靠性
HBase利用HDFS作为其文件存储系统，HDFS的多副本存储保障数据存储的高容错性。同时，当HBase集群中当某个节点出现故障时，协调服务组件 ZooKeeper 通知集群的主节点，将故障节点的日志信息分发到各从节点进行数据恢复。
2. HBase应用场景 1.搜索引擎的应用
网络爬虫持续不断地从网络上抓取新页面，并将页面内容存储到 HBase 中，爬虫可以插入和更新 HBase 里的内容；然后，用户可以利用 MapReduce 在整张表上计算并生成索引，为网络搜索做准备；接着，用户发起搜索请求；最后，搜索引擎查询建立好的索引列表， 获取文档索引后，再从 HBase 中获取所需的文档内容，最后将搜索结果提交给用户。
2.广告效果和点击流
在线广告是互联网产品的一项主要收入来源。互联网企业提供免费服务给用户，在用户使用服务时投放广告给目标用户。这种精准投放需要针对用户交互数据做详细的捕获和分析，以理解用户的特征；再基于这种特征，选择并投放广告。企业可使用精细的用户交互数据建立更优的模型，进而获得更好的广告投放效果和更多的收入。
但这类数据有两个特点：它以连续流的形式出现，它很容易按用户划分。在理想情况下，这种数据一旦产生就能够马上使用。
HBase 非常适合收集这种用户交互数据，并已经成功地应用在相关领域。它可以增量捕获第 一手点击流和用户交互数据，然后用不同处理方式来处理数据，电商和广告监控行业都已经非常熟练地使用了类似的技术。
例如，淘宝的实时个性化推荐服务，中间推荐结果存储在 HBase 中，广告相关的用户建模数据也存储在 HBase 中，用户模型多种多样，可以用于多种不同场景，例如，针对特定用户投放什么广告，用户在电商门户网站上购物时是否实时报价等。
3. HBase在滴滴的典型应用场景 滴滴中有一些对HBase简单操作，例如Scan和Get。每一个操作可以应用于不同的场景，例如Scan可以衍生出时序和报表。时序可以应用到轨迹设计中，将业务ID、时间戳和轨迹位置作为整体建立时序。另外在资产管理中，将资产状态分为不同阶段，将资产ID、时间戳、资产状态等信息建立时序。Scan在报表中应用也非常广泛。其实现有多种方式，主流方法是通过phoenix，使用标准的SQL操作Hbase做联机事务处理，该方法中需要注意主键及二级索引设计。报表中会以用户历史行为、历史事件及历史订单为需求进行详细设计。
Get操作可以应用于HBase中存储的语音和滴滴发票等小文件中。最基本的应用方法为根据ID获取实体属性。更深入的例如可以应用于join操作，例如在实时计算中有多个数据流需要合并，此时的ID即为HBase中的rowkey。另例如业务上游存在多个数据源，需要将这多个数据源数据聚合至一个表中。
此外，HBase中仍衍生出一些其他操作。互联网公司需求变化快速，介入业务方众多，可以通过动态列帮助实现这类需求。另有一些综合应用，例如图和Coprocessor。图包括用户自定义的图，可以自定义数据来源与数据分配。HBase集群中也接入了JanusGraph。Coprocessor主要应用于Phoenix和GeoMesa。
HBase在滴滴主要存放了以下四种数据类型：
统计结果、报表类数据：主要是运营、运力情况、收入等结果，通常需要配合Phoenix进行SQL查询。数据量较小，对查询的灵活性要求高，延迟要求一般。原始事实类数据：如订单、司机乘客的GPS轨迹、日志等，主要用作在线和离线的数据供给。数据量大，对一致性和可用性要求高，延迟敏感，实时写入，单点或批量查询。中间结果数据：指模型训练所需要的数据等。数据量大，可用性和一致性要求一般，对批量查询时的吞吐量要求高。线上系统的备份数据：用户把原始数据存在了其他关系数据库或文件服务，把HBase作为一个异地容灾的方案。 使用场景介绍
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a37bbf6a502fc11af799878212fc057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f694dd836f78d8ee06617bcc06c216f3/" rel="bookmark">
			求解包含约束的最优化问题：拉格朗日乘子法和KKT条件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 无约束等式约束不等式约束KKT条件 无约束 之前梯度类算法中介绍的最速下降法、牛顿法和拟牛顿法，可以直接使用的条件之一为：决策变量都是无约束的。
用数学语言描述的话，可以表达为：决策变量为 x = ( x 1 , x 2 , ⋅ ⋅ ⋅ , x n ) \pmb x=(x_1,x_2,···,x_n) x=(x1​,x2​,⋅⋅⋅,xn​)，目标函数为
m i n f ( x ) min f(\pmb x) minf(x)
但在实际问题中，大部分都是包含约束的，比如多个决策变量之间存在耦合关系、资源有上限等。其中，有些是等式约束，有些则是不等式约束。在求解这类包含约束的最优化问题时，就需要一些新的方法。本文主要介绍拉格朗日乘子法和KKT条件。
等式约束 当最优化问题中只包含等式约束时，数学模型可以表达为
m i n f ( x ) s.t. h l ( x ) = 0 , l = 1 , 2 , . . . , L min f(\pmb x) \\ \text{s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f694dd836f78d8ee06617bcc06c216f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5a57ff5ddb612f9035425fe0dafdd7/" rel="bookmark">
			PhpStorm-中文汉化版设置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.ngxcode.com/archives/607.html 前言 相信不少开发PHP的同学，对PhpStorm编辑器都不陌生，PhpStorm 是 JetBrains 公司开发的一款商业的PHP集成开发工具，旨在提高用户效率，可深刻理解用户的编码，提供智能代码补全，快速导航以及即时错误检查。
但PhpStorm默认是英文的版本，对于大多数英文不是很熟练的同学来说，操作和配置上难免有很大的困扰和阻力，其实通过插件方式，可以很简单的汉化PhpStorm编辑器，下面简单说下
教程 1.编辑器顶部，PhpStorm-&gt;Preference-&gt;Plugin-&gt;Chinese（Simplified）Language Pack/中文语言包，点击安装 2.重启PhpStorm 重启后，看到的就是完全汉化后的版本了，开始你充满活力编写Bug的一天吧，😄
结语 以上是PhpStorm-中文汉化版设置的详细教程介绍，希望能帮助到需要的同学，更多文章请关注本站其他内容，感谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d714e3a7e036c56c0738e4fbcd97b327/" rel="bookmark">
			PhpStorm-编辑器工作区中间那条灰线怎么去掉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.ngxcode.com/archives/612.html 前言 不少使用PhpStorm的同学，相信都会看到编辑器工作区中间的那条灰线，主要用来做代码样式的视觉参考使用，编码最好不要超过那条灰线，不然对整体代码阅读和观感上都不太友好。但跟我一样有少许强迫症的人来说，真的是太难受了，哈哈，下面简单说下怎么取消
教程 1.顶部菜单栏 Preferences -&gt; 编辑器 -&gt; 外观 -&gt; 显示强制换行和视觉参考线，取消勾线。点击应用和确认按钮。
这时候，中间那条别扭的黑线就消失不见了。开始你充满活力编写Bug的一天吧，😄
结语 以上是PhpStorm-编辑器工作区中间那条灰线怎么去掉的方法介绍，希望能帮助到需要的同学，更多文章请关注本站其他内容，感谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3525567317851cc3820d378381fe34a/" rel="bookmark">
			51单片机——I2C-EEPROM实验，小白讲解，相互学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I2C介绍
I2C（Inter－Integrated Circuit）总线是由 PHILIPS 公司开发的两线式 串行总线，用于连接微控制器及其外围设备。是微电子通信控制领域广泛采用的 一种总线标准。它是同步通信的一种特殊形式，具有接口线少，控制方式简单， 器件封装形式小，通信速率较高等优点。I2C 总线只有两根双向信号线。一根是 数据线 SDA，另一根是时钟线 SCL。由于其管脚少，硬件实现简单，可扩展性强 等特点，因此被广泛的使用在各大集成芯片内。下面我们就从 I2C 的物理层与 协议层来了解 I2C。
I2C物理层
I2C通信设备常用的连接方式如下：
它的物理层有如下特点：
（1）它是一个支持多设备的总线。“总线”指多个设备共用的信号线。在一个I2C通信总线中，可连接多个I2C通讯设备，支持多个通讯主机及多个通讯从机。
（2）一个 I2C 总线只使用两条总线线路，一条双向串行数据线(SDA)，一 条串行时钟线(SCL)。数据线即用来表示数据，时钟线用于数据收发同步。
（3）每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址 进行不同设备之间的访问。
（4）总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而 当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。 （5）多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定 由哪个设备占用总线。 （6）具有三种传输模式：标准模式传输速率为 100kbit/s，快速模式为 400kbit/s，高速模式下可达 3.4Mbit/s，但目前大多 I2C 设备尚不支持高速模 式。
（7）连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制。 下面我们来了解下 I2C 总线常用的一些术语： 主机：启动数据传送并产生时钟信号的设备； 从机：被主机寻址的器件； 多主机：同时有多于一个主机尝试控制总线但不破坏传输； 主模式：用 I2CNDAT 支持自动字节计数的模式； 位 I2CRM,I2CSTT,I2CSTP 控制数据的接收和发送； 从模式：发送和接收操作都是由 I2C 模块自动控制的； 仲裁：是一个在有多个主机同时尝试控制总线但只允许其中一个控制总线并 使传输不被破坏的过程； 同步：两个或多个器件同步时钟信号的过程； 发送器：发送数据到总线的器件； 接收器：从总线接收数据的器件。 I2C协议层 I2C 的协议定义了通信的起始和停止信号、数据有效性、响应、仲裁、时钟 同步和地址广播等环节。下面我们就来简单介绍下。 （ 1）数据有效性规定 I2C 总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保 持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态 才允许变化。如下图： 每次数据传输都以字节为单位，每次传输的字节数不受限制。 （ 2）起始和停止信号 SCL 线为高电平期间，SDA 线由高电平向低电平的变化表示起始信号；SCL 线为高电平期间，SDA 线由低电平向高电平的变化表示终止信号。如下图： 起始和终止信号都是由主机发出的，在起始信号产生后，总线就处于被占用 的状态；在终止信号产生后，总线就处于空闲状态。 （3）应答响应
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3525567317851cc3820d378381fe34a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfed852524d612b1a1a7c6976f9d1f28/" rel="bookmark">
			离散化（算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、离散化的概念二、离散化的模板三、离散化的应用题目思路分析代码实现 一、离散化的概念 离散化是一种将连续数据映射到离散值的过程。它通常用于优化某些算法，尤其是与区间查询相关的问题。
在离散化过程中，我们将一组实数转换为一组整数，使得原始数据的顺序和区间关系得以保留。具体地说，我们将原始数据排序，然后为每个不同的值分配一个整数。这个整数是该值在排序后出现的位置，即离散化后的数值。
假设我们有以下一组实数：{ 3.5 , 2.1 , 5.6 , 1.2 , 3.5 3.5, 2.1, 5.6, 1.2, 3.5 3.5,2.1,5.6,1.2,3.5}。对它们进行排序后，得到 { 1.2 , 2.1 , 3.5 , 3.5 , 5.6 1.2, 2.1, 3.5, 3.5, 5.6 1.2,2.1,3.5,3.5,5.6}。接着，我们可以为每个不同的值分配一个整数，例如：
1.2 → 1 1.2 → 1 1.2→1
2.1 → 2 2.1 → 2 2.1→2
3.5 → 3 3.5 → 3 3.5→3
5.6 → 4 5.6 → 4 5.6→4
最终，我们将原始数据替换为离散化后的整数，得到 { 3 , 2 , 4 , 1 , 3 3, 2, 4, 1, 3 3,2,4,1,3} 。这些整数可以用于解决一些与区间查询相关的问题，例如线段树、树状数组等算法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfed852524d612b1a1a7c6976f9d1f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b97435cf854a103c1adbf50d18d1e5/" rel="bookmark">
			echarts中series和tooltip地图的注意点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前在公司做的项目中就是使用的echarts进行地图的展示，遇到一个很奇怪的问题，就是在option的配置下面，formatter获取不到值，如果为字符串是可以正常显示的
tooltip: { trigger: "item", formatter: "{b}&lt;br/&gt;{c} (p / km2)", }, 如果formatter为函数，就会出现值为undefined的情况，具体代码如下：
tooltip: { trigger: "item", formatter: function(params) { console.log(params, "lllllll"); }, }, series: [ { name: "数据名称", type: "map", roam: false, mapType: mapName, selectedMode: "single", showLegendSymbol: false, visibility: "off", // data: this.mapData, data: [ { name: "新疆", value: Math.random()}, { name: "黑龙江", value: Math.random() }, { name: "内蒙古", value: Math.random() }, ], }, ], 以上所有的都是没有问题的，formatter中的参数params的值是从series.data中获取的，最后矛头对准了key和value，在数据中要使用name来匹配数据，一旦name名称对不上，数据就是获取不到的。
匹配之后代码如下，地图上的名称要和echarts渲染的名称相对应：
tooltip: { trigger: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b97435cf854a103c1adbf50d18d1e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1528118b3a25c323c3a5ee55adf0451/" rel="bookmark">
			实现图形算法API[软光栅渲染器，C&#43;&#43;]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有点烦，发烧感冒了三天[事实上是俩天，第三天是因为摆得太舒服了索性多玩一天]，啥都没学，打守望先锋也把把被虐...，想着今天来提起键盘把之前的东西都总结一下。
那么话归真题，首先我是仿造opengl来写的图形api，因为是在cpu端运行，所以要比opengl优雅很多。
首先肯定要预先计划好写哪些功能，我想的第一个是vertexbuffer，因为这个是最经常接触的，而且实现思路也非常清晰明了。
class VertexBuffer { struct DataWarp { ITypeTag* info = nullptr; size_t InfoSize = 0; void* data = nullptr; size_t dataElemSize = 0; ~DataWarp() { memory::dealloc(data, info-&gt;tSize); memory::dealloc(info, InfoSize); } }; public: /* * T	数据的类型 * bufferindex 所在的缓冲下标 * dataIndex 缓冲中对应的数据下标 */ template&lt;class T&gt; T* Sample(size_t bufferIndex, size_t dataIndex); /* * index 布局的下标 * size 数据的字节数 * data 数据指针 * T	数据的类型 */ template&lt;class T&gt; void SetData(size_t index, size_t size, void* data); private: std::vector&lt;DataWarp*&gt; buffers; friend class IInvoker; }; 这个是我设计的类；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1528118b3a25c323c3a5ee55adf0451/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22e852b97d603e39781f73ba1cba4fea/" rel="bookmark">
			修改Ubuntu 的用户名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改Ubuntu 的用户名 前言参考 前言 之前使用了一个VM Ubuntu虚拟机做开发；并且创建了快照；不小心删除了快照，又要开始重新高环境了；
直接使用了宅学提供的ubuntu，然后需要涉及到修改用户名
参考 1. Ubuntu系统修改用户名
在/etc/passwd文件中，圈出来字符串的选项是系统登录默认的登录名
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6421739589af7ba208d77c8524f1c650/" rel="bookmark">
			Java 实现 二叉树的 前序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、定义节点类 class Node { int val; Node left; Node right; Node(int val) { this.val = val; } } public class BinaryTree { /** * 前序遍历 * @param root 节点 */ public void preorderTraversal(Node root) { if (root != null) { System.out.print(root.val + " "); preorderTraversal(root.left); preorderTraversal(root.right); } } } 1）解析 首先，定义了一个 Node 类表示二叉树的节点。节点包含了一个整型的 val 值，以及左右两个子节点的引用。
然后，定义了 BinaryTree 类，该类包含了一个方法 preorderTraversal，用于实现前序遍历。
前序遍历的顺序是：先遍历根节点，然后遍历左子树，最后遍历右子树。
如果二叉树为空，则直接返回。否则，先输出根节点的值，然后递归遍历左子树和右子树。
2）使用方法 首先创建二叉树的节点，然后构建二叉树，最后调用 BinaryTree 类的 preorderTraversal 方法进行前序遍历。
2、测试代码 public class TestTree { public static void main(String[] args) { // 构建二叉树 Node root = new Node(1); root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6421739589af7ba208d77c8524f1c650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4d95cbe9054a74cf676970b9f9dbae2/" rel="bookmark">
			chatgpt赋能Python-pythonheaders
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 PythonHTTPHeaders：保护网站并提高网站SEO 在当今数字时代，网站的安全和SEO是非常重要的。其中之一实现这两个目标的方法是使用Python HTTP Headers。Python Headers是在服务器端控制浏览器和服务器之间的通信协议的方法。这种方法可以有效地提高网站的安全性，并帮助搜索引擎了解您的网站。
什么是PythonHTTPHeaders？ Python HTTP Headers是服务器发送给客户端（浏览器）的HTTP头部信息。这些头信息指示了如何处理返回的内容。使用Python HTTP Headers，网站可以控制如下:
防止跨站脚本攻击（XSS）防止点击劫持攻击防止内容嗅探攻击防止拒绝服务攻击（DoS）帮助搜索引擎了解您的网站提高页面加载速度 如何使用PythonHTTPHeaders？ 使用Python HTTP Headers很容易，只需在服务器配置中添加所需的HTTP头信息即可。以下是一些示例头文件：
X-XSS-Protection:1; mode=block 该头文件可以防止跨站脚本攻击。如果检测到XSS攻击，则会在浏览器中阻止页面加载。
X-Frame-Options: DENY 该头文件可以防止点击劫持攻击。如果尝试在iframe中加载网站，此头信息将禁止此操作。
X-Content-Type-Options: nosniff 该头文件可以防止内容嗅探攻击。这种攻击可以利用浏览器的漏洞来识别错误的MIME类型并误解解释内容。
Content-Security-Policy:default-src ‘self’ 该头文件可以防止跨站脚本攻击和拒绝服务攻击。这是最强大的头文件。它限制了允许执行的脚本的来源和允许加载的图像，CSS和其他内容的来源。
PythonHTTPHeaders如何提高SEO？ 搜索引擎是为了为用户提供最好的体验，这样他们才会保持他们的市场主导地位。因此，搜索引擎对网站的安全性和加载速度很感兴趣。HTTP头信息是搜索引擎用于了解网站安全性和加载速度的关键信息之一。如果网站使用了PythonHTTPHeaders，搜索引擎将更好地理解网站，并更倾向于更好地排名您的网站。
结论 在保护网站并提高SEO方面，Python HTTP Headers是一个有力的工具。使用适当的HTTP头信息，您可以轻松防止各种攻击，并提高搜索引擎的排名。在实施Python HTTP Headers时，请确保了解各个头信息的含义并适当配置服务器。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
🧡AI职场汇报智能办公文案写作效率提升教程 🧡 专注于AI+职场+办公方向。
下图是课程的整体大纲
下图是AI职场汇报智能办公文案写作效率提升教程中用到的ai工具
🚀 优质教程分享 🚀 🎄可以学习更多的关于人工只能/Python的相关内容哦！直接点击下面颜色字体就可以跳转啦！ 学习路线指引（点击解锁）知识定位人群定位🧡 AI职场汇报智能办公文案写作效率提升教程 🧡进阶级本课程是AI+职场+办公的完美结合，通过ChatGPT文本创作，一键生成办公文案，结合AI智能写作，轻松搞定多场景文案写作。智能美化PPT,用AI为职场汇报加速。AI神器联动，十倍提升视频创作效率💛Python量化交易实战 💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448a65fa59d3557ffddf7c240a8b7a71/" rel="bookmark">
			Java动态类型语言支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK7发布字节码首位新成员——invokedynamic指令。以实现动态类型语言支持。也是为JDK8里可以顺利实现Lambda表达式而做的技术储备。我们将在本文详细了解动态语言支持这项特性出现的背景和它的意义与价值。
1 动态类型语言 动态类型语言的关键特征是它的类型检查的主体过程是运行期而不是编译器进行的。变量无类型而变量值才有类型。
1.1 类型检查 类型检查是指验证操作接受的是否为合适的类型数据以及赋值是否符合类型要求。最自然的方式是认为检查发生在运行时，即当设计到具体的数据值时，即动态类型检查（也称运行时检查）。编译时检查（静态检查）通过对程序的静态分析，检查所有使用值的使用操作、调用和赋值，在程序运行前排除潜在的类型错误。
public class Test1 {
static class HelloWord {
public void sayHello() {
System.out.println("Hello Java");
}
}
public static void main(String[] args) {
HelloWord helloWord = new HelloWord();
helloWord.sayHello();
}
}
图 上述代码的字节码
Java在编译器将sayHello方法完整的符号引用生成出来，并作为方法调用指令的参数存储到Class文件中。而其他动态类型语言在编译期最多只能确定方法名称、参数、返回值这些信息，而不会去确定方法所在的具体类型。
1.2 静态类型语言与动态类型语言的特点 静态类型语言
能在编译器确定变量类型，编译器可以提供全面严谨的类型检查，有利于稳定性及让项目容易达到更大的规模。
动态类型语言
可以为开发人员提供极大灵活性，某些在静态类型语言中要花大量臃肿代码来实现的功能，由动态类型语言去做可能会很清晰简洁，提升开发效率。
表 静态类型语言与动态类型语言的特点
2 Java动态语言支持的技术背景 《Java虚拟机规范》第一版中规划了一个愿景：“在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于Java虚拟机之上。”目前确实已经有许多动态类型语言运行于Java虚拟机之上了。
JDK7以前，Java虚拟机层面对动态类型语言的支持一直都有所欠缺。主要表现在方法调用方面: 字节码的指令集中，4条方法调用指令的第一个参数都是被调用的方法的符号引用，在编译时就已经确定好。而动态类型语言只有在运行期才能确定方法的接收者。
3 java.lang.invoke包 3.1 方法句柄 方法句柄是一个强类型的，能被直接执行的引用。该引用可以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。当指向字段时，方法句柄实则指向包含字段访问字节码的虚构方法，语义上等价于目标字段的getter或者setter方法。
方法句柄的类型（MethodType）是由所指向方法的参数类型以及返回类型组成的。它是用来确认方法句柄是否适配的唯一关键。当使用方法句柄时，我们并不关心方法句柄所指向方法的类名或者方法名。
3.1.1 方法句柄的使用 方法句柄包含两个重要的类，MethodHandle和MethodType。
MethodHandle调用时有两个方法invoke和invoeExact，后者要求参数类型与底层方法的参数完全匹配，前者则在有出入时做修改如包装类型。
MethodType，不可变对象，是对方法的一个映射，在lookup时也是通过它来寻找的。
public class MethodHandleDemo { public void sayWord(String word) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/448a65fa59d3557ffddf7c240a8b7a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd490213998ef63b89188d4598b10e3b/" rel="bookmark">
			MT4自定义指标导入方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MT4交易软件，自带36种投资人经常使用的指标，基本上可以满足大多数投资人的分析需要。但是有些投资人想要使用的指标可能没有，众口难调，MT4不可能把所有指标都包括。不过投资人可以导入自定义的指标。下面就来介绍一下MT4自定义指标的导入方法。
第一步，下载或者编写自己想要导入刀MT4的自定义指标；
第二步，打开MT4交易软件，在菜单栏中点击【文件】=&gt;【打开数据文件夹】，就会打开MT4存放自定义指标的文件夹；
第三步，将自己准备好的自定义指标存放到下面的路径中
\MQL4\Indicators
第四步，重启MT4软件，在软件的导航栏中找到"自定义指标"的选项，找到自己安装的指标名称，直接将该指标拖放到MT4上的图表中，就可以使用自定义指标了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05835b8323479c41aff53c22f0204639/" rel="bookmark">
			NGINX一个server监听多个端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 NGINX一个server监听多个端口
server { listen 9018; listen 9019; location / { try_files $uri $uri/ /index,html; root /home/; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cff256fce47f1586c93bf1a0c49dd308/" rel="bookmark">
			【MATLAB】线性规划问题中的绝对值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在求解线性规划问题中碰到绝对值的情况:
m i n z = ∣ x 1 ∣ + 2 ∣ x 2 ∣ + 3 ∣ x 3 ∣ + 4 ∣ x 4 ∣ , min z=|x_1|+2|x_2|+3|x_3|+4|x_4|, minz=∣x1​∣+2∣x2​∣+3∣x3​∣+4∣x4​∣,
s . t . { x 1 − x 2 − x 3 + x 4 = 0 , x 1 − x 2 + x 3 − 3 x 4 = 1 , x 1 − x 2 − 2 x 3 + 3 x 4 = − 1 2 , s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cff256fce47f1586c93bf1a0c49dd308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cb90c87c9330b4c32129fddd83dde66/" rel="bookmark">
			Spring Boot系列(一)：Spring Boot 入门篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
对于学习Java的童鞋来说，可都是有用的博文，也是我悉心选择推荐给大家的。这次为大家带来的系列文章是关于Spring Boot的，Spring Boot对Javaer来说应该是很常用的一个框架。希望这个系列能对大家有用！​编辑
快速入门
总结
对于学习Java的童鞋来说，可都是有用的博文，也是我悉心选择推荐给大家的。这次为大家带来的系列文章是关于Spring Boot的，Spring Boot对Javaer来说应该是很常用的一个框架。希望这个系列能对大家有用！ 构建微服务：Spring boot 入门篇
什么是spring boot
Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是spring boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架（不知道这样比喻是否合适）。
使用spring boot有什么好处
其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？
1）配置web.xml，加载spring和spring mvc
2）配置数据库连接、配置spring事务
3）配置加载配置文件的读取，开启注解
4）配置日志文件
...
配置完成之后部署tomcat 调试
...
现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍！
但是如果使用spring boot呢？
很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！
使用sping boot到底有多爽，用下面这幅图来表达
快速入门 说了那么多，手痒痒的很，马上来一发试试！
maven构建项目
1、访问http://start.spring.io/
2、选择构建工具Maven Project、Spring Boot版本1.3.6以及一些工程基本信息，点击“Switch to the full version.”java版本选择1.7，可参考下图所示：
3、点击Generate Project下载项目压缩包
4、解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done!
项目结构介绍
如上图所示，Spring Boot的基础结构共三个文件:
l src/main/java 程序开发以及主程序入口l src/main/resources 配置文件l src/test/java 测试程序 另外，spingboot建议的目录结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cb90c87c9330b4c32129fddd83dde66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327709a5fe69d42f3a6e7a0ffdce2c4f/" rel="bookmark">
			Android内部存储与外部存储（私有目录与公共目录）图文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、存储空间概述
二、存储空间的划分
1、存储划分
2、内部存储
2.1 内部存储概述
2.2 内部存储 - 私有目录
3. 外部存储
3.1 外部存储概述
3.2 外部存储 - 私有目录
3.3 外部存储 - 公共目录
三、内部存储与外部存储比较
1、横向对比
2、目录结构
3、存储分类
四、总结
应用程序在 Android 系统运行过程中产生的用户数据、日志、下载的图片、文件等都需要存储在 Android 系统提供的存储空间里，所以有必要了解 Android 系统下存储空间的概念、分类、特点以及使用方法，在实际应用中采用适合的方式保存数据。
一、存储空间概述 从存储介质来说，Android 的存储空间用于数据持久化存储，属于 ROM 存储介质，手机关机或者退出 App 数据不会丢失，这里需要和经常提到的“内存”从概念上进行区分：内存属于 RAM 存储介质，退出 App 或者关机之后数据会丢失。我们在开发Android应用的过程中，避免不了要用到数据持久化技术，所谓的数据持久化就是将 RAM 中的临时数据永久性保存到 ROM 中，保证在 App 退出或者手机关机后数据不会丢失。
从存储结构来说，Android 系统的内核使用的是 Linux 内核， 所以 Android 的文件目录结构和 Linux 系统的文件目录结构类似。Android 系统使用虚拟文件系统（VFS）， VFS 的目录是以"/"为根节点，根节点下又有不同的节点。例如：/data, /sytem, /mnt, /storage 等等。
二、存储空间的划分 我们常用的数据持久化的方式有文件存储，数据库存储，SharedPreference存储等。在Android系统中有两个位置可以让应用实现数据持久化存储：内部存储和外部存储。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/327709a5fe69d42f3a6e7a0ffdce2c4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7ef2221cfbd914865449320ee7166a/" rel="bookmark">
			Android11获取串口服务流程（RK3568）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关于系统串口服务，以RK3568为例，官方demo在frameworks/base/tests/SerialChat
2、首先是获取串口服务
mSerialManager = (SerialManager)getSystemService(Context.SERIAL_SERVICE); 3、如果要想通过getSystemService获取serial服务，首先要在frameworks/base/core/java/android/content/Context.java删除SERIAL_SERVICE = "serial"的hide属性
4、检查frameworks/base/core/java/android/app/ContextImpl.java的构造函数中添加服务
import android.hardware.SerialManager; import android.os.ServiceManager; private ContextImpl(@Nullable ContextImpl container, @NonNull ActivityThread mainThread, @NonNull LoadedApk packageInfo, @Nullable String attributionTag, @Nullable String splitName, @Nullable IBinder activityToken, @Nullable UserHandle user, int flags, @Nullable ClassLoader classLoader, @Nullable String overrideOpPackageName) { mOuterContext = this; //。。。。。。省略 registerService(SERIAL_SERVICE, new ServiceFetcher() { public Object createService(ContextImpl ctx) { IBinder b = ServiceManager.getService(SERIAL_SERVICE); return new SerialManager(ctx, ISerialManager.Stub.asInterface(b)); }}); //。。。。。。。省略 } 至此串口服务就获取完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e7ef2221cfbd914865449320ee7166a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dff4a22aa06d12795cc79ce281f00e9/" rel="bookmark">
			C语言八进制转换 如何将十进制转为八进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言八进制转换：如何将十进制转为八进制
在C语言编程中，八进制是一种重要的进制类型。在某些情况下，我们需要将十进制转换为八进制。这篇文章将向大家介绍如何将十进制转换为八进制。
C语言八进制转换 如何将十进制转为八进制
一、八进制概述
八进制是一种以8为基数的进制类型。它只由0-7这几个数字组成。例如：1、2、3、4、5、6、7、10、11、12、13、14、15、16、17、20等，都是八进制数。
二、十进制转换为八进制
现在，我们详细的介绍如何将十进制转换为八进制。具体步骤如下：
定义变量 首先，我们需要定义一个变量来存储转换后的八进制数。
int octal_num = 0; 获取十进制数 接下来，我们需要获取需要转换的十进制数。
int decimal_num = 1234; 在这里，我们假设需要转换的十进制数是1234。
转换算法 接下来，我们需要将十进制数转换为八进制数。具体步骤如下：
（1）用8除以十进制数。
8 / 1234 = 154 （2）用十进制数对8取余数。
1234 % 8 = 2 （3）将余数存入八进制数的最低位。
octal_num = 2 （4）更新十进制数的值。
decimal_num = 154 （5）重复第1步至第4步，直到十进制数为0。
8 / 154 = 19 154 % 8 = 2 octal_num = 22 decimal_num = 19 8 / 19 = 2 19 % 8 = 3 octal_num = 322 decimal_num = 2 8 / 2 = 0 2 % 8 = 2 octal_num = 2322 decimal_num = 0 结果输出 最后，我们需要将转换后的八进制数输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dff4a22aa06d12795cc79ce281f00e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04df753ca9aac881e5d14f256516f93e/" rel="bookmark">
			C语言编程 三角形图形绘制教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言编程 三角形图形绘制教程
三角形是计算机图形学中最基本的图形元素之一，也是很多图形和游戏中的重要组成部分。本文将介绍如何使用C语言编程绘制三角形，包括原始的点绘制方法和简单的三角形填充算法。
C语言编程 三角形图形绘制教程
绘制三角形的基本原理 绘制一个三角形需要三个点，它们的位置决定了三角形的形状和大小。在计算机屏幕上绘制三角形通常需要指定每个点的坐标，并将它们连接到一起，形成一个三角形。在C语言中，可以使用图形库或OpenGL等库来完成这个过程。
点绘制方法 点绘制方法是最基本的三角形绘制方法，它只需要在指定的三个坐标位置上绘制一个点，然后将三个点连接起来。在C语言中，可以使用graphics.h库中的setcolor()和line()函数来实现。
int x1 = 50, y1 = 50, x2 = 100, y2 = 100, x3 = 150, y3 = 50; setcolor(RED); line(x1, y1, x2, y2); line(x2, y2, x3, y3); line(x3, y3, x1, y1); 使用上述代码，可以在屏幕上绘制一个红色的三角形。
三角形填充算法 点绘制方法只能绘制空心的三角形，如果要绘制实心的三角形，则需要使用三角形填充算法。三角形填充算法有很多种，这里介绍一种简单的扫描线算法。
扫描线算法的基本思路是，从三角形最低点开始向上扫描，计算交点并填充颜色。需要注意的是，由于扫描线算法需要对每个像素进行计算，因此效率较低，不适合用于大尺寸的图形绘制。
在C语言中，可以使用graphics.h库中的floodfill()函数来实现三角形填充。
int x1 = 50, y1 = 50, x2 = 100, y2 = 100, x3 = 150, y3 = 50; setcolor(WHITE); setfillstyle(SOLID_FILL, GREEN); line(x1, y1, x2, y2); line(x2, y2, x3, y3); line(x3, y3, x1, y1); floodfill((x1 + x2 + x3) / 3, (y1 + y2 + y3) / 3, WHITE); 使用上述代码，可以在屏幕上绘制一个绿色的实心三角形。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04df753ca9aac881e5d14f256516f93e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4510d706f042b2a1d06fcabf8f4ef842/" rel="bookmark">
			Chatgpt3.5 在python上的简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # 下面是python_LLM的环境变量，要引用的时候直接复制就行了 import openai import pandas as pd openai.api_key="sk_GbP"#这里填API #定义好询问函数 def get_completion(prompt, model="gpt-3.5-turbo"): messages = [{"role": "user", "content": prompt}] response = openai.ChatCompletion.create( model=model, messages=messages, temperature=0, # this is the degree of randomness of the model's output ) return response.choices[0].message["content"] # 如何快速的应用chatgpt get_completion("""告诉我setiment是什么意思""")#几乎可以说是最为简单的版本了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab3652545ec52422b690d5b3034ead7f/" rel="bookmark">
			20.04Ubuntu换源：提升软件下载速度和更新效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Ubuntu操作系统时，一个常见的优化措施是更改软件源，以提高软件下载速度和更新效率。软件源是指存储软件包的服务器，通过更换软件源，你可以选择更靠近你所在地区的服务器，从而加快软件下载速度，并减少更新过程中的等待时间。本文将介绍如何在Ubuntu中进行换源操作。
为什么换源？
默认情况下，Ubuntu使用官方软件源作为默认源，这些源位于全球各地。但由于网络延迟和带宽限制等因素，官方软件源可能在某些地区下载速度较慢。通过更换软件源，你可以选择一个更接近你所在地区的镜像源，从而获得更快的下载速度和更流畅的系统更新体验。
Ubuntu换源的两种方式：修改软件源文件、UI界面设置换源 1、修改软件源文件 ： 步骤一：打开终端备份源文件 在进行任何更改之前，建议备份原始的软件源文件。这样，如果在更改过程中出现问题，你可以恢复到原始的软件源设置。要备份源文件，可以使用以下命令：
sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 步骤二：选择镜像源 在选择新的软件源之前，你需要找到适合你的镜像源。一些常见的国内镜像源包括清华大学镜像源、阿里云镜像源和华为镜像源等。这些镜像源通常位于国内各地，提供更快的下载速度。
根据你的选择，打开软件源配置文件。可以使用以下命令打开文件：
sudo vim /etc/apt/sources.list 在打开的文件中，你会看到一系列以deb开头的行，表示不同的软件源。你可以选择性地注释掉原始软件源，并添加新的镜像源。例如，如果你选择使用清华大学镜像源，可以将以下行添加到文件中
清华大学镜像源：
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal universe
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates universe
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security universe
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security multiverse
中科大镜像源：
deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab3652545ec52422b690d5b3034ead7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96429b545b39da984ecebeb09e7473f/" rel="bookmark">
			position定位，下列说法错误的是（ ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		position定位，下列说法错误的是（ ）
A
fixed元素，可定位相对于浏览器窗口的指定坐标，它始终是以 body 为依据
B
absolute 的元素，如果它的父容器设置了 position 属性，并且 position 的属性值为 absolute 或者relative，那么就会依据父容器进行偏移
C
fixed 属性的元素在标准流中不占位置
D
relative元素以它原来的位置为基准偏移，在其移动后，原来的位置不再占据空间
答案是D
D选项中的说法是错误的。相对定位（position: relative）的元素在移动后，仍然占据其原来的位置，并且仍然占据相应的空间。它的移动不会影响其他元素的布局，但是它在布局中仍然保留了原来的空间。
因此，正确的说法是：
A. fixed 元素可定位相对于浏览器窗口的指定坐标，它始终是以 body 为依据。
B. absolute 的元素，如果它的父容器设置了 position 属性，并且 position 的属性值为 absolute 或者 relative，那么就会依据父容器进行偏移。
C. fixed 属性的元素在标准流中不占位置。
D. 相对定位的元素以它原来的位置为基准偏移，在其移动后，原来的位置仍然占据空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7efc37d7ab1791b7988bc816ed206fc/" rel="bookmark">
			使用Javascript在数组尾部添加数据的方法是？ A arrayObj.shift()； B arrayObj.unshift()； C arrayObj.pop()； D arrayObj
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Javascript在数组尾部添加数据的方法是？
A
arrayObj.shift();
B
arrayObj.unshift();
C
arrayObj.pop();
D
arrayObj.push()
答案是D
解析：
arrayObj.shift() 方法用于删除数组的第一个元素，并返回被删除的元素。
arrayObj.unshift() 方法用于在数组的开头添加一个或多个元素，并返回新的长度。
arrayObj.pop() 方法用于删除数组的最后一个元素，并返回被删除的元素。
arrayObj.push() 方法用于在数组的末尾添加一个或多个元素，并返回新的长度。
因此，使用 JavaScript 在数组尾部添加数据的方法是 arrayObj.push()。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6456c896e6f4d483f6a17c625732f158/" rel="bookmark">
			2022小米秋招前端-＜!DOCTYPE＞的判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于 &lt;!DOCTYPE&gt; 下列说法错误的是
A
声明必须是 HTML 文档的第一行，位于 标签之前。 B
声明没有结束标签。 C
声明对大小写不敏感。 D
声明是 HTML 标签，它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 答案是D
解析：
A. 正确，&lt;!DOCTYPE&gt; 声明必须是 HTML 文档的第一行，位于 标签之前。
B. 正确，&lt;!DOCTYPE&gt; 声明没有结束标签。
C. 正确，&lt;!DOCTYPE&gt; 声明对大小写不敏感。
D. 错误，&lt;!DOCTYPE&gt; 不是 HTML 标签，它是文档类型声明，用于告知浏览器当前 HTML 文档使用哪种 HTML 规范进行编写。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9195fec5bdf640986765be85ce754051/" rel="bookmark">
			SELECT...FOR UPDATE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SELECT...FOR UPDATE 一、悲观锁、乐观锁1.1 乐观锁1.2 悲观锁 二、SELECT...FOR UPDATE 一、悲观锁、乐观锁 在了解 SELECT...FRO UPDATE 时，先了解其几个概念，悲观锁、乐观锁。
1.1 乐观锁 乐观锁(Optimistic Locking) 假设并发冲突的概率较低，因此不会阻塞其他事务或线程的读写操作。乐观锁的核心思想是：在进行数据更新前，需先检查数据是否被其他事务修改过，如果没有修改，则进行更新操作，如果有修改，则进行冲突处理。
乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量。
乐观锁采取了更加宽松的加锁机制，避免了数据库幻读、业务处理时间过长等原因引起数据处理错误。乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。
乐观锁的实现通常涉及一下几个步骤：
读取数据：需记录读取时的版本号或时间戳。执行操作：执行数据修改。检查冲突：在更新前，再次读取数据，并比较之前记录的版本号或时间戳。处理冲突：如果检查到冲突，可以选择进行冲突处理，确保数据的一致性，如：终止当前事务、重试操作、抛出异常等。 常见的乐观锁的实现：
CAS机制：Java 中 J.U.C 并发包下非常多的类使用了 CAS 机制来处理并发问题。版本号机制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会 +1。当线程 A 要更新数据时，在读取数据的同时也会读取并记录 version 值，在提交更新时，满足 oldVersion=nowVerson 才更新。 1.2 悲观锁 悲观锁(Pessimistic Locking) ，顾名思义，在处理多个并发操作时，同一时间点，只能有一个线程可能访问其资源，其他线程需等待锁的释放，才能进行操作。
悲观锁的典型应用场景是数据库操作，其中常见的实现方式是使用数据库提供的行锁、表锁。当一个事务需要对某个数据进行操作时，会先获取锁，同时，其他事务如果也需要访问该数据，就需要等待锁的释放。
优点：保证了数据的一致性。
缺点：降低了并发性能，同一时间只能有一个线程可以对资源进行修改，其他线程需等待锁的释放。
悲观锁主要分为共享锁和排它锁：
共享锁(Shared Lock)：也叫 S锁，表示同一时间点可以允许多个线程或事务同时对资源进行 读 操作。排它锁(Exclusive Lock)：也叫 X锁，表示同一时间点只允许一个线程或事务对资源进行 读写 操作。 二、SELECT…FOR UPDATE SELECT...FOR UPDATE 是一种数据库查询语句，用于在事务中对选定的行或表进行加锁，以防止其他事务同时对这些数据进行修改。
SELECT...FOR UPDATE 语句通常与悲观锁机制一起使用。当一个事务执行 SELECT...FOR UPDATE 语句时，它会获取所选 行或表 的 排它锁，确保其他事务不能同时对这些数据进行修改，从而保持数据的一致性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9195fec5bdf640986765be85ce754051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f9ef604498c27e2475a960456be9168/" rel="bookmark">
			华为OD机试（2022&amp;2023）真题目录 &#43; 考点 &#43; 通过率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 华为OD机试是什么？华为OD面试流程？华为OD机试通过率高吗？华为OD薪资待遇？华为OD晋升空间？华为OD刷题列表，一天三题，刷出算法新高度，刷出人生新际遇。 大家好，我是哪吒。
本专栏包含了最新最全的华为OD机试真题，有详细的分析和Java代码解答。已帮助1000+同学顺利通过OD机考，发现新题目，随时更新。
华为OD机试是什么？ 华为OD机试是指华为公司的在线笔试，是华为公司用于筛选招聘岗位候选人的一种考核方式。
华为OD机试通常由多个题目组成，包括算法设计、编程、调试等多个环节，考察候选人的基础知识、实际能力和算法编写能力等多个方面，是华为招聘流程中非常重要的一环。
华为OD面试流程？ 华为OD面试流程一般包括以下几个步骤：
笔试：考察候选人的基础知识、算法设计和编程能力等多个方面。题目通常包括算法题、编程题、数据结构题等。性格测试：这部分是用来评估候选人的性格特质，以便更好地了解其适应能力、沟通能力和团队合作能力等。技术一面：该面试官通常是该项目组的技术负责人，主要考察候选人对技术的理解和实际应用能力。面试内容通常包括代码题和项目问题解决。群面：这是华为面试中比较特殊的一环，通常会组织多个候选人进行小组面试，以便更全面地了解其团队合作、沟通能力和领导能力等。终面：终面是在参加完所有面试后进行的最后一轮面试，由公司的高层领导或者HR部门的负责人进行面试。主要考察候选人的综合素质和领导潜力。 其中，笔试和性格测试是比较常见的部分，而技术一面和群面则比较特殊，通常会根据不同的岗位和项目有所不同。最终的面试结果也会根据个人的表现和竞争情况而定，不会限制通过人数。
华为OD机试通过率高吗？ 据华为官方公布的数据，华为OD机试的通过率约为75%。具体来说，华为OD机试一共有五个级别，从D1到D5，对应13到17级，每个级别的题目数量和难度都有所不同。在过去的招聘中，据说只有25%左右的候选人能够通过第一轮机试。第二轮性格测试也是招聘流程中的重要环节，会刷掉一部分人。不过，华为表示，最终的通过率取决于候选人的实际表现和竞争情况，不会限制通过人数。
此外，华为还将机试分为上机考试和在线作业两部分，上机考试主要考察算法设计和编程能力，在线作业主要考察算法思维和解决问题的能力。华为表示，在线作业部分是考察候选人的综合能力，包括解决问题的能力、沟通能力和团队合作能力等。
综合来看，华为OD机试的通过率虽然不是100%，但是也是在高水平范围内的。对于候选人来说，需要全面提升自己的能力，才能更好地通过机试。
华为OD薪资待遇？ 在华为od岗的薪资问题，并没有比市场上多多少，具体根据个人职级和绩效而定，初入职场的应届生薪资大概在20K-30K左右，相对于其他行业来说，华为的起薪是比较高的。
此外，华为的薪资结构包括基本工资、年终奖、分红等多个部分，其中年终奖的比例一般在15%以上，具体数额因个人绩效而定。此外，华为还有一些股票和期权等长期激励方式，可以让员工分享公司的成长红利。
总的来说，华为的薪资待遇相对较好，但是具体的薪资水平还是要根据个人的职级和绩效而定。
华为OD晋升空间？ 华为OD岗位的晋升空间取决于个人的能力和表现，以及公司的发展战略和需求。根据华为公司的招聘信息和应聘者的反馈，OD岗位的晋升通常有以下几个方向：
技术专家：可以继续深入学习和研究技术，成为该领域的专家，具备带领团队的能力。管理岗位：可以从技术专家向管理方向发展，承担更多的管理工作，带领团队完成项目。跨部门转岗：有些候选人可以通过在不同部门的工作经验，积累跨部门工作的经验，然后转到其他部门，进行业务拓展或管理。内部培训和发展：公司会定期组织内部培训和发展计划，为员工提供提升自身能力的机会，支持员工在公司内部寻找更适合自己的发展道路。 总的来说，OD岗位的晋升空间相对较广，但是需要候选人不断提升自身能力，积极参与公司的内部培训和发展计划，才能在职业生涯中获得更好的发展机会。
华为OD刷题列表，一天三题，刷出算法新高度，刷出人生新际遇。 1、华为OD机试真题 Java 实现【最多提取子串数目】【2023Q1 100分】
2、华为OD机试真题 Java 实现【不爱施肥的小布】【2023Q2 100分】
3、华为OD机试真题 Java 实现【猜字谜】【2023Q1 100分】】
4、华为OD机试真题 Java 实现【微服务的集成测试】【2023Q1 100分】
5、华为OD机试真题 Java 实现【字符串重新排序】【2023Q1 100分】
6、华为OD机试真题 Java 实现【知识图谱新词挖掘1】【2023Q1 100分】
7、华为OD机试真题 Java 实现【寻找关键钥匙】【2023Q1 100分】
8、华为OD机试真题 Java 实现【静态代码扫描服务】【2023Q1 100分】
9、华为OD机试真题 Java 实现【新员工座位安排系统】【2023Q1 100分】
10、华为OD机试真题 Java 实现【贪心的商人】【2023Q1 100分】
11、华为OD机试真题 Java 实现【MVP争夺战】【2023Q2 100分】
12、华为OD机试真题 Java 实现【任务总执行时长】【2023Q1 100分】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f9ef604498c27e2475a960456be9168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d4b3670f5669ba94b3c1bf6c88e9f95/" rel="bookmark">
			终于知道如何 把MATLAB中的 程序字体变大了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 一直觉得MATLAB的字体很小，但苦于不知道怎么修改。网上找一些博客，也没有可以用的，最后自己摸索，把matlab界面上的各个按钮试了个变，“暴力算法”，终于找到了！相信有很多小伙伴也小字体而苦恼，于是写了这篇博客，希望对读者有帮助。
二、如何设置大字体 废话不多说，直接上图：
（1）点击右上角的下三角
（2）选择自定义工具栏 （3）进入自定义工具栏之后，按下图依次点击，选择自己想要的字体大小，应用即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6a6adf28d1e6f917909ae39d90a509/" rel="bookmark">
			STM32CubeMX(6) —— STM32利用定时器编码器模式处理带编码器直流电机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32利用定时器编码器模式处理带编码器直流电机 文章目录 目录
STM32 Cubemax(五) —— STM32利用定时器编码器模式处理带编码器直流电机
文章目录
前言
一、硬件准备
二、接线 三、Cubemax配置
四、代码
总结
前言 电赛延期了,趁有时间再写点东西吧.
编码器电机配置较为繁琐,本文较长,耐心看下去,一定有收获.
本文适合已经对编码器有所了解的同学观看，如果对编码器原理还不太理解，可以看看CSDN中别人讲编码器的，个人觉得已经讲的十分清楚了，这里主要讲解怎么使用Cubemax去使用编码器
一、硬件准备 本次实验使用的是带增量式AB相霍尔编码器的直流减速电机 简单介绍一下这款电机,减速比为1:30,即输出轴转一圈,电机内部实际转30圈,霍尔编码器为13位编码器,即电机每转,对于编码器有2的13次方的增量.(简单的说,上面那个霍尔编码器检测的圆盘,转一圈,检测13个脉冲)
2. 电机所使用的电机驱动为应该大家都十分熟悉的L298N
这里就不过多介绍了,CSDN上也有很多对此介绍十分详细的.
3. 合适的8-12V的电源
电机额定电压为12V,可以选择串联3节锂电池12V,或者两节锂电池8V来进行实验.
二、接线 ！！！ 电机L298NSTM32M-OUT1/5V5V/A/编码器模式定时器IOB /编码器模式定时器IO GND
GNDGNDM+OUT2//ENAPWM输出IO/M1输出IO/M2输出IO 其中,这里要说明几点.
1.L298N,单片机和电机需要共地
2.我这里使用的是单PWM输出IO来控制ENA,而不是和其他博主一样使用两路PWM输出去控制M1,M2,然后一直使能的方法,这样可以节约一个定时器产生PWM.
三、Cubemax配置 1.首先是接线中用来控制M1和M2的两个IO口的输出配置,这里我使用的是PC4和PC5
2.开启定时器一的编码器模式
这里面修改Counter Period为20000,即代表,编码器计数器范围为0~20000.其他默认即可，这里的分配系数表示的对计数值分频，如果你这里写了3=4-1，那后面speed算的时候就不用除以4了。
对应的IO口为PE9,PE11.
3.开启用于控制ENA的PWM输出
这里采用的是定时器5的PWM输出.
本实验使用的是F103的板子,PWM输出频率为100hz
4.开启每隔10ms对编码器定时器中值的读取的定时器
5.最后配置中断 这里注意一下,最好编码器的更新中断定时器,要比10ms定时器的优先级高,可以防止在更新中打被打断.
四、代码 首先创建一个文件Motor.c和Motor.h,在此文件中来编写我们有关电机的代码.
首先在Motor.h中来定义一些我们常用的东西
1.Motor.h中定义Motor相关参数
#define RR 30u //电机减速比 #define RELOADVALUE __HAL_TIM_GetAutoreload(&amp;htim1) //获取自动装载值,本例中为20000 #define COUNTERNUM __HAL_TIM_GetCounter(&amp;htim1) //获取编码器定时器中的计数值 #define IN1(state) HAL_GPIO_WritePin(GPIOC,GPIO_PIN_4,(GPIO_PinState)(state)) //M1 #define IN2(state) HAL_GPIO_WritePin(GPIOC,GPIO_PIN_5,(GPIO_PinState)(state)) //M2 //电机结构体 typedef struct _Motor { int32_t lastAngle; //上10ms转过的角度 int32_t totalAngle; //总的角度 int16_t loopNum; //溢出次数计数值 float speed; //电机输出轴目前转速,单位为RPM }Motor; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae6a6adf28d1e6f917909ae39d90a509/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd77e02f122a71fd2b950cdfd73e5d12/" rel="bookmark">
			阿里云服务器开放端口的正确方式（超详细新版教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器端口怎么打开？云服务器ECS端口在安全组中开启，轻量应用服务器端口在防火墙中打开，阿里云服务器网以80端口为例，来详细说下阿里云服务器端口开放图文教程，其他的端口如8080、3306、443、1433也是同样的方法进行开启端口：
目录
云服务器ECS端口开通教程
轻量应用服务器开通端口教程
云服务器ECS端口开通教程 阿里云ECS服务器的端口设置是在防火墙中完成的，详细教程如下：
1、登录到ECS云服务器管理控制台
2、左侧栏找到【实例与镜像】&gt;&gt;【实例】，找到目标ECS实例，点击实例ID进入到实例详情页
3、切换到【安全组】页面，点击右侧【配置规则】，如下图：
阿里云服务器安全组配置规则，可以使用阿里云测速工具 aliyunping.com 测试一下本地到阿里云服务器各个地域节点的Ping值网络延迟。
4、在入方向点击【手动添加】，端口范围选择【HTTP(80)】，授权对象选择【0.0.0.0/0】，如下图：
阿里云服务器安全组开通80端口
授权策略：允许
优先级：1
协议类型：自定义TCP
端口范围 目的：HTTP(80)，系统预置了22、23、80、443、3306、3389等端口号，选择80，也可以手动输入80
授权对象 源：0.0.0.0/0，代表所有IPv4地址，意思是将80端口开放给所有的IPv4地址使用；
描述：随便填，自己知道就行
然后点【保存】即可，不需要重启云服务器，安全组规则保存后立即生效，至此云服务器ECS的80端口就已经开通了。下面阿里云百科再来说下轻量应用服务器开通80端口的流程：
轻量应用服务器开通端口教程 1、登录到轻量应用服务器管理控制台
2、在【服务器列表】中找到目标轻量应用服务器，并点击进入
3、在左侧栏找到【安全】&gt;&gt;【防火墙】，找到右上角的【添加规则】，如下图：
轻量应用防火墙开通端口
4、在添加防火墙规则页面，端口范围中输入80，如下图：
防火墙规则开通80端口
应用类型：自定义，也可以选择系统预置的
协议：TCP
端口范围：80
限制IP来源：0.0.0.0/0
备注：随意填，自己了解就好
可以在阿里云CLUB中心：aliyun.club 领取云服务器专用的满减券。
然后点【确定】，不需要重启，即时生效。
以上是阿里云服务器开通80端口教程，其他端口的开放也适用于此方法，将80改成22、443、8080、3306、3389、8888等端口号即可，云服务器ECS在安全组中设置开启端口，轻量应用服务器在防火墙中开通端口。
更多关于阿里云服务器问题及解答，请以官方页面为准。
原文：https://www.aliyunfuwuqi.com/ecs/3420/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46e59d65348d38af45b8e92bfd8a19ae/" rel="bookmark">
			uniapp 快手授权登录，发布、编辑、裁剪图片和视频，分享 Ba-Kwai
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介（下载地址） 快手授权登录，发布、编辑、裁剪图片和视频，一键智能裁剪，分享私信，打开用户主页，挂载小程序等。自带选择图片和选择视频方法。
抖音授权登录、发布、分享 Ba-Aweme（文档）
uniapp 常用原生插件大全
开放能力 账号授权社交功能生产功能 快手主站授权快手极速版授权 分享私信分享私信到指定人打开指定用户主页 单图编辑单图发布单视频编辑单视频裁剪单视频发布多视频图片裁剪智能裁剪视频多图编辑发布时挂载小程序 截图展示 准备工作 开发者需要在快手开放平台完成注册，新建一个网站应用，并获取应用标识appId 和 appSecret，详细参考申请注册流程，官网地址：https://open.kuaishou.com/platform
配置插件 在项目的 manifest.json 文件，App原生插件配置中，勾选插件，并配置appId和scope
使用方法 在 script 中引入组件
const kwai = uni.requireNativePlugin('Ba-Kwai'); 在 script 中调用（示例参考，可根据自己业务和调用方法自行修改）
methods: { sendAuth() { //授权登录 kwai.sendAuth({ state: 'BaKwai', //STATE安全参数，标识和用户或者设备相关的授权请求。建议开发者实现 loginType: 1, //默认1，1 通过快手App登录授权 2 通过H5页面登录授权 //isGetOpenId: true }, (res) =&gt; { console.log(res) if (res.data) { this.msgList.unshift(JSON.stringify(res.data)); } uni.showToast({ title: res.msg, icon: "none", duration: 3000 }) }); }, initKwaiOpenAPI() { //初始化使用接口 KwaiOpenAPI kwai.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46e59d65348d38af45b8e92bfd8a19ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697ee9700d87c91d98046ef78ddce7e7/" rel="bookmark">
			005——Fiddler安卓手机APP抓包（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓app开发很多时候，需要利用手机抓包，方便测试，
这篇博文详细介绍了如何利用Fiddler抓取安卓手机app的包
Fiddler安卓手机APP抓包 - 想念让我更烦恼 - 博客园 (cnblogs.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19d5a85c65fd0cf014c3c8ceaba97a0/" rel="bookmark">
			吐血整理！这份《python面试宝典》，你一定要看！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人情况基本介绍 我是2021年的校招应届生，同时也是字节教育的一名python工程师。从 10月底入职到现在也有差不多5个月了，这5个月我也逐渐适应了字节跳动的工作、生活方式，这也代表着从学校到职场的一些转变，正好2022年的金三银四又快到了，很多朋友可能还没有准备好，我就想把我面试的一些经验和诀窍分享出来，希望能够给到想了解的同学一些帮助。
面试前准备 简历
如果把自己看成一个产品，那么简历就是说明书。
先是准备好简历，写简历看似简单，想写好实则不容易。一份好的简历能帮你在一堆简历中脱颖而出。
刷题
正确的思路应该是：提前 2 - 3 个月开始复习面试的知识点的，提前 5 - 6 个月左右刷题的，如果时间太过于仓促，就先把历年大厂真题先多刷几遍。
项目
如果项目经验绝对会给你加分，所以在学python的过程中，一定要多参与项目，便于自己对一些项目的理解。
面试 我当初面试大概是这样的：9 月份只面试了 15 场左右，有时隔几天才面试一场，10 月份就厉害了，虽然工作日的时间只有 3 周，但是安排的面试最为密集，基本上 25 场左右，平均每天都安排 2 ~ 3 场，有时一天有 4 场的：上午一场、中午两场、晚上还有一场。
一天面试 2 - 3 场下来，直接累得躺床上，不想动。
我面试的思路是：先面试一些小公司，基本都拿到 offer 了，再去面试一些不想去的大公司，觉得稳了，再面试最想去的公司，当然如果你很牛逼，可以不用按这个思路来。
一开始是每场面试我都会记录技术问题的，方便查漏补缺，但是到后期就只记录一些自己回答不好的问题了，因为很多问题我都遇到过了的。
面试到 10 月份的时候，发现那些面试官问的基本都是这些了，很多问题的答案我都说了十几遍，想不记住都难、张口就来那种。
技术问题的回答率从 9 月份的 85% - 90% 左右到 10 月份的 95% 左右，技术面试基本都是通过的了。
所以，多面试也有好处，战线拉得长一点，你的失误会越来越少，也会越来越明确自己的目标，不会将就。
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19d5a85c65fd0cf014c3c8ceaba97a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11e019ded0dba923c54d27aa9c5e92d0/" rel="bookmark">
			Java线程的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.线程和进程
1.概念
2，进程和线程的区别
二.线程的五种创建方式
1.继承Thread类
2.实现Runnable接口
3.继承Thread类，使用匿名内部类
4.实现Runnable接口，使用匿名内部类
5.使用Lambda表达式创建线程
一.线程和进程 1.概念 线程：一个线程就是一个 "执行流". 每个线程之间都可以按照顺讯执行自己的代码. 多个线程之间 "同时" 执行着多份代码。通俗点说就是一个应用程序中执行着不同的功能，比如我们用微信聊天，微信运行起来相当于一个进程，而我们使用微信聊天，发朋友圈等等就相当于不同的线程。
进程：是正在运行的程序的实例，是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，通俗点说相当于一个跑起来的程序。
2，进程和线程的区别 1.一个进程至少包含一个或者多个线程；2.进程有自己独立的内存空间和文件和描述符表，同一个进程中的多个线程，公用一个地址和文件描述符表；3.进程是操作系统资源分配的基本单位，线程是操作系统调度执行的基本单位4.进程之间具有独立性，一个进程崩了，不会影响到其他进程；同一个进程中的多个线程，一个线程挂了，可能影响到整个进程或者其他线程； 二.线程的五种创建方式 1.继承Thread类 class Mythread extends Thread { @Override public void run() { while (true) { System.out.println("线程1"); try { Thread.sleep(1000);//控制打印的速度 } catch (InterruptedException e) { e.printStackTrace(); } } } } public class Demo1 { public static void main(String[] args) throws InterruptedException { //创建一个线程 Thread thread = new Mythread(); //启动线程 thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11e019ded0dba923c54d27aa9c5e92d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caaab9ee4c72915a7d64ae8592f5608a/" rel="bookmark">
			JavaWeb：实现酒店管理系统（课程设计完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 该系统是一个基于JavaWeb的酒店管理系统。
前端用到了 html+css+js+jQuery；
后端Http协议，Servlet基础，JSP技术，Mysql等
这个项目的代码相对简单、不太复杂，适合在校的学生参考。
文章末尾附项目源代码和图片素材。
一、功能概述 先简单的介绍一个这个项目的功能。
项目分为两个大部分：普通用户和管理员。
普通用户：注册和登陆账号，查看和修改自己的个人信息、查看自己的预约记录，查看其他客房情况并且可以预约。
管理员：查看所有客房信息，可以对客房进行增加、修改、下架、查询功能，也可以代替用户预约客房，取消预约等功能。
二、代码分析 action层：管理业务调度和管理跳转的，即处理逻辑问题bean层：封装数据，设置数据的属性和行为biz层：接受数据库的处理结果并且返回给前端dao层：对数据库进行增删改查util层： 是一个多功能，基于工具的包。比如字符串处理，JDBC连接等 三、项目展示 1.选择登录入口页面 2.登录页面 3.管理员客房管理页面 4.添加客房信息 5.修改客房信息 6.普通用户个人预约信息 7.普通用户个人信息查看和修改 四、部分代码展示 1.登录和注册 //1.判读用户请求的类型为login String method = req.getParameter("type"); switch (method) { case "login": // 从 login.html中 拿 账号，密码等数据 String name = req.getParameter("name"); String pwd = req.getParameter("pwd"); // 调用UserBiz的getUser方法，根据 网页中 输入的账号密码，获取相应对象 User user = userBiz.getUser(name,pwd); //判断 获取到的对象是否为 null; if (user == null) { System.out.println(user); out.println("&lt;script&gt;alert('用户名或密码不存在');location.href = 'login.html';&lt;/script&gt;"); }else { session.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caaab9ee4c72915a7d64ae8592f5608a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a9695feb42aba6347f316433a5009c2/" rel="bookmark">
			如何把ipa文件(iOS安装包)安装到iPhone手机上? 附方法汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苹果APP安装包ipa如何安装在手机上？很多人不知道怎么把ipa文件安装到手机上，这里就整理了苹果APP安装到iOS设备上的方式，仅供参考
苹果APP安装包ipa如何安装在手机上？使用过苹果手机的人应该深有感触，那就是苹果APP安装要比安卓APP安装复杂、困难很多，很多人不知道怎么把ipa文件安装到手机上，所以很多苹果用户还会选择越狱，下面我们来说说，目前常见的，。
方法
一、上架App Store
1、虽然很困难，但是，亥著告诉大家，这就是最正规的方式。
App Store的审核过程比较复杂，花费的时间较长，而且审核比较苛刻，所以并不是所有的APP都可以成功上架的，如果自己对于上架流程不够了解，可以借助第三方开发者服务平台代上架。
2、进入亥著平台，点击右上角的“开发者中心”，输入账号密码进行登录，如果没有账号，可以使用手机号注册一个。
进入亥著开发者中心，点击左侧导航栏的“APP上架”，选择iOS上架，上传自己的ipa文件。
二、越狱
越狱是很多iOS用户会尝试的方法，但是越狱也会带来弊端，系统不稳定，售后无法保修等等。
三、手机助手
iOS手机助手会提供苹果软件，这也是一种ios设备安装APP的方法，不过用过这种方法的用户应该大都遇到过一个问题，系统不稳定导致的闪退，尤其是游戏用户。
四、企业签名
用企业账号生成企业证书，对app进行签名。这是企业客户在进行内分发时经常会使用的方法。安装无限制，只需要信任企业证书即可。
五、超级签名
添加苹果手机udid，打包安装（最多安装100台），这种安装方式主要依靠个人开发者账号，但由于个人开发者账号的价格较高且有下载数量限制，所以一般来说单价较高，并不适合那些用户多的app，但如果用户量不是特别多，超级签名的优势就完全发挥出来了，按照下载量收费，稳定性高。
六、TF签名
又叫TF上架，testflight是苹果官方认可的分发模式，是目前最稳定的签名方式，性价比极高。一经上架，基本不会掉签。
注意：进行签名的ipa文件必须为未签名的。
Appuploader 常见错误及解决方法 问题解决秘籍
遇到问题，第一个请登录苹果开发者官网 检查一遍账号是否有权限，是否被停用，是否过期，是否有协议需要同意，并且在右上角切换账号后检查所有关联的账号是否工作正常，apple账号的邮箱也是个重要的地方，当有ipa上传，账号有发生变化，被停用，apple经常发送一些邮件，去检查邮件通知，根据邮件通知修改调整。只有账号正常没问题,功能才能正常使用。apple开发常用的3个网址: 开发者中心 ： Sign In - Apple
app管理中心： https://appstoreconnect.apple.com/
apple ID管理中心： Manage your Apple ID
工具只是提高工作效率，不要想着使用工具来突破apple限制，或者实现apple本身没有的功能。 常见的例如没给apple 688年费就想着软件上架，想长期有效突破apple 7天的限制，想着不受苹果限制的证书期限，设备数量限制等，都是异想天开，这是不可能的。
登录失败
弹出空白错误提示，请下载最新版本的appuploader试试，或者删除appuploader目录下的data目录试试 收不到短信，请在发送类型地方选择短信类型，选择自己能收短信的号码，并且一天之内有总短信数量限制，没用超过数量
登录的时候如果没给apple 688费用的，请勾选未支付688，否则登录进去后会提示免费账号，这个提示不是说没激活appuploader的意思。
无法启动
最新版本部分电脑有兼容问题，可以下老一点的版本(带数字标记的是老版本)，例如appuploader_win_0608.zip appuploader 老版本
don't have access,提示没权限或同意协议
下面几个错误是是因为苹果更新了协议，请登录苹果官网同意协议。
下面这个提示可能是账号过期，或者被停用，或者没付费688给apple，或者有协议需要更新。解决办法就是登录apple网站，确保账号正常。
苹果协议更新的常见的3个网址，每个网址都需要进去检查一遍，检查完了点击右上角的切换账号按钮，再进去检查一遍，检查完了点击右上角的切换账号按钮，再进去检查一遍，检查完了点击右上角的切换账号按钮，再进去检查一遍，重要的事情说3遍开发者中心 ： Sign In - Appleapp管理中心： https://appstoreconnect.apple.com/apple ID管理中心： Manage your Apple ID证书管理中心 Sign In - Apple
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a9695feb42aba6347f316433a5009c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/052ec0fe412c51a7ff2abc6afea0ea24/" rel="bookmark">
			【Python】使用函数统计指定数字的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码思路仅供参考，欢迎大家批评指正！
目录 6-3 使用函数统计指定数字的个数函数接口定义裁判测试程序样例样例详情思路代码 6-3 使用函数统计指定数字的个数 本题要求实现一个统计整数中指定数字的个数的简单函数。
CountDigit(number,digit )
其中number是整数，digit为[1, 9]区间内的整数。函数CountDigit应返回number中digit出现的次数。
函数接口定义 在这里描述函数接口。例如： CountDigit(number,digit ),返回digit出现的次数 裁判测试程序样例 /* 请在这里填写答案 */ number,digit=input().split() number=int(number) digit=int(digit) count=CountDigit(number,digit ) print("Number of digit 2 in "+str(number)+":",count) 样例详情 思路 利用字符串的count函数仅一行代码即可实现
代码 # By jurio. def CountDigit(number, digit): return str(number).count(str(digit)) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/137/">«</a>
	<span class="pagination__item pagination__item--current">138/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/139/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>