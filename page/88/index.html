<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f68c7390e7ab466c252a418dbf7d15/" rel="bookmark">
			重新开始学stm32 控制算法 —— PID算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天我们来学习新的内容 —— PID算法。想必大家都听说过 PID 算法的鼎鼎大名了，今天我们就从增量式 PID 和位置式 PID 这两种来认识这个非常实用且通用的控制算法。
简介 首先，我们还是先来简单了解一下什么是 PID 。
PID即：Proportional（比例）、Integral（积分）、Differential（微分）的缩写。PID 的使用场景非常广泛，凡是需要将某个物理量保持稳定的场景，PID 都可以大显神通。像它的名字一样，它的组成部分有三个部分：比例部分、积分部分、微分部分。
1.比例（P）部分
成比例地反映控制系统的偏差信号 e(t)，偏差一旦产生，控制器立即产生控制作用，以减小偏差。当仅有比例控制时系统输出存在稳态误差。P 参数越大比例作用越强，动态响应越快，消除误差的能力越强。但实际系统是有惯性的，控制输出变化后，实际 u(t) 值变化还需等待一段时间才会缓慢变化。所以，由于实际系统是有惯性的，比例作用不宜太强，比例作用太强会引起系统振荡不稳定。P 参数的大小应在以上定量计算的基础上根据系统响应情况，现场调试决定，通常将P参数由大向小调，以能达到最快响应又无超调为最佳参数。
要形象地理解的话，就比如控制水温，要控制现在的水温达到目标的水温，加热的功率根据两者的差距按比例来提供。当当前水温与目标水温差距较小时，就可以以较小的功率加热；当当前水温与目标水温差距较大时，就可以以较大的功率加热；当当前水温与目标水温差距极大时，就可以以极大的功率加热，就可以快速达到接近目标水温的温度。
2.积分（I）部分
控制器的输出与输入误差信号的积分成正比关系，主要用于消除静差。积分作用的强弱取决于积分时间常数 t，t 越大，积分作用越弱，反之则越强。
由于只有比例部分是不可能完全消除静态误差的，加强比例作用只能减小静态误差，所以必须引入积分作用。积分作用消除静差的原理是，只要有误差存在，就对误差进行积分，使输出继续增大或减小，一直到误差为零，积分停止，输出不再变化。但由于实际系统是有惯性的，输出变化后，u(t) 值不会马上变化，须等待一段时间才缓慢变化，因此积分的快慢必须与实际系统的惯性相匹配，惯性大，积分作用就应该弱，积分时间 I 就应该大些，反之而然。如果积分作用太强，积分输出变化过快，就会引起积分过头的现象，产生积分超调和振荡。通常 I 参数也是由大往小调，即积分作用由小往大调，观察系统响应以能达到快速消除误差，达到给定值，又不引起振荡为准。
还是拿控制水温来理解，按前面的按比例提供功率加热，当水温到达某个接近目标水温的温度时，我们按比例提供的加热功率来加入水与水的自然降温速度一样了，诶，温度没法再加了。这时候就需要到积分部分了，在前面一开始加热时就开始累积误差，时刻矫正着加热的力度，从而使水温更加接近目标水温。
3.微分部分
反映偏差信号的变化趋势，并能在偏差信号变得太大之前，在系统中引入一个有效的早期修正信号，从而加快系统的动作速度，减少调节时间。在微分控制中，控制器的输出与输入误差信号的微分（即误差的变化率）成正比关系。
不论比例调节作用，还是积分调节作用都是建立在产生误差后才进行调节以消除误差，都是事后调节。但是我们肯定是想要我们的系统在控制调整后能快速恢复，比例作用和积分作用是事后调节(即发生误差后才进行调节)，而微分作用则是事前预防控制，即一发现u(t)有变大或变小的趋势，马上就输出一个阻止其变化的控制信号，以防止出现过冲或超调等。D越大，微分作用越强，D越小，微分作用越弱。系统调试时通常把D从小往大调，具体参数由试验决定。
接着用控制水温来理解，就是当我们要对水加热或冷却时，都要一定程度去减小这个水的加热或冷却的速度，从而避免加热或冷却太过了。也许举另一个例子会更加形象，“阻尼” 大家都知道吧，其实微分部分的作用就相当于是 “阻尼” 的作用。
位置式PID 位置式 PID 的公式如下：
下面我们使用代码来实现这条公式。
我们可以先定义一个结构体来保存我们需要使用到的变量。
typedef struct { float target_val; //目标值 float err; //误差值 float err_last; //上一个误差值 float Kp,Ki,Kd; //比例、积分、微分系数 float integral; //积分值 float output_val; //输出值 }PID; 然后我们根据公式来写我们的位置式 PID 的运算函数。 float PID_realize(PID* pid, float actual_val) { pid-&gt;err = pid-&gt;target_val - actual_val; (1) pid-&gt;integral += pid-&gt;err; (2) pid-&gt;output_val = pid-&gt;Kp * pid-&gt;err + pid-&gt;Ki * pid-&gt;integral + pid-&gt;Kd * (pid-&gt;err - pid-&gt;err_last); (3) pid-&gt;err_last = pid-&gt;err; (4) return pid-&gt;output_val; } （1）首先是计算出误差e(k)，就是用目标值pid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7f68c7390e7ab466c252a418dbf7d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8914a21e1395ae507431b91e38f9a86/" rel="bookmark">
			Linux：haproxy部署--搭建nginx集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Haproxy介绍 Haproxy是一个开源的高性能的反向代理或者说是负载均衡服务软件之一，它支持双机热备、虚拟主机、基于TCP和HTTP应用代理等功能。
其配置简单，而且拥有很好的对服务器节点的健康检查功能（相当于keepalived健康检查），当其代理的后端服务器出现故障时，
Haproxy会自动的将该故障服务器摘除，当服务器的故障恢复后Haproxy还会自动将RS服务器添加
Haproxy特别使用与那些访问量很大。但又需要会话保持或七层应用的业务。Haproxy运行在普通的服务器硬件上，仅仅进行简单的优化就可以支持数以万计的并发连接。
并且它的运行模式使得它可以很简单安全的整合到各种网站的架构中，同时使得应用服务器不会暴露到网络中。
Haproxy软件引入了frontend，backend的功能，frontend（acl规则匹配）可以运维管理人员根据任意HTTP请求头做规则匹配，
然后把请求定向到相关的backend（server pools等待前端把请求转过来的服务器组）。通过frontend和backup，
我们可以很容易的实现haproxy的7层代理功能，haproxy是一款不可多得的优秀代理服务软件 Haproxy支持两种主要代理模式：第一个是4层tcp代理（例如：可用于邮件服务内部协议通信服务器、Mysql服务等）。
第二个是7层代理（如HTTP代理）。在4层tcp代理模式下，Haproxy仅在客户端和服务器之间双向转发流量。
但是在7层模式下Haproxy会分析应用层协议，并且能通过运行、拒绝、交换、增加、修改或者删除请求（request）或者回应（reponse）里指定内容来控制协议。 环境介绍 一台centos7作为nginx服务器 192.168.254.1
一台centos7作为nginx服务器 192.168.254.2
一台centos7作为haproxy服务器 192.168.254.3 为两个nginx服务器去实现负载均衡
haproxy部署 搭建nginx（两台服务器操作一样） nginx：下载https://nginx.org/en/download.html
去链接即可下载tar.gz归档包
放进Linux里
yum -y install pcre-devel zlib-devel gcc make tar xfv nginx-*.tar.gz -C /usr/src/ cd /usr/src/nginx-* useradd -M -s /sbin/nologin nginx ./configure --prefix=/usr/local/nginx --user=nginx --group=nginx &amp;&amp;make &amp;&amp;make install echo "&lt;h1&gt;server 192.168.254.1&lt;/h1&gt;" &gt;/usr/local/nginx/html/index.html 如果是web2 改为192.168.254.2区分开 echo "&lt;h1&gt;server 192.168.254.2&lt;/h1&gt;" &gt;/usr/local/nginx/html/index.html /usr/local/nginx/sbin/nginx 开启
killall -9 nginx 关闭
现在两台nginx服务器就全搭建完了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8914a21e1395ae507431b91e38f9a86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5d99572b4a38c408b61dbe7a6ec3f56/" rel="bookmark">
			openEuler下部署zabbix及简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
二、修改主机host文件
服务端 ：
客户端：
三、配置yum源 两台linux操作一致
1、 挂载光盘：
2、配yum本地源：
四、安装lamp环境 两台linux操作一致 五、关闭防火墙 两台linux操作一致 六、服务器安装zabbix服务 七、部署客户端
八、创建主机，监控项等
两台openEuler虚拟机
服务端ip：192.168.89.19
客户端ip：192.168.89.16
二、修改主机host文件 添加格式 ip 加主机名称
服务端 ： vim /etc/hosts
192.168.89.19 zabbix 客户端： vim /etc/hosts
192.168.89.19 zabbix 192.168.89.16 kehu
三、配置yum源 两台linux操作一致 1、 挂载光盘： [root@zabbix ~]# mkdir /zabbix [root@zabbix ~]# mount /dev/cdrom /zabbix mount: /zabbix: WARNING: source write-protected, mounted read-only. [root@zabbix ~]# vim /etc/fstab /dev/cdrom /zabbix iso9660 ro o o [root@zabbix ~]# mount -a 2、配yum本地源： [root@zabbix ~]# cd /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5d99572b4a38c408b61dbe7a6ec3f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8288c71b27e45343ead35febefc8663f/" rel="bookmark">
			openEuler系列 虚拟机配置本地yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、创建挂载
手动挂载
自动挂载
2、配本地yum源
1、创建挂载 将linux设备文件挂载到某个目录，通过该目录来访问设备文件里内容
mkdir openEuler 手动挂载 确定设备已连接
mount /dev/cdrom /opt/openEuler # 将光盘镜像文件挂载到刚刚创建的目录 df -Th #查看挂载结果 手动挂载 系统重启之后消失 如果让系统开机自动挂载，需要实现自动挂载
自动挂载 修改配置文件：/etc/fstab 在里面添加一行
/dev/cdrom /opt/openEuler iso9660 defaults 0 0 # #要挂载的设备 挂载点 文件系统格式 挂载选项 转存频率 自检次序 mount -a # 实现自动挂载，之后重启设备生效 2、配本地yum源 yum源仓库
阿里云：http://mirrors.aliyun.com/repo/
163：http://mirrors.163.com/centos/7/os/x86_64/
华为云：https://repo.huaweicloud.com/centos/
清华大学：https://mirrors.tuna.tsinghua.edu.cn/ce ntos-vault/
删除重命名原来的yum源文件
cd /etc/yum.repos.d mv openEuler.repo openEuler.repo.a # 修改了原有的名字 vim openEuler.repo # 重新创建了一个文件 配置如下 [myopenEuler] # yum源文件的名称，必须唯一 name=myopenEuler # yum仓库的名称 baseurl=file:///opt/openEuler #yum仓库的路径 可以填网上开源的路径 gpgcheck=0 #是否检查 0不检查 1检查 enable=1 # 是否启用 0不启用 1启用 # 如果gpgchek=1 必须添加 # gpgkey=xxxxx 密钥 yum clean all # 清空缓存
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8288c71b27e45343ead35febefc8663f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e798294bf05bc5ba214689596fecff25/" rel="bookmark">
			线性表---单链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性表一、线性表的定义二、线性表的特点三、存储结构-- 解决以下问题四、顺序表的特点五、顺序表的优缺点 线性表 一、线性表的定义 零个或多个数据元素的有限序列 二、线性表的特点 1.它是一个序列
a.数据元素之间是有序的
%nbsp;b.数据元素之间是一对一的关系2.有限性 三、存储结构 1.顺序存储结构
2.链式存储结构
– 解决以下问题 (1) 顺序表的基本描述
(2)顺序表的查找；
代码如下： LinkList LocateELem (LinkList L，Elemtype e) { p=L-&gt;next;j++; while(p) { if(p-&gt;data == e) return p; else { p=p-&gt;next; j++; } } return p; } (3)顺序表的插入；
代码如下： int ListInsert(LinkList &amp;L,int i,ElemType e){ p=L;j=1; while(p&amp;&amp;j&lt;i){p=p-&gt;next;++j;}	//寻找第i−1个结点 if(!p||j&gt;i−1)return 0;	//i大于表长 + 1或者小于1 q=new LNode;	//生成新结点s q-&gt;data=e; q-&gt;next=p-&gt;next;	//将结点s插入L中 p-&gt;next=q; return 1; } (4)顺序表的删除；
代码如下： int ListDelete_L(LinkList &amp;L,int i){ p=L;j=1; while(p &amp;&amp;j&lt;i){//寻找第i个结点，并令p指向其前驱 p=p-&gt;next; ++j; } if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e798294bf05bc5ba214689596fecff25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b5e9474df77cd1f7aecb6cd59814cf/" rel="bookmark">
			MySQL高可用InnoDB Cluster
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		InnoDB Cluster InnoDB Cluster是MySQL官方推出的一个全栈高可用解决方案。
InnoDB Cluster包含3个核心组件
MySQL Group Replication（MGR组复制）
MySQL Shell（MySQL高级客户端）
MySQL Router（MySQL路由）
MySQL Shell安装与配置 1、安装MySQL Shell [root@node01 ~]# wget https://downloads.mysql.com/archives/get/p/43/file/mysql-shell-8.0.33-linux-glibc2.12-x86-64bit.tar.gz [root@node01 ~]# tar -xf mysql-shell-8.0.33-linux-glibc2.12-x86-64bit.tar.gz -C /usr/local [root@node01 ~]# ln -s /usr/local/mysql-shell-8.0.33-linux-glibc2.12-x86-64bit/ /usr/local/mysqlsh [root@node01 ~]# mysqlsh --help MySQL Shell 8.0.33 Usage examples: $ mysqlsh --login-path=server1 --sql $ mysqlsh root@localhost/schema $ mysqlsh mysqlx://root@some.server:3307/world_x $ mysqlsh --uri root@localhost --py -f sample.py sample param $ mysqlsh root@targethost:33070 -s world_x -f sample.js $ mysqlsh -- util check-for-server-upgrade root@localhost --output-format=JSON 2、使用MySQL Shell root@localhost [(none)]&gt; create user 'root'@'%' identified by 'oracle'; Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b5e9474df77cd1f7aecb6cd59814cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6014fc093c5d548e36b5b14020e5810c/" rel="bookmark">
			Unity一个好用的文本下划线插件，可实现点击事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using UnityEngine.UI; class UnderlineProperty { public Color _color; public Vector3 _position; public float _width; public float _height; public Vector2 _privot; } [RequireComponent(typeof(Text))] public class MyUnderLineText : MonoBehaviour, IPointerDownHandler, IPointerUpHandler { private Text _text; private int _curCharacterCount = 0; private List&lt;Image&gt; _lines = new List&lt;Image&gt;(); private System.Action _clickEvent = null; //下划线点击事件 private bool _isInitUnderline = false; public System.Action ClickEvent { get { return _clickEvent; } set { _clickEvent = value; } } public Text Txt { get { if(_text == null) _text = transform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6014fc093c5d548e36b5b14020e5810c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd8790a078c1c6308a5eae758f9a2184/" rel="bookmark">
			SpringBoot集成RocketMQ消费者@RocketMQMessageListener注解参数介绍（内含5.x新参数介绍-rocketmq-spring-boot-starter 2.2.3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot集成RocketMQ消费者@RocketMQMessageListener注解参数介绍内含5.x新参数介绍-rocketmq-spring-boot-starter 2.2.3 @RocketMQMessageListener @RocketMQMessageListener @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface RocketMQMessageListener { // nameServer服务地址，多个用;隔开，可以直接在注解中指定也可以读取配置文件 String NAME_SERVER_PLACEHOLDER = "${rocketmq.name-server:}"; // ACL验证key，服务端开启了ACL时使用，可以直接在注解中指定也可以读取配置文件 String ACCESS_KEY_PLACEHOLDER = "${rocketmq.consumer.access-key:}"; // ACL验证密钥，服务端开启了ACL时使用，可以直接在注解中指定也可以读取配置文件 String SECRET_KEY_PLACEHOLDER = "${rocketmq.consumer.secret-key:}"; // 自定义的消息轨迹主题 String TRACE_TOPIC_PLACEHOLDER = "${rocketmq.consumer.customized-trace-topic:}"; String ACCESS_CHANNEL_PLACEHOLDER = "${rocketmq.access-channel:}"; // 消费者分组，不同消费者分组名称不能重复 String consumerGroup(); // topic名称 String topic(); // selectorType 消息选择器类型 // 默认值 SelectorType.TAG 根据TAG选择 // 仅支持表达式格式如：“tag1 || tag2 || tag3”，如果表达式为null或者“*”标识订阅所有消息 // SelectorType.SQL92 根据SQL92表达式选择 SelectorType selectorType() default SelectorType.TAG; /** * Control which message can be select.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd8790a078c1c6308a5eae758f9a2184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e24638de7c0a5a68d882aebf3b78918/" rel="bookmark">
			什么是mysql覆盖索引和索引下推？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库查询是一个常见的操作，但是如果不注意优化，可能会导致性能下降，资源浪费，甚至系统崩溃。为了提高数据库查询效率，我们需要了解一些数据库优化的技术和原理，其中两个重要的概念就是覆盖索引和索引下推。
什么是覆盖索引？
覆盖索引是指一个索引包含了查询所需的所有字段，而不需要回表查询原始数据。例如，假设我们有一个用户表，包含了用户的id，姓名，年龄，性别等字段，我们想要查询所有年龄大于18岁的用户的姓名和性别，那么我们可以创建一个包含了姓名，性别和年龄的索引，这样就可以直接从索引中获取查询结果，而不需要再访问用户表。
覆盖索引的优点是：
- 减少了磁盘I/O，提高了查询速度
- 减少了内存占用，节省了资源
- 减少了锁的竞争，提高了并发能力,它可以避免回表查询原始数据，从而减少了对数据行的访问和锁定。如果使用索引覆盖，那么只需要对索引记录加锁，而不需要对数据记录加锁。这样就可以减少锁的范围和冲突，提高并发能力
覆盖索引的缺点是：
- 增加了索引的大小，占用了更多的磁盘空间
- 增加了数据更新的开销，因为每次更新数据都需要更新索引
因此，在创建覆盖索引时，我们需要权衡利弊，选择合适的字段和顺序，避免创建过多或过大的索引。
什么是索引下推？
索引下推是指在使用联合索引时，将过滤条件下推到索引层，从而减少回表的次数。例如，假设我们有一个订单表，包含了订单的id，用户id，商品id，价格等字段，我们想要查询所有用户id为1且价格大于1000的订单的商品id和价格，那么我们可以创建一个包含了用户id，价格和商品id的联合索引，这样在扫描索引时就可以先过滤掉不满足用户id为1或价格大于1000的记录，而不需要回表查询订单表。
与联合索引不同的是，联合索引只能在查询条件中包含索引的前缀部分时才能生效，而索引下推可以在查询条件中包含任意部分的索引时生效。 例如，如果一个联合索引是（a,b,c），那么只有当查询条件中包含a或者a和b时才能使用该索引，而如果查询条件中只包含b或者c时则不能使用该索引。 但是如果使用了索引下推，那么即使查询条件中只包含b或者c，也可以将这些条件下推到索引层面上进行过滤，从而减少回表的次数和范围。
我们来具体看一下，在没有使用索引下推的情况下，MySQL的查询：
存储引擎读取索引记录；
根据索引中的主键值，定位并读取完整的行记录；
存储引擎把记录交给Server层去检测该记录是否满足WHERE条件。
使用索引下推的情况下，查询过程：
存储引擎读取索引记录（不是完整的行记录）；
判断WHERE条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；
条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；
存储引擎把记录交给Server层，Server层检测该记录是否满足WHERE条件的其余部分。
索引下推的优点是：
- 减少了回表的次数和范围，提高了查询速度
- 减少了数据传输量和网络开销
索引下推的缺点是：
- 增加了索引扫描的复杂度和开销
- 可能会导致误判或漏判，因为索引层无法处理一些复杂或模糊的过滤条件
因此，在使用索引下推时，我们需要注意一些限制和条件，比如：
- 索引下推只适用于联合索引
- 索引下推只适用于部分数据类型和操作符
- 索引下推可能会受到优化器的影响
总结
覆盖索引和索引下推是两种提高数据库查询效率的技术。覆盖索引是指一个索引包含了查询所需的所有字段，而不需要回表查询原始数据。索引下推是指在使用联合索引时，将过滤条件下推到索引层，从而减少回表的次数。这两种技术都有各自的优缺点和适用场景，在使用时需要根据实
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e3a6b2eb16a2ec693bc45647cc71eed/" rel="bookmark">
			如何在Ubuntu系统上安装VirtualBox Guest Additions？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这篇博文中，我们将向你展示如何在 Ubuntu 22.04 上安装 VirtualBox Guest 插件。
在 Oracle VirtualBox 中运行 Ubuntu 22.04 是很常见的场景。虽然 VirtualBox 提供了无缝的虚拟化体验，但您可以通过安装 VirtualBox Guest Additions 进一步改进它。这些新增功能提供了增强的功能和性能，包括更好的显示分辨率、无缝的鼠标集成以及改进的主机和客户操作系统之间的文件共享。
必备条件 Pre-Installed Ubuntu 22.04 VMA Regular User with sudo rightsStable Internet connectivity (1) 启动 Ubuntu 虚拟机 在我们进入安装过程之前，请确保您的 Ubuntu 虚拟机在 VirtualBox 中启动并运行。
(2) 安装依赖包 在安装 VirtualBox Guest add 之前，您需要一些基本的软件包，在终端上运行以下命令
$ sudo apt update $ sudo apt install build-essential linux-headers-$(uname -r) -y (3) 挂载 VirtualBox Guest Additions CD 镜像 在 VirtualBox 中，转到虚拟机窗口顶部的“Devices”菜单，然后选择“Insert Guest Additions CD Image”。此操作将虚拟地将 Guest Additions CD Image 装入虚拟机中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e3a6b2eb16a2ec693bc45647cc71eed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4954d9ada009d6bffe382f53a609e6bd/" rel="bookmark">
			忽视日志吃大亏，手把手教你玩转 SpringBoot 日志！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、日志重要吗 程序中的日志重要吗？ 在回答这个问题前，笔者先说个事例：
❝ 笔者印象尤深的就是去年某个同事，收到了客户反馈的紧急bug。尽管申请到了日志文件，但因为很多关键步骤没有打印日志，导致排查进度很慢，数个小时都没能排查到问题，也无法给出解决对策。导致了客户程序一直阻断，最终产生了不少损失。 事后，经过仔细推敲，成功复现了这个bug，其实是一个很不起眼的数据转换导致的。可因为日志内容的匮乏，排查起来难度很大。其实只要在数据转换前后进行日志输出，这个问题就是一眼的事。但可惜没如果，故事的最后，开发部门还是遭到了客户的投诉，影响到了部门绩效
❞ 对于刚学习编程的同学，很多人都对日志满不在乎，我们在做code review的时候，经常发现一些新同学喜欢一个方法写得很长，然后中间的注释和日志都少的可怜。
坦白的说，这是很不好的习惯，这意味着日后方法出了bug，或者需要迭代，要花费大量时间来理清方法的思路。千万别迷信什么“方法名、字段名起的见明知意，就可以不写注释与日志”，那是他们的业务场景不够复杂。以笔者为例，复杂的场景涉及很多公式、奇特的规定，不写注释与日志，后续没人能维护得了
所以请务必记住，日志在开发过程中非常重要。它可以帮助开发人员了解程序中发生了什么，以及在某些情况下为什么会发生错误或异常。通过查看日志，开发人员可以轻松地定位并解决问题，并且可以更好地监控和调整应用程序的性能，在必要时进行故障排除和安全检查
二、日志分级 最开始的日志分级是由Syslog的开发者Eric Allman在1981年提出的。之后，这个级别分级系统被广泛应用于各种领域的日志记录和信息处理中。下面我们就来介绍下常用的日志等级
TRACE
是最低级别的日志记录，用于输出最详细的调试信息，通常用于开发调试目的。在生产环境中，应该关闭 TRACE 级别的日志记录，以避免输出过多无用信息。
DEBUG
是用于输出程序中的一些调试信息，通常用于开发过程中。像 TRACE 一样，在生产环境中应该关闭 DEBUG 级别的日志记录。
INFO
用于输出程序正常运行时的一些关键信息，比如程序的启动、运行日志等。通常在生产环境中开启 INFO 级别的日志记录。
WARN
是用于输出一些警告信息，提示程序可能会出现一些异常或者错误。在应用程序中，WARN 级别的日志记录通常用于记录一些非致命性异常信息，以便能够及时发现并处理这些问题。
ERROR
是用于输出程序运行时的一些错误信息，通常表示程序出现了一些不可预料的错误。在应用程序中，ERROR 级别的日志记录通常用于记录一些致命性的异常信息，以便能够及时发现并处理这些问题。
当然，除了这五种级别以外，还有一些日志框架定义了其他级别，例如 Python 中的 CRITICAL、PHP 中的 FATAL 等。CRITICAL 和 FATAL 都是用于表示程序出现了致命性错误或者异常，即不可恢复的错误。当然，对于我们今天要说的内容，知道上述五种日志等级就够了。
三、常用日志插件 Log4j（1999年诞生）
Log4j 是Java领域中最早的流行日志框架之一。它由Ceki Gülcü开发，并后来由Apache软件基金会接管。Log4j 提供了灵活的配置选项、多种输出目的地、日志级别和分层日志体系。尽管Log4j 1在其时代取得了巨大的成功，但在性能和某些功能方面存在限制，因此后来演化为Log4j 2。
SLF4J（2004年诞生）
严格来说，SLF4J（Simple Logging Facade for Java）并不算一个插件，而是Ceki Gülcü开发的一个日志门面接口。它为Java应用程序提供了统一的日志抽象，使开发人员可以使用一致的API进行日志记录，而不需要直接依赖于特定的日志实现。SLF4J 可以与多种底层日志框架（如Logback、Log4j 2、java.util.logging等）结合使用。另外，搜索公众号Linux就该这样学后台回复“猴子”，获取一份惊喜礼包。
Logback（2009年诞生）
Logback 是Ceki Gülcü开发的日志框架，他也是Log4j的作者。Logback 是Log4j 1的后续版本，旨在提供更高性能、更灵活的配置和现代化的日志解决方案。Logback 支持异步日志记录、多种输出格式、灵活的配置以及与SLF4J紧密集成。
Log4j 2（2014年诞生）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4954d9ada009d6bffe382f53a609e6bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daaed168139403cb075c56eb98a52125/" rel="bookmark">
			Java中的HashTable：快速、高效的数据存储与检索方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在计算机科学中，散列表（HashTable）是一种常见的数据结构，它通过将键映射到值的方式将大量数据集中存储。哈希表通常是基于数组实现的，通过在数据上执行哈希函数来确定值的存储位置。
Java中的HashTable是一种线程安全的哈希表实现，它可以高效地存储和快速查找数据。本文将介绍Java中的HashTable的实现原理、常用方法和测试用例。
摘要 本文将介绍Java中的HashTable的实现原理、常用方法和测试用例。首先，我们将介绍哈希表的实现原理和哈希函数的作用。然后，我们将介绍Java中的HashTable的实现和使用方式，包括添加、查找和删除元素等常用方法。最后，我们将介绍如何编写测试用例来验证代码的正确性，以及如何优化哈希函数以提高性能。
哈希表的实现原理 哈希表是一种基于数组实现的数据结构，它通过在数据上执行哈希函数来确定值的存储位置。一个哈希函数可以将键映射到一个唯一的数组索引。当有多个键映射到相同的索引时，哈希表会使用链表将它们存储在同一位置。
哈希表的实现原理可以概括如下：
对于每个键，计算哈希值。哈希值是一个整数，它表示键的唯一性。
使用哈希函数将哈希值映射到一个数组索引。
在该索引位置的链表中查找键的值。
如果找到键，返回对应的值。否则，返回null。
Java中的HashTable的实现 Java中的HashTable是一种线程安全的哈希表实现，它可以高效地存储和快速查找数据。HashTable实现了Map接口，它存储键值对。
HashTable的常用方法包括：
put(Object key, Object value)：将指定的键值对添加到哈希表中。
get(Object key)：返回指定键的值。
remove(Object key)：从哈希表中删除指定键的值。
containsKey(Object key)：如果哈希表包含指定键，则返回true。
containsValue(Object value)：如果哈希表包含指定值，则返回true。
keySet()：返回键的集合。
values()：返回值的集合。
entrySet()：返回包含键值对的集合。
下面是Java中使用HashTable的示例代码：
java 复制代码 package com.example.demo.javaTest.map; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; import java.util.Hashtable; import java.util.Map; /** * @Date 2023-09-09 21:20 */ @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class HashTableTest { @Test public void testHashTable() { Map&lt;String, Integer&gt; ht = new Hashtable&lt;&gt;(); ht.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daaed168139403cb075c56eb98a52125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75502eca691e412cf77e3bfb24e3808c/" rel="bookmark">
			2023 华为OD机试备考攻略 以及题库目录分值说明 考点说明 （A卷&#43; B卷）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD在线刷题OJ 全新华为OD在线刷题平台登场！解锁上岸华为OD的终极秘籍！
亲爱的华为OD候选人们，你们期待已久的刷题平台终于来了！全新的华为OD机试在线刷题平台已经上线，为你们提供了一个全新的学习和提升华为OD机考编程技能的机会！无论你是初学者还是有经验的程序员，相信这个平台将成为你们上岸华为OD的终极秘籍！
【华为OD在线刷题OJ-点击立即开始刷题】)
华为OD统一考试A卷+B卷 新题库说明 2023年5月份，华为官方已经将的 2022/0223Q(1/2/3/4)统一修改为OD统一考试（A卷）和OD统一考试（B卷）。
你收到的链接上面会标注A卷还是B卷。请注意：根据反馈，目前大部分收到的都是B卷。但是仍有概率抽到A卷。
A卷对应2023的新题库（2022Q4 20223Q1） B卷对应20022部分考题以及新出的题目
专栏：2023华为OD机试(A卷+B卷)（C++JavaJSPy）
题库目录: 【华为OD统一考试B卷 】 题库目录-分值说明/在线刷题（最新版本-0901）
华为OD（人力外包）介绍 背景 过去，华为的"项目外包"主要针对非核心业务岗位，由于人员交付能力有限且稳定性不高，效果并不理想。为了解决更为核心的业务问题，华为于2019年开始探索并实行新的研发"人力外包"模式。这种模式按准雇员标准进行招聘，由业务部门负责培养和管理，对于绩效优秀且能力突出的人才提供转正式员工通道。
现状 目前，华为的OD（人力外包）只开放软件研发岗位，包括开发、测试、算法、大数据等职位。目前在职OD人数已经超过3万人。从实际接触的部门情况来看，每个产品线的OD比例不尽相同，有些部门的OD比例在20%以下，有些可以达到50%，甚至有些部门超过80%（具体比例受部门招聘要求、指标数量和OD基数等因素的影响）。
OD详情 人力外包
签约方为外企德科/科锐国际（人力服务公司）。劳动合同期为4年，试用期为6个月。 员工关系
合同管理、五险一金、考勤发薪由外企德科/科锐国际负责。定级定薪、员工培训、工作安排、绩效评比和晋升等由华为负责。 工作关系
OD员工与正式员工一起在华为研究所办公。工作内容基本没有差异，不存在核心非核心区别对待。主管和导师都是华为正式员工。 薪资结构 基本工资：基本工资是员工的固定薪资部分，占据薪资结构的主要部分。具体数额根据员工级别和参考范围确定，参考范围为10,000至40,000元。
绩效工资：绩效工资是根据员工的绩效表现而确定的一部分薪资。绩效工资占比较小，但是稳定可获得。绩效工资的发放根据绩效等级划分，一般分为A级和B级，A级可获得4个月绩效工资，B级可获得2个月绩效工资。
年终奖：年终奖是每年发放的一笔额外薪资，根据员工的绩效等级划分。一般来说，A级绩效可获得4个月年终奖，B级绩效可获得2个月年终奖。
试用期工资：在试用期内（6个月），员工的工资不打折，按照B级绩效发放绩效工资。试用期内的绩效评定分为A、B、C三档，主要集中在A和B档，C档的概率较小。绩效评定与正式员工分开进行，每半年进行一次评定。
五险一金：五险一金的缴纳基数按照员工的基本工资确定。公积金的缴纳比例在5%至12%之间，北京杭州的 od 公积金比例是 12%，武汉是 8%，其余均为 5%。。
福利补贴包括：
带薪年假入职和年度免费体检免费夜宵班车或加班打车免费下午茶节假日礼品等 工作时间 上班时间：上班时间具有一定的弹性，早上8:30至9:30之间可以灵活安排到岗时间，以适应员工的个人需求和交通情况。
午休时间：午休时间为12:00至14:00，员工可以在这段时间内休息和用餐。
下班时间：下班时间为17:30至18:30，具体时间一般跟所在的项目组安排一致。员工可以根据工作进度和任务完成情况，灵活安排下班时间，重点关注工作产出。
工作日安排：一般情况下，周一、周二和周四可能需要补工时，工作时间延长至晚上20:30左右。而周三和周五的工作时间为正常时间，无需补工时。这样可以确保每天的工时平均达到8小时。工时不需要补且无加班需求的情况下，员工可以自行灵活安排下班时间。
加班情况：月末的周六会固定加班，员工加班时将获得双倍工资。除此之外，根据业务需求，如果需要员工加班，员工可以申请加班，并按照国家规定支付加班费。
工作地点 北京：
华为北研所：北京市海淀区北清路156号中关村环保科技示范园 上海：
华为上研所：上海市浦东新区新金桥路2222号曼卡科技园：上海市浦东新区唐陆公路901号东方万国企业中心：上海市浦东新区金桥镇新金桥路1599号金桥万创中心：上海市浦东新区金苏路200号中宝盛达中心：上海市浦东新区金沪路951号青浦国际会展中心：上海市青浦区徐泾镇崧泽大道333号 深圳：
华为深研所：广东省深圳市龙岗区五和大道与张衡路交汇处坂田基地天安云谷：广东省深圳市龙岗区坂田街道岗头社区雪岗北路2018号安托山基地：广东省深圳市福田区北环大道万科瑧山府北侧约30米 东莞：
华为松研所：广东省东莞市松山湖科技产业园区环湖路99号南方工厂：广东省东莞市新城大道2号 杭州：
华为杭研所：浙江省杭州市滨江区江虹路410号海威大厦：浙江省杭州市滨江区滨康路101号 苏州：
华为苏研所：江苏省苏州市苏州工业园区江韵路9号 南京：
华为南研所：江苏省南京市雨花台区软件大道101号 成都：
华为成研所：四川省成都市郫都区西源大道1899号 武汉：
华为武研所：湖北省武汉市江夏区东湖高新区九峰三路207号 西安：
华为西研所：陕西省西安市雁塔区锦业路127号数字经济产业园：陕西省西安市长安区普新一路与普丰路交接口 长沙：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75502eca691e412cf77e3bfb24e3808c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6baa028f2111d981e2b94343207746cc/" rel="bookmark">
			瓦片地图下载工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收费工具，学生党勿扰，白嫖党勿扰
收费金额：500元
MyChat：wangjianjun1018
瓦片地图下载工具 概述操作查看地图 下载链接说明后续 概述 最近花费一点时间，研究瓦片地图。在网上找了好久，有好多下载的提供商，收费也真是高。而且，这些瓦片的图源都是来自谷歌地图服务器。内心不忍吐槽一下，谷歌到底养活了多少家国内公司啊…貌似扯远了。
操作 查看地图 (1) 下载的部分的0-19级地图
(2)某一级别的瓦片地图
(3) 地图下载完后，通过软件打开浏览
下载地图
下载的地图，有4种图源，分别是OSM,微软地图，谷歌地图，和未知图源（我取名为水地图），其中的微软地图和谷歌地图，有三种形式的图源，分别是普通地图，卫星地图，和混合地图。
(1)osm地图浏览
(2)微软地图浏览
(3)谷歌地图1
(4) 谷歌地图2
(5) 水地图
下载链接 源码：https://download.csdn.net/download/wocanimei007/85580496
试用：https://download.csdn.net/download/wocanimei007/85681624
说明 源码花费一定的心血，本来打算免费使用的，但是很多伸手党，下载源码，谢谢都不说一声，很不爽。
注意：osm，微软地图都可以直接下载，但是谷歌地图需要翻墙，你懂的。
后续 新增天地图下载
天地图下载，需要去官网申请key。程序内部有一个已经申请好的key。由于天地图服务器的限制，对于普通开发者，每天只能下载1万张瓦片。
下载链接：https://download.csdn.net/download/wocanimei007/85681470
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b76d006d83c40420ad129541efea2cf/" rel="bookmark">
			2023下半年最新华为OD 机试 与 面试 指南，独家总结上岸技巧，答读者问！必看！【万字长文，建议收藏】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为OD在线刷题OJ 全新华为OD在线刷题平台登场！解锁上岸华为OD的终极秘籍！
亲爱的华为OD候选人们，你们期待已久的刷题平台终于来了！全新的华为OD机试在线刷题平台已经上线，为你们提供了一个全新的学习和提升华为OD机考编程技能的机会！无论你是初学者还是有经验的程序员，相信这个平台将成为你们上岸华为OD的终极秘籍！
【华为OD在线刷题OJ-点击立即开始刷题】)
华为OD统一考试A卷+B卷 新题库说明 2023年5月份，华为官方已经将的 2022/0223Q(1/2/3/4)统一修改为OD统一考试（A卷）和OD统一考试（B卷）。
你收到的链接上面会标注A卷还是B卷。请注意：根据反馈，目前大部分收到的都是B卷。但是仍有概率抽到A卷。
A卷对应2023的新题库（2022Q4 20223Q1） B卷对应20022部分考题以及新出的题目
专栏：2023华为OD机试(A卷+B卷)（C++JavaJSPy）
题库目录: 【华为OD统一考试B卷 】 题库目录-分值说明/在线刷题（最新版本-0901）
华为OD（人力外包）介绍 背景 过去，华为的"项目外包"主要针对非核心业务岗位，由于人员交付能力有限且稳定性不高，效果并不理想。为了解决更为核心的业务问题，华为于2019年开始探索并实行新的研发"人力外包"模式。这种模式按准雇员标准进行招聘，由业务部门负责培养和管理，对于绩效优秀且能力突出的人才提供转正式员工通道。
现状 目前，华为的OD（人力外包）只开放软件研发岗位，包括开发、测试、算法、大数据等职位。目前在职OD人数已经超过3万人。从实际接触的部门情况来看，每个产品线的OD比例不尽相同，有些部门的OD比例在20%以下，有些可以达到50%，甚至有些部门超过80%（具体比例受部门招聘要求、指标数量和OD基数等因素的影响）。
OD详情 人力外包
签约方为外企德科/科锐国际（人力服务公司）。劳动合同期为4年，试用期为6个月。 员工关系
合同管理、五险一金、考勤发薪由外企德科/科锐国际负责。定级定薪、员工培训、工作安排、绩效评比和晋升等由华为负责。 工作关系
OD员工与正式员工一起在华为研究所办公。工作内容基本没有差异，不存在核心非核心区别对待。主管和导师都是华为正式员工。 薪资结构 基本工资：基本工资是员工的固定薪资部分，占据薪资结构的主要部分。具体数额根据员工级别和参考范围确定，参考范围为10,000至40,000元。
绩效工资：绩效工资是根据员工的绩效表现而确定的一部分薪资。绩效工资占比较小，但是稳定可获得。绩效工资的发放根据绩效等级划分，一般分为A级和B级，A级可获得4个月绩效工资，B级可获得2个月绩效工资。
年终奖：年终奖是每年发放的一笔额外薪资，根据员工的绩效等级划分。一般来说，A级绩效可获得4个月年终奖，B级绩效可获得2个月年终奖。
试用期工资：在试用期内（6个月），员工的工资不打折，按照B级绩效发放绩效工资。试用期内的绩效评定分为A、B、C三档，主要集中在A和B档，C档的概率较小。绩效评定与正式员工分开进行，每半年进行一次评定。
五险一金：五险一金的缴纳基数按照员工的基本工资确定。公积金的缴纳比例在5%至12%之间，北京杭州的 od 公积金比例是 12%，武汉是 8%，其余均为 5%。。
福利补贴包括：
带薪年假入职和年度免费体检免费夜宵班车或加班打车免费下午茶节假日礼品等 工作时间 上班时间：上班时间具有一定的弹性，早上8:30至9:30之间可以灵活安排到岗时间，以适应员工的个人需求和交通情况。
午休时间：午休时间为12:00至14:00，员工可以在这段时间内休息和用餐。
下班时间：下班时间为17:30至18:30，具体时间一般跟所在的项目组安排一致。员工可以根据工作进度和任务完成情况，灵活安排下班时间，重点关注工作产出。
工作日安排：一般情况下，周一、周二和周四可能需要补工时，工作时间延长至晚上20:30左右。而周三和周五的工作时间为正常时间，无需补工时。这样可以确保每天的工时平均达到8小时。工时不需要补且无加班需求的情况下，员工可以自行灵活安排下班时间。
加班情况：月末的周六会固定加班，员工加班时将获得双倍工资。除此之外，根据业务需求，如果需要员工加班，员工可以申请加班，并按照国家规定支付加班费。
工作地点 北京：
华为北研所：北京市海淀区北清路156号中关村环保科技示范园 上海：
华为上研所：上海市浦东新区新金桥路2222号曼卡科技园：上海市浦东新区唐陆公路901号东方万国企业中心：上海市浦东新区金桥镇新金桥路1599号金桥万创中心：上海市浦东新区金苏路200号中宝盛达中心：上海市浦东新区金沪路951号青浦国际会展中心：上海市青浦区徐泾镇崧泽大道333号 深圳：
华为深研所：广东省深圳市龙岗区五和大道与张衡路交汇处坂田基地天安云谷：广东省深圳市龙岗区坂田街道岗头社区雪岗北路2018号安托山基地：广东省深圳市福田区北环大道万科瑧山府北侧约30米 东莞：
华为松研所：广东省东莞市松山湖科技产业园区环湖路99号南方工厂：广东省东莞市新城大道2号 杭州：
华为杭研所：浙江省杭州市滨江区江虹路410号海威大厦：浙江省杭州市滨江区滨康路101号 苏州：
华为苏研所：江苏省苏州市苏州工业园区江韵路9号 南京：
华为南研所：江苏省南京市雨花台区软件大道101号 成都：
华为成研所：四川省成都市郫都区西源大道1899号 武汉：
华为武研所：湖北省武汉市江夏区东湖高新区九峰三路207号 西安：
华为西研所：陕西省西安市雁塔区锦业路127号数字经济产业园：陕西省西安市长安区普新一路与普丰路交接口 长沙：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b76d006d83c40420ad129541efea2cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f61ba8144374df0ceae2d5849692e12e/" rel="bookmark">
			华为OD机试备考攻略 以及题库目录分值说明 考点说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为题库说明 2022与2023题库的区别 华为OD机试的题库是季度更新的（Q1\Q2\Q3\Q4）。笔者专栏的题库分为2023和2022。
2023的题库是包括2022.11（Q4第四季度）之后以及2023年的题库。
2022的题库是包括2022.11（Q4第四季度）之前题库。
支持的语言 目前大部分题 使用C++ Java JavaScript 以及python实现。
部分题目，使用不同语言实现不同的思路。
2022题库是否还有价值？ 有：老题库注重基础，难度稍低。拿来练手可以了解华为OD的一些套路。
无：根据前方机考的小伙伴反馈，基本不考老题库。
题库目录 2023新题库-100分 序号题目考点 or 实现通过率1预订酒店回溯算法 / 组合问题/排序100%2最小调整顺序次数 逻辑分析100%3整理扑克牌逻辑分析100%4查找重复代码动态规划 / 最长公共子串100%5机房布局区间问题 / 区间交集100%6最左侧冗余覆盖子串滑动窗口 / 尺举法未知7查找单入口空闲区域回溯法/DFS未知8任务总执行时长逻辑分析100%9货币单位换算逻辑分析100%10投篮大赛逻辑分析100%11 最大利润贪心算法未知12通信误码字符串，数组100%13 密室逃生游戏逻辑分析100%14最多获得的短信条数/云短信平台优惠活动动态规划 / 完全背包100%15匿名信逻辑分析未知16任务调度优先队列未知17优选核酸检测点区间问题未知18挑选字符串逻辑分析/字符串处理100%19开心消消乐BFS/并查集100%20 最大报酬动态规划 / 01背包100%21最短木板长度贪心思维100%22完美走位滑动窗口 / 尺举法100%23处理器问题回溯算法 / 组合问题未知24不含101的数数位DP100%25租车骑绿岛贪心思维/逻辑分析100%26等和子数组最小和动态规划/回溯算法100%28模拟商场优惠打折逻辑分析未知29 对称美学逻辑分析/分治递归100%30二元组个数逻辑分析/数据结构100%31积木最远距离 相同数字的积木游戏逻辑分析/数据结构未知32 计算数组中心位置大数问题100%33最长的密码逻辑分析/字符串查找100%34端口合并逻辑分析/数据结构未知36箱子之字形摆放逻辑分析100%37新学校选址逻辑分析/数学问题100%38 打印机队列优先队列100%39星际篮球争霸赛 / MVP争夺战回溯算法/动态规划100%40真正的密码逻辑100%41 机器人 可活动的最大网格点数目BFS100%43日志首次上报最多积分动态规划100%44字符串重新排序字符串，数组，排序100%45总最快检测效率数据结构 / 优先队列未知46 单向链表中间节点数据结构100%47异常的打卡记录字符串，数组未知48 静态扫描 / 采用合理的缓存策略，最少需要的金币数贪心算法100%49快递投放问题逻辑分析未知50 优秀学员统计排序未知51猜字谜字符串，数组100%52最大连续文件之和 / 区块链文件转储系统滑动窗口100%53发现新词的数量/识图谱新词挖掘滑动窗口100%54日志限流二分查找未知56递增字符串动态规划100%57统一限载货物数最小值优先队列100%58最多颜色的车辆滑动窗口100%59 服务中心选址二分查找未知60最优资源分配逻辑分析100%62找数字、找等值元素逻辑分析100%63新员工座位 、统计友好度最大值逻辑分析未知64网上商城优惠活动 / 模拟商场优惠打折2逻辑分析未知65最快到达医院的方法数学问题100%66最长回文字符串字符串，数组100%人数最多的站点/小火车最多人时所在园区站点最大重叠区间个数100%68天然蓄水库双指针未知69组合出合法最小数逻辑分析100%70linux发行版的数量并查集/回溯法100%71最多几个直角三角形回溯算法 / 组合问题未知72单词倒序逻辑分析100%73寻找相似单词字符串，数组100%75预订酒店二分查找/排序未知76简单的自动曝光、平均像素值逻辑分析未知77获取最大软件版本号字符串，数组100%数组合并数据结构未知 2023新题库-200分 序号题目考点 or 实现通过率1士兵过河动态规划未知2二进制差异数位运算100%3简单的解压缩算法回溯算法100%4计算网络信号、信号强度图的BFS100%6 去除多余空格逻辑分析未知7优雅子数组动态规划 / 前缀和未知8 删除重复数字后的最大数字栈100%9数字加减游戏逻辑分析100%10最差产品奖滑动窗口10011分奖金栈/暴力分奖金12 查找树中元素 查找二叉树节点DFS未知14最优高铁城市修建方案图论 / 最小生成树未知15计算快递主站点并查集/回溯算法100%16无向图染色回溯算法 / 组合问题/无向图100%17最大化控制资源成本数据结构/小顶堆100%18 连接器问题区间问题 / 区间合并/贪心算法未知19最大平分数组动态规划/回溯算法未知20区间交叠问题区间问题 / 区间合并/贪心算法100%21垃圾短信识别逻辑分析100%22上班之路/是否能到达公司深度优先搜索DFS100%23最多等和不相交连续子序列区间问题未知24查找充电设备组合/最接近最大输出功率的设备动态规划 / 01背包100%25荒地建设电站 /区域发电量统计动态规划 / 前缀和100%26探索地块建立动态规划 / 前缀和100%27快速开租建站图论 / 拓扑排序100%.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f61ba8144374df0ceae2d5849692e12e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adcc8a5d5d6a11bd99192691b4acf78c/" rel="bookmark">
			ESP8266&#43;RS485无线数传电台通讯问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目背景 上一次我使用了51单片机控制485通信，发现单片机烧写程序略微复杂且容易出bug，读写数据也不够方便，然后就来尝试使用ESP系列Arduino来做一个设计。
二、硬件准备 1、ESP8266 nodemcu系列
2、工业级自动流向TTL转485模块
3、无线数传电台RS485（已连接相对应的设备）
三、程序编写 #include &lt;SoftwareSerial.h&gt; float proportion; unsigned char item4[8] = { 0x01, 0x03, 0x00, 0x01, 0x00, 0x05, 0xf5, 0xcb }; //发送命令 String data = ""; // 接收到的16进制字符串 SoftwareSerial mySerial(D5,D6);//定义8266软串口RX为D5，TX为D6 int sensorValue(int x, int y) //处理接收到的数据 { int t = 0; t = x * 256; t = t + y; return t; } void setup() { mySerial.begin(9600); Serial.begin(9600); } void loop() { delay(2000); // 放慢输出频率 // 发送命令 mySerial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adcc8a5d5d6a11bd99192691b4acf78c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdab2b50eaf7611563dbe78de03fa93f/" rel="bookmark">
			pybind11 调用 C&#43;&#43; 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、配置c++环境（这里我使用的vscode，安装的c++扩展能自动寻找编译器路径） 2、遇到的两个问题： 1、Microsoft Visual C++ 14.0 is required： 需要去visual studio 官网下载这个exe文件，安装时勾选c++1.43（这里要求14.0以上）
2、#include "stdafx.h"无法直接导入，需要替换成以下 #include &lt;stdio.h&gt; #include &lt;tchar.h&gt; 3、下载pybind11 git clone https://github.com/pybind/pybind11.git 4、编写setup_pybind.py # -*- coding: utf-8 -*- """ Created on Tue May 12 17:32:25 2020 @author: dell """ #Filename: setup.py from setuptools import setup, Extension functions_module = Extension( name='launch_camera', sources = ['D:\pyprojects\inspectis-sdk\Win32\ControlSoftwareExample.cpp'], include_dirs = ['D:\pyprojects\pybind11\include'] ) setup(ext_modules = [functions_module]) sources为需要编译的cpp文件，include_dirs为pybind11下的include文件
5、运行编译脚本 cd到setup_pybind.py目录下
python setup_pybind.py build_ext --inplace 6、导入外部库（尚未解决） 一直报错:ControlSoftwareExample.obj : error LNK2001: 无法解析的外部符号 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdab2b50eaf7611563dbe78de03fa93f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3facd1ebe3e19f262d52300d92b0588e/" rel="bookmark">
			Kubernetes 部署RocketMQ高可用集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes 部署RocketMQ高可用集群 导言RocketMQ 常用的部署模式如下单 Master 模式多 Master 多 Slave-异步复制模式 离线镜像制作1.安装 Go 1.162.制作 RocketMQ Operator Image获取 RocketMQ Operator制作 RocketMQ Operator Image 3.制作 RocketMQ Broker Image制作 RocketMQ Name Server Image根据官方已有镜像制作离线镜像(和上面的步骤二选一)制作 RocketMQ Console Image 准备单 Master RocketMQ 部署方案涉及的离线镜像单 Master 模式部署思路梳理资源配置清单GitOps部署资源部署资源 (分步式，二选一)部署资源 (一键式，二选一)验证 清理资源 多 Master 多 Slave-异步复制模式部署思路梳理获取 RocketMQ Operator准备资源配置清单部署 RocketMQ Operator (自动)部署 RocketMQ Operator (首选手动)部署 RocketMQ 集群验证清理资源清理 RocketMQ Cluster清理 RocketMQ Operator清理存储卷 扩容 NameServer特别说明扩容 Broker 导言 在网上有很多使用k8s部署rocketmq集群的文章，但是都不能很好的做到高可用集群的扩展和缩容，因此我在部署的时候自己整理了这样一份笔记，并且已经在生产环境使用。
关于RocketMQ，是在Spring Cloud Alibaba 全家桶之下的一款典型的分布式架构下的消息中间件产品，使用异步通信方式和发布订阅的消息传输模型。RocketMQ的基础使用，以及线上会碰到的问题，以及高级用法在这里就不做过多的介绍了，如果是刚入门的同学，可以去看我之前的一篇文章RocketMQ使用详解以及高并发系统实践问题
如果你要Kubernetes 部署RocketMQ高可用集群，那么前提就是你先得有一个k8s的集群环境，至于怎么部署k8s高可用集群，可以参考一下的文章，相信你自己就可以搭建k8s高可用集群
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3facd1ebe3e19f262d52300d92b0588e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f0f7efa92568e89c5ccd7428f86f2c/" rel="bookmark">
			【Nuxt3】Vue3 &#43; Element-plus 打包后报错 @popperjs/core
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
更新 Element-plus 后，运行时需要安装 @popperjs/core 依赖。
如果正常执行 npm install @popperjs/core ，那么，打包时，就会出现下面报错。 Named export ‘placements’ not found. The requested module ‘@popperjs/core’ is a CommonJS module, which may not support all module.exports as named exports. CommonJS modules can always be imported via the default export, for example using: import pkg from ‘@popperjs/core’; const { placements, createPopper } = pkg;
解决：
把 node_modules 删除，在 package.json 把 “@popperjs/core” 版本号改为 "@popperjs/core": "npm:@sxzz/popperjs-es@^2.11.7" （esm 的包）重新 npm install，即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f0f7efa92568e89c5ccd7428f86f2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28787cbe1a40af6c87afd865b914fcab/" rel="bookmark">
			vue 项目报Uncaught runtime errors: 导致项目崩溃
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用vue-cli新建的vue项目，当出现编译错误或警告或接口报错时，在浏览器中显示全屏覆盖导致程序崩溃，如下图，此报错在生产环境下并不会出现
通过看控制台，找到关键词webpack
可以明显的看出来是webpack-dev-server弄出来的
解决办法
在vue.config.js中添加如下配置 module.exports = defineConfig({ transpileDependencies: true, devServer: { port: ..., client: { overlay: false }, }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/351af89875c6047f68f8e44b0d030a4b/" rel="bookmark">
			SSM框架的考研助手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌在职Java研发工程师、专注于程序设计、源码分享、技术交流、专注于Java技术领域和毕业设计✌
温馨提示：文末有 CSDN 平台官方提供的老师 Wechat / QQ 名片 :)
项目名称 SSM框架的考研助手
演示视频 SSM框架的考研助手_哔哩哔哩_bilibili
系统截图 环境需要 1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 5.数据库：MySql 5.7版本；
6.是否Maven项目：否；
技术栈 1. 后端：Spring+SpringMVC+Mybatis
2. 前端：JSP+CSS+JavaScript+jQuery
使用说明 1. 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
2. 使用IDEA/Eclipse/MyEclipse导入项目，Eclipse/MyEclipse导入时，若为maven项目请选择maven;
若为maven项目，导入成功后请执行maven clean;maven install命令，然后运行；
3. 将项目中springmvc-servlet.xml配置文件中的数据库配置改为自己的配置;
4. 运行项目，在浏览器中输入http://localhost:8080/ 登录
POM依赖: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/351af89875c6047f68f8e44b0d030a4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3bd8285159177a5415e8d2a6ba15509/" rel="bookmark">
			PyPDF2.errors.DeprecationError: reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Us
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyPDF2版本在3.0.0及之后的版本对旧版本的很多函数进行修改，以下展示部分关键函数的修改示例
第一个错误提示：
PyPDF2.errors.DeprecationError: reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
源代码出错部分：
pdf_reader = PyPDF2.PdfFileReader(pdf_file) for page_num in range(pdf_reader.getNumPages()): page = pdf_reader.getPage(page_num) 针对reader.getNumPages进行修改后如下：
pdf_reader = PyPDF2.PdfFileReader(pdf_file) for page_num in range(len(pdf_reader.pages)): page = pdf_reader.getPage(page_num) 再次运行代码出现第二个错误提示：
PyPDF2.errors.DeprecationError: reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.
针对reader.getPage(pageNumber)进行修改后如下：
pdf_reader = PyPDF2.PdfFileReader(pdf_file) for page_num in range(len(pdf_reader.pages)): page = pdf_reader.pages[page_num] 即可成功运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0820701ab6235af9ee600affc53a386a/" rel="bookmark">
			对大文件压缩包分割和恢复的方法_python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 某次需要将大的压缩包分割传输，并恢复。找到了一段有用的python程序。
这个软件包可以压缩和分割大文件。它从一个根目录开始，遍历子目录，并扫描其中的每个文件。如果某个文件的大小超过了阈值大小，那么它们会被压缩和分割成多个归档文件，每个归档文件的最大大小为分区大小。压缩/分割适用于任何文件扩展名。
举例：
对于目录
$ tree --du -h ~/MyFolder └── [415M] My Datasets │ ├── [6.3K] Readme.txt │ └── [415M] Data on Leaf-Tailed Gecko │ ├── [ 35M] DatasetA.zip │ ├── [ 90M] DatasetB.zip │ ├── [130M] DatasetC.zip │ └── [160M] Books │ ├── [ 15M] RegularBook.pdf │ └── [145M] BookWithPictures.pdf └── [818M] Video Conference Meetings ├── [817M] Discussion_on_Fermi_Paradox.mp4 └── [1.1M] Notes_on_Discussion.pdf 使用
$ python3 src/main.py --root_dir ~/MyFolder 目录变成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0820701ab6235af9ee600affc53a386a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee5331092fd7c380dbd8c8883ae0db9/" rel="bookmark">
			python pytorch教程-带你从入门到实战（代码全部可运行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python pytorch教程-带你从入门到实战（代码全部可运行） 其实这个教程以前博主写过一次，不过，这回再写一次，打算内容写的多一点，由浅入深，然后加入一些实践案例。
下面是我们的内容目录：
1.先从数据类型谈起
1.1 如何生成pytorch的各种数据类型？
1.2 pytorch的各种数据类型有哪些属性？
1.3 pytorch的各种数据类型有哪些函数操作？
2.数据类型和其操作谈完，选择某一个方向开始学习和实践（深度学习）。
2.1 求导
2.2 损失函数
2.3优化器
2.4线性回归代码实战
2.5 卷积神经网络实战
2.6 神经网络实战
2.7 RNN和LSTM实战
1.先从数据类型谈起
那如果从数据类型谈起，我们就要从下面几个角度去谈：
1.1 如何生成pytorch的各种数据类型？
1.2 pytorch的各种数据类型有哪些属性？
1.3 pytorch的各种数据类型有哪些函数操作？
首先，我们知道pytorch是一个计算库，也有人说是深度学习库，那么计算库呢，肯定都是有自己的数据类型的。
另外pytorch都是围绕Tensors (张量)来进行计算的，Tensors 类似于 NumPy 的 ndarrays ，同时 Tensors 可以使用 GPU 进行计算。ndarrays 是不可以的，且只能存储在cpu中，但是Tensor可以，Tensor其实就是用来进行各种计算的数据结构，存储数据，且有各种各样的操作，增删改查之类的。
所以我们先从pytorch数据类型开始讲解，没有自己的数据类型，就无从谈起。当然其实大家如果学过数据结构就会知道，现在基本上想开发大型系统还是小型系统，还是说想开发一些功能接口，像pytorch其实就是一个功能接口，我们都需要从最基本的类开始设计，pytorch的每一个数据类型其实就是一个类，这个类会定义他的一些基本的数据，定义他的一些函数操作，比如乘法、加法、减法、乘法、梯度更新。所以，我们看待pytorch的数据类型的时候，可以从类的角度去看待它。
下面我们看一张图：
上图呢其实就是表示出了python的五个个数据类型和pytorch的五个数据类型的对应关系，其实pytorhc应该还有更多的，但是一般情况下掌握上面四种就可以了，即使你是做深度学习的，也只需要掌握上面四个。
下面我们开始正文：
1.1 如何生成pytorch的各种数据类型？
生成pytorch的各种数据类型比较简单，当然也分为甚多情况下面我们一一介绍：
在开始1.1之前，我们需要提前讲一个函数，这部分本来应该是在1.3来说的。
这个函数就是type
代码示例如下：
运行结果会返回他的变量的数据类型，这个函数我们在后面会常用到。
（1）通过pytorch的函数生成数据类型
1.randn函数,返回一个包含了从标准正态分布中抽取的一组随机数的张量
import torch #使用torch函数生成torch数据类型 print(torch.randn(2,3)) print(torch.randn(2,3).type()) 输入结果如下：
这个函数返回FloatTensor的张量。
2.rand函数，这个函数看似和randn函数很像但是其实是由很大区别的。
print(torch.rand(2,3)) print(torch.rand(2,3).type()) 输出结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ee5331092fd7c380dbd8c8883ae0db9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be7bce7feb6e25c47ef22023fca6e80/" rel="bookmark">
			JDK8源码阅读环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 环境 jdk 版本：1.8.0_381
系统：macos 13.5.1 Intel
目的 学习 jdk8 源码，并能自定注释。
新建 java 工程 在 idea 中新建 java 工程，注意并非 maven 工程。
如下图：
完成后，如下图：
配置源码 src.zip 找到 jdk 安装目录下的 src.zip 文件，该文件即为源码压缩包。
如下图：
复制到 idea 解压 src.zip 压缩包，并将解压后的所有文件复制到新建的 java 工程。
解压后的文件如下图所示：
复制到 idea 耗时比较长，须耐心等待。注意不要直接通过finder（资源管理器）复制到对应的目录，因为在 idea 中复制会自动匹配包路径。
复制完成后如下图所示：
解决 tools 不存在 测试程序如下：
public class Main { public static void main(String[] args) { System.out.println("Hello world!"); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("name", "jay"); String name = (String) map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be7bce7feb6e25c47ef22023fca6e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4c40f7bb455299a19c77f4ed72c536/" rel="bookmark">
			STM32——一文完全读懂IIC通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 I2C基本概念+硬件线路+通信结构：I2C设备地址：I2C数据传输：I2C时钟速度和通信速度：I2C应答机制：I2C设备之间的冲突检测：I2C设备规格：主机读取数据IIC通信过程实际编程和应用：IO 口模拟 IIC 总线常见的I2C通信错误类型和故障排除方法使用IIC通信常见外设深入学习高级特性： I2C基本概念+硬件线路+通信结构： 概念
I2C是一种串行同步通信协议，用于在集成电路之间进行通信。
硬件路线
I2C使用两根线进行通信：串行数据线（SDA）和串行时钟线（SCL）。
通信结构
I2C使用主从结构，其中主设备发起通信并控制通信的节奏，从设备响应主设备的请求。从机通常不会主动给主机发送数据，一般为主机给从机发送读取指令后，从机才给主机发送数据。器件发送数据到总线上，则定义为发送器，器件接收数据则定义为接收器。主器件和从器件都可以工作于接收和发送状态。
不能在IIC通信总线上接入无限多个设备的原因：
1.地址冲突：在IIC总线上，每个设备都需要有一个唯一的地址。地址通常由设备的硬件引脚配置。然而，IIC地址字段的宽度有限，这意味着地址空间是有限的。当连接的设备数量超过地址空间的限制时，设备之间可能会出现地址冲突，导致通信失败。
2.总线负载：每个设备在IIC总线上会产生一定的负载。总线的负载是指总线上的所有设备对电流和电压的需求。当连接的设备数量增多时，总线负载会增加，可能导致通信速度变慢或信号失真。
3.电气特性：IIC总线的电气特性是有限的。总线上的设备之间通过开漏或开漏/开漏极性输出进行通信。然而，当连接的设备数量过多时，总线上的电气负载可能超过IIC规范的限制，导致通信错误或电气稳定性问题。
一些基础概念
SDA:双向串行数据线，数据既可以从主机发送到从机，也可以从从机发送到主机。
SCL:串行时钟线，驱动数据线的信号由 SCL 产生。
主机:主机产生串行时钟（SCL）控制总线的传输方向，并产生起始条件（占用总线）和停止条件（释放总线）。
从机：从机不会控制 SCL 线，从机可以发送数据给主机，但是从机永远不可能主动发送数据给主机。
发送器：发送数据的一方 接收器：接受数据的一方 。
仲裁器：解决多主机模式下竞争总线的问题。（通常情况下我们遇到的都是单主机模式，一主多从）
总线的空闲状态：SDA 和 SCL 都是高电平
重复起始条件（一般不提，跟普通通信一样但是能够切换主从机）：I2C（Inter-Integrated Circuit）协议中的重复起始条件（Repeated Start Condition）是一种特殊的通信方式，允许在不断开总线的情况下切换主机和从机，并进行连续的数据传输。
I2C设备地址： 主机如何能找到对应的从机与其进行通信？——设备地址
每个I2C设备都有一个唯一的7位或10位地址，用于在总线上唯一标识设备。
7（4、3）位地址模式下，可以有最多128个不同的设备地址（0x00至0x7F）。
10位地址模式下，可以有最多1024个不同的设备地址（0x000至0x3FF）。
器件地址包含固定地址（由厂家决定）和可编程地址（由使用者决定）——参考手册。
7位地址编码方式：
在7位地址编码方式下，从机设备的地址由7个位组成，范围是0x00至0x7F（0至127）。其中，最高位（MSB）通常由I2C总线规范中保留，用于指示读/写操作。读操作对应的最高位为1，写操作对应的最高位为0。
例如，一个从机设备的7位地址为0x50（十进制为80），对应的二进制表示是0101000（其中最高位为读/写位，0表示写操作）。
7位地址编码方式是I2C通信中最常用的方式，适用于大多数应用。
10位地址编码方式：
在10位地址编码方式下，从机设备的地址由10个位组成，范围是0x000至0x3FF（0至1023）。其中，最高两位（MSB）用于指示读/写操作和扩展地址位。
扩展地址位提供了更多的地址空间，可以用于连接更多的从机设备。在10位地址编码方式下，前六位（位7至位2）用于指定扩展地址位，后四位（位1至位0）用于指示读/写操作。
例如，一个从机设备的10位地址为0x235（十进制为565），对应的二进制表示是1000110101（前两位为读/写位和扩展地址位）。
10位地址编码方式相对较少使用，主要用于连接大量的从机设备。
如何寻址？
在I2C通信中，主机设备可以选择与多个从机设备进行通信，每个从机设备都有一个唯一的地址。通过在地址字节中指定正确的从机设备地址，主机可以选择与特定的从机设备进行通信。
7位和10位就是一个从机多一些。
I2C数据传输： I2C使用起始条件（Start Condition）和停止条件（Stop Condition）来标识数据传输的开始和结束。
数据传输可以是字节（Byte）级别的，也可以是多字节（Multi-Byte）级别的。
主设备通过将数据位推送到SDA线上发送数据，从设备通过SDA线接收数据。
I2C传输模式：
I2C支持两种传输模式：发送模式（Master Transmit）和接收模式（Master Receive）。
在发送模式中，主设备向从设备发送数据。
在接收模式中，主设备从从设备接收数据。
数据帧格式：
起始条件(占用总线)+数据位（8 位，发送方发出，一般为7位地址位和1位读写位）+应答位（1 位，接收到 1 个字节数据的 一方要回一个应答，0 有应答，1 非应答）+数据传输（8位）+停止条件(释放总线)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a4c40f7bb455299a19c77f4ed72c536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6655143d26f6f4ccc09b140f1cbcde7a/" rel="bookmark">
			某程序员哀叹工资低：二本计算机毕业，四年前端开发，年包才四十万！薪资真的和学历挂钩吗？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		‍
‍程序员的薪资和学历有关系吗？是不是学历越高薪资越高？
一个程序员发帖问大家：为什么大家的工资都那么高，毕业三五年就能达到年包六七十万？自己二本计算机专业，做了四年前端开发，如今年包四十多万就到顶了。
网友回答，这些毕业三五年就拿到六七十万的人，其学历百分之九十以上是985或者211，属于典型的学历优势，他们毕业两年左右就能拿到四五十万的年薪。楼主既然是普通二本毕业，就不要和他们比了。
有人说，这是因为他们毕业就进了一线大厂，一路卷赢绩效晋升跳槽才拿到这个年包。楼主的条件和职业路线无法与他们相比，不要给自己徒增烦恼。
也有人说，那些人的薪资未必是真的，只是会吹牛而已，楼主不必当真。
许多人安慰楼主，他的薪资水平已经是中等偏上水平，属于社会前5%的成功人士，如果不读计算机专业，现在年包连15万都没有，还是放平心态吧。
还有人觉得楼主分明是在凡尔赛，其他二本毕业生哪有这么高？那些高薪资的人不仅学历高，人优秀，还得在一线大厂里老加班。楼主和他们出身起点差距太大，能在965的小公司拿到这么多薪资，已经没几个人能与之比肩。
其实也并非所有高学历的人都能拿到高薪资，有人说自己985计算机专业，工作五年，现在年包还不到40万。
有人说自己985本硕，工作五年，总包才26万。
有人说自己985毕业，做了五年前端开发，年包也到不了60万。
有人说自己211本科，工作四年，就因为没学计算机，现在在一线城市年薪才20万。
还有两个一本毕业，工作五到七年的网友说自己年包20万左右。
不知道看完上面这些留言之后，楼主有没有感到安慰或者满足？学历高的人未必能拿到高薪资，同理，学历低的人薪资未必一定低，比如下面这位网友：
学历二本，工作四年，在几个一线大厂之间反复横跳，现在年包一百多万。
还有许多二本毕业的人，年包分别达到了80万、55万和42万。
一位三本毕业、工作五年的人年包达到55万。
网友总结：
1.确实存在薪资很高的人，但并不多，因为薪资低的人不会炫耀，薪资高的人才会。
2.有些人在吹牛。
3.学历不代表一切，但我国确实存在学历门槛。
4.工作前几年，人与人的差距并不大，只有不断完善自己，才能不断突破自己，等待机遇的到来。
5.特殊领域来了浪潮，工资就会高起来。
正如网友所说，薪资低的人不愿意谈论自己的薪资，薪资高的人才愿意炫耀。这就容易给人造成一种错觉：薪资高的人比比皆是。但实际上，真相却在沉默的大多数人中。
那么学历高的人薪资一定高吗？
未必。
关于学历的迷思存在已久，不可否认学历确实能代表人的部分能力，是现阶段一种比较公平的筛选标准，许多工作也存在学历门槛。但影响一个人薪资的因素有很多，学历、公司、能力、机遇、选择、努力，这些都是。如果学历高的人在收入一般的传统行业里，未必能比在高薪行业的低学历人群薪资高。如果运气好吃上了时代赋予的红利，那更是“好风凭借力，送我上青云”。
所以学历高的人不必沾沾自喜、盲目自信，发挥好自己的学历优势，为自己争取利益最大化才是正道。学历低的人也不必觉得自己低人一等，走出学校的大门，一切都将从头开始，选好赛道，埋头苦干，一样会拿到不错的薪资。
‍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f5d5e50636f1f63bf29abb430992e16/" rel="bookmark">
			使用Docker安装OpenResty并使用Lua脚本实现通过请求头动态路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、Docker安装OpenResty1.1 前置准备1.2 正式部署OpenResty1.2.1 启动OpenResty容器1.2.2 访问欢迎页面1.2.3 修改欢迎页面内容查看效果 二、通过Lua脚本实现通过请求头动态路由2.1 新增一个index2.html页面用于演示效果2.2 编写Lua脚本2.3 配置nginx.conf2.4 配置my.conf2.5 重新加载配置2.6 测试动态路由功能 前言 OpenResty(又称：ngx_openresty) 是一个基于 nginx的可伸缩的 Web 平台，由中国人章亦春发起，提供了很多高质量的第三方模块。
OpenResty 是一个强大的 Web 应用服务器，Web 开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种 C 以及 Lua 模块,更主要的是在性能方面，OpenResty可以 快速构造出足以胜任 10K 以上并发连接响应的超高性能 Web 应用系统。
360，UPYUN，阿里云，新浪，腾讯网，去哪儿网，酷狗音乐等都是 OpenResty 的深度用户。
OpenResty 简单理解成 就相当于封装了nginx,并且集成了LUA脚本，开发人员只需要简单的其提供了模块就可以实现相关的逻辑，而不再像之前，还需要在nginx中自己编写lua的脚本，再进行调用了。
一、Docker安装OpenResty 1.1 前置准备 1、创建挂载目录用于挂载配置文件和日志 mkdir -p /home/docker/openresty/nginx mkdir -p /home/docker/openresty/nginx/lua mkdir -p /home/docker/openresty/nginx/logs 2、拉取镜像 docker pull openresty/openresty 3、运行OpenResty容器先拷贝一些配置文件出来，用于宿主机挂载 # 运行openresty容器 docker run -it --name openresty -p 7000:80 openresty/openresty # 拷贝conf文件夹和html文件夹内容到宿主机 docker cp openresty:/usr/local/openresty/nginx/conf /home/docker/openresty/nginx/conf docker cp openresty:/usr/local/openresty/nginx/html /home/docker/openresty/nginx/html docker cp openresty:/etc/nginx/conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f5d5e50636f1f63bf29abb430992e16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d68c772eadfb931b85b4e9c0f5895ed/" rel="bookmark">
			面试官问你前端性能优化时，他想问什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直以来，前端性能优化都是面试过程中考察的热点题目。
相关的技术博客也层不出穷，我们总是能找到很多这样的文章，
从一个应用的各个层面开始分析，优化的种种手段，取得的种种效果。
往往篇幅越长，讲得越细，越受欢迎。
但在面试的时候，问这类问题时，候选人经常答得不尽人意，大部分人会把自己能想起来的优化措施，给背一遍。
背得越多越好，对于候选人自己说，内心也发虚，背完之后面试官毫无表情，因为这并不是他们想要的答案。
我们不妨从面试官的角度来思考。
面试官想考察什么？ 这个很容易考察候选人技术的宽度和广度。 可以从网络层面，打包层面，渲染层面问你对前端知识边界的了解。也可以就一个方面深入考察，比如http2,tcp的队头阻塞问题，webpack分包策略等等。 考察一个人做事的能力和思考的方式。 如果真的做过，那么是如何实施的，怎么和其他部门配合的，遇到了哪些问题，怎么解决的。如果没做过，那么会怎么来计划，推进这件事情。 不至于让候选人无话可说。 面试过程中很容易陷入一种，面试官问不出问题，候选人答不出问题的尴尬境地，这种性能优化的问题就可以让双方都有话可说。 当然，面试是门玄学，实际在面试过程中，根据面试官的状态，技术问题的侧重点也是不一样的。
那么作为候选人来说，如何回答，才能脱颖而出呢？
候选人如何回答？ 首先第一个疑问就是，做过没做过呗？
如实回答即可，做过就讲自己做的过程，没做过就讲自己准备怎么做。
大的原则就是：稍带广度，突出深度。
两种情况我们需要分类讨论。
如果做过 或者你要假装自己做过。
明确范围 那就要明确你要进行前端优化的场景范围，或者说是要优化的应用是哪个种类。
一个toC的纯H5，在浏览器和微信里使用一个toB的系统，或者说内部使用的运营系统嵌入app内使用的Hybrid公司官网跨端应用，小程序等等 以上每种类别优化的方式都是要根据场景采用的措施和手段是不一样的。
在回答的过程中，要明确这个基础。
比如说，对于一个离线加载的h5，应当从网络层面突出强调离线加载的好处，而不是说资源体积上的优化。
明确目标 性能优化需要目标，这个目标肯定是一个量化数据。
这就考察到了候选人对前端页面性能数据的掌握。
比如常问题目，你们在优化过程中，是如何制定目标，或者说如何排查阻塞问题的？
这个问题其实是在问你们如何采集页面数据。
性能数据采集分为两种 实验室性能数据采集 google的lightHouse 帮助我们分析页面的六大属性First contentful paint 首次内容绘制 (FCP)Largest contentful paint 最大内容绘制 (LCP)First input delay 首次输入延迟 (FID)Time to Interactive 可交互时间 (TTI)Total blocking time 总阻塞时间 (TBT)Cumulative layout shift 累积布局偏移 (CLS) 谷歌浏览器的性能面板，做具体链路阻塞的分析。 线上真实数据采集 线上接入入web-vitals做用户的数据收集接入sentry等一些三方SDK做性能数据的收集 确定方案 在分析整个前端页面性能优化的链路过程中，我们需要找到一个阻塞点，或者说切入点。
以一个app中webview中嵌套h5的场景来说
我们需要找到从用户点击跳转开始，到展现的过程中，经历了哪几个阶段，哪个阶段耗时多久，成为了阻塞页面的主要问题，然后针对问题再说实施了哪些优化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d68c772eadfb931b85b4e9c0f5895ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04864bcfedd834c28da2d25af62af5c/" rel="bookmark">
			ScanNet点云文件解读记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下文件中包含ScanNet点云数据
&lt; scanId &gt;_vh_clean_2.ply
&lt; scanId &gt;_vh_clean_2.labels.ply
&lt; scanId &gt;.aggregation.json
&lt; scanId &gt;_vh_clean_2.0.010000.segs.json
可用官方提供的python文件选择下载获取。网上很多内容只包含了点云数据下载和提取教程，没有对这几个文件做进一步详细的解读。
_vh_clean_2.ply
|—_vh_clean_2.ply
|—scans
|—scene0000_00
|—scene0000_00_vh_clean_2.ply
|—scene0000_01
|—scene0000_01_vh_clean_2.ply
… …
|—scans_test
|—scene0707_00
|—scene0707_00_vh_clean_2.ply
|—scene0708_00
|—scene0708_00_vh_clean_2.ply
… …
|—task
… …
_vh_clean_2.ply目录中ply文件就是ScanNetv2数据集的mesh数据，解析ply文件得到的每个点包含7个值 (x,y,z,r,g,b,a)， 坐标 (x,y,z)，颜色 (r,g,b)，透明度(a均为255)。
提取ply中的(x,y,z,r,g,b)即为所需点云数据。除了每个点的信息外，还包括每个表面所连接的三个点 (p1,p2,p3)。
_vh_clean_2.0.010000.segs.json
|—_vh_clean_2.0.010000.segs.json
|—scans
|—scene0000_00
|—scene0000_00_vh_clean_2.0.010000.segs.json
|—scene0000_01
|—scene0000_01_vh_clean_2.0.010000.segs.json
… …
|—scans_test
|—scene0707_00(empty)
|—scene0708_00(empty)
… …
|—task
… …
|—scannetv2-labels.combined.tsv
_vh_clean_2.0.010000.segs.json中的json文件包含对应点云数据中每个点的标号，测试数据scans_test文件夹下无内容（测试数据用于打榜，不提供标注）
"segIndices"中的所有标号数量与对应点云的点数目相同，相同的标号指向同一个原始类别。与 .aggregation.json中的数据匹配可以划分出每个点的标签
.aggregation.json
|—.aggregation.json
|—scans
|—scene0000_00
|—scene0000_00.aggregation.json
|—scene0000_01
|—scene0000_01.aggregation.json
… …
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b04864bcfedd834c28da2d25af62af5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/209507f218d37007d10b6d945f170c94/" rel="bookmark">
			C&#43;&#43;基础-类和对象（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、构造深入1.初始化列表2.隐式类型转换1.隐式类型转换2.explicit 3.委托构造 二、类的静态成员1.静态成员声明2.静态成员定义3.静态成员特性 三、重载运算符和类型转化1.关系及算数运算符重载2.递增递减运算符重载及如何区分3.赋值运算符重载4.重载输入输出运算符1.重载输入运算符2.重载输出运算符 5.函数匹配与重载运算符 四、类的其他细节1.const成员函数2.内部类内部类的特性 3.匿名对象4.拷贝时编译器的优化5.对封装的进一步认识 总结 前言 对于任何C++的类来说，构造函数都是其中重要的组成部分，我们已经在上篇介绍了类的一些基础知识，这篇我们将继续了解类的一些其他功能。并对之前讲解过的内容（如构造函数）进行一些更加深入的讨论。
一、构造深入 1.初始化列表 有时我们可以忽略数据成员初始化和赋值的差异，但并非总是这样。如果成员是const或者是引用的话，我们必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员进行初始化。
class STU { public: //错误，my_id和rid必须要被初始化 STU(int i) { id = i;//正确 my_id = i;//错误：不可以给const赋值 rid = i;//错误：rid没有被初始化 } private: int id; const int my_id; int&amp; rid; }; 我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值！！！
STU(int i):id(i),my_id(i),rid(id){}//显示的初始化引用和const成员 上面就是我们的初始化列表。
初始化列表： 以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个"成员变量"后面跟一个放在括号中的初始值或表达式。
注意：
每个成员变量在初始化列表中只能出现一次(初始化只能初始化一次)引用成员变量，const成员变量和自定义类型成员(且该类没有默认构造函数时）必须放在初始化列表位置进行初始化尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。成员变量在类中声明次序就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后次序无关 class A { public: A(int i):a(i),b(a){} void print() { cout &lt;&lt; "A:" &lt;&lt; a &lt;&lt; " B:" &lt;&lt; b &lt;&lt; endl; } private: int b; int a; }; int main() { A a(10); a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/209507f218d37007d10b6d945f170c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57210ae1b5be748733ad670721a25c9/" rel="bookmark">
			C语言指向二维数组的四种指针以及动态分配二维数组的五种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 应用场景可能指向二维数组的指针动态分配二维数组 应用场景 当二维数组作为结构成员或返回值时，通常需要根据用户传递的参数来决定二维数组的大小，此时就需要动态分配二维数组。
可能指向二维数组的指针 如果现在有一个二维数组a[3][2]，那么将有以下几种指针可以指向它：
//第一种：二维数组指针，指向整个二维数组 int (*ptr)[3][2]=&amp;a; //第二种：一维数组指针，指向二维数组第一行元素 int (*ptr)[2]=a;//or &amp;a[0] //第三种：int *型指针，指向二维数组第一行第一列的第一个元素 int *ptr=&amp;a[0][0];//or *a //第四种：int *型指针，指向二维数组第一行元素 int **ptr = calloc(3, sizeof(int *)); for (int i = 0; i &lt; 3; ++i) { *(ptr+i)=*(a+i); } 动态分配二维数组 方式一 int main(int argc, char **argv) { //初始化 int (*ptr)[3][2] = calloc(3 * 2, sizeof(int)); //赋值 for (int i = 0; i &lt; 3; ++i) { for (int j = 0; j &lt; 2; ++j) { (*ptr)[i][j]=j; } } //打印 for (int i = 0; i &lt; 3; ++i) { for (int j = 0; j &lt; 2; ++j) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e57210ae1b5be748733ad670721a25c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d2042a83f87174bcd240f2ae86eede3/" rel="bookmark">
			【华为OD机试真题】-2023(A&#43;B卷)【C&#43;&#43;,JAVA,Python】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A+B卷 专栏：华为OD机试(Python,Java,C++)2023(A+B卷） python专栏：华为od机试(python)2023(A卷） 博主通信专业学硕，10年+互联网大厂经验，精通C++，Python，自学Java，热爱编程，乐于经验分享，已帮助千余名同学通过OD机考。 2023年5月，华为OD机考更新为OD统一考试（B卷）。B卷的题目包括两部分： 1.2022年老题库 2.2023新增题目 OD统一考试B卷的题目博主也会及时搜集更新！ 以下为OD统一考试(B卷)的题目： OD统一考试(B卷)基础题 序号 题目分数考点类型1补种未成活胡杨100滑动窗口OD统一考试 B卷2路灯照明问题100区间交并集OD统一考试 B卷3敏感字段加密100字符串处理OD统一考试 B卷4阿里巴巴找黄金宝箱(I)100单指针OD统一考试 B卷5喊7的次数重排100约瑟夫环OD统一考试 B卷6斗地主之顺子100逻辑分析OD统一考试 B卷7IPv4地址转换成整数100字符串处理OD统一考试 B卷8分苹果100位运算OD统一考试 B卷9组成最大数100自定义排序OD统一考试 B卷10最大花费金额100双指针OD统一考试 B卷11太阳能板最大面积100双指针OD统一考试 B卷12座位调整100逻辑分析OD统一考试 B卷13选修课100自定义排序，数据结构OD统一考试 B卷14分班100逻辑分析OD统一考试 B卷15分糖果100递归OD统一考试 B卷16最远足迹100字符串处理OD统一考试 B卷17需要打开多少监控器100逻辑分析OD统一考试 B卷18VLAN资源池100逻辑分析OD统一考试 B卷19求字符串中所有整数的最小和100字符串处理OD统一考试 B卷20求满足条件的最长子串长度100滑动窗口OD统一考试 B卷21TLV解析 Ⅰ100字符串分隔匹配OD统一考试 B卷22拼接URL100字符串处理OD统一考试 B卷23水仙花数 Ⅰ100数学运算OD统一考试 B卷24最大股票收益100贪心算法OD统一考试 B卷25找朋友100单调栈OD统一考试 B卷26找车位100逻辑分析OD统一考试 B卷27猴子爬山100动态规划OD统一考试 B卷28按身高和体重排队100自定义排序OD统一考试 B卷29阿里巴巴找黄金宝箱(Ⅱ)100贪心思维OD统一考试 B卷30玩牌高手100贪心思维OD统一考试 B卷31告警抑制100逻辑分析OD统一考试 B卷32寻找身高相近的小朋友100自定义排序OD统一考试 B卷33消消乐游戏100数据结构 栈OD统一考试 B卷34数组组成的最小数字100自定义排序OD统一考试 B卷35求最多可派出多少支团队100双指针OD统一考试 B卷36数组去重和排序100自定义排序，数据结构OD统一考试 B卷37快递运输100逻辑分析OD统一考试 B卷38停车场车辆统计100逻辑模拟OD统一考试 B卷39 查找众数及中位数
100数据结构OD统一考试 B卷40滑动窗口最大和100滑动窗口OD统一考试 B卷41连续字母长度100滑动窗口OD统一考试 B卷42寻找相同子串100字符串查找OD统一考试 B卷43阿里巴巴找黄金宝箱(Ⅲ)100数据结构OD统一考试 B卷44报文重排序100字符串分隔OD统一考试 B卷45 阿里巴巴找黄金宝箱(V)
100滑动窗口OD统一考试 B卷46五子棋迷100滑动窗口OD统一考试 B卷47字符串摘要100滑动窗口，自定义排序OD统一考试 B卷48数组拼接100逻辑分析OD统一考试 B卷49矩阵稀疏扫描100逻辑分析OD统一考试 B卷50文件目录大小100dfsOD统一考试 B卷51恢复数字序列100滑动窗口OD统一考试 B卷52分割数组的最大差值100逻辑分析OD统一考试 B卷53生日礼物100二分查找OD统一考试 B卷54乘坐保密电梯100逻辑分析OD统一考试 B卷55拔河比赛100自定义排序OD统一考试 B卷56计算最接近的数100滑动窗口OD统一考试 B卷57矩阵元素的边界值100数据结构OD统一考试 B卷58增强的strstr100正则表达式OD统一考试 B卷59最长公共后缀100字符串操作OD统一考试 B卷60支持优先级的队列100自定义排序OD统一考试 B卷61数字反转打印100逻辑分析OD统一考试 B卷62跳房子1100两数之和OD统一考试 B卷63数字涂色100逻辑分析OD统一考试 B卷64勾股数元组100数学知识OD统一考试 B卷65工号不够用了怎么办100数学知识OD统一考试 B卷66计算最大乘积100字符串处理OD统一考试 B卷67比赛的冠亚季军100逻辑分析OD统一考试 B卷68报文回路100逻辑分析OD统一考试 B卷69响应报文时间100字符串处理OD统一考试 B卷70食堂供餐100逻辑分析OD统一考试 B卷71经典屏保100数学运算OD统一考试 B卷72数据分类100位运算OD统一考试 B卷73按单词下标区间翻转文章内容100字符串处理OD统一考试 B卷74比赛100自定义排序OD统一考试 B卷75模拟消息队列100逻辑分析OD统一考试 B卷76荒岛求生100逻辑分析OD统一考试 B卷77奖牌榜排名100自定义排序OD统一考试 B卷78报数游戏100逻辑分析OD统一考试 B卷79数字最低位排序100自定义排序OD统一考试 B卷80GPU算力100逻辑分析OD统一考试 B卷81最长连续子序列100滑动窗口OD统一考试 B卷82最长元音子串100滑动窗口OD统一考试 B卷83 字符串子序列II
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d2042a83f87174bcd240f2ae86eede3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e56bd509812ff8157d7899145082fd9/" rel="bookmark">
			前端需要理解的 HTML 知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML（超文本标记语言，HyperText Markup Language）不是编程语言，而是定义了网页内容的含义和结构的标记语言。“超文本”（hypertext）是指连接单个网站内或多个网站间的网页的链接。HTML 使用“标记”（markup）来注明文本、图片和其他内容，以便于在 Web 浏览器中显示。
1 Doctype &lt;!Doctype&gt;声明即文档类型定义（DTD），告知浏览器采用的文档解析标准，分为严格模式（标准模式——W3C标准）和混杂模式（兼容模式—向老版本兼容），声明位置— HTML 文档首行（&lt;html&gt; 标签之前），在 HTML4 规定了三种不同的 &lt;!DOCTYPE&gt; 声明，分别是：Strict（严格模式）、Transitional 和 Frameset，后两种声明下，若 DTD 不存在/格式不正确或没有最后的 URI 则以混杂模式呈现，否则以严格模式呈现：
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt;
HTML5 与 HTML4 不同，不基于 SGML（Standard Generalized Markup Language 标准通用标记语言），也就不需要 DTD，因此 HTML5 仅标准模式 &lt;!DOCTYPE html&gt; 一种规范，没有严格和混杂之分。
通过document.compatMode可以输出当前文档的渲染模式是​怪异/混杂/兼容模式​（BackCompat）还是标准模式（CSS1Compat）。
2 HTML页面生命周期 HTML 有四个重要的生命周期事件：
DOMContentLoaded：DOM 完全加载以及解析时触发，而无需等 &lt;img&gt; /样式表/子框架里外部资源加载完成。此时可以查找 DOM 节点，并初始化接口。在用户允许的前提下，Firefox，Chrome 和 Opera 都会在 DOMContentLoaded 触发时自动填充表单。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e56bd509812ff8157d7899145082fd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8664b479bb0b0dc85e252ee756b00343/" rel="bookmark">
			Java实现Ip地址获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java实现Ip地址获取 一、两种实现方式二、测试结果 一、两种实现方式 package com.lyp; import org.apache.commons.lang3.ObjectUtils; import java.net.*; import java.util.ArrayList; import java.util.Enumeration; import java.util.List; import java.util.Optional; /** * 获取本机IP 地址 * */ public class IpUtils { public static void main(String[] args) throws SocketException, UnknownHostException { System.out.println("传统方式-----------hostAddress = " +getTraditionIp()); System.out.println( "新方式-----------hostAddress = "+IpUtils.getLocalIp4Address().get().toString().replaceAll("/","")); } /** * 传统方式，非常简单直接通过InetAddress获取，但不准确获取的为虚拟ip * @throws UnknownHostException */ public static String getTraditionIp() throws UnknownHostException { InetAddress localHost = InetAddress.getLocalHost(); String hostAddress = localHost.getHostAddress(); String hostName = localHost.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8664b479bb0b0dc85e252ee756b00343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/359485b69a54e9240cd67b5779709b40/" rel="bookmark">
			Windows配置python（anaconda&#43;vscode方案）的主要步骤及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows配置python（anaconda+vscode方案）的主要步骤及注意事项 1、准备工作 anaconda，官网下载（直接下载最新版）vscode，官网下载 (官网直接下载有可能太慢，可以考虑在国内靠谱的网站上下载）
PS：windows上也完全可以直接使用miniforge或者miniconda，安装配置方法完全一样，并且体积明显更小。 2、安装与配置anaconda 直接安装anaconda（miniforege、miniconda完全相同），除安装路径外全部默认，一直点击“下一步”直至安装完成配置环境变量： 在系统设置中找到环境变量找到anaconda的安装路径将以下三个路径增加到系统路径中
注意这里 D:\Download 是你安装anaconda的路径，根据你自己安装时选择的路径去找。如果找不到，可以在“搜索”中找到 anaconda，再不断定位回anaconda的安装路径即可。
以上三个路径主要表示：python所在路径、conda命令和常用脚本的路径。
配置完成后打开cmd，输入 python --version，会看到python版本号，输入 conda -V 也能查到anaconda的版本。 此时环境变量配置成功。（一般不成功可能是忘记点确定、保存或路径填错等）。以上操作大致如下：
完成上述配置后，可直接使用 python test.py (test.py为test.py的完整路径）即可运行python脚本。并且 conda 、pip install 等操作均可直接使用。
3、安装与配置vscode 下载vscode后直接安装（同样，除安装路径外，全部选择默认即可）
安装python插件：
注意python相关的插件很多，我们只需要安装开发者为 Microsoft 的版本。
新建一个python文件，打开该文件后右下角会出现以下字样：
如果没有显示，直接点击这个位置，会在上面出现提示（通常会出现intepreter字样）。此时注意看提示的文字。
这里很重要：目前的最新版通常都会自动去搜索conda环境，所以一般在配置好anaconda（miniforge、miniconda类似）在vscode中基本根据提示就可以找到python所在路径。
点击右上角三角形运行程序，即可执行python脚本。
4、关于windows下vscode里的一些坑 不知道从哪个版本开始，vscode会默认让python在powershell下运行，此时有可能会提示“需要初始化powershell”等，总之就是无法运行。【如果运行python文件之后，终端里前面有 PS 字样就说明在powershell里面】。此时简便起见，直接借助另一个插件解决即可： 安装coder runner插件：
打开"setting" （中文“设置”），搜索 code runner，找到设置：run in terminal
保险起见再勾上 “save file before run”（上图倒数第二个选项）。
自此再运行python脚本就直接在cmd中显示，不需要管powershell到底有没有配置好。
5、vscode里配置jupyter notebook 安装Jupyter插件
【一定要仔细！】在自己需要使用的环境里，先安装好两个库： pip install jupyter (这一个一般来说是已经装好）
pip install ipykernel （如果没装，直接运行notebook的cell时vscode也会提示并自动安装，但通常较慢，此时可考虑使用国内镜像安装）。比如：
pip install jupyter -i http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/359485b69a54e9240cd67b5779709b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98b64b65a1dc6140c9cb054a165db5d5/" rel="bookmark">
			[已解决]使用Pytorch的DataSet、DataLoad时报错：stack expects each tensor to be equal size..。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整报错：
RuntimeError: stack expects each tensor to be equal size, but got [4] at entry 0 and [3] at entry 30
问题所在：
使用pytorch的DataSet类中的getitem方法切分数据时，最后一个数据切分不完整。
解决办法：
重写len方法，把数据集返回长度处理一下即可，避免有不完整的数据留下
from torch.utils.data import Dataset class MyDataset(Dataset): def __init__(self,data,days_for_train): self.data = data self.days_for_train = days_for_train self.label_len = 0 self.pred_len = 1 def __len__(self): # 返回数据集的大小 return len(self.data) - self.days_for_train + 1 def __getitem__(self, index): s_begin = index s_end = s_begin + self.days_for_train r_begin = s_end r_end = r_begin + self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98b64b65a1dc6140c9cb054a165db5d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcc4567fb0ed1dcf8dc38718c1ddb97/" rel="bookmark">
			全面、详细、通俗易懂的C语言语法和标准库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 一、基于WSL2和Clion搭建Win下C开发环境
二、make、makeFile、CMake、CMakeLists的使用
三、全面、详细、通俗易懂的C语言语法和标准库
文章目录 系列文章目录前言变量变量的作用域变量的性质变量的声明和定义声明符和声明说明符存储类型符类型限定符类型说明符基本类型自定义类型扩展类型 正确认识变量 不完整类型变量的初始化和赋值 表达式和运算符左值和右值表达式中的类型转换隐式转换强制转换 typedef运算符sizeof运算符 预处理器宏定义带参数的宏多表达式、多语句的宏宏中的运算符预定义的宏 条件编译#if...#endif#ifdef/#ifndef...#endifdefined 文件包含头文件#include 其他指令#error#line 数组字符串字符串常量字符串变量&lt;string.h&gt; 结构空位对齐结构中的位域灵活数组成员 联合枚举函数函数的声明和定义函数的原型函数参数的传值方式可变参数列表和&lt;stdarg.h&gt;__func__ 指针指针变量指向指针的指针取地址运算符和间接寻址运算符空指针通用指针受限指针内存的动态分配与释放指针与数组指针与结构指针与函数 输入输出&lt;stdio.h&gt;流文件操作格式化输入输出字符的输入输出行的输入输出块的输入输出字符串的输入输出 错误处理&lt;assert.h&gt;&lt;signal.h&gt;&lt;setjmp.h&gt; 其它标准库&lt;stddef.h&gt;&lt;stdbool.h&gt;&lt;ctype.h&gt;&lt;stdlib.h&gt;数值转换伪随机数生成与环境通信搜索和排序 前言 本文并不是一篇C语言入门文章，它包含几乎所有C99语法及常用标准库的基本知识，请放心食用。
变量 在C语言中通过变量来代指内存中一个具体的存储空间。一个变量由以下几部分组成：
变量类型：变量存储值的类型变量名：变量的名字变量值：变量存储的值变量地址：变量的地址 变量的作用域 作用域指的是变量生效的范围。C 语言的变量作用域有以下两种：
文件作用域：文件作用域指的是，在源码文件顶层声明的变量，从声明的位置到文件结束都有效。块作用域： 块作用域指的是由大括号{}组成的代码块，它形成一个单独的作用域。凡是在块作用域里面声明的变量，只在当前代码块有效，代码块外部不可见。代码块可以嵌套，即代码块内部还有代码块，这时就形成了多层的块作用域。它的规则是：内层代码块可以使用外层声明的变量，但外层不可以使用内层声明的变量。如果内层的变量与外层同名，那么会在当前作用域覆盖外层变量。 变量的性质 在C语言中每个变量都具有以下性质：
存储期限：存储期限决定了为变量释放内存空间的时间： 自动存储期限：具有自动存储期限的变量会在所属程序块被执行时获得内存空间，在结束时释放内存空间。静态存储期限：具有静态存储期限的变量在程序运行的整个期间都会占用内存空间。动态内存：内存分配在堆上，根据需求自行释放。 链接：链接决定了变量在文件之间的共享范围： 内部链接：具有内部链接的变量只在所属文件内起作用。外部链接：具有外部链接的变量可以在不同文件内起作用。无链接：无链接的变量只在所属文件的所属块作用域内起作用。 变量的默认存储期限和链接与变量的作用域有关：
块作用域的变量具有自动存储权限并且无链接。文件作用域的变量具有静态存储权限和外部链接。 变量的声明和定义 在使用变量之前一定要对其进行定义和声明：
变量的声明：变量的声明用于指定变量的声明说明符和声明符，在程序中一个变量可以被声明多次。变量的定义：变量的定义用于为变量分配存储空间，在程序中一个变量只能被定义一次。 通常情况下变量的声明和变量的定义是同时发生的，但在使用extern关键字并且在它不失效的情况下，只有变量的声明而没有变量的定义。
声明符和声明说明符 声明符用于指明变量名，声明说明符分为以下三类，它们有各自的作用：
存储类型符：用于指明变量的性质类型限定符：用于修饰限定变量类型说明符：用于指明变量的类型 存储类型符 存储类型符在变量声明中最多出现一种，并且必须在声明说明符的最前面。
auto：auto修饰的变量具有自动存储期限、块作用域并且无连接，它只对块作用域的变量有效，因为对于块作用域的变量它是默认的。
static：static修饰的文件作用域的变量具有静态存储期限、文件作用域和内部链接；static修饰的块作用域的变量具有静态存储期限、块作用域并且无连接。
extern：extern用于在当前作用域引入其它文件中定义的变量。extern声明的变量会具有静态存储期限和外部连接并且不会占用内存空间。但如果在引入变量时又对变量进行了初始化，那么extern将失效。
register：register的性质和auto完全一致。但使用register声明的变量会请求编译器把它存储在寄存器中，并且由于寄存器没有地址，所以对register声明的变量使用取地址运算符是非法的，但该请求不一定得到应允。 类型限定符 const：const修饰的变量是只读的，不能被修改，因此也别成为常量。volatile：volatile关键字通常用于声明指向易变内存空间的指针，它告诉编译器该内存空间的数据是易变的，所以不要对其及逆行优化，并且在每次通过指针取值时都必须从内存中直接获取。restrict：见下文受限指针。 类型说明符 基本类型 基本类型包含以下三类：
整数类型：C语言允许使用十进制、八进制和十六进制书写整数类型值，其中八进制必须以0开头，十六进制必须以0x开头。编译器默认将整数常量当作int型处理，可以通过添加后缀的方式使编译器改变默认处理类型。在不加后缀的情况下，如果int型存不下十进制数，那么编译器会依次尝试、long int、long long int。对于八进制和十六进制，编译器会依次尝试unsigned int、long int、unsigned long int、long long int、unsigned long long int。 类型说明符后缀short int-unsigned short int-int-unsigned intulong intlunsigned long intullong long intllunsigned long long intull 浮点类型：编译器默认将浮点常量当作double型处理，可以通过添加后缀的方式使编译器改变默认处理类型。 类型说明符后缀floatfdouble-long doublel 字符类型：编译器将字符类型当作小整数类型处理。 类型说明符后缀char- 自定义类型 自定义类型包含以下几种，主体内容在下文：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdcc4567fb0ed1dcf8dc38718c1ddb97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb13022302bdb2af9803850629776e71/" rel="bookmark">
			SSD算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6个层，从小目标到大目标的预测
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78b3e9c5eb190fd37d901f5c19bae929/" rel="bookmark">
			springboot&#43;vue校园高校学习资料分享网站系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了校园资料分享平台的开发全过程。通过分析企业对于校园资料分享平台的需求，创建了一个计算机管理校园资料分享平台的方案。文章介绍了校园资料分享平台的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本校园资料分享平台有管理员和用户两个角色。管理员功能有个人中心，学生管理，资料分享管理，资源分类管理，举报反馈管理，系统管理等。用户功能有注册登录，个人中心，我的收藏，资料评论等。因而具有一定的实用性。此校园资料分享平台要严格控制管理权限，具体要求如下：
（1）要想对校园资料分享平台进行管理，首先要依靠学生名和密码在系统中登陆，无权限的学生不可以通过任何方式登录系统和对系统的任何信息和数据进行查看，这样可以保证系统的安全可靠性和准确性。
（2）在具体实现中对不同的权限进行设定，不同权限的学生在系统中登陆后，不可以越级操作。
3.2.2 数据完整性
（1）所有记录信息要保持全面，信息记录内容不可以是空。
（2）各种数据间相互联系要保持正确。
（3）相同数据在不同记录中要保持一致。
本站是一个B/S模式系统，采用Spring Boot框架作为开发技术，MYSQL数据库设计开发，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得校园资料分享平台管理工作系统化、规范化。
目录
1系统概述 1
1.1 研究背景 1
1.2研究目的 1
1.3系统设计思想 1
2相关技术 3
2.1 MYSQL数据库 3
2.2 B/S结构 3
2.3 Spring Boot框架简介 4
3系统分析 4
3.1可行性分析 4
3.1.1技术可行性 5
3.1.2经济可行性 5
3.1.3操作可行性 5
3.2系统性能分析 5
3.2.1 系统安全性 5
3.2.2 数据完整性 6
3.3系统界面分析 6
3.4系统流程和逻辑 7
4系统概要设计 8
4.1概述 8
4.2系统结构 9
4.3.数据库设计 10
4.3.1数据库实体 10
4.3.2数据库设计表 12
5系统详细实现 14
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78b3e9c5eb190fd37d901f5c19bae929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9303fbfe5d51db27f245b407ad3dce6b/" rel="bookmark">
			Linux——进程信号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0. 前言
1. 信号入门
1.1 生活角度的信号
1.2 技术应用角度的信号
1.3 注意信号
1.4 信号概念
1.5 用kill -l命令可以察看系统定义的信号列表
1.6 信号处理常见方式概览
2. 信号产生
2.1 通过终端按键产生信号
2.2 Core Dump核心转储
2.3 调用系统函数向进程发信号kill、raise
2.4 由软件条件产生信号alarm
2.5 硬件异常产生信号
2.6 wait\waitpid子进程状态码是否发生核心转储（进程控制补充core信号）
3. 捕捉信号初识
3.1 捕捉信号系统调用接口signal
3.2 定时器闹钟功能
3.3 模拟野指针异常（硬件异常）
3.4 总结
4. 深入内核及阻塞信号
4.1 信号其他相关常见概念
4.2 在内核中的表示
4.3 sigset_t
4.4 信号集操作函数
4.4.1 sigset_t 操作函数
4.4.2 sigprocmask
4.4.3 sigpending
4.5 操作案例分析
4.5.1 自定义捕捉所有信号？
4.5.2 观察block信号的pending信号集
4.5.3 阻塞所有信号？
5. 捕捉信号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9303fbfe5d51db27f245b407ad3dce6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f574f8045767706106d36a4c7137960/" rel="bookmark">
			Faunadb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Faunadb和google spanner都属于云分布式数据库天然支持分片(无需做分表分库操作，一库搞定，当然价格另说)，国内的也有比如TiDB Oceanbase等
本文使用java语言，其他语言可以跳过；有想直接使用的可以参考(无法访问外网，可以搞个vpn吧!!!，有时会遇到网络问题)：GitHub - fauna/faunadb-jvm: Scala and Java driver for FaunaDB v4
此文旨在想了解的小伙伴看看（免费使用30天）
本文演示使用的jdk版本为jdk21
目录
1.登录账号
2.了解一下FQL
3. 创建数据库，创建集合
4.点击搜索框中的dashbord进入到控制台然后到控制台创建集合
5. 生成数据库秘钥
6.springboot整合项目
7.实体
8.service及接口
9.属性文件配置属性
10.controller
11.启动后postman试试
1.登录账号 使用github账号或者注册一个
Welcome to Fauna docs - Fauna Documentation
2.了解一下FQL 建议按照图看下去
3. 创建数据库，创建集合 最好是跟着官网文档走
4.点击搜索框中的dashbord进入到控制台然后到控制台创建集合 （参考：使用 Spring Boot 使用 Fauna 和 Java 开始构建_rxjava_云O生-云原生）
最新的不一样，使用下面语法
Collection.create({
name: 'todos'
})
5. 生成数据库秘钥 记住不要到account哪里去申请
6.springboot整合项目 依赖
&lt;dependency&gt;
&lt;groupId&gt;com.faunadb&lt;/groupId&gt;
&lt;artifactId&gt;faunadb-java&lt;/artifactId&gt;
&lt;version&gt;4.4.0&lt;/version&gt;
&lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
实体\service\controller均参考博文：使用 Spring Boot 使用 Fauna 和 Java 开始构建_rxjava_云O生-云原生
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f574f8045767706106d36a4c7137960/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292cf6b92b1e82e4b253a87eb0035aa8/" rel="bookmark">
			SpringBoot毕业设计管理系统&#43;文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌在职Java研发工程师、专注于程序设计、源码分享、技术交流、专注于Java技术领域和毕业设计✌
温馨提示：文末有 CSDN 平台官方提供的老师 Wechat / QQ 名片 :)
项目名称 SpringBoot毕业设计管理系统+文档
演示视频 品springboot毕业设计管理系统包运行成功]_哔哩哔哩_bilibili
系统介绍 伴随着全球信息化发展，行行业业都与计算机技术相衔接，计算机技术普遍运用于毕业设计管理行业。实施计算机系统来管理可以降低毕业设计管理成本，使整个毕业设计的发展有显著提升。
本论文主要面向毕业设计管理中出现的一些常见问题，将其与计算机管理系统结合起来。通过这个系统，管理员可以更加方便的管理毕业设计；可以清楚的了解毕业设计管理情况；毕业设计管理系统在毕业设计管理中的应用，可以很大程度上提高管理水平，使高校获得更好的经济效益。
该系统基于B/S即所谓浏览器/服务器模式，应用java技术，选择MySQL作为后台数据库。系统主要包括首页，个人中心，公告信息管理，学生管理，教师管理，课题信息管理，选题信息管理，开题报告管理，任务书管理，检查报告管理，论文信息管理，开题评分管理，任务评分管理，检查评分管理，论文评分管理等功能模块。但是，这套系统实现的功能只是整个毕业设计管理中的一部分，系统中还存在一些不及之处，需要继续的创新，使其完美。
关键词：java技术；B/S；数据库；mysql；毕业设计管理；
系统模块设计 系统分为管理员功能模块,教师功能模块、学生模块。
学生登录系统为学生操作界面，主要包括首页，个人中心，课题信息管理，选题信息管理，开题报告管理，任务书管理，检查报告管理，论文信息管理，开题评分管理，任务评分管理，检查评分管理，论文评分管理管理等功能；
教师登录系统为教师操作界面，主要包括首页，个人中心，课题信息管理，选题信息管理，开题报告管理，任务书管理，检查报告管理，论文信息管理，开题评分管理，任务评分管理，检查评分管理，论文评分管理管理等功能；
管理员功能模块为管理员操作界面，主要包括首页，个人中心，公告信息管理，学生管理，教师管理，课题信息管理，选题信息管理，开题报告管理，任务书管理，检查报告管理，论文信息管理，开题评分管理，任务评分管理，检查评分管理，论文评分管理等功能；
系统截图 环境需要 1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 5.数据库：MySql 5.7版本；
6.是否Maven项目：否；
技术栈 1. 后端：Spring+SpringMVC+Mybatis
2. 前端：JSP+CSS+JavaScript+jQuery
使用说明 1. 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
2. 使用IDEA/Eclipse/MyEclipse导入项目，Eclipse/MyEclipse导入时，若为maven项目请选择maven;
若为maven项目，导入成功后请执行maven clean;maven install命令，然后运行；
3. 将项目中springmvc-servlet.xml配置文件中的数据库配置改为自己的配置;
4. 运行项目，在浏览器中输入http://localhost:8080/ 登录
POM依赖: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292cf6b92b1e82e4b253a87eb0035aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f27bab7d9e5a84f79579bd4fd2bd24/" rel="bookmark">
			精品微信小程序ssm校友录网站&#43;后台管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌在职Java研发工程师、专注于程序设计、源码分享、技术交流、专注于Java技术领域和毕业设计✌
温馨提示：文末有 CSDN 平台官方提供的老师 Wechat / QQ 名片 :)
项目名称 精品微信小程序ssm校友录网站+后台管理系统
演示视频 精品微信小程序ssm校友录网站+后台管理系统前后分离VUE_哔哩哔哩_bilibili
系统介绍 《微信小程序校友录网站+后台管理系统|前后分离VUE》该项目含有源码、文档等资料、配套开发软件、软件安装教程、项目发布教程等
本系统包含微信小程序前台和Java做的后台管理系统，该后台采用前后台前后分离的形式使用Java+VUE
微信小程序——前台涉及技术：WXML 和 WXSS、JavaScript、uniapp
Java——后台涉及技术：
前端使用技术：HTML5,CSS3、JavaScript、VUE等
后端使用技术：Spring、SpringMvc、Mybatis（SSM）等
数据库：Mysql数据库
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
系统主要功能：
管理员服务端：首页、个人中心、用户管理、校友管理、校友风采管理、校友视频管理、 视频分类管理、班级信息管理、留言板管理、论坛交流、系统管理，
校友服务端：首页、个人中心、校友风采管理、校友视频管理，
校友客户端；首页、校友风采、校友视频、交流论坛、我的等
系统截图 环境需要 1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 5.数据库：MySql 5.7版本；
6.是否Maven项目：否；
技术栈 1. 后端：Spring+SpringMVC+Mybatis
2. 前端：JSP+CSS+JavaScript+jQuery
使用说明 1. 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
2. 使用IDEA/Eclipse/MyEclipse导入项目，Eclipse/MyEclipse导入时，若为maven项目请选择maven;
若为maven项目，导入成功后请执行maven clean;maven install命令，然后运行；
3. 将项目中springmvc-servlet.xml配置文件中的数据库配置改为自己的配置;
4. 运行项目，在浏览器中输入http://localhost:8080/ 登录
POM依赖: &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7f27bab7d9e5a84f79579bd4fd2bd24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdc8e36bd8fe344c1ab067afa9b19b50/" rel="bookmark">
			Java实现计算两个日期之间的工作日天数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求： 需要在后端实现 计算当前日期与数据库内保存的日期数据之间相隔的工作日数目
实现 import java.time.DayOfWeek; import java.time.LocalDateTime; public class WorkdaysCalculator { public static void main(String[] args) { String givenDateTimeStr = "2022-01-01T12:34:56.789"; // 替换为你的日期时间字符串 LocalDateTime currentDateTime = LocalDateTime.now(); // 获取当前时间 LocalDateTime givenDateTime = LocalDateTime.parse(givenDateTimeStr); int workdaysCount = 0; // 记录相隔工作日数目 int daysCount = 0; // 记录相隔天数总数目 // 循环 直到当前日期在给定日期之前 while (currentDateTime.isAfter(givenDateTime) || currentDateTime.equals(givenDateTime)) { if (isWorkday(currentDateTime.getDayOfWeek())) { workdaysCount++; } currentDateTime = currentDateTime.minusDays(1); // 当前日期减去一天 daysCount++; } if (workdaysCount &gt; 90) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdc8e36bd8fe344c1ab067afa9b19b50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd36e16e267205cbe3abb4dd6c652dff/" rel="bookmark">
			ImportError: cannot import name ‘Mapping‘ from ‘collections‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PS D:\Pycharm_data\小土堆pytorch学习&gt; tensorboard --logdir=logs Traceback (most recent call last): File "D:\Anaconda3_2022.10\envs\pytorch_cuda11.8\Scripts\tensorboard-script.py", line 5, in &lt;module&gt; from tensorboard.main import run_main File "D:\Anaconda3_2022.10\envs\pytorch_cuda11.8\Lib\site-packages\tensorboard\main.py", line 27, in &lt;module&gt; from tensorboard import default File "D:\Anaconda3_2022.10\envs\pytorch_cuda11.8\Lib\site-packages\tensorboard\default.py", line 33, in &lt;module&gt; from tensorboard.plugins.audio import audio_plugin File "D:\Anaconda3_2022.10\envs\pytorch_cuda11.8\Lib\site-packages\tensorboard\plugins\audio\audio_plugin.py", line 23, in &lt;module&gt; from tensorboard import plugin_util File "D:\Anaconda3_2022.10\envs\pytorch_cuda11.8\Lib\site-packages\tensorboard\plugin_util.py", line 20, in &lt;module&gt; from tensorboard._vendor.bleach.sanitizer import Cleaner File "D:\Anaconda3_2022.10\envs\pytorch_cuda11.8\Lib\site-packages\tensorboard\_vendor\bleach\__init__.py", line 5, in &lt;module&gt; from tensorboard._vendor.bleach.linkifier import ( File "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd36e16e267205cbe3abb4dd6c652dff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ee82dd827e0a54dbb2669de13fddffb/" rel="bookmark">
			适配ios13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新Xcode之后，新项目需求，新建项目发现多了如图1所示两个新的文件SceneDelegate.h和SceneDelegate.m
运行之后发现黑屏，无论是真机还是模拟器都不行，换到iOS12的手机上则可以正常运行。
查看官方文档，SceneDelegate是为了优化启动和实现iPad多任务处理功能（在ipad上同时打开多个窗口）做出的改动，将原本在AppDelegate里的生命周期相关方法和window分离出来
iOS13以前：AppDelegate管理App的生命周期和UI生命周期；
iOS13以后：AppDelegate管理App的生命周期和新增的UISceneSession生命周期，
新增SceneDelegate文件来管理UI生命周期和window；
关于解决有两种情况：
不支持多窗口的APP
1）将新增的SceneDelegate文件删除
2）删除info.plist文件中Application Scene Manifest选项，如下图所示
3）在AppDelegate中新增window属性，在didFinishLaunchingWithOptions方法中跟往常一样进行相应根控制设置及处理，并删除新增的UISceneSession两个方法
支持多窗口 &amp;&amp; 适配13以下
2、需要用到SceneDelegate进行开发或不想删除该文件，且需要适配iOS13以前的版本。
解决核心：添加版本控制
1）AppDelegate中增加window属性，在didFinishLaunchingWithOptions方法中用if (@available(iOS 13.0, *)){}进行版本控制，UISceneSession lifecycle里的两个方法也要添加版本控制，如下图所示
（因为在iOS13以前的系统中，没有SceneDelegate文件，所以还是需要在AppDelegate方法中进行根控制的设置）
2）在SceneDelegate中willConnectToSession方法里进行根控制设置的时候也要添加相应的版本控制，需要注意的是，初始化window的时候需要用WindowScene进行初始化，否则黑屏加载不出视图。
2）在支持SceneDelegate的APP中，初始化window必须设置UIWindowScene *windowScene，
如果为nil，window将不会出现。
使用QQ的三方登录，在手机没有安装QQ的情况下，QQSDK会使用webView进行登录，QQSDK会创建一个新的window，这个window没有设置windowScene，会导致无法出现在屏幕上。
解决方案有2种：
关掉QQ的web登录功能，检测手机有没有安装QQ，没有安装QQ，就不显示QQ登录使用runtime hook window的initWithFrame方法，在hook方法中给window.windowScene 赋值 其他适配问题：
1、使用presentViewController推出页面，不会全屏，如图
原因：在iOS13之前，VC的modalPresentationStyle属性默认值为UIModalPresentationFullScreen，而在iOS13中改为了UIModalPresentationAutomatic
解决：设置vc.modalPresentationStyle = UIModalPresentationFullScreen;
2、私有KVC使用崩溃
运行之前项目突然崩溃，定位到UITextField 的Placeholder文字颜色设置
[self.phoneTextField setValue:[UIColor colorWithHexString:@"#888888"] forKeyPath:@"_placeholderLabel.textColor"]; [self.passwordTextField setValue:[UIColor colorWithHexString:@"#888888"] forKeyPath:@"_placeholderLabel.textColor"]; [self.registeTextField setValue:[UIColor colorWithHexString:@"#888888"] forKeyPath:@"_placeholderLabel.textColor"]; 有两种解决方案：
//方法1：去掉下划线访问placeholderLabel [self.phoneTextField setValue:[UIColor blueColor] forKeyPath:@"placeholderLabel.textColor"]; [self.phoneTextField setValue:[UIFont systemFontOfSize:20] forKeyPath:@"placeholderLabel.font"]; //方法2：改为修改并赋值属性字符串 NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ee82dd827e0a54dbb2669de13fddffb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f11e02b5c84cbafe873c642cbcfbd54e/" rel="bookmark">
			TypeScript基础内容（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一：TypeScript 变量声明
类型断言（Type Assertion）
TypeScript 是怎么确定单个断言是否足够
类型推断
变量作用域
二：TypeScript 运算符
算术运算符
关系运算符
逻辑运算符
短路运算符(&amp;&amp; 与 ||)
位运算符
赋值运算符
三元运算符 (?)
类型运算符
typeof 运算符
instanceof
其他运算符
负号运算符(-)
字符串运算符: 连接运算符 (+)
一：TypeScript 变量声明 变量是一种使用方便的占位符，用于运用计算机内存地址。
我们可以把变量当做存储数据的容器。
TypeScript变量的命名规则是：
变量名称可以包含数字和字母。除了下划线_和美元$ 符号外，不能包含其他特殊字符，包括空格。变量名不能以数字开头。 变量使用前必须先声明，我们可以使用var来声明变量。
我们可以使用以下四种方式来声明变量。
声明变量的类型及初始值：
var [变量名]:[类型]=值; 例如：
var uname:string ="Runoob"; 声明变量并初始化值，但不设置类型，该变量可以是任意类型：
var [变量名]=值; 例如：
var uname="Runoob"; 声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值是undefined:
var [变量名]; 例如：
var uname; 实例：
var uname:string ="Runoob"; var score1:number=50; var score2:number=32.5; var sum = score1+score2; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f11e02b5c84cbafe873c642cbcfbd54e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf4762573190e84153c50ba5e2cd445f/" rel="bookmark">
			vs打包生成的文件有：setup.msi,setup.exe 二者区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道通过VS工具自带的打包后会生成两个文件，一个是exe文件，一个是msi文件。
需要说明的是msi文件时windowinstaller开发出来的程序安装文件，它可以让你安装、修改、卸载你所安装的程序，也就是说VS工具打包生成的msi文件就是window installer的数据包，把所有和安装文件相关的内容封装在一个包里。VS工具打包生成的exe文件是主要是用于检查安装的环境，当安装的环境检查成功后，会自动再安装msi文件。当然可能会有exe文件也能直接安装的，但是开发exe的时候要比msi困难多，因为需要编写和安装、修改、卸载相关的很多内容，而msi把这些功能都集成化了，易于开发windows程序安装包。
原文链接：https://blog.csdn.net/u011580143/article/details/50033213/
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/87/">«</a>
	<span class="pagination__item pagination__item--current">88/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/89/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>