<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a89006b2852c87f90da6a07f2a0b5b6/" rel="bookmark">
			基于stm32f103的计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年9月29日，准备开始写博客。用来记录自己在嵌入式开发、C语言以及自己其他小项目的心得体会和知识点。
下面是直接在oled上面写的一个简单的计算器程序，有一些功能没写，以后尽量补充。
#include "calculator.h" #include "delay.h" #include "Display.h" #include "math.h" #include "key.h" #define GET_ARRAY_LEN(array,len) {len = (sizeof(array) / sizeof(array[0]));} u8 char_switch_flag[3][8]= { {1,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0} }; char char_switch[24][4]= //最后还有一个 '\0'，所以是4个字节。 { "7","8","9",".","sin","x^2","+","-", "4","5","6","0","cos","sqr","*","/", "1","2","3","c","tan","cur","d","=" }; u8 x_line_l[]={0,11,11,11,13,23,25,11}; u8 x_line_r[]={0,11,11,11,25,23,13,11}; void array_set(u8 *array,u8 lenth,u8 set_num) //数字数组清零 { while(lenth--){ array[lenth]=set_num; } } void calculator_display_Init() //NO_INVERSED { u8 m=0,n=0; u8 left=7,top=20,right=15,bottom=30; DrawRect(0,0,127,17,1);	for(m=0;m&lt;3;m++){ for(n=0;n&lt;8;n++){ left+=x_line_l[n]; right+=x_line_r[n]; DrawRect(left,top+m*13,right,bottom+m*13,1); GUI_DrawString(left+1,top+2+m*13,*(char_switch+m*8+n),char_switch_flag[m][n],FONT6X8); } left=7;right=15; } ScreenRefreshAll(main_cache); } static u8 i=0,j=0; void calculator_char_selection() { u8 x=0,y=0; if(G_IS_BIT_SET(key_down,4)){ //up 单击 1 G_CLEAR_BIT(key_down,4); if(i--&lt;1)i=2; } if(G_IS_BIT_SET(key_down,5)){ //down 单击 2 G_CLEAR_BIT(key_down,5); if(++i&gt;=3)i=0; } if(G_IS_BIT_SET(key_down,6)){ //right 单击 3 G_CLEAR_BIT(key_down,6); if(++j&gt;=8)j=0; } if(G_IS_BIT_SET(key_down,7)){ //left 单击 4 G_CLEAR_BIT(key_down,7); if(j--&lt;1)j=7; } for(x=0;x&lt;3;x++){ for(y=0;y&lt;8;y++){ if((x==i)&amp;&amp;(y==j))char_switch_flag[i][j]=1; else char_switch_flag[x][y]=0; } } } TYPE_FLAG alg_judge_type(char c) {	if(c&gt;='0' &amp;&amp; c&lt;='9')return NUMBER; else if((c == '+')||(c == '-')||(c == '*')||(c == '/')||(c == '='))return YUNSHUAN_1; //这些是需要显示的 else if((c == '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a89006b2852c87f90da6a07f2a0b5b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4283ab9a8e6f6885ea0d3518077906/" rel="bookmark">
			foobar2000_为MP3/flac嵌入歌词文件/封面编辑(提供eslyric插件下载)/信息标签编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 直接操作版(利用已经封装好的汉化版)使用关联歌词或者(保存到标签) 编辑封面其他信息编辑 自行操作版(从官网下载的foobar2000)安装eslyric 插件布局设置导入歌词源(.js) 直接操作版(利用已经封装好的汉化版) 汉化软件来源:asionwu - 博客园 (cnblogs.com)下载相关工具:(组件)
https://wws.lanzoui.com/b020gjtpc
密码:fbqk 百度：https://pan.baidu.com/s/1wVbB24nSlwiHJWzJOagF9g?pwd=fb2k 提取码:fb2k
蓝奏：https://wwi.lanzoup.com/b0jitwwf 密码:fb2k
使用 如果已经将歌词置于和歌曲文件同目录下:
执行以下操作:
关联歌词 或者(保存到标签) 静默写入会在两秒内结束
手动查看结果:
编辑封面 右键歌曲
其他信息编辑 自行操作版(从官网下载的foobar2000) 安装eslyric 插件 拖入dll文件即可
布局设置 可以从汉化版中导出主题
也可以自行编辑
可以替换为esLyric
导入歌词源(.js) 逐个导入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8d65d499985835625a14adad6cad6b/" rel="bookmark">
			数据结构与算法——线性表（链表篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😊数据结构与算法——线性表（链表篇） 🚀前言🚀线性链表（单链表）🚢概念🚢基本操作👻插入操作⛅按位序插入⛅指定结点的后插操作⛅指定节点的前插操作 👻删除操作⛅按位序删除⛅指定节点的删除 👻查找操作（带头结点）⛅按位查找操作⛅按值查找操作 👻单链表的创建⛅尾插法⛅头插法 🚢静态链表🚢循环链表🚢双向链表👻双向链表的初始化（带头结点）👻双向链表的插入操作👻双向链表的删除操作 💻总结 🚀前言 上一文数据结构与算法——线性表（顺序表篇）中详细介绍了线性表的顺序存储结构的特点是逻辑关系上相邻的两个元素在物理位置上也相邻，因此可以随机存取表中的任一元素，它的存储位置可用一个简单直观的公式来表示。
但是，从另外一方面来看，线性表顺序存储的特点也构成了这种存储结构的特点：在做插入和删除操作时，需要移动大量元素。
本篇文章，我将详细介绍线性表的另外一种表示方式——链式存储结构。由于链式存储结构不要求逻辑上相邻的元素在物理位置上也相邻，因此它没有顺序存储结构所具有的弱点，但同时也失去了顺序表可随机存取的优势
🚀线性链表（单链表） 🚢概念 线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的），因此，为了表示某个数据元素 a i ai ai与它的直接后继元素 a i + 1 ai+1 ai+1之间的逻辑关系，对数据元素 a i ai ai来说，除存储其本身的信息之外，还需要存储一个指示它直接后继的信息（即直接后继的存储位置），这两部分信息组成数据元素 a i ai ai的存储映像，称为结点（node）。
它包括两个域：其中存储数据元素信息的域称为数据域，存储直接后继存储位置的域称为指针域，指针域中存储的信息称为指针或链， n n n个结点（ a i ai ai(1&lt;=i&lt;=n)的存储映像）链结成一个链表，即为线性表的链式存储结构
由于链表的每个结点中只包含一个指针域，所以又称这种链表为线性链表或单链表，整个链表的存取必须从头指针开始进行，头指针指示链表中的第一个结点（即第一个数据元素的存储映像）的存储位置，同时，由于最后一个数据元素没有直接后继，则线性链表中最后一个结点的指针为空（NULL）
单链表的定义：
//方式一 typedef struct LNode{ //定义单链表节点类型 ElemType data; //每个节点存放一个数据元素 struct LNode *next; //指针指向下一个节点 }LNode, *LinkList //方式二 struct LNode{ //定义单链表节点类型 ElemType data; //每个节点存放一个数据元素 struct LNode *next; //指针指向下一个节点 }; typedef struct LNode LNode; typedef struct LNode *LinkList; 用线性链表表示线性表时，数据元素之间的逻辑关系是由结点中的指针指示的，换句话说，指针为数据元素之间的逻辑关系的映像，则逻辑上相邻的两个数据元素其存储的物理位置不要求紧邻，由此可得出，这种存储结构为非顺序映像或链式映像。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b8d65d499985835625a14adad6cad6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52e0a04b504aa499a92fda2a12230fef/" rel="bookmark">
			【链表】使用链表做加法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1: 给定两个用链表表示的整数，每个节点包含一个数位。
这些数位是反向存放的，也就是个位排在链表首部。
编写函数对这两个整数求和，并用链表形式返回结果。
示例：
输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295
输出：2 -&gt; 1 -&gt; 9，即912
解法: 从最低位到最高位做加法，增加一个temp用于记录是否要进位，如果链表是a-&gt;b-&gt;c 和 d-&gt;e-&gt;f，那么就是
v1 = (temp+a+d) / 10. temp = (temp+a+b) %10
v2 = (temp+b+e) / 10. temp = (temp+b+e) %10
v3 = (temp+c+f) / 10. temp = (temp+c+f) %10
最后构造链路：
v1-&gt;v2-&gt;v3-&gt;(temp&gt;0则增加一个节点)
构造链表
package org.example; public class ListNode { public int val; public ListNode next; public ListNode(int x) { val = x; next = null; } } 做加法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52e0a04b504aa499a92fda2a12230fef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7051a2654128ac5d336a52d2811d93a4/" rel="bookmark">
			IC设计中的DC综合学习记录——模板记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一名优秀的IC设计工程师需要懂综合，清楚自己设计的代码与底层的电路的对应关系，明白综合工具对代码的优化方案从而设计出更优PPA（performance，power，area）的电路。同时综合在代码和实际门级电路之间扮演着重要的角色，DC是用于将RTL代码转换成可用于布局布线的网表文件，而可用于布局布线的网表文件需要满足时序要求、面积要求、功耗要求。DC综合可以先从必要的步骤开始，再针对具体的error和warning、violation进行分析解决，若需要增加约束、设置再增加，但前提是需要将所有的error和warning、violation都报出来。
下面记录一种参考模板，在相应的路径下新建一个SYN的文件夹用于存放不同工程的与综合相关的文件。
目录
1 DC综合的总体介绍
2 read_rtl.tcl
3 setup_lib.tcl
4 sta_rules.tcl
5 opt_rules.tcl
6 setup_dc.tcl 7 run_dc.tcl
1 DC综合的总体介绍 &gt;mkdir SYN
&gt;cd SYN
SYN&gt;ls
project1 project2 project3
SYN&gt;cd project1
/SYN/project1&gt;ls
logs outputs reports scripts project1_flist
/SYN/project1&gt;cd scripts
/SYN/project1&gt;ls
opt_rules.tcl read_rtl.tcl run_dc.tcl setup_dc.tcl setup_lib.tcl sta_rules.tcl
按照综合步骤对以上文件进行说明或者举例说明。综合的基础步骤如下所示：
1 读入需要综合的rtl文件，即编写的rtl代码的.v文件——read_rtl.tcl，并生成相应的log文件
2 读入与底层电路对应的.db库文件——setup_lib.tcl，并生成相应的log文件（S家的脚本中可能没有这一个显示的步骤，因为它可以通过执行时自动加载.synopsys_setup.setup的隐形文件（文件名可能记不清楚了，待后续想起来再修改），这种方式有它的好处，但推崇显示的表示，即可让后来人一看就清楚，且修改库文件找起来也方便）
3 将读入的.v文件和.db文件link起来，并生成相应的log文件
4 读入设置综合模式或模型的文件——setup_dc.tcl
5 读入设置约束（包括时钟约束、输入输出约束等约束）的文件——sta_rules.tcl，并生成相应的log文件
6 读入设置优化的文件——opt_rules.tcl
7 进行compile之前的check，包括timing和design的check，生成相应的log文件
8 进行compile
9 进行compile之后的check，包括timing和design的check，生成相应的log文件
10 修改命名规则和使修改后的命名规则生效
11 生成相应的文件和报告
以上11个基础步骤对应下图中画红色下划线的语句
12 执行脚本文件——run_dc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7051a2654128ac5d336a52d2811d93a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058e9482969f02acc10a632588577475/" rel="bookmark">
			UE4-Actor基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Actor的生命周期 1.Actor的创建 a.从磁盘加载，适用于关卡中的Actor创建。 创建流程：
1.LoadMap或AddToWorld被调用 2.从磁盘中加载Actor
3.执行PostLoad，可执行自定义版本化和修复操作。
4.InitializeActorsForPlay：初始化Actor
5.为未初始化的 Actor 执行 RouteActorInitialize
6.初始化组件：PreInitializeComponents - 在 Actor 的组件上调用 InitializeComponent 之前进行调用
InitializeComponent - Actor 上定义的每个组件的创建辅助函数。
PostInitializeComponents - Actor 的组件初始化后调用
7.BeginPlay - 关卡开始后调用
b.从编辑器中复制。 创建流程：
1.编辑器中的 Actor 被复制到新世界场景中
2.PostDuplicate 被调用
3.InitializeActorsForPlay：初始化Actor
4.为未初始化的 Actor 执行 RouteActorInitialize
5.初始化组件：同上
6.BeginPlay - 关卡开始后调用
c.实例Actor 创建流程：
1.SpawnActor 被调用
2.PostSpawnInitialize
3.PostActorCreated 构建函数类行为在此发生。PostActorCreated 与 PostLoad 互斥。
4.ExecuteConstruction：OnConstruction - Actor 的构建。蓝图 Actor 的组件在此处创建，蓝图变量在此处初始化
5.PostActorConstruction
6.初始化组件：同上
7.OnActorSpawned 在 UWorld 上播放
8.BeginPlay - 关卡开始后调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058e9482969f02acc10a632588577475/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f01516d5446998eee79dbf3177b7cc1/" rel="bookmark">
			Ijkplayer编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一下编译ijkplayer过程
一、环境 1.1、VMware + ubuntu
1.2、安装git、vim
sudo apt install git sudo apt install vim 二、配置编译环境 2.1、配置AndroidSDK环境 2.1.1、下载AndroidSDK wget http://dl.google.com/android/android-sdk_r24.2-linux.tgz 国内下载地址：下载网站： http://tools.android-studio.org/index.php/sdk/
2.1.2、解压 tar -xvf android-sdk_r24.4.1-linux.tgz 解压后如图：
从Readme中可以知道需要执行更新指令：
2.1.3、执行更新命令 tools/android update sdk --no-ui 2.1.4、配置环境变量 打开配置文件：
vim /etc/profile 添加环境变量：
# android-sdk export ANDROID_SDK=/home/zzy/Library/AndroidSDK/android-sdk-linux # 需要替换成自己的路径 export PATH=$ANDROID_SDK:$PATH 生效环境变量
source /etc/profile 2.2、配置NDK环境 2.2.1、下载NDK https://dl.google.com/android/repository/android-ndk-r14b-linux-x86_64.zip?hl=zh-cn ijkplayer默认只支持11~14版本的ndk
2.2.2、解压 unzip android-ndk-r14b-linux-x86_64.zip 2.2.3、配置环境变量 vim /ect/profile 添加环境变量：
export ANDROID_NDK=/home/zzy/Library/android-ndk-r14b # 替换自己的路径 export PATH=$PATH:$ANDROID_NDK 生效环境变量
source /etc/profile 2.2.4、校验环境变量是否生效 ndk-build --version 三、 下载ijkplayer 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f01516d5446998eee79dbf3177b7cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2138646a126665db76d4013c76972717/" rel="bookmark">
			DNS基础之使用dig查询DNS解析过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 文中内容参考DNS 原理入门—阮一峰以及https://juejin.cn/post/6854573215843352583#heading-8 内容。
域名层级及分级查询 DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。
根域名.root对于所有域名都是一样的，所以平时是省略的。
根域名的下一级，叫做"顶级域名"（top-level domain，缩写为TLD），比如：.com、.cn、 .org、 edu等等
再下一级叫做"次级域名"（second-level domain，缩写为SLD），比如www.baidu.com里面的.baidu，这一级域名是用户可以注册的；
再下一级是主机名（host），比如www.baidu.com里面的www，又称为"三级域名"，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。
域名的层级结构如下:
主机名.次级域名.顶级域名.根域名
即
host.sld.tld.root
所谓"分级查询"，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址。
DNS 解析的具体流程 浏览器缓存：首先通过浏览器缓存信息寻找域名映射的IP地址，如果找到则返回，没找到则继续到下一级;
如果一个域名的DNS解析结果会有多个的话，浏览器是如何处理的呢？Chrome浏览器会优先向第一个IP发起HTTP请求，如果不通，再向后面的IP发起HTTP请求；
本机系统缓存：操作系统会检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析；
hosts文件由操作系统操作的IP和域名的本地映射文件，可以视为DNS server的重写，一旦查到了指定的域名，就不会继续查找DNS server， 所以可以节省时间。
但是hosts设置的IP地址是静态的，如果web app的宿主机地址发生改变，对应的hosts也要改写
有垃圾软件会偷偷修改系统的 hosts文件，达到 DNS劫持 的目的。 如： 把淘宝域名指向另外一个IP， 然后部署一个高仿的淘宝商城， 等你输入账号密码，你的账号信息就全部泄露了…
本地域名解析服务系统：本地域名系统Local DNS一般都是本地区的域名服务器。
Windows系统使用命令ipconfig 就可以查看，在Linux和Mac系统下，直接使用命令 cat /etc/resolv.conf 来查看LDNS服务地址。
如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
本地DNS解析器缓存一般都缓存了大部分的域名解析的结果
根域名解析：本地域名解析服务系统无法解析时，会向 根DNS服务器 发起域名解析请求
根域名服务器由 ICANN 来管理，在全球有 13 个根域名服务器，每个根域名服务器由多台机器。分布在全球各地，查询量非常大，所以分布在各地是有原因的。根域名服务器主要负责解析 TLD 服务器。
由于DNS解析中采用的是UDP协议，仅能传递512字节的有效报文，因此只能构建出A-M 13个根服务器，而真正工作运行肯定不止13台服务器，而是包含很多服务器镜像的
根域名解析服务器返回 gTLD (Generic top-level domain) 给本地解析服务器，即该域名所属的顶级域及其所在的服务器
本地 DNS 服务器已知顶级域名服务器地址后，向其发送查询报文；
顶级域 DNS 服务器，也就是 TLD，提供了它的下一级，也就是权威 DNS 服务器的 IP 地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2138646a126665db76d4013c76972717/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b843c4b1cc112c36814c9a8cb5ea72e/" rel="bookmark">
			Altium Designer 19 器件丝印标号位置批量统一摆放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Altium Designer 19 器件丝印标号位置统一摆放 文章目录 Altium Designer 19 器件丝印标号位置统一摆放前言总结 前言 在绘制PCB过程中，器件布局的时候挪动器件时，标号也随之移动，又想移到合适的位置，如果元件比较少的话还可以一个一个地移，但是元件多的话，操作起来就比较繁琐，每次都充分相同的动作。
如下图的四个贴片电阻，摆放的比较整齐，可以使用快捷方式对齐，而不用一个一个地挪。
具体的操作步骤如下：
1、首先选中要统一摆放丝印方向的器件
2、键盘快捷键 A+P
3、在标识符位号中选择要显示的位置，注释可以选择不改变（一般不用）。
4、点击确定，效果就如下面所示，很整齐。
总结 这个快捷键比较好用，是自己在玩的时候无意中发现的，大大的提高了画板的效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0d7bc0964b6d52a7842901fcfb8b428/" rel="bookmark">
			MySQL 数据库定时备份脚本实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 mysqldump命令备份数据mysqldump常用操作示例还原 MySQL 备份内容附 备份指令脚本、CRON定时任务脚本编辑实例 1.mysqldump命令备份数据 在MySQL中提供了命令行导出数据库数据以及文件的一种方便的工具mysqldump,我们可以通过命令行直接实现数据库内容的导出dump,首先我们简单了解一下mysqldump命令用法:
#MySQLdump常用
mysqldump -u root -p --databases 数据库1 数据库2 &gt; xxx.sql
2.mysqldump常用操作示例 备份全部数据库的数据和结构
mysqldump -uroot -p123456 -A &gt; /data/mysqlDump/mydb.sql
备份全部数据库的结构（加 -d 参数）
mysqldump -uroot -p123456 -A -d &gt; /data/mysqlDump/mydb.sql
备份全部数据库的数据(加 -t 参数)
mysqldump -uroot -p123456 -A -t &gt; /data/mysqlDump/mydb.sql
备份单个数据库的数据和结构(数据库名mydb)
mysqldump -uroot-p123456 mydb &gt; /data/mysqlDump/mydb.sql 备份单个数据库的结构
mysqldump -uroot -p123456 mydb -d &gt; /data/mysqlDump/mydb.sql
备份单个数据库的数据
mysqldump -uroot -p123456 mydb -t &gt; /data/mysqlDump/mydb.sql
备份多个表的数据和结构（数据，结构的单独备份方法与上同）
mysqldump -uroot -p123456 mydb t1 t2 &gt; /data/mysqlDump/mydb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0d7bc0964b6d52a7842901fcfb8b428/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d750b727b607aad8a9dfa8e66dd85ee/" rel="bookmark">
			oracle11g导入或导出dump文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 新建表空间
create tablespace MAP_DATA
logging datafile ‘D:\app\hasee\oradata\orcl\MAP2020.dbf’
size 500M autoextend on next 100M maxsize unlimited
extent management local;
--多个表空间
ALTER USER map2020 QUOTA UNLIMITED ON SOSM_WEB_DATA;
ALTER USER map2020 QUOTA UNLIMITED ON ODS2_DATA;
2 创建用户
create user map2020
identified by map2020
default tablespace MAP_DATA
temporary tablespace TEMP
profile DEFAULT;
3 为用户赋予权限
grant connect,dba,resource,unlimited tablespace to map2020;
4 创建逻辑目录
可通过navicat创建
5 为用户赋予该目录的读写权限
grant read,write on directory dump_dir to map2020;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d750b727b607aad8a9dfa8e66dd85ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db67a1646adc04a56bfb664dd89d2a91/" rel="bookmark">
			K8S的pod探针（livenessProbe，readinessProbe），kubelet对pod的状态检查（kubelet-exec，httpGet，tcpSocket）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8S的pod探针（livenessProbe，readinessProbe），kubelet对pod的状态检查（kubelet-exec，httpGet，tcpSocket） 1、kubelet的探测方式2、livenessProbe探针2.1、livenessProbe和kubelet-exec2.2、livenessProbe和kubelet-httpGet2.3、livenessProbe和kubelet-tcpSocket 3、readinessProbe探针3.1、readinessProbe和kubelet-exec3.2、readinessProbe和kubelet-httpGet3.3、readinessProbe和kubelet-tcpSocket 1、kubelet的探测方式 搭建K8S文档：yum安装K8S
ansible搭建K8S集群：ansible搭建K8S
准备至少3个机器搭建好K8S集群测试调度
节点名称IPk8s-master192.168.116.130k8s-node1192.168.116.131k8s-node2192.168.116.132 官网探针介绍：K8S-探针
探针配置介绍：K8S-配置探针
原理：在K8S集群中，为了测试pod是否正常运行，可以通过kubelet定期对pod进行健康检查，从而保证服务正常运行。
kubelet检查机制：
exec： 在容器内执行指定命令，当返回码为0表示检测成功。在 Kubernetes 1.20 版本之前，exec 探针会忽略 timeoutSeconds： 探针会无限期地持续运行，甚至可能超过所配置的限期，直到返回结果为止。grpc：使用 gRPC 执行一个远程过程调用。 目标应该实现 gRPC健康检查。 如果响应的状态是 “SERVING”，则认为诊断成功。gRPC 探针是一个 alpha 特性，只有在你启用了"GRPCContainerProbe" 特性门控时才能使用。httpGet：对容器的IP和URL进行HTTP的GET请求，当响应码为大于等于200且小于400，表示容器正常运行。tcpSocket：对容器内的端口或socket进行TCP检查，如果端口成功打开，证明容器正常运行。 探针的返回结果：
Success（成功）：容器通过了诊断。Failure（失败）：容器未通过诊断。Unknown（未知）：诊断失败，因此不会采取任何行动。 探针的类型：
livenessProbe（存活探针）：判断容器是否正常运行。如果存活探测失败，那么kubelet就会把老的容器删除，然后根据重启策略对容器做操作。如果容器没有存活探针，默认状态为Success。readinessProbe（就绪探针）：判断容器的是否就绪。比如：应用在启动时可能需要加载大量的数据或配置文件，或是启动后要依赖等待外部服务。在这种情况下，既不想杀死应用，也不想给它发送请求。这个时候就需要用到这个探针。
当就绪探测失败，端点控制器将从与 Pod匹配的所有服务的端点列表中删除该 Pod 的 IP 地址(如果是用nodeport映射端口到外网，这个时候就不能访问网站了，但是容器不会被删除)，初始延迟之前的就绪态的状态值默认为 Failure。 如果容器不提供就绪态探针，则默认状态为 Success。startupProbe（启动探针）：指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被禁用，直到此探针成功为止。如果启动探测失败，kubelet 将删除容器，而容器依其重启策略进行重启。如果容器没有提供启动探测，则默认状态为 Success。 探针主要字段解析：
（initialDelaySeconds: 5）：初始化延迟时间，主要是告诉kubelet，容器启动需要的时间，当过了这个时间再进行探测，要不然容器可能还没启动就会删除了。（periodSeconds: 5）：探测周期间隔时间，主要是指定kubelet对容器进行探针的时间周期，也就是第一次探测结束后，等待多少时间后对容器进行探测。默认值为10秒，最小值为1秒。（timeoutSeconds: 5）：单次探测超时时间，指定kubelet对容器探测的最大时间，超过这个时间证明容器探测失败。默认为1秒，最小为1秒。（successThreshold: 5）：探测失败到成功的重试次数，当kubelet对某个容器第一次探测失败后，重新进行探测的次数，比如指定为1，那么就会直接将容器删除。如果使用的探针是livenessProbe，那么只能配置为1，最小值为1次。（failureThreshold: 5）：探测成功到失败的重试次数，当kubelet对某个容器进行探测过程中，允许失败的次数，当用于readinessProbe探针，默认是3次，最小值为1次。也就是说当3次探测失败后，容器会被删除。当用于startupProbe探针，如果还设置了periodSeconds时间，那么等待容器启动的时间为failureThreshold的时间乘以periodSeconds时间的值，在这段时间内，容器没有启动，那么就会删除容器。 2、livenessProbe探针 2.1、livenessProbe和kubelet-exec 在master创建容器
vi nginx.yml apiVersion: apps/v1 kind: Deployment metadata: labels: app: nginx name: nginx-deployment namespace: default spec: replicas: 1 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: docker.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db67a1646adc04a56bfb664dd89d2a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c71d81edd1c895f35d37a8a03480e2b/" rel="bookmark">
			SuperMap iDesktop 桌面端扩展开发自定义浮动面板（DockPanel） - 调整浮动面板标签位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前 SuperMap iDesktop 桌面端提供了非常强大的扩展插件功能，用户可以轻易的通过插件配置文件 （*.config） 进行自定义扩展插件在 SuperMap iDesktop 桌面端上布局、状态等调整。此教程主要说明如何在 SuperMap iDesktop 上扩展开发自定义浮动面板 （如：工作空间管理器 WorkspaceControlManager、图层管理器 LayersControlManager 等浮动面板）。
目录 1. 准备工作2. 环境配置 2.1. 新建插件项目 2.2. 配置项目属性 2.3. 添加项目引用 3. 插件开发 3.1. 新建用户控件 3.2. 新建配置文件 4. 插件构建5. 运行结果 1. 准备工作 1.1. SuperMap iDesktop：10i 以其以上版本 - 下载地址 SuperMap iDesktop 下载；
1.2. Visual Studio：推荐使用 VS 2022 以其以上版本 （VS 2022版本支持 SuperMap iObjects .NET 64 位组件拖拽使用） - 下载地址 Visual Studio 下载；
1.3. .NET Framework框架：建议使用 4x 版本，暂不支持 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c71d81edd1c895f35d37a8a03480e2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/640eac1977f87eca2b2605ee05a8c939/" rel="bookmark">
			opencv图像对齐与图像相减python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.问题背景： 给一张图片和模板图片（如下图），需要用传统机器视觉的方法来提取他们不一样的特征（也就是划痕部分），并把划痕转为二值化
1.1 才开始使用基于灰度的方法：
因为划痕和旁边背景颜色比较接近，绘制出的灰度直方图变化不大，调了很久阈值也不能分出划痕部分，效果如下：
1.2 后来直接使用图像相减，RGB和Gray分别图像相减结果得到如下：
解决方案： 应该是没有配准而相减有边框的，最终决定配准后，图像相减
查阅资料文献后，大致思路如下：
1. RGB—&gt; 灰度图
2. 去噪滤波，图像增强等一系列预处理操作
3. 提特征点（ORB）并进行图像配准
4. 配准后进行二值化
5. 图像相减操作（ImageChops.difference）
1. RGB-----&gt; Gray # 1. 转为灰度图 target = cv2.imread("2368_data.png") gray_target=cv2.cvtColor(target, cv2.COLOR_BGR2GRAY) template = cv2.imread("2368_model.png") gray_template=cv2.cvtColor(template, cv2.COLOR_BGR2GRAY) 2. 去噪滤波 预处理操作 # 去噪滤波 预处理 target_gauss = cv2.GaussianBlur(gray_target,(3, 3),1,1) template_gauss = cv2.GaussianBlur(gray_template,(3, 3),1,1) # plt转为cv target_gauss =Image.fromarray(target_gauss) # np array template_gauss =Image.fromarray(template_gauss) # np array # 亮度增强 bright= 0.9 bright_target=ImageEnhance.Brightness(target_gauss).enhance(bright) bright_template=ImageEnhance.Brightness(template_gauss).enhance(bright) #色度增强 color = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/640eac1977f87eca2b2605ee05a8c939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0bbc80a968753d63e0672c6cc02f90/" rel="bookmark">
			git合并分支或者push时，报错：“Please enter a commit message to explain why this merge is necessary,especi”的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 我们在用git管理版本控制时，有时候会遇到git合并分支或者push时，会报错：
Please enter a commit message to explain why this merge is necessary, especially if it merges an updated upstream into a topic branch 然后我们按什么键都不管用，界面被锁住了，然而并非按什么键都不管用，其实是有门套的，方案如下：
方法一：
1、直接关闭当前窗口，再重新打开新的窗口；
2、接着就可以继续操作；但个人觉得这个方法不是办法中的办法，迫不得已，太麻烦了。（个人不建议）
方法二：
1、当出现上述情况，可按键盘左上角的“Ese”退出键；
2、输入“：wq”，注意是英文输入状态下的冒号，然后按下“Enter”键即可。（个人觉得这个方法好， “ :wq”是啥意思呢？？？学Linux操作系统时的命令： 强制性写入文件并退出。）
欢迎访问我的博客地址 : 博客地址，也可以手机扫码观看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae208658e3a9a191addc8ae6e3879667/" rel="bookmark">
			Linux中：Find和exec命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Find查找文件或目录
1.1、 案例：
按文件名称查找：-name
按文件类型来查找：
按文件名称来查找：
按文件创建，修改等来查找 1.2、利用find和管道将所需要的数据复制到另一个目录下
案例1： 案例2： 二、exec解释：
案例： 一、Find查找文件或目录 find命令是linux中查找文件的命令
语法格式：find 【文件路径】 【参数】
在不加任何参数的时候find命令会查看当前目录文件内容：
我们也搭配一些参数，来查找我们需要的特定的文件：
-name按名称来查找-type按文件类型查找-size按文件大小来查找-user按文件属主来查找 1.1、 案例： 按文件名称查找：-name 按文件类型来查找： 文件类型种类（f：普通文件 d：目录文件 b：块文件 l：链接文件 p：管道文件 s:套接字文件 ）
按文件名称来查找： 等等，按照这种方式根据自己需求来进行查找
按文件创建，修改等来查找 xargs 可以和管道配合
find ./ -maxdepth 1 -type f -print0 | xargs -0 ls -lh
-atime -- 访问时间 Linux中日志放在/var/log sylog
-mtime -- 文件内容修改时间
-ctime -- 文件属性修改时间
ctime ##以天为单位
cmin ##以分钟为单位
1.2、利用find和管道将所需要的数据复制到另一个目录下 案例1： cd /opt
touch {1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae208658e3a9a191addc8ae6e3879667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03db8ab022e6ac52563d235873479efe/" rel="bookmark">
			Matlab 最优化求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 @[toc]1 线性规划2 非线性规划3 无约束问题matlab解法3.1 符号解3.2 数值解 4 求解零点与方程组的解4.1 多项式4.2 符号解4.3 数值解4.4 方程组情形 5 约束问题matlab解法5.1 二次规划5.2 罚函数法（外） 6 其他一些命令6.1 fminbnd函数6.2 fseminf函数6.3 fminimax函数 matlab求解最优化函数主要包括linprog、quadprog、fminbnd、fmincon、fseminf和fminmax
1 线性规划 目标函数与约束条件都为线性函数，其Matlab标准式为
m i n f T x min \boldsymbol f^{T}\boldsymbol x minfTx
s . t . { A x ≤ b A e q ⋅ x = b e q l b ≤ b ≤ u b s.t.\left\{\begin{array}{l} \boldsymbol A\boldsymbol x \le\boldsymbol b\\ Aeq \cdot \boldsymbol x = beq\\ lb \le \boldsymbol b \le ub \end{array}\right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03db8ab022e6ac52563d235873479efe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1baa4b165062472de0c4ae4cfb27066/" rel="bookmark">
			Opencv中绘制直线，矩形，圆，椭圆，多边形（包括多边形填充），绘制文本，以及综合实现（python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.画线2.椭圆3.绘制圆4.画矩形5.绘制多边形6.绘制文本7.综合练习 1.画线 line(img, pt1, pt2, color, thickness=None, lineType=None, shift=None) Img:输入的原始图像；
Pt1:起始点坐标；
Pt2:结束点坐标；
Color:使用的颜色；
Thickness:线的宽度；
lineType:线的类型；
Shift:按坐标比例缩放；
def drawline(img_path='images/bg.png'): img=cv2.imread(img_path) img=cv2.resize(src=img,dsize=(450,450)) img=cv2.line(img=img,pt1=(0,0),pt2=(350,350),color=(0,255,0),thickness=3) cv2.imshow('img',img) cv2.waitKey(0) cv2.destroyAllWindows() 2.椭圆 ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness=None, lineType=None, shift=None): Img:输入的原始图像；
Center:中心点坐标；
Axes:长轴和短轴的长度；
Angle:椭圆中心沿逆时针选择角度；
startAngle:顺时针开始的角度；
endAngle:顺时针结束的角度；
Color:使用的颜色；
Thickness:线的宽度；
lineType:线的类型；
Shift:按坐标比例缩放；
def drawellipse(img_path='images/bg.png'): img = cv2.imread(img_path) img = cv2.resize(src=img, dsize=(450, 450)) img = cv2.ellipse(img=img,center=(200,200),axes=(100,50),angle=0,startAngle=0,endAngle=360,color=(0,255,0),thickness=2) cv2.imshow('img', img) cv2.waitKey(0) cv2.destroyAllWindows() 3.绘制圆 circle(img, center, radius, color, thickness=None, lineType=None, shift=None): Img:输入的原始图像；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1baa4b165062472de0c4ae4cfb27066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69b56e8681d79ebb3efee879c55137f8/" rel="bookmark">
			获取当前日期--moment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当日: [moment().startOf(“day”), moment().startOf(“day”).subtract(-1,
```javascript "day"),], 近七天: [moment().startOf("day").subtract(1, "weeks"), moment().startOf("day").subtract(-1, "day"),], 近一月: [moment().startOf("day").subtract(1, "month"), moment().startOf("day").subtract(-1, "day"),], 近三月: [moment().startOf("day").subtract(3, "month"), moment().startOf("day").subtract(-1, "day"),], 近六月: [moment().startOf("day").subtract(6, "month"), moment().startOf("day").subtract(-1, "day"),], 近一年: [moment().startOf("day").subtract(1, "year"), moment().startOf("day").subtract(-1, "day"),], 当前事件 moment() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65a1c9469c0948bc9db89fe0ef34666/" rel="bookmark">
			python篇---python读取rtsp流，并消耗（多种方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 python篇---python读取rtsp流，并消耗（多种方式）1.python读取rtsp流，并消耗（用线程）2.python读取rtsp流，并消耗（用进程）3.python读取rtsp流，并消耗（普通）4. 验证 本机 是否支持python rtsp 的GPU 加速5. 代码：python rtsp 的GPU加速 python篇—python读取rtsp流，并消耗（多种方式） 1.python读取rtsp流，并消耗（用线程） import os import cv2 import gc import time import threading import numpy as np from PIL import Image top = 100 stack = [] # 向共享缓冲栈中写入数据: def write(stack, cam, top: int) -&gt; None: """ :param cam: 摄像头参数 :param stack: list对象 :param top: 缓冲栈容量 :return: None """ print('Process to write: %s' % os.getpid()) cap = cv2.VideoCapture(cam) while True: _, img = cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65a1c9469c0948bc9db89fe0ef34666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64eb6b72cf21b39fde2ec054966a2f9e/" rel="bookmark">
			JS函数篇--理解函数的调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一个前端程序猿，我们都写过JS函数，也都调用过JS函数，但你是否曾经想过一个函数被调用的时候真正发生了什么？事实上，函数的调用方式对函数内代码的执行有很大的影响，主要体现在 this 参数以及函数上下文是如何建立的，这点很重要。
那第一个问题就来了：
你知道 JS 中调用一个函数有几种方式吗？（先别急着往后看，可以先在脑海里思索一番）
答案是：4种；
它们分别是：
作为一个函数（function）—— eat()，直接被调用。作为一个方法（method）—— dog.eat()，关联在一个对象上，实现面向对象编程。作为一个构造函数（constructor）—— new Dog()，实例化一个新的对象。通过函数的 apply 或者 call 方法 —— eat.apply(dog) 或者 eat.call(dog)。 下面让我们一个一个来看：
1.作为函数直接被调用 听起来有点蠢（函数当然要被作为函数（function）调用了，不然怎么调用？），哈哈好像有点像绕口令。不过我们这里说的“作为一个函数”被调用是为了区别于其他的 3 种调用方式。一般而言，通过()运算符调用一个函数，且被执行的函数表达式不是作为一个对象的属性存在时，就属于直接被调用的方式了。说人话就是，只要它不是作为方法、构造函数或通过 apply 和 call 调用的话，那就是妥妥的直接调用。
其中，作为函数调用又分为 3 种：
当以这种方式调用时，函数上下文（this 关键字的值）有两种可能性：
非严格模式：全局上下文（window 对象）；
严格模式：undefined；
2、作为方法被调用 当一个函数被赋值给一个对象的属性，并且通过对象属性引用的方式调用函数时，函数会作为对象的方法被调用。
这种情况下，函数被称为方法，调用的对象会称为函数的上下文，并且在函数内部可以通过 this 访问到。这也是 JS 实现面向对象编程的主要方式之一。
那么一个函数作为普通函数调用时和作为方法调用时有什么异同点呢？
在上面这段代码中，我们创建了一个独立的普通函数 whatsMyContext ，在它之后的所有代码都是在对这个函数进行引用并调用。
可以看到，在调用 1 和 2 中，即使我们创建了一个变量来引用原函数，在用这个变量调用该函数时，打印出来的 this 值依旧是 window 对象，因为这个变量也是在全局环境下声明的。
然后，在调用 3 和 4 中，我们创建了两个对象，他们都包含了一个名为 getMyThis 的属性，且该属性值为函数 whatsMyContext 的引用。通过这样的方式，我们就在对象上创建了一个名为 getMyThis 的方法。但是，千万别认为 whatsMyContext 成为了 obj_1 或者 obj_2 的一个方法，不，它依然还是一个独立的函数，它只是可以有多种调用方式而已。当调用 3 和 4 执行时，可以看到分别对应打印出了 obj_1 和 obj_2。正好印证了我们前文说的，当一个函数作为一个对象的方法被调用时，它的上下文将会是调用的这个对象，并且能在函数内部通过参数（this）访问到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64eb6b72cf21b39fde2ec054966a2f9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6cc80e86bcb4442526af24b82340941/" rel="bookmark">
			【20】输入一个字符串，统计其中的字母、数字、其他字符的个数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在【16】中其实已经写了相关代码，当时用的是getchar()函数。由于getchar()函数的应用：单字符输入函数。就总总感觉怪怪的
后来写了一篇输入输出总结，就觉得用gets岂不是更方便嘛。这篇其实和上篇没啥太大的出入，但是就是感觉非常舒服。
一些知识点： \0 为字符串结束符
关于空格和\0其实有点迷，那就总结一下：
空格作为一个字符占有一个字节的空间，我们可以把它看着一个字符去处理。空格是一个字符，本质上和abc一样，他的数值 (ASCII码)是32。 0代表字符串结束，数值是0
题目：输入一个字符串，统计其中的字母、数字、其他字符的个数。 代码部分： #define _CRT_SECURE_NO_DEPRECATE
#include &lt;stdio.h&gt;
void main()
{
char c[20];
printf("请输入一个字符串：");
gets(c);
int i=0,a=0,b=0,d=0;
while (c[i] != '\0')
{
if (c[i] &gt;= 'a' &amp;&amp; c[i] &lt;= 'z' || c[i] &gt;= 'A' &amp;&amp; c[i] &lt;= 'Z')
a++;
else if (c[i] &gt;= '0' &amp;&amp; c[i] &lt; '9')
b++;
else
d++;
i++;
}
printf("字母的个数为：%d\n数字的个数为：%d\n其他字符的个数为：%d\n", a, b, d);
}
运行结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb712b1bb53fa8313a52fdfab8548b8a/" rel="bookmark">
			ensp配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f485e3bf9b4a31a1c3616164374a607e/" rel="bookmark">
			MongoDB的使用以及和python的交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是MongoDB ? MongoDB是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。在高负荷的情况下，添加更多的节点，可以保证服务器性能。
MongDB将数据存储为一个文档，数据结构由键值对（key=&gt;value）组成。MongDB文档类似于JSON对象。
字段值可以包含其他文档，数组等。
主要特点 MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。
Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。
MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。
MongoDB安装简单。
MongoDB的下载及安装 你可以在mongodb的官网下载相应的安装包，地址为：网址：https://www.mongodb.com/download-center/community。如下图所示：
下载 相应的.msi 文件，下载后双击该文件，按操作提示安装即可。
安装过程中，你可以通过点击 “Custom(自定义)” 按钮来设置你的安装目录，也可以通过点击"Complete"按钮进行完整安装。如下图：
data目录是数据存储目录，数据库中的数据就存储在这个目录中。log是日志文件的输出目录。
下一步安装"install mongoDB compass"不勾选（当然你也可以选择安装它，可能需要更久的安装时间），MongoDB Compass 是一个图形界面管理工具，我们可以在后面自己到官网下载安装，下载地址：https://www.mongodb.com/download-center/compass。
命令行下运行 MongoDB 服务器 为了从命令提示符下运行 MongoDB 服务器，你可以从 MongoDB 目录的 bin 目录中执行 mongod.exe 文件，也可以将文件路径加入到path环境变量中，然后在命令行调用mongo。执行成功后，会输出以下信息：
这样也就进入了mongo的交互环境。由于它是一个JavaScript shell，您可以运行一些简单的算术运算:
MongoDB 概念解析 不管我们学习什么数据库都应该学习其中的基础概念，在mongodb中基本的概念是文档、集合、数据库，下面我们挨个介绍。
MongoDB的操作 MongoDB 创建数据库的语法格式如下：
use DATABASE_NAME 如果数据库不存在，则创建数据库，否则切换到指定数据库。
下面我们通过命令创建数据库student：
&gt; use student switched to db runoob &gt; db student 如果你想查看所有数据库，可以使用 show dbs 命令：
&gt; show dbs admin 0.000GB config 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f485e3bf9b4a31a1c3616164374a607e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27a67b4b5aea1d1e7a62a5296027341f/" rel="bookmark">
			将数据导入到MATLAB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将数据导入到MATLAB 将数据导入到MATLAB中有二种方式。
第一种：直接使用MATLAB读Excel文件
例如
Excel表格
num=xlsread('data1.xlsx','Sheet1','A1:E13');%读入Excel文件 input_train=num(1:8,1:4)';%1到8行，1到4列 output_train=num(1:8,5)';%1到8行，第5列 input_test=num(9:13,1:4)';%9到13行，1到4列 output_test=num(9:13,5)';%9到13行，第5列 其中，num：只是一个定义的名称而已，你可以把他定义成你所想想要的名称即可，比如：settlement；data1：是你自己给这个excel起的名字；xlsx：这是excel的文件后缀，如果你是更早的版本可能是xls，注意甄别即可；Sheet1：这个是你的数据在excel的第几页里面；A1:E13：这个是你的数据在excel所处的全部范围。num(1：8，1：4)：1：8的意思是第一行到第八行，1：4是第一列到第四列。()'表示将括号内的数据进行转置。
第二种方式
先在主页中点击，新建变量；然后修改变量名；然后粘贴数据。
然后在命令行窗口输入命令，保存数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9022bf22efb56d2dec0b9ff66d750823/" rel="bookmark">
			C3P0数据库连接池的解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、 Basic Pool Configuration (基础配置项)二、Managing Pool Size and Connection Age （管理连接池大小和连接寿命）三、Configuring Connection Testing（配置连接测试）四、Configuring Statement Pooling五、Configuring Recovery From Database Outages（从数据库中断恢复配置项）六、Configuring Unresolved Transaction Handling[![Go To Top](https://img-blog.csdnimg.cn/img_convert/559514564b425b8a2d8d410f07ccb293.png)](https://www.mchange.com/projects/c3p0/#contents)七、Configuring to Debug and Workaround Broken Client Applications[[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q6948Dkg-1655893008212)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]](https://www.mchange.com/projects/c3p0/#contents)八、Configuring To Avoid Memory Leaks On Hot Redeploy Of Clients[![Go To Top](https://img-blog.csdnimg.cn/img_convert/559514564b425b8a2d8d410f07ccb293.png)](https://www.mchange.com/projects/c3p0/#contents)九、Other DataSource Configuration[![Go To Top](https://img-blog.csdnimg.cn/img_convert/559514564b425b8a2d8d410f07ccb293.png)](https://www.mchange.com/projects/c3p0/#contents)十、Configuring Logging 十一、附录A Appendix A: Configuration Properties[[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-vvz8DFQk-1655893008216)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]](https://www.mchange.com/projects/c3p0/#contents)JavaBeans-style Properties[[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9TAOXV1H-1655893008217)(https://www.mchange.com/projects/c3p0/arrow_sm.png)]](https://www.mchange.com/projects/c3p0/#contents) 十二、网络闪断c3p0线程堵塞解决方法 一、 Basic Pool Configuration (基础配置项) c3p0 Connection pools are very easy to configure via the following basic parameters:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9022bf22efb56d2dec0b9ff66d750823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23dd85867522ca3229074627fc8101e/" rel="bookmark">
			docker安装eclipse-mosquitto MQTT并记录日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在目录/usr/local/mqtt创建
mkdir config data log sh
二、配置文件
vim config/mosquitto.conf
# 写入以下内容
persistence true
persistence_location /mosquitto/data
log_dest file /mosquitto/log/mosquitto.log
allow_anonymous true listener 1883
----------------------------------------------------------------------
vim sh/pwd.sh
# 写入以下内容
容器内执行
#对于passworf_file，可以复制一份模板，或者创建一个空文件
touch /mosquitto/config/pwfile.conf
chmod -R 755 /mosquitto/config/pwfile.conf
# 使用mosquitto_passwd命令创建用户，第一个admin是用户名，第二个123456是密码
mosquitto_passwd -b /mosquitto/config/pwfile.conf admin 123456
#之后重启容器 使用mqtt.fx连接
-------------------------------------------------------------------------
vim sh/topic.sh
# 写入以下内容
mosquitto_sub -v -t $1 &gt; /mosquitto/log/$1.out &amp;
或者下面这种可以支持带/反斜杠，（选一个就好）
mosquitto_sub -v -t $1 &gt; /mosquitto/log/${1##*/}.log &amp;
三、授权
chmod -R 755 /usr/local/mqtt chmod -R 777 /usr/local/mqtt/log
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a23dd85867522ca3229074627fc8101e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ec7d5b3504d5bb7a1202f41f6659f5/" rel="bookmark">
			语义分割学习笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、区别二、代码演示原图像与mask融合三、数据处理 一、区别 语义分割：每个像素都打上标签（这个像素是人，树，背景等）语义分割只区分类别，不区分类别中的具体单元
实例分割：不光要区分类别，还要区分类别中的每一个个体
全景分割：相当于语义分割加上实例分割
二、代码演示原图像与mask融合 from PIL import Image import imgviz import numpy as np image_file=r'D:\aaa\envs\labelme\Scripts\2_3_json\img.png' mask_file=r'D:\aaa\envs\labelme\Scripts\2_3_json\label.png' image=Image.open(image_file) mask=Image.open(mask_file) mask_img=Image.blend(image.convert("RGBA"), mask.convert("RGBA"),0.5) mask_img.save("vis2.png") 三、数据处理 将labelme标注好的json转换成mask图像
import json import os import imgviz import numpy as np from PIL import Image import cv2 import glob def save_colored_mask(mask,image_file): lbl_image=Image.fromarray(mask.astype(np.uint8),mode='P') colormap=imgviz.label_colormap() lbl_image.putpalette(colormap.flatten()) lbl_image.save(image_file) json_files=r'E:\桌面\资料\语义分割' img_file=r'E:\桌面\资料\语义分割\图片' json_l=glob.glob(os.path.join(json_files,'*.json')) for json_ in json_l: name=os.path.basename(json_) img_name=name.replace('json','png') fs=open(json_,encoding='utf-8') dict_=json.load(fs) # 获取图像 宽，高 height = dict_['imageHeight'] width = dict_['imageWidth'] shapes = dict_["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ec7d5b3504d5bb7a1202f41f6659f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc0f3d2f15d6e9f39846c9d4dba2ce3/" rel="bookmark">
			Long类型字段前端获取精度丢失的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 分布式项目中广泛使用雪花算法生成ID作为数据库表的主键，Long类型的雪花ID有19位，而前端接收Long类型用的是number类型，但是number类型的精度只有16位。这就导致雪花ID传到前端会出现精度丢失的问题。如下：
数据库的值：1461642036950462475 前端接收的值：1461642036950462500 (拓展)
使用雪花算法ID的优点:
算法简单，计算效率高。高并发分布式环境下生成递增不重复 id，每秒可生成百万个不重复 id。基于时间戳，以及同一时间戳下序列号自增，基本保证 id 有序递增，有利于数据库存储。不依赖第三方库和中间件(中间件方式生成ID的方式，依赖数据库或Redis缓存实现全局ID的递增) 缺点:
1.依赖服务器时间，服务器时钟回拨时可能会生成重复 id。算法中可通过记录最后一个生成 id 时的时间戳来解决，每次生成 id 之前比较当前服务器时钟是否被回拨，避免生成重复 id。
UUID方式明显的缺点是因为其无序的规则，导致数据库插入效率低，自增方式明显的缺点是不适合分表分库场景，分布式存储的场景会出现主键冲突。而且安全性低，因为ID增长有规律的，容易被非法获取数据。所以综合考虑下，使用雪花算法生成ID的方式更为推荐。
@ JsonSerialize注解 如果要将id字段从Long类型改成String类型，涉及到表，实体类等等代码的改动，影响面比较大所以这个做法是不提倡的。
基本介绍 Jackson是Spring框架默认的序列化框架，使用Jackson的@JsonSerialize注解可以完美解决这个问题。具体做法：后端的ID(Long) ==&gt; Jackson(Long转String) ==&gt; 前端使用String类型接收，并且Jackson反序列化默认支持的前端穿回来的String类型的19位数字字段用Long类型接收。
使用方面，将@JsonSerialize注解定义在字段上即可。Jackson提供了许多Json序列化器。另外我们也可以自定义序列化器。
需要注意不要再引入Gson，在我使用过程中发现同时引入Gson包的话，会导致@JsonSerialize注解失效。
使用 在项目中都是将注解标注在对应字段上，在Json序列化的时候把Long自动转为String。
@JsonSerialize(using = ToStringSerializer.class) private Long id; 需要注意的是被转换的字段必须是包装类类型，否则会转换失败。
@JsonSerialize(using = ToStringSerializer.class) private Long parentId; //转化成功 @JsonSerialize(using = ToStringSerializer.class) private long parentId; //转化失败 自定义序列化器 对于雪花ID集合，我们继续使用 ToStringSerializer，前端解析接收到到之后，还需要特殊处理。因此需要针对List类型的雪花ID集合自定义序列化器，实现将Long转换成String类型传递给前端。
自定义序列化器ListLongToStringArrayJsonSerializer，继承JsonSerializer
public class ListLongToStringArrayJsonSerializer extends JsonSerializer&lt;List&lt;Long&gt;&gt; { @Override public void serialize(List&lt;Long&gt; values, JsonGenerator gen, SerializerProvider serializers) throws IOException { String[] newValues = ObjectUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cc0f3d2f15d6e9f39846c9d4dba2ce3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc04428e129c2ad60310dfda9dbedd55/" rel="bookmark">
			使用long类型时js的精度丢失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用long类型时js的精度丢失问题 在后端和前端联调的时候，后端使用雪花算法生成了一个20位的id，使用postman调用接口的时候接口返回的id没有问题，但是前端在使用的时候发现从接口拿到的id和postman中的id是不一致的。
经过观察发现，js中Number类型只能接收16位以内的数字，如果超过16位，会导致一个四舍五入的精度丢失。
解决办法：后端可以在序列化的通用配置的时候将long类型统一序列化成String，但是要注意这种配置同样会影响其他long类型的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdb38f8fa44cb940138c60ebcbb6fc7/" rel="bookmark">
			Unity开发通用UI事件监听器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 封装UI事件，以方便对UI的一些通用操作的编写。例如：点击，鼠标按下，鼠标抬起，拖拽，开始拖拽，结束拖拽等等。
一.封装UI事件监听类 1.引入事件系统，并且继承接口（看自己需求继承），并且实现接口方法，在这里我们实现了点击和拖拽。
2.创建委托并且设置参数为，PointerEventData(与指针（鼠标/触摸）事件关联的事件有效负载)和object[](传递任意数量引用类型参数)
3.在实现的方法中执行委托事件
using System; using UnityEngine; using UnityEngine.EventSystems; public class UIListener : MonoBehaviour,IPointerClickHandler,IPointerDownHandler,IPointerUpHandler,IDragHandler { public Action&lt;PointerEventData, object[]&gt; onClick; public Action&lt;PointerEventData, object[]&gt; onDrag; public object[] args = null; public void OnDrag(PointerEventData eventData) { onDrag?.Invoke(eventData, args); } public void OnPointerClick(PointerEventData eventData) { onClick?.Invoke(eventData, args); } } 二.封装一个UI事件根类 1.根据在UI事件监听类中的委托事件来生成对应的添加委托侦听的方法
2.封装一个获取或者添加组件的方法（用来获取或者添加UI事件监听类到UI上）。
using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; public class UIRoot : MonoBehaviour { //获取或者添加组件 private T GetOrAddComponent&lt;T&gt;(GameObject go) where T : Component { T t = go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fdb38f8fa44cb940138c60ebcbb6fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8691aa3af18c9ad29b632713e31fef/" rel="bookmark">
			IDEA 无法保存设置 源根 D:XXXX在模块XXX中重复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当IDEA对一个项目来回切换JDK的版本，或者其他的一个设置，经常会出现这个错误
造成这个问题的原因就是bulid文件的版本不一样，或者设置不一样造成的
找到对应的文件位置，整个bulid文件夹删除即可，这样就可以完成设置了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a904152870b3d13423386a8e340469/" rel="bookmark">
			c&#43;&#43;学习之 关于vector的一些小知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.头文件
#include &lt;vector&gt;
2.初始化
vector&lt;int&gt; test; //默认初始化 vector&lt;int&gt; test2(test1); 或 vector&lt;int&gt; test2 = test1; //拷贝复制
vector&lt;int&gt; test = {1,2,3,4,5,6,7}; //直接赋值初始化
int a[] ={1,2,3,4,5};
vector&lt;int&gt; test(a,a+5);
//通过数组初始化
vector&lt;int&gt; test(7,3);//初始化test时在list中压入7个值为3的元素，若“3”的部分缺省，则会在test中压入7个0。
vector&lt; vector&lt;int&gt; &gt; test(i,vector&lt;int&gt;(j,val)); //定义一个 i * j 的值为val的int型二维向量
3.添加函数
int i = 1;
test.push_back(i); //将1加入到vector中
test.insert(test.begin() + i,val); //在test的第i个元素的位置插入值为val的元素。例如test 为1,2,3,4。i为1的情况下变为 1,val,2,3,4。
test.insert(test.begin() + i,k,val); //在test的第i个元素位置插入k个值为val的元素。
test.insert(test.begin() + i,a + j,a + k); //a为数组，在test的第i个位置插入a的第j到k的元素（不包括a + k）。例如v1.insert(v1.begin(),v2.begin(),v2.end());就是将v2加入到v1前。
4.删除函数
test.pop_back(); //删除容器中最后一个元素，该容器size会发生减1，但容量capacity不变。
test.erase(test.begin() + i); //删除vector容器中第i（i = 0,1,2,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53a904152870b3d13423386a8e340469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d35d2730e0a871c91a02e8772c75275/" rel="bookmark">
			深度学习入门-神经网络的学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习入门-神经网络的学习 ​ 这里所说的“学习”是指从训练数据中 自动获取最优权重参数的过程。为了使神经网络能进行学习，将导 入损失函数这一指标。而学习的目的就是以该损失函数为基准，找出能使它的值达到最小的权重参数。
神经网络(深度学习)与机器学习的不同 ​ 如图所示，神经网络直接学习图像本身。在第2个方法，即利用特征量和机器学习的方法中，特征量仍是由人工设计的，而在神经网络中，连 图像中包含的重要特征量也都是由机器来学习的。
损失函数 ​ 损失函数是表示神经网络性能的“恶劣程度”的指标，即当前的 神经网络对监督数据在多大程度上不拟合，在多大程度上不一致。这个损失函数可以使用任意函数， 但一般用均方误差和交叉熵误差等。
均方误差 ​ 这里，yk是表示神经网络的输出，tk表示正确解的标签，k表示数据的维数。
#手写数字识别中的以均方误差为损失函数的例子 import numpy as np def mean_squared_error(y, t): return 0.5 * np.sum((y-t)**2) y = np.array([0.1, 0.05, 0.6, 0.0, 0.05, 0.1, 0.0, 0.1, 0.0, 0.0])#图像为各个数字的概率 t = np.array([0, 0, 1, 0, 0, 0, 0, 0, 0, 0])#已知的正确解的标签 print(mean_squared_error(y, t)) 交叉熵误差 这里，log表示以e为底数的自然对数（log e ）。yk是神经网络的输出，tk是 正确解标签。由于只有正确解的标签tk为1，所以交叉熵误差的值是由正确解标签所对应的输出结果决定的。
import numpy as np def cross_entropy_error(y, t): delta = 1e-7 return -np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d35d2730e0a871c91a02e8772c75275/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e91bebb9bbcb97e31d06cdd875c85b/" rel="bookmark">
			ES6构造函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function Student(name, age) { this.name = name; this.age = age; this.sing = function () { return this.name + this.age; } } // 构造函数如下： function Person (p) { this.name = p.name; } // 如果用箭头函数作为构造函数，则如下 var Person = (p) = &gt; { this.name = p.name; } //例子 export const loadUserInfo = async (ouPath) =&gt; { const res = await service.get('/user/loadAdd', {params: {ouPath } }); return res; } export const loadEditUser = async (guid, ouPath) =&gt; { const res = await service.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e91bebb9bbcb97e31d06cdd875c85b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/603c74067eb5c5ab9ed49bd7cbc1f483/" rel="bookmark">
			[C语言]指针和数组（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、指针
访问内存是否只能通过变量来进行访问
我们知道程序中的变量只是一段存储空间的别名，那么是不是必须通过这个别名才能使用这段存储空间？
我们来看以前访问内存空间的方法： int a = 10; a = 20; 变量a占用4个字节的内存空间，我们要想改变这个段内存空间的值，需要将这个变量的值改成20，这个是通过变量的别名来访问内存的方法。我们再来看看一段代码：
#include &lt;stdio.h&gt; void test_pointer1() { int a = 10; int* pa = &amp;a; a = 20; printf("a = %d\n", a); *pa = 30; printf("a = %d\n", a); } int main() { test_pointer1(); return 0; } 来看看运行的结果：
可以看到我们通过*pa和a进行赋值是等效的。
指针的本质
（1） 指针在本质上也是一个变量
（2） 指针需要占用一定的内存空间
（3） 指针用于保存内存地址的值
我们来理解一下：
首先任何一种数据类型都可以理解为一种变量，指针也是一样的，其次既然指针是一种变量，那它就具有内存空间；既然指针也有内存空间，那它的内存空间应该要存放数据，这个数据就是和他对应变量内存的地址。我们来看看一段代码： void test_pointer2() { int b = 10; int* pb = &amp;b; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/603c74067eb5c5ab9ed49bd7cbc1f483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69db30c0405781209a7ee9fa0f071fae/" rel="bookmark">
			unity打包报错：The type name ‘AndroidJavaObject‘ could not be found in the namespace ‘UnityEngine‘.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity打包报错：The type name ‘AndroidJavaObject’ could not be found in the namespace ‘UnityEngine’. This type has been forwarded to assembly ‘UnityEngine.AndroidJNIModule, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null’ Enable the built in package ‘Android JNI’ in the Package Manager window to fix this error.
这个问题太简单了，答案就写在这里，还是没有仔细看清楚。就是上面粗体，以及下图所示。点enable就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74abe164c903fc28cf3d6dc31be7eb7/" rel="bookmark">
			零束科技获得中国信通院“2022安全守卫者计划优秀案例”奖项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		6月17日，中国信息通信研究院（以下简称“中国信通院”）正式发布2022安全守卫者计划优秀案例评选结果，凭借在车联网软件行业的实践经验和技术积累，零束科技应用的“车联网软件供应链安全实践”案例成功获得“2022安全守卫者计划优秀案例”奖项，这也是车联网软件行业唯一获奖的案例，为业界软件供应链安全工作的落地推进提供了参考。
一、零束“车联网安全管理平台”介绍
此次获奖的优秀案例解决方案，零束自研设计的“车联网安全管理平台”为核心组成部分：包括软件资产库、漏洞库、安全资产模型和风险评估处置模块，为态势感知平台输出资产清单，以获取关联的最新漏洞情报；漏洞情报经过资产模型关联和风险评估处置，得到相应的安全加固措施；如果安全加固涉及软件更新，则通过OTA系统升级实现，升级过程产生的资产更新继续同步给车联网安全管理平台，实现更新闭环。
二、零束“车联网安全管理平台”优势
1、构建结构化软件资产库
支持灵活构建数字模型，形成结构化的安全资产清单，支持快速定位安全漏洞的影响分布。
2、支持场景化漏洞风险评估
支持可视化车型拓扑构建和通信接口标识，提供基于攻击场景的漏洞风险评估，助力客户实现基于风险的漏洞管理。
3、支持多平台协同联动
支持与态势感知平台联动，可提供基于漏洞管理和事件管理的定制化安全运营服务，支撑车联网产品的全生命周期安全管理。
4、支持灵活适配
兼容不同需求，灵活适配域控版本和整车版本，满足不同客户场景需求。
持续为客户和用户创造价值，是零束存在的基石，零束科技自成立以来，聚焦研发智能车高附加值产品模块，为整车企业提供极具竞争力的全栈或平台解决方案。此次获评“2022安全守卫者计划优秀案例”，充分表明零束“车联网安全管理平台”解决方案具有行业示范作用和推广价值。未来，零束科技将继续加强自身基础技术能力建设，建立保障软件供应链安全的体系化方法，携手客户和合作伙伴，全力推动智能网联汽车产业安全生态体系构建，助力中国智能网联汽车产业健康发展。
三、关于“2022安全守卫者计划优秀案例”
为进一步促进软件供应链产业创新发展，提升企业软件供应链安全治理水平，中国信通院展开了“2022安全守卫者计划优秀案例——软件供应链安全专题”优秀案例征集活动，宣传推广一批成熟度高、具有示范作用的优秀案例。
更多智能车资讯，可关注零束科技“SOA开发者论坛”
地址：https://bbs.z-one.tech/omp/community/front/api/page/index
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887394352763c22cf8ded5871b521bb2/" rel="bookmark">
			Android 虚拟按键上报
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
本文主要讲述触摸屏上可能用到的虚拟按键menu、home、return，底层驱动的实现和相关实现原理，其中和上层有联系的只是概述。
两种实现方式
对于触摸按键的发送可以分为两种方法：
1. android提供的 virtualkey's 架构方法，
2. 直接报告key event的方法。
报告keyevent方法
在驱动中添加所支持的按键类型，报告支持事件类型
__set_bit(EV_SYN, input_dev-&gt;evbit); //同步事件
__set_bit(EV_KEY, input_dev-&gt;evbit); //按键事件
报告支持的按键
__set_bit(KEY_HOME, input_dev-&gt;keybit); // home按键
__set_bit(KEY_BACK, input_dev-&gt;keybit); // back按键
__set_bit(KEY_MENU, input_dev-&gt;keybit); // menu按键
触摸屏上的三个按键对应的坐标
(KEY_BACK) 120:1400
(KEY_HOME) 360:1400
(KEY_MENU) 500:1400
keyevent的报告方法很简单只要报告相应的 key 和设备同步sync就可以了
static void ft5x0x_report_value(struct ft5x0x_ts_data *data)
{
struct ts_event *event = &amp;data-&gt;event;
int i;
for (i = 0; i &lt; event-&gt;touch_point; i++)
{
if (event-&gt;au16_y[i]==1400)
{
if(event-&gt;au8_touch_event[i]== 0 || event-&gt;au8_touch_event[i] == 2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/887394352763c22cf8ded5871b521bb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8324ebbb067adbccc2b15ef79f9eda9/" rel="bookmark">
			springBoot中如何给敏感数据脱敏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、处理步骤1. 新建脱敏的枚举类2.新建脱敏操作的工具类3. 申明注解类4.注解的AOP操作5.实际使用6.可能遇到问题 总结 前言 在实际开发的过程中，我们可能会遇到一些敏感数据，但是用户又不希望这些敏感数据全部展示出来，所以这个时候就需要对数据进行脱敏处理
解决思路：新建一个注解了标签，用在实体类字段中，实现再查询数据时将数据替换成处理好的数据
一、处理步骤 1. 新建脱敏的枚举类 package com.fwy.common.config.dataRule; import lombok.Getter; /** * @description:隐私数据类型枚举 * @author: xiaYZ * @createDate: 2022/6/21 */ @Getter public enum PrivacyTypeEnum { /** 自定义（此项需设置脱敏的范围）*/ CUSTOMER, /** 姓名 */ NAME, /** 身份证号 */ ID_CARD, /** 手机号 */ PHONE, /** 邮箱 */ EMAIL, } 2.新建脱敏操作的工具类 package com.fwy.common.config.dataRule; /** * @description: * @author: xiaYZ * @createDate: 2022/6/21 */ public class PrivacyUtil { /** * 隐藏手机号中间四位 */ public static String hidePhone(String phone) { return phone.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8324ebbb067adbccc2b15ef79f9eda9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0ad06733ef52e5aa7df32cdfb7339a/" rel="bookmark">
			Mac如何读写NTFS硬盘，NTFSTool让Mac也可以轻松读写NTFS硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在了解Mac如何读写NTFS格式硬盘前，我们应该先了解什么是NTFS硬盘，以及Mac为什么不能对NTFS硬盘进行读写。
一、什么是NTFS硬盘
NTFS格式硬盘最早出现于1993年的win NT操作系统中，作为一款日志文件系统，除了可以对硬盘写入数据外，每次操作均保留修改日志，即便系统崩溃也非常容易恢复，而且不会丢失数据。
二、NTFS硬盘优点
1.安全性
NTFS格式硬盘相较于前辈FAT 32在安全性上做了不少的提升，可以支持加密文件系统——EFS，对未被授权的用户可以设置访问权限。
2.磁盘配额
在使用硬盘过程中，管理员可以划分用户可使用的磁盘空间大小。设置配额后，管理员还可以监控磁盘的使用情况，避免了磁盘空间使用失控，造成系统崩溃。
3.读写数据大
NTFS格式磁盘在储存空间上也有所提升，FAT 32格式的磁盘最大扩容仅能达到32GB，NTFS格式磁盘则也可以达到2TB。而且在数据传输过程中，FAT 32格式磁盘不能传输超过4GB的单个文件，而NTFS格式磁盘则完全可以胜任。
三、NTFS为什么不能被Mac读写
Mac的硬件与操作系统均是由苹果公司开发，而NTFS硬盘虽然有诸多优点，但它是由微软公司研发的，出于产权保护，微软公司未公开NTFS技术专利。如此在两套系统之间便存在了一道壁垒，当我们将NTFS硬盘连接到Mac后便仅有“只读”权限，并不能写入数据。
NTFS硬盘读写工具哪个好呢？NTFSTool for Mac一款mac mian费的ntfs读写工具，支持NTFS磁盘读写、挂载，推出、管理等功能。它的界面简洁易用，希望这款工具能够为你的工作和生活带来便利。NTFSTool xia载使用这款NTFS硬盘读写工具吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ecbc324f1ac32c18df070549b8625d7/" rel="bookmark">
			大佬算法博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.redblobgames.com/
A*算法来源于此
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369690cc630baedce6ca6d352069996a/" rel="bookmark">
			web技术分享| 【高德地图】实现自定义的轨迹回放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现(轨迹回放)方式有两种： 第一种是使用 JS API 和 AMap.PolyLine（折线）等图形配合实现。第二种是使用 JS API 和 AMapUI 组件库 配合使用，利用 PathSimplifier（轨迹展示组件）绘制出行动轨迹。 方案选择 以上两种实现方式我们可以根据两个因素 来决定哪一种更加适合自己：节点数量 的多少、排布的密集度 。
前者适合节点数量较少，排布比较稀松，例如，出租车轨迹回放，出租车行驶速度快，周期上报的时间也会相对较长。后者更加针对节点数量巨大、排布密集的路径，按秒记录位置的飞机行进轨迹，精细的地理边界等等。
实现流程 无论选择两种方式，我们都需要先收集到客户端上报的信息，这些信息可以自定义，通常我们会包含：经纬度、速度、逆编码之后的地理位置、方向、海拔 等基本地理信息，同时我们也可以加入一些自定义 的信息，例如：人员信息（头像昵称等）、出行信息（订单等）。
实现的流程：
客户端按（时间）周期上报地理信息以及自定义信息。服务端按时间轴存储客户上报的信息。按（时间等）条件查询出用户的轨迹，并通过简化算法去除一部分节点（例如，节点距离十分微小、或者多个点都在同一条直线、3点之间，其中一点略有偏差无法绘制成直线等等），最终获得适合绘制的路径（数组）。根据路径去绘制用户的行动轨迹。 路径简化算法（可选） 客户端上报的数据是按时间周期上报的，也就是说每个时间都对应了一个经纬度，经纬度在地图上就是一个又一个点，将这些点连接时，我们会得到 N 多条折线，为了绘制的轨迹更加美观，行动路线更加明确平滑，通常我们需要一个算法来简化折线。
例如：
A 点和 B 点，两者距离不到 1 像素，则可以去掉 B 点，只留 A 点。A，B，C 三点在一条直线上，或者，B 点仅仅稍微偏离 A 点和 C 点构成的线段，那么 B 点就可以去掉。 这里官方也推荐了一种算法库 simplify.js供大家参考，这里不做过多的阐述。
实现示例 车辆轨迹回放 这里我们使用第一种方式来实现 - 利用 JS API 和 AMap.PolyLine。
实现原理： 在地图上绘制车辆标记（AMap.Marker）。利用 AMap.PolyLine 绘制出两条轨迹：历史轨迹和驾驶途径过的轨迹，以颜色区分。按照一定的速度使车辆前进，并监听 Maker 移动的事件，在事件回调中，将车辆（Marker）位置设置为地图中心点，给使用者视觉主观上一种车辆在前进的感觉，同时延长驾驶途径过的轨迹。对于实现场景比较复杂的，需要进行自定义处理的比如： 查看每个节点的数据，我们可以把每个节点给绘制出来，节点被点击时显示该节点的数据。移动倍速播放，首先按上报的时间间隔来播放，选择倍速之后，改变 MarKer 移动的 duration。其他自定义。 自定义 API 我们可以让车辆：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/369690cc630baedce6ca6d352069996a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dda8d00218ebf917ea48ae1b6fb05cd/" rel="bookmark">
			Vue解决导出pdf文件图片展示不全问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：我们在开发过程中经常会碰见pdf导出不全的问题，今天我就来分享两个简单粗暴的方法，大家可以尝试一下 说个偷懒的办法，直接调用window.print() 方法就可以开启浏览器自带的打印功能。
如果还需要只截取网页部分可以在截图前将body替换掉，方法有很多可自行百度。
下面在说一种方法
首先引入两个工具，这里借用jspdf和html2canvas两个工具生成
这里是下载链接https://download.csdn.net/download/sunyv1/12424774
我们直接奔主体： 这个问题大概是由于html2canvas生成图片的时候不全导致的。我也是找了许多解决方案，下面分享两个：
1.显示被截取的元素绝不能有 overflow: hidden;，否则超出的部分就无法截取。
2.超过屏幕的部分截取异常，但是把屏幕滑到最顶端截取就正常了(我也不知道html2canvas出什么毛病)。既然是这样那就在截取之前加入以下代码，强制跳到顶端就能解决了。 window.pageYOffset = 0; document.documentElement.scrollTop = 0 document.body.scrollTop = 0; 这段代码可以放创建canvas节点前面 比如我写的时候是放在了如下图：(因为工作环境的原因，导出pdf的整体代码就不在这里一一奉上了，可以自行百度)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec53aa623be96dc1d4c0381bcda98ed3/" rel="bookmark">
			IntelliJ IDEA中有什么让你相见恨晚的好用插件?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，大家好，我是 Jackpop，硕士毕业于哈尔滨工业大学，曾在华为、阿里等大厂工作，如果你对升学、就业、技术提升等有疑惑，不妨交个朋友：
我是Jackpop，我们交个朋友吧！
IntelliJ IDEA在开发者中的受欢迎程度，想必不用多说。
开箱即用、功能强大，备受欢迎。
虽然IDEA已经提供了丰富的功能，但是，我们仍然可以通过配置插件来满足个性化的需求。
JetBrains Marketplace 上有着大量实用插件，但是，并非每个都称得上优秀。
今天，就给大家精选12款非常好用的IDEA插件。
1. CamelCase 命名规范对于编程语言重要，而且不同编程语言有不同的命名规范要求。有的要求驼峰命名，有的要求下划线命名。
通过CamelCase这款插件，我们可以在CamelCase, camelCase, snake_case, 和 SNAKE_CASE之间进行切换，只需要点击SHIFT + ALT + U，不需要手动逐个的去修改变量和函数名称，能够极大的提高效率。
2. Rainbow Brackets 开发过程中经常会用到各种各样的括号，大括号、中括号、小括号，层层嵌套，阅读和编码时让人眼花缭乱。
Rainbow Brackets为你提供了基于IntelliJ的IDE的美丽和优雅的彩虹括号。
这是一个很棒的插件，可以在开发你的应用程序时提高视觉体验，能够轻松识别出配对的括号。
3. Codota Codota是一款基于AI的代码自动补全工具，它根据数以百万计的开源Java程序和代码的上下文自动补全代码行，帮助你更快地编码，减少错误。
它提供全行AI自动完成，内联和相关的代码示例，以及基于你自己的编码实践的代码建议。
4. Nyan Progress Bar 等待构建项目时百无聊赖、枯燥乏味吗？
Nyan Progress Bar一个很酷很有趣的插件，它为基于IDEA增加了漂亮的进度条与Nyan猫。
这个插件使你的IDE在构建你的应用程序时更加优雅和可爱!
5. Presentation Assistant ​
这个插件显示你调用的任何动作的名称和快捷方式（Win/Mac）。
有很多时候，我们记不住一些操作以及快捷方式，通过这款插件，可以提高IntelliJ Idea的生产力。
6. Code Iris ​
这个插件将你的项目中的模块、包和类可视化。
它就像一个基于UML的 “谷歌地图”，能够应用于你的源代码。
它将模块、类、包和依赖关系可视化。
7. Rainbow CSV ​
CSV文件在开发过程中经常用于读写数据，我们可以Excel、Sublime等工具打开CSV文件。
但是，这样可视化效果较差，因此，使得效率大大降低。
Rainbow CSV是一个很酷的插件，可以用不同的颜色突出显示CSV文件。
它以不同的彩虹色突出显示CSV文件。
8. SmarterEditor 这个插件使你在使用IntelliJ时更有效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec53aa623be96dc1d4c0381bcda98ed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b477c0817ce422a8b705806fc90f179/" rel="bookmark">
			AirBuddy让您优雅的在 Mac 上使用 AirPods
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AirBuddy 是macOS系统上将iOS上的AirPods体验带到了Mac上。使用AirBuddy，您可以打开Mac旁边的AirPods外壳并立即查看状态，就像在iPhone或iPad上一样。
Airbuddy for mac是一款功能高效的AirPods耳机管理工具，可以帮助你体验AirPods及Beats无线耳机的应用。Airbuddy Mac po解版使用非常简单，只需启动后确保勾选即可，你还可以选择让他支持其他 W1 芯片耳机，并且选择连接 AirPods 时通知窗口的屏幕位置。还在等什么？AirBuddy Mac po解版吧！
常见问题 1、我需要运行AIrBuddy的最低macOS版本是什么？
AIrBuddy在macOS Mojave（10.14）或更高版本上运行。
2、有没有系统要求？
有。您的Mac必须支持蓝牙LE。一般来说，如果Handoff，Apple Watch解锁以及类似功能在Mac上运行，则意味着它支持BLE。
3、它能否显示其他设备（如iPhone和iPad）的电池状态？
能。请注意，您的移动设备必须至少已连接到Mac一次，并且必须在设备上“信任”Mac。在初始配对之后，设备可以通过Wi-Fi进行通信。您还可以启用与iTunes的Wi-Fi同步，以确保您的iPhone或iPad可以无线方式与Mac通信。
4、Apple Watch，Apple Pencil，Apple TV遥控器和其他设备怎么样？
这些目前不受支持。
5、我如何获得更新？
该应用程序会自动检查更新，并在可用时向您显示警报。
6、我在Mac附近打开了我的AIrPods机箱，状态窗口没有显示出来。为什么？
您应该检查的第一件事是您的设置中是否启用了状态窗口。要编辑您的设置，只需启动AIrBuddy即可。除此之外，该应用程序使用几种启发式方法来确定是否显示状态窗口，包括设备与Mac的距离，设备当前是否正被其他设备使用（如从iPhone播放音乐）等。设备显示在Notification Center小部件中，这意味着AIrBuddy已经看到它并决定不显示状态窗口！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15a6a3908f52910758f1860765db186/" rel="bookmark">
			CSP漫画工作室clipstudiopaint最新版本2022功能介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac上有什么好用的漫画绘画软件吗？为您推荐Clip Studio Paint for Mac，clip studio paint po解版是mac os系统上一款专注于插画绘制的软件，也可以用来进行漫画创作，是目前世界上领先的漫画和漫画创作软件，能够提供众多好用又实在的工具，如果你是一位专业漫画加或者漫画艺术家，那么这款强大的软件将帮助你完成漫画的绘制。为您带来clip studio paint ji活版下载！
clip studio paint ji活版功能 1、呈现手绘笔触的向量线条
向量图层异于一般的图层，使用向量图层可以不受限制地编辑线条，是平面设计和专业工作上不可或缺的存在。请务必体验CLIP STUDIO PAINT灵活的向量功能和自然的描绘笔触。
2、专属于你的艺术风格
从拟真水彩画、浓厚油画到动画风格的上色方式，你可以在笔刷自由的设定中找到与自己最契合的完美工具。欢迎在多彩的笔刷前端、材质还有水彩的边缘效果中进行探索。
3、让图案和视角更简单
使用高性能的尺规让对称和透视更简单，适用于制作复杂的图案和复杂的背景时。这些技术工具能满足你的需求，提供最畅快的绘画过程。
4、将照片和3D模组自动转换为线稿
可以将图像和3D模组自动转换为线稿，再进行加笔和上色来轻松地增添内容。CLIP STUDIO ASSETS上大量的素材让你的灵感源源不绝。
5、瞬间转换网点
可以在一瞬间将任何图像转换为网点，替你的创作增添独特性，在制作漫画和POP艺术时是不可或缺的一项功能。能用来黏贴黑白漫画的阴影网点，或制作经典的班戴点风格。
6、一眼看尽所有页面
利用CLIP STUDIO PAINT EX的页管理功能，能建立整本漫画或美术书籍。完成作品后，你可以在装订3D预览上进行确认，或使用能够浏览多页作品的线上阅读器CLIP STUDIO SHARE来发布作品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/152c1b9f8e4cfbf8fea75ae7cdbe9d64/" rel="bookmark">
			Hbase 深度使用分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版本描述：Hbase 2.X 版本 CRUD场景描述： 批量新增数据 循环put...那是不可能的..可以使用put(List&lt;Put&gt; puts) 需要注意的是当一部分数据插入成功后，此时某个RegionServer出现异常，之前的数据是不会回滚的，对于插入失败的数据hbase默认会进行重试直到到达最大重试次数还是失败即会结束重试（失败数据在写缓冲区），不过如果列族错误了，那么不会进行重试，直接抛出异常
批量查询数据 get(List&lt;Get&gt; gets) 返回一个Result数组，如果一部分数据失败，一部分数据查询成功，最终hbase还是会返回异常，如果你希望不要抛出异常而是返回成功部分的数据，那么可以使用batch接口进行查询
Scan 扫描查询 常见的OLTP数据库，最常用的就是各种join语法，不过在hbase可不支持这种语法，那么当我们需要通过部分条件查询批量数据的时候就会用到scan命令，不过考虑到性能那么我们一般使用scan(byte[] startRow,Filter filter) 这里的filter是用来翻页的，这个时候hbase会返回一个ResultScanner对象（这个时候hbase还没有真正的去scan数据，只是返回了你这个构建器对象而已）
Hbase 数据结构： Namespace（表命名空间），可以直接使用默认值，不过一般你的表特别多并且可以分不同场景管理的时候才需要考虑设置，方便对一种纬度的批量表进行统一管理Table（表），一个表由一个或者多个列族组成，很多表的属性都可以在列族中指定，列入TTL、压缩算法等Row（行），一个行包含了许多列，这些列通过列族来分类Column Family（列族），列族是多个列的集合，列族最大的最用是为了将一个场景/纬度下的列放在一个节点进行维护，这样可以提高性能和降低hbase架构复杂度列，多个列组成一个行，列可以随意定义，一个行中的列不限名字、不限制数量，只限定列族Cell（单元格），一个列中可以存储多个版本的数据，每个版本就是一个单元格，相比传统数据库，hbase数据库的数据颗粒度更加细小，同一个数据还存在多个版本Timestamp（时间戳/版本号），可以定义自己的版本号 当然hbase也和常见数据库一样有一个行数据主键（Rowkey），每一个行都有一个rowkey，这个是按照字典排序的
Hbase必知概念： WAL（预写日志），当写操作到达Region的时候，hbase会先将数据WAL，这个也是hbase用来故障恢复的依赖，因为hbase的写缓冲区是在内存中的，需要积累一定量的数据后才会刷写，那么这段时间如果Down机了，那么数据就会没了，所以才有了WAL
Region 这个相当于数据库的分区表或者mongo的分片概念，每一个Region都有起始rowkey和结束rowkey，代表了当前分区存储的范围，这个就和很多MQ的commitlog存储形式一样，每一条消息的头部字节都存储了当前消息的长度和结束位置
一个region包含多个store，一个store对应一个列族的数据，如果一个表有2个列族，那么在一个region里面就有2个storestore内部有menstore和hfile组成 很多MQ架构中都提供了异步刷盘/同步刷盘机制，其实hbase的WAL也和这个是一样的逻辑，WAL同样提供了异步/同步方式，同步方式对性能损耗较大但是数据100%安全，根据自己业务场景的实际需要改变
我刚开始的时候也有一个疑问，这种架构总觉得怪怪的，后来我发现是我肤浅了，我的疑问是：数据先写到WAL中，然后内存store汇聚数据，在写道hfile中，但是WAL和HFile的存储介质都是HDFS，那么不是有点多此一举么，其实这么设计的问题在于数据的顺序性，因为HDFS上的文件不能编辑，而数据库数据存放的顺序性是很重要的，如果我们数据一到就写到HDFS中，那么你很难保障数据的是顺序的，那么Menstore的价值就是在于内存整理顺序批量一次性的写到硬盘，那么这批数据的顺序性就是有保障的
HFile，hbase数据存储的实际载体 HFile是由一个个块组成的，默认每个块64KB
Data块：数据块，表中的数据就在这里Meta：元数据块FileInfo：文件信息，这里面描述了最后一个key等信息DataIndex：存储Data块的索引信息，索引的偏移值 Hbase之疑问？ hbase是一个随机读写数据库，并且上面也说到HDFS时不支持编辑文件内容的，那么hbase怎么完成CRUD的？
其实hbase基本都一直再做新增操作，刚刚说道CELL是多份的，当你编辑的时候其实hbase新增了一份cell，只是内部的版本号信息比之前的大，当你删除一条数据的时候，hbase还是做了新增操作，只是这条数据没有value，并且类型是DELETE，常用术语墓碑标记
那么疑问又来了，一直在做insert操作，第一个是垃圾数据会非常的庞大，第二个是数据的顺序性肯定不对了，其实hbase每隔一段时间会进行一次合并（这个操作和CK很类似）合并分为两种类型（minor和major）major合并过程中如果发现墓碑标记，那么就会忽略这条数据，这个时候这条数据才是真正的被物理删除了
Hbase数据的读取 Hbase实际的读取顺序是先从BlockCache中找数据，找不到了再去Memstore和HFile中查询数据。
由于HDFS的文件不可变特性，你不可能在一个KeyValue被新建之后删除它，HBase所能做的也就是帮你加上一个墓碑标记。但是你别忘了HDFS是不能修改的，所以墓碑标记和数据不在一个存储地，所以当我们再用Scan进行数据扫描读取的时候，就算已经查到了用户分页指定数据，hbase还是会继续往后扩大的读取，因为只有这样才能知道是否存在墓碑标记，所以性能最高的scan方式是加上起始-结束标记，这样可以限定hbase扩展读取的范围
在Scan扫描的时候store会创建StoreScanner实例。StoreScanner会把MemStore和HFile结合起来扫描，所以具体从MemStore还是HFile中读取数据，外部的调用者都不需要知道具体的细节。当StoreScanner打开的时候，会先定位到起始行键
Client - Region
最早期的hbase采用了三层查询方式，现在已经废弃了因为代码复杂还没啥实际意义
现在已经变成了两层查询方式，
客户端先通过ZooKeeper的/hbase/meta-region-server节点查询到哪台RegionServer上有hbase:meta表。客户端连接含有hbase:meta表的RegionServer。hbase:meta表存储了所有Region的行键范围信息，通过这个表就可以查询出你要存取的rowkey属于哪个Region的范围里面，以及这个Region又是属于哪个RegionServer。获取这些信息后，客户端就可以直连其中一台拥有你要存取的rowkey的RegionServer，并直接对其操作。客户端会把meta信息缓存起来，下次操作就不需要进行以上加载hbase:meta的步骤了。 Hbase 进阶 过滤器，在scan查询的时候经常用到，可以看成SQL语句中的where条件，在遍历过程中，不满足filter条件的数据就会被过滤
过滤器的模糊值匹配 //这段代码等同于SQL中like '%boluo%' Filter filter = new ValueFilter( CompareOperator.EQUAL, new SubstringComparator( "boluo" ) ); 上面那段代码会有个小问题就是一个列族下其他列也满足这个条件的话数据也会被捞出，那么指定列进行值匹配的话需要看下面的代码
//这段代码等同于SQL中name like '%boluo%' Filter filter = new SingleColumnValueFilter( Bytes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/152c1b9f8e4cfbf8fea75ae7cdbe9d64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffad562494e77a65c1fb5a820b265514/" rel="bookmark">
			Unity基础——List的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、List的方法和属性 Capacity： 用于获取或设置List可容纳元素的数量。当数量超过容量时，这个值会自动增长。您可以设置这个值以减少容量，也可以调用trin()方法来减少容量以适合实际的元素数目。　Count： 属性，用于获取数组中当前元素数量　Item()： 通过指定索引获取或设置元素。对于List类来说，它是一个索引器。　Add()： 在List中添加一个对象的公有方法　AddRange( ) 公有方法，在List尾部添加实现了ICollection接口的多个元素　BinarySearch()： 重载的公有方法，用于在排序的List内使用二分查找来定位指定元素.　Clear()： 在List内移除所有元素　Contains()： 测试一个元素是否在List内　CopyTo()： 重载的公有方法，把一个List拷贝到一维数组内　Exists()： 测试一个元素是否在List内　Find()： 查找并返回List内的出现的第一个匹配元素　FindAll()： 查找并返回List内的所有匹配元素　GetEnumerator()： 重载的公有方法，返回一个用于迭代List的枚举器
Getrange()： 拷贝指定范围的元素到新的List内
IndexOf()： 重载的公有方法，查找并返回每一个匹配元素的索引
Insert()： 在List内插入一个元素
InsertRange()： 在List内插入一组元素
LastIndexOf()： 重载的公有方法，查找并返回最后一个匹配元素的索引
Remove()： 移除与指定元素匹配的第一个元素
RemoveAt()： 移除指定索引的元素
RemoveRange()： 移除指定范围的元素
Reverse()： 反转List内元素的顺序
Sort()： 对List内的元素进行排序
ToArray()： 把List内的元素拷贝到一个新的数组内　trimToSize()： 将容量设置为List中元素的实际数目
二、List的用法 1、List的基础、常用方法：
(1)、声明：
List&lt;T&gt; mList = new List&lt;T&gt;();
①、T为列表中元素类型，现在以string类型作为例子。
List&lt;string&gt; mList = new List&lt;string&gt;(); **List&lt;T&gt; testList =new List&lt;T&gt; (IEnumerable&lt;T&gt; collection);** ②、以一个集合作为参数创建List：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffad562494e77a65c1fb5a820b265514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4abbeaf1cf2200e1dc14da90734878c/" rel="bookmark">
			windows 环境下打包为exe 与 playwright 代码带浏览器独立打包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 step1:建立playwright python虚拟环境step2: 安装需要的包step3 打包 step1:建立playwright python虚拟环境 新建虚拟环境可以在使用pyinstaller 打包时只打包环境内用到的相关包，减少打包的程序大小。
conda create -n py_venv_wright python==3.7 conda activate py_venv_wright 注意:如果activate后 pip list 仍然是全局的包的列表，需要在运行pip 命令和 Pyinstaller 、playwright 命令时 指定 虚拟环境下该命令的位置 + 命令参数 如:
d:\envs\venv_pyw\Scripts\pip.exe install pywin32
d:\envs\venv_pyw\Scripts\pip.exe install playwright
d:\envs\venv_pyw\Scripts\playwright.exe install chromium
d:\envs\venv_pyw\Scripts\pyinstaller.exe -F -i logo.ico xxxyyy.py --exclude-module pydoc
step2: 安装需要的包 pip install playwright pip install pyinstaller pip install pywin32 pip install other_packages_you_need step3 打包 准备好写好的python 程序代码，在cmd 命令窗口下运行，准备好logo.ico文件（应用程序图标文件也可以不用，可以在这个网站上上传图片转换为ico文件: https://www.bitbug.net/），
set PLAYWRIGHT_BROWSERS_PATH=0 playwright install chromium # 如果报错 PyInstaller.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4abbeaf1cf2200e1dc14da90734878c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/259/">«</a>
	<span class="pagination__item pagination__item--current">260/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/261/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>