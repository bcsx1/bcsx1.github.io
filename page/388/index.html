<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5d561d49bf43c3c060b5b4c076c504a/" rel="bookmark">
			Pytest 测试框架——数据驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 前面已经和大家介绍过 Unittest 测试框架的数据驱动框架 DDT，以及其实现原理。今天和大家分享的是 Pytest 测试框架的数据驱动，Pytest 测试框架的数据驱动是由 pytest 自带的pytest.mark.parametrize()来实现的。
pytest.mark.parametrize 实现数据驱动 pytest.mark.parametrize 是 pytest 的内置装饰器，它允许你在 function 或者 class 上定义多组参数和 fixture 来实现数据驱动。
@pytest.mark.parametrize() 装饰器接收两个参数：
第一个参数以字符串的形式存在，它代表能被被测试函数所能接受的参数，如果被测试函数有多个参数，则以逗号分隔；
第二个参数用于保存测试数据。如果只有一组数据，以列表的形式存在，如果有多组数据，以列表嵌套元组的形式存在（例如：[1,1]或者[(1,1), (2,2)]）。
针对装饰器的单参数和多参数，分别举例如下。
1.pytest.mark.parametrize 单参数
# test_singal.py import pytest @pytest.mark.parametrize("number", [1, 0]) def test_equal(number): assert number == 1 if __name__ == "__main__": pytest.main([]) 以上是单参数的一个例子，在这个例子中，test_equal 函数接收一个参数 number，这个参数有两组数据，分别是 1 和 0。
tips：
装饰器 pytest.mark.parametrize 的第一个参数里的参数名称必须与测试函数中的参数称保持一致。
即：test_equal这个函数方法的参数 number 必须与装饰器里的第一个参数的名称 number 保持一致。
运行以上代码，结果如下图所示：
￼
可以看到，函数 test_equal 提供了两组参数 1 和 0，所以它也执行了 2 次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5d561d49bf43c3c060b5b4c076c504a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2e66717e81b45b8dfdc912a851d1cac/" rel="bookmark">
			使用思科模拟器设计和配置校园网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、设计和配置校园网络二、知识总结三、网络设计1.接入层设计2.汇聚层设计 工程实现总结 一、设计和配置校园网络 网络至少包含三台路由器、一台三层交换机(实现其下 VLAN 间的互访)、 2 台 以上二层交换机和若干 PC，配置相应的路由协议（至少包含两种），按自主设计内容实现 VLAN 间主机的互访及不同路由器下主机的互连互通；网络应包括 ACL 和 NAT 设计内容。 二、知识总结 交换机：
二层交换机：属于数据链路层设备，自学习生成转发表，并根据此表进行数据帧的转发或过滤。
三层交换机：除了拥有二层交换机的数据帧转发功能外，一般还能使用网络层的IP协议实现路由等功能。
VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的LAN在逻辑上划分成多个广播域的通信技术。
Access接口：交换机上用来连接用户主机的接口，它只能连接接入链路；命令为： switchport mode access。
Trunk接口：交换机上用来和其他交换机连接的接口，它只能连接干道链路（Trunk Link：汇聚链接）命令为： switchport mode trunk。
VTP有三种模式，server、client、transparent。其中：
server模式：server交换机上创建的vlan信息会同步给其他模式交换机，可增、删、改、转发、始发和学习等
client模式：会同步学习VTP，自动修改vlan配置，但不能增、删、改信息
Transparent模式：会转发同步配置，但不学习，可增、删、改信息、始发。
命令为： vtp mode server
三层交换机的三层接口
物理三层接口：既可工作在二层（默认），也可以工作三层（需要用命令启用，即在端口配置下：no switchport）
逻辑三层接口（交换虚拟接口SVI）:包括三层VLAN接口和路由子接口，专门用于VLAN子网之间通信。
路由器：
路由器属于三层设备即网络层设备，它根据分组的目的IP地址选择本地端口进行分组的转发，可能还具有一些高层（传输层）的功能。
单臂路由（router-on-a-stick）是指在路由器的一个接口上通过配置逻辑接口的方式，实现原来相互隔离的不同VLAN（虚拟局域网）之间的互联互通。
静态路由：由网络管理员手工添加、配置的路由信息。
路由信息协议（Routing Information Protocol，RIP）是一种基于距离矢量算法的路由协议，以跳数（每经过一个路由器称为一跳）作为路由选择的依据，跳数最小的路由就是最好的路由。
OSPF（Open Shortest Path Fitst，开放最短路径优先）协议是一个内部网关协议，用于在单一自治系统内决策路由，是对链路状态路由选择算法的一种实现。
网络安全：
访问控制列表（Access Control Lists，ACL）是应用在路由器、三层交换机接口的指令列表，不但可以起到控制网络流量、流向的作用，而且在很大程度上起到保护网络设备、服务器的关键作用，作为外网进入内网的第一道头卡，路由器上的访问控制列表成为保护内网安全的有效手段。
网络地址转换（NAT，Network Address Translation）属接入广域网（WAN）技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。NAT不仅完美地解决了lP地址不足的问题，还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。
服务器应用：
DNS服务器：提供域名解析为ip地址的服务
DHCP服务器：动态的为客户端的计算机分配IP地址参数
Web服务器：客户端可以通过各种Web浏览器请求得到Web服务器的信息服务
三、网络设计 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2e66717e81b45b8dfdc912a851d1cac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07b4d25806c47016f1cd1033d667be8d/" rel="bookmark">
			【python】txt记事本转为excel表格，超快超方便
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		txt记事本转为excel表格，太简单啦！！！
使用python将txt格式转化为xls，火箭般的速度，就转化好了！！！
完整代码：
# -*- encoding: utf-8 -*- import xlwt def txt_xls(filename, xlsname): try: f = open(filename, 'r', encoding='utf-8') xls = xlwt.Workbook() sheet = xls.add_sheet('sheet1', cell_overwrite_ok=True) x = 0 while True: # 按行循环，读取文本文件 line = f.readline() if not line: break for i in range(len(line.split('\t'))): item = line.split('\t')[i] sheet.write(x, i, item) x += 1 f.close() xls.save(xlsname) # 保存xls文件 except: raise if __name__ == "__main__": filename = "a.txt" #需要转化的文件 xlsname = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07b4d25806c47016f1cd1033d667be8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c89980047005d145b2ab705cb9d78e/" rel="bookmark">
			access口 环路_交换机三种端口模式Access、Hybrid和Trunk的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原标题：交换机三种端口模式Access、Hybrid和Trunk的理解
很多朋友一直在问到交换机的几种端口具体是什么作用，这个确实在我们平时中很多朋友容易忽略，那么我们今天来了解下这方面的内容。
以太网端口有 3种链路类型：access、trunk、hybird
Access类型端口：只能属于1个VLAN，一般用于连接计算机端口；
Trunk类型端口：可以允许多个VLAN通过,可以接收和发送多个VLAN 报文,
一般用于交换机与交换机相关的接口。
Hybrid类型端口：可以允许多个VLAN通过，可以接收和发送多个VLAN 报文，
可以用于交换机的间连接也可以用于连接用户计算机。
首先，将交换机的类型进行划分，交换机分为低端(SOHO级)和高端(企业级)。
其两者的重要区别就是低端的交换机每一个物理端口为一个逻辑端口，而高端交换机则是将多个物理端口捆绑成一个逻辑端口再进行的配置的。
例如
cisco网络中，交换机在局域网中最终稳定状态的接口类型主要有四种：access/trunk/ multi/ dot1q-tunnel。
1、access: 主要用来接入终端设备，如PC机、服务器、打印服务器等。
2、trunk: 主要用在连接其它交换机，以便在线路上承载多个vlan。
3、multi: 在一个线路中承载多个vlan，但不像trunk,它不对承载的数据打标签。主要用于接入支持多vlan的服务器或者一些网络分析设备。现在基本不使用此类接口，在cisco的网络设备中，也基本不支持此类接口了。
4、dot1q-tunnel: 用在Q-in-Q隧道配置中。
什么是链路类型？
vlan的链路类型可以分为接入链路和干道链路。
1、接入链路(access link)指的交换机到用户设备的链路，即是接入到户，可以理解为由交换机向用户的链路。由于大多数电脑不能发送带vlan tag的帧，所以这段链路可以理解为不带vlan tag的链路。
2、干道链路(trunk link)指的交换机到上层设备如路由器的链路，可以理解为向广域网走的链路。这段链路由于要靠vlan来区分用户或者服务，所以一般都带有vlan tag。
什么是端口类型？
端口类型在以前主要分为两种，基本上用的也是access和trunk这两种端口。
1、access端口：它是交换机上用来连接用户电脑的一种端口，只用于接入链路。例如：当一个端口属于vlan 10时，那么带着vlan 10的数据帧会被发送到交换机这个端口上，当这个数据帧通过这个端口时，vlan 10 tag 将会被剥掉，到达用户电脑时，就是一个以太网的帧。而当用户电脑发送一个以太网的帧时，通过这个端口向上走，那么这个端口就会给这个帧加上一个vlan 10 tag。而其他vlan tag的帧则不能从这个端口上下发到电脑上。
2、trunk端口：这个端口是交换机之间或者交换机和上层设备之间的通信端口，用于干道链路。一个trunk端口可以拥有一个主vlan和多个副vlan，这个概念可以举个例子来理解：例如：当一个trunk端口有主vlan 10 和多个副vlan11、12、30时，带有vlan 30的数据帧可以通过这个端口，通过时vlan 30不被剥掉；当带有vlan 10的数据帧通过这个端口时也可以通过。如果一个不带vlan 的数据帧通过，那么将会被这个端口打上vlan 10 tag。这种端口的存在就是为了多个vlan的跨越交换机进行传递。
也可以看出，这两种链路方式恰好对应两种端口方式，理解起来也不算困难。原理理解了，当看到交换机时，配置几遍就完全明白了。
access和truck 主要是区分VLAN中交换机的端口类型
truck端口为与其它交换机端口相连的VLAN汇聚口，access端口为交换机与VLAN域中主机相连的端口。
trunk一般是打tag标记的,一般只允许打了该tag标记的vlan 通过,所以该端口可以允许多个打tag标记的vlan 通过，而access端口一般是untag不打标记的端口,而且一个access vlan端口只允许一个access vlan通过。
access,trunk,hybid是三种端口属性；
具有access性质的端口只能属于一个vlan，且该端口不打tag；
具有trunk性质的端口可以属于多个vlan，且该端口都是打tag的；
具有hybid性质的端口可以属于多个vlan，至于该端口在vlan中是否打tag由用户根据具体情况而定；
交换机三种端口模式Access、Hybrid和Trunk的理解
端口有三种模式：access，hybrid，trunk。access性质的端口只能属于一个vlan，且该端口不打tag，trunk可以属于多个vlan，可以接收和发送多个vlan的报文，一般用于交换机之间的连接;hybrid也可以属于多个vlan，可以接收和发送多个vlan的报文，可以用于交换机之间的连接也可以用于交换机和用户计算机之间的连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46c89980047005d145b2ab705cb9d78e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/771df7fd469c4e7dc6986d31285a02d4/" rel="bookmark">
			【吊打面试官】字节跳动spring boot高频面试题（最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 什么是 Spring Boot？Spring Boot 有哪些优点？Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？配置 什么是 JavaConfig？Spring Boot 自动配置原理是什么？你如何理解 Spring Boot 配置加载顺序？什么是 YAML？YAML 配置的优势在哪里 ?Spring Boot 是否可以使用 XML 配置 ?spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?什么是 Spring Profiles？如何在自定义端口上运行 Spring Boot 应用程序？安全 如何实现 Spring Boot 应用程序的安全性？比较一下 Spring Security 和 Shiro 各自的优缺点 ?Spring Boot 中如何解决跨域问题 ?什么是 CSRF 攻击？监视器 Spring Boot 中的监视器是什么？如何在 Spring Boot 中禁用 Actuator 端点安全性？我们如何监视所有 Spring Boot 微服务？整合第三方项目 什么是 WebSockets？什么是 Spring Data ?什么是 Spring Batch？什么是 FreeMarker 模板？如何集成 Spring Boot 和 ActiveMQ？什么是 Apache Kafka？什么是 Swagger？你用 Spring Boot 实现了它吗？前后端分离，如何维护接口文档 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/771df7fd469c4e7dc6986d31285a02d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6b4543e936ca839de2bca68600c791/" rel="bookmark">
			c# List去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 ： 对List集合中的元素去重。实现： 有三种方式可以使用
- 使用Linq中distinct（）方法
- 借助hashset
- 使用for循环遍历，这种方法在数据量大时，运行速度比较慢 代码示例
使用distinct（） //使用distinct() List&lt;string&gt; lst1 = new List&lt;string&gt;() { "as", "lio", "sdrf", "asd", "lio" }; var reslst =lst1.Distinct().ToList(); 使用hashset public static List&lt;T&gt; RemoveT&lt;T&gt;(List&lt;T&gt; items) { HashSet&lt;T&gt; set = new HashSet&lt;T&gt;(); var res = new List&lt;T&gt;();//返回 for (int i = 0; i &lt; items.Count; i++) { if (!set.Contains(items[i])) { set.Add(items[i]); res.Add(items[i]); } } return res; } 使用for-loop public static List&lt;string&gt; ForLoopRemove(List&lt;string&gt; items) { List&lt;string&gt; output = new List&lt;string&gt;(); for (int i = 0; i &lt; items.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa6b4543e936ca839de2bca68600c791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6de126a7dc4c77b069b4e6e6c1d91829/" rel="bookmark">
			2021 音视频技术趋势不完全预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The Economist （经济学人）在 The World in 2021 特别刊的编者序中写到：“21 是一个与好运、冒险、机遇和掷骰子有关的数字 —— 它是一个标准骰子六面数字相加的总和（即前6个自然数——1 + 2 + 3 + 4 + 5 + 6 = 21——的和，也称三角形数）”。
维基百科又告诉我们，21 是库德族旗帜中太阳光线的数量；是化学元素钪的原子序数；是斐波那契数列的最小非平凡数；是用于 FTP 连接的标准 TCP/IP 端口号。
此外，21 克还被认为是灵魂的重量。
所有这一切都离奇地应和着这个不同寻常的年份 —— 2021，它带着巨大的不确定性由远及近—— 风险没有变小，但吹来了新的风口，带来了新的需求 —— 需求刺激着市场，出现了新的商机 —— 而技术本身，也由此开始加速迭代。
以下是 LiveVideoStack 最为关注的2021年（不完全）音视频技术趋势，也是LiveVideoStackCon 2021 上海站 —— 新技术，新机会 —— 聚焦的技术热点。
关于边缘计算，大部分人都不会否认它代表的未来，不仅因为集中式架构面临巨大的网络成本，也因为用户对时延愈发苛刻的需求。但要实现边缘与中心协调的架构，需要时间和平台方更多的投入 —— 就像AWS等云厂商在云计算初期面临的挑战一样。
5G等基础设施的建设将为边缘计算打下关键的基础；关键应用场景和杀手级应用也将真正成为驱动边缘计算发展的一股力量：如工业领域对网络时延的需求，云游戏对海量边缘计算节点的需求，超高清或VR视频对超高带宽的需求等等。
本次 LiveVideoStackCon 2021 上海站，将有更多边缘计算相关的当下业务场景及其未来应用实例的技术分享。
实时音视频通讯、云游戏、超高清视频、VR/AR等应用与场景的落地和商业化，都离不开端到端低延时的支持。而想要实现超低延时，不仅体现在终端设备的迭代升级、硬件加速以及底层Codec的不断优化，网络架构的升级、传输协议的优化、链路策略的选择等等都是至关重要的因素。
5G、8K 时代的到来（或即将到来），不仅带来了传输带宽、终端运算能力的提升，VR/AR、沉浸式、高自由度视频技术等也得以快速发展。从高帧率到高分辨率，再到如今的 HDR，我们不断追求最极致的画质，这又进一步带来了全新的真实现场感和交互式体验。目前来看，AR/VR 在许多教育、培训场景下已经得到验证，并且正在向泛娱乐领域过渡，也许在未来 1-2 年内，VR 效果的短视频观看体验就会得到普及。
如今，似乎每一个软件投资和产品公关都要提及“无代码”平台或功能。与云计算类似，无代码本身也不是一个固有类别，而是用户与软件工具交互方式的转变。就像PC普及了软件的使用、API 普及了软件连接、云普及了软件的购买和部署一样，无代码或许能够通过普及特定的技术技能来引领下一波企业创新。 快手与声网等互联网公司也都成立了专门的团队进行“无代码/低代码”项目的研发。
“低代码（Low Code）”和“无代码（No Code）”经常被互换地提到，但它们的概念却截然不同。低代码和无代码都抽象了底层代码及其技术性，低代码旨在通过有限的抽象提高开发人员的效率，而无代码则想通过更强大的抽象来增强开发人员和非技术人员的能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6de126a7dc4c77b069b4e6e6c1d91829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5240da66024355b1759862c008304d85/" rel="bookmark">
			业务驱动向流程驱动转变_前端思维转变从事件驱动到数据驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接触过jQuery的小伙伴们大概在切换到mvvm初总不习惯，需要进行开发思维的转换，从事件驱动的角度出发到从数据驱动的角度出发，也是不小的挑战。
事件驱动 GUI与事件 GUI(图形用户界面)与事件驱动的渊源可谓不浅。
GUI应用程序的特点是注重与用户的交互，因此程序的执行取决于与用户的实时交互情况，大部分的程序执行需要等到用户的交互动作发生之后。
由于用户的输入频率并不高，若不停轮询获取用户输入，就有点像ajax轮询和websocket推送的关系：
1.资源利用率低。
2.不能真正做到及时同步。
由于GUI程序的执行流程由用户控制，并且不可预期，为了适应这种特点，我们需要采用事件驱动的编程方法。普通程序的执行可概括为“启动——做事——终止”，而事件驱动的程序的执行可概括为“启动——事件循环(即等待事件发生并处理之)”。
事件驱动编程 事件 事件是可以被控件识别的操作，如按下确定按钮，选择某个单选按钮或者复选框。每一种控件有自己可以识别的事件，如窗体的加载、单击、双击等事件，编辑框(文本框)的文本改变事件，等等。
事件(event)是针对应用程序所发生的事情，并且应用程序需要对这种事情做出响应。
事件处理 程序对事件的响应其实就是调用预先编制好的代码来对事件进行处理，这种代码称为事件处理程序(event handler)。
事件驱动编程(event-driven programming)就是针对这种“程序的执行由事件决定”的应用的一种编程范型。
Event loop 主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop(事件循环)。
关于Javascript的单线程与Event Loop，想要了解可以参考《JavaScript 运行机制详解：再谈Event Loop》。今天的主角是数据驱动，事件相关的不进行详细说明了。
事件驱动思维
在GUI和Javascript的设计场景下，我们写代码的时候也会代入这样的思维：
用户输入 =&gt; 事件响应 =&gt; 代码运行 =&gt; 刷新页面状态
于是乎，刚开始写应用的思路如下：
1.开发静态页面。
2.添加事件监听，包括用户输入、http请求、定时器触发等事件。
3.针对不同事件，编写不同的处理逻辑，包括获取事件状态/输入、计算并更新状态等。
4.根据计算后的数据状态，重新渲染页面。
通俗地说，事件驱动思维是从事件响应出发，来完成应用的设计和编程。
数据驱动
数据驱动，将我们从复杂的逻辑设计带进数据处理的世界。
何为数据
数据是什么，官方回答：数据是科学实验、检验、统计等所获得的和用于科学研究、技术设计、查证、决策等的数值。
但其实不管是资料中、生活和工作中，所有的事物我们都可以抽象为数据。像游戏里面的角色、物品、经验值、天气、时间等等，都是数据。游戏其实也算是对真实世界抽象的一种，而抽象之后，最终都可呈现为数据。
我认为，数据是一个抽象的过程。
回到日常写码中，前端写页面，抽象成数据常用的无非是：
1.列表 =&gt; array
2.状态 =&gt; number/boolen
3.一个卡片 =&gt; object
4.等等
事件驱动到数据驱动 数据驱动 vs 事件驱动 要对事件驱动和数据驱动进行直观的比较，大概是以下这样：
事件驱动
1.构建页面：设计DOM =&gt; 生成DOM =&gt; 绑定事件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5240da66024355b1759862c008304d85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/361dbd9ded0763914567d003d207776d/" rel="bookmark">
			MSP430 ADC_10bit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 MSP430共有两个ADC，分别是10bit和12bit，本章介绍10bitADC。
ADC10_A是高性能10位数模转换器，该模块实现了一个10位带有采样控制和窗口比较器的SAR核心。
最大转换率大于200ksps无缺码单调10bit转换器采样保持时间可软件或定时器编程定时器或软件控制开始转换片上可选软件使用REF模块或外部参考12个单独配置的外部输入REF温度传感器转换通道可选转换时钟源单通道、重复单通道、连续、重复连续转换模式用于低功耗检测输入信号的窗口比较器6个快速解码ADC中断向量(ADC10IFG0, ADC10TOVIFG,ADC10OVIFG, ADC10LOIFG, ADC10INIFG, ADC10HIIFG)
2.ADC10_A 操作 2.1 10-Bit ADC核心
ADC将输入模拟量转换为10bit数字量并储存在ADC10MEM0寄存器中。核心使用2个电压 (VR+ VR–)来定义最大值和最小值。当输入量等于VR+时，数字输出(NADC)最大 (03FFh)；当输入量等于VR-时，数字输出最小(0)。以下为输出计算公式：
配置寄存器ADC10CTL0, ADC10CTL1 和 ADC10CTL2控制ADC运行方式。
转换时钟
当脉冲采样模块被选择时，ADC10CLK用作转换时钟和产生采样间隔。ADC10SSELx位选择时钟来源，可用时钟有SMCLK, MCLK, ACLK,和MODCLK，配置 ADC10DIVx和ADC10PDIVx位，输入时钟可被分成1到512倍。
用户必须确保ADC10CLK选择的时钟在转换结束前可用，如果转换过程中时钟中断，转换不会完成，结果无效。
2.2 ADC10_A 输入与分路
共有 14个外部输入和2个内部输入通道可选，输入分路器是先断后开类型，这是为了减少切换通道时的噪音。输入分路器也是T型开关，这是为了减少不同通道的耦合。为了让杂散电容接地以消除串扰，没有使用的通道与ADC隔绝，并且连接到模拟地(AVSS)。
2.3 参考电压发生器
ADC10_A可以使用片上参考电压或者外部参考电压。片上参考电压有1.5V 、2.0V和2.5V，在REF模块配置。内部VCC也可作为参考电压。外部参考电压通过VEREF+和VEREF-引脚输入。
片上参考为低功耗而设计，这个参考包括一个带隙电压源和一个单独的参考缓冲器，两者都位于REF模块。每一种设备的当前消耗量分别在设备具体数据表中规定。ADC10_A还包含一个内部的参考电压缓冲器。当为VREF+选择内部引用时，该缓冲区将自动启用，但对于VEREF+也可以选择使用该缓冲区。来自REF模块的片上引用必须由软件启用。它的稳定时间为25微秒(典型)。
2.4 自动低功耗
ADC10_A为了低功耗设计，当不使用时会自动进入休眠，使用时会自动唤醒。
2.5 采样转换时间
采样输入信号(SHI)的上升沿触发ADC开始工作，ADC10ISSH能够转换SHI的极性，SAMPCON信号控制采样间隔和转换开始。当SAMPCON为1采样运行，SAMPCON由高变为低开始模数转换，在10bit模式需要12个ADC10CLK周期。窗口比较器另外还需要一个周期。ADC10SHP控制两个不同的采样方式：外部采样模式和脉冲采样模式。
外部采样模式
ADC10SHP = 0启动外部采样模式，SHI信号直接控制SAMPCON，也决定采样时间长度 tsample。当SAMPCON=1，采样运行，与ADC10CLK同步以后SAMPCON从高到低启动转换。
脉冲采样模式
ADC10SHP = 1选择脉冲采样模式，SHI触发采样计时器。ADC10SHTx位控制采样定时器间隔时间，在于AD10CLK同步之后，采样计时器保持SAMPCON为高
采样定时器注意事项： 当SAMPCON = 0，所有模拟输入为高阻。当SAMPCON = 1，在采样期间选择输入通道能够建模为低通RC滤波器。电容CI电压VC必须充电到源电压VS的1 / 2 LSB，以实现精确的10位转换。
2.6 转换结果
转换结果使用ADC10MEM0寄存器独立于转换模式访问，当转换结果写入ADC10MEM0后，ADC10IFG0置1.
2.7 ADC10_A转换模式
ADC10_A有4种转换模式，由CONSEQx位控制：
2.8 窗口比较器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/361dbd9ded0763914567d003d207776d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3e0ba641fe0b40a1899ed24b0b196b3/" rel="bookmark">
			ESP8266相互通讯（ESP-NOW）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ESP8266一.简介二.获取MAC三.发送端代码四.接受端代码五.调试结果 ESP8266 一.简介 这篇给大家分享一下多个ESP8266直接相互通讯，因为想做智能家居系统，但是想了一下，不止一个产品，比如测量温湿度的，检测人体的各种传感器，而且所处的位置也不一样，最后想到这个办法，可以用一个ESP8266模块作为一个总的控制，就像一个管家，来和其他ESP8266通讯，来实现我们想要的功能。
先说一下ESP-NOW，它是Espressif开发的一种协议，它使多个设备无需使用Wi-Fi即可相互通信。该协议类似于低功率的2.4GHz无线连接。设备之间需要进行配对，然后才能进行通信。配对完成后，连接安全且点对点，无需握手。”这意味着在将设备彼此配对后，连接将保持不变。换句话说，如果您的一块板突然断电或重置，则在重新启动时，它将自动连接到其对等端以继续通信。
简而言之，ESP-NOW是一种快速通信协议，可用于在ESP8266板之间交换小消息（最大250字节）。
ESP-NOW有多种用途
可以在不同的设置中进行单向或双向通信一个 主 ESP8266向多个ESP8266 从 发送数据
一块ESP8266板向不同的ESP8266板发送相同或不同的命令。此配置是构建遥控器之类的理想选择一个ESP8266从站从多个主站接收数据
如果要将多个传感器节点的数据收集到一个ESP8266板中，则此配置非常理想ESP-NOW双向通讯
使用ESP-NOW，每个板可以同时是发送者和接收者。因此，您可以在板之间建立双向通信。 总而言之，ESP-NOW是构建网络的理想选择，在该网络中，您可以有多个ESP8266板相互交换数据，这篇只是测试单方向的发送数据和接受数据
代码地址
ESP8266相互通讯
二.获取MAC 首先获取MAC地址，将下列程序烧入开发板，然后打开窗口，按ESP8266的复位按键，在串口助手就会打印MAC
#include &lt;ESP8266WiFi.h&gt; void setup(){ Serial.begin(115200); Serial.println(); Serial.print("ESP8266 Board MAC Address: "); Serial.println(WiFi.macAddress()); } void loop() { } 烧录程序时候也会显示该ESP8266的MAC
三.发送端代码 MAC需要改为接受的ESP8266的MAC
//发送 #include &lt;ESP8266WiFi.h&gt; #include &lt;espnow.h&gt; //接收方MAC地址 根据自己的板子修改 uint8_t broadcastAddress[] = {0x50, 0x02, 0x91, 0x67, 0xF5, 0xF4}; //发送数据的结构体 typedef struct struct_message { char a[32]; int b; float c; String d; bool e; } struct_message; //创建一个新的类型变量 struct_message myData; //这是一个回调函数，将在发送消息时执行。 //在这种情况下，无论是否成功发送该消息，都会简单地打印出来 void OnDataSent(uint8_t *mac_addr, uint8_t sendStatus) { Serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3e0ba641fe0b40a1899ed24b0b196b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5382ae0724414fafc6a9d20f448da860/" rel="bookmark">
			Python修改pip源为国内源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在python中安装第三方库时使用pip命令进行安装，pip默认从国外官网下载文件，下载速度很慢，经常下载超时。
解决办法：把pip源换成国内的，常用的有清华大学源、豆瓣源、阿里源、腾讯源（经我个人体验，阿里源是最好、下载速度最快、最稳定的）
pypi 清华大学源：https://pypi.tuna.tsinghua.edu.cn/simplepypi 豆瓣源 ：http://pypi.douban.com/simple/pypi 阿里源：https://mirrors.aliyun.com/pypi/simple/pypi 腾讯源：http://mirrors.cloud.tencent.com/pypi/simple 具体方法（修改默认源配置文件）：这是一个一劳永逸的方法，只需要修改一次，不需要每次使用pip时都修改pip源。
清华源：pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
阿里源：pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/
腾讯源：pip config set global.index-url http://mirrors.cloud.tencent.com/pypi/simple
豆瓣源：pip config set global.index-url http://pypi.douban.com/simple/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfca7eb2f4379b983c1503007414663c/" rel="bookmark">
			leetcode学习笔记1437 Check If All 1‘s Are at Least Length K Places Away
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		leetcode学习笔记1437 问题方法1 问题 Check If All 1’s Are at Least Length K Places Away
检查是否所有的1之间的间隔都至少是k.
Example 1:
Input: nums = [1,0,0,0,1,0,0,1], k = 2
Output: true
Explanation: Each of the 1s are at least 2 places away from each other.
Example 2:
Input: nums = [1,0,0,1,0,1], k = 2
Output: false
Explanation: The second 1 and third 1 are only one apart from each other.
Example 3:
Input: nums = [1,1,1,1,1], k = 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfca7eb2f4379b983c1503007414663c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e0c4e34b49b272899c76e906ee1891/" rel="bookmark">
			调试经验——Ryzen vs i7（AMD锐龙处理器与Intel i7处理器性能对比）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在运行深度学习案例时，无意中发现Ryzen处理器性能竟然要比i7高好几倍！
Ryzen: AMD Ryzen 5 4500U with Radeon Graphics, 2.38 GHz i7: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60 GHz 2.59 GHz
参考文章：吴恩达深度学习学习笔记——C1W2——神经网络基础——作业1——Python及Numpy基础
https://blog.csdn.net/hpdlzu80100/article/details/113007293
测试代码：
传统方法(classic):
import time x1 = [9, 2, 5, 0, 0, 7, 5, 0, 0, 0, 9, 2, 5, 0, 0] x2 = [9, 2, 2, 9, 0, 9, 2, 5, 0, 0, 9, 2, 5, 0, 0] ### CLASSIC DOT PRODUCT OF VECTORS IMPLEMENTATION ### tic = time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31e0c4e34b49b272899c76e906ee1891/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f809f53440d3c1408e99a719dc1ebee7/" rel="bookmark">
			【吊打面试官】今日头条redis高频面试题（最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概述 什么是RedisRedis有哪些优缺点为什么要用 Redis /为什么要用缓存为什么要用 Redis 而不用 map/guava 做缓存?Redis为什么这么快数据类型 Redis有哪些数据类型Redis的应用场景持久化 什么是Redis持久化？Redis 的持久化机制是什么？各自的优缺点？如何选择合适的持久化方式Redis持久化数据和缓存怎么做扩容？过期键的删除策略 Redis的过期键的删除策略Redis key的过期时间和永久有效分别怎么设置？我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?内存相关 MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据Redis的内存淘汰策略有哪些Redis主要消耗什么物理资源？Redis的内存用完了会发生什么？Redis如何做内存优化？线程模型 Redis线程模型事务 什么是事务？Redis事务的概念Redis事务的三个阶段Redis事务相关命令事务管理（ACID）概述Redis事务支持隔离性吗Redis事务保证原子性吗，支持回滚吗Redis事务其他实现集群方案 哨兵模式官方Redis Cluster 方案(服务端路由查询)基于客户端分配基于代理服务器分片Redis 主从架构Redis集群的主从复制模型是怎样的？生产环境中的 redis 是怎么部署的？说说Redis哈希槽的概念？Redis集群会有写操作丢失吗？为什么？Redis集群之间是如何复制的？Redis集群最大节点个数是多少？Redis集群如何选择数据库？分区 Redis是单线程的，如何提高多核CPU的利用率？为什么要做Redis分区？你知道有哪些Redis分区实现方案？Redis分区有什么缺点？分布式问题 Redis实现分布式锁如何解决 Redis 的并发竞争 Key 问题分布式Redis是前期做还是后期规模上来了再做好？为什么？什么是 RedLock缓存异常 缓存雪崩缓存穿透缓存击穿缓存预热缓存降级热点数据和冷数据缓存热点key常用工具 Redis支持的Java客户端都有哪些？官方推荐用哪个？Redis和Redisson有什么关系？Jedis与Redisson对比有什么优缺点？其他问题 Redis与Memcached的区别如何保证缓存与数据库双写时的数据一致性？Redis常见性能问题和解决方案？Redis官方为什么不提供Windows版本？一个字符串类型的值能存储最大容量是多少？Redis如何做大量数据插入？假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？使用Redis做过异步队列吗，是如何实现的Redis如何实现延时队列Redis回收进程如何工作的？Redis回收使用的是什么算法？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c266f3b06c3ac357b4d4446b833cc958/" rel="bookmark">
			HTML中给图片添加网站超链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在HTML中给图片添加网站超链接 html给图片添加超链接的方法：可以通过 标签来设置超链接，通过href设置所要跳转的链接，然后在a标签后面加入一个图片的格式路径，当点击图片时就可以跳转到想要跳转的网站中去。
&lt;li&gt;&lt;a href="https://baike.sogou.com/v14437.htm?fromTitle=2000%E5%B9%B4%E5%A5%A5%E8%BF%90%E4%BC%9A"&gt;&lt;img src="image/2000.jpg"&gt;&lt;/a&gt;&lt;/li&gt; 给大家看一个我自己写的图片转网站的超链接方法，供大家参考：
&lt;div class="picters"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="https://baike.sogou.com/v14437.htm?fromTitle=2000%E5%B9%B4%E5%A5%A5%E8%BF%90%E4%BC%9A"&gt;&lt;img src="image/2000.jpg"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://baike.sogou.com/v812451.htm?fromTitle=2004%E5%B9%B4%E5%A5%A5%E8%BF%90%E4%BC%9A"&gt;&lt;img src="image/2004.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://baike.sogou.com/v543362.htm?fromTitle=2008%E5%B9%B4%E5%A5%A5%E8%BF%90%E4%BC%9A"&gt;&lt;img src="image/2008.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://baike.sogou.com/v53415780.htm?fromTitle=2012%E5%A5%A5%E8%BF%90%E4%BC%9A"&gt;&lt;img src="image/2012.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://baike.sogou.com/v6278584.htm?fromTitle=2016%E5%B9%B4%E5%A5%A5%E8%BF%90%E4%BC%9A"&gt;&lt;img src="image/2016.jpg"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://baike.sogou.com/v61708696.htm?fromTitle=2020%E5%B9%B4%E5%A5%A5%E8%BF%90%E4%BC%9A"&gt;&lt;img src="image/2020.jpg"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 总结：以上就是本篇文章的全部内容了，希望对大家有所帮助。
以上就是html如何给图片加链接的详细内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432eb278a74f8035f84e5dd657bc6afe/" rel="bookmark">
			ioctl 详解，以ethtool为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关的ethtool命令：
ethtool -s|--change DEVNAME Change generic options
[ speed %d ]
[ duplex half|full ]
[ port tp|aui|bnc|mii|fibre ]
[ mdix auto|on|off ]
[ autoneg on|off ]
[ advertise %x ]
[ phyad %d ]
[ xcvr internal|external ]
[ wol p|u|m|b|a|g|s|d... ]
[ sopass %x:%x:%x:%x:%x:%x ]
[ msglvl %d | msglvl type on|off ... ]
该命令可以设置网卡的速率双工等等参数，我实际用到的命令是 ethtool -s ens1f1 speed 1000，即将ens1f1网口的速率设置为 GE，下面我们来看看配置是怎么下到网卡上的：
ethtool侧： do_sset --&gt; ecmd.cmd = ETHTOOL_SSET; send_ioctl --&gt; ioctl(ctx-&gt;fd, SIOCETHTOOL, &amp;ctx-&gt;ifr);标红的是命令字，内核是根据命令字做分发处理的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/432eb278a74f8035f84e5dd657bc6afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6fb5aa30a6a56419876aca8539c5fcd/" rel="bookmark">
			Word文档基本操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Word文档基本操作 MathTpye公式格式应用于整个Word文档方法一：从新公式预置加载格式方法二：从当前文档加载格式 将改写模式修改为插入模式 MathTpye公式格式应用于整个Word文档 方法一：从新公式预置加载格式 编辑一个内联格式并设置好格式；点击MathType内联菜单栏—预置—公式预置—保存预置用于新公式；点击Word菜单栏—MathType—格式化公式—选中MathType新的公式预置+整篇文档—点击确定。 方法二：从当前文档加载格式 编辑一个内联格式并设置好格式；保存退出，然后单击选中该公式；点击Word菜单栏—MathType—格式化公式—选中当前文档+整篇文档—点击确定。 将改写模式修改为插入模式 右击word文档最下方的 中文(中国) 图标—点击改写；这时候最下方会出现 改写 小图标—点击该图标。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d93f96a9afc2fe58996fb14db0c591/" rel="bookmark">
			【java快速入门-异常处理篇】- NullPointerException（空指针异常）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由图可知NullPointerException是属于RuntimeException异常中
NullPointerException即空指针异常，俗称NPE。如果一个对象为null，调用其方法或访问其字段就会产生NullPointerException，这个异常通常是由JVM抛出的，例如：
public class Main { public static void main(String[] args) { String s = null; System.out.println(s.toLowerCase()); } } //指针这个概念实际上源自C语言，Java语言中并无指针。我们定义的变量实际上是引用类型，Null Pointer更确切地说是Null Reference，不过两者区别不大。 那么如何处理NullPointerException？ 首先，必须明确，NullPointerException是一种代码逻辑错误，遇到NullPointerException，遵循原则是早暴露，早修复，严禁使用catch来隐藏这种编码错误。
其次好的编程习惯可以降低NullPointerException的产生，例如：
成员变量在定义时初始化：
public class Person { private String name = "";//将它定义成""（空字符）而不是默认的null可以很好的避免NullPointerException } 编写业务逻辑时，用空字符串""表示未填写比null安全得多。返回空字符串""、空数组而不是null：
public String[] readLinesFromFile(String file) { if (getFileSize(file) == 0) { // 返回空数组而不是null: return new String[0];//这样可以使得调用方无需检查结果是否为null } ... } 如果调用方一定要根据null判断，比如返回null表示文件不存在，那么考虑返回Optional&lt;T&gt;
public Optional&lt;String&gt; readFromFile(String file) { if (!fileExist(file)) { return Optional.empty();//这样调用方必须通过Optional.isPresent()判断是否有结果。 } ... } 那怎么定位NullPointerException？ 从Java 14开始，如果产生了NullPointerException，JVM可以给出详细的信息告诉我们null对象到底是谁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95d93f96a9afc2fe58996fb14db0c591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7adad305c64332f86ad0a21e29f425c/" rel="bookmark">
			数据泵expdp/impdp导入导出详细说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、数据泵导出expdp详细参数2、数据泵导入impdp详细参数3、数据泵作业参数详细说明 3.1 EXPDP命令行选项 3.1.1 ATTACH3.1.2 CONTENT3.1.3 DIRECTORY3.1.4 DUMPFILE3.1.5 ESTIMATE3.1.6 EXTIMATE_ONLY3.1.7 EXCLUDE3.1.8 FILESIZE3.1.9 FLASHBACK_SCN3.1.10 FLASHBACK_TIME3.1.11 FULL3.1.12 HELP3.1.13 INCLUDE3.1.14 JOB_NAME3.1.15 LOGFILE3.1.16 NETWORK_LINK3.1.17 NOLOGFILE3.1.18 PARALLEL3.1.19 PARFILE3.1.20 QUERY3.1.21 SCHEMAS3.1.22 STATUS3.1.23 TABLES3.1.24 TABLESPACES3.1.25 TRANSPORT_FULL_CHECK3.1.26 TRANSPORT_TABLESPACES3.1.27 VERSION3.2 EXPDP导出示例 3.2.1、导出表3.2.2、导出方案3.3.3、导出表空间3.2.4、导出数据库3.3 IMPDP导入参数3.3.1、REMAP_DATAFILE3.3.2、REMAP_SCHEMA3.3.3、REMAP_TABLESPACE3.3.4、REUSE_DATAFILES3.3.5、SKIP_UNUSABLE_INDEXES3.3.6、SQLFILE3.3.7、STREAMS_CONFIGURATION3.3.8、TABLE_EXISTS_ACTION3.3.9、TRANSFORM 3.3.10、TRANSPORT_DATAFILES3.4 IMPDP导入示例 3.4.1、导入表 1、数据泵导出expdp详细参数 oracle数据泵导出实用程序expdp提供了一种用于在 Oracle 数据库之间传输数据对象的机制。该实用程序可以使用以下命令进行调用:
示例: expdp scott/tiger DIRECTORY=dmpdir DUMPFILE=scott.dmp
可以通过参数控制导出的运行方式。
具体方法是: 在 'expdp' 命令后输入各种参数。
要指定各参数, 请使用关键字:
格式: expdp KEYWORD=value 或 KEYWORD=(value1,value2,...,valueN)
示例: expdp scott/tiger DUMPFILE=scott.dmp DIRECTORY=dmpdir SCHEMAS=scot 或 TABLES=(T1:P1,T1:P2), 如果 T1 是分区表USERID 必须是命令行中的第一个参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7adad305c64332f86ad0a21e29f425c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be5835f5d1d49f60ebd64a837a964c9/" rel="bookmark">
			E: Could not get lock /var/cache/apt/archives/lock - open (11: Resource temporarily unavailable)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在ubuntu下安装东西，常常出现这个错误
E: Could not get lock /var/cache/apt/archives/lock - open (11: Resource temporarily unavailable) E: Unable to lock directory /var/cache/apt/archives/ 解决方法如下
方法一(删除锁定文件) 在终端连续输入这两个指令
sudo rm /var/lib/dpkg/lock-frontend //如果提示没有这个文件夹，不用管它，继续敲下面这个 sudo rm /var/lib/dpkg/lock //敲完之后更新一下 sudo apt-get update 如果还没有办法，用下面
方法二(寻找apt进程) ubuntu下允许apt同时进行一个任务
如果你正在进行安装另一个东西，就要等待结束后在安装
如果你没有安装，就查看进程
ps -aux 比如有下面(apt-get进程，关掉即可)
root 5765 0.0 1.0 18204 15504 ? SN 04:02 0:00 apt-get -qq -d 关掉方法
以最后一列apt-get开头，这个进程正得到锁，在终端中执行
sudo kill 进程号(PID) 如果有用点个赞再走
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b52d559663be6dc293e0f9e8409cf4b/" rel="bookmark">
			数据全量、增量、比较更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【实验目的】
1.利用Kettle的“表输入”，“表输入出”，”JavaScript代码”组件，实现数据全量更新。
2.熟练掌握“JavaScript代码”，“表输入”，“表输入出”组件的使用，实现数据全量更新。
【实验原理】
通过“表输入”对MySQL表格的数据读入，然后通过“JavaScript代码”更新抽取数据的时间，再通过“表输入出”保存表格到MySQL数据库。
【实验环境】
操作系统：Windows10 Kettle版本：7.1.0.0
jdk版本：1.8.0及以上版本
【实验步骤】
一、建立转换 双击spoon.bat打开kettle。（1）点击新建按钮，在下拉菜单中点击选择"转换"即可创建；（2）然后点击"保存"重命名该转换文件，保存在某个指定的路径；（3）选择输入步骤、输出步骤和跳。
二、各组件的配置 1.使用Navicat向数据库mysql导入数据表：‘课程信息表’，导入结果如下：
2.“表输入”的配置：
Step1：双击‘表输入’组件，新建数据库的连接并进行测试，
Step2：连接成功后，获取表的字段名称
2.“JavaScript代码”的配置：
双击“HTTP client”组件，编写Script1的代码，并获取其相应字段名称和类型。
3.“表输出”的配置：
双击‘表输出’组件，选择目标表的名称，并使用SQL语句进行创建：
4.“表输出2”的配置：
双击‘表输出2’组件，选择目标表的名称，并使用SQL语句进行创建：
三、执行转换 点击按钮，执行转换，结果如下：
四、实验结果: 输入文件‘课程信息表.xlsx’：
输出文件‘test4_tableout’：
输出文件‘test4_tableout2’：
五、实验中遇到的困难： 表输入和表输出的数据库连接前后要一致（实验过程中，因不经意间改变了表输入步骤的数据库连接名称，致使表输出一直报错）
六、实验总结 本次试验主要是通过一个表输入，两个表输出来实现数据全量更新。一条经过JavaScript代码的处理，在数据表里添加表输出时的时间字段，另一条直接进行表输出，这两条过程的输出结果形成一个对比，实现数据的比较更新。
附 件： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e322b1e9a6e5bb2342ea1c44ca1b7c85/" rel="bookmark">
			UE4——编辑器资源操作篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我又来了，最近更新频率有所降低并不是我没有学到什么新的知识，只是最近工作有点忙加上 鼻炎引起发烧 然后又因为发烧引起上火口腔溃疡 什么的都来了。 所以大家工作在忙也要照顾好自己的身体
进入正题 今天我们来讲讲如何利用代码去修改我们的材质实例资源里面的参数并保存下来、创建蓝图、以代码的方式添加组件到蓝图内，首先我们来分析一下这篇博客涉及到的知识——
1.如何修改材质实例的编辑器参数
2.创建出蓝图
3.为蓝图中添加响应的组件或者是添加相应的静态网格组件
4.保存资源
5. 最后一点也是最难的一点（以上4点都在不打开编辑器的情况下去操作）
好了废话不多说，我们直接开始吧
首先分析一个点就是我们需要不打开编辑器的情况下去执行这些操作就必须让引擎识别到我们不需要打开编辑器又能运行我们的代码，这里最直接的就是使用commendlet的方式去操作了。因为commendlet的执行顺序是高于启动编辑器的。
关于commendlet的相关介绍可以看会我之前的博客有一期是有讲这个的。现在我们来写一个我们自己的commendlet
下面仅供参考——不完整示例
.h
UCLASS() class UMyCommandlet : public UCommandlet { GENERATED_UCLASS_BODY() /** Runs the commandlet */ //这里是我们commandlet的入口 其实和控制台应用程序一样 virtual int32 Main(const FString&amp; Params) override; public: //示例 更改材质参数函数 void ChangeMatParam(); //示例创建蓝图函数 void CreateBlueprint(); private: //我们自己创建一个世界 class FPreviewScene* Scene; .cpp
int32 UMyCommandlet ::Main(const FString&amp; Params) { ChangeMatParam(); CreateBlueprint(); } void ChangeMatParam() { //首先我们先基于一个材质实例或者材质去创建一个材质 //这里不创建也行直接把想要修改的材质加载上来就好了 class UMaterialInterface* InParentMat = LoadObject&lt;UMaterialInterface&gt;(NULL, TEXT("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e322b1e9a6e5bb2342ea1c44ca1b7c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe7d8f2167bec5c481cb5c2032de9bd/" rel="bookmark">
			SecureCRT中文乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击菜单栏中Options的Session Options
更改此处为gb2312
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb85362d58f088e1283b105975444e61/" rel="bookmark">
			EaxyExcel设置下拉框并解决excel下拉框255限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近有一个excel导出需求，要在单元格提供下拉框。
其中一个下拉框有300多个选项，使用EasyExcel导出，发现excel无法正常打开。网上一搜，发现excel本身每个单元格限制了255个字符，下拉框总字符超过255就无法正常打开。
在EasyExcel的issue有相关讨论
下拉框数据量超过88条记录，文件无法打开
里面提到一个思路，大致是创建另一个sheet存放下拉选项，本sheet的单元格通过公式链接到那个sheet的内容。
主要是在SheetWriteHandler的实现类的afterSheetCreate()，用这个指定
int TotalRowCount=88; // sheet2里面下拉框对应的一列需要放多少行数据 String enumSheetName = "sheet2"; // 下拉框数据所在的sheet页名称 String[] operationCity; // 下拉框的数据 CellRangeAddressList cellRangeAddressList5 = new CellRangeAddressList(1, TotalRowCount, 5, 5); String cityEnum = "=" + enumSheetName + "!$A$2:$A$" + (operationCity.length + 1); DataValidationConstraint constraint2 = helper.createFormulaListConstraint(cityEnum); DataValidation dataValidation2 = helper.createValidation(constraint2, cellRangeAddressList5); writeSheetHolder.getSheet().addValidationData(dataValidation2); 其实讲得还不够详细，下面直接上我的代码
先展示最终效果 实现 先引入EasyExcel和Guava工具类，还有lombok
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;30.1-jre&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springboot test启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb85362d58f088e1283b105975444e61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd45cf2bba64c8a5726e8982340da5fe/" rel="bookmark">
			MSP430CPU介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结 1. CPU介绍 MSP430的CPU具有诸如计算分支、表格处理、支持高级语言（C）等现代处理器特征，其特点包括：
1.RISC精简指令集
2.正交体系结构
3.包括程序计数器PC、堆栈寄存器SP、状态寄存器SR在内的全部寄存器可访问
3.单周期寄存器操作
4.更大的寄存器容量以减少内存访问
5.20位地址总线允许直接访问，在整个内存范围内进行分支，而不进行分页。
6.16位数据总线允许长字访问
7.提供常数发生器产生6个常用常数以减少代码大小
8.直接内存到内存传送不需要中间寄存器
9.字节、字、20位地址直接访问
2. 中断 中断向量为16位地址，可指向低64KB内存，这也意味着中断服务程序必须位于低64KB的内存空间中。
发生中断时，首先将PC和SR压入堆栈，因为PC长度为20bit，所以PC的0:15位先被压入，再把PC的16:19和SR一并压入堆栈。
3.CPU寄存器 MSP430含有16个寄存器（R0:R15），R0、R1、R2、R3有特殊用途，其余为通用寄存器。
3.1 程序计数器PC
20位PC（也就是R0）指向下一条将要执行的指令地址，每条指令为偶数个字节，意味着PC只能为偶数，每执行一条指令后PC自动递增。
3.2 堆栈指针SP
CPU使用20位SP（也就是R1）储存子程序返回地址，此外，所有的软件也能使用SP来储存数据。SP被用户初始化进入RAM，总是指向偶数地址。
3.3 状态寄存器SR
被作为源或者目的16位状态寄存器（也就是R2）只能够在寄存器模式下用字命令使用，其余的寻址模式组合用于支持常量生成器。不要给SR写16位数，否则结果将不可预料。
** 3.4常数发生器CG1和CG2**
6个常用常数可被CG1(R2)和CG2(R3)产生而不需要额外的代码，6个常数如下：
其优点包括：不需要特殊指令、不需要额外代码、检索常量不需要代码内存访问。
如果需要，编译器会优先使用常数发生器，若R2、R3设置为常规模式，则其被当做普通寄存器使用。
** 3.5普通寄存器**
12个普通寄存器（R4:R15）可储存8bit、16bit、20bit数据，若向内写入字节数据，则8:19位会被清除，若写入系数据，则16:19位会被清除
4.寻址模式 MSP430包含7个源寻址模式和4个目的寻址模式，最大能够寻址1MB内存空间。
寻址模式具体内容较为复杂，详情参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32b107329eb9ef123dfb11a7168ee123/" rel="bookmark">
			Spring  Cloud各核心组件的功能及作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud Eureka 服务发现与注册 Eureka Client eurela client存在于每个provider和consumer中。
eureka client有以下动作：
将本服务的信息注册到eureka注册中心。拉取注册注册中心的注册表，把各服务的注册信息缓存在本地中。定时向注册中心发送心跳（默认30s）保持通信并更新注册中心的注册表到本地注册表缓存中。如果超过90s没有发送心跳，则注册中心将会从注册表中将该服务删除。服务触发下线操作后，会主动请求注册中心删除该服务的信息。 如果在代码中，一个服务调用了另一个服务的接口，那么当前服务会从本地的注册表缓存中根据要调用的服务的serviceID获取到服务信息，根据服务信息通过http(Spring Cloud Feign，Spring boot2.X使用的是openfeign,在从1.X升级到2.X时注意feign包的引用)请求去调用。
Eureka Service eureka service是服务注册中心，可以存在多个，因此可以部署eureka service的集群保证高可用。如果当一个节点挂掉，比如，此时有个服务发起renew请求，发现连接失败。eureka会自动切换到另一个节点；除非eureka service全部挂掉，那神仙也没办法。
当15分钟内，集群中超过85%的客户端，没有正常心跳，则会开启自我保护机制。此时eureka server不再剔除注册表中的客户端，当此时eureka server接收到客户端注册请求，会在当前节点上注册，但是不会同步到其他eureka server节点上。当网络恢复正常，也就是集群中的节点恢复正常心跳后。则会把注册信息同步到其他的eureka server节点。
eureka service有以下动作：
接收eureka client端的服务注册，当收到client端的注册请求时，会把client端的注册信息缓存到本地，并同步到其他eureka service，如果client端注册到该节点的注册中心失败时，会自动寻找下一个注册中心节点并注册。提供服务注册表，每个eureka client会定时通过eureka service获取注册表缓存到本地。服务管理，eureka service管理eureka client的renew、cancel等操作，保证eureka client每次能拿到集群中最新的注册表信息。集群管理，每个eureka service更新服务注册表的数据后，会同步给集群中的其他eureka service。 通过eureka记录了服务信息后，还并不能调用远程服务。因为eureka只提供服务的注册与发现，不提供远程调用。
Eureka更新到2.0版本后，官方已经停止维护。
Spring Cloud Consul consul与eureka的区别：
consul提供CP（一致性、分区容错性）的保证，consul使用Raft协议保证其一致性。如果一个普通节点挂了，那么整个系统不会down掉，请求会转移到活着的节点上。但是当集群leader挂了后，集群会停止服务，直到新的leader选出来之后。集群才可继续运转。并且在服务注册时，服务信息需要同步写入集群的半数以上的机器才算成功，服务注册速度相对于eureka更慢，这就是为什么能保证CP缺不能保证A（可用性）的原因。
eureka提供了AP（可用性、分区容错性）的保证，eureka通过弱一致性，保证了集群的AP（可用性、分区容错性），当eureka的一个普通节点挂掉以后，请求也是会往另外的节点转发过去，当eureka service集群的某个节点挂掉后，服务也可以照常运行。因为eureka service通常由3台或更多的服务器组成eureka service，eureka service的数据会互相同步。但是在同步时，不会保证每次数据同步都能完成。并且eureka的服务注册相对于consul更快，因为eureka的服务只需要在集群中的一台eureka service上注册成功就算服务注册完成，之后再去eureka service中同步服务信息，这就导致了可能在eureka service1能成功调用该新注册的服务，但是eureka service2中调用不了该新注册的服务，所以虽然eureka service中的注册信息虽不一致，但集群依然能正常运作。
Spring Cloud Feign Spring Cloud Feign是Spring Cloud中的核心组件，如果没有了Feign，那么分布式集群的远程调用将会变的复杂无比。
使用@EnableFeignClients启用feign @EnableFeignClients是启用feign最基础的注解。注解中使用了@Import(FeignClientsRegistrar.class)导入了feign组件的注册器，以下是工作原理：
先查看是否定义了defaultConfiguration，如果定义了，则生成自定义配置的bean。未定义则使用系统默认的。该配置指定了Decoder解码器、Encoder编码器、Contract组件扫描构造器。扫描由basePackages定义的包地址，如果未定义basePackges，则扫描全包。扫描项目中贴了@FeignClient的类。获取到@FeignClient注解的配置的值，如value/name、path等。然后通过Spring封装的Ribbon客户端选择一个主机地址。根据value/name、path等值，封装成一个Request，调用目标主机。如果调用失败：看用户是否配置了Retryer来覆盖默认重试机制，如果未设置，默认不重试，再调用用户配置的fallback信息，如果fallback未设置，该fallback指定了用户自定义的失败回调配置类，可以通过配置hystrix来控制服务的熔断和降级功能。 Spring Cloud Ribbon 在我们平常使用Spring Cloud服务时，是感受不到Ribbon的存在的，因为feign封装了Ribbon，使得调用远程服务的方式变得异常简单，只需要两个注解@EnableFeignClients和@FeignClient即可实现远程调用和负载均衡。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32b107329eb9ef123dfb11a7168ee123/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b23e21242992c52f2277e0aba8092f/" rel="bookmark">
			浅谈卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 卷积层、激活函数层、池化层、全连接层
1、 卷积层：
一般的，标准数码相机的图像将有三个通道——红、绿、蓝——我们可以把它们想象成三个相互叠加的2d矩阵(每种颜色一个)，每个像素值在0到255之间（颜色越亮数值越大）。卷积在卷积网络中的主要目的是从输入图像中提取特征。卷积通过使用输入数据的小方块学习图像特征来保持像素之间的空间关系。
下面仅以0，1的二维矩阵进行举例（实际过程中为0-255）。
三通道中的其中一个通道，其二维矩阵例举如上。
所用的卷积核（谨以此为例）。
一个卷积核在此通道上进行卷积的结果
这里有一个图片， 我们可以执行诸如边缘检测、锐化和模糊等操作，只需在卷积操作之前改变滤波器（卷积核）矩阵的数值——这意味着不同的滤波器可以从图像中检测出不同的特征，例如边缘、曲线等。不同滤波器的效果如下从上到下分别为（单位矩阵，边缘检测、锐化、标准化模糊、高斯滤波）：
下面的动画为卷积层的工作过程：
滤光片(带红色轮廓)滑过输入图像(卷积运算)以产生特征映射。另一个过滤器(绿色轮廓)的卷积，在相同的图像上给出一个不同的特征图，如图所示。卷积操作捕获了原始图像中的局部依赖性。还要注意这两个不同的过滤器是如何从相同的原始图像生成不同的特征映射的。，图像和上面的两个过滤器只是我们上面说明的的数字矩阵。
在运用过程中，CNN在训练过程中自己学习这些过滤器的值(虽然我们在训练过程之前还需要指定一些参数，比如过滤器的数量，过滤器的大小，网络的架构等)。我们拥有的过滤器越多，提取的图像特征就越多，我们的网络在识别不可见图像中的模式方面也就变得越好。
卷积层相关的参数：
1、 depth: depth对应于我们用于卷积操作的过滤器的数量。在下图所示的网络中，我们使用三个不同的过滤器对原始船图像进行卷积，从而产生三个不同的特征映射。这三个特征映射想象成堆叠的2d矩阵，所以，特征映射的“深度”应该是3。
2、 stride:stride是我们在输入矩阵上滑动过滤器矩阵的像素数。当stride为1时，我们每次移动滤镜一个像素。当步幅为2时，当我们滑动它们时，过滤器一次跳跃2个像素。更大的步幅会产生更小的特征图。相关的计算公式在前几天的caffe文献中有所说明。
3、 Zero-padding:零填充:有时候，用0填充输入矩阵是很方便的，这样我们可以对输入图像矩阵的边界元素应用过滤器。零填充的一个很好的特性是，它允许我们控制特征映射的大小。添加零填充也称为宽卷积，不使用零填充则为窄卷积。
综上：卷积层的主要作用就是对图像的特征增强以及提取，通过不同的卷积核会提取出不同的特征，用作后期学习的重要数据。同时通过调整卷积的步长也可以调整我们的感受野。
二、 ReLu数层
在每个卷积操作之后都会使用激活函数来额外操作。这里以ReLu举例，ReLU为整流线性单元，是一种非线性操作。其输出如下所示:
ReLU是一个基于元素的操作(应用于每个像素)，它将feature map中的所有负像素值替换为0。卷积是一个线性操作——对应位置上元素的矩阵乘法和加法操作,但是我们在学习时大多数的真实数据是非线性的，所以我们考虑通过引入一个非线性函数如ReLU，ReLU ReLU的目的是我们在学习之前引入非线性这一概念。
从下图可以清楚地理解ReLU操作。它显示了将ReLU操作应用下图获得的一个特性映射。输出特征映射在这里也被称为“矫正”特征映射。也可以使用其他非线性函数，如tanh或sigmoid，来代替ReLU，但是ReLU在大多数情况下性能更好。
三、 池化层
空间池化(也称为子采样或下采样)降低了每个特征图的维数，但保留了最重要的信息。空间池化可以有不同的类型:Max、Average、Sum等。
在最大池化的情况下，我们定义一个空间邻域(例如，一个2×2的窗口)，并从该窗口内的修正特征映射中取最大的元素。我们也可以取平均值(平均池)或该窗口中所有元素的总和，而不是取最大的元素。在实践中，最大池化已经被证明可以更好地工作。
下图是一个使用2×2窗口对经过卷积+ ReLU操作得到的修正后的Feature map进行最大池化操作的例子。
我们将2×2的窗口滑动2个单元格(也称为“步幅”)，并在每个区域中取最大值。如上图所示，这减少了我们的feature map的维数。
在下图所示的网络中，池操作分别应用于每个特性映射(注意，由于这个原因，我们从三个输入映射得到三个输出映射)。
下图显示了池化对我们在上图中的ReLU操作后接收到的修正后的特征映射的影响。
池化的作用是逐步减少输入表达的空间大小。具体如下：
使输入表达(特性维度)更小，更易于管理
减少了网络中参数和计算的数量，因此控制过拟合
使网络不受输入图像中小的变换、变形和平移的影响(输入中小的失真不会改变池的输出-因为我们取一个局部邻域的最大值/平均值)。
帮助我们得到图像的比例几乎不变的表达(准确的术语是“等变的”)。无论检测图像中的对象位于哪里我们都可以检测到。
四、 全连接层
全连接层是一个传统的多层感知器，在输出层使用softmax激活函数（其他分类器如SVM也可以使用）。“全连接”意味着上一层的每个神经元都与下一层的每个神经元相连。
卷积层和池化层的输出表示输入图像的高级特征。全连接层的目的是利用这些特征根据训练数据集将输入图像分类成不同的类。例如，我们开始执行的图像分类任务有四种可能的输出，如
卷积层和池化层的输出表示输入图像的高级特征。全连接层的目的是利用这些特征将训练数据集将输入图像分类成不同的类。例如，我们开始执行的图像分类任务有四种可能的输出，如下图。
除了分类之外，添加一个完全连接的层也是学习这些特征的非线性组合的一种廉价方法。来自卷积层和池化层的大多数特性可能对分类任务很好，但这些特性的组合可能更好。
全连通层输出概率之和为1。这是通过在全连接层的输出层使用Softmax作为激活函数来保证的。Softmax函数取一个由任意实值分数组成的向量，并将其压缩为一个由0到1之间的和为1的值组成的向量。
到目前为止，我们已经看到了卷积、激活函数层和池化是如何工作的。重要的是要理解这些层次是任何CNN的基本构建块。如下图所示，我们有两组卷积、ReLU和Pooling层-第2个卷积层使用6个过滤器对第1个Pooling层的输出进行卷积，总共产生6个feature map。然后将ReLU分别应用于所有这六个特性映射。然后，我们对这六个修正后的特征映射分别执行最大池操作。
这些层一起从图像中提取有用的特征，在我们的网络中引入非线性，降低特征维数，同时使特征在缩放和转换时具有一定的等变性。
如上所述，卷积+池化层作为输入图像的特征提取器，而全连接层作为分类器。、
五、总结
卷积网络的整体训练过程总结如下:
Step1:用随机值初始化所有的过滤器和参数/权重
Step2:网络以训练图像为输入，进行前向传播步骤(卷积、ReLU、池化操作以及全连通层的前向传播)，求出每个类的输出概率。
假设上面的船图像的输出概率是[0.2,0.4,0.1,0.3]
由于第一个训练示例的权重是随机分配的，因此输出概率也是随机的。
Step3:计算输出层的总误差(所有4个类的总和)
总误差=∑½(目标概率-输出概率)²
Step4:使用Backpropagation计算误差相对于网络中所有权值的梯度，使用梯度下降更新所有滤波器值/权值和参数值，使输出误差最小化。权重按它们对总误差的贡献比例进行调整。
当再次输入相同的图像时，现在的输出概率可能是[0.1,0.1,0.7,0.1]，这更接近于目标向量[0,0,1,0]。
这意味着网络已经学会通过调整其权值/滤波器来正确分类这一特定图像，从而减少输出误差。
过滤器数量、过滤器大小、网络架构等参数在第1步之前都已经固定，并且在训练过程中不会改变，只更新过滤器矩阵的值和连接权值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09b23e21242992c52f2277e0aba8092f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d4ca08e5b4aec766ac5dd1a798512e/" rel="bookmark">
			Java集合基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int[ ] 转 List &lt;Integer&gt; int[] ints = new int[] {2,3,4}; List&lt;Integer&gt; list = Arrays.stream(ints).boxed().collect(Collectors.toList()); int[ ] 转 Integer[ ] int[] t = new int[] {2,3,4}; Integer[] integers = Arrays.stream(t).boxed().toArray(Integer[]::new); Integer[ ] 转 int[ ] Integer[] integers = new Integer[]{22,33,44}; int[] s = Arrays.stream(integers).mapToInt(Integer::valueOf).toArray(); Integer[ ] 转 List &lt;Integer&gt; Integer[] integers = new Integer[]{22,33,44}; List&lt;Integer&gt; list = Arrays.asList(integers); List &lt;Integer&gt; 转 int[ ] List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(111); list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d4ca08e5b4aec766ac5dd1a798512e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc096b99f697d5f48d4d2e4e87bea7c0/" rel="bookmark">
			opencv 随机形状_Pytorch随机遮挡&amp;#x27;Image&amp;#x27; object has no attribute &amp;#x27;shape&amp;#x27;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用transforms.RandomErasing时会出现如下的错误：
'Image' object has no attribute 'shape' 这是因为随机遮挡是对 (c, h, w) 形状的 tensor 进行操作，一般在 ToTensor 之后进行，而使用PIL.Image读取图片后的形式是(H, W, C)形状的图片，所以直接用RandomErasing时会出现错误。
image=Image.open('test.JPG').convert('RGB') image_era=transforms.RandomErasing(p=1, scale=(0.3, 0.5), value=0, inplace=False)(image) plt.imshow(image_era) 解决办法：
import PIL.Image as Image import torchvision.transforms as transforms import matplotlib.pyplot as plt image=Image.open('data/Fireworks/test/8.JPG').convert('RGB') plt.imshow(image) plt.show() print(image.size) import numpy as np import torch img_array=np.array(image).transpose(2, 0, 1) # transpose (H, W, C) -&gt; (C, H, W) img_tensor=torch.from_numpy(img_array) random_erasing=transforms.RandomErasing( p=1.0, # 概率值，执行该操作的概率，默认为 0.5 scale=(0.02, 0.33), # 按均匀分布概率抽样，遮挡区域的面积 = image * scale ratio=(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc096b99f697d5f48d4d2e4e87bea7c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db0d9c7e507c97e789250e0fff9e1a4/" rel="bookmark">
			SpringBoot 自动装配原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次问到 Spring Boot， 面试官非常喜欢问这个问题：“讲述一下 SpringBoot 自动装配原理？”。
我觉得我们可以从以下几个方面回答：
什么是 SpringBoot 自动装配？SpringBoot 是如何实现自动装配的？如何实现按需加载？如何实现一个 Starter？ 篇幅问题，这篇文章并没有深入，小伙伴们也可以直接使用 debug 的方式去看看 SpringBoot 自动装配部分的源代码。
前言 使用过 Spring 的小伙伴，一定有被 XML 配置统治的恐惧。即使 Spring 后面引入了基于注解的配置，我们在开启某些 Spring 特性或者引入第三方依赖的时候，还是需要用 XML 或 Java 进行显式配置。
举个例子。没有 Spring Boot 的时候，我们写一个 RestFul Web 服务，还首先需要进行如下配置。
@Configuration public class RESTConfiguration { @Bean public View jsonTemplate() { MappingJackson2JsonView view = new MappingJackson2JsonView(); view.setPrettyPrint(true); return view; } @Bean public ViewResolver viewResolver() { return new BeanNameViewResolver(); } } spring-servlet.xml
&lt;beans xmlns="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db0d9c7e507c97e789250e0fff9e1a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2601793731e6c7ec02e38854b93b1e/" rel="bookmark">
			禁用微信公众号复制链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 禁用微信分享 记录一个奇怪的需求需要禁用微信公众号复制链接 但是跳转a 链接后会失效 但是可以解决
if (typeof WeixinJSBridge == "undefined") { if (document.addEventListener) { document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); } else if (document.attachEvent) { document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); } } else { onBridgeReady(); } function onBridgeReady() { WeixinJSBridge.call('hideOptionMenu'); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed43965cf698b5ac41f0219c3a93b86/" rel="bookmark">
			End of startup status:LOW
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		End of startup status:LOW
解决方案:
加一条约束
set_property BITSTREAM.CONFIG.UNUSEDPIN Pullup[current_design]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/035cc302bccebe214443c681495bfb46/" rel="bookmark">
			新年第一篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		还是有一些朋友期待着我写一些分享的。2020年，于我而言，真的是非常特殊的一年。今年，全世界都被新冠的疫情所笼罩，大家都是小心翼翼的。我和老婆在20年新年之前，为了宝宝的安全，我们决定不回家了，之后突然就爆出了疫情。我们觉得非常幸运。如果回家了，在家里隔离，老婆正好在怀孕三个月，不能正常的接受产检，那么带来的后果可能是非常严重的。在杭州，还是能按时到妇保医院接受检查的。我们真是福星啊。
年中的时候，小宝宝出生了，年初由于公司第一优先级项目的进度原因，照顾宝宝妈妈的时间不够。宝宝妈妈一直在抱怨，这么拼命的工作，如果没有回报，图个啥。宝宝出生后，妈妈又生病了，做了一个大手术。需要修养好长时间。我也不能去照顾妈妈。真的是非常的无奈。宝妈产假的日子里，只能她自己一个照顾宝宝，有的时候，我还在忙第二个项目，不能每天六点就下班就走，替换她去照顾宝宝，她对我们公司的意见非常大。即使这样，宝妈还是支持我的工作的。也独力的支撑过这段时间了。我们的宝宝是个天使宝宝，基本上没有生过大病，吃得好，睡得好，宝妈省心了很多。要不然，真的不知道该如何支撑过这段时间。现在有人照顾宝宝，宝宝也很好带。体重稳定增长。感觉事情都变得顺利了起来。这也是因为宝妈和我们自己在整个阶段学习了备孕、养胎的各种知识。
在专业方向上，我还是继续在做三维CAD方向。有几个人在年前、年中的时候找我做CAD项目的咨询工作，我哪里来的时间呢？在国内做这个方向的，实在太缺人了。由于行业很小，有没有什么借鉴方案。很多情况都是靠摸索。国内的CAD项目，很多都是在国外的商业lib上做二次开发的，license成本非常高。所以，大家都想着自己开始做。这并非一朝一夕可以完成的。国内对于软件的保护，大家也是可以看见的。大量的程序员使用着破解的程序。连自己都不尊重自己的行业，不在意这个行业的长久发展。
今年在工作上，也是非常繁忙的一年。接手两个非常紧急的项目。一个大型项目，一个中型项目。也都是公司在20年的最高优先级项目。由于时间非常紧迫，我参与的第一个项目，必须要在春节之后的四个月内完工。当时真的是忙的鸡飞狗跳。需求分析、需求规格没有做，开发计划只做了一半。由于有1.0版本的经验，我们主要的两个开发人员认为难度不是很大。但是，半年后来复盘，还是草率了。我负责的基础模块有近3w行代码，而部分ui代码加上业务代码，也只有7w行。真的低估了需求的数量和难度。这是一个非常大的教训。这个项目的问题，导致我在参与的第二个项目时，不能全身心投入，总是要抽出一些时间来有bug修复、需求新增和优化。导致两个项目都受影响。
发生这种情况也是因为公司的人手不足，目前，我在负责搭建公司的三维平台，由于我负责的三维岗位很难找到合适的人才，还有一些算法研发的任务，我也是分身乏术。
第二个项目，我负责了主要的详细设计文档的编写工作。目前，在文档编写这一块，基本上已经熟悉的差不多了。我们的详细设计文档，还是很好的指导了开发工作。希望在新的一年中，能继续完善文档方面的工作，进一步的指导开发工作。
今年开始装修房子，这也占用了我大量的时间。幸好爸爸是干这个行业的，自己跑材料、找工人都很熟悉，倒也没花费什么力气，花最少的钱就装修好了房子，不过，用的材料倒是精挑细选的，都是符合新国标的。我们一家，终于在杭州安家落户了。宝妈觉得房子在，就能让人心安。古人云：“无恒产者无恒心”，古人智慧啊。
20年没有发布博客。好像在CSDN倒是写了点什么。在新的一年里，我要在专业上更近一步，要在Vulkan方面做社区上有更多的贡献。在工作上，也带领好小伙伴。让公司的产品卖的更好。
此篇，算作2020年的总结吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe110e7da6c49ba0371de680f3c22ec4/" rel="bookmark">
			input输入框动态提示，输入框&#43;下拉框（DataList）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要做一个类似于百度搜索框的那种 输入关键字段 可以自动提示
在网上找了好多的例子都试了试。好几个利用jQuery的都不行，没有成功。可是却无意间发现了一个input输入框自动提示神器 DataList
DataList的表现很像是一个Select下拉列表，但它只是提示作用，并不限制用户在input输入框里输入什么。 HTML5 Datalist的语法其实跟select下拉列表的语法几乎完全一样，非常的简单！
设备生产厂家：&lt;input type="text" name="sbsccj" id="" list="country" placeholder="请输入设备生产厂家" value="${requestScope.sbsccj }" style="width: 250px" class="input-text"&gt; &lt;datalist id="country"&gt; &lt;option value="Afghanistan 阿富汗"&gt; &lt;option value="Albania 阿尔巴尼亚"&gt; &lt;option value="Algeria 阿尔及利亚"&gt; &lt;option value="Andorra 安道尔共和国"&gt; &lt;option value="Angola 安哥拉"&gt; &lt;/datalist&gt; input的list属性一定要和datalist 标签的id对应 这样才可以让 input标签和datalist 标签关联起来
这样还有一个好处就是 既可以作为输入框使用，也可以作为下拉框使用。
可以避免单纯的输入框 输入内容容易不正确的问题
也可以避免下拉框内容过多 不容易寻找的问题 一举两得
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66a226596c6ff1fc399f0229354af42/" rel="bookmark">
			Verilog二维数组端口使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Verilog二维数组端口使用方法 Verilog不支持二维数组端口定义，限制了模块可扩展性。
通过generate将二维数组打包为一维数组输出，或将一维数组展开为二维数组即可方便地进行管理
将下列宏函数写入头文件并包含在设计中，直接调用宏函数进行打包\展开即可。
//二维数组打包为一维数组 `define PACK_ARRAY(PK_WIDTH,PK_LEN,PK_SRC,PK_DEST) \ generate \ genvar pk_idx; \ for (pk_idx=0; pk_idx&lt;(PK_LEN); pk_idx=pk_idx+1) \ begin \ assign PK_DEST[((PK_WIDTH)*pk_idx+((PK_WIDTH)-1)):((PK_WIDTH)*pk_idx)] = PK_SRC[pk_idx][((PK_WIDTH)-1):0]; \ end \ endgenerate //一维数组展开为二维数组 `define UNPACK_ARRAY(PK_WIDTH,PK_LEN,PK_DEST,PK_SRC) \ generate \ genvar unpk_idx; \ for (unpk_idx=0; unpk_idx&lt;(PK_LEN); unpk_idx=unpk_idx+1) \ begin \ assign PK_DEST[unpk_idx][((PK_WIDTH)-1):0] = PK_SRC[((PK_WIDTH)*unpk_idx+(PK_WIDTH-1)):((PK_WIDTH)*unpk_idx)]; \ end \ endgenerate 使用例
module example ( input [63:0] pack_4_16_in, output [31:0] pack_16_2_out ); wire [3:0] din [0:15]; `UNPACK_ARRAY(4,16,din,pack_4_16_in) wire [15:0] out [0:1]; `PACK_ARRAY(16,2,din,pack_16_2_out) endmodule 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1b4e5ea85350c322cbe39bbb7f0a5d/" rel="bookmark">
			linux网卡提供ioctl操作phy内核源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MAC注册： ./drivers/net/ethernet/freescale/fec_main.c注册mac驱动，compatible匹配dts里面的”fsl,imx6q-fec”的MAC设备，成功后-&gt;probe(fec_probe)中：
struct net_device *ndev = alloc_ethrdev_mqs(); //创建net_dev
SET_NETDEV_DEV(ndev, &amp;pdev-&gt;dev); //绑定net_dev到具体dev
时钟资源get与prepare
fec_reset_phy(); //dts里面phy-reset-gpio
fec_enet_init(dev); //配置fec寄存器，napi接口add
-&gt; netif_napi_add();
-&gt;ndev-&gt;netdev_ops;
-&gt;ndev-&gt;ethtool_ops;
fec_enet_mii_init();
-&gt;创建fep-&gt;mii_bus；
-&gt;mdiobus_register();
register_netdev();
PHY注册： 1、mdio总线注册： ./drivers/net/phy/mdio_bus.c提供了mdio_bus的通用接口，mdio_bus_init()负责创建mdio_bus总线以及bus-&gt;match、bus-&gt;pm，./drivers/net/phy/phy_device.c通过subsys_initcall(phy_init);的phy_init()函数中调用mdio_bus_init()注册mdio总线；
2、mdio驱动注册：
Phy_init()函数调用phy_drivers_register();来注册phy_drivers，包括Generic PHY和Generic 10G PHY这2个通用phy_drivers，挂在mdio_bus总线上。
3、mdio设备注册：
./drivers/net/ethnet/freescale/fec_main.c的probe-&gt;fec_enet_mii_init()中调用mdiobus_register(bus);-&gt;device_register(&amp;bus-&gt;dev);来注册ethx的mdio设备，及具体phy。
遍历0到PHY_MAX_ADDR的phy地址，mdiobus_scan();
Phy_device_register():主要包括
mdiobus_register_device(); //mdiodev-&gt;bus-&gt;mdio_map[paddr] = mdiodev;
Phy_scan_fixups(); //phy寄存器配置
device_add(); //
eth设备的ioctl ethx被up的时候，-&gt;fec_enet_mii_probe(ndev);
首先尝试phy是否被绑定，如果不存在则尝试遍历该网卡的mii总线上的phy是否存在。
eth设备支持ioctl的操作，比如读写phy寄存器等。
sockfd = socket(PF_LOCAL, SOCK_DGRAM, 0);
ret = ioctl(sockfd, SIOCGMIIPHY, &amp;ifr);
通过socket.c的ioctl -&gt; sock_do_ioctl -&gt;dev_ioctl(); -&gt;mac_ioctl
Mac_ioctl就是netdev注册的drv-&gt;fec_enet_ioctl();
-&gt;phy_mii_ioctl();
-&gt;mdiobus_read(bus, phy_id, reg_addr);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf613e5362823998809197592c0d37b/" rel="bookmark">
			基于STM32的计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、开发步骤二、项目实现1.STM32实现串口通信2.STM32的计算逻辑3.Qt界面设计3.1 界面的实现3.2 通讯部分的实现 三、总结 前言 本篇博客主要介绍自己开发一个计算器小项目的过程以及自己在开发过程中遇到的一些问题以及解决的方法。
基于STM32的计算器开发有如下需求：
1.操作界面在电脑端，用C++编写，只负责按键和显示；
2.计算部分在STM32端，用c语言编写，实现计算功能。
概括一下就是在电脑上编写一个上位机程序，主要负责发送数据，计算功能通过32实现。使用到的软件有keil5，QT，需要的基本知识有QT界面开发，C++编程基础，串口通讯等。
提示：此计算器可能存在一些bug和缺点，仅供大家学习参考。如果有新的想法以及问题，欢迎大家前来交流。
一、开发步骤 分为STM32和QT两部分完成，首先我们完成STM32的部分，在STM32上我们需要编写如下功能：
1.数据的接收与计算结果的发送
2.对接收数据的处理
QT上需要实现如下功能：
1.发送数据（相当于我们平时用的串口小程序）
2.接收计算结果并显示
明白了基本需求，我们接下来就开始一步一步的实现这些功能吧！！！
二、项目实现 1.STM32实现串口通信 STM32的串口通讯实现很简单，都是一个套路。网络上也有很多相关的资料，这里就不具体赘述，只简单的叙述一下串口初始化的步骤以及数据收发的操作。
首先我们需要初始化串口，基本步骤如下：
1.串口时钟使能，GPIO 时钟使能
2.复位串口
3.GPIO 端口模式的设置
4.串口参数初始化
5.中断设置初始化
6.使能串口
代码如下：
//这里使用USART1作为我们的串口 void uart_init(u32 bound) { GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; //串口时钟使能，GPIO 时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1| RCC_APB2Periph_GPIOA, ENABLE); //使能 USART1,GPIOA 时钟 //串口复位 USART_DeInit(USART1); //复位串口1 //GPIO 端口模式设置 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //ISART1_TX PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化 GPIOA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faf613e5362823998809197592c0d37b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb433708dc51fefef24141db72d802c/" rel="bookmark">
			基于STM32的计算器2.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1、下位机（STM32）实现计算逻辑1.1 数据存储1.2 运算优先级判断1.3 数据计算 2、上位机开发2.1 数据发送2.2 新增按钮功能2.2.1 开方运算2.2.2 CE2.2.3 % 总结 前言 之前的博客里介绍了我开发一个基于STM32的计算器的全部过程，包括下位机的开发以及上位机开发，但是这个计算器仍然存在许多的缺点。
1.无法进行混合运算，只可以进行两个数的基本四则运算
2.没有开方，CE等功能
3.计算逻辑考虑复杂，可以有更简单的实现方式
4.由于发送数据方式的问题，最多只能计算一个长度为8的表达式（包括计算符号）
这篇文章主要介绍我们计算器2.0的开发过程以及对一些关键算法逻辑的解释，计算器2.0能够实现复杂的多项式运算，判断运算优先级，并且增加了开方运算，百分号等功能。
1、下位机（STM32）实现计算逻辑 下位机用来完成我们的计算，他的计算逻辑包括如下几个部分：数据存储，运算优先级判断以及数据计算，下面分成这三块来介绍我的算法。
1.1 数据存储 在计算器1.0中，上位机发送数据的方式是一次性发送所有数据，这样的发送方式会存在一个问题就是当我们输入的计算表达式过长时，无法完全发送，最多只能发送8位数据。所以在计算器2.0版本中，采用一位一位发送数据的方式，这样我们计算表达式的位数就不会受到限制了。
根据这种发送数据的方式，我们使用了另外一种存储数据的方式，将数据和计算字符按顺序分别存放在两个数组中。首先设置标志位（temp_flag）用于判断是否有数据输入，而不是结束标志（0x0d 0x0a），当收到数据发送完成的结束标志位后，我们会对之前存储的数据进行运算，这个后面会说。
对上位机发送过来的每个数据首先需要进行判断是数值还是符号，判断函数如下：
//先判断输入是否为计算符号，若是计算符号，记录计算方式以及符号的位置 //存储在一个结构体save_ComputeInfo中 int find_ComputeWay(u8 sign) {	if(sign == '+') { return 1; } if(sign == '-') { return 2; } if(sign == '*') { return 3; } if(sign == '/') { return 4; } return 0; } way = find_ComputeWay(USART_RX_BUF[len-1]); if(way){ if(char_idx&lt;100){ save_ComputeInfo[char_idx].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddb433708dc51fefef24141db72d802c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cedd1920eec4aef730f3efb411e958b/" rel="bookmark">
			解决 dubbo在nacos注册出现ErrCode:400, ErrMsg:caused: dom name can only have these characters: 0-9a-zA-Z-问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主要异常如下
com.alibaba.nacos.api.exception.NacosException: failed to req API:/nacos/v1/ns/instance after all servers([192.168.11.43:8848]) tried: ErrCode:400, ErrMsg:caused: dom name can only have these characters: 0-9a-zA-Z-._:, current: DEFAULT_GROUP@@providers:com.project.api.Api$Iface:1.0.0:; 原因是因为
dubbo只能包含"[*,\\-._0-9a-zA-Z]+"这些字符
nacos只能包含"0-9a-zA-Z -._，"这些字符
我的地址中包含了'$'，为什么我的服务注册会出现$呢。是因为我的接口是这样编写。
public class Api { public interface Iface{ void get(); } } 这里是实现
@DubboService public class ApiImpl implements Api.Iface{ @Override public void get() { System.out.println("qqqqqqqqqqqqqqqq"); } } 在nacos注册服务中，不支持这样的格式。
改成如下即可
public interface Api { void get(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d70aeac7eecae96f0f78bf3701b5044/" rel="bookmark">
			freescale MC9S12G128 ADC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MC9S12G128 ADC10B12CV2 Features:Conversion Modes:MCU Operating Modes:Block Diagram:信号描述：寄存器：寄存器列表：ATDCTL0:ATDCTL1:ATDCTL2:ATDCTL3:ATDCTL4:ATDCTL5:ATDSTAT0:ATDCMPE:ATDSTAT2:ATDDIEN:ATDCMPHT:ATDDRn:PRR0:PRR1: 演示代码：单次转换模式：扫描转换模式：外部触发模式： Features: • 8-, 10-bit resolution.
• Automatic return to low power after conversion sequence
• Automatic compare with interrupt for higher than or less/equal than programmable value
• Programmable sample time.
• Left/right justified result data.
• External trigger control.
• Sequence complete interrupt.
• Analog input multiplexer for 8 analog input channels.
• Special conversions for VRH, VRL, (VRL+VRH)/2.
• 1-to-12 conversion sequence lengths.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d70aeac7eecae96f0f78bf3701b5044/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab64aa32cb89a40ea6d98b7b86bc04e/" rel="bookmark">
			autoware安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 链接 Autoware入门学习（二）——Ubuntu18.04下的源码安装和配置
ubuntu18.04 Autoware源码安装
安装包自身github下载
ubuntu18.04 安装autoware教程
1 依赖项 安装autoware前预先安装以下软件：
（1）ubuntu18.04+ros melodic
(2)Qt 5.12
sudo apt update sudo apt install -y python-catkin-pkg python-rosdep ros-$ROS_DISTRO-catkin sudo apt install -y python3-pip python3-colcon-common-extensions python3-setuptools python3-vcstool pip3 install -U setuptools 2 安装Eigen $ cd &amp;&amp; wget http://bitbucket.org/eigen/eigen/get/3.3.7.tar.gz #Download Eigen $ mkdir eigen &amp;&amp; tar --strip-components=1 -xzvf 3.3.7.tar.gz -C eigen #Decompress $ cd eigen &amp;&amp; mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make &amp;&amp; make install #Build and install $ cd &amp;&amp; rm -rf 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab64aa32cb89a40ea6d98b7b86bc04e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db4a8ade2112e39dd25f8a3ccb3d0c0/" rel="bookmark">
			swagger的使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Swagger的基本介绍 前后端分离情境下，相信许多朋友都会给第三方提供接口，跟自家的前端或者后端对接接口。
以前:
前端:我们对接一下接口，接口文档给我一份呗。
后端:等一下，我还在整理接口文档。
现在:
前端:我们对接一下接口，接口文档给我一份呗。
后端:要啥接口文档吗，swagger自动给我生成了,诺，地址给你（心里美滋滋，妈妈再也不用担心我还要写接口文档了）。
没错，Swagger就是为了解决接口对接等方面的问题，通过与程序集成在一起，通过注解等方式定义Controller等,说明每个Controller接口的名称，干啥的，接收参数字段对应什么名字，返回的数据又是啥，说明好这些，前端就直接根据文档慢慢对接，后端也可以继续开发，节约了很多时间。
二、Swagger的基本注解的介绍 1、@Api
/** value : 界面不显示，一般不需要配置 tags : 解释Controller的作用，用于什么业务,会在swagger导航栏处显示 **/ @Api(value = "访客机对接接口",tags = "访客机对接接口") 2、@ApiOperation
/** 说明 ：该注解用于Controller方法上，解释接口的相关信息 value : 这里用于说明接口的作用 notes : 这里用于说明注意事项和备注 code : 好像没啥用，可以不需要 produces : 类似于@RequestMapping中的produces，表示接口返回格式 **/ @ApiOperation(value = "访客机刷身份证交互接口",code = 0,notes = "访客机刷身份证之后需要进行的操作",produces = "application/json") 3、@ApiModel
/** 说明 ： 该注解用于springmvc数据绑定到的实体类上，用于说明实体类作用 value : 用于说明数据类型 description : 实体类的作用说明，比如接收订单信息等 **/ @ApiModel(value = "访客记录查询参数",description = "用于访客机查询访客人员访问记录") 4、@ApiModelProperty
/** 说明 ： 该注解用于实体类中的参数属性上，解释每个属性相关信息 name : 属性名称 value : 属性的作用解释 required : 是否必须 **/ @ApiModelProperty(name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db4a8ade2112e39dd25f8a3ccb3d0c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8cd972c2b59dd979f5ba7d54e15c6f/" rel="bookmark">
			机器人也能配送固定资产了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能、5G、物联网、大数据的不断发展，加上近年来我国陆续出台一系列政策支持服务机器人行业发展。各大厂商开始加码技术链条布局。SLAM、AI芯片、机器视觉、语音识别、UWB等核心技术获得较快发展，机器人的性能和智能化程度也得以提升。机器人可以做的事情很多：码垛、分拣、搬货、理货、配送等。今天我们探讨一下机器人配送。
什么是机器人配送？
根据应用的领域不同，国际机器人联盟（IFR）将机器人分为工业机器人和服务机器人两大类。机器人配送是指用于非制造业、以服务为核心的自主或半自主机器人代替人工，从事各种配送物品的工作。
机器人智能配送的需求与日俱增
从需求看，用户对末端配送的及时性、便捷性、安全性提出了更高的要求，但依靠双腿进行末端配送已经不能满足用户需求。具体来说，从“人找货”到“货找人”改变了“人-货-场”之间的相互关系，更好地满足用户的需求。当配送需求量快速增长时，人力资源的供给无法跟上，加上人工成本的上升和招聘的风险性等。机器人智能配送是人从简单重复的劳动中解脱出来的最佳方案。
疫情背景下，服务机器人的需求和无接触式配送的需求都与日俱增。服务机器人的价值凸显，市场认可度不断提升，行业有望获得进一步发展。有另外，在有特定场景下，机器人配送的优势更加凸显。市场上对机器人配送的需求越来越多。
基础设施的日益完善助力机器人智能化进程
随着5G、人工智能、云计算等基础设施的日新月异，助力推动机器人朝着更加智能化的方向发展。机器人跟软件之间的交互、感知的灵敏度、运控的精细化、人与机器人的交互等。配送机器人行业也在飞速发展，今后的行业竞争中心将是技术、场景、和资源的综合积累。个性化场景定制与产业数字化赋能将是厂商价值赋能的重要模式。
配送机器人的价值何在？
从安全的角度，在此次抗击疫情的过程中可以很明显地感受到无接触配送的价值和意义得到了迅速的放大，运输全程无人化极大的降低了风险，节省了人力。
从经济价值考虑，一方面疫情的催化加速了配送机器人的落地，实现量产和市场化，平摊下来的成本降低；另一方面，人力成本的提升，尤其是在劳动力成本高、人员紧缺的一线城市，如果采纳配送机器人无疑提升性价比。
从配送机器人自身的价值来看，配送机器人智能化和信息化程度日益提升，将其用于各种配送上，会减少人员的重复劳动，并实现全流程的监控，提升了整体的工作效率。
机器人如何配送固定资产？
易点易动将自身的固定资产和库存管理系统跟机器人、UWB相结合，推出智能化的实物管理和配送解决方案。以其中一个场景为例：员工A在易点易动系统中申请了一台笔记本电脑，管理员审批后，在手机APP发放完毕后，点击发送。这时，机器人可根据UWB定位标签定位到管理员所在的位置，过来取货。管理员将笔记本放在机器人上后，机器人开始按自动规划的最佳路线开始配送，通过UWB定位标签找到员工所在位置，最后员工在APP中签字收货。
https://v.youku.com/v_show/id_XNTA1NDk3NjM2MA==.html
易点易动机器人配送物品有如下优势：
1）机器人能自动定位到待送的物品的位置，并过来取货。2）机器人可根据员工（接受者）的工牌（工卡型UWB定位标签）定位到员工的位置，接到货物后，按照自动规划的路线，行走至接收者附近。3）可自动躲避静态和动态的障碍物，避免发生碰撞。比如当有人员突然接近它时，它会自动减速和避开，自动微调原设置好的轨迹，然后重新进入原轨迹。接近视觉盲区，它能自动减速并启动警报。4）数字化管理，配送流程可追溯。
机器人的应用场景：1）不利于人员经常出入的比如有辐射或者狭窄的库房等，机器人可以出入自如。2）规模和面积比较大的仓库。3）仓库、医院、酒店、养老院、公寓、学校、写字楼等。
易点易动负责人表示，推出智能化机器人配送物品最主要是从实际仓库需求出发，同时实现提高效率和提升用户体验。目前，随着各行各业对无接触式管理需求的增加，给智能化机器人配送带来了更多的需求和商机。易点易动团队将一如既往地为客户提供智能化实物资产和库存管理方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18a11f74791c60acb7c3299cb41f5c76/" rel="bookmark">
			ArcGIS 3个查询 =＞QueryTask、FindTask、IdentifyTask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 查询Task:查询任务query:询问QueryTask的基本过程 find:发现找到FindTask的基本过程 Identify:识别,认出Identify基本过程 查询Task:查询任务 QueryTask、``FindTask、IdentifyTask都是继承自ESRI.ArcGIS.Client.Tasks`看看就行啊,别拿来用啊!我可不负责运行的!!! query:询问 QueryTask：是一个进行空间和属性查询的功能类
它可以在某个地图服务的某个子图层内进行查询。
假设一个地图有底图(背景),县的一张图,市的,省的,都是叠加上去的,一层层覆盖某个子图层就是县或者市这些图的某一张 QueryTask进行查询的地图服务并不必须加载到Map中进行显示。
只是查询数据,不是查了北京就会显示北京,但是可以看到数据,面积等等 QueryTask的执行需要两个先决条件：一个是需要查询的图层URL、一个是进行查询的过滤条件。
URL:哪个地图的,哪个子图层。http://xx/地图/第一个图层.过滤条件:名字,坐标等等 QueryTask的基本过程 新建一个QueryTask =&gt; 一个查询的任务: 参数url:xx/MapServer/5 =&gt; MapServer的第5个子图层 过滤条件:没有写后面肯定会加的 =&gt; 两个先决条件:这个肯定需要的 QueryTask queryTask = new QueryTask("http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Demographics/ESRI_Census_USA/MapServer/5"); Query对象:这个就是过滤条件了 =&gt; 条件加在这里 Query query = new Query(); 传入空间几何范围，可以不设置 =&gt; geometry:几何geometry对象中有很多参数 =&gt; Extent范围, Point点, Polyline线,面等等 //你要根据一个几何图形查询(正方形),如果地图中有的话 =&gt; 如果没有,sql你学过了,你懂了,加了会怎么样 query.Geometry = geometry; 查询结果返回的字段，字段必须在图层中，字段的大小写可忽略quer.OutField.Add("*"); =&gt; select * where x=geometry; //不懂别学了好吧 query.OutFields.AddRange(new string[] { "AREANAME", "POP2000" }); 外比巴卜 query.Where = "POP2000 &gt; 350000"; 任务执行 =&gt; 执行条件是query返回一个fratureset =&gt; 就是返回一个你查询到的一块你指定小地图(北京)的所有数据 这个返回的数据不会直接显示,所以有个set,你可以自己去设置比如直接add到Map地图显示,或者打印出来给别人看 =&gt; 北京1949年xx… FeatureSet featureSet = queryTask.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18a11f74791c60acb7c3299cb41f5c76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00756f730cbaa9e08e375bc8bfa50dba/" rel="bookmark">
			【mysql】 “” 与 ‘‘ 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【mysql】 “” 与 '' 区别 (1) "" 是表达式，会把之后的语句包括进来 (2) '' 是占位符， 不会把之后的语句包括进来 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d876a7cd18c50394575b6bf2a22b8a3f/" rel="bookmark">
			js数字格式化输出_干货满满！如何优雅简洁地实现时钟翻牌器(支持JS/Vue/React)...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双十一剁手节过去了，大家应该在很多网页中看到了数字翻牌的效果吧，比如倒计时、 数字增长等。相信很多人都已经自己独立实现过了，我也在网上看了一些demo，发现HTML结构大多比较复杂，用了4个并列的标签来放置前后两个“牌”。本文就来讲解下，如何进一步精简HTML，让结构简单，让JS方法封装得易使用。先来看看最终效果：
每个翻牌的HTML结构(精简至2个并列标签)：
本次分享含有很多小技巧，灵活使用能够提升技术水平和工作效率，具体包括以下知识点：
知识点1：:before :after伪元素的使用
知识点2：line-height: 0的妙用
知识点3：transform-origin和perspective
知识点4：backface-visibility
知识点5：时间格式化函数的实现
Let's do it!
1 翻牌的构建 1.1 基本结构
首先解释下HTML的结构：
【说明】
flip: 纸牌的外框
down：表示向下翻牌动效，还有对于的up。后面章节会具体讲解。
front: 表示位于前面的纸牌
back: 表示位于后面的纸牌
number*: 表示纸牌上的数字
flip的CSS代码如下：
这段代码很基础，就不再详细解释了。眼尖的同学可能发现了，为什么要设置background为#fff(白色)呢?最终效果明明是黑的。留个疑问，下一小节就会明白了。
基本结构的效果是这样的:
1.2 构建纸牌并用伪元素拆分上下两部分
由于每个纸牌是上下对折、翻转的，所以每个纸牌要拆分成上下两部分。可是HTML中每个纸牌只有一个标签，怎么拆分成两个呢？这里就用到了before和after伪元素。
知识点1： 伪元素的使用
先看代码：
:before和:after在digital内部生成了两个伪元素，其中，before用来生成纸牌的“上半张”，after用来生成纸牌的“下半张”。
因此，before“上半张”为从“顶部(top: 0)”到“距底一半(bottom: 50%)”的部分，顶部两侧为圆角。
同理，after“下半张”为“距顶一半(top: 50%)”到“底部(bottom: 0)”的部分，底部两侧为圆角。
注意代码中的 content:"" 不能省略，否则伪元素是不显示的。
效果如下：
回答上一章节的问题，为什么底层设置background为白色？
答案很简单，元素内部的纸片边角和外层边角之间会有一点点的缝隙，这个缝隙会露出底部的白色，从视觉效果上看，更加具有立体感。
然后，为上下部分中间添加一条水平折线。
外层flip添加box-sizing: border-box保证了下边框不会影响元素的原有高度。
效果如下：
到这里，我们可以认为是4个小纸片，分别是：
前上：.digital.front:before前下：.digital.front:after后上：.digital.back:before后下：.digital.back:after 由于重叠在一起，只能看到一张纸牌。而看到的这个纸牌是后面(back)的纸牌，为什么呢？因为back的HTML写在了front的后面。不过没关系，后面我们会通过z-index来重新调整层叠顺序，先不着急。
1.3 为纸牌添加文字
还记的刚才的 content: "" 吗？纸牌的文字显示就用到了这个。
先通过CSS定义好0~9的数字：
现在效果如下：
可以很明显的看到两个问题：
本应该在后面的back纸牌跑到了前面(z-index问题)下半张纸牌的文字应该只显示下半部分。 先来解决问题2，这里就涉及到了第二个知识点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d876a7cd18c50394575b6bf2a22b8a3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34499f4a5a56d26db9fdc3f6dc3207e/" rel="bookmark">
			BFS 进阶之 A*， 双向bfs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 双向BFS例1、 [走迷宫](http://noi.openjudge.cn/ch0205/2753/)例2、[八数码](https://www.acwing.com/problem/content/description/847/) A* 算法简要概述具体做法关于算法的数学理论部分例1、[Knight Moves](http://poj.org/problem?id=2243)例2、[八数码](https://www.acwing.com/problem/content/description/181/)例 3、[第k短路](https://blog.csdn.net/CUCUC1/article/details/113185677) 关于双向BFS和A*的一些小缺陷 双向BFS 在由起点状态到目标状态进行搜索时,搜索树是以指数层级递增的,所以说在一些情况下,时间复杂度会导致单向的bfs TLE掉或者 MLE掉,这时候就需要对bfs进行一些优化,双向bfs就是一种,双向bfs适用于得知起点和目标点状态时适用,使用两个队列分别从起点和目标点进行双向搜索,当两个方向的状态第一次相遇,即为最短转移路径,这样可以限制搜索树的深度一般在原搜索树的一半左右,极大的降低了所需的复杂度
可以参考一下这个图 引用自
当两种颜色相遇的时候，说明两个方向的搜索树遇到一起，这个时候就搜到了答案。
例1、 走迷宫 这个题单向bfs也是可以的，但是也可以作为双向bfs的联系，很简单，直接上代码了，注释我自认为是比较详细的
注意我们在出队列的时候，我们要选择搜索树较小的那个出队列，这样就可以把总的搜索树尽可能压小也可以这样想如果选择大的，和单向bfs就没啥不同了
#include &lt;iostream&gt; #include &lt;queue&gt; #include &lt;cstdio&gt; using namespace std; const int maxn = 45; const int dir[4][2] = {{-1,0}, {0,1}, {1,0},{0,-1}};//方向 queue &lt;pair &lt;int,int&gt; &gt; q1, q2; int dis[maxn][maxn]; int vis[maxn][maxn];//vis 1 表示 q1扩展得到,2 表示 q2扩展得到 char maps[maxn][maxn]; bool check(int x, int y, int r, int c) { if (x &lt; 0 || x &gt;= r || y &lt; 0 || y &gt;= c || maps[x][y] == '#') return false; return true; } int dbfs(int r,int c) { bool flag;//记录这次是出的哪一个队列 //将起点终点入队列,并标记 vis[0][0] = 1,vis[r - 1][c - 1] = 2; dis[0][0] = dis[r - 1][c - 1] = 0; q1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34499f4a5a56d26db9fdc3f6dc3207e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084f6758ad87c5373f8dbed020d4a0c7/" rel="bookmark">
			套索回归详解 从零开始 从理论到实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		套索回归详解 从零开始 从理论到实践 一、套索回归的理解二、sklearn的使用2.1、方法、参数与属性2.2、简单案例 一、套索回归的理解 套索回归与岭回归相似，只不过收缩惩罚项变成了可调超参数与所有系数绝对值之和的乘积：
残差平方和(RSS, Residual Sum Of Squares):
R S S = ∑ i = 1 n ( y i − y ^ i ) 2 RSS=\sum^n_{i=1}(y_i-\hat y_i)^2 RSS=i=1∑n​(yi​−y^​i​)2
J β ( β ) = 1 2 n R S S + λ ∑ j = 1 p ∣ β ^ j ∣ J_{\beta}(\beta)=\frac{1}{2n}RSS+\lambda\sum^p_{j=1}|\hat\beta_j| Jβ​(β)=2n1​RSS+λj=1∑p​∣β^​j​∣
n n n 是样本的数量 ∣ β ^ j ∣ |\hat\beta_j| ∣β^​j​∣ 是 L 1 L1 L1范数 λ ∑ j = 1 p ∣ β ^ j ∣ \lambda\sum^p_{j=1}|\hat\beta_j| λ∑j=1p​∣β^​j​∣ 是收缩惩罚项(shrinkage penalty)，试图减少特征的数量来简化线性回归模型。 二、sklearn的使用 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/084f6758ad87c5373f8dbed020d4a0c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89955cf555d74c1b79603524d69d8e61/" rel="bookmark">
			多项式回归详解 从零开始 从理论到实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多项式回归详解 从零开始 从理论到实践 一、多项式回归的理解1.1、字面含义1.2、引申1.2.1、多项式回归 二、sklearn的使用2.1、方法与属性2.2、实例应用2.2.1、拟合非线性关系2.2.2、处理特征之间的影响2.2.3、多项式回归与不同degree的对比 一、多项式回归的理解 上一章是对线性关系的建模。比如在线性回归中，会假设建筑物的楼层数和建筑物的高度是一个线性关系，20层楼是10层楼的两倍左右高，10层楼是5层楼的两倍左右高。(即便不是线性关系，但是近似线性关系，误差很小，即可以等同线性关系)
然而在现实生活中，许多关系则几乎完全不是线性的，比如学生学习的时间和考试分数之间的关系，在60分及格分以上，考试每提高10分，所花的时间会越多(因为后面基本都是越来越难的题目，需要花更多时间练习，而不是每道题目难度一样)。
多项式回归是线性回归的一种扩展，它可以使我们对非线性关系进行建模。线性回归使用直线来拟合数据，如一次函数 y = k x + b y=kx+b y=kx+b等。而多项式回归则使用曲线来拟合数据，如二次函数 y = a x 2 + b x + c y=ax^2+bx+c y=ax2+bx+c、三次函数 y = a x 3 + b x 2 + c x + d y=ax^3+bx^2+cx+d y=ax3+bx2+cx+d以及多次函数等来拟合数据。
通过线性回归所不能解决的问题出发，由此来介绍多项式回归。
参考1 一次函数与直线的关系
参考2 线性函数 非线性函数 多项式函数
1.1、字面含义 多项式的理解：
“多项式回归”由“多项式”和“回归”组成。
“多项式”(polynomial)的含义：在数学中，多项式是指由若干个单项式(monomial)相加组成的代数式叫做多项式（若有减法：减一个数等于加上它的相反数）。
多项式中的每个单项式叫做多项式的项，这些单项式中的最高项次数，就是这个多项式的次数。单项式由单个或多个变量(一般为单个 x x x)和系数相乘组成，或者不含变量，即不含字母的单个系数(常数)组成，这个不含字母的项叫做常数项。
多项式函数：
形如 f ( x ) = a n x n + a n − 1 x ( n − 1 ) + … + a 2 x 2 + a 1 x + a 0 f(x)=a_nx^n+a_{n-1}x^{(n-1)}+…+a_2x^2+a_1x+a_0 f(x)=an​xn+an−1​x(n−1)+…+a2​x2+a1​x+a0​的函数，叫做多项式函数，它是由常数与自变量x经过有限次乘法与加法运算得到的。显然，当n=1时，其为一次函数 y = k x + b y=kx+b y=kx+b，当n=2时，其为二次函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89955cf555d74c1b79603524d69d8e61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c99f2b3314adf25a027416e27ad767a3/" rel="bookmark">
			让 Flutter 在鸿蒙系统上跑起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙系统 （HarmonyOS）是华为推出的一款分布式操作系统，那么如何在保证开发迭代效率的前提下，以相对低的成本将移动应用快速移植到鸿蒙平台上呢？美团外卖 MTFlutter 团队近期做了一次技术探索，成功地实现了 Flutter 对于鸿蒙系统的原生支持。
前言
鸿蒙系统 （HarmonyOS）是华为推出的一款面向未来、面向全场景的分布式操作系统。在传统单设备系统能力的基础上，鸿蒙提出了基于同一套系统能力、适配多种终端形态的分布式理念。自 2020 年 9 月 HarmonyOS 2.0 发布以来，华为加快了鸿蒙系统大规模落地的步伐，预计 2021 年底，鸿蒙系统会覆盖包括手机、平板、智能穿戴、智慧屏、车机在内的数亿台终端设备。对移动应用而言，新的系统理念、新的交互形式，也意味着新的机遇。如果能够利用好鸿蒙的开发生态及其特性能力，可以让应用覆盖更多的交互场景和设备类型，从而带来新的增长点。
与面临的机遇相比，适配鸿蒙系统带来的挑战同样巨大。当前手机端，尽管鸿蒙系统仍然支持安卓 APK 安装及运行，但长期来看，华为势必会抛弃 AOSP，逐步发展出自己的生态，这意味着现有安卓应用在鸿蒙设备上将会逐渐变成“二等公民”。然而，如果在 iOS 及 Android 之外再重新开发和维护一套鸿蒙应用，在如今业界越来越注重开发迭代效率的环境下，所带来的开发成本也是难以估量的。因此，通过打造一套合适的跨端框架，以相对低的成本移植应用到鸿蒙平台，并利用好该系统的特性能力，就成为了一个非常重要的选项。
在现有的众多跨端框架当中，Flutter 以其自渲染能力带来的多端高度一致性，在新系统的适配上有着突出的优势。虽然Flutter 官方并没有适配鸿蒙的计划，但经过一段时间的探索和实践，美团外卖 MTFlutter 团队成功实现了 Flutter 对于鸿蒙系统的原生支持。
这里也要提前说明一下，因为鸿蒙系统目前还处于Beta版本，所以这套适配方案还没有在实际业务中上线，属于技术层面比较前期的探索。接下来本文会通过原理和部分实现细节的介绍，分享我们在移植和开发过程中的一些经验。希望能对大家有所启发或者帮助。
背景知识和基础概念介绍
在适配开始之前，我们要明确好先做哪些事情。先来回顾一下 Flutter 的三层结构：
在 Flutter 的架构设计中，最上层为框架层，使用 Dart 语言开发，面向 Flutter 业务的开发者；中间层为引擎层，使用 C/C++ 开发，实现了 Flutter 的渲染管线和 Dart 运行时等基础能力；最下层为嵌入层，负责与平台相关的能力实现。显然我们要做的是将嵌入层移植到鸿蒙上，确切地说，我们要通过鸿蒙原生提供的平台能力，重新实现一遍 Flutter 嵌入层。
对于 Flutter 嵌入层的适配，Flutter 官方有一份不算详细的指南，实际操作起来成本很高。由于鸿蒙的业务开发语言仍然可用 Java，在很多基础概念上与 Android 也有相似之处（如下表所示），我们可以从 Android 的实现入手，完成对鸿蒙的移植。
Flutter 在鸿蒙上的适配
如前文所述，要完成 Flutter 在新系统上的移植，我们需要完整实现 Flutter 嵌入层要求的所有子模块，而从能力支持角度，渲染、交互以及其他必要的原生平台能力是保证 Flutter 应用能够运行起来的最基本的要素，需要优先支持。接下来会依次进行介绍。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c99f2b3314adf25a027416e27ad767a3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/387/">«</a>
	<span class="pagination__item pagination__item--current">388/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/389/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>