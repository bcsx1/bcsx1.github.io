<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f9d074b48fe4f38a444ab21c6447038/" rel="bookmark">
			【python】批量裁剪图片为指定大小，按位置截取，cv2（批量制作主图）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		京东电商的主图需要800*800和624*800两种不同的尺寸（不同类目有所不同），
得到的素材是一份800*800的图片，手动裁剪成624*800效率太低了，
python又派上用场了！
用cv2模块，可以快速将图片裁剪成所需要的大小，至于裁剪的位置嘛，需要事先计算一下。
改进方向：自动按中间的位置裁剪，再升级可以改进为自动识别中心位置并进行裁剪
【这次升级为批量裁剪啦！】
1. 安装cv2模块
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python 2. 新建 cut 和 out 文件夹
import numpy as np import cv2 import os def update(input_img_path, output_img_path): image = cv2.imread(input_img_path) print(image.shape) cropped = image[0:800, 88:712] # 裁剪坐标为[y0:y1, x0:x1] cv2.imwrite(output_img_path, cropped) dataset_dir = 'cut' output_dir = 'out' # 获得需要转化的图片路径并生成目标路径 image_filenames = [(os.path.join(dataset_dir, x), os.path.join(output_dir, x)) for x in os.listdir(dataset_dir)] # 转化所有图片 for path in image_filenames: update(path[0], path[1]) 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f9d074b48fe4f38a444ab21c6447038/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45596605aec544f329d7ee3cd932407a/" rel="bookmark">
			你好2020
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		00 年代如同梦呓，10 年代就在昨日。
趁大家都在纪念着 10 年代的结束，我是不是可以偷偷的原谅自己不太满意的过去。
希望过往所有的遗憾都是未来惊喜的铺垫。
生活从未偏爱过谁，可我能听懂你的歌，这也许就是你我生存下去的意义。
—— 佚名
2019 年 23 点 58 分，我抬手看了看时间，嗯，还有两分钟。
我盯着时间走到 59，开始在心中倒数，60.59.58…，不晓得是心情不够平静，还是身边歌声太过喧嚣，在倒数 5 秒的时候，时间竟然已经到了 00:00，就在眨眼的那前一秒还是大大的 59，59 的轮廓显得繁琐，如同我 2019 年一整年的生活；又如同我过往的 10 年代；眼那么一眨，就都翻过去了，然后时间一切归零，2020/01/01/00:00，悄悄的说一句：
你好，2020。
我公历是 1996 年生，农历是 1995 年生，不准确的说，我从本命年跨到了本命年。时间对我来说一直是一个很敏感的东西，虽然我也经常睡过头，然后又总是为此伤神，然后蒙上被子继续睡，妄图睡到第二天清晨。
十年前是 2010 年，那年发生了什么，那时候应该是初中，正年少，正轻狂，正意气风发，使劲想想应该能想起来，但是不如 2008 年好记，08 年奥运会，雪灾，转学。奥运会记忆已经不够深刻了，雪灾的雪大概也只剩白色了，转学到市里大概是我深刻的记忆了。好像一切都雾蒙蒙，忘的一干二净，但是曾经的稚嫩犹存。
今年 2020 年，人类没有离开地球，至今我也没见过奥特曼，哆啦 A 梦到现在都是我的梦中好友，喜羊羊灰太狼我早就看穿了，就像小时候看戏，台上打得难舍难分，私下里也都是很好的朋友，度过了那么多信以为真的虚假，瞒住了过往的十年，瞒不住 20 年代的破晓，瞒不过心中向往未来的光。
这一切都和我小时候想的有那么些不一样，我以为现在的我攒下的弹珠应该有一麻袋了，但是手里一个都没有；我以为现在的我跳方格应该可以跳到最后一格，可现在的我动弹一下都觉得累；我以为现在的我滑旱冰可以傲视群雄了，谁知道 19 年摔得那一下膝盖至今隐隐作痛；我以为，2020 年的我应该是个大人了，可是呢，现在的我却还在远方。
父母在，不远游，游必有方。爸爸妈妈，新的一年，我还是很想你们。我不知道什么是成长，但我感觉得到什么是思念。从一周三次电话不思念，到现在的，总记不起打电话却又总是思念。
2020 年了，那群把太阳画在左上角的孩子长大了。
我希望我的 20 年代是美好的：
我希望我每天都按时起床，去食堂吃一碗热乎的豆腐脑，告诉阿姨，单数日子不要加香菜，双数的日子多要一份香菜；找酱香饼小哥要三块钱饼，等他给我弄刚出锅的饼，刷酱的时候聊几句；再去包子铺买个鸡蛋～
我希望我可以认真对待每一餐；
我希望我可以合理的安排时间，问心无愧的做自己喜欢的事情，爱自己喜欢的人；
我希望我可以温柔且强大；
我希望我坚强决绝从不做作；
我希望我可以好好爱自己；
我希望我可以在阳光下蹦蹦跳跳，穿着干净清爽的衣服，在闲暇时去喝杯咖啡～
我希望我可以不够帅的滑着滑板用最帅的心情去看电影；
我希望我想哭的时候有人陪，开心的时候也是这个人陪着；
我希望我遇到一个人，我们彼此尊重，彼此欣赏，我们互相爱慕，我们很聊得来，也很少相互埋怨；
我希望我爱过的人都拥有属于自己的幸福；
我希望每一个灵魂都可以勇敢的有尊严的坚强的活着；
我希望我的亲人健康；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45596605aec544f329d7ee3cd932407a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8578d01d026202978784b1d58f5b4103/" rel="bookmark">
			吴恩达机器学习作业6——SVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sb from scipy.io import loadmat from sklearn import svm def plotData(X, y): plt.figure(figsize=(8,5)) plt.scatter(X[:,0], X[:,1], c=y.flatten(), cmap='rainbow') plt.xlabel('X1') plt.ylabel('X2') plt.legend() def plotBoundary(clf, X): '''plot decision bondary''' x_min, x_max = X[:,0].min()*1.2, X[:,0].max()*1.1 y_min, y_max = X[:,1].min()*1.1,X[:,1].max()*1.1 xx, yy = np.meshgrid(np.linspace(x_min, x_max, 500), np.linspace(y_min, y_max, 500)) Z = clf.predict(np.c_[xx.ravel(), yy.ravel()]) Z = Z.reshape(xx.shape) plt.contour(xx, yy, Z) def gaussKernel(x1, x2, sigma): return np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8578d01d026202978784b1d58f5b4103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb72b239556a7e1da6da534b223ccd30/" rel="bookmark">
			吴恩达机器学习作业5——偏差与方差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前半部分的练习中，你将实现正则化线性回归，以预测水库中的水位变化，从而预测大坝流出的水量。在下半部分中，您将通过一些调试学习算法的诊断，并检查偏差 v.s. 方差的影响。
import numpy as np import matplotlib.pyplot as plt from scipy.io import loadmat import scipy.optimize as opt def plotData(): """瞧一瞧数据长啥样""" plt.figure(figsize=(8, 5)) plt.scatter(X[:, 1:], y, c='r', marker='x') plt.xlabel('Change in water level (x)') plt.ylabel('Water flowing out of the dam (y)') plt.grid(True) def costReg(theta, X, y, l): # 正则化cost cost = ((X @ theta - y.flatten()) ** 2).sum() regterm = l * (theta[1:] @ theta[1:]) return (cost + regterm) / (2 * len(X)) def gradientReg(theta, X, y, l): # 正则化线性回归梯度 grad = (X @ theta - y.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb72b239556a7e1da6da534b223ccd30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871446dae1fcac33bfeb4c5101107a5e/" rel="bookmark">
			吴恩达机器学习7——支持向量机SVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		吴恩达机器学习7 一、SVM直观理解1. SVM引入逻辑回归2. 大边界分类器SVM3. SVM原理 二、核函数1. 核函数原理和概念2. SVM和核函数结合的计算步骤 三、使用SVM 一、SVM直观理解 1. SVM引入逻辑回归 与逻辑回归和神经网络 相比，支持向量机，或者简称 SVM，在学习复杂的 非线性方程 时提供了一种更为清晰，更加强大的方式。它也是我们所介绍的最后一个监督学习算法。
如我们之前的学习算法，我们从优化目标开始。为了描述支持向量机，将会从逻辑回归开始展示我们如何一点一点修改来得到本质上的支持向量机。
其CostFunction为：
在SVM中对costfunction进行改变：
将其中log函数部分换成了蓝色折线所代表的cost函数。
2. 大边界分类器SVM SVM是一种“宽边界”分类器（Large Margin Intuition）。
如图，SVM希望找到“最中间”的那条分界线（最宽边界）来分割两类。我们一步步来看：
首先观察SVM代价函数的图像：
和逻辑回归相比较：
IF y=1, we want θTx≥1 (not just ≥0)IF y=0, we want θTx≤−1 (not just ≤0)
同时，当C非常大时，我们希望蓝色的这部分为0
最小化问题便转变成：
3. SVM原理 通过上一节简化问题，我们知道SVM要求的最小值为||θ||的最小值，即θ的范数最小值。模型如下：
下面看一下限制条件代表的含义，通过高中数学，我们知道两个向量相乘（内积）的几何含义如下 ：（向量A在另一条向量B上的映射×向量B的模）
通过上面可知，我们要求||θ||的最小值，因此我们希望p(i)（x在θ上的映射）尽量大。只有这样才能使上面说的约束条件S.T满足。也就是SVM转变为了找到那个x在θ上的最大映射。
例子如下（θ为分界的法线（垂直））：
假如选择了下面图中的绿色线作为边界，我们会发现p(i)比较小，这样不能得出||θ||的最小值
如果选择下面的绿色线作为边界，我们可以得较长的映射p、和较小的||θ||值。
总结： SVM 要找到最中间的边界。所以要找到最长的映射p。进而可以找到所求参数θ的最小值。 二、核函数 1. 核函数原理和概念 在这里我们通过引入核函数来解决这个问题。
假设函数hθ(x)=θ0+θ1f1+θ2f2+θ3f3+⋯hθ(x)=θ0+θ1f1+θ2f2+θ3f3+⋯（用f代替x的参数）这个函数为新的假设函数。
引入：如果我们给出几个向量l(i)作为landmarks
这样就表示了样本x的一种高维映射，里标记点越近值越高。
最后，我们需要研究δ对核函数的影响，通过图片看出，δ越大收敛慢，δ越小收敛快。
2. SVM和核函数结合的计算步骤 上一节中的标记点，我们是随机选取的，但是这样不科学。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871446dae1fcac33bfeb4c5101107a5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd738eea1957379d844bd29ca18df07e/" rel="bookmark">
			How to design an online voting system
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 近些年微信上的网络投票系统比较多，那么如何设计一个在线的网络投票系统呢？今天，我们就给大家简要梳理一下。
安全性控制 由于因特网本身的开放性，使得网上投票面临种种危险，由此也引出了相应的安全控制性要求。
（1）信息保密性，投票者有保密的要求，如果用户名及投票内容被人知悉，就对用户的隐私权构成了侵害，因此网上投票系统中一般均有匿名投票的要求。
（2）投票者身份的有效性，在投票前，首先要确认投票者身份的合法性，这样才能保证统计结果的真实可靠。
（3）投票唯一性，一个投票者，其投票次数应当只一次，如果投票者可进行多次投票，这将对调查内容的可靠性构成严重的威胁。投票唯一性实质上也是投票者身份有效性。只有在确认身份有效的前提下，才能保证用户投票的唯一性。
基本功能 图 1.0 在线投票
技术实现 （1）基于短信验证码实现用户身份验证。
对于普通的在线投票系统，基于短信验证码实现用户身份校验基本上可以了，但是对于一些对用户身份要求非常严格的在线投票系统，还要对用户身份证或者用户人脸进行识别，进一步排除一个用户有多个手机号码的情况。
（2）基于Apache Echarts实现数据可视化展示。
Apache Echarts是百度在Apache上孵化的一个开源项目，支持多维度、多设备、动态展示数据。
参考文献
《开发者突击：JSP网络开发经典模块实现集》（程伟，汪孝宜编著；北京：电子工业出版社，2008.4，ISBN 978-7-121-04406-9） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316be202ec003624f9152b0c7d161e16/" rel="bookmark">
			Faiss安装，No module named ‘faiss‘/缺失 libomp.so
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先需要说明缺失libomp.so是因为没有装faiss库，因为faiss库就需要有libomp.so，因而问题变为如何正确安装faiss库。
方法一：直接使用pip安装faiss，但是会报错 pip install faiss 但是会提示错误，如下：
嗯，按照[2]的做法尝试了一下，发现还是不行。于是乎转用conda
或者可以直接尝试安装faiss-gpu，因为有时候是因为有cuda用的gpu版本的而不是cpu的因此会出现问题，使用命令：
pip install faiss-gpu 有时这样就可以解决问题了。不可以的话建议还是使用conda安装；
方法二：用conda安装 确定你要安装的版本：
CPU 版本，命令如下 conda install faiss-cpu -c pytorch GPU 版本，根据CUDA版本不同进行安装 conda install faiss-gpu cudatoolkit=8.0 -c pytorch # For CUDA8 conda install faiss-gpu cudatoolkit=9.0 -c pytorch # For CUDA9 conda install faiss-gpu cudatoolkit=10.0 -c pytorch # For CUDA10 参考：
[1].https://blog.csdn.net/mywmy/article/details/96993979
[2].https://blog.csdn.net/weixin_41864878/article/details/88683170
[3].https://www.jianshu.com/p/24b8cb642c83
[4].https://github.com/facebookresearch/faiss/issues/485#issuecomment-429528163
搞定，貌似有时候其对python版本也有限制，建议python=3.X，我的是python3.6的。
由于其一些依赖，如果出错尝试安装其依赖库，命令如下
conda install openblas swig 如果报错：ModuleNotFoundError: No module named ‘faiss.swigfaiss_gpu’
则需要安装：
conda install mkl 切记不要装混乱了，否则可能出现各种各样的问题，安装所需要的faiss版本即可；其他问题可查看[4]官网给出的一些相关说明；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e55b56f57db7c643f9a51d87ffa90f3/" rel="bookmark">
			CPNet：Context Prior for Scene Segmentation(CVPR 2020)代码复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码复现（ tf 版本进行中）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc20cd6aa50b745816f0fabf17696739/" rel="bookmark">
			机器视觉（二）——OpenCV配置出现异常: 0xC0000005: 读取位置 0x0000000000000008 时发生访问冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境：windows10 opencv4.1.2 virsual studio2019
问题描述：在Debug下调试运行正常，但是在Release模式下报错：0x00007FF8FFA61CE7 (opencv_world320d.dll)处(位于 myproject.exe 中)引发的异常: 0xC0000005: 读取位置 0x0000000000000008 时发生访问冲突。例如下图所示：
Release模式适合批量处理，速度是Debug模式下的N倍。
解决办法 删除vs2015中release模式附加依赖项中类似“opencv_xxxd.dlib”的项，因为名称带“d”是Debug模式下需要的，release下不能用。右键——解决方案——属性——配置设置成“活动（Release）”——连接器——输入——附加依赖库——选中后面方格里内容——删除带“d”的lib库和分号
在这里插入图片描述
原文链接：https://blog.csdn.net/sjx_5937681/article/details/104813658
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/772ae07c9544b5cf65e16eff05bf282a/" rel="bookmark">
			unity 使用rigidbody.addforce()跳跃的正确方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 逻辑：按下跳跃之后，现将y轴方向的速度设为0，然后再将addforce，这样在二段跳的时候不论在什么时机跳起来的高度都是一样的。
rigidbody.velocity = new Vector2(rigidbody.velocity.x, 0);//施加y方向速度，x方向维持原速 rigidbody.AddForce(new Vector2(rigidbody.velocity.x,200f )); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5cb7a56a0cd0ba790c4be52c6ae84c0/" rel="bookmark">
			【CSS3】rotate3d() 中的参数是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其它 3D 正方体演示：【CSS3】2D/3D 转换函数 文章目录 CSS3中的3D旋转函数rotate3d()什么是矢量（向量）？向量的坐标表示二维坐标系（平面直角坐标系）三维坐标系（空间直角坐标系）注意！Web坐标系与数学/物理学中坐标系的不同3D 正方体 Demo CSS3中的3D旋转函数rotate3d() 很多人跟我刚开始一样，搞不懂 rotate3d(x, y, z, angle) 中的 xyz 参数究竟是什么鬼意思，只知道，xyz代表矢量（向量）。
在 MDN 中是这样介绍的：
那么究竟个什么鬼是向量？
什么是矢量（向量）？ 物理学中称为 矢量；
数学中称为 向量；
矢量（向量）通俗的说，就是点到点之间的距离，而正负则表示方向的正反，无关大小。
而坐标点 O(0,0,0) 为坐标轴原点，即三轴相交的地方，也是起始点。
向量的坐标表示 下图中，点 P 是正方体原点的对角点，而原点到该点，即 【点O】到【点P】之间的距离，就是向量。
可这么理解： P(x,y,z) rotate3d(P, angle) 即，原点 O(0,0,0) 到点 P(x,y,z) 旋转 angle 度。 【线OP】 亦称正方体对角线。
那么想要正方体沿对角线 OP 旋转 45°，那就是 rotate3d(1,1,1,45deg);
为何？且看下节【平面坐标系】。
二维坐标系（平面直角坐标系） 由下图可看出，由 x=y 坐标点连成的线，就是正方形的对角线。(1,1)、(2,2)、(3,3)…(999,999) 均在一条线上。
三维坐标系（空间直角坐标系） 当换成 3D 坐标系，(1,1,1)、(2,2,2)、(3,3,3)…(999,999,999) 同样在一条线上，这条线，即为正方体的对角线。
那么，在 rotate3d() 中，既然只要求根据正方体对角线顺旋转 45°，无论是 rotate3d(1,1,1,45deg)，还是rotate3d(2,2,2,45deg)…rotate3d(999,999,999,45deg) 都可以实现相同效果，所以用 rotate3d(1,1,1,45deg) 即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5cb7a56a0cd0ba790c4be52c6ae84c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec0f93058d7a39ff7797acf6ddad977/" rel="bookmark">
			禅道 mysql 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方论坛上仅有的mysql相关错误的文章：https://www.zentao.net/ask/37291.html
他的解决办法是：
禅道-Bee 的解决办法：
先检查下磁盘空间，磁盘空间满的话，清理下，然后重启服务试试；
是不是有修改过一键安装包mysql的配置？如果是修改配置导致的，可以试试：
禅道迁移中问题的解决办法：
1.旧的zbox停止服务，重命名zbox为zbox_bak；安装相同版本的一键安装包，确认可以正常启动访问；停止服务后执行下面步骤迁移数据。
2. /opt/zbox_bak/app/zentao/www/data/upload/1 拷贝到 /opt/zbox/app/zentao/www/data/upload/1 【附件】
3. /opt/zbox_bak/data/mysql/zentao/ 整个文件夹拷贝到 /opt/zbox/data/mysql/zentao/ 下面 【数据库物理文件】
还是不行，可以联系官网顶部商务QQ，邀请加入禅道技术交流群，群里讨论下。
我从Windows版本切换的Linux版本，也碰到MySQL错误问题，描述如下：
我前面使用windows平台的禅道，现在需要把禅道重新部署linux，我把Windows禅道在页面上-&gt;后台-&gt;数据做的备份，
到linux还原总是把数据库清空掉，然后死掉。
最终发现导出的备份，sql.php文件包含PHP标记，需要改成sql同时去掉PHP标记，直接导入mysql就能用。
然后把www/data/upload/1下的文件复制完成即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab59a01320ccaf35e8d2971ed4b59aa5/" rel="bookmark">
			esp8266智能配网（Arduino）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考代码 #include &lt;ESP8266WiFi.h&gt; void setup() { Serial.begin(115200); //打开串口是为了调试 WiFi.mode(WIFI_STA); //注意需要设置为STA模式 } void loop() { WiFi.beginSmartConfig(); //开始智能配网 while(1)//等待配网 { Serial.print("."); delay(2000); if(WiFi.smartConfigDone()) { Serial.println("OK!"); break; } } WiFi.stopSmartConfig(); } 注意：一定要有延时函数，esp8266会自动检测是否有空跑的现象，如果存在会被复位。
手机端配网 微信配网
关注微信公众号 安信可科技
app配网
点我下载
更多参考 安信可开发文档参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72d426de165ce735b41e5cac5fe6057a/" rel="bookmark">
			c语言中switch用法举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例1：
如本文中描述的switch语法，switch是多个if else 的组合，其形式上与if的语法结构很像，if(表达式）{}
switch(表达式){ case 0: //表达式的各种取值+冒号，这跟我们平常列举各种情况的写法类似 case 1: //当表达式的多个取值的结果都一样的时，可以写在一起，在最后写break. case 3: cout &lt;&lt; "情形1"; break; case 2: cout &lt;&lt;"情形2"; break; case 4: cout &lt;&lt;"情形3"; break; default: break; } 例2：报错 main.cpp:23: error: crosses initialization of 'int nn'
原因分析：变量nn的的作用于是到switch的}结束，但是，倘若匹配了case2,就直接跳过了case1,此时nn是没有定义的，程序会崩。
改正： 将case1的情形用{}括起来，这样nn的作用域仅在case1的中，就可以避免跳到case2中调用nn的风险
int mm=2; switch(mm){ case 1: { int nn =22; qDebug()&lt;&lt;nn; break; } case 2: { qDebug()&lt;&lt;mm; break; } } 总结：switch语句中的各个case 可以使用{}分别进行括起来，这样不易出错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8709b6ebb97536b0b547bdd34af5b469/" rel="bookmark">
			交叉熵损失函数整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.交叉熵函数的由来(推导)1.1普通推导交叉熵 ：1.2极大似然推导交叉熵： 二.交叉熵函数直观理解三.交叉熵的两种不同形式3.1 Sigmoid + Cross-entropy3.2 SoftMax + Cross-entropy 四.交叉熵函数求导4.1 Sigmoid + Cross-entropy4.2 SoftMax + Cross-entropy 六.优缺点七.为什么逻辑回归不用MSE而用交叉熵 一.交叉熵函数的由来(推导) 1.1普通推导交叉熵 ： 我们一共有m组已知样本, ( x ( i ) , y ( i ) ) (x^{(i)},y^{(i)}) (x(i),y(i))表示第i组数据及其对应的类别标记,
其中 x ( i ) = ( 1 , x 1 i , x 2 i , x 3 i … x p i ) x^{(i)} = (1, x^{i}_1,x^{i}_2,x^{i}_3…x^{i}_p) x(i)=(1,x1i​,x2i​,x3i​…xpi​), y ( i ) y^{(i)} y(i)则为表示类别的一个数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8709b6ebb97536b0b547bdd34af5b469/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae422a2f3dbabe18c65caa00d18a871e/" rel="bookmark">
			信号（二）——进程间数据传递sigaction函数（sigaction结构体、siginfo_t 结构体）、sigqueue函数（sigval联合体）、信号的顺序响应问题——linux系统编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 sigaction信号安装函数sigaction 结构体siginfo_t 结构体 sigqueue信号发送函数sigval联合体 信号的顺序响应问题代码示例 上一篇讲到信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。Linux在支持新版本的信号安装函数sigation（）以及信号发送函数sigqueue()的同时，仍然支持早期的signal（）信号安装函数，支持信号发送函数kill()。kill+signal与sigqueue+sigaction的主要差别体现在后者可以带值发信号，这样就可以实现进程间是数据通信啦
sigqueue+sigaction sigaction信号安装函数 部分man：
NAME sigaction, rt_sigaction - examine and change a signal action SYNOPSIS #include &lt;signal.h&gt; int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); Feature Test Macro Requirements for glibc (see feature_test_macros(7)): sigaction(): _POSIX_C_SOURCE &gt;= 1 || _XOPEN_SOURCE || _POSIX_SOURCE siginfo_t: _POSIX_C_SOURCE &gt;= 199309L DESCRIPTION The sigaction() system call is used to change the action taken by a process on receipt of a specific signal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae422a2f3dbabe18c65caa00d18a871e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af61694ec1cd6ff03ce917650f29da73/" rel="bookmark">
			“running install error: can‘t create or remove files in install directory  The following error occu”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.问题描述：
当出现以下问题：
2.解决方案：
执行以下语句：
sudo python setup.py install 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced00971170e7e6067c67373b5117bfd/" rel="bookmark">
			Object的equals方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public boolean equals(Object obj):指示其他某个对象是否与此对象“相等”。
调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。
默认地址比较
如果没有覆盖重写equals方法，那么Object类中默认进行==运算符的对象地址比较，只要不是同一个对象，结果必然为false.
package Demo02; public class Demo02Equals { public static void main(String[] args) { /* Person类默认继承了Object类，所以可以使用Object类的equals方法 boolean equals(Object obj)指示其他某个对象是否与此对象"相等"。 equals方法源码： public boolean equals(){ return (this==obj); } 参数： Object obj可以传递任意的对象 ==比较运算符，返回的是一个布尔值 true false 基本数据类型：比较的是值 引用数据类型：比较的是两个对象的值 this是谁？那个对象调用的方法，方法中的this就是那个对象 p1调用的equals方法所以this就是p1 obj就是那个传递过来的参数p2 this==obj--&gt;p1==p2 */ Person p1=new Person("花环",20); Person p2=new Person("手链",21); boolean b = p1.equals(p2); System.out.println("p1地址"+p1);//p1地址Demo02.Person@1540e19d System.out.println("p2地址"+p2);//p2地址Demo02.Person@677327b6 System.out.println(b); System.out.println("-----------"); //把p2地址赋值给p1就能保证true了 p1=p2; System.out.println(p1.equals(p2)); } } 重写equals方法
package Demo02; import java.util.Objects; public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ced00971170e7e6067c67373b5117bfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da53ea74dfcea31c9e5781af1fdf2f1e/" rel="bookmark">
			zookeeper学习笔记之-Zookeeper中的Watch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		watcher 机制主要提供了服务通知功能
Watche的分类 客户端三类，服务端两类
dataWatches：表示监听的是某节点的数据变化，比如数据的新增、修改、删除childWathes：表示监听的是某节点的孩子节点的变化，如果某个节点新增或删除了，会触发其父节点上的NodeChildrenChanged事件existWatches（只在客户端）：服务端无需单独触发该事件，由客户端接收其他事件自己判断，比如客户端接收到一个NodeCreated事件，客户端如果注册了existWatches，那么existWatches就会被触发。 不同的Watcher事件类型会触发哪些Watche None defaultWatcher所有dataWatches（触发完可能清空）所有existWatches（触发完可能清空）所有childWatches（触发完可能清空）所有的persistentWatches所有的persistentRecursiveWatches NodeDataChangedNodeCreated 对应path的dataWatches（立马移除，先移除再执行）对应path的existWatches（立马移除，先移除再执行，如果绑定了existWatche，当节点被新增或修改时触发）对应path的persistentWatches对应path的每层父path对应的persistentRecursiveWatches（这里有点难理解，persistentRecursiveWatches中存储的就是Watcher,这里根据当前WatchedEvent对应的path，找到该path的各层父path，然后再遍历各层父path，根据父path去从persistentRecursiveWatches集合中找当前父path是不是有对应的Watcher，如果有就添加到result中去，等待执行，这就是递归，一个子节点的数据发生了变化，父节点上的Watcher也能被触发） NodeChildrenChanged 对应path的childWatches（立马移除，先移除再执行）对应path的persistentWatches对应path的每层父path对应的persistentRecursiveWatches NodeDeleted 对应path的dataWatches（立马移除，先移除再执行）对应path的existWatches（立马移除，先移除再执行，如果绑定了existWatche，当节点被删除时触发）对应path的childWatches（立马移除，先移除再执行）对应path的persistentWatches对应path的每层父path对应的persistentRecursiveWatches 不同的操作触发的Watcher事件类型 创建节点 触发当前节点的NodeCreated事件触发当前节点的父节点的NodeChildrenChanged事件 删除节点 触发当前节点的NodeDeleted事件触发当前节点的父节点的NodeChildrenChanged事件 修改节点 触发当前节点的NodeDataChanged事件 注意NodeChildrenChanged事件不会触发persistentRecursiveWatches
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f05f09a075f35d3fdfadf7ec5d40d2/" rel="bookmark">
			常用命令设置时区日期时间-date
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时区日期时间 Linux 中有两种时间，一个是系统时间(软件时间)，使用date 查看；另一个是硬件时间，就是主板的时间，使用clock查看
1 date 显示和设置系统时间
显示日期时间的命令格式：date [OPTION]… [+FORMAT]
FORMAT 格式说明 %F：日期，显示为数字，格式为 2020-07-03 %D：英制格式，月日年，格式为 03/07/20 %T：时间，显示为数字，格式为 15:54:16 %Y：年份，显示为完整年份数字，格式为 2020 %m：月份，显示为数字，格式为 07 %d：日期，显示为数字，格式为 03 %H：时分，显示为数字，格式为 (00..23):15 %k：小时，24小时制，格式为 00..23 %i：小时，12小时制，格式为 01..12 %I：小时，12小时制，格式为 1..12 %M：分钟，显示为数字，格式 52 %S：秒钟，显示为数字，格式 16 %y：年份，显示年份后两位数字，格式为 20 %h：月份，格式为 3月 %a：缩写星期 %A：完整星期 %b：缩写月份 %B：完整月份 %r：格式为 10:35:03 AM %R：等同于%H%M ，格式为 22:09 %s：从1970年1月1日至此时所经历的秒数，timestamp格式：1595732382 设置时间的格式：date [MMDDhhmm[[CC]YY]][.SS]
其中 MM-月份，DD-日期，hh-小时，mm-分钟，CC-年份的前两个数字，YY-年份的后两个数字，.ss-秒钟(点号不可省略)
范例：
#显示当前日期(默认格式) [root@centos8 ~]#date Sun Jul 26 11:05:45 CST 2020 #以yyyy-MM-dd 的格式显示当前日期 [root@centos8 ~]#date +%F 2020-07-26 #以yyyy-MM-dd hh:mm:ss 的格式显示当前日期 [root@centos8 ~]#date "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f05f09a075f35d3fdfadf7ec5d40d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/098dd379bf09a9638d3f3f9ab2ea00bc/" rel="bookmark">
			分布式锁Redisson的使用，看门狗机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式锁Redisson的使用，看门狗机制 Redisson简介Redisson使用项目使用以及说明 Redisson简介 Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。
Redisson使用 1.引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.12.0&lt;/version&gt; &lt;/dependency&gt; 2.编写配置类，初始化一个RedissonClient对象
import org.redisson.Redisson; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.io.IOException; /** * @ClassName MyRedissonConfig.java * @Author 拾光 * @Date 2020年07月25日 18:14:00 * @Description redisson配置类 */ @Configuration public class MyRedissonConfig { /** * 所有对redisson的使用都是通过RedissonClient来使用 * @return * @throws IOException */ @Bean(destroyMethod="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/098dd379bf09a9638d3f3f9ab2ea00bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e4161c0dd39dd7ed9a524ba9484717/" rel="bookmark">
			百度之星第二场（前四道签到题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你需要查看题目，
请点击下方↓
百度之星第二场题目
因为是水题嘛，所以就不多赘述了。
官方题解也早就出了，如果想看更为标准的解析
请移步下方↓
http://bestcoder.hdu.edu.cn/
Poker 这题其实很好想，我的思路是先把每次需要交的费用m先取出来，然后在用剩下的钱除以实际消耗的，就能得到次数y，最后因为事先取出m块钱，所以再从y次的基础上增加一次，就是最后的答案了。其中要注意的坑就是如果拥有的钱不足以支付一次的消耗，就需要特判 （用人话将就是一次也玩不起，就不要玩了，穷鬼不配玩游戏） ，也就是n&lt;m时的情况。
下面是AC代码：
#include&lt;bits/stdc++.h&gt; using namespace std; double a=2.0; int main() { int t,x,y; double ans,n,m,p,sum=0; scanf("%d",&amp;t); while(t--) { scanf("%lf%lf%lf",&amp;n,&amp;m,&amp;p); if(n&lt;m) { printf("0\n"); continue; } sum=n-m; y=sum; ans=m*p/100; x=ans; if(ans&gt;x) x++; y/=x; y++; printf("%d\n",y); } return 0; } Distance 我记得19年百度之星好像也出过一次类似的题目，（当时太菜没做出来QAQ，今天！一雪前耻！！！）
我的思路是这样的：
假设有 1 2 3 4 5 5个数在数轴上，从1开始向着更大的数前进（请自行脑补滑动变阻器），那么会有1→2、1→3、1→4、1→5 四种路线，而所有的路线都必须经过1和2之间的距离也就是4×(2-1)=4
然后从第2点开始，会有2→3、2→4、2→5三条线，这三条线都会经过2和3之间的距离，也就是3×(3-2)=3，但是从1开始走的1→3、1→4、1→5，也会经过这段距离，即又是3×(3-2)=3，然后我们将他们合并同类项，变成了(1/2)→3、(1/2)→4、(1/2)→5，就是 2×3×(3-2)
不难看出，就是选择某点x，那么能够路过x与x+1点之间路径的道路，就是x及其之前的点的数与x之后点的数的积，用人话讲就是：“把一堆点分成两部分，x及其之前，x之后，然后把它们的个数相乘，最后再乘上x与x+1的距离”
然后每个点都这么求一下，最后计算总和，就解出来啦 \ (^ o ^) / ~
下面是AC代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e4161c0dd39dd7ed9a524ba9484717/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8df6683385615be0e21aa8dd8c70c671/" rel="bookmark">
			使用Mybatis的好处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 解决： 在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。 2.Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大， sql 变动需要改变 java 代码。 解决： 将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。 3. 向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数对应。 解决： Mybatis 自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的 类型。 4. 对结果集解析麻烦， sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对 象解析比较方便。 解决： Mybatis 自动将 sql 执行结果映射至 java 对象，通过 statement 中的 resultType 定义输出结果的 类型。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e50e9a7535574d8898e998c79a7991c8/" rel="bookmark">
			Ubuntu18.04上传文件夹到github
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1登入github并新建一个repository 比较简单 2在ubuntu上安装git sudo apt-get install git 3本地创建 SSH Keys GitHub支持多种加密算法，选取rsa，代码如下，后面引号里改成自己的邮箱地址，创建好的加密文件在~/.ssh文件夹下。
会要求确认路径和输入密码，我们使用默认的一路回车就行，最好不要修改保存的文件名和文件夹，不然ssh连不通，踩坑忠告。成功的话会在～/下生成.ssh文件夹，按住ctrl+h可以显示隐藏文件夹，点进去，打开id_rsa.pub，复制里面的key。
ssh-keygen -t rsa -C "1540297462@qq.com" 运行结果： xj@xj-ThinkPad-T590:~/github_my$ ssh-keygen -t rsa -C "1540297462@qq.com" Generating public/private rsa key pair. Enter file in which to save the key (/home/xj/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/xj/.ssh/id_rsa. Your public key has been saved in /home/xj/.ssh/id_rsa.pub. The key fingerprint is: SHA256:mmMLlopKl8x8WwxIDiwAPsFq+qLH6QnhWSqHc7ZrJFQ 1519675115@qq.com The key's randomart image is: +---[RSA 2048]----+ |=.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e50e9a7535574d8898e998c79a7991c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04276ced2e0208fc6370d53d71ce001/" rel="bookmark">
			Python 的 libpng warning: iCCP: cHRM chunk does not match sRGB 报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		libpng warning: iCCP: cHRM chunk does not match sRGB 报错处理 前言处理方法更新 前言 用python3.6.6 写了一段很简单的图像卷积处理代码，然后很奇怪的，出现一段报错：
libpng warning: iCCP: cHRM chunk does not match sRGB
卷积代码如下：
import matplotlib.pyplot as plt import pylab import cv2 import numpy as np img = plt.imread("Test.jpg",0) #在这里读取图片 # img = plt.imread("Test2.jpg",0) #在这里读取图片 # plt.imshow(img) #显示读取的图片 # pylab.show() fil = np.array([[ -1,-1, -1], #这个是设置的滤波，也就是卷积核 [ -1, 0, 1], [ 1, 1, 1]]) res = cv2.filter2D(img,-1,fil) #使用opencv的卷积函数 plt.imshow(res) #显示卷积后的图片 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d04276ced2e0208fc6370d53d71ce001/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a8d1b8f2a8656e481d7186c710123c6/" rel="bookmark">
			zookeeper学习笔记之-Zookeeper 3.6源码编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用git拉取项目切分支：release-3.6.1利用maven下载依赖直接运行QuorumPeerMain类，编译过程会报错，比如找不到如下包 这些包需要jute生成，进入到zookeeper-jute模块，编译一下：编译后会生成对应的包，再次运行QuorumPeerMain类，还是报错，找不到Info接口，这个接口也需要生成，进入到zookeeper-server模块，编译一下：编译后会生成Info接口，再次运行QuorumPeerMain类，没有报错了，只不过没有启动成功：这是因为没有指定配置文件，指定一下：再次运行QuorumPeerMain类，没有报错了：这时其实已经成功了，可以使用zkCli.sh/或zkCli.cmd连接成功：只不过服务端日志太少，这是因为resource没有加到classpath中，log4j.properties没有起到作用：右键添加即可： 再次运行QuorumPeerMain类，一切正常，日志也多了。源码构建完成 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6ed1bdd3c6238ad332e9af8fd40bea4/" rel="bookmark">
			SpringMVC的执行流程（笔记总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SpringMVC的执行流程图 组件说明 DispatcherServlet： 整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 HandlerMapping： 根据请求的url查找Handler。HandlerMapping负责根据用户请求找到Handler即处理器（Controller），SpringMVC提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 ViewResolver： 进行视图解析，根据逻辑视图名解析成真正的视图，ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 Model： 返回的数据对象。 View： 实现类支持不同的View类型（jsp、freemarker、pdf...）。 SpringMVC工作流程 1、用户发送http请求到web服务器，web服务器解析http请求，匹配到DispatcherServlet的请求映射路径（在web.xml文件中配置），web容器将请求转交给DispatcherServlet。 2、中央调度器DispatcherServlet接收到请求后，会根据http请求以及HandlerMapping中的配置找到处理请求的处理器Handler。 3、HandlerMapping 找到对应的 Handler 之后，并不是返回一个 Handler 原始对象，而是一个 Handler 执行链（HandlerExecutionChain），在这个执行链中包括了拦截器和处理请求的 Handler。HandlerMapping 返回一个执行链给 DispatcherServlet。 4、DispatcherServlet 接收到执行链之后，会调用 Handler 适配器去执行 Handler。 5、HandlerAdapter执行完成 Handler之后会得到一个 ModelAndView，并返回DispatcherServlet。 6、DispatcherServlet 接收到 HandlerAdapter 返回的 ModelAndView 之后，会根据其中的视图名调用 ViewResolver。 7、ViewResolver 根据逻辑视图名解析成一个真正的 View 视图，并返回给 DispatcherServlet。 8、DispatcherServlet 接收到视图之后，会根据上面的 ModelAndView 中的 model 来进行视图中数据的填充，也就是所谓的视图渲染。 9、渲染完成之后，DispatcherServlet 就可以将结果返回给用户了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/523d301eabe1c96f6f477cbfd72b5294/" rel="bookmark">
			Action Segmentation with Joint Self-Supervised Temporal Domain Adaptation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：该文章发表于CVPR2020，文章主体框架建立在2019年“MS-TCN: Multi-Stage Temporal Convolutional Network for Action Segmentation”的基础上，欢迎查阅：MS-TCN介绍
论文原题：Action Segmentation with Joint Self-Supervised Temporal Domain Adaptation
原文地址：https://arxiv.org/abs/2003.02824
论文的目标为“行为分割”（Action Segmentation），由于文章的主体网络结构建立在MS-TCN的基础之上，这里我只对本文的Contribution进行介绍。
论文的Motivation是通过使用自监督学习（Self-supervised learning）来解决训练样本及测试样本之间可能存在的Domain variation问题（例如，不同的个体，在执行相同的action时可能有不同的习惯，若在训练集(source)及测试集(target)之间存在较大的差异，则会给模型精度带来很大的影响）。所谓自监督学习，就是通过使用无需标记的样本，建立某些辅助任务（auxiliary tasks），来学得更好的特征表示，从而为目标任务带来帮助，那么现在问题就是如何设计一个好的auxiliary task，来帮助我们解决Domain variation 问题。
机器学习领域一个专门解决此类问题的方向为领域自适应（Domain Adaption, DA），属于迁移学习的一个分支。作者使用了对抗学习（adversarial learning）的方式（类似于GANs），试图通过无标记视频序列，学得Domain invariant feature，从而使得Domain variation问题得到解决。为此，作者设计了两个self-supervised auxiliary tasks, 分别用于逐帧（frame-wise）特征提取以及对时间序列片段的特征提取（sequence-wise），接下来分别对这两部分进行介绍。
1. Local SSTDA (Frame-wise) 上图的左侧部分为Local SSTDA，用于逐帧（frame-wise）特征提取的自监督学习，为了解决domain variation问题（也就是减缓source（训练数据）及target（测试数据）之间特征表示的差异性），如上文所述，这里使用类似于GANs中的对抗学习。设计一个判别器Discriminator G l d G_{ld} Gld​，用于判断我们的输入数据是源自于source还是target（二分类问题），而我们的特征提取网络则希望学得domain-invariant的特征，从而欺骗判别器Discriminator。在两者的交替更新之下，最达到纳什均衡。
2. Global SSTDA Global SSTDA与上文所述的Local SSTDA类似，区别在于其用于提取对连续时间序列片段进行特征提取（sequence-wise），作者首先分别原始的source及target中的的完整video截成一系列片段，对每个截出的片段，使用**DATP（Domain Attentive Temporal Pooling）**进行特征提取，获得每个clip的特征向量，随后将这些源自source及target的片段进行随机打乱（shuffle）及拼接，输入后续的Discriminator进行类别预测（from source or target）。该部分的损失函数类似于Local SSTDA。
总损失函数loss function如下所示
SSTDA的自监督学习部分总体框下如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48a5bc85871b306d7bd040deb665d3f/" rel="bookmark">
			java项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决maven无法创建servlet的问题
https://blog.csdn.net/My_name_is_ZwZ/article/details/82930143?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
tomcat安装及idea配置
https://www.jianshu.com/p/2d4f51727035
Cause: java.sql.SQLException: Unknown initial character set index '255' received from server. https://blog.csdn.net/Ahuuua/article/details/89071738?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6496f58fcf372467a077421a40130848/" rel="bookmark">
			小项目中怎么防止Vue的闪现画面效果？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一句话总结
HTML: 元素加上v-cloak
CSS: [v-cloak]{display: none} 过程
页面刚加载的时候胡子语法会显示出来。
v-cloak是VueJS小型项目中提升用户体验简单且重要的方法。
用法
HTML中在你需要组织闪现的标签上加上v-cloak
1
2
3
4
&lt;div id="app"&gt; &lt;nav&gt;blabla&lt;/nav&gt; &lt;main v-cloak&gt;{{text}}&lt;/main&gt; &lt;/div&gt; CSS中给v-cloak设定样式，这个样式是只有【在vue实例编译结束前】应用的样式。
1
2
3
[v-cloak]{ display: none; } 原理
我没读完源码，但是v-cloak的原理我大概理解一点：
首先是CSS选择器，用[target]选择的是“带有 target 属性所有元素。”。可以点这里复习选择器。
那么[v-cloak]选择出来的就是所有带有v-cloak属性的元素了。
实例初始化完成之后，VueJS中会把Vue中特有的attribute去掉。在实例初始化完成之前，上面写的main的HTML代码实际是这样的：
1
然后加上CSS，就把所有带有v-cloak的元素都display: block了。 其实不止是v-cloak，你可以用v-if来试试，CSS里使用[v-if]{display:none}，效果看起来是一样的。和v-cloak一样，v-if也是在实例编译完之后去掉。
源码
然后我刚才去读了一下源码，大概是这一段，感兴趣的大佬可以去搜搜读读理解理解。
1
2
3
4
5
6
7
8
9
if (isRealElement) { // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6496f58fcf372467a077421a40130848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f0abd60914cd7ee93d5d5bf80980b7/" rel="bookmark">
			MS-TCN: Multi-Stage Temporal Convolutional Network for Action Segmentation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文题目：Multi-Stage Temporal Convolutional Network for Action Segmentation
原文地址：https://arxiv.org/abs/1903.01945
这篇文章涉及的是视频的行为分割问题（Action Segmentation），也就是对视频（video）中的每帧，推断其对应的行为类别，也就是说，该问题本质上是一个逐帧的图像分类问题。
该文章的主要核心内容如下：
1.使用TCN对时序邻域信息进行聚合 由于人的行为具有时间相关性，为了捕获行为的dynamics，在涉及视频序列处理的问题中，有必要对时序信息进行聚合。该论文使用时间卷积神经网络（Temporal Convolutional Networks, TCN）来进行时序信息的聚合。
TCN的输入不是原始的图像，而是按照时序进行排列的特征，为了扩大感受野，作者选择使用空洞卷积（dilated convolution），后接1x1卷积进行通道数量的调整。作者同样使用的残差连接（residual connection）来对梯度的反向传播进行优化。该残差结构可以公式化的表示为：
随后，我们对残差块进行堆叠，以提取更高层的特征，为了获得更大的感受野（receptive field），下一层的空洞卷积的dilation rate增加为原来的2倍，因此，随着层数的增加，网络的感受野呈指数增加。
最后，如同其他的分类任务，网络经过全连接层后，输入后续的softmax层中，得到逐帧的分类结果（frame-wise classification）
2.使用multi-state TCN对分类结果进行更好的调整 在第一部分提到的TCN已经实现了对视频的frame-wise classification，为了进一步改进分类效果，作者使用多层TCN进行堆叠，以对分类结果进行进一步微调。
3.在Loss function中加入平滑项，减缓过分类（over-classification）问题 常规的分类问题可以直接使用交叉熵（Cross-Entropy）损失
然而，在动作分类问题中，由于人的行为一般具有连贯性，直接使用Cross-Entropy
可能引起过分类（over-classification），造成行人行为的分类结果在时间轴上“不连贯”，因此，作者引入额外损失项对分类结果进行平滑
直观上来看，若当前帧与上一帧的行为分类结果的差异性越大，该loss项会基于网络更大的惩罚，从而一定程度上避免行为的分类结果在时间轴上出现剧烈的突变，提高分类结果的连贯性。
最终的损失函数为不同时刻对应的分类loss的求和。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e8cc95d0a1601d7a9055cad65a35ac9/" rel="bookmark">
			E2512 功能测试宏的参数必须是简单标识符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到报错的文件：
将这段代码修改该为：
#if defined(__cplusplus)
#if defined(__clang__)
#if QT_HAS_CPP_ATTRIBUTE(clang::fallthrough)
# define Q_FALLTHROUGH() [[clang::fallthrough]]
#endif
#elif defined(__GNUC__)
#if QT_HAS_CPP_ATTRIBUTE(gnu::fallthrough)
# define Q_FALLTHROUGH() [[gnu::fallthrough]]
#endif
#elif QT_HAS_CPP_ATTRIBUTE(fallthrough)
# define Q_FALLTHROUGH() [[fallthrough]]
#endif
#endif
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e6454811ba5ae691d6148554e13696a/" rel="bookmark">
			【微信公众号H5】H5  使用 jssdk 出现的问题 错误码:63002 invalid signature （安卓注册config正常 则ios注册config 签名错误问题 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.微信开发者，jssdk报config:fail,Error: 系统错误,错误码:63002,invalid signature 1.检查URL跟服务端接收到的URL 是否正确 URL Http用post方式 保证后端拿到的url是完整的 2.服务端 检验签名是否正确 哪怕是测试检测签名正确 也要让服务端从头检查 重点要前端注册的时候不出错
3.非常重要的是 一定要检查后端的jsapi_ticket 是否正确
出现错误的情况有如下：
3.1.出现反复请求jsapi_ticket 导致过期不是最新 应缓存jsapi_ticket 及 token
3.2.后端获取 jsapi_ticket 请求的路径出错
注释：正确的是https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi 4.注意参数type是否正确 微信官方有两个type
4.1.JS-SDK使用权限签名算法 type = jsapi
4.2.卡券扩展字段及签名生成算法 type = wx_card
微信文档
2.系统错误,错误码:40048 1.如果是开发者工具的话 直接换成手机测试
2.检查appid是否是对应公众号的appid 往往出错的不是不会 而且在于疏忽 过于自信导致
3.解决安卓注册config正常 则ios注册config 签名错误问题 原因是ios 无论路由跳转多少次，复制出来的链接都是首次进入的页面的链接 所以重点来了
Vue.prototype.href = window.location.href
记录第一次 进入的链接 在注册的时候 判断是否是ios 进行相对于的修改
let url = location.href.split('#')[0] let isIOS = function () { var isIphone = navigator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e6454811ba5ae691d6148554e13696a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd227740c59430766938aa6cfcccd38/" rel="bookmark">
			Vue &#43; iview &#43; quill （vue-quill-editor）富文本编辑器及插入自定义图片，样式调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述: 最近公司又这么一个需求，在form表单中对这个富文本编辑器列有必填的长度校验，然而在项目中img会转成base64格式的导致检验失败，因此需要我们自定义图片功能来解决这个问题。
1.安装
npm install vue-quill-editor --save npm install quill –save 2.在所需页面进行按需引入
创建文件组件 components/quill.vue
部分代码如下：
&lt;template&gt; &lt;div class="form-quill"&gt; &lt;div class="i-quill" :class="classes" v-show="!disabled"&gt; &lt;div ref="editor" :style="styles"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div v-show="disabled" v-html="value"&gt;&lt;/div&gt; &lt;Upload class="form-quill-upload" ref="uploadFileBtn" :action="uploadUrl" :format="format" :disabled="disabled" :maxSize="maxSize" :on-success="succUpload" :on-error="errorUpload" :show-upload-list="false" :before-upload="handleUpload" :on-format-error="formatError" :on-exceeded-size="exceededSize" &gt; &lt;Button type="primary" id="file" ref="uploadImgBtn"&gt;上传图片&lt;/Button&gt; &lt;/Upload&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Quill from "quill"; import "quill/dist/quill.core.css"; import "quill/dist/quill.snow.css"; import "quill/dist/quill.bubble.css"; &lt;/script&gt; 效果图如下： （默认编辑器有很多icon ，各取所需）
配置项：放在data中
options: { theme: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bd227740c59430766938aa6cfcccd38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a72b6caedf976f0f576a2a8551abd20/" rel="bookmark">
			B&#43;tree 是如何降低IO的?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先数据查询是经过两步的:
第一:将索引页加载到缓存中,然后从缓存中找到数据页;
第二:将数据页数据加载到缓存,然后将数据返回出去.
首先是索引降低了IO次数,为什么这么说?
原因:按B树和B+树来说, B+树的索引页中全部是都是索引,这样一个数据页中能查询到很多索引降低了下一次去磁盘再拿索引页的可能性, 这样就降低了磁盘的IO了.
第二: B树在非叶子节点存储数据了,这样我一个索引页上上有数据有索引,肯定效率低了. 这个B树就是一个多叉树而已了,
以上就是B+ 树的索引[我之前的理解盲区: 叶子节点中数据就是索引这是一个什么形式? 其实就是在非叶子节点存储索引页的开始,然后指针指向索引页即可. 叶子节点就是数据页中存储了该索引的最小值和最大值] 还有为什么二叉树,红黑树不可以呢?
第一: 数据量大,树的深度就变大,查询效率是log2(n), 儿多叉树的效率是是按这个分叉大小来分的, 肯定比这个要很多.
第二:叶子节点,数据没有按照指针的顺序来排序,这样范围查找困难.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db759adc513a6f25474aab996e0a1e8e/" rel="bookmark">
			css3缩放字体后模糊的两种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：改变元素的宽和高，只有是偶数的时候才不会模糊
width: 200px; height: 200px;
第二种：如果元素是auto或者未定义宽和高的
transform:perspective(1px) scale(0.8);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3395336727e64956f854fcc12a872372/" rel="bookmark">
			js逆向-ast混淆还原进阶二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标网站：aHR0cHM6Ly90YW9kYXhpYW5nLmNvbS9jcmVkaXQy （使用base64解码）
你一进去就能看到混淆的内容。
你一些常用的还原方法用在这里，可能也许就报错了，乘此机会可以修改你的代码，让它更兼容更通用。
这个混淆里面有无限debugger，禁止控制台输出，内存爆破等等某些常用的手段
自行试试吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b43595b798fa0d1882635ac394f00d5/" rel="bookmark">
			论文阅读笔记（1）——Recurrent Convolutional Neural Networks for Text Classification（用于文本分类的循环卷积神经网络）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要（Abstract）介绍（Introduction）相关工作（Related Work）文本分类（Text Classification）深度神经网络（Deep neural networks） 模型（Model）词表示学习（Word Representation Learning）文本表示学习（Text Representation Learning） 训练（Training）训练网络参数（Training Network parameters） 预训练词嵌入（Pre-training Word Embedding）实验（Experiments）数据集（Datasets）实验设置（Experiment Settings）方法比较（Comparison of Methods）Bag of Words/Bigrams + LR/SVMAverage Embedding + LRLDATree KernelsRecursiveNNCNN 结果与讨论（Results and Discussion）上下文信息（Contextual Information）学习关键字（Learned Keywords） 结论（Conclusion） 摘要（Abstract） 传统文本分类器通常依赖于许多人为设计的特性，如字典、知识库和特殊的树核。与传统方法相比，引入了一种循环卷积神经网络来进行文本分类，而不需要人为设计特征。在我们的模型中，在学习单词表示时，我们使用循环结构来尽可能捕获上下文信息，与传统的基于窗口的神经网络相比，这样可以引入较少的噪声。还使用了一个最大池层，自动判断哪些词在文本分类中扮演关键角色，以捕获文本中的关键组件。在四个常用数据集上进行实验，结果表明该方法在多个数据集，特别是文档级数据集上的性能优于现有方法。
介绍（Introduction） 特征表示：通常是基于词包的(BoW)模型，其中unigrams（一元语法）, bigrams（二元语法）, n-grams或一些精美设计的图案通常提取为特征。
N-grams：第N个词的出现只与前面N-1个词相关，而与其它任何词都不相关，整句的概率就是各个词出现概率的乘积。这些概率可以通过直接从语料中统计N个词同时出现的次数得到。
N-gram模型是一种语言模型（Language Model，LM），语言模型是一个基于概率的判别模型，它的输入是一句话（单词的顺序序列），输出是这句话的概率，即这些单词的联合概率（joint probability）。N-gram本身也指一个由N个单词组成的集合，各单词具有先后顺序，且不要求单词之间互不相同。
虽然高阶n-gram和更复杂的特征(如树核(Post和Bergsma 2013))用来捕捉更多的上下文信息和词序，但它们仍然存在数据稀疏性问题，严重影响分类精度。
单词嵌入是单词的分布式表示，极大地缓解了数据稀疏性问题。预先训练的单词嵌入可以捕获有意义的语法和语义规律。在单词嵌入的帮助下，提出了一些基于组合的方法来捕获文本的语义表示。
递归神经网络Recursive Neural Network(RecursiveNN)
优点：已被证明在构建句子表示方面是有效的。
缺点：
递归通过树结构捕获句子的语义。性能在很大程度上取决于文本树结构的性能。构建这样的文本树的时间复杂度至少为O(n2)，其中n为文本的长度。当模型遇到一个长句子或一个文档时，将非常耗时。并且两个句子之间的关系很难用树形结构来表示。因此，递归不适合建模长句子或文档。 循环神经网络Recurrent Neural Network(RecurrentNN)
优点：
时间复杂度O(n)。该模型对一个文本进行逐字分析，并将之前所有文本的语义存储在一个固定大小的隐藏层中。能更好地捕捉上下文信息。这可能有利于捕获长文本的语义。 缺点：
RecurrentNN是一个有偏差的模型，表现为后面的词比前面的词更占优势。因此，当它用于捕获整个文档的语义时，可能会降低效率，因为关键组件可能出现在文档的任何位置，而不是在文档的末尾。 卷积神经网络Convolutional Neural Network (CNN)
优点：
是一个无偏差模型。它可以通过最大池化层公平地确定文本中的有差别的的短语。与递归或循环神经网络相比，CNN可以更好地捕捉文本的语义。CNN的时间复杂度也是O(n)。 缺点：
以往对CNN的研究倾向于使用固定窗口等简单的卷积内核。在使用这样的内核时，很难确定窗口大小:较小的窗口大小可能会导致丢失一些关键信息，而较大的窗口会导致巨大的参数空间(可能很难训练)。 为解决上述模型的局限性，提出循环卷积神经网络Recurrent Convolutional Neural Network(RCNN)，并将其应用到文本分类的任务中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b43595b798fa0d1882635ac394f00d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67f9adcbd7d010a0c5496da524ce8b8a/" rel="bookmark">
			找出数组中那个第一次重复的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。（来源： 牛客网.）
先排序，在找重复的 手写排序，较为麻烦
public class Solution { public boolean duplicate(int numbers[],int length,int [] duplication) { //使用冒泡排序进行排序 for(int i=0 ;i&lt;length-1;i++){ for(int j=0;j&lt;length-1-i;j++){ if(numbers[j]&gt;numbers[j+1]){ int temp = numbers[j]; numbers[j] = numbers[j+1]; numbers[j+1]=temp; } } } //从已经升序的序列中找到重复值 for(int k=0;k&lt;length-1;k++){ if(numbers[k]==numbers[k+1]){ duplication[0]=numbers[k]; return true; } } return false; } } 利用Arrays工具类进行排序
链接：https://www.nowcoder.com/questionTerminal/623a5ac0ea5b4e5f95552655361ae0a8?answerType=1&amp;f=discussion 来源：牛客网 import java.util.*; public class Solution { public boolean duplicate(int numbers[],int length,int [] duplication) { if(numbers == null || length == 0){ return false; } Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67f9adcbd7d010a0c5496da524ce8b8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37a4a4d885c75fd623c68829c839af4/" rel="bookmark">
			根据官方文档分析Kotlin协程的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		协程的作用 我们先来看看kotlin 官方中文的详细文档
官方描述：协程通过将复杂性放入库来简化异步编程。程序的逻辑可以在协程中顺序地表达，而底层库会为我们解决其异步性。该库可以将用户代码的相关部分包装为回调、订阅相关事件、在不同线程（甚至不同机器）上调度执行，而代码则保持如同顺序执行一样简单。
协程最大的作用就是切换线程。Rxjava也可以线程切换，所以协程与Rxjava切换线程类似的，Rxjava切换是线程，而Kotlin的协程与Rxjava是不同的，协程和线程又有不同的，一个协程是一块块，每一块都有一个上下文Context，通过上下文做桥接来切换。
比如：有A线程和B线程，有三个代码块C1、C2、C3，这些代码块在执行时，在那个线程（A线程或B线程）上切换呢，那么就由协程去控制了，如A线程执行C1、C2代码块，B线程执行C3代码块。执行的单元以协程上下文Context，这么一块一块为单位来切换的。
可以简单地理解为，协程封装好一块块的代码在线程上执行，如封装好的一块块执行单元C1、C2在A线程上，如果要切换到B线程上，那么C1或C2的结果就以条件参数方式传入到C3中在B线程上执行。
协程的使用 1、添加依赖
//协程相关的核心库
implementation ‘org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.2’
implementation ‘org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.2’
2、创建协程
在 kotlin 里面提供了大量的高阶函数，kotlin 中 GlobalScope 类提供了几个携程构造函数。
runBlocking - 不是 GlobalScope 的 API，可以独立使用，区别是 runBlocking 里面的 delay 会阻塞线程，而 launch 创建的不会。
launch- 创建协程。
async - 创建带返回值的协程，返回的是 Deferred 类。
withContext - 不创建新的协程，在指定协程上运行代码块。
kotlin 在 1.3 之后要求协程必须由 CoroutineScope 创建，CoroutineScope 不阻塞当前线程，在后台创建一个新协程，也可以指定协程调度器。
3、runBlocking:T
class MainActivity : AppCompatActivity(){
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main)
tv_name.text = “learning kotlin”
Log.e("lu","主线程——${Thread.currentThread().name}_id_${Thread.currentThread().id}") test() Log.e("lu","协程执行结束。") }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d37a4a4d885c75fd623c68829c839af4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b48836400a727ee4fc2fd880729905cc/" rel="bookmark">
			使用CCS 安装 C2000ware 并创建示例项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CCS安装C2000WARE （一）下载C2000Ware_3_02_00_00_setup.exe 链接：https://pan.baidu.com/s/1BCzuNzCN_QBmvzJ1vDqISg
提取码：sh5m
（二）加载C2000Ware到CCS 1．安装C2000Ware_3_02_00_00_setup.exe
2．打开Resource Explorer
3．点击ALL右侧的添加
4．点击ADD，选择C2000文件夹
5．加载完成后下面就出现了c2000的项目资源包
6．选中需要的示例项目后，点击如图的按钮就可以加载工程到工作空间了
二、解决编译器版本问题 若出现编译器版本不对，无法加载示例工程的情况，需要自行安装别的编译器版本。
（一）下载编译器 1．点击install new software
2．选择code generation tools Update
3．选择需要的编译器下载
（二）安装编译器 比如下载的安装包在 D:\CCS6\ccsv6\eclipse\downloads
ti_cgt_c2000_16.9.11.LTS_windows_installer.exe
把安装后的ti-cgt-c2000_16.9.11.LTS文件夹 复制到 D:\CCS6\ccsv6\tools\compiler 目录下。
然后点击project -》New CCS project
点击more
点击 browse
找到D:\CCS6\ccsv6\tools\compiler 下的ti-cgt-c2000_16.9.11.LTS文件夹，载入。
这样 新版本的编译器就安装好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bc78d60123b74cc2f93509194938a7e/" rel="bookmark">
			springboot单元测试junit启用回滚测试数据报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错信息 Failed to retrieve PlatformTransactionManager java.lang.IllegalStateException: Failed to retrieve PlatformTransactionManager for @Transactional test 描述 在JunitTest类中，使用 @Transactional注解，在运行测试后自动回滚数据。在springboot启动类上添加注解 @EnableTransactionManagement ，运行单元测试报错。
解决 @Transactional注解需要一个事务实例的名称才能正常运行，默认的名称应该是transactionManager ，就像这样：@Transactional(“transactionManager”)。参考如下 @Transactional requires a bean with name transactionManager in your application context if not specified explictly. Specify the transaction manager you want to use with your test using the @Transaction annotation value attribute
https://stackoverflow.com/questions/37344471/failed-to-retrieve-platformtransactionmanager-for-transactional-test-for-test-c\
在本人的案例中，在数据源的配置类中添加如下配置，即可解决问题。 @Bean @Qualifier("transactionManager") public PlatformTransactionManager txManager(@Qualifier("monitorDataSource") DataSource dataSource){ return new DataSourceTransactionManager(dataSource); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e668c0c09643c24a789063b5c8252aa3/" rel="bookmark">
			IIC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欲观原文，请君移步
IIC 简介 IC(Inter-Integrated Circuit)总线是一种由PHILIPS公司开发的两线式串行总线，用于连接微控制器及其外围设备。I2C总线产生于在80年代，最初为音频和视频设备开发，如今主要在服务器管理中使用，其中包括单个组件状态的通信。例如管理员可对各个组件进行查询，以管理系统的配置或掌握组件的功能状态，如电源和系统风扇。可随时监控内存、硬盘、网络、系统温度等多个参数，增加了系统的安全性，方便了管理。IIC数据传输速率有标准模式（100 kbps）、快速模式（400 kbps）和高速模式（3.4 Mbps），另外一些变种实现了低速模式（10 kbps）和快速+模式（1 Mbps）。
下图是一个嵌入式系统中处理器仅通过2根线的IIC总线控制多个IIC外设的典型应用图
特点 简单性和有效性 由于接口直接在组件之上，因此 IIC 总线占用的空间非常小，减少了电路板的空间和芯片管脚的数量，降低了互联成本。总线的长度可高达 25 英尺，并且能够以 10Kbps 的最大传输速率支持 40 个组件。
多主控(multimastering) 其中任何能够进行发送和接收的设备都可以成为主总线。一个主控能够控制信号的传输和时钟频率。当然，在任何时间点上只能有一个主控。
IIC 通信协议 IIC 串行总线一般有两根信号线，一根是双向的数据线 SDA ，另一根是时钟线 SCL ，其时钟信号是由主控器件产生。所有接到 IIC 总线设备上的串行数据 SDA 都接到总线的 SDA 上，各设备的时钟线 SCL 接到总线的 SCL 上。对于并联在一条总线上的每个 IIC 都有唯一的地址。
IIC 总线在传输数据的过程中一共有三种类型信号，分别为：开始信号、结束信号 和 应答信号。这些信号中，起始信号是必需的，结束信号和应答信号，都可以不需要。同时还有空闲状态、数据的有效性、数据传输。
起始信号 当时钟线SCL为高期间，数据线SDA由高到低的跳变。
停止信号 当时钟线SCL为高期间，数据线SDA由低到高的跳变。
空闲状态 当 IIC 总线的数据线 SDA 和时钟线 SCL 两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。
应答信号 发送器每发送一个字节（ 8个bit ），就在时钟脉冲 9 期间释放数据线，由接收器反馈一个应答信号。
应答信号为低电平时，规定为有效应答位（ ACK ，简称应答位），表示接收器已经成功地接收了该字节；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e668c0c09643c24a789063b5c8252aa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c329702c9074738e084198b32194e392/" rel="bookmark">
			狄克斯特拉算法（Dijkstra）——算法思想及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个算法可是属于真正的老经典算法了，这学期离散数学里学到的唯一一个算法也就是这个Dijkstra算法，这个算法实际上就有贪心算法的味道在里面，即每次都确定一个顶点的最优路径，直到遍历全图。由于本人水平真的过低，这学期在离散数学中学这个算法的时候真的是花了很多很多时间才弄明白算法原理，曾一度怀疑人生并且无数次想要撕碎这个课本。我真的搞不懂明明很简单的一个算法，为什么放到教科书上面会给花里胡哨地加上一些专有名词，然后变得极度抽象，我是真的是很无语。。。个人感觉我们学校订的教科书编的不是很好（纯粹个人感觉。）
这边我尽量用最简洁易懂的方式，将这个算法表示清楚。因为我太清楚深受教科书毒害的学生们的感受了。。
首先，我们要明白，这个算法到底有什么用？（学一个新东西，要么是知道它有什么用（功利化学习），要么就是很喜欢它，就是想学（去功利化），当然如果你能做到二者兼顾，那最好了）这个算法，是求最短路径的，也就是求一个点到另一个点的最短路径，这里的最短路径指的是权值大于等于0的路，为什么是这样，这个我会在后文说到。至于为什么是带权，是为了与BFS广度优先搜索算法区分，BFS也是求最短路径，但是求的是不带权的路，也就是段数最少的路径。
在这之后，我们就可以开始学习这个算法了，这个算法的核心思想完全可以用一句话概括，“每次都确定初始点到一个顶点的最短路径，直到遍历全部顶点”。因为如果直接阐述思想，会过于抽象，难以理解，因此我这边就打算结合例子解释。这是我从书上找到的一个比较好的例子，这个例子弄懂了基本上这个算法也就掌握了。
首先，我们要明确我们的目标，我们要用Dijkstra算法算出b点到图上所有点的最短路径。在明确了目标之后，我们要先定义一个map&lt;char,int&gt; cost，存储从初始点点到各点的当前最短距离（当然这里不一定要用map,思想一样就可以，我这里用map是为了更好地理解），然后就是让计算机存储图的信息，这里我选择用map&lt;char,map&lt;char,int&gt; &gt; graph，（是不是感觉这里有点复杂。。其实完全不是的，这里完全就可以看成一个二维数组，a[x][y]，里面存储的值是x到y的距离），再然后就是我们需要再定义一个map&lt;char,char&gt; parents，存储最短路径上一个顶点的前一个顶点，也就是存储父节点，用来进行回溯，这样才能把最短路径经过的节点给一一求出来（如果你不需要求最短路径经过的节点，这个就不需要定义了，当然，最好还是要求出来，这样才能让这个算法更加elegant）。最后就是定义一个vector&lt; char &gt; over，用来存储已经确定好最短路径的顶点（这是Dijkstra算法思想中最关键的一环，就是你每次确定好的那个最短路径的顶点，它的最短路径到程序结束都不会再改变了，因此将其放到vector中，避免再对它进行操作），做好了上述三步，就可以开始我们的算法了。
根据上述三步，我们一开始确定的cost散列表（第一列是节点，第二列是初始点到各个节点的当前最短距离），如下·
这里切记，一开始我们只能确定b点到b点的距离是0（这是由于程序编写的需要），其他点默认正无穷。 而我们每一次都需要在cost里面找到一个最短的距离，通过这个最短距离确定一个节点。然后这就算确定了一个顶点的最短路径，也就是确定了b点到b点的最短路径，将其加入到over容器中，之后就不再需要求b点到b点的最短路径了（这个是不是在我们人看起来很傻。。其实我们的目的是让计算机识图，因此要把计算机当成一个蠢的不能再蠢的人看待）
之后我们就要开始更新这个cost散列表了，这也是Dijkstra算法很关键的一步，就是由于我们已经确定了到b点的最短路径，因此我们可以搜索b点到各个直接相邻的点的权值（也就是相邻边的长度），让已经确定的cost中b点的最短路径径加上权值，就能求出来b点到各个相邻点的距离（记住，这里是一个距离，不是最短距离，如果要是最短距离，一定一定要比较才能得出），此时我们将这个距离和我们存储在cost散列表里的当前最短距离比较，如果这个距离比当前最短距离小，就进行更新，将cost里面对应位置的值变成这个距离，然后把b设定为这个节点的父节点。在更新完后，我们的cost散列表就变成了这样，
b节点后面加上*就表示它是已经确定的节点了（也就是已经求出了初始点到这个节点的最短路径了），之后再在cost里面找，到一个顶点的最短路径，就不再需要考虑它了，切记切记！
之后就非常简单了，就是重复上面的步骤。再从cost里面找cost里面最小的值代表的节点（除已经确定的节点以外），找出这个节点，然后重复上面步骤就可以。这次我们找出的节点是c节点，然后cost散列表更新后就变成，
之后就是重复到所有顶点后面都加上*后，这个算法就算结束了，然后cost最终存储的值就是初始点到各个点的最短路径，若想具体求出，通过parents回溯即可。
这里我给出参考书上的解析图，
这里面每一行代表一次计算，每一次计算确立一个顶点，找到一条最短路径，然后括号的第一个参数是初始点到这个点的当前最短距离，也就是cost存储的值，然后第二个参数就是存储这个节点的父节点，λ表示暂未确定父节点。
最终cost的结果如下，
具体路径如下，
是不是看到这里感觉这个算法难度还好，不是很难。但是这个算法有几个很有想法的点，如果你有真正的去思考这个算法，你应该可以感受到。一，为什么每次确定下来的那个节点，之后就不需要再需要对它进行更新了？二，为什么就能很肯定每次确定下来的节点它对应的cost值就是最终的最短路径？三，为什么每次只能确定一个节点？四，为什么这个算法无法解决有负权边的情况？五，为什么要根据每次确定的节点对cost进行更新？想清楚了这几个问题，你才能能说真正的懂这个算法，要不然永远只能根据框架去套它，一辈子在门外徘徊。
首先，前四个问题其实是统一的，你只要弄清楚其中任何一个，其他几个就豁然开朗了。我这边就从第一个问题切入，首先要明白我们每次计算是如何确定那一个节点的？是在cost当前最短路径中找到目前最快能到达的节点（也就是目前初始节点到这个节点的距离最短），而当我们找到了这个节点，我们就当在cost中存储的值是初始节点到这个节点的最短路径，后续就不用再对这个节点在cost中的值进行更新了。这是为什么？
就是因为我们伟大的Dijkstra算法只应用于权值大于等于0的图，回到这个问题的一开始，我们每次要确定的节点是在cost当前最短路径中找到目前最快能到达的节点，如果我之后又能找到其他到这个节点的路径，那么我能找到的到这个节点的除cost中的最短路径的路径必然是cost中的未确定节点中除这个节点以外的节点对应的值再加上一个连接这俩个节点的边的权值（为什么这里说是cost中的未确定的节点，因为未确定的节点已经更新过了，我们不用再管它，若是你读了后面问题五的解释，你再回过头来仔细想想，就能明白，其实经过那些已经确定的节点的最短路径加上一条连接这俩个节点的边得到的值我们已经求过了！），而我们这次确定的节点中cost的值已经是除未确定节点中最小的了，其他节点再加上权值大于等于0的边，必然会比这个值大的！这里我要举个例子，因为这个是比较难理解的点，空讲的话就会有点抽象。
这里我定义的初始节点是家，根据算法，我第一次确定的节点是家，然后第二次确定的节点就是学校，也就是说到学校的最短路径是2，那有没有可能将到学校的路径缩短到少于2呢？答案是完全不可能，因为你到除家以外的其他节点已经要花比到这个节点更长的距离了，再加上大于等于0的权边，就完全不可能实现了，因此我上面说的一大段话就是说明这个道理。
至于最后的第五个问题，为什么要根据每次确定的节点对cost进行更新，这是因为，一个节点的最短路径必然是与它相邻节点的最短路径加上相邻边之后得到的。我们确定的这个节点是我们已经知道了它的最短路径，然后我们根据这个最短路径进行扩展，试图根据这个最短路径扩展到其他节点，得到到其他节点的路径（但是这个不一定是最短路径，这是很容易犯的错误，我之前也懵逼了很久，因为原先cost里面存的那个值也是与它相邻节点的最短路径加上相邻边之后得到的），根据上面我对问题一的解释，我们每次最终确定下来的节点它对应的cost值就是最终的最短路径，然后我们在确定了一个节点之后就需要确定下一个节点，直到所有节点都被确定，
那么，我们就需要时刻保持cost中存储的是初始节点到各个节点的当前最短路径，而每当我们确定下一个节点之后，我们就可以利用与这个节点相邻的边的信息，从而得到如上面所说的到其他节点的路径长度，而将其求出来的路径长度和我们cost里面存储的路径长度比较，更短的那个就是当前最短路径。
因此，从这里可以看出，根据每次确定的节点对cost进行更新的很大一部分原因就是在合理利用所有边的信息的情况下，时刻保持cost中存储的是初始节点到各个节点的当前最短路径。因为当前最短路径只有俩种可能，一是根据上一个已经确定的节点进行扩展得到的路径，二是之前已经存储到cost中的当前最短路径（这个是根据上一个之前已经确定的节点进行扩展得到的路径）。（一个节点的最短路径必然是它与相邻节点的最短路径加上相邻边之后得到的，这个是最最最最重要的！）
如果不是根据确定的节点对cost进行更新的话，那么我们就会将第一个情况变成根据未确定的节点进行扩展得到的路径，而到未确定的节点的最短路径我们还没有求出来，也就是得到了一条很有可能不是由最短路径加上相邻边得到的路径，这就会导致算法出错了，使得我们有可能漏掉更短的最短路径，从而有可能让cost散列表没有处于“时刻存储的是当前最短路径”的情况，最终让算法执行失败。
额，可能是我的水平实在过低，我原本的想法是尽可能简洁易懂，但是一不小心还是打了这么多字才把我认为核心的地方讲完，可能在某些人看来是啰里啰唆搞了半天吧。。。不过我还是很开心的，因为我在解释这五个问题的同时，也对我之前学习的知识进行重塑，也让我对这个算法有了进一步的认识，很多之前没有想清楚的地方也都豁然开朗了，果然，学无止境这个成语真的很有道理。。。
真正弄懂了这个算法的思想之后，剩下的就是相对比较简单的代码实现了。我这边就直接给出代码，
#include&lt;bits/stdc++.h&gt; using namespace std; int n, m; int find_lowest_cost(map&lt;int, int&gt; cost, vector&lt;int&gt;&amp; over)//找到当前开销最小的节点（不包括over中的节点） { int low; for (int i = 1; i &lt;= n; i++) { if (find(over.begin(), over.end(), i) == over.end()) low = i; } for (int i = 1; i &lt;= n; i++) { if (cost[i] &lt; cost[low] &amp;&amp; (find(over.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c329702c9074738e084198b32194e392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9982741839c6e4d23fb74c187d99d189/" rel="bookmark">
			vue &#43; antd项目Table的前台内容排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、table部分代码
&lt;!-- dom结构 --&gt; &lt;a-table row-key="id" :columns="columns" :loading="loading" :data-source="list" :pagination="pagination" @change="handlePageChange" &gt; &lt;template slot="operation" slot-scope="id, record"&gt; &lt;a @click="() =&gt; handleClickEdit(record.id)" &gt; 编辑 &lt;/a&gt; &lt;a @click="() =&gt; handleClickDelete(record.id)" &gt; 删除 &lt;/a&gt; &lt;a @click="() =&gt; handleClickDetail(record.id)"&gt; 详情 &lt;/a&gt; &lt;/template&gt; &lt;/a-table&gt; &lt;script&gt; const columns = [ { title: "货品名称", dataIndex: "goods" }, { title: "进货数量", dataIndex: "quantity" }, { title: "单价", dataIndex: "price" }, { title: "剩余数量", dataIndex: "rest" }, { title: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9982741839c6e4d23fb74c187d99d189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f46a10d4a2edc0ddc7c61d992feecc/" rel="bookmark">
			LeetCode 1231. 分享巧克力（极小极大化 二分查找）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 题目2. 解题 1. 题目 你有一大块巧克力，它由一些甜度不完全相同的小块组成。我们用数组 sweetness 来表示每一小块的甜度。
你打算和 K 名朋友一起分享这块巧克力，所以你需要将切割 K 次才能得到 K+1 块，每一块都由一些 连续 的小块组成。
为了表现出你的慷慨，你将会吃掉 总甜度最小 的一块，并将其余几块分给你的朋友们。
请找出一个最佳的切割策略，使得你所分得的巧克力 总甜度最大，并返回这个 最大总甜度。
示例 1： 输入：sweetness = [1,2,3,4,5,6,7,8,9], K = 5 输出：6 解释：你可以把巧克力分成 [1,2,3], [4,5], [6], [7], [8], [9]。 示例 2： 输入：sweetness = [5,6,7,8,9,1,2,3,4], K = 8 输出：1 解释：只有一种办法可以把巧克力分成 9 块。 示例 3： 输入：sweetness = [1,2,2,1,2,2,1,2,2], K = 2 输出：5 解释：你可以把巧克力分成 [1,2,2], [1,2,2], [1,2,2]。 提示： 0 &lt;= K &lt; sweetness.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f46a10d4a2edc0ddc7c61d992feecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ea303ad8f8e101cba7cd02c14f6dbf6/" rel="bookmark">
			数组对象的常用处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		何为数组对象？ 即数组里面包含的对象。比如： let someArr4 = [{ id:1, name:'bb' },{ id:4, name:'cc' },{ id:1, name:'dd' }] 1、filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
原数组不变
不会对空数组进行检测
let arr1 = [1,2,3,4] let arr2 = arr1.filter(item=&gt;item===1) console.log(arr1, 'arr1') // [1,2,3,4] arr1 console.log(arr2, 'arr2') // [1] arr2 let arr3 = [{ id:1, name:'aa', desc: 'aaaa' },{ id:2, name:'bb' },{ id:3, name: 'aa' }] let arr4 = arr3.filter(item=&gt;item.name === 'aa') console.log(arr4, 'arr4') // [{id:1,name:'aa', desc:'aaaa'},{id:3,name:'aa'}] arr4 2、find() 对于空数组，函数是不会执行的。
不会改变原数组
返回符合测试条件的第一个数组元素值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ea303ad8f8e101cba7cd02c14f6dbf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfe3d4a402d2a12a7bc8ca84711d2361/" rel="bookmark">
			Vue报错：Mixed spaces and tabs no-mixed-spaces-and-tabs 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue报错：Mixed spaces and tabs no-mixed-spaces-and-tabs 解决这错误比较合理且简单的方法是:
1.找到配置文件：test目录下的.eslintrc.js文件
2.然后到rules里，手动添加’no-mixed-spaces-and-tabs’，然后定义为0，关闭规则
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc3625e1965d319f189ecba379f0e404/" rel="bookmark">
			函数自执行前边那个感叹号 ！或者分号 ；是干嘛的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在阅读别人写好的自执行函数时经常遇到在function前加！或者； ，这是用来干嘛的呢？
很简单，就是用来防止前边的js语句没加分号，防“串味儿”的！
也就是说防止前边代码影响后边程序防止报错的。就酱~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e21f4ca054e071c9b528c7a667c9825e/" rel="bookmark">
			比例运算电路（multisim实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.同相比例运算电路
​ 输入与输出关系：​
2.反相比例运算电路 输入与输出关系：​
1.同相比例运算电路 仿真波形：
输入与输出关系： 2.反相比例运算电路 R2扫描波形
输入与输出关系： 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/423/">«</a>
	<span class="pagination__item pagination__item--current">424/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/425/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>