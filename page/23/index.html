<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09aecfaa0d8367f9a4bfd621619acf6c/" rel="bookmark">
			openGauss学习笔记-173 openGauss 数据库运维-备份与恢复-导入数据-对表执行VACUUM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 openGauss学习笔记-173 openGauss 数据库运维-备份与恢复-导入数据-对表执行VACUUM openGauss学习笔记-173 openGauss 数据库运维-备份与恢复-导入数据-对表执行VACUUM 如果导入过程中，进行了大量的更新或删除行时，应运行VACUUM FULL命令，然后运行ANALYZE命令。大量的更新和删除操作，会产生大量的磁盘页面碎片，从而逐渐降低查询的效率。VACUUM FULL可以将磁盘页面碎片恢复并交还操作系统。
对表执行VACUUM FULL。
以表product_info为例，VACUUM FULL命令如下：
VACUUM FULL product_info VACUUM 👍 点赞，你的认可是我创作的动力！
⭐️ 收藏，你的青睐是我努力的方向！
✏️ 评论，你的意见是我进步的财富！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32ea8f6ef78072aecaa1a254a0c7f7b/" rel="bookmark">
			[AIGC] ArrayList介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java编程中，我们经常需要存储和处理一组数据。为了更方便地管理数据集合，Java提供了许多集合类。其中之一就是ArrayList。
文章目录 是什么为什么怎么用总结 是什么 ArrayList是Java中的一个动态数组类，它实现了List接口。它可以自动调整大小，根据需要动态增加或减少元素数量。与传统的数组相比，ArrayList具有更多的灵活性和便利性。
为什么 ArrayList的出现解决了传统数组的一些问题。在传统数组中，一旦初始化大小后，无法改变大小。如果需要添加或删除元素，就需要手动进行元素的移动操作，非常麻烦和耗时。而ArrayList能够根据需要自动调整大小，并且提供了一系列方便的操作方法，大大简化了数组操作的复杂性。
怎么用 下面通过一个简单的例子来说明如何使用ArrayList。
import java.util.ArrayList; public class ArrayListExample { public static void main(String[] args) { // 创建一个ArrayList对象 ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); // 添加元素 names.add("Alice"); names.add("Bob"); names.add("Charlie"); // 获取元素数量 int size = names.size(); System.out.println("ArrayList中的元素数量为：" + size); // 访问元素 String first = names.get(0); System.out.println("ArrayList中的第一个元素为：" + first); // 修改元素 names.set(1, "Eve"); System.out.println("修改后的ArrayList为：" + names); // 删除元素 names.remove(2); System.out.println("删除元素后的ArrayList为：" + names); } } 输出结果：
ArrayList中的元素数量为：3 ArrayList中的第一个元素为：Alice 修改后的ArrayList为：[Alice, Eve, Charlie] 删除元素后的ArrayList为：[Alice, Eve] 在这个例子中，我们首先创建了一个名为names的ArrayList对象，并添加了三个元素。然后使用size()方法获取元素数量，并使用get()方法访问特定索引位置的元素。接着使用set()方法修改第二个元素并使用remove()方法删除第三个元素。最后输出修改后的ArrayList。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e32ea8f6ef78072aecaa1a254a0c7f7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5b0bb643fc53b98285c3dce4f545e8f/" rel="bookmark">
			返利机器人赚佣金工作原理及实现思路探索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		返利机器人赚佣金工作原理及实现思路探索 大家好，我是免费搭建查券返利机器人赚佣金就用微赚淘客系统3.0的小编，也是冬天不穿秋裤，天冷也要风度的程序猿！今天，我将带大家深入探索返利机器人的工作原理和实现思路，让你轻松掌握这一赚钱的秘密武器！
在电商时代，返利机器人成为了越来越多人的选择。它利用自动化技术、网络爬虫和数据分析等技术手段，帮助用户查找优惠券、获取返利，从而实现赚取佣金的目的。那么，返利机器人是如何工作的呢？
首先，返利机器人需要获取电商平台的商品信息和优惠券数据。通过爬取电商平台的公开数据，返利机器人可以实时获取各类商品的优惠券及返利信息，并将这些信息整合在一起。
其次，当用户通过返利机器人进行购物时，机器人会根据用户的查询条件，自动查找并领取相应的优惠券。同时，机器人还会根据用户的历史购物记录和浏览行为，智能推荐合适的商品，提高购物转化率。
最后，在用户完成订单后，返利机器人会根据与电商平台的协议，将一部分佣金返还给用户。用户可以随时查看自己的收益情况并进行提现操作。
那么，如何实现返利机器人呢？其实，要搭建一个返利机器人并不难。首先，你需要注册一个微信公众号（订阅号或服务号皆可）。然后，你需要注册并登录微赚淘客系统3.0。这个系统提供了丰富的功能和工具，可以帮助你快速搭建一个返利机器人。在微赚淘客系统3.0中，你可以方便地配置公众号的相关设置。你需要为公众号配置系统方案，选择使用你的分佣方案。此外，你还可以设置关注后回复语、关键词等其他配置项，以提升用户体验。
当然，要真正实现返利机器人的功能，还需要进行一系列的技术开发工作。你需要利用自动化技术、网络爬虫和数据分析等技术手段，开发相应的程序和算法，以实现自动查找优惠券、推荐商品和赚取佣金等功能。同时，你还需要关注电商平台的政策变化和数据安全问题，确保返利机器人的合规运营和用户数据的安全。
总的来说，返利机器人是一个基于自动化技术、网络爬虫和数据分析等技术手段的赚钱工具。通过搭建一个返利机器人，你可以轻松获取电商平台的佣金收益，如果不愿意写代码，可使用微赚淘客系统来实现。当然，要实现这一赚钱模式，你需要具备一定的技术实力和运营策略。希望本文对大家了解返利机器人的工作原理及实现思路有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ecb8c7a6521a95c1741bd78c8eaa45/" rel="bookmark">
			[足式机器人]Part2 Dr. CAN学习笔记-自动控制原理Ch1-5比例积分控制器Proportional-Intefral Controller
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供学习使用
本文参考：
B站：DR_CAN
Dr. CAN学习笔记-自动控制原理Ch1-5比例积分控制器Proportional-Intefral Controller 消除稳态误差——设计新的控制器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4d68ff112cd4c2b64f55d7f2b1eaba/" rel="bookmark">
			大厂HR大揭秘！年底才是找工作的黄金期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 求职职场上，一直有“金三银四”“金九银十”的传说。
所谓“金三银四”： 是因为现在的公司普遍有年终奖，年终奖嘛，那得年底才发。
很多人即便已经有了离职打算，但眼看都已经快呆到年底了，不如忍一把，拿到钱再说，还能安安稳稳过个年。
等年后一开工，就开始物色新工作。
所以，三月和四月，大量人才更替，求职市场活跃起来，老人有了要走的想法，公司也考虑招点新血液，也算是需求匹配了。
而且，在这个时间入职新公司，该拿的福利、年终奖啥的，也有资格享受，人们的换工作的意愿也会加大。
而”金九银十”，其实说的是校招，和社招关系不大。 从企业的视角看，一大批毕业生即将涌入社会，年轻，活力，价不高，那真算“遍地黄金”。
这个时候有工作经验的打工人市场上也会增多，这主要是因为，有很多公司说是说年终奖，但它在第二年5月份才发完。
这是企业的“留人战术”，毕竟开年公司整体业务气氛得浓，你人一走的多，气就聚不起来了。
所以，很多人即使心里骂骂咧咧，也会等熬到发完年终奖再走。
大家注意，这两个时间，企业放的岗位虽然多，但是竞争者也多啊。
况且，所谓的“金九银十”，还主要是针对应届生，含“金”量其实不高，企业眼睛都往学校集中了，咱都毕业大几年了，优势其实没想象的大。
还有，那些为年终奖能熬到7、8月的人，说明什么？说明年终奖高啊！年终奖高侧面说明业务能力强。
一定要清楚岗位跟着什么走 其实在企业端，岗位和求职热期并不是强关联的。
岗位，永远是跟着需求走的。
如果你是人事，你不可能跟老板说：
老板，“金三银四”“金九银十”，咱们为了招到更好更性价比的人，只在这几个月开HC。
老板听了肯定一个白眼就过去了，公司不要发展了？业务不要转了啊！
所谓的求职高峰期，高峰的更多只是人多而已，不确保什么样的公司在开什么样的岗位。
所以，找工作的黄金期在哪里？
就是在年底。
当所有人都觉得年前不敢动，没必要动的时候，企业的岗位其实是不会停的。
岗位还在，但竞争者变少了，这个时候，有经验的同学，就会成为市场上的香饽饽。
不信你可以试试，更新下简历，你会发现得到的回复和面试邀约比你想象的更多。
一定要在年的找工作 所以，我想对现在正在找工作的同学说：年底求职真的没有你想象的糟糕。
对于真的待不下去了，想要年终奖的同学，可以在这个时间段多刷招聘网站，万一看到更合适的offer，折算下来其实也不一定会“亏本”。
而且，年底在招人的企业，有3个非常大的优势。
没有虚假岗位：
因为新业务的产生不以时间为节点，而是以市场需求为导向。年底还在招人的公司，必然是真的要人。
之前面试总遇到虚假岗位，HR拉人头冲KPI啥的。那真的不妨试试年底投投简历。这个时候HR也正在为没有候选人焦头烂额呢。
业务发展快
许多正在快速发展、并且有远见的企业，会在年底制定来年的战略计划，需要提前储备人才，所以会在年底放出大量HC。
而且因为”金三银四“的存在，年后岗位流动其实非常大，当一个快车道，发展好的公司内人员流动，其实代表着很大的机会。
入职率高、入职周期短：
年底这个节点，还在招聘的企业，除了真要人，更是真的急着要人。企业的招聘欲望是很强烈的，为了完成招聘指标可能会放低招聘要求。
这时候，我们面试成功率、入职率都会提高。而且入职周期也会缩短。这对比较重视五险一金断缴的同学，非常友好。
薪资好商量：
前面说到，有些公司会有储备人才的计划。随之而来的，就是人才的预算。
这时候，有些公司是愿意在人才上花钱的，来年才能让员工们以更好的状态，投入到工作。所以，这个时候，只要已经确定offer了，薪资也会比其他时候更好商量，更容易拿到满意的薪资。
最后，面试题笔记分享 为了助力学Android朋友们能够在年底找到工作，本文给大家整了一套涵盖Android所有技术栈的快速学习方法和笔记。目前已经收到了七八个网友的反馈，说是面试问到了很多这里面的知识点。
每一章节都是站在企业考察思维出发，作为招聘者角度回答。从考察问题延展到考察知识点，再到如何优雅回答一面俱全，可以说是求职面试的必备宝典，每一部分都有上百页内容，接下来具体展示，完整版可直接下方扫码领取。
第一章 算法和数据结构面试题汇总 第二章 Java核心基础面试题汇总 第三章 Java深入泛型与注解面试题汇总 第四章 Java并发编程面试题汇总 第五章 Java虚拟机原理面试题汇总 第六章 Java反射类加载与动态代理面试题汇总 第七章 网络编程面试题汇总 第九章 高级UI面试题汇总 第十章 Framework内核解析面试题汇总 第十一章 Android组件内核面试题汇总 第十二章 程序性能优化与数据持久化面试题汇总 第十三章 开源框架面试题汇总 有需要完整面试题+答案解析的朋友，可以扫描下方二维码免费领取！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09b7526cfe118dfb001c19fdc031731a/" rel="bookmark">
			通知：Galaxy中国生信云免费空间升级至10G
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位用户：
即日起，Galaxy中国生信云（UseGalaxy.cn）所有注册用户的免费存储空间升级至 10G，这一措施响应了平台用户的呼声。随着平台上线的工具越来越多，社区也认为这很有必要。希望大家合理利用公共资源，不要浪费，及时清理无用文件。注意：
若使用 Delete 删除，文件依然会占用存储空间，此时可取消删除，即可找回。
对于确定不再需要的文件，使用 Delete(permanently) ，即为永久删除，文件不再占用存储空间，也不再可找回。
（节约资源，保护环境，践行低碳生活，人人有责。）
有更大存储和计算资源需求的用户，请联系管理员协调配置。
UseGalaxy中国社区
2023年12月25日
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/835abd02e30374b9b67d190370813ac4/" rel="bookmark">
			openGauss学习笔记-172 openGauss 数据库运维-备份与恢复-导入数据-分析表172.1 分析表172.2 表自动分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 openGauss学习笔记-172 openGauss 数据库运维-备份与恢复-导入数据-分析表172.1 分析表172.2 表自动分析 openGauss学习笔记-172 openGauss 数据库运维-备份与恢复-导入数据-分析表 执行计划生成器需要使用表的统计信息，以生成最有效的查询执行计划，提高查询性能。因此数据导入完成后，建议执行ANALYZE语句生成最新的表统计信息。统计结果存储在系统表PG_STATISTIC中。
172.1 分析表 ANALYZE支持的表类型有行/列存表。ANALYZE同时也支持对本地表的指定列进行信息统计。下面以表的ANALYZE为例，更多关于ANALYZE的信息，请参见ANALYZE | ANALYSE。
更新表统计信息。
以表product_info为例，ANALYZE命令如下：
ANALYZE product_info; ANALYZE 172.2 表自动分析 openGauss提供了GUC参数autovacuum用于控制数据库自动清理功能的启动。
autovacuum设置为on时，系统定时启动autovacuum线程来进行表自动分析，如果表中数据量发生较大变化达到阈值时，会触发表自动分析，即autoanalyze。
对于空表而言，当表中插入数据的行数大于50时，会触发表自动进行ANALYZE。对于表中已有数据的情况，阈值设定为50+10%*reltuples，其中reltuples是表的总行数。 autovacuum可以进行表自动分析功能的生效还依赖于下面几个GUC参数：
track_counts参数需要设置为on，表示开启收集收据库统计数据功能。autovacuum_max_workers参数需要大于0，该参数表示能同时运行的自动清理线程的最大数量。autovacuum_mode参需要配置允许进行analyze。 须知：
autoanalyze只支持默认采样方式，不支持百分比采样方式。多列统计信息仅支持百分比采样，因此autoanalyze不收集多列统计信息。autoanalyze支持行存表和列存表，不支持外表、临时表、unlogged表和toast表。 👍 点赞，你的认可是我创作的动力！
⭐️ 收藏，你的青睐是我努力的方向！
✏️ 评论，你的意见是我进步的财富！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf345173943a20bc3eb0a6b84b1e4ad/" rel="bookmark">
			[足式机器人]Part2 Dr. CAN学习笔记-自动控制原理Ch1-4终值定理和稳态误差Final Value Theorem &amp; Steady State Error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文仅供学习使用
本文参考：
B站：DR_CAN
Dr. CAN学习笔记-自动控制原理Ch1-4终值定理和稳态误差Final Value Theorem &amp; Steady State Error 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5dc6dc3d85f8fd734f53aee8ef9792b/" rel="bookmark">
			Unity 获取当前日期的短时间和处于早中午晚哪个时间段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我们手机中我们总会看到下图所示的时间，时间段+当前时间，假如我们要实现这个效果应该怎么做呢。
首先是使用DateTime.Now获取当前时间： // 获取当前时间 DateTime currentTime = DateTime.Now; 其次由当前时间获取短时间，可以使用以下两个方法：
//获取当前的短时间 法一 //string shortTime = currentTime.ToString("HH:mm"); //获取当前的短时间 法二 string shortTime = currentTime.ToShortTimeString(); 然后是通过当前小时数判断处于哪个时间段： string timeOfDay = GetTimeOfDayString(currentTime.Hour); //通过小时判断时间段 public string GetTimeOfDayString(int hour) { if (hour &gt;= 5 &amp;&amp; hour &lt; 9) { return "早上"; } else if (hour &gt;= 9 &amp;&amp; hour &lt; 12) { return "上午"; } else if (hour &gt;= 12 &amp;&amp; hour &lt; 14) { return "中午"; } else if (hour &gt;= 14 &amp;&amp; hour &lt; 18) { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5dc6dc3d85f8fd734f53aee8ef9792b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3643970e9fddc9057b40dc954c1ffa81/" rel="bookmark">
			matlab设置colorbar标题的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		%% 第一种 figure; A = rand(3,4,3); A1 = A(:,:,1); A2 = A(:,:,2); A3 = A(:,:,3); contourf(A1,A2,A3,30); colormap('jet');colorbar; my_handle=colorbar; my_handle.Label.String = 'depth/km'; my_handle.Label.FontSize = 15; %% 第二种 figure; A = rand(3,4,3); A1 = A(:,:,1); A2 = A(:,:,2); A3 = A(:,:,3); % my_handle.Label.String = 'Elevation (km)'; % my_handle.Label.FontSize = 15; contourf(A1,A2,A3,30); colormap('jet');colorbar; my_handle=colorbar; my_handle.Title.String = 'depth/km'; my_handle.Title.FontSize = 12; % t=get(my_handle,'YTickLabel'); % t=strcat(t,'km'); % set(my_handle,'YTickLabel',t); 第一种：
第二种：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42913ede175e87919e22809f8c284666/" rel="bookmark">
			python基础之操作MySQL数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作需要操作MySQL数据库，使用pymysql库，有些操作上不习惯的地方做了些修改。比如查询的时候结果不能按字段名读取数据等。以下是代码。
首先是引入库、引入random和string主要是为了生成id。
import pymysql import random import string 创建数据库链接对象
def mysqlconnect(): # 连接数据库 host = '192.168.1.1 port = 3306 user = 'root' password = 'root' database = 'ceshi_table' conn = pymysql.connect(host=host, port=port, user=user, password=password, database=database) cursor = conn.cursor() return cursor,conn 一、查询方法 def selectdata(sql_query): cursor,conn = mysqlconnect() # 执行SQL查询语句 cursor.execute(sql_query) # 获取查询结果 results = cursor.fetchall() # 查询 column_names = [desc[0] for desc in cursor.description] data = [] for row in results: name_value = {} for column_name in column_names: name_value[column_name] = row[column_names.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42913ede175e87919e22809f8c284666/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e7f6d7185c93b32efd0e589a48ce57/" rel="bookmark">
			查看docker映射数据卷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要查看Docker容器已经运行的数据卷映射，可以使用以下命令：
docker inspect -f '{{range .Mounts}}{{.Source}} -&gt; {{.Destination}}{{end}}' &lt;容器名称或ID&gt; 这个命令使用docker inspect命令以格式化的方式输出容器的详细信息。-f选项允许您指定Go模板，这里我们使用Go模板的range和{{.Source}} -&gt; {{.Destination}}来遍历并显示数据卷的源和目标路径。
将 &lt;容器名称或ID&gt; 替换为您要检查的实际容器的名称或ID。运行此命令后，您将看到容器中每个数据卷的源和目标路径。
例如，假设要查看名为my_container的容器的数据卷映射，您可以运行以下命令：
docker inspect -f '{{range .Mounts}}{{.Source}} -&gt; {{.Destination}}{{end}}' my_container 这将显示my_container中每个数据卷的映射关系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1802e8336d4d995fe0efe909d6857a0f/" rel="bookmark">
			MyBatis-Plus-Join关联查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-join-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.4.6&lt;/version&gt; &lt;/dependency&gt; 关联查询
baseMapper.selectJoinPage(page, StoreEntity.class, new MPJLambdaWrapper&lt;StoreEntity&gt;() .selectAll(StoreEntity.class) .select(DealerEntity::getDealerName) .leftJoin(DealerEntity.class, DealerEntity::getId, StoreEntity::getDistributorId) .eq(store.getStatus() != null, StoreEntity::getStatus, store.getStatus())); 说明：
StoreEntity.class是最终返回的DTOnew MPJLambdaWrapper()中的StoreEntity是主表查询的实体类.selectAll(StoreEntity.class)是查询主表的全部字段.select(DealerEntity::getDealerName)是查询字表的dealerName字段.leftJoin(DealerEntity.class, DealerEntity::getId, StoreEntity::getDistributorId)是表关联，DealerEntity.class是字表实体类，DealerEntity::getId关联字表的字段，StoreEntity::getDistributorId关联主表的字段.eq(store.getStatus() != null, StoreEntity::getStatus, store.getStatus())这个就是其他的条件查询啦，跟MP是一样的 以上执行SQL打印
select t.id, t.store_code, t.store_name, t.distributor_id, t.status, t.contact_person, t.contact_phone, t.store_location, t.position_lon, t.position_lat, t.create_by, t.create_time, t.update_by, t.update_time, t.dept_id, t.tenant_id, t.del_flag, # 这个是字表的字段 t1.dealer_name from tb_store t left join tb_dealer t1 on t1.id = t.distributor_id and t1.tenant_id = 1 where t.del_flag = '0' and t1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1802e8336d4d995fe0efe909d6857a0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff7cf56c39da01364f712f23ac412f7e/" rel="bookmark">
			ArcGIS online 无法连接网络的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此问题可能由多种原因造成，表现为系统托盘中的 ArcGIS Online 地球图标断开连接（显示红色×）。
解决方法：
方法一：
在系统托盘中的 ArcGIS Online 地球图标右键单击此图标 &gt;“属性”&gt;“启用 ArcGIS 连接”。
如果上述方法无效，则使用以下方法。
方法二：
警告：
下面的操作涉及更改操作系统的重要组成部分。必要时，请咨询计算机系统专业人士。
重命名 ESRI 文件夹即对 ArcGIS 恢复出厂设置，因此必须重新安装当前安装的所有第三方工具、自定义脚本和自定义工具栏。 此外，必须重新连接所有现有的文件夹连接。
操作：
1、重命名ESRI文件夹，以恢复ArcGis初始设置
关闭任何活动的 ArcMap 和 ArcGIS 应用程序。
打开 Windows 资源管理器。导航至路径：C:\Users\Administrator\AppData\Roaming
win7-win10为该路径，Administrator为当前系统用户名。默认情况下，应用程序数据（ AppData）文件夹是隐藏的。 如果无法定位文件夹，通过“文件夹选项”启用“显示隐藏的文件和文件夹”。
2、在“注册表编辑器”窗口中重命名 ESRI 文件夹
单击开始 &gt; 运行，然后输入 regedit。
在“注册表编辑器”窗口中，展开 HKEY_CURRENT_USER 文件夹。
展开“Software”文件夹。
将 ESRI 文件夹重命名为“ESRI_OLD”。
3、启动ArcMap，将自动完成初始化设置（自动生成ESRI文件夹与注册表项），查看是否能够连接ArcGis Online
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141da9f908f2587bd66c897070146919/" rel="bookmark">
			MyBatis-Plus多表关联查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有两张表：用户表（User）、区域表（Area），其中用户表里通过 area_id 字段关联区域表的 id 主键：
如果我们希望查询 User 时也能获取其所属的区域名称，这里对 User 实体类增加 areaName 属性：
@Data public class User { //指定主键使用数据库ID自增策略 @TableId(type = IdType.AUTO) private Integer id; private String userName; private String passWord; private Integer areaId; // area_name 不是 User 数据库表里的字段 // 因此需要添加 @TableField 注解，并将 exist 属性设置为 false @TableField(exist = false) private String areaName; } public interface UserMapper extends BaseMapper&lt;User&gt; { @Select("SELECT user.*, area.area_name FROM user, area " + "WHERE user.area_id = area.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/141da9f908f2587bd66c897070146919/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57e7926595ae8794db26ca54c0056c32/" rel="bookmark">
			vue中的render函数和过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、render函数
二、过滤器
全局注册过滤器
局部注册过滤器
过滤器使用
串联使用
过滤器js函数，可以传递参数
三、插件
插件作用：
开发插件：
使用插件：
一、render函数 需要js完全编程能力，比模板更接近编译器，编译模板，使用render函数我们可以用js语言来构建DOM，因为vue是虚拟DOM，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue就免去了转译的过程。
render(createElement){
return createElement(标签名称,{},子节点数组)
}
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;my-a :level="1"&gt; hello World &lt;/my-a&gt; &lt;/div&gt; &lt;script&gt; let myA = { props:['level'], data() { return { msg:'myA组件', arrs:[ {id:1,name:'terry'}, {id:2,name:'larry'}, {id:3,name:'ronda'} ] } }, // JSX Javascript + xml // let a = &lt;div&gt;&lt;/div&gt; // template:` // &lt;div&gt; // myA组件 // &lt;h1 v-if='level===1'&gt; // &lt;slot&gt;&lt;/slot&gt; // &lt;h1&gt; // &lt;h2 v-if='level===2'&gt; // &lt;slot&gt;&lt;/slot&gt; // &lt;h2&gt; // &lt;h3 v-if='level===3'&gt; // &lt;slot&gt;&lt;/slot&gt; // &lt;h3&gt; // &lt;/div&gt; // ` render(createElement){ // 创建节点描述 createElement(html标签,{元素属性,配置},[子节点数组]) // return createElement('h'+this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57e7926595ae8794db26ca54c0056c32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4d67e81deae94636699dad6f2f2765/" rel="bookmark">
			uniapp创建/运行/发布项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、产生背景----跨平台应用框架 在移动端各大App盛行的时代，App之间的竞争也更加激烈，他们执着于让一个应用可以做多个事情
所以就应运而生了小程序，微信小程序、支付宝小程序、抖音小程序等等基于App本身的内嵌类程序。
但是各大App他不可能是一样的框架所以就意味着各大App下的小程序也是不一样的。
对于开发人员而言，就意味着一个功能我不仅要写出一套app代码还要写出在各个APP上内嵌进去的n套不一样的代码，这是非常耗时耗力且一定程度上很鸡肋的事情
在这种情况下跨平台应用框架就出现了。
现在市面上比较有名生态相对成熟的就是uniapp、React-native、以及Taro
需要注意的是uniapp是基于vue框架的，react-native是基于react框架的，但taro他是基于node的，所以要用taro请先检查node环境为最新！
各大跨平台框架官方：
uniapp官网：https://uniapp.dcloud.net.cn/
react-native官网：https://www.reactnative.cn/docs/getting-started
taro官网：https://taro-docs.jd.com/docs/
2、前置使用条件 uniapp官网上对于uniapp的解释很全面也很具体
我个人认为uniapp是用着vue的语法，微信小程序的标签。
这就意味着 要使用uniapp最少是需要知道vue是怎么玩转的，小程序可能相对好一点不用那么严格但是最起码的一些基础还是要知道的。
3、环境安装 需要安装 官方指定idea—HBuilderX
3.1 方法一：下载安装 下载HBuilderX：https://www.dcloud.io/hbuilderx.html
3.2 方法二：命令安装 这个方法的前提是你有vue-cli的环境，没有的话建议直接走方法一。
不过命令行的话就直接创建了。
他是通过vue-cli指令指向到HBuilderX的创建项目那边。
4、创建项目 4.1 idea使用创建项目 在点击工具栏里的文件 -&gt; 新建 -&gt; 项目（快捷键Ctrl+N）：
下面就会出现这个面板：
选择uniapp类型，是uniapp还是Wap2App亦或是5+App或IDE插件2的位置输入你的项目名称选好你项目文件在电脑中的位置选择模板（uni-app自带的模板有 默认的空项目模板、Hello uni-app 官方组件和API示例，还有一个重要模板是 uni ui项目模板，日常开发推荐使用该模板，已内置大量常用组件。）根据自己的需要来决定是否启用uniCloud云端或者git点击创建 一个你需要的uniapp项目即创建完成左下7是在已经有现成项目需要接手去修改时 的云端引入。 4.2 命令行创建项目 第一步 创建项目命令行
使用正式版（对应HBuilderX最新正式版）: vue create -p dcloudio/uni-preset-vue my-project 使用alpha版（对应HBuilderX最新alpha版）: vue create -p dcloudio/uni-preset-vue#alpha my-alpha-project 使用Vue3/Vite版: 创建以 javascript 开发的工程（如命令行创建失败，请直接访问 gitee 下载模板） npx degit dcloudio/uni-preset-vue#vite my-vue3-project npx degit dcloudio/uni-preset-vue#vite-alpha my-vue3-project 创建以 typescript 开发的工程（如命令行创建失败，请直接访问 gitee 下载模板） npx degit dcloudio/uni-preset-vue#vite-ts my-vue3-project 第二步 创建项目命令行之后选择模板
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd4d67e81deae94636699dad6f2f2765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cb15c55efabd4f477e83913d3164813/" rel="bookmark">
			ArcGIS矢量化ArcScan工具条呈灰色无法使用的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用ArcGIS矢量化工具 ArcScan 时在满足以下条件：
1、栅格图像已二值化
2、对应要素类已启动编辑
3、管理器中ArcScan有效，如图中红框所示：
在此情况下，打开ArcScan，仍是灰色：
解决办法：点击菜单栏的【自定义】—&gt;【扩展模块】，在弹出窗口选中ArcScan 将显示如下图
此时，ArcScan 将不再是灰色，便可以使用了，如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a8c84f030955a8ed3da025d75fc420e/" rel="bookmark">
			解决GoogleEarth-谷歌地球无法打开的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对谷歌地球的常见问题，基本有三种可能性和一种特殊情况，针对不同的情况，有不同的解决方案。因此并不是别人能看，我这里不能看，我换成和别人一样的hosts就能看，要具体问题具体分析，才能对症下药。
如果实在无法解决的终极办法，联系我，我有个插件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a5895a426e0ab6cd62d0976dd1a5bd6/" rel="bookmark">
			Matalb数据处理和绘图时遇到尖点的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
在MATLAB中，数据处理和绘图时遇到尖点的问题可能是由于数据的不平滑性或者突变引起的。为了处理这种情况，可以尝试使用滤波器或平滑技术，以平滑数据并减少尖点的影响。 以下是一些常用的方法：
移动平均滤波器： 使用一个窗口，计算窗口内数据的平均值，然后将平均值作为新的数据点。这有助于减小突变对数据的影响。
1.使用移动平均滤波器
% 使用移动平均滤波器 smoothed_data = smooth(data, window_size); plot(smoothed_data); 中值滤波器： 与平均滤波器类似，但是计算窗口内数据的中值。中值滤波器对于处理离群值（如尖点）更为鲁棒。 2. 使用中值滤波器
smoothed_data = medfilt1(data, window_size); plot(smoothed_data); 样条插值： 使用interp1函数进行插值，以平滑曲线。样条插值通过拟合曲线来平滑数据。 3. 使用样条插值
x_interp = linspace(1, numel(data), 1000); % 调整插值点的数量 y_interp = interp1(1:numel(data), data, x_interp, 'spline'); plot(x_interp, y_interp); 去噪技术： 使用去噪算法，如小波变换，来降低数据中的噪声。 4. 使用小波变换去噪
denoised_data = wdenoise(data); plot(denoised_data); 选择哪种方法取决于你的数据特性和平滑程度的需求。你可能需要尝试不同的方法并调整参数以找到最适合你数据的方法。 下面是中值滤波器c语言代码、平均值滤波器c代码例子：
1.中值滤波器c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void medianFilter(int* data, int dataSize, int windowSize) { int* tempData = malloc(windowSize * sizeof(int)); int halfWindowSize = windowSize / 2; for (int i = halfWindowSize; i &lt; dataSize - halfWindowSize; ++i) { // Copy data to temporary array for (int j = 0; j &lt; windowSize; ++j) { tempData[j] = data[i - halfWindowSize + j]; } // Perform bubble sort (or any other sorting algorithm) for (int j = 0; j &lt; windowSize - 1; ++j) { for (int k = 0; k &lt; windowSize - j - 1; ++k) { if (tempData[k] &gt; tempData[k + 1]) { // Swap int temp = tempData[k]; tempData[k] = tempData[k + 1]; tempData[k + 1] = temp; } } } // Set the median value to the original data data[i] = tempData[halfWindowSize]; } free(tempData); } int main() { // Example usage int data[] = {3, 8, 2, 5, 1, 4, 7, 6}; int dataSize = sizeof(data) / sizeof(data[0]); int windowSize = 3; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a5895a426e0ab6cd62d0976dd1a5bd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48910ff2ba232d09c82ac75c33eb7e11/" rel="bookmark">
			前端八股文（js篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.强制类型转换规则 首先需要了解隐式转换所调用的函数。
当程序员显示调用Boolean（value）,Number（value），String（value）完成的类型转换，叫做显示类型转换。
当通过new Boolean（value），new Number（value），new String（value）传入各自对应的原始类型的值，可以实现"装箱"，将原始类型封装成一个对象。
其实这三个函数不仅仅是可以当做构造函数，它们可以直接当作普通的函数来使用，将任何类型的参数转换成原始类型的值：
Boolean('sdfsd') //true Number("23") //12 String({a:24}); // "[object object]" 其实这三个函数用于类型转换的时候，调用的就是js内部的ToBoolean，ToNumber，ToString方法，从而达到显示转换的效果
二.Object.is()与操作符 "===" ,"=="的区别 ==（或者!=）操纵在需要的情况下自动进行了类型转换 。===（或！==）操作不会执行如何转换。
===在比较值和类型时，可以说比==更快。
而在ES6中，Object.is()类似于 ===，但在三等号判定的基础上特别处理NaN,-0和+0，保证-0和+0不再相同，但Object.is（NaN，NaN）会返回true。
三.事件以及事件相关的兼容性问题 事件最早是在IE3和Navigator2中出现的，当时作为分担服务器运算负担的一种手段。要实现和网页的互动，就需要通过JavaScript里面的事件来实现。
每次用户与一个网页进行交互，例如点击链接，按下一个按键或者移动鼠标时，就会触发一个事件。我们的程序可以检测到这些事件，然后对此做出响应。从而形成一种交互。
当我们绑定事件时，需要遵循事件三要素
事件源：是指那个元素引发的事件。比如当你点击图标的时候，会跳转到百度首页。那么这个图标就是事件源。事件：事件是指执行的动作。例如，点击鼠标，按下键盘，获得焦点。事件驱动程序：事件驱动程序即执行的结果。例如，当你点击图标的时候，会跳转到百度首页。那么跳转到百度首页就是事件的处理结果。 事件源.事件= function (){ 事件处理函数 } 三.什么是预编译？ 所谓的预编译就是：在当前作用域中，JavaScript代码执行之前，浏览器首先会默认的把所有带var和function声明的变量进行提前的声明或者定义。
另外，var声明的变量和function声明的函数在预解析的时候有区别，var声明的变量在预解析的时候只是提前的声明，function 声明的函数在预解析的时候会提前声明并且会同时定义。也就是说var声明的变量和function声明的函数的区别是在声明的同时有没有同时进行定义。
四.Promise有几种状态，Promise有什么优缺点？ Promise有三种状态：
pending，fulfilled，rejected（未决定，履行，拒绝），同一时间只能存在一种状态，且状态一旦改变就不能再变。Promise是一个构造函数，promise对象代表一项有两种可能结果（成功或失败）的任务，它还持有多个回调，出现不同结果时分别发出相应回调。
初始化状态：pending当调用resolve（成功）状态：pending=&gt; fulfilled当调用rejecte（失败）状态：pending=&gt;rejected Promise的优点是解决了回调地狱，缺点是代码并没有因为新方法的出现而减少，反而变得更加复杂，同时理解难度也加大，所以后面出现了async/await的异步解决放案
五.document.write和innerHTML的区别？ document.write是直接写入到页面的内容流，如果在写之前没有调用document.open，浏览器会自动调用open，每次写完关闭之后重新调用该函数，会导致页面全部重绘。
innerHTML则是DOM页面元素的一个属性，代表该元素的html内容。你可以精确到某一个具体的元素来进行更改。如果想修改document的内容，则需要修改document.documentElement.innerElement。innerHTML很多情况下都优于document.write,其原因在于不会导致页面全部重绘。
六.call,apply,bind的区别？ call和apply的功能相同，区别在于传承的方式不一样：
fn.call(obj,arg1,arg2,...)调用一个函数，具有一个指定的this值和分别地提供的参数（参数的列表）fn.apply(obj,[argsArray])调用一个函数，具有一个指定的this值，以及作为一个数组（或类数组对象）提供的参数。 bind和call/apply有一个很重要的区别，一个函数被call/apply的时候，会直接调用，但是bind会创建一个新函数。当这个新函数被调用时，bind()的第一参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数。
七.this的指向哪几种？ 总结起来，this的指向规律有如下几条：
在函数体中，非显式或隐式地简单调用函数时，在严格模式下，函数内的this会被this绑定到undefined上，在非严格模式下则会被绑定到全局对象window/global上。一般使用new方法调用构造函数时，构造函数内的this会被绑定到新创建的对象上。一般通过call/apply/bind方法显示调用函数时，函数体内的this会被绑定到指定参数的对象上。一般通过上下文对象调用函数时，函数体内的this会被绑定到该对象上。在箭头函数中，this的指向是由外层（函数或全局）作用域来决定的。 八.什么是js的闭包？有什么作用 一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。
闭包的用处：
匿名自执行函数结果缓存封装实现类和继承 九.ES6箭头函数的特性 1.更简洁的语法，例如：
只有一个形参就不需要用括号括起来如果函数体只有一行，就不需要放到一个块中如果return语句是函数体内唯一的语句，就不需要return关键字 2.箭头函数没有自己的this，arguments，super
3.箭头函数的this只会从自己的作用域链上一层继承this
十.JS的作用域类型 在JavaScript里面，作用域一共有4种：全局作用域，局部作用域，函数作用域以及eval作用域。
全局作用域：这是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。局部作用域：当使用let或者const声明变量时，这些变量在一对花括号中存在局部作用域，只能够在花括号内部进行访问使用。函数作用域：当进入到一个函数的时候，就会产生一个函数作用域。函数作用域里面所声明的变量只在函数中提供访问使用。eval作用域：当调用eval()函数的时候，就会产生一个eval作用域。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6f015e1ad6f6f4b859a1869a08058f8/" rel="bookmark">
			Servlet入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Servlet介绍
1.1什么是Servlet
1.2Servlet的使用方法
1.3Servlet接口的继承结构
2.Servlet快速入门
2.1创建javaweb项目
2.1.1创建maven工程
2.1.2添加webapp目录
2.2添加依赖
2.3创建servlet实例
2.4配置servlet
2.5设置打包方式
2.6部署web项目 3.servlet的生命周期
3.1什么是servlet的生命周期
3.2servlet生命周期中重要的方法
3.3tomcat服务器内部执行代码的原理
3.4测试servlet的声明周期
1.Servlet介绍 1.1什么是Servlet Servlet是Server Applet的简称，是用Java编写的是运行在 Web 服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。使用 Servlet，可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。
1.2Servlet的使用方法 Servlet技术的核心是Servlet接口，定义了Servlet与Servlet容器之间的契约，Servlet容器将Servlet类载入内存，生成Servlet实例并调用它具体的方法，所以它是所有Servlet类必须直接或者间接实现的一个接口。
1.3Servlet接口的继承结构 Servlet接口：只负责定义Servlet程序的访问规范；
GenericServlet抽象类：实现了Servlet接口，做了很多空实现，并持有一个ServletConfig类的引用，并提供了一些ServletConfig的使用方法；
HttpServlet抽象类：实现了service方法，并实现了请求分发处理；
2.Servlet快速入门 2.1创建javaweb项目 2.1.1创建maven工程 2.1.2添加webapp目录 （1）右击项目，选择Add Frameworks Support
(2)选择Web Application，再点击OK
(3)将web目录拖拽到main目录下，并改名为webapp webapp：静态资源比如 html css js可以定义在web下面
WEB-INF：里面的资源不能直接被外界访问 web.xml 是web项目的核心配置文件
index.jsp：web项目的访问首页，在默认情况我们访问的首页就是index.jsp
2.1.3idea没有此选项问题 但有的新版idea右击项目没有这个，需要自己添加。
然后点击右下角的这个按钮即可
2.2添加依赖 在pom.xml添加依赖
&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; 2.3创建servlet实例 创建一个.java实现Servlet接口
package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6f015e1ad6f6f4b859a1869a08058f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2602844ff3e153c88d29addb0a561cb/" rel="bookmark">
			C&#43;&#43;药房管理系统设计模块代码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		药房管理系统涉及到药品管理、库存管理、销售管理等多个模块。其中类设计如下（使用C++语言）：
1. 药品管理模块——药品类（Drug）的定义：
```cpp
class Drug {
private:
string name;
int quantity;
double price;
public:
Drug(string n, int q, double p) {
name = n;
quantity = q;
price = p;
}
// Getter and setter methods
string getName() {
return name;
}
int getQuantity() {
return quantity;
}
double getPrice() {
return price;
}
void setQuantity(int q) {
quantity = q;
}
};
```
2. 药品库存管理模块的示例代码：
```cpp
class Inventory {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2602844ff3e153c88d29addb0a561cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e3a5723bcab23af23bb7648f6dfbd0/" rel="bookmark">
			Unity 如何获取当前日期的中文星期几
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要获取当前日期是星期几可以使用DateTime下的DayOfWeek方法。
首先我们在脚本中添加System引用：
using System; 然后我们再调用DateTime下的DayOfWeek方法：
DayOfWeek dayOfWeek = DateTime.Now.DayOfWeek; //获取当前是星期几 由于返回的是英文，所以我们还要转化为中文，可以通过Switch语句转化：
public string GetChineseDayOfWeek(DayOfWeek dayOfWeek) { switch (dayOfWeek) { case DayOfWeek.Sunday: return "星期日"; case DayOfWeek.Monday: return "星期一"; case DayOfWeek.Tuesday: return "星期二"; case DayOfWeek.Wednesday: return "星期三"; case DayOfWeek.Thursday: return "星期四"; case DayOfWeek.Friday: return "星期五"; case DayOfWeek.Saturday: return "星期六"; default: return ""; } } 最后调用转化方法：
string chineseDayOfWeek = GetChineseDayOfWeek(dayOfWeek); Debug.Log("今天是" + chineseDayOfWeek); 打印结果：
这就简简单单获得了当前日期是星期几，我们就可以根据需要使用它了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c394be6c87860cf9619564301a944b01/" rel="bookmark">
			k8s集群通过helm部署skywalking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装helm
下载脚本安装
~# curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 ~# chmod 700 get_helm.sh ~# ./get_helm.sh 或者下载包进行安装
~# wget https://get.helm.sh/helm-canary-linux-amd64.tar.gz ~# mv helm /usr/local/bin ~# chmod +x /usr/local/bin/helm 2、安装nfs
### 这里就将 nfs-server 安装在 master 节点 # 安装 nfs-utils、rpcbind 软件包（===所有节点===） yum -y install nfs-utils rpcbind # 创建目录 sudo mkdir -p /data/nfs # 添加权限 sudo chmod 777 -R /data/nfs # 编辑文件，添加以下内容 sudo vim /etc/exports /data/nfs 172.16.10.0/24(rw,no_root_squash,sync) # 重启服务 systemctl start rpcbind &amp;&amp; systemctl enable rpcbind systemctl start nfs &amp;&amp; systemctl enable nfs（所有节点） # 配置生效 exportfs -rv # 查看共享目录 sudo showmount -e 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c394be6c87860cf9619564301a944b01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e43060d2ed406a85234b0cb5934b4da/" rel="bookmark">
			Matlab编程技巧：导入MDF文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 问题引入2 导入MDF文件示例3 将信号导入Simulink4 总结 1 问题引入 在汽车电控开发中，测试标定工程师可以通过CANape将控制器运行时的观测量实时地录制下来，保存成MDF文件。MDF文件中的数据有助于工程师排查控制器的问题，从而优化控制策略。
对于简单的问题，工程师只要看一看MDF文件的数据，就能定位到问题在模型的位置。对于更加复杂的问题，可以将模型的输入信号从MDF文件中摘取出来，导入到模型中进行仿真调试，从而在模型层面复现问题。这个过程，汽车软件工程师称之为数据回灌。
进行数据回灌首先需要将MDF中的数据解析出来，转化为Simulink可以识别的格式。然后通过Simulink中的FromWorkspace导入模型进行仿真。
本文研究通过Matlab脚本解析MDF文件，并转换为Simulink可以识别的输入信号。
2 导入MDF文件示例 1）首先打开Matlab安装路径 C:\Program Files\Polyspace\R2019a\examples\vnt\CANape.MF4 ，从中可以获取Matlab的示例文件CANape.MF4；
2）通过CANape打开该文件，·可以看到其中所有的观测量随时间的变化；
3）对于想要提取的信号，例如PWM，可以右键Proterties打开属性对话框，在Group Information中可以看到它的Group是“10ms”；
这个很重要，在后面解析信号的时候需要先知道它的组；
4）在Matlab中运行以下函数，可以以该文件创建一个mdf对象；
&gt;&gt; m = mdf('CANape.MF4') m = MDF - 属性: File Details Name: 'CANape.MF4' Path: 'E:\Lesson\Blog\Mathworks\Matlab\MDF\CANape.MF4' Author: 'Otmar Schneider' Department: 'PMC @ Vector Informatik GmbH' Project: 'Demo' Subject: 'XCPSim' Comment: 'Example file created with Vector CANape' Version: '4.10' DataSize: 176545 InitialTimestamp: 2016-04-21 14:27:17.000010629 Creator Details ProgramIdentifier: 'MCD14.02' Creator: [1×1 struct] File Contents Attachment: [0×0 struct] ChannelNames: {2×1 cell} ChannelGroup: [1×2 struct] 运行该函数会返回很多关于此MDF文件的信息，其中最后一行表示该MDF文件中有两个ChannelGroup；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e43060d2ed406a85234b0cb5934b4da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63019eaf79932a976a6027bb4318bd98/" rel="bookmark">
			AOSP 源码编译android 12
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、python安装 a. python2安装
b. python3安装
二、repo管理多个git
a.第一步, 新建一个空白文件夹保存repo引导文件,并包含你的路径
b.下载启动器
c.将git-repo中的repo文件复制到 1 创建的.bin目录中
d.修改权限
e. 执行版本检查
三、初始化工程
a.执行创建文件夹命令，创建android12文件夹
b.切换到android12目录下
c.初始化android12
d.同步下载android源代码 j4代表的是4个线程
四、准备编译环境
a. 安装 jdk8
b.安装依赖包
五、下载内核源码
a.与下载AOSP源码类似，需要先建立文件夹 b.使用清华的镜像
c.完成后kernel目录中会生成一个goldfish文件夹，进入goldfish目录并使用git命令
六、交换空间
方法一
方法二
七、编译
a.初始化环境
b. 选择编译目标
c.Which would you like?
一、python安装 a. python2安装 sudo apt-get install python b. python3安装 sudo apt-get install python3
来自谷歌官网Android的警告
警告：对 Python 2 的支持已于 2020 年 1 月 1 日停止，详情请见 Sunsetting Python 2（废弃 Python 2）一文。所有主要的 Linux 发行版都在停止支持 Python 2 软件包。Google 强烈建议您将所有脚本改用 Python 3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63019eaf79932a976a6027bb4318bd98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b70ebb8a8862d390ffccb5895c42d7/" rel="bookmark">
			基于Java&#43;SpringBoot&#43;Vue狗粮销售商城系统设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主介绍：✌全网粉丝30W+,csdn特邀作者、博客专家、CSDN新星计划导师、Java领域优质创作者,博客之星、掘金/华为云/阿里云/InfoQ等平台优质作者、专注于Java技术领域和学生毕业项目实战,高校老师/讲师/同行交流合作✌
主要内容：SpringBoot、Vue、SSM、HLMT、Jsp、PHP、Nodejs、Python、爬虫、数据可视化、小程序、安卓app、大数据、物联网、机器学习等设计与开发。
🍅文末获取源码联系🍅
👇🏻 精彩专栏推荐订阅👇🏻 不然下次找不到哟
2022-2024年最全的计算机软件毕业设计选题大全：1000个热门选题推荐✅
Java项目精品实战案例《100套》
Java微信小程序项目实战《100套》
感兴趣的可以先收藏起来，还有大家在毕设选题，项目以及论文编写等相关问题都可以给我留言咨询，希望帮助更多的人
目录
一、 前言介绍：
二 、功能设计：
2.1 系统功能结构图
2.2 购买狗粮序列图
2.3 修改公告序列图
三、功能实现：
3.1首页用户模块
3.2管理员功能模块 四、库表设计：
六、论文参考：
七、其他案例： 八、推荐项目：
九、源码获取：
一、 前言介绍： 随着科学技术的飞速发展，社会的方方面面、各行各业都在努力与现代的先进技术接轨，通过科技手段来提高自身的优势，狗粮销售信息管理系统当然也不能排除在外。狗粮销售信息管理系统是以实际运用为开发背景，运用软件工程原理和开发方法，采用java技术构建的一个管理系统、论文主要是对狗粮销售信息管理系统进行了详细介绍，研究的现状以及还有涉及的开发背景，然后还对系统的设计目标进行了论述和系统的需求，以及整体系统设计方案实现、对系统的设计以及实现都论述讲解得比较细致，最后对狗粮销售信息管理系统进行了一些具体细节功能测试。
本系统以java为核心开发技术，结合SpringBoot+VUE框架实现了一个狗粮销售信息管理系统。狗粮销售信息管理系统的主要使用者分为管理员、用户、主要包括首页模块、个人中心、用户、商家管理、狗粮商品类型管理、狗粮商品信息、狗粮商品信息管理、以及狗粮商品相关资讯管理等功能。通过这些功能模块的设计、在设计开发的过程中中，充分保证了系统代码的良好良好可读性、操作实用性、代码易扩展性以及通用性等、便于后期的维护以及操作方便等特点。
关键词：狗粮销售系统系统；MySQL；Java；商品；
二 、功能设计： 2.1 系统功能结构图 系统架构图属于系统设计阶段，系统架构图只是这个阶段一个产物，系统的总体架构决定了整个系统的模式，是系统的基础。狗粮销售信息管理系统的整体结构设计如图4-2所示。
序列图是对象之间基于时间顺序的动态交互，它显示出了随着时间的变化对象之间是如何进行通讯的，由于篇幅所限本文只对用户购买狗粮商品以及管理员修改公告俩个用例进行描述。
2.2 购买狗粮序列图 狗粮销售系统的用户购买商品的工作流程如下：
狗粮销售系统用户输入正确的账号和密码进行登录。用户登录成功后进入商城首页，根据条件查找商品信息。用户向购物车中添加商品。用户进入购物车页面进行下单。如果库存足够，用户选择收获地址后提交订单。跳转我的商品订单页面，查看订单，完成购买。 根据基本流程，狗粮销售系统的用户购买商品的序列图如图4.5.1所示。
2.3 修改公告序列图 狗粮销售系统的管理员修改商品公告的工作流程如下：
狗粮销售系统管理员输入正确的账号和密码登录狗粮销售系统。管理员进入修改商品公告界面，并在界面中提交修改的公告信息。界面将公告信息传递到控制对象中。控制对象修改并保存商品公告信息。管理员在界面获得修改成功信息。 根据基本流程，狗粮销售系统的管理员修改商品公告的序列图如图所示。
三、功能实现： 3.1首页用户模块 本狗粮销售系统的前台页面布局采用了上左右的结构。上部为菜单导航栏，主要负责显示本系统的一些主功能；左部为狗粮全部展示以及狗粮的分类展示；右部为显示模块，主要显示使用不同功能后的结果
游客单击“注册”后，需要输入登录名、登录密码、邮箱以及电话。
会员输入用户名和密码后，首先要进行身份验证，如果该会员存在，并且密码正确且账户已经激活则成功登录；否则，根据错误类型提示提示错误信息“用户名不存在”，“密码错误”。并返回登录界面重新输入用户名和密码。
对于本系统的购物流程而言，未注册的游客可以进行狗粮的浏览以及狗粮的按类查询操作，而只有登录的注册会员才可以进行狗粮的购买、购物车的管理、订单的管理以及修改用户信息等操作。会员登录模块需要对用户的账号密码进行校验，如果校验成功则用户才可以拥有购买狗粮，订单管理等功能。否则需要重新输入用户名密码。
本系统的前台狗粮展示主要分为两种模式。第一种，用户可以查看所有的分类。第二种用户可以按照狗粮的类别来进行查询浏览。在这两种模式下用户只需要点击左部分分类的名称便可以进行查询。
购物车模块的设计主要包括：会员将狗粮添加到购物车中，在添加的过程中还可以决定要添加的数量。添加到购物车中后会员还可以调整，可以删除不需要的狗粮甚至一键清除购物车。
会员在确认购买狗粮后会进入支付管理页面，此时已经生成订单，但订单的状态为未付款状态。而当会员点击直接支付时，此时才会将用户填入的送货地址填入数据库中，并且修改订单的状态为已支付。
3.2管理员功能模块 项目启动后、管理员通过填写用户名、密码等信息进行登录验证，输入完成后选择角色登录验证账号密码无误后、即可进入狗粮销售信息管理系统首页，
主要实现步骤：项目启动后、管理员通过填写用户名、密码等信息进行登录验证，输入完成后选择角色登录验证账号密码无误后、即可进入网上超市商品信息管理系统首页，如图5-1所示。关键实现：网上超市商品系统系统，页面设计主要是在首页头部引入common以及jquery等公共的js和css样式布局文件，通过recommend index-pv2 DIV样式设计头部几个菜单栏的显示。用户点击其中一个div触发点击时间、页面就加载框架的布局、调用提前写好的.index-pv1 .animation-box:hover CSS文件等来渲染整个前端页面、用户登录注册，在用户注册页面通过填写账号、密码、姓名、手机、等信息用户注册，注册是用户输入input注册框之后点击确定事件(onsubmit)按钮、提交的时候绑定函数、书写函数(获取用户输入的数据&lt;获取数据时需要在指定位置定义一个id&gt;)、然后对form表单的数据进行判断、进行数据合法(form表单提交)、若数据非法(给出错误提示信息弹窗button，不让表单提交)，如图所示。
图管理员登录界面图
管理员登录进入狗粮销售信息管理系统后、可以查看首页模块、个人中心模块、用户管理、狗粮商品类型管理、狗粮商品信息管理、订单信息管理模块等内容模块进行详细的操作处理，用户点击列表、触发列表后台列表重新操作、代用后台Controller业务处理类进行处理、调用page页面方法、page页面方法重写了Service调用后台数据库执行SQL语句查询、将查询的结果返回给Controller--page方法、最后返回前端页面进行数据渲染实现、从而前端进行显示。如图所示。
图管理员功能界面图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0b70ebb8a8862d390ffccb5895c42d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6532bfd4ea71758fd078fdb7c97aadd/" rel="bookmark">
			双端队列、优先级队列、阻塞队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双端队列、优先级队列、阻塞队列 文章目录 双端队列、优先级队列、阻塞队列1 双端队列1.1 概述1.2 应用实例1.2.1 双端链表实现1.2.2 数组实现1.2.3 测试代码 1.3 课后作业- LeeTCode103 2. 优先级队列2.1 概述2.2 基于无序数组实现2.3 基于有序数组实现2.3 堆实现优先级队列2.4 总结2.5 练习-LeetCode23 合并K个升序链表 3. 阻塞队列3.1 单锁实现3.2 双锁实现 本节也来自于黑马数据结构与算法
1 双端队列 1.1 概述 双端队列、队列、栈对比
定义特点队列一端删除（头）另一端添加（尾）First In First Out栈一端删除和添加（顶）Last In First Out双端队列两端都可以删除、添加优先级队列优先级高者先出队延时队列根据延时时间确定优先级并发非阻塞队列队列空或满时不阻塞并发阻塞队列队列空时删除阻塞、队列满时添加阻塞 注1：
Java 中 LinkedList 即为典型双端队列实现，不过它同时实现了 Queue 接口，也提供了栈的 push pop 等方法 注2：
不同语言，操作双端队列的方法命名有所不同，参见下表
操作JavaJavaScriptC++leetCode 641尾部插入offerLastpushpush_backinsertLast头部插入offerFirstunshiftpush_frontinsertFront尾部移除pollLastpoppop_backdeleteLast头部移除pollFirstshiftpop_frontdeleteFront尾部获取peekLastat(-1)backgetRear头部获取peekFirstat(0)frontgetFront 1.2 应用实例 黑马代码如下
接口定义
package com.atguigu.linkedlist; /** * @author 小小低头哥 * @version 1.0 * 黑马程序接口定义 */ public interface Deque&lt;E&gt;{ //向队列的头部添加元素 boolean offerFirst(E e); //像队列的尾部添加元素 boolean offerLast(E e); //移除第一个元素 E pollFirst(); //移除最后一个元素 E pollLast(); //显示第一个元素 E peekFirst(); //显示最后一个元素 E peekLast(); //是否为空 boolean isEmpty(); //是否为满 boolean isFull(); } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6532bfd4ea71758fd078fdb7c97aadd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf266bd18deb2fa23a7091a62b10b24b/" rel="bookmark">
			【Vue3&#43;TypeScript】快速上手_笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 1. Vue3简介 2020年9月18日，Vue.js发布版3.0版本，代号：One Piece（n
经历了：4800+次提交、40+个RFC、600+次PR、300+贡献者
官方发版地址：Release v3.0.0 One Piece · vuejs/core
截止2023年10月，最新的公开版本为：3.3.4
1.1. 【性能的提升】 打包大小减少41%。
初次渲染快55%, 更新渲染快133%。
内存减少54%。
1.2.【 源码的升级】 使用Proxy代替defineProperty实现响应式。
重写虚拟DOM的实现和Tree-Shaking。
1.3. 【拥抱TypeScript】 Vue3可以更好的支持TypeScript。 1.4. 【新的特性】 Composition API（组合API）：
setup
ref与reactive
computed与watch
…
新的内置组件：
Fragment
Teleport
Suspense
…
其他改变：
新的生命周期钩子
data 选项应始终被声明为一个函数
移除keyCode支持作为 v-on 的修饰符
…
2. 创建Vue3工程 2.1. 【基于 vue-cli 创建】 点击查看官方文档
备注：目前vue-cli已处于维护模式，官方推荐基于 Vite 创建项目。
## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version ## 安装或者升级你的@vue/cli npm install -g @vue/cli ## 执行创建命令 vue create vue_test ## 随后选择3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf266bd18deb2fa23a7091a62b10b24b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1aea3e05c3e701361242d664db47be9/" rel="bookmark">
			Maven : Failure to find jar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Failure to find org.apache.maven.plugins:maven-source-plugin:jar:3.1 in https://repo.maven.apache.org/maven2 was cached in the local repository, resolution will not be reattempted until the update interval of central has elapsed or updates are forced 问题原因： 没有找到对应的jar，但由于本地缓存有相应的jar包，因此不会更新jar。
解决方案： 找到对应的jar，将其从本地仓库中删除，重新update project，由Maven重新拉去jar包。
右击项目，选择Maven，点击Update Project...
使用脚本进行清理：
```cmd
--javascripttypescriptbashsqljsonhtmlcssccppjavarubypythongorustmarkdown
cls @ECHO OFF SET CLEAR_PATH=D: SET CLEAR_DIR=D:\maven-repository(本地仓库路径) color 0a TITLE ClearLastUpdated For Windows GOTO MENU :MENU CLS ECHO. ECHO. * * * * ClearLastUpdated For Windows * * * * ECHO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1aea3e05c3e701361242d664db47be9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ada56ca15e79528e2970524184945c7/" rel="bookmark">
			【教程】从gitee或者github，下载单个文件或文件夹命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.打开git 2.初始化 git init 3.设置允许下载子目录 （不需要修改任何，只要原样复制，需要按照个人状况修改的话我会标注）
git config core.sparseCheckout true 4. 选择要下载的单个文件夹的路径 这里单引号内部需要修改，按照自己想要下载gitee或github的路径
echo '/父文件夹/子文件夹/*' &gt;&gt; .git/info/sparse-checkout 举个栗子： 假如我想要下载web这个目录下的所有文件，我需要这样写：
echo '/web/*' &gt;&gt; .git/info/sparse-checkout 如果是文件同理，就不加路径后面的/*
第一个/代表根目录
5.添加仓库地址目标仓库的地址 git remote add bird 仓库地址 仓库地址需要修改成，gitee或者github的地址，从这里复制
6.下载 不需要修改任何
git pull bird master 7.成功！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7f4368fda9bac522c3579067cbdea2/" rel="bookmark">
			vue data变量不能以“_”开头，否则会产生很多怪异问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 比如给子组件赋值，子组件无法得到这个值（也不是一直无法得到，设置后this.$forceUpdate() 居然可以得到）， 更无法watch到
&lt;zizujian :config="_config1"&gt; &lt;/zizujian&gt; this._config1 = { ..... } this.$forceUpdate() $开头也有问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c9fdb3cc89b94567d4ec1256f9ba8d8/" rel="bookmark">
			软件测试工程师应该如何做职业规划？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近总是听到有测试小伙伴在问，软件测试职业规划的问题，下面的小编就和大家一起探讨一下，顺便说说我的几个建议：
一、学习新技能 随着技术的发展，软件测试领域也在不断地发生变化。因此，软件测试人员应该不断地学习新技能，包括新的测试方法、工具和技术，以适应市场的需求。 比如说：
自动化测试 自动化测试是软件测试领域的一项重要技术，它可以提高测试效率和测试覆盖率。软件测试工程师需要学习自动化测试的原理、工具和技术，掌握至少一种自动化测试工具的使用。
移动应用测试 随着移动应用的普及，移动应用测试成为了软件测试领域的一个热门方向。软件测试工程师需要学习移动应用测试的技术和方法，熟悉各种移动设备和操作系统的特点和差异。
安全测试 安全测试是软件测试中的一个重要方向，它可以帮助企业发现和修复软件中的安全漏洞和缺陷。软件测试工程师需要学习安全测试的知识和技术，了解各种安全测试工具的使用。
数据库测试 数据库是软件系统中的一个重要组成部分，对数据库进行测试可以保证系统的数据完整性和稳定性。软件测试工程师需要学习数据库测试的技术和方法，掌握SQL语言的使用。
敏捷测试 敏捷开发模式已经成为了软件开发领域的主流模式，软件测试工程师需要学习敏捷测试的原理和方法，了解敏捷开发过程中的测试流程和角色分配。
总之，软件测试工程师需要不断学习新的技能和知识，以适应市场的需求，提高自身的竞争力。比如扫下面的二维码了解一下软件测试的热播技术视频：
二、提高自己的技术水平： 软件测试人员应该不断提高自己的技术水平，包括编程技能、测试技能、沟通技能等方面。这样可以更好地应对工作中遇到的各种问题。
学习新技术 软件测试领域的技术在不断发展和更新，软件测试工程师需要不断学习新技术，了解新的测试方法、工具和技术，以适应市场的需求。
参加培训和讲座 软件测试工程师可以参加各种培训和讲座，了解最新的测试技术和趋势，与同行进行交流和互动，提高自己的技术水平。
阅读相关书籍和文章 软件测试领域有很多优秀的书籍和文章，软件测试工程师可以阅读这些书籍和文章，深入了解测试理论和实践，提高自己的技术水平。
参加测试社区 软件测试领域有很多测试社区和论坛，软件测试工程师可以加入这些社区和论坛，与其他测试工程师进行交流和互动，分享测试经验和技术。
实践和总结 软件测试工程师需要不断实践和总结，通过实践来检验自己的测试技术和方法是否可行，通过总结来发现不足和改进的方向，提高自己的技术水平。
总之，软件测试工程师需要保持学习和成长的心态，不断提高自己的技术水平和能力，以适应市场的需求，并为自己的职业发展打下坚实的基础。所以可以扫码看看有没有你自己喜欢的话题：
三、建立良好的职业关系 软件测试人员应该建立良好的职业关系，包括和同事、客户和上司之间的关系。这有助于提高工作效率和工作质量，也有助于自身的职业发展。
好好与同事相处 软件测试工程师在工作中需要与许多人合作，包括开发人员、产品经理、项目经理等。与同事相处要友好、和善，尊重彼此的工作和成果，多沟通，多协作，建立良好的工作关系。
处理好与上级的关系 软件测试工程师需要与上级保持良好的关系，尊重上级的决策和安排，积极配合上级的工作，不断提供意见和建议，建立互信的关系。
维护好客户关系 软件测试工程师需要与客户保持良好的关系，及时回应客户的需求和反馈，提供专业的测试服务和支持，建立长期稳定的客户关系。
参加行业活动 软件测试工程师可以参加各种行业活动，包括技术讲座、研讨会、培训等，与同行进行交流和互动，建立广泛的人脉和社交圈。
建立个人品牌 软件测试工程师可以通过个人博客、微信公众号等方式建立个人品牌，分享测试技术和经验，提高自己的知名度和影响力，从而获得更多的职业机会。
总之，软件测试工程师需要注重与人的沟通和交流，建立良好的职业关系，提高自己的社交能力和影响力，为自己的职业发展打下坚实的基础。
四、设定职业目标 软件测试人员应该设定自己的职业目标，并制定实现目标的计划。这有助于自我激励，也有助于提高自己的职业发展。 以下是一些设定职业目标的建议：
确定长期职业目标 首先，你需要确定自己的长期职业目标，例如成为一名高级测试工程师或质量管理专家。这可以帮助你更好地规划自己的职业发展，并制定相应的计划。
制定短期职业目标 除了长期职业目标外，你还需要制定一些短期职业目标，例如在某个时间内提高测试技能或参加培训课程。这可以帮助你逐步实现长期职业目标。
持续学习和提高技能 作为一名软件测试人员，持续学习和提高技能是非常重要的。你可以参加各种培训课程、研讨会和会议，以及阅读相关的书籍和文章，来不断提高自己的技能水平。
寻找发展机会 你需要密切关注行业动态，了解行业趋势和发展方向，以及寻找适合自己发展的机会。这可以帮助你更好地规划自己的职业发展，并为未来做好准备。
与同行交流 与同行交流是非常重要的，可以帮助你了解行业内的最新动态和技术趋势，还可以建立人脉关系，为自己的职业发展打下基础。
五、参加行业活动 软件测试人员可以参加各种行业活动，包括技术讲座、研讨会、培训等，以了解行业的最新动态和趋势，也可以和同行进行交流和互动。
总之，软件测试人员应该保持学习和成长的心态，不断地提高自己的技能和能力，以适应市场的需求，并为自己的职业发展打下坚实的基础。
总结 如果你对此文有任何疑问，如果你也需要接口项目实战，如果你对软件测试、接口测试、自动化测试、面试经验交流感兴趣欢迎加入我们，加入方式在文章的最后面 自动化测试相关教程推荐： 2023最新自动化测试自学教程新手小白26天入门最详细教程,目前已有300多人通过学习这套教程入职大厂！！_哔哩哔哩_bilibili 2023最新合集Python自动化测试开发框架【全栈/实战/教程】合集精华，学完年薪40W+_哔哩哔哩_bilibili 测试开发相关教程推荐 2023全网最牛，字节测试开发大佬现场教学，从零开始教你成为年薪百万的测试开发工程师_哔哩哔哩_bilibili postman/jmeter/fiddler测试工具类教程推荐 讲的最详细JMeter接口测试/接口自动化测试项目实战合集教程，学jmeter接口测试一套教程就够了！！_哔哩哔哩_bilibili 2023自学fiddler抓包，请一定要看完【如何1天学会fiddler抓包】的全网最详细视频教程！！_哔哩哔哩_bilibili 2023全网封神，B站讲的最详细的Postman接口测试实战教学，小白都能学会_哔哩哔哩_bilibili 总结： 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c9fdb3cc89b94567d4ec1256f9ba8d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36be89f3f79f1111396d15a0f979f5e/" rel="bookmark">
			FPGA时序约束-汇总篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FPGA时序约束理论篇
FPGA时序约束理论篇-时序路径和模型
FPGA时序约束理论篇-Skew讲解
FPGA时序约束实战-I/O口约束
FPGA时序约束实战-时钟周期约束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e6fe858ead50732da52d11d1e107e05/" rel="bookmark">
			阿里同学聊测试开发与测试平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024软件测试面试刷题，这个小程序（永久刷题），靠它快速找到工作了！（刷题APP的天花板）
在一线大厂，没有测试这个岗位，只有测开这个岗位，即使是做业务测试，那么你的title也是测开。
所以想聊一聊测开的看法，但不代表这是正确的看法，仅供参考。
没来阿里之前我对测开的看法 一直以为专职做自动化测试和性能测试是测试这条路的最终归宿，测试开发，只是大厂才可能存在的角色；测试平台，少部分公司才会用到的东西，肯定不会成为主流的。
况且测试平台要会前端还得会后端，你都这么全栈为什么不做开发呢？做UI自动化、接口自动化直接写python脚本不就好了嘛，做性能测试用Jmeter就好了。
在多数人眼中，测试开发就是“开发一个测试平台，就要包揽前后端”，至少我一开始也是这样认为的。
前端要会、后端也要会，测试也得会，感觉就是全能的啊！
来了阿里之后，对测开看法有了转变：测开才是做测试这条路的最终归宿，其实不只是测试，包括运维，最终肯定是运维开发，而不是自动化运维（抛开管理层而言）。
只有开发测试平台才是测开的最终选择吗？不，不是的！
但做出一个平台是最容易体现你身为测开的价值，毕竟你前后端都啃了，能跟开发同学一样弄一个完整的平台了，晋升那不是妥妥的，现在大部分同学都很敬佩有开源测试平台经验的人。
包括在阿里，其实之前就有很多人聊过，如果你平时搬砖没有做一些技术活，那你的晋升之路肯定没有做纯技术的同学顺利，因为晋升答辩你可以短时间展示你的技术能力，但是没有办法短时间展示你的业务能力或者其他软实力。
阿里测开 其实是分部门的，如果是业务部门，那一般就是业务测试，点点点也不例外，当然你可以自己决定是否开发一些工具、脚本来辅助测试。如果是基础建设部门，那可能就是开发平台，或者是一些通用型工具。
像我们部门的话，很推崇技术解决问题，所以很多时候会用自动化去解决一些痛点，所以也有很多锻炼的机会等着我……
测试平台的好处和不足 好处
1、接口测试、UI自动化测试、性能测试均可通过点击页面解决，因此可以降低做自动化测试、性能测试的门槛，提高测试效率、测试广度。
2、平台有页面，页面友好能提高人干活的积极性，小白或者新同学见到也愿意去做和学习，也就提高了个人的主观能动性。
3、使用平台代表团队共享、数据共享、项目共享，基础弱的同学可以看到大神同学写的东西，这就可以提高团队的分享氛围，促进不同技术能力的同学互相学习，当然前提要肯去学。
4、数据共享意味着一切皆可溯源，比如有人删库跑路、删数据跑路，那对应的操作人记录肯定能看到，可以提高项目的稳定性。
5、数据私有化，这个私有化指的是，项目所有数据都可以保存在自己公司服务器 ，提高项目的安全性，不过大部分开源项目应该都支持私有化部署。
6、做出测试平台的同学更容易得到团队中的认可，能提高个人的影响力和晋升成功率。
还有其它好处，就不一一列举了。
不足
其实有些好处就是不足，比如：
1、降低了高阶测试的门槛，所以会让测试同学的技术能力更加两极分化，做技术的可能会越做越好，但本身没有代码能力的测试同学可能只能通过平台来做接口测试、自动化测试，缺少了自己独立锻炼实战的机会。
2、测试平台化是趋势，所以未来一定会有更多的企业效仿大厂招测试开发，那转行做测试的门槛也会更加高，未来可能会像面开发一样面测试（大厂已经是了）。
不过这个应该是算优势也算劣势吧，提高测试的竞争力可以提高测试的地位，只不过会淘汰很多只会手工测试不愿学习代码的同学。
3、做测试平台，不仅需要有很强的测试能力，因为你都不了解测试需要什么，怎么开发出一个好的平台呢？
然后还得需要有前后端的知识，可能还得加上运维知识，所以你得会很多东西，这就变成做测试平台的门槛反而很高，以至于有些开发同学来转行做测开。
4、做成一个可用性、稳定性、易用性都很好的测试平台，所需要的时间成本、人力成本是巨大的，因为这相当于开发一个完整的新项目，所以它的生命周期会很长，如何说服你的老板同意去做是一个问题，这就不仅需要你的技术能力能说服老板，更需要老板有魄力支持你。
假设你的技术能力low一点，那么它可能就无法在多个团队中展开使用，这样会导致投入产出比非常低，即使用起来，可能后期维护成本也很高……
这样来看其实平台也有很多不足。
我对测试平台的看法 它会是趋势，但它很难每个公司都能独立完成一个测试平台。前面有说过，完成测试平台所需要的能力五花八门，所以当你会这么多技能的时候，你可能就想要很高的薪资，但从国内对测试的态度来看，它的工资肯定会比开发低一层（大厂无视），这就变成一个恶性循环，公司想要低成本劳动力干测开的活，你作为测开想要拿到更高的薪资。
所以网上有很多开源的测试平台，一般没能力开发平台的公司就会私有化部署，然后再定制化二次开发，这也是一种趋势，应该不存在销售测试平台的情况，毕竟开源的都挺好看挺好用的。
测试平台很难做到适配所有项目，包括在阿里其实测试平台特别多，自动化、性能、兼容、云真机，但我所在的部门一个都没用上，原因有很多种，就不细说了。
问题汇总 测试平台是测开必需品吗？
我认为不是的，测试平台虽然很能体现测开的能力，但不是唯一方式。
实际项目中用不到测试平台，有必要学习吗？
只要是对自己成长有帮助的，其实都应该学习，只不过有优先级而已。假设未来你想走测开路线，那么学习如何开发测试平台也未尝不可，当然不影响当前工作前提下。
做测试平台的前提 对个人而言
有一个测试平台项目经历，可以提高面试通过率和自己的技术能力。
对团队而言
应该是质量效能部，或者基础建设部来主导，而不是业务测试部门来主导，这应该是一个专职工作，而不是闲下来的时候弄一弄。
另外要确保得到老板的支持，充分调研测试平台的可行性，比如团队组成、技术选型、可承受的损失范围、平台使用的部门等等。
测开都有哪些职责 我的主管跟我聊过，测开并不一定要做测试平台才算测开，一个合格的测开，应该是对自己项目上用到的编程语言很熟悉，如同开发一样熟，甚至要比他们还熟悉。
作为测开，可以给开发同学进行code review，特别是有新开发同学刚入职可能对业务、代码架构不熟悉，写的代码就会乱七八糟，这个时候假如你很熟悉整套代码，很熟悉这个编程语言，那么你就可以提出优化建议。
不要说不可能，我主管就可以，比开发还熟悉编程语言，另外还可以写单元测试，我们的服务端单元测试覆盖率是70%左右，所以基本服务端没啥Bug。
测试开发可以是开发平台，也可以是开发工具，亦可以是编写脚本，但都有一个最终目的，使用你的开发技能来提高测试效率、测试广度、深度，用更高的测试覆盖率来保障项目质量。
开发工具，可以是二次开发开源框架，比如RF，可以是二次开发测试工具，比如Jmeter。二次开发的前提不是为了秀你的技术，而是当前的工具/框架满足不了你的测试场景，所以你要二次开发，以此来满足。
像我项目中，因为有自研的rpc框架，所以需要二次开发Jmeter的取样器，才能正常测试。
至于到底要不要开发测试平台，这个只能看自己团队了~
总结 虽然市场上，很多测试开发工程师，没有这里提到的各种水平，但是他们有一个特点，会测试懂开发，代码基础特别扎实。我强烈建议你按着这个学习路线进行学习，坚持学习，尽量到达测试开发的目标，如果达不到，你也会接近这个目标，相信自己，持续学习，坚持下去，不轻易放弃。
行动吧，在路上总比一直观望的要好，未来的你肯定会感谢现在拼搏的自己！如果想学习提升找不到资料，没人答疑解惑时，请及时加入群： 786229024，里面有各种测试开发资料和技术可以一起交流哦。
最后： 下方这份完整的软件测试视频教程已经整理上传完成，需要的朋友们可以自行领取 【保证100%免费】
软件测试面试文档 我们学习必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有字节大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29784d17178822dcaa3ac420c14ad345/" rel="bookmark">
			服务器的出口IP地址查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在服务器中，IP地址是至关重要的。但是很多情况下我们看见的IP地址多数为内网IP。比如192.168.X.X。这些都是内网IP，也就是脱离了内网环境我们就无法再访问这些IP地址。
工作中，我们常常会接触到IP白名单；使用云服务器时需要配置安全组。这些都需要我们去配置指定的IP，但是如果我们配置的是非同一个子网的内网IP时，则会发现怎么配都不起作用。原因就是当跨网络做安全组配置或IP白名单时，必须采用真实的公网IP才行。但是家用网络一般公网IP你是不知道的，如果想知道也可以，在百度上直接输入IP即可。本文主要介绍如何知道1台服务器的公网IP（或者叫网络出口IP）。也很简单，通过下边命令即可：
curl ifconfig.me 此命令适用于任何系统，家用电脑也可以通过WIN+R打开命令行窗口执行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af147ccf8a9bac29e451814f1383769/" rel="bookmark">
			微机原理与接口技术——8254定时器/计时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、 掌握8254定时器/计数器的基本结构1、控制寄存器2、计数器（16位）3、8254端口地址 二、8254的工作方式方式2——分频器方式3——方波发生器工作方式比较 三、例题四、8254在PC机上应用五、8254初始化编程例子BCD码计数二进制计数 一、 掌握8254定时器/计数器的基本结构 1、控制寄存器 初始化编程时，由CPU写入控制字，以决定计数器的工作方式，设置读出命令。此寄存器只能写入不能读出。
2、计数器（16位） 8254有3个独立的计数器，每个计数器结构完全相同。
每个计数器对外有3个引脚：
GATE为门控信号输入端CLK为计数脉冲输入端OUT为输出信号信号端
3、8254端口地址 A1A0=00,选中0#计数器；
A1A0=01,选中1#计数器；
A1A0=10,选中2#计数器；
A1A0=11,选中控制寄存器；
二、8254的工作方式 掌握具有初值自动给重装功能的方式2、方式3，包括计数过程、波形、周期和启动方式
方式2——分频器 计数过程：若GATE为高电平，程序员写入新的计数初值，不会影响正在进行的减一技术过程，只有计数器减到1之后，计数器才装入新的计数初值，并且按照新的计数初值开始计数。波形：比例 1：N-1
启动方式：软件启动 方式3——方波发生器 计数过程：当计数初值为偶数时，每来一个CLK脉冲，计数值减2，当计数值减到0时输出端改变极性，内部完成初值自动填装，继续计数。
波形比例为：N/2:N/2 即为（1：1）
启动方式：软件启动
工作方式比较 三、例题 答案:8ms,8ms
四、8254在PC机上应用 五、8254初始化编程 例子 这里没有指明是按照BCD，还是二进制，一般化会指明。
BCD码计数 MOV AL,1010 0111H OUT 43H,AL MOV AL,40H OUT 42H,AL 因为这是BCD码计数，所有初值为2000H（直接加在后面H即可），在D5D4位时，我采用10，即为只写高八位，低八位置零。
二进制计数 MOV AL,1011 0110H OUT 43H,AL MOV AX,2000 OUT 42H,AL MOV AL,AH OUT 42H,AL 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7094734dc0cc5127451168a1bada4ad/" rel="bookmark">
			微短剧，会成为长视频的“救命稻草”吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		职场社畜秒变霸道总裁，普通女孩穿越成为艳丽皇妃.......这样“狗血”的微短剧，最近不仅在国内各大视频平台上异常火爆，而且还直接火出了国外。
所谓微短剧，就是单集时长从几十秒到十几分钟的剧集，有着相对明确的主题和主线、较为连续和完整的故事情节。今年，仅有三集的《逃出大英博物馆》火爆出圈。这部只有17分钟的短剧，在抖音上累计播放量超过4亿。
微短剧强劲的吸金能力，更是吸引大量的创业者、影视机构、长视频平台以及各类资本。数据显示，微短剧《无双》播出仅8天，投放收入超1亿元。
低成本、周期短、回报高，很多人把短剧称为“2023年最赚钱赛道”。不过，也有人认为它内容粗制滥制，不过是昙花一现的伪风口。
不管是否是伪风口，优酷、爱奇艺、腾讯视频等长视频平台早已不同程度地布局微短剧。对于“家家有本难念的经”的平台来说，微短剧会是救命稻草吗？
短剧为何火了？
微短剧，并不是什么新鲜事物。
早在2013年，优酷跟万合天宜合作出品的《万万没想到》，就是一部较为成功的短剧。只不过，当时的短剧还是以单元剧模式为主，没有连贯的剧情，主要靠段子和演技吸引观众。并且，当时没有如今火爆的短视频平台，微短剧仅在部分年轻观众中产生热度。
随着用户注意力不断分散，碎片化时间变多，短视频平台开始占据用户更多的时间，同时微短剧也开始迎来春天。
眼下的微短剧，大致可以分为两大类，一类是大家熟悉的竖屏短剧，单集成本往往不超过万元，这些成本通常不在内容制作上，而在流量投放上，因此内容大多比较粗糙、低质。
另一类在优酷、爱奇艺、腾讯视频等长视频平台上播放，一集时长通常在10-20分钟，制作成本和周期相对较长。
不管是哪一类微短剧，它们都有一个共同的特点：
爽。
头部的微短剧，基本都是甜宠、霸总、穿越、逆袭、悬疑等题材，比如优酷的《锁爱三生》、爱奇艺的《风月变》、腾讯视频的《招惹》，抖音的《逃出大英博物馆》、快手的《我回到十七岁的理由》等等。本身这些剧情就吸引人，再加上时间短、节奏快、反转不断，很多人看微短剧就是为了解压或者当做“电子榨菜”解闷。而且，微短剧总是会在高潮点上戛然而止，吸引观众继续往后观看，跟很多人看爽文是一样的体验。
虽然有相当部分人对微短剧不屑一顾，但今年它实实在在地火了。德塔文发布的《2023年上半年微短剧市场报告》显示，2023年上半年共上新微短剧481部，创下历史新高，跟2022年全年上新454部的数据相比明显呈井喷态势。
企查查统计显示，截止今年10月底，年内新增注册短剧企业数量为1.98万家，超过去年全年的1.87万家，占全国短剧企业总量的24.5%。
既然微短剧并不是新鲜事物，为何今年火了？事实上，没有无缘无故的横空出世，今年微短剧突然爆火的核心原因在于：
有利可图。
在不确定性因素仍较多的经济形势下，资本追求的首要因素是稳定性和安全性。投资微短剧，不仅安全稳定，还能给资本带来客观的回报。
因为微短剧的单集时长短，内容质量要求不高，因此制作成本相对较低。有的微短剧一集剧1分钟，拍摄成本只需要5000元。
尽管投入少，但是见效快而且明显。目前，微短剧盈利方式主要包括流量分账、平台采买、品牌定制、广告及电商带货等。数据显示，微短剧行业的月充值金额，已经从今年6月的4000万元增长至10月的6000万元。澎湃新闻曾报道，在微短剧行业里，整体付费收入超过千万甚至达到上亿元并不罕见。
由此，微短剧吸引了各路资本进场，进一步推动了整个市场的增长。艾媒咨询《2023-2024年中国微短剧市场研究报告》显示，2023年中国网络微短剧市场规模为373.9亿元，同比增长267.65%，2027年中国网络微短剧市场规模将超1000亿元。
在涌入微短剧赛场的选手中，长视频平台的动作尤为惹人注意。
理想饱满，现实骨感
长视频平台布局微短剧，既是主动出击，也是无奈之举。
如今来看，几个长视频平台早已在微短剧上纷纷行动——优酷设立“小剧场”，通过批量生产短剧抢占市场注意力；爱奇艺设立“竖屏控剧场”，以标签化栏目的运营方式推广短剧；腾讯视频上线“十分剧场”，并在站内首页设置“短剧”频道。
跟抖音、快手等短视频平台相比，“优爱腾”等长视频平台更加关注的是微短剧付费转化，商业化的意图更加明显，而短视频平台更在意的是流量。
这也是形势所逼。
持续盈利，一直是长视频平台的梦魇，也是一道始终解不开的难题。
此前，爱奇艺已经连续亏损十多年。今年第三季度，爱奇艺归母净利润为4.76亿元，去年同期净亏损为3.96亿元，虽然看似扭亏为盈，但这是爱奇艺通过裁员、裁撤业务线、缩减腰部剧集投入等方式，压缩运营和内容等成本后实现的。
同样，优酷、腾讯视频也常年处于亏损。有媒体报道，三家长视频平台十年烧光1000多亿，但依然没看到持续盈利的曙光。
拓展收入渠道，成为长视频平台必须突围的方向。微短剧，成为一个似乎拥有更多可能性的选择。毕竟，内容制作是长视频平台的优势，而且在精品化上更占优势。
不过，内容高质并不意味着流量就会走高。今年一季度，抖音、快手播放量最高的短剧《二十九》和《临夜传》，分别达到7.9亿和5.17亿，同期优酷、腾讯视频和爱奇艺的短剧的流量却没有一部破亿。
另外在商业化上，相比短视频平台，长视频平台的表现也不如人意。
微短剧的会员付费模式，跟付费小说模式十分接近，即把大量信息流投放到短视频平台，然后引导用户到小程序为短剧付费。这在短视频平台上较为普遍，但对于更为抵触广告的长视频观众来说难以接受。
广告变现和电商带货方面，在短视频平台上的变现效率更高。有品牌广告方表示，短视频平台已经成为其最大销售渠道，长视频平台对销量影响非常有限。
虽然试水较早、内容优质，但总体上看大多数长视频平台的微短剧并没有形成规模化和商业化。更深入地看，原因在于两方面：
人和钱。
“人”的方面，根据今年3月发布的《中国网络视听发展研究报告》，最近半年内，我国超10亿的短视频用户中有50.4%看过3分钟以内的微短剧。也就是说，短视频用户跟微短剧用户的重合度非常高。
反观长视频平台，其用户跟微短剧用户的重合度并不高，平台内观看短剧的氛围也不浓厚。这也在情理之中，相当一部分长视频用户每月花几十元的会员费，目的是为了享受更优质的内容，而不是观看几分钟的爽剧。
“钱”的方面，要让一个内容形态持续跑下去，必须要让创作者、品牌方、平台方等多方赚到钱才行。然而，长视频平台的商业模式相对比较单一，不像短视频平台在直播带货、广告植入、品牌定制等方面更为成熟。让各方赚钱的商业模式一旦跑不通，内容生态就会停滞不前。
如今来看，长视频平台布局微短剧的理想很丰满，但现实很骨感。
赌局与变局
面对未来，长视频平台布局微短剧，依然充满各种不确定性，宛如充满变数的赌局。
首先，微短剧能火是小概率事件，并不是人人都能押中爆款。
每当一个行业出现造富事件时，总是容易被神话。如今的微短剧行业，仿佛成为一个处处是黄金的造富场，随便推出一个作品就能赚钱。
事实上，当下的微短剧行业被夸大化了，很多人只看到几部爆火的顶流作品，却没看到那些还没面世就被枪毙或者面世后依然不为人知的作品，这样的作品占绝大数。
九州文化曾表示，公司每月推出50到60部短剧，每部成本20到30万，其中七成能保本，爆款率10%到15%，扑街率30%，还有10%为纯亏损。
这就意味着，微短剧行业里还是遵循着内容产业的“二八定律”，大部分作品都是炮灰，能火的是极少数。
未来，出爆款的难度将会越来越大。因为微短剧赛道涌入了大量玩家，但大部分都为了迎合市场，集中推出单一的、受欢迎的类型剧。云合《2023年H1全网微短剧正片有效播放·霸屏榜》显示，上半年正片有效播放TOP20的微短剧几乎都是甜宠类型。
当大部分机构都在打造同样类型的剧集时，出爆款的概率就更低了。
对于长视频平台来说，打造爆款的不确定性更大。本身，微短剧的创作思路和长剧不同，对“爽点”的把握、情节的处理、节奏的推进、反转的精彩程度都有很高要求。并且，现在是一个人人都是创作者的时代，长视频平台的对手不仅是各大影视机构，还是人手一部手机的普通用户。
相对难出爆款，监管风险或许是更大的隐忧。
《南方周末》曾评价市面上很大一部分微短剧，带有浓烈的 " 三俗 " 特征：庸俗、低俗、媚俗。由于创作门槛较低，部分微短剧不免落入俗套，甚至涉嫌色情、暴力、不良价值观等违规内容。
国家已经在监管层面出手整治，抖音、快手等平台也先后公布微短剧治理公告。对于违规短剧，可能面临下架和封禁等处罚。长视频反而因为在内容上严格把控，下架的风险更小。
当然了，对于长视频平台来说，微短剧并非没有机会，只是在打造微短剧的过程中，首要的不是追求爆款，而是降本增效。毕竟，流水不争先，争的是滔滔不绝。各家平台日子都不好过，腰包都不丰厚，首先要能够控制成本，同时提升爆款的命中率，形成可持续的动力。
布局AI，或许是降本增效的正确选择。优酷、爱奇艺、腾讯视频都已经表示，要将AIGC技术应用于内容创作。事实上，AI的确能够降低长视频平台的制作和宣发成本，同时在内容创作、市场偏好分析等方面提高效率。
走过十几年之后，长视频平台已经到了较为严峻的时刻。行业天花板肉眼可见，盈利压力依然沉重，寻找破局之路和挖掘新增量是必然选择。
微短剧的火热，给了长视频新的突围思路。不过，面对来势汹汹的短视频平台，以及较低的爆款概率和较高的监管风险，长视频平台依然需要闯出新的破局路径。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fab11f7813e55f2a64e7f5eed210fd0/" rel="bookmark">
			压力测试过程中数据库连接池不释放情况如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库连接池不释放可能会导致以下问题：
1. 数据库连接数不足：如果数据库连接池不释放连接，那么可用的数据库连接数会被逐渐减少，导致应用程序无法正常访问数据库，产生错误或者性能下降。
2. 内存泄漏：如果数据库连接池不释放连接，那么这些连接所占用的内存也不会被释放，可能会导致内存泄漏的问题。
3. 性能下降：如果数据库连接池不释放连接，那么数据库服务器的负载会逐渐增加，导致数据库性能下降。
如果发现数据库连接池不释放连接，可以尝试以下方法来解决：
1. 检查代码：检查应用程序中是否有不正确地使用数据库连接的情况，比如没有正确地关闭连接或者没有释放连接池。
2. 调整连接池参数：可以尝试调整连接池的参数，比如增加连接池的大小、减少连接的超时时间等，来减少连接池中连接的占用时间。
3. 优化数据库服务器：可以尝试优化数据库服务器的性能，比如增加数据库服务器的资源、优化数据库服务器的配置等，来提高数据库服务器的处理能力。
4. 使用连接池监控工具：可以使用连接池监控工具来监控连接池的使用情况，比如连接的创建、使用、释放等，以便更好地了解连接池的使用情况，从而找到问题所在。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdcf6f4d5218ddcc927fd15ccb846862/" rel="bookmark">
			〖Python网络爬虫实战㊹〗- JavaScript Hook 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 订阅：新手可以订阅我的其他专栏。免费阶段订阅量1000+ python项目实战
Python编程基础教程系列（零基础小白搬砖逆袭)
说明：本专栏持续更新中，订阅本专栏前必读关于专栏〖Python网络爬虫实战〗转为付费专栏的订阅说明作者：爱吃饼干的小白鼠。Python领域优质创作者，2022年度博客新星top100入围，荣获多家平台专家称号。 最近更新 〖Python网络爬虫实战㊸〗- 极验滑块介绍（五）
在 JavaScript 逆向的时候，我们经常需要追踪某些方法的堆栈调用情况。但在很多情况下，一些 JavaScript 的变量或者方法名经过混淆之后是非常难以捕捉的。仅仅凭借这些技巧还不足以应对多数 JavaScript 逆向。
本节我们来介绍一个比较常用的 JavaScript 逆向技巧 —— Hook 技术。
Hook 技术 Hook 英文翻译过来就是「钩子」的意思，那我们在什么时候使用这个「钩子」呢？
Hook 技术是一种在软件开发中改变或扩展程序行为的方法。它允许开发人员在程序执行过程中插入自定义代码，以便捕获特定事件或修改程序的行为。通过使用 Hook 技术，开发人员可以在不修改源代码的情况下对程序进行修改或扩展。
在软件开发中，Hook 技术在很多领域都有应用。例如，操作系统可以使用 Hook 技术来监视和控制应用程序的行为。在图形用户界面开发中，Hook 技术可以用于捕获和处理用户输入事件。在网络安全领域，Hook 技术可以用于检测和防止恶意软件行为。
Hook 技术通常涉及使用钩子函数（hook function）来截获和处理特定事件。钩子函数是在特定事件发生时被调用的自定义函数。通过注册钩子函数，并将其与目标事件相关联，可以在目标事件发生时执行自定义代码。钩子函数可以用来处理事件、修改参数、拦截和修改返回值等。
总而言之，Hook 技术是一种强大的工具，可以用于改变和扩展程序的行为。它提供了一种灵活和可扩展的方式来定制和增强软件功能。
Hook的常用手段 「动态代理」：通过动态代理技术，可以在运行时替换原始对象的行为，实现对方法的拦截和修改。「Xposed框架」：Xposed框架是一种基于Android系统的插件化框架，可以通过它来实现对系统和应用的Hook，包括修改方法、替换资源等操作。「Substrate框架」：Substrate框架也是一种用于Android系统的Hook框架，可以实现对方法的替换、资源的修改等操作。「JNI Hook」：通过JNI技术，可以在底层对方法进行Hook，实现对系统和应用的修改和扩展。「Instrumentation」：Android提供了Instrumentation机制，可以通过它来对应用的Activity、Service等组件进行Hook，实现对应用行为的监控和修改。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a976b6ec1a808e79c9ad5305f0166e83/" rel="bookmark">
			Java的maven
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.概念： 是一款用于管理和构建java项目的工具
作用:
方便项目的依赖管理
统一项目的结构,方便程序员开发及维护
提供了一套标准的项目构建流程,方便编译和构建
二.仓库类型: 本地仓库=&gt;自己计算机上的一个目录
中央仓库=&gt;由Maven团队维护的全球唯一的。仓库地址：https://repo1.maven.org/maven2/
私服=&gt;一般由公司团队搭建的私有仓库
目录结构:
三.依赖传递 概念: 坐标具有传递性
直接依赖：在当前项目中通过依赖配置建立的依赖关系
间接依赖：依赖的资源如果依赖其他资源，当前项目间接依赖其他资源
-排除依赖:
&lt;exclusions&gt;
&lt;exclusion&gt;
&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;/exclusion&gt;
&lt;/exclusions&gt;
依赖范围 scope
test测试有效,源码,和运行及打包时无效
compile测试,编译,运行都有效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac70596955ece14cee279bf923cccfa/" rel="bookmark">
			linux 内核死锁检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lockdep是内核提供协助发现死锁问题的功能。
本文首先介绍何为lockdep，然后如何在内核使能lockdep，并简单分析内核lockdep相关代码。
最后构造不同死锁用例，并分析如何根据lockdep输出发现问题根源。
Lockdep介绍 死锁是指两个或多个进程因争夺资源而造成的互相等待的现象。
常见的死锁有如下两种：
递归死锁：中断等延迟操作中使用了锁，和外面的锁构成了递归死锁。
AB-BA死锁：多个锁因处理不当而引发死锁，多个内核路径上的所处理顺序不一致也会导致死锁。
Linux内核提供死锁调试模块Lockdep，跟踪每个锁的自身状态和各个锁之间的依赖关系，经过一系列的验证规则来确保锁之间依赖关系是正确的。
使能Lockdep Lockdep检测的锁包括spinlock、rwlock、mutex、rwsem的死锁，锁的错误释放，原子操作中睡眠等错误行为。
在内核中配置路径为：Kernel hacking-&gt;Lock Debugging (spinlocks, mutexes, etc...)。
下面是lockcep内核选项及其解释：
CONFIG_DEBUG_RT_MUTEXES=y
检测rt mutex的死锁，并自动报告死锁现场信息。
CONFIG_DEBUG_SPINLOCK=y
检测spinlock的未初始化使用等问题。配合NMI watchdog使用，能发现spinlock死锁。
CONFIG_DEBUG_MUTEXES=y
检测并报告mutex错误
CONFIG_DEBUG_WW_MUTEX_SLOWPATH=y
检测wait/wound类型mutex的slowpath测试。
CONFIG_DEBUG_LOCK_ALLOC=y
检测使用中的锁(spinlock/rwlock/mutex/rwsem)被释放，或者使用中的锁被重新初始化，或者在进程退出时持有锁。
CONFIG_PROVE_LOCKING=y
使内核能在死锁发生前报告死锁详细信息。参见/proc/lockdep_chains。
Lock相关内核节点 /proc/sys/kernel/lock_stat------------------------置位则可以查看/proc/lock_stat统计信息，清楚则关闭lockdep统计信息。
/proc/sys/kernel/max_lock_depth--------------
/proc/sys/kernel/prove_locking
/proc/locks
/proc/lock_stat-------------------------------------关于锁的使用统计信息
/proc/lockdep---------------------------------------存在依赖关系的锁
/proc/lockdep_stats------------------------------存在依赖关系锁的统计信息
/proc/lockdep_chains----------------------------依赖关系锁链表
内核还提供了了Tracepoint协助发现锁的使用问题：/sys/kernel/debug/tracing/events/lock。
测试spin_lock死锁
构造测试用例代码如下：
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/spinlock.h&gt;
static DEFINE_SPINLOCK(hack_spinA);
static DEFINE_SPINLOCK(hack_spinB);
void hack_spinAB(void)
{
printk("hack_lockdep: A-&gt;B\n");
spin_lock(&amp;hack_spinA);
spin_lock(&amp;hack_spinB);
}
void hack_spinBA(void)
{
printk("hack_lockdep: B-&gt;A\n");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac70596955ece14cee279bf923cccfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f4cbb14d0975632f7cc06480c3221a/" rel="bookmark">
			压力测试中出现数据库死锁的情况如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压力测试中数据库死锁产生的原因有很多，以下是一些可能的原因：
1. 数据库连接池不够用：在压力测试中，大量的用户请求可能导致数据库连接池被占满，从而产生死锁。
2. 数据库连接数占满：过多的连接数可能导致数据库连接数达到上限，进而产生死锁。
3. 数据库日志中搜索block，能搜到block的话就是存在数据库死锁，找到日志，查看对应的sql，优化造成死锁的sql。
4. 网络带宽不够：在压力测试中，如果单位时间内传递的数据包过大，超过了带宽的传输能力，那么就会造成网络资源竞争，间接导致服务端接收到的请求数达不到服务端的处理能力上限。
5. 硬件资源限制：CPU、内存、磁盘等方面的性能瓶颈也可能导致数据库死锁。
6. 业务逻辑复杂度：业务解耦度较低，较为复杂，整个事务处理线被拉长导致的问题。
解决数据库死锁的方法包括：
1. 调整数据库连接池的大小，以适应更多的连接请求。
2. 优化SQL语句，避免死锁的产生。
3. 增加网络带宽，以提高数据传输能力。
4. 优化硬件资源的使用，提高CPU、内存、磁盘等方面的性能。
5. 简化业务逻辑，降低事务处理线的复杂度。
数据库连接数占满和数据库连接池不够用都是由于数据库连接资源不足导致的，但它们之间存在一些区别：
数据库连接数占满：当应用程序的数量或者每个应用程序的数据库连接数超过了数据库服务器允许的最大连接数时，就会发生数据库连接数占满的情况。这种情况下，新的数据库连接无法建立，会导致应用程序无法正常访问数据库，产生错误或者性能下降。
数据库连接池不够用：数据库连接池是一种管理数据库连接的技术，它可以有效地减少数据库连接的建立和关闭时间，提高应用程序的性能。但是，当数据库连接池中的连接数无法满足应用程序的访问需求时，就会发生数据库连接池不够用的情况。这种情况下，虽然数据库连接池可以快速地分配空闲连接，但是由于连接数的限制，仍然无法满足大量的访问需求。
总的来说，数据库连接数占满是一种紧急情况，需要立即解决；而数据库连接池不够用则是一种常见的性能问题，需要通过优化数据库连接池的配置、增加数据库服务器资源或者优化应用程序的访问方式来解决。
查看数据库的连接数
SELECT COUNT(*) FROM v$session WHERE username = 'TEST';
查看数据库最大连接数
SELECT value FROM v$parameter WHERE name = 'sessions';
需要注意的是，这些命令只能查看当前数据库服务器上的最大连接数，而不是整个数据库集群的最大连接数。如果你使用的是分布式数据库或者集群，需要在每个数据库服务器上分别执行这些命令，并将结果相加，才能得到整个数据库集群的最大连接数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da149ad621101ad2b6a9fc4eb767e697/" rel="bookmark">
			Linux可执行文件动态库依赖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可执行文件动态库依赖 在执行程序时，经常遇到
./LinuxApp.exe: error while loading shared libraries: libmodbus.so.5: cannot open shared object file: No such file or directory
查看系统的共享库缓存，以确定库的安装路径
ldconfig -p
查看当前的库文件的查找路径
echo $LD_LIBRARY_PATH
如果有动态库，可以把库文件放入
/usr/lib
或者
/usr/local/lib
也可以放入指定目录下，然后在环境变量LD_LIBRARY_PATH中加入指定目录
在构建可执行文件时，你可以使用 -rpath 或 -rpath-link 选项指定运行时搜索库的路径。这可以在链接阶段通过 CMake 或手动编写构建脚本来完成。
set(CMAKE_INSTALL_RPATH "/path/to/directory")
请注意，使用 rpath 或 LD_LIBRARY_PATH 等方法可能会导致系统在不同环境中运行时出现问题。确保你的解决方案适用于特定的使用场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2381074cac8aaef26010f3b38a06de4c/" rel="bookmark">
			Linux分割合并文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux分割合并文件 在Linux系统上，你可以使用split命令将大文件分割成多个小文件。以下是将 demo.tar.gz 分割成大小小于 50M 的文件的步骤：
1. 查看文件大小 首先，你可以使用 du 命令查看 demo.tar.gz 文件的大小，以确保其大小是 300M：
du -h demo.tar.gz 2. 使用 split 命令分割文件 接下来，使用 split 命令分割文件。split 命令通常用于将文件分割成指定大小的块。在这里，我们将文件分割成大小小于 50M 的块：
split -b 50M demo.tar.gz demo_part_ -b 50M: 指定每个分割块的大小为 50M。demo.tar.gz: 要分割的原始文件。demo_part_: 分割后的文件名前缀。 3. 查看分割后的文件 运行上述命令后，你将在当前目录下看到多个文件，类似于 demo_part_aa, demo_part_ab, demo_part_ac 等。这些文件就是分割后的文件块。
4. 验证分割结果 你可以使用以下命令验证分割结果：
du -h demo_part_* 这将显示每个分割块的大小。确保它们的大小都小于 50M。
5. 合并分割块（可选） 如果需要将这些分割块还原为原始文件，可以使用 cat 命令：
cat demo_part_* &gt; restored_demo.tar.gz 这将把所有的分割块合并为一个文件 restored_demo.tar.gz。这是一个可选的步骤，根据你的需求而定。
以上步骤是在命令行中使用 split 命令将大文件分割为大小小于 50M 的文件块的基本步骤。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be413729769613f545f10e1cf8fccc32/" rel="bookmark">
			探索 Vue3 (五) 骨架屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		骨架屏是页面的一个空白版本，通常会在页面完全渲染之前，通过一些灰色的区块大致勾勒出轮廓，待数据加载完成后，再替换成真实的内容。
目前主流 UI库 都有骨架屏，如 Element-UI、Antd
可以看到使用起来非常简单，只需要一行代码即可
// element &lt;el-skeleton /&gt; // antd &lt;a-skeleton /&gt; 安装
npm i -S @x-ui-vue3/skeleton main.js 文件中挂载
import { createApp } from 'vue' import Skeleton from '@x-ui-vue3/skeleton' import App from './App.vue' createApp(App).use(Skeleton).mount('#app') demo
&lt;script setup&gt; import { ref } from 'vue' const loading = ref(false) &lt;/script&gt; &lt;template&gt; &lt;label for="loading"&gt;点击切换&lt;/label&gt; &lt;input v-model="loading" id="loading" type="checkbox" /&gt; &lt;br /&gt;&lt;br /&gt; &lt;div v-skeleton="loading"&gt; &lt;span v-skeleton-item&gt;超文本标记语言是一种用于创建网页的标准标记语言。&lt;/span&gt; &lt;br /&gt;&lt;br /&gt; &lt;span v-skeleton-item&gt;www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be413729769613f545f10e1cf8fccc32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8974e56edebe797e194f610038d236b5/" rel="bookmark">
			html动态加载script
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;动态添加JavaScript代码&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;button onclick="addScript()"&gt;点击添加脚本&lt;/button&gt; &lt;script&gt; function addScript() { // 创建一个新的script元素 var script = document.createElement("script"); // 设置脚本的内容 script.textContent = ` document.body.innerHTML += "&lt;p&gt;这是一段动态添加的文本。&lt;/p&gt;"; `; // 将脚本添加到body元素 document.body.appendChild(script); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 当HTML文档被完全加载和解析完成时，DOMContentLoaded事件会被触发。这比load事件更早，因为在DOMContentLoaded事件触发时，样式表、图像和子框架可能还没有完全加载。
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Dynamic Script Loading&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; document.addEventListener("DOMContentLoaded", function() { var script = document.createElement("script"); script.src = "path/to/your/script.js"; document.body.appendChild(script); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 当一个资源（如脚本、图像或样式表）完成加载时，load事件被触发。这通常用于检测外部资源是否已完全加载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8974e56edebe797e194f610038d236b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0bd518dda8a3644c693b67c85526d1d/" rel="bookmark">
			【bug】uniapp一键登录，自定义协议条款是否支持内部路由？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp一键登录的自定义协议条款，不支持内部路由跳转
在uniapp文档上搜一键登录
加二维码之后可以提问
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e13db9430268492dd0fd8b21a01ed5d/" rel="bookmark">
			Power Apps 学习笔记 - 客户端脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 客户端API1.1 客户端API对象1.2 Xrm对象模型(旧) 2. 功能实现2.1 客户端脚本2.2 Look Up过滤事件2.3 Option Set 动态添加选项 1. 客户端API 1.1 客户端API对象 客户端API对象链接：客户端API
1. 使用执行上下文和表单上下文的时候切记需要在程序属性当中选择"上下文传递作为第一个参数". 1.2 Xrm对象模型(旧) a. context:用于获取当前客户端和用户的信息，或者特定的参数信息 b. data:提供实体数据和方法的访问权限，管理窗体和业务流程中的数据 c. ui:检索用户界面相关信息的属性和方法，包含子组件集合 2. 功能实现 2.1 客户端脚本 客户端脚本演练： 客户端脚本演练
客户端脚本API： 客户端API
a. 客户端脚本简介
客户端API: 分为四种主要对象，分别是executionContext(表单网格中事件执行的上下文)、formContext(表单引用上下文)、gridContext(网格引用上下文)、Xrm(全局对象)获取执行对象的属性的时候(属性引用)，其逻辑名称作为其唯一标识 b. 脚本使用
准备Js脚本
a. 解决方案当中上传Web资源(JavaScript代码)
b. 在表的窗体当中引入该Web资源进入相应窗体(主类型)向其中保存时/加载时添加事件，将相应的Js脚本添加，并设置好对应调用的方法名字即可 var namespace = window.namespace || {}; (function () { this.hello = function () { // 设置中国内容可能乱码 var alertStrings = { confirmButtonLabel: "Yes", text: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e13db9430268492dd0fd8b21a01ed5d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/22/">«</a>
	<span class="pagination__item pagination__item--current">23/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/24/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>