<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cc499e56d27c03a17fd9364998422b3/" rel="bookmark">
			机器学习 —— 李宏毅机器学习笔记（四）—— 梯度下降
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		梯度下降 在第二篇博客中已经简单介绍过梯度下降算法，梯度下降算法是机器学习领域最广为人知、用途最广的优化算法，用来确定模型的参数（包括随机梯度下降SGD，Momentum，Adam等）。首先回顾一下梯度下降的计算过程：
梯度下降中常用技巧（Tips） 一、调整学习率 如上图左边部分所示，假设我们的loss曲线是图中黑色曲线，从曲线左边端点作为起始点，使用不同的学习率进行参数的更新（学习率可以理解为参数更新的幅度/或者每次前进的步长），蓝色线——红色线——绿色线——黄色线 的学习率依次增大，可以看到蓝色线学习率较小，更新较为缓慢，但是经过足够次数的迭代更新之后，仍能到达全局最优点（loss曲线最小处）；红色线的学习率恰好合适，经过比较少次数的更新，就可以到达全局最优点；绿色线的学习率设置的比较大，在更新过程中会错过全局最优点，最终的结果是在全局最优点的两边震荡；黄色线的学习率设置的过大，更新参数之后导致loss剧增。
所以，我们可以根据Loss曲线的变化情况，对我们的学习率进行一个合理的调整。可以绘制上图右边部分所示的曲线图，横轴代表参数更新次数，纵轴代表Loss值，学习率的大小分为四种情况：
1、学习率较小（蓝色曲线）：Loss值以一个缓慢的速度下降，不过最终仍然可以到达全局最优点。
2、学习率恰好合适（红色曲线）：Loss值下降较快，比较少的更新次数就可以达到全局最优点。
3、学习率较大（绿色曲线）：Loss值开始下降比较快，不过最终Loss值会保持在一个比较大的位置，没有到达全局最优点。
4、学习率过大（黄色曲线）：Loss值有一个剧增的趋势。
根据绘制出的 Loss-No. of parameters updates曲线，我们可以知道学习率的设置情况，并且进行相应的调整。
在学习率的设置过程中，常见的做法是，进行学习率的衰减。
在模型训练初期，距离全局最优点较远，可以设置一个相对大一些的学习率，随着训练的进行，距离全局最优点的距离越来越小，此时应该减小学习率；所以让学习率随着时间或者更新的次数进行衰减。
除了学习率的衰减之外，另外一个做法是：为不同的参数设置不同的学习率。也就是接下来要介绍的一种优化算法AdaGrad。
AdaGrad优化器 AdaGrad根据自变量在每个维度的梯度值的大小来调整各个维度上的学习率，从而避免统一的学习率难以适应所有维度的问题,即为每个参数设置不同的学习率。
原始的梯度下降，所有参数的学习率是一样的，均为。在AdaGrad中，学习率的变化过程为，其中是参数相关的，其值为该参数之前所有偏导数的均方根。具体的计算过程如上图右边部分所示。化简之后，得到最终的计算形式为：
这里需要注意的一点为：
如果我们计算得到的较大，在原始的梯度下降中，代表建议参数更新的幅度比较大；但是在AdaGrad中，较大，分母项会变小，代表分母建议参数更新的幅度较小，而分子建议更新的幅度较大，最终的更新幅度由两者的比值共同确定。这样做的一个原因是：
假设损失函数为一元二次函数：
该损失函数在处取得最小值，假设当前处于处，那么最好的步长应该为，也就是。
而在AdaGrad中，正是这一思想的体现，不过为了减少计算量，增加运算速度，AdaGrad中使用过去一阶偏导数的均方根作为分母项（二阶偏导数）的近似。
过去一阶偏导数的均方根可以在一定程度上反应二阶偏导的大小情况。如上图所示，二阶偏导小的函数，其采样的一阶偏导的值也相对较小。
二、随机梯度下降（SGD） 之前梯度下降算法中，Loss函数是对所有训练样本的Loss之和，而在随机梯度下降中，每次只采样一个样本，根据这一个样本进行一次梯度下降，所以随机梯度下降算法更新参数的过程更快。
三、特征缩放（Feature Scaling） 特征缩放是用来标准化数据特征的范围，减少特征中特异值的影响。
例如：
特征的取值范围[1,10]，特征的取值范围[100,1000]，那么损失函数L对于参数的更新更为敏感，反映到图中，就是在Loss等高线沿的方向更加密集（陡峭），上图左边部分所示。我们更加希望得到像右图所示的Loss等高线。因为对于左边的情况，不同的参数需要设置不同的学习率，才能很好的完成模型训练过程；对于右图，如果Loss等高线是一个正圆形，沿着等高线下降的方向，就是我们最终想要的优化结果。所以特征缩放可以帮我们得到右图所示的情况。
常用的特征缩放的方式：
归一化：（min-max normalization；缩放到[0，1]之间}）
标准化：（Standardization）
其中表示均值，表示标准差。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/791dc6877f38918cfb8d5931b8bc1792/" rel="bookmark">
			【C&#43;&#43;】set的常用用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 set是STL中一种标准关联容器。它底层使用平衡的搜索树——红黑树实现，插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高。
set顾名思义是“集合”的意思，在set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列，支持集合的交(set_intersection),差(set_difference) 并(set_union)，对称差(set_symmetric_difference) 等一些集合上的操作，如果需要集合中的元素允许重复那么可以使用multiset。
求并、交、差、对称差等操作，暂不细说，使用时要包含头文件”algorithm”。unordered_set和unordered_multiset为set和multiset的无序版，使用时要包含头文件”unordered_set” 二、常用操作 使用时注意包含头文件&lt;set&gt; std::set and std::multiset associative containers s.begin() 返回set容器的第一个元素 s.end() 返回set容器的最后一个元素 s.clear() 删除set容器中的所有的元素 s.empty() 判断set容器是否为空 s.insert() 插入一个元素 s.erase() 删除一个元素 s.size() 返回当前set容器中的元素个数 2.1 模板原型 template &lt;class Key, class Compare=less&lt;Key&gt;, class Alloc=STL_DEFAULT_ALLOCATOR(Key) &gt; 2.2 声明 #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;functional&gt; using namespace std; set&lt;int&gt; s; int main(){ set&lt;int &gt; seta; //默认是小于比较器less&lt;int&gt;的set set&lt;int, greater&lt;int&gt; &gt; setb; //创建一个带大于比较器的set，需包含头文件functional int a[5] = {1,2,3,4,5}; set&lt;int &gt; setc(a,a+5); //数组a初始化一个set； set&lt;int &gt; setd(setc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/791dc6877f38918cfb8d5931b8bc1792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e436a02e53909e57ad53d10ec35a296b/" rel="bookmark">
			Thymeleaf拼接URL，字符和请求参数使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Thymeleaf来创建一个
http://localhost:8081/news/list/all?page=1&amp;size=10 这样的url，现在希望“all”、“page”、“size”变化，其他的不变：“all”可能自身变为其他字符串，如"top"，而“page”“size”只改变数值，如"3"和"30"。结果希望变为：
http://localhost:8081/news/list/top?page=3&amp;size=30 解决方案：
Controller如下，“all”其实就是下面的type变量，通过
model.addAttribute("type", type) 传给前端，“page”“size”作为请求参数@RequestParam：
/** * 查询所有新闻 * @return 新闻列表 */ @GetMapping("list/all") public String listAll(Model model, @RequestParam(value = "page", defaultValue = PAGE_DEFAULT) Integer page, @RequestParam(value = "size", defaultValue = SIZE_DEFAULT) Integer size) { String type = "all"; logger.info("List news:" + type); PageHelper.startPage(page, size); List&lt;News&gt; list = mNewsService.selectAll(); PageInfo&lt;News&gt; pageInfo = new PageInfo&lt;&gt;(list); model.addAttribute("type", type); model.addAttribute("newsList", list); int pages = pageInfo.getPages(); model.addAttribute("indexPage", page &lt; 0 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e436a02e53909e57ad53d10ec35a296b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a647e05fe0b64f350ecdfdea9de901/" rel="bookmark">
			新浪微博千万级消息推送如何实现？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的读写速度是10w/s级别的，消息推送采用list的的LPUSH,BRPOP实现实时性貌似不够，那么如何优化和实现呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3570b5e94e18b9271e2ade6a10b257b/" rel="bookmark">
			c/c&#43;&#43;实现简单线性回归问题(机器学习入门实例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性回归问题简单分析 个人简单分析，有问题欢迎评论讨论
如果给出很多组数据（x,y），求拟合一条y=wx+b直线模拟问题，高中数学也有提到过，就是求w,b两个参数，使得拟合的直线可以近似穿过目标数据区域的中间位置，尽可以使得更多的真实数据点落在拟合的直线上。这个问题常常出现在机器学习，深度学习的入门教程的前几个例子中，然而无奈网上教程都是用机器学习常用的python进行实现，作为一个习惯c/c++的强类型语言的个人来说，看到python没有类型标识简直看出强迫症和云里雾里的感觉（写完感慨python真香，然而现在还不咋习惯）。
因此我打算自己动手用c++来写一遍，希望能加深一下理解。对于给出的数据点集，通过迭代循环的手段进行优化w和b两个参数，迭代一次w，b的值更准确一次，而迭代n次运用的方法就是老生常谈的梯度下降法，经过n次迭代后得到的w和b就很准确了。而每一次迭代需要进行求导计算w(b)=w(b)-learningrate*▲w’(b’),具体过程可以求▲w’(b’)的平均值效果更好，learningrate学习率是用来控制下降的高度的，每次降太快容易越过极小值点。
那么，如何去衡量b直线的w和b准不准确呢，衡量的方法是累计（yi-yi’)^2的值， 定义成一个loss损失函数进行评估。
运行结果：具体结果和第一个图还是很接近的，数据点集和代码在下方
c++重写实现
#include&lt;bits/stdc++.h&gt; using namespace std; typedef long double ld; vector&lt;ld&gt; XArray; vector&lt;ld&gt; YArray; ld end_b,end_w; ld learning_rate = 0.0001; ld initial_b = 0; ld initial_w = 0; int num_iterations=5000; //处理csv文件得到数据点集 void getData(){ ifstream inFile("data.csv", ios::in); string lineStr; vector&lt;vector&lt;string&gt;&gt; strArray; while(getline(inFile,lineStr)){ stringstream ss(lineStr); string str; while(getline(ss,str,',')){ XArray.push_back(stod(str)); getline(ss,str,','); YArray.push_back(stod(str)); } } // for(int i=0;i&lt;XArray.size();i++){ // cout&lt;&lt;XArray[i]&lt;&lt;" "&lt;&lt;YArray[i]&lt;&lt;endl; // } } //衡量精确度的方法：loss函数 ld compute_error_for_line_given_points(ld b,ld w){ ld totalError = 0; for(int i=0;i&lt;XArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3570b5e94e18b9271e2ade6a10b257b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f1748680bad9aa0897d616a9de794ed/" rel="bookmark">
			为什么IEEE754标准中单精度浮点数的阶码取值范围是1~254（-126~127）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：以下都是建立在IEEE754标准中 2^8 = 256
2^7 = 128
带符号8位2进制本来应该是[-127, -0]U[+0, 127]
而该标准规定：
E = 0000 0000 M = 000…000 用来表示了正、负零
E = 1111 1111 M = 000…000 用来表示了正、负无穷
去掉这两个之后，阶码E的其余值： 0000 0001 ~ 1111 1110
上面的规定意思就是：
阶码0000 0000到1111 1111这些数中，
全1（1111 1111）=-127，表示了浮点数的无穷，被舍去全0（0000 0000），即+0，表示了浮点数的0，也被舍去 于是阶码的取值范围变成了[-126,-0]U[+1, 127]，合并之后成了[-126, 127]
同样，去掉全0和全1之后，无符号8位2进制的范围由[0, 255] 变成了[1, 254]
由[1, 254] ——&gt; [-126, 127] 便可以得知移码的偏移量为127，当然在理解这句话之前你得先知道移码和偏移量是什么。
而，在非规范时，E的范围是[0, 255]，即0000 0000 ~ 1111 1111 感谢：知乎回答
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4525cefc4c48d2537c1b60f032f0dd1/" rel="bookmark">
			python练习题（四）：有四个数字：1、2、3、4，能组成多少个互不相同且无重复数字的三位数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		count = 0 for i in range(1, 5): for j in range(1, 5): for k in range(1, 5): if (i != j) and (i != k) and (j != k): print(i,j,k) count += 1 print("总计： %d" % count) 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/984824fe2834e11dc378aaea241f29fe/" rel="bookmark">
			【python数据分析实战】城市餐饮店铺选址问题（2）—— 确定餐馆的具体位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 选址的评价指标如下：
人口密度指标 → 得分越高越好
道路密度指标 → 得分越高越好
餐饮热度指标 → 得分越高越好
同类竞品指标 → 得分越低越好
综合指标 = 人口密度指标x0.4 + 餐饮热度指标x0.3 + 道路密度指标x0.2 +同类竞品指标x0.1（假定）
2. 需要的空间数据（全是投影坐标系）
上海行政区：net_population.shp （上海1km²格网内的人口密度数据）
具体的道路：road.shp （上海道路数据）
网格数据：需要后面自己划分设定
在qgis做空间统计之后，网格数据导出点数据，投影成wgs84地理坐标系，导出excel文件
3. 指标处理
1）人口密度指标：对应net_population.shp中的数据，打开qgis，通过导入的该文件，双击进入‘样式’，选择‘渐进’，Z字段进行‘分位数’分类，然后点击‘应用’，就得到了要求的结果
–&gt; 输出结果为：
2）道路密度指标： 就是网格数据除以网格类的道路长度，选择菜单栏‘矢量’下面的‘分析工具’，点击‘计算线条总长度，这时候要新建一个文件夹来保存创建的数据文件，这样会计算每个网格里面的道路长度，并生成一个新的画布new_result（建议不要和原来的名称一样），打开属性表后，可以在’Z’值后增加了一个‘长度’列
–&gt; 输出结果为：
3）餐饮热度指标：加载餐饮数据.csv文件，编码默认GBK，然后选择横纵坐标，这时候加载的时候选择是WGS84的坐标系，如果直接使用投影坐标系，则该数据和地图数据不再一块。然后在将导入的数据转化为投影坐标系，这时候右键导入的数据，‘另存为’，选择投影坐标系，输入好文件名称（这里命名为cy）后，存在上一步创建好的文件夹里就可以了
–&gt; 输出结果为：
计算网格里餐饮店的个数，选择菜单栏上的‘矢量’，‘分析工具’，然后点击‘计算多边形内点的数目’，这时候‘输入多边形矢量图层’选择完成道路密度指标时候创建的新的画布new_result,'输入的点矢量’就是刚刚加载的cy数据，这时候属性聚合的统计方法选择‘总计’，输出的字段保存为cy_count,画布名称为new_result2,这时候属性表里面就多了一列‘cy_count’的数据
–&gt; 输出结果为：
4）同类竞争指标：针对cy的数据，打开属性表做一个选择，打开表达式选择‘字段和值’下面的类别（双击），在左侧窗口点击‘=’，之后在右下点击全部唯一，找到‘素菜’，并双击。然后重新打开属性表，可以看到上方有个’已选中178
–&gt; 输出结果为：
这时候点击左下角的‘显示所有要素’，这时候将cy数据另存为，注意勾选‘仅保存选中的要素’，命名为sc，投影坐标系。然后计算网格中素菜馆的个数，按照上一步骤重复一下即可（这里的输入多边形矢量图层选择new_result2，,输入的点矢量就是刚刚加载的sc数据），最终的画布new_result3就是最终的数据了
–&gt; 输出结果为：
最后：将网格转变为多边形质心（点），选择‘矢量’，‘集合工具’，点击‘多边形质心’，输入层选择new_result3，输出的文件名称为result_point，这时候要添加lng和lat，要将投影坐标系再转回到wgs84坐标系中，点击另存为，选择wgs84坐标系后，保存文件result_point_wgs84，这时候打开属性表，新建字段，分别创建lng、lat，都选择小数（浮点型），分别对应几何图形里面的$x, $y.至此所有的处理工作完成，导出数据就行，新建一个Excel表格，ctrl + a 键全选qgis里面的数据粘贴到Excel表格里面就可以了，第一列删掉，然后保存在桌面。数据样式如下：（直截取部分）
–&gt; 输出结果为：
4. python数据处理
1）数据导入并查看
加载刚刚通过qgis处理过后的数据
df2 = pd.read_excel('data.xlsx') data_df2_count = len(df2) print('一共有的数据量为{}'.format(data_df2_count)) print(df2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/984824fe2834e11dc378aaea241f29fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c520c92e18f152dcc787fc4a2369b6/" rel="bookmark">
			C语言——SO动态库与编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SO动态库与编译 库的概念定义 库存在的意义定义 库的种类如何编译一个动态库动态库与静态库区别 库的概念 定义 在windows平台和linux平台下都大量存在着库。Android中也存在着库，库顾名思义，指的是一个容器文件，里面装的是函数，由于window和linux的平台不同(主要是编译器、汇编器和连接器的不同)，因此二者库的二进制是不兼容的。
库存在的意义 定义 库是别人写好现有的，成熟的，可以复用的代码。
现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此，库的存在意义非同寻常。
库的种类 库有动态库和静态库。
库的文件格式，在不同的平台下是不一样的。比如，在window下，动态库是…dll，静态库…lib，如果是在Android和Linux操作系统的话，它的动态库是.so，静态库是.a
那么.so和.a又有什么区别与联系呢？
我们可以把这种库，理解成一个jar包，在jar里面是包含.class的，class的加载时发生在运行的时候，但是，除了.jar包，还有一种文件，叫做.arr，也类似于jar包，在相同条件下，它的文件大小是大于jar包的。
jar包类似于.so文件，.a类似于.arr文件
他们的区别发生在连接和加载过程中，而他们的目的都是一样的，都是去加载第三方的函数。
如何编译一个动态库 动态库与静态库区别 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbb5b86bc041c045895b7fae7e95a4c8/" rel="bookmark">
			无法打开arxiv.org的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/xiximayou/p/12274820.html
改成形如 http://xxx.itp.ac.cn/pdf/1806.06029
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3854e66edfa13778f2c034c8e33184ee/" rel="bookmark">
			Altium Designer 18中的Data Management–Version Control
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Data Management–Version Control（数据管理–版本控制）是Altium Designer 18中“Preferences”对话框第二项功能的第一个页面，如下图所示。
Summary摘要 “首选项”对话框的“数据管理–版本控制”页面允许您设置版本控制选项，例如提供程序和SVN可执行文件。默认情况下，安装了VCS Provider-SVN扩展。此扩展通过使用SharpSVN提供版本控制功能的实现。 此实现完全支持文件名中的Unicode（多字节）字符。例如，这允许您将文件中包含俄语字符的文件添加到SVN VCS存储库中。
Options/Controls选项/控件 Provider-列出可用的版本控制提供程序。
Enabled-选中以启用SVN-Subversion启用默认提供程序。
从所有设计存储库中签出新项目时，为您的本地工作副本选择SVN版本格式-选择所需的SVN版本工作副本格式。选项包括1.9（推荐），1.8和1.7。
如果选择了1.9以外的格式，则工作副本格式应仅用于签出新项目。 例如，如果您已经有一个使用1.9版本的项目，并且选择了1.7版本，则工作副本可能会遇到问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeff12a7a46c2b68444a5c880fca59dc/" rel="bookmark">
			C语言——结构体、共用体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构体、共用体 1.结构体基础知识代码基本写法内存对齐 2. 共用体引论定义基础写法共用体大小 1.结构体 基础知识 类似于Java中的javaBean,可以将一些变量封装成一些对象。同样的，在C里面可以将一些其他的变量，封装成一个结构体，结构体和共用体表现的含义是一致的
代码基本写法 #include&lt;stdio.h&gt; struct Student { int i; short j; }s1,s2; void main(){ struct Student student; student.i = 10; student.i = 5; s1.i = 10; s1.j = 3; printf("结构体大小%d:", sizeof(student)); system("pause"); } 内存对齐 在上述代码中，定义了两个结构体，，在结构体体中，定义了两个变量，一个int类型，一个short类型，int类型是4个字节，short类型是2个字节，按常理，这个结构体是6个字节，但是通过sizeof(student)查看，是8个字节，为什么是8个字节呢？
这就涉及到C里面的内存对齐概念。在C执行的过程中，特别是给对象，结构体进行分配内存的时候，它是遵循内存对齐的规则。
内存对齐
定义：对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他也就被称为自然对齐。比如在32位cpu下，假设一个整型变量的地址为0x00000004,那他是自对齐的。
结构体大小
定义：当结构体需要内存过大，使用动态内存申请。结构体占用字节数和结构体内字段有关，指针占用内存计算4/8字节，因此传指针比传值效率更高
结构体存储原则
(1).结构体变量中成员的偏移量必须是成员大小的整数倍(0被认为是任何数的整数倍)
(2).结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公数倍
看了上面定义，我们可以得知，刚刚我们定义的short类型，short类型是2个字节，由于在32位的CPU下，它最小的单位步长是4个字节，由于2个字节小于4个字节，所以系统会给short分配4个字节，只不过后面两个字节不会起作用，后面还有一个int类型，由于int类型有4个字节，所以这个结构体，一共8个字节。
为什么要基于内存对齐呢？
举个例子，张三要去请李四和王五去他家做客，由于李四和王五住在不同的楼层，所以，张三需要先去李四家邀请李四，再去王五家邀请，需要两次，这就是访问一个地址，它必须要做的两件事情，这就是没有去做实现内存对齐的情况下，那张三能不能只邀请一次呢？
答案是可以的，那就是让李四和王五同时处于一个房间
这个例子可以证明，内存对齐对于访问指针的效率非常重要的。
2. 共用体 引论 共用体和结构体类似，它都是表达一个数据类型的集合，只不过结构体，他需要内存开销更大一点。
定义 共用体是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候都只能有一个成员带有值，共用体提供了一种使用相同的内存位置的有效方法。
基础写法 union Data{ int i; float f; char str[20]; } data; 其调用方法与结构体类似。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aeff12a7a46c2b68444a5c880fca59dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25e165e75195237e2faffc649ee3e1ec/" rel="bookmark">
			深入理解Flutter的GestureDetector组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 上一篇文章 深入理解Flutter的Listener组件 介绍了触控事件的监听原理，让我们对Flutter中触摸事件的传递过程有了进一步的认识。
今天我们学习一下手势识别组件GestureDetector的原理。GestureDetector的内部实现使用的是Listener组件，如果对Listener还不太熟悉，可以先了解一下Listener的原理。
源码解析 一、GestureDetector是Listener的封装 GestureDector是一个无状态组件，它的build方法如下所示。
class GestureDetector extends StatelessWidget { ...省略 Widget build(BuildContext context) { ...省略return RawGestureDetector( gestures: gestures, behavior: behavior, excludeFromSemantics: excludeFromSemantics, child: child, ); } } build方法直接返回了RawGestureDetector组件，说明GestureDetector是由子组件RawGestureDetector构成的。而RawGestureDetector是一个有状态组件，它的State的build方法如下所示。
class RawGestureDetector extends StatefulWidget { @override RawGestureDetectorState createState() =&gt; RawGestureDetectorState(); } class RawGestureDetectorState extends State&lt;RawGestureDetector&gt; { ...省略 @override Widget build(BuildContext context) { Widget result = Listener( onPointerDown: _handlePointerDown, behavior: widget.behavior ?? _defaultBehavior, child: widget.child, );if (!widget.excludeFromSemantics) result = _GestureSemantics(owner: this, child: result); return result; } } build方法里面返回了Listener组件，这也证明了上面的结论：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25e165e75195237e2faffc649ee3e1ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebaa58a184853e475a4f173d318ec707/" rel="bookmark">
			解决bootstrap轮播不了问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、首先在开头导入时要注意你用的bootstrap是哪个版本的，导出的模版可直接去该版本的官网查找、复制，可避免自己写错。
ps:千万不要直接去复制他人的例子导入。
如关于bootstrap3.3.7版本的导入模板：
&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js"&gt;&lt;/script&gt; 此处引用的插件来自于bootstrap官网！ 二、引用js、css顺序错误，必须css、然后是jquery.js，最后再是bootstrap.js
原因：bootstrap.js需要借助jquery.js
如上图代码所示 三、默认使用Bootstrap的Carousel组件，只需要加上 data-ride=“carousel” 就可以实现自动播放了。无需使用初始化的js函数。所以，如果carousel不会自动播放，那么首先检查这个部分。这里还能加其他参数，比如是设置图片轮转的时间间隔。
&lt;div id="carousel-ad" class="carousel slide" data-ride="carousel" data-interval="2000"&gt; 四、轮播图中标签的class内容跟轮播图div容器的id不一致
例如：ol列表中li标签，data-target值，必须为"#carousel-example-generic"
因为div容易的id属性为： id=“carousel-example-generic”
&lt;ol class="carousel-indicators"&gt; &lt;li data-target="#carousel-example-generic" data-slide-to="0" class="active"&gt;&lt;/li&gt; .....&lt;/ol&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292adde2c347c1177e54f4c0e326c620/" rel="bookmark">
			C51串口的SCON寄存器及工作方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		串行口控制寄存器SCON 它用于定义串行口的工作方式及实施接收和发送控制。字节地址为98H，其各位定义如下表：
其中fosc为晶振频率
SM2：多机通讯控制位。在方式0时，SM2一定要等于0。在方式1中，当（SM2）=1则只有接收到有效停止位时，RI才置1。在方式2或方式3当（SM2）=1且接收到的第九位数据RB8=0时，RI才置1。
REN：接收允许控制位。由软件置位以允许接收，又由软件清0来禁止接收。
TB8: 是要发送数据的第9位。在方式2或方式3中，要发送的第9位数据，根据需要由软件置1或清0。例如，可约定作为奇偶校验位，或在多机通讯中作为区别地址帧或数据帧的标志位。
RB8：接收到的数据的第9位。在方式0中不使用RB8。在方式1中，若（SM2）=0，RB8为接收到的停止位。在方式2或方式3中，RB8为接收到的第9位数据。
TI：发送中断标志。在方式0中，第8位发送结束时，由硬件置位。在其它方式的发送停止位前，由硬件置位。TI置位既表示一帧信息发送结束，同时也是申请中断，可根据需要，用软件查询的方法获得数据已发送完毕的信息，或用中断的方式来发送下一个数据。TI必须用软件清0。
RI：接收中断标志位。在方式0，当接收完第8位数据后，由硬件置位。在其它方式中，在接收到停止位的中间时刻由硬件置位（例外情况见于SM2的说明）。RI置位表示一帧数据接收完毕，可用查询的方法获知或者用中断的方法获知。RI也必须用软件清0。
串行口的工作方式 8051单片机的全双工串行口可编程为4种工作方式，现分述如下：
1，方式0为移位寄存器输入/输出方式。可外接移位寄存器以扩展I/O口，也可以外接同步输入/输出设备。8位串行数据者是从RXD输入或输出，TXD用来输出同步脉冲。
（1）输出串行数据从RXD引脚输出，TXD引脚输出移位脉冲。CPU将数据写入发送寄存器时，立即启动发送，将8位数据以fos/12的固定波特率从RXD输出，低位在前，高位在后。发送完一帧数据后，发送中断标志TI由硬件置位。
（2）输入当串行口以方式0接收时，先置位允许接收控制位REN。此时，RXD为串行数据输入端，TXD仍为同步脉冲移位输出端。当（RI）=0和（REN）=1同时满足时，开始接收。当接收到第8位数据时，将数据移入接收寄存器，并由硬件置位RI。
2，方式1为波特率可变的10位异步通讯接口方式。发送或接收一帧信息，包括1个起始位0，8个数据位和1个停止位1。
（1）输出当CPU执行一条指令将数据写入发送缓冲SBUF时，就启动发送。串行数据从TXD引脚输出，发送完一帧数据后，就由硬件置位TI。
（2）输入在（REN）=1时，串行口采样RXD引脚，当采样到1至0的跳变时，确认是开始位0，就开始接收一帧数据。只有当（RI）=0且停止位为1或者（SM2）=0时，停止位才进入RB8，8位数据才能进入接收寄存器，并由硬件置位中断标志RI；否则信息丢失。所以在方式1接收时，应先用软件清零RI和SM2标志。
3，方式2
方式2为固定波特率的11位UART方式。它比方式1增加了一位可程控为1或0的第9位数据。
（1）输出: 发送的串行数据由TXD端输出一帧信息为11位，附加的第9位来自SCON寄存器的TB8位，用软件置位或复位。它可作为多机通讯中地址/数据信息的标志位，也可以作为数据的奇偶校验位。当CPU执行一条数据写入SUBF的指令时，就启动发送器发送。发送一帧信息后，置位中断标志TI。
（2）输入: 在（REN）=1时，串行口采样RXD引脚，当采样到1至0的跳变时，确认是开始位0，就开始接收一帧数据。在接收到附加的第9位数据后，当（RI）=0或者（SM2）=0时，第9位数据才进入RB8，8位数据才能进入接收寄存器，并由硬件置位中断标志RI；否则信息丢失。且不置位RI。再过一位时间后，不管上述条件时否满足，接收电路即行复位，并重新检测RXD上从1到0的跳变。
4，工作方式3
方式3为波特率可变的11位UART方式。除波特率外，其余与方式2相同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/909668b6189c7e0e0dbb71a5c23003a7/" rel="bookmark">
			pycharm“运行”按钮是灰色的该如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正常的运行按钮是绿色的，但有的时候（尤其是新使用pycharm的时候）你会发现运行按钮是灰色的。
思路一：
如果是新建的程序，是需要进行初次运行的。要右键点击左侧的程序文件，点击运行按钮，或者直接快捷键Ctrl+shift+F10
思路二：
环境变量没有设置好，配置一下即可（网上很多类似教程，就不一一列举了）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b383ae47aff6dac80e6d236d3c247e9/" rel="bookmark">
			电子设计教程22：虚短与虚断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“虚短”与“虚断”是非常重要的两个概念。在分析运放的输入信号与输出信号的关系时，这是两个基本的出发点。
当运放引入负反馈的时候，或者说工作在“线性区”的时候，输出电压与净输入电压（同相输入端反相输入端的差值）成线性关系，电路的放大倍数就是运放自身的开环增益。
u_O是有限值，通常不会大于电源电压。A_od非常大，常常达到百万倍，所以u_P-u_N几乎为0。由于两个输入端几乎没有电压差，看上去好像是短路了，所以称为“虚短路”。但是虚短路不是真正的短路，如果u_P 与u_N完全相等，电路的输入端就不存在差值，即便把0放大一百万倍，结果还是0。所以u_P 与u_N还是有一点点电压差的。
由于运放的输入电阻非常大，所以输入电流非常小，所以运放的输入端看上去相等于断路，称两个输入端为“虚断路”。虽然输入端的电流趋近于零，但不是真正的断路，如果输入端真的断路了，运放没有输入，当然也不会有正确的输出了，所以还是有很一点点输入电流的。
开环增益（写作A_od）非常大，通常是10000以上；
输入阻抗非常高 ，通常是1000000欧姆以上。
由于开环增益实在太大了，输入信号要非常非常小，电路才能工作。所以实际应用中，通常会闭环应用，加入负反馈，把输出连接到反相输入端。常常会用电阻分压，来决定放大倍数。例如分析下边这个放大电路的放大倍数：
“+”表示同相输入端，用u_P表示；
“-”表示反相输入端，用u_N表示；
由于虚断，分析R_F与R_2的串联支路，根据电流相等可得：
则闭环增益A_uf为
注意，应用“虚短”与“虚短”的前提是运放处于线性工作区，一般情况下处于线性工作区的运放都存在闭环负反馈。“虚短”其实是运放处于线性工作区的结果，而并非导致运放处于线性工作区的原因。如果人为的增大两个输入端的电压差，并不一定使输出电压增大，反而会使运放处于非线性区。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c08e3222906ae5b07d6c3fde25875b/" rel="bookmark">
			MySQL 删除视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除视图是指删除 MySQL 数据库中已存在的视图。删除视图时，只能删除视图的定义，不会删除数据。
基本语法 可以使用 DROP VIEW 语句来删除视图。
语法格式如下：
DROP VIEW &lt;视图名1&gt; [ , &lt;视图名2&gt; …] 其中：&lt;视图名&gt; 指定要删除的视图名。DROP VIEW 语句可以一次删除多个视图，但是必须在每个视图上拥有 DROP 权限。
删除视图 删除 v_students_info 视图，输入的 SQL 语句和执行过程如下所示。
mysql&gt; DROP VIEW IF EXISTS v_students_info; Query OK, 0 rows affected (0.00 sec) mysql&gt; SHOW CREATE VIEW v_students_info; ERROR 1146 (42S02): Table 'test_db.v_students_info' doesn't exist 可以看到，v_students_info 视图已不存在，将其成功删除。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/079e99c1d999cdf0503c60071c0f9f86/" rel="bookmark">
			云服务器运用在哪些地方可以突显其价值？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器现在都基本上都遍布在我们的生活中，在很多领域都有云服务器的存在，那么具体在哪些方面应用会比较恰当呢？云服务器厂家-Cloudeasy云管家来告诉您！
1、科研实验中心
以生物制药为例，我们在生物制药行业的研究和运营中，许多设备需要使用超级计算机计算的。而云服务器就完全适合这种需求。
组织器官模拟、药物开发、人类基因组相关研究、人工智能医生、医疗保健、生物大分子研究等，都需要双精度计算、模拟计算、160万cpu和mic核协同计算、分子动力学、前体计算等，所有的这些生物研究都需要依靠云服务器去支持的。
2、视频编解码技术
视频编解码中的H264编码技术是应用最广泛、最有效、最及时、最方便的编码技术。实现此编码过程所需的操作、编码和压缩是复杂的。该技术常用于视频流所在的视频制作公司、直播平台等。
云服务器可以支持h264视频编解码技术，使得视频编解码的处理更加方便快捷，无需担心安全问题，它是企业和个人用户参与视频编解码的最佳选择。
3、AI技术
目前，科技界最热门的话题是人工智能，但对人工智能有两个核心要求：一是数据库足够强大，二是计算能力足够强大。在计算能力方面，斯坦福大学的人工智能实验室的测试显示，谷歌的数据中心需要1000台CPU服务器来完成这项工作，而云服务器只有3台可以完成。
这些测试清楚地显示了云服务器在深度学习和机器学习中的强大性能。对于这个超级强大的运算能力，云服务器的效率是无与伦比的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45637e0e4b4d2b5a192dce0cecf19bde/" rel="bookmark">
			使用Android Studio 运行Flutter项目时遇到的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 使用Android Studio启动flutter项目无法连接到设备，报错：flutter run: No connected devices found; please connect a device, or see flutter.io/setup for getting started instructions.
起因 因为最近在研究学习flutter框架，下载了flutter SDK 和 Android Studio 之后创建了一个flutter object，当启动模拟器运行时报错，
那么问题来了，已经创建了设备是肯定的，为什么启动不了？
解决方案 经过网络各种查找，找到了问题，总结了以下步骤
一、在电脑上打开VM acceleration
二、按Android Studio&gt;Tools&gt;AVD Manager，添加android模拟器，虚拟设备
三、配置虚拟机，推荐选择x86和x86_64的image
四、启动模拟机，接着就可以执行 flutter run了。
问题又来了，哈哈哈，问题好多呀，不过后边都是小问题，在这里也说一下，免得忘记 ^_^ ^_^
1.在flutter sdk 目录运行flutter run 是不行的，根据提示转到项目目录去再试一下
2.又一个问题，这才发现flutter 是需要Android SDK 的支持，所以。。。果断去下载
打开Android studio &gt; Setting &gt; System Setting &gt; Android SDK 在这里下载根据上边提示的对应版本
接下来要先在Android studio 把devices运行起来
再次运行命令果然成功了，这样项目就运行起来了
虽然程序员做了好几年，但是第一次记录所学，写的不好，请多提意见，户型学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed03703c07e9ae6704beca453624d3e0/" rel="bookmark">
			关于李中伟前辈的三频外差成功了！并对上一篇博文“条纹间距和频率”有了解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一下：无论是条纹频率还是间距都是为了覆盖整张图片，phi123（f123的相位图）就可以用来求解phi1/phi2/phi3
暂时在matlab中自建立体图，最后能三维重建出来，实验中肯定是有噪声的，下一步要研究误差的修正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/529fc65d458d73d1e2380a501abf2542/" rel="bookmark">
			win10系统下使用Bitlocker提示正在等待激活问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开命令提示符
2.查看帮助
manage-bde -?
3.取消加密，并关闭Bitlocker
manage-bde -off d:
4.成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd590463891d452b7598126cecd7c99/" rel="bookmark">
			C语言——数组和指针，数组指针，指针数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组和指针，数组指针，指针数组 1.数组和指针关系及基本使用通过指针进行运算 2. 数组指针（也称行指针）定义 3.指针数组定义指针优先级 4.指针数组和数组指针的区别 1.数组和指针 关系及基本使用 数组是一个数据的集合，它在内存中的体现是一个连续的内存区域。如果当前声明的int类型数组，数组类型为3，这样我可以用一个int类型的指针，指向一个首地址，这样就可以通过指针操作数组了
#include&lt;stdio.h&gt; void main(){ int arr[] = { 100, 200, 300 }; for (int i = 0; i &lt; 3; i++) { printf("数组%d\n", arr[i]); } printf("======================\n"); int* p = &amp;arr; *p = 400; for (int i = 0; i &lt; 3; i++) { printf("数组%d\n", arr[i]); } system("pause"); } 上述代码中，通过指针方式操控数组，把数组第一个元素，由100转换为400
通过指针进行运算 int* p = &amp;arr;这是我们刚才设置的变量，当这个变量指向数组时，实际上指向的是数组的首地址，即数组的第一个元素，那我们能不能让这个指针指向第二个元素呢？
答案是肯定的，只需要*p的基础上面加1，就可以指向第二个元素
#include&lt;stdio.h&gt; void main(){ int arr[] = { 100, 200, 300 }; for (int i = 0; i &lt; 3; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd590463891d452b7598126cecd7c99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d6fb6ad9a41a5369e1a254f58ef1656/" rel="bookmark">
			C语言——函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数 1.定义2.格式实例注意事项 3.指针函数定义实例 4.函数指针定义实例1实例二注意事项 1.定义 函数是一组一起执行一个任务的语句。 每个C程序都至少有一个函数，即主函数main()。 所有简单函数的程序都可以定义其他额外的函数。
2.格式 函数返回值类型 函数名称(函数传入值类型 传入值名称){ 函数体 return 返回值类型;
}
实例 #include&lt;stdio.h&gt; void f(){ printf("函数\n"); } void main(){ f(); system("pause"); } 注意事项 1.自定义函数要写在main函数上方。
如果自定义函数写在main函数下方，编译器会报错，告诉我们函数找不到
这是因为在C语言中，是由上到下开始加载，当加载main函数的时候，没有发现还有自定义函数
那为什么java可以做到哪？
那是因为java是面向对象的语言，它对于整个class文件，它会全部加载进内存，所以它不会分为上和下。
C语言这点，类似于前端的DOM解析，都是由上到下进行解析。从上到下，如果没有加载进内存，就不会被其他函数所调用。
2如果想在下面进行声明自定义函数，怎么办呢？
写一个头文件(.h)，在里面只写函数声明不写函数调用，运行前提前声明要要调用的函数，例如：void f();
类似于java中的接口
#include&lt;stdio.h&gt; //对自己创建的头文件的引用 //自己的头文件是""引起来的，如果是系统的头文件可以用&lt;&gt; #include "fuc.h" void main(){ f(); system("pause"); } void f(){ printf("函数1\n"); } 问：C语言为什么要这样设计呢
答：因为C语言这个设计是以函数为基础，它不和Java一样。
Java是以类为基础，类作为一个对象，所以方法都可以写在类中。
但是，C语言是以每一个函数组成的每一个程序，当我们设计一个应用程序之后，它会出现很高的耦合，所以这些头文件就相当于一个接口，每一个类都相当于一个接口。
如果我要想调用这个类里面的内容，就可以把这个接口(.h)文件，引入进来就可以了。不用取引入.c文件。
实际上，这个接口(.h)只是取定义这个类的规范，这个接口并不会被直接编译成具体的对象，同样的,.h文件不会实习编译，真正编译的，是这个头文件所实现的C文件。
总而言之：.h文件相当于Java的接口，它是为了解决程序的耦合问题
3.指针函数 定义 指针函数是指带指针的函数，即本质是一个函数。函数返回类型是某一类型的指针
如：类型标识符 *函数名(参数表){
int *f(x,y)
}
实例 #include&lt;stdio.h&gt; int* int_add_func(void* w){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d6fb6ad9a41a5369e1a254f58ef1656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1706615651c7f62e66c8c8e08c48fad/" rel="bookmark">
			mysql自动将datetime类型的毫秒数四舍五入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题复现 近期在项目过程中，写了个接口，某个参数类型是datetime；联调时发现db里面的时间值是2020-04-01 00:00:00，但是合作业务方这边传参是2020-03-31 23:59:59。
这个问题之前遇到过，一看就知道是mysql dategtime类型的四舍五入问题。经确认，业务方果然是把毫秒数设为了大于500的值（999）。
原因探讨 这是为什么呢？
查看MySQL 5.6 manual发现，5.6.4及以上版本的mysql server端确实支持fractional second part(fsp)，但如果client提交过来的小数位数超过server端建表时指定的小数位数，mysql server会自动进行四舍五入的截断，没有任何警告或异常。
在看看我们的mysql server 版本
解决方案 1、入库前舍弃毫秒部分。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77545f1a66823789ce186994050aa322/" rel="bookmark">
			【Hive】FROM_UNIXTIME() 和 UNIX_TIMESTAMP（）时间戳函数用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天用 hive 进行 ETL时，需要对时间戳进行格式化， 其中还需要用到正则表达式及一些时间函数，在这里简单总结一下unix_timestamp、from_unixtime的用法，仅供参考。
先看下这段 HQL ：
CREATE TEMPORARY TABLE user_event STORED AS ORC AS SELECT t.user_id, t.event_id, t.invited AS user_invited, CASE WHEN t.time_stamp regexp '^\\d{4}-\\d{2}-\\d{2}\\s\\d{2}:\\d{2}:\\d{2}.*' AND e.start_time regexp '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z' THEN datediff(from_unixtime(unix_timestamp(CONCAT(SUBSTR(e.start_time, 1, 10), ' ', SUBSTR(e.start_time, 12, 8)), 'yyyy-MM-dd hh:mm:ss')), from_unixtime(unix_timestamp(CONCAT(SUBSTR(t.time_stamp, 1, 10), ' ', SUBSTR(t.time_stamp, 12, 8)), 'yyyy-MM-dd hh:mm:ss'))) ELSE NULL END AS invite_ahead_days, t.interested AS user_interested, e.user_id AS event_creator, CASE WHEN e.start_time regexp '^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z' THEN datediff(from_unixtime(unix_timestamp(CONCAT(SUBSTR(e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77545f1a66823789ce186994050aa322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08aa0e4982de5e8dbf3345bb3a44b676/" rel="bookmark">
			mysql幻读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		幻读(phantom read) 前提条件：InnoDB引擎，可重复读隔离级别，使用当前读时。表现：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。两点需要说明：
1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在当前读下才会出现。
2、幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。 幻读的影响 会造成一个事务中先产生的锁，无法锁住后加入的满足条件的行。产生数据一致性问题，在一个事务中，先对符合条件的目标行做变更，而在事务提交前有新的符合目标条件的行加入。这样通过binlog恢复的数据是会将所有符合条件的目标行都进行变更的。 幻读产生的原因 行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。 如何解决幻读 将两行记录间的空隙加上锁，阻止新记录的插入；这个锁称为间隙锁。间隙锁与间隙锁之间没有冲突关系。跟间隙锁存在冲突关系的，是往这个间隙中插入一个记录这个操作。 快照读：读取的是记录数据的可见版本（可能是过期的数据），不用加锁。
当前读：读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录
，举个例子，假设你开启了两个事务，分别是A和B，这里有张user表，里面有四条数据
id username password isadmin name type
1 vision 123456 1 赵 book
2 peter 123456 0 钱 test
3 bill 123456 0 孙 shop
4 tom 111111 0 李 shop
1、select快照读（照片）
当你执行select *之后，在A与B事务中都会返回4条一样的数据，这是不用想的，当执行select的时候，innodb默认会执行快照读，相当于就是给你目前的状态找了一张照片，以后执行select 的时候就会返回当前照片里面的数据，当其他事务提交了也对你不造成影响，和你没关系，这就实现了可重复读了，那这个照片是什么时候生成的呢？不是开启事务的时候，是当你第一次执行select的时候，也就是说，当A开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有B添加的那条数据......之后无论再有其他事务commit都没有关系，因为照片已经生成了，而且不会再生成了，以后都会参考这张照片。
2、update、insert、delete 当前读
当你执行这几个操作的时候默认会执行当前读，也就是会读取最新的记录，也就是别的事务提交的数据你也可以看到，这很好理解，假设你要update一个记录，另一个事务已经delete这条数据并且commit了，这样不是会产生冲突吗，所以你update的时候肯定要知道最新的信息啊。
我在这里介绍一下update的过程吧，首先会执行当前读，然后把返回的数据加锁，之后执行update。加锁是防止别的事务在这个时候对这条记录做什么，默认加的是排他锁，也就是你读都不可以，这样就可以保证数据不会出错了。但注意一点，就算你这里加了写锁，别的事务也还是能访问的，是不是很奇怪？数据库采取了一致性非锁定读，别的事务会去读取一个快照数据。
innodb默认隔离级别是RR， 是通过MVVC来实现了，读方式有两种，执行select的时候是快照读，其余是当前读，所以，mvvc不能根本上解决幻读的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28493f4fa499aceade00442963e2d542/" rel="bookmark">
			LayaAir学习笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LayaAir学习笔记（一） 前言环境搭建一、语言选择一、IDE安装二、环境搭建 前言 我是一个Unity开发者，各方面的原因开始对APP游戏及微信小程序产生了兴趣，于是打算学习一下，因为LayaAir思维模式和Unity比较相近，在移动端的表现以及与原生的混合开发都有更好的解决方案，废话不多说。
环境搭建 一、语言选择 语言优点缺点推荐AS3·LayaAir1.0引擎开发语言
·好用·新特性支持不友好
·AS3版本停止维护as3程序员TypeScript·官方推荐语言
·JS的超类（JS文件用TS命名不报错）
·新特性支持好新手+官方推荐JavaScript·动态语言
·上手快·项目体量越大，越难维护
·动态语言缺陷–编译时才检查语法（ 难 维 护 的 原 因 \color{red}{难维护的原因} 难维护的原因） 一、IDE安装 按照自己个实际情况选择自己合适的语言，选择对应的引擎下载
引擎下载
二、环境搭建 这里以TS为例，按照上面的建议TS比较适合我
1.安装Node.js，找到刚刚下载的Node.js安装包，一步一步的安装即可。
2.安装完Node.js后，接着就可以使用NPM来安装TypeScript Compiler，之后就能通过这个Compiler来将TypeScript编译成为JavaScript。在这个步骤里，开发者需要打开cmd命令行工具，输入指令“npm install -g typescript”，按回车键后，即可开始进行TypeScript Compiler的安装。
3.如果中途安装出错，可以在命令行中再次输入指令“npm install -g typescript”，重新安装。如果还是有错，可以通过输入指令“npm uninstall -g typescript”先卸载。然后再输入安装指令。
4.检查TypeScript编译环境版本，在命令行输入“tsc -v” 命令可查看当前TypeScript编译的版本。
5.我是Windows开发所以Mac 可能会遇到一些问题，这里无法提供帮助了。
那么就可以开始探索了，比较简单就简单记录一下，有疑问可以给我留言。明天来更新学习进度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/095133264c095e25cc33c24308bf8d19/" rel="bookmark">
			引发的异常: 0xC0000005: 读取位置 0x0000000000000008 时发生访问冲突
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行环境：windows10 opencv3.2 virsual studio2015
问题描述：在Debug下调试运行正常，但是在Release模式下报错：0x00007FF8FFA61CE7 (opencv_world320d.dll)处(位于 myproject.exe 中)引发的异常: 0xC0000005: 读取位置 0x0000000000000008 时发生访问冲突。例如下图所示：
Release模式适合批量处理，速度是Debug模式下的N倍。
解决办法：删除vs2015中release模式附加依赖项中类似“opencv_xxxd.dlib”的项，因为名称带“d”是Debug模式下需要的，release下不能用。右键——解决方案——属性——配置设置成“活动（Release）”——连接器——输入——附加依赖库——选中后面方格里内容——删除带“d”的lib库和分号
在这里插入图片描述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97bb7e855f777a4636d48c31a99d20d/" rel="bookmark">
			面向过程与面向对象编程区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向过程与面向对象编程区别 面向过程 1.概念： 以时间为中心，把解决问题的步骤分析出来，然后按顺序调用函数一步一步实现
面向对象方法的基础实现中也包含面向过程的思想
2.特性 模块化
流程化
3.优势 ①性能相较面向对象较高
类调用的时候需要实例化，因此开销大，比较消耗资源（eg：片机、嵌入式开发、Linux/Unix等一般采用面向过程开发）
性能是需要关注的主要因素
②流程化的编程，具体步骤和每个步骤系要完成的任务明确清晰，在开发之前基本考虑了实现方式和最终结果，便于节点分析
③效率高，强调代码的短小精悍，善于结合数据结构来开发高效率的程序。
4.劣势 需要深入的思考，耗费精力，代码重用性低，后期不易维护、不易扩展
。
面向对象 1.概念 当问题规模变得更大，面向过程的思想显然不够用。世界上的人和事物都可以看做一个对象，都有属于自己的的属性和特定行为，对象与对象之间通过方法来交互。简单来说就是靠属性+方法实现。
面向对象是一种以“对象”为中心的编程思想，把要解决的问题分解成各个对象，各个对象之间交互，完成事件，解决问题。
编程建立对象，描叙某个对象在整个解决问题的步骤中的属性和行为，而不是为了完成一个步骤。
2.特性 抽象
封装
继承
多态
3.优势： ①结构清晰，整个程序设计是结构化和模块化的，更符合人类的思维方式。
②易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护（系统低耦合的特点有利于减少程序的后期维护工作量）。
4.劣势： ①性能比面向过程低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。
②开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。
两者对比 最本质的区别 两者的结合方式不同
用两个例子来说明：
①蛋炒饭和盖浇饭问题 主要表现在粒度上
蛋炒饭的粒度只能是饭粒,即使添加再多东西也只是量不同而行相似的同种粒子
而盖浇饭的粒度是分结构和层次的,比如 饭粒 菜片 一碗饭 一碗菜 饭菜合在一起又是一个粒度
②下五子棋问题
以面向过程设计，整个思路是分析这个问题的解决步骤：
（1）开始游戏（2）黑子先走（3）绘制画面（4）判断输赢（5）轮到白子（6）绘制画面（7）判断输赢（8）返回步骤（2） （9）输出最后结果。
按照编程语言，依次调用函数实现：
下五子棋{ 开始游戏（）； 黑子先走（）； 绘制画面（）； 判断输赢（）； 轮到白子（）； 绘制画面（）； 判断输赢（）； 返回到 黑子先走（）； 输出最后结果； } 就是一个流程,循环的过程直到结束 整个程序是一个平面结构平面
以面向对象设计下五子棋，我们就要先划分出整个问题解决过程中涉及到的对象（三个：黑白棋子、棋盘系统、五子棋规则系统）：
（1）黑白棋子：用于下子这一行为
（2）棋盘系统：用于绘制下棋的画面
（3）五子棋规则系统：用于判断输赢、双方走棋是否合乎规范
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f97bb7e855f777a4636d48c31a99d20d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4764c2e11005e4b24e5e8f4834e4095/" rel="bookmark">
			完全卸载Android Studio(卸载得干干净净)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤其实很简单，一共三步，但是每一步都需要完成，步骤如下：
第一步：打开控制面板执行常规的卸载操作。
第二步：找到SDK的安装目录手动删除SDK。
第三步：进入“C:\Users&lt;你的用户名下&gt;”目录下，手动删除".android"、".AndroidStudioX.X"、".gradle"目录（比如我登陆电脑时的用户名是：lenovo，那么则来到C:\Users\lenovo目录下进行卸载）
搞定,done
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/744ff7fdbdf9e50f14dc6edfe7025d4d/" rel="bookmark">
			【zz】webrtc线程模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#- 转载 作者
webrtc的base的 thread，是我见过的封装最帅的c++线程库，根据比qt的还好用,发个例子给你
using namespace webrtc; using namespace rtc; //std::cout&lt;&lt;"Thread::Current()：" &lt;&lt; Thread::Current()-&gt;GetId(); //Thread::Current()-&gt;Start(); 不能调用start，因为不是我创建的，他已经开始了 //Thread::Current()-&gt;Run(); //阻塞当前线程进入线程循环 Thread * thread = new Thread(); //MyRunnable run; //thread-&gt;Start(&amp;run);//可以带一个Runnable参数运行,运行完就结束，否则运行Thread::Run进入消息循环 thread-&gt;Start(); //std::cout &lt;&lt; "Thread::Invoke()："&lt;&lt; thread-&gt;Invoke&lt;bool&gt;(RTC_FROM_HERE, &amp;task)&lt;&lt; " at " &lt;&lt; Thread::Current()-&gt;GetId() &lt;&lt; std::endl; thread-&gt;Post(RTC_FROM_HERE, Bind(task2));//将最常用的 auto handler= new MessageClient; //thread-&gt;PostAt(RTC_FROM_HERE, (int64_t)3000,handler); //thread-&gt;PostDelayed(RTC_FROM_HERE, (int64_t)5000, handler); //thread-&gt;Stop(); Thread * thread2 = new Thread(); thread2-&gt;Start(); thread2-&gt;Post(RTC_FROM_HERE, Bind(task2));//将最常用的 //thread2-&gt;Invoke() 非常有用，在任何地方可以指定我的代码运行在某个线程 //api下的proxy机制，实际上就是设置要执行的线程，然后加锁等待线程执行结果。这是我设计对外接口可以在任何线程调用而不出错的常用方法
//base的asyncinvoker与proxy类似的机制。
有ios的gdc，android的handler异曲同工
因为编写复杂稳定的多线程C++项目实在太难，所以一个好的跨平台C++基础库是我最求的目标,目前比较欣赏的项目有：
Boost:大而全，缺少一些可以直接上手的东西如线程消息队列，智能指针并非线程安全。 QT core：非常好 C++11：也需要线程消息队列，线程安全智能指针。 chromium的base库：太大了 当我看到webrtc的base时，非常惊讶的发现它正是我想要的,特点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/744ff7fdbdf9e50f14dc6edfe7025d4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1801ea5f1630b676beb85c98f5c6824/" rel="bookmark">
			大数据上云第一课：MaxCompute授权和外表操作躲坑指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、子账号创建、AK信息绑定
如果您是第一次使用子账号登录数加平台和使用DataWorks，需要确认以下信息：
• 该子账号所属主账号的企业别名。
• 该子账号的用户名和密码。
• 该子账号的AccessKey ID和AccessKey Secret。
• 确认主账号已经允许子账号启用控制台登录。
• 确认主账号已经允许子账号自主管理AccessKey。
1、子账号创建
（1）创建子账号
（2）绑定AK信息
（3）DataWorks给定角色
（1）使用阿里云账号（主账号）登录RAM控制台。
（2）在左侧导航栏的人员管理菜单下，单击用户。
（3）单击新建用户。
（4）输入登录名称和显示名称。
（5）在访问方式区域下，选择控制台密码登录。
（6）单击确认。
说明： （1）单击添加用户，可一次性创建多个RAM用户。 （2）RAM用户创建完成后，务必保存用户名和登录密码，并将其告知子账号。 2、创建RAM子账号的访问密钥
访问密钥对开发人员在DataWorks中创建的任务顺利运行非常重要，该密钥区别于登录时填写的账号和密码，主要用于在阿里云各产品间互相认证使用权限。因此主账号需要为子账号创建AccessKey。创建成功后，请尽可能保证AccessKey ID和AccessKey Secret的安全，切勿让他人知晓，一旦有泄漏的风险，请及时禁用和更新。运行密钥AK包括AccessKey ID和AccessKey Secret两部分。如果云账号允许RAM用户自主管理AccessKey，RAM用户也可以自行创建AccessKey。
为子账号创建AccessKey的操作如下所示。
（1）在左侧导航栏的人员管理菜单下，单击用户。
（2）在用户登录名称/显示名称列表下，单击目标RAM用户名称。
（3）在用户AccessKey 区域下，单击创建新的AccessKey。
（4）单击确认。
说明： 首次创建时需填写手机验证码。 AccessKeySecret只在创建时显示，不提供查询，请妥善保管。若AccessKey泄露或丢失，则需要创建新的AccessKey，最多可以创建2个AccessKey。 3、给RAM子账号授权
如果您需要让子账号能够创建DataWorks工作空间，需要给子账号授予AliyunDataWorksFullAccess权限。
（1）在左侧导航栏的人员管理菜单下，单击用户。
（2）在用户登录名称/显示名称列表下，找到目标RAM用户。
（3）单击添加权限，被授权主体会自动填入。
（4）在左侧权限策略名称列表下，单击需要授予RAM用户的权限策略。
（5）单击确定。
（6）单击完成。
说明：在右侧区域框，选择某条策略并单击×，可撤销该策略。 二、子账号生产环境创建函数、访问资源授权，OSS外部表授权
1、账号生产环境创建函数、访问资源授权
子账号登录DataWorks控制台之后，单击工作空间管理，成员管理给该子账号一个相应的角色。各角色对应的权限可以在工作空间管理界面的权限列表查看。此处添加的成员角色对生产环境是隔离的。下面介绍一下生产环境创建函数、访问资源授权。
（1）创建一个新的角色，给角色授权。
创建角色:create role worker; 角色指派:grant worker TO ram$建伟MaxCompute:banzhan;（ram$建伟MaxCompute:banzhan为RAM账号） 对角色授权:grant CreateInstance, CreateResource, CreateFunction, CreateTable, List ON PROJECT wei_wwww TO ROLE worker; （2）创建UDF函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1801ea5f1630b676beb85c98f5c6824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79086c4e77ee5594b5f4c3689400e7f9/" rel="bookmark">
			mybatis入门小项目(含目录结构与sql语句)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录结构 第一步 : 配置Pom文件 加载mybatis与mysql等依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.tong&lt;/groupId&gt; &lt;artifactId&gt;mybatis02&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 第二步 : 加入log4j.properties文件 log4j.rootLogger=DEBUG, Console #Console log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n log4j.logger.java.sql.ResultSet=INFO log4j.logger.org.apache=INFO log4j.logger.java.sql.Connection=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j. 第三步 : 创建数据库 create database dir; use dir; create table UserInfo ( userId int not null auto_increment, userName varchar(32) not null comment '用户名', userSex varchar(20) not null comment '性别', primary key (userId) ); insert into UserInfo (userId,userName,userSex) values (1,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79086c4e77ee5594b5f4c3689400e7f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e207bc5f6acb29d1431ad803373e811c/" rel="bookmark">
			基础sql语言-增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新增表数据
INSERT INTO [TABLE_NAME] (column1, column2, column3,...columnN) VALUES (value1, value2, value3,...valueN); 例：insert into person(id,name,age,phone,address) values (1,'yang',22,'123232323','中国上海');
2.删除表数据
DELETE FROM [table_name] WHERE [condition]; 例：delete from person where id = 1;
3.修改表数据
UPDATE [table_name] SET column1 = value1, column2 = value2....WHERE [condition]; 例：update person set address='浙江杭州' where id = 1;
4.查询表数据
Where语句，用于筛选查询出来的数据集，指定的条件语句中可以使用基本的算术、关系和逻辑运算，例如：&gt;,&lt;,=,!=,&amp;&amp;,||。
例: 查询年龄为22的年轻人
select * from person where name='yang'&amp;&amp; age=22; LIKE 子句，一般用来做一些简单的搜索查询，或者说模糊匹配，表达式主要涉及到两个符号：百分号 %：匹配任意多个字符，下划线 _：匹配固定一个字符。
例：查询所有的数据，找到其中 name 字段以字符「ang」结尾的数据记录集合：
select * from person where name like '%ang'; 查询所有的数据，找到其中 name 字段以字符「ang」结尾，并且前面还有一个任意字符的数据记录集合：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e207bc5f6acb29d1431ad803373e811c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d0a2c4b0d98affe6618ef4ea9e854a/" rel="bookmark">
			[Vue warn]: Duplicate keys detected: &#39;0&#39;. This may cause an update error.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Vue warn]: Duplicate keys detected: ‘0’. This may cause an update error.
刚开始看到这个问题我还有点奇怪，因为只在for循环哪里用到了key属性，后面查了下发现是同级v-for的key值一样造成报错。
控制台报错：
报错代码：
修改后代码
补充：如果有大神路过知道是什么原理请在评论区指点一下，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b3813253d27c7beb2ac61d0d305eff/" rel="bookmark">
			微信扫一扫调用失败解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现实项目中业务需要开发微信公众号，业务场景其中有需求要使用微信扫一扫，奇怪的问题产生了，第一次进入页面的时候调用成功没有问题，当做别的操作之后，在点击调用微信扫一扫 发现无路如何都调用不起来了。
微信JS-SDK说明文档官网 http://caibaojian.com/wxwiki/0030551f015f01ecaa56d20b88ee3c6cb32503bf.html#JSSDK.E4.BD.BF.E7.94.A8.E6.AD.A5.E9.AA.A4
在微信JS-SDK说明文档官网 找了很久也没有跟我相同的案例，多番测试之后发现是URL 的问题才导致了调用微信扫一扫调用不起来了 ，下面用我的例子来说明情况
第一次进入页面时，点击扫描后打印出来的URL 是没有拼接任何的参数，这个时候去调用微信扫一扫是成功的没有问题的
奇怪的问题产生了 当做别的操作之后，在点击调用微信扫一扫 发现无路如何都调用不起来了，原因就是因为的请求URL中 拼接了其他的参数，这样就导致了微信解析我的URL 的解析失败，因为我们调用微信端的接口值其实微信还要在我们的URL中拼接一些其他的参数，所以在这里就明白到了 调用微信扫一扫时 URL 不允许拼接有任何的参数。
本人解决方案 在增加一个刷新按钮 重定向URL 这样调用微信扫一扫就可以成功了
点击刷新后重定向的URL 完整的jsp
&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;%@include file="/context/mytags.jsp"%&gt; &lt;%-- &lt;t:base type="jquery,easyui,tools,DatePicker"&gt;&lt;/t:base&gt; --%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;上架列表&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" /&gt; &lt;!-- 引入 WeUI --&gt; &lt;link rel="stylesheet" href="&lt;%=basePath%&gt;/webpage/WeChat/weui-master/dist/style/weui.min.css" /&gt; &lt;style type="text/css"&gt; .checkname { width: 30%; border-radius: 5px; height: 30px; color: gray; } /* 签收按钮 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b3813253d27c7beb2ac61d0d305eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/981a67e3b3428b0b7921559c07896109/" rel="bookmark">
			vue 只要一杯卡布奇诺时间，就能简单上手的Dialog对话框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来，效果图
文件结构 首先，你在vue的项目里面，找个合适的位置创建一个文件夹，创建一个vue的文件以及一个js文件
代码如下：
myDialog.vue &lt;template&gt; &lt;div class="my-dialog" v-if="visible"&gt; &lt;div class="my-dialog-wrap"&gt; &lt;div class="my-dialog-title"&gt; &lt;span&gt;{{title}}&lt;/span&gt; &lt;div v-if="showCloseBtn" @click="close" class="my-dialog-btn my-close-btn"&gt;&lt;/div&gt; &lt;/div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props:{ visible: { type: Boolean, default: false }, showCloseBtn: { type: Boolean, default: true }, title: { type: String, default: '' } }, methods:{ close(){ this.$emit('closeDia', false); } } } &lt;/script&gt; &lt;style scoped&gt; .my-dialog{ position: fixed; top: 0; left: 0; z-index: 99999; width: 100%; height: 100%; background-color: rgba(24, 24, 24, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/981a67e3b3428b0b7921559c07896109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cf777f8387fbacc5f8708fa2590a4a3/" rel="bookmark">
			over()分析函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个函数长这个样子：OVER(PARTITION BY… ORDER BY…)
顾名思义，PARTITION 中文是分割的意思，ORDER 是排序的意思，所以翻译一下就是先把一组数据按照制定的字段进行分割成各种组，然后组内按照某个字段排序。
在使用 row_number() over()函数时候，over()里头的分组以及排序的执行晚于 where 、group by、 早于order by 的执行。
伪列ROWNUM
常用的分析函数如下所列：
- row_number() over(partition by ... order by ...)	--分组排序 - rank() over(partition by ... order by ...)	--分组排序 - dense_rank() over(partition by ... order by ...)	--分组排序 - count() over(partition by ... order by ...)	--分组计数 - max() over(partition by ... order by ...) --分组取最大值 - min() over(partition by ... order by .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cf777f8387fbacc5f8708fa2590a4a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d7c4f466b1beaa93d59835d6d385987/" rel="bookmark">
			矩阵乘法和矩阵快速幂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 摘要矩阵矩阵乘法矩阵快速幂矩阵乘法的应用 摘要 本文主要讲解矩阵乘法和矩阵快速幂。内容不难，都是定理，重点是矩阵乘法的应用。
蓝桥杯知识点汇总：
https://blog.csdn.net/GD_ONE/article/details/104061907
矩阵 数学上，一个 m × n {\displaystyle m\times n} m×n的矩阵是一个由 m m m行（row）n列（column）元素排列成的矩形阵列。矩阵里的元素可以是数字、符号或数学式。以下是一个由6个数字元素构成的2行3列的矩阵：
[ 1 9 − 13 20 5 − 6 ] {\displaystyle {\begin{bmatrix}1&amp;9&amp;-13\\20&amp;5&amp;-6\end{bmatrix}}} [120​95​−13−6​]
-------引用自维基百科。
知道了矩阵是什么后，看看什么是矩阵乘法。
矩阵乘法 数学中，矩阵乘法（英语：matrix multiplication）是一种根据两个矩阵得到第三个矩阵的二元运算，第三个矩阵即前两者的乘积，称为矩阵积（英语：matrix product）。设 A {\displaystyle A} A是 n × m {\displaystyle n\times m} n×m的矩阵， B {\displaystyle B} B是 m × p {\displaystyle m\times p} m×p的矩阵，则它们的矩阵积 A B {\displaystyle AB} AB是 n × p {\displaystyle n\times p} n×p的矩阵。 A {\displaystyle A} A中每一行的 m {\displaystyle m} m个元素都与 B {\displaystyle B} B中对应列的 m {\displaystyle m} m个元素对应相乘，这些乘积的和就是 A B {\displaystyle AB} AB中的一个元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d7c4f466b1beaa93d59835d6d385987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908093b9a0e6ffc9748af6f2349ab680/" rel="bookmark">
			目标检测应用竞赛 | 天池铝型材表面瑕疵（含数据集、详细解决方案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“AI算法修炼营”，选择加星标或“置顶”
标题以下，全是干货
目标检测应用竞赛——天池铝型材表面瑕疵 数据集下载链接：
https://tianchi.aliyun.com/competition/entrance/231682/information
数据介绍：在铝型材的实际生产过程中，由于各方面因素的影响，铝型材表面会产生裂纹、起皮、划伤等瑕疵，这些瑕疵会严重影响铝型材的质量。为保证产品质量，需要人工进行肉眼目测。然而，铝型材的表面自身会含有纹路，与瑕疵的区分度不高。传统人工肉眼检查十分费力，不能及时准确的判断出表面瑕疵，质检的效率难以把控。近年来，深度学习在图像识别等领域取得了突飞猛进的成果。铝型材制造商迫切希望采用最新的AI技术来革新现有质检流程，自动完成质检任务，减少漏检发生率，提高产品的质量，使铝型材产品的生产管理者彻底摆脱了无法全面掌握产品表面质量的状态。
大赛数据集里有1万份来自实际生产中有瑕疵的铝型材监测影像数据，每个影像包含一个或多种瑕疵。供机器学习的样图会明确标识影像中所包含的瑕疵类型。
解决方案与答辩情况 这是在天池大数据平台上一个比赛的决赛答辩笔记。比赛的名字：广东工业制造大数据创新大赛，智能算法赛。比赛的初赛是分类，物体识别；复赛：目标检测。 视频地址：https://b23.tv/av66819151
第一组 shuzhilian ai 1 模型：faster rcnn + fpn + cascade basebone：resnet152
2 数据：原始的数据分布不平衡，用了图像处理的方法将每一类做到了5000张。大体上分为两种数据集，有瑕疵的一类，无瑕疵的10类。各种类别之间的瑕疵规格相差很大，类别内的瑕疵大小规格相差也没有规律。
3 创新点
（1）多阶段的训练：先是用负样本来训练模型，然后用正样本验证学到的模型，最后将正样本中训练错误的和负样本一起来训练模型。
（2）Scale Normalization for training : 使用rpn 。理由：缺陷里面有很多正确的纹理，这些正确的纹理将会是判别缺陷的噪音。所以使用一个合适大小的框来减少这种噪音。
（3）cascade结构
4 项目落地：
1 时间太长（多尺度输入） 2 自动检测，增量学习，重新训练。 3 充分运用云（1流失处理，2灵活调度，3松耦合高内聚，4日志收集）
5 问答
1 改进三部分哪一个部分提升的效果最好？cascade 结构
2 cascade为什么会表现更好，它可能不会收敛？ 因为在级联前它保存了传统的方法，只是在传统的结构上加了额外的级联结构，所以可以在调参后收敛。
3 cascade结构中每一级都是哪些样本进入到了该级？按照阈值来决定那些样本来进入该级
4 cascade结构是怎么样来划分每一级的正负样本的？端到端训练的。（答辩的人没有说出来，其实论文中讲到阈值其实也就决定了正负样本。和上一个问题基本上是一样的。）
5 负样本是怎么取的？负样本对于提升有多大？77.8%，加上以后就是80.3%。
6 图像增强的时候，数据量增加到多少能达到一个最终的结果，这时增加图片就没有提升效果了？这要看数据集的复杂度，平常做的上下翻转，高斯模糊等等不能够做的太多，如果做的太多实际上训练样本对于最终的真实样本分布已经不一致了。复杂度小，增强小，复杂度高，增强多。这次做了一些的尝试，最后定在了4000到5000张左右。
第二组 风不动 1 模型：backbone：resnet101（快速版本），两阶段模型Faster rcnn。模型版本：快速模型到最高精度模型的比较，基模型的数量从1达到了4；从单尺度测试改为6尺度测试；框的过滤阈值从0.05降低到0.01。
2 数据分析：图片分辨率高，缺陷的尺寸差异大，瑕疵的形状不规则，标注不贴合 。
出发点
（1）由于缺陷长款比例分布不均匀采用两阶段回归，适应更多长宽比。
（2）由于缺陷尺度分布差异大，采用FPN结构适应更多的大小尺度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/908093b9a0e6ffc9748af6f2349ab680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f741c55d824a57279d0698374213d487/" rel="bookmark">
			统计字符串中大小写字母的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 统计字符串中大小写字母的个数 分别统计字符串中大写字母和小写字母的个数。 函数接口定义：
void fun ( char *s, int *a, int *b );
其中s、a、b 都是用户传入的参数。函数统计指针s所指字符串中大写字母和小写字母的个数，并通过形参a和b传回。
裁判测试程序样例： #include &lt;stdio.h&gt;
void fun( char *s, int *a, int *b );
int main( )
{ char s[100]; int upper=0, lower=0 ;
gets ( s );
fun ( s, &amp;upper, &amp;lower );
printf( “upper=%d lower=%d\n”, upper, lower );
return 0;
}
/ *请在这里填写答案 */
输入样例：
123abcDR5s
输出样例；
upper=2 lower=4
答案:
void fun( char *s, int *a, int *b ){ int i,j; i=0; j=0; while(*s){ if(*s&gt;='A'&amp;&amp;*s&lt;='Z')/ *判断是否为大写字母/ * i++; else if(*s&gt;='a'&amp;&amp;*s&lt;='z')/ *判断是否为小写字母/ * j++; *s++; } *a=i;/ *把i的值赋值给指针a/ * *b=j; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c52f4ee1d40e3c32ab2b83c950772d85/" rel="bookmark">
			找最大值及其下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 找最大值及其下标 在一维整型数组中找出其中最大的数及其下标。 函数接口定义：
int fun(int *a,int *b,int n);
其中形参a 、b、n都是用户传入的参数。函数fun的功能是在指针a所指向的一维数组中找出其中最大的数及其下标，下标存到指针b所指的变量里，函数返回最大值。
裁判测试程序样例： #include&lt;stdio.h&gt;
#define N 10
int fun(int *a,int b,int n);
int main()
{ int a[N],i,max,p=0;
for(i=0;i&lt;N;i++) scanf("%d",&amp;a[i]);
max=fun(a,&amp;p,N);
printf(“max=%d,position=%d\n”,max,p);
return 0;
}
/ 请在这里填写答案 */
输入样例：
2 1 5 4 8 4 5 8 9 1
输出样例：
max=9,position=8
答案：
int fun(int *a,int *b,int n){ int i,max,d; max=a[0]; for(i=0;i&lt;N;i++) if(a[i]&gt;a[i+1]) { max=a[i]; d=i; / * 记录下最大值下标/ * } / *找出最大值/ * *b=d;/ *把最大值下标赋值给指针b/ * return max; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d95036a76fed143c6a3271f7d8862e6/" rel="bookmark">
			以下程序的功能是输入一个字符串和一个字符，如果该字符在字符串中，就从该字符首次出现的位置开始输出字符串中的字符。例如，如果输入的字符串为“Hello”，输入的字符为’e’，则输出结果为“ello”。请
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下程序的功能是输入一个字符串和一个字符，如果该字符在字符串中，就从该字符首次出现的位置开始输出字符串中的字符。例如，如果输入的字符串为“Hello”，输入的字符为’e’，则输出结果为“ello”。请填空。 此处输入答案 match(char *s, char ch) {
while (*s != ‘\0’)
if (*s == ch)此处输入答案;
else s++;
此处输入答案
}
int main()
{
char ch, str[80], *p = NULL;
scanf("%s", str);
getchar();
ch = getchar();
if ((p = match(str, ch)) != NULL)
printf("%s\n", p);
else
printf(“Not Found\n”);
return 0;
}
答案：
char match(char *s, char ch) { while (*s != '\0') if (*s == ch)break; else s++; return s; } int main() { char ch, str[80], *p = NULL; scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d95036a76fed143c6a3271f7d8862e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffabfac531c0b66e74999fc4cd9deb5c/" rel="bookmark">
			使用函数实现字符串部分复制.本题要求编写函数，将输入字符串t中从第m个字符开始的全部字符复制到字符串s中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用函数实现字符串部分复制 (20分) 本题要求编写函数，将输入字符串t中从第m个字符开始的全部字符复制到字符串s中。 函数接口定义： void strmcpy( char *t, int m, char *s );
函数strmcpy将输入字符串char *t中从第m个字符开始的全部字符复制到字符串char *s中。若m超过输入字符串的长度，则结果字符串应为空串。
裁判测试程序样例：
#include &lt;stdio.h&gt; #define MAXN 20 void strmcpy( char *t, int m, char *s ); void ReadString( char s[] ); /* 由裁判实现，略去不表 */ int main() { char t[MAXN], s[MAXN]; int m; scanf("%d\n", &amp;m); ReadString(t); strmcpy( t, m, s ); printf("%s\n", s); return 0; } / * 你的代码将被嵌在这里 * / 输入样例：
7
happy new year
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffabfac531c0b66e74999fc4cd9deb5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81541b1b44d94025b6fabbe22d1de19/" rel="bookmark">
			C51 学习笔记03 | 8051单片机几大功能组成部件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8051单片机属于冯·诺依曼型结构，其内部主要包括以下几大功能部件。各个部分通过内部总线相连接。
1、中央处理器（CPU）
CPU是单片机的核心，它是8位数据宽度的处理器，能处理8位二进制数据或代码其主要任务是负责控制、指挥和调度整个系统协调工作，完成运算和控制功能。
2、程序存储器（ROM）
片内程序存储器大小为4KB，主要用于存放程序代码、原始数据和表格。但也有一些单片机内部不带ROM，如8031、80C31等。
3、数据存储器（RAM）
片内有128个8位用户数据存储单元，用以存放可以随时读/写的数据，如运算的中间结果、临时数据等。另外，内部还有128个专用寄存器（8位）单元，用于配置单片机的内部各个功能部件或存放一些控制指令数据。
4、并行输入/输出（I/O）口
四个8位并行I/O口，分别为P0、P1、P2、P3，每个口既可以用作输入口，也可以用作输出口。
5、定时/计数器
两个16位定时/计数器T0和T1,可用作定时器或计数器使用，通过编程配置可工作于4种不同的工作模式下。
6、中断系统
五个中断源的中断控制系统，包括：两个外部中断（INT0和INT1）和三个内部中断（定时/计数器T0、T1及串口中断）。每个中断源均可设置为高优先级或低优先级。
7、串行通信接口
一个全双工通用异步接收发送器（Universal Asynchronous Receiver/Transmiter, UART）串行I/O口，可实现单片机与单片机之间或其他微机之间的串行数据通信。
8、时钟电路
片内振荡器和时钟产生电路，但石英晶体和微调电容需要外接，最高允许振荡频率为12MHz。用于产生整个单片机运行的脉冲时序，对单片机的运行速度起着决定性的作用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5edb0ff39a4d88bdf84e015f716835b9/" rel="bookmark">
			php抽奖概率算法（适合大转盘等概率）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?php /* * 经典的概率算法， * $proArr是一个预先设置的数组， * 假设数组为：array(100,200,300，400)， * 开始是从1,1000 这个概率范围内筛选第一个数是否在他的出现概率范围之内， * 如果不在，则将概率空间，也就是k的值减去刚刚的那个数字的概率空间， * 在本例当中就是减去100，也就是说第二个数是在1，900这个范围内筛选的。 * 这样 筛选到最终，总会有一个数满足要求。 * 就相当于去一个箱子里摸东西， * 第一个不是，第二个不是，第三个还不是，那最后一个一定是。 * 这个算法简单，而且效率非常高， * 这个算法在大数据量的项目中效率非常棒。 */ function get_rand($proArr) { $result = ''; //概率数组的总概率精度 $proSum = array_sum($proArr); //概率数组循环 foreach ($proArr as $key =&gt; $proCur) { $randNum = mt_rand(1, $proSum); if ($randNum &lt;= $proCur) { $result = $key; break; } else { $proSum -= $proCur; } } unset ($proArr); return $result; } /* * 奖项数组 * 是一个二维数组，记录了所有本次抽奖的奖项信息， * 其中id表示中奖等级，prize表示奖品，v表示中奖概率。 * 注意其中的v必须为整数，你可以将对应的 奖项的v设置成0，即意味着该奖项抽中的几率是0， * 数组中v的总和（基数），基数越大越能体现概率的准确性。 * 本例中v的总和为100，那么平板电脑对应的 中奖概率就是1%， * 如果v的总和是10000，那中奖概率就是万分之一了。 * */ $prize_arr = array( '0' =&gt; array('id'=&gt;1,'prize'=&gt;'平板电脑','v'=&gt;1), '1' =&gt; array('id'=&gt;2,'prize'=&gt;'数码相机','v'=&gt;5), '2' =&gt; array('id'=&gt;3,'prize'=&gt;'音箱设备','v'=&gt;10), '3' =&gt; array('id'=&gt;4,'prize'=&gt;'4G优盘','v'=&gt;12), '4' =&gt; array('id'=&gt;5,'prize'=&gt;'10Q币','v'=&gt;22), '5' =&gt; array('id'=&gt;6,'prize'=&gt;'下次没准就能中哦','v'=&gt;50), ); /* * 每次前端页面的请求，PHP循环奖项设置数组， * 通过概率计算函数get_rand获取抽中的奖项id。 * 将中奖奖品保存在数组$res['yes']中， * 而剩下的未中奖的信息保存在$res['no']中， * 最后输出json个数数据给前端页面。 */ foreach ($prize_arr as $key =&gt; $val) { $arr[$val['id']] = $val['v']; } $rid = get_rand($arr); //根据概率获取奖项id $res['yes'] = $prize_arr[$rid-1]['prize']; //中奖项 unset($prize_arr[$rid-1]); //将中奖项从数组中剔除，剩下未中奖项 shuffle($prize_arr); //打乱数组顺序 for($i=0;$i&lt;count($prize_arr);$i++){ $pr[] = $prize_arr[$i]['prize']; } $res['no'] = $pr; print_r($res); ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5edb0ff39a4d88bdf84e015f716835b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93415aa2054835101831051f893b736/" rel="bookmark">
			数学建模及其算法概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数学模型的分类 1. 按模型的数学方法分： 几何模型、图论模型、微分方程模型、概率模型、最优控制模型、规划论模型、马氏链模型等。
2. 按模型的特征分： 静态模型和动态模型，确定性模型和随机模型，离散模型和连续性模型，线性模型和非线性模型等。
3. 按模型的应用领域分： 人口模型、交通模型、经济模型、生态模型、资源模型、环境模型等。
4. 按建模的目的分： 预测模型、优化模型、决策模型、控制模型等。一般研究数学建模论文的时候，是按照建模的目的去分类的，并且是算法往往也和建模的目的对应。
5. 按对模型结构的了解程度分： 有白箱模型、灰箱模型、黑箱模型等。比赛尽量避免使用，黑箱模型、灰箱模型，以及一些主观性模型。
6. 按比赛命题方向分： 国赛一般是离散模型和连续模型各一个，2016 美赛六个题目（离散、连续、运筹学/复杂网络、大数据、环境科学、政策）
二、数学建模十大算法 1、蒙特卡罗算法
该算法又称随机性模拟算法，是通过计算机仿真来解决问题的算法，同时可以通过模拟可以来检验自己模型的正确性，比较好用的算法。
2、数据拟合、参数估计、插值等数据处理算法
比赛中通常会遇到大量的数据需要处理，而处理数据的关键就在于这些算法，通常使用 Matlab 作为工具。
3、线性规划、整数规划、多元规划、二次规划等规划类问题
建模竞赛大多数问题属于最优化问题，很多时候这些问题可以用数学规划算法来描述，通常使用 Lindo、Lingo 软件实现
4、图论算法
这类算法可以分为很多种，包括最短路、网络流、二分图等算法，涉及到图论的问题可以用这些方法解决。
5、动态规划、回溯搜索、分治算法、分支定界等计算机算法
这些算法是算法设计中比较常用的方法，很多场合可以用到竞赛中。
6 、最优化理论的三大非经典算法：模拟退火法、神经网络、遗传算法
这些问题是用来解决一些较困难的最优化问题的算法，对于有些问题非常有帮助，算法的实现有一定困难。
7 、网格算法和穷举法
当重点讨论模型本身而轻视算法的时候，可以使用这种暴力方案，最好使用一些高级语言作为编程工具。
8 、一些连续离散化方法
很多问题都是从实际来的，数据可以是连续的，而经典计算机架构只认的是离散的数据，因此将其离散化后进行差分代替微分、求和代替积分等思想是非常重要的。
9 、数值分析算法
如果在比赛中采用高级语言进行编程的话，那一些数值分析中常用的算法。比如方程组求解、矩阵运算、函数积分等算法就需要额外编写库函数进行调用
10 、图象处理算法
赛题中有一类问题与图形有关，即使与图形无关，论文中也应该要不乏图片的。这些图形如何展示，以及如何处理就是需要解决的问题，通常使用 Matlab 进行处理
三、算法简介 1 、灰色预测模型 （ 一般 ）
解决预测类型题目。由于属于灰箱模型，一般比赛期间不优先使用。满足两个条件可用：
①数据样本点个数 6 个以上
②数据呈现指数或曲线的形式，数据波动不大
2 、微分方程模型 （ 一般 ）
微分方程模型是方程类模型中最常见的一种算法。近几年比赛都有体现，但其中的要求，不言而喻，学习过程中无法直接找到原始数据之间的关系，但可以找到原始数据变化速度之间的关系，通过公式推导转化为原始数据的关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e93415aa2054835101831051f893b736/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e92b8db5278253cd08e054d74a0b3e5/" rel="bookmark">
			公有云隐私泄露真的不可避免吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于公有云，大多数企业拒绝使用它的一个原因是安全和隐私问题。的确，公有云中存在一些无法避免的问题，前段时间层出不穷的数据泄露也说明了这一点！
那么，公有云隐私泄露问题真的很难避免吗？其实不是！以下Cloudeasy云管家将为您简要介绍一些您必须了解的有关公有云隐私的主要问题。
1.用户拥有数据，同时也要为此负责
当我们将数据上传到云服务提供商的服务器时，谁负责我们的个人信息？许多云用户对这个问题没有明确的答案。
大部分公有云服务供应商认为，即使数据上传到云中，用户还是保留着他们对数据的所有权。这就意味着，如果用户决定让云服务供应商处理他们的数据的话，他们就要对其绝对的信任。云服务供应商可能对所处理的信息在安全上负有一定的责任，但并不是全部。你可以选择不同的云服务供应商，或者不把特殊的数据上传到云中。
大多数公有云服务提供商认为，即使数据上传到云上，用户仍保留对数据的所有权。这意味着，如果用户决定让云服务提供商处理他们的数据，他们将对其拥有绝对的信任。云服务提供商可能对他们处理的信息的安全性负有一定的责任，但并非全部。您可以选择其他云服务提供商，或者不把特殊的数据上传到云中。
2.用户对数据的控制权是有限的
你会发现云服务供应商给终端用户提供的隐私选项是很有限的，这种情况很普遍，并且有可能引发问题。首先，你不是对所有数据都拥有控制权，只有一小部分是拥有特权的。其次，这些选项只能帮助你定制世界上其它人访问你的信息的方式，而你的云服务供应商仍然对这些数据有完全的访问权。作为用户，你无法阻止供应商的访问行为，因为这些是合同上有明文标注的。
您会发现，云服务提供商提供给最终用户的隐私选项是有限的。这是很常见的，可能会导致问题。首先，你不能控制所有的数据，只有一小部分是有特权的。其次，这些选项只能帮助您自定义世界上其他人如何访问您的信息，而您的云服务提供商仍然可以完全访问这些数据。作为用户，您不能阻止供应商的访问，因为这些在合同中有明确规定。
但是国内也有很多云服务商能够做到坚决不触碰用户数据隐私。例如Cloudeasy云管家代理的华为云有“坚决不碰 用户数据”的承诺。
3.数据加密才是王道
如果已经与云服务供应商签约了怎么办？不要着急，你还有一个法宝——加密。在把数据存储在云中之前，你可以对所有的敏感数据进行加密。这就给安全加上另外一层保护膜，而且控制权完全掌握在你自己的手中。这可能不得云服务供应商的喜欢，但你拥有对数据安全的完全掌控权，这就够了。
4.法律不能约束所有
不幸的是，虽然世界各地都有关于隐私的法律规定，但没有一个世界性的标准。尽管您在所有地区都受法律保护，但这可能不适用于您的数据。云服务提供商，或者最终所有的数据服务器，都受到不同的约束。所以，如果你希望当地法律在出问题时能拯救你，你必须三思而后行。
简而言之，数据安全的命运掌握在你自己手中。对于云计算的安全性，无论是公共云还是私有云，都应该准备足够的策略和应急准备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5f01a2d5439785dd9171b17268f9f6b/" rel="bookmark">
			数据结构——链表（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Leetcode第21题. 合并两个有序链表（Java实现） 解法一：最常用、也是数据结构教材中讲的例题
class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public class Solution_2 { public void mergeTwoLists(ListNode n1,ListNode n2) { ListNode newNode = new ListNode(0); //新建节点 ListNode cur = newNode;//新建头指针 while(n1!=null &amp;&amp; n2!=null) { if(n1.val &lt; n2.val) {//l3的指针指向小的节点 cur.next = n1; cur = cur.next; n1 = n1.next; }else { cur.next = n2; cur = cur.next; n2 = n2.next; } } //任一为空，直接连接另条表 if(n1 == null) { cur.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5f01a2d5439785dd9171b17268f9f6b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/444/">«</a>
	<span class="pagination__item pagination__item--current">445/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/446/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>