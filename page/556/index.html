<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d918f705d1b04d1a3df99b600abe878/" rel="bookmark">
			分析ffmpeg解析ts流信息的源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		花费一些时间，然后全部扔了。为了不忘记和抛砖引玉，特发此贴。
ffmpeg解析ts流
1.目的
打算软件方式解析出pat,pmt等码流信息
2.源代码所在位置 下载ffmpeg开源代码,官网http://ffmpeg.org/
具体代码位置libavformat/mpegts.c
3.代码分析
(a)整体分析
mpegts_read_header函数获取ts中节目信息，内部关键代码摘录如下:
seek_back(s, pb, pos);//指向码流开始位置
mpegts_open_section_filter(ts, PAT_PID, pat_cb, ts, 1);//获取pat,pmt信息，我只需要这个
//probesize / ts-&gt;raw_packet_size 检查的数据包个数
handle_packets(ts, probesize / ts-&gt;raw_packet_size);//处理码流数据包,在这里循环，得到所需信息
(b)分配并配置filter参数 static MpegTSFilter *mpegts_open_filter(MpegTSContext *ts, unsigned int pid,
enum MpegTSFilterType type)
{
MpegTSFilter *filter;
av_dlog(ts-&gt;stream, "Filter: pid=0x%x\n", pid);
if (pid &gt;= NB_PID_MAX || ts-&gt;pids[pid])
return NULL;
filter = av_mallocz(sizeof(MpegTSFilter));//分配filter
if (!filter)
return NULL;
ts-&gt;pids[pid] = filter;//总共有0-0x1fff(8191)pid(8192个,0x1fff无效)
//注意这句话
filter-&gt;type = type;
filter-&gt;pid = pid;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d918f705d1b04d1a3df99b600abe878/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48a14a36fd448695547b029c8b13a37/" rel="bookmark">
			[Android初级]自定义SeekBar样式（简单说明）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Android的组件SeekBar的使用，其实各个网上的用法也都一样，这里也是差不多的用法，但你看到我的博文，自然也要说清楚怎么个用法啦，接下来，看代码。
一 . 如上图。我们先创建布局，添加组件和他的背景等属性,主要看
android:progressDrawable="@drawable/po_seekbar" &lt;pre name="code" class="html"&gt;android:thumb="@drawable/seekbar_thumb" &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" android:paddingTop="10dp" &gt; &lt;TextView android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="自定义样式的SeekBar" /&gt; &lt;SeekBar android:id="@+id/my_seekbar" android:layout_width="fill_parent" android:layout_height="wrap_content" android:focusable="true" android:maxHeight="8dp" android:paddingLeft="16dp" android:paddingRight="16dp" android:progress="50" android:progressDrawable="@drawable/po_seekbar" android:secondaryProgress="50" android:thumb="@drawable/seekbar_thumb" /&gt; &lt;TextView android:layout_width="fill_parent" android:layout_height="wrap_content" android:text="系统自带的样式" /&gt; &lt;SeekBar android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;ProgressBar android:layout_width="fill_parent" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt; 二. 配置拖动条的背景色、进度条的填充色等，po_seekbar.xml &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;!-- 背景图 --&gt; &lt;item android:id="@android:id/background"&gt; &lt;shape&gt; &lt;solid android:color="#868F7E" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;!-- 第二进度条的背景色 --&gt; &lt;item android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e48a14a36fd448695547b029c8b13a37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd092361fa8f058433cb6fc554006879/" rel="bookmark">
			C&#43;&#43;学习笔记（十五）：vector对象在内存空间中是如何增长的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector对象在内存空间中是如何增长的
我们都知道vector对象是动态存储的，从这一点看有点像链表，可以动态的增加或减少元素。我们也知道链表中是有指针变量，专门用于存储上一个和下一个元素的地址。正是因为这两个指针的存在，我们才能做到动态的存储数据，即不用像数组那样必须事先申请好空间。链表的缺点就是不能够快速的随机访问其中元素，必须通过指针层层查找。
但是，vector既可以实现动态存储数据，而且支持快速随机访问（用下标或者指针访问元素）。对于能够用下标查找的数据类型，其存储方式必定是连续的，即每个元素紧挨着前一个元素存储。
这样对于vector来说，就会出现一个问题，我在初始定义vector的时候该给其申请多少内存空间？如果申请的很小，那么我来了新的数据改存放在哪里？如果申请的很大，我用不完，那岂不是很浪费内存空间？
当然对于vector这种标准库类型，通常我们只关心如何使用它，而不关心其实如何实现的。不过对于其在存储空间的实现方式还是了解一下比较好。
我们知道容器中元素连续存储，且容器大小是可变的，考虑向vector中添加元素会发生什么？如果没有空间容纳新的元素，容器不可能简单的将其添加到内存的其他位置，因为vector的元素必须连续存储。因此容器必须分配新的空间来保存已用的元素和新的元素。将已有元素从旧位置移动到新空间，然后添加新元素，释放旧空间。如果说我们每添加一个新的元素就执行一次这样的操作，显然性能会慢到我们不可接受。
为了避免上面的代价，标准库采用了可以减少容器空间重新分配的策略。当不得不获取新的内存空间时，vector的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，从而用来保存更多新的元素。这样，就不需要每次添加新的元素都重新分配容器的内存空间了。
vector类型提供了一些成员函数，允许我们与它的现实中内存分配部分互动。
c.capacity() 不重新分配内存空间的话，c可以保存多少元素
c.reserve(n) 分配至少能容纳n个元素的内存空间
c.shrink_to_fit() 将capacity()减少为size()相同大小。size()为vector已经保存元素个数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/680fc81408e748323024d6915f4eb5e2/" rel="bookmark">
			sql语句中as的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 as 一般用在两个地方，一个是query的时候，用来重新指定返回的column 名字 如：一个table 有个column叫 id， 我们的query是 select id from table1. 但是如果你不想叫id了，就可以重新命名，如叫 systemID 就可以这样写 select id as systemId from table1; 还有一个用法就是在create table 或 procedure 的时候，as 是个关键字。 例如 create table test as select * from table1 这时候就会create 一个table test，他是完全copy table table1里的全部数据。 create procdure name as （is） begin end; 具体可以参考 如何建立procedure。 这个时候 as 和is可以互换。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450ab448d35ee664adef60f592fa7da7/" rel="bookmark">
			open和fopen的区别：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		open和fopen的区别：
1.缓冲文件系统
缓冲文件系统的特点是：在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”， 装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存 “缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器 而定。
fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等
2.非缓冲文件系统
缓冲文件系统是借助文件结构体指针来对文件进行管理，通过文件指针来对文件进行访问，既可以读写字符、字符串、格式化数据，也可以读写二进制数 据。非缓冲文件系统依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度 快，由于ANSI标准不再包括非缓冲文件系统，因此建议大家最好不要选择它。本书只作简单介绍。open, close, read, write, getc, getchar, putc, putchar 等。
open 是系统调用 返回的是文件句柄，文件的句柄是文件在文件描述副表里的索引，fopen是C的库函数，返回的是一个指向文件结构的指针。
fopen是ANSIC标准中的C语言库函数，在不同的系统中应该调用不同的内核api linux中的系统函数是open，fopen是其封装函数，个人观点。仅供参考。
文件描述符是linux下的一个概念,linux下的一切设备都是以文件的形式操作.如网络套接字、硬件设备等。当然包括操作文件。
fopen是标准c函数。返回文件流而不是linux下文件句柄。
设备文件不可以当成流式文件来用，只能用open
fopen是用来操纵正规文件的，并且设有缓冲的，跟open还是有一些区别
一般用fopen打开普通文件，用open打开设备文件
fopen是标准c里的,而open是linux的系统调用.
他们的层次不同.
fopen可移植,open不能
我认为fopen和open最主要的区别是fopen在用户态下就有了缓存，在进行read和write的时候减少了用户态和内核态的切换，而open则每次都需要进行内核态和用户态的切换；表现为，如果顺序访问文件，fopen系列的函数要比直接调用open系列快；如果随机访问文件open要比fopen快。
来自论坛的经典回答：
前者属于低级IO，后者是高级IO。
前者返回一个文件描述符(用户程序区的)，后者返回一个文件指针。
前者无缓冲，后者有缓冲。
前者与 read, write 等配合使用， 后者与 fread, fwrite等配合使用。
后者是在前者的基础上扩充而来的，在大多数情况下，用后者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87849615217545335c5e44957a469ba9/" rel="bookmark">
			解决windows10, visual studio 2013里安装wtl9时遇到的脚本出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按官方指导，运行AppWiz里面setup.js后，启动vs2013,选择wtl向导时，会出现如setDirection未定义等一系列错误，导致无法使用工程创建向导。主要原因是系统会阻拦跨域名调用js，一个简单解决办法，把向导使用的两个js（Script.js,common.js）拷贝到向导页面所在目录，修改向导页面的引用这两个js文件的路径即可，关键修改结果如下：
&lt;SCRIPT&gt; document.scripts("INCLUDE_SCRIPT").src = "Script.js"; document.scripts("INCLUDE_COMMON").src = "Common.js"; &lt;/SCRIPT&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c510f91a9475ddd47a5b8870567b8d19/" rel="bookmark">
			Java设计模式之命令模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文继续介绍23种设计模式系列之命令模式。
定义 将来自客户端的请求传入一个对象，从而使你可用不同的请求对客户进行参数化。用于“行为请求者”与“行为实现者”解耦，可实现二者之间的松耦合，以便适应变化。分离变化与不变的因素。 角色 Command 定义命令的接口，声明执行的方法。 ConcreteCommand 命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。 Receiver 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。 Invoker 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 Client 创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。 优点 1.降低对象之间的耦合度。 2.新的命令可以很容易地加入到系统中。 3.可以比较容易地设计一个组合命令。 4.调用同一方法实现不同的功能 缺点 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。 适用情况 1.系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。 2.系统需要在不同的时间指定请求、将请求排队和执行请求。 3.系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。 4.系统需要将一组操作组合在一起，即支持宏命令。 应用 模拟对电视机的操作有开机、关机、换台命令。代码如下 //执行命令的接口 public interface Command { void execute(); } //命令接收者Receiver public class Tv { public int currentChannel = 0; public void turnOn() { System.out.println("The televisino is on."); } public void turnOff() { System.out.println("The television is off."); } public void changeChannel(int channel) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c510f91a9475ddd47a5b8870567b8d19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00a02be152c7eacd9e8441ca4cdd70e/" rel="bookmark">
			C&#43;&#43; STL算法之accumulate函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 介绍 用来计算特定范围内（包括连续的部分和初始值）所有元素的和，除此之外，还可以用指定的二进制操作来计算特定范围内的元素结果。其头文件在numeric中。 accumulate原函数声明定义如下： template&lt;class InputIterator, class Type&gt; Type accumulate( InputIterator _First, InputIterator _Last, Type _Val ); template&lt;class InputIterator, class Type, class Fn2&gt; Type accumulate( InputIterator _First, InputIterator _Last, Type _Val, BinaryOperation _Binary_op ); 参数说明。
参数描述_First指定范围内第一个迭代的值或者结合操作选项使用。InputIterator _Last指定范围内最后一个迭代值或者结合操作项使用。_Val要计算的初始值。_Binary_op运用于指定范围内所有元素和前面计算得到结果的参数。 但看说明也许不太容易懂，我们通过例子更具体的解释下这个函数。
2. 应用举例 #include &lt;vector&gt; #include &lt;numeric&gt; #include &lt;functional&gt; #include &lt;iostream&gt; using namespace std; int main( ) { vector &lt;int&gt; v1, v2( 20 ); vector &lt;int&gt;::iterator Iter1, Iter2; int i; for ( i = 1 ; i &lt; 21 ; i++ ) { v1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00a02be152c7eacd9e8441ca4cdd70e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b810e20a49f1a0a668dbf291599e9f/" rel="bookmark">
			C# WinForm无边框窗体设置阴影效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、添加引用
using System.Runtime.InteropServices; 2、定义常量值及函数 private const int CS_DropSHADOW = 0x20000; private const int GCL_STYLE = (-26); [DllImport("user32.dll", CharSet = CharSet.Auto)] public static extern int SetClassLong(IntPtr hwnd, int nIndex, int dwNewLong); [DllImport("user32.dll", CharSet = CharSet.Auto)] public static extern int GetClassLong(IntPtr hwnd, int nIndex);3、在你的窗体Load或构造事件中调用这个函数即可 SetClassLong(this.Handle, GCL_STYLE, GetClassLong(this.Handle, GCL_STYLE) | CS_DropSHADOW); 完整代码如下： using System; using System.Runtime.InteropServices; using System.Windows.Forms; namespace ShadowDemo { public partial class Frm_Main : Form { private const int CS_DropSHADOW = 0x20000; private const int GCL_STYLE = (-26); [DllImport("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b810e20a49f1a0a668dbf291599e9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec33c0e5032ebdebe11d091d33ca831/" rel="bookmark">
			C# 在winform中隐藏或者去除c#的标题栏并实现窗体移动附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 设置窗体的FormBorderStyle为None 不过要自己加上一些相应的操作代码了,不然窗口是不能进行拖动关闭之类的
#region 实现点击移动 internal static int WM_NCHITTEST = 0x84; internal static IntPtr HTCLIENT = (IntPtr)0x1; internal static IntPtr HTCAPTION = (IntPtr)0x2; internal static int WM_NCLBUTTONDBLCLK = 0x00A3; protected override void WndProc(ref Message m) { if (m.Msg == WM_NCLBUTTONDBLCLK) { return; } if (m.Msg == WM_NCHITTEST) { base.WndProc(ref m); if (m.Result == HTCLIENT) { m.HWnd = this.Handle; m.Result = HTCAPTION; } return; } base.WndProc(ref m); } #endregion 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28a25b5cf8062730a8c2edf9d6f22952/" rel="bookmark">
			C# MySQL封装操作类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Data; using System.Configuration; using System.Windows.Forms; using MySql.Data.MySqlClient; using System.Xml; using MySql.Data; /* * Author: Lee * Time: 2015-04-08 * Info: 数据库封装操作类 */ namespace Common { public class DbManager { //连接用的字符串 private string connStr; public string ConnStr { get { return this.connStr; } set { this.connStr = value; } } private DbManager() { } //DbManager单实例 private static DbManager _instance = null; public static DbManager Ins { get { if (_instance == null) { _instance = new DbManager(); } return _instance; } } /// &lt;summary&gt; /// 需要获得多个结果集的时候用该方法，返回DataSet对象。 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28a25b5cf8062730a8c2edf9d6f22952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0950317ece745f09edbe925cf9d5d2a/" rel="bookmark">
			Java设计模式之责任链模式、职责链模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文继续介绍 23种设计模式系列 之职责链模式。 什么是链 1、链是一系列节点的集合。 2.、链的各节点可灵活拆分再重组。 职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系， 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。 角色 抽象处理者角色(Handler)：定义出一个处理请求的接口。如果需要，接口可以定义 出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。 具体处理者角色(ConcreteHandler)：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。 抽象处理者角色 public abstract class Handler { /** * 持有后继的责任对象 */ protected Handler successor; /** * 示意处理请求的方法，虽然这个示意方法是没有传入参数的 * 但实际是可以传入参数的，根据具体需要来选择是否传递参数 */ public abstract void handleRequest(); /** * 取值方法 */ public Handler getSuccessor() { return successor; } /** * 赋值方法，设置后继的责任对象 */ public void setSuccessor(Handler successor) { this.successor = successor; } } 具体处理者角色 public class ConcreteHandler extends Handler { /** * 处理方法，调用此方法处理请求 */ @Override public void handleRequest() { /** * 判断是否有后继的责任对象 * 如果有，就转发请求给后继的责任对象 * 如果没有，则处理请求 */ if(getSuccessor() !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0950317ece745f09edbe925cf9d5d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e4028114dc80581c40dd7779671ca99/" rel="bookmark">
			C&#43;&#43;实现求解逆矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用C语言求解线性代数中求解逆矩阵的一类问题。
最近在学线代，其中有一个挺烦人的就是求解逆矩阵，虽然求逆矩阵不难，但我自己在解题的时候经常求错，所以就想能不能用算法来求解这一类的题目。
求解逆矩阵一般可以用初等行变换或伴随矩阵方法求解。
这里采用的是伴随矩阵方法。
思路很简单，先求矩阵A对应的行列式|A|，然后在求伴随矩阵即可，伴随矩阵可以用一个二维数组存放即可，注意一下伴随矩阵的元素排列方式，还有稍微注意一下在行列式中的元素下标和二维数组中的下标的不同。
接下来就是如何求解|A|的问题了，我没想太多，直接暴力求解吧，反正我需要求的阶数不会很多，所以即使算法不优，运行时间也不会很长。这里用的是余子式的方法，从第一行的第一个元素开始，得到对应的余子式，为了能够计算余子式的值，还需要继续对余子式求余子式，这里利用递归是一个很好的方法，会让思路很清晰。
至于伴随矩阵，实际上也是求解余子式的过程，这个过程和上述几乎是一样的。
下面是程序代码：carray.cpp
#include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; #define N 10 //行列式的最大阶数 int getvalue(int a[N][N],int n){ //计算|A| if(n==1) //递归结束条件，当n=1时，得到返回值a00； return a[0][0]; int res = 0,i,j,k,t,temp[N][N]; //定义一个临时数组，用于存放Ai的余子式 for(i=0;i&lt;n;i++){ for(j=0;j&lt;n-1;j++) for(k=0;k&lt;n-1;k++) temp[j][k] = a[j+1][(k&gt;=i)?k+1:k]; //每执行完一次j，k的循环，二位数组temp就是Ai的余子式 t = getvalue(temp,n-1); //递归，再求数组temp的第一行的余子式，直到余子式只有1个元素 if(i&amp;1) //确定余子式的符号并进行行列式运算 res -= a[0][i]*t; else res += a[0][i]*t; } return res; //返回行列式计算结果 } void getAStar(int a[N][N],int n,int yu[N][N]){ //计算每一行每一列的每个元素所对应的余子式，组成A* if(n==1) yu[0][0] = 1; //若阶数为1，则没有余子式 int i,j,k,t; int temp[N][N]; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++){ for(k=0;k&lt;n-1;k++) for(t=0;t&lt;n-1;t++) temp[k][t] = a[k&gt;=i?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e4028114dc80581c40dd7779671ca99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9e69c5e3b89a6aaee1885e6e4d1953/" rel="bookmark">
			dev_set_drvdata  ，SET_NETDEV_DEV
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 dev_set_drvdata(&amp;pdev-&gt;dev, dev); // it just like that platform_set_drvdata(); 把设备的相关信息放到设备结构里作为私有数据存起来。
SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev); //将网络设备的基类dev父设备指向了平台设备的设备基类dev !!! #define SET_NETDEV_DEV(net, pdev)((net)-&gt;dev.parent = (pdev)) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53831659df7aac769a9f29fb66f292a8/" rel="bookmark">
			Java设计模式之迭代子模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文继续介绍 23种设计模式系列 之迭代子模式。 定义 在软件构建过程中，集合对象内部结构常常变化各异，但对于这些集合对象，我们希望在不暴露其内部结构的同时，可以让外部客户代码透明地访问其中包含的元素；同时这种“透明遍历”也为同一种算法在多种集合对象上进行操作提供了可能。 使用面向对象技术将这种遍历机制抽象为“迭代器对象”为“应对变化中的集合对象”提供了一种优雅的方式。 迭代子(Iterator)模式又叫游标(Cursor)模式，是对象的行为模式。迭代子模式可以顺序地访问一个聚集中的元素而不必暴漏聚集的内部表象。 为什么聚集需要迭代子 多个对象聚在一起形成的总体称之为聚集(Aggregate)，聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂性和多样性，数组就是最基本的聚集，也是其他Java聚集对象的设计基础。 Java聚集(Collection)对象是实现了共同的java.util.Collection接口的对象，是Java语言对聚集的概念的直接支持。 聚集对象必须提供适当的方法，允许客户端按照一个线性顺序遍历所有元素对象 ，把元素对象提取出来或者删除掉等。一个使用聚集的系统必然会使用这些方法操作聚集对象，因而在使用聚聚的系统演化过程中，会出现两类情况。 ◆ 迭代逻辑没有改变，但是需要将一种聚集对象换成另一种聚集，因为不同的聚集具有不同的遍历接口，所以需要修改客户端代码，以便将已有的迭代调用换成新聚集对象所要求的接口。 ◆ 聚集不改变，但是迭代方式需要改变，比如原来只需要读取元素和删除元素，但现在需要增加新的；或者原来的迭代仅仅遍历所有的元素，而现在则需要对元素加以过滤等。这时就只好修改聚集对象，修改已有的遍历方法，或者增加新的方法。 显然，出现这种情况是因为所涉及的聚集设计不符合“开-闭”原则，也就是因为没有将不变的结构从系统中抽象出来，与可变成分分割，并将可变部分的各种实现封装起来。一个聪明的做法无疑是应当使用更加抽象的处理方法，使得在进行迭代时，客户端根本无需知道所使用的聚集是哪个类型；而当客户端需要使用全新的迭代逻辑时，只需要引进一个新的迭代子对象即可，根本无需修改聚集对象本身。 迭代子模式模式便是这样的一个抽象化的概念，这一模式之所以能够做到这一点，是因为它将迭代逻辑封装到一个独立的迭代子对象汇总，从而与聚集本身分隔开。迭代子对象是对遍历的抽象化，不同的聚集对象可以提供相同的迭代子对象，从而使客户端无需知道聚集的低层结构，一个聚集可以提供多个不同的迭代子对象，从而使得遍历逻辑的变化不会影响到聚集对象本身。 迭代子模式有两种实现方式，分别是白箱聚集与外禀迭代子和黑箱聚集于内禀迭代子。 白箱聚集与外禀迭代子 如果一个聚集的接口提供了可以用来修改聚集元素的方法，这个接口就是所谓的宽接口。 如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求。但是，这样会破坏对聚集对象的封装。这种提供宽接口的聚集叫做白箱聚集。 由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已，这种迭代子叫做游标迭代子（Cursor Iterator）。由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做外禀迭代子（Extrinsic Iterator）。 实现 一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代子可以通过聚集的遍历方法实现迭代功能。 因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代子角色往往仅仅保持迭代的游标位置。 角色 抽象迭代子(Iterator)角色：此抽象角色定义出遍历元素所需的接口。 具体迭代子(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。 聚集(Aggregate)角色：此抽象角色给出创建迭代子(Iterator)对象的接口。 具体聚集(ConcreteAggregate)角色：实现了创建迭代子(Iterator)对象的接口，返回一个合适的具体迭代子实例。 客户端(Client)角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。 抽象聚集角色类 这个角色规定出所有的具体聚集必须实现的接口。迭代子模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代子对象的实例。 public abstract class Aggregate { /** * 工厂方法，创建相应迭代子对象的接口 */ public abstract Iterator createIterator(); } 具体聚集角色类 实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。 public class ConcreteAggregate extends Aggregate { private Object[] objArray = null; /** * 构造方法，传入聚合对象的具体内容 */ public ConcreteAggregate(Object[] objArray){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53831659df7aac769a9f29fb66f292a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f87388b112806814495dd4d5d83bf45b/" rel="bookmark">
			Mysql group by top N的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：http://www.2cto.com/database/201309/247468.html 在日常工作中,经常要查询分组的前几名.oracle中可以通过row_num来支持查询, mysql暂时不支持row_num.那么如何来完成这个需求呢? 例如： 表中的数据： ? 1 2 3 4 5 6 7 8 9 10 + --------+-------+-----+ | Person | Group | Age | + --------+-------+-----+ | Bob | 1 | 32 | | Jill | 1 | 34 | | Shawn | 1 | 42 | | Jake | 2 | 29 | | Paul | 2 | 36 | | Laura | 2 | 39 | + --------+-------+-----+ 期望的结果： ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f87388b112806814495dd4d5d83bf45b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b02933fec91537eefaed1fb78e0f7049/" rel="bookmark">
			Android RecyclerView 使用完全解析 体验艺术般的控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处： http://blog.csdn.net/lmj623565791/article/details/45059587； 本文出自:【张鸿洋的博客】
概述 RecyclerView出现已经有一段时间了，相信大家肯定不陌生了，大家可以通过导入support-v7对其进行使用。 据官方的介绍，该控件用于在有限的窗口中展示大量数据集，其实这样功能的控件我们并不陌生，例如：ListView、GridView。
那么有了ListView、GridView为什么还需要RecyclerView这样的控件呢？整体上看RecyclerView架构，提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。
你想要控制其显示的方式，请通过布局管理器LayoutManager你想要控制Item间的间隔（可绘制），请通过ItemDecoration你想要控制Item增删的动画，请通过ItemAnimator你想要控制点击、长按事件，请自己写（擦，这点尼玛。） 基本使用 鉴于我们对于ListView的使用特别的熟悉，对比下RecyclerView的使用代码：
mRecyclerView = findView(R.id.id_recyclerview); //设置布局管理器 mRecyclerView.setLayoutManager(layout); //设置adapter mRecyclerView.setAdapter(adapter) //设置Item增加、移除动画 mRecyclerView.setItemAnimator(new DefaultItemAnimator()); //添加分割线 mRecyclerView.addItemDecoration(new DividerItemDecoration( getActivity(), DividerItemDecoration.HORIZONTAL_LIST)); ok，相比较于ListView的代码，ListView可能只需要去设置一个adapter就能正常使用了。而RecyclerView基本需要上面一系列的步骤，那么为什么会添加这么多的步骤呢？
那么就必须解释下RecyclerView的这个名字了，从它类名上看，RecyclerView代表的意义是，我只管Recycler View，也就是说RecyclerView只管回收与复用View，其他的你可以自己去设置。可以看出其高度的解耦，给予你充分的定制自由（所以你才可以轻松的通过这个控件实现ListView,GirdView，瀑布流等效果）。
Just like ListView Activity package com.zhy.sample.demo_recyclerview; import java.util.ArrayList; import java.util.List; import android.os.Bundle; import android.support.v7.app.ActionBarActivity; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.RecyclerView; import android.support.v7.widget.RecyclerView.ViewHolder; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; public class HomeActivity extends ActionBarActivity { private RecyclerView mRecyclerView; private List&lt;String&gt; mDatas; private HomeAdapter mAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b02933fec91537eefaed1fb78e0f7049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176e00bc3145b26684c4631e021214f9/" rel="bookmark">
			Java设计模式之观察者模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文继续介绍23种设计模式系列之观察者模式。
观察者模式中，一个被观察者管理所有相依于它的观察者物件，并且在本身的状态改变时主动发出通知。这通常通过呼叫各观察者所提供的方法来实现。此种模式通常被用来实现事件处理系统。 角色 抽象被观察者角色：把所有对观察者对象的引用保存在一个集合中，每个被观察者角色都可以有任意数量的观察者。被观察者提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。 抽象观察者角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。 具体被观察者角色：在被观察者内部状态改变时，给所有登记过的观察者发出通知。具体被观察者角色通常用一个子类实现。 具体观察者角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。 适用场景 1) 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 2) 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。 3) 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。 应用 珠宝商运送一批钻石，有黄金强盗准备抢劫，珠宝商雇佣了私人保镖，警察局也派人护送，于是当运输车上路的时候，强盗保镖警察都要观察运输车一举一动， 抽象的观察者 public interface Watcher { public void update(); } 抽象的被观察者，在其中声明方法（添加、移除观察者，通知观察者）： public interface Watched { public void addWatcher(Watcher watcher); public void removeWatcher(Watcher watcher); public void notifyWatchers(); }具体的观察者 保镖 public class Security implements Watcher { @Override public void update() { System.out.println(“运输车有行动，保安贴身保护"); } } 强盗 public class Thief implements Watcher { @Override public void update() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/176e00bc3145b26684c4631e021214f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c9954bf347c65c4395fc0d1c9cfe32/" rel="bookmark">
			Linux下正确使用getifaddrs()函数避免内存泄露
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中使用valgrind检测内存泄露时,发现getifaddrs()很容易导致内存泄露,下面是正确的代码:
//get local ip of network card //gcc -g get_addr.c -o get_addr // #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;ifaddrs.h&gt; int main(int argc, char* argv[]){ struct ifaddrs *ifc, *ifc1; char ip[64] = {}; char nm[64] = {}; if(0 != getifaddrs(&amp;ifc)) return -1; ifc1 = ifc; printf("iface\tIP address\tNetmask\n"); for(; NULL != ifc; ifc = (*ifc).ifa_next){ printf("%s", (*ifc).ifa_name); if(NULL != (*ifc).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c9954bf347c65c4395fc0d1c9cfe32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4acd25e30ef844b1bb9db8cdffa9323/" rel="bookmark">
			dev_set_drvdata,dev_get_drvdata
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dev_set_drvdata(&amp;pdev-&gt;dev, dev); //将平台设备资源信息放到网络设备里。
dev_get_drvdata(&amp;pdev-&gt;dev, dev); //将平台设备信息资源从网络设备里拿出来。
好处是很明显的，把设备的相关信息放到设备结构里，需要使用的时候可以方便的拿出来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2950fcd963d2831f94a4a403d8f3d7d3/" rel="bookmark">
			异常数据剔除---格拉布斯准则（java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一次发表博客，先发一个简单的算法吧，原理很简单，和大家分享一下。 最近在做一个项目（android端），需要剔除异常数据，就是根据之前一组数据判断新来的数据是否为合理数据，在相差过大的时候予以剔除，找到了格拉布斯准则，具体内容和步骤参见链接http://www.docin.com/p-730815444.html，我觉得写的很好，里面的例子可以借鉴理解： 有一组数据8.2,5.4,14.0,7.3,4.7,9.0,6.5,10.1,7.7,6.0,我们要对里面的异常值（最大或最小）进行剔除。 1.首先进行排序：4.7,5.4,6.0,6.5,7.3,7.7,8.2,9.0,10.1,14.0 2.求平均值及标准差：平均值7.89，标准差：2.704 3.最大值及最小值为可疑值，偏离差分别为：14-7.89=6.11；7.89-4.7=3.19.（根据这两个值判断是否剔除最大值或最小值，文档中说只能判断一个，实际上两边都可以判断） 4.最小值的G1=（平均值-最小值）/标准差 最大值的Gn=（最大值-平均值）/标准差 5.确定检出水平alpha，一般为0.01或0.05，越大越宽松，根据实际条件进行确定，我这里使用0.05，根据后面的表格求出临界值，与G1，Gn作比较；若G1（Gn）大于临界值，则剔除，反之保留。
以下为java代码实现：
public class Grubbs { private ArrayList&lt;Double&gt; dataArrayList; private int length; private final double alpha = 0.05; //传入一组数据，我们要做的是剔除最大或最小的异常值 public Grubbs(ArrayList&lt;Double&gt; arrayList) { this.dataArrayList = arrayList; this.length = arrayList.size(); } public ArrayList&lt;Double&gt; calc() { //因为格拉布斯准则只能对大于等于3个数据进行判断，所以数据量小于3时，直接返回 if (dataArrayList.size() &lt; 3) { return dataArrayList; } //首先对数据进行排序，我这里用了最基本的冒泡法 dataArrayList = bubbleSort(dataArrayList, length); //求出数据平均值和标准差 double average = calcAverage(dataArrayList); double standard = calcStandard(dataArrayList, length, average); //求助最小值和最大值G1，Gn double dubMin = average - dataArrayList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2950fcd963d2831f94a4a403d8f3d7d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bfa9662d7714fdee8f786f451981bb2/" rel="bookmark">
			MySql使用中的注意点（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要针对以前从事企业级应用开发的同学，因为企业级的应用，特别是金融企业通常选用Oracle或者DB2作为数据库。 与上述要花费大价钱的数据库软件相比，免费的MySql还是有一些局限性，以及一些MySql自身的特点要留心、注意。 1.在创建外键时，MySql仅支持数字类型的外键。 这点真的比较恶心，因为表的主键设计既可以有物理主键，同时也可以有逻辑主键。而逻辑主键通常并非仅是数字，可能包含业务说明的英文字母，那这样的逻辑主键是无法被设置为外键的。 但是如果选用物理主键作为外键，那么在做数据迁移时，特别是将测试环境的数据导入到生产环境中时，必须特别留心要保持数据之间关联关系。 那么要么把测试数据库中的主键值一起带入到生产数据库中，要么手动修改数据间关联。后者容易照成错误，而前者会破坏数据库主键连续的物理特性， 更坏的情况是，测试数据库中的主键在生产数据库中已经存在，而不得不使用再手动修改数据间关联的办法。 所以现在我们的数据库没有建立外键关联，虽然这是一柄双刃剑，但是多少会破坏数据库的完整性设计。 2.同一张表内设置默认当前时间的Timestamp类型的字段只能有一个。 例如，通常我们在建立一张表时，即有update_time，也有create_time。我们可能希望这两个字段的默认值都是当前时间，这样在业务程序中可以简化一些代码处理。 但是不幸的是，同一张表中只能有一个字段被DEFAULT CURRENT_TIMESTAMP修饰。 3.MySql的Timestamp类型的精度仅到秒。 这点也没什么好说的，如果业务需求一定要精确到毫秒，那么就保存long型的数字吧。 4.创建视图的where条件不能包含子查询。 例如：create view invalidView select * from A a where a.xxx = (select b.xxx from B b where ...) 即使上述语句去除前面create view invalidView部分可以正常运行，但是创建视图时会被禁止。 一种解决方案是将子查询变为表连接，另外一种方法是将子查询的逻辑提到字段的部分，即select和from中间。 5.没有对子查询进行算法优化。 例如：select * from A a where a.xxx = (select b.xxx from B b where ...) 上述语句当在Oracle中之间，后面的子查询只会被执行一次，但是在MySql中会被执行n次，n为A表中的数据量。 所以应该禁止子查询的使用。 解决办法首先是应该将子查询变为表连接的查询，如果不行，那么请将上述查询分拆为两次查询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28889df436fe8d493832e36facb63400/" rel="bookmark">
			Java设计模式之模板方法模式（Template Method）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文继续介绍23种设计模式系列之模板方法模式。
概述 模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 比如定义一个操作中的算法的骨架，将步骤延迟到子类中。模板方法使得子类能够不去改变一个算法的结构即可重定义算法的某些特定步骤。 模式中的角色 抽象类（AbstractClass）：实现了模板方法，定义了算法的骨架。 具体类（ConcreteClass)：实现抽象类中的抽象方法，已完成完整的算法。 应用 举个例子，以准备去学校所要做的工作（prepareGotoSchool）为例，假设需要分三步：穿衣服（dressUp），吃早饭（eatBreakfast），带上东西（takeThings）。学生和老师要做得具体事情肯定有所区别。 抽象类AbstractClass public abstract class AbstractPerson{ //抽象类定义整个流程骨架 public void prepareGotoSchool(){ dressUp(); eatBreakfast(); takeThings(); } //以下是不同子类根据自身特性完成的具体步骤 protected abstract void dressUp(); protected abstract void eatBreakfast(); protected abstract void takeThings(); } 具体类ConcreteClass public class Student extends AbstractPerson{ @Override protected void dressUp() { System.out.println(“穿校服"); } @Override protected void eatBreakfast() { System.out.println(“吃妈妈做好的早饭"); } @Override protected void takeThings() { System.out.println(“背书包，带上家庭作业和红领巾"); } } public class Teacher extends AbstractPerson{ @Override protected void dressUp() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28889df436fe8d493832e36facb63400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4058a6958cf80eb2b44149fc3875bb6f/" rel="bookmark">
			Java设计模式之策略模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文继续介绍 23种设计模式系列 之策略模式。 背景 在软件开发中常常遇到这种情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。 这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。 问题 如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化？ 方案 把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口，然后在类中包含这个对象的实例，这样类的实例在运行时就可以随意调用实现了这个接口的类的行为。 比如定义一系列的算法,把每一个算法封装起来, 并且使它们可相互替换，使得算法可独立于使用它的客户而变化。这就是策略模式。 适用情况 许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。 当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用。
一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。 优点 1、可以动态的改变对象的行为 缺点 1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类 2、策略模式将造成产生很多策略类 组成 环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。 抽象策略类(Strategy):定义所有支持的算法的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法。 具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。 应用 场景如下，刘备要到江东娶老婆了，走之前诸葛亮给赵云三个锦囊妙计，说是按天机拆开能解决棘手问题。场景中出现三个要素：三个妙计（具体策略类）、一个锦囊（环境类）、赵云（调用者）。 抽象策略类（ Strategy ） public interface Strategy { public void operate(); } 三个实现类（ ConcreteStrategy ）： 妙计一：初到吴国 public class BackDoor implements IStrategy { @Override public void operate() { System.out.println("找乔国老帮忙，让吴国太给孙权施加压力，使孙权不能杀刘备"); } } 妙计二：求吴国太开绿灯放行 public class GivenGreenLight implements IStrategy { @Override public void operate() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4058a6958cf80eb2b44149fc3875bb6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbfe95a7826629a7b645fb7432439957/" rel="bookmark">
			Java语言下的数组、链表、哈希表的增删查改效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几种数据结构，就把这几样拿出来实现了一下，比较他们的效率。
其中链表和哈希表是直接调用的java.util包下的LinkedList类和HashTable类。
hash算法是采用%操作(mod)，效率不是很高，但是作为hash表的代表应该问题不是很大。
创建100万个对象将其放入存储结构中，然后进行增加、删除、查找操作。
每次操作后调用system.nanoTime()方法，获取时间数据。代码如下：
/** * 测试数组时间的方法 */ public void f1(){ int i[] = new int[1000000]; long time1 = System.nanoTime(); //创建一个数组 for(int a=0;a&lt;i.length;a++){ i[a] = a; } long time2 = System.nanoTime(); System.out.println("创建数组时间："+(time2-time1)); //插入 time1 = System.nanoTime(); int b[] = new int[1000001]; int c = 100; for(int a=0;a&lt;b.length;a++){ if(a&lt;99){ b[a]=i[a]; }else if(a==99){ b[a] = c; }else{ b[a] = i[a-1]; } } time2 = System.nanoTime(); System.out.println("插入数组时间："+(time2-time1)); //删除 time1 = System.nanoTime(); int d = 99; for(int a = 0;a&lt;i.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbfe95a7826629a7b645fb7432439957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a379dbd775088c77a51e337df7800e8/" rel="bookmark">
			FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
H.264源代码分析文章列表：
【编码 - x264】
x264源代码简单分析：概述
x264源代码简单分析：x264命令行工具（x264.exe）
x264源代码简单分析：编码器主干部分-1
x264源代码简单分析：编码器主干部分-2
x264源代码简单分析：x264_slice_write()
x264源代码简单分析：滤波（Filter）部分
x264源代码简单分析：宏块分析（Analysis）部分-帧内宏块（Intra）
x264源代码简单分析：宏块分析（Analysis）部分-帧间宏块（Inter）
x264源代码简单分析：宏块编码（Encode）部分
x264源代码简单分析：熵编码（Entropy Encoding）部分
FFmpeg与libx264接口源代码简单分析
【解码 - libavcodec H.264 解码器】
FFmpeg的H.264解码器源代码简单分析：概述
FFmpeg的H.264解码器源代码简单分析：解析器（Parser）部分
FFmpeg的H.264解码器源代码简单分析：解码器主干部分
FFmpeg的H.264解码器源代码简单分析：熵解码（EntropyDecoding）部分
FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧内宏块（Intra）
FFmpeg的H.264解码器源代码简单分析：宏块解码（Decode）部分-帧间宏块（Inter）
FFmpeg的H.264解码器源代码简单分析：环路滤波（Loop Filter）部分
=====================================================
本文继续分析FFmpeg中libavcodec的H.264解码器（H.264 Decoder）。上篇文章概述了FFmpeg中H.264解码器的结构；从这篇文章开始，具体研究H.264解码器的源代码。本文分析H.264解码器中解析器（Parser）部分的源代码。这部分的代码用于分割H.264的NALU，并且解析SPS、PPS、SEI等信息。解析H.264码流（对应AVCodecParser结构体中的函数）和解码H.264码流（对应AVCodec结构体中的函数）的时候都会调用该部分的代码完成相应的功能。
函数调用关系图 解析器（Parser）部分的源代码在整个H.264解码器中的位置如下图所示。
单击查看更清晰的图片
解析器（Parser）部分的源代码的调用关系如下图所示。
单击查看更清晰的图片
从图中可以看出，H.264的解析器（Parser）在解析数据的时候调用h264_parse()，h264_parse()调用了parse_nal_units()，parse_nal_units()则调用了一系列解析特定NALU的函数。H.264的解码器（Decoder）在解码数据的时候调用h264_decode_frame()，h264_decode_frame()调用了decode_nal_units()，decode_nal_units()也同样调用了一系列解析不同NALU的函数。 图中简单列举了几个解析特定NALU的函数： ff_h264_decode_nal()：解析NALU Header ff_h264_decode_seq_parameter_set()：解析SPS ff_h264_decode_picture_parameter_set()：解析PPS ff_h264_decode_sei()：解析SEI H.264解码器与H.264解析器最主要的不同的地方在于它调用了ff_h264_execute_decode_slices()函数进行了解码工作。这篇文章只分析H.264解析器的源代码，至于H.264解码器的源代码，则在后面几篇文章中再进行分析。 ff_h264_decoderff_h264_decoder是FFmpeg的H.264解码器对应的AVCodec结构体。它的定义位于libavcodec\h264.c，如下所示。 AVCodec ff_h264_decoder = { .name = "h264", .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"), .type = AVMEDIA_TYPE_VIDEO, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a379dbd775088c77a51e337df7800e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe86275d4d69065bf0eaeca479a762f8/" rel="bookmark">
			版本管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景： 开发软件时,对你开发的代码及文档有效的管理 。将你的代码和开发文档的最新版本每天提交到服务器上, 第二天再从服务器上下载下这个最新版本,再对其进行维护. 免得你本机坏了,代码和文档丢了! 也可以不用每天从服务器上下载,但要每天提交到服务器上, 但要与服务器上的版本同步. 含义：编辑 版本管理是 软件配置管理的基础，它管理并保护开发者的软件资源。 它的主要功能有： (1) 集中管理档案，安全授权机制：档案集中地存放在服务器上，经 系统管理员授权给各个用户。用户通过check in和check out的方式访问服务器上的文件，未经授权的用户则无法访问服务器上的文件。 (2) 软件版本升级管理：每次登入时，在服务器上都会生成新的版本，任何版本都可以随时检出编辑。 (3) 加锁功能：在文件更新时保护文件，避免不同的用户更改同一文件时发生冲突。 (4) 提供不同版本 源程序的比较。 著名的版本控制软件编辑 Git----TortoiseGit 开源、快速 SVN( Subversion)--- TortoiseSVN 单位正在使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e8ce21f0544c02a28619503279e59e/" rel="bookmark">
			50个C/C&#43;&#43;面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试题1：变量的声明和定义有什么区别 为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明，但是只在一个地方定义。加入extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。 说明：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。 面试题2：写出bool 、int、 float、指针变量与“零值”比较的if语句 bool型数据： if( flag ) { A; } else { B； } int型数据： if( 0 != flag ) { A; } else { B； } 指针型数： if( NULL == flag ) { A; } else { B； } float型数据： if ( ( flag &gt;= NORM ) &amp;&amp; ( flag &lt;= NORM ) ) { A； } 注意：应特别注意在int、指针型变量和“零值”比较的时候，把“零值”放在左边，这样当把“==”误写成“=”时，编译器可以报错，否则这种逻辑错误不容易发现，并且可能导致很严重的后果。 面试题3：sizeof和strlen的区别 sizeof和strlen有以下区别： sizeof是一个操作符，strlen是库函数。 sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为‘\0‘的字符串作参数。  编译器在编译时就计算出了sizeof的结果。而strlen函数必须在运行时才能计算出来。并且sizeof
计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。  数组做sizeof的参数不退化，传递给strlen就退化为指针了。 注意：有些是操作符看起来像是函数，而有些函数名看起来又像操作符，这类容易混淆的名称一定要加以区分，否则遇到数组名这类特殊数据类型作参数时就很容易出错。最容易混淆为函数的操作符就是sizeof。 面试题4：C语言的关键字 static 和 C++ 的关键字 static 有什么区别 在C中static用来修饰局部静态变量和外部静态变量、函数。而C++中除了上述功能外，还用来定义类的成员变量和函数。即静态成员和静态成员函数。 注意：编程时static的记忆性，和全局性的特点可以让在不同时期调用的函数进行通信，传递信息，而C++的静态成员则可以在多个对象实例间进行通信，传递信息。 面试题5：Ｃ中的malloc和Ｃ＋＋中的new有什么区别 malloc和new有以下不同： （1）new、delete 是操作符，可以重载，只能在C++中使用。 （2）malloc、free是函数，可以覆盖，C、C++中都可以使用。 （3）new 可以调用对象的构造函数，对应的delete调用相应的析构函数。 （4）malloc仅仅分配内存，free仅仅回收内存，并不执行构造和析构函数 （5）new、delete返回的是某种数据类型指针，malloc、free返回的是void指针。 注意：malloc申请的内存空间要用free释放，而new申请的内存空间要用delete释放，不要混用。因为两者实现的机理不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e8ce21f0544c02a28619503279e59e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686676fcf52a665d47d676033119438c/" rel="bookmark">
			Hbase:namespace异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hbase 集群部署启动后几秒自动退出异常处理，
1.hadoop 与 hbase 版本不兼容，会导致此异常。
2.log 为 org.apache.hadoop.hbase.TableExistsException: hbase:namespace 异常，
很可能是更换了Hbase的版本过后zookeeper还保留着上一次的Hbase设置，所以造成了冲突。
解决方案：(这里作者就出现过这个错误 搞了好几个小时才定位到是这个错误) 1.切换到zookeeper的bin目录；
2.执行$sh zkCli.sh
输入 ls /
4.输入rmr /hbase
5.退出重启即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4761241bfca2db1125543efe085b64/" rel="bookmark">
			UIPanGestureRecognizer判断滑动的方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.h文件 CGFloat const gestureMinimumTranslation = 20.0 ; typedef enum : NSInteger { kCameraMoveDirectionNone, kCameraMoveDirectionUp, kCameraMoveDirectionDown, kCameraMoveDirectionRight, kCameraMoveDirectionLeft } CameraMoveDirection ; @interface FCDetailViewController : FCMainViewController { CameraMoveDirection direction; } .m文件 -------- - (void)viewDidLoad { [super viewDidLoad]; //监听滑动手势 UIPanGestureRecognizer *recognizer = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(handleSwipeFrom:)]; [self.view addGestureRecognizer:recognizer]; } - (void)handleSwipeFrom:(UIPanGestureRecognizer*)gesture { CGPoint translation = [gesture translationInView:self.view]; if (gesture.state == UIGestureRecognizerStateBegan ){ direction = kCameraMoveDirectionNone; }else if(gesture.state == UIGestureRecognizerStateChanged &amp;&amp; direction == kCameraMoveDirectionNone){ direction = [ self determineCameraDirectionIfNeeded:translation]; switch (direction) { case kCameraMoveDirectionDown: //NSLog (@ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d4761241bfca2db1125543efe085b64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163efbbc3a6e61248a89a5fdd4fb13e8/" rel="bookmark">
			reshape2包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写链接内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9201a5c41fc377daf45b4975a6e2f5ae/" rel="bookmark">
			常见的IO模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文讨论的背景是Linux环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX? Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I/O Models ”，Stevens在这节中详细说明了各种IO的特点和区别，如果英文够好的话，推荐直接阅读。Stevens的文风是有名的深入浅出，所以不用担心看不懂。本文中的流程图也是截取自参考文献。 Stevens在文章中一共比较了五种IO Model： * blocking IO * nonblocking IO * IO multiplexing * signal driven IO * asynchronous IO 由signal driven IO在实际中并不常用，所以主要介绍其余四种IO Model。 再说一下IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段： 1）等待数据准备 (Waiting for the data to be ready) 2）将数据从内核拷贝到进程中(Copying the data from the kernel to the process) 记住这两点很重要，因为这些IO模型的区别就是在两个阶段上各有不同的情况。 1、阻塞IO（blocking IO）
在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样： 图1 阻塞IO 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 所以，blocking IO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。 几乎所有的程序员第一次接触到的网络编程都是从listen()、send()、recv() 等接口开始的，这些接口都是阻塞型的。使用这些接口可以很方便的构建服务器/客户机的模型。下面是一个简单地“一问一答”的服务器。 图2 简单的一问一答的服务器/客户机模型 我们注意到，大部分的socket接口都是阻塞型的。所谓阻塞型接口是指系统调用（一般是IO接口）不返回调用结果并让当前线程一直阻塞，只有当该系统调用获得结果或者超时出错时才返回。 实际上，除非特别指定，几乎所有的IO接口 ( 包括socket接口 ) 都是阻塞型的。这给网络编程带来了一个很大的问题，如在调用send()的同时，线程将被阻塞，在此期间，线程将无法执行任何运算或响应任何的网络请求。 一个简单的改进方案是在服务器端使用多线程（或多进程）。多线程（或多进程）的目的是让每个连接都拥有独立的线程（或进程），这样任何一个连接的阻塞都不会影响其他的连接。具体使用多进程还是多线程，并没有一个特定的模式。传统意义上，进程的开销要远远大于线程，所以如果需要同时为较多的客户机提供服务，则不推荐使用多进程；如果单个服务执行体需要消耗较多的CPU资源，譬如需要进行大规模或长时间的数据运算或文件访问，则进程较为安全。通常，使用pthread_create ()创建新线程，fork()创建新进程。 我们假设对上述的服务器 / 客户机模型，提出更高的要求，即让服务器同时为多个客户机提供一问一答的服务。于是有了如下的模型。 图3 多线程的服务器模型 在上述的线程 / 时间图例中，主线程持续等待客户端的连接请求，如果有连接，则创建新线程，并在新线程中提供为前例同样的问答服务。 很多初学者可能不明白为何一个socket可以accept多次。实际上socket的设计者可能特意为多客户机的情况留下了伏笔，让accept()能够返回一个新的socket。下面是 accept 接口的原型： int accept(int s, struct sockaddr *addr, socklen_t *addrlen); 输入参数s是从socket()，bind()和listen()中沿用下来的socket句柄值。执行完bind()和listen()后，操作系统已经开始在指定的端口处监听所有的连接请求，如果有请求，则将该连接请求加入请求队列。调用accept()接口正是从 socket s 的请求队列抽取第一个连接信息，创建一个与s同类的新的socket返回句柄。新的socket句柄即是后续read()和recv()的输入参数。如果请求队列当前没有请求，则accept() 将进入阻塞状态直到有请求进入队列。 上述多线程的服务器模型似乎完美的解决了为多个客户机提供问答服务的要求，但其实并不尽然。如果要同时响应成百上千路的连接请求，则无论多线程还是多进程都会严重占据系统资源，降低系统对外界响应效率，而线程与进程本身也更容易进入假死状态。 很多程序员可能会考虑使用“线程池”或“连接池”。“线程池”旨在减少创建和销毁线程的频率，其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。“连接池”维持连接的缓存池，尽量重用已有的连接、减少创建和关闭连接的频率。这两种技术都可以很好的降低系统开销，都被广泛应用很多大型系统，如websphere、tomcat和各种数据库等。但是，“线程池”和“连接池”技术也只是在一定程度上缓解了频繁调用IO接口带来的资源占用。而且，所谓“池”始终有其上限，当请求大大超过上限时，“池”构成的系统对外界的响应并不比没有池的时候效果好多少。所以使用“池”必须考虑其面临的响应规模，并根据响应规模调整“池”的大小。 对应上例中的所面临的可能同时出现的上千甚至上万次的客户端请求，“线程池”或“连接池”或许可以缓解部分压力，但是不能解决所有问题。总之，多线程模型可以方便高效的解决小规模的服务请求，但面对大规模的服务请求，多线程模型也会遇到瓶颈，可以用非阻塞接口来尝试解决这个问题。 2、非阻塞IO（non-blocking IO） Linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子： 图4 非阻塞IO 从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。 所以，在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。 非阻塞的接口相比于阻塞型接口的显著差异在于，在被调用之后立即返回。使用如下的函数可以将某句柄fd设为非阻塞状态。 fcntl( fd, F_SETFL, O_NONBLOCK ); 下面将给出只用一个线程，但能够同时从多个连接中检测数据是否送达，并且接受数据的模型。 图5 使用非阻塞的接收数据模型 在非阻塞状态下，recv() 接口在被调用后立即返回，返回值代表了不同的含义。如在本例中， * recv() 返回值大于 0，表示接受数据完毕，返回值即是接受到的字节数； * recv() 返回 0，表示连接已经正常断开； * recv() 返回 -1，且 errno 等于 EAGAIN，表示 recv 操作还没执行完成； * recv() 返回 -1，且 errno 不等于 EAGAIN，表示 recv 操作遇到系统错误 errno。 可以看到服务器线程可以通过循环调用recv()接口，可以在单个线程内实现对所有连接的数据接收工作。但是上述模型绝不被推荐。因为，循环调用recv()将大幅度推高CPU 占用率；此外，在这个方案中recv()更多的是起到检测“操作是否完成”的作用，实际操作系统提供了更为高效的检测“操作是否完成“作用的接口，例如select()多路复用模式，可以一次检测多个连接是否活跃。 3、多路复用IO（IO multiplexing） IO multiplexing这个词可能有点陌生，但是如果我说select/epoll，大概就都能明白了。有些地方也称这种IO方式为事件驱动IO(event driven IO)。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9201a5c41fc377daf45b4975a6e2f5ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c365268820a0363f12345e00b40868f/" rel="bookmark">
			23种设计模式汇总整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式分为三大类：
创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式，共七种：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
其实还有两类：并发型模式和线程池模式。
设计模式的六大原则：
总原则－开闭原则
对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。
想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。
1、单一职责原则
不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。
2、里氏替换原则（Liskov Substitution Principle）
任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当衍生类可以替换基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。
里氏代换原则是对“开-闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。
3、依赖倒转原则（Dependence Inversion Principle）
面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
4、接口隔离原则（Interface Segregation Principle）
每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。
5、迪米特法则（最少知道原则）（Demeter Principle）
一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。
最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。
6、合成复用原则（Composite Reuse Principle）
尽量首先使用合成/聚合的方式，而不是使用继承。
之前已经陆续整理了9种设计模式，链接如下，接下来一段时间陆续把剩余的过一遍，整理出来，理解设计模式还是很重要的。
创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式
行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
还有两类：并发型模式和线程池模式。
-------2017年8月31日更新----------------
设计模式需要几个阶段的学习，
没有大量项目经验的时候学习，可能只是了解，
当有了一些项目场景的时候，才会深刻体会到其中的奥妙。
上面文章有些在写的时候，“借鉴”甚至“抄袭”了很多其他博主的文章，主要也是当时自己理解的不够深刻，需要借助现有的场景去理解，接下来会抽时间梳理一下设计模式的东西，整理一遍，希望能帮到大家。
作者：jason0539
博客：http://blog.csdn.net/jason0539（转载请说明出处）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f872fe346af244bcb6069cc1a3404002/" rel="bookmark">
			c&#43;&#43;智能指针练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例如下： #include &lt;iostream&gt; using namespace std; class counter { int m_use; template &lt;class T&gt; friend class smartpointer; counter(int use):m_use(use){} counter(){ m_use = 0;} }; template &lt;class T&gt; class smartpointer { public: smartpointer(T *ptr):m_pt(ptr),m_cnt(new counter(1)) { cout&lt;&lt;"smartpointer::smartpointer() invoked " &lt;&lt; m_cnt-&gt;m_use++ &lt;&lt;endl;	} smartpointer(const smartpointer&lt;T&gt;&amp; rhs) { m_pt = rhs.m_pt; m_cnt = rhs.m_cnt; ++(m_cnt-&gt;m_use); cout&lt;&lt;"smartpointer::smartpointer(const smartpointer&amp;) invoked " &lt;&lt; m_cnt-&gt;m_use++ &lt;&lt;endl; } ~smartpointer() { cout&lt;&lt;"SmartPointer::~SmartPointer() invoded" &lt;&lt; m_cnt-&gt;m_use &lt;&lt;endl; if(--(m_cnt-&gt;m_use) == 0) { delete m_pt; delete m_cnt; } } smartpointer&amp; operator=(const smartpointer&amp; rhs) { if(rhs == *this) return *this; m_pt = rhs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f872fe346af244bcb6069cc1a3404002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36935d7f505548885c20194c7258b63b/" rel="bookmark">
			运用stm32f103c8t6的TIM4无输出PWM的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其PWM无输出的原因是：因为如果在IO口的初始化之前没有使能时钟则该初始化是无效的。
例子：
int main()
{
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
TIM4_Mode_Config();//无时钟初始化；
TIM4_GPIO_Config(); //包含时钟初始化，则需要将其放在TIM4_Mode_Config()函数之前才会输出PWM；
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
}
解决方法：
int main()
{
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
TIM4_GPIO_Config(); //首先进行时钟初始化
TIM4_Mode_Config();//无时钟初始化；
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ab6e7f5200e1bcb4c3fd63806a1983/" rel="bookmark">
			数学基础：矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵的概念： 数学上，一个m×n的矩阵是一个由m行n列元素排列成的矩形阵列。矩阵里的元素可以是数字、符号或数学式。
如下是一个m×n的矩阵（m行n列）： Am×n=(aij)=⎛⎝⎜⎜⎜⎜⎜a11a21⋮am1a12a22⋮am2⋯⋯⋱⋯a1na2n⋮amn⎞⎠⎟⎟⎟⎟⎟ 同型矩阵： 如果，矩阵Am×n和矩阵Bm×n都是m×n的矩阵，则这两个矩阵为同型矩阵。
矩阵相等： 如果矩阵Am×n和矩阵Bm×n互为同型矩阵，并且对应元素相等aij=bij。则两个矩阵相等。
行向量与列向量： 行向量是一个 1×n的矩阵，即矩阵由一个含有n个元素的行所组成： α=（a1,a2,⋯,an）=[a1a2⋯an] 列向量是一个 n×1 的矩阵，即矩阵由一个含有n个元素的列所组成。（列向量的转置是一个行向量，反之亦然）： β=αT=（a1,a2,⋯,an）T=⎡⎣⎢⎢⎢⎢a1a2⋮an⎤⎦⎥⎥⎥⎥ 方阵（n阶矩阵）： n行n列的矩阵是一个方阵，也叫做n阶矩阵，如An： An×n=(aij)=⎛⎝⎜⎜⎜⎜⎜a11a21⋮an1a12a22⋮an2⋯⋯⋱⋯a1na2n⋮ann⎞⎠⎟⎟⎟⎟⎟ 零矩阵： 所有元素都是0的矩阵。
单位矩阵（E）： 主对角元素为1，其他元素为0的方阵是单位矩阵，如En： En=⎛⎝⎜⎜⎜⎜⎜10000100⋯⋯⋱⋯00⋮1⎞⎠⎟⎟⎟⎟⎟ 数量矩阵（kE）： 主对角元素为K，其他元素为0的方阵是数量矩阵（就是一个数乘以一个单位矩阵），如kEn： En=⎛⎝⎜⎜⎜⎜⎜k0000k00⋯⋯⋱⋯00⋮k⎞⎠⎟⎟⎟⎟⎟ 对角矩阵： 主对角是非零元素但未必相同，其他元素为0的方阵是对角矩阵，如λn： λn=⎛⎝⎜⎜⎜⎜⎜λ10000λ200⋯⋯⋱⋯00⋮λn⎞⎠⎟⎟⎟⎟⎟ 矩阵的计算： 矩阵相加： 在同型矩阵中。两个m×n矩阵A和B的和，标记为A+B，得到的仍一是个m×n矩阵，其内的各元素为其相对应元素相加后的值。例如： ⎡⎣⎢111302⎤⎦⎥+⎡⎣⎢072051⎤⎦⎥=⎡⎣⎢1+01+71+23+00+52+1⎤⎦⎥=⎡⎣⎢183353⎤⎦⎥ 矩阵相减： A-B内的各元素为其相对应元素相减后的值： ⎡⎣⎢111302⎤⎦⎥−⎡⎣⎢072051⎤⎦⎥=⎡⎣⎢1−01−71−23−00−52−1⎤⎦⎥=⎡⎣⎢1−6−13−51⎤⎦⎥ 矩阵相乘： 当矩阵A的列数和矩阵B的行数相等时才有意义。 如Am×n，Bn×p，因为A的列（n）和B的行（n）相同，所以他们可以相乘，它们的乘积为ABm×p;
例如A2×3×B3×2： [1−10321]×⎡⎣⎢321110⎤⎦⎥=[(1×3+0×2+2×1)(−1×3+3×2+1×1)(1×1+0×1+2×0)(−1×1+3×1+1×0)]=[5412] 乘法不满足交换律 ： AB ≠ BA；乘法结合律 ： （AB）C=A（BC）；乘法分配律： A（B+C）=AB+AC，（B+C）A=BA+CA；乘法和数乘结合律： λ（AB）=（λA）B=A（λB）；单位矩阵满足： AE=EA=A； 零矩阵满足： 0m×nAs×n=0m×n，As×n0n×t=0s×t； 矩阵转置： 把矩阵A的行换成同序数的列得到的矩阵，叫做A的转置矩阵，记作AT A2×3=(142536),AT=⎛⎝⎜123456⎞⎠⎟3×2 (AT)T=A(A+B)T=AT+BT(λA)T=λAT(AB)T=BTAT 方阵的幂运算： An×Am=An+m (An)m=Anm A0=E(单位矩阵)
转载于:https://www.cnblogs.com/wuwuwu/p/6162323.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ace028185481401e76818031465550e/" rel="bookmark">
			Arcgis for js加载百度地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：
在前面的文章里提到了Arcgis for js加载天地图，在本节，继续讲解如何在Arcgis for js中加载百度地图。
效果：
地图
影像-无标注
影像-有标注
实现：
第一，在此感谢http://www.cnblogs.com/chenyuming507950417/p/3343729.html这篇文章的主人，给了我很大的启发与帮助，因为一直在找相关的参数，都不对，只有这个参数是没有问题的。
第二，百度地图可调用的有地图切片，影像切片，以及道路等POI切片，我将之用TiledMapServiceLayer做了扩展，成了BDAnoLayer，BDVecLayer，BDimgLayer三个图层，其代码如下：
BDAnoLayer.js
define(["dojo/_base/declare", "esri/layers/tiled"], function (declare) { return declare(esri.layers.TiledMapServiceLayer, { constructor: function () { this.spatialReference = new esri.SpatialReference({ wkid: 102100 }); this.initialExtent = (this.fullExtent = new esri.geometry.Extent(-20037508.3427892, -20037508.3427892, 20037508.3427892, 20037508.3427892, this.spatialReference)); this.scale = [591657527.591555,295828763.795777,147914381.897889,73957190.948944,36978595.474472,18489297.737236,9244648.868618, 4622324.434309,2311162.217155,1155581.108577,577790.554289,288895.277144,144447.638572,72223.819286, 36111.9096437,18055.9548224,9027.977411,4513.988705,2256.994353,1128.497176]; this.resolution = [156543.033928,78271.5169639999,39135.7584820001,19567.8792409999,9783.93962049996,4891.96981024998,2445.98490512499, 1222.99245256249,611.49622628138,305.748113140558,152.874056570411,76.4370282850732,38.2185141425366,19.1092570712683,9.55462853563415, 4.77731426794937,2.38865713397468,1.19432856685505,0.597164283559817,0.298582141647617]; this.tileInfo = new esri.layers.TileInfo({ "rows": 256, "cols": 256, "compressionQuality": 90, "origin": { "x": -20037508.3427892, "y": 20037508.3427892 }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ace028185481401e76818031465550e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ac232aeac231c909c049e959adf489/" rel="bookmark">
			JSON字符串转javabean，MorphDynaBean cannot be cast to...问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JSONObject jobj = JSONObject.fromObject(str); Student s = (Student) JSONObject.tobean(jobj，Student.class); 是没有问题的，但是如果属性中含有复杂的类型，当其中属性有类似List , Map ,ArrayList、自定义的类型，如List&lt;Teacher&gt; teachers, 就不可以了。 会报错：MorphDynaBean cannot be cast to con.test…… 在JSONObject.toBean的时候如果转换的类中有集合,可以先定义Map&lt;String, Class&gt; classMap = new HashMap&lt;String, Class&gt;();在classMap中put你要转换的类中的集合名,像:classMap.put("teachers", Teacher.class);然后在toBean()的时候把参数加上, 像:Student student=(Student) JSONObject.toBean(str, Student.class, classMap); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33fdb4989be53a32e502c93c52a2e145/" rel="bookmark">
			ArcGIS Engine二次开发——计算shapefile面图层要素的面积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天，有个同事问我怎么计算面图层的面积，我也是好久没做AE的事情了，简单的查了查，告诉他用IArea接口。到了下午，他的这个问题依旧没有解决，继续求助于我。我百度了下，没有找到相应的文章，于是我意识到这个简单的事情，可能对于很多接触AE不深的人，真的是非常难得事情。最难的可能是不知道怎么做，就像我的同事一样。我很快就告诉他用IArea接口，他却惊讶的问我“你怎么知道的？”，并说他也是查到“似乎是用这个接口”，当然这是第一个层次的，属于还没入门，刚刚开始接触AE，所有的事情基本全都靠搜索引擎来解决，从网上找到代码了问题就解决了，找不到就解决不了。另一个层次的选手是知道要用某个接口，可是就是不知道怎么用，这种层次的，就算是入门了，但是还不精通，遇到问题不知道如何下手。其实无论什么层次，全部都应该学会看AE的类图和帮助，尤其是类图，在安装目录下的Diagram目录里，看多了自然就会得心应手。废话不多说了，下面是我写的一段试验代码，公布一下，希望能帮助那些有需求的童鞋，给他们节省点时间。
using System.Runtime; using System.Runtime.InteropServices; using ESRI.ArcGIS.Geodatabase; using ESRI.ArcGIS.DataSourcesFile; using ESRI.ArcGIS.Geometry; private void Form1_Click(object sender, EventArgs e) { IWorkspaceFactory pWSF = null; double dArea = 0; try { pWSF = new ShapefileWorkspaceFactoryClass(); IFeatureWorkspace pWS = pWSF.OpenFromFile(@"H:\水体淹没面积", 0) as IFeatureWorkspace; IFeatureClass pFC = pWS.OpenFeatureClass("水体淹没面积专题.shp"); IFeatureCursor pFeatureCur = pFC.Search(null, false); IFeature pFeature = pFeatureCur.NextFeature(); while (pFeature != null) { if (pFeature.Shape.GeometryType == esriGeometryType.esriGeometryPolygon) { IArea pArea = pFeature.Shape as IArea; dArea = dArea + pArea.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33fdb4989be53a32e502c93c52a2e145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a88194fa435c830b6ef1a6965372b6ec/" rel="bookmark">
			cocos3.4 改变窗口大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 void Director::changeWinSize( Size size ) { getOpenGLView()-&gt;setFrameSize(size.width ,size.height); _winSizeInPoints = size; setProjection(cocos2d::Director::Projection::_2D); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653a058800ea359dda6d43e1942092a3/" rel="bookmark">
			mysql只能localhost连接，解决不允许其他机器去访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ERROR 1130: Host ***.***.***.*** is not allowed to connect to this MySQL server 登陆mysql 首先 use mysql； 按照别人提供的方式update的时候，出现错误。 mysql&gt; update user set host='%' where user = 'root'; ERROR 1062 (23000): Duplicate entry '%-root' for key 'PRIMARY' 然后查看了下数据库的host信息如下： mysql&gt; select host from user where user = 'root'; +-------------+------+ | host | user | +-------------+------+ | % | root | | 127.0.0.1 | root | | MicroLetter | | | MicroLetter | root | | localhost | | +-------------+------+ host已经有了%这个值，所以直接运行命令： mysql&gt;flush privileges; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e64eac77367593dbb16027ab3ebea538/" rel="bookmark">
			基于Jpcap的网络抓包&#43;分析软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这是我们网络编程与协议分析的课设，由于最近一直在用JAVA写项目，后面就快要写到界面了，所以干脆直接学习用JAVA来写这次的课设，算是一举两得了。
课设的要求是获取局域网内的所有数据包，并且分析TCP，UDP，ICMP各个字段，和一些应用层协议（HTTP，DNS等）。
要实现在JAVA下抓包，需要利用Jpcap这个包。它实现了JAVA到winpcap的一个中间接口，所以实际上它就是通过调用winpcap来实现抓包的，而winpcap说白了就是一个流氓软件，它提供了一个访问网络底层的能力，并且具有独立于系统的dll。
winpcap在去年计算机网络课设的时候已经安装过了，东西不知道丢哪了，这里只给个64为的Jpcap的包点击打开链接、
创建工程后导入就好，有时候会出现导入完了还是提示错误，这里我把jar全部删了然后重新导入一遍就没问题了，具体原因不知。
这段代码可以实现打开网卡列表，选择一个网卡(this.num)打开一个捕捉器，进行无限次抓包(参数 -1代表无限，其他正数代表抓多少包后停止)
将这段代码放在一个extends Thread 的类当中，并重载run函数可以实现多线程。
public void run(){ NetworkInterface[] devices = JpcapCaptor.getDeviceList(); try { jcap = JpcapCaptor.openDevice(devices[this.num], 65535, false, 20); } catch (IOException e) { e.printStackTrace(); } jcap.loopPacket(-1, new ClientPacketHandler()); }这里用到的ClientPacketHandler类是一个实现PacketReceiver接口的类，其中只有一个函数
public void receivePacket(Packet packet) { } 这个函数就是loopPacket抓到一个包后的处理函数，而packet就是相应的数据包，这里的Packet就是Jpcap下数据包的基类，直接从Object继承来，而其他的例如TCPPacket，IPPacket都是由它继承来的。 if(packet instanceof TCPPacket) //可以判断这个包是否是TCP包，其它同 TCPPacket tp = (TCPPacket)packet //可以将它转换成TCP数据包 EthernetPacket EP = (EthernetPacket)packet.datalink; //可以取出数据链路层头部 依次类推。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a2cad2295d4baf36e56721802a56a79/" rel="bookmark">
			Runtime.getRuntime().exec()执行阻塞问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ava中用Runtime.getRuntime().exec() 调用外部程序, 获取"标准输出流", 老是阻塞. 在网上找了找, 觉得应该是"错误输出流"的问题. 果然, 为"错误输出流"单开一个线程读取之, "标准输出流"就不再阻塞了. 源码如下:
/**执行外部程序,并获取标准输出*/ public static String excuteCmd_multiThread(String[] cmd,String encoding) { BufferedReader bReader=null; InputStreamReader sReader=null; try { Process p = Runtime.getRuntime().exec(cmd); /*为"错误输出流"单独开一个线程读取之,否则会造成标准输出流的阻塞*/ Thread t=new Thread(new InputStreamRunnable(p.getErrorStream(),"ErrorStream")); t.start(); /*"标准输出流"就在当前方法中读取*/ BufferedInputStream bis = new BufferedInputStream(p.getInputStream()); if(encoding!=null &amp;&amp; encoding.length()!=0) { sReader = new InputStreamReader(bis,encoding);//设置编码方式 } else { sReader = new InputStreamReader(bis,"GBK"); } bReader=new BufferedReader(sReader); StringBuilder sb=new StringBuilder(); String line; while((line=bReader.readLine())!=null) { sb.append(line); sb.append("/n"); } bReader.close(); p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a2cad2295d4baf36e56721802a56a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324e2904e07b9565cb19fb95f4ab814d/" rel="bookmark">
			一个带有标记的SeekBar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个带有标记的SeekBar 对原生的SeekBar做了几个修改：
实现了进度在浮动窗显示去掉了进度条变色区域添加了可点击标记，点击指定标记，跳转到指定进度屏蔽了非标记区域的点击事件，只能通过滑动到非标记进度 效果图如下： 这个实现参考了，在GitHub上的地址： https://github.com/flyerSea/MarkSeekbar.git
浮动进度显示参考了GitHub上的这两个项目： https://github.com/azzits/CustomSeekbar.git https://github.com/soyoungboy/NumberSeekBar.git
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdd79b2f198e92d42d3e62a4c7e8dd78/" rel="bookmark">
			在ListViewIitem中实现文字可复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 突然遇到一个问题，需要使ListView中的文字可以复制。第一想到的解决方案就是使用EditText 替换TextView，背景透明。
这时看起来也不错，功能是有了，不过这时不仅可以复制还可以粘贴，在点击的时候，还会弹出软键盘。
这时需要在EditText添加两条属性，android:editable="false" ，使其不可编辑，不会有软键盘弹出，不可以复制，不可以粘贴。（ android:editable="false" 这个属性在sdk10之后可以用android:inputType="none"替换）
接着添加android:textIsSelectable="true" 。这时可以复制文字了。
下面是一个示例：
&lt;EditText android:id="@+id/etMessage" android:layout_width="match_parent" android:layout_height="wrap_content" android:textIsSelectable="true" android:editable="false"/&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d895610edbda31fb00a471913087aa94/" rel="bookmark">
			实例4：osganimationsolid例子实现关键帧插值动画(OSG程序开发实例集)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 该例子实现关键帧动画功能,主要由五部分组成：
1）场景组织
2）具体动画影响节点Trans的设置
3）第三部分：基本动画管理更新回调及两个动画的设置
#include &lt;osg\libs.h&gt;
//建立一个坐标轴，三个轴用不同的颜色显示
osg::Geode* createAxis()
{
osg::Geode *geode (new osg::Geode());
osg::Geometry *geometry (new osg::Geometry());
osg::ref_ptr&lt;osg::Vec3Array&gt; vertices (new osg::Vec3Array());
vertices-&gt;push_back (osg::Vec3 ( 0.0, 0.0, 0.0));
vertices-&gt;push_back (osg::Vec3 ( 10.0, 0.0, 0.0));
vertices-&gt;push_back (osg::Vec3 ( 0.0, 0.0, 0.0));
vertices-&gt;push_back (osg::Vec3 ( 0.0, 10.0, 0.0));
vertices-&gt;push_back (osg::Vec3 ( 0.0, 0.0, 0.0));
vertices-&gt;push_back (osg::Vec3 ( 0.0, 0.0, 10.0));
geometry-&gt;setVertexArray (vertices.get());
osg::ref_ptr&lt;osg::Vec4Array&gt; colors (new osg::Vec4Array());
colors-&gt;push_back (osg::Vec4 (1.0f, 0.0f, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d895610edbda31fb00a471913087aa94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46fcda6746202c2d02b45c4230ca8932/" rel="bookmark">
			实例2:5行代码实现浏览三维模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ #include &lt;osg/libs.h&gt;
void main()
{
osgViewer::Viewer viewer; //创建视图类对象
viewer.setSceneData(osgDB::readNodeFile("F://osg2015Y3M19D(result)//data//glider.osgt"));
viewer.run();//运行仿真循环，直至接收到Esc键，程序退出。
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b83ce081feb7fba01fb44f74ce28978d/" rel="bookmark">
			matlab legend图例无边框和输出高次方项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图例无边框
legend boxoff; 图例中输出高次方项
legend（'x^2','x^3'）; 效果如图所示
详细代码请看上一篇《高斯分布概率密度函数（PDF）和累积分布函数(CDF)》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb28c6f24d77cd57cad9ef7a17e7ca8/" rel="bookmark">
			canvas.drawRoundRect方法，绘制圆角矩形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public void drawRoundRect (RectF rect, float rx, float ry, Paint paint)
Draw the specified round-rect using the specified paint. The roundrect will be filled or framed based on the Style in the paint.
Parameters
rect The rectangular bounds of the roundRect to be drawn
rx The x-radius of the oval used to round the corners
ry The y-radius of the oval used to round the corners
paint The paint used to draw the roundRect
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acb28c6f24d77cd57cad9ef7a17e7ca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20375fc96eac42bfe46f1ab7dc9edf14/" rel="bookmark">
			Erlang 集群互连测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Erlang 集群互连测试 Erlang节点相同cookie全互联成为一个集群（cluster）. 如果2个集群不同cookie, 然后其中有节点连接到对方集群的节点， 这2个集群会合并成一个集群吗？ 连接到另一个集群时，需要先设置cookie，不然会被拒绝。 erlang:set_cookie(Node2, DiffCookie) 集群aaaa有节点a1, a2, cookie为 cookie_aaaa. 集群bbbb有节点b1, b2, cookie为 cookie_bbbb. &gt;erl -sname a1 -setcookie cookie_aaaa ... &gt;erl -sname a2 -setcookie cookie_aaaa
Eshell V6.3 (abort with ^G)
(a2@jinqing)3&gt; net_adm:ping(a1@jinqing).
pong
(a2@jinqing)4&gt; nodes().
[a1@jinqing] &gt;erl -sname b1 -setcookie cookie_bbbb ... &gt;erl -sname b2 -setcookie cookie_bbbb
(b2@jinqing)2&gt; net_adm:ping(b1@jinqing).
pong
(b2@jinqing)3&gt; nodes().
[b1@jinqing] bbbb节点无法直接连aaaa节点 (b2@jinqing)4&gt; net_adm:ping(a1@jinqing).
pang b2节点更改cookie后，仍保持与b1的连接。 (b2@jinqing)6&gt; erlang:get_cookie().
cookie_bbbb
(b2@jinqing)7&gt; erlang:set_cookie(node(), abcd).
true
(b2@jinqing)8&gt; erlang:get_cookie().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20375fc96eac42bfe46f1ab7dc9edf14/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/555/">«</a>
	<span class="pagination__item pagination__item--current">556/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/557/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>