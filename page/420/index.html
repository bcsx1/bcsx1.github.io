<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84fdb2644763fa8be552ef07753be873/" rel="bookmark">
			基于OpenCV的SSIM算法实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 最近接到了一个需求，需要对比图片并自动生成对比报表，核心功能就是获取图片相似度，生成表格。
这里仅介绍如何实现的图片相似度获取；
思路 相似度计算的算法选择的是SSIM算法，具体算法原理参考的是SSIM 的原理和代码实现，算法中涉及了卷积运算，还有图片的矩阵运算，决定选用OpenCV库来实现。因为后台使用的是C#写的，OpenCV使用的是C++，所以决定用C++封装图像相似度处理的函数，通过dll导出接口到C#中使用;（C#中有已经封装的OpenCV库，OpencvSharp和Emgu都是很好的，但是这次功能简单，没有必要使用)
实现 VS2019下的OpenCV环境搭建 OpenCV源代码编译 从https://opencv.org/releases/下载源代码，如果不介意官方打包的dll和lib体积太大的话，也可以下载exe版本，双击即可，可以省去后面的编译步骤从https://cmake.org/download/下载cmake，用于源码编译下载完cmake后解压，运行 解压目录/bin/cmake-gui.exe ，通过Browse Source找到第一步下载解压的OpenCV源码目录，然后选择一个结果输出路径比如我这里分别是：E:/Program Zip/opencv-4.4.0/opencv-4.4.0和 E:/Program Zip/opencv-4.4.0/opencv-4.4.0/build
点击左下角的Configure按钮，选择编译选项如下，然后点finish；这里我只配置了64位的，其他平台可以自行选择
-待配置完成后，点击generate，等待生成完成，点击project按钮打开解决方案选择Debug或Releas编译选项，在 INSTALL项目上右键，Build漫长的Build之后，你会在输出目录下(比如我的是E:\Program Zip\opencv-4.4.0\opencv-4.4.0\build\install)看到, 如果中间报了python相关的错误，可以忽略
到这里，opencv的编译就成功完成了 项目配置 把上一步编译好的opencv库中的 include,x64目录拷贝到合适的地方，最好是release合debug版本的分目录存放，下面是我的目录结构，因为暂时不考虑多个vs版本的，所以x64下面的vc目录去掉了
新建一个空的C++项目
在项目上右键，跳转到: 属性页-&gt;Configuration Properties-&gt;General-&gt;Configuration Type，修改为Dynamic Library (.dll)
跳转到：属性页 -&gt;C/C++-&gt;General-&gt;Additional Include Directories，填入存放opencv库的include目录的路径
跳转到：属性页-&gt;Linker-&gt;General-&gt;Additional Library Directories，填入存放opencv库的 路径中对应版本的lib路径，我这里使用了相应的编译选项宏以及编译平台宏，可以视情况选择
跳转到：属性页-&gt;Linker-&gt;Input-&gt;Additioinal Dependencies；release编译选项下填入opencv_core440.lib opencv_imgcodecs440.lib opencv_imgproc440.lib opencv_gapi440.lib opencv_calib3d440.lib,debug选项下记得名字后面要加d，因为我的代码中只用到了这些lib，所以只填了这些lib，如果不介意大小的话，可以把opencv所有的lib都加上，这样可以避免出现 找不到定义的报错
到此，项目配置就完成了，dll我们就直接拷贝到项目的输出路径去即可，可以按需拷贝，运行若报错说某个dll找不到就拷贝过去即可
SSIM的算法实现 算法的原理可以参考SSIM 的原理和代码实现，讲的非常清晰，同时也建议阅读下python下的实现
下面是计算图片差异的核心函数，返回的Mat中 包含了两幅图片各个像素点的相似度，如果需要整张图的，求一下均值即可;完整代码放在末尾
static const double C1 = 6.5025, C2 = 58.5225; Mat Compare_SSIM(Mat image1, Mat image2) { Mat validImage1, validImage2; image1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84fdb2644763fa8be552ef07753be873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35aadb3f45a5458128c95f37a10eb6b5/" rel="bookmark">
			ElasticSearch reindex超时怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 发现千万级数据定义的字段类型不对,然后需要新建索引,将旧的数据导到新的索引上,往往会出现超时现象
{"statusCode":502,"error":"Bad Gateway","message":"Client request timeout"} 解决方法wait_for_completion=false POST /_reindex?slices=9&amp;refresh&amp;wait_for_completion=false { "source": { "index": "dw_xxxx", "size": 10000 }, "dest": { "index": "dw_xxxx_nw" } } // reindex 时候加上,可以在重建的时候把旧数据中相应的字段移除 "script": { "source": "ctx._source.remove(\"update_time\");ctx._source.remove(\"create_time\");" } //修改keyword类型为指定date类型 "script": { "source": """ def sou = new SimpleDateFormat("yyyy-MM-dd HH:mm"); def des = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); def comment_time = des.format(sou.parse(ctx._source.comment_time)); def post_time = des.format(sou.parse(ctx._source.post_time)); ctx._source.comment_time=comment_time;ctx._source.post_time=post_time;""" } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da82bd5e27e2cd4acc5af6bc87fad007/" rel="bookmark">
			MySQL设置编码的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、查看编码 SHOW VARIABLES LIKE '%set%'; 二、将编码设置为UTF-8 SET character_set_client = utf8; SET character_set_connection = utf8; SET character_set_database = utf8; SET character_set_database = utf8; SET character_set_results = utf8; SET character_set_server = utf8; SET character_set_system = utf8; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e40a49f0b70147dec400fa2db706a5f7/" rel="bookmark">
			python学习笔记2 序列概述——列表、元组和字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 序列概述 数据结构是以某种方式（如通过编号）组合起来的数据元素（如数、字符乃至其他数据结构）集合。（A data structure is a specialized format for organizing and storing data.）
在Python中，最基本的数据结构为序列（sequence）。序列中的每个元素都有编号，即其位置或索引，其中第一个元素的索引为0，第二个元素的索引为1，依此类推。
基本的序列包括：列表、元组、字符串。其中，列表和元组的主要不同在于，列表是可以修改的，而元组不可以。这意味着列表适用于需要中途添加元素的情形，而元组适用于出于某种考虑需要禁止修改序列的情形。
Python支持一种数据结构的基本概念，名为容器（container）。容器基本上就是可包含其他对象的对象。两种主要的容器是序列（如列表、元组、字符串）和映射（如字典）。在序列中，每个元素都有编号，而在映射中，每个元素都有名称（也叫键）。有一种既不是序列也不是映射的容器，它就是集合（set）。
2. 序列的通用操作 索引、切片、相加、相乘和成员资格检查适用于所有的序列。另外，Python还提供了一些内置函数，可用于确定序列的长度以及找出序列中最大和最小的元素。
2.1 索引 按照元素的编号来访问各个元素，即为索引（indexing）。序列从左向右，以0作为第一个元素的编号，编号依次递增；从右向左，以-1作为最后一个元素的编号，编号依次递减。
&gt;&gt;&gt; greeting = 'Hellow' &gt;&gt;&gt; greeting[0] 'H' &gt;&gt;&gt; greeting[-1] 'w' &gt;&gt;&gt; 'Hellow'[1] 'e' &gt;&gt;&gt; fourth = input('Year:')[3] Year:2008 &gt;&gt;&gt; fourth '8' 2.2 切片 除使用索引来访问单个元素外，还可使用切片（slicing）来访问特定范围内的元素。
切片顾头不顾尾（例如[-3:-1]，无法索引到最后一个元素）；如果第一个索引指定的元素位于第二个索引指定的元素后面（如：[-3:0]，结果就为空序列）；简写的重要性，当冒号后不写任何内容时，切片直接结束于序列的末尾（例如索引最后三个元素:[-3:]）；步长，表示索引每次移动的方向和大小，为正时，表示向右移动，反之向左。当步长为负值时，第一个索引指定的元素可以位于第二个索引指定的元素后面，而上述[-3:0]结果为空序列的原因是该操作种默认是步长为正1，索引向右移动到达末尾，而无法到达第一个元素，返回空序列。 2.3 序列相加 可使用加法运算符拼接序列。
&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; 'Hellow, ' + 'World!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e40a49f0b70147dec400fa2db706a5f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c828baf6ed4bfdc26a3ad287ed13699d/" rel="bookmark">
			phpstrom 使用起来很卡的解决办法：The IDE is running low on memory and this might affect performance. Please cons
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当IDE 提示这个的时候：
The IDE is running low on memory and this might affect performance. Please consider increasing available heap.
说明：IDE内存不足，这可能会影响性能。请考虑增加可用堆。
解决：
ｈｅｌｐ－&gt;Diagonstic-&gt;Change menory settings
将内存数值改为2048M 或者更大，以增大phpstrom 的运行内存。
因在工作中遇到一个JS文件6万行代码，需要去优化时，打开或编辑的时候很卡，所以此方法有效解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d15e00e585a5b43e0be7911fe51ecaa3/" rel="bookmark">
			CentOS7下安装Redash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7下安装Redash
安装docker-ce docker-compose
1、安装docker-ce
首先删除较旧版本的docker（如果有）：
yum remove docker docker-common docker-selinux docker-engine-selinux docker-engine docker-ce
下一步安装需要的软件包：
yum install -y yum-utils device-mapper-persistent-data lvm2
配置docker-ce repo：
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
最后安装docker-ce：
yum install docker-ce
修改默认存储路径
vim /usr/lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
修改为：
ExecStart=/usr/bin/dockerd --graph /data/docker -H fd:// --containerd=/run/containerd/containerd.sock
2、安装
sudo curl -L "https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
安装Redash
mkdir /opt/redash
cd /opt/redash
#从GitHub下载源码
git clone https://github.com/getredash/redash.git
#创建docker-compose.production.yml文件,内容参考yml配置
# This is an example configuration for Docker Compose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d15e00e585a5b43e0be7911fe51ecaa3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfbe1a8bd7427f682b1def4a737e630b/" rel="bookmark">
			python - 输出列表自动对齐（支持中英文混合）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python - 输出列表自动对齐（支持中英文混合） 直接输出列表太难看？
是这样？
还是这样？
废话不多说，直接上代码
#实现中文字符对齐的方法 def aligns(string,length=20): difference = length - len(string) # 计算限定长度为20时需要补齐多少个空格 if difference == 0: # 若差值为0则不需要补 return string elif difference &lt; 0: print('错误：限定的对齐长度小于字符串长度!') return None new_string = '' space = '　' for i in string: codes = ord(i) # 将字符转为ASCII或UNICODE编码 if codes &lt;= 126: # 若是半角字符 new_string = new_string + chr(codes+65248) # 则转为全角 else: new_string = new_string + i # 若是全角，则不转换 return new_string + space*(difference) # 返回补齐空格后的字符串 #自动制表自动对齐 def tabulator(inputlist,column,length=20): p = '' num = 0 sum = len(inputlist) for i in inputlist: p = p + aligns(i,length) num = num + 1 sum = sum - 1 if num &gt;= column: print(p) p = '' num = 0 elif sum &lt;= 0: print(p) 参数解释：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfbe1a8bd7427f682b1def4a737e630b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c333b11c67c9a5f1b979bcc6016b80e3/" rel="bookmark">
			SQL查询，分组取top n
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL查询，分组取top n
一、关系型数据库 mysql：
1、自身join，having count(1) &gt; n
2、嵌套查询，where n &lt; (select count(1) from table where xx=xx)
二、分布式并行计算 hive sql：
使用开窗函数 row_number() over (partition by xx order by xxx)
select *
from (
select *, row_number() over (partition by 分组字段 order by 排序字段 desc) as od
from (
数据表
) a
) t where od&lt;= n
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63c7de8522781604f2226d4d2459327f/" rel="bookmark">
			Visual Assist X使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		****
部分快捷键 Shift+Alt+F Find References 查找引用 Shift+Alt+S FindSynbolDialog打开查找符号对话框
Alt+G GotoImplementation调到实现
Alt+M ListMethodsInCurrentFile
Alt+Left Arrow NavigateBack 后台
Alt+O OpenCurrespondingFile .h/.cpp切换
Shift+Alt+O OpenFileInSolutionDialog打开解决方案文件对话框
Ctrl+Shift+V Parse弹出最近10个copy的内容菜单
Shift+Alt+Q RefactorContextMenu 弹出重构菜单
Shift+Alt+C RefactorCreateFromUsage
Shift+Alt+R RefactorRename改名
Alt+Down Arraw ScopeNext
Alt+Up Arraw ScopePrevious
**** open file in solution 打开文件中的解决办法
open Corresponding file 打开相应文件
list methods in current file 列表方法在当前文件
file symbol 文件标记
find references 找到参考资料
find references in file 找到参考文件
clone find references results 寻找克隆结果
find previous by context 找到以前的前后关系
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63c7de8522781604f2226d4d2459327f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfed18aa3a0cf31f7778f6c702660d47/" rel="bookmark">
			vue无感知页面刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中处理中，常常有需要删除或更新数据之后刷新当前页面的需求
一般页面刷新使用 router.go(0) 或者window.reload()等刷新时，整个浏览器进行重新加载，闪烁，出现白屏状态，用户体验很差。
处理方法
provide / inject 组合
作用：允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。
App.vue:
声明reload方法，控制router-view的显示或隐藏，从而控制页面的再次加载
&lt;template&gt; &lt;div id="app"&gt; &lt;router-view v-if="isRouterAlive" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "App", provide() { return { reload: this.reload, }; }, data() { return { isRouterAlive: true, }; }, methods: { reload() { this.isRouterAlive = false; this.$nextTick(function () { this.isRouterAlive = true; }); }, }, }; &lt;/script&gt; 然后在你需要刷新的页面中调用this.reload的组件添加inject属性
export default { inject:['reload'], data() { return { } } } 最后在你相应的方法中调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfed18aa3a0cf31f7778f6c702660d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33aaa3dc79cce8dd600ecfb14feeedcd/" rel="bookmark">
			集合包含关系算法(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 已知一个List
list.add(“123”);
list.add(“1”);
list.add(“123456”);
list.add(“123”);
list.add(“124”);
从list中求出一个集合, 里面的元素彼此没有包含关系(去掉被包含的)
比如上面的元素123包含1, 那么取123; 123456包含123, 取123456
最后要的集合肯定只有两个元素, 就是123456和124
方案一: 思路: 迭代器拿到每一个元素, 然后for循环比较, 如果存在包含关系, 就将此元素去除掉.
List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("123"); list.add("1"); list.add("123456"); list.add("123"); list.add("124"); Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext()) { String s = iterator.next(); for (int i = 0; i &lt; list.size(); i++) { if (list.indexOf(s) == i) { continue; } if (list.get(i).contains(s)) { iterator.remove(); break; } } } list.forEach(System.out::println); 注: 此方案是由一个群友提供
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fb798cfdbabdb0259dfd232de775a30/" rel="bookmark">
			水仙花数的判断 — C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 水仙花数 水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身（例如：1^3 + 5^3+ 3^3 = 153）。
C++实现代码 #include &lt;iostream&gt; #include &lt;math.h&gt; using namespace std; int f,s,t,temp; int judge(int n){//拆数，针对三位数 f=n/100; s=(n/10)%10; t=n%10; temp=pow(f,3)+pow(s,3)+pow(t,3); if(temp==n){ return n; }else{ return 0; } } int main(){ int m,n,i,count=0; cin&gt;&gt;m&gt;&gt;n; for(i=m;i&lt;=n;i++){ if(judge(i)){ cout&lt;&lt;judge(i)&lt;&lt;" "; count++; } } if(!count){ cout&lt;&lt;"no";//非水仙花数 } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a52d5c01ea38c491acd5884bc4572e/" rel="bookmark">
			使用径向渐变实现两端凹槽，卡券效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手头有个需求，需要实现如下效果：
实现途中两边的凹槽效果，一开始的思路是使用伪类，html中中间凹槽和分割线是一个div，代码如下：
&lt;template lang="jade"&gt; act-dialog( :visible="visible", width="80%", @cancel="handleCancel" ) .store-content(slot="content") .header-area 联系商家 .store-info .store-name img.name( src="//cdn.s.shangjiadao.cn/source/images/mapupgrade/icon_store.png" ) {{storeinfo.store_name}} .store-address 地址：{{storeinfo.store_address}} .store-phone .phone 电话：{{storeinfo.store_phone}} .call img.icon-phone( src="//cdn.s.shangjiadao.cn/source/images/mapupgrade/icon_phone.png" ) a.clickmobile( :href="`tel:${storeinfo.store_phone}`" ) 拨号 .break-line .line .qrcode-box img.qrcode( :src="storeinfo.qrcode" ) .tip 长按识别商家二维码 &lt;/template&gt; &lt;script src="./index.js"&gt;&lt;/script&gt; &lt;style lang="less" scoped&gt; @import "./index.less"; &lt;/style&gt; &amp;:before{ content: ""; display: block; position: absolute; top: 6px; width: 10px; height: 24px; border-radius: 5px 0 0 5px; background: radial-gradient(16px at left, rgba(0,0,0,0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5a52d5c01ea38c491acd5884bc4572e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c57746aa021d934951be68a26b99f21c/" rel="bookmark">
			el-table-column如何获取其他列中的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-table-column是el-table中的列属性。
思路：采用插槽的方式即在slot-scope中获取 例如要获取该行中其他的属性比如文件id，那么可以直接在scope.row中取得，scope.row代表本行的所有数据，是一个字典：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bffb6e0212d2af05e71b1a315a46e78/" rel="bookmark">
			Spring中的HttpEntity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记是从Spring的文档中自己整理和翻译的
HttpEntity：代表一个HTTP请求或响应实体，由headers和body组成；一般和RestTemplate一起使用
1、常见使用方式一：HTTP request
RestTemplate restTemplate = new RestTemplate(); //请求头 HttpHeaders headers = new HttpHeaders(); //设置body的类型：纯文本形式 headers.setContentType(MediaType.TEXT_PLAIN); //第一个参数：body,第二个参数：headers HttpEntity&lt;String&gt; entity = new HttpEntity&lt;&gt;("HelloWorld", headers); //第一个参数：请求地址，第二个参数：一个HTTP请求 URI location = restTemplate.postForLocation("http://localhost:8080", entity); 2、常见使用方式二：HTTP response
RestTemplate restTemplate = new RestTemplate(); //第一个参数：URL地址，第二个参数：响应类型 HttpEntity&lt;String&gt; entity = restTemplate.getForEntity("http://localhost:8080", String.class); //响应体 String body = entity.getBody(); //响应体类型 MediaType contentType = entity.getHeaders().getContentType(); 3、使用方式三：在Spring MVC中使用，作为@Controller方法的返回值
@RequestMapping("/handle") public HttpEntity&lt;String&gt; handle() { HttpHeaders responseHeaders = new HttpHeaders(); responseHeaders.set("MyResponseHeader", "MyValue"); //设置头信息 return new HttpEntity&lt;String&gt;("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bffb6e0212d2af05e71b1a315a46e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7fd285defd8250388693728adaa4f3f/" rel="bookmark">
			CANDela studio 常用使用配置( For edit CAN Diagnostic databse)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(本文介绍车载诊断功能开发流程及工具操作)
汽车车载诊断功能由项目支持的各诊断服务组成，如22h读数据功能，2E写数据功能，19读诊断信息功能等。
目前的开发流程中，诊断协议栈的代码通过工具自动生成，输入文件为诊断数据库文件，格式为CDD，编辑CDD文件的软件为CANdela。
1 诊断调查表编辑
诊断开发第一步需确认项目所支持的服务及子服务的内容。因诊断功能是由整车厂及供应商协同开发且实际变更需求较大，故前期使用一个诊断调查表(特点：整车厂及供应商都要编辑该表)来记录当前的诊断功能。
当双方对诊断调差表内容达成一致后，便可依据其内容进行诊断软件开发。
2 诊断调查表CDD文件
2.1 打开CDD文件
CDD文件放在工程目录inputfile文件夹下，需安装软件CANdela及usb-over-network.
2.2 编辑项目相关信息
需根据输入确认如下内容：
诊断报文ID(物理寻址+功能寻址)
P2及P2*定时器参数
S3定时器参数
STmin及BlockSize
2.3 配置支持的服务
不同项目之间以及升级软件及应用软件之间，其支持的服务种类是不一样的，比如APP软件较Boot软件，就不支持34，36，37服务。
2.4 配置10服务
修改点：
1-子服务名称
2-子服务ID
3-子服务请求报文/肯定响应报文/否定响应报文格式
4-点击3后的yy；4处内容为肯定响应报文具体组成，主要为数据格式及数据名。
点击3后的RC，4处内容为子服务支持的否定响应码集合。
注：需注意每个子服务请求报文及响应报文的字节数，体现在自定义的data type中。
注：点击这里进行服务熟悉配置，图片上的P代表该子服务支持物理寻址，F代表该服务支持功能寻址。
配置该子服务支持的会话类型
有些服务需在特定的会话下才能支持，如编程会话下不支持10 03服务。
配置该服务是否需安全等级
配置该服务支持的寻址类型
注：以上配置需与诊断调查表保持一致。
2.5 配置data type
数据类型用以表明报文数据的长度及数据类型，常见的数据类型有hex，decascII，binary。
数据类型也可组合不同数据类型的数据，如表明软件版本的数据V101；该data type就是由1个ascii加3个dec构成。
2.5.1 单类型数据data type
如建立一个3个字节类型为BCD的data type，右击，选择New data type–》Raw Value；其图标显示为
2.5.2枚举类型data type
顾名思义，该类型代表接收的数据，每个值代表特定的含义，方便开发人员解析数据。
如建立一个表示车辆模式的数据；右击，选择New data type–》Text table；其图标显示为
2.5.3 线性数据data type
接收的数据需要经过精度加偏移量进行计算，得到的数据才为实际代表的含义，如温度传感器采集的数据。
物理值 = 总线值*精度+偏移量
2.5.4 数据包data type
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7fd285defd8250388693728adaa4f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5de04b8351ea41c5da10c3f93d5ed78/" rel="bookmark">
			WebRTC实践获取视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术前言 通过上次课程“WebRTC简介”我们知道了WebRtc技术主要是为了实现网页之间的实时通讯，本次课程我们将用一个简单实例展开讲解WebRTC调取本地摄像头的具体方法及原理。
接口方法 语法
navigator.getUserMedia(constraints,successCallback, errorCallback );
参数
1. constraints
MediaStreamConstaints对象指定了请求使用媒体的类型，还有每个类型的所需要的参数。例如下面只获取视频而不获取音频:
var constraints = {
audio: false,
video: true
}
2. successCallback
当调用成功后，successCallback中指定的函数就被调用，包含了媒体流的MediaStream对象作为它的参数。
例如 getUserMedia() 函数执行成功, 摄像头视频流可以设置为video标签的src属性资源:
function successCallback(stream) { window.stream = stream; // stream available to console if (window.URL) { video.src = window.URL.createObjectURL(stream); } else { video.src = stream; } } 3. errorCallback
当调用失败，errorCallback中指定的函数就会被调用，MediaStreamError对象作为它唯一的参数。
滤镜处理 .videoStyle1 { -webkit-filter: blur(4px) invert(1) opacity(0.5); } .videoStyle2 { filter: hue-rotate(180deg) saturate(200%); -moz-filter: hue-rotate(180deg) saturate(200%); -webkit-filter: hue-rotate(180deg) saturate(200%); } 实例代码 &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5de04b8351ea41c5da10c3f93d5ed78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f524594a9203c80e92cc074bacd40e6/" rel="bookmark">
			Blender - 切割、挤出、细分修改器、Eevee 渲染引擎使用：天空盒、插值/平旦着色器、屏幕空间反射SSR、环境遮蔽AO、去噪点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 切割挤出细分 - 修改器天空盒平滑插值、平旦着色反射AO 环境遮蔽去噪点练习勺子杯子摆放好物件、灯光最后渲染效果 切割 先进入编辑模式：对一个网格对象选中后，按下 “Tab” 键，或是视口类型选择：Edit Mode 即可进入编辑模式
下面是切割工具，就是一个细分算法，非常实用
Ctrl + B 后，将鼠标移动需要切割的面上，出现切割绿色线后，按下鼠标左键即可，也可以在绿色线出现的时候，使用鼠标滚轮控制细分的分段数量
确定后会弹出一个 Loop Cut and Slide 的参数选择
这里主要看三个
Number of Cuts - 是细分段数Smoothness - 如果你切割的边不是对称的，Smothness 可以控制平滑过渡Falloff - 是平滑过渡的曲线 挤出 可以旋转点、线、面来挤出，也是很实用的
细分 - 修改器 修改器可以对一个对象的点、线、面、等，进行程序的逻辑控制
细分修改器是：Subdivision Modifier
在 Blender 中，每个对象都有 Modifier Properties 属性
选择后，它的属性有这些，如下图：
这里先主要看：Render,Viewport,Quality，的三个选项：分别是设置在不同模式下的细分参数，Render 表示在渲染是使用的细分参数，Viewport 是在设计时的视口细分量，Quality 是控制细分的质量系数。
还有一些 Options 是控制 uv 平滑的
还有一个比较重要的是：Apply 按钮，这个就想 应用变换（参考前一篇的：冻结或应用变换） 一样，这里的应用指的是将修改器对对象的修改的点、线、面的结果，应用到网格本身，并将网格更新，也是非常有用的一个功能，在 OpenGL 中，你可以理解为，可以对网格的 VBO 的修改结果应用后，变成了 VBO 的原始数据了。如下图 Apply 按钮：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f524594a9203c80e92cc074bacd40e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d00d5301017f0d88f4514f8d1c42a18a/" rel="bookmark">
			C# tolua 之间互传 byte[]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# tolua 之间互传 byte[] (金庆的专栏 2020.8)
lua中不区分 string 和 byte[], 而在 C# 中 string 和 byte[] 之间转换涉及编码。
C# 中一般这样转：
string类型转成byte[]：
byte[] byteArray = System.Text.Encoding.Default.GetBytes(str); byte[]转成string：
string str = System.Text.Encoding.Default.GetString(byteArray); Default 编码是本机当前所用编码，还可以用 ASCII, UTF8 等其他编码。
测了在 lua 中读入一块2进制数据，调用 tolua 导出的一个方法，如：
public void Print(string s) { byte[] buf = Systen.Text.Encoding.Default.GetBytes(s); Debug.Log(Bitconvert.ToString(buf)); } 测了 Default, ASCII, UTF8, ISO-8859-1(Latin-1), Unicode 发现得到的 byte[] 会出错。
也试了 C#中使用Buffer.BlockCopy()方法将string转换为byte array的方法
发现 tolua 传到 C# 的 string 已经是编码过的，直接复制也是错的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d00d5301017f0d88f4514f8d1c42a18a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7861c9a1ede29ec4b68328111dba476e/" rel="bookmark">
			Python 一招搞定禅道提交bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注【无量测试之道】公众号，回复【领取资源】,
Python编程学习资源干货、
Python+Appium框架APP的UI自动化、
Python+Selenium框架Web的UI自动化、
Python+Unittest框架API自动化、
资源和代码 免费送啦~
文章下方有公众号二维码，可直接微信扫一扫关注即可。
禅道是非常实用的项目管理平台，它在业界也是非常有名的，对于使用它来对bug进行管理也是相当便捷的，今天简单分享一下如何通过 api 来提交bug到禅道，代码如下：
import requests loginhost="http://zen.beta.cn/index.php?m=user&amp;f=login" #登录url add_bughost="http://zen.beta.cn/index.php?m=bug&amp;f=create&amp;productID=10&amp;branch=0&amp;extra=moduleID=0" #new bug url def add_bug(): header={'Content-Type': "application/x-www-form-urlencoded; charset=utf-8"}#设置请求头 datas={"account":"$admin","password":"123456"} #定义请求的数据 s=requests.session() #实例化一个session对象 response=s.post(loginhost,headers=header,data=datas)#使用session发起请求 print(response.content) data = { "product": "10", # int 所属产品 * 必填 "openedBuild": "master", # int | trunk 影响版本 * 必填 "branch": "2", # int 分支 / 平台 "module": "434", # int 所属模块 "project": "84", # int 所属项目 "assignedTo": "baoyi", # string 指派给 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7861c9a1ede29ec4b68328111dba476e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691c1f9ccce018fac56eec318ac388d2/" rel="bookmark">
			C&#43;&#43;11内存模型完全解读-从硬件层面和内存模型规则层面双重解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		章节 一、预备知识1. 同步点：2. synchronized-with(同步)：3. happens-before(先于发生)：4. sequenced-before： 二、内存模型简述1. relaxed order：2. acquire-release order：acquire-release的可传递性：release-sequence rule：consume： 3. sequence-consistent order(seq_cst)： 三、一些例子解读四、总结五、关于三种内存序的一些Tips C++11标准引入了一套新的内存模型，这套模型中共有三种模型，分别为sequentially-consistent模型、acquire-release模型和relaxed模型。三种模型对内存序的约束力是不一样的，sequentially-consistent的约束力最强，但是执行效率也最低。relaxed模型约束力最差，执行效率最高。acquire-release模型约束力居中，属于半约束，执行效率也居中。
本文假设你已经对C++的这些内存模型有一些基本的概念，并且也了解一些硬件方面的知识，比如缓存一致性协议(MESI)和store-buffer以及invalidate-queue。相关描述在网上有很多，比如硬件角度看内存屏障，为什么需要内存屏障(尤其是这个，这里面通过例子讲了很多重要的知识点，强烈推荐，看懂这个，你就会恍然大悟)以及知乎专栏的一系列文章(知乎上很多大牛都有相关文章，强烈建议去看看)等等。
另外，有很多博客和书籍也专门讨论了C++11的内存模型，比如大名鼎鼎的《C++ Concurrency In Action 2nd》，这本书比较详细的介绍和讨论了C++11的内存模型以及锁的使用，此书强烈建议看英文原版，中文版在内存模型那些章节翻译的太差，网上有很多英文pdf，加上谷歌翻译，有道翻译，基本就能看懂了。此外，还有Jeff Preshing在2012年的一些文章，也都特别的好。另外，有一些不懂的问题如果去StackOverFlow上查询的话，可能会获得很多意外的惊喜！
一、预备知识 在开始之前，还需要准备一些预备知识，或者一些口头约定，以方便下文的讨论。
1. 同步点： 对于一个原子类型变量a，如果a在线程1中进行store(写)操作，在线程2中进行load(读)操作，则线程1的store和线程2的load构成原子变量a的一对同步点，其中的store操作和load操作就分别是一个同步点。
可以看出，同步点具有三个条件：
必须是一对原子变量操作中的一个，且一个操作是store，另一个操作是load；这两个操作必须针对同一个原子变量；这两个操作必须分别在两个线程中。 2. synchronized-with(同步)： 对于一对同步点来说，当写操作写入一个值x后，另一个同步点的读操作在某一时刻读到了这个变量的值x，则此时就认为这两个同步点之间发生了同步关系。
同步关系具有两方面含义：
针对的是一对同步点之间的一种状态的描述；只有当读取的值是另一个同步点写入的值的时候，这两个同步点之间才发生同步； 也就是说，如果读取的值不是另外一个同步点写入的值，则此时这两个同步点之间并没有发生同步。
3. happens-before(先于发生)： 当线程1中的操作A先执行，而线程2中的操作B后执行时，A就happens-beforeB。happens-before是用来表示两个线程中两个操作被执行的先后顺序的一种描述。
happens-bofore有三个个特点：
可传递性。如果Ahappens-beforeB，Bhappens-beforeC，则有Ahappens-beforeC；当store操作A与load操作B发生同步时，则Ahappens-beforeB；happens-before一般用于描述分别位于两个线程中的操作之间的顺序。 4. sequenced-before： 如果在单个线程内操作A发生在操作B之前，则表示为Asequenced-beforeB。这个关系是描述单个线程内两个操作之前的先后执行顺序的，与happens-before是相对的。
此外，sequenced-before也具有可传递性，并且sequenced-before与happences-before之间也具有可传递性：如果线程1中操作Asequenced-before操作B，而操作Bhappences-before线程2中的操作C，操作Csequenced-before线程2中的操作D，则有操作Ahappences-before操作D。
二、内存模型简述 1. relaxed order： 当程序员所写的代码被编译器翻译成机器语言时，编译器可能会为了优化性能来重排程序员所写的代码，比如：
int a = 0; int b = 0; void func() { int t = 1; a = t; b = 2; } 编译器最终优化后的代码可能是这样子的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/691c1f9ccce018fac56eec318ac388d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1faad32f75613d70c5f8edca5fa0c595/" rel="bookmark">
			post请求,参数为空时异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http的post请求,当content-type是application/json时，接口参数没传值，报了如下异常：
java.io.EOFException: No content to map to Object due to end of input at org.codehaus.jackson.map.ObjectMapper._initForReading(ObjectMapper.java:2775) ~[jackson-mapper-asl-1.9.4.jar:1.9.4] at org.codehaus.jackson.map.ObjectMapper._readValue(ObjectMapper.java:2691) ~[jackson-mapper-asl-1.9.4.jar:1.9.4] at org.codehaus.jackson.map.ObjectMapper.readValue(ObjectMapper.java:1315) ~[jackson-mapper-asl-1.9.4.jar:1.9.4] at org.codehaus.jackson.jaxrs.JacksonJsonProvider.readFrom(JacksonJsonProvider.java:419) ~[jackson-jaxrs-1.9.4.jar:1.9.4] at org.jboss.resteasy.core.interception.AbstractReaderInterceptorContext.readFrom(AbstractReaderInterceptorContext.java:59) ~[resteasy-jaxrs-3.0.7.Final.jar:?] at org.jboss.resteasy.core.interception.ServerReaderInterceptorContext.readFrom(ServerReaderInterceptorContext.java:62) ~[resteasy-jaxrs-3.0.7.Final.jar:?] at org.jboss.resteasy.core.interception.AbstractReaderInterceptorContext.proceed(AbstractReaderInterceptorContext.java:51) ~[resteasy-jaxrs-3.0.7.Final.jar:?] at com.alibaba.dubbo.rpc.protocol.rest.support.LoggingFilter.aroundReadFrom(LoggingFilter.java:91) ~[dubbo-sf.2.1.0.jar:sf.2.1.0] at org.jboss.resteasy.core.interception.AbstractReaderInterceptorContext.proceed(AbstractReaderInterceptorContext.java:53) ~[resteasy-jaxrs-3.0.7.Final.jar:?] at org.jboss.resteasy.plugins.interceptors.encoding.GZIPDecodingInterceptor.aroundReadFrom(GZIPDecodingInterceptor.java:59) ~[resteasy-jaxrs-3.0.7.Final.jar:?] at org.jboss.resteasy.core.interception.AbstractReaderInterceptorContext.proceed(AbstractReaderInterceptorContext.java:53) ~[resteasy-jaxrs-3.0.7.Final.jar:?] at org.jboss.resteasy.core.MessageBodyParameterInjector.inject(MessageBodyParameterInjector.java:150) ~[resteasy-jaxrs-3.0.7.Final.jar:?] at org.jboss.resteasy.core.MethodInjectorImpl.injectArguments(MethodInjectorImpl.java:89) ~[resteasy-jaxrs-3.0.7.Final.jar:?] at org.jboss.resteasy.core.MethodInjectorImpl.invoke(MethodInjectorImpl.java:112) ~[resteasy-jaxrs-3.0.7.Final.jar:?] 解决方法就是传空json串.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d532bd23206adab86c4ad82aef482a14/" rel="bookmark">
			\textbf{文本}失效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在LATEX文章撰写过程中遇到这个问题，字体无法加粗，解决办法是在文章的开始，加入了\usepackage[T1]{fontenc}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/920eef859d3bbb3efbc6749f17e0aa89/" rel="bookmark">
			剪绳子的几种解法 — C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目描述动态规划求解求解代码贪心法求解求解代码 题目描述 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
牛客网题目链接
动态规划求解 我们定义函数 f ( n ) f(n) f(n)为把长度为n的绳子剪成若干段后乘积的最大值
则 f ( n ) = m a x ( f ( i ) − f ( n − i ) ) f(n)=max(f(i)-f(n-i)) f(n)=max(f(i)−f(n−i))：
把长度为n的绳子剪为长度为i和长度为n-i的两端，然后再求子问题 f ( i ) f(i) f(i)和 f ( n − i ) f(n-i) f(n−i)(i=1,2,...,n-1) 即：一个问题可以分解为子问题，要使得该问题最优，则子问题先要实现最优，因此我们可以使用动态规划的思路去求解
原问题从上到下使用递归法求解，动态规划的核心是填表，先求解子问题，然后自下而上求解，最终得到原问题的解
求解代码 class Solution { public: int cutRope(int number) { if(number&lt;4)return number; else{ int *tab =new int[number+1];//表格数组 int i,j; //以下为填表过程 tab[0]=0;tab[1]=1;tab[2]=2;tab[3]=3; for(i=4;i&lt;=number;i++){ tab[i]=0; for(j=1;j&lt;=i/2;j++){ if(tab[i]&lt;tab[j]*tab[i-j]) tab[i]=tab[j]*tab[i-j]; } } return tab[number];//表中最后一个即为所求 } } }; 运行时间：3ms 占用内存：608k 贪心法求解 尽可能地剪出长度为3的子段，但当最后一段所剩长度为4时，将其剪为2*2的两段落，因为2*2 &gt; 3*1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/920eef859d3bbb3efbc6749f17e0aa89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bfdab5aef023138edbc4564f32a5703/" rel="bookmark">
			信息搜集--dig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		信息搜集–dig dig 命令全称域信息搜索器，是一个用于查询 DNS 域名服务器信息的命令行工具.
dig的常用命令格式：
dig [@server] [-p port] [-t type] [-4] [-6] [+trace] name
@ 指定 DNS 查询使用的服务器名称或 IP ，IP 地址可以是用点分隔的 IPv4 地址也可以是冒号分隔的 IPv6 地址。当参数指定的值是服务器的主机名时，dig 命令会在查询该域名服务器前先解析该主机名；
-p 指定 DNS 查询使用的端口号，默认情况下 DNS 查询使用标准的53端口，若使用非端口则需要通过 -p 参数指定，可使用此选项来测试已配置为侦听非标准端口号上的 DNS 服务器；
-t 指定 DNS 查询的记录类型，常用的类型包括：A/AAAA/NS/MX/CNAME 等，缺省查询类型是 A ；
-4 指定 dig 命令仅使用 IPv4 查询传输；
-6 指定 dig 命令仅使用 IPv6 查询传输；
+trace 跟踪从根名称服务器开始的迭代查询过程，缺省情况不使用跟踪。启用跟踪时，dig 命令会执行迭代查询以解析要查询的名称，显示来自用于解析查询的每个服务器的应答。
dig响应的常用类型：
NS 记录：用来指定域名由哪个 DNS 服务器进行解析；
root@kali:~# dig -t ns qq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bfdab5aef023138edbc4564f32a5703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/220e74d889e07aea36875e458714058a/" rel="bookmark">
			verilog中延时控制语句 # 的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		verilog中延时控制语法格式分为两种：
#&lt;延时时间&gt; 行为语句;
#&lt;延时时间&gt;;
1、在begin end块语句上，以上两种格式也没有什么区别的。但是在fork join块语句中还是有点区别。
举例来说：
例1：
initial fork
a = 0;
#100 a = 1;
#200 a = 2;
#300 a = 3;
join
例2：
initial fork
#100 a = 1;
#200;
a = 2;
#300 a = 3;
join
对于例1：0到100时间a为0,100到300时间，a为1，300到600时间a为2,600以后a为3；
对于例2：0到100时间a是2,100到300时间，a是1,300以后a是3.
2、#后的延时时间不一定要常量，也可以是表达式或变量。
仿真结果如下：
*
声明：文章用于个人知识学习积累与回顾，同时做个分享，个人能力有限，如有错误，欢迎指正。
联系：个人微博：东巴克。公众号：巴客小屋。文章有帮到你，也欢迎你来关注一波，谢谢
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642158759a01be95639bc19e1d31bbba/" rel="bookmark">
			Mac安装dmg程序提示无可装载的文件系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装dmg程序是提示 无可装在的文件系统
1. 查看SIP状态 在终端中输入csrutil status，就可以看到是 enabled 还是 disabled。
2. 关闭SIP 重启MAC，按住commond + R直到屏幕上出现苹果的标志和进度条，进入Recovery模式；
在屏幕最上方的工具栏找到实用工具（左数第3个），打开终端，输入：csrutil disable
关掉终端，重启mac；
重启以后就可以正常安装了。
3. 开启SIP 与关闭的步骤类似，只是在S2中输入csrutil enable即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bdd75f34e962c60b90fd4552910ce6d/" rel="bookmark">
			PCB板上的白色残留物怎么来的呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候一块设计比列非常好的PCB，在经过溶剂清洗后却有白色残留物出现，让其整体美观程度大打折扣。在PCB的生产过程中，这种问题虽然不会影响PCB正常使用，但往往让工程师为之头痛，首先这种白色的残留物第一眼给人的感觉就是pcb是已经氧化的，其次客户会觉得我们给他用的是旧的库存板。导致很多时候要跟客户解释很多次，我相信很多pcb工厂和pcb工程师都遇见过这种极其尴尬的情况。到底pcb板上的白色残留是怎么来的呢？
下面和小北一起学习PCB板上白色残留物的常见原因和处理技术进行简要介绍。
首先、导致你的PCB基板出现白色残留物的最大原因，是这一PCB板的基材本身已经存在有残留物，在加工过程中会吸收一部分助焊剂，再经焊锡及清洗，这样就会形成难看的白色残留物，因此，在焊锡前保持基板无残留物是很重要的。而积层板的烘干不当也同样会造成白色残留物的出现，此时可以使用溶剂进行清洗，以此进行消除。而在PCB板的加工过程中，一些SMT厂家所使用的铜面氧化防止剂配方与工程师所使用的溶剂配方不兼容，也是导致白色残留物出现的重要原因。以往铜面氧化防止都是松香为主要原料，但在焊锡过程却有使用水溶性助焊剂者。
因此在装配线上清洗后的基板就呈现白色的松香残留物。若在清洗过程加一卤化剂便可以轻松解决这一问题。而在使用松香助焊剂时，焊锡过后时间停留太久导致松香不易洗净，也是白色残留物出现的原因之一，此时应缩短焊锡与清洗之间的延迟时间，这一现象就可以避免了。除了上面提到的几种原因外，PCB基板上出现白色残留物，还有一种可能，那就是工程师在设计加工时使用了过旧的助焊剂，此时助焊剂将会大幅度吸收空气中水份，在焊锡过程后就会形成白色残留的水渍。出现这种问题时需要及时更换助焊剂，所形成的白色残留水渍可以利用化学溶剂进行消除。
在电路板的生产过程中，pcb制造是最基础也是最重要的一环，smt贴片加工、pcba的产品质量都跟pcb板的质量息息相关。任何一个细节的误差最终都可能影响产品的性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37af4015f05e008afc8edcf04b28d642/" rel="bookmark">
			转载：一文讲懂什么是vlan、三层交换机、网关、DNS、子网掩码、MAC地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：一文讲懂什么是vlan、三层交换机、网关、DNS、子网掩码、MAC地址 一、什么是vlan?二、单臂路由与三层交换机三、什么是网关四、什么是DNS五、MAC地址六、子网掩码补充 一、什么是vlan? VLAN中文是“虚拟局域网”。LAN可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN所指的LAN特指使用路由器分割的网络——也就是广播域。
听上面的概念，肯定有不少朋友是一头雾水的，什么是虚拟局域网？好好的，为什么要划分vlan？
这里举个例：通俗的了解
一所高中，新学期高一招了800个学生，这800个学生，如果放在一个班里，那肯定是管理不过来，面对800个人，老师看了也头疼，这边在授课，那边完全听不到，老师布置什么任务，也会有一些传达不到，老师要是想找某个学生的信息，要从800份信息中去找，极其麻烦，浪费时间；
而实际中，也是一样，电脑A要想要与电脑B通信，于是电脑A就需要发送arp请求，而网络中电脑众多，最终ARP请求会被转发到同一网络中的所有电脑，才能找到电脑B，如此一来，为了找到电脑B，消耗了网络整体的带宽，收到广播信息的计算机还要消耗一部分CPU时间来对它进行处理。造成了网络带宽和CPU运算能力的大量无谓消耗。
那么怎么办呢？
学校就针对这800个学生，分成了10个班，每个班80人，分别命名为高一（1）班，高一（2）班、、、、高一（10）班，每个人都会获得一个班级编号。
1101表示一班01号学生。
1102表示一班02号学生。
1201表示2班01号学生。
同一个班的学生编号尾数不同，其它的都相同。
那么这样老师再管理起来就轻松多了，可以把一班这80人管理的妥妥的，隔壁2班与3班乱成一锅粥也不管一班的事，我就要这一班80人好好上课就行。
这就是vlan，每个班就相当于一个vlan，而每个班名称，就相当于vlan的名称，而每个学生的编号就是ip地址；同班同学（同一个vlan的ip），因为同一个教室，朝夕相处，且可以相互通信，不同班的同学，若不做其它工作，很难往来通信。
所以同一个vlan间，可以相互通信；不同vlan，若不做配置，不能相互通信。
那么不同vlan如何通通信呢？就需要单臂路由与三层交换机。
二、单臂路由与三层交换机 我们知道要实现不同vlan间通信，就必须需要有路由功能，不同VLAN之间相互通信的两种方式（单臂路由、三层交换机）。
什么是单臂路由？
单臂路由的实现方式，其实就是普通二层交换机加路由器，从而实现不同vlan间的可以互相通信。
那什么是三层交换机呢？
对于小型的网络，单臂路由可以应付，但随着VLAN之间流量的不断增加，很可能导致路由器成为整个网络的瓶颈，出现掉包、或者通信堵塞。
为了解决上述问题，三层交换机应运而生。三层交换机，本质上就是“带有路由功能的（二层）交换机”。路由属于OSI参照模型中第三层网络层的功能，因此带有第三层路由功能的交换机才被称为“三层交换机”。
关于三层交换机的内部结构，可以参照下面的简图。
在一台本体内，分别设置了交换机模块和路由器模块；而内置的路由模块与交换模块相同，使用ASIC硬件处理路由。因此，与传统的路由器相比，可以实现高速路由。并且，路由与交换模块是汇聚链接的，由于是内部连接，可以确保相当大的带宽，所以对于正规的项目，需要使用三层交换机来实现网网络间的通信。
三、什么是网关 在了解了vlan与三层交换机后，能不能通信，还需要看网关是否正确。
一、什么是网关
网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。
二、如何来理解网关
大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。
按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，在这里我们所讲的“网关”均指TCP/IP协议下的网关。
三、网关的ip地址
那么网关到底是什么呢？
网关实质上是一个网络通向其他网络的IP地址，网关在网段内的可用ip中选一个，不过，一般用的是第1个和最后一个。
例如
比如有网络A和网络B，
网络A：的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩255.255.255.0；
如果需要与其它网段通信，那么它的网关可以设置为192.168.1.1，当然也可以设置为网段内其它的一个ip地址。
网络B：的IP地址范为“192.168.2.1~192.168.2.254”，子网掩码255.255.255.0。
如果需要与其它网段通信，那么它的网关可以设置为192.168.2.1，当然也可以设置为网段内其它的一个ip地址。
四、网关是如何实现通信？
在没有路由器的情况下，不同的两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(255.255.255.0)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。
如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机(如附图所示)。网络B向网络A转发数据包的过程。
所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。
五、什么是默认网关？
如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。
四、什么是DNS DNS是域名解析服务器（Domain Name System），是把网址变成IP地址的服务器。
DNS说白了是把域名翻译成IP地址用的，这里面举个例子，大家就很容易清楚了。
例如我们在浏览器里面输入www.baidu.com的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这台服务器的IP地址，我们不知道IP地址是多少，那么就需要主机问DNS服务器，DNS服务器就自动帮我们把www.baidu.com这个域名翻译成了IP地址61.135.169.105。然后写到了数据包的目的IP地址里面就可以进行通信。
就跟我们写信一样，你得写个收信人的地址邮局才能给你发送吧，你给国外写信，你写中文地址邮局不认识，需要这个一个人帮你翻译成英语。这就是DNS的作用，所以你的在本地连接里面写DNS才可以正常浏览网页，如果不设置DNS，是无法正常访问网页的。
五、MAC地址 讲到MAC地址，就不得不提ip地址，这里顺便把ip地址也说下。
IP与MAC
虽然现在已经ipv6了，但我们基本用的大多数还是ipv4协议，所谓ip就是你电脑整个网络的编号。其他电脑想访问电脑就得需要这个编号。但是这个编号很多情况下是一直在变化的。唯一不变的是你的MAC地址：物理地址。
MAC是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的MAC地址都是唯一的。
做个比喻，你经常搬家，你没搬一次家都有一个地址，XX小区XX单元XX号，这个就是IP。但是你的名字不变，这个就是MAC，不同的是我们的MAC不允许重名。
我们的IP分为两个部分：如上图分为网络部分和主机部分。网络部分好比就是你在XX省XX市XX镇，这个是国家固定下来了的。但是XX小区XX单元XX号是开发商自己定的。两个编号加起来就是你的ip了。不同的是在现实中两个编号的长度是固定的，在网络上A、B、C、D的ip地址却是变化的，这个在前天有详细讲到。
六、子网掩码 子网掩码是为了区分网络位和主机位，上面我们说到过，一个ip地址是由网络部分和主机部分。正如一个人的名字由姓与名组成。
那么我们可以把IP地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。
举个例子
有一个网段是192.168.1.0-192.1.254，这个网段就像一个村子一样，就称它为安防村，此这网段有个ip地址是192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的ip地址为192.168.1.2，我们一看他们，就知道他们是同村的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37af4015f05e008afc8edcf04b28d642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/053bc5d402b84aa54b570f88ea4ad7a5/" rel="bookmark">
			Visual Studio对代码进行注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Ctrl+K+C（可以同时按住三键，也已分开来按Ctrl+K,Ctrl+C）对选中的代码段进行注释
Ctrl+K+U（可以同时按住三键，也已分开来按Ctrl+K,Ctrl+U）对选中的代码段取消注释
2.Ctrl+Shift+/(切换块注释快捷键)对选中的代码段进行注释
Ctrl+Shift+/对选中的代码段取消注释
3.也可以利用按钮进行注释
4.输入"/*“后，会自动补齐”/**/"
5.更改快捷键的方法：工具—&gt;选项—&gt;环境—&gt;键盘（“新快捷键用于”下拉修改为文本编辑器，“显示命令包含”输入“注释”，选择“编辑.注释选定内容”），不建议移除命令的快捷键，按快捷键组合可以进行修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a170f72f3a218e04ca5babb1d779bb13/" rel="bookmark">
			CocosCreator 打包原生接入开屏双进程问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CocosCreator 打包原生接入开屏双进程问题记录 当我接入开屏后，启动游戏发现有两个进程，此时只需要注释AndroidManifest里面自己主Activity下的android:taskAffinity=""即可解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfc0d60f1597d9c83b9d06804f0055c/" rel="bookmark">
			Android网络安全之NetworkSecurityConfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		google在android p为了安全起见,已经明确规定禁止http协议额,但是之前很多接口都是http协议，我们一般是这样解决的：
在res目录下创建xml目录,然后随便创建一个.xml文件,里面内容如下:
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted="true" /&gt; &lt;/network-security-config&gt; 然后在AndroidManifest.xml文件下加上:
android:networkSecurityConfig="@xml/文件名"
&lt;application android:testOnly="false" android:name=".base.BaseApplication" android:allowBackup="true" android:configChanges="orientation|keyboardHidden" android:networkSecurityConfig="@xml/文件名" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:supportsRtl="true" android:theme="@style/AppTheme" tools:ignore="AllowBackup,GoogleAppIndexingWarning,UnusedAttribute" tools:replace="android:icon,android:label,android:theme,android:allowBackup,android:name"&gt; networkSecurityConfig是什么呢 从Nougat（Android 7）一个名为“Network Security Configuration”的新安全功能也随之而来。如果应用程序的SDK高于或等于24，则只有系统证书才会被信任。
网络安全性配置特性让应用可以在一个安全的声明性配置文件中自定义其网络安全设置，而无需修改应用代码。可以针对特定域和特定应用配置这些设置。此特性的主要功能如下所示：
自定义信任锚：针对应用的安全连接自定义哪些证书颁发机构 (CA) 值得信任。例如，信任特定的自签署证书或限制应用信任的公共 CA 集。仅调试重写：在应用中以安全方式调试安全连接，而不会增加已安装用户的风险。明文通信选择退出：防止应用意外使用明文通信。证书固定：将应用的安全连接限制为特定的证书。 下面分别来看看具体的用法
自定义可信 CA 应用可能需要信任自定义的 CA 集，而不是平台默认值。出现此情况的最常见原因包括：
连接到具有自定义证书颁发机构的主机，如自签署或在公司内部签发的 CA。将 CA 集仅限于您信任的 CA，而不是每个预装 CA。信任系统中未包含的附加 CA。 默认情况下，来自所有应用的安全连接（使用 TLS 和 HTTPS 之类的协议）均信任预装的系统 CA，而面向 Android 6.0（API 级别 23）及更低版本的应用默认情况下还会信任用户添加的 CA 存储。应用可以使用 base-config（应用范围的自定义）或 domain-config（按域自定义）自定义自己的连接。
配置自定义 CA 假设您要连接到使用自签署 SSL 证书的主机，或者连接到其 SSL 证书是由您信任的非公共 CA（如公司的内部 CA）签发的主机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfc0d60f1597d9c83b9d06804f0055c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d4f39aedeffe5a7bab13e1cf6e106c0/" rel="bookmark">
			Seata的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分布式事务解决的方案有哪些？ 目前分布式事务解决的方案主要有对业务无入侵和有入侵的方案，无入侵方案主要有基于数据库 XA 协议的两段式提交（2PC）方案，它的优点是对业务代码无入侵，但是它的缺点也是很明显：必须要求数据库对 XA 协议的支持，且由于 XA 协议自身的特点，它会造成事务资源长时间得不到释放，锁定周期长，而且在应用层上面无法干预，因此它性能很差，它的存在相当于七伤拳那样“伤人七分，损己三分”，因此在互联网项目中并不是很流行这种解决方案。
为了这个弥补这种方案带来性能低的问题，大佬们又想出了很多种方案来解决，但这无一例外都需要通过在应用层做手脚，即入侵业务的方式，比如很出名的 TCC 方案，基于 TCC 也有很多成熟的框架，如 ByteTCC、tcc-transaction 等。以及基于可靠消息的最终一致性来实现，如 RocketMQ 的事务消息。
入侵代码的方案是基于现有情形“迫不得已”才推出的解决方案，实际上它们实现起来非常不优雅，一个事务的调用通常伴随而来的是对该事务接口增加一系列的反向操作，比如 TCC 三段式提交，提交逻辑必然伴随着回滚的逻辑，这样的代码会使得项目非常臃肿，维护成本高。
Seata 各模块之间的关系 针对上面所说的分布式事务解决方案的痛点，那很显然，我们理想的分布式事务解决方案肯定是性能要好而且要对业务无入侵，业务层上无需关心分布式事务机制的约束，Seata 正是往这个方向发展的，因此它非常值得期待，它将给我们的微服务架构带来质的提升。
那 Seata 是怎么做到的呢？下面说说它的各个模块之间的关系。
Seata 的设计思路是将一个分布式事务可以理解成一个全局事务，下面挂了若干个分支事务，而一个分支事务是一个满足 ACID 的本地事务，因此我们可以操作分布式事务像操作本地事务一样。
Seata 内部定义了 3个模块来处理全局事务和分支事务的关系和处理过程，这三个组件分别是：
Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。 简要说说整个全局事务的执行步骤：
TM 向 TC 申请开启一个全局事务，TC 创建全局事务后返回全局唯一的 XID，XID 会在全局事务的上下文中传播；RM 向 TC 注册分支事务，该分支事务归属于拥有相同 XID 的全局事务；TM 向 TC 发起全局提交或回滚；TC 调度 XID 下的分支事务完成提交或者回滚。 与 XA 方案有什么不同？ Seata 的事务提交方式跟 XA 协议的两段式提交在总体上来说基本是一致的，那它们之间有什么不同呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d4f39aedeffe5a7bab13e1cf6e106c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b954b40ae83e0b1bdfb5900de26320e9/" rel="bookmark">
			软件工程-软件测试-测试方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程-测试方法-白盒和黑盒测试 软件工程-软件测试
软件测试方法可以分为静态测试和动态测试。
静态测试 静态测试是指被测试程序不在程序上运行，而是采用人工检测和计算机辅助金泰分析的手段对程序进行检测。
静态测试方法 （1）人工检测:是指不依靠计算机而是靠人工审查程序或评审软件，包括代码检查、静态结构分析和代码质量度量等；
（2）计算机辅助静态分析：利用静态分析工具对被测试程序进行特性分析，从程序中提取一些信息，以便检查程序逻辑的各种缺陷和可疑的程序构造。
动态测试 动态测试是指通过运行程序发现错误。
动态测试方法 白盒测试 概念 白盒法又称为逻辑覆盖法，因为要以程序（模块）内部的逻辑结构为基础来设计测试用例，主要用于单元测试。测试的关键也是如何选择高效的测试用例。
白盒测试的主要方法有程序结构分析、逻辑覆盖、基本路径测试等，它根据程序的控制结构设计导出测试用例，主要用于软件程序的验证。
原则 （1）对程序模块的所有独立的执行路径至少测试一次；
（2）对所有的逻辑判定，取“真”与取“假”的两种情况都至少测试一次；
（3）检查程序的内部数据结构，保证其结构的有效性。
（4）在循环的边界和运行界限内执行循环体；
方法 逻辑覆盖 标准
（1） 语句覆盖
选择足够的测试用例，使得程序中每个语句至少都能被执行一次。
（2） 判定覆盖
执行足够的测试用例，使得程序中每个判定至少都获得一次“真”值和一次“假”值。
（3） 条件覆盖
执行足够的测试用例，使得判定中的每个条件获得各种可能的结果。
（4） 判定/条件覆盖
执行足够的测试用例，使得判定中每个条件取到各种可能的值，并使每个判定取到各种可能的结果。
（5） 条件组合覆盖
执行足够的例子，使得每个判定中条件的各种可能组合都至少出现一次。
例：用白盒法测试以下程序段，如图所示，程序中有两个判定，每个判定都包含复合条件的逻辑表达式。
Procedure （VAR A,B,X:REAL）；
BEGIN
IF（A&gt;1) AND (B=0)
THEN X:=X/A ;
IF (A=2) OR (X&gt;1)
THEN X:=X+1
END;
基本路径测试 概念
从广义角度讲，任何有关路径分析的测试都可以被称为路径测试。简单描述：路径测试就是从一个程序的入口开始，执行所经历的各个语句的完整过程。
路径的表达式
（1）弧a和弧b相乘，表示为ab。它表明路径是先经历弧a，接着经历弧b，弧a和弧b是先后相接的。
（2）弧a和弧b相加，表示为a+b。它表明两弧是“或”的关系，是并行的路段。
可用以下三种方法计算环形复杂度：
（1）流图中区域的数量对应于环形复杂性。
（2）给定流图G的环形复杂度V(G)，定义为V(G)=E-N+2，E是流图中的边的数量，N是流图中节点的数量。
（3）给定流图G的环形复杂度V(G)，定义为V(G)=P+1，p是流图G中判定节点的数量。
导出测试用例
程序段的基本路径集中有4条独立路径：
路径1：4 →14
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b954b40ae83e0b1bdfb5900de26320e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af0a43afec429e436fc18192a7f8dc96/" rel="bookmark">
			编译.so动态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译.so动态库 最近在一个大项目分模块开发时，采用C++开发，各个模块开发好库之后，编译成为.so动态库。调用底层库时，只需要.so文件和对应头文件。
本文以test库为例说明：
文件包括：test.h test.cpp main.cpp
// test.h #include &lt;iostream&gt; using namespace std; int add(int a, int b); int subtract(int a, int b); int multiply(int a, int b); double divide(int a, int b); // test.cpp #include "test.h" using namespace std; int add(int a, int b){ return a+b; } int subtract(int a, int b){ return a-b; } int multiply(int a, int b){ return a*b; } double divide(int a, int b){ return a/1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af0a43afec429e436fc18192a7f8dc96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dab4ffdf88f5801cb8846ea5072d1851/" rel="bookmark">
			实时渲染入门：（四）纹理、着色器、材质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纹理(Texture) 纹理在导入时会被压缩。这个纹理跟视频编码里的纹理是相同的概念，也就是图像的轮廓和边缘，这里老师讲了一些压缩方面的东西，主要是格式相关，比如DXTC1，就没有阿尔法通道，而BC70是质量最高的方式。
压缩纹理是因为内存和带宽空间有限，每个着色器的纹理也同样存在上限。
多级渐进纹理(Mipmap)
一张图片的多级渐进纹理，由许多个由原来图片1/4纹理的图片构成。每个图片都是前者的1/4。
比如导入一张图片，原始分辨率为20482048，第一层就是10241024，第二层就是512*512。等等。
如果没有多级渐进纹理，纹理的噪声点回非常多。根据距离的远近，会切换纹理，当摄像机很近，就会是一张高分辨率的纹理，如果摄像机很远，就是一张低分辨率的纹理。这个就是纹理流送的过程。
同时也有不需要多层渐进纹理的情况，比如菜单(Interface)这样的交互界面。
像素着色器（Pixel Shaders） 它由GPU执行，是一个可以同时执行的简单的程序，大多数像素都设计到这个运算，它贯穿着渲染的每一个步骤。
像素着色器使用像素着色器语言编写。在DirectX中，使用的语言是HLSL。
着色器中通常会有一些未定义的关键变量，比如使用哪些纹理，定义光源如何与纹理相互影响，反射等等。
举个栗子：
可以从材质（Materials）里选择一个材质。双击进入。
当它被apply或者save的时候，实际上会被编译成HLSL代码。
打开之后就能看见HLSL的代码
在左下角能够看到有很多不同的着色器。
着色器越简单越好，如果把着色器写成一个大的，复杂的着色器，是很得不偿失的。
渲染管线(Pipeline)
1，输入汇编(Input Assembler)
2，顶点着色器(Vertex Shader)
3，凸包着色器（置换贴图）(Hull Shader)
4，域着色器(Domain Shader)
5，几何体着色器(Geometry Shader)
6，光栅化(Rasterizer)
7，像素着色器(Pixel Shader)
8，输出合并(Output Merger)
基于物理的渲染（PBR）材质管线
PBR使用高光，金属色，和粗糙度作为输入。它被用来计算环境中几乎所有的着色。
PBR被称为统一着色，因为几乎所有图像，模型，材质，它们的底层中都是建立在相同的着色，在PBR系统中。
为什么使用PBR？
有上述三点，但是目前我还无法理解。
我们通常会渲染多张图然后将它们合成到一起，这意味着对材质所做的一切，都必须在G-buffer中完成，它需要的所有信息都来自与G-buffer。G-buffer有颜色信息，光照信息，深度信息等等。因此要找到一个着色器，能够依靠G-buffer的信息就可以使用。
材质的性质
1，材质或者着色器能够查看的纹理采样器，是拥有数量上限的，通常是16，其中13个是常用的。也可以使用至多128个共享的采样器，但仅限于DX11。
2，纹理大小主要导致延迟和卡顿，而不是丢帧。这通常是带宽或者内存不足的问题。
3，像素着色器对于性能会有很大的影响。
4，分辨率越高，材质就越复杂，影响就越大。
5，像素着色的损耗取决于屏幕上的具体像素数量，因此远距离使用复杂材质更好一些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/368e6f0da1e495b4b12f51f2881baa51/" rel="bookmark">
			实时渲染入门：（四）光栅化、遮蔽和G-Buffer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光栅化 光栅化就是把3D数据转换为像素的过程。
如果要渲染一个三角形，那么我们要知道哪些像素块要被染色。这个过程就是光栅化的过程。而这个过程是在后台进行的，我们无法进行改动。
在光栅化中有一个性质，一个像素点永远只会同时用于显示一个多边形。而在光栅化过程中，并不是逐个像素询问的，而是以22大小的矩形进行询问的。
过度着色
让着色范围超出本应有的区域。比如这里有两个三角形，左侧的三角形犹豫22大小的访问机制，会遍历12个像素块，另一方面，应该着色的部分就会被着色。
但是这个时候旁边有一个三角形，在决定要对哪些像素块进行着色的时候，有八个像素块被重复计算了一遍。这就是过度着色。
在UE4中，可以通过Unit—&gt;Optimization Viewmodes-&gt;Quad Overdraw进入四边形过度绘制模式来查看这个过程。
颜色条从左往右表示渲染速度，颜色越深越好。
这个时候会发现一个现象，那就是近看是很蓝的，远看就绿了。
越绿意味着性能越差。
因此光栅化有如下性质：
1，多边形密度越大，染色费用越高。
2，从远处看，密度会增加。因为球体多边形的三角形面数没有变，但是显示相同数量多边形的像素变得更少。（同1）
3，这个时候就可以使用LOD或者距离剔除来解决这个问题。
4，初始像素着色器的通道越复杂，过度着色带来的损耗就越大。所以在正向渲染时，过度着色产生的影响更大。
所以当游戏使用正向渲染的时候，这些问题就要被注意到。而通常的手段就是LOD和距离剔除。
比如这种物体，在着色时会有非常多的重叠现象，造成了过度着色，对性能损耗很大。
G缓存 G缓存用于合成各种内容，比如材质、光照、雾等等。我们也无法对G-buffer做什么事情，但是它的消耗是很稳定的。（属实没跟上，回头可以补一补）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321d35963306b8f84e8daa53dffa3de4/" rel="bookmark">
			实时渲染入门：（三）几何结构渲染
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在CPU确定了所有对象的位置，并且知道了需要渲染哪些对象之后，渲染就正式开始了。
而几何体是第一个被渲染的对象。
深度通道/Early Z Pass（这里的Z是深度）
此时我们知道了所有需要被渲染的对象以及对象的位置，但是不知道渲染的顺序，也就是不知道哪些对象应该首先被渲染，哪些对象应该之后被渲染。
从宏观上看，渲染的顺序并不是按照像素排列顺序，也不是按照线条渲染，而是逐个对象渲染。
按照顺序是：首先渲染背景，接着逐个渲染对象。
但是这个时候就会出现一个问题，如果需要被渲染的对象是重叠在一起的，那么被挡住的部分是不用被渲染的，但是如果渲染的顺序不对，那么就会先渲染被遮挡住的对象，而后被渲染的对象会遮挡住之前渲染的对象，而被遮挡住的部分是不可见的，这就会造成浪费。
比如这个例子：蓝色部分是同一个对象，但是此时蓝色的部分即是遮挡物，又是背景。
而解决这个问题的办法，就是首先做一个深度测试，然后可以做出一个遮罩对象的效果。
好了，接下来的工作就是渲染具体的几何体。
绘制调用（Draw Call）
几何体会根据Drawcall（绘制调用）顺序渲染对象。
左侧图一共有5个对象，天空、地面、三个圆柱体，所以要调用5个绘制调用。
右侧图一共有6个对象，天空、地面、三个圆柱体，最后一个圆柱体由两种材质构成，因此要调用6次。
如果一个物体由10中材质构成，那么就会调用10次绘制调用。
下面是捕捉到的UE4的渲染过程。没有纹理，只有法线贴图。
由于深度通道的作用，UE4首先计算出它要渲染地面，而地面被柱子覆盖住的部分则是空的，因为它会被柱子遮挡住。
然后就渲染最右侧柱子的下半部分。
UE4会逐个渲染对象，并放到G缓存中。
而为什么会先渲染地板呢？是因为它会按照材质类型对场景对象进行分类，这样渲染会更快。所以UE4会优先渲染相同材质的对象。
绘制调用的性能问题 1，绘制调用的费用要比物体三角形数量重要的多
绘制调用次数可以在UE4中使用命令“stat RHI”来统计。在UE4和绝大多数实时渲染器中，绘制调用以及其他操作会造成很多损耗，与它们相比，三角形数量就不太重要了。
而绘制调用的损耗主要体现在哪里呢？每次绘制调用完成后，它都会等待下一个信息，然后再接着开始渲染。渲染之间的停顿就是耗时的原因。
关于性能可以举个栗子：
同样大小的两个平面。一个有150000+个三角形，但是只需要180+次的绘制调用。它的FPS是236
另外一个有100000+个三角形，需要44000+次绘制调用，它的FPS降到了4.6。而大多数的时间损耗都花费在了绘制调用的切换。
在渲染同样材质的对象时，该对象无论有1000个三角形面还是4000个三角形面，渲染时间可能没有区别。
2，为了减少绘制调用
最好使用少量大型模型，而不是大量的小型模型。
但是大型模型用得太多，也会同样遇到各种其他问题。
例如:
a.遮挡会变得更复杂
b.光照贴图也会变得更复杂
c.碰撞检测计算也会变得更复杂
d.会占用更多的内存
在UE4中创建物体大多都使用模块化的方式。也就是对一个个组件进行复制和移动，拼接成为一个更大的模型。另外，也可以完整地创建模型，然后原样导入，这样就变成了一个更大的模型。
a.实际上需要检测的对象变得更少了，但是它能遮挡对象的可能性会更低，因此面数可能会上升。（mark以后解释）
b.光照贴图纹理所占的内存空间有一个最大值，使用了很大的模型，会用光这个内存空间。
c.碰撞体积。如果一个球碰撞到了一个立柱，这个球就会从立柱那里查询碰撞信息，来确定下一步应该怎么做，而这个球则会从立柱得到一个面数非常低的碰撞模型。如果一个球碰撞了一个大模型的柱子，那么这个球就会从整个碰撞模型获取碰撞信息。
d.由模块化创建的模型，就会占用更少的内存，因为很多模型是复制的，无论一个模型被复制了多少次，在内存中，引擎只存储一个模型的大小。而一个大型模型的所有组件都会占用内存，所以更耗内存。
而模块化的好处就是碰撞检测简单，内存占用小，遮挡性能好，但是绘制调用次数更多。
所以通常的最佳解决方案是一个折中的方法：
使用单独的小块模型来构建模型
使用UE4中的合并功能，就可以把一些小的模型组合在一起。
那么哪些情况下适用这种方式呢？
1，这个网格越常见，并且面数越低越好。
2，只合并同一区域内的网格体
3，合并同一材质的网格体
4，碰撞检测简单的网格体
5，非常小或者只接受动态光照的网格体
6，远距离几何体。
在低端硬件或者VR设备应用中，几乎需要合并所有的对象。
实例化静态网格体组件
同时渲染相同的组件，比如这四根柱子是一模一样的，就可以通过一次绘制调用渲染，而不是四次。
默认情况下，UE4的网格体会实例化并保存在内存中，但不会在渲染时实例化。在内存中实例化意味着如果导入模型，假如它只在内存中占400KB，在场景中我放了两个该模型，它就会渲染两次。
但是如果是在渲染时实例化的话，就会占用两份内存，以及渲染两次。但是每次渲染都需要对比大量的对象，看这些对象是否相同，这同样也是一个巨大的开销。
实例化静态网格体就是给引擎一个列表，告诉引擎哪些模型是一模一样的，就可以同时渲染大量相同的对象。
细节层次LOD(Level Of Detail)
根据距离用一个模型代替另一个模型，当距离该模型远的时候，可以用一个面数更少的模型来代替之前的模型来较少渲染损耗。这个过程需要额外的一次绘制调用。
层次化细节层次（Hierarchical Level Of Detail）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/321d35963306b8f84e8daa53dffa3de4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eb6cc9c1b1d12cbbc13864eb7e2f477/" rel="bookmark">
			LeetCode 1552. 两球之间的磁力（极小极大化 二分查找）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 题目2. 解题 1. 题目 在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。
Rick 有 n 个空的篮子，第 i 个篮子的位置在 position[i] ，Morty 想把 m 个球放到这些篮子里，使得任意两球间 最小磁力 最大。
已知两个球如果分别位于 x 和 y ，那么它们之间的磁力为 |x - y| 。
给你一个整数数组 position 和一个整数 m ，请你返回最大化的最小磁力。
示例 1：
输入：position = [1,2,3,4,7], m = 3 输出：3 解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子， 两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。 我们没办法让最小磁力大于 3 。 示例 2： 输入：position = [5,4,3,2,1,1000000000], m = 2 输出：999999999 解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。 提示： n == position.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eb6cc9c1b1d12cbbc13864eb7e2f477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40561dba1fd9053e06f9b6af10192f4/" rel="bookmark">
			监督学习、非监督学习、强化学习都是什么？终于有人讲明白了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 01 术语整理
本节概述机器学习及其三个分类（监督学习、非监督学习和强化学习）。首先，与机器学习相关的术语有人工智能（Artificial Intelligence，AI）、机器学习（Machine Learning，ML）、强化学习、深度学习等，这里对这些术语进行简单的整理。
AI意味着人工智能，其定义因研究人员而异。从广义上讲，它指“像人类一样具有智能的系统和配备这种系统的机器人”。实现AI的方法之一是机器学习。
机器学习可以简单地描述为“向系统提供数据（称为训练数据或学习数据）并通过数据自动确定系统的参数（变量值）”。相反，基于规则的系统是非机器学习系统的一个例子。在基于规则的系统中，由人类来清楚地定义分支条件的参数，例如实现代码中所存在的if语句等。
另一方面，机器学习自动根据训练数据确定代码中的参数，以使系统运行良好。之所以称为机器学习，正是因为系统能根据训练数据计算和确定系统运行所需的参数。
强化学习是机器学习中的一种。机器学习可分为三大类：监督学习、非监督学习和强化学习。我们稍后会讨论这三个分类，这里只需要认识到强化学习是机器学习的一部分即可。
接下来是深度学习。深度学习是实现机器学习的算法之一。机器学习的算法包括逻辑回归、支持向量机（Support Vector Machine，SVM）、决策树、随机森林和神经网络等。深度学习是神经网络中的一种。
最后是深度强化学习。深度强化学习是强化学习和深度学习的结合。
02 监督学习、非监督学习、强化学习
这里对三种机器学习（监督学习、非监督学习和强化学习）分别进行介绍。
首先说明监督学习。
例如，“对邮政编码中的手写数字进行分类”是一种监督学习。邮政编码分类系统将每个数字的手写图像分类为0～9中的一个。诸如0到9的数据的分类目标被称为标签或类。这种系统被称为监督学习，因为给事先提供的训练数据预先标记出了正确的标签。换句话说，带标签的训练数据成了系统的教师。
监督学习包括学习阶段和推理阶段。我们将以图为例来解释手写数字的分类（见图1.1）。
▲图1.1 使用监督学习区分手写数字的示例
在学习阶段，准备许多0到9的手写数字图像数据，这些数据作为训练数据。训练数据有一个标签（0到9中的某个数值），根据标签可以找到关于手写数字图像的正确答案信息，例如“此手写数字图像为1”。在学习阶段，当将手写数字图像输入系统时，调整（学习）系统的参数以尽量将输入图像分类为正确的标签。
在应用阶段，将无标签的未知手写数字图像数据输入系统，图像被分类为0到9中的某一个输出标签并给出结果。如果已经学习到正确的结果，当输入未知的手写数字图像时，系统将输出正确的数值标签。除了手写数字的分类之外，还可使用监督学习来对图像、声音和文本数据进行分类。
此外，除了上面例子中提到的分类任务，监督学习也用于回归等任务。
接下来，介绍非监督学习。用一个词表达非监督学习就是“分组”。它将大量数据中类似的数据分为一组（称为聚类）。例如，“根据购买数据对客户进行分组的系统”是非监督学习。根据购买历史记录的特征对客户进行分组，可以为每个组实施不同的销售策略。
我们使用图来说明购买数据分析的例子（见图1.2）。假设存储了每个客户过去一年的购买数量和每次平均消费金额的数据，并对此数据进行分析。根据这些数据，客户可以分为两组。A组（左上角）是以较低频次购买高价商品的组，B组（右下角）是多次重复但每次消费金额较低的组。
▲图1.2 使用非监督学习根据购买数据对客户分组的示例
使用非监督学习进行分组将有助于了解每个客户所属的组，并针对每个组实施最佳销售策略（尽管部分业务还需要更详细的分析）。除了本例中提到的分组（聚类）以外，非监督学习也用于降维和推荐系统。
最后，我们讨论强化学习。强化学习是一种主要用于“时变系统控制规则构建”和“对战博弈策略构建”的方法。例如，强化学习用于机器人的步行控制和围棋对战程序（见图1.3）。
▲图1.3 强化学习示例（机器人步行控制和围棋比赛系统）
在我们熟悉的例子中，可能更容易想象一个孩子学会骑自行车的情形。当一个孩子学习骑自行车时，并没有人去教其诸如牛顿力学等力学法则以及如何骑车的详细方法，也不必通过观看视频来学习骑自行车。事实上，自己尝试骑自行车，在多次失败的过程中找到一种骑自行车的方法。
强化学习正如学骑自行车的例子，它是一种学习方法，它在不知道控制对象的物理定律的情况下重复试错，以学习到所希望的控制方法。
强化学习中没有带标签的数据作为训练数据，但这并不意味着根本没有监督信息。系统根据强化学习程序运行，在获得所需结果时给出称为奖励的信号。例如，在机器人的步行控制中，可以走的距离就是奖励。在围棋的比赛程序中，赢或输的结果就是奖励。失败时的奖励是负值，也称为惩罚。
如果想通过监督学习来学习机器人的步行控制，就需要尽可能多的“如果腿的关节处于这个角度并且速度是某值，那么就像这样转动电动机A”这样的模式，并预先给出其正确的做法。然而，当机器人行走时，对于每个时刻变化的状态，很难预先给出控制该电动机的正确做法。
另一方面，在强化学习中，将行走距离作为奖励提供给步行控制系统，并且重复试验多次。
这样一来，强化学习系统会根据重复试验和获得的奖励自行改变控制规则，以“如果之前的试验中所做改变使我可以走得更远，则这种改变是正确的”为基础。因此，可以在不教导机器人如何行走的情况下让机器人能渐渐行走更长的距离。
即使在像围棋这样的对战游戏的策略构建中，也无须在每个阶段将强者视为教师数据来进行教导，仅通过将成功或失败作为奖励来重复试验即可。这样做，强化学习系统会一点一点地改变游戏方式并变得更强。
学到的围棋或将棋系统比设计者本人更强大，这一点通过强化学习可以很容易实现。只听这个解释，强化学习就像魔术，但在实践中却存在着种种困难。
强化学习主要适用于“时变系统控制规则构建”和“对战博弈策略构建”，本书以前者“系统控制”为目标任务，通过编写相关程序来学习强化学习。
关于作者：小川雄太郎，东京大学博士，曾在东京大学从事脑机能测量及计算论的神经科学研究。现就职于株式会社电通国际信息服务技术开发部，从事机器学习相关技术的研究开发。
本文摘编自《边做边学深度强化学习：PyTorch程序设计实践》，经出版方授权发布。
【编辑推荐】
清华大学赵明国：AI芯片 +机器人，突破算法瓶颈边缘人工智能物联网解决方案如何提高业务绩效？人工智能时代的就业问题及应对经济学里的机器学习：二者结合必将拥有光明的未来人工智能70年，研究者们最不愿意面对的惨痛教训是…… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886033c605e55b4ab6524c9350b02396/" rel="bookmark">
			数据库复习笔记2——关系模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、关系模型基础知识 1、关系模型概述 关系模型的数据结构是：二维表结构，它是关系型数据库的基础。
关系数据模型由关系数据结构、关系操作和关系完整性约束三部分组成。
关系必须是规范化的，满足一定的规范条件。
关系数据库必须满足1NF范式，即一张表中不包含子表。（关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表）
关系模型只是常用的数据模型的一种，数据模型按照数据之间的联系可以划分为：
层次模型网状模型关系模型面向对象模型 2、关系模型的基本概念 关系模型在1970年提出，操作语言是结构化查询语言SQL（Structural Querry Language）
关系：通常指一张表元组：表中的一行记录属性：表中的一列，有属性名和属性值（分量）分量：元组中的一个属性值关系模式：对关系的描述，通常有几张表就有几个关系模式域：属性值的取值范围键： 超键（关键字）：在关系中能唯一标识元组的属性集候选键：不含有多余属性的超键（候选键中的所有属性都是必须的，缺少任何一个属性，都不能唯一标识一个元祖）主键：用户选作元组标识的候选键（人为设定）外键：如果关系模式R中的属性k是其他关系模式的主键，则k是R中的外键（表与表的关系通过外键来描述）外键表中的外键不能有主键表中不存在的数据。（保证数据的完整性和一致性）主属性：一个属性只要在任何一个候选键中出现过，这个属性就是主属性。非主属性：与上面相反，没有在任何候选码中出现过，这个属性就是非主属性。 举例说明超键、候选键等概念的含义：
假设有如下两张表：学生信息（学号 身份证号 性别 年龄 身高 体重 宿舍号）和 宿舍信息（宿舍号 楼号）
超键：只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键！
候选键：不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！
主键：就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了！
外键：宿舍号就是学生信息表的外键
主属性：出现在候选键中的属性称为主属性，如上面学号、身份证号都是主属性。
非主属性：没有在任何候选键中出现的属性，称为非主属性。如上面性别、年龄、身高、体重、宿舍号都是非主属性。
关系的完整性约束
实体完整性：关系必须有主键，且主键不能重复，不能为空参照完整性：以外键的形式维护实体间的引用关系，可以为空或者值为被参照关系的主键值用户自定义完整性：用户由应用环境决定的针对具体关系数据库的约束（属性类型等） 3、关系代数 我们以如下的两张表作为原始数据：
并操作（Union）
关系（表） R 与关系 S 的并（∪）由属于 R 或属于 S 的元组（记录）组成。
差操作（except）
关系R与关系S的差由属于R而不属于S的所有元组组成。
交操作（intersection）
关系R与关系S的差由属于R且属于S的所有元组组成。
笛卡尔积（cartesian product）
这里的笛卡尔积严格地讲是广义笛卡尔积。在不会出现混淆的情况下广义笛卡尔积也称为笛卡尔积。
两个分别为n目和m目的关系R和S的广义笛卡尔积是一个n+m列的元组的集合。元组的前n列是关系R的一个元组，后m列是关系S的一个元组。若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。
R中的每一行元素与S中的每一行元素连接。
相当于：select 列名 from 表A，表B 或者select 列名 from 表A join 表B
投影（projection）
关系R上的投影是从R中选择出若干属性列组成新的关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/886033c605e55b4ab6524c9350b02396/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22feced89cba3b859a160b692ae7c662/" rel="bookmark">
			antd pro/Ant Design Pro 增删改查表单服务器交互快速入门开发附Demo，第一讲之环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文结构 简介环境部署1.创建目录2.获取UMI3.安装依赖 代码运行方式Demo下载地址 简介 1.Ant Design Pro 是一款支持快速开发的前端框架， 官方首页寥寥几笔你可以在短时间内即可完成前端增删改查的代码，框架源于 蚂蚁金服体验技术部出品，身价还是比较高大上的，缺点是网上资料比较少，本文做为环境入门，订阅博主，后续会添加：Ant Design Pro的面向服务器交互增删改查、基于Token的认证等等，不多说，先看效果图。
环境部署 今天主讲环境搭建与运行，不多说，开始，你的本地环境需要安装 yarn、node 。如果需要教程的可以在下面评论，今后我补充上
1.创建目录 在磁盘任意地方创建个空目录(最好不要中文)，然后进去，按住shift键，鼠标右键空白，可选在此处打开命令窗口或者在此处打开powershell窗口， 强烈建议选择后者！注意下，尽量是管理员用户
2.获取UMI 直接执行
yarn create umi 运行完成，会有一些选择项，不会的可以按我选择
1.选择 &gt; ant-design-pro，也就是直接按回车行了
2.问你选 &gt; Pro V4还是&gt; &gt; Pro V5，直接按回车就行了
3.问你选 &gt; TypeScript还是 &gt; JavaScript ，本文用的是 TypeScript，直接回车就行了。
4.问你积木还是脚手架，直接按回车就行了
5.问你选 &gt; antd@4还是 antd@3 ，直接按回车就行了
6.然后就是等待success就行了
3.安装依赖 输入
npm install 完成了，整个环境搭建完毕，如果有报错请评论
代码运行方式 环境搭建完成后，即可直接运行，查看代码效果
1.输入
npm start 2.打开网站，看看效果，输入提示的local地址：http://localhost:8000，即可看到效果，当然，这些数据是从本地的mock进行加载的，下一个博客将会讲述，如何从服务器API中动态加载数据到前端。
Demo下载地址 下载地址【本文DEMO】
这个demo是我所有依赖下载完成的，直接输入
npm start 即可运行。
过几天下一个博客将会讲述，如何从服务器API中动态加载数据到前端，博主编写不易，感到有帮助的，请点赞加评论6666！！！让我有创作动力！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d64be28162d0bd44ee41c9b274db51e/" rel="bookmark">
			这个 Python 知识点，90% 的人都得挂~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇选自 Python黑魔法指南 -&gt; 第四章 -&gt; 第2节。
github仓库: https://github.com/iswbm/magic-python
magic-python 目前已经有 600+ 的 star 了，越来越多的人知道了它，从百度网盘的数据来看，已经有 将近 5000 的人下载了这本电子书。
如果本书对你学习 Python 有所帮助，那可以请你帮我 github 上帮我点个 star 嘛？让更多的人知道它。
本篇文章是选自该书的一节，由于昨晚有一位读者留言帮我指正了点小错误，所以我今天对这个知识点的最后一部分内容进行重新梳理，整理一下发出来。希望对你有所帮助。
-- 正文开始--
学习 Python 这么久了，说起 Python 的优雅之处，能让我脱口而出的， Descriptor（描述符）特性可以排得上号。
描述符 是Python 语言独有的特性，它不仅在应用层使用，在语言语法糖的实现上也有使用到（在下面的文章会一一介绍）。
当你点进这篇文章时
你也许没学过描述符，甚至没听过描述符。
或者你对描述符只是一知半解
无论你是哪种，本篇都将带你全面的学习描述符，一起来感受 Python 语言的优雅。
1. 为什么要使用描述符？ 假想你正在给学校写一个成绩管理系统，并没有太多编码经验的你，可能会这样子写。
class Student: def __init__(self, name, math, chinese, english): self.name = name self.math = math self.chinese = chinese self.english = english def __repr__(self): return "&lt;Student: {}, math:{}, chinese: {}, english:{}&gt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d64be28162d0bd44ee41c9b274db51e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9507e113fe996399c75a3f9f02ed109/" rel="bookmark">
			P2562 [AHOI2002]Kitty猫基因编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述
小可可选修了基础生物基因学。教授告诉大家 Super Samuel 星球上 Kitty猫的基因的长度都是 2 的正整数次幂 )， 全是由两种不同的基因单元组成的。 这两种不同的基因单元分别记成 0 和 1，于是 Kitty 猫基因可以写成一个 01 串表达式 。
为了便于分析和降低数据存储量，教授发明了 ABC 编码规则。该编码规则是不断地按照
对 Kitty 猫基因 01 串表达式 进行改写， 直至最终被改写成只含有字符 “ A”、“ B”、“ C”的符号串。
请你编写程序帮助小可可求出 Kitty 猫基因的 ABC 编码以协助教授开展科研工作。
输入格式
文件中以一行的形式存放了一个 Kitty 猫基因的 01 串表达式。
输出格式
以一行的形式输出这个 Kitty 猫基因的 ABC 编码。
输入输出样例
输入 #1
00
输出 #1
A
输入 #2
01001011
输出 #2
CCCABACCBAB
说明/提示
给出的01字符串长度Len\leq 256Len≤256
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; typedef long long ll; int m,n,t; string s; void sf(int ls,string ss){ int k = ss.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9507e113fe996399c75a3f9f02ed109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21b44fcdf8c39d91da626cfaf8211014/" rel="bookmark">
			cmd &#43; Cmder 命令行 使用教程技巧 （全攻略）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmd + Cmder 命令行 使用教程技巧 （全攻略） 一、Win10 的cmd0、特点1、注意与其他程序快捷键的区别２、你想知道的 命令技巧 二、cmder０、基础配置安装1、把 Cmder 文件位置加到系统环境变量2、添加 cmder 到右键菜单：3、设置中文编码4、设置启动窗口的目录5、配置渗透神器——sqlmap6. 需要注意的问题 一、Win10 的cmd 0、特点 把.exe程序拖进去cmd窗口，可以运行程序，且不会一闪而过
win10的cmd窗口，拖拽文件夹快速输入文件路
径
Ctrl+Shift+ 加号/减号 调节命令提示符透明度
Ctr/+C和Ctrl+V 复制和粘贴
Ctrl+F 搜索文本
属性设置大小布局快捷键
调试cmder中途打开cmd，没有反应，把我搞慌了，为什么我花了这么长时间要配置出完美的cmder？？
（windows10使用新版控制台时控制台黑屏，这并不是中病毒）
尝试方案：
勾选启用旧版控制台，还是不要乱改参数好，能用就行（完了，回不去了，用不了新版😔） 只能上下拖动，不能左右拖动，还特别长
最终解决方案：
属性-&gt;终端-&gt;取消勾选单独的前景 done！
配置好每次打开的位置，刚好不挡住游览器的缩写放大和关闭框高度，居电脑屏幕最右边，非常方便
1、注意与其他程序快捷键的区别 无剪切快捷键 程序运行时　Ctrl＋Ｃ　终止程序运行 退出 exit 暂停 pause Ctrl + A 是全选整个页面
右键属性
打开快速编辑模式
你就可以
左键拖动，选中文字（相当于Ctrl+M 标记），在需要的地方右键（即Ctrl+V粘贴）
命令行中撤销和剪切 Ctrl + Z/X 都无效
２、你想知道的 命令技巧 命令历史 F3 调出上一条执行的命令 F7 查看用过的命令,左右方向键或回车执行（先执行1个以上的命令） F8 同上方向键，不断切换历史命令 F9 输入序号选择执行过的命令，0、1、2、3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21b44fcdf8c39d91da626cfaf8211014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e579c5c94775fe257f1f25a2b38711/" rel="bookmark">
			2019年nodejs凉了吗？凉到什么程度了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在下于知乎上看到一个有趣的问题，叫「2019年nodejs凉了吗？凉到什么程度了？」问题挺耸人听闻的，但其实是一个很普适性的问题，对于大部分语言和框架的使用者来说都值得借鉴。这个问题下面小爝大佬的回答让我眼前一亮，有理有据，令人信服，所以在下特地跟小爝大佬要了授权，转载给大家看看～
文：知乎 小爝
原文链接：https://www.zhihu.com/question/313414600/answer/631267373
❝ 「问题原文：」 深圳市 boss 直聘拉勾网上 nodejs 开发工程师的岗位相较于 PHP Java Go 开发工程师的岗位少很多，总共才那么几个，请问 nodejs 是不是凉了，凉到什么程度了？
❞ 做后端的nodejs的使用场景有限，确实不如java和go，坑多且前人经验总结不如其他语言，但是写业务写工具写脚本写中间层应用，nodejs有自己的优势，可惜也不是独有，上手快是真的（这非常重要）。
我个人的体会，只代表我自己，如果专注后端开发，不建议nodejs作为主力开发语言，会对自己有局限，而且学到最后也是去学c++了。
对于前端而言，nodejs 是必须掌握的，虽然语法都是 js，但是目前的发展趋势是前端全干化，后端向云和基础服务下沉，nodejs 的优势很明显，贴近业务，扩大前端职能，让人的产出更好更多更快，对企业有价值，也可以同时帮前端工程师更好的提升自己的视野，了解 js，了解整个前后端应用开发流程，也就是所谓的 「BFF」，全称是 「Backends For Frontends」 (服务于前端的后端)。
专注做过一段时间后端你就会发现，用什么语言一点也不重要，如果是纯 curd，什么语言都差不多，用什么来写 curd 主要看社区和工具框架成熟度，如果是做后端架构，只会一门语言根本不行，而且环境，机器运维部署，网络等等要学的太多了，也根本不是一个语言的问题能解决的。
回到主题，nodejs 岗位可能确实比较少，也是现实，别压宝一个东西，多学点没毛病。（只是国内，国外看起来发展的真不错）
更重要的是学会看到除了语言之外的东西，比如现代企业，「尤其是大企业的用人和职位职能发展趋势」。
（国内外，gg，fb 大多前端都是 BFF 模式，阿里现在也有这个趋势，当然不一定拿 nodejs 做，以前是 php，比如百度，新浪）
避免撕逼，上面的观点仅仅是我个人体会…随便说的，自己的狭隘视角看到的。
ps一下背景，我自己用了 nodejs 很多年，国内和cnode差不多的时期写了一个跑了7年多的nodejs网站，公司内部 nodejs 用了很久，工程化，打包脚本，内部 cms，内容管理系统都可以写，用户端的，一天几千万 pv 的服务用 nodejs 也接过，业界也非常多，完全可以 hold 住高 qps 大流量的应用层。
所以我觉得根本不是语言的事，nodejs 本身的缺陷实实在在有不少，但瑕不掩瑜，前端一定要学否则可能未来失业，因为没准哪天你的老板就和你说了，来，小张，这个服务后端不维护了，只提供接口层或者 rpc 了，我们把 c 层接过来得了，以后前端后端一把梭，快速迭代效率杠杠的，你看怎么样…？
最后 如果你觉得这篇内容对你挺有启发，我想邀请你帮我三个小忙：
点个「在看」，让更多的人也能看到这篇内容（喜欢不点在看，都是耍流氓 -_-）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e579c5c94775fe257f1f25a2b38711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c219a18678ae123decf6e84bd225a69d/" rel="bookmark">
			计算机组成原理常考大题合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机组成原理常考大题合集 1.在“Cache-主存-辅存”三级存储体系中，“Cache-主存”结构与“主存-辅存”结构的引入为了解决什么问题？答案扩展 2.在CPU中，那些寄存器属于控制用指令部件，它们各起什么作用？答案扩展 3.比较说明中断方式与DMA方式的异同答案扩展 4.什么是指令周期、机器周期和时钟周期？二者有什么关系？答案扩展 5.在浮点数中，阶码的正负和尾数的正负各代表什么含义？对于实际数值的正负与大小有何影响？答案扩展 6.静态存储器依靠什么存储信息？动态存储器又依赖什么原理存储信息？比较他们的优缺点。答案扩展 7.将二进制数101101.101转换成八进制数和十六进制数。答案理解 8.已知[x]原=10110101，求真值x及其补码和反码。答案理解 9.设某机主频为8MHZ，每个机器周期平均含两个时钟周期，每条指令平均有2.5个机器周期，问该机的平均指令执行速度为多少MIPS？若机器主频不变，但每个机器的周期平均含4个时钟周期，每条指令平均含五个机器周期，则该机的平均指令执行速度又是多少MIPS？答案理解 10.设有一个具有20位地址和32位地址字长的存储器，问：1.该存储器能存储多少字节的信息？答案 2.如果存储器由512k*8位的SRAM芯片组成，需要多少片答案 3.需要多少位地址作为芯片选择答案 11.指令格式如下所示，其中OP为操作码字段，试分析指令格式特点。答案 12.冯.诺依曼原理的基本思想答案扩展 13.说明机器指令和微指令的关系答案扩展 14.外部设备的编址方式，并简述特点答案扩展 15.CPU响应中断应具有哪些条件？答案扩展 16.简述提高并行性的技术途径答案扩展 17.什么是自同步能力？具有自同步能力的磁记录方式有哪些？答案 18.RISC的三个要素答案扩展 19.设浮点数X=0.1101*1001，y=-10.10101*1011，求x+y=？答案 20.某计算机指令字长16位，地址码是三位，指令有 无地址、一地址、和二地址3种格式，设有N条二地址指令，无地址指令M条，试问一地址指令最多有多少条答案 21.什么叫指令？什么叫指令系统答案扩展 22.一次程序中断大致可分为哪几个阶段答案扩展 23.说明计算机系统的结构层次答案扩展 24.说明Cache的地址映射作用和方法答案扩展 25.什么是指令流水线技术？主要有哪些先关影响流水线效率？答案扩展 26.一个较完整的指令系统应包括哪几类指令？答案扩展 27.说明基本CPU模型中，指令寄存器、程序计数器、地址寄存器、状态条件寄存器的功能答案扩展 28.取指令事件指令和取数据事件答案 29.什么是“相联存储器”？相联存储器由哪几部分组成答案 30.什么是存储保护？通常采用什么方法？答案 31.什么是计算机体系结构中的并行性？有哪些提高并行性的基础技术方法答案 32.Cahche与主存之间的地址映像方法有几种？各有何特点？答案 33.DRAM存储器为什么要刷新？有哪几种常见的刷新方式答案 34.CPU有哪些主要寄存器？简述这些寄存器的功能。（答案较详细）答案 35.RISC机器具有什么优点，试简单论述。答案 36.计算机存储系统分为哪几个层次？每个层次主要采用什么存储介质？其存储容量和存取速度的相对值如何？答案 37.每道有16个扇区，每个扇区存储512个字节，假设磁盘旋转速度为每分钟3600转，求数据传输率答案 38.某计算机的Cache-主存层次采用组相联映射方式，页面大小为128B，Cache容量为64页，按4页分组，主存容量为4096页，问：1.主存地址共需多少位？答案 2.主存地址字段中主存字块标记，组地址标记和页内地址各需要多少位？答案 39.设某机有四个中断源A、B、C、D，其硬件排队优先次序为ABCD，现在要求将中断处理次序改为DACB。1.写出每个中断源对应的屏蔽字答案 2.按下图时间轴给出的四个中断源的请求时刻，画出CPU执行程序的轨迹。设每个中断源的中断程序时间均为20s答案 40.设机器数字长为8位（含一位符号位），若A= +15， B=+24，求【A+B】补和[A-B]补并还原成真值答案 41.奔腾处理器基本总线周期利用两个时钟周期可以传送8个字节数据，如果其总线时钟频率在100Mhz，则总线带宽是多少答案 42.有一个1024K*32位的存储模块，他有多少字节容量？如果用128K*8的SRAM芯片组成，需要多少芯片，每个芯片的地址引脚有多少条？答案 43.CPU执行一段程序时，Cache完成存取的次数为5000次，主存完成存取的次数为200次。已知Cache存取周期为40ms，主存存取周期为160ns。求：Cache命中率和平均访问时间Ta答案 44.已知时钟频率5Mhz的8086微处理器能够用4个时钟周期传送16位数据，请计算其处理器总线宽度答案 45.已知X=0.10011，Y=0.11001,用补码减法计算X-Y=？，要求写出计算过程，并指出计算结果是否溢出。答案 46.有一 主存—Cache 结构的存储器，其主存容量1MB，Cache容量64KB，每块8KB，采用直接地址映射方式。答案 47.若机器字长36位，采用三地址格式访存指令，共完成54种操作，操作数可在1K地质范围内寻找，画出该机器的指令格式并加以说明答案 48. 某机采用微程序控制器，其微程序控制器有18种微操作指令（采用直接控制法，即水平型微指令），有8个转移控制状态（采用译码形式），微指令格式中的下址字段7位。该机器指令系统采用4位定长操作码，平均每条指令由7条微指令组成答案 49.填空题书上重点习题（第二版）1.高级语言、汇编语言还有机器语言的差别和联系2.如何理解计算机组成和计算机体系结构3.冯·诺依曼计算机的特点是什么4.解释下列英文缩写的中文含义5.假设总线的时钟频率为100Mhz，总线的传输周期为4个时钟周期，总线的宽度为32位，试求总线的数据传输率。6.在异步串行传输系统中，假设每秒传输120个数据帧，器字符格式规定包含1个起始位，7个数据位，1个奇校验位，一个终止位，试计算波特率7.8. 1.在“Cache-主存-辅存”三级存储体系中，“Cache-主存”结构与“主存-辅存”结构的引入为了解决什么问题？ 答案 1.“Cache-主存”结构的引入是为了解决主存与cpu速度不匹配的问题。
2.“主存-辅存”结构的引入是为了解决主存储器容量不足的问题
扩展 Cache存储器，电脑中为高速缓冲存储器，是位于CPU和主存储器DRAM（内存）之间，规模较小，但速度很高的存储器，通常由SRAM（Static Random Access Memory 静态存储器）组成。它是位于CPU与内存间的一种容量较小但速度很高的存储器。CPU的速度远高于内存，当CPU直接从内存中存取数据时要等待一定时间周期，而Cache则可以保存CPU刚用过或循环使用的一部分数据，如果CPU需要再次使用该部分数据时可从Cache中直接调用，这样就避免了重复存取数据，减少了CPU的等待时间，因而提高了系统的效率。Cache又分为L1Cache（一级缓存）和L2Cache（二级缓存），L1Cache主要是集成在CPU内部，而L2Cache集成在主板上或是CPU上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c219a18678ae123decf6e84bd225a69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4214506c334a815d39e5e1859c842fc/" rel="bookmark">
			Android中DataBinding的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Data Binding的使用 1.安装插件 2. 创建dataBinding 环境 dataBinding {
enabled = true
}
注意：如果你的应用中有其他模块或依赖的库用到了Data Binding，也需要在buidl.gradle中配置
3. BaseActivity 统一调用布局 private void performDataBinding() {
binding = DataBindingUtil.setContentView(this, getLayoutId());
binding.executePendingBindings();
}
4. 编写布局xml之后通过插件将布局转换成databinding 5. databinding 的使用 5.1 variable简单使用 bean中
public class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4214506c334a815d39e5e1859c842fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2293a1d1c135f7d44a12080cb1abfcb/" rel="bookmark">
			“揭秘” Xilinx FPGA 的 ECO 功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欲观原文，请君移步
ECO 指的是 Engineering Change Order ，即工程变更指令。目的是为了在设计的后期，快速灵活地做小范围修改，从而尽可能的保持已经验证的功能和时序。ECO 是从 IC 设计领域继承而来，ECO 便相当于 ISE 上的 FPGA Editor。本文可以对于一些FPGA疑难杂症文件排查，或者对于一些加密 IP 进行破解，请读者自行琢磨，不予公开。【如有兴趣，请联系作者】
1.ECO的用途 修改 ILA 或者 VIO 的调试探针
将一个内部网络路由到外部探针
修复逻辑错误等
2.ECO 流程 打开已经实现的设计，修改网表后，如果设计未完全布局，请运行“增量布局”。否则，可以直接跳至增量布线。然后可以保存更改到新的检查点并编写新的编程和调试探针文件，打开
硬件管理器对设备进行编程。
3.ECO 工程实例 打开 dcp ，在 vivado 中一个工程在生成bit流过程中会产生 implementation 阶段产生三个 dcp 文件，分别是 *_opt.dcp, *_place.dcp, *_route.dcp中添加，如果需要固定布线，只是微调一下某些net，则使用, *_route.dcp, 对应不同的阶段，如果工程需要添加一些 cell ，可以在*_place.dcp中添加，如果需要固定布线，只是微调某些net，则使用*_route.dcp。
3.1 修改 ila 信号 本次实例采用*_route.dcp。
3.1.1 断开 net disconnect_net -net u_ila_0_axis_rx_tlast -objects [list {u_ila_0/probe8}] u_ila_0_axis_rx_tlast 的 net 名
Objects 后面的 pin 脚
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2293a1d1c135f7d44a12080cb1abfcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5cc0672a811e098d03d348f01b29ca0/" rel="bookmark">
			DDR3：MIG控制器设计（vivado）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：DDR SDRAM 全称为 Double Data Rate SDRAM，中文名为“双倍数据流 SDRAM”。DDR SDRAM 在原有的 SDRAM 的基础上改进而来。也正因为如此，DDR 能够凭借着转产成本优势来打败昔日的对手 RDRAM，成为当今的主流。DDR3为第四代SDRAM，第一代SDR SDRAM，第二代DDR SDRAM，第三代DDR2 SDRAM，第四代DDR3 SDRAM。 很多人将SDRAM错误的理解为第一代，也就是 SDR SDRAM，并且作为名词解释，皆属误导。
日常·唠嗑：对于深入做项目来说，DDR是必不可少的，特别是在做图像处理或者数据交互的时候。最近在做车牌识别的时候，就遇到了很多关于DDR数据读写的难题，好在查阅相关资料，以及在诸多大佬的帮助下，问题顺利解决了。
进入正文：
MIG IP 控制器是 Xilinx 为用户提供的一个 DDR 控制的 IP, 这样用户即使不了解 DDR 的控制和
读写时序也能通过 DDR 控制器方便的读写 DDR 存储器。7 系列的 DDR 控制器的解决方案如下所
示：
DDR3 控制器包含 3 部分:用户接口模块(User interface Block), 存储器控制模块(Memory
Controller)和 DDR3 的物理接口(Physical Layer)。开发人员只需要开发用户的逻辑设计跟 DDR 控制
器的用户接口对接来读写 DDR3 的数据。关于 DDR3 控制器用户端的接口定义和时序的更多介绍，
大家还是参考 Xilinx 提供的文档（UG586），接下来为大家介绍如何生成和配置 DDR3 控制器吧！
1、首先在 Vivado 环境里新建一个项目，取名为 ddr3_test。再点击 Project Manager 界面下的 IP
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5cc0672a811e098d03d348f01b29ca0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/419/">«</a>
	<span class="pagination__item pagination__item--current">420/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/421/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>