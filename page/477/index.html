<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef122889fbdbf7ae5b8500f62e0f299/" rel="bookmark">
			skadmin管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 skadmin管理系统 项目基于 Spring Boot 2.1.0 、 Spring Data JPA、 Spring Security、Redis、Vue的前后端分离的管理系统，项目采用分模块开发方式， 权限控制采用 RBAC（Role-Based Access Control，基于角色的访问控制），支持数据字典、数据权限管理、前端菜单支持动态路由， 另外还有其他的功能模块：日志管理、代码生成器、系统监控、云存储管理、系统工具等等。
项目源码 后端源码前端源码githubhttps://github.com/DengSinkiang/skadminhttps://github.com/DengSinkiang/skadmin-front-end 欢迎各路大神 star and fork ！！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7d992d7fde4c485574b60079f759e5/" rel="bookmark">
			C&#43;&#43; 获取时间戳：下周一、月初、月中、月末
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 获取时间戳：下周一、月初、月中、月末 在一次开发过程中需要利用当前时间获取下周一、这个个月月中、这个月月末和下个月月初的时间戳，在此做一个总结。
#include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;unistd.h&gt; #include &lt;time.h&gt; #define ONE_DAY (86400) using namespace std; int GetWeek(long now_timestamp) { struct tm gmtm; gmtime_r(&amp;now_timestamp, &amp;gmtm); int day_of_week = gmtm.tm_wday; return day_of_week == 0?7:day_of_week; } int GetDay(long now_timestamp) { struct tm gmtm; gmtime_r(&amp;now_timestamp, &amp;gmtm); int day_of_month = gmtm.tm_mday; return day_of_month; } int GetYears(long now_timestamp) { struct tm gmtm; gmtime_r(&amp;now_timestamp, &amp;gmtm); int years = gmtm.tm_year; return years; } int GetMonth(long now_timestamp) { struct tm gmtm; gmtime_r(&amp;now_timestamp, &amp;gmtm); int month = gmtm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f7d992d7fde4c485574b60079f759e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd2000d3a646687cb745c18ebb9ae8f7/" rel="bookmark">
			信赖域方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理解信赖域最好的途径是与线（一维）搜索对比，理解其区别．在ceres中，就提供了两种求解器，一种是基于信赖域的，一种是基于线搜索．
信赖域与线(一维)搜索之间的区别，可以用以下例子来理解；故事是这样的，永强头一天和王大拿约定第二天晚上一起喝酒，王大拿在山庄北边找一个店等永强，但是当时并没有说具体在哪家店．第二天永强从象牙山庄西边出发，去找王大拿．他有两种策略：一种是一维搜索，一种是信赖域．如果采用一维搜索的方案，永强已经确定了王大拿的方向（西北边），那他只要往那个方向走即可．一边走一边喊王大拿的名字，就可以确定走的距离，最终即可找到王大拿．如果采用信赖域的方案，永强首先划定一个１０米的圆圈，在这个圈中找到里王大拿最近的地方（可以通过观察周边情况确定，如是否能看到周围有酒馆，是否是王大拿经常出没的地方等），然后不断画圈，最终把王大拿所在的酒馆找出来．
一，线搜索方法 在线搜索方法中， δ x = a k p k \delta x = a_kp_k δx=ak​pk​ 其中， a k a_k ak​是一个数值，表示步长， p k p_k pk​表示与状态量相同维度的向量．一般来说，首先要确定方向 p k = − ( B k ) − 1 ▽ f k p_k=-(B_k)^{-1}\triangledown f_k pk​=−(Bk​)−1▽fk​. 根据 B k B_k Bk​的不同, 线搜索分为如下三类
B k = I B_k = I Bk​=I 时，即为原始最陡梯度下降法 B k = ▽ 2 f k B_k = \triangledown^2 f_k Bk​=▽2fk​, 即为牛顿法（若二阶导求不出来，用 ▽ f k T ▽ f k \triangledown f_k^T\triangledown f_k ▽fkT​▽fk​来近似，则为高斯牛顿法） B k B_k Bk​为对称正定矩阵，为拟牛顿法． 在确定完方向之后，如即采用最陡梯度下降法， p k = − ▽ f k p_k = -\triangledown f_k pk​=−▽fk​.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd2000d3a646687cb745c18ebb9ae8f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c0b2864e495188351e32ced14b92c9/" rel="bookmark">
			C&#43;&#43; sleep() 和 usleep() 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ sleep() 和 usleep() 的区别 代码如下：设置一个时间参数，分别向sleep()和usleep()方法传入该参数，打印sleep和usleep前后的系统时间戳
#include &lt;time.h&gt; #include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;unistd.h&gt; using namespace std; int main(int argc, char *argv[]){ int sleep_time = 100; cout &lt;&lt; "sleep before time: " &lt;&lt; time(NULL) &lt;&lt; endl; sleep(sleep_time); cout &lt;&lt; "sleep after time: " &lt;&lt; time(NULL) &lt;&lt; endl; cout &lt;&lt; "======================" &lt;&lt; endl; cout &lt;&lt; "usleep before time: " &lt;&lt; time(NULL) &lt;&lt; endl; usleep(sleep_time); cout &lt;&lt; "usleep after time: " &lt;&lt; time(NULL) &lt;&lt; endl; } 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c0b2864e495188351e32ced14b92c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9080f7763b3f300c7467a06a523123dc/" rel="bookmark">
			移动终端app测试点总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下所有测试最后必须在真机上完整的执行
安装、卸载测试
在真机上的以及通过91等第三方的安装与卸载
安装在手机上还是SD卡上启动app测试升级测试
数字签名、升级覆盖安装、下载后手动覆盖安装、跨版本升级、升级后可以正常使用。
覆盖安装要确保数据库有字段更新的话，能正常更新，否则就容易导致app异常。功能测试
包括功能点、业务逻辑、关联性（主要测试客户端与PC端的交互，客户端处理完后，PC端与客户端数据一致）、服务端接口测试（主要通过访问服务端接口来验证服务端业务逻辑功能点是否正确）数据对比测试
可在模拟器或真机上进行，同时与数据中实际的插入记录做对比，还要对比主站的相同流程性能安全android特性测试（横竖屏、home键、音量键、power键等）各种网络状态下进行的测试（包括飞行模式）
3G上网：TD-CDMA、CDMA2000、WCDMA能否正常使用。
edge、GPRS能否正常使用（主要测试是否支持net接入点和WAP接入点）中断测试
如突然来电
短信弹出
低电量等时app能否正常使用app切换测试（最小化、多个app切换）关机、待机后app能否正常使用兼容性测试
android各种版本
各种分辨率QVGA、WVGA、HWVGA等
与其第三方app的兼容app在清空数据或强制退出后还能正常运行否API，包括在app内跳转到另一个界面，在返回来，以及跳转到系统APIapp对资源的占用（cpu,内存，耗电，流量等）app本身涉及的权限长时间开机且开app，看是否会出现异常情况互动分享：如果程序里面包括分享功能，那么检测点击分享的时候是否会正常给出分享提示，点击分享后填写的分享内容是否正确 原文：http://xqtesting.blog.51cto.com/4626073/1148074
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d3ea58c91709835cb50467a214ea03/" rel="bookmark">
			ziparchive 压缩工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://php.net/manual/en/class.ziparchive.php
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94abee94ada4368191b3e385ae457d09/" rel="bookmark">
			C语言模拟进程调度算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本程序中主要通过7个子函数来实现多个进程并发执行的模拟，分别是加入准备队列函数sort、输入进程函数input、计算准备队列长度函数space、显示进程函数disp、输出正在运行进程和等待中进程的函数check、进程结束函数destroy和进程运行函数running；可以模拟在单处理器的环境下多个进程实现并发执行的每一个流程部分。
（1）进程运行函数sort：
首先创建一个insert变量判断是否有插入，如果准备队列为空或者准备队列队首等优先级小于新加入进程p的优先级，则将新加入等进程插入到准备队列队首；而如果准备队列不为空或者准备队列队首等优先级不小于新加入进程p的优先级，那么就需要通过循环来找出对应进程的插入点，将first指针指向准备队列队首，将second指针指向first指针等下一个地址，当second指针等指向不为空（没有循环到最后）时进行循环，每次循环的过程中判断新加入进程p的优先级是否大于循环到的进程的优先级，若新加入进程p的优先级大于循环到的进程的优先级，则将新加入进程p插入到准备队列当中，同时将insert变量置成1，表示已经有插入；而如果新加入进程p的优先级不大于循环到的进程等优先级，则让指针一直后移。如果到最后insert变量一直为0，也就是一直都没有插入（新加入进程p的优先级最小），则将新加入进程p插入到准备队列的尾部，作为优先级最小的进程。
图1 sort函数运行流程图
（2）输入进程函数input：
首先为新建的进程p分配空间，之后输入进程名、到达时间、服务时间和优先级，并将运行时间片置为0，将进程状态置为‘w’，意思是等待，最后调用上述自定义的sort()函数将进程p加入到准备队列中。
（3）输出正在运行进程和等待中进程的函数check：
主要的作用是输出正在运行的进程和等待中的进程，并为等待用的进程优先级增加2。首先需要定义进程指针pr，并为进程指针pr分配空间，之后调用显示进程函数disp，显示正在运行的进程p。将进程指针pr指向准备队列的队首，并进行循环，如果没有循环到准备队列队尾，调用显示进程函数disp显示正在等待的进程pr，将进程指针pr循环到的正在等待的进程优先级加2，并让pr指针后移，继续循环。
图2 check函数运行流程图
（4）显示进程函数disp：
主要用于显示进程的状况，功能很单一，就只是输出进程名、状态、优先级和运行时间片。
（5）计算准备队列长度函数space：
这个函数的功能比较简单，首先需要定义长度变量l初值为0，并且定义进程指针pr将pr指向准备队列队首，并进行while循环，若没有循环到队尾，则长度自增1，并且让pr指针后移，继续进行循环，最终返回一个准备队列的长度。
（6）进程结束函数destroy：
首先需要提示进程运行结束，并且释放正在运行的进程指针p所指向的空间。
（7）进程运行函数running：
这个函数的目的就是对正在运行的进行修改一些属性，使之能够模拟多个进程并发执行的效果。首先需要将正在运行的进程p的运行时间加1，之后进行判断，如果运行的时间片等于所需服务的时间（进程运行结束），则调用进程结束函数释放空间；而如果如果进程未运行结束，则将正在运行的进程优先级减2，将正在运行的进程状态修改为w（等待），最后调用准备队列函数，重新将正在运行的进程插入准备队列中。
图3 running函数运行流程图
（8）主函数：
主函数是整个程序的核心，首先需要输入5个进程，并将其加入到准备队列中，之后通过调用space()函数计算准备队列长度。当准备队列长度不为0且准备队列不为空时，进行循环；在循环中首先需要接收一个字符（接收回车），以示一个时间片。之后将准备运行的进程指针指向准备队列队首，并将准备队列队首位置后移；将即将运行的进程p隔离开，同时修改进程p的状态为r（运行状态），调用check()函数输出正在运行的进程和等待中的进程，并为等待用的进程增加优先级。最后调用进程运行函数运行进程指针p所指向的进程，输出下一步的提示。循环结束之后，代表5个进程都运行结束，输出提示。
图4 主函数运行流程图
运行结果：
图5 5个进程输入的结果图
输入5个进程，输入的顺序分别是进程名、到达时间、服务时间和优先级。
图6 运行第一个时间片的结果图
可以发现率先运行的是优先级最高的进程PCB2。
图7 运行第二个时间片的结果图
第二个时间片中可以看出原先执行的进程PCB2优先级减2，运行时间加1；同时原先等待的剩余进程优先级加2.在本时间片中执行的是优先级最高的进程PCB1。
图8 运行最后一个时间片的结果图
在最后一个时间片中准备队列为空，当执行完进程后，输出process was done 的提示，表示所有进程都已经执行完毕。
结果分析：
程序在执行过程中，需要输入5条进程的信息，分别依次输入进程名、到达时间、服务时间和优先级，由于实现的结果是模拟动态优先权调度算法，而所谓动态优先权调度算法则需要通过创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。
因此在本程序中，在就绪队列中的进程，随其等待时间的增长，其优先权以2为速率提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，这之中也体现了FCFS算法。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。另外当采用抢占式优先权调度算法时，再规定当前进程的优先权也以2为速率下降，则可防止一个长作业长期地垄断处理机。
进程在就绪队列中等待一个时间片之后，优先数增加2，而进程每运行一个时间片，优先数减2，另外在运行过程中，当前进程的运行时间每次加1，当运行的时间片等于所需服务的时间时，进程运行结束。
以下为程序运行的初始状态：
进程名
PCB1
PCB2
PCB3
PCB4
PCB5
到达时间
0
2
3
6
9
服务时间
5
3
5
2
2
优先级
2
3
1
2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94abee94ada4368191b3e385ae457d09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8898aa72c2fdaff9bbb950e595769de/" rel="bookmark">
			matlab中textscan和textread函数的比较使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：matlab中textscan和textread函数的比较使用 作者：sylvain
通过看其他热心网友的总结帖以及自己一点实践，简单说一下使用这个两个函数时需要注意的点：
1、基本语法
textscan的基本语法是：
C = textscan(fid, 'format') C = textscan(fid, 'format', N) 其中fid为fopen命令返回的文件标识符，这也是和textread的最大不同之处，需要注意的一点是，fid类似一个指针，其指向的位置会随着textscan的操作而改变，每读取一次数据，它的位置就会指向你已经读过的那个数据的后面。format实际上就是一个字符串变量，表示读取数据及数据转换的规则。N为按照读取格式format读取的次数。
textread的基本语法是：
[A,B,C,…] = textread（filename,format） [A,B,C,…] = textread（filename,format,N） 其中filename就是文件名， format就是要读取的格式，A,B,C就是从文件中读取到的数据。
必须严格遵守用法不可出现data=textread(filename,format,N)的形式
其中括号里面变量的个数必须和format中定义的个数相同。 如果每N行相同格式的数据，可采用[A,B,C,…] = textread（filename,format,N）的语法，读取N次。
2，两者的区别
可以看出这个两个函数最大的区别就是：textread不用先fopen那个文件，适用于格式统一的txt文件的一次性大批量读取。而使用textscan函数之前需要先用fopen函数打开要读取的文件并返回句柄fid。
其次textread读取某个文件后，下次再用textread读取这个文件时，还是会从文件头开始读取。而textscan函数每次读完数据后，其对应的句柄fid都是指向接下来要读数据的地方，类似于C函数中的文件读取指针，这样更方便于读取文本时的精确控制。
再次，textscan函数可以将多组数据读到一个元胞矩阵中，而textread函数只能将数据分别读取到不同的向量中。比如一个含有10行3列浮点数的文件，textscan函数可以将之读取到一个变量名A下 A=textscan(fid, ‘%f%f%f’), 而使用textread函数必须将之读入到三个变量名中 [A,B,C] = textread（filename,’%f%f%f’）。
3，几个方便的语法
假设文件myfile.txt 中的内容如下
Sally Type1 12.34 45 Yes Joe Type2 23.54 60 No Bill Type1 34.90 12 No [data1 data2 data3 data4 data5] = textread(‘myfile.txt’,’%s%s%f%d%s’);使用textread函数分别将数据按照格式读入到data1—data5中。然后可使用赋值语句data=[data1 data2 data3 data4 data5 data6]生成一个二维数组data。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8898aa72c2fdaff9bbb950e595769de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1654fd0b5acdf10ab7ae0b9352cd360a/" rel="bookmark">
			esp8266入门笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天找了半天的esp8266教程终于找到了一个好的视频教程
连接分享给大家：https://www.qutaojiao.com/227.html?time=1560184566600
今天写的第一个NodeMCU esp8266程序：
void setup() { // 初始化数字引脚13作为输出。 pinMode(13, OUTPUT); } // 循环函数一次又一次地运行 void loop() { digitalWrite(13, HIGH); // 打开LED（HIGH是电压电平） delay(1000); // wait for a second digitalWrite(13, LOW); // 将电压设为低电平，关闭LED delay(1000); // wait for a second } 以前总是不知道引脚号的对应，今天终于找到了原理图 第二个程序按键控制小灯
int led = 5; // LED引脚 int button = 16; // 按键连接的引脚 int temp = 0; // 用于读取按键状态的临时变量 void setup() { pinMode(led, OUTPUT); // LED设置为输入 pinMode(button, INPUT); // 按键设置为输出 } void loop() { temp = digitalRead(button); if (temp == HIGH) { digitalWrite(led, HIGH); Serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1654fd0b5acdf10ab7ae0b9352cd360a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/594aba80c2f29c16afc5ed527323df4d/" rel="bookmark">
			Apache 安装虚拟主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 通过安装虚拟主机实现一台主机提供多个网站的服务 Apache 中的新建虚拟主机的配置文件是单独的配置文件(httpd-vhosts.conf) 默认是关闭的 所以第一步是通过Apache的配置文件打开配置虚拟主机的配置文件 把前面的注释符去掉就可以了 接着打开 Apache24\conf\extra下面的httpd-vhost.conf配置文件 每一个&lt;VirtualHost&gt; 都代表一个虚拟主机 后面的*:80代表所有通过80端口(即web服务)访问的客户端 都访问到此虚拟主机中 通过代码配置虚拟主机 # *代表不限制ip :80指监听所有web服务
&lt;VirtualHost *:80&gt;
# 指定虚拟主机文件位置 DocumentRoot "F:\server\secondweb"
# 指定主机名 ServerName www.myweb.com # 文件夹权限配置
&lt;Directory "F:\server\secondweb"&gt;
# 所有人都可以访问
Require all granted
# 默认打开文件
DirectoryIndex index.php index.html
&lt;/Directory&gt;
&lt;/VirtualHost&gt;
此时已经将目标文件夹与www.myweb.com域名连接到一起 但是直接访问www.myweb.com会访问到外网DNS解析系统中的主机 因此需要现在主机电脑的imhosts.asm中（C:\Windows\System32\drivers\etc）维护域名与对应虚拟主机的关系 这样的话当浏览器中输入域名www.blogwwm.com的时候会先从本地的hosts 文件打开对应的网站 从而实现了一台服务器提供两个网站的功能 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb87e72f3a82bc5688d58e3078664b3/" rel="bookmark">
			xxxx does not support chkconfig 的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# chkconfig --add xxx
service xxx does not support chkconfig
需要在该启动脚本里添加如下文件信息
# chkconfig: 2345 50 90
# description: test mic server scripts
#chkconfig: 2345 50 90 含义 其中2345是默认启动级别，级别有0-6共7个级别
50是启动优先级，
90是停止优先级，
优先级范围是0－100，数字越大，优先级越低。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03cfe2c7a8809289a5cbacef37e2725a/" rel="bookmark">
			Sql去重查询数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在工作过程中，面试过程中， 部分求职者或者同事，对sql怎么去重查询，不是太熟练
今天下午忙里偷闲， 整理了一下 其实sql基本的查询 ，还是蛮有意思， 下面是我大致整理的几种去重查询 1.存在2条一样的数据， 使用distinct
eg: select distinct * from table(表名) where 条件
2.存在部分字段相同(有key, id 即唯一键) 如：id列不同,id类型为int,自增字段,使用聚合函数max或其他
eg: select * from table where id in (
select max(id) from table group by [去重复字段表1，.....] having COUNT(*)&gt;1
)
3.没有唯一键 ID， 需要借助创建临时表，来解决
eg: select indentity (int,1,1) as id , * into newtable(临时表) from table
select * from newtable where id in (select max(id) from newtable group by [去重复字段表1，.....]) drop table newtable
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03cfe2c7a8809289a5cbacef37e2725a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc449588bef3093b204b0919272f22c9/" rel="bookmark">
			【深度学习】SENet学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任意方向文本 Arbitrary Shape Scene Text Detection with Adaptive Text Region Representation 这篇论文中，接触到了这个block
从表中看出，SE-VGG16的对于模型性能的提升。
言归正传? Sequeeze-and-Excitation(SE) block并不是一个完整的网络结构，而是一个子结构，可以嵌到其他分类或检测模型中。
SENet的核心思想在于通过网络根据loss去学习特征权重，使得有效的feature map权重大，无效或效果小的feature map权重小的方式训练模型达到更好的结果。
一般卷积层的输出并没有考虑对各通道的依赖性，只是针对各个channel做卷积。本文的目标就是让网络有选择性的增强信息量大的特征，使得后续处理可以充分利用这些特征，并对无用特征进行抑制。SEblock就是给不同通道赋不同的权重，对于所有的转化Ftr：X→U，（X是输入的图形，U是提取的特征），我们都可以建立对应的SE块去对特征进行重计算。具体操作是对U做squeeze（average global pooling，size=W*H），得到一维向量（长度为C），然后做excitation（类似RNN中的门机制，学习参数W来建立通道相关性），得到的结果作为U中C个channel的权重做scale。其目的是学习每个通道的重要程度，增强有用的特征抑制无用的特征(Selectively enhance useful features and suppress less useful ones )
嵌入全局信息 压缩的目的：为了解决通道间相关性的利用问题，我们首先输出特征图中每个通道的信号。每个卷积核都是作用在局部感受野上(针对各个channel做卷积)，这导致每个变换输出U的单元不能利用这个范围之外的环境（上下文）信息。这个问题在感受野很小的较低层级中更加严重。 为了减轻这个问题，我们将全局空间信息压缩成一个通道描述符。利用全局平均池化得到一个通道维度（特征维度）上的统计数据。
这一步的结果相当于表明该层C个feature map的数值分布情况，或者叫全局信息
自适应重标定 激活的目的：为了能够利用压缩操作得到的聚合信息，我们下一步的目标是完整捕获通道维度上的依赖性。为了实现这个目标，这个函数必须具有满足两个标准：第一，他必须足够灵活（尤其是能够学习通道间非线性的相互作用）；第二，他必须能够学习一个非互斥（non-mutually-exclusive）的关系，因为我们希望确保多个通道都能被强调，这与独热激活（one-hot activation）方式相反。为了满足这两个标准，我们选择了一个带有sigmoid激活函数的简单的门限机制：
这个s其实是本文的核心，它是用来刻画tensor U中C个feature map的权重。而且这个权重是通过前面这些全连接层和非线性层学习得到的，因此可以end-to-end训练。这两个全连接层的作用就是融合各通道的feature map信息，因为前面的squeeze都是在某个channel的feature map里面操作。SE块本质上引入了对输入的动态适应性，这有助于增强特征区分能力。
Xc就是channel-wise multiplication，Uc是一个二维矩阵，Sc是一个数，也就是权重，因此相当于把Uc矩阵中的每个值都乘以Sc。
SE block在VGG-16中的具体应用如下， 为什么这里要有两个FC，并且通道先缩小，再放大？ 因为一个全连接层无法同时应用relu和sigmoid两个非线性函数，但是两者又缺一不可。为了减少参数，所以设置了r比率。
def Squeeze_excitation_layer(self, input_x, out_dim, ratio, layer_name): with tf.name_scope(layer_name) : squeeze = Global_Average_Pooling(input_x) excitation = Fully_connected(squeeze, units=out_dim / ratio, layer_name=layer_name+'_fully_connected1') excitation = Relu(excitation) excitation = Fully_connected(excitation, units=out_dim, layer_name=layer_name+'_fully_connected2') excitation = Sigmoid(excitation) excitation = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc449588bef3093b204b0919272f22c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e6842f4de9a1d2485846c260e022359/" rel="bookmark">
			判断溢出的正确方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自于https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65c5b7f97559e43fee392b7c29655ffe/" rel="bookmark">
			史上最简单的 SpringCloud 教程 | 第一篇： 服务的注册与发现Eureka(Finchley版本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：
http://blog.csdn.net/forezp/article/details/81040925
本文出自方志朋的博客
一、spring cloud简介 鉴于《史上最简单的Spring Cloud教程》很受读者欢迎，再次我特意升级了一下版本，目前支持的版本为Spring Boot版本2.0.3.RELEASE,Spring Cloud版本为Finchley.RELEASE。
Finchley版本的官方文档如下：
http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html
spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。另外说明spring cloud是基于springboot的，所以需要开发中对springboot有一定的了解，如果不了解的话可以看这篇文章：2小时学会springboot。另外对于“微服务架构” 不了解的话，可以通过搜索引擎搜索“微服务架构”了解下。
二、创建服务注册中心 在这里，我还是采用Eureka作为服务注册与发现的组件，至于Consul 之后会出文章详细介绍。
2.1 首先创建一个maven主工程。
首先创建一个主Maven工程，在其pom文件引入依赖，spring Boot版本为2.0.3.RELEASE，Spring Cloud版本为Finchley.RELEASE。这个pom文件作为父pom文件，起到依赖版本控制的作用，其他module工程继承该pom。这一系列文章全部采用这种模式，其他文章的pom跟这个pom一样。再次说明一下，以后不再重复引入。代码如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.forezp&lt;/groupId&gt; &lt;artifactId&gt;sc-f-chapter1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;sc-f-chapter1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;module&gt;service-hi&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65c5b7f97559e43fee392b7c29655ffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2cf63256b1ef3bd9f569fd00781d643/" rel="bookmark">
			LCD24064显示程序，此工程直接运行。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**********************************************************************
T6963C C51 Source Code240X64MCU:W78E516D 12MHZLCM Controller : T6963C RA6963
*********************************************************************/
/ 24064A/B
1.FG -----------------GND
2.GND-----------------GND
3.VDD-----------------+5.0V
4.V0
5.WR------------------P3.0
6.RD------------------P3.1
7.CE(CS)--------------P3.2
8.CD------------------P3.3
9.RST-----------------P3.4
10-17.D0-D7-----------P1
18.FS-----------------P3.5
19.LEDA---------------+5.0V
20.LEDK---------------GND
*/
#include &lt;reg52.h&gt;
#include &lt;intrins.h&gt;
#include &lt;stdio.h&gt; #define uint unsigned int
#define uchar unsigned char
#define Graphic 1
#define TXT 0
#define LcmLengthDots 240
#define LcmWidthDots 64
#define LcmDataBus P1
void Delay(uint MS);
char xdata LcmDataPort at 0x0000;
char xdata LcmCmdPort at 0x0100;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2cf63256b1ef3bd9f569fd00781d643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6326f596245fe8420418504c32a1bca6/" rel="bookmark">
			Python 爬虫面试题 170 道：2019 版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 最近在刷面试题,所以需要看大量的 Python 相关的面试题，从大量的题目中总结了很多的知识，同时也对一些题目进行拓展了，但是在看了网上的大部分面试题不是很满意，一个是有些部分还是 Python2 的代码，另一个就是回答的很简单，有些关键的题目，也没有点出为什么，最重要的是还有一些复制粘贴根本就跑不通，这种相信大家深有体会吧，这样就导致我们可能需要去找其他人发的类似的教程。难受啊，所以我决定针对市面上大多的 Python 题目做一个分析，同时也希望大家尽可能的做到举一反三，而不是局限于题目本身。大概就这样吧，有你看过的题目也有你没看到过的。
通过本场 Chat，你将获得如下知识点： 掌握 Python 的基础语法
语法常见的 Python 应用场景
掌握 Python 闭包的使用以及装饰器的使用
生成器和迭代器的使用
常见的设计模式的使用
深浅拷贝的区别
线程、进程、协程的使用
了解 Python 中的元编程和反射
常考的数据结构和算法
爬虫相关知识，网络编程基本知识等
所有题目 语言特性 1.谈谈对 Python 和其他语言的区别
2.简述解释型和编译型编程语言
3.Python 的解释器种类以及相关特点？
4.说说你知道的Python3 和 Python2 之间的区别？
5.Python3 和 Python2 中 int 和 long 区别？
6.xrange 和 range 的区别？
编码规范 7.什么是 PEP8?
8.了解 Python 之禅么？
9.了解 dosctring 么？
10.了解类型注解么？
11.例举你知道 Python 对象的命名规范，例如方法或者类等
12.Python 中的注释有几种？
13.如何优雅的给一个函数加注释？
14.如何给变量加注释？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6326f596245fe8420418504c32a1bca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00e55934c17eb6f800f455aa009b54a/" rel="bookmark">
			解决VMware虚拟机无法联网问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于博主在日常学习生活中经常通过VMware虚拟机来使用Linux或macOS系统，所以也是接触过不少和虚拟机有关的问题。其中，在博主的虚拟机里（如Ubuntu、deepin），有时候会出现主机已经联网，而虚拟机却无法联网的现象。在此，博主记录下有关这个问题的解决方法。
正文
环境：win10系统，VMware15
在“编辑虚拟机设置—-硬件----网络适配器”里，默认安装的虚拟机在此处的网络连接勾选的应该都是NAT 模式（若不是，推荐选择NAT 模式），事实上，选择NAT 模式并没有什么问题，“用于共享主机的IP地址”也就意味着虚拟机可以和主机共享网络。但是选择NAT 模式后，仍然会在虚拟机里出现无法连接有线网络的问题。
解决方法
在VMware菜单栏里，选择“编辑----虚拟网络编辑器”，
点击右下方的“更改设置”，之后点击左下方的“还原默认设置”，这样相当于重装了一次虚拟网络，而且只需要很短一段时间便可完成重装。之后，再次运行虚拟机，应该便可以在虚拟机里正常连接网络了。
Ramscy
2019.6.9 21:38
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22426bf2737f4a2c5187cf2cc68ac723/" rel="bookmark">
			Verilog语法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Verilog HDL语法总结 逻辑 0：表示低电平，也就是对应我们电路的GND；
逻辑 1：表示高电平，也就是对应我们电路的VCC；
逻辑 X：表示未知，有可能是高电平，也有可能是低电平；
逻辑 Z：表示高阻态，外部没有激励信号是一个悬空状态。Verilog的标识符可以是任意一组字母、数字、 $和_(下划线)符号的组合，但标识符的第一个字符必须是字母或者下划线。另外，标识符是区分大小写的。(采用一些前缀或后缀，比如：时钟采用clk前缀： clk_50m， clk_cpu；低电平采用_n后缀： enable_n；统一缩写，如全局复位信号rst；参数统一采用大写，如定义参数使用SIZE)二进制：4’b0101；十进制：4’d2；十六进制：4’ha。当代码中没有指定数字的位宽与进制时，默认为32位的十进制，比如100，实际上表示的值为32’d100。在Verilog语法中，主要有三大类数据类型，即寄存器类型、线网类型和参数类型。真正在数字电路中起作用的数据类型应该是寄存器类型和线网类型。
寄存器类型表示一个抽象的数据存储单元，它只能在always语句和initial语句中被赋值，并且它的值从一个赋值到另一个赋值过程中被保存下来。如果该过程语句描述的是时序逻辑，即always语句带有时钟信号，则该寄存器变量对应为寄存器；如果该过程语句描述的是组合逻辑， 即always语句不带有时钟信号，则该寄存器变量对应为硬件连线；寄存器类型的缺省值是x（未知状态）。
线网表示Verilog结构化元件间的物理连线。它的值由驱动元件的值决定，例如连续赋值或门的输出。如果没有驱动元件连接到线网，线网的缺省值为z（高阻态） 。
参数其实就是一个常量，常被用于定义状态机的状态、数据位宽和延迟大小等，由于它可以在编译时修改参数的值，因此它又常被用于一些参数可调的模块中，使用户在实例化模块时，可以根据需要配置参数。在定义参数时，我们可以一次定义多个参数，参数与参数之间需要用逗号隔开。这里我们需要注意的是参数的定义是局部的，只在当前模块中有效。将parameter定义放在紧跟着module的输入输出定义之后。 reg [31:0] delay_cnt; //延时计数器 reg key_flag ; //按键标志 wire data_en; //数据使能信号 wire [7:0] data ; //数据 parameter DATA_WIDTH = 8; //数据位宽为8位 算术运算符：常用的算术运算符主要包括加减乘除和模除（模除运算也叫取余运算）。Verilog实现乘除比较浪费组合逻辑资源，尤其是除法。一般2的指数次幂的乘除法使用移位运算来完成运算，详情可以看移位运算符章节。非2的指数次幂的乘除法一般是调用现成的IP。逻辑运算符：！，&amp;&amp;，||
位运算符：~，&amp;，|，^拼接运算符：{}，例{a,b}：将a和b拼接起来， 作为一个新信号。关键字：
always 产生reg信号语句的关键字；
assign 产生wire信号语句的关键字；
注：wire信号定义，wire信号就是硬件连线，比如此处的counter_en，代表计数到最大值时产生高电平使能，本质上是一个硬件连线，其实代表的是一些计数器/寄存器做逻辑判断的结果。 parameter WIDTH = 25 ; parameter COUNT_MAX = 25_000_000; reg [WIDTH-1:0] counter ; wire counter_en ; assign counter_en = (counter == (COUNT_MAX - 1'b1)) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22426bf2737f4a2c5187cf2cc68ac723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/559cb3c1445695f25b7504d250267538/" rel="bookmark">
			vagrant root 登录虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题本来觉得是个特别简单的问题，昨天弄的时候折腾了半晚上。所以打算记录下过程，主要也被网上的各种信息误导了。
1 先看下我这vagrant配置信息
Vagrant.configure("2") do |config| config.vm.box = "base" config.vm.box_check_update = false config.vm.network "forwarded_port", guest: 80, host: 8080 config.vm.network "private_network", ip: "192.168.0.1" config.vm.synced_folder "/data/www", "/data/www" # config.vm.provision "shell", inline: &lt;&lt;-SHELL # apt-get update # apt-get install -y apache2 # SHELL end 发现没有登录信息，然后网上查了下资料说是默认的登录用户名是vagrant，密码一样。就像下面。
config.ssh.username = "vagrant" config.ssh.password = "vagrant" 配置上上面的信息然后 vagrant ssh登录，发现登录正常没有问题。修改root的密码。
sudo -s passwd 改完之后按照网上信息修改
vim /etc/ssh/sshd_config PermitRootLogin prohibit-password 改为 PermitRootLogin yes 重启ssh服务 service sshd restart 退出，修改vagrant登录信息
config.ssh.username = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/559cb3c1445695f25b7504d250267538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70726b2bb95595c6c7cfb548adbabeb6/" rel="bookmark">
			迭代子模式（Iterator） Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代子模式 迭代子模式（Iterator）的定义 迭代子模式又叫游标模式（Cursor），是对象的行为模式。迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象（internal representation）。
聚集和Java聚集 多个对象聚在一起形成的总体称之为聚集（Aggregate），聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂化和多样性。数组就是最基本的聚集，也是其他Java聚集对象的设计基础。
Java聚集对象是实现了共同的java.util.Collection接口的对象，是Java语言对聚集概念的直接支持。从1.2版开始，Java语言提供了很多种聚集，包括Vector、ArrayList、HashSet、HashMap、Hashtable等，这些都是Java聚集的例子。
迭代子模式的结构 迭代子模式有两种实现方式，分别是***白箱聚集与外禀迭代子和黑箱聚集与内禀迭代子***。
白箱聚集与外禀迭代子 如果一个聚集的接口提供了可以用来修改聚集元素的方法，这个接口就是所谓的宽接口。
如果聚集对象为所有对象提供同一个接口，也就是宽接口的话，当然会满足迭代子模式对迭代子对象的要求。但是，这样会破坏对内聚对象的封装。这种提供宽接口的聚集叫做白箱聚集。聚集对象向外界提供同样的宽接口，如下图所示：
由于聚集自己实现迭代逻辑，并向外部提供适当的接口，使得迭代子可以从外部控制聚集元素的迭代过程。这样一来迭代子所控制的仅仅是一个游标而已，这种迭代子叫做游标迭代子（Cursor Iterator）。由于迭代子是在聚集结构之外的，因此这样的迭代子又叫做外禀迭代子（Extrinsic Iterator）。
现在看一看白箱聚集与外禀迭代子的实现。一个白箱聚集向外界提供访问自己内部元素的接口（称作遍历方法或者Traversing Method），从而使外禀迭代子可以通过聚集遍历方法实现迭代功能。
因为迭代的逻辑是由聚集对象本身提供的，所以这样的外禀迭代子角色往往仅仅保持迭代的游标未知。
一个典型的由白箱聚集与外禀迭代子组成的系统如下图所示，在这个实现中具体迭代子角色是一个外部类，而具体聚集角色向外界提供遍历聚集元素的接口。
迭代子模式涉及到以下几个角色：
抽象迭代子（Iterator）角色：此抽象角色定义出遍历元素所需的接口。具体迭代子（ConcreteIterator）角色，此角色实现了Iterator接口，并保持迭代过程中的游标未知。聚集（Aggregate）角色：此抽象角色给出创建迭代子（Iterator）对象的接口。具体聚集（ConcreteAggregate）角色：实现了创建迭代子（Iterator）对象的接口，返回一个合适的具体迭代子实例。客户端（Client）角色：持有对聚集及其迭代子对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。 源代码 抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代子模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代子对象的实例。
public abstract class Aggregate { /** * 工厂方法，创建相应迭代子对象的接口 */ public abstract Iterator createIterator(); } 具体聚集角色类，实现了抽象聚集角色类所要求的的接口，也就是createIterator()方法，此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。
public class ConcreteAggregate extends Aggregate { private Object[] objArray; public ConcreteAggregate(Object[] objArray) { this.objArray = objArray; } /** * 构造方法，传入聚合对象的具体内容 */ @Override public Iterator createIterator() { return new ConcreteIterator(this); } /** * 取值方法：向外界提供聚集元素 */ public Object getElement(int index) { if (index &lt; objArray.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70726b2bb95595c6c7cfb548adbabeb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d5375c25dd4c113cc38290b89013a4a/" rel="bookmark">
			优化VMware虚拟机运行速度总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主出于学习和工作的需要，需要经常使用Linux和macOS这两款操作系统，也就免不了在虚拟机里运行这两款系统。因此，博主也不得不通过优化虚拟机的运行速度来满足日常使用时的体验感。
正文
环境：win10系统，VMware15
1、清除多余快照
因为快照在硬盘中会形成很多零散的文件。选择菜单栏“虚拟机–快照–快照管理器”，或者使用快捷键ctrl+M打开快照管理器。删除多余的快照。
2、清理磁盘。
选择“编辑虚拟机设置–硬盘–碎片整理”，之后虚拟机便开始虚拟硬盘的整理，这对读写操作的性能提升是有帮助的。
3、虚拟机全局设置
在VMware菜单栏上选择“编辑–首选项–内存”，选择第一项“调整所有虚拟机内存使其适应预留的主机RAM（F）”。这样，虚拟机就只会读取物理内存，而不会读取硬盘了。这是提高VMware虚拟机运行速度的最基本的方法。当然，要保证宿主机有足够的物理内存空间供虚拟机使用，否则会出现内存争用的情况。
第二项和第三项都需要虚拟机内存和硬盘进行交换。这样，启动虚拟机时，会因为读取硬盘而导致虚拟机的运行速度明显下降。所以不要选择这两项。
5、设置“优先级”
在上图中选择“优先级”，在第一项“抓取的输入内容”选择“高”。
6、设置“设备”
在上图中选择设备，取消勾选“虚拟机运行时在主机上禁用自动运行”。
7、编辑虚拟机设置
在虚拟机配置中，可以将不必要的设备给删除，比如软盘驱动器，虚拟打印机（如果有的话）。点击选中相应的设备之后，再点下面的“移除”即可。
之后在“虚拟机设置”里，选择“选项–高级”，在“进程优先级内”，将第一项“抓取的输入内容”设置为“高”；在下面的“设置”内将“收集调试信息”设置为“无”，并勾选“禁用内存页面修整”。
8、分配合适的内存和CPU
在“虚拟机设置–硬件”里，为虚拟机分配合适的内存和CPU，但需注意不可超过主机自身的内存和CPU。其中，CPU（也就是处理器）要给满（除非你不想要图形界面）。
以上，便是博主对当前博主已知的可以优化VMware虚拟机运行速度的方法的总结。将上面所有步骤全部执行一遍，只要电脑本身硬件不是太差，便可以让虚拟机有比较良好的运行速度。
Lin丶TX
2019.6.6 20:36
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce922271627487c6515778efd1738b96/" rel="bookmark">
			double相乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.报错程序
public class Multiply {
public static Double multiply(Double a, Double b) {
return a * b
}
}
2.分析造成问题的原因
直接执行报错
3.解决方案
public class Multiply {
public static Double multiply(Double a, Double b) {
return a * b ；
}
}
4.扩展问题。发现double相乘会出现失准问题-----解决方案
public static void main(String[] args){ BigDecimal a1 = new BigDecimal(454.585); BigDecimal aa = new BigDecimal(0.05); Double dd=a1.multiply(aa).doubleValue(); System.out.println( dd); } 然而，并不是所有的double类型的数据相乘都会失准。原因我现在并不清楚，有知道的大神看到请求指教一下，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93523abd095e547451dcdd5c2a9ed380/" rel="bookmark">
			观察者模式（Observer） Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观察者模式 观察者模式（Observer）的定义 观察者模式是对象的行为模式，又叫发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。
观察者模式定义了一种一对多的依赖关系，让多个观察者同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。
观察者模式结构 一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。
同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象作出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。
下面以一个简单的示意性实现为例，讨论观察者模式的结构。
观察者模式涉及的角色有：
抽象主题（Subject）角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题对象又叫做抽象被观察者（Observable）角色。具体主题（Subject）角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者（Concrete Observable）角色。抽象观察者（Observer）角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。具体观察者（ConcreteObserver）角色：存储与主题的状态自洽的状态。具体观察者角色实现抽象观察者角色所要求的的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 源代码 抽象主题角色类
public abstract class Subject { /** * 用来保存注册的观察者对象 */ private List&lt;Observer&gt; list = new ArrayList&lt;&gt;(); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer) { list.add(observer); System.out.println("Attached an observer"); } /** * 移除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer) { list.remove(observer); } /** * 通知所有注册的观察者对象 */ public void notifyObservers(String newState) { for (Observer observer : list) { observer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93523abd095e547451dcdd5c2a9ed380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b9ae6fb77175c6ef3bb41bf175747d8/" rel="bookmark">
			堆的向上向下调整算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、已知关键字序列5,8,12,19,28,20,15,22是最小堆，插入关键字3，求调整后得到的最小堆
建堆：
插入关键字3：
从3开始向上调整，让它满足最小堆的特点，过程如下：
3和19交换位置
3和8交换位置：
3和5交换位置
至此交换完毕，满足最小堆的特点，调整后得到的最小堆为3，5，12，8，28，20，15，22，19。
2、已知小根堆为8,15,10,21,34,16,12，删除关键字8之后需重建堆，在此过程中，求关键字之间的比较次数
建堆：
删除关键字8之后，将最后一个节点12放到根节点，也就是原来8的位置，重新建堆
从12开始向下调整，使它满足小根堆的特点，过程如下
12和10交换位置
至此交换完毕，以满足小根堆的特点，此题问的是比较次数，很明显，第一次是比较12和15，第二次是比较12和10并交换，第三次还需要比较12和16，所以一共需要比较三次。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6daeb2161a876751f584d1e66dfff14b/" rel="bookmark">
			STM32的IO口灌入电流和输出驱动电流最大是多少?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚开始学习一款单片机的时候一般都是从操作IO口开始的，所以我也一样，先是弄个流水灯。
刚开始我对STM32的认识不够，以为是跟51单片机类似，可以直接操作端口，可是LED灯却没反应，于是乎，仔细查看资料发现，原来对于ARM，不管你要操作哪个IO口，都要先配置IO口。
不过对于普通的IO口的应用，配置会比较简单，主要就以下几个步骤：
1.打开相应IO口的时钟；
2.打开IO口相应引脚位；
3.配置IO口的模式；
4.初始化IO端口。
对于STM32的IO口可以根据需要由软件配置成8种模式：
（1）GPIO_Mode_AIN 模拟输入
（2）GPIO_Mode_IN_FLOATING 浮空输入
（3）GPIO_Mode_IPD 下拉输入
（4）GPIO_Mode_IPU 上拉输入
（5）GPIO_Mode_Out_OD 开漏输出
（6）GPIO_Mode_Out_PP 推挽输出
（7）GPIO_Mode_AF_OD 复用开漏输出
（8）GPIO_Mode_AF_PP 复用推挽输出
STM32的IO口灌入电流和输出驱动电流最大是多少？
最大可以输出8mA，灌入20mA，但要保证所有进入芯片VDD的不能超过150mA，同样所有从VSS流出的电流也不能超过150mA。
芯片手册这些参数都有的啊，一般配置IO的话有三个选项10MA，20MA，50MA，可以看情况配置，往大的配置也没有关系，实际使用是多少就是多少
STM32的IO口灌入电流和输出驱动电流最大是多少?
1，浮空输入的时候，你想输入大电流都难。浮空输入，内阻比较大，你得很高的电压，这样直接超过STM32的上限了。
2，推完输出，数据手册上最大电流是25ma，总电流也是25ma。实测可以上到60多mA。不过建议单个IO最好不要超过10mA。
STM32的IO口灌入电流和输出驱动电流最大是多少?
用的最多的也就是推挽输出、开漏输出、上拉输入。在这里做一个总结：
一、推挽输出：
可以输出高，低电平，连接数字器件; 推挽结构一般是指两个三极管分别受两互补信号的控制，总是在一个三极管导通的时候另一个截止。高低电平由IC的电源决定。
推挽电路是两个参数相同的三极管或MOSFET，以推挽方式存在于电路中，各负责正负半周的波形放大任务，电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。
二、开漏输出：
输出端相当于三极管的集电极，要得到高电平状态需要上拉电阻才行。适合于做电流型的驱动，其吸收电流的能力相对强（一般20mA以内）。开漏形式的电路有以下几个特点：
1、利用外部电路的驱动能力，减少IC内部的驱动。当IC内部MOSFET导通时，驱动电流是从外部的VCC流经上拉电阻、MOSFET到GND。IC内部仅需很小的栅极驱动电流。
2、一般来说，开漏是用来连接不同电平的器件，匹配电平用的，因为开漏引脚不连接外部的上拉电阻时，只能输出低电平，如果需要同时具备输出高电平的功能，则需要接上拉电阻，很好的一个优点是通过改变上拉电源的电压，便可以改变传输电平。比如加上上拉电阻就可以提供TTL/CMOS电平输出等。（上拉电阻的阻值决定了逻辑电平转换的速度。阻值越大，速度越低功耗越小，所以负载电阻的选择要兼顾功耗和速度。）
3、开漏输出提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。
4、可以将多个开漏输出连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系，即“线与”。可以简单的理解为：在所有引脚连在一起时，外接一上拉电阻，如果有一个引脚输出为逻辑0，相当于接地，与之并联的回路“相当于被一根导线短路”，所以外电路逻辑电平便为0，只有都为高电平时，与的结果才为逻辑1。
三、浮空输入
顾名思义就是浮在空中，上面用绳子一拉就上去了，下面用绳子一拉就沉下去了。
四、上拉输入/下拉输入/模拟输入：
这几个概念很好理解，从字面便能轻易读懂。
五、复用开漏输出、复用推挽输出： . 可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1600336bad20f4e97cd799c3bac99e9/" rel="bookmark">
			IBC&#43;Palette 实现屏幕内容编码优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在屏幕内容编码中采用IBC+Palette编码技术可显著提升其压缩效率。本文主要介绍了腾讯屏幕内容编码优化技术探索与实践：加入IBC+Palette编码工具集，并针对屏幕内容优化ME模块等。本文由腾讯音视频实验室视频编码技术负责人，王诗涛在LiveVideoStack线上分享中的演讲内容整理而成。
文 / 王诗涛
整理 / LiveVideoStack
直播回放：
https://www2.tutormeetplus.com/v2/render/playback?mode=playback&amp;token=e632113e78b14a2eb10ee64a0f16bd07
大家好，我是来自腾讯音视频实验室的王诗涛。接下来将与大家分享我们在屏幕内容编码优化与技术落地的探索之路。
1. 屏幕内容编码
在开始正式分享之前，首先简单介绍一下屏幕内容编码：屏幕内容图像与传统摄像头采集到的图像存在很大不同，屏幕内容图像是电子设备生成的图像，其直接从各类设备（包括但不限于计算机、移动终端）的图像显示单元捕获；一般情况下屏幕内容图像包括以下几个类型：计算机图形文本、自然图像与图形文本结合的混合图像以及计算机所生成的动画。
随着移动设备与智能终端不断渗透人们的生活，屏幕内容图像在我们的生活中也越来越普遍，无论是桌面协作、云游戏，还是第二屏幕、桌面共享、在线教育等领域都有其十分广泛的应用，那么屏幕内容图像与传统的摄像头所采集的图像究竟有什么区别？
摄像头采集到的图像在通常情况下都包含传感器的噪声，且色调一般连续并具有十分复杂的纹理；而对于屏幕图像，其通常并不包含噪声。这是因为其中很多都是计算机生成的图像，色调离散而颜色数更少；除此之外，屏幕图像的线条更为细腻，边缘也较为锐利；同时大部分屏幕图像的均匀平坦区域较多，重复图案与相同块也较多。传统视频编码方案更多为摄像头采集的自然视频图像设计，多采用预测+变换的混合编码结构。此混合编码结构对于屏幕内容编码的编码效果欠佳。如上图右侧所示，图中的Word文档为计算机生成的屏幕图像，我们可以从图中清晰看到一些区域的文字变得非常模糊，许多细节信息被丢失，同时表格边缘有非常明显振铃效应。由于屏幕图像相对于自然采集而来的摄像头图像有很大的不同。我们希望利用好屏幕图像的这些特有特征从而大幅度提高其编码效率和图像质量。
2. HEVC-SCC技术
HEVC针对屏幕图像编码的做了很多编码工具集的优化，首先简单介绍一下HEVC关于屏幕内容编码的一些主要技术。在HEVC的几个版本中都有一些针对屏幕内容编码的优化技术：例如v1版的HEVC就推出了变换跳过的编码技术，其原理是在编码时自主选择是否跳过频域变换；而HEVC-RExt除了变换跳过，还增加了残差旋转、残差DPCM与交叉分量预测等SCC工具；2016年，HEVC推出第四版HEVC-SCC，该版在之前基础上增加了很多专门针对屏幕内容编码的工具集，包括帧内块拷贝、调色板模式、自适应色彩转换与自适应运动矢量精度等。
接下来简要介绍下这几个工具集：
帧内块拷贝：采用当前帧已重建的块作为预测块，IBC在当前编码图像内做运动补偿；
调色版模式：调色板模式会枚举每个编码块的颜色值生成一个颜色表，并为每个样本传递一个索引以指示它属于颜色表中的哪个颜色；解码端根据规则生成一个颜色表并通过颜色表索引完成样本的重建工作。
自适应颜色转换：将残差自适应转换到不同的颜色空间，一个RGB颜色空间的图像块可以直接编码，也可以在编码时自适应地转换到YCoCg颜色空间以进行编码；
自适应运动矢量分辨率：由于编码过程中屏幕内容图像的运动通常是像素级的，因此我们可以在Slice级控制运动矢量MV的精度。
3. IBC编码与调色版模式
SCC编码工具集能显著提升屏幕内容编码压缩效率，这其中以IBC和调色板对压缩效率的提升最为明显。根据相关资料，对于屏幕内容，IBC可提升30%以上的压缩效率，如果加入调色版模式则可在IBC的基础上再提升15%。接下来我将对IBC和调色板进行详细介绍。
IBC编码是由当前编码图像帧的重建块预测得到的，以上图中的PDF截图为例，由于英文仅由26种英文字符组合而成，我们在编码的时候，很容易在当前I帧画面的已完成编码块中找到同一个英文字符；如果在编码时能够参考这些当前编码图像中已经完成重建的编码块，就能大大提升编码效率。比如，图中最后一行的IB两个字符就可以用它左上角的IB两个字符来做预测，这样预测精度非常高。还有一点，IBC是在PU级进行，我们可以将其视为一个帧间PU，帧间模式的设计让IBC和普通的帧间预测模式能够更灵活的连接起来，比如，一个帧间编码的CU可以有两个PU，一个使用传统的帧间预测，另一个使用IBC。
当然，IBC相对于传统帧间预测也存在许多不同：
IBC参考块都是滤波之前的重建像素。
当前图像如果被用于参考，其会被标记为长期参考帧；当整张图像解码完成之后，IBC会对其进行环路滤波然后将当前图像加入到DPB中作为短期参考帧。
IBC的预测块不能和当前CU重叠，以防止未重建好的样本被用于预测。
预测块和当前CU应当位于同一个Slice和同一个Tile。
IBC的块矢量必须是整像素精度。
除了IBC编码，SCC还有另一个重要工具集，也就是调色板模式（Palette mode）。调色板模式对于颜色数比较少的编码块会有比较好的效果，通常情况下，屏幕内容的颜色数量是有限的，这些颜色就可组成一个颜色集合，也就是一个调色板；随后在解码重建每个像素时，解码器可通过颜色表与索引，从调色板中寻找与对应像素点匹配的颜色从而完成像素重建。如上图右侧所示，图中CU有四种颜色，对每个像素点，编码器在进行编码时会直接从颜色表中寻找此对应的颜色值并直接完成像素重建；当颜色数较少时，绝大部分像素都可通过颜色表实现重建；由于采用颜色索引+颜色表的方式，不需要经过变化量化即可实现像素重建，调色板在显著提升编码效率的同时也降低了复杂度。
虽然一个编码块中的绝大多数颜色都可在颜色表中找到与其最为接近的颜色值，但是有时也会出现颜色表中找不到与编码像素点颜色很匹配的颜色的情况。针对这种情况，调色板模式增加了一种被称为“escape”的模式，此模式会对找不到匹配颜色的编码像素点专门进行反量化操作以完成像素重建，从而解决部分颜色点无法找到匹配颜色值继而导致颜色失真的问题。
上图展示了调色板编码的整体流程图，其中包括以下几大模块：颜色表生成模块、模式判决模块以及直方图计算模块。在进行模式选择时，如果最终编码器选定采用调色板模式，那么颜色表以及编码索引参数会被写入码流并传输到解码端。
4. 腾讯屏幕编码技术解决方案（TSE）
之前我们简单介绍了屏幕内容编码技术与HEVC中关于屏幕内容编码的一些工具集。这些工具集中，帧内块拷贝与调色板编码给屏幕内容编码压缩效率带来的提升最为明显。大部分情况下的屏幕内容编码序列如果采用IBC+Palette模式，其压缩效率相对于H265可实现50%以上的提升。对腾讯而言，腾讯无线投屏、腾讯会议等协同办公产品存在大量的桌面共享类的应用场景，共享的内容以PPT、Word等为主，这些都是非常适合屏幕内容编码的。。如果我们能够采用屏幕内容编码技术，无疑会大幅提升编码压缩效率，提升产品竞争力，所以我们启动了屏幕内容编码的研究与实现。接下来和大家分享一下腾讯屏幕编码技术解决方案的研究成果，我们推出了一个专门针对屏幕内容进行优化的编码器——腾讯屏幕内容编码器（TSE）。
TSE编码器主要是在原有编码器的基础上增加了IBC与Palette两个工具集，并且针对性的做了大量性能优化，其中的几项代表性优化有：
1）基于hash搜索的运动估计：对于IBC的运动估计，采用了基于hash表搜索的优化技术。传统的块匹配方法是基于SAD的，该方法耗时过大，无法满足无线投屏产品对于延时的高要求。我们通过使用基于hash搜索的运动估计方法来代替传统运动估计，采用hash表搜索的方式能够大大减少运动估计所需要搜索点的个数，从而降低运动估计的耗时。根据我们之前的统计，此方法在提升速度的同时，带来的压缩效率的损失基本可以忽略不计。
2）快速高效的颜色表生成算法：调色板编码整体流程中耗时最大的就是颜色表生成模块，SCM参考软件中的颜色表生成算法具有很高的复杂度，编码一帧耗时非常大。我们对颜色表的生成算法进行了大量的简化以达到提速的目的。在提速的同时，我们还需提高调色板效率，因为在进行调色板编码时，编码效率高低主要取决于颜色表生成质量，所以优化颜色表生成算法是其中的一项关键技术点。如何复用前面已生成的颜色表也是调色板编码的一个核心技术点。为了提升编码效率，我们最好复用之前已经生成的颜色表，也就是通过前面已经生成的颜色表来预测当前此颜色表，这样就可大幅度节省颜色表传输所消耗的码字，同时显著提升了调色板编码的效果。
3）高效的查找表算法：当颜色表生成之后，编码器需要去查找颜色表以找到每一个像素点的最接近的颜色，如何快速找到最匹配的颜色也是影响调色板编码性能的关键点之一。如果采用YUV三个变量进行搜索，那么我们需要构建一个2的24次方规模的查找表，这在实际应用中显然是不现实的。所以我们也对查找表算法进行了大幅度优化以降低其对于内存的占用。
4）大量的提前退出算法：我们在编码模式选择上加入了大量的快速算法，比如进行帧内、帧间判决后，根据判决结果以及cost值，决定是否要进行调色板编码+IBC编码的cost计算，这样可以节省大量时间。
5）汇编优化：除了以上优化，我们还对其中许多关键模块进行SIMD优化从而显著提升编码速度。
5. 成果与展望
经过上述一系列优化之后，腾讯TSE编码器的性能相较于X265有了显著提升：上图是二者的压缩效率对比数据，右侧为摄像头采集序列，左侧为LDP模式下的屏幕内容序列。对于屏幕内容序列，TSE编码器的编码效率相较于x265-ultrafast模式有70%的性能提升，相对于x265-medium也有将近55%的压缩性能提升；而观察右侧摄像头采集序列的对比数据，TSE编码器的编码效率相较于x265-ultrafast模式有也有20%左右的压缩性能提升。
上图是二者的压缩效率对比数据：对于屏幕内容序列，不打开IBC和PLT，TSE的平均编码耗时仅为x265-ultrafast的33%左右，而打开IBC和PLT，TSE的平均编码耗时是x265-ultrafast的50%左右。无论是编码速度还是编码效率，TSE的优势都十分明显。
TSE不仅在压缩效率和编码速度方面有优势，同时对主观质量的改善也是非常明显的。下图展示了TSE与x265的主观质量对比：
可以看到在相同码率的条件下，x265编码编码得到的图像中文字周边存在明显的振铃效应，给人眼的直观感受就是图像脏且比较模糊；但采用TSE编码所得图像中文字清晰而锐利，人眼的观看体验明显更加舒适，主观体验明显要好。综上所述，TSE编码器能为编码带来码率节省、速度提升与主观体验优化。
TSE技术现已在腾讯无线投屏与腾讯会议上实现了商用化，但提升用户体验的探索对我们来说是永无止境的。我们期望在未来能研发出更加出色的编码器，在尽可能快的情况下实现更好的压缩质量与效率，从而进一步提升用户体验。
LiveVideoStack 招募
LiveVideoStack正在招募编辑/记者/运营，与全球顶尖多媒及技术专家和LiveVideoStack年轻的伙伴一起，推动多媒体技术生态发展。了解岗位信息请在BOSS直聘上搜索“LiveVideoStack”，或通过微信“Tony_Bao_”与主编包研交流。
LiveVideoStackCon 2019北京正在招募讲师，无论你是技术派还是学术派，亦或是行业专家，无论你的团队有多小、有多新，都可以来申请成为LiveVideoStackCon的讲师。点击【阅读原文】了解更多大会相关信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd49c4b8c9bc2d71a5af79bccf114d93/" rel="bookmark">
			深度学习常用预训练网络模型的下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将下载好的模型放在~/.cache/torch/checkpoints文件夹中即可（windows为C:\用户名\.cache\torch\.checkpoints）
Resnet:
model_urls = {
'resnet18': 'https://download.pytorch.org/models/resnet18-5c106cde.pth',
'resnet34': 'https://download.pytorch.org/models/resnet34-333f7ec4.pth',
'resnet50': 'https://download.pytorch.org/models/resnet50-19c8e357.pth',
'resnet101': 'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth',
'resnet152': 'https://download.pytorch.org/models/resnet152-b121ed2d.pth',
}
inception:
model_urls = {
# Inception v3 ported from TensorFlow
'inception_v3_google': 'https://download.pytorch.org/models/inception_v3_google-1a9a5a14.pth',
}
Densenet:
model_urls = {
'densenet121': 'https://download.pytorch.org/models/densenet121-a639ec97.pth',
'densenet169': 'https://download.pytorch.org/models/densenet169-b2777c0a.pth',
'densenet201': 'https://download.pytorch.org/models/densenet201-c1103571.pth',
'densenet161': 'https://download.pytorch.org/models/densenet161-8d451a50.pth',
}
Alexnet:
model_urls = {
'alexnet': 'https://download.pytorch.org/models/alexnet-owt-4df8aa71.pth',
}
vggnet:
model_urls = {
'vgg11': 'https://download.pytorch.org/models/vgg11-bbd30ac9.pth',
'vgg13': 'https://download.pytorch.org/models/vgg13-c768596a.pth',
'vgg16': 'https://download.pytorch.org/models/vgg16-397923af.pth',
'vgg19': 'https://download.pytorch.org/models/vgg19-dcbb9e9d.pth',
'vgg11_bn': 'https://download.pytorch.org/models/vgg11_bn-6002323d.pth',
'vgg13_bn': 'https://download.pytorch.org/models/vgg13_bn-abd245e5.pth',
'vgg16_bn': 'https://download.pytorch.org/models/vgg16_bn-6c64b313.pth',
'vgg19_bn': 'https://download.pytorch.org/models/vgg19_bn-c79401a0.pth',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd49c4b8c9bc2d71a5af79bccf114d93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/866a0ebfdb5f18387e95b46a74f5bffa/" rel="bookmark">
			Android之RecyclerView性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 RecyclerView有着极高的灵活性，能实现ListView、GridView的所有功能。在日常开发中，使用非常广泛，如果使用不当将会影响到应用的整体性能，所以有必要了解一下如何更高效的使用。
数据处理与视图绑定分离 RecyclerView的bindViewHolder方法是在UI线程进行的，如果在该方法进行耗时操作，将会影响滑动的流畅性。
优化前：
class Task { Date dateDue; String title; String description; // getters and setters here } class MyRecyclerView.Adapter extends RecyclerView.Adapter { static final TODAYS_DATE = new Date(); static final DATE_FORMAT = new SimpleDateFormat("MM dd, yyyy"); public onBindViewHolder(Task.ViewHolder tvh, int position) { Task task = getItem(position); if (TODAYS_DATE.compareTo(task.dateDue) &gt; 0) { tvh.backgroundView.setColor(Color.GREEN); } else { tvh.backgroundView.setColor(Color.RED); } String dueDateFormatted = DATE_FORMAT.format(task.getDateDue()); tvh.dateTextView.setDate(dueDateFormatted); } } 上面的onBindViewHolder方法中进行了日期的比较和日期的格式化，这个是很耗时的，在onBindViewHolder方法中，应该只是将数据set到视图中，而不应进行业务的处理。
优化后：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/866a0ebfdb5f18387e95b46a74f5bffa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e7fd38b7cdfb881683b49d24a48eb9/" rel="bookmark">
			HTML&#43;CSS实现五角星评分效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.效果：2.HTML3.CSS4.图片5.另一种样式 1.效果： 技术栈 H5+CSS3+JQ+Bootstrap
2.HTML &lt;!DOCTYPE html&gt; &lt;!--suppress CssUnusedSymbol, JSUnresolvedLibraryURL --&gt; &lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no"&gt; &lt;title&gt;评价&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="../common/css/bootstrap.min.css"&gt; &lt;link rel="stylesheet" href="css/star-main.css" media="all" type="text/css"/&gt; &lt;script src="../common/js/jquery-1.10.2.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;div class="page-header"&gt; &lt;h2&gt;开始评价&lt;/h2&gt; &lt;/div&gt; &lt;form&gt; &lt;div class="panel panel-default"&gt; &lt;div class="panel-heading" style="font-size: 2rem;"&gt;满意度&amp;nbsp;&lt;span style="color:red;"&gt;*&lt;/span&gt;：&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;input name="starNum" id="starNum" type="hidden"/&gt; &lt;div class="starability-container"&gt; &lt;fieldset class="starability-slot"&gt; &lt;input type="radio" id="rate_1_0_1_5" name="starLevel" value="5" /&gt; &lt;label for="rate_1_0_1_5" title="5星"&gt;&lt;/label&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e7fd38b7cdfb881683b49d24a48eb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a1b276be885e81b7237fea2f3ffb29/" rel="bookmark">
			如何在自己网站上播放上传到优酷的视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在优酷上传自己的视频
2.浏览器打开并且播放该视频
3.从地址栏复制出v_show/id_和.html之间的字符串,如下所示
4.在 &lt;iframe src="http://player.youku.com/embed/" 'allowfullscreen'="" frameborder="0"&gt;&lt;/iframe&gt;的http://player.youku.com/embed/之后粘贴所复制的字符串,
如下所示
&lt;iframe src="http://player.youku.com/embed/XMzg5NzEwMzI4NA==" 'allowfullscreen'="" frameborder="0"&gt;&lt;/iframe&gt;
5.在你的网站指定位置加入该串代码,即 &lt;iframe src="http://player.youku.com/embed/XMzg5NzEwMzI4NA==" 'allowfullscreen'="" frameborder="0"&gt;&lt;/iframe&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b230bc2251520b3ddf29e16cf349dcf/" rel="bookmark">
			mb-3 bootstrap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问：什么是mb-0？ 最佳答案: Bootstrap具有广泛的响应边距和填充实用程序类。它们适用于所有断点：
xs(&lt; = 576px)，sm(&gt; = 576px)，md(&gt; = 768px)，lg(&gt; = 992px)或xl(&gt; = 1200px))
这些类的格式如下：
{property} {sides} – {size} for xs&amp; {property} {sides} – {breakpoint} – {size}表示sm，md，lg和xl。
m – 设定保证金
p – 设置填充
t – 设置margin-top或padding-top
b – 设置margin-bottom或padding-bottom
l – 设置margin-left或padding-left
r – 设置margin-right或padding-right
x – 设置padding-left和padding-right或margin-left和margin-right
y – 设置padding-top和padding-bottom或margin-top和margin-bottom
空白 – 在元素的所有4个边上设置边距或填充
0 – 将边距或填充设置为0
1 – 将边距或填充设置为.25rem(如果font-size为16px则为4px)
2 – 将边距或填充设置为.5rem(如果字体大小为16px则为8px)
3 – 将边距或填充设置为1rem(如果字体大小为16px，则为16px)
4 – 将边距或填充设置为1.5rem(如果字体大小为16px，则为24px)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b230bc2251520b3ddf29e16cf349dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ffdfb7ab00d0c656e3b49ca5dffc4aa/" rel="bookmark">
			注解方式实现springMVC产生的错误，Servlet.init() for servlet [springmvc] threw exception
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在写springMVC的demo时，产生下面错误 HTTP Status 500 – Internal Server Error
Type Exception Report
Message Servlet.init() for servlet [springmvc] threw exception
Description The server encountered an unexpected condition that prevented it from fulfilling the request.
Exception
javax.servlet.ServletException: Servlet.init() for servlet [springmvc] threw exception
​ org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493)
​ org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)
​ org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:660)
​ org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)
​ org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:798)
​ org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)
​ org.apache.coyote.AbstractProtocol C o n n e c t i o n H a n d l e r .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ffdfb7ab00d0c656e3b49ca5dffc4aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b833e3df7e23d9726c1f40b85b1ab1f/" rel="bookmark">
			数据库：postgreSQL根据当前时间更新时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、 创建时间类型 timestamptz 2、设置默认 CURRENT_TIMESTAMP 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aa37fabfb5965e2c2b90d80b7277b6b/" rel="bookmark">
			剑指offer Java实现 第六题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第六题：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。
实现思路是用栈保存数据然后利用后进先出的性质来输出数据。
代码实现：
ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); if(listNode == null){ return arrayList; } Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode!=null){ stack.push(listNode.val); listNode = listNode.next; } while (!stack.empty()){ arrayList.add(stack.pop()); } return arrayList; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a5e2bc6be4429c832fa8dbe2d5e5b2/" rel="bookmark">
			剑指offer Java实现 第五题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第五题：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
实现代码：
public static String replaceSpace(StringBuffer str) { if (str == null||str.length() == 0){ return null; } int spaceNum = 0; for (int i=0;i &lt; str.length();i++){ if (str.charAt(i) == ' '){ spaceNum++; } } StringBuffer result = new StringBuffer(20); int p1 = str.length() - 1; int p2 = str.length() + spaceNum*2 - 1; while (p1 != -1){ if (str.charAt(p1) != ' ') { result.append(str.charAt(p1)); p1--; p2--; }else { result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5a5e2bc6be4429c832fa8dbe2d5e5b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25cde61088e38d6325031e5d80793a5f/" rel="bookmark">
			hbase原理详细解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、hbase架构 hbase是主从架构的设计模式，一般有一主多从或多主多从，zookeeper负责协调hbase集群主要是负责一些元数据的存储，主指的是hmaster，从指的是hregionserver
1、系统架构 ps：图片来源网络，若如侵权请联系删除
1.1各个client职责 ZooKeeper 职责
1）ZooKeeper为 HBase 提供 Failover 机制，选举master，避免单点 master 单点故障问题
2）存储所有 Region 的寻址入口:-root-表在哪台服务器上。-root-这张表的位置信息
3）实时监控 RegionServer的状态，将 RegionServer 的上线和下线信息实时通知给 Master
4）存储 HBase 的 schema，包括有哪些table，每个 table 有哪些 column family
HMaster 职责
1）为 RegionServer 分配 region
2）负责 RegionServer 的负载均衡
3）发现失效的 RegionServer 并重新分配其上的 region
4）HDFS 上的垃圾文件(hbase)回收
5）处理 schema 更新请求(表的创建，删除，修改，列簇的增加等等)
HRegionServer 职责
1）RegionServer 维护 Master 分配给它的 region，处理对这些 region 的 IO 请求
2）RegionServer 负责 Split 在运行过程中变得过大的 region，负责 Compact 操作
1.2hbase中的几个核心概念 1.2.1region hbase中是以表结构在行的方向上划分的一个数据单元，一个region存储的是一个表中一定行键范围的数据，一个表在行的方向上进行划分会分成多个region
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25cde61088e38d6325031e5d80793a5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ae26dbc71dfc81be9923941a225f9f/" rel="bookmark">
			Eclipse：出现The selection cannot be launched，and there are no recent launches怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可能是我太大意太粗心，经过网上的资料，现在自己的blog下加以警示。 出现该问题的主要原因是： 因为语法问题导致的出错 解决办法：
1.检查分号。
2.检查main函数。
3.检查main函数后面括号里的String[ ] args；
好了，总结完毕。
错误的示范： public class Clsa { public static void mian(String[] args){//main error！！！！！ System.out.println("dsfdsfd "); } } 正确的示范： public class Clsa { public static void main(String[] args){ System.out.println("dsfdsfd "); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1940c3c29612a03f01daa9bec0a6a121/" rel="bookmark">
			mos管的开通电压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5684bc95ff4f160116d0b08d0459eeb/" rel="bookmark">
			Python实现生命游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者 | 借我一生执拗 来源 | Python高效编程
这次我们使用 Python 来实现生命游戏，这是一种简单的元胞自动机。基于一定规则，程序可以自动从当前状态推演到下一状态。制作的成品如下：
先来说说生命游戏的规则：
在生命游戏中，每个单元格有两种状态，生与死。在我们的实现中，黄色的单元格代表活着的细胞，红色单元格表示死亡的细胞。而每一个细胞的下一状态，是由该细胞及周围的八个细胞的当前状态决定的。
具体而言：
当前细胞为活细胞
周围有两个或者三个活细胞，下一世代，该细胞仍然活着。
周围少于两个活细胞，该细胞死于孤立。
周围多于三个活细胞，该细胞死于拥挤。
当前细胞为死细胞
周围恰好三个活细胞，下一世代，活细胞将繁殖到该单元格。
所需模块 无需安装的标准库：
argparse(命令行参数)
enum(枚举)
第三方库：
numpy
matplotlib
导入模块：
编程要点 首先，我们要知道细胞的生存空间是 N * N 的方阵，每个细胞都有两种状态：on, off。on 为 255，off 为 0。我们使用 numpy 产生 N * N 的方阵。np.random.choice 是在 State.on 和 State.off ，等概率随机抽取元素构造 N * N 的方阵。
class State(IntEnum):
on = 255
off = 0
def random_data(length = 4, seed = 420) -&gt; np.array:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5684bc95ff4f160116d0b08d0459eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82b8b3bdb942344138bf314cbc35b2ac/" rel="bookmark">
			Java项目的目录结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、Common包 Common用来封装一些常用的公共方法。
二、Dao包 Dao主要用来封装对数据库的新增，删除，查询，修改。叫做数据访问层。
三、Service包 服务层，相比Dao较高层次，可将多种方法封装起来。
四、Po包（Persistant Object） Po将数据库表中的记录在java对象中。也就是一个Po就是一个数据库表中的一个记录。
五、Vo包（value object） 和PO一样也是包含数据，但PO中的数据一般跟数据库中的表是一一对应的，而VO不同，一般用来存储数据和传递数据。
六、Util包 Util是utiliy的缩写，是一个多功能，相当于工具的包，封装一些实用的方法和数据结构。
七、Web包 该包内放置Servlet接口，通常实现HttpServlet接口，它能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。
八、Jsp 是一种动态网页开发技术，主要用于实现界面部分。
九、Jdbc Jdbc用来连接数据库，主要步骤：与数据库建立连接、发送sql语句、执行操作数据库的sql语句并处理结果。
Java目录结构图： 一般的java项目分四层： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b069d983fc51ea77fb14b95ca4563d7e/" rel="bookmark">
			JS 将字符串时间转为时间类型时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种适用于：20100823这种字符串格式
function dateValid(){
var bd = document.getElementById("sStartSaveDate").value;
var beginDate = new Date(bd.replace(/^(\d{4})(\d{2})(\d{2})$/,"$1/$2/$3"));
var ed = document.getElementById("sEndSaveDate").value;
var endDate = new Date(ed.replace(/^(\d{4})(\d{2})(\d{2})$/,"$1/$2/$3"));
if(beginDate &gt;= endDate){
alert("结束时间必须大于开始时间！");
return false;
}else{
document.getElementById('searchform').submit(); }
}
第二种适用于：2010-08-23这种字符串格式
unction dateValid(){
var beginDate = new Date(document.getElementById("sStartSaveDate").value.replace(/-/g,"/"));
var endDate = new Date(document.getElementById("sEndSaveDate").value.replace(/-/g,"/"));
if(beginDate &gt;= endDate){
alert("结束时间必须大于开始时间！");
return false;
}else{
document.getElementById('searchform').submit();
}
第三种适用于：2010/08/23这种字符串格式
function dateValid(){
var beginDate = new Date(document.getElementById("sStartSaveDate").value);
var endDate = new Date(document.getElementById("sEndSaveDate").value);
if(beginDate &gt;= endDate){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b069d983fc51ea77fb14b95ca4563d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eaf4caab13ba5a4404f556dd5fe2575/" rel="bookmark">
			vue axios请求频繁时取消上一次请求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在项目中经常有一些场景会连续发送多个请求，而异步会导致最后得到的结果不是我们想要的，并且对性能也有非常大的影响。例如一个搜索框，每输入一个字符都要发送一次请求，但输入过快的时候其实前面的请求并没有必要真的发送出去，这时候就需要在发送新请求的时候直接取消上一次请求。vue axios拦截器介绍
二、代码 import axios from 'axios' import qs from 'qs' export default { methods: { request(keyword) { var CancelToken = axios.CancelToken var source = CancelToken.source() // 取消上一次请求 this.cancelRequest(); axios.post(url, qs.stringify({kw:keyword}), { headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Accept': 'application/json' }, cancelToken: new axios.CancelToken(function executor(c) { that.source = c; }) }).then((res) =&amp;gt; { // 在这里处理得到的数据 ... }).catch((err) =&amp;gt; { if (axios.isCancel(err)) { console.log('Rquest canceled', err.message); //请求如果被取消，这里是返回取消的message } else { //handle error console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eaf4caab13ba5a4404f556dd5fe2575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/522af84bda03f5ecce622842a161f78b/" rel="bookmark">
			Python推导式用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推导式comprehensions， 可以快速，简单的依据一个数据序列变换到一个新的数据序列
list [表达式 for 变量 in 列表] 或者 [表达式 for 变量 in 列表 if 条件]
list1 = [0.2123, 0.1, 0.5, 0.6,0.5,0.8]
list2 = map(lambda x:1/x,list1) //lambda 方式得到list1 元素的倒数
list3 = [1/x for x in list1] // 推导式看起来更加简单
multiples = [i for i in range(30) if i % 3 is 0] dict test = {'testone': 10, 'testtwo': 34} test_frequency = {v: k for k, v in test.items()} set 它跟列表推导式也是类似的。 唯一的区别在于它使用大括号{}。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/522af84bda03f5ecce622842a161f78b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4880c7bfb04e833ca0883abeb8dbe7/" rel="bookmark">
			解决Linux环境下使用sudo apt-get update命令时出现的文件下载失败问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主今天在deepin中使用命令：sudo apt-get update时出现了如下图的问题：
环境：deepin15.10.1（vmware15）
正文
一、问题分析
由于博主曾在deepin中安装过sublime text 3，而在安装时采用的是sublime text官网给出的利用GPG密钥安装的方法。
即安装GPG密钥：
wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add - 因此，博主猜测，这个密钥是本次问题出现的根本原因。此次由于某种原因，无法连接上sublime text官网，因此就出现了部分索引文件下载失败的问题。
二、解决方案
博主在查阅资料后得知，上图中出现的这些曾经因安装而导入deepin的密钥，会以文件的形式存放在/etc/apt/sources.list.d/目录下。
因此，问题的解决就很容易了，只需删除/etc/apt/sources.list.d/目录下出现问题的文件即可。
输入如下命令：
sudo rm /etc/apt/sources.list.d/sublime-text.list 重新执行命令：sudo apt-get update
至此，问题解决完毕。
PS:上述问题的出现，应该涉及到了debian、Ubuntu、deepin等系统的软件源问题。但由于博主才疏学浅，尚未了解到这些知识，所以博客中部分内容尚还存在纰漏。由于博主的原因，博客中用词不严谨部分给读者带来了不好的阅读影响，博主在此先行说声抱歉了。
Lin丶TX
2019.6.3 15.38
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0efdae329889ec79bc29e326d06167c3/" rel="bookmark">
			SQL语句 CASE WHEN的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 select Id , case when Id=1 then '等于1' when Id &gt;=60 then '大于60' --注意各结果的数据类型须一致，int和时间等不能转为字符串没出错 when Id &lt;60 then '小于60' else 'ok' end AS result , OwnId from ContentDetectionRecord 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9986cd5ca9655ce58b115169ec0e23ea/" rel="bookmark">
			Java读取、写入txt文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA读取、写入txt文件 1、读取
public String GetLogString(String logpath){	System.out.println("----------------开始读取日志----------------"); File logfile = new File(logpath+"\\log.txt"); String totalstr = ""; if(logfile.exists()){ try { FileReader fr = new FileReader(logfile); BufferedReader br = new BufferedReader(fr); String line = ""; while ((line = br.readLine()) != null){ //按行读取文件流的内容 totalstr = totalstr + line +",";	} fr.close(); br.close();	} catch (Exception e) { e.printStackTrace(); }	}else{ System.out.println("日志文件不存在"); } return totalstr; } 2、写入
实现功能：把一个json对象按行写入到txt文件中。
public void WriteNewLog(JSONArray jsonlog, String logpath){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9986cd5ca9655ce58b115169ec0e23ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13156bc997375d0f708bc227fc285f95/" rel="bookmark">
			隐马尔可夫模型(三)——鲍姆-韦尔奇算法(Baum-Welch算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题回顾 模型参数的学习问题。即给定观测序列O={o1,o2,…oT}，估计模型λ=(A,B,Π)的参数。这个问题的求解需要用到鲍姆-韦尔奇算法，我会在隐马尔可夫模型系列的第三篇博客中讲解，这个问题是HMM模型三个问题中最复杂的。
鲍姆-韦尔奇算法本质上就是EM算法，只不过它比EM算法出来的早，所以这里继续称它为鲍姆-韦尔奇算法。
二、监督学习算法求解模型参数 监督学习算法适用于观测序列和状态序列都已知的情况下，因为需要大量的训练数据，而人工标注训练数据的代价很高，所以该方法不是很常用。
假设训练数据为S对长度为 T 的状态序列 I = (i1, i2, … , iT)及其观测序列 O = (o1, o2, … , oT)组成的集合{(I1, O1), (I2, O3), … , (Is, Os)}，其中所有可能的状态集合为Q = {q1, q2, … , qN}，所有可能的观测集合为V = {v1, v2, … , vM}。
初始状态概率分布Π：
Π =[ πi ]N
取 I1 到 Is 这S个状态序列的 i1时刻的状态，组成一个长度为S的初始状态序列 C = (c11, c21, … , cs1)，其中ck1表示 Ik 这个状态序列在时刻 1 时的状态。
假设C( i )表示初始状态序列 C 中 状态 qi 出现的次数，则 πi 等于：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13156bc997375d0f708bc227fc285f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56500d0871617e4ae8db51cc89d10e6a/" rel="bookmark">
			带你阅读spring容器源码创建过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.引言 在java体系中，spring是一个非常出名的框架。它包含了很多东西，但是IOC容器是它的基本功能，这个不可不知。
二.spring容器加载方式 在spring中，主要有三种方式加载容器：
1.使用类路径加载配置文件
ClassPathXmlApplicationContext("bean.xml")
2.使用文件系统加载配置文件
FileSystemXmlApplicationContext("/opt/bean.xml") 3.使用注解方式加载
AnnotationConfigApplicationContext(SpringConfig.class); 在实际的使用中，随着spring-boot的流行，注解方式使用的越来越普遍。
三.注解加载过程 AnnotationConfigApplicationContext(SpringConfig.class); 代码断点跟进去
第一步: this()
创建给bean definition的解析器，其中里面会添加一个ConfigurationClassPostProcessor.class 后置处理器来加载系统配置.
第二步：register(annotatedClasses); 将该类注册到容器中
1）.需要判断该类是否有Primary.class,Lazy.class注解修饰
2）.添加bean的别名
第三步：refresh(); 创建容器
1）.prepareRefresh();刷新前的预处理
①.initPropertySources();留给子类来初始化一些环境属性变量
②.getEnvironment().validateRequiredProperties(); 验证环境属性变量
③.this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();
创建早期的事件集合
2）. obtainFreshBeanFactory() 获取bean工厂
①.refreshBeanFactory(); 刷新bean工厂，添加序列化id
②.getBeanFactory() 获取bean工厂 new了一个 DefaultListableBeanFactory()；
3）prepareBeanFactory(beanFactory); 在beanFactory中预初始化一些值
①.设置bean的类加载器
②.设置bean表达式的解析器
③.设置系统预定义的后置处理器,，比如ApplicationContextAwareProcessor
④.忽略一些自动装配的接口,比如EnvironmentAware,EmbeddedValueResolverAware
⑤.注册一些可解析的依赖类，BeanFactory,ResourceLoader,ApplicationEventPublisher....
⑥.添加事件的侦测器ApplicationListenerDetector
⑦.侦测是否有织入，有的话还要添加LoadTimeWeaverAwareProcessor 后置处理器
⑧.注册默认的系统环境bean environment,systemProperties,systemEnvironment
4）.postProcessBeanFactory(beanFactory);
在子类中重写该方法，可以自定义添加一些bean 的后置处理器,修改spring 容器上下文
5）invokeBeanFactoryPostProcessors(beanFactory); 调用bean工厂的后置处理器
①.加载BeanFactoryPostProcessor
1.找到实现了PriorityOrdered接口的后置处理器，排序，调用
2.找到实现了Ordered接口的后置处理器，排序，调用
3.找到没有实现上两个接口的后置处理器，调用
②.加载BeanDefinitionRegistryPostProcessor
1.找到实现了PriorityOrdered接口的后置处理器，排序，调用
2.找到实现了Ordered接口的后置处理器，排序，调用
3.找到没有实现上两个接口的后置处理器，调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56500d0871617e4ae8db51cc89d10e6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e32afdddf62d9dd79d4e433dc1d31d4/" rel="bookmark">
			Python求1&#43;2!&#43;3!&#43;...&#43;N!的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 def factorial(n): j = 1 for i in range(1,n+1): j *= i return j n = int(input()) s = 1 for k in range(2,n+1): s += factorial(k) print(s) 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/476/">«</a>
	<span class="pagination__item pagination__item--current">477/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/478/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>