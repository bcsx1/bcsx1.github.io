<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b091b2ab4af0afee247f503f30ab30/" rel="bookmark">
			PCB板表面处理镀金和沉金工艺的区别是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、PCB板表面处理 PCB板的表面处理工艺包括：抗氧化，喷锡，无铅喷锡，沉金，沉锡，沉银，镀硬金，全板镀金，金手指，镍钯金 OSP 等。
要求主要有：成本较低，可焊性好，存储条件苛刻，时间短，环保工艺，焊接好，平整 。喷锡：喷锡板一般为多层（4-46 层）高精密度 PCB 样板，已被国内多家大型通讯、计算机、医疗设备及航空航天企业和研究单位采用。
金手指（connecting finger）是内存条上与内存插槽之间的连接部件，所有的信号都是通过金手指进行传送的。
金手指由众多金黄色的导电触片组成，因其表面镀金而且导电触片排列如手指状，所以称为“金手指”，金手指板都需要镀金或沉金。
金手指实际上是在覆铜板上通过特殊工艺再覆上一层金，因为金的抗氧化性极强，而且传导性也很强。不过因为金昂贵的价格，目前较多的内存都采用镀锡来代替，从上个世纪 90 年代开始锡材料就开始普及。
目前主板、内存和显卡等设备的“金手指”几乎都是采用的锡材料，只有部分高性能服务器 / 工作站的配件接触点才会继续采用镀金的做法，价格自然不菲的。
二、镀金和沉金工艺的区别
沉金采用的是化学沉积的方法，通过化学氧化还原反应的方法生成一层镀层，一般厚度较厚，是化学镍金金层沉积方法的一种，可以达到较厚的金层。
镀金采用的是电解的原理，也叫电镀方式。其他金属表面处理也多数采用的是电镀方式。
在实际产品应用中，90%的金板是沉金板，因为镀金板焊接性差是他的致命缺点，也是导致很多公司放弃镀金工艺的直接原因！
沉金工艺在印制线路表面上沉积颜色稳定，光亮度好，镀层平整，可焊性良好的镍金镀层。基本可分为四个阶段：前处理（除油，微蚀，活化、后浸），沉镍，沉金，后处理（废金水洗，DI 水洗，烘干）。沉金厚度在 0.025-0.1um 间。
金应用于电路板表面处理，因为金的导电性强，抗氧化性好，寿命长，一般应用如按键板，金手指板等，而镀金板与沉金板最根本的区别在于，镀金是硬金（耐磨），沉金是软金（不耐磨）。
1、沉金与镀金所形成的晶体结构不一样，沉金对于金的厚度比镀金要厚很多，沉金会呈金黄色，较镀金来说更黄（这是区分镀金和沉金的方法之一），镀金的会稍微发白（镍的颜色）。
2、沉金与镀金所形成的晶体结构不一样，沉金相对镀金来说更容易焊接，不会造成焊接不良。沉金板的应力更易控制，对有邦定的产品而言，更有利于邦定的加工。同时也正因为沉金比镀金软，所以沉金板做金手指不耐磨（沉金板的缺点）。
3、沉金板只有焊盘上有镍金，趋肤效应中信号的传输是在铜层不会对信号有影响。
4、沉金较镀金来说晶体结构更致密，不易产成氧化。
5、随着电路板加工精度要求越来越高，线宽、间距已经到了 0.1mm 以下。镀金则容易产生金丝短路。沉金板只有焊盘上有镍金，所以不容易产成金丝短路。
6、沉金板只有焊盘上有镍金，所以线路上的阻焊与铜层的结合更牢固。工程在作补偿时不会对间距产生影响。
7、对于要求较高的板子，平整度要求要好，一般就采用沉金，沉金一般不会出现组装后的黑垫现象。沉金板的平整性与使用寿命较镀金板要好。
三、为什么要用镀金板
随着 IC 的集成度越来越高，IC 脚也越多越密。而垂直喷锡工艺很难将成细的焊盘吹平整，这就给 SMT 的贴装带来了难度；另外喷锡板的待用寿命（shelf life）很短。
而镀金板正好解决了这些问题：
1、对于表面贴装工艺，尤其对于 0603 及 0402 超小型表贴，因为焊盘平整度直接关系到锡膏印制工序的质量，对后面的再流焊接质量起到决定性影响，所以，整板镀金在高密度和超小型表贴工艺中时常见到。
2、在试制阶段，受元件采购等因素的影响往往不是板子来了马上就焊，而是经常要等上几个星期甚至个把月才用，镀金板的待用寿命（shelf life）比铅锡合 金长很多倍所以大家都乐意采用 。 再说镀金 PCB 在度样阶段的成本与铅锡合金板相比相差无几。
但随着布线越来越密，线宽、间距已经到了 3-4MIL。因此带来了金丝短路的问题： 随着信号的频率越来越高，因趋肤效应造成信号在多镀层中传输的情况对信号质量的影响越明显。
趋肤效应是指：高频的交流电，电流将趋向集中在导线的表面流动。 根据计算，趋肤深度与频率有关。
四、为什么要用沉金板
为解决镀金板的以上问题，采用沉金板的 PCB 主要有以下特点：
1、因沉金与镀金所形成的晶体结构不一样，沉金会呈金黄色较镀金来说更黄，客 户更满意。
2、因沉金与镀金所形成的晶体结构不一样，沉金较镀金来说更容易焊接，不会造成焊接不良，引起客户投诉。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1b091b2ab4af0afee247f503f30ab30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a4dadd073be51b3f74bbc00fcc31bb/" rel="bookmark">
			监控指标10K&#43;！携程实时智能检测平台实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文将介绍携程实时智能异常检测平台——Prophet。到目前为止，Prophet 基本覆盖了携程所有业务线，监控指标的数量达到 10K+，覆盖了携程所有订单、支付等重要的业务指标。Prophet 将时间序列的数据作为数据输入，以监控平台作为接入对象，以智能告警实现异常的告警功能，并基于 Flink 实时计算引擎来实现异常的实时预警，提供一站式异常检测解决方案。
本次分享主要分为四个方面：
一.背景介绍
二.Prophet
三.智能化与实时化
四.挑战与展望
重要：点击文末「阅读原文」可查看 Flink Forward Asia 本场演讲视频。
一、背景介绍
1.规则告警带来的问题
大部分监控平台是基于规则告警实现监控指标的预警。规则告警一般基于统计学，如某个指标同比、环比连续上升或下降到一定阈值进行告警。规则告警需要用户较为熟悉业务指标的形态，从而较为准确的配置告警阈值，这样带来的问题是配置规则告警非常繁琐、告警效果也比较差，需要大量人力物力来维护规则告警。
当一个告警产生时，也需要耗费许多人力验证告警是否正确并确认是否需要重新调整阈值。在携程，规则告警还涉及了其它问题，比如携程仅公司级别的监控平台就有三个，每个业务部门还会根据自己的业务需求或业务场景构建自己的监控平台。携程内部有十几个不同规模的监控平台，在每一个监控平台都配置监控指标，对于用户是非常繁琐的。
二、Prophet
针对规则告警存在的以上几种问题，携程构建了自己的实时智能异常检测平台—— Prophet。携程构建 Prophet 的灵感源于 FaceBook 的 Prophet，但实现上有别于 FaceBook 的 Prophet。
1.一站式异常检测解决方案
首先，Prophet 以时间序列类型的数据作为数据输入。其次，Prophet 以监控平台作为接入对象，以去规则化为目标。基于深度学习算法实现异常的智能检测，基于实时计算引擎实现异常的实时检测，提供了统一的异常检测解决方案。
2.Prophet 系统架构
底层：Hadoop 底层。YARN 作为统一资源调度引擎，主要用于运行 Flink 的作业。HDFS 主要用于存储训练好的 TensorFlow 模型。
引擎层：首先数据必须实时存在于消息队列当中，Prophet 使用的是 Kafka。此外，Prophet 使用 Flink 计算引擎实现实时异常预警，使用 TensorFlow 作为深度学习模型的训练引擎。同时 Prophet 基于时序数据库存储历史数据。
平台层：最上层是对外提供服务的平台层 Prophet。Clog 用于采集作业日志。Muise 是实时计算平台。Qconfig 用于存储作业中需要用到的配置项。Hickwall 用于作业的监控告警。
3.Why Flink？
目前主流的实时计算引擎有 Flink、Storm 和 SparkStreaming 等多种，携程选择Flink 作为 Prophet 平台的实时计算引擎的原因主要是Flink具备以下四点特征：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a4dadd073be51b3f74bbc00fcc31bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abbf2ff68712e9c704446403534f1786/" rel="bookmark">
			RippleNet基于知识图谱的推荐算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着知识图谱近几年越来越热门，用知识图谱进行推荐的想法也随之产生。知识图谱结构本质上是由（头实体，关系，尾实体）三元组组成的集合，并构成有向图。下图形象的表示了在电影领域用知识图谱做推荐的原理，左边是用户喜爱的电影，中间是这些电影在知识图谱中和右边几部电影的联系，我们可以看到左边的电影和右边的电影在知识图谱中呈现了很多种相似的关系。在知识图谱中发现这些相关物品对推荐系统具有十分重大的价值。RippleNet就这样诞生了。
RippleNet模型如下图所示。以用户感兴趣的物品作为起点，在知识图谱上经过多层扩散，相当于将用户的兴趣在知识图谱上传播，达到抽取用户的特征的目的，最后将用户的特征与物品的特征通过矩阵相乘得到推荐值。
tensorflow2代码实现：https://github.com/SSSxCCC/Recommender-System
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31cefac4b38023efa9132b10bbe17269/" rel="bookmark">
			MKR基于知识图谱的推荐算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MKR推荐算法是一种基于知识图谱的推荐算法。它利用推荐模型和知识图谱嵌入模型交替学习来提升推荐质量。如下图a是MKR的模型结构。左半部分是推荐模型部分，其结合了传统的矩阵分解和深度神经网络多层感知机，来输出一个推荐值。右半部分是知识图谱嵌入模型部分，通过知识图谱三元组关系的头实体和关系来预测尾实体。
左右两个模型是通过中间的交叉压缩单元（cross&amp;compress units）连到一起。其结构如下图b所示。通过交叉压缩单元，将知识图谱领域的实体嵌入和推荐系统领域的物品嵌入连接起来，相互作用相互影响，互相促进训练过程，这也是一种迁移学习（transfer learning）的思想。
tensorflow2代码实现：https://github.com/SSSxCCC/Recommender-System
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1ad106d5ca42a2e3a3c33516af4e0d5/" rel="bookmark">
			Ubuntu 修改启动时默认内核版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近机房总是停电，每次停完电我就需要去手动重启一下改一下我需要的内核版本，太过麻烦，一周恨不得停八次电。。。。
目前 Ubuntu 的默认启动版本为 4.15.0，我想将其修改为4.15.0-45-generic
需要修改的目标文件： sudo /etc/default/grub 修改默认启动的内核 GRUB_DEFAULT=0 即为默认的启动内核，这个 0 是啥。。。
假设，在启动选择内核时， “Advananced options for Ubuntu” 的子菜单如下所示：
Ubuntu, with Linux 4.13.0-26-generic Ubuntu, with Linux 4.13.0-26-generic (upstart) Ubuntu, with Linux 4.13.0-26-generic (recovery mode) Ubuntu, with Linux 4.10.0-42-generic Ubuntu, with Linux 4.10.0-42-generic (upstart) Ubuntu, with Linux 4.10.0-42-generic (recovery mode) 第一个 Ubuntu, with Linux 4.13.0-26-generic 选项是索引就是 0，第二个是1，第三个是2，依此类推。（即GRUB菜单中的 Ubuntu为0，Advanced options for Ubuntu为1，…）
那我记不住我想要的内核是第几个咋弄。。。 那就直接改名字吧
我刚开始改成了这样
GRUB_DEFAULT="Ubuntu, with Linux 4.15.0-45-generic" 更新配置 sudo update-grub 然而，出现了以下 warning，那感情好啊，直接告诉了我应该改成啥了，在重新改一下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1ad106d5ca42a2e3a3c33516af4e0d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182bfadd9b3a004d0eb4c27b82a24ea5/" rel="bookmark">
			vue项目动态创建表格（模板字符串&#43;递归&#43;scss）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据后端数据（数据格式为多层嵌套数组）动态创建一行对多行的表格 效果图 html代码 如果表头也是后端数据动态加载，可用for循环 js代码 mounted: function () { this.oppd() }, methods: { oppd() { let html = this.createTab(this.table1) let tbody = document.getElementById('mytable') tbody.innerHTML = this.html }, createTab(arr) { //使用模板字符串+递归 this.html += '&lt;table style="width: 100%;"&gt;' for (let i = 0; i &lt; arr.length; i++) { let item = arr[i]; this.html += '&lt;tr&gt;' this.html += `&lt;td class="w200"&gt;${item.name}&lt;/td&gt;` this.html += `&lt;td class="w200"&gt;${item.sore}&lt;/td&gt;` this.html += '&lt;td class="w200" colspan="12"&gt;'; if (item.children &amp;&amp; item.children.length) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/182bfadd9b3a004d0eb4c27b82a24ea5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960d89d5b61cb4ad8bef5baac388496c/" rel="bookmark">
			判断按键输入代码及 vk 键值对应表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅做个笔记，以防丢失
#define KEY_DOWN(vk_code) GetAsyncKeyState(vk_code) &amp; 0x8000 ? 1 : 0 //用于判断按键输入 用法简示：
if (KEY_DOWN(VK_UP)) { KeyState = K_Up; } VK_NUMPAD0 到 VK_NUMPAD9 表示键盘上数字“ 0 ”到“ 9 ”键 (ASCII 码为 0x30 - 0x39)或(0x60-0x69) ；
VK_A 到 VK_Z 表示键盘上字母“ A ”到“ Z ”键 (ASCII 码为 0x41 - 0x5a) 或(0x41-0x5a)；
VK_ADD 表示数字键盘上的“ + ”键。
VK_MENU 表示键盘上 “ ALT ”键。
VK_BACK_QUOTE 表示键盘上 “ ` ”键。
VK_BACK_SLASH 表示键盘上 “ \ ”键。
VK_BACK_SPACE 表示键盘上 “ BACKSPACE “键。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/960d89d5b61cb4ad8bef5baac388496c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b0601631a327c723f28c659d1d1e3f7/" rel="bookmark">
			Day01 HTML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML 回顾 第一周: 1 java基础：变量、常量、数据类型、运算符 2 选择语句 if switch、循环语句 while do...while for 3 方法 方法的声明、调用、递归算法 第二周: 1 数组：一维数组、二维数组 属于引用类型 栈 堆 工具类 Arrays 2 面向对象: 封装 继承 多态 3 抽象类和接口 4 内部类和设计模式 5 常用类和异常 第三周: 1 String类 2 集合 List Set Map 3 IO 字节流 字符流 输入流 输出流、缓冲流、对象流 第四周: 1多线程 、线程同步 synchronized Lock接口 ReentrantReadWriteLock wait notify notifyAll 2网络编程 TCP UDP IP 3反射 今日内容 1、html简介 2、html基本标签 3、html基本标签的综合案例 4、html表单标签 5、html的框架标签 6、html的其它标签和特殊字符 教学目标 1、掌握html的书写规范 2、掌握html的基本标签9个 3、掌握html的表单标签 4、了解html的框架标签 5、掌握html标签的综合使用 课前简介 网页，是网站中的一个页面，通常是网页是构成网站的基本元素，是承载各种网站应用的平台。通俗的说，网站就是由网页组成的。 通常我们看到的网页都是以htm或html后缀结尾的文件，俗称 HTML文件。 第一节 HTML简介 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b0601631a327c723f28c659d1d1e3f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67c5eb7c00cf39f7c0c206aef09751b1/" rel="bookmark">
			解决sudoers权限问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前面一篇文章说到，sudo 操作免密码验证等，最好先切换到 root 用户，再进行编辑，最后强制保存。如果不这么做，而使用 chmod 来更改权限，就会导致之后的 sudo 操作全部被拒绝。
问题与解决 问题是这样的，我需要编辑 /etc/sudoers 文件，想让当前用户使用 sudo 操作可以免密码验证，但是保存不了，一直提示文件是只读的，:wq! 强制保存也不行，提示文件不属于当前用户所拥有。
于是敲了一句 chmod：
$ sudo chmod a+w /etc/sudoers
修改了 /etc/sudoers 的权限，再用 sudo 命令的时候，必定会出现报错：
sudo: /etc/sudoers is owned by uid 501, should be 0 sudo: no valid sudoers sources found, quitting 501 是我当前登录的用户 bingo，而 0 应该是 root 用户。 网上的解决方案是进入 recovery mode，将 sudoers 的权限修改回来。但我不相信必须要这么做，想先尝试看能不能改得回来。
于是将 /etc/sudoers 的 owner 和组，修改为 admin:
$ chown root:admin /etc/sudoers 执行这一句命令时出现一个报错：
$ chown: /etc/sudoers: Operation not permitted 那这就很尴尬了，sudo 本来就已经不能用了，怎么办？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67c5eb7c00cf39f7c0c206aef09751b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d2227142284ed6b56b6cab9d33f2b6/" rel="bookmark">
			hive中两种日期格式的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在解析埋点数据时会遇到两种不同的日期格式：yyyymmdd和yyyy-mm-dd，此类型之间的转换主要有两种思路：
第一种方法：from_unixtime+unix_timestamp
–20180905转成2018-09-05
select from_unixtime(unix_timestamp(‘20180905’,‘yyyymmdd’),‘yyyy-mm-dd’)
from dw.ceshi_data
–结果如下：
2018-09-05
–2018-09-05转成20180905
select from_unixtime(unix_timestamp(‘2018-09-05’,‘yyyy-mm-dd’),‘yyyymmdd’)
from dw.ceshi_data
–结果如下：
20180905
第二种方法：substr + concat
–20180905转成2018-09-05
select concat(substr(‘20180905’,1,4),’-’,substr(‘20180905’,5,2),’-’,substr(‘20180905’,7,2)) from dw.ceshi_data
结果如下：
2018-09-05
–2018-09-05转成20180905
select concat(substr(‘2018-09-05’,1,4),substr(‘2018-09-05’,6,2),substr(‘2018-09-05’,9,2)) from dw.ceshi_data
结果如下：
20180905
下面主要讲解from_unixtime和unix_timestamp两种函数：
from_unixtime：时间戳转日期函数
用法：from_unixtime(bigint unixtime[, stringformat])
返回值: string
说明: 转化时间戳到当前时区的时间格式
select from_unixtime(1423306743,‘yyyyMMdd’)
from dw.ceshi_data;
结果如下：
20150207
unix_timestamp:日期转时间戳函数
用法:unix_timestamp(string date)
返回值: bigint
说明: 转换格式为“yyyy-MM-dd HH:mm:ss“的日期到UNIX时间戳。如果转化失败，则返回0。
select unix_timestamp(‘2018-09-05 12:01:03’)
from dw.ceshi_data;
结果如下：
1536120063
–获取当前日期的时间戳：
select unix_timestamp()
from dw.ceshi_data;
结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d2227142284ed6b56b6cab9d33f2b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dacdc80fda204f70aae14301c2654df3/" rel="bookmark">
			zip压缩脚本（linux）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.上代码
#!/bin/bash # 压缩文件脚本 # 设置距离当前日期的开始和结束的天数 start_num=1179 end_num=1178 dir=/home/oracle/oradata_1t for ((j=$start_num; j&gt;=$end_num; j--)) do #获取以前的时间，格式：20180313 yyyymmdd=$(date -d "$j days ago" +%Y%m%d) yyyymm=$(date -d "$j days ago" +%Y%m) yyyy=$(date -d "$j days ago" +%Y) echo 'start...date:'$yyyymmdd source_folder_file=$dir'/'$yyyy'/'$yyyymmdd'/'$yyyymmdd'.log' zip_source_folder_file=$dir'/'$yyyy'/'$yyyymm'/t_mt_'$yyyymmdd'_log.zip' # 判断要压缩的文件是否存在，如果存在则进行压缩操作 if [ -f "$source_folder_file" ] ; then #压缩文件 zip -rj $zip_source_folder_file $source_folder_file #删除文件 rm -rf $source_folder_file rm -rf $dir'/'$yyyy'/'$yyyymmdd else echo '压缩文件不存在'$source_folder_file fi done 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658603822d4a758ad09d875841f0cb29/" rel="bookmark">
			7-3 计算平均成绩 (15分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定N个学生的基本信息，包括学号（由5个数字组成的字符串）、姓名（长度小于10的不包含空白字符的非空字符串）和成绩（[0,100]区间内的整数），要求计算他们的平均成绩，并顺序输出平均线以下的学生名单。
输入格式：
输入在一行中给出正整数N（≤10）。随后N行，每行给出一位学生的信息，格式为“学号 姓名 成绩”，中间以空格分隔。
输出格式：
首先在一行中输出平均成绩，保留2位小数。然后按照输入顺序，每行输出一位平均线以下的学生的姓名和学号，间隔一个空格。
输入样例：
5
00001 zhang 70
00002 wang 80
00003 qian 90
10001 li 100
21987 chen 60
输出样例：
80.00
zhang 00001
chen 21987
错误示范：
#include&lt;stdio.h&gt; struct student{ char num[10]; char name[10]; int score; }; int main (){ struct student A[10]; int n,i,sum=0; scanf("%d\n",&amp;n); for(i=0;i&lt;n;i++){ scanf("%s%s%d",A[i].num,A[i].name,&amp;A[i].score); sum+=A[i].score;} float average; average=((float)sum)/n; int flag=0; printf("%.2f\n",average); for(i=0;i&lt;n;i++){ if(A[i].score&lt;average&amp;&amp;flag==0){ printf("%s %s",A[i].name,A[i].num); flag++; } else if(A[i].score&lt;average){ printf("\n"); printf("%s %s"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658603822d4a758ad09d875841f0cb29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b5056b86d6ba8734cb9306d094fc1b/" rel="bookmark">
			UE4-（蓝图）第一百零九课 流程控制蓝图节点（循环、延时节点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果在循环体进行大量复杂的运算，游戏就会在当前帧卡住，直到循环结束才会执行下一帧。
一、Switch节点
Switch可以在所有枚举类型（包括自定义枚举）上使用
二、Branch 分支节点
三、延时
Delay：指定一个延时的时间进行一次操作，倒计时过程中再次调用无效（时间不会被重置）
Retriggerable Delay：可重新触发延时时间进行一次操作，倒计时过程中再次调用倒计时时间将重置为 设置的时间
四、DoOnce：每次只执行一次，再次调用不会执行，除非还原后再调用。可以设置DoOnce初始是不是关闭状态，如果StartClosed勾选，只能先调用还原再调用执行。
示例：第一次按1，屏幕会打印“Hello”字符串，再按一次1不会打印“Hello”（被DoOnce阻挡了），按一下2重置DoOnce，再按一下1，则又会打印“Hello”
五、DoOnce MultiInput，接受多个输入，但是只调用对应输入的执行命令一次，在调用其他的输入命令不会执行逻辑，重置命令调用后，才可以再次调用输入命令
示例：按键A调用打印A，按键B调用打印B，按键R重置命令，
结果：按了A键会打印字符“A”，再按B键，不会打印，除非按R键重置。
六、DoN：做n次（n是自己设置的次数），Counter从1开始计数，重置后重新变为1，做完N次后不再做，重置后才可以做。
七、FlipFlop：翻转，一个输入，交替执行。（A,B交替打印）
八、For Loop：当条件“First Index &lt;= Index &lt;= Last Index” 条件成立时，循环执行Loop Body后面的代码（循环体），否则就执行Completed后面的代码（跳出循环体）。
九、ForLoopWithBreak：可以被打断的循环
如果被打断，执行Completed。如果没有被打断，当循环完成后执行Completed
十、Gate：门。
1.Enter 可以连接键盘输入或任何事件
2.Enter 相当于一把钥匙，前提是open要打开的状态才能执行exit后面的蓝图
3.open相当于一个门需要被开启，但是还需要一把钥匙
4.close相当于一个门不能被开启，无论有没有这把钥匙都不能开启。
5.Toggle开门和关门交替
6.Start Closed：默认状态下门的状态是关闭的
十一、MultiGate：多个出门口，
Loop：勾选后，从0到2重复循环执行，如果不勾选Loop，挨个执行，等到所有出口都被执行过后，不再执行，除非Reset。
IsRandom：随机挑选一个门作为出口执行，如果不勾选Loop，随机选择，并且执行过的出口不会被再次执行。直到所有的出口都被执行后，不再执行，除非Reset
Loop与IsRandom都勾选，随机挑选出口，次数没有上限。
Start Index ：指定第一个出门口的角标。如果越界，会在运行的时候提示错误信息。
十二、WhileLoop：只要节点调用执行，就一直循环判断条件，条件为true时一直执行LoopBody中的逻辑，条件为false执行Completed中的逻辑
注意：很可能导致无限循环，使系统报错或者崩溃，使用时要注意。
十三、Sequence 序列节点
十四、Select选择节点
如果执行逻辑中只有参数不同，但是使用switch后所执行的方法是重复的，就可以使用Select节点代替switch
如：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e128d1560d83bc3fc76e11fe7dae1727/" rel="bookmark">
			B1030 完美数列 (25分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】 给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。
现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
【输入格式】 输入第一行给出两个正整数 N 和 p，其中 N（≤10​5​​）是输入的正整数的个数，p（≤10​9​​）是给定的参数。第二行给出 N 个正整数，每个数不超过 10​9​​。
【输出格式】 10 8
2 3 20 4 5 1 6 7 8 9
【题目信息】 作者: CAO, Peng
单位: Google
时间限制: 200 ms
内存限制: 64 MB
代码长度限制: 16 KB
【思路及特别注意点】 tip1:有0到5号共6个监测点，其中4号5号监测点易出现问题。
tip2:关于运行超时。4号监测点主要是检测算法的时间复杂度，看你写的程序是否运行超时，出现运行超时问题主要是在检测是否是完美数列的时候用了顺序查找，如果用顺序查找（时间复杂度达到O(n)）监测点4一定过不去，此时可以选择使用折半查找(时间复杂度为O(logn))这题监测点4我一共用了75ms。
tip3:关于数据存储格式。如果选择int作为基本数据的存储格式，监测点0-4都可以通过，可以得到23/25分的成绩，而监测点5过不去，因为两个数相乘可能超出int型数据所能表示的范围，所以可以改用long存储数据。
tip4:拓展知识。表示一种数据类型所用的字节数与计算机架构和编译器有关，笔者的机器是64位所用编译器为c++（g++），此时int占4字节，long占8字节。
【代码】 #include&lt;algorithm&gt; #include&lt;iostream&gt; using namespace std; //B1030 //2019-12-26 //11:42a.m. //用时：50min int main(){ long nums[100000],N,p; int i,j,k,maxlen=1,curlen=1; cin&gt;&gt;N&gt;&gt;p; for(i=0;i&lt;N;i++) cin&gt;&gt;nums[i]; sort(nums,nums+N); for(i=0;i&lt;N-1;i++){ //M&lt;=m*p; 计算最长完美序列 long minnum=nums[i]*p; int left=i+1,right=N,mid; for(;left&lt;=right;){ mid=(left+right)/2; if(nums[mid]&lt;=minnum) left=mid+1; else right=mid-1; } curlen=mid-i; if(maxlen&lt;curlen) maxlen=curlen; } cout&lt;&lt;maxlen; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bd324d1fe39c95abf4dae0cce1d3e07/" rel="bookmark">
			Python小数相加的坑：加出来等于.9999999一大串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近做数据处理，遇到了Python中小数的这种问题，写出来当做笔记。 代码： x = 6.2 + 0.1 print(x) x = 6.3 + 0.1 print(x) 第一个输出6.3 是没有任何问题的，但是第二个本应该是6.4。但是出来的却是一大串，这个比较令我困惑。后面发现其实就是Python的数据类型问题。解决方式如下：
方式1： x = Decimal('6.3') + Decimal('0.1') print(x) 方式2： x = "%.1f" % (6.3+0.1) print(x) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c73e0f0401b7b463d165c94ba0445f73/" rel="bookmark">
			golang引用自定义模块（类似java的maven）——github版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在golang中，可以通过 go mod的mod文件中添加依赖，依赖其他模块。这些模块既可以是来自第三方的模块，也可以是来自自己的模块。
例如：
下面代码的含义是 模块foolDealer 依赖模块 github.com/google/wire 和 github.com/wild46cat/golib
module foolDealer go 1.13 require github.com/google/wire v0.4.0 require github.com/wild46cat/golib v0.0.0-20191224150240-e041ab0d7835 首先说一下，这里的wire模块是google的模块，而golib模块，是我自己写的模块，方便自己调用。
好，下面上货。讲解一下如何处理golang的模块
1、首先新建一个项目golib，用于存储自己的公共代码。
需要注意的是，这里的module的名称应该是 github.com/wild46cat/golib
module github.com/wild46cat/golib go 1.13 2、上传到github上。
3、新建一个测试项目foolDealer
在测试项目的go.mod文件中添加依赖
require github.com/wild46cat/golib latest 注意，这里如果不清楚有什么版本，可以直接用latest代替。
然后执行命令
go mod vendor go mod download go mod tidy 执行后，能够看到，会出现一个vendor文件夹（当然，代码中应该有对应的import "github.com/wild46cat/golib/utils"）。
4、查看当前go.mod文件中是否发生了变化
module foolDealer go 1.13 require github.com/google/wire v0.4.0 require github.com/wild46cat/golib v0.0.0-20191224150240-e041ab0d7835 5、在代码中引用能够使用
package src import ( "github.com/google/wire" "github.com/wild46cat/golib/utils" "sync" ) func main() { wire.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c73e0f0401b7b463d165c94ba0445f73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97109d765f83fd40cb9baecfd15b0e22/" rel="bookmark">
			基于C#的AE二次开发之通过点击地图窗口计算面要素面积并显示（ITopologicalOperator）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于C#的AE二次开发之通过点击地图窗口计算面要素面积并显示 我的开发环境为ArcGIS Engine 10.2与Visual studio2010。主地图名称为axMapControl1。创建主地图的OnMouseDown来实现面状要素面积的计算，面状要素类必须经过投影（采用投影坐标系，而不是地理坐标系），否则计算出来的面积有误！（注意相关事件的添加与动态链接库的引入）
效果预览：
实现代码
private void axMapControl1_OnMouseDown(object sender, IMapControlEvents2_OnMouseDownEvent e) { try { //实例化一个点，以该点作拓扑算子，将点击的位置坐标赋予pPoint IPoint pPoint = new ESRI.ArcGIS.Geometry.Point(); ITopologicalOperator pTopologicalOperator = pPoint as ITopologicalOperator; pPoint.PutCoords(e.mapX, e.mapY); //以缓冲半径为0进行缓冲 得到一个点 IGeometry pGeometry = pTopologicalOperator.Buffer(0); //以该点进行要素选择（只能选中面状要素，点和线无法选中） axMapControl1.Map.SelectByShape(pGeometry, null, false); //刷新视图 axMapControl1.Refresh(esriViewDrawPhase.esriViewGeoSelection, null, null); // 获取选择集 ISelection pSelection = axMapControl1.Map.FeatureSelection; // 打开属性标签 IEnumFeatureSetup pEnumFeatureSetup = pSelection as IEnumFeatureSetup; pEnumFeatureSetup.AllFields = true; // 获取要素 IEnumFeature pEnumFeature = pSelection as IEnumFeature; IFeature pFeature = pEnumFeature.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97109d765f83fd40cb9baecfd15b0e22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a99e5ea9ce940c836795e1e252ddf95/" rel="bookmark">
			【学习总结】使用Swagger实现API规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【学习总结】使用Swagger实现API规范 1. 建立一个springboot工程
2. 建立实体类
3. 建立数据库并链接数据库，进行增删改查编写
4. 为工程增加swagger配置
5. 请求页面，显示结果
代码如下
1、建立工程
2、建立实体类
import io.swagger.annotations.ApiModel; import lombok.Data; import javax.persistence.*; @Data @Table(name = "classes") @ApiModel(value = "com.lxc.swagger.entity.Classes", description = "班级字段特征") public class Classes { @Id @Column(name = "id") @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id;//班级编号 private int studentNumbers;//学生人数 private String major;//专业 private String college;//所属学院 } 1、建立数据库链接，这里采用的是mysql
2、进行增删改查设置，这里使用fastmybatis
pom导入
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a99e5ea9ce940c836795e1e252ddf95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e483e5f7304a1d881f164e33a323f28/" rel="bookmark">
			vue  使用js  XLSX读取 excel 转换日期格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近要实现一个功能，大概就是前端读取excel 文件，excel内容展示在页面上，用户确认无误后再上传至后端，使用的XLSX来解析excel,读取日期的时候是数字，解决这个问题花了蛮久时间，记录一下
xlsx 官方github
1.首先要 安装 XLSX
npm install xlsx npm install moment 2.再导入
import XLSX from 'xlsx' import moment from 'moment' 3.用的是element-ui 的 el-upload组件上传，绑定upload
upload (file, fileList) { let files = {0: file.raw} this.readExcel1(files) } 4.读取excel，日期格式需要加上 cellDates: true 参数， el-table-column 需要显示的时候也要格式化
readExcel1 (files) { // console.log(files) if (files.length &lt;= 0) { return false } else if (!/\.(xls|xlsx)$/.test(files[0].name.toLowerCase())) { this.$Message.error('上传格式不正确，请上传xls或者xlsx格式') return false } const fileReader = new FileReader() fileReader.onload = (ev) =&gt; { try { const data = ev.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e483e5f7304a1d881f164e33a323f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d22f6db9d4142eb438776d19c52bcd/" rel="bookmark">
			TPS和QPS区别与计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QPS/TPS简介： QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。
TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。
QPS ： QPS ： 侧重于服务器处理请求的能力（偏向于开发)，即一秒内可以处理的请求数量称之为服务器的QPS；
假设在分布式服务中，其中单台订单服务器一次性（并发）可以处理100个下单请求，每个下单请求耗时 50毫秒：
QPS = ( 1秒 / 单个请求耗时) * 并发数 = (1000/50) * 100 = 2000
Tps： TPS： 侧重于服务器集群对单个业务的处理能力，是整个服务器集群对某个业务的处理能力,也是衡量一个系统能否满足当前市场需要的重要标准之一
假设某个购物系统，一次购买的操作，涉及到：
1） 账户系统扣钱；
2） 订单系统下订单；
3） 发货系统组织发货；
那么这个过程中产生了一个 TPS， 三个系统各产生了一个QPS
TPS 受单个服务的QPS、网络传输、磁盘IO、服务并发、集群数量 等等的影响。
补充： 在软件开发运营中，通常还有 PV、UV、IV 关键词：
pv访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。IV是IP访问数指独立IP访问数，计算是以一个独立的IP在一个计算时段内访问网站计算为1次IP访问数。在同一个计算时段内不管这个IP访问多少次均计算为1次。计算时段有以1天为一个计算时段，也有以1个小时为一个计算时段。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17229c7d80e43fa76b54d96ef86e4a4e/" rel="bookmark">
			reverse函数实现逆置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vector的逆置
#include&lt;vector&gt; #include&lt;algorithm&gt; int main(){ std::vector&lt;int&gt; nums; std::reverse(nums.begin(),nums.end()); return 0; } string的逆置
int main(){ sting str; cin&gt;&gt;str; reverse(str.begin(),str.end()); return 0; } 反转字符数组
int main(){ char a[100]; cin.getline(a,sizeof(a)); int m=strlen(a); reverse(a,a+m); return 0; } 自己实现reverse函数
void reverse(vector&lt;int&gt; &amp;nums){ for(int i=0;i&lt;nums.size()/2;i++){ swap(nums[i],nums[nums.size()-i-1]); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bc2c61a68939a8b516830e94a7aa9a/" rel="bookmark">
			Error processing condition on org.springframework.boot.autoconfigure.data.web.XXX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在尝试使用Redis存储用户信息的时候,加入Redis依赖并编码之后,SpringBoot项目启动报错如下:
1) 添加依赖:
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2. 添加配置文件::在resource下新建conf.之后新建redis配置文件
#Matser的ip地址 redis.hostName=localhost #端口号 redis.port=6379 #如果有密码 #redis.password=123456 #客户端超时时间单位是毫秒 默认是2000 redis.timeout=10000 #最大空闲数 redis.maxIdle=300 #连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal #redis.maxActive=600 #控制一个pool可分配多少个jedis实例,用来替换上面的redis.maxActive,如果是jedis 2.4以后用该属性 redis.maxTotal=1000 #最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。 redis.maxWaitMillis=1000 #连接的最小空闲时间 默认1800000毫秒(30分钟) redis.minEvictableIdleTimeMillis=300000 #每次释放连接的最大数目,默认3 redis.numTestsPerEvictionRun=1024 #逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1 redis.timeBetweenEvictionRunsMillis=30000 #是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个 redis.testOnBorrow=true #在空闲时检查有效性, 默认false redis.testWhileIdle=true 3.创建redis配置类*:
@Configuration @AutoConfigureAfter(RedisAutoConfiguration.class) public class RedisConfig { //Redis配置文件需要序列化 @Bean public RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate(LettuceConnectionFactory redisConnectionFactory) { RedisTemplate&lt;String, Serializable&gt; template = new RedisTemplate&lt;&gt;(); template.setKeySerializer(new StringRedisSerializer()); template.setValueSerializer(new GenericJackson2JsonRedisSerializer()); template.setConnectionFactory(redisConnectionFactory); return template; } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bc2c61a68939a8b516830e94a7aa9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33abb22acf60a8f017acbeba5f06c095/" rel="bookmark">
			keil提示：missing &#39;;&#39; before &#39;xxx&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		然鹅并找不到哪里少了分号
可能是alarm的问题，故将包含 alarm的头文件包含进来，解决问题
一般这个报错不是缺少分号，是定义那行有些类型头文件识别不了，keil报这个错误。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/260c0aaadab1366825948b3b65d0fa95/" rel="bookmark">
			栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.栈 栈：一种特殊的线性表，其只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。
栈中的数据元素遵守后进先出LIFO（Last In First Out）的原则。
压栈：栈的插入操作叫做进栈/压栈/入栈，入数据在栈顶。
出栈：栈的删除操作叫做出栈。出数据也在栈顶。
栈的实现 栈的实现一般可以使用数组或者链表实现，相对而言数组的结构实现更优一些。因为数组在尾上插入数据的代价比较小。
2.队列 队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有先进先出 FIFO(First In First Out) 原则。
入队列：进行插入操作的一端称为队尾
出队列：进行删除操作的一端称为队头
队列的实现 队列也可以利用数组和链表的结构实现，使用链表的结构实现更优一些，因为如果使用数组的结构，出队列在数组头上出数据，效率会比较低。
循环队列 实际中我们有时还会使用一种队列叫循环队列。如操作系统课程讲解生产者消费者模型时可以就会使用循环队列。环形队列可以使用数组实现，也可以使用循环链表实现。
栈与队列实现代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502946fe8df1603f48d4a837b293f8b8/" rel="bookmark">
			Oracle 11g/12c/19c单机自动安装脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash
#Creation Data: 2019-06-26
#Last-Modified Date: 2020-06-05
#Author: Create by xiaoxuesong
#Mail: xiaoxuesong@longigroup.com
#Function: Oracle 11g/12c/19c install on Linux 6/7(oracle linux &amp;&amp; redhat)
#version: 1.0 初版编写
#version: 1.1 加入判断是否归档模式，修改一些bug
#version: 1.2 加入安装目录判断，增加一些注释
#version: 1.3 加入字符集判断，设置默认字符集为AL32UTF8；丰富安装日志;增加GLOBLE_DBName环境变量;修改一些bug
#version: 2.0 判断OS版本，增加Linux 7的安装;判断DB版本，增加12.2.0.1的安装
#version: 3.0 使用function重构代码；增加安装判断；增加国家字符集判断；调整依赖的rpm包；自动判断OS版本；增加内存百分比设置参数；修改linux7 hostname目录；设置审计为none；设置DB密码不过期
#version: 3.1 修改一些配置项
#version: 3.2 增加了yum配置选项
#version: 4.0 增加19c安装配置，增加OS配置
#--可以完善的内容
#version: X 初始化变量输入时，加入不合理变量判断（比如判断Oracle_SID是否超过8个字符、密码合规性检查）
# 判断是否创建CDB
#Readme ：需要准备和确认的事情
#1，修改主机名/etc/sysconfig/network(linux6) 或者 /etc/hostname(linux7)
#2，软件安装路径和数据文件路径要提前规划好
#3，软件安装会自动下载到/tmp目录
#4，准备好yum源、NTP配置文件
#5，准备好监控脚本
#6，脚本必须放在Oracle用户有权访问的位置下执行，如/tmp目录
#****************************************************************************************************************#
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/502946fe8df1603f48d4a837b293f8b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c06ae7973f7f6e1bb113baace68a87d0/" rel="bookmark">
			数字图像处理（四）——Matlab实现图像几何变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验内容 已知3×3的图像如图所示：
A、将此图以图形中心为轴顺时针旋转30度。
B、将此图放大二倍。
C、对此图作水平镜像。
D、对此图作垂直方向的错切。
1.1使用matlab制作出题目所要求的图形。 定义一个a=zeros(300,300,3)的三维矩阵，用for循环对该矩阵中的每个像素点进行赋值运算，给出不同的值作为该图像每个像素点的灰度级，生成的图像如图所示：
1.2将此图以图形中心为轴顺时针旋转30度。 首先定义旋转角度为pi/6，即三十度，其次算出旋转后图像的矩阵大小，得到旋转后图像的长和宽，然后利用两个for循环遍历旋转后图像中的每个像素点，先将旋转中心移至原点，然后利用逆矩阵得到旋转后图像的坐标x和y在原图像中的坐标点x0、y0，由于在原图像中的坐标可能出现小数，因此利用最邻近插值算法对x0、y0进行四舍五入取整运算，然后再将旋转中心移至左上角，得到旋转后的图像如图所示：
过观察可发现旋转后的图像在边界处出现了不同程度的凹凸不平的噪声点，这是由于在处理旋转后图像坐标映射到原图坐标时太过于粗糙所导致的，此时采用双线性插值算法，让处理更为精细，处理后的图像如图所示：
1.3将此图放大二倍。 图像放大与图像旋转类似，都是遍历变换后的图像每个像素点，然后在原图中找出对应的像素点坐标，同样用最邻近插值放大后的图像如图所示：
1.4对此图作水平镜像与垂直方向的错切 水平镜像即将y方向的坐标作对称变换即可，垂直方向的错切则是对y方向的坐标点进行变换，变换后的图像如图所示：
实验代码附录如下： clc close all a=zeros(300,300,3); %% %生成图像 for i=1:100 for j=1:100 a(i,j,2)=50; a(i,j,1)=0; a(i,j,3)=0; end end for i=100:200 for j=200:300 a(i,j,2)=50; a(i,j,1)=0; a(i,j,3)=0; end end for i=200:300 for j=1:200 a(i,j,2)=50; a(i,j,1)=0; a(i,j,3)=0; end end for i=1:100 for j=100:300 a(i,j,1)=255; a(i,j,2)=255; a(i,j,3)=255; end end for i=100:200 for j=1:200 a(i,j,1)=255; a(i,j,2)=255; a(i,j,3)=255; end end for i=200:300 for j=200:300 a(i,j,1)=255; a(i,j,2)=255; a(i,j,3)=255; end end figure; imshow(a); %% %图像旋转 row=300; col=300; dushu= pi/6; %旋转角度 row1 = round(abs(row*cos(dushu)) + abs(col*sin(dushu))); %旋转后大小 col1 = round(abs(col*cos(dushu)) + abs(row*sin(dushu))); I1 = zeros(row1, col1,3); for i = 1:row1 for j = 1:col1 c = i - row1/2; %将旋转中心移至原点 d = j - col1/2; x = c*cos(dushu) - d*sin(dushu); %旋转 y = d*cos(dushu) + c*sin(dushu); x = round(x + row/2); %将所需图像移至坐标系正值部分 y = round(y + col/2); if x &gt; 0 &amp;&amp; x &lt;= row &amp;&amp; y &lt;= col &amp;&amp; y &gt; 0 I1(i,j,1) = a(x,y,1); I1(i,j,2) = a(x,y,2); I1(i,j,3) = a(x,y,3); end end end figure; imshow(I1); %% %使用双线性插值处理 row=300; col=300; dushu= pi/6; %旋转角度 row1 = round(abs(row*cos(dushu)) + abs(col*sin(dushu))); %旋转后大小 col1 = round(abs(col*cos(dushu)) + abs(row*sin(dushu))); I2 = zeros(row1, col1,3); for i = 1:row1 for j = 1:col1 c = i - row1/2; %将旋转中心移至原点 d = j - col1/2; x = c*cos(dushu) - d*sin(dushu); %旋转 y = d*cos(dushu) + c*sin(dushu); x = x + row/2; %将所需图像移至坐标系正值部分 y = y + col/2; if x &gt; 0 &amp;&amp; x &lt;= row &amp;&amp; y &lt;= col &amp;&amp; y &gt; 0 if x &lt; 1 %边界处理 x = 1; end if y &lt; 1 y = 1; end p=x-floor(x); q=y-floor(y); I2(i,j,1)=(1-q)*(1-p)*a(floor(x),floor(y),1)+(1-q)*p*a(ceil(x),floor(y),1)+q*(1-p)*a(floor(x),ceil(y),1)+q*p*a(ceil(x),ceil(y),1); I2(i,j,2)=(1-q)*(1-p)*a(floor(x),floor(y),2)+(1-q)*p*a(ceil(x),floor(y),2)+q*(1-p)*a(floor(x),ceil(y),2)+q*p*a(ceil(x),ceil(y),2); I2(i,j,3)=(1-q)*(1-p)*a(floor(x),floor(y),3)+(1-q)*p*a(ceil(x),floor(y),3)+q*(1-p)*a(floor(x),ceil(y),3)+q*p*a(ceil(x),ceil(y),3); end end end figure; imshow(I2); %% %图像水平镜像 b=a; for i=1:300 for j=1:300 x1=i; y1=300-j+1; b(x1,y1,1)=a(i,j,1); b(x1,y1,2)=a(i,j,2); b(x1,y1,3)=a(i,j,3); end end %% %图像放大两倍 %最邻近插值 c=a; row1=2*row; col1=2*col; for i=1:600 for j=1:600 x=round(i/2); y=round(j/2); c(i,j,1)=a(x,y,1); c(i,j,2)=a(x,y,2); c(i,j,3)=a(x,y,3); end end figure; imshow(c); %% %双线性插值 c1=a; for i=1:600 for j=1:600 x=i/2; y=j/2; if x &lt; 1 %边界处理 x = 1; end if y &lt; 1 y = 1; end p=x-floor(x); q=y-floor(y); c1(i,j,1)=(1-q)*(1-p)*a(floor(x),floor(y),1)+(1-q)*p*a(ceil(x),floor(y),1)+q*(1-p)*a(floor(x),ceil(y),1)+q*p*a(ceil(x),ceil(y),1); c1(i,j,2)=(1-q)*(1-p)*a(floor(x),floor(y),2)+(1-q)*p*a(ceil(x),floor(y),2)+q*(1-p)*a(floor(x),ceil(y),2)+q*p*a(ceil(x),ceil(y),2); c1(i,j,3)=(1-q)*(1-p)*a(floor(x),floor(y),3)+(1-q)*p*a(ceil(x),floor(y),3)+q*(1-p)*a(floor(x),ceil(y),3)+q*p*a(ceil(x),ceil(y),3); end end figure; imshow(c1); %% %图像错切 d=zeros(300,300,3); dx=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c06ae7973f7f6e1bb113baace68a87d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55c6184e35b0c56ac3a3c4f0bd7d0fed/" rel="bookmark">
			斐讯N1 – 完美刷机Armbian教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		斐讯N1 – 完美刷机Armbian教程 原文 ：鱼儿的博客为什么买斐讯N1？购买斐讯N1降级关键分区制作Armbian U盘进入U盘armbian刷armbian到emmc坑爹问题-1坑爹问题-2坑爹问题-3配置时区换apt源连接wifi修改vim粘贴模式 原文 ：鱼儿的博客 https://yuerblog.cc/2019/10/23/%E6%96%90%E8%AE%AFn1-%E5%AE%8C%E7%BE%8E%E5%88%B7%E6%9C%BAarmbian%E6%95%99%E7%A8%8B/
怎么说呢？我被斐讯N1刷机Armbian活生生折腾了4个晚上，终于还是搞定了。
首先得恭喜你，运气好搜到了我的博客，否则你可能需要8个晚上，16个晚上，甚至绝望。
我先说一下网上教程都坑在哪里：
搞不清楚到底哪个Armbian内核版本好用（好用是指：稳定、低负载、各硬件驱动正常）。搞不清楚所选内核应该配套哪个dtb文件（或者不知道dtb是啥）。刷到emmc遇到各种诡异现象（例如：偶然上不去网、readonly、拔掉U盘后无法启动）。刷到emmc不正常，不知道如何正确重刷。 没错，我把所有坑都踩了一遍，累的我死去活来。
所以，你搜到我的博客算是真的走运了：
我会告诉你每一步怎么做，用什么版本，为什么会被坑。
为什么买斐讯N1？ 主要是因为它比树莓派好。
网上实测N1性能超过树莓派3B+，我觉得没必要实测了，因为计算性能本身就不是板子的强项，够用即可。
N1的优势在于：
ARM64主流架构，真64位linux系统，docker随便玩。（Armbian输出：Linux aml 5.0.2-aml-- s905 #5.77 SMP PREEMPT Mon Apr 1 17:41:33 MSK 2019 aarch64 GNU/Linux）真千兆有线网口，2.4/5G双频wifi，可以作热点。自带8G的emmc存储，linux系统直接刷到盒子里，不用额外插SD卡，I/O性能好。CPU 4核，2G内存。 唯一缺点：
USB2.0，显然是不配套千兆网口带宽的，磁盘将成为了下载电影的瓶颈。需要精力折腾，因为是小众社区来支持N1硬件适配到Armbian系统，安装过程缺乏标准化的方案。 购买斐讯N1 全网只有拼多多售卖。
截止2019年11月份，全新未开封未刮K码的全新N1，售价在130元左右，我建议大家还是买新的省心。
N1目前处于炒作阶段，价格持续攀升，建议趁早购买。
注意：不需要买USB双公头刷机线，无论刷机还是重刷都是用不到的！
降级关键分区 连接HDMI、网线、电源，你会进入斐讯自带的安卓系统。
安卓系统的标准启动过程如下：
bootloader：斐讯针对该盒子硬件实现的类似BIOS的东西，它负责硬件的初始化，最终引导操作系统。boot分区：放着安卓操作系统的内核文件，由bootloader唤起，也就实现了进入操作系统的效果。recovery分区：类似于WinPE的东西，如果boot分区挂了，则可以通过Recovery方式进入一个临时的操作系统，然后恢复boot分区（类似于ghost做系统）。 问题就在于，bootloader是斐讯针对盒子定制的，它设置了一些限制，比如：
只能使用他家的安卓系统不支持U盘引导操作系统 所以呢，恩山论坛有一位叫做webpad的大神，修改了斐讯的bootloader。
我们要做的，就是把bootloader覆盖到盒子里面去。
webpad提供了工具，大家按照教程与工具：https://www.right.com.cn/forum/thread-340279-1-1.html，通过adb网络连接的方式刷入即可。
**一台N1这辈子只需要做一次降级操作，后续不需要再研究这个问题了。
连接USB线刷的方式，除非你想玩电视系统，否则刷Armbian是不需要强制使用的。**
制作Armbian U盘 刷armbian的整体逻辑如下：
为了把armbian刷入emmc存储，我们首先得把armbian刷到U盘上，然后通过U盘引导进入armbian系统。U盘进入系统后，我们执行一个命令就可以把armbian系统的boot分区以及rootfs等等都copy到emmc上。一旦完成emmc刷写，此后bootloader就会直接读emmc中的boot分区，直接引导进入armbian。 首先是选什么版本的Armbian，以及替换哪一个dtb文件，我直接告诉大家结论： Armbian 5.77版本，使用xiangsm的dtb文件，这是恩山论坛的帖子https://www.right.com.cn/forum/thread-510423-1-1.html
这是目前恩山论坛最新也是最广泛肯定的版本，大家就不要自己再折腾研究了。
至于armbian和dtb分别是什么来头，我简单说明一下：
armbian：直接来源于armbian的官方，armbian其实就是debian发行版为arm架构适配后的版本。也就是说，恩山论坛是没有人去改动armbian系统代码的，是非常可靠的。dtb：各种品牌的盒子千千万，每个盒子使用的网卡啊、cpu芯片啊的型号千千万，armbian内核为了能够和这些外设正常工作，就要求提供一种叫做dtb的描述文件，我理解就是针对各个硬件的驱动程序。 为了让斐讯N1的各个硬件可以被armbian正常调度，所以需要给斐讯N1适配一套dtb文件。dtb文件需要随着内核编译，所以不同armbian内核版本必须使用配套的dtb文件。目前斐讯N1的dtb文件已经被armbian收录到官方源码库里，但是使用的时候linux负载会显示的很高，所以热心网友为armbian5.77编译了一个fix过的dtb文件。 armbian5.77大家直接走我的网盘下载即可，因为从armbian官方下载非常慢：
链接: https://pan.baidu.com/s/1-7AmPhRkP1LKtqb6X7s9IA 提取码: sjp9 复制这段内容后打开百度网盘手机App，操作更方便哦
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55c6184e35b0c56ac3a3c4f0bd7d0fed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5714198cdb07484b3be58a3aa50b160d/" rel="bookmark">
			Kafka Consumer深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目需要进行实时读取服务端信息，在网上看到kafka可以解决这个问题，开发完成后对kafka做一个简单的整理，希望可以帮助到刚开始学习kafka 的同学，给自己也做个笔记：
首先说一下kafka是个什么东西：
kafka是一个分布式、支持分区的（partition）、多副本的（replica），基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等
Kafka的特性:
- 高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。
- 可扩展性：kafka集群支持热扩展
- 持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失
- 容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）
- 高并发：支持数千个客户端同时读写
Kafka的使用场景：
- 日志收集：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。
- 消息系统：解耦和生产者和消费者、缓存消息等。
- 用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。
- 运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。
- 流式处理：比如spark streaming和storm
我使用的是消费端，所以我着重说一下消费端的内容：
bootstrap.servers 连接Kafka集群的地址，多个地址以逗号分隔 key.deserializer 消息中key反序列化类,需要和Producer中key序列化类相对应 value.deserializer 消息中value的反序列化类,需要和Producer中Value序列化类相对应 group.id 消费者所属消费组的唯一标识 其他属性根据个人情况去定。
关于kafka的安装可以参考这篇文章：https://blog.csdn.net/qq_36245532/article/details/88850493
kafka总是自动关闭问题 在我启动kafka后，总是会模型奇妙的进程掉了，我是启动命令是
./kafka-server-start.sh /home/kafka/kafka_2.11-2.3.1/config/server.properties 解决办法：以守护进程的方式启动
./kafka-server-start.sh -daemon /home/kafka/kafka_2.11-2.3.1/config/server.properties 加 -daemon 和不加 -daemon 区别在于：
bin/kafka-run-class.sh # Launch mode if [ "x$DAEMON_MODE" = "xtrue" ]; then #加 daemon 会使用该命令 nohup $JAVA $KAFKA_HEAP_OPTS $KAFKA_JVM_PERFORMANCE_OPTS $KAFKA_GC_LOG_OPTS $KAFKA_JMX_OPTS $KAFKA_LOG4J_OPTS -cp $CLASSPATH $KAFKA_OPTS "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5714198cdb07484b3be58a3aa50b160d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90bbc4708125b4b558d73517f68608c3/" rel="bookmark">
			你一直奉为至宝的高可用架构，或许并是真正的保证高 SLA 的良药？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么这么设计（Why's THE Design）是一系列关于计算机领域中程序设计决策的文章，我们在这个系列的每一篇文章中都会提出一个具体的问题并从不同的角度讨论这种设计的优缺点、对具体实现造成的影响。如果你有想要了解的问题，可以在文章下面留言。
作者在去年使用过 Google Cloud 平台提供的 Kubernetes 来管理生产环境的集群，然而在托管的过程中却经历了一些比较严重的线上事故，几个集群的中的节点因为停机维护而同时重启导致线上的服务几个小时都处于不不可用的状态。
当然事故时间如此之长的原因有很多，在这里不会展开讨论，然而事故刚刚出现时作者曾经也想去责怪和质疑谷歌云服务的稳定性，但是在随后的分析中得出了另一个结论『你的基础服务其实不应该高可用』，我们在这篇文章就会为各位读者分享作者产生这一观点的原因。
概述 为了帮助大家理解今天的内容，我们需要帮助各位读者理解问题中的两个个关键点，也就是高可用意味着什么、基础服务在这里的定义以及基础服务和 SLA 之前的关系。
高可用 想要让服务达到高可用并不是一个容易的事情，不仅服务运行过程中出现的事故会影响可用时间，用于维护的计划停机和更新其实也会影响服务整体的可用时间，如果一个服务要求可用性为 99.95%，那么全年不工作的时间可能只有 4.38 小时，每个月只能宕机 21.9 分钟。
可用性不可用时间（每年）不可用时间（每月）99%87.6h7.3h99.9%8.76h0.73h99.99%52.56min4.38min99.999%5.26min26.3s99.9999%31.56s2.63s 假设我们需要达到 4 个 9 的可用性（99.99%），全年的不可用时间只有不足 1 小时，每个月的不可用时间只有 4.38 分钟，99.99% 就是 Google 云计算引擎对外提供的服务质量，每个月不可用时间小于 5 分钟，这也是作者见到过云服务商对外提供的最高服务等级协议（Service-Level Agreement, SLA）了。
很多人可能认为每个月不可用 5 分钟也没什么难的，但是如果你的业务服务建立在稳定性只有 99.95% 甚至 99.9% 的服务上时，你还能保证服务的高可用么？
基础服务 在这篇文章中我们谈到的基础服务指的其实都是基础设施和基础架构，例如用于支撑整个业务系统的 MySQL、Redis 以及 Kubernetes 等系统，这些系统的稳定性和可用性会影响整个业务系统的可用，由于这些基础服务往往提供了相对较为简单和稳定的功能，所以我们对基础服务的可用性有着更高的要求。
业务服务由于经常发版和迭代，有时很难保证服务的稳定和可用，而基础服务和基础架构因为处于更加底层的位置，所以它们稳定性的提升对于依赖它们的上游来讲会有比较大的收益，这也是所有业务同学对基础服务以及架构的期望 —— 保证尽可能高的可用性并保证服务不会宕机。
关系 虽然说所有的开发者都希望基础服务能够提供尽可能高的可用性和 SLA，但是极高的 SLA 对于整体业务的长期稳定并不是一件好的事情，可能在短期内能够提供较大的价值，但是从长远来看可能会造成更大的破坏，这也就是今天想要分析的问题 —— 『为什么基础服务不应该高可用』。
设计 在这一节中，我们将从以下的三个方面依次分析『为什么基础服务不应该高可用』：
凡是可能出错的事情就一定会出错；
成本因素有时是技术决策的最关键因素；
只有使用更多异构的副本才能保证更高的可用性；
最后一点并不是这个观点的强论点，我们放在这里只是为了让各位读者了解能够保证服务高可用的唯一方法，需要注意的是通过保证代码逻辑的正确、服务的正确配置来提升可用性并不是我们在这里要讨论的内容，这是一个服务正常工作的前提。
墨菲定律 墨菲定律其实已经是一个几乎所有地球人都知道的定律了，它在大多数的时候都会被解释成『凡是可能出错的事情就一定会出错』，任何一个线上的服务能够正常运行都是极其偶然的，只要时间拉的足够长，我们就没有办法保证任何服务 100% 的可用性。每一个服务的正常工作可能都需要满足以下的条件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90bbc4708125b4b558d73517f68608c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29b2e9741b5710f031d891d9fb8faa65/" rel="bookmark">
			关系型和非关系型数据库的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区别一：存储方式 关系型数据库以数据库表形式存储数据 结构比较规整固定 非关系型以JSON文档、哈希表或者其他方式 结构更加灵活和可扩展 区别二：表和数据的关系
关系型数据库中，必须定义好表和字段结构后才能添加数据，
非关系型数据库中，数据可以在任何时候任何地方添加，不需要先定义表,数据库会自动创建相应的集合
区别三：数据之间的关系
关系型数据库中建立实体数据之间的联系是通过加外键
非关系型数据库中除了这种规范化做法以外，还能用一种非规范化方式：
即把外部数据直接放到原数据集中，以提高查询效率。缺点就是更新审核人数据的时候将会比较麻烦。 区别四：参照完整性 参照完整性：若A关系中的某个或者某些属性参照B或其他几个关系中的属性，那么在关系A中该属性要么为空，要么必须出现B或者其他的关系的对应属性中。 举个例子：
上表是审核人员表 下表是借阅人员表 用外键关联
关系型数据库中不允许删除已经被使用的外部数据，例如审核人表中的"熊三"已经被分配给了借阅人表熊大，那么在审核人表中将不允许删除熊三这条数据，以保证数据完整性。
非关系型数据库中则没有这种强耦合的概念，可以随时删除任何数据。 区别五：事务 关系型数据库 有事务的概念
非关系型数据库没对事务的支持较差
区别六：应用场景 关系型数据库适合存储结构化数据，如用户的帐号、地址
NoSQL适合存储非结构化数据，如文章、评论。
前许多大型互联网项目都会选用MySQL（或任何关系型数据库） + NoSQL的组合方案。
区别七：查询语言
关系型数据库通过结构化查询语言来操作数据库 有统一标准
非关系型数据库使用的是非结构化查询语言（UnQl），它是没有标准的。 区别八：性能
关系型数据库为了维护数据的一致性 在面对高并发读写性能非常差，面对海量数据的时候读写效率非常低。
nosql存储的格式是key-value类型的，并且存储在内存中，对于数据一致性弱要求，无需sql的解析，提高了读写性能。 区别九：授权方式 大多数的关系型数据库都是付费的并且价格昂贵，成本较大，
非关系型数据库通常都是开源的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab9200bce100c57562cf6eaff84ea27b/" rel="bookmark">
			并查集--QuickFind实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 并查集的意义
判断连通性问题
初始化每个元素都是不同集合
判断两个点是否连通，查看是否在同一个集合中即可
2 QuickFindUF实现
顾名思义，查询非常快，用数组来存储，每个索引对应的是集合的编号
/** * @author Created by qiyei2015 on 2019/12/11. * @version: 1.0 * @email: 1273482124@qq.com * @description: 快速查询的并查集 * 用数组来存储，每个索引对应的是集合的编号 */ public class QuickFindUF implements UF{ /** * 元素集合 */ private int[] id; public QuickFindUF(int size) { id = new int[size]; //分别属于不同的集合 for (int i = 0 ;i &lt; id.length; i++){ id[i] = i; } } @Override public int size() { return id.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab9200bce100c57562cf6eaff84ea27b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d623fb4ad60f6a6f7bf835a758b22d0a/" rel="bookmark">
			使用 VS 2017进行C&#43;&#43; for Linux远程开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 最近的项目需要封装基础库，支持多平台。通常，当我们开发Linux程序时有两种方案：
在Linux上直接编写程序并进行运行测试和调试在Windows或Mac OS X上借助工具进行远程开发 但是本人没做过Linux下的C++开发，算是从头开始学起。在网上查了资料后，发现VS2017以后已经可以在VS上进行Linux代码的开发，便自己尝试，且把过程记录下来，一起学习。
内容参考：使用 VS 2019进行C++ for Linux远程开发
准备工作 安装VS2017以上的版本，这里选择的VS2019版本，先去微软官方下载visual studio，下载地址如下：
VS2019下载
一般选择社区版就好。安装的时候需要勾选 c++ for Linux 功能。准备一个可用的Linux远程环境，例如配置了静态IP的Linux虚拟机，并且已经安装好了GCC工具链以及openssh。
我是用vmware workstation虚拟机安装Ubantu server版本。安装教程如下：（后续添加）。 使用 创建新项目，按提示直接创建就好，这里新建一个空项目。
配置项目属性
vs不能编辑空项目的配置，所以我们先在项目中创建一个main.cpp，然后点击顶部菜单：项目-&gt;属性，你就能看到项目的配置界面了。
远程计算机是在调试中的远程连接管理器中添加的。这里一般不需要改动，除非你需要改变项目的类型或编译结果的存放位置。如果有多个远程环境时，也可以在这里进行选择。
调试部分提供了gdb和gdbserver，前者是让vs在Linux上启动一个console，然后在其中运行gdb并返回输出，如果你的Linux上的终端配置了彩色输出，那么和遗憾vs并不认识他们，会显示成原始的字符串；使用gdbserver时会在远程启用gdbserver，本地vs解析回传的数据不会出现杂音。这里我们选择了gdbserver，如果你发现无法打断点，那么参考微软的建议，换回gdb方案：
接着是配置的重点，首先是配置需要同步的远程环境的头文件，有了这些文件vs才能对你的代码进行自动补全和提示：
默认复制的路径通常已经包含了Linux上大部分的头文件，通常我们也不需要做更改。头文件的同步发生在第一次构建项目成功后或添加远程连接后手动同步。
接着是c/c++编译器的选择，也就是对gcc和g++编译参数的配置，讲解这些参数超出了我们的讨论范围，我们这里只需要选择合适的c++标准版本：
链接远程环境 有了远程环境我们才能同步头文件或者进行调试运行。
在第一次编译或调试你的项目时vs会自动让你连接远程环境，当然，我们推荐在调试-&gt;选项-&gt;跨平台-&gt;连接管理器中进行设置：
开始调试 至此你已经可以在vs中编写面向Linux平台的代码了，自动补全可以正常工作：
可以看到Linux中的头文件和结构体都已经可以识别了。如果你发现无法自动补全（通常发生在刚添加远程连接或是项目设置发生了变化后），先试试关闭vs重新打开，如果没用请尝试刷新intellisense或重新同步头文件。在编辑结束后我们就能点击调试按钮运行我们的程序了：
注意，构建的体系架构必须是和远程环境一致的，比如远程环境是x64，这里可以选择x64或x86，但是不能选择arm，否则会报错。
#include &lt;cstdio&gt; int main() { printf("hello from LinuxTest!\n"); return 0; } 点击调试-&gt;Linux 控制台，会显示一个可以交互的console，你可以在其中输入内容或是看到程序的输出：
可以看到远程的Linux系统对应的目录下也有相应的调试文件
遭遇问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c158be51675af26a1041b9fddb6e203/" rel="bookmark">
			ERROR tool.ExportTool: Encountered IOException running export job: java.io.IOException: No columns t
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用sqoop数据从Hive复制到MySQL出现的问题 19/12/22 11:03:37 INFO tool.CodeGenTool: Beginning code generation
Sun Dec 22 11:03:38 CST 2019 WARN: Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c158be51675af26a1041b9fddb6e203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffddeeb64f3586b90f13afdf31f29515/" rel="bookmark">
			java利用构建器来创建实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java利用构建器来创建实例而不是构造器
对于类而言，为了让客户端获取他本身的一个实例， 最传统的方法就是提供一个公有的构造器。 一个类中
重载多个构造器 客户面对多个构造器这种API永远也记不住该用哪个构造器， 并且每次调用构造器必然会创建新的对象， 如果程序需要重复使用对象，构造器无法避免创建不必要的对象。 静态工厂方法与构造器不同的
第一大优势为：他们有名称第二大优势为：不必每一次调用他们的时候创建一个新对象第三大优势为：他们可以返回原返回类型的任何子类型的对象第四大优势为：所返回的对象的类随着每次调用发生变化，这取决于静态方法的参数值 下面是静态工厂方法的一些惯用名称
1）from---------------------类型转换方法
Date d = Date.from(instant)
2）of------------------------聚合方法，带有多个参数，返回该类型的一个实例，把他们合并起来
Set&lt;Rank&gt; faceCard = EnumSet.of(JACK,QUEEN,KING)
3）valueOf-----------------比前两个更繁琐的方法BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE)
…
一个构造器中有多个参数时 静态工厂和构造器有个共同的局限性： 他们都不能很好的扩展到大量的可选参数。 比如用一个类来表示食品外面的营养成分标签。 构造器调用了通常你不想设置的参数， 仅仅是几个参数还可接受，但随着参数的增加，很快就失去了控制。 简而言之，重叠构造器模式可行，但当有更多的参数是，客户端的代码会看起来非常糟糕。
javaBean看起来强于上述的重叠构造器模式，但同时也会带来多线程下不安全的问题
那么，我们的构建器出场了。
利用静态内部类Builder,定义与外部类的成员完全相同的成员变量。 类似于javaBean的模式设置每一个参数 最后用build方法构建外部类的新实例（调用外部类的私有构造器） Main.java
public class Main { public static void main(String[] args) { //初始化一个NutritionFacts实例，一定要最后调用build()方法去调用NutritionFacts类的构造器去实例化NutritionFacts的对象 NutritionFacts cocaCola = new NutritionFacts.Builder(120,200).calories(1).carbohydrate(22).build(); //并且参数由客户端调用时决定，并不是一定要固定输入参数，改进写重载很多构造器给用户带来麻烦 //javaBean改进了重载一大堆构造器的问题，却也带来了线程不安全的问题 NutritionFacts cocaCola1 = new NutritionFacts.Builder(223,233).build(); } } NutritionFacts.java
public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; //私有构造器方法 private NutritionFacts(Builder build) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffddeeb64f3586b90f13afdf31f29515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f68c101083f2256353162bb96b697e/" rel="bookmark">
			全网首发：WINDOWS某些文件夹，提供管理员权限后也无法删除，正确解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试了网上一些解决办法，不彻底。于是自己又尝试了一番，找到终极解决办法：
设置权限 右键，安全，编辑。出现对话框时，把每个用户编辑一遍，确保都是“完全控制”
检查是否有”不是继承的“ 右键，属性，安全，高级。对于显示“不是继承的”项目：
应用到子目录 更改权限，对于显示”不是继承的“项目，勾选下方的两个复选框，如图：
应用。
确定之后，就可以删除了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8fd34a816b9be7988b4d7d112277bf5/" rel="bookmark">
			使用HAL库开发STM32：UART进阶使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 目的发送处理存在的问题解决方法个人常用处理方式 数据接收与解析数据接收数据解析 对于HAL库的吐槽总结 目的 在前面文章 《使用HAL库开发STM32：UART基础使用》 中介绍的UART的基础使用，基础使用非常简单，不过在实际应用过程中仅基础方法可能不是那么方便，还需要编写更多代码来完善使用。这篇文章将对常见的数据发送接收处理方式做个演示。
注1：在STM32开发时因为默认分配的堆内存不大，我个人比起使用malloc或是new方法申请内存，更多的喜欢把数据放在静态区域；（这样编译的时候也可以看到内存占用情况）
注2：本文中有些功能使用C++作为演示，实际使用中也可以自行改为纯C代码实现；
发送处理 存在的问题 前面文章中讲到我们通常使用非阻塞方式来收发数据，这里就产生了一个问题，如下代码：
void fun(void) { uint8_t data[256] = {0}; // TODO HAL_UART_Transmit_DMA(&amp;huart1, data, 256); //将data数组内容通过UART发送 } int main(void) { Init(); fun(); while (1) { } } 上面代码中fun函数里声明了一个数组，然后通过UART以非阻塞的方式进行发送，在调用发送函数后紧接着会立即退出fun函数，dara数组内存会被释放，但这个时候发送还在进行，这里就有可能发生发生数据不对或是程序跑飞等问题。
此外还有一个问题是同一个串口如果以非阻塞方式发送数据，在数据还未发送完的时候再次调用发送函数就会出错。
解决方法 对于第一个问题解决方法很简单，把data声明放到外面就成：
uint8_t data[256] = {0}; void fun(void) { // TODO HAL_UART_Transmit_DMA(&amp;huart1, data, 256); //将data数组内容通过UART发送 } 或者用动态申请的方式：
uint8_t *data; void fun(void) { data = (uint8_t*)malloc(256); //申请内存 // TODO HAL_UART_Transmit_DMA(&amp;huart1, data, 256); } void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) { if(huart == &amp;huart1) { free(data); //发送完成后释放内存 } } 对于第二个问题解决方法也不麻烦，通过观察可以知道HAL库的串口发送函数传入参数除了串口对象以外还有数据地址和长度，只要把数据地址和长度保存到下来，然后一个一发送即可，可以参考下节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8fd34a816b9be7988b4d7d112277bf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f12c6e1feeea15c702678575c2f6e173/" rel="bookmark">
			Android组件化开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发模式 为了便于区分，在这里将开发模式分为2种：一种是项目组件化开发模式，一种是单一工程开发模式。
单一工程开发模式 顾名思义，就是一个代码工程(Project)对应一个APP了，这个APP的所有业务功能都是集中在同一个工程里实现的。
上图是目前比较普遍使用的Android APP技术架构，往往是在一个界面中存在大量的业务逻辑，而业务逻辑中充斥着各种网络请求、数据操作等行为，整个项目中也没有模块的概念，只有简单的以业务逻辑划分的文件夹，并且业务之间也是直接相互调用、高度耦合在一起的；
上图单一工程模型下的业务关系，总的来说就是：你中有我，我中有你，相互依赖，无法分离。
然而随着产品的迭代，业务越来越复杂，随之带来的是项目结构复杂度的极度增加，此时我们会面临如下几个问题：
实际业务变化非常快，但是单一工程的业务模块耦合度太高，牵一发而动全身； 对工程所做的任何修改都必须要编译整个工程；功能测试和系统测试每次都要进行；团队协同开发存在较多的冲突.不得不花费更多的时间去沟通和协调，并且在开发过程中，任何一位成员没办法专注于自己的功能点，影响开发效率；不能灵活的对业务模块进行配置和组装； 组件化开发模式 集成模式—所有的业务组件被“app壳工程”依赖，组成一个完整的APP；
组件模式—可以独立开发业务组件，每一个业务组件就是一个APP；
app壳工程—负责管理各个业务组件，和打包apk，没有具体的业务功能；
业务组件—根据公司具体业务而独立形成一个的工程；
功能组件—提供开发APP的某些基础功能，例如打印日志、树状图等；
Main组件—属于业务组件，指定APP启动页面、主界面；
Common组件—属于功能组件，支撑业务组件的基础，提供多数业务组件需要的功能，例如提供网络请求功能；
APP组件化架构的目标是告别结构臃肿，让各个业务变得相对独立，业务组件在组件模式下可以独立开发，而在集成模式下又可以变为arr包集成到“app壳工程”中，组成一个完整功能的APP；
从组件化工程模型中可以看到，业务组件之间是独立的，没有关联的，这些业务组件在集成模式下是一个个library，被app壳工程所依赖，组成一个具有完整业务功能的APP应用，但是在组件开发模式下，业务组件又变成了一个个application，它们可以独立开发和调试，由于在组件开发模式下，业务组件们的代码量相比于完整的项目差了很远，因此在运行时可以显著减少编译时间。
这是组件化工程模型下的业务关系，业务之间将不再直接引用和依赖，而是通过“路由”这样一个中转站间接产生联系，而Android中的路由实际就是对URL Scheme的封装；
如此规模大的架构整改需要付出更高的成本，还会涉及一些潜在的风险，但是整改后的架构能够带来很多好处：
加快业务迭代速度，各个业务模块组件更加独立，不再出现业务耦合情况；稳定的公共模块采用依赖库方式，提供给各个业务线使用，减少重复开发和维护工作量；迭代频繁的业务模块采用组件方式，各业务研发可以互不干扰、提升协作效率，并控制产品质量；为新业务随时集成提供了基础，所有业务可上可下，灵活多变；降低团队成员熟悉项目的成本，降低项目的维护难度；加快编译速度，提高开发效率；控制代码权限，将代码的权限细分到更小的粒度； 组件化实施流程 组件模式和集成模式 Android Studio中的Module主要有两种属性，分别为：
//application属性，可以独立运行的Android程序，也就是我们的APP apply plugin: ‘com.android.application’ //library属性，不可以独立运行，一般是Android程序依赖的库文件 apply plugin: ‘com.android.library’ Module的属性是在每个组件的 build.gradle 文件中配置的，当我们在组件模式开发时，业务组件应处于application属性，这时的业务组件就是一个 Android App，可以独立开发和调试；而当我们转换到集成模式开发时，业务组件应该处于 library 属性，这样才能被我们的“app壳工程”所依赖，组成一个具有完整功能的APP；
Gradle自动构建工具有一个重要属性，可以帮助我们完成这个事情。每当我们用AndroidStudio创建一个Android项目后，就会在项目的根目录中生成一个文件 gradle.properties，我们将使用这个文件的一个重要属性：在Android项目中的任何一个build.gradle文件中都可以把gradle.properties中的常量读取出来；那么我们在上面提到解决办法就有了实际行动的方法，首先我们在gradle.properties中定义一个常量值 isBuildModule（是否是组件开发模式，true为是，false为否）：
每次更改“isModule”的值后，需要点击 "Sync Project"按钮
isBuildModule=false
然后我们在业务组件的build.gradle中读取 isBuildModule，但是 gradle.properties 还有一个重要属性： gradle.properties 中的数据类型都是String类型，使用其他数据类型需要自行转换；也就是说我们读到 isBuildModule是个String类型的值，而我们需要的是Boolean值，代码如下：
if (isBuildModule.toBoolean()) { apply plugin: 'com.android.application' } else { apply plugin: 'com.android.library' } AndroidManifest合并 在 AndroidStudio 中每一个组件都会有对应的 AndroidManifest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f12c6e1feeea15c702678575c2f6e173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62f04201538f55499ae9f61d2207cb9b/" rel="bookmark">
			RGBA图像格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RGBA是代表Red（红色）Green（绿色）Blue（蓝色）和Alpha的色彩空间。
alpha通道一般用作不透明度参数。如果一个像素的alpha通道数值为0%，那它就是完全透明的（也就是看不见的），而数值为100%则意味着一个完全不透明的像素（传统的数字图像）。在0%和100%之间的值则使得像素可以透过背景显示出来，就像透过玻璃（半透明性），这种效果是简单的二元透明性（透明或不透明）做不到的。它使数码合成变得容易。alpha通道值可以用百分比、整数或者像RGB参数那样用0到1的实数表示。
PNG是一种使用RGBA的图像格式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e82eddbe3e9b1e10d2c3302af2d3ca/" rel="bookmark">
			win10小课堂：如何解决svchost一直占用网速和内存？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10小课堂：如何解决svchost一直占用网速和内存？ svchost.exe是一个属于微软Windows操作系统的系统程序。 微软官方对它的解释是：svchost.exe 是从动态链接库(DLL)中运行的服务的通用主机进程名称。 svchost不仅会占有电脑内存，还会抢你的网，这次教大家如何关闭svchost。 1.鼠标右击【此电脑】选择【管理】。
2.双击打开【服务和应用程序】中的【服务】。
3.找到【Background Intelligent Transfer Service】然后点击【停止】。
4.鼠标右击【Background Intelligent Transfer Service】，选择【属性】。
5.启动类型选择【手动】，然后点击【确定】。
通过以上设置后，svchost就不会一直占用网速和内存了，操作很简单，各位小伙伴赶快设置一下吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc6a38bce73d0a3852de403471d4431/" rel="bookmark">
			全球摄像头镜头主要厂商（TOP 14）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全球摄像头镜头主要厂商（TOP 14）
CMOS图像传感器市场在2018年达到155亿美元，超过半导体市场总体营收的3%。索尼（Sony）与三星（Samsung）、豪威科技（OmniVision）、安森美半导体（ON Semiconductor）等厂商一起将CMOS图像传感器产业发展壮大，赋能各行各业的关键应用！一些创新方法（如晶圆级堆叠技术）专门针对CMOS图像传感器开发，并发展成半导体领域的共性技术。在竞争激烈的技术领域，成像功能成为OEM厂商和整个半导体供应链的关键焦点。
来源：西
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9294fcdd03a244ecb666b87bf3c5d170/" rel="bookmark">
			sqlserver 利用存储过程 迁移数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目升级，有些表的结构已近被改掉了。所以需要利用存储过程来将旧表的数据导入到新表中。学完后，特地在此做一个相关笔记。
1、数据表结构
t1数据表
t2数据表
2、连接远程数据库
-- 添加远程连接 EXEC sp_addlinkedserver @server = 'ipas', -- 目标服务器别名 @srvproduct = '', -- 产品名称，因为数据库是sqlserver，设置为空 @datasrc = '192.168.1.111' , -- 目标服务器名称 @provider = 'SQLOLEDB' -- 添加远程连接的登入名 EXEC sp_addlinkedsrvlogin @rmtsrvname = 'ipas' , -- 与以上 @server 同名 @useself = 'false' , @locallogin = NULL , @rmtuser = 'sa' , -- 数据库用户 @rmtpassword = 'admin123' -- 登入密码 --利用远程连接查询表，ipas 为定义的服务器别名；t1为表名 SELECT * FROM ipas.dbo.t1 3、创建存储过程
CREATE PROCEDURE test -- @pid_start 在这里为 开始查询添加的表数据 id @pid_start int, -- @pid_end 为 结束循环添加的表数据 id @pid_end int AS BEGIN -- 定义变量 DECLARE @num int; -- 定义用来接收数据库字段的变量 DECLARE @d_t_id int; DECLARE @d_t_name VARCHAR ( 255 ); DECLARE @d_t_value VARCHAR ( 255 ); DECLARE @d_t_age int; -- 设置开始循环的值 SET @num = @pid_start; WHILE @num &lt; @pid_end BEGIN -- 定义游标 DECLARE cu_t CURSOR -- 获取数据 FOR SELECT * FROM ipas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9294fcdd03a244ecb666b87bf3c5d170/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c95ab5089ce4d14ab465212526fd85db/" rel="bookmark">
			数据同步之全量数据同步（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍源表为单表时，全量数据同步的情况。当源表为多表时，跟单表的情况差不多。
一、数据同步情况说明
将源数据库S中的A表（将此表称为源表），通过ETL工具同步至目标数据库T的A表（将此表称为目标表）。假设源表A的表结构与目标表A的表结构完全一致。表结构如下图所示：
二、全量数据同步过程
1、单次全量数据同步流程图，如下图所示：
1)、开始。
2)、删除目标表A中的所有数据记录。即在目标数据库T下执行下面语句：
truncate table A 3)、查询源表A中所有数据记录。即在源数据库S下执行下面语句：
select * from A 4)、通过ETL等工具，将源表A中所有数据记录同步至目标表A。
5)、结束。
注意：本流程图，只是用来说明全量数据同步的原理的，实际情况，使用ETL等相关工具进行同步流程配置的时候会有所不同。
2、设置定时任务，根据实际情况，定时执行单次全量数据同步过程。
三、需要注意的地方
全量数据同步，只有在数据量较小，且对数据要求不高的情况下使用。全量数据同步可以保证源表A和目标表A，无论是数量还是每条数据记录上都是完全一致的。但是，此方法会在数据同步程序执行过程中，会造成目标表A为空，或者数据不全的情况出现。当然，也有另外方法可以解决此问题。后面会有专门的文章进行讨论。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df4e46811bea7eb717682d5e7a347b2d/" rel="bookmark">
			GetOverlappedResult取操作结果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://docs.microsoft.com/zh-cn/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult添加链接描述
GetOverlappedResult这个函数的主要作用不过是将Overlapped返回的结果进行一次简单的分析而已。
dwErrorRet = WaitForSingleObject(overlapped.hEvent, milliseconds); if(WAIT_OBJECT_0 == dwErrorRet)//WAIT_OBJECT_0 0x00000000 ：指定的对象出有有信号状态 { GetOverlappedResult(m_hWriteEvent, &amp;overlapped, &amp;dwNumberofBytesWritten, FALSE); } 一次重叠写操作过程(GetOverlappedResult方法):
1.填写一个OVERLAPPED结构
2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针)
3.做其它事(如更新界面)
4.GetOverlappedResult取操作结果
5.如果IO请求没有完成,并且没有出错则回到３
6.处理IO操作结果
例2.一次重叠写操作过程(完成例程方法):
1.填写一个OVERLAPPED结构
2.进行一次写操作,并指定重叠操作参数(上面的OVERLAPPED结构变量的指针),并指定完成例程
3.做其它事(如更新界面)
4.当完成例程被调用说明IO操作已经完成或出错,现在可以对操作结果进行处理了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/645f750361054d228856dab7b42c6125/" rel="bookmark">
			nginx 实现根据访问端跳转指定页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现在移动端访问某链接重定向到指定页面
nginx.conf 配置
server { listen 443; server_name www.songjingzhou.com; ssl on; ... location ~ / { include mobile_site_rewrite.conf; } } mobile_site_rewrite.conf 配置
set $mobile_rewrite do_not_perform; if ($http_user_agent ~* "Android|(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|iP(hone|od|ad)|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|p alm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino") { set $mobile_rewrite perform; } if ($http_user_agent ~* "^(1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw \-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(a d|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k) |le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10) |ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55 \/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to (pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-)") { set $mobile_rewrite perform; } if ($mobile_rewrite = perform) { rewrite ^/detail/(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/645f750361054d228856dab7b42c6125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3790b0223776455cc652cb326f63f734/" rel="bookmark">
			springboot使用fastjson解决中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 springboot使用fastjson解决中文乱码问题 一 问题描述 二 解决办法 在fastJson的设置中fastJsonConfig.setCharset(Charset.forName("UTF-8"));其编码方式默认为UTF-8，但仍然出现乱码情况，由于SpringBoot的编码方式是跟随系统设置，因此将编码强制到Http请求和response响应中
# application.yml文件中设置如下 spring: http: encoding: force: true 三 后来 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03174bb064df1c80cb858fae5559e9e7/" rel="bookmark">
			第五章平稳过程（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平稳过程基本概念 1.1定义 严平稳过程
设 X = { X t , t ∈ T } X=\{X_t,t\in T\} X={Xt​,t∈T}是随机过程，如果对任意的 n &gt; 1 , t 1 , t 2 , . . . t n ∈ T n&gt;1,t_1,t_2,...t_n\in T n&gt;1,t1​,t2​,...tn​∈T和实数 τ , \tau, τ,有n维随机变量 F t 1 , t 2 , . . . t n ( x 1 , x 2 , . . . , x n ) = F t 1 + τ , t 2 + τ , .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03174bb064df1c80cb858fae5559e9e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38bac0480eeafc9971c2f0b62e046095/" rel="bookmark">
			JAVA获取微信access_token(接口调用凭据)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序的开发中,后端直接请求微信的大部分业务都要使用到access_token
access_token通过微信提供的接口获取,目前获取一次的有效期是7200秒
官方提供的接口:
使用思路:
1.如果程序中使用到access_token的地方非常非常少，直接请求到参数然后使用就可以，可以不用存储（偷懒的方法）
2.将access_token存入数据库，程序每隔固定的时间刷新（注意有效期是2小时，控制在1.5小时左右刷新较好），需要使用到这个参数时直接从数据库获取
获取access_token的代码：
控制层逻辑:
String url="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=" + “你的appid” + "&amp;secret=" + "你的小程序secret"; String result = HttpUtil.sendGet(url); JSONObject object=JSON.parseObject(result); String Access_Token = object.getString("access_token");//这就是access_token HttpUtil:
import java.io.IOException; import org.apache.http.HttpEntity; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; public class HttpUtil { private static final CloseableHttpClient httpclient = HttpClients.createDefault(); /** * 发送HttpGet请求 * @param url * @return */ public static String sendGet(String url) { HttpGet httpget = new HttpGet(url); CloseableHttpResponse response = null; try { response = httpclient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38bac0480eeafc9971c2f0b62e046095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a79c9ffc8216827be41103d94c2ff04/" rel="bookmark">
			Sftp.java:379 突然上传失败原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Closing JDBC Connection [Transaction-aware proxy for target Connection [HikariProxyConnection@331469588 wrapping oracle.jdbc.driver.T4CConnection@1f8b10c4]]
cn.hutool.extra.ssh.JschRuntimeException: SftpException: Failure
&lt;== Total: 0
Closing JDBC Connection [Transaction-aware proxy for target Connection [HikariProxyConnection@1573503862 wrapping oracle.jdbc.driver.T4CConnection@434d001d]]
at cn.hutool.extra.ssh.Sftp.put(Sftp.java:379)
at cn.hutool.extra.ssh.Sftp.put(Sftp.java:364)
通过手动FTP工具上传，发现还是失败，因此可能是空间满了
查看空间df，发现的确是空间满了，清理一下日志，重新上传，解决问题
如果仍然有问题，就查看内存是否够用
free -m
排查大文件：
利用shell的文件大小查看指令
du -h --max-depth=1
来检查大号文件的位置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4315eac613c23b9084a6c904e3747015/" rel="bookmark">
			Word插入视频的两种办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一。
插入 -&gt;超链接
不要以为超链接就很NB 需要联网哈 虽然我确实之前这么以为 超链接
“超级链接在本质上属于一个网页的一部分，它是一种允许我们同其他网页或站点之间进行连接的元素。各个网页链接在一起后，才能真正构成一个网站。所谓的超链接是指从一个网页指向一个目标的连接关系，这个目标可以是另一个网页，也可以是相同网页上的不同位置，还可以是一个图片，一个电子邮件地址，一个文件，甚至是一个应用程序。而在一个网页中用来超链接的对象，可以是一段文本或者是一个图片。当浏览者单击已经链接的文字或图片后，链接目标将显示在浏览器上，并且根据目标的类型来打开或运行。” 对吧本地的 一个文件或者应用程序也可以
超我觉得是因为传输的数据是超文本的 ，反正就是一个地址 就跟内存地址没啥本质区别，所以我们要加链接必须是链接的地方有那个实体，就像我们给了你学校地址 你跑那一看 哎被拆了 那就不行了。而且我记着OS里也讲过文件系统什么链接什么的 忘了
二种方法 直接赋值过来作为word文件的一部分 对吧 这样 你吧word在另一个电脑打开也有对吧 因为是内嵌的
它是怎样的呢 是这样
实际上是加一个幻灯片 然后在幻灯片里插入一个视频 相当于 word包含了一个PPT ，PPT包含了一个视频
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d8ec7abc4e5de99eaf6a8f60d15dd24/" rel="bookmark">
			Linux下C&#43;&#43;/C 编译生成.a 或者.so 库文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近因为阅读源码的工作，需要自己编译一些 .so 文件或者 .a 文件，查了一些资料，写了一些示例，记录一下。
静态库和动态库 一般程序编译的过程可以分为编译和链接两个阶段。链接阶段，需要把所有的obj文件(.o)链接起来，生成可执行程序，这个过程可以链接其他外部的库文件。 有时候也有省略写法。
gcc -c test.c #源文件编译，生成 .o 文件 gcc -o test test.o #将Obj文件链接，可以多个文件 #省略写法 gcc test.c #默认生成 a.out gcc -o test test.c #两个阶段省略成一个 库文件里的具体实现时对用户透明的，只是提供功能函数，而用户不能知道库文件爱你的源码实现。如果你不想开源你的具体实现，你就可以只提供库文件供别人使用。库文件分为静态库和动态库文件：
静态库：一般情况下也就是 .a 文件。静态库就是指在链接的过程中，将库文件所有数据都整合到目标代码，这样生成的可执行文件执行时就不再需要外部库支持，随便哪里运行。这样就导致了静态库编译生成的可执行库文件较大，而且当库文件需要更新改变时，可执行文件也必须重新编译生成。
动态库：一般情况下就是 .so 文件。与静态库不同，动态库文件在链接时不会将所有的代码实现整合到目标代码中，而是在可执行程序执行到相应位置时才会去库文件中搜索相应的方法。所以动态库链接生成的函数就比较小，而且库文件更新时，只需要重新生成库文件就可以了，不需要重新编译可执行程序。这就给库文件升级更新带来了极大的便利。
库文件的编译生成 静态库的编译生成
静态库的编译生成需要用到 ar 指令，链接过程参数 -L 表示库文件路径，-l 表示库文件名称。库文件要以 lib{name}.a 命名格式，name指库文件的名字。
写一个测试小程序，三个文件，funTest.c, funTest.h 和 testMain.c ，testMain.c调用 一个 库函数输出：
// funTest.h 头文件进行函数接口定义 #include &lt;stdio.h&gt; void printa(); //-------------------------------------------- // funTest.c 源文件中实现 #include "funTest.h" void printa(){ printf("print a\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d8ec7abc4e5de99eaf6a8f60d15dd24/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/451/">«</a>
	<span class="pagination__item pagination__item--current">452/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/453/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>