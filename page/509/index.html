<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6492e6e7274a60f27ab08a25371d05af/" rel="bookmark">
			gradle项目构建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gradle中常用的命令 ./gradle tasks --all 显示项目中所有的构建任务，也显示每个任务的依赖 ./gradle anDep 每个配置的依赖树 ./gradle -b app.gradle 使用非默认的构建文件名 ./gradlew androidDependencies 查看android依赖 ./gradlew -P(配置属性)=xxx assembleDebug 使用-P标志运行gradle ./gradlew tasks 所有的task ./gradlew build -x lint 排除任务 ./gradlew -q hello 日志信息 -i -d -q -s -S 输出堆栈信息 ./gradlew --refresh-dependencies 强制刷新 ./gradlew projects 所有的project project相关的api getAllprojects() 获取所有的project的,0是根project getSubprojects()获取当前工程下的所有子project getParent() 获取当前工程的父project getRootProject() 获取根节点project project(string path,Closure configureClosure) 获取project allProject{} //配置所有project subprojects{}不包括当前节点工程,只包括它的subproject 文件相关操作api getRootDir() 获取根工程路径 getBuildDir()获取build路径 getProjectDir()获取project路径 file()从当前目录下获取文件 files()定位一个或多个文件 ------------------------------------------------------------------------------------
配置的方法
/** * 配置阶段开始前的监听回调 */ beforeEvaluate {} /** * 配置阶段完成以后的回调 */ afterEvaluate {} /** * gradle执行完毕后的回调监听 */ gradle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6492e6e7274a60f27ab08a25371d05af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee73b6c0fab222b398c7a1392e268252/" rel="bookmark">
			Error updating database.  Cause: com.mysql.jdbc.MysqlDataTruncation: Data truncation: Truncated inco...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行更新时的出错信息
Whitelabel Error Page This application has no explicit mapping for /error, so you are seeing this as a fallback.
Fri Jun 29 15:02:45 CST 2018 There was an unexpected error (type=Internal Server Error, status=500). ### Error updating database. Cause: com.mysql.jdbc.MysqlDataTruncation: Data truncation: Truncated incorrect DOUBLE value: 'as4' ### The error may involve com.nenu.dao.EmployeeDao.Employee ### The error occurred while setting parameters ### SQL: update employee set emp_name = ? and emp_password = ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee73b6c0fab222b398c7a1392e268252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d012ac7c65dcfa44a83876b87d91ce/" rel="bookmark">
			mac下php环境搭建  俗称 MNMP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意点:
1.mac下homebrew 就不多说了 正常安装
2.mac自带的有php和apache，可能也有nginx，自己查看 我的在/usr/local/Cellar 下面都有
3.环境配置说明
3.1 重新下载 homebrew install php56
3.2 下载好的php56 注意切换php版本 brew search php 查看版本是否是自己要的 不是查下切换命令 好像是brew unlink php@版本号 和brew link 版本号
3.3 echo 'export PATH="/usr/local/opt/php@5.6/bin:$PATH"' &gt;&gt; ~/.zshrc
echo 'export PATH="/usr/local/opt/php@5.6/sbin:$PATH"' &gt;&gt; ~/.zshrc
source ~/.zshrc
link完提示这个 用zsh的话就这样 bash的话是在~/.bash_profile内
3.4 启动php-fpm ！！！ 很重要 不然nginx启动服务 nginx也会说你403 或者 404
which php-fpm 找到路径 然后直接把路径copy 输入一遍就可以了
3.5 ps -ef | grep php-fpm 查找端口是否成功,发现多了三个/usr/local/opt/php内的php-fpm，表明成功启动了php-fpm。但是，还得将他设为开机自启动，否则终端关闭 服务也关闭了 又报 404了
3.6 设为开机自启动 mkdir -p ~/Library/LaunchAgents cp /usr/local/opt/php56/homebrew.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4d012ac7c65dcfa44a83876b87d91ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e804b2347fc74e7650ef81a0e9e8f5/" rel="bookmark">
			layabox快捷键设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ctrl+? 一键屏蔽 ctrl+b 打开资源管理器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0f5c9b058e350fc8d1e0aec636a0fa4/" rel="bookmark">
			npm 安装、删除依赖命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm安装依赖 【npm install xxx】利用 npm 安装xxx依赖到当前命令行所在目录【npm install xxx -g】利用npm安装全局依赖xxx 【npm install xxx –save】 安装并写入package.json的”dependencies”中【npm install xxx –save-dev】安装并写入package.json的”devDependencies”中 npm删除依赖 【npm uninstall xxx】删除xxx依赖【npm uninstall xxx -g】删除全局依赖xxx 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/395d1a4b0fafc6320258fa6670e32814/" rel="bookmark">
			引入外部js文件的加载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日做了一个阿里云点播的上传和播放，需要在JSP页面中引入阿里云点播提供的js文件，通过&lt;script&gt;标签将需要的js引入。
在dom加载完成之后执行$(function(){})中的代码去创建阿里云的js提供的对象，结果却报错了：说阿里云提供的一个js对象没有定义。很奇怪，js文件明明引入了，而且通过F12的NetWork可以看到文件引入也是成功的，这是为什么呢？
原因在于$(function(){})中的代码的执行时机仅仅是在dom的结构全部加载完成之后，而不是在dom中的所有外部资源(js、图片等)加载完成之后执行，此时可以使用window.onload来代替$(function(){})，因为window.onload是在dom结构及其外部资源全部加载完成之后才会执行的。
还有一种方式将js的引入放在&lt;body&gt;标签中而不是&lt;head&gt;中，&lt;body&gt;中的内容是从先向后同步加载的，&lt;head&gt;中则可能会异步加载。
按说还有一种方式：在引入外部js的&lt;script&gt;标签中指定其async属性为false，即&lt;script async="false" src="..."&gt;&lt;/script&gt;将外部js文件的加载改为同步加载，此时再使用$(function(){})就没有问题了，这说明dom中引入的外部资源的加载方式默认是异步的，但却没什么卵用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34ce88f0bf180cb80ba325a81ec60237/" rel="bookmark">
			DATASTAGE运行job时出现数据库错误解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.截断表出错 错误描述： main_program: Fatal Error: 截断表时出错。语句 = DELETE FROM 表名 错误原因：表处于暂挂状态 错误解决办法： a.远程连接数据库服务器（****）--用户*,密码* b.点击运行，输入db2cmd c.db2 connect to 数据库名 user 用户名 using 密码 d.db2 load from E:\b.txt of del terminate into 表名 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db8c68b971c9892eb26abbbef66c6fd3/" rel="bookmark">
			mysql: ERROR 2003 (HY000) 错误解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在确保安全策略组端口通过、Grant也没有问题的情况下。
show grants for user; 如果不行:
GRANT ALL PRIVILEGES ON *.* TO 'user'@'172.21.16.%' IDENTIFIED BY 'password' WITH GRANT OPTION; flush privileges; 检查是否有bind_address,网上很多人说在my.cnf中检查，但是mysql 5.7默认不在这个里面。 靠谱的检查方法
show variables like 'bind_address'; 如果确实绑定了127.0.0.1, 去查一下/etc/mysql/mysql.conf.d/mysqld.cnf，如果里面有问题结局。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db1bbc2622490ec117f24c90931caf7/" rel="bookmark">
			python  求阶乘之和。求1&#43;2!&#43;3!&#43;...&#43;20!的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阶乘：也是数学里的一种术语；阶乘指从1乘以2乘以3乘以4一直乘到所要求的数；在表达阶乘时，就使用“！”来表示。如h阶乘，就表示为h!；阶乘一般很难计算，因为积都很大。
一、参考解法：
分析：1、阶乘的计算：用递归函数实现是比较好的方案，先定义一个递归函数实现求阶乘功能。
def recursion(n): #'定义递归函数实现求阶乘功能' if n==1: return 1 else: return n*recursion(n-1) 分析：2、求和：（1）可以直接求和 。（2）也可以定义一个列表，将for遍历得到的阶乘结果追加到列表，然后使用sum()函数求和。
Sum=0 print("for循环直接调用递归函数求和".center(80,"*")) for i in range(1,21): Sum +=recursion(i) print(Sum) 列表求和方案： list=[] #定义一个空的列表，将调用递归函数生成的阶乘值追加到列表 print("将1-20的阶乘写入列表，使用sum函数求和".center(80,"*")) for i in range(1,21): list.append(recursion(i))# 将调用递归函数生成的阶乘值追加到列表 print(sum(list)) #列表求和 【完整源代码】以及结果：
def recursion(n): #'定义递归函数实现求阶乘功能' if n==1: return 1 else: return n*recursion(n-1) list=[ ] #定义一个空的列表，将调用递归函数生成的阶乘值追加到列表 for i in range(1,21): list.append(recursion(i))# 将调用递归函数生成的阶乘值追加到列表 print(sum(list)) #列表求和 Sum = 0 for i in range(1,21): Sum +=recursion(i) print(Sum) 结果： 2561327494111820313 二、参考解法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2db1bbc2622490ec117f24c90931caf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee18b0752dd9af823e9a084dce6f2707/" rel="bookmark">
			我为何一直强调外包公司别去
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「 不是针对外包 」
我为何一直对外包公司如此大的怨念？其实不是，外包公司也是公司，也是凭本事和技术挣钱，无论在道德、心理、合法性层面都没有任何意义的客观错误。
之所以我总给大家强调不要选外包公司，一是这么多年经验以来有感而发，二是最近面试的人比较多，尤其金三银四的时候，积攒了一些想法想写出来，供大家参考避坑。
其实我面试比较简约，之前也写过，有兴趣可以看看，[谈谈我面试别人的教训和总结]
先说说 被刷下去的面试者中 我主要分为典型的三类
1. 培训班大忽悠
2. 非科班出身
3. 长期外包公司
第一种 培训班出来的目前大部分公司也不是绝对不要，天份好、肯努力的从培训班出来的也有很多不错的，发展甚至比一些科班出身的还要厉害。但还有一种滥竽充数的，简历大忽悠，明明刚毕业说已经工作2-3年了，简历和技术栈也是写的有模有样，听说有的培训机构专门有一节课，甚至最后半个月就是培训怎么忽悠和迷惑面试官的，总之拿到offer就行。
像这种面试者，目前问几个问题就可以考察出来，能力和思想、经历是怎么样的，肯定直接就刷下去了。
第二种 非科班出身的，并不是说计算机专业的就一定牛逼，但是既然是IT行业编程，肯定计算机专业的优先，因为知识体系和基础架构在大学已经形成，学任何语言和框架 包括算法 不会很费劲。
但你要让会计专业的或者外语专业的 来中途转行程序员，这就对他们有难度了，因为首先逻辑能力就不行，再者一些很基础解决问题的思路也不如计算机专业的好，因为学的专业都不一样，肯定解决问题的思路的起点就不一样，会费很大成本来培养，所以一般不是很优秀的也会被刷下去。
「 外包公司不能长时间呆 」
我们今天说的第三种从业者，外包公司出来的，为什么多数从外包公司跳槽的都会被拒呢？
很多人尤其新手从业者有个误区：外包公司不是做项目很多吗？那肯定学的多，经验积累快啊，而且框架繁多肯定有好处。其实这就是问题所在，外包公司的工作性质决定了做任何项目都是给第三方做的，给甲方做的，给甲方做加工者。
说白了，只为老板的钱负责，不为项目本身内部质量负责，为何称之为外包项目，从甲方角度来讲：外包外包就是从外包找人把麻烦活儿包出去，从外包公司来讲：接外包接外包就是把别人不想做或者来不及做的麻烦活儿接过来，赚点辛苦钱，人海战术嘛，一般外包项目都很赶时间，所以项目经理带一班人使劲堆人就行了。
基本都是用很老、很成熟的技术体系，套需求，外包主要是明白和谈拢需求，然后就开工，时间紧是吗？行，凑人，甲方一般不管你用什么技术、新鲜活儿，只要按我要求和时间点交工让我能用就成。所以你觉得你所在的外包公司会像其他做自己产品的IT公司一样对你各种要求和规范吗？
所以，你压根没时间去研究代码架构和规范编码规范，这对你的职业生涯是致命的起点缺陷，一开始就不严格要求和约束自己的代码习惯和能力，将是后患无穷。这还不是致命的，期间你做一个功能，基本全是搜索、粘贴、 复制，要么是网络上的，要么是之前公司早已经写好千百遍的代码块，你想自己写一写东西都没机会，因为老大会告诉你 不 需 要！快点赶工期啊，小皮鞭抽起来！
而且，基本接项目都是接现在公司有的技术体系的项目，因为业务越接近，可复制越快，成本越低，重复劳动嘛，就像富士康流水线，码农们照着模版复制、加工、拧螺丝就行了，外包公司同理，所以大家知道有什么弊端了吗？
长此以往，不但技术和思想没有进步，还会形成和社会脱节的倾向，因为外包公司从来没时间给员工做技术培训和职业培养，因为他们只想着工期、尾款、项目奖金。
「 结论 」
不要觉得平时公司对代码规范和一些职业习惯，还不停催促你学习和使用新技术感到烦恼和厌恶，其实这是对你好，我们的行业一周不学习，你可能就一点点失去竞争力。
尤其第一份工作，务必要最大限度的找有自己产品的公司，哪怕十几人小公司，如果有产品也比几百人的外包强太多，因为做自己产品的公司，不舍得把自己的产品做的很粗糙，而且也更容易使用新技术。代码和规范也更正规，一般也会有人带你，潜移默化会对你形成一种好的影响，对将来跳槽和工作都有好处。
如果现在就在外包公司呆的朋友，看到此篇，也请警示，想一想自己已经写了多少时间的重复代码了？是不少该更新和学习新技术了？你如果现在出去还有竞争力吗？也希望看到此篇的，觉得好多转发，争取拯救更多芸芸众码农！
热门阅读：
1. 低学历者已无法生存 程序员尤其明显
2. 又有朋友被骗入传销了！
人帅、活好、三观正
长按扫码关注我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac4188e5801fda13c082e1789d32ebf/" rel="bookmark">
			安卓游戏内购破解之滚动的天空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 继《教我兄弟学Android逆向02 破解第一个Android程序》之后根据大神的帖子，实现破解一款游戏 内购！ 工具：依旧是Android Killer1.3.1.0 + JDK1.7
1.下载滚动的天空 链接: https://pan.baidu.com/s/1qslAz9Owq7ioOb228d6nIg 密码: d88c
2.使用Killer1.3.1.0打开apk，进行搜索“支付失败",转换为unicode
然后会出现3个结果，选择pay的
双击打开！直接使用替换大法，把支付成功的代码覆盖掉原来支付失败后执行的代码
支付失败的方法
支付成功的方法
接下来保存-编译-安装-运行，效果如下！
破解前： 破解后 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ed43e8ea2cc5dd26957aa52b4c79524/" rel="bookmark">
			Matlab 之norm函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab函数norm有两种形式：
1.n = norm(X)
2.n = norm(X,p) ，p - 范数
其中，n = norm(X) 与 n = norm(X,2)相同。
a = [1 -1.2;2 3];
n1 = norm(a);
n2 = norm(a,2);
n1 = 3.6383;n2 = 3.6383;
p = 2 时，2范数的计算
n = sqrt(max(max(eig(X*X')))); 其中，eig(X*X')是求矩阵X乘X转置的特征值；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d5e438b4bdebdae21d00ce5ef4b0bb/" rel="bookmark">
			1、Hbase原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Hadoop生态系统 Zookeeper分布式监控中心: HDFS的NameNode和MapReduce高可用。 zookeeper内部维护一个内存数据库。 存储Hbase一些数据（后续再谈）MapReduce:分布式计算框架Hive:数据仓库HBase:非关系型数据库HDFS:分布式文件系统Flume:日志收集工具（离线分析，离线数据处理）Sqoop:关系数据ETL工具(非关系型数据与关系型数据转换工具）Mahout:数据挖掘（将机器学习算法通过MapReduce做开源实现，可以通过MapReduce进行分析，提高效率）Pig(淘汰):数据流处理语言，通过编写sql脚本分析HDFS数据。Shark(淘汰):类似于Pig。 2.HBase简介 Hbase-Hadoop Database是一个高可用、高性能、面向列、可伸缩、实时读写的分布式数据库 。
可伸缩：可根据负载增减节点。
面向列：相对于行式数据库，空间利用率高。
利用HadoopHDFS作为其文件存储系统，利用Hadoop MapReduce来处理HBase中的海量数据，利用Zookeeper作为分布式协同服务。
主要用来存储非结构化和半结构化数据。
3.HBase优点 HBase是一种构建在HDFS之上的分布式、面向列的存储系统。在需要实时读写、随机访问超大规模数据集时，可以使用HBase。
尽管已经有许多数据存储和访问的策略和实现方法，但事实上大多数解决方案，特别是一些关系类型的，在构建时并没有考虑超大规模和分布式的特点。许多商家通过复制和分区的方法来扩充数据库使其突破单个节点的界限，但这些功能通常都是事后增加的，安装和维护都和复杂。同时，也会影响RDBMS的特定功能，例如联接、复杂的查询、触发器、视图和外键约束这些操作在大型的RDBMS上的代价相当高，甚至根本无法实现。
HBase从另一个角度处理伸缩性问题。它通过线性方式从下到上增加节点来进行扩展。HBase不是关系型数据库，也不支持SQL，但是它有自己的特长，这是RDBMS不能处理的，HBase巧妙地将大而稀疏的表放在商用的服务器集群上。
HBase 是Google Bigtable 的开源实现，与Google Bigtable 利用GFS作为其文件存储系统类似， HBase 利用Hadoop HDFS 作为其文件存储系统；Google 运行MapReduce 来处理Bigtable中的海量数据， HBase 同样利用Hadoop MapReduce来处理HBase中的海量数据；Google Bigtable 利用Chubby作为协同服务， HBase 利用Zookeeper作为对应。
大：一个表可以有上亿行，上百万列。
面向列：面向列表（簇）的存储和权限控制，列（簇）独立检索。
稀疏：对于为空（NULL）的列，并不占用存储空间，因此，表可以设计的非常稀疏。
无模式：每一行都有一个可以排序的主键和任意多的列，列可以根据需要动态增加，同一张表中不同的行可以有截然不同的列。
数据多版本：每个单元中的数据可以有多个版本，默认情况下，版本号自动分配，版本号就是单元格插入时的时间戳。
数据类型单一：HBase中的数据都是字符串，没有类型。
4.Hbase数据模型 RowKey：用于唯一标识Hbase中的一条数据（记录），不可重复，按照字典顺序排序，只能存储64k的字节数据，因此一般要求设计RowKey要简短。TimeStamp：HBase自动赋值时间戳(也可自己实现)，作为版本号，64位整型。Hbase每个cell存储单元（k:v）对同一份数据有多个版本，通过实践戳来区分版本之间的差异，按时间倒叙排序。CF(ColumnFamily):列族，可包含多列。权限控制，存储以及调优都是在列族层面进行的。HBase把同一列族里面的数据存储在同一目录下，由几个文件保存（StoreFile）。Column:列，对应key，一列可以在多个版本中维护不同数据。Value:数据。Cell:是未解析的字节数组。由{rowkey, column(=&lt;family&gt;+&lt;qualifier&gt;),version}唯一确定的单元。由rowkey，列族，列，版本唯一确定一个单元。中的数据，没有类型，全部是字节码形式存储。 5.Hbase体系结构 Client:
包含访问HBase的接口并维护catch来加快对Hbase访问。
再谈Zookeeper:
保证任何时候，集群中只有一个master。
保存所有Region的寻址入口。
实时监控Region Server的上下线信息。并通知Master.
存储HBase的schema和table元数据
Master:
为RegionServer分配Region
负责 RegionServer的负载均衡
发现失效的RegionServer并重新分配到其他RegionServer工作。（KeepAlive）
管理用户对table的增删改查（只负责请求传递）
RegionServer:
维护多个region，处理对这些region的IO请求，真正的增删改查操作。
水平切分运行中变得过大的region(裂变，尽量等分)。
Region:
每个region保存表中某段连续的数据(多行)，每个表一开始只有一个region，随着数据量不断增加，region增大，
当 达到一个阈值时，region就会被regionServer水平切分成两个新的region.
当region很多时，将会保存到其他regionServer上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d5e438b4bdebdae21d00ce5ef4b0bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5e6f19c6e7fe053c41b1bd5ddd6791/" rel="bookmark">
			ssh配置-使用本地多个私钥连接多个账户的github rsa认证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssh配置多个域多个账号 在一台电脑上配置git 多个账号私钥 需求: 有多个git账号, 要在本地使用ssh登录, 默认只使用~/.ssh/id_rsa 私钥, 也就是只能一个账号能使用, 而且, 还不是只有github, 还有gitee, gitlab 等, 那么会有很私钥 解决方式下面提供两种 第一种:通过ssh-add 把私钥添加到ssh-agent session中, 这种仅仅是临时的, 会话级别, 每次使用都要添加一下, 比较麻烦,但是呢, 可以把执行的命令, 写成自动动化的, 让自动执行. 第二种: 通过配置~/.ssh/config 配置文件来达到效果 # 具体: 不要用windows CMD 用git bash # 首先生成公钥跟私钥 (ssh-keygen 在git安装目录下的usr/) ssh-keygen -t rsa -f ~/.ssh/github_itkuke -C "itkuke@163.com" ssh-keygen -t rsa -f ~/.ssh/id_rsa -C "244013508@qq.com" 将公钥内容, 添加到对应(github, gitee, gitlab) 等远程服务器SSH keys 中, 然后进行下面的操作 (不要复制,复制的会有问题, 建议使用输出重定向方式追加到/home/git/.ssh/authorized_keys中)
例: cat github_phpzx_rsa.pub &gt;&gt; /home/git/.ssh/authorized_keys 第一种参考: # 将github_itkuke私钥添加到ssh-agent 的session中 # 会话级别, 只在当前客户端管用, 重打开一个不管用, 重启后也失效 eval `ssh-agent` ssh-add ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d5e6f19c6e7fe053c41b1bd5ddd6791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e76b9d29fcda1f806936f4d84ffdd3/" rel="bookmark">
			解释性语言和编译性语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解释性语言和编译型语言的区别和不同 解释性语言编译型语言概念计算机不能直接的理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言的编写的程序。翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。特征解释性语言的程序不要编译，省了道工序，解释性语言在运行程序的时候才翻译，比如解释性Java语言，专门有一个解释器可以直接执行Java程序,每一个语句都是执行的时候才能翻译。这样解释性语言每执行一次要翻译一次，效率表较低。编译型就是编译的时候直接编译成机器可以执行的（.exe .dll .ocx）,编译和执行是分开的，但是不能跨平台。例如Delphi,C++,ASM,C是直接变异成exe文件并且自带条件编译功能。比如exe文件，以后要运行的话就不用重新编译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行的时不要翻译，所以编译型语言的程序执行效率高。区别对于解释性语言而言，程序运行时的控制权在解释器(jre,.net)而不再用于程序。对于编译器而言，运行时的控制权在用户程序。一些网页脚本，服务器脚本以及辅助开发接口这样的对速度要求不高，对不同系统的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python、Ruby、Matlab等等。编译语言由于程序执行速度快，同等条件下对系统的要求比较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++,Pascal/Object Pascal(Delphi)等都是编译型语言。解释型语言，例如Java语言，Java程序首先通过编译器编译成class文件，如果在Windows平台上运行，则通过Windows平台上的Java虚拟机（VM）进行解释。如果运行在Linux平台上，则通过Linux平台上的Java虚拟机进行解释执行。所以说能跨平台，前提是平台上必须要有相匹配的Java虚拟机。如果没有Java虚拟机，则不能进行跨平台。编译型语言，例如C语言,用C语言开发程序后，需要通过编译器把程序编译成机器语言（即计算机可以识别的二进制文件，因为不同的操作系统识别的二进制文件是不同的），所以C语言程序进行移植后，需要重新编译（如Windows编译成ext文件，Linux编译成erp文件）总结优点：可移植性好，只要有解释环境，可以在不同的操作系统上运行。比如在解释执行时可以动态改变变量的类型、对程序进行修改以及在程序中插入良好的调试诊断信息等，而将解释器移植到不同的系统上，则程序不用改动就可以在移植了解释器系统上运行。优点：运行速度快，代码效率高，编译后程序不可以修改，保密性好。缺点：运行需要解释环境，运行起来比编译的要慢，占用的资源也要多一些，代码效率低，代码修改后就可以运行，不需要编译过程。因为不仅要给用户程序分配空间，解释器本身也占用了宝贵的系统资源。其封装底层代码，程序严重依赖平台。不能同C++，VB那样直接操作底层。缺点：代码需要经过编译方可运行，可移植性差，只能在兼容的操作系统上运行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/142db2cde39ccfd0803b12cf30252a61/" rel="bookmark">
			Linux下 OSG开发，影像没有纹理问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在Centos下用OSG加载影像和三维场景，一直没有纹理，在QT上通过后台查看发现一个警告“detected Opengl error:'invalid enumerant' at after randerer::compile”，发现是OpenGL的问题，然后在Centos对相关OpenGL库进行安装和更新。其实在Linux下只要安装了Mesa和freeglut就可以了。
yum install freeglut
yum install mesa*
进行安装就可以了，安装好后，可以通过yum list Mesa*进行查看和Mesa相关的Lib和开发包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/401bb2b5692b166851379fdd321254bf/" rel="bookmark">
			git stash详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景： 1 当正在dev分支上开发某个项目，这时项目中出现一个bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用git stash命令将修改的内容保存至堆栈区，然后顺利切换到hotfix分支进行bug修复，修复完成后，再次切回到dev分支，从堆栈中恢复刚刚保存的内容。 2 由于疏忽，本应该在dev分支开发的内容，却在master上进行了开发，需要重新切回到dev分支上进行开发，可以用git stash将内容保存至堆栈中，切回到dev分支后，再次恢复内容即可。 总的来说，git stash命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，stash中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。
命令详解： 1 git stash 能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。
$ git status On branch master Changes not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: src/main/java/com/wy/CacheTest.java modified: src/main/java/com/wy/StringTest.java no changes added to commit (use "git add" and/or "git commit -a") $ git stash Saved working directory and index state WIP on master: b2f489c second $ git status On branch master nothing to commit, working tree clean 2 git stash save 作用等同于git stash，区别是可以加一些注释，如下： git stash的效果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/401bb2b5692b166851379fdd321254bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc18d62cdd79c8656904ddb9b7f35e1/" rel="bookmark">
			Spring常用配置 - Bean的Scope
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scope描述的是Spring容器如何新建Bean的实例的。Spring的Scope有以下几种，通过@Scope注解来实现。
1. singleton：Spring的默认设置。一个Spring容器只有一个该Bean的实例。
2. prototype：每次调用，均新建一个Bean的实例。
3. request：web项目中，给每个http request新建一个bean的实例。
4. session：web项目中，给每个http session新建一个bean的实例。
5. globalsession：这个只在portal应用中有用。给每个global http session 新建一个bean的实例。
另外，在spring batch 中还有一个scope，即使用@stepscope.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8737b6578baf3d0ea66a64b0696faa6d/" rel="bookmark">
			centos服务器部署hexo（简版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前阿里云的服务器到期了，又新买的阿里云服务器，重新部署一下hexo，记录！
1、首先，进行服务端的系统更新，待更新完系统之后再进行以下操作。输入：
# yum update -y 注：-y：对所有的提问都回答“yes”； 更多yum的参数详解：yum命令
2、安装Git，输入：
# sudo yum install git-core // 查看版本 # git version // 输出 git version 1.8.3.1 3、安装Node.js，输入：
# yum install -y nodejs // 查看版本 # node -v // 输出 v6.14.2 4、安装hexo，输入：
// 初始化安装 # npm install hexo-cli -g ！！！报错： npm: relocation error: npm: symbol SSL_set_cert_cb, version libssl.so.10 not defined in file libssl.so.10 with link time reference @@@解决方法： # openssl version // 输出 OpenSSL 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8737b6578baf3d0ea66a64b0696faa6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223a0bc0639e7a5b7240c52c1fa61f72/" rel="bookmark">
			基于万方论文数据的知识管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.系统源码和使用方法见GitHub链接。。。 https://github.com/snowlixue/wanfangPaperSystem 2.系统爬取数据和清洗的方法见博客https://blog.csdn.net/dreamtheworld1/article/details/80634611 这里没有使用爬取下的全部数据。 3.系统主要用词向量模型来进行相似文章的推荐。 词向量是用来表示词的向量，通常也被认为是词的特征向量。关于词向量推荐可以参照其他博客。 首先使用hanlp包进行实体抽取。hanlp关键词抽取使用的是TextRank方法。 词向量使用Word2VEC进行训练。训练后为.bin .model或无后缀名文件。 关键词抽取和推荐代码如下：
Word2VECKeyWords.java
public static String[] getDistanceWord(String word) { Word2VEC w1 = new Word2VEC() ; try { w1.loadJavaModel("D:\\workspace\\eclipse-workspace\\cnki\\library\\AbstractVector") ; } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } String[] distance = new String[2]; distance[0] = (w1.distance(word).toArray()[0].toString()); distance[1] = (w1.distance(word).toArray()[1].toString()); return distance; } CnkiInfoImpl.java
// TODO Auto-generated method stub List&lt;Map&gt; selectCnki = new ArrayList&lt;Map&gt;(); //调dao里的方法 List&lt;CnkiinfoPO&gt; updateid = cdao.updateid(po); String needResult = updateid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/223a0bc0639e7a5b7240c52c1fa61f72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2683952f66ab21958ac1ec906d99fb79/" rel="bookmark">
			Linux（Ubuntu18.04）和Windows10 之间的局域网文件传输
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的时候当你需要同时使用windows和Ubuntu时，存在两者之间的文件传输或者通信问题。大多数采用移动硬盘、U盘间接传输的方式，或者干脆使用虚拟机拖拽到同类型系统内的工具传输。有没有简单一点的方法轻松地把Windows文件放到Ubuntu或者反过来。当然，使用WinSCP软件。
1、
下载地址：https://winscp.net/eng/download.php
下载好以后双击安装就不说了。。。之后需要重启！！
2、
Ubuntu执行命令安装SSH服务：sudo apt-get install openssh-server
3:、登录
点击新建站点，主机名输入Ubuntu的IP地址，用户名哪一行是Ubuntu的登录用户名和对应密码，点击登录即可。
然后就可以嚣张的左右拖拽了。非常方便！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84d4ba5d101f29250b09acd9301c625b/" rel="bookmark">
			嵌入式学习笔记（六） --程序的编译和执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者前面已经学过了Linux的基本命令，vi编辑器的使用。那么当我们编辑好一个.c文件时，如何执行它呢！？
要知道一个程序跑起来要经过编译和运行两大过程。编译将源代码生成可执行文件，然后执行查看结果。
一、gcc编译器 gcc(GNU Compiler)是GNU推出的多平台编译器，可将C、C++源程序编译连接成可执行文件，支持以下后缀：
.c c语言源代码
.h 程序所包含的头文件
.i 已经预处理过的C源代码文件
.s 汇编语言源代码文件
.o 编译后的目标文件
二、使用方法 1. gcc –o hello hello.c
-o 输出可执行文件 -c 只要求编译器输出目标代码（.o文件），而不必输出可执行文件 -g 用于调试 hello是可执行文件的名字（如果没有填写hello 默认是a.out），hello.c是你要编译的代码！
2. ./hello 查看输出结果
三、程序 编辑--编译--执行--调试 的完整过程 1.通过vi编辑器将程序写好 2.使用gcc编译器编译 3.执行查看结果 4.如果有错误（代码错误或者是逻辑错误），再返回去改正 5.再编译执行....直到成功 问：有没有搞错，我的程序是要在板子上运行的，为什么到你这就编程纯Linux机上开发了！！？
答：gcc实际上是一个编译器集，因为它不仅支持 C 语言编译，还支持 C++， Ada，Objective C 等许多语言。另外 GCC 对硬件平台的支持，可以所无所不在，它不仅支持 X86处理器架构, 还支持 ARM, Motorola 68000, Motorola 8800，AtmelAVR，MIPS 等处理器架构。arm-linux-gcc 是基于 ARM 目标机的交叉编译软件，可以通过arm-linux-gcc完成 linux-arm的开发，所以只是换了一个编译器，同时c开发性质不变。
相关链接
嵌入式学习笔记（一） --Ubuntu开发环境搭建 ：https://blog.csdn.net/feit2417/article/details/80738940
嵌入式学习笔记（二） --Ubuntu上配置vim编辑器和共享文件 ： https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84d4ba5d101f29250b09acd9301c625b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a438e8a0a0948ec45ea202f5a22afed/" rel="bookmark">
			嵌入式学习笔记（五） --vi编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔者已经基本了解了通过Linux命令对文件和目录的相关操作，可要对文件进行编辑，还得用到VI编辑器。熟悉VI编辑器的使用对今后的开发十分重要！！
vi是Linux中最基本的编辑器。但vi编辑器在系统管理、服务器配置工作中永远都是无可替代的。
目标：
熟悉vi的三种模式及模式切换命令熟练使用vi的拷贝、剪切和粘贴命令熟练使用vi的保存和退出命令熟练使用vi的光标命令熟练使用vi的查找命令熟练使用vi的替换命令 一、vi有以下三种模式 命令行模式 用户在用vi编辑文件时，最初进入的为该模式。可以进行复制、粘贴等操作。
插入模式 进行文件编辑，按ESC键可以回到命令行模式。
底行模式 光标位于屏幕的底行。可以进行文件的保存、退出、查找、替换、列出行号等 二、如何进入/保存退出vi编辑器以及模式之间是如何切换的？ 进入vi编辑器：如果我们想要对一文件进行编辑修改，进入这个文件目录，在命令终端输入 vi [文件名] 即可
模式转换：如果在插入模式下，按ESC键可以回到命令行模式；在命令行模式下，按下 i 键 进入插入模式；底行模式在编辑器窗口最下方，按下 ： 定位光标到底行。
其中命令行模式，这个模式下用户不能对文件内容进行修改。
保存和退出vi编辑器：通过底行模式，进行。相关命令如下
:q (Quit)退出没有修改的文件（若文件被修改了而没有保存，则此命令无效） :q! 强制退出，且不保存修改过的部分 :w (Write)保存文件，但不退出 :x (Exit)保存文件并退出 :w File 另存为File给出的文件名，不退出 :r File (Read)读入File指定的文件内容插入到光标位置 三、常用命令 正常来说，进到插入模式后，就可以对文件内容进行改动了，就打字一样方便。但因为在终端模式下，我们需要一些命令来代替鼠标完成一些比如复制粘贴的功能。
vi拷贝与粘贴命令(命令行模式下)
[N]x (Expurgate)删除从光标位置开始的连续N个字符（并复制到编辑缓冲区） [N]dd (Delete)删除从光标位置开始的连续N行（并复制到编辑缓冲区） [N]yy (Yank)复制从光标位置开始的连续N行到编辑缓冲区 p或P (Put)从编辑缓冲区复制文本到当前光标位置（即粘贴） u (Undo)取消上一次操作（即恢复功能） y0-将光标至行首的字符拷入剪贴板 y$-将光标至行尾的字符拷入剪贴板 d0-将光标至行首的字符剪切入剪贴板 d$-将光标至行尾的字符剪切入剪贴板 range y-块复制 range d-块剪切 vi光标命令(命令行模式下)
h 方向键，向左移动光标一个字符的位置，相当于键“←” j 方向键，向下移动光标到下一行的位置，相当于键“↓” k 方向键，向上移动光标到上一行的位置，相当于键“↑” l 方向键，向右移动光标一个字符的位置，相当于键“→” :N 移动光标到第N行（N待定） 1G 移动光标到文件的第1行 G 移动光标到文件的最后1行 :set number 设置显示行号 :set nonumber 取消显示行号 vi的查找命令(命令行模式下)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a438e8a0a0948ec45ea202f5a22afed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ff721390a7c45e8b78dd638ad62bf73/" rel="bookmark">
			python 简单的push pop实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 只是简单的实现，没有对边界情况进行处理，大家可以自己处理一下，比如说栈为空时不得弹出，也可以设置一下栈的大小，当栈满了将会溢出。还有就是输入不为push和pop的情况，或者用户不想用固定的列表[1,2,3]作为进出栈的数据，也可以改写手动输入数据值。这里只是提供一个简单的思路
# simple push and pop a = [1,2,3] void_lst = [] def push_pop(my_str,i): if my_str == 'push': void_lst.append(a[i]) print void_lst[len(void_lst)-1] elif my_str == 'pop': print void_lst[len(void_lst)-1] new_lst = void_lst[:-1] return new_lst else: pass def get_top(): print void_lst[len(void_lst)-1] count = -1 for i in range(10): my_str = raw_input('please input') if my_str == 'push': count += 1 push_pop(my_str,count) elif my_str == 'pop': count -= 1 void_lst = push_pop(my_str,count) else: pass 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e8cc978582590447c3a57d4257978b1/" rel="bookmark">
			最全的反爬虫技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反爬虫 的技术大概分为四个种类：
注：文末有福利！
传统反爬虫手段
1、后台对访问进行统计，如果单个IP访问超过阈值，予以封锁。
这个虽然效果还不错，但是其实有两个缺陷，一个是非常容易误伤普通用户，另一个就是，IP其实不值钱，几十块钱甚至有可能买到几十万个IP。所以总体来说是比较亏的。不过针对三月份呢爬虫，这点还是非常有用的。
2、后台对访问进行统计，如果单个session访问超过阈值，予以封锁。
这个看起来更高级了一些，但是其实效果更差，因为session完全不值钱，重新申请一个就可以了。
3、后台对访问进行统计，如果单个userAgent访问超过阈值，予以封锁。
这个是大招，类似于抗生素之类的，效果出奇的好，但是杀伤力过大，误伤非常严重，使用的时候要非常小心。至今为止我们也就只短暂封杀过mac下的火狐。
4、以上的组合
一、通过User-Agent来控制访问： 无论是浏览器还是爬虫程序，在向服务器发起网络请求的时候，都会发过去一个头文件：headers，比如知乎的requests headers:
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8 Accept-Encoding:gzip, deflate, sdch, br Accept-Language:zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4,da;q=0.2,la;q=0.2 Cache-Control:max-age=0 Connection:keep-alive Cookie: ********** Host:http://zhuanlan.zhihu.com Referer:Ehco - 知乎 Upgrade-Insecure-Requests:1 User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36 Query String Parameters view source view URL encoded 这里面的大多的数的字段都是浏览 这里面的大多数的字段都是浏览器向服务器”表明身份“用的
对于爬虫程序来说，最需要注意的字段就是：User-Agent
很多网站都会建立 user-agent白名单，只有属于正常范围的user-agent才能够正常访问。
比如知乎：
import requests import bs4 import random def get_html(url): try: r = requests.get(url, timeout=30) r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e8cc978582590447c3a57d4257978b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7051dc52c184c205e39aa54b4664ae9b/" rel="bookmark">
			笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人们总是想找到一个抽象理论，能够适应所有的问题，能够使自己感觉到自由，然而，这种想要想通一切的冲动只是大脑自以为是的幻想；
规则，弄清楚看得见的范围内的联系和规律，这种思考是由外而内的，联想的事情更倾向于自由和由内而外的；
引用文章：计算机科学是什么：
https://xiaogd.net/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f590bd5e7d756be2436de9e6d7662e61/" rel="bookmark">
			左值、左值引用、右值、右值引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 转载自：http://www.cnblogs.com/SZxiaochun/p/8017475.html 左值、左值引用、右值、右值引用 1、左值和右值的概念 左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体； 右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。 一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。
2、引用 引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。
引用可以改变指针的指向，还可以改变指针所指向的值。 引用的基本规则： 声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义； 对引用的一切操作，就相当于对原对象的操作。 3、左值引用和右值引用 3.1 左值引用 左值引用的基本语法：type &amp;引用名 = 左值表达式；
3.2 右值引用
右值引用的基本语法type &amp;&amp;引用名 = 右值表达式； 右值引用在企业开发人员在代码优化方面会经常用到。 右值引用的“&amp;&amp;”中间不可以有空格。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49a7d05bf08cae6acbc560b8016a017c/" rel="bookmark">
			Android 仿搜索历史记录，根据item内容自动换行，涉及动态添加布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据排列RecyclerView可以解决大部分问题，有一种情况：比如：商城的搜索历史记录，因为输入字符的长短不同，RecyclerView处理列数的时候，比较麻烦，如图：
解决方案：自定义View：
/** * Created by Administrator on 2018/6/20. * 自动换行 */ public class WarpLinearLayout extends ViewGroup { private Type mType; private List&lt;WarpLine&gt; mWarpLineGroup; public WarpLinearLayout(Context context) { this(context, null); } public WarpLinearLayout(Context context, AttributeSet attrs) { this(context, attrs, R.style.WarpLinearLayoutDefault); } public WarpLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); mType = new Type(context, attrs); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int withMode = MeasureSpec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49a7d05bf08cae6acbc560b8016a017c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd64480f3c14ff27afea503ca0427b52/" rel="bookmark">
			shell访问远程主机方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、传统ssh公私密钥授信，免密登录；
网上文档一堆，不罗嗦了
2、expect交互登录
#!/bin/expect set timeout 30 spawn ssh -l jikuan.zjk 10.125.25.189 expect "password:" send "zjk123\r" interact 注意：expect跟bash类似，使用时要先登录到expect，所以首行要指定使用expect 在运行脚本时候要expect file，不能sh file了
上面语句第一句是设定超时时间为30s，spawn是expect的语句，执行命令前都要加这句
expect "password："这句意思是交互获取是否返回password：关键字，因为在执行ssh时会返回输入password的提示：jikuan.zjk@10.125.25.189's password:
send就是将密码zjk123发送过去
interact代表执行完留在远程控制台，不加这句执行完后返回本地控制台 3、sshpass带密码登录
sshpass -p user_password ssh user_name@192.168..1.2
sshpass 参数 SSH命令(ssh，sftp，scp等)。 参数: -p password //将参数password作为密码。 -f passwordfile //提取文件passwordfile的第一行作为密码。 -e //将环境变量SSHPASS作为密码。 比如说： scp abc@192.168.0.5:/home/xxx/test /root 这个命令的作用是将服务器端文件test传到本地文件夹/root下。 利用sshpass，假设密码为efghi，则可写作： ssh -p efghi scp abc@192.168.0.5:/home/xxx/test /root 另外，对于ssh的第一次登陆，会提示：“Are you sure you want to continue connecting (yes/no)”，这时用sshpass会不好使，可以在ssh命令后面加上 -o StrictHostKeyChecking=no来解决。比如说上面的命令，就可以写作ssh -p efghi scp abc@192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd64480f3c14ff27afea503ca0427b52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/848eabe19b5450ad6b78928b5a54ec50/" rel="bookmark">
			大数定理和中心极限定理的通俗理解。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一直觉得大数定理和中心极限定理很神秘，很模糊。这次下决心来搞一个彻底清楚，研究一下。
先介绍一下大数定理。网上查了一下由下面几个版本。
切比雪夫大数定律：用统计方法来估计期望的理论依据。E(X)≈1n∑nk=1xk 直观含义很简单，就是，求平均。举个例子来说，加入班上由 80个同学，那么随机选一个同学，他的身高应该是班里面的平均值。
贝努利大数定律：事件 A 发生的频率 nAn 依概率收敛于事件 A 的概率 p。明确了频率的稳定性，当 n 很大时，事件发生的频率与概率有较大偏差的可能性很小。p≈nAn
这个版本定义是从概率的角度，当N很大的时候，事件A发生的概率等于A发生的频率。
中心极限定理 自然界与生产中，一些现象受到许多相互独立的随机因素的影响，如果每个因素所产生的影响都很微小时，总的影响可以看作是服从正态分布的. 在独立同分布的情况下，无论 X1,X2,...,Xn 的分布函数为何，它们的平均数 X¯¯¯¯ 当 n 充分大的时候总是近似地服从正态分布。
所以这样就很好理解为什么身高/智商/考试成绩符合正态分布了. 因为这些属性都取决于非常非常多的变量, 相当于一个有着n多股票的投资组合.这样他们总体组成的表现就会像他们的平均分布正态分布。
所以两个定理的核心思想都是平均。不管单个的样本(大数定理)，还是分布(中心极限定理)。如果N足够大都会趋向于平均。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0d89391a74c4a96969286d8c396f882/" rel="bookmark">
			模糊查询出两个字段均含有该模糊字段的列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：前端输入某个字符，若A字段包含该字符，查询出包含A字段的所有数据，B字段若也包含该字符，也要查询出包含B字段的所有数据，最终结果是两组数据的并集，而有时我们需要的是两组数据的交集，以下是解决方法：
解决方法：
在sql中做如下操作：
select * from tableName where 1=1 &lt;if test="A!=null"&gt;
and A like #{A}
or B like #{A}
&lt;/if&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/108fd1d6ec258e0bf27466f905b00ca3/" rel="bookmark">
			MATLAB实现小波变换去噪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在弄一个信号处理的比赛，主要用到了小波变换，先给出一个原始的小波变换的代码以供参考。 clear all;clc load(‘Audio_1_resample.mat’); s=data_resample; %获取要处理的信号，data_resample是在上面.mat里的一个参数 %整个信号的长度 N = numel(s); %小波分解; [c,l]=wavedec(s,7,’coif5’); %小波基为coif5,分解层数为7层 ca11=appcoef(c,l,’coif5’,7); %获取低频信号 cd1=detcoef(c,l,1); cd2=detcoef(c,l,2); %获取高频细节 cd3=detcoef(c,l,3); cd4=detcoef(c,l,4); cd5=detcoef(c,l,5); cd6=detcoef(c,l,6); cd7=detcoef(c,l,7); sd1=zeros(1,length(cd1)); sd2=zeros(1,length(cd2)); %1-3层置0,4-7层用软阈值函数处理 sd3=zeros(1,length(cd3)); sd4=wthresh(cd4,’s’,0.014); sd5=wthresh(cd5,’s’,0.014); sd6=wthresh(cd6,’s’,0.014); sd7=wthresh(cd7,’s’,0.014); c2=[ca11,sd7,sd6,sd5,sd4,sd3,sd2,sd1]; s0=waverec(c2,l,’coif5’); %小波重构 figure; subplot(211);plot(s);subplot(212);plot(s0);%画图
具体的分解层数、在哪一层选用去噪函数，哪一层置0或做其他操作，或者选用哪个小波基根据要处理的信号来定，具体问题具体分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c0c451f3e4af1e2a97a438ff9fef1b4/" rel="bookmark">
			Centos7.2搭建xampp环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XAMPP官方下载地址 https://www.apachefriends.org/zh_cn/download.html
1、根据需要选择相应的安装文件，这里我们选择了对应的64位xampp-linux-x64-7.2.6-0-installer.run
下载:wget https://www.apachefriends.org/xampp-files/7.2.6/xampp-linux-x64-7.2.6-0-installer.run
2、下载完成后上传到/opt目录下，执行前首先通过chmod -R 755 xampp-linux-x64-7.2.6-0-installer.run赋予执行权限。
3、然后进入到/opt目录下运行这个安装文件./xampp-linux-x64-7.2.6-0-installer.run，安装过程中全部回答yes。
4、安装完成后启动xampp服务，/opt/lampp/lampp start，有时会提示启动命令不存在，再次执行时会发现已经全部开启。 5、环境安装完成后，sudo /opt/lampp/lampp security依次设定密码
依次是xampp、phpmyadmin、mysql、ftp 如图
6、安装完成，后关闭防火墙centos7下命令为systemctl stop firewalld.service，既可以通过主机访问虚拟机的地址来查看是否安装成功。
7、XAMPP中的命令工具在/opt/lampp/bin/目录中，所以可以这样运行mysql命令 /opt/lampp/bin/mysql -uroot -p XAMPP使用mysql的的小插曲(用设置好的root用户密码登陆mysql 报错如图)
我直接跳过授权表进入到mysql中的user表中更新了root用户的密码,之后重启mysql,就可以登陆mysql了
原因应该是因为修改密码后没有重启XAMPP;
操作如下:
7-1、停止mysql服务器
sudo /opt/lampp/lampp stopmysql 7-2、使用`--skip-grant-tables' 参数来启动 mysqld
sudo /opt/lampp/sbin/mysqld --skip-grant-tables 7-3、再开一个终端(在终端中直接右键+B) 进入mysql
sudo /opt/lampp/bin/mysql -uroot 现在会直接进入mysql
7-4、连接mysql权限数据库
use mysql; 7-5、修改root用户的密码
update user set password=password("123456") where user="root"; #其中括号中即为所要设置的新密码。 7-6、刷新权限表（必须要有这一步）
flush privileges; 7-7、退出mysql
quit; 7-8、重启mysql服务
sudo /opt/lampp/lampp startmysql 8、也可以进入/opt/lampp/bin/目录执行mysql命令 cd /opt/lampp/bin/ ./mysql -uroot -p 9、简单的方法是可以直接将/opt/lampp/bin/目录添加到环境变量中如下操作，这样就可以直接使用mysql和mysqldump命令了。 9-1、打开 ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c0c451f3e4af1e2a97a438ff9fef1b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082fc39a30572aa993c15bf78bfb5a4b/" rel="bookmark">
			机器学习任务的一般步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、确定特征：（收集训练数据）
1 &gt; 数据探索：（为什么要进行数据探索呢：有助于选择 合适的 数据预处理方法 和 建模方法） （1）数据质量分析 -- 缺失值 -- 异常值 （2）特征分布特性的分析 -- 统计量 -- 直方图 （3）特征之间相关性分析 2 &gt; 数据预处理： 3 &gt; 特征选择： 二、确定模型：（暂定确切的模型）
三、模型训练：（根据样本数据计算模型参数）
四、模型评估： （根据测试数据，评估模型的预测性能）
note：深度学习可学习 feature ===========================================================================================
—–&gt;确定特征—-&gt;数据探索——&gt;数据质量分析——–&gt; 缺失值：
1.统计含有缺失值的样本数目 及 缺失率 2.缺失值的处理： 1&gt; 删除含有（一个或多个）缺失值的样本 (从 行 的角度考虑) 2&gt; 删除缺失值太多的特征(从 列 的角度考虑) 3&gt; 对缺失值进行插补 —— 均值mean(默认的方法) —— 中位数median —— 众数 most_frequent —— 固定值插补 （根据背景知识用某些常量进行插补） —— 最近邻插补 （寻找最相似的样本，用该样本对应的属性进行插补） —— 回归方法 （用没有缺失的数据建立回归方程预测不完整的样本数据） —— 插值法 （利用该变量已有数据 建立合适的插值函数 进行插补） 4&gt; 不处理（有些框架可处理数据缺失的情况，如：xgboost） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05a027c5d686134907f075bd69cb16c/" rel="bookmark">
			Chameleon算法及Matlab实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chameleon（变色龙）算法 ——使用动态建模的多阶段层次聚类
一种层次聚类算法，它采用动态建模来确定一对簇之间的相似度。
算法思想：
首先由数据集构造一个 k-最近邻图 Gk；再通过一种图的划分算法，将Gk图划分成大量较小的子图，每个子图代表一个初始的子簇；最后使用凝聚层次聚类算法，基于子簇的相似度反复合并子簇。 **为引出**Chameleon变色龙算法的一些定义，先说一下以往的聚类算法的不足之处：
忽略簇与簇之间的互联性
互联性：簇间距离较近的数据对之间的数量，即临接区域的大小。
忽略簇与簇之间的近似性
近似性：簇间数据对的相似度，即不同簇的对象间最近距离。
如图4所示：如果只看最近邻的链接，即只看近似性，则算法会倾向于合并c和d而不是a和b，但实际上a、b的临接区域较大，距离也不远（相对于a、b内部），即互连性更好，所以应该属于同一个cluster簇。 如图5所示：另一种情况，就是过分强调临接区域的大小，倾向于合并a、c，而不是a、b。
Chameleon算法就是努力保持这两种情况之间平衡，即考虑最近邻节点的靠近程度，也考虑临接区域的大小。
Chameleon算法的聚类步骤：
第一阶段：图划分算法，将数据对象划分成大量子簇；第二阶段：凝聚层次聚类算法，合并子簇。 3个关键知识点： 1. k-最近邻图Gk的构造（第一阶段）
Gk图中的每个点，表示数据集中的一个数据点。对于数据集中的每一个数据点找出它的所有k-最近邻对象，然后分别在它们之间加带权边。 如何找k-最近邻对象呢？？即找离该对象最近的k个对象点， （定义：若点ai到另一个点bi的距离值是所有数据点到bi的距离值中k个最小值之一，则称ai是bi的k-最近邻对象。） 若一个数据点是另一个数据点的k-最近邻对象之一，则在这两点之间加一条带权边，边的权值表示这两个数据点之间的相似度，即距离越大边权值越小，则近似度越小。
2. 划分k-最近邻图Gk（得到初始子簇）
目的：把Gk图划分为大量的无连接的子图，每一个子图就是第二阶段层次聚类的初始子簇。 划分步骤：首先把图Gk划分成两个近似的等大小的子图，使分区的边的总权重和最小，即（割边最小化）；我个人觉得它就是最小二分法。也就是说，簇C划分为两个子簇Ci和Cj时需要割断的边的加权和最小。割边用Ec（Ci，Cj）表示，用于评估簇Ci和Cj之间的绝对互连性。然后把每个子图看成一个初始的子图，重复上述过程直至生成每一个子图中节点数量达到一定标准。
3. 合并成最终的簇（第二阶段）
Chameleon算法根据每对簇Ci和Cj的 相对互连度 RI（Ci,Cj）和 相对接近度 RC（Ci,Cj）来决定两个簇之间的相似度。
两个簇Ci和Cj之间的 相对互连度 RI（Ci,Cj）定义为Ci和Cj之间的绝对互连度关于两个簇Ci和Cj之间的内部互连度的规范化： 绝对互连性：连接子簇Ci和Cj之间的边的权重之和。 相对互连性：一个子簇Ci做最小截断时需要去掉的边的权重和。
两个簇Ci和Cj的的 相对接近度 RC（Ci，Cj）定义为Ci和Cj之间的绝对接近度关于两个簇Ci和Cj的内部接近度的规范化，定义如下： 相对近似度：一个子簇Ci做最小截断时需要去掉的边的平均权重。 绝对近似度：连接子簇Ci和Cj之间的边的平均权重。
相似度函数：是相对互连度与相对近似度两个指标的乘积。 RI（Ci,Cj）* RC（Ci,Cj）^a ，选择使该函数值最大的簇对进行合并。其中，a是用来调节两个参量的比重的参数。a&gt;1,更重视相对近似性，a&lt;1更重视相对互连性。
合并子簇具体过程：
给定度量函数和阀值minMetric（用户指定阀值TRI和TRC）；访问每个簇，计算它与邻近的每个簇的RI和RC，通过度量函数公式计算出值tempMetric，将值存放于一个列表中；从列表找出最大的tempMetric值，若它超过阀值minMetric，将簇与此值对应的簇合并，（合并RI和RC分别超过TRI和TRC的簇对）；若找到的最大tempMetric没超过阀值，则表明此聚类已合并完成，移除聚簇列表，加入到结果聚簇中，（重复直到没有可合并的簇）；递归步骤2，直到待合并聚簇列表最终大小为空。 总结：
变色龙算法将互连性和近似性都大的簇合并；可以发现高质量的任意形状的簇 问题：
k-最近邻图中K值难以选取；最小二等分的选取；用户指定的阀值的选取；最坏情况下，高维数据的处理代价可能需要O(n^2)的时间。 Matlab实现 CSDN地址下载：
https://download.csdn.net/download/qiu1440528444/10489144
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a05699905f123d530b8b92c7928bc5a/" rel="bookmark">
			【错误总结】LaTex Warning: citation undefined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编译文档的时候出现了：
LaTeX Warning: Citation "*****" on page y undefined on input line * 解决办法
使用 pdflatex 编译
之后使用 bibtex 编译
之后在使用 pdflatex 编译两次
可以之后可以使用bibtex 编译一次
Xelatex 编译两次。解决问题！
不谢，哈哈哈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee975a258f032b469035b22d3f18a3b/" rel="bookmark">
			研二总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		又结束了一段实习。
京东实习结束后，在实验室憋了四个月，写了一篇文字检测的论文，然后又跑出去实习了。在实验室的那几个月还是收获颇丰的，系统的了解了当前文字检测的方法。没有了进度的压力，自己想学什么就学什么，对最新论文追着看了很多，对深度学习也有了更深刻的理解。后来面试阿里妈妈，能面到第五轮HR面，有一部分原因也是那几个月对学习的东西进行了细致的梳理。后来实习在滴滴做了一个多月的图像算法，然后又转去搜狗做了机器翻译。折腾了挺久，对NLP，机器翻译也算是粗浅的入门了。
研二上学期就一直在看论文、做实验。自己其实也是挺想好好做研究、发论文的，奈何实验室没有科研氛围，也没人具体指导，这一点真的已经被自己和同学吐槽了无数次。怎么研究，怎么实验，怎么写论文、讲故事，都没有人指导，更多的还是靠自己一点点摸索。在做文字检测的实验时，由于初期的多次实验结果没有达到预期的效果，反复尝试后，问题也没得到解决，心态就有点崩。把检测模型自己可改动的部分找出来，分成了四大部份：基础网络、损失函数、融合特征的结构、额外辅助信息。随意的改变其中某一部分，然后就期待着结果有没有好转。本质上是通过不同的组合方式，尝试看哪种效果好一些。即使是效果有提升，创新程度也是很低。另一方面，这样的方式能有改进的概率很低，最后的事实也充分验证了这点：这样尝试了大半个月，结果都没有提升。关于这一点，比较正确的处理方式还是在于：在多次实验失败后，还能够保持一个较好的心态；失败后认真的分析所存在问题，多次失败后再做改变时，可能就是这种方式有问题，可以进行更大幅度的改变，不能太保守；在每一次实验前，都应该对实验有个清晰的设计以及理论上的支持，避免盲目的尝试。
一月份把论文投出去后，就开始投简历再次找实习了。先是找了滴滴的图像算法实习。滴滴离我们学校实在是太远了，每次上班都得两个小时，每天通勤时间四个小时，想想自己也是很拼了。在滴滴刚开始做的还是文本区域检测，拿了一堆营业执照做检测。后来觉得滴滴实习的内容和京东实习的内容重合度实在是太高了，没什么新的东西，所以就辞了，转去搜狗做机器翻译。
为什么要做机器翻译呢？首先也是自己没找到BAT的图像实习，如果能找到的话，肯定继续研究图像了。其次之前一直在做图像，对其他领域也没有过多的了解过。看论文时，也发觉不同领域之间的相互借鉴越来越普遍，所以想深入的了解下其他领域的知识。在搜狗带我的mentor也是一个实习生（当然，这点他自己从没说过→_→），是计算所的机器翻译博士。从二月一直做到了六月初，做了四个多月时间。刚开始没有什么机器翻译的基础知识，mentor给了我几篇论文，还有DL4MT的代码，除去过年放假的时间，大概看了一个多星期时间吧。过完年后回来就是三月份了，虽然没有达到mentor的预期了解程度，但还是开始看实际的工程代码了。搜狗的机器翻译模型用的就是谷歌开源的Transformer模型，这也是目前业内现在用的最多的一个模型。我负责的主要是一个探索研究性质的任务：基于transformer模型，预测中译英中，英文单词大小写信息。这个研究点其实挺小，但是对于初入门的我应该是足够了。整个transformer模型的代码量不小，先是在小的数据集上跑通，然后看了大概一个多星期的时间，结合着论文，大致理清了模型的逻辑和框架。这点自己还是挺开心的，以小白的状态，能这么快的速度看完、看懂。看完了代码就开始着手改代码，实现预测大小写。看懂之后，代码很好改，两三天时间吧。不过即使这样，还是踩了不少坑，特别是在beam search 解码预测的时候，犯了几次错误。刚开始先是在10W条数据上训练测试，感觉还行之后，就开始在700W条数据训练。在不加BPE处理的方式下，自己的这个预测方式对翻译的提升还是挺明显的。BPE有效的解决了UNK的问题，用BPE处理训练数据后，自己的预测方式提升就没什么效果，四月份一整个月的时间都是在尝试用不同的方式来在ＢＰＥ　的方式下提升译文质量和大小写预测的精度。可惜的是，没什么实质性的进展。其实在这个时候，基本上就已经选宣判在BPE处理下，预测大小写对译文质量不会有实质上的提升。Mentor还是想让我继续尝试，看有没有其他好的解决方案。当然，尝试的方案还有很多，毕竟可改的点很多，但是改过之后的效果怎么样自己也是不知道的。再一次的感受到了深度学习的玄学性。之后就又探索了半个月。五月中旬，之前投的论文没中，于是请了两个星期假回实验室改论文。再回公司的时候就已经不怎么想实习了，因为大小写预测这个问题都已经做了这么长时间了，还没有提升。一方面是自己觉得付出与收获不对等，另一方面觉得这个小问题不值得花费这么长时间来研究，何况一直没改进，时间投入像是无底洞，有点厌倦了。后来mentor又让做了预测汉语分词，花费时间不多，就一个星期时间，也没什么实际效果（准确的来说是没有合适的测试集能评判这种方法的效果）。直到六月初离职，自己实习期间，能拿的出手的成果就是大写小预测。后来也整理了整理数据，写了一个中文论文，投了个会议，但愿能中吧。回想这段实习经历，在最初的两个月时间里，自己学习到的东西是最多的。之前一张白纸，什么都不会，意识到要学的东西很多，很有学习的热情，进步最快。到四月下旬的时候，实际上自己就已经停止进步了，进入了停滞、倦怠期。实验结果一直没改进，Mentor还不给其他任务，一直在实现他突发奇想的改进尝试点。理智上来讲，这个时候自己就应该离职退出。也是自己觉得压力不太大，贪于安逸没有做出改变。之前来搜狗实习很大原因也是因为看新闻报道，这个团队得了2017年WMT英汉互译的冠军，所以想来这边学习学习。以现在来看的话，实际上自己做的是探索研究性质的工作，并不牵涉到业务，也没学习到他们最优的点，略有失望。最大的收获就是对机器翻译有了很深的了解，对transformer这一主流模型有了很好的掌握，attention机制也有了新的理解。单靠这一点，秋招拿份机器翻译的offer应该没什么问题。
啰啰嗦嗦的写了一大堆流水账，也是mark下自己的经历吧。看之前那篇总结自己列的计划，没几个实现的，看来自己并不是那种执行能力很强的人。这次就不列计划了。接下来就要秋招了，这两个月就在实验室好好再沉淀。再联系联系老师，看有愿意收我做博士的没。恩，大致就这样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7188336cd4c2178619f3adb119a0c0e/" rel="bookmark">
			LaTeX如何输出反斜杠 \
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一是: $\backslash$
二是: \verb|\|
三是：$\setminus$
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24a743f3c8ccfdecfcca6022a1d7362/" rel="bookmark">
			Java判断变量是否是基本类型以及是否是默认值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		判断变量是否是基本类型：
/** * 判断object是否为基本类型 * @param object * @return */ public static boolean isBaseType(Object object) { Class className = object.getClass(); if (className.equals(java.lang.Integer.class) || className.equals(java.lang.Byte.class) || className.equals(java.lang.Long.class) || className.equals(java.lang.Double.class) || className.equals(java.lang.Float.class) || className.equals(java.lang.Character.class) || className.equals(java.lang.Short.class) || className.equals(java.lang.Boolean.class)) { return true; } return false; } 判断是否是默认值：
/** * 判断是否为基本类型的默认值 * @param object * @return */ public static boolean isBaseDefaultValue(Object object) { Class className = object.getClass(); String strClassName = "" + className; if(className.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24a743f3c8ccfdecfcca6022a1d7362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d47ff39535818452ce1b2fa1610493/" rel="bookmark">
			MATLAB与Robotstudio建立socket通信（初探）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2020-11-2更：python与rs的socket链接可以参考：https://forums.robotstudio.com/discussion/comment/25528/#Comment_25528 前记:
听一首《不想病》，歌词唱开头：做什么都不对，说什么都浪费，想什么我都可悲....；感觉就是不一样，好歌！哎，，，回到正题。好多事要去做，还得挤时间去玩，，，可悲啊 :D 。这里记录一下MATLAB与Robotstudio建立简单socket的例子。至于建立通讯的意义何在，暂时不能深入探究（我想最重要的联合仿真时的数据传递，MATLAB对数据进行分析类似的吧）。
附：在建立通信之前，MATLAB必须保证安装有能进行TIP/IP通信的Instrument Control Toolbox,然后就是Robotstudio创建了系统和对应通讯的Rapid程序，MATLAB作为client，RS最为server。
1、建立Robotstudio方机器人系统和Rapid程序。
1）打开RS，界面左上角基本---&gt;ABB模型库---&gt;拖入机器人---&gt;从布局建立系统---&gt;一直点击下一步---&gt;直到有选项---&gt;在添加选项里加入616-1 PC interface---&gt;完成---&gt;等待控制器状态变绿。
2）点击RAPID，在模块中建立程序，如下：
3）rapid程序如下：
MODULE moudle1 !define variables VAR socketdev server; VAR socketdev client; VAR string message; VAR string string1:=""; VAR string string2{3}:=["","",""]; VAR num pass:=0; VAR num X:=0; VAR num Y:=0; VAR num Rz:=0; VAR bool flag1:=FALSE; VAR rawbytes data; CONST robtarget p10:=[[0,0,23.72],[0.00796547,0.908649,0.417482,0.0017992],[0,-1,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]]; TASK PERS tooldata toolxi:=[TRUE,[[0,0,0],[1,0,0,0]],[-1,[0,0,0],[1,0,0,0],0,0,0]]; PROC main() a: !create communication SocketCreate server; SocketBind server,"127.0.0.1",55000; SocketListen server; SocketAccept server,client; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6d47ff39535818452ce1b2fa1610493/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4883173094ae987648a5ec31f4189133/" rel="bookmark">
			Oracle存储过程与触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-1（存储过程）创建一个显示学生总人数的存储过程
1 SQL&gt;SET SERVEROUTPUT ON 2 SQL&gt;CREATE OR REPLACE PROCEDURE STU_COUNT 3 2AS --需要定义的存储过程内的变量均写在AS下 4 3TOTAL NUMBER --定义 5 4BEGIN 6 5 SELECT COUNT(SNO) INTO TOTAL FROM STUDENT; --SELECT 后的变量个数要与INTO 后一致 7 6 DBMS_OUTPUT.PUT_LINE('总数：'||TOTAL); --字符'||'的含义是连接两个字符串 8 7END; 9 8/ 10 11 SQL&gt;EXECUTE STU_COUNT;
总数:12 PL/SQL 过程已成功完成。
7-2（存储过程）创建显示学生信息的存储过程STUDENT_LIST,并引用STU_COUNT存储过程
1 SQL&gt; SET SERVEROUTPUT ON 2 SQL&gt; CREATE OR REPLACE PROCEDURE STUDENT_LIST 3 2 AS 4 3 SNO STUDENT.SNO%TYPE; 5 4 SNAME STUDENT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4883173094ae987648a5ec31f4189133/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc0c0b183afe2bc252b63f6cac1417ee/" rel="bookmark">
			程序猿玩游戏——用c语言求游戏《计算器——游戏》的解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* 编写人@wonder 版本：v0.1 因为对这个游戏感兴趣，想到用编程求解法， 固编写了本程序。 本程序用来求游戏《计算器-游戏》的解法。 输入： 开始数字start，最大步数step，目标数字target， 为三个数字， （如123 3 321） 与可用的计算按钮 为若干字符串，用空格隔开，输入e结束。 （如r13 *-15 r &lt; e）。 输出： 所有可行的按键顺序，可能有多个输出。 目前集成的运算有： +n -n *n /n &lt;_______&lt;&lt;去掉最后一位 n_______在最后加上数字n n=》m___将所有数字n换为数字m ^n______幂运算 !_______+/- r_______reverse s_______sum {_______&lt;shift }_______&gt;shift m_______mirror 共14种运算 可以求出131关以内的解 基本算法： 1.输入数据 2.用递归找出所有可能的操作，生成一操作顺序码 3.对每个操作码计算，如果可行就输出 以后应优化一下算法，每次递归进行一次运算 继续增加运算，求出所有关卡。 */ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define R 10 int start,step,target; int OPNumber=0; char operate[6][R]; int debug = 0;//将值设为1开启debug模式 void inputDate() { char OPstring[R]; int i,j; printf("input start,step,target="); scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc0c0b183afe2bc252b63f6cac1417ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff33e4bac6a12a8f58dc7f30a0e80993/" rel="bookmark">
			电阻、电容、电感的实际等效模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、电阻的等效模型
2、电容的寄生参数
3、电容的等效参数
4、理想铝电解电容与实际铝电解电容的区别
5、电感的等效模型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95473c2f11ef8e38e2ab0c0686669fe2/" rel="bookmark">
			android UI之RecyclerView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章是在使用RecyclerView的过程中对官方文档的翻译，由于英语水平的局限可能有的表述不太准确，后续会更新。
原文地址RecyclerView
1.简介
总体来说RecyclerView是ListView的优化升级版.RecycleView中重要的组成部分包括：LayoutManager，RecyclerView.ViewHolder,RecyclerView.Adapter.下面是关于这三者的介绍
在RecyclerView模式中，可以有几个不同的组件一起工作显示数据，你整个界面的容器是一个recycler view，它通过你提供的layout manager进行view的填充，layout manager有默认的和自定义的（默认的layout manager有LinearLayoutManager和GridLayoutManager）. RecyclerView.ViewHolder
list中的view通过实现RecycleView.ViewHolder的view holder对象来展示。每一个item有自己的view holder对象进行管理,当用户滚动list的时候，recycleVIew会通过回收或者缓存离开屏幕的view更改其展示的数据重新回到屏幕内，做到复用。
RecyclerView.Adapter
通过一个RecyclerView.Adapter对象管理这些view holders对象。adapter主要工作是创建view holders，使用onBindViewHolder方法通过他们的位置进行数据的绑定
2.RecyclerView较之ListView比较起来有一些其自身的特点，包括以下：
（1）.列表首次被填充的时候，recyclerView不仅创建和绑定了用户可见的view holders，而且在两端创建和绑定了一部分不可见的view holders，当用户滑动的时候便可以直接显示（提前创建一部分不可见 view holders）
（2）.recyclerView对view holders进行了管理和复用，当用户滚动list的时候，它只会创建必要的view holders并对离开屏幕的view holders进行保存，当用户改变滚动方向的时候，可以立马将缓存中的view进行显示；当用户一直沿着一个方向滚动的时候，recyclerView会将最早离开屏幕的view holder进行数据的改变，不需要创建新的view holder实例只需要进行数据的重绑即可。
3.使用
（1）模块的build.gradle中添加引用
implementation 'com.android.support:recyclerview-v7:27.1.1' //（可按照自己编译的版本号进行版本的改变） (2) 布局
&lt;android.support.v7.widget.RecyclerView android:id="@+id/my_recycler_view" android:scrollbars="vertical" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; （3）填充数据
//获取RecyclerVIew对象的引用 mRecyclerView = (RecyclerView) findViewById(R.id.my_recycler_view); //通过LayoutManager进行连接 mLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mLayoutManager); //adapter填充数据 mAdapter = new MyAdapter(myDataset); mRecyclerView.setAdapter(mAdapter); (4)自定义Adapter内容
public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; { private String[] mDataset; // Provide a reference to the views for each data item // Complex data items may need more than one view per item, and // you provide access to all the views for a data item in a view holder public static class ViewHolder extends RecyclerView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95473c2f11ef8e38e2ab0c0686669fe2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffdf1f13615d066a88e94d24c727f8b7/" rel="bookmark">
			统计数据表的设计思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一张订单表，统计一个商品的购买次数，特别是数据量比较大的情况下，用count /sum等聚合函数统计订单表的效率会特别低，不如新建一个统计表， 用查询来获取购买量。解决办法可以用定时任务 定时 去更新数据统计表， 也可以用其他有效手段
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1bee5c1657a945274ad18426a2ef02/" rel="bookmark">
			【解答】多台西门子PLC之间可不可以无线通讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本方案为原创方案，版权归本公司所有。
如需转载，请注明文章出处。
一、方案基本情况
该方案可适用于3台以上西门子PLC，S7-200或S7-200Smart之间实现一主多从Modbus通讯协议的无线通讯。
·适用PLC型号：S7-200和S7-200SMART
·通讯协议：Modbus-RTU
·通讯关系：一主4从
·通讯距离：3KM
·通讯方式：全数字加密无线传输
·无线通讯装置：DTD434MCY 西门子PLC专用无线通讯装置
西安达泰电子有限责任公司 DTD434MC 西门子S7-200Smart 无线485 plc无线通讯 西门子plc无线通讯 一主多从 plc无线传输
二、方案的好处
1. 免布线
2. 免运行费用
3. 传输稳定可靠，达泰电子16年工业无线通讯品牌
西安达泰电子有限责任公司 DTD434MC 西门子S7-200Smart 无线485 plc无线通讯 西门子plc无线通讯 一主多从 plc无线传输
三、主站程序
主站程序我们采用分时循环采集的方式来依次读写4个从站的状态。程序编程采用毫秒定时器【T32】来作为系统的通讯采集周期。我们可根据实际需求调整参数大小。若使用GPRS通讯方式，出于对流量成本的考虑，需要根据实际情况调整通讯周期，以免增加不必要的后期费用。
西安达泰电子有限责任公司 DTD434MC 西门子S7-200Smart 无线485 plc无线通讯 西门子plc无线通讯 一主多从 plc无线传输
四、从站程序
从站程序只需要根据主站的通讯格式设置保持一致，然后再使从站响应指令即可正常通讯。其他从站通讯程序,除地址不一样外，其他的参数均相同，后期可根据实际使用情况调整。
五、指令调用说明
【Modbus Master Port0（v1.2）】通讯口0作为Modbus主站用到的指令。
六、成功案例
·浙江箭环电气，两台西门子plc之间的无线通讯，一端移动，200米；
·宝钢集团余能电厂，分布机组转炉煤气流量监测，1公里；
·苏州水都环境公司，PLC在线控制液位，压力等信号，800m；
·太原市汾源供水设备有限公司，台达PLC和台达触摸屏的通讯，50米，2017；
·国电投朝阳燕山湖发电有限责任公司,两台水泵到控制室PC组态王，500米，2017；
·成都纳尔美环境科技,西门子PLC与PC之间,3KM；
·青岛嘉华环境工程有限公司;S7-200和变频器到组态王，200M；
·渤海石油管理局（有限天津分公司）渤南作业公司 数据采集器到值班室，500米；
·潍柴动力股份有限公司，威纶触摸屏和5台S7-200PLC无线通讯，300米，2012年；
·山东重联电动车辆制造有限公司,S7-1200与3台S7-200无线通讯，1KM，2017；
·天马花源停车设备（北京）有限公司，1主5从PLC无线通讯，60M，2017；
·盘锦晨通锅炉有限公司，触摸屏到S7-200，200米，2017；
·蚌埠市康普压缩机有限公司，威纶屏到200PLC，50米，2018；
·天津科技大学，威纶屏和PLC，200米，2017；
·山东聊城阳谷电缆有限公司，PLC到触摸屏，200米，2017；
·丹东东方测控技术股份有限公司，PLC到组态王，2017；
·上海首坤机电科技有限公司，S7-1200与11台S7-200之间无线通讯，500M，2017
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1bee5c1657a945274ad18426a2ef02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c35ce35fa8e17b79c20f59d9c0c4d03/" rel="bookmark">
			系统创建定时执行任务bat批处理删除指定N天前文件夹的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先我们要创建一个.bat的文件，下面是创建删除七天前D盘backup目录下的.dmp文件和.log文件
@echo off echo 删除7天前的.dmp文件和日志 forfiles /p "D:\backup" /m *.dmp /d -7 /c "cmd /c del @path" forfiles /p "D:\backup" /m *.log /d -7 /c "cmd /c del @path" echo 正在执行逻辑删除，请稍等…… pause echo 任务完成! 下面是创建删除七天前D盘backup目录下的所有文件
@echo off echo 删除7天前所有的文件 forfiles /p "D:\backup" /s /m *.* /d -7 /c "cmd /c del @path" echo 正在执行逻辑删除，请稍等…… pause echo 任务完成! 将以上其中一行复制，新建.txt文本文件，粘贴并保存为.bat格式
说明：
/p 指定的路径 /s 包括子目录 /m 查找的文件名掩码 /d 指定日期,有绝对日期和相对日期, 此处-7指当前日期 的7天前 /c 运行的命令行 表示为每个文件执行的命令。命令字符串应该 用双引号括起来。 默认命令是 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c35ce35fa8e17b79c20f59d9c0c4d03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8dbda10a342e6d88752418dd4c6dd76/" rel="bookmark">
			train_test_split参数含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在机器学习中，我们通常将原始数据按照比例分割为“测试集”和“训练集”，通常使用sklearn.cross_validation里的train_test_split模块用来分割数据。
cross_validation已经弃用，现在改为从 sklearn.model_selection 中调用train_test_split 函数。
简单用法如下：
X_train,X_test, y_train, y_test =sklearn.model_selection.train_test_split(train_data,train_target,test_size=0.4, random_state=0,stratify=y_train) # train_data：所要划分的样本特征集
# train_target：所要划分的样本结果
# test_size：样本占比，如果是整数的话就是样本的数量
# random_state：是随机数的种子。
# 随机数种子：其实就是该组随机数的编号，在需要重复试验的时候，保证得到一组一样的随机数。比如你每次都填1，其他参数一样的情况下你得到的随机数组是一样的。但填0或不填，每次都会不一样。
stratify是为了保持split前类的分布。比如有100个数据，80个属于A类，20个属于B类。如果train_test_split(... test_size=0.25, stratify = y_all), 那么split之后数据如下： training: 75个数据，其中60个属于A类，15个属于B类。 testing: 25个数据，其中20个属于A类，5个属于B类。 用了stratify参数，training集和testing集的类的比例是 A：B= 4：1，等同于split前的比例（80：20）。通常在这种类分布不平衡的情况下会用到stratify。
将stratify=X就是按照X中的比例分配 将stratify=y就是按照y中的比例分配 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/823ac3f032018cca05064507d2b144ed/" rel="bookmark">
			vue进度条插件vue-nprogress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们在vue项目开发中经常会遇到的需求是，在跳转或者请求接口时要求有一个加载的进度条，现在我们介绍的是vue其中的一个进度条插件vue-nprogress
安装
$ npm install nprogress --save 使用
在main.js中引入依赖
import NProgress from 'nprogress' import 'nprogress/nprogress.css' 使用场景：
如果想ajax请求有progress，加载vue-resource的interceptors中：
Vue.http.interceptors.push((request, next) =&gt; { NProgress.start(); next((response)=&gt;{ NProgress.done(); }); }); 如果想路由跳转有progress，加在vue-router的beforeEach和afterEach中：
router.beforeEach(transition =&gt; { NProgress.start(); }); router.afterEach(transition =&gt; { NProgress.done(); }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed63e4027dabe00bfcd7e141700d44eb/" rel="bookmark">
			word怎么让封面、目录没有页码，页码从正文开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		word怎么让封面、目录没有页码，页码从正文开始 1，开始插入页码，从第一页开始，如图： 二、如果前两页是封面和目录，再从第一页开始就不合适了，解决步骤如下 1，在第三页的文字前面添加分页符 效果如图
2，选中第三页的页码，跳到设置页眉页脚的页面 3，设置为起始页码，从1开始后，第三页就变成第一页了 4，下面就是把前两页的页码删去了， 同样选中第三页的页码，跳到设置页眉页脚的页面，然后点击“链接到前一条页眉”
这里注意，”链接到前一条页眉”开始底色是灰色，点击后变为白色，然后再删除前，前面的页码即可
ps：注意如果不进行上一步，就把前面的页码删除后，后面的页码也会被删除。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/508/">«</a>
	<span class="pagination__item pagination__item--current">509/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/510/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>