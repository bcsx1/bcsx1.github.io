<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16a714f342bd0ab4c044d5c00dd7b0b1/" rel="bookmark">
			【linux kernel】linux 内核中EXPORT_SYMBOL（）分析与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux 内核中EXPORT_SYMBOL（）分析与实践 linux内核版本时间备注4.1.152021/11/1技术总结 一、EXPORT_SYMBOL()分析 ​ EXPORT_SYMBOL实际是一个宏函数。用于将函数或者符号向全部内核代码公开，不用修改内核代码就可以在内核模块中直接调用（注意是在内核模块中），即：使用EXPORT_SYMBOL可以将一个函数以符号的方式导出给其他模块使用。
​ 定义如下：//出自 linux dir/include/linux/export.h文件
#define __EXPORT_SYMBOL(sym, sec)	\ extern typeof(sym) sym;	\ __CRC_SYMBOL(sym, sec)	\ static const char __kstrtab_##sym[]	\ __attribute__((section("__ksymtab_strings"), aligned(1))) \ = VMLINUX_SYMBOL_STR(sym);	\ extern const struct kernel_symbol __ksymtab_##sym;	\ __visible const struct kernel_symbol __ksymtab_##sym	\ __used	\ __attribute__((section("___ksymtab" sec "+" #sym), unused))	\ = { (unsigned long)&amp;sym, __kstrtab_##sym } #define EXPORT_SYMBOL(sym)	\ __EXPORT_SYMBOL(sym, "") 这里以EXPORT_SYMBOL(system_state)为例，经过宏替换后结果如下：
extern typeof (system_state) system_state; extern __visible void *__crc_system_state __attribute__ ((weak)); static const unsigned long __kcrctab_system_state __used __attribute__ ((section("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16a714f342bd0ab4c044d5c00dd7b0b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43166cc49361b130b145741543ccb740/" rel="bookmark">
			雷军传：顺势而为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、人欲即天理，更现实的人生观；
2、顺势而为，不要做逆天的事情；
3、颠覆创新，用真正的互联网精神重新思考;
4、广结善缘，中国是人情社会;
5、专注，少就是多。
6、我真的认为任何一个创业成功，绝对不低于85%是运气，所以对于成功者来说还是要继续保持努力。
7、第一，热爱你所做的事；第二，创业要选择足够大的池塘、容量足够大的市场；第三，勤奋和努力是必要条件。
8、我愿意做最优秀的产品，让更多的人享受又好又便宜的产品，剩下的事情就是顺势而为。
9、上大学的目的，是为了如何去学习。上研究生的目的，就是学会如何去工作。
10、你集中优势兵力的时候，说不定比他全面出击你还要强。不必去比整体，这也是为什么我们经常可以看到一些小公司在某一个点上取胜。
11、我们只是在某个局部市场上和国外公司竞争，竞争有利于用户，有利于技术的进步。
12、说明消费者在追求品质的同时，也更看重产品的价格，既然如此，不如再来一次价格战，将优惠实实在在地带给消费者。
13、成为CEO: 首先是用你的业绩说话；第二是敬业精神；第三是诚信；第四是抱有感恩之心，处理好股东关系。
14、互联网首先是一个媒体，在互联网上开店，本质就是媒体营销。但这个媒体和传统不一样的地方，就是瞬间的交互，这个交互，就是优势。
15、雷十条：能洞察用户需求，对市场极其敏感；志存高远并脚踏实地；最好是两三个优势互补的人一起创业；一定要技术过硬，并能带队伍的技术带头人(互联网项目)；低成本情况下的快速扩张能力；履历漂亮的人优先，比如有创业成功经验的人等会加分；做最肥的市场，选择自己能做的最大的市场。只有大市场才能造就大企业，小池子养不了大鱼。方向有偏差的话，会浪费宝贵的创业资源；选择正确的时间点。市场基本成熟了，企业也已有雏形，引入天使投资后，业务会得到爆炸性增长；专注、专注再专注。最好只做一件事，这样才能把事情做到极致；业务在小规模下被验证，有机会在某个垂直市场做到数一数二的位置；
16、从商业的角度，你得选肥的市场，舍小的市场。
17、你会发现，如果你善待用户，他给你的好处是超出想象的，他对你的宽容度也是超出想象的。
18、小米和iPhone最大的区别在于，小米是集大成的，所谓集大成就是，让所有用户都参与到研发过程中，最后小米呈现出来的是适合不同用户的不同使用习惯的。
19、小米拥有的是粉丝而非用户。用户跟粉丝是两回事，用户是在没有更好选择的时候用你。怎么真心真意对待你的每个用户，怎么让你的粉丝支持你，这是最重要的。
20、第一是“专注”，就是简单的东西集聚力量，只有专注才能做好；第二是“极致”，就是做到你能做到的最好，极致就是做到别人达不到的高度；第三是“口碑”，其本质就是超越用户的期望值；第四是“快”，有时候，快就是一种力量，你快了以后能掩盖很多问题，企业在快速发展的时候往往风险是最小的，当你速度一慢下来，所有的问题都暴露出来了。
21、饥饿营销，是指商品提供者有意调低产量，以期达到调控供求关系，制造供不应求的“假象”、维持商品较高售价和利润率的营销策略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48d102e460918f07aa71f5e283f62550/" rel="bookmark">
			Trie树总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Trie树/字典树/前缀树二、代码1.Trie树节点字符节点数字节点其它 插入和查询操作1.插入操作2.查询操作3.一般题目不会考察的这么简单，一般会在查询上做做变形。 总结 前言 前缀树，字典树，Trie树都是指同一个数据结构。
提示：以下是本篇文章正文内容，下面案例可供参考
一、Trie树/字典树/前缀树 是一棵 N 叉树。前缀树用于存储、查找字符串。前缀树的每一个结点代表一个字符串的前缀。每一个结点会有多个子结点，通往不同子结点的路径上有着不同的字符。子结点代表的字符串是由结点本身的原始字符串 ，以及通往该子结点路径上所有的字符组成的。
前缀树的一个重要的特性是，结点所有的后代都与该结点相关的字符串有着共同的前缀，这是前缀树名称的由来。 前缀树有着广泛的应用，例如自动补全，拼写检查等等。 二、代码 1.Trie树节点 Trie树首先是一颗树，节点的类型：一般Trie中存储的要么全是消息字母，要么全是小写字母，要么全是数字，要么全是0和1。
字符节点 struct Node{ Node *son[26]; bool sign; //按照题目要求标记前缀 Node() sign(false) { //默认构造函数 memset(son, 0, sizeof son); } Node(bool s) Node() { //委托构造 sign = s; } } 数字节点 int son[N][kinds], idx; 其它 按照要求构造树的节点。
插入和查询操作 Trie的优点：存储大量字符，字符串的相同前缀只需要存储一次；查询字符串，只需要沿着N叉树向下走即可。
1.插入操作 void insert(string s){ auto p = root; for (auto c : s){ if (!p-&gt;son[c - 'a']) p-&gt;son[c - 'a'] = new Node; p = p-&gt;son[c - 'a']; } p-&gt;sign = true; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48d102e460918f07aa71f5e283f62550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f180b5b8d5c450cd6b10877e586e495d/" rel="bookmark">
			大学 数据分析 课程设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 双十一购物狂欢节现已成中国电子商务的年度盛典，随着电子商务平台的逐渐兴起，平台的竞争也越来越强，为了更好地提高平台和商家利润。伴随着网购规模的逐年增大，随之产生了大量的围绕平台和购物者的数据集，如果从这大量的数据中挖掘出有用的信息，这就需要用到数据分析技术了。分析出有用的数据事就可以区分无价值消费者、高价值消费者，从而针对不同价值的消费者制定优化的个性化服务方案，并制定相应的营销策略进行喜好推荐和促销，将有限的营销资源集中于高价值消费者，对不同的消费者提供个性化的服务，实现平台和商家的利润最大化目标。
原始数据 参考附件：data.csv
具体实验 导入数据 bf&lt;-read.csv("E:/data.csv") 使用glimpse函数查看所有数据列：
可以看到，12个变量，共有537577条数据。这12个变量分别为：
User_ID：购物者的编码Product_ID：产品编码Gender：购物者的性别Age：购物者的年龄Occupation：职业City_Category：购物者的居住地点Stay_In_Current_City_Years：在当前城市停留的年数Marital_Status：购物者的婚姻状况Product_Category_1：购买的产品类别Product_Category_2：产品可能属于其他类别Product_Category_3：产品可能属于其他类别Purchase：购买的金额
使用summary函数获取最小值、最大值、四分位数和均值等描述性统计量，结果运行情况如下：
购买次数最多产品分析 代码： bf&lt;-bf %&gt;% select(-User_ID) purpro_20&lt;-bf %&gt;% group_by(Product_ID) %&gt;% count() %&gt;% arrange(desc(n)) purpro_20[1:20,] %&gt;% ggplot(aes(x=Product_ID,y=n,fill=Product_ID))+geom_point(color='red')+theme(axis.text.x = element_text(angle=45,vjust=0.5),legend.position = "none") 结果：
从上图我们可以得知，编码为P00265242的产品被购买的次数最多，其次，编码为P00025442，P00110742，P00112142的产品被购买的次数也较多，次数均在1500次以上，从编码来看并没有什么很显眼的数据特点。
消费最多的价格区间 代码：
bf %&gt;% ggplot(aes(x=Purchase))+geom_histogram(fill="red") 结果：
从图上可知，消费最多的价格区间再8500左右，约有60000以上的消费次数。不存在购买频率十分显著的编码号，所以还需要进一步的挖掘。
产品类别信息统计 对不同性别绘制箱线图：
代码： p1&lt;-bf %&gt;% ggplot(aes(x=Gender,y=Purchase))+geom_boxplot() p1 结果：
对不同城市绘制箱线图： 代码：
p2&lt;-bf %&gt;% ggplot(aes(x=City_Category,y=Purchase))+geom_boxplot() p2 结果：
对消费者的婚姻状况绘制箱线图，我们分为男女两个方面：
代码： p3&lt;-bf %&gt;% ggplot(aes(x=as.factor(Marital_Status),y=Purchase,fill=Gender))+geom_boxplot() p3 结果：
从上面的3个箱形图中我们可以看出，男人在购物上花的钱比女人多。无论是是否结婚还是来自于不同城市，而且Age,Stay_In_Current_City_Years这两个变量本来应该保存成数字变量但是原始数据是使用字符型变量，所以需要我们进行进一步的处理。
统计年龄和所在城市的居住年份总数 我们使用年龄范围的平均值来代表每个阶段，可以看到各个年龄段出现的次数。然后我们根据Stay_In_Current_City_Years来统计消费者在当前城市停留最多的年数。
代码：
根据结果，我们可以发现：中年人（35-55岁）的比例最多；年轻人支付较少；就城市停留年数的统计数据看，停留一年的占大多数。
产品类别信息统计 首先我们通过用 table() 函数统计因子各水平的出现次数。可以看到：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f180b5b8d5c450cd6b10877e586e495d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80147e40994368eb43b9d717d774c331/" rel="bookmark">
			【工作笔记】MySQL安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、进入MySQL官网下载所需的MySQL安装包，地址：MySQL :: Download MySQL Community Server，安装步骤参考Windows10 MYSQL Installer 安装（mysql-installer-community-5.7.19.0.msi） | 菜鸟教程
PS：MySQL有安装包版和绿色版，绿色版选下面选项进行下载
2.安装MySQL，安装包版的安装过程很简单，按提示选择即可。
安装程序检查依赖包告警
点Execute后，程序自动下载对应依赖软件
其中有一项需要手动处理，因此安装程序检查会继续告警，点Yes继续
点击Execute，开始安装
安装过程……
密码：123456
安装完成，登陆验证
为了以后登录方便，配置环境变量，新增MYSQL_HOME
编辑Path参数，将新增的变量配置进去
再次测试，验证环境变量配置正确
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fae42f23de183814f3ec939ed81d4380/" rel="bookmark">
			MYSQL--视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 视图的定义创建视图操作视图删除视图 视图的定义 视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。通过视图，可以展现基表（用来创建视图的表）的部分数据；视图数据来自定义视图的查询表。
我们知道了视图的定义，那么，为什么要使用它呢？
因为视图有如下优点：
①. 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集；
②. 安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行或列，但是通过视图就可以简单的实现；
③. 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列队视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。
总而言之，使用视图的大部分情况是为了保障数据安全性，提高查询效率。
创建视图 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 参数说明：
OR REPLACE：表示替换已有视图；
ALGORITHM：表示视图选择算法，默认算法是UNDEFINED(未定义的)：
MySQL 自动选择要使用的算法 ；merge合并；temptable临时表；
column_list：可选参数，指定视图中各个属性的名词，默认情况下与select语句中查询的属性相同；
select_statement：表示select语句；
[WITH [CASCADED | LOCAL] CHECK OPTION]：表示视图在更新时保证在视图的权限范围之内；cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件；local表示更新视图的时候，要满足该视图定义的一个条件即可。
实例一：
实例二：
以上两个示例可以看出，虽然两个视图的字段名不同，但是，数据是相同的，因为两个视图引用的是同一个表中的数据，并且，as后的创建视图的语句也相同。
在实际开发中，用户可以根据自己的需求，通过视图的方式，获取基本表中自己需要的数据，这样既能满足用户的需求，也不会破坏基本表原来的结构，从而保证了基本表中数据的安全性。
操作视图 视图是逻辑表，也就是说视图不是真实的表，但操作视图和操作普通表的语法是一样的。
用户可以在视图中无条件地使用select语句查询数据。但使用insert、update和delete操作需要在创建视图时满足以下条件（满足以下条件的视图称为可更新视图）：
from子句中只能引用有1个表（真实表或可更新视图）；
不能包含 with、distinct、group by、having、limit等子句；
不能使用复合查询，即不能使用union、intersect、except等集合操作；
select子句的字段列表不能包含聚合、窗口函数、集合返回函数。
我们仍使用之前示例中的数据来操作视图：
删除视图 若视图不再被需要，我们可以将其删除，且视图的删除并不影响源表中的数据。
删除视图的 SQL 如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fae42f23de183814f3ec939ed81d4380/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f00d4a7f85dac817ae3c2a63c995bd91/" rel="bookmark">
			sessionStorage、localStorage、cookie区别与作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.相同点
都用来实现存储功能
二.不同点
1.存储大小
cookie只能存储4k以下大小的数据。
sessionStorage和localStorage能达到5M甚至以上
2.存储时间
sessionStorage是会话存储，也就是一次客户端与服务器通信的时间，当浏览器或窗口关闭，就会消失。
localStorage是本地存储，存储在浏览器中，不主动清除就会存在。
cookie可以被设置有效时间，在有效期间内都会存在。
3.作用方式
cookie用于把数据传回服务器，也可以从服务器传到客户端
localStorage和sessionStorage只作用于本地
额外：localStorage一般用于保存浏览历史记录，登录的用户信息等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9412056b4cfd131e9c84d5f5686392f/" rel="bookmark">
			基于语法树对SQL语句敏感字段进行脱敏的一种解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一:需求二:思路演进三:实现功能四:待优化五:小马过河六:代码部分 一:需求 一个面向开发人员使用的sql查询网页端工具, 同时要对展示的敏感字段进行脱敏处理。 例:需要在生产上执行 select * from cust where acct='123'; cust表中存在phone_no 手机号,通过本文中的工具对该字段进行脱敏. 原sql经该工具处理后返回效果 select -- 对phone_no进行脱敏后的效果 case when phone_no is null then null else '***' end as phone_no, acct from cust where acct = '123'; 二:思路演进 v0: 判断执行sql后的返回结果,如果列名为敏感字段.将敏感字段中的数据替换成 ‘***’ (对列起别名失效)
v1: 匹配前端输入的sql是否存在敏感字段,如果存在.拒绝执行 (不支持select * ,误伤where中条件)
v2: 使用链家开源的d18n工具,但是不支持对列起别名,所以没有深入研究该插件.
v3: 使用sql解析器进行解析,对select -待解析字段1- from -待解析字段2- where … 中的字段进行解析,判断是否存在敏感字段,如果存在则用常量对敏感列进行替代
例: select id ,name ,phone_no phoneNo from (select * from b) a where a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9412056b4cfd131e9c84d5f5686392f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe264863b15bdb7b6191a73a43812d17/" rel="bookmark">
			2048游戏编程具体思路和实现（更新2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2048游戏编程具体思路和实现 (更新中……)
请转至：2048游戏系列—总览篇 一、游戏背景 思路很简单的游戏：
试玩截图：
二、 游戏流程图 游戏的本质是根据玩家键盘（或其他）输入的值对一个 4 * 4 的二维矩阵进行移动、合并、检查等操作。
三、具体的功能实现 编译环境：Dev C++ 和 EGE图形库（网上自己搜索一下，有详细的安装流程的）
编程语言：C++
丰富的图形只是数据的映射，编程语言只是思想实例化的工具，关键还是在于数据处理
环境准备：
定义数据：
4*4矩阵空格数方向 #include &lt;iostream&gt; using namespace std; int grid[4][4];// 4*4矩阵 int EmptyBlock = 16;//空格数 int dir;//方向 int main() { return 0; } 调试函数(为了方便给 grid 赋了初值)
打印函数-PrintGrid()
！要注意一点：二维数组遍历的时候图形上是（j, i）对应到数组取值上是grid/[i/]/[j/]
​ 这一点要是不注意会在后面的代码翻大车！！！
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0Jyim40o-1635691298108)(https://cdn.jsdelivr.net/gh/Qi-China/Picture-PicX@master/2048/打印函数说明.4kgd084mupi0.png)]
计算空格函数-CalculateEmpty()
#include &lt;iostream&gt; using namespace std; int grid[4][4]= {{0,1,2,3}, {0,1,2,3}, {0,1,2,3}, {0,1,2,3},};// 4*4矩阵 int EmptyBlock = 16;//空格数 int dir;//方向 //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe264863b15bdb7b6191a73a43812d17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6cb443c6666c8810215901067a679da/" rel="bookmark">
			node安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/lgx5/p/10732016.html
其中有报错：
是想配置npm在安装全局模块时的路径和缓存cache的路径才遇到这个报错。如果用了方法一，确实不报错了但是你安装的路径还是会到默认路径，第二种方法并不能解决问题，个人测试，可能有差异
解决：
用管理员角色进行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/480e76473afb20f088126a70077046b0/" rel="bookmark">
			LearnOpenGL教程 模型加载库Assimp 遇到问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LearnOpenGL教程 模型加载库Assimp 遇到问题 1.cmake模型加载库Assimp: cannot find IL解决方案： 2.教程给的代码报错:解决方案： 3.执行代码时候报错：找不到dll文件参考教程 1.cmake模型加载库Assimp: cannot find IL 刚开始和教程给的一样，cmake模型加载库Assimp时候有遇到找不到directX：
去官网下载即可：
安装direcX时候也有下面问题：
去卸载Microsoft Visual C++ 2010 Redistributable：（用的下面的命令行方法）
参考教程：
‘S1023’ error when you install the DirectX SDK: https://docs.microsoft.com/en-us/troubleshoot/windows/win32/s1023-error-when-you-install-directx-sdk.
很坑的是，弄完DX问题之后，cmake还有显示找不到IL:
解决方案： 找了很久这是为什么，但是一直没发现怎么弄，后来发现。。。这是个warning！不是error!所以直接generate也能生成assimp解决方案！（但是我好像最早尝试的是比较低版本的assimp 3.3.1和4.0.1？点击generate失败过，但是后来试了用的4.1.0版本的assimp就可以直接generate生成assimp解决方案，不知道为啥）之后再去assimp解决方案build即可。
2.教程给的代码报错: FileSystem::getPath error：后面有“::”的名称一定是类名或命名空间名
解决方案： 去掉FileSystem::getPath，直接使用文件名即可。
最后使用Assimp库时候，需要为项目加上包含目录、库目录、.lib文件，具体可以参考文末的教程。
3.执行代码时候报错：找不到dll文件 按照教程，把当cmake生成的dll文件拷贝到自己项目的文件夹下，即可：
Assimp加载模型成功：
参考教程 学习LearnOpenGL教程：: https://learnopengl-cn.github.io/03%20Model%20Loading/03%20Model/
Assimp的安装编译及使用过程全纪录（VS2015）（适合菜鸟看的超详细记录）: https://www.jianshu.com/p/4f3a1271ce0b
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/093d714ada7c77713351635281487e20/" rel="bookmark">
			2021-10-31
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python安装jieba库时出现问题的解决办法 如题，一开始我使用的是pip install jieba，结果一直报错
就像这样，上网查了一下，发现好像是pip版本太低，然后尝试用python -m pip install --upgrade pip升级，结果显示pip已经到了最新版。。
又搜索了一下，发现可能是网速问题，于是换了个镜像版 输入pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jieba
然后还是报错，又找了半天，发现使用离线下载版本可以完美避开这个问题
具体方法是从另一位博主那里看到的，方法我贴下来了https://blog.csdn.net/qq_39445165/article/details/102456223
① 首先需要从官网上下载压缩包
https://pypi.org/project/jieba/
② 解压到其中的一个盘，进入到存在setup文件夹的目录，在文件导航栏中输入cmd，回车
我的安装路径是这样的
③ 输入python setup.py install 回车假如没有什么错误可以看到安装过程中的相关信息
④ 使用命令pip list查看安装的jieba库，如果安装成功了会显示版本，要是还不确定可以去python里使用import jieba，不报错就证明已经安装成功了。
这里贴一下我自己测试用的代码，正好最近在学python，跟着抄了这个代码
（这里的threekingdoms需要自己下载后和代码放在一个文件夹下面，不然会报错）
import jieba txt=open("threekingdoms.txt","r",encoding="utf-8").read() words=jieba.lcut(txt) counts={} for word in words: if len(word)==1: continue else: counts[word]=counts.get(word,0)+1 items=list(counts.items()) items.sort(key=lambda x:x[1],reverse=True) for i in range(15): word,count=items[i] print("{0:&lt;10}{1:&gt;5}".format(word,count)) 写在后面：计算机学起来感觉好难啊，python安装个第三方库快把我急死了，到处上网找办法，只能说互联网足够神奇（我爱互联网！！）
只能说人的天赋摆在这了，有的学起来就是慢，最近还要搞opencv完成数字媒体老师的大作业，愁死了。。。计算机专业计算机学不好，真的两行泪留下来，各位刚接触计算机的朋友一定要好好学啊，别像我这样都大三了还半吊子，啥都没学好TAT
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83569479c27499680b78ae3497dde090/" rel="bookmark">
			PCB封装的创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CHIP类PCB封装的创建0805C电容0805R电阻0805L电感SOT-23 IC类PCB封装的创建用封装向导创建IC类封装阅读规格书时需要关注的点 USB接口的PCB封装创建TF卡的PCB封装创建晶体PCB封装的创建现有PCB封装的调用3D PCB封装的创建使用AD进行简单的模型绘制用现有模型导入 CHIP类PCB封装的创建 创建新的PCB库文件：
【文件】-【新的】-【库】-【PCB元件库】
0805C电容 创建0805CPCB库
0805的规格书
PCB封装的焊盘一般比实物大，以保证贴片焊歪了还能完成焊接
放焊盘
由于图中所放置的是一个通孔焊盘，而规格书中是贴片的电阻电容，因此需要更改其属性
快捷键【Q】:实现mm和mil单位的快速转换
【ctrl】+【c】和【ctrl】+【v】:复制一个新的焊盘
先需要计算（根据规格书）两者之间的位置并放置，先将两个的中心重合，选中焊盘，点击【M】键，【通过x，y移动选中对象】设置移动的数值。
丝印的相关属性
【ctrl】+【G】:改变格点大小
完成之后如下图：
0805R电阻 0805L电感 SOT-23 SOT-23的规格书
IC类PCB封装的创建 规格书
由规格书可知，需要八个焊盘，若一个一个复制太麻烦，此时我们可以使用特殊粘贴，具体操作方法如下：
选择第一个焊盘，【ctrl】+【C】复制，之后选择【编辑】-【特殊粘贴】，在弹出的界面中选择【粘贴阵列】
在下面页面中设置复制数量，及焊盘间的距离
效果如下：
全部绘制完成后如下图：
用封装向导创建IC类封装 当焊盘数量太多时，自己去创建比较麻烦，此时，我们可以使用封装向导进行创建，最后再进行微调即可，具体操作步骤如下：
（这里我们以SOP-8为例）
首先我们选择一个PCB库，右键，选择【Footprint Wizard…
】
接着就会弹出以下界面：
最终效果如下图：
进行微调后，就完成了，如下：
阅读规格书时需要关注的点 为保证创建PCB封装的效率，我们需要又快又准的阅读规格书，其中，我们需要重点关注以下几点：
焊盘尺寸 ，相邻焊盘间距，左右上下焊盘中心距，丝印大小，一脚标示，原点设置到中心
USB接口的PCB封装创建 规格书：
设置通孔参数：
但在这里不需要勾。
USB接口封装：
TF卡的PCB封装创建 规格书：
晶体PCB封装的创建 通孔外径一般是内径的两倍。
现有PCB封装的调用 将现有PCB封装转变成PCB 库
打开PCB文件，【设计】-【生成PCB库】
（【D】+【P】生成PCB库），将生成的PCB库中与我们自己建好的PCB库中相同的封装删掉，再将剩余封装复制到我们自己建好的PCB 库中即可。
3D PCB封装的创建 【ctrl】+【D】切换到3D状态
使用AD进行简单的模型绘制 【放置】-【3D元件体】
【shift】+【右键】：调整视野
下面以按键为例，进行演示：
用现有模型导入 以电容为例
添加好之后转换到3D界面：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83569479c27499680b78ae3497dde090/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b832624eb48d41a290b40a118f8a952e/" rel="bookmark">
			echarts柱状图实现重叠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 option = { xAxis: { type: 'category', data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { data: [120, 200, 150, 80, 70, 110, 130], type: 'bar' }, { data: [130, 202, 180, 80, 90, 200, 130], type: 'bar', barGap:'-100%',//移动第二个柱子的位置实现重叠 z:'-1',//改变这根柱子的层级使这根柱子在下面 } ] }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294318e320cf0a996f502bd292fcc121/" rel="bookmark">
			Go学习的一点心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		减少内存消耗 比如说下面这段程序
for i, tl := 0, len(t); i &lt; tl; i++{ if t[i].method != httpMethod{ continue } } 初始化的时候就赋值了tl, tl 等于 t 的长度，这样避免了每次循环动态的计算长度，减少了内存消耗。
比下面这样写好
for i := 0; i&lt; len(t); i++{ } type IRouter interface { IRoutes Group(string, ...HandlerFunc) *RouterGroup } type Engine struct { RouterGroup RedirectTrailingSlash bool RedirectFixedPath bool HandleMethodNotAllowed bool ForwardedByClientIP bool RemoteIPHeaders []string TrustedProxies []string AppEngine bool UseRawPath bool UnescapePathValues bool MaxMultipartMemory int64 RemoveExtraSlash bool delims render.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/294318e320cf0a996f502bd292fcc121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f081027b794bb996741a48ff666fd7e/" rel="bookmark">
			linux 安装texlive 2021
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 下载iso安装文件: https://mirror.bjtu.edu.cn/CTAN/systems/texlive/Images/
2. 安装: sudo mount -o loop &lt;texlive&gt;.iso /mnt cd /mnt sudo ./install-tl OK 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5196a072a070f9dbcbb37e46b8e04b/" rel="bookmark">
			UE4构建光照后，BSP创建的静态网格变全黑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UE4构建光照后，BSP创建的静态网格变全黑 UE4简单几何体的构建常会用到BSP笔刷。不少小伙伴在创建完静态网格体并且构建完光照后会发现物体死黑的问题。这是由于没有设置光照贴图分辨率和坐标索引引起的。
解决方法 打开死黑物体的网格设置窗口，在Details中搜索光照贴图。把Light Map Resolution 和 Light Map Coordinate Index的两个数值和Build Setting里的默认值对应起来即可。保存退出后重新构建光照，问题解决。（将图中Light Map Resolution的4改为64，Light Map Coordinate Index0改为1）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc73feb4ce59c1d03acaaeffcdff1b75/" rel="bookmark">
			16. 最接近的三数之和 java Java 中Pair的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pair (JavaFX 8)
javafx.util 包中的Pair类
但是LeetCode不能用Pair类，这里只是简单提一下有这个类而已。
给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
示例：
输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
双指针算法
第一层for循环是 i ，j、k为双指针。
当 j 确定的时候，找一个最小的 k ，使得。
这样，就可以枚举出所有大于等于 target 的情况。然后看看当前和，是否最接近。如果是，就更新一下结果。
因为要找的是最接近的和，这个最接近有2层含义，大于等于 target 的最小数，或者是 小于等于 target 的最大数。
所以，如果存在
大于等于 target的最小和 小于等于 target的最大和 我们都要去检查一下，看看谁才是最接近的和。
数组的单调性。
如果不与 j 重叠，且最接近 j 的 k 满足
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc73feb4ce59c1d03acaaeffcdff1b75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5877aa535102989ab931b2767ce3ce6/" rel="bookmark">
			鼠标侧键设置工具X-Mouse安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鼠标侧键设置工具X-Mouse安装教程 X-Mouse是一款管理鼠标功能键的工具，通过它我们可以将鼠标的键赋予各种功能
下载地址：https://www.highrez.co.uk/downloads/XMouseButtonControl.htm
若打不开，请从本人上传的资源里下载安装包
下载安装包，四个都可以，一般选第一个
安装一路点击next就可以了
点击添加，选择要使用的应用程序 ，然后给它命名
设置自定义按键，选择要设置的键，然后选择功能（千万不要选择禁用）
也可以通过自定义设置键的功能，不过要先看一下语法
最后点击应用就可以使用了，比如我给侧键设置成“复制”和“粘贴”，就再也不用Ctrl c/v了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6090872523fe21175f8a39c67638afa0/" rel="bookmark">
			webrtc 的线程模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webrtc 的PC Factory 拥有3个线程：
1）signaling_thread_ ：所有PC Factory 和PC 的对外接口，都会切换到signaling_thread_ 执行，而PC Observer 所有的回调函数也都在signaling_thread_ 执行。
2） network_thread_：和网络有关的操作都在 network_thread_执行，比如收发数据包、绑定网络端口等。
3） worker_thread_：和网络无关的可能耗时的操作，都在worker_thread_执行。
1 三大线程的使用
1）对外接口线程切换
对PC 接口的调用总是进入到api/peer_connection_proxy.h中，
这就是对外接口的线程切换代码。因为切换线程最终都是向目标线程提交一个任务，但这个过程需要做参数传递，如果要做到阻塞式的线程切换--函数调用得等到提交到目标线程的任务执行完才能返回，一个典型的场景就是要拿到异步任务的返回值。
2）内部代码的线程切换
3）三大线程的创建
头文件在 src\api\Create_peerconnection_factory.h：
​​​​​​
实现在：
没有创建三大线程，因此由PC Factory 的构造函数创建，启动network_thread_ 和worker_thread_，并把调用webrtc::CreatePeerConnectionFactory 的线程包装为signaling_thread_。在windows 中，这个线程要么是在主线程（发起端），要么是在websocket线程（应答端）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df9d656500cbe7e236f13025e816d33/" rel="bookmark">
			[C语言编程练习][08]编写一个程序，提示用户输入名和姓，然后以“名，姓”的格式打印出来。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编写一个程序，提示用户输入名和姓，然后以“名，姓”的格式打印出来。
#include&lt;stdio.h&gt; int main(void) { char f_name[40]; char l_name[40]; printf("Enter your first name: "); scanf("%s", f_name); printf("Enter your last name: "); scanf("%s", l_name); printf("%s, %s\n", l_name, f_name); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99aebb23f26be0c289640b93f834b562/" rel="bookmark">
			小程序获取用户信息和openId
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，获取openId 1.openId是一个微信号在一个应用内唯一的标识，可以作为一个用户在应用内唯一的用户id。
2.获取步骤
（1）使用wx.login()获取登录凭证code
wx.login({ success(res){ res.code //登录凭证 } }) （2）将code传给后端，后端自定义接口
（3）后端调用微信接口获取相关信息：需要appid，appScret和前端的code
https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code （4）返回值：openId，unionId，sessionkey
3.获取openId不需要授权的操作。
二，获取微信用户信息 1.getUserInfo:至2021年4月开始getUserInfo不需要用户授权直接返回用户的匿名信息，因此getUserInfo已经不能用来获取用户的昵称和头像信息了。
2.open-data：若仅仅只是要展示用户微信头像和昵称可以直接使用open-data组件进行渲染，无需用户确认。
3.getUserProfile：若要直接获取用户的头像昵称信息，需要使用getUserProfile，且每次使用getUserProfile都会弹窗让用户确认信息。getUserProfile必须使用点击事件触发
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b48c6bfa2c8eae265ea303bba485e29/" rel="bookmark">
			嵌入式汇编实验二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		嵌入式汇编实验二 环境：ADS
软件：Metrowerks CodeWarrior for ARM Developer Suite v1.2
一、复制数据 要求：用汇编语言编程实现：将存储器中起始地址M1处的4个字数据复制到地址M2处。
AREA SCopy,CODE,READONLY M1 DCD 0x0001,0x0002,0x0003,0x0004 M2 DCD 0x0000,0x0000,0x0000,0x0000 ENTRY CODE32 START LDR R0,=M1	;M1的地址 LDR R1,=M2	;M2的地址 LDMIA R0!,{R4-R7} STMIA R1!,{R4-R7} END 二、累加 要求：用汇编语言编程实现：100+101+102+…+200，其和存于R0。
AREA Test,CODE,READONLY ENTRY CODE32 START MOV R0,#0 MOV R1,#100 LOOP ADD R0,R0,R1 ADD R1,R1,#1 CMP R1,#201 BNE LOOP END 三、寻找最小值 要求：用汇编语言编程实现：从存储器中起始地址M1处的20个字节数据中，找出一个最小数存放在R0中。
AREA TEST2,DATA,READWRITE M1 DCB 0x20,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11 DCB 0x10,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01 AREA TEST1,CODE,READONLY ENTRY CODE32 START LDR R1,=M1 LDRB R0,[R1],#1	;存放最小值 MOV R3,#1	;次数 FIND LDRB R2,[R1],#1	CMP R0,R2 MOVHS R0,R2 ADD R3,R3,#1 CMP R3,#20 BNE FIND END 四、跳转表 要求：利用跳转表的思想编写一个汇编子程序，根据键入的值（存放在R0中）不同来完成不同的子程序跳转（假设有四个子程序SUB0、SUB1、SUB2、SUB3）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b48c6bfa2c8eae265ea303bba485e29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be0570f374e900e95a7d6d5b2b2c6de/" rel="bookmark">
			el-cascader__点击文字可选中__去掉单选按钮__选中后菜单收起__自定义数据显示在选项中（已测有用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图
直接上代码：
注意：css样式一定要全局设置，不要写在scoped下（否则没效果）
&lt;el-cascader v-model="form.classify" ref="cascader" :options="dataList" :props="defaultProps" clearable popper-class="cascader" @change="onSubmit" &gt;&lt;/el-cascader&gt; //在此处定义popper-class，是因为下面设置的样式需要全局设置才生效，使用定义的类，将不会影响其他页面的效果
export default { data() { return { formInline:{classify:""}, dataList: [{ id:1, name:"haha" }], defaultProps: { value: "id", label: "name", expandTrigger: 'hover' , checkStrictly: true, emitPath: false, } }}, methods: { onSubmit() {//选中之后，自动关闭菜单项 this.$refs.cascader.toggleDropDownVisible(); } } } // 此处dataList并不是按照el-cascader定义的value,lable定义的属性名，所以此处要做转换
// 级联选择器el-cascader，通过点击label文字部分选中 .cascader { .el-cascader-panel{ .el-radio{ width: 100%; height: 100%; z-index: 10; position: absolute; top: 10px; right: -10px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3be0570f374e900e95a7d6d5b2b2c6de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e786421dc6e7442945f485e87669b20b/" rel="bookmark">
			程序语义错误的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般情况下，程序有语法错误都可以检查出来，但是有语义错误就必须一些手段：
1.把自己当成一个计算机把程序走一遍
2.在程序的关键点插入printf（）语句，监视指定变量值的变化
3.利用调试器Debugger
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdef0ab3212c9f0ad21856c962343fd/" rel="bookmark">
			【Windows 应用程序开发详解】五.Windows用户模式和内核模式的定义与区分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【Windows 应用程序开发详解】五.Windows用户模式和内核模式的定义与区分 一、用户模式定义：二、内核模式定义：三、两则区别：四、用户模式组件与内核模式组件之间的通信。 一、用户模式定义： 启动用户模式应用程序时，Windows 会为该应用程序创建进程，进程为应用程序提供专用的虚拟地址空间和专用的句柄表 。 由于应用程序的虚拟地址空间为专用空间，因此一个应用程序无法更改属于其他应用程序的数据。 每个应用程序都隔离运行，如果一个应用程序发生故障，则故障仅局限于该应用程序。 其他应用程序和操作系统不会受该故障的影响。除了专用之外，用户模式应用程序的虚拟地址空间也受到限制。 在用户模式下运行的处理器无法访问为操作系统保留的虚拟地址。 限制用户模式应用程序的虚拟地址空间可防止应用程序更改以及可能损坏关键的操作系统数据。
二、内核模式定义： 在内核模式下运行的所有代码都共享单个虚拟地址空间。 这意味着内核模式驱动程序不会与其他驱动程序和操作系统本身隔离。 如果内核模式驱动程序意外写入错误的虚拟地址，则属于操作系统或其他驱动程序的数据可能会受到安全威胁。 如果内核模式驱动程序发生故障，整个操作系统就会发生故障。
三、两则区别： 为了保证操作系统的代码和数据不被低权限的代码进行恶意的写入篡改，在X86和X64架构模式中定义了4个Ring等级，如下下图所示，目前在Windows一方面只使用了两个特权级，一个为Winodws内核模式使用的Ring0特权级，一个为用户模式使用的Ring3级
四、用户模式组件与内核模式组件之间的通信。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebffbb6645299b4ee2b0d4a8d80463df/" rel="bookmark">
			2、UE5源码编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加我微信入群探讨UE源码解读和引擎开发：13324598743，备注：UE
可从github，也可从如下我的网盘中下载UE5源码
链接：https://pan.baidu.com/s/18ch2QWNyZnT24uBUDWTHPg
提取码：jkqj
我使用的VS2019社区版。
解压后命令行执行Setup.bat如下，小水管慢慢装：
装完后执行GenerateProjectFiles.bat：
我双击打开生成的：UE5.sln
提示我安装C#
安装完成后，开始使用VS进行编译，因为我们经常会调试，此记得我们把启动工程选到UE5：
把解决方案配置选成：debug editor
然后选择UE5工程，右键生成即可。根据机器配置，时间从几小时到几天不等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd392d9639f60dd3e4e9d5d6d9c5b5c5/" rel="bookmark">
			【工作笔记】如何在MySQL官网下载Java连接MySQL数据库的驱动jar包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在开发时，Java连接MySQL数据库需要驱动jar包，而驱动包的版本要跟MySQL数据库版本相匹配，以下介绍怎样在MySQL官网下载各MySQL数据库对应版本的驱动包。
1、登陆Oracle官网（MySQL属于Oracle公司），网址Oracle | Integrated Cloud Applications and Platform Services，或者直接登陆MySQL的官网，MySQL
2、选择“Product”-&gt;“MySQL”
3、选择“Download”
4、选择“MySQL Community(GPL) Downloads”
5、选择“Connector/J”
6、选择“Platform Independent”
7、在此页面选择“Download”
8、如没有注册MySQL网站的账户，直接选择“No thanks,just start my download.”
9、开始下载，点确认即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e1ad6ab95e15fd5aacf4b89d0aa73cd/" rel="bookmark">
			React项目配置TypeScript环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情况1： 创建一个新项目 用Create React App 去创建一个typescript的项目
npx create-react-app my-app --template typescript # or yarn create react-app my-app --template typescript 注意⚠️：如果你通过npm install -g create-react-app 安装了create-react-app，建议你通过npm uninstall -g create-react-app 或 yarn global remove create-react-app 卸载这个包。因为全局安装的create-react-app 已不再支持
情况2： 在现存项目中添加tsx环境 第一步：安装依赖
npm install --save typescript @types/node @types/react @types/react-dom @types/jest # or yarn add typescript @types/node @types/react @types/react-dom @types/jest 第二步：把JavaScript文件重新命名，改为TypeScript文件(例如 src/index.js 改成src/index.tsx)，并且重启你的开发环境服务
参考：create-react-app文档
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1666e732ae60081879cf779e176b69a1/" rel="bookmark">
			1、UE设置使用openGL引擎方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加我微信入群探讨UE源码解读和引擎开发：13324598743，备注：UE
要周知，UE4.26以后，均不再支持落后的openGL引擎，转而使用vulkan引擎代替。因此在4.26以前可以通过在命令行参数中指定：-opengl来使用openGL引擎，在之后便不行了：
如图使用-vulkan则是使用vulkan引擎。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51452fb03b4259e8785094bf23df815e/" rel="bookmark">
			STM32学习：利用寄存器点亮LED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*使用普中PZ6806L开发板*/
由对应的LED模块的电路可知， 要想点亮一个LED，就要将其对应的引脚输出低电平。
要使用寄存器，首先要对其进行封装，具体代码如下：
#define PERIPH_BASE ((uint32_t)0x40000000) #define APB2PERIPH_BASE (PERIPH_BASE + 0x10000) #define GPIOC_BASE (APB2PERIPH_BASE + 0x1000) #define GPIOC_CRL	*(int*)(GPIOC_BASE+0X00) #define GPIOC_CRH	*(int*)(GPIOC_BASE+0X04) #define GPIOC_IDR	*(int*)(GPIOC_BASE+0X08) #define GPIOC_ODR	*(int*)(GPIOC_BASE+0X0C) #define GPIOC_BSRR	*(int*)(GPIOC_BASE+0X10) #define GPIOC_BRR	*(int*)(GPIOC_BASE+0X14) #define GPIOC_LCKR	*(int*)(GPIOC_BASE+0X18) #define AHBPERIPH_BASE (PERIPH_BASE + 0x20000) #define RCC_BASE (AHBPERIPH_BASE + 0x1000)	#define RCC_APB2ENR	*(unsigned int*)(RCC_BASE+0X18) 这些代码写在stm32f10x.h里，我使用的是写好的头文件，所以自己在写这些代码时其中的PERIPH_BASE,APB2PERIPH_BASE,GPIOC_BASE,AHBPERIPH_BASE,RCC_BASE都是定义好的，不需要再定义了，否则会出现警告"macro redefined"。其他寄存器的地址则通过“基地址+相对基地址的偏移量”得到。具体数据通过查询数据手册和开发板原理图可得到。
例如：
所有I/O接口均挂载在APB2上，而APB2又挂载在block2上，所以PERIPH_BASE为0x40000000。
而APB2PERIPH_BASE为（PERIPH_BASE+0x10000)
/*APB2起始地址*/
GPIOC地址为：
所以GPIOC_BASE=（APB2PERIPH_BASE+0x1000）
之后的GPIOC_CRL等寄存器可直接通过参考手册查的偏移量，在GPIOC_BASE上加就可以。
要注意的是这里的"unsigned int*"的作用是将立即数变为指针，外面的“*”是取内容运算符，使寄存器得到相应地址。
之后就是点亮LED的主程序：
int main() { /*第一步必须先开启时钟*/ RCC_APB2ENR |= 1&lt;&lt;4;	//通过移位运算开启GPIOC的时钟，'|'运算保持GPIOC之前的位不变	/*设置输入输出模式*/ GPIOC_CRL &amp;= ~(0X0F&lt;&lt;(4*0)); //对要进行操作的管脚复位，要操作几号管脚就是4*几 GPIOC_CRL |= (3&lt;&lt;(4*0)); //置位，设置输入输出模式 GPIOC_BSRR=(1&lt;&lt;(16+0)); //对应管脚输出低电平，LED亮 while(1){ GPIOC_BSRR=(1&lt;&lt;(16+0)); delay(0xFFFFF); GPIOC_BSRR=(1&lt;&lt;(0+0)); //对应管脚输出高电平，LED灭 delay(0xFFFFF); } } 之后下载程序到开发板就可以点亮LED了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db754af184fa0f66e75870189a8619fa/" rel="bookmark">
			常用Linux命令的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.学习Linux终端命令的原因 Linux刚面世时并没有图形界面，所有操作全靠命令完成，如瓷盘操作、文件存取、目录操作、进程管理、文件权限设定等在职场中，大量的服务器维护工作都是在远程通过SSH客户端来完成的，并没有图形界面Linux发行版本的命令大概有200多个，但是常用的命令只有10多个而已 2.常用Linux命令的基本使用 小技巧
（1）ctrl + shift + =放大终端窗口的字体显示
（2）ctrl + -缩小终端窗口的字体显示
（3）在敲出 文件/目录/命令的前几个字母之后，按下tab键，如果输入的没有歧义，系统会自动补全；如果还存在其他 文件/目录/命令，再按一下 tab 键，系统会提示可能存在的命令
（4） 按 上／下 光标键可以在曾经使用过的命令之间来回切换
（5）如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c
2.1 ls命令说明 ls是英文单词list的简写，其功能是列出目录的内容，是用户最常用的命令之一 2.1.1 特点：
Linux文件或目录名称最长的可以有256个字符以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示. 代表当前目录… 代表上一级目录 2.1.2 ls常用选项 参数含义-a显示指定目录下所有子目录与文件，包括隐藏文件-l以列表方式显示文件的详细信息-h配合-l以人性化的方式显示文件大小 2.1.3 ls通配符的使用 参数含义*代表任意个数个字符？代表任意一个字符，至少1个[]表示可以匹配字符组中的任一一个[abc]匹配a、b、c中的任意一个[a-f]匹配从a到f范围内的任意一个字符 2.2 cd命令说明 cd是英文单词change directory的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一 注意：Linux所有的 目录 和文件名 都是对大小写敏感的
命令含义cd切换到当前目录的主目录（/home/用户目录）cd ~切换到当前用户的主目录（/home/用户目录）cd .保持在当前目录不变cd …切换到上级目录cd -可以在最近两次工作目录之间来回切换 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ff3b696541428ce7f139f4b80cfc50/" rel="bookmark">
			【论文阅读】3D点云 -- PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本博客详解遵从论文讲述的顺序。但我们要明确该论文的要点，以更好的阅读论文：针对点云的3个特性，pointnet设计的应对方法，以及设计理念。
点云的无序性：网络使用了对称函数 (maxpooling) 来降采样点云的特征点云的各点之间影响：网络将局部点的特征与 全局特征 进行concat，综合信息预测结果点云的几何变化不变性（刚性变换）：网络添加了 T-net，学习一个仿射变换矩阵，来适应点云的旋转平移。
pointnet实现了多种任务：分类、零件分割、语义分割、3D目标检测。但对于本文，更重要的是抓住上面提到的核心点的设计。
虽然在现在来看，在相关研究中pointnet效果不理想，但在当时 pointnet 的提出是开创性的，pointnet++是在此基础上完成。而后的一系列论文，大多借鉴了pointnet++的对点云学习方式。
Abstract 【使用点云】点云是一种重要的几何数据结构。由于其不规则的格式，大多数研究人员将这些数据转换为规则的三维体素网格或图像集合。但是，这会使数据变得不必要的庞大，并导致问题。【本文设计】在本文中，我们设计了一种新型的直接使用点云的神经网络，它很好地考虑了输入点的 置换不变性（旋转不变形）。我们的网络名为PointNet，它为从对象分类、零件分割到场景语义解析的应用程序提供了统一的体系结构。
虽然简单，但PointNet是高效的。从经验上看，它表现出强劲的表现，甚至比现有技术更好。理论上，我们提供分析，以了解网络学到了什么，以及为什么网络在输入扰动和损坏方面是健壮的。 1. Introduction 在本文中，我们探讨了能够推理三维几何数据（如点云或网格）的深度学习体系结构。
【点云已有操作】由于点云或网格不是常规格式，大多数研究人员通常会将这些数据转换为常规的三维体素网格或图像集合（例如，视图），然后再将其输入深网体系结构。
【原因】典型的卷积结构需要高度规则的输入数据格式，如图像网格或三维体素，以便执行权重共享和其他内核优化。
【问题】然而，这种数据表示转换会使生成的数据变得不必要的庞大，同时还会引入数据量化，从而模糊数据的自然不变性。
【本论文解决方法】出于这个原因，我们将重点放在使用简单点云的3D几何体的不同输入表示上，并将结果命名为PointNets。点云是简单而统一的结构，避免了网格的组合不规则性和复杂性，因此更易于学习。然而，PointNets仍然必须尊重这样一个事实，即点云只是一组点，因此对其成员的排列是不变的，因此需要在网络计算中进行某些对称化。还需要考虑刚性运动的进一步不变性。
【PointNet是一个统一的体系结构】
它直接将点云作为输入，并为整个输入 输出类别标签，或为输入的每个点输出每个点 分割/部分标签。
我们网络的基本架构出人意料地简单，因为在初始阶段，每个点都被完全独立地处理。
在基本设置中，每个点仅由其三个坐标 (x,y,z)表示。可以通过计算法线和其他局部或全局特征来添加其他维度。【方法的关键是使用单个对称函数max pooling】
网络有效地学习一组优化函数/标准，这些函数/标准 选择点云中感兴趣或信息丰富的点，并对其选择的原因进行编码。网络的最终完全连接层将这些学习到的最佳值聚合到上述整个形状的全局描述符中（形状分类），或用于预测每点标签（形状分段）。【输入格式很容易应用刚性或仿射变换，因为每个点都独立变换】
因此，我们可以添加一个依赖于数据的空间变换网络，该网络尝试在点网处理数据之前对数据进行规范化，以便进一步改进结果。【对方法进行了理论分析和实验评估】
我们证明了我们的网络可以逼近任何连续的集合函数。
更有趣的是，我们的网络通过一组稀疏的关键点学习总结输入点云，这些关键点大致对应于根据可视化显示的对象骨架。理论分析提供了一种理解，为什么我们的点网对输入点的小扰动以及通过点插入（异常值）或删除（缺失数据）而导致的损坏，具有高度鲁棒性。
我们工作的主要贡献如下：
我们设计了一种新颖的深网体系结构，适用于使用三维无序点集；我们展示了如何训练这样一个网络来执行3D形状分类、形状部分分割和场景语义解析任务；我们对我们的方法的稳定性和效率进行了全面的实证和理论分析；我们展示了网络中选定神经元计算的3D特征，并对其性能进行了直观解释。
用神经网络处理无序集的问题是一个非常普遍和基本的问题——我们希望我们的想法也能转移到其他领域。
2. Related Work 【点云特征当前获取方式：针对不同任务手工制作】
点云的大多数现有特征都是针对特定任务手工制作的。点特征通常对点的某些统计特性进行编码，并设计为对某些变换保持不变，这些变换通常分为内在[2,24,3]或外在[20,19,14,10,5]。它们还可以分为局部特征和全局特征。对于特定的任务，找到最佳的特征组合并非易事。
【在3D数据上深度学习】
3D数据有多种流行的表示形式，导致了各种学习方法。
Volumetric CNNs：[28,17,18]是将3D卷积神经网络应用于体素化形状的先驱。然而，由于数据稀疏性和三维卷积的计算成本，体积表示受到其分辨率的限制。FPNN[13]和Vote3D[26]提出了处理稀疏性问题的特殊方法；然而，它们的操作仍然是在稀疏的体积上进行的，因此处理非常大的点云对它们来说是一个挑战。多视图CNN：[23,18]尝试将3D点云或形状渲染为2D图像，然后应用2D conv网络对其进行分类。通过精心设计的图像CNN，这一系列方法在形状分类和检索任务上取得了卓越的性能[21]。但是，将它们扩展到场景理解或其他3D任务（如点分类和形状完成）是非常重要的。光谱CNN：略。基于特征的DNN：[6,8]首先通过提取传统形状特征将3D数据转换为向量，然后使用完全连通的网络对形状进行分类。我们认为它们受到提取特征的表示能力的限制。
【对无序集的深入学习】
从数据结构的角度来看，点云是一组无序的向量。虽然深度学习的大部分工作都集中在常规输入表示上，如序列（在语音和语言处理中）、图像和体积（视频或3D数据），但在点集的深度学习方面做的工作并不多。
Oriol Vinyals等人[25]最近的一项工作研究了这个问题。他们使用具有 注意力机制的读-写网络来消耗无序的输入集，并表明他们的网络具有对数字进行排序的能力。然而，由于他们的工作集中在通用集合和NLP应用程序上，因此集合中缺少几何体的作用。
3. Problem Statement 【输入】我们设计了一个深度学习框架，直接使用无序点集作为输入。点云表示为一组3D点 { P i ∣ i = 1 , . . . , n } \{Pi | i = 1, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23ff3b696541428ce7f139f4b80cfc50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e3a191eefccdf16e2a6baf947734a9/" rel="bookmark">
			(三) 三维点云课程---RANSAC结合最小二乘求解点云的地面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三维点云课程—RANSAC结合最小二乘求解点云的地面 三维点云课程---RANSAC结合最小二乘求解点云的地面 三维点云课程---RANSAC结合最小二乘求解点云的地面1.RANSAC的步骤2.RANCAC的代码分析2.1输入参数 τ ， N \tau，N τ，N的分析2.2 平面模型的创建2.3统计内点的个数2.4最小二乘优化2.5提前终止RANSAC的迭代 3.RANSAC完整代码 1.RANSAC的步骤 1.从原始点中随机选择三个点，建立平面模型2.求解平面模型，比如 a x + b y + c z + d = 0 ax+by+cz+d=0 ax+by+cz+d=03.其他点相对该平面的误差，误差表示为其他点相对该平面的距离 d i d_i di​4.统计内点的个数,点为内点的条件 d i &lt; τ d_i&lt;\tau di​&lt;τ,其中 τ \tau τ是人为设定的5.重复1-4步的N次迭代，选择N次迭代中内点数最多的平面模型
2.RANCAC的代码分析 2.1输入参数 τ ， N \tau，N τ，N的分析 关于 τ \tau τ的确定是通过实验得到的，其实也可以通过卡方分布得到，但是卡方分布的要求较多，实际中并不满足卡方的要求，大多数是通过实验得到的。
迭代次数N的确定
( 1 − ( 1 − e ) s ) N = 1 − p N = l o g ( 1 − p ) l o g ( 1 − ( 1 − e ) s ) (1-(1-e)^s)^N=1-p \\ N=\frac{log(1-p)}{log(1-(1-e)^s)} (1−(1−e)s)N=1−pN=log(1−(1−e)s)log(1−p)​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e3a191eefccdf16e2a6baf947734a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd9d6ef7061a0b667221c2463df834a8/" rel="bookmark">
			2021-10-28-使用Python自动模拟按键库：pyautogui，但是反应太迟钝了，感觉很慢，可以用 pyautogui.PAUSE 调整速度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pyautogui.PAUSE 默认为 0.1，你可以将它调小，变得更快，或者调大，变得更慢 然而，凡事过犹不及，你知道就好~ import pyautogui as auto auto.PAUSE = 0.03 string = 'I want you to run faster' for s in string: auto.press(s) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f750d6da07a92aa30571d6db131206dd/" rel="bookmark">
			k8s中Pod创建流程，Master、Node、Pod架构表述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 k8s中Pod创建流程，Master、Node、Pod架构表述 基本流程图Master 架构Node 架构Pod 架构 基本流程图 用户通过API Server创建一个PodAPI Server将信息写入到etcd中存储scheduler检测到有未绑定Node节点的Pod，开始调度并更新Pod绑定到哪个节点，并发送给API ServerAPI Server 会把Pod绑定的节点信息写入到etcd和scheduler 本地留存一份Node结点上的kubelet通过API Server查看绑定的Pod，检测到新的pod被调度过来，于是将Pod相关数据传递给container runtime ，比如 Docker，去运行PodDocker将运行的信息传递给Container runtime，Kubelete可以从它获取到Pod状态，将状态更新到API Server中。API Server最后将状态写入etcd Master 架构 API Server：提供了HTTP Rest 接口的服务进程，对所有资源对象的增删改查等操作的唯一入口Contorller Manager: k8s 集群所有资源对象的自动化控制中心Schedular： ks集群中所有资源对象自动化调度控制中心ETCD： k8s集群注册服务发现中心，可以保存k8s集群中所有资源对象的数据 Node 架构 在 OS 上去创建容器所需要运行的环境，最终把容器或者 Pod 运行起来，也需要对存储跟网络进行管理。
Kubelet: 负责Pod对应容器的创建，启动和停止等操作，与master节点合作
kube-proxy: 使用iptabels进行组建Kunernetes的网络实现互通
Storage plugin:配置容器存储
Network plugin： 配置容器网络
Container Runtime： 启动配置这个容器和这个容器的运行环境
Pod 架构 一个Pod里面有一个或多个容器，定义容器运行的方式，提供给容器其共享的运行环境（网络等）。
在 Pod 里面，我们也可以去定义容器所需要运行的方式。比如说运行容器的 Command，以及运行容器的环境变量等等。Pod 这个抽象也给这些容器提供了一个共享的运行环境，它们会共享同一个网络环境，这些容器可以用 localhost 来进行直接的连接。而 Pod 与 Pod 之间，是互相有 isolation 隔离的。
Pod 可包含多个容器在里面，每个 Pod 至少会有一个 Pause 容器，其它用户定义的容器都共享该 Pause 容器，Pause 容器的主要作用是用于定义 Pod 的 ip 和 volume 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10d031a36e45f32868d81ec14b2ab0d6/" rel="bookmark">
			汇编语言中常见的标志位: CF, PF, AF, ZF, SF,TF,IF,DF, OF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、运算结构标志位
1.CF(进位标志位)：主要用来反映运算是否产生进位或借位，产生进位或借位则CF=1，否则CF=0。
2.PF(奇偶标志位)：用于反映运算结果中“1”的个数的奇偶性，如果“1”的个数为偶数，则PF=1，否则，PF=0。
3.AF(辅助进位标志位)：运算过程中看最后四位，不论长度为多少，最后四位向前有进位或者借位，则AF=1，否则，AF=0。
4.ZF(零标志位)：用来反映运算结果是否为0，如果运算结果为0，则ZF=1，否则ZF=0。
5.SF(符号标志位)：用来反映运算结果正负的符号位，运算结构为正数时，SF=0，否则SF=1。
6.OF(溢出标志位)：用于反映有符号数加减运算所得结果是否溢出，如果运算结果超过当前运算位数表示的范围，则为溢出，OF=1，否则，OF=0。
二、状态控制标志位
状态控制标志位是用来控制CPU操作的，它们要通过专门的指令才能使之发生改变。
1.TF(追踪标志位)：当TF被置为1 时，CPU进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这种方式主要用于程序的调试。
注意：指令系统中没有专门的指令来改变标志位TF的值，但程序员可用其他办法来改变其值。
2.IF(中断允许标志位)：用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求，当IF=1时，CPU响应CPU外部的可屏蔽中断发出的中断请求，当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。
注意：不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。
3.DF(方向标志位)：在串处理指令中，每次操作后，如果DF=0，则si、di递增，如果DF=1，则si、di递减。
注意：DF的值是由程序员进行设定的。（cld命令是将DF置为0，std命令是将DF值为1）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab65512fe317ea4096a554e1fccdcf70/" rel="bookmark">
			RefineNet: Multi-path Refinement Networks for High-Resolution Semantic Segmentation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 出处 2017 CVPR
2. 问题 重复的二次采样操作如池化，卷积会导致图像分辨率快速下降。
一种解决方案是使用反卷积作为上采样操作，来生成高分辨率的特征图。反卷积操作无法恢复低维特征，因为已经在前向传播阶段中的下采样操作中丢失了。低维信息对边界和细节的精确预测是至关重要的。DeepLab使用空洞卷积产生大的感受野，不需要下采样图片。这个方法有两个限制：
需要对大量的细节（高分辨率）特征图做卷积，计算昂贵。空洞卷积是一种粗糙的sub-sample方式，会丢失重要细节 另一种解决方案是利用来自中间层的特征，生成高分辨率的预测，比如FCN方法。来自中间层的特征能够描述目标的mid-level表示，仍然能保持空间信息。这种信息是对前几层特征的补充，而且对深层高维特征的补充，但仍然缺乏空间信息。
3. 解决方案 提出了RefineNet，一个一般的多路改进网络，能够显式地利用下采样过程中所有可用的信息，使用long-range残差连接实现高分辨率预测。RefineNet能够混合粗糙的高维语义特征和细粒度的低维特征，生成高分辨率的语义特征图。这样保证了网络能够很容易的通过网络的long-range残差连接反向传播到较早的低维层。
捕获高维语义特征的更深层可以使用前几层细粒度的特征来直接改善。RefineNet的独立组件根据恒等映射习惯利用残差连接，使得更高效的end-to-end训练。使用连接的残差池化，捕获丰富的上下文背景。
4. 整体结构 将预训练的Resnet根据特征图的分辨率分成4个block，利用4个级联的结构-refinenet单元，每一个都和一个resnet块和上一步refinenet块直接相连。
RefineNet-3的目标是使用来自RefineNet-3的高分辨率的特征来修正RefineNet-4输出的低分辨率的特征。最后一步，高分辨率的特征图传入softmax层，进行最终预测，得到密集的分数图。分数图然后上采样匹配原始图像大小。
作者把Resnet block和RefineNet模块之间的饿连接就叫做long-range残差连接
在前向传播过程中，long-range残差连接convey编码了visual细节的低维特征来修正粗糙的高维特征图。
4.1 RefineNet介绍 RefineNet block的第一部分是一个适应性的卷积集合，主要用于微调Resnet的预训练权重。 每个input path通过2个RCU线性传递
RCU 残差卷积单元是原始resnet卷积单元的简单版本，移除了bn层。
Multi-resolution fusion
所有的path input通过Multi-resolution fusion block融合进一个高分辨率的特征图。
首先通过卷积生成相同维度的特征图，然后上采样小特征图至最大的分辨率。最后将所有特征图求和。
Chained residual pooling
链式的残差池化用于捕获大图像范围的背景上下文。使用多种窗口大小来pool特征，通过可学习的权重来融合这些特征。
这个组件是将多个池化块连接起来，每个池化块由一个最大池化和一个卷积层组成。当前池化块可以重用之前池化操作的结果，因此不需要使用大的池化窗口就可以从大region获取特征。
所有池化块的输出特征图通过残差连接的求和操作和输入特征图融合。
池化层后边的卷积层的作用：求和操作的加权层，卷积层能调节训练过程池化块的重要性。
Output convolutions
RefineNet包括short-range和long-range残差连接，短期残差连接指的是一个RCU或残差池化组件中的local shortcut，长期连接指的是RefineNet模块和ResNet块之间的连接。
5. 启发 高维语义特征能够帮助图像区域的类别识别，低维特征能生成尖锐、细节的边界，用于高分辨率预测。
如何高效利用中间层特征仍然是一个开放性问题。
作者对所有的卷积单元引入残差连接，使得梯度能够高效反向传播，使得多级联RefineNet得到高效训练。
作者在Chained residual pooling中使用了ReLU层，ReLU对于随后的池化操作非常有效，使得模型对于学习率的变化不那么敏感。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f8b5766848226a7367d5768046c8b8/" rel="bookmark">
			arm64 kaslr 开启配置就能用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux平台上构建纵深防御系统的过程中，KASLR（内核地址空间布局随机化）几乎是必须使能的一项重要基础安全功能，多数安全从业人员接触KASLR都是从攻击的角度开始的，对其基本原理和用途多少有些了解，但当我们站在攻击的对立面想要在arm64架构上使能这个功能的时候，我们遇到了一些问题。
在我和我的同事中，有一个很普遍的认识错误，即kaslr的使能就是开启一些配置，配置好了就能正常使用。并且网络上的各种教程也是按照这个流程“成功”使能KASLR，让这种错误的认识广为流传。
按照相关文档的介绍，我们打开了kernel和u-boot相关的配置，如下：
// u-boot启用以下配置 CONFIG_ARMV8_SEC_FIRMWARE_SUPPORT=y // kernel启用一下配置 CONFIG_RANDOMIZE_BASE=y 重新编译u-boot和kernel之后，我们多次启动系统，通过检查对比每次启动后内核符号的地址，我们发现KASLR并未生效，因为内核符号地址是同一个值。
发现这个问题之后，我个人进行了一个小小的反思，因为在我的认识里，诸如PAN、PXN和DEP等系统自带的功能，只要开启对应的配置就能使能这些功能，所以在向业务团队提需求的过程中，这种类型的需求基本使用一到两句话轻描淡写，殊不知这样的需求描述可能完全没有可指导落地的价值，到功能验收和测试的时候可能还会埋怨业务团队不重视安全、不积极配合。
由此引发我联想到一个更加普遍的问题，即甲方安全人员如何才能制定出可执行、可落地的安全方案？在这个案例上我得到的启发是，制定安全方案的人，需要对业务有足够多的了解，了解到能够根据业务的真实逻辑来制定安全方案，而不是单方面从安全自身的需求进行脱离业务逻辑的表述，这种表述大概率不符合业务的实际情况，也不会得到业务方的认可。
因此，在KASLR这个案例上，我决定进一步分析arm64实现KASLR的原理。因为我们使用的硬件平台来自NXP，所以相关逻辑可能与其他平台不能完全契合，但大体思路应该都是相似的。
arm64平台实现KASLR的总体思路是通过trustzone运行一个sec firmware，sec firmware会负责生成kaslr-seed，也就是用来计算内核偏移的随机种子。其中，sec firmware的加载工作由u-boot负责执行，u-boot通过ppa（可以理解为trustzone中的一个应用，用来将sec frimware加载到trust总额中运行）将sec firmware（如teeOS.bin）加载到trustzone中运行，然后在fdt_fixup的过程中调用sec firmware生成kaslr-seed，并将这个值设置到对应的fdt。
整个实现思路的安全主旨就是通过trustzone来生成随机数，以保证随机数的安全性，进而保证内核地址的随机性。但在我们使用的平台上没有实现trustzone，ppa也不会生成和运行，因而导致虽然我们开启了必须的配置，但实际的业务逻辑并不支持KASLR的运行，所以必须在现有平台上重新构建安全地生成随机数的逻辑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d3ebe799e58abffc4a2fab4e0a3d4a/" rel="bookmark">
			从ICCV 2021看域泛化与域自适应最新研究进展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		©PaperWeekly 原创 · 作者 | 张一帆
学校 | 中科院自动化所博士生
研究方向 | 计算机视觉
Domain adaptation（DA: 域自适应），Domain generalization（DG: 域泛化）一直以来都是各大顶会的热门研究方向。DA 假设我们有有一个带标签的训练集（源域），这时候我们想让模型在另一个数据集上同样表现很好（目标域），利用目标域的无标签数据，提升模型在域间的适应能力是 DA 所强调的。
以此为基础，DG 进一步弱化了假设，我们只有多个源域的数据，根本不知道目标域是什么，这个时候如何提升模型泛化性呢？核心在于如何利用多个源域带来的丰富信息。本文挑选了四篇 ICCV 2021 域泛化与域自适应相关的文章来研究最新的进展。
CrossNorm-SelfNorm
论文标题：
CrossNorm and SelfNorm for Generalization under Distribution Shifts
论文链接：
https://arxiv.org/abs/2102.02811
代码链接：
https://github.com/amazon-research/crossnorm-selfnorm
简而言之，Batch Normalization 与 instance normlization 通常都假设训练数据与测试数据独立同分布。本文提出了两种新的 normalization 方法，CrossNorm 和 SelfNorm，二者可以很好的提升模型的泛化性。
1.1 Motivation and Insights
文章的两个方法分别对应两个目标：
1. 扩增训练数据分布。传统的 normalization 都是为了使得训练更加稳定和快速，那么作者是否能用 normalization 的方法进行数据的增强呢？答案是肯定的。一般来说，作者认为 RGB 图像的均值和方差代表了他的风格信息，交换他们的均值和方差不会对类别标签产生影响。CrossNorm 要做的事情就是在训练中交换特征图 channel-wise 的均值和方差，使得模型对风格变化更加鲁棒。
2. 减小域分布偏差。即使有了 1，模型依然会遇到完全没有见过的风格。一种可行的方式即减小训练和测试数据之间的分布。文章发现，作者可以通过调整 RGB 图像的均值和方差来缩小这种风格的差异。而 SelfNorm 的目标就是使用 attention 机制来调整 channel-wise 的均值和方差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d3ebe799e58abffc4a2fab4e0a3d4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab61a4fcea7606f8abc05f356fb514d/" rel="bookmark">
			编写一个程序，输入若干个整数，以-1标记为结束，输出其中的最大值和最小值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解析：利用while循环接收用户的输入，用break退出循环语句。第一次输入时，将该数同时赋给最大值和最小值，对以后输入的数进行比较，将最大值赋给max，最小值赋给min。这样对数组扫描一遍即可求出其中的最大数和最小数。对应的代码如下：
int main(){ int max, min, first = 1, num; printf("请输入若干个整数\n"); while (1){ scanf("%d", &amp;num); if (num == -1) break; while (first){ max = min = num; --first; } if (max &lt;= num) max = num; if (min &gt;= num) min = num; } printf("最大值是%d，最小值是%d\n",max,min); return 0; } 输入整数数字为1，2，3，4，5，6，7，8，88，99，-1，10。实现效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d61abc61d4994e97ffc6fcd70f658c3/" rel="bookmark">
			从键盘随机输入10个整数，然后从小到大顺序输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码如下：
int main(){ int num[10],i,j; printf("请输入10个整数\n"); for (i = 0; i &lt;10; i++){ scanf("%d", &amp;num[i]); } for (i = 0; i &lt; 10; i++){ for (j = i+1; j &lt; 10; j++){ if (num[i]&gt;num[j]){ int t; t = num[i]; num[i] = num[j]; num[j] = t; } } } for (i = 0; i &lt; 10; i++){ printf(" %d ", num[i]); } return 0; } 输入10 9 8 7 6 5 4 3 2 1十个整数后，运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d61abc61d4994e97ffc6fcd70f658c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee374d3759be62ee256780732f31bbf4/" rel="bookmark">
			Android 图片下载工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class DownGoodsImage { private Context context; private String filePath; private String fileName; private Bitmap mBitmap; private String mSaveMessage = "失败"; private final String TAG = "DOWNLOADIMG"; private ProgressDialog mSaveDialog = null; private Handler handler = null; String path = Environment.getExternalStorageDirectory().getAbsolutePath(); //myfile是我们要创建的文件夹的名字，这里的意思就是在这个路径下创建这个文件夹 File goodsImages = new File(path + "/goodsImages"); private List&lt;File&gt; list = new ArrayList&lt;&gt;(); private boolean download = true; public void downGoodsImg(String filePaths,String fileName) { filePath = filePaths; fileName = fileName; try { list = FileUtils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee374d3759be62ee256780732f31bbf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/622891e7cd02e58bef9643f92bbda4e8/" rel="bookmark">
			容器交付，k8s项目java实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		容器交付流程介绍 容器交付流程k8s部署java项目流程细节k8s部署java项目制作镜像第一步，准备java项目，把java进行打包（jar包或者war包） 第二步，制作dockerfile镜像开始打包，制作镜像本地启动制作好的镜像，查看是否可以访问网页本地查看 发布镜像到镜像服务器中登录你的Dockerhub账户上传镜像在slave01节点上拉取镜像 部署镜像暴露应用（重要）执行yaml文件，启动pod对外暴露端口使用ip地址访问本地访问网页访问 容器交付流程 k8s部署java项目流程细节 k8s部署java项目制作镜像 第一步，准备java项目，把java进行打包（jar包或者war包） 需要的两个依赖环境：
java环境 jdk环境maven环境 把java项目打包（springboot）
注意：编写DockerFile文件
第二步，制作dockerfile镜像 查看docker状态
systemctl status docker.service 处于启动状态
开始打包，制作镜像 docker build -t [name:tag] . // 创建docker镜像 docker build -t lieonchou/java-demo-01:latest . //最后的一个点符号千万不要漏掉代表在当前目录下的dockerfile创建，否则创建失败 创建成功
** 查看创建的镜像**
docker images 本地启动制作好的镜像，查看是否可以访问 docker run -d -p 8111:8111 [镜像名称] -t// -d 在后台运行，-p开放的端口号 docker ps //查看正在运行的docker 运行成功
网页本地查看 访问成功
发布镜像到镜像服务器中 我使用Dockerhub官方服务器。
登录你的Dockerhub账户 docker login [dockerhub_username] // 登录你的账户 输入用户名和密码，登录成功！
上传镜像 docker push [镜像名]:[版本号] // 上传镜像 正在推送
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/622891e7cd02e58bef9643f92bbda4e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69a221a340d9004d501390070d5b9cc7/" rel="bookmark">
			【工作笔记】如何在官网下载JDK的历史版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工作中许多开发软件都需要在JRE环境下运行，有一些软件因为版本原因要求Java的历史版本，下面记录下在Oracle官网下载JDK的历史版本。
1.进入官网
Oracle | Integrated Cloud Applications and Platform Services​
2.选择“Product”-&gt;“Java”
3.选择“Download Java”
4.选择“Java archive”
5.网页往下拉，找到对应版本，如Java 8
6.进入这个页面，往下拉，找到对应系统的版本
PS：下载历史版本需要Oracle账户。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f24830724a90c56690d69a620b0fbb75/" rel="bookmark">
			Spring Security系列教程之SpringSecurity中的密码加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
截止到现在，一一哥已经带各位学习了很多关于SpringSecurity的知识点，但是Spring Security作为一个安全框架，其中必然就应该带有安全加密方面的内容，所以本篇文章，一一哥 就带各位来学习Spring Security中的密码加密机制。
Let's go！
一. 密码加密简介
1. 散列加密概述
我们开发时进行密码加密，可用的加密手段有很多，比如对称加密、非对称加密、信息摘要等。在一般的项目里，常用的就是信息摘要算法，也可以被称为散列加密函数，或者称为散列算法、哈希函数。
这是一种可以从任何数据中创建数字“指纹”的方法，常用的散列函数有 MD5 消息摘要算法、安全散列算法(Secure Hash Algorithm)等。
2. 散列加密原理
散列函数通过把消息或数据压缩成摘要信息，使得数据量变小，将数据的格式固定下来，然后将数据打乱混合，再重新创建成一个散列值，从而达到加密的目的。
散列值通常用一个短的随机字母和数字组成的字符串来代表，一个好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理时，如果我们不抑制冲突来区别数据，会使得数据库中的记录很难找到。
但是仅仅使用散列函数还不够，如果我们只是单纯的使用散列函数而不做特殊处理，其实是有风险的！比如在两个用户密码明文相同时，生成的密文也会相同，这样就增加了密码泄漏的风险。
所以为了增加密码的安全性，一般在密码加密过程中还需要“加盐”，而所谓的“盐”可以是一个随机数，也可以是用户名。”加盐“之后，即使密码的明文相同，用户生成的密码密文也不相同，这就可以极大的提高密码的安全性。
传统的加盐方式需要在数据库中利用专门的字段来记录盐值，这个字段可以是用户名字段(因为用户名唯一)，也可以是一个专门记录盐值的字段，但这样的配置比较繁琐。
3. Spring Security中的密码处理方案
那么在Spring Security中，对密码是怎么进行处理的呢？其实Spring Security对密码的处理方案，有如下3种方式：
对密码进行明文处理，即不采用任何加密方式；
采用MD5加密方式；
采用哈希算法加密方式。
4. BCryptPasswordEncoder简介
以上说的是3种密码处理方案，并不代表只有3种加密算法，这个请大家注意哦！
实际上，Spring Security提供了多种密码加密算法，但官方推荐使用的是BCrypt Password Encoder方案，如下图所示：
我们开发时，用户表中的密码通常是使用MD5等不可逆算法加密后存储，但为了防止彩虹表破解，可以先使用一个特定的字符串(如域名)进行加密，然后再使用一个随机的salt(盐值)加密。其中特定的字符串是程序代码中固定的，salt是每个密码单独随机的，我们一般会给用户表加一个字段单独存储，但这样比较麻烦。
而BCrypt算法却可以随机生成salt并混入最终加密后的密码，验证时也无需单独提供之前的salt，从而无需单独处理salt。不同于 Shiro 中需要自己处理密码加盐，在 Spring Security 中，BCrypt Password Encoder 本身就自带了盐，所以处理起来非常方便。
另外BCryptPasswordEncoder使用BCrypt强哈希函数，我们在使用时可以选择提供strength和SecureRandom参数。strength值(取值在4~31之间，默认为10)越大，则密钥的迭代次数就越多，密钥迭代次数为2^strength。
二. 利用BCryptPasswordEncoder进行加密
了解了这些基本的理论知识之后，壹哥 就带各位进行代码实现啦。
我们继续在之前的案例基础之上进行本案例的代码实现，所以项目创建过程略过，请参考之前的章节内容。
1. 编写register接口
为了方便测试，我们首先在UserController中编写一个register接口，用于注册一个新用户，在添加用户时对密码进行加密。
@Autowired private PasswordEncoder passwordEncoder; /** * 添加用户.这里我们采用表单形式传参,传参形式如下: * http://localhost:8080/user/register?username=test&amp;password=123 */ @GetMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f24830724a90c56690d69a620b0fbb75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d23059386570e34e95e06e97385b14cb/" rel="bookmark">
			【Windows】Windows10 企业版 LTSC/Windows Server 2019如何安装应用商店和UWP应用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司使用的Windows都是企业版，因为平时习惯使用OneNote for windows10来记笔记，所以就想在公司电脑都装上OneNote，但是发现企业版不内置应用商店，也无法使用OneNote for windows10离线安装包来进行安装。查了很多教程最后终于找到了最简单并且能成功的方法。该方法适用于所有UWP应用在Windows企业版/Windows Server 2019上安装。我的操作系统是Windows10 LTSC 1809和Windows Server 2019，测试均有效。
1、安装应用商店 首先无法直接使用UWP离线安装包安装应该是因为当前Windows并没有安装应用商店的架构组件，所以没有办法脱离应用商店直接安装UWP应用。我们就需要先安装应用商店。直接下载下面安装程序，直接双击运行等待安装结束，安装完成后电脑上就有应用商店了。
百度网盘链接 -提取码：xipl
这个时候就可以点开应用商店了，有的人说这样就可以正常下载安装应用商店里的应用了，但是我这边发现虽然能进去应用商店，但是点击应用下载就一直没有反应，什么也下载不了。不知道是不是我电脑的问题，如果到了这一步你可以正常下载应用了，就可以不往下看了。如果你也遇到了和我一样的情况，就请继续往下看。
2、使用UWP离线安装包来进行安装 安装完应用商店，我们就可以正常使用UWP离线安装包来进行安装了。我们已OneNote for Windows10为例。
百度网盘链接 - 提取码：nklc
下载OneNote的UWP离线安装包，用管理员权限打开 Windows Powershell，使用 Add-AppxPackage 命令安装离线安装包（注意修改安装包路径）
Add-AppxPackage C:\Microsoft.Office.OneNote_16001.11629.20028.0_neutral_~_8wekyb3d8bbwe.appxbundle 执行完之后查看开始菜单最近添加的应用，发现OneNote已经成功安装了。其他UWP应用安装方法相同，只需要更换相应离线安装包即可。 获取微软商店应用离线安装包的方法可以参考这篇文章：手把手教你在Win10上安装Microsoft To-Do客户端 - 简书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea8d326a0f80442525c126914ca28e3/" rel="bookmark">
			[C语言编程练习][07]编写一个程序， 提示用户输入杯数， 并以品脱、 盎司、 汤勺、 茶勺为单位显示等价容量。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在美国的体积测量系统中，1品脱等于2杯，1杯等于8盎司，1盎司等于2大汤勺，1大汤勺等于3茶勺。编写一个程序，提示用户输入杯数，并以品脱、盎司、汤勺、茶勺为单位显示等价容量。思考对于该程序，为何使用浮点类型比整数类型更合适？
/* 在美国的体积测量系统中，1品脱等于2杯，1杯等于8盎司，1盎司等于2大汤勺，1大汤勺等于3茶勺。 编写一个程序，提示用户输入杯数，并以品脱、盎司、汤勺、茶勺为单位显示等价容量。 思考对于该程序，为何使用浮点类型比整数类型更合适？ */ #include &lt;stdio.h&gt; int main(void) { const int a_1_2 = 2;	//1品脱等于2杯 const int b_8_1= 8;	//8盎司等于1杯 const int c_2_1 = 2;	//2大汤勺等于1盎司 const int d_3_1 = 3;	//3茶勺等于1大汤勺 float cups = 0; printf("请输入杯数: "); scanf("%f", &amp;cups); float PINT = cups / a_1_2;//品脱数 float OUNCE = cups * b_8_1;//盎司数 float SOUP = OUNCE / c_2_1;//大汤勺数 float TEA = SOUP / d_3_1;//茶勺数 printf("%.0f 杯对应的品脱数为: %.2f\n", cups, PINT); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea8d326a0f80442525c126914ca28e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5c3708055b279cc7696624b5c2fcc1/" rel="bookmark">
			用c语言编写以英文字母为元素的菱形图案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编写一个程序，输出菱形图案，第一行为一个字母A，第二行为三个字母B，以此类推，第n行为2n-1个相应的字母，以后每行递减，n由键盘输入。 解析： 使用for循环语句实现本题功能，外层for循环每输出一行执行一次。对于每输出的一行，先用for输出相应的空格，即进行输出定位，然后，用for循环输出相应的字母。其中用c标记每行要输出的字母，初值为'A',每输出一行，c自增加1.从而改变输出的字母，以便依次取'A','B','C'.对应的程序如下：
int main(){ char c; int i, j, k, n; printf("输入n:\n"); scanf("%d", &amp;n); printf("对应的菱形图为：\n"); c = 'A'; for (k = 1-n; k &lt;= n - 1; k++){ i = n-abs(k);//调用内部函数abs（k）来求出k的绝对值 for (j = 1; j &lt;= n - i + 1; j++){ //输出行定位 printf(" "); } for (j = 1; j &lt;= 2 * i - 1; j++){ //输出字母c printf("%c", c); } printf("\n"); c++; //进行加1，得到下一个字符数据 } return 0; } 当用户输入n的值为5时，实现效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4142bd8907ea929c229ac483cd1219e/" rel="bookmark">
			[C语言编程练习][01]输入ASCII码值，输出对应的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：编写一个程序，要求提示输入一个ASCII码值，然后打印输入的字符。
#include &lt;stdio.h&gt; int main(void) { int ascii; printf("请输入一个ASCII码值："); scanf("%d",&amp;ascii); printf("ASCII码值为 %d 对应的字符是 %c",ascii,ascii); return 0; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/320/">«</a>
	<span class="pagination__item pagination__item--current">321/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/322/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>