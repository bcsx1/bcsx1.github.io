<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3715113058db643809fab29a4f90ba6e/" rel="bookmark">
			Linux命令 uname 等获取Linux系统详情命令分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.uname命令：查看系统基本信息
1.Linux系统命令行的格式：命令 【选项】 【参数】（command [option] [arguments]）
2.uname命令可用于大多数的UNIX和类UNIX系统以及Linux
3.功能说明：uname用于获取电脑和操作系统的相关信息，可显示Linux主机所用的操作系统的版本，硬件的名称等基本信息
4.语法:uname[-amnrsvpio][help][-version]
5.参数
-a或者-all详细输出所有的信息，依次为
内核名称 主机名 内核版本号 内核版本 硬件名 处理器类型 硬件平台类型 操作系统名称 -m或者-machine:显示主机的硬件（cpu）名称
-n或者-nodename显示主机在网络节点上的名称或主机名称
-r或-release显示Linux操作系统内核版本号
-s或者-sysname显示Linux内核名称
-v显示操作系统是第几个version版本
-p显示处理器类型或者unknown
-i显示硬件平台类型或者unknown
-o显示操作系统名
-help获取帮助信息
-version 显示uname版本信息
二.查看linux系统架构的5条常用命令
说明:很多时候我们都需要查看Linux系统是32位还是64位系统架构类型。无论是使用的是桌面版还是只安装了文本界面的Linux环境，以下命令几乎可以通吃所有的Linux发行版本，例如:RHEL CentOS Fedora Scientific Linux Debian Ubuntu Linux Mint OpenSUSE等等
1.uname命令
uname -a命令可以直接显示Linux系统框架的命令，几乎可以工作在所有的Linux/Unix系统中 2.dpkg命令
dgkg的命令可用于查看Debian / Ubuntu操作系统是32位还是64 位，此命令只适用于基于Debian和Ubuntu的Linux发行版 在终端中执行如下命令 dpkg --print -architecture 3.arch命令
arch命令主要用于显示操作系统架构类型，与uname -m命令非常相似。如果输出x86_64则表示位64位系统，如果输出i686或者i386则表示为32位系统 4.getconf命令
getconf命令主要用于显示系统变量配置，可以用如下参数来查看linux系统那个架构 getconf LONG_BIT 5.file 命令
file命令可以配合 /sbin/init这个特殊参数来查看系统架构类型（/sbin/init在Ubuntu 5.10里面是链接到/lib/systemd/systemd的）： file /sbin/init 三.九个uname命令获取Linux系统详情的实例
当你在控制台模式下，无法通过“鼠标右键 &gt; 关于”获取操作系统的信息。这时，在Linux下，你可以使用uname命令，帮助你完成这些工作。 Uname是unix name的缩写。在控制台中实际使用的时候只需键入uname。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3715113058db643809fab29a4f90ba6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/215361274b0d5a0566f6620f15250b27/" rel="bookmark">
			js中window自带的四舍五入toFixed方法中的坑以及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，各位，我胡汉三~啊呸，我又回来啦，还改了名，换了头像，哈哈哈！时隔这么长时间不更新了，太忙了，平时笔记都记在了自己的电脑上，从今天起，继续更起来啊！不能偷懒了
好了，今天我们来聊聊Window.toFixed吧，曾几何时，如果你说，有一个小数，我要你保留两位小数，我一定会很自信的祭出toFixed，But，让我们一起来看看以下效果
what? 这跟我九年义务教育学习的四舍五入不一样啊！经过和一位大佬的交流，原来此方法遵循一个叫什么"银行家算法"，
银行家算法：4舍6入5取双 被修约的数字小于5时，该数字舍去;被修约的数字大于5时，则进位; 被修约的数字等于5时，要看5前面的数字，若是奇数则进位，若是偶数则将5舍掉，即修约后末尾数字都成为偶数;若5的后面还有不为"0"的任何数，则此时无论5的前面是奇数还是偶数，均应进位。
但是看js的运行结果，并不是严格按照这个算法来的，当然了，我们可对这个算法不感兴趣，活得干啊，砖得搬啊，要是耽误了搬砖，可不得了
于是，我们可以自己实现一个toFixed
大体思路如下： 先把数字转成字符串，进行小数点切割，切成数组（整数和小数）把需要保留的位数切割出来，然后取出保留位数的后一位，进行四舍五入判断然后把整数数组和小数字符串相加，得到一个操作数，相当于之前的number 乘以一个系数，把小数扩大了多少倍，变成了整数然后根据第二步取出的数，来进行判断，如果大于等于5，那么就把第三步的数整数进行+1操作然后根据保留位数，把整数和小数部分，截取出来，拼接上小数点 下面直接上代码 // 对传进来的number进行拆解 function disassembleNum(number, digit) { // 如果不是number类型的值，就return if (!number || typeof number !== 'number') return; // 将number转换成字符串，按小数点拆分成数组 let numberArr = (number + '').split('.'); // 看看传进来的保留位数是否大于number的小数位数 let exceed = numberArr[1].length &lt; digit; // 把整数位的数组找个变量存起来 let integer = numberArr[0]; // 如果保留位数大于小数位数，则在后面加差出来的0，如果小于等于小数位数，则截取出到保留位数的小数部分,找个变量存起来 let originDecimal = exceed ? numberArr[1].slice(0, digit + 1) + '0'.repeat(digit - numberArr[1].length) : numberArr[1].slice(0, digit + 1); // 小数部分 let decimal = originDecimal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/215361274b0d5a0566f6620f15250b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8aad3e6783bd9277303ba43f10d4321/" rel="bookmark">
			node服务端配置process.env环境变量在全局文件中使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常开发中我们会遇到不同运行环境下使用到不同值的情况，如果我们每次开启服务测试时来回去修改URL路径，那么就会很愚钝，那最好的方法就是在运行时根据不同的运行命令去使用不同的全局值，可以使用dotenv模块来解决这个问题。dotenv可以从一个文件中加载环境变量，并将它们注入到process.env中。这样，在整个应用程序中都可以访问这些环境变量。
以下是使用dotenv模块的步骤：
安装dotenv模块
npm install dotenv 在启动应用程序的入口文件中加载.env文件
require('dotenv').config({ path: './env.web' }); 在这个例子中，我们使用config方法加载了名为env.web的文件，并将其中的环境变量注入到process.env中。
在应用程序中使用环境变量
const nodeUrl = process.env.NODE_URL; console.log(`Node URL is ${nodeUrl}`); 在这个例子中，我们使用process.env对象读取名为NODE_URL的环境变量，并将其存储在nodeUrl变量中。然后我们将其打印出来。
需要注意的是，在.env文件中定义的所有变量都会被注入到process.env中。如果有多个.env文件，可以通过path选项来指定要加载的文件，并按照需要加载多个文件。
另外，需要注意的是，.env文件中的变量不应该包含引号或其他特殊字符。每行的格式应该是VARNAME=value。例如：NODE_URL=asd。
如果需要在不同应用程序中使用相同的环境变量，请将它们放置在.env文件中，并将文件放置在共享位置。这样，所有使用这些变量的应用程序都可以加载它们，这样就避免了在多个应用程序中重复定义环境变量的问题。
以上所说，如果现在有.env.web和.env.app两个文件，里面都有NODE_URL对应着两个不同的值，该如何使用运行命令去指定运行哪个文件呢？
可以通过使用命令行参数来实现这个功能。在Node.js中，可以通过process.argv数组来获取命令行参数。
例如，你可以运行以下命令来指定要加载的.env文件：
node app.js --env=app 在这个例子中，我们使用了--env选项来指定要加载的.env文件的名称。然后，我们在应用程序的入口文件中检查该选项，并加载相应的文件。
以下是一个示例：
app.js:
const dotenv = require('dotenv'); // 解析命令行参数 const args = process.argv.slice(2); const env = args.find(arg =&gt; /^--env=/.test(arg)) || '--env=web'; const envFile = env.split('=')[1]; // 加载env文件 dotenv.config({ path: `./${envFile}.env` }); // 使用环境变量 console.log(`Node URL is ${process.env.NODE_URL}`); 在这个例子中，我们使用process.argv数组获取了所有命令行参数，并使用args.find方法找到了--env选项。然后，我们将其值分离出来，并使用它来加载相应的.env文件。如果没有指定--env选项，则默认加载env.web文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8aad3e6783bd9277303ba43f10d4321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf0c8ab0f20901024c63457c543b084/" rel="bookmark">
			uniapp pdf阅读插件（手势缩放、显示页数） Ba-Pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pdf阅读 Ba-Pdf 简介（下载地址） Ba-Pdf 是一款uniapp显示PDF文档的插件。支持手势缩放、双击缩放；支持显示页数；支持快速拖动；自带选择pdf文件方法。
支持手势缩放、双击缩放支持显示页数支持快速拖动自带选择pdf文件方法 可与uniapp自带的 uni.chooseFile 搭配使用。
插件本身也自带选择Pdf方法 selectPdf（参考使用方法）。
截图展示 使用方法 在 script 中引入组件
const pdf = uni.requireNativePlugin('Ba-Pdf') 在 script 中调用
methods: { readPdf() { //显示pdf pdf.readPdf({ path: this.path, }, (res) =&gt; { console.log(res) uni.showToast({ title: res.msg, icon: "none", duration: 3000 }) }); }, selectPdf() { //选择pdf 本插件自带 pdf.selectPdf((res) =&gt; { console.log(res) if (res.outputPath) { this.path = res.outputPath; } uni.showToast({ title: res.msg, icon: "none", duration: 3000 }) }); }, } 显示pdf readPdf 方法参数 属性名类型默认值说明pathString‘’pdf文件路径，不能为空 选择pdf selectPdf 回调参数 属性名类型说明outputPathStringpdf文件选择输出目录 系列插件 图片选择插件 Ba-MediaPicker （文档）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf0c8ab0f20901024c63457c543b084/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/548f4191ec86741106c3eed6a3beb325/" rel="bookmark">
			PX4无人机环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PX4无人机资料开发 1.1 Ubuntu系统的安装及相关工具使用ubuntu 系统安装以及基础使用系统安装ubuntu基础使用常用工具使用git常用命令 1.2PX4开发环境搭建编译工具链的安装code安装使用 1.1 Ubuntu系统的安装及相关工具使用 ubuntu 系统安装以及简单使用以及git，markdown工具的使用常用工具使用（git markdown） ubuntu 系统安装以及基础使用 系统安装 准备一台电脑（8核，GPU，8G内存以上，固态硬盘），移动U盘（4G以上）
windows下使用虚拟机安装ubuntu
ubuntu单系统
windows与ubuntu双系统
rufus
Ubuntu18.04系统
制作启动盘教程
单系统安装教程
​ 双系统安装
​ uefi+gpt方式启动。
​ 双系统安装教程
​ ubutnu系统最好安装到固态硬盘上
​ 如果安装完毕，只能进入单个系统，而且重启后进入电脑boot manager，可以进去另一个系统。那么就需要进入ubuntu系统中来修改grub.cfg添加window启动引导项。
menuentry 'Windows 10' { search --file --no-floppy --set=root /EFI/MICROSOFT/BOOT/BOOTMGFW.EFI chainloader /EFI/MICROSOFT/BOOT/BOOTMGFW.EFI } [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uRjBHdKU-1648797860413)(…/img/chap1/grubwindow.png)]
ubuntu基础使用 常用工具下载 vim typora chrome wps gpu驱动 source源修改 快捷键 搜狗在线翻译等
alt+ctrl+t ：
中文输入法安装
使用
ubuntu命令
常用命令
tab 键自动补齐；
mv souce target 用target重命名source
cp souce target
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/548f4191ec86741106c3eed6a3beb325/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4df577ed2373347780ccfe5a5058722/" rel="bookmark">
			Retrofit核心源码分析（二）- 网络请求和响应处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章中，我们详细分析了 Retrofit 中的注解解析和动态代理实现，本篇文章将继续深入研究 Retrofit 的核心源码，重点分析 Retrofit 如何进行网络请求和响应处理。
网络请求 在使用 Retrofit 发起网络请求时，我们可以通过定义一个接口并使用 Retrofit 的注解来描述这个接口中的请求，Retrofit 会自动生成一个实现该接口的代理对象。当我们调用这个代理对象的方法时，Retrofit 会根据注解的描述构建一个 Request 对象，并使用 OkHttp 将这个 Request 发送出去。
在 Retrofit 中，我们可以通过 Retrofit#execute 或 Retrofit#enqueue 方法来发送请求。这两个方法的区别在于，execute 方法会阻塞当前线程直到请求完成，而 enqueue 方法会将请求加入到 OkHttp 的请求队列中，并在请求完成时通过回调通知我们。
我们先来看一下 execute 方法的实现：
public &lt;T&gt; T execute(Call&lt;T&gt; call) throws IOException { Utils.validateServiceInterface(call.request().tag(), call.request().url().toString()); return (T) callAdapter(call, call.request().tag()).adapt(call).execute(); } 在这个方法中，首先会对接口进行校验，确保这个接口是有效的。然后我们会根据请求的 Tag 和 URL 来获取适配器callAdapter，并使用适配器来执行请求。
适配器的作用是将请求的参数适配成 OkHttp 能够识别的形式，并将 OkHttp 的响应适配成我们需要的形式。Retrofit 提供了一系列的适配器，包括 Call 适配器、RxJava 适配器、CompletableFuture 适配器等。
我们来看一下 callAdapter 方法的实现：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4df577ed2373347780ccfe5a5058722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf042a63ab15a1723a5fe0f21f4af65/" rel="bookmark">
			如何在VS2010上创建项目进行C语言编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：新建项目 选择Visual C++、空项目、名称以及位置（后两个可以自定义）
点击确定，创建项目
注意：
.c是源文件
.h是头文件
第二步：添加.C文件 在源文件选项上右击-添加-新建项
选择C++文件、名称必须是.c结尾的文件
第三步：编写C语言代码 右击项目名称-属性
选择链接器-系统-子系统-下拉菜单选择控制台-确定
运行程序：调试-开始执行（不调试）
成功运行：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/804bf3fd2d9aec14cd6015b6f4c36486/" rel="bookmark">
			Java中获取当前服务器的IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取ip的第一反应就是：使用InetAddress这个类：方法如下
InetAddress.getLocalHost().getHostAddress(); public static void main(String[] args) { try { //用 getLocalHost() 方法创建的InetAddress的对象 InetAddress address = InetAddress.getLocalHost(); System.out.println(address.getHostName());//主机名 System.out.println(address.getCanonicalHostName());//主机别名 System.out.println(address.getHostAddress());//获取IP地址 System.out.println("==============="); //用域名创建 InetAddress对象 InetAddress address1 = InetAddress.getByName("www.wodexiangce.cn"); //获取的是该网站的ip地址，如果我们所有的请求都通过nginx的，所以这里获取到的其实是nginx服务器的IP地址 System.out.println(address1.getHostName());//www.wodexiangce.cn System.out.println(address1.getCanonicalHostName());//124.237.121.122 System.out.println(address1.getHostAddress());//124.237.121.122 System.out.println("==============="); //用IP地址创建InetAddress对象 InetAddress address2 = InetAddress.getByName("220.181.111.188"); System.out.println(address2.getHostName());//220.181.111.188 System.out.println(address2.getCanonicalHostName());//220.181.111.188 System.out.println(address2.getHostAddress());//220.181.111.188 System.out.println("==============="); //根据主机名返回其可能的所有InetAddress对象 InetAddress[] addresses = InetAddress.getAllByName("www.baidu.com"); for (InetAddress addr : addresses) { System.out.println(addr); //www.baidu.com/220.181.111.188 //www.baidu.com/220.181.112.244 } } catch (UnknownHostException e) { e.printStackTrace(); } } 可以知道此时获取到的服务器如果加了代理方式就是获取到代理的地址，一般会使用netty代理转发。
/** * 获取服务器IP地址 * @return */ @SuppressWarnings("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/804bf3fd2d9aec14cd6015b6f4c36486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518deb279a034193ea3388788cd35b02/" rel="bookmark">
			结构光三维重建Projector-Camera Calibration投影仪相机标定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构光三维重建-Projector-Camera Calibration投影仪相机标定 目录
结构光三维重建-Projector-Camera Calibration投影仪相机标定
1.结构光相机标定软件
2. 依赖环境
2.1 安装TIFF
2.2 安装OpenCV
(1) 源码编译
(2) 编译OpenCV常见错误
2.3 安装QT5
3. 编译标定源码：3D Scanning Software
（1）源码编译
（2）常见的错误和解决方法
4.懒人必备
5. 结构光三维重建-3D Scanning Software实现三维重建
1.结构光相机标定软件 结构光相机标定是一件十分复杂的过程，所幸布朗大学开源了一套投影仪摄像机标定系统(Projector-Camera Calibration/3D Scanning Software) 官方地址： Projector-Camera Calibration / 3D Scanning Software
官网提供了Window和Apple OSX编译好的标定软件，很不幸的是，版本比较老旧，仅支持Windows 7 x64，Opencv也是比较老旧的OpenCV 2.4.11,没有提供Linux版本的,你想在Ubuntu成功运行还是要采坑的。
下面手把手教你，如何在Ubuntu上，编译源码
当然，若你不想经历填坑的痛苦，可以直接下载本人已经修改好的源码，已经包括Opencv，TIFF，scan3d-capture-src-2015等源码，直接使用即可
下载地址：结构光三维重建Projector-Camera Calibration投影仪相机标定
关于如果实现三维重建，请查看下一篇博客《结构光三维重建-3D Scanning Software实现三维重建》：https://panjinquan.blog.csdn.net/article/details/121113787
2. 依赖环境 库本地使用版本说明UbuntuUbuntu18.04本机系统tifftiff-4.3.0 (tiff-4.0.x以上亦可)opencv编译需要TIFF OpenCV
opencv-4.3.0 (opencv-3.2.0.x以上亦可)3D Scanning Software需要用的OpenCV QtQt 5.5.1(Qt 5.0.x以上亦可)3D Scanning Software的UI是使用Qt布局的 2.1 安装TIFF 下载地址：Index of /libtiff/ ，tiff-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/518deb279a034193ea3388788cd35b02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83af93e05e3823c433ab8f4d8a6cb63a/" rel="bookmark">
			解决IDEA中maven依赖报红的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 在使用IDEA进行编程时，发现maven依赖中有很多报红现象，如下图所示：
虽然不太影响项目运行，但也确实是个问题
原因：造成这种现象主要原因就是由于网络原因导致没有将Maven的依赖下载完整，就出现很多以.lastUpdated结尾的文件
二、解决方法 删除maven仓库所有以.lastUpdate结尾的文件，并在idea中按如下操作重新下载，依赖就不会报红了
（1）切换到maven的本地仓库
（2）在当前目录打开cmd命令行
（3）执行命令：for /r %i in (*.lastUpdated) do del %i
（4）在idea中重新下载依赖，就不会报红了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b573f3f36ef1ce50f8fa1dd0c91e0cec/" rel="bookmark">
			SSH远程登录并执行命令测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSH 是 Linux 下进行远程连接的基本工具，但是如果仅仅用它来登录那可是太浪费啦！SSH 命令可是完成远程操作的神器啊，借助它我们可以把很多的远程操作自动化掉！下面就对 SSH 的远程操作功能进行一个小小的总结。
远程执行命令 如果我们要查看一下某台主机的磁盘使用情况，是不是必须要登录到目标主机上才能执行 df 命令呢？当然不是的，我们可以使用 ssh 命令在远程的主机上执行 df 命令，然后直接把结果显示出来。整个过程就像是在本地执行了一条命令一样：
$ ssh nick@xxx.xxx.xxx.xxx "df -h" 那么如何一次执行多条命令呢？其实也很简单，使用分号把不同的命令隔起来就 OK 了：
$ ssh nick@xxx.xxx.xxx.xxx "pwd; cat hello.txt" 第一条命令返回的结果： /home/nick
这说明用这种方式执行命令时的当前目录就是登陆用户的家目录。
第二条命令返回 hello.txt 文件的内容。
注意，当命令多于一个时最好用引号括起来，否则在有的系统中除了第一个命令，其它都是在本地执行的。
执行需要交互的命令 有时候我们需要远程执行一些有交互操作的命令。
$ ssh nick@xxx.xxx.xxx.xxx "sudo ls /root" $ ssh nick@xxx.xxx.xxx.xxx "top" 这两条命令虽然提示的失败原因不同，但它们有一个共同点：都需要与用户交互(需要 TTY)。所以它们失败的原因也是相同的：
默认情况下，当你执行不带命令的 ssh 连接时，会为你分配一个 TTY。因为此时你应该是想要运行一个 shell 会话。
但是当你通过 ssh 在远程主机上执行命令时，并不会为这个远程会话分配 TTY。此时 ssh 会立即退出远程主机，所以需要交互的命令也随之结束。
好在我们可以通过 -t 参数显式的告诉 ssh，我们需要一个 TTY 远程 shell 进行交互！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b573f3f36ef1ce50f8fa1dd0c91e0cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fdbc541ba7271fbfb2b187c5254d544/" rel="bookmark">
			关于数据库中的schema的注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于数据库中的schema schema：模式，在SQL Server中文版文档中翻译为架构。
在数据库学习过程中，有一个schema概念，如概念模式、物理模式、内部模式、外部模式、逻辑模式，以及DBMS的schema等，每一个都有其特定的含义，在不同语境下的含义不同，容易初学者迷糊。
DBMS的schema就是数据库对象的集合，这个集合包含了各种对象如：表、视图、存储过程、索引等。
☆ISO/IEC 9075-1 SQL标准中将schema定义为描述符的持久命名集合（a persistent, named collection of descriptors）。
☆MySQL的文档中指出，在物理上，模式与数据库是同义的，所以，模式和数据库是一回事。从概念上讲，模式是一组相互关联的数据库对象，如表，表列，列的数据类型，索引，外键等等。但是从物理层面上来说，模式与数据库是同义的。你可以在MySQL的SQL语法中用关键字SCHEMA替代DATABASE，例如使用CREATE SCHEMA来代替CREATE DATABASE。
参考： MySQL Glossary之schema ，链接是MySQL :: MySQL 5.7 Reference Manual :: MySQL Glossary
☆Oracle的文档却指出，某些对象可以存储在数据库中，但不能存储在schema中。 因此，模式和数据库不是一回事。Oracle的schema与数据库用户密切相关。schema是数据或模式对象的逻辑结构的集合，由数据库用户拥有，并且与该用户具有相同的名称，也就是说每个用户拥有一个独立的schema。参考 Oracle Database Objects之 Schema Objects，链接是Database Objects
☆SQL Server中schema是数据库SQL Server内部的一个独立的实体，包括表、字段、数据类型以及数据库的主键和外键的名称。参考：SQL Server Glossary之database schema ，链接是 Glossary | Microsoft Learn
要理解SQL Server的架构（SCHEMA）可以参考
权限层次结构（数据库引擎）权限层次结构（数据库引擎） - SQL Server | Microsoft Learn
安全对象范围：架构 安全对象 - SQL Server | Microsoft Learn
尽管上述三个DBMS在定义schema方面有所不同：
★MySQL
在MySQL中，CREATE SCHEMA创建了一个数据库，这是因为CREATE SCHEMA是CREATE DATABASE的同义词。 换句话说，你可以使用CREATE SCHEMA或者CREATE DATABASE来创建一个数据库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fdbc541ba7271fbfb2b187c5254d544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3bf0ed178aa3e9ba961c0c7c93f8761/" rel="bookmark">
			C#控制台输出注册登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：C#注册登录页面 要求能够存储多组账户，能够有试错上线
逻辑分析： 注册逻辑： 1.首先需要注册账户，先输入账户名，账户名不能重复，注册完；接下来写密码，并二次确认输入的密码；然后将账户和密码存入数据库中，以此多次使用。
登录逻辑： 2.注册完之后，既可以需要登录，登陆的时候呢，先判断是否存在已经注册完的用户名，然后进行输入密码操作，然后判断密码是否正确，同样需要输入上限，达到上线之后即重新注册。
代码： class Program { public static int count = 1; public static string[][] num = new string[100][]; public static int mistakenum = 1; public static bool istrue = false; static void Main(string[] args) { while (true) { login0(); //注册 landing0(); //登录 } } #region 1.注册页面 static void login0() { Console.WriteLine(" 注册账号 "); Console.WriteLine("设置账号名"); string name = Console.ReadLine(); if (count&gt;1) //需注意count==1的时候，数组里面没有保存内容，因此不能与储存的内容进行保存 { if (Registeredname(name)) //要充分利用bool变量，进行判断，学会使用 { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3bf0ed178aa3e9ba961c0c7c93f8761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b245487a5ffd3d52c6b662f6530bbf69/" rel="bookmark">
			51通过虚拟样本生成和注意神经网络进行自动和准确的癫痫波纹和快速波纹检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Automatic and Accurate Epilepsy Ripple and Fast Ripple Detection via Virtual Sample Generation and Attention Neural Networks
摘要--全世界约有1%的人口患有癫痫。癫痫手术的成功关键取决于术前对致痫区的定位。高频振荡包括波纹（80-250赫兹）和快速波纹（250-500赫兹），通常被用作生物标志物来定位致痫区。最近的文献表明，快速波纹比波纹更能显示致痫区。因此，从脑磁图的波纹信号中准确地检测出快速波纹对于改善癫痫手术的效果至关重要。本文提出了一种自动和准确的波纹和快速波纹检测方法，它采用了虚拟样本生成和具有注意机制的神经网络。我们在具有50个波纹和50个快速波纹的病人数据上评估了我们提出的检测器，这些波纹和快速波纹由两位专家标记。实验结果显示，我们的新检测器优于多种传统的机器学习模型。特别是，我们的方法在50次重复的随机子抽样验证中可以达到89.3%的平均准确率和0.88的平均接收操作特征曲线下面积。此外，我们通过实验证明了虚拟样本生成、注意力机制和神经网络模型架构的有效性。
非侵入性的检测方法被普遍用于致痫区的定位[5-8]。带有尖峰信号的脑磁图（MEG）是一种无创技术，用于癫痫手术前的术前检查[9]，它指导iEEG对致痫区进行定位[10]。不幸的是，只有80%的患者在MEG记录中显示出尖峰。此外，即使切除了产生尖峰的脑区，癫痫手术最终也无法减少大约50%的病例的发作频率[4, 11]。幸运的是，各种研究表明，致痫脑产生的高频脑信号被称为高频振荡（HFOs），包括波纹（80-250 Hz）和快速波纹（FRs，250-600 Hz）。癫痫手术的结果关键取决于精确和无创地定位波纹和FRs[9, 12]。有许多研究表明，病理HFO是识别致痫组织的生物标志物，可以改善癫痫患者的术前诊断和手术效果[13]。
Ⅰ Introduction 最近，越来越多的证据表明，在致痫区的定位方面，FR比波纹更有用[14]，在多发癫痫病灶的情况下尤其如此。在这方面，准确地检测和区分MEG信号中的波纹和FR对于改善手术效果至关重要。
在目前的临床实践中，外科医生对脑电图中的波纹和FR的视觉检查是常规的。然而，与传统的尖峰相比，涟漪和FRs太弱，不易察觉，特别是，由于FRs持续时间短，振幅低，而且MEG信号数据量大，视觉识别FRs费时费力，主观性强，容易出错[15]。
为了解决上述问题，人们开发了许多方法[16-18]来自动检测和精确识别MEG、EEG和iEEG信号中的波纹和FRs。这些 "老式 "的HFOs检测方法一般都有类似的框架或工作流程：（1）根据观察或统计分析手工生成特征，（2）记录的数据被分成大量的信号段，（3）HFOs检测器自动从这些信号段中提取特征，（4）通过与手工特征的比较对提取的特征进行阈值处理。Klink等人[19]介绍了MEG中的自动HFOs检测和可视化方法，而另一项工作[17]使用手工制作的特征（如高频峰和低频峰）在EEG信号中自动区分HFOs。19]和[17]都要求手工制作的特征在识别HFOs信号段时有一个截止点，导致在将这些检测器应用于不同人群的类似神经影像数据时，不可避免地重新调整手工制作的特征的截止点。这妨碍了对未见过的HFOs的概括性。
机器学习为外科医生提供了一个很有前途的方法来提高检测HFO的性能，同时减少人为干扰。传统的机器学习算法，如逻辑回归，已被用于识别致痫区[20]。我们提出了一个使用神经网络（NN）的SMO检测器来完成同样的任务，并改善了HFOs的分类性能[21]。这样的HFOs检测器需要最小的人为干扰来从地面真实数据集中学习潜在的HFOs模式。然而，NN检测方法仍然存在几个挑战。
一个挑战是训练数据不足。多层NN模型的训练步骤通常需要大量的数据来理解隐藏在高维数据中的复杂模式[22]。然而，由于患者数量有限，单个患者的波纹和FRs实例数量较少，很难收集大量的信号样本进行机器学习模型训练。
另一个挑战是信号分类的性能有限。虽然有脑电图和EEG信号分析工具提供HFOs检测[15, 23]，但在癫痫患者的术前操作中，准确分类波纹和FRs仍然是个问题，目前的HFOs检测性能不足以满足临床使用。虽然大多数研究集中在将HFOs信号从尖峰或正常生物信号中分离出来，但它们仍然限制了准确区分HFOs的亚类型（即波纹和FR）。目前还不清楚最先进的HFOs检测模型是否可以直接应用于MEG的涟漪和FRs检测分类。最近，注意力机制被引入深度学习，以提取更好的特征嵌入[24]。Vaswani等人[25]使用唯一的注意力机制为神经机器翻译任务构建了一个序列-序列模型，取得了最先进的质量得分。Shen等人[26]讨论了注意力机制，该机制允许更多的灵活性，并且在建立依赖关系的模型时更注重数据驱动。Zhu等人[27]开发了一个DAN，一个用于新闻推荐的深度注意力神经网络。最近，有人提出整合注意力机制，从视觉诱发的MEG脑信号中对分类的图像进行分类[28]。据我们所知，注意力机制还没有被应用于来自MEG的HFO（即涟漪和FR）检测。
本研究旨在缓解数据不足的问题，提高HFOs信号中FRs检测的性能。具体来说，我们开发了一个波纹和快速波纹（ARF）检测器来自动区分HFOs信号中的波纹。我们的贡献有三个方面。首先，我们引入了一个虚拟样本生成方法，以创建更多的生物医学脑电信号来增加脑电的地面真实数据集。这改善了小的地面真实数据集的训练性能。其次，我们采用注意力机制来创建注意力神经网络（AttNN）模型，以实现准确的FRs检测。此外，这项研究涉及到全新的病人数据，这些数据从未在任何出版物中使用过，而且可能在公共场合无法获得。
本文的其余部分组织如下。第二节描述了脑电图数据和ARF检测器。实验设置显示在第三节，然后是实验结果和讨论，分别在第四节和第五节，最后在第六节总结这项工作。
II. MATERIALS AND METHODS A. MEG波纹和FRs地面真实数据集 在这项回顾性研究中，研究方案由机构审查委员会（IRB）审查，并根据《赫尔辛基宣言》从每个病人那里获得了IRB正式批准的知情同意书。我们从20名癫痫患者（年龄：6-60岁，平均年龄32岁；10名女性和10名男性）那里获得了脑电图数据，其特点是部分癫痫发作产生于大脑的某一部位。作为手术前评估的一部分，剥夺睡眠和减少抗癫痫药物被用来提高在脑电图记录期间捕获HFO的机会。另外还采用了以下病人的纳入标准。(1)在脑电图记录期间，头部移动小于5毫米，(2)所有脑电图数据的偏移量在6 pT以内（脑电图数据被认为是 "干净的"）。这20名患者在结构图像上至少有一个可见的病变，进行了临床颅内记录，并进行了癫痫手术。脑电图记录由一个306通道的全头脑电图系统（VectorView, Elekta Neuromag, Helsinki, Finland）在磁屏蔽室（MSR）进行。在收集脑电图数据的过程中，采样率被设置为4,000赫兹，每个病人都记录了大约一个小时的脑电图数据。
为了确定脑电图系统的噪声，应用了基于实验前刚刚获得的没有病人（空房间）的数据的本底噪声，产生的噪声水平为3-5英尺/赫兹。为了定位癫痫活动（如尖峰、涟漪和FRs），空房间的测量结果也被用来计算噪声协方差矩阵。公共可用的脑电处理器被用于分析传感器层面的脑电数据[29]。
对于基础真实数据集，两位专家从脑电图数据中手动选择波纹和FRs信号段。总共有100个持续时间为1秒的信号片段（50个波纹和50个FRs样本）被组成地面实况数据集，用于模型评估。与涟漪相比，FRs是少数类别。为了提高模型中FRs的检测精度，我们选择了一个平衡数据集来训练我们的模型。
为了测试FRs对致痫区定位的检测性能，我们根据临床 "金标准"（侵入性记录和临床结果）进一步确认信号样本是否来自致痫区，这与这些患者的HFOs来源分析分别显示了一致的位置。如果一个信号样本来自致痫区，它就被标记为来自病灶区，否则就被标记为来自非病灶区。我们有50个FRs信号中的46个来自病灶区，而50个ripples信号中的7个来自病灶区。
B. ARF检测器概述 ARF检测器的概述在图1中描述。具体来说，该检测器包括信号分割、虚拟样本生成、AttNN和信号标签。ARF检测器包含训练和测试两个阶段。在训练阶段，给定具有一定持续时间（即1000毫秒）的脑电信号片段的黄金标准，使用虚拟样本生成方法来增加纹波和FRs信号的大小。一个AttNN被训练来区分波纹和FRs。在测试过程中，给定一组来自病人的脑电图数据，ARF检测器将数据分离成一系列信号段，用移动窗口进入相同长度的训练数据。然后，训练好的AttNN被用来对这些片段进行分类。分配的标签通常由MEG处理器等软件进行[29]。如上所述，仅仅给HFOs贴标签对数据分析是不够的，分离正常控制和HFOs信号是一个相对简单的任务。在下面的分析中，我们着重于使用ARF检测器进行波纹和FRs分类。
C. 信号分割 通过移动窗口技术[30]，多通道MEG信号被分割。为了达到所提出的检测器的模型学习目的，临床癫痫学家使用MEG studio软件（MEG中心，辛辛那提儿童医院医疗中心，Cincinnati, OH, US）根据侵入性记录和手术结果手动选择了一些涟漪和FRs信号段。
图2显示了脑电波波纹和FRs的例子。涟漪和FRs信号段在时域上都是由时间序列向量表示。在这项研究中，我们对处理过的脑电图信号采用了1,000毫秒的窗口大小，没有重叠，因为这个时间长度足以覆盖一个波纹或FR。每个信号段包含一系列的4000个信号时间点。因此，尽管不同受试者的脑电图记录长度不同，但ARF检测器的训练数据被规范化为长度为1,000毫秒的信号段。波纹信号段是用80-250赫兹的带通滤波器在波形中目测出来的，而FR则是用250-500赫兹的带通滤波器分析的[29]。以前的研究[31]表明，这些HFOs与80%以上的病人的慢速尖峰相吻合。当使用基于患者颅内录音的HFOs来源分析[32]时，HFOs被证实。我们比较了MEG的FR和颅内记录的FR在产生HFOs的源头水平[32]。
D. MEG信号的虚拟样本生成 如上所述，本研究涉及应用虚拟样本生成方法来增加NN模型的训练样本的大小。在这里，我们在脑电图数据上使用了一种基于自适应合成（ADASYN）的虚拟样本生成方法[33]。虽然ADASYN最初是为了对不平衡的数据集进行过度取样而提出的，但它也被应用于增加样本大小当机器学习模型的训练样本不足时[34]。ADASYN方法首先计算出少数和多数类别样本之间的不平衡程度。如果该程度的不平衡性小于预设的最大可容忍不平衡性的阈值，它估计将从少数类别中产生的虚拟样本的数量。对于少数群体中的每个样本，该方法根据欧氏距离找到k-最近的邻居（KNN），并计算出给定的少数群体样本的密度分布。最终，根据估计的样本量和密度分布，为每个少数族裔样本生成虚拟样本。
由于ADASYN是针对遗传不平衡数据问题提出的，所以KNN方法中的欧氏距离适用于一般情况。然而，事实证明，欧氏距离并不是一个理想的信号之间的相似度测量。所以，基于ADASYN生成的虚拟样本对于反映波纹和FRs样本的分布可能是次优的。在这项工作中，我们通过引入自适应签名相关指数（ASCI）作为虚拟样本生成过程中的相似性度量来修改ADASYN[35]。ASCI是一个从-1到1的归一化相似性指数，它考虑了信号段之间的振幅差异。因此，我们将ASCI应用到虚拟样本生成中，以找到脑电信号段之间具有高形态相似性的邻居样本。假设ASCI(sa, sb)表示两个MEG信号段之间的ASCI，其中sa和sb是两个MEG信号段的Z-score变换。在两个样本信号之间进行三分法。假设R是信号振幅空间。R分为上部空间Ru、中部空间Rm和下部空间Rl。U=u(i)和L=l(i)是预先定义的在时间瞬间i的截断向量，例如，u(i)=0.25，l(i)=-0.25。然后，我们定义三个子空间为：上层子空间Ru={V&gt;U}，中间子空间Rm={L≤V≤U}，下层子空间Rl={V&lt;L}。信号sa = {sa(i), 1 ≤ i ≤ N}的三分化Ta = {ta(i)}的计算方法是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b245487a5ffd3d52c6b662f6530bbf69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48b6f902997ab0fd311e8948c6855915/" rel="bookmark">
			分享一个C&#43;&#43;表白代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小编来分享一个C++表白代码，废话不多说，直接上源码
#include&lt;iostream&gt; #include&lt;conio.h&gt; #include&lt;windows.h&gt; #include&lt;time.h&gt; #include&lt;stdio.h&gt; #include &lt;math.h&gt; #include &lt;tchar.h&gt; using namespace std; #define stoptimeshort 100 #define stoptimelong 400 #define PI 3.1415926 #define wide 49 #define gao 24 #define high 6 void Color (int a) { if (a == 0 || a == 14 || a == 20) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); } else if (a == 1 || a == 12) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE); } else if (a == 2) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_GREEN); } else if (a == 3) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_BLUE); } else if (a == 4 || a == 11) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED); } else if (a == 5 || a == 13) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED|FOREGROUND_GREEN); } else if (a == 7) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_GREEN|FOREGROUND_BLUE); } else if (a == 15) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY); } else if (a == 16) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_GREEN); } else if (a == 17) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_RED); } else if (a == 8) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE); } else if (a == 6) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_BLUE); } else if (a == 9) { SetConsoleTextAttribute (GetStdHandle (STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY|FOREGROUND_RED|BACKGROUND_RED|BACKGROUND_GREEN); } } /*jumping heart*/ float f(float x, float y, float z) { float a = x * x + 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48b6f902997ab0fd311e8948c6855915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae2df47e81e41b93a702f5c44d24b0e/" rel="bookmark">
			项目突然打开爆红的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先检查java文件夹是否蓝色，没有的话记得标记一下
进项目文件夹删除项目的iml和idea文件，这两文件保存了项目的包储存位置，项目版本控制信息，历史记录等配置信息打开maven，重新导入一下项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb2ba0dad9998f2ab45374de0745fd56/" rel="bookmark">
			phoenix整合hbase及相关简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装教程二、表映射三、语法 一、安装教程 下载解压：https://dlcdn.apache.org/phoenix/phoenix-5.1.2/
进入目录：cd /home/hadoop/phoenix/
解压：tar -xvf phoenix-hbase-2.1-5.1.2-bin.tar.gz
复制
cp /home/hadoop/phoenix/phoenix-hbase-2.1-5.1.2-bin/phoenix-server-hbase-2.1-5.1.2.jar /home/hadoop/hbase/hbase-2.1.0/lib 拷贝hadoop配置文件目录下的core-site.xml和hdfs-site.xml到phoenix的bin目录下
cp /home/hadoop/module/hadoop-3.2.2/etc/hadoop/core-site.xml /home/hadoop/phoenix/phoenix-hbase-2.1-5.1.2-bin/bin cp /home/hadoop/module/hadoop-3.2.2/etc/hadoop/hdfs-site.xml /home/hadoop/phoenix/phoenix-hbase-2.1-5.1.2-bin/bin 拷贝hbase的conf目录下的hbase-site.xml到phoenix的bin目录下
cp /home/hadoop/hbase/hbase-2.1.0/conf/hbase-site.xml /home/hadoop/phoenix/phoenix-hbase-2.1-5.1.2-bin/bin 设置环境变量：vi /etc/profile
#phoenix export PHOENIX_HOME=/home/hadoop/phoenix/phoenix-hbase-2.1-5.1.2-bin/ export PHOENIX_CLASSPATH=$PHOENIX_HOME export PATH=$PATH:$PHOENIX_HOME/bin 刷新：source /etc/profile（hadoop用户也要）
每个节点hbase配置：vi /home/hadoop/hbase/hbase-2.1.0/conf/hbase-site.xml
&lt;!-- Phoenix 支持HBase 命名空间映射 --&gt; &lt;property&gt; &lt;name&gt;phoenix.schema.isNamespaceMappingEnabled&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;phoenix.schema.mapSystemTablesToNamespace&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; 启动hbase：/home/hadoop/hbase-2.1.0/bin/start-hbase.sh
phoenix启动脚本添加
-Djava.security.auth.login.config=/home/hadoop/zookeeper/apache-zookeeper-3.6.3-bin/conf/jaas.conf -Djava.security.krb5.conf=/etc/krb5.conf 启动
cd /home/hadoop/phoenix/phoenix-hbase-2.1-5.1.2-bin/bin ./sqlline.py node10,node11,node12:2181 ./sqlline.py hdp155,hdp156,hdp157:2181 二、表映射 建default空间表
//建表 create 'tb1', 'info' //插入数据 put 'tb1', '1', 'info:name', 'zhan' put 'tb1', '2', 'info:age', '30' //查数据 scan 'tb1' 建立视图映射&amp;查看(default空间 )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb2ba0dad9998f2ab45374de0745fd56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5af806be5723b71b0db1f7f306c1ff8/" rel="bookmark">
			Windows下使用pip安装包 出错 TLS/SSL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows下使用pip安装包的时候出现如下问题： “WARNING: pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available”
解决办法：
在环境变量Path中加入anaconda3的如下路径：
D:\appdata\anaconda3\condabin
D:\appdata\anaconda3\Scripts
D:\appdata\anaconda3\Library\bin
D:\appdata\anaconda3\
注意两点：
[1] 需要将anaconda3的路径换成你电脑上的路径，这里是我的电脑上anaconda的安装路径;
[2] 这里应该只适用于Anaconda的环境，其他可能不适用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5917694e31b3ecde0d4a5685b471de1c/" rel="bookmark">
			【Java】全面解析异常（异常的分类、处理、抛出和捕获等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是异常异常的分类异常的抛出（throw关键字）异常的捕获throws关键字try、catch关键字 finally关键字自定义异常总结 什么是异常 “程序运行时，发生的不被期望的事件，它阻止了程序按照程序员的预期正常执行，这就是异常。”
我们在平时写代码的过程中就可能会遇到异常，给大家给举一些容易遇到常见的异常例子：
1.算术异常
Exception in thread “main” java.lang.ArithmeticException: / by zero
在JAVA中，我们都知道0不能作为除数，只能作为被除数，如果把0作为除数，编译器就会提示我们出先算术异常了。
2.数组越界异常
Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 5
数组越界，我们应该也不陌生，在使用数组时，如果超过了数组的大小，就会形成越界。程序就会发生异常，从而终止运行。
3.空指针异常
Exception in thread “main” java.lang.NullPointerException
对于数组arr，让它赋值为null,我并没有让它指向任何对象，它就是一个空指针。对于空指针进行访问，编译器就会提示我们空指针异常。
异常的分类 在代码运行时，可能会出现异常种类有很多，为了对不同异常或者错误进行很好的分类管理，Java内部维护了一个异常的体系结构：
图画的不是很好，大家凑合着看吧。下面为大家讲解一下这张图：
1.Throwable类是Java语言中所有错误(errors)和异常(exceptions)的父类。
2.Error：指的是Java虚拟机无法解决的严重问题，比如：JVM的内部错误、资源耗尽等。
3. Exception：异常产生后程序员可以通过代码进行处理，使程序继续执行。
异常可能在编译时发生，也可能在程序运行时发生，根据发生的时机不同，可以将异常分为运行时异常和编译时异常。
编译时异常
编译时异常，也称为受检查异常。从名字我们就能够理解，就是程序在编译的时候发生的异常。
运行时异常
在程序执行期间发生的异常，称为运行时异常，也称为非受检查异常。
编译时出现的语法性错误，不能称之为异常。编译过程中就会出错, 这是 “编译期” 出错。而运行时指的是程序已经编译通过得到class 文件了,再由 JVM 执行过程中出现的错误.
在Java中，异常处理主要的5个关键字：throw、try、catch、finally、throws
在讲异常处理之前，我们先要了解一下异常处理中的关键字，接下来我会一一为大家介绍这些关键字。
异常的抛出（throw关键字） 在Java中，可以借助throw关键字，抛出一个指定的异常对象，将错误信息告知给调用者
使用方法：throw new XXXException(“异常产生的原因”);
例如：
public static void main(String[] args) { throw new RuntimeException(); } 虽然代码没错，但是我是使用throw抛出的一个异常，所以程序就会反馈给我一个异常。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5917694e31b3ecde0d4a5685b471de1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c3a1597e7c0c6ee16f8df1746877b5b/" rel="bookmark">
			rrweb实现录像功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rrweb实现录像功能 安装ffmpeg 如何安装ffmpeg（windows） 进入官网页面：https://ffmpeg.org/download.html 找到git下面的第一个链接进行下载 下载完毕，解压到需要的路径，并复制bin路径。如：[C://ffmpeg/bin](file:///C://ffmpeg/bin)，这是程序所在的路径。可以从cmd里面粘取路径（一定得是自己解压以后的路径） 我的电脑 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; Path -&gt; 新建 -&gt; 输入咱们的FFmpeg路径 -&gt; 一路确定再依次关闭 测试一下是否配置成功：cmd窗口输入ffmpeg命令，如有信息则说明成功 具体不知道看这个文章：https://www.jianshu.com/p/9b5a5085e781 安装rrvideo npm i -g rrvideo 以安装 rrvideo CLI 我们使用rrweb录屏后是将数据传送给服务端，然后在服务端生成一个json文件，下载这个json文件，运行如下命令： rrvideo --input PATH_TO_YOUR_RRWEB_EVENTS_FILE --output OUTPUT_PATH PATH_TO_YOUR_RRWEB_EVENTS_FILE: 是要转码的json文件的路径 OUTPUT_PATH：是转码后生成mp4文件的路径 注意：OUTPUT_PATH路径后要加 \xxx.mp4 才能生成mp4格式的视频 例子代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;rrweb demo web site&lt;/title&gt; &lt;script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/rrweb@latest/dist/rrweb.min.js"&gt;&lt;/script&gt; &lt;script crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/rrweb@latest/dist/record/rrweb-record.min.js"&gt;&lt;/script&gt; &lt;link rel="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c3a1597e7c0c6ee16f8df1746877b5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea01f38f452131cbe9a14859dc3d374/" rel="bookmark">
			工作快满5年，聊聊这5年作为程序员中的那些事（文末加了结局揭晓和3年后近况的彩蛋！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 毕业将近5年了，一般来说，工作5年是一个槛，今天就聊聊俺这5年所作为程序员，所经历的一些事，分享给大家，希望有一定借鉴作用吧。
毕业的彷徨 俺老家是江西的，在大学混了3年多，基本上都是玩过来的，在大四的时候，对于未来的道路，是很迷茫的，不知道自己要干啥，因为自己学的是信管专业，班上一半人想从事金融和管理方面的工作，还有一部分就是从事IT，一部分准备考研，我当时算是剩下的那部分没有方向，很迷茫的那波人，然后家里也催着让我报考公务员，说工作稳定之类的，而且会计证考了2年都没考到，甚至英语4级证书都是年年考，年年挂，所幸大四的时候因为恋爱，和现在的老婆在一起了，所以动力满满地，还是勉强考过了，而且考到了一个数据库工程师证书。当时心里也知道，金融和考研我是不太可能的了，然后管理也觉得自己不太靠谱，也就剩下从事IT了，老实说，大学也学了C语言、汇编、C++、JAVA等，当编写的代码能运行成功的时候，心里还是有一点点成就感的。可能是因为这个原因，后来就选择成为了一名苦逼程序员了。
未来的道路 时间回到2011年，当时有很多企业和培训机构来学校演讲并招生，俺就不出意外的被鼓动，报了大型机培训，当时做大型机被吹比的很有钱途的，结果显而易见，2011年底，被一家二线城市的对日外包公司招进去实习了，当时招聘官口头说有做大型机的项目云云，被忽悠进去后，才发现，大型机业务一年前就做完了，只能进去做其他的了，俺就从抱着从事大型机的想法，一下子就被偏移到做对日外包了，大家都知道，做外包“很坑”的，就这样，未来的道路就从做对日外包开始了。
我所经历的外包（一） 记得11年年底刚进去实习的时候，实习工资是1.5K，加上其他餐补福利也就2K不到，刚好满足最基础的租房和温饱，记得进去最大的挑战就是学习日语了，俺对语言的学习可以说是深痛恶绝，但为了工作，木得办法，当然在技术上的挑战也是蛮大的，刚进去的1个月，只是进行各种培训，一个月后分项目组时，由于MTI（这里简称）项目人员缺口比较大，部门的3个实习生都被分进去了。
这个项目虽然是对日外包的项目，但已经经过开发和上线了，这次项目主要是在之前的基础上扩充功能，但接触后就傻眼了，代码基本看不懂，看不懂的意思是，一个功能拆分的类和引用关系过多，都懂得，运用个各种设计模式，这里说下，项目的框架是对日外包常用的T2框架，现在看来和Spring在功能上差不多，有那么点IOC和AOP的意思吧，但用起来比Spring更加的麻烦，只能多问问师兄，以及自己多多恶补各种知识了，就这样慢慢的度过了半年的实习期，等毕业后再过去，发现自己已经不在MTI项目组了。
这时，中心项目的人员缺口基本饱和了。而俺实习期间过了日语4级，后面被安排培训日语3级，技术上也被安排培训Android，就这样又过了小半年，期间司内日语3级考了2次，但都没过，俺也没心思再去考了，Android也培训完成，并和一同学习的同事，参与做了几个小的练手项目，这时，Smart项目组宣布近期不缺Android的人了，只是引进了几个培训IOS的，木滴办法，部门经理又把俺调到了MTI项目组。这期间，在公司里人事的几个小伙伴中，有1个在其他事业部，做的挺好，他们经理准备外派他到日本，而在日语培训期间认识的小伙伴，培训IOS顺利进入Smart项目组后，也准备外派到日本了，谁让他们都过了日语3级呢，哎，只有俺，貌似还在原地踏步...
我所经历的外包（二） 这时候到了12年年底了，前前后后经历了最初的入司实习，培训，进项目组，回校做毕设，毕业，再入职培训，最后还是在MTI项目组稳定下来了，到了现在这个阶段才算是真正的进入了MTI项目组，之前做的都是边边角角，而且大多是整理边缘部分的文档，此后大约在MTI项目做了1年半多一点，这1年半才算是真正的学会了如何作为一名程序员，后来才发觉，原来进入MTI项目组是很难得的，从里面学到了N多东西，一般我司的对日外包项目大都是3-6个月就结束的，但这个项目比较特殊，属于长期合作的形式，且2015年开始，客户那边的概要设计，也由MTI项目组承担了，从设计到开发，再到测试，都是我们这波人全程参与，记得是在15年的时候，由于逻辑分支太多，风险较大，客户提出要我们建立一套自动化测试体系，当时组里几位大牛就在做技术选型和搭框架，最终花了大半年，用selenium进行自动化测试体系的构建了，所有正常分支全覆盖，而单元测试体系是一直有的，覆盖率接近100%，从中真的学到了蛮多，还有后来的Shell脚本批处理也是很费神，并不是说难，而是太多了，我记得离开的时候有近百个Shell吧，就这样，俺在MIT项目组呆了近1年半，从中学到的我总结下：
1、形成了良好的编码规范和风格
由于是要求比较高的对日外包项目，对于编码规范的要求简直BT，例如：它不允许存在TAB键，且空的一行不准有空格存在。而且项目中运用到了很多设计模式，设计的也比较复杂，包括一些回调的写法等。所以编码风格也是在那个时候形成的。
2、对于JAVA项目的开发有了初步的认识
3、了解了自己确实对语言的学习木得天赋
无论怎么考，日语3级就是没过，我也放弃了，这也是让我萌生了离职的最初一个理由
4、工作中有了责任心和耐心
这点我认为是最重要的，在MTI项目中，加班还是挺多的，经过了近2年的历练后，自己对工作的责任心，在那个时候培养出来了。最后还有耐心，自我进入MTI长达一年多的时间里，整理文档的活从来没离开过我，而且文档都是日语写的，我只能吭哧吭哧的慢慢整理，对于做事的耐心也是那个时候养成的，那个时候就觉得，只要工作中我认为能做到的，只要我话时间和精力，基本都能做好。这对我以后在第二家公司工作中，发挥了巨大的作用。
第一次跳槽经历 这是在2014年3月，此时萌生了离职的想法，除了日语感觉坑爹外，还是觉得长期做外包没啥前途，而且那时候，听小道消息说，日元贬值，有可能缩减对日项目了，所以还是希望找一家做自己产品的公司。就这样，开始了大家都熟悉的投简历，找工作之旅。
期间发现了一些不错的招聘网站，主要是猎聘网，感觉比智联招聘和无忧网做的都要好，所以俺也主要到那里投简历了，结果4月的时候，收到了2个面试通知，在3月底的时候，就去进行面试了，首先面的是A公司，它还是在这个二线城市，是一家做大中型电商的互联网公司，依托于线下庞大实体店的集团背景，比较有潜力的一家，当时发生了一个小插曲，人事当时只通知了面试时间，而面试地方是发送短信的，结果可能刚换了手机，导致没收到，也没对方的手机号（打来是座机，且我打过去一直是业务繁忙），没办法，约定的时间，直接百度地图，转地铁，坐公交来到A公司大门，然后看到2栋庞大且具有现代风格的大楼，有东南西北4个门，一群保安在站岗，这逼格，当时心里就想，俺一定要进这公司，但木有短信的我只能在大门口等着了，那个时候已经过了面试时间，后来和一位年轻的保安说明了我的事和难处，他没为难了，带我进了人事大楼，找了个人事姐姐帮我查了下招聘信息，最后得以顺利面试，不出意外，我把我这2年所做的事，以及学到的东西说了，结果被录了。另外一家由于要经常出差，而且我面的也不太好，薪资谈的不高，就没去了。
当时觉得面试还是挺简单的，就是把自己做的东西说清楚就行，但实际上，据后来了解，这个部门当时缺人真心缺疯了，一个开发部门除了部门经理，就2个开发，然后有4个外包过来的顾问，而且项目的概设已经做完，接着就是做详设和开发了，这个时候，除了一个顾问是负责搭建基础框架和基础部件的，其他都是架构设计和项目管理的，严重缺乏开发，所以后面了解到，基本只要是做过实际JAVA项目的，都能进，就这样，俺又一次糊里糊涂的进“坑”了。
进了大“坑” 2014年5月，进入了我毕业后的第二家公司，薪资涨了50%，整体定位是一家大型互联网电商公司，是的，我进去主要是做电商，虽然电商发展的不如淘宝京东，但业务复杂程度却有过之而无不及。
刚进部门的时候，除开外包顾问，一共有6个开发了，除了一个13年刚毕业的，其他都至少3年的工作经验了，我在里面算是最年轻的，只有2年不到，怀着忐忑的心情，大家一起做了电商里一个模块化单元系统的开发。做了大概1个月吧，心里对这个系统有了初步的认识，技术上没之前MTI项目那个复杂和规范，但是业务上，真心是复杂到了极点，不只是有自营平台类，还有线上线下体系，包括系统自身的定位，是作为O2O里面的核心链路，可以说从前到后的整个链路流程，大部分的业务逻辑都在我们这个系统里的，然后大部分开发都是刚入职的，编码规范和风格大都不同，所幸我还坚持着上家公司养成的“对日外包式”的规范和风格，在编码结构上更加清晰，所以在代码评审的时候，显出亮点了，并在调测阶段，因为BUG率较低，开发效率高，解决问题速度快等这些原因，因此在系统联测阶段，当上了部门分的3个组中其中一个组的组长，就这样在近2年半的时光里，作为一个开发小组的组长，迭代完成了近60多个大大小小的版本，期间做了几次大的架构优化和性能优化，比如远程调用框架的变更优化，服务器扩容，数据迁移，还有大促节点前通宵压测，进行系统优化等等，整体来说是忙的时候特别忙，空闲的时候，特别闲，也经过这2年多的工作上的积累，自认为对电商架构和业务流程了解的还是比较清晰的，但是在技术上的积累，却似有若无，很多项目中用到的框架和中间件知其然而不知其所以然，对于技术领域来说，总结和沉淀的不够。
但在那个时候，只是觉得，只要能高效的完成日常工作，解决问题，我就认为足够了，可能是第一份的经历，使得我在工作中是一个不太喜欢依赖别人的人，就算不懂的，也尽量自己去寻找答案并解决问题，除非是过长时间还搞不定的，就这样，在最近的这1年内，基本上工作上的事都是别人问我问题，而我已经极少问别人本职工作的问题了。渐渐的，我发现目前的工作并没有多少挑战性了，相同的开发设计套路和类似于机械式的任务完成，使得日常版本的更新变得越来越枯燥，再加上项目内以及公司大环境的一些原因，还有生活压力以及买房的压力，使得我又萌生换工作的想法，时间是2016年的8月炎夏，看着窗外，我想着，这次该去哪呢？
“未来九星” 这章打算多说说部门的人事变动的事，因为发现上章遗漏了不少必要内容，作为一个补充吧。这边有几个小伙伴要提到下。
第一个，叫小棍子，13年毕业，在部门经理的呵护下茁壮成长着。
第二个是在14年5月，俺刚进项目时，有个童鞋与俺一起进的，后来成了一起玩的小伙伴，叫老高，他智商没得说，全国重点大学毕业，只是专业选了比较蛋疼的生物，毕业前就参加了软件培训，这才走向了程序员之路，他11年毕业，比俺早一年。
第三位，在系统开发了大半的时候，部门经理又招来了2位，其中一位简称阿飞，他也是11年毕业的，专职做JAVA开发，进入后，由于剩余的开发内容只剩后台还没人做，就把我和他分到一起做后台管理的模块了。而另外一位同事，记得系统上线后，就被调去了中心的其他部门做支援，之后就没回来过了，直到离开...
第四位，是在系统刚上线的时候，部门来了一位应届毕业生，简称小水子，我认为是最像我们部门经理的男人，嘿嘿。
第五位，是系统开发接近完成的时候，过来了，从国企跳过来的，据说只是来体检生活的。感情史据说比较丰富，简称情圣。
第六位，是15年，系统上线快1年后才过来的，在技术上是我们部门里的NO.1，技术达人一个，简称“专家”。
第七位是部门里最稳的人，是14年4月份过来的，比俺大三年，做啥事都很稳，但效率方面可能缺了点哈，就叫老稳吧，部门分组后，担任了后台组的组长。
第八位是叫老岳，这人聪明，有想法，做事说话都麻利的一腿，和老稳一块入司的，也担任了组长，而且后期顾问走了之后，担任了项目主管的角色。 最后一位，就是俺老大，部门经理了，我们都叫他关老大，是个真正的技术大牛，全国重点大学硕士科班毕业，已经工作6年，当时由于系统是做后端接口的，没有页面，不好测试，他自己刷刷刷几下，就写出了我们中心还沿用至今的TRT系统，支持中心所有系统的DEV测试。
以上九位并非是部门所有成员，仅列举出了比俺早离开团队的成员，目前个个都是前途远大，未来NB的高富帅，简称未来九星。哈哈。
九星“出世”（一） 这几章打算详细说说他们跳槽的经历，也为俺日后的跳槽提供了比较'深刻意义"的指导和作用。
首先离开我们的是关老大，在14年年底，项目刚上线后，他就离职了，后面在送别饭上，才知道他是要移民去国外，据说是为了家庭，为了小孩的教育等原因走的，算是目前为止，在我们部门待过的人中最NB的，无论是技术还是工作中的其他方面。
再说说毕业后就一直跟着关老大的小棍子，他是第二个走的，记得是在15年上半年，他是13年毕业的，在关老大的耳濡目染下，他一直坚持这不断地学习，在工作中，他尽量快速高效的完成日常工作（基本上是花在公司一半的时间），其他的时间就不断的研究源码，所以我们经常吐槽他的代码规范问题。离开之前，他把整套Spring框架和JDK源码都研究了一遍，是个非常刻苦的孩子。走的原因是因为薪资太低了，即使涨一倍，也超不过1W，然后下家找的也很不错，大家日常生活中应该都用过他们的产品，重点是薪资，由于小棍子毕业后就被招进来了，一个二线城市应届毕业生的薪资大家应该都清楚的，而且公司加薪是上半年的，第一年因未满一年就没加，所以在第二年加薪之前，他就果断离职了，离开了这座城市，去了魔都打拼，由于他的日常积累，特别是源码的研究上，所以面试时，薪资谈的很高，涨到了之前的3倍以上，所以果断地去了。我们那时都一致认为，他的未来一定是前途远大的。
时间回到15年的年前，快过年了，这时阿飞已经和他女朋友买好了去他女友家的机票，时间是放假前的第3天，阿飞向部门新来的经理请假，说明原因，而新来的部门老大是刚转正不久的，这方面比较严肃吧，也不太清楚中心总监的风格，就“傻乎乎”的向总监说了此事，结局是被喷了，中心明面上过年是不准多请假的，最多2天，部门老大只能把结果告诉阿飞，阿飞还想争取下，让同事帮忙带刷卡的，但部门老大建议他不要这样（之后的2年很多部门都是这样操作的，包括我们部门），结果就是2张飞机票浪费了。他就是这时候起，利用一切的闲余时间，开始狂看技术方面的东西了。就这样，半年多过去了，中间经历了部门最大挑战的一段时间，不仅要完成线上线下的进一步融合，还有战略级项目，与其他合作伙伴进行电商业务的对接，从有到无开发完成一个新的系统，在其中的一周，不少人都是连续通宵开发的，白天产品进行需求确立和不断的需求变更，晚上11点后，我们就基于需求和需求变更进行开发，开发完成的时候，基本都天亮了，大伙基本上都是住公司的，白天睡，晚上开发，特别是老高，貌似一周没回过家了，就这样，一天一个版本，差不多大半个月，系统从无到有到上线，到大促检验，一步步的挺过来了，之后的9月，10月，大家都闲下来了。阿飞也是那个时候走的，他去了BAT中的一家，而且，那时候他女友也成功进入同一家BAT公司了，临走时，大家都祝福他俩，他们一定会很幸福的。就这样，又一位战友离开了部门，离开了公司，也离开了这座城市。
九星“出世”（二） 接下来走的，是老稳了，他是其中一位组长，做事仔细认真，缓而不急，也是在15年走的，据他说是因为在这边，他感觉逐渐地学不到东西了才走了，由于他在这座城市定居了，去的下家也是同城的，就在他家附近，薪资貌似涨的不多，但16年的时候，他的下家搬到了魔都，然后他也随公司过去，薪资翻翻了，目前月薪是除关老大外，我们这些人中最多的了。听他的意思是，先到那赚一笔，等小孩读书了，再回来云云...他走之后，情圣就接替了老稳的位置，成为组长。
时间转眼就到16年年后，这时快到加薪的时候了，这次加薪前前后后，由于部门加薪池过少，分配不均等原因，这期间走了不少人了。
这期间第一个走的是老高，在老岳成了项目主管时，老高接替了他组长的位置，其实他年前就提出过离职的，新的部门经理为了挽留他，特意把部门评优名额给了他，因此把俺年度评优滴名额给占了...555，再说说15年的加薪，由于俺还是以上家公司的标准去谈加薪的，结果加的不多，只有部门平均水准。不过俺还是挺有耐力滴，坚挺到现在还木有走，哈哈。其实他可能也不是很想走的，但不知为啥，可能是因为他负责的业务模块的原因吧，刚好有几次因为我们部门对电商的某些板块更有经验，且其他部门缺人，就把老高调去支援了几次，他就很不爽了，是个急性子，就果断去找工作，找到下家后就提离职了，虽然部门经理有做挽留，但还是拿完年终不久，就走了，因为下家还是这个城市，所以薪资加的不是很多，大概加了一半吧。
接下来就简略的说下16年部门加薪的事吧，可以说是因为这个事，导致部门初始成员，走了不少，也是在那个时候，新增了不少的新鲜血液。这事的关键又说到俺了，俺当时工作4年，在这个城市无车无房，又成家有小孩了，可以说生活压力还是很大的，且上一年度的加薪中，俺是被压了薪资的，且年终评优也木得份，而在项目的这一年多，可以说俺是项目的支柱吧，碰到啥疑难问题，各种复杂业务的对接，问题定位等等，可以说作为一个开发来说，那段时间，俺是把全部的时间都投入到这个系统的工作上了，当时的结果是，产品部和测试部都抢着要对接俺的需求功能模块，因为这就意味着他们都能很轻松滴完成，部门经理也明白，当时如果少了俺，可以说是后面会很难工作了，当时俺也是狠心，直接把加薪幅度提到了60%多，结果最后加了50%，这样俺就从部门的加薪池中，占据了很大的一部分了，导致的结局就是：
1、情圣离职，当他知道他的加薪结果后就离职了，让我们想不到的是，这厮其实元旦左右就找好工作了，而且是BAT中的一家，也许是他很擅长忽悠，对方的HR小妹妹就被他硬生生的拖了近3个月才入职的。进去的时候薪资应该是翻倍了。
2、第二个走的是专家，在最近半年他被调去大数据部门做大数据了，且成为了那边的核心骨干，但由于他所属部门还是我们这，导致加薪时，薪酬分配还是用的我们部门的（这次大数据部门是中心所有部门加薪最多的），相比于他当时的薪资，增幅可能就是6%吧，恰好那一年他换了套更大的学区房，巨额的房贷也更进一步地促使他离开，虽然还是在这个城市，但他薪资按年来算的话，也涨了接近一倍吧，不愧是专家。
3、这次加薪期间，最后一个走的是小水，从14年入职以来，他的进步速度有目共睹，很快地上手业务和项目工作，在系统的优化和设计上，特别是整体压测和优化上，出力不少，并且在此期间，把关老大写的TRT系统进行了架构上的优化，而且换了更好的容器去部署。但因为部门加薪池分配以及作为应届毕业生第一年没加薪的原因，他也成为了“牺牲品”之一，结果就果断离开这座城市了，去了一线城市打拼，薪资至少翻了一倍（由于他入司的薪资比之前的小棍子多了不少，接近小棍子的1.7倍吧，所以只多了一倍的薪资）。
九星“出世”（三） 最后一个走的，就剩下老岳了，据他说是因为个人发展原因走的，他是在这一年的下半年走的，也是进入了BAT之中的一家，但工作内容和目前做的还是有点不同的，可以说是有点小转行了吧，所以虽然进入了BAT，但涨薪不到double。
在老岳走的前2个月，据了解，小棍子又跳了，是跳去了BAT中的一家，这次他又进一步地把其他主流中间件的源码也研究了一遍，除了小水，他的工作经验算是最低的了，但薪资开的依然很高，不比其他去BAT的低，算是潜力无限，未来光明了。
最后就说下俺了，俺是在老岳快走的时候，下定决心要离开这座城市的，俺从实习到现在，在这座城市呆了5年了，自从它房价的一涨再涨，俺已经看不到买房的希望了，加上俺小孩再过几年就要读书了，俺必须要买房啊，所以俺想通了，不能一心扑在工作上，要多学学小棍子，在工作中，尽量多抽出点时间，规划自己的未来，准备自己的未来。就这样俺踏上了和前面兄弟一样的求职之路了。记得刚决定离开的时候，俺就毫无准备的裸面了一家，之后的结果备受打击，由于俺平时在工作之余，没有过多地对工作进行思考和沉淀，俺除了能结结巴巴地描述自己做过的事之外，其他技术问题，有很多答不上来，基本上都是俺用过的，也知道怎么用，但问到原理的时候，俺就不会了。这个阶段持续了近4个月，俺是屡战屡败，每次面完都思考和总结着自己各方面需要提高的地方，渐渐地，俺通过这种边面边准备，边学习的方式，把俺这近5年来工作中的事，都一一沉淀，一一总结，把实践更深层次的转化为理论，把理论总结和提炼，可以说，这4个月之中，俺的实践工作能力没多大提高，但理论知识，特别是给面试官展现的能力，是有个飞跃式的提高吧，在准备和学习的过程中，俺就结合了之前“未来九星”们的经历和经验，运用到自己身上，才能有此飞跃，当我感觉差不多的时候，俺联系了之前进入BAT的兄弟们，直接内推了。准备工作已经完成，接下来就是俺真正滴求职之路了。
求职之路 记得是去年年底，经过了长达4个月的充分准备，俺正式进入了BAT面试的环节，不出意外地，俺过了前2轮的技术面，听之前小伙伴说，只要项目背景匹配度较高，而通过前两轮的话，后面就很简单了，俺在那个时候也就有点放松了，中间发生过意外，在第三轮面试电话打来的时候，俺恰好木有接到，就这样等了几天，又是去开会的半小时的功夫，面试电话打来了，俺手机比较老旧，要一直充电，就放在位置上木有接到，之后就有点慌了，那是一个周末，距离前一轮面试已经一周多了，结果还木得面试打来，俺就联系之前一轮的面试官（幸好俺之前加了他的微信，嘿嘿），他说已经催了，后面会打来的，叫我放心，意想不到的是，周日的下午，离我联系之前面试官也就20分钟的功夫，面试电话打来了，入耳听到的，是一个很有力量也很有磁性的声音，虽然听不出他声音里的负面情绪，但接下来的面试让我感觉到他的针对，在闲聊中，不经意的他问了我的未来规划，如何走，并且近期有哪些行动去完成目标和未来的规划等等，问的非常细致，然后还聊了人生理想等等，俺被他说得越来越没底气，感觉出对方一种压迫式的问题，一连串的问我，最后还聊了关于学习方法和思维方式方面的东西，最终俺就是挂在他的手上，后面了解到，他就是传说中的HRBP，俺就是倒在了他这一关。不过在最后，他也总结了我的优缺点，特别是我的缺点，一条条的分析给我，我感觉很到位，有许多自己需要完善的地方。
从这之后，我想了很多，也思考了很多，我发觉我还有许多要提高的地方，就这样，又过了一个月，在今年的1月份，俺觉得自身无论从技术，业务还是个人的状态，都到了一种短时间很难再提升的状态了，这个时候，俺除了再联系之前的兄弟，面BAT另外的一个部门之外，还联系了猎头，帮推荐合适的工作，毕竟都快小半年了，俺也不能一直绑定在BAT的求职道路上，是不？
记得是1月中旬，俺已经顺利面试BAT中的第一轮，这次虽然技术面问的很细很全面，但俺准备的却更加滴充分，包括状态和自身的心态上，都是全力以赴，无所顾虑的，也就顺利通过了，在第二轮的时候，当时很巧合，记得是周三的时候，俺请假一天，去了BAT所在的城市面另外2家猎头推的工作，上午一家，下午一家，回来的时候，晚上又面了BAT的第二轮面试，过了几天，三家都反馈通过，其中一家已经确定口头offer了，薪资接近翻倍，是个和俺目前做的事差不多，也是有O2O背景的一个互联网电商公司，而第二家B公司是一家大数据的公司，俺薪资报的也有点高，他们决定再增加一轮技术面，由他们的架构师面试，在BAT那边最后一面的前一天晚上，进行了B公司的最终技术面，记得那晚发挥挺好的，自己经历的项目说的很透彻到位，技术上回答的也比较不错，经过一晚上，在后面一天的BAT最终面试中，俺承续了昨晚的状态，而且更进一步，发挥的更好了，不仅把项目中的经历说的透彻到位，还把整个电商领域的上下游，从前到后，线上线下都串联起来分析了一遍，而在谈到未来规划和学习方法等内容上，俺也说的比之前准备的要好，按我自己的评价的话，应该是展现出来的全是亮点，缺点完全被掩盖了，当最后谈及到薪资的时候，俺果断报的比预期值高了3K，之后就是等待结果的时候了。
终篇，永不放弃 一段时间后，不出意外地，B公司发出了offer,薪资是有了小一倍的提高，甚至相比于BAT，这个薪资绝对给力，当时俺也纠结过一段时间的，毕竟10点上班，6点下班，周末双休，平时基本不加班，一个纯技术岗位，工作时间不长，而且对于技术上的提升也是会比较大的。
接近过年的时候，俺接到BAT公司hr的电话，通过一段时间的聊天后顺利通过真正意义上hr面试，过了几天，他告知我已经通过了，offer要年后发出，薪资是目前的2倍以上。就这样，那次同一天面试的3家公司都通过了，而据我了解到BAT的这家，平时工作量是俺目前公司的2倍以上，俺后来很纠结，其实BAT的单位时间报酬，也就是性价比其实并不是非常高的，往往要投入很多的时间，加班多，当时一度想选择B公司，工作时间少，又是做大数据，前途貌似很光明。
在那段时间里，俺又一次的思考了很多，想了很多，因为俺是一个工作之外学习不太多的人，如果要在程序员这个行业中走好，走深入，势必要花费大量精力和时间的，俺也不是一个能主动坚持学习的人，但俺绝对是一个被动坚持，且耐力很好的一个人，最终俺选择的是BAT的那家，虽然工作之外俺很难坚持学习，那就让俺在无尽地加班中，工作中不断地学习吧，哈哈。在这里分享一个故事，让俺当时经历了一次又一次面试失败后，深受启发，依然坚持不断的学习和准备：
永不放弃--一个藏羚人的感人的故事 ： 永不放弃--一个藏羚人的感人故事_风雷恒的博客-CSDN博客。
是的，任何事情都应该坚定目标，永不放弃，这里如何去坚持，是关键，俺通过小伙伴和自身的求职经历，有所体悟，现在总结几点分享下：
1、求职过程，一定不能急，哪怕面试的再多再久，也不要轻易的去一家不太想去或者面试的不太好的公司。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea01f38f452131cbe9a14859dc3d374/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5141028fde712962dc7eaaf002300f/" rel="bookmark">
			1，安装 onlyoffice
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ONLYOFFICE Document Server 是一个在线办公套件，包括文本、电子表格和演示文稿的查看器和编辑器，完全兼容 Office Open XML 格式：.docx、.xlsx、.pptx，并支持实时协作编辑。
ONLYOFFICE办公套件包括三个基本组件:
文字处理（Word）电子表格（Excel）演示文稿（PPT） Docker 安装
推荐的系统要求
内存：4 GB 或更多CPU : 双核 2 GHz 或更高交换文件：至少 5 GB硬盘：至少 10 GB 的可用空间发行版：64 位 Red Hat、CentOS 或其他内核版本为 3.8 或更高版本的兼容发行版，64 位 Debian、Ubuntu 或其他内核版本为 3.8 或更高版本的兼容发行版Docker：版本 1.9.0 或更高版本 从docker hub上(阿里云加速器)拉取onlyoffice/documentserver镜像到本地标签为7.1.1
Docker
从docker hub上拉取onlyoffice/documentserver镜像到本地
docker pull onlyoffice/documentserver:7.1.1
运行配置 Docker 镜像
存储数据
所有数据都存储在专门指定的目录，数据卷，在以下位置：
/var/log/onlyoffice 用于ONLYOFFICE 文档服务器日志/var/www/onlyoffice/Data 证书/var/www/onlyoffice/documentserver/sdkjs-plugins 插件管理，需要手动处理到sdkjs-plugins目录下（ONLYOFFICE Api Documentation - Adding plugins） 要从容器外部访问您的数据，您需要安装卷。可以通过在 docker run 命令中指定“-v”选项来完成。
sudo docker run -i -t -d -p 80:80 --privileged=true \ -v /app/onlyoffice/DocumentServer/logs:/var/log/onlyoffice \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c5141028fde712962dc7eaaf002300f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/234d0b8ce75abb447debff666e34dbd2/" rel="bookmark">
			VScode注释中文时乱码怎么办？VScode中文注释乱码问题的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在编写C语言代码的时候，会对代码进行中文的注释，但是使用VScode打开代码之后，部分的中文注释会出现乱码的情况，对此找到了几个解决中文注释乱码的方法，分享给大家，希望可以对大家的学习带来帮助。 不管是在哪一种编辑器上，都会有自动默认的一种编码格式，在vscode编辑器中默认的编码格式是utf-8，但是在注释的时候，因为使用的字符会不一样，所以可能存在着默认的配置文件，有可能是其他的编码格式，所以因为编码格式不对应，导致了在注释的时候出现了乱码的情况，下面一起来看看详细的解决方法，如下：
方法一：勾选auto guess
进入到VScode编辑器中，找到顶部菜单栏中的文件选项，点击之后选择下拉菜单中的“首选项”，再点击子右侧中的子选项“设置”，进入到设置中，在打开的界面中的搜索框中搜索auto guess，然后在右侧的界面中，将auto guess….前的复选框选上即可，如图所示：
方法二：状态栏中切换
在VScode编辑器的界面中，最底部就是状态栏，在状态栏中包含了行、列数的统计，其实也可以设置字符的编码格式，点击“utf-8”之后，选择第一个“通过编码重新打开”，再选择GB 2312打开，设置好了之后就重启VScode，再次打开之后注释不会出现乱码，右下角也会变成GB2312编码格式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d344554b6cd8ef111bd85894eca2da3f/" rel="bookmark">
			docker 常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 连接容器内部
ssh_exchange_identification: read: Connection reset by peer docker容器内重启ssh服务
/etc/init.d/ssh restart 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b833fa0a5bfae381043aa28ae1597b5d/" rel="bookmark">
			app中更改个人信息时前后端的业务逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在app中，更改个人信息的业务逻辑通常是这样的： 1. 前端页面提供一个表单，让用户输入新的个人信息。
2. 用户提交表单时，前端会向后端发送一个请求，将新的个人信息传递给后端。
3. 后端接收到请求后，会根据请求中传递的信息更新用户信息，并将更新后的用户信息返回给前端。
4. 前端接收到后端返回的更新后的用户信息后，将其更新到页面上。
下面是一个前端如何请求及后端 Node 如何返回字段的示例： 前端页面：
&lt;!-- html 页面中提供一个表单，让用户可以输入新的个人名称 --&gt; &lt;form @submit.prevent="submitForm"&gt; &lt;label for="newName"&gt;New Name:&lt;/label&gt; &lt;input type="text" id="newName" v-model="newName" required&gt; &lt;button type="submit"&gt;Submit&lt;/button&gt; &lt;/form&gt; 在这里，v-model 指令将用户输入绑定到 newName 变量中，@submit.prevent="submitForm" 指令绑定了表单提交事件，并触发 submitForm 方法。
前端 Vue 组件：
export default { data() { return { newName: '' // 初始化新名称为空字符串 } }, methods: { submitForm() { // 向后端发送 POST 请求，将 newName 传递给后端 axios.post('/api/updateName', { name: this.newName }) .then(response =&gt; { // 成功接收到后端返回的数据，将其更新到页面上 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b833fa0a5bfae381043aa28ae1597b5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c63c1be263f41fb2973833dcd7e14a1/" rel="bookmark">
			c# 32位程序突破2G内存限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因 在开发过程中，由于某些COM组件只能在32位程序下运行，程序不得不在X86平台下生成。而X86的32位程序默认内存大小被限制在2G。由于程序中可能存在大数量处理，期间对象若没有及时释放或则回收，内存占用达到了1.2G左右，就会引发异常“内存溢出”。
环境：Visual Studio 2022
问题复现 解决方案 1、在VS中右键【启动项目】的【属性】，在【生成事件】中申请大内存
2、使用editbin.exe申请大内存(注意editbin这个exe需要vs安装c++相关组件)。安装好后一般在如下目录中：C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.30.30705\bin\Hostx86\x86
在命令行中输入如下命令：
CALL "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\Common7\Tools\VsDevCmd.bat" editbin /largeaddressaware "$(TargetPath)" 3、再次运行，可见已成功突破2G内存限制
查看exe是否支持大内存 在命令窗口使用dumpbin查看。
命令：dumpbin /headers xxx.exe
运行命令后可见，蓝色框内，程序已经突破2G内存限制。
未突破2G内存限制程序显示：
天地不过是飘摇的逆旅，昼夜不过是光阴的门户。 ——《花镜》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/312d8271ebfbd59e9b5f171efec2bd0b/" rel="bookmark">
			Pytorch学习笔记(一)-神经网络参数的冻结与解冻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在迁移学习（Transfer Learning）等领域，通常会将预训练模型（Pre-trained Model）主干部分的权重进行冻结，再在目标领域的数据集下对余下权重参数进行调参。上述过程涉及神经网络参数冻结与解冻。
在Pytorch中，网络参数通过梯度下降法及其衍生算法进行优化，其关键在于梯度的逐层传递。因此，通过关闭或打开参数的梯度计算即可实现参数的冻结与解冻。Pytorch中，网络参数均为张量（Tensor），涉及梯度计算的特征（Attribute）为requires_grad，默认情况下requires_grad=True，即默认情况下计算Tensor的梯度。
model.fc.weight.requires_grad = False
model.fc.bias.requires_grad = False
PyTorch提供了state_dict()和load_state_dict()两个方法用来保存和加载模型参数，前者将模型参数保存为字典形式，后者将字典形式的模型参数载入到模型当中。下面是使用预训练权重（加载预训练模型）的代码，其中model_path就是预训练权重文件的路径：
# 第一步：读取当前模型参数 model_dict = model.state_dict() # 第二步：读取预训练模型 pretrained_dict = torch.load(model_path, map_location = device) pretrained_dict = {k: v for k, v in pretrained_dict.items() if np.shape(model_dict[k]) == np.shape(v)} # 第三步：使用预训练的模型更新当前模型参数 model_dict.update(pretrained_dict) # 第四步：加载模型参数 model.load_state_dict(model_dict) 但是，使用load_state_dict()加载模型参数时，要求保存的模型参数键值类型和模型完全一致
一旦我们对模型结构做了些许修改，就会出现类似unexpected key module.xxx.weight问题。比如在目标检测模型中，如果修改了主干特征提取网络，只要不是直接替换为现有的其它神经网络，基本上预训练权重是不能用的，要么就自己判断权值里卷积核的shape然后去匹配，要么就只能利用这个主干网络在诸如ImageNet这样的数据集上训练一个自己的预训练模型；如果修改的是后面的neck或者是head的话，前面的backbone的预训练权重还是可以用的。下面是权值匹配的示例代码，把不匹配的直接pass了：
model_dict = model.state_dict() pretrained_dict = torch.load(model_path, map_location=device) temp = {} for k, v in pretrained_dict.items(): try: if np.shape(model_dict[k]) == np.shape(v): temp[k]=v except: pass model_dict.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/312d8271ebfbd59e9b5f171efec2bd0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ae4c8164c799dcbb81f3f7732c0896/" rel="bookmark">
			Navicat连接Oracle报错：Oracle library is not loaded
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、用Navicat连接Oracle数据库时报错：Oracle library is not loaded
2、是oci.dll版本不对。因为Navicat是通过Oracle客户端连接Oracle服务器的，Oracle的客户端分为两种，一种是标准版，一种是简洁版，即Oracle Install Client。而我们用Navicat时通常会在自己的安装路径下包含多个版本的OCI，如果使用Navicat连接Oracle服务器出现错误时，多数是因为Navicat本地的OCI版本与Oracle服务器不符造成的。所以我们要做的就是下载对应版本的OCI使之与我们所安装的Oracle服务器相符合。
OCI下载地址：https://www.oracle.com/technetwork/topics/winx64soft-089540.html
4、OCI library中找到刚刚下载的文件夹中的oci.dll，重启Navicat就好了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f4865d53c8568e8a9c5bb283c369ac3/" rel="bookmark">
			mac修改pip源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方式1 pip3 config set global.index-url https://mirrors.aliyun.com/pypi/simple/ 方式2 修改~/.config/pip/pip.conf，添加该内容
[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple/ 源地址列表 阿里云: https://mirrors.aliyun.com/pypi/simple/ 中国科技大学: https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣: https://pypi.douban.com/simple/ Python官方: https://pypi.python.org/simple/ 中国科学院: https://pypi.mirrors.opencas.cn/simple/ 清华大学: https://pypi.tuna.tsinghua.edu.cn/simple/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6863b302b2bde5b2896794ed85d85bc8/" rel="bookmark">
			【赛码】回文串（python版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目地址：https://exercise.acmcoder.com/online/online_judge_ques?ques_id=3013&amp;konwledgeId=134 AC代码在本文最后
Point: 这个题的输出的录入写错了，不应该是YES/NO，要输出Yes/No……(^^;; 不过他们现在好像不做C端，所以估计这边维护的较弱，不建议在这里刷题。但是大厂很多考试在这里，还是建议在考试前来熟悉熟悉这个系统，oj的输入输出...上面放的题目也不是很难，应该也是想让大家练手了。
关于很多同学抱怨为什么要写输入输出，而不像力扣那样直接写核心代码。我的理解是校招的公司要求采用ACM模式，打过ACM的同学都知道，是要写输入输出的，甚至这上面都是有考点的，虽然和实际工作内容没有毛关系，但是人家制定规则，咱们只能见招拆招喽。
题目：👇
对于输入输出，首先我们需要理解什么是回文串，并牢记标准。
🌰帮助大家理解，下面是调试的代码，我把相应的打印出来了。python的回文问题，用切片来解决最简单
切片（slicing）可将一个可迭代对象中元素的子集，创建为一个新的可迭代对象。切片的语法是[ 可迭代对象 ] [ [ 起始索引:结束索引 ] ]。起始索引（start index）是开始切片的索引，结束索引（end index）是结束索引的位置。
输入：edfr
AC 代码：python3.4.3
s = input() for i in range(len(s)): p=s[:i]+s[i+1:] if p==p[::-1]: t=True break else: t=False if t: print('Yes') else: print('No') github地址： https://github.com/PointWu/acmCode
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6bce799fb4dccb3e4cb984a9ce4eac1/" rel="bookmark">
			【Kubernetes】第二十一篇 - k8s 项目部署流程和操作梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，前言 上一篇，介绍了 k8s 污点和容忍度；
在了解前面 k8s 介绍之后，设计并完成一个前后端项目的部署和持续集成；
本篇，介绍基于 k8s 项目部署流程设计；
二，项目部署流程设计 本地 IDE 进行代码开发，完成并提交到代码仓库（使用 gitee）；代码提交后，触发 jenkins 构建任务，拉取代码到 ci-server 服务器，开启构建流程；构建流程：1，拉取最新代码 2，安装依赖 3，打包构建 4，创建 docker 镜像 5，将构件推送至私有仓库；CI 过程可以执行单元测试，代码校验，质量检测，端到端测试等操作k8s 拉取镜像完成部署更新； 部署顺序：
配置并部署 mysql 数据库部署后端服务部署前端服务 备注：考虑到服务器成本，前端、后端和数据库全都部署在 k8s-node 上，和集群部署的是操作一致的；
三，部署操作梳理 部署 MySQL
可以为指定 node 添加污点，专门用于 mysql 部署（当前只有一个节点，不考虑）；为了保证mysql容器重启时数据不会丢失：创建 mysql 数据目录，用于存储 mysql 数据，实现 MySQL 数据的持久化；创建 Secret 对象，向为 mysql 容器提供用户名、密码信息；创建 mysql Deployment 配置文件，并创建 deploy 完成 pod 部署；创建 mysql Service 配置文件，并创建 service 解决 ip 漂移问题，对外提供 pod 访问；为 k8s-master 安装 mysql，使 k8s-master 能够使用 mysql 命令，测试数据库使用； 部署后端项目（nodejs）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6bce799fb4dccb3e4cb984a9ce4eac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/130cc448b6a0a0bec551dda694b20799/" rel="bookmark">
			MySQL面试题-性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.MySQL的优化可以从哪些方面考虑？
2.索引优化有哪些建议
3.如何优化sql的性能
4.大数据量（超100万行）的批量写（UPDATE、DELETE、INSERT）操作会导致什么问题
5.MySQL修改大表的表结构会出现什么问题
1.MySQL的优化可以从哪些方面考虑？ 1.索引优化
索引是加速数据库查询的关键。在设计表结构时，应该根据查询的需求添加合适的索引。常用的索引包括主键、唯一索引、普通索引、全文索引等。
同时，要避免过多的索引，因为每个索引都需要占用存储空间，会影响写入性能。
2.查询优化
优化查询语句是提高MySQL性能的重要手段。要尽可能使用索引，避免全表扫描。同时，要避免使用子查询，尽可能使用连接查询；避免在查询中使用“%”通配符；避免多余的字段等等。
3.数据库表结构优化
合理的表结构可以提高查询效率和减少存储空间。应该避免使用大字段，如TEXT、BLOB等，因为这些字段会占用大量的存储空间。同时，应该避免冗余字段，避免更新和维护时的复杂性。
4.缓存优化
使用缓存可以大大减轻MySQL数据库的压力，提高查询效率。常用的缓存技术包括Memcached和Redis等。
5.分区优化
对于数据量较大的表，可以使用分区技术将表分成多个部分。这样可以提高查询效率，同时降低了单个表的存储空间和索引大小。
6.配置优化
MySQL的参数配置会影响MySQL的性能。需要根据实际情况进行调整，包括缓冲区、连接数、线程数、查询缓存等等。
7.硬件优化
硬件设备也会影响MySQL的性能。要选择更快速的硬件设备，如更快的磁盘、更快的CPU和更多的内存等等。同时，要根据实际情况来决定使用RAID、SSD等技术。
2.索引优化有哪些建议 创建主键索引：每张表都应该有一个主键，可以使用自增主键或者UUID等方式创建。主键索引可以大大提高查询效率。
创建唯一索引：对于需要唯一性约束的列，可以创建唯一索引。唯一索引可以避免重复数据的插入，并且可以大大提高查询效率。
创建联合索引：对于经常用到多个列进行查询的情况，可以创建联合索引。联合索引是指包含多个列的索引。在使用联合索引时，需要注意索引列的顺序，应该将选择性高的列放在前面。
创建前缀索引：对于文本类型的列，可以使用前缀索引来提高查询效率。前缀索引是指只对文本的一部分进行索引。
不要使用全文索引代替普通索引：全文索引可以用来搜索文本内容，但是不能用来排序或者分组。如果需要排序或者分组，应该使用普通索引。
避免使用过多的列创建索引：索引列越多，索引的大小就越大，维护的代价也越高。应该根据实际情况来决定创建哪些索引。
避免使用含有NULL值的列作为索引列：含有NULL值的列无法使用B-Tree索引，会影响查询效率。
对于大表的索引优化，可以使用索引覆盖扫描、索引合并等技术，以提高查询效率。
3.如何优化sql的性能 尽量减少查询次数：查询的次数越多，数据库的负担就越重。可以通过合并多个查询语句、使用子查询等方式来减少查询次数。
使用索引：在查询语句中使用索引可以大大提高查询效率。应该根据具体的查询需求来选择合适的索引类型。
避免在查询条件中使用函数：在查询条件中使用函数会导致索引失效，影响查询效率。应该尽可能避免在查询条件中使用函数。
使用适当的JOIN方式：在使用JOIN时，应该选择合适的JOIN方式。INNER JOIN是最常用的JOIN方式，但是在某些情况下，LEFT JOIN或者RIGHT JOIN可能更合适。
避免使用SELECT *：SELECT *会返回所有列的数据，包括不需要的列，会增加网络传输的开销和数据库的负担。应该尽可能指定需要的列。
避免使用子查询：子查询是一种方便的查询方式，但是在某些情况下，子查询的性能可能比较低。可以考虑使用JOIN方式来代替子查询。
避免在查询语句中使用OR：在查询语句中使用OR会导致查询优化器无法使用索引，影响查询效率。可以考虑使用UNION ALL来代替OR。
使用LIMIT限制返回的数据行数：使用LIMIT可以限制返回的数据行数，可以减少数据库的负担和网络传输的开销。
使用EXPLAIN分析查询计划：使用EXPLAIN可以查看MySQL优化器在执行查询时选择的查询计划，可以根据查询计划来优化查询语句。
4.大数据量（超100万行）的批量写（UPDATE、DELETE、INSERT）操作会导致什么问题 阻塞其他操作：批量写操作可能需要占用大量的系统资源，包括CPU、内存、磁盘等，如果写操作持续时间过长，可能会阻塞其他操作，导致系统响应变慢。
磁盘空间不足：批量写操作可能会占用大量的磁盘空间，如果磁盘空间不足，可能会导致写操作失败或者数据库无法正常工作。
日志过大：在执行写操作时，MySQL会生成事务日志用于保证数据的一致性。如果写操作的数据量过大，事务日志也会变得非常大，可能会导致磁盘空间不足或者日志写入速度变慢。
死锁：如果多个客户端同时进行批量写操作，并且操作的数据范围有重叠，可能会导致死锁。
数据库性能下降：如果批量写操作的负载太大，可能会导致数据库性能下降，查询响应时间变慢，甚至出现数据库崩溃的情况。
主从延迟：在MySQL主从复制架构中，如果主服务器上发生了大量的写操作，从服务器需要读取和应用这些操作，就会导致主从延迟。特别地，如果从服务器在处理写操作的过程中遇到了锁冲突或者主服务器上的写操作太多，从服务器的复制进程可能会被阻塞，从而导致主从延迟。
为了避免以上问题，可以采取以下措施：
尽量减少批量写操作的数据量，可以将大批量数据分批进行写入，以避免对系统的影响。
预留足够的磁盘空间和系统资源，以确保批量写操作能够正常执行。
优化数据库表结构和索引，以提高写操作的性能和效率。
使用事务进行批量写操作，以确保数据的一致性。
使用数据库中的队列或者缓存机制，将批量写操作异步化处理，以避免对系统的影响。
5.MySQL修改大表的表结构会出现什么问题 长时间的阻塞：当对大表进行修改时，MySQL 会将表锁定，这将阻塞其他用户对该表的读写操作。在修改期间，如果有其他用户尝试访问该表，则会被阻塞，可能会导致应用程序的延迟或响应时间变慢。
需要大量的空间和时间：在修改大表结构时，需要为该表创建一个新的临时表并将数据复制到该表中。这将需要大量的磁盘空间和时间，特别是对于具有大量数据的表。
数据丢失：如果在修改表结构时发生错误，可能会导致数据丢失或不一致。因此，在进行此类操作之前，应备份数据库以便出现问题时可以进行恢复。
应用程序问题：如果应用程序依赖于表的结构或数据格式，则修改表结构可能会导致应用程序出现问题。在进行此类操作之前，应先检查应用程序的代码以确保它们不会受到影响。
使用 pt-online-schema-change 工具可以在一定程度上减少 MySQL 修改大表结构所带来的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/130cc448b6a0a0bec551dda694b20799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950a11a3bdf090182fcaff107f2371a9/" rel="bookmark">
			系统吞吐量、TPS（QPS）、用户并发量、性能测试概念和公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一．系统吞度量要素：
一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。
系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间
QPS（TPS）：每秒钟request/事务 数量
并发数：系统同时处理的request/事务数
响应时间：一般取平均响应时间
（很多人经常会把并发数和TPS理解混淆）
理解了上面三个要素的意义之后，就能推算出它们之间的关系：
QPS（TPS）= 并发数/平均响应时间 或者 并发数 = QPS*平均响应时间
一个典型的上班签到系统，早上8点上班，7点半到8点的30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每个员上登录签到系统的时长为5分钟。可以用下面的方法计算。
QPS = 1000/(30*60) 事务/秒
平均响应时间为 = 5*60 秒
并发数= QPS*平均响应时间 = 1000/(30*60) *(5*60)=166.7
一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。
决定系统响应时间要素
我们做项目要排计划，可以多人同时并发做多项任务，也可以一个人或者多个人串行工作，始终会有一条关键路径，这条路径就是项目的工期。
系统一次调用的响应时间跟项目计划一样，也有一条关键路径，这个关键路径是就是系统影响时间；
关键路径是有CPU运算、IO、外部系统响应等等组成。
二．系统吞吐量评估：
我们在做系统设计的时候就需要考虑CPU运算、IO、外部系统响应因素造成的影响以及对系统性能的初步预估。
而通常境况下，我们面对需求，我们评估出来的出来QPS、并发数之外，还有另外一个维度：日PV。
通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。
通常的技术方法：
1. 找出系统的最高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外）
2. 通过压力测试或者经验预估，得出最高TPS，然后跟进1的关系，计算出系统最高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。
A)淘宝
淘宝流量图：
淘宝的TPS和PV之间的关系通常为 最高TPS：PV大约为 1 : 11*3600 （相当于按最高TPS访问11个小时，这个是商品详情的场景，不同的应用场景会有一些不同）
B) B2B中文站
B2B的TPS和PV之间的关系不同的系统不同的应用场景比例变化比较大，粗略估计在1 : 8个小时左右的关系（09年对offerdetail的流量分析数据）。旺铺和offerdetail这两个比例相差很大，可能是因为爬虫暂的比例较高的原因导致。
在淘宝环境下，假设我们压力测试出的TPS为100，那么这个系统的日吞吐量=100*11*3600=396万
这个是在简单（单一url）的情况下，有些页面，一个页面有多个request，系统的实际吞吐量还要小。
无论有无思考时间（T_think），测试所得的TPS值和并发虚拟用户数(U_concurrent)、Loadrunner读取的交易响应时间（T_response）之间有以下关系（稳定运行情况下）：
TPS=U_concurrent / (T_response+T_think)。
并发数、QPS、平均响应时间三者之间关系
上图横坐标是并发用户数。绿线是CPU使用率；紫线是吞吐量，即QPS；蓝线是时延。
开始，系统只有一个用户，CPU工作肯定是不饱合的。一方面该服务器可能有多个cpu，但是只处理单个进程，另一方面，在处理一个进程中，有些阶段可能是IO阶段，这个时候会造成CPU等待，但是有没有其他请 求进程可以被处理）。随着并发用户数的增加，CPU利用率上升，QPS相应也增加（公式为QPS=并发用户数/平均响应时间。）随着并发用户数的增加，平均响应时间也在增加，而且平均响应时间的增加是一个指数增加曲线。而当并发数增加到很大时，每秒钟都会有很多请求需要处理，会造成进程（线程）频繁切换，反正真正用于处理请求的时间变少，每秒能够处 理的请求数反而变少，同时用户的请求等待时间也会变大，甚至超过用户的心理底线。
上面的引用于:http://www.cnblogs.com/jackei/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/950a11a3bdf090182fcaff107f2371a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d8aaed9fe99354167c80ea641e5e52/" rel="bookmark">
			curl编译：error: call to ‘_curl_easy_setopt_err_curl_off_t‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		inc/curl/typecheck-gcc.h:50:13: error: call to '_curl_easy_setopt_err_curl_off_t' declared with attribute warning: curl_easy_setopt expects a curl_off_t argument for this option [-Werror] _curl_easy_setopt_err_curl_off_t(); \ ^ curlDemo.c:453:5: note: in expansion of macro 'curl_easy_setopt' curl_easy_setopt(curl, CURLOPT_RESUME_FROM_LARGE, downloadedSize); 解决方法：
32位 downloadedSize定义为long long 类型
64位 downloadedSize 定义为long 类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7ad921369c8b520fafd9e7fdc721656/" rel="bookmark">
			c&#43;&#43;随机生成数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int num1 = rand() % 10 + 1;//生成1~10的随机数
int num2 = rand() % 100 + 1;//生成1~100的随机数
int num3= rand() % 34 + 66;//生成66~99的随机数
int num4 = rand() % (n - m + 1) + m;//生成m~n的随机数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f12e283651e51e7db034feeded1c0635/" rel="bookmark">
			模拟实现库函数strcpy的四种方法（逐个优化）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先，我们要明确strcpy的用法及工作原理，如下：
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;(strcpy需要引的头文件）
int main()
{ char arr1[] = "#############";
char arr2[] = "bit";
strcpy(arr1,arr2) ； (strcpy (目的地，源头））
printf("%s\n",arr1);
return 0;
}
此段代码的输出结果为bit。因为字符串的结束标志为‘\0’，所以字符串arr1的内容其实为”#########\0",字符串arr2的内容为"bit\0"，strcpy函数的本质就是将源头的值输送给目的地的值，遇到\0则停止。所以打印出arr1的结果是“bit”。
2.模拟实现strcpy函数
方法1:
#include&lt;Stdio.h&gt;
void my_strcpy(char*dest,char*sur) (地址要用指针来接收）
{ while( *sur != '\0')
{
*dest = *sur;
dest++;
sur++; }
*dest = *sur
}
int main()
{
char arr1[] = "##########";
char arr2[] = "bit";
my_strcpy(arr1,arr2); (数组传参实际上传过去的是数组首元素地址）
printf("%s\n,arr1);
return 0;
}
如果满分给十分，那么方法1只能拿到6分，代码形式较挫且不能发现bug
方法2:
#include&lt;Stdio.h&gt;
void my_strcpy(char*dest,char*sur) { while( *dest++ = *sur++) (*dest与*sur在没遇到\0之前都为真，所以while可以运行，每运行一次，后置++就使dest与str指针指向下一个元素，直到遇到\0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f12e283651e51e7db034feeded1c0635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d0a77bcc468695007c84705cc4faa7/" rel="bookmark">
			最详细蓝桥杯嵌入式教程（四）：按键单击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在完成了LCD的学习后，我们接下来开始学习按键的控制。
首先要学的是按键的单击控制。
下图是有关按键的控制电路。
在看明白电路之后，我们开始在上一个cubeMX的工程中继续进行配置。
然后，配置完这些之后，我们就来到了控制按键的关键，对定时器进行配置。
我们首先要了解一下，我们使用的板子的定时器，所以我们打开官方给我们的资料。
然后，我选择的是TIM4，继续对定时器继续配置。
到此为止，我们就已经完成了按键在cubeMX上的配置。
然后我们就可以开始编写程序了。
#ifndef __INTERRUPT_H
#define __INTERRUPT_H
#include "main.h"
#include "stdbool.h"
//声明结构体
struct keys
{
uchar state_index;//按键状态索引
bool key_state;//按键状态
bool single_flag;//按键最后确定被按下时置1
};
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
#endif
一般情况下，可以直接在旁边的文件栏找到hal_tim_h，如果找不到，就先将工程编译一下然后去找。
如果编译了之后都还找不到，那么我们就可以进行以下操作。
#include "interrupt.h"
struct keys key[4]={0,0,0,0};
//中断回调函数
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
if(htim-&gt;Instance==TIM4)
{
key[0].key_state=HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0);
key[1].key_state=HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1);
key[2].key_state=HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2);
key[3].key_state=HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0);
for(int i=0;i&lt;4;i++)
{
switch (key[i].state_index)
{
case 0:
{
if(key[i].key_state==0)
{
key[i].state_index=1;
}
}
break;
case 1:
{
if(key[i].key_state==0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3d0a77bcc468695007c84705cc4faa7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542a190d2620febadc180e4a79ed24f3/" rel="bookmark">
			tortoisegit 执行 pull 报错Could not get HEAD hash
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下方法验证通过：特此转发
报错如下：
解决方法：
1.
2.按确定
3.命令行中输入：git config --global --add safe.directory “*”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da8d401b8a5d9983586be5860a82b87/" rel="bookmark">
			STM32单片机中如何设置串口程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面以STM32F103C8T6单片机为例，介绍如何在STM32单片机中设置串口程序。
串口硬件连接
在STM32F103C8T6单片机中，有多个USART模块可供使用。这些USART模块的引脚分布如下：
USART1：PA9 (Tx), PA10 (Rx)
USART2：PA2 (Tx), PA3 (Rx)
USART3：PB10 (Tx), PB11 (Rx)
在使用其中的一个USART模块时，需要将其Tx引脚连接到外部设备的Rx引脚，将其Rx引脚连接到外部设备的Tx引脚。
串口寄存器的设置
在STM32单片机中，串口的寄存器包括USART_SR、USART_DR、USART_BRR、USART_CR1、USART_CR2和USART_CR3等。这些寄存器的作用如下：
USART_SR：串口状态寄存器，包括传输完成标志位TC、数据寄存器空标志位TXE和接收寄存器非空标志位RXNE等。
USART_DR：串口数据寄存器，用于存储待发送或已接收的数据。
USART_BRR：串口波特率寄存器，用于设置波特率。
USART_CR1：串口控制寄存器1，包括串口使能位UE、发送使能位TE、接收使能位RE和空闲中断使能位IDLEIE等。
USART_CR2：串口控制寄存器2，用于设置数据长度、停止位数和校验位等。
USART_CR3：串口控制寄存器3，用于设置硬件流控制等。
在STM32单片机中，设置串口程序的步骤如下：
1）使能USART时钟
USART模块的时钟需要在RCC_APB2PeriphClockCmd()函数中使能。
2）设置GPIO引脚模式
将USART的Tx和Rx引脚设置为复用功能，可以使用GPIO_Init()函数进行设置。
3）设置波特率
将USART_BRR寄存器设置为所需的波特率，可以使用USART_Init()函数进行设置。
4）使能串口
通过设置USART_CR1寄存器的UE、TE和RE位，使能串口的发送和接收功能，可以使用USART_Cmd()函数进行设置。
5）发送数据
通过将需要发送的数据写入USART_DR寄存器，实现数据的发送。
以下是一个简单的STM32串口发送程序的代码实现：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dccebd4b7eb387c4afd4db40f5cd9ba/" rel="bookmark">
			小迪安全2023年第1天培训笔记：Web应用、架构搭建、站库分离、路由访问、配置受限、DNS解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几期的内容非常简单基础，但越是简单基础的知识，越蕴含着雄厚的道理，知晓这些基础内容，有利于我们在今后的攻防中针对不同的情况做出正确的判断，从而采取有效的方法
一、WEB四大件-系统 web的四大件分别为系统、中间件、数据库、源码，我们通过一套完整的web搭建来分别解释四大件的作用。web搭建有多种方式，在本地搭建，在服务器搭建，web搭建又分为不同的系统，比如linux还是window等等，之前我只在Linux中搭建过相关web服务，正好今天学习一下在window server中搭建web
购买服务器搭建网站 1.购买域名：阿里云域名注册1元起(特惠专区）
2.购买服务器：https://ecs.console.aliyun.com/home，选择按量付费（注意，如果按量付费，阿里云的余额不得低于100，也可以选择腾讯云，可以直接购买，没有余额限制），镜像选择window server 2012 r2 ，其他配置默认即可
3.购买成功后，我们访问阿里云登录 - 欢迎登录阿里云，安全稳定的云计算服务平台即可看到我们的服务器，点击远程连接即可连接，也可以直接通过本地电脑的远程连接输入服务器的ip和密码来连接使用（推荐这种方式）
4.打开域名控制台，找到自己的域名，点击解析，记录类型为A，主机记录随便写，记录值为上面window server服务器的公网ip
5.根据教程Windows Server2012 环境下搭建IIS_windowsserver2012安装iis_小方不慌（网安版）的博客-CSDN博客搭建IIS，整个过程非常简单，无脑点下一步即可
6.打开zblog官网，下载asp版本的blog源码，下载地址：https://update.zblogcn.com/onlineasp/install.zip,下载好后，解压到指定目录
7.打开window server中的IIS，右击选择IIS管理器，找到左侧的网站按钮，右击添加网站，物理路径即我们下载的blog源码的解压地址，主机名即我们的二级域名
8.设置完成后，我们点击应用程序池，找到zblog-高级设置-启用32位应用程序为true
点击网站的功能视图，打开默认文档设置，将Default.asp置顶 此时访问study1.zhangjia.pro，安装网站即可
网站的三种模式 子域名模式 我购买的域名是zhangjia.pro，则study.zhangjia.pro就是zhangjia.pro的子域名，又叫二级域名在现实生活中，一般一个域名对应多个子域名，每个子域名对应不同的系统，我们可以分别去攻击 端口模式 网站的端口号默认是80，不加端口号也可以直接访问可以通过更换不同的端口号来访问不同的系统，如果更换为其他端口，则必须访问的时候添加端口号，格式为域名:端口号 目录模式 域名/a和域名/b可以部署两套不同的程序，通过更换域名的目录，即可访问不同的程序 其他模式 集成软件Docker容器分配站举例：博客站的每个用户都会分配一个网站供自己使用，QQ空间也是这种模式，此类网站安全性更好，更难突破 web程序源码 分为三种形式 开源商业自写 二、WEB四大件-中间件 常见的中间件配置包括目录权限、身份验证、解析规则，在日常的攻防中，当我们访问某个文件受阻的时候，就要考虑是不是某个中间件配置生效了
目录权限 每个网站都可以通过配置各种中间件来设置不同的文件访问权限，还是以上面的系统为例，我们打开任一文件，右击编辑权限-安全-编辑，即可修改该文件的访问状态，如果设置成拒绝访问，那么外部人员即使获取到了该文件的地址也无法访问
身份认证 还可以通过用户验证的方式，只有登录成功的用户才有访问权限，选中某个文件-功能视图中选择身份验证，关闭匿名访问，打开window身份验证即可
解析规则 媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型）是一种标准，用来表示文档、文件或字节流的性质和格式，通过该规则我们能够根据文件的后缀来解析指定的文件格式，某些网站会存在解析漏洞，我们可以将木马文件上传后，通过修改解析规则来执行木马
三、WEB四大件-数据库 数据库是结构化信息或数据的有序集合，一般以电子形式存储在计算机系统中。通常由数据库管理系统 (DBMS) 来控制。在现实中，数据、DBMS 及关联应用一起被称为数据库系统，通常简称为数据库
简单来说，我们打开某个网站，该网站的文章、动态、配置、我们的用户名和密码都是存储在数据库中
数据库有以下几种常见模式：
本地存储：网站和数据库存储在同一个服务器中，如果数据库放在本地，那么拿到了网站的数据，一般也能拿到数据库的数据站库分离：网站和数据库不在同一个服务器中，网站访问数据库通过远程连接等方式，比如网站存储在A服务器，数据库存储在B服务器，每次客户请求数据时，A服务器从B服务器获取内容，如果是站库分离的网站，拿到了网站的数据，也不一定能拿到数据库云数据库：云数据库是近几年兴起的一个产品，简单来说就是把数据库存储在云端上，常见的有阿里云数据库和腾讯云数据库，相比传统的服务器，云安全系数更高，登录方式和安全组等安全配置更加复杂，还包含在线统计和分析等特色功能，同云数据库相似的还有OSS，网站文件不在存储在本地，而是存储在OSS中，OSS只做存储使用，不会执行我们上传的后门 四、WEB四大件-源码 源码类型 网站的源码分为以下几个类型，如果能拿到源码就可以进行白盒测试-代码审计
开源 源码可见，比如GitHub和Gitee中公开的项目大多是源码不可见的源码不可见，，比如GitHub和Gitee中开源的付费项目项目大多是源码不可见的，有的是通过代码加密来实现，也有的是语言特性决定的，比如java编译好的都是class文件，打开都是字节码（可以通过反编译来还原代码） 商业自用 结构组成 不同类型的网站的各种文件目录是有规律的，我们在攻防某个网站的时候，即使没有获取到该网站的目录，也可以通过该网站的类型来判断常见目录，比如WordPress类型的网站一般把主题存在/wp-content/themes/中
数据库目录后台目录文件目录 路由访问 访问一般有两种方式，普通的路径访问和路径访问，有些网站项目无法通过路径访问，比如java的web-inf文件，URL和文件目录对应不上，这种的需要配置路由才能访问某个网站
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dccebd4b7eb387c4afd4db40f5cd9ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc78b971cf6f016ef7b8251bacaac28/" rel="bookmark">
			Linux驱动交叉编译把驱动文件放入开发板，以及printk函数打印级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇介绍了一个最简单的驱动程序和驱动程序大体结构，但那还是用本地编译只能在Ubuntu上运行，我们该怎么编译一个能加载到开发板上呢，就需要交叉编译，交叉编译通常都是在嵌入式开发中使用到的。
交叉编译 理解交叉编译前先了解下本地编译：是指编译源代码的平台和执行源代码编译后程序的平台是同一个平台。例如在x86平台下编译的程序，就只能在x86平台下运行。
而我们现在是在Ubuntu下（x86）编译，到ARM开发板（arm）上去运行自然不行，所以交叉编译：是指编译源代码的平台和执行源代码编译后程序的平台是两个不同的平台，其中运行编译程序称为宿主机，运行编译程序所产生目标代码的称为目标机。
那为什么不在ARM开发板上编译程序呢，这样就不用转来转去了。之所以要有交叉编译，主要原因是：
1、目标机的运行速度往往比宿主机慢得多，许多专用的嵌入式硬件被设计为低成本和低功耗，没有太高的性能。
2、整个编译过程是非常消耗资源的，嵌入式系统往往没有足够的内存或磁盘空间。
3、 一个完整的Linux编译环境需要很多支持包，交叉编译使我们不需要花时间将各种支持包移植到目标机上。
交叉编译说完了，那怎么宿主机怎么给程序进行交叉编译呢，我们是站在巨人的肩膀上，自然是有现成的工具叫交叉编译器。
根据每个人使用的开发板不同需要下载不同的交叉编译器，大家可自行百度。
其实我们只需要在Makefile中指明交叉编译器的路径就行了，我们来看一个例子。
ifeq ($(KERNELRELEASE),) #内核源代码路径 KERNELDIR ?= /home/xin/6818GEC/kernel #交叉编译器路径 CROSS_PATH := /home/xin/6818GEC/prebuilts/gcc/linux-x86/arm/arm-eabi-4.8/bin/arm-eabi- #模块源代码路径 PWD := $(shell pwd) default: $(MAKE) CROSS_COMPILE=$(CROSS_PATH) -C $(KERNELDIR) M=$(PWD) modules clean: rm -rf *.o *.ko *.mod .*.cmd *.mod.* modules.order Module.symvers .tmp_versions else #obj-m表示编译生成可加载模块，obj-y表示直接将模块编译进内核。 obj-m := hello.o endif 这里面的参数上一篇详细解释过了，看不懂可以去看看（初学者的第一个Linux驱动）。其中开发板内核源代码路径和交叉编译器路径需要根据自己的存放位置去改变。
这是Ubuntu上开发板内核源代码的路径和内容。
这是Ubuntu上交叉编译器的路径和内容。 路径中只需要交叉编译器的前缀arm-eabi-
内核打印函数 printk 正常当我们在写应用程序时，都会使用printf函数或相关的打印函数来输出信息，帮助我们调试代码或者打印日志。那内核的驱动程序又没有应用层的库函数，这时候就需要使用我们的printk函数了。先来看一段代码和现象。
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; //加载函数 int printktest_init(void) { //内核打印语句 printk("&lt;0&gt;""printk level 0!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dc78b971cf6f016ef7b8251bacaac28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e670758bc0b6b9c0f645064ea95f274d/" rel="bookmark">
			PointPillars 工程复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PointPillars 工程复现 先赞后看，养成好习惯。有帮助的话，点波关注！我会坚持更新，感谢谢您的支持！
需求： 学习并复现PointPillars，解决部署时遇到的各类问题，原始参考工程为PointPillars_MultiHead_40FPS，注释版以及添加ROS节点版本在PointPillars_MultiHead_40FPS_ROS，供大家参考学习，欢迎留言！
参考工程：
1. PointPillars_MultiHead_40FPS
2. OpenPCDet
3. onnx2trt
4. onnx2trt安装过程可能遇到的问题
5. Spconv
一. 准备工作 1. 下载工程
PointPillars_MultiHead_40FPS：点云目标检测网络主工程OpenPCDet工具：用于将pth的模型，转换为onnx模型onnx-tensorrt工具：用于onnx到trt模型的转换。 git clone https://github.com/hova88/PointPillars_MultiHead_40FPS.git --recursive git clone https://github.com/hova88/OpenPCDet.git git clone https://github.com/onnx/onnx-tensorrt.git 2. 模型转换：
注意：
官方提供的两个onnx两个链接文件地址失效，故只能采用OpenPCDet工具进行onnx的生成。
1） cbgs_pp_multihead_pfe.onnx. 2） cbgs_pp_multihead_backbone.onnx
2.1）pth转化为onnx
在OpenPCDet工具工程下，执行下面的操作：
A. 下载*.pth权重文件拷贝到OpenPCDet工程下B. 配置修改
主要修改tools/onnx_utils/trans_pfe.py和tools/onnx_utils/trans_backbone_multihead.py相关路径，例如： ## 1. trans_pfe.py, 修改main文件中三处路径, 用### 标记 if __name__ == "__main__": from pcdet.config import cfg, cfg_from_yaml_file cfg_file = '/home/cui/workspace/deepLearning/OpenPCDet/tools/cfgs/nuscenes_models/cbgs_pp_multihead.yaml' ### filename_mh = "/home/cui/workspace/deepLearning/OpenPCDet/pp_multihead_nds5823_updated.pth" ### cfg_from_yaml_file(cfg_file, cfg) model_cfg=cfg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e670758bc0b6b9c0f645064ea95f274d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a250367d1f79837ae48aa16fa769b4/" rel="bookmark">
			C语言Strcpy函数使用注意事项：当源字符数组长度大于目标数组时的细节问题（越界）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看这个更直观的例子
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(){ char str1[5] = "12345"; printf("%s\n", str1); // 初始化时12345算上'\0'其实应该有6位，而数组只开辟了五位，故导致没有结束标识，会往后继续输出 char str2[6] = "12345"; printf("%s\n", str2); // 正常输出 char str3[10] = "123456789"; strcpy(str2, str3); printf("%s", str2); // 越界，未报错，但是覆盖了别的内存单元的值，有风险 } 输出结果为：
12345a
12345
123456789
#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char const *argv[]) { char *sss = "How are you"; // 算上 \0刚好12个字符 char str[11];// 只能放11个，且未初始化，内容是任意的 printf("原本这个位置及后一个的值是：%c和%c\n", str[11], str[12]); // 打印'\0'后面一个单元的字符，这个单元的内容是任意的 strcpy(str, sss + 4); // 即复制how are you\0 数组str内容为'a','r','e','空格','y','o','u','任意','任意','任意','任意' printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a250367d1f79837ae48aa16fa769b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8bc71d6964cbc65a34563cd1d2058c/" rel="bookmark">
			开源鸿蒙南向嵌入学习笔记——NAPI框架学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开源鸿蒙南向嵌入学习笔记——NAPI框架学习（一） 前言——系列介绍 本系列文章主要是记录笔者在鸿蒙南向的学习与工作中的知识点笔记记录，其中不止会针对鸿蒙中的学习问题进行思考与记录，也会对涉及到的一些嵌入式等其他领域知识，自我学习的心得进行记录。
本篇内容主要是黄同学最近在OpenHarmony 南向开发学习中对NAPI框架以及一些代码中的接口，异步实现等机制的学习。
MindMap NAPI框架简介 Node.js 的 N-API NAPI 其实是最早应该是来自node.js中的一个拓展库（也可以说是一整套API接口），叫Node-API，叫做N-API。是用来构建本地插件的API，将所有的nodejs底层数据结构黑盒化，封装成二进制接口，这样就可以实现不同版本的Node.js使用同样的接口，其目的是为了简化开发和维护。
NAPI （OpenHarmony） NAPI，全称 Native API，是OpenHarmony系统中的一套原生模块拓展开发框架，基于Nodejs中的N-API开发，为开发者提供了JS与C/C++不同语言模块之间的相互访问，交互的能力。它可以用于规范化封装IO、OS底层等，并可以提供相应的JS接口供开发者调用。当然。N-API也可以做到这一点。区别于 N-API，主要在于NAPI针对OpenHarmony 系统做了 一些适配化和优化。但二者的目的都是为了简化和统一原生模块的开发和维护，提高跨平台和跨版本的兼容性。 JS和C/C++互相访问实现原理（浅谈） 鄙人浅谈一下这个东西，欢迎各位斧正！
不同的语言的数据类型采用的是 napi_value类型做封装和转换（计算机网络协议既视感），而像函数等接口则采用如 napi_create_function() 以及 napi_call_function() 等来进行创建和调用。使用到了 V8 引擎，且对 V8的接口做了 黑盒化 和 抽象化，使得更加稳定。 Code Question 主要是记录一下在读以及编写Code时的遇到的问题的以及自己积累的心得体会。
大多是一些代码中的接口的解释和个人结合相关资料后的一点理解。
#ifdef __cplusplus extern “C” 这是一个在cpp中的宏命令，其表示的是如果在cpp文件中，我们需要调用一个C文件的接口背景： C 和 C++ 对于函数名字处理的机制不同，众所周知，C++支持函数重载，因此在执行函数时会对名字有特殊处理，但是C不同，C认为函数名只是一个名字。如果需要使用到C中写好的接口，需要使用C方式的链接，因此在需要 extern "C" 来提示编译器在将cpp文件转为汇编时将该处对接口的调用方式由Cpp方式改为C方式，从而可以正确链接。 好处：就是方便了开发，使得Cpp对C的兼容性更强，对于已经写得很好的C接口，无需用Cpp再写一份。 _attribute_((constructor)) 这是GCC一个特有的语法，用来修饰一个函数，从而让该函数在“main”之前执行，所以可以用来做初始化以及其他准备工作，比如初始化块变量或注册回调函数。可以避免一些依赖问题，提高性能。相反，__attribute__((destructor))可以修饰函数，使得这个函数在共享库卸载或者程序退出时执行。这两个都是C++ 11 标准中引入的属性指定符序列中的一种，属性指定符序列是一种标准语法。该语法还可以携带一个优先级参数，用于指定多个构造函数的执行顺序，优先级越低，执行越早。区别static static 变量是在全局变量初始化后，main执行之前的，而__attribute__((constructor))是在全局变量初始化之前执行，这样可以避免依赖问题。static只能在当前文件中使用，而__attribute__((constructor))可以在不同文件或者动态链接库中使用。 NAPI_CALL 是一个接口函数，用来调用JS中的函数，参数包括环境变量，接收对象，函数对象，参数个数，参数数组，返回值使用场景 封装IO、CPU密集型、OS底层能力，并将JS接口对外暴露。实现JS与C/C++代码的互相访问。优先封装异步方法。 该函数与其他类型的接口函数的区别 这是一个宏，可以用来检测NAPI函数的返回值是否正确，其他类型的函数需要手动检测。可以调用JS中任意函数，无论是全局还是对象的，其他接口只能调用特定类型以及特定范围的接口。可以在任何地方需要回调的时候调用，不需要额外的参数以及DS。 优势 简化NAPI函数的调用和错误处理，提高Code的可读性和可维护性。可以方便调用JS中的接口，实现C/C++和JS代码的互相访问任意调用，无需额外的参数以及DS 局限性 宏，不能作为函数指针传递给其他函数不能直接处理异步操作，需要结合其他接口存在兼容性和稳定性问题。 DELCARE_NAPI_FUCTION 这是NAPI的一个宏，看名字大家都知道这个是用来声明一个函数的，黄同学在很多使用NAPI的Cpp代码都能看到这个宏。
宏定义原型（参数），有两种形式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c8bc71d6964cbc65a34563cd1d2058c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/780a070f714603329b0d19830b45b9dc/" rel="bookmark">
			Spring-Xml配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Spring 简介 1.简介 文档下载地址：Index of /spring-framework/docs
1.简介 Spring framework 是 Spring 基础框架
学习Spring 家族产品
Spring framework
SpringBoot
SpringCloud
Spring 能用来做什么
开发 WEB 项目
微服务
分布式系统
Spring framework 是 Spring 最基础的框架，是其它框架技术的基础
SpringBoot 是用来做简化开发的，单一项目
SpringCloud 做分布式微服务相关的，拆分大单体项目为小模块项目
2.Spring 概述 2.1 Spring framework 介绍 概述：spring 提供了基础框架，你不必关心框架细节，只需要专注于代码业务逻辑
优点：
组件化模块化的：通过很多模块与组件组合成 spring 应用，以后可以通过 Xml 或者注解的方式去操作
控制反转（ Inversion of Control (IoC) ）：传统创建对象都是通过认为的new 对象的方式，把控制创建对象的权利转交给Spring
依赖注入（Dependency Injection）：自动化的注入属性
3.模块 3.1 Spring 系统架构图 3.2模块介绍 Core Container：核心容器，是Spring 最核心的模块，以后用到的都依赖该模块实现
Aop：面向切面编程，目的是不改变原有代码的前提下对功能进行增强
Aspects：是Aop 具体实现
Data Access/Integration：数据层
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/780a070f714603329b0d19830b45b9dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c353d7a4b4a7a8809a54a6fb7cc5db2c/" rel="bookmark">
			软件测试 | websocket接口测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
WebSocket 是一种在单个 TCP 连接上进行全双工通信(Full Duplex 是通讯传输的一个术语。通信允许数 据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进 行信号的双向传输（ A→B 且 B→A ）。指 A→B 的同时 B→A，是瞬时同步的)的协议。
WebSocket 通信协议于 2011 年被 IETF 定为标准 RFC 6455，并由 RFC7936 补充规范。WebSocket API (WebSocket API 是一个使用WebSocket 协议的接口，通过它来建立全双工通道来收发消息) 也被 W3C 定为标准。
WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。
而 HTTP 协议就不支持持久连接，虽然在 HTTP1.1 中进行了改进，使得有一个 keep-alive，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。
但是在 HTTP 中 Request = Response 永远是成立的，也就是说一个 request 只能有一个response。而且 这个response也是被动的，不能主动发起。
websocket 常用于社交/订阅、多玩家游戏、协同办公/编辑、股市基金报价、体育实况播放、音视频聊 天/视频会议/在线教育、智能家居与基于位置的应用。
websocket 接口不能使用 requests 直接进行接口的调用，可以依赖第三方库的方式来实现调用，以下内 容介绍如何调用第三方库实现 websocket 的接口自动化测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c353d7a4b4a7a8809a54a6fb7cc5db2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4beb27a2576913d4f91528a74109b5d/" rel="bookmark">
			LocalDateTime获取当天、本周、本月的开始和结束时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LocalDateTime获取当天、本周、本月的开始和结束时间、年总天数和年总周数 // 获取当天日期 LocalDate now = LocalDate.now(); // 当天开始时间 LocalDateTime todayStart = now.atStartOfDay(); // 当天结束时间 LocalDateTime todayEnd = LocalDateTime.of(now, LocalTime.MAX); // 周一 LocalDate monday = now.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)); // 周日 LocalDate sunday = now.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY)); // 本周开始时间 LocalDateTime weekStart = monday.atStartOfDay(); // 本周结束时间 LocalDateTime weekEnd = LocalDateTime.of(sunday, LocalTime.MAX); // 本月1号 LocalDate firstDayOfMonth = now.with(TemporalAdjusters.firstDayOfMonth()); // 本月最后一天 LocalDate lastDayOfMonth = now.with(TemporalAdjusters.lastDayOfMonth()); LocalDateTime firstDayOfMonthStart = firstDayOfMonth.atStartOfDay(); LocalDateTime firstDayOfMonthEnd = LocalDateTime.of(lastDayOfMonth, LocalTime.MAX); // 年总天数 int lengthOfYear = now.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4beb27a2576913d4f91528a74109b5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b3332d9e5c213e92f9c4856341fa45/" rel="bookmark">
			【JESD204系列】三、JESD204B标准分层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JESD204B 作为一种分层规范，在规范中共定义了四个层，分别为应用层，传输层，数据链路层和物理层。各层分别执行各自的对应的功能，最终通过四个层的联合，将数据高速无误的进行传输。
【JESD204系列】三、JESD204标准分层 文章目录 1. 简介2. 分层简介2.1 应用层（Application Layer）2.2 传输层（Transport Layer）2.3 数据链路层（Data Link Layer）2.4 物理层（Physical Layer） 3. 总结3.1 数据帧输出路径3.2 发送端和接收端的逻辑功能 1. 简介 JESD204B与PCIE类似，其标准是一种分层规范，规范中的各层都有自己的功能要完成。如下图所示为JESD204B的分层框图。
下面就一一介绍各层完成的基本功能。
2. 分层简介 2.1 应用层（Application Layer） 应用层本身并不包含在协议标准之内，而是为了实现用户特殊配置，以及将原始数据映射成为规范格式之外的格式，而添加的一个层。对于需要以不同于N’（样本传输位数）的大小传输的数据，使用单独设计的应用层可以对其进行更加灵活且具有针对性的配置，将多个样本重新包装，从而降低通道速率，提高链路整体效率。值得注意的一点是，发送端和接收端的配置必须相同，才能进行正确的数据传输和接收。
2.2 传输层（Transport Layer） 传输层根据给定器件已定义的链路配置参数，决定如何包装来自ADC的数据，即LMFS参数配置，四个字母代表最主要的四个参数，收发两端协商好之后（ADC会将参数发给FPGA，双方会进行校验），就按规则进行组包和解包。 这些参数在初始通道对齐序列(ILAS)期间从ADC传输到FPGA。这些设置通过串行端口接口(SPI)配置，其设置ADC和FPGA上的寄存器值来定义链路配置参数。根据这些参数产生一个校验和并将其传输给接收器，以便接收器(FPGA)能够验证链路配置参数是否正确接收。通过链路传输的这些参数不是用于配置接收器，而是仅用于验证链路参数匹配。若检测到错误，FPGA将通过JESD204B规范的错误报告中定义的中断报告此错误。
数据在发送过程中首先要经过传输层，对于发送端来说，传输层要完成的任务是基于用户选择的链路参数，对转换器设备采样得到的原始数据进行打包组帧，从而映射成宽度为8bit 的特定格式数据，并根据链路参数中的相关参数，对数据进行控制位和尾位的添加，以满足映射后数据的格式要求。因此对接收端来说，传输层负责的主要功能就是对收到的数据进行对应的解帧处理，恢复成原始的数据。此外，根据协议规范，在传输层和数据链路层之间，还要有可选的加扰模块，按照特定算法对映射后的数据进行加扰。因此，相应的在接收端需要一个解扰模块，对发送端输出的数据流进行对应的解扰，使之恢复为未加扰的数据。用下图来大概说明一下传输层的作用，8个ADC通过一定的方式组合在4条链路中进行传输。
在传输层，一组样本或部分样本被分组成F个八位字节的帧。“帧”数据结构是指一组连续的八位字节(8b/10b 编码器的输出都是一个八位字节)，其中每个八位字节的位置都以帧对齐信号作为参考。“多帧”数据结构是指一组连续的帧，其中每个多帧的位置都以多帧对齐信号作为参考。在许多应用中，帧时钟将具有与采样时钟相同的频率。JESD204 协议允许在每个帧周期内每个转换器传输多个采样，S 必须总是整数，这样可以最小化SERDES 电路和敏感模拟部件之间的串扰。每个采样作为一组N’比特发送，由N 个数据比特，可选控制比特和可选尾部比特组成。在帧的结尾处的附加尾比特是必需的，这样可以在每个帧周期中填充每个通道使比特总数为整数个八位字节。
数据映射相关链路配置参数的意义与取值范围如表1 所示。
参数名含义取值范围M每个设备中的转换器数1-256L每个转换器链路的通道数1-32F每个帧中的字节数1-256S每帧中每个转换器的采样点数1-32N转换器分辨1-32N’每个采样的总比特数1-32K每个多帧中帧的数量1-32CF每个链路每个帧周期的控制字数量0-32CS每个采样的控制比特数0-3HD高数据密度模式使能0-1 表1. 链路配置参数含义及取值范围 2.3 数据链路层（Data Link Layer） 数据链路层主要是完成链路建立和数据编码，该层的主要功能即为建立传输链路，对数据进行传输。数据链路层层接受并行成帧数据（包含ADC样本、控制位和结束位），并输出8B/10B字，后者在物理层中进行串行化且可以加扰。传输过程包含以下几个环节，即代码组同步（CGS），初始通道对齐序列（ILAS），用户数据传输（DATA），每阶段具体功能下面将进行具体说明。在本层中还包含8B/10B 编码模块，功能是将打包形成的8bit 数据采取8B/10B 编码的处理，使传输保持直流平衡，从而使CDR（Clock Data Recovery）电路的设计更加简单。并且通过使用8B/10B 编码方式的几种控制字符，如字符/K/、/A/等，实现对多通道的同步对齐和检测。因此，接收端需要对应的8B/10B 解码模块，对发送端生成的10bit 编码数据恢复为8bit 数据，且通过其中包含的控制字符，实现检错和对齐等功能。
数据链路层通过链路建立过程同步JESD204B链路。链路建立包括三个不同阶段：代码组同步（CGS）、初始通道同步（ILS）、传输用户数据。
1.代码组同步（CGS）
根据JESD204B 协议规定，代码组同步是链路建立的第一个步骤，并且不进行加扰，代码组同步主要有以下几个步骤，值得注意的是，以下步骤对于单发射端-单接收端和多发射端-多接收端两种情况均适用。首先，接收端通过拉低SYNC 信号发起同步请求，进入代码组同步（Code Group Synchronization，CGS）阶段。发射端开始发送连续的/K/=/K28.5/字符，各接收器（FPGA）必须利用时钟和数据恢复（CDR）技术，在ADC传来的输入数据流中找到K28.5字符。一旦在所有链路通道上检测到某一数量的连续K28.5字符，接收器模块就会解除置位送至发送器模块的SYNC~ 信号。在发送端捕获到SYNC~ 的变化后，JESD204A和JESD204B的处理会略有不同。在JESD204A中，发送模块捕捉SYNC~ 信号的变化，经过固定数量的帧时钟之后，ILAS就会启动。在JESD204B中，发送模块捕捉SYNC~ 信号的变化，并在下一个本地多帧时钟（LMFC）边界上启动ILAS。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b3332d9e5c213e92f9c4856341fa45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c67638b6b44495e00dc3588e5fc7847/" rel="bookmark">
			递归——汉诺塔问题（结合代码理解，终于懂了）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 汉诺塔问题是一个经典的递归问题，汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子， 在一根柱子上从下往上按照大小顺序摞着 64 片圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一 根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。问要怎么移动圆盘？
​ 图1 汉诺塔
递归思想 ​开始说汉诺塔问题之前，我们先来回顾一下递归的主要思想。
​递归的关键思想有两个：
递归找到边界条件（结束条件），一般作为if语句中的判断条件。递归最后一层和其前一层或者是和其他层的关系（即递归的规律）用什么样的关系式来表达，一般作为else语句中的方法体（执行语句）。 ​这样说可能听着有点晕，举个例子，如递归中的阶乘问题：
//factorial阶乘 public int factorial(int n){ if(n == 1){ return1; }else{ return factorial(n - 1) * n; } } 这里的n == 1就是阶乘递归的边界条件（结束条件），如果没有结束条件，那么程序就会陷入无限递归过程中，直到栈溢出。递归的过程和二叉树这种数据结构有点类似，可以通过二叉树来理解递归如何将一个复杂的问题分解成若干个简单的子问题。递归实际上是将一个复杂的原问题（二叉树的根节点）一步步分解成一个个简单容易求解的子问题（二叉树的子孙节点），然后到达边界条件（结束条件），最后将求解的一个个子问题通过递归回溯联系起来，一层一层地回到二叉树的根节点，最终求解出原问题。在递归的过程中要注意，不要试图去跟踪复杂的递归过程，只要找出递归的规律即可，即递归的关系表达式，也就是说要完成最后一步，那在完成最后一步的前一步要做什么，要懂得化繁为简，例如我们在求funtion（n）的时候，就假设funtion（n -1）的结果已经求出来了（通过递归回溯求出来的），这样问题简单得多，就好解决多了。
尝试 ​在正式讲解汉诺塔问题之前，最好自己去玩一玩，看能不能找出其中的规律，如果五个圆盘玩不了，那就那叠三个圆盘来玩一玩，总之，一定要去玩一玩，并试着去找出规律，才会理解下面是在讲什么。
定义 在该汉诺塔问题中，假设是从A柱上将所有的圆盘移动到C柱上。图1中五个圆盘从上到下分别用1,2,3,4,5来表示，如1圆盘，2圆盘。开始柱是指开始移动前存放n个圆盘的柱子，中转柱是指中间状态存放（n - 1）个盘子的柱子，目标柱是指n个盘子最终要移动到的柱子。以图1中五层汉诺塔为例，要将A柱（塔）上的五个圆盘移动到C柱（塔）上，则A柱为开始柱，有五个圆盘；B柱为中转柱，在中间状态的时候存放了1-4圆盘（共四个圆盘）；C柱为目标柱，是五个圆盘最终存放的柱子。值得注意的是，这里的开始柱、中转柱和目标柱并不是固定一成不变的，而是会随着圆盘的移动而动态变化的。如果这里听着有点迷糊，那就接着往下看，回过头来就会恍然大悟了。 汉诺塔（递归）规律 可以很容易找出递归的结束条件，假设A柱上只有一个圆盘，那么直接从A柱上移动一个圆盘到C柱上，即结束条件为当n==1时，从A柱上移动一个圆盘到C柱上。我们需要将要移动的圆盘分为两部分，其中将最大的一个圆盘作为一部分，称为下部分；其他的圆盘看作一个整体作为另一部分，称为上部分。以在五层汉诺塔中将A柱上的五层圆盘移动到C柱上为例，将A柱上的五层圆盘分成两个部分，其中将5圆盘（即最大的那一个圆盘）作为一部分，称为下部分；其他圆盘（即1-4圆盘，共四个圆盘）看作一个整体作为另一部分，称为上部分；五个圆盘要想从A柱（此时A柱为开始柱）上移动到C柱（此时C柱为目标柱）上，则上部分一定要放在B柱上（此时B柱为中转柱），A柱上就剩下 下部分了，就可以将下部分移动到C柱上，然后再将在B柱的上部分直接移动到C柱上就大功告成了。从这可以看出，在成功将A柱上五个圆盘移动到C柱上之前，上部分（其他四个圆盘）一定是放在中转柱上。在上述第2部分中，要将其他圆盘（即1-4圆盘，共四个圆盘）放在B柱上，则问题变成从A柱移动四个圆盘到B柱上。其中将4圆盘（即第四个圆盘）作为一部分，称为下部分；其他圆盘（即1-3圆盘，共三个圆盘）看作一个整体作为另一部分，称为上部分；四个圆盘要想从A柱（此时A柱为开始柱）上移动到B柱（此时B柱为目标柱）上，则上部分一定要放在C柱上（此时C柱为中转柱），A柱上就剩下 下部分了，就可以将下部分移动到B柱上，然后再将在C柱的上部分直接移动到B柱上就大功告成了。从这可以看出，在成功将A柱上四个圆盘移动到B柱上之前，上部分（其他三个圆盘）一定是放在中转柱上。以此类推。 结合代码来理解 tower.move(5, 'A', 'B', 'C'); //num 表示要移动圆盘的个数，a，b，c只是变量名，本身不表示任何的柱，只有在参数传递时，传进什么柱便表示什么柱，例如 //move(4, 'A', 'C', 'B')，则a表示A柱，b表示C柱，c表示B柱。 public void move(int num , char a, char b ,char c) { //在move(int num , char a, char b ,char c)中，a为开始柱,b为中转柱，c为目标柱。 //如果只有一个盘 num = 1 if(num == 1) { //从开始柱移动到目标柱 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c67638b6b44495e00dc3588e5fc7847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/373c771d2fb9ccd29cdab6256d6f636d/" rel="bookmark">
			字符指针变量和字符数组的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中，字符指针变量和字符数组都可以用来存储一串字符。但是，它们之间有以下几个区别：
内存分配方式不同：字符数组在定义时需要指定数组的长度，内存空间在编译时就被分配了；而字符指针变量在定义时只分配了一个指针变量的内存空间，指向字符串常量或者动态分配的内存空间。
大小可变性不同：字符数组的大小是固定的，无法动态改变；而字符指针变量可以通过重新指向不同的内存地址来改变其大小。
初始化方式不同：字符数组可以通过直接赋值的方式进行初始化；而字符指针变量可以通过指向字符串常量或者动态分配的内存空间来进行初始化。
使用方式不同：字符数组可以直接作为函数参数传递，而字符指针变量需要先分配内存空间，并且要注意内存管理问题。
tip:
不可以对数组名赋值。
字符指针变量指向字符串常量时，内容不可以修改。(例: char *str="aaa"; str[2]='b'; 【报错】)
综上所述，字符指针变量和字符数组都有自己的优点和缺点，需要根据具体的情况来选择使用哪一种。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/170/">«</a>
	<span class="pagination__item pagination__item--current">171/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/172/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>