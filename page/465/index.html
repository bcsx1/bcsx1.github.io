<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08803cc297fbe3458b5df70ae77df5d0/" rel="bookmark">
			Python安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python安装 Anaconda3安装运行 Python下载软件安装外加模块安装以requests库为例错误安装示范 PyCharm设置解释器路径 Anaconda3 小编以为去官网安装好python就完事大吉了，但是要完成各种功能还得安装一堆package。
安装 Anaconda3就根本！没有！装一堆package的烦恼！Anaconda爸爸都自带好了，新手绝对够用。
安装 Anaconda官网安装
小编这样的新手建议安装3.7版本~毕竟新版更香，而且目前不存在2版本代码转3的需求。
运行 最重要的是，用Anaconda可以同时看到编译界面和Python Shell (比如打印个图，然后显示的窗口！)，妈妈再也不用担心我在IDLE和编译器间狂切了！
Python 下载 首先当然是官网下最新的Python(小编安装的时候是3.7版)
链接: https://www.python.org/downloads/windows/.
软件安装 可以选Customized,然后自己选择一个路径（后果就是很多教程里的默认没法用啦，得自己摸索（哭））
注意一定得把Add to PATH 勾上，不然你就重装吧
安装路径 ，C盘比较爆的可以在安装时选Customized，盘排序越靠前越好；
一定记得创建一个独立文件夹安装，而且文件夹名不能改，否则后期用官方python-3.7.4-amd64.exe修复或卸载时会出错 Add to PATH 这个一定要勾上，不然你就重装吧；
图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；
全新的 KaTeX数学公式 语法；
增加了支持甘特图的mermaid语法1 功能；
增加了 多屏幕编辑 Markdown文章功能；
增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；
增加了 检查列表 功能。
外加模块安装 以requests库为例 用cmd运行
win10家庭版在搜索栏输“命令提示符”，打开其所在文件位置，复制"命令提示符”到python安装的文件夹下，重命名为python_cmd
修改cmd默认路径
右键属性–&gt;快捷方式–&gt;起始位置
如下我的python安装目录为“E:\python_3.7.4”，我在起始位置就设成这个
应用完再打开就可以了
3.用cmd调用pip安装
python自配的安装程序在安装文件的子目录Scripts下，需要先在cmd里切换路径，如何切换详见：命令提示符窗口切换路径
pip install xxx (注意注意注意不用打开python!!!) CD Scripts
pip install requests
等一会requests库就安装好了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08803cc297fbe3458b5df70ae77df5d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b4a971c4d91917433ee9e475621b089/" rel="bookmark">
			Retrofit网络请求之注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过一篇关于retrofit的笼统介绍，但是碍于当时对于retrofit了解不多，很多东西都是一带而过，
没有讲明白，在接下来的文章中将陆续介绍转换器、注解、拦截器、Call与Observable的区别
本篇首先介绍注解，我们先来给注解分一下类：
a. @GET、@POST、@PUT、@DELETE、@HEAD----&gt;&gt;&gt;&gt;&gt;&gt;网络请求方法
示例：
@GET(“article/list/{page}/json”)
Observable&lt;BaseResponse
&gt;article_list(@Path(“page”)int page); b. @HTTP
作用：替换@GET、@POST、@PUT、@DELETE、@HEAD注解的作用 及 更多功能拓展
具体使用：通过属性method、path、hasBody进行设置：
method：网络请求的方法（区分大小写）
path：网络请求地址路径
hasBody：是否有请求体
@HTTP(method = “GET”, path = “blog/{id}”, hasBody = false)
Call getCall(@Path(“id”) int id);
{id} 表示是一个变量
method 的值 retrofit 不会做处理，所以要自行保证准确
c. @FormUrlEncoded
表示请求体是一个Form表单，发送form-encoded的数据
通常跟@Field &amp; @FieldMap和@Query和@QueryMap注解配合使用，只不过前者用于Post请求 后者用于Get请求
表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）:
@POST("/form")
@FormUrlEncoded
Call testFormUrlEncoded1(@Field(“username”) String name, @Field(“age”) int age);
d. @Multipart
作用：表示请求体是一个Form表单，发送form-encoded的数据（适用于有文件上传的场景）
通常跟@Part &amp; @PartMap注解配合使用
Part 后面支持三种类型:RequestBody、okhttp3.MultipartBody.Part} 、任意类型
除 okhttp3.MultipartBody.Part 以外，其它类型都必须带上表单字段okhttp3.MultipartBody.Part中已经包含了表单字段的信息
@POST("/form")
@Multipart
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b4a971c4d91917433ee9e475621b089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177e84c34a1732a75b090865e139d8e7/" rel="bookmark">
			fastjson解析json字符串和数组&#43;Scala时间处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说直接上代码
1.Json解析
package scala.csdn import com.alibaba.fastjson.JSON object ParseJson { def main(args: Array[String]): Unit = { //解析json字符串 val jsonStr = "{\"name\":\"Michael\"}" val parseJson = JSON.parseObject(jsonStr) val name = parseJson.getString("name") println(s"解析出的名字是：$name") //解析json数组 val jsonArray = "[{\"name\":\"Andy\", \"age\":30},{\"name\":\"Justin\", \"age\":19}]" val parseJsonArray = JSON.parseArray(jsonArray) //遍历 for (i &lt;- 0 until parseJsonArray.size){ val jsonObject = parseJsonArray.getJSONObject(i) val name = jsonObject.getString("name") val age = jsonObject.getInteger("age") println(s"$name's age is $age") } } } 2.时间处理
package scala.csdn import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177e84c34a1732a75b090865e139d8e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a955cbd4188236a94bcf706bb4a51b4f/" rel="bookmark">
			linux xampp网站搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 由于原高配服务器到期，为防止原域名悬空，我们团队决定在备用服务器上搭建法规宝平台。原备用服务器上的阴阳师悬赏封印计算功能暂停服务，服务时间另行通知。
之前为了方便配置，我们一直使用Windows服务器，备用服务器是linux系统，因此我们借此机会，介绍一下linux机上的网站部署。我们的原网站是采用PHP+MySQL的结构，因此就以该结构为例
2.搭建服务器环境 我们采用的环境是Linux + Apache + MySql + PHP的结构。说实话，传说Nginx不知道比Apache好多少倍，但是由于我水平所限，只能暂时采取Apache提供服务。
1）下载xampp xmapp是一个集成工具，其中x代表了平台，如w/l（分别对应Windows和linux），m代表mysql，a代表Apache服务器，两个p分别代表PHP和Perl。我们可以使用wget命令下载文件，将其下载到opt文件夹下
wget /opt https://www.apachefriends.org/xampp-files/5.6.36/xampp-linux-x64-5.6.36-0-installer.run 2）安装 接着为之赋权，使之可执行
chmod 777 xampp-linux-x64-5.6.36-0-installer.run 然后进行安装
./xampp-linux-x64-5.6.36-0-installer.run 3）启动lampp 安装完成后，就可以运行了
sudo/opt/lampp/lampp start 启动后，可以从外部访问站点，看到以下界面则为成功
3.配置网站目录 首先我们把php项目目录传输到服务器上，这里建议使用winscp工具进行传输，简单方便。途中红框为工程目录的压缩文件
这里我们需要对其进行解压，需要unzip工具，服务器上没有unzip工具，我们需要安装一下
yum install unzip 然后解压。
unzip laws.zip 解压完成，得到工程文件夹
我们的工程是thinkPHP的，所以其入口目录实在这个laws下面的public文件夹下。下面我们就开始配置网站目录。
配置目录只需要修改lampp里面的etc下的httpd.conf文件。
我们用vim打开这个文件
vim /opt/lampp/etc/httpd.conf 接着我们搜索documentroot,在Vim中输入
/DocumentRoot 我们轻易找到了documentroot的位置
原来的配置是指向阴阳师悬赏封印计算机的工程目录的，我们把它改为法规宝。注意，红字的两处都要修改。
在xampp体系中，任何修改Apache httpd.conf配置文件的操作，都必须重启服务才能生效。
sudo /opt/lampp/lampp restart 4.常见问题 我们再次访问，发现网站可以访问，但报了个错。
错误的来源在于thinkPHP框架试图写入某个文件但被拒绝了。原来默认的thinkPHP中的缓存文件拿到linux环境下，默认状态是不可写入的，所以我们需要找到这个缓存文件对其进行授权。按照报错提示，文件位于runtime文件夹下的temp下。
事实上，runtime文件夹中有3个文件夹
[root@izuf672gtixudsi85wvxz6z runtime]# ll total 12 drwxrwxrwx 2 root root 4096 Aug 28 19:47 cache drwxrwxrwx 8 root root 4096 Aug 28 20:39 log drwxrwxrwx 2 root root 4096 Aug 28 20:42 temp 偷懒起见，我们可以吧这三个文件夹都授权为777
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a955cbd4188236a94bcf706bb4a51b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad303181d821cb748bf7c4b7209f8d7e/" rel="bookmark">
			centos 7 使用firewalld  关闭和打开防火墙 及开放指定端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、firewalld的基本使用
启动： systemctl start firewalld
关闭： systemctl stop firewalld
查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld
开机启用 ： systemctl enable firewalld
2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。
启动一个服务：systemctl start firewalld.service
关闭一个服务：systemctl stop firewalld.service
重启一个服务：systemctl restart firewalld.service
显示一个服务的状态：systemctl status firewalld.service
在开机时启用一个服务：systemctl enable firewalld.service
在开机时禁用一个服务：systemctl disable firewalld.service
查看服务是否开机启动：systemctl is-enabled firewalld.service
查看已启动的服务列表：systemctl list-unit-files|grep enabled
查看启动失败的服务列表：systemctl --failed
3.配置firewalld-cmd
查看版本： firewall-cmd --version
查看帮助： firewall-cmd --help
显示状态： firewall-cmd --state
查看所有打开的端口： firewall-cmd --zone=public --list-ports
更新防火墙规则： firewall-cmd --reload
查看区域信息: firewall-cmd --get-active-zones
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad303181d821cb748bf7c4b7209f8d7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e4233532665e411ecc3d8ef46cec841/" rel="bookmark">
			使用vue&#43;echarts快速进行全国地图与各省市地图联动(下沉)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目源码附js/json地图数据（下载项目源码后请使用Npm install 来安装相关依赖）
效果 使用前请使用npm(cnpm)安装echarts，详情见官网。
本文作为笔记demo只引入5个省(市)，根据需求可以引入更多。
main.js // The Vue build version to load with the `import` command // (runtime-only or standalone) has been set in webpack.base.conf with an alias. import Vue from 'vue' import App from './App' import router from './router' import echarts from 'echarts' Vue.prototype.$echarts = echarts Vue.config.productionTip = false import '../node_modules/echarts/map/js/province/beijing.js' // 引入北京地图数据 import '../node_modules/echarts/map/js/province/fujian.js' // 引入福建地图数据 import '../node_modules/echarts/map/js/province/anhui.js' // 引入安徽地图数据 import '../node_modules/echarts/map/js/province/xinjiang.js' // 引入新疆地图数据 import '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e4233532665e411ecc3d8ef46cec841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f90d6f5c81153d3a94fab4af858d0a8b/" rel="bookmark">
			react 构建后 tomcat服务部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		react 构建后tomcat服务部署 在项目下执行npm run build ,生成构建后的部署文件 build目录文件
将该文件放置到本地tomcat 的运行目录下myapp ,myapp 里面内容为build目录下内容。
tomcat下server.xml配置 服务访问host name ,ip,context的docBase
启动tomcat,访问服务
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6962e9c193ae817e146952e25658912c/" rel="bookmark">
			stm32无法进入串口接收中断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
发送时一切正常。接收时，中断方式无法进入中断，轮询方式检测不到标志位。在确认代码没问题后开始检查电路，最终找到了原因。问题为IO口外部已经接了一个MAX3232芯片，而测试时又是直接从IO口跳线出来接到usb转串口芯片上进行测试，两个芯片接收信号连在一起存在干扰。
解决办法 :
只选用一种通信方式，因为我这边没有usb转232的数据线，所以选择了拆掉MAX3232的芯片。
转载于:https://www.cnblogs.com/zwj412/p/11422186.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/128e191a0d9bb1b5d19077ff9d6699c2/" rel="bookmark">
			ethtool网路工具内核解析流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##内核ethtool工具源码解析
###背景
用户态使用ethtool工具设置网口的模式（速率，双工，协商）时，发现设置的内容和读取的内容是不一
致的，以此问题为出发点，跟踪下内容ethtool的处理流程。
用户态设置网口模式的方法是 linux c通过socket打开网口，封装ethtool_cmd和ifreq结构体，然后ioctl逐步陷入内核中。
###用户态代码
struct ifreq ifr; struct ethtool_cmd *ethtool = NULL; strncpy(ifr.ifr_name, priv_data-&gt;eth_name, ethlen); ifr.ifr_data = (void *)ethtool; ethtool-&gt;cmd = ETHTOOL_SSET; ethtool-&gt;speed = mode-&gt;speed; ethtool-&gt;autoneg = mode-&gt;autoneg; ethtool-&gt;duplex = mode-&gt;duplex; ethtool-&gt;phy_address = phy_addr; ethtool-&gt;advertising = MII_BCMR_ADVERTIS; ret = ioctl(priv_data-&gt;mac_fd, SIOCETHTOOL, &amp;ifr); ###内核解析流程
[ 133.060870] [&lt;ffff00000866124c&gt;] phy_ethtool_sset+0x24/0x130 [ 133.066528] [&lt;ffff000008851348&gt;] dpa_set_settings+0x64/0x90 [ 133.072099] [&lt;ffff0000089e6064&gt;] ethtool_set_settings+0x104/0x110 [ 133.078190] [&lt;ffff00000887d65c&gt;] dev_ethtool+0x17fc/0x1bb0 [ 133.083674] [&lt;ffff00000889188c&gt;] dev_ioctl+0x31c/0x608 [ 133.088809] [&lt;ffff000008852fc0&gt;] sock_do_ioctl+0x70/0x88 [ 133.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/128e191a0d9bb1b5d19077ff9d6699c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb3a32d34a457ac67904bd7acd200a01/" rel="bookmark">
			【编程思想】什么是微服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 首先看一下什么是DevOPS
https://blog.csdn.net/bjweimengshu/article/details/79031552
2 什么是微服务
https://my.oschina.net/yu120/blog/661488
微服务架构
微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP协议的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。
因此，微服务核心为：
小, 且专注于做⼀件事情
独立的进程中
轻量级的通信机制
松耦合、独立部署
3 购物车页面中的微服务思想
https://my.oschina.net/CraneHe/blog/703177
未完待续……………………
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5997e3d79b1358a75b692d7421c642a/" rel="bookmark">
			一个7,8年的phper学习java之路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 一个7,8年的phper学习java之路
在https://www.iteye.com/blog/user/chenhaibo0806999上写了6,7年的博客(共96篇文章，访问量近80000)，最近准备开始在这个上写博客了，这个是处女作品，希望以后的编程之路顺利！之前用python写过图形报表，爬虫，后台搭建觉得python和PHP很像至少很简洁但速度没PHP快。3,4个月前做了一个决定努力学习java给自己10个月的时间然后转行做java，因为精通mysql/前端(HTML/CSS/javascript/jquery/vue)/linux所以只需要把java的东西学好，这对于工作7,8年的老司机来说应该问题不大；
6,7月份开始学习java的基础(比如语法，程序包，泛型等)并总结文档，最近在看JDBC/serlet/JSP，就将就和spring mvc一起搞，因为有8年工作经验就没有看网上的视频但看了两遍文档并记录记忆，直接开搞，一路的摸索尝试解决各种坑和bug，那是相当的累，今天的主题很简单：JDBC来写个增删改查，并简单的封装(OOP思想不能丢，对吧)，第一次在这上面写可能写的不好请大家多多包涵和指点！
JDBC的增删改查并封装
软件及工具：
JDK 1.8；
mysql驱动：8.0.11
IDEA编辑器
tomcat ：7.0.9
maven：3.6.1
直接上代码吧，封装前的，调试通过了，差不多每行都有注释吧-----------------------------
package com.example.chen.demo.controller;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import java.sql.*;
public class HandleSql {
static Connection con; //声明 Connection 对象
static PreparedStatement pStmt;//声明预处理 PreparedStatement 对象
static ResultSet res;//声明结果 ResultSet 对象
//IDEA右边Database链接数据库 一定要加 "?serverTimezone=GMT" 否则会报错
static String url = "jdbc:mysql://localhost:3306/test?serverTimezone=GMT&amp;characterEncoding=utf-8";
static String user = "root";
static String password = "root";
public Connection getConnection() {//建立返回值为 Connection 的方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5997e3d79b1358a75b692d7421c642a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b95095547d3b3d169b707f77ab36ecf2/" rel="bookmark">
			通过FCN进行高低肩识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先说明对于人的坐姿是否端正，需要就行高低肩识别，
算法流程
1：通过语义分割算法实现人的分割提取（enet，pspnet,fcn,unet等，我们这里使用fcn，因为从c++可以调用呀）
2：图像填充
3;左右肩斜率计算
1：c++显示fcn.
需要的文件有pascal-classes.txt，fcn8s-heavy-pascal.prototxt，这两个文件是在opencv-3.4.1的源码中，其它版本有没有，我不知呀。
另外的一个文件是fcn的模型文件fcn8s-heavy-pascal.caffemodel，这个需要单独下载，可以去我的资源里下载（包含上面的两个文件）
直接上代码
#include&lt;opencv2/opencv.hpp&gt; #include&lt;opencv2/dnn.hpp&gt; #include&lt;iostream&gt; using namespace cv; using namespace std; using namespace cv::dnn; const size_t width = 500; const size_t height = 500;//定义图像文件宽高 vector&lt;Vec3b&gt; labels_color(); string label_file = "F:/fcn/pascal-classes.txt"; string deploy_file = "F:/fcn/fcn8s-heavy-pascal.prototxt"; string model_file = "F:/fcn/fcn8s-heavy-pascal.caffemodel"; int main(int argc, char **argv) { Mat src = imread("F:/fcn/FT20A1180801279223.jpg"); if (!src.data) { cout &lt;&lt; "图像文件未找到!!!" &lt;&lt; endl; return -1; } resize(src, src, Size(500, 500), 0, 0); vector&lt;Vec3b&gt;colors = labels_color(); Net net; net = readNetFromCaffe(deploy_file, model_file);//读取二进制文件和描述文件 float t1 = getTickCount(); Mat inputblob = blobFromImage(src); net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b95095547d3b3d169b707f77ab36ecf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/502758a4686dc85de4ab10bd47ff9378/" rel="bookmark">
			第20节  信息化基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第20节 信息化基础知识
信息化基础知识
1[单项选择题]以下对信息系统集成的描述不正确的是（ ）。
A信息系统集成包括总体策划、设计、开发、实施、服务及保障
B信息系统集成主要包括设备系统集成和应用系统集成
C信息系统集成是具有高技术含量的工程过程，要面向用户需求提供全面解决方案
D信息系统集成工作的核心是满足用户要求，管理和商务活动是系统集成项目实施成功的保证
【参考答案】D
【题目解析】根据《系统集成项目管理工程师教程》第3.1小节的内容可知，系统集成是指将计算机软件、硬件、网络通信等技术和产品集成为能够满足用户特定需求的信息系统。包括总体策划、设计、开发、实施、服务及保障。信息系统集成有以下几个显著特点：(1)信息系统集成要以满足用户需求为根本出发点。(2)信息系统集成不只是设备选择和供应，更重要的是，它具有高技术含量的工程过程，要面向用户需求提供全面解决方案，其核心是软件。(3)系统集成的最终交付物是一个完整的系统而不是一个分立的产品。(4)系统集成包括技术、管理和商务等各项工作，是一项综合性的系统工程。技术是系统集成工作的核心，管理和商务活动是系统集成项目成功实施的保障。根据上述内容可知，选项D的说法不正确的，因此应选D。
2[单项选择题]A公司承接了一项信息系统升级任务，用户对文档资料标准化要求比较高并委派固定人员与A公司进行配合，要求在他们现有的信息系统（该系统是A公司建设的）基础上扩充一个审批功能，该公司最适用采用（）进行开发
A结构化方法 B原型法 C面向对象方法 D螺旋模型
【参考答案】A
【题目解析】结构化方法方法具有如下特点。（1）遵循用户至上原则。（2）严格区分工作阶段，每个阶段有明确的任务和取得的成果。（3）强调系统开发过程的整体性和全局性。（4）系统开发过程工程化，文档资料标准化。该方法的优点是：理论基础严密，它的指导思想是用户需求在系统建立之前就能被充分了解和理解。由此可见，结构化方法注重开发过程的整体性和全局性。
3[单项选择题] 以下关于信息属性的描述，错误的是（） 。
A信息具有真伪性，真实是信息的中心价值，不真实的信息价值可能为负
B信息具有滞后性，信息是数据加工的结果，因此信息必然落后于数据，加工需要时间
C信息具有扩压性，信息和实物不同，它可以扩散也可以压缩
D信息具有完全性，我们能够获取客观真实的全部信息，从而进行判断
【参考答案】D
【题目解析】信息是反应客观世界中各种事物特征和变化的知识，是数据加工的结果，信息是有用的数据。信息具有存在的普遍性；载体依附性；有序性；相对性；可度量性；可扩充性；可压缩性；可存储、传输与携带性；可替代性；可扩散性；可共享性；时效性等重要性质。 信息具有真伪性，真实是信息的中心价值，不真实的信息价值可能为负。 信息具有滞后性，信息是数据加工的结果，因此信息必然落后于数据，加工需要时间。 信息的时效性是指信息的效用依赖于时间并有一定的期限，其价值的大小与提供信息的时间密切相关。实践证明，信息一经形成，所提供的速度越快，时间越早，其实现价值越大。 信息的共享性是指信息作为一种资源，不同个体或群体在同一时间或不同时间均可使用这种资源。 信息具有扩压性，信息和实物不同，它可以扩散也可以压缩。
4[单项选择题]在开发一个系统时，如果用户对系统的目标是不很清楚，难以定义需求，这时最好使用 （ ） 。
A原型法 B瀑布模型 CV-模型 D螺旋模型 【参考答案】A
【题目解析】在开发一个系统时，如果用户对系统的目标不很清楚，难以定义需求，这时最好使用原型法的系统开发方法。应用原型法的主要目的就是获取需求。使用原型法，在用户的共同参与下可以改善和加快需求获取过程。其第一步是建造一个快速原型，实现客户或未来的用户与系统的交互，用户或客户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足客户的要求，开发人员可以确定客户的真正需求是什么。第二步则在第一步的基础上开发客户满意的软件产品。显然，快速原型方法可以克服瀑布模型的缺点，减少由于软件需求不明确带来的开发风险，具有显著的效果。选项B的“瀑布模型”，是一种将按软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等6个基本活动，并且规定了它们自上而下、相互衔接的固定次序的系统开发方法。瀑布模型强调文档的作用，并要求每个阶段都要仔细验证。选项C的“V-模型”，是一种典型的测试模型。该模型通常会在其开始部分对软件开发过程进行描述，其中通过单元测试检测代码的开发是否符合详细设计的要求；集成测试检测各单元代码是否能完好地结合到一起，是否符合概要设计阶段提出的要求；系统测试检测已集成在一起的产品是否符合系统规格说明书的要求；而验收测试则检测产品是否符合最终用户的需求。对于选项D的“螺旋模型”，是指将瀑布模型和快速原型模型结合起来，强调风险分析的一种开发模型。
5[单项选择题]信息标准化是解决信息孤岛的重要途径，也是不同的管理信息系统之间数据交换和互操作的基础。作为信息化标准的一项关键技术，目前流行的（ ）以开放的自我描述方式定义了数据结构，在描述数据内容的同时能突出对结构的描述，从而体现出数据之间的关系。这样组织的数据对于应用程序和用户都是友好的、可操作的。
A可扩展标记语言（XML）
B超文本标记语言（HTML）
C通用标记语言（GML）
DWeb服务描述语言（WSDL）
【参考答案】A
【题目解析】xml可扩展标记语言，用来存储数据和平台交换数据
6[单项选择题]商业智能（BI）的核心技术是逐渐成熟的数据仓库(DW)和（ ）。
A联机呼叫技术 B数据整理（ODS）技术
C联机事务处理（OLTP）技术 D数据挖掘（DM）技术
【参考答案】D
【题目解析】商业智能也称作BI，是英文单词Business Intelligence的缩写。商业智能通常被理解为将企业中现有的数据转化为知识，帮助企业做出明智的业务经营决策的工具口这里所谈的数据包括来自企业业务系统的订单、库存、交易账目、客户和供应商等来自企业所处行业和竞争对手的数据以及来自企业所处的其他外部环境中的各种数据。而商业智能能够辅助的业务经营决策，既可以是操作层的，也可以是战术层和战略层的决策。为了将数据转化为知识，需要利用数据仓库、联机分析处理(OLAP)工具和数据挖掘等技术。
7[单项选择题]构建电子商务平台是当前一种重要的商业模式，任何希望从事电子商务的公司或个人可以通过注册商铺的形式在该平台上从事电子商务活动。从技术角度来看，该平台属于（） 服务模式。
AIaaS BDaaS
CSaaS DPaaS
【参考答案】C
【题目解析】任何希望从事电子商务的公司或个人可以通过注册商铺的形式在该平台上从事电子商务活动。说明是使用的这个平台的软件从事相关经营活动。SaaS(Software-as-a- Service)：软件即服务。它是一种通过Internet提供软件的模式，用户无需购买软件，而是向提供商租用基于Web的软件，来管理企业经营活动。云提供商在云端安装和运行应用软件，云用户通过云客户端（通常是 Web 浏览器）使用软件。云用户不能管理应用软件运行的基础设施和平台，只能做有限的应用程序设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/502758a4686dc85de4ab10bd47ff9378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/536479013835758b37ebb59825ecd16a/" rel="bookmark">
			Object not found!  The requested URL was not found on this server.... 报错解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器（centos6.5） lnmp
报错如下
Object not found!
The requested URL was not found on this server. The link on the referring page seems to be wrong or outdated. Please inform the author of that page about the error.
If you think this is a server error, please contact the webmaster. Error 404
看提示是URL地址错误。原因是没有设置服务器地址重写，或者是设置了.htaccess文件，但没有打开重写功能。
解决办法是增加一个.htaccess文件，里面加上重写规则
1.找到/opt/lampp/etc（根据自身所在位置） vi httpd.conf看看是否开启了url_rewrite模块，也就是httpd.conf LoadModule rewrite_module modules/mod_rewrite.so 将前面的#去掉，如果没有这复制这段添加上去。
然后找到 AllowOverride all （默认是None ！！！这个很重要）
2.在所需要进行rewrite的web的主目录下添加.htaccess文件，添加上一句话：RewriteEngine on 然后补写上自己所需的所需规则。
转载于:https://www.cnblogs.com/kxcoder/p/11419155.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e197edfbb07224e9887b84a674feb492/" rel="bookmark">
			delete p和delete[] p的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.new、delete和malloc、free的区别 要谈delete p和delete []p的区别，首先介绍一下new/delete,free和malloc的区别。这一点在我这篇博客也有简单讲过。
在c语言中，malloc/free是用来负责动态申请/释放内存空间的，他们都是c中的库函数，而随着c++类和对象的出现，使得我们可以自定义数据类型，但是定义一个对象的时候会自动调用它的构造函数，在释放一个对象之前会自动调用它的析构函数，但是由于malloc和free都是库函数，都不在编译器的控制范围之内，编译器无法实现把执行构造函数和析构函数的任务强加给malloc和free，这就出现了new和delete了，new和delete的作用也是申请和释放内存空间，但是在执行new的时候会自动调用构造函数，执行delete的时候会调用析构函数。
2.delete p和delete[] p的区别 . delete p会调用一次析构函数，而delete[] p会调用每个成员的析构函数。看下面的代码：
class A { public: ~A() { cout &lt;&lt; "A的析构函数" &lt;&lt; endl; } }; int main() { A* pA = new A[10]; delete[]pA;//输出10次A的析构函数 //delete pA;//会出错，因为只析构了一次 A* pA1 = new A; delete pA1;//输出一次A的析构函数 //delete[] pA1;//编译器不会报错，但是系统会一直调用析构函数 int* pInt = new int[10]; delete[] pInt; //delete pInt;//不会出错 int* pInt1 = new int; delete pInt1; //delete[] pInt1;//不会出错 return 0; } 由上面的代码可以看出，delete[] p和delete p的区别在于他们对于非内部数据对象处理上，如果数组类型是自定义类，那么new[]只能用delete[]来对应，new和delete对应，但是对于普通数据类型而言，他们作用的效果是一样的，例如int* p=new int[10],delete p和delete[] p作用效果是一样的，原因是内部普通数据类型没有析构函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e197edfbb07224e9887b84a674feb492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b286040123ad1a4b77f49986f09d75/" rel="bookmark">
			Redis|Sentinel 高可用架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 前言 Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自懂切换。它的主要功能有:1 不时地监控redis是否按照预期良好地运行;2 如果发现某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端);3 能够进行自动切换。当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master,其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。
二 实践 本文介绍搭建主从复制以及三节点的sentinel 构建redis的高可用系统。其中 redis 一套主从 ，sentinel 三个节点 因为机器资源限制 ，两个sentinel 节点和 redis复用。
2.1 环境准备 Redis版本：Redis-3.2.8 OS 版本 CentOS 6 redis、sentinel 10.9.34.172 reids master 10.9.43.207 reids slave sentinel 10.9.34.252 sentinel 2.2 软件安装 wget http://download.redis.io/releases/redis-3.2.8.tar.gz tar zxvf redis-3.2.8.tar.gz mv redis-3.2.8 /usr/local/redis cd /usr/local/redis make PREFIX=/usr/local/redis install cd src &amp;&amp; make test 创建软连接
ln -s /usr/local/redis/bin/redis-cli /usr/local/bin/redis-cli ; ln -s /usr/local/redis/bin/redis-sentinel /usr/local/bin/redis-sentinel ; ln -s /usr/local/redis/bin/redis-server /usr/local/bin/redis-server ; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b286040123ad1a4b77f49986f09d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e7d9cb5adda17b2170031a972e77f6b/" rel="bookmark">
			第三期学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跌跌撞撞一年时间，终于开始写第三期了 ，其实这一期的内容早就有了，只不过一直没有放到博客上。不能停下学习的脚步，要继续前进呀！
1、JSON unmarshal map的结果是不确定的 测试代码：
package main import ( "encoding/json" "log" ) const str = `{"a":"aaaa","b":"baaa","c":100}` func main() { for i := 0; i &lt; 10; i++ { var m map[string]interface{} if err := json.Unmarshal([]byte(str), &amp;m); err != nil { log.Fatal(err) } for k, v := range m { log.Printf("k: %s, v: %v", k, v) } log.Println("--------------------------------------") } } 测试结果：
2、火焰图 火焰图(flame graph)是性能分析的利器，样子如下图所示
火焰图是基于perf结果产生的SVG图片，用来展示CPU的调用栈
y轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方就是它的父函数。
x轴表示抽样数，如果一个函数在x轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。
注意：x轴不代表时间，不是所有的调用栈合并后，按字母顺序排列的。
火焰图就是看顶层的哪个函数占据的宽度最大。只要有“平顶”，就表示该函数可能存在性能问题。颜色没有特殊含义，因为火焰图表示的是CPU的繁忙程度，所以一般选择暖色调。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e7d9cb5adda17b2170031a972e77f6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8477c0196b0668c07312f683c6dd26ff/" rel="bookmark">
			在WebStorm中用命令行创建vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前跟着视频教程用命令行创建过一次vue项目，过了一段时间以后再来从头创建竟然有点迷茫；接着在网上找了别人写的博客教程跟着创建，结果自己创建的过程中依然碰到了很多别人没有而自己却义无反顾踏入的坑，默默流下两行清泪 T_T。。。现在就来将创建的整个过程做一个总结记录，避免以后重蹈覆辙啦~
1. 准备工作 1.1 WebStorm 网上有很多WebStorm的安装教程，跟着安装基本没有什么太大问题。。。至于后面的激活，网上也有很多方法，经验之谈就是，一个没用再找一个，总会找到有用的办法啦，哈哈~
1.2 node.js node.js最好在官网下载，安装过程主要注意以下两点：
在安装过程中记得勾选 Add to Path 项，会自动帮你将node.exe的安装路径添加到环境变量中。 设置nodejs prefix（全局）和cache（缓存）路径：安装好node.js后，在node.js的安装路径下，新建node_global和node_cache两个文件夹
然后在命令行中进行配置
npm config set prefix "G:\Node_JS\node_global" npm config set cache "G:\Node_JS\node_cache" 设置成功后，之后用命令npm install XXX -g安装的模块都将安装在G:\Node_JS\node_global中
接下来，安装cnpm(淘宝镜像)，在cmd中输入：
npm install -g cnpm --registry=https://registry.npm.taobao.org 安装成功后，再在全局环境下安装vue，在cmd中输入：
npm install -g @vue/cli 最后，可在路径G:\Node_JS\node_global下，看到
2. 在WebStorm中用命令行创建vue项目 打开WebStorm,首先进行以下基础配置，否则在Terminal中输入cnpm、vue等会报错。打开File -&gt; settings -&gt;在搜索框中输入npm，然后进行如下图所述的配置
然后在WebStorm的Terminal中就可以通过输入
vue create XXX(项目名) 来创建vue项目啦~~如下图所示，以后的路就自己走啦 3.注意 按上述步骤，通过npm，安装全局cnpm和vue时，在cmd中输入cnpm -v，和 vue -V会被告知不是内部变量，要想通过cmd 访问通过npm安装的全局软件，需要在电脑的环境变量中加入node_global文件夹所在的位置呦~如下图所示。
我遇到的坑T_T:一开始我在电脑的环境变量中就加入了node_global文件夹所在的位置，但是我在WebStorm的Terminal中输入cnpm -v、vue -V，一直被告知不是内部变量T_T，这需要通过我在2中所述的设置，才能够解决呦 &gt;_&lt; 。。。其实我主要一直执着于用WebStorm里的Terminal来创建，如果直接在电脑的cmd中创建，也不会有这么多事儿啦，呵呵
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbf4b617299f66d5e1966e012936520c/" rel="bookmark">
			Springboot使用mongoDB，比较两个字段的大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://segmentfault.com/a/1190000007018484
Criteria criteria = new Criteria() {
@Override
public DBObject getCriteriaObject() {
DBObject obj = new BasicDBObject();
obj.put("$where", "this.lastUpdateTime &gt; this.lastReadTime");
return obj;
}
};
我使用的jar是spring-boot-starter-data-mongodb 2.14版本
Criteria的getCriteriaObject()方法，源码是
public Document getCriteriaObject() { if (this.criteriaChain.size() == 1) { return criteriaChain.get(0).getSingleCriteriaObject(); } else if (CollectionUtils.isEmpty(this.criteriaChain) &amp;&amp; !CollectionUtils.isEmpty(this.criteria)) { return getSingleCriteriaObject(); } else { Document criteriaObject = new Document(); for (Criteria c : this.criteriaChain) { Document document = c.getSingleCriteriaObject(); for (String k : document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbf4b617299f66d5e1966e012936520c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c9f9bb5215671ec503a8a91fa78522/" rel="bookmark">
			机器学习-SVM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		\[此篇文章介绍关于SVM中的一些不懂的地方的公式推导，以及代码实现和一些SVM问题，通过做题检验掌握的效果。\]
一、代码实现 \[调用sklearn包，进行SVM分类\]
#!/usr/bin/python # -*- coding utf-8 -*- import numpy as np import matplotlib.pyplot as plt import pandas as pd import matplotlib as mpl from sklearn import svm from sklearn.model_selection import train_test_split from sklearn.metrics import accuracy_score def load_data(): path = 'E:\数据挖掘\Machine learning\[小象学院]机器学习课件\8.Regression代码\8.Regression\iris.data' # 读取文件路径 data = pd.read_csv(path, header = None) # 从data 读取数据, x为前4列的所有数据, y为第5列数据 x, y = data[range(4)], data[4] # 返回字符类别的位置索引, 因y数组包含三类, 对应返回下标值 y = pd.Categorical(y).codes # 取x的前两列数据, 一般SVM只做二特征分类, 多特征的转化为多个二特征分类再bagging?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c9f9bb5215671ec503a8a91fa78522/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18512533c0dd01235bff99cebdf2f36/" rel="bookmark">
			CSS布局-水平&amp;垂直对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS布局-水平&amp;垂直对齐 水平居中 元素居中 设置width属性（不能为100%），设置margin:auto; 文本居中 使用属性text-align:center; 图片居中 将图片放入块元素中，同元素居中 垂直居中 使用padding：100px 0；
设置line-height 属性值和 height 属性值相等让元素居中
使用了 positioning 和 transform 属性来设置水平和垂直居中
使用弹性盒子，align-content: center; 可以让子元素居中
使用弹性盒子，margin: auto;同时水平垂直都居中
左右对齐 使用position：absolute；属性对齐元素
使用float属性，进行左右对齐
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de20d2470a5a4616d50980570d48cab5/" rel="bookmark">
			win10桌面快捷方式图标变白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桌面快捷方式变成白色图标是由于缓存文件的问题导致，删除 IconCache.db 这个文件后重启文件资源管理器。
一、找到路径 C:\Users\你的用户名\AppData\Local\IconCache.db
AppData文件夹 和 IconCache.db 这2个文件默认是隐藏的
需要更改：文件夹选项 &gt; 查看 &gt; 隐藏文件和文件夹 &gt; 显示隐藏的文件、文件夹和驱动器选择后点击应用保存设置。
二、打开任务管理器-右键Windows资源管理器-重新启动
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8649224f92c310f6040a4ef1255d6916/" rel="bookmark">
			c#中两个窗体相互传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做两个窗体相互传值的过程中，学习了好多类似的方法，最后找到了一篇很详细的博客，今天就结合这位大神的博客，http://blog.csdn.net/zlbcdn/article/details/70888603，加点自己的总结，保存备看。
1、功能展示 有时需要将子界面的内容传递到父界面，方法有好几种。经常用的是通过委托实现。具体的效果如下：
【说明】点击父界面上“打开子界面”button，则会弹出子界面。父界面与子界面如上图所示。
【说明】在子界面的textBox框内输入待返回至父界面的内容，点击“将内容返回”button，则父界面的textBox将会展示返回的内容。具体如上图所示
2、代码分析 里面应用了委托（delegate）和事件（event）。委托就是前端开发中最常用的“回调方法”（callback），event是一种注册机制，将动作与委托关联。
为了实现以上功能，首先先编写子窗体的定义。代码如下：
public partial class Form2 : Form { //第二步：声明一个委托类型的事件 public event setTextValue setFormTextValue; public Form2() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { //第三步：准备相关数据。 setFormTextValue(this.textBox1.Text); } } // 第一步：声明一个委托。（根据自己的需求） //注意：该委托必须声明在命名空间中，而不应该声明在类中，否则不能调用(新加) public delegate void setTextValue(string textValue); 第一步：先在子窗体中定义一个委托。根据实际需求定义委托 第二步：在子窗体中声明一个event，将委托与动作关联
第三步：在具体的事件中实现event
以上三步参见Form2的代码
父窗体的代码如下：
public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { Form2 form2 = new Form2(); //第四步：初始化事件 form2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8649224f92c310f6040a4ef1255d6916/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ed9bea7558c979826207658509ef002/" rel="bookmark">
			RISC-V发展迅猛，ARM有点坐不住了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注、星标公众号，不错过精彩内容
这两天可能很多人都被兆易创新基于RISC-V架构的GD32V刷屏了，可见RISC-V的发展之迅猛。
一、了解GD32V处理器
兆易创新在国内32位MCU中算是一家做的比较好的公司。在前天（2019年8月22日），兆易创新发布了基于RISC-V架构的GD32V系列MCU，算是在业界引起了不小轰动。
GD32V系列MCU采用了全新的基于开源指令集架构RISC-V的Bumblebee处理器内核，是兆易创新携手中国领先的RISC-V处理器内核IP和解决方案厂商芯来科技，面向物联网及其它超低功耗场景应用自主联合开发的一款商用RISC-V处理器内核。
发布的新品GD32VF103，首批提供了14个型号，包括QFN36、LQFP48、LQFP64和LQFP100等4种封装。供了108MHz的运算主频，以及16KB到128KB的片上闪存和6KB到32KB的SRAM缓存。
二、RISC-V发展历程
RISC：Reduced Instruction Set Computer，即精简指令集计算机。
RISC-V是基于RISC原理建立的免费开放指令集架构(ISA)，V是罗马字母，代表第五代RISC(精简指令集计算机)，可读作RISC-FIVE。
RISC的历史可追溯到1980年左右，在此之前，人们觉得简单的计算机可能会有用，但是没有很多人去阐述其设计原则，这种简单而有效的计算机一直都是学术界的兴趣。
1981年，在David Patterson的带领下，加州大学伯克利分校的一个研究团队起草了RISC-1，这就是今天RISC架构的基础。RISC-1原型芯片有44500个晶体管，拥有31条指令。包含78个32位寄存器，分为6个窗口，每个窗口包含14个寄存器，另外还有18个全局变量，寄存器占用大部分面积，控制和指令只占用芯片面积的6%，而同时代的芯片设计里要占用约50%的面积。
随后在1983年发布了RISC-II原型芯片,包含138个寄存器，分为8个窗口，每个窗口有16个寄存器，另外还有10个全局变量，但是只有39000个晶体管。接着在1984年和1988年发布了RISC-III和RISC-IV。
而RISC的设计理念也催生了一系列新架构，包含了许多我们耳熟能详的名字，如学术上认为比较成功的DEC Alpha、被写入经典教科书的MIPS、绕过指令级并行度障碍，追求线程级并行的SUN SPARC、服务器的王者IBM Power、以及现在统治嵌入式市场的arm。
2010年，Patterson教授的研究团队准备启动一个新项目，需要设计CPU，因而要选择一种指令集。他们调研了包括arm、MIPS、SPARC、X86等多个指令集，发现它们不仅设计越来越复杂，而且还存在知识产权问题。
RISC-V（第五代精简指令集）是David Patterson教授基于其30多年在精简指令集RISC领域的深入积累，在2010年到2014年期间带领团队研发出的最新一代CPU芯片设计指令集。RISC-V是基于精简指令集计算(RISC)原理建立的开放指令集架构(ISA)，RISC-V是在指令集不断发展和成熟的基础上建立的全新指令。RISC-V指令集完全开源、设计简单、易于移植Linix系统，采用模块化设计，拥有完整工具链。
我在之前写过一篇文章：第五代精简指令集计算机RISC-V你了解多少？
三、X86和ARM的厮杀
X86 架构和 Arm 架构厮杀多年，x86 没能移动处理器市场，Arm 也没能在服务器市场分到多少羹，两者各自安好，x86 依然在 PC 处理器市场独领风骚，Arm 依然在移动处理器市场稳坐老大。就在大家都认为主流架构市场会以当前格的局长治久安时，发生了中兴事件，打疼了中兴，打来了 RISC-V 崛起的机会。
上面说的兆易创新基于开源指令集架构RISC-V的GD32V系列MCU就是一个例子，其实，在GD32V之前还有很多基于RISC-V架构的处理器已经问世。
四、Arm 的随变而变
面对 RISC-V 的猛烈攻势，Arm 看“在眼里急在心里”，不想被人碾压只能迅速应变。熟悉 Arm 授权的用户应该清楚，以前客户如果想基于 Arm 架构设计产品，必须先选择处理器IP授权方案，向 Arm 支付一笔预付款才能取得 Arm 的 IP 设计资料，当客户完成研发、制造、出货后，还需要根据产品出货量向 Arm 支付权利金。显然，对于那些中小企业来说，RISC-V 的开源免费策略更受欢迎，虽然市面上基于 RISC-V 的产品为数不多，但是已经有很多 Arm 阵营的芯片公司在做双重准备，以满足用户可能出现的转移阵地的需求。
面对 RISC-V 咄咄逼人的发展态势，今年 7 月，Arm 推出新的授权模式“Flexible Access”：对于中低阶芯片的授权，未来客户不再需要缴纳“预付款”才能看到设计细节，而是能直接免费取得相关设计档案，并从中评估并选择最适合自己的产品，等到芯片正式生产后再按照制造的数量收费。
其实早在 2010 年 Arm 就发布了 DesignStart 计划，2015 年开放了 Cortex-M0 系统，取消预付授权或者评估费用，2017 年又将用户范围最广的 Cortex-M3 放入了 DesignStart 计划，如今推出“Flexible Access”授权模式无疑对准的是中小企业，这也是“不得已”的选择，在手机和平板市场增量停滞的大环境下，Arm 要想拿到新增用户只能对准初创企业，而这些企业资金有限，在 RISC-V 免费的吸引下及容易抛弃Arm拥抱 RISC-V，为了拿到更多增量市场，Arm 不得不放下“身段”召唤更多的新用户采用 Arm 架构设计产品。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ed9bea7558c979826207658509ef002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de93dbd4298dd2381ad55abf037a37c7/" rel="bookmark">
			解决Unable to lock directory /var/lib/apt/lists/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		E: Could not get lock /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)
E: Unable to lock directory /var/lib/apt/lists/
解决：
1、运行下面的命令来生成所有含有 apt 的进程列表
命令：ps -A| grep apt
2、杀死进程
命令：kill -9 2814
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de4208a067b59ebd580c0ec98b1771ff/" rel="bookmark">
			c&#43;&#43;第五章知识总结（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		—标识符的作用域与可见性
作用域：是一个标识符在程序正文中有效的区域。
C++中标识符的作用域有函数原型作用域，局部作用域（块作用域），类作用域，命名空间作用域。
1.函数原型作用域：
是C++程序中最小的作用域，在函数原型声明时形式参数的作用范围就是函数原型作用域（在函数说明中一定要包含形参的类型说明）。
注意：由于在函数原型的形参列表中起作用的只是形参类型，标识符并不起作用，可以省去。但考虑到程序的可读性，通常还是要在函数原型声明时给出形参标识符。
2.局部作用域：
函数形参列表中形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止。
函数体内声明的变量，其作用域从声明处开始，一直到声明所在的块结束的大括号为止。
3.类作用域：
类：一组有名成员的集合，类X的成员m具有类作用域，对m的访问方式有3种：
（1）如果在X的成员函数中没有声明同名的局部作用域标识符，那么在该函数内可以直接访问成员m。
（2）通过表达式x.m或者X::m。这正是程序中访问对象成员的最基本的方法。
X::m用于访问类的静态成员。
（3）通过ptr-&gt;m这样的表达式，其中ptr为指向X类的一个对象的指针。
4.命名空间作用域：
命名空间的语法形式：
namespace 命名空间名
{
命名空间内的各种声明（函数声明，类声明…）
}
一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的，不属于前面所述各个作用域的标识符，都属于该命名空间作用域。在命名空间内部可以直接引用当前命名空间中声明的标识符，如果需要引用其他命名空间的标识符，形式为：
命名空间名：：标识符名
例：
namespace SomeNs { class SomeClass{...}; } 如果需要引用类名SomeClass或函数名someFunc:
SomeNs::SomeClass objl;
命名空间允许嵌套：
例：
namespace OuterNs { namespace InnerNs { class SomeClass{...} } } 例：
#include&lt;iostream&gt; using namespace std; int i; //在全局命名空间中的全局变量 namespace Ns { int j; //在Ns命名空间中的全局变量 } int main() { i = 5; //为全局变量i赋值 Ns::j = 6;//为全局变量j赋值 { //子块1 using namespace Ns; //使得在当前块中可以直接引用Ns命名空间的标识符 int i; //局部变量，局部作用域 i = 7; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de4208a067b59ebd580c0ec98b1771ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6f9139cc23eb3a12235e88e6149be2/" rel="bookmark">
			有多少位是7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述
从键盘读入一个4位数的整数，求该数中有多少位是7
输入
一个4位数的整数
输出
该整数中7的个数
#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main() { int i=0,n; cin&gt;&gt;n; if(n/1000==7) i+=1; if((n/100)%10==7) i+=1; if((n/10)%10==7) i+=1; if(n%10==7) i+=1; cout&lt;&lt;i; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184535eb30700a057c97d671744166e1/" rel="bookmark">
			SuperMap iClient3D for WebGL教程（Entity）- PolylineVolumeGraphics
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：为梦齐舞
本文同步更新于简书文章[https://www.jianshu.com/p/97ac103cb6d4]
本节课程我们学习最后一个实体对象PolylineVolumeGraphics，线体积对象，它可以通过线数据挤出不同的形状，而成为体数据，比如我们希望在线绘制一根圆形的管道、绘制一堵围墙，那这样对象就能派上大用场了。
首先我们来看一个简单的效果图吧
实现代码如下
function computeCircle(radius) { var positions = []; for(var i = 0; i &lt; 360; i++) { var radians = Cesium.Math.toRadians(i); positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians))); } return positions; } viewer.entities.add({ id: "test", polylineVolume: { positions: Cesium.Cartesian3.fromDegreesArray([117.0, 32.0, 120.0, 36.0, 130.0, 36.0]), material: Cesium.Color.YELLOW, shape : computeCircle(6000.0), } }); viewer.flyTo(viewer.entities.getById("test")); 一、主要参数介绍 接下来我们来了解下PolylineVolumeGraphics的主要参数
1、positions：指定线对象的位置，一个点串对象，里面存储的是Cartesian3对象。
2、shape：要挤出的形状的数组，相当于是对象的切面形状
3、cornerType：角落样式的属性，默认是CornerType.ROUNDED，目前支持以下这种几种风格
4、show：定义对象是否显示。
5、fill：是否用材质进行填充。
6、material：定义材质外观对象
7、material：对象的填充材质，就是对象的外观，可以是颜色，也可以是贴图等等
8、outline：一个布尔属性，指定矩形是否显示轮廓。
9、outlineColor：轮廓的颜色。
10、outlineWidth：轮廓的宽度。
11、shadows：指定矩形是否从每个光源投射或接收阴影。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/184535eb30700a057c97d671744166e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8dbf6350092044ec85280f35b229a73/" rel="bookmark">
			用友U8&#43;数据导入 操作指引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用友U8+数据导入
操作指引
1 选择导入业务类型
选中左侧菜单栏实施导航-点击数据导入-选中打开模板-点击付款单（以导入付款单为案例）
2 编辑导入模板
点击付款单，后会弹出excel，填写对应值。蓝色为必填项。非蓝色可根据实际业务填写。
如一张单据存在多行，第二行数据直接复制第一行”表体款项类型“前面所有字段。如以下所示：
单号：2019080020。付款金额为300，由明细数据为100，200组合而成。
3 导入模板数据
数据填写完后，点击数据导入-选中业务单据-选中付款单-再点击导入。
特殊说明：导入文件是系统默认路径，请一定要在上一步打开模板中填写数据。
4 导入失败说明
导入可能会存在失败，以下失败的步骤。可双击点击错误，查看出错原因。
5 导入成功说明
导入成功后数据进入付款单审核页面，点击业务导航-点击付款单管理-点击付款单据审核-点击查询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195b4495d99819bcf47eb9ca8f37076b/" rel="bookmark">
			windows定时删除文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows如何定时删除指定目录文件。
提供一种方式：借助windows自带定时任务。
通过windows定时任务调用bat文件。
1、首先新建bat文件：
bat文件说明：
forfiles 自动删除7天前文件 （以当前系统时间为基准）
示例：
代码代码示例：
forfiles /p “d:\test” /s /m . /d -7 /c “cmd /c del @path”
d:\test换成你要的目录路径；
/d -7 指删除7天以前文件。
2、设置windows定时任务，绑定bat文件。
搜索windows-任务计划程序
创建任务
要点击任务计划程序库，或者任务计划程序库下面的菜单，才能新建任务。
设置任务
填写任务名称-设置安全选项
设置触发器，按业务所需-运行频次
点击操作-新建-浏览-选择新建的bat文件-确认
点击确认-任务列表中就可看到刚设置的定时任务。
点击右键还能运行、结束等功能。是不是很简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4967f0e6cd126260cbb69dc7caacb743/" rel="bookmark">
			sudo apt-get update出错：N: 无法安全地用该源进行更新，所以默认禁用该源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo apt-get update 执行上面命令后，出现： 正在读取软件包列表... 完成 W: GPG 错误：https://repo.fdzh.org/chrome/deb stable Release: 下列签名无效： EXPKEYSIG 1397BC53640DB551 Google Inc. (Linux Packages Signing Authority) &lt;linux-packages-keymaster@google.com&gt; E: 仓库 “https://repo.fdzh.org/chrome/deb stable Release” 没有数字签名。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 解决办法： sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 1397BC53640DB551 将签名更换为报错的那个
然后再次执行更新命令就可以了 sudo apt-get update 如果还是不行的话，说明源不行，需要换源。
换源方法： 方法一： 修改/etc/apt/sources.list文件
sudo vim /etc/apt/sources.list 删掉不用的软件源
方法二： 九宫格 --&gt; 打开“软件和更新” --&gt; “其他软件” --&gt;点击不能用软件源，删除
然后再试一次更新就成功了 sudo apt-get update 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f343f18319bd9668234c21f0ce859af/" rel="bookmark">
			智能网联云控平台在园区自动驾驶的场景应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文展示了自动驾驶云控平台架构及平台关键技术，以及在现实环境下的服务前景以及一些案例。自动驾驶还有很多的场景需要我们进行探索和技术创新，这里只是对目前我们所能触及到的在自动驾驶技术中的一些积累和想法进行分享。
▎本文来源：智东西
自动驾驶云控平台介绍
车联网平台的发展已经经历了三个主要阶段，即从最开始的TSP平台阶段（连接服务），到智能网联平台阶段（整车智能），再到现在自动驾驶云控平台阶段（车路协同），下一阶段将会基于“大数据+深度学习”技术从特定场景的自动驾驶到更广泛领域的智能化出行服务，实现全面的车-路-云高效协同。
斯润自动驾驶云控平台（Sirius Cloud Control以下简称云控平台）按功能分为感知层、传输层、处理层（近场处理、云端处理）、应用层共四层。
感知层通过车载设备或近端感知设备的信息获取来实现对车辆或环境状态数据的上报，通过智能终端进行数据的传输。
传输层则需要保证数据在传递过程中的实时性，车端通过CAN、LIN、FlexRay总线或以太网技术进行高速数据传输，传输通道通过5G或WIFI、NB-IOT等等过渡网络连接方式实现，在保证数据传递的低时延的前提下，完成整个控制链路的可靠性，安全性。
处理层包括近场处理以及云端处理两个过程，路端靠近车辆的设备中，通过边缘计算等技术可以实现近场处理，远远降低了数据传输的链路长度，提高了时效性，保障了低时延的需求。而云端处理则是通过将大量的数据上报之后进行综合分析，处理的数据具有高安全性的同时能够为应用层提供服务。
应用层包括运营管理、安全管理、应急管理、协同管理、公众管理等多方面应用，可以根据平台应用的环境进行设计，也可以通过丰富的人机交互设计实现客户的多重服务需求，最终将使“人-车-路-云”实现高效协同。
（自动驾驶云控平台功能架构）
自动驾驶云控平台功能中，每一个层级都有特定的功能，解决特定的问题，其中的关键技术是在发展的过程中不断的更新、迭代，而不是一夜之间就出现的。
下面我们就对自动驾驶云控平台中的关键技术进行展开。
平台架构与关键技术
自动驾驶云控平台脱离不了开放的车联网平台的技术，我们就从最底层到应用层开始进行逐级的分解，就云控平台架构技术而言，需要对每个功能层都进行定义及封装，通过对信息的采集、信息的分类处理、信息的计算再到应用过程来实现车辆的控制，或反之通过应用层对以下层面至终端进行控制。
底层是设备的接入层，随着汽车设备电子化进度的加快，可接入汽车的电子设备逐渐增多，如AVI、HUD、ADAS、T-BOX等等，那么如何能够有效的管理以及接入设备成了关键，接入的手段也有一些差异，除了像常规的CAN总线，未来还有以太网、Flexray、MOST等其他方式的接入手段来完成平台的数据采集要求。
网关层是对多协议的适配及多终端的融合的支持，斯润过去与国际、国内的95%的TBOX、IVI设备供应商建立的对接适配与联合交付工作，现在云控平台的网关进行平滑的扩展，将多路ADAS、路测试单元进行完整的融合，任何传感器与云端进行数据传递都需要建立非常高效且稳定的链接，所以我们需要在接入层设计出一套能够将多种设备进行有效接入的网关，我们称之为智能网关。
智能网关可以帮助终端设备与边缘计算、云端建立有效的连接，其中涵盖协议适配、消息路由、消息解析、消息转发，同时需要添加网关安全策略，例如Security Authentication。
另外一个部分叫EPIS，这是系统级的网关接口，这部分的功能主要是为了与车厂、示范园区数据中心、系统级的对接，保证系统的信息可以互相传递，完成整个数据链路的互动，打通上下游整体的信息通道。如与示范园区数据中心、汽车厂家各IT系统之间的连接，从而形成从汽车生产下线到车辆上路验收等整个汽车生命周期过程管理与更新记录。
网关的上层是智能网联的核心部分，我们称为基础服务层，其中涵盖了终端管理、车联网服务以及运营服务三个部分，由于终端的多样性，实际上很难对多个终端进行统一的协调和控制；每一家供应商提供的设备控制方式不一，所以控制策略就会有差异，比如T-BOX失联，问题会涉及到跟云端的通信，从而影响车辆数据的上报、以及对车辆的控制，那么此时怎么识别问题的原因，通过数据的分析如何对问题进行快速的定位是我们要考虑的核心问题。
数据层的主要任务是将数据进行清洗、存贮、隔离的动作。实际上自动驾驶，数据来源于平台、终端的数据内容，数据量特别的庞大，所以需要对数据的存储策略进行设计。
最上层是平台的应用部分，分为两个单元，第一部分是应用网关，应用如果想调用云控平台的组件，需要进行鉴权，具有安全认证策略，并不是所有的场景应用都能够访问平台，应用网关会围绕上层应用、三方的资源及算法进行判断与识别，将从单车应用扩展到多车应用。
（云控平台技术架构）
百度阿波罗自动驾驶技术是一整套算法，是在特定的区域内通过传统的车载设备完成数据采集，再通过算法来决策车辆行驶的路径的一系列过程，我们称之为单车智能。
如果自动驾驶要做规模化的商用，就需要使用完整的平台功能来连接每一辆车，并且提供对车辆的控制及应用、管理的能力以及根据车辆的状态实时提供管理及控制策略，因此在自动驾驶云控平台中所应用的技术路线要随之发生变化，接下来我们对智能网关、大数据存储及数据的可视化部分分别进行展开。
智能网关：
主机厂内容有很多自定义的协议，不同的车型具有不同的协议接入，这些都是对整体网关适配的能力的考验。所以网关的适配是核心能力。云控平台可以和企业平台进行对接，基于自动驾驶可以延伸出不同的三方平台，多平台的接入能力，是保证适用性的重要能力。智能网关Access Gateway大的框架基于MQTT、CoAP、TCP、HTTP、GB以及NB-IOT标准，能够将设备的接入变得简单，并且能够进行数据的分发及交互。
应用上层包含外部、内部服务，如AVP服务与云控平台的对接，还有AEB或其他服务，而且未来也会基于自动驾驶产生多种多样的服务，都可以与云控平台进行对接，因此智能网关需要具备多平台、多协议的技术接入能力，同时，在内部服务中要贯通终端管理、数据分析、面向2B端客户从应用到业务端的支撑单元进行贯通，业务逻辑打通，使得在运营环节没有数据的延迟。
（智能网关服务）
大数据存储：
自动驾驶场景下采集的数据量会变得非常庞大，单台车的数据量每天可以达到4-8T。那么面对这样庞大的数据量，我们就需要通过对“数据流”进行管理，来达到提升数据存储速度及存储效率。HDMS是分布式的数据存储方式，根据数据结构，不会去管控数据查询的效率，主要的用途是将数据进行快速存储在本地和云端的服务器。
其中的重点是把数据的采集、数据的接入做管理，如传感器、应用SDK以及第三方资源的接入等。接入方式不同所对应的传输的方式也有不同，从KAFKA到HTTP以及带有安全策略的TOS，目的都是基于数据的分布式存储，将基础存储、中间层存储，计算服务性内容等构建大数据集群，所以我们在数据存储的环节，需要构建大数据中台，把数据的存储方式和存储策略建立起来，大数据的概念大家基本上都有些共识，这里就不做过多的赘述了。
（数据中台架构）
数据可视化：
自动驾驶可以应用为虚拟仿真的展现方式，更多时候我们考虑基于数据展示的方式来进行利用，斯润基于自主研发以及第三方的开源技术能力来提供数据可视化服务。
开源的数据可视化产品如百度ECharts、阿里Data V，腾讯RayData华为的DLV，微软的Power Bi、Qlik等，都可以在特定的条件下提供进行数据展示的服务。目的是围绕云控平台在特定的环境下去做可视化的呈现，显示特定的数据，可以通过数据化的展现方式来对车辆进行管理，以及对应用服务进行数据的呈现并提供业务支撑。
（数据展示技术分析）
技术可验证与实际交付
在整个自动驾驶环节从硬件到平台到上层的应用分为三个部分，斯润的核心能力体现在T-BOX终端、自动驾驶云控平台以及应用层的车联网应用、出行服务和大数据服务方面。其他的内容我们会结合第三方的服务以及硬件来整合所有的资源，提供自动驾驶服务。
车路协同系统：
在示范园区车路协同系统的构建包括路侧智能化基础设施、通讯网络、自动驾驶云控平台以及车辆（终端）四个部分。路侧智能化基础设施需要部署网联式交通信号灯、毫米波雷达、激光雷达、智能摄像头、V2X路侧通信终端、边缘服务器、电子信息指示牌等基础设备，又称为智能化前端系统。
T-BOX终端：
目前斯润已经与中移动成立了联合实验室，与华为、和高通的通讯模组进行集成合作。在自动驾驶环节中，T-BOX是车上唯一的联网部件，其能力会向更高级的域控制器进行迭代，通讯模组功能和运算能力会相应的进行扩展与升级，传统的T-BOX内部主要包含CPU、MCU以及通讯模组组成，核心能力主要体现在基于Linux系统下的软件架构OS处理能力上。
斯润与中国移动共同合作研发5GT-BOX产品，具有应用场景广泛，兼容性强的特点。在与5G网络及云服务平台结合后，配合车端技术升级，在未来智能汽车即服务的产业转型中，可以实现为先进的智能汽车与道路、用户之间提供可靠的连接及服务的功能。
（斯润5G T-BOX产品架构）
T-BOX会将摄像头、雷达等设备的情况上传到云控平台，同时也可以将车内的传感器将车内人员的情况进行上传到云控平台。云控平台通过对T-BOX上传的数据以及其他平台的数据进行综合分析，下发指令至T-BOX而后通过车辆的网关对数据进行分发，从而完成数据传递的整个过程。
（T-BOX与云控平台交互方案）
FOTA远程升级：
在自动驾驶环境中，终端的程序面临各种紧急情况的挑战，对比车联网平台中，只需要对T-BOX以及车机或者液晶仪表等部件进行远程升级，但到了自动驾驶环境下，车辆的终端设备开始增加，应用场景也变得更加复杂，这时候所面临到的管理能力和软件迭代压力将大大增加，面对如此复杂的应用场景，各设备应用的复杂程度是我们之前难以想象的，所以，我们的解决方案是通过终端管理平台应用，以及有效的终端分析、管理能力来提供升级策略，协助整个自动驾驶场景下的所有终端产品进行远程迭代。
（FOTA应用技术）
车队运营中的车联网技术
在示范园区的环境中，路侧智能化基础设施、通讯网络、车联网云控平台以及T-BOX的模组都已经完成适配的情况下，车辆已经具备了使用自动驾驶的功能。我们便可以通过车队运营自动驾驶系统来为车队的运营提供自动驾驶多车运营的服务，在这种环境下，第一辆车可以是有人驾驶车辆，后面的车队采用自动驾驶，也可以是完全自动驾驶。
车队运营自动驾驶系统分为初始化配置、平台配置、园区配置、业务配置、运营管理五个环节。系统可以实现路线规划、车辆添加、车队组建、计划安排、实时监控、故障报警、设备管理、任务分配等功能。
（车队运营自动驾驶系统功能操作步骤）
园区自动驾驶场景的应用
AVP（Automated Valet Parking）即自动代客泊车服务，对比配置了RSPA功能的车辆，利用超声波传感器，车外的驾驶员只需按下按钮，就可以实现自动泊车，但前提条件是得提供一个空置的停车位，而AVP技术可以使车辆自行寻找空置的停车位并自动驶向该车位完成泊车操作，全程无需人为干预，应用前景广阔。
（车队运营自动驾驶系统功能操作步骤）
（云控平台概览）
（车辆状态监控）
（队列车辆监控）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/173106680fb9159c761db0035d506c78/" rel="bookmark">
			java异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体上我们根据Javac对异常的处理要求，将异常类分为2类。
非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类。javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try...catch...finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。
检查异常（checked exception）：除了Error 和 RuntimeException的其它异常。javac强制要求程序员为这样的异常做预备处理工作（使用try...catch...finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e327bc137816a0bc00acc5957e61efbf/" rel="bookmark">
			数据结构与算法（五）—— 广义表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		广义表是线性表的推广，又称列表。线性表的元素仅限于原子项，即每个数据元素只能是一个数或一个记录，如果放松对线性表元素的这种限制，允许它们自身具有结构，由此就产生了广义表的概念。
一、广义表的定义 广义表是n(n&gt;=0)个元素的有限序列，其中每个元素是原子项或者是一个广义表，通常记作GL=(a1,a2,a3,...,an)。GL是广义表的名字，n是它的长度。为了区分原子项和广义表，在书写上习惯用大写字母表示广义表，用小写字母来表示原子。通常用圆括号将广义表括起来，用逗号分隔其中的元素。当广义表非空时，称第一个元素a1是GL的表头(head)，其他元素组成的表称为GL的表尾(tail)。
下面列举一些广义表的例子：
(1) A=() —— A是一个空表，其长度为零；
(2) B=(a) —— B是一个只有一个原子的广义表，其长度为1；
(3) C=(a,(b,c)) —— C是一个长度为2的广义表，第一个元素是原子，第二个元素是子表；
(4) D=(A,B,C) = ((),(a),(a,(b,c))) —— D是一个长度为3的广义表，其中三个元素均为子表；
(5) E=(C,d) = ((a,(b,c)),d) —— E是一个长度为2的广义表，第一个元素是子表，第二个元素是原子；
(6) F=(e,F) = (e,(e,(e,...))) —— F是一个递归的表，它的长度为2，第一个元素是原子，第二个元素是表自身，展开后它是一个无限的广义表。
一个表展开后所含括号的层数称为广义表的深度。例如，表A、B、C、D、E的深度分别为1、1、2、3、3，而表F的深度为无穷大。 二、广义表的基本运算 对上面举例的广义表进行运算：
(1) 空表A没有表头也没有表尾，length(A) = 0，depth(A) = 1
(2) head(B) = a，tail(B) = ()，length(B) = 1，depth(B) = 1
(3) head(C) = a，tail(C) = ((b,c))，length(C) = 2，depth(C) = 2
(4) head(D) = A，tail(D) = (B,C)，length(D) = 3，depth(D) = 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e327bc137816a0bc00acc5957e61efbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/023ba3642932ccc7f33113f4661c91a3/" rel="bookmark">
			写一个重载的max函数，它获取double类型的两个或三个参数，返回其中最大的数。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include
using namespace std;
double max(double a, double b)
{
return a&gt;b ? a : b;
}
double max(double a, double b, double c)
{
return max(a,max(b,c));
}
int main()
{
double m1, n1, m2;
cout &lt;&lt; “请输入三个数:”;
cin &gt;&gt; m1&gt;&gt;n1&gt;&gt;m2;
cout &lt;&lt; “max=” &lt;&lt; max(m1, n1,m2) &lt;&lt; endl;
double x,y; cout &lt;&lt; "请输入两个数:"; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; "max=" &lt;&lt; max(m1, n1) &lt;&lt; endl; return 0; }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c983f8ba7c73feaff4b15c01a2f67892/" rel="bookmark">
			sql和MySQL的语句执行顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql和mysql执行顺序，发现内部机制是一样的。最大区别是在别名的引用上。
一、sql执行顺序
(1)from
(3) join
(2) on
(4) where
(5)group by(开始使用select中的别名，后面的语句中都可以使用)
(6) avg,sum…
(7)having
(8) select
(9) distinct
(10) order by
从这个顺序中我们不难发现，所有的 查询语句都是从from开始执行的，在执行过程中，每个步骤都会为下一个步骤生成一个虚拟表，这个虚拟表将作为下一个执行步骤的输入。
第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）
第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2
第三步：如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3
第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。
第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名=成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级='x’的话，left outer join会把x班级的所有学生记录找回（感谢网友康钦谋__康钦苗的指正），所以只能在where筛选器中应用学生.班级=‘x’ 因为它的过滤是最终的。
第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。
第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6.
第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。
第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8.
第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。
第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。
第十二步：应用top选项。此时才返回结果给请求者即用户。
二、mysql的执行顺序
SELECT语句定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c983f8ba7c73feaff4b15c01a2f67892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffdcb840dae91cf3c3393b2f868bec60/" rel="bookmark">
			JAVAEE session，cookie详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.1会话跟踪技术（回顾）
HTTP协议是一种无状态协议，其本身是无法进行会话跟踪的，即无法在不同的请求间进行状态保存（数据传递）。 什么会话？简单来说，只要打开了一个浏览器页面，在不关闭该页面的情况下所发出的所有请求，都属于一次会话。 常见的会话跟踪技术有两种：Cookie与Session。 1.1.1Cookie工作原理
用户在提交第一次请求后，由服务器生成Cookie，并将其封装到响应头中，以响应的形式发送给客户端。在客户端接收到这个响应后，将Cookie保存到客户端。 注意，Cookie总是与某个请求路径相绑定，即客户端只要发送包含有相同指定路径的请求，就会将该Cookie发送给服务端。当然，在Cookie中包含有数据。服务端会根据客户端发送来的Cookie数据对会话进行跟踪，即在不同请求间进行数据通信。 1.1.2Session工作原理
HttpSession是Cookie技术在服务端的会话跟踪实现。在服务器中系统会为每组会话维护一个Session，不同的会话对应不同的Session。什么是一组会话？包含有“部分相同请求路径”的若干请求/响应的集合，称为一组会话。这里的“部分相同请求路径”默认指的是ContextPath路径，即当前web应用的根路径。 HttpSession是一个可以存放键值对数据的域属性空间，同一组会话对应同一个Session域属性空间，从而实现了同一组会话中不同请求间数据的通信，即会话跟踪。 （1）写入Session列表
服务器对当前应用中的Session是以Map的形式进行管理的，这个Map称为Session列表。这个Map的key为一个32位长度的随机串，这个随机串称为SessionID，而value为HttpSession对象的引用。 当用户第一次提交请求时，服务端Servlet中执行到request.getSession()后，会自动生成一个Map.Entry对象，生成一个HttpSession对象，并根据某算法自动生成32位长度的随机串。然后将随机串（即SessionID）作为Map.Entry对象的key，将新生成的HttpSession对象引用作为Map.Entry对象的value。 （2）服务器生成并发送Cookie
在将Session信息写入Session列表后，系统会自动将“JSESSIONID”作为name（基于JavaEE协议的情况下），将这个32位长度的随机串作为value，以Cookie的形式存放到响应报头中，并随着响应将该Cookie发送给客户端。 （3）客户端接收并发送Cookie
客户端接收到这个Cookie后会将其存放到浏览器缓存中。即只要客户端浏览器不关闭，浏览器缓存中的Cookie就不会消失。 当用户在当前应用下提交第二次请求时，即提交的请求路径中携带有当前web应用的根路径时，就会将缓存中的这个Cookie伴随着请求的头部信息一并发送给服务端。 （4）服务端从Session列表中查找
服务端在接收到客户端发送来的请求后，会从请求中读取到客户端发送来的Cookie，并根据名称为JSESSIONID的Cookie的value值，从Session列表的Map的key中查找是否存在该JSESSIONID。若找到了该key，即可找到其对应的HttpSession对象。然后就可以对该Session域属性空间进行读写操作了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a09d993a016a8b3af50e7a9ea570f2c/" rel="bookmark">
			判断素数(C&#43;&#43;版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博文:https://blog.csdn.net/Jonms/article/details/80464622
1.简单粗暴法 对于判断一个数n是否为素数，按素数的定义，试除以从2开始到m-1的整数，如果都不能整除，则该数一定是素数。
#include &lt;iostream&gt; using namespace std; bool IsPrime(int n) { if(n &lt;= 1){ cout&lt;&lt;n&lt;&lt;"不是素数"&lt;&lt;endl; return false; } for (int i = 2; i &lt; n; i++) { if ((n % i) == 0){ cout&lt;&lt;n&lt;&lt;"不是素数"&lt;&lt;endl; return false; } } cout&lt;&lt;n&lt;&lt;"是素数"&lt;&lt;endl; return true; } int main() { int a = 2, b = 17, c = 18; IsPrime(a); IsPrime(b); IsPrime(c); return 0; } 运行结果:
2是素数 17是素数 18不是素数 2.更高效率的方法 若2都不能除尽，还要试4, 6, 8, …吗？若3都不能除尽，还要试9, 15, 21, …吗？等等。一个数，如果有因子的话，那么在它的平方根数以内就应该有，否则就没有因子。所以必定有一个因子不大于m的平方根。故判断m是否为素数，只要试除到m的平方根就可以了，不必一直到m-1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a09d993a016a8b3af50e7a9ea570f2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4e86f8e73615b684504f558fedfc334/" rel="bookmark">
			springboot&#43;mybatis&#43;mysql多数据源配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中经常要使用到不同的库的数据源，就以mysql为例，讲解一下自己在项目中配置多个数据源的过程：
1 在application.properties文件中配置不同数据源的配置。
# kbs database config spring.datasource.kbs.jdbc-url=jdbc:mysql://****:3306/kbs?allowMultiQueries=true&amp;useSSL=false&amp;Unicode=true&amp;characterEncoding=utf8&amp;useTimezone=true&amp;serverTimezone=GMT%2B8 spring.datasource.kbs.username=*** spring.datasource.kbs.password=*** spring.datasource.kbs.driver-class-name=com.mysql.jdbc.Driver spring.datasource.kbs.druid.initial-size=5 spring.datasource.kbs.druid.min-idle=1 spring.datasource.kbs.druid.max-active=20 spring.datasource.kbs.druid.test-on-borrow=true spring.datasource.kbs.druid.stat-view-servlet.allow=true # wp database config -test environment spring.datasource.wp.jdbc-url=jdbc:mysql://****:3306/wordpress?allowMultiQueries=true&amp;useSSL=false&amp;Unicode=true&amp;characterEncoding=utf8&amp;useTimezone=true&amp;serverTimezone=GMT%2B8 spring.datasource.wp.username=*** spring.datasource.wp.password=*** spring.datasource.wp.driver-class-name=com.mysql.jdbc.Driver spring.datasource.wp.druid.initial-size=5 spring.datasource.wp.druid.min-idle=1 spring.datasource.wp.druid.max-active=20 spring.datasource.wp.druid.test-on-borrow=true spring.datasource.wp.druid.stat-view-servlet.allow=true 2 编写不同数据源的@Configuration 第一个Configuration 文件：
package com.lenovo.knowledge.config; import javax.sql.DataSource; import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.SqlSessionTemplate; import org.mybatis.spring.annotation.MapperScan; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.jdbc.DataSourceBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import org.springframework.jdbc.datasource.DataSourceTransactionManager; @Configuration @MapperScan(value = "com.lenovo.know.dao.kbs", sqlSessionTemplateRef = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4e86f8e73615b684504f558fedfc334/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1504b68310146667ead3c970275b8b98/" rel="bookmark">
			SpringCloud微服务架构（三）Feign
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念
Feigh是一个声明式web服务客户端。它能让开发web服务变得容易。使用Feign需要创建一个接口并注解它。它拥有包括Feign注解和JAX-RS注解的可插拔支持。它还支持可插拔的编码器和解码器。Spring Cloud拥有Spring MVC支持，并使用Spring Web中默认同样的HttpMessageConverters。在使用Feign时，Spring Cloud集成了Ribbon和Eureka来提供负载均衡的HTTP客户端。
Feign的在使用中需要注意的地方
不能直接支持接收对象参数，只能一个一个属性接收。如果必须要接收对象参数，可以变相通过@RequestBody，通过json的表单提交来实现。
对于日期类型支持和json转换间冲突多，还滞后8小时。转为字符串类型，在提供者时，再强制转换为日期，更加方便些。
@PathVariable(“name”) String name 必须写名称“name”，springmvc可以不写。
启动超过1s会报超时，再刷新就可以正常访问，原因在于hystrix断路器的影响，稍差的机器可能会发生这个问题。
调用过程
首先，提供者provider-user和消费者custorm-feign都注册到Eureka中。用户请求feign中的controller，feign中的controller调用feign定义的接口方法。接口的方法根据注解去找到eureka注册中心中的provider-user地址，然后请求远程provider-user所在服务器的地址，然后调用远程的provider-user提供者的具体服务。提供者响应返回json，json被feign封装传输给“接口”的返回值，“接口”在返回给feign的controller，最终响应给用户。
总结
Feign简化HttpClient开发，封装了JAX-RS和springmvc的注解，学习成本低。Feign是典型的基于接口，基于动态代理技术自动生成代理对象。
代码demo可参考git:https://github.com/a870368162/springcloud-demo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca62813257912da6529393cf184caf3/" rel="bookmark">
			CTF-CMS系统漏洞分析溯源(第3题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据题意
想利用漏洞，我们需要先注册一个用户，在注册信息中想方设法插入我们的一句话木马。点“用户注册”来注册一个用户，“用户名”、“登录密码”、“邮件地址”等都可以随便填写，但“密码问题”需要特别注意，要填写“+撺数畲整煺焕敞蹉V=-|悄”，也就是&lt;% execute request(“a”)%&gt;a经过Unicode转码后的代码。
进入环境，再注册页面提交
问吧数据库的默认地址是问吧耳录下的data目录下的ask_newasp.asa，直接在浏览器中访问，看到了数据库的代码，拉到网页最下面，看到了熟悉的“类型不匹配：‘execute’”，说明一句话木马已经成功的插入到数据库中了。
使用菜刀链接获取key
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3561c49f12855c33505fc1367a60278a/" rel="bookmark">
			gitlab连通时报Could not resolve host:gitlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误描述：在搭建gitlab服务器的连通测试的时候报了如下图的错误，因为我在用docker启动gitlab镜像的时候做了hostname的设置，将hostname设置成了gitlab，因为物理机hosts文件中未对它做映射所以导致域名无法解析的问题。
解决方法：修改hosts文件，位置在下图：
修改hosts必须使用管理员用户的权限，你找到你本机的“记事本”软件，右击选择“以管理员身份打开”，打开hosts文件修改保存就好了。
修改完毕后，以上问题就解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d394c2547c7bf4cfe41365ccfb6e94/" rel="bookmark">
			OpenCV学习笔记-关于使用Mat.at(i,j) = int 语法报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关于使用Mat.at(i,j) = int 语法报错，内存异常的原因。
首先是查看异常如何发生的，单步调试可以发现再at方法里有以下断言：
_Tp&amp; Mat::at(int i0, int i1) { CV_DbgAssert(dims &lt;= 2); CV_DbgAssert(data); CV_DbgAssert((unsigned)i0 &lt; (unsigned)size.p[0]); CV_DbgAssert((unsigned)(i1 * DataType&lt;_Tp&gt;::channels) &lt; (unsigned)(size.p[1] * channels())); CV_DbgAssert(CV_ELEM_SIZE1(traits::Depth&lt;_Tp&gt;::value) == elemSize1()); return ((_Tp*)(data + step.p[0] * i0))[i1]; } 其中断言2要求这个Mat必须是有数据填充的，不能是空的。我一开始使用如下方法定义了一个空的Mat.
Mat mat; mat.create(mat_a.size(),mat_a.type()); 创建了一个指定大小和数据类型的空Mat,所以在调用at方法时报错。
改变，创建一个以0填充的Mat结构就可以了。
Mat mat = Mat::zeros(mat_a.size(),mat_a.type()); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b61e93fbce6fde0bc6e04d05e49563/" rel="bookmark">
			add_months函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天对add_months函数进行简单总结一下：
add_months 函数主要是对日期函数进行操作，在数据查询的过程中进行日期的按月增加，其形式为：
add_months(date,int);其中第一个参数为日期，第二个为按月增加的幅度，例如：
add_months （sysdate,2）：就是当前日期的两个月之后的时间。
如：表示2个月以后的时间：
SQL&gt; select add_months(sysdate,2) from dual; ADD_MONTHS(SYSDATE,+2)
----------------------
2012-5-16 下午 02:30:47
表示2个月以前的时间，可以用下列语句
SQL&gt; select add_months(sysdate,-2) from dual;
ADD_MONTHS(SYSDATE,-2)
----------------------
2011-11-16 下午 02:32:39
如果第一个参数即当前日期的地方是某一个指定的具体日期，则该日期需要使用to_date（'20190101','yyyymmdd'）进行转换，如下：
select * from tb_user where create_date_time&gt;to_date（'20190101','yyyymmdd'）and create_date_time&lt;tadd_months(to_date（'20190101','yyyymmdd'）,2)
以上语句表示查询日期在20190101到20190301之间的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fedff98551d886a4d6b31ca2866a61fe/" rel="bookmark">
			页面左右区域超出滚动互不影响，滚动区域联动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要写一个效果如下图所示，两个区域，之间的滚动条互不影响，各自独立作用。
点击左边导航，右边会跟着滚动
`
&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt; &lt;style&gt; nav { height: 100%; width: 200px; position: fixed; } nav ul { height: 300px; overflow-y: auto; } nav ul li { height: 50px; } main { padding-left: 240px; } .active { color: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;导航01&lt;/li&gt; &lt;li&gt;导航02&lt;/li&gt; &lt;li&gt;导航03&lt;/li&gt; &lt;li&gt;导航04&lt;/li&gt; &lt;li&gt;导航05&lt;/li&gt; &lt;li&gt;导航06&lt;/li&gt; &lt;li&gt;导航07&lt;/li&gt; &lt;li&gt;导航08&lt;/li&gt; &lt;li&gt;导航09&lt;/li&gt; &lt;li&gt;导航10&lt;/li&gt; &lt;li&gt;导航11&lt;/li&gt; &lt;li&gt;导航12&lt;/li&gt; &lt;li&gt;导航13&lt;/li&gt; &lt;li&gt;导航14&lt;/li&gt; &lt;li&gt;导航15&lt;/li&gt; &lt;li&gt;导航16&lt;/li&gt; &lt;li&gt;导航17&lt;/li&gt; &lt;li&gt;导航18&lt;/li&gt; &lt;li&gt;导航19&lt;/li&gt; &lt;li&gt;导航20&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;main&gt; &lt;h2&gt;标题01&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题02&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题03&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题04&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题05&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题06&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题07&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题08&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题09&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题10&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题11&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题12&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题13&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题14&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题15&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题16&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题17&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题18&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题19&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;h2&gt;标题20&lt;/h2&gt; &lt;div&gt;面为陪我&lt;/div&gt; &lt;/main&gt; &lt;/body&gt; ` &lt;script&gt; $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fedff98551d886a4d6b31ca2866a61fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c920d7bc7f76060d2b5eb9f994528a/" rel="bookmark">
			hbase导入数据同时与phoenix实现映射同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们的目标是：创建一个hbase表格，能够通过phoenix进行访问；同时能够导入本地数据到hbase中，最后都能够通过phoenix进行访问。
1、先在hbase中创建表格
create 'WHO_GOODS_LABEL','GID','INFO'
2、然后在phoenix中建立相同的表名以实现与hbase表的映射
create table if not exists WHO_GOODS_LABEL(GOODS_ID varchar primary key, INFO.ISWHITE varchar, INFO.DATA_DATE varchar );
注意：
（1）两个表名相同
（2）phoenix的主键名称不需要和hbase中的相同，两边通过表格的内置结构可以自动关联起来，因为表格可以自动识别到主键
（3）phoenix中的column必须以hbase的columnFamily开头，如上所示
通过上面两步已经创建了一个hbase和phoenix同步的表格WHO_GOODS_LABEL，在hbase中执行如下操作，phoenix中可以查看到数据
put 'WHO_GOODS_LABEL', '11', 'INFO:ISWHITE','1'
接下来我们需要把本地的文件存放到hbase中，大致流程是：
本地文件 上传到hdfs中，hdfs生成hfile文件，将hfile文件导入hbase中，具体操作如下步骤
3、本地文件上传到hdfs
本地文件who_goods_label_new.csv样例如下，通过逗号进行分割的。
11,1,2017-03-02
然后把文件上传到hdfs上，命令如下:
hadoop fs -put who_goods_label_new.csv /tmp/who_goods_label_new.csv
4、hdfs数据导入到hbase中，执行下面两条命令
hbase org.apache.hadoop.hbase.mapreduce.ImportTsv -Dimporttsv.columns=HBASE_ROW_KEY,INFO:ISWHITE,INFO:DATA_DATE -Dimporttsv.separator=, -Dimporttsv.bulk.output=/tmp/who_goods_label_output WHO_GOODS_LABEL /tmp/who_goods_label_new.csv
hbase org.apache.hadoop.hbase.mapreduce.LoadIncrementalHFiles /tmp/who_goods_label_output WHO_GOODS_LABEL
注意：第一条命令中需要通过importtsv.separator指定分隔符，否则默认的tsv文件默认的分隔符是tab键。
http://blog.sina.com.cn/s/blog_628cc2b70102x5lq.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb919548e91900502672c1f3c04831b1/" rel="bookmark">
			C&#43;&#43; 简单工厂模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;bits/stdc++.h&gt; #include &lt;conio.h&gt; using namespace std; class Operation{ private: int num1; int num2; public: virtual int cal()=0; int getn1(){ return num1; } void setn1(int n1){ num1=n1; } void setn2(int n2){ num2=n2; } int getn2(){ return num2; } }; class OperAdd:public Operation{ public: int cal(){ int res=getn1()+getn2(); return res; } }; class OperSub:public Operation{ public: int cal(){ int res=getn1()-getn2(); return res; } }; class Factory{ public: Operation* create(char op){ Operation* oper=NULL; switch(op){ case '+': oper=new OperAdd(); break; case '-': oper=new OperSub(); break; default: return NULL; } return oper; } }; int main(){ int n1,n2; cin&gt;&gt;n1&gt;&gt;n2; char op; cin&gt;&gt;op; Factory* f=new Factory(); Operation* oper=f-&gt;create(op); oper-&gt;setn1(n1); oper-&gt;setn2(n2); cout&lt;&lt;oper-&gt;cal()&lt;&lt;endl; getch(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/493c34470f1641da5099272f24a644fa/" rel="bookmark">
			Aviator表达式快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到的问题 最近项目中有这样一种场景：需要改变部分订单的结算方式，这个改动点对交易结算影响很大，需要逐步切流以减少风险。订单有buyerId(买家id)、sellerId（卖家id）、tkBizTag(订单打标)……几十个字段，如果case by case硬编码来限定切流的场景来做，就很不灵活，单纯这个切流就要上多次线。
因此有这样的技术需求：使用一种灵活多变的切流方式，即可支持对按照订单对象任何一个参数满足某种条件时进行切流，如按照订单类型字段、某些买家id符合要求。
解决方案 经过调研，最终采用aviator表达式＋动态内容推送中间件（diamond）来实现。
一个简单的demo如下：
NCpsPaymentDTO paymentDTO = newNCpsPaymentDTO(); paymentDTO.setTkBizTag(5); paymentDTO.setTbBuyerId(1234L); ExtraInfo extraInfo = new ExtraInfo(); extraInfo.setEventId(1234567L); HashMap paramMap= new HashMap(); paramMap.put("paymentDTO",paymentDTO); paramMap.put("extraInfo",extraInfo); String configInfo ="paymentDTO.tkBizTag == 5 &amp;&amp; paymentDTO.tbBuyerId % 10000 &lt;=2000 &amp;&amp; extraInfo.eventId == 1234567"; Expression expression =AviatorEvaluator.compile(configInfo); Boolean rst = (Boolean)expression.execute(paramMap); System.out.println(rst);//true Note:
其中configInfo取自动态内容推送中间件diamond，可以根据需求随时更新并推送到各台线上机器。
了解到这个程度足够了么？No.关于aviator还需要知道得更多。
Aviator简介 Aviator是一个高性能、轻量级的java语言实现的表达式求值引擎，主要用于各种表达式的动态求值。现在已经有很多开源可用的java表达式求值引擎，为什么还需要Avaitor呢？
Aviator的设计目标是轻量级和高性能，相比于Groovy、JRuby的笨重，Aviator非常小，加上依赖包也才450K,不算依赖包的话只有70K；当然，Aviator的语法是受限的，它不是一门完整的语言，而只是语言的一小部分集合。
其次，Aviator的实现思路与其他轻量级的求值器很不相同，其他求值器一般都是通过解释的方式运行，而Aviator则是直接将表达式编译成Java字节码，交给JVM去执行。简单来说，Aviator的定位是介于Groovy这样的重量级脚本语言和IKExpression这样的轻量级表达式引擎之间。
Aviator的特性 支持大部分运算操作符，包括算术操作符、关系运算符、逻辑操作符、正则匹配操作符(=~)、三元表达式?:，并且支持操作符的优先级和括号强制优先级，具体请看后面的操作符列表。支持函数调用和自定义函数支持正则表达式匹配，类似Ruby、Perl的匹配语法，并且支持类Ruby的$digit指向匹配分组。自动类型转换，当执行操作的时候，会自动判断操作数类型并做相应转换，无法转换即抛异常。支持传入变量，支持类似a.b.c的嵌套变量访问。性能优秀 Aviator的限制 没有if else、do while等语句，没有赋值语句，没有位运算符仅支持逻辑表达式、算术表达式、三元表达式和正则匹配 Aviator用法 最新jar包 &lt;dependency&gt; &lt;groupId&gt;com.googlecode.aviator&lt;/groupId&gt; &lt;artifactId&gt;aviator&lt;/artifactId&gt; &lt;version&gt;2.3.4&lt;/version&gt; &lt;/dependency&gt; 算术表达式 Long result = (Long)AviatorEvaluator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/493c34470f1641da5099272f24a644fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca53d5e8e62d26219a0b251957dd9f99/" rel="bookmark">
			引用thymeleaf模板，js中大于小于等符号转义异常问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在springBoot框架下，整合了thymeleaf前端模板后，由于thymeleaf对标签要求比较严格，所以在js中使用&gt; &lt; 等符号时，会报出异常。
正常抒写：
`&lt;script&gt; var a=0; var b=a+3; if(a&gt;b) alert("假"); else alert("真"); &lt;/script&gt;` 在引用thymeleaf后，以上的&gt;号会被判定格式问题，抛出异常。
那么正确写法如下：
&lt;script th:inline="javascript"&gt; /*&lt;![CDATA[*/ var a=0; var b=a+3; if(a&gt;b) alert("假"); else alert("真"); /*]]&gt;*/ &lt;/script&gt;
使用CDATA标签将需要用到特殊符号的地方包围起来就可以被识别了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/686829f112e07af9e4f107b9fa3c433c/" rel="bookmark">
			汇编语言中的标志位：CF、PF、AF、ZF、SF、TF、IF、DF、OF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CF:进位标志位。在无符号运算时，记录了运算结果的最高有效位向更高位的进位值或从更高位借位，产生进位或借位时CF=1，否则CF=0；
PF:奇偶标志位。相关指令执行后结果所有bit中1的个数为偶数，那么PF=1，1的个数为奇数则PF=0；
AF:辅助进位标志位。运算过程中看最后四位，不论长度为多少。最后四位向前有进位或者借位，AF=1,否则AF=0;
ZF:零标志位。相关指令执行后结果为0那么ZF=1,结果不为0则ZF=0；
SF:符号标志位。相关指令执行后结果为负那么SF=1，结果非负数则SF=0；
TF:调试标志位。当TF=1时，处理器每次只执行一条指令，即单步执行;
IF:中断允许标志位。它用来控制8086是否允许接收外部中断请求。若IF=1，8086能响应外部中断，反之则屏蔽外部中断;
DF:方向标志位。在串处理指令中，每次操作后，如果DF=0，si、di递增，如果DF=1，si、di递减；注意此处DF的值是由程序员进行设定的 cld命令是将DF设置为0，std命令是将DF设置为1；
OF:溢出标志位。记录了有符号运算的结果是否发生了溢出，如果发生溢出OF=1,如果没有OF=0；
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/464/">«</a>
	<span class="pagination__item pagination__item--current">465/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/466/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>