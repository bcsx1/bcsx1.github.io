<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af32229ca69188161a5476683327baa8/" rel="bookmark">
			Mac虚拟机设置静态IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 我们经常在做开发的时候都需要模拟生产环境, 但是一台真正的服务器显然不适合我们做开发, 因为我们要经常切换环境, 部署东西, 卸载东西, 此时就有了虚拟机, 但我们经常会遇到这样的问题, 虚拟机关机后或者电脑断网后虚拟机的IP地址就会变, 而我们在项目中设置的IP地址也就得改, 我们ssh工具还得重新输入一次IP进行连接, 所以我们需要设置静态IP
步骤 操作系统: MacOS 10.15
虚拟机软件: VMware Fusion 11.5
假设我们虚拟机的IP要设置成192.168.100.xxx
设定本机vmnet8网卡信息 切换root用户
sudo su - 用VIM打开vmware配置网卡的配置文件
vim /Library/Preferences/VMware\ Fusion/networking 删除文件中与VNET_8有关项，然后复制如下代码,
# 关闭DHCP answer VNET_8_DHCP no answer VNET_8_DHCP_CFG_HASH A3774230C8D2DDCBD24757FE6CE211D7A00CAB13 # 设置子网掩码 answer VNET_8_HOSTONLY_NETMASK 255.255.255.0 # 设置IP网段 answer VNET_8_HOSTONLY_SUBNET 192.168.100.0 answer VNET_8_NAT yes answer VNET_8_VIRTUAL_ADAPTER yes # vmnet8的IP answer VNET_8_VIRTUAL_ADAPTER_ADDR 192.168.100.1 配置vmnet8的IP和网关 用VIM打开vmnet8的配置文件
vim /Library/Preferences/VMware\ Fusion/vmnet8/nat.conf 找到这两行做修改，一般就是前两行
ip = 192.168.100.2 netmask = 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af32229ca69188161a5476683327baa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6caf16a40bbd9e93cb34970e65f3cdc0/" rel="bookmark">
			C语言如何做到四舍五入保留小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中的格式化打印 :
例如： printf("%.2f",21.195); 输出是 21.20 四舍五入保留了 定义宏变量 #define 即符号常量 也能够四舍五入保留 而变量和常变量 并不四舍五入：
float a=21.195 ; const float b=21.195; printf("%.2f \n %.2f",a,b); 输出为 21.19 并没有四舍五入，而是直接截断了 变量和常变量 不四舍五入宏定义符号常量和实型常量 要四舍五入 今天做一个很简单的实验的时候，测试用例有一个一直有问题，便揣测应该是精度问题：
先看题目：
正常coding：
#include&lt;stdio.h&gt; #define PI 3.14 int main(void) { /*********Begin*********/ float r, h; //输入半径和高 scanf("%f,%f", &amp;r, &amp;h); float c, s, v; c = 2 * r * PI; s = 4*PI*r*r; v = PI*r*r*h; int x = round(v); printf("C1=%.2f\n", c); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6caf16a40bbd9e93cb34970e65f3cdc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b82a7a21e9253678f7a6564b26fe0b1/" rel="bookmark">
			经典游戏服务器端架构概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12 经典游戏服务器端架构概述 架构的分析模型 一. 讨论的背景 ​ 现代电子游戏，基本上都会使用一定的网络功能。从验证正版，到多人交互等等，都需要架设一些专用的服务器，以及编写在服务器上的程序。因此，游戏服务器端软件的架构，本质上也是游戏服务器这个特定领域的软件架构。
​ 软件架构的分析，可以通过不同的层面入手。比较经典的软件架构描述，包含了以下几种架构：
​ 1.运行时架构——这种架构关心如何解决运行效率问题，通常以程序进程图、数据流图为表达方式。在大多数开发团队的架构设计文档中，都会包含运行时架构，说明这是一种非常重要的设计方面。这种架构也会显著的影响软件代码的开发效率和部署效率。本文主要讨论的是这种架构。
​ 2.逻辑架构——这种架构关心软件代码之间的关系，主要目的是为了提高软件应对需求变更的便利性。人们往往会以类图、模块图来表达这种架构。这种架构设计在需要长期运营和重用性高的项目中，有至关重要的作用。因为软件的可扩展性和可重用度基本是由这个方面的设计决定的。特别是在游戏领域，需求变更的频繁程度，在多个互联网产业领域里可以说是最高的。本文会涉及一部分这种架构的内容，但不是本文的讨论重点。
​ 3.物理架构——关心软件如何部署，以机房、服务器、网络设备为主要描述对象。
​ 4.数据架构——关心软件涉及的数据结构的设计，对于数据分析挖掘，多系统协作有较大的意义。
​ 5.开发架构——关心软件开发库之间的关系，以及版本管理、开发工具、编译构建的设计，主要为了提高多人协作开发，以及复杂软件库引用的开发效率。现在流行的集成构建系统就是一种开发架构的理论。
二. 游戏服务器架构的要素 ​ 服务器端软件的本质，是一个会长期运行的程序，并且它还要服务于多个不定时，不定地点的网络请求。所以这类软件的特点是要非常关注稳定性和性能。这类程序如果需要多个协作来提高承载能力，则还要关注部署和扩容的便利性；同时，还需要考虑如何实现某种程度容灾需求。由于多进程协同工作，也带来了开发的复杂度，这也是需要关注的问题。
​ 功能约束，是架构设计决定性因素。一个万能的架构，必定是无能的架构。一个优秀的架构，则是正好把握了对应业务领域的核心功能产生的。游戏领域的功能特征，于服务器端系统来说，非常明显的表现为几个功能的需求：
​ 1.对于游戏数据和玩家数据的存储
​ 2.对玩家客户端进行数据广播
​ 把一部分游戏逻辑在服务器上运算，便于游戏更新内容，以及防止外挂。
​ 针对以上的需求特征，在服务器端软件开发上，我们往往会关注软件对电脑内存和CPU的使用，以求在特定业务代码下，能尽量满足承载量和响应延迟的需求。最基本的做法就是“时空转换”，用各种缓存的方式来开发程序，以求在CPU时间和内存空间上取得合适的平衡。在CPU和内存之上，是另外一个约束因素：网卡。网络带宽直接限制了服务器的处理能力，所以游戏服务器架构也必定要考虑这个因素。
​ 对于游戏服务器架构设计来说，最重要的是利用游戏产品的需求约束，从而优化出对此特定功能最合适的“时-空”架构。并且最小化对网络带宽的占用。
[图：游戏服务器的分析模型]
三. 核心的三个架构 ​ 基于上述的分析模型，对于游戏服务端架构，最重要的三个部分就是，如何使用CPU、内存、网卡的设计：
​ 1.内存架构：主要决定服务器如何使用内存，以保证尽量少的内存泄漏的可能，以及最大化利用服务器端内存来提高承载量，降低服务延迟。
​ 2.调度架构：设计如何使用进程、线程、协程这些对于CPU调度的方案。选择同步、异步等不同的编程模型，以提高服务器的稳定性和承载量。同时也要考虑对于开发带来的复杂度问题。现在出现的虚拟化技术，如虚拟机、docker、云服务器等，都为调度架构提供了更多的选择。
​ 3.通信模式：决定使用何种方式通讯。网络通讯包含有传输层的选择，如TCP/UDP；据表达层的选择，如定义协议；以及应用层的接口设计，如消息队列、事件分发、远程调用等。
​ 本文的讨论，也主要是集中于对以上三个架构的分析。
四. 游戏服务器模型的进化历程 ​ 最早的游戏服务器是比较简单的，如UO《网络创世纪》的服务端一张3.5寸软盘就能存下。基本上只是一个广播和存储文件的服务器程序。后来由于国内的外挂、盗版流行，各游戏厂商开始以MUD为模型，建立主要运行逻辑在服务器端的架构。这种架构在MMORPG类产品的不断更新中发扬光大，从而出现了以地图、视野等分布要素设计的分布式游戏服务器。而在另外一个领域，休闲游戏，天然的需要集中超高的在线用户，所以全区型架构开始出现。现代的游戏服务器架构，基本上都希望能结合承载量和扩展性的有点来设计，从而形成了更加丰富多样的形态。
​ 本文的讨论主要是选取这些比较典型的游戏服务器模型，分析其底层各种选择的优点和缺点，希望能探讨出更具广泛性，更高开发效率的服务器模型。
分服模型 一. 模型描述 ​ 分服模型是游戏服务器中最典型，也是历久最悠久的模型。其特征是游戏服务器是一个个单独的世界。每个服务器的帐号是独立的，而且只用同一服务器的帐号才能产生线上交互。在早期服务器的承载量达到上限的时候，游戏开发者就通过架设更多的服务器来解决。这样提供了很多个游戏的“平行世界”，让游戏中的人人之间的比较，产生了更多的空间。所以后来以服务器的开放、合并形成了一套成熟的运营手段。一个技术上的选择最后导致了游戏运营方式的模式，是一个非常有趣的现象。
[图：分服模型]
二. 调度架构 1.单进程游戏服务器
最简单的游戏服务器只有一个进程，是一个单点。这个进程如果退出，则整个游戏世界消失。在此进程中，由于需要处理并发的客户端的数据包，因此产生了多种选择方法：
[图：单进程调度模型]
​ a.同步-动态多线程：每接收一个用户会话，就建立一个线程。这个用户会话往往就是由客户端的TCP连接来代表，这样每次从socket中调用读取或写出数据包的时候，都可以使用阻塞模式，编码直观而简单。有多少个游戏客户端的连接，就有多少个线程。但是这个方案也有很明显的缺点，就是服务器容易产生大量的线程，这对于内存占用不好控制，同时线程切换也会造成CPU的性能损失。更重要的多线程下对同一块数据的读写，需要处理锁的问题，这可能让代码变的非常复杂，造成各种死锁的BUG，影响服务器的稳定性。
​ b.同步-多线程池：为了节约线程的建立和释放，建立了一个线程池。每个用户会话建立的时候，向线程池申请处理线程的使用。在用户会话结束的时候，线程不退出，而是向线程池“释放”对此线程的使用。线程池能很好的控制线程数量，可以防止用户暴涨下对服务器造成的连接冲击，形成一种排队进入的机制。但是线程池本身的实现比较复杂，而“申请”、“施放”线程的调用规则需要严格遵守，否则会出现线程泄露，耗尽线程池。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b82a7a21e9253678f7a6564b26fe0b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726063841362802e22d0b894cb26cdb8/" rel="bookmark">
			分享5个免费的Python学习网站，抓紧收藏吧~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近有好多人说刚开始学习，有哪些免费的学习网站可以自学一下。于是，趁着空闲的时间在各大网站上面梳理了一下，找出了5个比较好的学习网站，并且都是免费的，比较适合初学者了解一些基础语法、解决BUG问题。 如果是大佬的话了解一下就行了，废话不多说了直接上干货吧！ 1、Python 官方中文网站
官方网站不仅有基础语法参考、Python标准模块介绍，相关的教程也有，平时查接口文档什么的都是比较方便的。
网站地址：https://docs.python.org/zh-cn/3/ 2、w3school
这是个比较老的网站了，记得刚开始学编程的时候我经常在上面查找Html标签的应用。不过，Python的应用在上面也是有的，忘记了一些内置函数怎么用来这上面查一查还是比较Nice的。
网站地址：http://www.w3school.com.cn/ 3、菜鸟教程
这个也不错，只要是你是新手学习上面各类编程语言都有，包括数据库的安装使用等操作步骤都会一步一步的列出来。相信新手朋友看到这个网站肯定会非常喜欢的，想要什么信息直接搜索就成了。
网站地址：http://www.runoob.com/ 4、python Code Example
这是一个英文网站，有一些英文功底可以使用这个网站。主要是收集了大量的python模块的使用实例，使用时通过搜索模块名称来查找相关的实例来进行参考。
比如：可以搜索一下datetime是怎么使用的，就可以搜索一下…
可以直接定位到里面的某个函数是怎么使用的，搜索到之后照着写就成了。
网站地址：https://www.programcreek.com/python/ 5、LearnPython
这个网站也是个英文网站，里面包含了一些初级和高级用法，大佬们有需要也可以来尝试一下。
网站地址：https://www.learnpython.org/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08f12224298bfa1a2e085f05e2f50025/" rel="bookmark">
			RabbitMQ安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ安装与配置 基于centos系统安装RabbitMQ，本次笔记我使用的是Centos 7.3版本的阿里云服务器。
一般在服务器中，软件装在usr/local底下：
1.安装前准备 安装rabbitmq之前，先要确保我们的服务器中有erlang环境 yum remove erlang* //如果之前安装过erlang，先删除 这样提示则没有安装过erlang！
安装C++编译环境 //yum -y install make gcc gcc-c++ yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC unixODBC-devel httpd python-simplejson 出现complete！则安装成功。
下载erlang和rabbitMQ 先在usr/local/底下创建rabbitmq_erlang目录，用于下载rabbitmq和erlang安装包
mkdir rabbitmq_erlang //创建rabbitmq_erlang目录 cd rabbitmq_erlang //进入该目录下载安装包 //下载erlang wget http://www.erlang.org/download/otp_src_20.1.tar.gz //上述erlang下载不了携带下述=参数 wget --no-check-certificate http://www.erlang.org/download/otp_src_20.1.tar.gz //下载rabbitMQ wget https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.0/rabbitmq-server-generic-unix-3.7.0.tar.xz 此处注意：需要下载erlang和rabbitmq对应的版本，否则后续步骤会出错，此处我就是版本没对应导致后续步骤出问题，因此在此补充此笔记
https://www.rabbitmq.com/which-erlang.html //erlang和rabbitmq版本对应链接 2.安装erlang 解压erlang安装包 tar -xvf otp_src_22.0.tar.gz 进入解压文件夹 cd otp_src_22.0 指定安装目录及安装配置（需要先安装并配置JDK） //erlang指定安装在/usr/local/erlang目录，当然也可以替换到其他目录 ./configure --prefix=/usr/local/erlang --enable-smp-support --enable-threads --enable-sctp --enable-kernel-poll --enable-hipe --with-ssl --without-javac 当出现如下提示时，表示配置成功！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08f12224298bfa1a2e085f05e2f50025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f01665396b98ca65255adc59fff70b/" rel="bookmark">
			C&#43;&#43;类型转换运算符的重载,自增自减运算符的重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ C++里面各种各样的运算符都可以拿来重载,虽然不是所有的运算符都可以重载,但是绝大部分都是可以重载的,比方说这个类型转换运算符的重载,自增自减运算符的重载.
C++类型转换运算符的重载 我们知道C++中内置的一些类型之间是可以相互装换的：
int a; double b=3.14; a=(double)b3; 我们希望自己写的类也可以进行类型转化
（1）将其他类型转换为我们写的类类型：只需要在构造函数中添加该类型的参数，然后将该参数的值赋给成员变量
class Person { public: int age; Person(int i=0):age(i){ } }; Person p; p = (Person)4; （2）将自己的类类型转化为其他类型，需要重载类类型操作符，函数形式如：operator 类型名称() const{返回其他类型的变量}
class Person { public: int age; operator int() const{ return age; } }; Person p; p.age = 12; int a = (int)p; 上面的转换都是显示的转换，也可以写成隐式转换，Person p;p = 4;和Person p;p.age=12;int a = p;
这样直接的隐式转换有时候会在我们不经意间就实现了，甚至我们本不想让其进行转换，所以为了避免这种情况。C++允许在上面的构造函数或者重载类类型的方法前面加上explicit关键字，之后就不能进行隐式的类型转换了。
自增自减运算符的重载: 自增和自减代表着哪两个运算符呢?
自增:变量名"++"
自减:变量名"- -"
我们都知道自增运算符++、自减运算符--有前置/后置之分，为了区分所重载的是前,置运算符还是后置运算符，C++规定：
前置运算符作为一元运算符重载 重载为成员函数： T &amp; operator++(); T &amp; operator--(); 重载为全局函数： T1 &amp; operator++(T2); T1 &amp; operator—(T2); 后置运算符作为二元运算符重载，多写一个没用的参数： 重载为成员函数： T operator++(int); T operator--(int); 重载为全局函数： T1 operator++(T2,int ); T1 operator—( T2,int); 但是在没有后置运算符重载而有前置重载的情况下， 定义一个obj,在vs中，obj++ 也调用前置重载，而dev则令 obj ++ 编译出错 接下来我们来看几个代码例子: int main() { CDemo d(5); cout &lt;&lt; (d++ ) &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05f01665396b98ca65255adc59fff70b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90dcd2acfacddbaa2e693d93f40c4cd8/" rel="bookmark">
			npm 下载指定版本包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#查看npm源 npm config get registry #npm 原始的源（发布npm包的时候一定要切换成这个源 npm adduser/npm login/npm publish发布） npm config set registry https://registry.npmjs.org/ 查看全局安装的软件 npm list -g # 升级或安装 cnpm $ npm install -g cnpm --registry=https://registry.npmmirror.com $ npm config set registry https://registry.npmmirror.com npm下载指定版本 cnpm i @supermap/iclient-leaflet@10.2.1 npm查看历史版本 npm view axios versions
npm查看本地安装版本
npm ls axios
npm ls xxx -g (查看全局安装的)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce042b72c95c7219305aabeb4c95591/" rel="bookmark">
			引用和指针概念及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引用和指针 指针：指针是一个特殊的变量，它里面存储的的数值为内存里的一个地址，通过*访问内存地址所指向的值
引用：引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。
举一个简单的例子：
int main() { int a = 10; int&amp; ra = a; //定义引用类型，可以理解为ra就是a的一个别名 //打印a和ra的值，都是10 printf("%d\n", a); printf("%d\n", ra); return 0; } 引用特性：
1.引用在定义时必须初始化
2.一个变量可以有多个引用
3.引用一旦引用一个实体，就不能再引用另一个实体
4.常引用
普通引用：int a=10; int&amp; ra=a; 普通引用可以通过引用来修改变量的值，相当于int* const a 常引用：const int a=10; const int&amp; ra=a; 常引用不能通过引用来改变变量的值，相当于const int* const a 同类型的常引用：
int main() { const int a = 10; //int&amp; ra = a; //此时编译报错，因为a是常量，不能通过普通引用来引用a const int&amp; ra = a; //int&amp; ra=10; //编译也会报错，因为10为常量 const int&amp; b = 10; } 不同类型的常引用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce042b72c95c7219305aabeb4c95591/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a478f748fb535e7154dbcb9aa879f1/" rel="bookmark">
			神经网络基础学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络基础学习总结 一、基本认识 神经网络（nn），有建立在它之上的许多类型。卷积神经网络，循环神经网络等等，常用于视觉图像处理领域的是卷积神域网络（cnn）。LeNet：是一种的用于处理手写数字识别的经典卷积神经网络，他的问世，写数字识别准确率得到大大的提高，取得了巨大的成功。神经网络的本质是对回归任务做回归。 二、卷积神经网络基本组成 感知机 由一堆线性参数w和偏置参数b，将输入它的所有参数与w相乘再加上参数b，再由激活函数激活输出。
卷积层 用多层卷积核对图像进行卷积运算。提取图像特征。
池化层 分为均值池化和最大池化。在保留图像特征的同时，极大的减少了计算量and防止过拟合现象。
全连接层 传统的神经网络架构。它的每一层中的每一个感知机都与前一层每一个感知机相连。由于他这样的特性会使得他的输出会与所有的数据相关，卷积池化解决了这样的问题。
现一般用于网络最后几层。
激活函数 Sigmoid：容易梯度过小，不利于反向传播。ReLU：解决了梯度过小消失的问题。函数简单，速度快。非线性不足。softmax：解决了归一化问题。一般最后全连接使用。 三、神经网络模型训练流程 （一）数据准备 数据集：神经网络训练需要大量的数据，要满足丰富（场景、明暗）、复杂（遮挡）、随机（角度）等要求。网络上由许多公共数据集。数据增强：由程序随机对数据进行各种处理，可以大大增强数据量。标注：数据集还需要标注，对于图像分类来说，标注就是他是哪一个分类。 （二）模型搭建 设计针对任务的神经网络模型。有多少层，各层怎样安排等等。在计算速度和精度之间取得平衡。Python可以采用动态图的写法。选择损失函数以及后续返向传播等。设置优化器（优化算法），控制学习率，学习步长。
（三）模型训练 大量数据进入神经网络计算输出到损失函数，损失函数与标签进行比较计算出损失，再由反向传播与梯度下降，调整神经网络各个参数，直至损失越来越小。（每次下降由步长控制。可设计计算法控制步长，防止局部最优，提高训练效率）当最后训练模型准确率达到可接受程度，训练结束。
四、神经网络网络设计技巧 卷积核 3-3 小卷积核多次卷积，参数量小，效果好。除去第一层会采用大卷积核一般也不会超过7*7，其它层均使用3-3或者1-1卷积核。巧妙的使用1-1的卷积核来进行通道降维和升维。 堆叠 神经网络层数堆叠很多时，要使用残差连接。至少不比原来差层数深 感受野大；层数浅 感受野小。网络通常为block堆叠，每一个block都是一个最小重复单元（由多个卷积组成）。 其他 通常在进行下采样的时候会进行channel数量的翻倍。在网络的特征提取部分，使用最大池化。在分类部分，使用平均池化。 五、算法选择 （一）损失函数 损失函数（loss function）就是用来度量模型的预测值f(x)与真实值Y的差异程度的运算函数。
最小二乘法&amp;均方误差（mean-squared error)极大似然估计法&amp;交叉熵法（计算上相同，前者由概率论导出；后者由信息论导出） （二）优化算法 BGD、SGD、MBGD分别为批量梯度下降算法、随机梯度下降算法、小批量梯度下降算法。这三个优化算法在训练的时候采用的数据量不同，但是他们在进行参数优化的时候是相同的。基本思想是：先设定一个学习率，参数沿梯度的反方向移动。
对超参数学习率比较敏感（过小导致收敛速度过慢，过大又越过极值点）。学习率除了敏感，有时还会因其在迭代过程中保持不变，很容易造成算法被卡在鞍点的位置。在较平坦的区域，由于梯度接近于0，优化算法会因误判，在还未到达极值点时，就提前结束迭代，陷入局部极小值。 Momentum（动量算法）：从梯度方向优化的算法。每下降一步都是由前面下降方向的一个累积和当前点梯度方向组合而成。
NAG算法，它是动量算法的一种优化。
AdaGrad算法是通过参数来调整合适的学习率，是能独立自动调整模型参数的学习率，对稀疏参数进行大幅更新和对频繁参数进行小幅更新。
RMSProp算法通过修改AdaGrad得来，其目的是在非凸背景下效果更好。
SGD，NAG以及Momentum对于模型中的不同参数，他们均使用相同的学习率，这会导致那些应该更新快的参数更新的慢，而应该更新慢的有时候又会因为数据的原因的变得快。不适合稀疏的数据。
稀疏的数据应该使用Adaptive方法（Adagrad、AdaDelta、Adam）。同样，对于一些深度神经网咯或者非常复杂的神经网络，使用Adam或者其他的自适应（Adaptive）的方法能够更快的收敛。
参考：优化器(Optimizer)（SGD、Momentum、AdaGrad、RMSProp、Adam）
六、调参 使用公开的模型预参数进行训练，加快收敛。数据集，全、复杂、样本量大，使用数据增强。设定恰当的lr（学习率）：过小导致收敛速度过慢，过大又越过极值点，或使用lr自适应的优化算法。batchsize（样本批次容量）：不能太大也不能太，一般几十到几百。epoch-number（训练次数）：观察accuracy/loss，前面快，后面很慢，十几轮一直上下浮动基本到极限了。使用可视化工具观察。 七、LeNet def forward(self, x): #[ N ,1,28,28] x = self.conv1(x) #[ N ,6,24,24] x = F.sigmoid(x) #[ N ,6,24,24] x = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35a478f748fb535e7154dbcb9aa879f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544827609382c95bd22392f588bd3c59/" rel="bookmark">
			Linux df -h
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 df -h ：显示目前在Linux系统上的文件系统的磁盘使用情况统计。
Filesystem：表示该文件系统位于哪个分区，因此该列显示的是设备名称；Used：表示用掉的磁盘空间大小；Available：表示剩余的磁盘空间大小；Use%：磁盘空间使用率;Mounted on：文件系统的挂载点，也就是磁盘挂载的目录位置。所谓的挂载就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说进入该目录就可以读取该分区的意思，这个动作我们称为挂载，那个进入点的目录我们称为挂载点。 参考： 1.Linux的df -h命令_秃秃秃秃哇的博客-CSDN博客
2.linux挂载点是什么-linux运维-PHP中文网 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bda206dc3048971d4354bcf1ac1e12fb/" rel="bookmark">
			几种相机模型：针孔相机模型、双目相机模型、RGB-D相机——SLAM学习笔记5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几种相机模型：针孔相机模型、双目相机模型、RGB-D相机 针孔相机模型双目相机模型RGB-D相机模型 针孔相机模型 针孔相机是最简单的相机，很多相机也可以看作是针孔相机来进行处理。如图1所示，空间点P经过小孔O投影后，得到P’。建立相机坐标系O-x-y-z，投影P’落在物理成像平面O’-x’-y’-z’上。令P的坐标为 ，P’的坐标为 ，根据相似三角形的关系：
其中f为物理成像平面与小孔之间的距离（焦距）。负号表示成像是倒立的，为了方便表示，可以等价地将成像平面对称地放到相机前方，如图1所示。(1.1)可以表示为：
则X’，Y’可以表示为：
为了将空间中的点转换为图像上的像素点，定义如下像素坐标系，原点o’位于图像的左上角，u轴向右与x轴平行，v轴向下与y轴平行。显然成像平面与像素平面之间，只相差了一个缩放和原点的平移。假设，像素坐标系在u轴上缩放了a倍，在v轴上缩放了β倍，原点平移了 ，那么P’在像素坐标系下的坐标为：
将(1.4)代入(1.3)中，可以得到：
其中 ，并将(1.5)写成矩阵的形式：
进一步地可以写成：
其中：
定义为相机的内参矩阵，相机的内参在出厂之后一般都是固定的。
上述的P是基于相机坐标系的坐标，但实际上由于相机在运动，P的相机坐标应该转换到世界坐标系下Pw更为方便。
双目相机模型 单目相机在投影过程中丢失了空间点的深度信息。参考人眼的工作原理，人眼可以根据左右眼看到的景物差异判断物体与我们之间的距离，我们理所应当地想到利用双目相机来识别3D空间。
如图所示，两眼相机的光圈中心之间的距离 O L O R O_LO_R OL​OR​称为基线（b）,f为焦距，方框为成像平面，成像为 P L P R P_LP_R PL​PR​
根据图中 Δ P P L P R \Delta PP_LP_R ΔPPL​PR​和 Δ P O L O R \Delta PO_LO_R ΔPOL​OR​ 的相似关系得到：
其中: d = u L − u R d=u_L-u_R d=uL​−uR​，称为视差。
很容易能够想明白视差d与物体距相机的距离成反比，可以料想到当物体在无穷远处，视差为0，这一点在公式中也能体现出来。
同时基线越长，双目相机能够测到的距离也就越远。拿人的眼睛来举例，人的眼睛基线并不长，对于飞机等非常远的物体，把握距离便不准确。
但是误差d并不好测量啊，而RGB-D相机则能够更加主动地测量深度。
RGB-D相机模型 RGB-D相机按照原理主要可以分成两大类，包括：
通过红外结构光（Structured Light）测量像素距离。但由于红外结构光本身的原因，他容易受到日光或其他传感器的干扰。同时对于透明材质，由于其不反射红外光，因此无法测量透明材质物体。通过飞行时间TOF(Time of Flight)测量像素距离。 此外，RGB-D相机在成本和功耗上相较于前两种相机也有一定劣势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bda206dc3048971d4354bcf1ac1e12fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/267bf646e217076831b8b54f7c67b741/" rel="bookmark">
			npm 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm 常用命令 配置相关查看 npm 配置列表安装 module 到指定目录下 配置相关 查看 npm 配置列表 npm config list 安装 module 到指定目录下 npm install --prefix [目录名字] [module] F:\Github\serverless-demo\test-mysql&gt;tree 文件夹 PATH 列表 卷序列号为 0C01-1963 F:. ├─db ├─src └─vpc F:\Github\serverless-demo\test-mysql&gt;npm insatll --prefix src mysql2 Unknown command: "insatll" Did you mean this? npm install # Install a package To see a list of supported npm commands, run: npm help F:\Github\serverless-demo\test-mysql&gt;npm install --prefix src mysql2 added 15 packages, and audited 16 packages in 4s found 0 vulnerabilities F:\Github\serverless-demo\test-mysql&gt;tree 文件夹 PATH 列表 卷序列号为 0C01-1963 F:.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/267bf646e217076831b8b54f7c67b741/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca891308f3ef48fe449906b13d723568/" rel="bookmark">
			记录integral中遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.van-field没有样式 打开控制台发现标签中的样式在控制台中都没有相应的值，猜想应该是vant的样式没有起作用，在网上查了发现没有相关资料比较少，看到这篇博文之后有一些启发
https://blog.csdn.net/ccmm_/article/details/122194381
看了一下官网精心了相应的操作之后，问题解决
2. 修改vant-field中placeholder字体的大小 在网上搜了没有什么好的方法，最后还是用样式穿透来解决问题
3.关于van-uploader上传文件的问题 3.1打印form为空对象 度娘一下发现formData需要使用FormData.get等方法获取相关值。
可以参考https://segmentfault.com/q/1010000010087308
3.2 表单数据请求需要与其余的类型的数据请求分开处理 请求之前打印为true，拦截处理的地方，打印为false，处理之后问题解决
3.3对于上传多张图片的处理 4.关于vant表单校验和elementui中表单校验的区别 elementui允许将数据和规则统一绑定在form标签上
vant则是将数据和规则分别绑定在输入框标签上
elementui中对表单的校验处理：
vant中对表单的校验处理相对于elementui则具有一定的差异：
附：async/await对错误情况的处理
5.利用window.scrollTo将页面滚动到指定的位置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7f007587fb1ded412ea171df8d7e46/" rel="bookmark">
			小程序，原生app，webapp对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		➢ 小程序
小程序是一种用户只需要扫描二维码或搜一搜即可打开应用，无需下载安装即可使用的手机“应用”。开发是基于统一框架进行的，框架提供了标准界面模板，通过提供本地的API供H5上的JS调用，但运行比H5更顺畅。
下面列出小程序明显的几点优缺点。
小程序的优点：
1．无需下载安装，无需注册，即开即用，用完就走，不占用手机内存，省流量，省安装时间；
2．打开速度比H5还快，体验上接近原生App；
3．跨越安卓和苹果平台，开发成本比App低，可以将更多财力、人力、精力放在产品运营和内容本身；
4．安卓手机可以直接添加手机桌面，看上去和App差不多；
5．相较于各种App，微信小程序Ul和操作流程会更统一，降低了用户的使用难度；
6．相较于原生App，推广更简单，更省成本。
小程序的缺点：
1．只能分享给群、朋友，不能分享到朋友圈；
2．二维码长按识别之后不能直接进入小程序，只能通过微信扫一扫才能进入到小程序；
3．没有推送（push）功能，不能给用户推送消息；
4．所能获取的用户数据非常有限，基本就是头像、昵称等，没有用户体系；
5．不需要注册，用完即走，没办法多任务处理；
6．不能做游戏；
7．小而美，做垂直，功能复杂度有限制。
➢ 原生App
原生App也称为Native App，基于不同智能手机操作系统，如iOS、Android、Windows，采用不同的语言和框架进行开发，该模式通常是由“服务器+App客户端”两部分构成，App应用所有的Ul元素、数据内容、逻辑框架均安装在手机终端上，才可以使用。
原生App与小程序几点对比：
1）小程序开发比原生App更简单，开发周期更短。小程序提供框架和API，基于HTML5进行开发，对接开发者现有的App后台的用户数据，其开发难度相对App较低。
2）小程序开发成本比原生App更低。原生App开发需要的人力、物力和时间成本都比较高。
3）小程序可以满足一些简单的基础应用，低频次及偏向于线下和场景生活服务类的轻应用，餐饮、快递等行业其受欢迎程度高。而对于一些需要大量计算的功能类应用，如图片处理或文档编辑，小程序是无法满足的，只能用原生或者WebApp去实现。
4）原生App的Ul、UE可以设计得更加人性化，更绚丽，功能的完善完全取决于开发者的想象力和技术实力。对系统接口的调用更为简单，一些功能比如AR（增强现实技术）、语音识别等功能，App能够在交互、视觉等用户体验上满足用户高要求。对于更丰富、更细化、更个性化的功能，是需要更大容量实现，这就需要在App上去承载，而小程序作为轻量级应用是无法满足的。
5）原生App应用可以在App Store、Android市场、360手机助手、百度应用、安全管家等应用市场进行下载安装。微信小程序，只能通过二维码或搜索小程序的名称，以及微信群或好友分享获取应用；另外微信公众号关联了小程序，那么在公众号的介绍页面，才会出现一个相关小程序的模块。只要点击相应的图标，就能轻松打开。
6）安装流程，小程序更简单。打开微信扫描二维码即可进入小程序。App需要扫码或者搜索进行下载并安装后才可以使用。
7）原生App安装在手机上会占用一定的空间，且随着功能的不断完善和更新其占用的资源也会更多。而微信小程序无须下载，其内容和功能都不占用手机内存；但微信本身比较臃肿，好友会话、群消息、朋友圈等功能堆积会占用大量的手机内存容量。
8）功能扩展性，App更强。
9）App的维护成本较高，需要针对不同操作系统做兼容性的开发，且需要用户自行升级。小程序运行于微信平台，大部分的维护工作由腾讯完成，其维护成本、周期和流程简单，更新也主要在微信后端完成，不存在操作系统和浏览器兼容方面的问题。
10）App用户忠诚度更高，因为App内容全面，用户主动选择，App获取门槛高，二次消费门槛很低。小程序的内容碎片化，用户被动接受，用完就退出程序，虽然首次消费门槛低，但后续消费门槛无法降低，用户由于难以找到小程序而选择放弃。
11）小程序只是简化版的App，并不能涵盖App的全部内容。微信对小程序的内存大小限制在2MB，只能保存最基础的功能。App更适合高频场景的服务，天然具备独立发展成生态的潜力，可以自成一套生态体系。即使小程序在用户体验上大大增强，这些也只是增量，App还是主要的阵地。
12）小程序由于微信本身的传播能力和获客能力，可以让互联网创业公司减少试错成本，提高产品的成功率。但微信缺少小程序的展示位，小程序难以获得好的位置资源，对于初创品牌来说如何让用户搜索到并引导用户点击前往是一大难题。
➢ WebApp
WebApp也就是我们说的HTML5 App，是一种框架型App开发模式。具有跨平台的优势，该开发模式通常由“HTML5云网站+App应用客户端”两部分构成，App应用客户端只需安装应用的框架部分，应用所有界面都是通过HTML5去实现，每次打开App的时候，都是去云端获取数据呈现给手机用户。
WebApp与小程序几点对比：
1）运行环境的不同。HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器。小程序的开发过程中会用到HTML5相关的技术（并非全部），最后的发布上线需要微信审核，微信在不更新自身软件的情况下可以将小程序更新到自身软件内，这就联想到了React Native框架，并且已经有开发者在微信小程序的开发工具源码中发现使用了React和NodeWebkit库。小程序的运行环境很有可能是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。
2）开发成本不同。微信小程序的开发直接使用微信团队提供的开发工具，并规范了开发标准，将前端常见的HTML、CSS变成了自定义的WXML、WXSS, WXML中标签，官方文档中也有明确的使用介绍，相信上手应该是非常容易的；WXSS、JSON和JS文件中的写法稍有限制，但整体相差不多。在统一了这些标准之后，作为一个开发者，你会发现，自己只要专注写程序就可以了。并且在使用一些API时，不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG，对一个HTML5 web开发，除了要了解熟悉复杂的开发工具（vscode、subIimtext、Atom等），还要学习前端框架（AnguIar、react、vue、backbone等）、模块管理工具（Webpack、Browserify等）、任务管理工具（Grunt、GuIp等），小到UI库选择、接口调用工具（ajax、Fetch Api等）、浏览器兼容性等都要我们一一考略，尽管这些工具可定制化非常高，并且提高了开发者的开发效率，但我相信项目开发的配置工作已经消耗了不少精力。项目中使用的各种外部库、各种工具的版本迭代、版本升级所产生的成本应该也不低。可见微信小程序的开发成本确实相比以往的web开发低很多。
3）获取系统级权限的不同。微信小程序相对于HTML5 web应用能获得更多的系统权限，比如网络通信状态、数据缓存能力等，这些系统级权限都可以和微信小程序无缝衔接，也就是官方宣称的拥有Native App的流畅性能，而这一点恰巧是HTML5 web应用经常被诟病的地方，这也是HTML5的大多应用场景被定位在业务逻辑简单、功能单一的原因。
4）运行流畅度，无论对于用户还是开发者来说，都是最直观的感受。HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，体验总是不尽人意，需要不断地对项目进行优化来提升用户体验。但是由于微信小程序运行环境独立，尽管同样用html+css+js去开发，但配合微信的解析器最终渲染出来的是原生组件的效果，自然体验上更流畅。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01560fd5b5d320d5bb5b14bf3f10c7eb/" rel="bookmark">
			新装的TensorFlow出现protobuf相关错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天刚装了个TensorFlow2.4，import tensorflow的时候，出现如下错误
TypeError: Descriptors cannot not be created directly.
If this call came from a _pb2.py file, your generated code is out of date and must be regenerated with protoc &gt;= 3.19.0.
If you cannot immediately regenerate your protos, some other possible workarounds are:
1. Downgrade the protobuf package to 3.20.x or lower.
2. Set PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=python (but this will use pure-Python parsing and will be much slower).
这是由于我们用pip安装tensorflow的时候，安装依赖包protobuf的版本过高造成的。新装的pytorch也会有这样的问题。
卸掉原来的，在重新装一个指定版本的就行了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01560fd5b5d320d5bb5b14bf3f10c7eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02521b15ffbfb2bf2859ee8a3f749766/" rel="bookmark">
			PVT(Pyramid Vision Transformer: A Versatile Backbone for Dense Prediction without Convolutions)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 网络框图 1.输入一张 H × W × 3 H \times W\times 3 H×W×3的图片，经过一个PatchEmbeeding将其分割成 H W 4 2 \frac{HW}{4^2} 42HW​ patches,每一个Patch大小是 4 × 4 × 3 4\times 4 \times 3 4×4×3,经过一个Linear Projection 得到embeeding patches ： H × W 4 2 × C 1 \frac{H\times W}{4^2}\times C_1 42H×W​×C1​,之后通过一个有 L 1 L_1 L1​层的encoder， 输出的特征被reshape为3D特征 F 1 F1 F1 （ H 4 × W 4 × C 1 \frac{H}{4}\times \frac{W}{4}\times C_1 4H​×4W​×C1​ ).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02521b15ffbfb2bf2859ee8a3f749766/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7eedbee4eaacc31d726459445027c54/" rel="bookmark">
			5.RTT-UART-DMA 接收及轮询发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上期博客分享了最常用的中断接收及轮询发送，这也是裸机上最常用的一种方式，那么本期就上上强度学习RTT-内核-消息队列结合DNA接收及轮询发送。所以在看本期博客前需要新引入一个概念“消息队列”。
1.RTT内核-线程间通信-消息队列的引入 消息队列能够接收来自线程或中断服务例程中不固定长度的消息，并把消息缓存在自己的内存空间中。其他线程也能够从消息队列中读取相应的消息，而当消息队列是空的时候，可以挂起读取线程。当有新的消息到达时，挂起的线程将被唤醒以接收并处理消息。消息队列是一种异步的通信方式。
如下图所示，线程或中断服务例程可以将一条或多条消息放入消息队列中。同样，一个或多个线程也可以从消息队列中获得消息。当有多个消息发送到消息队列时，通常将先进入消息队列的消息先传给线程，也就是说，线程先得到的是最先进入消息队列的消息，即先进先出原则 (FIFO)。（注意：想要了解更多的详细说明，请看官方手册。路径如下图。）
2.uart2.c编写 利用上一节博客的工程模板继续改写。依旧是修改uart2.c即可。
/* * 程序清单：这是一个串口设备 DMA 接收使用例程 * 例程导出了 uart_dma_sample 命令到控制终端 * 命令调用格式：uart_dma_sample uart2 * 命令解释：命令第二个参数是要使用的串口设备名称，为空则使用默认的串口设备 * 程序功能：通过串口输出字符串"hello RT-Thread!"，并通过串口输出接收到的数据，然后打印接收到的数据。 */ #include &lt;rtthread.h&gt; #define SAMPLE_UART_NAME "uart2" /* 串口设备名称 */ /* 串口接收消息结构*/ struct rx_msg { rt_device_t dev; rt_size_t size; }; /* 串口设备句柄 */ static rt_device_t serial; /* 消息队列控制块 */ static struct rt_messagequeue rx_mq; /* 接收数据回调函数 */ static rt_err_t uart_input(rt_device_t dev, rt_size_t size) { struct rx_msg msg; rt_err_t result; msg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7eedbee4eaacc31d726459445027c54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10e9d56c5b2c5fa2af299a1f11c27a72/" rel="bookmark">
			【FPGA】一、FPGA简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
一、FPGA
简介
相关名词解释
FPGA基本构造
FPGA开发流程
硬件资源介绍
二、开发工具介绍
VScode Quartus II Vivado ModelSim Visio 总结
一、FPGA 简介 FPGA是Field Progammable Gate Array的简称，也就是现场可编程门阵列。它是在PAL（可编程阵列逻辑）、GAL（通用阵列逻辑）等可编程器件的基础上进一步发展的产物。它是作为专用集成电路（ASIC）领域中的一种半定制电路而出现的，其内部的大部分电路功能都可以根据需求进行更改，即解决了定制电路的不足，又克服了原有可编程器件门电路数有限的缺点。
与传统模式的芯片设计相比，FPGA的涉笔并非单纯局限于研究以及设计芯片，而是针对较多领域产品都能借助特定芯片模型予优化设计。常见FPGA的应用领域有算法加速、视频图像处理、通信领域、医疗领域以及安防领域等。自Xilinx在1984年创造出FPGA以来，这种可编程逻辑器件凭借性能、上市时间、成本、稳定性和长期维护方面优势明显，在通信、医疗和安防等领域占有一席之地。
相关名词解释 说明：
PLL：可用于稳定时钟，时钟分频、倍频
IP：相当于第三方库文件
软IP核：由自己设计编写
硬IP核：集成好的IP核
FPGA基本构造 简化的FPGA基本结构由6部分组成，分别是可编程输入/输出单元、基本可编程逻辑单元、嵌入式块RAM、丰富的布线资源、底层嵌入功能单元和内嵌专用硬核。
FPGA开发流程 一般来说，FPGA的设计开发流程包括设计输入、RTL功能仿真、分析综合、布局布线、时序仿真、时序分析和上板验证等几个步骤。
说明： ① 设计输入：通过某些规范的描述方式，将设计者构思输入给EDA工具；
② RTL仿真：功能仿真，运营专门的仿真工具，验证设计的逻辑功能是否正确；
③ 设计综合：运用对应的EDA工具，将设计转化成逻辑门级别电路；
④ 布局布线：在指定器件上将设计的逻辑电路实现；
⑤ 时序仿真：将布局布线的时延信息反标注到设计网表中所进行的仿真，也叫后仿真；
⑥ 时序分析：为了保证设计的可靠性，在时序仿真后还要做一下验证；
⑦ 上板验证：将生成的配置文件写入芯片进行测试；
硬件资源介绍 我这里使用的是CycloneIV系列的EP4CE6F17C8这款FPGA开发板，如图所示：
二、开发工具介绍 说明：开发工具对于初学者来说选择一款就可以了，比如你用的哪家的开发板就可以选择相应的开发工具，有些EDA综合工具也自带代码编辑器和仿真器，如果够用就没必要装第三方仿真工具了。比如用Xilinx的开发板，就可以选择Vivado软件，这款软件自带代码编辑器和仿真工具。
VScode 官网下载地址：https://code.visualstudio.com
Visual Studio Code（简称VS Code)是Microsoft在2015年4月30日Build开发者大会上正式宣布一个运行于Mac OSX 、Windows和Linux之上的，针对与编写现代Web和云应用的跨平台源代码编辑器。它具有对JavaScript，TypeScript和Node.js的内置支持，并具有丰富的其他语言（例如C++，C#，Java，Python，Verilog）和运行时扩展的生态系统。 Quartus II Quartus II 是Altera公司推出的综合性CPLD/FPGA开发软件，软件支持原理图、VHDL、VerilogHDL等多种设计输入形式，内嵌自有的综合器以及仿真器，可以完成从设计输入到硬件配置的完整PLD设计流程。
Quartus II 提供了完全集成且与电路结构无关的开发包环境，具有数字逻辑设计的全部特性，包括：可利用原理图、结构框图、VerilogHDL、AHDL和VHDL完成电路描述，并将其保存为实体文件；此外，Quartus II 还可以与VScode、Modelsim关联使用，给开发人员提供了软件使用的便利性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10e9d56c5b2c5fa2af299a1f11c27a72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a998df81e2b296a94242975772b90ae4/" rel="bookmark">
			git 中stash的实用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用git协同开发工具的同学应该都知道，在开发过程中我们需要经常切换分支，例如正在某一个分支下做需求时候，在该需求还未完成时就需要在另外一个分支下进行问题的修改，如果直接checkout切换分支会有冲突，会导致切换不成功，但是又不想将当前的做的修改复原，于是想到将当前的改动暂时保存下来，然后切换到另外一个分支去修改问题，当问题修改完成了之后将分支切换回来，然后再将之前保存的改动释放即可继续对需求进行开发了。
以上的存储在git中提供了stash命令进行存储。
1. 存储当前分支下的所有改动（git stash） 如图上所示 ，使用git status 看到当前修改了test.txt文件，若要将该修改保存下来，直接使用git stash命令就可以了。如果想要 给当前压栈存储的修改添加说明信息（如果没有指定信息，则说明信息为最新的commit信息），使用git stash -m "存储的信息"，引号内为该次存储的命名。如下图所示：
2.查看所有的存储列表（git stash list ） 如上图所示，stash@{0}和stash@{1}分别是两次保存的修改，stash@{0}是最新的一次提交。
3.释放最近一次保存的内容，并且将该次保存的内容出栈（即将栈顶出栈，释放最近一次保存的内容后将该次保存内容删除）（git stash pop） 如上图所示，将最近一次存储释放之后，使用git stash list 查看存储列表，已经由原来的两条存储变成了一条。
4. 应用某一次的存储内容，但不删除改内容（即该存储的内容还是存储在栈内 git apply） 例如 ： git stash apply stash@{0}
就是将存储号为stash@{0}的存储内容释放出来，但是该存储还是被存储在栈内，没有被删除。
5. 存储指定的文件修改（git stash push .../.../ .../.../ .../.../） /.../...为你想要存储的修改的文件路径，当你修改了很多文件，但是你只想存储部分修改的文件，即可在git stash push 后面添加路径，如果是多个文件，在这些文件路径之间添加空格即可。
6.查看某一个压栈修改了哪几个文件（git stash show stash@{0} ） 当存储的修改过多时，你可能会忘记某次存储修改了什么文件，想要查看某次存储修改了哪些文件可以使用git stash show stash@{0}命令，stash@{0}为最近存储的修改，想要看其他的存储只需要改stash@{0}的数字，如stash@{5}.如上图我是先使用git stash list 查看存储列表，然后使用git stash show stash@{0}命令查看第一个修改，可以看到在最近的一次修改存储中我只修改了一个文件test.txt。
7.查看指定存储的修改内容（git stash show -p stash@{0}） 如果想查看某次存储修改的所有内容，而不是仅仅查看修改了什么文件，例如查看最近一次存储修改的所有文件和内容，可以使用git stash show -p stash@{0}命令查看。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a998df81e2b296a94242975772b90ae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60276c7d4f7ed187515c15cfc8a092b8/" rel="bookmark">
			用vue写一个tabs切换，控制样式变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果图
&lt;block v-for="(item,i) in cateList" :key="i"&gt; &lt;view :class="['left-scroll-view-item',i === active ? 'active' : '']" @click="activeChanged(i)"&gt; {{item.cat_name}} &lt;/view&gt; &lt;/block&gt; data() { return { cateList: [], active: 0, }; }, methods: { activeChanged(i) { this.active = i } } cateList是从后端获取的数据
scss语法 自己微调
.left-scroll-view-item { background-color: #F7F7F7; line-height: 120rpx; text-align: center; font-size: 24rpx; &amp;.active { background-color: #fff; position: relative; &amp;::before { position: absolute; content: ''; display: block; width: 6rpx; height: 60rpx; background-color: #C00000; top: 50%; left: 0%; transform: translateY(-50%); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c2615ac0a0d57aa0a139ca9c7ee72f/" rel="bookmark">
			ubuntu上给软件添加快捷方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建快捷方式软件位WindTerm
1、在/usr/share/applications下创建WindTerm.desktop
cd /usr/share/applications sudo gedit WindTerm.desktop 2、在WindTerm.desktop添加以下内容
[Desktop Entry] Version=1.0 Type=Application Name=WindTerm GenericName=Text Editor Comment=Sophisticated text editor for code, markup and prose Exec=/home/tt/tools/WindTerm_2.5.0/WindTerm Terminal=false MimeType=text/plain; Icon=/home/tt/tools/WindTerm_2.5.0/windterm.png Categories=TextEditor;Development; StartupNotify=true Actions=Window;Document; Name为软件名字，Exec软件所在路径，Icon是软件图标
3、配置完成后，按下windown键搜索Name里的名字拖拽到桌面即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2060603eb32c9a376ad47a726a28dbb4/" rel="bookmark">
			音频处理整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 振幅与dB的转换关系(链接) dB = 20*log10(x) = 10*log10(Y) x: 表示振幅 Y: 表示能量 Y = x*x = x^2 2 提取Mel谱的方法(链接) 做STFT得到复数矩阵将幅度转成分贝(db) 问：如果这里在mel spectrogram里面就把幅度转成db了，
那Log_mel_spectrogram跟它又有什么区别呢？将频率转到mel-scale def log_mel_spectrogram(audio: Union[str, np.ndarray, torch.Tensor], n_mels: int = N_MELS): """ Compute the log-Mel spectrogram of Parameters ---------- audio: Union[str, np.ndarray, torch.Tensor], shape = (*) The path to audio or either a NumPy array or Tensor containing the audio waveform in 16 kHz n_mels: int The number of Mel-frequency filters, only 80 is supported Returns ------- torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2060603eb32c9a376ad47a726a28dbb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4d4f039c0a7460c8735285758da149b/" rel="bookmark">
			C# 解决 https请求 ssl证书问题，看我一篇通通解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说，直接上代码，实干兴邦，空谈误国！光说不贴源代码更是耍流氓！
针对旧版本的接口框架,.netformwork4.5以下，加上传统的ssl机制即可解决问题。
针对.net core版本的框架，采用ssl证书验证回调的方式，其中方案二和方案三同属于一种解决方式，方案三的更直接明了。
代码实测的框架分别为netformwork4.5、.net core3.1，完美解决问题。如有纰漏，欢迎各路大神不吝赐教，多多交流分享哈。
//ssl证书请求无效的问题解决方案 //******** //方案一，netformwork //关于ServicePointManager.SecurityProtocol的设置是解决问题的关键。 ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls; //上述代码放在请求之前 HttpWebRequest request = (HttpWebRequest)WebRequest.Create ("https://www.baidu.com"); request.Timeout = 15000; request.ReadWriteTimeout = 20000; request.KeepAlive = true; //******** //方案二 private static bool RemoteCertificateValidate (object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors error) { return true; } ServicePointManager.ServerCertificateValidationCallback += RemoteCertificateValidate; //上述代码放在请求之前 HttpWebRequest request = (HttpWebRequest)WebRequest.Create ("https://www.baidu.com"); request.Timeout = 15000; request.ReadWriteTimeout = 20000; request.KeepAlive = true; //******** //方案三，.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4d4f039c0a7460c8735285758da149b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b785cdbc37da57ce4e5c54a66d23c22/" rel="bookmark">
			ajax通过get方式实现前后端连接交互，传输数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ajax ：async JavaScript and xmlasync：异步xml：闭合标签 1、向后端发起请求的步骤： （1）向后端发起请求，第一步：创建一个XMLHttpRequest构造函数，
//向后端发请求 //1.创建对象XHR 用new创建，new XMLHttpRequest let xhr = new XMLHttpRequest()//具体实现ajax的一个构造函数，方法 console.log(xhr) 结果：
结果返回一个XMLHttpRequest对象，对象里面有很多方法； （2）配置 ：open（）方法
open（请求方式、请求地址、是否异步）请求方式分为：GET、POST等GET方式：是用来从服务器上获取数据；POST方式：是用来向服务器传递数据，是携带数据信息的；请求地址：这里我们以向后端获取1.txt文件为例，下面是1.txt文件地址获取方式；是否异步：不写就是异步； 1.txt文件地址获取方式：
因为txt文件不能通过VScode在浏览器直接打开，但是同一个文件夹下的ajax.html文件可以打开，所以我们可以先将ajax.html打开，然后发现这个地址后面就是ajax：文件夹名，ajax.html：文件名，因为1.txt文件和ajax.html在同一个目录下，所以我们直接将地址后面的ajax.html换成1.txt，然后按回车，就打开了。图示如下：
1.txt和ajax.html在同一个目录下：ajax目录
ajax.html的地址：
将ajax.html更改为1.txt后，1.txt文件的地址： //2.配置 open(请求方式、请求地址、是否异步) xhr.open("GET","http://127.0.0.1:5500/ajax/1.txt") 地址解释：地址===http协议+域名+端口号+详细地址；http：传输数据要遵循的协议，还有：https：是数据加密协议；127.0.0.1：指的是本机的ip地址，因为地址有时候可能记不住，所以我们可以用localhost代替；localhost：指的是本机域名；5500：端口号； 另外的表示方法：
//2.配置 open(请求方式、请求地址、是否异步) xhr.open("GET","http://localhost:5500/ajax/1.txt") ✍​​​​​​​ 请求地址也是可以“传参的”： 比如地址：http://localhost:3000/user
地址内容是：
想请求里面的第一条数据就可以写成： xhr.open("GET","http://localhost:3000/user?username=hhh") 在user后面加上“？”和请求的具体内容； （3）发送请求：send（）
//3.发送请求 send() xhr.send() （4）接收后端发过来的数据，注册一个事件 【1】事件readystatechange：
//4.接收数据，注册事件 //onreadystatechange事件是只要跟后端接到头了，就会自动执行function函数 xhr.onreadystatechange = function(){ console.log("111") } 结果：
readystatechange事件不用自己手动触发，这个事件是只要跟后端接到头了，它就会自动触发，执行function函数；但是结果发现这个function函数执行了3次，这就跟readystate关键字有关了；下面就介绍一下readystate关键字的作用： readystate关键字的作用：
readystate：ajax状态码是用来表示一个ajax请求的全部过程中的某一个状态；readystate == 0：表示未初始化完成，也就是open方法还没有执行；readystate == 1：表示配置信息已经完成，也就是执行完open之后；readystate == 2：表示send方法已经执行完成；readystate == 3：表示正在解析相应内容；readystate == 4：表示响应内容已经解析完毕，可以在客户端使用了；这个时候我们就会发现，当一个ajax请求的全部过程中，只有当readystate == 4的时候，我们才可以正常使用服务端给我们的数据； ✍ 为什么会打印三次“111”的原因：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b785cdbc37da57ce4e5c54a66d23c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad0923b5dda14077b88d0ea9d71af963/" rel="bookmark">
			微信公众号开发中的一些设置和遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.微信公众号开发人员设置 2.回调地址域名配置 正式账号： 测试账号： 可能遇到的问题：
3.设置ip白名单 利用php向微信发送请求获取openid的时候，打印显示没有返回
在网上查了一些资料，基本可以确定php代码是没有问题的，突然想起来没有配置ip白名单，于是就把ip白名单配置了一下(多个ip换行添加就可以)
配置完之后发现还是没有返回，参考资料
PHP使用curl请求https站点的常见错误及解决方案 - 黎明互联-官方博客 - 黎明互联 - 区块链培训，PHP培训，IT培训，职业技能培训，追求极致！改变您的职业生涯！
CURL错误码表 - 黎明互联-官方博客 - 黎明互联 - 区块链培训，PHP培训，IT培训，职业技能培训，追求极致！改变您的职业生涯！
打印请求错误，发现返回6
处理对应问题之后，问题解决 为什么要配置ip白名单：IP白名单
4.服务器配置 启用服务器配置，而这将导致UI界面设置的自动回复和自定义菜单失效！（在实际项目中目前我还没有遇到过，感觉这个应该是后端来处理的）
参考官网：接入概述 | 微信开放文档
5.前端通过php来获取openid 开始直接放在本地去请求但是返回的结果是php文件自身
出现这种原因是因为：php要放在apache下才能运行 ，vue项目启用的服务器 是基于nodejs的 没有解析php的能力
于是想着把php的相关文件放在公司的测试服务器中，但是请求之后报跨域的问题，通过proxy代理（见上篇文章）解决了跨域问题，之后就能顺利请求到openid
遇到的其他问题 1.在运行php文件的时候报了一个错误：显示相关打印的方法比如print是undefined，后来发现是上一个语句少了分号造成的
2.Missing argument 3 in __constructor 经查证发现是应为在new相关的对象是少传了一个参数（定义了3个，但是只传了2个）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24d6e29b0015dbbd1d75f3d6d522e03/" rel="bookmark">
			我的世界Bukkit服务器插件开发教程（十）实体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十、实体 这一章原本被定在第五章，但由于一些原因（其实就是懒啊）拖了五章。
什么是实体
实体是Minecraft中动态的、移动中的对象。牛牛君是实体、可爱的小僵是实体、摇头的村民是个实体。
实体分为两类，一类为有生命实体，所有活性实体都继承LivingEntity类，比如村民、牛、兔子等等。
另一类为无生命实体，如箭、船、盔甲架等，没有生命。
除了玩家（EntityHuman）外，几乎所有实体都由 AI 控制。
1.实体 1.1.创建一个实体
我们假设需要一只可爱的小僵在我们身边。
先创建一个 Player 对象。
Player p = (Player) sender; sender 是发送指令的人，将 sender 强制转换成 Player 类型并赋值于p
（sender 是什么？赶快到以前翻翻温故吧！）
p.getWorld().spawnEntity(p.getLocation(), EntityType.ZOMBIE); 这行代码，首先获取玩家当前的世界（getWorld），然后将这个世界的僵尸实体传送到玩家所在位置。
现在，你应该看到一只僵尸在你身边了。
1.2.更改名字
首先创建一个Zombie对象。
Zombie zombie = (Zombie) p.getWorld().spawnEntity(p.getLocation(), EntityType.ZOMBIE); 然后就可以更改名字了：
//设置实体名字 zombie.setCustomName("守卫者"); 可是你会发现名字没有显示，还需设置名字可以显示：
//设置实体名字可见 zombie.setCustomNameVisible(true); 这些只是小菜一碟，本章最难的部分在于自定义实体。
2.自定义实体 自己创建一个实体是不太可能的，亲这边建议你转 Mod 开发，插件开发还是要看服务器的心情的呢。
所谓插件，无非是在原版的基础上加点特色，所以我们无法增加一个新物品，增加一个新实体，增加一个新方块。
那么，也只能在现有的实体上做做更改了。
1.1.自定义实体行为/重构AI（PathFinderGoal）
现有的实体已经能满足我们的大部分要求了，我们没有必要自己创建一个实体，可以重写一个实体啊。
现在我们需要一头牛，能吃钻石，并且能生产钻石块。
public class MyCustomCowEntity extends EntityCow { public MyCustomCowEntity(EntityTypes&lt;? extends EntityCow&gt; entitytypes, World world) { super(entitytypes, world); } } 在上面的代码中，我们继承了EntityCow类（当然这是继承 NMS 下的类），现在就可以开始进行重写了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24d6e29b0015dbbd1d75f3d6d522e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21e55f7715498a28a0b167d5bb7fed04/" rel="bookmark">
			webrtc Android最新源码及编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近工作中需要使用到webrtc处理音视频，但是官方的版本都不能支持H264的硬解码播放，所以自己动手下载及编译了最新的master版本源码。
自己编译or直接下载 由于众所周知的原因，下载webrtc的源代码，需要配合科学上网，就有点麻烦了。建议可以购买海外版服务器，下载编译之后，再下载回本地环境。
这里有已经下载编译好的最新源代码（2022.11.1同步），可供大家下载，直接编译使用：
链接：https://pan.baidu.com/s/1_z5AmY5iEAYDbUqVxhnONQ
提取码：2wb3
编译步骤（Ubuntu20.04系统） 【下载安装depot_tools】
git 命令获取 depot_tools git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 配置环境变量 echo "export PATH=$PWD/depot_tools:$PATH" &gt; $HOME/.bashrc 使环境变量生效 source $HOME/.bashrc 检测配置是否成功 echo $PATH 【下载源码】
创建下载目录 mkdir webrtc &amp;&amp; cd webrtc 获取源码（20G 左右，时间较久，1-2小时） fetch --nohooks webrtc_android 同步代码 gclient sync --nohooks 【编译】
安装编译依赖 ./src/build/install-build-deps.sh ./src/build/install-build-deps-android.sh 设置编译参数 cd src gn gen out/build --args='target_os="android" target_cpu="arm" is_debug=false' /** out/build ：编译文件的存放目录，可自定义 target_os：编译目标平台 target_cpu ：CPU架构平台 ，例：arm、arm64、x86、x64 is_debug ：Release模式或者Debug模式 */ 执行编译 ninja -C out/build 主要提取文件 out/build/lib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21e55f7715498a28a0b167d5bb7fed04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c582e33750024e2111455489072b7dd/" rel="bookmark">
			【Web系列十七】Springboot&#43;Vue实现websocket通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
SpringBoot
使用maven添加依赖
创建websocket服务
创建配置文件 Vue
创建websocket类
初始化
测试
连接与通信
断开连接
参考资料
前言 想实现websocket通信并不复杂，这篇文章列举了多种选择，感兴趣的可以移步了解。
一文搞懂四种 WebSocket 使用方式，建议收藏！ - 知乎 (zhihu.com)
而本文是使用ServerEndpoint实现的。
SpringBoot 使用maven添加依赖 maven搭建springboot环境可以参考博主的这篇文章。
【web系列十六】idea下使用Maven搭建spring boot开发环境_Nicholson07的博客-CSDN博客
找到pom.xml添加以下内容
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 创建websocket服务 创建service文件夹及WebSocket.java
@Component @Slf4j @ServerEndpoint(value = "/websocket/{sessionId}") public class WebSocket { public static int onlineCount = 0; public static Map&lt;String, WebSocket&gt; clients = new HashMap&lt;String, WebSocket&gt;(); public Session session; public String sessionId; public String getsessionId() { return sessionId; } public static void sendMessageTo(JSONObject json) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c582e33750024e2111455489072b7dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d7d8ae090d8a13f2d9c9929c60b33cc/" rel="bookmark">
			Matlab 画颜色不同的 分段折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.以纵坐标为分割
clear;clc; data = load("折线图需要的数据.mat"); data = data.data; color = [0.933333333333333 0.815686274509804 0.847058823529412; 0.690196078431373 0.643137254901961 0.894117647058824; 0.800000000000000 0.643137254901961 0.890196078431373]; x = 1:length(data); limit1 = 6; limit2 = 12; x1 = find(data &lt; limit1); x2=find((data&gt;=limit1)&amp;(data&lt;=limit2)); x3 = find(data &gt; limit2); for i = 2:length(data) A1 = find(x1 == i); A2 = find(x2 == i); A3 = find(x3 == i); if ~isempty(A1) num = 1; elseif ~isempty(A2) num = 2; else num =3; end plot(i-1:i,data(i-1:i),'LineWidth',2,'Color',color(num,:)) hold on end plot(x,limit1*ones(1,length(x)),'--k','LineWidth',1); hold on plot(x,limit2*ones(1,length(x)),'--k','LineWidth',1); hold on xlabel("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d7d8ae090d8a13f2d9c9929c60b33cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f42d2bf48dfcdd2260643fe23518e4dc/" rel="bookmark">
			基于STC89C52的四轮小车电机控制函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		51单片机是大多数同学入门单片机的首选，在现今的高校也是十分地普及，而智能小车也是一个很有意思的东西。
废话不多说，直接上代码：
.C文件部分
/*********************************************\
* _ooOoo_ *
* o8888888o *
* 88" . "88 *
* (| -_- |) *
* O\ = /O *
* ____/`---'\____ *
* .' \\| |// `. *
* / \\||| : |||// \ *
* / _||||| -:- |||||- \ *
* | | \\\ - /// | | *
* | \_| ''\---/'' | | *
* \ .-\__ `-` ___/-. / *
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f42d2bf48dfcdd2260643fe23518e4dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a32219ae6db86a86f6c234c38dda3d/" rel="bookmark">
			上传MacOS APP到AppStore
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、图形界面上传APP
1、可以使用 application Loader或transporter上传，
2、iosAPP是上传.ipa文件，MacOS APP是上传pkg包
如何打pkg包，可以参考：
qt 开发的 macos app 上线 appstore_活到老、学到老-CSDN博客
二、用命令行上传版本方法：
alias altool='/Applications/Xcode.app/Contents/Applications/Application\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool'
altool --validate-app -f XXX.ipa -u XXX账号 -p -t ios
App Uses Non-Exempt Encryption --- 设置为NO
alias Transporter='/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter'
Transporter -m upload -assetFile XXX.ipa -u XXX账号 -p XXX密码 -v informational
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c849607e0a5471a85c3cce0e30f0e985/" rel="bookmark">
			自用IdeaVim配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		- 具体配置如下
nnoremap &lt;SPACE&gt; &lt;Nop&gt; let mapleader = ":" set hlsearch set incsearch set smartcase set ignorecase set easymotion set surround set argtextobj set keep-english-in-normal-and-restore-in-insert set scrolloff=4 " basic key mapping " nnoremap L $ " nnoremap H ^ " noremap L $ " nvnoremap H ^ " nnoremap ; : " clear the highlighted search result nnoremap &lt;Leader&gt;sc :nohlsearch&lt;CR&gt; " Move half page faster " 向下半屏幕 nnoremap &lt;LEADER&gt;d &lt;C-d&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c849607e0a5471a85c3cce0e30f0e985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78af6259b272a196bd4737ba5ec11805/" rel="bookmark">
			多级评论实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		** 最近再开发个人的网站的时候，想到了多级评论，在简单的学习了一下之后，认识到数据库设计的重要性，对此，总结一下多级评论的实现 **
数据库设计 CREATE TABLE `comment` ( `id` int(11) , `foreign_id` int(11) '业务模块的id', `content` varchar(255) '内容', `username` varchar(20) '用户名称', `user_id` int(11) '用户id', `pid` int(11) '父级评论id', `target` varchar(255) '回复对象', `createtime` datetime '创建时间', ) 我们通常使用单表来实现多级评论
例如，在某个Post下评论，我们通常讲postId 记录在foreign_id下,当我直接回复Post本身时，我们将Pid记为空，当我们回复某个Post下的某个评论时，我们将Pid记为回复评论的Id,这样我们就可以实现多级评论。
pojo层设计 public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private Integer foreignId; private String content; private String username; private Integer userId; private Integer pid; private String target; private DateTime createtime; @Transient //表示数据中不存在 private List&lt;Comment&gt; children; } 在设计pojo层时，我们需要新增一个children作为此父级评论的子级评论的List
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78af6259b272a196bd4737ba5ec11805/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc81cca4b60036f41b2ad6c1919ec6d8/" rel="bookmark">
			《java练级之路之数组的应用场景》非常细致，小白也能看懂！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎇🎇🎇作者：
@小鱼不会骑车
🎆🎆🎆专栏： 《java练级之旅》
🎓🎓🎓个人简介：
一名专科大一在读的小比特，努力学习编程是我唯一的出路😎😎😎
🙈🙈🙈作者心里话
小鱼一直都是秉承着“开开心心看博客，快快乐乐学知识”这个观点来给大家用一些接地气的话进行讲解，可能会有人觉得小鱼太墨迹了，小鱼这里也很乐意接受大家的意见，会进行采纳，大家也可以指出小鱼的不足，小鱼也会积极的进行改变，总之，愿我们越来越优秀
前言
😎 emmm,这篇是关于java中《初识数组》的，关于前两章大家可以去我主页查看，当然我也会给这三篇文章单独分一类以便于大家更好的观看，我们经过了前两章有些枯燥的理论知识后是不是各位也都想上手实战一下，好的！我们这篇文章就是带大家巩固知识，不过你们应该懂小鱼吧，那必须会留下一些坑啊（大家可不要跳进坑里呦），在此基础还是会掺杂一些理论知识的，不过小鱼尽量找个大家更容易理解的方式进行讲解，好的废话不多说，我们进入正题
介绍
来让小鱼给大家介绍一些今天的任务，
任务1️⃣：保存数据（特别简单可以跳过）任务2️⃣：作为函数的参数任务3️⃣：作为函数的返回值任务4️⃣：数组练习（大家期待已久的！！！） 我们的任务规划好了，现在开始
💫数组的应用场景 😺1. 保存数据😸2. 作为函数的参数🍒 前言🍒 题目一🍒 题目二🌲fun1方法🌲fun2方法 😺3.作为方法的返回值😺4. 数组练习下一篇，白白 😺1. 保存数据 public static void main(String[] args) { int[]array={1,2,3}; for (int i = 0; i &lt;array.length ; i++) { System.out.print(array[i]+" "); } } 将数组的值打印出来，简称保存数据
😸2. 作为函数的参数 🍒 前言 大家应该很熟悉吧，咱们的阿七，当然，咱们的重点不是这个，理发店大家是不是都很常见，也有一句特别有意思的话，当然小鱼也是亲身经历的，我以为剪了头发，就可以了无牵挂，相信大家都是耳熟能详吧。不过我们先奔入正题，我们在理发时，一般就会有理发师A给你理发，但是理发之前呢，会先去洗头，这个时候就是理发师B的任务了，也就是理发师B和理发师A都可以对你进行改变（两种情况），
情况一这时候吧又有一个人特别着急，于是便让这个理发师B先给他洗了头，那么你呢，就只是干坐着，什么都没变，后来理发师A就又把你从理发师B的手里接了回来，你现在就是什么都没有改变的状态，
情况二就是理发师B给你把头洗了，等到理发师A再把你接回来的时候，你就是已经变化了的状态（头洗了和没洗是两种状态），
注意！！！先说明，理发师A和理发师B能做的事情都是一样的。
可能大家听这个会感觉一些疑惑，咦，这都什么是什么啊，小鱼想说，大家别急，等会咱们跟进着问题，疑惑也就渐渐的消散了。
🍒 题目一 public static void fun(int x) { x=20; System.out.println("x="+x); } public static void main(String[] args) { int a=10; fun(a); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc81cca4b60036f41b2ad6c1919ec6d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c171751795afc5b6a116b60a87362109/" rel="bookmark">
			三种图像内插法（最近邻内插法、双线性内插法、双三次内插法）的做法 &amp; 代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考博客 数字图像处理学习笔记（四）——数字图像的内插、度量、表示与质量_闭关修炼——暂退的博客-CSDN博客
数字图像处理学习笔记（七）——用Pycharm及MATLAB实现三种图像内插法（最近邻内插法、双线性内插法、双三次内插法）_闭关修炼——暂退的博客-CSDN博客
数字图像的内插 内插是在诸如放大、收缩、旋转和几何校正等任务中广泛应用的基本工具。
从根本上看，内插是用已知数据来 估计未知位置的数值的处理。
实现图像内插的方法有三种： 最近邻内插法、双线性内插法、双三次内插法 。
最近邻内插法 理解：在原图像中寻找最接近的像素，并把该像素的灰度赋给加想要创建大小的网格中的新像素。
当我们完成对网格中覆盖的所有点的灰度赋值后，就把图像扩展到原来规定的大小，得到放大后的图像。
本方法不常用是因为会产生不希望的人为缺陷的倾向（如某些直边缘的严重失真）。
双线性内插法 赋于点（x,y）灰度值公式：v(x,y)=ax+by+cxy+d
注：与该方法名称相反的是，双线性内插不是一种线性内插方法，因为其中包含有xy项。
4个系数可由4个用（x,y）点最近邻点写出的未知方程确定（四个未知数四个方程）。
双线性内插法给出了比最近邻内插好得多的结果，但随之而来的是计算量的增加。
双三次内插法 赋于点（x,y）灰度值公式：
注：双三次内插包括16个最近邻点。
16个系数可由16个用（x,y）点最近邻点写出的未知方程式确定。
如果求和的上下限为1和0时，那么就变成了双线性内插v(x,y)=ax+by+cxy+d公式的形式。
通常，双三次内插在保持细节方面比双线性内插相对较好，但其计算量非常大。
双三次内插是商业图像编辑程序的标准内插方法。
数字图像的度量 关于数字图像的度量，有欧氏距离、曼哈顿距离、切比雪夫距离之分。
对于坐标分别为（x,y）,（s,t）,（v,w）的像素p，q，z。
欧几里得（欧式）距离：
注：距点（x,y）的距离小于等于某个值r的像素是中心在（x,y）且半径为r的圆平面。
D4（又称城市街区、曼哈顿）距离：
注：距点（x,y）的距离小于等于某个值r的像素形成一个中心在（x,y）的菱形.
例如距中心点（x,y）的距离小于等于2的像素，形成固定距离的如右图轮廓，其中=1的像素是（x,y）的4领域。：
D8（又称切比雪夫、棋盘）距离：
注：距点（x,y）的距离小于等于某个值r的像素形成一个中心在（x,y）的方形。
例如距中心点（x,y）的距离小于等于2的像素，形成固定距离的如右图轮廓，其中=1的像素是（x,y）的8领域。
数字图像的表示 二维离散亮度函数——f(x,y)：
x，y说明图像像素的空间坐标；
函数值 f 代表了在点(x,y)处像素的灰度值。
二维矩阵——A[m,n]：
m,n说明图像的宽和高；
矩阵元素a(i，j)的值，表示图像在第 i 行，第 j 列的像素的灰度值（i,j表示几何位置）。
图像描述信息：如图像高度和宽度等信息。
图像数据：顺序存放的连续数据。
注：1字节=8位；
对于2色位图，1位表示一个像素颜色（2=）， 所以一个字节表示8个像素；
对于16色位图，4位表示一个像素颜色（16=）， 所以一个字节表示2个像素；
对于256色位图，8位表示一个像素颜色（256=），所以1个字节表示1个像素；
对于真彩色图，3个字节表示一个像素（因为真彩图有R、G、B三个通道）。
数字图像的质量 灰度级：表示像素明暗程度的整数量。
例如：像素的取值范围为0-255，就称该图像为256个灰度级的图像。
层次：表示图像实际拥有的灰度级的数量。
例如：具有32种不同取值的图像，可称该图像具有32个层次。
图像数据的实际层次越多，视觉效果就越好。
对比度：指一幅图像中灰度反差的大小 。
对比度 = 最大亮度 / 最小亮度（即最大像素值/最小像素值）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c171751795afc5b6a116b60a87362109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4eda56f6c1d1361d08f42e5bce319c9/" rel="bookmark">
			Linux如何查看端口是否打开？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux如何查看端口是否打开?在Linux系统中，查看端口是否打开可以通过命令来完成，这其中比较常见的命令为lsof命令、netstat命令，本文重点为大家介绍一下lsof命令，我们一起来学习一下吧。
lsof命令用于查看你进程打开的文件、打开文件的进程、进程打开的端口。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。
在Linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议和用户数据协议套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。
语法：
losf (选项)
选项：
-a 列出打开文件存在的进程;
-c&lt;进程名&gt; 列出指定进程所打开的文件;
-g 列出GID号进程详情;
-d&lt;文件名&gt; 列出占用该文件号的进程;
+d&lt;目录&gt; 列出目录下被打开的文件;
+D&lt;目录&gt; 递归列出目录下被打开的文件;
-n&lt;目录&gt; 列出使用NFS的文件;
-i&lt;条件&gt; 列出符合条件的进程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06563dfb8a212bcbd93c1bc35a3f214d/" rel="bookmark">
			一本书，带你走出Spring新手村
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		与IOC、AOP、SPI一样，Spring 提供的不只是一个开发框架，还包括它的设计思想。
它通过解耦 Bean 对象的实例化过程，管理 Bean 的生命周期，来维护开发过程中对象的使用过程。让你不需刀耕火种般 “new ”一个对象，也不需如 EJB 一样笨重臃肿地开发维护，只需像春风一样万物（万物皆可Bean）细无声般地使用。可以说，Spring完全担得起 Java 技术设计顶峰的称号。
除了运用，Spring 框架也是众多开发者最先接触到的一个源码级复杂项目。
对于任何初出茅庐，完成初次蜕变的开发者来说，苦苦寻觅各种项目进行练习，都不如学习 Spring 源码来得痛快。在其架构的设计、分治抽象的运用、设计模式的驾驭上，Spring 框架都是顶级的，也是最能给你带来丰富收获的。
学习 Spring 源码难吗？
难！
难到有1~2年编程经验的工程师，也不知道从哪里下手。
大部分资料和书籍都是从一个知识点直接透析到内核。
没有阅读源码经验的小白，根本没法如编写者般感同身受地学习，看时如云里雾里，忘时如过眼云烟。
为啥会这样？
因为 Spring产生太久了，源码太大了，主干核心源码外的繁枝末节太多太多。就像将一个沙发左移、套个沙发罩、盖上一块布，再铺个小坐垫，沙发套、盖布、坐垫对初学源码的开发者来说，并没有那么重要，我们要了解的是最初的沙发、最开始的木板，看看它的结构、闻闻它的味道。
所以，如果你真地想了解Spring 这个源码级复杂框架的设计和实现精髓，就应该像开发一个项目一样，从零写一遍。只有你写了这个项目，才能知道具体细节是如何处理的，各类设计是如何实现的。
驾驭复杂源码
对于大部分使用 Spring 框架的研发人员来说，在遇到 Spring 框架的报错提醒， 以及需要基于 Spring 框架开发 SpringBoot Starter 等技术类组件时，都会尝试阅读 Spring 框架的源码。
由于 Spring 框架的源码庞大、复杂，也不像平常的业务流程代码开发一样具有分层结构，并且使用了大量的设计模式，所以阅读难度较大，研发人员很难厘清其中的调用链路和各个类之间的关系。
《手写Spring：渐进式源码实践》一书的作者小傅哥最初学习Spring时，也阅读了不少相关图书，在反复学习后，仍然不能轻易理解 Spring 框架中各个功能的实现细节。其中一个原因是自己没有手动实现，只阅读图书，很难完全掌握 Spring 框架的精髓。
在学习过程中，小傅哥对 Spring 框架有了非常深入的了解和认识，也体会了更多精妙的设计原则和设计模式。彻底从实现上搞清楚：上下文如何管理、Aware如何通过SPI机制处理感知对象通知、切面拦截如何设计、三级缓存循环依赖如何实现、ORM框架怎么整合到Spring，等等。
手写Spring
独乐不如众乐，小傅哥把手动实现简单版 Spring 框架的内容编写成书，希望帮助更多的研发人员学习Spring 源码，编写出有价值的源码设计方案。
从此，你多了一段“手写Spring”项目的学习经历：具备了复杂源码的架构设计能力、吸收了复杂场景分治和抽象的思想、我就是学会了复杂结构中设计模式的运用。你手写过Spring的代码，以后路，你可以横着走！
内容简介
本书共21章。
第1～10 章：主要介绍IOC 容器，逐步完善一个简单的Spring Bean 容器的相关功能，引入实例化策略、注入属性和依赖、设计应用上下文、处理Bean 对象的生命周期，以及实现感知容器对象的监听等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06563dfb8a212bcbd93c1bc35a3f214d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2170339dd685aa6061c9e201a471c63/" rel="bookmark">
			obs 推 rtsp 流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		obs 默认推的是 rtmp 流，需要配置推流服务器，服务器可以使用 zlmediakit 的服务器。
obs 推 rtsp 流要安装插件，使用最新版本的 obs 客户端（28.x.x）不行，需要使用 27.1.3 的 obs 客户端。
推流插件使用最新版本 （v2.3.0）的可以使用，后面再新的不知道行不行。 obs-rtspserver-v2.3.0-windows-installer.exe
推流方法：
1. obs 客户端点击 工具 -&gt; RTSP服务器
2. 弹框点击启动，rtsp 就已经推流了。
obs 推拉流是本地启动了一个 rtspserver，直接使用 vlc 即可直接拉流，不需要经过服务器中转。
遇到的问题：
1. 可能会出现绿屏、崩溃等情况，作为使用者，直接把 obs 重启，重新推拉流即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b16d3c261d7cdf510f7219f51b494d11/" rel="bookmark">
			【机器翻译】【指标】扰动下的幻觉 Hallucination Under Perturbation HUP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机翻指标HUP源自文章HALLUCINATIONS IN NEURAL MACHINE TRANSLATION
https://openreview.net/pdf?id=SkxJ-309FQ
HUP翻译了机翻模型的鲁棒性以及翻译是否忠于源句。如何判断产生了幻觉？简单说就是，向源句加入微小扰动，参考翻译与无扰动翻译越相似，扰动翻译与无扰动翻译越不同，则说明产生了幻觉。这里的相似与否通过BLEU值来表明。HUP为幻觉的百分比。
原文将幻觉描述成四种模式：
四种常见的幻觉模式:(1)语法正确的输出与输入文本没有关系，(2)语法不正确的输出具有振荡结构，(3)输出大部分保留在源语言中，最后(4)简洁地跳转到序列的末尾。
并设计了扰动策略：
我们将这一发现扩展并系统化为一个暴力搜索过程(算法1)，将我们的标记分为几种类型:常见(100个最常见的德语标记)、罕见(100个最不常见的德语标记)、中频标记(从剩余的德语标记中随机抽样100个标记)和标点符号标记。此外，我们试图通过在开头、结尾、倒数第二和中间随机插入标记来打乱每个句子。我们对测试集中的每个句子都这样做，并为每个模型变量收集统计信息。
为了定义幻觉的定量阈值，我们修改了BLEU评分（adjusted bleu），它用于比较参考序列和翻译序列。
作者首先选择了在添加扰动前翻译BLEU&gt;=0.09的句子，因为在向输入序列添加扰动令牌之前，也不是所有的翻译都是好的。首先选择了基本正确的翻译后，选择扰动翻译与无扰动翻译越不同（&lt;0.01）的句子为幻觉。
。。。。
但没找着hup的实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fc311759fa077be3f81287f2115fc3/" rel="bookmark">
			SpringMVC获取请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、通过ServletAPI获取 将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象
@RequestMapping("/testParam") public String testParam(HttpServletRequest request){ String username = request.getParameter("username"); String password = request.getParameter("password"); System.out.println("username:"+username+",password:"+password); return "success"; } 2、通过控制器方法的形参获取请求参数 在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参
&lt;a th:href="@{/testParam(username='admin',password=123456)}"&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt; @RequestMapping("/testParam") public String testParam(String username, String password){ System.out.println("username:"+username+",password:"+password); return "success"; } 注：
若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数
若使用字符串数组类型的形参，此参数的数组中包含了每一个数据
若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果
3、@RequestParam @RequestParam是将请求参数和控制器方法的形参创建映射关系
@RequestParam注解一共有三个属性：
value：指定为形参赋值的请求参数的参数名
required：设置是否必须传输此请求参数，默认值为true
若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter 'xxx' is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null
defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值
4、@RequestHeader @RequestHeader是将请求头信息和控制器方法的形参创建映射关系
@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam
5、@CookieValue @CookieValue是将cookie数据和控制器方法的形参创建映射关系
@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam
6、通过POJO获取请求参数 可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值
&lt;form th:action="@{/testpojo}" method="post"&gt; 用户名：&lt;input type="text" name="username"&gt;&lt;br&gt; 密码：&lt;input type="password" name="password"&gt;&lt;br&gt; 性别：&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7fc311759fa077be3f81287f2115fc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b33a2127769ae4f89262c6d6d1428f/" rel="bookmark">
			Linux使用iPhone USB共享网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关键字：
ipheth 、ipheth-pair 、usbmuxd 、libimobiledevice
Apple iPhone USB Ethernet
Ubuntu系统默认可以识别，CentOS系统需要安装库文件
网卡识别 Ubuntu系统（20.04）版本，在连接IPhone后，可以识别到iPhone手机的网卡设备。CentOS默认无法识别。
部分资料说明参考安装ipheth-driver和ipheth-pair，其实CentOS默认已包含ipheth，不需要另外安装
默认ipheth路径：/lib/modules/xxxxxxx/kernel/drivers/net/usb
CentOS系统无法识别IPhone原因在于需要安装usbmuxd，安装usbmuxd需要依赖libimobiledevice、libplist、libusbmuxd
安装方法1：rpm离线安装
https://download.opensuse.org/repositories/home:/qmfrederik/CentOS_8/x86_64/
如遇如下错误，需先下载安装compat-openssl11-1.1.1k-4.el9.x86_64.rpm
安装方法2：yum在线安装
默认yum source找不到这几个安装包，需要修改source。
下载yum source文件：
cd /etc/yum.repos.d/
wget https://download.opensuse.org/repositories/home:qmfrederik/CentOS_8/home:qmfrederik.repo
yum install libplist libusbmuxd libimobiledevice usbmuxd 安装完成后连接IPhone可以看到有网卡设备
信任匹配 在完成上面步骤，识别网卡后，配置网络信息发现，并无法正常共享网络实现上网功能
原因为IPhone设备需要信任匹配，如下图：
部分资料说明需要增加ipheth-pair来实现此功能，现在可使用安装libideviceactivation代替
yum install libideviceactivation 完成信任匹配后，配置好网卡为自动获取IP，即可实现正常上网功能。
网卡配置 补充Centos网卡配置方法
方法1： nmtui命令，进入图形界面，输入网卡名称（ipconfig查看后记录一下）
方法2： nmcli命令
nmcli connection add con-name eth0 ipv4.method auto ifname eth0 type ethernet 其中，eth0为iPhone识别的网卡名称示例，根据识别情况修改
方法3： nmconnection文件
以上两种方式，最终都会实现创建nmconnection文件，内容如下：
/etc/NetworkManager/system-connections/eth0.nmconnnection
[connection] id=eth0 uuid=8ffexxxx-af50-xxxx-8a6f-71xxxxaexxx6 type=ethernet interface-name=eth0 [ethernet] [ipv4] method=auto [ipv6] addr-gen-mode=stable-privacy method=auto [proxy] Android设备 Android设备网卡识别基本不需要额外安装驱动，开启热点选择USB共享连接，即可识别出网卡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe78a34c97aadb38273eae4b0d7b1d2/" rel="bookmark">
			数字证书SSL品牌分类总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了方便大家直观的分辨，这里给大家分成了国内品牌和国际品牌两种
国产ssl证书品牌
1.JoySSl
JoySSL是网盾数科自研推出的新一代https数字证书，也是目前为数不多的中国自主品牌SSL证书。JoySSL携手全球可信顶级根，基于国内服务器验证签发，安全可信、完美兼容且更加稳定快速。JoySSL自主品牌证书提供90天免费版本，包括单域名、多域名、通配符等所有适配范围。
特点：价格性价比高、品牌自主，全球可信 2.CFCA
作为国家级权威的安全认证机构，CFCA不仅提供一流的电子认证服务，还为广大用户提供信息安全解决方案。旗下自主研发的纯国产SSL证书，不仅可支持国密算法（SM2/SM3），满足政府/金融等组织、机构国家监管需求，其根证书已置入到全球四大根证书库中。
特点：自主品牌，全球认可
3.vTrus
vTrus天威诚信旗下的国产SSL证书，以Certum作为根证书。自2020年上市以来，vTrus提供DV基础版，OV标准版和OV专业版SSL证书，目前还没有EV证书。该CA提供的证书保险金额偏低，最高仅40万美元。而vTrus与TrustAsia两个品牌的价格差不多，整体都是上千元，vTrus证书最低价1200元/年。目前vTrus的最长购买年限是1年。
4.TrustAsia
TrustAsia是根据Digicert提供的基础设施创建的国内品牌证书，算是国内比较早的自主品牌SSL证书， 特点是带有SSL证书状态检测服务。 证书支持双算法（RSA/ECC）,但未提供证书保险金额。
在价格上，TrustAsia相对比较贵，其域名型证书的官网最低价为1900元/年，OV SSL证书价格为4900元/年。在购买年限上，目前通过腾讯云的渠道购买，可以买到3年期的证书。
5.Wotrus
WoTrus是国内老牌CA 沃通的国有自主品牌。WoTrus SSL证书支持国际加密算法和国密SM2算法。 WoTrus国际算法的SSL证书主要和Sectigo以及Digicert合作，以贴牌的方式国产化。
在产品线上，WoTrus的产品线也是非常完善，包括EV、OV、DV等不同类型的SSL证书，可以满足不同的客户需求。在价格上也是比较容易接受，最便宜的DV证书也就488元一年。
6.BaiduTrust
BaiduTrust是百度倾力打造的新一代国产品牌SSL证书。BaiduTrust相对其他品牌的SSL证书，能够得到百度生态服务加持，如搜索排名加权、搜索收录提速、安全扫描服务等。选择BaiduTrust有利于网站的搜索引擎排名，这个功能使得这款产品在中小企业以及个人站长中非常流行。
BaiduTrust证书提供完整的SSL证书产品线，包括OV、EV、DV证书等，价格从880元/年起，提供本地验签以及网站漏洞扫描服务，性价比相当高。
国际SSL证书品牌
1.Digicert
DigiCert 旗下拥有 DigiCert，Symantec，Geotrust，Thawte，Rapid 5大SSL证书品牌。DigiCert SSL证书分为 OV 和 EV 两种验证级别，同时支持多域名和通配符功能，也是全球极少能支持 IP 直接申请证书的CA之一。
2.Symantec
SSL证书前身为 Verisign，后于2017年12月被DigiCert收购，现在已经使用 DigiCert 根证书。Symantec Secure Site SSL证书依然是各行业尤其是金融银行证券等大型企业认可的品牌。Symantec Secure Site SSL证书 支持诺顿安全签章，是网站拥有很好的可信度。
3.GeoTrust
全球很受欢迎的一款高性价比证书，服务的客户遍及全球。目前已经使用 DigiCert 根证书，安全性和稳定性均有可靠的保障。Geotrust 提供 DV,OV,EV三种验证等级的SSL证书，在功能上，支持单域名，多域名，通配符以及多域名通配符功能。
4.Rapid
面向中低端用户而提供信息安全产品，它可以验证域名的所有权，相对于中小型企业来说，是非常合适的，对于数据传输或是生意当中的交易，有着很大的保障作用，它的价格相对来说低廉，颁发的速度较快，也是Geotrust旗下的产品。
5.Thawte
Thawte SSL 证书主要有 4 种： SGC Supercerts 、 SSL Web Server、SSL123 和新推出的 SSL Web Server with EV ，其中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe78a34c97aadb38273eae4b0d7b1d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de1d0c93bcb87bdeffb8eb6d54224afe/" rel="bookmark">
			ubuntu 20.04.4编译 继续尝试编译Android 12,13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前使用虚拟机编译过Android10，现在开始记录编译12，上次忘记给镜像了这次补上镜像ubuntu-20.04.4-desktop-amd64：
链接：https://pan.baidu.com/s/1REJ2cIJyqupLRQjN9SW08Q 提取码：kezj
硬件虚拟机：硬盘先准备400G不知道够不够，内存方面google是推荐16G。。我这内存+交换空间希望能成功编译吧。(ps:内存不够，后面有教设置交换空间)
不知道为啥，repo使用的python指令？为python 建立软连接，自带了python3.8，并建立了python3软连接，我们直接就把python 也搞成python3
sudo ln -s /bin/python3 /bin/python 1、安装git 并配置好git sudo apt-get install git git config --global user.name "your name" git config --global user.email "XXX@XXX.com" 2、下载repo并配置,创建一个目录，下载的repo和aosp源代码全部都在这里面 mkdir aosp cd aosp git clone https://aosp.tuna.tsinghua.edu.cn/git-repo/ chmod a+x git-repo/repo 添加repo 到环境变量 export PATH=~/aosp/git-repo:$PATH 3、初始化选择需要下载的Android版本 repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest 不知道选择哪一个版本的进入到.repo/manifests.git/ 查看有哪些分支，在做选择。
cd .repo/manifests.git/ git branch -a 我们直接选择一个最新的初始化， repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-12.1.0_r8 repo sync -j4 下面就慢慢等吧。。等的过程我们在检查检查其他需要的东西。。
重新打开一个命令行，由于本人的机子内存不足，是分配了8G后面可能会出现内存不足无法编译的情况，这个时候需要设置交换空间，也就是虚拟内存！！上次编译Android10的时候是8G ，交换6G。。这次编译12估计要设置大一点儿了，机子好的自行忽略下面步骤。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de1d0c93bcb87bdeffb8eb6d54224afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe839f472c7bea7997cc502495247e0/" rel="bookmark">
			String转Json的几种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种： String格式为：
String result = "{"code":200,"code":"0","message":"SUCCESS"}" 使用：
JSONObject json = JSONObject.parseObject(result); 第二种： String格式为：
result: { "code": 200, "message": "查询成功", "result": { "records": [ { "jobName": "高级开发工程师", "jobExperience": "一年以下", "education": "本科" }, { "jobName": "高级开发工程师", "jobExperience": "一年以下", "education": "本科" } ], "total": 1, "size": 10, "current": 1, "pages": 1 } } 使用：
JSONObject json = (JSONObject) JSON.toJSON(result); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7d8124a139b87a5a0344c8b915ce270/" rel="bookmark">
			Linux CentOS7.6 部署ArcGIS Server10.3 保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		趁着双十一活动购买了腾讯云的轻量级服务器，计划用来安装ArcGIS服务器。不得不说300大元能买到这个配置还是嘎嘎香的，废话少说，直接开始
准备数据： 1、腾讯云服务器：Linux CentOS7.6
2、ArcGIS Server10.3安装包
3、许可
4、Xshell，用来远程连接服务器
5、Xftp,用来给服务器上传数据
安装步骤： 第一步：服务器系统准备环节 1、重置密码 2、利用Xshell登录服务器 使用xshell连接服务器时，出现了“WARNING! ：The remote SSH server rejected X11 forwarding request.”，意思是“远程SSH服务器拒绝X11转发请求。”只需要执行下面操作即可
yum install xorg-x11-xauth 关闭Xshell，再次打开后就没有了
3、启动服务 先执行yum install -y httpd，然后在执行systemctl start httpd。这样服务器就可以连接上了
yum install -y httpd ​ systemctl start httpd 这个时候表示腾讯云服务器可以远程连接了，可以直接打开网址http://121.5.162.118/ 第二步：数据处理 1、服务器上新建存储文件 我习惯将安装包和破解文件存在服务器的单独文件夹（softfile）内
cd / mkdir softfile ls 2、数据上传 利用Xftp将安装包和破解文件上传至服务器
大概需要十五分钟。。。。
第三步：服务器环境配置 1、安装依赖包 yum -y install fontconfig mesa-libGL mesa-libGLU libXtst libXext \libX11 libXi libXdmcp libXrender libXau xorg-x11-server-Xvfb \libXfont vim 2、配置文件 这个时候需要使用root用户，在hosts文件中末尾加入服务器端的实际ip和机器名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7d8124a139b87a5a0344c8b915ce270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f452a54b93b5d121b1f94da48ec95140/" rel="bookmark">
			【UE4】虚幻引擎运行流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 当前版本：4.26.2
本文原创
说明：有些名词保持英文可能更容易理解
目录
游戏流程总览
各个平台启动引擎的入口函数
引擎入口函数 GuardedMain()
EnginePreInit 引擎预初始化
EngineInit 引擎初始化
EngineLoop 引擎主循环
EngineExit 引擎退出
游戏流程总览 解释启用引擎和运行游戏的过程。
此处说明两种主要路径：编辑器路径、standalone 路径。
事件的一般顺序为初始化引擎、创建并初始化 GameInstance、加载关卡，最后开始游戏。然而在部分被调用函数的准确排序和函数被调用的位置方面，standalone 模式和编辑器模式之间存在差异。以下流程图展示两个平行运行的路径，它们在游戏开始之前汇聚。
各个平台启动引擎的入口函数 代码路径：Engine\Source\Runtime\Launch\Private\
作为入口函数，然后进入引擎的入口函数GuardedMain。如下图所示
引擎入口函数 GuardedMain() 代码路径：Runtime/Launch/Private/Launch.cpp
执行引擎四大阶段的流程：EnginePreInit 、EngineInit 、EngineLoop、EngineExit 。执行流程图如下所示
EnginePreInit 引擎预初始化 实际上调用 FEngineLoop::PreInit ，再调用 PreInitPreStartupScreen 和 PreInitPostStartupScreen ，从而实现许多初始化和核心模块相关的事情
PreInitPreStartupScreen 里的执行流程 先进行各种初始化，如解析command参数、trace、stat（性能分析工具）、FModuleManager、IFileManager、FPlatformFileManager、各种路径等
加载CoreUObject模块，启动FTaskGraphInterface
通过LoadPreInitModules()
加载 Engine、Renderer、AnimGraphRuntime 模块
通过 FPlatformApplicationMisc::LoadPreInitModules()加载 D3D12RHI、D3D11RHI、OpenGLDrv等模块（根据所在平台）
加载 SlateRHIRenderer模块（非服务器下）
加载 Landscape、RenderCore 模块
加载 TextureCompressor、AudioEditor、AnimationModifiers 模块
通过 FEngineLoop::AppInit() 进行
本地化文本Init logging to diskinit config system 通过 FConfigCacheIni::LoadGlobalIniFile 加载Engine、Game、Input 配置文件其他配置文件还有：Editor、EditorPerProjectUserSettings、EditorSettings、EditorKeyBindings、EditorLayout、Lightmass、Scalability、Hardware、DeviceProfiles、GameUserSettings等Load "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f452a54b93b5d121b1f94da48ec95140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7eb1c4ffe05d77b33c447d5418dc106/" rel="bookmark">
			Python：蒙特卡洛算法以及三门问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蒙特卡洛算法： 一 、蒙特卡洛算法简介 蒙特·卡罗方法（Monte Carlo method），也称统计模拟方法，它是一种思想或者方法的统称，而不是严格意义上的算法。蒙特卡罗方法的起源是1777年由法国数学家布丰（Comte de Buffon）提出的用投针实验方法求圆周率，在20世纪40年代中期，由于计算机的发明结合概率统计理论的指导，从而正式总结为一种数值计算方法，其主要是用随机数来估算计算问题。
二、蒙特卡洛方法的基本思想 当所求解问题是某种随机事件出现的概率，或者是某个随机变量的期望值时，通过某种“实验”的方法，以这种事件出现的频率估计这一随机事件的概率，或者得到这个随机变量的某些数字特征，并将其作为问题的解。 假想你有一袋豆子，把豆子均匀地朝这个正方形上撒，然后数落在圆内的豆子数占正方形内豆子数的比例，即可计算出圆的面积，近而计算出π。而且当豆子越小，撒的越多的时候，结果就越精确。蒙特卡罗的理论依据是概率论中的大数定律。
三、蒙特卡洛算法的基本工作步骤 蒙特卡罗算法一般分为三个步骤，分别为构造随机的概率的过程，从构造随机概率分布中抽样，求解估计量。
1.构造随机的概率过程
对于本身就具有随机性质的问题，要正确描述和模拟这个概率过程。对于本来不是随机性质的确定性问题，比如计算定积分，就必须事先构造一个人为的概率过程了。它的某些参数正好是所要求问题的解，即要将不具有随机性质的问题转化为随机性质的问题。如本例中求圆周率的问题，是一个确定性的问题，需要事先构造一个概率过程，将其转化为随机性问题，即豆子落在圆内的概率，而π就是所要求的解。
2.从已知概率分布抽样
由于各种概率模型都可以看作是由各种各样的概率分布构成的，因此产生已知概率分布的随机变量，就成为实现蒙特卡罗方法模拟实验的基本手段。如本例中采用的就是最简单、最基本的（0，1）上的均匀分布，而随机数是我们实现蒙特卡罗模拟的基本工具。
3.求解估计量
实现模拟实验后，要确定一个随机变量，作为所要求问题的解，即无偏估计。建立估计量，相当于对实验结果进行考察，从而得到问题的解。如求出的近似π就认为是一种无偏估计。
四、样例: sample1：蒙特卡洛方法求圆周率
# 经典的蒙特卡洛方法求圆周率 # 基本思想：在图中区域产生足够多的随机数点，然后计算落在圆内的点的个数与总个数的比值再乘以4，就是圆周率。 import math import random m = 10000 #模拟次数为10000次 n = 0 for i in range(m): # x、y为0-1之间的随机数 x = random.random() y = random.random() # 若点(x,y) 属于图中1/4圆内 则有效个数+1 if math.sqrt(x ** 2 + y ** 2) &lt; 1: n += 1 # 计算pi pi = 4 * n / m print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7eb1c4ffe05d77b33c447d5418dc106/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b0187561232a77c3fd79c9d6375a0a/" rel="bookmark">
			Java实现OPCUA通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java实现OPCUA通 视频说明：Java实现OPCUA通信_哔哩哔哩_bilibili
描述 utgard 的方式过时了，所以建议使用 OPCUA 的方式。
这是连接操作说明：OPC UA Client：使用UaExpert
使用的开源库是 milo：GitHub - eclipse/milo: Eclipse Milo™ - an open source implementation of OPC UA (IEC 62541).
因为没有实际项目，所以只运行 milo 的示例代码的客户端部分：
milo/milo-examples/client-examples at master · eclipse/milo · GitHub
代码 OPC UA milo 代码示例: 运行 milo 的示例代码
过程和问题🔥🔥 问题：生成证书不带 URI
描述：在 windows 上使用 openssl 生成带 URI 信息的自签名证书，没找到操作说明。在 linux 上看教程到还可以。
👉 有时间再研究
问题：不使用匿名连接，只能连接本地，不能连接远程。
描述：可以使用 UaExpert 的用户名密码连接，milo 代码测试不能连接，报 UnknownHostException 即 主机名未知 错误。
👌 搜索到相关解答，服务发现时，服务端返回的断点描述的主机名或者本地IP，远程是访问不到的，按照解答参考，修改端点的主机名为远程IP地址即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b0187561232a77c3fd79c9d6375a0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91035d65dcd1306d828b4f92254eb173/" rel="bookmark">
			Boost库的安装（基于CentOS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前往https://www.boost.org下载
1. 解压后 tar -xf boost_1_80_0.tar.bz2 cd boost_1_80_0 ./bootstrap.sh ./b2 link=shared sudo ./b2 install 2.然后在/etc/profile.d目录下 cd /etc/profile.d sudo vim boost.sh 3.写入 然后 保存 #!/bin/sh BOOST_ROOT=压缩包的安装路径（ pwd ） BOOST_INCLUDE=/usr/local/include/boost BOOST_LIB=/usr/local/lib export BOOST_INCLUDE BOOST_LIB BOOST_ROOT 4.执行boost.sh
chmod +x boost.sh source ./boost.sh 5.测试 vim boost_test.cpp 写入 #include &lt;boost/lexical_cast.hpp&gt; #include &lt;iostream&gt; #include &lt;boost/version.hpp&gt; #include &lt;boost/config.hpp&gt; int main() { using boost::lexical_cast; int a= lexical_cast&lt;int&gt;("888888"); double b = lexical_cast&lt;double&gt;("888.888"); std::cout &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; b &lt;&lt; std::endl; std::cout &lt;&lt; BOOST_VERSION &lt;&lt; std::endl; return 0; } 结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91035d65dcd1306d828b4f92254eb173/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e1be3172ad40486ef8f6e98b9bcddf5/" rel="bookmark">
			2.Zookeeper 权限控制 ACL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zookeeper 权限控制 ACL（Access Control List，访问控制表） ACL 权限可以针对节点设置相关读写等权限，保障数据安全性。permissions 可以指定不同的权限范围及角色。
ACL命令 # 获取节点acl权限信息 getAcl /demoNode # 设置节点acl权限信息 setAcl /demoNode world:anyone:crwa ACL结构 zookeeper 的 acl 通过 [scheme🆔permissions] 来构成权限列表。
scheme：代表采用的某种权限机制，包括 world、auth、digest、ip、super 几种id：代表允许访问的用户permissions：权限组合字符串，由 cdrwa 组成，其中每个字母代表支持不同权限， 创建权限 create©、删除权限 delete(d)、读权限 read®、写权限 write(w)、管理权限admin(a) world world 代表开放式权限
auth auth 用于授予权限，注意需要先创建用户
setAcl /demoNode auth:user1:123456:cdrwa # 添加认证用户，否则无法再访问已经设置权限的节点 addauth digest user1:123456 # 设置权限 setAcl /demoNode auth:user1:123456:cdrwa digest digest 可用于账号密码登录和验证
# 密码是上面创建的密码密文 setAcl /demoNode digest:user1:HYGa7IZRm2PUBFiFFu8xY2pPP/s=:cdrwa getAcl /demoNode # 登录用户 # 对于某些认证（如ShardingSphere-proxy）只需要设置用户：addauth digest user1 addauth digest user1:123456 getAcl /demoNode 节点密码忘记 如果节点密码等忘记，无法连接删除时，可以采用以下两种方法解决
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e1be3172ad40486ef8f6e98b9bcddf5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/212/">«</a>
	<span class="pagination__item pagination__item--current">213/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/214/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>