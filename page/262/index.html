<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f1e6af2cffc78225fa57c9fa444e61d/" rel="bookmark">
			C# wpf slider实现显示进度、拖动定位、点击定位功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、如何实现？1.显示进度2.拖动定位3.点击定位 二、效果预览总结 前言 实现一个播放器，必然需要一个进度条，一个基本的进度条通常用于显示进度、拖动定位，也可以点击定位，在wpf通常使用slider实现，改变其Value可以显示进度，但是拖动和点击也使用Value或ValueChanged时就会产生冲突，直接死循环了，所以我们需要将这3个功能区分开来，用不同的方式去实现。
一、如何实现？ 1.显示进度 显示进度直接通过Slider的Value以及Minimum和Maximum实现即可。
设置播放总时长
sd_cursorTime.Minimum = 0; sd_cursorTime.Maximum = e.Duration;//视频总时长 更新播放进度
sd_cursorTime.Value = e.Time;//当前播放时间 2.拖动定位 slider和scrollbar一样是基于RangeBase，其内部构造是一样的，甚至style也可以共用，其内部构造可以参考《C# wpf ScrollBar自定义样式详解》。slider的滑块就是一个Thumb控件，所以我们只需要注册Thumb控件的DragStarted和DragCompleted事件以及添加一个忽略当前播放时间标识，即能实现拖动定位了。
注册事件
&lt;Slider x:Name="sd_cursorTime" Thumb.DragStarted="sb_cursorTime_DragStarted" Thumb.DragDelta="sb_cursorTime_DragDelta" Thumb.DragCompleted="sb_cursorTime_DragCompleted" /&gt; 事件中定位
//是否忽略播放进度更新 bool _isIgnoreCursorTime = false; private void sd_cursorTime_DragStarted(object sender, System.Windows.Controls.Primitives.DragStartedEventArgs e) { //忽略播放进度更新，让进度条拖动不受影响。 _isIgnoreCursorTime = true; } private void sb_cursorTime_DragDelta(object sender, System.Windows.Controls.Primitives.DragDeltaEventArgs e) { //拖动中实时定位。根据需求，也可以不使用。 _play.Seek(sb_cursorTime.Value); } private void sd_cursorTime_DragCompleted(object sender, System.Windows.Controls.Primitives.DragCompletedEventArgs e) { //播放器定位 _play.Seek(sb_cursorTime.Value); //还原标识，然进度条重新变化。 _isIgnoreCursorTime = false; } 忽略播放进度更新
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f1e6af2cffc78225fa57c9fa444e61d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2767e6c3719c28e4fb2eaa2178491b1d/" rel="bookmark">
			Swiper轮播图插件之如何修改前进后退按钮swiper-button-prev和swiper-button-next的默认样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一步： 在轮播图最外层的容器中将原本前进后退按钮的大小设置为0 注意： Swiper6之前的默认容器是’.swiper-container’，Swiper7之后的默认容器是’.swiper’。
.swiper-container{ --swiper-navigation-size:0; } 第二步： 设置想要的按钮图片 &lt;!--如果需要导航按钮--&gt; &lt;div class="swiper-button-prev rot" slot="button-prev"&gt; &lt;img src="图片路径"/&gt; &lt;/div&gt; &lt;div class="swiper-button-next rat" slot="button-next"&gt; &lt;img src="图片路径"/&gt; &lt;/div&gt; 其他内容： 如果想设置按钮暂时隐藏起来，等鼠标移动到再显示出来，可以设置opacity来进行控制 即点击自定义图片切换前进后退按钮(默认隐藏,hover显示)
.swiper-container .rot, .swiper-container .rat { opacity: 0; } .swiper-container .rot:hover, .swiper-container .rat:hover { opacity: 1; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8b0f20a3f28487ebb92b79a9c2a074f/" rel="bookmark">
			【CSS盒子模型学习(图解）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css盒子模型 一、什么是盒子模型？二、盒子模型详解1、盒子模型的标签2、盒子模型的常用属性(1)第一部分(2)第二部分(3)第三部分(4)第四部分(5)第五部分 三、HTML中元素类型的转换1、标签的等级2、元素类型的转换 一、什么是盒子模型？ 所有HTML元素可以看作盒子，在CSS中，"box model"这一术语是用来设计和布局时使用。CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。
上面的图片说明了盒子模型(Box Model)：
Margin(外边距) - 清除边框外的区域，外边距是透明的Border(边框) - 围绕在内边距和内容外的边框。Padding(内边距) - 清除内容周围的区域，内边距是透明的。Content(内容) - 盒子的内容，显示文本和图像。 盒子的宽度和高度的计算:
(1)实际宽度= width + 左右内边距(padding)之和 + 左右边框线(border)之和 + 左右外边距(margin)之和。
(2)实际高度= height + 上下内边距(padding)之和 + 上下边框线(border)之和 + 上下外边距(margin)之和。
二、盒子模型详解 1、盒子模型的标签 ①div标签：块级标签(容器)，在没有设置高度、宽度属性时，和p标签相似(会自动换行)。作为容器可以包含其他标签。
②p、span标签虽然是块级标签,但是不能作为容器使用
2、盒子模型的常用属性 用盒子作为页面的布局时会用到的属性
(1)第一部分 属性属性值说明width ：宽度；height：高度 ；border-style ：上边 [右边 下边 左边]; （边框线的样式）border-width ：边框宽度,单位是像素;border-color ：边框线的颜色; (颜色名/rgb(r,g,b)/rgba(r,g,b,a)/#rrggbb #rgb)border-bottom-left-radius:像素值或百分比；（表示的是圆角左下边框）border-top-left-radius:像素值或百分比；（表示的是圆角左上边框）border-bottom-right-radius:像素值或百分比；（表示的是圆角右下边框）border-top-right-radius:像素值或百分比；（表示的是圆角右上边框）padding-top :上填充padding-right :右填充padding-bottom :下填充padding-left :左填充margin-top:上边界(边距）margin-right:右边界(边距）margin-bottom:下边界 (边距）margin-left:左边界(边距） 注：
border综合写法:border: 线型 线宽 颜色; border边框综合写法：
border-radius：像素值或百分比; --&gt;表示的是圆角边框padding内边距综合写法：
padding:10px 四边的内边距都为10px;
padding: 10px 5px;上下为10，左右为5
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8b0f20a3f28487ebb92b79a9c2a074f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114f9b627b85de54546c56403dc8ecd1/" rel="bookmark">
			Arm linux开发板移植OpenSSH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景介绍
二、下载源码
三、交叉编译
1、交叉编译zlib
2、交叉编译openssl
3、交叉编译openssh
四、Arm linux开发板SSH环境搭建
1、创建相关目录
2、拷贝文件到开发板上
3、生产Key文件并拷贝到开发板上
4、修改配置
五、SSH测试
一、背景介绍 笔者开发的嵌入式设备在经常安装在不好接触的地方，不太方拉出串口来调试，因此就想到用SSH远程登录调试设备。SSH 全称为 Secure Shell(安全外壳协议，简称 SSH)，是一种加密的网络传输协议，用于在不安全的网络中为网络服务提供安全的传输环境。 SSH 功能很强大，但是最常用的还是用于远程登录。
二、下载源码 zlib:
官网下载：https://www.zlib.net
版本：zlib-1.2.2.tar.gz
openssl:
官网下载：https://www.openssl.org/source
版本：openssl-1.1.1k.tar.gz
openssh:
官网下载：http://www.openssh.com/portable.html
阿里云镜像：https://mirrors.aliyun.com/pub/OpenBSD/OpenSSH/portable
版本：openssh-8.5p1.tar.gz
注意：openssh与openssl是有版本依赖的，版本不匹配可能会导致其他错误。
三、交叉编译 1、交叉编译zlib 解压并配置安装路径
tar -vxzf zlib-1.2.2.tar.gz cd zlib-1.2.2/ ./configure --prefix=/home/lyy/tools/zlib 修改Makefile，将相关工具链改为交叉编译工具链
然后编译安装zlib
make make install 2、交叉编译openssl 参考 使用openssl+curl让嵌入式设备实现https通讯 文章中的安装openssl章节。
3、交叉编译openssh --with-zlib：zlib库所在的路径
--with-ssl-dir：openssl库所在的路径
注意：openssl编译完不需要安装
tar -vxzf openssh-8.5p1.tar.gz cd openssh-8.5p1 ./configure --host=arm-linux-gnueabihf --with-libs --with-zlib=/home/lyy/tools/zlib --with-ssl-dir=/home/lyy/work/openssl/arm-openssl CC=arm-linux-gnueabihf-gcc AR=arm-linux-gnueabihf-ar make 四、Arm linux开发板SSH环境搭建 1、创建相关目录 确保开发板上有以下目录，如果没有则需创建。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/114f9b627b85de54546c56403dc8ecd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8010b38d78517c6137547fbd325c208f/" rel="bookmark">
			Unity OnEnable() OnDisEnable() Start() Awake() 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.同一脚本执行顺序Awake()-&gt;OnEnabled()-&gt;Start()
（不同脚本之间的awake和enable顺序不能保证！可以理解为不同脚本优先级Awake=Enable&gt;Start，同一脚本优先级Awake&gt;Enable
（例： 物体A.Awake()-&gt;物体A.Enable()-&gt;物体B.Awake()-&gt;物体B.Enable()-&gt;物体A.Start()-&gt;物体B.Start()-&gt;）
2.Awake()和Start()在gameObject的整个生命周期中只会调用一次。
Awake()在gameObject首次被激活的时候调用，即使脚本组件未启用（如果有绑定父物体，父物体也应该处于激活状态）
Start()在脚本组件首次被激活的时候调用（前提是gameObject处于激活的状态,如果有绑定父物体，父物体也应该处于激活状态）
OnEnabled()和OnDisEnabled()在脚本组件状态和gameObject状态有一项为true，另一项状态在true和false切换时会被调用。(因为实际上让游戏物体被停用，其所有组件也会被禁用，本质上就是脚本的激活与失活会调用这两个函数)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33456c63d736f0a56fe6294792d6c5d4/" rel="bookmark">
			Qt QComboBox QSS样式设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QComboBox 样式表可谓太丰富了，研究了一阵，总结出的记录。
QComboBox整体样式 /* 未下拉时，QComboBox的样式 */ QComboBox { border-radius: 3px; padding: 1px 18px 1px 3px; background: transparent; border: 1px solid gray; color: #333333; border-color: #E5E5E5; background-color: #FFFFFF; } /* 点击QComboBox后的已选中项的样式 */ QComboBox:on { color: rgb(33, 188, 188); background-color: #f1ee04; } 设置QComboBox展开区的样式 /* 下拉展开后，整个下拉窗体样式 */ QComboBox QAbstractItemView { outline: 1px solid #000000;/*选中项外边框*/ border: 1px solid yellow;/* 整个下拉窗体的边框 */ color: #d34b4b; background-color: #FFFFFF; /* 整个下拉窗体的背景色 */ selection-color: #3377FF;/*下拉框选中项字体颜色*/ selection-background-color:#FFFFFF;/* 下拉框选中项的背景色 */ } QComboBox 箭头样式 /* 下拉框箭头样式 */ QComboBox::drop-down { subcontrol-origin: padding;/* 子控件在父元素中的原点矩形。如果未指定此属性，则默认为padding。 */ subcontrol-position: top right;/* 下拉框的位置（右上） */ width: 15px;/* 下拉框的宽度 */ border-left-width: 1px;/* 下拉框的左边界线宽度 */ border-left-color: darkgray;/* 下拉框的左边界线颜色 */ border-left-style: solid; /* 下拉框的左边界线为实线 */ border-top-right-radius: 3px;/* 下拉框的右上边界线的圆角半径（应和整个QComboBox右上边界线的圆角半径一致） */ border-bottom-right-radius: 3px; /* 同上 */ background: #333333; } /* 悬浮在下拉箭头时样式 */ QComboBox::drop-down:hover { background: #3cff59; } /* 下拉箭头样式 */ QComboBox::down-arrow { width: 15px;/* 下拉箭头的宽度（建议与下拉框drop-down的宽度一致） */ background: transparent;/* 下拉箭头的的背景色 */ padding: 0px 0px 0px 0px;/* 上内边距、右内边距、下内边距、左内边距 */ image: url(:/images/combobox_arrow_down.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33456c63d736f0a56fe6294792d6c5d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/497604a798da8b6b092502bf44054beb/" rel="bookmark">
			Dice Loss，balanced cross entropy，Focal Loss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dice Loss Dice系数是一种集合相似度度量函数，取值范围在[0,1]： s = 2 ∣ X ∩ Y ∣ ∣ X ∣ + ∣ Y ∣ s=\frac{2|X\cap Y|}{|X|+|Y|} s=∣X∣+∣Y∣2∣X∩Y∣​其中， ∣ X ∩ Y ∣ |X\cap Y| ∣X∩Y∣是 X X X和 Y Y Y之间的交集元素个数， ∣ X ∣ , ∣ Y ∣ |X|,|Y| ∣X∣,∣Y∣分别是 X X X和 Y Y Y的元素个数。
Dice Loss为： L d i c e = 1 − 2 ∣ X ∩ Y ∣ + 1 ∣ X ∣ + ∣ Y ∣ + 1 L_{dice}=1-\frac{2|X\cap Y|+1}{|X|+|Y|+1} Ldice​=1−∣X∣+∣Y∣+12∣X∩Y∣+1​Dice Loss常用于语义分割，我们将 ∣ X ∩ Y ∣ |X\cap Y| ∣X∩Y∣近似为预测tensor与GT tensor的element-wise乘积，再将乘积后的矩阵求和（令 X X X是pred， Y Y Y是GT）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/497604a798da8b6b092502bf44054beb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eb405e1f6ec89f6633df33f2eb006b1/" rel="bookmark">
			ijkplayer编译报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译环境搭建好，./compile-ijk.sh all 的时候报如下错误，
id.mk:1: *** missing separator. Stop.
/media/amba/ijkplayer-master/android
profiler build: NO
[armeabi-v7a] Prebuilt : libijkffmpeg.so &lt;= /media/amba/ijkplayer-master/android/contrib/build/ffmpeg-armv7a/output/
[armeabi-v7a] Install : libijkffmpeg.so =&gt; libs/armeabi-v7a/libijkffmpeg.so
/media/amba/ijkplayer-master/android
profiler build: NO
/media/amba/ijkplayer-master/android/ijkplayer/ijkplayer-arm64/src/main/jni/Android.mk:1: *** missing separator. Stop.
/media/amba/ijkplayer-master/android
profiler build: NO
/media/amba/ijkplayer-master/android/ijkplayer/ijkplayer-x86/src/main/jni/Android.mk:1: *** missing separator. Stop.
/media/amba/ijkplayer-master/android
profiler build: NO
/media/amba/ijkplayer-master/android/ijkplayer/ijkplayer-x86_64/src/main/jni/Android.mk:1: *** missing separator. Stop.
/media/amba/ijkplayer-master/android
百度了说是命令行前需要TAB，试了还是出错。（IJKplayer源码是从WINDOW下载到本地，然后挂载拷进linux。）
怀疑是编码有问题，删掉原有的源码。
在Linux环境下重新下载IJKPlayer源码编译。问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2361bbf5d6f8702c70511b2628fd7eb/" rel="bookmark">
			电脑怎么设置扬声器播放麦克风的声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 电脑麦克风采集的语音信息，可以通过扬声器直接播放出去，用户根据实际需求设置麦克风侦听功能即可实现该效果。接下来介绍电脑怎么设置扬声器播放麦克风的声音:
工具/原料
1.设置程序：麦克风属性2.操作电脑：台式电脑3.操作系统：windows7 旗舰版 方法/步骤
在电脑菜单中选择进入控制面板。在控制面板界面选择硬件和声音选项。然后在硬件和声音界面点击声音选项。在声音界面中点击上方的录制栏。然后双击麦克风选项进入设置。然后继续点击上方的侦听栏。在这里勾选：侦听此设备 选项。设置完之后点击下方的应用保存。 END
总结：
1、打开电脑控制面板进入硬件和声音。 2、双击鼠标进入麦克风属性界面。
3、在麦克风属性选择正听此设备。
END
注意事项
tips1：可以选择默认播放的声音设备。tips2：麦克风音量可以单独调节。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/763372519ac4f8f7cbb96ab679681e39/" rel="bookmark">
			【C&#43;&#43;】-- STL容器适配器之底层deque浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、deque的使用 二、deque的原理
1.deque的结构 2.deque的底层结构
（1） deque底层空间
（2）deque如何支持随机访问
（3）deque迭代器 3.deque的缺点
（1）deque的优势
（2）deque致命缺陷
4.deque作为stack和queue的底层默认容器的原因
一、deque的使用 在【C++】-- STL容器适配器之stack一文中介绍了容器适配器的概念，容器适配器是一个封装了序列容器的类模板，对容器进行了转换，转换成栈的后进先出和队列的先进先出的等模板。
虽然stack和queue中也可以存放元素，但在STL中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为stack和队列只是对其他容器的接口进行了包装，STL中stack和queue默认使用deque作为容器:
class template std::stack template &lt;class T, class Container = deque&lt;T&gt; &gt; class stack; class template std::queue template &lt;class T, class Container = deque&lt;T&gt; &gt; class queue; 那么deque到底是什么呢？有什么优势使得stack和queue都以它作为底层默认容器，对它进行包装，让stack和queue变成容器适配器的呢？
二、deque的原理 1.deque的结构 deque作为双端队列，是一种双开口的连续空间的数据结构 ，双开口即可以在头尾两端进行插入和删除，并且时间复杂度为O(1)，有没有发现结合了vector和list的优点：
（1）与vector相比，头插O(1)，不需要挪动元素
（2）与list相比，连续存储，空间利用率高
2.deque的底层结构 （1） deque底层空间 deque并不是真正连续的空间，而是由一段段连续的小空间拼接而成，实际deque类似于一个动态的二维数组，其底层结构如下：
中控指针数组中存放的是指向缓冲区buffer的指针，是动态开辟的二维数组，先malloc一个指针数组，指针数组的每个位置存放一维数组buffer的地址。当deque不断开buffer时，map中控指针数组满了，那么会增容，不过map增容的代价非常低，因为只需要拷贝存储数据的buffer数组的指针，不需要拷贝buffer中的内容。
如果要计算要访问的元素在第几个buffer里面，每个buffer固定大小，i/buffer.size()+1算出在第几个buffer中，i%buffer.size()算出是buffer中的第几个元素。
（2）deque如何支持随机访问 双端队列底层是一段假象的连续空间，实际是分段连续的，为了维护其“整体连续”以及随机访问的假象，落在了deque的迭代器身上，因此deque的迭代器设计就比较复杂：
（3）deque迭代器 那deque是如何借助其迭代器维护其假想连续的结构呢？ 如果一个buffer走完了，如何走到下一个buffer的位置呢？用node++来控制，node反向指向map当中当前buffer的位置，那么node++就指向下一个node的位置，解引用就是下一个buffer的位置。
node并不是从第一个位置就开始存放的，从中间开始存放，那么头插就还有空余位置。
3.deque的缺点 deque适合头尾插入删除，不适合随机访问，不适合大量中间插入删除，由于它结合了vector和list的特性
所以其优缺点也跟vector和list相关。
（1）deque的优势 ① 与vector比较：头部插入和删除时，不需要搬移元素，效率特别高，而且在扩容时，也不需要搬移大量的元素，因此其效率是必vector高的。
② 与list比较：其底层是连续空间，空间利用率比较高，不需要存储额外字段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/763372519ac4f8f7cbb96ab679681e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f0299f0f8ef82b26fb64642c9edf9f/" rel="bookmark">
			C语言的变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量是指在程序运行期间其值可以发生变化的量。变量用于从外部接收数据、保存一些不断变化的值、保存中间结果及最终结果，而这些都无法用常量来实现。一个变量应该有一个名字即变量名，在内存中占据一定的存储单元，在该存储单元中存放变量的值。
变量名实际上就是一个符号地址，程序在编译时由系统给变量分配一定的内存空间。程序中对变量进行处理时，实际上是通过变量名找到相应的内存地址，从其存储单元读取数据，也就是变量的值。
变量的定义与使用
在C语言中，所有的变量必须先定义后使用。
1.变量的定义
其定义格式:
类型说明符 变量名表：
其中：
（1）类型说明符必须是C语言中有效数据类型，如int、char、float等，用于指定变量的类型，该类型决定了编译时分配给变量的内存单元的多少。
（2）变量名表可以由一个或多个变量名组成，各变量名之间用“，”分隔。变量名必须是合法的C语言标识符，变量名一般使用小写的字母。
（3）变量的定义必须放在变量的使用之前，一般函数体的开头部分进行定义。
例如：
int r; /定义r为整型/
float v,f; /定义v、f为单精度浮点型/
char ch; /定义ch为字符型/
在C语言中，基本数据类型包括char(字符型)、int(整型)、float(单精度浮点型)及double(双精度浮点型)等。不同的类型用于存放不同的数据，所需要的才能出空间也不同。
2.变量的初始化
C语言允许在定义变量的同时对变量赋值，这个过程称为变量的初始化。如
int x=2; /定义一个整型变量x并赋初始值2/
int s=1,t=1; /定义一个整型变量s和t，并分别赋初值1/
float f=3.68; /定义一个浮点型变量f，并赋初始值3.68/
char ch=‘x’; /定义一个字符型变量ch并赋初始值字符x/
对变量初始化时需注意:
（1）对一个变量赋初始值之后，该值被存储在分配给该变量的内存空间
（2）不允许对多个未定义的同类型变量连续初始化，如：“int x=y=3;“是不合法的，应写成”int x=3,y=3;”。
（3）初始化时，一般应“=”右边表达式的数据类型和“=”左边的变量的类型一致，如果不一致，系统会进行自动赋值转换。
（4）没有进行初始化的变量，其值是由定义时所使用的存储类型决定的。全局变量和static型变量的值是0或‘\0’，其他存储类型的局部变量的值是未知的。
3.变量的使用
变量定义之后，就可以在程序中使用了。在程序中使用变量，称为变量的引用，如进行数值计算、数据处理等。使用变量时，应先赋值，后引用。
在程序中可以通过初始化、赋值表达式或者输入函数scanf（）来对变量赋值。
变量使用实例：
#include&lt;stdio.h&gt; int main() { int a,b,c; char ch='A';	/*初始化*/ a=10;	/*使用赋值语句对变量a赋初值*/ b=a+ch;	/*使用赋值语句对变量b赋值*/ scanf("%d",&amp;c);	/*使用scanf()函数对变量c赋值*/ printf("%d,%d,%d,%c\n",a,b,c,ch); return 0; } 在main（）函数中定义了三个int型变量a,b,c，一个char型变量ch。
若程序中运行时输入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f0299f0f8ef82b26fb64642c9edf9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa7b8e0cd8f443d1e2f313d6246c46e/" rel="bookmark">
			ubuntu 查看端口占用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看端口占用情况
netstat -nultp
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e06671ba0bda23530b76b73e7b9d2a8/" rel="bookmark">
			get请求特殊字符报错405 特殊字符搜索解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 场景描述：用户需要搜索一些活动号，这些活动号名称是用户自由定义的，用户为了提高识别度，会加一些特殊字符，但是我们的接口默认不支持特殊字符搜索，例如[]{}诸如此类，以及以下情况：
参数以字母问号 ? 、与运算符号 &amp; 、井号 # 开头的 Get 请求，对应变量被解析为”参数为空“或者”参数不存在“；
参数中出现若干个空格 ，访问链接解析异常，无法访问；
参数中出现百分号 % ，某些场景下会出现参数值解析截断；
参数中出现中括号[、] 任意的字符，直接报错 405 – Bad Request；
上述问题在前端进行 Base64 编码后传输，拼接新的 url Get 请求访问第三方接口时，同样出现上述错误。
其实在上面的描述中已经透露出了问题发生的原因和可能的解决方案，就是由于没有对参数进行编码，直接进行拼接导致的报错，经过编码后基本都可以规避上述问题。下面将会对每一个问题以及其具体的原因进行分析。
二、问题分析 1. 参数为空/不存在 这种情况在后端（比如 Java）的表现就是，获取的参数 keyword = null 或者 keyword = “”（keyword 定义为 String 时），也就是前端的 url 并没有准确将参数的值完整地传输到后端。
在 url 中，诸如字母问号 ? 、与运算符号 &amp; 、井号 # 这样的字符属于保留字符，即它们在 url 中具有特定意义：
?：分隔 url 和查询参数
&amp;：分隔参数
#：指定书签和锚点
因此，当 url 中的参数以这些字符开头时，参数的解析会在这些字符的位置被中断，从而将对应变量传入的参数值解析为空。
2. 空格导致访问链接解析异常 很明显，如果 url 没有经过编码，空格会被参数携带并拼接到 url 链接后，这样对应服务器来说，这个空格的含义就很模糊了，到底是参数的一部分，还是将前半部分当作 url，后半部分当作下一组字串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e06671ba0bda23530b76b73e7b9d2a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756e205ab5b5aecdc6257c245935e893/" rel="bookmark">
			NodeJS加密算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将通过crypto的api深入了解加密算法
安全加密 当发送方A向接收方B发送数据时，需要考虑的问题有：
数据的安全性。
数据的完整性，即数据不被篡改。
数据的真实性，即数据确实来自于发送方，传输过程中没有被替换。
数据的不可否认性，即验证发送方确实发送了数据。
保证安全性 对称密钥加密 Symmetric Encryption 对称密钥加密又叫专用密钥加密或共享密钥加密，即发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算。
流程 A 使用密钥加密数据
A 将密文发送给 B
B 收到密文后，使用相同的密钥对其进行解密，取得原始数据
优点：速度快
缺点：密钥被盗就被破解、密钥管理不方便（每个用户都要对应一个密钥）
实现算法有：凯撒密码，AES（Advanced Encryption Standard）、DES（Data Encryption Standard）、动态口令等。
推荐：AES
AES加解密特点 分组长度是128bit，也就是16字节。
加密第一步，针对每个分组逐个字节的进行SubBytes的操作。笼统的说，就是每个字节根据256个值的替换表，将当前字节替换成另外一个字节。
加密第二步，以单个字节为单位进行ShiftRows处理，就是将字节有规律的打乱。
加密第三部，再以4字节为单位进行MixColumns处理，就是进行比特运算变成另外的4个字节。
加密第四步，还是4字节为单位与轮密钥进行XOR运算。至此一轮运算就结束了。
解密的过程就是加密的逆向过程。
分组密码的模式 对称密钥算法DES、AES都属于分组密码，分组密码的特点是分组的长度是固定的。但是由于明文的长度不固定且基本超过分组长度，所以就需要进行多轮的迭代加密。 模式就是指的多轮迭代的方式。
ECB模式：Electronic CodeBook mode（电子密码本模式）
CBC模式：Cipher Block Chaining mode（密码分组链接模式）推荐使用
CFB模式：Cipher FeedBack mode（密文反馈模式）
OFB模式：Output FeedBack mode（输出反馈模式）
CTR模式：CounTeR mode（计数器模式）推荐使用
NodeJS示例：Cipher、Decipher // 加密 const crypto = require("crypto"); const algorithm = "aes-192-cbc"; const password = "Password used to generate key"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756e205ab5b5aecdc6257c245935e893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c21a73c03940a2040050f6ff29afb9/" rel="bookmark">
			考研数据结构学习与总结笔记---1.1数据结构的基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		考研数据结构学习笔记---王道 数据结构的基本概念1.数据2.数据元素3.数据对象4.数据类型5.数据结构 数据结构三要素1.数据的逻辑结构2.数据的存储结构3.数据的运算 回顾与总结(示意图)知识回顾习题(自理解版)心得体会 数据结构的基本概念 1.数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
2.数据元素 数据元素是数据的基本单位,通常作为一个整体进行考虑和处理。(个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。
例如:
3.数据对象 数据对象是具有相同性质的数据元素的一个集合,是数据的一个子集. 例如: 整数数据对象是集合N.
4.数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称,具体分为以下类型:
1)原子类型。其值不可再分的数据类型。( 如基本数据类型:int,bool类型)
2)结构类型。其值可以再分解为若干成分(分量)的数据类型。如:
Struct Customer{ int num; int people; } 3)抽象数据类型。抽象数据组织及与之相关的操作。ADT用数字化的语言定义数据的逻辑结构,定义运算,与具体的实现无关.
5.数据结构 数据结构是相互之间存在种或多种特定关系(例如先后关系) 的数据元素的集合在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构.
数据结构包括三方面的内容:逻辑结构、存储结构和数据的运算。
数据的逻辑结构和存储结构是密不可分的两个方面, 一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。
数据结构三要素 1.数据的逻辑结构 逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。(它与数据的存储无关，是独立于计算机的。数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构;集合、树和图是典型的非线性结构。数据的逻辑结构分类如下所示
集合: 结构中的数据元素之间除“同属一个集合”外，别无其他关系,例如: 一个果盘中各个水果的关系(没啥关系)
线性结构 结构中的数据元素之间只存在一对一的关系,例如排队是你和你前面人的关系(仅此前后关系)
树形结构: 结构中的数据元素之间存在一对多的关系，例如族谱,书本的目录.
图状结构或网状结构。结构中的数据元素之间存在多对多的关系 例如: 日常生活中一个班级中不同人的关系(复杂的人际关系网)
2.数据的存储结构 存储结构是指数据结构在计算机中的表示(又称映像)，也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。
1)顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中,元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间:缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。(例如排队关系)
2)链式存储。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元;缺点是每个元素因存储指针而占用额外的存储空间且L只能实现顺序存取。
**3)索引存储。**在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是(关键字,地址:)。其优点是检索速度快:缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。
4)散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash) 存储。其优点是检索、增加和删除结点的操作都很快;缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。
3.数据的运算 施加在数据上的运算包括运算的定义和实现运算的定义是针对逻辑结构的，指出运算的功能;运算的实现是针对存储结构的(如排队时插号的方法)，指出运算的具体操作步骤。
在此环节只需要理解:
1.若采用顺序存储，则各个数据元素在物理上必须是连续的;若采用非顺序存储，则各个数据元素在物理.上可以是离散的。
2.数据的存储结构会影响存储空间分配的方便程度(比如:有人想插队)
3.数据的存储结构会影响对数据运算的速度(比如:顺序存储就很容易找到第三个人,非顺序存储找到第三个人方式就很多可能更简单也可能更复杂)
回顾与总结(示意图) 可以通过以下图片回顾之前知识
知识回顾习题(自理解版) 1.可以用( D )定义一个完整的数据结构。
A.数据元素 B.数据对象 C.数据关系 D.抽象数据类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c21a73c03940a2040050f6ff29afb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c0bfda6c0c2865a3097e97b2d78b22c/" rel="bookmark">
			ImportError: cannot import name ‘process_pdf‘ from ‘pdfminer.pdfinterp‘错误完全解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、可以先卸载PDFMiner3K和PDFMiner，然后重新安装PDFMiner即可
pip uninstall PDFMiner3K pip uninstall PDFMiner pip install pdfminer3k 但是还是不行，说明有残留，残留就是
如何找到呢，就找和你PDF mine同一天下载的包，全部手动删掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc342f00aeab7b8445e37fa5e1e78a25/" rel="bookmark">
			Linux基础——MySQL（四）主从
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述
应用
场景
从服务器作为主服务器的实时数据备份主服务器实现读写分离，从服务器实现负载均衡把多个从服务器更具业务重要性进行拆分 创业型公司架构部署分析
互联网80%读，20%写
负载均衡器承受三个web连接，数据库要承受五百个连接且要支持后续增长，所以建立从数据库，主同步数据到从，两相数据一致。由于互联网80%都是读，20%是写，所以进行读写分离操作，减轻主服务器负担。Web写找mysql主库，主库将变化的语句记录到bin-log日志中，bin-log日志同步到从数据库进行执行，达到双方数据一致。所以使用负载均衡器指向两个从数据库，从从数据库读取数据，减轻主数据库负担。
NFS对web服务器进行挂载，放静态数据；同时也要保证数据安全，所以需要备份服务器。此时也就是全网备份了。（数据库的备份是在从服务器上进行的，也就是温备份，在表锁定的情况下进行备份，此时用户不可写。）
另部署一个管理服务器，安装Zabbix监控工具。
从库不够用，可以再加，但是最多不能超过五台，否则会拖累主库。此时就可以添加数据库缓存（后端缓存，如：redis）。当web要写新数据，会对MySQL主库和数据库缓存双写，读的时候先调取缓存中的内容；如果缓存中没有内容，那么就会从从库中读取，然后再写入数据库缓存，最后返还web。所以在数据库缓存中存储的都是热数据，也就是经常被用户访问的数据。降低了数据库的读压力。（类似于CPU从内存中读取数据，内存从硬盘中读数据。）
开发在工作中需要制作绘图统计方面服务，所以一般会再启用一台从库。这个库不是用来读数据的，而是用来做开发分析，测试的。
另起一个服务器用来增量和全量备份，启用bin-log日志。
所以五台数据库，最多三个用来读，一个给开发做测试，一个用来做全备，增备。
MHA是数据库的备库，一旦主库宕机，他就会启用。所以一般为二主五从。
主从复制原理
MySQL的主从复制不是实时同步的，是异步同步的，所以会产生数据延迟。
实时同步：从数据到数据
异步同步：经过以此或多次中转
修改两台服务器的server_id，让两台服务器区分主从；主库打开二进制日志（log-bin=mysql-bin），启动I/O线程，这个线程记录二进制日志。一旦产生了改变数据的SQL语句，I/O线程就会 把这些SQL语句记录到二进制日志中。从库打开中继日志（relay-log=relay-bin），生成I/O线程和SQL线程。I/O线程监控主库的二进制日志，一旦主库的二进制日志发生变化，从库的I/O线程就会找主库的I/O线程，让主库的I/O线程将数据复制给它，并将其写入从库的中继日志中。从库的SQL线程通过对中继日志的解析，将可执行的SQL语句解析并执行到从库中。主库创建主从复制账号：grant replication slave on *.* to…。要验证想要连接的从库。从库记录主库的IP，端口，二进制日志的位置，二进制日志的名字，主从复制账号和密码，这六个条件。激活从库 master.info记录跟踪主从之间复制过的数据
relay-log.info记录中继日志到哪个文件，进行到什么位置。
部署过程
1.
需要两台机器一个作为主库，一个作为从库。两台机器必须都是源码按章MySQL，不能使用yum安装客户端，也不能克隆。
2.
[root@server ~]# vim /etc/my.cnf
//进入主库，开启log-bin日志，查看server-id
[root@server ~]# /etc/init.d/mysqld restart
//重启MySQL服务
[root@server ~]# ss -antup | grep 3306
//查看服务端口是否开启
[root@server ~]# ls /usr/local/mysql/data/
//查看二进制日志是否生成
3.
[root@client ~]# vim /etc/my.cnf
//进入客户机MySQL主配置文件，关闭二进制日志，设置server-id，手动添加relay-bin=relay-bin
[root@client ~]# /etc/init.d/mysqld restart
//重启数据库
删除/usr/local/mysql/data里面的二进制文件。
4.
[root@server ~]# mysql -uroot -pabc123,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc342f00aeab7b8445e37fa5e1e78a25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee0fd00873e143c8f6d6b1f65c09e5d3/" rel="bookmark">
			Linux shell脚本中经常使用的date输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取某个格式如，2022-06-16T00-27-18
[root@localhost ~]# date=$(date +%Y-%m-%d) [root@localhost ~]# dateH_now=$(date +'%H-%M-%S') [root@localhost ~]# key_now=${date}T$dateH_now [root@localhost ~]# echo $key_now 2022-06-16T00-27-18 2、仅获取当前时间的时分秒
[root@localhost ~]# date +'%H-%M-%S' 00-26-0 3、获取当前时间的年月日时分秒
[root@localhost ~]# date +%Y-%m-%d' '%H-%M-%S 2022-06-16 00-30-34 4、设置系统时间
date -s "2022-06-16 00:31:00" clock -w 5、获取今天日期 2022-06-16
$ date -d now +%Y-%m-%d 或者 $ date +%F 6、获取明天日期 2022-06-17
$ date -d next-day +%Y-%m-%d $ date -d tomorrow +%Y-%m-%d 7、获取昨天日期 2022-06-15
$ date -d yesterday +%Y-%m-%d 或者 $ date -d last-day +%Y-%m-%d 或者 $ date -d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee0fd00873e143c8f6d6b1f65c09e5d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0a7d942c9dd6c031db93810b737c74/" rel="bookmark">
			前端面试题（Vue）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vue 说说vue动态权限绑定渲染列表（权限列表渲染） 首先请求服务器,获取当前用户的权限数据,比如请求 this.$http.get(“rights/list”);
获取到权限数据之后,在列表中使用v-if v-if-else的组合来展示不同的内容
&lt;template&gt; &lt;div&gt; &lt;!-- 面包屑导航区 --&gt; &lt;el-breadcrumb separator-class="el-icon-arrow-right"&gt; &lt;el-breadcrumb-item :to="{ path: '/home' }"&gt;首页&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;权限管理&lt;/el-breadcrumb-item&gt; &lt;el-breadcrumb-item&gt;权限列表&lt;/el-breadcrumb-item&gt; &lt;/el-breadcrumb&gt; &lt;!-- 卡片视图 --&gt; &lt;el-card&gt; &lt;el-table :data="rightsList" border stripe&gt; &lt;el-table-column type="index" label="#"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="权限名称" prop="authName"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="路径" prop="path"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="权限等级" prop="level"&gt; &lt;template slot-scope="scope"&gt; &lt;el-tag v-if="scope.row.level === '0'"&gt;一级&lt;/el-tag&gt; &lt;el-tag type="success" v-else-if="scope.row.level === '1'"&gt;二级&lt;/el-tag&gt; &lt;el-tag type="danger" v-else&gt;三级&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-card&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { // 权限列表 rightsList: [] }; }, created() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a0a7d942c9dd6c031db93810b737c74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aca4d5156fc6b13629bb6a23dd0f1f8/" rel="bookmark">
			华为欧拉系统（EulerOS）安装图形化界面，和设置开机启动为图形化界面，还是命令行界面，两种界面相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装图形化界面
先测试网络
ping baidu.com
使用快捷键Ctrl+c
安装dde图形环境 sudo yum -y install dde
设置图形启动 sudo systemctl set-default graphical.target
完成后，重启电脑，使用sudo reboot命令。等待系统启动进入到图形界面。
2.设置开机默认启动命令行界面
用systemctl set-default multi-user.target 然后重启生效
3.图形化界面和命令行界面相互转化
init 3 //命令行界面
init 5 //图形化界面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d7c9e68c3727cb705d8b3b15d24588f/" rel="bookmark">
			校园二手平台——微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于课程需要，所以学着做了一个小程序，用的是云数据库，没有使用云函数，具体思路如下 源码在这里：
链接：https://pan.baidu.com/s/1YFWfqYA719Kx07m3Ytjsdg?pwd=8osz 提取码：8osz 一、功能设计思维导图 二、整体目录结构 三、页面展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ae92b9ecfe011c41e673f11826d8d8/" rel="bookmark">
			Arrays.sort的几种用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常规一个数组参数，将数组从小到大排序，时间复杂度为o(nlog n)
Arrays.sort(nums);
数组部分排序，将数组下标在 l 和 r-1 的数据排序。
Arrays.sort( nums , l,r); 对二维数组分别以行列排序，依旧是从小到大。
行Arrays.sort(nums,(a,b)-&gt;a[0]-b[0]);
列 Arrays.sort(nums,(a,b)-&gt;a[1]-b[1]);
之前做过一个字符串匹配题目，需要给字符串数组按串长度排序
Arrays.sort(words, (s1, s2) -&gt; {return s1.length() - s2.length();});
字符串直接排序的话就是比较ASCII值
例如 abc Abc acb
排序过后 为 Abc abc acb
大写字母ASCII值小， 后两个第一为都是a ，就接着往后比。
当然还有一些其他的用法，今天就到这了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4faf50a6e77ce0e6101f1dd0b76eeb24/" rel="bookmark">
			Doris进阶——分区与分桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分区与分桶： Doris中有两层的数据划分，第一层是分区（Partition），第二层是分桶（Bucket）。
Partition又能分为Range分区和List分区。Bucket仅支持Hash方式。
Partition： 只能指定Key列作为分区列指定分区值时需要加双引号理论上分区数量没有上限在不使用分区建表时，系统会自动创建一个表名一致但是用户不可见的全表分区 Partition_Range：
按照指定范围进行分区，一般生产环境下会使用日期作为分区
VALUES LESS THAN (...) ：仅指定上界，系统会将前一个分区的上界作为该分区的下界，会生成一个左闭右开的区间VALUES [....) ：同时指定上下界，比较好理解，也会生成一个左闭右开的区间查看Partition的使用命令：HELP　PARTITION； 示例：
-- 创建一张Range分区表 CREATE TABLE IF NOT EXISTS test.students2 ( `sid` LARGEINT NOT NULL COMMENT "学生id", `name` VARCHAR(50) NOT NULL COMMENT "学生名字", `class` INT COMMENT "学生所在班级", `age` SMALLINT COMMENT "学生年龄", `sex` TINYINT COMMENT "学生性别", `phone` LARGEINT COMMENT "学生电话", `address` VARCHAR(500) COMMENT "学生家庭地址", `date` DATE NOT NULL COMMENT "数据录入时间" ) ENGINE=olap DUPLICATE KEY(`sid`, `name`) PARTITION BY RANGE(`date`) ( PARTITION `d202204` VALUES LESS THAN ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4faf50a6e77ce0e6101f1dd0b76eeb24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/200617d497f5b1120f5fce62b3414fb7/" rel="bookmark">
			semantic_slam环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		orb_slam2 + 语义分割 + 八叉树地图,
github地址：https://github.com/floatlazer/semantic_slam
根据github上环境的版本要求，选择在ubuntu16.04的docker容器中搭建
首先pull了一个ubuntu16.04 + python2.7 + opencv3.3.0的镜像，在这个基础上搭建环境
1.download semantic slam的code
在$HOME下
$ mkdir catkin_ws $ cd catkin_ws $ mkdir src $ cd src $ git clone https://github.com/floatlazer/semantic_slam.git 2.安装orb slam2的环境
参考了https://www.jianshu.com/p/dbf39b9e4617
这中间涉及到ros, pangolin, eigen等的安装
进入sematic_slam文件夹中的ORB_SLAM2文件夹，build成功即可
3.安装语义分割相关
按照semantic slam的github中的要求
$ sudo apt-get install ros-kinetic-openni2-launch 4.安装八叉树地图相关
sudo apt-get install ros-kinetic-octomap-ros sudo apt-get install ros-kinetic-octomap-msgs sudo apt-get install ros-kinetic-octomap-server sudo apt-get install ros-kinetic-octomap-rviz-plugins 5.安装语义分割相关
pip install torch-0.4.0-cp27-cp27mu-linux_x86_64.whl #1.0之前的版本要在官网上下载 pip install torchvision==0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/200617d497f5b1120f5fce62b3414fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4fef42c2ddbd2bfeeee98bc2489ea2b/" rel="bookmark">
			Maven问题：To see the full stack trace of the errors, re-run Maven with the -e switch.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错如下
ERROR] -&gt; [Help 1]
[ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
[ERROR] [ERROR] After correcting the problems, you can resume the build with the command
[ERROR] mvn &lt;goals&gt; -rf :receptions
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4fef42c2ddbd2bfeeee98bc2489ea2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9039747102896c23963d8f84bb48e047/" rel="bookmark">
			回溯法求解八皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题提出：八皇后问题是一个古老而著名的问题。该问题是十九世纪著名的数学家高斯1850 提出在 8x8 格的国际象棋上摆放八皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了 40 种不同的解，后人有人用图论的方法解出 92种结果。虽然问题的关键在于如何判定某个皇后所在的行、列、斜线是否有别的皇后;可以从矩阵的特点上找到规律，如果在同一行，则行号相同:如果在同一列上，则列号相同;如果同在“/”斜线上的行列值之和相同:如果在对角线上，则行列号之和或行列号之差相等，逐个纪录符合题意的情况,最终得出解。
解决思路：利用数组来求解。
1)解决冲突问题:这个问题包括了行，列，两条对角线。
行:规定每一行放一个皇后，不会造成行上的冲突;
列:当第1列被某个皇后占领后，则同一列上的所有空格都不能再放皇后，被标记位置为被占领状态。
对角线：对角线有两个方向，在同一对角线上的所有点都不能有冲突。
2)使用算法分析与设计的知识，用递归法、枚举法、回溯法等解决问题。
3）思考要解决的问题：用什么算法分析与设计来描述棋盘，怎样描述棋盘，怎样描述皇后（包括皇后的位置，怎样移动皇后等）。怎样开始程序。
4）初步解决问题，列出大纲。
所用算法：
回溯法：
回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。按选优条件向
前搜索，以达到目标。当探索到某一步时，发现原先选择并不优或达不到目标， 就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。
行A的皇后放在第一列以后，行B的皇后放在第一列已经发生冲突。这时候不必继续放行C的皇后，而是调整行B的皇后到第二列，继续冲突放第三列，不冲突了才开始进入行C。如此可依次放下行A至E的皇后，将每个皇后往右边横向、斜向攻击的点位用叉标记，发现行F的皇后无处安身。这时回溯到行E的皇后，将其位置由第4列调整为第8列，进入行F，发现皇后依然无处安身，再次回溯行E。此时行E已经枚举完所有情况，回溯至行D，将其由第2列移至第7列，再进入行E继续。按此算法流程最终找到可行解，成功在棋盘里放下了8个“和平共处”的皇后。继续找完全部的解共92个。
回溯算法求解八皇后问题的原则是：有冲突解决冲突，没有冲突往前走，无路可走往回退，走到最后是答案。
流程图： 运行代码：
#include &lt;stdio.h&gt;
int queen[8] = {0};
int sum = 0;
int cnt ; //表示摆放了几个皇后，也表示摆放皇后的行数。
int col ; //表示在这一列上摆放了皇后
void greedy(){
while(1){
//在(cnt,col)这个坐标摆放皇后
if(cnt == 1 &amp;&amp; queen[0] == 7 &amp;&amp; col == 6){ //表示第一行的皇后已经到了第八列且第二行的皇后到了第六列位置，已经摆放不下皇后了就退出循环
break;
}
int isAttack = 0; //用来表示皇后们之间是否能够攻击的到，如果攻击的到就是1，否则就为0
int i=0;
for(i=0;i&lt;cnt;i++){
if(queen[i] == col){ //表示在同一列上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9039747102896c23963d8f84bb48e047/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5d0072a884a301356abaf613eaceb7/" rel="bookmark">
			解决 pyinstaller：IndexError: tuple index out of range问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python文件打包成exe可执行文件出错。 Python 3.10.0
PyInstaller 5.1
官方文档说PyInstaller已经支持3.7之后的python版本，但在运行过程中还是遇到，IndexError: tuple index out of range问题。
解决办法： 编辑python3\Lib下的dis.py文件。
找到def _unpack_opargs(code)函数，在else语句中添加extended_arg=0，如下图所示。
在命令行输入命令，-F代表打包成一个exe文件，-c是命令行脚本。
pyinstaller -F -c test.py 已经打包成功了，dist文件夹中生成了一个exe文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4efe676542250978b2f76cc891738f0/" rel="bookmark">
			解决GDAL写投影问题——proj.db报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 处理高分影像时，因为原数据没有存储投影信息，所以需要自己定义。使用GDAL（osr）对遥感影像定义投影。使用以下代码
from osgeo import gdal, osr ’‘’ 其他读取影像数据的程序 ‘’‘ # 获取地理坐标系统信息，用于选取需要的地理坐标系统 srs = osr.SpatialReference() srs.ImportFromEPSG(4326) # 定义输出的坐标系为"WGS 84" out_IRS.SetProjection(srs.ExportToWkt()) # 给新建图层赋予投影信息 出现问题：
ERROR 1: PROJ: proj_create_from_database: D:\Anaconda\pkgs\proj-6.2.1-h9f7ef89_0\Library\share\proj\proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation. 这个报错是说，使用的proj.db是由另一个程序创建的。
原因分析
使用osgeo.osr能够直接从安装的GDAL包读取指定投影类型的信息，在proj.db中存储了常用的投影系统的参数，因此指定EPSG号就能从proj.db中取到投影信息。
经过排查，我的情况是在anaconda的虚拟环境中同时安装了GDAL和其他地理空间库，此时同一环境路径下可能会产生多个proj.db文件，访问它的时候程序会无法判断访问哪个。因此只需要去查找gdal安装的那个proj.db在哪里，在程序中指定环境变量即可解决。
资源管理器中虚拟环境的路径下查找proj.db，找到两个结果：
显然，应该使用osgeo目录下的那个。
解决方法
在程序开头指定环境变量，指定上一步查找的路径即可。
os.environ['PROJ_LIB'] = r'D:\Anaconda\envs\geoenv\Lib\site-packages\osgeo\data\proj' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68189b3202f084ab929b313dfa5a7f77/" rel="bookmark">
			ffplay自定义播放器封装C#接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffplay自定义系列 第一章 自定义播放器接口
第二章 倍速播放
第三章 dxva2硬解渲染
第四章 提供C#接口(本章)
第五章 制作wpf播放器
文章目录 ffplay自定义系列前言一、接口二、使用示例1、简单播放2、自定义渲染3、播放流数据4、音频播放器5、控制播放 三、下载总结附录1、dll的import代码 前言 因为曾经的wpf项目涉及到多种播放功能，拉流、点播、摄像头预览、音频测试、视频剪辑等，将ffplay的接口封装给C#调用实现了那些功能。最近自己新版本的播放模块也做了C#的封装，虽然现在不做C#项目了，但是留着以备不时之需。下面将对dll的接口和功能以及使用方法做一些说明。
一、接口 由本身的c接口设计理念就是面向对象多实例化的，所以直接将播放器封装成一个对象就可以了。dllimport的部分就省略了，下面只展示对象接口。
播放对象
namespace AC { /************************************************************************ * @Project: AC.Play * @Decription: 视频播放器 * 这是一个功能完整的支持主流常见媒体格式且支持多路播放的音视频播放器。 * 其播放主体为ffmpeg+sdl，本项目是通过对ffplay的源码修改拓展而成。 * 目前是支持跨平台，在Windows和Linux均可以正常使用。 * 主要更新特性 * v1.0:提供基本的播放、控制、多实例化 * v1.1:支持精准定位，播放周期事件 * v1.2:支持windows摄像头预览、倍速播放 * v1.3:支持dxva2硬解渲染，以及设置解码器 * @Verision: v1.3.6 * @Author: Xin Nie * @Create: 2018/11/27 13:34:00 * @LastUpdate: 2022/5/21 23:40:00 ************************************************************************ * Copyright @ 2022. All rights reserved. ************************************************************************/ /// &lt;summary&gt; /// 播放器对象 /// &lt;/summary&gt; public class Play { /// &lt;summary&gt; /// 播放开始事件 /// 调用Start后触发此事件，出现错误也可能不触发 /// &lt;/summary&gt; public event EventHandler&lt;PlayStartedEventArgs&gt; Started; /// &lt;summary&gt; /// 播放停止中事件 /// 播放开始失败、播放到结尾、调用Stop，会触发此事件 /// &lt;/summary&gt; public event EventHandler&lt;PlayStoppingEventArgs&gt; Stopping; /// &lt;summary&gt; /// 播放停止事件 /// 调用Stop、连续调用Start，会触发此事件 /// &lt;/summary&gt; public event EventHandler Stopped; /// &lt;summary&gt; /// 游标时间改变事件 /// 可用于获取当前播放时间 /// &lt;/summary&gt; public event EventHandler&lt;PlayCursorTimeChangedEventArgs&gt; CursorTimeChanged; /// &lt;summary&gt; /// 视频渲染事件 /// 自定义视频渲染时可使用此事件 /// &lt;/summary&gt; public event EventHandler&lt;PlayDisplayEventArgs&gt; Display; /// &lt;summary&gt; /// 播放窗口句柄 /// 设置后将渲染到对应窗口中 /// &lt;/summary&gt; public IntPtr Window {get;set;} // &lt;summary&gt; /// 硬件加速类型 /// 与VCodecName方法冲突，指定VideoCodecName后,此选项失效。 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68189b3202f084ab929b313dfa5a7f77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4322f3f03ff6d3aa901d906b6bb1e2eb/" rel="bookmark">
			Matlab-数字图像处理-基础实验-图片展缩(最近邻、双线性插值）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Matlab-数字图像处理-基础实验-图片展缩（使用最近邻、双线性插值）
Problem Statement 1.使用MATLAB开发环境来实现缩放转换。 开发一个函数，可以实现通过最近邻插值的图像缩放：
out = nearest(img, a)
其中img是图片字符串，a是比例因子，a&lt;1或者a&gt;1。
2.开发一个函数，可以实现通过双线性插值的图像缩放：
out = bi_linear(img, a)
其中img是图片字符串，a是比例因子，a&lt;1或者a&gt;1。
Procedure (A)out = nearest(img, a)
(1) Read image to “img_original” and get image size [row,col].
(2) Initialize the rows and columns of the new image.
(3) Use class()function to obtain the data type of the original image ( “img_original”), so that the new image (out) data type is consistent with the original image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4322f3f03ff6d3aa901d906b6bb1e2eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb6123134141ca9ea06fecf2eaf7813f/" rel="bookmark">
			v-model 的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 v-model 详解 v-model既可以作用于表单元素，又可作用于自定义组件，无论是哪一种情况，它都是一个语法糖，最终会生成一个属性与事件
当其作用于表单元素时，vue会根据表单的元素类型去生成合适的属性和事件，例如，作用于普通文本框的时候，它会生成value属性跟input事件，而当其作用于多选框、单选框时，它会生成checked属性和change事件
v-model也可作用于自定义组件，当其作用于自定义组件时，默认情况下，它会生成一个value属性和input事件
&lt;Comp v-model="data" /&gt; &lt;!-- 等效于 --&gt; &lt;Comp :value="data" @input="data=$event" /&gt; 还可以通过model的配置来改变生成的属性和事件
// Comp const Comp = { model: { prop: "number", // 默认为 value event: "change" // 默认为 input } // ... } &lt;Comp v-model="data" /&gt; &lt;!-- 等效于 --&gt; &lt;Comp :number="data" @change="data=$event" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17bf3ccf5276aee7a4e6b39dc0ce5afd/" rel="bookmark">
			FileZilla Client下载安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载安装 （1）进入官网FileZilla - The free FTP solution
点击“Download FileZilla Client”之后，进入下载页面，
（2） 点击“Show additional download options”，进入Download FileZilla Client
选择适合的版本进行下载， （3）等待下载完成，找到刚刚下载的文件，
（4）每一步的安装流程如下，
点击“我同意”，进入下一步，
点击“next”下一步， 可以勾选在桌面创建快捷键，点击“next”下一步， 此处可以改变安装路径，点击“next”下一步， 点击“install”进入安装， 等待安装完成，
（5）点击“finish”之后，软件自动打开，
OK，安装完成了。
二、介绍 FileZilla 客户端是一个快速可靠的、跨平台的FTP,FTPS和SFTP客户端。具有图形用户界面(GUI)和很多有用的特性。一种快速、可信赖的FTP客户端以及服务器端开放源代码程式,具有多种特色、直觉的接口。
易于使用：FileZilla比其他任何一款FTP软件都要简单
多协议支持：FileZilla支持FTP、FTPS、SFTP等文件传输协议
多种语言：FileZilla支持多国语言，完美支持简体中文
多标签界面：FileZilla支持建立多个标签同时工作
远程查找文件：FileZilla支持远程查找文件功能
站点管理器：FileZilla自带功能强大的站点管理和传输队列管理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64653280df5b2f8f6302c9bb8ab0e262/" rel="bookmark">
			postgresql数据库不能删除解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在PostgreSQL中，如果一个库正在被使用，我们是无法直接去删除的，会收到如下报错：
postgres=#drop database demodb;
postgres=#drop database demodb; ERROR: database "demodb" is being accessed by other users DETAIL: There is 1 other session using the database. 不管是在命令行还是使用工具，我们都无法正常删除相应的数据库，这是postgresql的安全机制，正在使用有进程存在的数据库不能直接删除，出现这种情况建议重新创建一个数据库，把之前的数据备份，然后导入到新的数据库中。
在所有情况都允许的情况下又不得不删除原来的数据库，那么我们可以使用下面的方法来进行操作：
首先我们需要禁止会话再连接到库中，同时中断掉当前所有连接的会话才可以。
登录到数据库中 psql -U 用户名
在postgresql数据库命令行模式下进行操作
postgres=#
1、设置数据库为禁止连接 UPDATE pg_database SET datallowconn = 'false' WHERE datname = 'db_name'; 2、中断当前库中所有连接会话 SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = 'db_name'; 3、最后执行删除命令 drop database db_name; 注意！ 最后提示 ：“删库有风险，需谨慎操作！”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7ed6a9f053d3ef22bdf54aa3e21df5/" rel="bookmark">
			gradient descent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		full graident
相对sgd容易陷入local minimum，但是深度神经网络的high- dimension representation 不存在很多的local minimum
sgd
不容易陷入local minimum，因为noise
mini-batch
常用的
使用更大的batch size 降低了convergence的速度，值得注意的是btsize 与gpu显存相关
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422f332116d6ffe44c7b9875b451b561/" rel="bookmark">
			gitlab cicd 条件执行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gitlab条件、分支判断的demo 可以查看官文档：更加详细。可以实现指定分支分条件运行或者指定job分条件运行等。
--- .script: stage: build script: - env | grep CI_COMMIT_ | sort - if test -n "$CI_COMMIT_BRANCH" ; then echo "test -n CI_COMMIT_BRANCH = true"; else echo "test -n CI_COMMIT_BRANCH = false" ; fi - if test -n "$CI_COMMIT_TAG" ; then echo "test -n CI_COMMIT_TAG = true"; else echo "test -n CI_COMMIT_TAG = false" ; fi - if test -z "$CI_COMMIT_BRANCH" ; then echo "test -z CI_COMMIT_BRANCH = true"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/422f332116d6ffe44c7b9875b451b561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f913ecada7877499553edff310d432c5/" rel="bookmark">
			一个与微信小程序&#43;springboot后台的实时签到系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闲来无事，发现微信小程序挺好玩的所以打算做一个项目学习下小程序的使用，于是就有了这个项目。目前已经完成了基本的功能，如下图
项目总览：
签到地图：
签到任务：
签到记录：
个人中心：
后台管理界面：
体验码：
后端主要是springboot+mybatis框架加上mysql数据库，整体项目难度不大，还是比较容易上手的。
大家需要源码的话可以私信评论我QAQ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f027c84156028f5564e70bfc01208040/" rel="bookmark">
			FFmpeg源代码简单分析-架构图-解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接 FFmpeg源代码结构图 - 解码_雷霄骅的博客-CSDN博客_ffmpeg雷霄骅 函数背景色 函数在图中以方框的形式表现出来。不同的背景色标志了该函数不同的作用： 粉红色背景函数：FFmpeg的API函数。白色背景的函数：FFmpeg的内部函数。黄色背景的函数：URLProtocol结构体中的函数，包含处理协议（Protocol）的功能。绿色背景的函数：AVInputFormat结构体中的函数，包含处理封装格式（Format）的功能。蓝色背景的函数：AVCodec结构体中的函数，包含了编解码器（Codec）的功能。PS：URLProtocol，AVInputFormat，AVCodec在FFmpeg开始运行并且注册完组件之后，都会分别被连接成一个个的链表。因此实际上是有很多的URLProtocol，AVInputFormat，AVCodec的。图中画出了解码一个输入协议是“文件”（其实就是打开一个文件。“文件”也被当做是一种广义的协议），封装格式为FLV，视频编码格式是H.264的数据的函数调用关系。 区域 整个架构图可以分为以下几个区域：左边区域——架构函数区域：这些函数并不针对某一特定的视频格式，通用架构，通用流程右上方黄色区域——协议处理函数区域：不同的协议（RTP，RTMP，FILE）会调用不同的协议处理函数。右边中间绿色区域——封装格式处理函数区域：不同的封装格式（MKV，FLV，MPEGTS，AVI）会调用不同的封装格式处理函数。右边下方蓝色区域——编解码函数区域：不同的编码标准（HEVC，H.264，MPEG2）会调用不同的编解码函数。 箭头线 为了把调用关系表示的更明显，图中的箭头线也使用了不同的颜色：黑色箭头线：标志了函数之间的调用关系。红色的箭头线：标志了解码的流程。其他颜色的箭头线：标志了函数之间的调用关系。其中： 调用URLProtocol结构体中的函数用黄色箭头线标识；调用AVInputFormat结构体中的函数用绿色箭头线标识；调用AVCodec结构体中的函数用蓝色箭头线标识。 函数所在的文件 每个函数旁边标识了它所在的文件的路径。此外，还有一点需要注意的是，一些API函数内部也调用了另一些API函数。也就是说，API函数并不一定全部都调用FFmpeg的内部函数，他也有可能调用其他的API函数。 例如从图中可以看出来，avformat_close_input()调用了avformat_free_context()和avio_close()。这些在内部代码中被调用的API函数也标记为粉红色。 现在的执行流程 FFmpeg在avcodec.register_all被弃用后，新的流程_弥彦已死的博客-CSDN博客从学龄前开始解读FFMPEG代码 之 avcodec_register_all函数_zzyincsdn的博客-CSDN博客 模块介绍 右上区域（URLProtocol协议处理函数） URLProtocol结构体包含如下协议处理函数指针： url_open()：打开url_read()：读取url_write()：写入url_seek()：调整进度url_close()：关闭结构体代码 typedef struct URLProtocol { const char *name; int (*url_open)( URLContext *h, const char *url, int flags); /** * This callback is to be used by protocols which open further nested * protocols. options are then to be passed to ffurl_open_whitelist() * or ffurl_connect() for those nested protocols.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f027c84156028f5564e70bfc01208040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b3d04dd5dcd4af8ad6fbacf7620f9e/" rel="bookmark">
			更新pip的时候报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我要搭建vulhub，官网是这样说的。
我安装过后
2
我没有py3
并且这个好像要扶梯子
官网的到这就杀过了。
搜到一篇这个用pip安装，同理要先安装pip
接下来就是pip更新
问题来了哈
更新了又叫我更新，陷入死循环，这个报错网上也没搜出来。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64c0828135b31c8903fda1c21cb07e8/" rel="bookmark">
			好久不见～
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天突发奇想翻了翻以前的内容，看看日期，我噻，好久没有更新过了，但是每天都有朋友来关注、点赞收藏，甚至留言我的博客内容，再次表示十分感谢大家了。
所以决定今天来更新一篇，但是不是什么技术上的文章，毕竟我离技术稍微远点了，呃，其实项目管理也是门技术活。
废话不多说了，那我就分享下，我近期来的工作生活吧。这一年成功跳槽到大厂工作，还别说，大厂就是大厂，能学习到的（包括管理模式）更上一层楼了，而且薪水还涨了，这怎么不叫人欢喜。但是大厂也有坏处，譬如，卷。哈哈，这个不用我多说，就连我们平时一起吃饭，都拿这个开玩笑。不过呢，有点遗憾，我的工作生涯可能要告一段落了，具体原因不细说了，大家自行体会吧～～
尽管如此，这一年也是给了我不少的体验，工作环境、午餐、饭后水果等福利就不说了，感觉首先想道的就是有好领导，有好同事，特别特别感谢他们对我工作的支持。产品很积极、研发很积极、测试很积极，除了中间有些让我无可奈何又气急败坏，但是总体还是很顺利的渡过了。管理了几个平台，参与了几个项目，跨平台合作，天天都在说说说，每次都在问问问，真怕他们会嫌弃我，😄哈哈。。但是呢，每次按时发版上线，项目交付，都很让人兴奋🥰，怎么这么有成就感呢，工作不再千篇一律，每天都是新的挑战，感觉时间过的很快，偶尔突然意识到，快过国庆节，快过年了呀。
虽说这一年来，受大环境影响，整个行业都处于动荡不安的状态，就连某腾都开始采取升职不加薪的模式，但是也别担心，最近升级的新星互联网行业也是很值得考虑的，比如国产数据库、SaaS、Pass、电动车软件需求等等，安全度过低谷期是最重要的。还有很重要的一点，尽量保留些许资金，这种时候买房子也需要慎重。
嗯，今天就先这样吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e308a0d78892d8860c658cb681bf53d/" rel="bookmark">
			Ubuntu20.04系统安装及配置Android编译环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录ubunt系统（server版本）安装配置
安装时分区配置 按提示一直下一步安装提示，需要关注分区设置。
swap 创建 swap交换分区，系统运行过程，当物理内存不够会使用到swap交换分区。
swap大小设置，参考：
4G以内的物理内存，SWAP 设置为内存的2倍。
4-8G的物理内存，SWAP 等于内存大小。
8-64G 的物理内存，SWAP 设置为8G。
64-256G物理内存，SWAP 设置为16G。
如果系统安装时设置较小，可以后续调整，加大swap分区。
加大方法：
个人笔记本配置一般，加大前如下：
$ free -m
total used free shared buff/cache available
Mem: 7735 2445 929 772 4360 4236
Swap: 11548 0 11548
创建swapfile
mkdir swap
cd swap
sudo dd if=/dev/zero of=swapfile bs=1024 count=20000000
sudo mkswap swapfile
挂载swap
sudo swapon swapfile
挂载后swap大小变化：
$ free -m
total used free shared buff/cache available
Mem: 7735 2580 804 724 4350 4150
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e308a0d78892d8860c658cb681bf53d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/601f6cc47c3d202f0440dd6d30d7ef41/" rel="bookmark">
			JAVA-Web项目前后端接口定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前后端交互接口定义等（Rest请求等） 一、GET请求 前端请求方式 url?参数1名=参数1值&amp;参数2名=参数2值...... 例： brandyf.boost-traffic.jd.com/boost/traffic/monitor/plan/download?planId=1 后端写法 1、 @RequestMapping(value = "/apply/list", method = RequestMethod.GET) public String testMethod(@RequestParam("num") Integer pageNum, @RequestParam("size") Integer pageSize) { log.info("{},{}",pageNum,pageSize); return "OK"; } 2、 @RequestMapping(value = "/apply/list", method = RequestMethod.GET) public String testMethod(Integer pageNum, Integer pageSize) { log.info("{},{}",pageNum,pageSize); return "OK"; } 说明： @RequestParam：将请求参数绑定到你控制器的方法参数上，常见使用如下： @RequestParam(value="pageNum",required = true,defaultValue = "12") value:绑定参数的指定名称 required：是否必填 defaultValue：默认值，如果参数为数值型，这里会自动转换 二、POST请求 前端请求 接口地址 : /aaa/ccc/getobj 请求方式 : POST 请求数据类型 : application/json 请求示例 : { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/601f6cc47c3d202f0440dd6d30d7ef41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b08f37c1a9da85a5be08bf165ca0ec4a/" rel="bookmark">
			element- ui , el-select 多选，选择后自动关闭下拉框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景：
问题：单选选中之后，再次打开，不会定位到当前下拉勾选/选中项位置。
发现：多选可以定位到选中位置。
解决办法：用多选代替单选框，只要每次勾选后、替换前一次所选的值，即可实现单选的效果（但是下拉框不自动关闭，所以需要再手动关闭下拉框即可）。
如图：
单选（打开）： 多选（打开）：
效果：el-select 多选 ，选择下拉内容后自动关闭
html：
&lt;el-select ref="multiSelect" v-model="selectName" filterable multiple value-key="userid" @change="chooseCustom"&gt; &lt;el-option v-for="(item, index) in customList" :key="index" :label="item.username" :value="item" /&gt; &lt;/el-select&gt; js：
chooseCustom(){ //调用element-ui select组件blur方法 //要包再timeout里面，直接调用不会关闭下拉框option setTimeout(() =&gt; { this.$refs.multiSelect.blur() }, 50) } ps：
1、试过获取单选的scrolltop，通过scrolltop定位，但是没获取到scrolltop（一直为0）
2、试过通过直接获取到下拉option框dom，并直接display：none；（是可以关闭，但下拉箭头未改变，且组件中的visible等值未变，打开时，需要点击两下才能再次打开 -- 第一下关闭下拉框并修改值等，才会再次打开），所以不可只是单纯的将dom元素display掉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9284de8591b7c1ce3fd3d0fb0532570e/" rel="bookmark">
			时序图，程序员的保命技能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，各个大厂都在开猿节流，程序员们在公司里，靠什么技能来“保命”？
一方面，大家要有过硬的编程基础，另一方面，对UML图的掌握也很重要。今天，我们就来说一说其中一种重要的UML图：时序图。
时序图的使用场景非常广泛，几乎各行各业都可以使用，可以用于梳理业务流程，使业务看起来非常清晰，也可以梳理开源软件，梳理各个组件之间的关系，层次非常清楚，便于记忆，也可以使用在更多场景。
一、什么是时序图？
时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作，包括发送消息、接收消息、处理消息、返回消息等。
时序图重在展示对象之间的交互顺序，尤其强调交互的时间顺序，它可以直观的描述并发进程。
二、时序图的组成元素
时序图的组成元素主要有5种：
1. 角色(Actor)
系统角色，可以是人或者其他系统和子系统，以一个小人图标表示。
2. 对象(Object)
对象位于时序图的顶部，以一个矩形表示。对象的命名方式一般有三种：
1）对象名和类名。例如：华为手机:手机。
2）只显示类名，不显示对象，即为一个匿名对象。例如：:手机，在时序图中，用“：类”表示。
3）只显示对象名，不显示类名。例如：华为手机:，在时序图中，用“对象:”表示。
3. 生命线(LifeLine)
时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线(对象的时间线)，以一条垂直的虚线表示。对象间的消息存在于两条虚线间。
4. 激活期(Activation)
又叫控制焦点，它代表时序图中在对象时间线上某段时期执行的操作，以一个很窄的矩形表示。
5. 消息(Message)
表示对象之间发送的信息。消息分为三种类型。
1）同步消息(Synchronous Message)。消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义，以一条实线和实心箭头表示。
2）异步消息(Asynchronous Message)。消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的，以一条实线和大于号表示。
3）返回消息(Return Message)。返回消息表示从过程调用返回，以小于号和虚线表示。
三、时序图优质模板
为了方便大家学习和绘制时序图，小编为大家准备了几张不同场景下的时序图绘制案例供大家研究和学习，希望大家能快速掌握时序图的使用技巧。
1、微信支付时序图
2、时序图-登录
3、验证码注册时序图
4、店员-时序图
5、sso登录时序图
6、打印电子发票时序图
以上是在不同场景下程序员绘制时序图的案例，以上模板可以直接克隆使用，但授之以鱼不如授之以渔，接下来就为你分享时序图的绘制方法和绘制工具。
四、时序图的画法
时序图的绘制方法简单总结为以下3步：
1、划清边界，识别交互语境
即界定好自己所要画的时序图的范围，了解所要画的时序图的前提和背景。
比如“学生信息管理”就是所要绘制的时序图的交互内容，就不需要往上延伸到学生注册并认证身份，不需要用户登录，也不需要往下延伸到查询课表、资料下载等无关的内容上。
2、梳理角色和对象
在“学生信息管理时序图”中，角色有学生/教务用户，对象有教务主界面、学生信息界面、管理学生信息界面、数据库。
注意：角色和对象都是名词，动词不可以作为角色和对象。
3、添加消息
从触发整个交互的某个消息开始，在生命线之间从上到下依次画出所有消息，并注明每个消息的特性，如参数等。
如何绘制时序图？
推荐大家使用ProcessOn——一款专业在线作图工具和知识分享社区，支持流程图、思维导图、原型图、网络拓扑图、UML等专业图形的绘制，无需下载安装，即可免费使用。
以下是使用ProcessOn绘制时序图的操作方法：
Step1：注册登录ProcessOn（https://www.processon.com）
Step2：进入个人文件页，新建流程图，添加UML图形到图形区
Step3：拖拽使用UML相关图形到编辑区
Step4：标注内容，添加消息即可
如果你想让自己的时序图更美观一些，可以把标题、矩形框等填充不同颜色、相同的图标尽可能大小相同（复用功能很好用哦）、上下图形保持对齐等哦。
时序图的绘制方法和使用场景，小编已经分享完了，你学会了吗？没学会也没关系，模板库中还有更多时序图模板可以学习哦。同时，小编也为大家准备了ProcessOn的福利，识别下方海报二维码即可领取哦。
ProcessOn产品介绍 1.支持思维导图、流程图、原型图、时序图、架构图等十多种图形绘制。
2.无需下载安装，多端免费使用。
3.支持多人在线协作、修改文件。
4.有个人和团队两个版本，团队版可轻松实现资源共享和团队管理。
5.网站有海量各行各业的优质模板可供使用。
6.模板发布，可以获得收益，知识变现。
最后，祝愿程序员小伙伴们工作顺利，留住头发！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a309eba3a3c62084689ba660642af967/" rel="bookmark">
			Linux基础——Web（三）Nginx反向代理2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当负载均衡后方节点出现问题时，是没有错误提示的，而是不再把用户请求代理给坏的节点。当坏的修好后，过几秒会进行检测，会自动启用该节点。
1.
如果负载均衡池里的server加入backup参数，nginx会把它当作备用的Web节点，只要还有存活的其他节点，就不会启用备用节点。
（测试：负载均衡池的一个server后加入backup，退出保存后重启nginx服务，并访问域名，出现的为200.7的解析，当在200.7停用nginx服务时，再解析时，出现的是200.6的解析，表示调用备用的Web节点。）
2.
如果负载均衡池里的server加入down参数，nginx默认会忽略该server，认为他是坏的，或停用的。
实用场景：就算一个Web的server坏了，Nginx不再将用户的请求代理给这
个节点，但是nginx仍然在不断对这台server进行健康检测，消耗Nginx的服务资源。因此在我们维修这个坏了的server节点的时候，我们通常需要进入NginxLB配置文件里，给对应损坏的节点后面加入down参数，让Nginx忽略这台Web节点，然后我们再去维修这台坏了的server或者更换一台完好的server节点上去，连接好后，再去掉NginxLB的down参数，平滑重启Nginx。
（测试：在一个Web节点后加入down参数，重启服务后，访问域名时，200.7将停用，直接调用了200.6的Web节点。）
调度
算法
rr轮询（默认调度算法，静态调度算法）
负载均衡池里的server，如果按照1：1的比例分配给用户的请求，我们叫做轮询模式：rr
wrr（权重值，静态调度算法）
按权重值比例分配，成为wrr
ip_hash（静态调度算法）（会话保持）
如果按静态调度算法分配，我们成为ip_hash（根据用户的来源IP，计算出一个hash值，如果同样hash值的用户，默认代理给同一个Web节点。）
会话
保持
我们和客服的聊天记录，一般是存在内存里，所以会定期清空。想要保存这些数据，需要占用大量的内存空间，如果要永久保存就要占用数据的空间。对于附件，视频，图片这些大容量的数据资源，一般就会定期清空。
情况1
我们在与A的聊天信息在B也能看到，就是会话保持
情况2
进行会话保持
第一种：ip_hash，同一个IP地址的用户，永远代理给同一个Web节点来处理。
虽然ip_hash维持了用户的会话保持，但是，同一个IP地址永远代理给同一个Web节点，也就意味之失去了，负载均衡的意义，根本就不可能真正的负载均衡了。
第二种：一致性hash算法
开源nainx没有一致性hash算法，淘宝二次开发的tengine才有，要使用这种算法，需要取官网下载补丁包，打补丁
根据用户请求的uri进行hash。
第三种：cookie
用户访问网站的时候，网站可以给用户下发一个叫做cookie的文件，保存在用户的浏览器里，开发可以向cookie里写数据，将验证码的答案写入到cookie里。那么用户再次访问网站的时候，WebB可以通过读取用户的cookie信息，来知道具体的答案是多少，从而对用户的验证码进行验证。
这个过程是开发实现的。
第四种：session
session是运维解决的。
php默认会将用户的验证码写入到本地的session文件里，远程将session写入到redis（内存型数据库缓存）里。修改PHP的配置文件里的session保存路径。
盗链
在开发的动态网页里，其实根本没有图片，动数据都是文字数据，而图片是存在存储里，既不是在数据库中，也不是在网页代码中。
一般在工作中，我们通过Nginx反向代理，至少要分三类型的业务：读动态业务，写动态业务，读静态业务。 location过滤的是uri部分，如URL为：http://www.baidu.com/index，它的URI为index。
访问www.yunjisuan.com，默认进第一个负载均衡池，进入读动态
访问www.yunjisuan.com/upload/xxx.jpg，进入第二个负载均衡池，进入写动态
解析
流程
一般解析流程为：用户输入域名，反向代理代理给动态集群，找到首页，首页激活代码，从数据库拿出动态数据（可能是文字或图片，电影的地址等），然后把他们填充到页面里，返回给用户，用户的浏览器解析到文字直接显示到浏览器，解析到图片会重新发起一个URL，经过反向代理过滤，到静态集群，通过存储，把对应的图片取出，显示到浏览器中。因此，当网速很慢时，打开网站，会先显示文字，然后图片再一点一点地刷新出来。
思考
问题
用户当前临时上传的头像图片，一刷新用户就看到是如何实现的？
盗链图片，盗链电影如何实现？
用户上传图片附件，该内容放在NFS里；动态找MySQL；静态找NFS。
用户上传的图片附件要写入到NFS中，所以NFS需要挂载到上传；用户从静态进行读取数据，所以NFS也要挂载到静态。
基本流程：红箭头：上传；黑箭头：读取。
同一个页面，数据会变，说明他是动态网页。既然头像变了，说明头像对应的图片地址就变了，因此图片的地址，是保存在数据库里的。
刷新后就能直接看到，是因为在上传用户图片时，不光写入到了NFS里，同时在MySQL动态里也存储了一份，这样用户在通过同台访问个人中心直接就能访问MySQL，然后返回给用户。
什么是盗链
好比，原本是用户给爱奇艺钱，在爱奇艺看电影，但是我弄了一个链接，用户将钱给我，然后连接到爱奇艺的存储服务器看电影，而我却并没有真实存储电影的服务器，从而减少了存储服务器的成本，但是让用户看到了想要的结果。
盗链操作举例
1.
搜索一个图片，注意：不要是富含链接的图片（富含链接的图片：点击图片弹出网页）复制图片的地址。
2.
新建一个记事本，编写内容：将红色方框内的内容换成图片的链接，保存退出，然后将txt格式改成html后缀格式。
3.
双击这个文件
这样的操作就是简单的盗链操作，电脑上并没有这个图片，但是可以通过网页链接进行跳转访问。
预防
盗链
打水印，来源于名。这样用户看多了，就会去原站，因为他认为原站更专业。
盗链
操作
作业：三台设备，一个LB负载均衡器，一个动态Web，一个静态Web。通过负载均衡器访问动态Web的域名，让其从静态服务器上取图片。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a309eba3a3c62084689ba660642af967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d415de59078af60c5bc899b21f46e2ae/" rel="bookmark">
			js中(function(){})()的写法用处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js中(function(){})()的写法用处
首先嘛，JS中函数有两种命名方式
1、一种是声明式。
而声明式会导致函数提升，function会被解释器优先编译。即我们用声明式写函数，可以在任何区域声明，不会影响我们调用。
function XXX(){} 2、一种是函数表达式
函数表达式我们经常使用，而函数表达式中的function则不会出现函数提升。而是JS解释器逐行解释，到了这一句才会解释。因此如果调用在函数表达式之前，则会调用失败。
var k = function(){} fn1(); function fn1(){}//可以正常调用 fn2(); var fn2 = function(){}//无法调用 下面进入正题，对函数表达式加上()，是可以直接调用的
但是如果是对声明式的后部加上()则是会被编译器忽略。
var fn2 = function(){}();//对，就是这样 function fn1(){}();//会被忽略 而平常的function(){}则是一种声明式，如果加上()括号后，则会被编译器认为是函数表达式，（加上±号都可以），从而可以用()来直接调用
(function fn1(){})(); (function (){ let amis = amisRequire("amis/embed") let amisJson = { type:"page", body:[ { type:"html", html:"&lt;h1&gt;登录界面&lt;/h1&gt;" } ] } let aa = amis.embed("#index",amisJson) })(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e8eef4852bebef27f23b0e20266e2a6/" rel="bookmark">
			为什么BFE可以取代Nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BFE是基于Go语言编写的七层负载均衡开源软件，诞生于2014年。2020年6月，BFE被CNCF（Cloud Native Computing Foundation，云原生计算基金会）接受为“沙盒项目”（Sandbox Project），成为中国第一个网络方向的CNCF开源项目。BFE已经在百度大规模使用多年，每天转发超过万亿的请求；BFE也被度小满、央视网、招商银行、360、用友网络等机构选用。
BFE开源项目的地址：GitHub - bfenetworks/bfe: A modern layer 7 load balancer from baidu
《深入理解BFE》免费版：GitHub - baidu/bfe-book: 《深入理解BFE》（Book for opensource project BFE, in Chinese）
随着云计算和云原生的发展，七层负载均衡得到了越来越多的关注，这个领域出现了很多不同的解决方案。本文对七层负载均衡的多个主流生态进行了说明和对比。本文也将说明，BFE在安全性、稳定性、研发效率和综合成本等方面都明显优于Nginx，可以完美的取代Nginx。
1. 背景说明：七层负载均衡 负载均衡技术已经存在超过20年的时间。在发展初期，主要使用网络负载均衡，俗称四层负载均衡。四层负载均衡使用网络层信息（如：服务侧IP地址，TCP或UDP协议，端口号）来区分服务。四层负载均衡的代表性开源项目是LVS。
随着服务的数量越来越多，仅仅依靠网络层信息来区分服务已经不够用了。尤其对于对外服务来说，协议和端口都是固定的（如：Web服务一般为TCP协议的80和443端口），只能使用服务侧的IP地址来区分服务（如图1所示）。而IPv4地址的资源是非常紧张的。对于一个大型的企业，考虑到多地部署的场景，一个服务还要使用多个IP地址。七层负载均衡成为刚需。
图1 四层负载均衡：基于IP地址来区分服务
七层负载均衡使用应用层信息来区分目标服务。常用的信息是HTTP头部中所包含的Host（如：www.baidu.com）和Path（如：/abc），也可以使用HTTP头部中包含的其它信息（如：Cookie信息）。在使用七层负载均衡的情况下，多个服务可以复用相同的IP地址，七层负载均衡系统会根据不同的应用层信息将请求转发给不同的服务（如图2所示）。
图2 七层负载均衡：基于HTTP头部中的Host来区分服务
2. 七层负载均衡的4大生态 目前在七层负载均衡领域，存在4大生态（如表1所示）：
(1)Nginx/OpenResty生态
(2)Envoy生态
(3)Go语言生态
(4)Rust语言生态
表1 七层负载均衡的4大生态及代表项目
Nginx/OpenResty生态是目前势头最大的生态。Nginx本来是一个基于C语言开发的Web Server，后来也被用于作为七层负载均衡。OpenResty是对Nginx的一种扩展，可以利用Lua语言（一种脚本语言，由巴西人发明）对Nginx功能做扩展。Kong和APISIX都是属于这个生态的。
Envoy是基于C++开发的七层开源软件。最早由美国Lyft公司技术团队开发并开源，后Google加入。目前Envoy已经成为服务网格(Service Mesh)中Sidecar网关的重要候选系统。
Go语言于2009年由Google发布。由于其在内存管理和并发编程方面的优势，最近10年来获得迅猛的发展。Go语言的基础库中提供了非常好的网络协议栈支持。而业界常见的协议也往往能找到第三方提供的Go语言开源代码库。BFE、Traefik和Tyk都是基于Go语言研发的开源项目。
Rust语言是一种可以提供更好内存安全性的系统编程语言。Rust语言已经被大量用于系统级的开发场景。Linkerd基于Rust语言开发了七层负载均衡软件。
3. 多生态间的对比 下面对4个七层负载均衡的生态做一个简单的对比。在表2中列出了5个对比的指标，下面逐一进行说明。
表2 七层负载均衡4大生态的对比
(1) 性能
在4大生态中，除了Go语言生态，其它3个生态系统的性能都非常高。BFE开源项目的性能问题，我们在下一章专门讨论。
(2) 安全性/稳定性
众所周知，基于C/C++开发的程序在安全性和稳定性方面有严重的问题。C/C++程序超过50%的问题是由于内存管理造成的。即使对于一个已经超过20年经验的老程序员，也不敢说自己写的C/C++程序完全没有内存方面的问题。缓冲区溢出是C/C++程序在安全方面的重大隐患，著名的OpenSSL开源项目几乎每年都会发现缓冲区溢出导致的漏洞，而由于编程语言本质的问题，这方面的问题是不可能根治的。还有一个关键问题是，C/C++程序无法对于异常进行捕获，在出现异常的情况下，程序直接崩溃。
Go语言和Rust语言的主要设计目的之一就是为了解决C/C++在内存管理方面存在的问题。Go语言中，内存的分配和释放都由系统来负责；Rust在内存管理方面引入了非常复杂的机制，以保证内存管理的安全性。而且Go语言和Rust语言都可以捕获异常。在内存管理安全性和异常捕获两方面，Go语言和Rust语言都远好于C/C++，它们的程序在安全性和稳定性方面强优于C/C++的程序。
(3) 开发效率
现在软件的主要成本在于人的成本。硬件越来越便宜，人越来越贵。在七层负载均衡的生态选择方面，开发效率也是重要的考虑因素。
Go的开发效率远高于C/C++。Go语言的开发效率和Python差不多，大约是C/C++的5倍。
Rust的开发效率并不高。Rust的学习曲线很陡峭，在内存管理方面的设计成本也比较高。
(4) 开源生态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e8eef4852bebef27f23b0e20266e2a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77bd00b814c17ecdfd17742afdd00e56/" rel="bookmark">
			QT&#43;VS 编译报错E2512 功能测试宏的参数必须是简单标识符 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将错误代码替换
#if defined(__cplusplus)
#if defined(__clang__)
#if QT_HAS_CPP_ATTRIBUTE(clang::fallthrough)
# define Q_FALLTHROUGH() [[clang::fallthrough]]
#endif
#elif defined(__GNUC__)
#if QT_HAS_CPP_ATTRIBUTE(gnu::fallthrough)
# define Q_FALLTHROUGH() [[gnu::fallthrough]]
#endif
#elif QT_HAS_CPP_ATTRIBUTE(fallthrough)
# define Q_FALLTHROUGH() [[fallthrough]]
#endif
#endif
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d11932d070002c794acc5480d4d703b5/" rel="bookmark">
			php7.4安装xlswriter扩展（excel大文件读取）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用中文文档：https://xlswriter-docs.viest.me/zh-cn/an-zhuang
windows下载地址：https://github.com/viest/php-ext-xlswriter/releases
注意:window 注意版本、是否线程安全、操作系统位数.
github： https://github.com/viest/php-ext-xlswriter
linux下安装：
wget https://pecl.php.net/get/xlswriter-1.3.2.tgz tar xf xlswriter-1.3.2.tgz cd xlswriter-1.3.2 /www/server/php/72/bin/phpize ./configure --with-php-config=/www/server/php/72/bin/php-config --enable-reader make &amp;&amp; make install echo "extension = xlswriter.so" &gt;&gt; /www/server/php/74/etc/php.ini 重启php即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4268ce731b5897b7ec963321399b4a05/" rel="bookmark">
			MybatisPlus DML编程控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. id生成策略控制（Insert） 问题导入
主键生成的策略有哪几种方式？
不同的表应用不同的id生成策略
日志：自增（1,2,3,4，……）
购物订单：特殊规则（FQ23948AK3843）
外卖单：关联地区日期等信息（10 04 20200314 34 91）
关系表：可省略id
……
1.1 id生成策略控制（@TableId注解） 名称：@TableId
类型：属性注解
位置：模型类中用于表示主键的属性定义上方
作用：设置当前类中主键属性的生成策略
相关属性
type：设置主键属性的生成策略，值参照IdType枚举值
1.2 全局策略配置 mybatis-plus:
global-config:
db-config:
id-type: assign_id
table-prefix: tbl_
id生成策略全局配置
表名前缀全局配置
2. 多记录操作（批量Delete/Select） 2.1 按照主键删除多条记录 //删除指定多条数据 List&lt;Long&gt; list = new ArrayList&lt;&gt;(); list.add(1402551342481838081L); list.add(1402553134049501186L); list.add(1402553619611430913L); userDao.deleteBatchIds(list); 2.2 根据主键查询多条记录 //查询指定多条数据 List&lt;Long&gt; list = new ArrayList&lt;&gt;(); list.add(1L); list.add(3L); list.add(4L); userDao.selectBatchIds(list); 3. 逻辑删除（Delete/Update） 问题导入
在实际环境中，如果想删除一条数据，是否会真的从数据库中删除该条数据？
删除操作业务问题：业务数据从数据库中丢弃
逻辑删除：为数据设置是否可用状态字段，删除时设置状态字段为不可用状态，数据保留在数据库中
3.1 逻辑删除案例 ①：数据库表中添加逻辑删除标记字段 ②：实体类中添加对应字段，并设定当前字段为逻辑删除标记字段
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4268ce731b5897b7ec963321399b4a05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81c49bf64de03c11ed86d4b96264e82d/" rel="bookmark">
			TDengineGUI无法连接TDengine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档中写到TDengineGUI连接TDengine的配置为：
可以通过“新建连接”按钮，添加新的服务器进行管理。需要提供数据库服务器的ip地址、restful服务的端口号（默认为6041）、连接服务器的用户名和密码（默认为root:taosdata）
我连接时提示“连接失败”，去服务器上看了端口 使用情况，确实也没有6041端口的使用情况，后来发现时是自己没启动 taosAdapter 服务
只需要在要连接的服务器上执行下面的命令就可以啦
systemctl start taosadapter 官方介绍taosadapter：https://docs.taosdata.com/reference/taosadapter/
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/261/">«</a>
	<span class="pagination__item pagination__item--current">262/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/263/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>