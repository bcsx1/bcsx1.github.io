<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656a55a4a8479125c76305e90893e1d0/" rel="bookmark">
			禁忌搜索算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合优化算法系列：
现代优化算法 （一）：模拟退火算法 及应用举例
现代优化算法 （二）： 遗传算法 及应用举例
现代优化算法(三）：禁忌搜索算法
现代优化算法（四）：改进的遗传算法
现代优化算法（五）： 蚁群算法
目录
1 禁忌搜索算法的相关概念
（1）邻域 （2）侯选集合
（3）禁忌对象和禁忌长度 （4）评价函数
（5）特赦规则 （6）记忆频率信息
2 模型及求解 2.1 问题（1）的求解 禁忌搜索算法的流程 2.2 问题（2）的求解
1 禁忌搜索算法的相关概念 禁忌搜索算法是组合优化算法的一种，是局部搜索算法的扩展。禁忌搜索算法是人 工智能在组合优化算法中的一个成功应用。禁忌搜索算法的特点是采用了禁忌技术。所 谓禁忌就是禁止重复前面的工作。禁忌搜索算法用一个禁忌表记录下已经到达过的局部最优点，在下一次搜索中，利用禁忌表中的信息不再或有选择地搜索这些点。 禁忌搜索算法实现的技术问题是算法的关键。禁忌搜索算法涉及侯选集合、禁忌 对象、评价函数、特赦规则、记忆频率信息等概念。
（1）邻域 在组合优化中，距离的概念通常不再适用，但是在一点附近搜索另一个下降的点仍 然是组合优化数值求解的基本思想。因此，需要重新定义邻域的概念。
（2）侯选集合 侯选集合由邻域中的邻居组成。常规的方法是从邻域中选择若干个目标值或评价 值最佳的邻居入选。
（3）禁忌对象和禁忌长度 禁忌表中的两个主要指标是禁忌对象和禁忌长度。禁忌算法中，由于我们要避免 一些操作的重复进行，就要将一些元素放到禁忌表中以禁止对这些元素进行操作，这些元素就是我们指的禁忌对象。禁忌长度是被禁对象不允许选取的迭代次数。一般是给被禁对象 x 一个数（禁忌长度） t ，要求对象 x 在 t 步迭代内被禁，在禁忌表中采用 tabu(x) = t 记忆，每迭代一步，该项指标做运算 tabu(x) = t −1，直到 tabu(x) = 0时 解禁。于是，我们可将所有元素分成两类，被禁元素和自由元素。禁忌长度t 的选取可以有多种方法，例如t = 常数，或t = [ ]，其中 n 为邻域中邻居的个数；这种规则容易在算法中实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/656a55a4a8479125c76305e90893e1d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574ed875bf0cd5adc527bb113e48f8eb/" rel="bookmark">
			Android AndroidManifest.xml文件权限出现“Permission is only granted to system apps”的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说，直接上图
例如出现这个问题，好像也不会影响我们APP的正常使用，但是有强迫症的人实在是受不鸟。
该错误的意思是该权限只是针对系统级的app的。
那么只是针对系统级的app的这个是什么意思的呢？
有时候使用某些api需要使用系统权限，如调用PackageInstaller的相关接口，需要android.permission.INSTALL_PACKAGES权限，该权限系统只会授权给系统应用。
好吧，原来是这样的。那我们来解决这个问题。
解决方式一： 网上很多都说在AS的File -&gt; Settings -&gt; Inspections
在Android Lint, locate Using system app permission. 选择一个比Error等级低的.（意思就是把Error换成warning或者其它等级）
好吧我的乖乖，找了半天，Android Lint之后就没找到下一步的locate ，原来是我的AS升级了，我是用的是3.2.2的版本。
原来是在Android Lint之后到correctness里面往下翻，找到Using system app permission右边有一个severity.把error改为warning就行了。
ES的方法Preferences --&gt; EditorEditor --&gt; Inspections --&gt; Android Lint --&gt; uncheck item Using System app permissio
解决方式二： 就是把uses-permission改为permisson即可。
那为什么要这样改呢?
我们可以了解一下uses-permission和permisson到底有什么区别？
uses-permission是系统（SDK）定义的，使用的时候直接调用系统定义好的权限就可以对应用开启权限。permisson相当于自定义的一个权限，可以供其他应用程序使用本应用的说明。
网上还有说法uses-permission和permisson的作用于不同，这种说法表述有误。
在一般情况下实际上不需要为自己的应用程序声明某个权限，除非你提供了供其他应用程序调用的代码或者数据。这个时候你才需要使用&lt;permission&gt;这个标签，很显然这个标签可以让我们声明自己程序的权限。
刚好，我们申明的这个权限出现这个问题，就是使用某些api需要使用系统权限。所以把把uses-permission改为permisson，相当于这个权限是我们自己定义的。也可以解决这个问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/076b43e4d664857195223d06be229cf6/" rel="bookmark">
			现代优化算法 （二）：  遗传算法 及应用举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合优化算法系列：
现代优化算法 （一）：模拟退火算法 及应用举例
现代优化算法 （二）： 遗传算法 及应用举例
现代优化算法(三）：禁忌搜索算法
现代优化算法（四）：改进的遗传算法
现代优化算法（五）： 蚁群算法
目录
遗传算法简介 2 模型及算法 遗传算法简介 遗传算法（Genetic Algorithms，简称 GA）是一种基于自然选择原理和自然遗传机制的搜索（寻优）算法，它是模拟自然界中的生命进化机制，在人工系统中实现特定目 标的优化。遗传算法的实质是通过群体搜索技术，根据适者生存的原则逐代进化，终 得到优解或准优解。它必须做以下操作：初始群体的产生、求每一个体的适应度、 根据适者生存的原则选择优良个体、被选出的优良个体两两配对，通过随机交叉其染色 体的基因并随机变异某些染色体的基因后生成下一代群体，按此方法使群体逐代进化， 直到满足进化终止条件。其实现方法如下：
（1） 根据具体问题确定可行解域，确定一种编码方法，能用数值串或字符串表示 可行解域的每一解。 （2） 对每一解应有一个度量好坏的依据，它用一函数表示，叫做适应度函数，适应度函数应为非负函数。 （3） 确定进化参数群体规模M 、交叉概率 、变异概率 、进化终止条件。
为便于计算，一般来说，每一代群体的个体数目都取相等。群体规模越大、越容易找到优解，但由于受到计算机的运算能力的限制，群体规模越大，计算所需要的时 间也相应的增加。进化终止条件指的是当进化到什么时候结束，它可以设定到某一代进 化结束，也可能根据找出近似优是否满足精度要求来确定。表 2 列出了生物遗传概念 在遗传算法中的对应关系。 2 模型及算法 我们用遗传算法研究 1.2 中的问题。
（1）研究 1.2 中同样的问题。
我方有一个基地，经度和纬度为（70,40）。假设我方飞机的速度为 1000 公里/小时。 我方派一架飞机从基地出发，侦察完敌方所有目标，再返回原来的基地。在敌方每一目 标点的侦察时间不计，求该架飞机所花费的时间（假设我方飞机巡航时间可以充分长）。
问题（2）我方有三个基地，经度、纬度分别为（70,40），（72,45），（68,48）。假设我方 所有无人侦察机的速度都为 1000 公里/小时。三个基地各派出一架飞机侦察敌方目标， 怎样划分任务，才能使时间最短，且任务比较均衡。
（2） 初始种群
（3） 目标函数
（4） 交叉操作
交叉操作的方式有很多种选择，我们应该尽可能选取好的交叉方式，保证子代能继 承父代的优良特性。同时这里的交叉操作也蕴含了变异操作。
（5） 变异操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/076b43e4d664857195223d06be229cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ed87fdd89dad8bfff37b01299979f3/" rel="bookmark">
			OTP 22.0 RC3 发布，Erlang 编写的应用服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发四年只会写业务代码，分布式高并发都不会还做程序员？ OTP 22.0 第三个 RC 版已于近日发布，这说明正式版即将到来。Erlang/OTP 22 是一个新的主要版本，将会带来许多新特性和功能改进，以及提升兼容性。
OTP 22.0 RC3 没有重要的变更，主要是 bug 修复和细节上的改进，点此查看详细的更新日志。
RC2 和 RC1 的更新内容主要是对潜在不兼容性的改进、改进编译器和标准库等。
下载地址
http://erlang.org/download/otp_win32_22.0-rc3.exe
http://erlang.org/download/otp_win64_22.0-rc3.exe
在线文档
http://erlang.org/documentation/doc-11.0-rc3/doc
OTP (Open Telecom Platform) 是一个用 Erlang 编写的应用服务器，它是一套 Erlang 库，由 Erlang 运行时系统、主要使用 Erlang 编写的许多随时可用的组件以及 Erlang 程序的一组设计原则组成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0f81bb51f4fa420d6fe98562accb587/" rel="bookmark">
			第2条：遇到多个构造器参数时要考虑使用构建器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重叠构造器模式 // Telescoping constructor pattern public class NutritionFacts { private final int servingSize; // (mL) required private final int servings; // (per container) required private final int calories; // (per serving) optional private final int fat; // (g/serving) optional private final int sodium; // (mg/serving) optional private final int carbohydrate; // (g/serving) optional public NutritionFacts(int servingSize, int servings) { this(servingSize, servings, 0); } public NutritionFacts(int servingSize, int servings, int calories) { this(servingSize, servings, calories, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat) { this(servingSize, servings, calories, fat, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) { this(servingSize, servings, calories, fat, sodium, 0); } public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0f81bb51f4fa420d6fe98562accb587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7982e86e956a59f4e9e9b2dfc828f888/" rel="bookmark">
			第1条：用静态方法代替构造器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 静态工厂方法的优势 静态工厂方法与构造器不同的第一大优势在于，它们有名称。静态工厂方法与构造器不同的第二大优势在于，不必在每次调用天它们的时候都创建一个新对象。静态工厂方法与构造器不同的第三大优势在于 ，它们可以返回原返回类型的任何子类型的对象。静态工厂方法的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。静态工厂方法的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。 静态工厂方法的劣势 静态工厂方法的主要缺点在于，类如果不包含公有的或受保护的构造器，就不能被子类化。静态工厂方法的第二个缺点在于，程序员很难发现它们。 # from---类型转换方法，它只有单个参数，返回该类型的一个相对应的实例，例如： Date d = Date.from(instant); # of---聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来，例如： Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING); # valueOf---比from和of更繁琐的一种替代方法，例如： BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE); # instance或者getInstance---返回的实例是通过方法的（如有）参数来描述的，但是不能说与参数具有同样的值，例如： StackWalker luke = StackWalker.getInstance(options); # create或者newInstance---像instance或者getInstance一样，但create或者newInstance能够确保每次调用都返回一个新的实例，例如： Object newArray = Array.newInstance(classObject, arrayLen); # getType---像getInstance一样，但是在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型，例如： FileStore fs = Files.getFileStore(path); # newType---像newInstance一样，但是在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型，例如： BufferedReader br = Files.newBufferedReader(path); type---getType和newType的简版，例如： List&lt;Complaint&gt; litany = Collections.list(legacyLitany); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7acaab8e47d461f1df568076d117ac0a/" rel="bookmark">
			linux 脚本实现定时清理超时文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.生成.sh文件
日志输出目录：/user/FileClear/
folderFile0:清理的目录
timeout0：当前时间超过清理文件的最后修改时间多少秒的文件，进行清理
type0：对于目录下，文件夹为空 是否需要删除 0：不删除 1：删除
#!/bin/sh #当前时间 timecur=$(date "+%Y-%m-%d %H:%M:%S") function deleteTimeOutFile(){ local folderFile=$1 local timeout=$2 local type=$3 local outpath="/user/FileClear/info$(date "+%Y%m").log" if [ -d "$folderFile" ] ; then local folderFileList=`ls $folderFile` for folderFileOne in $folderFileList do local folderFileNew=$folderFile$folderFileOne if [ -d "$folderFileNew" ] ; then # 是文件夹 echo $(date "+%Y-%m-%d %H:%M:%S")" 文件夹："$folderFileNew deleteTimeOutFile $folderFileNew"/" $timeout $type if [ "`ls -A $folderFileNew`" = "" ]; then # type文件夹是否需要删除 0：不删除 1：删除 if [ $type -eq 1 ]; then echo $(date "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7acaab8e47d461f1df568076d117ac0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ba7acc62e248616c7c1c6330a4cb15/" rel="bookmark">
			数据不符合正态分布怎么处理呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际研究中，很多时候都需要数据满足正态分布才可以。比如说回归分析，其实做回归分析有一个前提条件即因变量需要满足正态分布性。也比如说方差分析，其有一个潜在的前提假定即因变量Y需要满足正态分布。还有很多种情况，比如T检验，相关分析等等。
但这种情况往往被分析人员忽略掉，或者是数学基本不够扎实，也或者无论如何数据均不满足正态分布等客观条件，也或者其它情况等。如果说没有满足前提条件，分析的结果会变得不科学严谨，分析结论会受到置疑。
哪些研究方法需要数据满足正态分布才行呢？以及如果不满足正态分布时应该如何处理呢？接下来会逐步说明。
第一：需要满足正态分布的几类常见研究方法： 常见会涉及五种研究方法，它们对正态性要求相对较高，如果不满足正态性则会有对应的处理。
线性回归分析 线性回归分析，很多时候也称回归分析。其对正态性的要求较为严格，包括因变量Y需要满足正态性要求，同时残差也需要满足正态性。如果说因变量Y不满足正态分布，通常情况下有以下几种处理办法。
第1：对因变量Y取对数处理（包括自然对数和10为底的对数）；这可以在SPSSAU的生成变量功能里面找到；
第2：如果数据接近于正态分布，则接受其为正态分布性。此种情况较多，因为在研究影响关系时，线性回归最适合，如果不进行线性回归，通常情况下很难有更适合的研究方法。因而很多时候只要数据接受于正态性即可，而不用强求数据完美的正态，事实上在生活中绝对的“正态性”并不存在。使用正态分布检验方法进行验证正态性最为严苛，因而可使用正态分布图直观查看数据分布情况，接近于“正态分布”更符合实际情况；
第3：加大样本量；有时候数据太少时，即使正态分布的数据，也因为样本小没有办法覆盖各种情况，从而变得不正态，因而加大样本量会减少这种情况产生。
pearson 相关分析 Pearson相关分析（也称皮尔逊相关分析，很多时候直接称呼为相关分析），在实际研究中使用最多。其实Pearson相关分析也有着默认的前提条件，即数据满足正态分布性。但现实中的数据很难满足正态分布性，此时建议使用Spearman（斯皮尔曼）相关系数进行研究即可。
方差分析 方差分析（这里特指单因素方差分析），其默认有个前提条件是因变量需要符合正态分布性，可能是由于即使非正态分布，方差分析的结果也较为稳健，因而很少有人先进行正态分布性检验。
事实上方差分析的因变量也需要满足正态分布特质，如果没有满足，则可以使用非参数检验进行检验。具体非参数检验的类型来看，如果X的组别为两组，比如上表中男和女共两组，则应该使用MannWhitney统计量，如果组别超过两组，则应该使用Kruskal-Wallis统计量结果。SPSSAU自动选择MannWhitney或者Kruskal-Wallis统计量。
独立T检验 独立T检验（也称T检验），其默认有个前提条件是因变量需要符合正态分布性，如果不满足，此时可考虑使用非参数检验，具体来讲应该是MannWhitney检验进行研究。
单样本T检验 单样本T检验，其默认前提条件是数据需要符合正态分布性，如果不满足，此时可考虑使用非参数检验，具体来讲应该是单样本Wilcoxon检验进行研究。
配对样本T检验 配对样本T检验，其默认前提条件是差值数据需要符合正态分布性，如果不满足，此时可考虑使用非参数检验，具体来讲应该是单样本Wilcoxon检验进行研究。其实配对样本T检验与单样本T检验的原理是一模一样，无非是进行了一次数据相减（即差值）处理而已，因而其和单样本T检验保持一致。
第二：理论与现实的“相悖” 从理论上讲，很多研究方法需要满足正态分布特质，但现实情况下，很难满足正态分布性。SPSSAU认为有两点原因。1是抽样样本过少，很难cover所有情况，所以导致总体是正态分布，但抽样样本不满足正态分布，比如中国13亿人的身高肯定是正态分布，但抽样100个人可能就不会正态分布；2是认知的不一致，事实上正态性是一种数学理论上的分布，实际情况下只要数据分布基本满足“钟形曲线”特征，SPSSAU认为也应该将数据看成是正态分布。
因而在实际研究过程中，很可能会出现需要满足正态性要求，但是并不满足，此时应该如何处理呢？SPSSAU认为有三种处理方式，如下图：
第一种：使用正态分布图直观判断正态分布特质，而不是使用检验方法。原因在于检验方法比较严苛，而现实数据满足“钟形曲线”特征即可；
第二种：将数据取对数，或者开根号等处理。如果数据值非常大，取对数或者开根号等，会对数据进行“压缩”处理，相对意义上单位会减小，但值的相对意义还是一样，通常情况下，数据会变得相对“正态”一些；此步可使用SPSSAU的“生成变量”功能即可完成。
第三种：使用其它研究方法。如果是使用方差分析，T检验等，如果不满足正态性，则有对应的非参数检验方法可以使用。如果是非参数检验方法进行差异对比，则应该使用中位数去表述大小差异等，而一般不使用平均值（满足正态分布性时才使用平均值表示整体水平）。当然，SPSSAU均会提供对应的非参数检验方法等，可直接使用。
第三：正态分布的“检验方法” 上述已经讲了很多关于正态分布的话题，那如何对正态分布性进行检验呢？SPSSAU共提供以下几种检验，如下：
第一种：图示法（使用SPSSAU的正态图即可，可得到类似如下的图等）
第二种：检验方法
SPSSAU共提供两种正态性检验方法，包括S-W检验和K-S检验。小样本(小于50)时建议使用S-W检验，大样本(大于50)时建议使用K-S检验；此两个检验的原假设为数据正态分布，因而P值&gt;0.05，说明该项具有正态分布特质；这些均会在SPSSAU的智能分析中默认提供。
下次再分析时，记得以上的方法来分析处理非正态的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32ce440dc0cf95b795105ca355d72668/" rel="bookmark">
			BUS hound使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bus hound的基础简介，可以在网上搜到很多资料。我这里结合实际情况，记录下实际实验的过程。监控某个设备，需要勾选前面的复选框，注意同一个设备有当前层和上层的分类。
（1）uart，测试自发自收。
(2)usb键盘
（3）USB鼠标
（4）USB存储器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02139966d72cfad6fdb08a703669bb80/" rel="bookmark">
			Python数据分析基础技术之Scipy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scipy是一个用于数学、科学、工程领域的常用软件包，可以处理插值、积分、优化、图像处理、常微分方程数值解的求解、信号处理等问题。它用于有效计算Numpy矩阵，使Numpy和Scipy协同工作，高效解决问题。
scipy官网：https://www.scipy.org/ 学习过程中可以查询官方文档
Scipy是由针对特定任务的子模块组成：
模块名应用领域scipy.io数据输入输出scipy.integrate积分程序scipy.interpolate插值scipy.linalg线性代数程序scipy.optimize优化scipy.cluster向量计算/Kmeansscipy.constants物理和数学常量scipy.fftpack傅立叶变换scipy.ndimagen维图像包scipy.odr正交距离回归scipy.signal信号处理scipy.sparse稀疏矩阵scipy.spatial空间数据结构和算法scipy.special一些特殊的数学函数scipy.stats统计 1. 积分（scipy.integrate）
导入模块：
from scipy.integrate import quad,dblquad,nquad #一维积分，二维积分，n维积分 print(quad(lambda x: np.exp(-x), 0, np.inf)) #exp（x）是e为底的指数函数 print(dblquad(lambda t, x: np.exp(-x * t) / t ** 3, 0, np.inf, lambda x: 1, lambda x: np.inf)) #**表示幂运算 #n元积分 def f(x,y): return x*y def bound_y(): return [0,0.5] def bound_x(y): return [0,1-2*y] print(nquad(f,[bound_x,bound_y])) 结果是返回一个值和误差组成的元组
2. 优化（scipy.optimize）
scipy.optimize模块提供了函数最值、曲线拟合和求根的算法。
该模块包括：
——多元标量函数的无约束和约束极小化(minimize)。使用多种算法(例如BFGS、Nder-Mead单纯形、Newton共轭梯度、COBYLA或SLSQP)
——全局(蛮力)优化例程。basinhopping, differential_evolution)
——最小二乘极小化(least_squares)和曲线拟合(curve_fit)算法
——标量单变量函数极小化(minimize_scalar)和根查找器(root_scalar)
——多元方程组求解器(root)使用多种算法(例如，混合鲍威尔、Levenberg-MarQuardt或大规模方法，如Newton-Krylov)
无约束函数最值(以最小值为例)：
导入模块：
from scipy.optimize import minimize import numpy as np 在数学最优化中，Rosenbrock函数是一个用来测试最优化算法性能的非凸函数，由Howard Harry Rosenbrock在1960年提出。也称为Rosenbrock山谷或Rosenbrock香蕉函数，也简称为香蕉函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02139966d72cfad6fdb08a703669bb80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d254db80a17a1fa3493ccb06b58ec2/" rel="bookmark">
			cesium工具：鼠标获取经纬度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//获取经纬度 getPosition = (viewer) =&gt; { //得到当前三维场景 var scene = viewer.scene; //得到当前三维场景的椭球体 var ellipsoid = scene.globe.ellipsoid; var entity = viewer.entities.add({ label : { show : false } }); var longitudeString = null; var latitudeString = null; var height = null; var cartesian = null; // 定义当前场景的画布元素的事件处理 var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas); //设置鼠标移动事件的处理函数，这里负责监听x,y坐标值变化 handler.setInputAction(function(movement) { //通过指定的椭球或者地图对应的坐标系，将鼠标的二维坐标转换为对应椭球体三维坐标 cartesian = viewer.camera.pickEllipsoid(movement.endPosition, ellipsoid); if (cartesian) { //将笛卡尔坐标转换为地理坐标 var cartographic = ellipsoid.cartesianToCartographic(cartesian); //将弧度转为度的十进制度表示 longitudeString = Cesium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d254db80a17a1fa3493ccb06b58ec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fccd9355cbaa76a0812aa3a8710bc538/" rel="bookmark">
			海波龙 11.1.2.4安装指南// hyperion install
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考信息 https://www.oracle.com/webfolder/technetwork/cn/obe/hyp_epm/kennedy_install/kennedy_obe.htm#t1s2
介绍 在安装oracle企业绩效管理套件（Hyperion）之前，首先您必须了解所有EPM产品。
List of EPM products:
Oracle Hyperion Foundation Services
Foundation Services
·Optionally, Oracle HTTP Server
·Oracle WebLogic Server
·Oracle Hyperion EPM Architect
·Oracle Hyperion Calculation Manager
·Oracle Smart View for Office
Oracle Essbase
· Oracle Essbase
·Oracle Essbase Administration Services
·Oracle Hyperion Provider Services
·Oracle Essbase Studio
Oracle Reporting Analysis and Framework
· Oracle Hyperion Reporting and Analysis Framework
· Oracle Hyperion Interactive Reporting
· Oracle Hyperion Financial Reporting
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fccd9355cbaa76a0812aa3a8710bc538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce751961db3d1f54fdd41eb3ba42c52/" rel="bookmark">
			vs创建c语言项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vs创建c语言项目
已知用c# 做一些简单的开发，以前虽然也捅咕过C和C++，但是好久不上手了，现在用VS都不知道怎么创建C项目。
首先打开VS程序，选择新建一个项目
然后在里面选择C++，新建win32控制台程序
下面的哪些名字和路径，改了项目名就行，其他的也不用管，没必要
随后进入了创建向导
这是一个关键点，选择空项目和控制台应用程序，创建完成项目
接下来我们需要添加一些源文件，右键添加新建项
出现添加项的选项卡，选择CPP文件，注意：在下面将拓展名改为.c
到此为止完成！！
一个简单的小程序测试一下即可
#include&lt;string.h&gt; #include&lt;stdio.h&gt; int main(void) { char hello[] = "Another Hello"; printf("%s\n", hello); gets(); //接收一个字符 防止控制台直接结束 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b926f74b0bf42d6536fa79eb319505ba/" rel="bookmark">
			反射的综合案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、案例说明 编写一个工厂方法可以根据配置文件产任意类型的对象。
例如有配置文件stu.properties，存储在项目的src文件夹下内容如下：
class=com.itheima.reflect.Student name=rose gender=女 age=18根据配置文件信息创建一个学生对象。 二、案例代码 public class Demo{ public static void main(String[] args){ // 获取对象 Student stu = (Student) createObject(); // 输出对象 System.out.println(stu); } / ** * 根据配置文件创建对象 */ public static Object createObject(){ try { // 创建属性集合 Properties pro = new Properties(); // 从文件中加载内容到集合中 pro.load(Demo.class.getResourceAsStream("/stu.properties")); // 从集合中获得类名 String className = pro.getProperty("class"); // 通过反射获得Class对象 Class c = Class.forName(className); // 快速创建对象 Object obj = c.newInstance(); // 遍历集合 Set&lt;String&gt; names = pro.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b926f74b0bf42d6536fa79eb319505ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0402b1ab1dcb53a88664f890eb96fec7/" rel="bookmark">
			通过OCI库执行带输出参数和游标的存储过程造成程序崩溃的查错过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手中有一套OCI操作的类似于JDBC的封装，要添加存储过程中对输出参数的支持，通过查看手册，只要调用OCIBindByName或者ByPos进行绑定即可，改好后代码大概是这样的：
class OciStatement : public DBStatement { public : //... void regOutParam(int idx, int type, int max); protected: void doExecute(int times); protected: OCIEnv	*	m_hEnv	; OCIError	*	m_hError; OCISvcCtx	*	m_hSvc	; OCIStmt * m_stmtp; map&lt;int, OCIStmt *&gt; m_outStmt; map&lt;int, DBOutBuf *&gt; m_outData; }; void OciStatement::doExecute(int times) { sword swResult; swResult = OCIStmtExecute(m_hSvc, m_stmtp, m_hError , times, 0, NULL, NULL, OCI_DEFAULT); if (!checkResult(swResult)) makeException(m_hError, swResult, m_sql.c_str()); } void OciStatement::regOutParam(int idx, int type, int max) { sword swResult; OCIBind * bindp = NULL; if (type == DBCT_RESULT) { OCIStmt * stmtp = NULL; swResult = OCIHandleAlloc(m_hEnv, (void **)&amp;stmtp , OCI_HTYPE_STMT, 0, NULL); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0402b1ab1dcb53a88664f890eb96fec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/626d9f64000cc0f15b6ea800ff8a93ed/" rel="bookmark">
			Handler使用方法详解(含实例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、目录
一、相关概念简介
二、使用方式
三、使用步骤
四、实例讲解
五、总结
一、相关概念简介
Handler是一套消息传递机制，通常的作用是在多线程的应用场景中，将子线程(工作线程)中需要更新UI的相关信息传递到主线程，从而实现工作线程对UI的更新。
二、使用方式
Handler的使用方式可以根据发送消息的方式不同而分为两种:
Handler.sendMessage()和Handler.post()
三、使用步骤
方式一，使用Handler.sendMessage()
在该使用方式中，因创建Handler的方式不同，又可分两种：创建Handler子类、使用匿名Handler内部类，但本质都是相同的，都是继承Handler类创建子类
一，创建Handler子类 1、自定义Handler子类，并重写handleMessage()方法 class mHandler extends Handler { //重写handleMessage（）方法 @Override public void handleMessage(Message msg) { super.handleMessage(msg); //执行的UI操作 } } 2、主线程中创建mHandler的实例 private mHandler mhandler = new mHandler(); 3、在子线程中创建需要发送的消息对象 Message msg = Message.obtain(); msg.what = 1; 4、在子线程中通过Hander发送消息到消息队列 mhandler .sendMessage(msg); 5、启动子线程 二、使用匿名Handler子类 1、在主线程中通过匿名内部类创建Handler类对象 Handler mhandler = new Handler(){ //重写handleMessage（）方法 @Override public void handleMessage(Message msg) { super.handleMessage(msg); //执行的UI操作 } }; 2、在子线程中创建需要发送的消息对象 Message msg = Message.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/626d9f64000cc0f15b6ea800ff8a93ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c24c5d1f804af70a3a29350a71088b3b/" rel="bookmark">
			vector容器容量自动增长的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. vector会自己根据数据的大小进行容量增长。
查看vector容量增长的次数
int count = 0; int* p = NULL; vector&lt;int&gt; v; for (int i = 0; i &lt; 100000; i++){ v.push_back(i); if (p != &amp;v[0]){ count++; p = &amp;v[0]; } } cout &lt;&lt; "count:" &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; "容量：" &lt;&lt; v.capacity() &lt;&lt; endl; cout &lt;&lt; "大小:" &lt;&lt; v.size() &lt;&lt; endl; 2. 如果已知vector的容量，可以使用 v.reserve(100000)提前分配空间，但这个空间没有真正的开辟出来。
3. 可以使用v.resize(6)进行数据大小的分配，如果v中元素个数大于6，后面的空间被舍弃。如果小于6， 添加默认值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3d1584899cd656f93cb14e0e596f669/" rel="bookmark">
			JS实现slideDown()和slideUp()效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS实现slideDown()和slideUp()效果 这两天在写一个小Demo，页面顶部需要实现webAPP那种将导航收起，通过按钮点击显示与隐藏的效果。实现过程中也花费时间挺久的，现在单独将这部分拎出来记录一下。废话太多了，直接上代码：
&lt;!DOCTYPE html&gt; &lt;html lang="zh-cn"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;响应式&lt;/title&gt; &lt;style type="text/css"&gt; *{ margin: 0; padding: 0; box-sizing: border-box; } a{ text-decoration: none; color: inherit; } ul li{ list-style-type: none; } header{ width: 100%; text-align: center; } .codeHead{ width: 100%; height: 70px; line-height: 70px; color: #fff; display: inline-block; text-align: center; font-size: 22px; position: relative; z-index: 99; background-color: #7ea6b1; } #nav-btn{ height: 20px; width: 20px; display: inline-block; border: 1px solid #fff; position: absolute; top: 25px; right: 30px; color: #fff; background-color: #7ea6b1; } #nav-list{ width: 100%; background-color:#7ea6b1; position: relative; z-index: 2; height: 0; overflow: hidden; } #nav-list li{ width: 100%; color: white; font-size: 14px; line-height: 30px; text-align: center; border-top: 1px solid #fff; }	&lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;nav&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3d1584899cd656f93cb14e0e596f669/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c55dcbea17af1e9f18cad2db94ce03d/" rel="bookmark">
			网易云的图片上传和视频上传功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.jkgis.party.resource.jkgisresourcelibrary.controller; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONObject; import com.google.gson.JsonObject; import com.jkgis.common.baseEntity.JKResponse; import com.jkgis.common.contant.Constant; import com.jkgis.common.util.*; import com.jkgis.party.resource.jkgisresourcelibrary.entity.VideoColumnAlbum; import com.jkgis.party.resource.jkgisresourcelibrary.entity.VideoResource; import com.jkgis.party.resource.jkgisresourcelibrary.mapper.VideoColumnAlbumMapper; import com.jkgis.party.resource.jkgisresourcelibrary.mapper.VideoResourceMapper; import com.jkgis.party.resource.jkgisresourcelibrary.util.ChineseInitalUtil; import com.jkgis.party.resource.jkgisresourcelibrary.vcloud.auth.BasicCredentials; import com.jkgis.party.resource.jkgisresourcelibrary.vcloud.auth.Credentials; import com.jkgis.party.resource.jkgisresourcelibrary.vcloud.client.VcloudClient; import com.jkgis.party.resource.jkgisresourcelibrary.vcloud.config.Config; import com.jkgis.party.resource.jkgisresourcelibrary.vcloud.upload.param.*; import com.jkgis.party.resource.jkgisresourcelibrary.vcloud.upload.recorder.Recorder; import com.jkgis.party.resource.jkgisresourcelibrary.vcloud.upload.recorder.UploadRecorder; import com.jkgis.party.resource.jkgisresourcelibrary.vcloud.util.ImageBase64Utils; import com.jkgis.party.resource.jkgisresourcelibrary.vcloud.util.JsonParamObjectUtil; import lombok.extern.log4j.Log4j2; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.*; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * 资源库视频上传管理控制类 */ @SuppressWarnings("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c55dcbea17af1e9f18cad2db94ce03d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505ac49084977c7ddb3eb348af8bcb57/" rel="bookmark">
			《机器人动力学与控制》第九章——动力学 9.1 初探欧拉-拉格朗日方程法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 《机器人动力学与控制》第九章——动力学9.1 初探欧拉-拉格朗日方程法9.1.0 前言9.1.1 一维系统9.1.2 一般情况 《机器人动力学与控制》第九章——动力学 9.1 初探欧拉-拉格朗日方程法 9.1.0 前言 本节我们推导一组描述受完整约束（Holonomic constraints）的机械系统运动的差分方程，这里的约束力满足虚功原理，这些方程组就叫欧拉——拉格朗日方程。推导欧拉——拉格朗日方程有两种方法：虚位移法和最小作用量法。（别问我什么意思，我从原版教材上翻译过来的）这里会从一个最简单的例子讲解求解机器人动力学的第一个方法：欧拉拉格朗日法。欧拉拉格朗日法可以总结为两个公式：
定义拉格朗日系数等于动能和势能之差：
由虚功原理得到的关节力/扭矩方程
9.1.1 一维系统 先讲一个最简单的例子：一个质量为m的质点，只受重力和竖直向上的拉力f的作用
假设向上为正方向，那么根据牛顿第二定律，我们有
把左边整理一下
这个
是这个质点的动能，接着我们再把右边项的重力动一下手脚
这个
是重力带来的势能。如果我们定义拉格朗日系数L是机械系统动能和势能之差
会发现
根据这个新发现我们重写第一个公式就能得到
这就是所谓的欧拉拉格朗日方程，用它我们可以描述力与系统运动的关系。接着我们用一个例子说明如何运用拉格朗日方程计算电机输出扭矩。
例9.1 单连杆结构
假设减速比为 r r r，那么电机的转速是输出端的 r r r倍，因此
系统的动能 = 电机的转动动能 + 连杆的转动动能，因此
J m J_m Jm​和 J l J_l Jl​分别是电机和连杆各自的转动惯量。系统的势能也能方便的得到， l l l是连杆重心与转轴的距离（假设连杆竖直向下的时候是初始位置，同时也是0势能点的位置），那么当转动一个theta角度时该系统的势能为：
如果定义
那么拉格朗日系数为：
代入到欧拉拉格朗日法公式中，得到
J θ ¨ ℓ + M g ℓ sin ⁡ θ ℓ = τ ℓ J \ddot{\theta}_{\ell}+M g \ell \sin \theta_{\ell}=\tau_{\ell} Jθ¨ℓ​+Mgℓsinθℓ​=τℓ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505ac49084977c7ddb3eb348af8bcb57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f144b79947261000fb95bb64d6d8bdec/" rel="bookmark">
			C&#43;&#43; Move与Forward实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这部分可重点参考《C++ Primer 》第5版 P608-P614，写的很透彻。
Forward的使用 #include&lt;iostream&gt; #include&lt;string&gt; #include&lt;vector&gt; using namespace std; template&lt;typename T&gt; void print(T&amp; t) { cout &lt;&lt; "lvalue" &lt;&lt; endl; } template&lt;typename T&gt; void print(T&amp;&amp; t) { cout &lt;&lt; "rvalue" &lt;&lt; endl; } template&lt;typename T&gt; void TestForward(T &amp;&amp; v) { print(std::forward&lt;T&gt;(v)); } int main() { TestForward(1);//rvalue int x = 1; TestForward(x);//lvalue return 0; } Forward的源码 // FUNCTION TEMPLATE forward template&lt;class _Ty&gt; _NODISCARD constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp; _Arg) noexcept {	// forward an lvalue as either an lvalue or an rvalue return (static_cast&lt;_Ty&amp;&amp;&gt;(_Arg)); } template&lt;class _Ty&gt; _NODISCARD constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp;&amp; _Arg) noexcept {	// forward an rvalue as an rvalue static_assert(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f144b79947261000fb95bb64d6d8bdec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef66bb27cb8b1cc7dd3639aa50366c66/" rel="bookmark">
			解决运行React Native项目报错 React Native version mismatch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在启动项目时，模拟器上报错信息为： React Native version mismatch
报错信息如上图所示，显示JS，Native的版本不匹配
实际上在我这是由于我前面开了一个android的模拟器，他们都占用8081端口，因此会导致同一个node.js服务器收到两个不同的Native版本，导致上述现象出现
在关闭android的模拟器，停止运行安卓项目后重新运行IOS模拟器后运行正常
有帮助的链接
1:https://stackoverflow.com/questions/47763824/react-native-version-mismatch
2:https://segmentfault.com/q/1010000014883882
有两个因素会导致出现这个报错：
1）：开启了多个模拟器，占用了同一个端口即上面的问题；
2）：npm每次安装的都是最新的版本，导致的不匹配，上面的链接有第二个问题的解决方案。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11b64482b1ef3987b0d7ffaab61c0437/" rel="bookmark">
			Hive初学者常用的一些命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive菜鸟指南 Hive简介 Hive对我来说就是一个基于HDFS的数据仓库，它提供了一个种SQL语言，能让不精通Java语言而熟悉SQL语言的工程师，快速的对HDFS或其他存储文件系统如Amazon，S3，上的数据进行数据分析，是Hadoop生态系统中非常重要的一个工具。
2.Hive常用语句 2.1菜鸟建表法 1.直接建表，指定分隔符，默认存储为text，也可以指定存储格式！
create table tb151
(id string comment “字段注释”,
name string,
age int)
row format delimited
fields terminated by ","
location ‘/path/to/data’;--location指定数据存放目录
从查询语句建表 create table tb151_sample as
select * from tb151 tablesample(5 rows);--抽样行数,也可是百分比(50 percent)和容量(10M)
根据已知表结构创建表 create table test_tb like tb151 location "/path/to/data";
2.2菜鸟导入导出Hive数据的几种方法 1.装载数据
--直接本地导入数据
load data local inpath "/path/to/data"
overwrite into table tbname;--local指本地目录，不加表示HDFS目录，overwrite关键字会覆盖表的数据
--从查询语句装载数据
insert overwrite table tbname
partition(partname="ptname")
select * from tbname2 where....;--overwrite关键字会覆盖元数据，使用into则追加数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11b64482b1ef3987b0d7ffaab61c0437/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73623c48eea209503b8389975690a07e/" rel="bookmark">
			第一个ndk-jni opencv程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明下，我使用的是opencv3.3.4的库，ndk15，至于为什么，看我下一篇文章。
1、环境搭建 首先要确保你的第一个ndk-jni 环境搭建成功，参考我的上一篇文章《我的第一个NDK-jni程序》，下面呢我会再给大家重新配置一次，看不懂下面配置的就看我上一篇文章https://mp.csdn.net/mdeditor/89525978#。
1、下载ndk15 此时我们要用的ndk15，所以我们卸载掉as默认的最新版本，操作如下
然后去掉Android NDK前面的勾，点击ok就会完成卸载。
接下来需要下载一个ndk15版本，给你们提供一个链接，里面有各个版本。
https://blog.csdn.net/shuzfan/article/details/52690554
下载完毕后需要解压文件，将解压路径设置为：Android Studio的SDK目录里，并命名为ndk-bundle。
2、取消Android studio默认NDK支持 因为我们要自己写Android.mk和Application.mk文件，所以我们要取消默认NDK支持，话不多说，看图。
去掉Android NDK support前面的勾，此时Android APK support前面的勾也会自动被去掉，不用管它，去掉之后点ok，会重启。
3、添加ndk依赖目录 1、选择你的NDK目录就行了，我的只是作为参考，点击ok。
2、接下来gradle.properties
添加一句
android.useDeprecatedNdk=true 3、打开local.properties
当你配置好NDK目录后，会自动生成这两句。
ndk.dir=/home/book/Android/Sdk/ndk-bundle sdk.dir=/home/book/Android/Sdk 2、开始编写代码 1、创建一个新的java类 我们暂且命名为NDKUtils，内容如下：
package com.example.book.ndklinkopecv1; public class NDKUtils { static { System.loadLibrary("OpenCV");//导入生成的链接库文件 } public static native int[] grayProc(int[] pixels, int w, int h); } 2、生成头文件 打开目录：/src/main/java
然后输入以下代码生成头文件
javah -jni com.example.book.ndklinkopecv1.NDKUtils
注意：本目录仅供参，实际以你的目录为准。
此时就会生成一个头文件
3、创建jni文件 此时我们需要创建一个jni文件夹，把头文件移进去。
在main目录上右键
选择JNIFolder，生成jni文件夹。
把头文件移动进去，并且创建一个cpp文件，直接复制就行了，后缀改一下就ok。
4、创建Android.mk和Application.mk文件 touch 就行了，不多说。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73623c48eea209503b8389975690a07e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c572d5a16f759fb6f373749cf2d4ca4b/" rel="bookmark">
			计算轮廓的特征参数（周长、面积、圆形度、周径比等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用C++、opencv计算轮廓的周长、面积、圆形度、周径比等特征参数 图像的特征参数用于图像的模式识别（图像识别），获取越多种类的特征参数，可从中选择合适的进行组合，进而更好地区分各个物体。
之前介绍过获取图像的灰度共生矩阵（https://blog.csdn.net/Lemon_jay/article/details/89455887）、不变矩（https://blog.csdn.net/Lemon_jay/article/details/89457633）、傅立叶描述子（https://blog.csdn.net/Lemon_jay/article/details/89349006）等，此次根据物体的轮廓进而计算出轮廓的周长、面积、圆形度、周径比等特征参数。还可自行拓展，如物体面积与最小外接矩形面积比、与最小外接圆的面积比、（最大）内切圆与物体面积比等。
opencv中相关API：
RotatedRect minAreaRect(InputArray points)
minAreaRect()函数的作用是找到轮廓的最小外接矩形
InputArray points：表示输入的点集（轮廓）
输出是矩形的四个点坐标
void minEnclosingCircle(InputArray points, Point2f&amp; center, float&amp; radius)
points：输入的点集（轮廓），可以为包含点的容器(vector)或是Mat。
center：返回包覆圆形的圆心。
radius：返回包覆圆形的半径。
其他知识点：所谓周长、面积等肯定不是物体真实的周长面积，代码所求的周长面积都是以像素点为单位，周长就是轮廓点集合的个数（以1像素点为步长），面积就是轮廓所围的所有像素点个数，所以想知道物体的真实周长面积，可以在图像中加入一个标准物体（如一张A4纸），并在找到、计算物体的参数时同时要找到、计算标准物体的参数，再进行换算。
圆形度计算公式采用的是：e=（4π*面积）/（周长*周长）
周径比的周即周长，径是指上面找到的轮廓最小外接矩形的长的一条边
代码如下：
#include "stdafx.h" #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;iostream&gt; #include &lt;math.h&gt; using namespace cv; using namespace std; int main() { //改变控制台字体颜色 system("color 02"); //读取图像 Mat src_image = imread("C:\\1.jpg"); //出错判断 if (!src_image.data) { cout &lt;&lt; "src image load failed!" &lt;&lt; endl; return -1; } //显示原图 namedWindow("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c572d5a16f759fb6f373749cf2d4ca4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70373035f5c5e84e63b7183e8bacf787/" rel="bookmark">
			jTessBoxEditor 训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在基于tesseract-ocr的图片文字识别中，可以通过jTessBoxEditor 进行训练，以提高图片文字的识别率。本文简单记录下训练的方法与步骤。
从网站https://sourceforge.net/projects/vietocr/files/jTessBoxEditor/下载jTessBoxEditor，解压到本地即可。运行jTessBoxEditor依赖java环境，因此需要安装配置jre。
一、基于jTessBoxEditor训练
1、生成tif和box文件 执行jTessBoxEditor目录下的train.bat批处理文件打开jTessBoxEditor，选中“TIFF/Box Generator”，如下图：
在面板输入待训练的内容后，再执行以下动作：
1）、点击图中标注的1，设置文件生成后保存的目录；
2）、修改图中标注的2的内容为自定义训练标志（最终生成训练文件的前缀）；
3）、修改图中标注3的文件名，生成的文件名由 2的内容 + 3的内容，如上图最终生成的tif文件和box文件名分别为hz.font.exp0.tif、hz.font.exp0.box
4）、点击图中标注4的按钮Generate，生成tif和box文件。
注：tif文件命名格式需规范，格式为“[lang].[fontname].exp[num].tif”，lang为语言名称，fontname为字体名称，num为序号。
5）、检查生成的字符配置文件hz.font_properties
字符配置文件内容为：font 0 0 0 0 0
内容语法说明：&lt;fontname&gt; &lt;italic&gt; &lt;bold&gt; &lt;fixed&gt; &lt;serif&gt; &lt;fraktur&gt; fontname为字体名称，italic为斜体，bold为黑体字，fixed为默认字体，serif为衬线字体，fraktur德文黑字体，1和0代表有和无，精细区分时可使用
2、字符矫正
打开“Box Editor”页面，如下图：
点击上图中的“Open”按钮，选择上一步生成的tif文件，检查字符是否正确，针对错误的修改Char列里面的内容，再点击“Save”保存修改。
3、开始训练
打开“trainer”页面，如下图：
点击图中标注的1，选择前面步骤生成的tif文件。修改图中标注2的语言与前面一致。图中标注3的地方选择“Train with Exsiting Box”，点击“run”按钮开始训练。训练成功后会在当前目录下生成tessdata目录，训练结果文件就在tessdata目录下hz.traineddata。就可以使用该训练文件去识别相关的图片。
二、通过写bat脚本训练
从https://digi.bib.uni-mannheim.de/tesseract/下载tesseract版本完成安装。配置好环境变量，打开命令行窗口执行tesseract -v 看到相关版本信息，则表示安装配置成功。
1、生成tif和box文件
可参照第一种方法生成。但这里介绍通过自定义图片使用jTessBoxEditor 合并tif，并用命令行生成box文件。
手动增加几张样图文件（通过画图软件写入内容，保存为tif格式）作为训练数据，打开jTessBoxEditor，点击tools菜单选择Merge Tiff，在弹出框选择训练图片（如下图的01-04，数据越多训练效果越好），点击“打开”按钮，弹出保存多张tif文件的名称输入框（如下图标注的3），按上面提到的tif文件命名格式填入文件名，如下图：
点击上图中的保存按钮，则将多张tif文件合并为一个tif文件num.font.exp0.tif。
2、生成box文件
打开命令行执行命令tesseract num.font.exp0.tif num.font.exp0 batch.nochop makebox生成box文件，执行命令后输出如下：
D:\wspace\tess4j-demo2\test-data\num&gt;tesseract num.font.exp0.tif num.font.exp0 batch.nochop makebox
Tesseract Open Source OCR Engine v4.0.0.20181030 with Leptonica
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70373035f5c5e84e63b7183e8bacf787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11197af89aecc8d138e47a67fbeb6e82/" rel="bookmark">
			解决pip更新问题。 You are using pip version 19.0.3, however version 19.1 is available.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当直接输入python -m pip install --upgrade pip更新还报错的时候，
输入命令：python -m pip install -U pip
Collecting pip
Downloading https://files.pythonhosted.org/packages/f9/fb/863012b13912709c13cf5cfdbfb304fa6c727659d6290438e1a88df9d848/pip-19.1-py2.py3-none-any.whl (1.4MB)
100% |████████████████████████████████| 1.4MB 21kB/s
Installing collected packages: pip
Found existing installation: pip 19.0.3
Uninstalling pip-19.0.3:
Successfully uninstalled pip-19.0.3
Successfully installed pip-19.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770c32c897ca5551c5aa86d41aa03e1f/" rel="bookmark">
			练习题：随机生成20个学生的成绩; 判断这20个学生成绩的等级;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import random def ran(n): if n &gt;90: ------》先定义形参n，是函数体内的变量n有意义，不然n会出现下划线，但不急着传参** return 'A' elif 80 &lt; n &lt; 90: return 'B' elif 60 &lt; n &lt; 80: return 'C' else: return 'D' def main(): for i in range(1,21): ----》使下方的print的内容循坏20行输出** score=random.randint(1,100) ----》取一个1，100内的随机整数 print('得分%s,等级为%s'%(score,ran(score))) ---》在这里给ran（）传参，可以达到随机20个的目的，要灵活运用传参的位置*** main() -----》置顶格，与函数名对齐，不然打印为空 转载于:https://www.cnblogs.com/zzzynx/p/10766174.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/799a35a30febe409e5907fd42ea2afa2/" rel="bookmark">
			【TensorFlow】理解tf.placeholder方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在tf里，placeholder方法可以说是最常见，用的最多的一个api了，这里就介绍一下这个api的具体使用情况。
通常placeholder的作用理解为是占位符，不过占位符这个概念似乎有些抽象，字面意思其实就是它的作用 — 占个位置，那啥东西是占个位置啊，大家只要写过函数就知道，形参就是占位置嘛。就像java或者C++里定义一个函数，会有形参，用来代替实际参数，在实际调用该方法的时候传入实参。
注意：占位符并没有初始值，它只会分配必要的内存
1、基本信息 先看一下方法的基本定义：
tf.placeholder( dtype, shape=None, name=None ) 输入参数共有三个：dtype，shape，name
dtype：表示输入的张量数据类型，常用的有float32，int32，float64等shape：表示输入的张量大小，默认是None，也可以表示多维，如 (2, 3) 表示2行3列，(None, 4) 表示4列但行数不确定，这种写法非常常见name：表示输入张量的名称 2、样例 看一下官网给的demo
x = tf.placeholder(tf.float32, shape=(1024, 1024)) y = tf.matmul(x, x) with tf.Session() as sess: print(sess.run(y)) # ERROR: will fail because x was not fed. rand_array = np.random.rand(1024, 1024) print(sess.run(y, feed_dict={x: rand_array})) # Will succeed. 解释一下上面的样例，首先定义了一个占位符 x，传入的张量数据类型是float32，大小是1024*1024，然后定义了一个张量运算，x * x，将结果返回给 y，就这么简单。
我们可以看到，第5行代码打印了 y 的运行结果，但是这样的写法是不对的，因为这个时候，x是没有被赋值初始化的，会报错。
必须按照第7，8两行的写法，先初始化一个对应 x 大小的张量，再把这个初始化张量通过 feed_dict 赋值给 x，在计算 y 的时候 x 就是已经初始化了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/799a35a30febe409e5907fd42ea2afa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9596b824788ffb757b37b876f8eab42/" rel="bookmark">
			ASCII码值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		|字符 | 码值 |
|a|97|
| 0 |48 |
|A|65|
http://tool.oschina.net/commons?type=4
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6ed08a0a2b440b6a9e7e78b692ae2da/" rel="bookmark">
			mysql datetime 插入或修改日期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL 中，字段定义为日期datetime格式，如果insert或update语句赋值字符串格式，如：'2019-01-01 12:00:00'，MySQL可以自动转为日期格式。
但如果是用hibernate中的hql 新增或修改，日期格式对应的参数值也必须是日期格式。例如 ：
INSERT INTO '类名'(列1, 列2,...) VALUES (值1, 值2,....) 如果列1是日期格式，值1也必须是日期格式，不能为字符串。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e250b4598bd52e2f52b69de77f745c/" rel="bookmark">
			javascript  二维数组   json数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二维数组的建立
javascript创建键值对的二维数组 var arr = new Array(); arr[0] = new Array(); arr[0]['name'] = "jack"; arr[0]['age'] = "21"; arr[1] = new Array(); arr[1]['name'] = "rose"; arr[1]['age'] = "22"; console.log(arr) 输出结果：
json对象的建立
我们在开发的过程中会用ajax，data参数的数据我们就可以用json对象来传递 var json={}; json.id=1; json.name='dog' console.log(json); 输出结果：
数组添加json对象 混合使用 var json={}; json.id=1; json.name='dog' var arr = new Array(); arr[0] = new Array(); arr[0]['name'] = "jack"; arr[0]['age'] = "21"; arr[1] = new Array(); arr[1]['name'] = "rose"; arr[1]['age'] = "22"; arr.push(json) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3df71775b9916512943cac7dabb95bd/" rel="bookmark">
			C/C&#43;&#43;---随机数生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在C/C++中一般使用rand()函数随机生成某些数字：
rand函数界限：stdlib.h头文件中有宏#define RAND_MAX 0x7fff
rand产生一个0-0x7fff的随机数，即最大是32767的一个数
rand()无参数，返回一个从0到32767的任意整数
**需要生成 a-b之间的随机数： rand()%(b-a+1)+a //表示a-b之间随机产生的一个整数 如果要产生0-99这100个整数中的一个随机整数，可以用 int num=rand()%100 如果要产生1-100这100个整数中一个随机整数，可以用 int num=rand%100+1 如果要产生1.8-3.5之间一个随机浮点数，可以采用如下方法：
float a=rand()%18+18; float b=a/10; 注：1. rand()函数每次调用前都会查询是否调用过srand(seed)，是否给seed设定了一个值，如果有那么它会自动调用srand(seed)一次来初始化它的起始值；
2. 若之前没有调用srand（seed），那么系统会自动给seed赋初始值，即srand（1）自动调用它一次
手动设置种子点：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main(){ int a[10]/*用于保存10个产生的随机数*/, i; srand((unsigned int)time(NULL));//设置当前时间为种子 for (i = 0; i &lt; 10; ++i){ a[i] = rand()%100+1;//产生1~100的随机数 } //打印生成的随机数 for (i = 0; i &lt; 10; ++i){ printf ("%d ", a[i]); } printf ("\n"); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49e9f5fc96dce07e453b54beea1eadf8/" rel="bookmark">
			非线性规划（二）: Matlab 求解约束极值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非线性规划（一）：定义与数值优化方法(梯度法、牛顿法、拟牛顿法、变尺度法)
非线性规划（二）: Matlab 求解约束极值问题
目录
约束极值问题 1 二次规划 2 罚函数法 3 Matlab 求约束极值问题 3.1 fminbnd 函数 3.2 fseminf 函数 3.3 fminimax 函数 4 Matlab 优化工具箱的用户图形界面解法 4 非线性规划的应用：飞行管理问题
4.1 模型一 4.2 模型二 习 题 约束极值问题 带有约束条件的极值问题称为约束极值问题，也叫规划问题。 求解约束极值问题要比求解无约束极值问题困难得多。为了简化其优化工作，可采用以下方法：将约束问题化为无约束问题；将非线性规划问题化为线性规划问题，以及 能将复杂问题变换为较简单问题的其它方法。 库恩—塔克条件是非线性规划领域中重要的理论成果之一，是确定某点为优点 的必要条件，但一般说它并不是充分条件（对于凸规划，它既是优点存在的必要条件， 同时也是充分条件）。 无约束问题的求解请参考这里：非线性规划（一）：定义与数值优化方法 1 二次规划 若某非线性规划的目标函数为自变量 x的二次函数，约束条件又全是线性的，就称 这种规划为二次规划。
Matlab 中求解二次规划的命令是 [X,FVAL]= QUADPROG(H,f,A,b,Aeq,beq,LB,UB,X0,OPTIONS) 返回值 X 是决策向量 x的值，返回值 FVAL 是目标函数在 x处的值。（具体细节可以参 看在 Matlab 指令中运行 help quadprog 后的帮助）。 h=[4,-4;-4,8]; f=[-6;-3]; a=[1,1;4,1]; b=[3;9]; [x,value]=quadprog(h,f,a,b,[],[],zeros(2,1)) 2 罚函数法 利用罚函数法，可将非线性规划问题的求解，转化为求解一系列无约束极值问题， 因而也称这种方法为序列无约束小化技术，简记为 SUMT (Sequential Unconstrained Minization Technique)。 罚函数法求解非线性规划问题的思想是，利用问题中的约束函数作出适当的罚函 数，由此构造出带参数的增广目标函数，把问题转化为无约束非线性规划问题。主要有 两种形式，一种叫外罚函数法，另一种叫内罚函数法，下面介绍外罚函数法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49e9f5fc96dce07e453b54beea1eadf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87b76d24ef9112dd9bbcf38172bf934e/" rel="bookmark">
			python学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档(https://docs.python.org/zh-cn/3/library/typing.html)
cookbook(https://python3-cookbook.readthedocs.io/zh_CN/latest/c07/p03_attach_informatinal_matadata_to_function_arguments.html)
给函数参数增加元信息 你写好了一个函数，然后想为这个函数的参数增加一些额外的信息，这样的话其他使用者就能清楚的知道这个函数应该怎么使用。
解决方案
使用函数参数注解是一个很好的办法，它能提示程序员应该怎样正确使用这个函数。 例如，下面有一个被注解了的函数：
def add(x:int, y:int) -&gt; int: return x + y python解释器不会对这些注解添加任何的语义。它们不会被类型检查，运行时跟没有加注解之前的效果也没有任何差距。 然而，对于那些阅读源码的人来讲就很有帮助啦。第三方工具和框架可能会对这些注解添加语义。同时它们也会出现在文档中。
Help on function add in module __main__: add(x: int, y: int) -&gt; int 尽管你可以使用任意类型的对象给函数添加注解(例如数字，字符串，对象实例等等)，不过通常来讲使用类或者字符串会比较好点
函数接受并返回一个字符串，注释像下面这样: def greeting(name: str) -&gt; str: return 'Hello ' + name 在函数 greeting 中，参数 name 预期是 str 类型，并且返回 str 类型。子类型允许作为参数。 断点 # 此处为断点 # sys.exit(0) 断言 assert
assert condition
assert condition,‘str’
用来让程序测试这个condition，true,就忽略，　如果condition为false，那么raise一个AssertionError出来。逻辑上等同于：
if not condition: raise AssertionError() 例子如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87b76d24ef9112dd9bbcf38172bf934e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6989759615e089be81aa48a3f6aa3489/" rel="bookmark">
			SQL Server 2017 Always On AG on Linux（二）SQL Server 证书及权限配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		既然没有了域认证，需要配置证书认证，步骤：
1. 启用S​​QL Server Always On Availability Groups功能
2. 在所有服务器上为SQL Server Always On Availability Groups安装Linux资源代理
3. 在所有Linux服务器启用防火墙上的Always On Availability Group端点端口
4. 在主副本上创建数据库主密钥
5. 创建将用于加密可用性组端点的证书
6. 使用证书为主副本创建Always On Availability Group端点进行身份验证
7. 将证书导出到文件
8. 将证书文件复制到辅助副本
9. 授予证书文件的SQL Server帐户权限
10. 在主副本上创建登录账号以供辅助副本使用
11. 为登录账号创建用户
12. 将步骤5中创建的证书与用户关联
13. 授予登录账号的CONNECT权限
1. 所有服务器：启用 hadr 功能（Always On Availability Groups）
/opt/mssql/bin/mssql-conf set hadr.hadrenabled 1 systemctl restart mssql-server 2. 所有服务器：为 SQL Server AlwaysOn AG 安装Linux资源代理。
群集资源代理程序 mssql-server-ha 是 Pacemaker 和 SQL Server 之间的接口
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6989759615e089be81aa48a3f6aa3489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19e86a815268d7982c332e59717c9ae6/" rel="bookmark">
			vscode 如何快速跳出括号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode 快速跳出括号 VS Code可以自动补全括号，补全的时候当然很爽，但事后身陷括号中，该如何是好呢？
其实大多数时候（编辑器），支持的比如想从括号右边跳出，那么你输入右括号就可以跳出来了。但是一些时候，我们想要跳出括号的时候，并不在括号中最后一个位置。这时该如何是好？
我的解决方法是通过安装插件设置快捷键解决。有两个插件可以推荐：
TabOut 这插件，顾名思义就是用 tab 键快速跳出括号。我看到挺多网上搜索出来的方式都是用这个插件实现的。但是这个插件太简单了，只有当光标在括号中最后一个位置时才能跳出括号，或者就是 tab，并且只能向后跳出。所以，感觉还是比较鸡肋的。 Bracket Jumper。个人非常推荐这个插件。因为功能很多，绑定相应的快捷键可以在括号内任意位置，向前、向后跳出括号，不会与 tab 键冲突。
通过绑定快捷键还可以实现更多的功能：。
我现在就是使用 shift+uparrow\downarrow 跳来跳去，非常好用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e19c0d69920840d503fe7bff10163066/" rel="bookmark">
			RefineNet: Multi-Path Refinement Networks for High-Resolution Semantic Segmentation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		conde: https://github.com/guosheng/refinenet
1 Introduction 主要贡献
1 多路径细化网络, 利用多层的抽象特征对于高分辨率语义分割, 网络运用低分辨率语义特征和描绘细节的底层特征去回归方法产生高分辨率语义特征图.
2 网络可以进行端到端的训练, 这对于性能非常重要, 网络中使用残量连接 和 恒等映射, 因此梯度可以直接通过短距离和长距离的残量网络进行传播, 从而有效的端到端的训练.
3 chained residual pooling: 能够从图像一个大的区域捕获背景信息. 它通过有效地池化具有多个窗口大小的特征并将它们与剩余连接和可学习的权重融合在一起来实现。
1.1 Related work RefineNet employs short-range and long-range residual connections with identity mappings which enable effective end-to-end training of the whole system, and thus help to archive good performance
2 Background ResNet通过stride=2减少特征图分辨率一半. 有两个影响:
First: it increases the receptive field of convolutions at deeper levels, enabling the filters to capture more global and contextual information which is essential for high quality classification
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e19c0d69920840d503fe7bff10163066/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb9382f619fbdd065d5d18d0bf9904b5/" rel="bookmark">
			concat函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在数据库中两个字段的值要在页面同一栏中展示，如图1到图2。用concat()函数。
SQL CONCAT函数用于将两个字符串连接起来，形成一个单一的字符串。
SQL CONCAT函数实例代码教程 - SQL CONCAT函数用于将两个字符串连接起来，形成一个单一的字符串。
SQL CONCAT函数用于将两个字符串连接起来，形成一个单一的字符串。试试下面的例子：
SQL&gt; SELECT CONCAT('FIRST ', ‘SECOND’);
±---------------------------+
| CONCAT('FIRST ', ‘SECOND’) |
±---------------------------+
| FIRST SECOND |
±---------------------------+
1 row in set (0.00 sec)
想要更详细了解CONCAT函数，考虑EMPLOYEE_TBL的表具有以下记录：
SQL&gt; SELECT * FROM employee_tbl;
±-----±-----±-----------±-------------------+
| id | name | work_date | daily_typing_pages |
±-----±-----±-----------±-------------------+
| 1 | John | 2007-01-24 | 250 |
| 2 | Ram | 2007-05-27 | 220 |
| 3 | Jack | 2007-05-06 | 170 |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb9382f619fbdd065d5d18d0bf9904b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eadf081f6c7c41cc7e62f2b34cd6b629/" rel="bookmark">
			农业种植农产品粮食大米和田香米水稻网站织梦模板源码下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模板名称：（自适应手机版）响应式粮食大米米业类织梦模板 HTML5响应式农业农产品网站源码下载
这款模板使用范围极广，不仅仅局限于一类型的企业，你只需要把图片和产品内容更换下，适用于任何行业。
本套织梦模板采用现在非常流行的全屏自适应布局设计，且栏目列表以简洁，非常时尚大气。页面根据分辨率大小而自动排版，很大程度上改善了页面宽度兼容问题，
适应大部分显示器分辨率尺寸哦。模板整体以多种颜色为主色调，适合做各种类型的网站。
本套织梦模板采用现在非常流行的全屏自适应布局设计，且栏目列表以简洁，非常时尚大气。页面根据分辨率大小而自动排版，很大程度上改善了页面宽度兼容问题，
适应大部分显示器分辨率尺寸哦。模板整体以多种颜色为主色调，适合做各种类型的网站。
同一个后台管理三网合一简单方便，体验极佳
1、该模板由AB模板王站长亲自制作，代码干净整洁;
2、效果相当的炫酷，相当简洁大气高端，模板简单，全部已数据调用，只需后台修改栏目名称即可
3、适用于粮食大米网站模版、农业农产品网站源码;
4、网站手工DIV+css，代码精简，首页排版整洁大方、布局合理、利于SEO、图文并茂、静态HTML;
5、首页和全局重新做了全面优化，方便大家无缝使用;
查看演示地址：http://7593543f2ad180d3.dededianpu.com/ 下载地址：https://www.dededianpu.com/post/65.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09be2196cdc96618a1d6e2d12a680e1/" rel="bookmark">
			js 箭头函数什么时候不需要用return 就可以有返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b01c2d6afaba766ac20a2c30e7c7908/" rel="bookmark">
			STM32F103 使用TIM3产生四路PWM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32F103 使用TIM3产生四路PWM
程序如下：
复制代码
/*******************************************************************************
程序说明 : 思路PWM波生成函数函数功能 : 使用TIM3的PWM功能生成思路PWM，输 入 : 无输 出 : 四路PWM，通过GPIO引脚复用，对TIM3的四个输出通道引脚重映射为PC6、PC7、PC8、PC9
*******************************************************************************/ #include"stm32f10x.h"
void RCC_Cfg(void);
void GPIO_Cfg(void);
void TIM_Cfg(void);
void NVIC_Cfg(void);
void delay_ms(u32 i);
void PWM_Cfg(float dutyfactor1,float dutyfactor2,float dutyfactor3,float dutyfactor4);
int main()
{
u8 flag = 1;
float ooo=0.5;
RCC_Cfg();
NVIC_Cfg();
GPIO_Cfg();
TIM_Cfg();
//开启定时器2 TIM_Cmd(TIM3,ENABLE); //呼吸灯 while(1){ PWM_Cfg(ooo,10,50+0.5*ooo,200-2*ooo); if(flag == 1) { ooo=ooo+0.002; } if(flag == 0) { ooo=ooo-0.002; } if(ooo&gt;100){ flag = 0; } if(ooo&lt;0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b01c2d6afaba766ac20a2c30e7c7908/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/820892ff92fd281cf8f8b5933251725f/" rel="bookmark">
			solidworks中，对实体进行镜像后，只保留镜像后的实体而删除镜像前的实体的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要按 插入—特征—删除实体 步骤做，如果直接在绘图窗口选中镜像前的实体，然后用delete删除，则镜像前后的实体将一同删除掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be89ff7bda04fcc4781759c21316f8e0/" rel="bookmark">
			scp在命令行中带密码远程下载文件 sshpass安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sshpass-Linux命令之非交互SSH密码验证
ssh登陆不能在命令行中指定密码。sshpass的出现，解决了这一问题。sshpass用于非交互SSH的密码验证，一般用在sh脚本中，无须再次输入密码。
它允许你用 -p 参数指定明文密码，然后直接登录远程服务器，它支持密码从命令行、文件、环境变量中读取。
安装步骤如下：
1. 下载
sshpass下载地址：http://sourceforge.net/projects/sshpass/ 下载为一个 tar.gz的压缩包。
2.把tar.gz的压缩包 上传到linux服务器，此处以sshpass-1.06.tar.gz为例,服务器存放目录为/user/
3.到user目录下，执行:cd /user
4.解压缩
tar -zxvf sshpass-1.06.tar.gz
5.进入解压后的文件目录
执行：cd sshpass-1.06
6.指定安装目录
执行：./configure --prefix=/user/sshpass
说明：/user/sshpass就是安装sshpass的路径。
7.加载
执行：make
再执行：make install
8.复制
执行：cp /user/sshpass/bin/sshpass /usr/bin/
说明：/user/sshpass是安装sshpass的路径。
9.检验是否安装成功
执行：sshpass
出现如下提示即安装成功：10.使用
sshpass -p ‘密码’ scp -r root@192.168.0.4:/user/count_fille.txt /user/
说明如下：注意：对于ssh的第一次登陆，会提示：“Are you sure you want to continue connecting (yes/no)”，这时用sshpass会不好使，可以在ssh命令后面加上 -o StrictHostKeyChecking=no来解决
11.如需定时执行
（1）生成一个.sh的文件，
执行：vi testsshpass.sh
然后把下面的粘贴进去,并保存
#!/bin/sh
sshpass -p ‘密码’ scp -r root@192.168.0.4:/user/count_fille.txt /user/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be89ff7bda04fcc4781759c21316f8e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49623bcdccb57b6ed62bdbbdde42ca1b/" rel="bookmark">
			Cocoapods 二进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 什么是组件二进制化？
在iOS开发中，事实标准是我们使用CocoaPods生成、管理和使用library。这里的library就是一个模块、组件或库。二进制化指的是通过编译把组件的源码转换成静态库或动态库，以提高该组件在App项目中的编译速度。 为什么我们需要二进制化呢？
在我们App开发中，我们逐渐的抽象了很多模块、业务、UI等把他转换成私有CocoaPod库。其中有很多我们自己的组件是用Swift写的，源码格式为.Swift。在app项目编译时.Swift部分代码编译非常慢。 随着业务的扩展，私有CocoaPod库和第三方CocoaPod库越来越多，App项目中的文件也越来越多。每次pod install安装新库或pod update更新库的时候，重新编译的过程需要等待很长时间。这也向我们提出了加快编译速度的需求。 下面是使用的工具个人理解上的对比，如果有不对的地方往指正和沟通，互相进步和学习
Cocopods组件二进制插件 二进制化后，可以看出我们编译的target变少了,少了RxSwift.....这些target,这些就时间差的由来。cocoapods-bin(是一个非cocoapods的开源项目) 该插件进行二进制化的策略是采用双私有源，即2个服务器一个静态服务器保存预先打好包的.a或者framework，一个是我们现在保存源码的服务器，在install的时候去选择使用下载那个。该插件优点缺点也十分明显 优点：源码和二进制文件之间可以来回切换，速度比较快缺点：源码的变动不能及时得到响应，而且需要第二个私有服务器cocoapods-packager(cocoapods的开源项目) 该插件是cocoapods的一个插件，主要是来将私有库打包成二级制的一个插件，通过修改*.podspec文件该插件的优缺点： 优点：可以将私有库打包成二级制文件，由组件本身去管理二进制文件，方便为主项目集成，私有库变动等缺点：该库已经有很长一段时间不维护了，很多问题都未解决，而且我们的组件里依赖相对比较复杂，使用的Swift不能很好的支持。cocoapods-binary(是一个非cocoapods的开源项目) 该插件是开源的Cocoapods推荐的的一个插件，主要是来将Podfile里所依赖的组件选择性打包成二级制的一个插件，通过修改Podfile文件里的内容该插件的优缺点： 优点：选择性的在将那些组件使用二进制，不需要多个服务去存二级制文件，二进制文件在pod install的过程进行预编译，生成的项目之间依赖framework。源码变动能比较快的得到相应缺点：二进制切换到源码文件的时候都会删除已经打好的二级制文件，下次切换需要重新编译新的二级制文件，这个过程比较耗时 Usage 在Podfile中加入以下内容
#引入插件 plugin 'cocoapods-binary' #一定要使用framework use_frameworks! #该值打开后 默认所有的依赖都将开启二进制化 #all_binary! #在依赖的组件后添加:binary =&gt; true/false 来切换源码和二级制 如果打开了上面的all_binary！后默认都是true target "HP" do pod "ExpectoPatronum", :binary =&gt; true end 复制代码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c39830d2991c19af3dc08a3a26825e/" rel="bookmark">
			现代优化算法 （一）：模拟退火算法 及应用举例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合优化算法系列：
现代优化算法 （一）：模拟退火算法 及应用举例
现代优化算法 （二）： 遗传算法 及应用举例
现代优化算法(三）：禁忌搜索算法
现代优化算法（四）：改进的遗传算法
现代优化算法（五）： 蚁群算法
现代优化算法是 80 年代初兴起的启发式算法。这些算法包括禁忌搜索（tabu search），模拟退火（simulated annealing），遗传算法（genetic algorithms），人工神经网 络（neural networks）。它们主要用于解决大量的实际应用问题。目前，这些算法在理论 和实际应用方面得到了较大的发展。无论这些算法是怎样产生的，它们有一个共同的目 标－求 NP-hard 组合优化问题的全局优解。虽然有这些目标，但 NP-hard 理论限制它 们只能以启发式的算法去求解实际问题。
启发式算法包含的算法很多，例如解决复杂优化问题的蚁群算法（Ant Colony Algorithms）。有些启发式算法是根据实际问题而产生的，如解空间分解、解空间的限 制等；另一类算法是集成算法，这些算法是诸多启发式算法的合成。
现代优化算法解决组合优化问题，如 TSP（Traveling Salesman Problem）问题，QAP （Quadratic Assignment Problem）问题，JSP（Job-shop Scheduling Problem）问题等效 果很好。 目录
模拟退火算法简介 1.2 应用举例
模拟退火算法简介 模拟退火算法得益于材料的统计力学的研究成果。统计力学表明材料中粒子的不 同结构对应于粒子的不同能量水平。在高温条件下，粒子的能量较高，可以自由运动和 重新排列。在低温条件下，粒子能量较低。如果从高温开始，非常缓慢地降温（这个过 程被称为退火），粒子就可以在每个温度下达到热平衡。当系统完全被冷却时，终形 成处于低能状态的晶体。
在模拟退火算法中应注意以下问题：
（1）理论上，降温过程要足够缓慢，要使得在每一温度下达到热平衡。但在计算 机实现中，如果降温速度过缓，所得到的解的性能会较为令人满意，但是算法会太慢， 相对于简单的搜索算法不具有明显优势。如果降温速度过快，很可能终得不到全局 优解。因此使用时要综合考虑解的性能和算法速度，在两者之间采取一种折衷。
（2）要确定在每一温度下状态转换的结束准则。实际操作可以考虑当连续m 次的 转换过程没有使状态发生变化时结束该温度下的状态转换。终温度的确定可以提前定 为一个较小的值 ，或连续几个温度下转换过程没有使状态发生变化算法就结束。
（3）选择初始温度和确定某个可行解的邻域的方法也要恰当。 1.2 应用举例 例 已知敌方 100 个目标的经度、纬度如表 1 所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30c39830d2991c19af3dc08a3a26825e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e30aa339a8d240d74d6cb182d7d14b08/" rel="bookmark">
			灰度共生矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用C++、opencv获取图像的灰度共生矩阵，即能量、熵、对比度、逆差矩等图像特征参数 灰度共生矩阵，指的是一种通过研究灰度的空间相关特性来描述纹理的常用方法，通俗的说就是图像的一组关于纹理信息图像特征（能量、熵、对比度、逆差矩），可以将纹理数字化。
灰度共生矩阵的原理和四个特征参数的计算公式可参考博客：https://blog.csdn.net/zhangxz259/article/details/81700167及https://blog.csdn.net/qq_37059483/article/details/78292869
代码：
#include "stdafx.h" #include &lt;iostream&gt; #include &lt;opencv2/highgui.hpp&gt; #include &lt;opencv2/core.hpp&gt; #include &lt;opencv2/imgcodecs.hpp&gt; #include &lt;opencv2/opencv.hpp&gt; using namespace std; using namespace cv; //灰度等级设为16 const int gray_level = 16; //0度灰度共生矩阵 void getglcm_horison(Mat&amp; input, Mat&amp; dst) { Mat src = input; CV_Assert(1 == src.channels()); src.convertTo(src, CV_32S); int height = src.rows; int width = src.cols; int max_gray_level = 0; for (int j = 0; j &lt; height; j++)//寻找像素灰度最大值 { int* srcdata = src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e30aa339a8d240d74d6cb182d7d14b08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1940de5d49db889cac42e15ca50e8b44/" rel="bookmark">
			【微信小程序】各种页面特效链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文字跑马灯效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1038触摸水波涟漪效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1350下拉菜单效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1875五星评分效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1876数字累加，动态效果：http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1694星战字幕效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1689动画卡片效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=2193图片的滤镜效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=3949黑客帝国metrix效果：http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4670CSS3动画效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4628仿直播点赞气泡效果：http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=2833文字弹幕效果： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4713发短信验证码倒计时：http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1671弹出菜单特效： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1659滚动动画： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1538实时圆形进度条： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1456遮罩层： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=3617仿Table效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1038支付倒计时效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=890侧边栏滑动特效： http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=1202顶部导航效果： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1665弹出和隐藏动画： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1449切换动画： http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1113操作按钮悬浮固定在底部：http://www.wxapp-union.com/portal.php?mod=view&amp;aid=1029文字单行背景自适应带角标：http://www.wxapp-union.com/portal.php?mod=view&amp;aid=636仿UC宣传页面的简单动画效果：http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=4266列表项左滑删除效果：http://www.wxapp-union.com/forum.php?mod=viewthread&amp;tid=2189 原文地址：http://www.wxapp-union.com/thread-5338-1-1.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78d2ec8a2babc57de93f0e5c8499f07f/" rel="bookmark">
			Java设计模式：状态机模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class State { private String value; public String getValue() { return value; } public void setValue(String value) { this.value = value; } public void method1() { System.out.println("State method1"); } public void method2() { System.out.println("State method2"); } } public class Context { private State state; public Context(State state) { this.state = state; } public State getState() { return state; } public void setState(State state) { this.state = state; } public void method() { if (state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78d2ec8a2babc57de93f0e5c8499f07f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4a99e1722fad07c42a41c810cbd2ef4/" rel="bookmark">
			Python读取PDF文档（或TXT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字符串在Python内部的表示是Unicode编码，首先我们来认识Python中encode()和decode()的作用与区别：
在做编码转换时,通常需要以unicode作为中间编码,即先将其他编码的字符解码(decode)成unicode,再从unicode编码(encode)成另一种编码。
decode的作用是将其他编码的字符转换成unicode编码,如str1,decode(‘gb2312’),表示将gb2312编码的字符串str1转换成unicode编码。
encode的作用是将unicode编码转换成其他编码的字符串,如str2,encode(‘gb2312’),表示将unicode编码的字符串str2转换成gb2312编码。
常见文档读取有：
TXTPDF 其中TXT文档的读取较为简单，爬取网页数据时注意read()的编码设置即可
我们主要来介绍使用pdfminer3k模块读取PDF
· 文档PDF的Python读取： ——英文PDF文件支持最好且只支持英文PDF是pyPDF2库
——而对于多语言PDF文件支持最好的则是pdfminer，我们这里就使用pdfminer3k库来实现读取PDF。
1. 安装pdfminer3k：
——pip install pdfminer3k ——python setup.py install`在这里插入代码片` 2. 验证安装pdfminer3k是否成功：
在cmd下，进入tools目录下（ cd ~/Downloads/pdfminer3k-1.3.1/tools）后使用命令 ——python3 pdf2txt.py ../samples/simple1.pdf #..是退回上一层目录的意思 3. Python读取PDF文档：
pdfminer3k中类的关系：
读取流程：
——打开pdf文档的文件对象：
fp = open("naacl06-shinyama.pdf", 'rb') #本地文档 fp = urlopen('https://www.tencent.com/zh-cn/articles/802741466496787.pdf') #在线pdf ——创建文档分析器（解析器）：
pdf_parser = PDFParser(fp) #传入pdf，从中获取数据 ——创建文档对象，保存获取的数据：
pdf_doc = PDFDocument() #保存获取的数据，和PDFParser是相互关联的 ——连接分析器和文档对象：
pdf_parser.set_document(doc) doc.set_parser(pdf_parser) ——判断文件是否允许文本提取：
if not doc.is_extractable: raise PDFTextExtractionNotAllowed #raise如果抛出异常，后续语句不执行 ——对文档对象提供密码（password）初始化，没有就不用传该参数：
doc.initialize("") ——创建资源管理器：
resource = PDFResourceManager() #用于存储共享资源，如字体或图像 ——创建参数分析器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4a99e1722fad07c42a41c810cbd2ef4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/481/">«</a>
	<span class="pagination__item pagination__item--current">482/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/483/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>