<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d75221bc1f6163f62828fdb596600fd8/" rel="bookmark">
			使用adb安装或卸载卸载手机系统应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用adb安装/卸载手机系统应用 准备工具 在浏览器下载并打开带有adb的工具；
手机打开“开发者选项”，在“开发者选项”中开启usb调试并连接电脑，手机端选择“传输文件”；
在手机端点击 “一律允许计算机调试”，等待手机与电脑连接成功；
在此处打开终端命令，输入adb devices 查看手机是否连接电脑；
打开adb工具，输入：adb shell，等待出现机型的字样即可；
注意：
机型的字样类似于PD1984:/ $
开始操作 输入pm list packages 命令，可以查看手机目前安装的所有应用，用于找到想卸载的软件名称。
注意：
此处均为英文。
卸载应用： 输入pm uninstall -k --user 0 应用软件名 命令，即可卸载某应用。
注意：
-k 命令会保留用户数据，若不包含-k则不会保留用户数据，清除的会较彻底。
--user与数字之间、应用软件名之间是有英文空格隔开的，若多了或者少了空格，命令都不会生效。
出现“Success”，则表示卸载应用成功。
注意
大部分系统应用要卸载2次。
系统应用会升级，第一次卸载的是更新的系统应用，第二次才能彻底卸载老版的系统应用。
重新安装/恢复应用 输入pm install-existing --user 0 应用软件名，即可重新安装/恢复某系统应用。
注意：
数字0与应用软件名之间有英文空格。
停用/冻结应用 输入adb shell pm disable-user 应用软件名命令，即可停用/冻结某系统应用。
出现”disabled-user“，则表示停用/冻结应用成功。
启用/解冻应用 输入adb shell pm enable 应用软件名命令，即可启用/解冻某系统应用。
出现”disabled-user“，则表示启用/解冻应用成功。
应用软件名 小米MIUI系统内置软件 应用软件名应用软件显示名称com.miui.analytics小米广告分析（必删）com.miui.systemAdSolution小米系统广告解决方案（必删）com.miui.virtualsim全球上网com.android.email电子邮件com.miui.backup备份com.miui.notes便签com.miui.hybrid快应用com.miui.hybrid.accessory快应用服务com.xiaomi.scanner扫一扫com.android.quicksearchbox搜索com.miui.voiceassist小爱同学com.miui.player音乐com.miui.video视频com.miui.cloudbackup桌面备份com.miui.bugreport用户反馈com.miui.touchassistant悬浮球com.android.printspooler打印处理服务com.android.bips默认打印服务com.xiaomi.gamecenter游戏中心com.xiaomi.gamecenter.sdk.service游戏服务com.miui.userguide用户手册com.miui.cloudservice小米云服务com.android.midrive小米云盘com.miui.yellowpage生活黄页com.miui.screenrecorder屏幕录制com.android.browser浏览器com.miui.contentextension传送门com.android.providers.userdictionary用户字典com.xiaomi.payment米币支付com.xiaomi.drivemode驾车模式com.android.stkUSIM卡应用com.xiaomi.simactivate.service小米SIM卡激活服务com.sohu.inputmethod.sogou.xiaomi搜狗输入法小米版com.miui.personalassistant智能助理com.android.calllogbackup小米云服务中备份通话记录com.miui.systemAdSolutionMSA小米广告推送服务com.xiaomi.scanner扫一扫com.miui.analyticsAnalyticscom.dsi.ant.serverANT HAL Servicecom.svox.picoPico TTS 语音识别系统com.android.thememanager个性主题com.miui.compass指南针com.miui.aod万象熄屏 vivo OriginOS系统内置软件 应用软件名应用软件显示名称com.android.bbkmusicvivo i音乐com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d75221bc1f6163f62828fdb596600fd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ad106ff3f1967e53ca34dec2891a54/" rel="bookmark">
			华为区块链开发,处方流转合约Java代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://wheart.cn/ package org.hyperledger.fabric.example; import java.util.List; import com.google.gson.Gson; import com.google.protobuf.ByteString; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.hyperledger.fabric.shim.ChaincodeBase; import org.hyperledger.fabric.shim.ChaincodeStub; import static java.nio.charset.StandardCharsets.UTF_8; public class SimpleChaincode extends ChaincodeBase { // 药品对象定义 class Drug { // 药品名称 String drugName; // 用法 String drugUsage; // 用量 String drugAmount; // 频率 String drugRate; // 数量 int drugNumber; } // 签章对象定义 class Signature { // 签章机构 String signCompany; // 签章内容 String signInfo; // 签章时间 String signTime; // 存证信息 String certificateInfo; } // 患者授权对象定义 class Accredit { // 被授权机构名称 String toAccreditCompany; // 被授权机构社会信用代码 String toAccreditCompanyId; // 被授权机构分支机构 String toAccreditCompanyBranch; // 授权开始时间 String beginTime; // 授权结束时间 String endTime; // 授权状态(0-未用;1-使用;9-取消) int accreditState; } // 处方登记对象定义 class Prescription { // 处方ID String prescriptionId; // 开具时间 String signTime; // 医生姓名 String dName; // 医生身份证 String dIdentityNumber; // 医院名称 String hospitalName; // 医院社会信用代码 String hospitalId; // 患者姓名 String name; // 患者身份证 String identityNumber; // 处方状态 String state; // 诊断信息 String diagnosticInfo; // 药品信息 (数组) Drug[] drugInfo; // 医生签章 (JSON字符串) Signature doctorSignature; // 医院签章 (JSON字符串) Signature hospitaSignature; // 药师签章 (JSON字符串) Signature pharmacistSignature; // 患者授权信息 (数组) Accredit[] accreditInfo; // 药师姓名 String pharmacistName; // 药师身份证 String pharmacistIdentityNumber; // 第三方审方机构名称 String auditName; // 第三方审方机构社会信用代码 String auditId; // 配药机构名称 String dispensingName; // 配药机构社会信用代码 String dispensingId; } // 处方审核对象定义 class PscrpAudit { // 处方ID String prescriptionId; // 处方状态 String state; // 药师签章 (JSON字符串) Signature pharmacistSignature; // 药师姓名 String pharmacistName; // 药师身份证 String pharmacistIdentityNumber; // 第三方审方机构名称 String auditName; // 第三方审方机构社会信用代码 String auditId; } // 患者授权对象定义 class PscrpAccredit { // 处方ID String prescriptionId; // 患者姓名 String name; // 患者身份证 String identityNumber; // 处方状态 String state; // 患者授权信息 (数组) Accredit[] accreditInfo; } // 处方配药对象定义 class PscrpDispensation { // 处方ID String prescriptionId; // 处方状态 String state; // 配药机构名称 String dispensingName; // 配药机构社会信用代码 String dispensingId; } private static Log logger = LogFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0ad106ff3f1967e53ca34dec2891a54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/821535db5dabb25eb3e9c02eff9b3c50/" rel="bookmark">
			Docker Capabilities
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux Capability Linux 内核中的 Capabilities 特性用于划分特权集，以便进程可以只分配 “执行特定功能” 的特权。
在引入此特性前，如果进程需要使用网络，则必须使用 root 来运行，通常是 sudo 或者添加 suid，那么普通用户在使用 ping 时，ping 就可以运行任何特权。引入 Capabilities 特性后，可以通过给 ping 应用添加 CAP_NET_RAW 特权集，使其具有使用网络的特权集，而不具备其他特权集。缺省 ping 具有 cap_net_admin 和 cap_net_raw 特权集
命令setcap和getcap可以设置和查看文件的capabilities。因为文件的capabilities存储在文件的扩展属性中（xattr），目前ext2，ext3，ext4和xfs等常用文件系统都支持扩展属性。常规cp命令不会复制文件capabilities，cp -a可以支持拷贝文件的capabilities。如文件系统没有设置xattr属性那么无论getcap，getfattr是看不到文件的capabilities属性的也可以函数setxattr()和getxattr()的security.capability字段是可以设置和查看文件的capabilities。
# getcap /bin/ping /bin/ping = cap_net_admin,cap_net_raw+p 在 Linux 中的 Capabilities 是通过 extended attributes 中的 security 命名空间实现的, selinux 也是一样 # getfattr -d -m "^security\\." /bin/ping getfattr: Removing leading '/' from absolute path names # file: bin/ping security.capability=0sAAAAAgAgAAAAAAAAAAAAAAAAAAA= security.selinux="system_u:object_r:ping_exec_t:s0" 可以通过查看进程 / proc/xxxx/status，来检查进程的特权集，并通过 capsh 来解码得到具体的特权集。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/821535db5dabb25eb3e9c02eff9b3c50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b27cae9d931b53138657b513b70c3c/" rel="bookmark">
			【码极客精讲】01背包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天阳了，没有发文。
我们今天就讲讲01背包。
01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2至Wn，与之相对应的价值为P1,P2至Pn。01背包是背包问题中最简单的问题。01背包的约束条件是给定几种物品，每种物品有且只有一个，并且有权值和体积两个属性。在01背包问题中，因为每种物品只有一个，对于每个物品只需要考虑选与不选两种情况。如果不选择将其放入背包中，则不需要处理。如果选择将其放入背包中，由于不清楚之前放入的物品占据了多大的空间，需要枚举将这个物品放入背包后可能占据背包空间的所有情况。 背包问题 问题雏形
01背包题目的雏形是：
有N件物品和一个容量为V的背包。第i件物品的体积是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。
从这个题目中可以看出，01背包的特点就是：每种物品仅有一件，可以选择放或不放。
其状态转移方程是：
f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
对于这方程其实并不难理解，方程之中，需要放置的是第i件物品，这件物品的体积是c[i],价值是w[i],因此f[i-1][v]代表的就是不将这件物品放入背包，而f[i-1][v-c[i]]+w[i]则是代表将第i件放入背包之后的总价值，比较两者的价值，得出最大的价值存入现在的背包之中。
理解了这个方程后，将方程代入实际题目的应用之中，可得
1
2
3
for (i = 1; i &lt;= n; i++)
for (j = v; j &gt;= c[i]; j--)//在这里，背包放入物品后，容量不断的减少，直到再也放不进了
f[i][j] = max(f[i - 1][j], f[i - 1][j - c[i]] + w[i]);
问题描述 求出获得最大价值的方案。
注意：在本题中，所有的体积值均为整数。
算法分析 对于背包问题，通常的处理方法是搜索。
用递归来完成搜索，算法设计如下：
1
2
3
4
5
6
7
8
9
10
11
int make(int i, int j)//处理到第i件物品,剩余的空间为j 初始时i=m , j=背包总容量
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b27cae9d931b53138657b513b70c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/185d9339372f712885aec3a50b2e0c3b/" rel="bookmark">
			JavaScript 将数组对象中的属性值提出放在新的数组里并起新的属性名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先循环需要提出字段的数组
2.var 对象
3.给新的属性起名
4.将值push到新的数组中
let itemList = [] for (var i = 0; i &lt; this.namelist.length; i++) { var obj = new Object(); obj.typeId = this.namelist[i].id itemList.push(obj) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a31b9f2740e3ec8aeb9df7d213d3338/" rel="bookmark">
			【Unity教程】如何实现Unity和Android原生互相调用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity是一个跨平台开发工具，发布到移动平台也是大部分Unity开发者的必备技能。而由于Unity跨平台的特性，总会遇到在移动平台的技术细节支持不够，或者需要在调用其他原生插件的情况。这里我们说一下如何在Android Studio中创建一个可供Unity调用的aar插件，以实现Unity和Android原生互相调用的目的。
开发工具 Android Studio，Unity
实现步骤 打开AndroidStudio，创建一个新的工程，选择NoActivity 选择存储路径。填写项目名，项目名无所谓，后续用不到；填写包名，包名后续需要在引用的时候用到。 创建好之后选择Android视图，在app上点击右键 new—Module，创建一个新的Module，选择Android Library。这个就是后续用来导出的库。 进入刚创建的Library，在下图的文件夹下右键，创建JavaClass，这个java类就是后续在Unity中引用的类。 接下来是一个Demo场景：在Unity中调用Android，弹出Tosat。并且回调Unity的指定方法： 6. 导出AAR：选中刚刚创建好的Library，选择Build— Make Module，将这个library打包为aar
导入Unity：将刚刚打包出的AAR文件放入Plugins-- Android文件夹中
Unity调用示例：
小结 Unity和Android代码互相调用是一种非常常见的开发方式，在弥补Unity功能的同时，也给原生SDK的接入提供了更多的可能性。较新版本的Unity已经可以支持直接导入java脚本文件而无需打包aar插件。
3DCAT实时云渲染为移动应用提供新的可能 随着3D可交互内容的逐步演进，客户端体积变得越来越庞大，对移动设备的硬件性能要求也越来越高，这些都成为了用户的痛点，并为新用户增加了极大的阻碍。云渲染的出现解决了这个痛点，开发者可以将庞大的3D资源存放于云端，用户只需要极少的成本便可快速体验到所需3D内容，为企业和用户清理了重重阻碍。运行在3DCAT实时渲染云的应用内容可灵活嵌入任意平台，支持海量用户安全访问，自动负载均衡和伸缩扩容。
如有需求，欢迎随时与我们联系！
本文《【Unity干货教程】如何实现Unity和Android原生互相调用？》内容由3DCAT实时云渲染解决方案提供商整理发布，如需转载，请注明出处及链接：【Unity干货教程】如何实现Unity和Android原生互相调用？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e72ca43ab4044da987ad2436ed5ce6a/" rel="bookmark">
			Django计算机毕业设计江西婺源旅游文化推广系统（程序&#43;lw）Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 该项目含有源码、文档、程序、数据库、配套开发软件、软件安装教程
项目运行
环境配置：
Pychram社区版+ python3.7.7 + Mysql5.7 + HBuilderX+list pip+Navicat11+Django+nodejs。
项目技术：
django + python+ Vue 等等组成，B/S模式 +pychram管理等等。
环境需要
1.运行环境：最好是python3.7.7，我们在这个版本上开发的。其他版本理论上也可以。
2.pycharm环境：pycharm都可以。推荐pycharm社区版;
3.mysql环境：建议是用5.7版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
6.Navcat11：这个版本不限10/11/14/15都可以。；
Python-Django毕设帮助，指导，本源码(见文末)，调试部署
5.1登录注册模块的实现 系统登录模块，为确保系统安全性，系统操作员只有在登录界面输入正确的管理员名、密码、权限以及验证码，单击“登录”按钮后才能够进入本系统的主界面。
管理员登录流程图如下所示。
图5-1管理员登录流程图
登录界面如下图所示。 图5-2登录界面图
用户注册，在用户注册页面通过填写账号、密码、姓名、年龄、手机等信息进行注册操作，如图5-3所示。
图5-3用户注册界面图
5.2管理员功能模块 管理员登录进入江西婺源旅游文化推广系统可以查看首页、个人中心、用户管理、 旅游景点管理、景点美食管理、景点类型管理、美食类型管理、景点攻略管理、景点资讯管理、用户交流、系统管理、订单管理等信息进行相应操作，如图5-4所示。
图5-4管理员功能界面图
用户管理，在用户管理页面中可以对索引、账号、姓名、年龄、性别、手机、照片等内容，进行详情或删除等操作；如图5-5所示。
图5-5用户管理界面图
旅游景点管理；在旅游景点管理页面中可以对索引、景点名称、 景点类型、景点图片、景点地址、营业时间、负责人、联系电话、价格等内容，进行详情、修改、查看评论或删除等操作；如图5-6所示。
图5-6旅游景点管理界面图
景点美食管理；在景点美食管理页面中可以对索引、美食名称、美食类型、美食图片、价格等内容，进行详情、修改、查看评论或删除等操作；如图5-7所示。
图5-7景点美食管理界面图
景点类型管理：在景点类型管理页面中可以对索引、景点类型等内容，进行修改或删除等操作；如图5-8所示。
图5-8景点类型管理界面图
美食类型管理：在美食类型管理页面中可以对索引、美食类型等内容，进行修改或删除等操作；如图5-9所示。
图5-9美食类型管理界面图
景点攻略管理；在景点攻略管理页面中可以对索引、攻略标题、景点名称、出发城市、行程天数、行程距离、交通工具、景点封等内容，进行详情、修改、查看评论或删除等操作；如图5-10所示。
图5-10景点攻略管理界面图
景点资讯管理；在景点资讯管理页面中可以对索引、标题、发布时间、封面等内容，进行详情、修改或删除等操作；如图5-11所示。
图5-11景点资讯管理界面图
用户交流：在用户交流页面中可以对索引、帖子标题、用户名、状态等内容，进行详情、修改或删除等操作；如图5-12所示。
图5-12用户交流界面图
订单管理；在订单管理页面中可以对索引、订单编号、商品名称、商品图片、购买数量、价格/积分、折扣/价格、总价格/总价格、折扣总价格、支付类型、状态、地址、电话、收货人等内容，进行详细的操作；如图5-13所示。
图5-13订单管理界面图
5.3用户功能模块 用户；在用户页面中可以查看首页、个人中心、我的收藏管理等内容；如图5-14所示。
图5-14用户功能界面图
我的收藏管理；在我的收藏管理页面中可以对索引、收藏图片、收藏名称等内容，进行详细的操作；如图5-15所示。
图5-15我的收藏管理界面图
Python-Django毕设帮助，指导，源码获取������������������，调试部署 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d11bb79e03cc9212f6204b9c1d2adb7e/" rel="bookmark">
			Java 跳出For循环总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 8 之前终止单层For循环 功能代码：
// break 终止循环 for (int i=0; i&lt; 10; i++){ if(i == 5) { break; } System.out.println("当前 i值为:" + i); } System.out.println("--------------------------"); // continue 跳出当前循环,执行下一个循环 for (int j=0; j&lt; 10; j++){ if(j == 5) { continue; } System.out.println("当前 j值为:" + j); } System.out.println("--------------------------"); 控制台输出：
当前 i值为:0 当前 i值为:1 当前 i值为:2 当前 i值为:3 当前 i值为:4 -------------------------- 当前 j值为:0 当前 j值为:1 当前 j值为:2 当前 j值为:3 当前 j值为:4 当前 j值为:6 当前 j值为:7 当前 j值为:8 当前 j值为:9 -------------------------- Java 关键字break 和continue 总结： break语句可以跳出当前循环；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d11bb79e03cc9212f6204b9c1d2adb7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11886e4807fb9b4ba8bc7035df6aa6a8/" rel="bookmark">
			Winform使用DataBinding实现数据绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的项目界面多个地方使用到模型的同一个属性，不使用数据绑定功能时，每当添加或修改一些功能时，都要手动赋值更新界面，总是担心哪里漏掉没有更新。
使用DataBinding可以实现自动绑定，当模型数据改变时，界面上绑定了模型属性的控件将自动更新，不需要手动一一赋值。
代码如下（注意代码中用的是Form2不是Form1）：
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; using System.Runtime.CompilerServices; namespace WindowsFormsApplication1 { public partial class Form2 : Form { public Form2() { InitializeComponent(); } Test test; private void Form2_Load(object sender, EventArgs e) { test=new Test(); label1.DataBindings.Add("Text", test, "Str"); label2.DataBindings.Add("Text", test, "Str"); label3.DataBindings.Add("Text", test, "Str"); } private void textBox1_TextChanged(object sender, EventArgs e) { test.Str = textBox1.Text; } } //要使用绑定数据功能，需要模型支持INotifyPropertyChanged接口 public class Test : INotifyPropertyChanged { string _str; public string Str { get { return _str; } set { _str = value; FireStrChanged(); } } //必须实现INotifyPropertyChanged接口的此事件 public event PropertyChangedEventHandler PropertyChanged; //要在.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11886e4807fb9b4ba8bc7035df6aa6a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ddb578ec48b137d0fd26ff1975b5740/" rel="bookmark">
			Few-shot Daily 2023/01/13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号：皮皮嬉
Few-shot相关
1st Place Solution for ECCV 2022 OOD-CV Challenge Image Classification Track
海康威视研究院、北京大学、浙江大学
https://arxiv.org/pdf/2301.04795.pdf
OOD-CV挑战是一种分布外泛化out-of-distribution generalization任务。在这一挑战中，我们的核心解决方案可以概括为:噪声标签学习是一个强大的测试时域自适应优化器。简而言之，主要流程可以分为两个阶段，用于域泛化的预训练阶段和用于域自适应的测试时训练阶段。在预训练阶段只利用有标签的源数据，在测试时训练阶段只利用无标签的目标数据。在预训练阶段，提出一种简单有效的掩码级复制粘贴数据增强策略，以增强分布外泛化能力，以抵抗这一挑战中的形状、姿态、上下文、纹理、遮挡和天气域变化。在测试训练阶段，利用预训练模型为未标记的目标数据分配噪声标记，并提出一种标记周期性更新的DivideMix方法进行噪声标记学习。在集成测试时增强和模型集成策略后，该解决方案在OOD-CV挑战赛的图像分类排行榜上排名第一。
1st Place Solution for ECCV 2022 OOD-CV Challenge Object Detection Track
海康威视研究院、浙江大学
https://arxiv.org/pdf/2301.04796.pdf
OOD-CV挑战是一种分布外泛化out-of-distribution generalization任务。为了解决目标检测跟踪中的这一问题，本文提出了一种简单有效的先泛化再适应(general-then-adapt, G&amp;A)框架，该框架由两阶段域泛化和一阶段域适应组成。域泛化部分由一个监督模型预训练Supervised Model Pretraining阶段和一个弱半监督模型预训练Weakly Semi-Supervised Model Pretraining阶段实现，前者使用源数据进行模型预热，后者使用具有box-level标签的源数据和具有image-level标签的辅助数据(ImageNet-1K)进行性能提升。域适应部分以无源域适应Source-Free Domain Adaptation范式实现，仅使用预训练模型和未标记目标数据以自监督训练方式进一步优化。所提出的G&amp;A框架帮助我们在OOD-CV挑战赛的目标检测排行榜上取得第一名。
HyperDomainNet: Universal Domain Adaptation for Generative Adversarial Networks
NeurIPS 2022
俄罗斯国家研究型高等经济大学、莫斯科物理技术学院
https://arxiv.org/pdf/2210.08884.pdf
https://github.com/MACderRu/HyperDomainNet
GANs领域自适应框架作为在非常有限的训练数据情况下训练GANs的主要成功方法，近年来取得了巨大的进展。本文通过提出一个极其紧凑的参数空间来微调生成器，显著改进了这一框架。本文提出一种新的域调制技术，只允许优化6000维向量，而不是StyleGAN2的3000万个权重，以适应目标域。我们将这种参数化应用于最先进的域适应方法，并表明它与完整的参数空间具有几乎相同的表现力。我们提出了一种新的正则化损失，大大增强了微调生成器的多样性。受优化参数空间规模缩小的启发，我们考虑了GANs的多域自适应问题，即根据输入query设置同一模型何时可以适应多个域。本文提出HyperDomainNet，这是一种超网络，可以根据目标域预测我们的参数化。经验证实，它可以成功地一次学习多个域，甚至可以泛化到未见过的域。
Boosting Out-of-Distribution Detection with Multiple Pre-trained Models
武汉大学、北京师范大学、华为诺亚方舟实验室
https://arxiv.org/pdf/2212.12720.pdf
分布外检测Out-of-Distribution (OOD) detection，即识别输入是否是从训练分布以外的新分布采样的，是在开放世界中安全部署机器学习系统的一项关键任务。最近，利用预训练模型的事后检测post hoc detection显示出了良好的性能，并且可以扩展到大规模问题。这一进步提出了一个自然的问题:我们能否利用多个预训练模型的多样性来提高事后检测方法的性能?本文提出一种检测增强方法，通过集成来自预训练模型的多个检测决策。该方法使用p-value而不是常用的硬阈值，并利用多假设检验的基本框架来控制分布内(ID)数据的真阳性率true positive rate。专注于model zoos的使用，并在各种OOD检测基准上与当前最先进的方法进行了系统的经验比较。与单模型检测器相比，所提出的集成方案显示了持续的改进，并显著优于当前竞争的方法。所提出方法在CIFAR10和ImageNet基准上的相对性能提高了65.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ddb578ec48b137d0fd26ff1975b5740/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00f936978237b6d5dec0b91d21095661/" rel="bookmark">
			如何搭建pytorch环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何搭建pytorch环境 1.conda创建虚拟环境pytorch_gpu2.切换到pytorch环境3.安装几个常用库（也可暂时不安）4.安装pytorch4.1进入官网查看要下载的版本4.2 根据系 统信息及cuda版本选择对应toolkit4.3复制上图中最后一行代码到pytorch环境终端4.4 验证pytorch是否安装成功4.5 如何查看自己电脑cuda版本4.5.1 windows如何查看4.5.2 linux如何查看 2022年4月27日更新 1.conda创建虚拟环境pytorch_gpu conda create -n pytorch_gpu python=3.6 创建虚拟环境还是相对较快的，它会自动为本环境安装一些基本的库，等待时间无需很长，成功之后界面如下所示：
2.切换到pytorch环境 使用如下命令，切换到我们刚刚创建好的pytorch虚拟环境，这样我们避免与其它python环境之间的干扰。
conda activate pytorch_gpu 切换成功之后就会看到在路径前边显示我们已经进入该虚拟环境。
3.安装几个常用库（也可暂时不安） conda install pandas jupyter notebook 4.安装pytorch 4.1进入官网查看要下载的版本 查看对应的版本，这里是官方链接：
4.2 根据系 统信息及cuda版本选择对应toolkit 这里最主要的是那个CUDA的版本，此处我选择的是10.1，是因为我的电脑的 cuda版本信息就是这样的。具体的查看方法可在4.5节查阅。
4.3复制上图中最后一行代码到pytorch环境终端 conda install pytorch torchvision cudatoolkit=10.1 -c pytorch 这里是下载过程截图：
但是在下载过程中torchvision以及pytorch没有下载成功，
因为这是去其官网下载，下载速度很慢，在上图中我们也可以看出是因为网络错误,网络上也有几种其他的方法，此处我没去验证，我还是让电脑重新下载的，等待时间挺长的，但是因为是在晚上下载的，一早起来就好了
4.4 验证pytorch是否安装成功 此时直接输入 python，即可成功进入：
而后输入如下指令，查看torch是否安装成功
&gt;&gt;&gt; import torch &gt;&gt;&gt; x=torch.randn(4,4) &gt;&gt;&gt; print(x) 正常情况下是出现这个界面的：
验证完成之后，可以quit()保存退出。
4.5 如何查看自己电脑cuda版本 4.5.1 windows如何查看 NVDIA控制面板–&gt;帮助–&gt;系统信息
组件–&gt;NVCUDA.DLL 可以查看CUDA版本
这里我的显示是10.1,所以我上边下载的版本也是10.1的，这里的版本要对应上，否则会出现问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00f936978237b6d5dec0b91d21095661/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f7f0053f9b682bcb26db356d7583f4a/" rel="bookmark">
			数据结构|以第一个元素为分界线（基准），将所有小于等于它的元素移到该基准的前面，将大于它的移到该基准的后面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：
有一个顺序表L，假设元素类型ElemType为整型，以第一个元素为分界线（基准），将所有小于等于它的元素移到该基准的前面，将大于它的移到该基准的后面。
思路：
可以从顺序表的两端开始扫描，左边扫描到小于等于基准则跳过不移动，大于基准的则与当前右边下标为j的交换，右边扫描到大于基准则跳过不移动，小于等于基准的则与当前左边下标为i的交换。
以下用了两种方法来做这题，这两种方法的时间复杂度都是O(n),空间复杂度是O(1),但使用方法二会更好，因为第2个算法中移动元素的次数更少
代码：
法1：
void Move(seqlist*&amp; L) { //第一个元素 int r = L-&gt;data[0]; //将后面的元素从两端扫描进行排序 int i = 1, j = L-&gt;length - 1; while (i&lt;j) { while (i&lt;j&amp;&amp;L-&gt;data[j]&gt;r) { //右边元素大于r则跳过，查找下一个 j--; } while (i&lt;j&amp;&amp;L-&gt;data[i]&lt;=r) { //左边元素小于等于r则跳过，查找下一个 i++; } //不符合上面两种情况则交换 if (i &lt; j) { swap(L-&gt;data[i], L-&gt;data[j]); } } //最后交换r和第i处的数值 swap(L-&gt;data[0], L-&gt;data[i]); } 法2：
void Move(seqlist*&amp; L) { //第一个元素 int r = L-&gt;data[0]; //将后面的元素从两端扫描进行排序 int i = 1, j = L-&gt;length - 1; while (i&lt;j) { while (i&lt;j &amp;&amp; L-&gt;data[j]&gt;r) { j--; } L-&gt;data[i] = L-&gt;data[j]; while (i &lt; j &amp;&amp; L-&gt;data[i] &lt;= r) { i++; } L-&gt;data[j] = L-&gt;data[i]; } L-&gt;data[i] = r; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5009f48abaa42b0d36c486403e0ece22/" rel="bookmark">
			JAVA各种加密与解密方式（精挑版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.BASE64加密/解密
2.MD5(Message Digest Algorithm)加密
3.DES(Data Encryption Standard)对称加密
4.AES(Advanced Encryption Standard)加密/解密
5.HMAC (Hash Message Authentication Code)散列消息鉴别码
6.恺撒加密
7.SHA(Secure Hash Algorithm)安全散列算法
8.RSA加密/解密
9.PBE加密/解密
1.BASE64加密/解密
Base64 编码是我们程序开发中经常使用到的编码方法，它用 64 个可打印字符来表示二进制数据。这 64 个字符是：小写字母 a-z、大写字母 A-Z、数字 0-9、符号"+“、”/“（再加上作为垫字的”="，实际上是 65 个字符），其他所有符号都转换成这个字符集中的字符。Base64 编码通常用作存储、传输一些二进制数据编码方法，所以说它本质上是一种将二进制数据转成文本数据的方案。
通常用作对二进制数据进行加密，示例：
import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; public class Base64Util { /*** * BASE64解密 * @param key * @return * @throws Exception */ public static byte[] decryBASE64(String key) throws Exception{ return (new BASE64Decoder()).decodeBuffer(key); } /*** * BASE64加密 * @param key * @return * @throws Exception */ public static String encryptBASE64(byte[] key) throws Exception{ return (new BASE64Encoder()).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5009f48abaa42b0d36c486403e0ece22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b54ecc5f967475505441821e1bbbd540/" rel="bookmark">
			ESP8266入门教程12：自动配网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载第三方库WiFiManager到lib文件夹
​git clone https://github.com/tzapu/WiFiManager.git
一、代码解析 第2行：包含WiFiManager库的头文件
第12行：创建WiFiManager对象
第14行：配置自动配网热点名称
二、自动配网 1、编译并上传固件，然后使用手机连接名称叫做“ESP8266-Auto”的WIFI热点
2、点击【Configure WiFi】开始配网，选择需要连接的WIFI热点名称，输入密码进行连接
​​​​​​​ 3、连接成功后会自动退出配置界面
4、按下ESP8266的复位键，即可看到WIFI连接成功的打印信息
三、完整代码 #include &lt;Arduino.h&gt; #include "../lib/WiFiManager/WiFiManager.h" void setup() { // put your setup code here, to run once: // 设置波特率 Serial.begin(9600); Serial.println(); // 创建WIFI管理器 WiFiManager wifiManager; // 自动连接 wifiManager.autoConnect("ESP8266-Auto"); // 打印WIFI信息 Serial.println("WIFI名称: " + WiFi.SSID()); Serial.println("IP地址: " + WiFi.localIP().toString()); } void loop() { // put your main code here, to run repeatedly: } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7519e27f38cfc0e5ff38d80ea4c0b3fc/" rel="bookmark">
			【JavaSE初阶篇】：系统环境变量path|classpath|JAVA_HOME
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 环境变量是为了 “在命令行窗口下”编译和运行Java程序而配置
一、系统变量：Path path环境变量作用： 将命令所在的路径配置到path中去，就相当于在计算机中“注册”了一样，以后找这个命令，会直接去你配置的路径下寻找。 达到了一个效果： 在任意的路径下去执行某个命令---》path环境针对整个操作系统而言 。 1、javac.exe编译java文件命令 ，java 执行class字节码文件命令 ，将其所在的路径jdk的bin目录 配置到 环境变量path中去，这样我就可以在任意的路径下去执行这两个命令，没有配置的话则只能在bin目录下才能运行，否则是找不到的：
2、配置好环境变量以后发现代码可以成功编译
3、接着进行解释/翻译/执行:
二、系统变量：classpath 系统有一个环境变量叫：classpath，现在我们将classpath环境变量显式的写出来：
默认值是.\ ，表示在当前目录路径，虚拟机在寻找.class文件的时候会在当前路径下进行搜索。即使配置中没有这个变量，实际上是存在的。 classpath作用：只要你配置到classpath中的路径，在执行java的字节码文件的时候，就会去这个配置的路径下找 对应的字节码文件：
配置了需要执行的字节码文件路径，可以在任意的路径下去执行字节码文件
总结： classpath作用：针对java执行字节码文件而产生的环境变量，只要配置了字节码文件所在的路径以后，那么以后你在任意位置都可以执行对应的字节码文件 在CLASSPATH环境变量当中配置了”.”之后，我们通常还会把JDK安装路径下的lib文件夹下的dt.jar和tools.jar这两个文件的位置也加入到CLASSPATH环境变量中，这又是为什么呢？就是因为这两个jar文件是JDK是提供给我们的两个基础类库。dt.jar是关于运行环境的类库，而tools.jar是工具类库。没有这两个类库支持，很多Java程序压根就无法运行，所以我们在配置环境变量的时候，要把它们的路径也加入到CLASSPATH当中，以确保程序能够正确的调用到基础类库中的类。 注意： 从JDK1.5开始，Java运行时环境(JRE)有了自动搜索当前文件夹下.class文件，并自动加载dt.jar和tools.jar类库文件的功能，所以， 从JDK1.5开始，可以不用配置CLASSPATH环境变量了 ！ 三、系统变量：JAVA_HOME tomcat，在执行startup.bat的时候会出现闪退问题： 解决： 必须要配置一个环境变量叫：JAVA_HOME 补充： 前面提到的path环境变量中刚好可以借助JAVA_HOME里面的内容，通过%%做引入 %JAVA_HOME%\bin JAVA_HOME环境变量当中配置的是JDK的安装路径，并且我们会在配置Path和CLASSPATH的时候，用%JAVA_HOME%去代替这两个环境变量中的JDK安装路径。这么做有两个好处：
首先，当我们重新安装了JDK或者是JDK升级之后，JDK的安装路径都会发生变化。在这种情况下，如果我们配置了JAVA_HOME环境变量，我们就可以只修改JAVA_HOME当中JDK的安装路径，而Path和CLASSPATH中涉及到的JDK的安装路径因为用%JAVA_HOME%代替了，所以不需要做任何修改，这样就减少了工作量和出错的概率。 其次，某些集成开发环境(IDE)和Java Web服务器会以JAVA_HOME环境变量的值去寻找JDK的安装路径。所以，如果我们希望在实际开过程中减少遇到莫名其妙问题的概率，应该添加一个JAVA_HOME环境变量，并且在Path和CLASSPATH中用%JAVA_HOME%去代替JDK安装的路径。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d359fc8bf9f6e84322dddbe45ce4d983/" rel="bookmark">
			矫正Linux 时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 获取 Linux 的 本地时间
timedatectl 发现 Local time和当前时间不同
下载 ntpdate
sudo yum install ntpdate 同步时间
sudo yum install ntpdate 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be70f7e7ea0ef28379d5d05f24777a54/" rel="bookmark">
			K8s部署前后端分离项目（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K8s部署前后端分离项目
环境准备
K8s环境
主节点master：192.168.3.200
子节点node1：192.168.3.201
子节点node2：192.168.3.202
Harbor远程仓库
已部署在master主节点上，目录为：cd /workspace/harbor/harbor
1、登录地址
http://192.168.3.200
输入用户名密码登录，初始用户名为admin,密码为Harbor12345，如下图所示：
密码配置在【harbor.cfg】配置文件中的【harbor_admin_password】属性。
Harbor.cfg目录：/workspace/harbor/harbor/harbor.cfg
2、查看harbor服务状态:
docker-compose ps
上图State属性全为【up】表示Harbor服务正常运行。如果未正常运行，则重启Harbor即可。
3、重启harbor
docker-compose restart
注意：Harbor所有命令需要在Harbor部署目录下执行。
部署前后端分离项目
生成前端vue镜像（所有子节点操作）
1、打包dist包
1、前端打包获得dist.zip包
2、上传到子节点服务器上自选目录，当前目录为：/home/docker/nginx/
上传方法：当前目录下输入【rz】后选择本地dist.zip文件后
3、上传到服务器成功后，解压dist.zip，命令为：unzip dist.zip
得到dist文件夹。
2、生成default.conf文件
在dist同目录下生成default.conf文件，
命令为：sudo vim default.conf
文件内容如下：
server {
listen 9000;
server_name localhost;
location /DLHYXT/dsmMgr { root /BJ/; proxy_set_header Host $host; try_files $uri $uri/ /DLHYXT/dsmMgr/index.html $uri/ =404; index index.html index.htm; } location /api/v1/note { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header x-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be70f7e7ea0ef28379d5d05f24777a54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f6c37e643c4b8fbc03cbdb9aff669d/" rel="bookmark">
			nginx 配置监听多个端口有什么问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx 可以通过配置文件监听多个端口。在配置文件中使用 "listen" 指令来设置监听端口。在多个 "listen" 指令中使用不同的端口号即可实现监听多个端口。这种方式可以让 Nginx 同时支持 HTTP 和 HTTPS 协议。
在配置多个端口时，需要注意的是，如果有多个端口监听同一协议，Nginx 会将请求随机分配到这些端口中的一个上。因此，如果需要为每个端口分配不同的虚拟主机，需要使用不同的 server 块来配置。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a393313cd438b68345cf23a058b713/" rel="bookmark">
			二叉树非递归实现前中后序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章主要是介绍了二叉树,用递归的方法实现了二叉树的一些基本操作,这篇文章主要是去补一下前面的内容
判断一个树是不是完全二叉树 //判断一个树是不是完全二叉树 public boolean icCompileteTree(TreeNode root){ if (root == null){ return true; } Queue&lt;TreeNode&gt; qu = new LinkedList&lt;&gt;(); qu.offer(root); while (!qu.isEmpty()){//如果队列不为空 TreeNode cur = qu.poll(); if (cur != null){ qu.offer(root.left); qu.offer(root.right); }else { break; } } //判断队列剩下的值有没有空 while (!qu.isEmpty()){ TreeNode top = qu.poll(); if (top != null){ return false; } } return true; } 完全二叉树,就是判断整个二叉树在节点上面判断整个节点的左子树是否存在,在遍历的时候不能有空的
前序遍历二叉树 //非递归实现前序遍历 public List&lt;Character&gt; preorderTraversalNor(TreeNode root) { List&lt;Character&gt; list = new ArrayList&lt;&gt;(); if (root == null) { return list; } Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode cur = root; while (cur !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4a393313cd438b68345cf23a058b713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/420bb72a439f1d935ee05d7fd5dccf8e/" rel="bookmark">
			ansible 安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 简介2. 安装2.1 yum 安装2.2 Python 安装 3. 帮助 1. 简介 Ansible 是简单的开源 IT 引擎，可自动执行应用程序部署、内部服务编排、云配置和许多其他 IT 工具。
Ansible 易于部署，因为它不使用任何代理或自定义安全基础设施。
Ansible 使用 playbook 来描述自动化作业，而 playbook 使用非常简单的语言即YAML（这是一种人类可读的数据序列化语言，通常用于配置文件，但可以用于存储数据的许多应用程序）这非常容易供人类理解、阅读和书写。因此，优势在于即使是 IT 基础设施支持人员也可以阅读和理解剧本，并在需要时进行调试（YAML——它是人类可读的形式）。
Ansible 专为多层部署而设计。Ansible 不会一次管理一个系统，它通过描述所有相互关联的系统来建模 IT 基础设施。Ansible 是完全无代理的，这意味着 Ansible 通过 ssh（默认情况下）连接您的节点来工作。但是，如果您想要其他连接方法（如 Kerberos），Ansible 会为您提供该选项。
连接到您的节点后，Ansible 会推送称为“Ansible 模块”的小程序。Ansible 在您的节点上运行该模块，并在完成后将其删除。Ansible 在简单的文本文件中管理您的库存（这些是主机文件）。Ansible 使用 hosts 文件，可以在其中对主机进行分组，并可以控制 playbook 中特定组的操作。
2. 安装 2.1 yum 安装 以下 centos 或 redhat 安装
配置 yum 源：
cat &lt;&lt;eof&gt;&gt;/etc/yum.repos.d/my.repo [epel] name=epel baseurl=http://mirrors.aliyun.com/epel/7Server/x86_64/ enable=1 gpgcheck=0 eof yum list ansible --showduplicates | sort -r yum -y install ansible 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/420bb72a439f1d935ee05d7fd5dccf8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e8f0bf92f874351bb814805b67b274/" rel="bookmark">
			IDEA报错 method ‘void ＜init＞()‘ not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现问题的原因： IDEA与Maven版本不匹配，有可能是Maven版本过高导致的。
出现这个问题原因是因为配置了自己安装的maven仓库。IDEA默认匹配了对应版本的MAVEN仓库。如下图：
为什么不使用IDEA自带的MAVEN？ 是因为自带的maven连接的是外网，我们请求外网连接不稳定，所以会配置使用阿里云的仓库地址。
可以通过这张图找到对应Maven的版本，我的对应的是3.8.1去官网下载对应的版本进行配置即可。
附赠所有的maven历史版本下载地址：maven所有历史版本
转载地址：IDEA报错 method ‘void ＜init＞()‘ not found
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d89bda77b80aaf19cb7c2b6951f502c/" rel="bookmark">
			js案例练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=., initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="" alt="" /&gt; &lt;img src="" alt="" /&gt; &lt;img src="" alt="" /&gt; &lt;img src="" alt="" /&gt; &lt;img src="" alt="" /&gt; &lt;script&gt; let imgArr = [ "./images/1.webp", "./images/2.webp", "./images/3.webp", "./images/4.webp", "./images/5.webp", ]; let imgList = document.querySelectorAll('img'); //伪数组是不能直接设置src的，必须拿到每一项才能设置 for (let i = 0; i &lt; imgList.length; i++) { imgList[i].src = imgArr[i]; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d89bda77b80aaf19cb7c2b6951f502c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f233295b2fd81e7596abf0ada478535/" rel="bookmark">
			4.R语言【rehsape2包】介绍、melt( )、cast( )函数、其他使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		b站课程视频链接：
https://www.bilibili.com/video/BV19x411X7C6?p=1
腾讯课堂(最新，但是要花钱，我花99😢😢元买了，感觉讲的没问题，就是知识点结构有点乱，有点废话）：
https://ke.qq.com/course/3707827#term_id=103855009
本笔记前面的笔记参照b站视频，【后面的画图】参考了付费视频
笔记顺序做了些调整【个人感觉逻辑顺畅】，并删掉一些不重要的内容，以及补充了个人理解
系列笔记目录【持续更新】：https://blog.csdn.net/weixin_42214698/category_11393896.html
文章目录 1. rehsape2包介绍2. 使用前必须准备的工作2.1 melt函数：宽数据——&gt;长数据2.1 cast函数：长数据——&gt;宽数据① dcast( )函数② acast()函数 3. 其他函数3.1 `add_margins()`函数3.2 `recast ()`函数3.3 `melt_check()`函数3.4 `colsplit()`函数 1. rehsape2包介绍 reshape2包是由Hadley Wickham开发的一个R包，从其命名不难看出，reshape2包可以对数据重塑，就像炼铁一样，先融化数据，再重新整合数据，它的主要功能函数为cast()和melt()，实现了长数据格式与宽数据格式之间的相互转换。
比如说，如果你要做回归等等的多变量分析，用到glm等等，那必然要用宽格式数据；
再比如说，如果你要到ggplot里面画图，按照Hadley大神的可视化语法思想，多半是要用长格式的数据的。
宽数据格式：每个变量单独成一列。
长数据格式：变量ID没有单独成列，而是整合在同一列
代码：
airquality
names(airquality) &lt;- tolower(names(airquality))
aql &lt;- melt(airquality, id.vars = c(“month”, “day”))
View(aql)
2. 使用前必须准备的工作 # 安装 install.packages("reshape2") # 导入 library(reshape2) #reshape2包的学习主要以官方推荐的空气质量数据集(airquality)为例 使用前必须要将列名变成小写，否则后面会报错 names(airquality) &lt;- tolower(names(airquality)) 2.1 melt函数：宽数据——&gt;长数据 官方介绍
从官方文档可以看出，melt()函数可以将一个对象“融化”为一个数据框。
对于不同的数据结构，melt()函数有不同的用法，如：
(1) 数据框(data frame)：melt.data.frame()
(2) 数组(array)：melt.array()、melt.matrix()、melt.table()
(3) 列表(list)：melt.list()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f233295b2fd81e7596abf0ada478535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b0ae7f2d9d98c0c1884ec9cfcbc914/" rel="bookmark">
			vue中使用xlsx读取excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载安装插件 npm install xlsx or yarn add xlsx 在项目的node_modules文件夹和package.json文件中可以找到xlsx依赖
导入项目 import * as XLSX from "../../node_modules/xlsx" 获取文件对象 这里使用的h5原生文件上传项
&lt;input type="file" id="uploadExcel" multiple @change="Change" /&gt; 其中multiple属性允许上传多个文件
在选择文件的过程中，触发事件的流程是下面这样的： 首先触发的是鼠标按下事件mousedown，然后就是焦点到了input上面，然后鼠标抬起事件mouseup，触发click事件，失去焦点onblur以后弹出文件选择框，选中文件以后触发焦点focus，最后触发change事件。 其中，可以发现fileList是一个类数组，由传入的file对象组成。每个file对象包含一下属性：
打印fileList信息 let fileList = event.target.files; 属性属性值描述lastModifiedNumber表示最近一次的修改时间的时间戳lastModeifiedDateObject表示最后一次修改时间的Date对象，可以在其中调用Date对象的有关方法。name文件上传时的文件名size文件的字节大小typeString文件的MIME类型weblitRelativePath当在input上添加webkitdirectory属性时，可选文件夹，此时weblitRelativePath表示文件夹中文件的相对路径。未加时为空 创建一个FileReader实例： let reader = new FileReader(); FileReader提供了如下方法： 方法定义方法定义readAsArrayBuffer(file)按字节读取文件内容，结果用ArrayBuffer对象表示readAsBinaryString(file)按字节读取文件内容，结果为文件的二进制串readAsDataURL(file)将文件读取为DataURL，因此可以读取图片。readAsText(file, encoding)将文件读取为文本，第二个参数是文本的编码方式，默认为utf-8abort()终止文件读取操作 FileReader提供了如下 事件: 事件描述onabort当读取操作被终止时调用onerror当读取操作发生错误时调用onload当读取操作成功完成时调用onloaded当读取操作完成时调用，无论成功或失败onloadstart当读取操作开始时调用onprogress在读取数据过程中周期性调用 读取excel主要是通过以下语句实现： XLSX.read(data, { type: type }); 返回的对象 FileReader方法对应的type取值如下：
base64以base64方法读取binaryBinatyString格式(byte n is data.charCodeAt (n))stringUTF-8编码的字符串buffernodejs BufferarrayUint8Array，8位无符号数组file文件的路径(仅nodejs下支持) vue中的v-for()展示数据 演示 代码 &lt;template&gt; &lt;div class="container"&gt; &lt;div class="header"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b0ae7f2d9d98c0c1884ec9cfcbc914/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eeb7a586a85f4e0873ba9d2c9104ecd/" rel="bookmark">
			laya3.0怎么打开vscode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 VSCode 中打开 Laya3.0，需要先安装 LayaAir 引擎插件，然后才能打开 Laya 项目。
首先打开 VSCode。点击 "扩展" 按钮，或者在菜单栏中选择 "扩展" - "打开扩展"。在扩展搜索框中输入 "LayaAir"。选择 "LayaAir" 插件，然后点击 "安装" 按钮。安装完成后，重启 VSCode。选择文件-&gt;新建-&gt;项目，会弹出layaAir的项目模板，选择一个，然后点击下一步就可以创建一个Laya项目了现在你就可以在 VSCode 中打开 Laya3.0 项目了 注意: LayaAir引擎插件需
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f02f9e35cb01ac8d0cb94037e90a448/" rel="bookmark">
			uni-app生成二维码（Qrcode）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view class="order-detail"&gt; &lt;view class="img-box"&gt; &lt;canvas v-if="isShowCode" canvas-id="qrcode" style="width: 160px;height: 160px;position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);"/&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; const app = getApp() import uQRCode from '@/static/js/uqrcode.js' export default { components: { }, data() { return { } }, onLoad(options) { this.generateCodeFn() }, onShow() { }, methods: { generateCodeFn(id){ uQRCode.make({ canvasId: 'qrcode', componentInstance: this, text: id, size: 160, margin: 0, backgroundColor: '#ffffff', foregroundColor: '#000000', fileType: 'jpg', errorCorrectLevel: uQRCode.errorCorrectLevel.H, success: res =&gt; {} }) }, }, } &lt;/script&gt; &lt;style lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f02f9e35cb01ac8d0cb94037e90a448/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1a7f71c51b07ba7edc42fc05a791f87/" rel="bookmark">
			Elasticsearch7.17 四 : ElasticSearch集群架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ElasticSearch集群架构核心概念节点分片(Primary Shard &amp; Replica Shard)集群状态和分片设定 集群搭建安装Cerebro客户端安装kibanaES安全认证集群内部安全通信开启并配置X-Pack的认证 生产环境常见集群部署方式如何对集群的容量进行规划 ElasticSearch集群架构 分布式系统的可用性与扩展性：
高可用性
服务可用性-允许有节点停止服务
数据可用性-部分节点丢失，不会丢失数据
可扩展性
请求量提升/数据的不断增长(将数据分布到所有节点上)
ES集群架构的优势：
提高系统的可用性，部分节点停止服务，整个集群的服务不受影响
存储的水平扩容
核心概念 节点 集群
一个集群可以有一个或者多个节点
不同的集群通过不同的名字来区分，默认名字“elasticsearch“
通过配置文件修改，或者在命令行中 -E cluster.name=es-cluster进行设定’
节点
节点是一个Elasticsearch的实例；本质上就是一个JAVA进程
一台机器上可以运行多个Elasticsearch进程，但是生产环境一般建议一台机器上只运行一个Elasticsearch实例
每一个节点都有名字，通过配置文件配置，或者启动时候 -E node.name=node1指定
每一个节点在启动之后，会分配一个UID，保存在data目录下
节点类型
Master Node：主节点
处理创建，删除索引等请求，负责索引的创建与删除
决定分片被分配到哪个节点
维护并且更新Cluster StateMaster eligible nodes：可以参与选举的合格节点
每个节点启动后，默认就是一个Master eligible节点，可以设置 node.master: false禁止。
Master-eligible节点可以参加选主流程，成为Master节点。
当第一个节点启动时候，它会将自己选举成Master节点Data Node：数据节点
可以保存数据的节点，叫做Data Node，负责保存分片数据。在数据扩展上起到了至关重要的作用。
通过增加数据节点可以解决数据水平扩展和解决数据单点问题Coordinating Node：协调节点
负责接受Client的请求， 将请求分发到合适的节点，最终把结果汇集到一起。
每个节点默认都起到了Coordinating Node的职责其他节点
Hot &amp; Warm Node
不同硬件配置 的Data Node,用来实现Hot &amp; Warm架构，降低集群部署的成本
Ingest Node
数据前置处理转换节点，支持pipeline管道设置，可以使用ingest对数据进行过滤、转换等操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1a7f71c51b07ba7edc42fc05a791f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c12fdb6a3c3281616bb792d67f0ddc59/" rel="bookmark">
			（已解决）javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher ar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点个关注，必回关
今天遇到一个非常奇怪的问题（数据库链接问题），如下图：
错误提示：
javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher are inappropriate 我找到了三个解决方案，我的问题已经解决，希望对您有帮助
解决方案一： 删除C:\Program Files\Java\jre\lib\security\java.security中的SSLV3(原因：JDK版本导致SSL调用权限上调，俗称：版本问题)
删除完之后在application.yml里配置数据源时添加上 &amp;useSSL=false
（亲自尝试，并未解决）
解决方法二： 下载新的JDK
如下图：
（亲自尝试，并未解决）
解决方法三： 原因：（SSH协议不支持）算法不支持当前的MySQL配置，重新配置一下
options配置信息
"-Djdk.tls.disabledAlgorithms=SSLv3, TLSv1.1, RC4, DES, MD5withRSA, DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, include jdk.disabled.namedCurves" （亲测有效）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e6311af3c674cf23b30b810e06b6fe/" rel="bookmark">
			C语言小游戏实战代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		07.绘制卡通头像 #include &lt;easyx.h&gt; #include &lt;stdio.h&gt; #define PI 3.14 int main() { initgraph(1024, 1024); // 设置背景色为白色 setbkcolor(WHITE); // 使用当前背景色清空窗体 cleardevice(); // 设置描边颜色为黑色，描边线形为实线，粗细为10 setlinecolor(BLACK); setlinestyle(PS_SOLID, 10); // 绘制头部 // 设置填充颜色为蓝色 setfillcolor(BLUE); fillellipse(118, 125, 990, 931); Sleep(1000); // 绘制脸 // 设置填充颜色为白色 setfillcolor(WHITE); fillellipse(189, 271, 919, 931); Sleep(1000); // 绘制一对眼睛 fillellipse(375, 170, 555, 420); fillellipse(555, 170, 735, 420); Sleep(1000); // 绘制一对瞳孔 setfillcolor(BLACK); solidcircle(484, 333, 25); solidcircle(617, 333, 25); Sleep(1000); // 绘制一对高光 setfillcolor(WHITE); solidcircle(484, 333, 10); solidcircle(617, 333, 10); Sleep(1000); // 绘制鼻子及竖线 setfillcolor(RED); fillcircle(554, 420, 35); line(554, 460, 554, 828); Sleep(1000); // 嘴巴 arc(320, 510, 789, 827, PI, 2 * PI); Sleep(1000); // 胡须 line(125, 313, 296, 410); line(83, 444, 270, 474); line(83, 595, 262, 527); line(819, 414, 990, 320); line(845, 478, 1029, 448); line(853, 542, 1029, 660); getchar(); closegraph(); return 0; } 09.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8e6311af3c674cf23b30b810e06b6fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f9bb618dedbf3ae5b39392d10683d6/" rel="bookmark">
			请你说说CNN，RNN，LSTM，Transformer之间的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解题思路
CNN概念：
传统意义上的多层神经网络是只有输入层、隐藏层、输出层，其中隐藏层的层数按需决定。而卷积神经网络CNN，在传统的多层神经网络基础上，全连接层前面加入了部分连接的卷积层、激活层和池化层操作，使得实际应用场景中能够构建更加深层、功能更强大的网络。
CNN优点：
CNN主要用于识别位移、缩放及其它扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以能够避免显示的特征抽取，隐式地从训练数据中进行学习。另外，CNN局部权重共享的结构可以使得网络并行学习，较好的处理高维数据，更接近于实际的生物神经网络，
CNN缺点：
（1）当网络层数太深时，采用反向传播调整内部参数会使得接近于输入层的变化较慢；（2）采用梯度下降进行迭代时很容易使得训练结果收敛于局部最优而非全局最优；
（3）池化层会丢失一定的有价值信息，忽略了局部与整体之间的关联性；
（4）特征提取的物理含义不是十分明确，导致可解释性一般。
RNN优点：
传统网络无法结合上下文去训练模型，导致对于序列特性数据场景的处理效果不佳，而RNN结构决定了其具有了短期记忆性，每一时刻隐藏层信息不仅由该时刻的输入层决定，还可以由上一时刻的隐藏层决定，做到挖掘数据张红的时序信息以及语义信息。
RNN缺点：
随着网络层数增加，RNN在长序列场景处理时会出现梯度消失或梯度爆炸的弊端（反向传播算法局限性导致）。
LSTM优点：
LSTM通过引入包含了遗忘门、输入门、输出门的cell状态的结构改善了RNN中存在的长期依赖问题，并且其表现通常比时间递归神经网络和隐马尔科夫模型更好，而LSTM本身也可以作为复杂的非线性单元构造更大型深度网络。
LSTM缺点：
梯度问题在LSTM中得到了一定程度的优化解决，但是并没有彻底搞定，在处理N量级的序列有一定效果，但是处理10N或者更长的序列依然会暴露，另外，每一个LSTM的单元节点都意味着有4个全连接层，如果时间序列跨度较大，并且网络较深，会出现计算量大和耗时偏多的问题。
Transformer优点：
（1）突破了RNN模型不能并行计算的限制；
（2）相比CNN，计算两个位置之间的关联所需要的操作次数不会随着距离的增长而增加；
（3）attention机制可以产生更具可解释性的模型，可以从模型中检查attention分布，各个attention head可以学会执行不同的任务。
Transformer缺点：
（1）局部信息的获取不如RNN和CNN强；
（2）位置信息编码存在问题，因为位置编码在语义空间中并不具备词向量的可线性变换，只是相当于人为设计的一种索引，所以并不能很好表征位置信息；
（3）由于transformer模型实际上是由残差模块和层归一化模块组合而成，并且层归一化模块位于两个残差模块之间，导致如果层数较多时连乘计算会使得顶层出现梯度消失问题。
收起解题思路
腾讯百度小米集团网易京东滴滴字节跳动薪人薪事科大讯飞顺丰集团海康威视恒生电子快手微众银行贝壳找房一加手机云从科技大宇无限
上一题
下一题
讨论区 表情
正在上传…重新上传取消
SandraWang 2022-04-15 02:54 1楼
局部和全局的关系
0 0
正在上传…重新上传取消
牛客197542472号 2022-06-07 21:13 2楼
CNN优点：局部权值共享，平移不变性可以更好提取特征以及处理高维数据；缺点：网络过深时其梯度回传变化相对于输入往往很小，出现梯度消失或爆炸的情况；解释性一般 RNN优点：相比于CNN，RNN结合序列上的时序上下文来提取特征，但是在处理序列数据时没有进行信息的过滤，在稍长序列中就会出现梯度消失、爆炸的情况 LSTM优点：LSTM经过使用全连接层设计遗忘门、输出门、输入门来过滤信息，使得在长序列数据中表现较好。但是在时间跨度非常大的序列数据中，会出现计算复杂和耗时偏多的问题 Transformer优点：相比于RNN，可以直接并行计算序列数据，计算的Attention也更有解释性，可以为不同的头分配不同的任务。虽然全局信息可以捕捉，但是不如CNN捕捉局部信息来的好，而且其位置编码的语义问题也很困扰，最后在Transformer内部堆叠残差层和BN层过多时，顶部会出现梯度消失的问题
10 0
正在上传…重新上传取消
黑VS白-晴岚 2022-07-31 16:48 3楼
CNN优点： CNN主要用于识别位移、缩放及其它扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以能够避免显示的特征抽取，隐式地从训练数据中进行学习。另外，CNN局部权重共享的结构可以使得网络并行学习，较好的处理高维数据，更接近于实际的生物神经网络， CNN缺点： （1）当网络层数太深时，采用反向传播调整内部参数会使得接近于输入层的变化较慢；（2）采用梯度下降进行迭代时很容易使得训练结果收敛于局部最优而非全局最优； （3）池化层会丢失一定的有价值信息，忽略了局部与整体之间的关联性； （4）特征提取的物理含义不是十分明确，导致可解释性一般。 RNN优点： 传统网络无法结合上下文去训练模型，导致对于序列特性数据场景的处理效果不佳，而RNN结构决定了其具有了短期记忆性，每一时刻隐藏层信息不仅由该时刻的输入层决定，还可以由上一时刻的隐藏层决定，做到挖掘数据张红的时序信息以及语义信息。 RNN缺点： 随着网络层数增加，RNN在长序列场景处理时会出现梯度消失或梯度爆炸的弊端（反向传播算法局限性导致）。 LSTM优点： LSTM通过引入包含了遗忘门、输入门、输出门的cell状态的结构改善了RNN中存在的长期依赖问题，并且其表现通常比时间递归神经网络和隐马尔科夫模型更好，而LSTM本身也可以作为复杂的非线性单元构造更大型深度网络。 LSTM缺点： 梯度问题在LSTM中得到了一定程度的优化解决，但是并没有彻底搞定，在处理N量级的序列有一定效果，但是处理10N或者更长的序列依然会暴露，另外，每一个LSTM的单元节点都意味着有4个全连接层，如果时间序列跨度较大，并且网络较深，会出现计算量大和耗时偏多的问题。 Transformer优点： （1）突破了RNN模型不能并行计算的限制； （2）相比CNN，计算两个位置之间的关联所需要的操作次数不会随着距离的增长而增加； （3）attention机制可以产生更具可解释性的模型，可以从模型中检查attention分布，各个attention head可以学会执行不同的任务。 Transformer缺点： （1）局部信息的获取不如RNN和CNN强； （2）位置信息编码存在问题，因为位置编码在语义空间中并不具备词向量的可线性变换，只是相当于人为设计的一种索引，所以并不能很好表征位置信息； （3）由于transformer模型实际上是由残差模块和层归一化模块组合而成，并且层归一化模块位于两个残差模块之间，导致如果层数较多时连乘计算会使得顶层出现梯度消失问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f9bb618dedbf3ae5b39392d10683d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a20e5c4cb1b3418b0bab359eb5fd36a7/" rel="bookmark">
			Cnpm install 项目依赖的过程中出现Package require os(darwin) not compatible...问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[fsevents@^1.0.0] optional install error: Package require os(darwin) not compatible with your platform(win32)
跟sass loader有关，运行一下命令：
cnpm rebuild node-sass
然后：
cnpm install
以上cnpm可以写成npm，cnpm只是使用了淘宝镜像，这样安装会快一些。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a64b5dd62ac2bc0abe0507b383f5855/" rel="bookmark">
			操作obs 命令行 文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 OBS (Open Broadcaster Software) 是一款开源的直播和录制软件。它可以通过命令行来操作，使用 obs-studio 命令来进行控制。
具体的命令可以通过在命令行中输入 "obs-studio --help" 查看。
一些常用的命令如下:
obs-studio --startreplaybuffer : 开始录制回放缓存obs-studio --stopreplaybuffer : 停止录制回放缓存obs-studio --startstreaming : 开始直播obs-studio --stopstreaming : 停止直播obs 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb9b33e7f001edd5a7ed11856380bc10/" rel="bookmark">
			调用libcurl实际操作以及libcurl函数介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.基本的http GET/POST操作
二.头文件和库bug解决（复习）
2.1找不到头文件如何解决
2.2找不到函数
2.3环境变量配置
三.libcurl函数介绍
3.1curl_easy_setopt函数部分选项介绍
3.2 curl_easy_perform 函数说明（error 状态码）
一.基本的http GET/POST操作 在C语言中，没有bool（布尔）这种类型，但是在C++中，把bool当做一种基本的数据类型。
在C语言中，当我们要表示真或假的时候，都是定义一个非bool类型来使用的。
在C++中，加入了布尔bool这种基础的类型，用true和false来表示真或者假，也可以用非0值来表示真，用0来表示假。在C++中，虽然布尔类型只表示true和false，看起来好像可以用一个位来存储布尔类型的变量，但其实，布尔类型在C++中是占用一个字节的。
#define ture 1 #define false 0 typedef unsigned int bool; #include &lt;stdio.h&gt; #include &lt;curl/curl.h&gt; bool getUrl(char *filename) { CURL *curl; CURLcode res; FILE *fp; if ((fp = fopen(filename, "w")) == NULL) // 返回结果用文件存储 return false; struct curl_slist *headers = NULL; headers = curl_slist_append(headers, "Accept: Agent-007"); curl = curl_easy_init(); // 初始化 if (curl) { //curl_easy_setopt(curl, CURLOPT_PROXY, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb9b33e7f001edd5a7ed11856380bc10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba73345c04a24d6a222b24dee6dcea2/" rel="bookmark">
			C语言关于冒泡排序的一些简单运用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
文章目录
前言
一、冒泡排序的思路。
二、代码实现
1.创建数组，计算数组的个数
2.创建循环变量，冒泡排序的主要代码
3.打印数组和完整代码
三、以输入的形式进行排序
1.完整代码
总结
前言 冒泡排序一般用于对一些数组，或者一组数字来进行从大到小，从小到大来进行排序。比如我们随便输入成绩，然后让我们来进行大到小来排序，然后打印输出。简单又快捷，可以试试。
一、冒泡排序的思路。 冒泡排序它在使用过程中是采取替换的方式来进行的。
比如我们有一组没有排序的数字： 4 3 2 1，我们想把它们从小到大的进行排序。
首先我们要明白下标（比如根据上边的数组： 4 3 2 1 它们的下标是： 0 1 2 3 4 ，4的下标是0，3的下标是1，下标加1我们下标指向的数字就发生改变了。4 和 3 的下标加1，下标指向的数字就是 3 和 2 了，现在3和 2下标就来到 1和 2了）这里没写数字的交换只是写了下标的改变，指向的数字也发生改变而已。
一开始的数组和下标，用下划线来表示下标 4 3 2 1没有改变4 3 2 10 1 2 3没有改变0 1 2 3 我们先拿4 和 3 进行比较，4 比 3 大然后我们交换数字，下标加1 4 3 2 14 3进行交换， 4 3 2 1变成3 4 2 13 4 2 10 1 2 3 下标加1，0 1 下标来到 1 20 1 2 3 再拿4 和 2 进行比较，4 比 2 大然后我们交换数字，下标加1 3 4 2 14 2进行交换， 3 4 2 1变成 3 2 4 13 2 4 10 1 2 3 下标加1，1 2 下标来到 2 30 1 2 3 再拿4 和 1进行比较，4 比 1 大然后我们交换数字，当4来到数组最后，我们结束这第一轮的交换。开始第二轮循环交换 3 2 4 14 1进行交换， 3 2 4 1变成 3 2 1 43 2 1 40 1 2 3下标加1，2下标来到3，3下标后面没有数字，所以不变0 1 2 3 开始第二轮的数组交换。下标又从0 和 1开始标记。开始不变 3 2 1 4不变3 2 1 40 1 2 3不变0 1 2 3 我们先拿3 和 2 进行比较，3 比 2 大然后我们交换数字，下标加1 3 2 1 43 2进行交换， 变成2 3 1 42 3 1 40 1 2 3 下标加1，0 1 下标来到 1 20 1 2 3 然后进行一轮轮的比较，交换最后我们就可以得到数组1 2 3 4。 根据上边的了解，我们再来看代码是如何实现的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ba73345c04a24d6a222b24dee6dcea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc97c193fa96a7cc3c618deaab1061ab/" rel="bookmark">
			【开源】F2FS技术拆解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		F2FS (Flash Friendly File System) 是专门针对SSD、eMMC、UFS等闪存设备设计的文件系统。由三星工程师Jaegeuk Kim于2012年10月发布到Linux社区，并于2012年12月进入Linux 3.8 内核主线。和UBIFS、JFFS2等文件系统不同，F2FS并不直接面向裸NAND闪存设计，而是和其他通用文件系统一样基于块设备层接口实现。既然如此，为什么说F2FS是针对SSD、EMMC、UFS等闪存设备设计呢？另一方面SSD、eMMC、UFS等拥有FTL（Flash Translation Layer）的闪存存储已经对外提供了通用块设备接口，是否真的需要针对性地设计一个文件系统呢？F2FS的“Flash Friendly”体现在哪些方面呢？请跟随本文对F2FS的设计实现做详细拆解，揭开F2FS与FTL“剪不断理还乱”的“爱恨交织”。
F2FS继承了日志结构文件系统的衣钵，使用异地更新的数据写入方式化随机为顺序。同时改善了日志结构文件系统的一些已知问题，如滚雪球效应和高清理开销。而FTL为了对上隐藏NAND闪存无法覆盖写的特性（先擦后写），其内部实现也采用了类似的日志结构写入方式。从软件模块化设计的角度看，两个层次的相近冗余设计似乎并不合理。然而存在即合理，F2FS实际上是摸准了FTL的软肋：那就是由于缺少上层（系统层、应用层）信息，FTL并不能很好的实现冷热分离、做到高效垃圾回收、减少写放大。同时FTL承载了太多目标：地址映射、磨损均衡、坏块管理等等，以及一些器件厂商无法言说的原因导致将FTL上移到软件层或是提供地址映射表等接口困难重重。因此即使拥有FTL，SSD、eMMC、UFS等设备也是需要一个针对性设计的文件系统来实现性能和寿命的优化。
F2FS虽然基于通用块设备层接口实现，但并不像通用文件系统一样无差别的对待机械磁盘和闪存盘，在设计上是”flash-awared”。根据闪存内部结构和闪存管理机制(FTL)，F2FS可通过多个参数配置磁盘布局、选择分配和回收单元大小从而适配不同实现的闪存存储设备。为方便理解F2FS，我们先简单介绍下FTL的地址映射方式和日志结构文件系统，然后从空间布局和索引结构入手建立F2FS的基本概念，进而深入到冷热分离、垃圾回收、块分配等细节中去。
FTL的地址映射方式 FTL(Flash Translation Layer)的本职工作是完成Host端逻辑地址到Flash侧物理地址的映射。需要地址映射的原因是闪存只能异地更新，为了对上支持数据块原地更新则需要通过地址转换实现。由于闪存先擦后写、擦写有次数限制（寿命）、使用过程中会不断出现坏块（块寿命不同）等特性，FTL还需具备垃圾回收、磨损均衡、坏块管理等十八般武艺。闪存内部的基本存储单位是Page（4KB）,N个Page组成一个Block。这里主要介绍下逻辑地址LPN（Logical Page Number）到物理地址PPN（Physical Page Number）的映射方式：
块级映射：将块映射地址分为两部分：块地址和块内偏移。映射表只保存块的映射关系，块内偏移直接对应。映射表比较小，需要内存（RAM）少。但无法很好的处理随机写，容易产生频繁的有效数据搬移和块擦除操作。
页级映射：映射表维护每个页的映射关系，这种方式灵活，能有效减少数据搬移。缺点是映射表很大（每个表项内容为PPN以4字节计算，128GB的闪存存储需要128GB/4KB*4B=128MB大小的内存保存映射表），约占存储容量的千分之一。
混合映射：主要思路是针对频繁更新的数据采用页级映射，很少更新的数据采用块级映射。其中采用Log Structed思想的混合映射将存储分为数据块（Data Block）和日志块（Log Block）。数据块用于存储数据，采用块级映射，日志块用于存储对于数据块更新后的数据，采用页级映射。混合映射是低端SSD、eMMC、UFS广泛采用的映射方式。根据日志块和数据块的对应关系又可以分为全相关映射（FAST）、块相关映射（BAST）、组相关映射（SAST）等等。下图是SAST映射的一个示例：2个日志块对应4个数据块，当日志块用完时需要通过搬移有效数据回收日志块。对于顺序写场景，最好情况下日志块对应位置记录了数据块的更新，则可以无需搬移数据，直接将日志块作为新的数据块，数据块进行擦除操作作为新的日志块。对于大量随机写场景，则需要将日志块和数据块中的有效数据搬移到空闲块的对应位置作为新的数据块，然后擦除原日志块和数据块。
图1 SAST映射数据搬移示例
日志结构文件系统 日志结构文件系统,Log Structured File System（注意：不是Journaling File System。Journaling File System是指在磁盘特定区域记录所有写入动作以便在需要时回溯和恢复，如：EXT4）思想的提出非常早，可以追溯到1992年时任UC Berkeley计算机系教授的John Ousterhout和他的学生Mendel Rosenblum发表的论文“The Design and Implementation of a Log-Structured File System”。John Ousterhout还是强大的Tcl语言（Tool Command Language，读：tickle，不是家电品牌哦）的发明者，就是下图这位白眉老爷爷。
图2 Tcl、LFS作者John Ousterhout
日志结构文件系统将所有的更改以日志式的结构连续的写入磁盘，以此加速文件写入和崩溃恢复。日志中包含索引信息，文件可以被高效的读出。为了快速的写入需要保留大块的空闲区域，可以将日志分成多个固定大小的连续空间——段（segment），在空闲区域不足时通过在碎片化的段中搬移有效数据回收新的连续空间。文章中还介绍了基于日志结构文件系统理念实现的Sprite LFS，较当时的UNIX文件系统FFS在小文件随机写上性能提升一个数量级。即使去除垃圾回收的开销，仍可以利用70%的磁盘带宽。日志结构文件系统如此优秀的写入性能不是没有代价的，如何高效的进行垃圾回收保持较高的写入性能特别是剩余空间较少、碎片化严重后的性能一直是众多日志结构文件系统致力于解决的问题。
下图展示了一个日志结构文件系统基本的索引结构和空间布局，以及数据更新方式。超级块Super Block（SB）自不必说，用于保存文件系统的基础信息。检查点Checkpoint（CP）则是指文件系统某一时点所有文件系统有效数据、索引结构一致完整的记录。创建检查点通常分两步：1.落盘所有文件数据、索引、inode表、段使用情况表，2.在固定的检查点区记录所有有效的inode表和段使用情况表地址以及时间戳等。为了应对检查点过程中的系统崩溃，实际有两个检查点区交替更新。由于时间戳是检查点最后更新的内容，每次重启后只需选择最新的检查点区即可保证有效性。在恢复到检查点后，还可根据日志记录继续前向恢复（roll-forward）数据。F2FS就针对单个文件的fsync实现了前向恢复能力，fsync时只需落盘文件数据和其直接索引。
除了超级块和检查点是保存在固定位置的，其他元数据和数据都是异地更新的日志。以更新一个文件的内容为例：先写入文件数据内容，再更新各级索引块，最后还要更新Inode Map。这种更新数据带来的索引数据更新问题被形象的称为“滚雪球效应”（英文语境中为：Wandering Tree），这也是日志结构文件系统的另一大问题。
图3日志结构文件系统索引结构和数据更新示意图
接下来的部分，我们先看F2FS如何在空间布局和索引结构上解决“滚雪球”效应，再看基于空间布局的冷热分离和垃圾回收算法如何减少回收代价以及块分配策略对碎片化后写性能的改善。
空间布局和索引结构 F2FS的空间布局在设计上试图匹配闪存存储内部的组织和管理方式。如下图所示，整个存储空间被化分为固定大小的Segment。Segment是F2FS空间管理的基本单元，也确定了文件系统元数据的初始布局。一定数量连续的Segment组成Section,一定数量连续的Section组成Zone。Section和Zone是F2FS日志写入和清理的重要单元，通过配置合适的Section大小可以极大地减少FTL层面垃圾回收的开销。
图4 F2FS空间布局
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc97c193fa96a7cc3c618deaab1061ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf7c1daf779654081192c19901a2228/" rel="bookmark">
			Aviator表达式引擎自定义可变参数函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Aviator表达式引擎自定义可变参数函数 背景 离线任务需要按表达式计算数值，需要用到求平均值Avg或统计Sum，参数可变，支持嵌套。类似以下表达式：
avg(a+b,b,sum(b,c),avg(d,e))+2 之前使用Aviator作为规则引擎来使用，轻量化和性能都能满足于是想到了使用Aviator来实现此业务。
尝试 于是看了下之前写的Aviator自定义函数，和查了一些网上的文章都是通过继承 AbstractFunction 类来实现的：
public class TestAviator { public static void main(String[] args) { // 注册函数 AviatorEvaluator.addFunction(new AddFunction()); // 执行表达式 Double result = (Double)AviatorEvaluator.execute("add(1.5, 2)") System.out.println(result ); } } class AddFunction extends AbstractFunction { @Override public AviatorObject call(Map&lt;String, Object&gt; env, AviatorObject arg1, AviatorObject arg2) { Number num1 = FunctionUtils.getNumberValue(arg1, env); Number num2 = FunctionUtils.getNumberValue(arg2, env); return new AviatorDouble(num1.doubleValue() + num2 .doubleValue()); } @Override public String getName() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adf7c1daf779654081192c19901a2228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0eace6ea9bae9e1e9e7d96f584b173ad/" rel="bookmark">
			研发k8s-web管理平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、代码编写 2、制作docker镜像 Dockerfile文件
FROM python:3.8.14 MAINTAINER LYY RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends &amp;&amp; rm -rf /var/lib/apt/lists/* WORKDIR /opt/app COPY requirements.txt ./ ENV PYTHONUNBUFFERED=1 RUN pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ COPY . . EXPOSE 8000 CMD ["python","manage.py","runserver","0.0.0.0:8000"] 查看镜像
docker images 3、运行镜像 docker run k8s-web:latest
4、获取config文件 sz .kube/config 5、登录系统 http://ip+8000
上传config文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcdb26457c70c88f7391882d5d723b0c/" rel="bookmark">
			Java实现License许可证控制(详细过程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现license控制需要准备: 1.密钥对
2.生成许可证
3.将配置代码配置到给客户部署的项目中
第一步：我们可以通过Jdk(建议jdk1.8)自带的keytool工具生成，在命令行(win+r输入cmd)输入以下命令：
#生成命令 keytool -genkeypair -keysize 1024 -validity 3650 -alias "privateKey" -keystore "privateKeys.keystore" -storepass "public_password1234" -keypass "private_password1234" -dname "CN=localhost, OU=localhost, O=localhost, L=SH, ST=SH, C=CN" 参数说明：
keysize 密钥长度validity 私钥的有效期（单位：天）alias 私钥别称keystore 指定私钥库文件的名称 (生成在当前目录)storepass 指定私钥库的密码 (keystore 文件存储密码)keypass 指定别名条目的密码 (私钥加解密密码)dname 证书个人信息 CN 为你的姓名OU 为你的组织单位名称O 为你的组织名称L 为你所在的城市名称ST 为你所在的省份名称 C 为你的国家名称 这一步可能报错：像下面这种情况（有可能是jdk过高导致的）,
那就执行这段命令(我指定了仓库类型和密钥就可以了)
keytool -genkeypair -keysize 1024 -storetype jks -keyalg DSA -validity 3650 -alias "privateKey" -keystore "privateKeys.keystore" -storepass "public_password1234" -keypass "private_password1234" -dname "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcdb26457c70c88f7391882d5d723b0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aff0b3082e24695df28ccf16f8b073a/" rel="bookmark">
			C/C&#43;&#43;中CString转char*（亲测有效，支持中文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++中经常碰到中文路径问题，或CString转成char*数组的问题，我查了很多资料，大部分都是复制粘贴的别人没用的内容，这里特把我找到真实有效的方法给出，这里面的函数都是系统函数，无需其他的头包含。也没必要再去找其他的方法，我在用，能正常使用。
char* CStringToCharArray(CString cstr) { int len = WideCharToMultiByte(CP_ACP, 0, cstr, cstr.GetLength(), NULL, 0, NULL, NULL); char* chars = new char[len + 1]; WideCharToMultiByte(CP_ACP, 0, cstr, cstr.GetLength(), chars, len, NULL, NULL); chars[len] = '\0'; return chars; } 网络上其他的转换都无法支持中文路径问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03a848e3b54a215c778dbb05d9ba3120/" rel="bookmark">
			用VSCode打开文件出现中文乱码的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 方法1：通过编码重新打开方法2：改变编码设置 在使用VScode过程中，用其他编辑器写好的文件通过VSCode打开，如果有中文，可能会有乱码现象。（可能有其他原因，多试几次找到最佳方法）
下面有两种解决办法。
方法1：通过编码重新打开 点击右下角中的“UTF-8”，选择“Reopon with Encoding（通过编码重新打开）”，输入“GB 2312”，选择“Simplified Chinese(GB 2312)”即可。
注意：这种方法只适用于当前文件，打开其他文件需要重复以上操作。
选择完后就没有乱码了。
方法2：改变编码设置 文件 --&gt; 首选项 --&gt; 设置 --&gt; 输入 " encoding " 搜索 --&gt; 找到 " Files: Encoding " --&gt; 选择GB18030
然后把文件关闭再打开，就可以看到中文不是乱码了。这种方法不用每次打开新文件都重新操作。
其他方法如：设置"files.autoGuessEncoding"、下载插件 Code Runner 试了没用。文中介绍的这两种方法有用，第二种更方便实用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5664c94db881e7822ae02860f617024c/" rel="bookmark">
			python 下载pip命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py
python get-pip.py
这就下载好了，用pip下载试试成功吗
pip install pyOpenSSL
python
import OpenSSL
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20525cc7260d2f0f1c57d48329f18fa/" rel="bookmark">
			el-table使用sortablejs实现行、列拖拽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图
代码如下
&lt;script src="//unpkg.com/sortablejs@1.7.0/Sortable.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="//unpkg.com/element-ui/lib/theme-chalk/index.css" /&gt; &lt;script src="//unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;div style="width:800px"&gt; &lt;el-table :data="tableData" border row-key="id" align="left"&gt; &lt;el-table-column v-for="(item, index) in col" :key="`col_${index}`" :prop="dropCol[index].prop" :label="item.label" &gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;pre style="text-align: left"&gt; {{tableCol}} &lt;/pre &gt; &lt;hr /&gt; &lt;pre style="text-align: left"&gt; {{tableData}} &lt;/pre &gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; new Vue({ el: '#app', data: { col: [ { label: '日期', prop: 'date', }, { label: '姓名', prop: 'name', }, { label: '地址', prop: 'address', }, ], dropCol: [ { label: '日期', prop: 'date', }, { label: '姓名', prop: 'name', }, { label: '地址', prop: 'address', }, ], tableData: [ { id: '1', date: '2016-05-02', name: '王小虎1', address: '上海市普陀区金沙江路 100 弄', }, { id: '2', date: '2016-05-04', name: '王小虎2', address: '上海市普陀区金沙江路 200 弄', }, { id: '3', date: '2016-05-01', name: '王小虎3', address: '上海市普陀区金沙江路 300 弄', }, { id: '4', date: '2016-05-03', name: '王小虎4', address: '上海市普陀区金沙江路 400 弄', }, ], }, mounted() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c20525cc7260d2f0f1c57d48329f18fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f701a0905f61b0020cfffea3a7256b/" rel="bookmark">
			vue修改el-input样式，样式穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue–element的form表单中修改el-input样式 在使用 element ui 组件过程中，我最近碰到了新的问题。
初始的界面效果是这样的：
这个效果真的不怎么好看，我想把输入框的背景色变浅，变得透明。于是我在代码中添加
.el-input{ background-color: rgba(255, 255, 255, 0.247); } 123 但是我的界面一点变化都没有。经过多种渠道我终于解决了这个问题，接下来上步骤。
1.首先，将代码运行，浏览器右键-检查 我标黄的部分是真正控制输入框样式的内部类。在案例里面我并没有设置这个类。我们可以在这个类里直接动态调整 background-color 到自己喜欢的效果。之后复制 background-color 的颜色数值。回到代码。
2.将样式的类名修改 由于这个类是el-input,的内部类，我也没有在这个案例里面给单独的 el-input ,设置类。我们就要这样设置这个 el-input__inner 的样式
.el-input.el-input__inner { background-color: rgba(255, 255, 255, 0.247); } 3.样式穿透 但是只是这样，也许还是会发现，界面不会有效果。我们这是就要做样式穿透 ， 样式穿透的方式我了解的有两种：
使用/deep/ ，两边要加空格。
使用 &gt;&gt;&gt; ，两边要加空格 。
//使用 /deep/ .el-input /deep/ .el-input__inner { background-color: rgba(255, 255, 255, 0.247); } //使用 &gt;&gt;&gt;
.el-input &gt;&gt;&gt; .el-input__inner { background-color: rgba(255, 255, 255, 0.247);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f701a0905f61b0020cfffea3a7256b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a1a2799651cb6ab7d79f33385361a01/" rel="bookmark">
			Echarts可视化图表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECharts 特性 ECharts 包含了以下特性：
丰富的可视化类型: 提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。
多种数据格式无需转换直接使用: 内置的 dataset 属性（4.0+）支持直接传入包括二维表，key-value 等多种格式的数据源，此外还支持输入 TypedArray 格式的数据。
千万数据的前端展现: 通过增量渲染技术（4.0+），配合各种细致的优化，ECharts 能够展现千万级的数据量。
移动端优化: 针对移动端交互做了细致的优化，例如移动端小屏上适于用手指在坐标系中进行缩放、平移。 PC 端也可以用鼠标在图中进行缩放（用鼠标滚轮）、平移等。
多渲染方案，跨平台使用: 支持以 Canvas、SVG（4.0+）、VML 的形式渲染图表。
深度的交互式数据探索: 提供了 图例、视觉映射、数据区域缩放、tooltip、数据刷选等开箱即用的交互组件，可以对数据进行多维度数据筛取、视图缩放、展示细节等交互操作。
多维数据的支持以及丰富的视觉编码手段: 对于传统的散点图等，传入的数据也可以是多个维度的。
动态数据: 数据的改变驱动图表展现的改变。
绚丽的特效: 针对线数据，点数据等地理数据的可视化提供了吸引眼球的特效。
通过 GL 实现更多更强大绚丽的三维可视化: 在 VR，大屏场景里实现三维的可视化效果。
无障碍访问（4.0+）: 支持自动根据图表配置项智能生成描述，使得盲人可以在朗读设备的帮助下了解图表内容，让图表可以被更多人群访问！
Echarts实例：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;第一个 ECharts 实例&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src="https://cdn.staticfile.org/echarts/4.3.0/echarts.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id="main" style="width: 600px;height:400px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a1a2799651cb6ab7d79f33385361a01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b249f7ced05e51b5e49e3a877cdcf52/" rel="bookmark">
			mybatis-plus多表联查join
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装依赖
&lt;dependency&gt; &lt;groupId&gt;com.github.yulichang&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-join&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;/dependency&gt; 2、定义三个基本实体类
2.1 User类
@Data public class User { //对应数据库的主键（uuid，自增id，雪花算法,redis，zookper） @TableId(type = IdType.AUTO) private Integer id; @NotNull(message = "名称xxx不能为空")//空校验 @NotBlank //不能为空字符串 @Size(min = 1,max = 5,message = "ssssss")//字符串长度校验 private String name; // @Min(value = 10,message = "最小值10") // @Max(value = 90,message = "最大值为99") @NotNull // @Max(value = 50,message = "超过最大值") // @Min(value = 10,message = "超过最小值") @Range(min=10,max = 99,message = "错误")//数字范围校验 private Integer age; @NotNull private String email; //逻辑删除字段 @TableLogic //逻辑删除注解 private Integer deleted; //字段添加填充内容 //策略 // @JsonFormat(pattern = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b249f7ced05e51b5e49e3a877cdcf52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca9906370c6fcd8a9528566dbb5e146/" rel="bookmark">
			数据结构：关于空间复杂度的例题计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、计算冒泡排序的空间复杂度 答案：该程序空间复杂度为O(1)。
解析：该程序在栈空间所申请的临时变量空间只有三个，也就是看成常数个，所以是O(1)。如下图所示
2、动态开辟N个数的数组空间复杂度 答案：该程序空间复杂度为O(N).
解析：因为该程序动态开辟了N+1个空间，属于O(N)这个量级，1可忽略，所以空间复杂度为O(N)。
3、计算阶乘递归的空间复杂度 答案：该程序空间复杂度为O(N)。
解析：因为每递归一次就申请一个空间，递归了N次所以申请了N个空间，所以是O(N)。
4、计算斐波那契递归的空间复杂度 答案：空间复杂度为O(N)。
解析：Fib依次申请空间，从Fib(N)申请到Fib(1)，共申请了N个空间。假设虽然Fib(N)递归一次变为Fib(N-1)和Fib(N-2)，看起来需要两个空间，可是将一个空间申请给Fib(N-1)，等返回后这个空间就会销毁，然后再将这个空间申请给Fib(2)，空间重复利用，每次递归都以此类推。所以每递归一次只需开辟一个空间，而不是每递归一次就要开辟2倍的空间。
总结 空间是可以重复利用，不累计的；
时间是一去不复还，累计的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bb75afdcffe8a664d4374e4e2d60a61/" rel="bookmark">
			C语言——用for语句循环嵌套输出＂＊＂组成的图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.【1】#include&lt;stdio.h&gt;
int main(){
int i,j,k;
for(i=1;i&lt;=8;i++)
{
for(j=1;j&lt;=i;j++)
{
printf("*"); }
for(k=20;k&gt;=2*i;k--)
{
printf(" ");
}
for(j=1;j&lt;=i;j++)
{
printf("*"); }
printf("\n"); }
return 0;
}
【2】#include&lt;stdio.h&gt;
int main(){
int i,j;
for(i=1;i&lt;=9;i++)
{
for(j=9;j&gt;=i;j--)
{
printf("*");
}
for(j=2;j&lt;=2*i+1;j++)
{
printf(" ");
}
for(j=9;j&gt;=i;j--)
{
printf("*");
}
printf("\n");
}
return 0;
}
【3】#include&lt;stdio.h&gt;
int main(){
for (int i = 0; i &lt; 4; ++i){
for (int j = 0; j &lt;= 2-i; ++j){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bb75afdcffe8a664d4374e4e2d60a61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34ce0f6d2fad6564393689a73f19fcd2/" rel="bookmark">
			程序员10个月接了30个私活单子，晒出收入，让大家意想不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现如今，相信很多职场朋友都非常羡慕程序员的高薪工作吧，很多学习计算机专业的大学生，他们在毕业以后，往往通过自己的专业就能找到互联网公司的高薪工作，而作为一名程序员，他们的工作压力还是非常大的，有时候经常熬夜加班，可是有些程序员也会在工作之余接一些私活，赚取零花钱。
近日有位程序员便在职场论坛分享了自己工作之余接私活的真实经历，他透露：10个月的时间借了30个私活单子，平均每个月能拿到两三万的收入，而这位程序员主要负责内容就是做h5和小程序，由于后期不需要维护，所以他的工作量还是相对来说要少一点。
根据程序的简易复杂程度，程序员会跟客户要不同的价格，这位程序员坦言目前不需要合作伙伴，他的目标就是想每个月赚个四五万七八万就可以了，暂时没有把私活做大的想法。
看到这位程序员透露的真实收入，也是很有感触：程序员的技术能力毋庸置疑，他们既可以通过专业技术在本职工作拿高薪，还可以在工作之余，通过兼职赚零花钱，很多程序员通过兼职实现了创业的梦想，据了解，不少程序员都是刚开始接触私活圈或者是广告圈，然后能找到几个长期合作的公司，收入稳定后再选择辞职。
所以大家在工作的时候可以有必要接触一些私活，通过私活赚零花钱提升自己的整体收入，而不是只拘泥于通过全职拿死工资。
关于Python技术储备 学好 Python 不论是就业还是做副业赚钱都不错，但要学会 Python 还是要有一个学习规划。最后大家分享一份全套的 Python 学习资料，给那些想学习 Python 的小伙伴们一点帮助！
一、Python所有方向的学习路线 Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
二、Python必备开发工具 三、精品Python学习书籍 当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
四、Python视频合集 观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
五、实战案例 光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
六、Python练习题 检查学习结果。
七、面试资料 我们学习Python必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有阿里大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。
这份完整版的Python全套学习资料已经上传CSDN，朋友们如果需要可以微信扫描下方CSDN官方认证二维码免费领取【保证100%免费】 Python资料、技术、课程、解答、咨询也可以直接点击下面名片，添加官方客服斯琪↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a014403d7a6b06e0ebd3b6ed69970ee/" rel="bookmark">
			SiteFactory编辑器支持Word文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当前功能基于PHP，其它语言流程大致相同
1.新增上传word json配置
在ueditor\php\config.json中新增如下配置：
/* 上传word配置 */
"wordActionName": "wordupload", /* 执行上传视频的action名称 */
"wordFieldName": "upfile", /* 提交的视频表单名称 */
"wordPathFormat": "/public/uploads/word/{yyyy}{mm}{dd}/{time}{rand:6}", /* 上传保存路径,可以自定义保存路径和文件名格式 */
"wordMaxSize": 102400000, /* 上传大小限制，单位B，默认100MB */
"wordAllowFiles": [".docx"] /* 仅支持docx格式的word */
2.修改编辑器配置文件，在工具栏上新增按钮
在ueditor\ueditor.config.js文件中，新增按钮名称"wordupload"，并添加鼠标悬浮提示，如下所示：
//工具栏上的所有的功能按钮和下拉框，可以在new编辑器的实例时选择自己需要的重新定义
, toolbars: [[
'fullscreen', 'source', '|', 'undo', 'redo', '|',
'bold', 'italic', 'underline', 'fontborder', 'strikethrough', 'superscript', 'subscript', 'removeformat', 'formatmatch', 'autotypeset', 'blockquote', 'pasteplain', '|', 'forecolor', 'backcolor', 'insertorderedlist', 'insertunorderedlist', 'selectall', 'cleardoc', '|',
'rowspacingtop', 'rowspacingbottom', 'lineheight', '|',
'customstyle', 'paragraph', 'fontfamily', 'fontsize', '|',
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a014403d7a6b06e0ebd3b6ed69970ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177ab63661ac7aed0198a06350d6a531/" rel="bookmark">
			vue实现动态返回顶部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;div&gt; &lt;div class="top" @click="returnTop" v-show="bool"&gt;∧&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { bool: false }; }, methods: { returnTop() { var ksHeight = document.documentElement.offsetHeight; var scrollT = document.documentElement.scrollTop || document.body.scrollTop; var scrollH = document.body.scrollHeight; if (ksHeight + scrollT &gt;= scrollH + 100) { window.scrollBy(0, -ksHeight); } }, handleScroll() { var ksHeight = document.documentElement.offsetHeight; var scrollT = document.documentElement.scrollTop || document.body.scrollTop; var scrollH = document.body.scrollHeight; if (ksHeight + scrollT &gt; scrollH) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177ab63661ac7aed0198a06350d6a531/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/190/">«</a>
	<span class="pagination__item pagination__item--current">191/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/192/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>