<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9e91427a28cab9ac20d4bea5109d012/" rel="bookmark">
			uni-app - 移动端（iOS&amp;Android）批量上传文件，支持重传、删除、多选，携带参数，进度监控
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍💻 作者简介：程序员半夏 , 一名全栈程序员，擅长使用各种编程语言和框架，如JavaScript、React、Node.js、Java、Python、Django、MySQL等.专注于大前端与后端的硬核干货分享,同时是一个随缘更新的UP主. 你可以在各个平台找到我!
🏆 本文收录于专栏: uniapp踩坑指南
🔥 专栏介绍: 本专栏提供了uni-app开发过程中必不可少的组件和解决方案。本书详细介绍了各种常用组件的使用方法和技巧，以及如何应对uniapp开发中遇到的各种问题。
文章目录 前言组件原理页面设置参数上传接口的参数设置上传设定（文件大小，数量，多选）文件选择上传状态上传成功/失败重传移除文件完整代码 前言 本文主要针对移动端（iOS和Android)。uni-app官方提供了uni.chooseFile(OBJECT)接口从本地选择选择非媒体文件。如果是图片视频的话，可以选择uni.chooseMedia(OBJECT)、uni.chooseVideo(OBJECT)、uni.chooseImage(OBJECT)等接口。
但是 uni.chooseFile(OBJECT)仅仅支持H5。
AppH5微信小程序支付宝小程序百度小程序抖音小程序、飞书小程序QQ小程序快手小程序京东小程序x√(HBuilder X2.9.9+)x(可使用wx.chooseMessageFile)xxxxxx 除了uni.chooseFile(OBJECT) 官方还提供了uni-file-picker来选择任意类型的文件上传。但是请注意该组件在移动端仍然仅支持选择图片和视频。
file-mediatypeStringimageimage/video/all选择文件类型,all 只支持 H5 和微信小程序平台 那么移动端，想要上传文件，我们该如何操作，按照官方的说法：App端如需选择非媒体文件，可在插件市场搜索文件选择，其中Android端可以使用Native.js，无需原生插件，而iOS端需要原生插件。。
这里我们选择使用插件：全文件上传选择非原生2.0版
组件原理 在生命周期mounted调用下面的代码，根据不同的平台去渲染不同的上传组件。
这段代码首先检查this.dom是否已经存在。如果不存在，根据运行环境（H5或APP-PLUS）创建一个新的input元素或webview。
在H5环境下，代码直接创建一个input元素并设置其样式、属性和事件监听器。
在APP-PLUS（移动端）环境下，使用plus.webview.create()创建一个webview并设置其样式、额外属性和数据，然后再加载了一个&lt;input :multiple="multiple" @change="onChange" :accept="accept" ref="file" class="file" type="file" /&gt;。最后，返回创建的DOM元素。
plus.webview.create()是一个用于创建Webview窗口的方法，它在uni-app的APP-PLUS环境下可用。这个方法接收四个参数：
path：要加载的HTML文件的路径，通常是一个相对路径。this.id：Webview窗口的标识，用于在后续操作中引用该窗口。styles：Webview窗口的样式设置，包括位置、尺寸、背景等属性。extras：Webview窗口的额外属性，可以在窗口创建后通过plus.webview.getWebviewById()方法获取。 在这段代码中，plus.webview.create()方法用于创建一个Webview窗口，用于处理文件选择和上传。path参数指定了Webview窗口要加载的HTML文件，this.id参数为Webview窗口分配了一个唯一标识。styles参数定义了Webview窗口的样式，例如位置、尺寸和背景颜色。extras参数包含了一些额外的属性，例如debug、instantly和prohibited，这些属性可以在Webview窗口创建后通过plus.webview.getWebviewById()方法获取。
/** * 创建File节点 * @param {string} path webview地址 */ create(path) { if (!this.dom) { // #ifdef H5 // 创建一个input元素 let dom = document.createElement('input'); // 设置input类型为file dom.type = 'file'; // 初始化input的值为空 dom.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9e91427a28cab9ac20d4bea5109d012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1207410c59b3833ac955ab12eaa0d72/" rel="bookmark">
			spring cloud config搭建报错：Caused by: org.eclipse.jgit.errors.TransportException: https://xxxx: not aut
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://www.longkui.site/error/caused-by-org-eclipse-jgit-errors-transportexception-https-xxxx-not-authorized/5957/
搭建spring cloud config服务端的时候，需要连接github(或者码云)，进行访问时页面报错：Whitelabel Error Page(status=404)
Caused by: org.eclipse.jgit.errors.TransportException: https://gitee.com/guo1635/spring-cloud-config.git: not authorized
报错截图如下：
这个错误是因为你的仓库是私有的，解决办法有两个，一个是把仓库变成共有的，另一个是在上面的配置文件中加入账号和密码，再访问接口就正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c6051ed29a4b85327a6350952965b80/" rel="bookmark">
			arcgis pro添加WGS-1984-Albers投影坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.打开arcgis pro 新建地图
2.右键地图选择属性
3.选择坐标系选项卡，单击添加坐标系按钮
4.选择自己想添加的地理坐标系或投影坐标系:以albers为例
5.添加好参数后点击保存即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54501e6d692e6d2e0601c24b5e328da2/" rel="bookmark">
			自定义hooks函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		体会1
1、js文件中定义useXX函数
export function usetestY() { const count = ref(10); const doubleCount = computed(() =&gt; count.value * 2); return { count, doubleCount, }; } 2、在vue文件中使用useXX函数
import { usetestY } from './data'; const { count, doubleCount } = usetestY(); console.log('1--', count); console.log('2--', doubleCount); 体会2
3、useAdd自定义hooks
const useAdd = ({ num1, num2 }) =&gt; { const addNum = ref(0); watch([num1, num2], ([num1, num2]) =&gt; { addFn(num1, num2); }); const addFn = (num1, num2) =&gt; { addNum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54501e6d692e6d2e0601c24b5e328da2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c53dcd73a1566da45d335369d51103a1/" rel="bookmark">
			NodeMCU ESP8266 外设的 Arduino API 接口介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NodeMCU ESP8266 外设的 Arduino API 接口介绍 文章目录 NodeMCU ESP8266 外设的 Arduino API 接口介绍前言模块中断数字IO模拟输入模拟输出延时串口 总结 前言 Arduino在硬件上做了相应的封装，新的硬件需要兼容Arduino的接口。比如NodeMCU ESP8266的底层硬件做一次封装，对用户需要开放出来规定好的接口。
下面Arduino的官方接口；
/** 地址如下： */ https://www.arduino.cc/reference/en/ 本文简单介绍一下ESP8266 Arduino Core库，相应拆分为几个常用的模块；
Interrupts：中断；Digital IO ：数字IO；Analog input：模拟输入；Analog output：模拟输出；Timing and delays：定时和延迟；Serial：串口； 下面我们进一步介绍。
模块 中断 ESP8266上使用中断，但必须谨慎使用，并且有几个限制：
中断回调函数必须位于 IRAM 中，因为它们发生时闪存可能正在执行其他操作。IRAM_ATTR通过在函数定义上添加属性来完成此操作。如果此属性不存在，则草图在尝试执行此操作时将会崩溃 attachInterrupt并显示错误消息。 IRAM_ATTR void gpio_change_handler(void *data) {... 中断不得调用delay()或yield()，或调用任何内部使用delay()的例程yield()；
中断中长时间运行（&gt;1ms）的任务会导致不稳定或崩溃。
如果中断被长时间运行的中断阻止，WiFi 和核心的其他部分可能会变得不稳定。
堆 API 操作可能很危险，应在中断中避免。
应尽量减少对 的调用malloc，因为如果内存碎片，它们可能需要很长的运行时间。
C++ 的 new和delete运算符绝不能在 ISR 中使用。他们的调用路径不在 IRAM 中。
数字IO Arduino 中的引脚编号直接对应于 ESP8266 GPIO 引脚编号。
pinMode、digitalRead、 和digitalWrite函数可以工作；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c53dcd73a1566da45d335369d51103a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1ebbabe4a4495a9854f6483d98ba873/" rel="bookmark">
			【问题处理】常见Linux安全漏洞处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 参考文章如下：
不专业的“漏洞扫描软件”，是否吓到你？
安全厂家漏洞扫描机制
近期甲方使用漏洞软件扫描网络环境下所有主机，扫描出一大堆安全漏洞，最好的处理方式当然是升级系统相关组件至最新的软件版本。
然而，整个软件系统引用了部分第三方开源组件，且操作系统官方源提供的软件版本相对陈旧，生产环境贸然升级这么多组件动作太大，与此同时，甲方使用的是内网网络环境，安全系数相对较高。
综合以上因素考虑，考虑使用以下几种方式规避安全漏洞处理：
修改服务端口号修改软件版本号或者banner信息通过防火墙封禁不相关的外部访问 二、常见漏洞处理 1、ftp服务 1.1、漏洞信息 漏洞名称
FTP服务器版本信息可被获取(CVE-1999-0614)
解决办法
建议您采取以下措施以降低威胁：
修改源代码或者配置文件改变缺省banner信息。
1.2、检测手段 使用telnet访问主机21端口，可探测到主机使用ftp软件版本（vsftpd 3.0.3）
[root@node111 ~]# telnet 172.16.21.61 21 Trying 172.16.21.61... Connected to 172.16.21.61. Escape character is '^]'. 220 (vsFTPd 3.0.3) 1.3、处理措施 处理措施有以下两种：
如不使用ftp服务，可关闭vsftpd服务，此时使用telnet连接超时 systemctl stop vsftpd systemctl disable vsftpd 如需要使用ftp服务，可尝试修改vsftpd服务banner信息，此时无法使用telnet探测到软件版本号
注：不同操作系统，软件配置文件路径有所不同（可能为/etc/vsftpd.conf或/etc/vsftpd/vsftpd.conf） echo "ftpd_banner=this is vsftpd" &gt;&gt; /etc/vsftpd.conf systemctl restart vsftpd 2、nfs服务 2.1、漏洞信息 漏洞名称
目标主机showmount -e信息泄露(CVE-1999-0554)
详细描述
可以对目标主机进行"showmount -e"操作，此操作将泄露目标主机大量敏感信息，比如目录结构。更糟糕的是，如果访问控制不严的话，攻击者有可能直接访问到目标主机上的数据。
解决办法
建议您采取以下措施以降低威胁:
限制可以获取NFS输出列表的IP和用户。
除非绝对必要，请关闭NFS服务、MOUNTD。
2.2、检测手段 使用任意一个客户端对主机IP进行showmount -e &lt;nfs-server-ip&gt;操作，可以查看到nfs共享信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1ebbabe4a4495a9854f6483d98ba873/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9d3d792604a67f29e245d3de8752bd3/" rel="bookmark">
			在小程序中获取公众号openid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在公众号里面配置域名
公众号-&gt;开发-&gt;开发管理-&gt;开发设置-&gt;业务域名
安装插件 { "dependencies": { "jweixin-module": "^1.6.0" } } npm install jweixin-module --save import wx from 'jweixin-module' Vue.prototype.$wx= wx &lt;template&gt; &lt;view class="content"&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { } }, onLoad() { }, created() { uni.showLoading({ title:'加载中...' }) }, onShow() { this.$wx.miniProgram.reLaunch({ url: `/mind/userInfo/userInfo?code=${this.geturlparam('code')}` //条转小程序页面 }) }, methods: { geturlparam(code) { let that = this let url = window.location.href let p = url.split('?')[1] let params = new URLSearchParams(p); return params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9d3d792604a67f29e245d3de8752bd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a072eb9f28d7fcb91caa4f4c44aa3d0/" rel="bookmark">
			如何新增hidl服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最好在自己的产品名下新增文件夹，创建相应的HIDL服务，假设目前要在tom下新增HIDL服务，流程如下：
1创建hidl服务文件夹test /vendor/tom/monet/interfaces/test
在test下新建1.0文件夹
在1.0下新增default文件夹
2. 新增.hal文件 在/vendor/tom/monet/interfaces/test/1.0下新增IwslTest.hal文件，内容如下
package vendor.monet.hardware.test@1.0; interface IwslTest{ test(int32_t side) generates (bool movingState); }; 3. 编译hidl-gen source build/envsetup.sh lunch xx make hidl-gen 这样后面就可以用hidl-gen工具了，
4. 配置hidl的package root LOC=vendor/tom/monet/interfaces/test/1.0/default PACKAGE=vendor.monet.hardware.test@1.0 5. 在1.0/default/下生成.cpp和.h文件 在vendor/tom/monet/interfaces/test/1.0/default下生成.cpp和.h文件：
hidl-gen -o $LOC -Lc++-impl -rvendor.monet.hardware:vendor/tom/monet/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE 然后会生成wslTest.cpp 和wslTest.h文件。生成后需要做相关修改，修改后内容如下：
#include "wslTest.h" #include &lt;android/log.h&gt; namespace vendor::monet::hardware::test::implementation { // Methods from ::vendor::monet::hardware::test::V1_0::IwslTest follow. Return&lt;bool&gt; wslTest::test(int32_t side) { // TODO implement __android_log_print(ANDROID_LOG_INFO, "simpleperf", "%s", "wslTest::test"); return bool {}; } // Methods from ::android::hidl::base::V1_0::IBase follow.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a072eb9f28d7fcb91caa4f4c44aa3d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a22c61e2da06817986db432f1ee7b41/" rel="bookmark">
			STM32F103的流水灯点亮版本1(寄存器地址操作)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、STM32简介 STM32，从字面上来理解，ST 是意法半导体，M 是 Microelectronics 的缩写，32 表示32 位，合起来理解，STM32 就是指 ST 公司开发的 32 位微控制器。在如今的 32 位控制器当中，STM32 可以说是最璀璨的新星，它受宠若娇，大受工程师和市场的青睐，无芯能出其右。
STM32 属于一个微控制器，自带了各种常用通信接口，比如 USART、I2C、SPI 等，可接非常多的传感器，可以控制很多的设备。现实生活中，我们接触到的很多电器产品都有 STM32 的身影，比如智能手环，微型四轴飞行器，平衡车、移动 POST 机，智能电饭锅，3D 打印机等等。
STM32 有很多系列，可以满足市场的各种需求，从内核上分有 Cortex-M0、M3、M4和 M7 这几种，每个内核又大概分为主流、高性能和低功耗。
二.使用通过寄存器点灯原理介绍。 (ps : stm32f1中文文档我在网上找到在这里下载的：
1.配置时钟使能。 因为流水灯要操作的引脚都是在GPIO端口的，所以根据系统结构图，属于AHB总线，所以所要用的端口的复位和时间控制都受RCC控制。
再看寄存器组起始地址表，可以看到RCC的地址范围，且可以看到要控制的寄存器都是在APB2总。
从上面发现复位和时钟控制的起始地址为0x4002 1000，
再翻到这里发下偏移量为0x18，所以该寄存器的地址为0x4002 1018
上图表格表示的寄存器里各位的含义，比如第三位也就是2那个位置为1时，就是GPIOA的时钟开启了。这时我们就可以用代码表达出来了。
接下来就是配置端口配置寄存器了，
这个就比较关键了，可以发现上面的时钟使能寄存器开启时钟是针对一个区域的，并不能确定引脚，
而这个寄存器就是确定引脚的，端口配置寄存器有两个，分别为端口配置低寄存器（CRL）和端口配置高寄存器（CRH）。
每四位配置一个端口，如11 01，11就是选择开启功能，01就是选择模式和确定最大速度，但有一点不一样，低寄存器的偏移地址为0x00，高寄存器的偏移地址为0x04。
我们翻到这里
以PA7为示例，相应端口配置器GPIOA_CRL地址为GPIOA的基址+上偏移量
在开头第二张图的那个位置可以找到GPIOA的地址为0x40010800， 低寄存器偏移如上图所示为0
以PA7口为输出口为例，就是要改变的是红色方框里的内容，
根据它下方表格里的内容得知要将他设置为推挽输出，输出模式最大速度为2MHz就是将它赋为0010,转换进制就是2（ps:我个人理解，错了的话希望大佬指正）
所以即将地址0x40010800的最前头一位赋为2,代码如下
7.接下来就是配置端口输出寄存器（ORD），可以看到偏移量为0xc，所以该寄存器的地址等于端口的基址加上偏移量，在相应的位赋值可以控制输出电压，0为低电压，1为高电压，以pa7引脚为例子，想要输出高电压，就需要在第八位赋1。
这里就可以控制led亮或者灭了，实现流水灯只需增加灯的数量和增加一些延时就行了。
三.使用C语言实现。 1.创建一个新的项目。选择自己对应的板子，注意后面需要勾选上core 以及startup
添加一个main.c并写入代码，注意项目结构，使用的引脚是PA7，PB9，PC15，同时如果灯不闪烁，程序没有正常运行，可以先试试仿真调试，仿真调试正常了一般在板子上运行就正常了
//--------------APB2使能时钟寄存器------------------------ #define RCC_AP2ENR ((unsigned volatile int)0x40021018) //----------------GPIOA配置寄存器 ------------------------ #define GPIOA_CRL ((unsigned volatile int)0x40010800) #define GPIOA_ORD ((unsigned volatile int)0x4001080C) //----------------GPIOB配置寄存器 ------------------------ #define GPIOB_CRH ((unsigned volatile int)0x40010C04) #define GPIOB_ORD ((unsigned volatile int)0x40010C0C) //----------------GPIOC配置寄存器 ------------------------ #define GPIOC_CRH ((unsigned volatile int)0x40011004) #define GPIOC_ORD ((unsigned volatile int)0x4001100C) //-------------------简单的延时函数----------------------- void Delay_ms( volatile unsigned int t) { unsigned int i; while(t--) for (i=0;i&lt;800;i++); } void A_LED_LIGHT(){ GPIOA_ORD=0x0&lt;&lt;7; //PA7低电平 GPIOB_ORD=0x1&lt;&lt;9; //PB9高电平 GPIOC_ORD=0x1&lt;&lt;15; //PC15高电平 } void B_LED_LIGHT(){ GPIOA_ORD=0x1&lt;&lt;7; //PA7高电平 GPIOB_ORD=0x0&lt;&lt;9; //PB9低电平 GPIOC_ORD=0x1&lt;&lt;15; //PC15高电平 } void C_LED_LIGHT(){ GPIOA_ORD=0x1&lt;&lt;7; //PA7高电平 GPIOB_ORD=0x1&lt;&lt;9; //PB9高电平 GPIOC_ORD=0x0&lt;&lt;15; //PC15低电平 } //------------------------主函数-------------------------- int main() { int j=100; RCC_AP2ENR|=1&lt;&lt;2; //APB2-GPIOA外设时钟使能 RCC_AP2ENR|=1&lt;&lt;3; //APB2-GPIOB外设时钟使能 RCC_AP2ENR|=1&lt;&lt;4; //APB2-GPIOC外设时钟使能 //这两行代码可以合为 RCC_APB2ENR|=1&lt;&lt;3|1&lt;&lt;4; GPIOA_CRL&amp;=0x0FFFFFFF; //设置位 清零 GPIOA_CRL|=0x20000000; //PA7推挽输出 GPIOA_ORD|=1&lt;&lt;7; //设置PA7初始灯为灭
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a22c61e2da06817986db432f1ee7b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f98849d8472ca00e062cc689dd87791/" rel="bookmark">
			【uniapp】查看协议文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		agreement.vue
&lt;template&gt; &lt;view class="agreement"&gt; &lt;!-- 协议页面 ,只能在手机上看，模拟器无法查看--&gt; &lt;web-view :src="protocolUrl"&gt;&lt;/web-view&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { protocolUrl: '' } }, onLoad: function(options) { this.protocolUrl = decodeURIComponent(options.url); } } &lt;/script&gt; 其他页面跳转到到协议页面
handleMZ() { uni.navigateTo({ url: '/pages/login/agreement?url=' + 文件地址（是html格式的哦） }) } 注意：在微信模拟器上看，是看不到的，只能在手机上看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df833109757e4cb8216d4b5ac29bdaa9/" rel="bookmark">
			商城有一个抽奖活动，作为用户购买三件商品才能抽奖一次，怎么分析测试点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要分析一个抽奖活动的测试点，需要考虑以下方面：
用户权限：
测试用户是否需要满足一定的条件才能参与抽奖。例如，只有购买了三件商品的客户才能参加抽奖。测试应确保这一条件的正确性和严格性。
购买流程：
测试购买流程是否顺畅，是否容易让人理解，以及是否存在可能的错误或漏洞。例如，测试在购买过程中是否可以顺利地添加到购物车，是否可以正确地结算，是否可以处理可能的异常情况等。
抽奖页面：
测试抽奖页面是否可以正确地显示给用户，包括页面布局、奖品信息、抽奖规则等。同时，也需要测试用户在抽奖过程中是否能正常操作，如抽奖、查看奖品信息等。
中奖概率与奖品：
测试抽奖算法是否正确，是否能按照预设的概率给出相应的奖品。同时，也需要测试奖品数量是否充足，防止出现奖品不足的情况。
系统性能：
测试系统在面对大量用户抽奖时的性能表现，防止出现系统崩溃等问题。
安全性和隐私保护：
测试系统的安全性，例如是否存在潜在的安全漏洞，如SQL注入、跨站脚本攻击等。同时，也需要测试系统是否能够保护用户的隐私数据，防止数据泄露。
用户反馈和客服支持：
测试用户反馈渠道是否畅通，用户是否可以方便地反馈问题和建议。同时，也需要测试客服支持是否及时、准确，是否能有效地解决用户的问题。
兼容性和可访问性：
测试系统是否能在不同的设备和浏览器上正常运行，以及是否有良好的用户体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032745876fbf576fda0368f1735d454a/" rel="bookmark">
			python 闭包理解与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概念介绍二、代码认识闭包2.1、参数在内函数中2.2、参数在外函数中2.3、闭包中内函数修改外函数局部变量 三、闭包的陷阱四、**使用闭包注意事项**五、闭包的作用六、闭包的应用6.1、装饰器6.2、单例模式 七、参考文档： 一、概念介绍 闭包并不只是一个python中的概念，在函数式编程语言中应用较为广泛。理解python中的闭包一方面是能够正确的使用闭包，另一方面可以好好体会和思考闭包的设计思想。
首先看一下维基上对闭包的解释：
在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量 的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其 相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。 另一种更容易理解的解释：
在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包 函数在内存中运行的理解：
程序被加载到内存执行时，函数定义的代码被存放在代码段中。函数被调用时，会在栈上创建其执行环境，也就是初始化其中定义的变量和外部 传入的形参以便函数进行下一步的执行操作。当函数执行完成并返回函数结果后，函数栈帧便会被销毁掉。函数中的临时变量以及存储的中间计算 结果都不会保留。下次调用时唯一发生变化的就是函数传入的形参可能会不一样。函数栈帧会重新初始化函数的执行环境。 C++中有static关键字，函数中的 static 关键字定义的变量独立于函数之外，而且会保留函数中值的变化。函数中使用的全局变量也有类似的 性质。 二、代码认识闭包 2.1、参数在内函数中 def outer_func(): loc_list = [] def inner_func(name): loc_list.append(len(loc_list) + 1) print '%s loc_list = %s' %(name, loc_list) return inner_func # 闭包函数的调用需要首先实例化 clo_func_0 = outer_func() clo_func_0('clo_func_0') clo_func_0('clo_func_0') clo_func_0('clo_func_0') clo_func_1 = outer_func() clo_func_1('clo_func_1') clo_func_0('clo_func_0') clo_func_1('clo_func_1') # 运行结果 clo_func_0 loc_list = [1] clo_func_0 loc_list = [1, 2] clo_func_0 loc_list = [1, 2, 3] clo_func_1 loc_list = [1] clo_func_0 loc_list = [1, 2, 3, 4] clo_func_1 loc_list = [1, 2] 从上面这个简单的例子应该对闭包有一个直观的理解了。运行的结果也说明了闭包函数中引用的父函数中local variable既不具有C++中的全局变量的性质也没有static变量的行为。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032745876fbf576fda0368f1735d454a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a0b3a90391f14cc6dff8469be15e003/" rel="bookmark">
			Python迭代器和生成器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、迭代器1.1、什么是迭代1.2、什么是迭代器1.3、Python 中的可迭代对象1.4、Python 中生成迭代器的方法1.4.1、`iter()`函数1.4.2、`enumerate()`函数1.4.3、`zip()`函数1.4.4、`map()`函数1.4.5、`filter()`函数1.4.6、`reversed()`函数1.4.7、`sorted()`函数 1.5、自定义迭代器类1.6、迭代器和列表的区别1.7、迭代器和for循环区别 二、生成器2.1、什么是生成器2.2、创建生成器2.2.1、生成器表达式2.2.2、生成器函数 2.3、生成器常用方法2.3.1、`send(value)`2.3.2、`close()`2.3.3、`throw()`2.3.3、`yield from` 2.4、`yield`和`yield from` 区别2.5、迭代器和生成器的异同2.6、语法糖2.7、`yield` 实现斐波那契数列 三、参考文档 一、迭代器 1.1、什么是迭代 迭代是指反复的执行一个过程，每次执行都会根据前一次的结果进行调整和优化。在计算机编程中，迭代常常用于循环执行某个操作，直到达到特定的条件或达成目标。迭代也可以用于指代软件开发中的“迭代开发”，即将一个大型软件开发项目分成多个小的迭代周期，每个迭代周期都完成一个可用的软件产品版本，以便及时反馈和调整。迭代的目的是不断优化和改进，逐步达成更好的结果。
1.2、什么是迭代器 迭代器（Iterator）是一种设计模式，它提供了一种访问集合（Collection）中元素的方法，而不必暴露集合内部实现的细节。迭代器为不同类型的集合提供了一种统一的遍历方式，使得集合的迭代访问变得更加简单和方便。迭代器通过提供 hasNext() 和 next() 等方法来实现集合的迭代访问。hasNext() 方法用于判断集合是否还有下一个元素，next() 方法用于返回集合中的下一个元素。迭代器还可以提供 remove() 方法来删除集合中的元素。
1.3、Python 中的可迭代对象 在Python中，可迭代对象是指实现了__iter__()方法的对象，该方法返回一个迭代器（Iterator）对象。以下是一些常见的Python中的可迭代对象：
列表（List）：列表是最常用的可迭代对象之一，可以使用for循环遍历列表中的元素。元组（Tuple）：与列表类似，元组也是可迭代对象，可以通过for循环遍历其中的元素。字符串（String）：字符串也是可迭代对象，可以将字符串中的每个字符作为迭代器返回。集合（Set）：集合也是可迭代对象，可以使用for循环遍历集合中的元素。字典（Dictionary）：字典在迭代时默认遍历的是字典的键。可以使用items()方法遍历字典的键值对。文件对象（File Object）：文件对象也是可迭代对象，可以按行迭代读取文件内容。生成器（Generator）：生成器是一种特殊的可迭代对象，可以通过yield语句生成迭代器。 除了以上常见的可迭代对象，还可以自定义类实现__iter__()方法，使其成为可迭代对象。通过实现__iter__()方法，可以定义自己的迭代器行为，从而实现自定义的迭代逻辑。
使用isinstance和Iterable判断对象是否可迭代
from collections import Iterable print isinstance([], Iterable) # True print isinstance((), Iterable) # True print isinstance("nihao", Iterable) # True print isinstance({1, 2, 3}, Iterable) # True print isinstance({"name": "liqiang"}, Iterable) # True with open("xxx.py", 'r') as f: print isinstance(f, Iterable) # True n = (x*3 for x in range(4)) print n # &lt;generator object &lt;genexpr&gt; at 0x106fda410&gt; print isinstance(n, Iterable) # True print isinstance('a', Iterable) # True print isinstance(100, Iterable) # False 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a0b3a90391f14cc6dff8469be15e003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2529ea56bde916ecf9cce5529b9231e9/" rel="bookmark">
			git常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git branch git branch --set-upstream-to=origin/master master #将本地的master和远程的master连接起来；若origin没和远程地址关联，则需要将origin改为远程地址。 git remote git remote -v #查看当前仓库的远程仓库，-v表示显示远程仓库的urlgit remote origin set-url [url] #设置或更改当前仓库的远程仓库地址git remote rm origin #删除当前目录的远程仓库git remote add origin [url] #添加当前目录的远程仓库#另外还可以修改config文件来修改这些信息 git config git config user.name #查看用户名,后面加上字符串就是代表更改用户名，这个更改只在当前目录下作用git config user.email #查看用户邮箱，后面加字符串代表更改邮箱，这个更改只在当前目录下作用git config –-global credential.helper cache #记住仓库的用户名和密码十分钟
git config credential.helper ‘cache –timeout=3600’ #可设置时间记住仓库的用户名和密码git config --global credential.helper store #长期记住仓库的用户名和密码 git status git status -uno 不显示未管理的文件 git pull # 从仓库下拉工程 git push #上传日志到仓库 git push tags #上传所有标签到仓库git push origion :标签名 #删除仓库某个标签,注意空格和冒号位置git push origion :branch #删除仓库某个分支,或git push origin --delete git branch -d #删除本地分支 git tag #显示本地所有标签 git tag -n #显示本地所有标签的详细信息git tag -a 标签名 日志编号 #给指定日志添加标签 git show 显示某一标签的详细内容；tagname是指标签的名字，使用git tag可以显示在命令行。 git log #显示日志的改动日期 git log --pretty=oneline #单行显示日志 git merge git merge branch #将分支branch合并到当前分支 git commit git commit -m “message” #提交新添加的文件,message是日志名称，其它已存在的文件改动不会提交git commit -a -m “message” #提交当前所有改动,包括新加的文件，都提交 git reset git reset code # code表示日志代码,回滚到某个commit日志，代码不回退git reset --hard code # code表示日志代码,回滚到某个commit的日志，连代码一起回退 git reset [-q] [&lt;tree-ish&gt;] [–] &lt;pathspec&gt;…​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2529ea56bde916ecf9cce5529b9231e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/449da2c473ce8aa12ee9a3ae1a3b1687/" rel="bookmark">
			k8s--基础架构--容器运行时接口 (CRI)和垃圾回收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Container Runtime Interface（CRI） Container Runtime Interface（CRI）是一个插件接口，它使kubelet能够使用各种容器运行时，无需重新编译集群组件。
您需要在集群中的每个节点上安装一个可用的容器运行时，以便kubelet能够启动Pod和它们的容器。
容器运行时接口（CRI）是kubelet和容器运行时之间通信的主要协议。
Kubernetes容器运行时接口（CRI）定义了集群组件kubelet和容器运行时之间通信的主要gRPC协议。
The API 在Kubernetes中，kubelet通过gRPC与容器运行时进行连接时充当客户端。
运行时和镜像服务的终端点必须在容器运行时中可用，可以通过在kubelet中使用–image-service-endpoint命令行标志来单独配置。
对于Kubernetes v1.28，kubelet优先使用CRI v1。如果容器运行时不支持CRI的v1版本，则kubelet尝试协商任何较旧的支持版本。v1.28的kubelet还可以协商CRI v1alpha2版本，但是此版本已被视为不推荐使用。如果kubelet无法协商支持的CRI版本，kubelet将放弃并不会注册为节点。
垃圾回收（Garbage Collection） 垃圾收集是Kubernetes用于清理集群资源的各种机制的集合术语。这允许清理以下资源：
已终止的Pod
已完成的作业
没有所有者引用的对象
未使用的容器和容器镜像
具有Delete回收策略的动态提供的PersistentVolumes的StorageClass
过时或过期的CertificateSigningRequests（CSRs）
在以下场景中删除的节点：
在使用云控制器管理器的情况下，在云中
在使用类似云控制器管理器的附加组件的本地环境中
节点租约对象
Owners and dependents 在Kubernetes中，许多对象通过所有者引用相互链接。
所有者引用告诉控制平面哪些对象依赖于其他对象。
Kubernetes使用所有者引用来为控制平面和其他API客户端提供在删除一个对象之前清理相关资源的机会。在大多数情况下，Kubernetes会自动管理所有者引用。
所有权与某些资源还使用的标签和选择器机制不同。例如，考虑一个创建EndpointSlice对象的Service。Service使用标签来允许控制平面确定哪些EndpointSlice对象用于该Service。除了标签之外，代表Service管理的每个EndpointSlice都有一个所有者引用。所有者引用有助于Kubernetes的不同部分避免干扰它们不控制的对象。
注意：
根据设计，不允许跨命名空间的所有者引用。命名空间内的依赖对象可以指定集群范围或命名空间范围的所有者。命名空间内的所有者必须存在于与依赖对象相同的命名空间中。如果不存在，则将所有者引用视为不存在，并且一旦验证所有者都不存在，依赖对象就会被删除。
集群范围的依赖对象只能指定集群范围的所有者。从v1.20开始，如果集群范围的依赖对象指定了一个命名空间内的资源作为所有者，那么它将被视为具有无法解析的所有者引用，无法进行垃圾收集。
从v1.20开始，如果垃圾收集器检测到无效的跨命名空间所有者引用，或者具有引用命名空间内资源的所有者引用的集群范围的依赖对象，将报告一个带有OwnerRefInvalidNamespace的警告事件，涉及的对象是无效的依赖对象。您可以通过运行kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace来检查这种类型的事件。
Cascading deletion Kubernetes通过检查并删除不再具有所有者引用的对象来清理资源，例如在删除ReplicaSet时留下的Pod。当您删除一个对象时，您可以控制Kubernetes是否自动删除对象的依赖对象，这个过程称为级联删除。级联删除有两种类型，如下所示：
前台级联删除后台级联删除 您还可以使用Kubernetes的finalizers控制垃圾收集如何以及何时删除具有所有者引用的资源。
前台级联删除 在前台级联删除中，您首先正在删除的所有者对象进入一个“正在删除中”的状态。在这个状态下，以下事情发生在所有者对象上：
Kubernetes API服务器将对象的metadata.deletionTimestamp字段设置为标记对象进行删除的时间。Kubernetes API服务器还将metadata.finalizers字段设置为foregroundDeletion。在删除过程完成之前，对象仍然通过Kubernetes API可见。 在所有者对象进入删除中状态后，控制器删除依赖对象。在删除所有依赖对象后，控制器删除所有者对象。在此时，对象在Kubernetes API中不再可见。
在前台级联删除期间，阻止所有者删除的唯一依赖对象是具有ownerReference.blockOwnerDeletion=true字段的依赖对象。有关更多信息，请参阅使用前台级联删除。
后台级联删除 在后台级联删除中，Kubernetes API服务器立即删除所有者对象，而控制器在后台清理依赖对象。默认情况下，Kubernetes使用后台级联删除，除非您手动选择使用前台删除或选择孤立依赖对象。
请参阅使用后台级联删除以了解更多信息。
当Kubernetes删除一个所有者对象时，被留下的依赖对象称为孤立对象。默认情况下，Kubernetes会删除依赖对象。要了解如何覆盖这种行为，请参阅删除所有者对象和孤立依赖对象。
Garbage collection of unused containers and images Kubelet是每隔五分钟对未使用的镜像执行垃圾收集操作，并且每分钟对未使用的容器执行垃圾收集操作。您应避免使用外部垃圾收集工具，因为这些工具可能会破坏Kubelet的行为并移除本应存在的容器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/449da2c473ce8aa12ee9a3ae1a3b1687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d7654bdbb3906a0a1048971092c695/" rel="bookmark">
			el-tabs(标签栏)的入门学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		el-tabs(标签栏)的入门学习
适用场景
与导航栏相似，项目中常见的是点击某个导航栏，主页面（el-main）模块的最上方会显示我们的标签栏集合，点击不同的导航栏，标签栏会在不断追加，若点击到标签集合中已存在，就进入选中指定的标签栏，显示页面
知识点
el-tabs嵌套el-tab-pane使用el-tabs的v-model对应el-tab-pane的nameel-tabs的type可以指定为card,border-cardel-tab-pane的label为显示的标签内容，标签的内容在首尾标签内部el-tabs可以设置closable,editable,addable,分别设置tab-remove,edit,tab-add动态修改标签集合还有tab-click钩子el-tabs中设置tab-position，修改标签位置，可以为top,bottom,left,right 效果图
代码 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='app'&gt; &lt;el-tabs v-model='tabPaneName' @tab-click='handleClick'&gt; &lt;el-tab-pane v-for='tab in tabs' :key='tab.name+"1"' :name='tab.name' :label='tab.label'&gt;{{tab.content}} &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;el-tabs v-model='tabPaneName' type='card' closable @tab-remove='handleRemove'&gt; &lt;el-tab-pane v-for='tab in tabs' :key='tab.name+"2"' :name='tab.name' :label='tab.label'&gt;{{tab.content}} &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;el-tabs v-model='tabPaneName' type='border-card' editable @edit='handleEdit'&gt; &lt;el-tab-pane v-for='tab in tabs' :key='tab.name+"3"' :name='tab.name' :label='tab.label'&gt;{{tab.content}} &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;el-radio-group v-model='position'&gt; &lt;el-radio label='top'&gt;top&lt;/el-radio&gt; &lt;el-radio label='bottom'&gt;bottom&lt;/el-radio&gt; &lt;el-radio label='left'&gt;left&lt;/el-radio&gt; &lt;el-radio label='right'&gt;right&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;el-tabs v-model='tabPaneName' type='border-card' :tab-position='position'&gt; &lt;el-tab-pane v-for='tab in tabs' :key='tab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8d7654bdbb3906a0a1048971092c695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ede9f65ac0e60fe949093bdbeff090ec/" rel="bookmark">
			各平台更新根证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows7 windows7根证书更新
https://support.microsoft.com/en-us/topic/support-for-urgent-trusted-root-updates-for-windows-root-certificate-program-in-windows-a4ac4d6c-7c62-3b6e-dfd2-377982bf3ea5
Linux 查看证书
ls -l /etc/ssl/certs/ 更新根证书
update-ca-certificates #centos 7 update-ca-trust CURL CURL根证书说明
CURL根证书更新
https://curl.se/docs/sslcerts.html
https://curl.se/docs/caextract.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca7b4e8e3514558b9ea3c4df01ebf9a/" rel="bookmark">
			Cocos Creator3.8 项目实战（七）Listview 控件的实现和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滚动列表在游戏中也很常见，比如排行榜 、充值记录等，在这些场景中，都有共同的特点， 那就是：数据量大 ， 结构相同。
在cocoscreator 中，没有现成的 Listview 控件， 无奈之下， 只能自己动手 用ScrollView 来实现一个。这样，有类似需求的朋友，能专注业务功能的开发，就不用重复造轮了。
⚠️ 文末附 ListView.ts 完整源码， 可直接拿去使用。
下面以排行榜Listview 实现为例，进行详细说明。
ListView 实现效果：
ListView 实现原理：
ListView 实现方式，类似 Android的 ListView 。
采用了AbsAdapter 适配器，用于设置数据，更新视图页面，获取数据数量，计算 item 显示位置等。
采用了 ScrollView 配合 item 预制体Prefab 来实现，动态生成列表项， 支持调整 item 项的间距，支持横向和竖向滚动 。
ListView 还设计了简单的上/下拉通知， 只需要初始化时设置相应回调方法即可。
使用步骤：
step 1 ，在creator层级管理器中，新建 ScrollView 节点，并做如下配置：
这里命名为 sore_rank_listview
step 2 ，独立新建一个item 预制体文件
这里命名为：score_rank_item ，添加了以下属性和布局
step 3 ，在层级管理器中，选择score_rank_item 节点，然后在creator属性检查器中，挂载ScoreRankItem.ts 脚本，并做如下属性配置：
step 4 ，在层级管理器中，选择Listview 节点，然后在creator属性检查器中，挂载Listview.ts 脚本，并做如下配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ca7b4e8e3514558b9ea3c4df01ebf9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b47a3935d16f8a8a4b76d9c77508d8b3/" rel="bookmark">
			使用pywin32读取doc文档的方法及run输出乱码 \r\x07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想写一个读取doc文档中表格数据，来对文档进行重命名。经查资料，py-docx无法读取doc文档，原因是这种是旧格式。所以，采用pywin32来进行读取。
import win32com.client as win32 word = win32.gencache.EnsureDispatch('Word.Application',) word.Visible = 0 Ndoc = word.Documents.Add() doc = word.Documents.Open(file_path) for t in doc.Tables: for row in t.Rows: for cell in row.Cells: print(cell.Range.Text) 一运行，结果都是一个框一个框：
以为是编码出了问题，在网上找了原因，gbk/utf-8/utf-16，甚至iso-8859-1各种encode/decode，发现能输出一些字符。无奈一decode都是无果。
各种网站解析无果，我跑去问“文心一言”，居然能翻出来。说明是解析出问题，但是咋都找不到原因。
检查代码，跟其他人写的也一样，这时只能怀疑编译环境了。目前我的版本是3.9，但是这步没办法排查。我只能试试输出到其他地方是什么结果了。 我直接把文件名给改了，结果看到了这样的错误。
看到输出文字，我很高兴，并且留意到\r\x07这个字符，复制到网上一搜，果然看到同样的问题。原来是出现这些转义符号，输出异常了。只要把它们删除即可。 print(cell.Range.Text.replace("\r\x07", "")) 总算是可以了，一个小小的问题折腾的一天，果然是生蔬了。同时也感慨人工智能的进步，写程序提高效率肉眼可见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e09e99a3099eefabfebc0160cbf286ac/" rel="bookmark">
			数据库表创建及所有命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建数据库，创建英雄表添加对应的约束条件：
#创建数据库 create database if not exists db_zy default charset=utf8mb4; #创建数据表 create table if not exists t_hero( id int primary key auto_increment, name varchar(50) not null unique, gender enum("男", "女") default "男", age int default 18, weapon varchar(50) unique )engine=innodb 2.插入80条数据：
insert into t_stu values(1, "孙悟空", "男",152,"金箍棒"); insert into t_stu values(2, "刘备", "男",45, "双管炮"); insert into t_stu values(3, "吕布", "男",44, "方天画戟"); insert into t_stu values(4, "赵云", "男",66, "龙胆亮银枪"); insert into t_stu values(5, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e09e99a3099eefabfebc0160cbf286ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e5555efdbf5c2df07b31fdf7de7cf4/" rel="bookmark">
			TS中Class类构造函数和this的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、构造函数 constructor是构造函数，构造函数会在对象被实例化时调用
constructor （） { // 构造函数体.. }
如下代码中我们实例化了三个对象，每一次都会调用一次constructor函数，输出“构造函数被调用了”
class Dog{ constructor() { console.log("构造函数被调用了"); } } const dog1 = new Dog(); // 打印：构造函数被调用了 const dog2 = new Dog(); // 打印：构造函数被调用了 const dog3 = new Dog(); // 打印：构造函数被调用了 我们也可以在实例化对象的时候传入参数，例如我们这里传入姓名和年龄，在constructor函数中接收参数
class Dog{ constructor(name:string, age:number) { console.log(name, age); } } const dog1 = new Dog("大黄", 3); // 大黄 3 const dog2 = new Dog("旺财", 4); // 旺财 4 const dog3 = new Dog("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e5555efdbf5c2df07b31fdf7de7cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/146e589bd0e2735b6f2ab541aa273d65/" rel="bookmark">
			2023华为OD机试真题-2023(A&#43;B卷)【Java、C&#43;&#43;、Go、Python】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【华为OD机试真题-2023(A+B卷)【Java、C++、Go、Python】 该专栏博客已帮助千余名同学通过OD机考 2023年5月，华为OD机考更新为OD统一考试（B卷）。B卷的题目包括两部分： 1.2022年老题库 2.2023新增题目 OD统一考试B卷的题目博主也会及时搜集更新！ 以下为OD统一考试(B卷)的题目： OD统一考试(B卷)基础题 序号题目分数考点类型1补种未成活胡杨100滑动窗口OD统一考试 B卷2路灯照明问题100区间交并集OD统一考试 B卷3敏感字段加密100字符串处理OD统一考试 B卷4阿里巴巴找黄金宝箱(I)100单指针OD统一考试 B卷5喊7的次数重排100约瑟夫环OD统一考试 B卷6斗地主之顺子100逻辑分析OD统一考试 B卷7IPv4地址转换成整数100字符串处理OD统一考试 B卷8分苹果100位运算OD统一考试 B卷9组成最大数100自定义排序OD统一考试 B卷10最大花费金额100双指针OD统一考试 B卷11太阳能板最大面积100双指针OD统一考试 B卷12座位调整100逻辑分析OD统一考试 B卷13选修课100自定义排序，数据结构OD统一考试 B卷14分班100逻辑分析OD统一考试 B卷15分糖果100递归OD统一考试 B卷16最远足迹100字符串处理OD统一考试 B卷17需要打开多少监控器100逻辑分析OD统一考试 B卷18VLAN资源池100逻辑分析OD统一考试 B卷19求字符串中所有整数的最小和100字符串处理OD统一考试 B卷20求满足条件的最长子串长度100滑动窗口OD统一考试 B卷21TLV解析 Ⅰ100字符串分隔匹配OD统一考试 B卷22拼接URL100字符串处理OD统一考试 B卷23水仙花数 Ⅰ100数学运算OD统一考试 B卷24最大股票收益100贪心算法OD统一考试 B卷25找朋友100单调栈OD统一考试 B卷26找车位100逻辑分析OD统一考试 B卷27猴子爬山100动态规划OD统一考试 B卷28按身高和体重排队100自定义排序OD统一考试 B卷29阿里巴巴找黄金宝箱(Ⅱ)100贪心思维OD统一考试 B卷30玩牌高手100贪心思维OD统一考试 B卷31告警抑制100逻辑分析OD统一考试 B卷32寻找身高相近的小朋友100自定义排序OD统一考试 B卷33消消乐游戏100数据结构 栈OD统一考试 B卷34数组组成的最小数字100自定义排序OD统一考试 B卷35求最多可派出多少支团队100双指针OD统一考试 B卷36数组去重和排序100自定义排序，数据结构OD统一考试 B卷37快递运输100逻辑分析OD统一考试 B卷38停车场车辆统计100逻辑模拟OD统一考试 B卷39查找众数及中位数100数据结构OD统一考试 B卷40滑动窗口最大和100滑动窗口OD统一考试 B卷41连续字母长度100滑动窗口OD统一考试 B卷42寻找相同子串100字符串查找OD统一考试 B卷43阿里巴巴找黄金宝箱(Ⅲ)100数据结构OD统一考试 B卷44报文重排序100字符串分隔OD统一考试 B卷45阿里巴巴找黄金宝箱(V)100滑动窗口OD统一考试 B卷46五子棋迷100滑动窗口OD统一考试 B卷47字符串摘要100滑动窗口，自定义排序OD统一考试 B卷48数组拼接100逻辑分析OD统一考试 B卷49矩阵稀疏扫描100逻辑分析OD统一考试 B卷50文件目录大小100dfsOD统一考试 B卷51恢复数字序列100滑动窗口OD统一考试 B卷52分割数组的最大差值100逻辑分析OD统一考试 B卷53生日礼物100二分查找OD统一考试 B卷54乘坐保密电梯100逻辑分析OD统一考试 B卷55拔河比赛100自定义排序OD统一考试 B卷56计算最接近的数100滑动窗口OD统一考试 B卷57矩阵元素的边界值100数据结构OD统一考试 B卷58增强的strstr100正则表达式OD统一考试 B卷59最长公共后缀100字符串操作OD统一考试 B卷60支持优先级的队列100自定义排序OD统一考试 B卷61数字反转打印100逻辑分析OD统一考试 B卷62跳房子1100两数之和OD统一考试 B卷63数字涂色100逻辑分析OD统一考试 B卷64勾股数元组100数学知识OD统一考试 B卷65工号不够用了怎么办100数学知识OD统一考试 B卷66计算最大乘积100字符串处理OD统一考试 B卷67比赛的冠亚季军100逻辑分析OD统一考试 B卷68报文回路100逻辑分析OD统一考试 B卷69响应报文时间100字符串处理OD统一考试 B卷70食堂供餐100逻辑分析OD统一考试 B卷71经典屏保100数学运算OD统一考试 B卷72数据分类100位运算OD统一考试 B卷73按单词下标区间翻转文章内容100字符串处理OD统一考试 B卷74比赛100自定义排序OD统一考试 B卷75模拟消息队列100逻辑分析OD统一考试 B卷76荒岛求生100逻辑分析OD统一考试 B卷77奖牌榜排名100自定义排序OD统一考试 B卷78报数游戏100逻辑分析OD统一考试 B卷79数字最低位排序100自定义排序OD统一考试 B卷80GPU算力100逻辑分析OD统一考试 B卷81最长连续子序列100滑动窗口OD统一考试 B卷82最长元音子串100滑动窗口OD统一考试 B卷83字符串子序列II100逻辑分析OD统一考试 B卷84关联子串100字符串处理OD统一考试 B卷85字符串变换最小字符串100逻辑分析OD统一考试 B卷86统计射击比赛成绩100自定义排序OD统一考试 B卷87相对开音节100字符串处理OD统一考试 B卷88一种字符串压缩表示的解压100字符串处理OD统一考试 B卷89德州扑克100逻辑分析OD统一考试 B卷90单词重量100字符串处理OD统一考试 B卷91非严格递增连续数字序列100滑动窗口OD统一考试 B卷92找出经过特定点的路径长度100逻辑分析OD统一考试 B卷93单词接龙100字符串处理OD统一考试 B卷94乱序整数序列两数之和绝对值最小100逻辑分析OD统一考试 B卷 OD统一考试(B卷)进阶题 序号题目分数考点时间1宜居星球改造计划200bfsOD统一考试 B卷2找最小数200数据结构 栈OD统一考试 B卷3解压报文200数据结构 栈OD统一考试 B卷4We are a team200并查集OD统一考试 B卷5最长广播效应200Dijkstra算法OD统一考试 B卷6服务失效判断200并查集OD统一考试 B卷7导师请吃火锅200贪心算法OD统一考试 B卷8考古学家200回溯算法OD统一考试 B卷9叠积木200回溯算法OD统一考试 B卷10打印任务排序200模拟入队出队OD统一考试 B卷11仿LISP计算200数据结构 栈OD统一考试 B卷12高效的任务规划200动态规划OD统一考试 B卷13转骰子200逻辑分析OD统一考试 B卷14最少面试官数200贪心算法OD统一考试 B卷15欢乐的周末200dfsOD统一考试 B卷16最佳植树距离200二分法OD统一考试 B卷17阿里巴巴找黄金宝箱(IV)200栈结构OD统一考试 B卷18通过软盘拷贝文件20001背包OD统一考试 B卷19代表团坐车20001背包OD统一考试 B卷20区间交集200区间合并OD统一考试 B卷21寻找最大价值矿堆200dfsOD统一考试 B卷22找出两个整数数组中同时出现的整数200逻辑分析OD统一考试 B卷23数据最节约的备份方法200双指针OD统一考试 B卷24数字游戏200前缀和OD统一考试 B卷25查字典200字符串处理OD统一考试 B卷26MELON的难题20001背包OD统一考试 B卷27数字序列比大小200贪心思维OD统一考试 B卷28跳格子1200动态规划OD统一考试 B卷29战场索敌200dfsOD统一考试 B卷30跳格子2200动态规划OD统一考试 B卷31计算误码率200逻辑分析OD统一考试 B卷32返回矩阵中非1元素的个数200bfsOD统一考试 B卷33最小循环子数组200KMP算法OD统一考试 B卷34不开心的小朋友200逻辑分析OD统一考试 B卷35跳房子2200三数之和OD统一考试 B卷36完全二叉树非叶子部分后续遍历200二叉树后序遍历OD统一考试 B卷37字符串化繁为简200字符串处理OD统一考试 B卷38评论转换输出200递归OD统一考试 B卷39树状结构查询200bfsOD统一考试 B卷40代码编辑器200字符串处理OD统一考试 B卷41周末爬山200bfsOD统一考试 B卷42最小传输时延1200Dijkstra算法OD统一考试 B卷43计算疫情扩散时间200bfsOD统一考试 B卷 ####
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/146e589bd0e2735b6f2ab541aa273d65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/266fe49571df5ef79851faa3cfa5bc1e/" rel="bookmark">
			亚马逊的卫星发射升空，它和“星链”在讲什么故事?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日前，亚马逊公司拟发射首批卫星，这一举动是为了启动名为“柯伊伯计划”的太空互联网服务计划。该计划希望能与太空探索技术公司的“星链”计划相抗衡。
亚马逊表示，Kuiper系统的首批生产卫星计划于2024年上半年发射，并预计将在2024年底与早期商业客户进行Beta测试。
01
贝索斯和马斯克的异同
事实上，亚马逊的卫星发射计划和SpaceX很像。它们都可统称为互联网卫星项目，都是旨在提供全球网络覆盖，并且都是低轨道卫星。
不过，二者也不完全是同质项目，其中也有不同。其中，在场景上，星链计划的目标是提供高速、低延迟的互联网服务，而Kuiper计划则将重点放在为农村和偏远地区提供网络覆盖上。
在发展程度上，SpaceX的星链计划已经开始了实际的发射工作，并且计划发射超过1万颗卫星，而亚马逊的Kuiper计划还处于规划阶段，尚未开始发射。在数量上，亚马逊计划组成3236颗卫星组成的巨型星座。
在资本上，亚马逊的贝索斯相对马斯克有过之而无不及。其仅在2021年第三季度，亚马逊公司的现金储备就为714亿美元。与此相对应的，马斯克在社交媒体表示，其有420亿美元“不知道买什么公司好”。甚至，一度有传言他要用这些钱投资A股市场。
不过，总之，二者都坐拥巨大资本。
02
低轨卫星如何成为香饽饽
卫星构建互联网或通讯网，最早可以追溯至摩托罗拉的铱星计划。虽然铱星是高轨66颗卫星，但就资本故事而言，并没有太多不同。
为什么这么古老的故事能在近期获得追捧?当我们把事情剖析一下，不免会得到答案。
铱星计划并未最终成功，原因很多，其中包括新科技的应用情况不理想，当时没有提高多少通话质量。导致，用户不想花钱换通讯技术不成熟的电话。
在当时，卫星电话市场混乱，缺乏标准，也让这个计划折戟沉沙。
时过境迁，反倒低轨卫星技术获得突破，并开始商业化。
其实起初，低轨卫星同样不成熟，它通信系统的发展受到卫星寿命、通信频段等问题的限制。后来，随着卫星制造技术的进步和市场需求的逐渐旺盛，低轨卫星通信系统的发展方兴未艾。
尤其是近年来，随着一箭双星/多星同时发射入轨等技术的广泛应用，低轨卫星通信系统的系统频谱利用率得到了提高，容量也得到了增大。
当然，现在的低轨道卫星并不是尽善尽美的，也有一些问题。比如它们都需要卫星数量较多，由此，带来地面控制、维护系统也比较复杂。
在通信方面，一个突出的问题是波束切换和星间切换。由于低轨卫星相对地球高速运动，使得终端在通信过程中需要频繁地切换到其他波束或卫星上才能继续通话。
以铱星系统为例，其最小切换时间间隔为10.3秒，平均切换时间间隔为277.7秒。实现切换需要一系列信令操作过程，频繁的切换加重了系统的信令负荷。切换越频繁，切换失败的概率越大。
当然，这也是亚马逊等公司在通告里没说的，具体发展还需等待其技术突破，这里只把难点摆出来。
为什么低轨道卫星这么受到热捧?
其实，这背后的原因不仅是商业层面的。一些观点认为，低轨道卫星的争夺本质在于对有限轨道资源的争夺。低轨道卫星，特别是地球静止轨道卫星容量是确定的，有限的轨道位置使得各国卫星发射机构都在努力抢占这些资源，以实现自身的战略目的。
一方面，现在低轨道卫星具有信号质量高、发射成本低、维护难度小等优势，对于通信、导航、遥感等功能的实现非常有利。因此，各国卫星发射机构都希望通过抢占低轨道卫星的位置，来实现自身的技术突破和市场拓展。
此外，由于缺乏统一的国际法规和管理机制，低轨道资源分配也存在着不公平和不合理的现象。这也使得各国卫星发射机构在争夺低轨道卫星资源时更加激烈。
03
低轨道卫星的商业化展望
国内在低轨道卫星的发展实力也很强。据相关资料，中国计划部署1.3万颗卫星以建立自己的星链系统，应对现代社会需求。这些卫星将可能用于互联网和商业运载火箭等领域。
马斯克更是放出豪言，认为星链是其实现火星移民过程中必不可少的基础设施。
当然，当下的营收也十分重要。据了解，低轨道卫星的付费模式通常包括硬件费用和服务费用。用户需要支付的硬件费用包括卫星天线、基座、路由器等设备费用，服务费用则是用户需要支付的通信服务费用。
比如，星链（Starlink）的收费模式就包括硬件费用和每月的服务费用。参与星链项目公开测试的用户需要支付499美元的硬件费用，包括星光连接相控卫星天线、三脚架基座、WiFi路由器和星光连接终端等。此外，用户还需要支付每月99美元的服务费用。对于已经拥有部分硬件的用户，他们需要额外支付50美元的费用。
公开资料显示，2022年星链的收入为14亿美元，高于前一年的2.22亿美元。SpaceX预计到2025年，星链项目将产生近40亿美元的营收和20亿美元的营业利润。虽然，也有观点认为星链项目的签约速度比预期慢得多，到2022年底的活跃项目超过100万，远不及公司原本预计的2000万。这可能对未来的营收产生一定的影响。
当然，营收话题对于亚马逊来说还为时尚早。
有意思的是，亚马逊的卫星计划一经推出便遭到科学家反对，但客观而言，他们的反对不是商业层面的。
据资料显示，科学家认为太空中的废弃卫星数千颗，如果亚马逊的柯伊博计划顺利实施，地球轨道上将会多出5000多颗人造卫星，这将使空间轨道更加拥挤，有可能发生碰撞，影响已有人造卫星的安全。
对于天文观测来说，过多的卫星会影响天文学家的观测和研究，因为它们会干扰天文信号，甚至有可能导致天文观测的失真或无效。
还有人认为，目前在地球附近的太空垃圾数不胜数，如果亚马逊大规模发射卫星，这些卫星最终将成为太空垃圾的一部分，清理这些垃圾需要花费大量时间和金钱。
他们给出的观点是，亚马逊的卫星计划为了覆盖网络信号，但是过于密集的卫星聚集在一起，可能会发生碰撞的情况，同时也会影响到其他国家发射卫星的计划。
你怎么看贝索斯和亚马逊的卫星计划，欢迎留言给我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16207a3071a661218c25f905a8da3436/" rel="bookmark">
			知识图谱系列Paper 1：Open-CyKG: An Open Cyber Threat Intelligence Knowledge Graph
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向前进！
一、摘要 Instant analysis of cybersecurity reports is a fundamental challenge for security experts as an immeasurable amount of cyber information is generated on a daily basis, which necessitates automated information extraction tools to facilitate querying and retrieval of data. Hence, we present Open-CyKG: an Open Cyber Threat Intelligence (CTI) Knowledge Graph (KG) framework that is constructed using an attention-based neural Open Information Extraction (OIE) model to extract valuable cyber threat information from unstructured Advanced Persistent Threat (APT) reports.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16207a3071a661218c25f905a8da3436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a380976d21fe012d23773360ec3c1f3/" rel="bookmark">
			Python: 库decimal()用于浮点数相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from decimal import Decimal a=1.1 b=2.2 print(Decimal('2.2')+Decimal('1.1')) 结果为：3.3
Pyhton中浮点数是不能直接相加的。
可以看到结果并不对。
因此需要用到decimal
可以看到a+c时不计算的结果是正确的。
因此在python中，计算浮点数时，一部分数字进行四则运算会出错，一部分不会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d01e257c6d9b12842280829b061a8b10/" rel="bookmark">
			算法笔记(dijkstra求带权无向图最短路径问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt; #include&lt;string.h&gt; #define N 100 //图最大顶点数 #define INF 0x3f3f3f3f//无穷大距离 typedef struct{ int vex[N][N]; int Vnum,Enum; }Graph; void CreateGraph(Graph *G){ memset(G-&gt;vex,INF,sizeof(G-&gt;vex)); printf("请输入图的顶点数和边数:"); scanf("%d%d",&amp;G-&gt;Vnum,&amp;G-&gt;Enum); printf("请按行输入边对应权值:\n"); for(int i=0;i&lt;G-&gt;Enum;i++){ int v1,v2; scanf("%d%d",&amp;v1,&amp;v2); scanf("%d",&amp;G-&gt;vex[v1][v2]); } printf("\n"); }//创建图 void Dijkstra(Graph *G){ int book[G-&gt;Vnum]={0};//用于判断点是否已找到最短路径 int dist[G-&gt;Vnum],start,end;//dist用于记录当前路径长度 int path[G-&gt;Vnum];//用于记录最短路径 printf("请输入起点和终点:\n"); scanf("%d%d",&amp;start,&amp;end); memset(dist,INF,sizeof(dist));//初始化dist数组 dist[start]=0; while(1){ int MIN=INF,u=-1; for(int i=0;i&lt;G-&gt;Vnum;i++) if(dist[i]&lt;MIN&amp;&amp;book[i]==0){ MIN=dist[i]; u=i; } if(u==-1) break;//说明图不连通 book[u]=1; for(int i=0;i&lt;G-&gt;Vnum;i++) if(dist[u]+G-&gt;vex[u][i]&lt;dist[i]){ dist[i]=dist[u]+G-&gt;vex[u][i]; path[i]=u; }//更新最短路径以及最短距离 } int temp[N],t=0,x=end; while(x!=start){ temp[t++]=x; x=path[x]; }//逆序记录路径 temp[t]=start; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d01e257c6d9b12842280829b061a8b10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aadca1eac82fd647c336c18c6613affb/" rel="bookmark">
			CCS安装和运行TMS320F28004x第一个程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. CCS安装 TI 的MCU或者DSP，官方的集成开发环境是 Code Composer Studio™ ，要开发TI的芯片，首先需要安装 CCS 环境。
CCS 软件可以到下面的 TI 官网下载：
https://www.ti.com.cn/tool/cn/CCSTUDIO
下载完之后，点击安装即可，在安装过程没什么特别的地方，基本上一路 next 即可，不多介绍了。
中途会让你选择安装的芯片软件包，我们勾选自己需要开发的系列芯片就行了。
第一次打开软件会提示如下：
要求要选择的 ccs 工作空间保存的文件放到哪个目录，默认它会放在 C 盘的用户目录下的。我这里选择在D盘新建的一个目录存放。然后点击 Launch 进入软件。
首次进入软件界面如下：
2. 导入SDK的例程 我使用的芯片是属于TI的C2000系列，可以去官网下载对应的SDK。
https://www.ti.com.cn/tool/cn/C2000WARE
下载完SDK之后，下面导入一个例程到CCS使用。
1、File -&gt; Import
2、导入CCS的例程到工作空间
3、然后在SDK里面，找到自己想要导入的例程，然后点击完成即可。
4、最后，导入之后目录结构如下。
3. 编译下载调试 3.1 编译 3.2 调试下载 1、首先新建调试配置
2、然后如果没有报错的情况下，一般就会自动进入调试仿真状态了。
3.3 解决进入调试时的错误 但是有些情况，进入调试时可能会遇到错误。如下，说连接目标的时候发生错误。
这个时候可能是 XDS100 的仿真器型号选择错误。
可以先点击工程，然后右键选择属性进行更改：
然后选择仿真器版本，如下图：
可以点击校验，如果确实可以成功连接的话，会出现success的提示，如下：
有时候可能更改了 XDS100 仿真器版本，还是不能解决，这时可能是仿真器的驱动没有安装，我们可以去下面的网站下载 XDS 仿真器驱动进行安装。
https://ftdichip.com/drivers/d2xx-drivers/
选择了不同的XDS仿真器型号，安装了新的驱动还是不能连接上的话，暂时就不知道是什么问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1965899d6fed8fe2132d2680f2765a1d/" rel="bookmark">
			Pinctrl子系统_03_Pinctrl子系统使用示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节演示，如何使用Pinctrl子系统配置I2C通信所使用的引脚，以IMX6ULL为例。
如下图所示，在芯片内部，有I2C模块。
怎么配置I2C模块？ 答：
首先，要知道I2C模块会使用哪些引脚，这可以通过看原理图确定。确定使用哪些引脚之后（假设使用pinA，pinB）， 就可以配置IOMUX，选择引脚的功能了。最后，就是配置（config）引脚了。 其中，第二步、第三步的配置，会作为一个类似下图的节点保存在设备树中。
然后，就可以通过类似下图所示的节点，来选择使用上图所示的节点，而不需要写额外的代码。
如下图所示，右边的节点由于格式是统一的，所以很容易构造，难点在于左边的节点，它没有统一的格式，往往不同平台之间的格式就大不相同。
如何构造Pinctrl节点？ 那么，如何构造左边的节点呢？
答：可以通过以下三种方法：
工具（tool），对于一些芯片厂商，有提供对应的工具，用于生成这些引脚；文档，或设备树示例；源码（较困难）； 对于imx6ull，他有提供一个工具（i.MX Pins Tool v6），可以生成对应的引脚配置信息。
使用方法也很简单，选中想要配置的引脚，然后选择要配置成哪种功能，然后点击完成，就会生成对应的配置信息。
开始配置I2C模块 看原理图获取引脚 首先，根据底板原理图获取使用到的引脚信息。
使用的是64,65号引脚。
然后，找到对应的管脚号是G16，G17。
选择引脚功能 然后，可以在工具上选择引脚的功能。
生成的设备树配置信息如下：
配置引脚 引脚功能选择完毕后，还可以配置引脚。
配置引脚后，可以看到节点配置信息也产生了变化。
可以推测，前面的宏是选择引脚的功能，后面的值则是引脚的配置值。
配置Client节点 此时，我们生成了Pinctrl节点，但是要怎么选择使用它呢？
&amp;iomuxc { pinctrl-names = "default"; pinctrl-0 = &lt;&amp;BOARD_InitPins&gt;; imx6ull-board { i2c1_pins: i2c1_pins { /*!&lt; Function assigned for the core: Cortex-A7[ca7] */ fsl,pins = &lt; MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x000018B0 MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x000018B0 &gt;; }; }; }; 参考内核设备树文件，内核的配置和使用如下：
所以，可以这样使用pinctrl：
&amp;i2c1 { clock-frequency = &lt;100000&gt;; pinctrl-names = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1965899d6fed8fe2132d2680f2765a1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d1ad4a1743169611a11cd96de72b8b7/" rel="bookmark">
			Android12 源码下载、编译、刷机、单编调试Framework
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引言1. 代码下载1.1 下载Repo工具1.2 安装和配置Git1.3 创建工程目录1.4 初始化Repo仓库1.5 同步代码 2. 驱动下载2.1 下载对应机型的驱动2.2 驱动提取 3. 代码编译3.1 设置编译环境3.2 初始化编译环境3.3 选择编译目标3.4 编译 4. 刷机5. 挂载system分区6. 单编译Framework模块单编framework.jar并替换单编services.jar并替换 参考 引言 深入学习Android系统框架开发前，首先要搭建Android工程的开发环境（建房子前先搞地基），详细的配置要求和操作步骤见官网说明 Establishing a build environment，本文也汇总了Android 12工程源码的下载、编译和刷机的实操过程。
在开始代码下载之前，先强调下源码编译对硬件/软件的要求：
硬件要求：
如果是 Android 2.3.x (Gingerbread) 及更高版本（包括 master 分支），需要 64 位环境。如果是较低的版本，则可以在 32 位系统中进行编译。如果要检出代码，至少需要 250 GB 可用磁盘空间；如果要进行构建，则还需要 150 GB。如果要进行多次构建，则需要更多空间。至少需要 16 GB 的可用 RAM，但 Google 建议提供 64 GB。 软件要求：
系统要求安装Ubuntu 18.04.1及以上版本。OpenJDK 详细说明可参考官网：Requirements
个人建议：如果电脑配置不够，可以用云电脑产品来代替，比如“天翼云电脑”，可以选择超强的配置和Ubuntu系统，实现Study Work Anywhere。调试终端可以使用模拟器，但有条件的话推荐用Google发布的终端设备来调试，如Pixl3L、Pixl4，闲鱼上很多。
1. 代码下载 官方教程参考Source control tools,Downloading the source，包含源码管理工具Git,Repo,Gerrit,Android Code Search,Android Studio,Android Debug Bridge (ADB)的说明和源码下载。在国内因为墙而导致无法初始化repo，本教程以国内的镜像站点为例子，比如科大 AOSP 镜像站点，或者北京外国语大学开源软件镜像站。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d1ad4a1743169611a11cd96de72b8b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e812da13496210aced49ba39e284a7cc/" rel="bookmark">
			超详细！新手必看！STM32基础-IIC串行通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I2C（Inter-Integrated Circuit）是一种常用的串行通信协议，通常用于连接微控制器和各种外部设备（例如传感器、存储器、显示器等）。
以下是使用I2C接口的一般步骤：
注：I2C 使用 SDA 信号线来传输数据，使用 SCL 信号线进行数据同步。
数据的有效性：
SDA数据线在 SCL 的每个时钟周期传输一位数据。传输时：
（1）SCL 为高电平的时候 SDA 表示的数据有效，即此时的 SDA 为高电平时表示数据 “1”，为低电平时表示数据“ 0”。
（2）当 SCL为低电平时，SDA 的数据无效，一般在这个时候 SDA 进行电平切换，为下一次表示数据做好准备。
硬件连接：
确保正确连接了I2C总线的两根线（SCL - 时钟线，SDA - 数据线）到目标设备。确保目标设备有正确的供电。 初始化I2C模块：
首先，初始化I2C模块，SDA\SCL模式，通信速率等参数。IIC： （把引脚初始化成复用开漏模式，要注意 I2C 的引脚必须
使用这种模式。）
SDA–复用开漏输出。
SCL–复用开漏输出 选择目标设备地址（制造商预先分配，查看手册获取）：
每个I2C设备都有一个唯一的地址。在通信开始之前，你需要知道你要与之通信的设备的地址。每个设备都有一个唯一的7位地址，用于在总线上区分不同的设备。 发送启动信号：
发送一个启动信号来开始I2C通信。起始信号的生成标志着I2C通信的开始，接着就可以发送目标设备的地址和读写位来开始通信。初始都为高电平。先拉低 SDA，然后再拉低 SCL。表示启动信号。 void IIC_Start() { SCL=1; SDA=1; SDA=0; SCL=0; } 发送目标设备地址和读/写位：
发送目标设备的地址和指定读写方向。
注：跟哪个从机通讯，把从机的地址发出去。发送数据是8个bit，这8个bit位中前7个bit位是从机的地址，最后1个bit位是用来表示读或者写的。1表示读，0表示写；这个过程相当于主机往SDA上发了8个bit的数据。主要是为了寻找与其通信的从机。 6.完成应答：
当主机找到需要通信的从机后，从机需要回复应答信号。应答信号为SCL从高电平变为低电平。
（1）应答信号： void IIC_Wait_Ack() { SCL = 0; SDA = 0; SCL = 1; SCL = 0; } （2）非应答信号：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e812da13496210aced49ba39e284a7cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d53f1e7751d0027fd3e271c4ecc3d47/" rel="bookmark">
			智能汽车的算力大战“开打”，高通、华为、英伟达入场谁会赢?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国庆还没完，电动汽车行业的算力大战已然开打。
现在，传统芯片公司、电动汽车头部厂商、造车新势力已全线加入。
在几年前，人们还认为电动汽车是大号的手机。而几年后，这种观念得到了飞速迭代。
01
为什么汽车需要算力
实际上，汽车作为一种终端非常需要算力支持。
这包括在车机系统中的算力，它主要负责导航、娱乐、语音识别等。
而在语音控制系统所需要的算力中，由于语音控制系统不断进化，为确保语音识别和处理的速度和准确性，对算力需求更多了。
最重要的是，自动驾驶系统需要的算力，这是智能汽车的重头戏。现在的自动驾驶系统需要高精度地图、传感器融合、决策和控制等复杂的技术支持，这块是算力需求增长最快的一部分。
当然了，对于安全控制来说，也需要一定的算力，它们被设计用来改善制动系统、避障系统等。
在目前电动汽车行业同质化严重、价格战猛烈的客观环境下，我们认为，算力将是未来车和车之间差异化的重要标志。
因为，算力水平直接影响了新能源车的计算效率，高效的计算能够更好地支持车辆的实时决策、控制和优化，大家可以类比手机，越卡的手机越没人买就是这个道理。
除了是个大号的手机，车联网传感器数据、导航数据、车联网数据等，客观上，这方面能力也会反映在车的销售中。
02
车厂之间的布局情况
现在，主流新能源车已十分关注这方面。
据了解，特斯拉在硬件上一直采用较为激进的策略，其FSD（Full Self-Driving）芯片算力已经达到了72TOPS，并采用了14nm制程工艺，大大提升了芯片性能和能效。特斯拉在算力方面进行了大量的投资，最新的Cybertruck更是配备了HW 3.0处理器，有望在算力上实现大幅提升。
新势力方面，蔚来汽车推出了搭载4颗英伟达Orin X芯片的ES7车型，总算力达到了1016TOPS，是特斯拉Model Y的7倍。蔚来通过与英伟达合作，想在此分一杯羹。
作为特斯拉的直接对手，小鹏G9使用了与蔚来ES7和理想L9相同的英伟达Orin X芯片，并且采用了两颗芯片，算力达到了508TOPS。虽然不及蔚来ES7的总算力，但相比小鹏上一代车型已有一个数量级的提升。
另外是一向“剑走偏锋”的理想，这次趋同于行业了，它在L9上采用了与小鹏G9相同的英伟达Orin X芯片，并且也是两颗，算力同样达到了508TOPS。
在手机高端芯片被华为逆袭后，高通也在积极布局智能汽车领域。其推出的骁龙Ride平台是专为汽车设计的处理器系列，旨在为汽车制造商提供更强大的自动驾驶功能。
高通仍然具有强大竞争力，对此不能小觑。
03
电动汽车的最终形态
电动汽车不仅是燃油车的替代，也不仅仅改变了动力来源。现在，它杂糅着最新科技的成果，未来的发展十分广阔。
以时下最流行的AIGC来说，Transformer和端到端大模型在智能汽车发展中扮演了关键角色，它提升了汽车的感知与决策能力，这在我们以往对机器人等行业的分析中已经司空见惯，但车才刚刚开始。
原理是，借助多传感器融合的方式，将摄像头、激光雷达、毫米波雷达、超声波雷达等多种传感器的信息进行融合处理，提取特征向量，并结合时序信息进行动态识别。
这样可以在统一的3D坐标系空间（BEV）内进行特征融合，提高感知的精准度。此外，Transformer大模型还可以通过注意力机制实现更精准的目标识别，结合多任务学习神经网络架构HydraNet，实现端到端的智能驾驶。
大家都知道，现在的自动驾驶还不是很可靠，在人工智能逐渐进步的当下，不得不说这有利于自动驾驶的最终成型。
现在还有一个趋势是，智能座舱正在向着舱驾智能的方向演化。
这倒逼了芯片行业的变革。
传统的汽车功能芯片已经无法满足需求，大算力智能座舱SoC芯片的需求大幅高涨。芯擎科技董事兼CEO汪凯博士曾表示，要打造一个更好用户体验感的智能座舱系统，首要条件就是智能座舱芯片的算力要向手机看齐。而要实现非常自然、流畅的交互体验，则需要足够的AI算力和相应的AI算法作为支撑，传统的车内娱乐芯片已经不能够满足智能座舱的计算能力需求。因此，伴随着整车电子电气架构加速由分布式向集中式演进，接下来的一段时间内，传统低算力芯片将加速被高性能座舱SoC替代。
其次，舱驾智能的发展需要汽车电子电气架构的不断升级。汽车电子电气架构的发展经历了多个阶段，从分布式电子电气架构到模块化阶段，再到集成化阶段，最后到域/跨域集中式电子电气架构和中央计算电子电气架构。在这个过程中，ECU的数量不断减少，功能更加集成，算力需求逐步增长。特别是在域集中控制阶段，功能域即根据功能划分的域控制器，最常见的是博世公司划分的五个功能域（动力域、底盘域、车身域、座舱域、自动驾驶域）。
在跨域融合阶段，为进一步降低成本和增强协同，出现了跨域融合，即将多个域融合到一起，由跨域控制单元进行控制。比如将动力域、底盘域、车身域合并为整车控制域，将高算力需求的座舱域和自动驾驶域合并为舱驾一体计算域。
中央计算+位置域阶段则进一步升级为更加通用的中央计算平台，充足的算力支持应用软件的迭代升级，通过位置域控制器（Zone ECU）连接车上某一个区域（如中域、左域、右域）内的传感器、执行器。位置域控制器负责某车身位置内的传感器数据的初步计算处理和网络协议转换，实现就近布置线束，减少通信接口，更好实现硬件可插拔扩展。
此外，高工智能汽车研究院监测数据显示，2021年度中国市场交付乘用车搭载信息娱乐的占比已经超过80%，其中，NXP、TI、全志、杰发等传统低算力芯片占比超过50%。这意味着高性能座舱SoC替代市场巨大。
也许，在未来，我们不仅仅得到的是电动汽车，还得到了功能强大的智能终端。行业依旧在飞速发展，对行业发展的终局目前还很难判断。
您还有什么想知道的，欢迎留言给我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2f5974b5cc6efa8665cb5a22f9ce98/" rel="bookmark">
			kubernetes 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubectl get role — all-namespaces 查看role 所有的namespace role 只作用于指定的namespace下kubectl get role -n namespace -oyamlKubectl get role -n namespace name -oyaml 不加name 显示kind：list 所有Role 和 cluster role唯一区别 role只作用于namespace下cluster role 作用于整个集群Kubectl get cluster role name -oyamlKubectl get cluster role view -oyaml &gt;/tmp/view.yamlKubectl get rolebinding —all-namespacesKubectl get rolebinding name -n namespace -oyamlRolebinding 将role中定义的权限授予 user group 或service accountKubectl scale —replicas=3 sts nginx 扩容nginx副本 sts statefulset缩写Kubectl autoscale deployment name —cpu-percent=20 —mix=2 —max=10 hpa定义pod副本数 cpu是和name的deployment里的request下的cpu做比较来进行扩容缩容 一般不用内存来判断是否扩容缩容因为可能会出现内存下不来的现象cpu是动态的或者去找开发让他开放一个端口反应的是网站的链接数当链接数达到多少进行扩容 自定义参数来进行是否扩容缩容kubectl lable node k8s-node02 region=subnet7 给node02定义lable 网段为7Kubectl get node -l region=sunet7 -l 使用lable过滤器过滤kubectl create deployment nginx --image=nginx:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2f5974b5cc6efa8665cb5a22f9ce98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34fe4d778fad9ff7da0676f539c2fdae/" rel="bookmark">
			【数据结构】二叉树的层序遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.层序遍历的原理1.1.创建一个队列，并将根节点入队。1.2.当队列不为空时，执行以下步骤：1.3如果队列为空，则表示遍历结束。 2.层序遍历的实现3.层序遍历的应用层序遍历实现判断二叉树是否为完全二叉树层序遍历实现判断完全二叉树的思路： 总结 当我们面对一个树结构时，常常需要对其进行遍历以获取其中的节点信息。其中一种常用的遍历方式是层序遍历，也称为广度优先搜索（BFS）。本篇博客将详细介绍层序遍历的原理和实现方法。 1.层序遍历的原理 层序遍历以树的根节点开始，按照从上到下、从左到右的顺序逐层遍历树中的节点。这意味着在遍历当前层的节点之前，需要先遍历完上一层的节点。层序遍历基于队列的数据结构实现，它的过程可以描述如下：
1.1.创建一个队列，并将根节点入队。 1.2.当队列不为空时，执行以下步骤： 从队列中取出一个节点，访问该节点。将该节点的所有子节点（如果存在）依次入队。 1.3如果队列为空，则表示遍历结束。 由于队列的特性，首先入队的节点会先被访问，保证了按照层级顺序遍历节点。
2.层序遍历的实现 1 / \ 2 3 / \ \ 4 5 6 首先，我们创建一个空队列，并将根节点1入队。然后按照队列非空的条件，执行以下步骤：
取出队列中的第一个节点1，并访问它。将节点1的子节点2和3依次入队。队列变为[2, 3]。取出队列中的第一个节点2，并访问它。将节点2的子节点4和5依次入队。队列变为[3, 4, 5]。取出队列中的第一个节点3，并访问它。将节点3的子节点6入队。队列变为[4, 5, 6]。取出队列中的第一个节点4，并访问它。此时该节点没有子节点入队。队列变为[5, 6]。取出队列中的第一个节点5，并访问它。此时该节点没有子节点入队。队列变为[6]。取出队列中的第一个节点6，并访问它。此时该节点没有子节点入队。队列为空，遍历结束。 按照上述步骤，我们可以得到层序遍历的结果为：[1, 2, 3, 4, 5, 6]。
void BinaryTreeLevelOrder(BTNode* root) { // 定义一个队列 Queue q; QueueInit(&amp;q); // 初始化队列 if (root != NULL) // 如果根节点不为空，将其入队 QueuePush(&amp;q, root); while (!isEmptyQueue(&amp;q)) // 当队列不为空时循环 { // 取出队头元素 BTNode* front = QueueFront(&amp;q); printf("%c "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34fe4d778fad9ff7da0676f539c2fdae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f487bce6b417cb9f5f64c661a9986c9/" rel="bookmark">
			生成Release版本的.pdb文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 软件分为Debug版本、Release版本这2种版本，其中Debug版本是带有.pdb调试信息文件，而Release版本不带.pdb调试信息文件。软件发布时，一般采用Release版本，若因内存泄漏、数组访问越界、除零错误、磁盘读写错误等异常，造成软件崩溃，会生成一个.dmp崩溃文件。该.dmp崩溃文件，如同飞机的黑匣子，记录软件(或飞机)处于崩溃那那一刻的堆栈信息、运行错误和执行的代码语句行。.dmp文件需要Release版本的exe携带.pdb调试信息或.pdb文件，才能解析到具体的代码崩溃行。这里介绍在visual studio里给Release工程，添加.pdb调试信息。比如，在VS2019里，给工程SqlOne添加Release版本的调试信息。
1 先切换到Release版本 点击VS工具栏的Release – 》OK，如图(1)所示，切换到Release版本
图(1) 切换到Release版本 2 在链接器里,勾选"生成调试信息" 在VS解决资源管理器里， 右击SqlOne工程 --》属性 --》链接器 --》调试 --》生成调试信息(/DEBUG) --》确定，如图(2)、图(3)所示：
图(2) 右击工程--》属性 图(3) 在链接里，启用"生成调试信息" 3 配置C/C++属性 1) 右击工程 --》属性–》【配置属性】–》C/C++ --》常规–》调试信息格式 ，勾选 用于"编辑并继续的程序数据库(/ZI)"–》确定，如图(4) 所示：
图(4) 选择 用于"编辑并继续的程序数据库(/ZI)" 2) 右击工程 --》属性–》【配置属性】–》C/C++ --》优化–》已禁用(/Od) --》确定，如图(5) 所示：
图(5) 在C/C++里，禁用"优化"选项 设置好之后，按Ctrl+Shift+B快捷键，编译该工程，在Release目录，得到与exe同名的.pdb文件，如图(6)所示：
图(6) 得到与exe同名的.pdb文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ead38caa4193cda08b63be9a6092ef8/" rel="bookmark">
			frp内网穿透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.工作原理2.配置2.1 服务端配置2.2 WINDOWS客户端配置 由于网络资源受限，部分服务器只有私网 IP ，没有公网 IP，即部分服务器无法被公网访问。但是有时我们需要通过公网对一些服务器进行访问，这样就出现了内网穿透。 1.工作原理 其本质是通过一台有公网 IP 的服务器，通过对应的协议和端口，和无公网服务器之间建立起一条虚拟隧道，达到让无公网 IP 的服务器也能被公网访问的目的。
2.配置 内网穿透有多个工具，具体参考：https://zhuanlan.zhihu.com/p/303175108 这里选择 frp 进行内网穿透，通过其工作原理可知，做内网穿透必须要有两台服务器：
具有公网 IP 的服务器（VPS），也叫服务端无公网 IP 的服务器（目标服务器），称为客户端，即目标的主机 2.1 服务端配置 下载对应的 frp 压缩包
官网链接：https://github.com/fatedier/frp/releases/
mkdir ~/frps cd ~/frps wget https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_linux_amd64.tar.gz 解压压缩包
tar -zxf frp_0.37.1_linux_amd64.tar.gz 修改配置文件
cd frp_0.37.1_linux_amd64 vi frps.ini frps.ini:
[common] bind_port = 7000 token = &lt;the conenntion passwd&gt; # dashboard相关配置，可以通过网页登录dashboard dashboard_port = 7500 dashboard_user = &lt;web interface login username&gt; dashboard_pwd = &lt;web user login password&gt; bind_port: 与客户端连接时的端口， 客户端和服务端的该地址需要一致
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ead38caa4193cda08b63be9a6092ef8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99ca583749b3884d7bee60abde73e9fd/" rel="bookmark">
			Ubuntu无法引导启动的修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TLDR：使用Boot-Repair工具。
Boot-Repair Boot-Repair是一个简单的工具，用于修复您在Ubuntu中可能遇到的常见启动问题，例如在安装Windows或其他Linux发行版后无法启动Ubuntu时，或者在安装Ubuntu后无法启动Windows时，或者当GRUB不再显示时，某些升级会破坏GRUB等。
引导修复允许您通过简单的单击来解决这些问题，这（通常重新安装 GRUB 并）恢复对问题之前已安装的操作系统的访问。
有2种修复方法，建议使用方法一，因为方法二的PPA经常不好访问。
软件界面如下：
方法1：获取包含启动修复的磁盘 使用引导修复的最简单方法是创建引导修复盘（自动启动引导修复的光盘）的实时 USB 磁盘，并在其上启动。
备注：建议将ISO安装在live-USB上（例如通过UnetBootin或LiliUSB或通用USB安装程序）。如果您的启动处于 EFI 模式，请不要将其刻录到 DVD 上。
方法2：在 Ubuntu 中安装引导修复 从 Ubuntu 实时会话（在 Ubuntu live-USB 上启动您的计算机，然后选择“试用 Ubuntu”）
连接到互联网
打开一个新的终端，然后键入以下命令：
sudo add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; sudo apt update sudo apt install -y boot-repair &amp;&amp; boot-repair Ref: https://help.ubuntu.com/community/Boot-Repair
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9d6d0f0b92b54490baaf7347ab08b2f/" rel="bookmark">
			13种改进粒子群优化算法 matlab2022 运行结果和耗时对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
阅读粒子群优化算法的文章，发现代码不仅要付费而且还没有运行结果，需要自己手动写代码运行，这里提供下我的运行结果。包含参数结果和耗时对比。
https://www.bilibili.com/read/cv11905136/?spm_id_from=333.999.0.0
% 定义适应度函数 fitness = @(x) x^6 - 3.5*x^4 + 4.3*x^3 + 2*x^2 + 0.8*x + 7; % 定义初始参数 N = 100; % 初始种群个数 c1 = 2.5; c2 = 1.6; w = 0.5; %权重 lamda = 0.5; % 退火参数 M = 100; % 迭代次数 D = 1; % 空间维数 c1max = 3; c1min = 0.3; c2max = 2; c2min = 0.2; wmax = 0.8; wmin = 0.3; mean_max = 5; mean_min = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9d6d0f0b92b54490baaf7347ab08b2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcf9a4df29463cca9c49d6a8710a001a/" rel="bookmark">
			【第11题】蒙地卡罗法求 PI-经典算法题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 说明 蒙地卡罗为摩洛哥王国之首都，该国位于法国与义大利国境，以赌博闻名。蒙地卡罗的基本原理为以乱数配合面积公式来进行解题，这种以机率来解题的方式带有赌博的意味，虽然在精确度上有所疑虑，但其解题的思考方向却是个值得学习的方式。
##解法
蒙地卡罗的解法适用于与面积有关的题目，例如求PI值或椭圆面积，这边介绍如何求PI值；假设有一个圆半径为1，所以四分之一圆面积就为PI，而包括此四分之一圆的正方形面积就为1，如下图所示：
如果随意的在正方形中投射飞标（点）好了，则这些飞标（点）有些会落于四分之一圆内，假设所投射的飞标（点）有n点，在圆内的飞标（点）有c点，则依比例来算，就会得到上图中最后的公式。
至于如何判断所产生的点落于圆内，很简单，令乱数产生X与Y两个数值，如果X2+Y2等于1就是落在圆内。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #define N 50000 int main(void) { int i, sum = 0; double x, y; srand(time(NULL)); for(i = 1; i &lt; N; i++) { x = (double) rand() / RAND_MAX; y = (double) rand() / RAND_MAX; if((x * x + y * y) &lt; 1) sum++; } printf("PI = %f\n", (double) 4 * sum / N); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09de9f0180eb5b43cffb00db60cd947f/" rel="bookmark">
			FPGA学习过程——如何写TestBench
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要如何编写TestBench1.准备好待仿真的模块2.编写TestbenchTestBench文件结构 名词解释1.仿真的单位和精度2.模块名3.变量的定义4.激励波形的产生例化待仿真模块 在vivado中如何编写testbench参考文献 概要 FPGA学习过程——如何写TestBench
由于在准备FPGA竞赛，因此打算恶补一下verilog的相关知识。本篇文章记录学习TestBench的心得，假如有错误的地方希望得到大佬指正。
编写 TestBench 是为了对设计的模块进行仿真验证，测试设计电路的功能、性能与设计的预期是否相符
如何编写TestBench 1.准备好待仿真的模块 以时序电路为例
module led_twinkle( input sys_clk , //系统时钟 input sys_rst_n, //系统复位，低电平有效 output [1:0] led //LED 灯 ); ...... //省略功能部分 endmodule 2.编写Testbench TestBench文件结构 注意注释，都是易错点
~timescale 1ns / 1ps //测试时间基本单位为1ns，精度为1ps module tb_led_twinkle(); //通常起名格式为 tb_被测试模块名 //输入 reg sys_clk; reg sys_rst_n; //输出 wire [1:0] led; //信号初始化，必须有这一步，容易被忽略 initial begin sys_clk = 1'b0; //系统时钟 sys_rst_n = 1'b0; // 系统复位 #200 //延时200ns sys_rst_n = 1'b1; end //生成时钟，模拟实际的周期时序 always #10 sys_clk = ~sys_clk; //每10ns，sys_clk进行翻转，周期为20ns //例化待测模块 led_twinkle u_led_twinkle( .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09de9f0180eb5b43cffb00db60cd947f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5688959df3055d926ab19595518a56f5/" rel="bookmark">
			Ubuntu 20.04 桌面美化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 20.04 桌面美化 Ubuntu 20.04 在 2020 年 4 月 28 日发布，距今已经快四个月了，我将自己的笔记本升级成 Ubuntu 20.04 操作系统了，Ubuntu 20.04 默认安装完成的桌面比较简单，如下图：
根据我个人的喜好，我会进行一系列的美化和优化，美化过的桌面看着非常漂亮，用着也得心应手。俗话说磨刀不误砍柴工，因为我日常工作使用的就是 Ubuntu 20.04 操作系统，所以安装完成后进行美化和优化算是让自己手中的工具更好用吧。先放一张美化完成的桌面截图吧。
下面开始正式的优化过程。
1、简单配置 1.1 登陆 Ubuntu 账号，开启 Livepatch 功能 Ubuntu 20.04 安装完成后会弹出登陆 Ubuntu 账号的提醒，如下图：
点击 Ubuntu Single-On 就会弹出登陆页面了，这里也可以先不登陆，直接点击跳过，后面再登陆。
也可以通过在已安装软件列表里面搜索 Software &amp; Updates 软件，如下图，打开后登陆 Ubuntu 账号。
切换到如下图的界面，点击 Sign In… 进行登陆。
如上图，点击 Sign In / Register 后，如果有账号就直接登陆，没有账号的话就安装提示注册一个账号。这里先说一下为什么要登陆 Ubuntu 账号，不登陆不行吗？答案是建议登陆，因为 Ubuntu 官方通过 livepatch 的方式为 Ubuntu 20.04 提供安全补丁的更新，只要登陆了账号，并打开 use Livepatch，当有补丁更新的时候，操作系统就会自动更新，不需要我们手动去更新。所以你如果不登陆的话，也是可以的，只是有补丁的时候需要手动去安装。
输入密码登陆成功后会弹出如下页面：
提示我们是否使用当前登陆的 Ubuntu 账户来应用 Ubuntu Livepatch，我们当然是要应用，所以点击 continue，然后会让输入登陆系统的密码，输入完成后就能看到如下界面，可以看到 Livepatch 的开关已经打开了，说明 Livepatch 功能已经开启了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5688959df3055d926ab19595518a56f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b5da04312c0f46b707d293d0fea148/" rel="bookmark">
			【C&#43;&#43;】标准库 - 文件的读写 ifstream, ofstream, fstream
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C++】标准库 - 文件的读写 ifstream, ofstream, fstream 文章目录 【C++】标准库 - 文件的读写 ifstream, ofstream, fstream一、概述二、打开文件2.1 - ifstream 打开文件2.2 - ofstream 打开文件2.3 - fstream 以读取和写入的方式打开 三、读取和写入文本文件3.1 - 读取文件内容3.1.1 - getline3.1.2 - get3.1.3 - &gt;&gt; 3.2 - 写入文件3.2.1 - &lt;&lt;3.2.2 - put 四、文件中的位置4.1 - 知悉指针当前的位置4.2 - 移动指针位置 五、一些实用的方法5.1 - eof5.2 - ignore5.3 - clear5.4 - fail 六、参考链接 一、概述 网上关于使用 C++ 读写文件的内容不是所期待的，所以来写一下。
无论是读文件还是写文件，首先需要打开文件，需要使用两个类
ifstream (Input File stream) 用于读取ofstream (Output File stream) 用于写入 这两个类继承自 std::io_base 用于处理 io 流。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b5da04312c0f46b707d293d0fea148/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a27209a05dd773c4452005372dddda7/" rel="bookmark">
			MySQL：温备份和恢复-mysqldump （4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 温备：同样是在数据库运行的时候进行备份的，但对当前数据库的操作会产生影响。（只可以读操作，不可以写操作）
温备份的优点：
1.可在表空间或数据文件级备份，备份时间短。
2.备份时数据库依然可以使用。
3.可达到秒级恢复，能够恢复到某一个时间点上。
4.恢复的速度很快，在大多数情况下在数据库工作时就可恢复。
5.几乎所有的数据库实体都可以进行恢复。
温备份的缺点:
1.尽量不要出错，否则后果会很严重。
2.如果热备份不成功，所得结果不可用于时间点的数据恢复。
3.维护的工作比较困难。
物理备份：
直接复制数据文件进行的备份
优点：不需要其他的工具，直接复制就好，恢复直接复制备份文件即可
缺点：与存储引擎有关，跨平台能力较弱
逻辑备份：
从数据库中导出数据另存而进行的备份
优点：能使用编辑器处理，恢复简单，能基于网络恢复，有助于避免数据损坏
缺点：备份文件较大，备份较慢，无法保证浮点数的精度，使用逻辑备份数据恢复后，还需要手动重建索引，十分消耗cpu资源。 正题 备份操作
格式1：备份指定库中的部分表
mysqldump [选项] 库名 [表名1] [表名2] … &gt; /备份路径/备份文件名
格式2：备份一个或多个完整的库
mysqldump [选项] --databases 库名1 [库名2] … &gt; /备份路径/备份文件名
格式3：备份所有的库
mysqldump [选项] --all-databases &gt; /备份路径/备份文件名
常用的选项包括-u、-p
-u、指定数据库用户名
-p 指定用户密码
--opt 当导出数据量较大的时候，可以优化执行速度
备份 mysqldump -uroot -p mysql user &gt; /backup/mysql-user.sql 这个意思是把mysql库中的user表备份到/back-user.sql中
mysqldump -uroot -p --databases test &gt; /backup/test.sql 把test库备份到/backup/test.sql
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a27209a05dd773c4452005372dddda7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452273b07bd70ac79ce4fb98a192a05f/" rel="bookmark">
			CSS 实现：常见布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 设备与视口 设备屏幕尺寸是指屏幕的对角线长度。像素是计算机屏幕能显示一种特定颜色的最小区域，分为设备像素和逻辑像素。
在 Apple 的视网膜屏（Retina）中，默认每 4 个设备像素为一组，渲染出普通屏幕中一个像素显示区域内的图像，即 1 CSS 像素跨越 2设备像素，从而实现更为精细的显示效果。如果用户进行放大，一个 CSS 像素还将跨越更多的物理像素。屏幕可显示的像素越多，同样的屏幕区域内能显示的信息也越多。
图像分辨率是单位英寸中所包含的像素点数，单位是 PPI（Pixels Per Inch）表示每英寸所拥有的像素数目，即像素密度。
设备像素比是默认缩放为 100% 的情况下，设备像素和逻辑像素的比值，即设备像素比 DPR = 物理像素数 / 逻辑像素数。设备像素比可以通过 window.devicePixelRatio 来获取。
Web 浏览器包含两个视口，布局视口（layout viewport）和可视视口（visual viewport）。可视视口指当前浏览器中可见的部分，不包括屏幕键盘、缩放外的区域，并且可以变化。当使用键盘对页面进行缩放时，操作的时布局视口。而当使用双指缩放，或键盘在手机上弹出的时候，或者之前隐藏的地址栏变得可见的时候，可视视口缩小了，但是布局视口却保持不变。可视视口要么跟布局视口相同，要么更小。
CSS 像素单位表示的布局视口宽高获取：
移动设备的布局视口的默认值为 980px，比如在一个宽 320px 的移动设备显示一个布局视口宽为 980px 的页面，移动设备浏览器会对这个页面进行缩放直至其布局视口宽度为 320px，使得缩放后的页面显示效果都不会很理想。使用 &lt;meta&gt; 标签可以显式设置布局视口的宽度： 2 三栏布局 指实现两侧栏固定宽度，中间栏自适应。
浮动（float）实现：
第一个为左栏元素左浮动 float: left 和设置固定宽度 width；
第二个为右栏元素右浮动 float: right 和设置固定宽度 width；
最后一个为中间栏元素设置外边距 margin = 左或右的固定宽度 + 额外外边距：
&lt;style&gt; .left, .right, .center { height: 100%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452273b07bd70ac79ce4fb98a192a05f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db88daa02701ee198c0f621dad1dba32/" rel="bookmark">
			npx create-react-app报错ENOENT: no such file or directory, lstat....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题重现： 在对应的文件夹命令行里输入了npx create-react-app react-rmdb，结果报错
ENOENT: no such file or directory, lstat....
问题解决及原因： 1. npm 安装不完整或损坏，首先尝试升级或重新安装 npm，以确保是最新版本且完整：
npm install -g npm@latest 2.检查权限，确保可以有权限访问：C:\Users\...\AppData\Roaming\npm目录，重新尝试管理员身份运行npx create-react-app react-rmdb，或者确保有读写权限
3.清除磁盘并且重新尝试
npm cache clean -f 4.检查npn的环境变量，确保有了 npm 的安装路径
补充一个检查是否安装Node.js 和 npm 命令 1. 检查 Node.js 的版本
node -v 2.检查npm 版本
npm -v 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e93456b603b42e40147b5904fe8306/" rel="bookmark">
			基础教程：5、图解Linux下JDK安装与环境变量配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		短网址：http://x.co/6nc86
5.1 下载JDK8 （1）百度搜索“jdk8”第一条结果就是JDK下载地址
（2）接受协议，单击下载
（3）JDK的上传到Linux服务器
首先，通过XShell连接远程服务器；
然后，单击工具栏中的xftp图标，如下图所示；
最后，将已经下载的Linux版的JDK8软件包文件从左边拖到右边即可
5.2 加压缩 （1）查看刚上传的软件包
（2）加压缩到指定目录
[root@node1 ~]# tar -zxvf jdk-8u192-linux-x64.tar.gz -C /opt （3）查看JDK目录
复制JDK根目录/opt/jdk1.8.0_192，下面配置环境变量需要用到。
5.3 配置JDK环境变量 （1）编辑JDK环境变量
[root@node1 ~]# vi /etc/profile.d/custom.sh 编辑内容如下
[root@node1 ~]# cat /etc/profile.d/custom.sh #!/bin/bash #java path export JAVA_HOME=/opt/jdk1.8.0_192 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib [root@node1 ~]# 其中，
JAVA_HOME表示Java的家目录 PATH=$PATH:$JAVA_HOME/bin表示在原来PATH环境变量的基础上增加JDK的bin目录路径，其中英文冒号是分隔符。CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib表示在原来的CLASSPATH环境变量基础上增加当前目录(.表示当前目录)和JDK的lib目录。 （2）使生效
[root@node1 ~]# source /etc/profile.d/custom.sh 或
[root@node1 ~]# source /etc/profile 5.4 测试JDK环境 （1）测试javac命令
[root@node1 ~]# javac （2）查看JDK版本号
[root@node1 ~]# java -version 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91e93456b603b42e40147b5904fe8306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22088f9f741a01ad504cce0f7590504a/" rel="bookmark">
			CentOs8安装Mysql8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOs8安装Mysql8.x 简介安装环境介绍1. 下载1.1. 在MYSQL官网找到社区版下载地址1.2. 在MYSQL社区版下载网页中选择你的操作系统及安装系统版本 2. 安装2.1. 解压与配置环境变量。2.2. 初始化数据库、启动数据库、登录数据库、修改密码。 3. 配置自动启动[非必选]4. 配置本机访问远程服务器上的mysql服务[非必选]4.1. 关闭防火墙对mysql端口的限制4.2. 在服务器上修改或创建一个可以支持远程访问的账号4.3. 在本地机器上连接服务器上的mysql服务 简介 在CentOs下安装Mysql8非常简单，只需要下载、安装、配置自动启动这三个步骤即可。配置自动启动是可选项，一般来说都需要设置自动启动。
安装环境介绍 笔者使用的是xx云服务器厂商的轻量应用服务器。内置了兼容CentOS8系统的Linux操作系统。在安装时找不到CentOS8，所以笔者就安装此系统将他当作CentOS8使用。
1. 下载 找到对应系统的安装包的下载链接后，可通过shell工具上传，也可直接在linux端使用wget命令直接下载至指定目录。
1.1. 在MYSQL官网找到社区版下载地址 打开mysql官网点击头部导航中的Downloads栏打开下载界面。
点击MySQL Community (GPL) Downloads »进入Mysql社区版的下载界面
今天我们要安装的是Mysql服务器，所以选择列表中的 MySQL Community Server 项目
1.2. 在MYSQL社区版下载网页中选择你的操作系统及安装系统版本 这里我的系统为x86的64位的linux系统。所以选择Linux - Generic后选择列表中的第一项进行下载
点击右侧的download按钮进入下载登录页，后选择底部的 No thanks, just start my download.链接进行下载。
注：此时下载的包会在你的电脑中，可自行选择shell工具进行上传，也可从浏览器中提取下载地址后在linux使用wget命令直接下载至linux端中。
这里提供笔者的下载地址：https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.33-linux-glibc2.28-x86_64.tar.gz
在linux中直接下载使用wget命令，可将安装包下载至当前目录。
wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.33-linux-glibc2.28-x86_64.tar.gz 2. 安装 安装主要将刚下载的安装包进行解压、然后配置环境变量让linux可以直接执行命令、最后初始化数据库并修改初始账号的密码后就能正常使用啦。
2.1. 解压与配置环境变量。 按照上面下载的步骤将安装包放到我们要安装的机器上后，使用tar命令将他解压至/usr/local目录中，并修改解压后的目录名称。
因为在后面要运行的脚本中，默认都指定安装目录是/usr/local/mysql这个位置，为了不必要的麻烦，我们就直接安装在这了。
# 解压至指定目录。这里需要注意。笔者的安装包是这个，各位读者需要自己注意安装包名称是否一致。 # 这里不展开说明tar命令了。各位同好有兴趣自己浏览。 tar -zvxf mysql-8.0.33-linux-glibc2.28-x86_64.tar.gz -C /usr/local # 修改mysql目录名称。 mv /usr/local/mysql-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22088f9f741a01ad504cce0f7590504a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3751f921e8317de6189508e138d318/" rel="bookmark">
			Gallery2分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文分析的代码基于 Android 4.x
文章目录 Gallery2介绍基本数据数据源DataManager数据管理LocalSource本地数据源Media数据的加载过程Gallery2页面结构ActivityStateStateManagerGalleryAppImplAbstractGalleryActivityGalleryActivityAlbumSetPage数据加载和渲染过程分析第四步 获得 AlbumSet 数据后，渲染器开始渲染 SlotView ThreadPool 线程池 Gallery2介绍 Gallery2主要功能是实现Android系统本地存储以及网络存储中的媒体（图片&amp;视频）资源的浏览，媒体信息，显示和更多操作（删除、分享、选择、缩放、编辑等）。
Gallery2界面的生成和普通的应用程序不同，普通应用程序一般就一个界面对应一个activity，搭配布局xml或代码来实现界面的显示，而Gallery2没有用到android的UI系统，而是通过openGL画出来，只用到了一个acitivity.、
Android4.x后的Gallery2的主要组成有：
①AlbumSetPage 所有专辑界面，点击Gallery图标后进入图库所显示的第一个页面；
②AlbumPage 单个专辑界面，AlbumSetPage的一个子集，显示该专辑内的所有图片，专辑通过文件夹来区分；
③PhotoPage 单张图片界面，可用通过AlbumPage进入，也可以通过外部调用浏览单张图片。
基本数据 Gallery2中描述单个媒体对象的数据结构图如下：
Gallery2中描述一组媒体对象的数据结构图如下：
MediaObject 数据渲染的最小单位，它包含丰富的衍生类。MediaObject定义了媒体数据最基本的信息，如SupportedOperations，SupportedOperations定义这个媒体文件支持的操作，如是否可以delete/share/rotate等。定义了最基本的Path路径，用于表示媒体对象的存储地址;
MediaItem MediaObject的衍生类，MediaObject的封装，是单个媒体的抽象，代表一张图片或者一个视频。在此抽象类中，定义getMimeType()/getWitdh()/getHeight()等抽象方法。;
LocalMediaItem MediaItem的衍生类，对本地MediaItem的抽象，代表一张本地图片或者一个本地视频。在此抽象类中，添加定义了bucketId/dataDirty; bucketId由文件夹的绝对路径的hashCode来表示，代表一个专辑，是专辑的索引。通过GalleryUtils的getBucketId可以获得传入路径的bucketId。
LocalImage LocalMediaItem的子类，表示一个本地存储的图片。内部定义了一个ITEM_PATH=“/local/image/item”。首先LocalImage的初始化有两种，一种是通过直接传入cursor对象来初始化这个Image对象，另外一种是通过传入id的形式来查询外部存储的数据库，得到cursor，进而初始化这个Image对象。
MediaSet 和MediaItem一样是MediaObject的衍生类，是一个类目录的数据结构，是一组媒体文件的抽象。它提供的主要基础接口有getMediaItemCount, getMediaItem, getSubMediaSetCount, getSubMediaSet, getTotalMediaItemCount. 还定义了getCoverMediaItem来获得一组图片或视频的封面。
LocalAlbumSet 继承于MediaSet，是所有图片和视频专辑的集合。其内部定义了三个path,分别是PATH_ALL,PATH_IMAGE,PATH_VIDEO.其内部定义了mAlbums用来保存专辑列表。LocalAlbumSet是AlbumSetPage的单位。
LocalAlbum 继承于MediaSet，代表一个bucket（目录）下的所有的media items。提供MediaItem的查询，删除等操作。LocalAlbum是AlbumPage的单位。
数据源 Gallery2中引入数据源的概念，由DataManager负责管理，目的是在不同的显示界面，能通过DataManager获得一个合适的数据源来初始化自己的数据。Gallery2中主要定义的数据源有ComboSource（组合源）, PicasaSource（Picasa源）,LocalSource（本地源）, ClusterSource（簇源）, UriSource（URL源）,FilterSource（过滤源）。这些数据源有一个共同的基类MediaSource, MediaSource是对数据源的抽象，它里面主要定义了数据源的基本组成，如定义了数据源的唯一标识prefix, prefix后面会讲到。
DataManager数据管理 在详细分析数据源的组成结构之前，首先来分析下DataManager。DataManager是用来管理整个系统中的所有media sets（集合）和media item。DataManager在Gallery Application启动时就创建并且初始化，可以通过GalleryAppImpl的getDataManager方法来获得DataManager实例，DataManager的初始化做了以下事情：
addSource(new LocalSource(mApplication)); addSource(new PicasaSource(mApplication)); addSource(new ComboSource(mApplication)); addSource(new ClusterSource(mApplication)); addSource(new FilterSource(mApplication)); addSource(new UriSource(mApplication)); 可以看出，DataManager实例化的同时也创建了所有数据源实例，并把它们加入自身维护的一个SourceMap中，提供存取操作。SourceMap中保存的索引是上面讲到的prefix。Prefix是数据源的唯一标识，在数据源的构造方法中赋值。如LocalSource的prefix为”local”， ComboSource的prefix为”combo”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce3751f921e8317de6189508e138d318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5986609986b07bbd0d96663ef72f9faf/" rel="bookmark">
			谈谈SSAID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SSAID简介参考 SSAID简介 以下内容转载自 https://qa.1r1g.com/sf/ask/3948431441/
Android 开发人员文档（针对 API &gt; 26）说明了有关ANDROID_ID的以下内容：
在 Android 8.0（API 级别 26）和更高版本的平台上，一个 64 位数字（表示为十六进制字符串），对于应用签名密钥、用户和设备的每个组合都是唯一的。ANDROID_ID 的值受签名密钥和用户的限制。如果在设备上执行恢复出厂设置或 APK 签名密钥更改，则该值可能会更改。
博客文章中还有以下内容：
在 O 中，Android ID（Settings.Secure.ANDROID_ID 或 SSAID）对于每个应用程序和设备上的每个用户都有不同的值。需要设备范围标识符的开发人员应改用可重置的标识符，例如广告 ID，为用户提供更多控制权。广告 ID 还提供面向用户的设置以限制广告跟踪。另外在 Android O 中：
只要软件包名称和签名密钥相同，ANDROID_ID 值在软件包卸载/重新安装时就不会改变。应用程序可以依靠此值在重新安装时保持状态。
如果应用安装在运行较早版本 Android 的设备上，当设备更新到 Android O 时，Android ID 保持不变，除非卸载并重新安装该应用。
仅当设备恢复出厂设置或签名密钥在卸载和重新安装事件之间轮换时，Android ID 值才会更改。
此更改仅适用于随附 Google Play 服务和广告 ID 的设备制造商。其他设备制造商可能会提供替代的可重置 ID 或继续提供 ANDROID ID。
而且，查看了计算SSAID的SettingsProvider.java的源码，好像流程如下：
每个设备用户都被分配了一个 32 字节的随机密钥。对于每个 APK：带有 sha256 的 hmac 用于计算 APK 签名者密钥的 SSAID（其中使用的密钥是在步骤 1 中生成的密钥）。hmac 被截断为 16 个字符。截断的值被保存到settings_ssaid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5986609986b07bbd0d96663ef72f9faf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/290b9e636790eb6770b14cdab9e619f9/" rel="bookmark">
			Context应用上下文理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Context相关类的继承关系Context类ContextIml.java类ContextWrapper类ContextThemeWrapper类 二、 什么时候创建Context实例创建Context实例的时机 小结 Context类 ，说它熟悉，是应为我们在开发中时刻的在与它打交道，例如：Service、BroadcastReceiver、Activity等都会利用到Context的相关方法。
下面开始分析和理解Context上下文的实现原理。
Context，中文直译为“上下文”，SDK中对其说明如下：
Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc
从上可知一下三点,即：
1. 它描述的是一个应用程序环境的信息，即上下文。
2. 该类是一个抽象(abstract class)类，Android提供了该抽象类的具体实现类(后面我们会讲到是ContextIml类)。
3. 通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作，例如：启动一个Activity，发送广播，接受Intent信息等。
于是，我们可以利用该Context对象去构建应用级别操作(application-level operations) 。
一、Context相关类的继承关系 Context类 路径： /frameworks/base/core/Java/android/content/Context.java
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/290b9e636790eb6770b14cdab9e619f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c74aa005efdd04dd9a3570cb6dd42ed6/" rel="bookmark">
			学习编程，框架真的那么重要吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编程世界常常被各种框架所包围，从前端到后端，从移动应用到大数据处理，似乎每个领域都有一套独特的框架等待着你去学习。其实，框架并不是编程的全部，也不是学习编程的必备条件。小狮妹将告诉你如何正确看待框架，以及如何有效地学习框架。
编程的基础才是最重要的
框架只是编程的一部分，而不是全部。如果你想成为一名优秀的程序员，你首先要有扎实的编程基础。这包括：
掌握至少一种编程语言，比如Python、Java、C++等
了解数据结构和算法，比如数组、链表、排序、搜索等
理解计算机原理，比如内存管理、操作系统、网络通信等
这些基础知识是编程技能的根本，它们可以让你更好地理解和解决问题。没有这些基础知识，学习框架就像盲人摸象，只能看到表面，而不知道内在。
框架是什么？
什么是框架？框架其实就是一种工具，它可以帮助我们快速地解决一类特定的问题。比如如果我们想要开发一个网站，我们可以使用前端框架（比如React或Vue）来构建网页界面，使用后端框架（比如Django或Express）来处理数据和逻辑。
小狮妹再举几个例子：
React和Vue是前端框架，它们可以让你更方便地创建动态的网页界面
Django和Express是后端框架，它们可以让你更容易地处理服务器端的逻辑和数据
TensorFlow和PyTorch是机器学习框架，它们可以让你更高效地实现人工智能的模型和应用
有了框架，我们就不需要从零开始编写所有的代码，而是可以利用框架提供的模板和功能，节省时间和精力。
框架有什么优点？
那么，框架有什么优点呢？框架的优点主要有以下几个：
提高效率：框架可以让我们专注于解决问题的核心部分，而不需要关心细节和重复的工作。框架通常已经经过了优化和测试，可以保证代码的质量和性能。框架还可以让我们更容易地复用和维护代码，提高开发效率。
规范标准：框架可以让我们遵循一定的规范和标准，使得代码更加统一和规范。这样，我们就可以更容易地与其他开发者协作和交流，也可以更容易地阅读和理解代码。框架还可以让我们避免一些常见的错误和漏洞，提高代码的安全性。
拓展功能：框架可以让我们拓展代码的功能和适应性，使得代码更加强大和灵活。框架通常提供了丰富的库和插件，可以让我们轻松地实现各种功能和效果。框架还可以让我们适应不同的平台和设备，使得代码更加兼容和可移植。
框架有什么缺点？
当然，框架也不是完美的，它也有一些缺点，比如：
增加复杂度：框架虽然可以简化问题的解决过程，但也会增加问题的复杂度。框架通常包含了很多配置文件和依赖项，这些都需要我们花费时间去学习和理解。如果我们不熟悉框架的原理和机制，我们可能会遇到一些难以解决的问题或错误。
降低灵活性：框架虽然可以规范代码的标准和风格，但也会降低代码的灵活性。框架通常会限制我们使用特定的语言或技术，这些可能不一定适合我们的需求或喜好。如果我们想要自定义或修改某些功能或效果，我们可能会受到框架的约束或影响。
过度依赖：框架虽然可以拓展代码的功能和适应性，但也会让我们过度依赖框架。如果我们只会使用框架，而不会编写原生的代码，我们就会失去一些基本的编程能力和知识。如果框架发生了变化或失效，我们就会陷入困境，无法应对新的挑战。
如何正确看待框架？
综上所述，框架是一种有利有弊的工具，它并不是编程的全部，也不是学习编程的必备条件。那么，我们应该如何正确看待框架呢？我认为，我们应该遵循以下几个原则：
基本功为先：框架只是工具，而不是目的。我们学习编程的目的是为了解决问题，而不是为了使用框架。因此，我们应该先建立坚实的基本功，掌握编程语言、数据结构、算法等基础知识，这些才是编程技能的基石。
选择性学习：并不是所有的框架都必须掌握。我们应该根据自己的项目需求和兴趣，选择适合自己的框架。我们可以先试用一些框架，比较它们的优缺点，然后选择最合适的那个。我们也可以根据自己的水平和进度，适时地学习新的框架。
深入理解：如果我们决定学习某个框架，我们应该深入理解它的原理和机制，而不仅仅是学习配置文件。这样，我们才能真正掌握框架的精髓，而不会被表象所迷惑。这样，我们也能更好地利用框架的优势，避免框架的缺陷。
学习编程，并不必须要掌握各种框架。框架只是一种工具，而不是一种知识。我们应该以基本功为先，选择性学习，深入理解。
希望这篇文章能让你对框架有更深的理解，如果你想学习编程，小编这次带来的，是从朋友那里薅到的一套完整的学习路线图，以及配套学习资料，它涵盖了Python学习的方方面面，且文献全彩，字迹清晰，很适合我们学习观看。
下面来看看资料详细内容：
一、Python基础 基础真的蛮重要的，因为Python的易应用性很容易让大家产生我什么都会了的感觉，但实际上还是不怎么会。
相关的视频学习资料：
二、爬虫阶段 应该有很多人都对爬虫感兴趣吧？
爬虫不只是爬虫工程师会用到，业余时间也可以用来爬点自己想要的东西，又或者是做兼职也是可以的，比如日常办公自动化、电商抓取商品信息、分析销售数据做报表等等。
大部分爬虫都是按“发送请求——获得页面——解析页面——抽取并储存内容”这样的流程来进行，这其实也是模拟了我们使用浏览器获取网页信息的过程。
所以爬虫的简要学习路径大概有：
学习 Python 包并实现基本的爬虫过程了解非结构化数据的存储学习scrapy，搭建工程化爬虫学习数据库知识，应对大规模数据存储与提取掌握各种技巧，应对特殊网站的反爬措施分布式爬虫，实现大规模并发采集，提升效率 相关的视频学习资料：
三、Python数据分析 数据分析也是当下的一大热门方向，用Python来做的话比其他语言强很多。
但往往只会数据分析还是差点意思，如果能具备爬虫能力来爬取数据就更好了。（分析爬虫抓取的数据，分析规律，用于商业化）
相关的学习资料：
四、数据库与ETL数仓 企业需要定期将冷数据从业务数据库中转移出来存储到一个专门存放历史数据的仓库里面，各部门可以根据自身业务特性对外提供统一的数据服务，这个仓库就是数据仓库。
传统的数据仓库集成处理架构是ETL，利用ETL平台的能力，E=从源数据库抽取数据，L=将数据清洗（不符合规则的数据）、转化（对表按照业务需求进行不同维度、不同颗粒度、不同业务规则计算进行统计），T=将加工好的表以增量、全量、不同时间加载到数据仓库。
相关的学习资料：
五、Python机器学习 现在不是各种吹人工智能么，机器学习就是人工智能的一个分支，它的应用太广泛了，比如自然语言处理，搜索引擎，各种识别技术，数据挖掘等等。
这难度不用我多说了吧，不会点算法就别碰，一碰就是各种高斯过程回归、线性判别分析、决策树、线性回归…
相关的学习资料：
上述这份完整版的Python全套学习资料已经打包好了，需要的小伙伴可以评论留言或者找我领取
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/80/">«</a>
	<span class="pagination__item pagination__item--current">81/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/82/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>