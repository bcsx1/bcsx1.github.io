<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cedb7958d604c44b6632014ba7bcb0/" rel="bookmark">
			原始类型与封装类的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。
Java中包含三种引用类型即为数组，类，接口, Java得三种引用类型，储存在引用类型变量中的值是该变量表示的值的地址”。最大的区别：值类型的变量存放在栈里；引用类型的数据存放在堆中。
具体区别：
1、值类型继承自ValueType（注意：而System.ValueType又继承自System.Object）；而引用类型继承自System.Object。
3、值类型的内存不由GC（垃圾回收，Gabage Collection）控制，作用域结束时，值类型会自行释放，减少了托管堆的压力，因此具有性能上的优势。例如，通常struct比class更高效；而引用类型的内存回收，由GC来完成。
4、值类型是密封的（sealed），因此值类型不能作为其他任何类型的基类，但是可以单继承或者多继承接口；而引用类型一般都有继承性。
5、值类型不具有多态性；而引用类型有多态性。
6、值类型有两种状态：装箱和未装箱，运行库提供了所有值类型的已装箱形式；而引用类型通常只有一种形式：装箱。（装箱和取消装箱的概念是 C# 的类型系统的核心。它在“值类型”和“引用类型”之间的架起了一座桥梁，使得任何“值类型”的值都可以转换为 object 类型的值[装箱]，反过来转换也可以。其中任何类型的值最终都可以按对象处理。）
Int是java的原始数据类型，Integer是java为int提供的封装类。Java为每个原始类型提供了封装类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/046b5564c83783ce6f5f5d59c533e3c9/" rel="bookmark">
			RTMPdump（libRTMP） 源代码分析 10： 处理各种消息（Message）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
RTMPdump(libRTMP) 源代码分析系列文章：
RTMPdump 源代码分析 1： main()函数
RTMPDump (libRTMP) 源代码分析2：解析RTMP地址——RTMP_ParseURL()
RTMPdump (libRTMP) 源代码分析3： AMF编码
RTMPdump (libRTMP) 源代码分析4： 连接第一步——握手 (HandShake)
RTMPdump (libRTMP) 源代码分析5： 建立一个流媒体连接 (NetConnection部分)
RTMPdump (libRTMP) 源代码分析6： 建立一个流媒体连接 (NetStream部分 1)
RTMPdump (libRTMP) 源代码分析7： 建立一个流媒体连接 (NetStream部分 2)
RTMPdump (libRTMP) 源代码分析8： 发送消息 (Message)
RTMPdump (libRTMP) 源代码分析9： 接收消息 (Message) (接收视音频数据)
RTMPdump (libRTMP) 源代码分析10： 处理各种消息 (Message)
=====================================================
函数调用结构图 RTMPDump (libRTMP)的整体的函数调用结构图如下图所示。
单击查看大图
详细分析 已经连续写了一系列的博客了，其实大部分内容都是去年搞RTMP研究的时候积累的经验，回顾一下过去的知识，其实RTMPdump（libRTMP）主要的功能也都分析的差不多了，现在感觉还需要一些查漏补缺。主要就是它是如何处理各种消息（Message）的这方面还没有研究的特明白，在此需要详细研究一下。 再来看一下RTMPdump（libRTMP）的“灵魂”函数RTMP_ClientPacket()，主要完成了各种消息的处理。
//处理接收到的数据 int RTMP_ClientPacket(RTMP *r, RTMPPacket *packet) { int bHasMediaPacket = 0; switch (packet-&gt;m_packetType) { //RTMP消息类型ID=1,设置块大小 case 0x01: /* chunk size */ //---------------- r-&gt;dlg-&gt;AppendCInfo("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/046b5564c83783ce6f5f5d59c533e3c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5f5405c953723835d3cd1f2e5c88b8/" rel="bookmark">
			RTMPdump（libRTMP） 源代码分析 9： 接收消息（Message）（接收视音频数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
RTMPdump(libRTMP) 源代码分析系列文章：
RTMPdump 源代码分析 1： main()函数
RTMPDump (libRTMP) 源代码分析2：解析RTMP地址——RTMP_ParseURL()
RTMPdump (libRTMP) 源代码分析3： AMF编码
RTMPdump (libRTMP) 源代码分析4： 连接第一步——握手 (HandShake)
RTMPdump (libRTMP) 源代码分析5： 建立一个流媒体连接 (NetConnection部分)
RTMPdump (libRTMP) 源代码分析6： 建立一个流媒体连接 (NetStream部分 1)
RTMPdump (libRTMP) 源代码分析7： 建立一个流媒体连接 (NetStream部分 2)
RTMPdump (libRTMP) 源代码分析8： 发送消息 (Message)
RTMPdump (libRTMP) 源代码分析9： 接收消息 (Message) (接收视音频数据)
RTMPdump (libRTMP) 源代码分析10： 处理各种消息 (Message)
=====================================================
函数调用结构图 RTMPDump (libRTMP)的整体的函数调用结构图如下图所示。
单击查看大图
详细分析 前一篇文章分析了RTMPdump（libRTMP） 的发送消息（Message）方面的源代码：RTMPdump（libRTMP） 源代码分析 8： 发送消息（Message）
在这里在研究研究接收消息（Message）的源代码，接收消息最典型的应用就是接收视音频数据了，因为视频和音频分别都属于RTMP协议规范中的一种消息。在这里主要分析接收视音频数据。
RTMPdump中完成视音频数据的接收（也可以说是视音频数据的下载）的函数是：RTMP_Read()。
RTMPdump主程序中的Download()函数就是通过调用RTMP_Read()完成数据接收，从而实现下载的。
那么我们马上开始吧，首先看看RTMP_Read()函数：
//FLV文件头 static const char flvHeader[] = { 'F', 'L', 'V', 0x01, 0x00,	/* 0x04代表有音频, 0x01代表有视频 */ 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00 }; #define HEADERBUF	(128*1024) int RTMP_Read(RTMP *r, char *buf, int size) { int nRead = 0, total = 0; /* can't continue */ fail: switch (r-&gt;m_read.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce5f5405c953723835d3cd1f2e5c88b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9ee631a002e6e7762f3eb6bbca7c76/" rel="bookmark">
			RTMPdump（libRTMP） 源代码分析 8： 发送消息（Message）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		=====================================================
RTMPdump(libRTMP) 源代码分析系列文章：
RTMPdump 源代码分析 1： main()函数
RTMPDump (libRTMP) 源代码分析2：解析RTMP地址——RTMP_ParseURL()
RTMPdump (libRTMP) 源代码分析3： AMF编码
RTMPdump (libRTMP) 源代码分析4： 连接第一步——握手 (HandShake)
RTMPdump (libRTMP) 源代码分析5： 建立一个流媒体连接 (NetConnection部分)
RTMPdump (libRTMP) 源代码分析6： 建立一个流媒体连接 (NetStream部分 1)
RTMPdump (libRTMP) 源代码分析7： 建立一个流媒体连接 (NetStream部分 2)
RTMPdump (libRTMP) 源代码分析8： 发送消息 (Message)
RTMPdump (libRTMP) 源代码分析9： 接收消息 (Message) (接收视音频数据)
RTMPdump (libRTMP) 源代码分析10： 处理各种消息 (Message)
=====================================================
函数调用结构图 RTMPDump (libRTMP)的整体的函数调用结构图如下图所示。
单击查看大图
详细分析 之前写了一系列的文章介绍RTMPDump各种函数。比如怎么建立网络连接（NetConnection），怎么建立网络流（NetStream）之类的，唯独没有介绍这些发送或接收的数据，在底层到底是怎么实现的。本文就是要剖析一下其内部的实现。即这些消息（Message）到底是怎么发送和接收的。 先来看看发送消息吧。
发送connect命令使用函数SendConnectPacket()发送createstream命令使用RTMP_SendCreateStream()发送realeaseStream命令使用SendReleaseStream()发送publish命令使用SendPublish()发送deleteStream的命令使用SendDeleteStream()发送pause命令使用RTMP_SendPause() 不再一一例举，发现函数命名有两种规律：RTMP_Send***()或者Send***()，其中*号代表命令的名称。
SendConnectPacket()这个命令是每次程序开始运行的时候发送的第一个命令消息，内容比较多，包含了很多AMF编码的内容，在此不多做分析，贴上代码：
//发送“connect”命令 static int SendConnectPacket(RTMP *r, RTMPPacket *cp) { RTMPPacket packet; char pbuf[4096], *pend = pbuf + sizeof(pbuf); char *enc; if (cp) return RTMP_SendPacket(r, cp, TRUE); packet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f9ee631a002e6e7762f3eb6bbca7c76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6de8dd1515cc6659916d03f202f6f8b/" rel="bookmark">
			校园导游图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此篇博客有合作三人完成
主要涉及无线网创建和单源最短路径问题
设计要求：设计我们学校的平面图，至少包括10个以上的场所，每两个场所间可以有不同的路，且路长也可能不同，找出从任意场所到达另一场所的最佳路径（最短路径）。
基本要求：
1）设计校园平面图，在校园景点选10个左右景点。以图中顶点表示校园内各景点，存放景点名称、代号、简介等信息；以边表示路径，存放路径长度等有关信息。
2）为来访客人提供图中任意景点相关信息的查询。
3）为来访客人提供任意景点的问路查询，即查询任意两个景点之间的一条最短路径。
实现提示：一般情况下，校园的道路是双向通行的，可设计校园平面图是一个无向网。顶点和边均含有相关信息。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define OK 1 #define ERROR -1 #define OVERFLOW 0	#define MAXVER 20	//定义最大定点数 #define MAXINT 200	// 无穷大 #define NULL 0 typedef char verType;	//定义顶点类型 typedef int status ; typedef struct ver	//关于景点(顶点)信息存放（结构体数组） { char name[20];	//存放景点名称 char mask;	//存放景点代号 char intro[20];	//景点简介 }Ver[MAXVER]; typedef struct	//无向网存放景区信息 { Ver verx;	//定义顶点 int arcs[MAXVER][MAXVER];	//定义弧 int vernum,arcsnum;	//定义最大顶点数 和弧 }MGraph; int locate(MGraph G,verType ch) //查找顶点在数组中的下标 { int i; for(i=0;i&lt;G.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6de8dd1515cc6659916d03f202f6f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae93b45e414332134a0d37a19d47734b/" rel="bookmark">
			Android 4学习（8）：用户界面 - Fragment
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考《Professional Android 4 Development》
Fragment简介 Fragment是我们可以将Activity分成不同的组成部分，这些组成部分拥有自己的生命周期和UI。它的最大用途在于适配不同的屏幕。
创建Fragment Fragment和Activity有很多相似之处，例如可以不带UI，但这样做对两者似乎都没什么意义。他们的创建方式也很相似，例如下面的代码：
package test.fragments; import android.app.Fragment; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; public class MySkeletonFragment extends Fragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // Create, or inflate the Fragment’s UI, and return it. // If this Fragment has no UI then return null. return inflater.inflate(R.layout.my_fragment, container, false); } } Fragment生命周期 Fragment的生命周期和它的宿主Activity密切相关，几乎和宿主Activity的生命周期一致，他们之间最大的不同在于Activity可以增加或删除Fragment。下图总结了Fragment的生命周期：
Fragment特有的生命周期事件 Attach and detach Fragment from the parent ActivityCreating and destroying FragmentCreating and Destroying UI 获取Fragment Manager 每个Activity对象都内置了一个FragmentManager对象，使用getFragmentManager()即可获得：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae93b45e414332134a0d37a19d47734b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b82714d2f0c503965644b93128d3f016/" rel="bookmark">
			Android 4学习（7）：用户界面 - 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考《Professional Android 4 Development》
Android UI基本元素 下面这些概念是Android UI设计的基础，深入学习和理解它们是Android UI设计的基础：
View：View是所有UI元素，包括Layout在内，的父类。View Groups：View的子类，实现了ViewManager接口。一个ViewGroup可以包含多个子View。Fragmengts：用于封装UI的基本元素。Fragment有自己的layout配置文件，可以接收用户输入，可以方便地适配不同的屏幕。Activity：用于表达android设备的屏幕，Activity类似于Web开发中的Form表单。View等UI元素只有绑到Activity中才可以被用户可见。 Android UI基础 Android UI与Activity的绑定 最常用的方法是使用setContentView()将Layout ID或View对象传到Activity中，例如：
@Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); } @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); TextView myTextView = new TextView(this); setContentView(myTextView); myTextView.setText(“Hello, Android”); } 同样的，使用findViewById()方法可以通过View ID获取View对象：
TextView myTextView = (TextView)findViewById(R.id.myTextView); Layout简介 Layout是ViewGroup的子类，用于描述和管理Android UI的布局。Android自带了很多Layout，常用的包括FrameLayout，LinearLayout，RelativeLayout和GridLayout。关于Layout的更多信息，可以参考这个链接：
http://developer.android.com/guide/topics/ui/declaring-layout.html#CommonLayouts
下面是一个Layout示例文件：
&lt;?xml version=”1.0” encoding=”utf-8”?&gt; &lt;LinearLayout xmlns:android=”http://schemas.android.com/apk/res/android” android:orientation=”vertical” android:layout_width=”match_parent” android:layout_height=”match_parent”&gt; &lt;TextView android:layout_width=”match_parent” android:layout_height=”wrap_content” android:text=”Enter Text Below” /&gt; &lt;EditText android:layout_width=”match_parent” android:layout_height=”wrap_content” android:text=”Text Goes Here!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b82714d2f0c503965644b93128d3f016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d363366eb8ceb6aa4f6f92cd590e9ce/" rel="bookmark">
			C# 执行bat批处理文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# 执行bat批处理文件 1 ///batPath为.bat 可执行文件的绝对路径 2 private void RunBat(string batPath) 3 { 4 Process pro = new Process(); 5 FileInfo file = new FileInfo(batPath); 6 pro.StartInfo.WorkingDirectory = file.Directory.FullName; 7 pro.StartInfo.FileName = batPath; 8 pro.StartInfo.CreateNoWindow = True;//隐藏窗体的显示 9 pro.Start(); 10 pro.WaitForExit(); 11 } 转载于:https://www.cnblogs.com/HedgehogBlog/p/3376301.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2eb2063c7c68f8d340a8732f914742/" rel="bookmark">
			eclipse下使用javaapi连接hbase记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.hadoop工程已经配置好，把hbase目录放到windows下，用来导入jar包。
2.确保windowshosts文件配置完成，确保java环境配置完成。
3.创建hadoop工程，把hbase下的jar包全部导入工程，不清楚到底需要哪个包，注意，可能你的hbase下的包不全，网上搜索。这里创建一个普通的工程，把hadoop的jar包导入工程也可以。
4.新建一个类输入代码如下：（前提是先创建了一个database的表）
package hbase1;
import java.io.IOException;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.HColumnDescriptor;
import org.apache.hadoop.hbase.HTableDescriptor;
import org.apache.hadoop.hbase.client.HBaseAdmin;
import org.apache.hadoop.hbase.util.Bytes;
public class test{
public static void main(String[] args) throws IOException {
Configuration conf = HBaseConfiguration.create(); conf.set("hbase.zookeeper.quorum", "testhd2");
HBaseAdmin admin = new HBaseAdmin(conf);
HTableDescriptor tableDescriptor = admin.getTableDescriptor(Bytes.toBytes("database"));
byte[] name = tableDescriptor.getName();
System.out.println(new String(name));
HColumnDescriptor[] columnFamilies = tableDescriptor.getColumnFamilies();
for (HColumnDescriptor d : columnFamilies) {
System.out.println(d.getNameAsString());
System.out.println("12345");
}
}
} 这里注意testhd2是zookeeper的服务器，不要连接namenode。应该把所有的zookeeper都写上，‘，’隔开，写一个也可以
5.可能会遇到错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b2eb2063c7c68f8d340a8732f914742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75d996e17c7586ffff4f78e83eaa417d/" rel="bookmark">
			向下取整符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Word-&gt;插入-&gt;符号,在字体中选择Lucida Sans Unicode 子集选择数学运算符 就能找到向上、向下取整符号。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c6393ff938c611c85c5941ed2753fbe/" rel="bookmark">
			树莓派学习笔记——GPIO功能学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.前言 树莓派现在越来越火，网上树莓派的资料也越来越多。树莓派源自英国，国外嵌入式开源领域具有良好的分享精神，树莓派各种集成库也层出不穷，下面推荐几个。 【 python GPIO】 【开发语言】——python 【简单介绍】——该库更确切的名称为raspberry-gpio-python，树莓派官方资料中推荐且容易上手。python GPIO是一个小型的python库，可以帮助用户完成raspberry相关IO口操作。但是python GPIO库还没有支持SPI、I2C或者1-wire等总线接口。除了python GPIO之外，还有众多的python扩展库（例如webiopi），毫无疑问的说python非常适合树莓派，树莓派也非常适合python。 【 wiringPi】 【开发语言】——C语言 【简单介绍】——wiringPi适合那些具有C语言基础，在接触树莓派之前已经接触过单片机或者嵌入式开发的人群。wiringPi的API函数和arduino非常相似，这也使得它广受欢迎。作者给出了大量的说明和示例代码，这些示例代码也包括UART设备，I2C设备和SPI设备等，毫无疑问地说wiringPi功能非常强大。 【 BCM2835 C Library】 【开发语言】——C语言 【简单介绍】BCM2835 C Library可以理解为使用C语言实现的相关底层驱动，它给我的感觉更像STM32的库函数，BCM2835 C Library的驱动库包括GPIO、SPI和UART等，可以通过学习BCM2835 C Library熟悉BCM2835相关的寄存器操作。如果有机会开发树莓派上的linux驱动，或自主开发python或PHP扩展驱动，可以从BCM2835 C Library找到不少的“灵感”。 【相关博文】 更多树莓派学习笔记请参考——【 树莓派学习笔记——索引博文】 1.硬件准备 【树莓派】——在开始所有的实验之前，你需要一块完整的树莓派。 【IO扩展板】——可以通过淘宝购买IO扩展板，或者购买万用板和杜邦线自行制作IO扩展板。 图1 树莓派扩展板——图片来自 天猫 大菠萝数码专营店 图2 运行效果图 2.注意事项 【编号方式】 图3 GPIO编号方式——该图片来自wiringPi说明文档 树莓派的软件扩展库虽然很多，但也导致了扩展库“碎片化”的问题，例如操作树莓派的GPIO端口，GPIO的编号便存在三种不同的方式 【1】插座编号方式 编号侧重 P1插座侧，从上到下，从左到右。正如图3的Header一栏。 【2】BCM2835编号方式 编号 侧重CPU寄存器，根据BCM2835的GPIO寄存器编号。正如图3 BCM GPIO一栏。 【3】wiringPi编号方式 编号 侧重实现逻辑，把扩展GPIO端口从0开始编号，这种编号方便编程。正如图3 WiringPi一栏。 【举例说明】 插座编号方式 11 -&gt; BCM2835编号方式 17 -&gt; wiringPi编号方式 GPIO0。无论如何它都是同一个IO管脚。 【代码写在哪里】 【1】直接在树莓派中编写 树莓派中有几款代码（文本）编辑软件，可以在树莓派中编写代码。 【2】在windows中编写 可以在windows中编写代码，如果是Python脚本可通过FTP软件传输到树莓派中，然后使用SSH客户端登录到树莓派中执行Python脚本。如果是C语言文件，除了使用FTP传输之外还需要在树莓派上编译才可以生成可执行文件（相当于windows上的exe文件）。相关软件操作请参考【 树莓派学习笔记——常用软件汇总】 【3】在其他linux中编写 与windows中编写代码不同，在其他linux发行版（例如ubuntu）中可安装交叉工具链，交叉编译C文件生成在树莓派的可执行文件，那么使用FTP传输可执行文件至树莓派即可。其实方式【1】和方式【3】是几乎相同的。 【本例原理图】 为了说明问题本例只有一个LED，接在了树莓派IO扩展插座的11脚。 图4 原理图 2 Python GPIO实现 【安装过程】 【1】先安装python-dev，输入以下指令。 sudo apt-get install python-dev 【2】安装RPi.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c6393ff938c611c85c5941ed2753fbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8054a30a5f5f41757e8594d1973189bf/" rel="bookmark">
			osip2和eXosip2的编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Linux下编译
1.准备libosip2-4.0.0.tar.gz和libeXosip2-4.0.0.tar.gz
2.解压编译安装osip2
3.解压编译安装eXosip2
4.在/etc/profile的最后添加export LD_LIBRARY_PATH=/usr/local/lib/:$LD_LIBRARY_PATH
5.在终端下运行source /etc/profile
二、Windows下编译
1.准备libosip2-4.0.0.tar.gz和libeXosip2-4.0.0.tar.gz
2.解压libosip2-4.0.0.tar.gz，进入libosip2-4.0.0\platform\vsnet目录，用VS2010打开osip.sln文件
3.先编译osipparser2，若出现“无法解析的外部符号”错误，就在libosip2-4.0.0\platform\vsnet\oispparser2.def文件的最后添加相应的外部符号，接着编译osip2，若出现“无法解析的外部符号”错误，就在libosip2-4.0.0\platform\vsnet\oisp2.def文件的最后添加相应的外部符号
4.编译成功后，在libosip2-4.0.0\platform\vsnet\Debug下会生成4个库文件：osipparser2.lib，osipparser2.dll，osip2.lib，osip2.dll
5.解压libeXosip2-4.0.0.tar.gz，进入libeXosip2-4.0.0\platform\vsnet目录，创建Debug目录，并把前面的4个库文件拷贝到Debug目录下
6.进入libeXosip2-4.0.0\platform\vsnet目录，用VS2010打开eXosip.sln文件，在项目属性中，C/C++ --&gt; 预处理器 --&gt; 预处理器定义: 删除HAVE_OPENSSL_SSL_H，C/C++ --&gt; 常规 --&gt; 附加包含目录: 将osip的头文件libosip2-4.0.0\include包含进来，编译，若出现“无法解析的外部符号”错误，就在libeXosip2-4.0.0\platform\vsnet\eXosip2.def文件的最后添加相应的外部符号。
7.编译成功后，在libeXosip2-4.0.0\platform\vsnet\Debug下会生成eXosip2.lib
8.创建自己的项目时需要 链接器 --&gt; 输入 --&gt; 附加依赖项：增加静态库引用：Dnsapi.lib;Iphlpapi.lib;Ws2_32.lib;osip2.lib;osipparser2.lib;exosip.lib;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/043c09d4bf22e21a9a28ae70b79de738/" rel="bookmark">
			三极管和运放构成的几种恒流源电路分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何利用三极管和运放设计一个150mA的恒流源，求电路图，验证过的！！！ 三极管和运放构成的几种恒流源电路分析(还不是太理解) 这几种电路都可以在负载电阻RL上获得恒流输出
第一种由于RL浮地,一般很少用
第二种RL是虚地,也不大使用
第三种虽然RL浮地,但是RL一端接正电源端,比较常用
第四种是正反馈平衡式,是由于负载RL接地而受到人们的喜爱
第五种和第四种原理相同,只是扩大了电流的输出能力,人们在使用中常常把电阻R2取的比负载RL大的多,而省略了跟随器运放
第五种是本人想的电路,也是对地负载
后边两种是恒流源电路
对比几种V/I电路,凡是没有三极管只类的单向器件,都可以实现交流恒流,加了三极管之后就只能做单向直流恒流了
第四和第五是建立在正负反馈平衡的基础上的,如果由于电阻的误差而失去平衡,会影响恒流输出特性,也就是说,输出电流会随负载变化
而其他几种电阻的误差只会影响输出电流的值,而不会影响输出特性
如果输出电流大,或者嫌三极管的集电极电流和发射极电流不相等,可以把三极管换成MOSFET 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2106059d1137ebb6eb4dd04768c0487/" rel="bookmark">
			Yii updateCounters 技术器的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$bagecmsShow = Post::model()-&gt;findByPk( intval( $id ) );
$bagecmsShow-&gt;updateCounters(array ('view_count' =&gt; 1 ), 'id=:id', array ('id' =&gt; $id ));
视图里即可用：
&lt;?php echo $bagecmsShow-&gt;view_count?&gt;
转载于:https://www.cnblogs.com/fengzhiqiangcaisangzi/p/3361252.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e16987e8f41ba5a666d04bdbc596b70/" rel="bookmark">
			Intent广播事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一种系统级消息传递的机制，Intent有能力穿越进程边界传递结构化消息。
到目前为止，你已经了解了使用Intent来启动一个新的应用程序组件，但是，它们还可以通过sendBroadcast方法在组件间广播匿名消息。你可以在你的应用程序中实现Broadcast Receiver来监听和响应这些广播的Intent。广播Intent用于通知系统的监听者或应用程序事件，从而扩展了应用程序间的事件驱动编程模型。
1、广播事件 广播Intent让你的程序更加开放；通过使用Intent来广播事件，你让你和第三方开发者响应事件而不需要修改你的原始程序。在你的应用程序里，你可以监听广播的Intent来替换或增强本地的（或第三方的）应用程序，或者对系统变化和应用程序事件作出响应。举个例子，通过监听外来的呼叫广播，你可以改变呼叫者的铃声或音量。
Android广泛地使用广播Intent来广播系统事件，如电池充电变化，网络连接和来电。
广播Intent是相当地简单。在你的程序组件里，构建你要广播的Intent，使用sendBroadcast方法发送出去。设定Intent的动作、数据和种类来使Broadcast Receiver精确地决定它们的兴趣。在这里，Intent动作字符串用来标识要广播的事件，因此，它必须是独一无二的标识事件的字符串。习惯的，动作字符串使用Java包的样子来定义，如下面的片段所示：
public static final String NEW_LIFEFORM_DETECTED = “com.paad.action.NEW_LIFEFORM”; 如果你想在Intent中包含数据，你可以使用Intent的data属性来指定一个URI。你还可以包含extras来增加额外的本地类型值。考虑就事件驱动模型而言，这些extras包等价于事件处理函数的可选参数。
下面的框架代码给出了一个广播的Intent的基本创建，使用之前定义的动作和一些以extras方法储存的额外的事件信息。
Intent intent = new Intent(NEW_LIFEFORM_DETECTED); intent.putExtra(“lifeformName”, lifeformType); intent.putExtra(“longitude”, currentLongitude); intent.putExtra(“latitude”, currentLatitude); sendBroadcast(intent); 2、使用Broadcast Receiver监听广播 Broadcast Receiver用于监听广播Intent。为了激活一个Broadcast Receiver，需要在代码或在程序manifest中注册。当注册一个Broadcast Receiver时，你必须使用Intent Filter来指定要监听哪个Intent。
为了创建一个新的Broadcast Receiver，需要扩展BroadcastReceiver类，并重写onReceive事件处理函数，如下面的框架代码所示：
import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; public class MyBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { //TODO: React to the Intent received. } } 当广播的Intent与注册的接收器的Intent Filter匹配时，onReceive方法会执行。onReceive处理函数必须在5秒内完成，否则应用程序无响应的对话框会显示。
在Intent广播的时候，注册有Broadcast Receiver的应用程序不需要正在运行。它们在有匹配的广播Intent时自动启动。这对于资源管理来说，是极好的，因为它允许你创建可以被关闭或杀死的事件驱动应用程序，而此刻又以安全的方式对广播事件做出响应。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e16987e8f41ba5a666d04bdbc596b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e09b95d03913f7e6ecfc1d5c88ecce/" rel="bookmark">
			js隐藏/显示页面元素的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript控制页面控件隐藏显示的两种方法
javascript控制页面控件隐藏显示的两种方法，方法的不同之处在于控件隐藏后是否还在页面上占位
方法一：
document.all&lt;"PanelSMS"&gt;.style.visibility="hidden"; document.all&lt;"PanelSMS"&gt;.style.visibility="visible";
方法二：
document.all&lt;"PanelSMS"&gt;.style.display="none"; document.all&lt;"PanelSMS"&gt;.style.display="inline";
方法一隐藏后 页面的位置还被控件占用 只是不显示 类似于.net验证控件的Display=Static
方法二隐藏后 页面的位置不被占用 类似于.net验证控件的Display=Dynamic
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff6939a0ff6f4d7f891ce023a38e979/" rel="bookmark">
			Android OpenGL库加载过程源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android系统采用OpenGL绘制3D图形，使用skia来绘制二维图形；OpenGL源码位于：
frameworks/native/opengl
frameworks/base/opengl
本文简单介绍OpenGL库的加载过程。OpenGL以动态库的方式提供，因此在使用OpenGL的接口函数绘图前，需要加载OpenGL库，并得到接口函数指针。函数EGLBoolean egl_init_drivers()就是负责OpenGL库的加载。
EGLBoolean egl_init_drivers() { EGLBoolean res; pthread_mutex_lock(&amp;sInitDriverMutex); res = egl_init_drivers_locked(); pthread_mutex_unlock(&amp;sInitDriverMutex); return res; } 为保证多线程访问的安全性，使用线程锁来放完另一个接口函数egl_init_drivers_locked static EGLBoolean egl_init_drivers_locked() { if (sEarlyInitState) { // initialized by static ctor. should be set here. return EGL_FALSE; } // 得到Loader对象实例 Loader&amp; loader(Loader::getInstance()); //加载EGL库 egl_connection_t* cnx = &amp;gEGLImpl; if (cnx-&gt;dso == 0) { cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX] =&amp;gHooks[egl_connection_t::GLESv1_INDEX]; cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX] =&amp;gHooks[egl_connection_t::GLESv2_INDEX]; cnx-&gt;dso = loader.open(cnx); } return cnx-&gt;dso ? EGL_TRUE : EGL_FALSE; } 函数首先定义指针cnx指向全局变量gEGLImpl，并且将cnx的域hooks指向gHooks，最后通过loader对象的open函数打开EGL动态库，因此最后从EGL库中加载的接口函数指针都保存到了变量gEGLImpl和gHooks中了。 frameworks\native\opengl\libs\EGL\Loader.cpp
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eff6939a0ff6f4d7f891ce023a38e979/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aee14f40903f74df5654ded48e3ef45/" rel="bookmark">
			BAT 批量为文件夹下的文件添加前缀  语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要为名字为1.doc添加“考试”二字，变成“考试_1.doc”，类似的需求还有很多
BAT语句为：
@echo off title 批量替换文件名 echo. echo 本批处理可批量替换本文件所在文件夹下所有文件的文件名。 echo. echo.&amp;set /p strtemp3= 请输入要添加前缀的文件类型： echo.&amp;set /p strtemp2= 请输入要添加前缀的文件名字符串（不变则直接回车）： setlocal enabledelayedexpansion for /f "delims=" %%a in ('dir /a /b *.%strtemp3%') do ( ren "%%~a" "%strtemp2%_%%a") echo. echo OK了！ echo. pause 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bfbca250972aca4dc0736e999e6ec34/" rel="bookmark">
			Servlet概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么80%的码农都做不了架构师？&gt;&gt;&gt; 一、Servlet概述 1.sun公司提供的动态web资源开发技术。本质是上一段java小程序，要求这个小程序必须实现Servlet接口，以便服务器能够调用。 2.开发Servlet的两个步骤 *实验：Servlet的快速入门 （1）步骤一：写一个java程序实现Servlet接口（此处直接继承了默认实现类GenericServlet） package cn.itheima; import java.io.*; import javax.servlet.*; public class FirstServlet extends GenericServlet{ public void service(ServletRequest req, ServletResponse res) throws ServletException, java.io.IOException{ res.getOutputStream().write("My FirstServlet!".getBytes()); } } （2）将编译好的带包的.class放到WEB-INF/classes下以外，还要配置web应用的 web.xml注册Servlet &lt;servlet&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itheima.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/FirstServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3.利用MyEclipse开发Servlet 二、Servlet的详述 1.生命周期：一件事物什么时候生，什么时候死，在生存期间必然会做的事情，所有这些放在一起就是该事物的声明周期。 2.Servlet的生命周期：通常情况下，servlet第一次被访问的时候在内存中创建对象，在创建后立即调用init()方法进行初始化。对于每一次请求都掉用service(req,resp)方法处理请求，此时会用Request对象封装请求信息，并用Response对象（最初是空的）代表响应消息，传入到service方法里供使用。当service方法处理完成后，返回服务器服务器根据Response中的信息组织称响应消息返回给浏览器。响应结束后servlet并不销毁，一直驻留在内存中等待下一次请求。直到服务器关闭或web应用被移除出虚拟主机，servlet对象销毁并在销毁前调用destroy()方法做一些善后的事情。 3.Servlet接口的继承结构 Servlet接口：定义了一个servlet应该具有的方法，所有的Servlet都应该直接或间接实现此接口 | |----GenericServlet：对Servlet接口的默认实现，通用Servlet，这是一个抽象类，其中的大部分方法都做了默认实现，只有service方法是一个抽象方法需要继承者自己实现 | |----HttpServlet:对HTTP协议进行了优化的Servlet，继承自GenericServlet类，并且实现了其中的service抽象方法，默认的实现中判断了请求的请求方式，并根据请求方式的不同分别调用不同的doXXX()方法。通常我们直接继承HttpServlet即可 4.web.xml注册Servlet的注意事项 4.1利用&lt;servlet&gt;&lt;servlet-mapping&gt;标签注册一个Servlet &lt;servlet&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itheima.FirstServlet&lt;/servlet-class&gt; 注意：此处要的是一个Servlet的完整类名，不是包含.java或.class扩展的文件路径 &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/FirstServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 4.2一个&lt;servlet&gt;可以对应多个&lt;servlet-mapping&gt; 4.3可以用*匹配符配置&lt;serlvet-mapping&gt;,但是要注意，必须是*.do或者/开头的以/*结束的路径。 ~由于匹配符的引入有可能一个虚拟路径会对应多个servlet-mapping，此时哪个最像找哪个servlet，并且*.do级别最低。 4.4可以为&lt;servlet&gt;配置&lt;load-on-startup&gt;子标签，指定servlet随着服务器的启动而加载，其中配置的数值指定启动的顺序 &lt;servlet&gt; &lt;servlet-name&gt;invoker&lt;/servlet-name&gt; &lt;servlet-class&gt; org.apache.catalina.servlets.InvokerServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bfbca250972aca4dc0736e999e6ec34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/653910895d3275af8f7a8d667057ec76/" rel="bookmark">
			svn:The working copy needs to be upgraded，eclipse不编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		eclipse不编译，每次修改代码控制台都显示错误
svn:The working copy needs to be upgraded
org.apache.subversion.javahl.ClientException: The working copy needs to be upgraded svn: Working copy ‘E:\aliyun-spirit\spiritmap0916′ is too old (format 10, created by Subversion 1.6) 提示的意思就是要更新svn版本，引发问题的原因就是用低版本的svn客户端载下来的代码，后来又升级svn客户端，去处理之前低版本载下来的代码造成的，右键project--Team--upgrade之后就ok了。
问题解决了，不过问题终究是自己不规范造成的首先class文件怎么能去svn控制，第二不要勤换，轻易升级svn版本，升级要慎重
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7a163d9adaf7988eff329cb8bb05658/" rel="bookmark">
			ubuntu系统下某些图标不能正常显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先打开dconf,然后选desktop-&gt;unity-&gt;panel 中，修改writelist的值为‘all’ ,ok了！快去试试吧！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3f2798811504596074c4c61bcc55c9/" rel="bookmark">
			c语言C&#43;&#43;集合运算代写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集合是具有某种特定性质的事物的总体。这里的“事物”可以是人，物品，也可以是数学元素。常用集合运算分双目运算和单目运算。
双目运算有：
和集 [&amp;]，两个或两个以上的集合的所有元素组成一个新的集合,称为和集。示例为：(1,2,3)[&amp;](1,3,4)=1 2 3 1 3 4
并集 [+]，两个或两个以上集合并在一起并去除其中重复元素的集合,称为并集。示例为：(1,2,3,5,9)[+](1,3,4)=1 2 3 5 9 4
差集 [-]，第一个集合减去第二个集合所包含的元素，称为差集。示例为：(1,2,3,5,9)[-](1,3,4)=2 5 9
交集 [*]，两个集合中都含有的元素。示例为：(1,2,3)[*](1,3,4)=1 3
补集 [/]，两个集中非共同元素组成的集合(也叫反交集)。示例为：(1,2,3)[/](1,3,4)=2 4
逆集 [\]，第二个集合减去第一个集合所包含的元素，称为逆集（也叫反差集）。示例为：(1,2,3)[\](1,3,4)=4
平集 [!]，两个集合的和集中，只出现一次的元素组成的集合称为平集。示例为：(1,2,3,2,5,6,2,1,4,3,2)[!](4,5,9,2,3,5,1,7)=6 9 7
频集 [!!]，两个集合的和集中，出现两次以上的元素组成的集合称为频集。示例为：(1,2,3,2,5,6,2,1,4,3,2)[!!](4,5,9,2,3,5,1,7)=1 2 3 5 4
单目运算有：
差集[-]，去除数集中重复的元素。示例为：(1,2,3,1,4,2,5)[-]=1 2 3 4 5
求和运算符号 [++]，集合中所有元素的总和。示例为：前置操作符式 [++](1,2,3,5,9)=20， (1,4,7)[++]=12。该操作符也可以后置于集合后面。如 (1,2,3,5,9) [++]=20
内积 [**]，集合中所有元素的乘积。示例为：[**](2,5;4,2;5,4)=1600
算术平均值 [~]，集合中所有元素的总和并除以元素的个数所得的值。示例为：前置操作符式 [~](1,2,3)=2，后置式 (2.5,3,9)[~]=4.8333
标准方差 [~~]，样本方差的算术平方根叫做样本标准差。这也是一个可以前置或后置的操作符。示例为： (1,5,3;6,8,2;9,1,6)[~~]=2.9627， [~~](1,5,3;6,8,2;9,1,6)=2.9627
n项移动平均 [~n]，对数集进行n项移动平均。这也是一个可以前置或后置的操作符。示例为： 2项移动平均 [~2](1,2,3,2,4,2,5)=1.5 2.5 2.5 3 3 3.5，3项移动平均 (1,2,3,2,4,2,5)[~3]=2 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e3f2798811504596074c4c61bcc55c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6733d568680f59051218f631167d960e/" rel="bookmark">
			C#泛型集合 using System.Collections.Generic
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛型最常见的用途是泛型集合，命名空间System.Collections.Generic 中包含了一些基于泛型的集合类，使用泛型集合类可以提供更高的类型安全性，还有更高的性能，避免了非泛型集合的重复的装箱和拆箱。 很多非泛型集合类都有对应的泛型集合类，下面是常用的非泛型集合类以及对应的泛型集合类：
非泛型集合类泛型集合类ArrayListListHashTableDIctionaryQueueQueueStackStackSortedListSortedList 为什么要用泛型集合？
在C# 2.0之前，主要可以通过两种方式实现集合：
a.使用ArrayList
直接将对象放入ArrayList，操作直观，但由于集合中的项是Object类型，因此每次使用都必须进行繁琐的类型转换。
b.使用自定义集合类
比较常见的做法是从CollectionBase抽象类继承一个自定义类，通过对IList对象进行封装实现强类型集合。这种方式要求为每种集合类型写一个相应的自定义类，工作量较大。泛型集合的出现较好的解决了上述问题，只需一行代码便能创建指定类型的集合。
什么是泛型？
泛型是C# 2.0中的新增元素(C++中称为模板)，主要用于解决一系列类似的问题。这种机制允许将类名作为参数传递给泛型类型，并生成相应的对象。将泛型(包括类、接口、方法、委托等)看作模板可能更好理解，模板中的变体部分将被作为参数传进来的类名称所代替，从而得到一个新的类型定义。
怎样创建泛型集合？
主要利用System.Collections.Generic命名空间下面的List&lt;T&gt;泛型类创建集合，语法如下：
List &lt; T &gt; ListOfT = new List &lt; T &gt; (); 其中的"T"就是所要使用的类型，既可以是简单类型，如string、int，也可以是用户自定义类型。下面看一个具体例子。
定义Person类如下：
class Person
{
private string _name; //姓名
private int _age; //年龄
//创建Person对象
public Person(string Name, int Age)
{
this._name= Name;
this._age = Age;
}
//姓名
public string Name
{
get { return _name; }
}
//年龄
public int Age
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6733d568680f59051218f631167d960e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a57cd1c6e3302c99c6eb04d412984eee/" rel="bookmark">
			Not starting NFS client services - no NFS found in /etc/fstab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Question:
I'm trying to start nfs service in my SLES.
I have my /etc/exports like this:
/root/data_backup *(ro) When I run service nfs start, it says:
Not starting NFS client services - no NFS found in /etc/fstab: For service nfs status, it says:
Checking for mounted nfs shares (from /etc/fstab) Solution: 'service nfs' (/etc/rc.d/nfs) is the NFS client. To start the NFS server, you have to use service nfsserver start
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a57cd1c6e3302c99c6eb04d412984eee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08eee83db298605f8792c740e0c34d07/" rel="bookmark">
			Linux 6.3下删除ORACLE11gR2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用SQL*PLUS停止 数据库 [oracle@rockdg oracle]$ sqlplus /nolog SQL&gt; connect / as sysdba SQL&gt; shutdown [immediate] SQL&gt; exit 2.停止Listener [oracle@rockdg oracle]$ lsnrctl stop 3.停止HTTP服务 [root@rockdg /root]# service httpd stop 4.用su或者重新登录到root(如想重新 安装可以保留 oracle用户，省得输入环境变量了) 5.将安装目录删除 [root@rockdg /root]# rm -rf /u01/app/oracle/ 6.将/usr/bin下的文件删除 [root@rockdg /root]# rm /usr/local/bin/dbhome [root@rockdg /root]# rm /usr/local/bin/oraenv [root@rockdg /root]# rm /usr/local/bin/coraenv 7.将/etc/oratab删除 [root@rockdg /root]# rm /etc/oratab 8.将/etc/oraInst.loc删除 [root@rockdg /root]# rm /etc/oraInst.loc 9.将oracle用户删除(若要重新安装,可以不删除) [root@rockdg /root]# userdel –r oracle 10.将用户组删除(若要重新安装,可以不删除) [root@rockdg /root]# groupdel oinstall [root@rockdg /root]# groupdel dba 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08eee83db298605f8792c740e0c34d07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38fce3566352f7b0ac8ab822a6dcac75/" rel="bookmark">
			视频码率,帧率和分辨率及H264介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视频码率,帧率和分辨率到底哪一个影响电影的清晰度
码率：影响体积，与体积成正比：码率越大，体积越大；码率越小，体积越小。
码率就是数据传输时单位时间传送的数据位数,一般我们用的单位是kbps即千位每秒。也就是取样率，单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真，围绕这个核心衍生出来cbr（固定码率）与vbr（可变码率）， “码率”就是失真度，码率越高越清晰，反之则画面粗糙而多马赛克
帧率：影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。如果码率为变量，则帧率也会影响体积，帧率越高，每秒钟经过的画面越多，需要的码率也越高，体积也越大。
帧率就是在1秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次，
分辨率：影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小。
清晰度
在码率一定的情况下，分辨率与清晰度成反比关系：分辨率越高，图像越不清晰，分辨率越低，图像越清晰。
在分辨率一定的情况下，码率与清晰度成正比关系，码率越高，图像越清晰；码率越低，图像越不清晰。
带宽、帧率
例如在ADSL线路上传输图像，上行带宽只有512Kbps，但要传输4路CIF 分辨率的图像。按照常规，CIF分辨率建议码率是512Kbps，那么照此计算就只能传一路，降低码率势必会影响图像质量。那么为了确保图像质量，就必须降低帧率，这样一来，即便降低码率也不会影响图像质量，但在图像的连贯性上会有影响。
H.264
H.264是在MPEG-4技术的基础之上建立起来的，刏其编解码流程主要包括5个部分：帧间和帧内预测（Estimation）、变换（Transform）和反变换、量化（Quantization）和反量化、环路滤波（Loop Filter）、熵编码（Entropy Coding）。
H.264的PSNR比MPEG-4（ASP）和H.263++（HLP）明显要好，凈在6种速率的对比测试中，刓H.264的PSNR比MPEG-4（ASP）平均要高2dB，凖比H.263（HLP）平均要高3dB。刡6个测试速率及其相关的条件分别为：32 kbit/s速率、10f/s帧率和QCIF格式；64 kbit/s速率、15f/s帧率和QCIF格式；128kbit/s速率、15f/s帧率和CIF格式；256kbit/s速率、15f/s帧率和QCIF格式；512 kbit/s速率、30f/s帧率和CIF格式；1024 kbit/s速率、30f/s帧率和CIF格式。刣
凙
H.264最大的优势是具有很高的数据压缩比率，凧在同等图像质量的条件下，凨H.264的压缩比是MPEG-2的2倍以上，凿是MPEG-4的1.5～2倍。凶举个例子，凝原始文件的大小如果为88GB，则采用MPEG-2压缩标准压缩后变成3.5GB，凿压缩比为25∶1，凓而采用H.264压缩标准压缩后变为879MB，凪从88GB到879MB，凥H.264的压缩比达到惊人的102∶1！H.264为什么有那么高的压缩比？低码率（Low Bit Rate）起了重要的作用，凌和MPEG-2和MPEG-4 ASP等压缩技术相比，刪H.264压缩技术将大大节省用户的下载时间和数据流量收费。
刣
I/P/B帧
I帧:帧内编码帧，也就是关键帧或独立帧
预测帧:以I帧做为基础帧,以I帧预测P帧,再由I帧和P帧预测B帧;
B帧:双向预测内插编码帧
P帧:前向预测编码帧
凷除了支持P帧、B帧外，凰H.264还支持一种新的流间传送帧——SP帧
统计的结果表明,在间隔1~2帧的图像中,各像素只有10%以下的点,其亮度差值变化超过2%,而色度差值的变化只有1%以下
在视频压缩的过程中， I帧是图像数据压缩，是独立帧。P帧是参考I帧进行帧间图像数据压缩，不是独立帧。在压缩后的视频中绝大多数都是B/P帧，故视频质量主要由B/P帧表现出来。由于B/P帧不是独立帧，而只是保存了与邻近的I帧的差值，故实际上并不存在分辨率的概念，应该看成一个二进制差值序列。
而该二进制序列在使用熵编码压缩技术时会使用量化参数进行有损压缩，视频的质量直接由量化参数决定，而量化参数会直接影响到压缩比和码率。　视频质量可以通过主观和客观方式来表现，主观方式就是通常人们提到的视频清晰度，而客观参数则是量化参数或者压缩比或者码率。在视频源一样，压缩算法也一样的前提下比较，量化参数，压缩比和码率之间是有直接的比例关系的。　分辨率的变化又称为重新采样。由高分辨率变成低分辨率称为下采样，由于采样前数据充足，只需要尽量保留更多的信息量，一般可以获得相对较好的结果。而由低分辨率变成高分辨率称为上采样，由于需要插值等方法来补充（猜测）缺少的像素点，故必然会带有失真，这就是一种视频质量（清晰度）的损失。
传输数据量
由于网卡在网络上接收到的数据包长短不一，这些不同的包长组和必然会对接口速率造成影响。总线上传输的数据除了数据净荷，在协议层还会添加必要的协议头和尾，因此加上网络开销，传输数据量 一般小≤净荷数据量 * 1.3
H.264标准的关键技术 1.帧内预测编码 帧内编码用来缩减图像的空间冗余。凣为了提高H.264帧内编码的效率，刂在给定帧中充分利用相邻宏块的空间相关性，凖相邻的宏块通常含有相似的属性。凭因此，凨在对一给定宏块编码时，刨首先可以根据周围的宏块预测（典型的是根据左上角的宏块，凷因为此宏块已经被编码处理），凰然后对预测值与实际值的差值进行编码，刉这样，凟相对于直接对该帧编码而言，凴可以大大减小码率。刓
H.264提供6种模式进行4×4像素宏块预测，凫包括1种直流预测和5种方向预测，凪如图2所示。减在图中，凕相邻块的A到I共9个像素均已经被编码，凧可以被用以预测，几如果我们选择模式4，凵那么，凊a、b、c、d4个像素被预测为与E相等的值，利e、f、g、h4个像素被预测为与F相等的值，凣对于图像中含有很少空间信息的平坦区，凟H.264也支持16×16的帧内编码。刪图2 帧内编码模式 2.帧间预测编码 帧间预测编码利用连续帧中的时间冗余来进行运动估计和补偿。刣H.264的运动补偿支持以往的视频编码标准中的大部分关键特性，凹而且灵活地添加了更多的功能，凷除了支持P帧、B帧外，凰H.264还支持一种新的流间传送帧——SP帧，凎如图3所示。刚码流中包含SP帧后，凜能在有类似内容但有不同码率的码流之间快速切换，刧同时支持随机接入和快速回放模式。刦图3 SP-帧示意图H.264的运动估计有以下4个特性。凪 (1)不同大小和形状的宏块分割 对每一个16×16像素宏块的运动补偿可以采用不同的大小和形状，减H.264支持7种模式，凔如图4所示。减小块模式的运动补偿为运动详细信息的处理提高了性能，刏减少了方块效应，凣提高了图像的质量。出图4 宏块分割方法 (2)高精度的亚像素运动补偿 在H.263中采用的是半像素精度的运动估计，凲而在H.264中可以采用1/4或者1/8像素精度的运动估值。凱在要求相同精度的情况下，凜H.264使用1/4或者1/8像素精度的运动估计后的残差要比H.263采用半像素精度运动估计后的残差来得小。凕这样在相同精度下，凝H.264在帧间编码中所需的码率更小。凓 (3)多帧预测 H.264提供可选的多帧预测功能，分在帧间编码时，凜可选5个不同的参考帧，利提供了更好的纠错性能，凮这样更可以改善视频图像质量。凙这一特性主要应用于以下场合：周期性的运动、平移运动、在两个不同的场景之间来回变换摄像机的镜头。凘 (4)去块滤波器 H.264定义了自适应去除块效应的滤波器，凑这可以处理预测环路中的水平和垂直块边缘，刊大大减少了方块效应。凯
3.整数变换 在变换方面，刘H.264使用了基于4×4像素块的类似于DCT的变换，凬但使用的是以整数为基础的空间变换，刄不存在反变换，出因为取舍而存在误差的问题，凢变换矩阵如图5所示。刨与浮点运算相比，凋整数DCT变换会引起一些额外的误差，処但因为DCT变换后的量化也存在量化误差，凟与之相比，凱整数DCT变换引起的量化误差影响并不大。凷此外，则整数DCT变换还具有减少运算量和复杂度，凥有利于向定点DSP移植的优点。刐 4.量化 H.264中可选32种不同的量化步长，処这与H.263中有31个量化步长很相似，出但是在H.264中，凳步长是以12.5%的复合率递进的，凭而不是一个固定常数。凔
在H.264中，击变换系数的读出方式也有两种：之字形(Zigzag)扫描和双扫描，凢如图6所示。凪大多数情况下使用简单的之字形扫描；双扫描仅用于使用较小量化级的块内，凣有助于提高编码效率。删图6变换系数的读出方式 5.熵编码 视频编码处理的最后一步就是熵编码，凶在H.264中采用了两种不同的熵编码方法：通用可变长编码（UVLC）和基于文本的自适应二进制算术编码（CABAC）。利
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38fce3566352f7b0ac8ab822a6dcac75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e353492486465c13ec8b0d05c537920/" rel="bookmark">
			hdu1437(概率DP)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		天气情况 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)
Total Submission(s): 547 Accepted Submission(s): 220
Problem Description 如果我们把天气分为雨天，阴天和晴天3种，在给定各种天气之间转换的概率，例如雨天转换成雨天，阴天和晴天的概率分别为0.4,0.3,0.3.那么在雨天后的第二天出现雨天,阴天和晴天的概率分别为0.4,0.3,0.3.现在给你今天的天气情况,问你n天后的某种天气出现的概率. Input 我们这里假设1,2,3分别代表3种天气情况,Pij表示从i天气转换到j天气的概率. 首先是一个数字T表示数据的组数. 每组数据以9个数开始分别是P11,P12,P13,……,P32,P33,接着下一行是一个数字m，表示提问的次数。每次提问有3个数据，i,j,n,表示过了n天从i天气情况到j天气情况(1&lt;=i,j&lt;=3 1&lt;=n&lt;=1000)。 Output 根据每次提问输出相应的概率(保留3位小数)。 Sample Input 1 0.4 0.3 0.3 0.2 0.5 0.3 0.1 0.3 0.6 3 1 1 1 2 3 1 1 1 2 Sample Output 0.400 0.300 0.250 Hint:如果GC提交不成功，可以换VC试试 Author xhd Source ACM暑期集训队练习赛（四） Recommend lcy 本题给出不同天气每过一天之间转化的概率以及起始天气和终止天气和之间的天数，求概率。本题是个典型的概率DP，关键要找准状态转移方程。 设dp[i][j]为过了i天天气为j的概率，则状态转移方程为为： dp[i][1]=dp[i-1][i]*p[1][1]+dp[i-1][2]*p[2][1]+dp[i-1][3]*p[3][1] dp[i][2]=dp[i-1][1]*p[1][2]+dp[i-1][2]*p[2][2]+dp[i-1][3]*p[3][2] dp[i][3]=dp[i-1][1]*p[1][3]+dp[i-1][2]*p[2][3]+dp[i-1][3]*p[3][3] 为了加快速度，可以用矩阵的快速幂求解。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; //***************************************************** //origin存放需计算的矩阵，res存放答案矩阵 //最终答案为res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e353492486465c13ec8b0d05c537920/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ffdd9f7beda73df06966b3ad6971bb/" rel="bookmark">
			EasyBCD的使用心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 今天试着用了一下EasyBCD，想着修改grub，使电脑从windows端进行启动，可是在EasyBCD没有找到ubuntu的grub，后来听别人说，原来在装ubuntu的时候要进行选择的。所以，我感觉EasyBCD很不强大。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0ec422e99ee7fc5c61da1e25f8e4b9/" rel="bookmark">
			校招季求职知识储备建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 将所储备的知识点分为基础知识、项目相关知识、智力题与逻辑推理、拓展知识、算法及相关书籍五部分。
基础知识储备方面：
Ø 语言：C/C++语系、Java、Javascript、PHP、Python、Linux、HTML5等；
Ø 海量数据处理技术和算法
Ø 数据结构：排序（堆排序+基数排序+快排）、图、栈+堆+队列+链表+数组+二叉树+红黑树；
Ø 计算机网络：OSI七层和五层模型、UDP和TCP（对比、拥塞控制、滑动窗口）、DNS机制、IP地址、网络协议、P2P网络、三次握手和四次挥手机制；
Ø 操作系统：锁机制、多线程、进程及进程间关系、通讯、同步；
Ø Java语言相关：Java对象池、Java代理机制、Java序列化、Java类加载机制、JDK+JVM+JRE、Java锁机制、Java自动打包和解包机制、HashMap、HashTable、ArrayList、HashSet的底层实现机制、Socket编程、Java反射机制、Java多线程、JVM、Java同步机制、JNI和JNDI、Java中的Cache机制；
Ø C/C++语言相关：override和overload、C++实现映射机制、memcpy、menset、strcpy源码、C++内存管理与JVM、虚函数、构造函数+赋值构造函数+拷贝构造函数+析构函数、继承与多态等；
Ø 数据库技术：ACID、分布式三段提交协议、SQL；
Ø 其他：卡特兰数、母函数、六度分割理论、螺旋队列、动态规划等。
项目相关方面，根据实习的项目共统计一下技术要点。
智力题及逻辑推理方面：这类题目一般可以在Web搜到很多，今年常考的智力题有：兔子买药、海盗分金子、小白鼠喝毒药等。
拓展知识方面，主要储备知识点：
Ø 大数据处理：NoSQL及各类NoSQL数据库、MapReduce；
Ø 即时通讯IM：腾讯、人人网、雅虎等不同IM的区别及腾讯微信的相关信息；
Ø 微博：新浪、腾讯微博的对比研究、微博Cache设计、新浪微博技术架构、高性能微博技术架构设计；
Ø 搜索引擎：通用搜索与垂直搜索、搜索意图识别、搜狗和360搜索对比；
Ø 数据挖掘：协同过滤算法、聚类算法、图片搜索；
Ø 系统设计：新浪爱问系统设计、异常框架设计；
Ø 定向广告：回头客定向与定向广告、Cookie原理及应用；
Ø 移动互联网
Ø 系统架构
Ø 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bc655cb808928ec39cc203673d6ce38/" rel="bookmark">
			[原创]让你省写大量重复代码的方法 使用PropertyInfo类 反射获取类 的类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前在开发一个系统的时候
小组里的人在写方法的时候很累，很多方法都是对象的属性需要大量的重复赋值，然后 添加到List对象中
你是否还在为一个对象里有几十 上百个属性 手动写代码赋值烦恼呢？
下面是一个以前的读取数据库 信息的例子
[c-sharp] view plain copy print ? public IList&lt;KFS_Model.QAS_V_MessageInfo&gt; PagerTest(string where, KFS_Model.Pager p) { SqlDataReader dr = null; string table = "QAS_V_MessageInfo"; string orderby = "QuestionTime"; IList&lt;KFS_Model.QAS_V_MessageInfo&gt; list = new List&lt;KFS_Model.QAS_V_MessageInfo&gt;(); Pagination.page(table, where, orderby, true,p); dr = Pagination.page(table, where, orderby, false, p); while (dr.Read()) { KFS_Model.QAS_V_MessageInfo qas = new KFS_Model.QAS_V_MessageInfo(); qas.UserId = dr.GetGuid(1); qas.UserName = dr.GetString(2); qas.SonModelId = dr.GetGuid(3); qas.SonModelName = dr.GetString(4); qas.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bc655cb808928ec39cc203673d6ce38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d12dbc9761c38424865dec8468230a/" rel="bookmark">
			Spring 3.1.1使用Mvc配置全局日期转换器，处理日期转换异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring3.0配置日期转换可以通过配置自定义实现WebBingingInitializer接口的一个日期转换类来实现，方法如下
转换类：
public class DateConverter implements WebBindingInitializer { public void initBinder(WebDataBinder binder, WebRequest request) { SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd"); binder.registerCustomEditor(Date.class, new CustomDateEditor(df, false)); } } 在spring-servlet.xml当中的进行注册：
&lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;!-- 日期格式转换 --&gt; &lt;property name="webBindingInitializer"&gt; &lt;bean class="DateConverter" /&gt; &lt;/property&gt; &lt;/bean&gt; spring3.1.1的处理进行调整，所以按照3.0的写法在3.1.1里面是无效的，通过查找资料及测试，发现可行方法
原因：
annotation-driven缺省注册类的改变 Spring 3.0.x中使用了annotation-driven后，缺省使用DefaultAnnotationHandlerMapping 来注册handler method和request的mapping关系。 AnnotationMethodHandlerAdapter来在实际调用handlermethod前对其参数进行处理。 在spring mvc 3.1中，对应变更为 DefaultAnnotationHandlerMapping -&gt; RequestMappingHandlerMapping AnnotationMethodHandlerAdapter -&gt; RequestMappingHandlerAdapter AnnotationMethodHandlerExceptionResolver -&gt; ExceptionHandlerExceptionResolver 以上都在使用了annotation-driven后自动注册。 而且对应分别提供了AbstractHandlerMethodMapping , AbstractHandlerMethodAdapter和 AbstractHandlerMethodExceptionResolver以便于让用户更方便的实现自定义的实现类。 &lt;mvc:annotation-driven/&gt;相当于注册了DefaultAnnotationHandlerMapping和AnnotationMethodHandlerAdapter两个bean，配置一些messageconverter。即解决了@Controller注解的使用前提配置。
spring mvc &lt;mvc:annotation-driven /&gt;会自动启动Spring MVC的注解功能，但实际它做了哪些工作呢？ Java代码 &lt;bean class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d12dbc9761c38424865dec8468230a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed82757fbd7be4c9b406334ef5092d77/" rel="bookmark">
			自动化写入多行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 用automation写入Excel的时候一次可以写入很多行，这样避免多次函数调用的开销 我一次写1024行，效果比一次写一个单元格好多了 RangePtr rangetmp;
hr=sheet-&gt;get_Range(_variant_t("A1"),_variant_t("A1"),(Range**)&amp;rangetmp);
CRange rg;
rg.AttachDispatch(rangetmp);
rangetmp.Detach();
COleSafeArray saRet;
DWORD numElements[2];
numElements[0]= m_iNumRows; //Number of rows in the range.
numElements[1]= m_iNumCols; //Number of columns in the range.
saRet.Create(VT_BSTR, 2, numElements);
//Fill the SAFEARRAY.
long index[2];
long iRow, iCol;
//resize range to make enough room for the value array
rg = rg.get_Resize(COleVariant(m_iNumRows),
COleVariant(m_iNumCols));
rg.put_Value2(COleVariant(saRet));
rg.DetachDispatch();
saRet.Detach();	
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11360bc6e9bc866ae9d9c550aa6d98e8/" rel="bookmark">
			安装Android Studio提示找不到JDK解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文出自 0nly.Me，转载时请注明出处及相应链接。
本文永久链接: http://0nly.me/archives/98.htm
Google推出的Android开发工具Android Studio亮点不少，有些功能实在是强大。基于Intellij idea，几乎完美解决了Eclipse太耗资源的问题。
但在Windows 64位系统环境下安装的时候，提示找不到JDK，尽管你可能已经设置好了环境变量。
解决办法如下：
管理员权限打开CMD，运行一下两句话即可
mklink C:\Windows\SysWOW64\java.exe C:\Windows\System32\java.exe
mklink C:\Windows\SysWOW64\javaw.exe C:\Windows\System32\javaw.exe
CMD提示成功即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ceb84952263c91fa68c6fcc44f0549d/" rel="bookmark">
			Deep Learning论文笔记之（四）CNN卷积神经网络推导和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Deep Learning论文笔记之（四）CNN卷积神经网络推导和实现
zouxy09@qq.com
http://blog.csdn.net/zouxy09
自己平时看了一些论文，但老感觉看完过后就会慢慢的淡忘，某一天重新拾起来的时候又好像没有看过一样。所以想习惯地把一些感觉有用的论文中的知识点总结整理一下，一方面在整理过程中，自己的理解也会更深，另一方面也方便未来自己的勘察。更好的还可以放到博客上面与大家交流。因为基础有限，所以对论文的一些理解可能不太正确，还望大家不吝指正交流，谢谢。
本文的论文来自：
Notes on Convolutional Neural Networks, Jake Bouvrie。
这个主要是CNN的推导和实现的一些笔记，再看懂这个笔记之前，最好具有CNN的一些基础。这里也先列出一个资料供参考：
[1] Deep Learning（深度学习）学习笔记整理系列之（七）
[2] LeNet-5, convolutional neural networks
[3]卷积神经网络
[4] Neural Network for Recognition of Handwritten Digits
[5] Deep learning：三十八(Stacked CNN简单介绍)
[6] Gradient-based learning applied to document recognition.
[7]Imagenet classification with deep convolutional neural networks.
[8] UFLDL中的“卷积特征提取”和“池化”。
另外，这里有个matlab的Deep Learning的toolbox，里面包含了CNN的代码，在下一个博文中，我将会详细注释这个代码。这个笔记对这个代码的理解非常重要。
下面是自己对其中的一些知识点的理解：
《Notes on Convolutional Neural Networks》
一、介绍
这个文档讨论的是CNNs的推导和实现。CNN架构的连接比权值要多很多，这实际上就隐含着实现了某种形式的规则化。这种特别的网络假定了我们希望通过数据驱动的方式学习到一些滤波器，作为提取输入的特征的一种方法。
本文中，我们先对训练全连接网络的经典BP算法做一个描述，然后推导2D CNN网络的卷积层和子采样层的BP权值更新方法。在推导过程中，我们更强调实现的效率，所以会给出一些Matlab代码。最后，我们转向讨论如何自动地学习组合前一层的特征maps，特别地，我们还学习特征maps的稀疏组合。
二、全连接的反向传播算法
典型的CNN中，开始几层都是卷积和下采样的交替，然后在最后一些层（靠近输出层的），都是全连接的一维网络。这时候我们已经将所有两维2D的特征maps转化为全连接的一维网络的输入。这样，当你准备好将最终的2D特征maps输入到1D网络中时，一个非常方便的方法就是把所有输出的特征maps连接成一个长的输入向量。然后我们回到BP算法的讨论。（更详细的基础推导可以参考UFLDL中“反向传导算法”）。
2.1、Feedforward Pass前向传播
在下面的推导中，我们采用平方误差代价函数。我们讨论的是多类问题，共c类，共N个训练样本。
这里表示第n个样本对应的标签的第k维。表示第n个样本对应的网络输出的第k个输出。对于多类问题，输出一般组织为“one-of-c”的形式，也就是只有该输入对应的类的输出节点输出为正，其他类的位或者节点为0或者负数，这个取决于你输出层的激活函数。sigmoid就是0，tanh就是-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ceb84952263c91fa68c6fcc44f0549d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81ec7ea3565d3f4d51bd509b41bf9b19/" rel="bookmark">
			.NET 调用外部exe程序，出现已停止工作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		趁热打铁，赶紧记录下来。
本身调用，使用Process.Start(“XX.exe”); 基本上是没问题的，但是有些需要读取配置文件的exe程序（目前将出现停止工作的原因归为这个，您有想法，请留言）会出现“程序已停止工作”，其实原理也简单的，本身调用的时候，目录是自己bin文件夹的路径，之后你设置其他路径的时候，就会出现错误，可以用cmd调试测试下，直接打开cmd，将exe要调用的程序拉入cmd中执行，看是否出错，如果不出错，那么使用Process.Start(“XX.exe”);调用也没问题的，如果出错，则是路径的问题。
解决方法如下：
cmd测试：先cd到exe程序的所在目录，之后将exe拉进去执行，我这测试就没问题，正常运行了，于是就有下一步，c#程序操作cmd来调用exe程序。
程序实现cmd调用外部exe程序：
Process p = new Process();//新进程 p.StartInfo.FileName = "cmd.exe";//打开cmd程序 p.StartInfo.UseShellExecute = false;//不使用shell启动程序 p.StartInfo.RedirectStandardInput = true; p.StartInfo.RedirectStandardOutput = true; p.StartInfo.RedirectStandardError = true; p.StartInfo.CreateNoWindow = true;//true表示不显示黑框，false表示显示dos界面 p.Start();//启动 p.StandardInput.WriteLine(@"cd\"); p.StandardInput.WriteLine(proSystem + ":");//proSystem为程序所在盘 exePosition = "cd " + fileStrName + "Mobai.App" + "\\" + btnName + @"\bin\Debug"; p.StandardInput.WriteLine(exePosition);//执行程序所在目录 p.StandardInput.WriteLine(btnName);//执行程序具体位置 p.StandardInput.WriteLine("exit");//退出 p.Close();//关闭 如果你打开的是记事本,或是config文件的话,去掉cd,直接打开地址.
转载于:https://www.cnblogs.com/bkycjj/p/3255485.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44df892add68ae3964e4e89fc27683de/" rel="bookmark">
			每天一个linux命令（41）：ps命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。
要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。
ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。
kill 命令用于杀死进程。
linux上进程有5种状态: 1. 运行(正在运行或在运行队列中等待) 2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process 1．命令格式：
ps[参数]
2．命令功能：
用来显示当前进程的状态
3．命令参数：
a 显示所有进程
-a 显示同一终端下的所有程序
-A 显示所有进程
c 显示进程的真实名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44df892add68ae3964e4e89fc27683de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30769351e2b0bd3a319b630b8128d5fe/" rel="bookmark">
			出现“error c4430缺少类型说明符-假定为int。注意C&#43;&#43;不支持默认int
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现“error c4430缺少类型说明符-假定为int。注意C++不支持默认int:
出现这种错误的原因，是因为函数没有写返回值。是在VC6.0的工程转为高版本（VS2010）的时候经常出现的;
#include &lt;stdio.h&gt;main(){ printf("hello,world\n");} 上面的代码在VC6.0中编译没错，但在VS2010编译出错，因为主函数没有返回值，加上void即可；
从网上下载的很多代码都是VC6.0环境下的，本人用的开发环境是VS2010，在升级代码时经常出现这个错误，错误的原因就是定义的函数没有返回值（把void省略了）。加上即可；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dcb15ef07de70bfab4042e7ef5e1be6/" rel="bookmark">
			CDialog上使用CToolBar&#43;CReBar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最经在做一些用户界面的东西，对话框上有很多按钮和组合框，全部加起来差不多有20多个吧，界面非常凌乱，最后决定用CToolBar + CReBar来重新设计界面，为什么选用这个呢?一是因为看到IE用的也是这个，二是用CReBar+透明的CToolBar可以实现漂亮的换肤效果。
1、在对话框类中添加成员变量:
CStatic m_static; CButton m_btn; CComboBox m_combo; CToolBar m_toolBar; CReBar m_reBar; 在OnInitDialog()添加如下代码：
1、用于创建工具栏和ReBar
if (!m_reBar.Create(this)) return FALSE; if (!m_toolBar.CreateEx(this)) return FALSE; //TBSTYLE_TRANSPARENT是使CToolBar透明，可以显示CReBar的背景。 //TBSTYLE_LIST用于设置按钮文字时，文字在按钮的右边，默认情况下是文字在按钮的下部 m_toolBar.ModifyStyle(0, TBSTYLE_TRANSPARENT | TBSTYLE_LIST); m_toolBar.GetToolBarCtrl().SetExtendedStyle(TBSTYLE_EX_DRAWDDARROWS);//设置下拉箭头样式 m_toolBar.SetButtons(NULL, 5);//设置ToolBar 按钮个数 m_reBar.AddBar(&amp;m_toolBar); 2、添加按钮：
CRect rect; int nIndex = -1; //添加文本 m_toolBar.SetButtonInfo(++nIndex, 0, TBSTYLE_BUTTON | BTNS_AUTOSIZE | TBSTYLE_AUTOSIZE | TBBS_DISABLED, -1); //此处是为了增加按钮的宽度，可以更加自己的需要适当的调整，由于是不可见字符，因此是透明的 m_toolBar.SetButtonText(nIndex, _T(" ")); m_toolBar.GetItemRect(nIndex, &amp;rect); rect.top += 3;//此处是为了让文本垂直居中 m_static.Create(_T("工具栏"), WS_CHILD | WS_VISIBLE | SS_CENTER | SS_SIMPLE, rect, &amp;m_toolBar); m_static.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dcb15ef07de70bfab4042e7ef5e1be6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c68ecc4e44ca56ad43cd52902c92a6f3/" rel="bookmark">
			udhcpc和udhcpd
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		udhcpc是dhcp拨号的客户端
udhcpd是dhcp拨号的服务器端
具体资料可以查看源码包中的README,man手册，官方网站，wiki，或者google。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd9681422a0de5e31e23a413e7296d7/" rel="bookmark">
			不要轻易修改你的主机名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不要轻易修改你的主机名 作者: Asher | 分类: Dataguard, Oracle, RAC | Tag: Dataguard, RAC | 评论: 0 字号： T| T 这篇文章不是标题党，是在实际工作中真切的案例。 场景：这是一套Windows Server 2008 R2 X64的系统，跑了一套10.2.0.5.0的oracle物理备库，运行一切正常。在客户的要求下，需要调整该服务器的机器名。
步骤：整理好调整的思路后，开始执行操作[包括停备库，ASM实例，修改hosts文件、tnsnames.ora文件等]，在客户IT人员修改完机器名并重启服务器之后，发现悲剧的一幕，机器无法正常启动，不过客户端倒是可以ping通服务器，但是无法通过远程桌面连接。
怎么办呢？经过分析和定位，感觉极有可能出问题的地方就是OracleCSService这个服务，而且该服务的启动类型是自动启动。也就是说该服务项会加载到windows系统的启动项里，随着操作系统的启动而启动，而该服务又是hard-coded,应该是同机器名进行“捆绑”的，由于修改了机器名，导致OracleCSService服务项不能正常启动，进而导致操作系统无法正常启动。
找到解决问题的思路之后，可以尝试重启服务器，进入安全模式，禁用该服务，然后重启机器，结果该机器已经无法再次进入安全模式，之前进去过，原因未知，客户IT硬件人员操作。
于是，一边尝试可以进入安全模式的方法，一边估计下下策的重装Windows系统，重建Dataguard的方案。结果，更为不可思议的是，服务器特么自己能够正常启动了，大家什么都没操作。接下来，就登录上去，果断重建了OracleCSService服务：
删除该服务： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 Microsoft Windows [Version 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cd9681422a0de5e31e23a413e7296d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36295af552554255905e52ab978da87a/" rel="bookmark">
			数据结构学习笔记(1.大O表示法和顺序表)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看国嵌唐老师的数据结构视频，觉得还不错，所以就把笔记记录下来
本节知识点： 1.数据之间的逻辑结构： 集合结构：数据元素之间没有特别的关系，仅同属相同集合 线性结构：数据元素之间是一对一的关系 树形结构：数据元素之间存在一对多的层次关系 图形结构：数据元素之间是多对多的关系 2.数据之间的物理结构 顺序存储结构：将数据存储在地址连续的存储单元里 链式存储结构：将数据存储在任意的存储单元里，通过保存地址的方式找到相关的数据元素 3.数据结构是相互之间存在一种或多种特定关系的数据元素的集合 4.程序 = 数据结构 + 算法 5.大O表示法：算法效率严重依赖于操作数量， 首先关注操作数的最高次项，操作数的估计可以作为时间和空间复杂度的估算，在没有特殊说明的时候， 我们应该分析复杂度的最坏情况 6.常见的复杂度类型： 大小关系： 7.线性表是零个或多个数据元素的集合，之间的元素是有顺序的，个数是有限的，数据类型必须相同。线性表包含两种存储方式，一种是顺序表，另一种链表。 8.对于线性表的使用是这样的：应该是在设计算法的时候，考虑算法中使用的数据，这些数据之间是什么关系的，如果是符合线性表特质的，就选择线性表作为数据结构。 9.顺序表与数组的关系：其实顺序表就是在数组的基础上构建的，本质跟数组是一样的，只是在数组的基础上增加了length长度，capacity容量等特性，然后补充了一些列，增、删、改、查的功能。 10. 我觉得链表比顺序表最大的优势，就在于链表的删除和插入要比顺序表简单的多，而且当线性表长度很大的时候很难开辟出整段的连续空间！！！最重要的是顺序表在创建的时候长度就固定了，再也改变不了了，而链表则可以根据情况动态增加，这一点是顺序表无论怎么样都不可能实现的！！！ 顺序表的优点是：无需为线性表中的逻辑增加额外的空间，可以快速的通过下标的方式找到表中的合法位置。 11.线性表的常用操作：创建线性表、销毁线性表、清空线性表、将元素插入线性表、将元素从线性表中删除、获取线性表中某个位置的元素、获取线性表的长度 本节代码： 1.本节的代码是一个可以适合各种类型的顺序表，之所以能够适合各种类型，是因为它在顺序表中保存的是元素的地址(其实就是一个指针数组)。 2.代码中的描述顺序表的结构体中的元素介绍：length是顺序表中有元素的个数、capacity是顺序表的容量、node是顺序表的头地址(也是这个指针数组的头地址)、还有一个就是pos，pos是在删除和插入的时候使用的一个参数，它代表的是插入到顺序表位置的下标(数组的下标 是从0开始的 这个很要注意)。顺序表中有length个元素 下标是从0到length-1的。 要注意的是 操作顺序表不同功能函数的pos的允许范围是不一样的。 3.本节代码对于函数参数的合法性判断是极其重视的，这个规范是值得学习的。 4.本节代码中对于顺序表的操作函数，凡是外界输入的，和输出到外界的，都是void *类型的，这样就保证了只有在这些操作函数中才能去改变 描述顺序表的结构体里面的值，在其他文件的函数中接受到的都是void *类型，无法直接给这个结构体中的值进行改变，这样的封装，保证了代码的安全性。 5.对于本节代码最值得思考的地方，常见的顺序表是typedef一个A类型，然后在顺序表中定义一个这个A类型的数组和length顺序表元素个数，这个顺序表中是好多个A类型的顺序集合，占用空间的大小是sizeof(A)*capacity。而本节的顺序表中是好多个unsigned int *地址类型的顺序集合，表中只有地址，第一节省了顺序表的空间，第二这样可以变相的保存不同类型的数据，第三它实现了 顺序表(即数据结构) 和 我们打算利用的数据(即元素)的分离。例如：linux内核链表(一个双向循环链表)就是一套单独的链表体制，这个链表用在很多机制上面，它就是变相的存储了好多类型的数据，并且实现了链表和数据的分离。 所以在main.c中 数据要想保存在这个顺序表中 就应该先给这些数据开辟内存 因为顺序表中没有他们呆的地方 顺序表中只能保存他们的地址。 如图： 代码如下： Seqlist.c： /************************************************************************************ 文件名：Seqlist.c 头文件：Seqlist.h 时间： 2013/08/05 作者： Hao 功能：可以复用 带有增 删 改 查 功能的顺序表 难点：1.顺序表中存放的都是 各种数据的地址 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36295af552554255905e52ab978da87a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124cd830f413565ef9493539698b8a2a/" rel="bookmark">
			关于oauth 2.0的 grant type 四种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参照这篇 博文
http://huoding.com/2011/11/08/126
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c05058adddd9cb918fd3bbb85e2c2b/" rel="bookmark">
			DB2 Error Messages (Sorted by SQLCODE)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DB2 Error Messages (Sorted by SQLCODE) DB2 Error Messages (Sorted by SQLCODE) SQLCODESQLSTATEDescription00000000The SQL statement finished successfully. 01xxxThe SQL statement finished successfully, but with a warning.+01201545The unqualified column name was interpreted as a correlated reference.+09801568A dynamic SQL statement ends with a semicolon.+10002000No rows found to satisfy the SQL statement.+11001561Update to a table defined using DATA CAPTURE was not signaled to originating subsystem. (DPROP)+11101590The SUBPAGES clause was specified (and ignored) for a Type 2 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08c05058adddd9cb918fd3bbb85e2c2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85c4b8b1efeffcb28cc2a453a4c87e38/" rel="bookmark">
			Libosip/libeXosip 交叉编译以及在DM6467的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Libosip/libeXosip 交叉编译以及在DM6467的使用
1、 最新libosip/libeXosip的下载地址：
libosip2-4.0.0.tar.gz http://www.antisip.com/download/exosip2/
libeXosip2-4.0.0.tar.gz http://www.antisip.com/download/exosip2/
SIP协议解析，基本原理等建议CSDN搜索，有较多热心网友文章可以参考，经验宝贵。
2、 设置好交叉编译环境:
创建目录/home/user_xxx/arm_target, /home/user_xxx/build, /home/user_xxx/sources,将全部压缩包放到/home/user_xxx/sources下，解压：
tar –xvf libosip2-4.0.0.tar.gz
tar –xvf libeXosip2-4.0.0.tar.gz
3、 交叉编译libosip2:
1) mkdir /home/user_xxx/build/libosip2
2) cd /home/user_xxx/build/libosip2
下一步很重要，关系到编译出的库是否能在你的目标板使用，红色部分为目标板使用的交叉编译器，注意路径要正确。
3) ../../sources/libosip2-4.0.0/configure --prefix=/home/user_xxx/arm_target --enable-shared --disable-static
4) make
5)make install 6)编译成功后在/home/user_xxx/arm_target/lib下能够看到你需要的库。
4、 交叉编译libeXosip2:
一定要先编译libosip2库，libeXosip2是对libosip2的进一步封装和扩展，如果先编译libeXosip2会编译失败。
1) mkdir /home/user_xxx/build/libeXosip2
2) cd /home/user_xxx/build/libeXosip2
3) ../../sources/libeXosip2-4.0.0/configure --prefix=/home/user_xxx/arm_target --enable-shared --disable-static PKG_CONFIG_PATH=/home/user_xxx/arm_target/lib/pkgconfig/
4) make
5) make install
6) 一定要选择相同的版本，否则编译出错。
5、 编译结果：
6、 目标板Makefile中依赖共享库的项目的编译：
参考附录。
7、 验证osip2/eXosip2库是否可用：
测试osip2/eXosip2库是否可用，不需要很复杂的代码，我们这里只调用eXosip_init()就可以检验以上操作是否正确。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85c4b8b1efeffcb28cc2a453a4c87e38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0bd82b97c70659dde270a8c927a75ad/" rel="bookmark">
			解决win7&#43;ubuntu双系统，win7下网卡驱动一切正常，却无法连接的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景：win7+ubuntu双系统，用EasyBCD作系统引导。笔记本是宏基V5-573G 现象：win7下无线网卡驱动安装正常，设备已开启，却无法连接。右下角wifi处只有一个红叉，无论怎样安装驱动或者修复都不好用。 解决：将ubuntu的wifi打开，重启，win7下的wifi就可以用了。 尼玛什么原理，分区什么的都不在一块 -----------------------初步判断问题原理 http://bbs.9gal.com/read.php?tid=393082&amp;fpage=0&amp;toread=&amp;page=2 不是这些问题,部分无线网卡和wwan卡是一样的原理 本身要先上载固件到卡上,然后进行初始化和操作,然而ubuntu和windows上载的固件是不同的 于是就造成了ubuntu初始化之后跟win下的驱动控制方式不对应,导致无法控制 ubuntu自己的驱动又有毛病导致不停arp= =... 楼主,我劝你别这么蛋疼 你完全可以装个win7,需要ubuntu的话用vmware虚拟机装就好了,效率比你来回切好得多 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95da3a3b1c301eb3eabfa196db4667d9/" rel="bookmark">
			严重: Exception sending context initialized event to listener instance of class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		严重: Exception sending context initialized event to listener instance of class com.i2f.common.utils.SpringContextLoaderListener
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'envPropertyWatchdog' defined in class path resource [i2shopping/i2shopping-resources.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [com.i2f.i2shopping.core.support.EnvPropertyWatchdog]: Constructor threw exception; nested exception is java.lang.NullPointerException
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:883)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:839)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:440)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409)
at java.security.AccessController.doPrivileged(Native Method)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380)
at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95da3a3b1c301eb3eabfa196db4667d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06fefb0cde3fbfc7da198498b6f225d0/" rel="bookmark">
			python lxml模块安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：http://www.cnblogs.com/zhuyp1015/archive/2012/07/17/2596495.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f31aebcd048a15c5f938ae04b60879/" rel="bookmark">
			Linux使用 dd 命令 创建特定大小文件最简单的方法 及 文件杂谈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 创建特定大小文件最简单的方法是使用 dd 命令。 dd if=“inputFileName” of="outFileName" bs="块大小" count=“块个数” 块大小可以使用各种计量单位 字节(1B) - c 字(2B) - w 块(512B) - b 千字节(1024B) - k 兆字节(1024K) - M 吉字节(1024M) - G 例： dd if=/dev/zero of=test.file bs=1M count=10 在当前文件夹下创建一个大小为10M的文件test.file 内容全为0 /dev/zero 是一个字符设备，它会不断返回0值字节（\0）. 如果不指定输入参数(if)，默认情况会从stdin读取输入。如果不指定输出参数(of)，默认情况会将stdout作为输出。 也可用 dd 命令来传输大量数据来测试内存的操作速度。 $ dd if=/dev/zero of=./testmm.file bs=10M count=10 记录了10+0 的读入 记录了10+0 的写出 104857600字节(105 MB)已复制，0.577581 秒，182 MB/秒 $ ll -h |grep 'testmm.file' -rw-rw-r--. 1 itudu itudu 100M 7月 16 18:14 testmm.file 文件类型： 一般文件： - 目录文件： d 字符设备： c 块设备: b 链接文件： l 套接字文件: s 管道文件： p 目录的读、写、执行权限意义： 读权限：允许读取目录中文件和子目录的列表 写权限：允许在目录中新建和删除文件或子目录 执行权限：可以访问目录中的文件和子目录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28af21390f68db451d630158eb0d8f76/" rel="bookmark">
			批处理追加环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先判断该环境变量是否已经存在,如果不存在则添加该环境变量。
下面以追加路径：D:\MyPath 为例子
@echo off @set Path_=D:\MyPath for,/f,"skip=4 tokens=1,2,*",%%a,in,('reg query "HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment" /v Path'),do,( @set PathAll_=%%c ) echo %PathAll_%|find /i "%Path_%" &amp;&amp; set IsNull=true|| set IsNull=false if not %IsNull%==true ( reg add "HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment" /v Path /t REG_EXPAND_SZ /d "%PathAll_%;%Path_%" /f ) @echo on path @echo off @pause 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/854fbe2cd72422c6b943651b7cfd9c95/" rel="bookmark">
			工厂三兄弟之抽象工厂模式（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2 产品等级结构与产品族 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法具有唯一性，一般情况下，一个具体工厂中只有一个或者一组重载的工厂方法。但是有时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。为了更好地理解抽象工厂模式，我们先引入两个概念：
(1) 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
(2) 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。
产品等级结构与产品族示意图如图3所示：
图3 产品族与产品等级结构示意图
在图3中，不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构。图3中一共有五个产品族，分属于三个不同的产品等级结构。我们只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一确定这个产品。
当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如图4所示：
图4 抽象工厂模式示意图
在图4中，每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，图4所示结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大减少了系统中类的个数。
【作者：刘伟 http://blog.csdn.net/lovelion】
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/564/">«</a>
	<span class="pagination__item pagination__item--current">565/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/566/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>