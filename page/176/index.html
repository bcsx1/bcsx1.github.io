<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61525986fc4ebe24466d4c5c2fbadcca/" rel="bookmark">
			Qt多线程等待框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.问题背景 动图gif作等待框时，主线程会因运行指定任务而占用导致出现界面假死，故采用多线程。
本等待框适用于可拆分步骤的计数类型(已知总数，每完成一部分刷新进度条百分比界面)。
参考文章的博主主页
二.代码 1.继承QThread的任务类。
#ifndef KQTASKTREAD_H #define KQTASKTREAD_H #include &lt;QThread&gt; #include &lt;QWidget&gt; #include &lt;functional&gt; class KQTaskTread : public QThread { Q_OBJECT public: KQTaskTread(QWidget* widget,const std::function&lt;void()&gt;&amp; task); signals: void taskFinish(); // QThread interface protected: void run() override; std::function&lt;void()&gt; m_task = nullptr ;//C++11兼容多种函数声明类型，函数指针 QWidget* m_wait_ui; }; #endif // KQTASKTREAD_H #include "kqtasktread.h" KQTaskTread::KQTaskTread(QWidget* widget,const std::function&lt;void()&gt;&amp; task) { this-&gt;m_task = task; m_wait_ui = widget; if ( this-&gt;m_wait_ui != nullptr ) { connect(this,SIGNAL(taskFinish()),m_wait_ui,SLOT(close())); } } void KQTaskTread::run() { if ( this-&gt;m_task !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61525986fc4ebe24466d4c5c2fbadcca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7ce2121b5568960ae434173659fea50/" rel="bookmark">
			Java基础框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Spring是什么？
Spring是一个Service 层的框架，可以整合许多其他框架进行工作。
Spring的主要技术是IOC(控制反转)和AOP(面向切面编程)。
①什么是控制反转？
简单来讲就是将对象创建的权利和对象生命周期的管理过程交给Spring框架来处理，从而在开发的过程中不再需要关注对象的创建和生命周期的管理，而是需要时由Spring框架来提供，这个由Spring框架管理对象创建和生命周期的机制叫做控制反转。在创建对象的过程中，Spring可以通过对对象属性的进行设置，这个过程称之为依赖注入，也就是DI。
②IOC的实现原理
在创建一个Spring容器时，Spring会去解析指定的xml文件，当解析到其中的&lt;bean&gt;标签时，会根据其中的class属性指定类的全路径名，通过反射创建该类的对象，并将该类存入内置的Map中进行管理，其中键就是该标签的id值，值就是该对象。之后，通过getBean方法来从容器中获取对象时，其实就是根据传入的条件在内置的Map中进行匹配，如果有则返回，没有则抛出异常。
③IOC获取对象的方式：
通过context.getBean()方法获取bean时有两种方式：
传入id值，传入class类型
通过class方式获取bean时，若同一个类匹配多个bean，则在获取时因为无法确定到底要获取哪个bean会抛出异常，同时，在获取bean时，若找不到该类型的bean还会去检查是否存在该类型的子孙类型bean，若有，则返回若找不到或找到多个则抛出异常，符合面向对象多态的特性，而id是惟一的，不存在这样的问题，所以尽量使用id。
④Spring创建对象的方式
通过类的无参构造方法创建对象：
通过指定构造器创建对象
通过工厂创建对象
2.单例和多例
Spring默认采用单例模式，减少了对象的创建，从而减少了内存的消耗，但在开发过程中是存在多例的需求的，Spring也提供了选项可以将bean设置为多例。
bean在单例模式下，spring容器启动时解析xml发现该bean标签后，直接创建该bean对象并存入map中，此后无论调用多少次getBean（）获取该对象时返回的都是一个对象，此对象一直被spring容器持有，直到容器退出时，对象被移出容器。
bean在多例模式下，spring在解析时，只是将bean进行管理，并不会创建对象，每次调用返回的都是一个新的对象，这个对象spring容器并不会拥有，何时销毁取决于用户程序本身。
3.懒加载机制：
可以规定指定的bean不在启动时就立即创建，而是在后续第一次用到时才创建，从而减轻启动过程中对时间和内存的消耗。懒加载机制只对单例bean有作用，对于多例bean设置懒加载是没有意义的，懒加载只是延后了对象创建的时机，对象仍是单例的。
①为指定的bean配置懒加载：&lt;bean id ="" class="" lazy-init=''true"&gt;&lt;/bean&gt;
②为全局配置懒加载：&lt;default-lazy-init="true"&gt;
如果同时设定全局变量和指定变量，且配置不相同，则局部配置覆盖全局配置
4.自动装配：
自动装配就是要根据要设置的javabean属性的名字或类型到spring中自动寻找对应id或类型的bean进行注入设置，从而省去依次配置的过程，简化了配置。
5.spring注解方式实现IOC和DI
spring除了默认的使用xml配置文件的方式实现配置之外，也支持使用注解方式实现配置，这种方式效率更高，配置信息清晰，代码在哪对应的配置就在哪，方便开发阶段进行修改。
①spring注解方式实现IOC
a、导入开发包;
b、编写配置文件，并导入context约束;
c、开启包扫描;&lt;context:component-scan base-package=""&gt;&lt;/context:component-scan&gt;
d、使用注解注册bean：在配置的包中的类上使用@Component注解，则这个类会自动被注册为bean
e、bean的id；通常情况下注解注册bean实用类名首字母小写为bean的id，但是如果类名的第二个字母为大写则首字母保留原样。
f、也可以通过在@Component中配置value属性，明确的指定bean的id；
g、在bean中的属性上通过@Autowired实现自定义bean类型的属性注入
h、当spring解析到@Component注解时，创建当前类的bean在spring容器中进行管理，在创建bean的过程中发现了@Autowired注解，会根据当前的bean类型，寻找在spring中是否存在该类型的bean，找到直接注入，找不到则会检查其子孙类，实现类是否存在，若存在唯一的则自动注入，若没有找到或者找到多个无法注入，则会按照属性名对应的id去查找对应的bean，若存在则注入，否则抛出异常。
I、其他的一些注解：@Scope（value=“prototype”），配置是单例还是多例，默认为单例
@Lazy懒加载机制
@PostConsrtuct修饰某个方法，将该方法声明为初始化方法，对象创建后立即执行。
@PreDestroy修饰某个方法，将该方法声明为销毁的方法，对象销毁前调用的方法。
@Controller（控制层，一般用在web层）；
@Service（业务访问层，一般用在service层）；
@Respository（数据访问层，一般用在dao层）；
@Component（通用的注解）四个功能完全相同，都是用来修饰类，将类声明为Spring管理的bean的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566200bef0aa2daaa370819e7286cd63/" rel="bookmark">
			R语言读取excel和csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、读取csv文件 1.可以直接读取，无需安装包。
#读取以逗号为分隔组的CSV文件 data = read.csv('datafile.csv') 2.如果文件是有分隔符的类型，则需加上seq参数，如果是空格分隔符使用seq=’ ’如果是制表符分隔，使用\t，如果是逗号就是seq = ','。
#读取不同分隔符的数据 data = read.csv('datafile.csv',seq = '') 3.如果一个数据文件首行没有列名，加上header=FALSE可以增加列名，这时列名为v1,v2,v3…可对列名进行更改。
​ ​#读取没有列名的数据，这时会为数据自动生成列名v1,v2,v3... data = read.csv('datafile.csv',header = FALSE) #为列添加或更改列名 names(data) = c('column1','column2','culumn3') ​ 4.在默认情况下字符串类型的数据列都被转换为因子型，一些数据分析和处理可能用的类型不同，可以进行相互转换。
#读取的数据字符串保留为字符串型 data = read.csv('datafile.csv',stringsAsFactors = FALSE) #可再将其转换为字符型 data$column1 = factor(data$column) 二、读取excel文件 读取Execl文件可以将excel文件转换为csv文件再进行读取（打开excel文件、点击文件、点击另存为、选择保存地址、文件类型选择csv然后保存），也可以下载包，这里推荐使用readxl包，不推荐使用xlsx，使用xlsx还需要安装Java，如果没有的话就比较麻烦。
使用readxl读取excel文件。sheet参数为工作簿中的工作簿。
#读取excel文件 library(readxl) data = read_excel('datafile.xlsx',sheet = '1') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/097f4f425b052a46fa387e6bfc5b47ee/" rel="bookmark">
			用 visio 2013 绘制倾斜立方体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依次点击“形状”→“更多形状”→“常规”→“方块” 2
. 选择“三维框”形状即可，后续可根据需求对其进行缩放、变形、反转等操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce5585f2c19129921b74ca39b3f0d98e/" rel="bookmark">
			禅道和数据库端口冲突报错SQL连接异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上午无意间装了禅道研究了一下子，后来也没有在意就关了。中午再启动代码的时候报了一堆错误，检查了数据库也没什么问题，回退了版本还是报错。突然间想起来可能是装了禅道的原因。附上报错截图：
解决办法：
找到；禅道的安装包 里面找到start.exe
打开 然后点左上角卸载服务
如果禅道也要用的话可以点左上角-服务-配置端口 把端口号改成3307
OK 完美解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad9974b6f735a2dddaabd0213a4bb1f/" rel="bookmark">
			用 visio 2013 让插入的图片倾斜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选中需要倾斜的图片
依次点击“开始”→“效果”→“三维旋转”
选择需要旋转的形式即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82fbd3b386d61c28b730a9993b40cecf/" rel="bookmark">
			用 visio 2013反转图形或镜像图形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件版本：visio 2013
选择待反转图形，依次点击“开始”→“位置”→“旋转形状”，即可根据需求进行图形反转。
若需要进行图形镜像操作，可提前将图形复制出一份，将复制出来的图形进行垂直反转或水平反转。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c242b76ff10a4f3393e257236281a4/" rel="bookmark">
			AndroidStudio：新Logcat过滤规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 过滤规则：package:mine level:error 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9cfb8d918ce5fedd6c8d7e3082709e/" rel="bookmark">
			总结几个简单好用的Python人脸识别算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家总结几个简单、好用的人脸识别算法。人脸识别是计算机视觉中比较常见的技术，生活中，我们接触最多的人脸识别场景是人脸考勤。
人脸识别的算法最核心的工作是从一张图片中识别出人脸的位置。识别的算法可以说是多种多样， 下面我就来为大家一一介绍下。
1. HoG人脸检测 该算法采用传统的机器学习算法来识别人脸。传统机器学习算法的特点是人工构造特征，然后将构造好的特征送入模型训练。
该算法用HoG提取图片中人脸特征，用SVM算法进行分类。
HoG（Histogram of Oriented Gradient, 方向梯度直方图）特征是一种在计算机视觉和图像处理中用来进行物体检测的特征描述子，通过计算和统计图像局部区域的梯度方向直方图来构成特征。
dlib库中有该算法的实现，下面我们看看核心代码
import dlib# 加载预训练的 HoG 人脸检测器hog_face_detector = dlib.get_frontal_face_detector()# 对图片进行人脸检测results = hog_face_detector(imgRGB, 0)for bbox in results: x1 = bbox.left() # 人脸左上角x坐标 y1 = bbox.top() # 人脸左上角y坐标 x2 = bbox.right() # 人脸右下角x坐标 y2 = bbox.bottom() # 人脸右下角y坐标 results 存放一张图中检测出来的多个人脸， 遍历results可以得到每张人脸的矩形框。
检测示例如下：
绿框框出来的就是算法检测出来的人脸。
HoG 人脸检测由于采用传统机器学习算法，所以性能比较高，在CPU上运行也可以比较快。但它无法检测小于 80*80 的人脸，对旋转人脸、非正面人脸，识别效果也不太好。
2. 深度学习人脸检测 虽然传统机器学习算法检测更快，但准确度却有待提升。基于深度学习的人脸检测算法往往会更加准确。
这里介绍的是使用残差网络ResNet-10通过网络（模型）在图像的单通道（ Single Shot Detector，SSD）中检测多个人脸。简称SSD算法。
首先，需要将原始图片进行blob预处理，然后直接送入模型，进行检测
cv2库提供了该算法的实现，核心代码如下：
import cv2# 加载预训练的 SSD 模型opencv_dnn_model = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c9cfb8d918ce5fedd6c8d7e3082709e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5caaa2de6d0270dbeeff3220ed3aca75/" rel="bookmark">
			PyQGIS开发 -- 基础学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自主学习QGIS开发 虽然QGIS本身功能强大，但还是架不住我们要编写新的功能、新的业务流程、新的算法。前文中我们提到，扩展QGIS有2种方法，一是用Python、C++来写QGIS的插件；另一种就是基于QGIS的C++ API开发独立应用程序。然而后者资料甚少，官方C++ API文档也非常简略，我也不可能把所有功能都列举出来，放到博客里。因此我们想要开发更多功能，就得借助一大利器——PyQGIS的文档了。
2、PyQGIS Python是一种面向对象、直译式的电脑程式语言，具有近二十年的发展历史。它包含了一组功能完备的标准库，能够轻松完成很多常见的任务。它的语法简单，与其它大多数程式设计语言使用大括号不一样，它使用缩进来定义语句块。 Python由于有着较高的开发效率，并且具有胶水语言的特性，被广泛应用于各种系统当中。ArcGIS与QGIS也不例外。QGIS项目中，使用了sip库来实现Python与C++代码的绑定。QGIS官方称之为PyQGIS。
QGIS软件里面，专门有一个Python的控制台，用于使用Python脚本，实现一些特殊功能。开启方法为：Plugins → Python Console。效果图如下：
由于Python的种种优势，QGIS官方写了一个PyQGIS cookbook的文档，里面对PyQGIS进行了详细的介绍。文档内容包括但不限于：
-载入图层
-使用栅格图层
-使用矢量图层
-处理几何形体
-投影变换
-地图渲染、打印
研究PyQGIS文档，就会发现，里面各个类的名称，与QGIS的C++ API中的名称一样。因此，我们可以通过QGIS的Python文档，来学习QGIS C++的开发。
3、举例——载入图层 上一篇中提到的，我们的第一个QGIS程序中的一个功能，就是打开Shapefile文件，并显示出来。如果我们通过PyQGIS的文档，该怎样学习开发呢？
我们应该先在PyQGIS中，找到相应功能的文档介绍。比如载入图层，就是：http://docs.qgis.org/testing/en/docs/pyqgis_developer_cookbook/loadlayer.html
里面介绍载入OGR图层（Shapefile属于OGR图层），代码如下：
vlayer = QgsVectorLayer("/path/to/shapefile/file.shp", "layer_name_you_like", "ogr") 我们”翻译“成C++的代码，就是：
QgsVectorLayer *vlayer = new QgsVectorLayer("/path/to/shapefile/file.shp", "layer_name_you_like", "ogr"); 可以看出来，Python代码转化为C++代码非常方便。
文档中还介绍了载入栅格图层的Python代码：
fileName = "/path/to/raster/file.tif" fileInfo = QFileInfo(fileName) baseName = fileInfo.baseName() rlayer = QgsRasterLayer(fileName, baseName) if not rlayer.isValid(): print "Layer failed to load!" 其对应的C++代码就可以写成：
QString fileName = "/path/to/raster/file.tif"; QString fileInfo = QFileInfo(fileName); QString baseName = fileInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5caaa2de6d0270dbeeff3220ed3aca75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d716e9557e677d21bd90525ab8588f/" rel="bookmark">
			K8S---Pod进阶资源限制以及探针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Pod 进阶
1、资源限制
2、Pod 和 容器 的资源请求和限制：
3、CPU 资源单位
4、内存 资源单位 5、实例操作
5.1 示例1
5.2 示例2
6、重启策略（restartPolicy）
6.1 示例1
二、健康检查：又称为探针（Probe） 1、探针的三种规则
2、Probe支持三种检查方法
3、官网示例
4、exec方式
4.1 示例1：exec方式
5、httpGet方式
5.1 示例2：httpGet方式
6、tcpSocket方式
6.1 示例3：tcpSocket方式
7、就绪检测
7.1 创建readiness-httpget资源
7.2 查看pod状态
7.3 进入资源里
7.4 查看pod状态
8、就绪检测2
8.1 创建readiness-myapp资源
8.2 查看资源的具体状态
8.4 readiness探测失败，Pod 无法进入READY状态，且端点控制器将从 endpoints 中剔除删除该 Pod 的 IP 地址
9、启动、退出动作
9.1 创建资源
9.2 查看pod具体状态
9.3 查看/var/log/nginx/nessage的信息
9.4 在node02节点上查看
9.5 在master节点上删除pod，再到node02节点上查看
一、Pod 进阶 1、资源限制 当定义 Pod 时可以选择性地为每个容器设定所需要的资源数量。 最常见的可设定资源是 CPU 和内存大小，以及其他类型的资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d716e9557e677d21bd90525ab8588f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41cbe0305a6c4a087967134533ff51b2/" rel="bookmark">
			Android：IdleHandler的简单理解和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IdleHandler的简单理解和使用 1、IdleHandler 是什么2、IdleHandler 使用方式2.1、添加和删除2.2、执行 3、常见问题和使用场景3.1、使用场景3.2、常见问题 参考 1、IdleHandler 是什么 IdleHandler 说白了，就是 Handler 机制提供的一种，可以在 Looper 事件循环的过程中，当出现空闲的时候，允许我们执行任务的一种机制。
IdleHandler 被定义在 MessageQueue 中，它是一个接口。
public final class MessageQueue { public static interface IdleHandler { boolean queueIdle(); } } 返回值为 false，即只会执行一次；返回值为 true，即每次当消息队列内没有需要立即执行的消息时，都会触发该方法。 基本使用方法
Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() { @Override public boolean queueIdle() { Log.v(TAG, "#looper message has worked out"); return false; } }); } 2、IdleHandler 使用方式 2.1、添加和删除 在MessageQueue中：
private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;&gt;(); public void addIdleHandler(@NonNull IdleHandler handler) { if (handler == null) { throw new NullPointerException("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41cbe0305a6c4a087967134533ff51b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07e59b30f5da9ffb1c4f7be20b90bea4/" rel="bookmark">
			K8S---pod基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、资源限制
二、Pod 的两种使用方式
三、Pod 资源共享
四、底层容器Pause
1、Pause共享资源
1.1 网络
1.2 存储
1.3 小结
2、Pause主要功能
3、Pod 与 Pause 结构的设计初衷
五、Pod容器的分类
1、基础容器（infrastructure container）
2、初始化容器（init container）
3、应用容器（main container）
六、操作示例
1、编写myapp.yaml
2、创建myapp.yaml配置资源
3、查看pod创建过程
4、查看pod日志
5、编写myservice.yaml
6、创建 myservice.yaml 配置资源
7、编写mydb.yaml
8、创建mydb.yaml配置资源
9、查看 myapp-pod 创建全过程
10、小结
七、镜像拉取策略（Image PullPolicy）
1、官方示例
2、不指定版本，查看默认拉取策略
2.1 不指定版本号创建pod
2.2 查看默认拉取策略
2.3 查看创建过程
3、测试案例（非循环命令）
3.1 创建测试案例mypod.yaml
3.2 生成mypod配置资源
3.3 查看创建过程
3.4 修改mypod.yaml
3.5 删除原有资源
3.6 更新资源
3.7 在node1节点使用curl查看头部信息
4、测试案例（循环命令）
4.1 修改mypod.yaml
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07e59b30f5da9ffb1c4f7be20b90bea4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00703cc15763c90351d585c5088a73b9/" rel="bookmark">
			K8S---yaml文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、K8S支持的文件格式
1、yaml和json的主要区别
2、YAML语言格式
二、YAML
1、查看 API 资源版本标签
2、编写资源配置清单
2.1 编写 nginx-test.yaml 资源配置清单
2.2 创建资源对象
2.3 查看创建的pod资源
3、创建service服务对外提供访问并测试
3.1 编写nginx-svc-test.yaml文件
3.2 创建资源对象
3.3 访问测试
三、详解K8S中的Port
四、试运行生成 yaml 模板后创建实例
1、–dry-run：试运行
2、查看生成yaml格式
3、查看生成json格式
4、使用 yaml 格式导出生成模板
5、使用 yaml 模板创建实例
6、将现有资源生成 yaml 模板导出并保存为文件
7、查看字段帮助信息
五、总结
一、K8S支持的文件格式 kubernetes支持YAML和JSON文件格式管理资源对象。
JSON格式：主要用于api接口之间消息的传递
YAML格式：用于配置和管理，YAML是一种简洁的非标记性语言，内容格式人性化，较
易读
1、yaml和json的主要区别 YAML 使用空格缩进，这是 Python 开发人员熟悉的领域。JavaScript 开发人员喜欢 JSON，因为它是 JavaScript 的一个子集，可以直接在JavaScript中解释和编写，同时使用简写方式声明 JSON，在使用没有空格的典型变量名时，不需要键中的双引号。有很多解析器在 YAML 和 JSON 的所有语言中都能很好地工作。在许多情况下，YAML 的空白格式可以更容易查看，因为格式化需要更人性化的方法。
如果您的编辑器中没有空格可见或缩进线指示符，那么 YAML 的空白虽然更紧凑，更容易查看，但可能难以手动编辑。JSON 的序列化和反序列化要快得多，因为要检查的功能明显少于 YAML，这使得更小更轻的代码能够处理 JSON。一个常见的误解是 YAML 需要较少的标点符号并且比 JSON更紧凑，但这完全是错误的。空格是不可见的，所以看起来字符较少，但是如果你计算实际的空格是必要的，以便正确解释 YAML以及正确的缩进，你会发现 YAML 实际上需要比 JSON 更多的字符。JSON不使用空格来表示层次结构或分组，并且可以通过删除不必要的空格来轻松展平，以实现更紧凑的传输。 2、YAML语言格式 大小写敏感使用缩进表示层级关系不支持 Tab 键制表符缩进，只使用空格缩进缩进的空格数目不重要，只要相同层级的元素左侧对齐即可，通常开头缩进两个空格符号字符后缩进一个空格，如冒号，逗号，短横杠（-）等— 表示 YAML 格式，一个文件的开始，用于分隔文件# 表示注释 二、YAML 1、查看 API 资源版本标签 kubectl api-versions 2、编写资源配置清单 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00703cc15763c90351d585c5088a73b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7aa7d32233befb8852d359547b6f7c4/" rel="bookmark">
			Linux下让普通用户能够执行sudo systemctl stop xxx.service
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 背景 我想让普通用户(例如:app)运行1024端口以上的服务，且服务的启停必须用systemd来管理。
普通用户：用户不能过期，要有家目录，要能够远程登录，密码复杂化。定期更改密码是后话。
1.2 实现 "1024以上端口的服务"的相关目录其属主/组得为app
root@vm7-201:~# root@vm7-201:~# ls -ld /data/prometheus/prometheus/ drwxr-xr-x 5 app app 144 Feb 26 20:14 /data/prometheus/prometheus/ root@vm7-201:~# root@vm7-201:~# ls -l /data/prometheus/prometheus/ total 206448 -rw-r--r-- 1 app app 11357 Dec 9 21:06 LICENSE -rw-r--r-- 1 app app 3773 Dec 9 21:06 NOTICE drwxr-xr-x 2 app app 38 Dec 9 21:06 console_libraries drwxr-xr-x 2 app app 173 Dec 9 21:06 consoles drwxr-xr-x 4 app app 70 Feb 26 22:05 data -rwxr-xr-x 1 app app 109779661 Dec 9 20:49 prometheus -rw-r--r-- 1 app app 934 Dec 9 21:06 prometheus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7aa7d32233befb8852d359547b6f7c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aec1cb9c10a7f1c80cc5ffce340ee2a/" rel="bookmark">
			在visio中插入数学公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：安装 visio 2013、Mathtype。
依次点击“插入”→“对象”，弹出对话框“插入对象”。在弹出的对话框内点击“Microsoft 公式 3.0”，点击“确定”，弹出“Mathtype”编辑界面，即可插入公式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983971cbb09a737b62f2ed5874ebc76c/" rel="bookmark">
			DataNode无法启动的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb4b7d3d0014d14ed6e209b9bfefecd/" rel="bookmark">
			15、条件概率、全概率公式、贝叶斯公式、马尔科夫链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		条件概率 定义：设A、B是两个事件，且，P(A) &gt; 0 则称 为事件A发生的条件下事件B的条件概率
对这个式子进行变形，即可得到概率的乘法公式：
P(A) &gt; 0 时，则
P(B) &gt; 0 时，则
乍一看，这个式子不就是把除法形式写成了乘法形式嘛，不然不然，这个区别是本质的，分母不为0很关键，而且看法也不同：前面的是条件概率，后面的是概率的乘法公式。
概率的乘法公式，起源于概率的乘法原理，一件事情发生的概率等于造成这件事发生的接连发生的事件概率的乘积，如果要让A，B同时发生，那么就让其中一个先发生，不妨设为A吧，A发生以后B再发生，这样子的话，A，B就会同时发生了，根据概率的乘法原理如下
概率的乘法公式的n个事件的形式:
如果要使n件事件同时发生，不妨先发生 ，接着再发生 ,
全概率公式 若事件满足下列两条
则称 为完备事件组
全概率公式如:
以n=3为例：
比如一件事情的结果就只有三种 ，也知道它们发生的概率，但是呢，这时候偏偏有一个事件B也发生了，我们的目的是找出B发生的概率，于是呢，我们让B与 发生联系，从而进行试验，可以得到各自的条件概率 ,那么这就足够了，我们就可以得到事件B发生的概率
贝叶斯公式 贝叶斯定理的发明者 托马斯·贝叶斯 提出了一个很有意思的假设：“如果一个袋子中共有 10 个球，分别是黑球和白球，但是我们不知道它们之间的比例是怎么样的，现在，仅通过摸出的球的颜色，是否能判断出袋子里面黑白球的比例？”
简单而言就是已知结果找原因
设是完备事件组，且
B 为任意事件，P(B) &gt; 0,则
对于这个公式的理解主要靠上面那句话。什么是结果?什么又是原因？对于全概率公式，我们说是为了求事件B发生的概率所做的试验，这些就是结果了，那么反过来，我们找原因，这些完备事件在B发生时的条件概率就是我们所要查照的原因了。
通常把 叫做先验概率，就是做试验前的概率，就是经验了；而把 叫做后验概率，在统计决策中十分重要，由此得到的决策叫做贝叶斯决策。也就是说我们在对经验不断地更新和修正，当然是利用生活实践，即所谓试验。（又是一个人生哲理，对于很多事情，就是要不断地利用当前的经验来进行试错，不断地修正，从而达到自我的一个最佳状态
马尔科夫链 定义一种表述方法，考虑只取有限个或可数个值的随机过程 若 ，则称过程在 n 时刻处于状态 i。
马尔可夫性：给定过去的状态 和现在的状态 ，将来的状态 的条件分布与过去的状态独立，只依赖于现在的状态，这样的性质称为马尔可夫性。
如果我们用 A表示过去的状态，用 B 表示现在的状态，而用 C 表示将来的状态，即
则马尔科夫性可以用条件概率直观表示为
等价推出
因此马尔可夫性也可以理解为在已知现在状态的条件下，过去与将来相互独立
马尔科夫链：设随机过程 的状态空间 I 有限或可列，如果它具有马尔科夫性，即对任意的状态 和任意的 有
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bb4b7d3d0014d14ed6e209b9bfefecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a0ce7c227086d52a07899dcc6e29db0/" rel="bookmark">
			Hive--开窗函数--窗口位置函数：LAG、LEAD、FIRST_VALUE、LAST_VALUE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		窗口位置函数 窗口函数：LAG、LEAD、FIRST_VALUE、LAST_VALUE总结FIRST_VALUELAST_VALUELAGLEAD 窗口函数：LAG、LEAD、FIRST_VALUE、LAST_VALUE 总结 不指定窗口时,不排序默认第一行到最后一行,排序默认第一行到当前行
指定窗口时 --rows between 起始位置 and 结束位置
N preceding：往前多少行N following：往后多少行current row：当前行unbounded：起点或者终点，没有边界unbounded preceding 表示从前面的起点unbounded following：表示到后面的终点 FIRST_VALUE
功能：取每个分区内某列的第一个值语法：FIRST_VALUE(col,true/false) over (partition by col1 order by col2)第二个参数为true，跳过空值（默认为false） LAST_VALUE
功能：取每个分区内某列的最后一个值语法：LAST_VALUE(col,true/false) over (partition by col1 order by col2)第二个参数为true，跳过空值（默认为false） LAG
功能：取每个分区内某列的前面的第N个值语法：LAG(col,N,defaultValue) over (partition by col1 order by col2) LEAD
功能：取每个分区内某列的后面的第N个值语法：LEAD(col,N,defaultValue) over (partition by col1 order by col2) FIRST_VALUE 功能：取每个分区内某列的第一个值语法：FIRST_VALUE(col) over (partition by col1 order by col2)示例：取每个部门薪资最高的员工姓名 select empno, ename, salary, deptno, FIRST_VALUE(ename) over (partition by deptno order by salary desc ) as first from db_emp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a0ce7c227086d52a07899dcc6e29db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8a296490e3c324e1d86407f4d55bd5/" rel="bookmark">
			进程间的数据隔离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程间的数据隔离 不同进程之间的数据是隔离的，现在我们来验证一下 from multiprocessing import Process import time age = 18 def change_age(): global age age = 16 if __name__ == '__main__': p = Process(target=change_age) p.start() p.join() print(age) 上面这段代码定义了一个变量age=18，在change_age函数中将age定义为全局变量，并重新给age赋值16,然后等子进程执行完毕再执行主进程。如果打印出来的age是18，则可以说明，进程间的数据是隔离的。打印结果如下：
思考：为什么global没有生效 其实global生效了，不过它改变的是自己进程的age变量。前面学习创建进程的方法的时候总结过：每开一个进程，操作系统就会在内存里开辟一块空间存放相应的代码包括变量，大概如下图：
如何让不同进程间的数据通信 后面会学习不同进程间数据通信的办法…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6991e3d3685087360275e9da3fe5fd29/" rel="bookmark">
			IDEA好用快捷键（记录自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 IDEA好用快捷键（记录自用） 1、ptg：一键生成JavaBean 1.1 展示： 1.2 点击即可一键生成javaBean 2、maven helper：根据项目打包，可调试Maven项目 2.1 内容展示：针对某个模块进行单独编译，调试，打包，十分方便 3、mybatisX 3.1 作用：在mapper接口处定义方法后可以直接生成statement 3.2 然后再写上sql语句即可 3.3 另外点击左侧小鸟标志直接跳转对应方法 3.4 跳转至： &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;持续更新&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b417a856ed8de1d0560ae803840f4d95/" rel="bookmark">
			Pod的基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、资源限制 Pod 是 kubernetes 中最小的资源管理组件，Pod 也是最小化运行容器化应用的资源对象。一个 Pod 代表着集群中运行的一个进程。kubernetes 中其他大多数组件都是围绕着 Pod 来进行支撑和扩展 Pod 功能的，例如用于管理 Pod 运行的 StatefulSet 和 Deployment 等控制器对象，用于暴露 Pod 应用的 Service 和 Ingress 对象，为 Pod 提供存储的 PersistentVolume 存储资源对象等。
二、Pod 的两种使用方式 一个 Pod 中运行一个容器。每个 Pod 中一个容器的模式是最常见的用法，在这种使用方式中，你可以把 Pod想象成是单个容器的封装，kubernetes 管理的是 Pod 而不是直接管理容器。
在一个 Pod 中同时运行多个容器。一个 Pod中也可以同时封装几个需要紧密耦合互相协作的容器，它们之间共享资源。这些在同一个 Pod 中的容器可以互相协作成为一个 service单位，比如一个容器共享文件，另一个 sidecar 容器来更新这些文件。Pod 将这些容器的存储资源作为一个实体来管理。
三、Pod 中几个重要字段的含义和用法 1、NodeSelector 是一个供用户将 Pod 与 Node 进行绑定的字段
apiVersion: v1 kind: Pod ... spec: nodeSelector: disktype: ssd 这样的一个配置，意味着这个 Pod 永远只能运行在携带了“disktype: ssd”标签（Label）的节点上；否则，它将调度失败
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b417a856ed8de1d0560ae803840f4d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15cef38650e6705b8d315ad271f0b97d/" rel="bookmark">
			ptp4l
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：
linuxptp/ptp4l PTP时钟同步配置选项_就是个linux工程师的博客-CSDN博客_ptp4l
匆忙翻译了一下linuxptp ptp4l的帮助手册，不尽准确，不尽详细，仅供参考。欢迎留言讨论相关问题。
1 名称
ptp4l - PTP普通时钟/边界时钟/透明时钟协议栈
2 描述
ptp4l是一个Linux上PTP协议（IEEE 1588）的实现，支持普通时钟，边界时钟和透明时钟。
3 配置选项
配置选项 描述
-A 自动选择延迟测量机制，运行时使用E2E，但接收到peer delay request报文后自动切换到P2P。
-E E2E延迟测量机制 （默认配置）
-P P2P延迟测量机制
-2 IEEE 802.3协议
-4 UDP/IPv4协议（默认配置）
-6 UDP/IPv6协议
-H 硬件时间戳（默认配置）
-S 软件时间戳
-L Legacy硬件时间戳
-f 指定配置文件，若没有指定，则使用默认配置。
-i 指定网口（PTP port），可以多次使用指定多个网口，但该选项或配置文件中至少要指定一个。
-p 指定PHC （PTP Hardware Clock） device，例如/dev/ptp0，该选项已经不推荐使用，适用于v3.5之前的内核，因为v3.5之前的内核不支持通过网口找到PHC device。
-s slaveOnly模式
-l 打印级别 0~7（默认6，LOG_INFO）
-m 将信息打印到标准输出
-q 不将信息发送到系统logger
-v 显示版本号
-h 显示help信息
4 长配置选项
下面每一个在配置文件中使用的选项也可以在命令行中使用，例如slaveOnly选项，可以在命令行中以下面的形式使用，
--slaveOnly 1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15cef38650e6705b8d315ad271f0b97d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcec663ef3d4a2c55d231c1b37fd4f99/" rel="bookmark">
			MySQL数据库的备份、恢复、导出、导入（bin log和mydump）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、使用 bin log 来恢复数据
一、bin log的三种格式
1、statement：基于SQL语句的复制（statement-based replication，SBR）
2、row：基于行的复制（row-based replication，RBR）
3、mixed：混合模式复制（mixed-based replication，MBR）
4、查看模式和更改模式
二、配置bin log策略
三、获取bin log文件列表
四、生成新的bin log文件
五、查看日志中的内容
1、在mysql中使用show binlog events查看
2、在shell中使用mysqlbinlog来查看
六、利用bin log 来恢复数据
1、通过pos来恢复
2、通过时间来恢复
二、逻辑备份和恢复
一、mysqldump工具实现逻辑备份
二、逻辑恢复
三、物理备份和恢复
一、物理备份
二、物理恢复
四、数据库的导出和导入
一、导出
1、通过INTO OUTFILE导出
2、使用mysqldump导出
3、使用mysql命令导出
二、导入
五、数据库误删除恢复步骤
一、使用 bin log 来恢复数据 一、bin log的三种格式 1、statement：基于SQL语句的复制（statement-based replication，SBR） 每一条会修改数据的sql都会记录在binlog中。优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。但是注意statement相比于row能节约多少性能与日志量，取决于应用的SQL情况。正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。缺点：由于记录的只是执行语句，为了这些语句在slave上正确运行，我们还必须记录每条语句在执行时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时相同的结果。另外，一些特定的函数功能如果要在slave和master上保持一致会有很多相关问题。 2、row：基于行的复制（row-based replication，RBR） 5.1.5版本的MySQL才开始支持row level的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。优点：binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以row level的日志会非常清楚的记下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题。缺点：所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。但是新版本的MySQL对row level模式进行了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更。 3、mixed：混合模式复制（mixed-based replication，MBR） 从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。在Mixed模式下，一般的语句修改使用statment格式保存binlog，如果一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。 4、查看模式和更改模式 mysql&gt; show variables like 'binlog_format'; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | binlog_format | MIXED | +---------------+-------+ 1 row in set, 1 warning (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcec663ef3d4a2c55d231c1b37fd4f99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5668503458a4ec3543f951492ec51d8c/" rel="bookmark">
			罗技MX Keys从蓝牙连接切换为优联（无线接收器）连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道什么原因用最近MX Keys蓝牙连接mac怪卡的，按一个键按四五下电脑上才有反应。于是还是想用无线接收器连接来控制电脑。
按照壳子上按fn+o来切换好像不太管用。。。
于是试了很久，最后用罗技自家的键盘管理软件切换上了。
先下一个Logi Options+。
下载链接：https://www.logitech.com.cn/zh-cn/software/logi-options-plus.html#software-download
打开后可以看到3个匹配设备：
然后回到起始页，点添加设备
然后这样就连上了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f1b9fdea2c1f0f221e7b1dadd6a9827/" rel="bookmark">
			Ant.design 没有检测到 Form.Item React 中的自定义输入组件答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ant.design 没有检测到 Form.Item React 中的自定义输入组件答案 - 爱码网 (likecs.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4375c3603ee1987150ed9ab04674b7a5/" rel="bookmark">
			损失函数的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不论是什么模型，所用的方法都是让模型进行准确的预测判断，在此过程中，会使用训练集对模型进行训练，根据误差调整模型使之更为精确，使得误差减小到可接受范围以内，而量化误差的数学方法就是损失函数，损失函数分为以下两类：
绝对值损失函数：
平方损失函数：
模型训练的本质是找到一个参数，使得损失函数值最小化，绝对值损失函数损失值是等比变化的，而平方损失函数损失值变化较快，容易产生大的损失值，使得结果倾向于异常值，还有一种Huber loss损失函数，误差介于绝对值损失函数和平方损失函数之间，适用于既想关注正常值，又想照顾异常值的情况（且不会让异常值产生较大影响）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02733d525d21a7c1b030797824a919c8/" rel="bookmark">
			正则化的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则化是一种用于解决过拟合问题的机器学习方法，过拟合模型是指机器学习模型在训练数据上表现良好，但是测试数据上表现不佳的情况，正则化就是通过向模型的损失函数中加入“惩罚项”以便于防止过拟合。
常用的正则化方法有L1正则化，L2正则化，Dropout和批标准化
L1正则化：将模型权重的绝对值之和加入损失函数中
L2正则化：将模型权重的平方和加入损失函数中
Dropout：在训练过程中随机“删除”网络的一些神经元，从而防止过拟合
批标准化：在训练过程中对每个批次的输入数据进行归一化，从而防止梯度爆炸或消失
损失函数详见浅谈对损失函数的认识（基础）_distance424的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51bfb0e8deeb5a1dddc3430df75b8f91/" rel="bookmark">
			蓝桥杯备战之实战-双路输出控制器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：因为我的板子的PA1引脚坏了，所以只能用PA3引脚代替 一.题目 二.主要任务： 1.按键以及pwm波的设置 具体初始化过程不在描述，提供代码
uint8_t keynum=0;//全局变量的设置 void Key_Scan(void) { if(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == 0) { keynum++; if(keynum&gt;250) { keynum=0; flag_A1=!flag_A1; while(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == 0); } } if(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1) == 0) { keynum++; if(keynum&gt;250) { A1_duty+=10; if(A1_duty&gt;100) A1_duty=0; keynum=0; while(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1) == 0); } } if(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2) == 0) { keynum++; if(keynum&gt;250) { keynum=0; flag_A2=!flag_A2; while(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2) == 0); } } if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == 0) { keynum++; if(keynum&gt;250) { A2_duty+=10; if(A2_duty&gt;100) A2_duty=0; keynum=0; while(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == 0); } } } 通过定时器扫描按键
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51bfb0e8deeb5a1dddc3430df75b8f91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb81e7856b85a5eeae34ca5c5a15e1e/" rel="bookmark">
			Makefile:****missing separator. stop解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上网搜了一下，找到解决办法了。我整理如下：
【1】终端执行：vim ~/.vimrc
【2】添加：
set noexpandtab
set autoindent
保存，然后退出
【3】打开你的Makefile
【4】删除Makefile里面的命令前面的空格或tab字符
【5】在命令前面输入tab键，然后保存退出。
【6】终端执行：make。没有错误了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eddce4cb1ffc00c54924f4abafaa221c/" rel="bookmark">
			深度学习模型参数量计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若你的模型parameters为7327930，则
7327930 * 4 （Byte）/1024 *1024 = 27.95 MB
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f108e02a48b407cfacdf1fc1ea7e2401/" rel="bookmark">
			makefile基础及常用规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是makefile？或许很多Windows的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。特别在Unix下的软件编译，你就不能不自己写makefile了。
我们用一个示例来说明Makefile的书写规则。在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：
1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。
2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。
3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。
只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成
（1）Makefile的规则。还是让我们先来粗略地看一看Makefile的规则。
target ... : prerequisites ...
command
target也就是一个目标文件，可以是Object File，也可以是执行文件，还可以是一个标签（Label）。 prerequisites就是要生成那个target所需要的文件或是目标。command也就是make需要执行的命令。这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。
Linux中对Makefile的使用，内核的Makefile分为5个组成部分： A，Makefile 最顶层的Makefile B，.config 内核的当前配置文档，由Kconfig在menu config时生成，编译时成为顶层Makefile的一部分
C，arch/$(ARCH)/Makefile 和体系结构相关的Makefile D，scripts/Makefile.xxx 一些特定Makefile的规则
E，kbuild级别Makefile 各级目录下的大概约500个文档，编译时根据上层Makefile传下来的宏定义和其他编译规则，将源代码编译成模块或编入内核。顶层的Makefile文档读取.config文档的内容，并总体上负责build内核和模块。Arch Makefile则提供补充体系结构相关的信息。
（2）示例：
edit : main.o kbd.o command.o display.o / insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o / insert.o search.o files.o utils.o main.o : main.c defs.h cc -c main.c kbd.o : kbd.c defs.h command.h cc -c kbd.c command.o : command.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f108e02a48b407cfacdf1fc1ea7e2401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c9c7bca8fd8fc0bf934b5eb4706706d/" rel="bookmark">
			antd 选择框实现切换时将默认选中清空效果实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给一个value 效果如下为true就显示选择的内容 sed就为我自己动态选择的内容 点击切换的时候设为false即可 效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5e1fdbdcb81bd357bc08ed7e2d251de/" rel="bookmark">
			Web安全攻防世界09 ics-07（XCTF）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 友情提示：攻防世界最近的答题环境不太稳定，我这篇没有做到最后一步...为了水个成就提前发出来了，以后等网好了会测试到最后一步的...
本次ics-07的解题过程依然小白友好~
题目是这个样子的： 是工控的云管理系统，页面看起来好酷炫~我们先点击左边的目录，看看有没有什么可疑的上传或者注入点~
唯一可以利用的链接是业务管理下的项目管理，目测是sql注入~根据页面view source的提示，crtl+u打开源码~
emm...发现47行&lt;a href="view-source.php"&gt;view-source&lt;/a&gt;，“view source”其实是个链接...
原因分析： 按照惯例，拿起小字典逐行查一下源码的意思，贴在下面~
visual studio code：Visual Studio Code - Code Editing. Redefined，补充一个PHP Intelephense的扩展，在选中函数时就可以直接跳转到php手册，对小白很友好~
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;cetc7&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php //8-22行内容为访问域名 session_start(); //创建新会话，或重用现有会话（cookie提交会话id时） if (!isset($_GET[page])) { //检查是否请求此页面 show_source(__FILE__); //若存在请求，语法高亮本页面（show_source作用等同于highlight_file） die(); } if (isset($_GET[page]) &amp;&amp; $_GET[page] != 'index.php') { //如果请求页面，且请求链接不为index.php include('flag.php'); //解析此文件flag.php }else { //若请求此页面，且请求连接为index.php header('Location: ?page=flag.php'); //重定向到flag.php } ?&gt; &lt;form action="#" method="get"&gt; page : &lt;input type="text" name="page" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5e1fdbdcb81bd357bc08ed7e2d251de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec83588946080b8948edb32d1e97460/" rel="bookmark">
			OpenFeign详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenFeign是什么？ OpenFeign：
OpenFeign是Spring Cloud 在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。
Feign：
Feign是Spring Cloud组件中的一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务。
Feign是在2019就已经不再更新了，通过maven网站就可以看出来，随之取代的是OpenFeign，从名字上就可以知道，他是Feign的升级版。
@FeignClient 使用OpenFeign就一定会用到这个注解，@FeignClient属性如下：
name：指定该类的容器名称，类似于@Service（容器名称）url: url一般用于调试，可以手动指定@FeignClient调用的地址decode404:当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignExceptionconfiguration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contractfallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口fallbackFactory: 工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码path: 定义当前FeignClient的统一前缀，当我们项目中配置了server.context-path,server.servlet-path时使用 远程调用接口当中，一般我们称提供接口的服务为提供者，而调用接口的服务为消费者。而OpenFeign一定是用在消费者上。
OpenFeign使用 OpenFeign 常规远程调用 所谓常规远程调用，指的是对接第三方接口，和第三方并不是微服务模块关系，所以肯定不可能通过注册中心来调用服务。
第一步：导入OpenFeign的依赖
第二步：启动类需要添加@EnableFeignClients
第三步：提供者的接口
@RestController @RequestMapping("/test") public class FeignTestController { @GetMapping("/selectPaymentList") public CommonResult&lt;Payment&gt; selectPaymentList(@RequestParam int pageIndex, @RequestParam int pageSize) { System.out.println(pageIndex); System.out.println(pageSize); Payment payment = new Payment(); payment.setSerial("222222222"); return new CommonResult(200, "查询成功, 服务端口：" + payment); } @GetMapping(value = "/selectPaymentListByQuery") public CommonResult&lt;Payment&gt; selectPaymentListByQuery(Payment payment) { System.out.println(payment); return new CommonResult(200, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec83588946080b8948edb32d1e97460/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81ef1439754d0320f461c9616502ce43/" rel="bookmark">
			PTA C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 7-467 找小写字母 本题目要求读入不含空格的字符串，然后输出这个字符串中小写字母的个数。
输入格式: 输入在一行中给出一个不含空格的字符串。输入保证字符串长度不超过100。
输出格式: 输出有两行。
第一行按输入顺序输出这个字符串中所有小写字母。
第二行输出这些小写字母的个数。
输入样例: AghE+FbcdL@MN 输出样例: ghbcd 5 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b1b77a4b56a1235bd01db6d40f8c8f/" rel="bookmark">
			分享118个HTML个性简实模板，总有一款适合您
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享118个HTML个性简实模板，总有一款适合您
118个HTML个性简实模板下载链接：https://pan.baidu.com/s/1BkWLBWqxYYJXedZTAZjbgw?pwd=sizv 提取码：sizv
Python采集代码下载链接：采集代码.zip - 蓝奏云
蓝色清爽单页排版HTML5模板
蓝色清爽单页排版HTML5模板是一款基于bootstrap实现的蓝色简洁大气单页排版响应式模板。
扁平化个人摄影博客html5模板
扁平化个人摄影博客html5模板是一款大气扁平风格的摄影爱好者网站模板下载。
简洁simple个人博客模板下载
简洁simple个人博客模板下载是一款基于bootstrap实现的博客网站模板下载。
CSS3仿Flash动画个人博客模板
CSS3仿Flash动画个人博客模板是一款横向全屏切换的个人博客模板下载。
import os import shutil import time from time import sleep from docx import Document from docx.shared import Inches from framework.base.BaseFrame import BaseFrame from sprider.business.DownLoad import DownLoad from sprider.business.SeleniumTools import SeleniumTools from sprider.business.SpriderTools import SpriderTools from selenium import webdriver from selenium.webdriver.common.by import By from sprider.model.SpriderEntity import SpriderEntity from sprider.access.SpriderAccess import SpriderAccess title_name = "社会教育" class ChinaZJsSelenium: base_url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b1b77a4b56a1235bd01db6d40f8c8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae09a7cf656b5e1d8ca8228285c3d86/" rel="bookmark">
			分享119个HTML个性简实模板，总有一款适合您
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享119个HTML个性简实模板，总有一款适合您
119个HTML个性简实模板下载链接：https://pan.baidu.com/s/1nvjsB06p8C2qA2_EWuna9g?pwd=z3z2 提取码：z3z2
Python采集代码下载链接：采集代码.zip - 蓝奏云
Bootstrap4登陆页网站模板
Bootstrap4登陆页网站模板是一款蓝色大气简洁网站模板下载。提示：本模板调用到谷歌字体库，可能会出现页面打开比较缓慢。
创意组合瀑布流网站模板
创意组合瀑布流网站模板是一款简答的瀑布流布局展示产品图片网站模板下载。提示：本模板调用到谷歌字体库，可能会出现页面打开比较缓慢。
蓝色渐变视频背景网站模板
蓝色渐变视频背景网站模板是一款蓝色大气鼠标滚动切换网页模板下载。提示：本模板调用到谷歌字体库，可能会出现页面打开比较缓慢。
名片简历网站个人主页模板
名片简历网站个人主页模板是一款响应式个人简历网站模板下载。提示：本模板调用到谷歌字体库，可能会出现页面打开比较缓慢。
import os import shutil import time from time import sleep from docx import Document from docx.shared import Inches from framework.base.BaseFrame import BaseFrame from sprider.business.DownLoad import DownLoad from sprider.business.SeleniumTools import SeleniumTools from sprider.business.SpriderTools import SpriderTools from selenium import webdriver from selenium.webdriver.common.by import By from sprider.model.SpriderEntity import SpriderEntity from sprider.access.SpriderAccess import SpriderAccess title_name = "社会教育" class ChinaZJsSelenium: base_url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ae09a7cf656b5e1d8ca8228285c3d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e692ffcad2c4ea296254658921067f6/" rel="bookmark">
			无法访问org.springframework.stereotype.Controller
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 版本问题 解决方案 将pom文件内的spring版本降低
&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc653f8bd64145ba523b6059ba09abdf/" rel="bookmark">
			Pycharm中设置以pytest或unitest运行用例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、点击pycharm--preferences...进入设置
2、Tools--&gt;python integrated Tools-在Default test runner 选择对应的运行器，点击apply和ok
3、上一步设置完成后，由于缓存原因可能还不能以pytest形式运行，所以要进行缓存的清除
再次右键运行脚本，就会出现pytest方式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/335d18ef8c4ac1765b11ac3f69225355/" rel="bookmark">
			G1D51-审稿意见回复&amp;论文写作时态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、步骤 1、首先修改稿件——决定哪些采纳，哪些反对
2、逐条进行回复
二、回复注意事项 1、首先，表示感谢
2、表示考虑了审稿人的建议，对其进行认真思考。修改的进行说明，未修改的也要解释保留原因
3、直接在回复信中展示原文和修改部分，不要让审稿人和编辑再次回到原文中去查找内容
4、对于细微的修改最明智的做法是接受
5、表示不接受时，措辞要委婉，并给出充足的论据，论据最好不是文中内容。
6、对每个审稿人的意见逐一作出回复，不要说请看另一个答案。
7、最后再次感谢审稿人，“We would like to thank the referee again for taking the time to review our manuscript.”
8、刚开始要有general 感谢
9、一对一回复模板句式
We gratefully appreciate for your valuable suggestion/ comment.
Thank you for your rigorous consideration/ comment/ nice suggestion/
advice.
We gratefully thanks for the precious time the reviewer spent
making constructive remarks
We feel sorry for the inconvenience
brought to the reviewer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/335d18ef8c4ac1765b11ac3f69225355/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ad067dfd9c046d448ea4ba1c033d167/" rel="bookmark">
			vue-router声明式导航传值的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-router的传值类型有两种，一种是query，一种是params
query传值
const routes = [ // 先定义规则数组,这个routes用于生成路由对象，与下面的route没关系 { path: '/A', component: A } ] &lt;a href='#/A?x=123'&gt;显示A&lt;/a&gt; &lt;router-view&gt;&lt;/router-view&gt; 接收方： console.log(this.$route.query.x) 输出： 123 query传值格式为： 地址?属性名 = 值
只需要在链接跳转时在后面拼接上 ?属性名=值 即可完成传值
若要传多个query值的话，格式为： 地址?属性名1=值1&amp;属性名2=值2
使用方式还是 this.$route.query.属性名
params传值
const routes = [ // 先定义规则数组,这个routes用于生成路由对象，与下面的route没关系 { path: '/B:x', component: B } ] &lt;a href='#/B/456'&gt;显示B&lt;/a&gt; &lt;router-view&gt;&lt;/router-view&gt; 接收方： console.log(this.$route.params.x) 输出： 456 params传值需要在定义规则数组的path属性上定义属性名,在跳转链接直接传值就行 格式为 地址/值
若要传多个值的话，
则需要在规则数组的path属性上更改，格式为： path:'/地址/:属性名1/:属性名2'
跳转链接也要进行更改，格式为： 地址/属性值1/属性值2
使用方式还是 this.$route.params.属性名
query+params传值
const routes = [ { path: '/C:x', component: C } ] &lt;a href='#/C/789?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ad067dfd9c046d448ea4ba1c033d167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13c3d236847cc92673e536c1f52f7213/" rel="bookmark">
			【超详细】MyBatis详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是MyBatis？
二、MyBatis快速入门
三、Mapper代理开发
四、MyBatis核心配置文件
五、配置文件完成增删改查
5.1 环境准备
5.2 功能清单列表
5.2.1 查询
5.2.2 添加
5.2.3 修改
5.2.4 删除
六、MyBatis参数传递
七、注解完成增删改查
八、MyBatis的逆向工程
九、分页插件
一、什么是MyBatis？ MyBatis是一款优秀的持久层框架，用于简化JDBC开发。MyBatis本来是Apache的一个开源项目iBatis，2010年这个项目由apache software foundation迁移到了google code，并且改名为MyBatis。2013年11月迁移到Github官网：http://mybatis.org/mybatis-3/zh/index.html 持久层：负责将数据保存到数据库的安那一层代码。
JavaEE三层架构：表现层、业务层、持久层 框架：框架就是一个半成品软件，是一套可重用的、通用的。软件基础代码模型。
在框架的基础上构建软件编写更加高效、规范、通用、可扩展。
二、MyBatis快速入门 mybatis-config.xml的基础配置：
userMapper：
Java代码：
public class MyBatisDemo { public static void main(String[] args) throws IOException { //加载mybatis的核心配置文件，获取SqlSessionFactory String resource = "mybatis-config.xml"; //返回一个字节输入流 InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //2.获取SqlSession对象，用它来执行sql SqlSession sqlSession = sqlSessionFactory.openSession(); //3.执行sql List&lt;User&gt; users = sqlSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13c3d236847cc92673e536c1f52f7213/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3827d322600abf63258dab72bb31189f/" rel="bookmark">
			车轨耦合动力学外部激励——轨间焊缝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题说明轨间焊缝模型Matlab代码说明参考资料 问题说明 车辆在经过钢轨焊缝处时，由于车辆-钢轨间的位移突变，会使得车辆系统产生较大的振动。
轨间焊缝模型 本文选用较为典型的焊缝区低凹短波不平顺，采用在长1m的余弦波上叠加一短波不平顺波进行描述，其函数表达式为
y ( t ) = { 1 2 δ 1 ( 1 − c o s 2 π v t ) 0 ≤ t ≤ 1 − λ 2 v , 1 + λ 2 v &lt; t ≤ 1 v 1 2 δ 1 [ 1 − c o s ( π − π λ ) ] + 1 2 δ 2 [ 1 cos ⁡ ( 2 π v t λ − π − π λ λ ) ] 1 − λ 2 v &lt; t ≤ 1 + λ 2 v y(t)= \begin{cases} \frac{1}{2}\delta_1 (1-cos2\pi vt)&amp; 0 \le t \le \frac{1-\lambda}{2v}, \frac{1+\lambda}{2v}&lt;t\le \frac{1}{v}\\ \frac{1}{2}\delta_1 [1-cos(\pi-\pi \lambda)]+\frac{1}{2}\delta_2[1\cos(\frac{2\pi vt}{\lambda}-\frac{\pi-\pi \lambda}{\lambda})]&amp; \frac{1-\lambda}{2v}&lt;t\le \frac{1+\lambda}{2v} \end{cases} y(t)={21​δ1​(1−cos2πvt)21​δ1​[1−cos(π−πλ)]+21​δ2​[1cos(λ2πvt​−λπ−πλ​)]​0≤t≤2v1−λ​,2v1+λ​&lt;t≤v1​2v1−λ​&lt;t≤2v1+λ​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3827d322600abf63258dab72bb31189f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3ba910442e1011f329ba5b2b3e59977/" rel="bookmark">
			MySQL —— 表的约束
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. null 空属性2. default 默认值3. comment 列描述4. zerofill 格式化输出5. primary key 主键6. auto_increment 自增长7. 唯一键8. unique key 外键 前言： 表的约束主要是靠数据类型。有些情况，光靠数据类型约束是不够的，比如想要限制某个字段它的值是唯一的，不能重复，这就需要额外的约束。本章只介绍 null/not null,default, comment, zerofill，primary key，auto_increment，unique key 这些约束，都比较的常用。 1. null 空属性 null是空属性，意思就是它的值不存在。注意：是不存在 ，这样记忆不容易混。有C语言基础可能以为 null 就是空指针？在c/c++里，null，0，"" 它们的数值是一样的，它们是有值的。但是 MySQL中的null 它没值，不参与任何运算。
mysql&gt; select null; +------+ | NULL | +------+ | NULL | +------+ 1 row in set (0.00 sec) mysql&gt; select null+1; +--------+ | null+1 | +--------+ | NULL | +--------+ 1 row in set (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3ba910442e1011f329ba5b2b3e59977/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82286f8798dbe0ef7862ffe6ca6a64f2/" rel="bookmark">
			比较器的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比较器 当给出一个普通int型数组，让其排序时，可直接使用Arrays.sort()进行排序，也可以使用各种排序算法进行排序。但当给出一个对象数组时， 直接使用Arrays.sort()会报错。因为sort函数不知道怎么进行排序。
java的student类
class Student{ private String name; private int id; private int age; public Student(String name,int id,int age) { this.name = name; this.id = id; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getID() { return id; } public void setID(int id) { this.id = id; } public int getAge() { return age; } public void setAge(int age) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82286f8798dbe0ef7862ffe6ca6a64f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddda9603249c81b80eff4e232acda11c/" rel="bookmark">
			springboot整合mongodb的常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 对于mongodb在springboot环境下使用的常用api记录。正所谓一些api见名知意只需要学会使用即可。对于一些特殊的api会举例说明。
一、sprinboot整合 mongodb 常用方法 mongoTemplate.findAll(T.class): 查询文档的全部数据 mongoTemplate.findById(&lt;id&gt;, T.class): 查询文档id为id的数据 mongoTemplate.find(query, T.class);: 根据query内的查询条件查询 mongoTemplate.upsert(query, update, T.class): 修改 mongoTemplate.remove(query, T.class): 删除 mongoTemplate.insert(User): 新增 Query对象 1、创建一个query对象（用来封装所有条件对象)，再创建一个criteria对象（用来构建条件） 2、精准条件：criteria.and(“key”).is(“条件”)模糊条件：criteria.and(“key”).regex(“条件”) 3、封装条件：query.addCriteria(criteria) 4、大于（创建新的criteria）：Criteria gt = Criteria.where(“key”).gt（“条件”） 小于（创建新的criteria）：Criteria lt = Criteria.where(“key”).lt（“条件”） 5、Query.addCriteria(new Criteria().andOperator(gt,lt)); 6、一个query中只能有一个andOperator()。其参数也可以是Criteria数组。 7、排序 ：query.with（new Sort(Sort.Direction.ASC, "age"). and(new Sort(Sort.Direction.DESC, "date"))) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be567114702c487a683db3e36d761f57/" rel="bookmark">
			【会议记录】Linux内核的最新进展（6.2版本）分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前一段时间我参加了阅码场的活动 Yomoday（北京场），现场有很多技术专家，非常多前沿的技术分享。这是其中一个主题的记录，尽量还原当时的分享内容，但也可能有些地方不特别准确。
Linux内核的最新进展（6.2版本）分享 1 会议主讲 张健，阅码场内核教练，《ARM架构与调试调优》训练营教练，大简科技系统软件架构师，十四年IT基础设施研发经验，其中包括六年Linux kernel一线研发经验，在suse，华为，星际比特（技术合伙人）等公司工作。作为团队核心成员参与了大陆第一个Cortex-A8 SOC芯片研发，负责CPU软件验证，操作系统移植等工作。作为华为派驻到Linaro的技术专家，主导/参与多个Linux与arm架构相关特性研发（ILP32，contiguous bit hint，kernel selftest等）。
2 会议摘要 Linux 内核开发模式Linux 6.2整体情况Linux 6.2在体系结构的更新 3 会议内容 1 Linux 内核开发模式
宏观上说一下内核的开发模式，还有 Linux 6.2 整体的大概是什么情况。这里包括自己跟着写代码之外，还包括对于规范的理解，还包括跟社区的沟通。
一般来说，参与社区不是单单一个动作，对内核来说其实也是一样的。即使你说编译器，它可能也不是一个社区，包括 RISC-V 它虽然是一个架构，但它其实里面又有不同的工作组，这里面其实还有挺多沟通的事情。写代码是一部分的工作，大家如果去关注内核的时候，如果对于内核的开发模式有一个了解的话，会对于关注内核的动态会有一些帮助。
从这个图中能看到一些，我们如果想关注一些内核的动态，能从这些点去关注。
1.1 提交邮件列表
普通软件开发流程很简单，我们一般写代码 Review 合进去，一般软件开发就这么做。而内核开发其实很类似，假设已经都落到特性上（就不说前面特性怎么定出来的），我们要开发一个特性了，开发之后发内核社区还是比较 old school 的，它是通过发邮件的方式发到邮件列表 ，然后大家都可以 Review 。
最终是看 maintainer有没有给你 acknowledgment（ACK） ，给你 ACK之后补丁就有机会合进去，最终评审这部分最终的目标其实就是没有人反对，并且你所修改的子系统的这部分（比如 arch/arm64 的或者内存子系统，或者是 RISC-V），能给你一个 ACK，所以 ack by xxx 就过了，然而 Review 过了以后并不会直接合进去。
1.2 合入Next分支
在平时比较简单开发流程，评审过之后可能跑个CI，通过后可能就合进去了。但是对于内核来说，它其实不会直接合进去。为啥呢？因为内核补丁太多了，其实每一次的大版本内核的合入可能都是上万个提交。这么多个补丁，如果评审之后一把就合了主线，大家就很难拿到一个相对比较稳定的主线去做开发。所以用了一个折中的方式，先合入到每个子系统的分支（比如我们去合入到 arch/arm64 子系统的分支里面，或者合入这个内存的子系统），或者文件系统的一个 next分支。
什么是 next分支？next分支 是在下一次内核大版本开发时，补丁有机会被合进的分支，所以叫 next分支。如果你的补丁过 Review 就会合到 next分支。这种情况下， 对于一般的特性来说就比较稳了，到了 next分支，在下一版大版本开发的时候，你就有机会被推到主线。当然个别情况也有可能你进next分支 之后，进主线的时候被其他人叫过来 “哎这个东西我不同意”，一般比较资深的 maintainer 可能会跳出来了，你的补丁有可能会被踢出去。一般是改得比较深的比较多的补丁上会有这个可能。假如没有反对意见，其实最终会合到主分支。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be567114702c487a683db3e36d761f57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/663444f6c9f0e470a3a0b8e528a91d05/" rel="bookmark">
			工程训练(第三章 铸造 )-江苏海洋大学-mooc 答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家可以点赞 评论 关注 一下下嘛 亲亲 miaow~~ 1.砂型铸造的特点是 ( 原材料价格低廉 )
2.在选择分型面时,应尽量使铸件 ( 位于下型 )
3.机器造型适宜于 ( 成批大量生产 )
‍4.型砂透气性不好会使铸件产生（ 气孔 ）缺陷
​5.训练时熔炼铝合金所采用的设备是 ( 坩埚炉 )
‎6.砂型制作的准备工作包括 ( 工装准备 造型工具准备 修型工具准备 检查模样是否完整和清洁 )
‍7.常用的型砂种类包括 ( 黏土砂 水玻璃砂 树脂砂 )
‌8.铸造是一种高精度的加工方法 X
9.铸造生产成本高、不能加工形状复杂的工件 X
10.铸造加工适应性广、 工艺灵活性大 Y
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21fe388fcd0900f56e0871f273ebbdd4/" rel="bookmark">
			三维量子力学 量子力学（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动量 p p p有三个分量，为 p x p_x px​等。它们分别满足与位置坐标的对易关系，比如 p x = − i ℏ ∂ ∂ x p_x=-i\hbar\frac{\partial }{\partial x} px​=−iℏ∂x∂​。可以用位置坐标梯度算符表示即 p = − i ℏ ∇ \bm{p}=-i\hbar\nabla p=−iℏ∇。位置矢量用 r \bm{r} r表示。
在 d 3 r d^3\bm{r} d3r（我喜欢写作 d V dV dV）区域发现它的概率是 ∣ Ψ ( r , t ) ∣ 2 d V |\Psi(\bm{r},t)|^2dV ∣Ψ(r,t)∣2dV。那么归一化条件是 ∫ ∣ Ψ ∣ 2 d V = 1 \int |\Psi|^2dV=1 ∫∣Ψ∣2dV=1。
如果势能与时间无关，那么可以确定一组完备的定态 Ψ n ( r , t ) = ψ n ( r ) e − i E n t / ℏ \Psi_n(\bm{r},t)=\psi_n(\bm{r})e^{-iE_nt/\hbar} Ψn​(r,t)=ψn​(r)e−iEn​t/ℏ， n = 1 , 2 , … n=1,2,\dots n=1,2,…。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21fe388fcd0900f56e0871f273ebbdd4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/175/">«</a>
	<span class="pagination__item pagination__item--current">176/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/177/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>