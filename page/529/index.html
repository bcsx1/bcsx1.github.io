<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f18974762e69d38c486a126d92cb9bde/" rel="bookmark">
			钢笔、电梯、纸杯、桌子、洗衣机测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.csdn.net/tanyujing/article/details/8717575
钢笔测试
能在不同的纸上写吗？能在墙上写吗？笔尖朝上，倒着拿还能写出字吗？
能在不同的环境下写吗？水里？沙漠？低温？太空？
笔的形状是否适合手握？（想像一件用砂纸做的T恤……）
要用多大的力气才能写出字来？
长期放着不用，墨水会不会堵住？
加一次墨水能用多长时间？
笔上的标签有没有错别字？是否考虑了globalization，不同国家、不同文化？logo会不会让某种人反感？
笔容易折断吗？如果折断了，飞出来的东西会不会伤到人？
把笔放到嘴里咬会不会有危险？小孩总会乱吃东西。
……
电梯测试
需求测试：
查看电梯使用说明书、安全说明书等
界面测试：
查看电梯外观
功能测试：
1.测试电梯能否实现正常的上升和下降功能。
2.电梯的按钮是否都可以使用。
3.电梯门的打开，关闭是否正常。
4.报警装置是否可用。
5.与其他电梯之间是否协作良好。
6.通风状况如何。
7.突然停电时的情况。
8.上升途中的响应。
1）电梯本来在1楼，如果有人按18楼，那么电梯在上升到5楼的时候，有人按了10楼，这时候是否会在10楼先停下来；
2）电梯下降到10层时显示满员，此时若8层有人等待电梯，是否在8层停。
可靠性：
1.门关上的一刹那出现障碍物。
2.同时按关门和开门按钮。
3.点击当前楼层号码。
4.多次点击同一楼层的号码等等。
5.同时按上键和下键会怎样。
易用性：
1.电梯的按钮的设计符合一般人使用的习惯吗．
负载/压力测试：
1.看电梯的最大限度的承受重量．在负载过重时是否有提醒。
2.在一时间内不断的让电梯上升，下降。
稳定性测试：
1.最大负载下平稳运行的最长时间。
文档测试：
1.使用手册是否对电梯的用法、限制、使用条件等有详细描述
杯子
需求测试: 查看杯子使用说明书
界面测试: 查看杯子外观
功能度：用水杯装水看漏不漏；水能不能被喝到
安全性：杯子有没有毒或细菌
可靠性：杯子从不同高度落下的损坏程度
可移植性：杯子在不同的地方、温度等环境下是否都可以正常使用
兼容性：杯子是否能够容纳果汁、白水、酒精、汽油等
易用性：杯子是否烫手、是否有防滑措施、是否方便饮用
用户文档：使用手册是否对杯子的用法、限制、使用条件等有详细描述
疲劳测试：将杯子盛上水（案例一）放24 小时检查泄漏时间和情况；盛上汽油（案例二）放24 小时检查泄漏时间和情况等
压力测试：用根针并在针上面不断加重量，看压强多大时会穿透
跌落测试: 杯子加包装( 有填充物), 在多高的情况摔下不破损
震动测试: 杯子加包装( 有填充物), 六面震动, 检查产品是否能应对恶劣的铁路\ 公路\ 航空运输
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f18974762e69d38c486a126d92cb9bde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff41acd7ce68c45fa780748e6a179698/" rel="bookmark">
			关于域名的小知识有什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		域名是Internet网络上的一个服务器或一个网络系统的名字，在全世界，没有重复的域名，域名具有唯一性。
1、什么是标题
Internet域名是Internet网络上的一个服务器或一个网络系统的名字，在全世界，没有重复的域名。域名的形式是以若干个英文字母和数字组成，由"."分隔成几部分，如yuminghome.com就是一个域名。
2、域名和网址有什么区别
域名和网址是不同的。一般来说，在通过注册获得了一个域名之后，需要根据网址所载信息内容的性质，在域名的前面加上一个具有一定标识意义的字符串，才能构成一个网址。
3、什么是IP地址
我们知道，在Internet上有千百万台主机，为了区分这些主机，人们给每台主机都分配了一个专门的地址，称为IP地址。通过IP地址就可以访问到每一台主机。IP地址由4部分数字组成，每部分都不大于256，各部分之间用小数点分开。
4、什么是虚拟主机
互联网现有上亿台的计算机，这些计算机归结为两大类：客户机和服务器。客户机是访问别人信息的机器。当您通过邮电局或别的ISP拨号上网时，您的电脑就被临时分配了一个IP地址，利用这个临时身份证，您就可以在Internet的海洋里获取信息，当您断线后，您的电脑就脱离了Internet，IP地址也被收回。
服务器则是提供信息让别人访问的机器，通常又称为主机。由于人们任何时候都可能访问到它，因此作为主机必须每时每刻都连接在Internet上，拥有自己永久的地址。为此不仅得设置专用的电脑硬件，还得租用昂贵的数据专线，再加上各种维护费用如房租、人工、电费等等。为此，人们开发了虚拟主机技术。利用虚拟主机技术，可以把一台真正的主机分成许多的虚拟的主机，每一台虚拟主机都具有独立的域名和IP地址，具有完整的Internet服务器功能。虚拟主机之间完全独立，在外界看来，每一台虚拟主机和一台独立的主机完全一样。效果一样，但费用却大不一样了。由于多台虚拟主机共享一台真实主机的资源，每个虚拟主机用户承受的硬件费用、网络维护费用、数据专线的费用均大幅度降低，Internet真正成为人人用得起的网络！
5、域名有哪些类型
由于Internet最初是在美国发源的，因此最早的域名并无国家标识，人们按用途把它们分为几个大类，它们分别以不同的后缀结尾
6、哪些字母和数字能用于域名
英文26个字母和10个阿拉伯数字以及横杠"－"可以用作域名。字母的大小写没有区别。每个层次最长不能超过26个字母。中文暂时不能用作域名。
7、怎样选择最佳域名
按照习惯，一般使用你的名称或商标作为域名。域名的字母组成要便于记忆，能够给人留下较深的印象。
不需要实名com域名：http://www.iisp.com/domain/intro_com_oe.php?s=hyc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30381cd46fec6562b558e125ec10d1e3/" rel="bookmark">
			android中汉字转为拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汉语转为拼音 首先要先导入架包：com.belerweb:pinyin4j:2.5.1
工具类：
注释的方法，是可以将单个汉字转为拼音的，为注释的可以转化词语，
public class HanZiToPinYin { // public static String toPinYin(char hanzi){ // HanyuPinyinOutputFormat hanyuPinyin = new HanyuPinyinOutputFormat(); // hanyuPinyin.setCaseType(HanyuPinyinCaseType.LOWERCASE); // hanyuPinyin.setToneType(HanyuPinyinToneType.WITH_TONE_MARK); // hanyuPinyin.setVCharType(HanyuPinyinVCharType.WITH_U_UNICODE); // String[] pinyinArray=null; // try { // //是否在汉字范围内 // if(hanzi&gt;=0x4e00 &amp;&amp; hanzi&lt;=0x9fa5){ // pinyinArray = PinyinHelper.toHanyuPinyinStringArray(hanzi, hanyuPinyin); // } // } catch (BadHanyuPinyinOutputFormatCombination e) { // e.printStackTrace(); // } // //将获取到的拼音返回 // return pinyinArray[0]; // } public static String getPinYinAllChar(String zn_str, int caseType) { char[] strChar = zn_str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30381cd46fec6562b558e125ec10d1e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f3812dcbb234c93c8de8a44f46783e/" rel="bookmark">
			【OpenGL】绘制一个点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 glew glew 全称是 OpengGL Extension Wrangler Library，它能够帮忙解决 OpengGL 不断扩展的问题。初始化 glew 之后，它将查询系统上所有可用的扩展功能并自动加载它们，然后提供一个头文件作为接口，我们直接通过头文件就可以使用这些扩展功能。 glew 的下载地址 http://glew.sourceforge.net/ 下载之后进行解压，得到的目录结构
|-glew-2.1.0 |-bin |-lib |-include |-doc 接下来开始配置环境，配置的方式有两种，第一种方式跟配置 glut 一样，系统级的配置，配置之后所有的 opengl 项目都不需要配置
第一步，把 include 目录下的头文件放在 %VISUAL_STUDIO%\VC\include\gl 目录下第二步，把 lib 目录下的 lib 文件放在 %VISUAL_STUDIO%\VC\lib 目录下，然后在项目属性的 链接器 –&gt; 输入 添加相应库的引用第三步，把 bin 目录下的 dll 文件放在 system32 目录下，同样的 64 位系统要放在 sysWOW64 目录下 这种方式虽然能够一劳永逸，但因为 win32 和 x64 的库文件名一样，所以无法做到兼容，即无法同时把 32 位的库文件和 64 位的库拷到系统路径；另外过多地把库文件拷到系统路径也不好，因此推荐使用第二种方式，即给每个创建的项目配置环境
把头文件放在 $PROJECT_ROOT%\include\GL 目录下，然后在项目属性的 C/C++ –&gt; 附加包含目录 中添加 .\include把静态库 lib 文件放在 $PROJECT_ROOT%\lib 目录下，然后在项目属性的 链接器 –&gt; 常规 –&gt; 附加库目录 中添加 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f3812dcbb234c93c8de8a44f46783e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/107e468a9d5f9e168710c8b3abde6a5b/" rel="bookmark">
			排序算法三：堆排序基本原理以及Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 基本原理 堆排序就是利用堆的特性进行一个无序序列的排序工作。
堆的特点
堆分为最大堆和最小堆，其实就是完全二叉树。
最大堆要求节点的元素都要不小于其孩子
最小堆要求节点元素都不大于其左右孩子。
两者对左右孩子的大小关系不做任何要求，其实很好理解。
有了上面的定义，我们可以得知，处于最大堆的根节点的元素一定是这个堆中的最大值。
其实我们的堆排序算法就是抓住了堆的这一特点，每次都取堆顶的元素，将其放在序列最后面，然后将剩
余的元素重新调整为最大堆，依次类推，最终得到排序的序列。
基本思想
将初始待排序关键字序列 (a1,a2,⋯,an) 构建成大顶堆，此堆为初始的无序区
将堆顶元素 a[1] 与最后一个元素 a[n] 交换，此时得到新的无序区 (a1,a2,⋯,an−1) 和新的有序区 (an) 由于交换后新的堆顶 a[1] 可能违反堆的性质，因此需要对当前无序区 (a1,a2,⋯,an−1) 调整为新堆，然后再次将 a[1] 与无序区最后一个元素交换，得到新的无序区 (a1,a2,⋯,an−2) 新的有序区 (an−1,an−2) 。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。
一个例子
这里有一个无序的序列， [16,7,3,20,17,8] 首先构造一个二叉树：
然后依据构造的二叉树，从下至上调整，得到一个初始化的最大堆。
再讲堆顶的数和堆底的数互换。
但是，此时的堆可能不符合要求，需要再从新调整：
再重复，将堆顶和堆底互换（当然了，在之前，堆的大小要减1）
又一次进行调整：
重复，将堆顶和堆底互换（当然了，在之前，堆的大小又要减1）
再调整：
再换：
再调整：
再换： 到这，一个堆排序就完成了，最终得到一个最小堆。
2. Python 实现 程序
#定义一个对单一节点的父节点以及其孩子大小交换的函数 def initialMaxHeap(a,startIndex,endIndex): leftChildIndex=2*startIndex+1 #父节点为i，左边孩子的位置为2*i+1 #判断左边孩子是否有右边的孩子 if leftChildIndex+1&lt;=endIndex and a[leftChildIndex+1]&gt;a[leftChildIndex]: leftChildIndex+=1 if a[leftChildIndex]&gt;a[startIndex]:#左右孩子值大于父节点的值的时候，交换,使得这个二叉树的最大值位于父节点上 temp=a[startIndex] a[startIndex]=a[leftChildIndex] def myHeapSort(a): #a是要排序的序列 listLength=a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/107e468a9d5f9e168710c8b3abde6a5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c14144f42e16e5f3d2ed0247188d08f/" rel="bookmark">
			秒杀高并发优化分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习了慕课网《高并发秒杀优化》视频，总结如下：
秒杀的高并发问题在哪里？
业务分析
红色部分是有可能发生高并发的地方，我们来一一分析
一、详情页通过用户大量的刷新，一些静态资源需要加载，这个耗费IO时间。优化方案：使用CDN缓存
CDN(内容分发网络)可以加速用户获取数据；部署在离用户最近的网络节点上；命中CDN不需要方法后端服务器；互联网公司可以自己搭建或租用。
二、系统时间不用优化，因为访问一次内（Cacheline）大约10ns。
三、秒杀地址接口
四、秒杀操作
方案一：天猫阿里用到的优化：
曾看过看过一篇博客《 ITOO---选课里的“秒杀”业务实现（一）》就是这样实现的。
把资源放到redis中，把资源竞争引入到redis，因为redis并发量高达几万或者几十万；业务逻辑发送到MQ,然后并发写到库中。
这其中有一个redis并发问题，虽然redis是单线程，但还是存在因操作上引起的数据覆盖，这里应该把所有的业务逻辑都一步执行，执行完毕后其它业务才能执行，这里使用到redis lua脚本,这里完全可以解决。
方案2：用mysql解决资源竞争。
有人会有疑问，mysql太低效？
无事务的执行mysql测update操作，承受并发量是4w/s。这样的效率还是挺好的。
用java控制事务之后呢
加上事务后的瓶颈
这样的并发量只有500/s。
1、网络延迟
大概要20ms左右，如果不计算其他业务时间，并发量就才50/s，所以尽量选择同城机房。
2、
第一点是需要修改mysql源码，阿里和天猫曾经用过。
第二点适用范围很大。
3、优化数据库：分库分表
搭建各种集群，如下：
总结
这只是大体结构，还存在细节上的问题，可以多多交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec003cd2a40003bd4ac8ff356df5c1e/" rel="bookmark">
			2010noip提高组 机器翻译 (水题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem C: 机器翻译 Description 小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。 这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义 来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有， 软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中 文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。 假设内存中有 M 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入 内存前，如果当前内存中已存入的单词数不超过 M−1，软件会将新单词存入一个未使用的 内存单元；若内存中已存入 M 个单词，软件会清空早进入内存的那个单词，腾出单元来， 存放新单词。 假设一篇英语文章的长度为 N 个单词。给定这篇待译文章，翻译软件需要去外存查找多 少次词典？假设在翻译开始前，内存中没有任何单词。
Input 输入文件名为 translate.in，输入文件共 2 行。每行中两个数之间用一个空格隔开。 第一行为两个正整数 M 和 N，代表内存容量和文章的长度。 第二行为 N 个非负整数，按照文章的顺序，每个数（大小不超过 1000）代表一个英文 单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。
Output 输出文件 translate.out 共 1 行，包含一个整数，为软件需要查词典的次数。
Sample Input 3 7 1 2 1 5 4 4 1 Sample Output 5
一道很水的题目，直接用队列来模拟操作，每次加入队列，判断这个元素是否已经在队列了，可用数组标记辅助，如果元素不在，就加入，同时计数器要自加，如果加这个元素的时候，队列大小超过了m，那么就把第一个出队，同时标记为0，即不在队列了，最后输出结果就OK了。
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include&lt;set&gt; #include&lt;queue&gt; #include&lt;map&gt; using namespace std; int main() { int m,n; while(~scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bec003cd2a40003bd4ac8ff356df5c1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36b8e247f6246824b33252c9f24a7d50/" rel="bookmark">
			Android解决service向activity传值失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：在service使用Intent打开activity并传递值，在onResume中使用getIntent不能及时地获得正确的值，取到的是上一次的值。
一般情况下，我们在使用intent打开activity时候，会执行onCreate、onStart、onResume,如果此时activity处于栈顶，再次打开activity执行onPause、onStop,此时activity再接受intent请求的话，会执行onNewIntent、onRestart、onStart、onResume。因此，当后台运行的activity回到前台并传递回数据时候需要特别注意下。
默认情况下，使用intent开启activity时，即使已经存在一个相同的正在运行的activity，系统也会创建一个新的实例显示。为避免实例化多次，需要在清单文件中将该activity的launchMode设为singleTask。此时，当再次通过intent开启一个已存在的实例，那么系统就不会再调用onCreate，而是调用onNewIntent方法。
解决方法：设置activity的launchMode为singleTask的前提下，调用onNewIntent方法，并在里面调用setIntent(intent)确保获得的值不是上一次保存下来的。此时，再调用onResume得到的值就会是正确的了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d9aba1856435b6bc4b5acd45fd33dd3/" rel="bookmark">
			腾讯云免流搭建教程免流服务…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：腾讯云免流搭建教程免流服务器搭建教程流控搭建自动安装 作者：免流搭建-免流服务器搭建 看本教程前先确保你的服务器上已经用最新适配centos7.0的一键脚本搭建了云免服务器
推荐使用 阿里云或腾讯云
现在适配某汪的一键云免搭建脚本 现在可用的是网易蜂巢Docker（Centos7.0 效果同6.7）和Centos7.0 综合脚本
然后用 xhell 连接你的服务器 软件可以去百度下载
打开压缩包的这个文件
把里面的命令复制下来 粘贴到控制台界面下 然后回车
输入数据库密码 如果输错了没办法删除的 只能 ctrl+c 终止安装 然后重新安装
然后会出来很多让你选择y或n的选项 统统直接回车 什么都不要选
然后一直等就行了 看你服务器配置 半个小时到一个小时不等
不要问我为什么还没好 为什么这么慢 你服务器配置越高就安装的越快 我给人家安装等过两个小时 如果你没超过这个时间就不要抱怨慢
打开上图中的web 目录
用记事本打开红框中的3个文件
把3个文件里的 qwer123 全部替换成你的数据库密码 就是一开始设置的那个密码
注意 是三个文件里的 都要替换 都要替换都要替换 然后保存 保存 保存
接下来打开下面图片中的文件
是红箭头指的文件
就是这个 login.php 用记事本打开它
那个admin就是你管理界面的管理员账户 admin123就是密码修改成你想要的 然后保存
保存
保存
接下来 打开sh目录
Server.conf那个文件没有的话不用管 这是以前的图片
把里面所有的qwe123都替换成你的数据库密码
前面的字母p要保留下来
然后 保存
下面是修改端口的部分
打开上图中的 nignx.conf 文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d9aba1856435b6bc4b5acd45fd33dd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b183fc7d7bb2a4bce3d22bd6b8e7b0/" rel="bookmark">
			数据仓库建模-维度建模基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，什么是维度建模 kimball推出维度建模。 按照事实表，维度表来构建数据仓库，数据集市。这种方法的最被人广泛知晓的名字就是星型模式（Star-schema） 维度建模法的缺点也是非常明显的， 1 由于在构建星型模式之前需要进行大量的数据预处理，因此会导致大量的数据处理工作。 而且，当业务发生变化，需要重新进行维度的定义时，往往需要重新进行维度数据的预处理。 而在这些与处理过程中，往往会导致大量的数据冗余。 2 如果只是依靠单纯的维度建模，不能保证数据来源的一致性和准确性，而且在数据仓库的底层，不是特别适用于维度建模的方法。 二，什么是维度表和事实表 事实表：存放大量有业务性能的度量值 维度表：包含有业务的文字描述 三，维度建模的方法 当一个人业务总是随时间发生变化，那么需要什么呢？ 四步维度建模： 1，选取业务处理过程 （选取业务处理） 维度模型一致性 第一个维度模型应该是一个最有影响的模型（POS零售业务） 2，定义业务处理的粒度（定义粒度） 粒度的定义：对事实表的行给出确定的说明。也就是，如何描述事实表的单个行？ 应根据业务处理过程中产生的最具有原子性信息，来开发维度模型（原子型数据就是不能再做进一步的细分） 最佳粒度的数据是：POS事物的单个分列项（） 3，选定用于每个事实表行的维度(选定维度) 引出的问题是：业务人员如何描述从业务处理过程得到的数据？ 常见的维度有：日期，车，车主，账户，套餐，事件类型等 粒度定义后，可以确定基本维度，我们往往会在基本粒度上，加入更多的维度，而且这些附加维度不会产生另外的事实行 4，确定用于形成每个事实表行的数字型事实 回答的问题：要对什么内容进行评测（度量）？ 典型的事实是：银行的账户余额，电商的订货量这样的可加性数字数据 这四步建模，以用户对业务的理解作为确定维度和事实的内容依据 但是，许多公司企图用数据驱动最省力的方式建模，结果很少有成功
----Question-----
数据仓库建模三范式建模为什么能保证口径的一致性？
三范式规则（不背原文了）是一种互斥的排他法规则，
按三范式设计出来的成员属性，
只可能从属于一个实体，
依赖于一个主键（其他都是引用），
换句话说只存于一个地方，其他都从这个地方取数，这当然就保证了数据一致。
而“维度”设计的本质，就是从不同角度来解读数据，
是一种包容性的方式（因为没有界限定义，所以连法则都不能算）。
比如我把楼上的例子再扩大化，国家和省市是可以作为两个维度来分析的（比如在统计营业收入时）但是国家又包括省市，
这就造成了一个成员可能在多个地方出现，数据相对三范式也就难以保证口径一致（因为要同步更新多个地方，可能会有时差或误差）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e1c42ffdf48155ca04fedaac2adcf8/" rel="bookmark">
			排序算法二：快速排序算法原理以及MATLAB与Python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天继续学习排序算法。今天的主角是快速排序算法。
1. 快速排序基本原理 快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。
该方法的基本思想是：
1．先从数列中取出一个数作为基准数。
2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
3．再对左右区间重复第二步，直到各区间只有一个数。
举例说明：
这里有一个待排序的序列：a=[72 6 57 88 60 42 83 73 48 85]
按照以上的思想，手动操作了一次这个思想：
上面的过程就是一次排序，将所有的小于选定的数全部放在了左边，全部大于选定的数放在了其右边。然后再分别对这两边的子序列进行相同的操作。知道最后需要操作的子序列中只有一个数。再排序结束。
2.MATLAB 实现 依据上面的思想对其进行代码实现。显然，对待子序列的操作最好就是使用过递归进行。
自定义快速排序函数 myQuickSort
function a=myQuickSort(a,leftIndex,rightIndex) % a是待排序序列 %leftIndex和rightIndex是开始的左右两个边界 %%----------------------------------------------------------%% % if leftIndex&gt;rightIndex % break; % end if leftIndex&lt;rightIndex i=leftIndex; j=rightIndex; temp=a(i);%选定的这个数挖掉，相当于挖坑 while i&lt;j while (i&lt;j)&amp;&amp;(a(j)&gt;=temp)%从右往左，找到第一个小于设定的数， j=j-1; end a(i)=a(j);%将找到的第一个小于设定的数填坑到最开始挖的坑里面去 while (i&lt;j)&amp;&amp;(a(i)&lt;=temp)%从做到由，找到第一个大于选定的数 i=i+1; end a(j)=a(i);%将找到的第一个大于选定的数填入上一步挖的坑里面去 % if i==j % a(j)=temp; % end end a(j)=temp;%最后，i=j，将选定的数再填到上一步挖的坑里面去 a=myQuickSort(a,leftIndex,j-1);%对左边序列进行递归 a=myQuickSort(a,i+1,rightIndex);%对右边序列进行递归 end end 测试函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64e1c42ffdf48155ca04fedaac2adcf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23955b28434e484d1508d9d14d2965b1/" rel="bookmark">
			byte[]转String，编码与乱码问题，以及Base64编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先常用的byte[]直接转String很简单：
public static void main(String[] args) { String str="我是中国人"; byte[] arr=str.getBytes(); System.out.println("打印："+arr); for(byte e : arr) { System.out.print(e + " "); } String str2=new String(arr); System.out.println("\n打印2："+str2); } 比如上面这个，输出的结果是： 打印：[B@15db9742 -50 -46 -54 -57 -42 -48 -71 -6 -56 -53 打印2：我是中国人看到这个就要知道编码了。byte是一个字节，汉字是两个字节。所以五个汉字要十个byte类型的数字存储。然后数字变成汉字，这中间就是走了一个编码规范的过程。 那么java中是如何处理字符编码的？这就需要规范了，
JAVA使用自己的String类，并且String类对象是不需要指定编码表的！为什么它会自己知道一堆数字各代表什么字符呢？就是因为String里的字符信息是用UNICODE编码存放的。而JAVA为了表示字符（注意是单个字符），也有char这个数据类型，而且他的大小是固定2个8位16进制数字长度，也就是0~65535。为的就是对应UNICODE里面的一个字符。大家如果想取一个String里的按UNICODE数字，可以用getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 方法取得一个char[]，这个char[]里就是表示String字符的，按UNICODE编码表编码的数字。
为什么会出现byte[ ]转String又会出现乱码现象？
很显然，就是上面提到的，编码规范不一样。举个栗子，比如GB2312规范的中文“当”字，就是用0xB5,0xB1这两个八位的数字来表示的。在英文系统上，没有GB2312编码表，给他一个0xB5,0xB1，他就傻傻的当作ASCII来处理。放到Java里，他又会按照自己的UNICODE规范来处理，所以规范不一样，就会出现奇怪的结果，也就是乱码。
那么我们怎么解决byte[ ]转String的乱码问题呢？
得看byte[]来自哪里了。时常会遇到，要把一张图片转为byte[]然后在转为String流对象传输到别的地方，接收者再转为byte[]再变成图片。
①有人推荐使用序列化，这也是一个方案，但是具体实施还没有研究过。
②直接传输byte[]的话，会出现byte[]过长数据丢失。因为不是所有的byte组合都可以映射成char
③那么就是用常见的Base64编码规范吧。base64的编码规范就是将常见的字符转换成6位二进制表示（常用64个所以叫base64吧）。怎么写，有现成的工具类哦如下：
import org.apache.commons.codec.binary.Base64; public class UtilHelper { //base64字符串转byte[] public static byte[] base64String2ByteFun(String base64Str){ return Base64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23955b28434e484d1508d9d14d2965b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ee567cb30ed92fc067964574c1eb1f/" rel="bookmark">
			logging的陷阱:python使用logging不能写日志,写不出日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 我自己写了两个模块request和checkcode,这两个中都引用了logging进行记录日志. 当分别使用request和checkcode时均没有问题,但是,将两个模块都导入后,写日志就出现异常.总是一个能写日志,一个不能写日志.
原因 因为两个文件中都是使用logging配置文件的方式创建logger,而且这两个模块都使用的不是同一个配置文件,所以,执行了两遍logging.config.fileConfig(log_conf_file). 我认为,使用logger = logging.getLogger('checkcode')获取到一个Logger,这是一个实例,你使用logger.info('this is a info msg')时,该Logger中并太多的配置信息,所以还是要读配置文件. 当你再导入另一个模块,就会又执行了一遍logging.config.fileConfig(log_conf_file_A),这是就把logging的配置文件又重新刷新.当你再想写之前的logger.info('this is a info msg')时,因为读配置文件又读不到想要的相关配置,所以导致写日志失败.
注:该分析未经证实,仅供参考.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c0fb8f9756d9f2d56cf59b2226efed/" rel="bookmark">
			codeforces 839 C Journey
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C. Journey time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output There are n cities and n - 1 roads in the Seven Kingdoms, each road connects two cities and we can reach any city from any other by the roads.
Theon and Yara Greyjoy are on a horse in the first city, they are starting traveling through the roads. But the weather is foggy, so they can’t see where the horse brings them.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c0fb8f9756d9f2d56cf59b2226efed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45cc089c7ccbbcd6fe490c81d07d98ca/" rel="bookmark">
			codeforces 839 B Game of the Rows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B. Game of the Rows time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output Daenerys Targaryen has an army consisting of k groups of soldiers, the i-th group contains ai soldiers. She wants to bring her army to the other side of the sea to get the Iron Throne. She has recently bought an airplane to carry her army through the sea.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45cc089c7ccbbcd6fe490c81d07d98ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d27ebfe182c88e7154a8add674af63d3/" rel="bookmark">
			GHGL项目-RSA加解密导致内存泄漏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述：JVM最大堆内存是默认（即32G），在做登录压测的时候，在到200并发的时候，tomcat崩了，查看日志的时候发现堆内存竟然满值，总有那么一些值不能释放，查询哪些类没有被释放，发现没有被释放的，见下图： 是java.util.HashTablesEntry和java.security.Provider.ServiceKey这两个类竟然占用了80%左右内存，一眼就看出了是加解密的问题，上网查看加解密导致内存泄漏的问题的时候，正好有原因和解决方法。 网上链接地址：http://www.jianshu.com/p/b67bb91530b5 原因是加解密的工具类中有一个静态资源总是在增加一个new对象，而且无法释放，最后导致堆内存满值， 那段代码是： 这个RSA加解密经常用到， 解决办法是： private static BouncyCastleProvider bouncyCastleProvider = new BouncyCastleProvider(); Cipher cipher = Cipher.getInstance("RSA",bouncyCastleProvider); 这样就OK， 看一下一直增加新对象不释放的过程： 1、 2、 3、 4、 在此感谢亮亮、波波等大神的帮忙。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/723a294968fabe941230e63b7951d7ad/" rel="bookmark">
			**Ioc和Aop
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IOC IOC控制反转，其实是一种思想，传统的Java se 是通过new 来创建一个对象，是程序主动的创建依赖对象。IOC是指，通过容器的来帮忙创建和注入依赖对象。类与类直接可以松耦合。
实现方式：配置文件，注解
BeanFactory接口是 IOC的具体实现，用来包装 管理 各种bean。
1.Ioc底层原理 （1）xml配置文件（2）dom4j解析（3）工厂设计模式（4）反射 步骤： 第一步：创建类的.xml文件 &lt;bean id="userService" class="....."/&gt;第二步：创建一个工厂类：使用dom4j解析配置文件+反射 public class UserFactory{ public static UserService getUserService(){ //使用dom4j解析配置文件 //根据id值获得class的属性值 String classValue="class属性值"； //使用反射来创建class对象 Class class=Class.forName(classValue); UserService service=class.newInstatnce(); return service; } } 通过IOC，我们如果改掉UserService类，只需更改bean里面的配置属性就行了，降低了类之间的耦合度
2.Ioc和DI的区别： （1）Ioc：控制反转，把创建对象交给Spring进行配置（2）DI：依赖注入。组件之间依赖关系由容器在运行期决定，容器动态的将某个依赖关系注入到组件中。向类里面的属性中设置值（3）二者关系：DI不能单独存在，要在Ioc基础之上来完成操作，即要先创建对象才能注入属性值。 3.循环依赖 递归调用过程中，发现Bean还在创建中（创建中是指new 出来，但是所有属性值均为null，等待init） 就是循环依赖。spring为解决单例的循环依赖问题，使用了三级缓存。bean的获取过程：一级缓存 -&gt; 二级缓存 -&gt; 三级缓存。
一级：用于存放完全初始化好的bean二级：存放原始的bean对象（尚未填充属性）,用于解决循环依赖三级：存放bean的工厂对象，解决循环依赖 具体过程：
A创建过程中需要B，于是A将自己放入三级缓存里，去实例化B；B实例化的时候发现需要A，于是B先查一级缓存 没有，查二级缓存 没有，查三级缓存 有。 然后把三级缓存里的A放到二级缓存，并删除三级缓存里的AB顺利初始化完自己后，将自己放到一级缓存（此时B中的A状态依然是创建中）然后返回继续创建A，此时B已经结束，直接从一级缓存中拿到B，完成创建，并把自己放入一级缓存。 Spring整合web项目原理 加载Spring核心配置文件 ApplicationContext context=new ClassPathXmlApplicationContext(“bean1.xml”);加载文件要new一个对象，每次访问都要new对象加载配置，效率低实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成实现原理： a) ServletContext对象b) 监听器（ServletContextListener接口）c) 具体使用： i. 服务器启动时，为每个项目创建一个ServletContext对象ii. 使用监听器可以监听到ServletContext在何时创建iii. 在监听器的，ServletContextListener接口的contextInitialized()方法方法中加载Spring配置文件（括号1中代码），创建对象。iv. 把创建出来的对象放到ServletContext域对象里面（setAttribute方法）v. 获取对象时，从ServletContext域对象中得到（getAttribute方法） AOP 面向切面思想，扩展功能时不通过源代码，横向抽取机制。Java面向对象的时候，遇到重复代码可以通过抽取方法和抽取类的方式实现。AOP的理念：将分散在各个业务逻辑中相同的代码通过横向切割的方式抽取到一个独立的模块。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/723a294968fabe941230e63b7951d7ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ea14c23f9d23193564cac77913356e/" rel="bookmark">
			做一个WINDOWS下破解WIFI。不须要Linux抓包！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搬家了，没网了。
没有WIFI了！
想破解，只是没有Linux环境，不能抓包！破解！
于是自己动手开工。 在windows 下直接破解。貌似国内 还没看到。假设有了，那么请各位童鞋 提醒一下。赶急 要使用啊！！
终于：
只是有点问题，假设路由器 启用混淆模式，那么怎样拿到真实的握手协议呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4f7612321008e2bac418bef60527bc0/" rel="bookmark">
			Kotlin协程介绍和使用入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://www.jianshu.com/p/9f720b9ccdea
本文主要介绍协程的用法, 以及使用协程能带来什么好处. 另外, 也会粗略提一下协程的大致原理.
本文的意义可能仅仅是让你了解一下协程, 并愿意开始使用它.
如果想彻底理解协程, 请查看官方文档, 官方文档链接将在文章的结尾给出.
如果你以前在别的语言里学习过协程, 如Python的yield, 那请你先忘记它们, 毕竟还是有些区别, 等你弄懂了Kotlin的协程, 再去作对比, 否则, 可能会有一些先入为主的思路来阻碍你理解, 我就吃过这个亏.
初识协程: 首先我们来瞄一眼协程是长啥样的, 以下引用(copy)了官网的一个例子: fun main(args: Array&lt;String&gt;) { launch(CommonPool) { delay(1000L) println("World!") } println("Hello,") Thread.sleep(2000L) } /* 运行结果: ("Hello,"会立即被打印, 1000毫秒之后, "World!"会被打印) Hello, World! */ 姑且不管里面具体的细节, 上面代码大体的运行流程是这样的:
A. 主流程: 调用系统的launch方法启动了一个协程, 跟随的大括号可以看做是协程体.
(其中的CommonPool暂且理解成线程池, 指定了协程在哪里运行)打印出"Hello,"主线程sleep两秒
(这里的sleep只是保持进程存活, 目的是为了等待协程执行完) B. 协程流程:
协程延时1秒打印出"World!" 解释一下delay方法:
在协程里delay方法作用等同于线程里的sleep, 都是休息一段时间, 但不同的是delay不会阻塞当前线程, 而像是设置了一个闹钟, 在闹钟未响之前, 运行该协程的线程可以被安排做了别的事情, 当闹钟响起时, 协程就会恢复运行.
协程启动后还可以取消
launch方法有一个返回值, 类型是Job, Job有一个cancel方法, 调用cancel方法可以取消协程, 看一个数羊的例子:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4f7612321008e2bac418bef60527bc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6450371a8cc6f2cec74a04b9febe98/" rel="bookmark">
			Tomcat8 禁止缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;Context docBase="/my/path/to/xmlui" reloadable="true"&gt; &lt;Resources cachingAllowed="false" /&gt; &lt;/Context&gt; 网上的都是针对以前版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e618801def7c2176b0423ec25e0b2ead/" rel="bookmark">
			Unity Shader(一) Lowpoly动态低多边形 (QQ登录界面低边动画)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在逛论坛的时候偶然发现有人在问动态低多边形(Lowpoly)是如何实现的，因为经常编写UGUI拓展对顶点操作较为熟悉的我立马就想到利用继承UnityEngine.Graphic，重写OnPopulateMesh方法绘制顶点、赋值颜色，在Update方法中计算顶点位置使得顶点在进行连续且不无断点的路径上产生位移即可，当然这只是初步的设想，这种方式能实现动态低边效果，但是不同的三角面展现的高光效果在UI也不是一件简单的事情，所以我们摒弃2DUGUI的方式，使用网格编程和Shader（着色器）来实现这一效果。
本文合适对向量运算和Shader有一定了解的人员，当然你也可以直接使用成果。
实现效果 网格使用代码生成，使得我们有更多可配置的余地
变种一 变种二 Inspecetor 主要内容 绘制网格网格持久化编写Shader网格动态化 详细设计 Unity中网格要可见还需要两个额外的好搭档Material和Shader，所以我们先创建好三个必备文件Lowpoly.cs（C#代码绘制网格）、Lowpoly.material（材质球）和LowpolyShader（着色器，用于给材质球着色）。
先补一个最终想要实现的大致效果 嗯，请脑补掉企鹅大厂的Logo : )
绘制网格 首先通过观察图片我们需要得知大致的绘制思路，大概如下几点：
绘制一个NxM的网格改变网格顶点的位置,实现网格错乱重点：每个三角形颜色一致，并没有顶点到顶点的颜色过度要计算法线，来实现不同角度的反射不同程度的来亮度将改变网格的算法移动到Update函数中，实现动画效果 绘制原理 我们就根据上述已经总结好的几点思路来逐步讲解原理
上一个NxM的效果图 绘制NxM的网格
在Unity中网格存储在MeshFilter组件的mesh属性里，所以我们在将绘制好的网格存入MeshFilter.mesh属性即可。要绘制mesh网格需要向mesh网格中写入顶点位置，贴图uv值（如果你不贴贴图的话也可以不赋值），三角面对应顶点的序号，顶点法线（如果不需要模型的细节也不可以不赋值法线，稍后我们再谈法线的问题），顶点切线（用于处理细节）,这里暂不考虑tangent。着色器的会为每一个顶点进行光照计算并并给顶点赋值颜色，如果A点到B点是三角面上的一条边，那么A点到B点的中间的颜色为A点的颜色到B点颜色的过渡色。但是因为我们要实现的效果中，三角面的颜色不存在过渡色，也就意味着着色器处理过后的三个顶点的颜色值一样，也就要求三个顶点的顶点法线是相同的，所以在处理网格法线时，我们需要将构成三角面的网格的三个顶点法线设置为同一个向量，同时这样也就意味着看似在一起的顶点也不能够共用，共用同一个顶点就会导致相邻两个三角面的法向量相同，从而导致所有顶点法向量相同导致无法曾现层次感。所以我们要为每一个三角面创建三个顶点。又因为每个四边形都需要利用两个三角面来组合绘制，因此我们可计算出绘制动态低多边形所需要的三角面个数(TrianglesCount)、顶点个数(VerticesCount)、UV坐标(UVsCount)和法线向量个数(NormalsCount): TrianglesCount = N*M*2 VerticesCount = TrianglesCount*3 UVsCount = VerticesCount NormalsCount = VerticesCount 有了以上大致的了解我们来计算顶点，顶点计算代码如下,为方便计算我们先计算一个矩形中右下角的三角形，再计算左上角的三角形
Mesh mesh = new Mesh(); mesh.name = "LowPoly"; size = new Vector3(1,1,0); origin = new Vector3 (-size.x / 2.0f,-size.y/2.0f,0); perX = size.x / XCount; perY = size.y / YCount; // 右下角三角面 for (int i = 0; i &lt;= YCount; i++) { for (int j = 0; j &lt;= XCount; j++) { if (j.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e618801def7c2176b0423ec25e0b2ead/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c019911ecdbb582c0b72c2c6a03415e/" rel="bookmark">
			1.11 C# 静态类和单例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 day 11 静态类和单例 1,静态类 静态成员变量 静态关键字static 静态成员的调用是不依赖对象,所以说一般静态成员也称之类成员 静态成员的调用方式: 静态成员依赖于类,所以调用的方式为类.静态成员 静态方法的特点: 1.调用方式,类名.方法名() 2.静态方法中不能出现this关键字,实际上就是不能访问非静态成员. 3.动态方法中可以直接调用静态成员 4.静态成员可以被重载,但是不能被重写. 静态成员和动态成员使用场景: 1.静态方法更适用于工具类,处理一次性结果时. 2.动态方法更适用于变化的功能,就是不是仅仅拿到结果,而是关注 过程,这个过程是变化的. 静态构造函数 1.静态构造函数会在动态构造函数之前会被系统默认调用 2.静态构造函数没有修饰符修饰 3.静态构造函数不能被手动调用 4.静态构造函数只会被调用一次,并且不能重载 5.静态构造函数调用取决于类的内部有没有静态成员被调用 2,单例 1. 默认构造使用private修饰 2. 内建该类的静态实例 3. 静态构造方法中给该静态实例做初始化 4. 对外提供获取该静态实例的方法 如: class SingleClass { private SingleClass() //1,私有化构造函数 { } private static SingleClass instance; //2,内建该类的实例 public static SingleClass Instance() //4给外部一个实例的方法 { if (instance == null) { instance = new SingleClass(); //3.给该实例初始化 } return instance; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2362bbd5c794ab9d52506fc7f5bbda2/" rel="bookmark">
			镜像文件下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://vault.centos.org/6.5/isos/x86_64/
http://archive.cloudera.com/cdh5/repo-as-tarball/5.5.1/
好书推荐
Inside the Java Virtual Machine(中文第2版)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6123dec8781250ff6e14f9295ae6559b/" rel="bookmark">
			mvn详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 Maven，发音是[`meivin]，"专家"的意思。它是一个很好的项目管理工具，很早就进入了我的必备工具行列，但是这次为了把project1项目完全迁移并应用maven，所以对maven进行了一些深入的学习。写这个学习笔记的目的，一个是为了自己备忘，二则希望能够为其他人学习使用maven 缩短一些时间。 2.命令 mvn pom.xml文件配置详解 http://maven.apache.org/ref/2.0.8/maven-model/maven.html mvn -version/-v 显示版本信息 mvn archetype:generate 创建mvn项目 mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app 创建mvn项目 mvn package 生成target目录，编译、测试代码，生成测试报告，生成jar/war文件 mvn jetty:run 运行项目于jetty上, mvn compile 编译 mvn test 编译并测试 mvn clean 清空生成的文件 mvn site 生成项目相关信息的网站 mvn -Dwtpversion=1.0 eclipse:eclipse 生成Wtp插件的Web项目 mvn -Dwtpversion=1.0 eclipse:clean 清除Eclipse项目的配置信息(Web项目) mvn eclipse:eclipse 将项目转化为Eclipse项目 在应用程序用使用多个存储库 &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;Ibiblio&lt;/id&gt; &lt;name&gt;Ibiblio&lt;/name&gt; &lt;url&gt;http://www.ibiblio.org/maven/&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;PlanetMirror&lt;/id&gt; &lt;name&gt;Planet Mirror&lt;/name&gt; &lt;url&gt;http://public.planetmirror.com/pub/maven/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; mvn deploy:deploy-file -DgroupId=com -DartifactId=client -Dversion=0.1.0 -Dpackaging=jar -Dfile=d:\client-0.1.0.jar -DrepositoryId=maven-repository-inner -Durl=ftp://xxxxxxx/opt/maven/repository/ 发布第三方Jar到本地库中： mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6123dec8781250ff6e14f9295ae6559b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/556ab42f356151b738766a0782b3ba82/" rel="bookmark">
			shell 处理将动态解析的日志文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候，我们需要对一些程序的日志文件进行数据分析，如果是我们自己处理和分析的情况下一般是使用程序读取对应日志文件按照对应规则保存到数据库然后再进行分析。 如果我们直接到日志文件进行分析，我们没有办法记录以及分析过的。因为日志文件是随时在增加的。但是我们程序读取到和处理一次时，没有办法确定是否有新的日志追加到里面。 那么如果直接读取第一行后删除第一行后再写入文件中。这样会造成日志丢失，所以这个方法是不可行的。那么既然直接读取不可行，就想其他的办法。在日志文件中我们都有一些习惯或者对应规则按照天拆分。也就是每当一天结束后，对应那天的日志文件会按照规则新生成一个文件，而不是当前正在使用的日志文件（老司机懂，新司机请自行脑补）
根据这个思路我们就读取备份的日志文件，这样就不会在当前日志造成丢失了。但是考虑到日志分析对按照天来读取，这样数据更新太慢不好，那么就想法指定周期读取如5分钟一次，10分钟一次，30分钟一次。。。。
具体看对应业务对数据更新速度要求，这样一来我们就可以实现去用程序动态解析日志文件了。按照指定周期拆分文件，大部分程序都有自己的配置规则，根据实际程序来定，这里举例说明nginx 没有自己的拆分规则。需要借助其他工具来拆分。 在linux 中可以使用logrotate 来实现 似乎logrotate 中最小单位是天所以这里还是很推荐的一种方案，如果业务量大，一天的日志很可能上G
logrotate 不可以实现那么还是我们自己动手吧
#!/bin/bash # 遍历目录下所有文件 function listPath(){ for file in `ls $1` do if [ -d $1"/"$file ]; then listPath $1$file/ else path=$1$file end=${path: -4} if [ "$end" == ".log" ]; then dologFile $path fi fi done } # 处理日志文件 function dologFile(){ if [ -s $1 ]; then time=$(date +%Y%m%d-%H%M%S) echo $1 $time mv $1 $1-$time fi } # 重新加载nginx 日志 function loadNginx(){ echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/556ab42f356151b738766a0782b3ba82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18a4325ee52477b1a451483d3f4c171/" rel="bookmark">
			1.9 C# 面向对象的三大特性--多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day 9 面向对象的三大特性--多态 1,方法重载 ---&gt;同一个方法但是不同的行为,参数不同这一特性称之为方法重载 构造函数就是方法重载 ---&gt;方法重载的特点: 1,方法名必须相同. 2,参数列表不可以相同. 3,如果参数列表相同,那么判断方法重载时就看参数的类型 或者参数的顺序. 4,函数返回值类型不构成判断方法重载的依据 5,必须是同一个类中的同一个方法的不同实现 2,方法重写 ---&gt;方法重写的特点 1,必须是父子关系 2,需要被重写的方法前面要被申明虚(virtual)方法 3,子类重写父类的虚方法要使用override 4,一般情况下virtual要与override需要成对儿出现 5,虚方法可能会被重写(就是子类可以用override也可以不用) 6,子类重写了父类方法,那么父类中的方法一定是虚方法 ---&gt;方法重写的使用场景 1,多个子类对同一个行为表现出不同的状态时,此时应该用重写. 2,虚方法实际上功能已经实现,但是呢,又不是实现的很好.通过 重写去完善功能. ---&gt;方法重写需要注意的地方 1,子类不能重写父类用sealed修饰的方法 2,子类不能重写父类用static修饰的方法 3,如果父类中有abstract修饰的方法,子类必须重写. 3,里氏替换原则 ---&gt;LSP:原则上来说子类对象可以赋值给父类对象,也可以 说子类替换父类,并且能够出现在任何父类出现的 地方,反过来说父类对象不能直接替换子类对象,这 种特性称之为里氏替换原则. 1,子类可以隐式转换为父类 2,父类必须强转子类(强转只是改变类型不能改变指针所指向的内存((变量类型))) ---&gt;is和as as;(对象类型)关键字的含义是转换,但是一旦转换失败后, 系统会默认给一个null值,程序不会报错 A as B ? B的类型:null; is:询问的意思 A is B? is作为判断A是不是B类型 或者A是不是B类型的子类. 引用类型调用方法方法: /* * 在调用一个对象的方法时,会检查这个对象a的类型, * 首先找到堆中的类型对象指针, * 通过指针找到对象a,查看其是否有该方法. * 如果没有,则通过类型对象的类型对象指针向上查找 * 直到找到该方法为止,然后检查该方法是否为虚方法, * 如果非虚方法直接调用,如果该方法为虚方法,即有 * virtual修饰的方法,则根据变量a,去找对象的实例, * 查找该方法是否被重写过,如果有,执行. * 没有则继续向上查找.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18a4325ee52477b1a451483d3f4c171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/569e384df4be75ae23f401de3e0f2f2a/" rel="bookmark">
			B - Vladik and Complicated Book（思维题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vladik had started reading a complicated book about algorithms containing n pages. To improve understanding of what is written, his friends advised him to read pages in some order given by permutation P = [p1, p2, ..., pn], where pi denotes the number of page that should be read i-th in turn.
Sometimes Vladik’s mom sorted some subsegment of permutation P from position l to position r inclusive, because she loves the order.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/569e384df4be75ae23f401de3e0f2f2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aa08c8336a38da2e91c272960fde0d2/" rel="bookmark">
			uvalive 3938 Ray, Pass me the dishes!（线段树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接：https://vjudge.net/problem/UVALive-3938
题意： 给一个数组，多次查询，询问区间[l, r]最大连续和。
思路： 线段树。 查询一个区间的最大连续和，可以找一个mid，这个最大连续和的起点和终点， 可能在mid的左边，或者在mid的右边，或者横跨mid。
左区间和右区间的最大值是递归定义的，维护起来也是容易的。
横跨mid的最大值如何计算？等于左区间最大后缀+右区间最大前缀。
如何维护区间最大前缀和区间最大后缀？
设一个区间为[l, r], 设它的左区间最大前缀为[l, idx1]，右区间最大前缀为[(l+r)/2+1, idx2] 那么区间最大前缀为比较前缀和在区间[l, idx1]和[l, idx2]中哪一个比较大， 选择大的那个前缀和对应的那个idx。
最大后缀同理。
如何查询最大前缀？ 设一个区间[l, r]，它的最大前缀为prefix, 如果prefix&lt;=query_r(要查询的区间的右端点值)， 满足条件，直接return [l, prefix]
若prefix &gt; query_r，那么最大前缀在当前区间的左区间或者右区间。 当mid = (l+r)/2 &gt;= query_r，那么要查询的最大前缀在区间[l, mid]; 当mid &lt; query_r，那么可以得到当前区间的右区间的最大前缀prefix2， 当前区间的最大前缀要在左区间最大前缀prefix1和右区间最大前缀prefix2中选择大的。
最大后缀同理。
注意当区间和相同时，取坐标比较小的那位。
代码： （写法来源：http://www.cnblogs.com/zyb993963526/p/6547946.html）
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; #include &lt;cstdlib&gt; using namespace std; const int maxn = 1000000 + 5; typedef long long ll; typedef pair&lt;int, int&gt; Interval; int n, m, QL, QR; ll sum[maxn]; struct Node { Interval max_sub; //最大连续和, 一个区间 int prefix; int suffix; }tree[maxn]; ll calc(int L, int R){ return sum[R] - sum[L-1]; } Interval better(const Interval &amp;a, const Interval &amp;b){ if(calc(a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0aa08c8336a38da2e91c272960fde0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd5ed33c6b1df547b0a0b19557449a54/" rel="bookmark">
			Re：从零开始的Spring Security Oauth2（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 今天来聊聊一个接口对接的场景，A厂家有一套HTTP接口需要提供给B厂家使用，由于是外网环境，所以需要有一套安全机制保障，这个时候oauth2就可以作为一个方案。
关于oauth2，其实是一个规范，本文重点讲解spring对他进行的实现，如果你还不清楚授权服务器，资源服务器，认证授权等基础概念，可以移步理解OAuth 2.0 - 阮一峰，这是一篇对于oauth2很好的科普文章。 需要对spring security有一定的配置使用经验，用户认证这一块，spring security oauth2建立在spring security的基础之上。第一篇文章主要是讲解使用springboot搭建一个简易的授权，资源服务器，在文末会给出具体代码的github地址。后续文章会进行spring security oauth2的相关源码分析。java中的安全框架如shrio，已经有跟我学shiro - 开涛，非常成体系地，深入浅出地讲解了apache的这个开源安全框架，但是spring security包括oauth2一直没有成体系的文章，学习它们大多依赖于较少的官方文档，理解一下基本的使用配置；通过零散的博客，了解一下他人的使用经验；打断点，分析内部的工作流程；看源码中的接口设计，以及注释，了解设计者的用意。spring的各个框架都运用了很多的设计模式，在学习源码的过程中，也大概了解了一些套路。spring也在必要的地方添加了适当的注释，避免了源码阅读者对于一些细节设计的理解产生偏差，让我更加感叹，spring不仅仅是一个工具框架，更像是一个艺术品。
概述 使用oauth2保护你的应用，可以分为简易的分为三个步骤
配置资源服务器配置认证服务器配置spring security 前两点是oauth2的主体内容，但前面我已经描述过了，spring security oauth2是建立在spring security基础之上的，所以有一些体系是公用的。
oauth2根据使用场景不同，分成了4种模式
授权码模式（authorization code）简化模式（implicit）密码模式（resource owner password credentials）客户端模式（client credentials） 本文重点讲解接口对接中常使用的密码模式（以下简称password模式）和客户端模式（以下简称client模式）。授权码模式使用到了回调地址，是最为复杂的方式，通常网站中经常出现的微博，qq第三方登录，都会采用这个形式。简化模式不常用。
项目准备 主要的maven依赖如下
&lt;!-- 注意是starter,自动配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 不是starter,手动配置 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 将token存储在redis中 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 我们给自己先定个目标，要干什么事？既然说到保护应用，那必须得先有一些资源，我们创建一个endpoint作为提供给外部的接口：
@RestController public class TestEndpoints { @GetMapping("/product/{id}") public String getProduct(@PathVariable String id) { //for debug Authentication authentication = SecurityContextHolder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd5ed33c6b1df547b0a0b19557449a54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f87454ff36d85f0bc9dde0a54ec7d22e/" rel="bookmark">
			Sequelize 中文API文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sequelize 中文API文档－1. 快速入门、Sequelize类 2016年05月20日 35766 声明
Sequelize类是引用sequlize模块后获取一个顶级对象，我们通过它来创建sequlize实例，也可以通过该对象来获取模内其它对象的引用，如：Utils工具类、Transaction事务类等。创建实例后，可以通过实例来创建或定义Model（模型）、执行查询、同步数据库结构等操作。
快速入门 1.1 安装1.2 建立连接1.3 model定义1.4 Promise Sequelize类 2.1 new Sequelize() - 实例化2.2 new Sequelize() - 通过URI实例化2.3 sequelize.models - 实例中已定义的模型2.4 sequelize.define() - 模型定义2.5 Sequelize - 顶级对象2.6 Utils - 工具类2.7 Promise - Promise对象2.8 QueryTypes - 查询类型枚举2.9 Validator - validator.js对象2.10 Transaction - 事务对象2.11 Deferrable - 延时对象2.12 Instance - 实例对象2.13 Association - 联合关系对象2.14 Error - 错误对象2.15 ValidationError - 验证失败错误对象2.16 DatabaseError - 数据库错误对象2.17 TimeoutError - 查询超时错误对象2.18 UniqueConstraintError - 唯一性错误对象2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f87454ff36d85f0bc9dde0a54ec7d22e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3571dd9a7687fcf3480b8b771017af90/" rel="bookmark">
			两种图像骨架提取算法的研究(1)原理部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像骨架提取，实际上就是提取目标在图像上的中心像素轮廓。说白了就是以目标中心为准，对目标进行细化，
一般细化后的目标都是单层像素宽度。比如输入图像是这样：
输出骨架图像(红色)
关于骨架提取，现存的算法有一千种以上（论文[1]中谈到，There are more than one thousand algorithms thathave been published on this topic）。论文[1]中提到，所有的骨架提取算法无外乎分为迭代和非迭代两大类。在迭代算法中，又分为并行迭代和顺序迭代两种。
本文分别介绍两种提取算法，它们分别来源于论文[1](K3M顺序迭代)、[2](Zhang-Suenalgorithm,并行迭代)。
这两种方法都是对二值图像操作的，思想都是从目标外围往目标中心，利用以待检测像素为中心3*3像素窗口的特征，对目标不断腐蚀细化，直至腐蚀到不能再腐蚀（单层像素宽度），就得到了图像的骨架。下面详细介绍一下两种骨架提取算法。
一 K3M 该算法的思想是，提取目标外围轮廓，然后利用轮廓腐蚀目标图像边界（这是一次迭代过程），
直至腐蚀到不能再腐蚀。
算法分为两块
第一块，不断腐蚀，提取出伪骨架(部分区域有两层像素宽度，但已经很接近真实骨架)。
第二块，从伪骨架中提取真实骨架。
第一块：提取出伪骨架 每次迭代共有6步。不断迭代，直至某次迭代的过程，目标边界中没有新的像素被腐蚀，那么此时，剩余的目标图像像素就很接近于真实骨架(称之为伪骨架)。
&lt;1&gt;提取最新目标轮廓(初始为原目标轮廓)并记录这些轮廓点。
&lt;2&gt;依次检测这些轮廓点的8像素邻域，是否只含有3连通像素，如果有，把此点从轮廓点删除，并在目标图像中删除（腐蚀掉）对应点。
&lt;3&gt;依次检测&lt;2&gt;中剩余轮廓点的8像素邻域，是否只含有3 or 4连通像素，如果有，把此点从轮廓点删除，并在目标图像中删除（腐蚀掉）对应点。
&lt;4&gt;依次检测&lt;3&gt;中剩余轮廓点的8像素邻域，是否只含有3 or 4 or 5连通像素，如果有，把此点从轮廓点删除，并在目标图像中删除（腐蚀掉）对应点。
&lt;5&gt;依次检测&lt;4&gt;中剩余轮廓点的8像素邻域，是否只含有3 or 4 or 5 or 6连通像素，如果有，把此点从轮廓点删除，并在目标图像中删除（腐蚀掉）对应点。
&lt;6&gt;依次检测&lt;5&gt;中剩余轮廓点的8像素邻域，是否只含有3 or 4 or 5 or 6 or 7连通像素，
如果有，把此点从轮廓点删除，并在目标图像中删除（腐蚀掉）对应点。
这是一次迭代过程的最后一步，如果在这步骤中仍有像素被腐蚀，
说明除了真实骨架还有”肉”，仍需继续腐蚀边界。这一步骤是算法迭代的终止条件。
第二块 从伪骨架中提取真实骨架。 算法第一块得到的伪骨架有部分区域是两个像素宽度，而目标骨架是单层像素宽度。所以，通过下面这一步骤提取最终骨架：
依次检测目标图像中，伪骨架的8像素邻域，是否只含有2 or 3 or 4 or 5 or 6 or 7连通像素，如果有，把此点从伪骨架中删除(腐蚀)，就得了最终的骨架。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3571dd9a7687fcf3480b8b771017af90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e8c7d294f9128455ff894f5cf335c7f/" rel="bookmark">
			ArcGIS Server和Portal 如何取消联合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们将Portal和Server联合之后，当我们想取消联合，发现在portal中的编辑设置中并没有删除联合serve这一个按钮，那我们应该怎么办呢？
解决办法： 打开portaladmin（如：https://计算机域名:7443/arcgis/portaladmin/）后，依次点击Federation&gt;Servers。我们会看到如图的已经联合的server
点击打算取消的servre&gt;点击Unfederate&gt;Unfederate Server&gt;取消成功。
P.S:从 ArcGIS Enterprise 门户中删除托管服务器会使现有托管 Web 图层无法使用。重新添加托管服务器不会将托管服务返回到可用状态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b12fcf2be00d97354ba704acb2e9dcc3/" rel="bookmark">
			安卓使用约束者布局实现屏幕适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先简单快速的介绍约束者布局实现屏幕适配。 为了实现屏幕适配，我们需要解决两个问题： 一、指定控件在父控件的百分比位置。 二、指定控件占父控件的百分比空间。 我们先解决第一个问题，指定控件水平方向在父控件的百分之四十，垂直方向在父控件百分之二十的位置，布局文件代码：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="test.constraintlayouttest.MainActivity"&gt; &lt;android.support.constraint.Guideline android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" app:layout_constraintGuide_percent="0.4" android:id="@+id/vertical_line_1" /&gt; &lt;android.support.constraint.Guideline android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal" app:layout_constraintGuide_percent="0.2" android:id="@+id/horizontal_line_1" /&gt; &lt;ImageView android:id="@+id/iv_top" app:layout_constraintLeft_toLeftOf="@id/vertical_line_1" app:layout_constraintTop_toTopOf="@id/horizontal_line_1" android:layout_width="50dp" android:layout_height="50dp" android:background="#ff0000" /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 效果： 然后第二个问题，指定控件占父控件的百分比空间，宽度20%，高度60%。 我们分别给控件的左右上下四个方向都设置约束，左右约束的百分比差值就是控件的宽度，高度同理。 布局文件代码：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="test.constraintlayouttest.MainActivity"&gt; &lt;android.support.constraint.Guideline android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" app:layout_constraintGuide_percent="0.4" android:id="@+id/vertical_line_1" /&gt; &lt;android.support.constraint.Guideline android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" app:layout_constraintGuide_percent="0.6" android:id="@+id/vertical_line_2" /&gt; &lt;android.support.constraint.Guideline android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b12fcf2be00d97354ba704acb2e9dcc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1e60102ad4313da4d8b95d38e6c7fdd/" rel="bookmark">
			Python异常：SyntaxError: Non-ASCII character &#39;\xe5&#39; in file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【现象】 在编写Python时，当使用中文输出或注释时运行脚本，会提示错误信息：SyntaxError: Non-ASCII character '\xe5' in file ******* 【原因】
Python2.x的默认编码文件是用的ASCII码，而你的python文件中使用了中文等非英语字符。Python2.x默认编码是UTF-8，不会出现这个问题。
【解决办法】
在Python源文件的最开始一行，加入一句：# coding=UTF-8（等号换为”:“也可以）或者# -*- coding:UTF-8 -*- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21ffbd2d436450a714e39ed9ddac9e76/" rel="bookmark">
			1.8 C# 继承和继承关系中的构造函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1,构造函数 构造函数的语法格式: 修饰符+类名(){ } 构造函数的作用:实例化对象,快速初始化对象 构造函数的特点: 1,如果类中没有构造函数,系统会为每一个类生成默认的构造函数 2,如果类中存在带有参数的构造函数,系统就不会为类生成默认的构造函数 此时如果调用new Cat();时会报错. 解决方法有两个:1,为类添加默认的构造函数 2,new Cat(传参数); 3, 构造函数是没有返回值的. 2.继承 继承的语法 A:B 即A类继承自B类 继承的特点: 1.子类会拥有父类所有的公开字段/属性/方法 2.父类不会拥有子类的字段/属性/方法 3.如果子类和父类出现相同的字段/属性/方法,以子类为准 4.子类可以出现在任何父类出现的地方,子类可以替换父类,父类不能直接替换子类 Father f = new Son(); 编译时f的类型是Father,运行时f的类型是Son 5.如果子类出现和父类相同的方法名时,如果想隐藏父类方法, 需要在子类方法修饰符后加上new关键字,防止后期程序过大时出现Bug 6.base关键字代表父类对象 7.一个子类不可以拥有多个父类(父类除了object类) 8.父类可以拥有多个子类 继承中的构造函数特点: 1.如果两个类存在父子关系,那么在实例化子类的时候,首先会调用 父类的无参数构造函数,然后再调用子类的构造函数 2.实例化子类对象的时候,可以指定父类调用父类中存在的任意构造函数 使用关键字:base() :base() ----指定子类构造函数调用父类的无参数构造函数 :base(a) ---指定子类构造函数调用父类带有一个参数的构造函数 这里需要注意的是: 我们在实例化子类对象的时候,一定要关注构造函数的特点; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfe70b8c8f23dba4b208bd71a80ddc9/" rel="bookmark">
			mui.back()返回刷新功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景：操作某个步骤需要获取用户信息,如果用户未登陆,则跳转登录页面,登陆成功之后使用mui.back()返回父页面,父页面必须刷新。
子页面：登陆页
父页面：跳转登录页的页面
在子页面初始化时,注册beforeback方法; mui.init({ beforeback: function() { //获得父页面的webview var list = plus.webview.currentWebview().opener(); //触发父页面的自定义事件(refresh),从而进行刷新 mui.fire(list, 'refresh'); //返回true,继续页面关闭逻辑 return true; } }); 2.在父页面中添加事件监听：
window.addEventListener('refresh', function(e){//执行刷新 location.reload(); }); 这样，在子页面执行返回操作mui.back()时,会执行父页面的refresh事件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eda9f7f30c7dd1db84194cae6f9fb336/" rel="bookmark">
			Codeforces835C-Star sky(二维前缀和&#43;思维)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Star sky time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output The Cartesian coordinate system is set in the sky. There you can see n stars, the i-th has coordinates (xi, yi), a maximum brightness c, equal for all stars, and an initial brightness si (0 ≤ si ≤ c).
Over time the stars twinkle. At moment 0 the i-th star has brightness si.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eda9f7f30c7dd1db84194cae6f9fb336/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5739d01e4609962f72f9f2d8e10b0cc/" rel="bookmark">
			arcgis 启动速度慢解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 arcmap启动时候分为两个步骤： 1. 加载文档，如果是这个阶段慢的话，可以尝试 （1）尝试先删除地图模板，默认模板，Win7路径：C:\Users\当前登录用户\AppData\Roaming\ESRI\Desktop10.2\ArcMap\Templates?，删除normal.txt
（2）点击运行，输入regedit，选择HKEY_CURRENT_USER\Software\ESRI，重命名ESRI为ESRI_1?
（3）更新计算机硬件驱动程序 2. 获取许可慢，可能是因为许可服务器和本机的通讯比较慢（哪怕许可服务器是本机也可能会出现这个问题），可以尝试把许可借入到本地来解决问题。 3. 如果是整体比较慢还可能是因为您的计算机软硬件环境和arcmap软件系统要求不合，查看： http://desktop.arcgis.com/zh-cn/arcmap/latest/get-started/setup/arcgis-desktop-system-requirements.htm 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339fc48921d0fad84624fca7820af65e/" rel="bookmark">
			你需要来自XXX的权限才能对此文件夹进行更改 win10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 10 删除文件夹出现问题： 你需要来自XXX的权限才能对此文件夹进行更改
你需要来自SYSTEM的权限才能对此文件夹进行更改
解决流程： 右击打开此文件夹属性，如下图，点击高级按钮
出现下图，点击更改：
继续，在输入框中输入 e，右击按钮 检查名称 出现下图，并确认
勾选替换子容器和对象的所有者，应用并确认：
重新打开该文件夹属性，并选择高级
添加：
选择主体：
在输入框中输入e，右击按钮检查名称
勾上完全控制，勾上仅将这些权限应用到此容器中的对象和/或容器 并确定：
点击启用继承button，后会变成禁用继承，勾选箭头，应用并确认：
完成！重新点击删除： 成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/042030fb664844dda36da7a97ef5412e/" rel="bookmark">
			几分钟理解 数据结构 - 哈希表及其优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小概 哈希容器也可以理解为是一种映射容器，采用哈希算法（映射算法，散列算法），将不定长的数据压缩成定长的数据，这串定长值我们称为 哈希值，并将不同的哈希值分组存起来，每一个分组我们认为是一个 槽
我们将不同的数据格式通过哈希算法，将其映射到不同的槽内，当我们需要取数据时，把需要的数据转化成哈希值，再凭借哈希值去找对应的槽，然后便可以将数据取出来
可以理解为一个键值对容器
put(key, value)
get(key)
图解如下
并且进行以下设定
$key$ - 键
$h_{key}$ - 哈希值
$hash(key)$ - 哈希算法
$bucket$ - 槽
$bucketNum$ - 槽数
哈希表 我们现在假设 key 为整数，用 数组 分配槽的情况，并开始讨论如何设计，让对这一容器增删改查的时间复杂度趋近于 $O(1)$
哈希算法 映射可以如下表示，下标 $n$ 代表变化的取值
$$(x_n, y_n) -&gt; (x, y)$$
更通常的映射关系如下，并且我们在这里讨论这种情况
$$(x_n, y_n) -&gt; (0, bucketNum - 1)$$
如何将不定长的数据压缩成定长的数据，我们主要给出以下几种常用的方法
线性哈希：$hash(key) = a × key + b $
平方哈希：$hash(key) = sub(key^2, a, b)$，设函数 $sub(num, a, b)$ 代表取 $num$ 第 $a$ 位数到第 $b$ 位数，则
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/042030fb664844dda36da7a97ef5412e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edd85b042eda423bb4ae9ece3822b04e/" rel="bookmark">
			CodeForces - 803C Maximal GCD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maximal GCD You are given positive integer number n. You should create such strictly increasing sequence of k positive numbers a1, a2, …, ak, that their sum is equal to n and greatest common divisor is maximal. Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them. If there is no possible sequence then output -1. Input The first line consists of two numbers n and k (1 ≤ n, k ≤ 1010).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edd85b042eda423bb4ae9ece3822b04e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71239e1f79e63db8cb46f8a77e4458eb/" rel="bookmark">
			CodeForces 803C
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maximal GCD Describtion: You are given positive integer number n. You should create such strictly increasing sequence of k positive numbers a1, a2, …, ak, that their sum is equal to n and greatest common divisor is maximal. Greatest common divisor of sequence is maximum of such numbers that every element of sequence is divisible by them. If there is no possible sequence then output -1.
Input The first line consists of two numbers n and k (1 ≤ n, k ≤ 1010 ).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71239e1f79e63db8cb46f8a77e4458eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c2cf9e717675397527d9189920c6308/" rel="bookmark">
			codeforces 835 C Star sky
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C. Star sky time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output The Cartesian coordinate system is set in the sky. There you can see n stars, the i-th has coordinates (xi, yi), a maximum brightness c, equal for all stars, and an initial brightness si (0 ≤ si ≤ c).
Over time the stars twinkle. At moment 0 the i-th star has brightness si.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c2cf9e717675397527d9189920c6308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4af9b0198bf20fcaca0757c6e37ac8b5/" rel="bookmark">
			A Knight&#39;s Journey (深度搜索&#43;字典序)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A Knight's Journey Time Limit : 2000/1000ms (Java/Other) Memory Limit : 131072/65536K (Java/Other) Total Submission(s) : 125 Accepted Submission(s) : 26 Problem Description Background The knight is getting bored of seeing the same black and white squares again and again and has decided to make a journey around the world. Whenever a knight moves, it is two squares in one direction and one square perpendicular to this. The world of a knight is the chessboard he is living on.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4af9b0198bf20fcaca0757c6e37ac8b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f204088888d658e9e0dbe18fc4b339ee/" rel="bookmark">
			Codeforces 835C - Star sky  【预处理前缀和】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C. Star sky time limit per test 2seconds memory limit per test 256megabytes The Cartesian coordinate system is set in the sky. There you canseen stars, the i-th has coordinates (xi,yi), a maximum brightness c, equal for all stars, and an initialbrightness si (0 ≤ si ≤ c).
Over time the stars twinkle. At moment0 the i-th star has brightness si. Let at moment t some star has brightness x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f204088888d658e9e0dbe18fc4b339ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5f2cb2290700a55e12984342b84069f/" rel="bookmark">
			服务器修改主机名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前修改主机名的方式有两种： 1.使用hostname newname 这种方式属于一次性修改，修改之后立即生效，但是系统重启后，配置就会失效了
2.修改/etc/sysconfig/network文件将HOSTNAME等号右边改成新的主机名。这种方法系统重启后仍然有效。
但是目前使用的centos7系统中 有新的命令可以使用 hostnamectl set-hostname newname设置新的主机名 hostnamectl –static set-hostname newname设置静态名字 使用该指令后即可对主机名进行修改，重启后仍然有效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00add077a02858f1534ad3e1577cf83/" rel="bookmark">
			Properties类的用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、properties文件 Properties文件是java中很常用的一种配置文件，文件后缀为“.properties”，属文本文件，文件的内容格式是“键=值”的格式，可以用“#”作为注释，java编程中用到的地方很多，运用配置文件，可以便于java深层次的解耦。例如java应用通过JDBC连接数据库时，通常需要在代码中写数据库连接字符串，下面贴出java通过JDBC连接数据库的代码（以mysql为例）：
String driver="com.mysql.jdbc.Driver";//mysql提供的Driver接口的实现类 String jdbcUrl="jdbc:mysql:///user";//此处为"jdbc:mysql://localhost:3306/user"的简化形式，user为数据库名 String user="root"; String password="451535"; Class.forName(driver);//通过反射动态实例化mysql数据库驱动类 Connection conn= DriverManager.getConnection(jdbcUrl,user,password); 以上代码连接mysql数据库没有任何问题，但是我想换成Oracle数据库，问题就来了，不是不能改，而是我必须得到java源代码中修改代码，这样的硬代码耦合在java中一般不这么做（菜鸟程序员有可能）。所以，为了达到解耦的目的，我们可以用配置文件来储存数据库的连接字符串。下面贴一份保存数据库连接字符串的properties配置文件 jdbc.properties： driver=com.mysql.jdbc.Driver jdbcUrl=jdbc:mysql://localhost:3306/user user=root password=451535 这样我们就可以通过加载properties配置文件来连接数据库，达到深层次的解耦目的，如果想要换成oracle或是DB2，我们只需要修改配置文件即可，不用修改任何代码就可以更换数据库。 二、Properties类 java中提供了配置文件的操作类Properties类（java.util.Properties）： public class Properties extends Hashtable.可见Properties类继承了Hashtable，而HashTable又实现了Map接口，所以可对 Properties 对象应用 put 和 putAll 方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是 String 的项。相反，应该使用 setProperty 方法。如果在“不安全”的 Properties 对象（即包含非 String 的键或值）上调用 store 或 save 方法，则该调用将失败。
Properties的常用方法： 1.setProperty(String key, String value) 调用 Hashtable 的方法 put。 2. getProperty(String key) 用指定的键在此属性列表中搜索属性 3. getProperty(String key, String defaultValue) 用指定的键在属性列表中搜索属性。 4. load(InputStream inStream) 从输入流中读取属性列表（键和元素对）。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00add077a02858f1534ad3e1577cf83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b860c4d6294c1e1481ba7e32bed5dc5/" rel="bookmark">
			申请免费SSL证书及相关配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 申请地址：https://www.sslforfree.com/ 1、打开申请地址，输入要申请的域名，输入完之后点击 右侧的"Create Free SSL Certificate"按钮 2、选择中间的 “Manual Verification”（手动验证）并验证域名（Manual Verify Domain） 3、 下载下图中第一步的两个文件（也可能是一个，如果是一级域名的话，www和不带www各一个文件，二级域名是一个文件）上传到服务器 www.xxx.com/.well-known/acme-challenge/目录下(如果.well-known/acme-challenge不存在需要手动创建， 注意.well-known之前有个“.”)，上传完之后保证上传的文件能够在浏览器地址栏里能够访问到，可通过第五步的连接进行测试 友情提示：默认情况下，nginx是不允许访问网站根目录下的隐藏文件的，配置SSL时可将nginx配置文件中的访问限制先取注释掉 # location ~ /\. # { # deny all; # } 4、如果验证文件能够正常访问，则可以进行下一步，下载证书文件，下载的证书文件是一个压缩包，里面包含三个文件:ca_bundle.crt、priate.key和certificate.crt; 将ca_bundle.crt的内容复制到 certificate.crt中，然后将certificate.crt和private.key上传到服务器当中,（我上传到了/usr/local/nginx/conf/ssl/vmerchant目录下） 5、配置nginx以支持HTTPS,重启nginx ,搞定 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/912e0108115deabd038f9541842f5d7f/" rel="bookmark">
			java 3年经验面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鉴于本人能力，面试官提出的问题，各位大神勿喷。
1、RBAC权限管理 ：答案可百度。
2、StringBuffer与StringBuilder的区别：线程安全是区别的重点。
3、索引失效问的比较多：数据量大的时候必备。
4、零星问题：http状态码。
5、自由发挥：考验处理问题的能力和经验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfc42ce80a5b142c1c684daf5bb8ad34/" rel="bookmark">
			git 提交代码remote: error:updating the current branch in a non-bare repository  is denied
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 开发机提交代码到远程仓库时，出错如下错误：
$ git push origin master Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 267 bytes | 0 bytes/s, done. Total 3 (delta 1), reused 0 (delta 0) remote: error: refusing to update checked out branch: refs/heads/master remote: error: By default, updating the current branch in a non-bare repository remote: error: is denied, because it will make the index and work tree inconsistent remote: error: with what you pushed, and will require 'git reset --hard' to match remote: error: the work tree to HEAD.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfc42ce80a5b142c1c684daf5bb8ad34/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/528/">«</a>
	<span class="pagination__item pagination__item--current">529/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/530/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>