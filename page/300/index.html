<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c480e79a6aa7d98bb78012db3567241/" rel="bookmark">
			基于 Flask 的 RESTful API 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：
本文章只是一个蒟蒻的一个小尝试，存在很多问题，请谨慎观看，欢迎批评指正！
0x01 接口文档 使用 showdoc 实现：https://www.showdoc.com.cn/marx
0x02 项目结构 0x03 初始化项目 __init__.py from flask import Flask from flask_restful import Api from flask_sqlalchemy import SQLAlchemy print("████████╗ ██████╗ ██████╗ ██████╗ ") print("╚══██╔══╝ ██╔═══██╗ ██╔══██╗ ██╔═══██╗") print(" ██║ ██║ ██║ ██║ ██║ ██║ ██║") print(" ██║ ██║ ██║ ██║ ██║ ██║ ██║") print(" ██║ ╚██████╔╝ ██████╔╝ ╚██████╔╝") print(" ╚═╝ ╚═════╝ ╚═════╝ ╚═════╝ ") app = Flask(__name__) # 创建程序实例 app.config.from_pyfile('config.py') # 导入配置 api = Api(app) db = SQLAlchemy(app) # 实例化SQLAlchemy类，传入程序实例app， from todo_api import views, models, commands, config # 这些模块也需要导入程序实例，为了避免循环依赖，导入语句在末尾定义 0x04 视图函数 viwes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c480e79a6aa7d98bb78012db3567241/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28bbf5e4b67c24cd6153a8b719c2fe8/" rel="bookmark">
			编程基础小知识之 List（列表）和 tuple（元组），学会就能一定程度上偷懒啦~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前我们学习了字符串，整数，浮点数几种基本数据类型，
现在我们接着学习两种新的数据类型，列表（List）和元组（tuple）。
一、List（列表） 1、什么是 List （列表） List （列表）是 Python 内置的一种数据类型。 它是一种有序的集合，可以随时添加和删除其中的元
素。
那为什么要有 List （列表）呢？
我们用一个例子来说明。
现在有一个团队要出去玩，要先报名。如果用我们之前学过的知识，那么就是用一个字符串变量把他们
都记录起来。
但是这样太麻烦了，而且也不美观。
在编程中，一定要学会偷懒，避免「重复性工作」。如果有一百个成员，那么你及时是复制粘贴，也会
把你写烦。
这时候就可以使用列表了。
就这样，一行代码就可以存放 N 多个名字了。
2、怎么创建 List（列表） 从上面的例子可以分析出，列表的格式是这样的。
其实列表就是用中括号 [] 括起来的数据，里面的每一个数据就叫做元素。每个元素之间使用逗号分
隔。
而且列表的数据元素不一定是相同的数据类型。
比如：
list1=['两点水','twowter','liangdianshui',123] 这里有字符串类型，还有整数类型。
我们尝试把他打印出来，看看打印的结果是怎样的。
3、如何访问 List（列表）中的值 就像一开始的例子，我们有时候不需要把全部人员的姓名都打印出来，有时候我们需要知道第 3 个报名
的人是谁？前两名报名的是谁？
那么怎么从列表中取出来呢？
换种问法就是，怎么去访问列表中的值？
这时候我们可以通过列表的下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符。
例如：
name = ['一点水', '两点水', '三点水', '四点水', '五点水'] # 通过索引来访问列表 print(name[2]) # 通过方括号的形式来截取列表中的数据 print(name[0:2]) 可见，我们需要知道知道 name 这个列表中第三个报名的是谁？只需要用 name[2] 就可以了。
这里你会问，为什么是 2 ，不是 3 呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c28bbf5e4b67c24cd6153a8b719c2fe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/963e850a3beb836d323f2f3332fe2c48/" rel="bookmark">
			C语言break/continue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		break: 1.break不能用于循环语句和 switch 语句之外的任何其他语句中。
2.不管是 for 循环，还是 while 循环，或者是 do…while 循环，都可以用 break 跳出来，但是 break 只能跳出一层循环。当有多层循环嵌套的时候，break只能跳出“包裹”它的最里面的那一层循环，无法一次跳出所有循环。
continue: continue 的用法十分简单，其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，然后进行下一次是否执行循环的判定。
备注： 1.break 语句只能在循环或开关中使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d8249824d11f0c2e98062e0131d5d7/" rel="bookmark">
			工业互联网（十四）——相机标定（Camera calibration）原理、步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载： 最详细、最完整的相机标定讲解
图像处理——相机标定（Camera calibration）
相机标定
相机标定（Camera calibration）原理、步骤
工业相机标定相关知识整理
相机标定——标定图片拍摄规范
相机标定中部分疑问和注意事项
张正友相机标定Opencv实现以及标定流程&amp;&amp;标定结果评价&amp;&amp;图像矫正流程解析（附标定程序和棋盘图）
世界坐标与像素坐标的相互转换
张正友相机标定程序实现
单目相机提高标定精度的经验(转载)
计算机视觉：相机成像原理：世界坐标系、相机坐标系、图像坐标系、像素坐标系之间的转换(转载)
内参、外参、畸变参数三种参数与相机的标定方法与相机坐标系的理解
计算机视觉-相机内参数和外参数
相机标定(Camera calibration)
相机参数标定（camera calibration）及标定结果如何使用(转载)
1.为什么要相机标定？ 在图像测量过程以及机器视觉应用中，为确定空间物体表面某点的三维几何位置与其在图像中对应点之间的相互关系，必须建立相机成像的几何模型，这些几何模型参数就是相机参数。
【1】进行摄像机标定的目的：求出相机的内、外参数，以及畸变参数。
【2】标定相机后通常是想做两件事：一个是由于每个镜头的畸变程度各不相同，通过相机标定可以校正这种镜头畸变矫正畸变，生成矫正后的图像；另一个是根据获得的图像重构三维场景。
摄像机标定过程，简单的可以简单的描述为通过标定板，如下图，可以得到n个对应的世界坐标三维点Xi和对应的图像坐标二维点xi，这些三维点到二维点的转换都可以通过上面提到的相机内参K ，相机外参 R 和t，以及畸变参数 D ，经过一系列的矩阵变换得到。
2.什么叫相机标定？ 在大多数条件下这些参数必须通过实验与计算才能得到，这个求解参数的过程就称之为相机标定（或摄像机标定）
3.为什么相机标定很重要？ 无论是在图像测量或者机器视觉应用中，相机参数的标定都是非常关键的环节，其标定结果的精度及算法的稳定性直接影响相机工作产生结果的准确性。因此，做好相机标定是做好后续工作的前提，提高标定精度是科研工作的重点所在。
4.相机标定方法有哪些？ 相机标定方法有：传统相机标定法、主动视觉相机标定方法、相机自标定法。
传统相机标定法需要使用尺寸已知的标定物，通过建立标定物上坐标已知的点与其图像点之间的对应，利用一定的算法获得相机模型的内外参数。根据标定物的不同可分为三维标定物和平面型标定物。三维标定物可由单幅图像进行标定，标定精度较高，但高精密三维标定物的加工和维护较困难。平面型标定物比三维标定物制作简单，精度易保证，但标定时必须采用两幅或两幅以上的图像。传统相机标定法在标定过程中始终需要标定物，且标定物的制作精度会影响标定结果。同时有些场合不适合放置标定物也限制了传统相机标定法的应用。
目前出现的自标定算法中主要是利用相机运动的约束。相机的运动约束条件太强，因此使得其在实际中并不实用。利用场景约束主要是利用场景中的一些平行或者正交的信息。其中空间平行线在相机图像平面上的交点被称为消失点，它是射影几何中一个非常重要的特征，所以很多学者研究了基于消失点的相机自标定方法。自标定方法灵活性强，可对相机进行在线定标。但由于它是基于绝对二次曲线或曲面的方法，其算法鲁棒性差。
基于主动视觉的相机标定法是指已知相机的某些运动信息对相机进行标定。该方法不需要标定物，但需要控制相机做某些特殊运动，利用这种运动的特殊性可以计算出相机内部参数。基于主动视觉的相机标定法的优点是算法简单，往往能够获得线性解，故鲁棒性较高，缺点是系统的成本高、实验设备昂贵、实验条件要求高，而且不适合于运动参数未知或无法控制的场合。
5、常用术语 内参矩阵: Intrinsic Matrix
焦距: Focal Length
主点: Principal Point
径向畸变: Radial Distortion
切向畸变: Tangential Distortion
旋转矩阵: Rotation Matrices
平移向量: Translation Vectors
平均重投影误差: Mean Reprojection Error
重投影误差: Reprojection Errors
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8d8249824d11f0c2e98062e0131d5d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b51c733315c48cc81b80b5a3f82ea48/" rel="bookmark">
			初识API网关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网关是什么 百度百科：网关(Gateway)又称网间连接器、协议转换器，在网络层以上实现，连接两个或者多个广域网或者局域网。
我们这里说的是API网关，指的是所有api调用的统一入口。
api网关的在架构中的位置，如下图
​ 图1
为什么需要网关 随着微服务的增多，如果跟之前一样还是客户端直接对接不同的微服务，会有很多不便：
客户端多次请求不同的服务，增加了客户端的复杂性可能存在跨域问题每个服务都需要独立身份认证随着项目的发展，将难以重构 网关的功能 安全防护
防刷，黑白名单 协议适配
封闭内部不同的协议实现，对外提供统一的协议 流量监控和容错
限流，降级，熔断 统一接入
统一认证鉴权统一限流避免新增服务还需要新分配域名，配置nginx，服务拆分还需要客户端配合改造。 其他：日志，缓存（幂等接口的缓存）
常见的网关实现 zuul 基于web servlet，核心是一系列的filtres，无缝集成hystrix，zuul1是单线程接收转发处理，阻塞IO，不支持长连接。目前已有zuul2.
kong 本质基于nginx+lua（略）
traefik go语言开发，目前比较适合k8s。
gateway 组成部分：
路由：最基础部分，唯一的ID对应的目的URL，包含若干断言和过滤器。断言：根据配置的路由规则，对http request进行断言匹配。（if else）过滤器：对请求和响应进行修改。 工作原理：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-KvGkzEjz-1644834368139)(images/image-20210606214157231.png)]
​ 客户端向Spring Cloud Gateway发出请求。如果gateway handler mapping确定了一个请求与路由匹配，它将被发送到gateway Web handler。过滤器被虚线分隔的原因是，过滤器可以在发送代理请求之前和之后运行逻辑。执行所有的“pre”过滤逻辑。然后发出代理请求。代理请求发出后，将运行“post”筛选逻辑。
servicemesh 去中心化的方案（略）
怎么使用网关 以spring cloud gateway为例
路由规则 路由规则 datetime after before between Cookie Header Host Method Path Query RemoteAddr weight Path
spring: cloud: gateway: routes: - id: baidu_ # 路由ID唯一 uri: http://baidu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b51c733315c48cc81b80b5a3f82ea48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffb8311c8171256cc36dcfd70770daae/" rel="bookmark">
			手把手教你使用HAL库开发入门——成为点灯大师
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言基础知识时钟GPIO的输入输出模式 CubeMX配置Keil编程实验现象 前言 非常感谢百问网黄老师的授课和解答，非常推荐同学们上百问网学习嵌入式知识
百问网官网
基础知识 时钟 HSI：内部高速时钟LSI：内部低速时钟HSE：外部高速时钟LSE：外部低速时钟 因为内部的时钟容易受芯片温度的影响，所以精准度不太好。所以一般采用使用外部是时钟。
GPIO的输入输出模式 推挽输出：
推挽结构由两个MOS管按互补对称的方式连接，任意时刻总是其中一个三极管导通，另一个三极管截止。如 ①所示，内部由一个P-MOS管和一个N-MOS管组成，两个MOS管的栅极（ Gate， G）接到
了左侧“输出控制” ，漏极（ Drain， D）接到外部输出， P-MOS管的源极（ Source， S）接到VDD（ 3.3V），N-MOS管的源极接到Vss（ 0V）。
MOS管作为开关使用，“输出控制”向两个MOS管栅极加一定电压， P-MOS管源极和漏极之间导通，VDD 经过P-MOS管的S-&gt;G-&gt;D输出， N-MOS管处于高阻态（电阻很大，近似开路），整体对外为高电平；“输出控制”取消向两个MOS管栅极施加电压， P-MOS管源极和栅极截止，P-MOS管处于高阻态， N-MOS管源极和漏极导通，整体对外为低电平。
推挽模式，让“输出控制”变为了VDD/Vss输出，使得输出电流增大，提高了输出引脚的驱动能力，提高
了电路的负载能力和开关的动作速度。
开漏输出
开漏模式下，“输出控制”不会控制P-MOS管， “输出控制”只会向N-MOS管栅极加一定电压， 两个
MOS管都处于截止状态，两个漏极处于悬空状态，称之为漏极开路。“输出控制”取消栅极的施加电压， PMOS管依旧处于高阻态， N-MOS管导通，整体对外为低电平。
复用推挽输出/复用开漏输出
GPIO引脚除了作为通用输入/输出引脚使用外，还可以作为片上外设（ USART、 I2C、 SPI等）专用引脚，即一个引脚可以有多种用途，但同一时刻一个引脚只能使用复用功能中的一个。
当引脚设置为复用功能时，可选择复用推挽输出模式或复用开漏输出模式，在设置为复用开漏输出模式
时，需要外接上拉电阻。
上拉输入
如②所示， VDD经过开关、上拉电阻，连接外部I/O引脚。当开关闭合， 外部I/O无输入信号时，默认输入高电平。
该模式的典型应用就是外接按键，当没有按键按下时候， MCU的引脚为确定的高电平，当按键按下时候，引脚电平被拉为低电平。
下拉输入
如②所示， Vss经过开关、下拉电阻，连接外部I/O引脚。当开关闭合，外部I/O无输入信号时，默认输入低电平。
浮空输入
如②所示，两个上/下拉电阻开关均断开，既无上拉也无下拉， I/O引脚直接连接TTL肖特基触发器，此时I/O引脚浮空，读取的电平是不确定的，外部信号是什么电平， MCU引脚就输入什么电平。 MCU
复位上电后，默认为浮空输入模式。
模拟输入
如②所示，两个上/下拉电阻开关均断开，同时TTL肖特基触发器开关也断开，引脚信号直接连接模拟输入，实现对外部信号的采集。
CubeMX配置 第一步，设置时钟
第二步，配置GPIO引脚
首先查看原理图，找到LED和按键
Keil编程 主程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffb8311c8171256cc36dcfd70770daae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c762b7dacd0da5adb2c76e4dd57d48/" rel="bookmark">
			只有CSDN记录了自己在网上真实的码龄
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想起许久（好几年）没登录过的CSDN账号，登录了一下，看到头像边上标记着：22年码龄。还真是，刚用注册CSDN的时候，就是2000年那阵。那时候还没别的什么基于web的技术社区，除了大学的BBS。
顺便祝CSDN Live long and prosper!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d03d8dfa863ec97083089e1c21ab217c/" rel="bookmark">
			java.lang.IllegalStateException: Failed to introspect Class报错原因和解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个报错其实就是没有找到要加载的类，一般在启动的时候报错。
加载不到的类有两种情况，一种是直接找不到要加载的依赖包，或者添加了依赖包后没有加载进入，需要看看是不是 maven 的设置问题，重新刷新加载一下 maven 的依赖，或者清一下 idea 的缓存；另外一种是导入了依赖包，但是依赖包中又引入了其他的依赖包中的类，这个类找不到，我遇到的就是这个场景，之前开发中要用到公司开发的依赖包，但是该依赖包又要引入某个类，这个类其实引入后没有用到，但是启动项目的时候还是会报这个错误，所以要么去掉这个类，要么仍旧引入有这个类的包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f271d7951fd6074bb7c4168086cf67c/" rel="bookmark">
			结构光三维重建-3D Scanning Software实现三维重建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结构光三维重建-3D Scanning Software实现三维重建 目录
结构光三维重建-3D Scanning Software三维重建
1. 说明
2.Requirements
（1）下载相关文件
（2）3D Scanning Software源码编译
3. Data capture
（1）运行程序：scan3d-capture
（2）采集校准图片：Capture calibration images
（3） 进行校准：Calibration
4. 扫描模型：Model Scanning 5.可视化3D点云
1. 说明 布朗大学开源了一套投影仪摄像机标定系统(Projector-Camera Calibration/3D Scanning Software) ，该软件可以使用数据投影仪和摄像机来扫描3D物体，增加了投影和灰度代码模式的捕获，以及点云重建功能。
官网地址： Projector-Camera Calibration / 3D Scanning Software
2.Requirements 官网搭建了一个简易的结构光系统：一个Optoma PK301微型投影仪+QuickCam Pro 9000一个网络摄像头，该软件中的拍摄模块应该与大多数USB网络摄像头工作，但如果您的摄像头不支持，可以使用外部工具捕获图像，然后也可以从文件夹中读取。
官网提供了Window和Apple OSX编译好的标定软件，很不幸的是，版本比较老旧，仅支持Windows 7 x64，Opencv也是比较老旧的OpenCV 2.4.11,没有提供Linux版本的,如你想在Ubuntu成功运行还是要采坑的。
（1）下载相关文件 把下面的内容都下载下来，并解压，后面需要用到
（2）3D Scanning Software源码编译 在Ubuntu18.04源码编译，请移步鄙人的另一篇博客《结构光相机标定-3D Scanning Software源码编译》：
https://panjinquan.blog.csdn.net/article/details/121093639https://panjinquan.blog.csdn.net/article/details/121093639
3. Data capture （1）运行程序：scan3d-capture 完成3D Scanning Software源码编译后，在 bin目录下，可以找到一个可执行文件：scan3d-capture
运行他即可：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f271d7951fd6074bb7c4168086cf67c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203e94e58907735fc3d252df2164f876/" rel="bookmark">
			word按标题自动生成序号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		word按标题自动生成序号@TOC
1、按标题色设置文档格式；
2、导航显示，是在“视图”导航窗体上面显示；
3、选择自动生成序号的格式；
4、选中后，自动可自动自动添加序号；
5、设置序号生成规则；可点击“自定义的多级列表”
6、按单级别标签设置word，调整缩进位置，级别样式等；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0c0637aab2dac4632521489d098c9a7/" rel="bookmark">
			vue的data为什么是一个函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue在不同的情况下的作用： 1. 根实例对象data可以是对象也可以是函数（根实例是单例)，不会造成数据冲突问题
2. 如果不是一个函数，而组件实例的data都是同一个引用数据，当该组件作为公共组件共享使用，如果它是一个对象，会报错，并且一个地方的data更改，所有的data一起改变，相反，如果data是一个函数，每个实例的data都在闭包中，就不会各自影响了。
vue根实例中的data
const app = new Vue({ el:"#app", // 对象格式 data:{ foo:"foo" }, // 函数格式 data(){ return { foo:"foo" } } 组件实例中的data
Vue.component('component1',{ template:`&lt;div&gt;组件&lt;/div&gt;`, data:{ foo:"foo" } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33603473a70c5877a3387fef5b46f417/" rel="bookmark">
			WebRTC M96 Release Notes(SDP废除Plan B，支持Opus Red冗余编码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://groups.google.com/g/discuss-webrtc/c/Bp8OzBzipSc
切换到M96分支 git checkout branch-heads/4664 PSAs Plan B和Unified Plan Plan B是Chrome/Chromium独有的实现，Safari和Firefox一直支持Unified Plan，Chrome在M72已经支持Unified Plan。从某种程度上说如果后续再开发WebRTC可以不考虑Plan B的支持了，因为Unified Plan的支持已经非常好。
Plan B和Unified Plan各有优劣，在只有一路音频和视频的时候这两种方案并没有什么区别，在多路音视频的时候Unified Plan每一路音视频都会有一个Mline，这样就提供了很大的灵活性，可以针对每一路音视频协商不同的能力，比如我们有一路摄像头和一个屏幕共享，就可以让屏幕共享使用av1编码，而摄像头使用h264。作为多年跟SDP打交道的开发者不得不说SDP Sucks，SDP真的是一个很糟糕的设计，它是一个标准但又是一个相对灵活的标准，每家的实现可能又不一样，不得不花费很多精力进行SDP的适配，如果你还有没有被SDP的适配困扰过某种意义上你可能还没有完全了解WebRTC。但标准一旦确立，别人撼动它也很难，微软曾经搞出来ORTC标准来屏蔽SDP的协商问题，最终也还是失败了。
用于 SCTP 传输的 DcSCTP 库 SCTP（Stream Control Transmission Protocol，流控制传输协议） RFC 4960
它是一种传输协议，默认使用5000端口，在TCP/IP协议栈中所处的位置和TCP、UDP类似，同时具备TCP和UDP的特征。
DcSCTP library for the SCTP transport used by WebRTC’s Data Channels
Connection oriented. Similar to TCP, SCTP is connection oriented. It also offers a multi-homing capability that isn’t used by WebRTC Optional reliability. Reliability is optional in SCTP and is up to the implementer using SCTP to decide if he needs this capability or not Optional ordering.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33603473a70c5877a3387fef5b46f417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cafeac4ad70e7de340aa64f6f1a71df2/" rel="bookmark">
			【CSDN】文章撰写方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
检查列表：Ctrl/Command + Shift + C
插入代码：Ctrl/Command + Shift + K
插入链接：Ctrl/Command + Shift + L
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cafeac4ad70e7de340aa64f6f1a71df2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c660de6176344c939a55f3f172ed6d4c/" rel="bookmark">
			一篇文章搞懂 HBase 的内部原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文隶属于专栏《1000个问题搞定大数据技术体系》，该专栏为笔者原创，引用请注明来源，不足和错误之处请在评论区帮忙指出，谢谢！
本专栏目录结构和参考文献请见1000个问题搞定大数据技术体系
正文 HBase 是构建在 HDFS 之上的，它利用 HDFS 可靠地存储数据文件，其内部则包含 Region 定位、读写流程管理和文件管理等实现，本文从以下几个方面剖析 HBase 内部原理。
1 . Region 定位 HBase 支持 put ， get ， delete 和 scan 等基础操作，所有这些操作的基础是 region 定位。
给定一个 rowkey 或 rowkey 区间，如何获取 rowkey 所在的 RegionServer 地址？
region 定位基本步骤如下: 客户端与 ZooKeeper 交互，查找 hbase:meta 系统表所在的 Regionserver ， hbase:meta 表维护了每个用户表中 rowkey 区间与 Region 存放位置的映射关系，具体如下:
rowkey : table name , start key , region id
value : RegionServer 对象(保存了 RegionServer 位置信息等)客户端与 hbase:meta 系统表所在 RegionServer 交互，获取 rowley 所在的 RegionServer客户端与 rowkey 所在的 RegionServer 交互，执行该 rowkey 相关操作。 需要注意的是，客户端首次执行读写操作时才需要定位 hbase:meta 表的位置，之后会
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c660de6176344c939a55f3f172ed6d4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3294afb518dcd6c15aea0c9a1e95bbff/" rel="bookmark">
			c语言基本语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c语言基本语法 1. 语句 c语言的代码由一行行语句组成，语句就是程序执行的命令。c语言规定每条语句必须以分号[^;]结尾，除有明确规定可以不写分号。
int x = 1; 上面就是声明了一个变量，这个变量为x，并把它的初始值设为1。
多个语句也可以写在一行。
int x; x = 1; 一条语句也可以分为多行，这时就要依靠分号来判断语句在哪一行结束。
int x = 1 ; 但是为了代码的可读性以及整洁性不建议这样写（特殊情况除外）
2. 表达式 c语言的各种计算，主要通过表达式完成，表达式是一个计算式，用来获取值。
1 + 1 上面就是一个表达式，用来获取1 + 1的计算结果，表达式也可以加上分号成为一条语句，但是没有什么实际意义。
表达式与语句的主要区别：
语句可以包含表达式，但是表达式本身不构成语句。
表达式都有返回值，语句不一定有。因为语句用来执行某个命令，很多时候不需要返回值，比如变量声明语句（int x = 1）就没有返回值。
3. 语句块 c语言支持多条语句使用一对大括号[^{}],组成一个块，也叫复合语句。
{ int x; x = 1; } 上面就是一个语句块的示例。
注意语句块大括号的后面不需要加分号。
4. 空格 c语言里的空格主要是帮助编译器区分语法单位，如果语法单位不需要添加空格也能区分，空格就不是必须的，只是为了增加代码的可读性。
int x = 1; //等同于 int x=1; 示例中赋值符号‘=’前后有没有空格都可以，因为编译器在这里不通过空格也能区分语法单位
语法之间也可以有多个空格
int x = 1; 语法之间多个空格等同于一个空格，和单个空格效果一样。
空格还用来表示缩进。多层级的代码有没有缩进，其实对于编译器来说并没有差别，没有缩进的代码也是完全可以运行的。强调代码缩进，只是为了增强代码可读性，便于区分代码块
int main(void){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3294afb518dcd6c15aea0c9a1e95bbff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46d531b2714fc5c9dbeff0633f7a8577/" rel="bookmark">
			LearnOpenGL 笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概述
OpenGL到底是什么
核心模式与立即渲染模式
扩展
状态机
二、窗口
视口
渲染循环(Render Loop)
输入
渲染
三、三角形
图形渲染管线
顶点输入
顶点着色器
片段着色器
链接顶点属性
顶点数组对象
索引缓冲对象
四、着色器
数据类型
输入与输出
Uniform
更多属性
从文件读取
五、纹理
纹理环绕方式
纹理过滤
多级渐远纹理Mipmap
加载与创建纹理
应用纹理
纹理单元
六、变换
向量
矩阵
七、坐标系统
正射投影
透视投影
3D
Z缓冲Z-buffer
八、摄像机
摄像机位置
摄像机方向
Look At
自由移动
视角移动-加入鼠标
缩放
词汇表
一、概述 OpenGL到底是什么 一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。
OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。实际的OpenGL库的开发者通常是显卡的生产商。
OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。
核心模式与立即渲染模式 早期的OpenGL使用立即渲染模式，OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。
教程面向OpenGL3.3的核心模式。
扩展 OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。
状态机 OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。
二、窗口 int main() { glfwInit();//初始化 glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //glfwWindowHint函数的第一个参数代表选项的名称，我们可以从很多以GLFW_开头的枚举值中选择；第二个参数接受一个整型，用来设置这个选项的值。 GLFWwindow* window = glfwCreateWindow(800, 600, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46d531b2714fc5c9dbeff0633f7a8577/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9179ac99a41b5374c032f3f0f1855574/" rel="bookmark">
			Linux pgrep命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 pgrep pgrep是一个根据名称查找进程ID的命令，返回的是进程ID，若存在当个进程，则分为不同的行返回ID（默认实现）。
2 示例 查找java进程：
pgrep java 上图还显示了ps与pgrep的区别，简单来说：
pgrep name 等价于 ps -e | grep name | awk '{print $1}' 3 常用参数 -l：显示PID和进程名称-a：显示详细信息-c：计算进程数量-n/-o：显示进程号最大与最小的进程 4 与其他命令配合 一般pgrep需要和其他命令配合使用，最常见的是kill：
pgrep name | xargs kill -15 注意需要使用xargs传递参数，而不能只使用管道，这样是话会提示not enough arguments：
pgrep name | kill -15 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafa483caf5ac5522522ee70b29ace52/" rel="bookmark">
			CAXA2020复制粘贴时卡顿或卡死
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：当使用卡萨绘图时内容过多，使用命令复制粘贴时，就会卡顿或者是软件无响应。这个问题出现频率很高！
问题解决：经互联网搜索发现，有多人出现这种情况，其中，在百度经验中得到了解决。是因为卡萨软件与WINDOWS输入法冲突，安装其他输入法，如搜狗输入法后，这个问题就没有了，记得把默认输入法也删除掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e88a2a77cfd11ba04f9b0773c6d2b54/" rel="bookmark">
			【mysql】limit实现分页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 分页1. 背景：2. 实现规则3. 拓展4. 练习 分页 1. 背景： 背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？
背景2：表里有 4 条数据，如果只想要显示第 2、3 条数据怎么办呢？
2. 实现规则 分页原理
所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。
MySQL中使用 LIMIT 实现分页
格式：
LIMIT [位置偏移量,] 行数 第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。
举例
--前10条记录： SELECT * FROM 表名 LIMIT 0,10; 或者 SELECT * FROM 表名 LIMIT 10; --第11至20条记录： SELECT * FROM 表名 LIMIT 10,10; --第21至30条记录： SELECT * FROM 表名 LIMIT 20,10; 使用limit实现数据的分页显示
需求1：每页显示5条记录，此时显示第1页
SELECT employee_id,last_name FROM employees LIMIT 0,5; 需求2：每页显示6条记录，此时显示第2页 SELECT employee_id,last_name FROM employees LIMIT 5,6; 需求3：每页显示7条记录，此时显示第3页 SELECT employee_id,last_name FROM employees LIMIT 6,7; 需求4：每页显示pageSize条记录，此时显示第pageNo页：公式： LIMIT (pageNo-1) * pageSize, pageSize; 分页显式公式：（当前页数-1）* 每页条数，每页条数 SELECT * FROM table LIMIT(PageNo - 1)*PageSize, PageSize; 注意：LIMIT 子句必须放在整个SELECT语句的最后！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e88a2a77cfd11ba04f9b0773c6d2b54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a5694259d5a7b6ee9326cd321da9c64/" rel="bookmark">
			链表：回文链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 https://leetcode-cn.com/problems/aMhZSa/
判断链表是否为回文链表。
解题思路 根据回文特性，从字符串正反两边读起，得到的字符内容都是相等的。
由于链表的单向性，我们查找一个元素，需要通过从头遍历到末尾找到。
这里我们可以通过快慢指针，快指针先走两步，到达末尾的时候停止，而慢指针一次走一步，这个时候刚好到达链表中部。中间节点把链表一分为二。把后半段链表反转。判断前后半段的链表是否相等。相等就是回文。 具体代码如下：
代码 /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public boolean isPalindrome(ListNode head) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode slow = dummy; ListNode fast = dummy; while(fast !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a5694259d5a7b6ee9326cd321da9c64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0c60410e8af04e20532f57556d7510/" rel="bookmark">
			vmware克隆虚拟机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		克隆虚拟机
克隆完成之后必须修改ip因为不能相同
输入hostname查看主机名字
vi /etc/hostname 可进入VI编辑模式按I改本机的主机名
修改完成后wq保存退出
再重启虚拟机
修改ip地址
cd etc/sysconfig/network-scripts
vim ifcfg-ens33
192.168.126.123是克隆过来的改成123以外的
按下esc 输入wq保存退出
重启网络
输入vi /etc/hosts 进去VI编辑模式按I添加被克隆的虚拟机的IP地址与克隆后的虚拟机的IP地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a2764b59b85735e24a40a3eaa21d967/" rel="bookmark">
			Java学习路线总结（书籍、视频推荐篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍅 作者简介：CSDN2021博客之星亚军🏆、新星计划导师✌、博客专家💪
🍅 哪吒多年工作总结：Java学习路线总结，搬砖工逆袭Java架构师
🍅 关注公众号【哪吒编程】，回复1024，获取Java学习路线思维导图、大厂面试真题、加入万粉计划交流群、一起学习进步
立志存高远，笃行践初心 三更灯火五更鸡，正是男儿读书时。 黑发不知勤学早，白首方悔读书迟。
立志，标定人生方向；奋斗，创造人生价值，二者相辅相成，互相促进。
大部分程序员的「 目标 」都是成为一名优秀的工程师，一名可以统览全局的「 架构师 」。
千里之行始于足下 对于大部分普通人而言，成为一名优秀的架构师还是有一定难度的，「 千里之行始于足下，一步一个脚印，慢慢来 」。
最近有很多小伙伴问我，正在苦修Java，但是丈二和尚摸不着头脑，知识点繁杂，太迷茫，今天小编在此整理了一份个人的学习方略，分享给大家。
目录
立志存高远，笃行践初心 千里之行始于足下 一、学习方式
二、看书
1、Java核心技术
2、Java编程思想
3、Effective Java
4、深入理解 Java 虚拟机
5、重构 改善既有代码的设计
6、算法4
7、编写高质量代码：改善Java程序的151个建议
8、Java并发编程实战
9、Head First设计模式
10、Java性能权威指南
11、软技能 代码之外的生存指南
12、亿级流量Java高并发与网络编程实战
13、JavaScript高级程序设计
14、温馨提示
二、看视频
三、写博客
四、学习方式总结
一、学习方式 在小编这里学习方式分为以下几种：
看书看视频看官网看博客 在小编看来，学习理念是【先广度后深度】，先把Java知识体系的东西都了解到，工作上先会用，写代码快如闪电，然后再研究原理，争取对代码进行性能优化，进一步进行结构优化。
那么，上面四种学习方式该如何抉择呢？毕竟Java知识体系的东西实在是太多太多，这还不算其它语言，学海无涯苦作舟，书山有路勤为径。
二、看书 在大多数人看来，看书，是学习新知识最好的方法，那么我介绍几本比较经典的书籍吧！
1、Java核心技术 唯一可以和《Java编程思想》媲美的一本Java入门书籍。单从技术的角度来看，前者更好一些。但上升到思想层面嘛，自然后者更好，两者的偏重点不同。
2、Java编程思想 Java第一神作，适合各种阶段的Java程序员（除了小白），相当于武林绝学中的易筋经，我的第二本Java技术书，第一本读了两遍的书，值得反复阅读。
最近已经再出Java编程思想第五版了，小编也应邀编写了书评，并有了先睹为快的机会，写的很好，很与时俱进。
读《Java编程思想第五版》心得体会
3、Effective Java 《Effective Java》第三版一共包含了 90 条极具实用价值的经验规则，每条规则都值得 Java 程序员在实战中去参照。这本书不需要按部就班地从头到尾读，可以随意挑选任意小节进行阅读，因为每条规则相对都是独立的，尽管它们之间会交叉引用，但并不妨碍我们随心所欲地阅读。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a2764b59b85735e24a40a3eaa21d967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0bb9b82c63d8fa66811aa0be67101d/" rel="bookmark">
			如何在 MacOS 安装轻量级虚拟机工具 Multipass
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文介绍如何在 MacOS 中安装并使用 Multipass
下载 官网地址：https://multipass.run
安装 启动 Multipass 1. 点击启动 Multipass 2. 点击 Multipass 的小图标，点击 Open shell 等待 Multipass 获取镜像文件，并安装虚拟机实例
3. 虚拟机安装完成，自动进入虚拟机实例 该虚拟机实例使用的是 Ubuntu 20.04 的系统
常用命令 1. 查看 multipass 当前支持的虚拟机系统版本 multipass find 2. 查看本机安装的虚拟机实例 multipass list 3. 进入虚拟机实例 multipass shell [虚拟机实例的名字] 4. 启动/停止 虚拟机实例 启动
multipass start [虚拟机实例的名字] 停止
multipass stop [虚拟机实例的名字] 5. 创建指定版本的虚拟机实例 multipass launch -n [实例名称] -c [核数] -d [磁盘大小] -m [内存大小] [image 版本] -n 实例名称 -c cpu核数 -m 内存大小 -d 磁盘大小 ## 查看更多安装相关的参数 multipass launch --help 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0bb9b82c63d8fa66811aa0be67101d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a62cfb84401f7be728abed1d7b7d7393/" rel="bookmark">
			基于opencv的小球追踪（颜色追踪）的python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		程序参考：树莓派视觉小车 – 小球追踪（颜色追踪）（OpenCV色彩空间HSV）https://car.inotgo.com/2021/11/20211108230409934Q.html
树莓派算力有限，现在使用手机摄像头充当电脑的无线摄像头，通过手机安装于树莓派小车上实现图像采集，在电脑端进行视觉处理，后期实现计算机控制小车运行实现小球追踪。
效果展示
理论基础
为什么用HSV空间而不是RGB空间？
因为RGB通道并不能很好地反映出物体具体的颜色信息。
而HSV空间能够非常直观的表达色彩的明暗、色调、以及鲜艳程度，方便进行颜色之间的对比。（RGB受光线影响很大，所以采取HSV）
这里用HSV的目的：得到合适的二值图。
Hue：色相（具体的颜色），Value（明度），Saturation（饱和度）程序及介绍 import numpy as np import cv2 def nothing(*arg):#创建回调函数 pass def Trackbar_Init(): # 1 create windows 窗口设置（名称） cv2.namedWindow('h_binary') cv2.namedWindow('s_binary') cv2.namedWindow('v_binary') # 2 Create Trackbar 滑动条设置 cv2.createTrackbar('hmin', 'h_binary', 86, 179, nothing) cv2.createTrackbar('hmax', 'h_binary', 100, 179, nothing) cv2.createTrackbar('smin', 's_binary', 80, 255, nothing) cv2.createTrackbar('smax', 's_binary', 213, 255, nothing) cv2.createTrackbar('vmin', 'v_binary', 180, 255, nothing) cv2.createTrackbar('vmax', 'v_binary', 255, 255, nothing) # 创建滑动条 滑动条值名称 窗口名称 滑动条值 滑动条阈值 回调函数 def Get_HSV(image): # 1 get trackbar's value 获取滑动条的值 hmin = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a62cfb84401f7be728abed1d7b7d7393/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6284ba09d0afd9f71a0063661454c3f1/" rel="bookmark">
			Javaweb之jsp详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Javaweb之jsp详解 1. JSP指令元素 1.1. page指令 page指令是JSP页面中最常用的指令，用来声明JSP页面的属性等信息。一个page指令允许定义多个属性；也可以一个page指令定义一个属性，定义多个page指令。
&lt;!-- 一个page指令,设置多个属性 --&gt; &lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;!-- 一个page指令,设置一个属性.配置多个page指令 --&gt; &lt;%@ page import="java.util.*"%&gt; &lt;%@ page pageEncoding="UTF-8"%&gt; 但是需要注意的是：
page指令设置的属性只能出现一次，除import属性以外。属性名称区分大小写。 page指令允许的属性如下：
属性名称取值范围描述languagejava指明该JSP文件采用的语言。extends任何类的全名指明该JSP文件继承于哪个类。JSP为Servlet，因此当指明继承普通类时需要实现Servlet的init()、destroy()等方法。import任何包名、类名引入该JSP中用到的类、包等。import是唯一可以声明多次的page指令属性。一个import属性可以引用多个类，中间用英文逗号隔开。JSP中下面四个包里的类可以直接使用：java.lang.，javax.servlet.，javax.servlet.jsp.，javax.servlet.http.。sessiontrue，false指明该JSP内是否内置Session对象。如果为true，则内置Session对象，可直接使用。否则不内置Session对象。默认为trueautoFlushtrue，false是否运行缓存。如果为true，则使用out.println()等方法输出的字符串并不是立刻到达服务器端的，而是暂时存在缓存里，缓存满或者程序执行完毕或者执行out.flush()操作时才到客户端。默认为truebuffernone、数字+KB指定缓存大小，当autoFlush设为true时有效，默认值为8KB。isThreadSafetrue，false指定是否线程安全。如果为true，则运行多个线程同时运行该JSP程序，否则只运行一个线程运行，其余线程等待。默认为falseisErrorPagetrue，false指定该页面是否为错误处理页面。如果为true，则该JSP内置Exception对象，可直接使用，否则没有。默认为falseerrorPage某个JSP页面的相对路径指明一个错误显示页面，如果该JSP程序抛出一个未捕捉的异常，则转到errorPage指定的页面。errorPage指定的页面通常isErrorPage属性为true，且内置Exception对象为未捕捉的异常。contentType有效的文档类型客户端浏览器根据该属性判断文档类型。info任意字符串指明该JSP的信息，该信息可以通过Servlet.getServletInfo()方法获取。trimDirective Whitespacestrue，false是否去掉指令前后的空白字符。默认为falseisELIgnoredtrue，false指明当前页面是否忽略EL表达式。默认为false，表示不忽略。 pageEncoding
和
contentType
属性
pageEncoding属性：指明当前JSP页面使用的编码格式。pageEncoding属性的值要与JSP页面的真实编码保持一致，否则会出现乱码。 &lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; contentType属性：在JSP页面编译成Servlet文件时，对应response.setContentType()方法。 pageEncoding属性与contentType属性只设置其中一个属性时，另一个属性的默认与设置的相同。如果两个属性都不设置的话，两个属性的默认值都为“ISO-8859-1”。一般情况下，至少设置其中一个。
errorPage
和
isErrorPage
属性
创建一个JSP页面，编写代码如下： [](javascript:void(0)😉
&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My JSP 'page.jsp' starting page&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6284ba09d0afd9f71a0063661454c3f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4736e22dc7ba36bae33a835382b316ba/" rel="bookmark">
			深入理解裸机与RTOS开发模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言裸机开发模式轮询方式事件驱动方式改进的事件驱动方式常用时间驱动方式：定时器使用状态机进行改进总结 RTOS的引入RTOS编程要注意的问题临界资源的访问任务的休眠唤醒 总结 前言 感谢韦东山老师的直播教学，在今天的这次教学中学到了很多实用的知识。对逻辑开发和RTOS开发有了本质的理解。
博主也在这里向大家推荐一个嵌入式学习网站百问网官网。在这里有所有嵌入式学习的视频，更有韦东山老师的亲自授课为你解答疑惑。
裸机开发模式 所谓裸机开发，指的就是没有操作系统，就是单片机开发。程序的运行，完全取决于代码的逻辑设计，硬件设备的固定设定。不需要操作系统的参与和调度。
这里将韦老师上课举得例子拿来进行分析
讲的是一位宝妈，需要一编进行喂孩子吃饭，一边需要回复同事的消息。
那么我们首先想到的方式就是进行轮询
轮询方式 void main{}{ while(1){ eat();//喂孩子吃饭函数 message();//回复同事消息 } } 这是一个非常经典的单片机程序，是不是就是你的跑马灯程序。那么我们来分析这个程序：
在执行喂孩子这个函数的时候，回复同事消息这个函数是无法执行的，在执行回复同事消息这个函数的时候，程序是无法执行喂孩子这个函数，那么对于同事而言，宝妈总是在一段时间消失，无法回复消息。对于孩子而言，妈妈总是在一段时间无法来喂我吃饭。
双方（同事和孩子）似乎都没有得到满足。显然这个程序是不太好的，那么我们如何来进行优化呢？
相信已经有朋友类比到了我们最初的单片机实验，我们可以使用中断呀！没错中断就是下面我们的优化方式，也叫做事件驱动方式
事件驱动方式 事件是一个宽泛的概念，什么是事件？可以是：按下了按键、串口接收到了数据、模块产生了中断、某个全局变量被设置了。
什么叫事件驱动？当某个事件发生时，才调用对应函数，这就叫事件驱动。
我们将上面的例子进行改进：
当孩子哭的时候宝妈就给他喂饭当同事发送了消息，电脑提示了才去回复同事 void crying_isr(){//检测孩子是否在哭的中断函数 eating();//哭了就执行喂孩子吃饭的函数 } void message_isr(){//检测同事是否发消息函数. message();//执行回消息函数 } void main(){ while(1){ } } 这种编程方式就使得这两个中断函数执行的都很快，不用像轮询一样再去等待上一个函数的执行完毕。
但是如果两个中断同时发生，就会相互影响：
两个中断，同一时间只能处理一个如果当前中断处理时间比较长，就会影响到另一个中断的处理。
下面继续优化 改进的事件驱动方式 对于上面的程序，我们出现的问题是，当两个中断同时产生的时候，同一时间只能处理一个，如果一个中断处理时间比较长，就会影响另一个中断的处理。
下面我们针对这些问题来进行改进我们的程序。
对于中断的处理，原则上是“尽快”。否则就会影响其他中断，导致其他中断的处理延迟，甚至丢失。
下面我们通过设置标志位来改进程序。
void crying_isr(){//检测孩子是否哭了 is_crying=1;//如果哭了就将标志位置1 } void message_isr(){ is_message=1;//将有消息标志位置1。 } void main(){ while(1){ if(is_crying==1) eating(); if(is_message==1) message(); } } 设置了标志位以后，我们的中断处理函数就会很快执行，那么就不会影响到其他中断的处理，不会导致中断的延迟，丢失。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4736e22dc7ba36bae33a835382b316ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec07983f5773b96e6301db5fed79f3c6/" rel="bookmark">
			c内部机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		①。 汇编理论知识 7种模式， 32个寄存器
r0 - r7 : 7种模式都是一样的
r8- r12 : 普通模式、 FIQ 下特有的 r8 - r12 r13 - r14 : 每种下都有 ， 每种模式都不一样
sp : 每种模式下都有自己的栈， 所以r13 每种模式下都有 lr： 比如从user 模式切换到fiq 模式，把user模式返回地址存的lr中， fiq执行完毕以后就可以直接回到user模式 pc : 程序寄存器， 当前程序执行在哪里， 所以只有一个，一个国家只有一个皇帝 , pc 指向那条指令， cpu执行哪条 ， 程序跑飞了， pc寄存器内容不对了 cpsr: 程序状态寄存器，存储cpu的状态
spsr: 保存cpsr 比如User模式下有cspr， 在fiq下把user模式下的cpsr保存到fiq下的spsr ,返回的恢复User模式下状态
栈的集中概念； * 空栈： sp 指向空位 ，每次存入的时可以直接存入然后栈 指针移动一格 ； 取出的时需要首先移动一格才能取出 empty * 满栈： sp 指向栈中最后一格数据， 每次存入需要移动栈指针一格在存入 取出的时候直接取出，在移动栈指针 full
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec07983f5773b96e6301db5fed79f3c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b7aea9cb107b0ca649803648086482/" rel="bookmark">
			欧拉函数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是欧拉函数 在数论中，对正整数n，欧拉函数是小于或等于n的正整数中与n 互质的数的数目。此函数以其首名研究者欧拉命名，它又称为φ函数（由高斯所命名）或是欧拉总计函数[1]（totient function，由西尔维斯特所命名）。
例如，因为1,3,5,7均和8互质。
欧拉函数实际上是模n的同余类所构成的乘法群（即环的所有单位元组成的乘法群）的阶。这个性质与拉格朗日定理一起构成了欧拉定理的证明。
总而言之，欧拉函数是小于x的整数中与x互质的数的个数，一般用φ(x)表示。特殊的，φ(1)=1。
2.欧拉函数公式以及证明 N=p1^a1*p2^a2.....pk^ak;//将N因式分解
欧拉函数公式：φ(n)=N*(1-1/p^1)*(1-1/p^2)....(1-1/p^k)
证明：
1.从1到N中去掉p1,p2.....pk的所有倍数。N-N/p1-N/p2-.....-N/pk。
2。由于一些数可能是pi*pj的倍数，所以加上所有pi*pj的倍数。N-N/p1-N/p2-.....-N/pk+N/p1p2+N/p2p3.....。
3.由于一些数可能是pi*pj*pz的倍数，经过上诉两步，相当于没有减去pi*pj*pz的倍数，所以减去所以pi*pj*pz的倍数。N-N/p1-N/p2-.....-N/pk+N/p1p2+N/p2p3.....-N/p1p2p3-N/p2p3p4-.....。
4,得出规律第四步操作为加上所以pi*pj*pz*px的所有倍数，最后将公式总结得出欧拉公式：φ(n)=N*(1-1/p^1)*(1-1/p^2)....(1-1/p^k)
3.欧拉函数的性质 ① 当m,n互质时，有phi（m*n）= phi（m）*phi（n）；
② 若i%p==0，有phi（i*p） = p * phi(i)；
③ 对于互质x与p，有x^phi§≡1（mod p),因此x的逆元为x^(phi§-1)，即欧拉定理。
（特别地，当p为质数时，phi（p）=p-1,此时逆元为x^(p-2)，即费马小定理）
④ 当n为奇数时，phi(2n)=phi(n)
⑤ 若x与p互质，则p-x也与p互质，因此小于p且与p互质的数之和为phi(x)*x/2;
⑥N&gt;1，不大于N且和N互素的所有正整数的和是 1/2 *N *eular(N)。
⑦若(N%a == 0 &amp;&amp; (N/a)%a==0) 则有:E(N)=E(N/a)*a;
⑧若(N%a==0 &amp;&amp; (N/a)%a!=0) 则有:E(N)=E(N/a)*(a-1);
4.线性筛法求欧拉函数 一些题目会要求我们求1到n的欧拉函数之和，例如AcWing 874 筛法求欧拉函数，这是我们在利用公式来求欧拉函数时就过于麻烦，我们可以利用筛法求欧拉函数。
线性筛法求欧拉函数模板：
ll get_eulers(int n)
{
euler[1]=1;//1的欧拉函数为1
for(int i=2;i&lt;=n;i++)
{
if(!st[i]) //如果为质数
{
primes[cnt++]=i;
euler[i]=i-1;
}
for(int j=0;primes[j]&lt;=n / i;j++)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0b7aea9cb107b0ca649803648086482/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5747db0316760371349b2b893a03d120/" rel="bookmark">
			前缀和&#43;哈希表优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用场景： 当需要大量判断某些区间的某一性质时使用。比如找出数组nums中满足某一性质的区间的个数，比如找出数组中最长的满足某一性质的区间，这些区间有O()个，这时就要想到用前缀和。例如求一个长度为n的序列的区间[j+1, i]的某一性质时，通过pre[i]-pre[j]可以以O(1)的时间复杂度判断这个区间是否具有这一性质。显然，这里的pre[i]-pre[j]也是狭义的。广义上来讲，凡是以pre[i]和pre[j]为参数，以O(1)时间复杂度得出判断结果的函数都可以。
题目举例 LeetCode 560题：
题目：给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
分析：数组nums的区间[j, i]间的和为k，等价于数组nums的前缀和prefixsum[i] - prefixsum[j - 1] = k，即prefixsum[i] - k = prefixsum[j - 1]，也就是说数组nums在i处的前缀和减去k的值在[0,j]间有个j的前缀和与之相等，则[j,i]间的和为k。
int subarraySum(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int, int&gt; sum; int count = 0; int pre = 0; sum[0] = 1; for (auto c : nums) { pre += c; if (sum.find(pre - k) != sum.end()) { count += sum[pre - k]; } // 用 []访问，key不存在时，C++会利用该key及默认构造的value，组成{key，value}对，插入到map中。 // 存在则加一，不存在则创建后赋值为1 sum[pre]++; } return count; } 参考：辣鸡算法（五）：前缀和+哈希表优化_cly141220010的博客-CSDN博客_前缀和+hash 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1d7a98db2b5fd3ee1fd3ae9c2490d6/" rel="bookmark">
			Redis 5.0数据结构之压缩列表ziplist源码详解（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于篇幅过长，ziplist的源码分析分为两篇，本篇是第二篇，涉及到ziplist的添加元素、查找元素、删除元素以及连锁更新实现的源码分析。
Redis 5.0数据结构之压缩列表ziplist源码详解（一）
前文已经提及了压缩列表ziplist的主要设计初衷是尽量节约空间，因此设计出了一系列的压缩编码，将ziplist设计成了内存地址连续，使用基地址+偏移量的方式来访问压缩列表内节点，并且说明了压缩列表节点结构具有的属性以及相应的作用，通过源码分析了对于节点内各属性的编码的实现细节。
接下来将继续通过源码解析ziplist的各操作是如何实现的。
添加元素 添加元素是调用ziplistPush函数，其中参数where参数决定新元素插入位置。
unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) { unsigned char *p; p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl); return __ziplistInsert(zl,p,s,slen); } 实际完成添加元素工作的是__ziplistInsert函数，源码如下：
// 将值长度为slen的节点存放到zl压缩列表的位置p处 unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) { // 因为涉及到位运算 大小端转换 // Redis默认小端存储 如果在大端存储的机器上允许 需要大小端转换 // reqlen为当前节点所需长度 size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen; unsigned int prevlensize, prevlen = 0; // 偏移量 size_t offset; int nextdiff = 0; unsigned char encoding = 0; long long value = 123456789; /* initialized to avoid warning.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d1d7a98db2b5fd3ee1fd3ae9c2490d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c597d435082d7c19536d3131a6bc592/" rel="bookmark">
			focus属性在textarea上不能用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 **
focus属性在textarea上不能用 **
输入框获取焦点的属性 focus 在input标签 type为text时正常获取焦点打开输入法 在textarea标签时 模拟器正常 各种手机都不获取焦点
&lt;a-textarea placeholder="Basic usage" :rows="1" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43cf1c13f876193b1b58248021e20103/" rel="bookmark">
			微信小程序Url传参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序的跳转分五种
1.wx.navigateTo:保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面，小程序中页面栈最多十层。（可带参）
2.wx.redirectTo:关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。（可带参）
3.switchTab:跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面（不可带参）
4.wx.navigateBack:关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。（没有url属性，不可带参）
5.wx.reLaunch：关闭所有页面，打开到应用内的某个页面（可带参）
1.wx.navigateTo
(1).在pageA页面有一个固定的值要传递到pageB页面，比如说一个固定的值id要传递给B
pageA页面
wx.navigateTo({
url: "/pages/pageA/pageA?id=77" });
pageB页面 data:{id:0}
onload(options){
this.setData({ id:options.id })
console.log(this.data.id) // 77
}
(2).在pageA页面有多个固定的值要传递到pageB页面，比如说一个固定的值id要传递给B
pageA页面
wx.navigateTo({
url: "/pages/pageA/pageA?id=77&amp;age=20" });
pageB页面
data:{id:0,age:0},
onload(options){
this.setData({ id:options.id, age:options.sex })
console.log(this.data.id,this.data.sex) // 77,20
}
还有一种就是多个参数用 'xx?xx=' + 11 + '&amp;xxx=' + 22 的方式传参
pageA页面
data:{age:20}
wx.navigateTo({
url: "/pages/pageD/pageD?id=" + 77 + ‘&amp;sex=’ + '男' + '&amp;age=' + this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43cf1c13f876193b1b58248021e20103/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e4ad2ecef3ec9fb49937fc02b11e1b/" rel="bookmark">
			Pysyft学习笔记四：MINIST数据集下的联邦学习（并行训练与非并行训练）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 手写数字识别模型（非并行训练）概述图导入基本包创建客户机设置训练参数初始化数据集搭建神经网络模型定义训练与测试函数定义主函数训练效果 手写数字识别模型（并行训练）概述图导入必要的包建立客户机初始化训练参数定义训练集与测试集定义神经网络使用Fed_avg算法整合模型定义训练定义测试启动入口训练效果 经过前面几篇笔记的学习，基本上已经知道了联邦学习的基本代码框架。联邦学习也有两种实现方式，一种是C/S架构，服务器整合模型，一种是P2P架构，不需要第三方。现在先实现C/S架构下的横向联邦学习模型。 大概处理过程如下： 1.数据预处理，得到data_loader
2.建立虚拟机，分配数据集
3.初始化模型
4.将模型发送给虚拟机
5.指导虚拟机训练
6.回收模型 熟悉了基本的处理流程以后，打算自己写一个用MINIST数据集的手写数字识别联邦学习模型。 手写数字识别模型（非并行训练） 概述图 服务器先将model发送Alice，Alice利用本地数据进行训练以后，再将模型发送给Server，Server接受到模型后，将模型发送给Bob，Bob利用本地数据进行训练，训练完成后，交给Server，Server利用本地的测试数据对model进行评估，然后将这个模型分发给Alice和Bob。
但是这样训练的缺点非常明显：Bob可以对接受模型的参数进行推理，可能能得到Alice本地数据的部分特征，从而破坏了数据的隐私性。非并行训练，训练时间长，Bob的数据是后训练的，可能占总模型的大，而不能很好的利用到双方的数据。
目前在写训练代码时还遇到了一些困惑，写在了本文的最后面，欢迎各位大佬留言，万分感谢。
导入基本包 import torch #用于构建NN import torch.nn as nn #需要用到这个库里面的激活函数 import torch.nn.functional as F #用于构建优化器 import torch.optim as optim #用于初始化数据 from torchvision import datasets, transforms #用于分布式训练 import syft as sy hook = sy.TorchHook(torch) 创建客户机 Bob = sy.VirtualWorker(hook,id='Bob') Alice = sy.VirtualWorker(hook,id='Alice') 设置训练参数 class Arguments(): def __init__(self): self.batch_size = 1 self.test_batch_size = 100 self.epochs = 3 self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8e4ad2ecef3ec9fb49937fc02b11e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c17d6e3e96735aebb50784b58ea0b10/" rel="bookmark">
			权限管理系统项目文档——Vue前端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第二篇 前端实现篇1. 搭建开发环境1.1 技术基础1.2 开发环境1.3 创建项目 2. 前端项目案例2.1 安装Element2.2 页面路由2.3 安装SCSS2.4 安装axios2.5 安装Mock.js 3. 工具模块封装3.1 封装axios模块3.2 封装mock模块 4. 第三方图标库4.1 使用第三方图标库4.2 Font Awesome 5. 多语言国际化5.1 安装依赖5.2 添加配置5.3 字符引用5.4 页面测试 6. 登录流程完善6.1 登录界面6.2 主页面6.3 页面测试 7. 管理应用状态7.1 安装依赖7.2 添加store7.3 引入store7.4 使用store7.5 收缩组件7.6 页面测试 8. 头部组件功能8.1 主题切换组件8.1.1 编写组件8.1.2 页面测试 8.2 语言切换组件8.2.1 编写组件8.2.2 页面测试 8.3 用户信息面板8.3.1 编写组件8.3.2 页面测试 8.3 系统通知面板8.3.1 编写组件8.3.2 页面测试 8.4 用户私信面板8.4.1 编写组件8.4.2 页面测试 9. 动态加载菜单9.1 添加store9.2 登录页面9.3 导航守卫9.4 导航树组件9.5 页面测试 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c17d6e3e96735aebb50784b58ea0b10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e70ad003ec82907b592dfc07ed64ba7/" rel="bookmark">
			Eclipse 调试 PHP 配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文使用的 Eclipse 版本（其他版本请自行探索）
必备条件：
1、首先确保 Apache 安装正确；
2、配置 PHP 环境，能正常运行 PHP 项目；
3、Eclipse 安装正确；
关键步骤：
1、下面用于调试的 php 环境要与正式运行环境的路径一致
2、确保路径正确，在浏览器中能正常访问（apache要运行起来）
3、启动调试，选择 XDebug 调试器，即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8d0502b2cee05cd11d6c40f5339189/" rel="bookmark">
			权限管理系统项目文档——SpringBoot后端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 关键技术第一篇 后端实现篇1. 搭建开发环境2. 集成Swagger文档3. 集成MyBatis框架4. 集成Druid数据源5. 跨域解决方案6. 业务功能实现6.1 工程结构规划6.1.1 mango-admin6.1.2 mango-common6.1.3 mango-core6.1.4 mango-pom6.1.5 打包测试 6.2 业务代码封装6.2.1 通用CURD接口6.2.2 分页请求封装6.2.3 分页结果封装6.2.4 分页助手封装6.2.5 HTTP结果封装 6.3 MyBatis分页查询6.3.1 添加依赖6.3.2 添加配置6.3.3 分页代码6.3.4 接口测试 6.4 业务功能开发6.4.1 编写DAO接口6.4.2 编写映射文件6.4.3 编写服务接口6.4.4 编写服务实现6.4.5 编写控制器 6.5 业务接口汇总6.6 导出Excel报表6.6.1 添加依赖6.6.2 编写服务接口6.6.3 编写服务实现6.6.4 编写控制器6.6.5 工具类代码6.6.6 接口测试 7. 登录流程实现7.1 登录验证码7.2 Spring Security7.2.1 添加依赖7.2.2 添加配置7.2.3 登录认证过滤器7.2.4 身份验证组件7.2.5 认证信息查询7.2.6 添加权限注解7.2.7 Swagger添加令牌函数 7.3 登录接口实现7.4 Spring Security执行流程剖析 8. 数据备份还原8.1 新建工程8.2 添加依赖8.3 添加配置8.4 自定义Banner8.5 启动类8.6 跨域配置8.7 Swagger配置8.8 数据源属性8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b8d0502b2cee05cd11d6c40f5339189/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d3353feaed8d94e16939f3149e8d56/" rel="bookmark">
			【JQuery Mobile移动应用开发实战】JQuery Mobile基础——JQuery Mobile界面综合实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 8. JQuery Mobile界面综合实战8.1 清爽的电子书阅读器8.2 简单的计算器8.3 移动BBS模板8.4 基于JQuery Mobile的简单记事本8.5 基于JQuery Mobile的全键盘界面 所有markdown笔记以及对应pdf以及项目源码都已上传至网盘：
链接：https://pan.baidu.com/s/1-_iqh67EU43BpgEa040hMQ
提取码：ziyi
8. JQuery Mobile界面综合实战 主要知识点包括：
利用JQuery Mobile进行开发的方法开发实战中的技巧什么样的应用可以用JQuery Mobile开发 8.1 清爽的电子书阅读器 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"/&gt; &lt;link rel="stylesheet" href="../css/jquery.mobile-1.4.5.min.css" /&gt; &lt;script src="../script/jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script src="../script/jquery.mobile-1.4.5.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div data-role="page" id="home" data-title="首页"&gt; &lt;div data-role="header" data-position="fixed"&gt; &lt;a href="#"&gt;返回&lt;/a&gt; &lt;h1&gt;电子书阅读器&lt;/h1&gt; &lt;a href="#"&gt;设置&lt;/a&gt; &lt;/div&gt; &lt;div data-role="content"&gt; &lt;ul data-role="listview"&gt; &lt;li&gt;&lt;a href="#page_1"&gt;jQuery Mobile实战 第一章&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#page_2"&gt;jQuery Mobile实战 第二章&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6d3353feaed8d94e16939f3149e8d56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cffe905f038b7f27d1876f3836c9886/" rel="bookmark">
			计算水仙花数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算水仙花数 什么是水仙花数 要计算水仙花数，首先我们要知道什么是水仙花数
① 水仙花数是一个三位数
例如：111 222 333
② 水仙花数的个位、十位、百位的数字立方和等于原数
例如：123 – 13+23+33=1+8+27=36**≠** 123(不是水仙花数)
​ 153 – 13+53+33=1+125+27=153 = 153(是水仙花数)
好了，当我们弄懂了什么是水仙花数，就来分析一下怎么求出水仙花数？
分析如何获得水仙花数 ① 输出所有的水仙花数必然要使用到循环，遍历所有的三位数，三位数从100开始，到999结束
for(int i=100; i&lt;=999;i++) {...} ② 不是每个三位数都是水仙花数，因此需要判断，是否满足水仙花的第二个条件
if(判断语句) {...} ③ 判断条件是将三位数中的每个数值取出来，计算立方和后与原始数字进行比较是否相等
if(? + ? + ? == 原数) { 满足条件打印原数 } 分析完毕，现在主要问题就是怎么分别计算出个、十、百位上的值呢？
再分析如何获得个、十、百位上的值 怎么求个位数
153 3就是原始数字对10进行取余的运算的结果 ---- 153%10=3 怎么求百位数
153 1就是原始数字除以100的结果（整除） ---- 15 3 / 100 = 1 怎么求十位数
153 153通过除以10，可以将5移动到个位上（整除）---- 153 / 10 = 37
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cffe905f038b7f27d1876f3836c9886/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d449d7260410010170e872804c3ab54/" rel="bookmark">
			Linux命令 - ps（process status）进程管理、实用查询组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ps（Process Status）是linux的进程管理命令，但是只是执行ps命令这一个瞬间（快照）的进程状态。 说到Linux进程，就需要细说一下5种进程状态，如下表格：
ps支持UNIX（参数前有一个 -，比如 -pcpu）、BSD（参数前不能有 -，比如 au）、GUN（参数前两个 -，比如 --sort）三种风格，如下：
[root@iZ2ze4zhiwnwqxsc7wehwlZ ~]# ps au --sort -pcpu USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 575 0.0 0.0 110088 132 ttyS0 Ss+ Jan21 0:00 /sbin/agetty --keep-baud 115200 38400 9600 ttyS0 vt220 root 1306 0.0 0.0 115436 448 tty1 Ss+ Jan21 0:00 -bash root 2884 0.0 0.1 115440 2040 pts/0 Ss 13:27 0:00 -bash root 8264 0.0 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d449d7260410010170e872804c3ab54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afee048e1744b2aa94fa9ed51247be4d/" rel="bookmark">
			【JQuery Mobile移动应用开发实战】JQuery Mobile基础——列表控件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 5. 列表控件的使用5.1 简单的新闻列表5.2 音乐专辑列表的显示5.3 更完善的音乐专辑列表5.4 显示销售的商品列表5.5 图书销量排名5.6 简单的电话通讯录5.7 让查找更加便捷5.8 比较高级的新闻列表 5. 列表控件的使用 JQuery Mobile使用方便而且具有出色的交互性，本章主要知识点包括：
列表的使用方法，包括最基础的列表及列表内容的排列技巧。列表的高级用法，包括在列表中插入图片及额外的按钮。使用列表规划界面布局。 5.1 简单的新闻列表 用列表控件实现简单的新闻列表：
&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;title&gt;Fixed Positioning Example&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=0.5"/&gt; &lt;link rel="stylesheet" href="../css/jquery.mobile-1.4.5.min.css" /&gt; &lt;script src="../script/jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script src="../script/jquery.mobile-1.4.5.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div data-role="page"&gt; &lt;div data-role="header" data-position="fixed" data-fullscreen="true"&gt; &lt;a href="#"&gt;返回&lt;/a&gt; &lt;h1&gt;今日新闻&lt;/h1&gt; &lt;a href="#"&gt;设置&lt;/a&gt; &lt;/div&gt; &lt;div data-role="content"&gt; &lt;ul data-role="listview"&gt; &lt;li&gt;&lt;a href="#"&gt;中美海军举行联合反海盗演习 首次演练实弹射击&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;安徽回应警察目睹少女被杀:不护短已提请检方介入&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;深圳居民为省钱开船到香港加油被判拘役5个月&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;海南卫生厅干部体验看病难:候2小时就诊5分钟&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afee048e1744b2aa94fa9ed51247be4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb7404708a0732ed017349de8e856251/" rel="bookmark">
			KVM虚拟化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		KVM虚拟化 虚拟化技术 虚拟化技术就是对资源的抽象，如虚拟机，虚拟内存等
虚拟化（Virtualization）技术最早出现在 20 世纪 60 年代的 IBM 大型机系统，在70年代的 System370 系列中逐渐流行起来，这些机器通过一种叫**虚拟机监控器（Virtual Machine Monitor，VMM）**的程序在物理硬件之上生成许多可以运行独立操作系统软件的虚拟机（Virtual Machine）实例
VMM虚拟机监控器也叫做Hypervisor，就是为了虚拟化而引入的一个软件层。它向下掌控实际的物理资源，向上呈现出N份逻辑资源。
虚拟机监控器运行的实际物理环境，称为宿主机；其上虚拟出来的逻辑主机，称为客户机。
分类
从资源提供角度分
平台虚拟化：把CPU，内存，外设等作为资源提供给虚拟机使用。在同一个X86平台上面，可以虚拟多个X86平台，每个平台可以运行自己完全独立的操作系统。如QEMU，KVM，VMware等所管理的虚拟机操作系统虚拟化：如果把操作系统及其提供的系统调用作为资源，那虚拟化就表现为操作系统虚拟化，例如Linux容器虚拟化技术就是在同一个Linux操作系统之上，虚拟出多个同样的操作系统，每个应用程序认为自己运行在一个独立的OS。如LXC或Docker等所管理的容器 从虚拟化实现方式分
Type I：虚拟机直接运行在系统硬件上，被称为裸机型，没有所谓的宿主机操作系统。他们直接控制硬件资源以及客户机。这种方案的性能处于主机虚拟化与操作系统虚拟化之间。如xen和vmware ESXType II：虚拟机运行在传统操作系统上，同样创建的是硬件全仿真实例，被称为**托管（宿主）**型。Hypervisor构建出一整套虚拟硬件平台，使用者根据需要安装新的操作系统和应用软件，底层和上层的操作系统可以完全无关化。简单的说这类VMM通常就是宿主机操作系统上的一个应用程序，像其他应用程序一样受宿主机操作系统的管理，通常抽象为进程。如VMware workstation、KVM。主机虚拟化中VM的应用程序调用硬件资源时需要经过:VM内核-&gt;Hypervisor-&gt;主机内核，相对来说，性能是几种虚拟化技术中最差的 Hypervisor管理工具的对比
工具厂商主CPU目标CPU主系统目标系统qemuFebrice，BellardInter，AMD，ARMx86/x86-64/ARMWindows，Linux，Mac OSLinuxkvmRed HatInter/AMDx86/x86-64LinuxWindows/LinuxXen剑桥大学，Inter/AMDInter/AMDx86/x86-64Windows/Linux/SolarisWindows/LinuxHyper-V微软Inter/AMDx86/x86-64WindowsWindows/LinuxVMware ESXi ServerVMwareInter/AMDx86/x86-64裸机安装Windows/LinuxOracle VMOracleInter/AMDx86/x86-64裸机安装Windows/Linux KVM架构 KVM内核模块 它属于标准Linux内核的一部分，是一个专门提供虚拟化功能的模块，主要负责CPU和内存的虚拟化本质上，KVM是管理虚拟硬件设备的驱动，该驱动使用字符设备**/dev/kvm**（由KVM本身创建）作为管理接口，主要负责vCPU的创建，虚拟内存的分配，vCPU寄存器的读写以及vCPU的运行 QEMU QEMU是用户态工具，可以为客户机提供设备模拟的功能，包括模拟BIOS、数据总线、磁盘、网卡、显卡、声卡、键盘、鼠标等。
我们知道KVM只负责CPU和内存的虚拟化，加载了它以后，用户就可以进一步通过工具创建虚拟机（KVM提供接口），但仅有KVM还是不够的，用户无法直接控制内核去做事情（KVM只提供接口，怎么创建虚拟机，分配vCPU等并不在它上面进行），还必须有个运行在用户空间的工具才行，KVM的开发者选择了比较成熟的开源虚拟化软件QEMU来作为这个工具，并对其进行了修改，最后形成了QEMU-KVM。
在QEMU-KVM中，KVM运行在内核空间，QEMU运行在用户空间，实际模拟创建，管理各种虚拟硬件，QEMU将KVM整合了进来，通过/ioctl 调用 /dev/kvm，从而将CPU指令的部分交给内核模块来做，KVM实现了CPU和内存的虚拟化，但kvm不能虚拟其他硬件设备，因此qemu还有模拟IO设备（磁盘，网卡，显卡等）的作用，KVM加上QEMU后就是完整意义上的服务器虚拟化。但是，由于qemu模拟io设备效率不高的原因，现在常常采用半虚拟化的virtio方式来虚拟IO设备。
KVM负责提供对cpu，内存的虚拟
QEMU负责除CPU和内存外的其他设备的虚拟以及对各种虚拟设备的创建与调用
libvirt libvirt是一套免费、开源的支持Linux下主流虚拟化管理程序的C函数库，其旨在为包括KVM在内的各种虚拟化管理程序提供一套方便、可靠的编程接口。 当前主流Linux平台上默认的虚拟化管理工具virt-manager,virsh等都是基于libvirt开发。libvirt是一个针对各种虚拟化平台的虚拟机管理的API库。一些常用的虚拟机管理工具如virsh（类似vim编辑器），virt-install，virt-manager等和云计算框架平台（如OpenStack，OpenNebula，Eucalyptus等）都在底层使用libvirt提供的应用程序接口。libvirt主要由三个部分组成：API库，一个守护进程 libvirtd 和一个默认命令行管理工具 virsh。 总结 QEMU是一个独立的虚拟化解决方案，并不依赖KVM（它本身自己可以做CPU和内存的模拟，只不过效率较低）。而KVM是另一套虚拟化解决方案，对CPU进行虚拟效率较高（采用了硬件辅助虚拟化），但本身不提供其他设备的虚拟化，借用了QEMU的代码进行了定制，所以KVM方案一定要依赖QEMU。即使后来RedHat后来开发了libvirt，也只能简单的认为libvirt是个虚拟机管理工具，仍然需要通过用户空间QEMU来与KVM进行交互。 KVM虚拟机部署 环境准备 Linux主机需要安装图形化桌面 最小化——&gt;图形
yum groupinstall -y “GNOME 桌面”
重启
startx临时开启终端（不推荐）
systemctl set-default graphical.targer
[root@server1 ~]# systemctl get-default
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb7404708a0732ed017349de8e856251/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adaf55f0af7124aaaaad855d17fcb78f/" rel="bookmark">
			go语言用cookie实现登录（gin&#43;gorm）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go语言用cookie实现登录（gin+gorm） 第一步数据库验证表单提交的用户名和密码是否正确 //获取表单提交的数据进行登录 name := c.PostForm("name") password := c.PostForm("password") //每个人的验证都基本不同，代码就省略了 //将获得的数据进行数据库验证，如果验证成功，则进行第二步在验证成功的地方设置cookie //下方代码为我验证成功的地方，设置cookie if admin.Password == password { c.SetCookie("abc", 123, 3600, "/", "localhost", false, true) // 返回信息登录成功 c.String(http.StatusOK, "Login success!") } 第二步设置cookie // 给客户端设置cookie // maxAge int, 单位为秒 // path,cookie所在目录 // domain string,域名 // secure 是否智能通过https访问 // httpOnly bool 是否允许别人通过js获取自己的cookie c.SetCookie("abc", "123", 3600, "/", "localhost", false, true) 参数中第一个和第二个可以自己定义（“abc”, 123）
第三步设置中间件 func AuthMiddleWare() gin.HandlerFunc { return func(c *gin.Context) { // 获取客户端cookie并校验 if cookie, err := c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adaf55f0af7124aaaaad855d17fcb78f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad68ba7a487cd0b806cd6ec662837408/" rel="bookmark">
			安装新版本的idea，双击打不开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看.bat文件，发现一直找旧版本的idea的破解jar，各种找网上给出的目录都不对，最后自己翻到这个路径。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cacc5ca578956faf4941334fb3afa67d/" rel="bookmark">
			全基因组序列对比~mVISTA，perl转化mvista格式（图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mVISTA的使用 首先，官方网址：https://genome.lbl.gov/vista/index.shtml
打开后如下，点击mVISTA
输入需要对比的序列个数
在对应位置输入自己的邮箱，上传目标序列的fasta格式文件 这里有三个选项，LAGAN是多序列对比，Shuffle-LAGAN是检测重排
在Name栏输入对应序列的名称，一般不能出现空格，可以用“-”代替
然后要上载文件，这里的文件格式要求必须是mvista格式的文件（要用perl语言转化，后续详细教程）
一一对应上传后，点击submit提交
等待邮件的结果即可
二、perl语言将genbank格式转化为mvista格式 脚本来源于此：mVISTA格式文件：由Perl脚本处理GenBank注释文件而来 - 简书
复制代码到记事本，保存并命名为get_mVISTA_format_from_GenBank_annotation，文件格式是.pl
启动perl语言，这里我并没有改变路径，所以我直接把上面保存的文件拖入电脑文档文件夹下
同时还要将自己要转化的序列文件的genbank格式整理到一个文件夹中，并且也放入同一目录下
将get_mVISTA_format_from_GenBank_annotation.pl文件拖拽至＞后，两次回车，出现如下界面
复制example命令
然后将input换成自己的文件路径和名称
回车后
这时候打开自己的文件夹，mvista格式就已经出来啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec470fde692fb4884267d1de0e008007/" rel="bookmark">
			Real-time Instance Segmentation with Discriminative Orientation Maps
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 网络结构网络输出后处理总结 OrienMask是2021年新出的一篇实时的实例分割模型。下图是OrienMask在coco数据集上的测试结果。在单张2080ti上可以达到42.7fps的速度。
这篇文章的主体思路是先使用yolo检测出目标的bbox，然后再检测出bbox中的前景来完成实例分割任务。
网络结构 上图是OrienMask的网络结构，主要分为3块：Backbone、FPN、Heads。
使用darknet53作为Backbone，进行了32倍下采样，分别在4x，8x，16x，32x下采样的进行FPN来进行特征融合；最后是检测heads，32x、16x、8倍下采样分支上输出bbox结果，4倍下采样的分支上输出Orientation Maps。可以看出来除了在4倍下采样的分支上输出Orientation Maps之外只是一个yolo。
网络输出 这里详细介绍网络的输出和Orientation Maps的作用。
在后处理之前，模型的输出是：dets_conf，dets_coor，dets_orien。
其中dets_conf的尺寸是：18207*80。这里 18207 = 3 ∗ ( 1 7 2 + 3 4 2 + 6 8 2 ) 18207=3*(17^2+34^2+68^2) 18207=3∗(172+342+682)，3是表示每个尺度下有3个不同比例的anchor，17、34、68分别是3个尺度的grid size；80代表类的数量。dets_conf里存放的是所有尺度的grid的置信度。
dets_coor的尺寸是：18207*4。18207的定义同上，4代表bbox的长度即xywh。这里存放的所有尺度的grid的xywh的偏移量。
dets_orien的尺寸是9*2*544*544。这里9代表9个anchor（3个尺度*3个不同长宽比），2代表x,y（向量），544是图像输入尺寸。即dets_orien里存了输入图像在9个anchor上的方向向量。
后处理 怕表达不清楚，后处理这块照着代码聊吧。这里提供的代码是我转tensorrt时没能转进onnx的部分，与源码中的后处理代码可能会有一点出入，但是最终结果是对的。后面会介绍转tensorrt的全部流程和代码。
def post_processing(dets_coord, dets_conf, dets_orien, dets_anchor_idx, grid_sizes, base_xy, grid_anchors, pre_post_num=400, conf_thresh=0.005): selected_inds, dets_cls = torch.nonzero(dets_conf &gt; conf_thresh, as_tuple=True) selected_inds = selected_inds.view(-1) dets_cls = dets_cls.view(-1) dets_conf = dets_conf[selected_inds, dets_cls] # 选择固定数量的候选框留给 NMS 操作 if selected_inds.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec470fde692fb4884267d1de0e008007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5593da9116a499c2d09625f2a91a369f/" rel="bookmark">
			【Java开发】之 Long 类型序列化成 String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、情景介绍 在项目开发过程中，当后端返回给前端的类型为 Long 类型时，如果值超过了前端 js 显示的长度范围的话会导致数字精度丢失，但我们又不想变更字段的类型，此时我们可以在序列化返回时将 Long 类型转换成 String 类型。
二、转换方式 1、使用 @JsonSerialize 注解 import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; public class Demo { @JsonSerialize(using = ToStringSerializer.class) private Long uid; } 注意： 该注解生效的类型必须是包装类，如果是原生的类型比如 long 会转换失败。
2、使用全局配置 使用 @JsonSerialize 有很大的局限性，就是需要在每个要转换的类型上添加该注解，所以，我们可以通过 WebMvcConfigurer 来实现全局序列化：
import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.SerializerProvider; import com.fasterxml.jackson.databind.module.SimpleModule; import org.springframework.context.annotation.Configuration; import org.springframework.http.converter.HttpMessageConverter; import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; import java.io.IOException; import java.util.List; /** * @author 王廷云 */ @Configuration public class ShopWebConfig implements WebMvcConfigurer { /** * 注册自定义类型转换器 */ @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5593da9116a499c2d09625f2a91a369f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2b63957880fd38889574bbde5dff0f/" rel="bookmark">
			按键的原理及独立式按键的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按键的原理及独立式按键的实现 键盘的基本原理 抖动的消除 硬件消抖
软件消抖
硬件消抖
软件消抖
利用延时程序消除抖动。
键盘的分类 独立式键盘和行列键盘
独立式键盘
特点
每个键占用一根并口线，键位多时占用并口(IO口)线多。用于键位较少的情况。处理简单，直接判并口线。 行列键盘—矩阵键盘
特点
键位分布在行列交叉点上。占用并口线少，键位越多越明显。 键位的识别
第一步是首先检测键盘上是否有键按下；
第二步是识别哪一个键按下。
检测键盘上是否有键按下的处理方法—全扫描
识别键盘中哪一个键按下的处理方法—逐行逐列扫描
开始 元件
编程
#include "reg51.h" //定义P1.0口 sbit key0 = P1^0; //定义一个数组，共阴0-9 unsigned char s[] = { 0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F }; unsigned char num=0; void delay(unsigned int n) { //给变量一个初始值，防止变量初始化的时候是一个随机数 //可能造成程序的误动作 unsigned int i=0,j=0; for(i=0;i&lt;n;i++) { for(j=0;j&lt;120;j++); } } void key() { if(key0==0) { delay(200); num++; } } void seg() { P2=s[num]; if(num==10) { num=0; } } void main() { while(1) { key();//按键的程序	seg();//操作数码管 } } 按键消抖效果并不是很好，引入标志位，确保按键按下，数码管立即反应
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2b63957880fd38889574bbde5dff0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/367711127cf7cabd3c1b139c1bcb157c/" rel="bookmark">
			网格边的种类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网格中边的种类分成以下几种： 1、boundary edges，即边界边 (仅由一个多边形使用) ，或者是一个线单元。
红色线是由边界边组成的边界线 2、non-manifold edges，即非流形边，由三个或更多的多边形共享使用。
两个立方体有一条共同的边。非流形边的存在是因为一条边被四个面共享。 3、feature edges，即特征边，由两个三角形共用的边，且两个三角形和特征边组成的二面角&gt;特征角。
红色线是由特征边组成的特征线 4、manifold edges，即流形边，正好由两个多边形使用的边。
流形边 参考资料：
Extract EdgesHow to fix non-manifold geometry 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec44ca248d2285e458bfe5d7091393b/" rel="bookmark">
			TenSEAL学习笔记一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言TenSEAL简介Homomorphic EncryptionTenSEALContextEncryption and Evaluation 引言 发现网上没有什么TenSEAL的学习笔记，只能看官方文档，所以打算根据官方文档和自己的一些理解写一下TenSEAL的学习笔记。
TenSEAL简介 Tutorial 0: Getting Started
Welcome to TenSEAL’s first tutorial of a serie aiming at introducinghomomorphic encryption and the capabilities of the library.
TenSEAL is a library for doing homomorphic encryption operations on tensors. It’s built on top of MicrosoftSEAL, a C++ library implementing the BFV and CKKS homomorphic encryption schemes. TenSEAL provides ease of use through a Python API, while preserving efficiency by implementing most of its operations using C++, so TenSEAL is a C++ library with a Python interface.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec44ca248d2285e458bfe5d7091393b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a751528fad81774a176830569f3faaec/" rel="bookmark">
			Ajax请求url拼接多个参数写法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 get
字符串拼接
url: "" + URL + "/system/ops/setoff?dc="+dc+"&amp;sysId="+sysId+"&amp;paw="+paw 模板字符串
url: `/system/ops/content/setoff?contentIds=${contentIds}&amp;removeReason=${value}&amp;contentType=${contentType}` post
data: JSON.stringify({ pageNo: pageNum, sysid: sysid, dc: $('#dc option:selected').val(), paw: $("#paw").val() }), 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/299/">«</a>
	<span class="pagination__item pagination__item--current">300/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/301/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>