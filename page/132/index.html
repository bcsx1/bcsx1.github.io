<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae43e6a0403d02ce0e97f6c759b5badd/" rel="bookmark">
			算法数据结构基础——二叉树的遍历（前序、中序、后序、层序）及python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 二叉树的遍历简介 二叉树的遍历：指的是从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。
在二叉树的一些实际问题中，经常需要按照一定顺序对二叉树中每个节点逐个进行访问一次，用以查找具有某一特点的节点或者全部节点，然后对这些满足要求的节点进行处理。这里所说的「访问」就是指对该节点进行某种操作，例如：依次输出节点的数据信息、统计满足某条件的节点总数等等。
回顾二叉树的递归定义可以知道，二叉树是由根节点和左子树、右子树构成的。因此，如果能依次遍历这 3 个部分，就可以遍历整个二叉树。
如果利用深度优先搜索的方式，并且根据访问顺序次序的不同，我们可以分为 6 种遍历方式，而如果限制先左子树后右子树的遍历顺序，则总共有 3 种遍历方式：分别为 「二叉树的前序遍历」、「二叉树的中序遍历」 和 「二叉树的后续遍历」。
而如果使用广度优先搜索的方式，则可以按照层序方式（按照层次从上至下，每一层从左至右）对二叉树进行遍历，这种方式叫做 「二叉树的层序遍历」。
2. 二叉树的前序遍历 二叉树的前序遍历规则为：
如果二叉树为空，则返回。
如果二叉树不为空，则：
访问根节点。
以前序遍历的方式遍历根节点的左子树。
以前序遍历的方式遍历根节点的右子树。
从二叉树的前序遍历规则可以看出：前序遍历过程是一个递归过程。在遍历任何一棵子树时仍然是按照先访问根节点，然后遍历子树根节点的左子树，最后再遍历子树根节点的右子树的顺序进行遍历。
如下图所示，该二叉树的前序遍历顺序为：A - B - D - H - I - E - C - F - J - G - K。
2.1 二叉树的前序遍历递归实现 二叉树的前序遍历递归实现步骤为：
判断二叉树是否为空，为空则直接返回。
先访问根节点。
然后递归遍历左子树。
最后递归遍历右子树。
二叉树的前序遍历递归实现代码如下：
class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def preorder(root): if not root: return res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae43e6a0403d02ce0e97f6c759b5badd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88fbd34ce5972356b2d1da2bd0319e4/" rel="bookmark">
			FPGA频率测量的三种方法（直接测量法，间接测量法，等精度测量法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、FPGA频率测量？ 频率测量在电子设计和测量领域中经常用到，因此对频率测量方法的研究在实际工程应用中具有重要意义。
通常的频率测量方法有三种：直接测量法，间接测量法，等精度测量法。
2、直接测量法 2.1、方法 直接测量法也叫频率测量法，即在固定在时间t内对被测信号的脉冲数进行计数，然后求出单位时间内的脉冲数，即为被测信号的频率。
下图中的信号分别为：
sys_clk：系统的基准时钟gate：根据基准时钟生成的闸门信号，用于生成一个固定的时间（例如1s，方便计算）clk_fx：被测信号 gate是在基准时钟下生成的固定时间信号，它持续的时间 Tg = sys_clk ✖ 计数个数N（可设置）；在gate持续为高的时间内，可使用被测信号clk_fx对其进行计数，计数个数为cnt（图中为5），则cnt个被测信号的周期即为gate时长。
此种方法的本质是：同样的时间内分别使用两种时钟计时，则有 Tg = Tfx---- Tsys_clk ✖ 计数个数N = Tclk_fx ✖ cnt，公式变换后： clk_fx = cnt ✖ sys_clk / 计数个数N （其中clk_fx为待测信号频率，sys_clk为基准时钟频率）
2.2、误差分析 从图可以看出，在gate为高电平期间，被测信号实际上差不多有六个周期被囊括在内，但是因为被测信号是相对与系统的异步信号，相位不同，第一个周期无法被采样，所以实际采样为5，这样造成的误差为一个被测信号周期。可以预见，这种测量方法带来的测量误差即为一个被测信号周期。
那么理论上测得的准确频率：clk_fxe = cnt ✖ sys_clk / 计数个数N----理论上cnt无误差
实际上测量的频率值：clk_fx = cnt±1 ✖ sys_clk / 计数个数N----cnt会存在一个周期的测量误差
测量误差 = |（clk_fxe - clk_fx）/ clk_fxe | ✖ 100% = 1 / cnt ✖ 100%
所以测得的cnt越大，那么测出来的误差值就小，而cnt越大则代表被测信号的频率越高，所以可以推断该种测量方法适合测量高频信号；此外，选择的闸门时间越长则被测信号的个数越多，同样测量就越精确，但是增大闸门时间又会带来测量时间过长的问题，需要依据具体需求进行取舍。
2.3、Verilog代码 Verilog源码如下：
闸门时间设定为0.5s，非闸门时间也0.5s，则每1秒更新一次测量数据使用计数器生成闸门时间，闸门时间取反得到非闸门时间在闸门时间对被测信号计数在非闸门时间更新测量数据使用parameter定义参数，方便调用修改 //直接测量法(高频) module	cymometer_direct(	input sys_clk	,	//基准时钟，设计为50M(可更改) input sys_rst_n	,	//复位信号，低电平有效 input clk_fx	,	//待测信号 output reg [31:0]	fre	//测量结果 ); parameter	TIME_SYS = 20	;	//系统时钟周期：20ns--频率=50MHz parameter	TIME_GATE = 500_000_000	;	//500ms闸门设置的时间，单位：ns localparam	N = TIME_GATE /	TIME_SYS;	//生成闸门需要计数的个数 reg gate	;	//闸门 reg [31:0] cnt_gate	;	//用于生成闸门的计数器 reg [31:0] cnt_fx	;	//闸门时间内对被测信号计数 wire	gate_n	;	//闸门取反，用于在非闸门时输出测得的频率值 assign	gate_n = ~gate	;	//闸门取反，用于在非闸门时输出测得的频率值 //分频计数器，闸门时间设定为1ms，则每2ms测量一次	always @(posedge sys_clk or negedge sys_rst_n)begin	if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d88fbd34ce5972356b2d1da2bd0319e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ef74c666fd033b4d681d7a2c08d593/" rel="bookmark">
			问题解决：微信小程序编译后出现unexpected attribute name, near `.for`/`.key`/的等一系列unexpected attribute name, near问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 当对初始代码添加了wx.for和wx.key 初始代码 &lt;view class="tab"&gt; &lt;van-button round type="info" class="tab-item" size="small"&gt;豆子&lt;/van-button&gt; &lt;/view&gt; 最后代码 &lt;view class="tab"&gt; &lt;van-button wx.for="{{tab_list}}" wx.key="index" round type="info" class="tab-item" size="small"&gt;{{item.title}}&lt;/van-button&gt; &lt;/view&gt; 添加wx.for和wx.key后的最后代码，保存编译出现的错误： [ WXML 文件编译错误] ./pages/home/index.wxml unexpected attribute name, near `.for` 9 | &lt;/swiper&gt; 10 | &lt;view class="tab"&gt; &gt; 11 | &lt;van-button wx.for="{{tab_list}}" wx.key="index" round type="info" class="tab-item" size="small"&gt;{{item.title}}&lt;/van-button&gt; | ^ 12 | &lt;/view&gt; 13 | &lt;/view&gt; at files://pages/home/index.wxml#11(env: Windows,mp,1.06.2303220; lib: 2.32.0) [ WXML 文件编译错误] ./pages/home/index.wxml 删除wx.for后出现的错误： [自动热重载错误 WXML 文件编译错误] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ef74c666fd033b4d681d7a2c08d593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c06d5dfa11fe97e6f1bef3c3ff2fbec/" rel="bookmark">
			Android App开发教程（二）——透过Chaquopy结合Python第三方库numpy安装与应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 前一篇已经教大家如何在Android Studio上进行Chaquopy安装；由于Chaquopy支援Python多个第三方库，让开发者可以在Android Studio上轻松使用Python生态系统。Chaquopy支援大多数常用的Python第三方库，例如numPy、SciPy、Pandas、Matplotlib、Scikit-learn等。详细第三方库可参考Chaquopy package repository网站。
因此这次要教大家如何安装Python第三方库numpy与应用。
2. Android Studio安装Python第三方库numpy 以下环境是在Windows 10下建置。
a. 在appàbuild.gradleàdefaultConfigàpython区块添加文件添加。(图1)
pip{ install "numpy" }​ 看官们如果要安装其他第三方库也可以利用此方式进行新增。
图1 b. 设定完后记得，点击Sync Now进行同步，完成之后，Python的第三方库numpy套件就成功加入项目内。(图2)
图2
3. Android内使用 Python第三方库numpy套件范例
以下提供两个范例，1) 使用numpy计算两个矩阵的乘积。2) 使用numpy生成随机数组，并计算其平均值和标准差，除了透过python使用numpy计算外，还能将计算后的数值返回并转成java格式，供使用者能够在java进行后续应用，达到java与python交互应用。 a. 使用numpy计算两个矩阵的乘积。 i. 在hello_python.py档案内增加。(图3)
import numpy as np #使用numpy计算两个矩阵的乘积 def matrix_multiply(): a = np.array([[1, 2], [3, 4]]) b = np.array([[5, 6], [7, 8]]) c = np.matmul(a, b) return c 图3
ii. 我们在MainActivity档案内添加以下程式码，将python内numpy计算完后的数值读取到java程式中。(图4)
//初始化python环境 if(!Python.isStarted()){ Python.start(new AndroidPlatform(this)); } //使用numpy计算两个矩阵的乘积 Python py = Python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c06d5dfa11fe97e6f1bef3c3ff2fbec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ce863cd400a729e1f2f94dccedd7ce/" rel="bookmark">
			JAVA娱乐小项目——将图片转化为字符画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
代码
效果演示
前言 灵感来源于JAVA课上同学の颜文字表情，于是决定做一个JAVA小项目来娱乐玩一下QAQ
代码 package test; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; public class image_text { public static void main(String[] args) { // 读取图片文件 File imageFile = new File("path/to/your/image.jpg"); try { // 将图片转换为BufferedImage对象 BufferedImage bufferedImage = ImageIO.read(imageFile); // 设置字符画的宽度和高度 int asciiWidth = 80; int asciiHeight = 40; // 缩放图片以适应字符画的宽度和高度 BufferedImage resizedImage = new BufferedImage(asciiWidth, asciiHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g2d = resizedImage.createGraphics(); g2d.drawImage(bufferedImage, 0, 0, asciiWidth, asciiHeight, null); g2d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4ce863cd400a729e1f2f94dccedd7ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9948876fc1e00cb1705b0bcb10e26a4c/" rel="bookmark">
			Git常用命令cherry-pick
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git常用命令cherry-pick 将指定的提交应用于其他分支，可以用于恢复不小心撤销（revert/reset）的提交。
对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。
这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并 git merge 。另一种情
况是，你只需要部分代码变动(某几个提交)，这时可以采用 cherry pick。
1、cherry-pick使用 git cherry-pick 命令的参数，不一定是提交的 commit 值，分支名也是可以的，表示转移该分支的最新提交。
# 选择commit,合并进当前分支,会在当前分支产生一个新的提交 # 去合并某分支的某一次提交记录 $ git cherry-pick commit # 合并分支的某几次提交记录 $ git cherry-pick commit1 commit2 ... # 合并提交记录commit1到commit2之间的所有的提交记录,但不包含commit1的这次提交记录 $ git cherry-pick commit1..commit2 # 合并提交记录commit1到commit2之间的所有的提交记录,包含commit1的这次提交记录 $ git cherry-pick commit1^..commit2 # 合并该分支上最新的一次提交记录 $ git cherry-pick branch_name 例子：
$ git branch * branch_a master # branch_a $ git log --oneline ddbfc0b (HEAD -&gt; branch_a, origin/branch_a) branch_a | update a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9948876fc1e00cb1705b0bcb10e26a4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfd7a8f03bea47fb84ced9cd635e4fd2/" rel="bookmark">
			win11安装open-ssh server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		帮助链接：
安装 OpenSSH | Microsoft Learn
step1: 本机管理模式的power shell下查询安装状态
Get-WindowsCapability -Online | Where-Object Name -like 'OpenSSH*' Name : OpenSSH.Client~~~~0.0.1.0 State : Installed Name : OpenSSH.Server~~~~0.0.1.0 State : NotPresent step2: 上面表示openssh server还没有安装，进行安装
Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0
Install the OpenSSH Server 0 [main] install 16324 find_fast_cwd: WARNING: Couldn't compute FAST_CWD pointer. Please report this problem to the public mailing list cygwin@cygwin.com /usr/bin/install: target `Server' is not a directory PS C:\Users\pota&gt; Add-WindowsCapability -Online -Name OpenSSH.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfd7a8f03bea47fb84ced9cd635e4fd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de3f5e80c1e576b2dd1d2bcc4aa3110/" rel="bookmark">
			Excel VBA编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前两天我朋友找我帮忙，让给excel做个按钮功能，方便他们表格统计，我晚上研究了一下给他做出来了，这里记录一下入门操作和大概思路，具体怎么写VBA的代码我就不记录了，那玩意儿看教程去吧，也不是这一篇博客能讲完的，对于做开发的来说很简单，看一下就会了，不会做开发的同学就去B站找VBA的教程，跟着教程一步一步学吧。
vba编程，简单来说就是excel自带的一种编程语言，是用来方便扩展excel的功能及业务的，让用户完全可以自定义功能，自己开发出自己想要的东西，比如你想加个按钮，加个弹框，用最简单的操作来实现excel原本复杂且重复的操作。
1.想要实现vba开发，首先得要excel支持这个功能，默认一般是关闭的，所以需要我们先把开发工具这个选项给打开：
文件 &gt; 选项 &gt; 自定义功能区 &gt; 勾选开发工具（勾选保存后，在excel文件上方，就可以看到开发工具的选项）
开发工具开放后，还需要启用宏：
文件 &gt; 选项 &gt; 信任中心 &gt; 信任中心设置 &gt; 宏设置 &gt; 选择"启用所有宏"
2.添加宏
所谓的宏，也懒得讲什么官话，网上一搜就有，简单说就是，你就理解成一个功能代码块，一个宏，就是一个功能的代码。
比如现在的需求是做两个按钮，每个按钮有不同的功能，首先要做的就是添加宏代码，选择：
开发工具 &gt; 宏
或者按Alt+F11也行，会弹出开发界面，下图中添加了button1和button2两个宏
写代码这里可以大概分为三个地方：
附上代码：
Sub button1() '获取所选单元格 Dim x As Integer, y As Integer, tableCell As String x = Selection.Row() y = Selection.Column() f = Replace(Mid(Cells(1, y).Address, 2, 2), "$", "") ' 由列数得到列标 tableCell = f &amp; x '给单元格填写系统当前时间 Dim finishTime As String finishTime = Range(tableCell).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de3f5e80c1e576b2dd1d2bcc4aa3110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9985a4dab6a6400912d6d7681b112949/" rel="bookmark">
			Vue.config.js 配置项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue.config.js 学习 vue.config.js 是什么？ 他是vue项目的可选配置文件，在启动vue项目时会自动加载（修改该配置文件后，需重启vue项目。）
属性 productionSourceMap （布尔值） 是否需要将每一个js文件都多生成一个 .map文件。true：生成、false：不生成
因为打包后为压缩代码体积，都会进行压缩加密处理。如果出现报错情况，不好知道问题报错的位置，那么.map就可以准确的输出错误行。但是使用productionSourceMap会大大加代码的体积。
publicPath （字符串路径） 部署路径：默认打包打包到根目录，例如：百度一下，你就知道，如果该运用需要部署到子路由上，如：https://www.baidu.com/mode/ ，则将publicPath：/mode/
outputDir（字符串） 当运行 vue-cli-service build 时，默认会将outputDir的值作为文件容器进行打包，默认：outputDir: 'dist'
assetsDir（字符串） 用于打包后存放静态资源（ js、css、img、fonts ）的文件容器名称（相对 outputDir 目录内）
indexPath（字符串路径） 指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径。
filenameHashing（布尔值） 在 vue-cli-service build 时，是否将文件名追加hash值：如：mode.f123123d.js·以便更好的控制缓存
注意：这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 false 来关闭文件名哈希
pages（对象） 理解：每一个页面应用、组件都有它对应的（css、js、html）入口，通过 pages 我们可以设置每个页面或组件的文件入口。
事例：
module.exports = { pages: { index: { // page 的入口 entry: 'src/index/main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9985a4dab6a6400912d6d7681b112949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96fb63554bb4645b2ee991e3cd73f92b/" rel="bookmark">
			近期学习论文总结 2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号：EDPJ
目录
0. 摘要
1. Artificial Fingerprinting for Generative Models: Rooting Deepfake Attribution in Training Data
1.1 核心思想
1.2 步骤
2. HyperDomainNet: Universal Domain Adaptation for Generative Adversarial Networks
2.1 核心思想
2.2 Training Loss
2.3 泛化
3. Data-Efficient Instance Generation from Instance Discrimination 3.1 核心思想
3.2 步骤
3.3 消融实验
4. MIND THE GAP: Domain Gap Control for Single Shot Domain Adaptation for Generative Adversarial Networks 4.1 核心思想
4.2 步骤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96fb63554bb4645b2ee991e3cd73f92b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff877eff092373e1ddac8835e063a5e/" rel="bookmark">
			c&#43;&#43;基础编程学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跟着黑马视频学的
1.水仙花数（do……while实现）
#include &lt;iostream&gt; using namespace std; int main() { int num = 100; do { int a, b, c; a = num / 100; c = num % 10; b = num % 100 / 10; int sum = a*a*a + b*b*b + c*c*c; if (sum == num) { cout &lt;&lt; num &lt;&lt; endl; } num++; } while (num &lt; 1000); } 2.for循环
敲桌子
从1开始数到数字100， 如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。
#include &lt;iostream&gt; using namespace std; int main() { for (int i = 1; i &lt;= 100 ; i++) { if (i / 10 == 7 || i % 10 == 7 || i % 7 == 0) { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bff877eff092373e1ddac8835e063a5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13fa293cb6cebe30c8f36cca60463ba6/" rel="bookmark">
			网络编程原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.局域网
二.网络通信基础
（1）IP地址
（2）端口号
（3）协议
（4）五元组
（5）协议分层
1.分层的作用
2.OSI七层模型
(6)封装和分用
一.局域网 交换机：组建局域网。
路由器：把局域网来接起来。（WiFi的本质就是个无线路由器）
广域网：通过路由器将局域网连接起来，就形成了广域网。
节点：上述设备的统称，任何一个连入网络的交换机、路由器、电脑都可以称为“节点”。
相邻节点：通过一根网线连接起来的节点。
二.网络通信基础 （1）IP地址 IP：用来定义主机的网络地址（格式是32位的二进制数）
特殊IP：本机环回IP，通常是127.0.0.1
作用：IP地址解决了网络通信时，定位网络主机的问题。
（2）端口号 端口号：用于定义主机中的进程。（类似于发快递，不仅需要收货地址（IP地址），还需要收件人（端口号））
（3）协议 概念：网络数据传输经过的所有网络设备都必须遵从的一组约定。（规定数据传输时的数据格式）
三要素：
1.语法：数据的结构与格式
2.语义：发出信息和做出回应的规定
3.时序：事件实现的顺序
网络通信信号传递：
1.电信号（网线）
2.光信号（光纤、电磁波）
都可以传递信息：对于电信号，可以用低电平表示1，高电平表示0
对于光信号，可以使用高频光表示1，低频光表示0
（4）五元组 在TCP/IP协议中，用五元组来标识一个网络通信
（5）协议分层 1.分层的作用 实际的网络通信很复杂，需要分更多的层次。
面向接口编程：定义好两层之间的接口规范，让双方遵循这个规范来对接。
2.OSI七层模型 物理层：约定了网络通信中的基本硬件设备（网线、网口）
数据链接层：主要负责相邻两个节点之间，具体怎么进行传输
网络层：主要负责路径的规划，走那条路比较划算
传输层：起点和终点，端到端之间的传输
应用层：描述了传输的数据，用户要怎样使用
传输层：系统内核
(6)封装和分用 举例：用户在输入框输入hello的程序运行过程（封装和分用）
输入方：
1.应用层
协议：“应用层数据报”（本质上是遵循了预定格式的字符串）
2.传输层
把上述的应用层数据，构造成传输层数据报
传输层使用的协议，最知名的就是UDP和TCP，需要构造出UDP报头（在应用层数据模型基础上加一个UDP报头）
3.网络层
最知名的协议：IP协议，基于上述数据，打包成一个IP数据报
IP报头也相当于一个字符串，包含了一组最核心的信息（源IP和目的IP） 4.数据链接层
最知名的协议：以太网
基于以上数据，打包成一个“以太网数据帧”
接收方
1.物理层：网卡接收到的是光信号和电信号，在物理层把广电信号转换回二进制的数据。
2.把数据交给数据链路层解析，数据链路层去掉帧头帧尾，交给上层网络层
3.网络层：IP协议解析IP报头，把得到的传输数据报交给上层传输层
4.传输层：UDP解析，取出报头，取出载荷，交给对应的应用层程序
5.应用层：qq应用程序，qq争对应用层协议进行解析，显示到界面上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc236293be5d278417dca16c961324ca/" rel="bookmark">
			华为ensp本地AAA配置实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于本实验
本实验要求将路由器AR1 配置为AAA服务器，以本地认证方式对尝试登求ARI的用户进行身份认证和授权。路由器AR2作为登录用户(AAA客户端)，以Telnet的方式登录AR1。读者需要在AR1中创建一个名为 datacom 的管理员域，并创建两个本地用户，允许这两个本地用户进行Telnet 登录，并且用户1 (hcia-admin) 能够进入系统视图实施配置和调试，用户2 (hcia-user) 不能进入系统视图。
实验目的 ● 掌握AAA本地认证的配置方法。
● 掌握AAA本地授权的配置方法。
● 掌握AAA维护的方法。
实验组网介绍
实验拓扑图如下
使用的网络地址 设备接口IP地址子网掩码默认网关R1G0/0/010.10.12.1255.255.255.0——R2G0/0/010.10.12.2255.255.255.0—— 实验任务列表
配置任务1：配置hcia-admin 用户AAA用户本地认证
配置任务2：配置hcia-operator 用户AAA本地认证
一. 配置hcia-admin 用户AAA用户本地认证
步骤1 基本配置
完成R1的基础配置
1. system-view
2. un in en //此命令是取消信息提示
3. sysname R1
4. interface GigabitEthernet 0/0/0 //此命令可以缩写成：int g0/0/0
5. ip address 10.10.12.1 24
完成R2的基础配置
1. sys
2. un in en
3. int g0/0/0
4. ip add 10.10.12.2 24
配置完成后，可以使用ping命令来验证两台设备之间的连通性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc236293be5d278417dca16c961324ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4465bc4c24c721d4310534549d65b24/" rel="bookmark">
			关于误删系统PATH值之后，解决办法3种，推荐按步骤来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.先打开Dos命令窗口
输入echo %path%
此方法行不通之后，第2种方法如下
2.利用注册表中path缓存找回
找到HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment 复制路径添加即可，此方法不行之后，最后第3种方法
3.当注册表中的缓存也没有时候 【此电脑-&gt;属性-&gt;高级系统设置-&gt;系统保护-&gt;系统还原】
点击系统还原，待电脑重启之后就能找回原来的系统PATH值。
注意：此方法可能会影响到最近安装的软件，慎用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b02dccda961d204afa860a3f4642a2/" rel="bookmark">
			AttributeError: ‘Text‘ object has no property ‘FontProperties‘解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在试跑《机器学习实战》一书中的K-NN算法时，遇到了错误：AttributeError: 'Text' object has no property 'FontProperties'
具体情况为：
经检查发现原因为：在给图标标题设置标签时，出现了大小写的错误。FronProperties应改为：全小写的fronproperties。
※※※----注意：只有在开始设置标签时才需要将FronProperties应改为：全小写的fronproperties在引入字体属性和配置字体路径时，依旧是FronProperties -------------※※※
#引入字体属性模块 from matplotlib.font_manager import FontProperties # 设置汉字格式 font = FontProperties(fname=r"c:\windows\fonts\simsunb.ttf", size=14) #设置标题,x轴label,y轴label axs0_title_text = axs[0][0].set_title(u'每年获得的飞行常客里程数与玩视频游戏所消耗时间占比',fontproperties=font) axs0_xlabel_text = axs[0][0].set_xlabel(u'每年获得的飞行常客里程数',fontproperties=font) axs0_ylabel_text = axs[0][0].set_ylabel(u'玩视频游戏所消耗时间占比',fontproperties=font) plt.setp(axs0_title_text, size=9, weight='bold', color='red') plt.setp(axs0_xlabel_text, size=7, weight='bold', color='black') plt.setp(axs0_ylabel_text, size=7, weight='bold', color='black') 这样就OK啦~成功运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9d3dd990c5f9a29d7e939f076d026b/" rel="bookmark">
			c&#43;&#43;删除字符串中所有换行和空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 static inline void StringTrans(std::string&amp; s) { // 删除所有换行 std::string::size_type r = s.find('\r\n'); while (r != std::string::npos) { if (r != std::string::npos) { s.replace(r, 1, ""); r = s.find('\r\n'); } } //删除所有空格 s.erase(std::remove(s.begin(), s.end(), ' '), s.end()); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dfb9db83bfc4037319b1cf5058d40f/" rel="bookmark">
			算法基础--MD5算法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、简介 MD5再开发过程中经常碰到的一种算法，因此感觉有必要对其原理进行更深入的了解一下。
2、算法概念 散列函数，也称作哈希函数，消息摘要函数，单向函数或者杂凑函数。散列函数主要用于验证数据的完整性。通过散列函数，可以创建消息的“数字指纹”，消息接收方可以通过校验消息的哈希值来验证消息的完整性，防止消息被篡改。散列函数具有以下特性：
散列函数的运算过程是不可逆的，这个称为散列函数的单向性。对于一个已知的消息及其散列值，要找到另外一个消息使其获得相同的散列值是不可能的，这个特性称为散列函数的弱碰撞性。这个特性可以用来防止消息伪造。任意两个不同消息的散列值一定不同。对原始消息长度没有限制。
任何消息经过散列函数处理后，都会产生一个唯一的散列值，这个散列值可以用来验证消息的完整性。计算消息散列值的过程被称为“消息摘要”，计算消息散列值的算法被称为消息摘要算法。MD5算法是Hash算法的一种，叫做消息摘要算法。所谓摘要，从字面意思理解，是指内容的大概。在MD5算法中，这个摘要是指将任意数据映射成一个128位长的摘要信息。并且其是不可逆的，即从摘要信息无法反向推演中原文，在演算过程中，原文的内容也是有丢失的。因为MD5算法最终生成的是一个128位长的数据，从原理上说，有2^128种可能，这是一个非常巨大的数据，约等于3.4乘10的38次方，虽然这个是个天文数字，但是世界上可以进行加密的数据原则上说是无限的，因此是可能存在不同的内容经过MD5加密后得到同样的摘要信息，但这个碰中的概率非常小。
3、应用场景 MD5常用在密码加密中，一般为了保证用户密码的安全，在数据库中存储的都是用户的密码经过MD5加密后的值，在客户端用户输入密码后，也会使用MD5进行加密，这样即使用户的网络被窃听，窃听者依然无法拿到用户的原始密码，并且即使用户数据库被盗，没有存储明文的密码对用户来说也多了一层安全保障。MD5签名技术还常用于防止信息的篡改。使用MD5可以对信息进行签名，接收者拿到信息后只要重新计算签名和原始签名进行对比，即可知道数据信息是否中途被篡改了。
4、算法原理 假设原始消息长度是b（以bit为单位），注意这里b可以是任意长度，并不一定要是8的整数倍。计算该消息MD5值的过程如下：
信息填充 在计算消息的MD5值之前，首先对原始信息进行填充，这里的信息填充分为两步。
填充原始信息：对原始信息进行填充，填充之后，要求信息的长度对512取余等于448。填充的规则如下：假设原始信息长度为b bit，那么在信息的b+1 bit位填充1，剩余的位填充0，直到信息长度对512取余为448。这里有一点需要注意，如果原始信息长度对512取余正好等于448，这种情况仍然要进行填充，很明显，在这时我们要填充的信息长度是512位，直到信息长度对512取余再次等于448。所以，填充的位数最少为1，最大为512。填充信息长度：填充信息长度，我们需要把原始信息长度转换成以bit为单位，然后在第一步操作的结果后面填充64bit的数据表示原始信息长度。第一步对原始信息进行填充之后，信息长度对512取余结果为448，这里再填充64bit的长度信息，整个信息恰好可以被512整除。其实从后续过程可以看到，计算MD5时，是将信息分为若干个分组进行处理的，每个信息分组的长度是512bit。 信息处理 信息分组定义
原始信息经过填充之后，最终得到的信息长度（bit）是512的整数倍，我们先对信息进行分组，每512bit为一个分组，然后再将每个信息分组（512bit）再细分为16个小的分组，每个小分组的长度为32bit。规定如下Mp 代表经过填充之后的信息LM 表示Mp的长度（以bit为单位）N 表示分组个数，N = LM/512M[i] 表示将原始信息进行分组后的第i个信息分组，其中i=1…NX[i] 表示将M[i]进行分组后的第i个小分组，其中i=1…16 标准幻数定义 现定义四个标准幻数如下，
A = 01 23 45 67B = 89 ab cd efC = fe dc ba 98D = 76 54 32 10
在计算机中存储时，采用小端存储方式，以A为例，A在Java中初始化的代码为为A=0x67452301 常量表T T是一个常量表，T[i] = 4294967296 * abs(sin(i))的运算结果取整，其中i=1…64
辅助方法 T我们定义四个辅助方法。
F(x,y,z) = (x &amp; y) | ((~x) &amp; z)G(x,y,z) = (x &amp; z) | (y &amp; (~z))H(x,y,z) = x ^ y ^ zI(x,y,z) = y ^ (x | (~z))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89dfb9db83bfc4037319b1cf5058d40f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c8d723366d33c73b6fc085d3c1acc7/" rel="bookmark">
			springboot 当前时间戳转日期时间 时间戳和日期时间 互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 将日期格式转换成时间戳 public static void main(String[] args) throws Exception{ String time = "2023-05-12 12:30:59"; Date parse = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(time); Long time1 = parse.getTime(); System.out.println(time + " ---&gt; " + time1); } // 将时间戳转换成日期格式 public static void main(String[] args) { Long time = 1527996283000L; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String time1 = sdf.format(new Date(time)); System.out.println(time + " ----&gt; " + time1); } // 当前时间 转 北京时间 日期时间 Date times = new Date(); SimpleDateFormat timesFormat = new SimpleDateFormat("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76c8d723366d33c73b6fc085d3c1acc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69ca59ccd22a0bcdee381f95e4965f82/" rel="bookmark">
			史上最全关于C&#43;&#43;类和对象详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类和对象 前言 在C++中,面向对象有三大核心,分别是封装,继承和多态。
C++中一般用类和对象来进行封装。
类和对象是面向对象编程中的基础概念。类是一个抽象的概念，用于描述一类对象共有的属性和行为。而对象是类的实例，具有该类所描述的属性和行为。
类和对象是什么 类可以看作是一个模板，它定义了对象的属性和行为，并为我们提供了定义对象时所需要的具体信息。它包括数据成员和成员函数两部分。数据成员用于描述对象的属性，成员函数则用于描述对象的行为。
类相当于一个蓝图，它们规定了所有同类对象的共同特征，即这些对象具有相同的属性和相同的行为。而对象则是这个蓝图在现实世界中的具体实例。
举个例子，我们可以定义一个类叫做“人”，这个类有属性和行为，比如姓名、性别、年龄、说话、吃饭等。当我们需要描述一个具体的人时，我们就可以创建一个“人”的对象，例如“张三”就是一个“人”的对象。
类和对象是面向对象编程的基础，它们提供了一种结构化、模块化和抽象的方式来描述现实世界中的事物，是面向对象编程的关键所在。
案例 例如:
//在C++中,用class是一种定义类的关键字。使用class关键字定义一个类的语法如下: class ClassName{ public: //访问限定符 int member1; char member2; float member3; void Print{ cout&lt;&lt;"测试"&lt;&lt;endl; } } 其中,ClassName是你所定义的类名称,public是访问限定符,在C++中,访问限定符一共有三个.
分别是:(public,private,protected).在这里,我们先不展开去详解,后面我们会特地去讲解.这里可以简单把它理解成一种访问变量的权限,就像是平时生活中的所谓的会员.
接着往下看,简而易见,就是定义变量和函数,跟平时C++中定义结构体的写法没啥区别,这里只是在场景搬到类里面.以上就是声明一个类的基本写法.
定义对象:
//这里定义了一个对象 ClassName p; //在main函数中,我们使用(.)来调用对象的成员函数 //访问的对象成员. //例如 p.Print(); p.member1(); this指针 在 C++ 中，this 是一个指向当前对象的指针。每个对象都有自己的 this 指针，它指向这个对象的地址。this 指针是在对象被创建时隐含地传递给成员函数的，可以用来访问对象的数据成员和成员函数。
this 指针的用法有如下几种：
1. 访问对象的数据成员 在 C++ 中，对象的数据成员和成员函数都是在对象内存空间中的。因此，在成员函数中可以通过 this 指针来访问对象的数据成员。例如：
class MyClass { public: void func() { this-&gt;data_member = 10; // 使用 this 指针访问对象数据成员 } private: int data_member; }; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69ca59ccd22a0bcdee381f95e4965f82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5534cf7059641f864f5ab201662c27c/" rel="bookmark">
			从零开始学习JVM（六）-直接内存和执行引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 直接内存介绍 直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。直接内存是在Java堆外的、直接向系统申请的内存空间。直接内存来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存。通常访问直接内存的速度会优于Java堆。即读写性能高。
因此出于性能考虑，读写频繁的场可能会考虑使用直接内存。Java的NIO库允许Java程序使用直接内存，用于数据缓冲区。
1.1 非直接缓冲池 使用IO读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。
1.2 直接缓冲池 使用NIO时，操作系统划出的直接缓存区可以被Java代码直接访问，只有一份。NIO适合对大文件的读写操作。
直接内存不足也可能导致OutOfMemoryError异常，由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。
直接内存大小可以通过MaxDirectMemorySize设置，如果不指定，默认与堆的最大值-Xmx参数值一致。
使用直接内存的缺点：分配回收成本较高和不受JVM内存管理
直接内存不足导致的OOM代码示例：
public class MaxDirectMemorySizeTest02 { private static final int BUFFER = 1024 * 1024 * 20; public static void main(String[] args) { ArrayList&lt;ByteBuffer&gt; list = new ArrayList&lt;&gt;(); int count = 0; try { while (true) { ByteBuffer buffer = ByteBuffer.allocateDirect(BUFFER); list.add(buffer); count++; try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } } finally { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5534cf7059641f864f5ab201662c27c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e891eb2f27e9442b7fc1a928dda864e9/" rel="bookmark">
			从零开始学习JVM（五）-运行时数据区的方法区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 方法区基本介绍 官方文档：The Java® Virtual Machine Specification
《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。所以方法区看作是一块独立于Java堆的内存空间。JVM的运行时数据区结构图如下：
从线程共享与否的角度来看JVM的内存区域：
方法区与Java堆一样，是各个线程共享的内存区域。方法区在JVM启动的时候被创建，并且它的实际物理内存空间中和Java堆区一样都是可以不连续的。方法区的大小跟堆空间一样，可以选择固定大小或者可扩展。当关闭JVM就会释放这个区域的内存。
方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError:PermGen space(jdk1.7之前)或者java.lang.OutOfMemoryError:Metaspace(jdk1.8之后).
初始化一个对象对于在JVM内存分配区域如下：
对于一个对象在JVM中关于栈、堆、方法区的交互关系图如下：
2. Hotspot中方法区的演进 在jdk1.7及以前，习惯上把方法区称为永久代，从jdk1.8开始，使用元空间取代了永久代。
本质上，方法区和永久代并不等价，仅是对Hotspot而言的。《Java虚拟机规范》对如何实现方法区不做统一要求。例如：BEA JRockit/IBM J9不存在永久代的概念。现在来看，当年使用永久代，不是好的idea。这容易导致程序OOM（超过XX:MaxPermSize上限）
Hotspot到了JDK8，终于完全废弃了永久代的概念，改用了与JRockit、J9一样在本地内存中实现的元空间来代替。
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：元空间不在虚拟机设置的内存中，而是使用本地内存。永久代、元空间二者并不只是名字变了，内部结构也调整了。根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。
3. 设置方法区大小与OOM解决思路 3.1 设置方法区大小 方法区的大小不是固定的， JVM可以根据应用的需要动态调整。
jdk7及以前
通过-XX:PermSize来设置永久代初始分配空间。默认值是20.75M，通过-XX:MaxPermSize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M。当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError:PermGen space。
jdk8及以后
元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定默认值依赖于平台。Windows下，-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1 //即没有限制。与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace-XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。 3.2 如何解决OOM OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。 4. 方法区的内部结构 《深入理解Java虚拟机》书中对方法区存储内容描述如下：
它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器(Just-In-Time Compiler,即时编译器)编译后的代码缓存等。
（1）类型信息
对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：
这个类型的完整有效名称（全名=包名.类名）这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）这个类型的修饰符（public，abstract，final的某个子集）这个类型直接接口的一个有序列表 （2）域（Field）信息
JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）
（3）方法（Method）信息
JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：
方法名称方法的返回类型（或void）方法参数的数量和类型（按顺序）方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）异常表（abstract和native方法除外） 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引 （4）non-final的类信息
静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分类变量被类的所有实例共享，即使没有类实例时，你也可以访问它 public class MethodAreaTest { public static void main(String[] args) { Order order = new Order(); order.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e891eb2f27e9442b7fc1a928dda864e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f9648540a50b82ff273eef1827aecd5/" rel="bookmark">
			【Java】volatile和内存屏障
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内存不可见的现象volatile内存可见性和有序性缓存一致性协议(MESI)内存屏障 原子性 虽然synchronized可以解决原子性和内存可见性问题，但 在解决内存可见性时并没有真正通过线程间通信解决，同时 也没有解决有序性问题。所以来看一个新的关键字 volatile。 内存不可见的现象 先重现一个内存可见性问题。创建两个线程，一个线程不断的循环判断标识决定是否退出，另外一个线程来修改标识位。
public class Demo01_Volatile { private static int flag = 0; public static void main(String[] args) throws InterruptedException { //定义一个线程 Thread t1 = new Thread(() -&gt; { System.out.println("t1线程已启动.."); //循环判断标识位 while (flag == 0){ //TODO: } System.out.println("t1线程已退出.."); }); //启动线程 t1.start(); //定义第二个线程，来修改flag的值 Thread t2 = new Thread(() -&gt; { System.out.println("t2线程已启动.."); System.out.println("请输入一个整数："); Scanner scanner = new Scanner(System.in); //接收用户输入并修改flag的值 flag = scanner.nextInt(); System.out.println("t2线程已退出.."); }); //确保t1先启动 TimeUnit.SECONDS.sleep(1); //启动线程 t2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f9648540a50b82ff273eef1827aecd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0271f79fd5a617559b39484fd6521483/" rel="bookmark">
			（2021，FastGAN）用于高保真 few-shot 图像合成的更快、更稳定的 GAN 训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Towards faster and stabilized gan training for high-fidelity few-shot image synthesis
公众号：EDPJ
目录
0. 摘要
1. 简介
2. 相关工作
3. 方法
3.1 跳跃层通道激励 3.2 自监督判别器 4. 实验 4.1 图像合成性能
4.2 更多分析与应用
5. 结论
参考
附录
A. 跳层激励带来的性能提升
B. 判别器的特征提取性能
C. 不同分辨率下的风格混合 S. 总结
S.1 核心思想
S.2 模块架构
S.3 Loss
S.4 分析
0. 摘要 在高保真图像上训练生成对抗网络 (GAN) 通常需要大规模 GPU 和大量训练图像。 在本文中，我们以最小的计算成本研究了 GAN 的 few-shot 图像合成任务。 我们提出了一种轻量级 GAN 结构，可在 1024x1024 分辨率上获得卓越的质量。 值得注意的是，该模型仅需在单个 RTX-2080 GPU 上从头开始进行几个小时的训练即可收敛，并且具有一致的性能，即使训练样本少于 100 个也是如此。 两种技术设计构成了我们的工作，一个跳跃层通道激励模块（skip-layer channel-wise excitation module）和一个作为特征编码器训练的自监督鉴别器。 通过涵盖各种图像域的 13 个数据集，当数据和计算预算有限时，我们展示了我们的模型与最先进的 StyleGAN2 相比的卓越性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0271f79fd5a617559b39484fd6521483/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e4abe5125e85cea1324391e6213f68c/" rel="bookmark">
			（2022，FreGAN）利用频率分量在有限数据下训练 GAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FreGAN: Exploiting Frequency Components for Training GANs under Limited Data
公众号：EDPJ
目录
0. 摘要
1. 简介
2. 相关工作
3. 方法
3.1 小波变换 3.2 高频鉴频器 3.3 跳频连接（Frequency Skip Connection，FSC） 3.4 高频对齐（High-Frequency Alignment，HFA）
3.5 优化
4. 实验
4.1 主要结果
4.2 消融研究 4.3 兼容性与 GAN 平衡（equilibrium）分析 5. 讨论 参考
A. 附录
A.1 更多实现细节
S. 总结
S.1 核心思想
S.2 方法
S.3 优化
0. 摘要 在有限数据下训练 GAN 通常会导致判别器过度拟合和记忆问题，从而导致训练发散。 现有方法通过使用数据扩充、模型正则化或注意力机制来减轻过度拟合。 然而，他们忽略了 GAN 的频率偏差，对频率信息尤其是包含丰富细节的高频信号考虑得很少。 为了充分利用有限数据的频率信息，本文提出了FreGAN，提高了模型的频率感知能力，更加关注高频信号的产生，有利于高质量的生成。 除了利用真实图像和生成图像的频率信息外，我们还将真实图像的频率信号作为自监督约束，这减轻了 GAN 的不平衡并鼓励生成器合成足够的而不是任意的频率信号。 广泛的结果证明了我们的 FreGAN 在改善低数据条件下的生成质量方面的优越性和有效性（尤其是当训练数据少于 100 时）。 此外，FreGAN 可以无缝应用于现有的正则化和注意机制模型，以进一步提升性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e4abe5125e85cea1324391e6213f68c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a15c2c80a204dfd3697630bdef4444a/" rel="bookmark">
			升级pip——报错解决“You should consider upgrading via the ‘pip install --upgrade pip‘ command.”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用pip安装pybullet时，会出现黄色提示表示我们的pip版本太低，需要升级
You are using pip version 8.1.1, however version 23.1.2 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.
但是当我们按照黄色字体提示，在终端输入“pip install --upgrade pip” 时，终端还是会报错
Command "python setup.py egg_info" failed with error code 1 in /tmp/pip-build-RdvD44/pip/
下面我们给出解决方法： 一、升级pip 在终端输入：
sudo wget https://bootstrap.pypa.io/pip/2.7/get-pip.py sudo python get-pip.py pip -V (下面的黄色提示不用管它)
出现问题： pip -V报错“/usr/bin/pip: 没有那个文件或目录” 在终端输入
// 清除缓存 hash -r 如何还是不行，就尝试更新一下
sudo apt-get update sudo apt-get upgrade 二、升级pip3 在终端输入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a15c2c80a204dfd3697630bdef4444a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edde765ca5986be1cf7630b36aa0c74a/" rel="bookmark">
			pinia数据持久化插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 前段时间用vue3、vite4、pinia、ts做一个后台系统，在状态管理方面需要实现持久化，防止刷新丢数据，一开始在网上找，找了几个插件，发现要么不支持加密，需要另外安装加密插件，要么就是不能更改缓存方式，例如只能用localStorage，就这些问题我就萌生了自己写一个插件的想法。
开始 首先我们知道利用use方法可以把整个状态传到自定义个方法里面，例如下面这段代码。
import { createPinia } from "pinia" // 1 引入数据持久化插件 import stateForever from "stateForever" const store = createPinia() // 2 pinia使用数据持久化插件 store.use(stateForever) export default store use我们这个方法之后会把整个状态传给我们自定义的方法里面，接下来写一个方法接受这个参数
const stateForever = (stateOptions) =&gt; { const { options, store } = stateOptions const { persist } = options } export default stateForever 其中persist是后面我们需要用到的配置在pinia里面的对象。
这样在stateForever这个方法里面就能拿到了整个状态内容，加密方式使用base64方式，有兴趣的道友可以看一下源码，写的不好的地方，请大佬指正一下。
下面是插件介绍
本插件主要使用了pinia的发布订阅功能，加载的时候读取缓存中的数据写入到pinia里面，当状态发生变化时在存到缓存里面，因此完成了状态数据实时缓存，再说一下加密，本插件使用了base64加密方式encrypt设置为true时, 将对数据进行加密缓存。
使用方法：在状态中state同级别下设置persist对象，该对象可设置四个属性，分别是key——自定义存储id，默认为当前状态id，即store.$id，storage——缓存方式， 默认以sessionStorage方式持久化，encrypt—— 是否加密，默认不加密，paths——设置state中的状态持久化，不设置或者设置为true则持久化当前全部状态。
概要 一个轻量级的可加密的pinia持久化插件
A lightweight and encrypted pinia persistence plug-in
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edde765ca5986be1cf7630b36aa0c74a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7608213dd7cde2dc114543a2caa9a17e/" rel="bookmark">
			pandas join表的拼接操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Relational Connection`merge` Index ConnectionDirectional Connection`concat``append` and `assign` Operation similar to connection`compare``combine` Relational Connection merge df1.merge(df2, on, how) df.merge(dsf2, left_on, right_on, how) df1.merge(df2, on, how, suffixes) on is a column or a list, the base columns of merging. Similarly, left_on for left table, right_on for right table. how is a str in [‘left’, ‘right’, ‘inner’, ‘outer’], default ‘inner’ suffixes is a list with two suffixes,
used to distinguish columns with same name in different tables.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7608213dd7cde2dc114543a2caa9a17e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd8cfa73c2def23f18835d0e7f05adc/" rel="bookmark">
			python中的时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 认识时间戳认识python的time模块与常用方法datetime包生成时间戳与时间戳转时间类型的方法 认识时间戳 1970年1月1日00时00分00秒至今的总毫秒(秒)数timestampfloat类型 time模块与他的函数们 时间处理，转换时间格式生成时间戳函数time获取本地时间函数localtimelocaltime对应字段介绍暂停时间函数sleeptime中的strptime和strftime 生成时间戳函数time 导入包: import time 使用方法: time.time() 返回值: 秒级别的浮点类型 举例: 1580878485.4009378 获取本地时间函数localtime 导入包: import time 使用方法: time.localtime(timestamp) 参数介绍∶ timestamp :时间戳(可不传) In [22]: In [1]: import time ...: ...: In [2]: t = time.localtime() ...: ...: In [3]: t Out[22]: time.struct_time(tm_year=2023, tm_mon=6, tm_mday=3, tm_hour=11, tm_min=39, tm_sec=16, tm_wday=5, tm_yday=154, tm_isdst=0) localtime对应字段介绍 暂停函数sleep 导入包: import time 使用方法: time.sleep(second) 参数介绍: second :希望程序被暂停的秒数 time中的strftime 首先我们导入time模块。通过调用striftime,第一个参数是格式化的匹配规则。第二个参数是一个时间localtime对象。返回赋值给str_time变量。通过打印返回了符合参数中格式化标准的字符串。它的功能和datetime中的striftime完全一致，只是要负责转换的变量类型不同而已，一个处理的是datetime.datetime时间类型，另一个处理的是time.struct_time时间类型。导入包∶ import time 使用方法: time.strftime(format,t) 参数介绍: format: 格式化规范t : time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd8cfa73c2def23f18835d0e7f05adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45326b4bf4844b9b115b5be517fe1b71/" rel="bookmark">
			VBA for 循环、while 循环和 do...while 循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VBA 中的循环语句是一种可以让程序多次执行同一段代码的结构。循环语句可以有多种类型，例如 for 循环、while 循环和 do...while 循环。
以下是 VBA 中三种常见的循环语句的简单讲解：
1.For 循环 For 循环是一种常用的循环语句，它允许我们指定一个初始值和一个结束值，并且在循环中可以设置步长。示例代码如下： For i = 1 to 10 step 2 ' 代码块 Next i 上面的代码将会从 1 开始，每隔 2 个数字往上计数，直到 10 结束。在循环中可以加入代码块，例如： For i = 1 to 10 MsgBox(i) Next i 该代码将会弹出 1 到 10 的消息框。 2.While 循环 While 循环适用于需要反复执行某个特定代码块的情况。当满足条件时，代码块就会一直执行下去。示例代码如下： While i &lt; 10 ' 代码块 Wend 上述代码中的“i”为一个变量，只要该变量小于 10，代码块就会一直执行下去。 3.Do While 循环 与 while 循环类似，do while 循环也是重复执行某一段代码块，只要满足指定条件。示例代码如下： Do While i &lt; 10 ' 代码块 Loop 上述代码中的“i”为一个变量，只要该变量小于 10，代码块就会一直执行下去，直到 i &gt;= 10 时结束。 以上是 VBA 中三种常见的循环语句的简单讲解，当然还有其他类型，如 for each 循环等。在编写程序时，需要根据实际情况选择合适的循环语句，以便更加高效的完成任务 下面是常用方法及跳出循环 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45326b4bf4844b9b115b5be517fe1b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/550a4e4b376444154903109b7755b27e/" rel="bookmark">
			开放接口签名(Signature)实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开放接口签名(Signature)实现方案 既然是对外开放，那么调用者一定没有我们系统的Token，就需要对调用者进行签名验证，签名验证采用主流的验证方式，采用Signature 的方式。
字段
类型
必传
说明
appid
String
是
应用id
timestamp
String
是
时间戳
nonce
String
是
随机数、不少于10位
signature
String
是
签名
signature: 生成方式
将参数appId=wx123456789&amp;nonce=155121212121&amp;timestamp=1684565287668&amp;key=35AB7ECF665EF5EF44CF8640EC136300 进行拼接 key指的是appid对应的appSecret
将上述参数进行MD5加密
二、流程
1、通过应用设置模块添加应用分配appid和appsecret，针对不同的调用方分配不同的appid和appsecret。
2、加入timestamp（时间戳），有效时间内内数据有效。
3、 加入随机字符串，则认为接口为重复调用，返回错误信息（防止重复提交）。
4、加入signature，所有数据的签名信息。
三、实现
简单来说，调用者调用接口业务参数在body中传递，header中额外增加四个参数signature、appid、timestamp，随机字符串。
我们在后台取到四个参数，其后三个参数加上调用者分配的appSecret，使用字典排序并使用MD5加密后与第一个参数signature进行比对，一致既表示调用者有权限调用。
接口异常：
403
签名不一致
403
appId或appSecret不正确
422
参数timestamp不能为空
408
请求时间超过规定范围时间10分钟
422
随机串nonce不能为空
422
随机串nonce长度最少为10位
407
不允许重复请求
代码实现： 自定义注解： /** * 签名算法实现=&gt;指定哪些接口或者哪些实体需要进行签名 */ @Target({TYPE, METHOD}) @Retention(RUNTIME) @Documented public @interface Signature { //允许重复请求 boolean resubmit() default true; } 签名工具类： /** * 开放接口签名工具类 * @author ShawnWang * @datetime 2023-05-19 * @desc 接口校验工具类 * 生成有序map,签名，验签 * 通过appId、timestamp、appSecret做签名 * @menu */ @Slf4j public class SignUtil { /** * 生成签名sign * 加密前：appid=wx123456789&amp;nonce=155121212121&amp;timestamp=1684565287668&amp;key=35AB7ECF665EF5EF44CF8640EC136300 * 加密后：4CD98E261F46AA75E8935695C864A26D */ public static String createSign(SortedMap&lt;String, String&gt; params, String key){ StringBuilder sb = new StringBuilder(); Set&lt;Map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/550a4e4b376444154903109b7755b27e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77453f9f8d1cc497262a8418f7744c1d/" rel="bookmark">
			交叉熵损失CrossEntropyLoss
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在各种深度学习框架中，我们最常用的损失函数就是交叉熵，熵是用来描述一个系统的混乱程度，通过交叉熵我们就能够确定预测数据与真实数据的相近程度。交叉熵越小，表示数据越接近真实样本。
回到顶部
1 分类任务的损失计算 1.1 单标签分类 二分类
单标签任务，顾名思义，每个样本只能有一个标签，比如ImageNet图像分类任务，或者MNIST手写数字识别数据集，每张图片只能有一个固定的标签。二分类是多分类任务中的一个特例，因为二分类只有正样本和负样本，并且两者的概率之和为1，所以不需要预测一个向量，只需要输出一个概率值就好了。损失函数一般是输出经过sigmoid激活函数之后，采用交叉熵损失函数计算loss。
以上面猫狗二分类任务为例，网络最后一层的输出应该理解为：网络认为图片中含有这一类别物体的概率。而每一类的真实标签都只有两种可能值，即“不是这一类物体”和“是这一类物体”，这是一个二项分布，可能的取值为0或者1，而网络预测的分布可以理解为标签是1的概率。当网络的输出logits=2时，经过sigmoid得到为狗的概率是0.9，交叉熵损失loss=-1×log(0.9) - 0×log(0.1) ≈ 0.1。
多分类　在多分类任务中，利用softmax函数将多个神经元（神经元数目为类别数）输出的结果映射到对于总输出的占比（范围0~1，占比可以理解成概率值），我们通过选择概率最大输出类别作为预测类别。
上面为三分类任务，输出的logits向量对应三个类别，经过softmax后得到三个和为1的概率[0.9,0.1,0]。样本“剪刀”对应的真实分布为[1,0,0]，此时计算损失函数得loss = -1*log(0.9) - 0×log(0.1) - 0×log(0) ≈ 0.1。如果网络输出的概率为[0.1,0.9,0]，此时的交叉熵损失为loss= -1*log(0.1) - 0×log(0.9) - 0×log(0)= 1。上述两种情况对比，第一个分布的损失明显低于第二个分布的损失，说明第一个分布更接近于真实分布，事实也确实是这样。
1.2 多标签分类 多标签分类任务，即一个样本可以有多个标签，比如一张图片中同时含有“猫”和“狗”，这张图片就同时拥有属于“猫”和“狗”的两种标签。在这种情况下，我们将函数作为网络最后一层的输出，把网络最后一层的每个神经元都看做任务中的一个类别，以图像识别任务为例，网络最后一层的输出应该理解为：网络认为图片中含有这一类别物体的概率。而每一类的真实标签都只有两种可能值，即“图片中含有这一类物体”和“图片中不含有这一类物体”，这是一个二项分布。综上所述，对多分类任务中的每一类单独分析的话，真实分布是一个二项分布，可能的取值为0或者1，而网络预测的分布可以理解为标签是1的概率。此外，由于多标签分类任务中，每一类是相互独立的，所以网络最后一层神经元输出的概率值之和并不等于1。
上面的多标签分类任务有三个标签：狗，猫，猪。输入图片中没有猪，所以真实分布应该为：[ 1, 1, 0 ] 。
假设经过右图的网络输出的概率分布为：[ 0.95, 0.73, 0.05]，则我们可以对狗，猫，猪这三类都计算交叉熵损失函数，然后将它们相加就得到这一张图片样本的交叉熵损失函数值。
loss狗=-1×log(0.95)-(1-1)×log(1-0.95)≈0.05
loss猫=-1×log(0.73)-(1-1)×log(1-0.73)≈0.31
loss猪=-0×log(0.05)-(1-0)×log(1-0.05)≈0.05
loss总=loss狗+loss猫+loss猪=0.05+0.31+0.05=0.41
假设经过右图的网络输出的概率分布为：[ 0.3, 0.5, 0.7]，交叉熵损失损失为
loss狗=-1×log(0.3)-(1-1)×log(1-0.3)≈1.2
loss猫=-1×log(0.5)-(1-1)×log(1-0.5)≈0.7
loss猪=-0×log(0.7)-(1-0)×log(1-0.7)≈1.2
loss总=loss狗+loss猫+loss猪=1.2+0.7+1.2=3.1
由上面两种情况也可以看出，预测分布越接近真实分布，交叉熵损失越小，预测分布越远离真实分布，交叉熵损失越大。
回到顶部
2 损失函数的pytorch实现 Pytorch关于损失函数的内容，可以在官方文档torch.nn — PyTorch 1.10 documentation里找到。
2.1 nn.BCEloss BCEloss主要用于计算标签只有1或者0时的二分类损失，标签和预测值是一一对应的。需要注意的是，通过nn.BCEloss来计算损失前，需要对预测值进行一次sigmoid计算。sigmoid函数会将预测值映射到0-1之间。如果觉得手动加sigmoid函数麻烦，可以直接调用nn.BCEwithlogitsloss。
1
2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77453f9f8d1cc497262a8418f7744c1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64547a84e7eebb0ace107c8d2bd3b096/" rel="bookmark">
			IDEA创建maven项目报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.报错信息如下：
[Guice/ErrorInjectingConstructor]: NoSuchMethodError: DefaultModelValidator: method 'void &lt;init&gt;()' 2.个人通过在csdn上面的查找，发现了博主也出现了类似的错误：
文章链接如下：
(10条消息) 【IDEA创建Maven项目报错- Error injecting constructor, java.lang.NoSuchMethodError: org.apache.maven.model】_unable to provision_真.菜鸡的博客-CSDN博客
(10条消息) maven版本过高导致的致命无法解决错误之Maven环境搭建_程序彤的博客-CSDN博客
3.了解了问题所在：maven版本过高（3.9.2），与我的IDEA不匹配。
通过几篇文章的学习，知道了2021.3左右的IDEA的版本大概适用3.6.3的maven版本
因此开始重新下载旧版本的maven，放在新的文件夹里，因为个人比较谨慎，怕出错。
下载后解压到那个新文件夹。
进入高级系统设置里面的环境变量，把里面的MAVEN_HOME设置为对应的新版本的文件夹
如下：
然后把这个文件夹里面的conf文件夹（也就是配置）里面的settings.xml用记事本打开
把本地仓库和远程仓库配置一下，如下：
这个中间项就是本地仓库的路径
这个就是镜像仓库的信息，建议直接搜阿里云，然后在官网即可找到
搞完这个之后，直接这样子：
进入这个页面后，这样子：
然后再这样子：
右边的两个项，修改为
然后apply后ok，重新进入项目，不出意外问题就解决啦！！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94cb05283c7936dfa7715eb899007c4c/" rel="bookmark">
			视频推拉流 - python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，
最近的一个项目中，需要用python实现摄像头实时视频推流，代码写好后运行程序，始终会报错，说转码不对。
p.stdin.write(frame.tobytes()) 报错 后来查询大量资料，发现是因为pycharm环境下下载的ffmpeg包的版本太低，需要在conda环境下下载最新版本的ffmpeg
下面展示一下实现过程，方便大家学习。
1.首先打开我们的CMD
查询conda版本
conda --version 2.查看现有虚拟环境
conda info --envs 或者 conda env list 3.创建conda虚拟环境
conda create -name ceshi python=3.9 4.切换到ceshi的虚拟环境里面
conda activate ceshi 5.查看ceshi环境里面的库
conda list 下载opencv,和ffmpeg库（opencv库用的是pip）
pip install opencv-python //ffmpeg库需要使用conda环境下载
conda install ffmpeg 二，工程代码
1.进入工程
2.
3.
4.推流代码
#!/usr/bin/env python # -*- coding: utf-8 -*- # @Time : 2023/5/31 19:18 # @Author : LXL # @File : tuiliu.py import cv2 # subprocess 模块允许我们启动一个新进程，并连接到它们的输入/输出/错误管道，从而获取返回值。 import subprocess # 视频读取对象 cap = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94cb05283c7936dfa7715eb899007c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e82288ebc0f7c8c1b179cd1119e1fb79/" rel="bookmark">
			RK平台如何配置USB功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 RK平台基本能够通过dts配置就能实现USB功能。为了方便理解，我这里分三部分来介绍，包括：usb-phy，usb控制器，usb供电。
usb-phy usb-phy负责最底层的信号转换，主要是硬件的差分信号转换成数字信号传给usb控制器，然后再送到主控，其框架大概如下：
usb数据线 CPU usb controler usb-phy usb device 找原理图上的usb-phy 以rk3399的host口为例，我们先找到原理图上对应的usb口：
由原理图我们可以知道，rk3399有两个usb-phy，分别是PHY0和PHY1，一个usb-phy有两个port口，分别是typec口和host口，我们要配置的是PHY0下面的host口，确定好这个之后我们就可以去dts找对应的配置节点。
找dtsi中的usb-phy 在rk3399.dtsi中我们可以看到：
u2phy0: usb2-phy@e450 { compatible = "rockchip,rk3399-usb2phy"; reg = &lt;0xe450 0x10&gt;; clocks = &lt;&amp;cru SCLK_USB2PHY0_REF&gt;; clock-names = "phyclk"; #clock-cells = &lt;0&gt;; clock-output-names = "clk_usbphy0_480m"; power-domains = &lt;&amp;power RK3399_PD_PERIHP&gt;; status = "disabled"; u2phy0_host: host-port { #phy-cells = &lt;0&gt;; interrupts = &lt;GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH 0&gt;; interrupt-names = "linestate"; status = "disabled"; }; u2phy0_otg: otg-port { #phy-cells = &lt;0&gt;; interrupts = &lt;GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH 0&gt;, ┆ &lt;GIC_SPI 104 IRQ_TYPE_LEVEL_HIGH 0&gt;, ┆ &lt;GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH 0&gt;; interrupt-names = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e82288ebc0f7c8c1b179cd1119e1fb79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/436ff5c44bc001cb849cd386861292b6/" rel="bookmark">
			Vue中根据不同状态切换 Tabs 标签页内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大纲 📗 Avue具体方法如下： Tabs 组件用于包含多个标签页，每个标签页由 TabPane 组件表示。
v-model 可以控制当前激活的标签页（即默认展示出来的页面）。
📗 ElementUi具体方法如下： v-model —— 绑定值，选中选项卡name name —— 与选项卡绑定值 value 对应的标识符，表示选项卡别名 示例： &lt;template&gt; &lt;div&gt; &lt;el-tabs v-model="activeName" @tab-click="handleClick"&gt; &lt;el-tab-pane label="处理中" name="1"&gt;&lt;/el-tab-pane&gt; &lt;el-tab-pane label="审核" name="2"&gt;&lt;/el-tab-pane&gt; &lt;el-tab-pane label="完成" name="3"&gt;&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;avue-crud :option="option" :data="data" :page="page" v-model="form" ref="crud" @row-save="rowSave" @row-update="rowUpdate" @row-del="rowDel" &gt; &lt;/avue-crud&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import API from "@/components/common/newApi"; export default { data() { return { /* data:[]后端获取到的数据列表。option表格配置项.form 表单*/ data: [], //处理中data form: {}, //处理中 activeName: '1', status:3, option: { size: 'mini', //表格大小 medium/small/mini index: true, //序号 border: true, menu: false, stripe: true, //斑马纹 align: 'center', column: [{ label: '月份', prop: 'yearToMonth', type: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/436ff5c44bc001cb849cd386861292b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb824c5cf23e5f7f1deb453481e93b8/" rel="bookmark">
			matplotlib 同时显示两个figure
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求描述 想要实现的效果是在算法运行结束之后，同时显示多个数据图。
既不是阻塞的效果：关闭第一张图片，才会运行后续代码显示下一张图片；
也不是覆盖的效果：显示第二张图片时，会将第一张图片覆盖掉。
import matplotlib.pyplot as plt plt.figure(1) plt.plot(数据对象1) plt.figure(2) plt.plot(数据对象1) plt.show() 效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e709388c76242bc1324c745219bb3d9/" rel="bookmark">
			（2020，latent space）解释用于语义面部编辑的GAN的隐空间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Interpreting the Latent Space of GANs for Semantic Face Editing
公众号：EDPJ
目录
0. 摘要
1. 介绍
1.1 相关工作
2. InterFaceGAN 的框架
2.1 隐空间中的语义
2.2 隐空间中的操作
3. 实验
3.1 隐空间分离
3.2 隐空间操控 3.3. 条件操作
3.4 在 StyleGAN 上的结果
3.5 真实图像操作
4. 结论
一些想法
参考
0. 摘要 虽然生成对抗网络（Generative Adversarial Networks，GANs）是高保真度图像合成领域的先进技术，但是GAN如何把从随机分布中采样的隐编码（latent code）映射为逼真的图像，人们对此还没有充分的认知。先前的工作假设由GAN学到的隐空间（latent space）遵从一个分布式的表示（distributed representation），但可以进行向量运算。在本文，提出了一个新的架构，叫做InterFaceGAN，通过解释由GAN学到的隐语义（latent semantics），进行语义的面部编辑。在该框架中，我们详细地研究隐空间中的不同语义是如何被编码的。我们发现，在线性变形（linear transformations）之后，训练良好的生成模型的 latent code 学习到了一个分离的（disentangled）表示（representation）。我们研究分离各种语义，并设法将一些纠缠的语义与子空间投影分离，从而更精确地控制面部属性。除了操纵性别、年龄、表情和是否戴眼镜外，我们甚至可以改变面部姿势（face pose）并修复 GAN 模型意外生成的伪像（artifacts）。当与 GAN 逆映射（inversion）或一些编码器相关模型相结合时，我们所提出的方法可处理真实图像。研究结果表明，学习自发地合成面部图像会产生一种解耦的、可控的面部属性 representation。
1. 介绍 GAN 的原理：通过对抗性的训练，学习一个从隐分布（latent distribution）到真实数据的映射。在学习了这种非线性映射之后，GAN 能够从随机采样的 latent code 中生成逼真的图像。 然而，对于语义是如何在潜在空间中产生和组织的，人们并不确定。以人脸合成为例，当对 latent code 进行采样以生成图像时，code 如何能够确定输出人脸的各种语义属性（例如，性别和年龄），以及这些属性如何相互纠缠？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e709388c76242bc1324c745219bb3d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f5dec6d0fc804300dfa522fc5bb2c05/" rel="bookmark">
			pycharm 报错处理 libpng warning: iCCP: cHRM chunk does not match sRGB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 使用的代码编辑器为pycharm，错误显示为：
处理方法 避免这个报错Ctrl+shift 将输入法切换，不使用搜狗输入法下运行，报错就没了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ddfd0d0b8d3cfbf591cb2b976b05cc1/" rel="bookmark">
			（2020，特征相关度）用于跨域少样本分类的由解释引导的训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Explanation-Guided Training for Cross-Domain Few-Shot Classification
公众号：EDPJ
目录
0. 摘要
0.1 关键词和名词解释
1. 简介
2. 相关研究
2.1 Few-shot Classification（FSC）
2.2 Cross-domain Few-shot Classification（CD-FSC）
2.3 用于FSC的explanation
3. Explanation-guided Training
3.1 CD-FSC结构
3.2 Training
4. Experiment
4.1 Dataset and model preparation
4.2 Evaluation
4.3 Explanation-guided training与LFT的结合
4.4 解析explanation-guided training的效果
4.5 LRP的量化分析
5. 参考
0. 摘要 跨域少样本分类任务（Cross-domain few-shot classification task，CD-FSC）面对的挑战主要来自于：每个类别中有标签样本（labelled data）少，以及training set和testing set属于不同的domain。本文基于现有的FCS提出了新的训练方法。它使用了FSC模型预测时获得的解释（explanation），该值用于模型的中间特征图（feature map）。首先，我们调整了每个layer的重要性传播（relevance propagation），从而解释FSC模型的预测。第二，作者改进了与模型无关的（model-agnostic）由解释引导的（explanation-guided）训练策略：动态的寻找并强调（emphasis）对预测重要的特征。本研究不是为了提出新的解释方法，而是聚焦于explanation在训练阶段的新用法。
0.1 关键词和名词解释 cross-domain（跨域）：在source domain学习到的model（例如：识别），用于另一个不同的target domainfew-shot（少样本）：对于已经预训练（pre-train）好的model，只看过少量的labelled data（support set），就能完成task（query set）。N-way K-shot：few-shot learning的设置。Support set共有N个类别，每个类别有K个labelled data。relevance（相关度）：本文使用的方法是增强对预测（分类）重要的特征，削弱对预测不重要的特征。在我看来这也应该叫做置信度，如公式（2）所示，显示的是对特征属于某一个类别确信的程度。BP：本文使用的是back propagation，把relevance从后往前传，最终获得初始特征的relevance。其实叫做置信传播（belief propagation）也是可以的。explanation（解释）：通过BP，获得初始特征的relevance，也称之为explanation。这是因为：当成功预测时，与该类别对应的特征对于预测也最为重要，相应的relevance也最大。这也解释了为什么预测的是这个类别而不是其他的。information bottleneck（信息瓶颈）​：​舍弃不重要的信息，保留重要的信息​。本文使用的方法​也是基于这个理论。但是舍弃的对某一轮（episod）预测不重要的信息可能对于其它轮的预测很重要​，这就导致了overfitting。所以本作的方法虽然会舍弃一些信息，但是并不会过度。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ddfd0d0b8d3cfbf591cb2b976b05cc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b833fa71467c16ae96dcebb509f11ca7/" rel="bookmark">
			【RocketMQ】重试机制及死信消息处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【RocketMQ】重试机制及死信消息处理 文章目录 【RocketMQ】重试机制及死信消息处理1. 重试机制1.1 生产者重试1.2 消费者重试1.2.1 死信队列 参考文档： 官方文档 1. 重试机制 1.1 生产者重试 rocketmq生产者发送消息失败默认重试2次(同步发送为2次，异步发送为0次)。
当然也可以自定义重试次数及机制：
// 失败的情况重发3次 producer.setRetryTimesWhenSendFailed(3); // 消息在1S内没有发送成功，就会重试 producer.send(msg, 1000); 1.2 消费者重试 若Consumer消费某条消息失败，则RocketMQ会在重试间隔时间后，将消息重新投递给Consumer消费，若达到最大重试次数后消息还没有成功被消费，则消息将被投递至死信队列。
在集群模式下，消费的业务逻辑代码会返回 Action.ReconsumerLater，NULL，或者抛出异常，如果一条消息消费失败，最多会重试 16 次，之后该消息会被丢弃。在广播消费模式下，广播消费仍然保证消息至少被消费一次，但不提供重发的选项。 消息重试只针对集群消费模式生效；广播消费模式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息
最大重试次数：消息消费失败后，可被重复投递的最大次数。 consumer.setMaxReconsumeTimes(5); 在实际生产中，一般重试3-5次，如果还没有消费成功，则可以把消息签收，通知人工介入。
重试间隔：消息消费失败后再次被投递给Consumer消费的间隔时间，只在顺序消费中起作用。 consumer.setSuspendCurrentQueueTimeMillis(5000); 示例：
消费者重试示例：
@Test public void retryConsumer() throws Exception { DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("retry-consumer-group"); consumer.setNamesrvAddr(MqConstant.NAME_SRV_ADDR); consumer.subscribe("retryTopic", "*"); //设置最大重试次数 consumer.setMaxReconsumeTimes(2); consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) { MessageExt messageExt = list.get(0); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b833fa71467c16ae96dcebb509f11ca7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dce3f892599a61f6846356f9c92624f/" rel="bookmark">
			用户openId 和 unionId 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、长度不同 openId=28，unionId=29
2、openId 是同一用户同一应用的唯一标识 不同小程序或者不同微信H5，openId都是不一样的
单个应用中用户的唯一标识是openId
同一个appId下用户openId肯定是相同的
3、unionId 是同一用户不同应用的唯一标识 不同应用是指同一微信开发平台下的不同应用。
同主体（简单理解同一个公司注册的，并关联在平台），用户的唯一标识是 unionId
也就是说，不同应用要找用户的唯一标识，就是 unionId
如果需要在多公众号、移动应用之间做用户共通，则需要前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的openid，但他对所有这些同一开放平台账号下的公众号和应用，只有一个unionid。一个微信开放平台只可以绑定10个公众号。
参考链接：
微信小程序中的用户ID(openid和unionid)_小程序openid什么意思_何浪的博客-CSDN博客
openId和unionId的区别_涓涓细刘的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98a2edd494d2083bad6195539d06cf9/" rel="bookmark">
			使用openCV比对任意两张图片的相似度（亲测较准确）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案：使用openCV中的直方图算法做对比。测试效果较好。
步骤（在java中使用openCV）： 1.引入openCV的依赖 &lt;!-- https://mvnrepository.com/artifact/org.openimaj/core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.openpnp&lt;/groupId&gt; &lt;artifactId&gt;opencv&lt;/artifactId&gt; &lt;version&gt;4.5.5-1&lt;/version&gt; &lt;/dependency&gt; 2.代码 代码中提供了均方差算法（MSE）、结构相似性指数算法（SSIM）、峰值信噪比（PSNR）、直方图算法。其中直方图效果最好
package com.angus.temp; import org.opencv.core.*; import org.opencv.imgcodecs.Imgcodecs; import org.opencv.imgproc.Imgproc; import java.util.ArrayList; import java.util.List; /** * @author angus * @version 1.0.0 * @Description * @createTime 2023年06月01日 19:15:00 */ public class OpenCVImageSimilarity { public static void main(String[] args) { // 加载OpenCV库 System.loadLibrary(Core.NATIVE_LIBRARY_NAME); // 读取两张图像。准备比对的图片 Mat image1 = Imgcodecs.imread("C:\\Users\\Pictures\\0009.jpg"); Mat image2 = Imgcodecs.imread("C:\\Users\\Pictures\\0011.jpg"); // 将图片处理成一样大 Imgproc.resize(image1, image1, image2.size()); Imgproc.resize(image2, image2, image1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d98a2edd494d2083bad6195539d06cf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3bb4aff911caeb76b458739f3c1f1f3/" rel="bookmark">
			chatgpt赋能python：Python分割空格详解——教你精通字符串的处理方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python分割空格详解——教你精通字符串的处理方法 在Python编程中，字符串是必不可少的数据类型。而字符串中的分割空格在数据清洗、文本处理等方面非常常见。本篇文章将为大家介绍如何使用Python对空格进行分割，为大家的数据处理和文本处理带来帮助。
什么是Python分割空格？ Python中的字符串表示一系列字符序列，而其中经常需要对字符串进行分割空格，即按照一定规则将字符串从空格处分割成多个片段。Python中常用的分割空格方法有split()、rsplit()，其中split()分割方向从左到右，rsplit()分割方向从右到左。
使用Python分割空格 下面以一个字符串为例，使用split()方法进行分割：
str = "Python is a popular programming language" result = str.split() print(result) 输出结果为：
['Python', 'is', 'a', 'popular', 'programming', 'language'] 同样的，使用rsplit()方法进行分割：
str = "Python is a popular programming language" result = str.rsplit() print(result) 输出结果同样为：
['Python', 'is', 'a', 'popular', 'programming', 'language'] 需要注意的是，如果在split()中提供了参数，表示按照特定字符进行分割，而不是按照空格进行分割，例如：
str = "Python is a popular programming language" result = str.split('p') print(result) 输出结果为：
['Python is a', 'o', 'ular ', 'rogramming language'] 小结 Python中的分割空格方法可以帮助我们对字符串进行数据清洗和文本处理。常用的方法有split()和rsplit()，在使用时需要注意参数的传递和分割方向的选择。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3bb4aff911caeb76b458739f3c1f1f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15fe3735e77aa2d53c047810b0bf219a/" rel="bookmark">
			如何隐藏微信内置底部前进后退的按钮？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在微信H5中，会有下面一个问题：
使用 window.location.href 进行页面跳转或者 react 内部项目使用 this.props.history.push 进行页面跳转时，做好的 h5 页面放在微信里，底部会出选 前进后退 的按钮，如下图：
解决方案如下：（适用于特殊场合）
第一种情况：如果只是页面之间跳转，使用 window.location.replace 代替window.location.href ，亲测有效
第二种情况：react项目内部页面跳转使用 this.props.history.replace 代替 this.props.history.push 第三张情况：vue项目内部页面跳转使用 this.$router.replace 代替 this.$router.push
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5a61b7ba6c050adf64f5c3ec852b108/" rel="bookmark">
			BugReport本地crash日志分析总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在ApplicationExitInfo日志中找到自己的包
2.找到自己应用包退出理由为：reason=4 (APP CRASH(EXCEPTION))的时间点
3.在bugreport中找到crash时间点对应日志
4.根据日志分析退出原因
查看crash日志搜索下面日志：
AndroidRuntime: Process: com.rz.arglass（包名）
tombstone日志分析：
Android Tombstone 分析_yunshouhu的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441e8fba5d3bd8e498b0d7fd2c8541ea/" rel="bookmark">
			VuePress学习指南（下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VuePress 如何自定义主题和页面布局 要自定义VuePress的主题，需要做以下几步：
创建主题文件夹：在VuePress项目的根目录下创建一个themes文件夹，并在其中新建一个以主题名命名的文件夹，例如my-theme。
创建主题配置文件：在my-theme文件夹中创建一个config.js文件，用于配置主题的一些选项，例如导航栏、侧边栏、颜色等。
创建主题模板文件：在my-theme文件夹中创建一个layouts文件夹，并在其中创建.vue文件，用于定义不同页面类型的布局，如首页、文章页、404页等。
引入主题：在VuePress项目的配置文件.vuepress/config.js中，将theme选项指向my-theme主题的路径。
要自定义VuePress的页面布局，需要做以下几步：
创建页面模板文件：在VuePress项目的根目录下创建一个.vue文件，用于定义特定页面的布局。
配置页面布局：在.vue文件中使用组件来包含页面内容，并通过插槽（slot）来定制布局的各个部分，如导航栏、侧边栏、页脚等。
配置页面路由：在VuePress项目的根目录下的.vuepress/config.js中，配置特定页面的路由路径和组件路径，如：
module.exports = { themeConfig: { sidebar: [ ['/my-page', 'My Page'] ] }, extendPageData($page) { if ($page.path === '/my-page') { $page.layout = 'MyLayout' } } } 其中sidebar选项配置了页面的侧边栏，extendPageData函数用于获取当前页面的信息，并通过layout属性指定使用哪个布局模板。
添加代码高亮、分页功能 代码高亮 VuePress 使用了 Prism.js 来实现代码高亮。要开启代码高亮功能，需要在 .vuepress/config.js 文件中进行如下配置：
module.exports = { themeConfig: { // ... markdown: { // 配置 markdown-it 插件 extendMarkdown: md =&gt; { md.set({ breaks: true }) md.use(require('markdown-it-prism')) } } } } 上述配置中，我们通过 extendMarkdown 选项来引入了 markdown-it-prism 插件，该插件可以为代码块添加语法高亮。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/441e8fba5d3bd8e498b0d7fd2c8541ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f2ec9d1c960308f8a5e5228138c00e6/" rel="bookmark">
			sql server创建数据表的完整语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建数据库 语法：CREATE DATABASE &lt;数据库名称&gt; 复制
CREATE DATABASE dbname -- 创建名为 dbname 的数据库 复制
2.表的创建 语法： USE suntest create table 仓库 ( 仓库编号 int , 仓库号 varchar(50) , 城市 varchar(50) , 面积 int ) create table 仓库1 ( 仓库编号 int not null , 仓库号 varchar(50) not null, 城市 varchar(50) not null, --不能为空not null-- 面积 int ) create table 仓库2 ( 仓库编号 int primary key , --主键的关键字primary key-- 仓库号 varchar(50) unique, --唯一索引关键字unique-- 城市 varchar(50) not null, --不能为空not null-- 面积 int ) create table 仓库3 ( 仓库编号 int primary key , --主键的关键字primary key-- 仓库号 varchar(50) unique, --唯一索引关键字unique-- 城市 varchar(50) default '青岛', --不能为空not null-- 面积 int check (面积&gt;=300 and 面积&lt;=1800) ) create table 职工表 ( 职工编号 int identity (1,1) primary key, 职工号 varchar(50) unique, 仓库号 varchar(50), 工资 int check(基本工资&gt;=800 and 基本工资&lt;=2100), ) create table 订单表 ( 订单编号 int identity(1,1) primary key, 订单号 varchar(50) unique, 职工号 varchar(50) references 职工表(职工号),--references两张表通过“职工号”关联-- 订购日期 datetime, 销售金额 int ) create table 阳光工资表 ( 职工编号 int identity (1,1) primary key, 职工号 varchar(50) unique, 仓库号 varchar(50), 基本工资 int check(基本工资&gt;=800 and 基本工资&lt;=2100), 加班工资 int, 奖金 int, 扣率 int, 应发工资 as (基本工资+加班工资+奖金-扣率) --as为自动计算字段，不能输入值-- ) 复制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f2ec9d1c960308f8a5e5228138c00e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ecd379dc62d7ad4bb010bd2fe9dd62/" rel="bookmark">
			六一儿童节 全网最全的微服务&#43;Outh2套餐，你确定不来试一试？（入门到精通，附源码）满足你的味蕾需要（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		咱们废话不多说，直接开干！！！
目录
一、项目目录
二、Token
三、授权服务器oauth
1.pom
2.application
3.OauthApp启动类
4.DiyUserDetails
5.MyUserDetailService
6.KeyPairController
7.TokenConfig
8.WebSecurityConfig
9.ResourceServerConfig
10.AuthorizationServerConfig
11.授权码模式说明 与 创建数据表
12.测试
（1）获取授权码
（2）获取令牌 （3）检查令牌
（4）刷新令牌
四、user-service模块与feign模块
五、gateway模块 资源服务器
一、项目目录 feign：远程接口调用
Gateway：资源服务器
Oauth2：授权服务器 user-service： 普通资源
二、Token 对于Token采用非对称加密，因此到 java 的 bin 目录下打开 cmd，执行以下命令，生成 jwt.jks
keytool -genkey -alias jwt -keyalg RSA -keystore jwt.jks 将其复制到 oauth2 的 resource 目录下，
三、授权服务器oauth 1.pom &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ecd379dc62d7ad4bb010bd2fe9dd62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f79fe024046c3e5643a27032d234d92f/" rel="bookmark">
			2023年天府杯全国大学生数学建模竞赛B题中国环境问题的治理解题全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2023年天府杯全国大学生数学建模竞赛 B题 中国环境问题的治理 原题再现： 问题背景：
随着经济的快速发展和人口的持续增长，中国的环境问题已经成为了一个急需解决的重要问题。这些环境问题不仅对人们的健康和生活质量产生了巨大的影响，还对生态系统和生态平衡造成了极大的破坏。近年来，中国政府积极推动环保事业的发展，通过采取一系列政策和措施，取得了一定的成效，但环境污染问题依然十分严峻，需要进一步采取措施来加以解决。
其中，空气污染是中国环境问题中最为突出的问题之一。由于城市化进程的加速和工业化的 发展，许多城市空气中的 PM2.5 等有害物质超标，给人们的身体健康造成了严重的威胁。因此，建立空气质量指数（AQI）与不同污染物浓度之间的数学模型，能够帮助政府和公众更好地了解空气质量的情况，并采取相应的措施来改善空气质量。
另外，水环境污染也是中国环境问题的重要方面。随着城市化进程的加速和工业化的发展，许多地区的水环境受到了严重的污染，水质问题成为了公众关注的焦点。因此，构建水环境质量综合评价指标，以反映水环境的污染程度和治理效果，对于政府和公众了解水环境问题的严重性和推动水环境治理具有重要意义。
除此之外，城市噪声污染也是一个长期存在的环境问题。由于城市的交通密度和建筑密度的增加，以及人们生活方式的变化，城市噪声污染已经成为了一个普遍存在的问题。为了更好地监测和控制城市噪声污染，优化城市噪声污染的监测网络，以最小化监测点数量，同时保证监测结果的准确性和全面性，成为了当务之急。根据上述背景，请你和你的团队解决以下问题。请解决：
问题 1：空气污染已经成为了中国环境问题中最为突出的问题之一。如何建立空气质量指数（AQI）与不同污染物浓度之间的数学模型，来更好地了解空气质量的情况，并采取相应的措施来改善空气质量？请给出全国各城市空气质量的最好的 10 座城市。
问题 2：随着城市化进程的加速和工业化的发展，许多地区的水环境受到了严重的污染，水质问题成为了公众关注的焦点。如何构建水环境质量综合评价指标，以反映水环境的污染程度和治理效果？请给出全国各城市水环境的最好的 10 座城市。
问题 3：由于城市的交通密度和建筑密度的增加，以及人们生活方式的变化，城市噪声污染已经成为了一个普遍存在的问题。选定一座城市，并收集需要的数据，确定如何优化城市噪声污染的监测网络，以最小化监测点数量，同时保证监测结果的准确性和全面性。
求解过程 这个题就是老生常谈的一个话题，环境保护，而环境保护其中一个重要评测标准就是空气质量，第一问说如何建立空气质量指数（AQI）与不同污染物浓度之间的数学模型，来更好地了解空气质量的情况，并采取相应的措施来改善空气质量？请给出全国各城市空气质量的最好的 10 座城市。
首先空气质量指数与不同污染物浓度，这个不同污染物浓度你要搞清有哪些？有经验的你会知道”两尘四气”， PM2.5、PM10、CO、NO2、SO2、O3，这6个指标可以准确的衡量某地空气质量情况，进而对污染源采取相应措施。但是这个数据采集就很烦，还好我这有。第一问构建多元线性回归模型,基于不同污染物的对于空气质量的影响关系；然后再进行一个空气质量总体的可视化对比和多个因子之间的环形图或饼形图对比，第一问非常简单。我打个样，可视化图表怎么做呢？
然后第二问水污染的问题，也是如此只不过其中略微有些不同，这一整个题难度我不予评价，像问题重述、问题背景、模型假设、参考文献这种废磕练习我不写，有要整个模型建立与求解过程的请见下方“ 只会建模 QQ名片” 点击QQ名片即可。
天府杯数学建模指导预订请见下方“ 只会建模 QQ名片” 点击QQ名片即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8d420ed1b5a58c8e61dbd081b6c92cb/" rel="bookmark">
			学习路之gis--百度离线地图下载制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在有些情况下需要使用地图，但又不能访问外网，这时你需要一个离线地图。本文介绍如何制作百度离线地图。
下面将介绍如何实现一个离线版百度地图：
1. 下载百度地图瓦片
下载网址：望远网-百度地图下载
首先需选择下载地图瓦片的样式，大部份情况默认，有少数特殊情况需使用主题样式，比如黑色背景等
左边选择矩形或多边形按钮
然后利用拖动选择需要下载的区域
点击下载瓦片， 在弹出窗口中选择需要下载的百度地图瓦片级别，然后点击jpg下载或png下载即可
注意下载瓦片为png.测试程序不显示jpg（可能要改一）
2. 实现百度离线地图
下载“百度地图瓦片测试V3.0.zip” 下载地址：望远网-订制及代写各种python脚本和工具软件
链接: https://pan.baidu.com/s/1Y-6CnEmwOrApV3Z74Ys1Gg?pwd=e3ag 提取码: e3ag 复制这段内容后打开百度网盘手机App，操作更方便哦
将前面下载的瓦片的tiles目录替换掉本代码的titles目录。
然后编辑test_tiles.html文件，设置地图的中心位置，前面下载百度地图瓦片时会有中心坐标，直接复制过来即可。
//初始化地图,设置中心点坐标和地图级别
map.centerAndZoom(new BMap.Point(112.987942,28.189387), 4); 最后直接双击打开test_tiles.html文件，就可以看到百度离线地图的效果。
也就可以把该段html代码集成到你的项目中，这样就可以实现你想要的功能了。 非常简单方便。
文章主要内容来自 百度离线地图下载制作
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/131/">«</a>
	<span class="pagination__item pagination__item--current">132/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/133/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>