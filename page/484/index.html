<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35cd5a421db150a8e16765491b8f022d/" rel="bookmark">
			MongoDB删除数组元素的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		use test
switched to db test
插入测试数据:
db.country.insert({“name”:“China”,“province”:[{“name”:“Henan”,“code”:“1001”},{“name”:“Hebei”,“code”:“1002”},{“name”:“Jiangsu”,“code”:“1003”}]});
WriteResult({ “nInserted” : 1 })
方法一:
想删除名为"Hebei"的省份信息，分两步:
(1).查找到对应的数组元素，并将其替换为"null"
db.country.update({“name”:“China”,“province.name”:“Hebei”},{"KaTeX parse error: Expected '}', got 'EOF' at end of input: …et":{"province.":“null”}});
WriteResult({ “nMatched” : 1, “nUpserted” : 0, “nModified” : 1 })
此时数组数据如下:
db.country.find()
{ “_id” : ObjectId(“59f97d03a4fe2442400cbd2c”), “name” : “China”, “province” : [ { “name” : “Henan”, “code” : “1001” }, “null”, { “name” : “Jiangsu”, “code” : “1003” } ] }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35cd5a421db150a8e16765491b8f022d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07bdd0dd584b7a7e36b3112c13229d8e/" rel="bookmark">
			Centos7下安装yum install net-tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yum install net-tools
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce0df82489f4046b3150722f3552db9a/" rel="bookmark">
			双亲委派模型与线程上下文类加载器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：
SPI机制是什么，有哪些应用场景，又带来了哪些问题？双亲委派模型是Java推荐的类加载模型，但违背该模型的案例有哪些？为什么会违背，又是怎么解决这种case的?JDBC驱动加载的案例有哪些，SPI机制为它带来了哪些方便？线程上下文类加载器的作用与应用场景？ 一、引子 SPI机制简介 SPI的全名为Service Provider Interface，主要是应用于厂商自定义组件或插件中，在java.util.ServiceLoader的文档里有比较详细的介绍。简单的总结下java SPI机制的思想：我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、xml解析模块、jdbc模块等方案。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 Java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。 有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。
Java SPI的具体约定为：当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件，该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类：java.util.ServiceLoader。JDBC SPI mysql的实现如下所示。
SPI机制带来的问题 Java 提供了很多服务SPI，允许第三方为这些接口提供实现。这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现则是由各供应商来完成。终端只需要将所需的实现作为 Java 应用所依赖的 jar 包包含进类路径（CLASSPATH）就可以了。问题在于SPI接口中的代码经常需要加载具体的实现类：SPI的接口是Java核心库的一部分，是由启动类加载器来加载的；而SPI的实现类是由系统类加载器来加载的。启动类加载器是无法找到 SPI 的实现类的(因为它只加载 Java 的核心库)，按照双亲委派模型，启动类加载器无法委派系统类加载器去加载类。也就是说，类加载器的双亲委派模式无法解决这个问题。
线程上下文类加载器正好解决了这个问题。线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。
二、线程上下文类加载器 线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。Java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器，在线程中运行的代码可以通过此类加载器来加载类和资源。
线程上下文类加载器从根本解决了一般应用不能违背双亲委派模式的问题，使得java类加载体系显得更灵活。 上面所提到的问题正是线程上下文类加载器的拿手好菜。如果不做任何的设置，Java应用的线程上下文类加载器默认就是系统类加载器。因此，在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。
// Now create the class loader to use to launch the application try { loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce0df82489f4046b3150722f3552db9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eba38519e62410f67a7c6fa81a720b6/" rel="bookmark">
			[链表]leetcode2：两数相加(medium)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题解：
说明：使用此方法击败90%的人，嘿嘿嘿！思路： 注意此题，不需要将链表倒置进行加减，因为最后还要倒置回来，所有同学们只需将链表从头加到尾，满10进一即可。 代码如下：
class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { //注意此题，不需要将链表倒置进行加减，因为最后还要倒置回来，所有同学们只需将链表从头加到尾，满10进一即可 //此题不需要将链表倒置，我们直接从左至右相加，向右边进位，这样与倒置链表从右至左相加一样的，因为两个链表的低位对低位，高位对高位，不会错位 ListNode *head=new ListNode(0);//建立头结点 ListNode *begin=head; int carry=0;//进位 while(l1!=nullptr||l2!=nullptr||carry!=0) { //1、计算当前位的总和 int sum=(l1?l1-&gt;val:0)+(l2?l2-&gt;val:0)+carry; //2、将个位数字生成一个新节点，并更新进位数字 ListNode *temp=new ListNode(sum%10); carry=sum/10; //3、将temp加入到新链表中，并更新begin节点（begin相当于链表的尾节点，尾节点的next节点为空） begin-&gt;next=temp; begin=temp; //4、移动链表 if(l1)l1=l1-&gt;next; if(l2)l2=l2-&gt;next; } return head-&gt;next; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0289b107cb97f4aea825a9abeb2cee/" rel="bookmark">
			如何免费查找/下载S&amp;P500指数的历史数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		S&amp;P500指数介绍
先进入雅虎财经 ，在往下拉的时候有这样一个APPLY：
在 【Time Period】选择你需要的数据的起止日期，
在【Show】选择历史数据，
【Frequency 】表示你选择的数据的粒度，有daily（每日），weekly（按周划分），monthly（月度）数据。
这三个选项选择好了之后，点击Apply,就能查找出数据来，下方的Download Data会将查找的数据保存为csv格式。
日期Date , 开盘Open，最高 High ，最低Low， 收盘Close* ， 调整收盘价Adj Close** , 成交量Volume。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f0960a7f0c1a68bf84126a3a693b33/" rel="bookmark">
			使用ffmpeg合并多个视频文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于腾讯视频将一个视频分割成多个20M左右的小文件，所以必须合并起来成为一个完整视频文件，用什么工具来合并这些文件呢，想到了已经安装好的ffmpeg，开源免费，又是现成的。 两种方法：
方法1、直接写文件名，使用“|”来分割： ffmpeg -i "concat:f00282urkwd.321002.1.ts|f00282urkwd.321002.2.ts|f00282urkwd.321002.3.ts|f00282urkwd.321002.4.ts|f00282urkwd.321002.5.ts|f00282urkwd.321002.6.ts|f00282urkwd.321002.7.ts|f00282urkwd.321002.8.ts|f00282urkwd.321002.9.ts|f00282urkwd.321002.10.ts|f00282urkwd.321002.11.ts|f00282urkwd.321002.12.ts|f00282urkwd.321002.13.ts|f00282urkwd.321002.14.ts|f00282urkwd.321002.15.ts|f00282urkwd.321002.16.ts|f00282urkwd.321002.17.ts|" -c copy output.mp4 1）需要合并的文件名称及路径： 2）合并过程如下： 3、合并后的结果： 方法2、先编辑一个txt的文本文件，其中罗列了需要合并的子文件路径和名称： ffmpeg -f concat -safe 0 -i filelist.txt -c copy output.mp4 filelist.txt的内容： file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.1.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.2.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.3.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.4.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.5.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.6.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.7.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.8.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.9.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.10.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.11.ts' file 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.12.ts' 注意：为了防止出现“Unsafe file name 'D:\delphisr\腾讯下载地址解析子串\k0028qzpkdl.321002.1.ts'
filelist.txt: Operation not permitted” 必须在命令中加入“-safe 0”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3275e3d1031a1b35ca896a49ee268805/" rel="bookmark">
			C#导入Excel表格数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入数据用bootstrap-4.1.3-dist前段框架的模态框搭建的导入页面的窗体，通过触发页面的按钮弹出模态框，其弹出模态框、关闭模态框的方法框架的内部已经定义好调用方法就可以；弹出模态框，要重置from表单，以防上次打开的数据遗留；找到打开模态框的按钮，给这个按钮一个点击事件，找到要弹出的模态框用model（“show”）触发模态框弹出。导入Excel表格数据要根据其数据模板定义好的规则导入，通过触发按钮导入数据；刚弹出导入的模态框是没有数据的，所以导入到数据库的按钮要禁用，当表格有数据的时候才启用。打开模态框的代码、模态框的内容效果如下截图：
一、 下载导入考生信息的模板
1、 把建好的模板放在当前项目的文件夹里
2、 通过代码找到模板
3、 代码实现给用户下载模板，填写信息导入
用IO流读取文件，判断模板文件是否存在；获取文件名称，以文件的格式返回数据；
注意：在模板添加考生信息时，数据之间的关系要以数据库的关系对应，确保数据的准确性
其方法代码、表格模板截图如下：
二、 导入的方法
方法的大致思路如下：
1、判断文件类型是不是.xls格式
（1）获取读取的文件；
（2）把文件转换为二进制数组；（3）二进制数组转成内存流；（4）利用NPOI把内存流中的数据读取成工作簿Excel
导入的数据临时存放于Session中，获取文件之前要清空临时存储数据的Session，以防Session残留以前的数据；获取文件的后缀，判断文件的后缀名是否是“.xls/.XLS”格式；声明一个二进制的数组存放文件，把文件以流的形式读取文件并传入二进制数组存放，再将二进制数组转化为内存流，由NPOI插件的方法将内存流转化为工作簿。其整个转换过程代码如下截图：
2、 判断工作簿中是否有工作表
3、判断工作表是否有数据 4、判断数据准确性（学院、专业、年级、班级、表跟表之间的关系）
5、数据都有,然后读取数据，把数据临时存放Session。
三、 把导入的数据临时存放Session，将Session中的数据进行分页操作
调用封装的分页类，实例化一个对象列表，判断Session中的数据是否为空；不为空，把Session中的数据赋值给刚实例化的对象列表；把数据进行分页的操作，分页前要把数据进行排序，最后返回分页数据；其代码如下截图所示：
四、 保存导入的数据（批量新增）
导入数据成功，还需要把数据保存，保存数据的过程、结果都相当于是新增数据，因导入的数据是批量性的，所以保存的数据也是批量性，无意之中就是一个批量新增数据的过程。新增数据要做到几个步骤：1、判断页面要新增保存的数据是否为空2、判断新增的数据是否已存在，即检查新增的数据是否出现重复3、保存数据的操作、判断保存数据是否成功4、把保存的结果返回给用户。其新增保存的过程代码如下截图：
五、 模板导入数据的效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d94199201cb7e0201043527c968078a7/" rel="bookmark">
			C语言，数的冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数的排序（sort）利用数组进行冒泡排序 数的排序（sort） 利用数组进行冒泡排序 排序的规律有两种：一种是“升序”，从小到大；另外一种是“降序”，从大到小；
排序的方法有很多，我先说一个最基本的，最简单的排序方法—冒泡排序，顾
名思义，它就类似与冒泡一样；
冒泡排序的基本思路是：每次将相邻的两个数比较，将小的调到前面，将大的沉底，对每一对相邻的元素进行同样的操作，这样最后一个元素就是当前排序中最大的数，每执行一次，排除最后一个元素，针对剩下的元素重复以上的步骤。即；持续每次针对越来越少的元素重复上面步骤，直到没有任何一对数字需要比较。
例如：有8个数需要进行冒泡排序；
5，8 , 2，4, 3, 7，9, 1；
有8个数需要排序，一共需要比较7次，上面只执行了四次，下面的以此类推就可以了；
#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main() { int a[1000];//定义一个数组，用来放需要比较的数； int i, j, k; for (i = 0; i &lt; 8; i++)//输入n个需要比较的数，我这里是10个 { cin &gt;&gt; a[i]; } for (i = 0; i &lt; 8-1; i++)//冒泡排序 { for (j = 0; j &lt; 8-1 - i; j++) { if (a[j] &gt; a[j + 1]) { k = a[j]; a[j] = a[j + 1]; a[j + 1] = k; } } } for (i = 0; i &lt; 8; i++)//输出已经排好序的数； { cout &lt;&lt; a[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d94199201cb7e0201043527c968078a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd7df085ed85c4daf8d7723bf1f62fdf/" rel="bookmark">
			thinkphp---在视图中把时间戳转化成常用的时间格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		{$times|date=“Y-m-d H:i:s”,###}
实际项目运用如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cda2269f98f81779a6ba4b324653069/" rel="bookmark">
			Python基础教程：Day14b-网络应用开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python基础教程-网络应用开发
发送电子邮件
在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。
就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。
下面的代码演示了如何在Python发送邮件。
from smtplib import SMTP from email.header import Header from email.mime.text import MIMEText def main(): # 请自行修改下面的邮件发送者和接收者 sender = 'abcdefg@126.com' receivers = ['uvwxyz@qq.com', 'uvwxyz@126.com'] message = MIMEText('用Python发送邮件的示例代码.', 'plain', 'utf-8') message['From'] = Header('王大锤', 'utf-8') message['To'] = Header('骆昊', 'utf-8') message['Subject'] = Header('示例代码实验邮件', 'utf-8') smtper = SMTP('smtp.126.com') # 请自行修改下面的登录口令 smtper.login(sender, 'secretpass') smtper.sendmail(sender, receivers, message.as_string()) print('邮件发送完成!') if __name__ == '__main__': main() 如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。
from smtplib import SMTP from email.header import Header from email.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cda2269f98f81779a6ba4b324653069/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5642c9a1043bedb7a9fb074731cea63a/" rel="bookmark">
			JSONArray集合转list集合对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请求接口转list&lt;对象&gt;
JSONObject obj = PostInterface.post(PostInterface.ServletName.activitiModel,"queryPlaceHolderList",new HashMap()).getJSONObject("SvcCont");
List&lt;Placeholder&gt; dataArr = JSON.parseArray(obj.getString("placeHolderList"),Placeholder.class);
转载于:https://www.cnblogs.com/320321ABab/p/10697124.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872da7ce98eaf72dc224cbfd99b262ee/" rel="bookmark">
			okhttp网络框架源码解析八okhttp的拦截器RetryAndFollowUpInterceptor重试和重定向拦截器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、
RetryAndFollowUpInterceptor：主要负责失败重连的。
比如说需要失败重连，就可以在okhttpclient中进行配置，但是需要注意的是，并不是所有的网络请求，当它失败后都可以进行重连的，它是有一定的限制范围的。所以okhttp内部，就会进行网络请求异常和响应码的判断，如果都在它的判断范围内的话，就可以进行网络请求的重连。主要看它的intercept（）这个最关键的代码
111行，创建了streamAllocation这个对象，streamallocation实际上就是建立、执行http网络请求所需要的网络的组件的。从它的名字上可以判断，它所做的其实就是stream allocation，用来分配stream。需要注意的是，这个streamallocation对象虽然在RetryAndFollowUpInterceptor中创建好了，但是它在这个拦截器中并没有被使用到。真正被使用是在下一个拦截器中。它主要是用于获取服务端的connection连接，和用于服务端用于进行数据传输的输入输出流。它是依次通过拦截器链传给下一个拦截器。
在整个拦截器的拦截过程，可以把它理解为一个递归的过程，也就是说，它的内部会通过要给realInterceptorChain这个类去负责所有的拦截器，并把它们串联起来。所以说，只有当所有的拦截器执行完以后，这个okhttp网络请求才会返回response。但是在实际开发过程中，网络本来就是不稳定的，在执行过程中肯定会出现不同程度的问题，比如说连接中断了，或者失败了，都是有可能的，这个时候response的返回码code就不是正常的200了，因此这个response就不一定是可以用的，或者说在请求过程中已经抛出异常了，那么此时，这个retryandfollowupinterceptor是怎么帮我们进行拦截的呢？
它所有的逻辑都在while循环中。
2、在while（true）while循环中
在168行，对重试的次数进行判断，因为不可能无限次地去进行网络请求，
MAX_FOLLOW_UPS设置的值为20。意思是这个RetryAndFollowUpInterceptor拦截器会对失败的网络进行重连，但是不是无限制的，当okhttp内部超过了20次网络重连请求，就不会再进行请求了，这时候做的就是释放这个streamAllocation对象。这也是整个的网络失败重连接的核心流程，有一个跳出的逻辑。
3、
RetryAndFollowUpInterceptor是第一个拦截器，也是最重要的一个拦截器，因为它创建的streamAllocation是核心之一。这个对象是执行网络请求所需要的网络的组件，它的作用就是用来分配stream。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff7c3285cc496e76b0bb6c53586207a/" rel="bookmark">
			MPAndroidChart之折线图详情使用(X轴文本换行，滑动，限制线)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：MPAndroidChart 是一个Android非常强大的图标库，包括折线图，柱状图，饼图，雷达图，散列图等，官方github地址请戳这里
一.说了这么多，咱先看看 效果图：
2.博主主要以这个折线图为列，讲讲具体实现过程，首先看到这个效果图，我之前以为很简单，所以刚开始 自己自定义了一个，后来发现问题挺多，所以在github找了一番资料，最终使用MPAndroidChart库。
3.添加依赖
（在主project的build.gradle中添加依赖）
allprojects { repositories { maven { url 'https://jitpack.io' } } } （然后在app的build.gradle中添加依赖）
dependencies { implementation 'com.github.PhilJay:MPAndroidChart:v3.0.2' } 4.在xml 布局中使用
&lt;!--心率--&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" android:layout_marginRight="20dp" android:layout_marginTop="20dp" android:text="心率"/&gt; &lt;com.github.mikephil.charting.charts.LineChart android:id="@+id/linCart" android:layout_width="match_parent" android:layout_height="200dp" android:layout_marginLeft="20dp" android:layout_marginRight="20dp"/&gt; &lt;!--呼吸率--&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="right" android:layout_marginRight="20dp" android:layout_marginTop="20dp" android:text="呼吸率"/&gt; &lt;com.github.mikephil.charting.charts.LineChart android:id="@+id/linCartBreath" android:layout_width="match_parent" android:layout_height="200dp" android:layout_marginLeft="20dp" android:layout_marginRight="20dp"/&gt; 5.Java类实现代码
@BindView(R.id.ll_title_root) LinearLayout llTitleRoot; //心率 @BindView(R.id.linCart) LineChart mLineCharHeart; //呼吸率 @BindView(R.id.linCartBreath) LineChart mLinCartBreath; @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ff7c3285cc496e76b0bb6c53586207a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d956ea39ba1d572ee1d0358c8f3eb84/" rel="bookmark">
			推荐系统介绍——协同过滤，隐语义模型，随机游走
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整个项目参考于：https://blog.csdn.net/sinat_33741547/article/category/6442592，以及对相关学习课程的实践。
项目代码：https://github.com/FairyFali/recommend。
环境依赖：Python3：Pandas,numpy,pickle
目录
基于用户的协同过滤模型
什么是基于用户的协同过滤？
UCF方法
相似度计算
预测得分
评价方法
程序代码
隐语义模型
概述
程序代码
基于随机游走的PersonRank模型
概述
PageRank简单介绍
PersonRank算法
程序代码
项目实战演示
部署环境：
环境依赖：
基于用户的协同过滤模型 什么是基于用户的协同过滤？ 协同过滤（collaborative filtering，简称CF）是利用某兴趣相投、拥有共同经验之群体的喜好来推荐用户感兴趣的信息。
具体步骤如下：
（1）收集用户购买行为和兴趣特点。通过日志文件记录的用户浏览历史，购买历史和评价历史得到用户对商品的喜好程度矩阵user-item矩阵，如图3-15所示。
图1 用户商品喜好程度矩阵 （2）通过收集的矩阵可以计算用户之间的相似度，如图2所示。相似度高的用户优先作为推荐对象的相似用户。
图2 用户之间的相似度 （3）寻找邻居。选择最相近的k个邻居作为相似用户，如图3所示。
图3 最邻近方法推荐 （4）个性化推荐。通过基于用户的方法的思路是，基于邻居和推荐对象的相似度为权重计算推荐对象对某一商品的喜好程度，获得所有未购买商品的预测喜好程度，选择喜好程度最高的n个商品作为推荐商品列表，如图3-17所示，同时也可以使用基于商品的个性化推荐。
（5）评估推荐结果。通过用户实际购买商品和推荐商品做对比，比较结果作为推荐质量的评判。
同理，基于商品的协同过滤则是以商品为单位计算相似度，成为基于物品的协同过滤模型。
UCF方法 基于user的协同过滤，通过不同用户对item的评分来评测用户之间的相似性，基于用户之间的相似性做出推荐。
如何预测用户1对于商品4的喜好程度，如图4所示：
（1）找到和用户1相似的用户且购买过商品4（基于购买记录）即为用户n；
（2）根据用户n对商品4的评价，以相似度为权重回填结果；
（3）针对所有用户组合，重复1~3，直到所有空格都被填满。
根据预测的用户对商品喜好程度，找到用户未购买的喜好程度最高的k个商品推荐个用户即可。
图4 基于用户预测用户对商品的喜好程度 相似度计算 （1）Jaccard 系数：等于样本集交集与样本集合集的比值，即J=|A∩B|/|A∪B|
（2）余弦相似度：又称为余弦相似性。通过计算两个向量的夹角余弦值来评估他们的相似度，即。
预测得分 计算用户对商品的感兴趣程度，我们用下面的公式来求解：
其中u代表用户，i代表商品，S(u,k)包含和用户兴趣最接近的K个用户，N(i)是对物品i有过行为的用户集合，w代表用户u和用户v的相似程度，r代表用户v对物品i的兴趣。
评价方法 （1）基于预测的评估方法
一般来说，推荐系统质量采用平均绝对误差(Mean Absolute Error, MAE)来衡量，通过计算用户推荐商品与实际所购买商品之间的偏差来评估推荐质量。假设系统推荐的商品集为{p1,p2,…,pn}，而用户实际购买的商品集为{q1,q2,…,qn}，则
另外均方根误差(Root Mean Squared Error, RMSE)也是推荐系统的一个评估指标。
MAE和RMSE指标数值越小，则推荐商品和用户实际购买商品集间的差异越小，即系统推荐质量越高。
（2）基于IR的评估方法
召回率和准确率是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。其中召回率衡量的是检索系统的查全率，准确率是衡量的是检索系统的查准率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d956ea39ba1d572ee1d0358c8f3eb84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e36246b00a709a53584dd852f1b6f5/" rel="bookmark">
			Get和Post请求区别和使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GET和POST是什么？ 答：HTTP协议中的两种发送请求的方法。
HTTP是什么？ 答：HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。
Get请求和Post请求区别： （1）post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）
（2）post发送的数据更大（get有url长度限制）
（3）post能发送更多的数据类型（get只能发送ASCII字符）
（4）post比get慢
（5）post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据.
总结：GET把参数包含在URL中，POST通过request body传递参数，所以Post更加安全一些；Get的效率比Post高一些，但是Get请求发送的参数是有限的，而Post请求是没有限制的(理论上来讲)。
使用场景： 在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；Get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式； 区别表现如下：
Get是从服务器上获取数据，Post是向服务器传送数据。Get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。Post是通过HTTP Post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。对于Get方式，服务器端用Request.QueryString获取变量的值，对于Post方式，服务器端用Request.Form获取提交的数据。Get传送的数据量较小，不能大于2KB。Post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 5. Get安全性非常低，Post安全性较高。但是执行效率却比Post方法好。 Get和Post还有一个重大区别： Get产生一个TCP数据包；Post产生两个TCP数据包。
对于Get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据），而对于Post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
比如说：Get只需要汽车跑一趟就把货送到了，而Post得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。由于Post需要两步，时间上消耗的要多一点，所以Get比Post更有效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc7e629333533ce22c40f27ccf91327b/" rel="bookmark">
			epoll模型水平触发、边沿触发优缺点对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		epoll模式下的水平触发、边沿触发
1，epoll默认是水平触发
2，水平触发通俗来讲：只要有数据，epoll_wait函数就一直返回；边沿触发通俗来讲：只有socket状态发生变化，epoll_wait函数才会返回。
3，水平触发优、缺点及应用场景：
优点：当进行socket通信的时候，保证了数据的完整输出，进行IO操作的时候，如果还有数据，就会一直的通知你。
缺点：由于只要还有数据，内核就会不停的从内核空间转到用户空间，所有占用了大量内核资源，试想一下当有大量数据到来的时候，每次读取一个字节，这样就会不停的进行切换。内核资源的浪费严重。效率来讲也是很低的。
应用场景：
4，边沿触发优、缺点及应用场景：
优点：每次内核只会通知一次，大大减少了内核资源的浪费，提高效率。
缺点：不能保证数据的完整。不能及时的取出所有的数据。
应用场景：处理大数据。使用non-block模式的socket。
总结：
如果我们用水平触发不用担心数据有没有读完因为下次epoll返回时，没有读完的socket依然会被返回，但是要注意这种模式下的写事件，因为是水平触发，每次socket可写时epoll都会返回，当我们写的数据包过大时，一次写不完，要多次才能写完或者每次socket写都写一个很小的数据包时，每次写都会被epoll检测到，因此长期关注socket写事件会无故cpu消耗过大甚至导致cpu跑满，所以在水平触发模式下我们一般不关注socket可写事件而是通过调用socket write或者send api函数来写socket，说到这我们可以看到这种模式在效率上是没有边缘触发高的，因为每个socket读或者写可能被返回两次甚至多次，所以有时候我们也会用到边缘触发但是这种模式下在读数据的时候一定要注意，因为如果一次可写事件我们没有把数据读完，如果没有读完，在socket没有新的数据可读时epoll就不回返回了，只有在新的数据到来时，我们才能读取到上次没有读完的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e40013e4cfc8e2f363316ba8a80b095/" rel="bookmark">
			算：前缀树，哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前缀树：
算：从Trie树（字典树）谈到后缀树（10.28修订）
剑指Offer——Trie树(字典树)
海量数据处理之Tire树（字典树） 字符串算法：Trie树（前缀树）、后缀树 https://blog.csdn.net/hyman_yx/article/details/54410619 Trie树（字典树，前缀树，键树）分析详解
https://blog.csdn.net/NK_test/article/details/47836119 Trie树的常见应用大总结（面试+附代码实现）
哈希表：
Redis底层详解（一） 哈希表和字典
哈希表（散列表）原理详解 哈希表详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3660036fd9173a0343f91c20b563b27/" rel="bookmark">
			总结：编写Hive UDF自定义函数（通过IP地址查询所属省份地市和运营商）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件记录字段包括：起始IP（Start_ip），结束IP（End_ip），运营商（IDC），省份（Province），地市（City）
1. 将输入的点分十进制IP地址转换成长数字类型 IP地址是一个32位的二进制数，将它划分为4个字节，每个字节是8位，因此每个字节所能表示的最大数字是2^8=255(从0开始)
public static long ip2long(String ip) { if (ip.matches("\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}")) { String[] ips = ip.split("[.]"); long ipNum = 0L; if (ips == null) return 0L; for (int i = 0; i &lt; ips.length; i++) ipNum = ipNum &lt;&lt; 8 | Long.parseLong(ips[i]); return ipNum; } return 0L; } 按位或运算符" | "运算的规则是将两个数字的二进制数按右边对齐，进行或运算，有1为1，全0为0，例如
1110 1011 0011 1000 1001 0110 0010 1010 1111 1111 0011 1010 &lt;--或运算之后的结果 ipNum &lt;&lt; 8表示二进制数ipNUm向左移8位，用十进制表达式表示就是十进制数ipNum * 2^8。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3660036fd9173a0343f91c20b563b27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e5b843101e6e5756e4feb40b5fa37a2/" rel="bookmark">
			c&#43;&#43;源码查找网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加：http://www.boost.org/
1、http://snippets.dzone.com/tag/c/ --数以千计的有用的C语言源代码片段 2、http://www.hotscripts.com/category/c-cpp/scripts-programs/ Hotscripts --提供数以百计的C和C++脚本和程序。所有程序都分为不同的类别。 3、http://www.planetsourcecode.com/vb/default.asp?lngWId=3 --超过万行C和C++免费的源代码 4、http://freshmeat.net/browse/164/ --超过9000个C编写的项目。 5、http://www.daniweb.com/code/c.html --DANIWEB提供的实用代码段 。 6、http://www.programmersheaven.com/tags/C/ --programmersheaven.com上的C编程资源。 7、http://www.ddj.com/code/ddj.html --Dr. Dobb’s Journal的源代码。 8、http://www.cprogramming.com/cgi-bin/source/source.cgi --C和C + +编程资源。 9、http://private.codecogs.com/ --CodeCogs是一项协作的开放源码库，C/C++的数值方面的组件。 10、[URL=http://www.google.com /codesearch?q=programming++lang:c&amp;cs_r=lang:c ]http://www.google.com/codesearch?q=programming++lang:c&amp;cs_r=lang:c [/URL] --谷歌代码的C源代码。 11、http://www.codepedia.com/1/C --CodePedia是一个开放的关于系统编程和其他与电脑有关的议题。 12、http://www.cis.temple.edu/~ingargio/cis71/code/ --为学生提供的一个简单的C语言程序的列表。 13、http://www.codeproject.com/?cat=2 --codeproject提供的C/C++资源代码项目。 14、http://www.thefreecountry.com/sourcecode/cpp.shtml --以下是一些C和C++库的DLL，VCLs，源代码，元件，模块，应用程序框架，类库，源代码片段等，你可以在您的项目中使用而不需要支付费用和版税。 15、[URL=http://people.sc.fsu.edu /~burkardt/cpp_src/cpp_src.html ]http://people.sc.fsu.edu/~burkardt/cpp_src/cpp_src.html [/URL] --这是一个全面的关于C++的345个源代码清单。 16、http://www.cplusplus.com/src/ --C++写的通用控制台程序和Windows程序代码清单。 17、http://users.cs.fiu.edu/~weiss/dsaa_c++/code/ --C++语言数据结构与算法分析（第二版）的源代码。 18、http://c.snippets.org/ --C源代码片段。 19、http://www.bbdsoft.com/downloads.html --C++源代码。 20、http://www.moshier.net/ 天文学和数值软件源代码 21、http://cplus.about.com/od/cgames/C_Games_with_Source_Code.htm --游戏有关的C++源代码。 22、[URL=http://cliodhna.cop.uop.edu /~hetrick/c-sources.html ]http://cliodhna.cop.uop.edu/~hetrick/c-sources.html [/URL] --免费的C/C++数值计算源代码。 23、http://www.mathtools.net/C_C__/Utilities/index.html --C/C++工具。 24、http://www.programmerworld.net/resources/c_library.htm --免费C++源代码和其它有用的工具。 25、http://www.cmcrossroads.com/bradapp/links/cplusplus-links.html --布拉德阿普尔顿的C++链接-资源，项目，图书馆，教学和编码。 26、http://www.robertnz.net/cpp_site.html --这是一个收集了数C/C++网站链接列表的网页。 27、http://www.josuttis.com/libbook/examples.html --在这里，你可以看到并下载所有的本书的C++标准库例子 。 28、ftp://66.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e5b843101e6e5756e4feb40b5fa37a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/742024678141ec6680e54d8cbad53d36/" rel="bookmark">
			转为16进制，八进制，十进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入整数显示十六进制（10分）
题目内容：
编写程序，输入一个非负整数，显示其十六进制形式。如输入31，输出1f。
输入:一个非负整数。
输出：一个十六进制数
提示：设n是非负整数，则cout&lt;&lt;hex&lt;&lt;n;显示n的十六进制形式。
样例1输入：
31
样例1输出：
1f
#include
#include using namespace std;
int main()
{
int a,b;
cin&gt;&gt;a;
b=a&gt;0?a:-a;
if(a&gt;0)
{
cout&lt;&lt;dec&lt;&lt;a&lt;&lt;" “;
cout&lt;&lt;hex&lt;&lt;a&lt;&lt;” “;
cout&lt;&lt;oct&lt;&lt;a;
}
else if(a&lt;0)
{
cout&lt;&lt;”-"&lt;&lt;dec&lt;&lt;b&lt;&lt;" “;
cout&lt;&lt;”-"&lt;&lt;hex&lt;&lt;b&lt;&lt;" “;
cout&lt;&lt;”-"&lt;&lt;oct&lt;&lt;b;
}
else if(a==0)
{
cout&lt;&lt;dec&lt;&lt;a&lt;&lt;" “;
cout&lt;&lt;hex&lt;&lt;a&lt;&lt;” ";
cout&lt;&lt;oct&lt;&lt;a;
}return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc4c2f8dd0832a2cc7f6b4d86552c917/" rel="bookmark">
			无序数组求中位数——小根堆法原理(附python代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小根堆法： 定义中位数为一个有序数组(len(array)+1)//2处的元素，“//”代表下取整。我知道中位数的定义分按照数组长度的奇偶性分两种，但是面试官会告诉你这里求的中位数就是有序数组(len(array)+1)//2处的元素。
如：
1 2 3 4 5 6 7 8 9 的中位数是(9+1)//2 = 5
1 2 3 4 5 6 7 8 9 10 的中位数是(10+1)//2=5
现在来求无序数组的中位数：
步骤 1 ：如果数组长度为奇数则取数组的前 (len(array)+1)//2 个元素建立 一个最小堆，如果为偶数则取(len(array)+1)//2 +1个元素建立 一个最小堆。
步骤 2 ：遍历剩余元素，如果该元素小于堆顶元素，则丢弃或不作处理；如果该元素大于堆顶元素，则将其取代堆顶元素，并且重新调整当前堆为最小堆。
步骤 3 ：遍历结束后，返回堆顶元素，它就是所要寻找的中位数。
原理：
(建立大根堆也是行得通，这里选小根堆来解释)
这里假设数组长度为奇数，步骤1中说是从前往后取(len(array)+1)//2 个元素建立 一个最小堆，其实任意取(len(array)+1)//2 个元素都可以，所取的这(len(array)+1)//2 个元素有两种可能的情况。
情况1：这(len(array)+1)//2 个元素中包含了中位数。
情况2：这(len(array)+1)//2 个元素没有包含中位数。
对于情况1:
中位数可能位于堆顶或者堆内部。
(1)当中位数位于堆顶的时候，因为是小根堆，所以数组内所有比中位数大的元素都在小根堆内，此时遍历数组剩余元素，根本不可能找到比堆顶大的元素，所以遍历完数组剩余元素堆顶保持不变。
如1 2 3 4 5 6 7 8 9 任取(9+1)//2=5个元素建立小根堆，如果5是堆顶，那堆内的其余元素只能是6 7 8 9了。遍历剩余元素1 2 3 4 ，堆顶保持不变。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc4c2f8dd0832a2cc7f6b4d86552c917/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56d7a6e48409fd0af6ed403d11a542f2/" rel="bookmark">
			JAVA迭代器原理源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 迭代器为什么不定义成类，而定义为一个借口？ 假设迭代器定义为一个类，我们就可以通过创建对象调用方法来实现集合的遍历。
但是，java中拥有很多种集合，他们的数据结构是各不相同的，所以遍历的方式应该是不一样的！
最终就没有定义为迭代器类，而无论你是哪种集合都应该具有遍历功能，包含（判断、获取等功能）
判断和获取等功能应该是每种集合都应该具备的，而具体的实现方式又不太一样
所以把这些特有的功能提取出来，而不提供具体的实现。这种方式就是接口！！
在真正的具体子类中，以内部类的方式实现 ArrayList中迭代器的具体实现如下 public interface Inteator { public abstract boolean hasNext(); public abstract Object next(); } public interface Iterable { Iterator iterator(); } public interface Collection extends Iterable { Iterator iterator(); } public interface List extends Collection { Iterator iterator(); } public calss ArrayList implements List { public Iterator iterator() { return new Itr(); } private class Itr implements Iterator { //接口的具体实现类 //包含了 所需功能 next() hasNext() 等 } } //编译看左边，运行看右边~~~ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e73b4c2c8f3e9e229fe0370b96edad2/" rel="bookmark">
			去除wps我的电脑中（网盘和右键菜单展示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 自定义图标展示，打开wps登录图标
2.右键图标，进入设置页面
3.点击应用即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d40d9b0b802df529bb7b04b6f5c7f222/" rel="bookmark">
			httpbin.org的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、https://httpbin.org/headers返回headers信息
二、https://httpbin.org/ip返回你使用的访问此链接的IP地址
三、https://httpbin.org/user-agent返回USER-AGENT信息
四、http://httpbin.org/get?show_env=1返回更为详细的信息（被图掉部分为IP）
小知识： (1) 透明代理
代理服务器将客户端的信息转发至目标访问对象，并没有完全隐藏客户端真实的身份。即服务器知道客户端使用了代理IP，并且知道客户端的真实IP地址。
(2) 普通匿名代理
代理服务器用自己的IP代替了客户端的真实IP，但是告诉了目标访问对象这是代理访问。
(3) 高匿代理
代理服务器良好地伪装了客户端，不但用一个随机的IP代替了客户端的IP，也隐藏了代理信息，服务器不会察觉到客户端是通过代理实现访问的，即用户仿佛就是直接使用代理服务器作为自己的客户端，618国内IP代理就是高匿名的服务器。
所以使用高匿代理就可以隐藏自己的真实IP了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faeee0d5d196a5a1f5145c4fdf25160d/" rel="bookmark">
			Seata实战-分布式事务简介及demo上手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Seata简介分布式事务产生背景数据库的水平分割微服务化 分布式事务理论基础两阶段提交(2pc)TCC基本原理幂等控制空回滚防悬挂 事务消息优缺点比较 Seata解决方案AT模式(业务侵入小)第一阶段第二阶段 TCC(高性能) Demo上手-AT模式Dubbo集成Seata配置修改启动测试 Demo上手-TCC模式Dubbo集成Seata配置修改启动测试 Seata简介 Seata(Simple Extensible Autonomous Transaction Architecture) 是 阿里巴巴开源的分布式事务中间件，以高效并且对业务 0 侵入的方式，解决微服务场景下面临的分布式事务问题。
附上项目github链接
https://github.com/seata
目前Seata还处于不断开源升级中，并不建议在线上使用，生产环境可以考虑使用阿里云商用的GTS，附上Seata目前的升级计划，可以考虑在V1.0，即服务端HA集群版本进行线上使用
先来看下为什么会产生分布式事务问题
分布式事务产生背景 讲到事务，又得搬出经典的银行转账问题了，下面以实例说明
假设银行(bank)中有两个客户(name)张三和李四
我们需要将张三的1000元存款(sal)转到李四的账户上
目标就是张三账户减1000，李四账户加1000，不能出现中间步骤(张三减1000，李四没加)
假设dao层代码如下
public interface BankMapper { /** * @param userName 用户名 * @param changeSal 余额变动值 */ public void updateSal(String userName,int changeSal); } 对应xml中sql如下
&lt;update id="updateSal"&gt; update bank SET sal = sal+#{changeSal} WHERE name = #{userName} &lt;/update&gt; 如果两个用户对应的银行存款数据在一个数据源中，即一个数据库中，那么service层代码可以如下编写
/** * @param fromUserName 转账人 * @param toUserName 被转账人 * @param changeSal 转账额度 */ @Transactional(rollbackFor = Exception.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faeee0d5d196a5a1f5145c4fdf25160d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5032d394256dabff22cf6ff9bbc8abe1/" rel="bookmark">
			(pre-receive hook declined)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		remote: GitLab: You are not allowed to push code to protected branches on this project.
To 106.13.91.39:webtest/wow.git
! [remote rejected] master -&gt; master (pre-receive hook declined)
error: failed to push some refs to 'git@106.13.91.39:webtest/wow.git'
提交代码时报这个
原因是没有提交代码到master分支的权限
到gitlab修改权限就可以提交了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05252c8dcbfc8226ee98bf868fa2433b/" rel="bookmark">
			线程池都有哪几种工作队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 1、ArrayBlockingQueue
是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
2、LinkedBlockingQueue
一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列
3、SynchronousQueue
一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool（5）使用了这个队列。
4、PriorityBlockingQueue
一个具有优先级的无限阻塞队列。
转载于:https://my.oschina.net/u/3847203/blog/3034100
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/876c9bb3b989398b3d9d5346ae405c77/" rel="bookmark">
			4.Python中条件语句使用方法（if语句、if嵌套）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。
可以通过下图来简单了解条件语句的执行过程：
1.if条件语句的基本用法： if 判断条件： 执行语句…… else： 执行语句…… 其中"判断条件"成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。
else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。
实例：
if实例： age = 18 if age &gt;= 18: print('你已成年！') else: print('你未成年！') 结果：
2.if条件语句的嵌套方式一： if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系。
当判断条件为多个值时，可以使用以下形式：
if 判断条件1: 执行语句1…… elif 判断条件2: 执行语句2…… elif 判断条件3: 执行语句3…… else: 执行语句4…… 实例：
holiday_name = '植树节' if holiday_name == '情人节': print('买礼物，买花，买包，买化妆品') elif holiday_name == '愚人节': print('吃饭') else: print('不过节') 结果：
3.if条件语句的嵌套方式二： if 条件1: 条件1满足执行的动作 if 满足条件1的基础上的条件2: ... else: 条件2不满足的情况下 else: 条件1不满足时，执行的动作 实例： have_ticket = False knife_length = 21 if have_ticket: print('已有车票，请安检.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/876c9bb3b989398b3d9d5346ae405c77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5889a33e102ccab3c046813221e70619/" rel="bookmark">
			C语言实现学生信息管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、题目分析二、关键算法构造：三、程序实现：四、调试、测试、及运行结果五、经验归纳 一、题目分析 对学生信息管理系统，要求完成以下基本任务：
改写程序为良好程序风格（文档注释，函数注释，语句注释）。将功能补充完全（基于文件处理，完成刷新和保存功能）。将学生信息改为更好的数据组织，而非离散形式（结构体）。可将程序中的不足（如数据验证）等根据自己的能力与理解完成。 用使用C语言做一个学生信息管理系统，我的想法是先把需要的一些变量封装在结构体中，然后结合以前学过的数据结构知识（链表），做一些增删查改的操作，并将其保存在文件中。
二、关键算法构造： typedef struct score //成绩 { int score_c;	//C语言成绩 int score_math;	//高等数学成绩 int score_english;	//大学英语成绩 }Score; typedef struct Student { char name[100]; //姓名 char num[100]; //学号 char sex;	//性别 (m代表女生f代表男生) int age;	//年龄 Score score;	//成绩 }stu; typedef struct LNode { stu data; struct LNode *next; }LinkList; 流程图：
三、程序实现： #include &lt;stdio.h&gt; #include &lt;malloc.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; typedef struct score { int score_c;	//C语言成绩 int score_math;	//高等数学 int score_english; //大学英语成绩 }Score; typedef struct Student { char name[100]; //姓名 char num[100]; //学号 char sex;	//性别 (m代表女生f代表男生) int age;	//年龄 Score score;	//成绩 }stu; typedef struct LNode { stu data; struct LNode *next; }LinkList; char nam[100];//名字 char nu[100];//学号 char s;//性别 int ag;//年龄 Score sc;//成绩 void menu()/* 菜单界面*/ { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5889a33e102ccab3c046813221e70619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63555bebd598d40be3403e949821e2d3/" rel="bookmark">
			flutter项目连接不了夜神模拟器的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：Android studio 下的Android项目能够正常连接夜神模拟器，新建flutter项目无法连接
查找问题：
cmd 下输入命令行 adb version
cmd 定位到夜神模拟器安装目录bin下 ，输入命令行 adb version
发现两个adb的版本不一致，这直接导致了flutter项目无法识别夜神模拟器。
解决方案
copy AndroidSDK目录下的platform-tools下的adb.exe 到 Nox \ bin下，并重命名为nox_adb.exe,替换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a978e0f37580783689c8e65b551a57b6/" rel="bookmark">
			前端学习-jQuery实现焦点图无缝轮播特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		焦点图无缝轮播原理：一开始先把第一张图片克隆并粘贴在图片列表的最后，我简单用数字代表图片一下，1 2 3 4 5 1,这里的数字就是不同的图片，可以看见有五张不同的图片，但是要把第一张复制粘贴到列表的最后，这样我们在滑动到 5 这张图片的时候再滑动就可以无缝到"第一张"的感觉，但是还没完，得想办法回去真正的第一张，我们就可以用一个if来判断，当无缝滑动到克隆的 1 以后，获取图片列表对象，调用css方法设置left回到第一张，这个办法回去肉眼是看不出来的，是一瞬间的事情，所以继续滑动也就形成了完美的无缝循环。接下来是代码。
&lt;script src="js/jquery-3.3.1.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function(){ /*按钮移入效果*/ $(".image-box .btn_L").mouseover(function(){ $(this).css({"color":"#4B0082","font-size":"45px","font-weight":"bold"}); }) $(".image-box .btn_L").mouseout(function(){ $(this).css({"color":"#fff","font-size":"35px","font-weight":"normal"}); }) $(".image-box .btn_R").mouseover(function(){ $(this).css({"color":"#4B0082","font-size":"45px","font-weight":"bold"}); }) $(".image-box .btn_R").mouseout(function(){ $(this).css({"color":"#fff","font-size":"35px","font-weight":"normal"}); }) /*按钮移入效果*/ /*图像移动函数*/ var i = 0; var clone=$(".image-box .img li").first().clone();//复制第一张 $(".image-box .img").append(clone);//粘贴复制的到列表后面 var size = $(".image-box .img li").length;//获取图片长度 $(".image-box .btn_L").click(function(){ moveL(); }) $(".image-box .btn_R").click(function(){ moveR(); }) function moveL() { i++; if(i==size) { $(".image-box .img").css({left:0}); i = 1; } $("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a978e0f37580783689c8e65b551a57b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4964f8dea02d40906993dcc100a1b33/" rel="bookmark">
			静态编译qt 5.7.1 引用sqlcipher 之openssl问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Mingw下静态编译qt 5.7.1, 使用openssl 1.0.6d, 编译出来使用正常，然后下载最新的sqlcipher, 用最新的openssl 1.1.1b, 然后编译完毕正常运行。
现在开始改写qt sqlite 插件，试图静态连编，结果最后连接的时候无法找到HMAC_CTX_new函数 ，进入到sqlite.c一看，发现这个函数 需要特定的openssl版本。。。。果断注释掉宏重新编译，一切正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e30990e66ab702820e92813bc259e2b0/" rel="bookmark">
			ubuntu安装配置zookeeper和kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(一)zookeeper 1.下载zookeeper 下载地址: http://apache.fayea.com/zookeeper/ 我用的3.4.10版本的 2.解压zookeeper 解压后的目录结构 3.配置zookeeper 进入 conf文件夹下,有一个zoo_sample.cfg文件,这是一个简单的配置例子,我们需要将它改名为 zoo.cfg,我是复制重命名的,并且把带#的注释去了 4.启动zookeeper 在bin目录下 ./zkServer.sh start 可以测试一下是否启动成功 在bin目录下 ./zkCli.sh ok , zookeeper的单机版已经部署成功了 (二)kafka 1.下载kafka 下载地址:http://apache.fayea.com/kafka/2.1.0/ 2.解压kafka 解压后的根目录结构如下
3.启动kafka服务 在bin目录下,启动,指定根目录config下的配置文件,不要关闭该终端
./kafka-server-start.sh ../config/server.properties
4.创建topic 在bin目录下
./kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test
5.查看topic 在bin目录下
./kafka-topics.sh --list --zookeeper localhost:2181
6.产生消息，创建消息生产者 在bin目录下
./kafka-console-producer.sh --broker-list localhost:9092 --topic test
7.消费消息，创建消息消费者,在生产者中发送的消息都会出现在消费者中 在bin目录下
./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning
这样本机的kafka环境就搭建好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94642fecf1fccd463abfc7ee56a92b9/" rel="bookmark">
			faceswap 安装使用详情
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近对AI换脸比较感兴趣，就看了一下faceswap的使用。
1.下载代码：
https://github.com/deepfakes/faceswap
2.安装python 3.xx版本，之前是2.x不能正常工作
3.运行setup.py
wudi:faceswap xiepengchong$ python setup.py WARNING Running without root/admin privileges INFO The tool provides tips for installation and installs required python packages INFO Setup in Darwin 17.7.0 INFO Installed Python: 3.5.1 64bit INFO Encoding: UTF-8 INFO Upgrading pip... INFO Installed pip: 7.1.2 Enable Docker? [y/N] y INFO Docker Enabled Enable CUDA? [Y/n] Y INFO CUDA Enabled WARNING Nvidia-Docker is only supported on Linux. Only CPU is supported in Docker for your system Enable Docker?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c94642fecf1fccd463abfc7ee56a92b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61b9efbf4b88df4f4363d587e2e5391/" rel="bookmark">
			pytorch如何在测试的时候启用dropout
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们知道，dropout一般都在训练的时候使用，那么测试的时候如何也开启dropout呢？
在pytorch中，网络有train和eval两种模式，在train模式下，dropout和batch normalization会生效，而val模式下，dropout不生效，bn固定参数。
想要在测试的时候使用dropout，可以把dropout单独设为train模式，这里可以使用apply函数：
def apply_dropout(m): if type(m) == nn.Dropout: m.train() 下面是完整demo代码：
# coding: utf-8 import torch import torch.nn as nn import numpy as np class SimpleNet(nn.Module): def __init__(self): super(SimpleNet, self).__init__() self.fc = nn.Linear(8, 8) self.dropout = nn.Dropout(0.5) def forward(self, x): x = self.fc(x) x = self.dropout(x) return x net = SimpleNet() x = torch.FloatTensor([1]*8) net.train() y = net(x) print('train mode result: ', y) net.eval() y = net(x) print('eval mode result: ', y) net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e61b9efbf4b88df4f4363d587e2e5391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1c1350eb8b45c85e6c0c04fc161eaf/" rel="bookmark">
			flask 中ajax 传递参数应用场景与form表单传递参数的场景小心得
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先是ajax 在flask中的应用步骤的实现：
在前端html中的表现形式：
function recover_send(uid){ var act='recover'; var id=uid; $.ajax({ url:'/account/ops', type:'POST', data:{'act':act,'id':id}, dataType:'json', success:function(res){ if(res['code']==200){ alert('数据恢复成功'); window.location.href='/account/index'; } } }) } 后端flask 中的数据呈现 def search(): req=request.values statuss=req['status'] keys=req['keys'] print(statuss) if statuss=='-1': return jsonify({'code':200,'msg':'请选择状态'}) elif statuss=='1': query = User.query.filter(User.status==1) list = query.all() return jsonify({'code': 200, 'msg': '查询现存状态'}) else: query = User.query.filter(User.status==0) list = query.all() return jsonify({'code':200,'msg':'查询删除状态'}) 这里需要注意的是 返回的是json的数据，不是视图模板 form表单的形式实现数据传递：
def index(): req=request.values query = User.query if 'mix_kw' in req: rule=or_(User.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba1c1350eb8b45c85e6c0c04fc161eaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa5d1ff400468ebb5260b831c184593/" rel="bookmark">
			【verilog语法】关于testbench与被测module的输入输出数据类型定义：reg/wire原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		testbench的输入输出数据类型正好与被测模块相反 1、被测module中，输入为wire，输出为reg
输入信号是由模块外部决定的，输入数据的状态是变化的,与外部模块是通过线连接，所以用wire，不用reg
2、testbench中，输入为reg，输出为wire
所谓寄存器类型就是暂存一个数据，保持数据不变。
在testbenchb里定义的A，B输出给被测模块
因此对于testbench来说，A，B是输出，数据需要存储才能输出给被测module，用reg型
在testbenchb里定义的result用来接收从被测模块中输入的数据
因此对于testbenchb来说，result是输入，用导线与被测模块连接，用wire型
也就是说，tb的输出对应着被测模块的输入；tb的输入对应着被测模块的输出
注意：只要是always块内部的变量输出，都用reg型
代码示例 文件名称：alu_tb
`timescale 1ns/1ns	//仿真时间单位/时间精度 `include "alu.v" module ALU_tb; reg [31:0] A; reg [31:0] B; reg [4:0] sl;	//左移的位数 reg [2:0] ALUctr;	//3位ALU控制信号 wire [31:0] Result;	// wire zero;	//零标志位 ALU myalu(A,B,sl,ALUctr,Result,zero); always #2 A&lt;=A+1; initial begin A=32'hffff_fff0;B=0;sl=0;ALUctr=3'b010; #0 B&lt;=1;	//因为begin-end是串行，实际上是第5+5ns开始对b赋值 end initial begin $monitor($time,,"%d + %d = %d",A,B,Result); #100 $finish; end endmodule always与reg辨析（转自百度知道） 问：
verilog里面always与reg分别代表什么意思，有什么功用？
为什么只对输出用reg，对输入不用？
答：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa5d1ff400468ebb5260b831c184593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066fc4f3240fed9e77251975cc294a11/" rel="bookmark">
			编码(decode与encode)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 1. 什么是编码2. 编码方式属性3. decode与encode 1. 什么是编码 事实上计算机只认0或1，然而却可以通过计算机来显示文本，这就是靠编码来实现的。
编码其实就是约定的一个协议，比如ASII编码约定了大写字母A对应十进制65，那么在读取一个字符串的时候，看到65，计算机就知道这是大写字母A的意思
由于计算机是美国发明的，所以这个ASCII编码设计时只采用1个字节存储，包含了大小写英文字母、数字和一些符号。但是计算机在全世界普及之后，ASCII编码就成了一个瓶颈，因为1个字节是完全不足以表示各国语言的
大家知道英文只用26个字母就可以组成不同的单词，而汉字光长用字就有好几千个，至少需要2个字节才足以存放，所以后来中国制定了GB2312，用于对汉字进行编码
然后的然后日本，韩国也制定了各自的编码，然后就出现冲突了，就导致了最初计算机上总是容易看到乱码的现象
为了解决这个问题，Unicode编码应运而生。Unicode组织的想法最初也很简单，创建一个足够大的编码，将所有国家的编码都加进来，进行统一标准。
随着问题的解决，新的问题也出现了，如果你写的文本只包含英文和数字，那么用Unicode编码就显得特别浪费存储空间（使用ASCII编码只占用一半的存储空间），所以本着能省一点是一点的精神，Unicode还创造了多种实现方式
比如常见的UTF-8编码就是Unicode的一种实现方式，它是可变长编码。
简单来说就是，当文本是ASCII编码的字符时，它用1个字节存放；而当文本是其他Unicode字符的情况，它将按一定的算法转换，每个字符使用1~3个字节存放。
2. 编码方式属性 GB2312UTF-8UnicodeGB2312编码专门用来解决中文编码的，是双字节的,并且不论中英文都是双字节的;包含全部中文字符；总的来说GB2312编码方式的编码是以中国国情而创造的，在国际上的兼容性不好。UTF－8 编码是Unicode的一种实现方式，因为对于大多数语言，只需要一个字节就能够编码，如果都采用Unicode会极大浪费，于是出现了可变长编码UTF-8。它对英文使用8位（即一个字节），中文使用24位（三个字节）来编码。另外，如果是外国人访问你的GB2312网页，需要下载中文语言包支持。访问UTF-8编码的网页则不出现这问题。可以直接访问。这也是为什么大多数的网页是使用UTF-8编码而不是GB2312。目前几乎收纳了全世界大部分的字符。所有的字符都有唯一的编号，这就解决了解码的冲突！但是，unicode把大家都归纳进来，却没有为编码的二进制传输和二进制解码做出规定。 3. decode与encode decodeencodedecode的作用是将其他编码的字符串转换成unicode编码，如str1.decode(‘gb2312’)，表示将gbk编码的字符串str1转换成unicode编码。encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘gb2312’)，表示将unicode编码的字符串str2转换成gbk编码。 encode：用于编码 str.encode(encoding='UTF-8',errors='strict') #	encoding -- 要使用的编码，如"UTF-8" #	errors -- 设置不同错误的处理方案 该方法返回编码后的字符串
u='我喜欢你啊！' str1=u.encode('gb2312') print(str1) # b'\xce\xd2\xcf\xb2\xbb\xb6\xc4\xe3\xb0\xa1\xa3\xa1' decode：encoding 指定的编码格式解码字符串。默认编码为字符串编码 str.decode(encoding='UTF-8',errors='strict') #	encoding -- 要使用的编码，如"UTF-8" #	errors -- 设置不同错误的处理方案 该方法返回解码后的字符串
u='我喜欢你啊！' str1=u.encode('gb2312') print(str1.decode('gb2312')) #	我喜欢你啊！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/718af7c1655d6373b38434aa493b7ad3/" rel="bookmark">
			LeetCode两数相加(链表)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { if(nullptr==l1){ return l2; } if(nullptr==l2){ return l1; } ListNode* head=nullptr;//用来保存加起来的第一个结点 ListNode* tmp=head;//用tmp来更新下一个结点 int step=0;//表示进位 while(l1!=nullptr||l2!=nullptr){ int sum=0;//每次加完都要更新sum sum+=step;//先加进位 if(l1!=nullptr){ sum+=l1-&gt;val; l1=l1-&gt;next; } if(l2!=nullptr){ sum+=l2-&gt;val; l2=l2-&gt;next; } if(sum&gt;9){//大于9表示有进位 sum-=10; step=1; } else{ step=0;//更新step } ListNode* cur=new ListNode(sum); if(head==nullptr){ head=cur; //将第一个结点保存起来 tmp=head; } else{ tmp-&gt;next=cur; tmp=cur; } } if(step&gt;0){//如果最后两个相加有进位 ListNode* cur=new ListNode(1); tmp-&gt;next=cur; } return head; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4775f7644568dbc6c4ff695142108b37/" rel="bookmark">
			python生成随机整数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python生成随机不重复的整数，用random中的sample
index = random.sample(range(0,10),10) 上面是生成不重复的10个从1~10的整数
python生成完全随机的整数，用numpy中的random.randint
index = np.random.randint(0,10,size=10) 生成的是可能会重复的10个从0~10的整数
转载于:https://www.cnblogs.com/yanxingang/p/10653487.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69b787bd39afe516fb06fb0188d426f/" rel="bookmark">
			xgboost 可视化与结果分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 xgboost 的可视化，调用 xgb.to_graphviz 或 xgb.plot_tree 接口；
1. 指定 fmap（feature map） https://www.kaggle.com/mmueller/xgb-feature-importance-python
按照 feature map 的格式，编写 fmap 文件：
def ceate_feature_map(features, fmap_filename): outfile = open(fmap_filename, 'w') i = 0 for feat in features: outfile.write('{0}\t{1}\tq\n'.format(i, feat)) i = i + 1 outfile.close() # 调用 fmap_filename = 'xgb.fmap' create_feature_map(X_train.columns, fmap_filename) 将 xgb.fmap 文件传入 xgb.plot_tree 文件中：
xgb.plot_tree(bst, fmap=fmap_filename) 指定图像的大小：
fig = ptl.gcf() fig.set_size_inches(150, 100) 2. 结果分析 bst.get_dump()
查看各棵树的结构； bst.predict 的参数：
pred_leaf=True，各棵树对各个样本的预测的叶子； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a32a0c00c12c50e5bf408e5147bac4/" rel="bookmark">
			Jetson AGX Xavier JetPack 4.2环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jetson AGX Xavier 去年，NVIDIA在苏州举办了GTC China大会上发布的AI计算平台，主要用于移动端的计算。想法美好，不过配起来环境还是遇到了很多问题，一些是软件，另一些甚至还有硬件。
设备需求 Jetson AGX Xavier（当然）显示器（两台，一个给host主机，一个给Xavier平台，配套的hdmi线）网线（也要备两根）键鼠（一套就行，主要工作在host上）usb type C（用原装。。） 刷机过程 主机配置（虚拟机） 主机host的要求是linux系统，为了满足要求又不想太麻烦用多机多系统，可以选择虚拟机进行主机的设置。一开始我还用了win10自带的Hyper-V，但实际上很不好用，走了一小段弯路。之后才老老实实使用Vmware workstation。
这大概是最低配置了，注意一下硬盘空间（当然我安装时没注意选择了host的cuda这一堆，占了不少地方）。操作系统使用的是Ubuntu 18.04，老的16.04在其他教程上也见过，应该也没有什么问题。
安装sdkmanager 主机host端到官网下载
下载后输入sudo apt install /PATH_TO_SDKMANAGER，把PATH_TO_SDKMANAGER对应为你的下载文件。然后就会自动安装。
烧录镜像 下载 安装成功后，直接运行SDKManager即可，第一步会让你输入Nvida账号。然后来到第二部，选择要安装组件。
这里主机上的套件（HOST）应该不是必须的，下面的（TARGET）要选上，特别是CUDA和AI这两项。之后就会进入漫长的下载，不过是一边下载一边安装，节省了时间。
小技巧是点右上角的菜单栏，在设置中可以改把最大下载连接数，默认是1，可以改成3来加速。
烧录 安装之后，会让你选择烧录方式。此时就要先把Xavier的线先给连好了。
hdmi键盘鼠标网线（同时要求与host处于一个局域网中）与host相连的USB type-c线（使用原装线！！！！手机的不行！！！别问我为啥）最后，是电源线 自动方式是要烧录了Jetson OS系统之后才能使用，因为它对网络进行了设置。这是安装系统内套件用的。
手动方式就需要自己动手进入recovery模式：
用原装usb先将host与Xavier连接，还要注意是连接电源灯旁边的插口手动进入recovery模式 确保连接电源并保持Xavier为关闭状态；按住中间的按键（Force Recovery）不松手按住左边的电源（Power）不松手过一两秒，同时松手 如下图的指示：
如果成功进入Recovery模式，host的虚拟机VMware会弹出提示，这时记得要把连接给虚拟机内，而不是主机。不然就无法在虚拟机内部找到这个硬件。
如果想要确认是否连接，可以在命令行中输入lsusb，如果里面有NVidia Corp.这一项则代表成功。
之后就可以点Flash开始烧录，接着便是漫长的等待。。。
烧录成后Xavier上就有了系统，此时显示屏上会有System Configuration，一步一步走，记住最后的用户名和密码。然后一路继续，重启后就能进入系统啦。
安装SDK 套件 这一步是需要在Xavier系统运行时安装的，因此务必保证：
使用原装USB线与host主机相连System Configuration步骤完成Xavier上正在运行配置好的Ubuntu系统确保网线相连，并处于一个局域网中 否则就会报错：
这时一步一步检查，具体可以到TERMINAL中查看报错信息。我就始终没有成功连接上USB，即使上一步能在Recovery中找到。然而忙活了半天，发现居然是因为USB线的原因！换上原装USB线就可以找到了！仔细观察两根还是不同的，原装是蓝色端口且标有“SS”，因此要认准这个标志了。
切换源！ 这一节其实不必要，但错了问题就会很大。通常我都会有安装系统切换更新源到国内的习惯，这次没细心，直接搜了Ubuntu的源，复制过来，发现会导致找不到源的错误。
仔细对比原始source文件和网上的源，发现之间是不同的：
网上搜索得来的源一般都是：
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a32a0c00c12c50e5bf408e5147bac4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89080f28ae405c9948ebedf7ba1b0b36/" rel="bookmark">
			【For非数学专业】通俗理解似然函数、概率、极大似然估计和对数似然
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 似然函数与概率1.1 似然函数与概率的初步认识1.2 似然的定义1.3 结合具体实例来深入理解似然与概率 2. 极大似然估计3. 对数似然函数4. 总结 1. 似然函数与概率 1.1 似然函数与概率的初步认识 似然函数，在机器学习的算法模型中，可以说是“老熟人”了，虽然总感觉自己已经掌握了这个概念，但是每次遇到具体的情况时，发现还是难以说清楚，于是根据wiki上关于Likelihood function的解释，以及个人的学习理解，整理笔记如下：
在统计学中，似然函数（或简称似然）是一个基于给定数据模型参数的特殊函数，似然(likelihood)与概率(probability)所表示的意义是完全不同的，具体如下：
在给定参数值的情况下，概率用于描述未来出现某种情况的观测数据的可信度。
在给定观测数据的情况下，似然用于描述参数值的可信度。
听起来可能会觉得摸不着头脑，先不着急，待我给出似然的定义之后，我们再来结合具体实例来理解上面的两句话。
1.2 似然的定义 根据概率的分布属于离散型还是连续型，似然函数的定义也略有不同，下面分别进行说明：
（1）对于离散型变量
假设X是一个离散型的随机变量，它的概率分布p取决于参数θ，那么它的似然函数定义为：
L ( θ ∣ x ) = p θ ( x ) = P θ ( X = x ) = P ( X = x ∣ θ ) = P ( X = x ; θ ) L(\theta | x)=p_{\theta}(x)=P_{\theta}(X=x)=P(X=x | \theta)=P(X=x ; \theta) L(θ∣x)=pθ​(x)=Pθ​(X=x)=P(X=x∣θ)=P(X=x;θ) 【注】其中 L ( θ ∣ x ) L(\theta | x) L(θ∣x) 为 L ( Θ = θ ∣ X = x ) L(\Theta=\theta | X=x) L(Θ=θ∣X=x) 的缩写，它表示基于给定的X=x，我们认为参数Θ=θ的似然（可信度），它的值则等于基于给定的参数Θ=θ，我们预测出现X=x的概率（可信度）（概率有好几种表达方式，这里全部列举了出来…）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89080f28ae405c9948ebedf7ba1b0b36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/250688c5e42c16f0bb956f024ab81752/" rel="bookmark">
			51单片机学习笔记（蜂鸣器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蜂鸣器简介 在单片机应用的设计上，很多方案都会用到蜂鸣器，大部分都是使用蜂鸣器来做提示或报警，比如按键按下、开始工作、工作结束或是故障等等。
自激蜂鸣器是直流电压驱动的，不需要利用交流信号进行驱动，只需对驱动口输出驱动电平并通过放大电路放大驱动电流就能使蜂鸣器发出声音，非常简单。
改变单片机引脚输出波形的频率，就可以调整控制蜂鸣器音调，产生各种不同音色、音调的声音。改变输出电平的高低电平占空比，则可以控制蜂鸣器的声音大小。 原理图 电流从P15进入通过ULN2003D芯片到达BZ（无源蜂鸣器），ULN2003D芯片起到一个放大电流的作用，ULN2003D是大电流驱动阵列，可直接驱动蜂鸣器，继电器等负载。要使蜂鸣器发声只需要输出一定频率的脉冲。
以下为驱动蜂鸣器的程序
#include "reg52.h" #include&lt;intrins.h&gt; typedef unsigned int u16; typedef unsigned char u8; sbit beep=P1^5;//定义蜂鸣器管脚 void delay(u16 i) { while(i--); } void Beep()//高低电平的变化使输出脉冲 { beep=~beep;//进行高低电平的转换，‘~’是取反符号 delay(100);//延时 } void main() { while(1) { Beep(); } } 改变delay(i)中的参数i，可以改变音调，音色。
改变高低电平的占比可以改变声音的大小。
大家可以试着调出一个电子琴来哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae14e8cba2a3d95038d663c3ab3b602/" rel="bookmark">
			matlab中switch函数的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下列子函数中switch用于变量和函数的多分支选择问题
使用格式如下：switch-case-end
switch 变量
case 常量1
语句序列1；
case 常量2
语句序列2；
…
case 常量n
语句序列n;
otherwise
语句序列；
end
举例如下：
function [lb,ub,dim,fobj] = Get_Functions_details(F)
switch F
case ‘F1’
fobj = @F1;
lb=-100;
ub=100;
dim=30;
case 'F2' fobj = @F2; lb=-10; ub=10; dim=30; case 'F3' fobj = @F3; lb=-100; ub=100; dim=30; end
end
% 函数F1
function o = F1(x)
o=sum(x.^2);
end
% 函数F2
function o = F2(x)
o=sum(abs(x))+prod(abs(x));
end
%函数 F3
function o = F3(x)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aae14e8cba2a3d95038d663c3ab3b602/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e245bd0df11d72f8194eb57a394cf6/" rel="bookmark">
			有道词典的本地/扩展/离线词库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网易有道词典纯净版(飞扬时空)：https://pan.baidu.com/s/1c1yfMsK
本版本主要进行如下修改和定制：
去除主窗口底部横幅广告
去除取词窗口及查询结果中的广告内容
去除翻译页面及结果「人工翻译」按钮
去除主窗口左侧「人工翻译」、「精品课」、「满意度调查」标签
优化程序设置：默认关闭开机启动、自动更新、每日推荐、网易精选等选项
安装程序采用官方界面风格，并具备程序运行检测、现有版本检测及卸载等功能
更多说明：https://www.52pojie.cn/thread-781018-1-1.html 离线词库文件下载：http://download.huzheng.org/zh_CN/
参考
HYFH
转载于:https://www.cnblogs.com/ourweiguan/p/10647179.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191a3e5900b64d9bcb0bede7fa0ba77a/" rel="bookmark">
			python 获取毫秒级时间问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据网上的一些说法，在python里获取ms级系统时间可以通过以下方式获取：
import datetime print(datetime.datetime.now().microsecond) 但通过以下代码测试，发现返回的并不是ms的值，而是us的值：
import datetime def getTime_ms(): return (datetime.datetime.now().hour*3600 +\ datetime.datetime.now().minute*60+\ datetime.datetime.now().second )*1000+\ datetime.datetime.now().microsecond/1000 def timetime(): t = getTime_ms() while getTime_ms() - t &lt; 500: pass a = getTime_ms() print(t, a, a- t) if __name__ == '__main__': from timeit import timeit t = timeit('timetime()', 'from __main__ import timetime', number=1) print(t) 打印结果;
(35460614, 35461114, 500)
0.499531984329
上面实验不太直观，换一个直观点的：
def timetime(): t1 = datetime.datetime.now() while 1: t2 = datetime.datetime.now() if (t2 - t1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/191a3e5900b64d9bcb0bede7fa0ba77a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cffdf7644b451b21636d65d19f74d36/" rel="bookmark">
			求字节数表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		求字节的运算符为：sizeof ，该运算符的作用是测试数据类型或变量在内存中存放时所占的字节数 ，C语言中 sizeof 运算符是一个单目运算符。其格式： sizeof（&lt;类型说明符&gt;|&lt;变量名&gt;）
相同类型在不同系统或机型中所占内存的字节数可能不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fbe4c8f6e8b48a720ff91bfc8584e48/" rel="bookmark">
			L1-056 猜数字 （20 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		L1-056 猜数字 （20 分)
一群人坐在一起，每人猜一个 100 以内的数，谁的数字最接近大家平均数的一半就赢。本题就要求你找出其中的赢家。
输入格式：
输入在第一行给出一个正整数N（≤10
​4
​​ ）。随后 N 行，每行给出一个玩家的名字（由不超过8个英文字母组成的字符串）和其猜的正整数（≤ 100）。
输出格式：
在一行中顺序输出：大家平均数的一半（只输出整数部分）、赢家的名字，其间以空格分隔。题目保证赢家是唯一的。
输入样例：
7
Bob 35
Amy 28
James 98
Alice 11
Jack 45
Smith 33
Chris 62
输出样例：
22 Amy
作者: 陈越
单位: 浙江大学
时间限制: 400 ms
内存限制: 64 MB
代码长度限制: 16 KB
编译器 (31)
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
struct st{因为要知道那个人的名字要用到结构
char str[10];
int t;
}a[10001];///我也不知道为什么用a[1005]都显示断错误
int main()
{
int i,j,n,k,t,sum=0;
scanf("%d",&amp;n);
for(i=0;i&lt;n;i++)
{
scanf("%s%d",a[i].str,&amp;a[i].t);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fbe4c8f6e8b48a720ff91bfc8584e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b962f43ca69ef49fdabd2639e5ead9fd/" rel="bookmark">
			几何畸变
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几何畸变（geometric distortion）：指遥感成像过程中，受多种因素的综合影响，原始图像上地物的几何位置、形状、大小、尺寸、方位等特征与其对应的地面地物的特征往往是不一致的，这种不一致就是几何变形，也称几何畸变。
百科定义：图像中的几何图形与该物体在选定投影中几何图形的差异，或与地面实况的差异。几何畸变主要是由于遥感器姿态角的变化，物镜系统的光学畸变，扫描速度不稳定，地球自转，地面曲率、地形起伏等引起的。
镜头畸变：透镜由于制造精度以及组装工艺的偏差会引入畸变，导致原始图像的失真。镜头的畸变分为径向畸变和切向畸变两类。
图像插值是在基于模型框架下，从低分辨率图像生成高分辨率图像的过程，用以恢复图像中所丢失的信息。图象插值方法有：最近邻插值，双线性插值，双平方插值，双立方插值以及其他高阶方法。
插值
图像内插值：其主要应用是对图像进行放大以及旋转等操作，是根据一幅较低分辨率图像再生出另一幅均具有较高分辨率的图像，是图像内插值。
图像间的插值，也叫图像的超分辨率重建，是指在一图像序列之间再生出若干幅新的图像，可应用于医学图像序列切片和视频序列之间的插值图像内插值实际上是对单帧图像的图像重建过程，这就意味着生成原始图像中没有的数据。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/483/">«</a>
	<span class="pagination__item pagination__item--current">484/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/485/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>