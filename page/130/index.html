<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cce4785775923b37da5430e2c2cf096/" rel="bookmark">
			react实现导航栏随着内容滚动进行切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面展示关键代码
const navigationBarData = [ { key: "1", name: "首页" }, { key: "2", name: "知识库" }, { key: "3", name: "知识问答" }, { key: "4", name: "专家库" }, { key: "5", name: "排行榜" }, ]; //定义导航栏 onScroll={() =&gt; { //滚动监听 navigationBarData.map((item) =&gt; { //遍历每个导航栏对应的内容 const mark = "#layout" + item.key; const scrollTop = document.getElementsByClassName("knowledgePortal")[0].scrollTop; const dom = $(mark); const offsetTop = dom.offset().top; const outerHeight = dom.outerHeight(); if ( offsetTop - scrollTop &lt;= 0 &amp;&amp; offsetTop + outerHeight - scrollTop &gt; 0 ) { //判断当前导航栏是否处于页面视口中，是的话就将此导航加上选中样式 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cce4785775923b37da5430e2c2cf096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/400b1ce4f4911bfffec5930449d5406c/" rel="bookmark">
			OpenEuler安装Kubernetes&#43;KubeSphere教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos也适用
目录
一、环境准备
1、主机准备
2、关闭selinux、防火墙等
3、关闭swap分区
二、安装docker
1、配置yum源
1、1配置docker源
2、安装依赖包
3、安装docker
二、安装kubernets
1、配置国内源
2、内核配置
2.1、配置IPVS（可选）
3、安装相应版本
4、初始化Master
4、1master部署calico网络
5、master重置*
6、将work node加入
四、安装KubeSphere
1、前置工作
搭建NFS作为默认存储驱动（sc）
创建存储类和provisioner
安装metrics-server
2、部署KubeSphere
获取文件
安装
安装进度检查
登录
一、环境准备 1、主机准备 三台虚拟机并配置好主机名及映射（本次实验主机为虚拟机openEuler22.03 SP1）
2、关闭selinux、防火墙等 # 三台都要操作 # 临时关闭，可用getenforce查看是否关闭 setenforce 0 # 通过配置文件关闭 sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config #关闭防火墙 sudo systemctl stop firewalld sudo systemctl disable firewalld 直接root执行如下吧 iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X 3、关闭swap分区 #三台都要操作 swapoff -a sed -ri 's/(.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/400b1ce4f4911bfffec5930449d5406c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/872e153cc723c8634ba43422001f0597/" rel="bookmark">
			前端实现 生成条形码并调用打印机打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文档使用开发语言vue3+vite+setup语法糖
实现功能，批量选择数据--&gt;生成条形码---&gt;调用打印机--&gt;打印输出
一、生成条形码： 1.安装所需要插件 npm i jsbarcode 2. 引入 import JsBarcode from 'jsbarcode' 3. 使用 // html 部分 &lt;svg ref="barcodeRef"&gt;&lt;/svg&gt; // js部分 import{ref, onMounted} from 'vue' import JsBarcode from 'jsbarcode' const barcodeRef=ref(null) const text = '123456789' const options= { // format: 'EAN13', // 格式 height: 50, // text: "覆盖显示的文本", fontSize: 16, // background: '#ccc', lineColor: 'black' } JsBarcode(barcodeRef.value, text , options) 具体相关条形码配置options，请参考jsbarcode - npm
二，调用打印机打印条形码 1.安装所需要插件 npm i vue-print-nb 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/872e153cc723c8634ba43422001f0597/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2031826c8cdc80704460a0a3102663e0/" rel="bookmark">
			2021年国赛高教杯数学建模B题乙醇偶合制备C4烯烃解题全过程文档及程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021年国赛高教杯数学建模 B题 乙醇偶合制备C4烯烃 原题再现 C4 烯烃广泛应用于化工产品及医药的生产，乙醇是生产制备 C4 烯烃的原料。在制备过程中，催化剂组合（即：Co 负载量、Co/SiO2 和 HAP 装料比、乙醇浓度的组合）与温度对 C4 烯烃的选择性和 C4 烯烃收率将产生影响（名词解释见附录)。因此通过对催化剂组合设计，探索乙醇催化偶合制备 C4 烯烃的工艺条件具有非常重要的意义和价值。
某化工实验室针对不同催化剂在不同温度下做了一系列实验，结果如附件 1 和附件 2 所示。请通过数学建模完成下列问题：
(1) 对附件 1 中每种催化剂组合，分别研究乙醇转化率、C4 烯烃的选择性与温度的关系，并对附件 2 中 350 度时给定的催化剂组合在一次实验不同时间的测试结果进行分析。
(2) 探讨不同催化剂组合及温度对乙醇转化率以及 C4 烯烃选择性大小的影响。
(3) 如何选择催化剂组合与温度，使得在相同实验条件下 C4 烯烃收率尽可能高。若使温度低于 350 度，又如何选择催化剂组合与温度，使得 C4 烯烃收率尽可能高。
(4) 如果允许再增加 5 次实验，应如何设计，并给出详细理由。
整体求解过程概述(摘要) 本文主要研究乙醇偶合制备 C4 烯烃时，不同催化剂组合及温度对乙醇转化率和 C4 烯经选择性的影响、C4 烯经收率最高时的催化剂组合与温度最优化的实验设计问题。
针对问题一，分析附件 1 中每种催化剂组合数据规律,分别建立乙醇转化率、C4 烯烃选择性与温度之间的一元二次回归模型。基于最小二乘法,运用 Matlab 中的 polyfit()和 regress()函数对该模型进行求解，得到回归系数，然后通过判别系数 R^2 判断模型是否准确，如果判别系数小于 0.6，则认为该模型不准确，需要进行进一步通过剔除离总体偏差较大的数据与优化方程模型进行模型的优化，进而通过分析所得曲线的变化规律得到结论:在一定范围内随着温度升高，乙醇的转化率与 C4 烯怪的选择性均会增高，但若温度过高，则 C4 烯经的选择性可能会降低；对附件 2 中的数据进行对比分析，并结合化学反应机理得到结论:乙醇转化率随着时间增大逐渐减小，C4 烯烃选择性随时间变化的趋势较为平稳，随着反应时间增加，各产物的选择性都趋于平稳，即化学反应达到平衡状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2031826c8cdc80704460a0a3102663e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a652d9c9ce56e3dbe292d00b77201f4d/" rel="bookmark">
			chatgpt赋能python：Python第三方库下载指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python第三方库下载指南 Python是一种广泛使用的编程语言，因为它是一个免费而开放源代码的语言，而且具有易学易用、可读性强、强大的库和工具等特点。Python的第三方库是Python语言的重要组成部分，可以添加功能和模块，提高代码的可维护性和复用性。本文将介绍Python第三方库的下载方法，以便开发人员可以更轻松地获取其他开发者创建的Python库。
1. 安装pip pip是Python的软件包管理工具，用于从Python Package Index（PyPI）下载和安装Python库。如果你的Python版本为2.7.9或3.4以上，则已经自带pip。否则，需要手动安装pip。
在命令行中输入以下命令以安装pip：
$ curl https://bootstrap.pypa.io/get-pip.py | python 安装完成后，可以使用以下命令来检查pip的版本：
$ pip --version 2. 使用pip下载库 要使用pip下载库，需要知道库的名称。库名称一般是库的名称，但它也可以是指向库项目托管部分的URL。有些库可能只在GitHub等版本控制系统中发现。
下面是一些下载流行库的示例：
下载numpy numpy是数值计算的Python第三方库。在命令行中输入以下命令来下载numpy：
$ pip install numpy 下载pandas pandas 是一个数据处理的Python第三方库。在命令行中输入以下命令来下载pandas：
$ pip install pandas 下载matplotlib matplotlib是一个用于绘图的Python第三方库。在命令行中输入以下命令来下载matplotlib：
$ pip install matplotlib 下载flask Flask 是一个Python的Web框架。在命令行中输入以下命令来下载flask：
$ pip install Flask 3. 使用virtualenv 当开发多个Python项目时，可能需要使用不同的库版本、Python版本或操作系统版本等。Virtualenv是一种Python的虚拟环境管理工具，允许开发人员在同一计算机上创建独立的Python虚拟环境。这意味着可以针对不同项目使用不同的Python版本、库和操作系统。
以下是virtualenv的安装和使用教程：
安装virtualenv 在命令行中输入以下命令来安装virtualenv：
$ pip install virtualenv 创建虚拟环境 在命令行中输入以下命令来为Python项目创建虚拟环境：
$ virtualenv myenv 激活虚拟环境 在命令行中输入以下命令来激活虚拟环境：
$ source myenv/bin/activate 激活虚拟环境后，可以在其中安装所需的库。当不再需要虚拟环境时，可以使用以下命令来停止虚拟环境：
$ deactivate 结论 本文介绍了Python的第三方库的下载方法，包括安装pip、使用pip下载库以及使用virtualenv来管理不同项目的Python环境。虽然本文介绍了一些常见库的下载方法，但是Python的库数量非常庞大，而且在PyPI中每周都有数百个新库发布。因此，如果想将Python作为编程语言进行开发，知道如何下载和使用第三方库是非常重要的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a652d9c9ce56e3dbe292d00b77201f4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd2fafa98f0117144c83664a9f714c7/" rel="bookmark">
			使用DevEco Studio高效开发（ArkTS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍
本篇Codelab主要介绍使用DevEco Studio开发工具，高效开发登录应用的案例。使用开发工具以下功能：
使用DevEco Studio开发工具的预览器适配多设备页面。
使用DevEco Studio开发工具运行和调试代码。
使用DevEco Studio开发工具测试代码。
相关概念 使用预览器查看应用/服务效果：在HarmonyOS应用/服务开发过程中，DevEco Studio为开发者提供了UI界面预览功能，可以查看应用/服务的UI界面效果，方便开发者随时调整代码。
在Phone和Tablet中运行应用/服务：DevEco Studio为开发者提供本地真机运行HarmonyOS应用/服务功能，本地真机的界面渲染和操作体验更加流畅。
使用真机进行调试：DevEco Studio提供了丰富的HarmonyOS应用/服务调试能力，支持JS、ArkTS、C/C++单语言调试和ArkTS/JS+C/C++跨语言调试能力。
HarmonyOS测试框架：DevEco Studio支持应用/服务测试框架，包含HarmonyOS Test、HarmonyOS JUnit、OpenHarmony Test测试能力。
完整示例 gitee源码地址
源码下载
使用DevEcoStudio高效开发（ArkTS）.zip
环境搭建
我们首先需要完成HarmonyOS开发环境搭建，可参照如下步骤进行。
软件要求 DevEco Studio版本：DevEco Studio 3.1 Release及以上版本。HarmonyOS SDK版本：API version 9及以上版本。 硬件要求 设备类型：华为手机或运行在DevEco Studio上的华为手机设备模拟器。HarmonyOS系统：3.1.0 Developer Release及以上版本。 环境搭建 安装DevEco Studio，详情请参考下载和安装软件。设置DevEco Studio开发环境，DevEco Studio开发环境需要依赖于网络环境，需要连接上网络才能确保工具的正常使用，可以根据如下两种情况来配置开发环境： 如果可以直接访问Internet，只需进行下载HarmonyOS SDK操作。如果网络不能直接访问Internet，需要通过代理服务器才可以访问，请参考配置开发环境。开发者可以参考以下链接，完成设备调试的相关配置： 使用真机进行调试使用模拟器进行调试 代码结构解读
本篇Codelab只对核心代码进行讲解，对于完整代码，我们会在源码下载或gitee中提供。
No Preview
├──entry/src/main│ ├──cpp // C++代码区│ │ ├──types // 接口存放目录│ │ │ └──libentry │ │ │ ├──index.d.ts // 接口文件│ │ │ └──oh-package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd2fafa98f0117144c83664a9f714c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ab2fdb1659e45a65ebfc68892a2372/" rel="bookmark">
			Vue处理超过16位数字精度丢失问题（数字最后两位变0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现象： 当我们使用MyBatis-Plus 使用 ASSIGN_ID(雪花算法) 生成的id作为主键时，因为其长度为19位，而前端一般能处理16位，如果不处理的话在前端会造成精度丢失，最后两位会变成00，感觉像是四舍五入后的效果，如下：
1648981853080055810 =&gt; 1648981853080055800 后端处理 @JsonSerialize(using = ToStringSerializer.class) @TableId(type = IdType.ASSIGN_ID) private Long id; 前端处理 前端一般都是用axios进行数据请求，我们通过引入json-bigint来解决：
// 安装依赖 npm install json-bigint // 使用 import JSONBIG from 'json-bigint' axios.defaults.transformResponse = [ function (data) { const json = JSONBIG({ storeAsString: true }) const res = json.parse(data) return res } ] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d093c6de737eef301c521b9600385f95/" rel="bookmark">
			vue项目如何进行查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在进行项目的开发中，我们常常需要通过前端发送请求，后端接受请求对数据库进行查询，并将结果反馈给前端。那么，我们该如何在前端进行查询请求的编写，可以进行怎样的查询呢？我们可以使用 Axios 发送请求到后端 API 接口，根据不同的查询条件进行数据筛选和过滤。下面是我学习到的一些方法。
方法 按类型查询，可以在后端 API 接口中添加一个类型参数，前端发送请求时携带这个参数，后端根据参数进行查询：
axios.get('/api/data', { params: { type: 'food' } }) .then(response =&gt; { console.log(response.data) }) 按 id 查询，可以在后端 API 接口中添加一个 id 参数，前端发送请求时携带这个参数，后端根据参数进行查询：
axios.get('/api/data', { params: { id: 123 } }) .then(response =&gt; { console.log(response.data) }) 按名字查询，可以在后端 API 接口中添加一个 name 参数，前端发送请求时携带这个参数，后端根据参数进行查询：
axios.get('/api/data', { params: { name: 'apple' } }) .then(response =&gt; { console.log(response.data) }) 进行模糊查询，可以在后端 API 接口中添加一个 keyword 参数，前端发送请求时携带这个参数，后端根据参数进行模糊查询：
axios.get('/api/data', { params: { keyword: 'apple' } }) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d093c6de737eef301c521b9600385f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328f64a8e540e2f95fb0704557746d50/" rel="bookmark">
			Eureka注册中心使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eureka注册中心 单机模式 父工程依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;2021.0.1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; 然后创建一个rureka工程
创建主类
加上@EnableEurekaServer注解
配置yml文件
server: port: 8888 eureka: # 开启之前需要修改一下客户端设置（虽然是服务端 client: # 由于我们是作为服务端角色，所以不需要获取服务端，改为false，默认为true fetch-registry: false # 暂时不需要将自己也注册到Eureka register-with-eureka: false # 将eureka服务端指向自己 service-url: defaultZone: http://localhost:8888/eureka 把其他服务注册到rereka
eureka: client: service-url: defaultZone: http://localhost:8888/eureka 现在有了Eureka之后，我们可以直接向其进行查询，得到对应的微服务地址，这里直接将服务名称替换即可
@Service public class BorrowServiceImpl implements BorrowService { @Resource BorrowMapper mapper; @Resource RestTemplate template; @Override public UserBorrowDetail getUserBorrowDetailByUid(int uid) { List&lt;Borrow&gt; borrow = mapper.getBorrowsByUid(uid); //这里不用再写IP，直接写服务名称userservice User user = template.getForObject("http://userservice/user/"+uid, User.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/328f64a8e540e2f95fb0704557746d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c36d80e76f52b56f6b1f031871a3c9d/" rel="bookmark">
			Python输入一个时间值a，它是距离当日午夜的秒值，计算目前的时间，时间按HH：MM：SS格式输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：输入一个时间值a，它是距离当日午夜的秒值，计算目前的时间和距离午夜的时间，时间按HH：MM：SS格式输出
主要目的：计算当前时间，根据当前时间算出距离午夜时间。
代码如下： 实例：输入时间秒值，为距离午夜的时间，计算目前的时间 ，计算距离午夜时间。
学习方向： 1、实例 2、 掌握 python 基本语法 3、 掌握条件语句 4、 浮点的应用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c87772515cd64519832ac99b6e4bf8/" rel="bookmark">
			BUUCTF刷题记录——MISC部分解答（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、签到 直接打开签到就行了
二、 下载得到gif动图，发现动图中一闪而过flag，拖进PS中，打开时间轴，即可发现flag。 即flag{hellohongke}，也可以用Stegsolve软件（需要安装java环境）——Frame Browser——打开图片一帧一帧得到flag
三、二维码 下载过后是一个二维码，我们对这个文件进行分析，将文件拖入Winhex中，可以看到里面含有pk字母，还有一个4number.txt，我们打开虚拟机，进一步确认，binwalk分析文件，里面有一个zip压缩包，需要进行分离 。
分析文件：binwalk filename
分离文件：binwalk -e filename
首先尝试用binwalk分离文件，发现分离失败。
我们使用foremost分离文件，分离出来一个压缩包。
打开压缩包发现需要密码，我们把压缩包拖进winhex中，发现是真加密，通过zip破解工具。
密码为7639
得到CTF{vipw_wnoei}
四、你竟然赶我走 下载完以后发现是一张图片，直接拖进Winhex先查看内容，搜索发现flag
flag{stego_ is_s0_bor1ing}
五、大白 下载完以后发现是一个图片，并且得到提示：看不到图？ 是不是屏幕太小了 直接拖进Winhex先查看内容，
发现红色线框处，宽高不一致，从图片上来看，高度过低，可能存在显示不全。
关于16进制表示的意思大致如下图：举例：
因此我们修改红线框里的宽高后，再保存为图片查看。 可以看到，图片拉长以后显出flag，flag{He1l0_d4_ba1}
六、N种方法解决 下载完以后发现是一个直接拖进Winhex先查看内容，
发现是一个base64加密的图片，拖进工具中进行转化（或者这串代码拖入到浏览器地址栏里回车）， 得到一个二维码图案，在使用扫描工具对二维码进行扫描得到Flag。
KEY{dca57f966e4e4e31fd5b15417da63269} 七、乌镇峰会种图 下载完以后发现是一个图片，直接拖入WinHex。在里面直接搜索flag字段，发现图片尾部有flag，完成。
flag{97314e7864a8f62627b26f3f998c37f1}
八、基础破解 题目提示：给你一个压缩包，你并不能获得什么，因为他是四位数字加密的哈哈哈哈哈哈哈。。。不对= =我说了什么了不得的东西。。。
下载后得到一个压缩文件，解压发现无法解压。
由题目可知，该密码为4位数，直接拖入ARchpr中暴力破解
得到密码为2563，解压得到一个flag.txt
打开后是一段base64加密文字 ，直接打开HackBar解密。
flag{70354300a5100ba78068805661b93a5c} 九、wireshark 下载后是一个流量包，用wireshark打开，直接找到user登录信息，追踪流，即可得到flag
flag{ffb7567a1d4f4abdffdb54e022f8facd}
十、文件中的秘密 下载后发现是一个图片，老样子，直接拖入WinHex后，直接发现flag，flag的字符串每个中间是空一格的，所以直接搜索flag找不到，直接肉眼下拉查看。
或者，直接点击图片右键，查看图片属性
flag{870c5a72806115cb5439345d8b014396} 十一、LSB 下载后是一个图，将图拖进WinHex中没有发现什么有效线索，在看题目，根据题目LSB，我们可以判断是LSB 隐写术，即最低有效位（Least Significant Bit）隐写术。是一种比较简单的基于二进制的隐写方式，能将一个完整的文件隐藏进另一张图片中。图像一般都是以RGB三原色的方式存储的，存储后R（红）、G（绿）、B（蓝）三组数据按顺序规律排列，每个的取值范围为0~255，范围对应的二进制值就是00000000-11111111，LSB就是把一个文件的二进制每一位拆分修改到图片的色彩数据的二进制值最低位。
此时我们需要用到Stegsolve.jar软件，该软件需要配置java环境。
使用该软件打开后，点击左右箭头，发现在每一个red，green，blue数字为0的通道的时候，图片上方出现一行模糊的背景：
选择Analyse——Data Extract：
勾选row，是应为首先让他按照“行”进行提取，个人理解是因为出现的是一行模糊图案，Bit order按照字节排序的话，MSB和LSB的区别就是：
1、LSB，英文 least significant bit，中文义最低有效位。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c87772515cd64519832ac99b6e4bf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc25dd0a7a3316bc0dfd99e3206a8b2/" rel="bookmark">
			吴恩达深度学习学习笔记——C3W2——机器学习策略2——练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20230608 updated: C3W2 Quiz - Autonomous driving (case study) Ans: B
Note: As discussed in lecture, applied ML is a highly iterative process. If you train a basic model and carry out error analysis (see what mistakes it makes) it will help point you in more promising directions.
Ans: False
Note: Softmax would be a good choice if one and only one of the possibilities (stop sign, speed bump, pedestrian crossing, green light and red light) was present in each image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc25dd0a7a3316bc0dfd99e3206a8b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e76c51c698120523912701458c1b462/" rel="bookmark">
			记录一下解决MySQL储存emoji表情失败的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
发现问题 最近在开发一款微信小程序，今天收到有位用户反馈，说在授权微信登录时候保存带有emoji表情的昵称失败
怎么能让用户有不好的体验！！！
于是乎立马进行测试，好吧，果然发现在数据入库的过程中出现了错误：SQLSTATE[HY000]: General error: 1366 Incorrect string value: ‘\xF0\x9F\x98\x92’ for column ‘nickname’ at row 1
分析问题 不难看出emoji表情**‘\xF0\x9F\x98\x92’**占了4个字节，所以我们在储存的时候需要单独处理，大致思路有两种，第一种就是在原有utf8基础上在写入数据前用base64_encode()来编码，取出数据的时候再用base64_decode()来解码；第二种就是更改字段的字符集来兼容4字节的emoji表情
解决问题 最终问题完美结果，废话不多说，咱们直接上步骤，总共两步搞定🤣
1.修改需要可能会储存emoji表情的字段的字符集为utf8mb4_general_ci 2.修改my.ini文件配置 找到MySQL数据库配置文件，也就是my.ini，修改如下字段（没有就新增）
[mysql] default-character-set = utf8mb4 [client] default-character-set = utf8mb4 [mysqld] character-set-client-handshake = FALSE character-set-server = utf8mb4 collation-server = utf8mb4_unicode_ci init_connect = 'SET NAMES utf8mb4' 添加上面配置项后必须重启MySQL服务，然后大功告成
PS：MySQL的版本一定要大于5.5.3才能用上面方法存表情，太老的版本不支持！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6145a51857228dafd3af0d8f2f8bad88/" rel="bookmark">
			mybatis批量操作（批量查询，批量插入，批量更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mybatis批量操作（批量查询，批量插入，批量更新） 在开发过程中操作大数据量时，连续的循环单个sql操作会导致数据库连接数剧增，整体执行效率也会变的比较低，因此需要使用批量操作，减少连接数，效率更快。
批量查询的方法： 注：如果是简单的批量查询entity，mybatis-plus中有封装好的方法，可以直接使用
复杂一点的：
xxxDao.java
List&lt;ArticleAccumulatedIncomeDTO&gt; batchAccumulatedIncome(List&lt;Long&gt; ids); xxxDao.xml
&lt;select id="batchAccumulatedIncome" resultMap="ArticleSumIncome"&gt; select article_id,sum(income) as accumulated_income from wallet &lt;where&gt; article_id in ( &lt;foreach collection="list" item="id" index="index" separator=","&gt; #{id} &lt;/foreach&gt; ) &lt;/where&gt; group by article_id &lt;/select&gt; 批量插入的方法： xxxDao.java
int addResource(List&lt;Resource&gt; ResourceList); xxxDao.xml
&lt;insert id="addResource" parameterType="java.util.List"&gt; insert into resource (object_id, res_id, res_detail_value, res_detail_name) values &lt;foreach collection="list" item=" ResourceList " index="index" separator=","&gt; ( #{ResourceList.objectId,jdbcType=VARCHAR}, #{ResourceList.resId,jdbcType=VARCHAR}, #{ResourceList.resDetailValue,jdbcType=VARCHAR}, #{ResourceList.resDetailName,jdbcType=VARCHAR} ) &lt;/foreach&gt; &lt;/insert&gt; 批量更新的方法： 方法一：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6145a51857228dafd3af0d8f2f8bad88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/560e4b29d00c7ad318b40f81d0d223cf/" rel="bookmark">
			实验四、shell编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的 1.了解shell的特点和主要种类。
2.掌握 shel1 脚本的建立和执行方式。
3.掌握bash的基本语法。
4.学会编写shell 脚本。
二、实验内容 shell 脚本的建立和执行。历史命令和别名定义。shell变量和位置参数、环境变量。bash的特殊字符。一般控制结构。算术运算及bash 函数。 三、主要实验步骤 利用 vi建立一个脚本文件，其中包括 date、cal、pwd、 ls等常用命令;然后以不同方式执行该脚本。
创建脚本文件： 以不同的方式执行脚本：
输入定向到shell脚本
shell从example中读取命令行，并执行他们。当shell到达文件末尾时，终止执行，并把控制返回到shell命令状态
以脚本名作为bash参数
执行过程与第一种方式相同，但这一种方式能在脚本名后面带参数，从而将参数值传递给程序中的命令，使一个shell脚本可以处理多种情况，就如同函数的调用，可以根据问题给定相应的实参
将shell脚本的权限设置为可执行，然后在提示符下直接执行
首先将文本编辑器建立的shell脚本设置为有执行权限
然后将该脚本所在的目录添加到命令搜索路径（PATH）中
然后就可以在提示符后输入脚本名example就可以直接执行该文件
运行history命令,配置历史命令环境。
显示历史命令清单：
配置历史命令环境：
通过重新为环境变量HISTFILE赋值来改变存放历史命令的文件
利用HISTSIZE变量重新设定历史文件中能够保留的命令的个数限定
体会 bash的命令补齐功能。
在命令行上输入部分目录名称或文件名并按下Tap键后，可能出现下述情况：
若系统可以唯一确定是哪个目录或文件，则自动补全相应的名称。按Enter键执行该命令若Linux找到了不止一个文件名，则会把文件名补全到这些文件名中相同的部分的最后一个字符若shell根据已输入的字符不能唯一确定相应的名称，则会尽量补齐后面的字符，然后响铃提示，要求用户进一步输入名字中后面的字符 如果输入过程中不知道后面的字符，系统也无法唯一确定名称，则可以先按Esc键，然后按？键，或者连续按两次Tab键，shell会列出当前目录下所有可以匹配已输入字符的文件或者给出可以匹配已输入字符的命令
用alias定义别名, 然后执行。
定义别名：
定义变量my并赋值，然后执行 对习题4.8中的shell 脚本进行编辑,然后执行。
新建脚本example2，并输入如下内容，然后保存退出
然后执行该脚本
由此可见该脚本的功能是换行
按习题4.14要求编写脚本,然后执行。
求斐波那契数列的前10项及总和
按习题4.18要求编写脚本,然后执行。
设计一个程序cuts，由标准输入读取数据，获取由第一个参数n和第二个参数m所限定范围的数据，n和m都是整数，即从输入的字符串中抽取第n个字符至第m个字符之间的所有字符（包含这两个字符）
运行例 4.20的程序。若取消其中的“eval",则会出现什么情况?
取消其中的eval后：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d60e5971104a4f846a6dd927d3290ad/" rel="bookmark">
			Ubuntu20.04安装cppAD和Ipopt（肯定好使，不信看结尾我的B站视频）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 安装ipopt安装必要工具安装依赖ASLBLAS and LAPACKHSLMUMPS Linear Solveripopt 安装CppAD问题 由于最近研究非线性模型预测控制(NMPC)需要用到非线性求解器和自动微分的库，安装过程也是有些坎坷，因此记录一下，也希望和我有一样目的的能少踩一点坑。 安装ipopt 最简单的方法是直接用apt命令行安装，
sudo apt install coinor-libipopt-dev 但是这种方式安装的ipopt版本很低，而且可能会报一些错。如果对版本有要求的话就别用这种方法，比如运行Udacity的mpc代码的话就需要3.12版本以上，这个时候就需要通过源码安装。
源码安装可以参考官网安装教程，优秀的工程师是不能害怕英文的。
安装必要工具 sudo apt install gcc g++ gfortran git patch wget pkg-config liblapack-dev libmetis-dev 安装依赖 Ipopt使用了一些不包括在源码的额外的包，例如ASL,Blas,Lapack等。ipopt还需要至少一个线性求解器用于系数对称不定矩阵，通常大部分的求解时间都花费在了求解线性系统，所以线性求解器的选择会影响ipopt的速度和鲁棒性。
因为即将下载好几个库的源码，为了方便管理，可以建立一个文件夹专门存放ipopt和一些依赖库的源码。
例如mkdir ipopt_libs cd ipopt_libs,以后的源码都克隆到这个文件夹下。
ASL 我看很多博客都安装了这个库，我当时也安了，但是我现在发现官网说使用C++指定优化问题是不需要安装的，但是安装也很简单，大家可以试试不安好不好使，我也把安装指令放在下面，
git clone https://github.com/coin-or-tools/ThirdParty-ASL.git cd ThirdParty-ASL ./get.ASL ./configure make sudo make install BLAS and LAPACK ipopt的build系统会自己找到安装在你系统里的BLAS和LAPACK，这俩库已经在安装必要工具时安装过了，就是那个liblapack-dev.
HSL HSL有两个版本，第一个版本Coin-HSL Archive是免费的，这个版本包括MA27,MA28和MC19；第二个版本Coin-HSL Full可以免费用于学术，可以通过学校邮箱申请，这个版本包括更多现代化的代码，包含第一个版本，除此之外还包括MA57等。第二版比第一个版本快,官网说MA57在一些问题上比求解MA27快多了，但是我用第一版也够了，我也申请了一个第二版，成功了，我打算换一下。
这个库需要去官网申请下载，有其他博客提供了免费版的，下载他那个就不用申请了，但是想用学术这个还得自己申请，成功的话会收到一个邮件包含下载链接。
安装指令如下：
git clone https://github.com/coin-or-tools/ThirdParty-HSL.git cd ThirdParty-HSL 然后把下载的hsl库压缩包解压，重命名包日期去掉，放到ThirdParty-HSL目录下，变成这样ThirdParty-HSL/coinhsl ./configure make sudo make install MUMPS Linear Solver 其实我现在不知道这个安不安有没有影响，我看这个也是线性求解器，上边那个MA27也是线性求解器，我看其他博客有的安了，有的没安也好使，安不安随大家吧，可以先不安试试，安装也很简单，命令如下，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d60e5971104a4f846a6dd927d3290ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a68e0b75bf6212efe998ea7accf32823/" rel="bookmark">
			Android---CTS失败项解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改tips：
1、查看CTS测试代码中使用hasSystemFeature判断是否有系统feature，如果没有return（不进行后面的测试）如果刚好设备没有这个feature，可以把这个feature移除掉，这样CTS就不会对这个feature进行测试，即可pass。
2、CTS测试开始会安装相应的进程包，测试结束就会卸载这个包。可以通过接收广播来进行相应的操作。代码如下：
String currentPackage = intent.getData().getSchemeSpecificPart();//被安装/卸载的包名 switch (action) { case Intent.ACTION_PACKAGE_ADDED: if ("".equals(currentPackage)) { //判断CTS正在运行的时候，做相应的处理 } break; case Intent.ACTION_PACKAGE_REMOVED: if ("".equals(currentPackage)) { //判断CTS结束的时候，做相应的处理 } break; default: break; } 1、CtsThemeHostTestCases
在PackageManagerService.java中
@SuppressWarnings("resource") @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) { ....... synchronized (mAvailableFeatures) { for (FeatureInfo feat : mAvailableFeatures.values()) { if (checkin) { pw.print("feat,"); pw.print(feat.name); pw.print(","); pw.println(feat.version); } else { pw.print(" "); pw.print(feat.name); if (feat.version &gt; 0) { pw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a68e0b75bf6212efe998ea7accf32823/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c07e453cad99b8eacc38b2dec2e15f6/" rel="bookmark">
			数据结构课设日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 问题分析和任务定义 1.1 问题描述和要求
本次课程设计要求协助中国大学生计算机设计大赛江苏省组委会，设计一款赛事管理系统，实现赛务相关的数据管理及信息服务，该系统能够为省级赛事管理解决以下问题：
（1）从team.txt中读取参赛队伍的基本信息，能够管理各参赛队的基本信息（包含参赛队编号，参赛作品名称，参赛学校，赛事类别，参赛者，指导老师），赛事类别共11项（参见大赛官网jsjds.blcu.edu.cn）；包括增加、删除、修改参赛队伍的信息。
（2）实现基于二叉排序树的查找。根据提示输入参赛队编号，若查找成功，输出该赛事类别对应的基本信息（参赛作品名称、参赛学校、赛事类别、参赛者和指导老师信息），同时，输出查找成功时的平均查找长度ASL；否则，输出“查找失败！”。请输出ASL(成功)的计算公式和结果值。
（3）能够提供按参赛学校查询参赛团队，根据提示输入参赛学校名称，若查找成功，输出该学校参赛的所有团队的基本信息，输出的参赛团队需有序输出（按参赛队编号）。（排序算法可从选择排序、插入排序、希尔排序、归并排序、堆排序中任意选择，并为选择算法的原因做出说明。）
（4）为省赛现场设计一个决赛叫号系统。所有参赛队按赛事组织文件中的赛事类别分到9个决赛室，决赛室按顺序叫号，被叫号参赛队进场，比赛结束后，下一参赛队才能进赛场。请模拟决赛叫号系统，演示省赛现场各决赛室的参赛队进场情况。（模拟时，各参赛队进场比赛时间可设为0.5秒）
（5）赛事系统为参赛者提供赛地的校园导游程序。为参赛者提供各种路径导航的查询服务。以我校长山校区提供比赛场地为例，（请为参赛者提供不少于10个目标地的导航。可为参赛者提供校园地图中任意目标地（建筑物）相关信息的查询；提供图中任意目标地（建筑物）的问路查询，即查询任意两个目的地（建筑物）之间的一条最短的简单路径。
【设计要求】
1）赛事数据要求存入文件（txt或excel）并能读入查询；
2）赛地目的地查询，需提供目的地（建筑物）名称、代号、简介等信息；最短路径的输出需包含途经地及最短路径值。
3）输入数据形式和范围：赛事相关数据可从键盘输入，或自文件导入。
4）界面要求：交互设计要合理，每个功能可以设计菜单，用户根据提示，完成相关功能的要求。
1.2 问题分析
1.2.1
读取team.txt中的参赛队伍的基本信息，文件的读取可以使用标准库中的 ifstream 类，读取的信息存入一个vector容器中。ifstream类提供了一系列成员函数来读取和处理文件内容。其中，各个文件中不同的数据项之间均使用#分隔，读取时需要把#号识别为分隔符并且自动省略掉，其中增加、删除、修改参赛队伍的信息需要用到相应的类和vector数组的操作比如迭代器和相关函数等操作
读取操作如下
//添加队伍信息 void add() { string filename = "team.txt"; // 需要读取的文件名 ifstream fin(filename); // 创建文件读取器 // 如果打开文件失败，输出错误信息并退出程序 if (!fin.is_open()) { cerr &lt;&lt; "文件打开失败： " &lt;&lt; filename &lt;&lt; endl; exit(1); } // 使用 getline 函数逐行读取文件内容 string line; while (getline(fin, line)) { // 将每一行中的 # 作为分隔符，存储到 vector 中对应的数据结构中 size_t pos1 = line.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c07e453cad99b8eacc38b2dec2e15f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a56a70480491b9dd96d3a334c6c7dfb/" rel="bookmark">
			Python的NumPy库基础用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、基础概念 NumPy是Python中用来进行数值计算和数据分析的一个基础库，它提供了许多高效的数组操作函数，支持不同维度的数组和矩阵运算。下面来详细介绍一下NumPy的用法。
二、安装与导入模块 因为该库不是Python的标准库，所以我们需要在命令行（cmd）执行以下命令来安装该库：
pip3 install numpy
之后我们进入python编译器或者vscode、pycharm等软件导入该库：
import numpy as np
三、创建NumPy数组 1、 一维数组（一组数据） import numpy as np a = np.array([1,2,3]) print(a) 运行结果是：
2、 多维数组（多个一组数据组合起来的数组） import numpy as np a = np.array([[1,2,3],[4,5,6],[7,8,9]]) print(a) 运行结果是：
四、数组属性的获取 数组有很多属性值，包括数组的形状、数据类型、大小、维度和元素数等。通过以下属性可以获取数组的信息。
以下代码中将列出四种常用属性获取方法：
import numpy as np a = np.array([[1,2,3],[4,5,6],[7,8,9]]) # 获取数组的形状 print(a.shape) # 获取数组的数据类型 print(a.dtype) # 获取数组的大小 print(a.size) # 获取数组的维数 print(a.ndim) 我们看结果：
五、数组的修改和访问 可以用索引和切片来修改和访问数组的元素。
1、访问 我们用索引的方式来访问数组中的 ' 1 '：
import numpy as np a = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a56a70480491b9dd96d3a334c6c7dfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ad6e7e414bb1d9e55c0e0e9396705f9/" rel="bookmark">
			你听说过 FileReader 吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FileReader 概念 FileReader 是 Java 中用于读取字符流的类。它继承自 InputStreamReader 类，可以从文件中读取字符数据并将其转换为 Java 字符串。
FileReader 的使用方法 使用 FileReader 读取文件需要以下步骤：
创建 FileReader 对象，指定要读取的文件路径。创建一个字符数组，用于存储从文件中读取的字符数据。使用 read(char[] cbuf) 方法将数据读入字符数组中。关闭 FileReader 对象。 以下是一个简单的 FileReader 示例代码：
import java.io.FileReader; import java.io.IOException; public class FileReaderExample { public static void main(String[] args) { try { FileReader reader = new FileReader("example.txt"); char[] buffer = new char[1024]; int length = reader.read(buffer); System.out.println(new String(buffer, 0, length)); reader.close(); } catch (IOException e) { e.printStackTrace(); } } } 上述代码中，我们创建了一个 FileReader 对象，并指定要读取的文件路径为 “example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ad6e7e414bb1d9e55c0e0e9396705f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac224f659f8e48cb62f4355258d59e21/" rel="bookmark">
			IDEA中的建造者模式代码生成插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件名称：Builder Generator
作用：帮助生成建造者模式的代码
用法如下：
Mac 电脑按快捷键 Command + N 弹出如下弹窗
选 Builder 后弹出如下弹窗
配置项不多，自己试试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b81890a6b7e87424bfcfb0dbb68db770/" rel="bookmark">
			C# 如何提取字符串中的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一、使用正则表达式 1、纯数字提取
1 string str = "提取123abc提取"; //我们抓取当前字符当中的123 2 string result = System.Text.RegularExpressions.Regex.Replace(str, @"[^0-9]+", ""); 3 Console.WriteLine("使用正则表达式提取数字"); 4 Console.WriteLine(result); 2、带有小数点数字提取
1 string str = "提取123.11abc提取"; //我们抓取当前字符当中的123.11 2 str=Regex.Replace(str, @"[^\d.\d]", ""); 3 // 如果是数字，则转换为decimal类型 4 if (Regex.IsMatch(str, @"^[+-]?\d*[.]?\d*$")) 5 { 6 decimal result = decimal.Parse(str); 7 Console.WriteLine("使用正则表达式提取数字"); 8 Console.WriteLine(result); 9 } 3、提取大于等于0，小于等于1的数字 Regex.IsMatch(str, @"^([01](\.0+)?|0\.[0-9]+)$") 方法二、使用ASCII码 1 string str = "提取123abc提取"; //我们抓取当前字符当中的123 2 foreach (char c in str) 3 { 4 if (Convert.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b81890a6b7e87424bfcfb0dbb68db770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f4ced8bdcd76031b16adff554f25d75/" rel="bookmark">
			代码随想录算法训练营第十五天| 层序遍历 、 226.翻转二叉树 、 101. 对称二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		102. 二叉树的层序遍历
题目： 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
示例 1：
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
示例 2：
输入：root = [1]
输出：[[1]]
示例 3：
输入：root = []
输出：[]
思路： 层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。
而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。
代码： class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if(root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while(!que.empty()){ int size = que.size(); // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 vector&lt;int&gt; vec; for(int i = 0; i &lt; size; i++){ TreeNode* node = que.front(); que.pop(); vec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f4ced8bdcd76031b16adff554f25d75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030073fe65d5b89d6fa1525af62c62cc/" rel="bookmark">
			根据接口的返回url下载文件到本地 单选与多选下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function handleDownload(row) { doDownload(row.ddtid); } // 多项下载 function multiDownload() { let resultArr = downloadArr.value.filter((item) =&gt; item.status == "已完成"); let ids = resultArr.map((item) =&gt; item.ddtid).join(","); doDownload(ids); } // 下载文件 function doDownload(ids) { downloadAbility(ids).then((res) =&gt; { res.data.map(function (v, i) { let elemIF = document.createElement("iframe"); elemIF.src = v.url; elemIF.style.display = "none"; let index = v.url.lastIndexOf("/"); let name = v.url.substring(index + 1, elemIF.src.length); download(v.url, {}, name, { Authorization: "Bearer" + getToken() }); setTimeout(() =&gt; { elemIF.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030073fe65d5b89d6fa1525af62c62cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb35e030518feb76a403bb3104d925f5/" rel="bookmark">
			js/vue【分钟转时分 】【2023-05-26转成2023年05月26日 年月日形式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常规js写法
minTime(min) { let minTime = ""; let h = Math.floor(min / 60); min -= h * 60; if (min == 0) { minTime = h ? "0" + h + ":00" : ""; } else { if (min &lt; 10) { min = "0" + min; } if (h &lt; 10) { h = "0" + h; } minTime = (h ? h + "时" : "") + (min ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb35e030518feb76a403bb3104d925f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec8354242050c835057b447d7bb64942/" rel="bookmark">
			流程图在线设计器集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持flowable, activit, camunda 的bpmn文件在线设计
BPMN Modeler
http://www.bpmnmodeler.com/
Flowable的http://www.bpmnmodeler.com/flowable/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b1216c88d7edbfdd287281e31eec2e/" rel="bookmark">
			Linux命令(30)之ps
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux命令之ps 1.ps介绍 linux命令ps是用来查看系统进程的命令。类似与Windows任务管理器中查看到的进程的功能。
2.ps用法 ps [参数]
ps常用参数 参数说明-A显示所有的进程数据-a显示跟当前终端关联的所有进程-u基于用户的格式显示-x显示所有进程，不以终端机来区分-e显示所有进程-f显示完整格式输出-l显示终端进程信息-j工作格式-p &lt;pid&gt;显示指定进程的信息-o根据进程状态进行过滤 3.实例 3.1ps -ef |head -n 5 “ps -ef |head -n 5”输出解释 UIDPIDPPIDCSTIMETTYTIMECMD启动进程的用户ID进程的ID进程的父进程ID进程中生命周期中的CPU利用率进程启动时的系统时间 在哪个终端上运行
-? 指与终端无关
tty1 指运行在tty1终端上，E.g:tty1-tty6
运行进程一共累计占用的CPU时间启动的程序名称 3.2 ps -aux |head -n 5 "ps -aux |head -n 5"输出解释 USERPID%CPU%MEMVSZRSSTTYSTATSTARTTIMECOMMAND启动进程的用户进程的ID进程占用CPU的百分比进程占用内存的百分比进程占用虚拟内存的大小；等价于VIRT (top命令输出)进程占用物理内存的大小; 等价于RES (top命令输出) 在哪个终端上运行
-? 指与终端无关
tty1 指运行在tty1终端上，E.g:tty1-tty6
进程的状态该进程被触发启动的时间该进程实际使用CPU运作的时间该进程的实际指令 STAT指进程的状态，包括：
R：正在运行中
S：静止状态
T：暂定执行
D：无法中断的休眠状态 (通常 IO 的进程)
Z：僵尸进程
STAT进程状态后s、&lt;等含义：
&lt;：进程运行在高优先级上
N：表示进程运行在低优先级上
L：表示进程有页面锁定在内存中
s：表示进程是控制进程
l：表示进程是多线程的
+：表示当前进程运行在前台
3.3ps -l |head -n 5 F:程序的flag(标签)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b1216c88d7edbfdd287281e31eec2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5672446a9e7299ec4b2b8c98d6a63490/" rel="bookmark">
			【Java基础】- HttpURLConnection详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Java基础】- HttpURLConnection详解 文章目录 【Java基础】- HttpURLConnection详解一、HttpURLConnection简述二、HttpURLConnection使用步骤三、HttpURLConnection使用的方法设置连接参数方法设置请求头或响应体发送URL请求获取响应相应的信息头用以下方法获取 四、HttpURLConnection使用演示Get方式POST方式 五、HttpURLConnection使用总结 一、HttpURLConnection简述 HttpURLConnection一个抽象类是标准的JAVA接口，该类位于java.net包中，它提供了基本的URL请求，响应等功能。
HttpURLConnection是基于http协议的，支持GET、POST、PUT、DELETE等各种请求方式。如果使用HTTPS协议请求，可以使用它的子类HttpsURLConnection完成更安全的请求操作。
二、HttpURLConnection使用步骤 创建一个URL对象：URL url=new URL(“接口地址”)
调用URL对象的openConnection()来获取HttpURLConnection对象实例；
HttpURLConnection connection= (HttpURLConnection) url.openConnection();
设置HTTP请求使用的方法：GET、POST或其他请求；
connection.setRequestMethod(“GET”);
设置连接超时，读取超时的毫秒数，以及服务器希望得到的一些消息头；
connection.setConnectTimeout(6*1000);
connection.setReadTimeout(6 * 1000);
调用getInputStream()方法获得服务器返回的输入流，然后输入流进行读取了；
InputStream in = connection.getInputStream();
最后调用disconnect()方法将HTTP连接关掉；
connection.disconnect();
三、HttpURLConnection使用的方法 设置连接参数方法 编号方法名说明1setAllowUserInteraction如果为 true，则在允许用户交互（例如弹出一个身份验证对话框）的上下文中对此 URL 进行检查。2setDoInputURL 连接可用于输入和/或输出。如果打算使用 URL 连接进行输入，则将 DoInput 标志设置为 true；如果不打算使用，则设置为 false。默认值为 true。3setDoOutputURL 连接可用于输入和/或输出。如果打算使用 URL 连接进行输出，则将 DoOutput 标志设置为 true；如果不打算使用，则设置为 false。默认值为 false4setIfModifiedSince有些协议支持跳过对象获取，除非该对象在某个特定时间点之后又进行了修改5setUseCaches如果为 true，则只要有条件就允许协议使用缓存。6setDefaultAllowUserInteraction默认值为 “sticky”，它是所有 URLConnection 的其中一种静态状态。此标志适用于下一个及后续创建的所有 URLConnection。7setDefaultUseCaches将此 URLConnection 的 useCaches 字段的值设置为指定的值。 设置请求头或响应体 编号方法说明1setRequestProperty(key,value)设置一般请求属性。如果已存在具有该关键字的属性，则用新值改写其值。注：HTTP 要求所有能够合法拥有多个具有相同键的实例的请求属性，使用以逗号分隔的列表语法，这样可实现将多个属性添加到一个属性中。2addRequestProperty(key,value)添加由键值对指定的一般请求属性。此方法不会改写与相同键关联的现有值 发送URL请求 编号方法说明1getOutputStream建立实际连接之后，就是发送请求，把请求参数传到服务器，这就需要使用outputStream把请求参数传给服务器 获取响应 编号方法说明1getContent检索此 URL 连接的内容；此方法首先通过调用 getContentType 方法确定对象的内容类型；如果这是该应用程序第一次遇到的特定内容类型，则会创建适用于该类型的内容处理程序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5672446a9e7299ec4b2b8c98d6a63490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04dcff87146ec713664a2b2ec31b3d41/" rel="bookmark">
			【二分查找】为什么我的二分查找总写错？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【二分查找】为什么我的二分查找总写错？ 关于二分查找，其思想一般很容易理解，但其代码实现却包含比较多的细节，新手往往写出错误甚至陷入死循环的代码。本篇笔记旨在记录关于二分查找的如下几个方面：
如何准确无误并快速的写出二分查找？二分查找出错或进入死循环的原因分析 1、如何准确无误并快速的写出二分查找？ 问题引入 问题1：给定一个 n个元素有序的（升序）整型数组 nums 和下标范围 low ~ high 和 一个目标值 x ，写一个函数搜索下标范围 low ~ high 的 nums 中第一个 x，如果目标值存在返回下标，否则返回 -1。
- 注：这里的low ~ high 先假定为左闭右开区间[low, high)，之后 问题1 的代码实现以这个区间为前提。如果是左闭右闭区间[low, high]，对应的代码实现需要作出一定的修改。
示例1：
输入: nums = [-1,0,3,5,9,9,12], low=0, high=6, x = 9
输出: 4
解释: 9 出现在 nums 的左闭右开区间 [0,6) 中，从左至右第一个位置的下标为 4
二分查找的基本思想 以下给出二分查找的基本思想：
令左右指针 L = low, R = high若 L &lt; R ，在[L, R)区间执行如下循环进行筛选： 取中间元素 nums[mid] 与目标值 x 比较： 若 nums[mid] &gt;= x ，则说明 所有 nums[mid, R) &gt;= x，排除右半区域。令R=mid，继续执行步骤2;若 nums[mid] &lt; x ，则说明 所有 nums[L, mid+1) &lt; x，排除左半区域。令 L = mid+1，继续执行步骤2; 循环结束，L == R。此时达到筛选目的 nums[low, L) &lt; x &lt;= nums[R, high)。此时只需判断 nums[R] 与目标值x的关系即可。 二分查找代码实现 // 找到升序数组 nums 在左闭右开区间 [low, hihg) 中出现的第一个等于目标值 x 的元素下标，若存在则返回其下标，否则返回 -1 int bioSearch(int nums[], int low, int high, int x) { int L = low, R = high ; // 假设 nums[L-1] = -INF, nums[R] = INF // 循环不变式：nums[low:L) &lt; x &lt;= nums[R:high)，nums[L,R)待筛选 while (L &lt; R) { // 待筛选区间左闭右开[low, high)决定了循环边界为 L &lt; R int mid = L + ((R - L) / 2 ); // 等价于 mid = (L+R)/2 ; if (nums[mid] &gt;= x) R = mid ; // 说明 nums[mid,R)&gt;=x，在[L,mid)区间继续筛选，故令 R = mid else L = mid + 1 ; // 说明 nums[L,mid+1) &lt; x，在[mid+1,R)区间继续筛选，故令 L = mid+1 } // 循环结束 L == R，此时nums[low:L) &lt; x &lt;= nums[R:high) // 根据上面循环不变式可知，nums[R]才可能是第一个等于目标值x的元素，但只知道 nums[R] &gt;= x，是“=”还是“&gt;”需要进一步判断 if (R == high || nums[R] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04dcff87146ec713664a2b2ec31b3d41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3929f2bc26344db50bd9cda1d3ab4a/" rel="bookmark">
			MATLAB 入门（一）绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绘图 绘图颜色选项参数 绘图线形选项参数 数据标记点选项参数 生成幕布 figure
建立一个幕布，相当于一整张白纸，可以将整张纸分成多个区域进行绘图。
新生成的幕布上没有任何东西
在使用绘图函数时会默认调用figure函数生成幕布。
二维绘图 绘制y关于x的图像 plot（x，y）
&gt;&gt; x=0:0.1:100; &gt;&gt; y=exp(cos(x)); &gt;&gt; plot(x,y) 给图像添加标题 title（‘标题’）
&gt;&gt; title('y=exp(cos(x))') 给轴添加标签 xlabel ，轴名称label
&gt;&gt; x=0:pi/50:2*pi; &gt;&gt; plot(x,sin(x)); &gt;&gt; xlabel('x'); &gt;&gt; ylabel('sin(x)'); &gt;&gt; x=0:pi/50:2*pi; plot(x,sin(x)); xlabel('x'); ylabel('sin(x)'); 三维绘图 绘制f（x，y，z）的图像 plot3（x，y，z）
&gt;&gt; x=1:0.01:100; &gt;&gt; plot3(sin(x),cos(x),x) 给图形增加网格线 grid on
给图片增加网格线 对比上图观看
绘制三维平面 生成网格坐标 a=-8:8; b=-8:8; [x,y]=meshgrid(a,b) x =
-8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 -8 -7 -6 -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 y =
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b3929f2bc26344db50bd9cda1d3ab4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9a79ec1708028245d7d1bc13e9deeed/" rel="bookmark">
			PHP 反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 PHP 反序列化漏洞简介无类测试有类测试CTF真题 PHP 反序列化漏洞简介 原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而导致代码
执行，SQL 注入，目录遍历等不可控后果。在反序列化的过程中自动触发了某些魔术方法。当进行
反序列化的时候就有可能会触发对象中的一些魔术方法。
serialize() //将一个对象转换成一个字符串
unserialize() //将字符串还原成一个对象
触发：unserialize 函数的变量可控，文件中存在可利用的类，类中有魔术方法：
参考：https://www.cnblogs.com/20175211lyz/p/11403397.html
__construct() //创建对象时触发
__destruct() //对象被销毁时触发
__call() //在对象上下文中调用不可访问的方法时触发
__callStatic() //在静态上下文中调用不可访问的方法时触发
__get() //用于从不可访问的属性读取数据
__set() //用于将数据写入不可访问的属性
__isset() //在不可访问的属性上调用 isset()或 empty()触发
__unset() //在不可访问的属性上使用 unset()时触发
__invoke() //当脚本尝试将对象调用为函数时触发
无类测试 serialize
unserialize
有类测试 &lt;?php class ABC{ public $test; function __construct(){ $test = 1; echo '调用了构造函数&lt;br&gt;'; } function __destruct(){ echo '调用了析构函数&lt;br&gt;'; } function __wakeup(){ echo '调用了苏醒函数&lt;br&gt;'; } } echo '创建对象a&lt;br&gt;'; $a = new ABC; echo '序列化&lt;br&gt;'; $a_ser=serialize($a); echo '反序列化&lt;br&gt;'; $a_unser=unserialize($a_ser); echo '对象快要死了！&lt;br&gt;'; ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9a79ec1708028245d7d1bc13e9deeed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75ee7a752c6156980112e19f2130f7c9/" rel="bookmark">
			Verilog HDL可综合与不可综合语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、可综合的语法子集1.1 模块声明类1.2 端口声明1.3 parameter1.4 内部信号wire，reg1.5 循环语句for1.6 assign语句1.7 always进程块1.8运算操作符1.9赋值符号=（阻塞）、&lt;=（非阻塞） 二、不可综合的语法子集2.1 所有工具都不支持的结构2.2 有些工具支持有些工具不支持的结构 硬件描述语言（HDL）是用来描述 数字电路和设计 数字逻辑系统的语言。 Verilog HDL是硬件描述语言的一种，用于数字电子系统设计，是目前应用最为广泛的一种硬件语言。 一、可综合的语法子集 可综合的语法是指硬件能够实现的语法，这些语法可以通过综合工具编译最终生成用于烧录到FPGA的配置数据流。
所有综合工具都支持的结构：always，assign，begin，end，case，wire，tri，reg，integer，default，for，function，and，nand，or，nor，xor，xnor，not，if，inout，input，module，negedge，posedge，output，parameter…
1.1 模块声明类 模块的端口声明了模块的输入输出口。例：
module adder(count,sum,a,b,cin); input [2:0] a,b; input cin; output count; output [2:0] sum; assign {count,sum} = a + b + cin; endmodule 1.2 端口声明 每一个module都会有输入和输出信号用于和外部器件或者其它模块通信。这些输入输出端口可以分为三类：input，output，inout（双向）。
1.3 parameter parameter来定义常量。在每一个赋值语句的右边必须是一个常数表达式。也就是说，该表达式只能包含数字或先前已定义过的参数：
parameter msb=7; //定义参数msb为常量7 parameter e=25, f=29; //定义二个常数参数 parameter r=5.7; //声明r为一个实型参数 parameter byte_size=8, byte_msb=byte_size-1; //用常数表达式赋值 parameter average_delay = (r+f)/2; //用常数表达式赋值 参数型常数经常用于定义延迟时间和变量宽度。在模块或实例引用时可通过参数传递改变在被引用模块或实例中已定义的参数，例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75ee7a752c6156980112e19f2130f7c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cc59f8680b64d26588ebb7067387445/" rel="bookmark">
			理解 Vue 中的 MVVM 思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是 Vue Vue 是一套用于构建用户界面的渐进式 JavaScript 框架, 与其他大型框架不同的是, Vue 被设计为可以自底向上逐层应用, Vue 的核心库只关心视图层, 方便与第三方库或既有项目整合.
2. JavaScript 框架了解 jQuery : 大家熟悉的 JavaScript 框架, 优点是简化了 DOM 操作, 缺点是 DOM 操作太频繁, 影响前端性能.Angular : Google 收购的前端框架, 其特点是将后台的 MVC 模式搬到了前端并增加了模块化开发的理念 (对后台程序员友好, 对前端程序员不太友好).React : Facebook 出品, 一款高性能 JS 前端框架; 提出了 虚拟 DOM 的概念, 用于减少真实 DOM 的操作, 在内存中模拟 DOM 操作, 有效的提升了前端渲染效率; 缺点是使用复杂, 因为需要额外学一门 【JSX】语言.Vue : 一款渐进式 JavaScript 框架, 其特点是综合了 Angular (模块化) 和 React (虚拟 DOM) 的优点;Axios : 前端通信框架; 因为 Vue 的边界很明确, 就是为了处理 DOM, 所以并不具备通信能力, 此时就需要使用一个通信框架与服务器交互; 当然也可以直接选择使用 jQuery 提供的 Ajax 通信功能.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cc59f8680b64d26588ebb7067387445/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55351ae72d242973607905bd3a76ddec/" rel="bookmark">
			对话ChatGPT，大模型时代到来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 你觉得大模型时代已经到来了吗？2. 大模型和以前的模型有什么区别？3. 列举一下你知道的大模型有哪些4. ChatGPT与传统的智能助手有什么区别？5. ChatGPT有什么优势和劣势？6. ChatGPT有哪些应用场景，请举例说明？7. 写一首歌， 歌的主题是《大模型时代》 以下回答由基于GPT-3模型的ChatGPT完成 1. 你觉得大模型时代已经到来了吗？ 作为一个由开放人工智能（OpenAI）训练的大型语言模型，我认为大模型时代已经到来了。随着深度学习技术和计算硬件的迅速发展，越来越多的机器学习模型变得更加庞大和复杂。这些大型模型在自然语言处理、图像识别、语音识别、机器翻译和其他任务中表现出色。例如，BERT、GPT-3等超大型语言模型已经成为当前最先进的自然语言处理模型。
虽然大型模型有很多优点，如更高的准确性和更好的泛化能力，但也存在一些缺点，如需要大量的计算资源和时间来训练和推理，以及对数据集的依赖性更强。另外，还有一些人担心大型模型可能会加剧AI的歧视性和不公平性等问题。
总的来说，大型模型已经成为机器学习领域的主流趋势，并且将继续发挥重要作用。
2. 大模型和以前的模型有什么区别？ 大模型和以前的模型有以下几个区别：
神经网络层数更深：大模型通常拥有比以前的模型更深的神经网络。这意味着它们可以处理更复杂的任务，学习更抽象的概念。
参数更多：大模型通常有比以前的模型更多的参数。这意味着它们可以更好地适应训练数据，并对新的样本进行更准确的预测。
训练需要更长时间：由于大模型的规模较大，因此训练通常需要更长的时间。这包括使用更多的计算资源（例如GPU）和更长的训练时间。
优化更困难：由于大模型的规模较大，因此优化变得更加困难。这包括需要更小的学习率、更复杂的正则化技术等。
更高的性能：大模型通常具有比以前的模型更高的性能。这意味着它们可以在更广泛的任务上取得更好的成果，例如图像分类、语音识别和自然语言处理等。
3. 列举一下你知道的大模型有哪些 以下这些是我知道的一些大模型：
GPT-3（Generative Pre-trained Transformer 3）是目前为止最大的自然语言处理模型，由 OpenAI 开发。该模型具有1750亿个参数，采用了深度神经网络和自监督学习来预测下一个单词、生成文本等任务。
BERT（Bidirectional Encoder Representations from Transformers）也是由谷歌开发的自然语言处理模型之一，拥有1.1亿个参数。它使用双向编码器模型设计，可以更好地理解句子中的上下文。
ResNet（Residual Network）是一种图像分类模型，由微软研究院开发。该模型包含数百个卷积层和跨层连接，可以处理高分辨率图像，识别出复杂的物体和场景。
VGG（Visual Geometry Group）是另一种图像分类模型，由牛津大学视觉几何组开发。该模型结构简单，但效果显著，在多个计算机视觉竞赛中都取得了优异的成绩。
AlphaGo 是由 DeepMind 开发的围棋 AI 程序，其深度强化学习算法使用了数百万局围棋的数据进行训练，最终在 2016 年击败了当前世界冠军李世石。
4. ChatGPT与传统的智能助手有什么区别？ ChatGPT与传统的智能助手在几个方面存在差异：
数据驱动：传统的智能助手通常是基于规则和程序编写的，需要开发人员或专家来明确定义问题和答案。而ChatGPT是一种数据驱动模型，它通过从大量文本中学习语言模式和语义知识来理解和回答问题。
自然度：由于数据驱动，ChatGPT表现出更自然、流畅的回答方式，因为它可以使用许多不同的单词和短语来表达同样的意思，并可以根据上下文提供更具体的答案。
通用性：传统的智能助手通常被设计用于特定领域的任务，如语音识别或自然语言处理。相比之下，ChatGPT作为一个通用性的语言模型，可以应用于多种不同的任务和领域，例如聊天机器人、问答系统、自动摘要等。
可扩展性：由于其可训练的特性，ChatGPT具有很高的可扩展性，可以在各种不同的数据集上进行训练，以适应不同的应用场景。
5. ChatGPT有什么优势和劣势？ ChatGPT优势和劣势分别如下：
优势：
自然语言生成: ChatGPT是一种自然语言生成模型，可以生成非常逼真的文本。这意味着它可以用于许多不同的任务，包括对话系统、文章摘要、翻译等等。
预训练模型: ChatGPT是一种预训练模型，使用了巨大的数据集进行了深度学习训练。这使得它能够处理更多的上下文信息，并且在许多任务中表现出强大的性能。
可定制性强: ChatGPT可以通过微调、迁移学习或重新训练来实现特定任务的个性化需求。例如，针对某个特定行业的文本内容进行训练以提高性能。
开源和免费: ChatGPT是开源的，任何人都可以使用和修改代码。同时，由于其在OpenAI平台上公开发布，因此可以免费使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55351ae72d242973607905bd3a76ddec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fcd8f5e4ca99aaed29273ec31e47f0f/" rel="bookmark">
			Linux模块文件如何编译到内核和独立编译成模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 编译成独立模块 假定我们有以下驱动程序,要编译成可以加载到开发板的独立ko文件
hello.c
#include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/kdev_t.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/cdev.h&gt; //#include &lt;io/uaccess.h&gt; #include &lt;linux/device.h&gt; #include &lt;asm/io.h&gt; #include &lt;asm/uaccess.h&gt; static int major = 237; static int minor = 0; static dev_t devno; struct device *class_dev = NULL; struct class *cls; static int hello_open (struct inode *inode, struct file *filep) { printk("hello_open()\n"); return 0; } static int hello_release (struct inode *inode, struct file *filep) { printk("hello_release()\n"); return 0; } #define KMAX_LEN 32 char kbuf[KMAX_LEN+1] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fcd8f5e4ca99aaed29273ec31e47f0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8104caee68da250832e49c359a84e10/" rel="bookmark">
			MySQL增删改查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、增加数据
1.创建学生表
2.增加字段信息。
二.更新字段信息
1.更新字段类型信息
2.更新字段名称
3.更新字段内容
三.查询表数据
1.查看学生的所有信息
2.查询表中所有学生所对应的成绩。
3.查询姓名为酱紫的学生
4.查询成绩大于90分的学生
​编辑
5.查询学生成绩在80-90之间
6.查询学生成绩小于80的。
四.删除表数据
1.删除id为4学生信息
2.删除表中所有信息。
3.删除学生表
总结
一、增加数据 1.创建学生表 CREATE TABLE `student` ( `id` varchar(20) CHARACTER SET gb2312 COLLATE gb2312_chinese_ci NOT NULL, `name` varchar(20) CHARACTER SET gb2312 COLLATE gb2312_chinese_ci DEFAULT NULL, `性别` varchar(20) DEFAULT NULL, `age` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312; 2.增加字段信息。 insert into student(id,name,age) values('1','小酱饼','18'); 查看student表字段信息。
二.更新字段信息 1.更新字段类型信息 alter table 表名 modify 字段 数据类型; alter table student modify id int; 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8104caee68da250832e49c359a84e10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acdac3f1f1b0f7e1d3354496fb3a69cd/" rel="bookmark">
			Linux系统安装redis-cli 7.0.11版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux系统下载redis-cli 7.0.11版本 # 下载redis-cli 7.0.11版本 yum -y update yum -y install http://rpms.remirepo.net/enterprise/remi-release-7.rpm yum --enablerepo=remi install redis rpm -qi redis # 验证安装的版本 redis-cli -v # 连接redis服务 redis-cli -h host -p 6380 --tls -a 密码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e81c5af8730fb49beb8520c36bd3bf/" rel="bookmark">
			博客摘录「 坐标系对应EPSG代号、经度范围、中央经线」2023年6月7日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WGS84、国家2000的WGS84、国家2000的投影坐标系
北京54投影坐标系
西安80投影坐标系
投影坐标系北京54投影坐标系西安80投影坐标系
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29eb7e02777b9f2df65f4f4f7d783932/" rel="bookmark">
			思科小型网络配置实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置思路
1.交换机上配置端口连接描述，在实际工作中很有用
2.外网配置，模拟外网：PC的IP地址200.200.200.2，Server的IP地址是200.200.200.3，网关都是200.200.200.1。SW-ISP的连接PC和Server-ISP的口属于vlan 3,，连接路由器侧接口属于vlan 2，,配置生成树的边缘端口，连接路由器侧的IP地址是20.1.1.1 255.255.255.240。R7-Border地址为20.1.1.2 255.255.255.240
3.内网vlan和子网划分：
Manage：vlan 1，172.16.1.0/24
Shichangbu：vlan 10 172.16.10.0/24 网关172.16.10.254/24
Xingzhengbu：vlan 20，172.16.20.0/24，网关172.16.20.254/24
Caiwubu：vlan 30，172.16.30.0/24，网关172.16.30.254/24
Server：vlan 100，172.16.100.1/24，网关172.16.100.254/24
其中连接用户的接口配置stp的portfast和bpduguard，防止用户通过DHCP拿不到IP地址和用户私接交换机
4.内网转化为公网的地址池
XS：20.1.1.3/28
XZ：20.1.1.4/28
CW：20.1.1.5/28
5.核心交换机和边界路由器之间使用172.16.1.0/24网段
二、配置过程
1.交换机上配置端口连接描述
SW-CORE(config)#int e0/0
SW-CORE(config-if)#description toInternet
SW-CORE(config-if)#int e0/1
SW-CORE(config-if)#description toServer
SW-CORE(config-if)#int e2/0
SW-CORE(config-if)#description toXS1
SW-CORE(config-if)#int e3/0
SW-CORE(config-if)#description toXS2
SW-CORE(config-if)#int e4/0
SW-CORE(config-if)#description toXZ1
SW-CORE(config-if)#int e5/0
SW-CORE(config-if)#description toXZ2
SW-CORE(config-if)#int e6/0
SW-CORE(config-if)#description toCW
SW2-XS1(config)#int e0/0
SW2-XS1(config-if)#description to CORE
SW2-XS1(config-if)#int e0/1
SW2-XS1(config-if)#description to XS2
SW3-XS2(config)#int e0/0
SW3-XS2(config-if)#description to CORE
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29eb7e02777b9f2df65f4f4f7d783932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d67d293037b81a0290e3ae52964b2ab9/" rel="bookmark">
			Unity pc端内嵌网页插件Embedded Browser基本使用流程（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本操作 导入 下载后会得到一个后缀为.unitypackage的文件，这个就是unity的包。现在我们只需要点开unity，然后右键Assets,选择import package即可打开文件，在文件中选择这个包就可以导入了。
等待稍后加载文件，点击import即可成功导入。
使用公网网址 这个时候我们就可以开始初步使用了，这里以导入百度搜索为基础，介绍使用流程。
在新建的场景中的canvas里面建立一个raw image控件。
在该控件中点击Add Component添加插件，输入browser,可以看到，系统已经自动找到了我们导入的插件。
选择GUI Beowser UI后，系统会自动添加两个compoent
其中Browser里面的URl就是我们放网页地址的地方，填入百度搜索的地址。运行unity，可以看到百度已经加载出来了，输入搜索也是可以的。
这里如果不能点击的同学，可以再添加一个compoents
GUI Browser是即将被淘汰的组件，建议使用pointer UI GUI，但是实际上这个插件再2.0版本就这么说，到3.1了依旧没有改。。。
使用本地html网页 如果是要使用网页替代unity UI 那么插入本地网页必不可少，请看详细操作方法：
在unity跟目录下建立BrowserAssets文件夹。注意，名字必须完全一致，如果不一致会导致插件找不到文件
将需要使用的html放入其中即可
回到unity中，将刚才在输入的百度url改为，localGame://mychart.html
点击运行后可以发现我们自定义的html文件就显示了出来。
unity和html的交互 在这个插件里面提供了html和unity互相调用传参的方法。基本操作如下：
html调用unity方法 html调用unity的方法，只需要js调用一个方法，然后在c#里面监听同名函数即可。具体代码如下
html
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;style type="text/css"&gt; * { padding: 0; margin: 0; box-sizing: border-box; } .title { margin: 0; text-align: center; color: aqua; background-color: #162256; padding: 10px 0; height: 60px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d67d293037b81a0290e3ae52964b2ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34af8ced3e192fdb8fa3bef5c2ecaa5c/" rel="bookmark">
			中专学历自学前端找工作?也太真实了。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自我介绍
在没有任何包装的情况下成功收到大概十几家公司的面试邀请。
因为喜欢代码，喜欢编程，而坚持下来的学习。想起五六年前智能手机刚兴起的时候，我就在各种论坛（代表：某葫*侠），各种 Q 群混着跟着搞各种锁机、破解、刷机一系列技术，手机编程、iapp（手机编程软件，这个应该有不少人都知道吧？）、IDEA（一个手机上学习 Java 的软件）。
这个时候的自己虽然很喜欢编程，但真正让我决定学习编程的其实还是 2016 年因为盗版二被迫停更的火影战记（童年回忆了啊），那时就决定自己以后要学编程，然后做出续版。。。不过后来东倒西歪的直到现在学了前端....而不是安卓和 JAVA 开发，哈哈哈哈哈哈哈。
回归正题，说说现在的我的情况：十九岁，学历只有中专，目前在广州天河一个不到十人的小公司。
自学了大概一年左右，u1s1，自学真的非常难受，很难保持自律，也很迷茫，时常会质疑自己学了这么多有什么用？能不能找到工作？更何况我本身还是要给社恐，属于是和人说话就紧张，说话声音就很小，也很不自信的一个人。
当时光是想想要去面试，和以后工作时不得不和同事交流一系列都会感到害怕。（现在入职半个月了，其实还好，同事都非常好，都因为我的年龄很照顾我。真的很感谢他们。）
我平常是怎么学习的？ 嗯...还记得第一次是在某绿色葫芦上的简单的 HTML 入门教程（大概是 2018 年），跟着学了点基础标签后就完完全全迷上了...
现在还记得，这套视频大概十几集，每集也就两三分钟，主题是教如何制作一个“黑页”，其实就是用几个 html 标签和 css 样式做一个看着很酷的纯静态页面，然后放到云主机上，再加上一个免费的二级域名，这样一个自己的网站就出来，就可以拿出去装b了。给同学给或者给网友看，装作是黑客，很傻气，至少现在看来是这样。
在这之后，我去找了当时我在读的中专的老师借了本 html+css 入门书籍进行学习，说是入门，但其实也就是只有个基础，毕竟。。中专嘛懂的都懂。
之后我就花了大概几十块钱，在某东上买了一本学习 html + css + js 的书（依稀记得是 2019 年？），然后...就是对着书摁学，期间也找了一些网上的零散的教程，学习之类的。这个过程我在网上还认识了一个师傅，虽然现在已经不联系了，还是很感谢他对当时的自己的帮助，真的很大。
时间跳到 2020，emmm 又迷上了后端，在网上找了一套黑马的 PHP 教程，学了个大概，能做出一个简易的留言板。
这段时间，还沉迷了黑客，学了些网络安全，了解一系列如：肉鸡、蠕虫、kail 等等东西。还下载了一堆计算机病毒。。。几乎各种有名病毒的都下载了一遍，然后在学校的电脑上测试常见 Web 安全攻击。
TIPS：同样是根据当年的笔记写的文章。
2021，收心，开始只学前端，放弃其它一切技术，开始只钻研前端，其实这个时候的我还只是个菜鸟，虽然很早接触了前端，但其实也只是边学边玩的状态，到了这时也只会点 html 标签和 css 样式，js dom，bom，jq 而已。
也是同年大概这个时候，我。。。选择了辍学，然后回到家自学。
这一年学了很多，真的很多，也才知道自己原来这么菜。
啊呸，跑题了，说说我这一年是咋学习的：视频 + 语雀 + vscode + 浏览器，同事开着四个软件，先是看视频，跟着视频敲，边敲边打注释，以自己的理解来写上注释，就算很多没必要写注释的地方我也强迫着自己去写，以至于到现在养成了一行代码一行注释的习惯（不知是好是坏。。。）。
在跟着视频敲完代码后，我就开始根据自己写的代码和注释整理好写入语雀，记作笔记，也只是只有我自己才能看懂的笔记，随后在学完课程后我又会复盘自己的笔记，然后将其整理为一篇完整的文章。
整理的同时相当于又学了一篇。（在这一步还不算完，我基本会在学习完一个月后再去复盘一篇自己写的文章，并尝试以一种教授别人的形式重写）
基本上就是看视频的时候跟着敲一遍，并在看完后，整理成笔记放到语雀上，过程有什么不懂或 BUG 就上浏览器查。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34af8ced3e192fdb8fa3bef5c2ecaa5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6d5e527e921e1708350b8b44b07b04c/" rel="bookmark">
			Vue.js 中的 watch 属性详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue.js 中的 watch 属性详解 在 Vue.js 中，watch 属性是一种非常重要的属性，它可以监听 Vue 实例中指定的数据变化，并在数据发生变化时执行相应的操作。本文将对 Vue.js 中的 watch 属性进行详细的介绍，并附上相关的代码示例。
什么是 watch 属性？ 在 Vue.js 中，watch 属性被定义为一个对象，它可以用来监听 Vue 实例中的数据变化。当监听的数据发生变化时，watch 属性可以执行指定的回调函数，从而实现对数据变化的响应。
watch 属性的基本语法如下所示：
// 监听一个数据的变化 watch: { targetData: { handler(newVal, oldVal) { // 数据发生变化时执行的操作 }, deep: true, // 是否深度监听 immediate: true, // 是否在组件创建时立即执行回调函数 }, }, 在上述代码中，targetData 表示要监听的数据，handler 表示数据发生变化时执行的回调函数。deep 和 immediate 分别表示是否深度监听和是否在组件创建时立即执行回调函数。
watch 属性的用途 watch 属性的主要用途是监听 Vue 实例中的数据变化，并在数据发生变化时执行相应的操作。例如，在一个购物车组件中，我们可以使用 watch 属性监听购物车中的商品数量变化，并在商品数量变化时重新计算购物车总价。
此外，watch 属性还可以用来监听组件中的数据变化，并进行一些数据验证和数据同步操作。例如，在一个表单组件中，我们可以使用 watch 属性监听用户输入的数据，并在数据发生变化时进行数据验证和数据同步操作，从而增强表单的交互性和可用性。
watch 属性的深度监听 在 Vue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6d5e527e921e1708350b8b44b07b04c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf0cfc1d69eac323721ce51ba2f7658/" rel="bookmark">
			git撤销commit提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、git rebase 1)使用git log命令查看提交历史，找到要删除的记录的哈希值。
2)git rebase -i 命令指定要删除的哈希值。
如git rebase -i abcdefgh # 表示删除该提交
git rebase -i abcdefgh~1 # 表示要删除的提交的前一个提交。
3)git 会打开交互式编辑器。
删除提交需要将pick 改为drop,保存并关闭，git 会自动广播提交。
2、git revert 可以撤销指定提交的更改，并创建一个新提交来保留已撤销的更改历史记录。
1)git log 查看提交记录
2)git revert abcdef 同git rebase 一样，也会打开一个编辑器，会让输入撤销提交的注释，保存后，git 会创建一个新提交，用于撤销要撤销的提交所做的更改。
git revert 命令会保留原提交，新建一个撤销的提交，而git rebase 会直接删除提交。
3、git reset 1) git log查看提交记录
2) git reset --hard 提交哈希值。
会删除所有在该提交上的个性，并将当前分支HEAD指针移动到要删除的提交上。
3)git reset --soft 哈希值。
只删除提交本身而不影响更改。
4）删除提交到远程仓库的分支中，可以使用git push --force将更改强制推送到远程分支。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64688514f5e9fd370c119f5dfe38a171/" rel="bookmark">
			Arrays.asList()：隐藏的陷阱，你避开了吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，我们经常需要将数组转换为List来方便地进行操作。Arrays.asList()方法是一种常见的方式，但是它存在一个不太常见但需要注意的坑。本文将深入探讨Arrays.asList()的使用，揭示其中的陷阱，并提供解决方案。
Arrays.asList()方法介绍 Arrays.asList()方法是将数组转换为List的方法，它返回一个List对象，但这个List对象并不是java.util.ArrayList对象，而是Arrays内部的ArrayList对象。
Arrays.ArrayList类继承自AbstractList，实现了List接口。它重写了add()、remove()等修改List结构的方法，并将它们直接抛出UnsupportedOperationException异常，从而禁止了对List结构的修改。
具体来说，Arrays.asList()方法返回的是Arrays类中的一个私有静态内部类ArrayList，它继承自AbstractList类，实现了List接口。
Arrays.asList()方法的使用非常简单，只需要将一个数组作为参数传递给该方法即可。例如：
String[] arr = new String[]{"a", "b", "c"}; List&lt;String&gt; list = Arrays.asList(arr); Arrays.asList()方法的坑 尽管Arrays.asList()方法很方便，但也存在一些坑，其中最常见的一个是：在使用Arrays.asList()方法时，如果对返回的List对象进行修改（例如增加、删除元素），将会抛出"UnsupportedOperationException"异常。
为什么会出现这个异常呢？这是因为Arrays.asList()方法返回的List对象，是一个固定大小的List，不能进行结构上的修改，否则会抛出异常。
下面的代码演示了这个问题：
String[] arr = new String[]{"a", "b", "c"}; List&lt;String&gt; list = Arrays.asList(arr); list.add("d"); // 抛出 UnsupportedOperationException 异常 上述代码中，我们尝试向List对象中添加一个新的元素"d"，结果会抛出"UnsupportedOperationException"异常。
解决Arrays.asList()方法的坑 要解决Arrays.asList()方法的坑，我们需要将返回的List对象转换为一个可修改的List对象。有几种方法可以实现这个目标：
方法一：使用java.util.ArrayList类 我们可以使用java.util.ArrayList类，将Arrays.asList()方法返回的List对象转换为一个java.util.ArrayList对象，示例如下：
String[] arr = new String[]{"a", "b", "c"}; List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(arr)); list.add("d"); // 正常运行 上述代码中，我们首先使用Arrays.asList()方法将一个数组转换为一个List对象，然后使用ArrayList的构造方法，将这个List对象转换为一个java.util.ArrayList对象，最后可以向这个ArrayList对象中添加元素。
方法二：使用Collections类 我们也可以使用Collections类提供的静态方法，将Arrays.asList()方法返回的List对象转换为一个可修改的List对象，示例如下：
String[] arr = new String[]{"a", "b", "c"}; List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64688514f5e9fd370c119f5dfe38a171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f16e13d3019f104e6b4e8dc32c7a9c15/" rel="bookmark">
			python读取txt文件为列表，并清除里面多余的字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、使用文件对象的read ()方法来读取文件的内容，然后使用字符串对象的splitlines ()方法来按照行分割字符串，并去掉每行末尾的\n。例如：
with open ('filename.txt') as f: lines = f.read ().splitlines () 2、使用文件对象的readlines ()方法来读取文件的每一行，然后使用列表推导或者map函数来对每一行应用字符串对象的rstrip ()方法，去掉每行末尾的空白字符，包括\n。例如：
with open ('filename.txt') as f: lines = [line.rstrip () for line in f] 或者
with open ('filename.txt') as f: lines = list (map (lambda line: line.rstrip (), f)) 两种方法的优缺点：
使用read ()和splitlines ()方法的优点是代码更简洁和直观，而且splitlines ()方法可以处理不同的换行符，比如\n，\r，\r\n等。缺点是read ()方法会一次性读取文件的全部内容，如果文件很大，可能会占用较多的内存空间。使用readlines ()和rstrip ()方法的优点是可以逐行读取文件，节省内存空间，而且rstrip()方法可以指定要去掉的空白字符，比如只去掉\n而保留其他空白字符。缺点是代码稍微复杂一些，而且rstrip()方法可能会去掉一些你想要保留的空白字符，比如行尾的空格或者制表符。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2460cbb75535e120f9e7feecb7bd9324/" rel="bookmark">
			AES解密报错：Malformed UTF-8 data（主流方法总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试了
一、以为格式错误，改格式为UTF-8
先在前端转，比较麻烦。就在后端转。
但下图代码里的mb_detect_encoding还存在字符串较短时判断不准的情况，最后也不折腾了。因为将原文参数用json.encode转字符串后返回的就是UFT-8格式的数据，加密也不至于改格式。而且前端Nginx服务器配置里也加了charset UTF-8;
function str_to_utf8 ($str = '') { $current_encode = mb_detect_encoding($str, array("ASCII","GB2312","GBK",'BIG5','UTF-8')); $encoded_str = mb_convert_encoding($str, 'UTF-8', $current_encode); return $encoded_str; } (12条消息) php将任意编码的内容转换成utf-8_php字符转码_Rudon滨海渔村的博客-CSDN博客
二、去掉密文的换行符
(19条消息) 项目部署到linx下时，前端AES解密报Malformed UTF-8 data_qq_39196385的博客-CSDN博客
三、加密和解密的key 不一样
(19条消息) encrypt 解密报错 Malformed UTF-8 data_uncaught error: malformed utf-8 data_Memory_bellwether的博客-CSDN博客
四、用Base64加解密
我后端本来就在AES加密后，又用Base64加密了。后端去掉Base64加密后就报跟前端一样的Malformed UTF-8 data错误。
前端倒是本来没有Base64解密，但加上后仍然报同样的错。
五、更改密钥为32位
AES 有三种算法，主要是对数据块的大小存在区别：
AES-128：需要提供 16 位的密钥
AES-192：需要提供 24 位的密钥
AES-256：需要提供 32 位的密钥
我发现我用的256，但密钥很短，百度了一个AES密钥在线生成器，新密钥换上后问题解决。
并且虽然后端用了Base64加密，但我前端用的AES解密插件自带Base64解密，所以搞定。
PHP使用OpenSSL实现AES加密的笔记 - 景北斗 - 博客园 (cnblogs.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a1944d771f2d55484995261748ef07/" rel="bookmark">
			Java连接超时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java.net.SocketTimeoutException: connect timed out 通常表示无法建立到远程服务器的连接，可能是由于网络问题或目标服务器不可用导致的。这种情况下，可以尝试以下几种解决方法：
检查网络连接：可以检查本地网络连接是否正常，例如，是否存在防火墙或代理服务器等问题。
检查目标服务器状态：可以检查目标服务器是否正常运行，是否存在过载或其他故障等问题。
检查端口是否开放：可以检查端口是否被正确开放，是否存在端口占用或防火墙等问题。
增加连接超时时间：可以尝试增加连接的超时时间，以允许更长时间的等待。例如，在Java中，可以通过设置连接超时来增加超时时间。
使用备用服务器：如果目标服务器不可用，可以尝试使用备用服务器来处理请求。
java.net.SocketTimeoutException: Read timed out 通常表示无法从远程服务器读取数据，可能是因为网络不稳定或者目标服务器响应时间过长。这种情况下，可以尝试以下几种解决方法：
增加超时时间：可以尝试增加连接的超时时间，以允许更长时间的等待。例如，在Java中，可以通过设置连接超时和读取超时来增加超时时间。
检查网络连接：可以检查本地网络连接是否正常，例如，是否存在防火墙或代理服务器等问题。
检查目标服务器状态：可以检查目标服务器是否正常运行，是否存在过载或其他故障等问题。
缩小数据范围：如果读取的数据量过大，可以尝试缩小数据范围，以减少读取时间。
优化代码逻辑：可以检查代码逻辑是否存在瓶颈或性能问题，并进行相应的优化。
远程数据读取 从远程服务器读取数据的过程通常包括以下几个步骤：
建立连接：客户端通过网络连接到远程服务器，建立起连接。这个过程通常需要指定远程服务器的IP地址和端口号。
发送请求：客户端向远程服务器发送请求，请求可以是读取数据、写入数据或执行其他操作。请求通常包含一些参数和数据，用于指定要执行的操作和相关信息。
接收响应：远程服务器接收到请求后，会处理请求并返回响应。响应通常包含一些数据和状态信息，用于告诉客户端请求是否成功，并返回相应的数据。
解析响应：客户端接收到响应后，需要将响应解析为可读取的数据格式。例如，在HTTP协议中，响应通常以HTML、JSON、XML等格式返回。
处理数据：客户端根据响应中的数据进行相应的处理。例如，将数据显示在界面上、保存到本地文件中或进行其他操作。
关闭连接：客户端在完成请求和响应后，需要关闭与远程服务器的连接，释放相关资源。
需要注意的是，从远程服务器读取数据的过程可能涉及到网络延迟、连接超时、数据包丢失等问题，因此需要在代码中进行相应的异常处理和错误处理，以保证程序的稳定性和可靠性。
读请求超时的Java代码示例 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.URL; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; public class HttpsExample { public static void main(String[] args) throws IOException { // 设置SSL证书信任和验证 TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() { public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {} public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {} public X509Certificate[] getAcceptedIssuers() { return null; } } }; try { SSLContext sslContext = SSLContext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9a1944d771f2d55484995261748ef07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd8523667e0898d9e5479e82c9236854/" rel="bookmark">
			C语言小项目 -- 扫雷游戏完整代码（递归展开 &#43; 选择标记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
🚀0. 游戏介绍：
🐷 游戏规则
🛸雷诀八条
🚀1. 开发环境及框架：
🚀2. 游戏具体功能分析实现：
🐷2.1 棋盘
🐷2.2 棋盘初始化 init_Board;
🐷2.2 棋盘打印 show_board;
🐷2.3 布置雷 set_mine
🐷2.4 排查雷及判断输赢 fine_mine
🐷2.5 按规则展开static void explosion_spread
🐷2.6 获取周围雷的个数get_mine_count
🐷2.7 标记雷mark_mine
🚀3. 游戏完整代码：
🛰️MineSweeper.h——头文件
🛰️MineSweeper.c——源文件
🛰️MineSweepertest.c
🚀3. 游戏效果图：
🚀0. 游戏介绍： 《扫雷》是一款大众类的益智小游戏，于1992年发行。游戏目标是在最短的时间内根据点击格子出现的数字找出所有非雷格子，同时避免踩雷，踩到一个雷即全盘皆输。
🐷 游戏规则 在一个9×9（初级）、16×16（中级）、16×30（高级）或自定义大小的方块矩阵中随机布置一定量的地雷（初级为10个，中级为40个，高级为99个），再由玩家逐个翻开方块，以找出所有地雷为最终游戏目标。如果玩家翻开的方块有地雷，则游戏结束。
🛸雷诀八条 第一条：基本定式不要忘，现场推理真够呛。第二条：鼠标点击不要快，稳定节奏把空开。第三条：顺手标雷不要惯，积累下来记录悬。第四条：无从下手不要愣，就近猜雷把心横。第五条：遇到猜雷不要怕，爆了脸上不留疤。第六条：猜雷猜错不要悔，哭天抢地也白费。第七条：碰上好局不要慌，紧盯局部慢扩张。第八条：痛失好局不要恨，既然有缘定有份。 🚀1. 开发环境及框架： 本人开发环境采用—VS2022，学会调试，参考文章调试规则，以及windows自带画图板
采取工程内多文件进行链接编译，包括：
MineSweeper.h——头文件，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。MineSweeper.c——源文件，里边含各种函数的具体功能实现MineSweepertest.c——测试扫雷游戏的使用，包含主体运行，主函数等 🚀2. 游戏具体功能分析实现： 🐷2.1 棋盘 如何定义初始化棋盘，便是需要解决的第一个问题
可知棋盘用二维数组更便于表示：
char show[ROWS][COLS];//展示棋盘 char mine[ROWS][COLS];//雷盘 #define ROW 9 #define COL 9 定义了两个棋盘，分别用来保存布置雷的信息和排查雷的信息，这样就可以避免二者相互干扰或者相互覆盖；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd8523667e0898d9e5479e82c9236854/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1fbff170b02d53b37f2b97427c33a98/" rel="bookmark">
			Extend函数和append函数的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在看《机器学习实战》一书中有关决策树的案例讲解时发现了extend和append函数都是表示添加，但用法不同的这个情况，如图：
其实，具体讲来是，extend是将容器打碎后添加（添加的是容器内的元素），而append添加是将容器看作整体来进行添加（将整个容器作为一个整体的元素添加到新的容器中）
课本中也有更容易理解的例子:
于是，我们可以真正理解通过
reducedFeatVec = featVec[:axis] #去掉axis特征 reducedFeatVec.extend(featVec[axis+1:]) 上述两步只是为了去掉axis特征。
而通过append操作
retDataSet.append(reducedFeatVec) 我们又可以将reDataSet = [ ]这个空集合重新整合成数组的形式，这样我们的函数最后返回的就还是一个数据集的形式啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e0857b0c9e923593e81dbe13ae9e616/" rel="bookmark">
			【Java】线程池的概念及使用、ThreadPoolExecutor的构造方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是线程池为什么用线程池JDK提供的线程池工厂模式如何使用 自定义线程池ThreadPoolExecutor类的构造方法工作原理拒绝策略 线程池的使用 什么是线程池 在之前JDBC编程中，通过DataSource获取Connection的时候就已经用到了池的概念。这里的池指的是数据库连接池。当Java程序需要数据库连接的时候就从池子中拿一个空闲的连接对象给Java程序，Java程序用完连接之后就会返回给连接池。线程池就是在池子里放的是线程本身，当程序启动的时候就创建出若干个线程，如果有任务就处理，没任务就阻塞等待。
为什么用线程池 当创建一个线程时，系统申请资源，将其加入到PCB的链表中，当需要销毁线程时释放资源，从PCB链表中移除。线程池的作用就是为了减少这些关于申请和释放PCB的操作，尽量保证程序在用户态执行，减少系统创建线程的开销。
JDK提供的线程池 ①Executors.newCachedThreadPool():处理大量短时间工作任务的线程池;
②Executors.newFixedThreadPool()：创建一个固定大小线程池；
③Executors.newSingleThreadExecutor()： 创建一个只有一个工作线程的线程池；
④Executors.newSingleThreadScheduledExecutor()：创建一个带时间定时的线程池；
⑤Executors.newScheduledThreadPool()：创建一个指定大小并带时间定时的线程池；
⑥Executors.newWorkStealingPool()：创建一个指定大小（不传入参数，为当前机器CPU核心数）的线程池，并行地处理任务。
// 1. 用来处理大量短时间工作任务的线程池,如果池中没有可用的线程将创建新的线程，如果线程空闲60秒将收回并移出缓存 ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); // 2. 创建一个操作无界队列且固定大小线程池 ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); // 3. 创建一个操作无界队列且只有一个工作线程的线程池 ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); // 4. 创建一个单线程执行器，可以在给定时间后执行或定期执行。 ScheduledExecutorService singleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor(); // 5. 创建一个指定大小的线程池，可以在给定时间后执行或定期执行。 ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3); // 6. 创建一个指定大小（不传入参数，为当前机器CPU核心数）的线程池，并行地处理任务，不保证处理顺序 Executors.newWorkStealingPool(); 无界队列：指的是对于队列中的元素个数不加限制，可能会出现能存被消耗殆尽的情况。
工厂模式 在JDK中通过Executors工具类调用一系列方法完成不同功能线程池的创建涉及一种设计模式：工厂模式。
这种模式就是为了解决构造方法创建对象的不足，比如下面这种情况：
想通过id和age属性分别创建不同的学生对象，但由于重载方法的参数列表相同，所以会报错。可以定义静态方法起不同的方法名,根据传来的数据按照工厂方法里的逻辑返回对应的对象。
class Student { private int id; private int age; private String name; // // 通过id和name属性来构造一个学生对象 // public Student (int id , String name) { // this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e0857b0c9e923593e81dbe13ae9e616/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/129/">«</a>
	<span class="pagination__item pagination__item--current">130/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/131/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>