<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0eb4c5b948e3cefc9b8233e45f91874/" rel="bookmark">
			【MyBatis Plus】使用 MyBatis Plus 完成分页功能，以及通用分页实体的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、MyBatis Plus 分页插件1.1 了解 MyBatis Plus 的插件功能1.2 配置分页插件1.3 测试分页功能 二、实现通用分页实体2.1 分页查询需求2.2 分页实体类2.3 分页查询接口2.4 通用实体的转换2.4.1 PageQuery 转换为 MP Page2.4.2 分页结果 PO 转换 VO 一、MyBatis Plus 分页插件 1.1 了解 MyBatis Plus 的插件功能 当使用 MyBatis Plus 的插件功能时，可以通过配置不同的插件来满足项目的需求。这些插件可以增强 MyBatis Plus 的功能，提高数据库操作的效率和安全性。以下是对主要插件的介绍：
插件功能PaginationInnerInterceptor自动分页TenantLineInnerInterceptor多租户DynamicTableNameInnerInterceptor动态表名OptimisticLockerInnerInterceptor乐观锁IllegalSQLInnerInterceptorSQL 性能规范BlockAttackInnerInterceptor防止全表更新与删除 PaginationInnerInterceptor（自动分页）：PaginationInnerInterceptor 用于实现自动分页功能。通过配置这个插件，可以轻松地在查询操作中启用分页，而无需手动编写分页查询的 SQL。插件会自动计算起始行和结束行，以获取指定范围的数据。
TenantLineInnerInterceptor（多租户）：TenantLineInnerInterceptor 插件用于支持多租户架构。在多租户环境中，不同租户共享同一数据库，但数据需要分隔。这个插件可以自动在 SQL 查询中添加租户条件，以确保每个租户只能访问自己的数据。
DynamicTableNameInnerInterceptor（动态表名）：DynamicTableNameInnerInterceptor 允许在运行时动态更改 SQL 查询中的表名。这对于根据不同的条件选择不同的表格非常有用，例如，可以根据用户身份或其他因素选择不同的表格。
OptimisticLockerInnerInterceptor（乐观锁）：OptimisticLockerInnerInterceptor 用于支持乐观锁机制。乐观锁是一种并发控制方式，可以防止多个用户同时修改同一记录。这个插件会自动为实体添加乐观锁的版本字段，并在更新操作中检查版本号，以确保数据的一致性。
IllegalSQLInnerInterceptor（SQL 性能规范）：IllegalSQLInnerInterceptor 用于检查 SQL 查询语句的性能规范。它可以帮助开发者优化 SQL 查询，减少潜在的性能问题。通过检查 SQL 的性能规范，可以提高查询的效率。
BlockAttackInnerInterceptor（防止全表更新与删除）：BlockAttackInnerInterceptor 用于防止执行全表更新和删除操作。这有助于减少潜在的危险操作，以保护数据库的安全性。插件可以拦截包含特定条件的 SQL 查询，阻止执行这些操作。
通过合理配置这些插件，可以提高 MyBatis Plus 的功能和性能，以满足不同项目的需求，并且这些插件使数据库操作更加高效和安全。下面将演示如何利用 PaginationInnerInterceptor 自动分页插件来实现分页功能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0eb4c5b948e3cefc9b8233e45f91874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97cced23cf5a3a9963405166a96510bd/" rel="bookmark">
			Python 面向对象--人狗大战（代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目实训 人狗大战
多个人，多条狗，多个品种，年龄，攻击力 可参考教程:https://blog.csdn.net/Aluxian_/article/details/134141861?spm=1001.2014.3001.5502
attack_vals = { "二哈":20, "藏獒":70, "金毛":40 } def dog(name, d_type): data = { "name":name, "d_type":d_type, "life_val":100 } if d_type in attack_vals: data["attack_val"] = attack_vals[d_type] else: data["attack_val"] = 15 def dog_bite(person_obj): person_obj["life_val"] -= data["attack_val"] print("狗[%s]咬了人[%s]一口,人掉血[%s],还有血量[%s]..." % (data['name'], person_obj["name"], data["attack_val"], person_obj["life_val"])) data["bite"] = dog_bite return data def person(name,age): data = { "name": name, "age": age, "life_val": 100 } if age &gt;= 18: data["attack_val"] = 50 else: data["attack_val"] = 30 def person_beat(dog_obj): dog_obj["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97cced23cf5a3a9963405166a96510bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61609116e8c7655e73c45ba0637a1eb0/" rel="bookmark">
			AUC的解释，以及其他指标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为做比赛，又开始看一些关于评价指标的问题，下面这篇帖子不错，贴过来吧。
参考
ROC曲线画法。
https://www.zhihu.com/question/22844912
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb534daccf58683b11cb641bb0da46b2/" rel="bookmark">
			微信小程序实现微信登录(Java后台)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两天在自己的小项目中加入了微信小程序的很多功能，今天来说一下关于微信授权登录的部分。
需要的材料 1：一个可以测试的微信小程序
2：此微信小程序的APPID和APPscret
流程 微信用户对应一个小程序都有一个唯一的openid，微信授权登录，微信授权登录的核心就是获取这个openid并存在数据库作为用户存在的唯一标识。微信授权登录的流程大体分为两步
1.微信小程序前端获取code并发送到后台
在微信小程序的前端调用wx.login()获取一个code，这个code就像是我们去微信后台服务器获取用户信息的一个钥匙，微信通过获取这个code的过程给用户一个选择是否授权的选择，如果用户选择了授权就会返回一个code。这个code是一次性的，也是有时限的，代码如下。 //请求code wx.login({ success(res) { if (res.code) { //把获取到的code通过一个request的请求发给java服务器 wx.request({ url:你的url地址, data: { code: res.code }, method: 'POST', dataType: 'json', success: function (res) { //请求成功的处理 } } }, fail: function () { console.log("发送code失败：", res.data); } }) 2.后台接收code并通过code拉取用户的openid
后台接受了code以后通过建立一个http请求去访问微信后台服务器拉取这个用户的openid，
如果一切正常就会得到这个用户对应这个小程序的openid和用户个人的Access_token（和微信小程序的Access_Token不一样）。
请求的地址：
https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;secret=SECRET&amp;js_code=JSCODE&amp;grant_type=authorization_code 通过GET方式访问，其中的参数分别是： appid：小程序的appid
secret：小程序的appsecret
js_code：小程序前端传来的code
grant_type：这个不用修改，表示授权的类型
需要用到的包
&lt;!-- http请求工具包依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt; &lt;/dependency&gt; public Map&lt;String, Object&gt; hqToken(String code, String APPID, String APPSecret) { StringBuilder url = new StringBuilder("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb534daccf58683b11cb641bb0da46b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5835039fa1d9d970f11e41424c4d165/" rel="bookmark">
			使用JavaScript给图片添加图片水印的前端实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当涉及图片处理时，JavaScript是一种强大的工具。在本篇博客中，我们将学习如何使用JavaScript来给图片添加水印，并将其封装成一个函数，以便在需要的时候重复使用。
准备工作： 在开始之前，确保你已经准备好了以下内容：
1.一张待添加水印的图片。
2.水印图片。
3.一个基本的HTML文件和一个连接到JavaScript文件的script标签。
添加水印效果： 首先，我们需要编写一个函数，用于添加水印到图片上。以下是一个示例函数：
function addWatermark(imagePath, watermarkPath) { var canvas = document.createElement('canvas'); var context = canvas.getContext('2d'); // 创建一个新的Image对象，用于加载原始图片 var image = new Image(); image.src = imagePath; // 在图片加载完成后执行下面的代码 image.onload = function() { canvas.width = image.width; canvas.height = image.height; // 将原始图片绘制到canvas上 context.drawImage(image, 0, 0); // 创建一个新的Image对象，用于加载水印图片 var watermark = new Image(); watermark.src = watermarkPath; // 在水印图片加载完成后执行下面的代码 watermark.onload = function() { // 设置水印的位置和尺寸 var x = 0; var y = 0; var width = image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5835039fa1d9d970f11e41424c4d165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4030e95054b20c228b42a4eb0c92aace/" rel="bookmark">
			android实现自定义提示框（alertDialog）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自定义dialog页面 如果有背景图，背景图可直接加载到dialog里面，默认dialog是方边框，可以通过背景图来控制边框形状，而且这样可以避免弹框和自定义的页面之间有空白的情况
添加背景图
window.setBackgroundDrawable(getResources().getDrawable(R.drawable.dialog));
去边框
window.getDecorView().setPadding(0, 0, 0, 0);
具体代码在第3步
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="560sp" android:layout_height="@dimen/dp_300" android:gravity="center" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_width="@dimen/dp_300" android:layout_height="@dimen/dp_200" android:layout_margin="10dp" android:layout_weight="1" android:paddingLeft="@dimen/dp_20" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="@dimen/dp_260" android:layout_height="@dimen/dp_50" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/textView1" android:layout_width="@dimen/dp_180" android:layout_height="@dimen/dp_50" android:gravity="center" android:textColor="@color/black" android:textSize="@dimen/dp_22" android:textStyle="bold" android:text="2023年9月15日"/&gt; &lt;TextView android:id="@+id/textView2" android:layout_width="fill_parent" android:layout_height="@dimen/dp_50" android:textColor="@color/black" android:textSize="@dimen/dp_22" android:textStyle="bold" android:text="星期四"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="@dimen/dp_150" android:layout_height="@dimen/dp_200" android:layout_margin="10dp" android:layout_weight="1" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/textView3" android:layout_width="@dimen/dp_100" android:layout_height="wrap_content" android:gravity="center" android:textColor="@color/black" android:textSize="@dimen/dp_32" android:textStyle="bold" android:text="11:55"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="@dimen/dp_260" android:layout_height="@dimen/dp_200" android:layout_margin="10dp" android:layout_weight="1" android:orientation="horizontal"&gt; &lt;TextView android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4030e95054b20c228b42a4eb0c92aace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6105831aee1c4b4fc3929dd83c039848/" rel="bookmark">
			swiper插件获取当前的轮播元素及索引index( loop=true）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义轮播标签
swiper-slide–轮播元素class
&lt;div class="swiper-container" &gt; &lt;div class="swiper-wrapper" id="swiper-slide-content"&gt; &lt;div class="swiper-slide" data-name="测试1" &gt; &lt;div class="item"&gt; &lt;div class="swpimg"&gt; &lt;img th:src="@{/screen/app/images/swpimg01.png}" alt=""&gt; &lt;/div&gt;	&lt;p&gt;测试轮播1&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="swiper-slide" data-name="测试2" &gt; &lt;div class="item"&gt; &lt;div class="swpimg"&gt; &lt;img th:src="@{/screen/app/images/swpimg01.png}" alt=""&gt; &lt;/div&gt;	&lt;p&gt;测试轮播2&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Swiper插件初始化
onTransitionEnd回调事件–轮播切换时会触发
swiper-slide-active 标识当前正在轮播的元素，可以根据它来获取我们自定义的元素属性值：data-name
data-swiper-slide-index 当前轮播元素的索引属性
//初始化Swiper var swiper = new Swiper('.swiper-container', { // 显示几个 slidesPerView: 3, paginationClickable: true, // 在slide之间设置距离 spaceBetween: 20, // 设定slide与左边框的预设偏移量 slidesOffsetBefore: 20, // 设定slide与左边框的预设偏移量 slidesOffsetAfter: 20, autoplayDisableOnInteraction:false, autoplay: 5000, loop: true, onTransitionEnd: function (swiper) { var index = $('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6105831aee1c4b4fc3929dd83c039848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3412dda07cb975591d4be425d72b770d/" rel="bookmark">
			Hessian矩阵的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hessian 矩阵是多元函数的二阶偏导数构成的矩阵，它用于描述函数的曲率和凹凸性。理解 Hessian 矩阵的关键概念包括以下几点：
二阶导数：Hessian 矩阵包含了函数的所有可能的二阶偏导数。对于一个函数f(x₁, x₂, …, xₙ)，Hessian 矩阵H的元素Hᵢⱼ表示了函数f对自变量xᵢ和xⱼ的二阶偏导数。例如，Hᵢⱼ = ∂²f/∂xᵢ∂xⱼ。
对角线元素：Hessian 矩阵的对角线元素Hᵢᵢ表示了函数在对应自变量方向上的曲率。如果 Hᵢᵢ &gt; 0，表示函数在这个方向上是凸的，如果 Hᵢᵢ &lt; 0，表示函数在这个方向上是凹的。如果 Hᵢᵢ = 0，表示函数在这个方向上没有曲率变化。
非对角线元素：非对角线元素Hᵢⱼ（i ≠ j）表示了函数在不同自变量方向上的交叉曲率。正值表示函数在这两个方向上同时凸，负值表示函数在这两个方向上同时凹，而零值表示两个方向上的曲率不相关。
示例说明：
考虑一个简单的多元函数，例如 f(x, y) = x² + 2xy + y²，其中(x, y)是自变量。我们可以计算这个函数的 Hessian 矩阵。
首先，计算一阶偏导数：
∂f/∂x = 2x + 2y∂f/∂y = 2x + 2y 然后，计算二阶偏导数：
∂²f/∂x² = 2∂²f/∂y² = 2∂²f/∂x∂y = ∂²f/∂y∂x = 2 将这些二阶偏导数组合成 Hessian 矩阵：
H = [∂²f/∂x², ∂²f/∂x∂y; ∂²f/∂y∂x, ∂²f/∂y²] = [2, 2; 2, 2]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3412dda07cb975591d4be425d72b770d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d57d105ff755b47c9ae8d608afc56fa/" rel="bookmark">
			ionic--学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ionic默认组件都很基础，又用了Shadow DOM。官网提供的自定义属性无法满足设计需求。网上看了很多文章，demo也写了不少，最后总结一下。
在官方文档中提供的自定义属性 + 组件自身的属性，能满足部分更改需求。
截取部分：
一、例：更改某个按钮左右间距
在按钮自身的自定义属性中有如下两条正好复合需求
// html &lt;ion-button color="primary" size="small" class="apply-btn" (click)="create()"&gt;创建&lt;/ion-button&gt; //css .apply-btn { --padding-start: 10px; --padding-end: 10px; } 二、修改range组件，设计稿range的滑轮和滑块的颜色不一样，而且还是渐变色。
第一步：定义两个组件，修改其中一个组件样式（two的样式）
//html &lt;ion-item class="one"&gt; &lt;ion-range min="-200" max="200" color="secondary" class="one-range"&gt; &lt;ion-label slot="start"&gt;-200&lt;/ion-label&gt; &lt;ion-label slot="end"&gt;200&lt;/ion-label&gt; &lt;/ion-range&gt; &lt;/ion-item&gt; &lt;ion-item class="two"&gt; &lt;ion-range min="-200" max="200" color="secondary" class="two-range"&gt; &lt;ion-label slot="start"&gt;-200&lt;/ion-label&gt; &lt;ion-label slot="end"&gt;300&lt;/ion-label&gt; &lt;/ion-range&gt; &lt;/ion-item&gt; 第二步：添加组件支持的自定义属性
//css .two { --background: yellow; --height: 80px; width: 310px; .two-range { --ion-color-base: linear-gradient(180deg, #F44336 0%, #4CAF50 100%) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d57d105ff755b47c9ae8d608afc56fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96e54515e8e297c14d599d3303fcce4/" rel="bookmark">
			【RNN&#43;加密流量A】ET-BERT: A Contextualized Datagram Representation with Pre-training Transformers for...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 论文简介摘要存在的问题论文贡献1. ET-BERT2. 实验 总结论文内容数据集可读的引用文献参考连接 论文简介 原文题目：ET-BERT: A Contextualized Datagram Representation with Pre-training Transformers for Encrypted Traffic Classification
中文题目：ET-BERT：一种基于预训练转换器的数据报上下文化表示方法，用于加密流量分类
发表会议：WWW '22: The ACM Web Conference 2022
发表年份：2022-4-25
作者：Xinjie Lin
latex引用：
@inproceedings{lin2022bert, title={Et-bert: A contextualized datagram representation with pre-training transformers for encrypted traffic classification}, author={Lin, Xinjie and Xiong, Gang and Gou, Gaopeng and Li, Zhen and Shi, Junzheng and Yu, Jing}, booktitle={Proceedings of the ACM Web Conference 2022}, pages={633--642}, year={2022} } 摘要 加密流分类需要从内容不可见和不平衡的流量数据中获取判别性和鲁棒性的流量表示，以实现准确的分类，这是实现网络安全和网络管理的一项挑战，但也是必不可少的。现有解决方案的主要局限是高度依赖深度特征，而深度特征过度依赖于数据大小，难以在未见数据上进行泛化。如何利用开放域未标记的流量数据学习具有较强泛化能力的表示仍然是一个关键的挑战。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c96e54515e8e297c14d599d3303fcce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ce4897ec72d680c31df308f700741a/" rel="bookmark">
			JavaScript: 创造交互的魔法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在当今数字化时代，网页已成为人们获取信息和进行交流的主要平台之一。而要使网页充满生机和活力，JavaScript无疑是最重要的工具之一。它是一门强大的脚本语言，它让网页与用户产生互动，并赋予网页以无穷的可能性。本文将带您进入JavaScript的世界，揭示其神奇的力量。
正文 一、简介 JavaScript起源于1995年，最初是作为一种在浏览器上运行的脚本语言而被创造出来的。JavaScript可以被嵌入到HTML页面中，通过脚本语句实现动态的网页效果和用户交互。与其他静态的网页语言相比，JavaScript使得网页更具吸引力、更具交互性。
二、基础语法 在学习任何编程语言之前，了解其基础语法是至关重要的。以下是一个简单的JavaScript代码示例，它将向用户显示一条问候语：
// 定义一个变量来存储用户名 var username = prompt('请输入您的名字：'); ​ // 在网页上显示问候语 document.write('欢迎您，' + username + '!'); 以上代码中，我们使用var关键字定义了一个变量username，并通过prompt函数获取用户输入的名字。然后，使用document.write函数将问候语显示在网页上。
三、DOM操作 DOM (Document Object Model) 是JavaScript的重要组成部分，它允许开发者与网页中的HTML元素进行交互。以下示例演示了如何使用JavaScript更改HTML元素的样式：
// 获取HTML元素 var header = document.getElementById('header'); ​ // 更改元素样式 header.style.color = 'red'; header.style.fontWeight = 'bold'; header.style.fontSize = '24px'; 在以上代码中，我们使用document.getElementById函数获取一个id为header的HTML元素，并使用style对象更改了它的颜色、字体粗细和字体大小。
四、事件处理 JavaScript为网页注入了交互的魔力，使得用户可以与网页进行实时互动。以下示例展示了如何使用JavaScript处理按钮的点击事件：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;button id="myButton"&gt;点击我&lt;/button&gt; ​ &lt;script&gt; // 获取按钮元素 var button = document.getElementById('myButton'); ​ // 添加点击事件处理函数 button.addEventListener('click', function() { alert('您点击了按钮！'); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 以上代码中，我们使用addEventListener函数为按钮元素添加了一个点击事件处理函数。当用户点击按钮时，浏览器将弹出一个包含文本"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ce4897ec72d680c31df308f700741a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdf4dfc944c344a4229c16466b20c376/" rel="bookmark">
			Redis安装Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载安装包
wget http://download.redis.io/releases/redis-3.0.0.tar.gz
2、安装
mkdir /usr/local/redis
cp redis-3.0.0.tar.gz /usr/local/redis
cd /usr/local/redis
tar -zxvf redis-3.0.0.tar.gz
cd /usr/local/redis/redis-3.0.0
make PREFIX=/usr/local/redis install
cp /usr/local/redis/redis-3.0.0/redis.conf /usr/local/redis/bin
vim /usr/local/redis/bin/redis.conf
3、修改配置文件
vim /usr/local/redis/bin/redis.conf
daemonize yes#后端启动
requirepass#密码
开启远程访问
注释掉
4、启动
cd /usr/local/redis/bin
./redis-server ./redis.conf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396262ee936f3d3e26ff0e60bea6cae0/" rel="bookmark">
			BMC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 BMC（Baseboard Management Controller），基板管理控制器，普通PC没有，服务器产品必备。BMC是一个独立的系统，只要通电即可运行，服务器无需开机，不依赖其它软硬件，如OS、BIOS、CPU、内存等；BMC可以与BIOS和OS交互
功能 设备信息管理 记录服务器型号、制造商、日期、各部件生产和技术信息、机箱信息、主板信息、BMC信息（服务器主机名、IP、BMC固件版本等）
服务器状态监控管理 对服务器各个部件（CPU、内存、硬盘、风扇、机框等）的温度、电压等健康状态进行检测
服务器远程控制管理 服务器的开关机、重启、维护、固件更新、系统安装等
维护管理 日志管理、用户管理、BIOS管理、告警管理等
在主板中位置 IPMI 智能平台管理接口（IPMI：Intelligent Platform Management Interface）是一项应用于服务器管理系统设计的标准规范，由Intel、HP、Dell和NEC公司于1998年共同提出，当前最新版本为2.0。利用此接口标准设计有助于在不同类服务器系统硬件上实施系统管理，使不同平台的集中管理成为可能。
IPMI独立于主机系统、CPU、BIOS/UEFI之外，可独立运行的板上部件，其核心是BMC，IPMI的所有功能都是向BMC发送命令去完成的
各大厂商IPMI接口 以下可统称为MGMT；带外管理口
惠普的iLO
戴尔的iDRAC
浪潮的IPMI
新华三的HDM
华为的iBMC
IBM的IMM
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20d0023d14c2f0f3593b163cbcba73ac/" rel="bookmark">
			python自动化测试（九）：EcShop添加商品功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置条件：
本地部署：ECShop的版本是3.0.0、Google版本是
Google Chrome65.0.3325.162 (正式版本) （32 位） py的selenium版本是3.11.0
目录
一、前置代码
二、添加商品操作
2.1 点击添加商品
2.2 添加名称、分类、品牌
2.3 添加价格、勾选促销、添加促销
2.4 清除促销输入框的只读属性
2.5 清除并设置促销日期（开始与结束）
2.6 上传图片（pywinauto）
2.7 确定提交
一、前置代码 （打开ECSHOP后台，登录）
# coding=utf-8 # 导入自动化的模块 from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains from selenium.common.exceptions import NoSuchElementException from selenium.webdriver.support.select import Select import time import pywinauto # 定义一个浏览器 driver = webdriver.Chrome() url = "http://localhost/ecshop/admin/privilege.php?act=login" # 打开一个浏览器 driver.get(url) # 最大化窗口尺寸 driver.maximize_window() # 添加全局的等待时间 driver.implicitly_wait(10) # 输入用户名 driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20d0023d14c2f0f3593b163cbcba73ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f870cc001f32a9a4f53d5de211a8ecbe/" rel="bookmark">
			python自动化测试（十）：EcShop删除商品功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置条件：
本地部署：ECShop的版本是3.0.0、Google版本是
Google Chrome65.0.3325.162 (正式版本) （32 位） py的selenium版本是3.11.0
目录
一、前置代码
二、删除操作
2.1 进入商品列表
2.2 通过货号进行删除
一、前置代码 （打开ECSHOP后台，登录）
# coding=utf-8 from selenium import webdriver from selenium.common.exceptions import NoSuchElementException from selenium.webdriver.support.select import Select import time # 定义一个浏览器 driver = webdriver.Chrome() url = "http://localhost/ecshop/admin/privilege.php?act=login" # 打开一个浏览器 driver.get(url) # 最大化窗口尺寸 driver.maximize_window() # 添加全局的等待时间 driver.implicitly_wait(10) # 输入用户名 driver.find_element_by_name("username").send_keys("admin") # 输入密码 driver.find_element_by_name("password").send_keys("t1194783") # 点击登录按钮 driver.find_element_by_class_name("btn-a").click() 二、删除操作 2.1 进入商品列表 # 进入子页面 driver.switch_to.frame("menu-frame") # 点击商品列表 driver.find_element_by_link_text("商品列表").click() # 返回父级页面 driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f870cc001f32a9a4f53d5de211a8ecbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85a03e25b62a38437798131a9862308/" rel="bookmark">
			Android开发笔记（三）—Activity篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		活动组件Activity 启动和结束生命周期启动模式信息传递Intent显式Intent隐式Intent 向下一个Activity发送数据向上一个Activity返回数据 附加信息利用资源文件配置字符串利用元数据传递配置信息给应用页面注册快捷方式 启动和结束 （1）从当前页面跳到新页面：startActivity(new Intent(源页面.this,目标页面.class))
（2）从当前页面回到上一个页面，相当于关闭当前页面：finish()
生命周期 onCreate：创建活动。把页面布局加载到内存，进入了初始状态。
onStart：开始活动。把活动页面显示在屏幕上，进入了就绪状态。
onResume：恢复活动。活动页面进入活跃状态，能够与用户正常交互，例如允许响应用户的点击动作、允许用户输入文字等等。
onPause：暂停活动。页面进入暂停状态，无法与用户正常交互。
onStop：停止互动。页面将不在屏幕上显示。
onDestroy：销毁活动。回收活动占用的系统资源，把页面从内存中清除。
onRestart：重启活动。重新加载内存中的页面数据。
onNewIntent：重用已有的活动实例。
注：如果一个Activity已经启动过了，并且存在当前应用的Activity任务栈中，启动模式为singleTask，singleInstance或singleTop（此时已在任务栈顶端），那么在此启动或回到这个Activity的时候，不会创建新的实例，也就是不会执行onCreate方法，而是执行onNewIntent方法。
下图为活动的状态变迁过程：
打开新页面的方法调用顺序为：
onCreate-&gt;onStart-&gt;onResume
关闭旧页面的方法调用顺序为：
onPause-&gt;onStop-&gt;onDestroy
启动模式 （一）启动模式类型
（1）默认启动模式standard
在该模式下，每启动一个Activity就会在栈顶创建一个新的实例，即启动的Activity会依照启动顺序被依次压入Task栈中。实际开发中，闹钟程序通常使用这种模式。
（2）栈顶复用模式singleTop
该模式会判断要启动的Activity实例是否位于栈顶，如果位于栈顶则直接复用，否则创建新的实例。实际开发中，浏览器的书签、应用支付跳转通常采用这种模式。适合开启渠道多、多应用开启调用的Activity，通过这种设置在一定条件下可以避免已经创建过的Activity被重复创建，多数通过动态设置使用。
（3）栈内复用模式singleTask
与singleTop模式类似，只不过singleTop模式只是针对栈顶的元素，而singleTask下，如果task栈内存在目标Activity实例，则将task内的对应Activity实例之上的所有Activity弹出栈，并将对应Activity置于栈顶，获得焦点。应用场景：
程序/浏览器主界面：不希望主界面被创建多次，而且在主界面退出的时候整个App是最好的效果。
耗费系统资源的Activity：对于那些极其消耗系统资源的Activity，我们可以考虑将其设为singleTask模式，减少资源耗费。 （4）全局唯一模式singleInstance
在该模式下，我们会为目标Activity创建一个新的Task栈，将目标Activity放入新的Task，并让目标Activity获得焦点。新的Task有且只有这一个Activity实例。如果已经创建过目标Activity实例，则不会创建新的Task，而是将以前创建过的Activity唤醒。无论从哪个任务栈中启动该Activity，该实例在整个系统中只有一个。实际开发中，来电界面通常使用这种模式。
（二）设置Activity的启动模式
（1）静态设置启动模式
打开配置文件AndroidManifest.xml，给activity节点添加属性android:launchMode，属性值填入standard表示采取标准模式，当然不添加属性的话默认就是标准模式standard。
&lt;activity android:name=".MainActivity" android:launchMode="standard"/&gt;
（2）动态设置启动模式
动态设置是通过Java代码设置的，通过Intent动态设置Activity启动模式。
Intent类的启动标志说明Intent.FLAG_ACTIVITY_NEW_TASK开辟一个新的任务栈，该值类似于launchMode=“standard”；不同之处在于，如果原来不存在活动栈，则FLAG_ACTIVITY_NEW_TASK会创建一个新栈Intent.FLAG_ACTIVITY_SINGLE_TOP当栈顶为待跳转的活动实例之时，则重用栈顶的实例。该值等同于launchMode=“singleTop”Intent.FLAG_ACTIVITY_CLEAR_TOP当栈中存在待跳转的活动实例时，则重新创建一个实例，并清除原实例上方的所有实例。该值与launchMode="singleTask"类似，但singleTask采取onNewIntent方法启动原任务，而FLAG_ACTIVITY_CLEAR_TOP采取先调用onDestroy再调用onCreate来创建新任务Intent.FLAG_ACTIVITY_NO_HISTORY该标志与launchMode=“standard”情况类似，但栈中不保存新启动的活动实例，这样下次无论以何种方式再启动该实例，也要走standard模式的完整流程，即栈中不保存新启动的活动实例Intent.FLAG_ACTIVITY_CLEAR_TASK该标志非常暴力，跳转到新页面时，栈中的原有实例都被清空。注意该标志需要结合FLAG_ACTIVITY_NEW_TASK使用，即setFlags方法的参数为“Intent.FLAG_ACTIVITY_CLEAR_TASK ｜ Intent.FLAG_ACTIVITY_NEW_TASK” （三）启动模式的实际应用
（1）在两个活动之间交替跳转
背景介绍：假设活动A有个按钮，点击该按钮会跳到活动B；同时活动B也有个按钮，点击按钮会跳到活动A；从首页打开活动A之后，就点击按钮在活动A与活动B之间轮流跳转。此时活动页面的跳转流程为：首页-&gt;活动A-&gt;活动B-&gt;活动A-&gt;活动B-&gt;活动A-&gt;活动B-&gt;…多次跳转之后想回到首页，正常的话返回流程是这样的：…活动B-&gt;活动A-&gt;活动B-&gt;活动A-&gt;活动B-&gt;活动A-&gt;首页，每个箭头都代表按一次返回键，可见要按下许多次返回键才能返回首页。其实在活动A和活动B之间本不应该重复返回，因为回来回去总是这两个页面是没有意义的。照理说每个活动返回一次足矣，同一个地方返回两次已经是多余的了，再返回应当回到首页才是。也就是说，不管过去的时候怎么跳转，回来的时候应该按照这个流程：…活动B-&gt;活动A-&gt;首页，或者：…活动A-&gt;活动B-&gt;首页，总之已经返回了的页面，决不再返回第二次。
设计思想：
对于不允许重复返回的情况，可以设置启动标志FLAG_ACTIVITY_CLEAR_TOP，即使活动栈里面存在待跳转的活动实例，也回重建该活动的实例，并清除原实例上方的所有实例，保证栈中最多只有该活动的唯一实例，从而避免了无谓的重复返回。于是活动A内部的跳转代码就改成了：
Intent intent=new Intent(ActStartActivity.this, ActFinishActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); 当然活动B内部的跳转代码也要设置同样的启动标志：
Intent intent=new Intent(ActFinishActivity.this, ActStartActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); （2）登录成功后不再返回登录页面
背景介绍：很多App第一次打开都要求用户登录，登录成功再进入App首页，如果这时按下返回键，发现并没有回到上一个登录页面，而是直接退出App了，这又是什么缘故呢？原来用户登录成功后，App便记下用户的登录信息，接下来默认该用户是登录状态，自然不必重新输入用户名和密码。既然默认用户已经登录，哪里还需要回到登录页面？不光登录页面，登录之前的其他页面包括获取验证码、找回密码等页面都不应回去，每次登录成功后，整个App就焕然一新仿佛忘记有登录页面这回事。
设计思想：对于回不去的登录页面情况，可以设置启动标志FLAG_ACTIVITY_CLEAR_TASK，该标志会清空当前活动栈里的所有实例。不过全部清空之后，意味着当前栈没法用了，必须另外找个活动栈才行，也就是同时设置启动标志FLAG_ACTIVITY_NEW_TASK，该标志用于开辟新任务的活动栈，这也就是为什么FLAG_ACTIVITY_CLEAR_TASK要配合着FLAG_ACTIVITY_NEW_TASK使用的原因，如果没有设置FLAG_ACTIVITY_NEW_TASK，则栈内对应的Activity销毁重新创建。
于是离开登录页面的跳转代码变成下面这样：
Intent intent=new Intent(ActStartActivity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f85a03e25b62a38437798131a9862308/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d52e2967511d150a0f4ef55a73d737b1/" rel="bookmark">
			云安全与容器安全： 探讨在云环境和容器化应用中如何保护数据和工作负载的安全。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今数字化时代，云计算和容器化应用已经成为了企业业务的主要组成部分。这两项技术的普及，极大地提高了开发和部署的效率，但也带来了新的安全挑战。在本文中，我们将探讨云安全和容器安全的重要性，以及如何有效地保护数据和工作负载的安全。
章节一：云安全的基础 云计算已经成为企业IT基础设施的主要部分。云平台提供了资源虚拟化、弹性扩展、自动化管理等优势，但也伴随着一系列安全问题。在云环境中，数据和工作负载需要得到充分的保护，以防范数据泄露、未经授权访问等风险。云安全的基础包括身份认证、访问控制、数据加密等。
技术案例：AWS Identity and Access Management (IAM)
AWS的IAM服务是云安全的核心组成部分。它允许您管理用户、角色和权限，以确保只有授权的用户可以访问云资源。例如，您可以创建一个具有只读权限的IAM用户，以限制其对敏感数据的访问。以下是一个示例IAM策略：
章节二：容器安全的挑战 容器化应用在云环境中得到了广泛的应用，例如Docker和Kubernetes。容器的轻量级和可移植性使其成为开发人员的首选，但容器安全面临许多挑战。容器隔离、镜像安全、运行时安全等问题需要得到解决，以确保容器环境的安全性。
技术案例：Docker容器隔离
Docker使用命名空间和控制组来实现容器隔离。这意味着每个容器都有自己独立的文件系统、进程和网络空间，与宿主系统和其他容器隔离开来。这有助于防止容器之间的干扰和攻击。
章节三：云中的容器安全 在云环境中，容器安全变得更加复杂。容器编排系统如Kubernetes管理着大量容器，需要更强大的安全措施来保护这些容器。云提供商也提供了一系列工具和服务，以帮助用户加强容器安全。
技术案例：AWS Fargate
AWS Fargate是一种服务器无关的容器编排服务，它可以自动管理容器的部署和伸缩。AWS Fargate集成了AWS Identity and Access Management (IAM) 和 Virtual Private Cloud (VPC)，以提供容器级别的访问控制和网络隔离。
章节四：数据保护和加密 数据保护是云安全的关键要点。在云环境中，数据可能存储在多个位置，因此需要加强数据加密和保护。云提供商通常提供数据加密服务，以确保数据在传输和静态存储时都受到保护。
技术案例：AWS Key Management Service (KMS)
AWS KMS是一种托管的密钥管理服务，用于创建和控制加密密钥。您可以使用KMS来加密数据、管理密钥轮换、监控密钥使用等。它与AWS S3、RDS等服务无缝集成，以提供数据的端到端加密。
章节五：监控和审计 云安全的另一个重要方面是监控和审计。您需要能够跟踪谁访问了云资源，以及他们做了什么。云提供商通常提供日志记录和审计工具，以帮助用户实现这一目标。
技术案例：AWS CloudTrail
AWS CloudTrail记录了云环境中的API活动，并将这些活动存储在S3存储桶中。您可以使用CloudTrail来跟踪资源的访问、更改、删除等活动，并设置警报以监控潜在的安全威胁。
章节六：最佳实践和未来趋势 最后，我们将探讨一些云安全和容器安全的最佳实践，以及未来的趋势。云安全是一个不断发展的领域，随着技术的演进，安全威胁也在不断变化。因此，持续学习和采用最佳实践至关重要。
总结而言，云安全和容器安全是保护数据和工作负载安全的关键要点。通过使用适当的工具和服务，制定良好的策略，以及遵循最佳实践，企业可以有效地应对安全挑战，并在云环境和容器化应用中确保数据的完整性和可用性。安全是一个持续的过程，需要不断更新和改进，以适应不断变化的威胁和技术。
希望这篇文章能够帮助读者更好地理解云安全和容器安全的重要性，以及如何保护其数据和工作负载的安全。如果您有任何问题或想法，欢迎在评论中分享。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d2b3ab71e73b9c2001724ce8a03ae8/" rel="bookmark">
			VSCode终端输出中文乱码（cin cout）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VSCode终端输出中文乱码（cin cout） 1 终端显示不出中文问题 最近学代码，从终端cin中文，但是cout出来的就是乱码的东西。类似下面这种：
2 原因 因windows中文版系统cmd编码默认为GBK，而VSCode默认新建文件的编码为UTF-8，编码不统一，所以会出现中文乱码情况。所以要让他们统一编码，我把他们都变为了UTF-8，但是终端显示的cout结果仍然显示不出来中文。于是我让他们统一为GB2312（简体中文）。
3 解决方法 3.1 查看系统编码方式 因为终端显示用的是cmd，查看一下cmd的编码。
在win10桌面的左下角搜索栏搜索cmd就找到命令提示符；输入以下指令用来查看系统的编码方式； 查看编码指令 chcp GB2312的活动代码页为936。
注意：
GB2312的代码页编号是936，utf-8的代码页编号为 65001。
如果在cmd 中chcp得到的活动代码页为650001，如何将系统修改为936，参考博文http://t.csdnimg.cn/yVE6D方案二（勾选Beta版：utf-8，不勾选Beta版：GBK）
或者用修改编码指令
chcp 936 //改为GBK2312 chcp 65001 //改为UTF-8 3.2 更改VSCode编码方式 936就表示是系统是中文编码。所以把VSCode也变为一样的编码方式。
在VSCode界面的右下角，可以看到我此时更改后的编码为GB2312：
如果不是GB2312，就点击它会弹出通过编码打开 和 通过编码保存，我们选择第一个通过编码打开 ，找到GB2312选择即可。
注意：
在选择了GB2312后，当前代码里面的中文可能出现乱码情况，此时只用ctrl+z就可以恢复代码的中文。
想要内置终端显示，就点击屏幕下方的Compile &amp; Run 或者 在代码界面左键Run Code。（注意代码.cpp文件命名不要有空格，有空格报错，可以是中文命名）
想要外置终端显示，就点击右上角的播放箭头即可。
4 验证 可以看到此时的姓名和住址正常显示中文了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97c367d63c81b705c637282ab11b8b58/" rel="bookmark">
			恶意软件防范和拦截： 提供防范恶意软件攻击的策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		恶意软件，或者俗称的“病毒”，一直是IT领域的一个严重威胁。这些恶意软件可以窃取敏感信息、损害系统稳定性，甚至对企业和个人造成重大经济损失。在这篇博客文章中，我们将讨论如何防范和拦截恶意软件攻击，包括使用反病毒软件、沙箱技术和应用白名单。
第一章：恶意软件的威胁 恶意软件的威胁一直存在，而且不断演化。从最早的计算机病毒到今天的勒索软件和间谍软件，恶意软件攻击的复杂性和危害性都在不断增加。举例来说，WannaCry 勒索软件在2017年爆发，造成了全球范围内的破坏，使企业和机构付出了巨额赎金。
第二章：反病毒软件的重要性 反病毒软件是防范恶意软件攻击的第一道防线。它们使用病毒特征库来检测和删除已知的恶意软件。这些软件不断更新其特征库以适应新的威胁。例如，Symantec Endpoint Protection和McAfee都是业内知名的反病毒软件，它们能够及时检测和清除各种恶意软件。
第三章：沙箱技术的应用 沙箱技术是一种用于隔离和分析未知文件和应用程序的方法。它创建一个受限环境，使文件和应用程序无法访问系统的关键部分。这有助于检测和拦截未知的恶意软件。例如，Cuckoo Sandbox是一个流行的开源沙箱工具，用于自动分析恶意软件样本。
第四章：应用白名单的使用 应用白名单是一种策略，只允许已知和受信任的应用程序在系统上运行。这可以减少潜在的恶意软件攻击，因为只有经过认证的应用程序可以执行。微软的AppLocker和Symantec的Application Control是应用白名单的实现示例。
第五章：综合应对策略 在现实世界中，最佳的恶意软件防范和拦截策略通常包括多层防御。这些层次可以包括反病毒软件、沙箱技术和应用白名单的组合。此外，定期更新操作系统和应用程序、培训员工避免社会工程攻击、网络监控和安全审计也是重要的防御措施。
第六章：结语 恶意软件攻击是一个持续存在的威胁，但通过使用反病毒软件、沙箱技术和应用白名单等策略，我们可以显著减少潜在的风险。然而，不要忘记，恶意软件不断演化，因此我们需要保持警惕，定期更新我们的安全策略，并与安全社区保持联系，以保护我们的系统和数据免受威胁。希望这篇博客可以帮助你更好地了解和应对恶意软件的威胁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7737a0a96851694697763fa2ab8bc5/" rel="bookmark">
			【Qt之QRegExp、QRegularExpression】详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式 正则表达式由表达式、量词和断言构成。最简单的表达式是一个字符，例如 x 或 5。表达式还可以是方括号中的一组字符。[ABCD] 将匹配 A、B、C 或 D。我们可以将这个表达式写成 [A-D]，匹配英文字母表中的任何大写字母的表达式可以写成 [A-Z]。
量词指定必须匹配表达式的出现次数。x{1,1} 表示匹配一个且仅一个 x。x{1,5} 表示匹配一个包含至少一个 x 但不超过五个 x 的字符序列。
请注意，通常情况下，正则表达式不能用于检查平衡的括号或标签。例如，可以编写一个正则表达式来匹配一个开启的 HTML &lt;b&gt; 标签和它的闭合 &lt;/b&gt; 标签，但如果 &lt;b&gt; 标签是嵌套的，同样的正则表达式将匹配错误的开启 &lt;b&gt; 标签和闭合 &lt;/b&gt; 标签。对于 &lt;b&gt;bold &lt;b&gt;bolder&lt;/b&gt;&lt;/b&gt; 这个片段，第一个 &lt;b&gt; 会与第一个 &lt;/b&gt; 匹配，这是不正确的。然而，可以编写一个正则表达式来正确匹配嵌套的括号或标签，但前提是嵌套层级的数量是固定且已知的。如果嵌套层级的数量不是固定且已知的，那么就不可能编写一个不会出错的正则表达式。
假设我们想要一个正则表达式来匹配范围在 0 到 99 的整数。至少需要一个数字，所以我们从表达式 [0-9]{1,1} 开始，它表示精确匹配一个数字。这个正则表达式匹配范围在 0 到 9 的整数。为了匹配范围在 0 到 99 的整数，将最大匹配次数增加到 2，正则表达式变为 [0-9]{1,2}。这个正则表达式满足了最初的要求，即匹配从 0 到 99 的整数，但它也会匹配出现在字符串中间的整数。如果我们希望匹配到的整数恰好是字符串的整个内容，我们必须使用锚定断言，即 ^（脱字符）和 $（美元符号）。当 ^ 是正则表达式的第一个字符时，表示正则表达式必须从字符串开头开始匹配。当 $ 是正则表达式的最后一个字符时，表示正则表达式必须匹配到字符串的结尾。正则表达式变为 ^[0-9]{1,2}$。请注意，断言，例如 ^ 和 $，不匹配字符，而是字符串中的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c7737a0a96851694697763fa2ab8bc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6b4aa79cb0102c6f9f4d9caa5c37438/" rel="bookmark">
			scannet v2 数据集下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		scannet数据集：
一共1513个采集场景数据（每个场景中点云数量都不一样，如果要用到端到端可能需要采样，使每一个场景的点都相同），共21个类别的对象，其中，1201个场景用于训练，312个场景用于测试，有四个评测任务：3D语义分割、3D实例分割、2D语义分割和2D实例分割。
如果去官网下载，要填一个TOS协议，然后发邮件过去，会得到python脚本。
类似下面这样，脚本放在github里保存。
#coding:utf-8 #!/usr/bin/env python # Downloads ScanNet public data release # Run with ./download-scannet.py (or python download-scannet.py on Windows) # -*- coding: utf-8 -*- import argparse import os import urllib.request #(for python3) # import urllib import tempfile BASE_URL = 'http://kaldir.vc.in.tum.de/scannet/' TOS_URL = BASE_URL + 'ScanNet_TOS.pdf' FILETYPES = ['.sens', '.txt', '_vh_clean.ply', '_vh_clean_2.ply', '_vh_clean.segs.json', '_vh_clean_2.0.010000.segs.json', '.aggregation.json', '_vh_clean.aggregation.json', '_vh_clean_2.labels.ply', '_2d-instance.zip', '_2d-instance-filt.zip', '_2d-label.zip', '_2d-label-filt.zip'] FILETYPES_TEST = ['.sens', '.txt', '_vh_clean.ply', '_vh_clean_2.ply'] PREPROCESSED_FRAMES_FILE = ['scannet_frames_25k.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6b4aa79cb0102c6f9f4d9caa5c37438/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d07981188ea41fb5274a6d833390fea/" rel="bookmark">
			6.Python3-基本数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题记 python3基本数据类型
变量赋值 counter = 100 # 整型变量 miles = 1000.0 # 浮点型变量 name = "fql" # 字符串 print (counter) print (miles) print (name) 多个变量赋值 同时为多个变量赋值： a = b = c = 1
为多个对象指定多个变量： a, b, c = 1, 2, "fql" Number（数字） 查询变量的对象类型： a, b, c, d = 20, 5.5, True, 4+3j print(type(a), type(b), type(c), type(d)) isinstance函数： a = 111 b = isinstance(a, int) print(b) type和isinstance的区别： class A: pass class B(A): pass print(isinstance(A(), A)) print(type(A()) == A ) print(isinstance(B(), A)) print(type(B()) == A) true和false：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d07981188ea41fb5274a6d833390fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c06e5bf9250ca5e3f57ece2c55f3531d/" rel="bookmark">
			【码极客精讲】函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机的函数，是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时，还带有一个入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理；所谓出口，就是指函数的函数值，在计算机求得之后，由此口带回给调用它的程序。
如sin(30)=0.5,这里的30就是函数的参数值，它将由入口传给计算机，供计算机处理，而0.5就是函数值，它将由出口返回给调用这个函数的程序。另外，我们数学里的函数是固定的那些，而计算机中的函数，可以根据其运算功能，由我们自己去定义，只要是运算功能是固定的，我们就可以把它定义成一个函数，这样可以避免相同的程序段在程序中重复出现，在需要它时，只需要调用相应的函数就行了。这样不仅可以使我们编写的程序精简，而且可以使我们的程序更富有可读性。
一个较大的程序一般应分为若干个程序块，每一个模块用来实现一个特定的功能。所有的高级语言中都有子程序这个概念，用子程序实现模块的功能。在C语言中，子程序的作用是由一个主函数和若干个函数构成。由主函数调用其他函数，其他函数也可以互相调用。同一个函数可以被一个或多个函数调用任意多次。在程序设计中，常将一些常用的功能模块编写成函数，放在函数库中供公共选用。要善于利用函数，以减少重复编写程序段的工作量。许多程序设计语言中，可以将一段经常需要使用的代码封装起来，在需要使用时可以直接调用，所以，函数也可以说是许多代码的集合，这就是程序中的函数。比如在C语言中：
int　max(int　x,int　y)//整数类型　最大(整数类型　x,整数类型　y) { return　(x&gt;y?x:y);//返回(x&gt;y?x:y) } 就是一段比较两数大小的函数，函数有参数与返回值。C++程序设计中的函数可以分为两类：带参数的函数和不带参数的函数。这两种参数的声明、定义也不一样。
带有（一个）参数的函数的声明：
类型名标示符+函数名+（类型标示符+参数）
{
// 程序代码
}
没有返回值且不带参数的函数的声明：
void+函数名（）//无类型+函数名
{
// 程序代码
}
花括号内为函数体。
如果没有返回值类型名为"void", 整数类型int 类型返回值为整数类型int,以此类推……
类型名有：void int long float int* long* float* ……
C++中函数的调用：函数必须声明后才可以被调用。调用格式为：函数名（实参）
调用时函数名后的小括号中的实参必须和声明函数时的函数括号中的形参个数相同。
有返回值的函数可以进行计算，也可以做为右值进行赋值。
#include　&lt;iostream&gt;//#包含　&lt;iostream.h&gt;文件 using　namespace　std;//使用　命名　空间 int　f1(int　x,int　y)//整数类型　f1(整数类型　x,整数类型　y) { int　z;//整数类型　z return　x+y;//返回　x+y; } void　main()//无类型　主函数() { cout&lt;&lt;f1(50,660)&lt;&lt;endl//输出 } RANK函数 RANK函数是Excel计算序数的主要工具，它的语法为：RANK（number，ref，order），其中number为参与计算的数字或含有数字的单元格，ref是对参与计算的数字单元格区域的绝对引用，order是用来说明排序方式的数字（如果order为零排列，即2、1和3。需要注意的是：相同数值用RANK函数计算得到的序数（名次）相同，但会导致后续数字的序数空缺。假如上例中F2单元格存放的数值与F3相同，则按本法计算出的排名分别是3、3和1（降序时）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c06e5bf9250ca5e3f57ece2c55f3531d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9a5e2ebbb6a282b627007705d18c7b5/" rel="bookmark">
			IT老鸟给开发者升职加薪的小技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 升职加薪对大多数人来说都是工作重要动力所在，但总存在“青出于蓝而胜于蓝”，后来人居上的情况。很多人不清楚，自己兢兢业业，任劳任怨，到头来还是得不到领导的重视，身边一起过来的同事都成为了自己的领导，或者都已经拿到满意的offer，今天来分享下，怎么让自己在工作中能找到升职加薪的“捷径”。
一、国企和民企升职加薪的路线 不管你是在国企还是在民企，相信大家都很想知道，个人哪些能力和行为和升职加薪挂钩。那国企和民企在升职加薪的路线上有什么区别呢？
1、国企：
国企的升职加薪路线主要是以个人的工作能力和职位来决定的。 进入核心部门，接触核心业务，也是升职加薪的关键。 国企的职位晋升一般比较稳定，需要经过一段时间的基层历练才能得到提拔。 2、民企：
民企的升职加薪路线主要是以个人的工作能力和业绩来决定的。 民企的职位晋升相对较快，因为民企的组织结构相对较为灵活，更加注重员工的实际能力和业绩表现。 总的来说，不管在任何企业，个人能力的建设都是非常的重要，那工作能力又包括哪一块呢？工作能力大致分为软能力和硬能力，这两项能力的不同来决定你未来可以走多远。
软能力：包括团结同事、学会和客户、领导沟通，讲究人情世故，学会做向上管理等。
硬能力：包括学历、证书、技术能力、创新能力、解决问题的能力等。
二、提升个人能力的小技巧 个人能力的成长，一般需要花费3-5年左右的时间，甚至10年等更长的时间，那有没有“捷径"可走呢？ 或者说哪些是我们可以提前准备的？
1、人情世故，偷偷学起来 IT行业与其他行业很大的不同表现需要很强的团队协助能力，因为IT项目涉及范围广、耗时长。成功的项目背后必然有一群团结合作的项目成员 ，需求、进度把握精准的项目经理、激励合理分配的伯乐领导等等。因此项目管理背后其实就是人的管理，因此我们在项目中要学会怎么团结同事、为领导分忧，这样你离升职加薪也就不远了。
这些正是我前面提到的软能力的建设，但对应能力的建设，需要在平时的工作和项目中去实践，而且公司刚好在建设期，有重大项目建设需要等，不可控因素较多，因此这些机会出现时，需及时抓住，多多总结领悟。
2、学历、技能认证一个也不能少 学历的重要性相信大家都有目共睹了，但是很多IT开发者，容易陷入一个误区，认为IT行业不需要技能认证，自己有编程能力即可，能解决问题就行。其实大家很有可能错过这一大“捷径”。
当技术能力差不多的两个人，同时申请更好职位时，有华为认证、思科认证、亚马逊认证的，在领导心中加分不止一点点哦。更重要的是国家提倡“以考代评”，技能认证不只是个人能力的体现，更是一种能力的认可。相信很多在国企工作的开发者对此深有感触。这也是为数不多，我们可以好好把握的一条升职加薪的“捷径”。
3、以考代评，软硬兼顾 前面提到技能认证不失为升职加薪的捷径，那具体表现在哪些方面？在近年来各种云、SASS平台的出现，让云应用出现百花争艳的局面，下面以云认证为例，分析下个人技能认证带来的影响。
云认证对IT开发者个人工作能力的影响主要体现在以下几个方面：
3.1提高技术能力：云认证通常涉及多种云服务和技术，通过学习和考试，IT开发者可以提高自己的技术水平，加深对云计算的理解。
3.2增强职业竞争力：拥有云认证可以让IT开发者在职场上更具竞争力，因为许多企业和组织都在寻找具备云技能的开发者。
3.3扩展职业发展机会：云认证可以让IT开发者接触到更多的技术领域和职业发展机会，例如云计算架构师、云安全专家等。
3.4提高工作效率：通过云认证，IT开发者可以更有效地管理和优化云资源，提高工作效率。 3.5降低企业成本：通过云认证的IT开发者可以更好地为企业规划和管理云资源，从而降低企业的IT成本。
三、个人总结 前面我们提到升职加薪，一个很重要的方面是提升个人的软实力和硬技能。因此这两个是决定能走多远的重要因素，也是我们升职加薪的底层逻辑。为了方便大家了解，建议大家参考——点击查看《2023开发者职场生存白皮书》，解锁升职加薪的财富密码，祝你走向人生巅峰，感兴趣的小伙伴们已经偷偷收藏看起来了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40a1a5423fc6ea3872bdba29009db1e3/" rel="bookmark">
			vue2.x 引入Jessibuca直播流播放器问题与解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行Jessibuca demo检测现有的视频流是否可以正常播放【视频流无问题，则此步忽略】 demo地址：GitHub - bosscheng/jessibuca-demo: Jessibuca demo常规步骤：npm install、npm run serve，然后报错如下，并参见Error: @vitejs/plugin-vue requires vue (＞=3.2.13) or @vue/compiler-sfc to be present in the dependen-CSDN博客Jessibuca在vue项目里的使用 参见vue-＞jessibuca播放器使用_jessibuca vue_黛玉葬花也葬你的博客-CSDN博客问题： vue2没有public文件夹 选择将文中所述三个文件放在static/jessibuca下，并在index.html中引入jessibuca.js其中三个文件也替换为最新代码中文件DEMO | Jessibuca
运行问题1：只能播放1-2s就停止播放 尝试切换MediaSource为webcodecs运行问题2：Uncaught SyntaxError: Unexpected token ＜，解决： 确认index.html路径为./static/jessibuca/jessibuca.js更改jessibuca.js中decoder的路径为：./static/jessibuca/decoder.js 解决思路参见记一次Uncaught SyntaxError: Unexpected token ＜错误_jessibuca.js:1 uncaught syntaxerror: unexpected to_nbwgl的博客-CSDN博客 至此解决
本来懒得动手写东西，以此谢谢群里提供意见、还不愿意收个奶茶钱的、素未谋面的小伙伴~~~
---------------------------------------------------------------------------------------------------------------------------------
后来发现这个地方有提及的，只是自己没仔细看文档。。Document (常见问题) | Jessibuca
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bbf39c81c85f54e18c4f2c870e65dab/" rel="bookmark">
			自定义QChartView实现鼠标放在图表时，显示鼠标位置坐标值(x,y)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：因为需要一次性从文件中加载大量数据到图表中显示，所以打算使用qchartview+qscrollarea，当横坐标数据超出默认设定的显示范围之后，重新设置chartview的宽度和scrollarea内容区域(scrollAreaWidgetContents)的宽度，从而实现一次性显示所有数据的目的。因为这样显示之后，如果滚动条向右边拖动时，图表的纵坐标会看不到，为了能够方便的显示纵坐标上的值，于是想到在鼠标放在图表时，通过一个标签显示鼠标所在位置的坐标。
一、自定义QChartView，实现鼠标移动事件，获取坐标值。
项目代码根目录添加c++头文件和源文件，切记根目录，不要在子目录。
showvaluechartview.h
#ifndef SHOWVALUECHARTVIEW_H #define SHOWVALUECHARTVIEW_H #include &lt;QChartView&gt; class ShowValueChartView: public QChartView { Q_OBJECT public: explicit ShowValueChartView(QWidget *parent = Q_NULLPTR); protected: void mouseMoveEvent(QMouseEvent *e); public: signals: /** 鼠标在图表位置的数据改变时触发 **/ void onMousePositionValueChanged(QPointF valueGivenSeries); }; #endif // SHOWVALUECHARTVIEW_H showvaluechartview.cpp
#include "showvaluechartview.h" ShowValueChartView::ShowValueChartView(QWidget *parent) : QChartView(parent) { setMouseTracking(true); } void ShowValueChartView::mouseMoveEvent(QMouseEvent *e) { auto const widgetPos = e-&gt;position(); auto const scenePos = this-&gt;chart()-&gt;mapToScene(QPoint(static_cast&lt;int&gt;(widgetPos.x()), static_cast&lt;int&gt;(widgetPos.y()))); auto const chartItemPos = chart()-&gt;mapFromScene(scenePos); auto const valueGivenSeries = chart()-&gt;mapToValue(chartItemPos); // qDebug() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bbf39c81c85f54e18c4f2c870e65dab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/014f1c9e8ed17180f6270d342e68b1bb/" rel="bookmark">
			Babylonjs学习笔记(七)——相机行为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 书接上回，这里学习ArcRotateCamera的三种相机行为！！！
一、相机Bouncing(弹跳)行为 // 当距离 小于lowerRadiusLimit 或者大于upperRadiusLimit的值时，会恢复原状 camera.useBouncingBehavior = true; 二、相机AutoRotation(自动旋转)行为 // 相机默认旋转的行为 如果有行为阻止了该行为，大约1.5秒后继续转动 camera.useAutoRotationBehavior = true; // 相机转动的速度 camera!.autoRotationBehavior!.idleRotationSpeed = .5 // 旋转至全怠速所需的时间 camera!.autoRotationBehavior!.idleRotationSpinupTime = 1000 // 用户交互到开始旋转之间的等待时间 camera.autoRotationBehavior!.idleRotationWaitTime = 2000; // 缩放停止相机旋转动画 camera.autoRotationBehavior!.zoomStopsAnimation = true 三、相机Framing行为 // 相机框架行为 和 camera.setTarget 连用 camera.useFramingBehavior =true; // 聚焦半径 camera.framingBehavior!.radiusScale = 10 // 聚焦时间 camera.framingBehavior!.framingTime = 4 *1000; // 显示网格框架 ball.showBoundingBox = true // 相机聚焦到网格 camera.setTarget(ball) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699b788c79473a7addc19ab246ab861f/" rel="bookmark">
			css比较万能的定位居中方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 div { width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); /* 50%为自身尺寸的一半 */ } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3eab3450331d04ad5969f5469324b3da/" rel="bookmark">
			前端实现：图片添加水印JS&#43;Canvas（简易版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片加水印是一种常见的图像处理技术，通常用于保护版权、防止盗用、增加图片的识别度等多种场景。例如：证件照片加水印、个人照片加水印、网站图片保护等等。
处理思路：1.在HTML文件中创建一个canvas元素，并设置其宽度和高度；
2.在JavaScript文件中获取canvas对象，并读取需要加水印的图片；
3.在图片加载完成后，将其绘制到canvas上；
4.在canvas上绘制水印；
5.将canvas上的内容转换为图片，并替换原始的图片；
注意：并未直接针对原图片做处理！！！
1.第一步：在 HTML 文件中创建一个 canvas 元素，并设置其宽度和高度。
&lt;!-- HTML --&gt; //width height 对应原图片的宽高 &lt;canvas id="myCanvas" class="canvas" width="800" height="600"&gt;&lt;/canvas&gt; 2.第二步：在 JavaScript 文件中获取 canvas 元素，并读取需要加水印的图片。
const canvas = document.getElementById('myCanvas'); const ctx = canvas.getContext('2d'); // 加载需要加水印的图片 function loadImage() { const img = new Image(); img.onload = function() { drawImageWithWatermark(img); }; img.src = 'pic.webp'; } 3.第三步：在图片加载完成后，将其绘制到 canvas 上。
// 在 canvas 上绘制原始图片 function drawImage(image) { ctx.drawImage(image, 0, 0); } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3eab3450331d04ad5969f5469324b3da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a50b13a81c9d6531469209c10ab36df1/" rel="bookmark">
			变量的作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在javascript中，var定义的变量实际是有作用域的。
1 假设在函数体内声明，但在函数体外不可以使用
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function qj(){ var x = 1; x = x+1; } x = x+2; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 浏览器翻译如下：
发现在函数内定义的变量在函数外不能够不引用。所以报错说改变量未定义。
2 函数内和函数外的变量相同时，就近原则，取函数内的
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function qj(){ var x = 1; function qj2(){ var x = 'A'; console.log('inner'+'x') } console.log('outer'+x) qj2() } qj() &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 浏览器翻译如下：
规范：
由于所有的全局变量都会绑定到windows上，如果不同的js文件，使用了相同的全局变量，就会有冲突。 解决方案：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a50b13a81c9d6531469209c10ab36df1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6861a1431deb6beaafd473e6662a23/" rel="bookmark">
			Win10历史剪贴板 Win&#43;V无法打开问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接CMD命令：“taskkill /f /im explorer.exe &amp; start explorer.exe”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fe075219e94c48a942bc656b8c8ad6d/" rel="bookmark">
			spring boot导入导出excel,集成EasyExcel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; 二、新建导出工具类
package com.example.springbootclickhouse.utils; import javax.servlet.http.HttpServletResponse; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; public class ExcelReponseTools { //设置导出样式 public static void setExcelResponseProp(HttpServletResponse response, String rawFileName) throws UnsupportedEncodingException { response.setContentType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"); response.setCharacterEncoding("utf-8"); String fileName = URLEncoder.encode(rawFileName, "UTF-8"); response.setHeader("Content-disposition", "attachment;filename*=utf-8''" + fileName + ".xlsx"); } } 三、新建实体类
package com.example.springbootclickhouse.Excel; import com.alibaba.excel.annotation.ExcelProperty; import com.alibaba.excel.annotation.write.style.ColumnWidth; import com.example.springbootclickhouse.ExcelValidTools.ExcelValid; import com.example.springbootclickhouse.ExcelValidTools.NumberValid; import com.example.springbootclickhouse.utils.GenderConverter; import lombok.*; import java.io.Serializable; import java.time.LocalDateTime; @Data @AllArgsConstructor @NoArgsConstructor public class StudentExcel implements Serializable { private static final long serialVersionUID = 1L; @ExcelProperty("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fe075219e94c48a942bc656b8c8ad6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/794b55757ddf4887d5127409d5d42eba/" rel="bookmark">
			DC-1靶场
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DC-1 下载地址
DC and Five86 Series Challenges - Downloadshttps://www.five86.com/downloads.html解压打开虚拟机
使用kali中的namp扫描发现对方端口及ip
map -sT 192.168.10.0/24 扫描发现开启了常见的端口及目标IP地址，直接浏览器 访问，查看能不能找到相关的信息，在页面上看到关键 词Drupal，和Drupalcms很类似。
我们可以使用kali详细扫描，或者使用目录扫描发现一 些蛛丝马迹
nmap -sT -A -p- -T5 192.168.10.24 -sT：这表示使用TCP扫描。 -A：这表示启用所有nmap的自动化检测服务，如操作系统检测，端口服务识别等。 -p-：这表示扫描所有可能的端口，从1到65535。 -T5：这表示将nmap的默认警报级别设置为5，这通常是相对较低的警报级别，会使扫描更加安静。 发现该项目遵循robots协议，直接浏览器访问：192.168.10.24/robots.txt
利用MSF框架，找到robots协议及关于Drupal漏洞模块可以利用的
┌──(root㉿kali)-[~]└─# msfdb init # 初始化 ┌──(root㉿kali)-[~] └─# systemctl start postgresql #开启数据库服务 ┌──(root㉿kali)-[~] └─# msfconsole #开机 MSF msf6 &gt; search drupal #搜索漏洞模块 f6 &gt; use 1 [*] No payload configured, defaulting to php/meterpreter/reverse_tcp msf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; msf6 exploit(unix/webapp/drupal_drupalgeddon2) &gt; set rhosts 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/794b55757ddf4887d5127409d5d42eba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cadbfc46e80dbaf54f3d39004533c06/" rel="bookmark">
			DC-2靶场
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DC-2 下载地址：DC and Five86 Series Challenges - Downloadshttps://www.five86.com/downloads.html
DC-2环境配置：
解压打开虚拟机
网络改成nat
1、使用kali中的namp扫描发现对方端口及ip
nmap -sT 192.168.10.0/24
尝试直接访问 发现目标主机ip无法访问 显示网站不存在
2、通过更改windows下的host文件
c:\windows\System32\drivers\etc\hosts修改如下 192.168.10.25 dc-2 DC-2的地址 浏览器访问dc-2 显示成功
发现该系统使用 wordpress开发的项目： 点击flag我们可以查看flag1，提醒我们使用字典爆破
一般来说wp的默认登录界面是wp-login.php，我们在浏览器地址栏进行尝试
根据提示，使用WPScan扫描一下用户
wpscan --url http://dc-2/ -e u,其中-e表示枚举，u表示要扫描的目标：用户名 分析了一下flag，这段话的意思是需要用cewl来爬去网站的内容，制作社工字典来对wordpress账号进行暴破。联系到之前用跑出来的账号名 登陆后台
可以看到有以上这些用户，将看到的用户写入一个自己创的文件
根据flag1提示来生成字典
cewl http://dc-2 -w passwd.txt 使用WPScan进行爆破
wpscan --url http://dc-2/ -U pass.txt -P passwd.txt
使用账号密码登录:发现flag2
flag2提示寻找另外一个切入点;从刚才的扫描可以得知，该网站除了开放了80端口外，还开放了一个7744的ssh端口 这里我们使用hydra和刚刚已生成的密码字典，对已知的用户名进行ssh登录密码的爆破
可以看到爆破的用户名和密码，我们使用tom进行ssh登录
使用cat命令查看，发现无法使用，那么我们使用echo $PATH查看当前路径，再使用ls usr/bin查看目录结构，发现我们 可以使用less ls scp vi这几个命令
使用vi打开flag3.txt文件，这里提示我们使用su来切换到jerry来找到进一步的线索
su jerry也不行 现在需要想办法使用切换用户的命令。调用/bin/sh命令解释器，输入BASH_CMDS[a]=/bin/sh，然后切换环境变量，输入export PATH=PATH:/bash，然后在输入cat flag3.txt，我们可以看到已经可以使用该命令了
su jerry 输入jerry爆破的密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cadbfc46e80dbaf54f3d39004533c06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c029c256b2a042df6ee819960a4dd1b3/" rel="bookmark">
			(五)库存超卖案例实战——使用zookeeper分布式锁解决“超卖”问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本节内容使用zookeeper实现分布式锁，完成并发访问“超卖”问题的解决。相对于redis分布式锁，zookeeper能够保证足够的安全性。关于zookeeper的安装内容这里不做介绍，开始本节内容之前先自行安装好zookeeper中间键服务。这里我们利用创建zookeeper路径节点的唯一性实现分布式锁。并同时演示如何使用Curator工具包，完成分布式锁。
正文 在项目中添加zookeeper的pom依赖 &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.7.2&lt;/version&gt; &lt;/dependency&gt; 创建zookeeper客户端工具，实现加锁和解锁方法 - 创建ZookeeperClient客户端工具
package com.ht.atp.plat.util; import org.apache.zookeeper.CreateMode; import org.apache.zookeeper.KeeperException; import org.apache.zookeeper.ZooDefs; import org.apache.zookeeper.ZooKeeper; import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; @Component public class ZookeeperClient { /** * zookeeper连接地址 */ private static final String connectString = "192.168.110.88:2181"; /** * 分布式锁根路径 */ private static final String ROOT_PATH = "/distributed"; /** * zookeeper客户端 */ private ZooKeeper zooKeeper; /** * 初始化zookeeper客户端 */ @PostConstruct public void init() { try { // 连接zookeeper服务器 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c029c256b2a042df6ee819960a4dd1b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbdd2557acac0ad731c90ff2fe02fbb9/" rel="bookmark">
			基于Taro &#43; React 实现微信小程序半圆滑块组件、半圆进度条、弧形进度条、半圆滑行轨道（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果： 功能点： 1、四个档位
2、可点击加减切换档位
3、可以点击区域切换档位
4、可以滑动切换档位
目的： 给大家提供一些实现思路，找了一圈，一些文章基本不能直接用，错漏百出，代码还藏着掖着，希望可以帮到大家
代码 ts的写法风格
index.tsx import { View, ITouchEvent, BaseTouchEvent } from '@tarojs/components' import Taro from '@tarojs/taro' import { useState } from 'react' import styles from './index.module.less' import classNames from 'classnames' import { debounce } from '~/utils/util' enum ANGLES { ANGLES_135 = -135, ANGLES_90 = -90, ANGLES_45 = -45, ANGLES_0 = 0 } enum MODE_VALUE { MODE_1 = 1, MODE_2 = 2, MODE_3 = 3, MODE_4 = 4 } const HalfCircle = () =&gt; { const [state, setState] = useState({ originAngle: ANGLES.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbdd2557acac0ad731c90ff2fe02fbb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9947c737fe1dd3357986709dee436e4/" rel="bookmark">
			华为手机屏幕坏了无法使用怎么备份资料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近用水龙头洗了一下华为手机，接过进水把屏幕排线烧了，无法使用，但是有资料急着需要拷贝出来，故而尝试手机外接电脑显示器完成该项任务。步骤如下：
1.准备工具。
a.准备一个电脑显示器。
b.一个鼠标。
c.一个键盘。
d.一个Type-C接口的电脑拓展坞。
2.设备接线流程。
1）将鼠标，键盘通过USB接口接入拓展坞。
2) 将显示器通过高清线接入拓展坞，与此同时显示器插入外接电源。
3）将拓展坞接到手机的Type-C接口。
3.操作流程
1）先按一下Num Look 按键。
2）接着按一下Space按键。
3）再接着输入手机密码。
4）再接着按一次Space按键。
4）再接着连续按两次Tab按键。
5）最后按Enter键。
不出所料的话，您当前电脑显示器已经成功显示手机的屏幕，利用鼠标就能对手机进行操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ab1c0936042844f1d8560fd6ebcba6f/" rel="bookmark">
			redis 集群配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 . 存在的问题 单台redis容量限制，如何进行扩容？继续加内存、加硬件么？单台redis并发写量太大有性能瓶颈，如何解决？redis3.0中提供了集群可以解决这些问题。 2 . 什么是集群 redis集群是对redis的水平扩容，即启动N个redis节点，将整个数据分布存储在这个N个节点中，每个节 点存储总数据的1/N。
如下图：由3台master和3台slave组成的redis集群，每台master承接客户端三分之一请求和写入的数
据，当master挂掉后，slave会自动替代master，做到高可用。
3 . 集群如何配置？ 3.1 需求： 配置3主3从集群 下面我们来配置一个3主3从的集群，每个主下面挂一个slave，master挂掉后，slave会被提升为 master。
为了方便，我们在一台机器上进行模拟，我的机器ip是：192.168.200.129，通过端口来区分6个不同的 节点，配置信息如下
3.2 创建案例工作目录：cluster 执行下面命令创建 /opt/cluster 目录，本次所有操作，均在 cluster 目录进行。
# 方便演示，停止所有的redis ps -ef | grep redis | awk -F" " '{print $2;}' | xargs kill -9 mkdir /opt/cluster cd /opt/cluster/ 3.3 将redis.conf复制到cluster目录 redis.conf 是redis默认配置文件
cp /opt/redis-6.2.1/redis.conf /opt/cluster/ 3.4 创建master1的配置文件：redis-6379.conf 在/opt/cluster目录创建 redis-6379.conf 文件，内容如下，注192.168.200.129 是这个测试机器的 ip，大家需要替换为自己的
include /opt/cluster/redis.conf daemonize yes bind 192.168.200.129 dir /opt/cluster/ port 6379 dbfilename dump_6379.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ab1c0936042844f1d8560fd6ebcba6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c88e3bb3ebbc39d760d345f6d6c188f6/" rel="bookmark">
			redis知识点整理（自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、常见问题
1、Redis的数据持久化策略有哪些
2、什么是缓存穿透，怎么解决
3、什么是布隆过滤器
4、什么是缓存击穿，怎么解决
5、什么是缓存雪崩，怎么解决
6、redis双写问题
7、Redis分布式锁如何实现
8、Redis实现分布式锁如何合理的控制锁的有效时长
9、Redis的数据过期策略有哪些
10、Redis的数据淘汰策略有哪些
二、其他问题
1、Redis集群有哪些方案,知道嘛
2、什么是Redis主从同步
3、你们使用Redis是单点还是集群?哪种集群
4、Redis分片集群中数据是怎么存储和读取的
5、redis集群脑裂
6、怎么保证redis的高并发高可用
7、你们用过Redis的事务吗?事务的命令有哪些
8、Redis是单线程的，但是为什么还那么快?
一、常见问题 1、Redis的数据持久化策略有哪些 rdb和aof两种方式。
1）其中rdb为数据快照，将内存中的数据拷贝到磁盘中（存为快照文件），通过save或bgsave命令触发rdb存储。当故障重启后，通过读取快照文件，快速恢复数据存储。
2）aof存储方式为追加文件存储，文件中记录redis写命令。
配置文件触发策略：apendfsync always / apendfsync everysec （将写命令存储到aof缓冲区，每隔一秒将缓冲区的数据存储到文件中，因此可能会缺失一秒数据）/ apendfsync no
aof重写机制：aof记录的是操作命令，会存在很多冗余命令，可以通过bgrewriteaof命令，删除冗余命令，从而压缩aof的文件
两种方式优缺点对比：
rdb恢复数据速度快、但存储时间间隔较长，存在缺失数据的情况。
aof宕机恢复速度慢，但数据完整性较高。文件体积会比较大。
默认配置是开启rdb，关闭aof。实际应用场景中，往往两者结合使用，rdb周期性的定点备份数据。
【精选】Redis持久化的两种方式：RDB与AOF（详解）_rdb和aof_PeakXYH的博客-CSDN博客
2、什么是缓存穿透，怎么解决 请求查询缓存和数据库都不存在的数据，使db压力瞬间变大。
解决方案：
1）接口过滤，过滤掉例如id=-122等无效访问，以及加上权限过滤的方式等
2）对请求空值的数据进行缓存，例如请求不存在的id=43的数据，则在redis中缓存该条数据（值为空值），但需要注意：key设置的过期时间不能太长
3）布隆过滤器
3、什么是布隆过滤器 通过一组hash函数，将查询的入参散列到列表的不同地址，若列表地址的值均为1，则表示入参存在。通过布隆过滤器校验后，允许查询缓存、数据库。
4、什么是缓存击穿，怎么解决 某条数据在redis中过期，正好大量用户访问该热点数据，导致db压力变大（类似缓存雪崩？）
互斥锁：setnx 解决方案：
1）设置互斥锁，缓存过期后，线程一查询时获取锁，查询到数据后重新设置缓存，再释放锁。其他线程在锁住状态时，则循环休眠重试从redis获取数据。
2）逻辑设置缓存的过期时间。线程一进来后发现缓存已过期，获取互斥锁，锁获取成功，则开启新线程更新缓存，线程一则直接先返回过期数据。其他线程进入，查询缓存已过期且获取互斥锁失败，也直接返回过期数据。
Redis缓存击穿问题及解决思路_缓存击穿怎么解决-CSDN博客
5、什么是缓存雪崩，怎么解决 大量缓存在同一时间失效，大量用户请求进来，瞬间耗尽数据库资源，导致数据库无法使用。
解决方案：
缓存的有效期设置随机值，避免同一时间失效
6、redis双写问题 线程一删除redis中数据；线程二此时查询数据绕过缓存直接查询数据库，又将数据存在了缓存中。
1） 延迟双删：保持最终一致性，非强一致性。延迟时间不好确定
2）强一致性的解决方案：
加分布式锁，通过redisson提供的读写锁，readlock（共享锁）读数据，writelock（排它锁）写数据。
3）延迟一致性的解决方案：
a、通过异步消息通知实现。发送更新缓存的通知到mq，mq执行更新缓存的操作。
b、通过canal监听mysql数据库的binlog日志，canal通知数据变更，业务服务更新数据。
7、Redis分布式锁如何实现 基于redisson通过实现设置锁，底层原理是用setnx+lua。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c88e3bb3ebbc39d760d345f6d6c188f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb944ad15b2f0e649e9d3e7fb09f8ca/" rel="bookmark">
			Dubbo项目consumer无法启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误原因如下：
1.
注册中心中
dubbo：register（消费者）
dubbo：service（提供者）两个配置的暴露地址要一致
2.提供者和消费者的配置都是从superdiamonds 中拉下来的，因为superdiamonds中要配置两个项目的配置信息
3.消费者中pom文件要配置一下jar包，将提供者的Facade层引入项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d963559bae49e9f00f37d21c1bfa38ab/" rel="bookmark">
			电池内阻仪原理分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 整理电脑看到一个名为“内阻仪”的文档，打开看了一下，记录一下；
前置知识 测内阻就是测电阻，核心原理：R=U/I；
U：这里面是交流激励信号；
I：这里是恒流激励
电路与原理 总结 上述只是定性分析了原理，实际做成电路调试要根据具体参数。
哪里有部队的地方欢迎留言指出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6951732c9b33f0127fcd8815e41dd713/" rel="bookmark">
			获取当前时间（String形式）一行代码搞定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有的公司，存储数据库的时间格式不是datetime而是直接用的varchar，这样方便取的时候避免时间转换，但是如果要存当前时间，一般都是至少三行搞定。
// 创建日期对象 Date now = new Date(); // 创建日期格式化对象 SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); // 格式化日期对象为字符串 String currentTime = format.format(now); // 输出当前时间字符串 System.out.println("当前时间：" + currentTime); 然后，为了减少代码量（秉着能少写就少写的原则，一行代码就行）
package Lx; import java.time.LocalDateTime; import java.time.format.DateTimeFormatter; public class TimeString { public static void main(String[] args) { String currentTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")); System.out.println("当前时间：" + currentTime); } } 打印结果：
这行代码使用LocalDateTime.now()获取当前时间，并使用DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")指定日期格式。然后通过format()方法将LocalDateTime对象转换为字符串表示。输出的结果将是格式为"yyyy-MM-dd HH:mm:ss"的当前时间字符串，例如：“2023-11-01 10:07:38”。你可以根据需要修改日期格式的模式。
A
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b838bb3ad5592f9faab5f1c16ba979/" rel="bookmark">
			Vue.js WebSocket 整合指南：实时通信的完美解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 WebSocket是一种在Web应用程序中实现双向通信的通信协议，它允许客户端和服务器之间建立持久的、低延迟的连接，以实现实时数据传输。相比传统的HTTP请求，WebSocket更适合需要实时性和交互性的应用程序。
为什么需要WebSocket？ WebSocket解决了传统HTTP请求的一些限制，例如：
实时性: 传统HTTP请求需要客户端定期轮询服务器以获取新数据，而WebSocket允许服务器主动推送数据给客户端，实现实时更新。双向通信: WebSocket支持双向通信，客户端和服务器都可以发送消息，而不是仅限于客户端向服务器发送请求。低延迟: WebSocket连接保持开放，减少了连接和断开的开销，从而实现更低的通信延迟。 Vue.js中的WebSocket连接 Vue.js是一种流行的JavaScript框架，它使得构建现代Web应用程序变得更加容易。在Vue.js中实现WebSocket连接可以轻松地将实时通信功能集成到应用程序中。
websocket常用事件 setupWebSocket(): 用于创建WebSocket连接，配置WebSocket对象，并定义连接的事件处理函数。closeWebSocket(): 用于关闭WebSocket连接。onWebSocketOpen(): WebSocket连接成功时的事件处理函数。onWebSocketMessage(event): 处理接收到的WebSocket消息。onWebSocketClose(): 处理WebSocket连接关闭事件。sendMessage(message): 用于发送消息到WebSocket服务器。startHeartbeat(): 启动心跳检测。stopHeartbeat(): 停止心跳检测。 WebSocket连接配置 首先，我们需要创建一个Vue.js组件，负责WebSocket连接的创建和管理。在组件的data属性中，我们定义了WebSocket对象
&lt;template&gt; &lt;div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { websocket: null, // WebSocket对象 }; }, created() { this.setupWebSocket(); // 创建WebSocket连接 }, beforeDestroy() { this.closeWebSocket(); // 在组件销毁前关闭WebSocket连接 }, methods: { setupWebSocket() { this.websocket = new WebSocket("ws链接"); // 创建WebSocket连接 this.websocket.onopen = this.onWebSocketOpen; // WebSocket连接打开时的处理函数 this.websocket.onmessage = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b838bb3ad5592f9faab5f1c16ba979/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c96118a0bc90d965e032510455f2fb/" rel="bookmark">
			C&#43;&#43;经典面试题100例及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.面向对象的程序设计思想是什么? 答：把数据结构和对数据结构进行操作的方法封装形成一个个的对象。
2.什么是类? 答：把一些具有共性的对象归类后形成一个集合，也就是所谓的类。
3.对象都具有的两方面特征是什么?分别是什么含义? 答：对象都具有的特征是：静态特征和动态特征。
静态特征是指能描述对象的一些属性（成员变量）动态特征是指对象表现出来的行为（成员函数） 4.在头文件中进行类的声明，在对应的实现文件中进行类的定义有什么意义? 答：这样可以提高编译效率，因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大的提高了编译效率。
5. 在类的内部定义成员函数的函数体，这种函数会具备那种属性? 答：这种函数会自动为内联函数，这种函数在函数调用的地方在编译阶段都会进行代码替换。
6. 成员函数通过什么来区分不同对象的成员数据?为什么它能够区分? 答：通过this指针指向对象的首地址来区分的。
7. C++编译器自动为类产生的四个缺省函数是什么? 答：默认构造函数，拷贝构造函数，析构函数，赋值函数。
8. 拷贝构造函数在哪几种情况下会被调用? 1.当类的一个对象去初始化该类的另一个对象时；
2.如果函数的形参是类的对象，调用函数进行形参和实参结合时；
3.如果函数的返回值是类对象，函数调用完成返回时。
9. 构造函数与普通函数相比在形式上有什么不同?（构造函数的作用，它的声明形式来分析） 答：构造函数是类的一种特殊成员函数，一般情况下，它是专门用来初始化对象成员变量的。
构造函数的名字必须与类名相同，它不具有任何类型，不返回任何值。
10. 什么时候必须重写拷贝构造函数? 答：当构造函数涉及到动态存储分配空间时，要自己写拷贝构造函数，并且要深拷贝。
11. 构造函数的调用顺序是什么? 1.先调用基类构造函数
2.按声明顺序初始化数据成员
3.最后调用自己的构造函数。
12. 哪几种情况必须用到初始化成员列表? 答：
1.类的成员是常量成员初始化；
2.类的成员是对象成员初始化，而该对象没有无参构造函数。
3.类的成员为引用时。
13. 什么是常对象? 答：常对象是指在任何场合都不能对其成员的值进行修改的对象。
14. 静态函数存在的意义? 答：静态私有成员在类外不能被访问，可通过类的静态成员函数来访问；
当类的构造函数是私有的时，不像普通类那样实例化自己，只能通过静态成员函数来调用构造函数。
15. 在类外有什么办法可以访问类的非公有成员? 答：友元，继承，公有成员函数。
16. 什么叫抽象类? 不用来定义对象只作为一种基本类型用作继承的类 17. 运算符重载的意义? 答：为了对用户自定义数据类型的数据的操作与内定义的数据类型的数据的操作形式一致。
18. 不允许重载的5个运算符是哪些? 1. .*（成员指针访问运算符号）
2. ：：域运算符
3. Sizeof 长度运算符号
4. ?：条件运算符号
5. .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c96118a0bc90d965e032510455f2fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f854fb7378e3434e6d1bd1e5f86d5bf/" rel="bookmark">
			从小白到大牛：Linux嵌入式系统开发的完整指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux嵌入式系统开发一直是一个激动人心的领域，吸引着越来越多的开发者。无论你是初学者还是已经有一些经验的开发者，本文将为你提供从小白到大牛的完整指南，帮助你掌握Linux嵌入式系统开发的关键概念和技能。我们将深入探讨Linux内核、设备驱动、交叉编译、根文件系统、应用程序开发等方面，并提供实际代码示例。
第一部分：入门Linux嵌入式系统开发 在这一部分，我们将从头开始，介绍Linux嵌入式系统开发的基本概念和工具。这是对初学者的友好入门，也是已经有一些经验的开发者的复习。
1.1 什么是嵌入式系统？ 嵌入式系统是一种特殊类型的计算机系统，通常用于控制、监视或执行特定任务。它们通常嵌入在其他设备中，如智能手机、汽车、家用电器等。
1.2 为什么选择Linux？ Linux是一个强大的开源操作系统内核，广泛用于嵌入式系统开发。它具有稳定性、可靠性和可定制性，而且有一个庞大的社区支持。
1.3 准备开发环境 安装Linux发行版配置交叉编译工具链 1.4 编写你的第一个Linux应用程序 以下是一个简单的"Hello World"应用程序示例：
#include &lt;stdio.h&gt; int main() { printf("Hello, World!\n"); return 0; } 1.5 编译和运行应用程序 使用交叉编译工具链来编译应用程序，并将其部署到嵌入式系统上。
第二部分：深入Linux内核和设备驱动开发 在这一部分，我们将深入研究Linux内核和设备驱动开发的核心概念。这将帮助你更好地理解和控制嵌入式系统。
2.1 Linux内核基础 内核组成内核模块 2.2 设备驱动基础 设备和驱动程序的概念设备树字符设备驱动示例 #include &lt;linux/init.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/fs.h&gt; static int mydriver_open(struct inode *inode, struct file *file) { printk("My driver opened\n"); return 0; } static int mydriver_release(struct inode *inode, struct file *file) { printk("My driver closed\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f854fb7378e3434e6d1bd1e5f86d5bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9724c6746cff7eb54d416b5f95573a30/" rel="bookmark">
			Carla 轨迹点生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人备份用
import carla import xmltodict def get_vehicle_transforms(vehicle, distance=1.0, num_points=10): trajectory_points = [] for i in range(num_points): location = vehicle.get_location() transform = vehicle.get_transform() forward_vector = transform.rotation.get_forward_vector() # 计算下一个点的位置 next_point = location + distance * (i + 1) / num_points * forward_vector # 获取yaw角度 yaw = transform.rotation.yaw trajectory_points.append((next_point.x, next_point.y, next_point.z, yaw)) return trajectory_points def save_trajectory_to_xml(trajectory_points, xml_filename): data = {'trajectory': {'point': []}} for point in trajectory_points: x, y, z, yaw = point data['trajectory']['point'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9724c6746cff7eb54d416b5f95573a30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d157005696e8ac24dde0d2427e2d9d8/" rel="bookmark">
			GhostNet（CVPR 2020）学习笔记 （附代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址：​​​​​​https://arxiv.org/abs/1911.11907v2
代码地址：https://github.com/huawei-noah/Efficient-AI-Backbones/blob/master/ghostnet_pytorch/ghostnet.py
1.是什么？ Ghost module是一种模型压缩的方法，它可以在保证网络精度的同时减少网络参数和计算量，从而提升计算速度和降低延时。Ghost模块可以代替现有卷积网络中的每一个卷积层。Ghost module的核心思想是将一个卷积层分解成两个较小的卷积层，其中一个卷积层被称为ghost卷积层，它只使用原始卷积层的一小部分通道来计算输出，而另一个卷积层则被称为剩余卷积层，它使用剩余的通道来计算输出。这种分解方式可以大大减少计算量和参数数量，同时保持网络的精度。Ghost module已经被应用于GhostNet等网络架构中，并取得了出色的表现。
2.为什么？ 由于硬件资源以及计算量的限制，在嵌入式设备当中部署卷积神经网络是很困难的。想要解决这个问题，就要想方设法的使网络模型更加的轻量化。现存的网络模型轻量化方法一般有两种：模型压缩和轻量化网络设计。
模型压缩：
pruning connection: 减去一些不重要的神经元连接；
channel pruning: 通道剪枝，减去一些无用的通道，以便加速运算；
model quantization: 模型量化，在具有离散值的神经网络中对权重或激活函数进行压缩和计算加速；
tensor decomposition: 张量分解，通过权重的冗余性和low-link来减少参数或计算；
knowledge distillation: 知识蒸馏， 利用大模型来教小模型，提高小模型的性能
轻量化网络设计：
Xception: depthwise conv operation
MobileNet 系列： 深度可分离卷积 depthwise separable conv、inverted resdual block、AutoML technology
ShuffleNet 系列: channel shuffle operation
尽管这些模型获得了良好的性能，但是feature map之间的相关性和冗余性一直没有得到很好的利用。
那么什么是feature map之间的相关性和冗余性呢？
作者在实验过程中将ResNet50的第一个残差组的feature map进行可视化，发现里面有三对feature map（如下图中的红绿蓝三对feature map）它们极其相似，作者认为这些feature map对之间是冗余的（相关的）。
每张图代表一个通道，图中三组颜色相连的图非常相似。论文将一组中的一张图称为本征图（intrinsic），其他和本征图相似的图称为本征图的魅影（ghost）。那么，既然ghost和Intrinsic非常相似，我们是否可以通过一种相对简单的、计算量较少的运算代替运算量大的卷积操作生成ghost图？ghost模块就是基于这种想法，提出用简单的线性运算生成ghost，但总共的通道数（# intrinsic+ghost）以及生成特征图的大小和原来保持一致。
作者考虑到这些feature map层中的冗余信息可能是一个成功模型的重要组成部分，正是因为这些冗余信息才能保证输入数据的全面理解，所以作者在设计轻量化模型的时候并没有试图去除这些冗余feature map，而是尝试使用更低成本的计算量来获取这些冗余feature map。
作者生动的将这些冗余的feature map称为 Ghost（幽灵） 。
3.怎么样？ 3.1 Ghost Module 生成ghost图的过程采用简单的线性运算Φ，代替原本的卷积操作。如下图所示，假设原始卷积操作中输入Input与n组k x k的Kernel卷积后生成通道数为n，尺寸为h’ x w’大小的输出。在ghost模型中，我们用m组k x k的Kernel与input进行卷积，生成m x h’ x w’的本征图intrinsic，之后本征图进行线性变换Φ产生ghost图，将intrinsic和ghost一起作为输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d157005696e8ac24dde0d2427e2d9d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a939602848dccecd2d209521f285095c/" rel="bookmark">
			Flutter 小技巧之不一样的思路实现炫酷 3D 翻页折叠动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天聊一个比较有意思的 Flutter 动画实现，如果需要实现一个如下图的 3D 折叠动画效果，你会选择通过什么方式？
相信可能很多人第一想法就是：在 Dart 里通过矩阵变换配合 Canvas 实现。
因为这个效果其实也算「常见」，在目前的小说阅读器场景里，类似的翻页效果基本都是通过这个思路完成，而这个思路以前我也「折腾」过不少，比如 《炫酷的 3D 卡片和帅气的 360° 展示效果》 和 用纯代码实现立体 Dash 和 3D 掘金 Logo ，就是在 Dart 里利用矩阵变换实现的视觉 3D 效果。
但是今天通过一个叫 riveo_page_curl 的项目，提供了不一样的实现方式，那就是通过自定义 Fragment Shaders 实现动画 ，使用自定义 shaders 可以直接使用 GLSL 语言来进行编程，最终达到通过 GPU 渲染出更丰富图形效果。
解释这个项目之前，我们先聊聊 Fragment Shader ，Flutter 在 3.7 开始提供 Fragment Shader API ，顾名思义，它是一个作用于片段的着色器，也就是通过 Fragment Shader API ，开发者可以直接介入到 Flutter 渲染管道的渲染流程中。
那么直接使用 Fragment Shader 而不使用 Dart 矩阵变换的好处是什么？简单来说就是可以减少 CPU 的耗时，直接通过图形语言（GLSL）直接给 GPU 发送指令，从性能上无疑可以得到提升，并且实现会更简洁。
不过加载着色器这个行为的开销可能会比较大，所以必须在运行时将它编译为适当的特定于平台的着色器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a939602848dccecd2d209521f285095c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2300ef0f42b59def02dcef7360f22892/" rel="bookmark">
			ts 简易封装 axios，统一 API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 为什么要封装目标文件结构封装通用请求方法获得类型提示http 方法文件上传使用示例实例化post 请求类型提示文件上传 总结完整代码： 为什么要封装 axios 本身已经很好用了，看似多次一举的封装则是为了让 axios 与项目解耦。
比如想要将网络请求换成 fetch，那么只需按之前暴露的 api 重新封装一下 fetch 即可，并不需要改动项目代码。
目标 统一请求API使用接口数据时能有代码提示 文件结构 │ index.ts	# 实例化封装类实例 │ ├─http │ request.ts # 封装axios │ └─modules login.ts	# 业务模块 upload.ts 封装通用请求方法 先封装一个通用的方法 request，然后在此基础上封装出 http 方法：
class HttpRequest { private readonly instance: AxiosInstance; constructor(config: AxiosRequestConfig) { this.instance = axios.create(config); } request&lt;TReqBodyData, TResData, TResStructure = ResStructure&lt;TResData&gt;&gt;( config: AxiosRequestConfig&lt;TReqBodyData&gt; ): Promise&lt;TResStructure&gt; { return new Promise&lt;TResStructure&gt;((resolve, reject) =&gt; { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2300ef0f42b59def02dcef7360f22892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78bd2e33dda54e36a0d19639700608ff/" rel="bookmark">
			input和原生js文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.input上传 input 标签主要有以下几个属性
accept 设置上传文件的类型，默认为空，表示可以上传所有类型文件。常见的 MIME typescapture 摄像头，user 前置摄像头 environment 后置摄像头multiple 是否可以选多个文件 默认falsewebkitdirectory 是否可以选择文件夹 上传图片并预览
&lt;body&gt; &lt;input type='file' onchange='upFile(this)'/&gt; &lt;img style='display:none' id='img' /&gt; &lt;/body&gt; &lt;script&gt; function upFile(event){ var file=event.files[0] // 上传的file图片 console.log(file) // 预览功能 var fileReader = new FileReader(); var DomImg=docudocument.getElementById('img') fileReader.onload = (e) =&gt; { // 获取选择图片的base64 DomImg.style.display='block' DomImg.setAttribute('src',e.target.result) }; fileReader.onerror = () =&gt; { DomImg.style.display='none' }; fileReader.readAsDataURL(file); } &lt;/script&gt; 2.原生 JS 方式选择文件 showOpenFilePicker 选择文件。查看文档
options(可选参数)
multiple Boolean类型，是否可多选excludeAcceptAllOption Boolean类型，是否排除允许全部类型选项，如下图types Array类型，可选的文件类型数组。每个元素十个对象包含description和accept description 文件类型的描述accept 允许的文件类型对象，key为文件的MIME types，value为文件后缀名数组 通过window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78bd2e33dda54e36a0d19639700608ff/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/67/">«</a>
	<span class="pagination__item pagination__item--current">68/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/69/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>