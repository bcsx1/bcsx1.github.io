<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0ceaf8131ca9b395fc90037f7e2f64/" rel="bookmark">
			Cobalt Strike使用教程——实战篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍实战中 Cobalt Strike 4.3 的常用操作，包括Malleable C2配置与分析、监听器和Beacon Payload配置与区别、进程注入与欺骗、与MSF联动以及插件使用方法。
文章目录 一、Malleable C2配置(一) 基本配置规则(二) 流量特征对比 二、监听器和Beacon(一) Beacon HTTP(二) Beacon HTTPS(三) Beacon SMB(四) Beacon TCP(五) Beacon DNS(六) External C2 三、进程注入和欺骗(一) 会话传递(二) 进程欺骗 四、与MSF联动(一) MSF—&gt;CS(二) CS—&gt;MSF 五、使用插件(一) 加载插件(二) 常见插件 一、Malleable C2配置 为持久化控守，绕过AV和防火墙等安全设备流量审计，需要使CS流量特征尽可能隐蔽，除修改C2监听端口、自生成cobaltstrike.store秘钥库之外，利用Malleable C2 Profile自定义CS通信流量特征也是非常重要的方面，下面介绍基本的配置规则，并抓包对比默认配置和自定义配置的流量特征。
(一) 基本配置规则 profile文件必须包含以下几个部分：
global options：定义全局变量信息http-get：定义Beacon向C2发送http-get时的流量特征http-post：定义C2向Beacon发送http-post时的流量特征 https-certificate为可选部分，配置好profile文件后用c2lint工具检查可用性和基本通信数据：./c2lint [/path/to/my.profile]，如果不通过检查可能会导致通信失败，检查无误后就可以在启动CS时指定profile文件：./teamserver &lt;ip&gt; &lt;passwd&gt; [profile]，自定义profile如下：
profile配置模板参考：https://github.com/xx0hcd/Malleable-C2-Profiles
malleable-c2参数说明参考：https://www.cobaltstrike.com/help-malleable-c2
###global options### set sleeptime "20000"; # 单位ms set jitter "30"; # 睡眠抖动时间，百分比0-99 #set host_stage "false"; # 设置所有的Payload都为Stageless，提高安全性 set useragent "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b0ceaf8131ca9b395fc90037f7e2f64/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bbd9162f32810520a98c041db5dc89d/" rel="bookmark">
			使用css网格布局实现一些简单布局（了解grid）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、居中
二、简单换行自适应（弹性布局的）
三、固定的头部底部导航中间自适应
四、圣杯双飞翼布局
一、居中 我们知道水平居中可以依靠margin来实现，原理就是水平布局公式的自动调整。（注意要固定宽度哦）。而开启定位后布局公式发生改变，我们要固定top、left、right、bottom、以及宽高，可以实现水平和垂直的居中自适应。以及我们可以使用弹性容器，调整主轴辅轴的分配实现水平垂直居中自适应。
这里主要展示css网格布局的水平垂直居中自适应，代码如下
.out{ height: 100vh; display: grid; place-items: center; } .inner{ width: 100px; height: 100px; background-color: aqua; } &lt;div class="out"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; 二、简单换行自适应（弹性布局的） .out{ display: flex; justify-content: center; flex-wrap: wrap; } .inner{ height: 100px; flex: 0 1 200px; background-color: aqua; margin: 5px; } &lt;div class="out"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt; 让弹性元素等比缩放，伸展系数0，这样 在视口缩小的同时宽度不够自动换行到下面同时不会充满下面，使用媒体查询的方式会比较麻烦。
三、固定的头部底部导航中间自适应 作为一个小白，我一开始的做法是三个块元素，我们知道默认宽度是100%，只要给上高度，中间部分可以用calc计算一个视口高度减去我们头部底部的高度。
这里展示css中网格布局实现的主要代码。
&lt;div class="out"&gt; &lt;header&gt;Header&lt;/header&gt; &lt;main&gt;Main&lt;/main&gt; &lt;footer&gt;Footer&lt;/footer&gt; &lt;/div&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bbd9162f32810520a98c041db5dc89d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb49782ec0d9276be75d93bfe31d89fb/" rel="bookmark">
			机器学习（周志华）学习笔记（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
学习教材
学习内容
一、绪论
1.1 基本术语
1.2 假设空间
1.3 归纳偏好
二、 模型评估与选择
2.1 经验误差
2.2 评估方法
2.3 性能度量
2.4 方差与偏差
学习时间
学习教材 机器学习（周志华） 学习内容 一、绪论 1.1 基本术语 数据集：
示例：关于一个事件或对象的描述。（Xi）
特征向量：
样本的维数：用于描述一个样本的属性个数。
标记：关于示例结果的信息。（Yi）
样例：标记信息的示例。
聚类：将训练集分成若干组。
泛化能力：学得模型适用于新样本得能力。
分类任务与回归任务的区别：分类任务用于预测离散值，回归任务用于预测连续值。
监督学习和无监督学习的区别：训练数据是否拥有标记信息。其中分类和回归是监督学习的代表，聚类是无监督学习的代表。
1.2 假设空间 归纳：从具体事实中归结出一般性规律，从特殊到一般的“泛化”过程。
演绎：从基础原理推演出具体状况，从一般到特殊的“特化”过程。
1.3 归纳偏好 （归纳）偏好：机器学习算法在学习过程中对某种类型假设的偏好。
奥卡姆剃刀（Occam's razor）:若有多个假设与观察一致，则选择最简单的那个。
NFL定理：所有学习算法在考虑所有潜在的问题时的期望值都相同。
二、 模型评估与选择 2.1 经验误差 错误率：分类错误的样本数占样本总数的比例。
精度=1-错误率。
误差：学习器的实际预测输出与样本的真实输出之间的差异。
训练误差/经验误差：学习器在训练集上的误差。
泛化误差：在新样本上的误差。
2.2 评估方法 留出法：直接将数据集划分为两个互斥的集合。通常采用“分层采样”
交叉验证法：先将数据集划分为k个大小相似的互斥子集（从数据集中分层采样得到）。每用k-1个子集的并集作为训练集，余下的子集作为测试集，从而进行k次训练和测试，最终返回k个测试结果的均值。k最常用的取值是10。 留一法：m个样本划分为m个子集——每个子集包含一个样本。 评估结果比较准确，但在数据集较大时，计算量非常大。
验证集：模型评估与选择中用于评估测试的数据集。（同一算法不同模型对比）
测试集：对比不同算法的泛化性能。（不同算法对比）
2.3 性能度量 回归任务红最常用的性能度量是均方误差。
P-R图：以查准率作为纵轴，查全率作为横轴做出的图。其中若一个学习器的P-R曲线被另一个学习器的曲线完全包住，则可断言后者的性能优于前者。当两个曲线有交叉时：平衡点（BEP）度量：利用平衡点对应的查全率进行比较；F1度量：根据对查准率和查全率的而重视程度不同而用的度量方法。
ROC曲线：真正例率（TPR）为纵轴，假正例率（FPR）为横轴。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb49782ec0d9276be75d93bfe31d89fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68cf1272c4a190c80f57ba5f6332c6ed/" rel="bookmark">
			350. 两个数组的交集 II——（每日一题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。
示例 1：
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
public int[] intersect(int[] nums1, int[] nums2) { Arrays.sort(nums1); Arrays.sort(nums2); int n1=0,n2=0,i=0; int rus[] = new int[nums1.length]; while(n1&lt;nums1.length&amp;n2&lt;nums2.length) { if(nums1[n1]==nums2[n2]) { rus[i]=nums1[n1]; i++; n1++; n2++; } else if(nums1[n1]&gt;nums2[n2]) { n2++; } else n1++; } return Arrays.copyOfRange(rus, 0, i); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4348a4232518d5f95e3dfe2d7dc3bd56/" rel="bookmark">
			Chrome插件2: 插件主页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chrome插件: 插件主页面 { "manifest_version":2, "name":"FirstChromePlugin", "version":"1.1", "description":"第一个谷歌插件", "author":"Qz1997", "icons": { "16":"img/1.png", "48":"img/1.png", "128":"img/1.png" }, "browser_action": { "default_icon":"img/1.png", "default_title":"Qz第一个插件", "default_popup": "main.html" } } 解释
# 注意使用 UTF-8的编码 { # 插件框架的版本 "manifest_version":2, # 插件名称 "name":"FirstChromePlugin", # 插件版本 "version":"1.0", # 插件的描述 "description":"第一个谷歌插件", # 作者 "author":"Qz1997", # 图标 "icons": { "16" }, "browser_action": { # 默认的图标 "default_icon":"img/1.png", # 鼠标移动到图标上的提示 "default_title":"Qz第一个插件", # 展示页面 : 相对路径地址 "default_popup": "main.html" } } 目录结构
main.html
&lt;!doctype html&gt; &lt;html lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4348a4232518d5f95e3dfe2d7dc3bd56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc4ba968c1582b9ef684fdaf650afd0/" rel="bookmark">
			Chrome插件15: 为页面添加按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主文件
"content_scripts": [ {	"matches": ["&lt;all_urls&gt;"], "js": ["/js/autoBaidu.js"], "run_at": "document_start" } ], "web_accessible_resources": ["js/inject.js"] autoBaidu.js
document.addEventListener('DOMContentLoaded', function () { let jsPath = 'js/inject.js'; let tmp = document.createElement('script'); tmp.src = chrome.extension.getURL(jsPath); tmp.setAttribute('type','text/javaScript'); document.head.appendChild(tmp); }) inject.js
$("#su").after(' &lt;input type="button" class="bg s_btn" value="Qz1997" id="zdyau"/&gt; ') $("#zdyau").click(()=&gt;{ alert("点击了自定义的按钮") }) 效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5efd93435c01b719248206d77f95d441/" rel="bookmark">
			C# 正则使用_正则表达式使用整理（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 正则表达式是字符匹配，爬虫应用实现的基础，多数计算机语言都支持正则。
1.C# 正则匹配域名
C#域名操作，正则匹配域名_天马3798的博客-CSDN博客_c# 判断域名
2.C# 正则匹配URI
C# 常见Url操作实例（一）、正则表达式匹配URl_天马3798的博客-CSDN博客_c# 正则表达式 网址
3.
更多：
Kestrel简介_Kestrel Web 服务器简介 .Net Core上传组件_.Net Core图片上传处理组件 C# 常见Url操作实例（一）、正则表达式匹配URl 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/739f2eac959e480feb6b00dbd97a65e0/" rel="bookmark">
			⑩【蓝桥杯】STM32G4嵌入式竞赛实训平台（CT117E-M4）学习——DAC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写在前面——
本文将介绍嵌入式竞赛实训平台（CT117E-M4）开发板上ADC的使用。
一、硬件平台 嵌入式竞赛实训平台（CT117E-M4）是北京国信长天科技有限公司设计、生产的一款“蓝桥杯全国软件与信息技术专业人才大赛–嵌入式设计与开发科目”专用竞赛平台，平台以STM32G431RBT6为主控芯片，预留扩展板接口，可为用户提供丰富的实验场景。
CT117E-M4产片图片 二、软件平台 KEIL5,STM32CubeMX 三、原理图 四、配置过程 基本步骤： OUT1 和 OUT2对应两个输出通道External Trigger 外部中断EXTI9 触发 就是使用外部中断来触发ADCTigger 选择DAC的触发方式 Output Buffer 使能DAC输出缓存 五、函数编写 /* USER CODE BEGIN 2 */ void DAC1_OUT1_Set_Vol(float vol) //设置PA4的输出电压 { uint16_t temp;	temp = (4096*vol/3.3f);	HAL_DAC_SetValue(&amp;hdac1, DAC_CHANNEL_1,DAC_ALIGN_12B_R,temp); HAL_DAC_Start(&amp;hdac,DAC_CHANNEL_1); } /* USER CODE END 2 */ 六、总结 DAC欧克！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3583b72ba88173128093a3243105855/" rel="bookmark">
			基于C#的工控上位机软件开发从入门到学废，需要几步？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于C#的工控上位机软件开发从入门到学废，需要几步？ 随着工控产品的应用，开始大幅度渗透进民用领域。涉及的工控产品范围广泛，如PLC、DCS、变频器、仪表、电机、SCADA、低压及配电元器件等。
准备工具 开发工具 Visual Studio 2022 Community
要下载Community（社区免费）版本，2010以上都可以。
数据工具 SQL Server2019 Express
要下载Express（免费）版本，2008 R2以上都可以。
OPC服务器 KepServer 6.5
上位软件与PLC通讯服务，注意：学习可以，商用付费。
学习步骤 学习C#软件基础
通过书籍、视频、度娘等方式，学习C#语法，winform开发流程及思路，面向对象编程思想等。
学习上位软件与串口通讯
在工业控制中很多设备都支持串口通讯协议，如扫码器，各种检测传感器、打印机等，串口比较简单也是必须学的。
学习上位软件与PLC通讯
通讯学习中涉及到Modbus及TCP通讯协议，可以下载第三方通讯插件，会使用即可。
学会使用OPC服务器
配置Kepserver服务器，网上有傻瓜式教程，一步步配置即可，支持市面上大多型号PLC，编程时可以使用大神写好的opc.dll文件，会使用即可。
上位软件通过Sqlserver增删改查
配置数据库表结构，网上教程一大堆，学习SQL语句基本语法、触发器、存储过程等，小项目掌握增删改查即可。
上位软件操作Excel、INI、CSV、TXT等文件
一般工控软件都需要将数据导出，要学会对各种基本样式文件的读写编程，教程也很多，大多可以直接复制使用。
接下来你就可以做一些小的工控项目了，在项目中不断学习成长。
做过的项目或者DEMO一定好好留着，后期做项目你会用到的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238967536b5a53badea7222fde699f24/" rel="bookmark">
			C语言的/t到底有什么用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先看代码：
#include&lt;stdio.h&gt; int main() { printf("abc\tabcd\tabcde\tabcdef\tabcdefg\tabcdefgh\t666\n12345678123456781234567812345678123456781234567812345678"); } 看输出：
涨知识：
其中的\t到底是什么功能，之前一直以为是输出四个空格，实际上并不是，而是补全前面字符串的位数到8的整数倍，比如前面有3个字符，就补上5个空格，前面有15个字符，就补上1个空格，如果前面已经满8个了，就补上八个空格。
转义字符是一种特殊的字符常量。以反斜线"\"开头，后跟字符。具有特定的含义，不同于字符原有的含义，故称“转义”字符。
我们在学习C语言转义字符的时候，会有下面这个表格：
转义字符含义\n回车换行，光标移到下一行的行首。\r回车，光标移到当前行的行首，把当前行前面全部删掉\t制表符，即Tap键\b退格，删掉前面一个字符\a鸣铃\'输出一个单引号 ‘\"输出一个双引号 “\\输出一个反斜线 \\v竖向跳格\f走纸换页 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2847efbab5d31681a19ebb933ae9be60/" rel="bookmark">
			踩坑系列-HBuilder X运行sass插件编译问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天写小程序项目的时候编译sass报以下错误
21:11:27.818 [0;31m--&gt; LibSass 的二进制文件(E:\Program Files\HBuilderX\plugins\compile-node-sass\node_modules\node-sass-china\vendor\win32-ia32-72\binding.node)缺失，请执行下面3条命令下载对应版本的二进制文件：（有可能引发此错误的原因是 Node 版本变更）[0m 21:11:27.820 mkdir -p E:\Program Files\HBuilderX\plugins\compile-node-sass\node_modules\node-sass-china\vendor\win32-ia32-72
21:11:27.833 cd E:\Program Files\HBuilderX\plugins\compile-node-sass\node_modules\node-sass-china\vendor\win32-ia32-72
21:11:27.834 curl -o binding.node http://cdn.npm.taobao.org/dist/node-sass/v4.7.2/win32-ia32-72_binding.node
21:11:27.837 [0;31m--&gt; MacOS 、Unix/Linux 请根据权限使用 sudo [0m
我就知道是没这个文件，要去下载文件
然后我就去百度上查找是否有相关问题，结果遇到了几篇文章也有错误：
他们的解决方案 在终端输入以下命令来查看我们需要下载哪个版本的二进制文件
node -p "[process.platform, process.arch, process.versions.modules].join('-')"
这里是win32-x64-93然后我就根据文档找没找到于是就没下载。
然后我就在v4.7.2版本下载了一个最高的win32-ia32-59_binding.node版本，把他换成binding.node
运行报了一大堆错。
我就想4.7.2版本没有，其他版本应该有把我就用github搜索win32-ia32-72_binding.node，然而github是坑人的，没搜到
解决办法：
v4.72前面是大版本号4，出现的不是重大更新应该不会出现版本不兼容问题：是我在v4.12.0找到了win32-ia32-72_binding.node
下载换名字binding.node问题解决
耗时一下午踩坑不易，点个赞吧
GitHub地址：https://github.com/sass/node-sass/releases/tag/v4.12.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b30dd66c9206346735fee921547b8d0e/" rel="bookmark">
			单片机中的ROM,RAM和FLASH的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ROM——作用存放指令代码和一些固定数值（掉电后数据存在） 程序经过编译、汇编、链接后，生成hex文件；用专用的烧录软件，通过烧录器将hex文件烧录到ROM中这个时候的ROM中，包含所有的程序内容：一行一行的程序代码、函数中用到的局部变量、头文件中所声明的全局变量，const声明的只读常量等，都被生成了二进制数据。RAM——程序运行中数据的随机存取（掉电后数据消失） 整个程序中，所用到的需要被改写的量，都存储在RAM中，“被改变的量”包括全局变量、局部变量、堆栈段。FLASH——存储用户程序和需要永久保存的数据。 例如：现在家用的电子式电度表，它的内核是一款单片机，该单片机的程序就是存放在ROM里的。电度表在工作过程中，是要运算数据的，要采集电压和电流，并根据电压和电流计算出电度来。电压和电流时一个适时的数据，用户不关心，它只是用来计算电度用，计算完后该次采集的数据就用完了，然后再采集下一次，因此这些值就没必要永久存储，就把它放在RAM里边。然而计算完的电度，是需要永久保存的，单片机会定时或者在停电的瞬间将电度数存入到FLASH里。ROM中包含所有的程序内容，在MCU上电时，CPU开始从第1行代码处执行指令。这里所做的工作是为整个程序的顺利运行做好准备，或者说是对RAM的初始化（注：ROM是只读不写的），工作任务有几项： 为全局变量分配地址空间---如果全局变量已赋初值，则将初始值从ROM中拷贝到RAM中，如果没有赋初值，则这个全局变量所对应的地址下的初值为0或者是不确定的。当然，如果已经指定了变量的地址空间，则直接定位到对应的地址就行，那么这里分配地址及定位地址的任务由“连接器”完成。设置堆栈段的长度及地址---用C语言开发的单片机程序里面，普遍都没有涉及到堆栈段长度的设置，但这不意味着不用设置。堆栈段主要是用来在中断处理时起“保存现场”及“现场还原”的作用，其重要性不言而喻。而这么重要的内容，也包含在了编译器预设的内容里面，确实省事，可并不一定省心。分配数据段data，常量段const，代码段code的起始地址——代码段与常量段的地址可以不管，它们都是固定在ROM里面的，无论它们怎么排列，都不会对程序产生影响。但是数据段的地址就必须得关心。数据段的数据时要从ROM拷贝到RAM中去的，而在RAM中，既有数据段data,也有堆栈段stack，还有通用的工作寄存器组。通常，工作寄存器组的地址是固定的，这就要求在绝对定址数据段时，不能使数据段覆盖所有的工作寄存器组的地址。必须引起严重关注。 注：普通的MCU是在上电时或复位时，PC指针里面的存放的是“0000”，表示CPU从ROM的0000地址开始执行指令，在该地址处放一条跳转指令，使程序跳转到_main函数中，然后根据不同的指令，一条一条的执行，当中断发生时，按照系统分配的中断向量表地址，在中断向量里面，放置一条跳转到中断服务程序的指令，如此，整个程序就跑起来了。决定CPU这样做，是这种ROM结构所造成的。过程中中C语言编译器作了很多的工作，可仔细阅读编译器自带的help文件进行学习。I/O口寄存器：也是可以被改变的量，它被安排在一个特别的RAM地址，为系统所访问，而不能将其他变量定义在这些位置。中断向量表：中断向量表是被固定在MCU内部的ROM地址中，不同的地址对应不同的中断。每次中断产生时，直接调用对应的中断服务子程序，将程序的入口地址放在中断向量表中。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab193c3b9bc82939592cdebf37abd027/" rel="bookmark">
			⑨【蓝桥杯】STM32G4嵌入式竞赛实训平台（CT117E-M4）学习——ADC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面——
本文将介绍嵌入式竞赛实训平台（CT117E-M4）开发板上ADC的使用。
目录
一、硬件平台
二、软件平台
三、原理图
四、配置过程
五、函数编写
六、总结
一、硬件平台 嵌入式竞赛实训平台（CT117E-M4）是北京国信长天科技有限公司设计、生产的一款“蓝桥杯全国软件与信息技术专业人才大赛–嵌入式设计与开发科目”专用竞赛平台，平台以STM32G431RBT6为主控芯片，预留扩展板接口，可为用户提供丰富的实验场景。
CT117E-M4产片图片
二、软件平台 KEIL5,STM32CubeMX
三、原理图 在硬件平台上，ADC一般用于测量R37,R38上的电压，查阅手册：
PB12 --&gt; ADC1_IN11 PB15 --&gt; ADC2_IN15 四、配置过程 基本配置步骤：
选择ADC1选择通道11选择独立模式选择12位数据，右对齐使能连续转换规则通道如图设置 五、函数编写 1.常规方法： ADC初始化后进行ADC校准：
ADC_HandleTypeDef hadc1; //声明两个ADC结构体 HAL_ADCEx_Calibration_Start(&amp;hadc1); //AD校准 ADC获取函数：
uint16_t getADC1(void) // 获取PB12引脚的电压(对应R38电阻) { uint16_t adc = 0; HAL_ADC_Start(&amp;hadc1); HAL_ADC_PollForConversion(&amp;hadc1, 50); //等待转换完成，50为最大等待时间，单位为ms，可有可无应该 adc = HAL_ADC_GetValue(&amp;hadc1); return adc; } 主函数：
char buf[64] = {0}; sprintf(buf , "ADC1(R38): %.2f V", (3.3 * getADC1())/4096); LCD_DisplayStringLine(Line8, (uint8_t *)buf); sprintf(buf , "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab193c3b9bc82939592cdebf37abd027/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7f4a51b747ba185a821914143106695/" rel="bookmark">
			markdown_markdown制作幻灯片ppt的若干方式(marp/slidev)markdow_slidev&#43;vscode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 markdown 制作幻灯片的若干方式(marp/slidev)markdowslidev基本特点和安装导出插件的使用(vscode) marp基本特点导出 markdown 制作幻灯片的若干方式(marp/slidev)markdow slidev 基本特点和安装 When working with WYSIWYG所见即所得 editors, it is easy to get distracted by the styling options. Slidev remedies that by separating the content and visuals.This allows you to focus on one thing at a time, while also being able to reuse the themes from the community. Slidev does not seek to replace other slide deck builders entirely. Rather, it focuses on catering to the developer community.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7f4a51b747ba185a821914143106695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fe7311e90f9e6dbe6d1f91c2eb0e6a8/" rel="bookmark">
			数据结构与算法:1.链表结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 Python链表 1.1基本概念 概念：链表是通过一个个节点组成的，每个节点都包含了称为cargo的基本单元，它也是一种**递归**的数据结构。
图示：能保持数据之间的逻辑顺序，但不必按照顺序存储。
和C不一样的是python没有专门的指针概念，在python中每个变量都是指针
链表的删除可以通过修改指针来实现
Python实现链表的方法：
class Node: ''' data:节点保存的数据 _next:保存下一个节点对象 ''' def __init__(self,data,pnext=None): self.data=data self._next=pnext 1.2 链表的基本要素 １．节点，每一个节点有两个域：
左：值域，右：针域
２．head节点：特殊节点，永远指向第一个节点
３．tail节点：特殊节点，永远指向最后一个节点
４．None:链表最后节点的针域的指针指向None值,因此也叫接地点.
class Node: def __init__(self,data = None, next = None): self.data = data self.next = next 创建独立节点:
node1 = Node(1) node2 = Node(2) node3 = Node(3) 表示节点间关系:
node1.next = node2 node2.next = node3 1.3链表的常用方法 LinkedList() 创建空链表，不需要参数，返回值是空链表 is_empty() 测试链表是否为空，不需要参数，返回值是布尔值 append(data) 在尾部增加一个元素作为列表最后一个，参数是要追加的元素，无返回值 iter() 遍历链表，无参数，无返回值，此方法一般是一个生成器 insert(idx,value) 插入一个元素，参数为插入元素的索引和值 remove(idx)移除1个元素，参数为要移除的元素或索引，并修改链表 size() 返回链表的元素数，不需要参数，返回值是个整数 search(item) 查找链表某元素，参数为要查找的元素或索引，返回是布尔值 链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fe7311e90f9e6dbe6d1f91c2eb0e6a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02f4cfee633d15705a3283863401a1d6/" rel="bookmark">
			QML小程序：按键元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按键盘上，下，左，右键，移动矩形框
按键盘+，-键，缩放矩形框
演示如下：
main.qml
import QtQuick 2.12 import QtQuick.Window 2.12 //按键盘上，下，左，右键，移动矩形框 //按键盘+，-键，缩放矩形框 //窗口 Window { visible: true //窗口可见 width: 640 //窗口宽度 height: 480 //窗口高度 title: qsTr("Key") //窗口标题 //深色背景区域 DarkRectangle { //绿色矩形框 GreenRectangle { id: greenRect //绿色矩形框id x:8; y:8 //绿色矩形框位置 } focus: true //绿色矩形框焦点 Keys.onLeftPressed: greenRect.x -= 8 //按左键，左移8个像素 Keys.onRightPressed: greenRect.x += 8 //按右键，右移8个像素 Keys.onUpPressed: greenRect.y -= 8 //按上键，上移8个像素 Keys.onDownPressed: greenRect.y += 8 //按下键，下移8个像素 Keys.onPressed: { switch(event.key){ case Qt.Key_Plus: //按+键，放大8个像素 greenRect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02f4cfee633d15705a3283863401a1d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd4c5d2098ed2c2229aa1fc742ea5b87/" rel="bookmark">
			微信小程序实名认证接口_人脸核身接口整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、微信小程序实名认证接口_人脸核身接口整理
开场一个字：
悲观。目前实名接口，人脸识别接口开放度不高。“实名信息授权”已经回收。
二、人脸核身接口
1.使用条件
需要现申请通过才能使用。
目前开放的分类不多，并且还需要行业资质。
2.详细使用官方文档
微信人脸核身接口能力 | 微信开放社区 (qq.com)
三、城市服务实名信息接口
1.使用条件
1、本接口暂只支持校验基于大陆身份证 “姓名与身份证开通微信支付”的用户实名信息；
2、由于信息较为敏感，使用此接口校验用户（或业务方）输入的实名信息时，需要在页面前端征得用户的同意。因此调用此接口后，会跳转至微信官方的“用户同意”界面。用户点击同意按钮后方可继续后续调用。
3、请根据开放范围、场景所需及信息校验必要性申请本接口，并请谨慎使用。若后期使用过程中，用户举报较多或被发现在不合理使用，微信有权永久回收该小程序的该接口的权限。
2.开放范围
1、本接口目前为内测邀请开放阶段，免费开放给非个人开发者，且完成了微信认证的小程序（不包含境外主体）。
2、接口的开放的场景及必要性，参考国家法规、政策规定的需要“实名办理”的相关业务。具体的开放主体类目范围如下：
政务（政府和事业单位）公立医疗（含公立医疗机构的互联网医院）公立教育机构交通行业的官方企业或单位（含：航空公司、机场、客运、交通市民卡、铁路、公交、地铁、轮渡）基础运营商合规的保险公司官方快递与邮政（实名校验场景需要与支付相关联）水、电、燃、暖等官方生活缴费机构； 如你的小程序主体类目所属范围、支付业务场景等，与上述相符，则可以按照对应方式申请。
3.详细官方文档说明
城市服务实名信息校验接口说明 | 微信开放社区
更多：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98fd9b313e41c383a6652c7d8ec2e55e/" rel="bookmark">
			vscode使用技巧，bebug之监察二维数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用debug观察多维数组
今天有一道题需要监视多维数组，网上找了很多办法但是都年代久远无法使用。
最后试出一个办法：
监视里面输入*(int(*)[n])arr_name@n
就可以监视一个int类型，行列数都是n，名字为arr_name的二维数组。
解答：一维数组，int a[2].其中a就是数组的地址，可以使用a访问
但是二维数组的地址是每一行的首个元素名称。比如int a[2][3].元素全为-1.
那么访问的时候，使用*a[0][n]和*a[1][n]访问元素，所以int*[n]arr_name是声明了列数为n的指针，后面，因为C++对二维数组的指针行数没有要求，所以声明指针的时候要先指明列数，@n是指明有几行。然后输入到监视器中，就能看见一个大小为2x3的数组了。记住二维数组输入a是没用的，因为二维数组中，a不是指针，每一个行的第一个元素的名称才是指针地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deb6af925d707fd6ea1e09e395b8f849/" rel="bookmark">
			QML小程序：输入元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展示自定义组件（行编辑框）的输入，焦点切换
展示自定义组件（文本编辑框）的输入
展示图如下：
main.qml
import QtQuick 2.12 import QtQuick.Window 2.12 //展示自定义组件（行编辑框）的输入，焦点切换 //展示自定义组件（文本编辑框）的输入 //窗口 Window { visible: true //窗口可见 width: 640 //窗口宽度 height: 480 //窗口高度 title: qsTr("Input") //窗口标题 //行编辑区域 Rectangle { id: lineEditScope width: 200 //行编辑区域宽度 height: 80 //行编辑区域高度 color: "gray" //行编辑区域颜色 //自定义组件：行编辑框1 CLineEdit { id: input1 //行编辑框1的id x: 8; y: 8 //行编辑框1位置 width: 96 //行编辑框1宽度 height: 20 //行编辑框1高度 focus: true //行编辑框1焦点 text: "Text Input 1" //行编辑框1默认值 KeyNavigation.tab: input2 //允许按Tab键切换焦点到input2 } //注意：如果自定义组件中要使得KeyNavigation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deb6af925d707fd6ea1e09e395b8f849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824ba5171fd88a673b35d5c52aca9295/" rel="bookmark">
			用Git管理Unity项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在Unity里打开Edit -&gt; Project Settings -&gt; Editor，然后设置如下所示：
Version Control Mode:
每当我们在Unity中导入文件或文件夹时，Unity都会生成Meta文件。这些文件包含了导入的资源的Inspector设置，这些都需要被Git追踪。
WWW Security Emulation:
但我们做网页版游戏时，这里的设置就会显得非常重要。由于我做的是手游，所以我就保持默认值。如果你对此感兴趣，可以进一步了解。
Asset Serialization：
Unity 中所有的资源文件，包括Scene、Images、Prefabs，都会以文本或者二进制文件来存储。如果想用Git跟踪文件变化，我们应该存储成文本文件。
二、Git设置
Unity项目的Git操作和其他类型的项目基本一样。
但Unity项目中有很多文件是没有必要跟踪的：
我们可以这样设置.gitignore文件：
# =============== #
# Unity generated #
# =============== #
Temp/
Library/
# ===================================== #
# Visual Studio / MonoDevelop generated #
# ===================================== #
ExportedObj/
obj/
*.svd
*.userprefs
/*.csproj
*.pidb
*.suo
/*.sln
*.user
*.unityproj
*.booproj
# ============ #
# OS generated #
# ============ #
.DS_Store
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/824ba5171fd88a673b35d5c52aca9295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce9bfc8511704d8b6145c3784aaa4d4a/" rel="bookmark">
			Vue 设置proxy后post请求失效，pending挂起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		proxy: { "/api": { // 测试环境 target: "http://192.168.0.79:8080", // 接口域名 changeOrigin: true, //是否跨域 pathRewrite: { "^/api": "", }, onProxyReq: function (proxyReq, req, res, options) { if (req.body) { let bodyData = JSON.stringify(req.body); // incase if content-type is application/x-www-form-urlencoded -&gt; we need to change to application/json proxyReq.setHeader("Content-Type", "application/json"); proxyReq.setHeader("Content-Length", Buffer.byteLength(bodyData)); // stream the content proxyReq.write(bodyData); } }, }, }, 具体可以查看：https://github.com/chimurai/http-proxy-middleware/issues/40
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d1c7efa01690b7cae5c46f66cfb0f6f/" rel="bookmark">
			深度强化学习中的episode、epoch、batch-size、iteration
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度强化学习中的episode、epoch、batch-size、iteration batch_sizeiterationepochepisode batch_size 即批大小，如果把全部数据放入内存后再加载到显存中，空间显然不够的；如果一个一个数据加载训练并更新模型参数，效率极低。所以考虑一批一批地加载数据，每次送进去的数量就是batch_size，这样可以加快速度。
用minibatch方法时会定义batch_size，即把整个数据集分几份后，每份的大小就是batch-size。假设把10000个样本，分成500批次送进去，则每次送进20个样本，batch_size=20。
iteration 即迭代，表示每个循环的一遍，一次参数更新。用minibatch时就意味着训练完一个batch。
一个epoch的数据=batch_size * iteration 。假设把10000个样本，分成500批次送进去，则每次送进20个样本，则iteration=500，每经过一个iteration，参数更新一次。
epoch one forward pass and one backward pass of all the training examples,
in the neural network terminology.（在神经网络术语中，所有训练示例的一次前向传递和一次反向传递）
一个epoch就是跑一遍完整的训练数据。假设有10000个训练样本，这10000个样本都跑完就算一个epoch。实验中一般需要训练很多个epoch，取均值作为最后的结果，从而减少偶然性，避免取到局部极值。
即所有训练数据过一遍，如果数据有300条，把数据分成了3个batch，batch_size是300 / 3 = 100，3个batch都跑完，即跑了三个iteration，就是一个epoch。
episode episode常用于强化学习，以游戏举例，例如模型训练中途或迭代结束后，玩一轮游戏（例如玩一局飞机大战）看看本局游戏能得多少奖励。无论通关还是失败，都是一个episode。如果玩围棋，从头下到尾的一局棋就是一个episode。
agent根据状态和策略做出行为，从而获得奖励，到任务结束。往往在agent训练完成后或经过一段时间训练后，进行很多次episode，检验agent执行任务的能力，可以通过评价指标、奖励值进行评估，对模型进行验证，并保存模型。（划分valid集就是典型的例子）
参考：
关于epoch、episode、iteration和batch size
深度学习中epoch、iteration、batch_size、episode的通俗理解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1a4647c4143cc3c5fdf35fcd84bdf87/" rel="bookmark">
			Java数据结构---HashMap（哈希表及其基本操作）（含hashset）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java数据结构---HashMap（哈希表及其基本操作）（含hashset） 1. HashMap1.2 基础操作（增、删、改、查）1.3 其他操作 2. HashSet2.1 基础操作（增、删、改、查）2.2 HashSet如何实现去重？ 1. HashMap HashMap 是一个散列表，它存储的内容是键值(key-value)映射。
HashMap 的 key 与 value 类型可以相同也可以不同，根据定义，不受限制。
1.2 基础操作（增、删、改、查） 定义一个哈希表 HashMap&lt;Integer, String&gt; hashmap= new HashMap&lt;Integer, String&gt;(); 添加键值对（key-value）（增） hashmap.put(1, "string1"); // 执行完后hash表内为{1=string1} hashmap.put(2, "string2"); // 执行完后hash表内为{1=string1, 2=string2} hashmap.put(2, "string2"); // 执行完后hash表内为{1=string1, 2=string2, 3=string3} 根据key值访问value（查） hashmap.get(1); // 返回string1 hashmap.get(2); // 返回string2 hashmap.get(3); // 返回string3 根据key值删除元素（删） hashmap.remove(1); // 执行完后hash表内为{2=string2, 3=string3} hashmap.remove(2); // 执行完后hash表内为{3=string3} hashmap.remove(3); // 执行完后hash表内为{} // 删除所有键值对 hashmap.clear(); 替换 hashMap 中是指定的key对应的 value hashmap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1a4647c4143cc3c5fdf35fcd84bdf87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d37094392ecbc14fe329f2713647867/" rel="bookmark">
			python同样数据打乱数据集和标签 np.random
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请参照此链接！！！
https://blog.csdn.net/HYLZ2019/article/details/105438375
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca1f30aab1de9d3121a7da2673e85b6/" rel="bookmark">
			MySQL掌握的怎么样？听说这几道MySQL面试题没有几个人能答得出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL可谓是程序员必备技能，怎么检测自己掌握了多少呢，一起来测试一下吧！一共12个关卡，看看你能闯到第几关？
目录
什么是左外链接，什么是右外链接？
分页关键字是什么？
Select 语句的执行顺序？
数据库三范式
MyISAM存储引擎
InnoDB存储引擎
数据库事务的特性
事务的隔离级别
什么是索引？有什么优点？
索引有哪些分类？
索引的底层实现原理？
如何避免索引失效？
什么是左外链接，什么是右外链接？ 左连接
（左外连接）以左表为基准进行查询,左表数据会全部显示出来,右表 如果和左表匹配 的数据则显示相应字段的数据,如果不匹配,则显示为 NULL。
右连接
（右外连接）以右表为基准进行查询,右表数据会全部显示出来,右表 如果和左表匹配的数据则显示相应字段的数据,如果不匹配,则显示为 NULL。
分页关键字是什么？ MySQL的分页关键词limit
SELECT * FROM student3 LIMIT 2,6; 查询学生表中数据，从第三条开始显示，显示6条 。
Select 语句的执行顺序？ 顺序依次为form... on...left join...where...group by...avg()/sum()...having..select...
order by...asc/desc...limit...
数据库三范式 第一范式：1NF 原子性，列或者字段不能再分，要求属性具有原子性，不可再分解； 第二范式：2NF 唯一性，一张表只说一件事，是对记录的惟一性约束，要求记录有惟一标识，
第三范式：3NF 直接性，数据不能存在传递关系，即每个属性都跟主键有直接关系，而不是间接关系。
MyISAM存储引擎 主要特点：
MySQL5.5版本之前的默认存储引擎
支持表级锁（表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁）；
不支持事务，外键。
适用场景：
对事务的完整性没有要求，或以select、insert为主的应用基本都可以选用MYISAM。在Web、数据仓库中应用广泛。
InnoDB存储引擎 主要特点：
MySQL5.5版本之后的默认存储引擎；
支持事务,支持行级锁（行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁）；
支持聚集索引方式存储数据。
数据库事务的特性 原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。 一致性：事务的执行使得数据库从一种正确状态转换成另一种正确状态
隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务， 持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。 事务的隔离级别 读未提交（read Uncommited）:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ca1f30aab1de9d3121a7da2673e85b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c8f36ae96002c06830ce371bfab4c4/" rel="bookmark">
			Python私有属性与私有方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 场景定义 私有属性
是指在 Python 的面向对象开发过程中，对象的某些属性只想在对象的内部被使用，但不想在外部被访问到这些属性。
即：私有属性是对象不愿意公开的属性。
私有方法
是指在 Python 的面向对象开发过程中，对象的某些方法或者称为函数只想在对象的内部被使用，但不想在外部被访问到这些方法或函数。
即：私有方法是对象不愿意公开的方法或函数。
2、 语法定义 在 Python 中定义私有属性和私有方法的语法如下：
class Staff: def __init__(self, s_name, s_salary): self.s_name = s_name self.__salary = s_salary def __secret(self): print("%s 的工资是 %d" % (self.s_name, self.__salary)) (1). __salary是以两个下划线开头来定义的私有属性。
(2). __secret(self)是以两个下划线开头来定义的私有方法。
3、 调用分析 (1). 在__init__的对象初始化方法中，以两个下划线开头定义的__salary属性就是私有属性。
现在在对象的外部来调用一下__salary属性，看是否能正常访问该私有属性。
从上图运行结果可以看出，第11行，即在对象外部访问对象的私有属性 __salary 时，提示 AttributeError 错误，Staff 对象 zhangsan 没有属性 __salary。
为了证明 Staff 类对象确实是有__salary 这个实例属性的，只是因为在对象外部不能访问私有属性。
我把 self.__salary 修改为：self.salary，__secret(self)方法对self.__salary属性的引用，做相应的修改，看如下图所示的运行结果。
可以从运行结果看出，这种非私有属性在外部的调用是正常的，没有提示 AttributeError 错误。
(2). 在 __secret(self) 实例方法中，以两个下划线开头定义的__secret(self)方法就是私有方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11c8f36ae96002c06830ce371bfab4c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1ea0cb35b88f24d82763b8c76877854/" rel="bookmark">
			C语言基本运算,求字节运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出一个3位的正整数，输出其反序数
#include&lt;stdio.h&gt; int main() { int number,a,b,c; number=123; printf("输出的三位数为:%d\n",number); a=number/100; b=(number-a*100)/10; c=number%10; printf("反序数是:%d%d%d\n",c,b,a); return 0; } 运行结果：
运算符sizeof用于计算数据类型所占的字节数。
#include&lt;stdio.h&gt; int main() { printf("char类型占%d字节\n",sizeof(char)); printf("short int类型占%d字节\n",sizeof(short int)); printf("int类型占%d字节\n",sizeof(int)); printf("float类型占%d字节\n",sizeof(float)); printf("double类型占%d字节\n",sizeof(double)); return 0; } 运行结果：
求字节数运算示例
#include&lt;stdio.h&gt; int main() { int a,b; a=sizeof(3+5.0); b=sizeof 3+5.0; printf("%d,%d,%d\n",a,b,sizeof("china")); return 0; } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d75c661844488b90512a9ce647fbbc33/" rel="bookmark">
			Intellij IDEA中push代码到github中引发的部分报错 解决思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Intellij IDEA中push代码到Github上时报错：OpenSSL SSL_read: Connection was reset, errno 10054 百度参考了这篇文章：
参考文档
使用了方法2解决
windows 用户：cmd 命令行窗口输入下面命令
ipconfig /flushdns
二、IDEA提交代码突然SSL错误OpenSSL SSL_read: Connection was reset，443 该问题参考文章：
参考文章
采用了方法2解决
三、push时报当前用户身份验证失败 报错内容如下：
Remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. Authentication failed for 'https://github.com/Banishglory/fcsystem.git/'
经过查询后得知 目前git不接受用户名密码的校验方式，需要使用token的方式验证。
具体操作方式如下：
登录你的github账号，登录后点击右上角选择settings
第一步之后往下滚左侧选择开发者设置
第一步在跳转后的页面点击第三个选项后，点击图中的序号2的位置创建新的token
4. 创建完成后 复制创建好的token进入到idea中settings中搜索git，之后在github中配置对应的account，使用token登录后就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab8897dada7029964d581deaaa13071/" rel="bookmark">
			JavaSE之File类及相关方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File类位于java.io包下，主要用于文件或目录的创建、查找和删除等操作
一、File类的静态成员变量
static String pathSeparator //字符串表示的路径分隔符
static char pathSeparatorChar //路径分隔符
static String pathSeparator //字符串表示的默认文件名称分隔符
static char separatorChar //默认文件名称分隔符
路径分隔符在Windows系统下为分号；在Linux系统下为冒号：
默认名称分隔符在Windows系统下为反斜杠\ 在Linux系统下为正斜杠/
二、File类的构造方法
绝对路径：以盘符开始的完整路径
相对路径：一个简化的路径，相对于当前项目的根目录
注意：路径不区分大小写，在Windows系统下，因为\为转义字符，所以\\表示一个反斜杠
publi File(String pathname) ：参数pathname，字符串的路径名称，可以是绝对路径，也可以是相对路径，路径可以存在，也可以不存在，只是将该路径封装为File对象
public File(String parent,String child)：parent父路径，child子路径，组合起来是完整路径
三、File类获取功能的方法
getAbsolutePath()方法返回的是绝对路径表示的字符串，但getPath()根据File对象创建时的参数，可以使绝对路径字符串，也可以是相对路径字符串，File类的toString()方法实际上就是调用了getPath()方法
length()方法获取指定文件的大小，不能获取文件夹的大小，构造方法中的路径不存在时，length()方法返回0
四、File类判断功能的方法
isDirectory()方法和isFile()方法使用的前提是该路径是存在的，若不存在均返回false
五、File类创建删除功能的方法
public boolean creatNewFile() throws IOException ：创建文件的路径必须存在，否则会抛出异常，因此调用这个方法时，必须处理这个异常，要么throws，要么try catch
mkdir()方法创建单级文件夹，mkdirs()方法可以创建单级文件夹，也可以创建多级文件夹，都是空文件夹，文件夹已存在或路径不存在时均返回false
六、File类目录遍历功能的方法
两个方法遍历的都是构造方法中参数给出的路径，这个路径不存在或者不是目录（文件夹）时，会抛出空指针异常
使用递归打印多级目录：
public void getAllFile(File dir){
File[] files=dir.listFiles();
for(File f: files){
if(f.isDirectory)
getAllFile(f);
else
System.out.println(f);
}
}
如果要删选出特定后缀的文件（特定类型的文件），使用代码如
if(f.getName().endsWith("特定后缀"));
System.out.println(f);
七、使用FileFilter过滤器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ab8897dada7029964d581deaaa13071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d2788df4bba3fdb48476b11aa433ee/" rel="bookmark">
			JavaSE之Properties类属性集以及缓冲流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Map&lt;K,V&gt;接口有一个早期的实现类是Hashtable&lt;K,V&gt;，目前已被HashMap所取代，但Hashtable下有一个子类目前仍在使用。即Properties集合，该集合是目前唯一一个与IO流结合的集合
一、Properties集合
Properties集合同样是一个双列集合，它的属性列表中的键和值都是字符串
使用Properties集合中的store方法把集合中的临时数据写入到硬盘中存储
使用Properties集合中的load方法把硬盘中保存的键值对读取到集合中使用
Properties集合中的一些方法如下：
setProperty方法即调用Map集合的put方法，getProperty方法相当于Map集合中的get(Key)方法，stringPropertyNames方法相当于Map集合中的keySet方法
使用store方法：
1.void store(OutputStream out,String comments); 使用字节输出流，不能写入中文
2.void store(Writer writer,String comments); 使用字符输出流，可以写入中文
comments：解释说明用的字符串，不能使用中文，一般使用" "
使用load方法：
1.void load(InputStream inStream); 使用字节输入流，不能读取含中文的键值对
2.void load(Reader reader); 使用字符输入流，可以读取含中文的键值对
注意：
1.存储键值对的文件中，键与值得连接符合可以是=、空格等其他符号
2.存储键值对的文件中，可以使用#在键值对前注释，被注释的键值对不会再被读取
二、缓冲流
缓冲流，也叫高效流，是对四个Filexxx流的增强，分为字节缓冲流：BufferedInputStream和BufferedOutputStream，字符缓冲流：BufferedWriter和BufferedReader
缓冲流的基本原理：在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少IO次数，从而提高读写的效率
1.BufferedOutputStream：字节缓冲输出流
构造方法：BufferedOutputStream(OutputStream out); 将数据写入底层的输出流
BufferedOutputStream(OutputStream out,int size); 指定缓冲区大小
因此使用时：
BufferedOutputStream bos=new BufferedOutputStream(new FileOutputStream("文件路径"));
2.BufferedInputStream：字节缓冲输入流
构造方法：BufferedInputStream(InputStream in); BufferedInputStream(InputStream in,int size); 指定缓冲区大小
因此使用时：
BufferedInputStream bis=new BufferedInputStream(new FileInputStream("文件路径"));
之后的使用同之前的Filexxx相同
3.BufferedWriter：字符缓冲输出流
构造方法：BufferedWriter(Writer out); BufferedWriter(Writer out,int size); 指定缓冲区大小
该流特有的方法：void newLine(); 写入一个行分隔符，即换行，不同系统下行分隔符也不同
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26d2788df4bba3fdb48476b11aa433ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab811b43b707f66de2fe64d8c779806/" rel="bookmark">
			IDEA设置sql方言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sql方言能在使用IDEA的时候自动联想
就像这样：
实现方法 首先打开设置
找到对应的路径并将数据库改成你正在使用的数据库即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6ea9ca1f02666c05d4e2c98671ea902/" rel="bookmark">
			CSS选择器梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1).CSS样式 可分为内联样式、内部样式、外部样式 2).选择器整理 一、基础选择武器
二、关系选择器
三、伪类选择器
四、伪元素选择器
一、基础选择器
1. 通用选择器 也叫做通配符选择器
最常用的是方法是：
*{margin:0;padding:0}//有的元素自带外边距 利大于弊 优先级很低
2. 元素选择器 也叫做标签选择器 权重值为1
div{样式声明}//弊端是很多标签并存时，没有办法精准定位 当div标签里面包着span标签和a标签时 a没有继承div颜色样式 span继承
3. id选择器 权重值100 话语权很中
&lt;div id="abc"&gt;一个标签&lt;/div&gt;//id名字不能以数字开头 不建议中文名字 #abc {样式声明} 只能一对一给值，尽量不做样式书写的选择
4. 类选择器 （重要） 常常用于样式的编写 使用标签的class属性赋值，类选择器的权重值为10
&lt;div class="abc"&gt;一个标签&lt;/div&gt;//类名不能以数字开头 不建议使用中文名字 .xxx{样式声明} 一个元素可以创建多个类名，每个类名之间用空格分开 注意最后不要随便加空格
&lt;div class="abc wxy"&gt;一个标签&lt;/div&gt; 易错点：
忘记给元素增加id 或者class属性就直接写css样式class的.千万不能丢！先写类名还是先写class属性不能出现多个class属性 用空格将多个class分开，最后千万不要随便加空格 5. 群组选择器 把多个选择器连起来，表示这些选择器都拥有某种相同的样式
div,p,span{ color:red; } 选择器不一定是相同类型的 可以不同类型
#mydiv.b,h4{ color:blue; } 二、关系选择器
html结构中存在三种关系“兄弟关系”、“父子关系”、“后代关系”
6. 后代选择器 空格加入更深层的后代， 不一定得一层一层的往里写
为什么要用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6ea9ca1f02666c05d4e2c98671ea902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f542cd2f2fa04d424a67c2aadeb42d/" rel="bookmark">
			Apollo 7.0障碍物感知模型原型，SMOKE 单目3D目标检测，代码开源。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：黎国溥 CSDN博客专家，华为云-云享专家
首发：公众号【3D视觉开发者社区】
前言 SMOKE是一个one-stage的单目视觉障碍物检测模型，它认为2D检测对于单目3D检测任务来说是冗余的，且会引入噪声影响3D检测性能，所以直接用关键点预测和3D框回归的方式。
最近发布的百度Apollo 7.0中，摄像头障碍物感知也是基于这个模型改进的；它能实现实时推理，代码开源，值得学习一下。
论文名称：SMOKE: Single-Stage Monocular 3D Object Detection via Keypoint Estimation
论文地址：https://arxiv.org/pdf/2002.10111.pdf
开源地址：https://github.com/lzccccc/SMOKE
环境搭建：https://guo-pu.blog.csdn.net/article/details/122243245
SMOKE模型的3D目标检测和俯视图效果如图1.1所示。
图1.1 SMOKE模型效果
一、论文动机 1.1 对于已有的两阶段单目3D目标检测框架：
a、基于2D目标检测网络生成目标的2D候选区域；
b、针对获取到的目标的“2D patch特征” 预测目标位姿；
1.2 SMOKE
a、论文认为其中的2D检测对于单目3D检测任务来说是冗余的，且会引入噪声影响3D检测性能。
b、若已知相机内参和目标的3D属性，反过来是可以推测出目标的2D检测框的；（即：基于3D box在图像平面上的投影点求取满足条件的最小外接矩形。）
本论文抛弃了2D候选区域生成这一步，提出了基于关键点预测的一阶段单目3D检测框架SMOKE(Single-Stage Monocular 3D Object Detection via Keypoint Estimation)，直接预测目标的3D属性信息。
​​
二、单目3D目标检测 针对单张RGB图像，宽度 W、高度 H、通道数 3；
给出其中每个目标的类别标签 C、3D边界框 B；其中B 可以用7个参数表示（h、w、l、x、y、z、θ），如图2.1 所示。需要加水相机的内参矩阵已知。
(h、w、l) 表示目标的高度、宽度和长度；(x、y、z) 表示目标中心点在相机坐标系下的坐标；θ 表示目标的航向角。
图2.1 描述3D目标检测框 三、SMOKE 整体框架 输入图像经过DLA-34 Backbone进行特征提取；网络主要包含两个分支：关键点预测分支和3D边界框回归分支，DLA框架结构如图3.1 所示。
SMOKE网络采用关键点预测分支来定位前景目标，关键点分支输出的分辨率为 ( H 4 , W 4 , C ) \left( \frac{H}{4}, \frac{W}{4},C\right) (4H​,4W​,C)，表示数据集中前景目标的类别个数。3D边界框回归分支输出的分辨率为 ( H 4 , W 4 , 8 ) \left( \frac{H}{4}, \frac{W}{4},8\right) (4H​,4W​,8)，表示描述3D边界框的参数有8个。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f542cd2f2fa04d424a67c2aadeb42d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f66c5ed29b8ec2f814f513e6c053cc25/" rel="bookmark">
			【Flink】Flink 部分算子是 FinishSHED 不做checnpoint
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.概述 1.概述 转载：记一次flink不做checkpoint的问题 请参考原文，这里仅仅是学习一下。
问题现象： Flink UI界面查看checkpoint的metrics发现一直没有做checkpoint，仔细排查发现有部分subtask的状态是finished。
下图是测试环境复现问题
问题原因： 仔细排查代码后发现source是消费kafka的数据，配置的并行度大于kafka的partition数，导致有部分subtask空闲，然后状态变为finished。后来查看了checkpoint过程的源码得以佐证。
在CheckpointCoordinator类的triggerCheckpoint方法中有如下代码段
// check if all tasks that we need to trigger are running. // if not, abort the checkpoint Execution[] executions = new Execution[tasksToTrigger.length]; for (int i = 0; i &lt; tasksToTrigger.length; i++) { Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt(); if (ee == null) { LOG.info("Checkpoint triggering task {} of job {} is not being executed at the moment. Aborting checkpoint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f66c5ed29b8ec2f814f513e6c053cc25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57eb9ba8b73096ea4536a5d99ec405c9/" rel="bookmark">
			Leetcode刷题(第234题)——回文链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目
给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。 ：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题 二、示例
输入：head = [1,2,2,1] 输出：true 输入：head = [1,2] 输出：false 三、思路
本题采用快慢指针的思路，找到中间位置的节点然后进行断开，将后半部分的链表的顺序倒过来，然后进行while循环比对。
四、代码展示
/** * Definition for singly-linked list. * function ListNode(val, next) { * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * } */ /** * @param {ListNode} head * @return {boolean} */ var isPalindrome = function(head) { let slow = head let fast = head.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57eb9ba8b73096ea4536a5d99ec405c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eefa4e81d8daec9a90bdbc6230ad3b77/" rel="bookmark">
			wps打字超级卡顿，试了很多办法都没用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你有遇到过wps打字超级卡顿，反应迟钝，而且其他文档和其他软件打字正常，只有独独这一个文档如此“可恨”的情况吗？
如果你尝试了各种方法，比如把wps中的文件-选项-自动更正全部去掉勾，换输入法，重装wps，转文档格式，换键盘，重启电脑，给电脑一锤子，依旧这一个文档卡的要死的话，那么…
请你看看文档中是不是插入了不少公式！！太多的公式会让文档变卡！！！别问我怎么知道的！！！
希望大家少踩坑，在科研道路上一帆风顺（笑脸）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b606f83a73794da5027a773e0c8bb4/" rel="bookmark">
			动态规划例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态规划 这里我们引用一下维基百科的描述：“动态规划（Dynamic Programming, DP）在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间 · · · · · · 动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。”
通俗一点来讲，动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存子问题的解，避免重复计算。解决动态规划问题的关键是找到状态转移方程，这样我们可以通过计算和储存子问题的解来求解最终问题。
同时，我们也可以对动态规划进行空间压缩，起到节省空间消耗的效果。
在一些情况下，动态规划可以看成是带有状态记录（memoization）的优先搜索。状态记录的意思为，如果一个子问题在优先搜索时已经计算过一次，我们可以把它的结果储存下来，之后遍历到该子问题的时候可以直接返回储存的结果。动态规划是自下而上的，即先解决子问题，再解决父问题；而用带有状态记录的优先搜索是自上而下的，即从父问题搜索到子问题，若重复搜索到同一个子问题则进行状态记录，防止重复计算。如果题目需求的是最终状态，那么使用动态搜索比较方便；如果题目需要输出所有的路径，那么使用带有状态记录的优先搜索会比较方便。
一维(空间复杂度有时可压缩到常数) 三步问题 有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。
示例1:
输入：n = 3
输出：4
说明: 有四种走法
示例2:
输入：n = 5
输出：13
def waysToStep(self, n: int) -&gt; int: if n&lt;=2: return n a=1 b=1 c=2 d=4 for i in range(n-3): a=b b=c c=d d=(a+b+c)%1000000007 return d 打家劫舍 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b606f83a73794da5027a773e0c8bb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b11ffc39e28db29491fe86728e8688b/" rel="bookmark">
			window安装mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载mysql 1. mysql的官网http://www.mysql.com/ 2. 进入顶部的Downloads 3. 点击页面底部的Community(GPL) Downloads 4. 在中间的位置找到windows上要用的下载页面“MySQL on Windows(Installer &amp; Tools)” 5. 选择第一项"MySQL Installer” 6. 页面底端找到下载入口“Windows (x86, 32-bit), MSI Installer ”，点击Download按钮开始下载，共381.4M 注意：MSI格式是指windows的安装程序，下载后直接双击就能进入安装，区别于对文件zip解压的安装方式；
7. 点击 No thanks, just start my download.按钮进入下载页面 8. 下载完成 二、安装mysql 1. 双击下载好的mysql安装文件“mysql-installer-community-5.7.14.0.msi”打开安装程序 2. 选择安装类型 3. 安装mysql server，所以选择最后一项“Custom”，然后点击"Next"按钮继续 4. 在这里需要从安装程序提供的可安装的产品中选择我们需要的mysql server 5.我们展开Available Products里的第一项“MySQL Servers”，依次展开其子结点，直到其终端结点，操作系统是64位的，所以选中“MySQL Server 5.7.14 - X64” 6.然后点击绿色的向右箭头，将当前Product移动需要安装的列表，然后在右边展开“MySQL Server 5.7.14 - X64”项，取消“Development Components”的勾选（只需要安装mysql server），之后点击“Next”按钮进入下一步 7. 点击“Execute”（执行）开始安装，等待安装完成后Status会显示Complete，mysql图标前会出现一个绿色的勾，然后点击“Next”按钮进入产品配置界面 8. 点击“Next”按钮进入MySQL Server 的配置 9. Config Type选择“Development Machine”，选择此项将使用较小的内容来运行我们的mysql server，对应小型软件、学习是完全够用的。之后“Next” 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b11ffc39e28db29491fe86728e8688b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0bf3cc82185bba54e8043a68c89e24/" rel="bookmark">
			测试Pangolin是否安装成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、终端输入
cd Pangolin/examples/HelloPangolin cmake . make ./HelloPangolin 二、显示这个结果则成功
三、顺便放一个 我可终于装完了ORB_SLAM3 被内存不够折腾了好久 换个内存条就可了hhh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e82d011eceb16e71b444d2fa3f49761/" rel="bookmark">
			【 PermissionError: [Errno 13] Permission denied: 问题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PermissionError: [Errno 13] Permission denied: 问题 个人情况比较特殊，常规的Errno 13解决方法都无效。
问题及解决： 刚开始还能正常安装扩展包，突然间不知道为什么创建新的虚拟环境和安装新的扩展包都失败了，报错：PermissionError: [Errno 13] Permission denied: xxxxx。
不知道起因是什么，猜想是anaconda是在另一个win用户下安装的，此用户没有权限？（但是在本次问题之前，在非安装conda的win用户下成功创建过虚拟环境，所以还是没解决找出问题所在）去安装anaconda的用户下，发现可以正常 创建虚拟环境，安装扩展包。
解决：返回使用的用户下，用管理员权限打开 conda prompt 可以正常安装扩展包，正常创建虚拟环境。先凑合用着，等有时间了系统解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd6b1ef92b913d09b0faab765a4d85a/" rel="bookmark">
			Unity操作文件对话框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unity文件对话框操作 一、运行时操作文件对话框调用Win32操作对话框1.打开对话框；保存对话框；调用windows窗口对文件进行筛选功能，文件类型自定义2.实现步骤 二、编辑时操作文件对话框 一、运行时操作文件对话框 调用Win32操作对话框 （1）OpenFileDialog控件的基本属性
InitialDirectory：对话框的初始目录Filter：获取或设置当前文件名筛选器字符串，
例如：文本文件 "txt (.txt)";
所有文件 (.)||.*FilterIndex在对话框中选择的文件筛选器的索引，如果选第一项就设为1RestoreDirectory 控制对话框在关闭之前是否恢复当前目录FileName：第一个在对话框中显示的文件或最后一个选取的文件Title 将显示在对话框标题栏中的字符AddExtension是否自动添加默认扩展名CheckPathExists 在对话框返回之前，检查指定路径是否存在DefaultExt 默认扩展名DereferenceLinks 在从对话框返回前是否取消引用快捷方式ShowHelp 启用"帮助"按钮ValiDateNames控制对话框检查文件名中是否不含有无效的字符或序列 （2）OpenFileDialog控件有以下常用事件
FileOk 当用户点击"打开"或"保存"按钮时要处理的事件HelpRequest 当用户点击"帮助"按钮时要处理的事件 1.打开对话框；保存对话框；调用windows窗口对文件进行筛选功能，文件类型自定义 （1）打开对话框
（2）保存对话框
（3）调用windows窗口对文件进行筛选功能，文件类型自定义
主要是：设置filter，并且结合pth.filterIndex去选择使用生成的类型列表中的第几个（注意是从1开始的）
//\0字符串分隔符（多个根据\0分割的字符串形成下拉列表）； //pth.filter = "JSON file(*.json)\0*.json\0FBX file(*.fbx)\0*.fbx\0"; //* \0*.fbx"; //;是&amp;的作用 1:.json;.fbx;.gltf 2:.json 3:.fbx 4:.gltf 5:PNG 6:All Files pth.filter = "模型文件(*.json|*.fbx|*.gltf)\0*.json;*.fbx;*.gltf\0JSON file(*.json)\0*.json\0FBX file(*.fbx)\0*.fbx\0GLTF file(*.gltf)\0*.gltf\0PNG file(*.png)\0*.png\0All Files\0*.*\0\0"; 2.实现步骤 （1）创建窗口对话框类：FileDialog
using UnityEngine; using System.Collections; using System.Runtime.InteropServices; using System; [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)] public class FileDialog { public int structSize = 0; public IntPtr dlgOwner = IntPtr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddd6b1ef92b913d09b0faab765a4d85a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/757628ea42b275112b7e4385d18f9447/" rel="bookmark">
			立讯检测 | 广州可靠性——机械冲击试验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过人工模拟产品在使用、储存、运输或装配过程中，有可能受到的各种外界机械应力，来验证产品对机械环境的适应能力。主要测试项目有：
· 振动试验
· 机械冲击试验
· 碰撞试验
· 跌落试验
· 插拔寿命/按键寿命等耐久试验
· 摩擦/刮擦等试验
……
机械冲击/碰撞试验
试验目的
模拟产品在使用或运输中可能遇到的短时间内的极大冲击力，验证产品对外界冲击力的抵抗能力。
常见标准
GB/T 2423.5、IEC 60068-2-27 机械冲击；
GB/T 2423.6、IEC 60068-2-29 机械碰撞；
冲击波形
锯齿波：能量最小，严酷等级最低；
半正弦波：能量其次，严酷等级其次，目前使用最为普遍；
梯形波：能量最大，严酷等级最高。
锯齿波波形
半正弦波波形
梯形波波形
冲击和碰撞的区别
差异描述
机械冲击
机械碰撞
模拟现象不一样
偶然的、突发的高能量的冲击
（如汽车急刹车）
预料之中、小能量的冲击
（如关闭车门）
加速度不一样
较大，如50g、100g或更大
较小，如30g、10g
测试次数不一样
测试次数较少，
如测试3次/轴*6轴，共18次
或10次/轴*6轴，共60次
测试次数较多，
如测试100次/轴*6轴，共600次
测试设备不一样
机械冲击台
振动台或碰撞台
测试条件确认
加速度：冲击的强度，单位为g；一般为30~500g，典型为30g、50g、100g；
脉冲宽度：冲击持续时间，单位为ms；一般为2~18ms，典型为6ms、11ms；
冲击波形：半正弦波、梯形波、锯齿波；
冲击次数：一般测试方向为6轴（±X、±Y、±Z）。
如： 加速度：100g 脉冲时间：6ms 试验次数：3次/方向 试验方向：6（±X、±Y、±Z）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9703d5d8f98ae6eebc373d763276aa73/" rel="bookmark">
			[蓝桥杯] 合数个数 （Python 实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
代码：
n = 2020 nums = [1 for _ in range(1,n+2)] for i in range(2,n): if nums[i]: for y in range(i**2,n+1,i): nums[y] = 0 print(nums.count(0)) 结果：1713
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b3687a0956084f5ed621ff7113fbf7/" rel="bookmark">
			[C语言编程练习][20]初始化顺序表（顺序表中元素为整型），里边的元素是1,2,3，然后通过scanf读取一个元素（假如插入的是6），插入到第2个位置，打印输出顺序表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Description
初始化顺序表（顺序表中元素为整型），里边的元素是1,2,3，然后通过scanf读取一个元素（假如插入的是6），插入到第2个位置，打印输出顺序表，每个元素占3个空格，格式为1 6 2 3，然后scanf读取一个整型数，是删除的位置（假如输入为1），然后输出顺序表 6 2 3，假如输入的位置不合法，输出false字符串。提醒，Language一定要选为C++。
Input
第一次输入插入的元素值，第二次输入删除的位置
Output
假如插入的元素为6，那么输出为
1 6 2 3
假如删除的位置为1，那么输出为
6 2 3
#define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MaxSize 100	//定义最大长度100 /*初始化顺序表（顺序表中元素为整型），里边的元素是1,2,3， 然后通过scanf读取一个元素（假如插入的是6），插入到第2个位置， 打印输出顺序表，每个元素占3个空格，格式为1? 6? 2? 3， 然后scanf读取一个整型数，是删除的位置（假如输入为1）， 然后输出顺序表? 6? 2? 3，假如输入的位置不合法，输出false字符串。 提醒，Language一定要选为C++。*/ //静态分配实现的顺序表 typedef int ElemType; typedef struct { ElemType data[MaxSize];	//静态数组存放数据元素 int length;	//顺序表的当前长度 }SqList;	//结构体类型SqList //初始化操作 InitList void InitList(SqList&amp; L) { for (int i = 0; i &lt; MaxSize; i++) { L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b3687a0956084f5ed621ff7113fbf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec8813c3856e72d000a70de742a0697/" rel="bookmark">
			企业微信定时发送图片/文字信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于近期看到企微有自定义机器人的操作,特地写了个定时获取api中的图片并发给同事,有效的加大了开发效率,代码遇到问题可以联系我
# -*- coding:utf-8 -*- import json import uuid import time import os import requests import hashlib import base64 import uuid headers = { 'content-type': 'application/json', } while True: # https://api.btstu.cn/sjbz/api.php 不色 # https://api.vvhan.com/api/girl 色 # https://api.vvhan.com/api/girl?type=https 超级色 image_res = requests.get("https://api.vvhan.com/api/girl?type=https") # 获取api中的图片 uuid_str = uuid.uuid1() # 随机uuid用于添加文件名称 image_name = "%s.png" % uuid_str # 拼接文件名称 with open(image_name, "wb") as f: # 通过wb追加的方式将图片文件流添加 f.write(image_res.content) file_name = os.path.abspath('.') + "\%s" % image_name # 拼接文件地址 print(file_name) with open(file_name, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ec8813c3856e72d000a70de742a0697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d8c4a1aa5d45c98ccb9adbdd858b9ce/" rel="bookmark">
			（转）Visual Studio 2017在编译时出现错误E2512：功能测试宏的参数必须是简单标识符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio 2017在编译时出现错误E2512：功能测试宏的参数必须是简单标识符
问题描述 Visual Studio 2017在编译时出现错误E2512：功能测试宏的参数必须是简单标识符，如下图：
解决方案： 点击下图红色剪头按钮，弹出如下选项：
选择“仅生成”，然后清理，重新生成即可。
“生成+IntelliSense”是说：Visual Studio的IntelliSense功能类似其他IDE中的auto-completion，也就是能够自动补全。对于我来说只要调试就可以，所以关闭，就解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9965dde19b520a2e372f6df7c278e18f/" rel="bookmark">
			getline(cin,str)与cin造成的报错“string subscript out of range“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cin的读取不会读取"\n"
但是getline(cin,str)以"\n"结束，
所以cin后使用getline(cin,str)导致str读取到"\n"，str为空
如下
int main() {//加权的意思时乘权重 int n; string ID; ID.resize(100); cin &gt;&gt; n; //getchar(); for (int i = 0; i &lt; n; i++) { getline(cin, ID); cout &lt;&lt; addPow(ID) &lt;&lt; endl; } } 解决的方法就是在cin后用getchar()读取cin后的"\n"，使得getline可以正常读取，如上
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f8c254b1c5eead5dc6897527046a41/" rel="bookmark">
			WPF视频播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!-- Declare the MyVideos class, which belongs to the DataTemplatingLab namespace.--&gt; &lt;!-- Setting the Directory to the relative path pointing to the Media folder.--&gt; &lt;!-- Giving this an x:Key. Now controls in this Window can bind to the videos in the Media folder.--&gt; &lt;Window.Resources&gt; &lt;local:MyVideos Directory="../../media" x:Key="Vids" /&gt; &lt;DataTemplate x:Key="MainScreenTemplate"&gt; &lt;Border BorderBrush="LimeGreen" BorderThickness="2" CornerRadius="3" Margin="15"&gt; &lt;Grid&gt; &lt;!-- Background image if no video is playing. --&gt; &lt;Image Source="Images\Crystal.jpg" Stretch="Fill" /&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f8c254b1c5eead5dc6897527046a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fda0adee569336ca79a5cd01701bb7b/" rel="bookmark">
			C 语言判断回文数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//判断一个数是否为回文数。//设n是一任意自然数。若将n的各位数字反向排列所得自然数n1与n相等，则称n为一回文数。//例如，若n=1234321，则称n为一回文数；但若n=1234567，则n不是回文数 #include &lt;stdio.h&gt; int main() { int n, x, y; int r=0; printf("输入一个整数: "); scanf("%d", &amp;n); //123 y = n; // 翻转 while( n!=0 ) { x = n%10; //321 r = r*10 + x; //取倒数，利用追加的方式 // 321 n=n/10; //相除 123/10=12 12/10=1 1/10=0 退出循环 // printf("%d",n); } // 判断 if (y == r) printf("%d 是回文数。", y); else printf("%d 不是回文数。", y); return 0; } 字符串判断回文
#include &lt;stdio.h&gt; #include&lt;string.h&gt; int main() { int a=12021; char s[10]={'\0'},s1[10]={'\0'}; sprintf(s,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fda0adee569336ca79a5cd01701bb7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd4af5f32e7240d86cf7f398a452dd9/" rel="bookmark">
			[C语言编程练习][19]使用C&#43;&#43;的引用，注意提交时把代码选为C&#43;&#43;；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Description
使用C++的引用，注意提交时把代码选为C++；在主函数定义字符指针 char *p,然后在子函数内malloc申请空间，通过fgets读取字符串，然后在主函数中进行输出；要求子函数使用C++的引用，注意在C++中从标准输入读取字符串，需要使用fgets(p,100,stdin)
Input
输入一个字符串，例如 I love C language
Output
如果输入的是I love C language，那么输出也是I love C language
#define _CRT_SECURE_NO_WARNINGS #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void modify_pointer(char*&amp; p) { p = (char*)malloc(100);	//申请空间 fgets(p, 100, stdin); //如果使用fgets传入的是一个指针变量，中间参数是指针指向的空间大小，数组就是sizeof } int main() { char* p = NULL; modify_pointer(p); puts(p); return 0; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/290/">«</a>
	<span class="pagination__item pagination__item--current">291/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/292/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>