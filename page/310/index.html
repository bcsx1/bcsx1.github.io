<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b889010f06ed0dc1fc4d95f1257ea3/" rel="bookmark">
			什么是C语言？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于大多数的程序员来说，C语言是学习编程中的第一门语言，是你从大学开始学习编程的中必须要掌握的一门语言，是大一必须要掌握的基础，如果熟练地掌握了C语言，你在程序员或其他从事计算机行业等的工作更上一层楼，而不仅仅是码农，对于C语言的简单理解，就是：C语言是一门计算机语言，在读大学的时候，一般计算机相关的专业都要求学习这门计算机语言。C语言之所以叫做C语言，与其他的计算机语言（例：Java,C++,C#等）都不同，它是引入计算机的指针，它也是C语言与计算机硬件打交道的桥梁，可以操作硬件。从大学选择计算机这门专业就必须要掌握C语言这一门语言，因为它是整个计算机语言中基础，必须熟练掌握。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70084e269af6765be29e236d650338dc/" rel="bookmark">
			Vue 多表单校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue 多表单检验
1.应用场景：当需要使用到多个form表单；每个form绑的ref值不同；可以理解为这个ref是这个form的id。
2.校验方法：this.$refs[“formname”].validate,这个是elementui里面自带的校验方法；
还需要使用ES6的新特性，promise；promise其实就是一个构造函数
3.代码：
这是js部分，template里面只需要写form表单就可以了
const base = new Promise((resolve, reject) =&gt; { this.$refs["aform"].validate(valid =&gt; { if (valid) { resolve(); } }); }); const soap = new Promise((resolve, reject) =&gt; { this.$refs["bform"].validate(valid =&gt; { if (valid) { resolve(); } }); }); const http = new Promise((resolve, reject) =&gt; { this.$refs["cform"].validate(valid =&gt; { if (valid) { resolve(); } }); }); const mq = new Promise((resolve, reject) =&gt; { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70084e269af6765be29e236d650338dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/993f63742caf8555994a39ab58a2dd31/" rel="bookmark">
			ID卡（工卡）复制到手机NFC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.很多单位的工卡都是ID卡，而读卡机，一般是多频的，支持多种卡，那么如何把ID卡写到手机NFC中，实现“忘带卡自由”呢？
2.前提条件：用手机NFC，在单位的刷卡机上刷卡，提示“非法卡”。说明打卡机支持NFC，如果不支持，请略过本文
3.在单位的打卡机上正常刷卡，屏幕上会提示卡号。或者有的工卡上带卡号，一般ID卡号是00开头或000开头的10位卡号。如果不是，说明不是ID卡，请略过本文。有的单位的人事系统里也会记录员工的物理ID卡号。或者用其他读卡器读ID卡，也能读到卡号。
4.获取到ID物理卡号后，如：0002216215，打卡WINDOWS自带的计算器，转换成程序员模式（按ALT+3快捷键也可），复制0002216215粘贴到计算器，点击“十六进制”，转换成十六进制为0021D117
5.生成逆序值：17D12100（2位2位的从后往前，生成十六进制的逆序值，看顺序就知道了）
6.使用逆序值17D12100做异或运算，异或运算可以使用在线的异或运算工具计算。如下网站：
​​​​​​BCC校验(异或校验)在线计算_ip33.com
结果是E7，生成完整的字符串为17D12100E7
7.把17D12100E7，写到解码的编辑数据的前几位，写入IC-UID卡中。写卡工具可以在某宝或某多买，我买的是价格65元的PM8，用手机APP+OTG接口运行。运行后使用一个IC-UID卡先读卡，存储成文件后，可以在APP中编辑数据，把保存的空卡数据前几位替换成刚才生成的数据文件，再写卡即可。
8.测试：把刚才写卡的IC-UID卡，在单位打卡机刷一下，如果正常，说明成功了。用小米或华为的手机模拟门卡功能模拟就可以。IC-UID卡可以多次写卡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfe4e3cf60a0f31a7974253cb1b1b97/" rel="bookmark">
			postman--日期使用当前的时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方法一：需要输入日期的情况下，不用手动填入时间，在body中引用“Pre-request”中的这段内容，send时便会显示当前的时间
var moment = require('moment');
var delivery_time = moment().format("YYYY-MM-DD HH:mm:ss");
pm.environment.set("delivery_time",delivery_time);
console.log(delivery_time);
方法二：
Timestamp = new Date().toISOString(); //获取当前时间，并转化为使用 ISO 标准返回 Date 对象的字符串格式
postman.setGlobalVariable("Timestamp",Timestamp); //设置全局变量 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d94a122571ad7637950370f84d33ff7c/" rel="bookmark">
			关于selenium模块出现异常：selenium.common.exceptions.StaleElementReferenceException: 的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from selenium.webdriver import Chrome from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys import time from selenium.common import exceptions as ex web = Chrome() web.get('https://www.lagou.com/wn/jobs?labelWords=&amp;fromSearch=true&amp;suginput=&amp;kd=python') # //*[@id="jobList"]/div[1]/div[1]/div[1]/div[1]/div[1]/a time.sleep(5) # 在加载没有完成就进行操作容易报错，这里加上等待时间，等上5秒就可以了。 divs = web.find_elements(by=By.XPATH, value='//*[@id="jobList"]/div[1]/div') for div in divs: try: job_name = div.find_element(by=By.XPATH, value='./div[1]/div[1]/div[1]/a').text job_company = div.find_element(by=By.CLASS_NAME, value='company-name__2-SjF').text job_price = div.find_element(by=By.CLASS_NAME, value='p-bom__JlNur').text print(job_name,job_company,job_price) except ex.StaleElementReferenceException: web.refresh() # 刷新 # 经过再次测试拉钩网站，发现其实之前的代码和思路都没有错，问题还是处在selenium模块上，也可以说是问题出现在程序运行上，代码都没有问题 # 只不过程序运行的时候，会偶发性出现一下异常： # selenium.common.exceptions.StaleElementReferenceException: Message: stale element reference: element is not attached to the page document # 异常大概意思是陈旧元素，元素没有连接上,具体出现异常情况，有可能跟网页刷新，等待时间等待有关，目前还未找出解决方法.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d94a122571ad7637950370f84d33ff7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c66fd8081546014c25c9f629a62cbe6/" rel="bookmark">
			【无标题】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7-4 合并两个有序数组 (15 分)
已知两组递增的有序数列（数据无重复）。编写程序将两组数列合并为一组递增的有序数列，且合并后的该组数列中相同的整数只出现一次。
如(1​5​7​9​)∪(2​3​7​10​)⇒(1​2​3​5​7​9​10​)
输入格式: 第一行输入第一个数组的元素个数m（m≤10），之后依次输入m个递增的整数； 第三行输入第二个数组的元素个数n（n≤10），之后依次输入n个递增的整数，数据之间以空格间隔。
输出格式: 在一行中依次输出合并后的递增数列，每个数据之间有一个空格，行末无多余空格。
输入样例: 4 1 5 7 9 4 2 3 7 10 结尾无空行
输出样例: 1 2 3 5 7 9 10 结尾无空行
#include&lt;stdio.h&gt;
int main(){
int a[20],b[20];//设置两个要用到的数组，设置为二倍长度。
int i,j,k,l,m,n,o,cnt=0;//i,j,k,l是循环要用的变量。
scanf("%d",&amp;m);
for(i=0;i&lt;m;i++){
scanf("%d",&amp;a[i]);
}
scanf("%d",&amp;n);
for(i=0;i&lt;n;i++){
scanf("%d",&amp;b[i]);
}//输入两个数组。
for(i=0;i&lt;n;i++){
for(j=0;j&lt;m+cnt;j++){//遍历两个数组。
if(a[j]==b[i]){
break;
}//如果元素相同，不做任何操作。
if(a[j]&gt;b[i]){//如果数组a中的元素大于b中的
o=j;
for(k=m+cnt;k&gt;o;k--){//保留数组a前面的
a[k]=a[k-1];//一个一个往前推
}
a[o]=b[i];//插入
cnt++;//因为插了一个，所以末项得加1
break;
}
if(b[i]&gt;a[m+cnt-1]){//如果a中的所有元素都不大于b
a[m+cnt]=b[i];//将其插在最后面
cnt++;
break;
}
}
}
printf("%d",a[0]);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c66fd8081546014c25c9f629a62cbe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed56b5d3effa8cebb126478a53ffef4/" rel="bookmark">
			【VHDL语言学习笔记（七）】 分频器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：实现分频器设计。
1. 设计一个分频器实现将原信号进行8分频，所得信号占空比为50%。
分频是将单一频率信号的频率降为原来的1/N，就叫N分频。将信号进行8分频，即所得信号频率是原信号频率的1/8，则其所得信号的1个周期等于原始信号的8个周期。
占空比是高电平持续时间占整个周期的比值。占空比为50%意思是高低电平持续时间一样，均为半个周期的时间长。
程序
library ieee; use ieee.std_logic_1164.all; use ieee.std_logic_unsigned.all; entity frequency_divider is port( clk	:in std_logic;	--原始信号 fp_out	:out std_logic	--经过分频后的输出信号 ); end frequency_divider; architecture behave of frequency_divider is begin process(clk) variable count	:integer := 0;	--integer决定分频数N begin if(clk'event and clk = '1') then	--上升沿 count := count + 1;	--对上升沿的个数进行计数，其实就是对原始信号的周期进行计数 if(count &lt; 5) then fp_out &lt;= '1';	--输出信号在原始信号的前四个周期内保持高电平 elsif(count &lt;8) then fp_out &lt;= '0';	--输出信号在原始信号的后四个周期内保持低电平 end if; if(count = 8) then	--因为是8分频，所以当计数到8时要将计数值清0 count := 0; end if; end if; end process; end behave; 波形仿真图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eed56b5d3effa8cebb126478a53ffef4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10977fdac452ee7cb8482ba006b2a41a/" rel="bookmark">
			【Mysql实战45讲】11 给字符串加索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前缀索引 如果给邮箱加索引，可以考虑用前缀索引：alter table testTable add index prefix_index(email(6));如果定义好长度，使用前缀索引可以做到既节省空间，又不额外增加太多查询成本的作用通过 select count(distinct targetField) as L from targetTable; 计算表中某个字段不重的个数通过 select count(distinct left (targetField, 5)) from targetTable; 计算表中某个字段前5位不重的个数。该个数大于L * 95% 即可选择作为前缀长度，如果5和6都满足，则选择5 前缀索引的缺点 前缀索引可能会增加扫描行数使用前缀索引后就无法用上覆盖索引对查询性能的优化了。因为无法确定前缀索引是否截取了完整的信息，所以InnoDB总要回到id索引再次查一次 其它方式 对于邮箱，尾部可能都是固定的@qq.com，所以可以较为方便的使用前缀索引，但对于身份证号类型的数字就不行了，身份证号有18位，其中前6位是地址码，所以同一个县的人身份证号前六位是相同的，在这个场景下，可以在存身份证号到数据库时，将号码反转后再存，也就是倒序存储：select field_list from t where id_card = reverse(‘input_id_card_string’);除了倒序存储的方式外，也可以使用 hash 字段：在表上再建一个整数字段，用于保存身份证的校验码，同时给这个字段加索引，每次插入新数据时，同时用 crc32() 这个函数获取校验码填到这个新字段中。这两种方法都不支持范围查询 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a221393212bad4e0ace92441bc2fbf41/" rel="bookmark">
			【c语言】在一个一维整数组中找出其中最大的数及其下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//在一个一维整型数组中找出其中最大的数及其下标 #include &lt;stdio.h&gt; #define N 10 int fun(int* a, int* b, int n) { int* c, max = *a;//设max为数组a的第一个元素 for (c = a + 1; c &lt; a + n; c++)//查找：从数组a的第二个元素起 到a[n]结束 if (*c &gt; max)//如果该数大于max { max = *c;//将该数赋给max *b = c - a;//最大值下标求法 } return max; } int main() { int a[N], i, max, p = 0; printf("please enter 10 integers:\n"); for (i = 0; i &lt; N; i++) scanf_s("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a221393212bad4e0ace92441bc2fbf41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/892890d959eddb0e6d544bd6dc8e6904/" rel="bookmark">
			【Mysql实战45讲】09 普通索引和唯一索引的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 change buffer 当更新一个数据页时，如果数据页在内存中，就直接更新，如果不在内存中，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了，然后在下次查询需要访问该数据页时，再将数据页读入内存，然后执行 change buffer 中与这个数据页有关的操作。change buffer 的好处是减少了读磁盘，所以可以提升执行速度，而且数据读入内存中需要占用 buffer pool，所以还提高了内存利用率change buffer 的主要目的是将记录的变更动作缓存下来，所以在一个数据页真正进行数据更新时，change buffer 记录的变更越多（更新次数越多），收益就越大。所以对于写多读少的业务，change buffer 的使用效果最好，比如常见的账单类、日志类的系统 普通索引和唯一索引 唯一索引：所有更新操作都要先判断该操作是否违反了唯一性约束，比如要插入一条数据时，要先判断现在表中是否已经存在了该数据，而这必须要将数据页读入内存才能判断，如果都读入内存了，那就没必要使用 change buff 了，直接更新内存即可普通索引会使用 change buffer，推荐使用普通索引 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b483309021a6bc717a2ebc45a6517b4/" rel="bookmark">
			返回头相关的安全问题及处理办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.HTTP Content-Security-Policy缺失 可以防止XSS,
参考地址 Content Security Policy 入门教程 - 阮一峰的网络日志
X-XSS-Protection 防止XSS
httpServletResponse.setHeader("Content-Security-Policy", "script-src 'self' 'unsafe-eval' 'unsafe-inline';object-src 'self'"); //当发生xss注入时，停止动态脚本加载 httpServletResponse.setHeader("X-XSS-Protection", "1; mode=block"); 2.X-Frame-Options Header未配置
X-Frame-Options HTTP响应头可以指示浏览器是否允许当前网页在“frame”或“iframe”标签中显示，以此使网站内容不被其他站点引用和免于点击劫持攻击。
httpServletResponse.setHeader("X-Frame-Options","SAMEORIGIN"); 3.HTTP X-Permitted-Cross-Domain-Policies缺失
Web 服务器对于 HTTP 请求的响应头中缺少 X-Permitted-Cross-Domain-Policies，这将导致浏览器提供的安全特性失效。 当一些在线的 Web Flash 需要加载其他域的内容时，很多 Web 会通过设置一个 crossdomain.xml 文件的方式来控制其跨域方式。很有可能有些开发者并没有修改 crossdomain.xml 文件的权限，但是又有和跨域的 Flash 共享数据的需求，这时候可以通过设置 X-Permitted-Cross-Domain-Policies 头的方式来替代 crossdomain.xml 文件，其可选的值有： none master-only by-content-type by-ftp-filename all。Web 服务器对于 HTTP 请求的响应头中缺少 X-Permitted-Cross-Domain-Policies，这将导致浏览器提供的安全特性失效，更容易遭受 Web 前端黑客攻击的影响。
httpServletResponse.setHeader("X-Permitted-Cross-Domain-Policies","value"); 4.HTTP X-Download-Options缺失
Web 服务器对于 HTTP 请求的响应头中缺少 X-Download-Options，这将导致浏览器提供的安全特性失效。Web 服务器对于 HTTP 请求的响应头中缺少 X-Download-Options，这将导致浏览器提供的安全特性失效，更容易遭受 Web 前端黑客攻击的影响。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b483309021a6bc717a2ebc45a6517b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee8b94724d90d818c2b6fe532501a140/" rel="bookmark">
			SHELL编程——系统硬件信息数据库收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先创建数据库表：
CREATE TABLE ``audit_audit_system( `id` int(11) NOT NULL AUTO_INCREMENT, `ip_info` varchar(50) NOT NULL, `serv_info` varchar(50) NOT NULL, `cpu_info` varchar(50) NOT NULL, `disk_info` varchar(50) NOT NULL, `mem_info` varchar(50) NOT NULL, `load_info` varchar(50) NOT NULL, `mark_info` varchar(50) NOT NULL, PRIMARY KEY(`id`), UNIQUE KEY `ip_info` (`ip_info`), UNIQUE KEY `ip_info_2` (`ip_info`), ) 然后编写脚本如下：
#!/bin/bash #auto get system info echo -e "\033[34m \033[1m" cat &lt;&lt;EOF +++++++++++++++++++++++++++++++++++++++++++++ +++++++Welcome to use system Collect+++++++++ +++++++++++++++++++++++++++++++++++++++++++++ EOF ip_info=`ifconfig |grep "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee8b94724d90d818c2b6fe532501a140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18b7b2575b74a6233e45fcd8e07823a6/" rel="bookmark">
			java倒计时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private static void time(String sqlDate) { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date jsDate = null; try { // 输入时间转为date jsDate = sdf.parse(sqlDate); } catch (ParseException e) { e.printStackTrace(); } // 获取当前时间 Date nowDate = new Date(); Long qdTime = nowDate.getTime(); Long jsTime = jsDate.getTime(); // 恢复成秒 Long xh = (jsTime - qdTime)/1000; try { String text = "离下班时间还有 "; while (xh &gt; 0) { xh = xh - 5; // int dd = (int) (xh / 60 / 60 * 24); int hh = (int) (xh / 60 / 60 % 12); int mm = (int) (xh / 60 % 60); int ss = (int) (xh % 60); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18b7b2575b74a6233e45fcd8e07823a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fba790aa083d49c571642797bb2d58/" rel="bookmark">
			项目上传GitHub
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目上传GitHub 1. 安装Git客户端2. GitHub注册账号，创建库3.Git命令仓库操作 1. 安装Git客户端 这里就不细述了，网上都有，安装很简单。
2. GitHub注册账号，创建库 同上。
3.Git命令仓库操作 选择上传的文件夹-&gt;右击-&gt;Git Bash Here，打开GitHub命令窗口
2. 输入指令
//初始化git仓库 git init //将本地项目提交至本地仓库 git add . //-m "*" 这里是注释内容（可不写，但最好写上，否则会报错） git commit -m "first commit" //远程连接git仓库（输入HTTPS/SSH地址） git remote add origin git@github.com:yourname/music.git //这里需要SSH KEY，否则会在上传时没有权限被拒绝，详见注（2） //本地仓库推送至远程仓库 git push origin master 注：
（1）HTTPS/SSH
（2）SSH KEY
在GitHub页点击个人头像-&gt;Settings（设置）
在此页创建一个新的密钥New SSH keys，Title栏任填、Key栏填入SSH KEY密钥（这里展示的是已经创建完成的图）
（3）由于本地Git仓库与GitHub仓库之间的传输是通过SSH加密，所以需创建SSH KEY（若C盘用户目录下有.ssh目录，里面有id_rsa和id_rsa.pub这两个文件则无需操作）
//邮箱地址为github注册的邮箱 ssh-keygen -t rsa -C "your_email@youremail.com" //这里是上面操作回车以后系统返回的（不设置密码可直接回车，然后会让你重复密码，继续回车即可） Enter passphrase &lt;empty for no passphrase&gt;: //①输入这个指令会显示SSH密钥 cat ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69fba790aa083d49c571642797bb2d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5599d9639798e1eb4563c6da7cbdafb/" rel="bookmark">
			RabbitMQ介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ是基于AMQP协议的，通过使用通用协议就可以做到在不同语言之间传递。
AMQP协议 核心概念
server：又称broker，接受客户端连接，实现AMQP实体服务。connection：连接和具体broker网络连接。channel：网络信道，几乎所有操作都在channel中进行，channel是消息读写的通道。客户端可以建立多个channel，每个channel表示一个会话任务。message：消息，服务器和应用程序之间传递的数据，由properties和body组成。properties可以对消息进行修饰，比如消息的优先级，延迟等高级特性；body是消息实体内容。Virtual host：虚拟主机，用于逻辑隔离，最上层消息的路由。一个Virtual host可以若干个Exchange和Queue，同一个Virtual host不能有同名的Exchange或Queue。Exchange：交换机，接受消息，根据路由键转发消息到绑定的队列上。banding：Exchange和Queue之间的虚拟连接，binding中可以包括routing keyrouting key：一个路由规则，虚拟机根据他来确定如何路由 一条消息。Queue：消息队列，用来存放消息的队列。 Exchange 交换机的类型，direct、topic、fanout、headers，durability（是否需要持久化true需要）auto delete当最后一个绑定Exchange上的队列被删除Exchange也删除。
Direct Exchange,所有发送到Direct Exchange的消息被转发到RouteKey 中指定的Queue,Direct Exchange可以使用默认的默认的Exchange （default Exchange），默认的Exchange会绑定所有的队列，所以Direct可以直接使用Queue名（作为routing key ）绑定。或者消费者和生产者的routing key完全匹配。Toptic Exchange,是指发送到Topic Exchange的消息被转发到所有关心的Routing key中指定topic的Queue上。Exchange 将routing key和某Topic进行模糊匹配，此时队列需要绑定一个topic。所谓模糊匹配就是可以使用通配符，“#”可以匹配一个或多个词，“”只匹配一个词比如“log.#”可以匹配“log.info.test” "log. "就只能匹配log.error。Fanout Exchange:不处理路由键，只需简单的将队列绑定到交换机上。发送到改交换机上的消息都会被发送到与该交换机绑定的队列上。Fanout转发是最快的。 消息如何保证100％投递 什么是生产端的可靠性投递？ 保证消息的成功发出保证MQ节点节点的成功接收发送端MQ节点（broker）收到消息确认应答完善消息进行补偿机制 可靠性投递保障方案 消息落库，对消息进行打标
消息的延迟投递
在高并发场景下，每次进行db的操作都是每场消耗性能的。我们使用延迟队列来减少一次数据库的操作。
消息幂等性 幂等性是什么？点击这篇文章看下。
我对一个动作进行操作，我们肯能要执行100次1000次，对于这1000次执行的结果都必须一样的。比如单线程方式下执行update count-1的操作执行一千次结果都是一样的，所以这个更新操作就是一个幂等的，如果是在并发不做线程安全的处理的情况下update一千次操作结果可能就不是一样的，所以并发情况下的update操作就不是一个幂等的操作。对应到消息队列上来，就是我们即使受到了多条一样的消息，也和消费一条消息效果是一样的。
高并发的情况下如何避免消息重复消费 唯一id+加指纹码，利用数据库主键去重。
优点：实现简单
缺点：高并发下有数据写入瓶颈。
利用Redis的原子性来实习。
使用Redis进行幂等是需要考虑的问题
是否进行数据库落库，落库后数据和缓存如何做到保证幂等（Redis 和数据库如何同时成功同时失败）？如果不进行落库，都放在Redis中如何这是Redis和数据库的同步策略？还有放在缓存中就能百分之百的成功吗？ confirm 确认消息、Return返回消息 理解confirm消息确认机制
消息的确认，指生产者收到投递消息后，如果Broker收到消息就会给我们 的生产者一个应答，生产者接受应答来确认broker是否收到消息。 如何实现confirm确认消息。 在Channel上开启确认模式：channel.confirmSelect()在channel上添加监听：addConfirmListener，监听成功和失败的结果，具体结果对消息进行重新发送或者记录日志。 return消息机制 Return消息机制处理一些不可路由的消息，我们的生产者通过指定一个Exchange和Routinkey，把消息送达到某一个队列中去，然后我们消费者监听队列进行消费处理！
在某些情况下，如果我们在发送消息的时候当Exchange不存在或者指定的路由key路由找不到，这个时候如果我们需要监听这种不可到达的消息，就要使用Return Listener！
Mandatory 设置为true则会监听器会接受到路由不可达的消息，然后处理。如果设置为false，broker将会自动删除该消息。
消费端自定义监听 消费端限流 什么是消费端的限流？限流算法点击这里阅读。
假设我们有个场景，首先，我们有个rabbitMQ服务器上有上万条消息未消费，然后我们随便打开一个消费者客户端，会出现：巨量的消息瞬间推送过来，但是我们的消费端无法同时处理这么多数据。
这时就会导致你的服务崩溃。其他情况也会出现问题，比如你的生产者与消费者能力不匹配，在高并发的情况下生产端产生大量消息，消费端无法消费那么多消息。
rabbitMQ提供了一种qos（服务质量保证）的功能，即非自动确认消息的前提下，如果有一定数目的消息（通过consumer或者Channel设置qos）未被确认，不进行新的消费。 void basicQOS(unit prefetchSize,ushort prefetchCount,Boolean global)方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5599d9639798e1eb4563c6da7cbdafb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39937895e08007682c300223df893168/" rel="bookmark">
			【VMware Workstation Server】读取描述失败，错误代码：2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、问题：
1、旧版本vmware卸载后，由于vmware相关服务未卸载干净导致新版本无法安装 2、windows系统中vmware需卸载的相关服务无法正常删除
3、VMware Workstation Server服务提示&lt;读取描述失败，错误代码：2&gt; 二、解决办法
1、在windows系统开始菜单的搜索栏中搜索“cmd”,选择以管理员身份运行 2、在cmd命令行窗口输入以下命令，删除vmware相关服务
sc delete VMUSBArbService sc delete VMAuthdService sc delete VMwareHostd 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a6a453bb850d859999e047dd18dc61b/" rel="bookmark">
			【Java设计模式】面向对象设计原则总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象设计原则 单一职责原则 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中
单一职责原则是实现高内聚、低耦合地指导方针
开闭原则 软件实体应当对扩展开放，对修改关闭
软件实体应尽量在不修改原有代码地情况下进行扩展 利用相对稳定地抽象层+灵活的具体层
里氏代换原则定义 所有引用基类的地方必须能透明地使用其子类的对象
在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象 我喜欢动物 → 我喜欢狗
依赖倒转原则 高层不应该依赖低层模块，它们都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
【例】组装电脑
现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选 择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船 等。
上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。
根据依赖倒转原则进行改进： 代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个 组件具体的实现类。
接口隔离原则 客户端不应该依赖那些它不需要的接口
当一个接口太大时，需要将它分割成一些更细小的接口使用该接口的客户端仅需知道与之相关的方法即可每个接口应该承担一种独立的角色 这里借用黑马程序员课程中的例子
我们需要创建一个 黑马 品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防 盗功能提取成一个接口，形成一套规范。类图如下：
上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们 还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现 SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：
这样就实现了接口隔离原则
合成复用原则 优先使用对象组合，而不是继承来达到复用的目的
合成复用原则就是在一个新的对象里通过关联关系来使用一些已有的对象，使之成为新对象的一部分。
【例】汽车分类管理程序
汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色 汽车等。如果同时考虑这两种分类，其组合就很多。类图如下：
从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话， 就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。
迪米特法则 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发 该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b36cd822178170f10be82efc8444904a/" rel="bookmark">
			【python】os模块小实验，文件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OS模块小实验要求：
1.找出当前目录下所有非文件夹的文件
2.统计其中包含有Pyhon单词的文件数量
3.不区分大小写
4.输出文件数量
完整代码：
import os files = os.listdir() yes_file = 0 no_file = 0 filename_python = 0 print("所有非文件夹的文件:") for file in files: is_file = os.path.isdir(file) if(is_file == False): no_file = no_file +1 # 当前目录下所有非文件夹的文件，并统计文件数量 print(file) print("文件数量:", no_file) for file in files: low_filenanme = file.lower() # 文件名转化为小写 check_name = low_filenanme.find('python') # find查找是否有这个词 if(check_name &gt; -1): filename_python = filename_python + 1 print("名称包含Python的文件数量:", filename_python) 运行结果：
所有非文件夹的文件: a.txt ispython.txt pyThon.txt test1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b36cd822178170f10be82efc8444904a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c12797cf95aa6b6ae62a242d0845c53/" rel="bookmark">
			ubuntu vscode C#代码跳转(omnisharp)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要安装omnisharp扩展。
如果直接在有应用商店搜索扩展，那么安装完成之后可能会报错。
这里使用从本地文件的方式进行安装。下载omnisharp扩展文件(后缀名为vsix的文件)。https://github.com/OmniSharp/omnisharp-vscode/files/3191894/csharp-1.15.2.zip
然后从弹出的小框中，选择"从VSIX安装"，开始从本地查找文件（上面下载的zip解压之后的文件，后缀名为vsix）。
然后vscode会自动下载一些文件
PS1：
如果直接进行搜索安装：
这里搜索道德omnisharp版本可能比较新，目前搜到的最新版本是v1.23.17.但是安装完成之后会报错：
fail]: OmniSharp.MSBuild.ProjectManager Attempted to update project that is not loaded: /media/acat/J/Server/Poll_server/Poll_server.csproj 安装v1.15.2版本的omnisharp可以解决这个问题。也就是前文所下载的文件。
PS2:
可能需要在settings.json文件后面添加如下两行（在无法跳转时可以试试）
"omnisharp.useGlobalMono": "always", "omnisharp.path": "latest" PS3:
不知道为啥，用着用着又不能正常跳转了，还出现了报错信息。难搞了，先放一放吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73a0441cdaedfd51b2b1ba072fead949/" rel="bookmark">
			解决T(n)=T(n-1)&#43;n的结果为O(n^2)的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决T(n)=T(n-1)+n的结果为O(n^2)的过程 查了半天资料没查到心中的答案：无语
自己静下心推导了一下：
T(n)
=T(n-1)+n
=T(n-2)+(n-1)+n
=T(n-3)+(n-2)+(n-1)+n
…
=T(0)+1+2+…+(n-2)+(n-1)+n
=1+1+2+…+(n-2)+(n-1)+n
=1+(n+1)*n/2
综上：为O(n^2)
有同学会问T(n)=T(n-1)+1，这个，按照上面的方法递推一遍，你发现最后的结果就是O(n)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cfde6d9607f8e7278a26a5cdd34e32/" rel="bookmark">
			隐藏tab标签完美解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		隐藏第一页：
ui-&gt;tabWidget-&gt;setTabEnabled(0, false);
ui-&gt;tabWidget-&gt;setStyleSheet(“QTabBar::tab:disabled {width: 0; color: transparent;}”);
显示第一页：
ui-&gt;tabWidget-&gt;setTabEnabled(0, true);
ui-&gt;tabWidget-&gt;setStyleSheet(“QTabBar::tab:disabled {width: 20; color: transparent;}”);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4fa9f421b23dc075a830b4e1b0edf95/" rel="bookmark">
			springboot 整合rabbitMq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMq入门 RabbitMq名词 queue队列
最最最核心的队列，用于存储消息
exchange
交换机，用来接收消息，发送到队列
routing key
路由，生产者发送消息到交换机，一般会指定路由key，用来指定发送到绑定的哪个队列
virtual
虚拟机，类似于不同的数据库
消息类型 Hello World
生产者直接发送消息到队列，消费者直接从队列获取消息
发送消息时，只需要指定队列，不需要指定交换机，以及路由key，只有一个消费者
Work queues
发送消息时，只需要指定队列，不需要指定交换机，以及路由key，设定多个消费者
Publish/subscribe
广播模型交换机，发送消息时，需要新建Fanout交换机，队列，交换机和队列绑定时，不需要路由key，所以队列都能获取到交换机中的消息；消息发送时需要指定交换机，消息接收时需要指定队列，每个消息都会发送到不同的队列，并且每个队列都会被消费一次；
Routing
Declare交换机类型，发送消息时，需要新建Declare交换机，队列，交换机和队列绑定时，需要指定routing key；如果不指定，则所有消息都会发送到该队列；消息发送时，需要指定交换机，还有Routing key，每个消息会根据不同的Routing key，发送到不同的队列，消费者绑定不同的队列来获取消息；
Topics
Topic交换机类型，发送消息时，需要新建Topic交换机，队列，交换机和队列绑定时，需要指定routing key，routing key指定有个规则（列如 发送 CN.HUNAN.CHANGSHA 指定routing key CN.HUNAN.* 或者 CN.# 队列能接受到消息；*只能代表一个单词，#可以代表多个单词）；发送消息时，和Routing模式是一样的，指定交换机以及routing key，发送到不同的队列，消费者绑定不同的队列来获取消息；
配置 maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; yml配置 spring: rabbitmq: host: 127.0.0.1 #ip port: 5672 #端口 username: guest #账号 password: guest #密码 virtual-host: / #链接的虚拟主机 # addresses: 127.0.0.1:5672 #多个以逗号分隔，与host功能一样。 # requestedHeartbeat: 60 #指定心跳超时，单位秒，0为不指定；默认60s # publisherConfirms: true #消息发送到交换机确认机制,是否确认回调 # publisherReturns: #消息发送到交换机确认机制,是否返回回馈 # connectionTimeout: #链接超时。单位ms。0表示无穷大不超时 # ### ssl相关 # ssl: # enabled: #是否支持ssl # keyStore: #指定持有SSL certificate的key store的路径 # keyStoreType: #key store类型 默认PKCS12 # keyStorePassword: #指定访问key store的密码 # trustStore: #指定持有SSL certificates的Trust store # trustStoreType: #默认JKS # trustStorePassword: #访问密码 # algorithm: #ssl使用的算法，例如，TLSv1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4fa9f421b23dc075a830b4e1b0edf95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f976644fa31a966ad83321380a5fe816/" rel="bookmark">
			加密方式汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		加密技术 加密技术大体上分为 双向加密 和 单向加密 ，而双向加密又分为 对称加密 和非对称加密。
双向加密即明文加密后形成的密文，可以通过逆向算法还原出明文。而单向加密只是对信息进行了摘要计算，不能通过算法逆向生成明文。
单向加密从严格意思上说不能算是加密的一种，而只是摘要算法，常见的单向加密技术有BASE64(一种编码形式)、MD5、SHA、HMAC(消息认证码)。
双向加密技术可以分为 对称加密 与 非对称加密 两种。
（1）对称加密：即加密与解密用的是同一把秘钥，常用的对称加密技术有DES、AES等。
（2）非对称加密：加密与解密用的是不同的秘钥，常用的非对称加密技术有RSA等。
Java 对称加密（常见的对称加密算法：DES，AES，3DES等等）
1、DES算法
DES是1977年美国联邦信息处理标准中使用的一种对称密码技术，曾今被美国和其他国家政府银行使用。
不过现在已被暴力破解，不再安全可靠，我们除了用它解密以前的密文外，已不再使用DES了
2、AES
AES密码学中的高级加密标准（Advanced Encryption Standard，AES），又称 高级加密标准Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。目前美国国家安全局使用的，苹果的钥匙串访问采用的就AES加密。是现在公认的最安全的加密方式，是对称密钥加密中最流行的算法。
/***************************************************** * AES加密 * @param content 加密内容 * @param key 加密密码，由字母或数字组成 此方法使用AES-128-ECB加密模式，key需要为16位 加密解密key必须相同，如：abcd1234abcd1234 * @return 加密密文 ****************************************************/ public static String enCode(String content, String key) { try { byte[] raw = key.getBytes(); //获得密码的字节数组 SecretKeySpec skey = new SecretKeySpec(raw, "AES"); //根据密码生成AES密钥 Cipher cipher = Cipher.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f976644fa31a966ad83321380a5fe816/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9853124d624161a4b53fc5c37454407/" rel="bookmark">
			如何有效建立触摸屏与PLC之间无线通讯？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要建立触摸屏与PLC之间无线通讯其实很简单，接下来，我们就来详细说说威纶通触摸屏与三菱FX3U PLC基于三菱专用协议下的无线通信实现方法。
首先你需要一台威纶通触摸屏作为主站，两台三菱FX3U PLC（485BD扩展）作为从站，并采用无线通讯终端DTD435MC作为实现无线通讯的硬件设备。
无线网络图 ▼
接线方式
1.触摸屏与达泰无线设备的接线
第一步：将触摸屏专用Rs485数据线红色导线与DTD435MC的A端口相连接； 将触摸屏专用Rs485数据线黑色导线与DTD435MC的B端口相连接
第二步：给无线通讯终端接入天线
第三步：全部接线结束后，分别给触摸屏与无线通讯终端供电
2.PLC与达泰无线设备的接线
FX3U通讯口使用485BD模块，因为FX3U-485BD口是四线制的，所以需要将RDA和SDA短接接入A（485+,CN2-4），再将RDB和SDB短接接入B（485-,CN2-5）。
威纶通触摸屏主站设置
1.系统参数设置
2.触摸屏画面制作
3.1号从站设置
4.2号从站设置
三菱PLC从站设置
1.PLC的设置
2.PLC站号的设备
3.将程序下载到PLC
无线通讯测试
威纶通触摸屏和FX3U分别接1块DTD435MC-V96
通过外部给1号站和2号站X点信号，看触摸屏对应的点是否有亮，如果点亮，表示通讯正常。
通过触摸屏上面的按钮给1号站和2号站Y点信号，看FX3U对应的Y点是否有亮，如果点亮，表示通讯正常。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e06845ce3459aba2b6f4956123477c/" rel="bookmark">
			【机器学习】决策树案例一：利用决策树进行年龄与音乐类型喜好分类预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用决策树进行年龄与音乐类型喜好分类预测 1 利用决策树进行年龄与音乐类型喜好分类预测1.1 导入模块与加载数据1.2 划分数据1.3 模型创建与训练1.4 模型应用1.5 模型可视化1.6 数据核验 手动反爬虫，禁止转载： 原博地址 https://blog.csdn.net/lys_828/article/details/122041951（CSDN博主：Be_melting） 知识梳理不易，请尊重劳动成果，文章仅发布在CSDN网站上，在其他网站看到该博文均属于未经作者授权的恶意爬取信息 1 利用决策树进行年龄与音乐类型喜好分类预测 1.1 导入模块与加载数据 import pandas as pd music_df1= pd.read_csv('../data/music.csv') music_df1.head() 输出结果如下。
数据读入之后，可以简单看一些各个字段的情况，使用info()方法进行输出。
music_df1.info() 输出结果如下。本案例属于对于决策树模型使用的基本流程进行认知，数据已经被处理干净，而且字段相对较少。
1.2 划分数据 划分特征数据和标签数据。
X = music_df1.drop(columns=['genre']) X.head() y = music_df1['genre'] y.head() 输出结果如下。
1.3 模型创建与训练 导入创建模型的模块，此案例是进行决策树分类，注意不是回归，然后再进行模型初始化。这里没有进行训练模型和测试模型的划分，而是直接将全部的数据进行应用到模型中。
from sklearn.tree import DecisionTreeClassifier model = DecisionTreeClassifier() model.fit(X,y) 输出结果如下。
1.4 模型应用 模型训练完毕后，可以直接用于预测，也可以将模型保存在本地，遇到问题时候再调用。首先进行直接预测，比如任意输入两个字段的数据，看看模型最终预测的结果如何。
test_set=[[31,0]] prediction = model.predict(test_set) prediction test_set=[[21,1]] prediction = model.predict(test_set) prediction test_set=[[31,0],[21,1]] prediction = model.predict(test_set) prediction 输出结果如下。注意predict()方法中传入的是二维列表，其中可以放置单一的两个字段的数据，也可以输出多个两字段的数据，即完成单数据的分类预测和多数据的分类预测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e06845ce3459aba2b6f4956123477c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32a7a602a2b19077be6df6b343bb421e/" rel="bookmark">
			JAVACV 中断报错：Error: [h264 @ 00000181aa66e6c0] error while decoding MB 91 47, bytestream -5，图像延时问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先个人感觉JAVACV这个库不好用，内部API基本上没有注释
FFmpegFrameGrabber grabber = FFmpegFrameGrabber.createDefault(rtspUrl); log.info("创建grabber成功"); grabber.setOption("rtsp_transport", "tcp"); grabber.setFrameRate(frameRate); //设置获取的视频宽度 grabber.setImageWidth(frameWidth); //设置获取的视频高度 grabber.setImageHeight(frameHeight); //设置视频bit率 grabber.setVideoBitrate(2000000); FFmpegLogCallback.set(); grabber.start(); log.info("grabber.start"); Java2DFrameConverter java2DFrameConverter = new Java2DFrameConverter(); while (true){ Frame frame = grabber.grabImage(); if (null == frame) { continue; } BufferedImage bufferedImage = java2DFrameConverter.getBufferedImage(frame); byte[] bytes = imageToBytes(bufferedImage, "jpg"); byte2image(bytes); // 抓取延时2s Thread.sleep(2000); } /** * byte数组到图片 * * @param data */ int num = 0; public void byte2image(byte[] data) { if (data.length &lt; 3) { return; } try (FileImageOutputStream imageOutput = new FileImageOutputStream(new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32a7a602a2b19077be6df6b343bb421e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a679382d01c28e9fe98b2a8e5280ef1d/" rel="bookmark">
			python进行ecc签名与验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Python生成ecc秘钥，与签名验证 import ecdsa import hashlib from ecdsa.util import sigencode_der,sigdecode_der ecc_pri = ecdsa.SigningKey.generate(curve=ecdsa.NIST256p) sign_dat = ecc_pri.sign(b'123456', entropy=None, hashfunc=hashlib.sha256, sigencode=sigencode_der) print(sign_dat) ecc_pub = ecc_pri.get_verifying_key() result = ecc_pub.verify(sign_dat, b'123456', hashfunc=hashlib.sha256, sigdecode=sigdecode_der) print(result) #验证成功返回True with open('ecc_sig.data','wb') as f1: f1.write(sign_dat) with open('ecc_pub.pem','wb') as f2: f2.write(ecc_pub.to_pem()) 2、openssl验证签名 3、导入外部ECC秘钥进行签名 #使用openssl的外部私钥与公钥 import ecdsa import hashlib from ecdsa.util import sigencode_der,sigdecode_der with open('ecc_prikey.key', 'rb') as f1: pem_pri=f1.read() with open('ecc_pub.key', 'rb') as f2: pem_pub=f2.read() pri_ecc = ecdsa.SigningKey.from_pem(pem_pri) print(pri_ecc) #私钥对象 pub_ecc = ecdsa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a679382d01c28e9fe98b2a8e5280ef1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bf16f6d631639381987bfd0192f3849/" rel="bookmark">
			WEB应用程序开发(六)创建Session对象与实现界面安全退出/登录功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WEB应用程序开发之创建Session对象与实现界面安全退出/登录功能 什么是session创建Session思维图 代码测试与结果Session方法Session生命周期创建方式销毁方式一. 服务器关闭二. 长时间不调用自动销毁三. 调用invalidate()方法 销毁session 安全退出 什么是session Session对象是javax.servlet.http.HttpSession的实例
它在第一个JSP页面被装载时自动创建，完成会话期管理。
从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。
Servlet API中，定义了HttpSession接口，用来封装会话对象, HttpSession是接口，会话对象是Web容器创建的，在Servlet中使用
HttpServletRequest中的方法获得会话对象
public HttpSession getSession()：获取跟当前请求相关的session，如果不存在session，就创建一个新的session对象返回
下来是展示Session实现会话机制的过程
创建Session思维图 代码方面新增两行代码,放置在之前设置好的LoginServlet对象中
//获取服务器生成的session对象 HttpSession httpSession=req.getSession(); //向session对象设置一段键值,登陆成功后将用户信息储存到一个对象的session对象中 httpSession.setAttribute("user",user); public class LoginServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter out = null; try { resp.setContentType("text/html;charset=utf-8");//响应格式设置 req.setCharacterEncoding("utf-8");//设置post请求数据解码格式 String account = req.getParameter("account"); String password = req.getParameter("password"); System.out.println(account); System.out.println(password); LoginDao loginDao=new LoginDao(); User user= loginDao.checkLogin(account,password); out= resp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bf16f6d631639381987bfd0192f3849/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b79f9a7c60cf28185acf1b7d17d0212/" rel="bookmark">
			MD5详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、介绍
二、特点
1、不可逆
2、抗碰撞
三、性质
四、用途
1、防止被篡改
2、防止直接看到明文
3、防止抵赖（数字签名）
五、算法原理
1、数据填充
2、添加消息长度
3、数据处理
（1）4个链接变量
（2）4个非线性函数
（3）4种操作（轮函数）
4、MD5运算
六、破解
七、MD5较MD4所做的改进
一、介绍 属于Hash算法。MD5对输入任意长度的消息产生一个128位（16个字节）的消息摘要。
二、特点 1、不可逆 相同数据的md5值肯定一样，不同数据的md5值不一样。即，不可能从结果逆向推导初始值。不可逆是因为有很多不可逆的算法，会丢失很多原文信息，比如移位。
2、抗碰撞 根据一个输入，找到一个输入得到相同的输出，不可行。抗碰撞并不是无碰撞，因为散列算法会有碰撞。
三、性质 1、压缩性：任意长度的数据，算出的md5值长度都是固定的（超损压缩）
2、容易修改：从原数据计算出md5值很容易
3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的md5值都有很大区别
4、弱抗碰撞：已知原数据和其md5值，想找到一个具有相同的md5值的数据是非常困难的
5、强抗碰撞：想找到两个不同的数据，使他们具有相同的md5值，是非常困难的
四、用途 1、防止被篡改 （1）比如发送一个电子文档，发送前，我先得到MD5的输出结果a。然后在对方收到电子文档后，对方也得到一个MD5的输出结果b。如果a与b一样就代表中途未被篡改。
（2）比如文件下载，为了防止不法分子在安装程序中添加木马，就可以在网站上公布由安装文件得到的MD5输出结果。
（3）SVN在检测文件是否在CheckOut后被修改过，也是用到了MD5。
2、防止直接看到明文 现在很多网站在数据库存储用户的密码的时候都是存储用户密码的MD5值。这样就算不法分子得到数据库的用户密码的MD5值，也无法知道用户的密码。当用户登录的时候，系统把用户输入的密码计算成MD5值，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这不但可以避免用户的密码被具有系统管理员权限的用户知道，而且还在一定程度上增加了密码被破解的难度。
3、防止抵赖（数字签名） 这需要一个第三方认证机构。例如A写了一个文件，认证机构对此文件用MD5算法产生摘要信息并做好记录。若以后A说这文件不是他写的，权威机构只需对此文件重新产生摘要信息，然后跟记录在册的摘要信息进行比对，相同的话，就证明是A写的了。这就是所谓的“数字签名”。
五、算法原理 1、数据填充 对消息进行数据填充，使消息的长度对512取模得448，设消息长度为X，即满足X mod 512=448。根据此公式得出需要填充的数据长度。
填充方法：在消息后面以位为单位进行填充，填充第一位为1，其余为0。第一个填充的是0x00（1000 0000），然后就填0x0。(此时消息长度为N*512+448)
2、添加消息长度 在第一步结果之后再填充上原消息的长度，可用来进行的存储长度为64位。如果消息长度大于264，则只使用其低64位的值，即（消息长度 对 264取模）。在此步骤进行完毕后，最终消息长度就是512的整数倍。(此时消息长度为(N+1)*512 )
3、数据处理 （1）4个链接变量 首先是四个常数：
A=0x01234567
B=0x89ABCDEF
C=0xFEDCBA98
D=0x76543210
如果在小端模式中，应该是：
A=0x67452301
B=0xEFCDAB89
C=0x98BADCFE
D=0x10325476
它们被称为链接变量（chaining variable）
（2）4个非线性函数 F(X，Y，Z)=(X&amp;Y)|((~X)&amp;Z)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b79f9a7c60cf28185acf1b7d17d0212/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10469cfac7cfce28df67c1b8a83d95d5/" rel="bookmark">
			Zabbix配置钉钉的带图片报警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号：运维开发故事，作者：wanger
实现思路：
首先报警信息里要有itemid，这是前提，根据信息里传入的参数使用正则匹配到itemid
构建一个session会话，或者使用cookie来进行登录，根据itemid去请求图片，并将获取到的图片保存到本地，由于markdown的图片链接需要被访问到，我的zabbix是在内网中，所以需要将图片传到图床或者传到一个具有公网IP的web服务器，我这里传到了我的个人服务器
将报警信息转换成markdown语法格式
构造请求利用钉钉的webhook发送消息
设置钉钉机器人 钉钉机器人需要进行安全设置，这里我定义了关键词”通知“，也就是说发送的消息中必须包含这个词 脚本实现 由于需要将图片从本地拷到远端，免密需要提前配置好，脚本是用zabbix用户执行，Web服务器目录的安全策略最好设置一下 #!/usr/bin/python # -*- coding: utf-8 -*- import requests,time import json,sys,re,os zabbixserver_url ='http://192.168.99.200/index.php' #定义远端的web服务器地址，将图片复制到远端的web目录下 pname_path='http://47.103.15.51/dingding_pic/' #定义获取的图片地址 testUrl = "http://192.168.99.200/chart.php" host='192.168.99.200' def get_itemid(): itemid=re.search(r'ITEM ID:(\d+)',sys.argv[2]).group(1) return itemid def get_picture(itemid,pname): #构建session，或者可以一次构建之后使用cookie登录 myRequests = requests.Session() try: loginHeaders = { "Host":host, "Accept":"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8" } # 构建登录所需的信息 playLoad = { "name": "Admin", "password": 'zabbix', "autologin": "1", "enter": "Sign in", } myRequests.post(url=zabbixserver_url, headers=loginHeaders, data=playLoad) testUrlplayLoad = { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10469cfac7cfce28df67c1b8a83d95d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4ca7b90f94b5afa3d73749e4c6f115/" rel="bookmark">
			海信IP906H-FV IP906H-FV1固件刷机 电信融合机终端 卡刷固件及教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 固件特点： 1、调出原厂固件屏蔽的wifi，开放原厂固件屏蔽的市场安装和u盘安装apk；
2、无开机广告，无系统更新，不在被强制升级；修改dns，三网通用；
3、大量精简内置的没用的软件，运行速度提升30%以上，多出大量的存储空间；
4、去除应用安装限制，实现自由安装软件；
5、支持开机自启动、开机密码锁、儿童应用锁、应用隐藏、开机自动进入HDMI等各种花式功能；
6、固件压缩包有刷机教程，解压获取。
刷机方法： 把下载的刷机包4个文件放入U盘根目录，并插入盒子靠高清接口处的USB接口。 然后用顶针顶住REC复位按钮不放手，通电等待进入刷机进度条页面放开短接！ 等待刷机完毕自动重启，完成刷机。
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
刷机固件：
链接:https://pan.baidu.com/s/1Kfn85oqDBFYxYZ9TRtnwPA 提取码:k9yb 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d068860b1d987e8efb50c751475554/" rel="bookmark">
			java 文件尾部或任意位置追加内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不多bb,上代码
@Test void f1() throws IOException{ File file = new File("./a.txt"); byte[] s="123456".getBytes(); //方法一 OutputStream out=new FileOutputStream(file,true);// 如果为true ，则字节将写入文件的末尾而不是开头 out.write(s); //方法二 RandomAccessFile randomAccessFile=new RandomAccessFile(file,"rw");// w写,r读 randomAccessFile.seek(file.length());//调整文件指针,学过C/C艹的应该知道 randomAccessFile.write(s); } 其中 RandomAccessFile 更为灵活 , 不过OutputStream安全点,自己取舍
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64307be632003349fe690bd96ed97c0d/" rel="bookmark">
			git提交后push中出现之前的提交的代码或者其他人提交的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git提交后push中出现之前的提交的代码或者其他人提交的代码 问题现象1、项目最外层目录的pom.xml文件，右键输入git reset --mixed HEAD~7指令，撤销commit的全部内容2、如果出现红色的未提交的代码，使用项目右键 -&gt; Git -&gt; Add 把全部代码提交成绿色状态，把红色的部分变成绿色的。3、Pull本分支代码4、通过文件右键查看历史记录，用来处理自己更改的代码被回退的问题5、更改完成确认代码无误后再次提交并且Push即可 注意：使用这个需要注意，后面的操作，自己操作过的代码(蓝色)会还原(白色)，新建的代码会变成未提交的状态(绿色)，所以需要记录下自己更改过的代码位置，方便去本地还原。使用缓存区处理这个问题的话，问题会依然存在。 问题现象 1、项目最外层目录的pom.xml文件，右键输入git reset --mixed HEAD~7指令，撤销commit的全部内容 注：7，是前7行提交的行数，撤销后会把push里面所有的代码都加载到本地，也就是代码是蓝色和红色的状态。最好数一下，如果大于提交的行数的话会还原以前提交的代码到本地，这个时候不是你提交的代码还原就好，比较麻烦，尽量避免。
2、如果出现红色的未提交的代码，使用项目右键 -&gt; Git -&gt; Add 把全部代码提交成绿色状态，把红色的部分变成绿色的。 注：因为有红色的代码就无法进行Pull的操作，在项目右键使用回退也可以，回退不太建议使用，会导致代码遗失更多。
3、Pull本分支代码 注：会保留自己未提交的代码，全部蓝色的代码会还原为白色，新建的会变成绿色，说明处理成功。
把别人提交的代码尽量还原，只保留自己之前想提交的部分，代码只有白色和绿色的即可。
4、通过文件右键查看历史记录，用来处理自己更改的代码被回退的问题 注：如果没有蓝色的代码被回退，跳过此步骤就好
5、更改完成确认代码无误后再次提交并且Push即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b46072a3a8588886fa4874fd06eb0f4/" rel="bookmark">
			图解单值二叉树和二叉树最大深度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
单值二叉树
思路
二叉树最大深度
思路：
实现代码
图解代码
单值二叉树 力扣
思路 左子树和跟比看是否相同，右子树和跟比看是否相同 一直递归下去
bool isUnivalTree(struct TreeNode* root){ if(root == NULL) return true; //注意root-&gt;left!= NULL 否者会出现NULL访问val if(root-&gt;left &amp;&amp; root-&gt;val != root-&gt;left-&gt;val) return false; if(root-&gt;right &amp;&amp; root-&gt;val != root-&gt;right-&gt;val) return false; //左右子树递归时要用 &amp;&amp; 返回值要么为1(true),要么为假(0); return isUnivalTree(root-&gt;left) &amp;&amp; isUnivalTree(root-&gt;right); } 二叉树最大深度 力扣
思路： 任何一颗二叉数都可以看作，根+左子树+右子树 所以找出左右子树较大深度的那个+1就是其深度 实现代码 int maxDepth(struct TreeNode* root){ //没有节点，既深度0 if(root == NULL) return 0; //先保存一下左右子树 再用三目操作符 //直接递归的话递归的次数会变得巨大 int lefttree = maxDepth(root-&gt;left); int righttree = maxDepth(root-&gt;right); //左右子树相比 较大的那个+1 return lefttree &gt; righttree ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b46072a3a8588886fa4874fd06eb0f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109386f88d1cf8cb9e40dff5e90c7f4a/" rel="bookmark">
			【Kalibr】问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
一、在标定imu和camera时，由于采集的数据较多，标定过程中出错
提示：“Spline Coefficient Buffer Exceeded. Set larger buffer margins”
路径：/home/Downloads/project/kalibr_ws/src/Kalibr/aslam_nonparametric_estimation/aslam_splines/src/BSplineExpressions.cpp 447行
所以，这里人为的将_bufferTmax提高，
423行：_bufferTmax = _spline-&gt;spline().timeInterval(_bufferRight).second*
改为：_bufferTmax = _spline-&gt;spline().timeInterval(_bufferRight).second*10;
提高十倍。
二 igraph报错
https://blog.csdn.net/boyhoodme/article/details/115642521
https://www.cnblogs.com/guoben/p/13339297.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93b81e8d78df4dfc0fc5f4d21b41d307/" rel="bookmark">
			如何将python文件打包成exe格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 如何将python文件打包成exe格式1、安装pyinstallerimage-202112172208230072、进入python文件的存储位置3、生成exe文件4、pyinstaller详解 如何将python文件打包成exe格式 1、安装pyinstaller 打开命令行，安装pyinstaller模块
pip install pyinstaller 若出现如下图所示的无法连接HTTPS的问题请参考文章：成功解决win10下 Can’t connect to HTTPS URL because the SSL module is not available
查看是否安装成功
pip list 2、进入python文件的存储位置 看自己的保存路径
3、生成exe文件 执行命令
pyinstaller -F tree.py(要打包的脚本文件) 执行完成之后会新增如下图所示的文件
而我们所需要的exe文件就在dist文件夹下面
点击就可以运行了
4、pyinstaller详解 Pyinstaller -F tree.py 打包exe Pyinstaller -F -w tree.py 不带控制台的打包 Pyinstaller -F -w -i tree.ico tree.py 打包指定exe图标打包 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f60b03c127d0b3e8b7c876a5e19d7696/" rel="bookmark">
			考研准考证下载方式【当无法下载或者找到地址时】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、登陆账号后，进入下载页面 https://yz.chsi.com.cn/apply/kscx/kscx.do
2、右击鼠标-查看网页源代码 3、搜索confirmSubmit 将图中的字符串，删除所有的单双引号以及+号，拼接起来：
location.assign(’/apply/kscx/zkzdown.do?bmh=’+“3XXXXXX6”+’&amp;trnd=’+“4XXXXXX-XXXX-XXXX-XXXX-XXXXXXX”);
拼成下面的网址，直接打开就开始下载准考证了，我自己试了一下还是旧的证。
https://yz.chsi.com.cn/apply/kscx/zkzdown.do?bmh=3XXXXXX6&amp;trnd=4XXXXXX-XXXX-XXXX-XXXX-XXXXXXX
bmh 是报名号，不变；trnd每次刷新页面变换一下
PS：应该是简单的字符串拼接，后面再看两个数字有变化的话应该就是更新了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abb7b550409de1e15ce478d55e0bd708/" rel="bookmark">
			华为盒子EC6108V9A-RK3128-1&#43;4G 免拆机 卡刷固件及教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 固件特点： 1、调出原厂固件屏蔽的wifi，开放原厂固件屏蔽的市场安装和u盘安装apk；
2、无开机广告，无系统更新，不在被强制升级；修改dns，三网通用；
3、大量精简内置的没用的软件，运行速度提升30%以上，多出大量的存储空间；
4、去除应用安装限制，实现自由安装软件；
5、支持开机自启动、开机密码锁、儿童应用锁、应用隐藏、开机自动进入HDMI等各种花式功能；
6、本固件不支持高安版，本固件不支持CA版、上海电信CA、四川电信CA版。
刷机方法：
1、准备FAT32格式的4G或者8G容量的U盘，如果是有多个文件的u盘，最好先格式化清空一下u盘。在U盘根目录下新建upgrade文件夹，然后将下载的update.zip固件包拷到upgrade文件夹里（切勿将update.zip固件包解压）；
2、将装有升级固件的u盘插到靠近网口一端的USB口；
3、然后拔掉电源重新插上开机，然后立即重复按遥控器待机键，不停的按，直到进入recovery界面，然后选择第一项，如下图所示，然后就会出现刷机进度条，等待进度条走完即刷机成功； PS：如果你的盒子固件是2017.7以后官方更新的固件，则需要开机通过来回交替不停的按遥控的左右方向键，进入recovery界面，选择第二项 从外部设备即U盘刷机（界面是英文的）；
4、刷机成功后即进入桌面，此固件除了桌面和市场，无其他任何预装！非常干净！
声明：本安卓固件，仅供内部测试和技术交流使用，任何非法商业使用及商业利益冲突带来的法律纠纷，与本人无关，本人概不负责，请下载后24小时内删除，谢谢合作！刷机既有乐趣也有风险，请慎重选择，一切源于刷机造成的后果自负，本人概不负责！
刷机包获取： 链接: https://pan.baidu.com/s/1eRk5N2wOQwEdG_hKCWWiUQ 提取码:6s88 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2672efb1890b073cb69b4dd6bd1ddf26/" rel="bookmark">
			用python画圣诞树、樱花树、卡通图案及打包成exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 用python画圣诞树、樱花树、卡通图案及打包成exe文件效果1、圣诞树--朴素2、圣诞树--可爱3、圣诞树--飘雪4、樱花树--飘落效果5、樱花树--暖色调6、哆啦a梦 用python画圣诞树、樱花树、卡通图案及打包成exe文件 如何将python代码生成exe文件，直接在桌面运行请参考文章：如何将python文件打包成exe格式
效果 1、圣诞树–朴素 import turtle # 定义圣诞树的绿叶函数 def tree(d, s): if d &lt;= 0: return turtle.forward(s) tree(d - 1, s * .8) turtle.right(120) tree(d - 3, s * .5) turtle.right(120) tree(d - 3, s * .5) turtle.right(120) turtle.backward(s) n = 100 turtle.speed('fastest') # 设置速度 turtle.left(90) turtle.forward(3 * n) turtle.color("orange", "yellow") turtle.left(126) # turtle.begin_fill() for i in range(5): turtle.forward(n / 5) turtle.right(144) turtle.forward(n / 5) turtle.left(72) turtle.end_fill() turtle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2672efb1890b073cb69b4dd6bd1ddf26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb05787d38fd608471caca9a3f820e7c/" rel="bookmark">
			SpringBoot开启热部署（修改html和静态资源不需要重启项目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置 首先在settings中打开此选项
在pom.xml中添加
&lt;!-- 热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 在配置文件中添加
spring: devtools: restart: enabled: true # 配置热部署 additional-paths: src/main/java exclude: WEB-INF/** 此时配置便已经完成
使用 修改完点击这里即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc83a3f30ca9fbaefddc2dc63092e258/" rel="bookmark">
			mavon-editor 富文本编辑器图片上传和获取html，markdown节点信息 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.下载安装 npm install mavon-editor --save 二.全局挂载和使用 import mavonEditor from "mavon-editor"; import "mavon-editor/dist/css/index.css"; Vue.use(mavonEditor); 三.组件封装即使用 &lt;template&gt; &lt;div&gt; &lt;mavon-editor ref="md" placeholder="请输入文档内容..." :boxShadow="false" style="z-index: 1; border: 1px solid #d9d9d9; height: 50vh" v-model="content" @imgAdd="$imgAdd" :toolbars="toolbars" @save="saveMavon" @change="changeMavon" &gt;&lt;/mavon-editor&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: "home", components: {}, props: ["markdownData"], data() { return { content: "", // 文本域的值 html: "", //上传图片的地址 markdown: "", //左侧 markdown 内容 toolbars: { bold: true, // 粗体 italic: true, // 斜体 header: true, // 标题 underline: true, // 下划线 strikethrough: true, // 中划线 mark: true, // 标记 superscript: true, // 上角标 subscript: true, // 下角标 quote: true, // 引用 ol: true, // 有序列表 ul: true, // 无序列表 link: true, // 链接 imagelink: true, // 图片链接 code: true, // code table: true, // 表格 fullscreen: true, // 全屏编辑 readmodel: true, // 沉浸式阅读 htmlcode: true, // 展示html源码 help: true, // 帮助 /* 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc83a3f30ca9fbaefddc2dc63092e258/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f73cde183d807d71cc2f5f4bc7c699c/" rel="bookmark">
			C语言实现快速排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
序
嗨，这里是狐狸~~ 快速排序的思想：
快速排序的流程：
整个算法处理过程：
算法动态演示：
代码如下：
总结
序 愿天上的每一个流星，都为你而闪耀天际。
嗨，这里是狐狸~~ 今天是2021年12月17日，星期五，距离2022年还有14天，今天又来和大家见面了，时光荏苒，趁还有些时日，多发些有用的知识出来，也希望大家可以认真看，认真学，不要任当下时间流逝了。
好，今天来讲什么呢？讲下排序算法吧，全部讲完肯定不可能，我们今天来看下其中的一种——快速排序，带大家一起学习快速排序算法。
快速排序的思想： 1 先从数组中选取一个数作为基准点，可随机选择；
2 将数组中大于该基准点的放在该基准点右边，小于该基准点的放在该基准点左边；
3 对左右两个数组进行快速排序。
快速排序的流程： 整个算法处理过程： 算法动态演示： 代码如下： 让我们来看下怎么实现快速排序算法
#include &lt;stdio.h&gt; void swap(int a[], int low, int high) //交换两个数的值 { int t = a[low]; a[low] = a[high]; a[high] = t; } int partition(int a[], int low, int high) //计算基准点，分割为左右两个数组 { int point = a[low];//基准点等于第一个元素 /* while(1){ while(low&lt;high &amp;&amp; a[++low]&lt;point); while(a[--high]&gt;point); if(low&gt;=high) break; */ while(low&lt;high) { while(low&lt;high &amp;&amp; a[high]&gt;=point)//控制high指针比较并左移 { high--; } swap(a,low,high); //} while(low&lt;high &amp;&amp; a[low]&lt;=point)//控制low指针比较并右移 { low++; } swap(a,low,high); } return low;//返回基准点位置 } void quicksort(int a[], int low, int high) //low:起始位置 high:末尾位置 { if(low&lt;high){ int point = partition(a,low,high);//计算基准点 quicksort(a,low,point-1); //对基准点的左边进行排序 quicksort(a,point+1,high);//对基准点的右边进行排序 } } int main() { int i; int a[] = {5,13,6,24,2,8,19,27,6,12,1,17}; int N = 12; quicksort(a, 0, N-1); for(i=0; i&lt;N; i++) printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f73cde183d807d71cc2f5f4bc7c699c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f64b2e05a3d152742f683b39e2ca0a/" rel="bookmark">
			我想起那天在夕阳下的口胡，那是我逝去的青春。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		退役三周了，前两周忙着给结训赛出题，闲下来的这周百无聊赖。我早已有写退役记的想法，但大四比赛爆炸，也就一直拖着没写。现在想想，怎么能因为结果不顺心，而忽略过程中的美好呢？
先列一下重要的时间记录
时间事件2015.09进章丘四中读高中2015-2018初小学对数学半懂不懂的我对高中数学展现出极强的兴趣2017-2018渐渐喜欢上她2018.06-2018.09高考爆炸，与她相差 50 50 50 多分，她去了 OUC，我来了 SDNU2018.09参加 ACM 招新宣讲，但没当一回事，于是没参加笔试2018.09参加学生会纳新，失败2018.09晚上听两名舍友 qp 和 sxf 谈论 ACM 学到的知识，非常感兴趣，花两天学完了 C 语言语法，准备刷题入队2018.10国庆没刷题，而是写了个奇怪的程序2018.11国庆回来后开始猛刷题，一周刷到 50 50 50 题并顺利通过面试入队（梦开始的地方~~2019.05与 lyd 和 sxf 组成第一支队伍参加省赛，拿到第一块铜牌2019.07-2019.09sxf 跑路，把 lzw 拉过来组队2019.10参加银川站，拿到第一块区域赛铜牌（赛后才发现蓝书里居然有金牌题原题，没做到好亏），赛后 lyd 退役2019.12与 wx 组队，BreakFast 正式成立！！！2019.12稀里糊涂地成为 18 级 ACM 队队长2020.01与 lzw 去秦皇岛参加了 wannafly camp，结识 lyh 巨佬2020.01疫情开始，身为最菜队长的我开始猛刷蓝书，水平迅速提升2020.11CCPC 绵阳站 BreakFast 开门铁，自闭的同时开始反思训练方法的不足，之后 wx 永无上机机会2020.11蓝桥杯 B 组国一，rk 212020.12ICPC 济南站热身赛凭实力爆零，正式赛拿银2021.04EC Final 顺利打铁，一题罚坐到比赛结束2021.05省赛又是破铜烂铁，与心理预期相差太大，第二天跟队友一起深刻反思，制定《比赛注意事项》2021.05本着非金即银的心态参加ICPC银川站，最终铜牌滚粗，之后 lhr 永无上机机会2021.06本着退役赛的心情参加西安邀请赛，终于拿银，在和队友的商议下，决心再打一届比赛冲金2021.06-2021.12每两天一场训练赛2021.07参加保研夏令营，被打得遍体鳞伤后终于等来华科的 offer2021.11ICPC 济南站铜牌滚粗，把大部分原因归结于题目的区分度2021.11ICPC 沈阳站铜牌滚粗，意识到自己遗忘了许多知识点2021.12CCPC 哈尔滨站打铁，耻辱退役 进入高中后，遇到了我的数学启蒙老师，他的讲课方法和人格魅力让我彻彻底底爱上了数学，大考小考的班里数学rk1一般都是我。后来，数学老师还提议我去参加数学竞赛，但我看着自己那除数学外拉跨的成绩，最终还是回绝了。到了高三，我和班上一位女生轮流拿班级成绩 rk1，渐渐地互相产生了好感，于是… 此处省略一万八千字。高考结束后，与她聊天，幻想着以后一起上大学的日子，那段时光很是甜蜜。高考出分之时，幻想破碎之刻，我红着眼看着相差 50 50 50 多分的成绩，自知无法与她上同一所大学，于是选择说了再见。最终，她去了 OUC，我来了 SDNU。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92f64b2e05a3d152742f683b39e2ca0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c906d488ae113798a3fad27fe617750b/" rel="bookmark">
			pandas连接mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，以管理员身份进入cmd输入下载代码pip install mysql-connector-python进行插件下载
二，输入另一个下载代码进行下载插件pip install SQLALchemy下载完成即可·
三，下载完成后进入vscold运行pandas进行mysql连接，输入连接代码即可完成连接
root后面是你的mysql密码
四，有些电脑不支持前两个插件代码下载，如果无法下载则使用一下代码依次下载，与一二方法一样
打开cmd
1，输入python -m pip install mysql-connector-python下载
2，输入python -m pip install SQLALchemy下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92d9f330dc75e0b44e215f2faefbf522/" rel="bookmark">
			微信公众号如何配置关键词自动回复小程序链接和太阳码？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、如何配置微信公众号关键词回复小程序链接？ 1. 首先登录想要配置的公众号，找到关键词回复，点击添加回复。
2. 填写规则名称、填写关键词按需求选择全匹配或半匹配，点击文字
3. 填写如下代码，确认保存。
&lt;a href="http://www.qq.com" data-miniprogram-appid="your_miniprogram_appid" data-miniprogram-path="pages/index/index"&gt;点击跳小程序&lt;/a&gt; 4. 效果
二、如何配置微信公众号关键词回复小程序太阳码？ 1. 首先登录想要配置的公众号，找到关键词回复，点击添加回复。
2. 填写规则名称、填写关键词按需求选择全匹配或半匹配，点击图片，选择你提前准备好的太阳码，保存
3. 效果
GXC
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a9cefcd8e213c39983d3782d5dbc99/" rel="bookmark">
			linux 下 添加 4G 模块的支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）修改 drivers/usb/serial/option.c
static const struct usb_device_id option_ids[] = { ... { USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff), /* ZTE MF820S */ ... { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000)}, /* SIMCom SIM5218 */ ... { USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9003), /* Quectel UC20 */ .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist }, 这个数组里添加 ID
static const struct option_blacklist_info net_intf4_blacklist = { .reserved = BIT(4), }; 第4个功能处于黑名单
在
static int option_probe(struct usb_serial *serial, const struct usb_device_id *id) .... /* * Don't bind reserved interfaces (like network ones) which often have * the same class/subclass/protocol as the serial interfaces.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95a9cefcd8e213c39983d3782d5dbc99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48717c79449acc8e609eed8c8fac0142/" rel="bookmark">
			【洛谷】P1019 单词接龙（C&#43;&#43;/Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传送门：洛谷P1019
思路：本题题目为单词接龙，所以顾名思义，第二个接入的单词前缀要与前一个单词的后缀相同才能连到一起。做本题之前，大家可以先去了解一下KMP算法，这样触类旁通，可以解出更多的题。
KMP算法详解
理清本题要点（限制条件）：
接龙的单词要的前缀要与前一个单词的后缀相同每个单词的引用不超过两次输入的最后一行是“龙”的开头 C++代码：
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;cstring&gt; using namespace std; string str[25], ret; // str[] 存储你输入的n个字符串，ret 是“龙” int n, num[25], sum = 0; // num[] 为每个字符串使用过的次数，sum记录“龙”的最大长度 char st; // st 为首字母 // 计算重叠部分长度的函数 int overlap(int d) { int rlen = ret.size(); int dlen = str[d].size(); // 外层循环计算加入下一个单词后，“龙”增加的长度i for (int i = 1; i &lt; min(rlen,dlen); i++) { bool flag = true; // 内层循环作比较，遇到不想同的字符跳出本层循环，如果全部相同就返回 for (int j = 0; j &lt; i; j++) { if (ret[rlen - i + j] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48717c79449acc8e609eed8c8fac0142/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15604e9c292d727522f22f354fcf35e1/" rel="bookmark">
			FlutterWeb性能优化探索与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		美团外卖商家端基于 FlutterWeb 的技术探索已久，目前在多个业务中落地了App、PC、H5的多端复用，有效提升了产研的整体效率。在这过程中，性能问题是我们面临的最大挑战，本文结合实际业务场景进行思考，介绍美团外卖商家端在 FlutterWeb 性能优化上所进行的探索和实践，希望对大家能有所帮助或启发。
一、背景
1.1 关于FlutterWeb 时间回拨到 2018 年，Google 首次公开 FlutterWeb Beta 版，表露出要实现一份代码、多端运行的愿景。经过无数工程师两年多的努力，在今年年初（2021 年 3 月份），Flutter 2.0 正式对外发布，它将 FlutterWeb 功能并入了 Stable Channel，意味着 Google 更加坚定了多端复用的决心。
图1 FlutterWeb历史 当然 Google 的“野心”不是没有底气的，主要体现在它强大的跨端能力上，我们看一下 Flutter 的跨端能力在 Web 侧是如何体现的：
图2 Flutter跨端能力 上图分别是 FlutterNative 和 FlutterWeb 的架构图。通过对比可以看出，应用层 Framework 是公用的，意味着在 FlutterWeb 中我们也可以直接使用 Widgets、Gestures 等组件来实现逻辑跨端。而关于渲染跨端，FlutterWeb 提供了两种模式来对齐 Engine 层的渲染能力：Canvaskit Render 和 HTML Render，下方表格对两者的区别进行了对比：
图3 模式对比 Canvaskit Render 模式：底层基于 Skia 的 WebAssembly 版本，而上层使用 WebGL 进行渲染，因此能较好地保证一致性和滚动性能，但糟糕的兼容性（WebAssembly 从 Chrome 57 版本才开始支持）是我们需要面对的问题。此外 Skia 的 WebAssembly 文件大小达到了 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15604e9c292d727522f22f354fcf35e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d312a0ad610d2c4b718c2a996d22ae06/" rel="bookmark">
			高级Android插件化最全开源项目、看这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 插件化技术发展到现在其实已经很成熟了，但是相应的问题，如果没有真正地去实践过，根本不了解其中有多少问题，会牵涉到多少技术细节，多少被外人膜拜的外表光鲜的技术大牛都被『插件化』这三个字折磨地死去活来，这对于 Android 整个生态的损害也让人无法忽视。
**那么这个组件化是什么意思呢？**我说下我自己的理解，可能不对，还请指教：
通过 gradle 配置的方式，将打 debug 包和 release 包分开。这样会有一个好处，开发一个模块，在 debug 的时候，可以打成一个 apk ，独立运行测试，可以完全独立于整个宿主 APP 的其他所有组件；待到要打 release 包的时候，再把这个模块作为一个 library ，打成 aar ，作为整个宿主 APP 的一部分。而 debug 和 release 的切换都是通过 gradle 配置，可以做到无缝切换。至于模块之间的跳转，可以用别名的方式，而不是用 Activity 和 Fragment 类名。这样所有的模块和宿主 APP 都是完全解耦的，彻底解决了并行开发的可能造成的交叉依赖等问题。
按照这个思路，我们再来看看一些其他的细节：
在 Android 里有一个比较爽的一点是，作为 library 的时候，aar 里的引用依赖，在宿主 Application 里也有同样的引用依赖，并不会打包两份到宿主 Application 里；
模块之间的跳转，除了使用别名的方式，我能想到的还有另外一种方式，同样是通过 gradle 脚本，将跳转用到的类打成一个 jar ，作为一个 API 服务提供给其他模块作为编译期依赖（provided）引入；
各个 library 在 debug 的时候作为 apk ，要独立打包运行测试，这时就需要有一个启动 Activity ，而 library 是不需要的，我的想法是放置两个 AndroidManifest.xml ，使用 sourceSets 分别在 debug 和 release 的时候加载不同的 AndroidManifest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d312a0ad610d2c4b718c2a996d22ae06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2acbc94a575665b0dda4fff46abb66b3/" rel="bookmark">
			UE4 Android环境配置随笔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，转载请注明出处。
作者的UE4引擎版本：4.26.2
官方UE4配置文档：跳转至官方文档
按照上面的官网步骤下来，下载了Android Studio4.0，按照上面的步骤走了一遍下来。
打包时候一直报错：忘记截图了，报错内容如下
Installed Build Tools revision 32.0.0 is corrupted. Remove and install again
app:assembleDebug
最后报错提示的红色字体为：app:assembleDebug
如果你细心一点，去这个错误上面可能会找到下面的字
Whats is wrong: Installed Build Tools revision 32.0.0 is corrupted. Remove and install again
翻译下来是说你下载的SDK Tools是损坏的，让你去Android Studio里面的SDK Manager中卸载重装，
但是实际原因是下载的32.0.0和31.0.0都是和unreal engine4.26.2不匹配。我测试下来发现30.0.3是能用的。
我的Android SDK Manager配置界面如下，仅供参考
SDK Platforms：
SDK Tools：
这个NDK不用你自己选，是在UE4的步骤中下载下来的，运行AndrodSetup.bat下载下来的。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/309/">«</a>
	<span class="pagination__item pagination__item--current">310/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/311/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>