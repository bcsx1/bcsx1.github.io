<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d24218770d868ec2da8650e4a1044a9/" rel="bookmark">
			【bilibili kratos】构建环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 拉取源码 1.1 fork自己的分支（方便修改） github地址修改为你自己的分支地址，代码中相应的地方也要修改。而且需要重新构建模板
go get -u github.com/gobuffalo/packr/packr 1.2 构建脚手架工具 Linux/Mac
GOMOD=on &amp;&amp; go get -u github.com/zzpu/kratos/tool/kratos Windows
set GOMOD=on &amp;&amp; go get -u github.com/zzpu/kratos/tool/kratos 2 使用脚手架工具构建脚手架 2.1 构建脚手架 kratos new kratos-demo go get -u github.com/zzpu/kratos/tool/kratos-gen-project genproject: 安装成功! go: finding github.com/zzpu/kratos master # get https://proxy.golang.org/github.com/zzpu/kratos/@v/master.info # get https://proxy.golang.org/github.com/zzpu/kratos/@v/master.info: 200 OK (0.105s) # get https://proxy.golang.org/github.com/@v/list # get https://proxy.golang.org/github.com/google/wire/@v/list # get https://proxy.golang.org/github.com/google/@v/list # get https://proxy.golang.org/github.com/@v/list: 410 Gone (0.028s) # get https://proxy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d24218770d868ec2da8650e4a1044a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3b002c54f4df2650acc6177296dd882/" rel="bookmark">
			udhcp源码详解（一）之DHCP服务器和客户端的工作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		udhcp源码详解（一） 之DHCP服务器和客户端的工作流程
From : &lt;https://blog.csdn.net/who538592/article/details/58621748&gt;
DHCP服务器的工作流程 udhcpd，即dhcp服务器，在路由器等网关设备中，DHCP服务器启动后用于给LAN侧和无线终端分配IP、租约和其他网络配置。根据RFC2131文档规范，一个标准的DHCP服务器和客户端的交互时序如下，这是一个完整的交互过程，从INIT到BOUND，其余的交互过程，比如INIT_REBOOT、RENEWING和REBINDING都可视作该过程的简化或一部分。
DHCP客户端的工作流程 udhcpc，即DHCP客户端的工作相对简单，可以使用客户端状态转移图来描述，根据所处的
不同状态，与服务器进行交互。如下图所示，客户端工作的起点一般是INIT和INIT_REBOOT状态，
一个标准的获取IP及其配置的流程是INITSELECTINGREQUESTINGBOUND， 重启后的重新获取IP
lease的流程：INIT_REBOOTREBOOTINGBOUND，
T1过期续约lease：BOUNDRENEWINGBOUND，
T1和T2过期续约lease：BOUNDRENEWINGREBINDINGBOUND。
可见，BOUND状态是最终完成配置的状态，REBOOTING、REQUESTING、RENEWING和REBINDING是中间状态，在中间状态，若接收到ACK即跳转到BOUND状态完成配置，若接收到NAK或lease过期则回到INIT状态。
这篇udhcp详解是基于busybox-1.20里的 …/busybox-1.20/networking/udhcp/目录下的源码进行讲解与分析，主要是对udhcp server端源码进行的讲解，client端相对于server端相对简单一些，源代码上面表现的实现思想大体相似。
udhcp的文件结构 udhcp的文件夹中包含许多源文件和头文件，每组源和头文件对应着一个模块或功能。
Dhcpd.c——整个DHCP server运行的主线，其udhcpd_main函数就是server开始允许的入口，相当于main入口。在udhcpd_main中，各个模块被组合起来实现DHCP服务器的功能。
Dhcpc.c：DHCP client运行的主线，提供udhcpc_main作为入口函数，相当于main函数，将各个客户端模块组合起来实现DHCP客户端的功能。
Frontend.c：该文件提供了一个main入口，在其中根据传入参数选择启动DHCP服务器还是客户端。
其余文件都是负责各个具体的模块：
Arpping.c：该源文件只包含arpping函数，在服务器给客户端分配一个free IP后，会调用arpping函数，查看网络上是否有主机已经使用该地址。
File.c和file.h：DHCP server file manipulation，负责DHCP服务器的文件操作，其中最重要的函数是read_config，该函数载入默认配置信息，并从配置文件udhcpd.conf读取配置信息。（以后读取配置信息的函数可以模仿read_config函数写）。
leases.c：tools to manage DHCP leases，针对dhcpOfferedAddr结构的操作函数，该结构体是DHCPOFFER报文的数据主体，通过它，服务器向客户端提供租约的信息。
options.c：DHCP server option packet tool，针对DHCP数据报文的options字段的操作函数都在这个文件中。
packet.c：DHCP数据报文的构造和发送。
pidfile.c：Functions to assist in the writing and removing of pidfiles。针对pidfile的写和删除操作。主要针对/tmp/var/run/udhcpd0.pid
serverpacket.c：Constuct and send DHCP server packets。构造和发送dhcp服务器报文。
clientpacket.c：Packet generation and dispatching functions for the DHCP client。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3b002c54f4df2650acc6177296dd882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3206e66e3ece73b3eba86579e8440535/" rel="bookmark">
			SNMP简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介
SNMP：“简单网络管理协议”，用于网络管理的协议。SNMP用于网络设备的管理。
SNMP协议主要由两大部分构成：SNMP管理站和SNMP代理。SNMP管理站是一个中心节点，负责收集维护各个SNMP元素的信息，并对这些信息进行处理，最后反馈给网络管理员；而SNMP代理是运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。
SNMP管理站和SNMP代理之间是松散耦合。他们之间的通信是通过UDP协议完成的。一般情况下，SNMP管理站通过UDP协议向SNMP代理发送各种命令，当SNMP代理收到命令后，返回SNMP管理站需要的参数。但是当SNMP代理检测到网络元素异常的时候，也可以主动向SNMP管理站发送消息，通告当前异常状况。
SNMP的基本思想：为不同种类的设备、不同厂家生产的设备、不同型号的设备，定义为一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备进行管理。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高网络管理的效率，简化网络管理员的工作。
SNMP的工作方式：管理员需要向设备获取数据，所以SNMP提供了【读】操作；管理员需要向设备执行设置操作，所以SNMP提供了【写】操作；设备需要在重要状况改变的时候，向管理员通报事件的发生，所以SNMP提供了【Trap】操作。
snmp分为Agent端和Manger端。Agent端用于对设备、磁盘、进程等相关信息进行监控，当有异常信息时，上报snmp报文。
二、SNMP 和 UDP
SNMP采用UDP协议在管理端和agent之间传输信息。 SNMP采用UDP 161端口接收和发送请求，162端口接收trap，执行SNMP的设备缺省都必须采用这些端口。SNMP消息全部通过UDP端口161接收，只有Trap信息采用UDP端口162。
三、Snmp版本
SNMP目前共有v1，v2，v3这三个版本： SNMP v1是SNMP协议的最初版本，不过依然是众多厂家实现SNMP基本方式。 SNMP v2通常被指是基于community的SNMP V2。Community可以理解成为密码。
SNMP v3 是最新版本的SNMP。它对网络管理最大的贡献在于其安全性。增加了对认证和密文传输的支持。
四、SNMP角色
Snmp分2种角色：SNMP管理站（manager，我们的本机127.0.0.1）和SNMP代理（agent， 我们要操作的机器，比如 192.168.66.66）。管理站指的是运行了可以执行网络管理任务软件的服务器，通常被称作为网络管理工作站（NMS）,NMS负责采样网络中agent的信息，并接受agent的trap。代理是实际网络设备中用来实现SNMP功能的部分。代理在UDP的161端口接收NMS的读写请求消息，管理站在UDP的162端口接收代理的事件通告消息。所以，一旦获取设备的访问权限（community，默认为public），就可以访问设备信息、改写和配置设备参数。由于采用UDP协议，不需要在代理和管理站之间保持连接。
五、SNMP的操作命令
SNMP协议之所以易于使用，这是因为它对外提供了三种用于控制MIB对象的基本操作命令。它们是：Get、Set 和 Trap。
Get：管理站读取代理者处对象的值。它是SNMP协议中使用率最高的一个命令，因为该命令是从网络设备中获得管理信息的基本方式。
Set：管理站设置代理者处对象的值。它是一个特权命令，因为可以通过它来改动设备的配置或控制设备的运转状态。它可以设置设备的名称，关掉一个端口或清除一个地址解析表中的项等。
Trap： 代理者主动向管理站通报重要事件。它的功能就是在网络管理系统没有明确要求的前提下，由管理代理通知网络管理系统有一些特别的情况或问题 发生了。如果发生意外情况，客户会向服务器的162端口发送一个消息，告知服务器指定的变量值发生了变化。通常由服务器请求而获得的数据由服务器的161 端口接收。Trap 消息可以用来通知管理站线路的故障、连接的终端和恢复、认证失败等消息。管理站可相应的作出处理。
六、SNMP的消息构成
SNMP协议定义了数据包的格式，及网络管理员和管理代理之间的信息交换，它还控制着管理代理的MIB数据对象。因此，可用于处理管理代理定义的各种任务。
一条SNMP消息由"版本号"、"SNMP共同体名"和"协议数据单元(PDU)"构成，数据包的长度不是固定的。
版本标识符 | 团体名 | PDU
版本识别符(version identifier)：用于说明现在使用的是哪个版本的SNMP协议，确保SNMP代理使用相同的协议，每个SNMP代理都直接抛弃与自己协议版本不同的数据报。
团体名(Community Name)：团体（community）是基本的安全机制，用于实现SNMP网络管理员访问SNMP管理代理时的身份验证。类似于密码，默认值为 public。团体名（Community name）是管理代理的口令，管理员被允许访问数据对象的前提就是网络管理员知道网络代理的口令。如果把配置管理代理成可以执行Trap命令，当网络管理 员用一个错误的分区名查询管理代理时，系统就发送一个autenticationFailure trap报文。 协议数据单元（PDU）：PDU (协议数据单元)是SNMP消息中的数据区， 即Snmp通信时报文数据的载体。PDU指明了SNMP的消息类型及其相关参数
七、PDU(协议数据单元)
PDU (协议数据单元)是SNMP消息中的数据区， 即Snmp通信时报文数据的载体。
八、MIB(管理信息库)
管理信息(MIB)库可以理解成为agent维护的管理对象数据库，MIB中定义的大部分管理对象的状态和统计信息都可以被NMS访问。MIB是一个按照层次结构组织的树状结构，每个被管对象对应树形结构的一个叶子节点，称为一个object，拥有唯一的数字标识符
MIB数据对象以一种树状分层结构进行组织，这个树状结构中的每个分枝都有一个专用的名字和一个数字形式的标识符。结构树的分枝实际表示的是数据对象的逻 辑分组。而树叶，有时候也叫节点（node），代表了各个数据对象。在结构树中使用子树表示增加的中间分枝和增加的树叶。 使用这个树状分层结构，MIB浏览器能够以一种方便而且简洁的方式访问整个MIB数据库。MIB浏览器是这样一种工具，它可以遍历整棵MIB结构树，通常 以图形显示的形式来表示各个分枝和树叶对象。可以通过其数字标识符来查找MIB中的数据对象，这个数字标识符号从结构树的顶部（或根部）开始，直到各个叶 子节点（即数据对象）为止。这种访问方式和文件系统的组织方式一致。两者的主要区别在于文件系统中的路径名可以以绝对也可以以相对方式表示，而MIB数据 对象只能以绝对方式表示，不能使用相对方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3206e66e3ece73b3eba86579e8440535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce795cb92470dda2ad97bc6b49ddbf72/" rel="bookmark">
			【Excel2019(四)：排序与筛选】【简单&#43;复杂&#43;自定义（&#43;高级）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇：【Excel2019(三)：查找、替换与定位】【查找与替换+定位工具】
文章目录 1. 排序1.1 简单排序1.2 复杂排序1.3 自定义排序1.4 利用排序，打印工资条 2. 筛选2.1 简单筛选2.2 复杂筛选2.3 自定义筛选2.4 高级筛选2.4.1 筛选不重复数据2.4.2 筛选出财务部或发生额大于3000的数据2.4.3 筛选出财务部且发生额大于3000的数据 1. 排序 1.1 简单排序 选中全部数据或者该列（降序或者升序）中的某一单元格进行排序即可，不建议选中该列进行排序
1.2 复杂排序 多个条件排序：从最后一个条件开始排序
1.3 自定义排序 灵活运用自定义排序
一般汉字数字按拼音排序，需要自定义序列
1.4 利用排序，打印工资条 利用排序，打印工资条
有十一位员工的信息，还有一行表头。
要求每个员工的工资条都有一行表头，即在员工之间插入表头。
还有是个员工没有表头，复制十行表头。
在数据的最右侧新建一列数字，然后排序即可。
2. 筛选 2.1 简单筛选 直接筛选
2.2 复杂筛选 没有顺序要求
2.3 自定义筛选 文本筛选
数字筛选
2.4 高级筛选 数据-高级
2.4.1 筛选不重复数据 原数据
处理数据
打钩选择不重复的记录即可
结果图
2.4.2 筛选出财务部或发生额大于3000的数据 条件区域
2.4.3 筛选出财务部且发生额大于3000的数据 条件区域
下一篇：【Excel2019(五)：分类汇总和数据有效性】【分类汇总+数据有效性】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfbe6cc2b617cba982034155c628736a/" rel="bookmark">
			免积分解决：Cannot resolve net.sourceforge.pinyin4j:pinyin4j:2.5.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 spring boot项目。解决如下： 到http://sourceforge.net/projects/pinyin4j/下载，解压，取出jar包放进仓库： 打开maven，再刷新一下: 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06a68218ad7c5d220be2f47435e6a45e/" rel="bookmark">
			单体应用-前后整合-(2)用户菜单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前SQL初始化数据中，也包含了部分菜单权限数据。
这边我们后端先把菜单的数据初始化到Redis中存放，提供API供前端调用，
然后再调整下前端测试。
后端将用户菜单数据初始化到Redis
dao模块中，先增加个常量：
public interface RedisConstant { ... String USER_MENUS = "userMenu-"; } 定义个类用于返回菜单数据格式的对象：
public class Menu { private String path; private String name; private String icon; private List&lt;Menu&gt; children; ... } 初始化Redis的类中，用json格式存放用户菜单：
@Component public class InitRedisData implements CommandLineRunner { private static Logger logger = LoggerFactory.getLogger(InitRedisData.class); @Autowired private StringRedisTemplate stringRedisTemplate; @Autowired private SysUserRepository userRepository; @Autowired private SysRoleRepository roleRepository; @Autowired private SysUserDataSourceRepository sysUserDataSourceRepository; @Autowired private SysPermRepository sysPermRepository; @Override public void run(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06a68218ad7c5d220be2f47435e6a45e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f39c21d1e611d37ac2a6e962d297c5/" rel="bookmark">
			JSON.parseObject反序列化需要注意的事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现有JSON字符串
Login对应shiyukirito
但我之前为此准备的类的变量是name，这样setName就会找不到Login，不能将shiyukirito变量正确存为name。
private String name; private long id; private String dio; 于是我加了一个setLogin方法，
public void setLogin(String name){this .name = name;} 但依然无法读入数值。
原因是setName方法把setLogin方法覆盖了。
也就是说JSON.parseObject调用了所有的set方法来执行
public void setName(String name) { this.name = name; System.out.println("执行了setname方法"+name); } public void setLogin(String name){this .name = name;System.out.println("setLogin"+name);} //github 返回的JSON中Login对应name; 通过打印结果可以看出
setLoginshiyuKirito 执行了setname方法null setLogin确实成功从JSON字符串中得到Login但setname中没有得到name的信息，覆盖了这个name
可以将setName方法注释掉来达成目的。或者在setName中判断一下name是否为空
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f1ab257954f8c6607450d5741ab349/" rel="bookmark">
			win10系统如何解决管理员已阻止你运行此应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法/步骤 当运行安装一些特殊软件的时候，win10系统会弹出提示“管理员已阻止你运行此应用。有关详细信息，请与管理员联系”
首先在win系统右下角的windows图标上点右键
在打开的右键菜单中，选择“运行”
在运行对话框中，输入gpedit.msc
输入完成后，点击”确定“
注意：win10家庭版默没有组策略功能，可以参考（https://blog.csdn.net/qq_18671415/article/details/104417830）下面的经验链接开启
打开组策略编辑器后，双击打开右侧对话框里的”计算机配置“
然后双击打开”Windows 设置“
然后双击打开”安全设置“
然后双击打开”本地策略“
然后双击打开”安全选项“
在安全选项中，选择“用户账户控制：以管理员批准运行所有管理员”双击打开
在弹出的对话框中，选择”已禁用“
然后点击下面的”确定“
点击确定后，会弹出提示，需要重启系统才能生效，点击右上角的叉号，关闭组策略编辑器
点击左下角的windows图标，打开开始菜单，选择电源然后重启系统
重启开机后，再次运行软件就可以正常打开了
注意事项 设置完成后，要重启系统才能生效
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfe4b0a11158a8dc1abc3f4763b3656b/" rel="bookmark">
			单体应用-前后整合-(1)登录相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端config：
开启代理解决和远程服务器跨域的问题。
Q:部署到nigix的时候不清楚是否还需要开启反向代理？
proxy: { '/server/api/': { target: 'http://localhost:8080/', changeOrigin: true, secure: false, // 如果是https接口，需要配置这个参数为true pathRewrite: { '^/server': '' }, }, }, 参考：在 model 中请求服务端数据
一种常见的规避跨域的方法就是：把 ajax 请求发送到你的本地开发服务器，然后本地开发服务器再把 ajax 请求转发到远端去，从网络拓扑上看本地开发服务器起着「反向代理」的作用。本地服务器和远端服务器是「服务器和服务器间的通信」，就不存在跨域问题了。
配置代理也很简单，只需要您在配置文件 config/config.js 中与 routes 同级处增加 proxy 字段
下面把登录相关前后端串起来跑一下。
调整下 service/login.js :
登录时/server/api/login/account 被按照代理的配置调整为
http://localhost:8080/api/login/account
其它则还是通过mock获取数据
export async function accountLogin(params) { return request('/server/api/login/account', { method: 'POST', data: params, }); } models/login 中调用该方法
import { accountLogin } from '@/services/login'; ... const Model = { effects: { *login({ payload }, { call, put }) { const response = yield call(accountLogin, payload); .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfe4b0a11158a8dc1abc3f4763b3656b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe6753dd1e88e6d59a525030af54624/" rel="bookmark">
			linux 下查看 USB 设备的 PID 和 VID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里以 centos7为例
方法一： 首先进入 /sys/bus/usb/devices 目录：
cd /sys/bus/usb/devices 先不要插入 usb 设备，然后使用 ll 命令，可查看到当前的设备；然后插入设备后再使用 ll 命令查看，对比即可知道插入为哪个设备。以下红线圈出的为插入的设备：
然后进入对应设备的目录，通过查看 idProduct 和 idVendor 文件即可得到 USB 设备的 PID 和 VID。
方法二： 命令：
cat /sys/kernel/debug/usb/devices 即可查看所有 USB 设备的信息，也是跟上面一样的方法，先不插入设备然后查看一下有哪些设备，然后插入设备再查看一次就能确定当前 USB 设备的信息，包括 PID 和 VID。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfe57058ea0148f038da85a2be43c210/" rel="bookmark">
			解决Docker启动Tomcat容器，访问404问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：没有关闭防火墙或者Tomcat的webapps文件夹下没有东西 排查和解决 启动Tomcat容器 docker run -d -p 8888:8080 tomcat 查看已经启动的容器 docker ps 使用8888端口访问Tomcat失败先查看防火墙状况 service firewalld status 如果防火墙没关闭，先关闭防火墙 service firewalld stop 防火墙关闭时，防火墙的状态如下
确定防火墙关闭但访问Tomcat还是失败之后，使用如下命名进入Tomcat的目录 docker exec -it c110e319cdd1(启动的Tomcat容器的容器id) /bin/bash 使用命令查看当前文件夹内的所有文件 ls -l 进入webapps文件夹下 cd webapps 查看webapps下的文件 ls -l 显示total 0，问题就出在这里，webapps文件夹下没有东西返回上一级目录 cd .. 删除webapps文件夹（-r是级联删除,-f是强制删除，不然文件夹是删不掉的） rm -rf webapps 将webapps.dist文件夹下的内容复制到给webapps文件夹 rm webapps.dist webapps 此时再访问Tomcat，成功
操作图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8fe176455f724d42ae4bedcc4a27d9/" rel="bookmark">
			Docker-Swarm集群-Portainer使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装Docker 1.windows7下安装docker 是的，现在还是有人用windows7的，因为没有Hyper-V，所以并不能使用docker for windows，但是可以使用docker toolbox，也有人喜欢放到linux虚拟机里用（docker for windows也是带了linux内核）。
点击Docker Toolbox overview进行下载。
安装完成后，如果你之前安装过git，那么打开Docker Quickstart Terminal可能会报错“bush无法找到”，你需要点击Docker Quickstart Terminal右键属性，手动改成你Git目录下的bush.exe。
打开后初始化需要下载boot2docker.iso，必定龟速，可以手动下载boot2docker.iso。复制文件boot2docker.iso到C:\Users\mid1507\.docker\machine\cache\boot2docker.iso目录，重新打开Docker Quickstart Terminal。
详见：Docker的boot2docker.iso镜像使用 win7搭建docker解决的一些坑
这时候就已经可以在win7下使用docker了。
注意，Docker Quickstart Terminal的主机并不是windows，而是它自己构建的一个linux系统，所以你并不能通过localhost访问docker容器，得访问这个内置Linux的IP，一般情况下这个地址是192.168.99.100。
另见 解决windows系统无法对docker容器进行端口映射的问题
2.windows10下安装docker 这就比较简单，直接下载安装，没遇到什么坑。Docker Desktop for Windows
3.Linux下安装docker 采用yum安装的话，直接yum search docker就可以找到了。因为生产上多用的是centos7，这里给一下aliyun的镜像。
docker-ce.repo
[docker-ce-stable] name=Docker CE Stable - $basearch baseurl=https://mirrors.aliyun.com/docker-ce/linux/centos/7/$basearch/stable enabled=1 gpgcheck=1 gpgkey=https://mirrors.aliyun.com/docker-ce/linux/centos/gpg 然后操作一下：
cp docker-ce.repo /etc/yum.repos.d/docker-ce.repo yum makecache yum install docker-ce -y #开机自启docker systemctl enable docker #重启docker systemctl daemon-reload systemctl restart docker 4.配置守护进程daemon.json vi /etc/docker/daemon.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8fe176455f724d42ae4bedcc4a27d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/594e153dc26992cfd7c266754d3b77b5/" rel="bookmark">
			web页面通过websocket获取客户端本地已安装的软件列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web页面通过websocket获取客户端本地已安装的软件列表
原文地址：web页面通过websocket获取客户端本地已安装的软件列表
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/063a3fdc5d0f3951af9cfb196ac5e4d0/" rel="bookmark">
			Android之判断手机是否有root权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Root权限？ 当你买了一台Android 手机回来的时候，并不意味着你拥有了对这台手机的绝对支配权，因为当你想要删除系统自带的软件，却无能为力。原因很简单：手机厂商处于自身利益，绑定了一些软件，不允许我们删除；有一些手机依赖的软件，不能随意删除。
Android手机只有两种账户类型：一种是普通账户，另一个是超级管理员。手机默认开机进入的就是普通用户对应的界面，如果要进入超级管理员页面，则需要对手机进行root权限。root 其实就是Linux系统下的超级管理员的账户名称，我们可以把它理解成是Windows系统下的administrator，即：root权限 = root的权限 = 管理员权限。
如何判断手机是否有root权限？ 当手头上有一台Android手机，如何知道它有没有被root过呢？除了用XXX助手/工具来判断外，也可以通过adb 命令判断
命令行输入 adb shell，#代表已经root过，$代表没有root权限。
注意：能执行adb shell，表示进入到手机系统，但不代表有root权限。
如何root？ 以下是切换到手机的root账户的示例：
可以看到root失败，解决方案：BD教程root 手机系统
示例2：
有一些机器root的方法是：su root su是linux下的一个切换账户命令，普通账户要密码参数，root是最高级别的管理员，不需要密码。
代码判断是否有root权限 public class RootUtil { public static boolean isDeviceRooted() { return checkRootMethod1() || checkRootMethod2() || checkRootMethod3(); } private static boolean checkRootMethod1() { String buildTags = android.os.Build.TAGS; return buildTags != null &amp;&amp; buildTags.contains("test-keys"); } private static boolean checkRootMethod2() { String[] paths = { "/system/app/Superuser.apk", "/sbin/su", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/063a3fdc5d0f3951af9cfb196ac5e4d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/859f48ac7a90306d27360ccc607e27eb/" rel="bookmark">
			Constant expression required问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上一篇文章中，我用自己写的枚举类来作Case判断的时候发现了问题。系统一直提示Constant expression required，这是为什么呢？
原因是这样的：switch…case语句的case后面的值必须为常量，因为switch在编译的时候需要确保case里面的值必须不能相同。直接写getXXX这样的方法是可能出现重复的，因为你可以写两个相同的枚举值，但是实际业务场景下，一般也不会有人这样子做。即使如此，编译器还是不认。那怎么办呢，我们加一个方法提前判断就行了。
枚举类
public enum NumberForCaseEnum { ONE(1), TWO(2), THREE(3), FOUR(4); private int index; private NumberForCaseEnum(int index){ this.index=index; } public int getIndex(){ return this.index; } /** * 提前判断，用于解决 * Case中出现的Constant expression required * @param value * @return */ public static NumberForCaseEnum getByValue(int value){ for(NumberForCaseEnum x:values()){ if(x.getIndex()==value){ return x; } } return null; } } 测试代码：
//可以通过循环遍历拿值 for(NumberForCaseEnum x:NumberForCaseEnum.values()){ System.out.println("枚举值："+x.getIndex()); } //也可以单独拿值 System.out.println("调皮捣蛋的："+ONE.getIndex()); // switch(NumberForCaseEnum.getByValue(2)){ case ONE: System.out.println("1111"); break; case TWO: System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/859f48ac7a90306d27360ccc607e27eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e00513ab5369a88e80491f55a15d548/" rel="bookmark">
			UnityEditor面板中显示网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写了了个Editor扩展插件，方便大家在Unity中访问我的博客，增加用户体验和沉浸感。
public class WebViewEditorWindow : EditorWindow { [MenuItem("博客/CSDN")] static void Open() { string Url = "http://blog.csdn.net/mseol"; string typeName = "UnityEditor.Web.WebViewEditorWindowTabs"; Type type = Assembly.Load("UnityEditor.dll").GetType(typeName); BindingFlags Flags = BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy; MethodInfo methodInfo = type.GetMethod("Create", Flags); methodInfo = methodInfo.MakeGenericMethod(type); // Title, URL, 最小宽度, 最小高度, 最大宽度, 最大高度 methodInfo.Invoke(null, new object[] { "setsuodu的博客", Url, 400, 300, 800, 600 }); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b5713d717b30dfac0ba0ccac92b359/" rel="bookmark">
			Elasticsearch 聚合分析深入学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		聚合分析运算是数据库中重要的特性，对于数据分析场景尤为重要。类似于关系型数据库中的 SUM，AVG, GROUP BY 等，Elasticsearch 也提供了丰富的聚合运算方式，可以满足大部分分析和查询场景。
Doc Values 和 Field Data 在学习聚合分析之前，我们先了解一下 Doc Values 和 Field Data 数据结构，我们知道倒排索引的优势在于查找包含某个项的文档，反过来确定哪些项是否在某个文档中并不高效，ES 为了满足排序、聚合以及执行脚本的需求，因此就出现了 Doc Values 和 Field Data 两种数据结构，一般对应的数据结构如下：
Doc Terms ----------------------------------------------------------------- Doc_1 | brown, dog, fox, jumped, lazy, over, quick, the Doc_2 | brown, dogs, foxes, in, lazy, leap, over, quick, summer Doc_3 | dog, dogs, fox, jumped, over, quick, the Doc Values Doc Values 在索引生成时创建，通过序列持久化数据结构存储到磁盘，可以以操作系统的文件缓存来代替 JVM heapDoc Values 不支持分词的字符串，如果想要分词的字符串进行聚合功能，可以看下面的 Field Data 数据结构设置字段属性 doc_values=false 可以关闭 Doc Values 功能，意味你不可以对该字段进行聚合、排序等，同时也可以节省磁盘空间 Field Data Field Data 构建和管理 100% 在内存中，常驻于 JVM 内存堆，会消耗大量的内存，开启时需要谨慎考虑早起版本所有类型字段的默认设置都是 Field Data，后面大部分类型字段都迁移到了 Doc Values，只留下分词字符串还使用 Field Datatext 类型默认是 Field Data 功能的，如果需要可以通过设置属性 fielddata=true 开启该功能Field Data 是延迟加载的，也就是只有你第一次对一个分词字符串进行聚合、排序操作时才会加载，所以第一次加载时查询会较慢indices.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b5713d717b30dfac0ba0ccac92b359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/456eac35cd288e0a650dd822a9731d42/" rel="bookmark">
			CentOS7安装harbor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、下载安装包 点击这里下载Harbor
github project
这里分为在线和离线的版本，我下载的是1.8.1在线的版本
# wget --continue https://storage.googleapis.com/harbor-releases/release-1.8.0/harbor-online-installer-v1.8.1.tgz 下载下来之后解压缩，目录下会有harbor.conf，就是Harbor的配置文件了
二、配置Harbor 大多数时候，只需要修改hostname属性和https证书即可。配置完成之后再当前目录下执行./prepare,再执行./install.sh。Harbor就回根据当前目录下的docker-compose.yml下载依赖的镜像
image.png
三、启动Harbor 安装完成之后，打开浏览器访问你上边配置的hostname属性，就能看到Harbor的界面了。
image.png
四、登录 [root@localhost harbor]# docker login harbor.docker-plus.xyz Username: admin Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad5e11fab95e38e3ab8f0f4dacf0679/" rel="bookmark">
			MySQL8.0忘记root密码解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.跳过密码进入mysql (1)管理员权限打开cmd，先暂停mysql服务
C:\Windows\system32&gt;net stop mysql
(2)进入mysql安装目录bin目录，运行命令mysqld --console --skip-grant-tables --shared-memory
(3)运行成功时，打开另外一个cmd窗口进入mysql
C:\Windows\system32&gt;mysql -uroot -p
不需要输入密码直接Enter
2.修改密码 (1)刷新权限
mysql&gt;flush privileges
(2)查看authentication_string是否为空,authentication_string字段用于存储加密后的密码
mysql&gt;select user,host,authentication_string from user
(3)authentication_string字段为空的话就可以用ALTER USER修改，不能的话先将该字段设为空,否则可能会报错 ERROR 1396 (HY000): Operation ALTER USER failed for ‘root’@'localhost’
use mysql;
update user set authentication_string=’’ where user='root’
(4)修改密码，若需要支持navicat,使用mysql_native_password修改密码，毕竟8.0加密方法不一样
ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘新密码’;
不需要支持navicat:
ALTER user ‘root’@‘localhost’ IDENTIFIED BY '新密码’
修改完毕 退出第一个cmd命令，重启服务即可 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa71f76f0275c1968916b4e3c498d08c/" rel="bookmark">
			对象转为字符串方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 第一种方法
依赖
&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; Student student = new Student() //对象 String content = ObjectMapper.writeValueAsString(student);//对象转为字符串 第二种方法
依赖
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.28&lt;/version&gt; &lt;/dependency&gt; User user = new User(); //自己先创建一个对象 user.setUsername("123"); user.setPassword("123456"); // 我这里利用阿里的fastjson，将Object转换为json字符串; // (需要导入com.alibaba.fastjson.JSON包) String jsonString = JSON.toJSONString(user); System.out.println(jsonString+"得到的字符串") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da0d39b51feb62b45e7bdbdd611823aa/" rel="bookmark">
			Untracked Files Prevent Merge 			Move or commit them before merge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天提交代码后使用git进行合并，结果报Untracked Files Prevent Merge 这个错误，仔细研究了下，原来是自己之前由于git上传代码出问题，于是将代码copy给了另一个同事，之后他进行了提交。而自己拉取时不知道什么原因没拉到他的代码，结果git上代码已存在，而自己的代码未上传。之后先重新提交后再进行合并，成功解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd9e6ee92ae59bc6a77852bef2308f10/" rel="bookmark">
			Redis 实现高可用延迟队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
用过的延迟任务处理队列（RocketMQ、KafKa、Redisson等），对于一些要求比较高的场景是无法运用于生产环境的，一旦机器宕机或者应用重启会导致队列消息丢失，从而造成无法挽回的损失。
Redisson JDK内置的延迟队列或者基于时间轮算法的队列，都无法保证生产系统的高可用性，而Redisson很好的解决了这个问题。
Redisson 在基于 NIO 的 Netty 框架上，充分利用了 Redis 键值数据库提供的一系列优势，在 Java 实用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。
示例：
框架支持多种 redis 集成部署方式，包括单节点，主从模式，集群模式，哨兵模式等等。
&lt;!-- 最新参考maven-resposity--&gt; &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;3.12.1&lt;/version&gt; &lt;/dependency&gt; 创建消息类：
** * 消息类 */ @Data @AllArgsConstructor @NoArgsConstructor @Builder public class Message implements Serializable { /** * 消息ID */ private long messageId; /** * 创建时间戳 */ private long timestamp; } 定义延迟队列：
/** *延迟处理队列设计 **/ @Slf4J public class MessageDelayQueue { public static void main(String[] args) throws Exception { Config config = new Config(); config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd9e6ee92ae59bc6a77852bef2308f10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f5208a9d687fd674a97e831451b1f17/" rel="bookmark">
			迭代器源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代器源码分析：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35f9b8cd56518c6cce7ad53102c23cc4/" rel="bookmark">
			c&#43;&#43;编程练习 018:别叫，这个大整数已经很简化了!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		北大程序设计与算法（三）测验题汇总(2020春季)
描述 程序填空，输出指定结果
#include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; using namespace std; const int MAX = 110; class CHugeInt { // 在此处补充你的代码 }; int main() { char s[210]; int n; while (cin &gt;&gt; s &gt;&gt; n) { CHugeInt a(s); CHugeInt b(n); cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; n + a &lt;&lt; endl; cout &lt;&lt; a + n &lt;&lt; endl; b += n; cout &lt;&lt; ++ b &lt;&lt; endl; cout &lt;&lt; b++ &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; } return 0; } 输入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35f9b8cd56518c6cce7ad53102c23cc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df9d032504faef9576e779e9ca8c48e/" rel="bookmark">
			kafka踩坑——java找不到kafka-run-class.sh: line 309: exec: java: not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天执行
user_1@test_1:/opt/kafka$ sudo bin/zookeeper-server-start.sh config/zookeeper.properties /opt/kafka/bin/kafka-run-class.sh: line 309: exec: java: not found 但却出现报错kafka-run-class.sh: line 309: exec: java: not found，
根据网上查询，说可能是jdk问题，之后我又在/etc/profile下检查jdk
# java JAVA_HOME=/usr/local/java/jdk-11.0.6 JRE_HOME=$JAVA_HOME CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH PATH=$PATH:$JAVA_HOME/bin export JAVA_HOME CLASSPATH PATH JRE_HOME # java 8 #JAVA_HOME=/usr/local/java/jdk1.8.0_231 #JRE_HOME=/usr/local/java/jdk1.8.0_231/jre #CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib #PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin #export JAVA_HOME JRE_HOME CLASS_PATH PATH 发现也没有什么错误呀，再一想我使用的是普通用户登录进来在root用户下的目录下（/opt/kafka）进行操作，虽然给该文件夹了755权限并且还带了sudo执行，但是否是还可能是因为用户权限问题呢？之后我把用户切换成了root用户，再一执行，发现开启成功。
随后我想，之前我只赋予了/opt/kafka755权限，就试试把这个/opt/kafka增加chmod 777 权限后再用普通用户登录，看是否有效。
实验了一下
发现还是不行，可能是因为调用需要用到jdk可能还要再给jdk增加权限。
得了，那我就把kafka放到普通用户的文件夹下使用就行了。
再来实验一下
启动成功！
扩展知识：
Linux的文件访问权限及修改权限命令chmod
Linux中文件权限查看和修改
再进行深入分析后发现是Kafka的默认/usr/bin/java路径与我们实际的$JAVA_HOME/bin/java路径不一致导致的。 这里我们有两种修改方式：
修改我们的实际路径（$JAVA_HOME）设置一个软连接就可以了 参考文章：Kafka启动报错处理：/opt/module/kafka/bin/kafka-run-class.sh: 第 258 行:exec: java: 未找到
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9e7496cd71cc96f68f0888a68229393/" rel="bookmark">
			unreal Lightmass可能遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		光照贴图的UV问题是造成lightmass的最大的问题。注意事项是，不能重叠，每个之间要留有空隙从而避免泄露可扩散。最好的方法当然是在max里自己来展开每个UV。
光照UV重叠 如果我们发现例如，角落边缘透光，重叠，接缝瑕疵等问题，那么需要返回3D工具。手动的使用第一种方法自己建立光照贴图UV.
对于UV重叠。只需要进行构建，然后看日志信息，大概率会出现UV重叠的信息，这个时候我们可以手动去创建。
光照贴图扩散 这主要时由于这两个部分在光照贴图里过于靠近，所以我们的光照UV中需要每个部分都要有一定的间隔，要不就会出现这种问题。
接缝问题 我们打开它的光照贴图可以看到，对于圆柱型的东西，是比较容易出问题的，仅有一个接缝的Uv是比较合适的。
这个时候我们也是要手动的调整光照UV。
Indirect Seams 间接光照的运算结果在模型之间的接缝处会出现不自然的裂缝
这种的主要原因是两个Mesh之间虽然是平滑的，但是在间接光照进行阴影计算时并不知道这些信息。可以通过在世界设置中调节间接光照的质量和平滑度来减少这种现象
提高间接光照质量会加重光照构建的成本，而如果过于提高平滑度的话，会导致间接光照的很多细节被丢弃。所以一个更好的解决方案是，在构建关卡时，如果是一个平滑的面的话就直接使用一个整体的模型来做，而不是用好几个模型拼接而成。
Bleeding 光照泄露的主要原因是光照贴图的分辨率造成的
像这样室外的光照感觉上就像直接透过到了室内，显然不符合预期。虽然通过修改光照贴图的分辨率来进行应对，但是这样就相当于绕过了问题的来源。更根本的解决方法是，让"地板"与房间的尺寸匹配，这样在光照计算时，房间的地板就不会接收到外部的光的光照计算。
Emissive Material 自发光颜色的材质是通过HDR来实现泛光效果的，因此它本身并不参与光照运算。
通过在使用了自发光颜色材质的物体上打开
可以让其能够照亮周围环境，但仅限于静态光照。当物体是Movable时，没有办法开启这个选项。视频中实现的类型于动态照亮的效果是通过在物体上绑定一个改变GI的PP来实现的，然后两个PP之间的Blending就会改变空间内的灯光造成的影响，形成类似于被物体本身照亮的效果。
Error Coloring 错误着色可以用于排查静态光照计算时报出的UV方面的错误，因为光照构建时只是提示物体上有UV的Overlapping和Wrapping有时候还是很难找到对应的问题的，尤其是模型并不是自己构建的情况下。
打开这个选项之后要将光照质量调整为预览，才能看到错误着色。
重新构建一次光照，就能看到
橙色的部分是Overlapping而绿色的部分是Wrapping。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29a6fe9874c9085506d7479970fb971b/" rel="bookmark">
			docker加载新的镜像后repository和tag名称都为none的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里我以 zookeeper为例，先将zookeeper文件拉取到linux系统上，然后操作命令
docker load -i zookeeper-images(文件的名称) 然后docker images 查看镜像，会发现，刚才load的文件已经存在
[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE demo 2.0 f4290c0b5683 2 days ago 341MB &lt;none&gt; &lt;none&gt; 2e30cac00aca 2 weeks 然后给这个镜像起个名字为 zookeeper-image版本号为2.0
[root@localhost ~]# docker tag 2e30 zookeeper-image:2.0 然后再查看镜像是否更改完成
[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE demo 2.0 f4290c0b5683 2 days ago 341MB zookeeper-image 2.0 2e30cac00aca 2 weeks 问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aac41ccd3cd914a16dc6191463d9079/" rel="bookmark">
			AssetBundle资源加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AssetBundle资源加密 前言测试资源资源加密打包资源解析加载反编译资源普通资源加密资源 前言 AssetBundle中无论是美术素材，还是关键的热更代码，一旦被不法分子破解，都会给项目带来不可估计的损失。这里介绍一下AssetBundle加解密使用流程。
测试资源 手动设置打上标签
资源加密打包 加密脚本
using System; using System.IO; using System.Security.Cryptography; public class SeekableAesStream : Stream { private Stream baseStream; private AesManaged aes; private ICryptoTransform encryptor; public bool autoDisposeBaseStream { get; set; } = true; /// &lt;param name="salt"&gt;//** WARNING **: MUST be unique for each stream otherwise there is NO security&lt;/param&gt; public SeekableAesStream(Stream baseStream, string password, byte[] salt) { this.baseStream = baseStream; using (var key = new PasswordDeriveBytes(password, salt)) { aes = new AesManaged(); aes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4aac41ccd3cd914a16dc6191463d9079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/646dd975c9c7779bd3dcb753d6453323/" rel="bookmark">
			汇编跳转指令: JMP、JECXZ、JA、JB、JG、JL、JE、JZ、JS、JC、JO、JP 等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跳转指令分三类:
一、无条件跳转: JMP;
二、根据 CX、ECX 寄存器的值跳转: JCXZ(CX 为 0 则跳转)、JECXZ(ECX 为 0 则跳转);
三、根据 EFLAGS 寄存器的标志位跳转, 这个太多了.
根据标志位跳转的指令:
JE ;等于则跳转
JNE ;不等于则跳转
JZ ;为 0 则跳转
JNZ ;不为 0 则跳转
JS ;为负则跳转
JNS ;不为负则跳转
JC ;进位则跳转
JNC ;不进位则跳转
JO ;溢出则跳转
JNO ;不溢出则跳转
JA ;无符号大于则跳转
JNA ;无符号不大于则跳转
JAE ;无符号大于等于则跳转
JNAE ;无符号不大于等于则跳转
JG ;有符号大于则跳转
JNG ;有符号不大于则跳转
JGE ;有符号大于等于则跳转
JNGE ;有符号不大于等于则跳转
JB ;无符号小于则跳转
JNB ;无符号不小于则跳转
JBE ;无符号小于等于则跳转
JNBE ;无符号不小于等于则跳转
JL ;有符号小于则跳转
JNL ;有符号不小于则跳转
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/646dd975c9c7779bd3dcb753d6453323/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f637d9adabe3600363a0af95912d7ce1/" rel="bookmark">
			Wide &amp; Deep算法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献
Wide &amp; Deep Learning for Recommender Systems
前情提要
FM
FFM
DeepFM
Wide &amp; Deep，直译为又深又宽，又名又长又宽，从名字里我们就隐约觉得它的背景不简单，是的，它竟是谷歌提出来的！不仅背景不简单，内涵也很不简单，具体如何，下面分解。
在介绍DeepFM的文章中（见最上方链接）已经说过，DeepFM结合了FM对低阶特征交叉的处理和DNN对高阶特征交叉的处理，一时风头无两，但这样的思想其实在Wide &amp; Deep中就有了，Wide来处理低阶特征交叉，Deep来处理高阶特征交叉，这个Deep还就是DeepFM中的那个Deep，时下最受热捧的DNN是也！这么说来DeepFM就是把Wide &amp; Deep中的Wide部分改成了FM喽？对！也不对！这句话怎么说，我们先来看Wide &amp; Deep中Wide部分是什么。
都说Wide部分是对低阶特征交叉的处理，那么是怎么个处理法呢？谷歌默默扔出了个
Emm,这长得六亲不认的东西是什么？xi大家都明白了，这就代表一个特征，然后直接来个所有特征连乘？那还叫什么低阶特征交叉，所谓低阶，不是通常就指两个特征交叉么？FM中不就是这样的么？谷歌高冷地说，你没看到每个特征右上角都带了个cki么？那东西非0即1，也就是说如果它是0的话那对应的那个特征不就原地消失了么？那我每个这样的连乘式，每组cki都至多只有两个为1，其余全为0，那每个连乘式不就最多只剩两个特征相乘了么，所以是低阶特征交叉啊，然后我们这样的连乘式共有k个，在每一个连乘式里面若有两个cki为1，那就对应着两个特征交叉项，若只有一个cki为1，那就对应着一个原始特征，你看，一个简洁的式子内涵丰富,是不是淋漓尽致地彰显了我谷歌的逼格，我们还为这种操作取了个更有逼格的名字，cross product!那你又问了，那这连乘式具体要取几个呢？每组的cki又该怎么设置呢，我总不能排列组合打包把每种情况都要了吧，这样如果碰上数据集大型稀疏的场合，具体来说，推荐系统里的CTR不就经常是这种场合？不是会碰上少量数据记录无法拟合大量参数的问题么？（FM中有提及，见最上面的链接）谷歌又冷哼一声，你小子懂得还挺多，你家没程序员么？自己多调调参不就试出来了么？好吧，Wide &amp; Deep中的Wide部分是需要比较有经验的人员帮忙设置这些连乘式的！
Well,说完了wide部分,是时候显出Wide &amp; Deep的全貌了，请看
容易看出，左边的部分就是Deep,右边的那孤零零的部分就是wide,上面标着Cross Product的操作在上面已经说明了，再看DeepFM
可以看到，两个模型的区别是除了低阶特征交叉的处理不同外（一个用FM，一个用Cross Product），还有个重要的区别，DeepFM的两部分共享了底下两层，而Wide &amp; Deep除了使用相同的原始特征外，一早就分道扬镳，DeepFM的两部分结合得更紧密些，这或许是DeepFM表现得更好的原因，谁又知道呢？
关于模型权重的计算，跟DeepFM一样，Wide &amp; Deep也使用SGD就完事了。至此，Wide &amp; Deep模型也就介绍完了。
在一个阴暗的角落，由于忙着教导各路武林高手真正的武术是什么，已经很久没有管具体业务的阿里，直到最近，才看到由手下呈上来的关于Wide &amp; Deep和DeepFM的报告，阿里长长地呼出一口气，心里毫无波动，甚至有些想笑，“CTR？谷歌？华为？very funny!不如让我来教教你们，什么叫电商之王！”
敬请期待，DIN！
DIN
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131c30af25adb0d5084e9dcf83da071e/" rel="bookmark">
			Sqlite3入门学习（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux环境下sqlite3的安装及常用Linux API说明
环境安装 Step1：一般的linux可能会自带sqlite，在安装之前先使用sqlite3命令检测一下，若显示并未安装，则进行下述操作
Step2：先到 https://www.sqlite.org/download.html ，下载sqlite-autoconf-*.tar.gz压缩包
Step3：下载完了，把压缩包放进Linux系统中，放在Ubuntu的桌面，然后解压
Step4：进入解压后路径接着执行命令./configure --prefix=/usr/local 表示安装至usr/local路径下;
Step5: 接着执行命令 make
Step6: 最后执行命令make install
Step7:执行命令sqlite3，检测是否安装成功，如下图所示表示安装成功
常用Linux API说明 sqlite3_open int sqlite3_open(const char* fileName, sqlite3** ppDB);
函数功能：打开一个数据库；若该数据库文件不存在，则自动创建。打开或者创建数据库的命令会被缓存，直到这个数据库真正被调用的时候才会被执行。
输入参数：fileName，待打开的数据库文件名称，包括路径，以'\0'结尾；
特别说明：SQLite 支持内存数据库，内存方式存储使用文件名":memory:"
输出参数：ppDB,返回打开的数据库句柄；
返回值：执行成功返回SQLITE_OK，否则返回其他值；
sqlite3_close int sqlite3_close(sqlite3* pDB);
函数功能：关闭一个打开的数据库；
输入参数：pDB,打开的数据库句柄
输出参数： 无
返回值：执行成功返回SQLITE_OK，否则返回其他值
sqlite3_exec 函数功能：编译和执行零个或多个SQL 语句，查询的结果返回给回调函数callback
int sqlite3_exec(sqlite3* pDB, const char *sql, sqlite_callback callback, void*para, char** errMsg);
输入参数：
pDB：数据库句柄；
sql：待执行的SQL 语句字符串，以'\0'结尾；
callback：回调函数，用来处理查询结果，可以输入NULL；
para：传入的参数，可以为NULL，该参数被传给回调函数callback调用；
输出参数：errMsg,返回错误信息，注意是指针的指针。
返回值：执行成功返回SQLITE_OK，否则返回其他值
sqlite3_busy_handle() int sqlite3_busy_handle(sqlite3*, int(*)(void *, int), void *);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131c30af25adb0d5084e9dcf83da071e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe3fadd2390e71db365685765dc6199f/" rel="bookmark">
			Anaconda conda 不能用，一直Solving enviroment 最后报错CondaHTTPError: HTTP 000 CONNECTION FAILED for url
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在新电脑装Anaconda,创建新环境的时候，conda create -n tensorflow pip python=3.6
Solving enviroment \ 一直转圈圈，不能完成。上网搜索了一大圈方法，于是尝试：
conda update conda 还是转圈圈，不过转了一会出现了以下提示：
CondaHTTPError: HTTP 000 CONNECTION FAILED for url &lt;https://repo.anaconda.com/pkgs/r/noarch/repodata.json.bz2&gt;
Elapsed: -
An HTTP error occurred when trying to retrieve this URL.
HTTP errors are often intermittent, and a simple retry will get you on your way.
If your current network has https://www.anaconda.com blocked, please file
a support request with your network engineering team.
ConnectionError(ReadTimeoutError("HTTPSConnectionPool(host='repo.anaconda.com', port=443): Read timed out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe3fadd2390e71db365685765dc6199f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1de88e734e920f898458913357686736/" rel="bookmark">
			【Tableau】chapter11-范围-线图与倾斜图（个人学习笔记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		----课时作业 1、接听量范围-线图
创建平均值、最大值、最小值计算字段
将这三个计算字段加入详细信息
添加参考线（平均值用线，最大最小值用区间）
最终结果
2、各省劳动生产率倾斜图
创建计算字段——排名
将单位拖至标签，将排名置入行，编辑表计算，特定维度选择期间和单位，重启间隔选择期间，排序顺序按照累计值排序
将排名，累计值拖入标签，拖入的排名也要进行编辑表计算操作，标记选择线末端，全部勾选
此时图如下
创建变化量计算字段，因为变化量有正有负，所以创建一个变化量绝对值计算字段用来修改图中线的粗细，拖入大小
创建颜色标志计算字段，拖入颜色
此时如下图
将区间进行手动排序，先同期再当期发现此时排名是降序排列，设置一个计算字段保存正确排序顺序，替换原来排序字段，并再次编辑表计算，得到结果如下图
----课后练习 1、通话时长范围-线图
2、售电量倾斜图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07577389f3c43543f1106202d25d59d2/" rel="bookmark">
			writing-mode排版属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 快速理解writing-mode属性 writing-mode：文字排版的方式。 区分IE浏览器和非IE浏览器写法（常用）： 非IE浏览器，CSS3规范： ①水平方向，从左到右（默认）： writing-mode: horizontal-tb;&gt; ②垂直方向，从左到右： writing-mode: vertical-lr; ③垂直方向，从右到左： writing-mode: vertical-rl; IE浏览器： ①水平方向，从左到右（默认）： writing-mode: lr-tb; ②垂直方向，从左到右： writing-mode: tb-lr; ③垂直方向，从右到左： writing-mode: tb-rl; 理解：先按照前面部分规则排序，再按照后面部分规则排序。 PS：t=top，b=bottom，l=left；r=right。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06b788fc7e5a50cead36bd3913e65d62/" rel="bookmark">
			DoTween  DOColor颜色、DOFade透明度  渐变动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 using UnityEngine; using System.Collections; using DG.Tweening; using UnityEngine.UI; public class TextColorTween : MonoBehaviour { private Text text;	void Start () { text = GetComponent&lt;Text&gt;(); //颜色渐变，参数：1、红色，2、时间 text.DOColor(Color.red, 2); //渐显，控制透明度的，参数1、alpha值，2、时间 text.DOFade(1, 3); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbefb918ec795f8d86f3b786071d3a6e/" rel="bookmark">
			知识图谱——TransH模型原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		知识图谱——TransH模型原理 1 从TransE到TransH模型 在之前的文章知识图谱——TransE模型原理中，我们介绍了TransE模型的基本原理，对于TransE模型而言，其核心思想为：
h + r = t h+r=t h+r=t
其中h是头实体向量，r是关系向量，t是尾实体向量。根据这个核心公式，我们不难发现其存在着一定的局限性。比如当存在多对一 关系的时候，假设 ( h 1 , r , t ) , ( h 2 , r , t ) (h_1,r,t),(h_2,r,t) (h1​,r,t),(h2​,r,t)，根据TransE的假设，可以确定的是：
h 1 + r = t ， h 2 + r = t h_1+r=t，h_2+r=t h1​+r=t，h2​+r=t
这使得 h 1 , h 2 h_1,h_2 h1​,h2​两个头实体的向量过于相近。与此同时，当存在 ( h , r , t ) , ( t , r , h ) (h,r,t),(t,r,h) (h,r,t),(t,r,h)均在图谱中出现的时候，会计算出r=0，h=t 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbefb918ec795f8d86f3b786071d3a6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd97c43100a540385683d03795a7df1e/" rel="bookmark">
			Flutter全栈式开发之Dart 编程指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 Flutter 是 Google推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart语言开发 App，一套代码可同时运行在 iOS 、Android、Mac、Windows等平台，甚至能生成Web版，运行于浏览器中。
Dart亮相于2011年10月10至12日在丹麦奥尔胡斯举行的GOTO大会上。该项目由Lars bak和kasper lund创建。2013年11月14日，谷歌正式发布Dart 1.0版本
Dart 语法结合Java与JavaScript语法特点，几乎没有令人不适的怪异语法，使Java系程序员倍感亲切，快速上手。
基于目前Flutter的火热，Dart语言也受到重视，但目前缺少一套系统的，细致的Dart编程语言指南，在实践工作中也发现，因为Dart语言没学好，囫囵吞枣式的开始做Flutter开发，一些开发同学极易写出粗糙的代码，或者对语言本身缺乏理解，代码设计不够优雅，Flutter一些源码理解不够深刻（如EventBus、Stream、异步编程等），故录制了一套Dart 编程教程，该套教程着眼于Flutter全栈式，即能熟练运用Dart语言开发Flutter程序，也能使用Dart开发简单的后台服务，编写工具等。
课程内容 课程文档：
全套Flutter全栈式教程暂定大纲如下，后续会视我个人时间情况，适当增加实战案例。后续Flutter课程的更新情况，受我个人业余时间影响，有快有慢，望理解。
视频课程 博主发布的相关视频课程
Flutter全栈式开发之Dart 编程指南
https://study.163.com/course/courseMain.htm?courseId=1209508814&amp;share=2&amp;shareId=480000001855430
Flutter 全栈式开发指南
快速上手篇可试看
欢迎关注我的公众号：编程之路从0到1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa471d5a483f5783131f093389eb1c3/" rel="bookmark">
			多线程/多协程快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程/多协程快速排序 文章目录 多线程/多协程快速排序快速排序代码实现优化建议 快速排序 原理略，百度很多
代码实现 package main import ( "fmt" "sync" "time" ) //分割算法1 func partition1(arr []int, low, high int) int { t := arr[low] for low &lt; high { for low &lt; high &amp;&amp; arr[high] &gt; t { high-- } arr[low] = arr[high] //将小的往前覆盖，第一个覆盖的是枢纽数据 for low &lt; high &amp;&amp; arr[low] &lt;= t { low++ } arr[high] = arr[low] //将大的往后覆盖 } arr[high] = t //将枢纽数据覆盖回去 return low } //分割算法2 func partition2(arr []int, low, high int) int { t := arr[low] y := low //指向最后一个比t小的数，y++就是第一个比t大的数 for i := low + 1; i &lt;= high; i++ { if arr[i] &lt; t { y++ arr[i], arr[y] = arr[y], arr[i] } } arr[y], arr[low] = arr[low], arr[y] fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efa471d5a483f5783131f093389eb1c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/498fb870d5995632751c306dde4a3e96/" rel="bookmark">
			【Android】OkHttp系列(二)：重试/重定向拦截器RetryAndFollowUpInterceptor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该系列OkHttp源码分析基于OkHttp3.14.0版本
文章目录 概述源码分析重试recoverisRecoverable总结所有不允许进行重试的情况 重定向followUp什么时候为nullfollowUpBody什么时候不为null 概述 用于对连接失败时重新连接以及对需要重定向的响应进行重定向。
源码分析 对于所有的拦截器而言，关键逻辑都在其intercept()方法中。
重试 @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; Transmitter transmitter = realChain.transmitter(); int followUpCount = 0;//重定向次数 Response priorResponse = null; while (true) { ...省略部分代码 Response response; boolean success = false; try { //调用后续的拦截器 response = realChain.proceed(request, transmitter, null); success = true; } catch (RouteException e) { // The attempt to connect via a route failed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/498fb870d5995632751c306dde4a3e96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17c4329e3ce4381ecc08fa73d27a409a/" rel="bookmark">
			MATLAB学习笔记（二）绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记目录、内容、截图来自B站郭彦甫老师的视频和课件
Basic plotting 一：Plot from Data plot( ) plot(x,y)
plot(y)【或者plot（x）】：此时x的值取1：n。如plot(cos(0:pi/20:2*pi))
如果在一张图上想画两个图形则加：hold on和hold off
如：
二：Plot style plot(x,y,‘str’) 其中str是我们想去改变的元素
如：使用hold可以使多个图在一个figure里
legend（） legend（‘L1’,‘L2’,…）
title( ) and ?label( ) title()
xlabel()
ylabel()
zlabel()
栗子如图
text（） and annotation（） LaTax：做注解
linspace(x0,x1,n)
其中n代表的是点的数目，即分成n-1等分。
步长应当是(x1-x0)/(n-1)
练习：
t=linspace(1,2);
f=t.^2;
g=sin(2*pi.*t);
plot(t,f,‘k-’,t,g,‘ro’);
legend(‘t^2’,‘sin(2\pi{t})’);
xlabel(‘Time(ms)’);
ylabel(‘f(t)’);
title(‘Mine assignment’);
Graphical object properties figure objectaxes objectline object 一：修改项目 先找到需要修改的地方，再去改
寻找到需要修改的地方 提取或者设置图像性质 get()set() 栗子：（修改数据）
x=linspace(0,2*pi,1000);
y=sin(x);
h=plot(x,y);
get(h)
得到了：
AlignVertexCenters: ‘off’
Annotation: [1×1 matlab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17c4329e3ce4381ecc08fa73d27a409a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7415a44e1521d1a78f1b9ec5be250d54/" rel="bookmark">
			单体应用-SpringBoot-(1)划分模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		几乎完全参考自SpringBoot+Maven多模块项目（创建、依赖、打包可执行jar包部署测试）完整流程
目前由下到上划分了几个模块：
common : 常用比如工具类等
core : 打算用来放一些系统级别相关的类，配置等
dao : 数据层
service : 服务层
web : 前后端分离的话主要就剩下Controller了
下面是项目和每个模块的pom
项目的pom 需要注意的是packaging为pom。
声明每个子模块。
打包使用的插件，暂时还没深入了解，理解应该有错误。
目前我知道的是要打成war包的话，需要SpringBoot帮忙生成WEB-INF, DispatcherServlet等，所以得用spring-boot-maven-plugin。
网上还看到说打包成war还需要排除springboot的内置tomcat，我测试了下没排除的话，没发现什么影响。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.funwe&lt;/groupId&gt; &lt;artifactId&gt;spfun&lt;/artifactId&gt; &lt;version&gt;0.0.1&lt;/version&gt; &lt;name&gt;spfun&lt;/name&gt; &lt;description&gt;spfun&lt;/description&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;!-- 子模块 --&gt; &lt;modules&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;core&lt;/module&gt; &lt;module&gt;dao&lt;/module&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;web&lt;/module&gt; &lt;/modules&gt; &lt;!-- 依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7415a44e1521d1a78f1b9ec5be250d54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20355d7ae2aec33fb604f2791e5f4401/" rel="bookmark">
			json.load()/json.loads()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中json文件处理涉及的四个函数json.dumps()和json.loads()、json.dump()和json.load()的区分 一、概念理解
1、json.dumps()和json.loads()是json格式处理函数（可以这么理解，json是字符串）
(1)json.dumps()函数是将一个Python数据类型列表进行json格式的编码（可以这么理解，json.dumps()函数是将字典转化为字符串）
(2)json.loads()函数是将json格式数据转换为字典（可以这么理解，json.loads()函数是将字符串转化为字典）
2、json.dump()和json.load()主要用来读写json文件函数
总结
res=json.loads(var) var为变量
res=json.load(file) file为文件路径
res都为字典类型
二、代码测试
1.py
1 import json 2 3 # json.dumps()函数的使用，将字典转化为字符串 4 dict1 = {"age": "12"} 5 json_info = json.dumps(dict1) 6 print("dict1的类型："+str(type(dict1))) 7 print("通过json.dumps()函数处理：") 8 print("json_info的类型："+str(type(json_info))) 运行截图：
2.py
1 import json 2 3 # json.loads函数的使用，将字符串转化为字典 4 json_info = '{"age": "12"}' 5 dict1 = json.loads(json_info) 6 print("json_info的类型："+str(type(json_info))) 7 print("通过json.dumps()函数处理：") 8 print("dict1的类型："+str(type(dict1))) 运行截图：
3.py
1 import json 2 3 # json.dump()函数的使用，将json信息写进文件 4 json_info = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20355d7ae2aec33fb604f2791e5f4401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71d3356629ec8061ada1f129c292fc2/" rel="bookmark">
			Android ViewPager2实现无限轮播
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android轮播控件 全新升级，基于ViewPager2实现无限轮播功能。可以自定义indicator，需自定义实现 Indicator 接口，内置了的IndicatorView，支持五种动画切换。支持传入RecyclerView.Adapter 即可实现无限轮播，支持任何ReyclerView.Apdater框架，集成使用请参考Sample。
支持自动轮播支持一屏三页支持自定义Indicator支持自定义view支持数据刷新支持垂直滚动支持任意RecyclerView.adapter，RecyclerView的使用方式。良好的代码封装，更多优化请参考代码实现。 项目地址前往项目地址 效果图 点击下载 banner.apk 体验
基本使用的功能，请下载apk体验更流畅 描述普通样式两边缩放一屏三页 IndicatorViewIndicatorStyleINDICATOR_CIRCLEINDICATOR_CIRCLE_RECTINDICATOR_BEZIERINDICATOR_DASHINDICATOR_BIG_CIRCLE 效果图12收集更多的效果Indicator查看simple代码… 使用步骤 Step 1.依赖banner 项目地址前往项目地址 项目地址前往项目地址 项目地址前往项目地址 Step 2.xml &lt;com.to.aboomy.pager2.Banner android:id="@+id/banner" android:layout_width="match_parent" android:layout_height="150dp"/&gt; Step 3.自定义RecyclerView.Adapter //自定义adapter public class ImageAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; //或者使用其他三方框架，都是支持的，如：BRVAH public class ImageAdapter extends BaseQuickAdapter&lt;String, BaseViewHolder&gt; { public ImageAdapter() { super(R.layout.item_image); } @Override protected void convert(@NonNull BaseViewHolder helper, String item) { Glide.with(mContext) .load(item) .into((ImageView) helper.getView(R.id.img)); } } Step 4.在页面中使用Banner @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e71d3356629ec8061ada1f129c292fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00862cad8996e691a17bbd3871d0f200/" rel="bookmark">
			几种为相片添加地理GPS坐标信息的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前大法的a7开GPS很耗电，一般都是事后加，碰巧手机BUG，手机照相的GPS也看不到了，一不做二不休，长远解决此类问题：
一、Opanda_power_Exif
这个最易用，但要收费，貌似很久没更新了，有1.2的版本破解，自行百度。
二、ExifTool
超级牛，是加拿大的开源软件。
1.打开手机上GPS软件，将相机中的时间用GPS时间对准。
2.在安卓手机上使用OziExplorer或GpsLogger，记录下拍照期间的GPS轨迹。
3.在电脑上，通过exiftool将轨迹文件中的坐标通过时间匹配照片文件，并加入到照片文件的EXIF 中。如果d:\DCIM\ 是照片目录， 命令：
exiftool -geotag=track.gpx d:\DCIM\
大功告成！
另外也有GUI界面，但ExifToolGUI必须配合ExifTool 使用。https://exiftool.org/gui/
附上：科学网上张金龙发布的方法：http://blog.sciencenet.cn/blog-255662-864234.html。这个有点复杂。
在野外， 将GPS和相机设定为相同时间，野外工作完成后保存航迹。野外工作结束，尽快从GPS导出航迹， 格式为gpx格式，例如 track20150131.gpx 。从相机导出照片，到某文件夹下，注意路径中不能有中文（但文件名可以有中文）, 例如D:/plantphotos/20150101， 命名为 IMG_0001.jpg, IMG_0002.jpg
下载 exiftool（ http://www.sno.phy.queensu.ca/~phil/exiftool/ ）的Windows可执行文件， 解压缩， 将 exiftool(-k).exe 重命名为 exiftool.exe ， 拷贝到照片所在的路径。注意照片的完整路径不能有中文。
创建一个纯文本文件， 该文件为csv文件的模板， 用于之后从每张照片的exif文件中导出经纬度。命名为 csv.mft，内容为：
$filename,$gpslongitude#,$gpslatitude#,$gpsaltitude#
创建一个纯文本文件， 命名为 run_exiftool_geotaging.bat，内容为： exiftool -geotag=track20150131.gpx ./
pause
创建一个纯文本文件， 命名为 run_exiftool_creat_csv.bat，内容为 exiftool -p csv.mft ./&gt;test.csv
pause
双击run_exiftool_geotaging.bat文件， exiftool从航迹提取信息， 并为该文件夹下对应时间的照片添加经纬度和海拔。双击 run_exiftool_creat_csv.bat 文件， exiftool读取每张照片的经纬度和海拔， 并保存到相应.csv文件中。 三、德国人的exiftool的GUI工具，没琢磨：geosetter
http://www.geosetter.de/en/download/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2498aa255e199101a96d790daa674ee3/" rel="bookmark">
			leetcode 回溯算法总结（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回溯使用的场景： 回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项，当我们在某一步选择了其中一个选项时，就进入下一步，然后又面临新的选项。我们就这样重复选择着，直至到达最后的状态。
一般画树状图表示
做回溯的题步骤：【树的深度遍历过程】 画图，观察元素是否有重复，如有重复则需要剪枝，思考如何剪枝回溯三要素：路径、选择列表、结束条件按照此代码模板，写出代码。 经验：在做选择后还要撤销选择，如果做出的选择写在函数列表里如backtrack(path + [num[i]], num[:i] + num[i+1:])，那么无需撤销操作，如果写在外面如path.append(nums[i])，这样就需要撤销上一步的操作。对于树来说，是一个节点一个节点的处理的，我通常习惯用第一种，将选择后的路径放在函数里。如果选用第二种，那么需要撤销操作
需要认真思考剑指offer面试题中的 二叉树路径和 和 矩阵中的路径
【https://mp.weixin.qq.com/s__biz=MzAxODQxMDM0Mw==&amp;mid=2247484709&amp;idx=1&amp;sn=1c24a5c41a5a255000532e83f38f2ce4&amp;chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&amp;scene=21#wechat_redirect】
算法框架 废话不多说，直接上回溯算法框架。解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：
1、路径：也就是已经做出的选择。
2、选择列表：也就是你当前可以做的选择。
3、结束条件：也就是到达决策树底层，无法再做选择的条件。
代码方面，回溯算法的框架：
result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。
剪枝方法： 全排列里面的剪枝，只需要考虑后面的元素和第一个元素相同的情况，则continue。但是要注意是要保证同层不同和上下层相同（i &gt; start），详见leetcode40.总结对于全排列题不适合用mark，mark用在矩阵中元素只访问一次的情况下如访问矩阵里的坐标或者字母题。 注意事项 1.如果是选择列表循环内需要判断，用continue（表示这步不行还有机会进行下一步），如果是在选择列表循环外判断则用return中断
2.首先对当前路径进行判断，再进入下一个选择列表中。这样可以保证所有的状态都得到判断。
（剑指offer12，13有感而发）
做题顺序 Leetcode:46，47，39，40，78，90，22
剑指offer：12，13
【leetcode46】全排列
#我一直和组合问题看成是一类问题，动作选择弄成start，但是这题，动作选择根本不适合start，因为它还会选取到start之前的动作，因此，这道题应该把动作改成可选择数字的列表。 #这一题没有重复的情况，不需要剪枝。 class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: #如果有[1, 2, 3],第一次选择1，之后选择2，3，那么这种可以用start #但是对于这道题，第一次选择2，第二次可以选择1，3，这种就没必要用start result = [] size = len(nums) if size == 0:#终止条件 return result def backtrack(path, nums): ''' :param path: 列表 :param nums: 动作选择列表 结束条件：len(path)==size ''' if len(path) == size: result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2498aa255e199101a96d790daa674ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ee78fb162184583da9a5daad5efc93/" rel="bookmark">
			python实现单列模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式简介 所谓的单列模式就是不管什么样的情况，只能有一个对象存在。应用场景有线程池、系统配置对象。总之单列模式中只能有一个对象，而且是首次创建的对象
代码：
class Singleton(object): """ 单例模式 """ class _A(object): """ 真正干活的类, 对外隐藏 """ def __init__(self): pass def display(self): """ 返回当前实例的 ID，是全局唯一的""" return id(self) # 类变量，用于存储 _A 的实例 _instance = None def __init__(self): """ 先判断类变量中是否已经保存了 _A 的实例，如果没有则创建一个后返回""" if Singleton._instance is None: Singleton._instance = Singleton._A() def __getattr__(self, attr): """ 所有的属性都应该直接从 Singleton._instance 获取""" return getattr(self._instance, attr) if __name__ == '__main__': # 创建两个实例 s1 = Singleton() s2 = Singleton() print(id(s1), s1.display()) print(id(s2), s2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ee78fb162184583da9a5daad5efc93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b5e2cf0569c732a941c7a5ee84afac/" rel="bookmark">
			【问题解决】编译VTK时CMAKE中找不到Qt5X11Extras
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译VTK时，use.system.qt5
sudo apt install qt5-default
出现以下错误
CMake Error at /usr/lib/x86_64-linux-gnu/cmake/Qt5/Qt5Config.cmake:26 (find_package):
Could not find a package configuration file provided by "Qt5X11Extras" with
any of the following names:
Qt5X11ExtrasConfig.cmake
qt5x11extras-config.cmake
Add the installation prefix of "Qt5X11Extras" to CMAKE_PREFIX_PATH or set
"Qt5X11Extras_DIR" to a directory containing one of the above files. If
"Qt5X11Extras" provides a separate development package or SDK, be sure it
has been installed.
Call Stack (most recent call first):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58b5e2cf0569c732a941c7a5ee84afac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3905f292cc75390a3c495a513f153470/" rel="bookmark">
			排队打水问题（贪心）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排队打水问题（贪心算法） 【类型一】 有n个人排队到r个水龙头打水，他们装满水的时间为 t 1 t_1 t1​， t 2 t_2 t2​， t 3 t_3 t3​，……， t n t_n tn​为整数且各不相等，应如何安排他们打水顺序才能使他们花费时间最少（含等待时间）？
【分析】 由于排队时，越靠前面的计算次数越多，因此时间越小的人排队越靠前得出结果越小，所以可以用贪心算法解答。
解答步骤：
（1）按时间顺序排序；
（2）将排序后的时间按顺序依次放到每个水龙头的队列中；
（3）统计并输出。
如果当水龙头数目为1时，按时间顺序从小到大放入队列即可
【实现代码】 #include&lt;iostream&gt; #include&lt;algorithm&gt; //#include&lt;iomanip&gt; #include&lt;cstring&gt; using namespace std; int main() { int n,r,sum=0;//人数，水龙头数 int s[5000],arr[5000];//每个水龙头的时间 memset(s,0,sizeof(s)); cin &gt;&gt; n &gt;&gt; r; for(int i=1; i&lt;=n; i++) cin &gt;&gt; arr[i]; sort(arr+1,arr+1+n); int k=0; for(int i=1;i&lt;=n;i++) { k++; if(k==r+1)//r人一组,第r+1个人回到第一个龙头 k=1; s[k] += arr[i];//加上等待时间 sum += s[k];//累加 } cout &lt;&lt; sum &lt;&lt; endl; return 0; } 【类型二】 与类型一类似，n人，r个水龙头，但接水顺序确定不能改变，问需要多长时间所有人打完水（时间仅算第一个人开始到最后一个人打完水结束），如信息学奥赛一本通T1322。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3905f292cc75390a3c495a513f153470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99391c4a8277ede091358dee56d770b0/" rel="bookmark">
			了解一下，Android 10中的ART虚拟机(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缘起
接着上期”了解一下，Android 10中的ART虚拟机(I)“，今天继续介绍ART。今年春节十几天假里，我大概把profman和dex2oat整体看了一遍。出乎我意料的是，dex2oat居然再一次让我看得万念俱灰。
在我写《深入了理解Android Java虚拟机ART》一书的时候，我最早也是先研究的dex2oat，稿子都写了100多页了，但数月过后就是无法拿下，所以只能放下它，转而去研究ART Runtime。这是我写深入理解Android 4本书来第一次碰到这种挫折。所以，书中dex2oat的字节码到机器码的编译部分在第六章，但dex2oat的源码分析却在第九章。
我的困惑
本来以为有了Nougat ART的基础，研究AOSP 10中的ART应该是水到渠成，但没想到依然是困难重重。虽然我很快能把AOSP 10中dex2oat的执行顺序梳理出来（这一点上和AOSP 7.0没有太大区别），但感觉这一路的风景变化很大。这其中，最让我感到恐慌的是这样一个问题：我很强烈的感觉到，dex2oat很多特性、其中的很多代码所对应的功能都和Java VM技术本身有着某种密切关系，但我却不知道这些特性、功能到底是为了解决JVM的什么问题——套用一个朋友的原话”就是每行代码都能看懂，但就是不知道为什么“——也就是知其然，却不知其所以然
也就是说，我一直以来只是被动的去解释ART的代码，但却没有真正掌握JVM。并且，没有掌握随着Java语言本身的发展，随着整体技术的发展，JVM本身所需要做的改进。我相信代码的作者在改进ART虚拟机时脑子是有一条路线的，绝对不是一拍脑袋就想出来的。
我之前很单纯的把上面这个问题归结于我对语言本身不了解。这才有了前面几期公众号中我试图以quickjs和javascript语言为研究课题在这方面有所突破。但这条路可能是失败了。因为js引擎（其实就是javascript虚拟机）难度并不比jvm少。而且，quickjs引擎还涉及到从js代码到quickjs字节码的编译，而这部分在jvm中是不涉及的，因为jvm处理的已经是字节码了。
那么，问题到底在哪？同时，我对研究ART的好处也产生了巨大的怀疑，研究这玩意到底学到了什么？（这个质疑对我个人来说已经是非常严厉的了）。万般无奈之下，我转而去看一下别人关于JVM的书都讲些什么。于是，我在微信读书PC版上完整的读了周志明老师《深入理解Java虚拟机：JVM高级特性与最佳实践》，最新版，两遍。它给我带来了意想不到的感受和认识。
我的一些认识
先简单说下周老师这本书，我认为是名至实归的深入理解。这种”深入理解“的表现方式并不是和我的书一样，把代码给你弄出来，一行一行去给你解释。而更倾向于一种”深入浅出“：一个很复杂的东西，用最简单，最让人理解的方式表达出来，同时把它出现的背景，渊源，未来发展，甚至在实际案例中的价值都讲出来。这就非常非常难了，光涉及”渊源“的地方就需要做大量长期的跟踪工作。神农班之前安排过一个局，就是介绍Java泛型，有同学洋洋洒洒千字，但和书中对泛型在java中的介绍对比起来，这文字背后所体现的技术功底的差距就非常明显了。
再说下我从周老师这本书里看到的一些东西。先讲讲技术之外的认识。我必须客观承认，周老师这本书我现在是能几乎无障碍读下来，而且有恍然大悟的体会。这个结果归根结底还是这几年在ART上花的功夫。这就是所谓的付出终有回报。尤其在周书中介绍编译器这一块，我没感受到太大的难度，包括Java字节码，Class的解析等。要知道在2015年前，我在Java上的经历只不过用Java开发过一些Android UI程序，对JVM毫无所知。所以，通过这一点，我觉得前几年对ART的投入，以及最终的结果——《深入理解Android Java虚拟机ART》这本书还是有效果。这个认识给了我一点信心。BTW，我感觉上述效果对其他读者也是有的。大家可以试一下——也就是拿我的书结合周老师的书一起看看。
接下来介绍一下技术方面的认识。
首先，JVM从一开始就不纯粹是为了Java语言而生的。我看了周老师书之后才注意到这一点。其实在Jvm规范中，人家开篇就说了”The Java Virtual Machine knows nothing of the Java programming language, only of a particular binary format, the class file format. A class file contains Java Virtual Machine instructions (or bytecodes) and a symbol table, as well as other ancillary information.“。
上面英文的意思是JVM和Java编程语言毛关系都没有。它只认class文件。这句话完全拓展了我对JVM的认识。我一直对OS很痴迷。只不过Linux Kernel被其它人上上下下左左右右前前后后都玩透了，所以我才选择设备端的JVM为目标。但我之前并未把jvm当做一个类似kernel，类似qemu这样的虚拟机。我还计划过今年什么时候花点时间好好研究下真正的虚拟机QEMU（源码都下好了）。但这句话一出，原来踏破铁鞋无觅处，JVM就是VM（虽然实际上它还是和Java语言有各种各样的关系，但我现在看待它的角度不太一样了），不要把它和Java语言绑定死。实际上，几十年来，java语言从1发展到今天的13，但字节码却只新增了一个invoke-dynamic。从这个角度看，kotlin这个语言其实也可以当做一门独立于Java之外的语言了。甚至，只要有合适的工具，我们可以把C/C++/Javascript的代码编译成class文件，转而由jvm执行了。再想多一点，某公司的某编译器，貌似其愿景和早已有几十年历史的jvm殊途同归咯？
其次，我之前一直不明白jvm规范里为什么还要有linking（链接）的概念。我早期一直从事C++的开发。在C++开发中，链接往往是编译阶段的事情。而且，这个事情是通过一个比较明确的阶段来做的。即先编译，然后链接，然后生成最终的二进制。但写java程序的时候，本身是感受不到链接的。为何JVM里会有呢？其实，我们只要从一个高层次的角度来看待链接就能明白。链接，我猜测（没考证，仅仅是根据书中的内容推断的）应该在各种语言里都存在。因为它是为了解决这样的一个基本问题：即你写的代码如何调用别人写的代码？在C++开发中，这个工作是由程序员来主动完成的。但对jvm来说，链接是由jvm来完成的。其目标都是一样，把你代码里调用的符号和真实的地方对应起来。
再有，对协程的重新认识。java里的协程我最早在2010年左右就曾经接触过，但作为一个C++开发者，我对线程的认识更熟悉，认为OS里的线程调度是经过千锤百炼的，而协程最终还是要转换成对线程的使用，自己搞个调度器实在是????。但最近这几年随着go语言的使用，协程又重新展示了它的巨大价值。周老师书中展示了一个测试比较，用协程后，系统的吞吐量大增。所以，协程肯定是有价值的。貌似java语言后续要原生支持协程，只不过自己搞个调度器的难度确实不小。大家拭目以待。
最后，周老师书中对JIT和AOT优劣势有非常详细的介绍。这个让我对某司某编译器的搞法有了不同角度的评价。仁者见仁智者见智，这里就不多说了。我总体感觉是，JVM的发展和Java语言的发展关系密切，如果仅从android这个小小的领域里想引领jvm的发展，显然是有极大和致命的不足。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99391c4a8277ede091358dee56d770b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3b5a940e460be116e5bf3ea11100df4/" rel="bookmark">
			let/const 的变量提升与暂时性死区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从一道面试题说起 请说出 let，const，var 的区别
大部分的回答是这样的，甚至很多博客中的答案也是这样的:
let/const 提供了块级作用域let 不能重复定义var 有变量提升，let / const 没有变量提升 前两条没什么问题，第三条中 var 有变量提升 也是对的，而 let / const 没有变量提升 确是错误的，且有很大的迷惑性。本文就从这一点谈起：
let / const 存在变量提升(hoist)以及它们的暂时性死区(TDZ)
let/const 没有变量提升的错觉 console.log(aVar); // undefined console.log(aLet); // causes ReferenceError: aLet is not defined var aVar = 1; let aLet = 2; var 与 let 的对比式运行结果，强烈的衬托出 let 似乎没有变量提升，否则为什么会有 aLet is not defined 报错
let/const 变量提升的反例 let x = 'outer value'; (function() { console.log(x); let x = 'inner value'; }()); 为什么说上述例子可以证明 let 会发生变量提升呢
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3b5a940e460be116e5bf3ea11100df4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/447/">«</a>
	<span class="pagination__item pagination__item--current">448/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/449/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>