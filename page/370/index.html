<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55a04c2d1e6911fc577b70fee829382/" rel="bookmark">
			剖析ES类的constructor及static,public,private,protected区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6引入了class类的概念，创建的每一个class类，都会有一个constructor()方法，该方法是一种用于创建和初始化class创建的对象的特殊方法–构造函数方法。
class Animal(){} 等同于 class Animal(){ constructor(){} //默认的constructor方法 } 继承
class Parent { constructor(name, age) { this.name = name; this.age = age; } getName() { console.log(this.name) } } class Child extends Parent { constructor(name, age) { super(name, age) //代表父类的构造函数 this.name = name // super 之前会报错， 应该写在super 之后 } } 拓展,添加protected声明的变量可以直接访问
class Parent { constructor(protected name) { } getName() { console.log(this.name) } } 在ES6中，我们的javascript也有了类，那么，JS中的类有没有static,public,private,protected这些关键字呢，又是怎么样的呢，本文主要带你探讨JS类中的static,public,private,protected这些关键字的使用。
1、static 类（class）通过 static 关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能。
静态方法调用同一个类中的其他静态方法，可使用this关键字。
class StaticMethodCall { static staticMethod() { return 'Static method has been called'; } static anotherStaticMethod() { return this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55a04c2d1e6911fc577b70fee829382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c81f3d23d482d4a4f668bc9a1e817e/" rel="bookmark">
			德州扑克实践之三-----比较大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经过前面的两篇文章，整体工作已经完成了2/3了，剩下的1/3，将会在本片文章提及
整体流程： 比较之前须得获取，牌型，牌值，这两部分在上一篇文章已经讲解了，不懂得小伙伴可私信我，乐意解答！ 之后就是简单的遍历，通过两两比较，并排好序，就得到含有玩家按顺序从大到小拍好的数组，类似于[0，3，1，2] 然后就是翻译：玩家0&gt;玩家3&gt;玩家1&gt;玩家2 说明：比较大小并排序有许多算法，小编的不是最好的，相信你可以写出更好的算法，节约大量的时间和空间 接上一篇的文章 players=deal_cards(2,5) Values=sort_values(players) CArdtype=result_card_type(players) -------------------------------------- '''通过以上三行代码就可以得到牌值和牌型了''' 知道了牌型 牌值 就是进行比较了，加入自己玩的话，肯定是先比较牌型，牌型相同在比较大小，简单来说就是这样，代码实现也是这样
def compare_value(player_fir, play_sec, card_type_fir, card_type_sec): if card_type_fir &lt; card_type_sec: return 1 #first&lt;second elif card_type_fir &gt; card_type_sec: return -1 #first&gt;second elif card_type_fir == card_type_sec: #牌型相等 比较大小 if card_type_fir in [9, 5, 4, 1, 0]: #高牌、顺子、同花、同花顺、皇家同花顺 直接比大小 for i in range(5): if player_fir[i] &gt; play_sec[i]: return 1 elif player_fir[i] &lt; play_sec[i]: return -1 elif card_type_fir in [2, 3, 6]: #四条、葫芦、三条 比较中间的呢个牌值 if player_fir[2] &gt; play_sec[2]: return 1 elif player_fir[2] &lt; play_sec[2]: return -1 else :#相等 for i in range(5): if player_fir[i] &gt; play_sec[i]: return 1 elif player_fir[i] &lt; play_sec[i]: return -1 elif card_type_fir == 7: #两对 if player_fir[1] &gt; play_sec[1]: return 1 elif player_fir[1] &lt; play_sec[1]: return -1 else: if player_fir[3] &gt; play_sec[3]: return 1 elif player_fir[3] &lt; play_sec[3]: return -1 else: for i in range(5): if player_fir[i] &gt; play_sec[i]: return 1 elif player_fir[i] &lt; play_sec[i]: return -1 elif card_type_fir == 8: #一对 先找到对子的位置，比较大小 d1, d2 = 0, 0 for i in range(4): if player_fir[i] == player_fir[i + 1]: d1 = player_fir[i] if play_sec[i] == play_sec[i + 1]: d2 = play_sec[i] if d1 &gt; d2: return 1 elif d1 &lt; d2: return -1 elif d1 == d2: for i in range(5): if player_fir[i] &gt; play_sec[i]: return 1 if player_fir[i] &lt; play_sec[i]: return -1 return 0 以上代码为比较大小的核心代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c81f3d23d482d4a4f668bc9a1e817e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cab219a8b0977df756301fc3bcc42fb8/" rel="bookmark">
			【前端】excel数据处理，转义字符&amp;lrm；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬虫爬出来的“数值”，在excel做计算的时候出错了
#VALUE! 一开始觉得应该是数据类型出错了，做了很多尝试，比如常用的：
1. 文本分列
2. 贴到记事本再复制
不过，并没有用
倒回去看错误原因：
这时候反应过来，是出现隐藏的字符了，
回去看html代码段，有新发现
出现了，转义字符：
&amp;lrm; 原来元凶就是它，占着位置，但是很难被发现！！！
解决办法：
用着excel，就用excel解决问题吧~
好家伙，前后夹击
=MID(B3,2,2) 搞定，这样就变成数值型了，可以进行下一步计算
反过来一想，如果想要防止爬虫，也许这是个点子喔，乍一看就真的好像爬的数据出现问题了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5390744b7fd19d8d87ec5ebbfa862e00/" rel="bookmark">
			动态开关定时任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @ConditionalOnProperty 注解通过havingValue与配置中心的scheduled的值相同则开启定时任务,如果不同则关闭,实现动态开关定时任务 @ConditionalOnProperty(prefix = "imageScheduled" , name = "scheduled" , havingValue = "true") //配置文件 true开启 false关闭 imageScheduled: scheduled: true cron: 0 0/1 * * * ? 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b21e31b8002108b7b03dc0a8f39e2f/" rel="bookmark">
			Django：HttpResponse对象的属性与方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.HttpResponse对象： 对于HttpRequest对象来说，是由django自动创建的，但是，HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。
HttpResponse类在django.http.HttpResponse， 在HttpResponse对象上扩展的常用方法：
页面渲染： render()（推荐）&lt;br&gt; render_to_response(),
页面跳转：redirect("路径")
locals()： 可以直接将函数中所有的变量传给模板
2.HttpRequest属性： path： 请求页面的全路径，不包括域名
method： 请求中使用的HTTP方法的字符串表示。全大写表示。例如
if req.method=="GET":
do_something()
elseif req.method=="POST":
do_something_else()
GET: 包含所有HTTP GET参数的类字典对象
POST： 包含所有HTTP POST参数的类字典对象
服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过
HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用
if req.POST来判断是否使用了HTTP POST 方法；应该使用 if req.method=="POST" COOKIES: 包含所有cookies的标准Python字典对象；keys和values都是字符串。 FILES： 包含所有上传文件的类字典对象；FILES中的每一个Key都是&lt;input type="file" name="" /&gt;标签中 name属性的值，FILES中的每一个value同时也是一个标准的python字典对象，包含下面三个Keys：
filename： 上传文件名，用字符串表示
content_type: 上传文件的Content Type
content： 上传文件的原始内容
user： 是一个django.contrib.auth.models.User对象，代表当前登陆的用户。如果访问用户当前没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。
你可以通过user的is_authenticated()方法来辨别用户是否登陆： if req.user.is_authenticated();
只有激活Django中的AuthenticationMiddleware时该属性才可用
session： 唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。
2.HttpRequest方法： 方法： get_full_path(), 比如：http://127.0.0.1:8000/index33/?name=123 , req.get_full_path()得到的结果是 /index33/?name=123
req.path得到的结果就是 /index33
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1782d76f71a4aef87e9a89e1a9773721/" rel="bookmark">
			在外部DDR3内存中运行的MicroBlaze程序的固化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文以基于米联客MA703FA开发板的MicroBlaze LWIP千兆以太网例程为例，详细介绍在外部DDR3内存中运行的MicroBlaze程序的固化方法。
FPGA型号：XC7A35TFGG484-2
首先打开Vivado工程，进入Block Design，添加AXI Quad SPI IP核：
点击Run Connection Automation，连接AXI LITE总线，并导出SPI引脚：
再次点击Run Connection Automation，连接Quad SPI的时钟：
双击Quad SPI IP核，进入配置界面。将Mode设置为Quad（四线），Slave Device设为Micron（SPI Flash的品牌）。注意下面要勾选Enable STARTUP Primitive。
点击Run Synthesis，开始综合：
综合完毕，选择Open Synthesized Design：
点击Schematic：
显示引脚配置面板：
配置SPI Flash的4线I/O引脚：
配置SPI Flash的片选引脚：
注意：SPI Flash的时钟引脚不用配置。
确保xdc文件里面已经配置好SPI 4线模式：
set_property CFGBVS VCCO [current_design] set_property CONFIG_VOLTAGE 3.3 [current_design] set_property BITSTREAM.GENERAL.COMPRESS true [current_design] set_property BITSTREAM.CONFIG.CONFIGRATE 50 [current_design] set_property BITSTREAM.CONFIG.SPI_BUSWIDTH 4 [current_design] set_property BITSTREAM.CONFIG.SPI_FALL_EDGE Yes [current_design] 配置完毕后，点击Generate Bitstream，产生bit文件：
生成失败，提示LUT资源不够。这是因为以太网工程比较大，加入了Quad SPI之后，XC7A35T里面的LUT资源不够了。
考虑到我们程序里面只用到了定时器中断，其他五个中断都没有用到，所以我们可以只保留定时器中断，其余的全部删除。
回到Block Design里面，我们把AXI Interrupt Controller上挂接的Concat删掉，把定时器的interrupt中断引脚接到AXI Interrupt Controller的intr上面去。连线后，上面还是显示的是intr[5:0]，不用管，待会儿综合完毕，它会自动变成intr[0:0]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1782d76f71a4aef87e9a89e1a9773721/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d712b7f664608afad71d7e859065cb0/" rel="bookmark">
			springmvc数据响应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springmvc数据响应有两种方式：
1、页面跳转方式：收到客户端请求后，业务处理函数返回要跳转的页面
2、回写数据方式：收到客户端请求后，业务处理函数直接返回数据，如字符串，对象，集合等
一、页面跳转方式 前置准备工作：
1、写对应跳转视图controllTest.jsp
这里注意添加isELIgnored=“false”，其意义为是否忽略代码中的表达式（默认值true,忽略）如：${username}，如果值true，最终网页上会直接显示字符“${username}”，如果值false，这里的username会根据业务处理函数中的模型设置的实际值进行显示。
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isELIgnored="false" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;success!!!${username}&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 2、在spring-mvc.xml中配置视图解析器，添加视图前后缀
&lt;!-- 视图解析器配置 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--prefix是前缀，suffix是后缀，解析器会将前缀+视图+后缀的顺序拼接，访问最终视图--&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;property name="prefix" value="/"&gt;&lt;/property&gt; &lt;/bean&gt; ------------------页面跳转方式有如下4种------------------
@Controller @RequestMapping("/user") public class UserControll { @RequestMapping("/testControll1") public ModelAndView controllTest1() { // 创建模型和视图对象 ModelAndView modelAndView = new ModelAndView(); // 设置模型属性 modelAndView.addObject("username", "test1"); // 设置视图 modelAndView.setViewName("controllTest"); // 返回模型和视图 return modelAndView; } @RequestMapping("/testControll2") // spring-mvc为我们提供了ModelAndView对象，可以直接使用 public ModelAndView controllTest2(ModelAndView modelAndView) { // 设置模型属性 modelAndView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d712b7f664608afad71d7e859065cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00113bc00cdab587618bef9ba69ab608/" rel="bookmark">
			MD5码加密（盐值加密）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MD5码加密（盐值加密） ​ 主要应用于用户密码在数据库的存储，当我们需要保存用户账号密码信息用于身份验证时，如果密码直接以明码的形式保存在数据库，很容易在数据库信息泄露时造成安全隐患。
​ 所以需要一种加密算法且算法不可逆来保证密码存储的安全性。
MD5信息摘要算法，一种被广泛使用的密码散列函数，可以产生出一个128位的散列值，用于确保信息传输完整一致。
盐值，一串随机字符串。
MD5盐值加密，作用就是为了防止MD5被暴力破解。通过盐值和密码进行组合计算得出MD5，在数据库中要同时存储该MD5码及盐值。在需要验证密码正确性时，可以将密码和数据库中对应账号密码的盐值组合计算出的MD5与数据库中的MD5进行比对。
DigestUtils进行MD5加密 import org.apache.commons.codec.digest.DigestUtils; @Test void PasswordText() throws Exception { String pwd1 = "123456"; System.out.println(DigestUtils.md5Hex(pwd1)); String pwd2 = "123457"; System.out.println(DigestUtils.md5Hex(pwd2)); } 打印结果：
e10adc3949ba59abbe56e057f20f883e f1887d3f9e6ee7a32fe5e76f4ab80d63 Md5Crypt进行MD5盐值加密 import org.apache.commons.codec.digest.Md5Crypt; @Test void PasswordText() throws Exception { String pwd1 = "123456"; //该方法盐值头必须加上"$1$",且仅支持8位以内的随机字符串 System.out.println(Md5Crypt.md5Crypt(pwd1.getBytes(), "$1$salt")); System.out.println(Md5Crypt.md5Crypt(pwd1.getBytes(), "$1$salt")); System.out.println(Md5Crypt.md5Crypt(pwd1.getBytes(), "$1$sal")); //自定义工具类用于获取盐值 String salt = RandomSaltUtil.getSalt(6); System.out.println("salt:"+salt); System.out.println(Md5Crypt.md5Crypt(pwd1.getBytes(), salt)); salt = RandomSaltUtil.getSalt(6); System.out.println("salt:"+salt); System.out.println(Md5Crypt.md5Crypt(pwd1.getBytes(), salt)); } 打印结果：
$1$salt$638tR8bROOvPnPklDQ9Vf/ $1$salt$638tR8bROOvPnPklDQ9Vf/ $1$sal$1afz/G1WVDMaQYYTVmyRG1 salt:$1$8PSRMX $1$8PSRMX$/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00113bc00cdab587618bef9ba69ab608/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df662f7bfeed6314339e9b27e0779f06/" rel="bookmark">
			Visual Studio 2015 安装教程（附安装包）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Visual Studio 对于程序员来讲应该是一个非常熟悉的开发工具了，对于从事GIS软件开发的C++或QT开发人员，就更是一款不可缺少的开发工具了！
现在为大家分享一个2015版的Visual Studio，你可以通过关注微信公众号“水经注GIS”之后，在后台回复“VS2015”即可获取软件下载地址。
Visual Studio 2015 安装教程 Visual Studio 2015 下载完成之后，会有一个名为“vs2015.pro_chs.iso”的光盘镜像文件，如下图所示。
光盘镜像文件
将光盘镜像文件在虚拟光驱中加载之后，可以打开查看光盘内容，如下图所示。
安装文件
双击“vs_professional.exe”可以开始进入软件安装界面，如下图所示。
初始化安装
在安装过程中，可以选择安装位置，然后可以按默认值安装也可以自定义安装，这里我们选择自定义安装，如下图所示。
自定义安装
由于我们主要基于C++进行开发，因此选择了“Visual C++”选项，你可以根据自己的需要进行选择。
选择功能
确认自定义选择的功能项正确，并确保安装盘有足够的空间后，点击“安装”按钮可以开始安装，如下图所示。
选定功能确认
现在，只需要静静地等待它安装，这个安装过程比较耗时间，在此期间可以先去做一些其它的工作。
正在安装
经过比较长一段时间的安装之后，会提示安装完成，当启动软件时会提示登录，这里点击“以后再说”跳过即可，如下图所示。
安装完成
第一次启动会要求选择开发环境，我们这里选择“Visual C++”环境，你可以根据实际需要进行选择，如下图所示。
开发设置
配置开发环境，大概需要几分钟时间，如下图所示。
开发环境配置
Visual Studio 2015 启动之后，会进行初始界面，如下图所示。
软件界面
现在，整个Visual Studio 2015就安装完成了，你可以通过新建项目开始你的开发工作。
总结 Visual Studio 应该是GIS行业的用得比较多的开发工具，水经注的所有软件产品都基于该工具进行开发和编译。
当前为你分享的 Visual Studio 是2015版本，你可以通过关注微信公众号“水经注GIS”之后，在后台回复“VS2015”获取软件下载地址。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab0514f8dddbe6bfd95c5e64c18eb85/" rel="bookmark">
			协方差矩阵及其计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观测矩阵 例：如果观测 N N N个人的体重 w w w和身高 h h h，这样会形成 R 2 R^2 R2的样本空间，观测向量 X j X_j Xj​（ X j ⊆ R 2 X_j\subseteq R^2 Xj​⊆R2）表示第 j j j个人体重和身高，观测矩阵可以表示为：
[ w 1 w 1 … w N h 1 h 2 … h N ] \begin{bmatrix}w_1&amp;w_1&amp;\dots &amp;w_N\\h_1&amp;h_2&amp;\dots &amp;h_N \end{bmatrix} [w1​h1​​w1​h2​​……​wN​hN​​]
其中：
X 1 = [ w 1 h 1 ] X_1=\begin{bmatrix}w_1\\h_1 \end{bmatrix} X1​=[w1​h1​​]， X 2 = [ w 2 h 2 ] X_2=\begin{bmatrix}w_2\\h_2 \end{bmatrix} X2​=[w2​h2​​]， X N = [ w N h N ] X_N=\begin{bmatrix}w_N\\h_N \end{bmatrix} XN​=[wN​hN​​]，这些为观测向量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab0514f8dddbe6bfd95c5e64c18eb85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef45895286a7e3b8a005379b160f5cd2/" rel="bookmark">
			boost入门（二）：Asio的编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 经过上一篇文章《boost入门：boost简介》，我们编译了boost库。下面我们学习下Asio。
Asio是不需要编译成lib文件，直接在程序中引入头文件即可。Asio依赖的库比较多，我们可以看下它的依赖：
Boost.System（必须）
Boost.Coroutine（可选），如果用spawn()启动协程就需要它
Boost.Regex（可选），如果使用带参数的read_until()或async_read_until()重载boost::regex
OpenSSL（可选），如果你使用Boost.Asio的SSL支持
Boost.Thread
Boost.Date_Time
Boost.Serialization
是不是很多，上面我们编译整个boost的时候已经生成了绝大多数，只剩下一个OpenSSL。
OpenSSL是不是编译很让人头疼，有个网址可以提供编译好的lib文件和dll文件。我也是偶尔间发现的，请看网址：Win32OpenSSL
上面是OpenSSL64位的安装包，下面是OpenSSL 32位的安装包。带Light是精简版本，建议下载不带Light的版本。下面是我本地电脑的安装目录：
lib文件存放着可链接的lib，我一般用静态链接：
运行示例，测试环境 我们演示两种，一种是自动链接到其他boost库的，比如：Boost.Coroutine，一种需要链接OpenSSL。
首先我们先链接Boost.Coroutine，无需再项目上添加链接库，直接将以下代码拷进项目里面:
// // echo_server.cpp // ~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include &lt;boost/asio/io_context.hpp&gt; #include &lt;boost/asio/ip/tcp.hpp&gt; #include &lt;boost/asio/spawn.hpp&gt; #include &lt;boost/asio/steady_timer.hpp&gt; #include &lt;boost/asio/write.hpp&gt; #include &lt;iostream&gt; #include &lt;memory&gt; using boost::asio::ip::tcp; class session : public std::enable_shared_from_this&lt;session&gt; { public: explicit session(boost::asio::io_context&amp; io_context, tcp::socket socket) : socket_(std::move(socket)), timer_(io_context), strand_(io_context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef45895286a7e3b8a005379b160f5cd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a10e11801214b63b5344ef887dce9cf1/" rel="bookmark">
			express路由及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由 路由表示应用程序端点 (URI) 的定义以及端点响应客户机请求的方式。 有关路由的简介，请参阅基本路由。
以下代码是非常基本的路由示例。
var express = require('express'); var app = express(); // respond with "hello world" when a GET request is made to the homepage app.get('/', function(req, res) { res.send('hello world'); }); 路由方法 路由方法派生自 HTTP 方法之一，附加到 express 类的实例。
以下代码是为访问应用程序根目录的 GET 和 POST 方法定义的路由示例。
// GET method route app.get('/', function (req, res) { res.send('GET request to the homepage'); }); // POST method route app.post('/', function (req, res) { res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a10e11801214b63b5344ef887dce9cf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288af408e4f8ab37450d902aa363b246/" rel="bookmark">
			Qt样式表：QComboBox的弹出列表样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QComboBox的弹出列表的类型是QAbstractItemView。这是个抽象类，无法创建对象，如果QComboBox自定义弹出列表类型使用的是它的子类，一般是QListView。当然用其他子类也行，如：
ui-&gt;comboBox-&gt;setView(new QTreeView()); 就是看起来怪怪的。
弹出列表参考样式：
QComboBox{ border-radius: 6px; border: 1px solid #00bcd4; padding:6px 10px 6px 10px; color: #000000; } QComboBox::drop-down{ border:none; } QComboBox::down-arrow{ image: url(:xiala_black.png);border: none; } QComboBox:disabled{ background: #d8d8d8; } QComboBox QAbstractItemView{ background-color: #FFFFFF; color:#000000; border:1px solid #00bcd4; border-radius:6px; outline:none; } QComboBox QAbstractItemView::item{ selection-background-color: #00bcd4; color:#000000; height:40px; border-radius:6px; } QComboBox QAbstractItemView::item:selected{ background-color: #00bcd4; color:#FFFFFF; } QComboBox QScrollBar:vertical{ width:10px; background-color:transparent; border:none; border-radius:6px; } QComboBox QScrollBar::handle:vertical{ border-radius:6px; width: 10px; background:#00bcd4; } QComboBox QScrollBar::handle:vertical:hover{ background:#24d4e0; } QComboBox QScrollBar::add-line:vertical{ border:none; } QComboBox QScrollBar::sub-line:vertical{ border:none; } QComboBox要设置setView()弹出列表样式才会起作用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/288af408e4f8ab37450d902aa363b246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db22ec7e7d92e475a09e36b55f110699/" rel="bookmark">
			SAP Data Service操作简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SAP Data Service是通过SAP HANA认证的ETL工具，其主要功能就是将数据从多个业务系统中抽取出来，进行必要的处理，如转换、合并、过滤、清洗，然后加载到BW系统或者HANA.
DS的主界面如下：
介绍一下几个名词：
1、project。 项目是允许对作业进行分组的可重用的对象，简单来说，就是个文件夹，方便对作业的分类管理。
2、Job. 作业是唯一可以执行的对象。可以在开发过程中手动执行来测试作业。在生产过程中，可以调度批作业并将实时作业设置为服务，当Data Integrator 收到消息请求时，服务将执行某个进程。作业由一个或多个步骤构成，每个步骤都由一个对象图标来表示。
3、Workflow。工作流定义了用于执行数据流的决策过程。例如，工作流中的元素可基于前一个作业设置的值来确定执行路径，也可以在主路径中出现错误的情况下指明一个替代路径。工作流的最终目的是为执行数据流做准备，并在数据流完成后设置系统的状态。所有的工作流节点都会在这里进行展示，并且标明被调用的次数。
4、Data Flow。所有的数据流节点都会在这里进行展示，并且标明被调用的次数。
5、Transform. 转换对数据集进行操作。转换处理输入集并产生一个或多个输出集。相比之下，函数可以对数据集中特定列内的单个值进行操作。Data Integrator 包含许多个内置转换。可以在对象库的“转换”选项卡上使用这些转换。Transform里边常用的组件包括Merge、Query、SQL等。
Merger是将两个或多个数据源中的行统一到一个目标中；Query检索满足指定条件的数据集，Query 转换与 SQL SELECT 语句相似。SQL用于执行所指示的 SQL 查询操作。
操作流程：
创建 project -&gt; 创建job -&gt; 创建workflow -&gt; 创建dataflow
创建作业
右键单击相应的project，选择“new bath job”
给作业命名
右键作业
创建Workflow
首先打开任务，将workflow拖入任务
创建Dataflow
创建target表和source表
右键单击数据库
当数据库表数量非常多的时候，使用import by name的方式比较好，这样就可以只导入自己需要的表。
输入要导入的表名称，然后点击import
右键数据库，执行刷新就可以看到导入的表
将表拖入到已经建好的dataflow中，会出现make source 和 make target两种选项。make source:作为数据源头，make target：作为数据存放的目标表
Query的设置
在source表和target表中间，必须要加上一个query来进行mapping
双击query 进行数据字段绑定：
将左边的source中的字段依次拖拽到query中的对应字段。
Mapping是对字段做一些处理，functions中有一些系统定义的方法。
也可以在where中添加筛选条件
Script的使用
有些表是全量更新的，在插入新数据之前，需要删除原数据，这种情况就可以使用Script写JS代码来实现。将Script放在工作流的前面执行。
参数
在Script和Where里都会使用到参数，参数是在作业里创建，然后在Script中初始化后，Script和后面的工作流中都可以使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db22ec7e7d92e475a09e36b55f110699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c163f62f63a66bb363f8433a7e6f474b/" rel="bookmark">
			cadence allegro画pcb时如何选中元器件的指定位置移动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		画PCB时有时我们需要精确定位某一元器件位置，但是当我选中该元件时，鼠标抓取的位置并不是我们想要的，那么该如何修改
1.Find面板中选择你要移动的元件属性：symbol、pin、via、text…
然后选中你要移动的元件。
2.点击edit菜单栏，选择move，或者在工具栏中选择十字图标。
3.右键，选择options—&gt;Rotation point
~symbol origin 封装的原点，指的是你画该封装时指定的原点位置
~body center 元件中心
~user pick 用户鼠标指定位置
~symbol pin number 封装引脚编号
4.指定坐标点，x x轴坐标值 y轴坐标值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d9d1700a94f64f5f1eb93def61db8a/" rel="bookmark">
			【论文阅读】A New Meta-Baseline for Few-Shot Learning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【论文阅读】A New Meta-Baseline for Few-Shot Learning 参考文献格式：Chen Y , Wang X , Liu Z , et al. A New Meta-Baseline for Few-Shot Learning[J]. 2020.论文地址：https://arxiv.org/abs/2003.04390源码地址：https://github.com/yinboc/few-shot-meta-baseline 1.1 主要内容 提出了一种元基线 (Meta-Baseline)方法，通过在所有基类(base classes)上预先训练分类器，并在基于最近质心的小样本(few-shot)分类算法上进行元学习，实验结果大大优于目前最先进的方法。
在元学习阶段，一个模型在基类未见任务中的获得更强泛化能力的同时，在新类任务中的泛化表现可能反而下降。此外，对于元基线来说，存在2个重要的因素：一个是预训练，另一个是从预训练分类器中继承一个好的小样本分类度量。这就有可能让模型更好地利用，具有更强可传递性的预训练表示。
什么是元基线方法？ 小样本学习的目的，是让分类模型能迁移到仅带有少量标记样本的新类别中。而元学习是目前小样本学习研究中比较常见的方法。作者元基线方法所做的，是用最简单的形式利用预训练分类器和元学习的优势。
元基线方法包括两个训练阶段。
阶段一：预训练阶段
预训练阶段，主要是**分类器基线（Classifier-Baseline）**的训练。
具体方法是，在具有标准交叉熵损失的所有基类上训练分类器，然后删除其最后一个 FC 层，得到编码器 fθ。编码器能将输入映射到特征空间。
阶段二：元学习（meta-learning）阶段
这一阶段，主要基于分类器基线评估算法，进行模型优化。
给定预训练特征编码器fθ，在基类训练数据中采样 N-way K-shot 任务。
为了计算每个任务的损失，在支持集（support-set）中计算N种类型的质心，公式如下：
然后用它们来计算查询集（query-set）中每个样本的预测概率分布，公式如下：
损失是根据 p 和查询集样本的标签计算的交叉熵损失。
1.2 实验结果 元基线方法效果如何？（大幅提升性能） 论文作者在 miniImageNet 和 tieredImageNet 两个数据集上进行了实验。
（ miniImageNet）
（tieredImageNet）
改进效果并不仅仅局限于 N-way K-shot 任务。在单类 K-shot 任务中，实验结果同样证明了元学习阶段的有效性。
作者还在大规模数据集 ImageNet-800 上进行了进一步评估。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d9d1700a94f64f5f1eb93def61db8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/040ad3c525b69eb9069756825ecbbd08/" rel="bookmark">
			get_phy_device和phy_device_register
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/** * get_phy_device - reads the specified PHY device and returns its @phy_device *	struct * @bus: the target MII bus * @addr: PHY address on the MII bus * @is_c45: If true the PHY uses the 802.3 clause 45 protocol * * Description: Reads the ID registers of the PHY at @addr on the * @bus, then allocates and returns the phy_device to represent it. */ struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45) { struct phy_c45_device_ids c45_ids = {0}; u32 phy_id = 0; int r; // phy_id没有读成功 就不会分配phy_device相关内存资源 r = get_phy_id(bus, addr, &amp;phy_id, is_c45, &amp;c45_ids); if (r) return ERR_PTR(r); /* If the phy_id is mostly Fs, there is no device there */ if ((phy_id &amp; 0x1fffffff) == 0x1fffffff) return NULL; return phy_device_create(bus, addr, phy_id, is_c45, &amp;c45_ids); } EXPORT_SYMBOL(get_phy_device); /** * get_phy_id - reads the specified addr for its ID.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/040ad3c525b69eb9069756825ecbbd08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d8d8a240ac354ed09a0072b7132e0f/" rel="bookmark">
			Springboot整合Thymeleaf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot整合Thymeleaf 摘自https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html
一、thymeleaf简介 简介 简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点：
模板引擎（这里特指用于Web开发的模板引擎）是为了使[用户界面](https://baike.baidu.com/item/用户界面)与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的[HTML](https://baike.baidu.com/item/HTML)文档 · 1.Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。
· 2.Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、改jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。
· 3.Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。
为什么使用 Thymeleaf 如果希望以 Jar 形式发布模块则尽量不要使用 JSP 相关知识，这是因为 JSP 在内嵌的 Servlet 容器上运行有一些问题 (内嵌 Tomcat、 Jetty 不支持 Jar 形式运行 JSP，Undertow 不支持 JSP)。
Spring Boot 官方中推荐使用 Thymeleaf 作为模板引擎，因为 Thymeleaf 提供了完美的 Spring MVC 支持
Spring Boot 提供了大量模板引擎，包括：
FreeMarker
Groovy
Mustache
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5d8d8a240ac354ed09a0072b7132e0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbed6d513ff63c9cc19030f78e02aab6/" rel="bookmark">
			leecode 字符串解码 ——python 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。
示例 1：
输入：s = "3[a]2[bc]"
输出："aaabcbc"
示例 2：
输入：s = "3[a2[c]]"
输出："accaccacc"
示例 3：
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
示例 4：
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
--------------------------------------------------------转自leecode
使用python正则匹配n[abc]这种最内层的组合，然后在原来的字符串的展开替换，由中间向两边延伸，最终完成解析。个人感觉这种办法虽然取巧了，但是胜在简单。
import re def func(s=''): if s == '': return None # print('s:{}'.format(s)) ret = re.search(r'(\d+)\[([a-z]+)\]', s) if ret: # print(ret.groups()) num = int(ret.groups()[0]) chrs = ret.groups()[1] tmp_str = chrs * num # print('tmp_str:{}'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbed6d513ff63c9cc19030f78e02aab6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d6d42291df61d76c550cc4bc80f439d/" rel="bookmark">
			JAVA List对布尔值进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 记录一个对一个集合中的 某一个布尔值进行排序 true 在前 false 在后
// 排序 responses.sort((o1, o2) -&gt; { if (o1.getThisDefault() ^ o2.getThisDefault()) { return o1.getThisDefault() ? -1 : 1; } else { return 0; } }); return responses; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145e53475db4030138b05a2919e92ccd/" rel="bookmark">
			学习记录（3）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 焊接初体验一、焊接步骤二、注意事项三、关于六脚自锁开关 端口复用与重映射一、端口复用端口复用配置过程 二、端口重映射（Remap）端口重映射配置过程 本周洛谷题总结写在最后 焊接初体验 一、焊接步骤 准备焊锡丝和电烙铁以及相关电子元件，将海绵浸湿，用以擦除电烙铁刀头上多余的锡。
焊接引脚： 将电烙铁在350℃下预热，按照电路图将电子元件扣合到电路板上，左手拿焊丝，右手拿烙铁，将刀头靠近电子元件引脚部分，再将焊锡丝靠近刀头（焊锡丝从烙铁对面接触焊件），待焊锡丝融化时，将焊锡从根部往引脚上提，当焊锡在焊接面上扩散达到预计量时，拿开焊丝并移开烙铁，此时一个引脚便焊接完毕。若在焊接过程中不小心将两个引脚连在一起，可以用刀头在两个引脚之间快速划过，一般就可以将两个引脚分开。
最后再将电路连接起来即可。
二、注意事项 电烙铁不用时要将它放回到架子上，焊接过程结束之后一定要关闭开关，断开电源。焊接时要在明亮的环境中进行，使用电烙铁过程中一定要注意不要被烫到。在焊接过程中可以佩戴口罩，防止中毒。焊接前一定要明确电路图。 三、关于六脚自锁开关 在焊接过程中我使用的开关是六脚开关，即双刀双掷开关。
实物图如下：
连接电路时中间的引脚一般都选择接入VCC。一共两排引脚，一排3个，每边只有一个是有用的，这两个有用的构成开关，其余4个只是起固定作用，至于具体是哪个得用万用表确定。
端口复用与重映射 一、端口复用 STM32有很多内置外设，这些外设的外部引脚都是与GPIO复用的。一个GPIO如果可以复用为内置外设的功能引脚，那么当这个GPIO作为内置外设使用的时候，就叫做复用。
以串口1为例，串口1的发送接收引脚是PA9,PA10,当把PA9,PA10不用作GPIO，而用作复用功能串口1的发送接收引脚时，叫端口复用。
端口复用配置过程 串口模式配置如下表：
具体代码实现过程如下：
二、端口重映射（Remap） 每个内置外设都有若干个输入输出引脚，一般这些引脚的输出端口都是固定不变的，但通过引脚重映射可以使一个外设的引脚除了具有默认的端口外，还可以通过设置重映射寄存器的方式，把这个引脚映射到其他端口。
部分重映射：功能外设的部分引脚重新映射，还有一部分引脚是原来的默认引脚。
完全重映射：功能外设的所有引脚都重新映射。
端口重映射配置过程 //以串口3为例，其开启重映射时的入口参数 GPIO_PartialRemap_USART3 //部分重映射 GPIO_FullRemap_USART3 //全部重映射 对以下三个寄存器进行读写操作前需要使能AFIO辅助功能时钟：
AFIO_MAPR:配置复用功能重映射AFIO_EXTICRX:配置外部中断线映射AFIO_EVCR:配置EVENTOUT事件输出 本周洛谷题总结 一、快速排序
先找到整个数组的一个基准值，所有元素比基准小的放在基准前面，比基准大的放在基准后面，从而先将所有数字分成两部分，再对分成的两部分数字再按照第一次排序的方法进行排序。
二、选择排序
从头至尾扫描序列，找出最小的一个元素，和第一个元素交换，接着从剩下的元素中继续这种选择和交换方式，最终得到一个有序序列。
三、桶排序
对于桶排序，我们首先需要知道所有待排序元素的范围，然后需要有在这个范围内的同样数量的桶，接着把元素放到对应的桶中，最后按顺序输出。
写在最后 本人小白一枚，这些仅仅是我个人的经验和认知，也许含有多处错误，希望读者给我指正。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71ddbace8810a276e9c2566c874266ce/" rel="bookmark">
			elasticsearch学习七-ES面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 为什么要使用Elasticsearch? 系统中的数据，随着业务的发展，时间的推移，将会非常多，而业务中往往采用模糊查询进行数据的搜索，而模糊查询会导致查询引擎放弃索引，导致系统查询数据时都是全表扫描，在百万级别的数据库中，查询效率是非常低下的，而我们使用ES做一个全文索引，将经常查询的系统功能的某些字段，比如说电商系统的商品表中商品名，描述、价格还有id这些字段我们放入ES索引库里，可以提高查询速度。
2 Elasticsearch的master选举流程？ Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能。 3 Elasticsearch集群脑裂问题？ “脑裂”问题可能的成因:
网络问题：集群间的网络延迟导致一些节点访问不到master，认为master挂掉了从而选举出新的master，并对master上的分片和副本标红，分配新的主分片节点负载：主节点的角色既为master又为data，访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。内存回收：data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。 脑裂问题解决方案：
减少误判：discovery.zen.ping_timeout节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判。选举触发: discovery.zen.minimum_master_nodes:1 该参数是用于控制选举行为发生的最小集群主节点数量。当备选主节点的个数大于等于该参数的值， 且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为（n/2）+1，n为主节点个数 （即有资格成为主节点的节点个数）
角色分离：即master节点与data节点分离，限制角色 主节点配置为：node.master: true node.data: false
从节点配置为：node.master: false node.data: true
4 Elasticsearch索引文档的流程？ 协调节点默认使用文档ID参与计算（也支持通过routing），以便为路由提供合适的分片： shard = hash(document_id) % (num_of_primary_shards)
当分片所在的节点接收到来自协调节点的请求后，会将请求写入到Memory Buffer，然后定时（默认是每隔1秒）写入到Filesystem Cache，这个从Memory Buffer到Filesystem Cache的过程就叫做refresh；当然在某些情况下，存在Momery Buffer和Filesystem Cache的数据可能会丢失，ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到translog中，当Filesystem cache中的数据写入到磁盘中时，才会清除掉，这个过程叫做flush；在flush过程中，内存中的缓冲将被清除，内容被写入一个新段，段的fsync将创建一个新的提交点，并将内容刷新到磁盘，旧的translog将被删除并开始一个新的translog。flush触发的时机是定时触发（默认30分钟）或者translog变得太大（默认为512M）时； 5 Elasticsearch更新和删除文档的流程？ 删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，因此不能被删除或者改动以展示其变更；磁盘上的每个段都有一个相应的.del文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。 6 Elasticsearch搜索的流程？ 搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。PS：在搜索的时候是会查询Filesystem Cache的，但是有部分数据还在Memory Buffer，所以搜索是近实时的。每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch增加了一个预查询的处理，询问Term和Document frequency，这个评分更准确，但是性能会变差。 7 Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？ 64 GB 内存的机器是非常理想的， 但是32 GB 和16 GB 机器也是很常见的。少于8 GB 会适得其反。如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。通过设置gateway.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71ddbace8810a276e9c2566c874266ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3c1288b2d5c01f3459a51232e1fa0e7/" rel="bookmark">
			matlab求解两元一次方程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 syms x y
eq1=x+y -4;
eq2=x-y-8;
[x,y]=solve(eq1,eq2)
syms x y eq1=x+y -4; eq2=x-y-8; [x,y]=solve(eq1,eq2) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4151fd0259f9560a2167ddcde0d24c7e/" rel="bookmark">
			Java 算法竞赛（蓝桥杯）常用API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给大家整理了一下java算法中常用的一些api供大家参考，也祝愿大家能在比赛中取得一个好成绩
1.String类 public int length() 返回字符串的长度public char charAt(int index) 返回第index位置的char类型的字符public boolean equals(Object anObject) 用于比较两个字符串是否相同public int indexOf(String s) 返回s在在原字符串的位置，没有返回-1，举个例子 String s="asdppap"; System.out.println(s.indexOf("pa"));//返回4 System.out.println(s.indexOf("22"));//返回-1 public String trim() 返回一个字符串,任何前导和尾随空格删除public char[] toCharArray() 将字符串转换为一个新的字符数组public String[] split(String regex) .split("，"); 按，分割字符串（貌似正确用法是正则表达式） 2.Math类 static double abs(double a) 返回一个 double值的绝对值 有int，float的重写static double max(double a, double b) 返回两个 值中大的一个，min同理返回小值double pow(double base, double exponent) 返回第一个参数的第二个参数次方static double sqrt(double a) 开平方 3.BigInteger类 主要用于大数的运算
这里就不列方法了直接上程序比较直观
public static void main(String[] args) { BigInteger big1=BigInteger.ONE,big2=BigInteger.TWO; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4151fd0259f9560a2167ddcde0d24c7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a5c58d9c4096068817a4414ad0c1c9/" rel="bookmark">
			空格 &#43; %20 三者的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三者有何区别？ 都表示可以空格，区别在于使用场景不同
%20 用在 URL 的路径部分，如 xxx.com/%20abc/haha.htm，而如果写成 xxx.com/+abc/haha.htm，是不会正确识别的，直接空格更是不行（平时浏览器都替我们转换了），路径部分 %20 表示空格 package main import ( "github.com/gin-gonic/gin" ) // 测试代码，路径带空格 func main() { a := gin.Default() a.GET("/ asd", func(ctx *gin.Context) { ctx.JSON(200, gin.H{}) }) a.Run(":8000") } 可以看出，在路径部分不存在赤裸裸的空格，只有 %20 表示空格，’+’ 在这里就是 ‘+’
URL 中的查询部分 package main import ( "fmt" "github.com/gin-gonic/gin" ) // 测试代码，参数值带空格 func main() { a := gin.Default() a.GET("/", func(ctx *gin.Context) { q := ctx.Query("q") fmt.Println(q) ctx.JSON(200, gin.H{}) }) a.Run(":8000") } 可以看到，查询部分依旧不能出现赤裸裸的空格，只能是 ‘+’ 或 %20
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a5c58d9c4096068817a4414ad0c1c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb9c604dc893482687f9c85eca919304/" rel="bookmark">
			字符串类String8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仿Android 工具类String8写的 /************************************************************************* &gt; File Name: string8.h &gt; Author: hsz &gt; Mail: &gt; Created Time: 2021年04月11日 星期日 12时24分52秒 ************************************************************************/ #ifndef __STRING8_H__ #define __STRING8_H__ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;stdarg.h&gt; #include &lt;stdint.h&gt; #include &lt;ctype.h&gt; namespace Alias { #define MAXSIZE (1024 * 8) class String8 { public: String8(); String8(const String8&amp; other); String8(const char* other); String8(const char* other, const size_t numChars); String8(const std::string&amp; other); ~String8(); const char* c_str() const; std::string toStdString() const; // String8 -&gt; std::string bool isEmpty() const; size_t length() const; void clear(); int append(const String8&amp; other); int append(const char* other); int append(const char* other, size_t numChars); // this只能用于非静态成员函数，所以第一个参数就是fmt static String8 format(const char* fmt, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb9c604dc893482687f9c85eca919304/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b92b3773e7f11888f1367140a8bcc8d/" rel="bookmark">
			虚拟手机一款安卓模拟器，让你手机里拥有另外一台手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		『安卓软件』虚拟大师这是一款安卓模拟器，让你手机里拥有另外一台手机，不怕任何病毒，支持各种手游！
官网下载https://www.vmos.com
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c720fba078f4388a5b679a6f9a11f362/" rel="bookmark">
			IDEA配置NodeJS项目遇到问题及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA配置NodeJS项目遇到问题及解决 1. 配置安装NodeJS插件2. Error: No ESLint configuration found.3. TypeError: this.CliEngine is not a constructor4. No ESLint configuration found5. npm run build 时报 cp 不是内部命令错误6. run configuration配置运行 1. 配置安装NodeJS插件 安装 Idea — File — Settings — plugins — nodejs，安装后重启idea，run configuration配置；
可参考：添加链接描述
2. Error: No ESLint configuration found. Idea — File — Settings — plugins — eslint安装后重启IDEA；
3. TypeError: this.CliEngine is not a constructor 可参考： https://blog.csdn.net/qq_34817440/article/details/104278778
修改 .\IntelliJ IDEA 2017.2\plugins\JavaScriptLanguage\languageService\eslint\bin\eslint-plugin.js
4. No ESLint configuration found 主要是缺少.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c720fba078f4388a5b679a6f9a11f362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad56400cc610dd42febabddbd123262/" rel="bookmark">
			C语言字符转数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言字符减去‘0’多用于字符转成数字的操作，如下举例：
int main() { char str = '9'; int ret = str - '0'; printf("%d\n",ret); //或者更直白一点 printf("%d",'8' - '0'); } 以上输出为9 8
字符串中字符运算本质就是ASCII码值的预算，将字符串中字符减去’0’，就是转换成数字；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/862a18aba4ed4a56426557de80c3a3d4/" rel="bookmark">
			【CSS】内联格式化上下文 IFC（inline formatting context）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IFC（inline formatting context） 问题：font-size与font-family造成的字体高度问题字模（em-square）在字模中绘制字体一个字体的高度行盒（line-box）line-box高度计算的细节：对于内联元素对于行内块元素 例如： line-height属性line-height作为行内元素的高度line-height的取值normalnumberlengthpercentage（百分比） vertical-align属性基线位置vertical-align作用取值相对行的关键字值（随line-height变化）相对父元素的关键字值（不随line-height值变化） 问题：font-size与font-family造成的字体高度问题 使用相同的font-size，但使用不同的font-family，渲染出来的line-height是不同的
并且font-size:100px时元素的height也不是100px：
为什么会造成这种原因呢？是因为字体设计导致的！
字模（em-square） 字模em-square 又称为 em size，是字体设计中的概念，在一个字体中，每个字符都被放置在自己的空间容器中，即字模
字模的高度称为“ em”，它源自大写字母“ M”字符的宽度，因为字母的比例被做成了方形（因此有了“EM Square”的称呼）
在计算机字体中，em 是空间的数字化定义总量
在 OpenType 字体中，UPM 或 em 大小通常是 1000 单位在 TrueType 字体中，UPM 约定是 2 的幂，通常是 1024 或 2048 当时用字体来设置样式时，em 将会缩放到需要的值
这意味着对于 font-size:100的字体样式时，1000 单位在这个实例中将会缩小到 100px 在字模中绘制字体 知道了你的字体将会使用 1000，1024 或 2048UPM 后，你需要设定你的字形的绘制，以保证你字体样式的所有面都充分地填入 UPM 空间内
字体设计时有一些刻度和度量线，度量线的位置可以自定义：
基线：
顶线：
X线：
一个字体的高度 使用font-face选择一种字体后，这种字体定义其字模em-square(字模)，每个字符将会绘制出自己的正方形容器，这个正方形使用相对单位和生成一个1000单位（也可以是1024，2048或者其他）
设计字体时还可以设置一些度量线（ascender,descender,capital height,x-height等），有些值（顶线、基线）是超出em-square之外的值
比如em-square是1000，顶线(ascender)是1100和底线（descender）是540，这意味着该字体在1000个单位的em-square使用了1100 + 540个单位，也就是说font-size:100px的时候，其高度是164px，这个计算高度定义了字体元素内容高度（content-area）
在字体设计时Capital高度是640和x-height的值是485，定义了大写字母是68px高度（680个单位）和小写字母（x-hegiht）是49px高度（485个单位）
行盒（line-box） 当一个行盒（line-box）元素呈现在屏幕上，它根据它的宽度可以有很多线，每一行都是由一个或多个行内元素（inline box）（HTML标签元素(如span之类的inline属性标签)或匿名内联元素文本内容）组成
line-box的高度是基于它的子元素高度的，浏览器为每个行内元素计算的高度都是line-box（子元素的最高点到最低点），因此line-box的总高度足以包含所有子元素（默认情况下）。
line-box高度计算的细节： 对于内联元素 padding和border增加了其background区域，但不会增加内容区域高度（甚至是line-box高度）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/862a18aba4ed4a56426557de80c3a3d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e641cae88756e623ed64e4b16df4cda9/" rel="bookmark">
			npm install 常见的报错解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm install 常见的报错解决办法 当我们从官网下载好node.js之后，安装完成某一个模块时候，总是会报出以下类似警告或者错误。
如图，这里我是在安装express 框架，他报警告了。
npm WARN saveError ENOENT: no such file or directory, open 'C:\Users\Cr'xuan\Desktop\nodes\package.json' npm notice created a lockfile as package-lock.json. You should commit this file. npm WARN enoent ENOENT: no such file or directory, open 'C:\Users\Cr'xuan\Desktop\nodes\package.json' npm WARN nodes No description npm WARN nodes No repository field. npm WARN nodes No README data npm WARN nodes No license field. 当然，这里并不是意味着我们安装的模块就出错了，这些警告是提醒我们完善一些操作，增加代码的稳定性。
先来说说前面两个错误：
npm WARN saveError ENOENT: no such file or directory, open 'C:\Users\Cr'xuan\Desktop\nodes\package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e641cae88756e623ed64e4b16df4cda9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9203146b91b333d9e5416193d0c12788/" rel="bookmark">
			linux同时连接有线无线上网问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因： linux同时连接有线和无线网时，希望用有线连内网组网，如OAI EPC组网，用无线访问外网，但是默认会优先用有线。
解决： 所以设置限制，只允许目标地址为有线连接所在网段的数据包从有线走。
图形化界面操作： system settings-&gt;network-&gt;wired-&gt;options-&gt;IPV4settings-&gt;Routes
勾选 use this connection only for resources on its network
此时，有线局域网就不影响在机器上访问外网了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fae17f0a1b953bd57350af62fac5d0e7/" rel="bookmark">
			拦截器（interceptor）和过滤器（filter）的认识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssm框架的的登录拦截问题 刚开始就是直接用springsecurity，虽然能成功的拦截请求然后跳到登录页，但不明白是什么原理，然后就有点懵，然后就想先看一下拦截器，因为原理也是基于拦截和过滤的这个思想做的。想到拦截器就又想到过滤器，这两个到底是什么东西。
原理介绍 interceptor是基于Java反射机制，它依赖于mvc容器，只能对controller的请求起作用，它能获取到请求路径的context，而且能被多次调用，只要请求了被配置为拦截的路径就会有拦截，而且它能获取到IOC容器中的各个bean，但过滤器就不行。filter是基于函数回调，依赖于servlet容器，它只在初始化时被调用一次，它是在请求进入容器之后，但还未进入servlet之前进行预处理，并且在请求结束返回给前端这之间进行后期处理。
Filter主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比较泛的，比如登录不登录之类）。如果是大神那肯定有更好的使用方法。
拦截器（interceptor） 经过使用后的感觉，interceptor就是一个AOP的实现，它就是对请求的controller中的方法的增强。
使用 自定义interceptor类，实现HandlerInterceptor接口，重写它的方法
package com.example.interceptor; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; /** * @className LoginInterceptor * @date 2021/4/14 9:12 * @description 登录认证拦截器 **/ public class LoginInterceptor implements HandlerInterceptor { @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println("LoginInterceptor.afterCompletion"); } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fae17f0a1b953bd57350af62fac5d0e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4272dc292fb165d1b79f2922bd74c16/" rel="bookmark">
			消息队列kafka部分原理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为什么要有消息系统。
1、解耦合。
一个事件需要不同的系统提供服务，不同的服务处理的能力不同。（可可豆制作成巧克力的例子）
2、异步控制。
秒杀活动中，可以将风险控制、库存锁定与减库存、生成订单异步处理。
3、流量控制
网关接收请求、请求放在队列中，后端从队列中依次处理请求。
二、kafka消息队列
broker是kafka的实例。
producer是生产者。
consumer为消息消费者。
topic：消息的主题，就如关系型数据库中的表。
partition：topic的分区，一个topic可以有多个分区，且分散在不同的服务器上，主要作用是用来提高负载和扩展，一个分区就相当于一个文件夹。
replication：副本，当leader故障则会选择一个follwer作为leader，
消费者组：指定group-id相同则为同一个组，同一个个组的消费者不能消费同一个分区，若要重复消费数据，则可以指定为不同的消费者组。
zookeeper：kafka集群注册在zookeeper上，用来保存监听集群节点，保证可用性。
2、工作流程
kafka发送数据的时候永远是找leader，将数据写入leader，然后follower会主动去leader中同步数据。
怎么保证消息不丢失呢？
那就是通过ACK应答机制！在生产者向队列写入数据的时候可以设置参数来确定是否确认kafka接收到数据，这个参数可设置的值为0、1、all。
kafka集群分为主从节点，节点通过在zookeeper中注册成为Controller，其他的Kafka broker叫Kafka Broker follower。
二、kafka高性能
1、顺序写的问题
简单来说就是将批量此的数据统一存储到磁盘。
2、零拷贝
数据要从硬盘或者网络中读取，需要从硬盘拷贝到OS缓存，再从OS缓存拷贝到应用缓存再次发送到socket缓存。
零拷贝是CPU直接操作读取数据发送到网络socket缓存中，减少拷贝占用的io资源和上下文切换。
PS：linux中的零拷贝技术
https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy1/index.html
三、kafka分段存储
1、每个topic都可以分为一个或多个partition，kafka是逻辑上的，那partition就是比较具体的东西了！Partition在服务器上的表现形式就是一个一个的文件夹，每个partition的文件夹下面会有多组segment文件，每组segment文件又包含.index文件、.log文件、.timeindex文件三个文件， log文件就实际是存储message的地方，而index和timeindex文件为索引文件，用于检索消息。
2、稀松索引
当kafka每写入4kb的数据的话会记录以下offset。
读取的时候通过二分查找找到离目标索引最近的前一个位置，然后顺序查找到目标数据。
kafka高可用之冗余设计
1、创建主题的时候会创建分区个数和多个副本。分区分为leader和follower之分。
当读写数据的时候会操作leader，写数据的时候会写进leader，然后follower会去leader同步数据。
2、ISR leader partition会维护一个ISR列表，作为备用列表。 PS：会根据一定的规则清楚差异化较大的brokerid号。
Kafka的架构思想总结：
1、高可用：多副本。
2、高并发：优秀的网络架构。
3、高性能：写数据：顺序写-》写OS-cache-》写磁盘。 读数据：a。根据稀松索引 b.零拷贝：减少了应用程序与OS的上下文切换。
集群的评估方式
1、容量评估、
举例一个10亿请求的需求。
0：00 --08：00 只占20%,其他16个小时有80%的请求：8亿请求。
1620%=3 小时。就是3个小时处理了80%的数据量6.4亿。
6.4亿除以3小时=5.5万/s。qps=5万
如果灭个请求的大小为50kb。
10亿请求50kb = 46T * 2个副本 = 92T * 保留三天数据 276T
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4272dc292fb165d1b79f2922bd74c16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55c341999a7d298c6999614797286238/" rel="bookmark">
			cocosCreator---listview
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享总结与感受，欢迎大家交流学习
listView实用性很强，游戏中排行榜，领取奖励列表等等，都能用的上。除了游戏之外其他的app、web都会用的上，下面会讲用cocosCreator实现的，其实用其他的语言、引擎、ui库也都是一样的道理，重在思想。
在设计的时候，1.要考虑一次加载过多卡顿的问题 2.滑动流畅问题
解决方式：1.创建出有限个item 2.通过滑动后在判断将有限个item放在滑动方向的反方向（向上滑，会将最上面的item位置放在最下面）3.其中有一个缓存区空间的概念，在content外，交换位置都在缓存区中变化，没有缓存区域看着就会不流畅
下面的例子主要在cocoscreator中实现
实现功能：
1.实际生成20个item，显示30个数据或者更多
2.添加新item
3.删除item，但总数据不会小于30个
4.将listview滑动到指定的y=500的位置上
上，码 listviewCtl.js cc.Class({ extends: cc.Component, properties: { itemTemplate: { // item template to instantiate other items default: null, type: cc.Node }, scrollView: { default: null, type: cc.ScrollView }, spawnCount: 0, // how many items we actually spawn 实际生成item totalCount: 0, // how many items we need for the whole list 显示信息总数 spacing: 0, // space between each item 每个item之间间隔 bufferZone: 0, // when item is away from bufferZone, we relocate it 缓冲区 lblScrollEvent: cc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55c341999a7d298c6999614797286238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f1e46fa5534d1b78452815d88bd4b88/" rel="bookmark">
			Unknown host ‘dl.google.com‘ You may need to adjust the proxy settings in Gradle的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分析： 这个Error的出现是因为你的当前代理不可用了造成的，也就你需要替换可用的代理。
二、发生场景： 一般公司的代理发生变化时会出现这种情况。
当你的本地gradle 缓存的有某些依赖库时你打包\或者编译运行apk时可能不会出问题，只是警告下。当本地无缓存的依赖库，你打包\或者编译运行apk时变会出问题了，xxx依赖下载失败之类的。同时还报Unknown host ‘dl.google.com’ You may need to adjust the proxy settings in Gradle 三、如何解决： 首先你需要找个可用的代理按照如下1种方案替换即可。（注意同时配置时2会覆盖1）
1、File &gt; Settings &gt; Appearance &amp; Behavior &gt; System Settings &gt; HTTP Proxy 替换可用的代理。
2、gradle.properties 配置文件中设置可用代理。
systemProp.https.proxyPort=端口 systemProp.http.proxyHost=可用代理 systemProp.https.proxyHost=可用代理 systemProp.http.proxyPort=端口 四、最后 配置完成后sync下gradle，然后编译即可！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b2e0501c80067278dfa81e7dd82a0e/" rel="bookmark">
			如何提高代码的扩展性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何提高代码的扩展性 如何提高代码的扩展性
一、架构的高可用？（不是本文的重点）
二、软件项目的变化（为什么要提高代码的可扩展性（背景））
软件设计的唯一产出物—代码
面向对象的目的是模块化
三、什么是高内聚、低耦合
1、搞清楚模块是什么
例如：如果模块A直接操作了模块B的数据，这种操作模块与模块之间就为强耦合，甚至可以认为这种情况之下基本算没有分模块！如果A只是通过数据与B模块交互，这种我们称之为弱耦合！微服务独立的模块，方便去维护，或者写单元测试等等…如果木块之间的依赖非常严重，将会非常不易于维护。
四、软件设计的目的
1、如何评价代码的质量
2、如何实现代码的高质量？⭐
（2）、开闭原则
（4）、依赖倒置原则
（5）、接口隔离原则
一、架构的高可用？（不是本文的重点）
（1）、【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。
（2）、【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。
（3）、【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。
（4）、【服务层】到【缓存层】的高可用，是通过缓存数据的冗余来实现的。
缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service对cache进行双读或者双写。缓存层也可以通过支持主从同步的缓存集群来解决缓存层的高可用问题。当redis主挂了的时候，sentinel能够探测到，会通知调用方访问新的redis，整个过程由sentinel和redis集群配合完成，对调用方是透明的。
（5）、【服务层】到【数据库读】的高可用，是通过读库的冗余来实现的。
既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。当读库挂了的时候，db-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。
（6）、【服务层】到【数据库写】的高可用，是通过写库的冗余来实现的。
以mysql为例，可以设置两个mysql双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。自动故障转移：当写库挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-db-master，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。
X轴和Z轴已经趋于成熟。以后的发展方向必定是业务功能的发展，代码的高可用。
二、软件项目的变化（为什么要提高代码的可扩展性（背景））
软件设计的唯一产出物—代码
面向对象的目的是模块化
三、什么是高内聚、低耦合
1、搞清楚模块是什么
模块就是从系统层次去分成不同的部分，每个部分就是一个模块！ 分而治之， 将大型系统的复杂问题，分成不同的小模块，去处理问题！
耦合：主要是讲模块与模块之间的联系
例如：如果模块A直接操作了模块B的数据，这种操作模块与模块之间就为强耦合，甚至可以认为这种情况之下基本算没有分模块！如果A只是通过数据与B模块交互，这种我们称之为弱耦合！微服务独立的模块，方便去维护，或者写单元测试等等…如果木块之间的依赖非常严重，将会非常不易于维护。
内聚：主要指的是模块内部【东西聚合在一起形成了一个模块】例如方法，变量，对象，或者是功能模块。
模块内部的代码， 相互之间的联系越强，内聚就越高， 模块的独立性就越好。 一个模块应该尽量的独立，去完成独立的功能！如果有代码非得引入到独立的模块，建议拆分成多模块！低内聚的代码，不好维护，代码也不够健壮
四、软件设计的目的
1、如何评价代码的质量
最重要的是：灵活性；可扩展性；可维护性；可读性；
2、如何实现代码的高质量？⭐★
遵循SOLID设计原则：（接口设计原则）参考依据高内聚、低耦合
单一职责原则：一个类值负责一个功能的职责
开闭原则：扩展开放，修改关闭。
里氏代换原则：使用父类的地方都能使用子类对象
依赖倒转原则：针对接口编程，
接口隔离原则：针对不同部分用专门接口，不用总接口，需要哪些接口就用哪些接口
（1）、你认为下图的设计违反了哪一种设计原则？
（1）、违反了单一职责原则（SRP）
画图和计算面积并不是单一职责，计算几何学应用程序只计算面积不画图，但是还要引入GUI。
应该有且仅有一个原因引起类的变更。简单点说，一个类，最好只负责一件事，只有一个引起它变化的原因。 也就是说引起类变化的原因只有一个。高内聚、低耦合是软件设计追求的目标，而单一职责原则可以看做是高内聚、低耦合的引申，将职责定义为引起变化的原因，以提高内聚性，以此来减少引起变化的原因。职责过多，可能引起变化的原因就越多，这将是导致职责依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。单一职责通常意味着单一的功能，因此不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。
（2）、开闭原则
对扩展开放。模块对扩展开放，就意味着需求变化时，可以对模块扩展，使其具有满足那些改变的新行为。换句话说，模块通过扩展的方式去应对需求的变化。
对修改关闭。模块对修改关闭，表示当需求变化时，关闭对模块源代码的修改，当然这里的“关闭”应该是尽可能不修改的意思，也就是说，应该尽量在不修改源代码的基础上面扩展组件。
一个开闭原则的简单实例（懂则不用看）
对拓展开放，对修改关闭：比如当某个业务增加，不是在原类增加方法，而是增加原类的实现类。 下面的例子是一个非常典型的开闭原则及其实现。非常简单，但却能够很好的说明开闭原则。
假设有一个应用程序，能够计算任意形状面积。这是几年前我在明尼苏达州农作物保险公司遇到的一个非常简单问题。app程序必须能够计算出指定区域的农作物总的保险报价。正如你所知道的，农作物有各种形状和大小，有可能是圆的，有可能是三角形的也可能是其他各种多边形。
OK，让我们回到我们之前的例子中…
作为一名优秀的程序员，我们将这个面积计算类命名为 AreaManager。这个 AreaManager是单一职责的类：计算形状的总面积 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8b2e0501c80067278dfa81e7dd82a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903c6143532e62c9e69bf9be94075322/" rel="bookmark">
			【数学建模】——线性规划模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意matlab中求的是“最大值”、“小于等于”， 如果我们求最大值或者约束条件中为”大于等于“， 只需要在前加负号
上述有错，f为价值向量
注意对照线性规划模型的标准式：“最小、“小于等于”
zeros(3,1)：linprog()函数中的变量包含下界向量和上界向量，在这里只有下界向量（大于0）
zeros()函数： zeros(n)： 生成一个nn的零矩阵，如果n不是标量，则会报错 zeros(m,n)和zeros(m,n)：均是一个mn的矩阵 zeros(d1,d2,d3…)和zeros([d1 d2 d3…])：均是生成一个d1d2d3*……的零数组或矩阵 zeros(size(A)) ：生成一个和矩阵A大小相同的零矩阵 zeros(m, n,…,classname)和zeros([m,n,…],classname)：生成一个类型为classname的m*n大小的零数组或矩阵，其中classname的取值有：double’, ‘single’, ‘int8’, ‘uint8’, ‘int16’, ‘uint16’, ‘int32’, or ‘uint32’ ———————————————— 版权声明：本文为CSDN博主「一千种风的味道」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/denglavender/article/details/102636724 如果没有相应的约束（可能没有等式约束，可能没有不等式约束），则用 []（方括号）来占位
例：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/482a492a4106bb3a9f35b2f5b0dfe1b9/" rel="bookmark">
			MSP430第三十六章：通用异步收发通信模块 – UART Mode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 通用串行通信接口——USCI总览 USCI模块支持多种串行通信方式，不同的USCI模块支持不同的模式，每个不同的USCI模块都用不同的字母命名。例如，USCI_A和USCI_B是不同的。如果在一个设备上配备了多个相同的USCI模块，那么这些模块的名称将以递增的数字命名。例如，如果一个设备有两个USCI_A模块，它们被命名为USCI_A0和USCI_A1。
USCI_Ax模块支持:
UART模式用于IrDA通信的脉冲整形用于LIN通信的波特率自动检测SPI模式 USCI_Bx模块支持:
I2C模式SPI模式 2. UART模式 在异步模式下，USCI_Ax模块通过两个外部引脚UCAxRXD和UCAxTXD连接外部系统。置零UCSYNC位时选择UART模式。
UART模式的特点包括:
奇数、偶数或没有校验的7位或8位数据独立的发射和接收移位寄存器独立的发送和接收缓冲区寄存器低位在前或者高位在前的数据传输格式用于多处理器系统的内置空闲线路和地址位通信协议从LPMx模式自动唤醒的接收机开始边缘检测(不支持从LPMx.5模式唤醒)带小数的可编程波特率错误检测和抑制的状态标志地址检测的状态标志接收和发送的独立中断能力 3. UART操作 在UART模式下，USCI以异步的比特率传送和接收字符。每个字符的时序是基于所选的USCI波特率，发送和接收使用相同的波特率频率。
3.1 USCI初始化和重置
USCI由PUC或通过置一UCSWRST位复位。在PUC之后，UCSWRST位被自动置一，使USCI处于复位状态。当UCSWRT置一时，UCRXIE，UCTXIE、UCRXIFG、UCRXERR、UCBRK、UCPE、UCOE、UCFE、UCSTOE、UCBTOE位将复位，UCTXIFG位将置一。置零UCSWRST将释放USCI进行操作。为了避免不可预知的动作，只有置一了UCSWRST后才能配置或重新配置USCI_A模块。
推荐的初始化或重新配置USCI模块流程：
置一UCSWRST位用UCSWRST = 1初始化的所有USCI寄存器(包括UCAxCTL1)配置端口通过软件清除UCSWRST通过UCRXIE或UCTXIE启用中断(可选) 3.2 帧格式
UART帧格式由一个起始位、7或8个数据位、一个奇/偶/无奇偶校验位、一个地址位(地址位模式)和一个或两个停止位组成。UCMSB位控制传输的方向，并选择LSB或MSB。
3.3 异步通信格式
当两个设备异步通信时，协议不需要多处理器格式。当三个或更多的设备通信时，USCI支持空闲线和地址位多处理器通信格式。
3.3.1 空线多处理器的格式
当UCMODEx = 01时，空闲行多处理器格式被选择。在传输线上数据块被空闲时间分开，当在一个字符的停止位之后接收到10个或更多连续的1(标记)时，检测到传输线上空闲。接收到空闲线路后，波特率发生器关闭，直到检测到下一个开始边缘，UCIDLE位也会 置一。在空闲时间之后收到的第一个字符是地址字符，UCIDLE位被用作每个字符块的地址标签。在空闲行多处理器格式中，当接收到的字符是一个地址时，该位被置一。
UCDORM位用于控制空闲线多处理器格数据的接收，当UCDORM = 1，所有的非地址字符都被组装，但是不被传送到UCAxRXBUF中，并且不会产生中断。当接收到一个地址帧时，该字符被传送到UCAxRXBUF, UCRXIFG被置一，当UCRXEIE = 1时任何错误标志置一。当UCRXEIE= 0并且一个地址帧被接收，但是有帧错误或奇偶校验错误，字符不会被转移到UCAxRXBUF，UCRXIFG也不会置一。
如果接收到一个地址，用户软件可以验证该地址，并且必须置一UCDORM以继续接收数据。如果UCDORM仍然置一，则只接收地址字符。当UCDORM在接收字符期间被清除时，接收中断标志在接收完成后被置一。UCDORM位不会被USCI硬件自动修改。
对于空闲线多处理器格式的地址传输，一个精确的空闲时间可以由在UCAxTXD上生成地址字符标识符。双缓冲UCTXADDR标志指示加载到UCAxTXBUF的下一个字符之前是否有11位的空闲行。UCTXADDR在开始位生成时自动清除。
发送空闲帧
3.4 波特率自动检测
当UCMODEx = 11时，选择自动波特率检测的UART模式。为了自动检测波特率，数据帧之前有一个由中断和同步字段组成的同步序列。当接收到11个或更多连续的零时检测到中断。如果中断的长度超过21位，则中断超时错误标志UCBTOE位置一。USCI在接收到break/sync字段时不能发送数据。
为了符合LIN协议，字符格式应该设置为8个数据位，低位在前，没有奇偶校验，一个停止位，没有地址位。
同步字段由字节字段内的数据055h组成。同步基于模第一个下降边缘和最后一个下降边缘之间的时间测量。如果通过置一UCABDEN使能波特率自动检测功能，则使用发送波特率发生器进行测量。否则，波形将接收但不进行测量。测量结果被传输到波特率控制寄存器(UCAxBR0、UCAxBR1和UCAxMCTL)。如果同步字段的长度超过了可测量的时间，则置一同步超时错误标志位UCSTOE。
UCDORM位用于控制该模式下的数据接收。当UCDORM被置一后，所有的字符都被接收但是不会被转移到UCAxRXBUF，并且产生中断。当一个中断/同步字段被检测到，UCBRK标志被置一。中断/同步字段后面的字符被转移到UCAxRXBUF和UCRXIFG中断标志被设置。还设置了任何适用的错误标记。如果UCBRKIE位被置一，接收中断/同步设置UCRXIFG。UCBRK位由用户软件或读取接收缓冲区UCAxRXBUF复位。
当接收到中断/同步字段时，用户软件必须重置UCDORM以继续接收数据。如果UCDORM保持置一，只有接收到下一个break/synch字段后的字符才被接收。UCDORM位不会被USCI硬件自动修改。
当UCDORM = 0时，所有接收到的字符都置一接收中断标志UCRXIFG。如果UCDORM在接收字符期间被清除，接收中断标志将在接收完成后置一。用于检测波特率的计数器限制为07FFFh(32767)计数。这意味着采样模式下可检测的最小波特率为488波特，低频模式下为30波特。波特率自动检测模式适用于全双工通信系统，但有一定的限制。USCI在接收break/sync字段时不能传输数据，如果接收到帧错误的0h字节，在此期间传输的任何数据都会被损坏。后一种情况可以通过检查接收到的数据和UCFE位来发现。
3.4.1发送Break/ sync字段
设置UCTXBRK为UMODEx = 11写入055h到UCAxTXBUF。UCAxTXBUF必须准备好接收新数据(UCTXIFG = 1)
这会生成一个13位的中断字段，后面跟着一个中断分隔符和同步字符。分隔符的长度由UCDELIMx位控制。当同步字符从UCAxTXBUF转移到移位寄存器时，UCTXBRK自动复位将需要的数据字符写入UCAxTXBUF。UCAxTXBUF必须准备好接收新数据(UCTXIFG = 1)
写入UCAxTXBUF的数据被转移到移位寄存器并在移位后立即传输 3.5 IrDA编码和解码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/482a492a4106bb3a9f35b2f5b0dfe1b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d37b25147419bc8dcfb51bd90f99f66d/" rel="bookmark">
			Altium Designer绘制PCB板子的基本步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Altium Designer绘制PCB板子的基本步骤 前言一、 建立元器件库二、 建立工程，建立原理图，建立PCB三、 画原理图四、 画pcb图五、其他有关知识讲解六、其他学习资料连接 前言 最近因为一些需求，需要使用AD绘制一个PCB板，因此学习了AD的使用，为了方便自己日后再次使用的时候能够快速回忆起来，将一些基本步骤做一下记录，也希望能对大家有所帮助。
一、 建立元器件库 一般把别人拿来用就好，但我觉得一些基本流程还是需要的，有些时候自己要用的元器件可能与别人的不一样，步骤如下：
新建集成库、新建原理图库、新建pcb库，新建页面如图所示：
建立好之后，打开原理图库，绘制原理图库，并保存，绘制步骤如下：
1）菜单栏—放置（place）—直线、矩形等
2）放置管脚，注意有※的一边指向外侧
注意，绘制的时候，需要根据自己要用的元器件参数进行绘制
4. 打开pcb库，建立pcb图，并保存
1）在Top layer（顶层），画焊盘，place pad
2）焊盘参数设置，焊盘大小，是否挖洞，引脚
3）在Top Overlay（丝印层）画边框
在SCH library选择该元器件，添加footprint；
这样一个元器件就制作好了，如果需要再添加元器件，打开SCH library窗口，在这里可以添加一个元器件，画该元器件的原理图；打开PCB library窗口，在这里可以添加一个元器件，画PCB图
二、 建立工程，建立原理图，建立PCB 建立好原理图、PCB之后可能不在项目里，拉进去就好
三、 画原理图 打开xxx.pcbdoc原理图文件，是这样的
步骤：
打开视图-面板-components，添加元器件库，然后从导入的库里，找元器件放入原理图，和Proteus一样的，添加的时候按tab键，可以修改当前的器件名称（当有多个相同的器件时一定要改名字！）
画完之后编译一下，看看有没有错误，防止将错误带入pcb，方法工程—编译（21好像是validate），双击error看看错误具体在哪，若无弹窗，则编译无问题
电路设计完成，点击菜单栏的设计，选择“Update PCB Document PCB1.PcbDoc”，在弹窗中点击执行变更，生成一个个的元器件在pcb里边
注意事项以及小tips
（1）空格，选中器件方向，右键移动，左键选中，ctrl加滑轮放大缩小
（2）添加多个元器件或者网络标号时，按一下tab键，先改名字，后边添加的器件会自动根据名字标号
四、 画pcb图 1.将原理图导入到PCB之后就可以布线了，将元器件一个个摆放好位置，手动布线。
导入后的样子：
步线原则：线不走直角，标签不压线；VCC加粗，GND不连，通过铺铜实现。
在哪层进行布线：常见的有两层，底层（bottom layer）和顶层（top layer），两层都可以，不接触
2.布完线之后，就可以根据使用区域规划板子大小了，或者根据要求提前规划板子也行。
规划板子大小步骤：
（1）在PCB页面在Keep-Out Layer层，用直线画出所需板子的大小形状，注意必须是封闭的形状。（也可以place—keep out—track画一个框）
（2）选中画出的这些封闭的框框。（一次不能全部选中的话可以按住Shift依次选中线条）
（3）Design — Board Shape — Define from selected objects，这样就画好了任意复杂形状的PCB。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d37b25147419bc8dcfb51bd90f99f66d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8428a45869e78fb361ed20b9c23b0a8/" rel="bookmark">
			SpringBoot
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 一、Spring的发展历史 Spring1.x时代
在Spring1.x时代，都是通过xml文件配置bean，随着项目的不断扩大，需要将xml配置分放到不同的配置文件中，需要频繁的在java类和xml配置文件中切换。
Spring2.x时代
随着JDK 1.5带来的注解支持，Spring2.x可以使用注解对Bean进行声明和注入，大大的减少了xml配置文件，同时也大大简化了项目的开发。
那么，问题来了，究竟是应该使用xml还是注解呢？
最佳实践：
1、 应用的基本配置用xml，比如：数据源、资源文件等；
2、 业务开发用注解，比如：Service中注入bean等；
Spring3.x到Spring4.x到Spring5.x
从Spring3.x开始提供了Java配置方式，使用Java配置方式可以更好的理解你配置的Bean，现在我们就处于这个时代，并且Spring4.x和Springboot都推荐使用java配置的方式
二、Spring的Java配置方式 Java配置是Spring4.x推荐的配置方式，可以完全替代xml配置。
@Configuration和@Bean
Spring的Java配置方式是通过@Configuration 和 @Bean这两个注解实现的：
1、@Configuration作用于类上，相当于一个xml配置文件；
2、@Bean作用于方法上，相当于xml配置中的；
示例： 该示例演示了通过Java配置的方式进行配置Spring，并且实现了SpringIOC功能。
1、Maven创建工程 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-qNVkjBx7-1618485464708)(http://m.qpic.cn/psb?/V13x1ZYF1dFQtq/2ELojbveoLokAAua.WgxfVU2tw2AdDvuatVLFWa1Pdc!/b/dFMBAAAAAAAA&amp;bo=ywEZAgAAAAARB.E!&amp;rf=viewer_4)]
2、导入pom.xml &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;!-- 自定义版本号 --&gt; &lt;spring.version&gt;4.3.8.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring jar --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8428a45869e78fb361ed20b9c23b0a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fe50a6a91834dbea330ab9aba8ffea9/" rel="bookmark">
			有虫0.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		while语句中的break和continue
遇到continue 结束这次循环，判断循环条件，进入下一次循环。
遇到break，结束循环。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int num = 1; while (num &lt;= 5) { printf("正在吃第%d颗糖\n",num); num++; } return 0; system("pause"); } #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int num = 1; while (num &lt;= 5) { if (num == 3) { printf("有虫！\n"); continue; } printf("正在吃第%d颗糖\n",num); num++; } return 0; system("pause"); } #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int main() { int num = 1; while (num &lt;= 5) { if (num == 3) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fe50a6a91834dbea330ab9aba8ffea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/567e2990a818f036cd509dce673e4d43/" rel="bookmark">
			Adapter-Bot开源了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《The Adapter-Bot: All-In-One Controllable Conversational Model》
作者：香港科技大学
时间：2020年8月
地址：https://github.com/HLTCHKUST/adapterbot
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7789ce44b1c4ccb1b4fd255fe0bbe71d/" rel="bookmark">
			4.RuntimeError(“{} is a zip archive (did you mean to use torch.jit.load()?)“.format(f.name))
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在pytorch-gpu10.0 即cuda10.0的pytorch虚拟环境中（torch1.2.0）运行VoronoiNet代码时候，会出现上面的错误，一开始我以为是因为学姐的代码对pytorch版本有要求，但是问了学姐那里的torch版本就是1.2.0的，就很奇怪为什么我这里明明是相同的环境怎么就不行，有bug。
在网上查找原因，发现基本都是说torch版本的问题 →👉
使用torch.load()加载模型参数时，提示“xxx.pt is a zip archive(did you mean to use torch.jit.load()?)“
RuntimeError("{} is a zip archive (did you mean to use torch.jit.load()?)".format(f.name)) when loading model weights
解决问题 但是因为我要用的cuda10.0不支持torch1.6.0，就一直没改，后来突然想起来报错里面说的是torch.load旧版本不能用zip之类的， torch.load报错指向的不就是加载MNIST数据集嘛，所以突然想起来我这里项目运行位置已经有mnist数据集了，是之前使用别的torch虚拟环境时候下的**（torch版本比较高），所以在这里运行代码时候不会再重新下了，会去加载已经存在的数据集，所以可能是因为加载了这个旧的所以与现在环境的torch版本不匹配，因此就把mnist数据集删掉**，让代码中download=true重新下载，问题解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab737c0dc46158fffb08c7afb4851a8/" rel="bookmark">
			MiniCA 软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MiniCA，信息安全实验课要用的软件，找了好久，终于找到了，上传到git上，方便有需要的人，非作者。
GitHub: https://github.com/LoseSynchronization/MiniCA
Gitee: https://gitee.com/lose_synchronization/MiniCA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05f41662d7441dfdd5cfcc77af83b112/" rel="bookmark">
			5.gpu版本Pytorch执行.cuda()代码会卡死
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载好了gpu版本的pytorch后测试 发现torch.cuda.is_available() = True了，但是.cuda()命令运行时候一直卡死，没有反应：
使用pycharm远程连接也是这样，一直卡死在model.cuda()语句不动：
怀疑了好久是不是版本有问题，尝试了各种pytorch-conda-python版本都没有用，而且我下载的就是官网推荐的版本，所以应该是没问题的。后来甚至还怀疑是不是pycharm的问题，但是上面也试了脱离pycharm直接在python虚拟环境里面的python解释器直接运行.cuda()也不行，所以也不是pycharm的问题。
附各种版本尝试，呜呜呜
就一直觉得问题很奇怪，最后还是请教同学跑了一下他那里的代码想看看到底怎么使用GPU的，发现他那里也不能用了，结果是因为服务器有问题了，重启了一下服务器就万事大吉了！不得不感叹重启大法确实好，我一直在找自己这里的问题，卡了很多天，反正算是一次宝贵的经验吧。
附 容器里 pytorch model.cuda()卡死（虽然不是我这里的问题的解决方法，但是可能给其他人一些提示，也一并放这里了）
python - Pytorch .to(‘cuda’)或.cuda()不起作用，只会卡住（同上）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980301a5b7d17577e1843cc0dc31b1a4/" rel="bookmark">
			【C&#43;&#43;】将十进制数转化为二进制，并将每个bit位输出 —— 10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：将十进制数转化为二进制，并将32个bit位的每个bit位输出
代码：直接上代码：
#include &lt;iostream&gt; using namespace std; int main() {	long long int i = 3211264; int j = 0, a[1000], bit[32]; while (i) { a[j] = i % 2; i /= 2; j++; } for (i = j - 1; i &gt;= 0; i--) { cout &lt;&lt; a[i]; bit[i] = a[i]; } cout &lt;&lt; endl; if (j - 1 &lt; 31) { for (int m = j; m &lt; 32; m++) { bit[m] = 0; } } for (int i = 0; i &lt; 32; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/980301a5b7d17577e1843cc0dc31b1a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd34063cbddebf1e0920ea40ccfa6efe/" rel="bookmark">
			1.查看cuda版本-nvcc -V、cat /usr/local/cuda/version.txt、nvdia-smi 三种方式得到的都不一样
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 1.nvcc -V 查cuda为9.1 nvcc -V 2.cat /usr/local/cuda/version.txt 查cuda为8.0 cat /usr/local/cuda/version.txt 3.nvdia-smi 查cuda为11.2 nvidia-smi 解释 CUDA有 Runtime 运行API和 Driver 驱动API，两者都有对应的CUDA版本：
nvcc --version 显示的就是前者对应的CUDA版本，而 nvidia-smi显示的是后者对应的CUDA版本。
一般运行API版本&lt;=驱动API版本即可。
软件运行时调用的应该是Runtime Version。
1.nvcc -V命令会按照PATH顺序，显示的不是cuda软链接里面的，发现原因：是因为/usr/bin（①处）在PATH中相较/usr/local/cuda（②处）靠前，因此优先级高，所以nvcc –V命令会按照PATH顺序，先去①里面找，应该是在这文件夹里的nvcc中找到了9.1版本的cuda，所以就不去别的地方找了，就没有找到②处我们想要的cuda版本。
解决nvcc -V显示的不是cuda软链接里面的cuda版本这一问题：
2.cat /usr/local/cuda/version.txt 显示的就是cuda软链接里面的cuda版本
3.nvidia-smi driver 驱动API对应的CUDA版本
参考帖 Linux 和 Windows 查看 CUDA 和 cuDNN 版本
【CUDA】nvcc和nvidia-smi显示的版本不一致？
解决nvcc -V显示的CUDA版本与nvidia-smi显示的CUDA版本不一致的问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37239c6439a4aa2a25c355769212251e/" rel="bookmark">
			2.多个cuda共存，解决nvcc –V查看的cuda版本不是软链接的cuda对应的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多个cuda共存，解决nvcc –V查看的cuda版本不是软链接的cuda对应的 发现问题解决问题*修改环境变量PATH流程1.查看当前nvcc –V指向哪里的nvcc2.查找原因，为什么没有指向软链接好的地方3.排除问题4.成功解决 所以，接下来想用什么版本的cuda，都可以通过更改软链接的方式，直接指向想要用的cuda版本即可更改软链接cuda版本 参考帖 发现问题 服务器里面装了很多个版本的cuda.
1.查看/usr/local里面 cuda 版本的软链接——cuda
进入/usr/local目录 使用 stat cuda命令，可以看到指向的是cuda-8.0版本。
stat cuda 2.一般情况下，nvcc –V查看的cuda版本就是软链接这里的8.0，但是查了之后发现，nvcc –V的是9.1：
解决问题 *修改环境变量PATH 流程 换了有管理员权限的账户进行操作的。
1.查看当前nvcc –V指向哪里的nvcc 2.查找原因，为什么没有指向软链接好的地方 查看环境变量path，命令：
echo $PATH
发现原因：是因为/usr/bin（①处）在PATH中相较/usr/local/cuda（②处）靠前，因此优先级高，所以nvcc –V命令会按照PATH顺序，先去①里面找，应该是在这文件夹里的nvcc中找到了9.1版本的cuda，所以就不去别的地方找了，就没有找到②处我们想要的cuda版本；
3.排除问题 首先，将/usr/bin/nvcc保存成其他格式的，会发现再调用nvcc –V命令会提示没有文件了：
其次，更改PATH内①和②顺序，采用的方法是将环境变量②位置提前：
export PATH=/usr/local/cuda/bin:$PATH $PATH：如果PATH不为空，则指的是PATH原来的内容，在这里就是把PATH赋值给②+原来的PATH内容；如果PATH为空，则指的就是空内容。
4.成功解决 nvcc命令成功指向软链接/usr/local/cuda里面的cuda版本-8.0
所以，接下来想用什么版本的cuda，都可以通过更改软链接的方式，直接指向想要用的cuda版本即可 更改软链接cuda版本 因为我想要使用10.0的cuda，所以需要如下命令：作者：Maple2014 安装多版本 cuda ，多版本之间切换
在/usr.local目录下：
#切换cuda版本 rm -rf /usr/local/cuda #删除之前创建的软链接 sudo ln -s /usr/local/cuda-8.0/ cuda 最后文件名与参考帖有一点不同，其实没必要再加/usr/local/ 了，直接写cuda即可。
但是，服务器这里提示我没有权限，sudo rm删除旧的cuda版本需要我的账户有管理员权限，找同学用管理员账户给了我了管理员权限：
切换cuda版本：8.0→10.0，nvcc -V 查看转换成功！
参考帖 在此感谢实验室同学cw的帮助。
安装多版本 cuda ，多版本之间切换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5aef2d6a6d39c3a3d115777626816d/" rel="bookmark">
			静态方法和泛型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态变量 静态代码块 不能定义静态泛型变量静态方法不能使用/访问泛型类中的泛型，应该将该方法定义为泛型方法 public class Test&lt;T&gt; { public static T name; //error public T sex ; static { T ab; //error } } 泛型存在的意义就是为了动态指定具体类型，增强灵活性和通用性静态和动态之分就在于静态是编译时类型，动态是运行时类型。Java中的静态变量和静态代码块是在类加载的时候就执行的实例化对象时，先声明并实例化变量再执行构造函数即变量在实例化前已经被加载了静态申明与非静态申明的生命周期不同 静态方法 public class Test&lt;T&gt; { public static void main(String[] args) { } //泛型方法 public T demo1(T t) { return t; } //静态方法使用泛型参数 public static T demo2(T t) { return t;} //error //定义泛型静态方法 public static &lt;T&gt; ResponseBean&lt;T&gt; error(String msg, T data) { return new ResponseBean&lt;&gt;(200, data, msg); } } 静态方法不能访问类中定义的泛型，如果静态方法中数据类型不确定，可以在方法上定义泛型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5aef2d6a6d39c3a3d115777626816d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/369/">«</a>
	<span class="pagination__item pagination__item--current">370/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/371/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>