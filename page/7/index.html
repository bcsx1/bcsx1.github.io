<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b182d54fe4eb1dd3e7f7afa623447b/" rel="bookmark">
			使用克魔助手进行iOS数据抓包和HTTP抓包的方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 本文博客将介绍如何在iOS环境下使用克魔助手进行数据抓包和HTTP抓包。通过抓包，开发者可以分析移动应用程序的网络请求发送和接收过程，识别潜在的性能和安全问题，提高应用的质量和安全性。
引言 在移动应用程序的开发和测试过程中，对网络请求的调试和分析是至关重要的。通过抓包，开发者可以监听和分析应用程序发送和接收的网络请求，发现潜在的性能和安全问题。克魔助手提供了数据抓包和HTTP抓包两种方式，本文将详细介绍这两种方式的配置和使用方法，帮助开发者更好地进行网络请求的调试和分析。
数据抓包 在克魔助手中，首先通过数据线连接电脑和手机，然后在控制台的左侧工具栏要选择进行数据包的App，并点击“开始抓包”。这样就可以生成该App的抓包数据包，包括源端口、目的端口、源地址、协议等。用户还可以对抓包的数据进行过滤操作，选择需要的数据进行存储，方便后续的分析和调试。克魔助手抓包分为数据抓包和HTTP抓包两种方式。下面我们将详细介绍这两种方式。
APP过滤 数据过滤 此外 还可以对抓包的数据进行过滤操作，选择需要的数据进行存储。
HTTP抓包 抓取HTTPS请求，通常是通过在PC端安装mitmproxy证书。 通过设置为iOS设备信任mitmproxy证书，实现对HTTPS流量的中间人攻击并解密。
具体步骤如下：
1.魔助手中进行如下设置：点击“开始抓包”，然后点确定。
将会提示是否选取设备安装此描述文件
安装证书步骤： 首先到手机设置找到&gt;已下载描述文件，然后点击安装“mitmproxy证书”。
信任证书步骤：
首先到手机“设置”找到“通用”，然后点击进入“关于本机”，下一步到“信任根设置”，然后点击“信任根证书 mitmproxy”。
配置代理步骤： 首先找到手机“设置” 然后点击WiFi，找到最右侧的按钮，在选项上的“配置代理”中，选择“手动”，然后输入跟电脑一样的服务器号和端口号
配置完成后即可查看抓包的http数据，除此之外还可以看到的数据：请求头(常规，响应标头，请求标头），响应数据，负载数据
ps:请保持设备与电脑连接的是相同的Wi-Fi&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2320cbb072fbb04de8d5f021f06037/" rel="bookmark">
			光伏逆变器MPPT的作用、原理及算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MPPT是逆变器非常核心的技术，MPPT电压在进行光伏电站设计时一项非常关键的参数。
一、什么是MPPT？
（单块光伏组件的I-V、P-V曲线）
上图中，光伏组件的输出电压和电流遵循I-V曲线(绿色)、P-V曲线(蓝色)，如果希望逆变器输出的功率最大，就需要直流电压运行在红点所在的最大点，这个点就是最大功率点。假如最大功率点是550V，550V时功率是200W。此时，运行在520V时的功率约为190W，580V时约为185W，都没有550V时的功率大。逆变器如果跟踪不到550V，就损失了发电量，但不会对系统产生其他影响。
那为什么还要不断跟踪呢？因为这个曲线随着光照强度、温度和遮挡的不同在变化着，最大功率点也就在变化了，可能早上最大功率点电压是560V，中午是520V，下午是550V，所以逆变器需要不断地寻找这个最大功率点，也就是最大功率点跟踪了，这样才能保证全天的电池板能量都能最大化地输出出来，不浪费太阳能资源。
在了解上述基本知识的基础之上，我们再来聊一聊MPPT。
MPPT，即MaximumPowerPointTracking的简称，中文为“最大功率点跟踪”，它是指逆变器根据外界不同的环境温度、光照强度等特性来调节光伏阵列的输出功率，使得光伏阵列始终输出最大功率。
MPPT的作用是什么？
由于太阳能电池收到光强以及环境等外界因素的影响，其输出功率是变化的，光强发出的电就多，带MPPT最大功率跟踪的逆变器就是为了充分的利用太阳能电池，使之运行在最大功率点。也就是说在太阳辐射不变的情况下，有MPPT后的输出功率会比有MPPT前的要高，这就是MPPT的作用所在。
举个例子，假设MPPT还没开始跟踪，这时组件输出电压是500V，然后MPPT开始跟踪之后，就开始通过内部的电路结构调节回路上的电阻，以改变组件输出电压，同时改变输出电流，一直到输出功率最大(假设是550V最大)，此后就不断得跟踪，这样一来也就是说在太阳辐射不变的情况下，组件在550V的输出电压情况，输出功率会比500V时要高，这就是MPPT的作用。
二、单个光伏组件的MPPT的影响因素
一般来说，辐照度、温度变化对输出功率的影响，最直接就体现在MPPT上，也就是说辐照度和温度是影响MPPT的重要因素。
辐照度降低，光伏组件的输出功率会降低；温度升高，光伏组件的输出功率会降低；
1、辐照度对MPPT的影响
（辐照度变化对光伏组件输出功率的影响
逆变器进行最大功率点跟踪（MPPT）就是要找到上图中，功率最大的点。从上图可以看出，当辐照度下降的时候，最大功率点几乎是成比例降低的，如下表所示。
由上表可以看出辐照度成比例下降时，MPPT电压略微下降；由于P=IU，辐照度下降时，P成比例下降，而U略微下降，因此电流I应该是成比例下降的。
2、温度对MPPT的影响
（温度变化对组件输出功率的影响）
从上图可以看出，当温度变化时，最大功率按照温度系数的比例逐渐下降，如下表所示。
由此可见：电流主要受辐照度的大，电压主要受温度的影响。
三、光伏发电单元的MPPT及其原理与算法
1、光伏发电单元的MPPT
上面两张图都是一个光伏组件的MPPT跟踪，而在实际工程中，一个500kW的逆变器，往往要接80~90个光伏组串。
光伏阵列在使用过程中易受周围环境(如浮云，建筑物，树木遮荫等)和电池板表面的灰尘的干扰，导致光伏阵列的输出功率减小，输出特性曲线变得复杂。输出特性曲线呈多极值点。如果一个电站，某一个组串后面有空调机组；又有一片树叶遮盖了某一块电池片；又有一片树荫遮挡了部分组件。那么不同的组串间必然存在输出功率偏差。因此，每个逆变器接入的光伏组串的输出特性曲线变得复杂，呈多极值点，如何找到最高的那个点，就需要MPPT了！
（光伏方阵的输出功率曲线）
2、最大功率点跟踪的原理
随着电子技术的发展，当前太阳能电池阵列的MPPT控制一般是通过DC/DC变换电路来完成的。其原理框图如下图所示。
光伏电池阵列与负载通过DC/DC电路连接，最大功率跟踪装置不断检测光伏阵列的电流电压变化，并根据其变化对DC/DC变换器的PWM驱动信号占空比进行调节。
（MPPT系统原理框图）
对于线性电路来说，当负载电阻等于电源的内阻时，电源即有最大功率输出。虽然光伏电池和DC/DC转换电路都是强非线性的，然而在极短的时间内，可以认为是线性电路。因此，只要调节DC-DC转换电路的等效电阻使它始终等于光伏电池的内阻，就可以实现光伏电池的最大输出，也就实现了光伏电池的MPPT。
3、MPPT的算法
目前，光伏阵列的最大功率点跟踪(MPPT)技术，国内外已有了一定的研究，发展出各种控制方法常，常用的有一下几种：恒电压跟踪法(ConstantVoltageTracking简称CVT)、干扰观察法(PerturbationAndObservationmethod简称P&amp;O)、增量电导法(IncrementalConductancemethod简称INC)、基于梯度变步长的电导增量法等等。(这些算法只能用在无遮挡的条件下)
1）单峰值功率输出的MPPT的算法
目前，在无遮挡条件下，光伏阵列的最大功率点跟踪(MPPT)的控制方法常用的有以下几种：
l恒电压跟踪法(ConstantVoltageTracking简称CVT)
l干扰观察法(PerturbationAndObservationmethod简称P&amp;O)
l增量电导法(IncrementalConductancemethod简称INC)
l基于梯度变步长的电导增量法，等等。
2）多峰值功率输出MPPT算法
普通的最大功率跟踪算法，如扰动观测发和电导增量法在一片云彩的遮挡下就有可能失效，不能实现真正意义的最大功率跟踪。目前，国际上也有人提出了多峰值的MPPT算法，主要包含如下三种：
结合常规算法的复合MPPT算法
Fibonacci法
短路电流脉冲法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35ba2a77d698991ab0d97431f8cd3e75/" rel="bookmark">
			Mybatis SQL构建器类 - 问题&amp;答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 Java开发人员可能会碰到的最棘手的事情之一就是在Java代码中嵌入SQL语句。通常情况下，这是因为需要动态生成SQL语句 - 否则可以将其外部化到文件或存储过程中。正如你已经了解到的，MyBatis在其XML映射功能中有一个强大的解决方案来生成动态SQL。然而，有时候在Java代码中构建SQL语句字符串是必要的。在这种情况下，MyBatis还有一个特性可以帮助您，避免陷入典型的加号、引号、换行、格式化问题和嵌套条件语句处理额外逗号或AND连接符的混乱中。实际上，在Java中动态生成SQL代码可能会成为一场真正的噩梦。例如：
String sql = "SELECT P.ID, P.USERNAME, P.PASSWORD, P.FULL_NAME, " "P.LAST_NAME,P.CREATED_ON, P.UPDATED_ON " + "FROM PERSON P, ACCOUNT A " + "INNER JOIN DEPARTMENT D on D.ID = P.DEPARTMENT_ID " + "INNER JOIN COMPANY C on D.COMPANY_ID = C.ID " + "WHERE (P.ID = A.ID AND P.FIRST_NAME like ?) " + "OR (P.LAST_NAME like ?) " + "GROUP BY P.ID " + "HAVING (P.LAST_NAME like ?) "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35ba2a77d698991ab0d97431f8cd3e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e38e01ac7f7eaffdb608c7663218f8/" rel="bookmark">
			使用rsync构建镜像网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验环境
某公司在深圳、北京两地各放置了一台网站服务器，分别应对南北大区内不断增长的客户访问需求，两台服务器的网站文档必须保持一致，如图12.3所示，同步链路已通过VPN专用线路实现。
需求描述
&gt; 服务器 A（北京）作为rsync发起端，目录/var/www/html作为原始位置。
&gt; 服务器B（深圳）作为远程rsync 服务器，目录/var/www/html 作为目标位置。
&gt; 结合 inotify机制实现触发式的上行同步，保持两个站点的网页文档一致。
推荐步骤
配置rsync服务器（深圳，服务器B）。
通过 inotify 机制实现实时同步（北京，服务器 A）。
12.1配置rsync源服务器
本章以CentOS7.3系统中的rsync-3.1.2-4.el7.x86_64为例。
[root@node01 ~]# rpm -q rsync 在远程同步任务中，负责发起rsync同步操作的客户机称为发起端，而负责响应来自客户机的 rsync同步操作的服务器称为同步源。在同步过程中，同步源负责提供文档的原始位置，发起端应对 该位置具有读取权限，如图12.1所示。
(1)建立/etc/rsyncd.conf 配置文件。
配置文件rsyncd.conf位于/etc目录下。下面将以源目录/var/www/html、备份账号backuper为例，介绍其配置方法。
[root@node01 ~]# vim /etc/rsyncd.conf use chroot = yes //禁锢在源目录 address = 192.168.184.101 //监听地址 port 873 //监听端口 log file = /var/log/rsyncd.log //日志文件位置 pid file = /var/run/rsyncd.pid //存放进程ID的文件位置 hosts allow = 192.168.184.0/24 //允许访问的客户机地址 [wwwroot] //共享模块名称 path = /var/www/html //源目录实际路径 comment = Document Root of www1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59e38e01ac7f7eaffdb608c7663218f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ed959041c0c2c8ec90ada364485900/" rel="bookmark">
			C# 如何读取Excel文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当处理Excel文件时，从中读取数据是一个常见的需求。通过读取Excel数据，可以获取电子表格中包含的信息，并在其他应用程序或编程环境中使用这些数据进行进一步的处理和分析。本文将分享一个使用免费库来实现C#中读取Excel数据的方法。具体如下：
准备工作： 在VS中通过Nuget安装免费Excel读写库 – Free Spire.XLS for .NET. 或者下载产品包后手动导入dll。
实现思路： 导入Spire.Xls命名空间加载Excel文件获取指定工作表，然后再获取其中包含数据的区域遍历数据区域中的行和列通过 Worksheet.Range.Value 属性，以字符串形式返回单元格内的数字或文本。 读取Excel代码： using Spire.Xls; namespace ReadExcelData { class Program { static void Main(string[] args) { //创建Workbook类的对象 Workbook wb = new Workbook(); //加载Excel文件 wb.LoadFromFile("示例.xlsx"); //获取第一张工作表 Worksheet sheet = wb.Worksheets[0]; //获取包含数据的单元格区域 CellRange locatedRange = sheet.AllocatedRange; //遍历其中的每一行 for (int i = 0; i &lt; locatedRange.Rows.Length; i++) { //遍历其中的每一列 for (int j = 0; j &lt; locatedRange.Rows[i].ColumnCount; j++) { //获取单元格数据 Console.Write(locatedRange[i + 1, j + 1].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5ed959041c0c2c8ec90ada364485900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c2138fbce0fe746db73dedbea8d69d6/" rel="bookmark">
			鸿蒙开发之android对比开发《基础知识》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于华为鸿蒙未来可能不再兼容android应用，推出鸿蒙开发系列文档，帮助android开发人员快速上手鸿蒙应用开发。
1. 鸿蒙使用什么基础语言开发？ ArkTS是鸿蒙生态的应用开发语言。它在保持TypeScript（简称TS）基本语法风格的基础上，对TS的动态类型特性施加更严格的约束，引入静态类型。同时，提供了声明式UI、状态管理等相应的能力，让开发者可以以更简洁、更自然的方式开发高性能应用ArkTS官方文档。
2. 对于声明式UI知多少？ 鸿蒙应用也使用了声明式UI，作为大前端主流的开发方式，例如swiftUI、JetPack Compose、Flutter等。下面是一段鸿蒙的声明式UI代码：
如代码所见，我设置Text的文本（message），不再需要传统的获取到TextView的对象，然后调用setText(message)方法设置值，而是通过数据传递，响应式的设置控件的值。
3. application相当于鸿蒙app组件？ application相当于UIAbility，但是区别在于一个应用程序可以设置多个UIAbility。当用户打开、切换和返回到应用时，UIAbility实例会在其生命周期的不同状态之间转换。UIAbility类提供了一系列回调，通过这些回调可以知道当前UIAbility实例的某个状态发生改变，UIAbility实例的创建和销毁，或者UIAbility实例发生了前后台的状态切换。UIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，如图所示
Create状态：在应用首次创建UIAbility实例时触发，此时系统会调用onCreate()回调。可以在该回调中进行应用初始化操作，例如变量定义资源加载等，用于后续的UI界面展示。
WindowStageCreate和WindowStageDestroy状态：UIAbility实例创建完成之后，在进入Foreground之前，系统会创建一个WindowStage。WindowStage创建完成后会进入onWindowStageCreate()回调，可以在该回调中设置UI界面加载、设置WindowStage的事件订阅。
在onWindowStageCreate()回调中通过loadContent()方法设置应用要加载的页面，并根据需要调用on('windowStageEvent')方法订阅WindowStage的事件（获焦/失焦、可见/不可见）。Foreground和Background状态：Foreground和Background状态分别在UIAbility实例切换至前台和切换至后台时触发，对应于onForeground()回调和onBackground()回调。
onForeground()回调，在UIAbility的UI界面可见之前，如UIAbility切换至前台时触发。可以在onForeground()回调中申请系统需要的资源，或者重新申请在onBackground()中释放的资源。onBackground()回调，在UIAbility的UI界面完全不可见之后，如UIAbility切换至后台时候触发。可以在onBackground()回调中释放UI界面不可见时无用的资源，或者在此回调中执行较为耗时的操作，例如状态保存等。 例如应用在使用过程中需要使用用户定位时，假设应用已获得用户的定位权限授权。在UI界面显示之前，可以在onForeground()回调中开启定位功能，从而获取到当前的位置信息。当应用切换到后台状态，可以在onBackground()回调中停止定位功能，以节省系统的资源消耗。
Destroy状态：Destroy状态在UIAbility实例销毁时触发。可以在onDestroy()回调中进行系统资源的释放、数据的保存等操作。
例如调用terminateSelf()方法停止当前UIAbility实例，从而完成UIAbility实例的销毁；或者用户使用最近任务列表关闭该UIAbility实例，完成UIAbility的销毁。
4. activity相当于鸿蒙app什么组件？《点击查看做鸿蒙应用开发到底学习些啥？》 activity等同于使用@Entry和@Component修饰的页面组件。页面同样有生命周期和启动模式等概念。例如如下Splash页面的代码：
组件的生命周期包括aboutToAppear、onPageShow、onPageHide、onBackPress、aboutToDisappear五种状态，如图所示：
aboutToAppear: aboutToAppear?(): voidaboutToAppear函数在创建自定义组件的新实例后，在执行其build函数之前执行。aboutToAppear不同于onPageShow的地方在于该函数仅会在自定义组件实例创建后执行一次。允许在aboutToAppear函数中改变状态变量，更改将在后续执行build函数中生效。aboutToAppear函数可以用于接收自定义组件实例创建时的状态参数，初始化页面状态变量等。 aboutToDisappear: aboutToDisappear?(): voidaboutToDisappear函数在自定义组件析构销毁之前执行。不允许在aboutToDisappear函数中改变状态变量，特别是@Link变量的修改可能会导致应用程序行为不稳定。 onPageShow: onPageShow?(): void页面每次显示时触发一次，包括路由过程、应用进入前后台等场景，仅 @Entry修饰的自定义组件生效。 onPageHide: onPageHide?(): void页面每次隐藏时触发一次，包括路由过程、应用进入前后台等场景，仅 @Entry修饰的自定义组件生效。 onBackPress: onBackPress?(): void当用户点击返回按钮时触发，仅 @Entry修饰的自定义组件生效。返回true表示页面自己处理返回逻辑，不进行页面路由，返回false表示使用默认的路由返回逻辑。不设置返回值按照false处理。 页面组件之间跳转的方式有以下几种：
启动模式包含两种：
5. View相当于鸿蒙app什么组件？ 只使用@Compoent注解的组件可以理解为view,组件（Component）是界面搭建与显示的最小单位，HarmonyOS ArkUI声明式开发范式为开发者提供了丰富多样的UI组件，我们可以使用这些组件轻松的编写出更加丰富、漂亮的界面。
组件根据功能可以分为以下五大类：基础组件、容器组件、媒体组件、绘制组件、画布组件。其中基础组件是视图层的基本组成单元，包括Text、Image、TextInput、Button、LoadingProgress等，如下图所示：
本文主要讲解了鸿蒙开发之android对比开发，以及鸿蒙生态的开发语言ArkTS，
对于已经有移动开发经验的同学来说上手可以说非常快，ArkTS语法也非常简洁易学，如果大家对华为生态的应用开发感兴趣或者想深入学习可以借鉴：《做鸿蒙应用开发到底学习些啥？》
为了能让大家更好的学习鸿蒙 (Harmony OS) 开发技术，这边特意整理了《鸿蒙 (Harmony OS)开发学习手册》（共计890页），希望对大家有所帮助：做鸿蒙应用开发到底学习些啥？
《鸿蒙 (Harmony OS)开发学习手册》
入门必看
1. 应用开发导读(ArkTS)
2. 应用开发导读(Java)
HarmonyOS 概念
1. 系统定义
2. 技术架构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c2138fbce0fe746db73dedbea8d69d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d6c305b53869c3a61e40d1ffc43917/" rel="bookmark">
			java 企业工程管理系统软件源码&#43;Spring Cloud &#43; Spring Boot &#43;二次开发&#43; 可定制化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工程项目管理软件是现代项目管理中不可或缺的工具，它能够帮助项目团队更高效地组织和协调工作。本文将介绍一款功能强大的工程项目管理软件，该软件采用先进的Vue、Uniapp、Layui等技术框架，涵盖了项目策划决策、规划设计、施工建设到竣工交付、总结评估、运维运营等全过程。通过该软件，项目团队可以轻松地进行项目管理、合同管理、预警管理、竣工管理、质量管理等操作，从而提高项目管理的效率和质量。
工程项目管理软件（工程项目管理系统）对建设工程项目管理组织建设、项目策划决策、规划设计、施工建设到竣工交付、总结评估、运维运营，全过程、全方位的对项目进行综合管理
工程项目各模块及其功能点清单
一、系统管理
1、数据字典：实现对数据字典标签的增删改查操作
2、编码管理：实现对系统编码的增删改查操作
3、用户管理：管理和查看用户角色
4、菜单管理：实现对系统菜单的增删改查操作
5、角色管理：管理和查看用户角色的权限
6、系统消息：查看系统消息
二、系统设置
1、项目前期模板设置：实现对项目前期模板文档的增删改查操作
2、项目权限管理：管理各项目的成员名单
3、资源管理：实现对资源清单的增删改查操作
4、考核指标：实现对考核指标的增删改查操作
5、预警指标：实现对预警指标的增删改查操作
6、模板管理：实现对模板的增删改查操作
7、提醒消息模板：实现对提醒消息模板的增删改查操作
三、项目管理
1、项目列表：实现对项目列表的增删改查操作，包括查看各项目的立项人、创建时间、
项目经理、计划开始时间、计划结束时间等信息，可以进行终止和导出操作
2、项目计划管理：项目计划查看和管理模块，可执行增删改查操作，包括查看甘特图
3、进度上报管理：项目进度上报模块，可上报任务或任务步骤进度
4、形象进度：形象进度管理
5、指引：项目指引详情
四、合同管理
1、项目合同：项目合同详情查询和展示页面
2、问题合同：问题合同详情查询和展示页面
3、合同收付款：合同收付款详情查询和展示页面
4、资金计划：实现各项目资金计划的详情查看及其增删改和导出操作
5、项目考核：项目考核详情查看页面
6、奖惩管理：奖惩查看管理页面
五、预警管理
1、预警管理：预警管理和信息查看页面，可以执行设置预警指标操作
2、预警记录：预警记录管理
六、竣工管理
1、工程竣工移交：工程竣工移交管理
2、工程竣工验收：工程竣工验收管理
七、质量管理
1、中间验收：中间验收记录管理
2、质量检查：质量检查记录管理
3、隐患整改：隐患整改记录管理
八、统计报表
1、项目汇总：项目汇总信息查看，包括进度、计划时间等信息
2、进度报表：项目进度报表，包括计划时间和已用资源等信息
3、收支报表：项目收支报表，包含总体收支、项目收支和收支统计模块
4、资金计划报表：资金计划详情展示
5、资金计划统计：资金计划统计模块，提供信息导出功能
6、差异报表：项目差异报表，进入详情界面可执行基线对比
7、每周报表：项目每周报表
九、工作台
1、我的待办：我的待办和已办工作
2、我的消息：我的消息清单，包含未读信息和已读信息
前端架构：VUE、Uniapp、Layui、Bootstrap、H5、CSS3
涉及技术：Eureka、Config、Zuul、OAuth2、Security、OSS、Turbine、Zipkin、Feign、Monitor、Stream、ElasticSearch等 该工程项目管理系统采用先进的Spring Cloud+Spring Boot+Mybatis技术框架，结合Vue+ElementUI实现前后端分离，构建了一个功能强大的工程项目管理系统。该系统涵盖了项目管理、合同管理、预警管理、竣工管理、质量管理等多个方面，通过数据字典、编码管理、用户管理、菜单管理等功能实现了系统的全面管理和设置。前端架构采用VUE、Uniapp、Layui、Bootstrap、H5、CSS3等技术，后端涉及Eureka、Config、Zuul等云原生技术。该系统的建立将有助于提高工程管理效率、减轻劳动强度、提高信息处理速度和准确性，为企业数字化转型和提升竞争力提供了有力支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c5a7dcc0b4dedf6397f0a5654461b96/" rel="bookmark">
			Cookie和Session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cookie
cookie是什么
cookie的常用方法
cookie总结
session
为什么使用session？
session是什么？
session的常用方法
session总结
会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。
cookie cookie是什么 cookie是在浏览器中保存的
如果想要使用cookie要保证我们的浏览器是开启cookie，所以说有一定的弊端，如果浏览器没有开启cookie，就不能再使用cookie了
cookie的大小是有限制的，通常是4096byte
cookie的保存是以键值对的形式存在的
cookie的常用方法 //1.cookie的构造方法，目的是实例化出来cookie对象
Cookie(String name,String value)
//2.设置cookie的方法
setValue(String value) //修改cookie的值
getValue(String value) //获得cookie的值 getName(String value) //获得cookie的键 setMaxAge(int time) //设置cookie的有效时间
//3.要将cookie发送到浏览器
response.addCookie(Cookie cookie);
//4.获得所有cookie
request.getCookies();
实例
SetCookieServlet类
public class SetCookieServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { /** * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c5a7dcc0b4dedf6397f0a5654461b96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e85206319da8db8a252bb59c7799f8/" rel="bookmark">
			【react项目开发遇到的问题记录】：The above error occurred in the ＜Route.Provider＞ component:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行路由切换会出现一下报错：The above error occurred in the &lt;Route.Provider&gt; component:
解决办法
在使用组件懒加载的时候，在外面套一个react的组件:Suspense
Suspense 目前在 react 中一般配合 lazy 使用，当有一些组件需要动态加载(例如各种插件)时可以利用 lazy 方法来完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2707aa170caf40f8d716071fe20e7e82/" rel="bookmark">
			创酷rs2022车机安装app
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创酷rs2022车机安装app 关键词前置条件操作步骤向车机推送app 关键词 创酷rs车机安装app
创酷rs2022车机安装app
创酷rs车机进入工程模式
创酷rs2022车机进入工程模式
创酷rs车机开启adb
创酷rs2022车机开启adb。
前置条件 小雪OS升级到1.2版本。
操作步骤 屏幕进入主界面；
依顺序点击
左上
右上
右下
左下可能要点两遍；
然后主屏幕出现ICIEengineering图标；
点击ICEengineer图标，输入密码1到8输入3遍：123456781234567812345678
操作完上面4个步骤后，车机进入工程模式；
在工程模式下滑倒最下方，点击开启Wi-Fi ADB；
在点击系统设置，进入安卓的设置菜单；
连续点击系统版本9次，开启开发者模式，和安卓手机一样的方法。
向车机推送app 使用安卓手机安装甲壳虫adb；
甲壳虫ADB下载地址：
将安卓手机和车机连接到同一个Wi-Fi；
使用甲壳虫adb向车机推送app；
建议安装 快马市场，用来给车机安装app。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f511cf0a8eed3ab5027c2fcae0435b57/" rel="bookmark">
			rsync远程同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、配置rsync源服务器 rsync是一个开源的快速备份工具，可以在不同主机之间镜像同步整个目录树，支持增量备份，保持链接和权限，且采用优化的同步算法。
[root@localhost ~]# rpm -q rsync rsync-3.1.2-4.el7.x86_64 在远程同步任务中，负责发起rsync同步操作的客户机称为发前端，而负责响应来自客户机的rsync同步操作的服务器称为同步源。在同步过程中，同步与负责提供文档的原始位置，发前端应对该位置具有读取权限。
配置rsync同步源需要建立配置文件rsyncd.conf，创建备份账号，然后将rsync程序以守护进程（"--daemon"选项）方式运行。
1）建立/etc/rsyncd.conf配置文件
配置文件rsyncd.conf位于/etc目录下。
[root@localhost ~]# cat /etc/rsyncd.conf uid = nobody gid = nobody use chroot = yes address = 192.168.136.24 port 873 log file = /var/log/rsyncd.log pid file = /var/run/rsyncd.pid [wwwroot] path = /var/www/html comment = Document Root of www.bdqn.com read only = yes dont compress = *.gz *.bz2 *.taz *.zip *.rar auth users = backuper secrets file = /etc/rsyncd_users.db 2）为备份账户创建数据文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f511cf0a8eed3ab5027c2fcae0435b57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c85f1b971e8f14157d4a02e29b0a9667/" rel="bookmark">
			新字符设备驱动所涉及的函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 简介 经过前面字符驱动的实战操作，我们已经掌握了 Linux 字符设备驱动开发的基本步骤，字符 设备驱动开发重点是使用 register_chrdev 函数注册字符设备，当不再使用设备时就使用 unregister_chrdev 函数注销字符设备。 register_chrdev ()函数 和 unregister_chrdev() 这两个函数是老版本驱动使用的函数。现在新的 字符设备驱动已经不再使用这两个函数，而是使用 Linux 内核推荐的新字符设备驱动 API 函数。 本文之后我们来学习，如何编写新字符设备驱动，并且在驱动模块加载时自动创建设备节 点文件。 这里主要掌握 新字符设备驱动所涉及的函数的使用。 二. 新字符设备驱动原理 1. 分配和释放设备号 (1) 旧的字符设备注册函数的弊端 使用 register_chrdev() 函数注册字符设备时，只需要给定一个主设备号即可，但是这样会 带来两个问题： ① 需要我们事先确定好哪些主设备号没有使用（即确认开发板上所有字符设备都没有使用的一个主设备号）。 ② 会将一个主设备号下的所有次设备号都使用掉（因为register_chrdev() 函数的函参只传递了了主设备号，而没有传入次设备号导致的）。 例如，现在设置 LED 这个主设备号为 200 ，那么 0~1048575(2^20-1) 这个区间的次设备号就全部都被 LED 一个设备分走了。这样太浪 费次设备号了！一个 LED 设备肯定只能有一个主设备号，一个次设备号。 (2) 新的注册设备号 / 申请设备号函数 解决这两个问题最好的方法就是要使用设备号的时候向 Linux 内核申请，需要几个就申请 几个，由 Linux 内核分配设备可以使用的设备号。 如果没有指定设备号的话，就使用如下函数来申请设备号： int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) 如果给定了设备的主设备号和次设备，号就使用如下所示函数来注册设备号即可： int register_chrdev_region(dev_t from, unsigned count, const char *name) 参数 from 是要申请的起始设备号，也就是给定的设备号； 参数 count 是要申请的数量，一 般都是一个； 参数 name 是设备名字。 注 销 字 符 设 备 之 后 要 释 放 掉 设 备 号 ， 不 管 是 通 过 alloc_chrdev_region 函 数 还 是 register_chrdev_region 函数申请的设备号，统一使用如下释放函数： void unregister_chrdev_region(dev_t from, unsigned count) 新字符设备驱动下，设备号分配示例代码如下（可以在NXP 官方提供的 Linux内核源码中搜索到）： int major; /* 主设备号 */ int minor; /* 次设备号 */ dev_t devid; /* 设备号 */ if (major) { /* 定义了主设备号 */ devid = MKDEV(major, 0); /* 大部分驱动次设备号都选择 0 */ register_chrdev_region(devid, 1, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c85f1b971e8f14157d4a02e29b0a9667/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fc3888beb6a99fc61de9f2e6a5f5301/" rel="bookmark">
			android 手机主界面侧滑退出app问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近重新搭了个app，发现手机显示APP主界面时，沿着手机右边向左滑，会直接关闭应用，所以想搞个第一次提示，第二次退出app的效果。
结果搞出个复杂的东西，下面是两段代码。1:
1:GestureDetector+扩展函数。其实这个我觉得自己写的挺好，在一些不是系统级的滑动场景下应该有用。但时在返回退出这个需求上无法监听，实现效果。。。 class SwipeGestureListener(private val context:Context,private val onSwipeLeft:()-&gt;Unit) :GestureDetector.SimpleOnGestureListener() { override fun onFling( e1: MotionEvent, e2: MotionEvent, velocityX: Float, velocityY: Float ): Boolean { Log.e("滑动","onFling") val deltaX =e2.x -e1.x val deltaY =e2.y -e1.y if (Math.abs(deltaX)&gt;Math.abs(deltaY) &amp;&amp; deltaX&lt;0){ onSwipeLeft.invoke() return true } return false } // override fun onScroll( // e1: MotionEvent, // e2: MotionEvent, // distanceX: Float, // distanceY: Float // ): Boolean { // Log.e("滑动","onScroll") // // 判断手势为从右到左的滑动，并且滑动距离较大 // if (distanceX &lt; 0 &amp;&amp; Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fc3888beb6a99fc61de9f2e6a5f5301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab17266e9fce04fad8c0bc57267ad9df/" rel="bookmark">
			R语言学习笔记-R包的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐在线安装，可以解决包与包之间的依赖关系。
1.首先在RGui： 2.在RStudio 的console下： 如安装ggplot2包，则：
install.packages("ggplot2")
生信方面：
首先安装：
install.packages("BiocManager")
则就可以这样安装ggplot2包：
BiocManager::install("ggplot2")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec961346b502bdfc5a33a16c36d8f3f/" rel="bookmark">
			VScode——下载、安装、配置C/C&#43;&#43;环境（windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.快速下载 还在因为vscode官方下载慢而头疼嘛，按这个步骤来直接起飞兄弟萌
首先进入vscode官方网站然后选择对应版本下载然后进入浏览器下载页面复制下载链接粘贴到地址栏
将地址中的/stable前换成vscode.cdn.azure.cn
即可实现超速下载 下面是一个国内镜像的下载链接
https://vscode.cdn.azure.cn/stable/b4c1bd0a9b03c749ea011b06c6d2676c8091a70c/VSCodeUserSetup-x64-1.57.0.exe
点我快速下载
下载完后，你应该会安装，毕竟你已安装过无数软件啦！！！
二.配置过程 1.汉化教程 在插件里选择中文简体插件进行安装
在安装后需要重启，重启后应该是这样的
2.安装MinGW 方法一：
官网下载地址
方法二：
链接：百度网盘
提取码: mcv9
下载好后，点击.exe文件
Version: 指的是 gcc 的版本，如果没有特殊的需求，一般选择最高的版本号即可。最高版本是8.1.0 ，选中它即可
Architechture:电脑系统是 64位的，选择 x86_64；如果是 32位 系统，则选择 i686
Threads:如果是 Windows ，选择 win32 ，如果是 Linux、Unix、Mac OS 等其他操作系统要选择 posix
Exception：seh 是新发明的，而 sjlj 则是古老的。seh 性能比较好，但不支持 32位。 sjlj 稳定性好，支持 32位。
建议64位操作系统选择seh
最后我的选择是这样的。
后续请参考以下链接：
知乎参考链接
三.VScode配置C语言环境 1.自己先建立一个文件夹作为工作路径
2.打开VScode，选择打开刚刚的文件夹
3.建立一个.c文件或.cpp文件，它会自己弹出一个叫你安装C/C++的环境插件，你安装即可。
到这一步，你应该变成这样的。
4.如果接下来你要对字体、页面布局的大小进行设置，可以在左下角的设置按钮处进行设置
6.运行你的第一个程序7.了解一下生成的json文件 { "tasks": [ { "type": "cppbuild", "label": "C/C++: gcc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec961346b502bdfc5a33a16c36d8f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b840162321b6eb9f00138f41fdfc3418/" rel="bookmark">
			Java开发框架和中间件面试题(7)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
63.Spring中都应用了哪些设计模式？
64.请举例说明如何在Spring中注入一个Java Collection？
65.说一下都有哪些基本理念？
67.Spring Bean的生命周期？
68.说说Spring AOP的实现原理？
69.Spring中事务的实现方式？
70.说说Spring事务的底层原理？
71.Spring依赖注入有哪几种方式？
72.如何防止表单重复提交？
73.说一下Spring MVC的运行流程？
74.SpringMVC启动流程？
75.什么是ORM框架？
76.mybatis中的#和${}的区别是什么？
77.Mybatis是否支持延迟加载？延迟加载的原理是什么？
78.说一下mybatis的一级缓存和二级缓存？
79.mybatis有哪些执行器（Executor)?
80.Mybatis和hibernate的区别有哪些？
81.Mybatis如何根据多个id进行查询？
63.Spring中都应用了哪些设计模式？ 1.简单工厂模式：简单工厂模式的本质就是一个工厂类根据传入的参数，动态的决定实例化哪个类。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象。
2.工厂方法模式：应用程序将对象的创建以及初始化职责交给工厂对象，工厂Bean。定义工厂方法，然后通过config.xml配置文件，将其纳入Spring容器来管理，需要通过factory menthod指定静态方法名称。
3.单例模式：Spring用的是双重判断加锁的单例模式。
4.代理模式：Spring的AOP中，使用的Advice（通知）来增强被代理类的功能。Spring实现AOP功能的原理就是代理模式（①JDK动态代理，②CGlib字节码生成技术代理。）对类进行方法级别的切面增强。
5.装饰器模式：动态的给一个对象添加一些额外的功能。Spring的ApplicationContext中配置所有的DataSource。这些DataSource可能是不同的数据库，然后SessionFactory根据用户的每次请求，将DataSource设置成不同的数据源，以达到切换数据源的目的。在Spring中有两种表现：
一种是类名中含有Wrapper
另一种是类名中含有Decorator
6.观察者模式：定义对象间的一对多的关系，当一个对象的状态发生改变时，所有依赖于他的对象都得到通知并自动更新。Spring中观察者模式一般用在listener的实现。
7.策略模式：策略模式是行为性模式，调用不同的方法，适应行为的变化，强调父类的调用子类的特性。getHandler是HandlerMapping接口中唯一方法，用于根据请求找到匹配的处理器。
8.模板方法模式：Spring JdbcTemplate的query方法总体结构是一个模板方法和回调函数，query方法中调用的execute（）时一个模板方法，而预期的回调doInStatement(Statement state)方法也是一个模板方法。
64.请举例说明如何在Spring中注入一个Java Collection？ 1.Spring注入有四种方式：
set注入，构造器注入，基于注解的注入，xml配置文件注入
2.可以注入的Java collection集合类如下：
list，set，map，props:该标签支持注入键和值都是字符串类型的键值对。
list和set都使用value标签；map使用entry标签；props使用prop标签。
65.说一下都有哪些基本理念？ 1.横切关注点
对哪些方法进行拦截，拦截后怎么处理，这些关注点称为横切关注点；
2.Aspect（切面）通常是一个类，里面可以定义切入点和通知。
3.JointPoint（连接点）程序执行过程中明确的点，一般是方法的调用，被拦截到的点。因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。
4.Advice（通知）AOP在特定的切入点上执行的增强处理，有before（前置），after（后置），afterReturning(最终），afterThrowing（异常），around（环绕）。
5.Pointcut(切入点）带有通知的连接点，在程序中主要体现在书写切入点表达式。
6.weave（织入）将切面应用到目标对象并导致代理对象创建的过程。
7.introduction（引入）在不修改代码的前提下，引入可以在运行期为类动态地增加一些方法或者字段。
8.AOP代理（AOP proxy）AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以是JDK动态代理，也可以是CGlib代理，前者基于接口，后者基于子类。
9.目标对象（Target Object）包含连接点的对象，也被称作被通知或者被代理对象，POJO。
66.说一下AOP的使用场景？
1.Authentication权限
2.Caching缓存
3.Context passing内容传递
4.Error handling 错误处理
5.Lazy loading懒加载
6.Debugging调试
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b840162321b6eb9f00138f41fdfc3418/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dae26116d685d0013bd6ffbbfa854b3/" rel="bookmark">
			Java开发框架和中间件面试题(8)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
82.Mybatis一级缓存，二级缓存？
83.Mybatis如何防止SQL注入？
84.mybatis中resultType和resultMap有什么区别？
85.如何在SpringBoot中禁用Actuator断点安全性？
86.什么是SpringBoot？SpringBoot有哪些优点？
87.SpringBoot中的监视器是什么？
88.什么是yaml文件？
89.如何使用SpringBoot实现异常处理？ 90.SpringBoot中有哪些常用注解？
91.SpringBoot中有哪些选择器类？
92.SpringBoot中缓存相关的注解有哪些？
93.Springboot如何进行打包和部署？
94.SpringBoot如何访问不同数据库？
95.为什么要使用hibernate？
96.hibernate中如何在控制台查看打印的SQL语句？
97.hibernate有几种查询方式？
98.hibernate实体类可以被绑定为final吗？
99.在hibernate中使用integer和int做映射有什么区别？
100.如何搭建一个高可用的系统？
101.你认为项目中最重要的过程是哪些？
82.Mybatis一级缓存，二级缓存？ 1.一级缓存：指的是Mybatis中sqlSession对象的缓存，当我们执行查询以后，查询的结果会同时存入sqlSession中，再次查询的时候，先去sqlSession中查询，有的话直接拿出来，当sqlSession消失时，Mybatis的一级缓存也就消失了，当调用sqlSession的修改，添加，删除，commit(),close()等方法时，会清空一级缓存。
2.二级缓存：指的是Mybatis中的sqlSessionFactory对象的缓存，由同一个sqlSessionFactory对象创建的sqlSession共享其缓存，但是其中缓存的是数据而不是对象。当命中二级缓存时，通过存储的数据构造成对象返回。查询数据的时候，查询的流程是二级缓存&gt;一级缓存&gt;数据库。
3.二级缓存执行时机，如果开启了二级缓存，sqlSession进行close()后，才会把sqlSession一级缓存中数据添加到二级缓存中，为了将缓存数据取出来执行反序列化，还需要将要缓存的pojo实现Serializable接口，因为二级缓存数据存储介质多种多样，不一定只存在内存中，也可能存在硬盘中。
4.Mybatis执行步骤，Mybatis框架主要是围绕SqlSessionFactory进行的，具体步骤：
定义一个configuration对象，其中包含数据源，事务，mapper文件资源以及影响数据库行为属性设置settings.
通过配置对象，则可以创建一个sqlSessionFactoryBuilder对象
通过sqlSessionFactoryBuilder获得sqlSessionFactory实例。
通过sqlSessionFactory实例创建sqlSession实例，通过SqlSession对数据库进行操作。
83.Mybatis如何防止SQL注入？ 注意：但凡是sql注入漏洞的程序，都是因为程序要结束来自客户端用户输入的变量或者URL传递的参数，并且这个变量或者参数组成sql语句的一部分。对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的【外部数据不可信任】的原则。纵观Web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的。所以自然能想到，就是变量的检测，过滤，验证下手，确保变量是开发者所预想的。
1.检查变量数据类型和格式，数据类型检查，SQL执行前，要进行数据类型检查，如果是邮箱📮，参数就必须是邮箱的格式，如果是日期，就必须是日期格式；
只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式检查，确保变量是我们预想的格式，这样子很大程度上可以避免SQL注入攻击。如果上述例子中ID是int型的，效果会怎么样呢？无法注入，因为输入注入参数会失败。比如上述中的name字段，我们应该在用户注册的时候，就确定一个用户名规则，比如5~20个字符，只能由大小写字母，数字以及汉字组成，不包含特殊字符。此时我们应该有一个函数来完成统一的用户名检查。不过，仍然有很多场景并不能用到这个方法，比如写博客，评论系统，弹幕系统，必须允许用户可以提交任意形式的字符才行，否则用户体验感太差了。
2.过滤特殊符号
3.绑定变量，使用预编译语句
84.mybatis中resultType和resultMap有什么区别？ 1.resultType是直接表示返回类型的（对应着我们的Model对象中的实体）
2.resultMap则是对外部ResultMap的引用（提前定义了db和Model之间的映射key，value关系），但是resultType跟resultMap不能同时存在。
85.如何在SpringBoot中禁用Actuator断点安全性？ 默认情况下，所有敏感的HTTP端点都是安全的，只有具有Actuator角色的用户才能访问他们。安全性是使用标准的HTTPServletRequest.isUserInRole方法实施的。
我们可以使用managerment.security.enable=false来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。
86.什么是SpringBoot？SpringBoot有哪些优点？ 1.SpringBoot简介
基于Spring4.x的设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，引用的不稳定性得到了解决。
2.SpringBoot有哪些优点？
快速构建项目，可以选择一些必要的组件；
对主流框架的无配置集成；
内嵌Tomcat容器，项目可独立运行；
删除了繁琐的xml配置文件；
极大地提高了开发和部署效率；
提供starter,简化Maven配置；
3.SpringBoot有哪些缺点？
版本迭代速度快，一些模块改动很大；
由于无需配置，报错时很难定位。
87.SpringBoot中的监视器是什么？ 监视器也叫listener，是servlet的监听器，可以用于监听Web应用程序中某些对象的创建，销毁增加，修改，删除等动作的发生，然后做出相应的响应处理。当范围对象的状态发生改变时，服务器自动调用监听器对象中的方法，常用于系统加载时进行信息初始化，统计在线人数和在线用户，统计网站的访问量。配置监听器的方法：
通过@Component把监听器加入Spring容器中管理；
在application.properties中添加context.listener.class配置
在方法上加上@EventListener注解
88.什么是yaml文件？ yaml是JSON的一个超集，可以非常方便的将外部配置以层次结构形式存储起来。yaml可以作为properties配置文件的替代。
yaml使用的注意事项：
在properties文件中是以“."进行分割的，在yml中是用"."进行分割的；
yml的数据格式和json的格式很像，都是KV格式，并且通过":"进行赋值；
每个冒号后面一定要加一个空格；
89.如何使用SpringBoot实现异常处理？ 1.使用@ExceptionHandler注解处理局部异常，该方式只能处理当前Controller中的ArithmeticException和NullPointerException异常，缺点就是只能处理单个controller的异常。
2.使用@ControllerAdvice+@ExceptionHandler注解处理全局异常
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dae26116d685d0013bd6ffbbfa854b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73fa09affc10e7ae03f0788af04296b2/" rel="bookmark">
			Java开发框架和中间件面试题(9)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
102.你了解秒杀吗？怎么设计？
103.什么是缓存穿透？怎么解决？
102.你了解秒杀吗？怎么设计？ 1.设计难点：并发量大，应用，数据库都承受不了。另外难控制超卖。
2.设计要点：
将请求尽量拦截在系统上游html尽量静态化，部署到cdn上面。按钮及时设置为不可用，禁止用户重复提交请求。
设置页面缓存，针对同一个页面和uid一段时间内返回缓存页面。
数据用缓存抗，不直接落到数据库。
读数据的时候不做强一致性校验，写数据的时候再做。
在每台物理机上也缓存商品信息等等变动不大的相关的数据。
像商品中的标题和描述这些本身不变的会在秒杀开始之前全量推送到秒杀机器上并一直缓存直到秒杀结束。
像库存这种动态数据会采用被动失效的方式缓存一定时间（一般是数秒）。失效后再去缓存拉取最新的数据。如果允许的话，用异步的模式，等缓存都落库之后再返回结果。
如果允许的话，增加验证措施。
3.其他业务和技术保障措施：
业务隔离。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上说，卖家报名之后对我们来说就是已知热点，当真正开始时我们可以提前做好预热。
系统隔离。系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外99%分开。秒杀还申请了单独的域名，目的也是请求到不同的集群中。
数据隔离。秒杀所调用的数据大部分都是热数据，比如，会启用单独Cache集群或者MySQL数据库来放热点数据，目前也是不想0.01%的数据影响另外99.9%。另外需要复习缓存穿透，雪崩等等问题，主要的流量都落在了缓存数据库上，需要针对缓存数据库的高可用作保障。
4.短连接生成 这个应该是比较公认的方案了：
1.分布式ID生成器产生ID
2.ID转62进制字符串
3. 记录数据库，根据业务要求确定过期时间，可以保留部分永久链接，主要难点在于分布式ID生成。鉴于短连接一般没有严格递增的需求，可以使用预先分发一个号段，然后生成的方式。看了下新浪微博的短连接，8位，理论上可以保存超过200万亿对关系，具体怎么存储还有待研究。
103.什么是缓存穿透？怎么解决？ 1.缓存穿透。
一般的缓存穿透，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB数据库）。一些恶意的请求会故意查询不存在key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。
2.怎么解决？对查询结果为空的情况也进行缓存，缓存时设置短一点，或者该key对应的数据insert之后清理缓存。对一定不存在的key进行过滤。可以把所有的可能存在的key放在一个大的bitmap中，查询是通过该bitmap过滤。
3.缓存雪崩。
当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，会给后端系统带来很大的压力，导致系统崩溃。
4.如何解决？
在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如：
对某个key只允许一个线程查询数据和写缓存，其他线程等待；
做二级缓存，不同的key,设置不同的过期时间，让缓存失效的时间尽量均匀。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7e96251269b26be58c47546e88a41a2/" rel="bookmark">
			Java开发框架和中间件面试题(10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
104.怎么保证缓存和数据库数据的一致性？
105.什么是缓存穿透，什么是缓存雪崩？怎么解决？
106.如何对数据库进行优化？
107.使用索引时有哪些原则？
108.存储过程如何进行优化？
109.说说如何对Tomcat进行优化？
110.BIO、NIO和AIO的区别？
111.Netty的特点？
112.Netty的线程模型？
113.如何进行JVM性能调优？
115.GC调优策略有哪些？
116.介绍下单点登录？
117.RabbitMQ的使用场景有哪些？
118.RabbitMQ有哪些重要的角色？有哪些重要的组件？
119.RabbitMQ中vhost的作用是什么？
120.介绍下RabbitMQ的架构？
121.RabbitMQ中的交换机类型有哪些？
122.除了ReetrantLock,你还接触过JUC并发包中的哪些并发API？
123.你了解哪些负载均衡算法、策略？
124.如何设计符合幂等性的高质量Restful API ?
125.如何理解Restful API 的幂等性？
126.jsp和servlet有什么区别？
127.forward和redirect的区别？
128.jsp有哪几个作用域？
129.session和cookie有什么区别？
130.如果客户端禁止cookie能实现session还能用吗？
104.怎么保证缓存和数据库数据的一致性？ 1.淘汰缓存在；如果是较为复杂的数据时，进行缓存的更新操作就会变得异常复杂，因此一般推荐选择淘汰缓存，而不是更新缓存。
2.选择先淘汰缓存，再更新数据库，加入先更新数据库在淘汰缓存，如果淘汰缓存失败，那么后面的请求就会得到脏数据，直至缓存过期。加入先淘汰缓存再更新数据库，如果更新数据库失败，只会产生一次缓存穿透，相比较而言，后者对业务则没有本质上的影响。
3.延时双删除策略，如下场景：同时有一个请求A进行更新操作，另一个请求B进行查询操作。我们按照如下步骤执行：
（1）请求A进行写操作，删除缓存
(2)请求B查询发现缓存不存在
（3）请求B去数据库查询得到旧值
（4）请求B将旧值写入缓存
（5）请求A将新值写入数据库，次数便出现了数据不一致问题，此时我们可以采用延时双删策略的已解决。
public void write（String key,Object data){ redisUtils.del(key); db.update(data); Thread.Sleep(100); redisUtils.del(key); } 这么做，可以将1秒内所造成的缓存脏数据，再次删除。这个时间设定可以根据业务场景进行一个调节。
4.数据库读写分离的场景
假如有如下场景：两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。我们按照如下步骤执行：
1.请求A进行写操作，删除缓存
2.请求A将数据写入数据库了
3.请求B查询缓存发现，缓存没有值
4.请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值。
5.请求B将旧值写入缓存
6.数据库完成主从同步，从库变为新值，依旧采用延时双删策略解决此问题。
105.什么是缓存穿透，什么是缓存雪崩？怎么解决？ 1.缓存穿透：一般的缓存系统，都是按照key去缓存查询，如果不存在对用的value，就应该去后端系统去查找（比如DB数据库）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。
2.怎么解决？
对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert之后清理缓存。对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的bitmap中，查询时通过该bitmap过滤。
3.缓存雪崩：当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，会给后端系统带来大量的压力，导致系统崩溃。
4.如何解决？在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待；做二级缓存；不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀。
106.如何对数据库进行优化？ 1.选取适合的字段属性
为了获取更好的性能，可以将表中字段的宽度设的尽可能小。
尽量把字段设置成not null
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7e96251269b26be58c47546e88a41a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9877b9a68fb788320d4e6292d72c0862/" rel="bookmark">
			k8s的二进制部署（二）网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		节点部署完成之后,节点的状态都是Notready，所以要部署k8s网络：
k8s的网络类型： k8s中的通信模式：
pod内部之间容器与容器之间的通信。 在同一个pod中的容器共享资源和网络，使用同一个网络命名空间，可以直接通信的
同一个node节点之内，不同pod之间的通信 每个pod都有一个全局的真实的IP地址，同一个node直接的不同pod可以直接使用对方的pod的IP地址进行通信。
Pod1和pod2是通过docker的网桥来进行通信的
不同node节点的上的pod之间如何进行通信？ Cni插件：cni是一个标准接口，用于容器运行时调用网络插件，配置容器网络，负责设置容器的网络命名空间，IP地址，路由等等参数
Flanne插件：功能就是让集群之中不同节点的docker容器具有全集群唯一的虚拟IP地址，他是一个overlay网络，在底层物理网络的基础之上，创建一个逻辑的网络层，二层+三层的集合，二层是物理网络，三层是逻辑上的网络层，overlay网络也是一种网络虚拟化的技术
Flannel支持的数据转发方式： UDP模式，默认模式，应用转发，配置简单，但是性能最差Vxlan模式，基于内核转发，也是最常用的网络类型（小集群都使用这个模式）Host-gw（性能最好，但是配置麻烦，了解即可） UDP模式（用的较少）：基于应用转发，是由flannel来提供路由表，flannel封装数据包，解封装
每个node节点都会有一个flannel的虚拟网卡
数据流向图：
Vxlan模式：使用的就是overlay的虚拟隧道通信技术，是一个二层＋三层的模式
而UDP是基于应用层，用户态
Vxlan：flannel提供路由表，内核封装解封装
Flannel1.1接口，用的就是vxlan
Vxlan的工作模式图：简单来说就是说vni+ip地址
vim /etc/profile
source &lt;(kubectl completion bash)
source /etc/profile
Node1,node2
将flannel.tar拖入
docker load -i flannel.tar
mkdir -p /opt/cni/bin
将cni-plugins-linux-amd64-v0.8.6.tgz拖入
tar -xf cni-plugins-linux-amd64-v0.8.6.tgz -C /opt/cni/bin/
Node2同样的操作
Master01
拖入kube-flannel.yml
kubectl apply -f kube-flannel.yml
查看（多刷新几次，需要等待时间）
kubectl get pod -n kube-system
kubectl get pod -o wide -n kube-system
Ifconfig查看
Node1，node2
网络已部署完成
kubectl get nodes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9877b9a68fb788320d4e6292d72c0862/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/867dc1aa2c6351e1b16ae7d06f7d7ea4/" rel="bookmark">
			python实现rtmp推流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果只需要推送单独的视频流或者音频流时，最简单的方式是用python启动一个ffmpeg命令行进程，然后往该进程写入视频或者音频原始数据即可。
推送视频流代码
command = ['ffmpeg', '-y', '-an', '-f', 'rawvideo', '-vcodec','rawvideo', '-pix_fmt', 'rgb24', #像素格式 '-s', "{}x{}".format(width, height), '-r', str(fps), '-i', '-', '-pix_fmt', 'yuv420p', '-vcodec', "h264", '-f' , 'flv', push_url] pipe = subprocess.Popen(command, shell=False, stdin=subprocess.PIPE) 在需要写入视频帧时调用
pipe.stdin.write(image.tostring()) 推送音频流代码
command = ['ffmpeg', '-y', '-vn', '-f', 's16le', '-acodec','pcm_s16le', '-ac', '1', '-ar', '16000', '-i', '-', '-acodec', 'aac', '-f' , 'flv', push_url] pipe = subprocess.Popen(command, shell=False, stdin=subprocess.PIPE) 在需要写入音频时调用
pipe.stdin.write(frame.tostring()) 在同时有音视频时，用ffmpeg命令行一直没有调试成功，最后只好用c++代码调用ffmpeg api实现，然后再封装成python函数。这里主要参考了ffmpeg源代码中examples/muxing.c，对于音视频时间戳的同步需要比较注意，在这篇文章中有详细介绍 https://zhuanlan.zhihu.com/p/675007477。 代码已经开源 https://github.com/lipku/python_rtmpstream
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1a438f91eea8b5c5e43459d06fb0ff/" rel="bookmark">
			聊一聊Spring Bean 的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲一讲 Spring Bean 的生命周期算是面试时候一道非常经典的问题了！
如果没有研究过 Spring 源码，单纯去背面试题，这个问题也是可以回答出来的，但是单纯的背缺乏理解，而且面试一紧张，就容易背岔了。但是如果你从头到尾看了松哥的 Spring 源码分析，那么这个问题就不需要背了，就根据自己对 Spring 源码的理解讲出来就行了。
在前面的文章中，松哥和大家分析了 Spring 中 Bean 的创建是在 createBean 方法中完成的，在该方法中，真正干活的实际上是 doCreateBean 方法，具体位置在 AbstractAutowireCapableBeanFactory#doCreateBean，小伙伴们在面试时候常被问到的 Spring Bean 的生命周期，实际上就是问 doCreateBean 方法的执行逻辑。
doCreateBean 方法整体上来说，干了四件事：
Bean 的实例化。Bean 属性填充。Bean 初始化。Bean 销毁方法注册。 这里大家注意区分实例化和初始化两个方法，实例化是指通过反射创建出来 Bean 实例的过程，而初始化则是调用一些回调函数进行 bean 的一些预处理。
1. 实例化 // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) { instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); } if (instanceWrapper == null) { instanceWrapper = createBeanInstance(beanName, mbd, args); } Object bean = instanceWrapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b1a438f91eea8b5c5e43459d06fb0ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a35c2b6669c8c2b326b9bebe8e6e370/" rel="bookmark">
			如何批量提取pdf文件名到excel？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&amp;nbsp; &amp;nbsp; 如何批量提取pdf文件名到excel？在大家整理PDF文档的时候会不会遇到下面这些问题，首先PDF过多，每个PDF文件都有自己的名字，我们想要分类排放的话非常麻烦，不仅耗费时间而且带来的收益非常低，然后即使我们整理好了PDF文档，后续想要寻找这些PDF文档的话也是非常麻烦的，因为没有快速搜索的操作，即使将PDF进行分类了寻找也非常的难受，最后整理PDF文档的时候可能会出错，因为消耗了大量的精力和集中力，如果我们一次操作太长的时间很有可能导致整理后的文档有问题，后续要维护会变的更加麻烦。
综上所述，如果我们在整理PDF文档的时候遇到了上面这些问题应该怎么办呢？小编这里推荐的是批量提取PDF文件名到excel里面，这样能够带来超多的好处，首先能够快速的为我们整理和分类PDF文件，无需我们自己创建文件夹并一个个添加进去了，然后excel文档是支持查询操作的，如果我们想要找什么PDF文件直接搜索就可以找到，不用我们再自己手动翻找PDF文件，最后excel文档能够帮助我们完成分析和报告，如果领导有这方面的需求，excel文档也能够帮助我们快速完成分析的操作，那么应该如何批量提取PDF文件到excel里面呢？快来跟随小编看看下面这些方法吧！
&amp;nbsp;
方法一：使用“优速文件名提取器”批量提取PDF文件名到excel
步骤1：首先请您将“优速文件名提取器”下载并安装到电脑上，安装完成后打开软件，在软件左侧可以看到【文件名】选项，点击它。
&amp;nbsp;
步骤2：之后需要先将PDF导入到软件中，只要点击【添加文件】按钮就可以选择pdf文件并导入到软件里面。
&amp;nbsp;
步骤3：文件导入成功后左侧就会显示出很多设置，在这里我们可以设置名称、后缀等内容，但最重要的就是【导出格式】一定要设置为xlsx格式，也就是excel的格式，其余设置都可以按照自己的想法调节。
&amp;nbsp;
步骤4：调节完全部设置后点击右上角的【开始提取】按钮，启动软件的提取操作。等待一会提取完成会自动打开输出文件夹，文件名提取后的excel导出文件就保存在这里。
&amp;nbsp;
步骤5：双击将excel文件打开就可以看到所有PDF文件名都被成功提取到excel表格的第一列里。
&amp;nbsp;
方法二：使用Python 脚本来进行提取
&amp;nbsp;&amp;nbsp;&amp;nbsp;要批量提取&amp;nbsp;PDF 文件的名称到 Excel 表格中，你可以使用一些自动化的工具或脚本来实现这个目的。以下是一种常见的方法：
使用&amp;nbsp;Python 脚本：
&amp;nbsp;&amp;nbsp;你可以使用&amp;nbsp;Python 编写一个脚本来批量提取 PDF 文件名称，并将其保存到 Excel 表格中。首先，你需要安装 pandas 和 PyPDF2 这两个 Python 库，它们分别用于处理 Excel 表格和 PDF 文件。
下面是一个简单的示例代码，演示了如何批量提取指定文件夹中的&amp;nbsp;PDF 文件名称，并将其保存到 Excel 表格中：
import os
import pandas as pd
from PyPDF2 import PdfReader
# 指定 PDF 文件所在的文件夹路径
pdf_folder = '/path/to/your/pdf/folder'
# 遍历文件夹，提取 PDF 文件名
pdf_files = [f for f in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a35c2b6669c8c2b326b9bebe8e6e370/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a960f1b0bafe839c5a802f54a9b687ad/" rel="bookmark">
			OpenCV-Python(21):凸缺陷检测及点到多边形最短的距离求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习目标 凸缺陷的查找求某一点到一个多边形的最短距离不同形状的匹配 凸缺陷 前面我们已经学习了轮廓的凸包，对象上的任何凹陷都被成为凸缺陷。OpenCV 中有一个函数cv2.convexityDefect() 可以帮助我们找到凸缺。函数使用如下：
hull = cv2.convexHull(cnt,returnPoints = False) defects = cv2.convexityDefects(cnt,hull) 注意：如果查查找凸缺陷，在使用函数cv2.convexHull 找凸包时，参数returnPoints 一定要是False。 它会返回一个数组，其中每一行包含的值是[起点，终点，最远的点，到最远点的近似距离]。我们可以在一张图上显示它。我们将起点和终点用一条绿线连接，在最远点画一个圆圈，要记住的是返回结果的前三个值是轮廓点的索引。所以我们还要到轮廓点中去找它们。
import cv2 import numpy as np img = cv2.imread('star.jpg') img_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) ret, thresh = cv2.threshold(img_gray, 127, 255,0) contours,hierarchy = cv2.findContours(thresh,2,1) cnt = contours[0] hull = cv2.convexHull(cnt,returnPoints = False) defects = cv2.convexityDefects(cnt,hull) for i in range(defects.shape[0]): s,e,f,d = defects[i,0] start = tuple(cnt[s][0]) end = tuple(cnt[e][0]) far = tuple(cnt[f][0]) cv2.line(img,start,end,[0,255,0],2) cv2.circle(img,far,5,[0,0,255],-1) cv2.imshow('img',img) cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a960f1b0bafe839c5a802f54a9b687ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67f8fe02967266c70385bca56c2c0a8c/" rel="bookmark">
			Android集成OpenSSL实现加解密-JNI实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义JNI方法
companion object{ init { System.loadLibrary("jnitest") } } external fun encryptAES(data :ByteArray): ByteArray? external fun decryptAES(data :ByteArray): ByteArray? 使用OpenSSL方法实现AES加密和解密
#include "include/openssl/aes.h" const char* key_data = "0123456789abcdef"; extern "C" JNIEXPORT jbyteArray JNICALL Java_com_test_jnitest_TestLib_encryptAES(JNIEnv *env, jobject thiz, jbyteArray data_) { size_t len = strlen(key_data); // 数据长度 unsigned char* unsigned_key_data = new unsigned char[len]; // 分配内存空间 // 将数据复制到内存空间中 memcpy(unsigned_key_data, key_data, len); jbyte *data = env-&gt;GetByteArrayElements( data_, NULL); jsize data_length = env-&gt;GetArrayLength( data_); // 创建 AES 上下文对象 AES_KEY aes_key; if (AES_set_encrypt_key(unsigned_key_data, len * 8, &amp;aes_key) &lt; 0) { return NULL; } // 分配加密结果缓冲区 int out_size = data_length + AES_BLOCK_SIZE; unsigned char *encrypted_data = (unsigned char *) malloc(out_size); if (encrypted_data == NULL) { return NULL; } // 执行加密操作 AES_cbc_encrypt((unsigned char *) data, encrypted_data, data_length, &amp;aes_key, unsigned_key_data, AES_ENCRYPT); // 将加密结果转换为 Java 中的 byte 数组返回 jbyteArray result = env-&gt;NewByteArray( out_size); env-&gt;SetByteArrayRegion( result, 0, out_size, (jbyte *) encrypted_data); // 释放内存 free(encrypted_data); env-&gt;ReleaseByteArrayElements( data_, data, JNI_ABORT); return result; } extern "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67f8fe02967266c70385bca56c2c0a8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469a42a38283474a956fcacdeea826de/" rel="bookmark">
			6. C&#43;&#43;的引用与指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文首先介绍 C++ 的内存模型和变量周期作为知识背景，接着对C++中的引用和指针（原始指针和智能指针）进行介绍。
1. 对象生命周期 什么是对象生命周期？简单来说，对象生命周期指的是：对象从创建直到被释放的时间跨度。很自然地，我们会意识到不是所有变量的创建方式和释放时间都是一样的，据此，我们把对象的生命周期氛围四种类型：静态存储周期、线程存储周期、自动存储周期和动态存储周期。
静态存储周期： Static Storage Duration 静态存储周期类型的对象在程序执行开始的时候就会分配内存，直至整个程序结束了才会释放。主要包括：全局变量、静态的类数据成员和函数中的局部变量，如下例子所示：
// 1. 全局变量 int global_var = 10; // 2. 类中的静态数据成员 class MyClass{ static int static_var_class; } // 3. 函数中的静态局部变量 int myFunc(){ static int static_var_func; } 线程存储周期： Thread Storage Duration 线程存储周期类型的对象只会在指定的线程内进行内存的分配与释放。在多线程编程中，为了避免数据紊乱，可以使用该方法，当然以下提及的自动存储周期严格来说也能算是线程周期，只不过这个线程是代码默认的主线程，因此不需要额外标注。如下例子展示如何使用线程存储周期的变量：
thread_local int thread_var; 自动存储周期： Automatic Storage Duration 自动存储周期类型的对象只会存在于其被声明和定义的作用域内，一旦退出作用域则自动释放，如函数的参数或者其内部定义的局部变量。这是最常见或者说默认的定义类型，不需要额外的关键字，以下例子展示的是函数内部定义的局部变量：
void myFunction() { int local_var; // Automatic storage duration } 动态存储周期： Dynamic Storage Duration 动态存储周期类型的对象在程序执行的时候通过关键字 new 或 malloc 实时分配内存，直至整个作用域退出也不会自动释放内存，必须通过使用关键字 delete 或 free 函数进行手动释放，否则会造成内存泄漏的问题。如下例子展示如何分配和释放一个原始指针变量：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/469a42a38283474a956fcacdeea826de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd2b252c04762a1defb2ae3014a2f06f/" rel="bookmark">
			Unity 爱心血量效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这里写自定义目录标题 1.准备爱心血条2.HeartUI 代码3.在Inspector窗口中绑定好对象4.在血量减少的地方，调用更新方法5.效果展示 1.准备爱心血条 准备好红色爱心和灰色爱心的图片
2.HeartUI 代码 using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; public class Hearts : MonoBehaviour { [Header("爱心UI图的列表")]public List&lt;Image&gt; redHearts = new(); void Start () { } public void UpdateHeartUI(int HP) { //先将所有红色爱心全部隐藏 foreach (Image redHeart in redHearts) { redHeart.enabled = false; } //再根据HP数量先将爱心依次显示 for (int i=0; i&lt; HP; i++) { redHearts[i].enabled = true; } } } 3.在Inspector窗口中绑定好对象 4.在血量减少的地方，调用更新方法 5.效果展示 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed2aa271dd3e3353305b4f94a6268cb/" rel="bookmark">
			防反接电路与MOS管防反接深入解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、经典防反接电路 1、二极管防反接 这种电路使用一个二极管将电源的正极与负极相连，当电源的极性正确时，二极管处于正向导通状态，电流可以正常流过；而当电源的极性反接时，二极管处于反向截止状态，电流无法通过，从而起到了防反接的作用。
缺点：利用二极管的单向导电性实现电源防反接，但电路经过二极管后会有压降，拉低负载电路电压。
2、整流桥防反接保护电路： 这种电路使用了一个整流桥，它由4个二极管组成，可以将电源的正负极性自动纠正。当电源的极性正确时，整流桥的输出与电源的输出相同；而当电源的极性反接时，整流桥会自动将电源的正负极性进行调换，从而实现了防反接的功能。
缺点：产生两个二极管的压降，拉低负载电路电压。
3、PMOS管防反接 这种电路使用了一个PMOS管作为开关，当电源的极性正确时，MOS管处于导通状态，电流可以正常流过；而当电源的极性反接时，MOS管处于截止状态，电流无法通过，从而实现了防反接的作用。
优点：MOS管导通电阻非常小，因此导通压降可以忽略不计。
区别：在正常的MOS管应用电路中VDS&lt;0，但此处VDS&gt;0。下面会进行详细解释。
4、保险丝+稳压管防反接 这种电路使用了一个保险丝+稳压管，当电源的极性正确时，保险丝处于正常工作状态；而当电源的极性反接时，稳压管反向导通，保险丝会熔断，切断电路，从而保护后级电路的安全运行。
优点：既能防止反接，还能防止过压和过流。
二、MOS管防反接电路详解 1、如下图所示为：VDS&lt;0的MOS管防反接电路。 电源正接时，PMOS的寄生二极管是截止的。
VS=5v,VG=0V,VGS=0-5V=-5V&lt;-VGS(th) PMOS导通
电源反接时，寄生二极管会导通，电源与负载电路未完全断开，因此不可靠。
2、如下图所示为：VDS&gt;0的MOS管防反接电路。 VS=5v-0.7=4.3V,VG=0V,VGS=0-4.3V=-4.3V&lt;-VGS(th) PMOS导通
电源反接时寄生二极管和MOS管都断开，电源与负载电路断开，可靠
三、MOS管寄生电容与GS端的串并联电阻 寄生电容 上图中的C(GD) C(GS) C(DS)为二极管的寄生电容。
寄生电容是指电感，电阻，芯片引脚等在高频情况下表现出来的电容特性。
一个电阻等效于一个电容，一个电感，一个电阻的串联，低频情况下表现不明显，而高频情况下，等效值会增大。
MOS管经常被要求数十K乃至数M的开关频率，频率越高，交流成分越大，寄生电容就能通过交流电流的形式通过电流，形成栅极电流。消耗的电能、产生的热量不可忽视。
MOS管的寄生电容是指由于MOS管的结构和构造而产生的电容。它主要包括输入电容（Ciss）、输出电容（Coss）和反向传输电容（Crss）三个参数。
输入电容（Ciss）是指当MOS管的输入端施加一个信号时，所需要的电荷量。它由MOS管的栅极和源极之间的电容以及栅极和漏极之间的电容组成。
输出电容（Coss）是指当MOS管的输出端施加一个信号时，所需要的电荷量。它由MOS管的漏极和源极之间的电容以及栅极和漏极之间的电容组成。
反向传输电容（Crss）是指当MOS管的栅极施加一个信号时，所需要的电荷量。它由MOS管的栅极和漏极之间的电容组成。
这些寄生电容会影响到MOS管的开关速度和性能。在使用MOS管构建电路时，我们需要考虑到这些寄生电容的存在，以免与外部电路冲突，并确保电路的正常运行
GS间的并联电阻 1、泄放电阻、释放寄生电容Cgs的电流。
2、保证MOS管有效关断，当G级开路时，DS端的电压会给C(GD)充电，导致G级电压升高，MOS不能有效关断。
有并联电阻后，G级开路，则GS端等电位，保证了MOS管的有效关断。
G级串联电阻 1、减小电流，G级串联电阻，与 Ciss（Ciss = Cgd+Cgs）形成一个RC充放电电路，可以减小瞬间电流值。
2、减小振荡，MOS管接入电路，也会有引线产生的寄生电感的存在，与寄生电容一起，形成LC振荡电路。
对于开关方波波形，是有很多频率成分存在的，那么很可能与谐振频率相同或者相近，形成串联谐振电路。
串联一个电阻，可以减小振荡电路的Q值，是振荡快速衰减，不至于引起电路故障。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da45622064a1f1b565fded7f2f330d59/" rel="bookmark">
			【git】提交pr之前，提前看到pr的效果，即本地分支和master的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd210bca891f1abb6fdd4cf57327e05/" rel="bookmark">
			FPGA - 231227 - 5CSEMA5F31C6 - 电子万年历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TAG - F P G A 、 5 C S E M A 5 F 31 C 6 、电子万年历、 V e r i l o g FPGA、5CSEMA5F31C6、电子万年历、Verilog FPGA、5CSEMA5F31C6、电子万年历、Verilog 顶层模块 module TOP( input CLK,RST,inA,inB,inC,switch_alarm, output led,beep_led, output [41:0] dp ); // 按键消抖模块 wire keyA_turn, keyB_turn, keyC_turn; // 按键处理模块 wire select_sign; wire [1:0]	flag_turn; wire [1:0] flag_switch; wire year_add, month_add, day_add; wire	hour_add, minute_add, second_add; wire alarm_hour_add, alarm_minute_add, alarm_second_add; // 时钟模块 wire [6:0] year; wire [4:0] day; wire [3:0] month; wire [4:0] hour; wire [5:0] minute; wire [5:0] second; // 数码管显示模块 wire [32:0]	digital_clock; // 闹钟模块 wire [4:0]	alarm_hour; wire [5:0]	alarm_minute; wire [5:0]	alarm_second; //按键消抖模块 right_key rk_A( .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd210bca891f1abb6fdd4cf57327e05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd72b555bc180e61f511afed76cc6a3b/" rel="bookmark">
			ChatGPT在地学、GIS、气象、农业、生态、环境等领域中的高级应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以ChatGPT、LLaMA、Gemini、DALL·E、Midjourney、Stable Diffusion、星火大模型、文心一言、千问为代表AI大语言模型带来了新一波人工智能浪潮，可以面向科研选题、思维导图、数据清洗、统计分析、高级编程、代码调试、算法学习、论文检索、写作、翻译、润色、文献辅助阅读、文献信息提取、辅助论文审稿、新闻撰写、科技绘图、地学绘图（GIS地图绘制）、概念图生成、图像识别、教学课件、教学案例生成、基金润色、专业咨询、文件上传和处理、机器/深度学习训练与模拟、大模型API二次开发等特定任务，生成文本、图片、代码、语音、视频等不同形式的数据、模式和内容，成为不少科研工作者的第二大脑。
专题一
开启大模型
1 开启大模型
1) 大模型的发展历程与最新功能
2) 大模型的算法构架与底层逻辑
3) 大模型的强大功能与应用场景
4) 国内外经典大模型（ChatGPT、LLaMA、Gemini、DALL·E、Midjourney、Stable Diffusion、星火大模型、文心一言、千问等）
5) 如何优雅使用大模型
案例1.1：开启不同平台的大模型
案例1.2：GPT不同版本的使用
案例1.3：大模型文件上传和处理
专题二
基于ChatGPT大模型提问框架
2 提问框架（提示词、指令）
1) 专业大模型提示词，助你小白变专家
2) 超实用的通用提示词和提问框架
3) 高级提问技巧
案例2.1：设定角色与投喂规则
案例2.2：行业专家指令合集
案例2.3：角色扮演与不同角度提问
案例2.4：分步提问与上下文关联
案例2.5：经典提问框架练习，提升模型效率
专题三
基于ChatGPT大模型的数据清洗
3 基于ChatGPT的数据清洗
1) R语言和Python基础（勿需学会，能看懂即可）
2) 数据清洗方法（重复值、缺失值处理、异常值检验、标准化、归一化、数据长宽转换，数据分组聚合）
案例3.1：使用大模型指令随机生成数据
案例3.2：使用大模型指令读取数据
案例3.3：使用大模型指令进行数据清洗
案例3.4：使用大模型指令对农业气象数据进行预处理
案例3.5：使用大模型指令对生态数据进行预处理
专题四
基于ChatGPT大模型的统计分析
4 基于AI大模型的统计分析
1) 统计假设检验
2) 统计学三大常用检验及其应用场景
3) 方差分析、相关分析、回归分析
4) 混合线性模型
5) Meta分析
案例4.1：使用大模型对生态环境数据进行正态性检验、方差齐性检验
案例4.2：使用大模型进行t检验、F检验和卡方检验
案例4.3：使用大模型指令对生态环境数据进行方差分析、相关分析及回归分析
案例4.4：使用大模型指令构建混合线性模型
案例4.5：使用大模型指令对文献收集数据进行Meta分析 专题五
基于ChatGPT大模型的机器学习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd72b555bc180e61f511afed76cc6a3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e452b4a01a9d5a9792353c153c8a1eb/" rel="bookmark">
			AI大模型引领未来智慧科研暨丨ChatGPT在地学、GIS、气象、农业、生态、环境等领域中的高级应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以ChatGPT、LLaMA、Gemini、DALL·E、Midjourney、Stable Diffusion、星火大模型、文心一言、千问为代表AI大语言模型带来了新一波人工智能浪潮，可以面向科研选题、思维导图、数据清洗、统计分析、高级编程、代码调试、算法学习、论文检索、写作、翻译、润色、文献辅助阅读、文献信息提取、辅助论文审稿、新闻撰写、科技绘图、地学绘图（GIS地图绘制）、概念图生成、图像识别、教学课件、教学案例生成、基金润色、专业咨询、文件上传和处理、机器/深度学习训练与模拟、大模型API二次开发等特定任务，生成文本、图片、代码、语音、视频等不同形式的数据、模式和内容，成为不少科研工作者的第二大脑。
专题一
开启大模型
1 开启大模型
1) 大模型的发展历程与最新功能
2) 大模型的算法构架与底层逻辑
3) 大模型的强大功能与应用场景
4) 国内外经典大模型（ChatGPT、LLaMA、Gemini、DALL·E、Midjourney、Stable Diffusion、星火大模型、文心一言、千问等）
5) 如何优雅使用大模型
案例1.1：开启不同平台的大模型
案例1.2：GPT不同版本的使用
案例1.3：大模型文件上传和处理
专题二
基于ChatGPT大模型提问框架
2 提问框架（提示词、指令）
1) 专业大模型提示词，助你小白变专家
2) 超实用的通用提示词和提问框架
3) 高级提问技巧
案例2.1：设定角色与投喂规则
案例2.2：行业专家指令合集
案例2.3：角色扮演与不同角度提问
案例2.4：分步提问与上下文关联
案例2.5：经典提问框架练习，提升模型效率
专题三
基于ChatGPT大模型的数据清洗
3 基于ChatGPT的数据清洗
1) R语言和Python基础（勿需学会，能看懂即可）
2) 数据清洗方法（重复值、缺失值处理、异常值检验、标准化、归一化、数据长宽转换，数据分组聚合）
案例3.1：使用大模型指令随机生成数据
案例3.2：使用大模型指令读取数据
案例3.3：使用大模型指令进行数据清洗
案例3.4：使用大模型指令对农业气象数据进行预处理
案例3.5：使用大模型指令对生态数据进行预处理
专题四
基于ChatGPT大模型的统计分析
4 基于AI大模型的统计分析
1) 统计假设检验
2) 统计学三大常用检验及其应用场景
3) 方差分析、相关分析、回归分析
4) 混合线性模型
5) Meta分析
案例4.1：使用大模型对生态环境数据进行正态性检验、方差齐性检验
案例4.2：使用大模型进行t检验、F检验和卡方检验
案例4.3：使用大模型指令对生态环境数据进行方差分析、相关分析及回归分析
案例4.4：使用大模型指令构建混合线性模型
案例4.5：使用大模型指令对文献收集数据进行Meta分析 专题五
基于ChatGPT大模型的机器学习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e452b4a01a9d5a9792353c153c8a1eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33807f7e593ba2d69d46149b2bd402ac/" rel="bookmark">
			R语言【BIEN】——BIEN_occurrence_family 可从 BIEN 数据库中提取指定科（或多个科）的所有记录。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Package BIEN version 1.2.6
Parameters BIEN_occurrence_family( family, cultivated = FALSE, new.world = NULL, observation.type = FALSE, all.taxonomy = FALSE, native.status = FALSE, natives.only = TRUE, political.boundaries = FALSE, collection.info = FALSE, ... ) 参数【family】：一个科名或一个科名组成的向量。
参数【cultivated】：是否也返回已知的栽培记录？默认为 FALSE。
参数【new.world】：NULL（默认值）返回全球记录，TRUE 仅返回新世界记录，FALSE 仅返回旧世界记录。
参数【observation.type】：是否返回观测类型的信息（即标本与绘图）？默认值为 FALSE。
参数【all.taxonomy】：返回所有分类信息？包括原始数据和 "擦除" 数据。
参数【native.status】：是否返回引种状态信息？默认值为 FALSE。如果值为 TRUE ，还会返回有关引种状态的其他信息。
参数【native.only】：是否排除检测到的引入物种？默认为 TRUE。
参数【political.boundaries】：是否返回观测记录的行政边界信息？默认值为 FALSE。
参数【collection.info】：是否返回有关收集和识别的附加信息？默认值为 FALSE。
参数【...】：传递给内部函数的附加参数。
Value 数据帧，包含指定科的观测记录。
Example &gt; library(BIEN) 载入需要的程辑包：RPostgreSQL 载入需要的程辑包：DBI Type vignette("BIEN") or vignette("BIEN_tutorial") to get started Error in file(con, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33807f7e593ba2d69d46149b2bd402ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5af34f5bd7844b6409a63023c5708a17/" rel="bookmark">
			【将G2O库使用交叉编译移植到arm平台】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 准备材料
1.下载好g2o的代码。下载地址：https://github.com/RainerKuemmerle/g2o
如果只是在Ubuntu系统上安装g2o，可以参考代码库中的readme.md。
2.下载suitesparse4.4.6. 选择4.4.6版本是因为我发现ROS系统中使用的是这个版本。即使用sudo apt-get install libsuitesparse-dev命令安装的版本。
3.相应的编译工具make 和cmake 是要有的。
4.安装自己的交叉编译工具链。我这里使用的是arm板厂商提供的编译工具
二 对G2O库的改造
1.将suitesparse文件夹中的CXSParse里的源码替换掉g2o的EXTERNAL文件夹中的csparse。
注意SuiteSparse_config文件夹中的SuiteSparse_config.h也需要拷过去。
EXTERNAL中的CMakeList.txt里59行需要去掉cs_api.h。因为这个文件已经没有了。
以上步骤主要是将g2o中原来的csparse替换为性能更好的cxsparse。
2.修改g2o的CMakeList.txt。
按照下面的方式设置交叉编译工具。 SET(CMAKE_SYSTEM_NAME Linux) SET(TOOLCHAIN_DIR "/home/andrew/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu") set(CMAKE_CXX_COMPILER ${TOOLCHAIN_DIR}/bin/aarch64-linux-gnu-g++) set(CMAKE_C_COMPILER ${TOOLCHAIN_DIR}/bin/aarch64-linux-gnu-gcc) SET(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN_DIR} ${TOOLCHAIN_DIR}/aarch64-linux-gnu/include ${TOOLCHAIN_DIR}/aarch64-linux-gnu/lib) 2)关掉了CHOLMOD，因为我没有使用CHOLMOD的solver。
# For building the CHOLMOD / CSPARSE solvers option (G2O_USE_CHOLMOD "Build g2o with CHOLMOD support" OFF) 3)使g2o自己编译EXTERNAL中的csparse。
# find_package(CSparse) # if (G2O_USE_CSPARSE) # if(CSPARSE_FOUND) # set(BUILD_CSPARSE OFF CACHE BOOL "Build local CSparse library") # else(CSPARSE_FOUND) set(BUILD_CSPARSE ON CACHE BOOL "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5af34f5bd7844b6409a63023c5708a17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4551b3ef86bf6c21bc658bc4c374d1c4/" rel="bookmark">
			Java工具类：获取当前方法上一级、全部的调用者
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、场景二、工具类三、测试类四、测试结果 一、场景 在一些多线程的代码逻辑中，一个方法可能会被很多不同的线程所调用，如果没办法知道该方法具体的调用者，在通过日志排查问题时，日志会非常难以分析
解决：可以在打印日志时，将方法的上一级调用者打印出来
二、工具类 /** * 堆栈相关工具类 * * @author hcs * @date 2023/8/21 14:05 */ public class StackTraceUtils { /** * 获取方法整个调用过程的相关信息 * * @return */ public static String getAllTag() { StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace(); for (StackTraceElement e : stackTrace) { System.out.println("当前方法调用过程 = " + e.getClassName() + "\t" + e.getMethodName() + "\t" + e.getLineNumber()); } StackTraceElement log = stackTrace[1]; String tag = null; for (int i = 1; i &lt; stackTrace.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4551b3ef86bf6c21bc658bc4c374d1c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3851eab3e5e8ea36b61b55f47cc22a47/" rel="bookmark">
			Android集成OpenSSL实现加解密-编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 OpenSSL 源码：
前往 OpenSSL 官方网站（https://www.openssl.org/source/）下载最新的源码压缩包并解压，示例在WSL环境编译
下载NDK
前往https://developer.android.google.cn/ndk/downloads?hl=zh-cn下载NDK版本并解压
配置交叉编译环境
export ANDROID_NDK_ROOT=/home/android-ndk-r23c PATH=$ANDROID_NDK_ROOT/toolchains/llvm/prebuilt/linux-x86_64/bin:$PATH 修改 OpenSSL 的配置文件
./Configure android-arm64 -D__ANDROID_API__=29 --prefix=/home/openssl-3.2.0/output 这里的 android-arm 可根据你的需要选择不同的目标平台和架构，例如 android-arm64、android-x86 等。 --prefix 参数是指定 OpenSSL 编译输出的目录，目录建议提前新建。
执行编译命令：
make &amp;&amp; make install 编译成功后，会在输出路径下生成如下文件夹
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d03afe5cf52b5f5a682696b5af0e7d2/" rel="bookmark">
			如何分清Session、Request、ServletContext
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Session、Request 和 ServletContext 是 Java Web 开发中常用的对象，用于在不同范围内存储和共享数据。
作用域：servletContext &gt; Session &gt; request
Session（会话） 表示服务器和客户端之间的一次会话。当用户访问服务器时创建，当用户关闭浏览器或会话超时时销毁。可以存储特定用户的状态信息，比如登录状态、购物车内容等。在不同的页面或请求中共享同一个用户的会话数据。可以通过 HttpSession 对象访问和操作。在 JSP 或 Servlet 中，可以使用 request.getSession() 获取当前会话的 HttpSession 对象。 Request（请求） 表示客户端发送给服务器的请求，包含了客户端的信息和数据。在一次 HTTP 请求的生命周期内有效，包含了用户的请求信息、参数、头部信息等。可以通过 HttpServletRequest 对象访问和操作。在 Servlet 中，请求对象由容器（比如 Tomcat）创建并传递给 Servlet。 ServletContext（Servlet 上下文） 表示整个 Web 应用的上下文，是全局唯一的。在整个 Web 应用的生命周期内有效，可以用于在不同的 Servlet 之间共享数据和资源。可以用于获取应用级别的参数、存储全局数据等。在 Servlet 中，可以通过 getServletContext() 获取 ServletContext 对象。 区别 SessionRequestServletContext作用域会话级别。每个用户会话对应一个独立的 Session 对象。请求级别。每个 HTTP 请求都有对应的 Request 对象。应用级别。整个 Web 应用共享一个 ServletContext 对象。存储内容存储特定用户的状态和数据，比如登录信息、购物车内容等。在整个会话期间保持持久性。包含了当前请求的信息，如请求参数、头部信息等。存储应用级别的全局数据、参数和资源，可供整个应用程序使用。获取方式通过 HttpServletRequest 的 getSession() 方法获取 HttpSession 对象。由 Servlet 容器创建，并作为参数传递给 Servlet 的 doGet() 或 doPost() 方法。在 Servlet 中可以使用 getServletContext() 方法获取 ServletContext 对象。 生命周期会话在用户访问服务器时创建，在用户退出或会话超时后销毁。Request 对象的生命周期仅在单次请求过程中有效，请求结束后被销毁。ServletContext 对象在 Web 应用启动时创建，在应用关闭时销毁，它存在于整个应用的生命周期内。 这些对象的区别在于它们的作用域、生命周期和存储内容。Session 用于跟踪用户会话状态，Request 用于处理单次请求的信息，而 ServletContext 则提供了整个应用级别的共享环境。通过这些对象，开发者可以在不同的层次上管理和共享数据，以满足应用程序的需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d03afe5cf52b5f5a682696b5af0e7d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab0f1d6b4d1253a82f406fac691b9636/" rel="bookmark">
			Python高级用法：有序字典（OrderedDict）与不可变集合（frozenset）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有序字典（OrderedDict） Python标准库的collections模块提供了名为OrderedDict的有序字典。它选择性地接受一个可迭代对象作为初始化参数：
from collections import OrderedDict OrderedDict((str(number), None) for number in range(5)).keys() OrderedDict还有一些其他功能，例如利用popitem()方法在双端取出元素或者利用move _ to _ end()方法将指定元素移动到某一端。
popitem(last=True)的作用是有序字典返回并删除键值对。如果 last 为 true，则按 LIFO 顺序返回。如果为 false，则为 FIFO 顺序。
move_to_end(key, last=True)将现有键移动到有序字典的任一端。如果last为true（默认值），则移动到右端。当last为false时移动到最左侧。
用法如下：
from collections import OrderedDict d = OrderedDict.fromkeys('abcde') d.move_to_end('b') ''.join(d) d.move_to_end('b', last=False) ''.join(d) 运行效果如下
不可变集合（frozenset） 不可变集合是指一旦创建内容就不再发生变化的集合，他是一种不可变的、可哈希的、无序的集合，其元素是唯一的、不可变的（可哈希的）对象。
由于frozenset()具有不变性，它可以用作字典的键，也可以作为其他set()和frozenset()的元素。在一个set()或frozenset()中不能包含另一个普通的可变set()
正确用法如下：
set([frozenset([1,2,3]), frozenset([2,3,4])]) frozenset([frozenset([1,2,3]), frozenset([2,3,4])]) 但如果使用set对象作为set中的值，将会出错
效果如下
set([set([1,2,3]), set([2,3,4])]) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/befcf5d74fe3866999c84a514250d1fb/" rel="bookmark">
			Python圣诞树代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python圣诞树代码 # 小黄 2023/12/25 import turtle as t # as就是取个别名，后续调用的t都是turtle from turtle import * import random as r n = 100.0 speed(20) # 定义速度 pensize(5) # 画笔宽度 screensize(800, 800, bg='black') # 定义背景颜色，可以自己换颜色 left(90) forward(250) # 开始的高度 color("orange", "yellow") # 定义最上端星星的颜色，外圈是orange，内部是yellow begin_fill() left(126) for i in range(5): # 画五角星 forward(n / 5) right(144) # 五角星的角度 forward(n / 5) left(72) # 继续换角度 end_fill() right(126) def drawlight(): # 定义画彩灯的方法 if r.randint(0, 50) == 0: # 如果觉得彩灯太多，可以把取值范围加大一些，对应的灯就会少一些 color('tomato') # 定义第一种颜色 circle(3) # 定义彩灯大小 elif r.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/befcf5d74fe3866999c84a514250d1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04cbb46951c2581054e6b8d4c28d9c3e/" rel="bookmark">
			业务中台-产品设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目进入产品设计阶段前，让我们深入探讨一下产品经理的能力、产品经理与项目经理的关系，以及产品经理之间的合作问题。这些议题在实际项目中经常遇到，值得我们仔细探讨。
1、首先，我们来谈谈产品经理的核心能力。
产品经理的两大关键能力是原型设计和PRD文档编写。这两种技能可以通过快速学习掌握，即使经验不足的同事也能在1-2周内迅速上手。然而，值得注意的是，仅仅拥有这两项技能并不足以保证产品的成功。业务能力同样重要，特别是在我们正在构建的业务中台项目中。业务中台的核心在于“业务”二字，如果产品经理缺乏业务能力，那么由他们负责的项目注定会失败。
有同学可能会认为，业务能力可以边做边学，但我们必须指出，我们的规划设计阶段只有两个月。用一个月的时间来学习，然后试图在一个月内赶上原定的进度是不现实的。那么，具体需要哪些业务能力呢？
我所在的行业是零售业，这个行业最常提到的三个关键词是人、货、场。因此，零售行业的产品经理至少需要具备将人、货、场的业务流程进行串联的能力。
2、接下来，我们来谈谈产品经理与项目经理之间的关系。
许多公司都存在项目经理和产品经理互不相让的情况，但在我们的项目中，这种情况基本不存在。原因如下：
2.1、业务中台项目是公司的战略级项目，组织目标高度一致；
2.2、在我们的公司中，产品经理驱动项目，而项目经理主要负责进度和协调，职责明确；
2.3、在规划阶段，项目的整体计划已经有了大致的轮廓，因此项目经理和产品经理只需按步执行即可；
2.4、项目经理和产品经理由项目总监统一管理，项目总监对两者的KPI负责。
3、此外，产品经理之间的合作也是我们需要关注的问题。
产品经理之间存在矛盾是不可避免的，关键在于我们如何在项目过程中处理这些矛盾。我们采取了以下措施来解决这些问题：
3.1、明确各产品经理的职责和负责的领域；
3.2、建立模块间的互操作性规则，即谁引用谁负责；
3.3、实施绩效管理措施，确保业绩与付出成正比。
在设计阶段，产品经理的工作内容主要包括业务调研、原型设计、原型确认和PRD文档输出。由于该项目，我们在前期规划中已经与各部门领导进行了深入的交流和调研，因此在设计阶段，我们的工作主要是通过原型与业务团队反复确认和优化方案，最后形成PRD文档。这种方式有点类似于IT驱动业务变革的过程。
此外，我们需要注意的是，PRD文档和原型确认并不需要所有用户参与，核心团队成员的意见更为重要。这些核心人员通常是岗位负责人，只有他们才能推动项目的后续实施。
在具体设计时，重点提下需关注以下事项：
1、功能逻辑要完整：无论是新增、修改、删除、批量删除、导入、导出等操作，都不能遗漏。单据类功能还需考虑作废和批量作废逻辑，与财务相关的功能要考虑到反审逻辑；
2、注重细节：在页面显示和查询上要抓住核心业务字段，避免今天加一个字段、明天再加一个的情况发生；
3、保持原型和PRD文档的风格和样式统一：我们项目中使用的工具有Axure（原型设计）、Ant Design（原型样式）、蓝湖（原型展示）和Axure-Team模式（原型共享），PRD文档则使用飞书进行编辑和协作。
以上是对设计阶段的一些个人见解和经验分享，希望对大家有所启发和帮助。
关键的输出物：1、产品原型、2、PRD文档、3、会议纪要、4、问题清单、5、PRD业务确认计划（业务的时间一定要提前确认）等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5372e8d2ebb456cbfa290def38b44ce4/" rel="bookmark">
			react 为什么要重构架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
重构架构是react16及16后的版本对15以前的版本的架构进行了重构，
React 15 的架构可以分为两层： Reconciler（协调器） 负责找出变化的组件，以及标识出如何更新。Renderer（渲染器） 负责将变化的组件渲染到页面上。 React 15 使用的是栈调和器，它是递归、同步的方式。这样的设计可以使组件更新简单、快速，有一些缺点，例如：
更新一旦开始，中途就无法中断，可能会造成浏览器渲染卡顿。无法实现异步、分片、优先级等高级功能。无法兼容新的浏览器特性，如 requestIdleCallback 和 requestAnimationFrame。 React 16 的架构可以分为三层： Scheduler（调度器），负责调度任务的优先级，高优任务优先进入Reconciler（协调器）。Reconciler 负责找出变化的组件，以及标识出如何更新。Renderer（渲染器）， 负责将变化的组件渲染到页面上。¹² React 16 使用的是全新的 Fiber 调和器，它是循环、异步、可中断的方式。这样的设计可以使组件更新更加灵活、高效带来了一些优点：
可以在浏览器每一帧的时间中，预留一些时间给 JS 线程，避免长时间占用主线程，造成卡顿。可以实现异步、分片、优先级等高级功能，如 Concurrent Mode（并发模式）、Suspense（悬停）、Lazy Loading（懒加载）等。可以兼容新的浏览器特性，如 requestIdleCallback 和 requestAnimationFrame。 总结 重构 React 的架构的主要原因是为了提高 UI 的渲染性能和用户体验，解决 CPU 和 I/O 的瓶颈，实现异步、可中断、可恢复、可优先级的更新流程，以及支持一些新的特性，如 Time Slice（时间分片）、Suspense（悬停）、Lazy Loading（懒加载）、Concurrent Mode（并发模式），所以react15递归、同步的更新执行是不支持的，重构就必须来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff6877f71b3fa8344f1ad3ad7b1875f/" rel="bookmark">
			Kubernetes使用ECK部署Elasticsearch和Kibana集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernetes使用ECK部署Elasticsearch和Kibana集群 原文链接：Kubernetes使用ECK部署Elasticsearch8.0和Kibana集群（k8s）_k8s elasticsearch 8-CSDN博客Elastic Cloud Kubernetes（ECK）安装Elasticsearch、Kibana实战教程Elastic Cloud Kubernetes（ECK）安装Elasticsearch、Kibana实战教程-阿里云开发者社区k8s使用ECK部署Elasticsearch和Kibana集群 一、安装ECK kubectl create -f https://download.elastic.co/downloads/eck/2.0.0/crds.yamlkubectl apply -f https://download.elastic.co/downloads/eck/2.0.0/operator.yamlwget https://download.elastic.co/downloads/eck/2.10.0/crds.yamlwget https://download.elastic.co/downloads/eck/2.10.0/operator.yamlkubectl create -f crds.yamlkubectl apply -f operator.yaml搞错了，就删除重新搞kubectl delete -f crds.yamlkubectl delete -f operator.yaml执行完成使用下面命令看容器运行成功就安装好了kubectl -n elastic-system logs -f statefulset.apps/elastic-operator 二、部署Elasticsearch集群 安装出现异常，内存不够，也没有绑定PVC,加内存，加CPU，绑定PVC Warning FailedScheduling 14s default-scheduler 0/3 nodes are available: pod has unbound immediate PersistentVolumeClaims. preemption: 0/3 nodes are available: 3 Preemption is not helpful for scheduling..Warning FailedScheduling 12s default-scheduler 0/3 nodes are available: 1 node(s) had untolerated taint {node-role.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff6877f71b3fa8344f1ad3ad7b1875f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ea887e14f3738d2d0eea874ba713900/" rel="bookmark">
			JavaScript中等待两个ajax异步请求完成解决方式记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript中等待两个Ajax异步请求完成的一种常见方法是使用Promise.all()方法。你可以将两个Ajax异步请求封装成 Promise对象，并将它们放入一个数组中，然后使用Promise.all()来等待它们都完成。
function request(url) { return new Promise((resolve, reject) =&gt; { $.ajax({ type: 'GET', url: url, dataType: "json", data: data, success: function (res) { if (res.status === 200) { resolve(xhr.response); } else { reject(new Error(xhr.statusText)); } }, error: function (res) { reject(new Error(res)); } }); }); } // 第一个异步请求 const request1 = request('url1'); // 第二个异步请求 const request2 = request('url2'); // 使用Promise.all()等待两个异步请求完成 Promise.all([request1, request2]) .then(results =&gt; { // 两个异步请求都完成了 const result1 = results[0]; // 第一个请求的结果 const result2 = results[1]; // 第二个请求的结果 // 处理结果 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ea887e14f3738d2d0eea874ba713900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d42ed77cbee3b5743ca383436264eab/" rel="bookmark">
			http工具类：调用http接口时绕过SSL证书验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、场景二、X509TrustManager三、HttpUtil 一、场景 对接第三方接口时，由于SSL证书验证导致接口对接失败
解决方法：调用接口时绕过SSL
二、X509TrustManager import javax.net.ssl.X509TrustManager; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; /** * 证书信任管理器（用于https请求） * author:vincente 2013-11-5 */ //这个证书管理器的作用就是让它信任我们指定的证书，上面的代码意味着信任所有证书，不管是否权威机构颁发。 public class MyX509TrustManager implements X509TrustManager { @Override public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { } @Override public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { } @Override public X509Certificate[] getAcceptedIssuers() { return null; } } 三、HttpUtil import com.alibaba.fastjson.JSONObject; import com.xxx.config.MyX509TrustManager; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.io.*; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d42ed77cbee3b5743ca383436264eab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0bed67df283a7303d8d711d4545130d/" rel="bookmark">
			SuperMap iDesktopX 利用“渔网”制作马赛克地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：gsh 目录
前言
1. 创建网格
2.导出行政区范围内的标注点
3.符号化制图
前言 GIS中常使用类似于“渔网”效果将地图区域划分为规则的网格，进行空间分析和可视化展示。这些网格可以用于许多用途，例如：采样、统计、制图等等。今天小编来带大家使用SuperMap iDesktopX利用“渔网”制作马赛克地图。
1. 创建网格 数据：本实例使用的是世界行政区图。
将数据加载到地图窗口，激活地图相关菜单栏。功能入口：地图—制图—地图网格。地图网格功能参数说明：
格网类型：设置格网类型为经纬网或公里网。
坐标系：若格网类型为公里网，可设置公里网的坐标系为投影坐标系；若格网类型为经纬网，则格网默认为地图的地理坐标系，不支持修改。
横向间隔：用于调整两个相邻的横向网格线之间的距离。当网格类型为经纬网时，间隔的单位为度；当网格类型为公里网时，间隔的单位为米。
纵向间隔：用于调整两个相邻的纵向网格线之间的距离。当网格类型为经纬网时，间隔的单位为度；当网格类型为公里网时，间隔的单位为米。
行数/列数：可根据设置的横向/纵向间隔，动态计算得出的格网的行数和列数，修改行列数后，格网间隔也会动态改变。
光滑系数：默认为2，范围[1,5]，光滑系数为1则不进行光滑处理，不插入点，则只有单元格两个端点。
数据类型：支持输出的数据类型：点数据集、线数据集、面数据集和CAD数据集。
标注格网：在主分割线处显示标注 ，同时可单机AaBb按钮，在“文本风格设置”对话框中，设置文本相关的属性。
显示主分割线：在每条纵横交错的格网线与地图外框交点处，显示分割线。
（注：制作地图格网的时，会根据横向和纵向间隔生成地图格网，随着地图范围的变化，格网的间隔保持不变，行列数会随范围的变化而变化变，建议在确定布局中的地图显示范围后，再生成地图格网。）
本示例的数据采用的是世界行政区，长宽比为2：1，因此为了提取比较均匀的网格信息，保留长宽比例进行设置。制作马赛克地图需要点数据，数据类型选择点数据集。
输出的网格点数据集：
2.导出行政区范围内的标注点 使用空间查询，查询出世界行政区内的点。功能入口：空间分析—空间查询。
查询结果：
3.符号化制图 点击图层管理器中的点数据集右键风格设置，选择一个好看的点符号。在空白处右键属性，选择一个喜欢的背景，一副好看的马赛克地图就完成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/856f99b169665d42f281b6fcc61e344b/" rel="bookmark">
			基于51单片机的里程计价器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、摘要 随着城市交通的日益拥堵，出租车作为城市公共交通的重要组成部分，其服务质量和效率受到了广泛关注。为了提高出租车行业的管理水平，降低运营成本，本文设计了一种基于单片机的出租车里程计价器。该计价器采用高精度传感器采集车辆行驶速度和里程信息，通过单片机进行处理和计算，实现自动计费功能。同时，计价器具有实时显示车速、里程、费用等信息的功能，方便乘客和驾驶员了解行车情况。通过实际测试，该计价器具有较高的精度和稳定性，能够满足出租车行业的使用需求。
二、引言 出租车作为城市公共交通的重要组成部分，其服务质量和效率对于缓解城市交通压力具有重要意义。传统的出租车计价器主要依靠人工操作，存在计费不准确、管理不便等问题。为了解决这些问题，本文设计了一种基于单片机的出租车里程计价器。该计价器采用高精度传感器采集车辆行驶速度和里程信息，通过单片机进行处理和计算，实现自动计费功能。同时，计价器具有实时显示车速、里程、费用等信息的功能，方便乘客和驾驶员了解行车情况。
三、系统设计 1. 硬件设计
本计价器主要由以下部分组成：单片机控制模块、传感器模块、显示模块和通信模块。
（1）单片机控制模块：采用高性能单片机作为核心处理器，负责处理传感器采集的数据，实现计费算法，并控制显示模块和通信模块的工作。
（2）传感器模块：包括速度传感器和里程传感器，用于采集车辆行驶速度和里程信息。
（3）显示模块：采用液晶显示屏，实时显示车速、里程、费用等信息。
（4）通信模块：采用无线通信技术，将计价器的计费数据发送到后台管理系统，实现远程监控和管理。
2. 软件设计
本计价器的软件主要包括数据采集、数据处理、计费算法和显示控制等模块。
（1）数据采集模块：负责读取传感器采集的速度和里程数据。
（2）数据处理模块：对采集到的数据进行滤波、校准等处理，提高数据的准确性。
（3）计费算法模块：根据处理后的数据，实现自动计费功能。计费算法需要考虑不同时段、不同距离的费率调整等因素。
（4）显示控制模块：负责控制液晶显示屏的显示内容和格式。
四、系统测试与分析 为了验证本计价器的性能和可靠性，我们进行了实际道路测试。测试结果表明，该计价器具有较高的精度和稳定性，能够满足出租车行业的使用需求。同时，计价器的实时显示功能有助于提高乘客和驾驶员的行车体验。
#include &lt;reg52.h&gt; #include &lt;intrins.h&gt; typedef unsigned char uchar; typedef unsigned int uint; sbit Trig = P2^0; // 超声波模块触发引脚 sbit Echo = P2^1; // 超声波模块回声引脚 sbit Beep = P1^5; // 蜂鸣器引脚 sbit LED = P1^6; // LED灯引脚 uchar distance; // 存储测得的距离 void delay(uint z) { uint x, y; for (x = z; x &gt; 0; x--) for (y = 110; y &gt; 0; y--); } void UART_Init() { SCON = 0x50; // 设置串口工作方式1 TMOD = 0x20; // 设置定时器1工作方式2 TH1 = 0xFD; // 设置波特率为9600 TL1 = 0xFD; TR1 = 1; // 启动定时器1 ES = 1; // 开启串口中断 EA = 1; // 开启总中断 } void UART_SendByte(uchar dat) { SBUF = dat; while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/856f99b169665d42f281b6fcc61e344b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2987c6f681fd368fa0be90c982791a5/" rel="bookmark">
			uniapp：实现手机端APP登录强制更新，从本地服务器下载新的apk更新,并使用WebSocket，实时强制在线用户更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现登录即更新，或实时监听更新
本文介绍的是在App打开启动的时候调用更新，点击下方链接，查看使用WebSocket实现实时通知在线用户更新。
uniapp：全局消息是推送，实现app在线更新，WebSocket，apk上传:
登录更新流程 1.在app每次启动的时候请求java后端,2.后端接口获取最新的版本：3.打开更新页面4.后端下载接口去指定目录下载apk 背景：内部手持机app开发功能，需要更新的到车间各个手持机上。最初的方案：开发人员开发完后，去现成给每台手持机安装更新设想：实现在线发布，手持机检测版本后更新。 实现手持机更新
1.发布到应用商店
2.uiniapp自带版本更新
3.自己开发功能，检测需要更新后从自己的服务器上下载下来更新
这里我们选择自己开发，毕竟不需要证书，和依托于其他平台
app更新更新我们需要解决哪些问题？
1app什么时候知道自己需要更新？
2检测到需要更新后从哪里获取文件？
3如果app一直在线运行，如何实时通知它需要更新？
下面我们逐一解决：
1app什么时候知道自己需要更新？
这里我们使用的是在app每次打开的时候去请求我们后台的接口，拿到最新的app版本（自己定义的），和当前app的版本进行比较。
前提是，你在自己的服务器上上传了apk之后并且记录了在自己的业务表里面。这样你才能比较是否需要更新。（意思就是最好你维护一张表，每次上传插入一条记录）
实现：
1.在app每次启动的时候请求java后端, 因此要卸载App.vue里面
&lt;script&gt; function requestToJavaBackend() { uni.request({ url: 'http://*.*.*.*:8080/app/getNewestVersion', // 替换成你的后端 Java 服务的API地址 method: 'GET', // 或 'POST'，根据你的需求选择请求方法 success: (res) =&gt; { if(res.data.code === 200){ console.log(res.data.data); console.log(); console.log(uni.getSystemInfoSync().appVersion+"111111111"); console.log(); console.log(uni.getSystemInfoSync().appVersionCode+"222222"); console.log(platform+"33333333333333333333") const newVersionName = res.data.data.newVersionName //线上最新版本名 const newVersionCode = res.data.data.newVersionCode; //线上最新版本号 // const selfVersionCode = Number(uni.getSystemInfoSync().appVersion) //当前App版本号 const selfVersionCode = Number(uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2987c6f681fd368fa0be90c982791a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb98f34c7a834dc370d9332d6fe5d7b/" rel="bookmark">
			2942. 查找包含给定字符的单词 23.12.23（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个下标从 0 开始的字符串数组 words 和一个字符 x 。
请你返回一个 下标数组 ，表示下标在数组中对应的单词包含字符 x 。
注意 ，返回的数组可以是 任意 顺序。
示例 1：
输入：words = ["leet","code"], x = "e" 输出：[0,1] 解释："e" 在两个单词中都出现了："leet" 和 "code" 。所以我们返回下标 0 和 1 。 示例 2：
输入：words = ["abc","bcd","aaaa","cbc"], x = "a" 输出：[0,2] 解释："a" 在 "abc" 和 "aaaa" 中出现了，所以我们返回下标 0 和 2 。 示例 3：
输入：words = ["abc","bcd","aaaa","cbc"], x = "z" 输出：[] 解释："z" 没有在任何单词中出现。所以我们返回空数组。 提示：
1 &lt;= words.length &lt;= 501 &lt;= words[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fb98f34c7a834dc370d9332d6fe5d7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2c829d4c7cddfab8593380b8382de0e/" rel="bookmark">
			K8s实战-init容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念： 初始化容器的概念 比如一个容器A依赖其他容器，可以为A设置多个 依赖容易A1，A2，A3
A1,A2,A3要按照顺序启动，A1没有启动启动起来的 话，A2,A3是不会启动的，直到所有的静态容器全 部启动完毕，主容器A才会启动。
一般用于A容器运行之前，先做一些准备工作。
如果初始化容器失败，则会一直重启，pod不会创建
实战： yaml1
apiVersion: v1 kind: Pod metadata: name: init-pod labels: app: init-pod spec: containers: - name: init-pod image: busybox command: ['sh', '-c', 'echo The app is running! &amp;&amp; sleep 3600'] volumeMounts: - mountPath: /xx name: workdir initContainers: - name: init-mkdir image: busybox command: ['sh', '-c', "touch /work-dir/1112233"] volumeMounts: - mountPath: /work-dir name: workdir volumes: - name: workdir emptyDir: {} 容器成功启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2c829d4c7cddfab8593380b8382de0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44a3082af5520d6768d0cc2262c3e163/" rel="bookmark">
			百度CTO王海峰：文心一言用户规模破1亿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“文心一言用户规模突破1亿。” 12月28日，百度首席技术官、深度学习技术及应用国家工程研究中心主任王海峰在第十届WAVE SUMMIT深度学习开发者大会上宣布。会上，王海峰以《文心加飞桨，翩然赴星河》为题作了主旨演讲，分享了飞桨和文心的最新成果。
**飞桨开发者已达1070万** WAVE SUMMIT深度学习开发者大会始于2019年4月，每年两次与开发者相聚，如今已是五载十届。
回顾五年，大会一路见证了百度对人工智能技术和产业趋势的前瞻判断，指引了技术创新和产业实践的方向。 2019年王海峰在首届大会上提出，深度学习框架是智能时代的操作系统。深度学习的通用性特点，以及深度学习框架及平台的发展，推动人工智能标准化、自动化和模块化，进入工业大生产阶段。2020年，王海峰提出了打造AI新型基础设施，云智一体加速产业智能化，将AI大生产平台升级为云智一体的新型基础设施，为产业智能化奠定坚实的基础。2021年，王海峰表示，人工智能呈现出“融合创新”和“降低门槛”的特点：一方面，AI技术及产业的融合创新越来越多；另一方面，虽然AI技术越来越复杂，但AI开发与应用的门槛却越来越低。2022年，王海峰进一步提出，深度学习平台加上大模型，贯通了从硬件适配、模型训练、推理部署，到场景应用的AI全产业链，夯实了产业智能化基座。今年，大语言模型的出现，为通用人工智能带来曙光。
五年来，在持续技术创新和赋能产业的发展历程中，飞桨自身也在不断升级，从深度学习框架，到平台生态，发展成为技术领先、功能丰富的产业级深度学习开源开放平台。飞桨集核心框架、基础模型库、开发套件、工具组件，以及助力开发者成长的星河社区于一体，具有动静统一的深度学习框架、端到端自适应大规模分布式训练、云边端全场景高性能推理等关键核心技术。
飞桨生态愈加繁荣，2019年，凝聚在飞桨平台的开发者规模150万，到今年8月的Wave Summit，已经达到800万，服务的企业数量、基于飞桨创建的模型数量，也都高速增长。王海峰现场公布了飞桨生态最新成果，截至2023年12月底，飞桨已凝聚1070万开发者，服务23.5万家企事业单位，基于飞桨创建了86万个模型。
文心一言用户规模破亿，日提问量快速增长 据了解，百度自2019年起深耕预训练模型研发，发布了文心大模型1.0。经过近四年积累，百度于今年3月在全球科技大厂中率先发布了知识增强大语言模型文心一言。10月，文心一言的基础模型升级到4.0，理解、生成、逻辑和记忆四大人工智能基础能力全面提升。文心大模型4.0过去两个多月整体效果又提升了32%。
王海峰现场披露，文心一言用户规模已突破1亿，自8月31日获准开放对公众提供服务以来，文心一言的用户提问量一路上扬，基本与文心大模型的效果提升同步。越来越多的用户在信任和使用文心一言。
王海峰最后表示：“五载十届，我们与所有开发者一起，踔厉奋发，笃行不怠。愿继续与所有开发者携手并肩，在飞桨和文心的支持下，共赴通用人工智能的星辰大海！”
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/6/">«</a>
	<span class="pagination__item pagination__item--current">7/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/8/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>