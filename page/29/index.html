<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b849ab606472cfcd98b012d088ad2267/" rel="bookmark">
			springboot&#43;vue项目如何在linux上部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux上部署项目，是我们实训项目作业的最后一步，此时我们的项目编码测试已经完成，接下来就需要在服务器上部署上线，那么如何部署上线，接下来我会在虚拟机上的CentOS7系统上实现部署，
一.下载JDK
因为我们的是java项目，所以首先需要确保服务器又java运行环境，也就是jdk，我们是CentOs系统，所以可以通过命令 yum install -y java-1.8.0-openjdk 完成安装，
然后在执行命令 java -version 检查是否安装，显示版本号则成功。
使用命令安装jdk系统会自动设置环境变量，不需要手动配置，如果是通过解压得到jdk的则需要自己配置环境变量，这里不介绍了。
二. 下载mysql
1.使用命令 sudo yum install mysql-server 安装mysql
2.安装完成后，启动 mysql 并设置它在系统启动时自动启动，两条命令分开执行
sudo systemctl start mysqld
sudo systemctl enable mysqld 3.设置密码，这是设置root用户进入mysql的密码，也可以修改为其他用户组的密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH caching_sha2_password BY 'xxx';
xxx为要设置的密码
4.进入mysql，然后输入上一条定义的密码
mysql -u root -p
5.如果显示下图信息，则表示进入mysql，也表示安装成功。
6.还需要创建自己项目对应的数据库和表，这里也不详细叙述
三.打包部署后端项目。
1.在pom.xml中加入
&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${spring-boot.version}&lt;/version&gt; &lt;configuration&gt; &lt;-- 启动类所在路径 --&gt; &lt;mainClass&gt;com.fyt.SpringbootPro1Application&lt;/mainClass&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;repackage&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 如果是父子模块的项目则 添加下面这个
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b849ab606472cfcd98b012d088ad2267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e30ccb3d5a0045b8a21ada222dc51b41/" rel="bookmark">
			微机原理与接口技术——串行通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、串行通信方式分类二、异步串行通信帧格式及通信速率帧数据通信速率例子 串行通信接口标准：RS-232C 三、8250编程1、8250的初始化编程2、8250的应用编程 一、串行通信方式分类 按照数据传送方向以及其特点:
单工通信：只允许数据按照一个固定的方向传送半双工通信：数据不能同时在两个方向传送全双工通信：收发双方可同时进行数据传送 二、异步串行通信帧格式及通信速率 帧数据 通信速率 数据信号速率，又称波特率，表示每秒传送0、1代码个数（包含起始位、校验位、停止位），单位为波特。
例子 设串行异步通信一帧字符有7个数据位，奇校验，2个停止位，波特率为19200bps，则每秒能传输最大字符数是多少？
答案;1745
串行通信接口标准：RS-232C RS-232C采用负逻辑，标准规定：
逻辑“1”信号，电平在-3V~-15V之间
逻辑“0”信号，电平在+3V~+15V之间
三、8250编程 1、8250的初始化编程 初始化编程的格式相对固定，只需要在其中几个地方改动即可。
格式;
MOV DX,3FBH MOV AL,80H OUT DX,AL ；分频系数 MOV DX,3F9H MOV AL,____ ；高八位 OUT DX,AL MOV DX,3F8H MOV AL,____ ；低八位 OUT DX,AL ；帧格式 MOV DX,3FBH MOV AL,____ OUT DX,AL ；设置中断允许寄存器只看看D0：接收 D1：发送 MOV DX,3F9H MOV AL,____ OUT DX,AL ；设置MODEM控制寄存器，只看D3D4 ；D3——中断是1，查询时0 ；D4——内环时1，反之是0 MOV DX,3FCH MOV AL,____ OUT DX,AL 2、8250的应用编程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d3b749e7939c4a6d418a67bf8d7fa5/" rel="bookmark">
			ansible-playbook实操之一键搭建lnmp&#43;wordpress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、架构和准备：
2、配置nginx角色：
3、配置mariadb角色：
4、配置php角色：
5、配置完之后，写脚本调用roles
6、配置完之后浏览器搭建wordpress：
1、架构和准备： 操控节点：20.0.0.22 ansible
搭建节点：20.0.0.61
关闭防火墙和安全机制
在主节点ansible中配置roles
cd /etc/ansible/roles mkdir nginx mariadb php mkdir nginx/tasks mkdir mariadb/tasks mkdir php/tasks 2、配置nginx角色： cd /etc/ansible/roles/nginx/tasks vim main.yml - name: install nginx yum: name: nginx #下载nginx - name: copy nginx file copy: src: /opt/nginx.conf dest: /etc/nginx/ #将配置好的nginx.从文件copy到目标节点 - name: Download WordPress get_url: url: https://wordpress.org/latest.tar.gz dest: /opt/latest.tar.gz - name: Extract WordPress command: "tar -xf /opt/latest.tar.gz -C /usr/share/nginx/html/" - name: Set permissions for WordPress command: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25d3b749e7939c4a6d418a67bf8d7fa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b363719f32bf9025c934343a048ac267/" rel="bookmark">
			js Array方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Array（数组，引用数据类型）： js数组是可以自动调节大小的，一个数组中可以包含不同的数据类型。js数组必须用非负整数作为索引访问，不能使用字符串作索引，数组索引是从0开始。并要求使用 "[ ]" 来访问。js数组复制操作时浅拷贝，即复制数组地址的引用。（js对象的复制都是浅拷贝） 注意：在复制数组时要判断是否要修改数组元素，如果要修改数组元素的话，最好是使用数组深拷贝处理，复制数组的原始值。
Array方法： (1)不会修改原有数组 concat()：用于连接两个或者多个数组。 var arr1 = [1,2] var arr2 = [3,4] var arrConcat = arr1.concat(arr2);// [ 1, 2, 3, 4 ] var arr2Concat = arr2.concat(arr1);// [ 3, 4, 1, 2 ] join()：返回一个字符串，join方法会把所有数组元素使用 join() 传入的字符连接起来。 var arr = [1, 2, 3, 4, 5]; console.log(arr.join('*'));// 1*2*3*4*5 filter()：过滤出符合要求的元素，返回所有符合要求的所有元素数组。 var arr = [1,2,3,4]; var arrfilter = arr.filter((element)=&gt;{ return element &gt; 2; }) console.log(arrfilter);// [ 3, 4 ] slice()：输入start(开始位置)和end(结束位置)，返回这两个位置之间的元素数组。 如果只有一个参数，就返回这个位置之后的所有元素数组。如果参数为负数，表示从最后一个位置，向前多少个位置。 const animals = ['ant', 'bison', 'camel', 'duck', 'elephant']; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b363719f32bf9025c934343a048ac267/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe7c4dd0bcc9f1f0e4f30f915e91d43b/" rel="bookmark">
			NodeJs导出xlsx，行列合并，内容居中，字体颜色，字体加粗，字体大小，批量任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（要学会游泳，就必须下水。——列宁） Nodejs Xlsx 这次我们将演示如何使用NodeJs将一组数据使用以下样式导出
行列合并内容居中字体颜色字体加粗字体大小 导出结果 示例代码 const _ = require('lodash'); const bluebird = require('bluebird'); const xlsx_style = require('xlsx-style'); const fs = require('fs'); // 目标：对相同活动编号的行进行合并 // 如果活动编号相同，则合并行，包括活动名称。并且其子集数据中的城市和名称也要进行合并 // 并对北京地区进行标红 // 模拟数据库已存储的数据 const list = [ { campaignNumber: '1', campaignTitle: '足球', child: [ { city: '河南', name: '河南1' }, { city: '河南', name: '河南2' }, { city: '河北', name: '河北1' } ] }, { campaignNumber: '2', campaignTitle: '篮球', child: [ { city: '北京', name: '北京1' }, { city: '北京', name: '北京2' }, { city: '湖南', name: '湖南1' }, { city: '湖南', name: '湖南2' } ] }, { campaignNumber: '3', campaignTitle: '乒乓球', child: [ { city: '安徽', name: '安徽1' }, { city: '安徽', name: '安徽2' }, { city: '浙江', name: '浙江1' }, { city: '上海', name: '上海1' } ] } ]; // 定义分组数组 const groupList = []; // 将活动编号相同的行进行分开存储 for (const item of list) { for (const childItem of item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe7c4dd0bcc9f1f0e4f30f915e91d43b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccddd090a24b05e210311f7bd91923cb/" rel="bookmark">
			VSCode快捷键大全：提升编程效率的利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 Visual Studio Code是一款强大的代码编辑器，它提供了许多实用的快捷键，可以帮助我们更快地完成编程任务。通过使用这些快捷键，我们可以快速地导航、编辑和调试代码，提高编程效率。本文将详细介绍VSCode中常用的快捷键，帮助开发者更好地利用这款工具。
常用快捷键 导航快捷键 Ctrl + P：快速打开文件Ctrl + G：跳转到行号Ctrl + T：打开快速文件搜索Ctrl + Shift + T：打开最近关闭的文件Ctrl + W：关闭当前所在文件Ctrl + K + W：关闭所有打开文件 编辑快捷键 Ctrl + X：剪切当前行或选中文本Ctrl + C：复制当前行或选中文本Ctrl + V：粘贴文本Ctrl + Shift + V：粘贴纯文本，不保留格式Ctrl + /：设置/取消行注释Alt + Shift + A：设置/取消块注释Ctrl + Shift + Enter：在当前行上方插入新行Alt + Shift + Up/Down：上下移动选中文本Ctrl + K Ctrl + C：注释当前行或选中文本Ctrl + K Ctrl + U：取消注释当前行或选中文本 查找和替换快捷键 Ctrl + F：在当前文件中查找文本Ctrl + H：打开查找和替换面板Ctrl + Shift + F：在多个文件中查找文本 调试快捷键 F5：开始调试会话F10：跳过当前方法或函数F11：进入当前方法或函数内部调试Alt + F5：停止调试会话并清除断点 其他常用快捷键 Ctrl + Z：撤销操作Ctrl + Y：恢复操作Ctrl + Shift + K：删除当前行或选中文本F2：重命名当前文件F12：打开文件所在文件夹Ctrl + K + 0：收起所有代码Ctrl + K + J：展开所有代码Ctrl + B：收起/展开侧边栏Ctrl + J：收起/展开控制台 汇总 Ctrl+Shift+P，F1：显示命令面板
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccddd090a24b05e210311f7bd91923cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25957467c723f99885ae6d2b563b19f5/" rel="bookmark">
			软件测试基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件的生命周期软件开发瀑布模型螺旋模型增量、迭代敏捷 软件测试生命周期软件测试V模型软件测试W模型 软件的生命周期 软件生命周期是指从软件产品的设想开始到软件不再使用而结束的时间。 如果把软件看成是有生命的事物，那么软件的生命周期可以分成6个阶段，即需求分析、计划、设计、编码、测试、运行维护。
需求分析：需求是否合理，需求是否完整；
计划：项目由谁开发、由谁测试、什么时候开发结束、什么时候测试结束、什么时候项目上线。
设计：开发人员设计项目底层如何实现，输出一个技术文档；测试人员设计测试用例
编码：开发人员开发软件，测试人员设计测试工具，测试用例
测试：执行测试，提交BUG，验收BUG
运行维护：将项目推到线上环境，如果发现线上BUG，此时需要进行修复，重新上线。
软件开发 瀑布模型 瀑布模型在软件工程中占有重要地位，是所有其他模型的基础框架。瀑布模型的每一个阶段都只执行一次，因此是线性顺序进行的软件开发模式
优点： 强调开发的阶段性； 强调早期计划及需求调查； 强调产品测试。
缺点： 依赖于早期进行的唯一一次需求调查，不能适应需求的变化； 由于是单一流程，开发中的经验教训不能反馈应用于本产品的过程； 风险往往迟至后期的测试阶段才显露，因而失去及早纠正的机会。
螺旋模型 一般在软件开发初期阶段需求不是很明确时，采用渐进式的开发模式。螺旋模型是渐进式开发模型的代表之一。这对于那些规模庞大、复杂度高、风险大的项目尤其适合。这种迭代开发的模式给软件测试带来了新的
要求，它不允许有一段独立的测试时间和阶段，测试必须跟随开发的迭代而迭代。
优点： 强调严格的全过程风险管理。 强调各开发阶段的质量。 提供机会检讨项目是否有价值继续下去。
缺点： 引入非常严格的风险识别、风险分析和风险控制，这对风险管理的技能水平提出了很高的要求。这需要人员、资金和时间的投入。
增量、迭代 增量开发模型，鼓励用户反馈，在每个迭代过程中，促使开发小组以一种循环的、可预测的方式驱动产品的开发。因此，在这种开发模式下，每一次的迭代都意味着可能有需求的更改、构建出新的可执行软件版本，意味着测试需要频繁进行，测试人员需要与开发人员更加紧密地协作。增量是逐块建造的概念，例如画一幅人物画，我们可以先画人的头部，再画身体，再画手脚……而迭代是反复求精的概念，同样是画人物画，我们可以采用先画整体轮廓，再勾勒出基本雏形，再细化、着色。
敏捷 个体与交互重于过程和工具；
可用的软件重于完备的文档；
客户协作重于合同谈判；
响应变化重于遵循计划；
在每对比对中，后者并非全无价值，但我们更看重前者。
敏捷开发有很多种方式，其中scrum是比较流行的一种：
scrum由product owner(产品经理)、scrum master(项目经理)和team(研发团队)组成。
产品经理负责整理user story(用户故事)，定义其商业价值，对其进行排序，制定发布计划，对产品负责。
项目经理负责召开各种会议，协调项目，为研发团队服务。
研发团队则由不同技能的成员组成，通过紧密协同，完成每一次迭代的目标，交付产品。
与瀑布不同，scrum将产品的开发分解为若干个小sprint(迭代)，其周期从1周到4周不等，但不会超过4周。参与的团队成员一般是5到9人。每期迭代要完成的user story是固定的。每次迭代会产生一定的交付。
scrum的基本流程：
产品负责人负责整理user story ——&gt;发布计划会议——&gt;迭代计划会议——&gt;每日例会——&gt;演示会议——&gt;回顾会议
软件测试生命周期 需求阶段 ：测试人员了解需求、对需求进行分解，得出测试需求 ；
计划阶段：根据需求编写测试计划/测试方案；
设计阶段：测试人员适当的了解设计，对于设计测试用例是很有帮助的，测试人员搭建测试用例框架，根据需求和设计编写一部分测试用例；
编码阶段：测试人员一般是不需要编码的，但已经编码的模块，专业的白盒测试人员可以计划执行单元测试，完善、细化测试用例以及调整测试计划和方案。
测试阶段：测试阶段是软件测试人员最为重要的工作阶段，根据测试用例和计划执行测试，在执行的过程中记录、管理缺陷，测试完成后编写测试报告。
运行维护：测试人员需要参与项目的实施工作。测试人员对项目产品的业务和操作非常了解，加上测试人员的沟通表达能力一般都比较强，所以测试人员可以参与用户使用软件的培训，在试运行项目时收集问题并及时反馈给相关负责人。
软件测试V模型 V模型目的是改进软件开发的效率和效果，是瀑布模型的变种：
明确的标注了测试过程中存在的不同类型的测试，并且清楚的描述了这些测试阶段和开发过程期间各阶段的对应关系。
V模型指出，单元和集成测试应检测程序的执行是否满足软件设计的要求；系统测试应检测系统功能、性能的质量特性是否达到系统要求的指标；验收测试确定软件的实现是否满足用户需要或合同的要求。
局限性:仅仅把测试作为在编码之后的一个阶段，未在需求阶段就进入测试
软件测试W模型 W模型增加了软件各开发阶段中应同步进行的验证和确认活动。W模型由两个V字型模型组成，分别代表测试与开发过程，图中明确表示出了测试与开发的并行关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25957467c723f99885ae6d2b563b19f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4e11337334964eabaf437d0468baba/" rel="bookmark">
			使用Maven Archetype插件制作项目脚手架(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Archetype是一个Maven项目模板工具包。通过Archetype我们可以快速搭建Maven项目。比如我们在ide里面创建项目时，可以选择很多maven内置的Archetype，我们最常用的可能是maven-archetype-quickstart
当然maven提供了能力，让我们自定义项目结构，比如下图如果我们想要基于Archetype来自动生成下面多模块结构的脚手架，我们可以先手动建立下面的代码结构
然后把下面插件加入到上面项目主pom中：
&lt;build&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-archetype-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 然后在该项目的根目录下执行如下命令，来生成Archetype的模板：
mvn archetype:create-from-project 执行完毕后，在\target\generated-sources\archetype目录下会生成内容如下，该内容就是Archetype模板：
在该目录下执行mvn install把模板安装到本地仓库，然后就可以执行下面命令来生成自己应用的项目结构了：
mvn archetype:generate -DarchetypeGroupId=com.jiaduo -DarchetypeArtifactId=project-template-archetype -DarchetypeVersion=1.0-SNAPSHOT -DarchetypeCatalog=local -DgroupId=com.jiaduo -DartifactId=order -Dversion=1.0-SNAPSHOT -DinteractiveMode=false 生成后的项目结构如下：
当然如果你想要使用代码的调用方式，可参考如下：
public class Main { public static void main(String[] args) { String DgroupId ="com.jiaduo"; String DartifactId ="Order"; String Dversion ="1.0-SNAPSHOT"; String targetDir ="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af4e11337334964eabaf437d0468baba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819081115425e24a1b78addfe67bc018/" rel="bookmark">
			电子电器架构刷写方案——General Flash Bootloader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电子电器架构刷写方案——General Flash Bootloader 我是穿拖鞋的汉子，魔都中坚持长期主义的汽车电子工程师。 注：文章1万字左右，深度思考者入！！！
老规矩，分享一段喜欢的文字，避免自己成为高知识低文化的工程师： 屏蔽力是信息过载时代一个人的特殊竞争力，任何消耗你的人和事，多看一眼都是你的不对。非必要不费力证明自己，无利益不试图说服别人，是精神上的节能减排。
无人问津也好,技不如人也罢,你都要试着安静下来,去做自己该做的事.而不是让内心的烦躁、焦虑、毁掉你本就不多的热情和定力。
文章大体有如下内容： 1、简介 2、刷写系统概述 3、Flash Bootloader刷写流程 4、Flash Bootloader架构介绍 5、关于刷写的思考 正文如下： 一、Bootloader简介 首先基于现在整车电子电气架构中ECU类型，大体分为两类： MCU（常规MCU）具备硬实时，应用Classic AUTOSAR软件架构； MPU，具备操作系统，应用上多使用Adaptive AUTOSAR软件架构或者自研； 那相应对于Bootloader介绍也分为： 1、MCU Bootloader是微控制器（MCU）中的引导程序，它的设计旨在解决程序升级问题，尤其是在产品稳定投产、程序烧录后，MCU被外壳等材料覆盖，无法通过烧录口进行升级的情况下。Bootloader可以通过一定方式触发运行，比如按键触发或UDS协议指令（在汽车行业中）触发。一旦Bootloader运行，它可以通过串口接收新的代码并写入Flash，从而在不使用烧录器的情况下实现程序升级。 2、Bootloader，中文名称为系统启动加载器，是计算机系统从开机上电到操作系统启动过程中所需要的一个引导程序。在嵌入式Linux系统中，Bootloader也扮演着重要的角色。它是一段在操作系统内核运行之前运行的程序，主要负责初始化硬件设备、建立内存空间映射图，将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。 Bootloader的具体作用如下： -&gt; 1、提供初始的硬件设备的初始代码，以及检测和初始化单板； -&gt; 2、引导操作系统，包括定位、解压和加载操作系统到内存空间，然后将其控制权交给操作系统； -&gt; 3、当操作系统获取控制权后，嵌入式系统中的Bootloader就不复存在了。 此外，U-Boot是一款流行的功能强大的开源Bootloader项目。它支持多种嵌入式操作系统内核，如Linux、NetBSD、VxWorks等，也支持多种处理器系列，如PowerPC、ARM、x86、MIPS。U-Boot有较高的可靠性和稳定性，以及高度的灵活的功能设置，适合U-Boot调试、操作系统的不同引导要求、产品发布等。它还包含丰富的设备驱动源码和较为丰富的开发调试文档与强大的网络技术支持。 首先关于ECU刷写的软件架构Flash Bootloader并没有在AUTOSAR规范中有明确定义。原因是每家刷写策略基于自身需求不一致，没有必要在AUTOSAR规范中特定定义函数接口等信息。 基于整车不同域，使用场景不一样，就会有不同的总线类型。因此在做ECU刷写时，也是通过不同的总线类型CAN,LNFlexRay or Ethernet)来完成软件的下载更新。 整车所有件基于相同的刷写流程，只是数据传输的总线载体不一样而已。 在研发阶段，可以随时进行应用程序(Application)的更新和下载可以随时为研发工程师随时进行下载调试更新等功能在车辆下线阶段，进行应用程序的刷写和灌注:在车辆售后阶段进行售后维护和升级 目前对于ECU更新方式: 1、刷写上位机通过OBD口，相当于传统的Flash更新方式进行更新； 2、另外是通过OTA，基于OTAMaster 对车内节点进行更新； 上述刷写方式不需要通过更换硬件ECU来完成软件的更新，对于软件bug或者功能升级，在硬件不需要更新的情况下，可以直接通过更新Application功能实现功能升级对于量产的ECU产品，可以不通过传统的调试接口UTAGDAP2)来完成Fash 的刷写这个时候调试口已经关闭，通过OBD口升级提供一种更好的方案对于车内的ECU来讲，通过一套协议(UDS)即可完成全部ECU的刷写需求在一定程度上，保证了刷写过程中的安全性和合法性。 通过上位机加载待刷写的Flash Data/Driver，不用通过烧录口就可以进行software update，对用户而言更加友好。 二、系统概述 诊断仪通过OBD诊断口和网关ECU进行连接，实现诊断刷写和路由功能:每个ECU的内存布局都是基本类似，包含了三大部分 Flash Bootloader.Flash Driver 和Application. Flash Bootloader实现总线通信基于ISO标准和OEM企标，实现诊断服务功能Application调用Flash Driver 接口来对Fash进行擦写操作一般情况下，代码仅在轮询模式下运行的中断仅在一些特殊需求下才会用到,一般代码精简短小，占用空间资源不大. 用于擦除和写入数据的Driver,通常是在RAM中执行调用的，是片内片外的驱动程序可对Hash 进行擦除和写入，可将数据写入Flash中。 -&gt; 通过驱动调用擦除接口，可以对内存地址进行擦除，将地址上旧数据进行擦掉; -&gt; 在数据写入阶段可以调用驱动的写入接口，实现对新数据在擦除后的地址进行写入操作,不同的芯片厂家和硬件平台，flash driver 是有所不同的。 根据 Flash 芯片不同，不同点主要体现如下两点: 1、不同的擦写参数(Sectors/Pages): 擦除和写入的Sector 和page 大小不一样2、存储保护机制(ECC)； 对于第一点(擦写参数(Sectors/Pages)是指在擦除或重写存储设备中的数据时所使用的单位。不同的存储设备可能有不同的擦写参数，这些参数可能会影响擦写性能和寿命。 在闪存设备中，擦写参数通常是以扇区(Sector)或页(Page)为单位进行操作的。扇区通常是一个存储单元，可以容纳一定数量的数据，而页是闪存设备中一个最小的可擦除单位。 对于不同的闪存设备，擦写参数可能会有所不同。例如，一些设备可能有 2KB的页大小，而另一些设备可能有 4KB 或 8KB 的页大小。此外，一些设备可能支持不同的擦写策略，例如一次擦写一个扇区或一次擦写多个扇区。 这些不同的擦写参数可能会影响闪存设备的性能和寿命。例如，如果一个设备的页大小较小，那么在执行写入操作时，可能会需要进行更多的读-改-写操作，这可能会导致性能下降。此外，如果一个设备的擦写策略过于频繁地擦除同一区域的数据，那么这个区域的寿命可能会比其他区域更短。因此，选择正确的擦写参数对于优化闪存设备的性能和寿命非常重要。这需要根据具体的应用需求和设备特性进行选择。 对于第二点:(存储保护机制(ECC)是一种用于Nand Flash 的差错检测和修正算法，它能够确保数据的可靠性。 在Nand Flash的每个页面上，包括额外的存储空间，即64个字节的空闲区(每512 字节的扇区有 16 字节)。这个空闲区能存储 ECC 代码及其它信息，例如磨损评级或逻辑到物理块映射。在编程操作期间，ECC单元根据扇区中存储的数据来计算误码校正代码。数据区的ECC代码然后被分别写入到各自的空闲区。当数据被读出时，ECC代码也被读出，运用反操作可以核查读出的数据是否正确 如果有数据错误，ECC 算法可以校正数据错误。能校正的错误的数量取决于所用算法的校正强度。软件通常负责磨损评级或逻辑到物理映射，并且如果处理器不包含ECC 硬件的话，软件还需要提供 ECC 码。 芯片内部对数flash driver存放位置: -&gt; 1、UTSAR转化为加密的二进制数组文件并对文件进行加密存储在FIashBootloader 中的指定Flash 区域，调用前先解密目的是防止flash误操作，误调用，比如用户程序(Application 调用flashdriver 接口，对某-块区域进行调用擦写)，添加加密策略，就保证了只有 Bootloader 具备解密能力，才可以调用Flash driver； -&gt; 2、刷写Application之前通过诊断仪载入到 RAM中上述操作是先通过诊断仪将 flash driver 下载到指定的区域(RAM 区域)，下载完成后Bootloader 才可以调用相应的接口实现对内存的擦除和写入。ECU 复位或者断电后 flashdriver就不再存在，避免安全问题。 三、Flash Bootloader刷写流程 本文仅描述通用性刷写流程，不同OEM或多或少有一定的差异如上图,当前假设只有FBL程序,没有Application(用户程序)。ECU上电后运行在Bootloader当中，Tester 通过相应的接口卡 举例常用的: CAN总线用VN16 系列； DoIP用VN56系列。 这样刷写上位机与待刷写 ECU 建立连接，通过UDS 协议刷写上位机与 ECU 进行相应的数据交互，主要读取一些所需要的诊断版本信息数据。接下来就是将用户程序数据通过刷写上位机传到ECU相应的地址处进行刷写。数据传输并写入完毕，Bootloader 会对数据进行校验，其中包含对单独每一个 block 以及整体的数据进行校验上述完毕后，对App有效标志位进行操作置位，后续复位。复位操作首先在FBL中查阅应用数据flag 位是否置位，判断有效后就会跳到用户程序中在Application中运行正常。后续有新的刷写请求，会继续运行至FBL中。对于刷写流程大体分为三步: A：Pre programming 首先切换至编程会话模式，进行Programming Pre-condition状态检查（车速、挡位等）； 关闭DTC功能 对常规通信报文进行设置，只接收诊断报文 目的是让ECU全负荷为刷写服务。 切换至编程会话模式写入一些DID和读取DID操作这些操作与OEM企业标准强相关。在定义刷写流程中明确每一步执行的内容和目的。信息安全要求过Service27，表示通过争取途径获取访问权限。 1、Request Service 34报文格式中会体现下载数据长度、是否压缩等信息；、 2、通过Service36/37完成数据的整体传输3、数据传输完成后，会执行 Service 31，对下载数据做完整性校验，数据丢失、错位等失真情况。 Flash Driver后会通过Service 31RID(猜出FF00)调用对内存擦除的接口实现对ECU内存的擦除操作。想要写入新的数据之前，必须对数据做擦除操作后才可以进行写入。 如上图，Vector 中国关于Fash Bootloader 产品手册的截图关于 Flash Bootloader 工程主要分为几大部分: 1、通信协议栈主要用于实现不同总线的通信需求，如图支持车载CAN 总线/LIN 总线/Flexray总线/车载以太网 2、OEM Download Manager主要是基于OEM企标要求做代码功能实现:A:OEM 定义的刷写流程(在 Bootloader 模式下)所使用到的诊断服务、子服务所支持的DID/RID/NRC信息都在这个模块做功能实现; 3、Fash bootloader 用户程序读取一些软件版本号、NVM存储应用，小模块上述流程也完全符合AUTOSAR开发流程。包含CAN、LIN早期协议栈是GENY做配置，现在是用Dawinciconfigurator定义pdur、CANdRIVER。当前 Bootloader 中也包含了一些非AUTOSAR定义的内容，这个时候需要由 Bootloader软件服务商自己OEM特定需求做定制化开发。也就是日常所说的购买成熟协议栈使用。 4、Bootmanager为芯片一级boot,是ECU 上电后第一个执行的代码，由该模块负责ECU该往那个代码模块跳比如进入 Bootloader还是Application(常见刷写成功后置位Flash位作为下次启动的判定标准)当需要对FlashBootloader做更新时，就需要由Bootloader Updater 来实现，其实这个逻辑也可以对照SBL/PBL，当有Super SBL时，也可以允许对PBL做擦除。 5、为了完成刷写功能，用于UI界面加载Flash Driver/Flash Data，也执行刷写template定义刷洗序列。 FBL和Application之间的跳转ECU上电后，代码运行会进入到FBL中，做相应的一些ECU初始化，初始化完成后会进入判断刷写标志位的一个步骤。若刷写标志位有效，进入到Boot 中，若标志位无效，进入App 中。FBL跳转至ApplicationFBL初始化 A:检查刷写标志位 B:检查Application的有效标志位 C:跳转至Application的入口 D:执行Application的启动代码 Application跳转至FBL Application 运行中接收到诊断仪发出的诊断刷写请求 Application 将刷写请求标志位存入NVM 或者RAM中 Application 执行复位操作 FBL检查诊断刷写标志位 另外关于Stay In Boot功能： 在Application无法接收和处理诊断请求时，避免ECU无法进行刷写更新并不是所有的OEM都会用到，通常情况下，用于研发阶段，量产中可能也会用(影响启动时间)。该功能应用场景是在某一次更新当中把新的APP更新到ECU中。此时APPdata没有经过很充分的认证导致APP 软件中有 bug，比如有死循环 (While)。每一次ECU 上电，先进入boot，在进入app，死循环无法与诊断仪(刷写上位机)做诊断数据交互，发送请求也没有响应。 这个时候通过其他方式来规避这个风险，vFlash也支持，对ECU启动时间有影响。 当收到Stay in boot message进入Stay in boot状态，避免ECU编程板砖。 关于ECU安全启动 对于Flash Data会存在片内或片外，会有可能被不法分子做篡改的风险。 通过安全启动获知该ECU 是否App data 是否被篡改、是否无效等，保证车辆安全ECU一上电，通过HSM，HSM 可以理解位信息安全的加密引擎，对FBL做源码校验，通过特定算法和 key 计算出一个 MAC 值(消息认证码)。这个消息认证码与原本存在芯片中的消息认证码进行比较: 若一样，FBL valid。不一样:FBL被算改了！ 同样策略也可以对APP做mac检验，开启ECU时计算一个MAC值对比ECU内部存储的就可以确认APP是否有效安全启动每一家芯片供应商都有自己的做法 HSM（硬件安全模块）对于实现AUTOSAR系统的加密保护起着重要作用。随着汽车电子控制单元（ECU）连通度的提高，安全和防范外部威胁的重要性日益增加。HSM具有适当的固件，即使在资源不足的情况下，也能保证系统的加密。此外，HSM还允许在单独的处理器上计算密码，以满足实时需求。因此，HSM在AUTOSAR系统中发挥着关键作用，确保了系统的安全性和实时性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/819081115425e24a1b78addfe67bc018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7a421fca87e82ed5461250e038b0dd1/" rel="bookmark">
			python-nmap库使用教程（Nmap网络扫描器的Python接口）（功能：主机发现、端口扫描、操作系统识别等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Python-nmap库使用教程前置条件引入python-nmap创建Nmap扫描实例执行简单的主机发现（`nmap -sn`）示例，我有一台主机配置为不响应 ICMP 请求，但使用`nmap -sn`，仍然能够探测到设备： 端口扫描扫描特定端口扫描多个端口和主机 获取扫描结果解析高级扫描信息错误处理和异常使用Python-nmap进行OS指纹识别（猜测目标主机操作系统类型）总结 Python-nmap库使用教程 Python-nmap是一个Python库，用于帮助进行网络扫描。它是Nmap网络扫描器的Python接口，允许开发者从Python脚本中直接调用Nmap的功能。这篇文章将详细介绍如何使用python-nmap库来执行各种网络扫描任务。
前置条件 在开始之前，需要确保安装了Nmap和python-nmap库。可以通过以下命令安装Nmap：
# 更新软件源列表 sudo apt-get update # 安装 nmap sudo apt-get install nmap 对于python-nmap库，可以使用pip进行安装：
pip install python-nmap 引入python-nmap 要在Python代码中使用nmap，首先需要导入库：
import nmap 创建Nmap扫描实例 创建一个Nmap扫描实例是使用python-nmap进行扫描的第一步。下面的代码演示了如何创建一个Nmap扫描器对象：
nm = nmap.PortScanner() 执行简单的主机发现（nmap -sn） 扫描一个或多个IP地址，以检查它们是否在线：
nm.scan(hosts='192.168.1.0/24', arguments='-sn') 上面的命令使用了-sn参数，这是Nmap的ping扫描选项，用于执行主机发现而不是端口扫描。-sn选项除了发送ICMP回显请求（即ping请求），还会发送TCP和/或UDP包到特定的端口。
示例，我有一台主机配置为不响应 ICMP 请求，但使用nmap -sn，仍然能够探测到设备： 用Advanced IP Scanner工具查看192.168.1.118设备是在线的：
配置了不响应ICMP请求：
nmap -sn 192.168.1.118 用nmap -PR也可以，但耗时较长：
nmap -PR 192.168.1.118 端口扫描 扫描特定端口 可以指定扫描单个主机上的特定端口：
nm.scan('127.0.0.1', '22-443') 这将扫描本地主机（127.0.0.1）上从22到443之间的所有端口。
扫描多个端口和主机 也可以同时扫描多个端口和主机：
nm.scan('192.168.1.0/24 10.0.0.0/24', '22,80,443') 此命令会扫描两个子网内的主机，只检查端口22、80和443。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7a421fca87e82ed5461250e038b0dd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc66a29e446e62a9d0c529f0b7e9d6c0/" rel="bookmark">
			算法笔记(模拟最大三数乘积问题)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题:给定一个无序整型数组，可能包含正数，负数和0，在数组中找出由三个数组成的最大乘积，并输出。
分类讨论有九种情况:
1.两个负数，一个正数
2.三个全是正数
3.三个全是负数
4.两个正数，一个负数
5. 两个负数，一个零
6.两个正数，一个零
7.三个全是零
8.一个正数，两个零
9.一个负数，两个零
本来想用两种排序(绝对值排序，非绝对值排序)来枚举求解，但是有点繁琐。发现规律后，只要非绝对值排序，然后求两个结果取最大值即可。
四种情况中，2，3，4，5，6，7，8，9的计算方法其实是一样，都是递增排序后的最后3个数的乘积；而1的计算方法则是递增排序后的第一个数，第二个数以及最后一个数的乘积。
给出几个样例可以自行验证:
-5 -3 -1 0 3 5
0 1 2 3 4 5
-6 -4 -2 -1 -6 -4 -2 -1 0
-3 0 5 10
-5 -3 -1 3 5
#include&lt;stdio.h&gt; void InsSort(int arr[],int len){ for(int i=1; i&lt;len; ++i){ int insert=arr[i]; int index=i-1; while(index&gt;=0 &amp;&amp; insert&lt;arr[index]){ arr[index+1]=arr[index]; --index; } arr[index+1]=insert; } } int MaxValue(int a,int b){ return a&gt;b?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc66a29e446e62a9d0c529f0b7e9d6c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6b4698ee8f277324639d1df8b8db84/" rel="bookmark">
			Redis 主从集群 —— 超详细操作演示！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五、Redis 主从集群 五、Redis 主从集群5.1 主从集群搭建5.1.1、伪集群搭建与配置5.1.2、分级管理5.1.3、容灾冷处理 5.2 主从复制原理5.2.1、主从复制原理5.2.2、数据同步演变过程 5.3 哨兵机制实现5.3.1 简介5.3.2 Redis高可用集群搭建5.3.3 Redis高可用集群的启动5.3.4 Sentinel 优化配置 5.4 哨兵机制原理5.4.1 三个定时任务5.4.2 Redis 节点下线判断5.4.3 Sentinel Leader 选举5.4.4 master 选择算法5.4.5 故障转移过程5.4.6 节点上线 5.5 CAP 定理5.5.1 概念5.5.2 定理5.5.3 BASE理论5.5.4 CAP的应用 5.6 Raft 算法5.6.1 基础5.6.2 角色、任期及角色转变5.6.3 leader 选举5.6.4 数据同步5.6.5 脑裂5.6.6 Leader 宕机处理5.6.7 Raft 算法动画演示 数据库系列文章：
关系型数据库:
MySQL —— 基础语法大全MySQL —— 进阶 非关系型数据库:
Redis 的安装与配置Redis 基本命令（上）Redis 基本命令（下）Redis 持久化 五、Redis 主从集群 为了避免 Redis 的 单点故障 问题， 我们可以搭建一个 Redis 集群，将数据备份到集群中的其它节点上。若一个 Redis 节点宕机，则由集群中的其它节点顶上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6b4698ee8f277324639d1df8b8db84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e8b2ac980aaf73f6c5720aab30e5753/" rel="bookmark">
			Python学习10
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，这里是七七，今天是Python学习专题的最后一期，要介绍两个代码，一个是名称字符串匹配代码，一个是时间序列分解实现代码。
首先介绍名称字符串匹配代码。
一、名称字符串匹配代码 import pandas as pd from fuzzywuzzy import fuzz from fuzzywuzzy import process import re info_data=pd.read_excel("./data/附件1.xlsx") sale_data=pd.read_excel("./data/附件2.xlsx") buy_data=pd.read_excel("./data/附件3.xlsx") loss_data=pd.read_excel("./data/附件4.xlsx") data=pd.merge(buy_data,info_data,on="单品编码",how="left") data=data[["日期","单品名称"]] data["日期"]=pd.to_datetime(data["日期"]) data=data.set_index("日期") grouped=data.groupby("日期") for group_name,group_data in grouped: strings=group_data["单品名称"].tolist() threshold=80 similar_strings={} for string in strings: best_match=process.extractOne( string, [s for s in strings if s not in [string]], scorer=fuzz.ratio) if best_match[1]&gt;=threshold and best_match[0]!=string and best_match[0][:2]==string[:2]: if re.search(r'\(\d+\)',best_match[0])and re.search(r'\(\d+\)',string): similar_strings[string]=best_match[0] strings=[s for s in strings if s not in [string]] if bool(similar_strings): print(group_name) for original,similar in similar_strings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e8b2ac980aaf73f6c5720aab30e5753/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3464f5183c8c8e5dc25b39e225fd70dd/" rel="bookmark">
			【Qt之Quick模块】5. QML基本类型及示例用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QML格式 以下是一个QML文件
import QtQuick 2.12 Window { id: mainWindow width: 400 height: 300 visible: true title: "My QML Application" Rectangle { id: rect width: 200 height: 100 color: "red" Text { id: textItem text: "Hello World!" font.pixelSize: 20 color: "white" anchors.centerIn: parent } MouseArea { id: mouseArea anchors.fill: parent onClicked: { rect.color = "blue" textItem.text = "Clicked!" } } } } 文件内是啥意思呢？
第一行 ： 导入了QtQuick模块的2.12版本
第二行Window ： 定义了一个Window元素作为应用程序的主窗口，并设置了窗口的属性
Rectangle元素 ： 在Window元素内部，创建了一个Rectangle元素作为子元素，用于显示一个红色的矩形
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3464f5183c8c8e5dc25b39e225fd70dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f313757d2fef0a5f26cd3480a13c56f1/" rel="bookmark">
			redis的性能管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis的性能管理：redis的数据缓存到内存当中
used_memory:853336 redis中数据占用的内存
used_memory_rss:4292608 redis向操作系统申请的内存
used_memory_peak:853336 redis使用内存的峰值
redis系统巡检：硬件巡检，数据库 nginx redis docker k8s
内存碎片率：used_memory_rss/used_memory
系统已经分配给了redis，但是redis未能够有效利用的内存
allocator_frag_ratio:1.29
#分配器碎片的比例，redis主进程调度时产生的内存，比例越小越好，值越高，内存的浪费越多
allocator_rss_ratio:8.06
#分配器占用物理内存的比例，告诉你主进程调度执行时占用了多少物理内存
rss_overhead_ratio:0.33
#RSS是向系统申请的内存空间，redis占用物理空间额外的开销比例，比例越低越好，redis实际占用的物理内存和向系统申请的内存越接近，额外的开销越低
mem_fragmentation_ratio:5.42 #内存碎片的比例，越低越好，内存的使用率越高
自动清理：vim /etc/redis/6379.conf
activedefrag yes写在最后一行
/etc/init.d/redis_6379 restart重启
手动清理： redis-cli memory purge
设置redis的最大内存阀值
一旦到达阀值，自动清理碎片，开启key的回收机制
vim /etc/redis/6379.conf
567行
maxmemory 1gb
key回收的策略：
vim /etc/redis/6379.conf
598行
maxmemory-policy volatile-lru
使用redis内置的LRU算法，把已经设置了过期时间的键值对中淘汰数据，移除最近最少使用键值对（针对已经设置了过期时间的键值对）
maxmemory-policy volatile-ttl
已经设置了过期时间的键值对，从当中挑选一个即将过期的键值对（针对有设置过期时间的键值对）
maxmemory-policy volatile-random
从已经设置了过期时间的键值对当中，挑选数据随机淘汰键值对。（对设置了过期时间的键值对进行随机移除。）
allkeys-lru
LRU算法当中，对所有的键值对进行淘汰，移除最少使用的键值对。（针对所有的键值对）
allkeys-random
从所有键值对当中任意选择数据进行淘汰。
maxmemory-policy noeviction
禁止键值对回收（不删除任何键值对，直到redis把内存塞满，写不了，报错为止）
在工作当中，一定要给redis占用内存设置阀值
redis占用内存的效率问题如何解决：
日常巡检当中，对redis的占用情况做监控设置redis占用系统内存的阀值，避免占用系统全部内存内存碎片清理，手动清理/自动清理配置合适的key回收机制 redis雪崩：
缓存雪崩：大量的应用请求无法在redis缓存当中处理，请求会全部发送到后台数据库，数据库并发能力本身就很差，一旦高并发，数据库会很快崩溃。
redis集群大面积故障
redis缓存中，大量数据同时过期，大量的请求无法得到处理
redis实例宕机
解决方案：
事前：高可用架构，防止整个缓存故障。主从复制和哨兵模式，redis集群。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f313757d2fef0a5f26cd3480a13c56f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2e1899a66b5e9aefe8dc25b53c81ed/" rel="bookmark">
			前端八股文（js篇 ）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.防抖，节流是什么，如何实现?
二.介绍下Set,Map，WeakSet和WeakMap的区别
三.setTimeout，Promise，Async/Await的区别
四.简述同步和异步的区别
五.怎么添加，移除，复制，创建，和查找节点
六.attribute和property的区别是什么？
七.原始类型有哪几种？null是对象吗？
八.什么是函数式编程，应用场景是什么？
九.JavaScript中的数组和函数在内存中是如何存储的？
十.扩展运算符的作用及使用场景
一.防抖，节流是什么，如何实现? 我们在平时开发的时候，会有很多场景频繁触发事件，比如说搜索框实时发请求，onmousemove，resize，onscroll等，有些时候，我们并不能或者不想频繁触发事件，这时候就应该用到函数防抖和节流。
函数防抖，指的是短时间内多次触发同一事件，只执行最后一次，或者只执行最开始的一次，中间的不执行。
具体实现：
//函数防抖 function debounce(func,wait){ //设置变量，记录setTimeout得到的id let timerId=null; return function(...args){ if(timerId){ //如果有值，说明正在等待中，清除它 clearTimeout(timerId); } //重新开始计时 timerId=setTimeout(()=&gt;{ func(..args); },wait); } } 函数节流，指连续触发事件但是在n秒中只执行一次函数。即2n秒内执行两次。节流如字面意思，会稀释函数的执行频率。
具体实现如下：
//函数节流 function throttle(func,watit){ let context,args; let provious=0; return function () { let now = new Date(); context=this; args=arguments if(now-provious&gt;wait){ func.app(contxt,args) provious=now; } } } 二.介绍下Set,Map，WeakSet和WeakMap的区别 Set:
成员唯一，无序且不重复键值与键名是一致的可以遍历，方法有add，delete，has WeakSet：
成员都是对象成员都是弱引用，可以被立即回收机制回收，可以用来保存DOM节点，不容易造成内存泄露不能遍历，方法有add，delete，has Map:
本质上是键值对的集合，类似集合可以遍历，方法很多，可以跟各种数据格式转换 WeakMap:
只能接收对象作为键名，不接受其他类型的值作为键名键名是弱引用，键值可以是任意的，键名所指的对象可以被垃圾机制回收，此时键名是无效的不能遍历，方法有get，set，has，delete 三.setTimeout，Promise，Async/Await的区别 事件循环中分为宏任务队列和微任务队列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d2e1899a66b5e9aefe8dc25b53c81ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982ad565ddfa640d73ed74a996d75f46/" rel="bookmark">
			Webpack笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程简介
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee1a39606209cdfdf0894de2fc0efb0/" rel="bookmark">
			32. 深度学习进阶 - Transfer Learning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi，你好。我是茶桁。
之前的课程中，咱们学习了CNN的原理，学习了pooling, fully connected是做什么的。还了解了理论上简单的模型也是可以做事情的，只不过在特定的一些情况下要解决问题的时候简单方法效果不太好，所以用了像LSTM，或者RNN、CNN之类的结构。
这些本质上都是在做特征的提取。一个经典的观念是，神经网络其实一共都可以分成两个部分，第一个部分是特征提取，第二个部分是分类器。像fully connected layer，其实就是之后再加上一个Softmax或者log Softmax，在做分类器的实现。
前面在进入全连接层之前，也在进入Softmax或者log Softmax之前，全部做的都是特征提取的事。
不管你是线性函数，就线性变化全连接的这种网络，还是RNN，LSTM或者CNN等等，在进入Softmax之前，这些都是在做特征提取。
Hinton当时的说法我觉得说的很有道理，就说「特征提取的作用是让相似的东西不相似，让不相似的相似」。
意思就是，我们对于任何一个神经网络来说，到最终的这个全连接，加上Softmax，之前的这些东西不管你是输入的是一个图片还是几个文字，还是说一串数据。所谓的让看起来相似的东西不相似是如果有两个图片，或者两组数据，他们在我们人看起来是比较类似的。但是假设他们的label不一样的话，我们整个特征提取的过程是把输入的这两个x，人看起来是一样的，在最后输出的这个地方要尽可能的不一样。所以送到分类器里边，它们结果差距才能大。
如果这两个东西看起来很不一样，就假如说有两只猫，一只猫特别瘦，黑黑的。一只是橘猫，特别的胖，大小也不一样。但这个在图片来说这差距是很大的。我们整个做feature extraction的时候是要把这两张图在最后变成一样，就在最后的时候变得相似。输入的时候不相似，但是经过特征提取其实要把它变相似。这样送入到了Softmax它才会产生分类的作用。
接下来讲了卷积神经网络的计算过程以及整个模型的搭建是什么样的。然后还讲了RES-NET的原理，这个也需要去理解。
Transfer Learning 那么现在，咱们今天就跟大家来介绍一个比较重要的概念，深度学习共同的基础部分，就是transfer learning。
咱们现在的这个深度学习模型变得越来越复杂了。上节课给大家举过这些例子，不同的人提出来了不同的模型，
重点给大家介绍了一个RES-NET和Inception model，也称为GoogleNET。
模型现在其实已经变得越来越复杂，这么复杂的结果是什么呢？结果是我们现在已经很难从头到尾搭建一个模型了。现在的模型结构已经这么复杂了，很少有人能有时间，或者在工作的时候有时间、有精力能从零开始一层一层的去做搭建，这是第一方面。
第二个方面，大家还发现一个特点。在结构中越接近前边虽然任务不一样，比如解决动物分类或者解决人物分类，但是越靠近前边，它们的特征相似度越高。
换句话说，有一个RES-NET专门对人物分类，还有一个是是专门做动物，它们分的类别完全不一样。但是就前边这些CNN的结果往往都很相似，而且是越往前越相似。
这是因为这些过程都是在做特征提取，如果都是一个比较相似的图片任务的话，在这个过程中特征提取其实从刚开始的时候在解析图片上的重要程度，其实要提取的东西都是类似的。
比方说识别我左手的水和我右手的手机，还有我前面站着一个美女，刚开始都是要识别它的轮廓。然后都要识别它的局部的形状，还要识别颜色… 这样的一个直接的结果，其实我们每一层用的filter都是类似的，只要达到一个比较好的结果，前面的这些filter都是类似的。
filter类似是因为filter控制的是我们要提取什么重要特征。那么我们就发现从前到后，其实越是前边越是比较简单的特征，线、块这些，到后边越来越综合。
有了这个之后大家就发现，既然现在模型这么复杂，从头到尾要搭建一个模型已经很难了，我们可以直接用这个模型的结构。
第二我们发现不仅模型的结构可以，模型的权重都也可以。可以用这个模型的权重来训练，直接把这个模型的权重拿过来。
其实也就是说，我们可以直接下载一个模型，把别人训练好的权重一起拿过来，这些东西就是一堆数字。然后它是在task a上弄的，我把它用到了task b上。训练的时候让它不要进行反向传播，在进入全连接层的时候再进行反向传播。
大家把这种学习方式就叫做transfer Learning， 迁移学习。我们平时日常在工作的时候经常会这么做。
客观上来讲，不同的任务，任务越类似肯定迁移的时候越好迁移。所以说其实它和任务的相似度以及和数据量的相对大小很有关系。
假设我们两个任务，A和B。这两个任务，A是分类狗，B是分类狼，A原本训练数据集是100W，B的训练集是1W。那么这两个任务比较而言，任务相似度非常大，原任务相对新任务数据量比较大，这个时候基本上迁移学习就非常好迁移，我们都可以不去更改进入全连接层之前的所有内容就可以进行迁移，只需要更改全连接层。也就是特征提取的部分完全平移。
那么如果A任务还是分类狗，B任务是分类汽车。A原本训练数据集是100W，B的训练集是5000W。那这两个任务比较而言，任务相似度非常小，原任务相对新任务数据量是小的，这个时候迁移学习就变得很困难，可能也只有图像线条，颜色这些个特征提取的部分可以迁移，基本是特征提取的最前边的部分。
所以，Transfer Learning的容易程度，在一个二维平面直角坐标系内的两个相关项，也就是x和y轴就是任务相似度和原任务相对新任务数据量的大小。
如果重新训练，怎么样来transfer呢？说了这么多，还是直接来看一个实例, 来看看我们具体该如何做「冻结」。
用的这个数据集, cifar10，这也是一个很经典的数据，它是十个典型的很常见的物品的分类。
咱们先引入必要的库，然后down数据集：
import torchvision import torch.nn.functional as F from torchvision.transforms import transforms import torch import matplotlib.pyplot as plt from torch import nn from icecream import ic cifar_10 = torchvision.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ee1a39606209cdfdf0894de2fc0efb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000afaa362f48640f8db4d64c7fb722e/" rel="bookmark">
			【并发编程篇】定义最大线程的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 🍔省流🏳️‍🌈前言🛸CPU密集型🌹代码实现 🛸IO密集型 🍔省流 池的最大大小如何去设置
使用CPU密集型和IO密集型这2种方法
🏳️‍🌈前言 上一篇文章我们讲解了自定义线程池的方法，里面提到了最大线程池
那么，到底应该怎么去定义最大线程呢
🛸CPU密集型 通常情况下，计算机系统的处理能力取决于两个主要因素：处理器核心数量和线程数。处理器核心表示处理器上的物理处理单元数量，而线程是操作系统调度处理器执行任务的最小单位。
在一个CPU密集型任务中，处理器会尽可能地使用所有可用的处理器核心来执行任务，以最大化利用CPU资源。因此，可以通过将线程数设置为处理器核心数来提高任务执行效率。这是因为多个线程可以并行执行任务，从而减少任务的总执行时间。
假设一个系统有n个处理器核心，我们可以创建m个线程来执行一个CPU密集型任务，其中m &lt;= n。如果创建的线程数大于可用的处理器核心数，那么线程之间将需要分享处理器资源，从而导致任务执行效率下降。因此，通常将线程数设置为可用处理器核心数可以获得最佳性能。
现代操作系统通常会动态调整线程数，以最大化利用可用的处理器资源。例如，在JVM中，使用线程池可以方便地管理线程，并实现动态调整线程数的功能。在实际应用中，选择合适的线程数需要考虑多种因素，例如任务特性、系统负载、硬件资源等。
🌹代码实现 package org.Test6; import java.util.concurrent.*; public class Demo01 { public static void main(String[] args) { //获取CPU有多少核 System.out.println(Runtime.getRuntime().availableProcessors()); ExecutorService threadPool = new ThreadPoolExecutor( 2, Runtime.getRuntime().availableProcessors(), 3, TimeUnit.SECONDS, //超时等待时间 new LinkedBlockingQueue&lt;&gt;(3), Executors.defaultThreadFactory(), new ThreadPoolExecutor.DiscardOldestPolicy() ); try { for (int i = 1; i &lt;= 10; i++) { //使用线程池后，使用线程池来创建线程 threadPool.execute(()-&gt;{ System.out.println(Thread.currentThread().getName()+"ok"); }); } }catch (Exception e){ e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000afaa362f48640f8db4d64c7fb722e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c2e565300860b465066e26597f285fb/" rel="bookmark">
			windows下使用vscode&#43;cmake调用opencv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、编写CMakeLists.txt
cmake_minimum_required(VERSION 3.20)	# 指定运行的cmake最低版本 project(demo_cpp) set(OpenCV_DIR G:/Install_package/opencv/build)	# 设置OpenCV_DIR的路径 find_package(OpenCV) #cmake会到OpenCV_DIR目录下寻找OpenCVConfig.cmake文件，自动配置opencv include_directories(${OpenCV_INCLUDE_DIRS}) # 包含头文件 message(${OpenCV_INCLUDE_DIRS}) message(${OpenCV_LIBS}) add_executable(main main.cpp)	target_link_libraries(main ${OpenCV_LIBS})	# 链接文件 2、编写main.cpp
#include &lt;iostream&gt; #include "opencv2/opencv.hpp" int main() { std::cout &lt;&lt; "hello,world" &lt;&lt; std::endl; cv::Mat Image = cv::imread("D:/6_cuda_code/cuda-image-preprocess/lena.jpg"); std::cout &lt;&lt; "Image.cols:" &lt;&lt;Image.cols &lt;&lt; ",Image.cols:"&lt;&lt; Image.rows&lt;&lt; std::endl; return 0; } 3、编译运行程序
3.1 使用cmake构建项目
cmake -B build -G"Visual Studio 16 2019" 3.2 编译项目
cmake --build build 3.3 运行exe
.\build\Debug\main.exe 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760a8ad25608f8c9a5cd492dead391b7/" rel="bookmark">
			Python学习9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，这里是七七，本次Python学习专题的例子剖析已经接近尾声，再更新几期本专题就结束了，对于展示的例子，可以介绍的细节部分越来越少了。
今天来给大家介绍的是粒子群优化算法的实现代码。
总代码 import matplotlib.pyplot as plt import numpy as np import pyswarms as ps plt.rcParams['font.sans-serif'] = [u'simHei'] plt.rcParams['axes.unicode_minus'] = False list_1=['花叶类','花菜类','水生根茎类','茄类','辣椒类','食用菌'] predit_buy=[ [3.285864,3.2921748,3.2889733,3.285188,3.2851105,3.2964268,3.2876368] , [7.7414317,7.763459,7.814592,7.794937,7.747068,7.810813, 7.7633805] , [12.018661,11.912668,12.027704,11.941088,11.92054,12.118359,11.972251] , [4.5562034,4.601929,4.5483465,4.549116,4.532483,4.539543,4.601603], [3.7067149,3.65774,3.6644902,3.6755412,3.6658049,3.6834998,3.6471841] , [4.015016,4.075036,4.025253,4.0783653,4.0397897,4.0211616,4.0569587] ]#预测进价 predit_sale=[ [190.75572,189.94437,189.2342,190.34938,189.08669,188.56415,190.10588], [28.618061,28.872581,28.873682,28.74203,28.776909,28.86964,28.661997], [26.962397,27.805391,27.65219,27.210875,27.88252,27.764929,27.24346], [32.29913,31.795496,32.425,31.649815,31.683603,31.381622,31.967655], [102.14867,101.67641,102.01936,102.55891,102.07538,102.73362,102.2766], [56.307552,57.39569,58.130955,56.80816,56.4629,57.186737,57.953686]]#预测销量 predit_omega=[0.7]*6 #折扣 predit_gama=[0.1283,0.1551,0.1365,0.0668,0.0924,0.0945] #耗损率 day=6 ini_pos=[0.6,0.4,0.3,0.6,0.9,0.6,150,30,20,20,100,60] ini_pos=np.array(ini_pos) n_particles=1000 n_dimensions=12 lower_bound=np.array([0.3,0.2,0.2,0.3,0.3,0.3,10,0,0,10,10,20]) upper_bound=np.array([1.2,0.98,0.8,0.9,1.2,1.0,450,90,75,60,300,250]) bounds=(lower_bound,upper_bound) weight_ini=0.3 #给定的初始值占总粒子的比例 pos_given=np.random.uniform( low=lower_bound,high=upper_bound,size=(int(n_particles*weight_ini),n_dimensions) ) pos_given=0.8*pos_given+0.2*ini_pos pos_given=np.clip(pos_given,lower_bound,upper_bound) pos_random=np.random.uniform( low=lower_bound, high=upper_bound, size=(int(n_particles * (1-weight_ini)), n_dimensions) ) Initial_pos=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/760a8ad25608f8c9a5cd492dead391b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbef0f24b4832c507202e12c4f91da9f/" rel="bookmark">
			matlab一本通 学习笔记三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形步骤：生成自变量，根据函数产生结果向量，利用figure生成窗口，使用plot生成图形，设置轴，设置标记，使用'r,g,y,b'等设置颜色，使用'x.-ov'标识线型；使用position在figure中设置图像的左下角坐标和图像大小，使用name设置图像名称；使用hold on在保留原图的基础上，叠加画图；使用grid on打开格子标记；使用xlim([ ])限定x轴范围；使用title为绘制的图形添加title；使用xlabel和ylabel为x,y轴添加标注；使用legend为图形添加图例；plotyy用于绘制双y轴图形； 想去年的今天，只差3分啊，今天一过，又得重操旧业，还有不怕跌倒的勇气不？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39bc635b06e7c2f4b01985c279260f03/" rel="bookmark">
			Vuforia Web API Authentication
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Use the OAuth2 or Vuforia Web Services (VWS) scheme to authenticate requests with the Vuforia Web API.
Authentication Methods Various Vuforia features and services are available through a Web API. Use the authentication method supported by the specific features as described in the table below.
VWS AuthenticationOAuth2 Authentication Cloud Targets Web APICloud Query Web APIVuMark Generation Web API Model Target Web APIArea Target Capture APILogin credentials for the Area Target Generator and Model Target Generator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39bc635b06e7c2f4b01985c279260f03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/202c55fdcc6863ba1a414b7cb470a706/" rel="bookmark">
			持续集成交付CICD：Jira 远程触发 Jenkins 实现更新 GitLab 分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验
1.环境
2.GitLab 查看项目
3.Jira新建模块
4. Jira 通过Webhook 触发Jenkins流水线
3.Jira 远程触发 Jenkins 实现更新 GitLab 分支
二、问题
1.Jira 配置网络钩子失败
2. Jira 远程触发Jenkins 报错
一、实验 1.环境 （1）主机
表1 主机
主机架构版本IP备注master1K8S master节点1.20.6192.168.204.180 jenkins slave
（从节点）
jira9.12.1192.168.204.180:8801node1K8S node节点1.20.6192.168.204.181node2K8S node节点1.20.6192.168.204.182jenkins jenkins主节点 2.414.2192.168.204.15:8080 gitlab runner
（从节点）
gitlabgitlab 主节点 12.10.14192.168.204.8:82 jenkins slave
（从节点）
sonarqube9.6192.168.204.8:9000 （2）查看K8集群状态
# kubectl get node 2.GitLab 查看项目 （1） GitLab查看后端项目（项目编号为19）
（2）GitLab查看前端项目（项目编号为20）
3.Jira新建模块 （1）查询已有模块（前端项目）
（2）新建后端项目模块
（3）再次查看模块
4. Jira 通过Webhook 触发Jenkins流水线 （1）Jenkins新建流水线
（2）配置触发器
（3）拿到Webhook 触发地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/202c55fdcc6863ba1a414b7cb470a706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc87e49c6b9242eb9282bd9436eadf9/" rel="bookmark">
			多维时序 | MATLAB实CNN-BiGRU-Mutilhead-Attention卷积网络结合双向门控循环单元网络融合多头注意力机制多变量时间序列预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多维时序 | MATLAB实现CNN-BiGRU-Mutilhead-Attention卷积网络结合双向门控循环单元网络融合多头注意力机制多变量时间序列预测 目录 多维时序 | MATLAB实现CNN-BiGRU-Mutilhead-Attention卷积网络结合双向门控循环单元网络融合多头注意力机制多变量时间序列预测预测效果基本介绍模型描述程序设计参考资料 预测效果 基本介绍 多维时序 | MATLAB实现CNN-BiGRU-Mutilhead-Attention卷积网络结合双向门控循环单元网络融合多头注意力机制多变量时间序列预测。
模型描述 多维时序 | MATLAB实现CNN-BiGRU-Mutilhead-Attention卷积网络结合双向门控循环单元网络融合多头注意力机制多变量时间序列预测，用于处理时间序列数据；适用平台：Matlab 2023及以上
1.data为数据集，格式为excel，4个输入特征，1个输出特征，考虑历史特征的影响，多变量时间序列预测；
2.主程序文件，运行即可；
3.命令窗口输出R2、MAE、MAPE、MSE和MBE，可在下载区获取数据和程序内容；
注意程序和数据放在一个文件夹，运行环境为Matlab2023b及以上。
程序设计 完整程序和数据获取方式1：同等价值程序兑换；完整程序和数据获取方式2：私信博主回复MATLAB实现CNN-BiGRU-Mutilhead-Attention卷积网络结合双向门控循环单元网络融合多头注意力机制多变量时间序列预测获取。 %--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- %% 数据集分析 outdim = 1; % 最后一列为输出 num_size = 0.7; % 训练集占数据集比例 num_train_s = round(num_size * num_samples); % 训练集样本个数 f_ = size(res, 2) - outdim; % 输入特征维度 %--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- %% 划分训练集和测试集 P_train = res(1: num_train_s, 1: f_)'; T_train = res(1: num_train_s, f_ + 1: end)'; M = size(P_train, 2); %--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- P_test = res(num_train_s + 1: end, 1: f_)'; T_test = res(num_train_s + 1: end, f_ + 1: end)'; N = size(P_test, 2); ———————————————— 版权声明：本文为CSDN博主「机器学习之心」的原创文章，遵循CC 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc87e49c6b9242eb9282bd9436eadf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9549acae6ce67b2e2f579f634391d863/" rel="bookmark">
			网络7层架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网络 7 层架构
什么是OSI七层模型？ OSI模型用于定义并理解数据从一台计算机转移到另一台计算机，在最基本的形式中，两台计算机通过网线和连接器相互连接，在网卡的帮助下共享数据，形成一个网络，但是一台计算机基于微软的Windows系统而另一台计算机基于Mac OS系统，那么这两台计算机之间将如何相互通信？
为了完成不同计算机或网络或架构之间的成功通信，国际标准化组织提出了OSI七层模型，该模型(从上到下)包括了应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
每一层其实际上都是一个协议包，比如说当我们要提起应用层的时候，并不仅仅指计算机的应用程序（谷歌、火狐等APP），还包含了大量的应用层协议，应用层协议能使应用层程序在网络中够正确的运行，记下来我们一起来看下OSI的七层模型。
物理层 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。 数据链路层 数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 网络层 网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 传输层 传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。 会话层 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名） 表示层 表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）） 应用层 应用层 主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d7aa2b26a8e1e7927c6ef3d900c2c8d/" rel="bookmark">
			IP编址，IP地址介绍与子网划分方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络层位于数据链路层与传输层之间。网络层中包含了许多协议，其中最为重要的协议就是IP协议。网络层提供了IP路由功能。理解IP路由除了要熟悉IP协议的工作机制之外，还必须理解IP编址以及如何合理地使用IP地址来设计网络。 上层协议类型 以太网帧中的Type字段值为0x0800，表示该帧的网络层协议为IP协议。在剥掉帧的头部和尾部之前，网络设备需要根据帧头中Type字段确定下一步将帧发送到哪个上层协议进行处理。本例中的帧头部Type字段表示该帧需要上送到IP协议进行处理。以下将介绍帧的头部和尾部被剥掉后，IP协议将如何处理帧中的数据。 IP报文头部 IP报文头部信息用于指导网络设备对报文进行路由和分片。同一个网段内的数据转发通过链路层即可实现，而跨网段的数据转发需要使用网络设备的路由功能。分片是指数据包超过一定长度时，需要被划分成不同的片段使其能够在网络中传输。IP报文头部长度为20到60字节，报文头中的信息可以用来指导网络设备如何将报文从源设备发送到目的设备。其中，版本字段表示当前支持的IP协议版本，当前的版本号为4。DS字段早期用来表示业务类型，现在用于支持QoS中的差分服务模型，实现网络流量优化。源和目的IP地址是分配给主机的逻辑地址，用于在网络层标识报文的发送方和接收方。根据源和目的IP地址可以判断目的端是否与发送端位于同一网段，如果二者不在同一网段，则需要采用路由机制进行跨网段转发。 IP编址 IPv4地址为32比特的二进制数，通常用点分十进制表示。IP地址用来标识网络中的设备，具有IP地址的设备可以在同一网段内或跨网段通信。IP地址包括两部分，第一部分是网络号，表示IP地址所属的网段，第二部分是主机号，用来唯一标识本网段上的某台网络设备。 每个网段上都有两个特殊地址不能分配给主机或网络设备。第一个是该网段的网络地址，该IP地址的主机位为全0，表示一个网段。第二个地址是该网段中的广播地址，目的地址为广播地址的报文会被该网段中的所有网络设备接收。广播地址的主机位为全1。除网络地址和广播地址以外的其他IP地址都可以作为网络设备的IP地址。 二进制、十进制和十六进制 网络中的数据可以采用二进制、十进制或十六进制来表示，了解这些进制对理解IP网络基础知识很有必要。每种进制使用不同的基值表示每一位的数值。二进制每一位只有0和1两个值，基值为2，二进制数的每一位都可以用2的x次幂来表示，x表示二进制数的位数。十六进制的每一位可以有16个数值，范围为0-F（即0-9和A-F），A对应十进制的10，F对应十进制的15（二进制的1111）。 进制之间转换 IP地址以字节为单位分为四段，每字节包含8个比特，可以表示0到255，共256个数值。从二进制到十进制转换表中可以看到每一位二进制数所代表的十进制数。上面的表格举例说明了8位二进制数转换为十进制数和十六进制数的情况。从表格中也可以看到全0和全1所对应的十进制数和十六进制数。 二进制和十进制转换 32位的IP地址分为4个字节，每个字节有256个取值。因此，理论上IPv4可以有4,294,967,296个IP地址，但实际上只有其中一部分地址可以分配给网络设备使用。本例中，IP地址的前三个字节表示网络号，最后一个字节表示该网络上网络设备可用的地址范围。将二进制格式的IP地址转换为十进制格式时，需要把二进制中每一位1所代表的值加在一起，得出IP地址的十进制值。 IP地址分类 IPv4地址被划分为A、B、C、D、E五类，每类地址的网络号包含不同的字节数。A类，B类和C类地址为可分配IP地址，每类地址支持的网络数和主机数不同。比如，A类地址可支持126个网络，每个网络支持224 （16,777,216 )个主机地址，另外每个网段中的网络地址和广播地址不能分配给主机。C类地址支持200多万个网络，每个网络支持256个主机地址，其中254个地址可以分配给主机使用。D类地址为组播地址。主机收到以D类地址为目的地址的报文后，且该主机是该组播组成员，就会接收并处理该报文。各类IP地址可以通过第一个字节中的比特位进行区分。如A类地址第一字节的最高位固定为0，B类地址第一字节的高两位固定为10，C类地址第一字节的高三位固定为110，D类地址第一字节的高四位固定为1110，E类地址第一字节的高四位固定为1111。 IP地址类型 IPv4中的部分IP地址被保留用作特殊用途。为节省IPv4地址，A、B、C类地址段中都预留了特定范围的地址作为私网地址。现在，世界上所有终端系统和网络设备需要的IP地址总数已经超过了32位IPv4地址所能支持的最大地址数4,294,967,296。为主机分配私网地址节省了公网地址，可以用来缓解IP地址短缺的问题。企业网络中普遍使用私网地址，不同企业网络中的私网地址可以重叠。默认情况下，网络中的主机无法使用私网地址与公网通信；当需要与公网通信时，私网地址必须转换成公网地址。还有其他一些特殊IP地址，如127.0.0.0网段中的地址为环回地址，用于诊断网络是否正常。IPv4中的第一个地址0.0.0.0表示任何网络，这个地址的作用将在路由原理中详细介绍。IPv4中的最后一个地址255.255.255.255是0.0.0.0网络中的广播地址。 网络通信 源主机必须要知道目的主机的IP地址后才能将数据发送到目的地。源主机向其他目的主机发送报文之前，需要检查目的IP地址和源IP地址是否属于同一个网段。如果是，则报文将被下发到底层协议进行以太网封装处理。如果目的地址和源地址属于不同网段，则主机需要获取下一跳路由器的IP地址，然后将报文下发到底层协议处理。 子网掩码 子网掩码用于区分网络部分和主机部分。子网掩码与IP地址的表示方法相同。每个IP地址和子网掩码一起可以用来唯一的标识一个网段中的某台网络设备。子网掩码中的1表示网络位，0表示主机位。 默认子网掩码 每类IP地址有一个缺省子网掩码。A类地址的缺省子网掩码为8位，即第一个字节表示网络位，其他三个字节表示主机位。B类地址的缺省子网掩码为16位，因此B类地址支持更多的网络，但是主机数也相应减少。C类地址的缺省子网掩码为24位，支持的网络最多，同时也限制了单个网络中主机的数量。 地址规划 通过子网掩码可以判断主机所属的网段、网段上的广播地址以及网段上支持的主机数。图中这个例子，主机地址为192.168.1.7，子网掩码为24位（C类IP地址的缺省掩码），从中我们可以判断该主机位于192.168.1.0/24网段。将IP地址中的主机位全部置为1，并转换为十进制数，即可得到该网段的广播地址192.168.1.255。网段中支持的主机数为2n，n为主机位的个数。本例中n=8，28=256，减去本网段的网络地址和广播地址，可知该网段支持254个有效主机地址。 地址规划举例 根据给出的IP地址和子网掩码，请算出此网络中包含的主机地址数量以及可用主机地址的数量。本例说明如何根据B类IP地址及其子网掩码判断主机所属的网段、网段中的广播地址以及有效主机地址数量。判断过程与C类地址类似。 有类IP编址的缺陷 在设计网络时使用有类IP地址会造成地址的浪费。 如果企业网络中希望通过规划多个网段来隔离物理网络上的主机，使用缺省子网掩码就会存在一定的局限性。网络中划分多个网段后，每个网段中的实际主机数量可能很有限，导致很多地址未被使用。如图所示的场景下，如果使用缺省子网掩码的编址方案，则地址使用率很低。 变长子网掩码 采用可变长子网掩码可解决上述问题。缺省子网掩码可以进一步划分，成为变长子网掩码（VLSM）。通过改变子网掩码，可以将网络划分为多个子网。本例中的地址为C类地址，缺省子网掩码为24位。现借用一个主机位作为网络位，借用的主机位变成子网位。一个子网位有两个取值0和1，因此可划分两个子网。该比特位设置为0，则子网号为0，该比特位设置为1，则子网号为128。将剩余的主机位都设置为0，即可得到划分后的子网地址；将剩余的主机位都设置为1，即可得到子网的广播地址。每个子网中支持的主机数为27-2（减去子网地址和广播地址），即126个主机地址。 变长子网掩码举例 可变长子网掩码缓解了使用缺省子网掩码导致的地址浪费问题，同时也为企业网络提供了更为有效的编址方案。本例中需要使用可变长子网掩码来划分多个子网，借用一定数量的主机位作为子网位的同时，剩余的主机位必须保证有足够的IP地址供每个子网上的所有主机使用。 无类域间路由 无类域间路由CIDR（Classless Inter Domain Routing）由RFC1817定义。CIDR突破了传统IP地址的分类边界，将路由表中的若干条路由汇聚为一条路由，减少了路由表的规模，提高了路由器的可扩展性。如上图所示，一个企业分配到了一段A类网络地址，10.24.0.0/22。该企业准备把这些A类网络分配给各个用户群，目前已经分配了四个网段给用户。如果没有实施CIDR技术，企业路由器的路由表中会有四条下连网段的路由条目，并且会把它通告给其他路由器。通过实施CIDR技术，我们可以在企业的路由器上把这四条路由10.24.0.0/24，10.24.1.0/24，10.24.2.0/24，10.24.3.0/24汇聚成一条路由10.24.0.0/22。这样，企业路由器只需通告10.24.0.0/22这一条路由，大大减小了路由表的规模。 网关 报文转发过程中，首先需要确定转发路径以及通往目的网段的接口，然后将报文封装在以太帧中通过指定的物理接口转发出去。如果目的主机与源主机不在同一网段，报文需要先转发到网关，然后通过网关将报文转发到目的网段。网关是指接收并处理本地网段主机发送的报文并转发到目的网段的设备。为实现此功能，网关必须知道目的网段的IP地址。网关设备上连接本地网段的接口地址即为该网段的网关地址。 IP包分片 网络中转发的IP报文的长度可以不同，但如果报文长度超过了数据链路所支持的最大长度，则报文就需要分割成若干个较小的片段才能够在链路上传输。将报文分割成多个片段的过程叫做分片。接收端根据分片报文中的标识符（Identification），标志（Flags)，及片偏移（Fragment Offset）字段对分片报文进行重组。标识符用于识别属于同一个数据包的分片，以区别于同一主机或其他主机发送的其它数据包分片，保证分片被正确的重新组合。标志字段用于判断是否已经收到最后一个分片。最后一个分片的标志字段设置为0，其他分片的标志字段设置为1，目的端在收到标志字段为0的分片后，开始重组报文。片偏移字段表示每个分片在原始报文中的位置。第一个分片的片偏移为0，第二个分片的片偏移表示紧跟第一个分片后的第一个比特的位置。比如，如果首片报文包含1259比特，那么第二分片报文的片偏移字段值就应该为1260。 生存时间 报文在网段间转发时，如果网络设备上的路由规划不合理，就可能会出现环路，导致报文在网络中无限循环，无法到达目的端。环路发生后，所有发往这个目的地的报文都会被循环转发，随着这种报文逐渐增多，网络将会发生拥塞。为避免环路导致的网络拥塞，IP报文头中包含一个生存时间TTL（Time To Live）字段。报文每经过一台三层设备，TTL值减1。初始TTL值由源端设备设置。当报文中的TTL降为0时，报文会被丢弃。同时，丢弃报文的设备会根据报文头中的源IP地址向源端发送ICMP错误消息。 协议号 目的端的网络层在接收并处理报文以后，需要决定下一步对报文该做如何处理。IP报文头中的协议字段标识了将会继续处理报文的协议。与以太帧头中的Type字段类似，协议字段也是一个十六进制数。该字段可以标识网络层协议，如ICMP（Internet Control Message Protocol，因特网控制报文协议），也可以标识上层协议，如TCP（Transmission Control Protocol，传输控制协议，对应值0x06）、UDP（User Datagram Protocol，用户数据包协议，对应值0x11）。 本章总结 问：子网掩码的作用是什么？
答：32位的IP子网掩码用于区分IP地址中的网络号和主机号。网络号表示网络或子网，主机号表示网络或子网中的主机。
问：IP报文头部中TTL字段的作用是什么？
答：如果网络中存在环路，则IP报文可能会在网络中循环而无法到达目的端。TTL字段限定了IP报文的生存时间，保证无法到达目的端的报文最终被丢弃。
问：网关的作用是什么？
答：网关是指接收并处理本地网段主机发送的报文并转发到目的网段的设备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e07f20000d76d81806f2805bc45dbf07/" rel="bookmark">
			Flash、Ajax各自的优缺点，在使用中如何取舍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flash 和 Ajax 都是用于 Web 开发的技术，各自有一些优缺点。在使用中取舍需要根据具体的需求和情况来决定。
Flash 的优点包括： 动画和多媒体效果丰富：Flash 可以创建非常丰富的动画和多媒体效果，适合制作交互式内容和游戏。跨平台性好：Flash 可以在多个平台上运行，并且拥有相对统一的外观和行为。较强的交互性：Flash 支持复杂的用户交互，可以实现丰富的用户体验。 Flash 的缺点包括： 对 SEO 不友好：搜索引擎很难解析 Flash 内容，因此 Flash 页面的搜索引擎排名通常较低。安全性问题：Flash 存在安全漏洞，容易成为恶意攻击的目标。移动设备支持差：随着移动设备的普及，Flash 在移动设备上的支持逐渐减弱。 Ajax 的优点包括： 异步加载：Ajax 可以在不刷新整个页面的情况下向服务器请求数据，提高用户体验。提升性能：通过减少页面刷新次数，减轻服务器压力，提高页面加载速度。较好的 SEO：Ajax 技术可以被搜索引擎解析，有利于网站的搜索引擎优化。 Ajax 的缺点包括： 对 JavaScript 依赖性强：Ajax 技术需要浏览器支持 JavaScript，对于禁用 JavaScript 的用户可能会造成问题。跨域限制：由于安全策略，Ajax 请求受到同源策略的限制，跨域请求需要特殊处理。状态管理复杂：由于页面局部刷新，状态管理可能变得复杂，需要更多的前端开发工作。 在使用中，应该根据具体的项目需求和情况进行取舍。如果需要丰富的动画和交互效果，并且对 SEO 要求不是很高，可以选择使用 Flash；如果需要提升性能和用户体验，并且对 SEO 要求较高，可以选择使用 Ajax 技术。同时，也可以考虑使用 HTML5 技术替代 Flash，以获得更好的性能和跨平台支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6535a6132978882e13f93aa77b3c87b8/" rel="bookmark">
			ctfshow中web入门第web41
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ctfshow中web入门第web41 ​​
留下了|运算绕过的方法那么直接利用脚本即可。
先用or运算的php脚本生成需要的规则文件(.txt文件)。如下图直接把需要绕过的正则替换成题目的正则就好：
​​
再用python脚本基于刚刚生成的txt文件跑出payload，如下图：
​​
结果中的分号需要去除。就ok了。
​​
利用代码：
//php或运算绕过脚本 &lt;?php $myfile = fopen("res_xor.txt", "w"); $contents=""; for ($i=0; $i &lt; 256; $i++) { for ($j=0; $j &lt;256 ; $j++) { if($i&lt;16){ $hex_i='0'.dechex($i); } else{ $hex_i=dechex($i); } if($j&lt;16){ $hex_j='0'.dechex($j); } else{ $hex_j=dechex($j); } $preg = '/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\{|\}|\&amp;|\-/i';//根据题目给的正则表达式修改即可 if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){ echo ""; } else{ $a='%'.$hex_i; $b='%'.$hex_j; $c=(urldecode($a)|urldecode($b)); if (ord($c)&gt;=32&amp;ord($c)&lt;=126) { $contents=$contents.$c." ".$a." ".$b."\n"; } } } } fwrite($myfile,$contents); fclose($myfile); //php异或绕过脚本 &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6535a6132978882e13f93aa77b3c87b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb37adb6c55b941c4042b45aabe23829/" rel="bookmark">
			Matlab论文插图绘制模板第132期—函数等高线填充图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的文章中，分享了Matlab函数折线图的绘制模板：
函数三维折线图：
函数网格曲面图：
函数曲面图：
函数等高线图：
进一步，再来分享一下函数等高线填充图。
先来看一下成品效果：
特别提示：本期内容『数据+代码』已上传资源群中，加群的朋友请自行下载。有需要的朋友可以关注同名公号【阿昆的科研日常】，后台回复关键词【绘图桶】查看加入方式。
模板中最关键的部分内容：
1. 数据准备
此部分主要是构造绘图数据并初始化绘图参数。
% 函数构造f = @(x,y) sin(2*x) + cos(2*y);% 初始化绘图参数LevelStep = 0.2;Fill = 'on';LW = 1; 2. 颜色定义
作图不配色就好比做菜不放盐，总让人感觉少些味道。
但颜色搭配比较考验个人审美，需要多加尝试。
这里直接使用TheColor配色工具中的SCI权威配色库：
%% 颜色定义map = TheColor('sci',2068);% map = flipud(map); 3. 函数等高线填充图绘制
通过调用‘fcontour’命令，绘制初始函数等高线填充图。
h = fcontour(f,'LevelStep',LevelStep,... 'Fill',Fill,... 'LineWidth',LW);hTitle = title('FcontourFilled Plot');hXLabel = xlabel('XAxis');hYLabel = ylabel('YAxis'); 4. 细节优化
为了插图的美观，对坐标轴细节等进行美化：
% 赋色colormap(map)colorbar% 坐标轴美化set(gca, 'Box', 'off', ... % 边框 'LineWidth', 1,... % 线宽 'Layer','top',... % 图层 'XGrid', 'off', 'YGrid', 'off', .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb37adb6c55b941c4042b45aabe23829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90289025477bb70df1211012b7f0ac0b/" rel="bookmark">
			go ioc三方库推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Go 语言中，没有像 Spring Boot 这样的完整的 IOC（Inversion of Control）框架。Go 语言的设计哲学更倾向于简洁、轻量级的解决方案，没有像 Java 的 Spring Framework 这样重量级的 IOC 容器。
然而，Go 社区中有一些简化依赖注入和控制反转的库和框架，它们提供了一些基本的 IOC 功能。以下是一些流行的 Go 语言中支持依赖注入和控制反转的库和框架：
1. **Wire**：Wire 是一个用于 Go 语言的依赖注入库，它使用代码生成和静态分析来自动解析依赖关系。它提供了一种简单的方式来定义依赖关系，并生成用于初始化依赖关系的代码。
2. **Gin**：Gin 是一个流行的 Web 框架，它提供了一些基本的依赖注入功能。你可以使用 Gin 的中间件机制来注入依赖项，并在处理 HTTP 请求时访问它们。
3. **Dig**：Dig 是一个简单的依赖注入库，它提供了一种声明式的方式来定义和解析依赖关系。它支持构造函数注入和字段注入，并提供了一些依赖关系的生命周期管理功能。
4. **Fx**：Fx 是一个轻量级的依赖注入框架，它专注于简单和可靠的依赖注入。Fx 使用构造函数注入来解析依赖关系，并提供了一些生命周期管理功能。
这些库和框架提供了一些基本的 IOC 功能，但它们不像 Java 的 Spring Framework 那样全面和复杂。在 Go 语言中，通常更倾向于简洁和模块化的设计，使用特定的库和组件来实现特定的功能，而不是依赖一个完整的 IOC 框架。根据你的具体需求，你可以选择适合你的项目的库或框架来处理依赖注入和控制反转的需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b6fe3e2ad8f67df5d826be1259fba9/" rel="bookmark">
			Linux命令的操作练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建ss别名，查看长格式详细信息
alias ss='ls -l'
2.创建ss别名，复制boot文件夹下的内容到data文件夹下
alias ss='cp -r /boot /data' 3.删除别名ss
unalias ss
4. 复制test文件夹下的passwd文件到qq文件夹下，并改名为ww
cp test/passwd qq/ww
5. 把当前文件夹下的，test文件，复制到当前用户的家目录下
cp -r test ~
6.将qq文件夹移动到ww文件夹下
mv qq ww
7.查找名为qq的文件
find -name qq
8.请找到 /var/log/ 文件夹下 30天以前，大于1G 已 log 结尾的普通文件，并将找到的文件移动到/opt下
find /var/log -mtime +30 -size +1G -type f -name "*log" -etc mv {} /opt \;
9.给test文件夹的passwd文件做软连接，到qq文件夹下，改名为ww
ln -s /test/passwd /qq/ww
10.删除test文件
rm test
11.删除qq文件夹
rm -rf qq 1.创建一个xzq文件夹
mkdir xzq
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b6fe3e2ad8f67df5d826be1259fba9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254e03c117ca593746f5d1c7b919400c/" rel="bookmark">
			音视频技术开发周刊 | 325
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每周一期，纵览音视频技术领域的干货。
新闻投稿：contribute@livevideostack.com。
AI读心术震撼登顶会！模型翻译脑电波，人类思想被投屏｜NeurIPS 2023
在最近举办的NeurIPS大会上，研究人员展示了当代AI更震撼的应用场景——AI读心术！
OpenAI「登月计划」剑指超级AI！LeCun提出AGI之路七阶段，打造世界模型是首位
OpenAI「登月计划」笃定了超级人工智能必定会到来，甚至近在眼前。而在LeCun看来，实现AGI还很遥远，打造出世界模型仅是这第一步。
AI首次攻克难倒陶哲轩数学难题，DeepMind里程碑算法登Nature！LLM搜代码自我进化
困扰数学家多年、让陶哲轩直呼喜欢的上限集问题数学难题，竟然被DeepMind的新算法破解了？这是史上首个用LLM发现的算法，堪称里程碑级研究，一经发布立马登Nature。
视频生成可以无限长？谷歌VideoPoet大模型上线，网友：革命性技术
2023 年底，科技公司都在冲击生成式 AI 的最后一个关卡 —— 视频生成。谷歌提出的视频生成大模型上线，立刻获得了人们的关注。这款名为 VideoPoet 的大语言模型，被人们认为是革命性的 zero-shot 视频生成工具。
NeurIPS 2023 Spotlight | 腾讯AI Lab绝悟新突破：在星际2灵活策略应对职业选手 近日，腾讯 AI Lab 的游戏 AI 团队宣布了其决策智能 AI "绝悟" 在《星际争霸 2》中的最新研究进展，提出一种创新的训练方法显著提升了 AI 的局内策略应变能力，使其在考虑了 APM 公平的对战环境中，与 3 位国内顶尖的神族职业选手各进行多达 20 局神族 vs 神族的对战，稳定地保持 50% 及以上的胜率。该成果已获 NeurIPS 2023 Spotlight 论文收录。 卷生成式AI的旗舰手机，2024年会引发一场交互革命
最近，各家手机厂商都在不约而同地做着一件事：把生成式 AI 搬上手机。先是在 10 月份的骁龙峰会上，小米放出消息，能在手机端侧运行的 60 亿参数大模型。
阿里文生视频挑战Gen-2、Pika，1280×720分辨率无压力，3500万文本-视频对显奇效
文生视频可以精细到什么程度？最近，阿里巴巴的一项研究给出了答案：1280×720 分辨率没有压力，而且生成效果非常连贯。
美图AI动漫功能的落地探索
2022年可以说是AIGC技术的元年，LLM领域的GPT和图像领域的Stable Diffusion，都属于行业的颠覆性技术。在图像领域，业界出现了如DALLE，Midjourney等基于简单描述文本生成图像的模型和工具。美图在2022年以来，发布了多项AIGC相关应用，LiveVideoStackCon 2023深圳站 邀请到了美图 影像研究院李骈臻老师分享相关经验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/254e03c117ca593746f5d1c7b919400c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca2ca6ea1e79182e8bdcccb877842b3f/" rel="bookmark">
			Export Spreadsheets to CSV WinForms App -Spread.NET
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Export Spreadsheets to CSV in WinForms Apps December 21, 2023
Exporting to CSV unlocks universal compatibility and simplifies data sharing across platforms and applications.
The ability to export to comma-separated values (CSV) from a spreadsheet control enhances interoperability and data accessibility. It seamlessly translates spreadsheet data into the ubiquitous CSV format, fostering effortless integration with a vast ecosystem of analytical tools, databases, and third-party applications. This democratizes your data, empowering users to leverage existing workflows and external expertise, enriching analysis, and maximizing the reach and impact of your data-driven insights.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca2ca6ea1e79182e8bdcccb877842b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/722e6b6f5a718a143b2fc0c42d9041ee/" rel="bookmark">
			vivado 输出延迟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出延迟
set_output_delay命令指定输出端口相对于设计接口处的时钟边缘。
当考虑应用板时，此延迟表示以下各项之间的相位差：
1.数据从FPGA的输出封装引脚通过板传播到另一个设备，以及
2.相对基准板时钟。
输出延迟值可以是正的，也可以是负的，这取决于相对的时钟和数据相位在FPGA之外。
使用输出延迟选项
尽管-clock选项在SDC标准中是可选的，但Vivado Design需要它套件工具。
相对时钟可以是设计时钟，也可以是虚拟时钟。
输出延迟命令选项包括：
•最小和最大输出延迟命令选项
•时钟下降输出延迟命令选项
•添加延迟输出延迟命令选项
最小和最大输出延迟命令选项
-min和-max选项为最小延迟分析（保持/删除）和最大延迟分析（设置/恢复）。如果两者都不使用，则输出延迟值适用于两个最小值和最大。
时钟下降输出延迟命令选项
-clock_fall选项指定输出延迟约束应用于定时路径由相对时钟的下降时钟沿捕获。如果没有此选项，Vivado IDE默认情况下仅假设相对时钟的上升沿（在设备外部）。不要将-clock_fall选项与-rise和-fall选项混淆。这些选项指的是数据边缘而不是时钟边缘。
添加延迟输出延迟命令选项
在以下情况下，必须使用-add_delay选项：
•最大输出延迟约束已经存在，并且
•您希望在同一端口上指定第二个最大输出延迟约束。
对于最小输出延迟约束也是如此。此选项通常用于约束相对于一个以上时钟边沿的输出端口，例如DDR中的上升沿和下降沿接口，或者当输出端口连接到使用不同时钟的几个设备时。
set_output_delay命令选项的使用
以下示例介绍了set_output_delay命令选项的典型用法。对于有关输出延迟约束方法的其他信息，请参阅中的此链接《FPGA和SoC的超快设计方法指南》（UG949）。
输出延迟示例一
此示例定义了相对于先前定义的sysClk的min和的输出延迟最大分析。
&gt; create_clock -name sysClk -period 10 [get_ports CLK0] &gt; set_output_delay -clock sysClk 6 [get_ports DOUT] 输出延迟示例二
此示例定义了相对于先前定义的虚拟时钟的输出延迟。
&gt; create_clock -name clk_port_virt -period 10 &gt; set_output_delay -clock clk_port_virt 6 [get_ports DOUT] 输出延迟示例三
此示例指定相对于DDR时钟的输出延迟值，该值为min的不同值（保持）和最大（设置）分析。
&gt; create_clock -name clk_ddr -period 6 [get_ports DDR_CLK_IN] &gt; set_output_delay -clock clk_ddr -max 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/722e6b6f5a718a143b2fc0c42d9041ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113afb79f5c491012c740eede5979673/" rel="bookmark">
			机器学习之实验过程01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
data_path = '/home/py/Work/labs/data/SD.csv' # 请确保您的数据文件路径是正确的
df = pd.read_csv(data_path)
df.head()
# 创建散点图 # 创建散点图 plt.figure(figsize=(10, 6)) plt.scatter(df['成本'], df['价格'], color='blue', label='Data Spot') plt.title('Cost vs Price') plt.xlabel('Cost') plt.ylabel('Price') plt.legend() plt.grid(True) plt.show() plt.savefig('test.jpg') 实现梯度下降算法来优化线性回归模型的参数
def gradient_descent(X, y, learning_rate=0.01, iterations=100): """ 实现梯度下降算法来优化线性回归模型的参数。 """ m = len(y) X = np.hstack((np.ones((m, 1)), X)) # 添加一列 1 作为偏置项 theta = np.zeros(X.shape[1]) loss_history = [] for _ in range(iterations): predictions = X.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/113afb79f5c491012c740eede5979673/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9dc89abd01c7d700ad2855bbfffc15c/" rel="bookmark">
			【单调栈】LeetCode:2818操作使得分最大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者推荐 map|动态规划|单调栈|LeetCode975:奇偶跳
本文涉及的基础知识点 单调栈分类、封装和总结
题目 给你一个长度为 n 的正整数数组 nums 和一个整数 k 。
一开始，你的分数为 1 。你可以进行以下操作至多 k 次，目标是使你的分数最大：
选择一个之前没有选过的 非空 子数组 nums[l, …, r] 。
从 nums[l, …, r] 里面选择一个 质数分数 最高的元素 x 。如果多个元素质数分数相同且最高，选择下标最小的一个。
将你的分数乘以 x 。
nums[l, …, r] 表示 nums 中起始下标为 l ，结束下标为 r 的子数组，两个端点都包含。
一个整数的 质数分数 等于 x 不同质因子的数目。比方说， 300 的质数分数为 3 ，因为 300 = 2 * 2 * 3 * 5 * 5 。
请你返回进行至多 k 次操作后，可以得到的 最大分数 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9dc89abd01c7d700ad2855bbfffc15c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5e35f4519503dad34e403840dd7bc13/" rel="bookmark">
			微信小程序~如何设置页面的背景色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序~如何设置页面的背景色 众所周知，微信小程序每个页面由.json，.scss，.ts，.wxml这四个文件组成。
有的小伙伴会发现，需要给页面加背景色的时候，只需在此页面的.scss文件中写个page{background-color:
#f8f8f8;}就能生效，却不知其所以然。
这是因为微信小程序的每个页面，都有一个page根标签，见“调试器”中的wxml选项卡。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4fff5139abc91325ce36fff401bfd20/" rel="bookmark">
			springboot社区志愿服务平台-计算机毕设 附源码 71787
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot社区志愿服务平台 摘 要 科技进步的飞速发展引起人们日常生活的巨大变化，电子信息技术的飞速发展使得电子信息技术的各个领域的应用水平得到普及和应用。信息时代的到来已成为不可阻挡的时尚潮流，人类发展的历史正进入一个新时代。在现实运用中，应用软件的工作规则和开发步骤，采用Java技术开发，SpringBoot框架，采用的数据库是Mysql。建设社区志愿服务平台。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
本设计主要实现集人性化、高效率、便捷等优点于一身的社区志愿服务平台，完成后台首页、个人资料（个人信息、修改密码）、播图管理、公告管理、系统用户（普通用户、管理用户、管理员）模块管理（社区新闻、志愿活动、活动分类、报名信息、活动签到、签到信息、活动签退、签退信息、留言记录）等功能模块。系统通过浏览器与服务器进行通信，实现数据的交互与变更。本系统通过科学的管理方式、便捷的服务提高了工作效率，减少了数据存储上的错误和遗漏。
关键词：社区志愿服务平台，Java，SpringBoot，Mysql Spring boot+community volunteer service platform ABSTRACT The rapid development of science and technology has caused great changes in people's daily life. The rapid development of electronic information technology has made the application level of electronic information technology in all fields popular and applied. The arrival of the information age has become an irresistible fashion trend, and the history of human development is entering a new era.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4fff5139abc91325ce36fff401bfd20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1685f279c9e6446f5d1dbb2e0578ca2a/" rel="bookmark">
			基于YOLOv8深度学习的200种鸟类智能检测与识别系统【python源码&#43;Pyqt5界面&#43;数据集&#43;训练代码】目标检测、深度学习实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《博主简介》
小伙伴们好，我是阿旭。专注于人工智能、AIGC、python、计算机视觉相关分享研究。
✌更多学习资源，可关注公-仲-hao:【阿旭算法与机器学习】，共同学习交流~
👍感谢小伙伴们点赞、关注！
《------往期经典推荐------》
一、AI应用软件开发实战专栏【链接】
项目名称项目名称1.【人脸识别与管理系统开发】2.【车牌识别与自动收费管理系统开发】3.【手势识别系统开发】4.【人脸面部活体检测系统开发】5.【图片风格快速迁移软件开发】6.【人脸表表情识别系统】7.【YOLOv8多目标识别与自动标注软件开发】8.【基于YOLOv8深度学习的行人跌倒检测系统】9.【基于YOLOv8深度学习的PCB板缺陷检测系统】10.【基于YOLOv8深度学习的生活垃圾分类目标检测系统】11.【基于YOLOv8深度学习的安全帽目标检测系统】12.【基于YOLOv8深度学习的120种犬类检测与识别系统】13.【基于YOLOv8深度学习的路面坑洞检测系统】14.【基于YOLOv8深度学习的火焰烟雾检测系统】15.【基于YOLOv8深度学习的钢材表面缺陷检测系统】16.【基于YOLOv8深度学习的舰船目标分类检测系统】17.【基于YOLOv8深度学习的西红柿成熟度检测系统】18.【基于YOLOv8深度学习的血细胞检测与计数系统】19.【基于YOLOv8深度学习的吸烟/抽烟行为检测系统】20.【基于YOLOv8深度学习的水稻害虫检测与识别系统】21.【基于YOLOv8深度学习的高精度车辆行人检测与计数系统】22.【基于YOLOv8深度学习的路面标志线检测与识别系统】22.【基于YOLOv8深度学习的智能小麦害虫检测识别系统】23.【基于YOLOv8深度学习的智能玉米害虫检测识别系统】 二、机器学习实战专栏【链接】，已更新31期，欢迎关注，持续更新中~~
三、深度学习【Pytorch】专栏【链接】
四、【Stable Diffusion绘画系列】专栏【链接】
《------正文------》
基本功能演示 摘要：智能鸟类检测与识别系统在生态保护、科学研究、野生动物监测、以及生态旅游等领域扮演着举足轻重的角色。本文基于YOLOv8深度学习框架，通过11788张图片，训练了一个进行鸟类智能检测与识别的目标检测模型,可检测200种不同鸟类。并基于此模型开发了一款带UI界面的鸟类智能检测与识别系统，可用于实时检测场景中的不同鸟类，更方便进行功能的展示。该系统是基于python与PyQT5开发的，支持图片、视频以及摄像头进行目标检测，并保存检测结果。本文提供了完整的Python代码和使用教程，给感兴趣的小伙伴参考学习，完整的代码资源文件获取方式见文末。
文章目录 基本功能演示前言一、软件核心功能介绍及效果演示软件主要功能（1）图片检测演示（2）视频检测演示（3）摄像头检测演示（4）保存图片与视频检测结果 二、模型的训练、评估与推理1.YOLOv8的基本原理2. 数据集准备与训练3. 训练结果评估4. 检测结果识别 【获取方式】结束语 点击跳转至文末《完整相关文件及源码》获取
前言 智能鸟类检测与识别系统在生态保护、科学研究、野生动物监测、以及生态旅游等领域扮演着举足轻重的角色。
首先，这类系统对生态保护有极其重要的影响，它能够帮助研究者和保护人员准确地监测鸟类种群的动态，评估受保护区域的生物多样性，及时发现稀有或濒危鸟种，从而制定更有效的保护措施。
其次，在科学研究领域，智能识别系统能够提供大量精确的鸟类观察数据，协助研究人员进行行为学、迁徙学和生态学的研究，加深人们对鸟类习性及其生态系统的理解。在野生动物监测方面，智能检测系统可以减少人为干扰，提高数据的收集效率和准确度，助力森林管理及非法狩猎的预防。
此外，在生态旅游业，鸟类检测与识别技术可以提升游客的体验，实现自动化识别和解说服务，让游客更深入地了解自然界的奥妙。
综上所述，智能鸟类检测与识别系统具有广阔的应用前景，不仅可以促进生态环境保护，还能够支持科学研究，提高监测效率，且对于推动生态文明建设和发展生态旅游具有积极作用。
博主通过搜集不同种类的鸟类的相关数据图片，根据YOLOv8的目标检测技术，基于python与Pyqt5开发了一款界面简洁的鸟类智能检测与识别系统，可支持图片、视频以及摄像头检测，同时可以将图片或者视频检测结果进行保存。
软件初始界面如下图所示：
检测结果界面如下：
一、软件核心功能介绍及效果演示 软件主要功能 1. 可进行200种鸟类的检测与识别，具体鸟类名称见数据集介绍部分;
2. 支持图片、视频及摄像头进行检测，同时支持图片的批量检测；
3. 界面可实时显示目标位置、目标总数、置信度、用时等信息;
4. 支持图片或者视频的检测结果保存；
（1）图片检测演示 点击图片图标，选择需要检测的图片，或者点击文件夹图标，选择需要批量检测图片所在的文件夹，操作演示如下：
点击目标下拉框后，可以选定指定目标的结果信息进行显示。 点击保存按钮，会对视频检测结果进行保存，存储路径为：save_data目录下。
注：1.右侧目标位置默认显示置信度最大一个目标位置。所有检测结果均在左下方表格中显示。
单个图片检测操作如下：
批量图片检测操作如下：
（2）视频检测演示 点击视频图标，打开选择需要检测的视频，就会自动显示检测结果。点击保存按钮，会对视频检测结果进行保存，存储路径为：save_data目录下。
（3）摄像头检测演示 点击摄像头图标，可以打开摄像头，可以实时进行检测，再次点击摄像头图标，可关闭摄像头。
（4）保存图片与视频检测结果 点击保存按钮后，会将当前选择的图片【含批量图片】或者视频的检测结果进行保存。检测的图片与视频结果会存储在save_data目录下。
二、模型的训练、评估与推理 1.YOLOv8的基本原理 YOLOv8是一种前沿的目标检测技术，它基于先前YOLO版本在目标检测任务上的成功，进一步提升了性能和灵活性。主要的创新点包括一个新的骨干网络、一个新的 Ancher-Free 检测头和一个新的损失函数，可以在从 CPU 到 GPU 的各种硬件平台上运行。
其主要网络结构如下：
2. 数据集准备与训练 通过网络上搜集关于不同鸟类的各类图片，并使用LabelMe标注工具对每张图片中的目标边框（Bounding Box）及类别进行标注。一共包含11788张图片，其中训练集包含5994张图片，验证集包含5794张图片，部分图像及标注如下图所示。
具体200种鸟类名称如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1685f279c9e6446f5d1dbb2e0578ca2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca12726e6f55a9ec848abe1ab7110df4/" rel="bookmark">
			Spark的核心概念：RDD、DataFrame和Dataset
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Spark，其核心概念包括RDD（Resilient Distributed Dataset）、DataFrame和Dataset。这些概念构成了Spark的基础，可以以不同的方式操作和处理数据，根据需求选择适当的抽象。
RDD（Resilient Distributed Dataset） RDD是Spark的基本数据抽象，它代表一个不可变、分布式的数据集合。下面我们将更详细地探讨RDD：
RDD的特性： 不可变性：一旦创建，RDD是不可更改的，这意味着您无法在原始RDD上执行修改操作。所有的转换操作都会生成新的RDD。分布式性：RDD的数据被分割并分布在集群的多个节点上，可以并行处理，这使得Spark非常适合大规模数据处理。容错性：Spark可以跟踪RDD的每一步操作，以便在节点失败时进行恢复，这确保了数据的可靠性和一致性。 RDD的创建方式： 可以从多种数据源创建RDD，包括从内存中创建、从磁盘或HDFS读取数据、从其他RDD转换等。
from pyspark import SparkContext sc = SparkContext("local", "RDD Example") # 从内存中创建RDD data = [1, 2, 3, 4, 5] rdd = sc.parallelize(data) # 从磁盘或HDFS读取数据创建RDD rdd = sc.textFile("data.txt") RDD的转换操作： RDD可以通过一系列的转换操作进行处理和转换，例如map、filter、reduce等，操作的示例：
# 使用map转换操作对RDD中的每个元素进行乘法操作 rdd = rdd.map(lambda x: x * 2) # 使用filter转换操作筛选出偶数 rdd = rdd.filter(lambda x: x % 2 == 0) # 使用reduce操作对RDD中的元素进行求和 total = rdd.reduce(lambda x, y: x + y) RDD的转换操作允许以弹性和分布式的方式处理数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca12726e6f55a9ec848abe1ab7110df4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/301f6d516b207c048911736c3f8f36d8/" rel="bookmark">
			GO语言基础笔记（四）：并发编程基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Goroutines
通道（Channel）
代码示例
Goroutines 定义与特点：
Goroutines是Go语言中实现并发的基本单位。它比传统的线程更轻量级，拥有更小的内存占用和更快的启动时间。在Go程序中，您可以轻松地启动成千上万的Goroutines。 使用方法：
使用go关键字后跟一个函数调用，即可启动一个Goroutine。例如：go myFunction() package main import ( "fmt" "time" ) // 定义一个简单的函数 func printNumbers(prefix string) { for i := 1; i &lt;= 5; i++ { fmt.Println(prefix, i) // 休眠一段时间，以模拟实际操作中的耗时 time.Sleep(time.Millisecond * 500) } } func main() { // 使用 go 关键字启动一个新的 Goroutine go printNumbers("Goroutine") // 主Goroutine也执行相同的函数 printNumbers("Main") // 等待足够长的时间以确保Goroutine完成 // 注意：这不是同步Goroutines的推荐方式 // 后续课程将介绍更好的方法（如WaitGroup或Channel） time.Sleep(time.Second * 3) fmt.Println("主函数执行完毕") } 函数定义：printNumbers函数接受一个字符串参数prefix，并打印出该前缀下的数值序列。启动Goroutine：使用go关键字启动printNumbers函数作为一个新的Goroutine。这意味着printNumbers("Goroutine")将并行执行。主Goroutine：主函数main本身也是一个Goroutine。在这里，它调用printNumbers("Main")，同样执行数值打印操作。并行执行：您会看到，"Goroutine"和"Main"的输出是交替出现的，显示了两个Goroutine是同时运行的。等待结束：使用time.Sleep暂时等待Goroutine完成。这是为了演示目的；实际应用中我们会使用更加精确的同步机制。 在实际应用中，我们通常不使用time.Sleep来等待Goroutines完成，而是使用像通道（Channels）或sync.WaitGroup这样的同步机制。这个示例的目的是简单地展示Goroutines的并发执行。在后续课程中，我们将探讨更高级的同步技术和并发模式。 通道（Channel） 定义与作用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/301f6d516b207c048911736c3f8f36d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/195e97ff6407c82369f9e7b3bb6f85f3/" rel="bookmark">
			GO语言基础笔记（三）：复合类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入学习Go语言中的复合类型：数组、切片、映射（Map）和结构体。这些类型是构建复杂数据结构和实现复杂逻辑的基础。
目录
1. 数组（Array）
遍历数组
多维数组
数组作为函数参数 2. 切片（Slice）
切片的长度和容量
添加元素到切片
切片的切片操作
使用make创建切片 多维切片 遍历切片 3. 映射（Map）
检索映射中的元素
删除映射中的元素
使用make创建映射
遍历映射
4. 结构体（Struct）
结构体作为函数参数
使用指针操作结构体
定义结构体的方法
1. 数组（Array） 定义：数组是具有相同类型元素的固定长度序列。声明方式：var arr [n]Type，其中n是数组的长度，Type是存储元素的类型。特点：长度固定，一旦声明，长度不能改变。 var arr [5]int arr[0] = 1 fmt.Println(arr) // 输出：[1 0 0 0 0] 遍历数组 // 使用for循环遍历数组 for i := 0; i &lt; len(arr2); i++ { fmt.Printf("arr2[%d] = %d\n", i, arr2[i]) } // 使用for range遍历数组 for index, value := range arr2 { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/195e97ff6407c82369f9e7b3bb6f85f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/995d07e2f07262c8c025a6485d1597ea/" rel="bookmark">
			前端未死，顺势而生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 随着人工智能和低代码的崛起，“前端已死”的声音逐渐兴起。前端已死？尊嘟假嘟？快来发表你的看法吧！
一、“前端已死”因何而来？ 在开始讨论之前，首先要明确什么是“前端”。
所谓前端，主要涉及网站和手机App的开发和更新。
随着科技的飞速发展，人工智能（AI）和低代码开发平台迅速崛起，不可避免地对前端技术领域产生了的影响：改变开发模式，提高开发效率，降低技术门槛。于是很多公司对前端的招聘，在需求量比以前有所下降的同时，对求职者人的技术要求却在不断提高。在需求市场增速放缓、技术门槛提高的双重压力大背景下，求职竞争日益加剧，就业形势日趋严峻。
2020年，疫情突如其来，冲击前所未有。经济深陷泥潭，海量财富蒸发，贸易投资下挫，金融市场动荡，复苏动能匮乏。许多经济实体业务萎缩，生产停顿，失业上升，供需失调，产业链断裂，供应链紊乱。大型互联网公司纷纷裁员，小型互联网公司面临倒闭，可谓雪上加霜。
于是“Java 已死、前端已凉” 的言论开始在IT圈流传开来。到今年3月，鹅厂的最高级别T13前端工程师被裁了的消息传出，一石激起千层浪，不仅仅是火上浇油，而且似乎可以为“前端已死”盖棺定论了。
二、“前端已死”是否属实？ 宣判前端死刑是否合情合理合法，还得追根溯源，来探究其发展规律。
（一）伴随互联网发展大潮，网站兴起。
1994年4月20日，通过美国Sprint公司的一条64K国际专线，中关村地区教育与科研示范网络工程实现与国际互联网（NCFC）的全功能IP 连接。以此为开端，中国启动了全面铺设信息高速公路的工作。1996年，丁磊创办了网易公司；王志东成功地并购美国华渊资讯网，并更名为新浪网；张朝阳创办了搜狐的前身爱特信公司。1998年，新浪、网易转型门户，多家新闻门户创立，并随之开启了门户网站的繁荣时代。
（二）伴随着移动互联网发展大潮，手机App兴起。
2009年，移动互联网兴起。2010年被称为微博元年。2011年互联网平台全面开放。2012年，移动互联网用户首次超过PC用户，基于移动终端的各类App接踵而至，带动和影响着各行各业。 当互联网处于红利期时，企业触网上线建设网站、开发APP，发展电子商务、成为时髦，对IT人才需求激增，薪资也是水涨船高。“天下熙熙，皆为利来；天下攘攘，皆为利往。 ”会点儿HTML和CSS的都可以说自己是前端了，前端入门容易，薪资可观，上限还高，一时间人们对前端这一行业趋之若鹜，不管是本专业的，参加培训的，还是自学的，都不愁找不到工作，统统可以就业！这也导致前端从业者的水平普遍偏低。
随着互联网产业的发展，市场资源已经被互联网开发殆尽，各个行业也已经进入稳定期，互联网的红利期已经过去，行业增长进入平台期，企业没有更多的利润去养更多的人了，招聘需求有所降温，薪资增长放缓，甚至出现小幅回落。与此同时，随着人工智能（AI）迅速崛起和低代码开发平台技术的发展，企业对前端人员的技术要求与时俱进，一些人员被淘汰，出现裁员潮属于正常情况。
尽管前端行业经历了招聘需求下降、薪资增长放缓以及一些企业的裁员等诸多挑战，不过前端技术需求还是有的，就业市场并未完全消失，所以“前端未死”，只是要换一种活法。
三、前端技术走向何方？ 虽然行业可能会面临瓶颈，但前端技术仍然是互联网和移动互联网等领域的基石和核心。目前没有第二个技术代替前端。不过趋势和需求变了。
从行业发展趋势来看：在AI技术和低代码平台的赋能加持下，前端技术仍在迅速演进，也会更加成熟。从就业人员角度来看：新技术新方向不断涌现，门槛提高，掌握全栈是个优先考虑的大方向和加分项。从企业需求角度来看：前端既要懂基础底层，又要懂业务开发，还要善于沟通协作，会推进项目实施。
四、前端人员如何突围？ 前端仍然是数字时代的核心。
前端技术仍在迅速发展变革。
2009年基于TypeScript的Angular诞生2012年FaceBook推出开源React2013年Electron问世2014年Vue.js横空出世…… 开发框架换了又换，归根结底就是要提升开发效率，节约开发成本。 持续学习、拓宽技能、不断进取，提升实力，是成功突围的关键。
持续学习新技术，多学习一些前后端融合的知识，掌握全栈技能。掌握业务能力，学习一些产品、设计等方面的知识，拓展技术面。积极参与开源项目、贡献代码，展示学习能力，实现技术的积累。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bab1b772305a4c89a9675fff8e84660/" rel="bookmark">
			memory_profiler python 代码内存性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装
pip install memory_profiler 使用
# 在需要分析内存性能的函数前面添加修饰符 @profiler @profiler @profiler(precision = 4, stream=open("memory.info", "w+"))	# 配置精度，并且把结果输出到日志文件 def aaa()； a = [] b = [] c = [] for i in range(10): a.append(i) 运行
python -m memory_profiler test.py 可视化工具 mprof
python -m mprof run test.py	# 生成 memory perf 数据 python -m mprof plot memory.info	# 绘制 memory perf 图，并显示 python -m mprof plot memory.info --output=memory.png	# 绘制 memory perf 图，不显示，保存至当前路径 mprof 命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bab1b772305a4c89a9675fff8e84660/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c074271d0058be2bb2489eed4d1a80a9/" rel="bookmark">
			GO语言基础笔记（二）：控制结构与函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 控制结构 1.1 if-else 结构 基本形式：if 条件判断后跟着一个代码块。如果条件为真，则执行该代码块。else 语句：紧随 if 代码块后面，当 if 条件不成立时执行。else if：可以在 if 和 else 之间添加更多的条件判断。 package main import ( "fmt" ) func main() { score := 85 // 假设这是一个成绩 // 使用 if 判断成绩是否优秀 if score &gt;= 90 { fmt.Println("成绩优秀，等级：A") } else if score &gt;= 80 { // 当成绩不满足第一个 if 条件（即小于90），但满足 else if 条件时执行 fmt.Println("成绩良好，等级：B") } else if score &gt;= 70 { fmt.Println("成绩合格，等级：C") } else if score &gt;= 60 { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c074271d0058be2bb2489eed4d1a80a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29fd28466db41000f3d72e1cf83d9b75/" rel="bookmark">
			第十二章集合类总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		12.1 集合类概述
java.util包中提供了一些集合，这些集合类又称为容器。提到容器不难想到数组。集合类与数组的不同之处是：数组的长度是固定的，集合的长度是可变的；数组用来存放基本类型的数据，集合用来存放对象的引用。常用的集合有List集合、Set集合和Map集合，其中List集合与Set集合继承了Collection接口，各接口还提供了不同的实现类。
12.2 Collection接口
Collection接口是层次结构中的根接口，构成Collection的单位称为元素，Collection接口通常不能直接使用，但该接口提供了添加元素、管理数据的方法。由于List接口与Set接口都继承了Collection接口，因此这些方法对List集合与Set集合是通用的。Collection接口的常用方法如下：
例题12.1：向”购物车“添加商品
12.3 List集合
12.3.1 List接口的实现类
List接口的实现类有ArrayList类和LinkedList类，
ArrayList类底层是数组，LinkedList类的底层是链表。
ArrayList适合查，LinkedList适合删除插入。
例题12.2：举例说明List集合的常用方法
下标不能越界，否则会报错
12.4 Set集合
Set集合中的对象不按特定的方式排序，只是简单地把对象加入到集合中，但Set集合中不能包含重复对象。Set集合由Set接口的实现类组成。Set接口继承了Collection接口，因此包含Collection接口的所有方法。
Set接口常用的实现类有HashSet类与TreeSet类
HashSet不保证元素的顺序，元素的存储顺序可能会随着时间的推移而改变。 允许存储 null 元素（只能存储一个）。 不允许存储重复元素，如果试图添加一个已存在的元素，该操作将不会产生任何效果。HashSet 的内部实现基于哈希表（HashMap），它使用哈希函数来计算元素的存储位置。当你需要一个无序的、不允许重复元素的集合时，可以考虑使用HashSet。
TreeSet 是一个有序集合，它根据元素的自然顺序（或者通过自定义的比较器）来进行排序。 不允许存储 null 元素。 允许存储重复元素。TreeSet 的内部实现基于红黑树，这是一种自平衡二叉搜索树，保证了元素的有序性。当你需要一个有序的集合，并且想根据元素的自然顺序（或者自定义的比较器）来排序时，可以考虑使用 TreeSet。
例题12.3：使用TreeSet类实现自然（升序）排序 12.5 Map集合 Map 是 Java 集合框架中的一个接口，用于存储键值对（key-value pairs）的数据结构。它提供了将键映射到值的功能，可以通过键快速查找到对应的值。
12.5.1 Map接口
Map接口提供了将key映射到值的对象。一个映射不能包含重复的key，每个key最多只能映射到一个值。除集合的常用方法外，Map接口还提供了以下的特殊方法：
12.5.2 Map接口的实现类
Map接口的常用实现类有HashMap和TreeMap，简述如下：
HashMap: 基于哈希表实现，提供了快速的查找性能。 不保证元素的顺序，即不保证元素的插入顺序与遍历顺序一致。 允许使用 null 作为键和值。
TreeMap: 基于红黑树实现，提供了有序的键值对集合。 键是按照自然顺序或自定义排序规则进行排序的。 不允许使用 null 作为键。
例题12.4：输出Map集合中书号（键）和书名（值）
结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49ec3ec9c4ce07b21c387cac83bbcd17/" rel="bookmark">
			语音增强数据集总结【持续更新】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 语音增强数据集总结纯净语音AVSpeechCommon Voice(2019首次发布，至今一直在更新)Multi Lingual Speech(MLS) (2020）DidiSpeech（2021）VCTK（2019）（又名Voice Bank）AiShellLibriSpeechTIMIT 噪声AudioSetWHAM!(2019)DEMANDFSD50K（2021）Noise-92AudioSet 已经合好的公开语音增强数据集VoiceBank+DemandNISQANOISEX-92 真实带噪语音REAL-M(2021)DAPS（2014） 其他MUSAN（2015）BABEL（2011-）语音分离LibriMix(2020)AMI(2005) 语音增强数据集总结 语音增强的第一步一般是准备数据，包含带噪语音和纯净语音。一般这些数据都是人工合成的，以纯净语音和噪声数据为基础即可合出带噪语音信号。以下介绍一些语音增强领域常用的数据集。
纯净语音 AVSpeech 16kHz，由谷歌发布
干净语音，用于语音分离任务。音视频数据集(Audio-Visual Dataset)。
每条数据长度在3~10s，共计4700h，包括不同人种、不同语言和不同表情姿态的150,000个说话人。每条数据 &gt; 只出现一个说话人的面部和声音
数据分布如下图：
原文：Looking to Listen at the Cocktail Party: A Speaker-Independent Audio-Visual Model for Speech Separation
网页：https://looking-to-listen.github.io/avspeech/
github：http://looking-to-listen.github.io/
Common Voice(2019首次发布，至今一直在更新) 48kHz，16bit，MP3格式 截至2023/7/21,
该数据集包括112种语言的28118小时语音，可用于训练的数据共18652小时。具体分布可看官网。
论文：https://arxiv.org/abs/1912.06670
官网链接：https://commonvoice.mozilla.org/en/languages
因为数据集一直在更新，所以建议直接去官网看。
Multi Lingual Speech(MLS) (2020） 源自LibriVox有声读物的数据集 16kHz，8种语言。
44.6k小时的英语数据，以及总计6k左右的其他7种语言的数据
具体分布如下：
论文：https://arxiv.org/abs/2012.03411
链接：http://www.openslr.org/94/
DidiSpeech（2021） 普通话，由滴滴出行发布 共800小时，6000个说话人，采样率48kHz，位深度16 bit。
性别、地域分布和录音设备（IOS/Andorid）比例基本接近1:1。年龄分布为adults(&gt;=20): youths(13-19): children(&lt;13) = 5:3:2。
包括两个子集DidiSpeech-1和DidiSpeech-2。DidiSpeech-1对标VC（Voice Conversion）任务，包括4500个说话人，共572h，每个说话人的录音有50 parallel sentences（平行语句，每个说话人都说的相同的句子）和50 non-parallel sentences（不被重复的、每个人不同的内容）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49ec3ec9c4ce07b21c387cac83bbcd17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7540c45b800713e2cc063300e823ee49/" rel="bookmark">
			如何在linux安装软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.安装种类
1.编译安装：灵活性高，难度较大， 可以安装新版本
2.rpm安装：查软件信息，是否安装，文件列表
3.yum：是rpm的升级版本，解决rpm的弊端
rpm安装：
安装软件的时候必须要有安装包
途径：1.从网上找 2.该软件官网下载
命令：mount 、dev/sr0 /mnt
mount：挂载光盘
/dev/sr0 ：挂载的设备
mnt：挂载的文件（和系统中哪个文件夹做关联）
只要是外来设备想在linux里面使用，必须使用挂载
一般写入的是临时的 如要永远使用需要写到文件
最好使用空文件夹进行挂载，文件夹要存在
一个文件夹挂载多个设备 （1.光驱 2.磁盘 谁后挂显示谁，同一时间只能挂载一个）
一个设备可以挂载在多个文件夹上 abc
yum仓库
本地yum（自己既是服务端又是网络端）
网络yum（客户端和服务器端分开），要依靠网络
yum是rpm的升级版本，两者安装前提 必须要有安装包！！!
安装的流程！
1.客户端配置文件去寻找服务端（提供安装包）
2.客户端将元信息下载到本地（元信息：安装包的位置，安装的依赖关系）
3.根据元信息去下载对应的安装包到本地，然后安装
4.安装完成之后，再删除安装包
在本地yum中
服务器端不需要更改 vim、etc/yum.conf
客户端的配置文件夹： cd /etc/yum.repos.d 必须在此文件夹下面
配置文档的时候必须要以repo结尾！
配置文件的格式：
【local】---------仓库的描述，本地仓库
name=local （名字随便自己取）
baseurl = 服务器的位置 一定要跟挂载的文件夹一致 因为一致才可以访问安装包
gpgcheck=0 不需要验证 gpgcheck=1，此时需要验证
enabled=1 开启（无需操作 因为本身就是开启的状态）
baseurl解析
baseurl里面填写安装包的地址
file：// 本地位置 file：///mnt （表示本机光盘的挂载点在mnt上）
http：//网络位 https：.// 网络位置
操作及解析如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7540c45b800713e2cc063300e823ee49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9497da3b3b2ba3e94c66476a4b18fd6/" rel="bookmark">
			Linux服务器解压zip文件时出现错误：End-of-central-directory signature not found./cannot find zipfile directory……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 问题： Linux中使用 unzip命令解压zip文件 时出现以下错误：
End-of-central-directory signature not found. Either this file is not
a zipfile, or it constitutes one disk of a multi-part archive. In the
latter case the central directory and zipfile comment will be found on
the last disk(s) of this archive.
unzip: cannot find zipfile directory in one of ecshop.zip or
ecshop.zip.zip, and cannot find ecshop.zip.ZIP, period.
截图如下：差点给jar背锅了文件大小如下。
原因： 在windwdos或Linux中下载的文件不完整或文件传输过程中出现问题。
解决： 在浏览器中点击下载链接，直接下载到本地(文件一般没得问题)；使用 Xftp7 或者 scp命令 将文件上传至服务器，切莫使用secure CRT上传血的教训，给人整不会了；此时在服务器端使用 unzip命令解压文件 则没有问题。 总结： 有时候问题的出现可能不是unzip不能用，而是文件本身的问题，好了，我又帮你解决了一个坑，太难了呀！差点让unzip背锅了。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/28/">«</a>
	<span class="pagination__item pagination__item--current">29/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/30/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>