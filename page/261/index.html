<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec3ced9c57c7a06eab7864ab9cdcf41/" rel="bookmark">
			算法01-list取随机组合数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从一个list列表中，获取三个数之和为0的所有随机组合，且不重复
例：nums = [-1, 0, 2, 1, -2]
输出：[[-1, 0, 1], [0, 2, -2]]
扩展：四个数之和的所有组合，五个数之和的所有组合......
import copy from collections import Counter res = [] # 最终输出结果 def func(num_list, tmp): """ tmp: 存储随机组合的临时变量 """ if len(tmp) == 3: if sum(tmp) == 0: # 判断是否重复 new_tmp = copy.deepcopy(tmp) flag = True for data in res: if dict(Counter(data)) == dict(Counter(new_tmp)): flag = False break if flag: res.append(new_tmp) for i in range(len(num_list)): if len(tmp) &lt; 3: tmp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ec3ced9c57c7a06eab7864ab9cdcf41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f539c4be8c8d1c983b277ec4148f8eb6/" rel="bookmark">
			Python解释器及IDLE的使用图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Python解释器
想必大家都已经了解到Python是一种解释型语言，当我们装载了Python解释器之后，解释器会读取我们编写的程序并执行，我们会采用两种形式去使用解释器，他们分别是交互模式和文件模式。
1) 交互模式
交互模式指的是我们在终端进入Python或者在IDLE中输入一行代码执行一次的模式，在后面的学习中，部分例题会采用交互模式。
以我们刚装载好的IDLE为例来介绍一下交互模式，首先我们找到我们的Python解释器，在当前页面可以直接进行交互。
注：以交互模式运行时通常被称为Python shell
我们可以看到‘&gt;&gt;&gt;’这个符号，我们可以在他后面进行输入指令，首先我们来输入一条简单的指令看一下效果。
第一行为我们输入的信息，回车（enter）之后会看到第二行的信息，也就是解释器打印出的内容。(我们在一次交互模式下定义过的变量等都是可以重复使用的)
然后‘&gt;&gt;&gt;’再次出现等待我们的第二次指令的发送。
下面再展示几个实例，此时你也可以打开你的解释器进行练习。
在交互模式下如果出现错误代码系统会立刻报错。
交互模式在我们学习新内容的时候可以得到及时的调试并得到反馈。
2) 文件模式
尽管交互模式在调试的时候使用着很方便，但却不利于保存，它只是简单的执行并显示在屏幕上，我们在需要编写之后并保存下来就要采用文件模式。
我们可以创建一个文本文件并以.py结尾然后使用IDLE打开，或者在IDLE中直接点击File-&gt;New File进入一个文件，然后可以进行代码的编写。
先编写一段入门代码：
通过F5或者在Run中run Module执行文件。
运行结果如下：
3) 文件模式下进行交互
文件模式下是先编写程序然后运行到shell页面
然后我们运行它来进行交互
在交互的过程中，如果我们的主程序，也就是test.py是没有错误的，就可
以在交互页面一直进行操作，哪怕是语法错误也仍在当前文件下。但是如果我们主 程序（test.py）出 现了语法错误，那么出现错误的语句下面的语句都不会被执行。
我们来看个例子：
代码如下：
我们来研究分析一下当中间有一步为错误之后，后续语句是否会被处理。
2. 总结
通过这些例子想必大家可以认识到交互模式、文件模式、以及文件模式下使用Python shell进行交互，在程序出错的时候是处于一个什么样的状态，在学习过程中，推荐大家采用第二种方式去进行学习开发。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a709c1e294855a21f11237858baad659/" rel="bookmark">
			Socket.IO-Client-cpp的使用——C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Socket.IO C++基于Boost和WebSocket++，可在多平台上工作(跨平台)。此通信类似于websocket，但是不通用于websocket。
Sockect.io 与Websocket的区别 我在知乎上看到说明两者的区别，感觉比较详细
WebSocket和Socket.io之间的区别(译) - 知乎 (zhihu.com)
Sockect.IO编译 Socket.IO-Client-cpp编译——C++_十年之少的博客-CSDN博客
代码说明 我是比照着 官方的给的示例（socket.io-client-cpp-master/examples/QT/SioChatDemo）进行学习的，官方的示例说明网址是Socket.IO C++ | Socket.IO。
在.h文件上设置命名空间： using namespace sio; 获取套接字（socket），可获取含有命名的套件字，具体看需求； socket::ptr sock = _io-&gt;socket(); // socket::ptr sock = _io-&gt;socket("nsp"); 监听套接字的事件，如新消息、用户加入、用户离开等；需要用到socket::on函数，他有两种形式，如下 typedef std::function&lt;void(const std::string&amp; name,message::ptr const&amp; message, bool need_ack, message::list&amp; ack_message)&gt; event_listener_aux; typedef std::function&lt;void(event&amp; event)&gt; event_listener; void on(std::string const&amp; event_name,event_listener const&amp; func); void on(std::string const&amp; event_name,event_listener_aux const&amp; func); 很明显，示例里用的是第二种形式，回调函数的格式必须是：
void funcName (const std::string&amp; name,message::ptr const&amp; message,bool need_ack,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a709c1e294855a21f11237858baad659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c34001313f997e0decf25b653a5052/" rel="bookmark">
			在防火墙firewall中开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在生产中往往是不能关闭防火墙firewall的（以下操作是在linux中执行的） #补充一下查看防火墙的命令 #查看防火墙状态 systemctl status firewalld #关闭防火墙 systemctl stop firewalld #重启防火墙 systemctl restart firewalld #启动防火墙 systemctl start firewalld 现在是开启防火墙的状态下开启的8080的访问端口 1. 添加8080端口 firewall-cmd --zone=public --add-port=8080/tcp --permanent 2.设置指定ip访问端口 firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.100.10" port protocol="tcp" port="9200" accept" 3. 重启 firewalld firewall-cmd --reload #这步必须有！！！ 4. 查看是否生效 firewall-cmd --list-ports firewall-cmd --list-all 删除某个端口： firewall-cmd --zone=public --remove-port=8080/tcp --permanent 重启 firewalld firewall-cmd --reload #这步必须有！！！ 查看是否生效 firewall-cmd --list-ports 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fa0f41bf50e5d7892e492c4911b6280/" rel="bookmark">
			基础篇-现代数据库都有哪些锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有三种锁：写锁，读锁，范围锁。
写锁 又叫排它锁、X 锁。加了写锁之后，只有持有写锁的事务才能更新写入数据，其他事务不能再加读锁和写锁，也不能加范围锁。
读锁 又叫共享锁，S锁。加了读锁，还可以被其他事务加读锁。但是不能加写锁。当只有一个事务加读锁，这个事务可以升级为写锁。
范围锁 对某个范围的数据施加排他锁，而且是不能对这个范围数据进行新增写入的。比如
SELECT * FROM books WHERE price &lt; 100 FOR UPDATE;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c787f1662a721879ecb446ac44f2d28f/" rel="bookmark">
			3、Eureka服务发现与负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前面两节内容中，我们已经完成了Eureka服务注册中心的搭建，和服务的注册，本节我们将对服务的发现以及负载均衡策略进行分析
在Eureka中，服务发现是基于服务名称来获取服务列表，然后通过负载均衡策略，选择列表中合适的一项来进行服务的调用。
首先启动两个userUsevice服务： 1、在已启动的userService服务中右键，选择 Copy Configuration
2、在虚拟机参数 VM options 中设置 -Dserver.port=8082(端口号要和前一个服务不同)
3、启动我们设置好的第二个服务
4、我们再启动orderService服务和Eureka服务中心
5、将RestTemplate注入到Spring容器中，并添加 @LoadBalanced 注解实现负载均衡策略。
6、在orderService服务中，我们在业务层修改调用userService服务的的url，将ip端口的调用模式修改为userService的服务名称。
7、我们查看Eureka服务中心，可以看到已注册的服务，其中userService服务是一个列表，包含了8081，8082两个端口的服务。
8、我们通过requestMapping调用orderService的queryOrderByUserId方法。
9、我们查看userService服务其中一个端口的控制台，假设先看8081
可以看到控制台并没有任何输出，我们再查看8082:
可以看到该端口的服务执行了一条sql语句，很明显，orderService选择了8082端口的userService服务进行调用。
前面我们提到过，在Eureka中，服务发现是基于服务名称来获取服务列表，然后通过负载均衡策略，选择列表中合适的一项来进行服务的调用。因此在本案例中，orderService通过Eureka服务中心发现了需要调用的userService服务列表，然后通过负载均衡的方式选择了8082端口的userService服务进行服务调用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35fa2c216b3ec8851f5fb9f342b7d892/" rel="bookmark">
			android逆向必备工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 逆向用途 :
软件防护 : 根据逆向的方法针对性的开发防护策略 ;
算法研究 : 在没有源码的前提下 , 通过反编译 , 反汇编 , 拿到 Smali 代码 , 研究其产品的算法 , 实现途径 ;
接口分析 : 接入一个没有源码的第三方库 , 无法进行调试 , 出现问题后 , 可以使用逆向的方法 , 查找问题原因 , 解决相关问题 ; 找到问题后 , 修改汇编代码 , 然后重新打包 ;
数据采集 : 分析应用的数据 , 获取该应用的更新内容 , 运营信息 , 在 APP 中可以拿到一些非公开的数据 ;
调试分析 : 应用打包 , 混淆 , 加固 后上传到应用市场 , 如果某个分发渠道版本出现问题 , 可能就需要调试分析具体的这个 APK 包的问题 ; 结合源码与渠道包进行逆向分析, 查找问题原因；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35fa2c216b3ec8851f5fb9f342b7d892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eccf01476b0054956da79a48ee4ea25a/" rel="bookmark">
			【Servlet】什么是Servlet；常见状态码；Servlet API；Cookie和Session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Servlet 文章目录 Servlet1. Servlet是什么2. 第一个Servlet程序2.1 创建项目2.2 引入依赖2.3 创建目录2.4 编写代码2.5 打包程序2.6 部署程序2.7 验证程序 3. 更方便的部署方式(Smart Tomcat)3.1 安装Smart Tomcat插件3.2 配置Smart Tomcat插件 4. 常见的访问出错4.1 出现4044.2 出现4054.3 出现5004.4 出现"空白页面"4.5 出现"无法访问此网站"4.6 小结 5. Servlet运行原理6. Tomcat执行流程7. Servlet API7.1 HttpServlet1.核心方法2. 代码实例：处理GET请求3. 处理POST请求 7.2 HttpServletRequest1. 核心方法2. 打印请求信息3. 获取GET请求中的参数4. 获取POST请求中的参数(1)5. 获取POST请求中的参数(2)6. 获取POST请求中的参数(3) 7.3 HttpServletResponse1. 核心方法2. 示例：设置状态码3. 示例：自动刷新4. 示例：重定向 8. Cookie和Session8.1Cookie8.2 会话机制(Session)8.3 Cookie和Session的区别8.4 核心方法 9. 上传文件9.1 核心方法9.2 示例 1. Servlet是什么 Servlet是一种实现动态页面的技术，是一组Tomcat提供给程序猿的API，帮助程序猿简单高效的开发一个web app，主要是开发动态页面
静态页面也就是内容始终固定的页面，即使用户不同/时间不同/输入的参数不同，页面内容也不会发生变化。
动态页面就是用户不同/时间不同/输入的参数不同，页面内容会发生变化
构造动态页面的奇数有很多，每种语言都有意思额相关的库/框架来做这件事
Servlet就是Tomcat这个HTTP服务器提供给Java的一组API，来完成构建动态页面这个任务
Servlet主要做的工作
允许程序猿注册一个类，在Tomcat收到某个特定的HTTP请求的时候，执行这个类中的一些代码帮助程序猿解析HTTP请求，把HTTP请求从一个字符串解析成一个HttpRequest对象帮助程序猿构造HTTP响应，程序猿只要给指定的HttpResponse对象填写一些属性字段，Servlet就会自动的按照HTTP协议的方式构造出一个HTTP响应字符串，并通过Socket写回给客户端 2. 第一个Servlet程序 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eccf01476b0054956da79a48ee4ea25a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c573a07d9ed7177c9d75859db69ebd6/" rel="bookmark">
			【Android -- 面试】Android 知识点（四大组件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 文章目录 目录ActivityFragmentServiceBroadcast ReceiverContentProvider Activity 1. 说下 Activity 的生命周期？
参考回答：
在 Activity 的生命周期涉及到七大方法，分别是：
onCreate() 表示 Activity 正在创建，常做初始化工作，如 setContentView 界面资源、初始化数据
onStart() 表示 Activity 正在启动，这时 Activity 可见但不在前台，无法和用户交互
onResume() 表示 Activity 获得焦点，此时 Activity 可见且在前台并开始活动
onPause() 表示 Activity 正在停止，可做 数据存储、停止动画等操作
onStop() 表示 Activity 即将停止，可做稍微重量级回收工作，如取消网络连接、注销广播接收器等
onDestroy() 表示 Activity 即将销毁，常做回收工作、资源释放
另外，当 Activity 由后台切换到前台，由不可见到可见时会调用 onRestart()，表示 Activity 重新启动
2. 说下 Activity 的四种启动模式？
参考回答：
standard 标准模式：每次启动一个 Activity 就会创建一个新的实例
singleTop 栈顶复用模式：如果新 Activity 已经位于任务栈的栈顶，就不会重新创建，并回调
onNewIntent(intent) 方法
singleTask 栈内复用模式：只要该 Activity 在一个任务栈中存在，都不会重新创建，并回调
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c573a07d9ed7177c9d75859db69ebd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f0493b525d1f7a77549dbbe1d1d45cc/" rel="bookmark">
			macOS环境下ping通github.com（丢包率0%），以及安装homebrew
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ping不通的解决办法。-&gt;查找github.com的ip。-&gt;管理员模式下输入-&gt;在新打开的页面里按i，左下角会有“insert”-&gt;然后按esc，左下角insert标志消失，shift+zz保存更改-&gt;回到终端，ping github.com，丢包率0%。 安装homebrew1.终端输入安装命令2. 解决报错 参考网上多个教程才解决我的问题，所以干脆自己整理一个解决方式。 ping不通的解决办法。 -&gt;查找github.com的ip。 站长工具
得到一个IP地址。
-&gt;管理员模式下输入 vim /private/etc/hosts
-&gt;在新打开的页面里按i，左下角会有“insert” 然后粘贴
140.82.113.3 github.com
-&gt;然后按esc，左下角insert标志消失，shift+zz保存更改 -&gt;回到终端，ping github.com，丢包率0%。 安装homebrew 1.终端输入安装命令 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)" 在输入该命令之前，要保证可以打开这个网页。https://raw.githubusercontent.com/Homebrew/install/master/install.sh
如图即为成功打开。之后执行命令，看他的报错。
2. 解决报错 我遇到的第一个错误是
fatal: unable to access ‘https://github.com/Homebrew/brew/’: Failed to
connect to github.com port 443: Operation timed out Failed during: git
fetch origin --force
这个错误的意思就是连不上github.com，在我用上面的方法操作一番之后，错误变成了
curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused
这个错误比较好理解，就是不能链接到raw.githubusercontent.com，可以用和上面一样的方法解决。在站长工具中搜索raw.githubusercontent.com即可。之后就安装成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cc50761b1f96c393f68bbfb7fa564b8/" rel="bookmark">
			js中var let const区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var let const 0、结论一、var1、var可以重复声明，可以重新赋值2、var声明的变量存在变量提升3、var声明的变量，如果不初始化，值为undefined4、var在全局作用域下声明的变量挂载到window上，不存在块级作用域 二、let1、块级作用域2、暂时性死区 三、const1、声明后不可修改2、const声明的变量必须初始化 总结 js常见面试题之 var let const 的区别与用法 0、结论 var 声明的范围是函数作用域或全局作用域，let 和 const 声明的范围是块作用域
var 声明的变量会被提升到函数作用域的顶部，let 和 const 声明的变量不存在提升，且具有暂时性死区特征
var 允许在同一个作用域中重复声明同一个变量，let 和 const 不允许
在全局作用域中使用 var 声明的变量会成为 window 对象的属性，let 和 const 声明的变量则不会
var 或 let 语句声明的变量，如果没有初始化，则其值为 undefined。使用 const 声明的变量必须进行初始化，且不能被修改
var定义的变量，可以预解析提前调用的结果是undefined，let定义的变量不能预解析，提前调用的结果是 报错。
var定义的变量，变量名称可以重复，效果是重复赋值，let定义的变量不能重复，否则执行报错。
var定义的变量作用域是全局/局部作用域。let定义的变量如果在{}中只能在{}中调用。
在循环语句中var定义的循环变量和使用let定义的循环变量。执行原理和执行效果不同。
一、var 1、var可以重复声明，可以重新赋值 //var 关键字可以声明同名变量,实际第二次声明是对第一次声明的变量重新赋值 var num1 = 10; var num1 = 20; console.log(num1); // 20 ​ //let 和const 关键字不能重复声明同名变量,即使之前是用var声明的也会报错 var num2 = 10; let num2 = 20; // Uncaught SyntaxError: Identifier 'num2' has already been declared ​ //let 和 var 在声明变量时,可以不用初始化 let num3; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cc50761b1f96c393f68bbfb7fa564b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7076ef4549d50e3cb0201f08f15048ae/" rel="bookmark">
			立创EDA怎么实现圆形区域禁止铺铜
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先在需要禁止布线的层绘制圆
点击绘制的圆，然后右击鼠标，选择“转为实心填充”
（1）在类型选择“无填充”
（2）网络设置“无”，避免出现一样网络，铺铜后连接在一起，不能实现禁止填充
设置后的铺铜效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f9d78d1e04e3eb693c9199c51d347c/" rel="bookmark">
			oracle使用心得（4）——如何恢复被删除的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、使用步骤第一步：查询这个时间点的数据第二步：核对数据库系统时间第三步：执行这条语句把数据恢复到这个时间点第四步： 报错处理 总结 在实际开发的过程中，我们也许会有误删据的时候，但以下方法可以让你恢复删除的数据
一、使用步骤 第一步：查询这个时间点的数据 查询这个时间点的数据，看是否是自己需要的数据。
select * from tablename as of timestamp to_timestamp('2022-06-21 13:30:00','yyyy-MM-dd hh24:mi:ss') 第二步：核对数据库系统时间 有可能因为系统时间和数据库时间不一致查不出数据 所以先查询数据库的时间。
select to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual； 第三步：执行这条语句把数据恢复到这个时间点 flashback table tablename to timestamp to_timestamp('2022-06-21 13:30:00','yyyy-MM-dd hh24:mi:ss') 第四步： 报错处理 再执行第三步的时候可能会报下列错误
ORA-08189: 因为未启用行移动功能, 不能闪回表，需要开启行移动功能
执行下面语句处理错误
alter table tablename enable row movement； 总结 使用flashback 语句，将对应的表回滚为对应时间的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91e8e19ddc7c2e2ecacbd2c9f608026/" rel="bookmark">
			[C语言]宏定义#define的使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、宏定义定义常量
预定义符号
FILE //进行编译的源文件
LINE //文件当前的行号
DATE //文件被编译的日期
TIME //文件被编译的时间
STDC //如果编译器遵循ANSI C，其值为1，否则未定义
我们来看一段代码： #include &lt;stdio.h&gt; void test_define1() { printf("file name is %s\n", __FILE__); printf("line is %d\n", __LINE__); printf("date is %s\n", __DATE__); printf("time is %s\n", __TIME__); printf("stdc is %d\n", __STDC__); } int main() { test_define1(); return 0; } 输出结果：
预处理过程对宏定义的处理
在前面一节中我们了解到编译过程中有一步是预处理，我们再来看看编译过程：
其中预处理就包括了对宏定义的处理，预处理工作是系统引用预处理程序对源程序中的预处理部分做处理，而预处理部分是指以“#”开头的、放在函数之外的、一般放在源文件的前面的预处理命令，如：包括命令 #include，宏命令 #define 等，合理地利用预处理功能可以使得程序更加方便地阅读、修改、移植、调试等，也有利于模块化程序设计。
我们来看看一段代码： void test_define2() { #define PI 3.14 int R = 2; float S = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91e8e19ddc7c2e2ecacbd2c9f608026/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d422292ecdf90d215e91bd1fe23c27fd/" rel="bookmark">
			Error creating bean with name xxx Factory method ‘sqlSessionFactory‘ threw exception； nested excepti
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常日志：
Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'xxx': Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'xxx': Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'payRequestServiceImpl': Unsatisfied dependency expressed through field 'baseMapper'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'payRequestMapper' defined in file [E:\code\xxx\xxx\target\classes\orm\mapper\XxxMapper.class]: Unsatisfied dependency expressed through bean property 'sqlSessionFactory'; nested exception is org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d422292ecdf90d215e91bd1fe23c27fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd20640baec6ae48ff54e666dc4e07a/" rel="bookmark">
			PhpStorm 2022 for Mac(PHP集成开发)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PhpStorm 2022 for Mac是一款非常好用的PHP集成开发软件，Phpstorm提供强大的内置工具来调试，测试和分析您的应用程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb4ddc2c003309fd8c923f4fdc32b27a/" rel="bookmark">
			SAR几何畸变的原因是什么？主要有哪些类型？真实孔径雷达和合成孔径雷达的异同点是什么？SAR距离向分辨率和方位向分辨率为什么不同？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、SAR几何畸变的原因是什么？主要有哪些类型？ 由于SAR影像侧视成像的特点，在影像上会形成固有的几何特征，如距离向压缩、透视收缩、顶底位移和雷达阴影等
距离向压缩 侧视成像的几何结构是按地面点到天线中心的斜距进行投影的，如图所示，地面上两个目标点A和B在像平面上相对应的点为a和b，如果A和B相距比较近，可以视为∠ACB为直角，对应的地面距离Rg与斜距Rs之间关系为：Rs = Rg·sinθ
可知斜距Rs比地距 Rg小，而且同样大小的地面目标，离天线正下方越近，在影像上尺寸越小，因此在影像上存在近地点被压缩，远地点被拉伸的现象（都是压缩，但是在近地端比远地端更严重）
透视收缩 当雷达波束照射位于雷达天线同一侧的斜面时，如图所示，雷达波束到达斜面顶部的斜距Rs和到达底部的斜距Rs’之差ΔR比斜面对面的地距差ΔX小，在SAR影像上斜面长度被缩短，这样的现象称之为透视收缩，收缩比：l=ΔR/ΔX=sinφ/cosα
透视收缩是面向雷达波束的斜面投影到斜距平面时距离压缩增强现象，归根结底还是距离压缩图像上前坡总是比后坡距离压缩明显，透视收缩表明较大的回波面积集中体现在较小的图像区域，在强度图像上，前坡比后坡明亮入射角越小，透视收缩越严重，即近地端透视收缩严重，远地端次之。当入射角为零时，山顶、山腰、山底的回波集中到一点，出现最大透视收缩 透视收缩产生条件：
侧视角大于地面坡度角，二者相等时，收缩比达到极小值侧视角加坡度角小于等于90°时 顶底位移 当雷达波束到斜坡顶部的时间比雷达波束到斜坡底部的时间短的时候，顶部影像先被记录，底部影像后被记录，斜坡底部和顶部影像颠倒显示的现象成为顶底位移，如图所示，它是透视收缩的进一步发展
在起伏地形成像，当坡度与雷达俯角之和大于90度时（即当地入射角为负时），山顶部分的回波比来自山脚部分的回波更早被雷达接收记录，从而使山顶影像“叠置”在山脚影像之前
顶底位移也称雷达叠掩，是山顶部分的回波比山脚部分的回波更早被雷达接收记录，从而使山顶影像“叠置”在山底之前的图像失真现象叠掩现象与局部入射角θ密切相关：θ&lt;0°时，叠掩；0°&lt;θ&lt;90°时，透视收缩；90°&lt;θ时，阴影叠掩现象与雷达俯角也有关系，俯角越大，产生叠掩的可能性越大，因此叠掩多是近距离现象 雷达阴影 侧视雷达成像在距离向会产生雷达阴影。起伏地形的后坡雷达波束不能到达，没有回波信号，在图像相应位置出现暗区。有三种情况：
地形后坡坡度小于雷达俯角：不会产生阴影地形后坡坡度等于雷达俯角：视后坡粗糙度如何地形后坡坡度大于雷达俯角：产生阴影 侧视雷达阴影产生的规律：
雷达阴影是起伏地形的雷达影像在后坡出现暗区的图像缺失现象雷达阴影的产生与坡度及雷达俯角有关判断雷达阴影还要考虑山脊走向与卫星航向的关系，考虑真倾向与伪倾向的关系阴影区不含信息，但却是一种很好的观测方向和地形信息的指示器 二、真实孔径雷达和合成孔径雷达的异同点是什么？ 合成孔径雷达：是一种高分辨率相干成像雷达。高分辨率在这里包含两方面的含义：即高的方位向分辨率，足够高的距离向分辨率。**真实孔径雷达：**顾名思义其雷达天线长度是实际长度，雷达波的发射和接收都是以其自身有效长度的效率直接反映到显示记录中 真实孔径雷达和合成孔径雷达的区别 原理概念区别：RAR通过无线电波单次反射成像，SAR是利用一段时间内雷达与目标之间的相对位移，得出特征相干信号的变化，以取得比RAR更加精细的结果孔径大小区别：合成孔径雷达是利用合成孔径原理来改善方位向分辨率天线长度区别：真实孔径雷达的天线越长，接受到的信息越多，而合成孔径雷达的天线被集成在了一起，不需要有真实孔径雷达那么长的天线也可以接收到一样多的信息分辨率区别：真实孔径雷达分辨率分为距离向分辨率和方位向分辨率，且两者互不相关。合成孔径雷达的距离分辨率与真实孔径雷达距离向分辨率相同。真实孔径机载雷达一般用短脉冲来实现距离向分辨率，而合成孔径雷达通常用带宽（脉冲频率的变化范围）为B的线性调频脉冲来实现作用距离向的良好分辨率。合成孔径雷达的方位向分辨率与距离、波长无关，平台飞行高度无关，理论上方位分辨率是雷达天线真实孔径长度D的一半 PS
距离向分辨率指在脉冲发射方向上（距离向）能分辨两个目标的最小距离方位向分辨率是在与辐射波束垂直方向（方位向）上相邻的两束脉冲之间，能分辨两个目标的最小距离 真实孔径雷达和合成孔径雷达的联系 真实孔径雷达的工作原理：天线发出的一束无线电（或微波）辐射射向目标，电磁辐射与目标发生相互作用，其中有一部分背向散射返回到天线。雷达接收机探测到回波，从中可以知道目标的方位、距离和飞行速度等信息合成孔径雷达的工作原理：发射器产生的线性调频脉冲经放大后，馈送至天线发射出去，平台做等速直线飞行并保持天线的指向稳定，天线接收的地面回波信号，经接收系统混频、中放、相位检波等一系列的信号处理后，再送入存储器，存储器的信号经成像后形成雷达图像 三、SAR距离向分辨率和方位向分辨率为什么不同？ SAR图像分辨率包括距离向分辨率（Range Resolution）和方位向分辨率（Azimuth Resolution）。
距离向分辨率（Range Resolution） 在垂直于飞行方向上的分辨率，也就是侧视方向上的分辨率（所能分辨的目标间最小距离）。距离向分辨率与雷达系统发射的脉冲信号相关，与脉冲持续时间成正比：
Res(r) = τC / 2 其中C为光速，τ为脉冲持续时间。
距离分辨率与距离无关若要提高距离分辨率，需要减小脉冲宽度脉冲宽度小，则S/N降低，需加大发射功率，造成设备庞大，费用昂贵目前一般采用脉冲压缩技术来提高距离分辨率 方位向分辨率（Azimuth Resolution） 沿飞行方向上的分辨率，也称沿迹分辨率。如下为推算过程：
真实波束宽度：β = λ / D真实分辨率：ΔL = β * R = Ls（合成孔径长度）合成波束宽度：βs = λ / (2 * Ls) = D / (2 * R)合成分辨率：ΔLs = βs * R = D / 2 其中λ为波长，D为雷达孔径，R为天线与物体的距离。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb4ddc2c003309fd8c923f4fdc32b27a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f43fc5edcde20ebaf263c519bc52556/" rel="bookmark">
			开源SPL重新定义OLAP Server
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OLAP（Online Analytical Processing）是指在线联机分析，基于数据查询计算并实时获得返回结果。日常业务中的报表、数据查询、多维分析等一切需要即时返回结果的数据查询任务都属于OLAP的范畴。对应的，行业内也有相应产品来满足这类需求，那就是OLAP Server。
OLAP Server现状 当前主流OLAP Server几乎都是基于RDB或封装成RDB的大数据平台，有点类似早期的ROLAP（这个词已经很少被提及了），其中一个关键的特征是使用SQL作为查询语言。
RDB和SQL的特性会给OLAP Server带来诸多困难。
复杂报表困难 事实上，报表才是OLAP业务的重头戏，OLAP的查询需求中有相当大一部分都是事先做好的报表查询界面，而不是自由拖拽的多维分析，而复杂报表又经常占据报表需求的一半以上。这类报表的典型特点是数据处理逻辑复杂，每个报表都需要单独编写代码进行数据准备，最常见的做法是使用复杂SQL或存储过程，如果碰到一些数据库无法实现的场景（如文件等外部数据源、跨数据源计算、前后端分离等）还需要通过JAVA完成，过程十分繁琐。
SQL实现这些计算很难，存储过程也有很多缺点（无移植性、有安全隐患等）导致越来越少使用，Java集合运算困难且无法热切换而难以适应复杂多变的报表需求。当前OLAP Server在复杂报表这方面就表现的很不理想了。
自助关联差 即使不管复杂报表，只考虑多维分析的这种基础的OLAP任务，使用SQL作为查询语言时也很难胜任，只能解决一小部分无关联的单表分析，满足一些相对固定的多维分析需求，适用范围很小，难以适应灵活的自助分析场景。
体系封闭 当前OLAP Server严重依赖数据库，数据库有“库”的概念，数据只有“入库”才能处理，而且通常只能同时处理一个数据库，无法同时计算数据库外部的数据。而OLAP名为在线分析，业务上还要求做T+0式的实时查询分析。其他数据源的数据需要先ETL到数据库中才能计算，这就造成了不实时。典型的场景是OLAP业务经常要查询业务库的实时数据，要将实时数据（业务库）和历史数据（分析库）混合查询分析（T+0查询），这是当前OLAP Server难以满足的。何况还有很多非关系数据库的数据也无法被OLAP Server直接计算。
性能低 退一步来讲，即使只关注历史数据，不考虑实时生产数据，也只使用单一的数据库，当前OLAP查询也面临性能低的问题，我们经常会遇到查询报表要等几分钟、实时查询不实时、多维分析卡顿的情况。根本原因仍然是SQL的问题，基于关系代数理论的SQL难以实现高性能算法，仅靠数据库在工程上优化并不能根本解决问题，SQL复杂时数据库优化经常无效而导致性能仍然很低。
开源SPL重新定义OLAP Server SPL技术问世之后，将使OLAP Server的上述窘境大为改观。
SPL是结构化数据计算专用程序语言（Structured Process Language）的简称。SPL提供丰富的计算类库和敏捷的开发语法可以快速完成各类复杂数据处理；SPL的计算能力不依赖于数据库（数据源），天然支持多样性数据源，可以完成跨数据源混合计算，实现跨异构源的实时查询；SPL内置了大量高性能算法和存储方案以及并行计算机制保证计算的高性能。
敏捷的过程计算适应复杂报表 在复杂数据处理方面，SPL提供独立的敏捷语法支持过程计算，相对于SQL，SPL的语法更简洁，适合完成复杂报表数据准备。
比如要计算：一只股票最长连续上涨了多少天？
用SQL借助窗口函数还要写成四层嵌套的语句：
select max(continuousDays)-1 from (select count(*) continuousDays from (select sum(changeSign) over(order by tradeDate) unRiseDays from (select tradeDate, case when closePrice&gt;lag(closePrice) over(order by tradeDate) then 0 else 1 end changeSign from stock) ) group by unRiseDays) 而同样的逻辑用SPL写要简单得多：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f43fc5edcde20ebaf263c519bc52556/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5905726fe16cfe69a08ae4aa7e425473/" rel="bookmark">
			SQLyog 报错2058 ：连接 mysql 8.0.11 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置新连接报错：错误号码 2058，分析是 mysql 密码加密方法变了。
解决方法：windows 下cmd 登录 mysql -u root -p 登录你的 mysql 数据库，然后 执行这条SQL：
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';
#password 是你自己设置的root密码
然后在重新配置SQLyog的连接，则可连接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9440491f6bbf0ae49bb342e659fe806/" rel="bookmark">
			latex \textbf{} 字体加粗失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：
用latex写中文论文，用\textbf{}命令加粗指定文字
解决方案：
1. 对于中文无法加粗，检查是否引用了中文环境包
\usepackage{ctex} 2. 对于英文、数字无法加粗，引用字体编码设置包
\usepackage[T1]{fontenc} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97165ff5ecabe6452ea59a02bb1039aa/" rel="bookmark">
			基于人脸识别的考勤系统：Python3 &#43; Qt5 &#43; OpenCV3 &#43; FaceNet &#43; MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Contributor : datamonday
Github Repo : https://github.com/datamonday/Face-Recognition-Class-Attendance-System
Initial Blog : 基于人脸识别的考勤系统：Python3 + Qt5 + OpenCV3 + OpenFace + MySQL
Project Post : 2019.04.14
Last Update : 2021.05.25
文章目录 Update: 2021.05.251. 项目简介及声明2. 环境配置🎡2.1 Anaconda 创建虚拟环境2.2 安装所需要的包2.3 安装 dlib 3. 系统前端设计🤖3.1 主界面3.2 信息采集界面 4. 系统功能介绍🛵4.1 信息采集功能4.2 人脸识别简介4.3 活体检测简介4.4 查询考勤信息4.5 查询学生信息4.6 补签及请假登记 5. 数据库存取信息🥗5.1 数据库可视化工具 Navicat5.2 创建MySQL数据库5.3 MySQL表格及字段说明5.4 PyMySQL 使用5.5 本地 Excel 表格说明（测试中）Auxiliary_Info.xlsxClassroom_Info.xlsxCollege_Class_Info.xlsxClassroom_Course_Schedule.xlsxAttendance_Logs.xlsx 6. 源码介绍及使用🍨6.1 代码目录树6.2 关键文件说明6.3 需要修改源码部分6.4 使用步骤6.5 人脸识别结果 7. 问题及解决方案7.1 闪退Bug1）查看结果按键闪退2）训练模型按键闪退3）开始识别按键闪退 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97165ff5ecabe6452ea59a02bb1039aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb6d9c3a864cb876b0d8dee59872e89/" rel="bookmark">
			win11在cmder中使用vim查看内容的时候空白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依次选择，最终打上个√就可以了
“Show system menu (RCIickfcr Settings)” -》 “Debug” -》 “properties” -》 “Use legacy console (requires relaunch, affects all consoles)”
一句话概括，使用旧版
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dda09f3f4c6553e8283d3aae899a85dd/" rel="bookmark">
			数学建模——线性规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本概念
模型求解和应用
基于求解器的求解方法
基于问题的求解方法
其他 基本概念 运筹学的一个重要分支是数学规划，线性规划是数学规划的一个重要的分支。
变量称为决策变量，规划的目标称为目标函数，限制条件称为约束条件，s.t.是“受约束于”的意思。
建立线性规划模型的一般步骤为：①分析问题，找出决策变量。②找出等式或不等式约束条件。③构造关于决策变量的一个线性函数。
线性规划模型的一般形式：
或：
为目标函数的系数向量，又称为价值向量；为决策向量；为约束方程组的系数矩阵；为约束方程组的常数向量。
还有标准型：
目标函数为极大型，约束条件为等式约束。满足约束条件的解为可行解，使目标函数达到最大值得可行解角叫最优解。所有可行解构成的集合叫做可行域，记为R。
在数学规划问题求解过程中，一定还要计算灵敏度分析。灵敏度分析指系统因周围条件变化显示出来的敏感程度的分析。线性规划问题的a、b、c都设定为常数，但是在实际过程中，这些系数都会有少许的变动。
模型求解和应用 MATLAB中求解数学规划的问题有两种模式：基于求解器的求解方法和基于问题的求解方法，
基于求解器的求解方法 需要将线性规划化为标准形式：
要求目标函数必须是最小化，约束条件分为小于等于约束和等号约束，lb和ub是决策变量上下界。
MATLAB函数调用格式为：
[x,fval] = linprog(f,A,b)
[x,fval] = linprog(f,A,b,Aeq,beq)
[x,fval] = linprog(f,A,b,Aeq,beq,lb,ub)
x返回的是决策变量的取值，fval返回的是目标函数的最优值，f为价值向量，A,b对应的是线性不等式约束，Aeq和beq对应的是线性等式的约束，lb和ub分别对应决策向量的下界向量和上界向量。
这种方法只能应用于决策向量是一维的情况。
基于问题的求解方法 首先用变量和表达式构造优化问题，然后用solve函数求解，可以用doc optimproblem查看帮助。
①prob=optimproblem('ObjectiveSense','max');
ObjectiveSense可以是max和min，代表优化最大值还是最小值，默认是min
②定义f，A，b（同上，f可以定义为行向量，这样目标函数不同再转置）
③x=optimvar('x',2,1,'TYPE','integer','LowerBound',0,'UpperBound',inf);
第一个‘x’里面是变量名，列向量，后面是存在几行几列。
‘TYPE’，后面定义的是该函数所属类型，比如说integer整数型，double双精度型号
‘LowerBound'与'UpperBound'表示下界与上界所跟的0，inf分别是范围
④prob.Objective=f * x;%目标函数，目标函数需要得到一个标量数值，不是矩阵向量
⑤prob.Constraints.con=A*x&lt;=b;%约束条件,只有一个约束，也可以不加.con，.con是标签，可以自己命名，多个约束条件时，必须标签不能一样。
⑥[sol fval flag out]=solve(prob);%fval是最优值，sol.x是决策变量的值，当多个决策变量时，可以sol.y，flag在线性规划中不用在意，在非线性规划中注意不能为负值。
例如：
采用求解器求解：
clc,clear f = [-2;-3;5];%转换为求最小 A = [-2,5,-1;1,3,1]; b = [-10;12]; Aeq = [1,1,1]; beq = [7]; lb = zeros(3,1); [x,fval] = linprog(f,A,b,Aeq,beq,lb,[]); x -fval x =
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dda09f3f4c6553e8283d3aae899a85dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bddd840f8489bbcf27da483b63ee56f8/" rel="bookmark">
			python—PIL图像操作(二)绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
ImageDraw模块
绘制直线
绘制圆弧
绘制椭圆
绘制弦
绘制扇形
绘制多边形
绘制矩形
绘制文字
绘制点
ImageFont模块
ImageDraw模块 ImageDraw模块实现了绘图功能。可以通过创建图片的方式来绘制2D图像；也可以在原有图片上进行绘图，以达到修饰图片或对图片进行注释的目的。在ImageDraw模块绘图时需要首先创建一个ImageDraw.Draw对象，并且提供指向文件的参数。然后引用创建的Draw对象方法进行绘图。最后保存或直接输出绘制的图像：drawObject=ImageDraw.Draw(black)
绘制直线 drawObject.line ([x,y1,x2,y2], fill= None,width =0,joint= None)
表示以(x1,y1)为起始点，以(x2,y2)为终止点画一条直线。[x1,y,2,y2]也可以写为(x1,y1,x2,y2)、[x1,y1)(x2,y2)]; fill用于设置指定线条颜色; width设置线条的宽度; joint表示一系列线之间的联合类型。它可以是“曲线”。
绘制圆弧 drawObject.arc ([x1,y1 ,x2,y2],tart,end,fill=None,width=0)
在左上角坐标为(x1,y1),右下角坐标为(x2,y2)的矩形区域内(圆O内)，以start为起始角度，以end为终止角度，截取圆O的一部分圆弧并画出来。如果[x1,y1,x2,y2]区域不是正方形，则在该区域内的最大椭圆中根据角度截取片段。参数fill和width与line方法相同。
绘制椭圆 drawObject.elipse([x1,y1, x2,y2],fill=None,outline=None,width=0)
用法同arc类似，用于画圆(或者椭圆)。outline 表示只规定圆的颜色。
绘制弦 drawObject.chord([x1,y1, x2,y2],start, end, fill=None,outline=None,width=0)
用法同arc类似，用于画圆中从start到end的弦。fill表示弦与圆弧之间空间用指定颜色填满，设置为outline表示只规定弦线的颜色。
绘制扇形 drawObiect.pieslice ([x1,y1,x2,y2],start,end,fill=None,outline=None,width=0)
用法同elipse类似，用于画起止角度间的扇形区域。fill 表示将扇形区域用指定颜色填满，设置为outline表示只用指定颜色描出区域轮廓。
绘制多边形 drawbjct.polygon([x1,y1,x2,y2,...],fill= None,outline=None)
根据坐标画多边形，Python会根据第一个参量中的(x,y) 坐标对，连接出整个图形。fill表示将多边形区域用指定颜色填满，outline只用于设置指定颜色描出区域轮廓。
绘制矩形 drawObject.rectangle([x1,y1,x2,y2], fill=None,outline=None,width=0)
在指定的区域内画一个矩形，(x1,y1)表示矩形左上角的坐标，(x2,y2)表示矩形右下角的坐标。fill 用于将矩形区域颜色填满，outline 用于描出区域轮廓。
绘制文字 drawObject.text(position,text,fill=None,font=None,anchor=None,spacing=0,align=“left",direction =None,features=None,language=None)
在图像内添加文字。其中参数position是一个二元组，用于指定文字左上角的坐标; text表示要写入的文字内容; fill 表示文本的颜色; font 必须为ImageFont中指定的font类型；spacing表示行之间的像素数；align 表示位置“left"，“center" 或“right"；direction表示文字的方向。它可以是’rtl’(从右到左)，'ltr' (从左到右)或’ttb’ (从上到下)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bddd840f8489bbcf27da483b63ee56f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de07c481c4d2e5dfa6444993f1e5309c/" rel="bookmark">
			cuda使用中遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、release和debug模式运行结果有差异
（1）如果差异比较小，应该是release模式使用快速运算库导致的差异，网上解决方式很多
（2）如果差异太大，需要看看是否有些数组没有赋值成功，可以通过开启release模式下的debug选项，打印相应的结果，我遇到的问题是debug模式没有问题，但是在release模式时，内容拷贝函数会偶尔失效，最后检查是这个问题关闭就好
2.如何使用系统中的共享内存
Use shared GPU memory with TensorFlow? - Stack Overflow
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d3232101c005568a42b4e402a12b7f/" rel="bookmark">
			解决vs code中文注释变成问号的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好久没有使用vs code了，今天打开发现中文注释变成了问号，如下图所示
看了网上的帖子说把设置中的"files.autoGuessEncoding"项的值改为true即可。试了下，好像没有用
后来我把encodin模式换成了GB2312就恢复了正常
第1步，点击屏幕右下角的编码方式
第2步 选择 “通过编码方式打开”
第3步，选择GB2312
问题解决了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15bd87319b6afcacf4be0037049acf8e/" rel="bookmark">
			生活篇之工资和年终奖的纳税
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 程序员都想拿高薪，那么怎样才能让你赚更多的钱呢？
年终奖可以放到工资一起发放，也可以单独计算发放。那么问题来了，到底是合并发放划算还是单独发放划算？
我们先来看税率表--
工资适用的税率表：
年终奖适用的税率表：
我们要充分使用个税的政策红利，
要注意以下三点：
年终奖税率表有盲区，要充分利用；
（年终奖个税的拐点分别为36000、144000、300000……）总收入合理分配，即工资和年终奖合理分配，使个税达到最低；不同收入标准的人员，要分别进行规划。 个人初步演算后的最值（未考虑社保公积金及专项扣除）：
收入不超过96000元的：
只要年工资不要超过96000，年终奖不要超过36000，合并发放或分别发放，区别不大。
（但注意：年终奖放工资一起发，可能会在1、2月份先交税，后又要去汇算清缴做退税，多一个步骤。）收入96000-132000元的：
年工资不要超过96000，年终奖不要超过36000，最划算。收入132000-240000元的：
年工资不要超过204000，年终奖不要超过36000，最划算。收入240000-260000元的：
年终奖不要超过36000，其余放工资。收入260000-270000元之间：有拐点，具体在哪个金额我没有去找。对比上文的第4条和下文的第6条，计算思路已有差别，就因为这个拐点。这段的人员用第4条或第6条均可，差异不大。
（拐点是因为工资是分段计算，但年终奖不是哦。）收入270000-348000元的：
年工资不要超过204000，其余放年终奖，年终奖不要超过144000。 本文章参考以下文章编写： 【2022退税超全攻略！个人所得税怎么交？退税怎么操作？】
【2022年终奖个税税率表（年终奖个税计算）】
【http://www.gdmzwhlytsq.com/hyxw/20220415260712.html】
我读完这些文章以后觉得思路特别清晰，写得非常好，作为狂热的开源技术人， 所以我想分享给更多技术小伙伴~无意冒犯，并无商用，如若侵权请联系作者删除此文章！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0404a96aad4d477ade34e1455cba869d/" rel="bookmark">
			Flask 项目使用 cloudinary 全纪录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面，由于在Heorku上运行程序过程中创建的文件将不会永久保存，而且会在一天内被重置。即用户上传的文件无法像在本地一样保存在服务器端的文件夹。因此将媒体文件保存在cloudinary（类似七牛云）。
如果要直接使用heroku的cloudinary插件需要绑定海外的信用卡🙂，所以直接嵌入源代码。
项目地址
部署地址
配置 我是写在.env文件里面，在heroku需要手动设置
# 在cloudinary主页的控制台 CLOUD_NAME=**** API_KEY=**** API_SECRET=**** CLOUDINARY_URL=**** # 记得大写 heroku config:set API_KEY=**** 一些基本操作 cors = CORS() # flask-cors用于跨域 cors.init_app(app) @cross_origin() 具体实现 import cloudinary from cloudinary.uploader import upload def upload_cloudinary(file_to_upload): """上传函数""" cloudinary.config( cloud_name=os.getenv('CLOUD_NAME'), api_key=os.getenv('API_KEY'), api_secret=os.getenv('API_SECRET')) # cloudinary.uploader.upload 传入文件流或本地文件名 # 设置resource_type="auto" 可以上传任意格式文件 upload_result = upload(file_to_upload, resource_type="auto") # 返回上传结果 url 和文件类型 return upload_result['url'], upload_result['format'] 参考链接 https://devcenter.heroku.com/articles/cloudinary
Python image and video upload
Cloudinary Upload API简介：轻松替代AWS S3
flask-cloudinary
官方示例项目pycloudinary
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf508eb0833fc5c7aa78a7d05c8eca66/" rel="bookmark">
			Vue组件加载顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记：
1、父子组件的加载顺序为：
父beforeCreated -&gt;父created -&gt;父beforeMounted -&gt;子beforeCreated -&gt;子created -&gt;子beforeMounted -&gt;子mounted -&gt; 父mounted
2、父组件更新顺序为：
父beforeUpdate-&gt;父updated
3、子组件更新顺序为：
父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated
4、父子组件销毁顺序为：
父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47bc13ba0dfec6ea12d0dcefb6a45458/" rel="bookmark">
			java小游戏 ： 飞翔的小鸟 （完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 飞翔的小鸟 小游戏 可以作为 java入门阶段的收尾作品 ；
需要掌握 面向对象的使用以及了解 多线程，IO流，异常处理，一些java基础等相关知识。
一 、游戏分析 1. 分析游戏逻辑 （1）先让窗口显示出来，然后绘制 游戏的背景
（2）让小鸟显示在屏幕中，并且可以上下飞
（3）屏幕出现闪烁，解决闪烁问题 : 用双缓冲，就是将内容绘制到 一张图片上，然后再显示出来
（4）让障碍物显示出来，并且让障碍物可以移动起来
（5）碰撞检测
（6）绘制刚开始的页面和死亡后的页面
（7）让 障碍物 动起来
2.代码分析 （1）app 包 ：（游戏启动类）
GameApp 类 作为 游戏启动类 。
（2）main 包 : （游戏主要类）
① Bird 类
② Barrier 类
③ BarrierPool 类
④ GameBackGround 类
⑤ GameBarrierLayer 类
⑥ GameFrame 类
⑦ GameReady 类
⑧ GameTime 类
（3）util 包 ：（游戏工具类）
① Constant 类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47bc13ba0dfec6ea12d0dcefb6a45458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d705ce1760d9a5f05f7a5f49c9feaf2d/" rel="bookmark">
			Java 应用压测性能问题定位经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是压测 压测，即压力测试，是确立系统稳定性的一种测试方法，通常在系统正常运作范围之外进行，以考察其功能极限和和可能存在的隐患。
压测主要用于检测服务器的承受能力，包括用户承受能力，即多少用户同时使用系统时基本不影响质量、流量承受等。另外，通过诸如疲劳测试还能发现系统一些稳定性的问题，比如是否存在连接池中的连接被耗尽，内存被耗尽，线程池被耗尽，这些只能通过疲劳测试来进行发现定位。
为什么要压测
压测的目的就是通过模拟真实用户的行为，测算出机器的性能(单台机器的 QPS、TPS)，从而推算出系统在承受指定用户数(100 W)时，需要多少机器能支撑得住。因此在进行压测时一定要事先设定压测目标值，这个值不能太小，也不能太大，按照目前业务预估的增长量来做一个合理的评估。压测是在上线前为了应对未来可能达到的用户数量的一次预估(提前演练)，压测以后通过优化程序的性能或准备充足的机器，来保证用户的体验。压测还能探测应用系统在出现交易洪峰时稳定性情况，以及可能出现的一些问题，发现应用系统薄弱一环，从而更有针对性地进行加强。
压测
这几种测试可以穿插进行，一般会在压力测试性能指标达标后，再安排耐久性测试。
压测名词解释
常见的压测工具 ab
ApacheBench 是 Apache 服务器自带的一个 web 压力测试工具，简称 ab。ab 又是一个命令行工具，对发起负载的本机要求很低，根据 ab 命令可以创建很多的并发访问线程，模拟多个访问者同时对某一 URL 地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说 ab 工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。
Jmeter
Apache JMeter 是 Apache 组织开发的基于 Java 的压力测试工具。用于对软件做压力测试，它最初被设计用于 Web 应用测试，但后来扩展到其他测试领域。
JMeter 能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。
JMeter 的功能过于强大，这里暂时不介绍用法，可以查询相关文档使用(参考文献中有推荐的教程文档)
LoadRunner
LoadRunner 是 HP(Mercury)公司出品的一个性能测试工具，功能非常强大，很多企业级客户都在使用，具体请参考官网链接。
阿里云PTS
性能测试 PTS（Performance Testing Service）是一款性能测试工具。支持按需发起压测任务，可提供百万并发、千万 TPS 流量发起能力，100% 兼容 JMeter。提供的场景编排、API 调试、流量定制、流量录制等功能，可快速创建业务压测脚本，精准模拟不同量级用户访问业务系统，帮助业务快速提升系统性能和稳定性。
作为阿里内部使用多年的性能测试工具，PTS 具备如下特性：
免运维、开箱即用。SaaS化施压、最大支持百万级并发、千万级TPS流量自助发起能力。支持多协议HTTP1.1/HTTP2/JDBC/MQTT/Kafka/RokectMq/Redis/Websocket/RMTP/HLS/TCP/UDP/SpringCloud/Dubbo/Grpc 等主流协议。支持流量定制。全球施压地域定制/运营商流量定制/IPv6 流量定制。稳定、安全。阿里自研引擎、多年双十一场景打磨、支持 VPC 网络压测。性能压测一站式解决方案。** 0 编码构建复杂压测场景，覆盖压测场景构建、压测模型设定、发起压力、分析定位问题、出压测报告完整的压测生命周期。100% 兼容开源 JMeter。提供安全、无侵入的生产环境写压测解决方案。 压测工具的比较
如何选择压测工具
这个世界上没有最好的工具，只有最适合的工具，工具千千万，选择一款适合你的才是最重要的，在实际使用中有各种场景，读者可以结合压测步骤来确定适合自己的工具：
确定性能压测目标：性能压测目标可能源于项目计划、业务方需求等确定性能压测环境：为了尽可能发挥性能压测作用，性能压测环境应当尽可能同线上环境一致确定性能压测通过标准：针对性能压测目标以及选取的性能压测环境，制定性能压测通过标准，对于不同于线上环境的性能压测环境，通过标准也应当适度放宽设计性能压测：编排压测链路，构造性能压测数据，尽可能模拟真实的请求链路以及请求负载执行性能压测：借助性能压测工具，按照设计执行性能压测分析性能压测结果报告：分析解读性能压测结果报告，判定性能压测是否达到预期目标，若不满足，要基于性能压测结果报告分析原因 由上述步骤可知，一次成功的性能压测涉及到多个环节，从场景设计到施压再到分析，缺一不可。工欲善其事，必先利其器，而一款合适的性能工具意味着我们能够在尽可能短的时间内完成一次合理的性能压测，达到事半功倍的效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d705ce1760d9a5f05f7a5f49c9feaf2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31301d6b9284bc21c53ba789ec9dfeee/" rel="bookmark">
			【git】在新环境下，git的基础配置流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题：新环境下，无法直接拉取仓库，需要进行基础配置以及ssh秘钥设置
1、git基础配置 （1）用户名
git config --global user.name "user" （2）用户邮箱
git config --global user.email "user@xxxx.com" （3）查看配置是否生效
git config --global user.name git config --global user.email 2、git 生成 SSH 公钥 ssh-keygen -t rsa -C "user@xxx.com" 根据提示操作，基本上一路回车即可
3、git 增加 SSH 公钥 （1）获取生成的公钥
cat ./.ssh/id_rsa.pub （2）将生成的秘钥粘贴到远端仓库
3、git clone 项目 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10537cd49aa4c010ce96cee8a8f7da74/" rel="bookmark">
			Vue3的效率提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3的效率提升具体表现在哪方面？ 静态提升 在vue3中元素节点没有绑定动态内容会被静态提升
// vue2 的静态节点 render(){ createVNode("h1", null, "Hello World") // ... } // vue3 的静态节点 const hoisted = createVNode("h1", null, "Hello World") function render(){ // 直接使用 hoisted 即可 } 静态属性会被提升
&lt;div class="user"&gt; {{user.name}} &lt;/div&gt; const hoisted = { class: "user" } function render(){ createVNode("div", hoisted, user.name) // ... } 预字符串化 &lt;div class="menu-bar-container"&gt; &lt;div class="logo"&gt; &lt;h1&gt;logo&lt;/h1&gt; &lt;/div&gt; &lt;ul class="nav"&gt; &lt;li&gt;&lt;a href=""&gt;menu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;menu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;menu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=""&gt;menu&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10537cd49aa4c010ce96cee8a8f7da74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/714db710f47c412c2c7cae0392aca844/" rel="bookmark">
			PyAutoGUI程序自动化控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyAutoGUI程序自动化控制
PyAutoGUI是一个款Python的GUI自动化工具，其目的是利用脚本控制鼠标和键盘操作。PyAutoGUI 适用于 Windows、macOS 和 Linux，并在 Python 2 和 3 上运行。
在已安装Python环境的基础上通过pip安装
PyAutoGUI库：
pip install -i https://pypi.douban.com/simple pyautogui
源码地址：https://github.com/asweigart/pyautogui
PyAutoGUI 有几个功能：
移动鼠标，单击或键入其他应用程序的窗口。
向应用程序发送击键（例如，填写表单）。
截屏，并给出一个图像（例如，按钮或复选框），在屏幕上找到它。
找到应用程序的窗口，并移动、调整大小、最大化、最小化或关闭它（当前仅使用 Windows）
在 GUI 自动化脚本运行时显示用户交互的消息框。
一、鼠标控制功能
鼠标坐标定义：
屏幕上的位置由 X 和 Y 笛卡尔坐标引用。X 坐标从左侧的 0 开始，然后向右侧增大，Y 坐标从顶部的 0 开始，然后向下增大。
左上角的像素位于坐标 0，0 处。如果屏幕的分辨率为 1920 x 1080，则右下角的像素将为 1919、1079（因为坐标从 0 开始，而不是从 1 开始）。
0,0 X轴 --&gt;
±--------------------------+
| | Y 轴
| | |
| 1920 x 1080 screen | |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/714db710f47c412c2c7cae0392aca844/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1b1d7762d31b7882936fa519544e7b/" rel="bookmark">
			C# wpf ScrollBar自定义样式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、ScrollBar的组成1.结构说明2.具体组成行按钮页按钮滑块轨道 二、如何自定义？1.确定参数2.定义Style3.定义Template 四、使用方法1.继承Style2.设置参数示例代码 五、具体例子1.通用模板2.仿移动端滚动条3.音量调节滚动条4.加减按钮滚动条 总结 前言 滚动条是一个常见控件，很多控件中都包含滚动条，比如ListBox、ComboBox、GridView等。wpf默认的滚动条的样式并不是特别好看，而且经常与UI设计的滚动条不一致，这个时候我们就需要自定义滚动条了。值得一提的是这，wpf的滚动条定制性和拓展性都非常好，这就为我们自定义滚动条提供了非常有利的条件。
一、ScrollBar的组成 ScrollBar由6个部分组成。两个行按钮、两个页按钮、一个滑块、一个轨道。
1.结构说明 一个简单的纵向滚动条如下：
纵向滚动组成如下：
一个简单的纵向滚动条如下：
横向滚动条与纵向滚动条结构一致，相当于纵向滚动条顺时针转90度：
2.具体组成 行按钮 行按钮可以是任意按钮类型，且在ScrollBar内不受布局位置的限制，可以任意摆放。标识行按钮的方式是Command绑定ScrollBar的LineCommand。
LineCommand有4种分别是：LineUpCommand、LineDownCommand、LineLeftCommand、LineRightCommand，共4个方向，分别两两对于纵向和横向的ScrollBar。
代码如下（示例）：
（1）上行按钮
绑定ScrollBar.LineUpCommand即为上行按钮。
&lt;RepeatButton Command="ScrollBar.LineUpCommand" /&gt; （2）下行按钮
绑定ScrollBar.LineDownCommand即为下行按钮。
&lt;RepeatButton Command="ScrollBar.LineDownCommand" /&gt; （3）左行按钮
绑定ScrollBar.LineLeftCommand即为左行按钮。
&lt;RepeatButton Command="ScrollBar.LineLeftCommand" /&gt; （4）右行按钮
绑定ScrollBar.LineRightCommand即为右行按钮。
&lt;RepeatButton Command="ScrollBar.LineRightCommand" /&gt; 页按钮 页按钮相对于行按钮有布局的要求，需要放在Track标签的Track.DecreaseRepeatButton或中Track.IncreaseRepeatButton标签中（Track是轨道标签第4节会说明）。
页按钮只能是RepeatButton类型，并且Command绑定ScrollBar的PageCommand。PageCommand有4钟，分别是LineUpCommand、LineDownCommand、LineLeftCommand、LineRightCommand，共4个方向，分别两两对于纵向和横向的ScrollBar。
代码如下（示例）：
上页按钮
放在Track.DecreaseRepeatButton标签里并绑定ScrollBar.PageUpCommand即为上页按钮。
&lt;Track.DecreaseRepeatButton&gt; &lt;RepeatButton Command="ScrollBar.PageUpCommand" /&gt; &lt;/Track.DecreaseRepeatButton&gt; 下页按钮
放在Track.IncreaseRepeatButton标签里并绑定ScrollBar.PageDownCommand即为下页按钮。
&lt;Track.IncreaseRepeatButton&gt; &lt;RepeatButton Command="ScrollBar.PageDownCommand" /&gt; &lt;/Track.IncreaseRepeatButton&gt; 左页按钮
放在Track.DecreaseRepeatButton标签里并绑定ScrollBar.PageLeftCommand即为左页按钮。
&lt;Track.DecreaseRepeatButton&gt; &lt;RepeatButton Command="ScrollBar.PageLeftCommand" /&gt; &lt;/Track.DecreaseRepeatButton&gt; 右页按钮
放在Track.IncreaseRepeatButton标签里并绑定ScrollBar.PageRightCommand即为右页按钮。
&lt;Track.IncreaseRepeatButton&gt; &lt;RepeatButton Command="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d1b1d7762d31b7882936fa519544e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85d8cb99f4b746d6efcd05a51b83a9cd/" rel="bookmark">
			C语言##__VA_ARGS__的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言可变参数函数详解 0 前言1 __VA_ARGS__的用法2 ##__VA_ARGS__的用法总结 0 前言 在调试过程中，有时会用到自定义的打印，这是就会用到##__VA_ARGS__，接下来详细讲解。
1 __VA_ARGS__的用法 自定义打印时，用到可变参数，用...即可表示可变参数，如下：
#include &lt;stdio.h&gt; #define LOG1(...) printf(__VA_ARGS__)//...表示可变参数，__VA_ARGS__就是将...的值复制到这里 int main(int argc, char** argv) { char *str = "test __VA_ARGS__"; int num = 10086; LOG1("this is test __VA_ARGS__\r\n"); LOG1("this is test __VA_ARGS__:%s, %d\r\n", str, num); return 0; } 打印结果如下：
this is test __VA_ARGS__ this is test __VA_ARGS__:test __VA_ARGS__, 10086 2 ##__VA_ARGS__的用法 ##__VA_ARGS__前面加上##的作用是：当可变参数的个数为0时，这里的##可以把把前面多余的","去掉,否则会编译出错。
当想要在自定义的调试信息加上时间、行数等信息时，应该怎么做呢？先把正确的用法写在前面：
#include &lt;stdio.h&gt; #define LOG3(fmt, ...) printf("&lt;%s:%s&gt;:"fmt"\r\n", __FILE__, __FUNCTION__, ##__VA_ARGS__) int main(int argc, char** argv) { char *str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85d8cb99f4b746d6efcd05a51b83a9cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0112371c96860a8b71f7348022b1b6c9/" rel="bookmark">
			Keepalived学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用keepalived配置nginx双活方法 配置 Keepalived - 主 1. 通过命令 vim keepalived.conf 打开配置文件
global_defs { # 路由id：当前安装keepalived的节点主机标识符，保证全局唯一 router_id keep_171 } vrrp_instance VI_1 { # 表示状态是MASTER主机还是备用机BACKUP state MASTER # 该实例绑定的网卡 interface ens33 # 保证主备节点一致即可 virtual_router_id 51 # 权重，master权重一般高于backup，如果有多个，那就是选举，谁的权重高，谁就当选 priority 100 # 主备之间同步检查时间间隔，单位秒 advert_int 2 # 认证权限密码，防止非法节点进入 authentication { auth_type PASS auth_pass 1111 } # 虚拟出来的ip，可以有多个（vip） virtual_ipaddress { 192.168.1.161 } } 配置 Keepalived - 备 1. 通过命令 vim keepalived.conf 打开配置文件
global_defs { router_id keep_172 } vrrp_instance VI_1 { # 备用机设置为BACKUP state BACKUP interface ens33 virtual_router_id 51 # 权重低于MASTER priority 80 advert_int 2 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { # 注意：主备两台的vip都是一样的，绑定到同一个vip 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0112371c96860a8b71f7348022b1b6c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e09a3127d7829776de171b6c3a146445/" rel="bookmark">
			VueX五个核心属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VueX五个核心属性分别是state、mutation、action、getter，module
1.state: 用于保存需要全局共享的数据,在组件中访问state里面的数据用this.$store.state.数据名或者用辅助函数
2.mutation: 用于修改 state 里面的数据。每个 mutation都有一个字符串的事件类型和一个回调函数，我们需要改变 state 的值就要在回调函数中改变。我们要执行这个回调函数，那么我们需要执行一个相应的调用方法：store.commit。
3.action: action 可以提交 mutation，在 action 中可以执行 store.commit，而且 action 中可以有任何的异步操作。在页面中如果我们要调用这个 action，则需要执行 store.dispatch
4.getter: 从基本数据(state)派生的数据，相当于state的计算属性,具有返回值的方法
5.module: 模块化vuex，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理
结合实际: 我们做的后管系统,登录请求的写到actions里面,通过mutations将用户信息和token保存到state里面
style上加scoped属性的原理
在 Vue 组件中，为了使样式模块化，不对全局造成污染，可以在style 标签上添加 scoped 属性以表示它的只属于当下的模块，局部有效。
结合实际:我们做的后管系统设置头像图片样式的时候,不加scoped属性就会影响全局样式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/904040364379d41b0926f715e6ff621d/" rel="bookmark">
			TypeScript基础之联合类型、交叉类型、类型别名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		联合类型 联合类型表示取值可以为多种类型中的一种，使用 | 分割每个类型。
let a: number | string | boolean; a = 100; a = 'xman'; a = true; 函数中使用：
const test = (info: string | number) =&gt; { // ... } 约束取值
const num: 1 | 2 = 1; type isMan = true | false; type EventNames = 'click' | 'scroll' | 'mousemove'; 以上1 | 2, true | false, ‘click’ | ‘scroll’ | 'mousemove’被称为字面量类型，分别为数字、布尔、字符串字面量类型，可以用来约束取值只能是其中几个值中的一个。
交叉类型 交叉类型是将多个类型合并为一个类型，使用&amp;定义交叉类型。
可以将多个接口类型合并成一个类型，实现等同于接口继承的效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/904040364379d41b0926f715e6ff621d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ad92440df22ddbd2e8f34721ea4345/" rel="bookmark">
			【FFmpeg&#43;Qt开发】解码流程 详细分析&#43;代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、FFMPEG 概述
​二、FFMPEG 解码
2.1解码流程
2.2解码示例
一、FFMPEG 概述 FFmpeg 是一套可以用来记录、转换，数字音频、视频，并能将其转化为流的开源计算机程序。FFmpeg 采用 LGPL 或 GPL 许可证；它提供了录制、转换以及流化音视频的完整解决案；它还包含了非常先进的音频\视频编解码库 libavcodec，为了保证高可移植性和编解码质量，libavcodec 里很多 code 都是从头开发的。 FFmpeg 在 Linux 平台下开发，但它同样也可以在其它操作系统环境中编译运行，包括 Windows、Mac OS X 等。FFmpeg最早由 Fabrice Bellard 发起，2004 年至 2015 年间由 Michael Niedermayer 主要负责维护。许多 FFmpeg 的开发人员都来自 MPlayer 项目，而且当前 FFmpeg 也是放在MPlayer 项目组的服务器上。FFmpeg名称来自 MPEG 视频编码标准，前面的"FF" 代表"Fast Forward"。 下载链接：Download FFmpeg
具体下载详见：Qt+FFmpeg----windows下环境搭建_猿力猪的博客-CSDN博客_ffmpeg开发环境搭建
​
​二、FFMPEG 解码 2.1解码流程 🔴解码：将带有封装格式的视频解封装后得到的压缩码流数据（编码数据）经过解码得到像素数据的过程。 例如：解码 H.264 压缩码流数据得到 YUV （或者 RGB ）的像素数据。 解码的流程图，如下所示： 🔴解码思路分析：
注册所有的组件 av_register_all()打开视频文件 avformat_open_input() 有可能打开失败获取视频信息 视频码流、音频码流、文字码流查找流信息 avformat_find_stream_info()找到解码器 avcodec_find_decoder() 有可能没找到打开解码器 avcodec_open2()读取码流中的一帧码流数据 av_read_frame()解码读到一帧码流数据 得到一帧的像素数据 YUV RGB重复7-8的动作 直到视频所有的帧都处理完关闭解码器关闭视频文件 🔴解码过程中几个重要的结构体：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7ad92440df22ddbd2e8f34721ea4345/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55b0a628825a001eaea7f0e81379a21/" rel="bookmark">
			《黑色沙漠》游戏分析与拆解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
游戏概述
核心循环与系统拆解
交易所
游戏流程
装备强化
强化失败保护
神器
成就
设计目的
后记
《黑色沙漠》游戏系统拆解图
前言 本文主要分析PC端《黑色沙漠》台服游戏流程中让玩家感到兴奋愉快的系统，分析这些系统为何吸引玩家，如何做到让玩家长期游玩并且愿意付费。详细的系统拆解图在文末。
游戏概述 《黑色沙漠》是由韩国Pearl Abyss公司制作的开放世界MMORPG，韩服于2013年首测，台服于2017年正式公测，同时还有日服、美服。在2018年8月，《黑色沙漠》推出重制版，对游戏的画面质量进行了大幅度升级。
游戏付费模式 买断制（游戏资格与部分内购商品的礼包）+内购制
游戏特色 前所未见的高规格的画面。保留真实世界的复杂与细腻，从壮丽的自然景观到熟悉的生活场景，每一瞬光影都令人赞叹。
无锁定模式的爽快战斗。不同于传统MMORPG死板、单一的锁定式战斗，追求反应速度与操作技巧的结合，呈现高动作感的爽快打击。
攻城略池的大规模团战。获胜的团队不仅能成为领主，还能控制税收，掌握地方资源。
完美定制独一无二的样貌。细微如骨骼、脸部线条、到每寸肌肤质感的自定义角色系统。
图 1 游戏内画面
核心循环与系统拆解 图 2 系统拆解
图 3 核心循环
上图就是游戏中的核心循环，玩家通过PVE玩法获取各种资源，然后投入到角色的各方面养成中，养成带来反馈是PVE获取资源更轻松、PVP体验更好。游戏的核心就是赚“银币”，只要有银币就可以买到几乎所有东西。
黑色沙漠中大部分的PVP玩法都是使用玩家自己的装备。这可能有些不公平，但在《黑色沙漠》这款装备驱动的游戏中，这是反馈玩家投入的最佳方式。
另外，上面的核心循环缺少了生活玩法带来的银币等资源产出，喜欢战斗喜欢休闲玩法的玩家，可以通过生活玩法赚取银币。
交易所 图 4 交易所拆解
概述 从核心循环图中可以发现，交易所是游戏资源交换的中枢，因为交易所是玩家间交易道具的唯一途径，不仅能够交易游戏内各种玩法的产出，如装备、角色养成素材，也能交易付费道具如角色时装等。
价值礼包是《黑色沙漠》中一项最常见也最实用的付费内容，相当于其他游戏中的VIP。价值礼包能提供诸多便利，但要论其中哪项最重要使其成为玩家不得不消费的理由，那必然是交易所领取额的增加了。
设计目的 高消费能力玩家可以选择充值购买付费道具，将其上架交易所贩卖给其他玩家，来加快银币的获取。低消费能力的玩家也可以借此不花一分钱就获得付费道具如角色时装等。
游戏流程 游戏的流程决定了玩家在什么时间或什么阶段接触到什么内容，在流程中能让玩家感到兴奋的某些内容，我称其为“兴奋点”。兴奋点的设置十分重要，决定了玩家是否愿意继续体验游戏的后续内容。
在黑色沙漠前期的兴奋点非常集中，首先是选择职业和捏脸。这是玩家对游戏的第一印象：丰富的职业、酷炫的技能特效以及细致到骨骼，脸部线条的角色自定义系统。
图 5 选择职业界面
图 6 角色自定义界面
接着进入游戏，在前十分钟玩家就会接触到游戏的战斗系统，能第一时间展现《黑色沙漠》高品质的游戏画面与爽快的战斗系统。
图 7 战斗画面
并且一开始角色升级会很快，随着角色的升级玩家会解锁更多的新的技能，让玩家对游戏一直保持新鲜与兴奋。
图 8 技能界面
玩家在接触了游戏大部分系统，对游戏有基本的了解之后，就开始进入核心循环中。在这个核心循环中兴奋点的获取会比较困难，因为大部分时间玩家是在重复地刷怪赚钱，以追求角色装备或其他地方的提升。如果往后整个游戏流程仅有这一种兴奋点显然是不够的，因此还需要添加其他的兴奋点，下面先介绍装备的提升。
装备提升主要有两种途径：一是强化自身装备，二是赚银币，在交易所买其他玩家强化的装备。而装备强化是《黑色沙漠》游戏流程中必不可少的一环，也是最吸引玩家的系统之一。
装备强化 图 9 装备强化界面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d55b0a628825a001eaea7f0e81379a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be219428a3fd0ce13384628a6df701e5/" rel="bookmark">
			我经历的前端屎山项目&#43;挽救方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 最近看到掘金一篇好文《如何把前端项目写成一座屎山？》， 看的热泪盈眶，回想起了这么多年我遇到过的前端代码屎山
作为一个有代码洁癖的人，挽救失足代码是工作中一大重要事项，在此总结了一下遇到过的失足代码，以及一些修正的方法
不写注释 这个见到的就太多了，跟个人习惯有关，很多coding能力强的人也不写注释，觉得自己的代码可读性很强
解法：把写注释写到团队规范中，重要、复杂模块，注释多多益善
不使用eslint、prettier等任何格式相关工具 这个经常遇到，你想象一下以下几个场景：
在同一个文件中，你的代码两格缩进，别人的代码四格缩进，某某某的代码，随意缩进……
在某一个3000行的vue文件中，你新写了一个computed，发现死活不生效，后来才在最下面一行，发现了computed早就写过，把你上面的覆盖掉了
解法：eslint、prettier还是要有的，如果嫌麻烦可以把规则设定的少一些，总不能两格四格随意缩进吧
全面拥抱状态管理器 这个是在Gaode公司遇到的，中后台数据可视化项目，某架构大神把所有的数据都放到redux里面，数据量之大，甚至能影响到界面的性能，后来再别人的修改下，减少了N多数据，解决了性能问题。
解法：后来我们定下规则，不需要共享的数据，绝对不放到redux里面。至于之前的数据，慢慢修改
不做模块抽象和复用 最经典的，还是在JD公司，当时的业务是广告投放黄金流程，第一步-设置基本信息，第二步-上传素材，第三步，确定信息上传。
其中第二步的上传素材，可以上传图片、视频、图片+视频三种方式的，当时单文件vue，4000行代码，最大的问题在于上面三种上传方式的dom、js，都是分开处理的，完全没有做复用，可读性比较差，而且修改内容的话，很容易修改漏了。
解法：由于是黄金业务流程，当时无人敢动，我也不敢，在慢慢摸索了N久之后，了解了代码的逻辑，要了一周的工期+测试验收、产品验收的时间，才把这块重构搞定
编写长长长长长的组件 还是在JD公司，当时的业务是广告投放黄金流程，第一步-设置基本信息，这个单vue文件3000多行，没有任何子组件，每次维护代码的上下横跳，简直要吐血。
解法：这个拆分倒是比较简单的，因为广告投放第一步，有一些选择人群、选择时间、地域之类的业务组件，还是比较方便拆分的，当时拆了5、6个子组件+4个业务性的mixin，清晰了很多
冷门库的使用 还是在JD公司，遇到的不只是冷门库，而且废弃的库。
当时的场景：某团队写了一个kpi项目——UI组件库，对标element ui的那种，然后为了表示有人使用，就在自己新启动的业务系统中，使用了这个UI组件库，不幸的是，这个新启动的业务系统，后来到了我的手里。那个UI组件库功能少不说，后来因为人员变动，没人维护了！！！
由于开发的费劲，不得已又引入了element ui，没错，就是两套库，问题照样很多：样式不协调倒还好说，element ui的一些组件（例如dialog），由于样式冲突的冲突，压根没法使用！
解法：长痛不如短痛，要了专门的时间，把那个没人使用的垃圾UI库，直接全部删掉，相关引用的组件使用element ui组件代替
修改 node_modules 中源码 还是在JD公司，当时入职接手的第一个react项目，就是这样，需要修改node_modules中某个配置文件，要不然就跑不起来！！！
解法：应当需要读取本地配置文件。这个本来想解来着，结果后面不久项目废弃了，也就没有再投入时间去解
能力不够写的复杂组件 这个是在Gaode公司，某产品负责人喜欢复杂的表格，于是乎，某前端大哥把rctable的源码拿了过来，二次封装了一个复杂的表格组件。
思路没问题，不过该大哥没有达到平衡，就是自己的能力+表格代码的复杂度+产品源源不断的需求，导致了众多bug，收到很多吐槽。
领导很重视这个问题，于是派团队内技术最NB的哥们来重构这个代码，这哥们最大的NB，不止在技术，而是研究了一下说，咱能不能不做这个复杂的组件？
解法：那哥们的想法还真实现了，不久后面产品负责人进行了调整，新来的产品对那个复杂表格不感冒，把那个复杂表格组件功能阉割一下收尾，把bug清理一下就高挂起来了
滥用setTimeout 这个在LH公司，某同事似乎与nextTick有仇，从来不用，一律使用settimeout代替，项目中众多 setTimeout 到处埋伏
这样就出大问题了：
1、setTimeout 时机控制的有问题，导致了流程有问题
2、setTimeout 导致了代码可读性差，因为 setTimeout 比较多，你无法一眼看出哪个先执行来
3、倒是了js报错，很多是在setTimeout中调用了vue组件的ref，这个时候如果组件销毁了，setTimeout继续执行的话，ref就获取不到，瞬间报错
解法：setTimeout 能不用就不用，要不然就乱了
使用自己不了解的项目架构 在LH公司，接手了某项目，了解了之后，觉得很多引用的三方包没用，问了相关同事，答曰：这是从之前的项目迁移过来的，不知道干啥用的，项目能正常启动，就没动。
……殊不知，影响了可读性，影响了性能，更增加了维护的成本
解法：要对自己的项目架构负责，及时梳理系统架构
黑科技、影响全局的魔法功能 你新写了一个功能，明明代码跟api上一页，结果就是不好使，然后你发现了问题，某同事在全局重写了这个功能，比原来的功能多了一些限制
解法：减少对黑科技的使用，影响全局的那些方法，需要告知项目同组的前端研发
git commit注释 这个倒是不算代码屎山了，不过你想象一下，跟你配合的某同事，git commit的内容，一律都是“test”，这个时候，你review他的代码的时候，是不是感觉无从下手？
解法：按git提交规范约束commit
没有任何交接的项目 Duang！一个新git库给你了，除此之外，啥都没有！然后产品过来跟你聊这块的新需求了，很着急，希望明天上线的那种。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be219428a3fd0ce13384628a6df701e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71432a2f33d01c484ccd5c2047641421/" rel="bookmark">
			同源策略（same origin policy）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浏览器的同源策略 同源策略是一个重要的安全策略，它用于限制一个origin的文档或它加载的脚本如何能与另一个源的资源进行交互。能够减少恶意文档，减少可能被攻击媒介。 如果两个URL的协议、域名、端口号都相同，就称这两个URL同源。
浏览器默认两个不同的源之间是可以互相访问资源和操作DOM的。两个不同的源之间若是想要访问资源或者操作DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。它的存在可以保护用户隐私信息，防止身份伪造。
Origin Web内容的源用于访问它的URL的协议（方案）、主机（域名）、和端口号。只有当协议、主机、域名都匹配时，两个对象才具有相同的起源，即Origin相同。
（如果把html看做是一个文档，那么端口号是其存放位置的根目录，主机是其上级目录，协议是其上上级目录，同源策略就可以理解为同一根目录下的文件才可以访问、操作）
在浏览器中, &lt;script&gt; 、&lt;img&gt;、&lt;iframe&gt;、&lt;link&gt;等标签都可以跨域加载,而不受浏览器的同源策略的限制, 这些带src属性的标签每次加载的时候,实际上都是浏览器发起一次GET请求, 不同于普通请求(XMLHTTPRequest)的是，通过src属性加载的资源,浏览器限制了JavaScript的权限，使其不能读写src加载返回的内容。
浏览器同源策略中,除了上述的几个标签可以跨域加载外,其他出现跨域请求时,请求会发到跨域的服务器,并且会服务器会返回数据,只不过浏览器"拒收"返回的数据
浏览器的同源策略目的是为了保护用户的信息安全,为了防止恶意网站窃取用户在浏览器上的数据,如果不是同源的站点,将不能进行如下操作 :
Cookie、LocalStorage 和 IndexDB 无法读写DOM 和 Js对象无法获得AJAX请求不能发送 三、跨域解决方案 1、ajax跨域请求方案 jsonp跨域 jsonp（JSON with Padding），是JSON的一种 “使用模式”，可以让网页跨域读取数据，其本质是利用script标签的开放策略，浏览器传递callback参数到后端，后端返回数据时会将callback参数作为函数名来包裹数据，从而浏览器就可以跨域请求数据并制定函数来自动处理返回数据。
jsonp跨域实现流程：
jsonp跨域代码示例： var script = document.createElement('script'); script.type = 'text/javascript'; // 传参callback给后端，后端返回时执行这个在前端定义的回调函数 script.src = 'http://a.qq.com/index.php?callback=handleCallback'; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) { alert(JSON.stringify(res)); } jsonp跨域优点： jsonp兼容性强，适用于所有浏览器，尤其是IE10以下浏览器 jsonp跨域缺点 没有关于调用错误的处理只支持GET请求，不支持POST以及大数据量的请求，也无法拿到相关的返回头，状态码等数据callback参数恶意注入，可能会造成xss漏洞无法设置资源访问权限 补充： JSON 与 JS 对象 与 JSONP 的区别_要不要买菜啊的博客-CSDN博客
跨域资源共享（CORS） 跨域资源共享（Cross-origin resource sharing，CORS）是一个 W3C标准，允许浏览器向跨域服务器发送请求，从而克服了ajax只能同源使用的限制。CORS需要浏览器和服务器同时支持。目前，所有主流浏览器（IE10及以上）使用XMLHttpRequest对象都可支持该功能，IE8和IE9需要使用XDomainRequest对象进行兼容。
CORS整个通信过程都是浏览器自动完成，浏览器一旦发现ajax请求跨源，就会自动在头信息中增加Origin字段，用来说明本次请求来自哪个源（协议+域名+端口）。因此，实现CORS通信的关键是服务器，需要服务器配置Access-Control-Allow-Origin头信息。当CORS请求需要携带cookie时，需要服务端配置Access-Control-Allow-Credentials头信息，前端也需要设置withCredentials。
浏览器将CORS请求分成两类：简单请求和非简单请求。简单请求需要满足以下两大条件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71432a2f33d01c484ccd5c2047641421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc74a9760f26daf07fb957a531babeba/" rel="bookmark">
			AD画板流程和快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AD画板流程和快捷键 AD画板流程新建工程新建原理图和PCB并保存新建原理图库和PCB库绘制原理图库和PCB库显示pcb library绘制pcb库，设置原点位置测量距离快捷键：r 、m切换单位：q 绘制原理图画线：f2原理图自动添加器件编号：t 、a、a编译原理图：导入原理图到pcb中： PCB绘制设置规则：Keep-Out Layer层绘制板框图设置原点：定义板形，先选中板框，然后：d 、s、d 布局切换单位：q测距r、m删除效果：shift+c适当调节器件丝印大小，避免影响看图： 布线布线：f2过孔：*器件换层：L过孔盖油： 敷铜p、g 导出gerber文件导出非机械层导出机械层导出钻孔层 结束 AD画板流程 新建工程 默认配置就行，这里输入工程名和工程位置
新建原理图和PCB并保存 新建原理图库和PCB库 完成上面的流程，工程目录如下：
绘制原理图库和PCB库 记录一些常用的功能
显示pcb library 绘制pcb库，设置原点位置 测量距离快捷键：r 、m 切换单位：q 绘制原理图 画线：f2 原理图自动添加器件编号：t 、a、a 弹出以下菜单：
编译原理图： 编译信息在Messages面板：
导入原理图到pcb中： PCB绘制 设置规则： Keep-Out Layer层绘制板框图 设置原点： 定义板形，先选中板框，然后：d 、s、d 布局 布局的时候要考虑布线
切换单位：q 测距r、m 删除效果：shift+c 适当调节器件丝印大小，避免影响看图： 布线 布线：f2 过孔：* 器件换层：L 过孔盖油： 选中所有过孔，然后勾选如下选项。
敷铜 p、g 一般按照如下设置即可：
导出gerber文件 导出非机械层 点击ok，弹出CAMtastic1.Cam，直接关闭，不需要保存，如下图所示：
导出机械层 其他选项默认，点击ok，弹出CAMtastic1.Cam工程文件，还是直接关闭，不用保存
导出钻孔层 弹出文件，依旧不保存，直接关闭
导出文件一般在工程目录下，Project Outputs for [project]，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc74a9760f26daf07fb957a531babeba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d034ba23faa844629a0b9bf8781b2a4/" rel="bookmark">
			用python做计算器（超级版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用python做计算器（超级版） 经过三分钟的思考，高级版计算器被我升级了，变成了更快捷，更简单的超级版
库 依旧还是我们忠实的sympy库，非常好用。
string附属功能 这次因为一个一个输入数太麻烦了，我就改成 1+1 这种形式了（横版）。主要是应用string的检索，不懂得人可以去官网看看（3. An Informal Introduction to Python — Python 3.9.13 documentation）
主要就是通过对于输入的字符串进行某一段的索取，因为字符串是不允许删减的，所以只有这种办法。
寻找运算符 list_s = ["+", "-", "*", "/", "!", "^", "%"] function = input() while(1): if(function[f_search] in list_s): sym = function[f_search] break else: f_search += 1 先设置一个list，把所有的运算符放在里面，记住得是string类型的。这里我只放了一部分，并没有都做。然后用一个while循环，不断去找function的运算符的地方，如果找到了，就赋值给一个变量，如果不是运算符，就将f_search加一。这样可以从输入的string变量的第一个字符到最后一个字符去找运算符。
截取第一个数 num1 = function[0:f_search] 因为我是对于运算符前面进行检索，所以第一个是0。0到f_search就可以确保第一个数不会包括运算符，避免之后出问题。这里我不用了if和else就是因为我输入的运算符是！（阶乘）的时候不会出错，具体原因接下来讲。
截取第二个数 length = len(function) gan = 1 + f_search if(length != （f_search + 1)): num2 = function[gan:length] 这里定义了一个gan变量，也是为了确保截取第二个数的时候不会包括运算符。这里还获取了一下function的长度，如果长度和运算符的一致的话就不进行第二个数的截取了，因为阶乘只要一个数。这里要记住+1，不然length和f_searc永远不会相等。
数过大的问题 try: result = float(num1) ** float(num2) except OverflowError: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d034ba23faa844629a0b9bf8781b2a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03eb23da50f9bad22ab71828631bdc00/" rel="bookmark">
			项目实战！手把手教你 Jmeter 性能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今日分享：如何使用 jmeter 进行性能测试，就拿一个具体项目为例进行讲解。
一、目录结构
说明：确认转让接口的入参依赖于：前台登录接口和获取submitToken接口
二、目录结构中的：撤资项目---测试计划
内容如上图所示
三、目录结构中的：确认撤资---线程组
内容如下图所示：
四、目录结构中的：用户参数 填写登录的用户名和密码
内容如下图所示：
五、目录结构中的：BeanShellPreProcessor---前置处理器
内容如下图所示：
java代码为：【使用base64对用户名密码加密】
import org.apache.commons.codec.binary.Base64; String username = vars.get("username"); String password = vars.get("password"); String combineduserpass = username + ":" + password; byte[] encodedUsernamePassword = Base64.encodeBase64(combineduserpass.getBytes()); vars.put("auth",new String(encodedUsernamePassword)); 备注：
username---用户参数中的：名称
password----用户参数中的：名称
六、目录结构中的：HTTP信息头管理器
内容如下图所示：
备注：HTTP信息头管理器中的名称相当于python文件headers里的内容
七、目录结构中的：HTTP请求—前台登录接口
内容如下图所示：
备注：
Body Data内容：{"authorization": "Basic ${auth}"} 此内容为登录接口的入参
参数auth是BeanShellPreProcessor【前置处理器中：java代码返回的参数：auth】
八、目录结构中的：HTTP请求—前台登录接口 察看结果树
内容如下图所示：
九、目录结构中的：HTTP请求—前台登录接口 登录xAuthToken提取
内容如下图所示：
正则表达式提取器：获取登录接口返回的：xAuthToken值
备注：
1、引用名称可以随便取，但是正则表达式中的名称需与接口返回的xAuthToken的名称保持一致；
2、一般获取第一个xAuthToken出现的值【模板/匹配数字】；
十、目录结构中的：HTTP请求—获取submitToken值
内容如下图所示：
备注：
1、该接口请求返回submitToken值；
2、入参如Body Data所示；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03eb23da50f9bad22ab71828631bdc00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7fe729016a44f35b6766dc9de792e3/" rel="bookmark">
			进程间的通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程通信就是指进程之间的信息交换
文章目录 前言一、共享存储二、管道通信三、消息传递 前言 进程是分配系统资源的单位（包括内存地址空间）因此各进程拥有的内存地址空间相互独立，为了保证安全，一个进程不能直接访问另一个进程的地址空间，但进程之间的信息交换有事必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法。
一、共享存储 共享存储：两个进程虽不能直接访问彼此的地址空间，但操作系统为他们开辟了一段共享空间，两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。操作系统只负责提供共享空间和同步互斥工具（如P、V操作）。
共享存储又分为两种：基于数据结构的共享和基于内存区的共享。
基于数据结构的共享：这种共享方式速度慢，限制多是一种低级的通信方式。比如共享空间里只能放一个长度为10的数组（只能存放一种固定的数据结构）。
基于存储区的共享：这种共享方式速度快，是一种高级通信方式。在内存中画一块共享存储区，数据的形式，存放位置都由进程控制，而不是操作系统。
二、管道通信 “管道”：指用于链接读写进程的一个共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的缓冲区。
管道通信：
1.“管道”只能采用半双工通信，即某一时间段内只能实现单向的传输，如要实现双向同时通信，则需要设置两个通道。
2.各个进程要互斥的访问管道。
3.数据以字符流的形式写入管道，当管道写满时写进程的write（）系统调用将被阻塞，等待读进程将数据取走，当读进程将数据全部取走后，管道变空，此时读进程read（）系统调用将被阻塞。
4.如果没写满就不允许读，如果没读空，就不允许写。
5.数据一旦被读出，就从管道中被抛弃，这就意味着读进程只能有一个否则会有读错数据的情况。
三、消息传递 进程间的数据交换以格式化消息（由消息头和消息体组成）为单位，进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。
消息头包括：发送进程ID，接收消息ID，信息类型，消息长度等格式化消息（计算机网络中的“报文”其实就是一种格式化的消息）
消息传递分为两种：直接通信方式和间接通信方式。
直接通信方式：消息直接挂到接收进程的消息缓冲队列上。（通过原语来发送和接收）
间接通信方式：消息先发送到中间实体（信箱）中，因此也称为信箱通信方式（与管道不同的是多个消息都放在一个指定的信箱中，通过接收原语来接收相应的消息）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39344eaa6a4b4b2268ad464525fd67b/" rel="bookmark">
			《python网络应用开发》大作业报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
股票数据爬取 **
目录 **股票数据爬取** 1.大作业目的2.大作业内容3.需求分析4.实现思路5.详细实现6. 源代码运行小结 1.大作业目的 从网易股票爬取股票信息，包括每只股票的代码、名称、价格、涨跌幅、涨跌额；
2.大作业内容 （1） 从网易股票爬取股票信息，包括每只股票的代码，名称，价格，涨跌幅，涨跌额；
链接: 点击此处
（2） 根据成交额对获取到的股票进行排序；
（3） 将结果存储到csv文件中；
（4） 将结果存储到MySQL或MongoDB数据库里；
（5） 创新性设计与实现（如代理，异步携协程，分布式爬虫等）。
3.需求分析 实现爬取网易股票数据的需求
根据大作业要求，完成指定内容的爬取和保存，并撰写大作业报告，要求内容翔实，条理清晰，图文并茂（用例图、流程图、效果截图），主要（关键代码）须有详细注释，写清楚测试结果，并对存在的问题及后续需改进的方面进行分析。
1）完成相关模块和第三方库的安装配置；
2）通过相关技术完成源码的爬取；
3）实现指定内容的提取；
4）实现数据的保存；
2、问题的解决方案：
根据系统功能要求，可以将问题解决分为以下步骤：
（1） 完成爬虫的设计；
（2） 完成相关爬虫的部署；
（3） 根据问题描述，设计提取方法；
（4） 将结果存入文件及数据库中；
（5） 功能调试；
（6） 完成大作业总结报告。
4.实现思路 1、问题描述（功能要求）：
（1）完成相关模块和第三方库的安装配置；
（2）通过相关技术完成源码的爬取；
（3）实现指定内容的提取；
（4）实现数据的保存；
2、问题的解决方案：
根据系统功能要求，可以将问题解决分为以下步骤：
（1） 根据问题描述，设计提取方法；
（2） 将结果存入文件及数据库中；
（3） 进行数据分析并生成可视化图像
（4） 功能调试；
环境介绍：python 3.9
pycharm
requests
csv
MySQL
5.详细实现 （1）打开网易股票网易股票网址链接: link
（2）&lt;分析网页性质&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39344eaa6a4b4b2268ad464525fd67b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4c7a278ca2fe25ff59bc78e69a6184/" rel="bookmark">
			spring boot 常见注解及其作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@SpringBootApplication@component 、@service、@Controller、@Repository@ResponseBody@RsetController@AutoWired、@Qualifier、@Resousce@RequestMapping、@GetMapping、@PostMapping@Value、@ConfigurationProperties、@PropertySource@Configuration、@Bean （一）@SpringBootApplication：
是springboot项目的核心注解，目的是开启自动配置。
学习这个注解之前，需要学习spring中的@ConponentScan、@SpringBootConfiguration、
@enableAutoConfiguration ，@SpringBootApplication等同于这三个注解；
1、@ConponentScan:用来自动扫描被这个注解标识的类，最终会生成ioc容器里里面的bean组件，默认扫描的范围是这个配置类所在的包及其子包中的类
2、@SpringBootConfiguration：与@configuration作用一致，都是用来声明当前类为配置类，但是这里的作用是声明springboot主类所使用的配置类
3、@enableAutoConfiguration：开启自动配置、是springboot实现自动化配置的和核心注解、通过这个注解将spring应用所需的bean注入到容器当中。
（一） @component 、@service、@Controller、@Repository
作用基本上一致：都是将类注入到ioc容器当中，但是其中使用场景各有不同；
@component ：一般作用在entity实体类上面；
@service：一般作用在service业务逻辑层；
@Controller：一般作用于控制控制层；
@Repository：一般作用在dao持久层；
（三）@ResponseBody：可以作用在方法或者是类上面，表示该方法返回的结果直接写入Http Response body 当中，也就是不回经过视图解析器，直接将返回的数据展示在页面上;
(四）@RsetController ：用于处理请求，通常作用在控制层中的类之上，等同于@Controller和@ResponseBody；
(五) @AutoWired、@Qualifier、@Resousce :作用基本相同，都是注入属性，但是使用场景不同，@AutoWired是通过类型注入属性，@Qualifier是通过名称注入属性，@Resousce可通过类型和名称注入属性
（六）@RequestMapping、@GetMapping、@PostMapping ：这三个注解作用类似，可以通过这些注解来指定控制器可以处理哪些URL请求，但是作用场景不同；@RequestMapping通过该注解就可以使用配置的URL来进行访问，方式可以是post或者get请求；@GetMapping功能类似，但是限定了get请求，@PostMapping ：功能类似，但是限定了post请求。
（七）@Value、@ConfigurationProperties、@PropertySource：@Value作用在组件中的属性之上，用于读取配置文件；@ConfigurationProperties配置属性作用在类上，可以读取配置类当中的属性作用于当前类中属性；@ConfigurationProperties 参数：prefix=（"XXX"）意思就是读取配置文件当中前缀为”XXX“所匹配的属性；@PropertySource:指定属性文件，参数：value={classpath:"属性文件名称" } 、encoding="字符编码" ；@PropertySource通常和@ConfigurationProperties 注解一起使用​​​​​​​
（八）@Configuration、@Bean :@Configuration作用于类上，将当前类作为配置类，@Bean将组件注入到ioc容器当中；通常一起组合使用；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a7dfb70671bf8fdb1e70772f2751b4/" rel="bookmark">
			C&#43;&#43;三级练习题-1 爬楼梯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		爬楼梯
题目描述
树老师爬楼梯，他可以每次走1级或者2级，输入楼梯的级数，求不同的走法数 例如：楼梯一共有3级，他可以每次都走一级，或者第一次走一级，
第二次走两级 也可以第一次走两级，第二次走一级，一共3种方法。
输入格式
输入包含若干行，每行包含一个正整数N，代表楼梯级数，1 &lt;= N &lt;= 30。
输出格式
不同的走法数，每一行输入对应一行输出。
输入数据 1
5
8
10
输出数据 1
8
34
89
思路
这题可以用递归，其实与斐波那契数列差不多，先列式子，在解答。
代码
#include &lt;bits/stdc++.h&gt; #define N 1000010 using namespace std; int calculate(int n)//主函数 { if(n==1) return 1; if(n==2) return 2; return calculate(n-1)+calculate(n-2);//递归 } int main() { int n; while(scanf("%d",&amp;n)!=EOF)//无限输入 cout&lt;&lt;calculate(n)&lt;&lt;endl;//输出 return 0; } 以上就是今天内容，更多请见官网：ylkj.mysxl.cn
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/260/">«</a>
	<span class="pagination__item pagination__item--current">261/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/262/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>