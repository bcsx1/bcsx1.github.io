<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a830dfc9d7e7200e32cb41bab5e651/" rel="bookmark">
			快速转换PDF文件: Python和PyMuPDF教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决问题 有时候将文档上传Claude2做分析，有大小限制，所以需要切割pdf文档为几个小点的文档，故才有了本文章。
如何用Python和PyMuPDF制作你想要大小的PDF？
PDF是一种广泛使用的文件格式，可以在任何设备上查看和打印。但是，有时您可能只需要查看PDF文件中的前几页，而不是整个文件。在这种情况下，将PDF文件转换为只包含指定页数的新文件可能是有用的。本文将介绍如何使用Python和PyMuPDF模块来实现此任务。
安装PyMuPDF模块 在使用PyMuPDF之前，我们需要先安装它。可以使用以下命令来安装PyMuPDF：
pip install PyMuPDF 导入PyMuPDF和wxPython模块 接下来，我们需要导入PyMuPDF和wxPython模块：
import fitz import wx 创建GUI界面 为了方便用户输入PDF文件和页码数量，我们将创建一个简单的GUI界面。我们将使用wxPython模块来创建GUI界面。以下是代码示例：
class PDFExtractorFrame(wx.Frame): def __init__(self, *args, **kw): super(PDFExtractorFrame, self).__init__(*args, **kw) panel = wx.Panel(self) vbox = wx.BoxSizer(wx.VERTICAL) self.file_picker = wx.FilePickerCtrl(panel, message="选择PDF文件", wildcard="PDF Files (*.pdf)|*.pdf", style=wx.FLP_DEFAULT_STYLE | wx.FLP_USE_TEXTCTRL) vbox.Add(self.file_picker, 0, wx.EXPAND | wx.ALL, 10) self.page_input = wx.TextCtrl(panel, value="1", style=wx.TE_PROCESS_ENTER) vbox.Add(self.page_input, 0, wx.EXPAND | wx.ALL, 10) extract_button = wx.Button(panel, label="提取", size=(70, 30)) extract_button.Bind(wx.EVT_BUTTON, self.on_extract) vbox.Add(extract_button, 0, wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a830dfc9d7e7200e32cb41bab5e651/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c0aff191eaa1a98c9a2b1dc85c6585d/" rel="bookmark">
			webrtc的线程模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
线程的声明
线程创建过程
向线程中投递消息
从消息队列中取消息的具体实现
处理线程消息
webrtc线程模块的实现逻辑在 rtc_base\thread.h 文件中
比如想创建一个线程：
//声明要创建的线程指针，通过智能指针管理 std::unique_ptr&lt;rtc::Thread&gt; video_thread_; // 创建线程 video_thread_ = rtc::Thread::Create(); //设置新创建的线程名 video_thread_-&gt;SetName("video_thread_", video_thread_.get()); //开启线程 video_thread_-&gt;Start(); //向线程投递要处理的消息 video_thread_-&gt;Post(RTC_FROM_HERE, this, MESSAGE_ID);// MESSAGE_ID 自定义的消息id //向线程投入带有消息体的消息 video_thread_-&gt;Post(RTC_FROM_HERE, this, VIDEO_INFO,new rtc::TypedMessageData&lt;VIDEO_INFO_MEESAGE&gt;(r)); //其中RTC_FROM_HERE 是个宏定义，标记线程调用的原位置 // Define a macro to record the current source location. #define RTC_FROM_HERE RTC_FROM_HERE_WITH_FUNCTION(__FUNCTION__) 下面看下线程的具体实现
线程的声明 //线程继承自一个任务队列，并且有两个存储消息的消息队列 //普通消息 messages_，延时消息 delayed_messages_ class RTC_LOCKABLE RTC_EXPORT Thread : public webrtc::TaskQueueBase { explicit Thread(SocketServer* ss); explicit Thread(std::unique_ptr&lt;SocketServer&gt; ss); private Message msgPeek_; //声明对应的消息 //MessageList 具体的定义： //typedef std::list&lt;Message&gt; MessageList; MessageList messages_ RTC_GUARDED_BY(crit_); //延时队列继承自 std::priority_queue&lt;DelayedMessage&gt; PriorityQueue delayed_messages_ RTC_GUARDED_BY(crit_); uint32_t delayed_next_num_ RTC_GUARDED_BY(crit_); } 创建线程的实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c0aff191eaa1a98c9a2b1dc85c6585d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736fbf688e3f65149bda4d0a062019ce/" rel="bookmark">
			计算机毕业设计springboot基于HTML5的酒店预订管理系统4u2r79【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本项目包含程序+源码+数据库+LW+调试部署环境，文末可获取一份本项目的java源码和数据库参考。
系统的选题背景和意义 选题背景： 随着互联网的快速发展和人们生活水平的提高，旅游业也迎来了蓬勃的发展。酒店作为旅游行业的重要组成部分，其预订管理系统的效率和便捷性对于提升用户体验和酒店运营效益至关重要。传统的酒店预订方式存在诸多问题，如繁琐的手工操作、信息不透明、预订流程复杂等，已经无法满足现代化的需求。因此，开发一款基于HTML5的酒店预订管理系统具有重要的意义。
选题意义： 首先，基于HTML5的酒店预订管理系统可以提供更加便捷和高效的预订方式。通过在线预订系统，用户可以随时随地进行酒店预订，无需受限于时间和地点。同时，系统可以实现自动化处理，减少人工干预，提高预订效率，节省时间和精力。
其次，该系统可以提供更加全面和准确的酒店信息。通过系统的数据库管理，酒店的各项信息可以得到有效整理和更新，包括房型、价格、设施、评价等。用户可以根据自己的需求和偏好，选择最适合的酒店。同时，用户可以通过系统查看其他用户的评价和反馈，提高选择的准确性和信任度。
此外，基于HTML5的酒店预订管理系统还可以提供更加个性化的服务。系统可以根据用户的历史预订记录和偏好，推荐符合用户口味的酒店和特惠活动。用户可以享受到更多定制化的服务，提升旅行体验。
最后，该系统对于酒店经营者来说也具有重要意义。通过系统的数据分析和统计功能，酒店经营者可以了解市场需求和用户偏好，优化酒店的运营策略。同时，系统可以提供实时的房态信息和预订情况，帮助酒店经营者进行资源调配和收益管理。
综上所述，基于HTML5的酒店预订管理系统在提升用户体验、提高酒店运营效益和促进旅游业发展方面具有重要的意义。 以上选题背景和意义内容是根据本选题撰写，非本作品实际的选题背景、意义或功能。各位童鞋可参考用于写开题选题和意义内容切勿直接引用。本作品的实际功能和技术以下列内容为准。
技术栈： 前端Vue：用于构建交互式用户界面。
后端Java开发语言：使用Java作为后端开发语言。
Spring Boot框架：作为快速开发框架，替代了SSM框架，提供自动配置、快速构建等功能。
MySQL 5.7数据库：用于数据存储和管理。
使用Spring Boot，你可以通过依赖管理和自动配置来减少手动配置工作，并使用Spring框架的各种功能，如依赖注入、面向切面编程等。同时，Spring Boot还提供了用于构建RESTful API、集成测试和部署的工具和插件，使得开发过程更加高效和便捷。
功能需求分析 (1)的通用功能包括用户登录和密码修改，是两个角色共同需要使用的功能，用例分析如图3-1所示。
图3-1 通用功能用例分析图
(2)管理员可以对系统首页、个人中心、用户管理、会员等级管理、房间类型管理、酒店信息管理、订单信息管理、取消订单管理、留言反馈、系统管理等进行基本的信息管理。其用例分析如图3-2所示。
图3-2 管理员用例图
(3)用户可以实现对首页、酒店信息、酒店资讯、留言反馈、后台管理、个人中心等信息进行操作，用例分析如图3-3所示。
图3-3用户用例图
3.5 流程分析 3.5.1 登录流程 每个用户都有专属的密码和账号，在输入合法的账号和密码之后即可进入。登录流程如图3-4所示：
图3-4登录流程图
3.5.2 添加信息流程 管理层人员有添加信息功能。添加信息流程如图3-5所示：
图3-5 添加信息流程图
3.5.3 删除流程 用户可以选择把自己发布的信息删掉，选择要删除的信息确认之后，删除信息的操作就完成了。删除信息流程图如图3-6所示。
图3-6 删除信息流程图
3.6 本章小结 本章首先对整个进行了详细的需求描述，然后按照这些要求对的角色和功能进行了详细的分析，并对这些要求进行了详细的说明。同时为保证需求分析的全面性，还对的一些非功能性需求进行描述和对流程进行分析，为以后的的开发提供了一个比较完善的参考依据。
第四章 设计 4.1 总体设计 基于HTML5的酒店预订管理学统的建设可以为基于HTML5的酒店预订管理学统管理提供帮助，通过对一些基础信息管理实现针对性的安排，可以按照用户的角色权限使不同用户角色看到不一样的信息界面。现根据需求阶段的分析，我们可以大致确定需要包含的功能如下图所示：
总体结构图如下，见图4-1。
图4-1 总体结构图
4.2 数据库设计 数据库能直观反映表现的需求，数据库的设计能否切实符合的需求关系到整个最终的呈现结果。通过之前的分析梳理，明确了中需要包含的功能和要求。中除了涉及对数据库的增加、删除、查寻、修改的基础操作较多，还要理清实体间的对应关系，据此完成表结构的设计与实现。
4.2.1 数据库逻辑设计 为了更直观阐明数据库的设计，使用 Vision 绘制的基于HTML5的酒店预订管理学统数据模型E-R实体属性图。根据需求设计了以下几个主要实体。
酒店信息实体属性图，如图4-2所示。
图4-2酒店信息实体属性图
酒店信息评论实体属性图，如图4-3所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/736fbf688e3f65149bda4d0a062019ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/028df9d5e7af8aa9a32cf551d026220f/" rel="bookmark">
			ERROR: Could not find a version that satisfies the requirement cv2 (from versions: none)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在终端输入：pip install cv2
出现错误提示：
ERROR: Could not find a version that satisfies the requirement cv2 (from versions: none )
ERROR: No matching distribution found for cv2
原因：
没有名为cv2的库，将命令改为：pip install opencv-python
安装成功！
如果还是有错误，将命令改为：pip install opencv-contrib-python
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9aa8662f6f47f60a5767ef83986cb7e/" rel="bookmark">
			论文笔记--ERNIE-VIL 2.0: MULTI-VIEW CONTRASTIVE LEARNING FOR IMAGE-TEXT PRE-TRAINING
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文笔记--ERNIE-VIL 2.0: MULTI-VIEW CONTRASTIVE LEARNING FOR IMAGE-TEXT PRE-TRAINING 1. 文章简介2. 文章概括3 文章重点技术3.1 Multi-view learning3.2 对比损失函数 4. 文章亮点5. 原文传送门6. References 1. 文章简介 标题：ERNIE-VIL 2.0: MULTI-VIEW CONTRASTIVE LEARNING FOR IMAGE-TEXT PRE-TRAINING作者：Bin Shan Weichong Yin Yu Sun Hao Tian Hua Wu Haifeng Wang日期：2022期刊：arxiv preprint 2. 文章概括 文章提出了基于Multi-view进行预训练的多模态模型ERNIE-ViL 2.0，更高效地捕捉到模态内部和模态之间的特征。文章通过引入sequence of object tags作为一种特殊view，来提升模型对语义-图像的对齐能力。实验表明，ERNIE-ViL 2.0在多个下游多模态任务上取得了SOTA水平。
3 文章重点技术 3.1 Multi-view learning 文章的整体架构基于多视角学习(Multi-view learning)，简单来说就是将一个物体的多个角度的输入互为补充，比如3D物体的不同角度，比如不同组合方式，比如指纹的不同录入角度等。
首先，文章构建了各种不同的视角：
I2I(image-image)：针对输入的图片，我们通过图像增强方式来构造图像的多种视角。具体增强方法为对图片进行随机的剪裁、翻转或高斯模糊，得到图像的两个不同视角 I v 1 , I v 2 I_{v_1}, I_{v_2} Iv1​​,Iv2​​。T2T(text-text)：针对输入的文本，文章参考SimCSE[2]的dropout方法，即对输入的文本进行随机的dropout mask对其中一部分token进行掩码，得到文本的不同视角 T v 1 , T v 2 T_{v_1}, T_{v_2} Tv1​​,Tv2​​。I2T(image-text)/T2I(text-image)：针对输入的图片-文本对，我们引入special text sequence。具体来说，通过pretrained object detector对输入的图片进行目标检测，得到目标 o 1 , … , o k o_1, \dots, o_k o1​,…,ok​，然后生成prompt：This picture contains o 1 , o 2 , … , o k o_1, o_2, \dots, o_k o1​,o2​,…,ok​。通过这个特殊的sequence对图片标题中缺失的文本信息进行补充
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9aa8662f6f47f60a5767ef83986cb7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50216e5d8092462fc1b13644f0b7b467/" rel="bookmark">
			Excel透视表与python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、Excel透视表
1、源数据
2、数据总分析
3、数据top分析
二、python实现
1、第一张表演示
2、第二张表演示
一、Excel透视表 1、源数据 1）四个类目，每类50条数据
2）数据内容
2、数据总分析 1）选择要分析的字段，左侧为要对其进行汇总的数据，右侧为要汇总的具体值项
2）值字段设置
值汇总方式：数据计算方式
值显示方式：数据的百分比
数字格式：数字的表示方式（如小数点个数等）
3、数据top分析 1）按照近一个销售额对每个品类的top5进行分析
依据 “求和项：近一个月销售额” 对ID的top5进行选择
二、python实现 1、第一张表演示 import pandas as pd import numpy as np #读取原始文件 file=pd.read_excel('F:\Excel\\透视表.xlsx',sheet_name='销售源数据') #对数据汇总做成透视表 第一张表 data1=file.pivot_table(index=['品类'],values=['近一个月销售额','近一个月销量','团购价'],aggfunc=[np.sum,np.mean]).reset_index() data11=pd.DataFrame(data1.values[:,[0,2,3,6]],columns=['品类','求和项:近一个月销售额','求和项:近一个月销量','平均值项:团购价']).sort_values('求和项:近一个月销售额',ascending=False).reset_index(drop=True) data11['求和项:近一个月销售额']=data11['求和项:近一个月销售额'].astype(float).map(lambda x:'{:.1f}'.format(x)) data11['平均值项:团购价']=data11['平均值项:团购价'].astype(float).map(lambda x:'{:.1f}'.format(x)) data11 2、第二张表演示 #第二张表 data2=file.pivot_table(index=['品类','ID'],values=['近一个月销售额','近一个月销量','团购价'],aggfunc=[np.sum,np.mean]).reset_index() data22=pd.DataFrame(data2.values[:,[0,1,3,4,5]],columns=['品类','ID','求和项:近一个月销售额','求和项:近一个月销量','平均值项:团购价']) #按照品类选择出销售额最高的ID data22[['求和项:近一个月销售额','求和项:近一个月销量','平均值项:团购价']]=data22[['求和项:近一个月销售额','求和项:近一个月销量','平均值项:团购价']].astype(float) #建立一张新表进行拼接 data24=pd.DataFrame() for i in data11['品类'].to_list(): data23=data22.loc[data22[data22.品类==i].index,:].nlargest(5,'求和项:近一个月销售额') data24=pd.concat([data24,data23],axis=0) data24['求和项:近一个月销售额']=data24['求和项:近一个月销售额'].astype(float).map(lambda x:'{:.1f}'.format(x)) data24['平均值项:团购价']=data24['平均值项:团购价'].astype(float).map(lambda x:'{:.1f}'.format(x)) data24 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26095df3597d0a46c69c581134664d38/" rel="bookmark">
			微信Dat文件转图片（文末含工具下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你是否遇到过这样的场景，电脑使用了较长的一段时间后，微信占用了比较大的存储空间，
导致电脑的存储空间不够用，想要先把文件备份或者删除掉，这是我们会发现视频和文件是可以直接备份的，但是图片被微信加密成了是看不懂的dat文件，不删除，电脑空间不够，想删除，又不知道删除的是哪个文件？
这时很多非IT专业的小伙伴，可能就只能眼睁睁的看着电脑的空间越来越少，却无计可施！
那么是否有办法来将dat文件转换成普通的图片格式呢，例如：jpg格式。
下面就简单的介绍一下使用Python进行dat转换为jpg的方法，写的比较简单没有增加复杂逻辑（文末，会放封装好的exe工具）
代码主要会分为两部分：
1、使用tkinter选择文件夹路径和文件要保存的路径
2、将dat文件转换为jpg的简单实现逻辑
完整代码如下：
import tkinter as tk from tkinter import * from tkinter import ttk, messagebox from tkinter import filedialog import os # 创建Tkinter帧的实例 app = tk.Tk() # 定义几何 app.geometry("950x350") def get_folder(): path = filedialog.askdirectory() str_folder_obj.set(path) def save_folder_path(): path = filedialog.askdirectory() str_save_obj.set(path) def DatToImage(): folder_path = str_folder_obj.get() save_path = str_save_obj.get() if save_path == "" or folder_path == "": messagebox.showinfo("Alert", "文件地址和保存地址都不能为空") else: openDatFile(folder_path, save_path) messagebox.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26095df3597d0a46c69c581134664d38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a28aea38f7b56a71d845befce377d2/" rel="bookmark">
			ansible安装lnmp（集中式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装nginx二、安装mysql三、安装php测试： 一、安装nginx - name: the nginx play hosts: webservers remote_user: root tasks: - name: stop firewalld #关闭防火墙 service: name=firewalld state=stopped enabled=no - name: selinux stop command: '/usr/sbin/setenforce 0' - name: mount dev #挂载光盘 mount: src=/dev/sr0 path=/mnt state=mounted fstype=iso9660 ignore_errors: true - name: copy nginx.repo #nginx源 copy: src=/etc/yum.repos.d/nginx.repo dest=/etc/yum.repos.d - name: install nginx yum: name=nginx state=latest ignore_errors: true - name: restart nginx service: name=nginx state=started enabled=yes ignore_errors: true vim /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a28aea38f7b56a71d845befce377d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0189816ea88889b4905f20db3bd2036/" rel="bookmark">
			python 数字人视频生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 您只需要录纸一段十几秒的视频，就可以制作数字人了，视频模板可反复利用生成，根据语音去匹配嘴型。
公众号看高清演示视频
数字人视频
base_image = Image.open(base_image).convert('RGB') fore_image = Image.open(fore_image).resize(base_image.size) scope_map = np.array(fore_image)[:,:,-1] / 255 scope_map = scope_map[:,:,np.newaxis] scope_map = np.repeat(scope_map, repeats=3, axis=2) res_image = np.multiply(scope_map, np.array(fore_image)[:,:,:3]) + np.multiply((1-scope_map), np.array(base_image)) res_image = Image.fromarray(np.uint8(res_image)) res_image.save(save_image) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9392e2f677f905d2989c5109b0d5379/" rel="bookmark">
			Unity面向新手，如何使物体移动，让物体自由的动起来。几种移动方案讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在大部分的Unity游戏开发中，移动是极其重要的一部分，移动的手感决定着游戏的成败，一个优秀的移动手感无疑可以给游戏带来非常舒服的体验。而Unity中有多种移动方法，使用Transform，使用刚体Rigidbody，使用CharacterController，使用NavMesh导航系统等等等等。当然，对于新手来说，最常见的莫过于使用Transform和Rigidbody这两种组件的移动方案。所以，这篇文章将就这两种移动方案进行分析讲解。
注意！！！以下代码均为2D场景，3D同理
二、Transform Transform组件是GameObject的变换组件，可以操纵GameObject的位置(Position)，大小(Scale)，旋转(Rotation)等等。所以，使用Transform组件进行物体移动是一个非常不错的选择，以下是通过Transform组件实现的几种移动方式，以及对应的场景。
1.Translate 使用Transform的Translate函数可以在GameObject的本地坐标系下进行平移。可以传入一个位移向量作为参数，指定平移的方向和距离。
[SerializeField] private float moveSpeed; private void Update() { //自动向右移动 transform.Translate(Vector2.right * moveSpeed * Time.deltaTime); } //物体沿向量指向方向移动 //Vector2.right 向右移动向量，也可以写成自己定义的 //moveSpeed 移动速度，通常为float型 Translate方法在游戏中可以用作物体移动，适用简单的移动方式，例如箱子在平面上自动移动等等。
2.MoveTowards 使用Transform的MoveTowards函数可以实现直线移动到目标位置。可以传入当前位置、目标位置和移动速度来控制移动的速度和到达目标位置。
MoveTowards函数对应的三个参数分别为(当前位置，目标位置，移动速度)，前两个为Vector类型，最后一个为float类型，也可以写成整型等。
例如：将物体移动到(5，5)的位置
[SerializeField] private float moveSpeed; private void Update() { transform.position = Vector2.MoveTowards(transform.position,new Vector2(5,5),moveSpeed); } 3.Lerp 使用Transform的Lerp函数可以实现平滑插值移动。可以传入起始位置、目标位置和插值比例来控制移动的过渡效果。
Lerp函数对应的三个参数分别为(当前位置，目标位置，插值比例)，前两个为Vector类型，最后一个为float型=类型，插值比例范围是[0，1]，当lerp取0时，物体不移动，lerp取1时，物体直接移动到目标位置，lerp取值越大，物体移动越快。
例如：将物体移动到(5，5)
[SerializeField] private float moveSpeed; [SerializeField] private float lerp; private void Update() { transform.position = Vector3.Lerp(transform.position, new Vector2(5,5), lerp); } 接下来，将讲解一下Lerp函数的移动原理：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9392e2f677f905d2989c5109b0d5379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e248aa255aadb148a923e4ae1728dcc6/" rel="bookmark">
			java实现倒计时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思路:启动newSingleThreadScheduledExecutor单线程池,延时结束时间的毫秒数和现在的毫秒数的差
long now = System.currentTimeMillis(); Calendar calendar = Calendar.getInstance(); calendar.clear(); //指定时间的毫秒数 PropKit.get("") 可以替换成自己的日期 calendar.set(Integer.parseInt(PropKit.get("year")), Integer.parseInt(PropKit.get("month")), Integer.parseInt(PropKit.get("day")), Integer.parseInt(PropKit.get("hour")), Integer.parseInt(PropKit.get("minutes")), Integer.parseInt(PropKit.get("second"))); // Calendar 的 month 从 0 开始，也就是全年 12 个月由 0 ~ 11 进行表示。 long millis = calendar.getTimeInMillis(); long start = millis - now; Log log = Log.get(); // hutool的工具类 log.info("距离结束还有{}毫秒",start); ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(); scheduledExecutorService.schedule(()-&gt;{ // 执行业务 },start,TimeUnit.MILLISECONDS); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04e452c8e73ba48fa7ae12a669aeef9e/" rel="bookmark">
			vue的templete中不能使用import导入的js方法解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在methods中在定义一次
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f7e9bf4608f754c5f700bb09f7f8c05/" rel="bookmark">
			linux安装expect(解决自动安装脚本的回复)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作用 :可以根据关键字匹配,自动输入结果 比如(yes/no)
安装 expect依赖tcl库
安装包：永久有效
链接：百度网盘 请输入提取码
提取码：2jbr
链接：百度网盘 请输入提取码
提取码：63g1
我将两个压缩包传到了/opt/目录下 1.安装tcl tar xf tcl8.4.11-src.tar.gz cd tcl8.4.11/unix ./configure make &amp;&amp; make install 2.安装expect tar xf expect-5.43.0.tar.gz cd expect-5.43.0 ##### 注意:--with-tclinclude是自己安装tcl的目录 ./configure --with-tclinclude=/opt/tcl8.4.11/generic --with-tclconfig=/usr/local/lib/ make &amp;&amp; make install 创建软链接 ln -s /opt/expect-5.43/expect /usr/bin/expect
测试用例 expect结合scp 创建文件:vim test.sh
#!/usr/bin/expect set timeout 10 set username [lindex $argv 0] set password [lindex $argv 1] set ip [lindex $argv 2] set port [lindex $argv 3] set sourcePath [lindex $argv 4] set targetPath [lindex $argv 5] spawn scp -P$port $sourcePath $username@$ip:$targetPath expect { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f7e9bf4608f754c5f700bb09f7f8c05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45bfa8a87d75ce4f9026a26f1daeda10/" rel="bookmark">
			轻松解决宝塔面板设置了授权IP访问，但是IP变动导致访问不了面板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了宝塔面板的安全与隐蔽性，我们很多站长会设置授权IP，授权IP的作用是：设置访问授权IP,多个请使用逗号(,)隔开;注意：一旦设置授权IP,只有指定IP的电脑能访问面板!
但是很多站长不是通过专用的虚拟通道访问，用的都是宽带运营商提供的宽带，这就会有个很尴尬的情况，就是我们的IP会在一天甚至几天后发生变化，于是访问面板就会出现下面的错误提示：
那该如何解决呢？其实很简单，仅需要技术宅提供的一条命令即可删除此设置，前提是需要你没有关闭服务器的SSH服务，在SSH中执行：
rm -f /www/server/panel/data/limitip.conf即可清理授权IP中设置的IP！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1c53a88837993b51aaad0618b5910b/" rel="bookmark">
			vue.draggable 插件 API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue.draggable 中文链接： https://www.itxst.com/vue-draggable/vnqb7fey.html
1. 安装方式 yarn add vuedraggable npm i -S vuedraggable 2. 使用方法 // 1. 在需要的页面直接引用 import Draggable from "vuedraggable"; // 2. 当组件使用 components: { Draggable }, // HTML &lt;Draggable/&gt; 1. Attributes 参数说明类型可选值默认值v-model绑定的数据---list不能与 v-model 同时写在 v-draggable 上 绑定的数据---ghostClass被选中且被拖动时的样式（类名，如果设置了hover，一定要加 !important, 不然会失效）string--chosenClass鼠标按下且悬浮时的样式（类名，如果设置了hover，一定要加 !important, 不然会失效）string--dragClass拖动元素样式（类名）string--animation动画效果string-“0”delay延迟拖动string-“0”scroll是否允许拖动到隐藏区域boolean-truescrollFn滚动回调函数function--scrollSensitivity距离滚动区域多远时，滚动滚动条---scrollSpeed滚动速度---disabled是否禁用拖动boolean-falsehandle可拖动元素的类名 ( 如：.move, 一定要加点，不然无法选中)string--filter禁止某一行被拖拽的类名（如：filter=“.forbid” 在需要禁用的地方设置 :class= “item.forbid” 就能禁用）string--draggable可被拖动的类名string--options多个组之间互相拖拽配置项object{ group:{name: ‘itxst’,pull:‘clone’,put:false},sort: true }-—groupobjectname: string 设置相同的名称，多个组件之间可以互相拖拽 拖出 pull: ‘clone’ / Boolean / Array / Function 当类型为 Boolean / Function 时，表示能/不能拖出, Function 返回 boolean， ‘clone’ 默认值，拖出时克隆当前组的数据到其他组 拖入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac1c53a88837993b51aaad0618b5910b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d409a5d5ee790f8f8375ea5014c62486/" rel="bookmark">
			Android Studio/Android SDK加载packages不全、无法下载问题/国内镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题描述解决思路解决思路1：翻墙解决思路2：通过国内镜像地址访问 其他总结：遇到问题不要怕折腾……参考文档 问题描述 问题的本质是无法直接获取官方文件（因为GFW）
运行SDK Manager后无法加载全部packages，按网络教程配置代理后没有效果。在AS中绑定SDK Manager后一样加载不全packages，且请求资源的URL列表为空。
解决思路 解决思路1：翻墙 尝试无果，放弃。
解决思路2：通过国内镜像地址访问 首先要安装好SDK Manager和Android Studio（建议先安装好SDK再装AS），并在Android Studio中绑定SDK路径，可以在AndroidDevTools官网下载安装，具体教程可参考Android Studio配置安卓环境并创建项目（卸载重装也是一种方案，卸载AS后要删除C盘如下图所示的三个文件夹再重装）；
（没有卸载干净的话，重装后可能会有问题，可参考彻底卸载Android Studio）
在Android Studio菜单栏中依次选择“File-&gt;Settings-&gt;Appearance &amp; Behavior-&gt;System Settings-&gt;HTTP Proxy”，按下图进行配置，填写东软信息学院开源镜像站网址：
http://mirrors.neusoft.edu.cn/ 设置完成后，“Android SDK”中会自动加载出获取资源的国内镜像地址，packages也会加载完全，如下图；
下载所需的工具，选择“File-&gt;Sync Project with Gradle Files”即可。
其他 如果程序编译又出现了其他问题，可以先试试确保“C:/Users/当前用户/.gradle”文件夹下无“gradle.properties”文件（有的话直接删除），并在项目的“build.gradle”文件替换原有配置，需要替换的配置见下图：
两处均替换为：
maven{ url 'https://maven.aliyun.com/repository/google' } maven{ url 'https://maven.aliyun.com/repository/jcenter' } maven{ url 'http://maven.aliyun.com/nexus/content/groups/public' } 可以在界面下方的Terminal使用以下命令编译项目（能看到报错信息）：
gradlew compileDebugSource 编译成功无报错，开发环境搭建完成~ 可以愉快地开发啦 ~^_^~
总结：遇到问题不要怕折腾…… 参考文档 [1] Android SDK 国内镜像源
[2] Unable to resolve dependency for ‘:app@debug/compileClasspath’: Could not resolve com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d409a5d5ee790f8f8375ea5014c62486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc32c99c4000e31fa5356b050c9c5247/" rel="bookmark">
			AntV-G6：图表自动居中显示/画布自适应/fitView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 需求描述调研分析关于fitView的使用问题记录① 设置后“没有效果”② 只有一个节点时，节点变得超大③ 图表缩放得太小 总结参考网址 需求描述 图表节点较多时，可能分布到屏幕可视范围之外，期望图表自动居中显示
调研分析 阅读官网文档：G6.Graph配置项，一下就看到了这个配置项：
看起来只要在初始化图表的配置里加上“fitView: true”就能万事大吉了（然鹅真的是这样吗◐.◑）
关于fitView的使用问题记录 ① 设置后“没有效果” 这种情况是：已将fitView设为true，图表还是超出了屏幕
问题分析：开启fitView后，图表确实进行了自动缩放、居中的操作；但这些操作基于的“画布”可能并不是我们预期的“屏幕可视范围”，导致缩放后图表依然超出屏幕
解决思路：配置fitViewPadding，缩小画布范围
② 只有一个节点时，节点变得超大 这种情况是：已经设置了fitView、fitViewPadding，数据较多的情况下显示符合预期；但图表只存在一个节点（或者几个离得很近的节点）时，节点变得超大
问题分析：首先要充分理解fitView的作用——为了让图表最大限度地充满画布而自动进行缩放、偏移；只有一个节点的图表被放大到“充满画布”，自然会变得超大
解决思路：配置maxZoom，限制图表的最大缩放比例（根据官网文档，maxZoom和minZoom对于图表缩放比例具有最高优先级）
③ 图表缩放得太小 与第二个问题同理，可以调整fitViewPadding放大画布范围，也可配置minZoom限制图表最小缩放比例
总结 在初始化图表的配置里加上“fitView: true”，可以使图表自动缩放、偏移，以达到最大限度地充满画布的效果；自适应效果不太好的两个调整方向：①配置fitViewPadding限制画布范围，②配置maxZoom、minZoom限制图表最大/最小缩放比例 参考网址 [1] G6.Graph配置项
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8eb4ebaea9e4106cc931d5f1e736b244/" rel="bookmark">
			usleep头文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、usleep头文件概述 usleep头文件定义了usleep()函数，该函数用于让进程休眠指定的微秒数。
该函数的原型定义如下：
#include &lt;unistd.h&gt; int usleep(useconds_t microseconds); 其中，useconds_t表示微秒数，是一个unsigned int类型。
二、usleep函数的使用 使用usleep函数需要包含头文件unistd.h，一般情况下可以在代码文件的开头使用如下指令来引入：
#include &lt;unistd.h&gt; 使用usleep函数可以实现让进程休眠指定的微秒数。例如，下面的代码使用usleep函数让程序休眠500毫秒：
#include &lt;unistd.h&gt; int main() { usleep(500000); // 休眠500毫秒 return 0; } 三、usleep函数的注意事项 1. usleep函数的参数必须是正整数 usleep函数的参数表示要休眠的微秒数，必须是正整数。如果传递了0或负数，usleep函数将不会有任何效果。
2. usleep函数可能会被信号中断 在调用usleep函数的过程中，如果进程捕捉到某个信号，就会中断usleep函数，跳转到信号处理函数进行处理。在信号处理函数返回之后，usleep函数会重新开始执行。
3. usleep函数可能会引起系统调度 在进程休眠期间，操作系统可能会进行调度，将其他进程调度到CPU上运行。如果其他进程的优先级高于当前进程，操作系统可能会提前结束当前进程的休眠。此时，usleep函数会立即返回。
4. usleep函数可能会和定时器一起使用 usleep函数可以和其它定时器函数（如setitimer）一起使用，实现更复杂的定时功能。
四、完整代码示例 #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;signal.h&gt; void signal_handler(int signum) { printf("Catch signal %d\n", signum); } int main() { // 注册信号处理函数 signal(SIGINT, signal_handler); printf("Start sleeping...\n"); usleep(500000); // 休眠500毫秒 printf("End sleeping...\n"); return 0; } 上面的代码使用signal函数注册了一个信号处理函数，用于捕捉SIGINT信号。在程序运行过程中，如果用户按下Ctrl+C键，就会产生SIGINT信号，程序就会跳转到signal_handler函数进行处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8eb4ebaea9e4106cc931d5f1e736b244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11464fa9afba9f4b010dcbd244ba0ec5/" rel="bookmark">
			Android代码设置状态栏颜色及字体黑白色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.看我贴的代码。我这里提供了一个修改状态栏的方法。
/** *bDark true 黑色 false 白色 */ public void setDarkStatusWhite(boolean bDark) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { View decorView = getWindow().getDecorView(); //修改状态栏颜色只需要这行代码 getWindow().setStatusBarColor(getResources().getColor(android.R.color.white));//这里对应的是状态栏的颜色，就是style中colorPrimaryDark的颜色 if (decorView != null) { int vis = decorView.getSystemUiVisibility(); if (bDark) { vis |= View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR; } else { vis &amp;= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR; } decorView.setSystemUiVisibility(vis); } } } 2.在MainActivity活动中如何使用
public class MainActivity extends AppCompatActivity { private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (Build.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11464fa9afba9f4b010dcbd244ba0ec5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb794414a680b951a6902a675c208cd/" rel="bookmark">
			《CPU通识课》读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
摘要
第一章 CPU概览
第1节 CPU的发展历程
第2节 为什么我国需要自主研发CPU？
第3节 指令集
第4节 汇编语言
第5节 CPU的生产流程
第二章 CPU系统原理
第1节 基础理论
第2节 乱序执行
第3节 多发射和转移猜测
第4节 内存
第5节 从CPU到计算机
第三章 CPU生态
第1节 生态的重要性
第2节 操作系统
第3节 虚拟机
第4节 生态的优点
第5节 我国计算机事业的发展历程
结论与心得
引言 中科院计算基数研究所研究员、龙芯CPU首席科学家 胡伟武：要想彻底解决我国在计算机领域自主创新的问题，必须把眼光放得长远，自主研发中国的CPU势在必行。
从大学阶段一直到成为中科院计算技术研究所的一名科研人员，胡伟武始终没有忘记自己入党时立下的誓言，并时刻以身边的优秀党员作为自己学习的榜样。为了研发龙芯CPU，胡伟武带领几十名年轻科研人员日夜奋战，终于在2002年8月10日，将中国人设计的第一枚通用CPU“龙芯1号”研制成功，终结了国产计算机没有自主CPU芯片的历史。
“龙芯1号”诞生的随后20年中，胡伟武带领科研团队走出了一条从实验室走向市场的道路，随着一代代以龙芯命名的产品的更新换代，他们在学习中不断追赶全球最前沿技术，逐渐将龙芯二字发展成为中国自主CPU的代名词。最新亮相的龙芯3A5000系统通用CPU，已经接近国际主流CPU的性能，在部分实际应用中，其表现甚至优于国外同类型产品。
通过“龙芯1号”的研发历程，我们认识到一定要把中华民族的发展主导权牢牢抓在自己的手里，刻苦学习科学技术，对我们来说，就是这些信息产业的基础产品（像CPU、操作系统）要实现自主。自主就是我们党长期建立的自力更生、艰苦奋斗，掌握自己的能力。
立足中国，纵观历史，我国IT产业的根本出路在于构建自己的生态体系。
摘要 【目的/意义】
CPU承载了计算机中最本质的技术原理。
CPU的架构从根本上定义了一台计算机的核心功能，
CPU原理涵盖了整个计算机大部分的运行过程。
学习计算机组成原理从CPU入手是最直接的途径，也是必由之路。
【方法/过程】
本论文会站在芯片产业发展的角度，
阐述CPU的基本概念、核心原理、生产制造及产业生态。
【结果/结论】
中国IT产业的根本出路是建立自己的生态体系。产业链存在剥削现象，一个产业链最终的价值是消费者给的，而产业链内部的利益分成则主要是由生态主导者定的。
中国IT企业的普遍情况是制造业发达、解决方案落后、利润率低。华为属于中国创新能力最强的一线厂商，干的事情最多最辛苦，但利润都不如苹果公司的零头。归根结底是因为中国企业没有解决方案的话语权，没有建立自己的生态体系。
第一章 CPU概览 第1节 CPU的发展历程 计算机是一种可以执行计算功能的自动化设备。在信息社会中，无数的计算机每天都在执行大量的信息处理和计算工作，本来属于人的工作可由计算机自动完成，大大提高了社会生产力。
计算机科学先驱冯·诺依曼在1945年以论文的形式描述了计算机的结构模型，鉴定了现代计算机的结构基础。冯·诺依曼体系结构是现代计算机共同的模型，现在无论是高性能的大型科学计算机，还是我们身边的台式计算机、手机，都遵从冯·诺依曼体系结构。
事实上，计算机中的运算器、控制器两部分经常被一起设计，二者合称为中央处理器（Central Processing Unit，CPU）。CPU的主要任务就是由控制器指挥计算机中的其他部件一起协同工作，并且由运算器执行数值计算。
CPU是计算机中最复杂的芯片。CPU采用的是超大规模集成电路，现代的芯片制造技术可以在一根头发丝的宽度上排列1000根电路连线。台式计算机中的一个芯片就能包含50亿个晶体管，而人脑中的神经元的数量也就在800亿个左右。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fb794414a680b951a6902a675c208cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b7e8ed8e45da7b4e8e29fd389ee8b91/" rel="bookmark">
			自适应大屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可视化大屏适配/自适应现状 可视化大屏的适配是一个老生常谈的话题了，现在其实不乏一些大佬开源的自适应插件、工具但是我为什么还要重复造轮子呢？因为目前市面上适配工具每一个都无法做到完美的效果，做出来的东西都差不多，最终实现效果都逃不出白边的手掌心，可以解决白边问题的，要么太过于复杂，要么会影响dom结构。
npm包：autofit.js
这是一款可以使你的项目一键自适应的工具 github源码👉go
从npm下载引入快速开始 默认参数为1920*929（即去掉浏览器头的1080）, 直接在大屏启动时调用即可
使用 以上使用的是默认参数，可根据实际情况调整，参数分别为
export default { mounted() { autofit.init({ dh: 1080, dw: 1920, el:"#app", resize: true },false) // 可关闭控制台运行提示输出 }, } 以上使用的是默认参数，可根据实际情况调整，可选参数有
* - el：渲染的dom，默认是 "#app"，必须使用id选择器 * - dw：设计稿的宽度，默认是 1920 * - dh：设计稿的高度，默认是 929 ，如果项目以全屏展示，则可以设置为1080 * - resize：是否监听resize事件，默认是 true * - ignore：忽略缩放的元素（该元素将反向缩放），参数见readme.md * - transition：过渡时间，默认是 0 * - delay：默认是 0 忽略某些元素 autofit.init({ ignore: [ { el: ".gaodeMap", }, ] }) 传入 ignore 以使元素不被缩放
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b7e8ed8e45da7b4e8e29fd389ee8b91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd499aa9d3a88d55a86b93e48fe25d2/" rel="bookmark">
			在分布式系统中使用过滤器对请求进行链路追踪：Span ID和Trace ID的作用和处理流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在分布式系统中使用过滤器对请求进行链路追踪：Span ID和Trace ID的作用和处理流程 目录 场景介绍背景知识——Span ID 和 Trace ID过滤器操作 RequestStatsFilterResponseStatsFilterRequestTraceGatewayFilterFactory 过滤器执行顺序处理流程总结 1. 场景 假设我们在操作一个电商应用的订单过程中，订单的创建可能涉及"用户服务" ，“库存服务”，“订单服务"以及"支付服务"这四个服务。当用户发起一个创建订单的请求，请求首先到达"用户服务”，“用户服务"通过RequestStatsFilter在请求头部添加Span ID和Trace ID，然后发送给下一个"库存服务”，如此下去，每个服务都会以此类推，直至请求结束。在订单创建请求的生命周期内，不同的服务都能通过Span ID和Trace ID来准确追踪请求的具体路径和状态。
2. 介绍 在微服务架构中，一个请求可能需要经过多个服务。为了更好地理解和跟踪一个请求在各个服务之间的运行情况，我们通常需要使用链路追踪。这篇博客将会解释如何利用过滤器来实现这一功能，重点关注Trace ID和Span ID的作用及其处理流程。
3. 背景知识——Span ID 和 Trace ID 在链路追踪中，有两个关键的概念：Span ID和Trace ID。
Span ID：在分布式系统中，一个请求在一个特定的服务中的处理阶段被标记为一个"span"，而Span ID是这个"span"的唯一标识符。专注于标记和追踪一个单独的请求在一个微服务中的处理情况，用来追踪一个请求在单个微服务内的子操作。
Trace ID：对于整个请求链路，无论它穿越了多少个服务，都会有一个唯一的Trace ID来标识，被保存在TRACE_ID_HEADER中。它保存的是Trace ID，这是一次请求在所有微服务中的唯一标识。无论这次请求经过多少个微服务处理，其Trace ID都是不变的。
4. 过滤器操作 我们利用三个过滤器来进行链路追踪：RequestStatsFilter，ResponseStatsFilter，RequestTraceGatewayFilterFactory。
RequestStatsFilter：在请求处理链的开始处添加链路追踪信息，即生成新的追踪ID和Span ID，加入请求头信息。ResponseStatsFilter：在请求处理链的结束处，清理并记录链路追踪信息。将从请求头提取出的TraceId添加到响应头后，清除掉对应的链路信息。RequestTraceGatewayFilterFactory：捕踪并记录请求相关信息以及链路追踪信息，在对应处理请求的服务处，从请求头提取出Span ID和其他请求相关的信息并进行记录。 5. 过滤器执行顺序 当本服务接收到一个请求时，首先经过RequestStatsFilter，生成Span ID和Trace ID，并将这两个信息添加到请求头。然后，RequestTraceGatewayFilterFactory从请求头提取出这两个信息，并记录相关日志。上述过程结束后，请求才会进入具体的业务处理模块。在请求处理结束后，即将响应返回给调用方之前，ResponseStatsFilter将被触发，从请求头提取TraceId添加到响应头，然后清除这些信息。
6. 处理流程 处理开始，RequestStatsFilter会为请求生成新的追踪ID和Span ID，添加到请求头中。然后，在RequestTraceGatewayFilterFactory中，会从请求头部中提取出这些信息，并且将这些信息通过请求的Metadata继续传递给下一个过滤器。最后，当响应要发回给客户端时，ResponseStatsFilter将Span ID信息写入响应头部，并将其从服务器中删除。
7. 总结 利用过滤器进行链路追踪是跟踪微服务中请求处理状态的一种高效方式。正确使用与理解Span ID和Trace ID对于分析和优化微服务性能至关重要。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/037f0375df986aff0f31257ff8d8430b/" rel="bookmark">
			【ChatGPT】ChatGPT是如何训练得到的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ChatGPT是一种基于语言模型的聊天机器人，它使用了GPT（Generative Pre-trained Transformer）的深度学习架构来生成与用户的对话。GPT是一种使用Transformer编码器和解码器的预训练模型，它已被广泛用于生成自然语言文本的各种应用程序，例如文本生成，机器翻译和语言理解。
在本文中，我们将探讨如何使用Python和PyTorch来训练ChatGPT，以及如何使用已经训练的模型来生成对话。
1.准备数据 在训练ChatGPT之前，我们需要准备一个大型的对话数据集。这个数据集应该包含足够的对话，覆盖各种主题和领域，以及各种不同的对话风格。这个数据集可以是从多个来源收集的，例如电影脚本，电视节目，社交媒体上的聊天记录等。
在本文中，我们将使用Cornell Movie Dialogs Corpus，一个包含电影对话的大型数据集。这个数据集包含超过22,000个对话，涵盖了多个主题和风格。
我们可以使用以下代码下载和解压缩Cornell Movie Dialogs Corpus，这个数据集也可以从[这里](https://www.cs.cornell.edu/~cristian/Cornell_Movie-Dialogs_Corpus.html)手动下载。
import os import urllib.request import zipfile DATA_URL = 'http://www.cs.cornell.edu/~cristian/data/cornell_movie_dialogs_corpus.zip' DATA_DIR = './cornell_movie_dialogs_corpus' DATA_FILE = os.path.join(DATA_DIR, 'cornell_movie_dialogs_corpus.zip') if not os.path.exists(DATA_DIR): os.makedirs(DATA_DIR) if not os.path.exists(DATA_FILE): print('Downloading data...') urllib.request.urlretrieve(DATA_URL, DATA_FILE) print('Extracting data...') with zipfile.ZipFile(DATA_FILE, 'r') as zip_ref: zip_ref.extractall(DATA_DIR) 2.数据预处理 在准备好数据集之后，我们需要对数据进行预处理，以便将其转换为模型可以处理的格式。在本教程中，我们使用了一个简单的预处理步骤，该步骤包括下列几步：
将数据拆分成句子pairs（上下文，回答）去除标点符号和特殊字符将所有的单词转换成小写将单词映射到一个整数ID将句子填充到相同的长度 下面是用于预处理数据的代码： import re import random import numpy as np import torch def load_conversations(): id2line = {} with open(os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/037f0375df986aff0f31257ff8d8430b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1137b1cde1ce5d9090fca913d3cf6bb/" rel="bookmark">
			解决ComposerStaticInit类重复加载问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tp5中composer安装phpoffice后报错
Cannot declare class Composer\Autoload\ComposerStaticInit6c9266e89aa536667bf36f59ad8e6e6b, because the name is already in use
错误原因:
使用ThinkPHP5框架的项目，在引用某些包的时候，可能会通过其它包（目前已知phpoffice/phpword）引用到 laminas/laminas-zendframework-bridge 这个包，由于thinkphp没有加载 vender/autoload ，而是通过直接解析autoload_static中的类做加载的，而这个包会重新引用 autoload做自动加载，结果就产生了ComposerStaticInit 这个类重复加载的问题。
目前的解决方法是在 laminas-zendframework-bridge这个包中autoload.php 这个文件中的一行代码直接注释掉。暂未发现有其它影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/972722567f91c168bc9abaa72dd16eed/" rel="bookmark">
			snakeyaml升级2.0版本遇见的坑，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天公司做安全漏洞扫描，发现snakeyaml1.x版本有高危漏洞，需要升级到2.0，但是snakeyaml从1.x版本升级到2.0之后报错，项目无法启动
2023-07-26 16:56:27,036 main ERROR appenders contains an invalid element or attribute “appender”
2023-07-26 16:56:27,064 main ERROR Unable to locate appender “Filelog” for logger config “root”
2023-07-26 16:56:27,064 main ERROR Unable to locate appender “RollingFileWarn” for logger config “root”
2023-07-26 16:56:27,065 main ERROR Unable to locate appender “RollingFileError” for logger config “root”
requestId: 2023-07-26 16:56:27.746 ERROR [main] org.springframework.boot.SpringApplication - Application run failed
java.lang.NoSuchMethodError: org.yaml.snakeyaml.representer.Representer: method ()V not found
at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/972722567f91c168bc9abaa72dd16eed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a29bd0719d687c6d57ecad66094a5ab/" rel="bookmark">
			51单片机:数码管和矩阵按键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一:动态数码管模块
1:介绍
2:共阴极和共阳极
A:共阴极
B:共阳极
C:转化表
3:74HC138译码器
4:74HC138译码器控制动态数码管(位选)
5:数码管显示完整代码
6:74HC573锁存器
A:基本点
B:原理图介绍
c:74HC573控制数码管代码
二:矩阵按键模块
1:介绍
2:原理图
3:矩阵按键代码
一:动态数码管模块 1:介绍 LED数码管：数码管是一种简单、廉价的显示器，是由多个发光二极管封装在一起组成“8”字型的器件;
我们的51单片机的1个数码管就相当于由8个发光二极管封装在一起, 所以我们只需要控制8个发光二极管封就可以实现数码管的显示,这款单片机是共阴极连接
数码管扫描（输出扫描） 原理：显示第1位→显示第2位→显示第3位→……，然后快速循环这个过程，最终实现所有数码管同时显示的效果,节省I/O口
2:共阴极和共阳极 我们这款单片机是共阴极所以我们主要介绍共阳极连接
A:共阴极 1.LED共阴极是指LED灯中的二极管的阴极有一个共同的接点，并且该接点连接在GND端，即处于低电平状态。 我们只需要给它一个高电频(1)就可以点亮他
从高位到低位读取
eg:让第一个数码管显示0
数码管段码表对应的0,1,2,3,4,5,6,7,8,9
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F}; B:共阳极 LED共阳极是指LED灯中的二极管的阳极有一个共同的接点，并且该接点连接在VCC端，即处于高电平状态。 我们只需要给它一个低电频(0)就可以点亮他
数码管段码表对应的0,1,2,3,4,5,6,7,8,9
unsigned char LED7Code[] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90}; C:转化表 3:74HC138译码器 概述 D74HC138D 是一种三通道输入、八通道输出译码器,主要应用于消费类电子产品 3个io口控制8位,因为单片机上面的资源有限
通过A0~A2数据的输入来控制Y0~Y7数据的输出;实现 3个io口控制8位,(位选)
4:74HC138译码器控制动态数码管(位选) eg:点亮LED8
EDL1对应的是Y7的输出端口,所以只需要控制A,B,C输出Y7即可
从高位到低位读和写; (只需要将二进制转化位10进制的7即可)
P2_4=1;P2_3=1;P2_2=1;//二进制111转化十机制为:7,输出Y7;当用户选择1时点亮LED8 5:数码管显示完整代码 #include &lt;REGX52.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a29bd0719d687c6d57ecad66094a5ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31c83187ada97fe26be7e255ff76dd2c/" rel="bookmark">
			python解密微信聊天记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python解密微信聊天记录（适用于大部分安卓系统） 视频教程地址第一步 备份微信聊天记录第二步 将备份同步至电脑第三步 解压备份文件第四步 获取当前手机的IME号第五步 获取数据库存储位置以及密码第六步 使用sqlcipher.exe打开数据库下载链接参考链接 视频教程地址 https://www.bilibili.com/video/BV1uu4y1m78m/?vd_source=4d76e1f0894dd654b34fd69919cef992 第一步 备份微信聊天记录 以小米手机（MIUI14）为例，在设置中找到我的设备， 备份与恢复，选择备份微信 第二步 将备份同步至电脑 可以使用数据线或者其他方式将微信聊天的备份文件拷贝至电脑上 第三步 解压备份文件 将备份的.bak文件后缀改为 .zip，并且使用7-zip解压（WinRAR解压的结果不全） 第四步 获取当前手机的IME号 不同品牌手机获取IME号方式不同，例如小米手机可以在设置中搜索IME来获取， 每个手机默认有两个IME号码，获取到后记录下来 第五步 获取数据库存储位置以及密码 仅可获取备份微信时登录账户的数据库密码，其他账户无法获取 运行代码后会列举出所有可能的密码，请在下一步中解密过程中使用 import re import os import hashlib # 获取当前路径下的所有文件以及文件夹名称 def GetFileName(path): dirs = os.listdir(path) return dirs # 计算微信数据库的密码 def calculate_md5(string): md5_hash = hashlib.md5() md5_hash.update(string.encode('utf-8')) return md5_hash.hexdigest() # 获取文件中uin,解密数据库密码的关键 def GetUin(path): uin="" with open(path, 'r', encoding='UTF-8') as file_obj: lines = file_obj.readlines() for line in lines: if "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31c83187ada97fe26be7e255ff76dd2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a89a426fa0edb7425eaa6694922a59/" rel="bookmark">
			Visual Stdio Code 输出中文/中文注释显示乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		乱码本质上是保存格式与解码方式不符合，我将keil的工程（GB2312）导入VScode（UTF-8）产生了中文注释乱码的现象，有2种解决方式。
方法1：
方法2：
文件 → 首选项 → 设置 → 搜索 files.autoGuessEncoding →设置为GB2312
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/256712c3223a7c8b1c4efed79011185c/" rel="bookmark">
			vue 实现微信分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入微信JS-SDK：在Vue应用的index.html文件中，可以使用script标签引入微信官方提供的JS-SDK，例如：
在Vue组件中配置微信分享参数：在需要进行分享的Vue组件中，可以使用Vue的生命周期钩子函数（如created或mounted）来配置微信分享的参数。具体配置参数的代码如下所示：
配置后端接口：上述代码中的YOUR_BACKEND_API_URL需要由你自己的后端接口来提供微信分享的参数。后端接口需要对请求进行验证，并返回包含微信分享参数的JSON数据。
微信JS-SDK的配置参数需要通过调用微信官方的后端接口来获取。在这个后端接口中，你需要使用你的微信公众号的AppID和AppSecret来进行签名验证，并生成一个包含参数的JSON返回给前端。
您可以参考微信官方文档中关于JS-SDK的介绍和使用说明，以了解更多关于微信分享的信息和配置方法。
请确保你在后端和前端的代码中使用了正确的AppID、AppSecret以及相关的URL，这样才能成功地实现微信分享功能。还要确保你的微信公众号已经进行了相应的设置和配置，例如关联了域名等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eab587243718aa9ea6907d3ae77a214/" rel="bookmark">
			uniapp制作保存海报详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备素材和设计：首先，您需要准备用于制作海报的素材，包括背景图片、文字、图标、Logo等。确定海报的尺寸和布局，考虑您想要达到的视觉效果，并确保素材的质量和合适的分辨率。
使用uniapp组件和样式：在uniapp中，您可以使用Vue框架和uniapp提供的组件来创建海报。使用合适的组件，如图片组件、文本组件等，将素材放置在合适的位置。同时，使用CSS样式来调整和美化海报的外观，包括颜色、字体、边框等。
动态生成海报：如果您需要在海报上显示动态数据，如用户信息、活动信息等，您可以使用uniapp的数据绑定机制。将动态数据绑定到合适的组件上，使得海报能够根据不同的数据内容进行动态生成。
添加保存功能：为了让用户能够保存海报，您可以使用uniapp提供的原生能力或第三方插件。例如，您可以使用uniapp提供的保存图片的原生API，或使用第三方插件来实现保存功能。
测试和优化：在完成海报制作和保存功能后，进行全面测试，确保海报在不同设备和屏幕尺寸下正常显示，并且保存功能能够正常工作。如果发现问题或需要改进的地方，及时进行调试和优化。
值得注意的是，uniapp是一个跨平台的开发框架，可帮助您同时开发iOS和Android应用。在制作和保存海报的过程中，您需要针对不同平台进行适配和测试，确保海报在不同平台下都能够正常显示和保存。在开发过程中，您可以查阅uniapp的官方文档和相关示例代码，以获取更详细的指导和帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c071697c74eb83230743e34333c7fa4/" rel="bookmark">
			Ubuntu系统安装opencv详细操作及具体应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu系统安装opencv详细操作及具体应用 前言一、opencv是个什么东西二、opencv的安装1、资源准备及前期准备2、安装编译3、配置更改4、验证版本 三、opencv应用1、打开图片进行特效显示2、使用opencv库打开摄像头3、修改上一个程序打开视频文件来播放 四、容易碰到的问题五、参考文献 前言 由于ubuntu系统近日被不小心整崩溃了，所以早期安装的一些东西又要重新安装，闲来无事，为提高重装人的效率，将一些东西写成博客。
一、opencv是个什么东西 开源计算机视觉(OpenCV)是一个主要针对实时计算机视觉的编程函数库。
OpenCV的应用领域包括:2D和3D功能工具包、运动估计、面部识别系统、手势识别、人机交互、移动机器人、动作理解、物体识别、分割和识别、实体影像立体视觉:来自两个摄像机的深度感知、运动跟踪、增强现实等。
二、opencv的安装 1、资源准备及前期准备 由于官网下载太慢，因此找来一个国内的靠谱网站使用。
国内快速下载地址：https://www.raoyunsoft.com/wordpress/index.php/2020/03/09/opencvdownload/
这里选择3.4.11版本
默认下载到下载里
右键提取到此处即可，或者终端输入指令：
unzip opencv-3.4.11.zip 2、安装编译 进入解压后的文件夹：opencv-3.4.11
cd opencv-3.4.11 进入 root 并更新
sudo su sudo apt-get update 接着下面这条命令安装 cmake
sudo apt-get install cmake 复制下面这条命令，安装依赖库
sudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff5.dev libswscale-dev 创建 build 文件夹并进入，使用 cmake 编译参数
cmake .. 用make创建编译
sudo make 想更快编译完，可以使用命令：sudo make -j4 的4线程进行编译。
安装
sudo make install 基本不会报错
3、配置更改 修改 opencv.conf 文件，在此空文件中添加 opencv 库的安装路径：/usr/local/lib
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c071697c74eb83230743e34333c7fa4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/599242edf3be0953f23a832359a8e7a5/" rel="bookmark">
			获取el-upload上传视频的视频时长
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 // 获取视频时长 getVideoTime(file) { let that = this var url = URL.createObjectURL(file.raw); var audioElement = new Audio(url); var duration; audioElement.addEventListener("loadedmetadata", function () { duration = parseInt(audioElement.duration); //时长为秒，取整 that.editDialog.data.duration = duration }); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebcb619bee4b81d6cdc8a4dfd11564cb/" rel="bookmark">
			「第二章」python-docx 中的 Paragraph 教程（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言（对paragraph进行说明） 上一章我们讲了一下 python-docx 是啥，哪儿来的，还有怎么引用它。总体来说，就是扯了各种犊子，还有一点点新手小白可能不太知道的一些东西。这一章，我们开始说一些干货，当然是小白也能理解的、大神选手看一眼就懂的干货。本章，我们将围绕着 python-docx 中的 Paragraph 展开非常、及其、特别简单易懂且详细的一大波讲解。看完本章后，无论小白还是大白还是老白，一定都能把这一部分的内容玩儿的很明白。
本章所讲解的内容主要为 python-docx 中的 Paragraph 的各种操作手法，那我一直默默唧唧说的这个 Paragraph 到底是个啥子东西呢？我们先来了解一下在 python-docx 眼中，docx 的长相是什么样子的，来一张图辅助理解一下。
如上图所示，在 docx 中，每一个段落，就是 python-docx 眼中的一个 paragraph，毕竟这个单词本身也是段落的意思。每一个 Paragraph 又由若干个 run 组成，一般情况下，在同一个 Paragraph 中，如果包含不同字体的个别词或句子，就会被定义为一个 run。在python-docx眼中，下图是一个paragraph，但由于字体格式的不同，这个paragraph又被分为了三个run。
注：虽然不同的字体会将一个段落分为若干的run，但是我们在实际对docx文档的操作过程中会发现，即使字体完全相同，一个paragraph可能也会被分成毫无规则的若干个run。
Paragraph 的实际操作（一） 为了少说废话，多多带大家认识、熟悉和掌握python-docx中的各种功能函数，在接下来的篇幅中，我们会从实例处理出发，解释python-docx中的每一个功能函数。
目标一、使用python-docx读取（遍历）所有 Paragraph。 A、过程描述：
① 随便创建一个docx文档，在其中写入几段内容，在本次的样例中，我所使用的文档为：朱自清《背影》。
② 打开Spyder，创建python工程，并引入python-docx库。
③ 利用python-docx提供的函数对文档进行处理。
注：
（1）关于我为什么使用Spyder，这里面为什么不是pyCharm、VSCode等其它编程环境，在第一章中已经说明了，其实不管白猫还是黑猫，只要能抓住耗子，就是好猫，大家各自【投己所好】。
（2）如何安装python-docx依赖库、如何在工程中引入python-docx库，在第一章中已经进行了详细的讲解，这里就不再赘述了。
B、代码实现：
第一步、使用第一章中讲解引入python-docx的方法，在我们的工程中引入python-docx依赖库。
# 在本例中，我使用 import 直接将 docx 作为相对路径引入本工程。 # 当然你也可以使用 from docx import document，或 from docx import * 进行引用。 import docx 第二步、使用python-docx依赖库提供的命令打开我们想要操作的文档。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebcb619bee4b81d6cdc8a4dfd11564cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d281c58069101881bd8d4c3c9d637f/" rel="bookmark">
			「第一章」python-docx 基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言（不感兴趣不用看~） 源于一次我们单位领导的神奇需求，我认识了一个利用Python语言处理Word的神器，即为本专栏所介绍的：python-docx。
我所在单位是一家与网络安全相关的单位，平时总会为第三方公司出具大批量的报告，客户总会冒出来很多奇奇怪怪、亟待解决、消耗很多人力、又非常简单的需求，比如他会突然给我们一个模板，让我们按照给定的模板，出1000份报告，这个模板中70%，甚至80%以上的内容，都是一样的，我们要做的就是按照模板，修改其中那20%-30%的差异部分，检查无误后（页码、错别字、叠字 and so on······），然后生成为PDF，再交给他们。
起初一旦有了这种任务，我们十几个人简直是痛不欲生，苦不堪言，悲痛欲绝，死去活来，总之，在当时，你可以把所有能表达让人绝望和抓狂的词语全部加在我们的身上，光是任务多而简单重复也就罢了，关键全都是无需任何思考的复制粘贴，三到五天，每天8小时，做着简单而重复的工作，真的会让人抓狂，关键还会占用我们其他很重要的工作的时间，那些被占了时间的重要工作，就必须得通过回家后线上办公，周末的时间线上办公，法定假日的时间线上办公的方式去搞定了。后来······
emmm，后来，领导应该是也做得烦了，因为，他也需要和我们做一样的工作，然后领导就问啊：
“内个，谁谁谁啊，这个东西，能不能想办法用自动化解决一下啊”。
我硬着头皮答应了，因为我也想啊，如果能自动化的几秒钟或几分钟，哪怕是自动5-10分钟，那也比我们十几个人好多天把时间都浪费了强百倍啊。接下这个任务后，我就用度娘 股沟了一下，发现了这个从此以后爱不释手的小东西------由Steve Canny编写的python-docx，当然在这里我不是向大家推荐，也不是说python-docx就是目前为止最为好用的docx处理工具，只是把我所认知的一些事情分享给大家，如果有什么说的不对的地方，欢迎大家批评指正哈。
python-docx到底是个啥？（墨迹给新人） python-docx，读到名字就知道了，是一个和python有关系的东西，那它到底是个什么东西嘞？python-docx，由Steve Canny基于openXML开发，还有众多的贡献者，就不一一列名了，和我们的文章也没有什么关系，如果在读的你感兴趣，或者也想成为贡献者，可以前往：
文档站：python-docx — python-docx 0.8.11 documentationhttps://python-docx.readthedocs.io/en/latest/作者的GithubGitHub - python-openxml/python-docx: Create and modify Word documents with PythonCreate and modify Word documents with Python. Contribute to python-openxml/python-docx development by creating an account on GitHub.https://github.com/python-openxml/python-docx 看一下相关的东西，完蛋了，说跑偏了，我们转回来哈。Python-docx是利用python开发的一款python库，作者在里面已经写好了众多的docx文档处理功能，我们只需要熟悉python的基本语法，然后学习一下python-docx库的每一个函数（功能）的用法，就可以轻松自如的应对各种Docx文件了，比如以下功能（当然适用范围为：人懒、简单、内容多）：
根据某个需求创建指定的docx文档，并在里面生成自己想要的内容，内容可以来自于：各种搜索引擎、引用其他文档、随机生成等等。根据某个需求修改别人发来的docx文档 我说提到的需求，只是我目前为止遇到的需求，工欲善其事必先利其器，当我们掌握了一项神奇的技能，那我们以后利用这个技能可以做的事，肯定是越来越多，比如学会了python-docx，你可以应对自己工作中那些简单而多的任务，你可以去有相关需求的人接单赚钱，你可以使用python-docx结合python爬虫技术，批量生成某些人想要的某些文档等等，在更完了本专栏的文章后，我会写出100个python-docx使用样例，这样无论大家遇到什么样花里胡哨的问题，就都能轻松解决了。
如何安装 python-docx 呢？ python不知道大家都是用什么IDE？常见的有VScode、pycharm、Spyder等，我使用的是Spyder，同事都给我推荐pycharm，但是可能是先入为主的原因，我在尝试了pycharm后，还是选择了Spyder，这个IDE的问题，我感觉大家选择一款自己喜欢的就好。
如果python还不会安装的话，去百度一篇如何安装python就好了，我推荐使用Anaconda（点链接去下载：Anaconda | The World’s Most Popular Data Science Platform），Anaconda这个东西，可以一键安装python的集成开发环境，比较方便一些。
在安装好了python之后，是不能直接使用python-docx的，python安装之后，所带的库都是标准库，而python-docx属于第三方库，所以我们需要自行安装一下这个库，具体安装方法为通过下面的命令进行安装。
# 使用 pip install 命令，安装 python-docx 库 pip install python-docx 如果一切操作都“畅通无阻”的话，应该会得到如下图所示的提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77d281c58069101881bd8d4c3c9d637f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a158bb2cfa6f7f24de6b84a10d481527/" rel="bookmark">
			python错误提示：AttributeError: ‘DataFrame‘ object has no attribute ‘append‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误提示：
AttributeError: ‘DataFrame’ object has no attribute ‘append’
出现错误的代码：
df_train_log = pd.DataFrame() df_train_log = df_train_log.append(log_train, ignore_index=True) 原因：
append包在pandas被弃用
解决方法：
将代码改为：
df_train_log = pd.concat([df_train_log, pd.DataFrame([log_train])], ignore_index=True) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22bf31a545fe66d25b98b398b8d564ff/" rel="bookmark">
			【微信小程序】导出 Excel 报表并分享，使用xlsx库生成 Excel,使用echars插入图表、使用pdfmake导出为PDF文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 生成EXCEL插入汇总和图表导出为PDF 生成EXCEL 要在微信小程序中导出 Excel 报表并分享，可以使用第三方库 xlsx 来生成 Excel 文件，并使用 wx.saveFile 方法将文件保存到本地，然后使用 wx.shareFile 方法来分享文件。
以下是一个示例代码，演示如何在微信小程序中导出 Excel 报表并分享：
首先，安装依赖库 xlsx，可以使用 npm 进行安装： npm install xlsx 在小程序的页面中引入 xlsx 库，并定义一个导出 Excel 报表的方法： // 引入依赖库 const XLSX = require('xlsx'); // 定义导出 Excel 报表的方法 function exportExcel(data, filename) { const workbook = XLSX.utils.book_new(); const sheet = XLSX.utils.aoa_to_sheet(data); XLSX.utils.book_append_sheet(workbook, sheet, 'Sheet1'); const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' }); const filePath = `${wx.env.USER_DATA_PATH}/${filename}.xlsx`; wx.saveFile({ tempFilePath: filePath, filePath: filePath, success: function(res) { const savedFilePath = res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22bf31a545fe66d25b98b398b8d564ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd00c2afb190b0539ddb3657ede355b/" rel="bookmark">
			手把手一起实现Visual Studio 2022本地工程提交(和克隆)Gitee
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、VS2022本地工程提交Gitee 登录Gitee，创建空仓库，如图：
新建仓库：
打开Visual Studio 2022创建的工程，点击创建Git存储库：
复制Gitee仓库URL：
将URL填入，点击创建并推送：
输入Gitee用户名和密码：
刷新Gitee页面，已提交代码：
2、修改代码再次提交 如图，GlobalVariable.cs代码中日期为private string globalUpdateTime = “2023.7.29”：
现在本地工程做出修改，如图：
点击图中“+”，提交暂存：
点击保存，如图：
输入“提交消息”，选择提交临时数据并推送：
推送完成，如图所示：
刷新Gitee，可以看到已经更新代码：
VS打开Git存储库，如图：
也可以看到操作记录：
3、本地克隆Gitee远程仓库 点击克隆存储库，如图：
输入存储库URL，指定路径，然后点击克隆，如图：
如图，克隆成功：
然后新建分支，如图：
输入分支名称，创建：
可以看到分支已经创建成功：
Git存储库也可以看到分支信息：
同样修改一下时间信息，然后提交至远程仓库：
输入“提交消息”，选择全部提交并推送：
点击保存：
如图，已经提交成功：
刷新Gitee，可以看到新提交的分支：
确认是刚刚修改过的工程：
Git存储库也可以看到操作信息：
希望本文对大家有帮助，上文若有不妥之处，欢迎指正
分享决定高度，学习拉开差距
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc3c982af31fb3eb332a1a1a1a273289/" rel="bookmark">
			基于opencv与机器学习的摄像头实时识别数字！附带完整的代码、数据集和训练模型！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 使用摄像头实时识别数字算是目标检测任务，总体上分为两步，第一步是检测到数字卡片的位置，第二步是对检测到的数字卡片进行分类以确定其是哪个数字。在第一步中主要涉及opencv的相关功能，第二步则使用机器学习的方式进行分类。
一、使用opencv捕捉（检测）数字卡片 重点操作是使用轮廓查找函数，获取数字卡片的外轮廓。
在获取轮廓前的图像预处理步骤需要根据自己的实际应用场景进行调整。
import cv2 import imutils # 开启外接摄像头 cap = cv2.VideoCapture(1) rectKernel = cv2.getStructuringElement(cv2.MORPH_RECT, (11, 11)) while True: flag, frame = cap.read() if frame is None: continue if flag is True: frame_copy = frame.copy() frame_copy_2 = frame.copy() frame_copy_3 = frame.copy() # 自动阈值处理 frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) frame_ths = cv2.threshold(frame_gray, 0, 255, cv2.THRESH_BINARY_INV|cv2.THRESH_OTSU)[1] # 闭操作 img_closed = cv2.morphologyEx(frame_ths, cv2.MORPH_CLOSE, rectKernel) # canny边缘检测；这里使用的imutils包，也可以使用opencv自带的canny temp = imutils.auto_canny(img_closed) # 轮廓查找 contours, hierarchy = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc3c982af31fb3eb332a1a1a1a273289/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c7dd1b105d2fef1b58ad20bc0e131a/" rel="bookmark">
			内连接（sql）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 等值连接
等值连接的语法格式为：（sql99语法） SELECT columns FROM table1 JOIN table2 ONtable1.column_name=table2.column_name;
其中，JOIN 可以写为 INNER JOIN。下面是一个示例：
SELECT orders.order_id, customers.customer_name, orders.order_date FROM orders JOIN customers ON orders.customer_id = customers.customer_id; 上述语句将 orders 表和 customers 表基于 customer_id 列进行等值连接，返回订单号、客户名称和订单日期。
2. 非等值连接
非等值连接的语法格式为：
SELECT columns FROM table1 JOIN table2 ON table1.column_name &gt; table2.column_name;
下面是一个示例：
SELECT products.product_name, suppliers.supplier_name FROM products INNER JOIN suppliers ON products.supplier_id &gt; suppliers.supplierid; 上述语句将 products 表和 suppliers 表基于 supplier_id 列进行非等值连接，返回产品名称和供应商名称。
3. 自连接（一张表看成两张表）
自连接的语法格式为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53c7dd1b105d2fef1b58ad20bc0e131a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b221437bb990a39319daac478d65b9fd/" rel="bookmark">
			51单片机学习--按键控制流水灯模式&amp;定时器时钟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TMOD负责确定T0和T1的工作模式，TCON控制T0和T1的启动或停止计数，同时包含定时器状态
TF1：定时器1溢出标志
TF0：定时器0溢出标志
0~65535 每隔1微秒计数器+1，总时间65535微秒，赋上初值64535，则只有1000微秒即1毫秒
第一步：编写Timer_Init() 首先配置TMOD
所以初始化TMOD = 0x01; //0000 0001
整体操作：TMOD = TMOD &amp; 0xF0; //低四位清零，高四位不变
TMOD = TMOD | 0x01; //最低位置1，其他位不变
接下来配置TCON
TF0 = 0;
TR0 = 1;
还要配置TH0和TL0
用64535，存在这两个盒子里，盒子最大只能存八字节也就是256，所以
TH0 = 64535 / 256;
TL0 = 64535 % 256;
最后配置中断系统
要打开的开关置1
ET0 = 1;
EA = 1;
PT0 = 0;
来看看代码
#include &lt;REGX52.H&gt; void Timer0_Init(void)	//1毫秒@11.0592MHz { TMOD &amp;= 0xF0;	//设置定时器模式 TMOD |= 0x01;	//设置定时器模式 TL0 = 0x66;	//设置定时初值 TH0 = 0xFC;	//设置定时初值 TF0 = 0;	//清除TF0标志 TR0 = 1;	//定时器0开始计时 //中断系统 ET0 = 1; EA = 1; PT0 = 0; } void main() { Timer0_Init(); while(1) { } } unsigned int T0Count; void Timer0_Routine() interrupt 1 { TL0 = 0x66;	//设置定时初值 TH0 = 0xFC;	//设置定时初值 T0Count ++; if(T0Count &gt;= 1000) { T0Count = 0; P2_0 = ~P2_0; } } 接下来把定时器模块化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b221437bb990a39319daac478d65b9fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb83ee7267680e4547ff1b1c7661ea04/" rel="bookmark">
			pgrep(1) command
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.命令简介2.命令格式3.选项说明4.常用示例参考文献 大咖好呀，我是恋喵大鲤鱼。 !!! 我的第二本开源书籍《后台开发命令365》上线啦，欢迎大家协同共建。
1.命令简介 pgrep（process grep）根据进程名称或其他属性查找进程。
pgrep 命令以名称为依据从运行进程队列中查找进程，并显示查找到的进程 ID。每一个进程 ID 以一个十进制数表示，通过一个分隔串和下一个 ID 分开，默认的分隔串是一个新行。对于每个属性选项，用户可以在命令行上指定一个以逗号分隔的可能值的集合。
2.命令格式 pgrep [&lt;options&gt;] &lt;pattern&gt; 3.选项说明 -d, --delimiter &lt;delimiter&gt; 设置用于分隔输出中每个进程 ID 的字符串（默认为换行符）。 -f, --full 模式通常仅与进程名称匹配。设置 -f 时，将使用完整的命令行。 -g, --pgroup &lt;pgrp&gt;,... 只匹配列出的进程组 ID 中的进程。进程组 0 被转换为 pgrep 或 pkill 自己的进程组。 -G, --group &lt;gid&gt;,... 只匹配实际组 ID 列出的进程。可以使用数值或符号值。 -l, --list-name 列出进程的名字和 ID。 -n, --newest 选择最近执行的进程。 -o, --oldest 选择最早的进程。 -P, --parent &lt;ppid&gt;,... 选择父 PID 匹配的进程。 -s, --session &lt;sid&gt;,... 只匹配进程会话 ID 列出的进程。会话 ID 0 被转换为 pgrep 或 pkill 自己的会话 ID。 -t, --terminal &lt;term&gt;,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb83ee7267680e4547ff1b1c7661ea04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ebe36cbe45be46d47ab175e31cbf02e/" rel="bookmark">
			ESP32（MicroPython） 四足机器人（五）功能补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次更新增加了前后倾斜（每次动作交换前部和后部高度）、蹲起与抬脚动作，均位于用于连续执行动作的function函数中，但实测抬脚动作需要先启动function函数的另一项功能才能正常开启，代码检查无误，应该是MicroPython固件的bug。另外，对于判断功能，增加了elif语句的使用，避免重复使用if语句以提高运行效率。
程序如下
import time
from machine import SoftI2C,Pin
from servo import Servos
import _thread
i2c=SoftI2C(sda=Pin(9),scl=Pin(8),freq=10000)
servos=Servos(i2c,address=0x40)
servos.position(0,90)
servos.position(1,90)
servos.position(2,90)
servos.position(3,90)
servos.position(4,90)
servos.position(5,90)
servos.position(6,90)
servos.position(7,90)
servos.position(8,120)
servos.position(9,120)
servos.position(10,120)
servos.position(11,120)
time.sleep(1)
Height1=0 #前部高度，0为最高
Height2=0 #后部高度，0为最高
mode=0
delay=300
def straight(angle): #直行，给所有转向舵机写入相应角度以调整方向
servos.position(0,angle)
servos.position(1,angle)
servos.position(2,angle)
servos.position(3,angle)
def turn(angle): #倾斜
servos.position(0,angle)
servos.position(1,angle)
servos.position(2,180-angle)
servos.position(3,180-angle)
def tilt(height1,height2): #前后倾斜,局部变量与全局变量通过大小写区分
servos.position(4,90-height1)
servos.position(5,90-height1)
servos.position(6,90-height2)
servos.position(7,90-height2)
servos.position(8,120-height1-height1) #底部舵机使用两倍偏置以确保平衡
servos.position(9,120-height1-height1)
servos.position(10,120-height2-height2)
servos.position(11,120-height2-height2)
def crawl(step,angle): #爬行，第一个参数为步骤数,第二个参数为相比直立状态降低的角度，步长随第二个参数的增大而增大
if step==1:
servos.position(4,90-angle-angle)
servos.position(7,90-angle)
if step==2:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ebe36cbe45be46d47ab175e31cbf02e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f89ba1427fcd3164cbaaaca7557f135/" rel="bookmark">
			支持向量机(support vector machine, SVM)的分类(matlab实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		支持向量机(support vector machine,SVM)是一种新的机器学习方法，其基础是Vapnik 创建的统计学习理论(statistical learning theory,STL)。统计学习理论采用结构风险最小化(structural risk minimization,SRM)准则，在最小化样本点误差的同时，最小化结构风险，提高了模型的泛化能力，且没有数据维数的限制。在进行线性分类时，将分类面取在离两类样本距离较大的地方；进行非线性分类时通过高维空间变换，将非线性分类变成高维空间的线性分类问题。 本章将详细介绍支持向量机的分类原理，并将其应用于基于乳腺组织电阻抗频谱特性的乳腺癌诊断。 1 理论基础 1.1 支持向量机分类原理 1.线性可分SVM 支持向量机最初是研究线性可分问题而提出的，因此，这里先详细介绍线性SVM的基本思想及原理。 值得一提的是，若数据集中的绝大多数样本是线性可分的，仅有少数几个样本(可能是异常点)导致寻找不到最优分类超平面。针对此类情况，通用的做法是引入松弛变量，并对式(28-7)中的优化目标及约束项进行修正，即 2.线性不可分SVM 在实际应用中，绝大多数问题都是非线性的，这时对于线性可分SVM是无能为力的。对于此类线性不可分问题，常用的方法是通过非线性映射φ:R?→H,将原输入空间的样本映射到高维的特征空间H中，再在高维特征空间H中构造最优分类超平面，如图28-2所示。另外，与线性可分SVM相同，考虑到通过非线性映射到高维特征空间后仍有因少量样本造成的线性不可分情况，亦考虑引入松弛变量。 3.多分类SVM 由线性可分SVM和线性不可分SVM的原理可知，支持向量机仅限于处理二分类问题，对于多分类问题，须做进一步的改进。目前，构造多分类SVM的方法主要有两个：直接法和间接法。直接法通过修改待求解的优化问题，直接计算出用于多分类的分类函数，该方法计算量较大、求解过程复杂、花费时间较长，实现起来比较困难。间接法主要是通过组合多个二分类SVM来实现多分类SVM的构建，常见的方法有一对一(one-against-one)和一对多(one-against-all)两种， 1.2 libsvm软件包简介 libsvm工具箱是台湾大学林智仁(C.JLin)等人开发的一套简单的、易于使用的SVM模式识别与回归机软件包，该软件包利用收敛性证明的成果改进算法，取得了很好的结果。libsvm共实现了5种类型的SVM:C-SVC,u-SVC,One Class-SVC,e-SVR和v-SVR等。下面将详细介绍libsvm软件包中主要函数的调用格式及注意事项。 1.SVM训练函数svmtrain 函数svmtrain用于创建一个SVM模型，其调用格式为 model= svmtrain(train_label,train_matrix,'libsvm_options'); 其中，train_label为训练集样本对应的类别标签；train_matrix为训练集样本的输入矩阵；libsvm_options为SVM模型的参数及其取值(具体的参数、意义及其取值请参考libsvm软件包的参数说明文档，此处不再赘述);model为训练好的SVM模型。值得一提的是，与BP神经网络及RBF神经网络不同，train_label及train_matrix为列向量(矩阵),每行对应一个训练样本。 2.SVM预测函数svmpredict 函数svmpredict用于利用已建立的SVM模型进行仿真预测，其调用格式为 [predict _label,accuracy]= svmpredict(test_label,test _matrix,model); 其中，test_label为测试集样本对应的类别标签；test_matrix为测试集样本的输入矩阵；model为利用函数svmtrain训练好的SVM模型；predict_label为预测得到的测试集样本的类别标签；accuracy为测试集的分类正确率。需要说明的是，若测试集样本对应的类别标签test_label未知，为了符合函数svmpredict调用格式的要求，随机填写即可，在这种情况下，accuracy便没有具体的意义了，只需关注预测的类别标签predict_label即可。 2 案例背景 2.1 问题描述 乳腺是女性身体的重要器官，乳腺疾病类别繁多，病因复杂，其中，乳腺癌是乳腺疾病的一 种，逐渐成为危害女性健康的主要恶性肿瘤之一。近年来，乳腺癌等乳腺疾病发病率呈明显上升趋势，被医学界称为“女性健康第一杀手”。 相关研究结果表明，在直流状态下，不同生物组织表现出不同的电阻特性，生物组织电阻抗随着外加电信号频率的不同而表现出较大的差异。常见的电阻抗测量方法有：电阻抗频谱法(impedance spectroscopy)、阻抗扫描成像法(electrical impedance scanning,EIS)、电阻抗断层成像法(electrical impedance tomography,EIT)等。电阻抗频谱法的测量依据是生物组织的电阻抗随着外加电信号频率的不同而呈现出较大的差异。阻抗扫描成像法的原理是癌变组织与正常组织及良性肿瘤组织的电导(阻)率相比，存在着显著性的差异，从而使得均匀分布在组织外的外加电流或电压场产生畸变。电阻抗断层成像法则利用设于体表外周的电极阵列及微弱测量电流，提取相关特征并重新构造出截面的电阻抗特性图像。 尽管目前的电阻抗测量结果还存在一些偏差，但相关研究已经证实癌变组织与正常组织的电阻抗特性存在显著的差异。因此，乳腺组织的电阻抗特征可以应用于乳腺癌的检查与诊断中。由于电阻抗测量法具有无创、廉价、操作简单、医生与病人易于接受等优点，随着测量技术的不断发展，电阻抗测量系统精度的日益提高，基于乳腺组织电阻抗特性的乳腺癌诊断技术势必会在临床检查与诊断中发挥其特有的作用。 1996年，Jossinet研究小组利用电阻抗频谱法测量了来自64位妇女的106个乳腺样本的电阻抗特性，并将其分为6组：乳腺组织、结缔组织、脂肪组织、乳腺病、纤维腺瘤和乳腺癌，其中前3组是正常组织，后3组是病变组织(其中前2组是良性病变)。各组的乳腺样本数如表28-1所列。 2.2 解题思路及步骤 依据问题描述中的要求，利用SVM建立乳腺癌诊断模型并对模型的性能进行评价，大体上可以分为以下几个步骤，如图28-5所示。 1.产生训练集/测试集 与前面几章类似，要求所产生的训练集样本数不宜太少，且应具有代表性。同时，由于libsvm软件包对输入的数据有格式上的要求，需要转换产生的训练集和测试集输入矩阵和类别标签以满足函数svmtrain和函数svmpredict调用格式的要求。 2.创建/训练SVM诊断模型 利用函数svmtrain可以方便地创建/训练一个SVM模型，值得一提的是，在创建之前，如若需要，还应对数据进行归一化。同时，由于不同核函数类型及参数对模型的泛化能力影响较大，因此，需要确定核函数类型及选择较好的参数。一般选用RBF核函数，且利用交叉验证方法选择较好的模型参数。 3.仿真测试 当SVM诊断模型训练好后，输入测试集的类别标签及输入矩阵函数svmpredict,便可以得到对应的预测类别标签及正确率。 4.性能评价 依据函数svmpredict返回的正确率，可以对建立的模型性能进行评价。若模型性能不理想，可以从以下3个方面进行调整：训练集的选择、核函数的选择及模型参数的取值，并在此基础上重新建立模型，直到模型的性能达到要求为止。 3 MATLAB程序实现 利用MATLAB及libsvm软件包中提供的函数，可以方便地在MATLAB环境下实现上述步骤。 %% 清空环境变量 clear all clc %% 导入数据 load BreastTissue_data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f89ba1427fcd3164cbaaaca7557f135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ecf3dfe89840501837e5128f6bb3343/" rel="bookmark">
			YOLOv7网络结构详细讲解及训练自己数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、工程总体介绍
二、网络结构介绍
1.总体结构图
2.CBS
3.ELAN和E-ELAN
4.MP
5. SPPCSP
6.RepConv
7.Detect
三、训练自己数据
前言
YOLOv7是一种优秀的端到端检测算法。YOLOv7由Alexey Bochkovskiy和Chien-Yao Wang等人（YOLOv4团队）于2022年提出。在 5 FPS 到 120 FPS 的范围内，YOLOv7 的速度和准确性都超过了所有已知的物体检测器，在 30 FPS 的所有已知实时物体检测器中，YOLOv7 的准确性最高，达到 56.8% AP。
Paper:[2207.02696] YOLOv7: Trainable bag-of-freebies sets new state-of-the-art for real-time object detectors (arxiv.org)https://arxiv.org/abs/2207.02696
GitHub:WongKinYiu/yolov7: Implementation of paper - YOLOv7: Trainable bag-of-freebies sets new state-of-the-art for real-time object detectors (github.com)https://github.com/WongKinYiu/yolov7
一、工程总体介绍 yolov7工程文件夹和数据集datasets文件夹在同一级，datasets下面分为images（放图片）和labels（放标签），images和labels下面分为test（测试集）、train（训练集）、val（验证集）三个文件夹。
yolov7文件夹中第一个cfg文件夹存放的是模型配置文件（model.yaml）。data文件夹中存放的是数据集配置文件（data.yaml）和超参数配置文件（hyperparameters.yam）。deploy文件夹中为nvidia triton推理服务器部署的demo。figure文件夹中是yolov7的一些demo结果图（3D检测，关键点检测等）。inference中存放的是带推理的数据（图片，文件夹）。models中存放的是yolov7网络结构组成常用的代码。paper中为yolov7论文。runs为训练、测试的结果。tools中为一些一些ipynb文件格式的工具（模型转换、模型对比等）。utils中存放工具类函数（激活函数、画图函数等）。.gitignore为docker的ignore文件。LICENSE.md为许可文件。README.md为使用说明文件。detect.py检测代码。export.py模型导出代码。hubconf.py为pytorch hub文件。requirements.txt依赖环境文件。test.py测试文件。train.py为yolov7-tiny、yolov7训练文件。train_aux.py为yolov7-w6、yolov7-e6训练文件。 二、网络结构介绍 1.总体结构图 yolov7总体结构由Input、Backbone、Head、Detect四部分组成。Input为640*640*3的数据输入。Backbone为骨干网络由CBS、ELAN、MP-1组成。Head由CBS、SPPCSPC、E-ELAN、MP-2、RepConv组成。Detect为三个检测头。除了Detect模块代码在models/yolo.py,其余模块代码均在models/common.py。
2.CBS 代码如下：
class Conv(nn.Module): # Standard convolution def __init__(self, c1, c2, k=1, s=1, p=None, g=1, act=True): # ch_in, ch_out, kernel, stride, padding, groups super(Conv, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ecf3dfe89840501837e5128f6bb3343/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afccf500f7001df0e3a887132a6260b6/" rel="bookmark">
			shardingsphere读写分离配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：
如果是升级之前的单库单表，要将之前的 数据库接池 druid-spring-boot-starter 注释掉，换成 druid，否则无法连接数据库。
原因：
因为数据连接池的starter（比如druid）可能会先加载并且其创建一个默认数据源，这将会使得sharding-jdbc创建数据源时发生冲突。解决办法为，去掉数据连接池的starter即可，sharing-jdbc自己会创建数据连接池。 即：
&lt;!-- Druid 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; 改成：
&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; 另：数据库驱动类型如果不是用druid，也可以用zaxxer，这样引入的maven包是：
&lt;dependency&gt; &lt;groupId&gt;com.zaxxer&lt;/groupId&gt; &lt;artifactId&gt;HikariCP&lt;/artifactId&gt; &lt;version&gt;${hikaricp.version}&lt;/version&gt; &lt;/dependency&gt; 读写分离yaml配置
spring #读写分离配置 shardingsphere: #数据源配置，可配置多个data_source_name datasource: #names: ds1,ds2,ds3 names: master,slave1,slave2 #master ds1数据库连接信息 master: #数据库驱动类型 #type: com.zaxxer.hikari.HikariDataSource type: com.alibaba.druid.pool.DruidDataSource #数据库驱动类名 driver-class-name: com.mysql.cj.jdbc.Driver #数据库url连接 url: jdbc:mysql://47.99.110.140:3306/jpay?useUnicode=true #数据库用户名 username: root #数据库密码 password: root@2022 maxPoolSize: 100 minPoolSize: 5 #slave1 ds2数据库连接信息 slave1: #数据库驱动类型 # type: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afccf500f7001df0e3a887132a6260b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2cc003ee14b1b5e485e6a60cdca5611/" rel="bookmark">
			docker 安装 active Mq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装完Docker的机器上，安装activeMQ。
拉取镜像：
docker pull webcenter/activemq
查看镜像：
docker images
Docker运行ActiveMQ镜像
docker run --name activemq -d -p 8161:8161 -p 61616:61616 --privileged=true --restart=always webcenter/activemq
首先创建挂载目录：
mkdir -p /usr/soft/activemq
mkdir -p /usr/soft/activemq/log
运行activeMQ镜像：
docker run --name='activemq' \
-itd \
-p 8161:8161 \
-p 61616:61616 \
--restart=always \
-e ACTIVEMQ_ADMIN_LOGIN=admin \
-e ACTIVEMQ_ADMIN_PASSWORD=admin123456 \
-v /usr/soft/activemq:/data/activemq \
-v /usr/soft/activemq/log:/var/log/activemq \
webcenter/activemq:latest
61616是 activemq 的容器使用端口
8161是 web 页面管理端口
/usr/soft/activemq 是将activeMQ运行文件挂载到该目录
/usr/soft/activemq/log是将activeMQ运行日志挂载到该目录
-e ACTIVEMQ_ADMIN_LOGIN=admin 指定登录名
-e ACTIVEMQ_ADMIN_PASSWORD=123456 登录密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2cc003ee14b1b5e485e6a60cdca5611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546d0a2b832bab13f2cea81bfce49501/" rel="bookmark">
			linux centos7 安装java17
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除旧版本的java或者说是自带的，免得干扰
查找java
rpm -qa|grep java
java-1.8.0-openjdk-1.8.0.262.b10-1.el7.x86_64
javapackages-tools-3.4.1-11.el7.noarch
tzdata-java-2020a-1.el7.noarch
python-javapackages-3.4.1-11.el7.noarch
java-1.8.0-openjdk-headless-1.8.0.262.b10-1.el7.x86_64
删除java
rpm -e --nodeps 查询到的jdk
下载java17
Java Downloads | Oracle
或者直接用wget 进行下载：
wget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz
安装
创建存放目录
mkdir -p /usr/share/jdk-17.0.8
cd /usr/share/jdk-17.0.8
把文件上传到/usr/share/jdk-17.0.8/目录下进行解压
tar -zxvf jdk-17_linux-x64_bin.tar.gz
配置环境变量
vim /etc/profile
找到export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL，在该文件的末尾下面写上：
#java
export JAVA_HOME=/usr/share/jdk-17.0.8
export CLASSPATH=.:$JAVA_HOME/lib
export PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin
java17是没有jre/bin目录的，但是为了方便切换到8版本，还是保留吧。想切换到java只需要修改环境变量JAVA_HOME为你java8的安装目录即可。
保存并退出
:wq
使环境变量生效
source /etc/profile
java -version
输出
java version "17.0.8" 2023-07-18 LTS
Java(TM) SE Runtime Environment (build 17.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/546d0a2b832bab13f2cea81bfce49501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b3162d397118d2e36c96bdbb71f01e5/" rel="bookmark">
			EL表达式（还算详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EL表达式 什么是EL表达式 EL 表达式是 Expression Language 的缩写，全称为 "Expression Language"。它是一种用于在Java Web应用中访问和操作数据的简化表达式语言。EL 表达式最初是为（JSP）开发的，但后来也被广泛应用于其他基于Java的Web框架。
EL语法格式 EL 表达式的语法格式使用${}包裹，其中${}内部可以是一个表达式或者变量名。EL 表达式主要用于在页面中获取和展示数据，执行算术运算，访问JavaBean属性，以及调用JavaBean方法等。
El表达式默认对JavaBean对象的getter方法进行调用 EL 表达式对 JavaBean 的普通属性底层默认进行调用，这是因为 EL 表达式通过 JavaBean 的 getter 方法获取属性的值。在 JavaBean 中，通常会为属性提供公开的 getter 和 setter 方法，用于获取和设置属性的值。EL 表达式使用这些 getter 方法来获取 JavaBean 属性的值。
EL 表达式的语法为 ${beanName.property}，其中 beanName 是 JavaBean 的名称，property 是 JavaBean 的属性名称。在获取属性值时，EL 表达式会自动查找 beanName 对象中名为 getProperty 的方法（根据属性名进行转换），然后调用这个方法来获取属性的值。
示例：
假设有一个名为 User 的 JavaBean，其中包含属性 name 和对应的 getter 和 setter 方法：
public class User { private String name; // Getter方法 public String getName() { return name; } // Setter方法 public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b3162d397118d2e36c96bdbb71f01e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f2356b87e6e6cd2e60dc030f239d490/" rel="bookmark">
			Android11 突破android/data限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android11 突破android/data限制 记得添加权限 &lt;uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" tools:ignore="ScopedStorage" /&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; 权限部分，现获取文件所有权限，在获取SAF权限
import android.annotation.SuppressLint; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.content.UriPermission; import android.net.Uri; import android.os.Build; import android.os.Environment; import android.provider.DocumentsContract; import android.provider.Settings; import androidx.documentfile.provider.DocumentFile; /** * 2023/7/30 * 该类用户：zhanghui * 安卓11以上的文件操作，处理android/data的下的可以操作 * 记得给上权限 * &lt;uses-permission android:name="android.permission.INTERNET"/&gt; * &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; * &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; */ public class SAFFile { private DocumentFile documentFile; /** * @param file */ public SAFFile(Context context,String file){ documentFile = DocumentFile.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f2356b87e6e6cd2e60dc030f239d490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7353db43361a66dc5a0a2f3cb0abe3e/" rel="bookmark">
			进程间通信(IPC)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 IPC介绍为什么需要进程间通信ipcs用法- 一.无名管道PIPE二.FIFO，也称为命名管道，它是一种文件类型。三.消息队列- 四.共享内存- 五.信号**信号发送函数——入门版**信号注册函数——高级版六.信号量 IPC介绍 进程间通信 (IPC，InterProcess Communication)是指在不同进程之间传播或交换信息。IPC的方式通常有管道(包括无名管道和命名管道)、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC
为什么需要进程间通信 1).数据传输
一个进程需要将它的数据发送给另一个进程。
2).资源共享
多个进程之间共享同样的资源。
3).通知事件
一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件。
4).进程控制
有些进程希望完全控制另一个进程的执行(如Debug进程)，该控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。
参考进程间通信
ipcs用法 ipcs -a 是默认的输出信息 打印出当前系统中所有的进程间通信方式的信息
ipcs -m 打印出使用共享内存进行进程间通信的信息
ipcs -q 打印出使用消息队列进行进程间通信的信息
ipcs -s 打印出使用信号进行进程间通信的信息
ipcs -t 输出信息的详细变化时间
ipcs -u 输出当前系统下ipc各种方式的状态信息(共享内存，消息队列，信号)
- 一.无名管道PIPE 特点： 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。
它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。
它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write
等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。
当一个管道建立时，调用pipe函数 在内核中开辟一块缓冲区用于通信，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。如下图：
要关闭管道只需将这两个文件描述符关闭即可
原型：
#include &lt;unistd.h&gt; int pipe(int fd[2]); // 返回值：若成功返回0，失败返回-1 若要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）；反之，则可以使数据流从子进程流向父进程。
例子：
#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/wait.h&gt; #include &lt;string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7353db43361a66dc5a0a2f3cb0abe3e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/107/">«</a>
	<span class="pagination__item pagination__item--current">108/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/109/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>