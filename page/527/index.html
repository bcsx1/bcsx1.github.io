<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29309b8cc8f6a1779254e885b4029c4f/" rel="bookmark">
			关于微擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用微擎的过程中遇到一些特别头疼的事情
微擎更新对服务器的系统要求特别苛刻，它涉及到很多敏感操作，安全软件会将其判断为入侵行为，所以，安全狗之类的防护软件要关闭，即使将微擎更新地址加入白名单也没有，一样会拦截，最好是将系统防火墙也关了，把进程里能关的安全软件都关了，阿里云windows服务器会默认加载云盾的进程，最好将这个也关闭了。对于linux服务器关闭所有拦截程序，很麻烦。微擎对盗版插件打击很严格，你在微擎里安装盗版插件之后，官方能检测出来， 将此站点设为黑名单，将影响更新，无法购买云商城里的东西，也无法安装云商城里的插件，你就只能使用盗版插件，而且付费版的还会影响其余功能。公司以前使用的是旧版微擎和盗版插件，使用官方最新版的微擎之后，将盗版插件移植过来，然后被官方检测出来，导致很多功能受限。使用盗版之后轻微情况可以删除盗版内容之后联系客服恢复，严重的情况会将当前顶级域名拖黑，导致此域名下的所有下级域名都无法正常使用微擎，然后该域名绑定的微擎账户也会被拖黑，导致无法登陆微擎平台。这种情况要么升级成付费版的微擎让官方解封，要么申请新的微擎账户，绑定新的域名。你在某个域名下购买安装的微擎，就只能在该域名下使用，若是在服务器复制粘贴到别的站点安装，别的站点会被视为使用盗版，从而被列入黑名单。微擎官方团队QQ群那帮人特装逼特没素质，官网连个电话都没有，但凡涉及到盗版的字眼，一言不合就拖黑，封禁你的微擎账号，而且不给你解释的机会，解封就得花钱买他们的付费版。说白了只是腾讯微信的一个第三方，腾讯技术部总监招人的时候跟我QQ聊天都没摆过架子，你个小小第三方公司还摆个臭架子。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb25273367702ecda52a138d4cf8a6a/" rel="bookmark">
			如何一步一步提高图像分类准确率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载链接：https://zhuanlan.zhihu.com/p/29534841
第一步：先进行训练，得到一个初始的结果
结果分析：首先我们观察训练 loss（目标函数值）变化，刚开始 loss 从 200 不断减小到接近 0，但是在 100 轮左右开始出现震荡，并且随着训练幅度越来越大，说明模型不稳定。然后观察训练集和验证集的准确率，发现训练集准确率接近于 1，验证集准确率稳定在 70% 左右，说明模型的泛化能力不强并且出现了过拟合情况。最后评估测试集，发现准确率为 69.36%，也没有达到很满意的程度，说明我们对模型需要进行很大的改进，接下来进行漫长的调参之旅吧！
第二步：进行数据增强
使用数据增强技术（data augmentation），主要是在训练数据上增加微小的扰动或者变化，一方面可以增加训练数据，从而提升模型的泛化能力，另一方面可以增加噪声数据，从而增强模型的鲁棒性。主要的数据增强方法有：翻转变换 flip、随机修剪（random crop）、色彩抖动（color jittering）、平移变换（shift）、尺度变换（scale）、对比度变换（contrast）、噪声扰动（noise）、旋转变换 / 反射变换 （rotation/reflection）等，可以参考 Keras 的官方文档 [2] 。获取一个 batch 的训练数据，进行数据增强步骤之后再送入网络进行训练。
---------------------------------------------------------------------------------------------------------
数据增强具体做的方面：一共从如下三个方面：
我主要做的数据增强操作有如下方面：
图像切割：生成比图像尺寸小一些的矩形框，对图像进行随机的切割，最终以矩形框内的图像作为训练数据。
图像翻转：对图像进行左右翻转。
图像白化：对图像进行白化操作，即将图像本身归一化成 Gaussian(0,1) 分布。
结果分析：我们观察训练曲线和验证曲线，很明显地发现图像白化的效果好，其次是图像切割，再次是图像翻转，而如果同时使用这三种数据增强技术，不仅能使训练过程的 loss 更稳定，而且能使验证集的准确率提升至 82% 左右，提升效果十分明显。而对于测试集，准确率也提升至 80.42%。说明图像增强确实通过增加训练集数据量达到了提升模型泛化能力以及鲁棒性的效果，从准确率上看也带来了将近 10% 左右的提升，因此，数据增强确实有很大的作用。但是对于 80% 左右的识别准确率我们还是不够满意，接下来继续调参。
--------------------------------------------------------------------------------------------------------- 第三步：从模型入手，使用一些改进方法
接下来的步骤是从模型角度进行一些改进，这方面的改进是诞生论文的重要区域，由于某一个特定问题对某一个模型的改进千变万化，没有办法全部去尝试，因此一般会实验一些 general 的方法，比如批正则化（batch normalization）、权重衰减（weight decay）。我这里实验了 4 种改进方法，接下来依次介绍。
权重衰减（weight decay）：对于目标函数加入正则化项，限制权重参数的个数，这是一种防止过拟合的方法，这个方法其实就是机器学习中的 l2 正则化方法，只不过在神经网络中旧瓶装新酒改名为 weight decay [3]。
dropout：在每次训练的时候，让某些的特征检测器停过工作，即让神经元以一定的概率不被激活，这样可以防止过拟合，提高泛化能力 [4]。
批正则化（batch normalization）：batch normalization 对神经网络的每一层的输入数据都进行正则化处理，这样有利于让数据的分布更加均匀，不会出现所有数据都会导致神经元的激活，或者所有数据都不会导致神经元的激活，这是一种数据标准化方法，能够提升模型的拟合能力 [5]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fb25273367702ecda52a138d4cf8a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71f140aaa7d0db6345a9deed6a3382b0/" rel="bookmark">
			VS Code中转换大小写功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、默认情况下VS Code的编辑菜单或快捷键中没有 转换为大写，转换为小写的功能
解决方案1：使用键盘配置，开启转换为小写，转换为大写的快捷键 以VS中的 快捷键为例：
小写 -》Ctrl+U
大写=》Ctrl+Shift+U
解决方案2，直接修改keybings.json 添加配置
{ "key": "ctrl+shift+u", "command": "editor.action.transformToUppercase", "when": "editorTextFocus" }, { "key": "ctrl+shift+l", "command": "editor.action.transformToLowercase", "when": "editorTextFocus" }更多：
VS Code修改选中文字或代码的颜色
VS Code 列编辑功能说明
VS Code使用技巧整理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c06da416d948ba5af84c5b08163735/" rel="bookmark">
			JQuery 动态加载iframe.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html:
&lt;iframe id="ifm" style="width:inherit;height:inherit" runat="server" &gt;&lt;/iframe&gt; &lt;li data-options="iconCls:'icon-search'"&gt; &lt;a href="javascript:void(0)" onclick="showdata()"&gt;学生成绩表&lt;/a&gt; &lt;/li&gt; JS：
function showdata() { $("#ifm").attr("src", 'showdialog.aspx');//JQuery动态加载iframe。 } .net aspx后台加载：
if (!IsPostBack) { this.ifm.Attributes.Add("src ", "showdialog.aspx"); } 转载于:https://www.cnblogs.com/longdb/p/7582686.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a68c9bab796eb061aeafce16c767c7/" rel="bookmark">
			Xcode9解决exportArchive: requires a provisioning profile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://stackoverflow.com/questions/45748140/xcode-9-distribution-build-fails-because-format-of-exportoptions-plist-has-chang
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3a06564a088d8db0ac92a34882a1f8a/" rel="bookmark">
			Android 慎用GsonFormat，小心入坑！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装：请自行在Android stdio中下载此插件并安装。 2.使用： 3.问题： 一直以来，我都十分喜欢这个工具，但是它有一个巨坑的地方。比如： 用工具生成的类有有static出现，在这里并没有它存在的意思，它的存在导致我的程序出错还不报错。我们要知道，内部类出现静态类，静态类分配内存就不一样，赋值也不一样。希望今后使用这个工具时候，可以谨慎点，检查下类中代码在写其他代码，不然小问题也可以浪费你很长的时间，到时候就后悔莫及了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcc98d8cee95dcbcea2301afd928723/" rel="bookmark">
			矩阵求逆（c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵求逆（c++） 标签（空格分隔）： 技术博客
简要过程介绍 方法的名称是“Gauss-Jordan (or reduced row) elimination method”。
设单位对角矩阵为I，则 MM−1=I 主要过程为，摆一个相同大小的对角矩阵在旁边，将原矩阵变成对角矩阵的过程中，对对角矩阵施以相同的变化。原理为，对矩阵施以特定变化等同于对矩阵进行线性计算。
实现过程 第一步： 准备阶段：进行 行与行的变换，使矩阵对角位的数值非0。
过程如下： + 按顺序我们先从第一行开始。 + 查看后面所有行中位于第一个位置的元素的绝对值，找到绝对值最大的那一行，将其与第一行位置交换。 + 如果绝对值最大为0，此矩阵不可逆，退出。 + 紧接着做第二行，依旧查看后续行中位于第二列的元素中绝对值，将绝对值最大的行与第二行交换。
代码为一个4*4的矩阵求逆（4*4矩阵在图形学中用途最广）
int i, j, k; Matrix44&lt;T&gt; s; Matrix44&lt;T&gt; t(*this); for (i = 0; i &lt; 3; i++) {//找到下三角每列的绝对最大值 int pivot = i; T pivotsize = t[i][i]; if (pivotsize &lt; 0)pivotsize = -pivotsize; for (j = i + 1; j &lt; 4; j++) { T tmp = t[j][i]; if (tmp &lt; 0)tmp = -tmp; if (tmp &gt; pivotsize) { pivot = j; pivotsize = tmp; } } if (pivotsize == 0) { //can not inverse return Matrix44(); } if (pivot !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdcc98d8cee95dcbcea2301afd928723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/344a4f011a3daaf7d20a1e1c3bdd8535/" rel="bookmark">
			opencv图像遮掩及移动区域像素占比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include "opencv2/opencv.hpp" #include "opencv2/video/background_segm.hpp" using namespace cv; using namespace std; int main() { VideoCapture capture; capture.open(0); int frameNum = 1; Mat frame, mask, thresholdImage, output; if (!capture.isOpened()) cout &lt;&lt; "fail to open!" &lt;&lt; endl; capture &gt;&gt; frame; Ptr&lt;BackgroundSubtractorMOG2&gt; bgsubtractor = createBackgroundSubtractorMOG2(); bgsubtractor-&gt;setVarThreshold(20); while (true) { capture &gt;&gt; frame; ++frameNum; // 视频遮挡 //cv::Mat logo = cv::imread("mark.bmp"); Mat logo(400, 300, CV_8UC3, Scalar(0, 0, 255)); cv::Mat imageROI; int x = (frame.cols - logo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/344a4f011a3daaf7d20a1e1c3bdd8535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/258c6449dc3f4fbd53c62230e800a366/" rel="bookmark">
			堆排序重要算法：向上向下调整算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stl中并没有堆这样一个类（但是有个priority_queue，这其实就是堆哦，stl跟大小比较相关的容器大都允许自定义比较函数哦，很不错的呢），但是在学习中我们可以模拟实现堆，把它封装为一个类，然后在运用当中调用它的各种接口，实现一次可以深入理解堆排序的原理和优势，使我们在面对各种问题的时候可以借助这个算法实现更好的优化。
接下来就让我们看一下具体的实现过程：
这里是头文件和命名空间的包函
#pragma once #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;assert.h&gt; using namespace std; 这里是模拟实现的堆数据结构 template&lt;class T, class Compare&gt; class Heap { public: Heap() //无参构造函数 {} Heap(const T* a, size_t n) //使用数组初始化堆 { size_t i = 0; _a.reserve(n); for (i = 0; i &lt; n; i++) { _a.push_back(a[i]); } int parent = (n - 1) / 2; for (parent; parent &gt;= 0; parent--) { adjustdown(parent); //建堆需要实现的向下调整算法； } } void Push(const T&amp; x) { _a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/258c6449dc3f4fbd53c62230e800a366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c085d11fd3c734693f9f76632a7857d/" rel="bookmark">
			简单易懂的softmax交叉熵损失函数求导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来写一个softmax求导的推导过程，不仅可以给自己理清思路，还可以造福大众，岂不美哉~
softmax经常被添加在分类任务的神经网络中的输出层，神经网络的反向传播中关键的步骤就是求导，从这个过程也可以更深刻地理解反向传播的过程，还可以对梯度传播的问题有更多的思考。
softmax 函数 softmax(柔性最大值)函数，一般在神经网络中， softmax可以作为分类任务的输出层。其实可以认为softmax输出的是几个类别选择的概率，比如我有一个分类任务，要分为三个类，softmax函数可以根据它们相对的大小，输出三个类别选取的概率，并且概率和为1。
softmax函数的公式是这种形式：
S i = e z i ∑ k e z k S_i = \frac{e^{z_i}}{\sum_k{e^{z_k}}} Si​=∑k​ezk​ezi​​
S i S_i Si​代表的是第i个神经元的输出。
ok，其实就是在输出后面套一个这个函数，在推导之前，我们统一一下网络中的各个表示符号，避免后面突然出现一个什么符号懵逼推导不下去了。
首先是神经元的输出，一个神经元如下图：
神经元的输出设为：
z i = ∑ j w i j x i j + b z_i = \sum_j{w_{ij} x_{ij} + b} zi​=j∑​wij​xij​+b
其中 w i j w_{ij} wij​是第 i i i个神经元的第 j j j个权重， b b b是偏移值。 z i z_i zi​表示该网络的第 i i i个输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c085d11fd3c734693f9f76632a7857d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/758735d650b1509c90b764e33c702e0d/" rel="bookmark">
			mysql常用代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://tool.oschina.net/uploads/apidocs/mysql-5.1-zh/sql-syntax.html#sqlps 语法
–查询兴趣是books select my_contacts.*,interests.interest from my_contacts,contact_interest,interests where interests.interest=’books’ and contact_interest.interest_id=interests.id and my_contacts.id=contact_interest.contact_id; –另外一种写法 select my_contacts.id,my_contacts.phone,my_contacts.last_name,my_contacts.first_name,my_contacts.email,my_contacts.birthday,my_contacts.prof_id,my_contacts.status_id,my_contacts.zip_id,interests.interest,profession.profession,status.status,zip_code.city,zip_code.state,zip_code.zip_code from my_contacts inner join contact_interest on my_contacts.id=contact_interest.contact_id inner join interests on contact_interest.interest_id=interests.id inner join profession on my_contacts.prof_id=profession.id inner join status on my_contacts.status_id=status.id inner join zip_code on my_contacts.zip_id=zip_code.id where interests.interest=’books’; –创建personbooks表，作为Php查询的视图表。但是表不能一起更新呀？可以插入？怎样插入呀？ –更新，直接通过查询可以更新吗？注意语句方法，不通用。可以呀，就是视图呀。就是查询的代码复制创建的。 create view person_books as select my_contacts.id,my_contacts.phone,my_contacts.last_name,my_contacts.first_name,my_contacts.email,my_contacts.birthday,my_contacts.prof_id,my_contacts.status_id,my_contacts.zip_id,interests.interest,profession.profession,status.status,zip_code.city,zip_code.state,zip_code.zip_code from my_contacts inner join contact_interest on my_contacts.id=contact_interest.contact_id inner join interests on contact_interest.interest_id=interests.id inner join profession on my_contacts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/758735d650b1509c90b764e33c702e0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce4c3d7503615f59092ceb77cef4b161/" rel="bookmark">
			文档类型声明&lt;!DOCTYPE&gt;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天的笔试面试有几次涉及到了这个知识点，所以今天就来总结总结，有错误可以指出，大家一起交流，共同进步。
&lt;!DOCTYPE&gt;即文档类型声明，它的作用就是告诉浏览器的解析器应该以什么样的文档类型定义（DTD）来解析文档。
HTML 4.01规定了DTD有三种类型：strict,transitional,frameset
其中：strict:如果您需要干净的标记，免于表现层的混乱，请使用此类型。请与层叠样式表（CSS）配合使用。
&lt;!doctype html public "-/w3c/dtd html 4.01/en" "http://www.w3.org/tr/html4/strict.dtd"&gt; transitional：Transitional DTD 可包含 W3C 所期望移入样式表的呈现属性和元素。如果您的读者使用了不支持层叠样式表（CSS）的浏览器以至于您不得不使用 HTML 的呈现特性时，请使用此类型。
&lt;!doctype html public "-/w3c/dtd html 4.01 transitional/en" "http://www.w3.org/tr/html4/loose.dtd"&gt; frameset：Frameset DTD 应当被用于带有框架的文档。除 frameset 元素取代了 body 元素之外，Frameset DTD 等同于 Transitional DTD。
&lt;!doctype html public "-/w3c/dtd html 4.01 frameset/en" "http://www.w3.org/tr/html4/frameset.dtd"&gt;
由于HTML5不基于SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为，而HTML4.01基于SGML，所以需要对DTD进行引用。
浏览器对页面的渲染（对css的解析）分为两种模式：标准模式和怪异模式，所谓的标准模式是指，浏览器按W3C标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。
当我们不使用&lt;!DOCTYPE&gt;或者使用错误的&lt;!DOCTYPE&gt;时，浏览器将会按照怪异模式解析文档，因此在不同的浏览器中页面呈现的方式有所不同或者是导致其他更加严重的后果，所以为了能够最大的兼容不同的浏览器，我们要养成正确使用&lt;!DOCTYPE&gt;的习惯，在HTML5之前最好都采用strict类型。
严格模式和怪异模式具体有什么差别呢？举例如下：
标准模式中IE6不认识!important声明，IE7、IE8、Firefox、Chrome等浏览器认识；而在怪异模式中，IE6/7/8都不认识!important声明。
这只是其中的一个差异，实际上还存在其他的一些差异，比如对盒子模型的解析等等。
参考：http://www.cnblogs.com/jenry/archive/2013/01/05/2846557.html
http://www.cnblogs.com/xiaomifeng/p/4502940.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d826ba33496f020288b1f3f052fec98/" rel="bookmark">
			关于ajax请求  后台返回中文数据乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法上使用@ResponseBody注解 让容器知道返回的不是页面
以下转载
@ResponseBody
在@Controller 类方法中可以让字符串直接返回内容。
其返回处理的类是org.springframework.http.converter.StringHttpMessageConverter，此类默认编码
SO-8859-1 所以乱码 可以在Spring配置文件中修改 如下： &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter" &gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;bean class = "org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name = "supportedMediaTypes"&gt;
&lt;list&gt;
&lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 可以解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343fba2b243c56e6c524893f36123258/" rel="bookmark">
			常用的计时函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常的工作过程中，时常会遇到需要计时的要求，不同场合需要的计时精度也不同，这里列举几个常用的计时函数，以备不时之需。
1、time()
头文件：time.h
原型：time_t time(time_t *tloc)
精度： &lt;1s
精度级别：低
示例：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main(int argc, char* argv[]) { time_t now; now = time(NULL); printf("%s %ju secs since the Epoch\n", asctime(localtime(&amp;now)), now); system("pause"); return 0; } 2、clock()　头文件：time.h
原型：clock_t clock(void)
说明：返回从“开启这个程序进程”到“程序中调用clock()函数”时之间的CPU时钟计时单元（clock tick）数，与 CLOCKS_PER_SEC(#define CLOCKS_PER_SEC ((clock_t)1000))有关，
精度：&lt;10ms
精度级别：低
示例：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; int main(int argc, char* argv[]) { clock_t start, end; long long i = 0; start = clock(); while (i &lt; 10000000000) ++i; end = clock(); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/343fba2b243c56e6c524893f36123258/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135ea7910777b6b22ab9e03b7330ccca/" rel="bookmark">
			C&#43;&#43;中new、delete
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 new/delete（操作符）作用手工分配内存（heap上） malloc/free（函数）
2 new/delete int 基础类型
int *p2 = new int(10);
printf("%d\n", *p2);
delete p2;
3 new/delete 数组
int *p1 = new int[10];
delete[] p1;
4 new/delete类
c++中的new能自动的调用类的构造函数，delete能调用类的析构函数
malloc不会调用类的构造函数 free也不会调用类的析构函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a30939b93dc0d8e41a892c3d185a3b78/" rel="bookmark">
			JAVA-Comparable接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TreeSet实现类中的元素是无序的，但是可以按照一定的顺序遍历，当我们自定义一个类，就需要用Comparable接口或者Comparator接口覆写其中的方法来实现元素之间的比较排序。
用Person类为例（需要覆写hashCode()和equals()方法）
**
1.Comparable接口 **
第一步，Person类implements接口
第二步，在Person类中覆写compareTo()方法
//在Person类中覆写 @Override public int compareTo(Object o) { if(o instanceof Person){ Person person=(Person)o; //return this.age-person.age; // int型对象没有方法，所以只能返回运算；如果Integer age，可以用return this.age.compareTo(person.age) int i=this.age.compareTo(person.age); if(i==0){ return this.name.compareTo(person.name); }else return i; } return 0; } 2.Comparator接口 （1）内部类写法
public class TreeSetTest { @Test public void test() { Comparator com=new Comparator(){ @Override public int compare(Object o1, Object o2) { if(o1 instanceof Person &amp;&amp; o2 instanceof Person){ Person person1=(Person)o1; Person person2=(Person)o2; int i=person1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a30939b93dc0d8e41a892c3d185a3b78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47398780123b5b20f78287c074614e81/" rel="bookmark">
			eMMC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		e·MMC ™ Memory MTFC4GMVEA-4M IT, MTFC8GLVEA-4M IT, MTFC16GJVEC-4M IT, MTFC32GJVED-4M IT, MTFC64GJVDN-4M IT Features • MultiMediaCard (MMC) controller and NAND Flash • 153- or 169-ball WFBGA/VFBGA/LFBGA (RoHS 6/6- compliant) • V CC : 2.7–3.6V • V CCQ (dual voltage): 1.65–1.95V; 2.7–3.6V • Temperature ranges – Industrial temperature: –40 ̊C to +85 ̊C – Storage temperature: –40 ̊C to +85 ̊C • Typical current consumption – Standby current: 120μA for 4GB–16GB; 140μA for 32GB; 160μA for 64GB – Active current (RMS): 80mA (4GB–64GB) MMC-Specific Features • JEDEC/MMC standard version 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47398780123b5b20f78287c074614e81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f53679b9ddcfdb449f4b29cfdf5144aa/" rel="bookmark">
			2.16 数据存储
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day16 数据存储 一,PlayerPrefs存储数据 1,PlayerPrefs适用范围 a. 存储机制：Key-Value b. 可存储变量类型：int、float、string 2, 常用方法 SetFloat 存储float类型的数据 SetInt 存储int类型的数据 SetString 存储string类型的数据 DeleteAll 删除所有PlayerPrefs数据 GetFloat 通过Key值获取float类型的数据 GetInt 通过Key值获取int类型的数据 GetString 通过Key值获取string类型的数据 HasKey 判断是否存在该Key值的数据 3,使用方法 PlayerPrefs.SetFloat("Score",10.0f); 二,XML数据生成和解析 1,XML常用的类 1. XmlDocument——XML文件类 2. XmlNode——XML节点类 3. XmlAttribute——XML属性类 4. XmlElement——XML元素类 2,XmlNode InnerText 获取或设置节点及其所有子节点的值。(仅元素节点拥有) Value 获取或设置节点的值。(仅属性节点拥有) AppendChild 将指定的节点添加到该节点的子节点列表的末尾 3,XmlDocument CreateXmlDeclaration 创建一个具有指定值的 XmlDeclaration 节点。 CreateElement 创建具有指定名称的元素。 CreateNode 创建具有指定的节点类型、 Name 和 NamespaceURI 的 XmlNode。 AppendChild 将指定的节点添加到该节点的子节点列表的末尾。 （继承自 XmlNode。） Save 将 XML 文档保存到指定的文件。 4,XmlElement SetAttribute 设置具有指定名称的特性的值。 HasAttributes 判断该元素节点是否具有属性 5,Xml数据生成步骤 在Unity引擎中如何生成本地XML数据？ 第一步：引用C#的命名空间 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f53679b9ddcfdb449f4b29cfdf5144aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b985bf02713ffba1767dbff4979b45e/" rel="bookmark">
			统计学简介之五——两个样本均值之差的分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 统计学简介之五——两个样本均值之差的分布 一、均值之差的定义 二、例题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3821a861bbd88e925b9056c0e7e0d909/" rel="bookmark">
			qt获取combox内容的知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		combox如何获取数据：
1.currentIndex(); 获取当前comBox的索引，是int类型的值。
2.currentText(); 获取当前comBox的文本，是QString类型。
3.currentData(int role = Qt::UserRole)获取当前comBox绑定的数据，是QVariant类型。
具体使用方法：
QWidget * widget=ui-&gt;tableWidget-&gt;cellWidget(j,0);//获得widget
QComboBox *combox=(QComboBox*)widget;//强制转化为QComboBox double kernelkind=combox-&gt;currentIndex();//获得索引数据 int QString str=combox-&gt;currentText();//获取文本文档 自己编写的代码：用来获取combox和tablewidget中的内容 int *Dialog1::on_pushButton_2_clicked(){int num; int j=5; double *a=new double[j]; for(int j=0;j&lt;2;j++) {QWidget * widget=ui-&gt;tableWidget-&gt;cellWidget(j,0);//获得widget QComboBox *combox=(QComboBox*)widget;//强制转化为QComboBox QString string=combox-&gt;currentText();//获得combox中的文本内容 if(string==tr(""))//判断内容是否为空 { { QMessageBox::warning(NULL, "warning", "Content", QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes); break; } } } for(int j=2;j&lt;5;j++) { if(ui-&gt;tableWidget-&gt;item(j,0)==NULL|| //判断指向该cell的指针是否为空 (ui-&gt;tableWidget-&gt;item(j,0)&amp;&amp;ui-&gt;tableWidget-&gt;item(j,0)-&gt;text()==tr(""))) { QMessageBox::warning(NULL, "warning", "Content", QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes); break; } } for(int j=0;j&lt;2;j++) { QWidget * widget=ui-&gt;tableWidget-&gt;cellWidget(j,0);//获得widget QComboBox *combox=(QComboBox*)widget;//强制转化为QComboBox double kernelkind=combox-&gt;currentIndex(); a[j]=kernelkind; qDebug()&lt;&lt; a[j]; } for(int j=2;j&lt;5;j++) { QString s=ui-&gt;tableWidget-&gt;item(j,0)-&gt;text();//取出字符串 double num = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3821a861bbd88e925b9056c0e7e0d909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/661cd0f397a7dbfb681f321ebb0b755d/" rel="bookmark">
			快速上传ipa文件到iTunes Connect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常打包的ipa文件上传到App Store审核，要用到xcode或者Application Loader上传
只能在mac苹果机上传
这里分享的这个ipa上传辅助工具Appuploader在Windows、Linux或Mac系统都能上传、跨平台开发没有Mac苹果机的iOS上架非常实用。
亲测20M的ipa包，一分多钟就上传成功了、非常快。
Appuploader还可以在辅助申请iOS证书、同样可以在Windows、Linux或Mac系统中申请，不需要Mac钥匙串助手生成csr文件。
Appuploader还有个特别的功能，可以不用99美金的苹果开发者账号、用普通的apple id就可以申请iOS开发证书，可以打包ipa安装到非越狱手机测试。
Appuploader工具官网
http://www.applicationloader.net
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73f24b55ce645aa6454fe63af09e2664/" rel="bookmark">
			vortex-报错集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题一：
CREATE TABLE: Improper use of NULL in the target list;
use conversion function to specify data type of the null value.
字段列表中，null 作为字段时候会报此错误 ，作个转换就好 cast(null as 数据类型) as 字段名 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715c60ed6f5d7b7742094facc589beff/" rel="bookmark">
			明码 与 密码 切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;明码&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action ='#'&gt; &lt;input type="text" name="password"&gt; &lt;input type="button" name="showPassword" value='明码'&gt; &lt;/form&gt; &lt;script type='text/javascript'&gt; var form = document.forms[0]; var password = form.password, showPassword = form.showPassword; showPassword.onclick = function(){ var type = password.getAttribute('type'); if (type === 'password') { this.value = '明码'; password.setAttribute('type', 'text'); } else { this.value = '密码'; password.setAttribute('type', 'password'); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79e0a03e2dd9d403748748f7ce174a3f/" rel="bookmark">
			mysql初学者的小坑``和&#39;&#39; 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来看这段sql语句
create table 'product_info'(
'product_id' varchar(32) not null,
'product_name' varchar(64) not null comment '商品名称',
'product_price' decimal(8,2) not null comment '单价',
'product_stock' int not null comment '库存',
'product_description' varchar(64) '描述',
'product_icon' varchar(512) comment '小图',
'category_type' int not null comment '类目编号',
'create_time' timestamp not null default current_timestamp comment '创建时间',
'update_time' timestamp not null default current_timestamp on update current_timestamp commont '修改时间',
primary key('product_id')
) comment '商品表';
乍一看这段代码是没问题的，但运行时它却会报错：
Error Code: 1064. You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''product_info'( 'product_id' varchar(32) not null, 'product_name' varchar(6' at line 1 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79e0a03e2dd9d403748748f7ce174a3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403f4d04a64b3ea70626b18dac8aa5c2/" rel="bookmark">
			作业1  对这门课的希望和自己的目标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这门课 感觉比较高深
但是希望自己可以尽量去学
至少已经学会了使用博客
目标么？
简简单单 期末不挂科！
哦耶！
转载于:https://www.cnblogs.com/maerr/p/7514795.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/340977bb338dd8a7169b00a168e50a2a/" rel="bookmark">
			java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：导入commons-logging.jar包
如果用的是maven直接用：
&lt;dependency&gt;
&lt;groupId&gt;commons-logging&lt;/groupId&gt;
&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
&lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;即可
报错：
Exception in thread "main" java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory
at org.apache.commons.beanutils.ConvertUtilsBean.&lt;init&gt;(ConvertUtilsBean.java:154)
at org.apache.commons.beanutils.BeanUtilsBean.&lt;init&gt;(BeanUtilsBean.java:113)
at org.apache.shiro.config.ReflectionBuilder.&lt;init&gt;(ReflectionBuilder.java:126)
at org.apache.shiro.config.ReflectionBuilder.&lt;init&gt;(ReflectionBuilder.java:120)
at org.apache.shiro.config.IniSecurityManagerFactory.&lt;init&gt;(IniSecurityManagerFactory.java:64)
at org.apache.shiro.config.IniSecurityManagerFactory.&lt;init&gt;(IniSecurityManagerFactory.java:68)
at org.apache.shiro.config.IniSecurityManagerFactory.&lt;init&gt;(IniSecurityManagerFactory.java:73)
at com.shiro.test.test.main(test.java:21)
Caused by: java.lang.ClassNotFoundException: org.apache.commons.logging.LogFactory
at java.net.URLClassLoader$1.run(URLClassLoader.java:366)
at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
at java.security.AccessController.doPrivileged(Native Method)
at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
at java.lang.ClassLoader.loadClass(ClassLoader.java:423)
at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
at java.lang.ClassLoader.loadClass(ClassLoader.java:356)
... 8 more
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba02268623a17fc27fc1b7dfb7b510b2/" rel="bookmark">
			哈希表查找(Java)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		散列（哈希表） 1.基本思想：将关键字 (数据项)被映射到从0到Tablesize-1这个范围中的某个数，并且被放到适当的单元中。其中这个映射就叫做散列函数。
0 ≤ H(Ki) ≤ Tablesize−1 如图：
2.冲突：将两个不同的关键字映射到同一表的位置。如图： 3.构造哈希函数的两个标准：(1)简单并且能快速计算；(2)能在地址中获取键的均部分。
4.构造哈希函数的几种常见方法: (1)平均取中法：具体做法是先通过关键字的平方值扩大相近数的差别，然后根据表长度取中间的几位数作为哈希值。 例如：将一组关键字(0100，0110，1010，1001，0111)平方后得(0010000，0012100，1020100，1002001，0012321)若取表长为1000，则可取中间的三位数作为散列地址集：(100121，201，020，123)。
(2)除余法：用关键字除以一个不大于哈希表长度 m 的正整数p(素数)所得的余数作为哈希地址的一种方法。 h(key) = key % p (3)折叠法：根据哈希表长将关键字尽可能分成若干段，然后将这几段的值相加，并将最高位的进位舍去，所得结果即为其哈希地址。 例如：有一组关键字(4766934, 5656975, 4685673, 3547807,7569664)，将这些数拆成2位，4位和1位数，然后再把它们相加，如下图： 4.解决哈希冲突 4.1开放定址法：当冲突发生时，按照某种方法探测表中的其他存储单元，直到找到空位置为止。
Hi = (H(key)+di) % m (i=1,2,...k(k ≤ m−1) (1)线性探测法： di = 1,2,3,...,m−1 (2)二次探查法： di = 12,22,32,42,...,k2 (3)双重哈希法 : 一旦发生冲突， 应用第二个哈希函数以获取备用位置。 4.2链表法：将所有关键字为同义词的结点链接在同一个单链表中。 5.哈希查找的 Java 实现： “`Java /** * 哈希查找的算法的实现 * * {1，3，66，56，34，67，343，77，31，64，0，5，6，32，55，23，56}采用哈希表存放 用除余法构建哈希函数 用链表法解决哈希冲突 * * @author zww * */ public class HashTableSearch { /* 哈希结点 */ private static class Node { int key; // 链表中的键 Node next; // 下一个同义词 }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba02268623a17fc27fc1b7dfb7b510b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28c5d33b927986eca8c4fcc8a11c8bae/" rel="bookmark">
			推荐系统基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于推荐系统的基础整理，是对于部门内部交流培训学习“推荐系统基础”的一个整理，比较基础。And，这基本是技术知识~~
1 个性化推荐概述 1.1 推荐系统概述 首先，需要申明一点的就是推荐系统！=推荐算法。推荐系统是一套完善的推荐机制，包括前期数据的准备、具体推荐的过程(这个过程可能是一套复杂的算法模型，也可能是一个简单的规则，也可能是多种模型的混合结果等等)、后期数据的预测、AB测试效果评估等等。
1.2 推荐算法模型概述 在算法模型上大体可以分基于内容的推荐、基于协同过滤的推荐。
基于内容推荐，即通过内容本身的属性，然后计算内容的相似性，找到与某物品属性相似的物品。协同过滤，所谓协同过滤，即不依赖于物品本身的物品属性，而是通过其他相关特征，例如人参与的行为数据，来达到推荐物品的目的。
关于协同过滤，又分为以下几个类别：基于物品的协同，即ItemCF；基于用于的协同，即UserCF；基于模型的协同，即ModelCF。
其中，基于模型的协同又可以分为以下几种类型：基于距离的协同过滤；基于矩阵分解的协同过滤，即Latent Factor Model(SVD)；基于图模型协同，即Graph，也叫社会网络图模型。
2 基于内容的推荐 其实但从字面上也好理解，其推荐的依据为物品的内容，即物品的具体相关属性。换言之，即我们希望找到的是跟当前物品相似的物品。
那么，我们的目标就明确了，计算当前物品与其他物品的相似度，然后生成一个相似TopN列表，然后想要多少个推荐多少个。
通常我们会有以下两种方式来计算相似度：通过物品间的距离去度量相似；通过直接计算相似度。
2.1 计算物品距离的几种方法 (1) 欧几里得距离(Euclidean Distance)
最常见的距离度量方式，衡量多维空间中两点之间的绝对距离，要求维度的统一。
(2) 明可夫斯基距离(Minkowski Distance)
明氏距离是欧氏距离的扩展，是对多个距离度量公式的概括性的表述(可以看到，当p=2时，其实就是欧式距离)。
(3) 曼哈顿距离(Manhattan Distance)
曼哈顿距离来源于城市区块距离，是将多个维度上的距离进行求和后的结果，即当上面的明氏距离中p=1时得到的距离度量。
//还有其他的一些距离度量，但是都不太常用，最常用的依然是欧式距离度量。
2.2 计算相似度量的几种方法
(1) 向量空间余弦相似度(Cosine Similarity)
余弦相似度用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小。相比距离度量，余弦相似度更加注重两个向量在方向上的差异，而非距离或长度上。
(2) 皮尔森相关系数(Pearson Correlation Coefficient)
即相关分析中的相关系数r，分别对X和Y基于自身总体标准化后计算空间向量的余弦夹角。
基于内容的推荐，还有一点需要注意的就是，对于物品自身属性，如果属性值过少，我们需要适当进行扩大维度，如果维度过多，则需要进行降维。
关于降维和升维，都是一个很大的研究方向，大体上可以说一下几种常见的方式。例如降维，我们可以进行维度聚类、主题抽取，进一步把相关维度进行合并，进一步减少维度；而对于升维，我们可以把维度进行矩阵化，例如假设物品X有A和B两个维度属性，那么我们通过生成A*B矩阵的方式，把维度扩充到A*B个维度。
3 基于协同过滤的推荐
3.1 基于用户的协同(UserCF) 基于用户的协同过滤，即我们希望通过用户之间的关系来达到推荐物品的目的，于是，给某用户推荐物品，即转换为寻找为这个用户寻找他的相似用户，然后相似用户喜欢的物品，那么也可能是这个用户喜欢的物品(当然会去重)。
来看一个表格：
用户/物品
物品A
物品B
物品C
物品D
用户A
Y
？
Y
？
用户B
-
Y
-
-
用户C
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28c5d33b927986eca8c4fcc8a11c8bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca77ab3dc15b2adc0a0f7f3b4671bce/" rel="bookmark">
			typedef在结构体定义中的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：http://www.cnblogs.com/lzjsky/archive/2010/11/24/1886717.html
面向对象的语言接触得多了，经常会忘记c语言中结构体变量声明的特殊性，在这里总结回顾一下。
一、结构体在代码中的两种常见定义形式
(1) 结构体类型定义
struct A
{
...
};
定义{}中的结构体为一个名称是"A"的结构体。
使用这种定义方式时，必须使用struct A xxx来声明变量，A xxx的声明形式在c语言中是不被支持的。
eg: 想要声明一个类型为A的结构体变量a
struct A { unsigned char ucZERO; unsigned char ucRESERVED; unsigned short usALERT; }; A a; 错误信息：
(2)结构体变量定义
struct
{
...
}A;
以{}中的结构定义一个名称为"A"的结构体变量，A是结构体变量不是结构体类型。这种定义形式下的结构体被称为匿名结构体，是没办法被直接引用的。
二、typedef在结构体定义中的应用
typedef是c语言关键字，作用是为一种数据类型定义一个新的名字。对于以上两种结构体定义形式，typedef都可以为其创建别名。
(1) 为结构体A创建一个别名tagA
typedef struct A
{
... }tagA;
(2) 为匿名结构体创建一个别名tagA
typedef struct
{
... }tagA;
typedef在这里的应用解决了匿名结构体不能被再引用的问题。
三、总结
不管是以上那种方式的应用，在c语言中使用typedef帮助定义结构体，对于声明结构体变量，便可以直接使用tagA xxx(结构体名 对象名)的形式，而没必要带上struct关键词。实际项目C代码中，结构体的定义一般都使用了typedef，在大量使用结构体变量的场合，这样会省事很多。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5300de7b4094806e93589a9d96ffc291/" rel="bookmark">
			算法学习之递归--爬楼梯问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 例题: 爬楼梯 树老师爬楼梯，他可以每次走1级或者2级，输入楼梯的级数，求不同的走法数。
例如：楼梯一共有3级，他可以每次都走一级，或者第一次走一级，第二次走两级，也可以第一次走两级，第二次走一级，一共3种方法。 输入：输入包含若干行，每行包含一个正整数N，代表楼梯级数，1 &lt;=N &lt;= 30输出不同的走法数，每一行输入对应一行
输出：不同的走法数，每一行输入对应一行输出
分析：n级台阶的走法 = 先走一级后，n-1级台阶的走法 + 先走两级后，n-2级台阶的走法。即 f(n) = f(n-1)+f(n-2)
很经典也很简单的题，算法如下：
#include&lt;iostream&gt; using namespace std; int stair(int n){ if( n == 0 ) return 1; if( n == 1 ) return 1; return stair( n-1 ) + stair( n-2 ); } int main(){ int n; while(cin&gt;&gt;n) cout&lt;&lt;stair(n)&lt;&lt;endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68796436ff21dfe21b43b8c3e6a936a6/" rel="bookmark">
			CGJ02、BD09、西安80、北京54、CGCS2000常用坐标系详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、万能地图下载器中的常用坐标系
水经注万能地图下载器中的常用的坐标系主要包括WGS84经纬度投影、WGS84 Web 墨卡托投影、WGS84 UTM 投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02经纬度投影、GCJ02 Web 墨卡托投影、BD09 经纬度投影和BD09 Web 墨卡托投影等。
其中，WGS84、WGS84 Web 墨卡托、GCJ02和BD09是近年来GIS系统（尤其是WebGIS）中的常用坐标系，而西安80、北京54和CGCS2000坐标是测绘中常用的坐标系。
本软件除了支持常用的坐标系外，还支持其它各种地理坐标系和投影坐标系，当在坐标投影转换时，选择“更多”可以选择其它坐标系。
对于不同的功能，本软件所支持的常用坐标系略有不同，本文将会对矢量导入导出、影像导出大图、影像导出瓦片和高程导出所支持的坐标系分别作出说明。
二、矢量导入导出坐标系
矢量导入主要包括导入下载范围和导入矢量数据叠加，这两中导入方式均支持WGS84经纬度投影、WGS84 Web 墨卡托投影、WGS84 UTM 投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02经纬度投影、GCJ02 Web 墨卡托投影、BD09 经纬度投影和BD09 Web 墨卡托投影等。
下图为导入沿线路径时，可选择的坐标投影。
下图为导入矢量数据时，可选择的坐标投影。
与导入数据相同，在将矢量数据导出时也可以进行WGS84经纬度投影、WGS84 Web 墨卡托投影、WGS84 UTM 投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02经纬度投影、GCJ02 Web 墨卡托投影、BD09 经纬度投影和BD09 Web 墨卡托投影等投影转换。
三、影像导出大图坐标系
在下载卫星影像并导出大图时，可支持导出WGS84经纬度投影、WGS84 Web 墨卡托投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02 Web 墨卡托投影和BD09 Web 墨卡托投影等，不支持导出GCJ02经纬度投影和BD09经纬度投影。
四、影像导出瓦片坐标系
在下载卫星影像导出瓦片时，只可以选择导出WGS84经纬度投影、WGS84 Web 墨卡托投影、GCJ02 Web 墨卡托投影和BD09墨卡托投影。
五、高程导出坐标系
在导出高程时，可支持导出WGS84经纬度投影、WGS84 Web 墨卡托投影、北京54高斯投影、西安80高斯投影、CGCS2000高斯投影、GCJ02 Web 墨卡托投影和BD09 Web 墨卡托投影等，不支持导出GCJ02经纬度投影和BD09经纬度投影。
六、常用坐标系详解
（一）WGS84坐标系
WGS-84坐标系（World Geodetic System一1984 Coordinate System）
一种国际上采用的地心坐标系。坐标原点为地球质心，其地心空间直角坐标系的Z轴指向BIH （国际时间服务机构）1984.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68796436ff21dfe21b43b8c3e6a936a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30c12ee8eebb9ce6f04b5ce2ab6b8b07/" rel="bookmark">
			硕士论文答辩需要注意哪些问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 作者：[已重置] 链接：https://www.zhihu.com/question/23980652/answer/68398285 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 毕业季：如何做个成功的硕士毕业论文答辩？ 2015-03-23 国家社科期刊数据库 【导读】研究生毕业答辩的时间一般只有20～30分钟，能不能把大量工作在这么短时间里成功地讲出来，对个人的表达能力、应变能力和综合能力都是极大的挑战。成功的演讲是自信和技巧的结合，扎实的专业知识和细致周到的答辩准备工作是成功的前提。如何做个成功的硕士毕业论文答辩？
论文写好，答辩幻灯制作完成，下一步就是要准备如何表达、进行答辩了。研究生毕业答辩的时间一般只有20～30分钟，能不能把大量工作在这么短时间里成功地讲出来，对个人的表达能力、应变能力和综合能力都是极大的挑战。
成功的演讲是自信和技巧的结合，扎实的专业知识和细致周到的答辩准备工作是成功的前提。使用一些答辩技巧也不可缺少，可以充分展示整理研究材料、展示研究成果的能力，让别人知道自己都做了什么。要想这场战争获胜，就必须对答辩的目的、程序、可能遇到的问题及解决方法进行深入剖析，做到胸有成竹！下面重点介绍硕士研究生论文答辩的技巧和注意事项。
一、硕士论文答辩考察什么
要进行答辩，首先就要明确论文答辩想考察研究生什么。硕士教育重在训练科学的思维、如何进行科学实验以及如何将科学成果转化为学术文章甚至是创造社会效益。而博士教育重在培养研究生的创造性思维，力求在前人研究的基础上有所突破，要求博士生在求学期间有好的、新的科研思路。明确了以上这些就能知道答辩委员会的各位专家们关注的中心问题了。
（一）考察论文的真实性
论文的真实性包括立题依据是否充分可行（一般没有问题，否则开题报告时就不能通过，当然也可能出现专家质疑的情况，这就需要自己对研究背景、依据等有充分的理解）；实验设计是否科学合理；实验步骤、操作方法是否准确无误；统计方法是否应用得当、数据分析结果是否可信（一般采用SPSS或者SAS软件进行统计，非统计学专业者进行数据整理和运算时最好请教医学院校统计学专业人士或求助于师长，力保统计学方法的准确。此点非常重要，因为统计学方法使用不当可能导致统计结果发生变化，从而可能导致结论不成立）。
实事求是乃科学研究的基础，论文本身必须真实可靠，弄虚作假难逃答辩委员会专家们的火眼金睛。如果在这方面出现问题，论文势必不能通过专家评审。
（二）考察相关知识与应用能力
研究生应该熟悉和掌握本领域的专业知识及相关基础知识。一个完整合理的科学实验一般都要涉及“PRFR”以下几部分：（1）“Predecessor”——前人成功的实验。也就是说课题具备立项依据，不能是凭空的假想，研究论文是建立在前人基础之上的科学假设，小心求证。（2）“Repetition”——可重复性。既涵盖我们重复前人的实验，也要保证后来者能够重复答辩者的实验，能被repeat并且被不断repeat的实验才能证明是高水平的研究，是可信的研究。（3）“Fresh”——创新。这是一个民族的灵魂也是一个科学实验的灵魂。没有创新，科学就不会进步。虽然Repeat很重要，但是Fresh建立在repeat基础之上，更具有科学意义、更具推广意义。（4）“Reliability”——科学结论合理、可靠是研究者最终的目标。
（三）考察研究生的综合素质
包括答辩者的表达能力（比如答辩委员会要求解释论文中提到的某项实验是如何具体操作的，有何心得？）、应变能力（比如一次答辩中，评委老师提出问题：“请用一段话概括一下你导师的为人”——何其尖锐？和专业知识毫无关系，但是确又和答辩者息息相关）等综合能力。
二、硕士论文的答辩准备
（一）思想准备
答辩是学校对硕士论文成绩进行考核、验收的一种形式。研究生要明确目的、端正态度、树立信心，通过论文答辩这一环节，来提高自己的分析能力、概括能力及表达能力。
（二）答辩内容准备
在反复阅读、审查自己硕士论文的基础上，写好供20分钟用的答辩报告。反复练习必不可少，尚需注意以下细节：事前亲临现场，熟悉现场布置，测试设备（如存放答辩幻灯的U盘/移动硬盘是否在答辩使用电脑上正常播放；PowerPoint版本兼容问题等）；熟悉讲稿；练习如何表达，尤其着重于引言部分和结束部分。
（三）物质准备
主要准备参加答辩会所需携带的用品。如：硕士论文的底稿、说明提要、主要参考资料，画出必要的挂图、表格及公式，必要时准备相关内容幻灯以备答辩委员会提问。
三、如何陈述硕士论文
（一）良好的开场白
开场白是整个论文答辩的正式开始，它可以吸引注意力、建立可信性、预告答辩的意图和主要内容。好的开始是成功的一半，应包括：引言、连接、启下三个作用。良好的开场白应做到：切合主题、符合答辩基调、运用适当的语言。应避免负面开头，如自我辩解等（如“我今天来的匆忙，没有好好准备……”），既不能体现对答辩委员会专家的尊重，也是个人自信不足的表现，答辩者在各位专家的第一印象中大打折扣。牢记谦虚谨慎是我国的传统美德，但是谦虚并非不自信。同时也要避免自我表现，洋洋得意，寻求赞赏。过度的表现，会引起答辩委员会专家的反感。
（二）报告的中心内容
报告的中心内容包括：论文内容、目的和意义；所采用的原始资料；硕士论文的基本内容及科研实验的主要方法；成果、结论和对自己完成任务的评价。在答辩报告中要围绕以上中心内容，层次分明。具体做到：突出选题的重要性和意义；介绍论文的主要观点与结构安排；强调论文的新意与贡献；说明做了哪些必要的工作。
讲稿一般采用幻灯片的方式展示，做到主题明确，一目了然；精选文字，突出重点，简明扼要；适当美化视觉效果，加深印象。幻灯片制作具体注意事项见本章上节。
答辩时应注意：掌握时间、扼要介绍、认真答辩。为此须做到以下几点：
1. 不必紧张，要以必胜的信心，饱满的热情参加答辩；
2. 仪容整洁，行动自然，姿态端正。答辩开始时要向专家问好，答辩结束时要向专家道谢，体现出良好的修养；
3. 沉着冷静，语气上要用肯定的语言，是即是，非即非，不能模棱两可；
4.内容上紧扣主题，表达上口齿清楚、流利，声音大小要适中，富于感染力，可使用适当的手势，以取得答辩的最佳效果；
(三)答辩委员会专家可能提出的问题
研究生报告结束后，答辩委员会专家将会提出问题，进行答辩，时间10～15分钟。一般包括：需要进一步说明的问题；论文所涉及的有关基本理论、知识和技能；考察研究生综合素质的有关问题。
评委可能提出的问题一般来源于以下几个方面：
1. 答辩委员的研究方向及其擅长的领域；
2. 可能来自课题的问题：是确实切合本研究涉及到的学术问题（包括选题意义、重要观点及概念、课题新意、课题细节、课题薄弱环节、建议可行性以及对自己所做工作的提问）；
3.来自论文的问题：论文书写的规范性，数据来源，对论文提到的重要参考文献以及有争议的某些观察标准等；
4.来自幻灯的问题：某些图片或图表，要求进一步解释；
5.不大容易估计到的问题：和课题完全不相干的问题。似乎相干，但是答辩者根本未做过，也不是课题涉及的问题。答辩者没有做的，但是评委想到了的东西，答辩者进一步打算怎么做。
(四)如何回答答辩委员会专家提出的问题
首先要做到背熟讲稿，准备多媒体，调整心态，做提问准备，进行预答辩。在随后的汇报中突出重点、抓住兴趣、留下伏笔。忌讳讨论漫无边际，由于课题是自己知识的强项，讨论时毫无收敛，漫无边际，往往是内容复杂化，过多暴露疑点难点，给提问部分留下隐患。一个聪明的研究生应该“就事论事”，仅围绕自己的结果进行简单讨论，这样提问往往更为简单，回答更为顺畅。
到了提问环节，专家提问不管妥当与否，都要耐心倾听，不要随便打断别人的问话。对专家提出的问题，当回答完整、自我感觉良好时，不要流露出骄傲情绪。如果确实不知如何回答时，应直接向专家说明，不要答非所问。对没有把握的问题，不要强词夺理，实事求是表明自己对这个问题还没搞清楚，今后一定要认真研究这个问题。
总之，答辩中应实事求是，不卑不亢，有礼有节，时刻表现出对专家的尊重和感谢。注意答辩不纯粹是学术答辩，非学术成分大约占一半，要显示出自己各方面的成熟，要证明自己有了学术研究的能力。
（五）结束语和致谢
报告结束前一定要进行致谢。导师为研究生的成长付出了很多心血，在答辩这种关键时刻，对导师表示正式而真诚的感谢，体现了对导师的尊重，这是做人的基本道理。建议全文念出对导师致谢的段落，其他的致谢段落可以简略一些。同时应当说明汇报结束，欢迎各位专家的提问，使答辩工作顺利进入下一环节。
《诗经•国风•汉广》有云：南有乔木，不可休思；汉有游女，不可求思。汉之广矣，不可泳思；江之永矣，不可方思。面临答辩时的感觉正如此诗写照。几年的辛苦学习是否有成效，要在这最后时刻得以展现。充分准备，最后的胜利一定是属于我们的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a0ea6003227b495bfbc6897d3790c6/" rel="bookmark">
			CentOS7安装aapt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7安装aapt 下载aapt工具 aapt下载链接
之后上传到服务器中，本人上传到/usr/local目录下 给aapt 添加权限 chmod 777 aapt 运行./aapt -bash: ./aapt: /lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录 此时我们需要安装：glibc.i686，zlib.i686，libstdc++.i686 先安装 yum install glibc.i686 之后在运行 ./aapt #./aapt: error while loading shared libraries: libz.so.1: cannot open shared object file: No such file or directory 安装 yum install zlib.i686 运行./aapt #./aapt: error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory 此时安装 yum install libstdc++.i686 会报版本冲突的话 就照提示说 –setopt=protected_multilib=false yum install libstdc++-4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7a0ea6003227b495bfbc6897d3790c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e2f25ca555db3db5f28f99dbfe16cc0/" rel="bookmark">
			C&#43;&#43;之 mutable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mutable 关键字 1. 在C++中，mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。
struct ST { int a; mutable int b; }; const ST st={1,2}; st.a=11;//编译错误 st.b=22;//允许 2. mutable在类中只能够修饰非静态数据成员。mutable 数据成员的使用看上去像是骗术，因为它能够使const函数修改对象的数据成员。然而，明智地使用 mutable 关键字可以提高代码质量，因为它能够让你向用户隐藏实现细节，而无须使用不确定的东西。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。
class ST { int a; mutable int showCount; void Show()const; … }; ST::Show() { …//显示代码 a=1;//错误，不能在const成员函数中修改普通变量 showCount++;//正确 } 3. const承诺的是一旦某个变量被其修饰，那么只要不使用强制转换(const_cast)，在任何情况下该变量的值都不会被改变，无论有意还是无意，而被const修饰的函数也一样，一旦某个函数被const修饰，那么它便不能直接或间接改变任何函数体以外的变量的值，即使是调用一个可能造成这种改变的函数都不行。这种承诺在语法上也作出严格的保证，任何可能违反这种承诺的行为都会被编译器检查出来. 4. mutable的承诺是如果某个变量被其修饰，那么这个变量将永远处于可变的状态，即使在一个const函数中。这与const形成了一个对称的定义，一个永远不变，而另外一个是永远可变. 5. 看一个变量或函数是否应该是const，只需看它是否应该是constant或invariant，而看一个变量是否应该是mutable,也只需看它是否是forever mutative。 6. 这里出现了令人纠结的3个问题 * 1. 为什么要保护类的成员变量不被修改？ * 2. 为什么用const保护了成员变量，还要再定义一个mutable关键字来突破const的封锁线？ * 3. 到底有没有必要使用const 和 mutable这两个关键字？ 7. 保护类的成员变量不在成员函数中被修改，是为了保证模型的逻辑正确，通过用const关键字来避免在函数中错误的修改了类对象的状态。并且在所有使用该成员函数的地方都可以更准确的预测到使用该成员函数的带来的影响。而mutable则是为了能突破const的封锁线，让类的一些次要的或者是辅助性的成员变量随时可以被更改。没有使用const和mutable关键字当然没有错，const和mutable关键字只是给了建模工具更多的设计约束和设计灵活性，而且程序员也可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。
引用 博客： http://blog.csdn.net/tht2009/article/details/6920511
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99cbb0a539025e64b4546dd001e0a831/" rel="bookmark">
			libcurl中CURLOPT_WRITEFUNCTION设置回调函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文档： Let’s assume for a while that you want to receive data as the URL identifies a remote resource you want to get here. Since you write a sort of application that needs this transfer, I assume that you would like to get the data passed to you directly instead of simply getting it passed to stdout. So, you write your own function that matches this prototype: size_t write_data(void *buffer, size_t size, size_t nmemb, void *userp); You tell libcurl to pass all data to this function by issuing a function similar to this: curl_easy_setopt(easyhandle, CURLOPT_WRITEFUNCTION, write_data); 文档只是简单的说 你可以通过设置 curl_easy_setopt(easyhandle, CURLOPT_WRITEFUNCTION, write_data)这个函数来告诉libcurl，传递所有的数据到上面的 size_t write_data(void *buffer, size_t size, size_t nmemb, void *userp);这个自己定义的满足这个格式的函数就行了。 BUT，我们来看一个例子： #include &lt;iostream&gt; #include &lt;curl/curl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99cbb0a539025e64b4546dd001e0a831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd9c2a537541a37b0c1fb435f58f3bfb/" rel="bookmark">
			Unity3d--矩形Rect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Unity使用多个2D坐标空间，其中大部分将X定义为向右增加，Y向上增加。一个例外是在GUI和GUILayout类中，其中Y向下增加。 下面以GUI的矩形示例： new Rect的两种方法： 对一个Rect对象，其成员变量为： 其可用的函数： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb692035e287c08d5b242fcadbd5e58a/" rel="bookmark">
			ArcGIS for Android Runtime100 基本操作（三）——离线数据空间查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空间查询是地理信息中的一个概念，指的是通过空间数据进行空间数据库的查询操作。
在ArcGIS for Android里，通常采用FeatureTable类来展示空间数据，每个空间表包含了一系列的字段，一个图形和一个空间参考系。而空间数据的来源主要包括在线获取，离线的geodatabase数据、VTPK数据和MMPK数据的读取等。
目前来说离线数据还是以geodatabase数据，所以我们以geodatabase数据为例说明下如何在ArcGIS for Android Runtime 100里进行空间查询。
之前我写过一篇基于Runtime 10.2.9的空间查询的例子，博客地址是：http://blog.csdn.net/bit_kaki/article/details/76429910，可以参考下。其实在Runtime 100里，对于空间查询的方法变化并不大，最大的变化就是在Runtime 100里对于异步统一采用了ListenableFuture接口来进行表达。
Query方法查询（对FeatureTable类查询）
用Query方法查询是ArcGIS for Android里最常用的查询方法，在Runtime 100里，依然是通过先构造一个QueryParameters实例，然后对其填充所需的查询参数，最后把这些参数传递给一个对FeatureTable类的Query查询方法即可。其官方API如下：
简单示例如下：
mMapView.setOnTouchListener(new DefaultMapViewOnTouchListener(this, mMapView) { @Override public boolean onSingleTapConfirmed(MotionEvent v) { android.graphics.Point screenPoint=new android.graphics.Point(Math.round(v.getX()), Math.round(v.getY())); Point clickPoint = mMapView.screenToLocation(screenPoint); QueryParameters query = new QueryParameters(); query.setGeometry(clickPoint);// 设置空间几何对象 FeatureTable mTable = dataFeatureLayer.getFeatureTable();//得到查询属性表 final ListenableFuture&lt;FeatureQueryResult&gt; featureQueryResult = mTable.queryFeaturesAsync(query); featureQueryResult.addDoneListener(new Runnable() { @Override public void run() { try { FeatureQueryResult featureResul = featureQueryResult.get(); for (Object element : featureResul) { if (element instanceof Feature) { Feature mFeatureGrafic = (Feature) element; Map&lt;String, Object&gt; mQuerryString = mFeatureGrafic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb692035e287c08d5b242fcadbd5e58a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444d7f12be6ecbec9d3dd94405274120/" rel="bookmark">
			数据结构与算法(Python)-Python快速入门篇3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 对于简单的任务，我们可以利用一些函数，按照任务处理的流程书写代码来完成需求，这种方式称之为过程式编程(procedural programming)；但是对于复杂的系统，如何有条理的将每个模块的代码内聚起来，如何清晰和简洁地表达各个模块之间的交互，就需要一种新的指导思想，面向对象编程(object-oriented programming)。OOP强调的就是为独立模块构造对象，对象之间通过消息通信来完成复杂的功能。OOP主题是复杂的，本节只对有限主题进行学习，知识结构如下图所示：
面向对象编程(OOP) 1）类的定义 在Python每个变量实际上都是指向对象的一个引用，这在前面已经说明过了。我们使用class关键字定义类，就像使用def关键字定义函数一样。在Python中，支持两种定义类的写法:
#python2.x class MyClass: # old-style class MyClass(object): # new-style class #python3.x class MyClass(object): # new-style class class MyClass: # new-style class (implicitly inherits from object) 上面的两种定义方式是受到历史原因引起的，在此我们不去深究。一种合理的方式是，在python2.x中总是显式使用:
class MyClass(object): pass 这种方式；在python3.x中如果为了兼容2.x代码则也是用这种方式，否则没有区别。
2)类的成员变量和方法 OOP与面向过程编程一个很大的区别在于，对象可以附加属性(包含哪些数据)和方法(支持哪些操作，也是一种函数)，通过将数据和函数内聚到对象身上，我们使对象的概念更加清晰，与系统其它部分的交互更加明确。例如下面定义一个圆形类:
class Circle(): pi = 3.141592 def __init__(self, radius=1): #初始化函数 类似C++构造函数 self.radius = radius def area(self): # 求面积操作 return self.radius * self.radius * Circle.pi def setRadius(self, radius): self.radius = radius def getRadius(self): return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444d7f12be6ecbec9d3dd94405274120/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c83c9a0a2ed4748ba734dd26fab8713/" rel="bookmark">
			练习二（第二周）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 练习2：
打印出所有的"水仙花数"，所谓"水仙花数"是指一个三位数，其各位数字立方和等于该数本身。例如：153 是一个"水仙花数"，因为153=1的三次方＋5的三次方＋3的三次方。
1.代码
public class Flower { public static void main(String args[]){ int i,W1,W2,W3; for(i=100;i&lt;1000;i++) { W1=i/100; W2=i%100/10; W3=i%10; if(i==(int)Math.pow(W1, 3)+(int)Math.pow(W2, 3)+(int)Math.pow(W3, 3)) { System.out.println(i); } } } } 2.运行截图 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5be75dfa003240258dc1a2d488923eb3/" rel="bookmark">
			网易笔试最长公共子括号序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个合法的括号匹配序列被定义为: 1. 空串""是合法的括号序列 2. 如果"X"和"Y"是合法的序列,那么"XY"也是一个合法的括号序列 3. 如果"X"是一个合法的序列,那么"(X)"也是一个合法的括号序列 4. 每个合法的括号序列都可以由上面的规则生成 例如"", "()", "()()()", "(()())", "(((()))"都是合法的。 从一个字符串S中移除零个或者多个字符得到的序列称为S的子序列。 例如"abcde"的子序列有"abe","","abcde"等。 定义LCS(S,T)为字符串S和字符串T最长公共子序列的长度,即一个最长的序列W既是S的子序列也是T的子序列的长度。 小易给出一个合法的括号匹配序列s,小易希望你能找出具有以下特征的括号序列t: 1、t跟s不同,但是长度相同 2、t也是一个合法的括号匹配序列 3、LCS(s, t)是满足上述两个条件的t中最大的 因为这样的t可能存在多个,小易需要你计算出满足条件的t有多少个。 如样例所示: s = "(())()",跟字符串s长度相同的合法括号匹配序列有: "()(())", "((()))", "()()()", "(()())",其中LCS( "(())()", "()(())" )为4,其他三个都为5,所以输出3.
思路：每次在原字符串中取出一个字符，将取出的字符在剩余的字符串中插空，剩余字符串保持相对位置不变，
如果插孔后的字符串符合括号规则，而且与原字符串不相同，那么这个字符串就是长度与原字符串相同的
一个符合条件的字符串结果，且能够保证LCS（S,T）最大。将符合条件的字符串存入一个map中，最后
统计map的size即可。
public class Main { public static void main (String[] args) { Scanner sc = new Scanner(System.in); String s = sc.nextLine(); char[] c = s.toCharArray(); int len = c.length; //HashMap&lt;String, Integer&gt; map = new HashMap&lt;String Integer&gt;(); HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); for (int i = 0; i &lt; len; i++) { // cishi str String s1 = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5be75dfa003240258dc1a2d488923eb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae9ce691aa5a6c3ede7a12b4ee89d3ff/" rel="bookmark">
			硕士生预答辩中存在的共性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硕士生毕业论文预答辩，作为导师对学生毕业前的最后一次集体指导，已经成为惯例。上周六，实验室对10位即将毕业的硕士生进行了全天时间的预答辩，按正式答辩的顺序和时间要求进行。由于受平时学术交流，进展汇报强调细节交流的影响，大部分同学不能在规定时间内完成汇报内容。预答辩的结果令我满意的很少。总结起来，存在的共性问题如下：
1、选题的重要性和意义阐述不清楚，让人听不出研究的价值所在。
2、汇报提纲完全按论文章节构成，没有进行合理规划、归类和整合。汇报提纲（内容）之间，无承前启后及过渡性语言。
3、对汇报内容不太熟悉，PPT文字描述太多。
4、过于强调细节，如数学公式的推导等，而忽视了介绍解决问题的思路、方案设计、实验步骤及结果的测试分析等。
5、汇报总结中，未直截了当地呈现本文的主要工作和贡献。
6、忽视取得的成果展示，如论文、专利、获奖情况等一带而过。
7、无致谢。 由于答辩委员会成员，研究方向各异，有偏实验科学的、有偏硬件设计的、有偏算法和软件设计的。如果不讲究答辩策略，可能会造成“做的好，不如讲得好”的结局，从而影响答辩成绩。我的建议（15分钟左右）如下：
1、课题概述（2-3分钟）:阐述为什么要开展这项研究，即立项依据和国内外研究现状介绍。主要介绍课题来源、研究背景、现状及存在问题等，从而引出论文研究目的、研究内容及解决的主要问题。——回答“为什么要做？”
2、课题内容（8-10分种）:主要突出：1）解决问题的思路和采取的措施；2）实验结果展示及分析。文字描述多了，会影响讲解思路，也会给人不熟悉内容的印象；公式推导多了，这不是答辩老师所感兴趣的（感兴趣的评委自然会看你的纸质论文）。同时，可能占用了后续展示主要成果的时间，让评委看不到你最后的“干货”。——回答“怎么做的?”
3、课题总结（1-2分钟）:1）直接以按序号形式列出所开展的工作；2）创新点与贡献，即提出了什么方法或理论？解决了什么问题？实现了什么功能？有创新的强调创新，无创新的强调工程应用价值。课题展望或存在问题可一带而过，如果评委需要追问，后续回答问题时阐述即可。——回答“做到了什么程度？”
4、成果展示：如论文、专利、获奖等。
以上主要为答辩生汇报过程的问题与建议。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3623f0d67c760322a3e8df07f0e77718/" rel="bookmark">
			HTML超文本标记语言常用的一些标签
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在之前的学习中了解到了xml是可扩展型标记语言，所以html和xml有相似之处，html是可以在网络上传输的超文本标记语言，所以xml的所有要求对于html同样适用，单双标签，子标签，属性，之类的html也都有。超级文本标记语言是标准通用标记语言下的一个应用，也是一种规范，一种标准。
超文本标记语言 超文本标记语言
它通过标记符号来标记要显示的网页中的各个部分。网页文件本身是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容（如：文字如何处理，画面如何安排，图片如何显示等）。浏览器按顺序阅读网页文件，然后根据标记符解释和显示其标记的内容，对书写出错的标记将不指出其错误，且不停止其解释执行过程，编制者只能通过显示效果来分析出错原因和出错部位。但需要注意的是，对于不同的浏览器，对同一标记符可能会有不完全相同的解释，因而可能会有不同的显示效果。 语言特点 超级文本标记语言文档制作不是很复杂，但功能强大，支持不同数据格式的文件镶入，这也是万维网（WWW）盛行的原因之一，其主要特点如下： 简易性：超级文本标记语言版本升级采用超集方式，从而更加灵活方便。 可扩展性：超级文本标记语言的广泛应用带来了加强功能，增加标识符等要求，超级文本标记语言采取子类元素的方式，为系统扩展带来保证。 平台无关性：虽然个人计算机大行其道，但使用MAC等其他机器的大有人在，超级文本标记语言可以使用在广泛的平台上，这也是万维网（WWW）盛行的另一个原因。 通用性：另外，HTML是网络的通用语言,一种简单、通用的全置标记语言。它允许网页制作人建立文本与图片相结合的复杂页面，这些页面可以被网上任何其他人浏览到，无论使用的是什么类型的电脑或浏览器。 元素 &lt;html&gt;&lt;/html&gt; 创建一个超文本标记语言文档。 &lt;head&gt;&lt;/head&gt; （头）设置文档标题和其它在网页中不显示的信息，比如direction方向、语言代码Language Code（见实体定义!ENTITY % i18n）、指定字典中的元信息、等等。 &lt;BASE&gt; 文档中不能被该站点辨识的其它所有链接源的URL（统一资源定位器） &lt;LINK&gt; 定义一个链接和源之间的相互关系，比如引用一个层叠样式表（英文缩写：css）、做一个链接到一个脚本、为某文件做一个链接（可打印的版本）、文档特定的工具栏/菜单。 &lt;script&gt;&lt;/script&gt;脚本语句标签，比如引用一个javascript脚本。 &lt;body&gt;&lt;/body&gt;文档体，文档的可见部分。 &lt;title&gt;&lt;/title&gt; 设置文档的标题。 当然，如果不使用以上基本框架结构，而直接使用在实体部分中出现的标记符，在浏览器下也可以解释执行。 内容描述 &lt;h1&gt;&lt;/h1&gt; 最大的标题（一号标题） &lt;pre&gt;&lt;/pre&gt; 预先格式化文本 （英文全称：PREformatted） &lt;u&gt;&lt;/u&gt; 下划线（英文全称：Underline） &lt;b&gt;&lt;/b&gt; 黑体字 （英文全称：Bold） &lt;i&gt;&lt;/i&gt; 斜体字 （英文全称：Italics） &lt;tt&gt;&lt;/tt&gt;打字机风格的字体 &lt;cite&gt;&lt;/cite&gt;引用，通常是斜体 &lt;em&gt;&lt;/em&gt; 强调文本（通常是斜体加黑体、英文全称：EMphasize） &lt;strong&gt;&lt;/strong&gt; 加重文本（通常是斜体加黑体） &lt;font size="" color=""&gt;&lt;/font&gt; 设置字体大小从1到7，颜色使用名字或RGB（中文全称：红绿蓝）的十六进制值 &lt;BASEFONT&gt;&lt;/BASEFONT&gt;基准字体标记 &lt;big&gt;&lt;/big&gt; 字体加大 &lt;SMALL&gt;&lt;/SMALL&gt; 字体缩小 &lt;DELECT&gt;&lt;/DELECT&gt; 加删除线 &lt;CODE&gt;&lt;/CODE&gt;程式码 &lt;KBD&gt;&lt;/KBD&gt;键盘字（英文全称：KeyBoarD） &lt;SAMP&gt;&lt;/SAMP&gt; 范例（英文全称：SAMPle） &lt;VAR&gt;&lt;/VAR&gt; 变量（英文全称：VARiable） &lt;BLOCKQUOTE&gt;&lt;/BLOCKQUOTE&gt; 向右缩排（向右缩进、块引用） &lt;DFN&gt;&lt;/DFN&gt; 述语定义（英文全称：DeFiNe） &lt;ADDRESS&gt;&lt;/ADDRESS&gt;地址标记 &lt;sup&gt;&lt;/SUP&gt; 上标字 （英文全称：SUPerscript） &lt;SUB&gt;&lt;/SUB&gt; 下标字（英文全称：SUBscript） &lt;xmp&gt;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3623f0d67c760322a3e8df07f0e77718/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/355386c99d1284865e2d65a6b63eb543/" rel="bookmark">
			亚信实习记录。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：我是一名准大四的计算机专业学生。在大三下学期快结束的时候，为了给家里一个交代，跟着很多同学一样加入了找实习的队伍。而亚信这个时候恰好来了我们学校做宣讲会，可能是由于亚信与我们学校有协议(固定名额)，通过宣讲会后的简单群面后，我进入了亚信实习。
写这篇博客的原因：
当时收到offer后，很纠结接不接受亚信的offer，所以百度了很多相关"亚信""实习"等字眼。不过我当时看见的相关评论，比如百度知道和知乎的。很多都是负面的信息。而我在csdn上看见了一篇"在亚信实习的日子"的博客，博客链接 记录了博主在亚信实习的每周的日子。记录的十分真实，也让我在进入亚信实习前有了一点了解。非常感激。
我写这篇博客的目的，是想把个人情况，以及进入公司前前后后的经历写出来。一方面是记录，顺便给后来人一些参考。
( 第一次写博客，有的地方可能比较啰嗦。。望谅解)
从上面我进入亚信实习的过程来看，我是很幸运的。我个人的水平其实很渣：上海普通一本计算机专业，就学了基本编程语言，学校这学期唯一开的java web我都没去上，其他专业课也都马马虎虎。懂的东西其实并不多。所以我在收到offer后，还是很心虚的！非常担心在这边做不了什么（并且在入职协议上还有一句：若乙方（实习生）完成不了任务，甲方有理由辞退）
但是后来来了亚信，发现我这些考虑都是多余的。大部分实习生都有一个入职流程，也就是培训。会培训一些javaweb及Linux，还有亚信做移动业务方面的知识。时长会有一个月左右（包括考核）
因为刚进公司马上就被经理要求写日报，所以我现在记录的基本根据日报+回忆来写，和前面的那篇博文一样，我也以周报的
形式来记录吧！
一：7.10-7.16： 7.10号入职，马上就被分配到了一个经理底下，人事叫我自己去另外一栋楼找经理。
然后经理安排了一个老员工来带我，就称他为刘组长吧！刘组长人很好，给我讲了团队正在做的事情，以及相关技术，软件什么的。
这周主要做的事情有：学习git，学习sonar配置，参加了第一次部门聚餐+会议，聚餐感觉很棒（公费），会议有很多听不懂，都是他们在讨论...
二：7.17-7.23： 这周才开始正式准备培训内容，内网，公司数据库，公司用的框架及配置数据库工具。并且这周二经理给我们公司的三个实习生布置了一个部门内的考核任务，就是用jdbc去查数据库。这个任务大概花了我一周的时间（数据量很大，几十万条数据），具体是去数据库用sql1查出sql2，在用sql2去查出最终需要的结果。并将最终结果进行比较。正好我java基础对这个了解一点，顺便问了一起来实习的同学，加上周末加班，最终顺利解决了。
三：7.24-7.30： 这周我才正式开始培训，理论上我们这批比以前的慢了一礼拜。
培训讲了demo（就是一个小型的增删改查的管理系统），数据模型（中国移动的相关数据表）开始使用我们部门做的开发-测试-运维管理平台，并且我跟着进入一个做"单元测试"的小组，又开了一次需求会议（全场聆听）
四：7.31-8.6： 这周继续培训，其他时间几乎全在做demo,因为要用公司的框架,不熟悉,做得比较慢，做了增删改查加一些小功能，并且听了刘组长给别的部门讲的课（关于GIT）
周四我们部门的三个实习生，被安排进了部门当前的任务中，都被布置了相关任务。（写后台接口）
但是周五的时候开了总结会，带我们的老员工说不用做了。。换任务了。。
ps:这周发工资了，非常高兴！第一笔自己挣的大款了。
五：8.7-8.13： 这周每天都开了站立会，对每天要做的任务进行分工，因为我比另外两个实习生进来晚一些，他们做任务更熟悉。。我倒是不怎么了解，还在配环境中。（IDEA工具）
并且这周进行了入职引导（本应该一个月前就有的T-T） 培训在这周也完结了，陆续开始了培训的考核，其中demo和后台进程是要写代码，另外两门关于移动内容的是笔试（考核比较松，不严格）
六：8.14-8.20： 这周我继续在准备考核事宜，所以很少接任务来做，一般都是把项目代码拉下来，自己看看同事写的。 周三晚上单元测试又开了一个会，我被导师安排去写一个报告（但是这个报告后来又不用了。。。）后续对单元测试做了总结，明确了要做什么，该怎么做。我也被分配到了相关任务：写后台接口，实际上就是做查询功能。将数据库的表信息展示到前台（前台专门有妹子做，我只用写后台接口） 第一次接任务，十分激动，一边模仿之前的，一边问老员工，最终终于完成了。（调试的时候是前台连我的IP来测试，好牛逼）
七：8.21-8.27 上次做了查询功能，这周做了删除功能，并且这次是我做的前台（现在部门很缺做前台的），前台代码（JS）之前几乎没学过，感觉写起来很吃力！不过很高兴功能还是完成了。并且在页面上做了很多功能测试，进行了很多后台代码的修改。
刘组长给我们分享了他上周参加devops峰会的收获！又了解了很多知识。
这周总算把培训的最后一项：demo考完了！至此培训内容圆满结束！（我应该都顺利通过了，很开心）
八：8.28-9.3 这周前两天又是对之前写的页面进行增增补补，我做了“新增”功能。然后后三天算是最轻松的三天了。。都没什么事情做，每天都自己在网上看一些资料。。。
现在我坐在两个老员工中间，一个是做架构的大牛，一个是我导师，都很厉害！（吓- -）
九：9.4-9.8 这周是入职来最轻松的一周了！因为要开始做新项目了，正在需求确定阶段，功能未完全确定，我们实习生都没什么事做（老员工做的老项目我们不怎么了解）。
这几天我都在一个叫做 freeCodeCamp的网站上学习前台知识，网站链接 里面的内容很详细，如图：
我已经在上面学习了几十个小时的课程了，包括html.css,bootstrap,jQuery,基础JS和json。
底下是补充的地方：
工作环境还不错，但是加班挺多的，基本上每个老员工都加班。。实习生也是六点多才走（有的时候也加班七八点，好像我另外两个一起来的同学，他们部门有时候让他们加班到9点。。。） 加班到9点有30补贴。
当初我们学校一起来的还有3个做测试的妹子。。现在都走了俩了。。说是太累。。
我所在的部门因为不是做移动业务的，是做一些工具、网站的部门，所以我感觉我们部门能学到的东西还不少！平时用的react+spring boot
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76188e3fa1461148d71449c46c41c6a6/" rel="bookmark">
			kaggle 邮箱验证的时候提示 You did not enter the correct captcha response. Please try again
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		听一个朋友说的kaggle这个东西，打算借此好好学习一下，注册的时候邮箱验证总显示
You did not enter the correct captcha response. Please try again 没有输入正确的验证码是什么鬼，老子根本没输验证码好么。。。 后来发现这个验证码是用google提供的api，google被和谐了，所以加载不出来……翻个墙就能出来验证信息了，唉
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be5cf8a385d3d9e7771167e85bd75976/" rel="bookmark">
			操作系统：CPU调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前面我们已经总结了process的一些基本信息，进程是程序运行的一个基本单位。当进程运行的时候，需要占用CPU，如果当多个进程需要运行的时候，我们该怎么安排这些进程占用CPU呢？ 这就是我今天要总结的CPU调度了
在正式讨论CPU调度策略之前，我们先来看看CPU调度我们会考虑哪几个方面的因素：
turnaround时间（周转时间）：任务完成时间 - 任务到达时间响应时间：任务开始运行时间 - 任务到达时间公平性整体性能 在介绍每一种CPU调度策略之后，我会从这四个方面来分析调度策略的优点和缺点；
FIFO（First In， First Out） 多个任务都需要使用CPU这个场景很像在路边小吃摊排队的场景，自然而然可以想到谁先来，谁就先被服务。这就是所谓First In， First Out; 也叫First come， First served. 这种调度策略实现起来相对简单，但在某些方面表现却不是十分友好：
假设有三个任务A、B、C同时到达（at time 0）,需要运行的时间为1000ms，20ms，20ms。这个时候先执行A，再执行任务B，最后执行任务C； 在这种情况下，任务B和C各自只是用CPU时间20ms，却要等上1000ms。一旦先来运行的是个耗时比较长的任务，那后面到来耗时短的任务需要等待很长时间才能上CPU运行；这种策略对耗时较短任务不友好 那我们改变现有的策略，让耗时短的任务先运行，看看怎么样。
短作业优先（shortest job first） 在这种模式先，在上面描述的场景就可以完美解决了：任务B和C先被执行，最后完成任务A；这种情况下符合我们预期；但修改一些任务到达的条件，又是怎么样呢？
假设任务A、B、C耗时分别是1000ms, 20ms, 20ms, 但A先到达，B和C在A到达10ms之后到达； 这种情况下，又出现了如FIFO中描述的问题，B和C依旧需要等待990ms、1010ms的时间才能运行； 这个时候就考虑能不能让耗时短的任务抢占CPU呢？（抢占CPU需要消耗资源），于是乎有了Shortest Time-to-Completion First（STCF）
抢占式短作业优先（Shortest Time-to-Completion First） 对于上面描述的场景，在这种场景下，任务B上来就可以运行，任务C等待20ms可以运行，然后任务A继续接着运行（没有考虑上下文切换耗时）。如果仅仅考虑turnaround time，现在的这种方法已经足够了；
但如果考虑每个任务的响应时间呢？ 以上的三种调度策略都需要等待某个任务完成，才能开始运行，这样会导致任务的平均响应时间变大，那么有没有方式，使任务的平均响应时间变短呢？这就是想到Round Robin策略了
Round Robin 在这种策略下，不再是把任务运行完之后再运行下一个任务，取而代之的是每个任务轮流在CPU上运行一个时间片。 这样的好处是，在任务到达之后，等待几个较短的时间片之后，新来的任务就可以开始运行了。这样降低了任务的响应时间。
一下两点值得我们注意：
Round Robin策略对每个任务来说都是公平的，同时降低了任务的响应时间，但与此同时确是增加了平均的turnaround time却是增加的。这是trade-off，具体选用那种策略，在于我们更关注哪个方面的表现实现RR策略，每一个时间片用完，都需要进行上下文切换的。进行上下文切换的消耗会均摊到所有执行的任务上 我们知道，内核的进程比用户进程优先级高；对于同样的内核进程和同样的用户进程，他们也有优先级区别，在CPU调度上，我们如何体现出任务的优先级呢？
多级反馈队列Multi-Level Feedback Queue 为了RR调度策略的turnaround time和降低交互任务的响应时间，于是就有了多级反馈队列调度策略；操作系统的大多使用该算法进行CPU调度； 对于上面的多级反馈队列的数据结构的简单示例，从下到上优先级依次增加。 在这个多级反馈队列中，调度过程需要遵循如下有如下几条规则：
如果任务A的优先级大于任务C的优先级，则先运行任务A任务A和B优先级一样，则任务A、B以Round Robin的方式运行当有新任务到来的时候，进入优先级最高的队列一旦一个任务用完了时间片或者因为I/O放弃了CPU，则将该任务移到下一个优先级队列固定周期之后，把所有的任务都迁移到优先级最高的队列中去 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7106eba4f78c294a4a81626d0f6ecaf4/" rel="bookmark">
			操作系统：进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程 简单来说，进程就是运行的程序，有生命周期。
进程的API Create: 创建进程Destroy：结束进程Wait：等待进程结束Miscellaneous Control：挂起进程或者重启进程Status：查看进程状态，运行时间，运行状态 创建进程的时候，操作系统需要完成下面几件事：
从disk将code和static data载入到memory中为进程分配stack空间和heap空间初始化其他资源，I/O从main函数开始执行程序 进程状态 running（运行）： 在处理器上运行ready（就绪）：进程准备好了，但处理器没有选择进程运行Blocked（阻塞）：请求其他资源，比如文件访问、I/O等 对于上图，可以总结出以下几条规律：
1.进程可以从running状态到ready状态，下CPU（时间片用完，或者被抢占） 2. 进程可以从ready状态到running状态，上CPU 3. 进程可以从running到达blocked状态，请求资源，例如I/O 4. 进程可以从blocked到ready状态，请求资源已就位 进程与操作系统交互 前面介绍了进程的一些概念，并且提到了在创建进程时，操作系统会做的一系列工作，那么我们从下图看看进程运行的整个生命期，操作系统参与了哪些环节： 上图显示很简单，如果程序需要进行I/O操作呢，程序和操作系统的交互又会是怎么样呢？
值得注意的是当程序在执行的时候，需要进行系统调用如I/O操作或者被系统中断时，程序会trapped into OS，在保存好进程的上下文环境之后，程序的执行权就交给了操作系统。此外，程序的主导权由进程变更到操作系统的时候，需要上下文切换，进程之间的切换也需要上下文切换。 简单点来说，上下文切换需要保存进程的的相关信息。
参考文献： http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-intro.pdf http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-api.pdf
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd637cc46b1dbf56c07270bd0d54399/" rel="bookmark">
			Linux下源码编译安装详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 源码要运行，必须先转成二进制的机器码。这是编译器的任务。
比如，下面这段源码（假定文件名叫做test.c）。
#include &lt;stdio.h&gt; int main(void) { fputs("Hello, world!\n", stdout); return 0; } 要先用编译器处理一下，才能运行。
$ gcc test.c $ ./a.out Hello, world! 对于复杂的项目，编译过程还必须分成三步。
$ ./configure $ make $ make install 编译过程流程图：
一.编译的具体过程 1. 配置（configure） 编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做"配置"（configure）。
这些配置信息保存在一个配置文件之中，约定俗成是一个叫做configure的脚本文件。通常它是由autoconf工具生成的。编译器通过运行这个脚本，获知编译参数。
configure脚本已经尽量考虑到不同系统的差异，并且对各种编译参数给出了默认值。如果用户的系统环境比较特别，或者有一些特定的需求，就需要手动向configure脚本提供编译参数。
$ ./configure --prefix=/www --with-mysql 上面代码是php源码的一种编译配置，用户指定安装后的文件保存在www目录，并且编译时加入mysql模块的支持。
2. 确定标准库和头文件的位置 源码肯定会用到标准库函数（standard library）和头文件（header）。它们可以存放在系统的任意目录中，编译器实际上没办法自动检测它们的位置，只有通过配置文件才能知道。
编译的第二步，就是从配置文件中知道标准库和头文件的位置。一般来说，配置文件会给出一个清单，列出几个具体的目录。等到编译时，编译器就按顺序到这几个目录中，寻找目标。
3. 确定依赖关系 对于大型项目来说，源码文件之间往往存在依赖关系，编译器需要确定编译的先后顺序。假定A文件依赖于B文件，编译器应该保证做到下面两点。
（1）只有在B文件编译完成后，才开始编译A文件。 （2）当B文件发生变化时，A文件会被重新编译。 编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。而makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。
在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。
4. 头文件的预编译（precompilation） 不同的源码文件，可能引用同一个头文件（比如stdio.h）。编译的时候，头文件也必须一起编译。为了节省时间，编译器会在编译源码之前，先编译头文件。这保证了头文件只需编译一次，不必每次用到的时候，都重新编译了。
不过，并不是头文件的所有内容，都会被预编译。用来声明宏的#define命令，就不会被预编译。
5. 预处理（Preprocessing） 预编译完成后，编译器就开始替换掉源码中bash的头文件和宏。以本文开头的那段源码为例，它包含头文件stdio.h，替换后的样子如下。
extern int fputs(const char *, FILE *); extern FILE *stdout; int main(void) { fputs("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd637cc46b1dbf56c07270bd0d54399/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8249875fc7473d58fe494be8c471d94/" rel="bookmark">
			如何获取combobox显示的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ComboBox1.Text;
ComboBox1.Items.Strings[ComboBox1.ItemIndex];//ComboBox1.ItemIndex&gt;=0的时候才能用
转载于:https://www.cnblogs.com/Little-Star/p/7485295.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c32c607e1125650498717ca1f4fdf6/" rel="bookmark">
			java 常用的数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. java 常用的数据结构: JSONObject HashMapJSONArray 三者之间的区别，分别在什么场景下适用: 1.1 JSONObject #1. 基本用法 JSONObject obj = new JSONObject(); obj.put("key",object); obj.get("key"); obj.getString("key"); #2. 遍历key --&gt; 转换成HashMap JSONObject obj = new JSONObject(); Map&lt;String,Object&gt; resMap = new HashMap&lt;String,Object&gt;(); Set&lt;String&gt; keySet = obj.keySet(); for (String key : keySet) { resMap.put(key, obj.get(key)); } 1.2 JSONArray JSONArray array = new JSONArray(); jSONObject json = new JSONObject(); array.add(json); #JSONArray 数据格式 [{"id":121266001,"text":"众筹(121266001)"},{"id":120886001,"text":"公益(120886001)"},{"id":98,"text":"包装(98)"},{"id":120950002,"text":"天猫点券(120950002)"}] 1.3 HashMap Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put("key",Object); map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22c32c607e1125650498717ca1f4fdf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d29fea60fac5e2e2db5f64a67e9dc9/" rel="bookmark">
			HDU 6184 Counting Stars（无向图三元环计数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Counting Stars
Time Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 459 Accepted Submission(s): 115
Problem Description Little A is an astronomy lover, and he has found that the sky was so beautiful!
So he is counting stars now!
There are n stars in the sky, and little A has connected them by m non-directional edges.
It is guranteed that no edges connect one star with itself, and every two edges connect different pairs of stars.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d29fea60fac5e2e2db5f64a67e9dc9/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/526/">«</a>
	<span class="pagination__item pagination__item--current">527/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/528/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>