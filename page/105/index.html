<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2584fea4b3715246ea911507e4635e6f/" rel="bookmark">
			pre/post gate sim 仿真笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在芯片研发阶段至少存在三种仿真，只有在这三种仿真都通过后才可能进入到芯片的tape out阶段，这三种仿真分别是rtl 功能级仿真、综合后网表仿真（pre gate sim）、PR后网表仿真（post gate sim）。下面简单记录一下两种gate sim仿真，后期有补充再做添加，发现错误再做修改。
不论是pre还是post的gate sim都是门级网表的仿真，进行门级仿真主要有两个目的：1 检查门级网表的功能是否符合设计意图；2 将门级网表的仿真波形用于功耗分析。
这里建议进行门级仿真的case由代码设计者或者算法设计人员提供场景，原因是他们十分清楚什么样的场景能充分得到可与目标功耗具有比较意义的功耗数据；同时也建议做门级仿真的人员最好是验证人员，因为门级仿真的环境是在功能仿真的环境上进行修改得到的，验证的人员更熟悉验证环境，同时需要门级功耗数据时已经进行到研发时间紧迫的阶段，这样能减少门级仿真所花费的时间，提升功耗决策效率，而且验证人员也更熟悉每支case如何确认波形的正确性，避免功耗的输入波形有误，造成决策失误，从而影响项目进程。
1 pre gate sim
前门级仿真使用综合后的网表进行的，一般综合时会在ss corner下完成，而用于功耗分析的前门级仿真会在tt corner下进行，因此在用vcs仿真时需要设置+nospecify+notimingcheck，即使加了反标sdf的语句：-sdf min:tb_top.u_asic_top:$(pre_sdf)，也是需要设置+nospecify+notimingcheck。
pre gate sim是没有路径延时的，但存在cell内部的延时。如果pre gate sim仿真是使用的tt corner，而网表使用的是ss corner，则在pre gate sim仿真时会出现时序违例，仿真错误的情况，因此需要+nospecify和+notimingcheck。
为什么在做功耗分析时使用tt corner请看如下网址：一问 | 为什么power 只需要在typical corner 做sign off？ (qq.com)
关于tt corner、ss corner可以参看如下链接：
Corner芯片TT,FF,SS_tt corner_别想太多的博客-CSDN博客
在使用VCS仿真时使用的参数设置可参考如下网址：
仿真条件+nospecify　+notimingcheck　+delay_mode_zero的区别_no specify_风起云涌66的博客-CSDN博客
2 post gate sim
post gate sim是对在PR之后的网表和sdf进行功耗分析，在PR之后已经添加了完整的路径延时且不论是在SS还是TT corner下都应该能满足时序要求实现芯片功能，因此在进行gate sim仿真时不能使用nospecify和notimingcheck，需要把所有的时序都反标上去，这样才能尽最大限度的模拟真实芯片工作时的情况（如不同信号的延时导致毛刺的产生，导致功耗增大）。
在进行post gate sim时会出现某个或者某些寄存的初始值为x，由于X的传播导致post gate sim无法正常仿真下去；同样某些memory也存在未初始化最开始的输出为X，由于X传播导致仿真不能继续。因此需要在进行仿真时需要将它们进行初始化，初始化这里用config_file.txt文件。
config_file.txt文件里的内容格式如下所示
defaultvalue x
tree tb_top.asic_top.u_module_a 0 random
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2584fea4b3715246ea911507e4635e6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09469b003c7456ef6ca1dadada03262/" rel="bookmark">
			王佩丰Excel24讲_第9讲：countif函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、countif函数1.函数语法（1）count函数（2）countif函数 2.计算数值区间3.如何解决超过15位字符时的错误 二、常见应用示例1.在数据区域中查找重复数据2.在数据有效性中使用countif函数3.在条件格式中使用countif函数 三、 2007及以上版本中的countifs函数在这里插入图片描述 系列文章目录 一、countif函数 1.函数语法 （1）count函数 count(值1,值2,…)
返回包含数字的单元格以及参数列表中的数字的个数
（2）countif函数 countif(range,criteria) countif(区域,条件) 计算区域中满足给定条件的单元格的个数
2.计算数值区间 计算参加考试数 仅仅计算次数，用count()函数即可
设置单元格格式为“常规”
计算及格数
有条件的计算次数，需要用到countif()函数
注：countif()中条件需要加英文状态下的双引号
3.如何解决超过15位字符时的错误 计算相同银行卡号数量1
如果直接用count()计算相同银行卡号数量，因为银行卡号超过15位，发现结果有为2的（应该都为1才对）；因此需要借助*通配符，即：
计算相同银行卡号数量2
由上图可知，countif()函数中的区域应当是不变的，因此使用绝对引用 可以用*代替超过15位字符部分
二、常见应用示例 1.在数据区域中查找重复数据 找出未体检过的人员名单 若未体检过的为0，否则为体检过的
可以结合if函数写的更清楚些，即：
用颜色格式标识出未体检过的名单
点击“条件格式”-“新建规则”，选择“使用公式确定要设置格式的单元格”，规则“=countif($ G:$ G,$ A2)=0”，设置颜色为“红色”，即未参加体检的会标为红色。
2.在数据有效性中使用countif函数 问题1：将C列设置为禁止输入重复数据
点击“数据”-“数据有效性”，允许“自定义”，公式“=COUNTIF(C:C,C2)&lt;2”
问题2：将D2:I20设置为禁止输入重复数据 在左上角的单元格中输入“D2:I20”，便可自动选择该区域，点击“数据”-“数据有效性”，允许“自定义”，公式“=countif($ D$ 2:$ I$20,D2)&lt;2”
3.在条件格式中使用countif函数 将重复数据标记为红色背景 三、 2007及以上版本中的countifs函数 countifs(ceiteria_range1,criterial1,[ceiteria_range21,criterial3]…) countifs(区域1,条件1,区域2,条件2…) 计算多个区域中满足给定条件的单元格的个数
系列文章目录 第1讲：excel常用的基础操作 第2讲：excel单元格格式设置 第3讲：查找、替换、定位
第4讲：排序与筛选 第5讲：分类汇总、数据有效性 第6讲：数据透视表 第7讲：excel常用函数与公式 第8讲：if函数 第9讲：countif函数 第10讲：sumif函数 第11讲：vlookup函数 第12讲：match+index函数 第14讲：日期函数 第15讲：条件格式与公式 第16讲：简单文本函数 第17讲：数学函数 第18讲：lookup和数组 第19讲：indirect函数 第20讲：图表基础 第21讲：经典excel动态图表实现原理 第22讲：制作甘特图与动态甘特图 第23讲：双坐标柱形图、饼图美化与ppt图表 第24讲：宏表函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b28eae5fbaf1e8c90c0423d224f17a3e/" rel="bookmark">
			王佩丰Excel24讲_第8讲：if函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、if函数1.if函数的基本用法2.if函数的嵌套3.用if函数处理运算错误iserror函数 二、and函数与or函数1.and函数：表示“且”的关系2.or函数：表示“或”的关系在这里插入图片描述 系列文章目录 一、if函数 1.if函数的基本用法 函数语法：IF(logical_test,[value_if_true],[value_if_false]) 中文注释：IF(测试条件,真值,[假值])
举例 如果性别是男，则称呼为男士
如果性别是女，则称呼为女士
IF函数中，若参数为字符串，则需要用英文状态下的双引号""
2.if函数的嵌套 举例1 专业类后加专业代号： 理工 对号 LG 文科 对号 WK 财经 对号 CJ
举例2 加分政策：
本地学生 总分为原始分加 30 本省学生 总分为原始分加 20 外省学生 总分为原始分加 10
举例3 录取情况： 600分含600 显示 第一批 400-600分含400分 显示 第二批 400分以下 落榜
如何尽量回避IF函数的嵌套?
如果需要嵌套IF函数5层以上，要考虑用别的函数，如：vloop函数 3.用if函数处理运算错误iserror函数 作用：在工作表写函数时回避掉错误
ISERROR(值)
检测一个值是否为错误值，返回TRUE或FALSE
二、and函数与or函数 1.and函数：表示“且”的关系 AND(逻辑值1,逻辑值2,…)
在参数组中，任何一个参数逻辑值为FALSE，即返回FALSE；只有当所有参数值都为TRUE，才返回TRUE
举例：对于60岁以上（含）的男性员工给予1000元奖金
2.or函数：表示“或”的关系 OR(逻辑值1,逻辑值2,…)
在参数组中，任何一个参数逻辑值为TRUE，即返回TRUE；只有当所有参数值都为FALSE，才返回FALSE
举例：对于60岁以上或40岁以下的员工给予1000元奖金
综合使用：对于60岁以上的男员工或40岁以下的女员工给予1000元奖金
写IF函数前先理清思路很重要
系列文章目录 第1讲：excel常用的基础操作 第2讲：excel单元格格式设置 第3讲：查找、替换、定位
第4讲：排序与筛选 第5讲：分类汇总、数据有效性 第6讲：数据透视表 第7讲：excel常用函数与公式 第8讲：if函数 第9讲：countif函数 第10讲：sumif函数 第11讲：vlookup函数 第12讲：match+index函数 第14讲：日期函数 第15讲：条件格式与公式 第16讲：简单文本函数 第17讲：数学函数 第18讲：lookup和数组 第19讲：indirect函数 第20讲：图表基础 第21讲：经典excel动态图表实现原理 第22讲：制作甘特图与动态甘特图 第23讲：双坐标柱形图、饼图美化与ppt图表 第24讲：宏表函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d2767706c8c4057e5beca0cd4de0a23/" rel="bookmark">
			王佩丰Excel24讲_第7讲：excel常用函数与公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、excel常用公式1.运算符2.公式中的比较判断3.单元格引用 二、excel常用函数1.如何使用函数2.常用函数3.利用定位工具选择输入公式的位置（1）跳跃式求和（2）跨列求和 系列文章目录 一、excel常用公式 1.运算符 算术运算符
加减乘除： + - * / （一般针对数值）
excel中的加减乘除和数学中的加减乘除运算是一样的；
特别地，对于文本格式的数值，sum函数无法求和，但是将文本+0会变成数值，就可以进行sum求和了
连字符&amp; （一般针对文本）
文本适合左右相连，数值适合加减乘除
举例
源表
计算“利润”，利润=金额-成本
计算“单价”，单价=金额/数量
比较运算符
等于/大于/小于/大于等于/小于等于/不等于：=、 &gt;、 &lt;、 &gt;=、 &lt;=、 &lt;&gt;
2.公式中的比较判断 比较运算符的结果：TRUE/FALSE
源数据
举例：计算每个人的总分，规则是本地考生加30分
如果来源=“本地”，那么结果为真，TRUE在excel中代表说数字1，则F6=(D6=“本地”)*30+E6，接下来的数据向下拖拽即可。
F6后面的第一个等号不具有实际意义，只是表示后面内容不直接显示，而是显示运算后的结果
3.单元格引用 相对引用：A1
绝对引用：$A$1
举例
如下图中，E7、E8、E9属于相对引用（按照行或列递增），$B$7属于绝对引用（锁定单元格不变）
混合引用：$A1 A$1
举例：计算九九乘法表
B23需要向下递增，B列不变，即B23、B24、B25…，因此锁住B列；
C22需要向右递增，22不变，即C22、D22、E22…，因此锁住22行
分别向右向下拖拽
引用就是为了拖拽而服务的
二、excel常用函数 1.如何使用函数 等号开头，函数名在中间，括号结尾，括号中间写参数
= 函数名（参数1,参数2,…）
2.常用函数 SUM：求和
AVERAGE：求平均
MIN：求最小
MAX：求最大
COUNT与COUNTA：计数
RANK：排名
更详细的函数使用可参考：数据分析工作中excel最常用的八大函数
3.利用定位工具选择输入公式的位置 （1）跳跃式求和 手工选区域不方便（有些区域是4行数据，有些事5行，有些是6行...）
首先选中D2-D38，即所有需要计算求和的数据区域然后查找&gt;定位，选择”空值“最后点击“求和”按钮即可
（2）跨列求和 首先，选中数据区域任意一个单元格然后点击“查找-定位”，并选择“定位”，在反白区域输入J2/I2，按ctrl+enter键填充其他区域
系列文章目录 第1讲：excel常用的基础操作 第2讲：excel单元格格式设置 第3讲：查找、替换、定位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d2767706c8c4057e5beca0cd4de0a23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69416c100c9085ee32db6c730ab9c647/" rel="bookmark">
			王佩丰Excel24讲_第6讲：数据透视表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、创建数据透视表二、数据透视表中的组合1.日期组合2.文本组合3.数值组合 三、汇总多列数据四、在透视表中使用计算五、利用筛选字段自动创建工作表系列文章目录 一、创建数据透视表 源数据
每列是一个属性，代表一个字段；每行是一条记录目标表
按月统计各部门的发生额具体步骤
点击“插入”&gt;“数据透视表”&gt;“行：月”&gt;“列：部门”&gt;“值：发生额”
如何更改数据透视表汇总方式？
双击“求和项-发生额”，便可看到不同类型的“值字段汇总方式”，如下图：
二、数据透视表中的组合 1.日期组合 源数据
目标表
按“所属区域”和“订购日期”统计各“产品类别”的金额具体步骤 首先点击“插入”&gt;“数据透视表”&gt;“行：所属区域、订购日期”，发现“订购日期”是具体年/月/日，需要改成“季度”展示。选中“订购日期”数据中任意一个单元格，然后右键选中“组合”，步长改为“季度”展示。
然后选择“列：产品类别”&gt;“值：金额”
2.文本组合 文本本身需要做一些手工的组合，没有什么规律，比如各个“产品类别”之间没有什么客观的联系，这边不多赘述。
3.数值组合 按照金额本身划分一个区间
选中数字区域的任意一个单元格，“插入&gt;数据透视表”
然后将“金额”分别拖入“行”和“值”，即根据金额的分类统计金额本身；但是不希望金额分的如此详细，打算做下分类，随意选中“金额”任意一个数据，右键选择“组合”，为了便于分类，将起始改为0，终止改为320000，步长改为40000；由此便完成了一个数据区间的统计。
注意：有两种情况可能导致日期无法汇总：
1.日期中有空格
2.有一个或全部日期是文本格式
三、汇总多列数据 一列的数据从多个角度看
源数据
目标表
具体步骤
先将“员工姓名”和“工号”拖入行，但是发现不在一行，此时选中透视表中任意一个数据单元格，点击“报表布局-以表格形式显示”，即可实现多个行标签并列显示的效果。
再将“生产数量”拖入值中，分别改值字段汇总方式为“求和、平均值、最大值、最小设值”，字段名称可自己设置。
四、在透视表中使用计算 源数据
目标表
具体步骤
首先“插入-数据透视表”，将“规格型号”拖入行，“数量、合同金额、成本”分别拖入列
此时还差“利润率”字段，但是源表中别无这个数据，因此需要计算，点击“字段、项目”下的“计算字段”；输入名称是“合同金额”、公式=（合同金额-成本）/合同金额；由此利润率便计算出来了，并选中该列设置单元格格式为百分比，可是利润率中出现了#DIV/0！的报错，是因为分母为0了，对此可以勾选“数据透视表选项”的“格式-对于错误值，显示为空”即可。
五、利用筛选字段自动创建工作表 根据“科目划分”下的35个分类分别创建35张工作簿
源数据
目标表
具体步骤
插入&gt;数据透视表&gt;行：科目划分&gt;值：科目划分点击数据透视表中任意一个单元格，选中“选项-显示报表筛选页”，便可出现35张数据透视表，并且名字分别“科目划分”下的分类最后，选中这35张透视表，选择右键删除透视表中的文字和格式，即可变成35张空表
系列文章目录 第1讲：excel常用的基础操作 第2讲：excel单元格格式设置 第3讲：查找、替换、定位
第4讲：排序与筛选 第5讲：分类汇总、数据有效性 第6讲：数据透视表 第7讲：excel常用函数与公式 第8讲：if函数 第9讲：countif函数 第10讲：sumif函数 第11讲：vlookup函数 第12讲：match+index函数 第14讲：日期函数 第15讲：条件格式与公式 第16讲：简单文本函数 第17讲：数学函数 第18讲：lookup和数组 第19讲：indirect函数 第20讲：图表基础 第21讲：经典excel动态图表实现原理 第22讲：制作甘特图与动态甘特图 第23讲：双坐标柱形图、饼图美化与ppt图表 第24讲：宏表函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6b0425e20146fd65dd8dcf6c89f4d7/" rel="bookmark">
			王佩丰Excel24讲_第5讲：分类汇总、数据有效性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、分类汇总工具1.认识分类汇总2.使用分类汇总前先排序3.如何批量实现多维度数据的汇总4.将分类汇总后的结果复制到其他区域5.如何批量合并内容相同的单元格 二、设置数据有效性1.设置整数数据有效性2.设置文本长度数据有效性3.设置序列数据有效性（下拉框） 系列文章目录 一、分类汇总工具 1.认识分类汇总 按什么分类？汇总什么？怎么汇总？
2.使用分类汇总前先排序 分地区统计金额的总计
首先将“所属区域”进行排序，“升序”或者“降序”都可以，保证各个地区可以挨在一起（其实是做分类）。
然后选择“数据-分类汇总”：分类字段：所属区域；选定汇总项：金额；汇总方式：求和。
3.如何批量实现多维度数据的汇总 分地区与产品分类统计数量、金额、成本的总计
首先将“所属区域”与“产品类别”进行“自定义排序”，“升序”或者“降序”都可以，保证各个地区和各个产品类别可以挨在一起（其实是做分类）。
然后选择“数据-分类汇总”：先根据“所属区域”进行分类汇总，即分类字段：所属区域；选定汇总项：数量、金额、成本；汇总方式：求和。
再根据“产品类别”进行分类汇总，即分类字段：产品类别；选定汇总项：数量、金额、成本；汇总方式：求和。
4.将分类汇总后的结果复制到其他区域 当把“分类汇总后的结果”单独复制到一个工作表中时发现，会把表格全部内容粘贴到工作表中
此时，在粘贴所复制的分类汇总后的结果前，可以调用查找-定位，选择 “可见单元格”，然后发现选定区域会变灰，这时再粘贴就可以得到想要的内容了。
5.如何批量合并内容相同的单元格 首先将“所属区域”按照“升序或降序”进行排序，保证各个区域挨在一起
然后根据“所属区域”进行分类汇总，即分类区域：所属区域；选定汇总项：所属区域；汇总方式：求和。
最后从A2开始，选中一直到A44，再查找-定位（选择“空值”）
最后点击合并居中，并删除“分类汇总”，同时选中A2到A39格式刷B2到B39即可。
二、设置数据有效性 1.设置整数数据有效性 设置A列仅能输入500~1000之间的整数
选中A列，点击“数据-有效性”
选择允许：整数、数值：介于，最小值：500，最大值：1000
此时，发现输入600是可以的，输入300会报错。
不用的时候选择“全部清楚”数据有效性
2.设置文本长度数据有效性 设置B列仅能输入字符长度为8位的产品编码
同理，选中B列，点击“数据-有效性”，选择允许：文本长度、数据：等于，数值：8
此时发现输入8位数字是对的，输入9位会报错
3.设置序列数据有效性（下拉框） 设置C列付款方式中仅能输入现金、转账、支票
同理，选中C列，点击“数据-有效性”，选择允许：序列、来源：现金、转账、支票
注意：逗号必须是英文状态的此时发现会有选择框可进行选择，避免输入错误情况出现。
系列文章目录 第1讲：excel常用的基础操作 第2讲：excel单元格格式设置 第3讲：查找、替换、定位
第4讲：排序与筛选 第5讲：分类汇总、数据有效性 第6讲：数据透视表 第7讲：excel常用函数与公式 第8讲：if函数 第9讲：countif函数 第10讲：sumif函数 第11讲：vlookup函数 第12讲：match+index函数 第14讲：日期函数 第15讲：条件格式与公式 第16讲：简单文本函数 第17讲：数学函数 第18讲：lookup和数组 第19讲：indirect函数 第20讲：图表基础 第21讲：经典excel动态图表实现原理 第22讲：制作甘特图与动态甘特图 第23讲：双坐标柱形图、饼图美化与ppt图表 第24讲：宏表函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0566b9f9d6b5bb055efbd6f6449192eb/" rel="bookmark">
			王佩丰Excel24讲_第4讲：排序与筛选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、排序1.简单排序2.多条件排序3.按颜色排序4.自定义排序次序5.利用排序插入行 二、筛选1.在筛选中使用多个条件2.在高级筛选中使用常量条件区域（或/并）3.在高级筛选中筛选不重复值 系列文章目录 一、排序 1.简单排序 按照数学成绩降序排列
直接选中数学成绩分数中的任意一个单元格，然互开始-筛选-降序（就从数学最高分到最低分排列）
2.多条件排序 数学最重要，语文其次，英语再次。
只是随便选中一个单元格，然后开始-筛选-自定义排序
然后点击添加条件
添加了次要条件 数学-数值-降序语文-数值-降序英语-数值-降序
最后就排好序了
3.按颜色排序 颜色一样的怎么排序？
随便选中一个单元格，然后开始-筛选-自定义排序，主要关键字：ERPCO号；排序依据：单元格颜色；次序：红色-在顶端、黄色-在顶端，最后就可以实现按颜色排序了（红色在上，黄色在下）
excel自动排序的规则：字母和数字
4.自定义排序次序 按照“销售部门：一部、二部、三部…”排序
随便选中一个单元格，然后开始-筛选-自定义排序，主要关键字：销售部门；排序依据：数值；次序：自定义序列
自己可手动输入序列：一部、二部、三部…，然后点击“添加”，选中自己刚刚新添加的序列，并确定，最后按照“销售部门：一部、二部、三部…”排序。
5.利用排序插入行 制作工资条
这里共有11列数据，因此复制11行表头
在数据最后一列增加一列排序，然后按照升序排列即可。
可能会有多余表头，最后删掉即可。
二、筛选 1.在筛选中使用多个条件 筛选一车间的数据
筛选&gt;选中部门“一车间”
筛选发生额大于500的数据
筛选 &gt;清空条件&gt;选中“发生额”&gt;点击“数字筛选”&gt;大于&gt;发生额大于500
筛选一车间的邮寄费
筛选&gt;选中“部门:一车间”&gt;然后再选中“科目划分:邮寄费”
筛选所有车间的数据
筛选&gt;选中“部门”&gt;点击“文本筛选:包含”&gt;输入“车间”
2.在高级筛选中使用常量条件区域（或/并） 筛选出财务部或发生额大于3000的数据
手动输入条件“部门-财务部”，“发生额&gt;3000”，并错开分成两行，表示“或”的关系；若在一行表示“并”的关系。
然后筛选&gt;高级筛选&gt;条件区域选中手动输入的条件，然后便可得到结果
筛选出一车间或大于3000的二车间或发生额大于10000的数据
同理，手动输入条件，然后选中其为条件区域
注意：
1.条件区域必须带有表头，且表头要与原数据表头一模一样
2.两个条件在同一行里，那么就是且;不在同一行里就是或 3.在高级筛选中筛选不重复值 筛选&gt;高级筛选&gt;条件区域“空”、勾选不重复记录
系列文章目录 第1讲：excel常用的基础操作 第2讲：excel单元格格式设置 第3讲：查找、替换、定位
第4讲：排序与筛选 第5讲：分类汇总、数据有效性 第6讲：数据透视表 第7讲：excel常用函数与公式 第8讲：if函数 第9讲：countif函数 第10讲：sumif函数 第11讲：vlookup函数 第12讲：match+index函数 第14讲：日期函数 第15讲：条件格式与公式 第16讲：简单文本函数 第17讲：数学函数 第18讲：lookup和数组 第19讲：indirect函数 第20讲：图表基础 第21讲：经典excel动态图表实现原理 第22讲：制作甘特图与动态甘特图 第23讲：双坐标柱形图、饼图美化与ppt图表 第24讲：宏表函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90c237e6d73acc0a1f5dd50e90811591/" rel="bookmark">
			王佩丰Excel24讲_第3讲：查找、替换、定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、查找与替换1.按值查找2.模糊查找（1）*和?通配符（2）~通配符 二、定位工具1.通过名称框定位单元格及区域位置2.定位条件（1）为有批注的单元格设置红色填充色（2）为有公式的单元格设置红色填充色（3）填充解除单元格合并后遗留的空白单元格（4）批量删除图片 系列文章目录 一、查找与替换 任何文本和编辑类工具里都带有查找和替换的功能。
1.按值查找 替换"一车间"为"一部门"
首先点击开始-查找-替换选项，替换内容为：一车间，替换为：一部门，并勾选单元格匹配（这样可以保证只替换那些只有“一车间”这3个字的单元格）。
将“苏州”更改为“苏州市”
同理，将苏州更改为苏州市也是一样，需要勾选单元格匹配，就可以把苏州替换为苏州市，而不会把苏州市替换为苏州市市，只替换完全符合的选项。
2.模糊查找 （1）*和?通配符 *和?都是通配符：
（1）*在excel中指的是任意值 （就是任意一个东西，一或者多个字符）
（2）?(英文的半角问号）(问号只代表一个字符）
将姓张的员工都改为"经理的亲戚"
首先点击开始-查找-替换选项，替换内容为：张*，替换为：经理的亲戚，并勾选单元格匹配（这样可以保证只替换那些只有“张*”这几个字的单元格）。
将姓张并且名字为两个字的员工都改为"经理的亲戚"
首先点击开始-查找-替换选项，替换内容为：张?（?为英文状态下），替换为：经理的亲戚，并勾选单元格匹配（这样可以保证只替换那些只有“张?”这两个字的单元格）。
（2）~通配符 波浪线“~”的意思是使得后面的字符（一个字符）不生效。
仅将“张*”替换为"经理的亲戚"
首先点击开始-查找-替换选项，替换内容为：张~* （~为英文状态下），替换为：经理的亲戚，并勾选单元格匹配（这样可以保证只替换那些只有“张*”的单元格）。
若是仅将“张**”替换为"经理的亲戚"，则需多加一个“ ~ ”，将替换内容改为：张~* ~* 即可。
ctrl+f，查找的快捷键；ctrl+h，替换的快捷键
二、定位工具 1.通过名称框定位单元格及区域位置 参考王佩丰Excel24讲_第1讲：认识excel中的如何“快速选中很多行”一节
2.定位条件 （1）为有批注的单元格设置红色填充色 红色角标（批注），
选中单元格-鼠标右键-插入批注
显示或隐藏批注
审阅-显示所有批注
如何把有批注的单元格设置为红色的填充色？
查找-定位-批注-确定，这样把所有的有批注的单元格都定位了，然后直接填充颜色为红色就可以了。
（2）为有公式的单元格设置红色填充色 查找-定位-公式-确定，这样有公式的单元格就全部选中了，然后直接填充颜色为红色就可以了。
（3）填充解除单元格合并后遗留的空白单元格 在工作中，原本（内容中）带有合并单元格的表，你必须先取消掉合并，保证每一行中都带有内容，这样excel才能识别。
先选定一个区域，然后输入一个内容，然后按住ctrl，打回车。该区域内所有的单元格内都是这个内容。 如何根据表格内已有内容，把空单元格补满？
定位-空值，选定空单元格
选中表格数据区域
定位-空值，选择一个已选好的空单元格，输入“=”和键盘上下左右的上键，然后按住ctrl+enter回车，这样就填好了。
（4）批量删除图片 全部选中excel中的所有图片，然后按detele批量删除 定位-对象-确定
系列文章目录 第1讲：excel常用的基础操作 第2讲：excel单元格格式设置 第3讲：查找、替换、定位
第4讲：排序与筛选 第5讲：分类汇总、数据有效性 第6讲：数据透视表 第7讲：excel常用函数与公式 第8讲：if函数 第9讲：countif函数 第10讲：sumif函数 第11讲：vlookup函数 第12讲：match+index函数 第14讲：日期函数 第15讲：条件格式与公式 第16讲：简单文本函数 第17讲：数学函数 第18讲：lookup和数组 第19讲：indirect函数 第20讲：图表基础 第21讲：经典excel动态图表实现原理 第22讲：制作甘特图与动态甘特图 第23讲：双坐标柱形图、饼图美化与ppt图表 第24讲：宏表函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/246ebbc43df534cd4bbcca2131f4558e/" rel="bookmark">
			王佩丰Excel24讲_第2讲：excel单元格格式设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、使用单元格格式工具美化表格1.设置单元格格式（字体、边框、颜色）2.合并单元格3.表格中的斜线如何设置4.格式刷 二、单元格数字格式1.数字格式（数值—&gt;文本—&gt;数值）2.利用数字格式隐藏数据3.数字格式学习表 三、使用“分列”工具1.利用分列切割数据2.利用分列工具转化文本、数值、日期（文本—&gt;日期） 系列文章目录 一、使用单元格格式工具美化表格 1.设置单元格格式（字体、边框、颜色） 开始-对齐方式栏-点击右下小箭头，是指单元格格式的对话框就出来了。
也可以直接选中某个单元格，然后右键，再选择设置单元格格式
"对齐"选项卡：设置文字对齐方式
"边框"选项卡：设置单元格边框
"字体"选项卡：设置字体颜色
"填充"选项卡：设置单元格背景颜色
2.合并单元格 选中要合并的单元格，然后点击 开始-对齐方式栏-合并后居中。
表格的边框？
开始-字体栏-边框（图标在填充颜色的左边），比如选择所有框线
合并并居中下拉 跨越合并
随手选择一大块单元格，然后点击跨行合并，然后就可以看到这一大块中，每一行的都分别核定成了一个单元格，但是每列并没有合并。（即中间有横线，并不是一整块空白）
3.表格中的斜线如何设置 选中单元格，右键，点击设置单元格格式，然后，选择边框。
这里选中两行两列的单元格，然后随便选择边框线样式，然后因为单元格中有很多条线条，可以依据具体情况，点击，然后设置。
斜线？还是直接边框，然后点一下，就可以设置斜线了。
斜线上下的字怎么写进去的？
首先，双击单元格就可以写字了。
但是如果我想在下一行继续写呢？ 我就必须按住alt，敲击回车，然互就可以到达下一行。首先，在一个单元格中输入两行字。第一行输完了，然互按住alt，敲击回车，然后就可以输入第二行字了。然后设置斜线。然后再按回车，就出现了斜线上和斜线下两行字，然后选择左对齐，然后自己调整字的位置，做到美观。
4.格式刷 点击格式刷，然后把某个格式刷一下，然后再选择一块数据，就会自动粑之前的格式刷过去。（选中-格式刷-再选中）很多地方要刷，先选中想要刷的格式，然后，双击格式刷，然后就可以随便刷了。不想刷了，就按esc键，然后鼠标就恢复正常了。
二、单元格数字格式 1.数字格式（数值—&gt;文本—&gt;数值） 在excel当中，会去掉无意义的数字格式。比如，输入2400.00，会直接省略成2400，输入007，会变成7。设置单元格格式-数字-数值-小数数位，可以自己设置；千分位分隔符，就是千位数字之后的逗号。
点击数字-货币，可以添加货币符号；如果是负数，还可以选择要不要变成红颜色的。
数字-会计专用，会计专用这种格式，他的货币符号是在单元格最左侧的。（而货币格式下，货币符号是在数字前面，贴着数字的）
数字是0的情况下，会计专用会显示为横线，而货币会显示为0。
数字-日期，excel的日期系统，微软采用了1900纪年方式，比如数字1就是1900年1月1日。所以以此类推，1000就是1902年9月26日。
所以当输入今天的日期，2023年6月8日，我们点击设置单元格格式-数字-常规，2023.6.8就会变成45085。
数字-时间，我们打数字1，然后改成时间，就会显示0：00；1.5，就显示12:00.；2，也是0:00。
数字-科学计数，10000，变为1.00E+04，意思是10的4次方
数字-特殊，邮政编码、中文小写数字、中文大写数字
数字-自定义，数值永远是数值，只是显示格式变了，复制的话，最后粘贴出来的还是原本的数值。自定义，y是年，m是月，d是日；mmm表示英文月份缩写，mmm表示英文月份全写。aaa显示为一二三四五六日，aaaa显示为星期一星期二星期三，周aaa显示为周一周二周三……
文本和其他格式不通用
在excel 中，数字分为两类：表示大小和多少的含义；不表示大小和多少。
在excel中写身份证号不能直接写（因为身份证号有18位，而excel只能精确到15位，所以回车之后，后四位就会变成0000），需要提前告诉excel要输入的内容并不是一个表示大小或者多少的概念，而是一个所有数字都要意义的一个编码，所以怎么做呢？
选中要输入身份证号的一列，然后设置单元格格式-数字-文本。这样就不会自动变成科学计数，也不会使得后四位变为0000。（即输入什么就是什么，excel不会擅自删改内容）
但是文本格式之后，再也无法通过“设置单元格格式”改为常规样式。所以，文本格式不能随便改变。如果一组数字是文本格式，那么这组数字不能运算。但是仍然可以把它改为数字。选中文本格式的数字，然后这时，这些文本格式数字的左上角会出现黄色菱形感叹号，点击这个感叹号，然后，选择“转换为数字”。那么就转换为数字了。
如果数字太多，看不出谁是文本，谁是数字，直接随便找个单元格写“1”，右键-复制，并选择表中数字区域，然后右键-选择性粘贴-乘，这样所有的文本格式数字，就会被强制转化为数字格式。
2.利用数字格式隐藏数据 如果想要隐藏数据，可以利用数字-自定义-;;;
3.数字格式学习表 三、使用“分列”工具 1.利用分列切割数据 怎么把txt文件直接拷进excel
首先复制txt，然后直接选中A1单元格，然后直接把内容复制进去。但是发现很乱，而且所有的表格内容全都在A列的各行里。
此时我们选中整个A列，点击开始菜单里的数据，点击数据工具栏的分列；就会出现使用分隔符号或者固定宽度分，看情况，但一般是选择用分隔符号分；最后就去选择用什么分隔符号分。
excel中提到的符号都是半角英文符号；如果要按照中文符号分，选择‘其他’，然后输入相应的中文符号。
继而对“ERPCO号”进行分列
这里选了“常规”，会丢失数据，因此可以选择“文本”
2.利用分列工具转化文本、数值、日期（文本—&gt;日期） 有些情况下，日期是文本格式，跟文本格式的数字不同，不能通过黄色叹号转变。这时要把它改为常规样式，只要选中这些文本格式的日期，然后数据-分列，然后直接点击“完成”。这样这些文本格式的日期，就可以直接变成常规格式。
比如：想将日期改成“年-月-日”样式，但因为是文本样式，所以没有改成功；因此可以利用分列工具转化文本、数值、日期
系列文章目录 第1讲：excel常用的基础操作 第2讲：excel单元格格式设置 第3讲：查找、替换、定位
第4讲：排序与筛选 第5讲：分类汇总、数据有效性 第6讲：数据透视表 第7讲：excel常用函数与公式 第8讲：if函数 第9讲：countif函数 第10讲：sumif函数 第11讲：vlookup函数 第12讲：match+index函数 第14讲：日期函数 第15讲：条件格式与公式 第16讲：简单文本函数 第17讲：数学函数 第18讲：lookup和数组 第19讲：indirect函数 第20讲：图表基础 第21讲：经典excel动态图表实现原理 第22讲：制作甘特图与动态甘特图 第23讲：双坐标柱形图、饼图美化与ppt图表 第24讲：宏表函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0f83e785b10bb11051c238757f44c48/" rel="bookmark">
			王佩丰Excel24讲_第1讲：excel常用的基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、excel简介1. excel能做些什么2. excel界面包括什么 二、excel常用的基础操作1. 新建工作表、更改工作表的标签颜色、插入/删除多个工作表2. 插入行/列，插入多个行或列、移动行或列3. 调整行高列宽4. 单元格选取、整行整列选取、数据区域选取5. 如何快速选中很多行 三、excel小工具：冻结窗格、填充柄1. 冻结窗格2. 填充柄 系列文章目录 一、excel简介 1. excel能做些什么 例如：
2. excel界面包括什么 二、excel常用的基础操作 1. 新建工作表、更改工作表的标签颜色、插入/删除多个工作表 在底下所有表格后面有一个加号，点击即可新建工作表；在工作表的标签上面右键，找删除，就可以删除工作表了。
在表的标签上右键，然后选择“修改工作表标签颜色”，就可以自己更改工作表标签颜色了。
点击一个工作表标签，并按住shift，再点击一个工作表，就可以选中多个工作表了，然后在标签上点击右键，选择插入-工作表，那么现在插入的就是三张表（也就是连选了几个工作表，就能够同时新建几个工作表）。
（按住shift进行连选，点中第一个和最后一个就能选中连续的几个工作表；反之，删除也一样，用shift连选，然后删除就可以了。）
2. 插入行/列，插入多个行或列、移动行或列 1，2，3，4行
A，B，C，D列
（横行竖列），便于定位到每个单元格
插入空行，直接点击行前的数字，然后右键，选择插入，这样就Ok了。（右键，选择删除就可以删除了）
也可以同时新建多个空行。（选中多行之后，右键，然后选择插入，就可以插入多行了）列也是一样的。
如果不小心弄反了c列和d列，怎么把两列的次序交换呢？
我们可以先选中c列整列，再把鼠标放到边框线上，此时鼠标变成上下左右四个方向的箭头，然后按住shift键去拖拽，这时原来的虚线现在就变成了一条竖线，而不是原来的框了；只需要把它挡在d列的右侧（也就是e列的前面），然后再松开鼠标和shift键，这样两列就把顺序交叉过来了。
3. 调整行高列宽 当我们把鼠标移动到列标签的边框线上时，鼠标样式又变得不同了。（一个竖线，两边是箭头）拉一下鼠标，就可以把列调宽或者窄。也可以不自己左右拉，直接双击，然后单元格大小就可以自动调整到能够容纳内容的大小（自动调整为最窄）。也可以选择多列，然后你左右拉，你选中的这几列，同时被调整。选择多列，然后在边框线上双击一下，然后就都调整为最窄。
4. 单元格选取、整行整列选取、数据区域选取 怎么样快速到达一个表格的底部呢？选中一个单元格，然后把鼠标移动到它的下面的边框线上（此时鼠标变成上下左右四个方向的箭头），然后把双击鼠标，这样就可以到达表格的底部了。如果随意选择一个单元格，然后在它上面的边框线上双击（此时鼠标变成上下左右四个方向的箭头），那么就会回到表格的顶部。最左面和最右面也同理。
5. 如何快速选中很多行 先在名称框中输入单元格名称，比如A100，然后回车，就会自动跳到该单元格。
还可以在名称框中输入2：100，意思是2到100行这样一个范围，回车，就会选中这样一个范围了
三、excel小工具：冻结窗格、填充柄 1. 冻结窗格 看很多数据往下滑的时候，看不到表头，就会忘记表里面的内容是什么。但是有些表格怎么样做到滑动的时候一直在顶上不动的呢？
在视图当中，有一项是冻结窗格。点击一下，其中有一项是冻结首行，点击一下，可以看到表格的第一行出现了一条黑线，然后接下来我们再滚动，第一行就不动了。（想取消冻结的话，还是点击冻结窗格，然后单机取消冻结首行，就可以了）；也可以冻结首列。
但有的时候，我们需要的不只是冻结首行。（因为表头信息）例如，选中c4单元格，然后再点击冻结至第3行B列，最后不仅冻结了前三行，也冻结了前两列）
2. 填充柄 其实就是拖拽
比如我在f1单元格里写一个1，然后回车，会发现此时单元格的右下角又一个小正方形，当我把鼠标移动到这个小方块上的时候，鼠标的样式再次变化，变成了实心的加号。此时，当我们把鼠标左键按住往下拖时会发现接着下去的“2，3，4，5，6，7，8……”（居然会自己找规律）；而如果按着ctrl+鼠标左键，我们拖拽出来了很多“1”。
那为什么有时候是顺序的，有的时候是复制呢？
ctrl键是填充开关：若按住鼠标左键拖拽是复制填充，则ctrl+鼠标左键拖拽是顺序填充，反之亦然。
又比如我在g1单元格中写上今天的日期（即用Ctrl键+：键，按住Ctrl敲冒号），然后再向下拖拽，然后发现日期的话，也是很自然的一天一天填下来；按住ctrl键再来拖拽的话就是复制。
但是如果输入2023年6月2日，我们拖拽时不用左键，而是按住右键，就会出来提示，问是否要按照工作日填充。选中工作日填充，就会填充出星期一到星期五。（右键填充，特别的填充）
系列文章目录 第1讲：excel常用的基础操作 第2讲：excel单元格格式设置 第3讲：查找、替换、定位
第4讲：排序与筛选 第5讲：分类汇总、数据有效性 第6讲：数据透视表 第7讲：excel常用函数与公式 第8讲：if函数 第9讲：countif函数 第10讲：sumif函数 第11讲：vlookup函数 第12讲：match+index函数 第14讲：日期函数 第15讲：条件格式与公式 第16讲：简单文本函数 第17讲：数学函数 第18讲：lookup和数组 第19讲：indirect函数 第20讲：图表基础 第21讲：经典excel动态图表实现原理 第22讲：制作甘特图与动态甘特图 第23讲：双坐标柱形图、饼图美化与ppt图表 第24讲：宏表函数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f7260b7bc68e9f3687ee6fa87f70a6/" rel="bookmark">
			【爬虫实战】Python爬取知网文献信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 临近毕业季，想必很多今年毕业的朋友们最近都在焦头烂额地忙着撰写论文吧。那么如何高效地了解研究领域的热点问题，学习优秀论文解决问题的思路和方法呢？我们可以使用“知网”这个众所周知的平台来进行文献的检索与阅读。使用python可以更加有效地实现文献信息的爬取。通过快速浏览相关领域文献的基本信息，我们可以从中找出感兴趣的值得我们深入研究的文章再来进行精读，极大地提高了效率。
01 选择合适的待爬取网站 我们日常使用知网的网址为：https://www.cnki.net/。但是该网址难以获取网页源代码。右键“查看网页源代码”后会跳转到如下的页面：
但是，我们发现可以从知网空间获取网页源代码。知网空间是知网的一个搜索入口，常用于文献的快速检索，网址为：https://search.cnki.com.cn/。
02 目标页面分析 以“金融科技”为例，点击搜索，对页面进行分析，按F12选择Fetch/XHR。我们找到了如下发送的请求，且发现是以post方式发送。
且携带的参数为：‘searchType’: ‘MulityTermsSearch’, ‘Article Type’: ‘’, ‘ReSearch’: ‘’, ‘ParamIsNullOrEmpty’: ‘false’, ‘Islegal’: ‘false’, ‘Content’: ‘金融科技’, ‘Theme’: ‘’, ‘Title’: ‘’, ‘KeyWd’: ‘’, ‘Author’: ‘’, ‘SearchFund’: ‘’, ‘Originate’: ‘’, ‘Summary’: ‘’, ‘PublishTimeBegin’: ‘’, ‘PublishTimeEnd’: ‘’, ‘MapNumber’: ‘’, ‘Name’: ‘’, ‘Issn’: ‘’, ‘Cn’: ‘’, ‘Unit’: ‘’, ‘Public’: ‘’, ‘Boss’: ‘’, ‘FirstBoss’: ‘’, ‘Catalog’: ‘’, ‘Reference’: ‘’, ‘Speciality’: ‘’, ‘Type’: ‘’, ‘Subject’: ‘’, ‘SpecialityCode’: ‘’, ‘UnitCode’: ‘’, ‘Year’: ‘’, ‘AcefuthorFilter’: ‘’, ‘BossCode’: ‘’, ‘Fund’: ‘’, ‘Level’: ‘’, ‘Elite’: ‘’, ‘Organization’: ‘’, ‘Order’: ‘1’, ‘Page’: ‘1’, ‘PageIndex’: ‘’, ‘ExcludeField’: ‘’, ‘ZtCode’: ‘’, ‘Smarts’: ‘’,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56f7260b7bc68e9f3687ee6fa87f70a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4987a69c344352e04ae15c65e8eb91/" rel="bookmark">
			使用Fiddler进行弱网测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先打开Fiddler，Rules-&gt;Performance-&gt;勾选 Simulate Modem Speeds 然后快捷键Ctrl+R打开设置窗口，设置speeds
释义：每1kb上传/下载所需时间为0.3s
测试目的： 很多bug都会在弱网的情况下展现出来，如由于响应慢而多次请求，最终导致app出现ANR问题
Fiddler限速原理： 是通过延迟发送数据或接收的数据的时间来限制网络的下载速度和 上传速度，从而达到限速的效果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8acaff572ce23154a5ff30e91bf1e5f6/" rel="bookmark">
			手把手教你使用 Python 调用 ChatGPT-3.5-API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天 OpenAI 开放了两个新模型的api接口，专门为聊天而生的 gpt-3.5-turbo 和 gpt-3.5-turbo-0301。
ChatGPT is powered by gpt-3.5-turbo, OpenAI’s most advanced language model.
从上面这句话，我们可以知道现在 chat.openai.com 官网就是由 gpt-3.5-turbo 模型提供的服务，现在官方公开了这一模型的调用接口，这使得我们这些普通开发者也能直接在自己的应用/服务中使用这个狂揽亿万用户的模型。
接下来将和大家介绍如何利用 Python 快速玩转 gpt-3.5-turbo。
先跑起来，再理解 首先你需要有一个 openai 账号，如何注册我就不多说了，网上教程很多，而且很详细，如果有问题可以加我微信：
访问下面页面，登录 openai 账号后，创建一个 api keys。
# api keys 创建页面 https://platform.openai.com/account/api-keys 接下来很简单了，安装 openai 官方的 Python SDK，这里需要注意的是得安装最新版本 openai，官方推荐的是 0.27.0 版本。
pip install openai==0.27.0 直接上请求代码：
import openai import json # 目前需要设置代理才可以访问 api os.environ["HTTP_PROXY"] = "自己的代理地址" os.environ["HTTPS_PROXY"] = "自己的代理地址" def get_api_key(): # 可以自己根据自己实际情况实现 # 以我为例子，我是存在一个 openai_key 文件里，json 格式 ''' {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8acaff572ce23154a5ff30e91bf1e5f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c50f15b26f027569badb44490406b30a/" rel="bookmark">
			【Java】-【tomcat部署项目】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat 的目录结构 bin：Tomcat 的启动、关闭脚本。 conf：Tomcat 配置文件。 lib：Tomcat 需要的类库（jar 包）。 logs：日志目录。 temp：Tomcat 运行时产生的临时文件。 webapps：存放 Web 应用程序的目录。 work：存放 Tomcat 生成的 Servlet 源文件。 部署方法 直接将 web 项目文件件拷贝到 webapps 目录中（最常用）：webapps 目录是 Tomcat 默认的应用目录，当服务器启动时，会加载所有这个目录下的应用。如果你想要修改这个默认目录，可以在 conf下的 server.xml 文件里修改 Host 标签里的 appBase 值。这个方法实际上和在 IDE开 发环境里部署项目是一样的。用此方法的访问路径为：http://localhost:8080/webname。修改 Server.xml 文件：在 conf 下的 server.xml 文件里找到 Host 标签，在里面添加如下代码： &lt;Context path="/项目名" docBase="项目路径" reloadable ="true" debug="0" privileged="true"&gt;&lt;/Context&gt; path：表示访问的路径，可以自定义，例如：http://localhost:8080/budaye。
docBase：表示应用程序的路径，可以使用绝对路径或者相对路径，相对路径相对于webapps。
reloadable：表示可以在运行时在 classes 与 lib 文件夹下自动加载类包。这个属性在开发阶段通常都设为 true，方便开发；在发布阶段应该设置为false，提高应用程序的访问速度。
在 conf\Catalina\localhost 目录下添加 xml 配置文件，文件内容配置如下： &lt;Context path="/项目名" docBase="项目路径" reloadable ="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c50f15b26f027569badb44490406b30a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a97c2ca5b833921a30e01898be982368/" rel="bookmark">
			计算机视觉基础模型汇总，13大类算法，85个变种
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视觉领域的同学应该有所体会，获取大量标注数据是一件成本非常高的事。为了应对这个问题，研究者们通过借助无标注数据、图文数据或者多模态数据等，采用对比学习、掩码重建等学习方式预训练得到视觉基础模型，用于适应各种下游任务，比如物体检测、语义分割等。在过去一年中，由于LLM、多模态等领域的快速发展，更多新兴的计算机视觉基础模型被提出。
到目前为止，已发布的计算机视觉基础模型数目已经相当可观，对于视觉领域的同学来说，这些基础模型具有非常高的研究价值。为了方便同学们了解并掌握该领域的最新进展，发出属于自己的顶会，我今天就和大家分享一篇综述论文，该文作者对计算机视觉领域的基础模型进行了详细的梳理，涵盖了13大类算法模型，以及每一类模型的变种共85个，从最早的LeNet、ResNet到最新的SAM、GPT4等都有。
​综述链接：https://arxiv.org/pdf/2307.13721.pdf
除此之外，学姐也帮大家整理了120篇21年-23年必读的CV领域算法模型的代表性论文，部分代码已开源。
尽管已有的方法表现不俗，但我们清楚，计算机视觉基础模型的发展仍然有巨大的进步空间，希望同学们能通过这份资料全面掌握计算机视觉领域的发展脉络，厘清每个模型的变化历史，并从中找到更优解。
论文list： Surveys（12） Foundational Models Defining a New Era in Vision: A Survey and Outlook 2023
A of Large Language Models 2023
Harnessing the Power of LLMs in Practice: A Survey on ChatGPT and Beyond 2023
Multimodal Learning with Transformers: A Survey 2023
Self-Supervised Multimodal Learning: A Survey
Vision-and-Language Pretrained Models: A Survey 2022
A Survey of Vision-Language Pre-Trained Models 2022
Vision-Language Models for Vision Tasks: A Survey 2022
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a97c2ca5b833921a30e01898be982368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a89cf778828e3c37788cc60ca7b5c1/" rel="bookmark">
			scanf和printf的用法及其常见错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		printf printf() 的作⽤是将参数⽂本输出到屏幕。它名字⾥⾯的 f 代表 format （格式化），表⽰可以定制输出⽂本的格式。
书写方式 在使用printf前需要输入#include &lt;stdio.h&gt;进行声明，printf大致可分为两种书写方式，第一种是直接书写的方法，例如：
#include &lt;stdio.h&gt; int main() { printf("你好"); return 0; } 第二种是利用“占位符”的书写方式：
占位符介绍 在上图中%d为“占位符”，所谓 “占位符”，就是这个位置可以⽤其他值代⼊，这个值必需在引号后标明出来。另外这个值的类型必须要和前面的占位符一一对应，详情如下：
• %a ：⼗六进制浮点数，字⺟输出为⼩写。
• %A ：⼗六进制浮点数，字⺟输出为⼤写。
• %c ：字符。
• %d ：⼗进制整数。
• %e ：使⽤科学计数法的浮点数，指数部分的 e 为⼩写。
• %E ：使⽤科学计数法的浮点数，指数部分的 E 为⼤写。
• %i ：整数，基本等同于 %d 。
• %f ：⼩数（包含 float 类型和 double 类型）。
• %g ：6个有效数字的浮点数。整数部分⼀旦超过6位，就会⾃动转为科学计数法，指数部分的 e
为⼩写。
• %G ：等同于 %g ，唯⼀的区别是指数部分的 E 为⼤写。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97a89cf778828e3c37788cc60ca7b5c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ec7255e50557e62899d031d3e67e42b/" rel="bookmark">
			Deeplearning.AI自然语言处理学习笔记——C2W4——词嵌入向量——练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20230807：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd761e2e92bf960e53e0efb1a9b23fe1/" rel="bookmark">
			HAL 库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HAL库 1、初识HAL库 1.1 CMSIS 简介 CMSIS（微控制器软件接口标准）：Crotex Microcontroller Software Interface Standard，是由ARM和与其合作的芯片厂商、软件工具厂商，共同制定的标准
ARM官方提供的CMSIS规范架构 1.2 HAL库 简介 ST为了方便用户开发STM32芯片开发提供了三种库：
标准外设库：Standard Peripheral Libraries ST最早的库，现在还在用目前只兼容 F0/F1/F3/F2/F4/L1 系列目前已停止维护 HAL库（硬件抽象层）：Hardware Abstraction Layer ST目前主推的库全系列兼容兼容性好、移植方便，但效率不太高 LL库：Low Layer 与HAL库困捆绑发布全系列兼容轻量级、效率高不匹配部分复杂外设，比如 USB 2、STM32Cube 固件包浅析 STM32Cube固件包即：ST公司基于自己的产品，根据上文ARM官方的CMSIS规范架构标准，提供的CMSIS-Pack
2.1 STM32Cube固件包文件夹简介 _htmresc：图片文件Documentation：STM32Cube说明文档Drivers：驱动源码 Middlewares：中间文件 Projects：ST官方开发板案例Utilities：公共组件其他文件 License.md：软件版权信息package.xml：固件包版本信息Readme.md：自述Release_Notes.html：补充或更新说明 2.2 CMSIS文件夹关键文件 CMSIS文件夹下文件目录 关键文件 Device：微控制器专用头文件、启动文件、专用系统文件Include：Cortex-M内核及其设备文件、编译器相关头文件 3、HAL库框架结构 3.1 HAL库文件夹结构 以STM32F1系列为例：
Inc：HAL库和LL库驱动源码头文件Src：HAL库和LL库驱动源码.chm后缀文件：用户手册 3.2 HAL库文件介绍 以STM32Cube_F1_v1.8.0为例：
文件描述stm32f1xx_hal.c stm32f1xx_hal.hHAL库的初始化、系统滴答，HAL库延时函数等相关函数stm32f1xx_hal_conf.hHAL库的用户配置文件，用于裁剪HAL库、配置晶振参数等stm32f1xx_hal_def.h包含HAL库通用的美剧类型数据和宏定义stm32f1xx_hal_cortex.c stm32f1xx_hal_cortex.h内核通用函数定义和声明，如NVIC、MPU、系统软复位、Systick等，其实主要是对core_cm2.h文件的相关函数再次封装stm32f1xx_hal_ppp.c stm32f1xx_hal_ppp.h某任意外设驱动源码，PPP表示任意外设stm32f1xx_hal_ppp_ex.c stm32f1xx_hal_ppp_ex.h主要是存放外设的扩展（特殊）功能的驱动源码，PPP表示任意外设stm32f1xx_ll_ppp.c stm32f1xx_ll_ppp.hLL库驱动源码，在部分stm32f1xx_hal_ppp.c或stm32f1xx_hal_ppp_ex.c中会被调用 3.3 HAL库API函数和变量命名规则 a. 命名规则 文件名称stm32f1xx_hal_ppp.(c/h)stm32f1xx_hal_ppp_ex.(c/h)函数名HAL_PPP_FunctionHAL_PPPEx_Function外设句柄PPP_HandleTypeDef无外设工作参数初始化结构体PPP_InitTypeDefPPP_InitTypeDef配置参数结构体PPP_YyyyConfTypeDefPPP_YyyyConfTypeDef 即让某个外设(PPP)完成某个功能(Function)，常见的有以下几种：
初始化/反初始化函数：HAL_PPP_Init()，HAL_PPP_DeInit()
外设读写函数：HAL_PPP_Read()，HAL_PPP_Write()，HAL_PPP_Transmit()，HAL_PPP_Receive()
控制函数：HAL_PPP_Set ()，HAL_PPP_Get ()
状态和错误：HAL_PPP_GetState ()，HAL_PPP_GetError ()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd761e2e92bf960e53e0efb1a9b23fe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aecd2b5a561ea06f7e1591a5d100e6e7/" rel="bookmark">
			ViSQOL、PESQ、mosnet等mos分打分工具和Polqa语音感知音质打分测评
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创：转载需附链接： https://blog.csdn.net/qq_37100442/article/details/132057139?spm=1001.2014.3001.5502 一、背景 Mos分评价音质重要指标，最近也有很多机构和公司在研究适合自己的评价体系。目前Mos分主要分为主观评测和客观感知评价。其中客观感知评价由于方便和节省人力，被大众研究。本文章以标准polqa的mos分为可信前提，验证visqol、pesq、mosnet与polqa的一致性，以及visqol的可信度验证；主要用于 编解码、 降噪、回声消除等算法的感知效果进行打分，从而促进算法的迭代和可信度； 二、评价方式综述 1、主观评价 1） 优点：主观测试是音频评价的黄金准则，最符合人的实际听感。
2） 缺点：主观评测费时费力，测试者太少、测试者不规范等都会带来测试误差；
3） 常用方法：AB-TEST， MUSHAR
2、客观打分 1） 缺点：不能够完全符合人的听觉感知，存在听感好打分低的情况；
2） 优点：方便测试和开发人员，快速验证语音的相对质量，方便日常工作，提升开发 和测试效率；
3） 常用方案：有参考（POLQA, PESQ, VISQOL）和无参考（ITU-TP.1201传统方法 和 MOSNET的AI打分）
二、打分维度和一致性对比 1、打分维度： 结论：Visqol支持对时间帧和频率轴的各个频带进行打分（如下图所示），并且支持16khz和48khz；pesq只有最后的评分结果，拿不到时间和频率的细节打分，并且仅支持8kh和16khz打分；Mosnet为无参考打分；
2、一致性对比： 结论：visqol和polqa的一致性更高， pesq颗粒度不够， mosnet（AI无参考模型）表现最差；
注：SMD48和SMD49，SMD50和SMD51，SMD271和SMD272这三对音频各对的音源相同，并且每对的后者都针对前者做了过认证优化。
三、visqol可信度测评 从一些常见维度对语音进行损伤，测试visqol是否符合听感判断。
1、音量的影响： 结论：音量差异影响不大，但是当降低-18db开始分数降低；
​​​​2、混响的影响： 结论：混响音响较大，加入混响分数就开始降低，但是混响大小影响有规律
3、噪音的影响： 结论：噪音影响很大，加入噪音分数就明显降低，但是不同信噪比变化有规律
4、频带缺失的影响 结论：频带缺失影响打分较大，但是不同的频带模型还是能够匹配降低不同的分值；
四、总结 visqol和polqa有较高的一致性（可能有幸存者偏差，但是拿到的数据是我们过认证的随机音频），visqol也存在和听感不符合的打分，例如加入轻微混响和噪音都会对打分有影响；但是混响和噪音的影响随着RT60和SNR的变化是有规律的，如果在降噪和混响模型的测试，也具相对意义，可以进行研发的自测；
参考文献：
1、 https://github.com/google/visqol
2、Objective Measure of Perceptual Audio Quality
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc038b7a6791ebfb21a22f5be1bc34e3/" rel="bookmark">
			掌握 JVM 调优命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用命令 1、jps查看当前 java 进程2、jinfo实时查看和调整 JVM 配置参数3、jstat查看虚拟机统计信息4、jstack查看线程堆栈信息5、jmap查看堆内存的快照信息 JVM 日常调优总结起来就是：首先通过 jps 命令查看当前进程，然后根据 pid 通过 jinfo 命令查看和修改 jvm 参数，通过 jstat 命令查看 class 的加载信息以及 GC 信息，通过 jstack 命令查看线程堆栈信息，通过 jmap 命令查看堆内存信息。
1、jps查看当前 java 进程 jps 是 Java 虚拟机自带的命令行工具，用于显示当前运行的所有Java进程及其相关信息，包括进程 ID、主类、进程状态等。其基本用法为：
jps [options]
其中，常用的选项有：
-l：显示主类的完整路径名。
-p：显示进程的当前线程所在的工作进程组。
-s：显示进程的启动时间。
-v：显示进程的虚拟机信息，如JVM版本、GC类型等。
要查看当前所有正在运行的Java进程及其相关信息，可以输入命令：jps要查看主类的完整路径名，可以输入命令：jps -l要查看进程的启动命令行参数字符串，可以输入命令：jps -m需要注意的是，由于 jps 命令直接读取 Java 虚拟机的内部数据，因此需要确保当前用户具有足够的权限才能使用。 2、jinfo实时查看和调整 JVM 配置参数 jinfo 是 Java 虚拟机自带的命令行工具，用于查看和调整Java虚拟机的配置参数和运行状态。它可以用来检查Java虚拟机的内存使用情况、垃圾回收情况、类加载情况等。要使用 jinfo 命令，您可以在 Java 程序运行的终端或命令行界面中输入以下命令：
jinfo &lt; pid&gt; [options]
其中，"pid"是Java进程的进程ID，可以通过"jps"命令查看
例如，要查看Java虚拟机的内存使用情况，可以使用以下命令：
jinfo &lt; pid&gt; -dump:live
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc038b7a6791ebfb21a22f5be1bc34e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f157f069d7827cb777ec57719cbba0f/" rel="bookmark">
			解决前端ELement UI时间控件el-date-picker提交时间误差8小时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 前端使用框架与UI：Vue+ElementUI。
在项目开发中使用到了DateTimePicker组件，在选择时间后点击查询发现查询导的内容与预期内容有所偏差，之后发现前端选中的时间在后端接收时相差了八个小时。
原因 我们国家的标准时间是东经120°时间（东八区），而标准时间是格林威治时间（世界时），两者相差了整整8小时。
解决 需要在el-date-picker中设置value-format属性，value-format=“yyyy-MM-dd HH:mm:ss”。
&lt;el-date-picker v-model="value" type="datetime" value-format="yyyy-MM-dd HH:mm:ss" placeholder="选择日期时间"&gt; &lt;/el-date-picker&gt; 并且在后端实体类上时间字段添加注解：
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8") private LocalDateTime orderTime; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa2b093bd0c97776ffbb26f6b6cdb082/" rel="bookmark">
			ElasticSearch--warning: usage of JAVA_HOME is deprecated, use ES_JAVA_HOME
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es和jdk是一个强依赖的关系，所以当我们在新版本的ElasticSearch压缩包中包含有自带的jdk，但是当我们的Linux中已经安装了jdk之后，就会发现启动es的时候优先去找的是Linux中已经装好的jdk，此时如果jdk的版本不一致，就会造成jdk不能正常运行，报错如下：
warning: usage of JAVA_HOME is deprecated, use ES_JAVA_HOME
Future versions of Elasticsearch will require Java 11; your Java version from [/usr/local/jdk1.8.0_291/jre] does not meet this requirement. Consider switching to a distribution of Elasticsearch with a bundled JDK. If you are already using a distribution with a bundled JDK, ensure the JAVA_HOME environment variable is not set. 如果Linux服务本来没有配置jdk，则会直接使用es目录下默认的jdk，反而不会报错。
解决办法 1. 进入bin目录
1. 进入bin目录 cd /usr/local/elasticsearch-7.14.0/bin 2.修改elasticsearch-env配置 vim ./elasticsearch-env # 将jdk修改为es中自带jdk的配置目录,es自带的jdk位置/usr/local/es/elasticsearch-7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa2b093bd0c97776ffbb26f6b6cdb082/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74457f96911079e241dc588463cbd727/" rel="bookmark">
			Gumbel-Softmax简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Gumbel Softmax trick的使用场景 1. argmax简介 在NLP领域的强化学习或者对抗学习中，token的生成是离散的。比如，一个token的产生是一个大小为vocab size的one-hot向量。比如，对于character level的token： [ 1 , 0 , 0 , 0 , . . . , 0 ] [1, 0, 0, 0, ..., 0] [1,0,0,0,...,0]代表a， [ 0 , 1 , 0 , 0 , . . . , 0 ] [0, 1, 0, 0,..., 0] [0,1,0,0,...,0] 代表b。具体选择哪个token就根据输出的每个维度的大小，选择预测概率最大作为输出token，即 a r g m a x arg \ max arg max操作。
如图：
以四维向量 v v v为例，对其做argmax操作，得到的one-hot vector为 [ 0 , 1 , 0 , 0 ] [0, 1, 0, 0] [0,1,0,0]。虽然该方法可以得到正确的分类，但是显而易见，argmax是不可导的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74457f96911079e241dc588463cbd727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e25fa59f5a25ec3fad34bed4ecc919b/" rel="bookmark">
			算法学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、动态规划1.什么是动态规划2.动态规划四大步骤3.动态规划示例1) 案例一：打家劫舍I 「来自leetcode198」2) 案例二：爬楼梯 「来自leetcode70」 二、回溯算法1、什么是回溯算法2、回溯算法示例1) 案例一：给定一个没有重复数字的序列，返回其所有可能的全排列。 `持续更新中。。。。。` 一、动态规划 1.什么是动态规划 动态规划的核心是保存已计算过的历史数据来减少计算。用空间来换算时间。
动态规划是对一个任务的拆解，对有重叠子问题的处理。
2.动态规划四大步骤 步骤一：定义dp数组的含义
步骤二：定义状态转移方程
步骤三：初始化过程转移的初始值
步骤四：可优化点(可选)
3.动态规划示例 1) 案例一：打家劫舍I 「来自leetcode198」 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
示例 1：
输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2：
输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。 如果你对于动态规划还不是很了解，或者没怎么做过动态规划的题目的话，那么 House Robber （小偷问题）这道题是一个非常好的入门题目。本文会以 House Robber 题目为例子，讲解动态规划题目的四个基本步骤。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e25fa59f5a25ec3fad34bed4ecc919b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9935f0fc0f679d6ff09351d148d69b16/" rel="bookmark">
			AI图片生成Stable Diffusion环境搭建与运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Stable Diffusion是一种基于扩散过程的生成模型，由Ge et al.在2021年提出。该模型利用了随机变量的稳定分布，通过递归地应用扩散过程来生成高质量的图像。与其他生成模型相比，Stable Diffusion在生成高质量的图像方面具有显着优势。具体而言，该模型所生成的图像具有更好的细节保留能力和更自然的外观。通过对不同扩散时间的研究，Stable Diffusion还可以实现通过调整时间精度来生成图像的分辨率。
在实践中，Stable Diffusion被广泛应用于图像生成、压缩、修复和增强等应用中。此外，该模型还可以与其他深度学习技术结合使用，例如GAN和VAE，以提高生成图像的质量和多样性。总之，Stable Diffusion是一种非常实用且具有潜力的图像生成模型，在未来的研究和应用中将发挥重要作用。
本文主要介绍Stable Diffusion webui环境搭建，后续将陆续介绍参数设置、API搭建、模型基本原理、训练、部署等内容。具体更新可关注文章下方公众号，也可关注本专栏。所有相关文章会在《Python从零开始进行AIGC大模型训练与推理》中进行更新，地址为“https://blog.csdn.net/suiyingy/article/details/130169592”。
1 环境搭建 显卡驱动、CUDA、CUDNN、Docker、Python等环境搭建请参考本专栏另一篇博文《Docker AIGC等大模型深度学习环境搭建（完整详细版）》，地址为“https://blog.csdn.net/suiyingy/article/details/130285920”。
1.1 创建Python环境 这里使用conda创建一个Python 3.10环境，命令如下所示。
conda create -n stdf python=3.10 -y conda activate stdf 1.2 stable-diffusion-webui环境安装 stable-diffusion-webui提供了网页前端页面用于Stable Diffusion模型生成图片，其Github官方工程地址为“https://github.com/AUTOMATIC1111/stable-diffusion-webui”。官方工程页面提供了安装步骤，包括一些自动安装脚本。这里主要是手动进行安装，并在Ubuntu 18.04与Ubuntu 20.04上进行验证，其环境安装命令如下所示。手动进行安装的好处在于及时了解报错信息并进行修复。
conda activate stdf git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git cd stable-diffusion-webui pip install -r requirements_versions.txt -i https://pypi.tuna.tsinghua.edu.cn/simple pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 2 启动stable-diffusion-webui stable-diffusion-webui的启动命令为“python launch.py”，启动后程序会自动安装和下载所依赖的其它环境。安装过程中出现的问题及解决方式如下所示。运行成功后，我们可通过网页浏览器访问，默认端口号为7860，访问地址为“IP:7860”或“0.0.0.0:7860”或“127.0.0.1:7860”或“localhost:7860”。如果需要通过其它主机进行访问，需要让防火墙允许该端口，命令为“sudo ufw allow 7860”。
运行成功后页面如下。安装过程中出现的问题及解决方式如下所示。
2.1 openclip安装不上
Openclip无法安装原因可能是网络问题导致无法获取到github上相应资源，因而可通过将其替换为gitee上对应资源加以解决。具体修改方式为将launch.py文件中的openclip_package所在行替换为如下内容，位于第234行左右。
openclip_package = os.environ.get('OPENCLIP_PACKAGE', "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9935f0fc0f679d6ff09351d148d69b16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f891ed1e86eec3c919f31cb85f37298/" rel="bookmark">
			keil5软件仿真设置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.第一步打开魔术棒，选择正确的芯片型号，不过这一步一般创建工程的时候就完成了，如果换过芯片记得换回来。
2.选择8M的晶振
3.我们打开file-&gt;device database,我们选择自己的芯片型号，并且复制这段代码。我们需要括号前面和括号里面的，下面是我芯片的代码。
DARMSTM.DLL -pSTM32F103ZE
4.再次打开魔术棒，找到DEBUG，选择USE simulaton，然后把我们刚刚复制的这段代码先后填入下方画圈的地方。然后点击ok。
最后我们Ctrl+F5就可以愉快的软件仿真了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5135a93c36d15bd609a17c3980051067/" rel="bookmark">
			QGC调试px4飞控问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本文主要讨论本人遇到的问题，由于各操作步骤已有不少文章说明具体操作方法，本文不再赘述。
1.如果使用碳纤维机架，要在电源板背面增加绝缘层以防短路。如果自行焊接导线，应当检查是否短路。
2.传感器校准时尽量不要放到桌子上调，这是因为桌子可能不平整，会影响校准精度，放在地面上调会好一些。
3.使用前应当先进行电调校准，否则会导致电机无法启动。
4.遥控器校准应当力求操作准确，可以多利用遥控器的机械限位，并且避免操作校准时无需操作的轴（如进行右摇杆横轴校准，应当注意纵轴保持中心位置）。另外要注意各通道是否需要反相。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84e52f0fc653abb2814504ae9f93c3d0/" rel="bookmark">
			51单片机学习--DS18B20温度读取&amp;温度报警器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需要先编写OneWire模块，再在DS18B20模块中调用OneWire模块的函数
先根据原理图做好端口的声明：
sbit OneWire_DQ = P3^7; 接下来像之前一样把时序结构用代码模拟出来：
unsigned char OneWire_Init(void) { unsigned char i; unsigned char AckBit; OneWire_DQ = 1; OneWire_DQ = 0; //总线拉低 //延时500us i = 227; while (--i); OneWire_DQ = 1; //释放总线 //延时70us i = 29; while (--i); AckBit = OneWire_DQ; //延时500us i = 227; while (--i); return AckBit; } void OneWire_SendBit(unsigned char Bit) { unsigned char i; OneWire_DQ = 0; //总线拉低 //延时10us后直接读电平 i = 4; while(--i); OneWire_DQ = Bit; //延时50us凑满时间片 i = 22; while(--i); OneWire_DQ = 1; } unsigned char OneWire_ReceiveBit(void) { unsigned char i; unsigned char Bit; OneWire_DQ = 0; //延时5us i = 2; while(--i); OneWire_DQ = 1; //延时5us i = 2; while(--i); Bit = OneWire_DQ; //延时50us i = 22; while(--i); return Bit; } void OneWire_SendByte(unsigned char Byte) { unsigned char i; for(i = 0; i &lt; 8; i ++) { OneWire_SendBit(Byte &amp; (0x01&lt;&lt;i)); } } unsigned char OneWire_ReceiveByte(void) { unsigned char i; unsigned char Byte = 0x00; for(i = 0; i &lt; 8; i ++) { if(OneWire_ReceiveBit()) {Byte |= (0x01&lt;&lt;i);} } return Byte; } 至此，OneWire模块就写好了，接下来在DS18B20模块中模拟数据帧：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84e52f0fc653abb2814504ae9f93c3d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4acd6c80013860fefb6314c78db37d/" rel="bookmark">
			linux常用网络命令/多网卡绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 网络配置命令
1.1 ifconfig命令
1.1.1 设置临时虚拟网卡
1.2 ss命令
二. 多网卡绑定
一. 网络配置命令 1.1 ifconfig命令 在不带任何选项和参数执行 ifconfig 命令时， 将显示当前主机中已启用（活动）的网络接口信息
1.1.1 设置临时虚拟网卡 ifconfig ens33:0 [ip地址/可选] 关闭虚拟网卡
ifconfig ens33:0 down 1.2 ss命令 ss 命令：也可以查看网络连接情况，主要用于获取 socket 统计信息，它可以显示和 netstat 命令类似的输出内容，但 ss 的优势在于它能够显示更多更详细的有关 TCP 和UDP连接状态的信息，而且比 netstat 更快速更高效
格式：ss 【选项】
-t: tcp协议相关 -u: udp协议相关
-w: 裸套接字相关 -x：unix sock相关
-l: listen状态的连接 -a: 所有
-n: 数字格式 -p: 相关的程序及PID
-e: 扩展的信息 -m：内存用量
-o：计时器信息 -r: --resolve 把 IP 解释为域名，把端口号解释为协议名称
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4acd6c80013860fefb6314c78db37d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a69a97ad82b72e284374b84c9e43b7e/" rel="bookmark">
			解决uni-app的pages.json的模块化及模块热重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言uni-app的"彩蛋"pages.js的模块化安装pages.js示例模块的规范（被加载的模块也是CommonJS规范，通过module.exports输出）module1.js示例 前言 由于业务需要，需要在原有的系统上再衍生出一套相同的系统，也就是一套代码多个系统，这就需要考虑到page.json中page项要动态生成，方便我们后期去维护（当然考虑的不止这一点，这里只针对page.json文件来讲）。
uni-app的"彩蛋" uni-app自带一个webpack loader钩子文件page.js，在项目src目录下建立page.js（与pages.json同级）即可生效（pages.json仍然需要存在，作为初始值，建议存放一些和路由无关的配置）。pages.js要求CommonJS规范，直接通过module.exports输出一个钩子函数。
pages.js的模块化 由于是js，就可以实现模块的依赖，如果不考虑模块的热重载问题，可以不使用hot高阶函数，但是大多数情况下，需要依赖的模块也可以通过热重载更新pages.js，由于不是webpack的标准运行依赖，所以需要手动添加依赖项（使用addDependency），并且需要每次清除模块的缓存，因此uni-pages-hot-modules就诞生了。
安装 npm i uni-pages-hot-modules -S
pages.js示例 const { hot } = require('uni-pages-hot-modules') module.exports = hot((pagesJson) =&gt; { let basePages = [] let baseSubPackages = [] return { // 合并pages.json的内容 ...pagesJson, pages:[ ...basePages, ...require('./page_modules/tabbar.js'), ...require('./page_modules/component.js'), ...require('./page_modules/appPlus.js'), ...require('./page_modules/module1.js') ], // 分包配置 subPackages:[ ...baseSubPackages, ...require('./subpackage_modules/api.js'), ...require('./subpackage_modules/extUI.js'), ...require('./subpackage_modules/template.js') ] } }) 模块的规范（被加载的模块也是CommonJS规范，通过module.exports输出） module1.js示例 module.exports=[ { "path": "pages/sub/sub", "style": { "navigationBarTitleText": "sub" } }, // 在模块里继续引入其他子模块 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a69a97ad82b72e284374b84c9e43b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cfdaa17628ee53a542e6094768c0e23/" rel="bookmark">
			Vue首次搭建脚手架报错。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
第一次搭建Vue脚手架，和我想的一样并没有想的那么顺利，当我满怀期待去运行我写好的组件时，一串串红色的error，直击我的心灵，这也不禁让我想起了一首诗，雄关漫道真如铁，而今迈步从头越难关，哈哈哈，接下来看看我在搭建Vue脚手架并运行的过程中遇到了哪些问题吧！
一，在安装vetur插件之后，当我创建一个Vue文件时，在template里面单独写一段注释时，在一段解析过后，弹出两个警告。 解决方案：打开vscode里面的一个配置项就可以了。
二，当时我的组件是写在我的D盘，而搭建Vue脚手架是在Desktop上搭建的，在我搭建完毕后，把我的App.vue文件和其它组件文件也放到了相应的配置文件夹内，运行的时候给我报了两个错误 模块未找到:错误:无法解决(Can‘t resolve ‘xxx‘ in ‘D:\briup\vue_test\node_modules\send) 错误原因：组件引入 App.vue/其他组件 时出错了,首先仔细检查引入的文件名大小写及单词拼写是否正确!!!其次检查一下组件引入的路径是否正确，我这里就是因为从另一个路径复制过来，导致路径不正确。
错误路径：
改完之后的正确路径：
三，定义的文件名错误。 错误原因： 这里是你的vue文件名字不是它推荐的多单词形式，如schoolName。
解决方案：这里由于没有找到更好的解决方案，我只能被逼无奈按照他的要求给文件名改成小驼峰形式(schoolName)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/144d700ad9408862c3f2c1e6e9c50f8a/" rel="bookmark">
			节外生枝 - Minecraft Fabric Mod 开发：第 2 期 添加物品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上一期，我们已经准备好了开发环境。这一期我们将带领大家进行代码实现。本期我们将尝试在Minecraft中添加物品。
实现 Mod 入口点 什么是Mod入口点呢。其实这是笔者形象表述的，而非一个专业术语。读者不妨自己设想一下，既然给出一个Mod，自然是要按照代码运行。那么问题来了，该从哪里开始运行呢？这样的一个起始点，我们就称之为Mod入口点。
学过编程的同学都知道，程序的运行需要从一个入口点开始，在面向过程的语言中，这个点通常是入口函数；而对于面向对象的语言，这个点则通常是一个对象的某个方法。开发Minecraft Mod，我们使用的是Java语言，它是一款面向对象的语言。因此，我们需要为Mod的运行提供一个入口点方法。
如上文所述，入口点方法是存在于某个对象中的，我们不妨在项目试图里打开src/main/java/org/tutorial/tutorialmod
我们可以发现，默认情况下，这个路径对应的有一个源代码和一个包含了源代码的文件夹。原因在于，我们在上一期创建Mod时，在Environment一栏选择的时Both选项，即客户端和服务端。Mod运行分为客户端运行和服务端运行。对于普通玩家而言，游玩的都是客户端，而对于服务器而言，则运行服务端。具体原理这里不过多赘述。这里只以客户端作为讲解。
我们打开TutorialModClient文件，可以发现文件中已经为我们定义好了TutorialModClient类。这就是我们这个Mod（项目）的对象。接下来就是提供入口方法了。由于Fabric有一套自己的API，我们只需使用Fabric提供的API即可。因此，我们需要在文件开头导入Fabric API
import net.fabricmc.api.ClientModInitializer; 这里导入的是Fabric为我们准备好的Mod初始化的模板。我们需要使Mod对象遵循这个模板进行初始化，只需如下即可：
public class TutorialModClient implements ClientModInitializer { @Override public void onInitializeClient() { } } 值得注意的是，@Override是一种注解，表示以下方法重写了父类的方法（即我们导入的模板中要求给出的方法）。这个方法原型是固定的，必须是void型，且方法名必须是onInitializeClient。
【服务端对应的模板是ModInitializer，其入口方法为onInitialize】
接下来我们可以进行编译运行。按下Ctrl+F9或手动构建。构建成功后，我们选择Minecraft Client任务运行。为了方便观察Mod是否加载以及便于后期对Mod信息修改。这里推荐大家安装Mod Menu，选择1.16.5 Fabric版本。安装后运行界面如下。
到这里，Mod的入口点问题已经解决了！
注册表机制 Minecraft中采用注册表机制（与Windows系统注册表不完全类似）。注册表分为很多种。具体种类参见如下链接。
tutorial:registry_types [Fabric Wiki]
名称空间 使用give命令给予玩家物品时，还记得我们是如何表示物品的吗？比方说，铁锭我们的表述为’minecraft:iron_ingot’。冒号前我们称之为名称空间namespace。
那么名称空间是用来干什么的呢？简单来说就是为了兼容的。有时我们发现，一个模组加了一个物品比如说钢片，另一个模组也有这个物品但却不是同一个，总不能一个叫钢片的物品被两个模组注册吧。所以就有了名称空间的说法，每个模组都有一个自己的名称空间，注册的物品也都属于这个空间，就不会和其他模组的同名物品冲突（尽管玩家看到相同的连个物品依旧困扰无奈）。
Coding… 知道了以上几点知识，我们大致有了开发的思路。接下来让我们用代码实现吧！
首先，让我们来实现Mod入口点。Fabric是一个成熟的框架，它为我们准备好了一切，我们只需要照着模子一点点雕刻即可。创建一个类，并指定接口。
public class TutorialModClient implements ClientModInitializer { } 接下来，我们需要具体实现onInitializeClient方法。注意方法名前要加上@Override表示对接口的实现。
@Override public void onInitializeClient() { } 构建项目，同时选择执行Minecraft Client任务，有的同学的“Build”窗口中输出很多下载信息，那是项目正在补全所需文件及环境。过一会，就会弹出一个Minecraft游戏窗口。为了方便以后的开发，这里推荐安装一个Mod——Mod Menu。
进入游戏后在主菜单选择模组即可看到我们自己写的Mod。
注册物品
我们在TutorialModClient下创建一个类TutorialItems用于存放我们需要注册的物品并且提供一个注册的方法。代码如下：
public class TutorialItems { public static final Item BRONZE_INGOT = new Item(new Item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/144d700ad9408862c3f2c1e6e9c50f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72c45ac49aeca2178cd1c935f0280c98/" rel="bookmark">
			内网渗透——内网信息收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、内网信息收集简介
1.对当前机器角色进行判断
2.对当前机器所处网络环境及拓扑结构进行判断分析
3.对当前机器所处区域进行判断
二、本机信息收集
1.手动收集
2.相关查询命令
（1）获取本机网络配置信息
（2）操作系统和软件信息
#1.操作系统及其版本信息
#2.系统体系结构
#3.安装的软件及版本，路径等
3.查询本机服务信息
4.查询进程列表
（1）可以查看到当前进程列表和用户，分析软件，邮件客户，VPN和杀毒软件等进程
（2）查看进程信息
5.查看启动程序信息
6.查看计划任务
7.查看主机开机时间
8.查询用户列表
（1）查看本机用户列表
（2）获取本地管理员信息
（3）查看当前在线用户
9.列出或断开本地计算机与所连接的客户端之间的会话
10.查询端口列表
11.查看补丁列表
（1）查看系统的详细信息
（2）查看安装在系统中的补丁
12.查询本机共享列表
13.查询路由表及所有可用接口的ARP缓存表
14.查询防火墙配置
（1）关闭防火墙
（2）查看防火墙配置
（3）修改防火墙配置
#1.允许指定程序全部连接
15.查看代理配置情况
16.查询并开启远程连接服务
（1）查看远程连接端口
（2）在windows server 2003中开启3389端口
（3）在windows server 2008和2012中开启3389端口
三、权限查询
1.查看当前权限
2.获取域SID
3.查询指定用户的详细信息
四、判断是否存在域
1.ipconfig查询
2.查看系统详细信息
3.查询当前登录域及登录用户信息
4.判断主域
五、探测域内存活主机
1.NetBIOS快速探测
2.ICMP协议探测
3.ARP协议探测
（1）arp-sacn工具
（2）Empire中的arpsacn模块
（3）Nishang中的Invoke-ARPScan.ps1脚本
(4)通过TCP/IP端口探测内网
一、内网信息收集简介 渗透测试进入内网之后，首先要对所处的内网环境进行判断，有以下三个方面：
对当前机器角色进行判断
对当前机器所处网络环境及拓扑结构进行判断分析
对当前机器所处区域进行判断
1.对当前机器角色进行判断 对当前机器角色的判断，是指判断当前机器是普通 Web 服务器、开发测试服务器、公共服务器、文件服务器、代理服务器、DNS 服务器还是存储服务器等。具体的判断过程，是根据机器的主机名、文件、网络连接等情况综合完成的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72c45ac49aeca2178cd1c935f0280c98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87917b1965180ee60ad26a0869e6a1b0/" rel="bookmark">
			【五】从jdbc到mybatis看这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发Java程序都知道mybatis是ORM框架，对象-关系映射（Object-Relational Mapping，简称ORM），所谓的 ORM 框架就是一种为了解决面向对象与关系型数据库中数据类型不匹配的技术，它通过描述 Java 对象与数据库表之间的映射关系，自动将 Java 应用程序中的对象持久化到关系型数据库的表中。
最早开发javaweb程序都是使用jdbc操作数据库，会有很多的弊病，之后ORM框架出现了解决了这些问题，本文主要介绍一下mybatis是怎么获取数据库连接的。如下是原生态jdbc的代码：
//注册驱动 Class.forName("com.mysql.jdbc.Driver");); //获取连接 Connection conn= DriverManager.getConnection("jdbc:mysql://ip:3306/dbname", "username", "password"); //获取预执行对象 PreparedStatement preparedStatement = conn.prepareStatement("select * from t_user"); //执行结果, 获取结果集 ResultSet resultSet = preparedStatement.executeQuery(); //遍历结果集 while(resultSet.next()){ System.out.println(resultSet.getString("username")); } //释放资源 conn.close(); preparedStatement.close(); resultSet.close(); 一、获取数据库连接
如下是mybatis执行的一段代码
mybatis执行insert实际实现是在doUpdate()方法中，通过debug,我们可以看到prepareStatement方法，
接着debug,我们可以看到获取数据库连接的方法
再往里debug就可以看到，打开数据库连接的方法
至此，mybatis获取数据库连接调用就清晰了
二、数据库驱动Driver加载
不管是mysql或者oracle等等数据库的连接,在我们Java程序中,都需要将相应的数据库驱动jar包加入到Java应用程序中
下面通过mybatis的两个DataSource数据源实现方式来看我们的数据库驱动是如何加载的呢？
先来看mybatis的UnpooledDataSource.java数据源
在以上static块中,通过使用DriverManager.getDrivers()就能在Java程序中获取得到我们当前以及注册的数据库驱动Driver类,那么这些Driver类是何时注册的呢？
从registeredDrivers中遍历得到Driver的Vector集合，那么registeredDrivers是什么时候初始化进去的呢？在DriverManager.java静态代码块找到了loadInitialDrivers();
这就是我们要找的驱动加载方法了
从代码中我们看到通过ServiceLoader.load(Driver.class); ServiceLoader是实现了Iterable迭代器的，往下看：
此处的hasNext()方法实际调用的是ServiceLoader中的内部类LazyIterator中的hasNext()方法。
接着往下我们找到了hasNextService()方法，因为传递过来的类是java.sql.Driver
所以此处fullName的全称是:META-INF/services/java.sql.Driver，此时我们去查看mysql的驱动jar包,看是否存在该文件
显然能够找到配置文件，看mysql的驱动代码
可见registeredDrivers集合在此处得到初始化，我们回过头来再看LazyIterator迭代器中的方法nextService()，可以看到从配置文件类中读取到驱动类Driver，通过反射调用产生Driver实例。
S p = service.cast(c.newInstance()); 总结：mybatis从配置文件类中读取到驱动类Driver，通过Class.forName方法将该类加载到JVM中，此时会调用执行Driver类中的static方法块，将Driver类驱动注册到DriverManager中。
至此驱动加载过程分析完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db4301ae030db6c0b7dc58e517df0ee/" rel="bookmark">
			超级详细的手把手教你使用Lighthouse更好推动项目性能优化，性能指标详解，优化方法，需要关注指标分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌸Lighthouse是什么—一种工具 Lighthouse 是一个开源的自动化工具，用来测试页面性能。 🌸为什么要用Lighthouse----提升用户体验 Web性能可以直接影响业务指标，例如转化率和用户满意度分析收集各种应用页面性能指标，并进行评估，以此我们可以根据评估结果进行针对性优化，不断提升用户体验 🌸Lighthouse怎么用----用法多样，根据需求进行选择 目前官方提供了4种使用方式： Chrome 开发者工具（DevTools）Node CLINode ModuleChrome 扩展 方式一：Chrome 开发者工具（DevTools） 1.在chrome浏览器中打开你需要测试的网站，按f12进入开发者调试模式2.找到Lighthouse-点击 generate report,它会对页面进行相关性能的检查，最终生成报告
方式二：使用Node Cli 1.安装node 8 或更高版本
2.全局安装lighthouse:
npm install -g lighthouse 3.新建一个文件夹，初始化，可根据自己需求进行绑定git仓库
npm init -y 4.使用终端输入下面命令(这里以m.jd为例）
npx lighthouse https://wqs.jd.com/data/coss/important/msportal_recovery.shtml?tpl=index --locale zh --quiet --chrome-flags="--headless" --only-categories=performance --preset=desktop 5.生成报告
6.打开报告
7.分析报告，从不同角度来对照分析我们的关注指标
7.1 用户角度 7.1.1 项目首屏加载时间 例如，从打开系统到看到系统页面的时间
关注点：FCP
First Contentful Paint(首次内容渲染)表示浏览器渲染出第一个内容的时间，这个内容可以是文本、图片或SVG元素等，不包括iframe和白色背景的canvas元素
7.1.2 交互响应时间，例如 当我们点击某个按钮，到系统发送请求获取结果，此过程的消耗时间
关注点：FID 点击直达WEB-DEV-FID文档
首次输入延迟 (FID) 是测量加载响应度的一个以用户为中心的重要指标
因为该项指标将用户尝试与无响应页面进行交互时的体验进行了量化，低 FID 有助于让用户确信页面是有效的
首次输入延迟 (FID) 指标有助于衡量您的用户对网站交互性和响应度的第一印象
FID 测量从用户第一次与页面交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对交互作出响应，并实际能够开始处理事件处理程序所经过的时间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db4301ae030db6c0b7dc58e517df0ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4170fc5a4b1016a87cafed953da10221/" rel="bookmark">
			电子信息工程专业如何安排学习？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大一 在众多的工科院校中一定有一个专业叫电子工程信息工程专业，这个专业一般是开设在电信学院下面的。那么电子信息工程专业的学生主要是学习那些知识呢？电子信息工程专业属于工科专业，所以决定了这个专业主要是应用为主，就是不会涉及到太多的基础研究，这个是和理科专业有很大的区别的。大一的时候和所有的专业一样都有公共课和专业课。公共课就是数学、英语、马克思这些，这些基本所工科所有的专业都会上的课。除了公共课之外就是专业课了大一的时候一般来说先有一门专业课叫模拟电路，虽然我们已经进入了数字化的时代了，但是数字电路的基础还是模拟电路，所以我们还是要从基础的模拟电路先学起来。不过要提一点的是，因为模拟电路是一切数字电路的基础，所以设计的知识都是比较深奥的，大一这时候学习起来可能比较吃力，但是好处是因为数字时代的到来，现在我们除了芯片原厂，在你出去工作的公司都很少要使用到模拟电路的知识，或者说使用到的模拟电路的知识都是比较简单的。到了大二下学期就可以上一门课叫数字电路了。如果我们有一些计算机知识就知道，在计算机里面，我们所有的信息都是用0和1来保持的，就像这段文字，在计算机里面保持也是0和1进行保存。那么在计算机中怎么表示这个0和1呢？在最简单的数字电路里面我们将输出高电平认为是1，输出低电平认为是0。
总结
在大一的时候主要学习两门课程，模拟电路和数字电路。
大二 1、因为电子信息这个专业主要还是应用为主，其实模拟电路和数字电路这些专业课还都是比较底层部分的课程，到了大二你就正式进入了应用部分的课程了，这时候学校就会开设C语言的课程，C语言是什么？C语言可以理解为和计算沟通语言，通过C语言你可以编写程序，将你写好的程序编译之后就可以烧录到MCU当中，这时候MCU就可以按照你的程序执行了。这样说起来有点深奥，什么所MCU？什么是程序？举一个例子，假设我们是一个毛孩子打开了家里面的洗衣机的电路板，这时候我们会看到一个大大的黑色的正方形芯片，这个芯片就是MCU。但是光有MCU也不管用，既然是洗衣机，那么就需要控制电机让电机转动，然后衣服才能洗干净。这时候你就需要编写一个让电机转动的程序控制电机的转动，这个程序就是使用C语言进行编写的。
总结：大二学习C语言和MCU控制技术。这两门课就非常实用了，如果你毕业后从事的是嵌入式软件开发，基本就是使用C语言进行编码设计了，所以C语言是要学好的课程。
2、原理图和PCBA设计，如果你对硬件比较感兴趣，那么可能你就需要学好的课程就是原理图和PCBA设计了，大家都拆过电路板，绿色的电路板上面有很多的芯片也有很多的电阻电容，那么在电路板上面的电子元器件都有什么用呢？为什么要放在上面？如果你学习了数字电路和模拟电路这两个课程之后，你就会非常的清楚知道电阻和电容在电路板上面的作用了，这时候你就可以动手设计你的原理图了，原理图设计完成之后你就可以通过原理图绘制你的PCB，然后将你的PCB文件发到工厂就可以生产PCB的板子，就是我们平常的电路板，然后将芯片贴到PCB板上就得到了我们的电路板了。在以后的工作中如果是从事嵌入式硬件工程师，那么这个课程你就需要学好了，如果从事的软件工程师，只要会查看原理图即可，并不需要学会绘制PCB。
大三 1、大三之后你基本对于硬件和软件都有了基本的了解，那就是要综合应用起来了，这时候你应该使用你大一和大二学到的知识制作一个完整的小产品，比如智能小车等，这时候就是考验你的动手能力和编程能力了，如果对于之前的知识你都学习的非常扎实，那么你制作起来也就非常的容易了。你可以制作一个小车可以跟着黑线行走，也可以通过手机蓝牙控制小车的前进和后退，如果你能制作出来这个小车，证明你上面的知识学的还算是比较扎实了，因为就单单这个简单的小车，很多电子信息工程专业的学生毕业了还是做不出来。
2、在大二你学习了C语言，但是编程可能已经入门了，但是编写代码代码的能力还有很大的提升空间，这时候你就可以去学习一些操作系统的知识和数据结构，因为编程就是程+算法，数据结构就是程序的基础算法，如果你能深入的理解了数据结构，对你的编码水平又有了很大的提升。
gongzong号 欢迎扫码关注本人gongzong号：公众号上分享更多嵌入式知识和资料，分享个人学习嵌入式的心得体会。欢迎大家一起来玩呀。也可以在gongzong号留言+ V一起讨论学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0bd234081cab4b5da838c08000275b3/" rel="bookmark">
			Pycharm查看函数源码时进入pyi文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程主要是为了解决一个在使用 Pycharm时常见的一个问题，这个问题虽然不会对写代码造成很大的影响，但是对于我个人而言是一件比较厌烦的事情。
问题描述 该问题出在我在使用Pycharm时，遇到不熟悉的函数想去查看源码中的注释，我使用Pycharm快捷键Ctrl + B或者按住Ctrl点击对应的函数，可以正常跳转，但是却没有跳转到正常的源码，而是跳转到了一个.pyi文件，在.pyi文件中只有函数的调用，没有对应的详细注释。
.pyi 文件是类型提示文件，用于提供对代码中类型注解的补充。这些文件通常用于类型检查和静态分析工具，例如 MyPy。.pyi 文件中通常只包含函数、类和方法的签名信息，而没有实际的代码实现。
.pyi文件中只有函数的调用规则，无法看到注释及源码。
网上错误教程示例 网上的所有教程都是要我们在设置中将.pyi文件存根删除。
删除完毕后又会有很多新的问题产生，例如Pycharm在预编译的时候无法找到函数，导致预编译报错（画红色波浪线）；查看函数源码时会定位到多个同名函数（可能在其他库中存在同名函数）。
这个时候想要去找到函数源码难度也很大。
正确解决方法 同样是进入到设置，找到文件类型，点击忽略的文件和文件夹。
在这里添加*.pyi文件。
这个时候再次使用快捷键查看源码即可查看到真实的源码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3924c6a381052eb70711044028ff7228/" rel="bookmark">
			使用Python将Word文档转换为PDF的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要： 文介绍了如何使用Python编程语言将Word文档转换为PDF格式的方法。我们将使用python-docx和pywin32库来实现这个功能，这些库提供了与Microsoft Word应用程序的交互能力。
正文： 在现实生活和工作中，我们可能会遇到将Word文档转换为PDF格式的需求。PDF格式具有广泛的应用，可以保留文档的格式和排版，并且可以在不同平台上方便地共享和查看。在本文中，我们将介绍如何使用Python来实现这个转换过程。
首先，我们需要安装两个Python库：python-docx和pywin32。这些库分别提供了处理Word文档和与Microsoft Word应用程序交互的功能。您可以使用以下命令来安装这些库：
pip install python-docx pywin32 一旦我们安装好所需的库，我们就可以编写Python代码来进行转换操作。下面是一个示例代码：
import os import win32com.client as win32 from docx import Document def convert_to_pdf(input_path, output_path): # 创建Word应用程序实例 word_app = win32.gencache.EnsureDispatch('Word.Application') # 设置应用程序可见性为False（不显示Word界面） word_app.Visible = False try: # 打开Word文档 doc = word_app.Documents.Open(input_path) # 保存为PDF doc.SaveAs(output_path, FileFormat=17) doc.Close() return True except Exception as e: print("转换失败：" + str(e)) return False finally: # 关闭Word应用程序 word_app.Quit() # 输入和输出文件路径 input_file = "C:\\mydocs\\光项目商务\\验收报告2020.docx" output_file = "C:\\mydocs\\光项目商务\\验收报告2020.pdf" # 调用函数进行转换 success = convert_to_pdf(input_file, output_file) if success: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3924c6a381052eb70711044028ff7228/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/450568cd8bb5f3721bc50da087e8fdd3/" rel="bookmark">
			python自动化：读取word表格并保存excel中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python自动化：读取word表格并保存excel中 一、问题需求 ​ 工作中因为业务需求，经常会收到版式相同的word的文件，需求汇总文档里的表格数据，为了方便，可以先汇总至excel中，以备后续使用。
二、程序分析 需要设计两个函数： 函数1：read_word_table()，读取word中所有table，保存于字典data_dict； 函数2：save_table_to_sheet()，获取字典data_dict，变量value，在一个excel文件中分别保存于不同的sheet中 三、操作代码 1 函数read_word_table() 读取word中所有table，保存于字典data_dict；
# 读取word中table def read_word_table(self): try: data_dict = {} # 用来存储数据 doc = Document(self.file_name) # 读取文档 num = 0 flag = True while flag: table_list = [] try: one_tbale = doc.tables[num] # 提取一个表格对象 tb1 = one_tbale # 提取一个表格对象 for i in range(0, len(tb1.rows)): row_lis = [] row = tb1.rows[i] # 提取表格的每一行对象 tb1_row_cells = row.cells # 提取到行里面的所有的格子 for j in range(len(tb1_row_cells)): tb1_row_cell = tb1_row_cells[j] cell_text = tb1_row_cell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/450568cd8bb5f3721bc50da087e8fdd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0734eea7c4df7829d14c751d5ef6dcac/" rel="bookmark">
			NVIDIA Jetson Nano主机的autoware的学习与demo运行-第7章-Autoware源码安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Autoware源码安装 建立workspace
mkdir-p autoware.ai/src cd autoware.ai 这个是下载了一个名为autoware.ai.repos的文件，是为了方便管理多个git库而开发+的Python脚本
wget -O autoware.ai.repos "https://gitlab.com/autowarefoundation/autoware.ai/autoware/raw/1.14.0/autoware.ai.repos?inline=false" 将autoware.ai.repos中的git库文件下载到src文件夹中
vcs import src &lt; autoware.ai.repos 进行初始化（这里使用的是本系列文章的第2章中的小鱼源）
sudo rosdepc init rosdepc update 进行编译 rosdep install -y --from-paths src --ignore-src --rosdistro $ROS_DISTRO 会稍微比较久，稍等片刻后
AUTOWARE_COMPILE_WITH_CUDA=1 colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release 但是在运行过程中可能会出现问题
解决方法就是安装对应的ROS包，使用命令
sudo apt-get install ros-melodic-（缺少的包的名字） 但是在部分报错的包一般是不会用到的，可以在指令后面加入参数【–continue-on-error】忽略报错，到在后面的应用时有需要再添加。
不要在不需要的地方浪费太多时间。
AUTOWARE_COMPILE_WITH_CUDA=1 colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release --continue-on-error 等待时间也是比较久
在此过程中，累计死机一次，卡死两次，nano主机的算力孱弱，要有耐心
建议在编译命令后面添加参数【-j 2】只使用CPU的两核进行编译。虽然慢点，但也不至于死机。
完成后就可以运行autoware看看是否安装成功
cd autaware.ai/ source install/setup.bash roslaunch runtime_manager runtime_manager.launch 此时会又启动一个Autoware的终端
Autoware的界面
至此，autoware安装完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a35504a74093fc6451584bcace2dd0d9/" rel="bookmark">
			【JS】实现系统取色器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果 使用环境说明 根据当前的信息，截至到 2023 年 8 月，以下是一些支持使用 new EyeDropper() 的主要浏览器（可能还有其他浏览器也提供了类似的功能）：
Google Chrome：从 Chrome 94 版本开始引入了 new EyeDropper() 构造函数，可以通过 JavaScript API 来创建和使用 EyeDropper` 工具。
Microsoft Edge：从 Edge 94 版本开始，支持 new EyeDropper() 构造函数，你可以在 Edge 中使用 JavaScript 来创建和操作 EyeDropper。
Mozilla Firefox：在 Firefox 浏览器中，可以使用 colorpickereyedropper 事件来实现类似的功能，不过具体的 API 是以事件形式而不是构造函数的形式提供的。
请注意，不同浏览器可能对 new EyeDropper() 的支持程度有所不同，具体支持的版本也可能会随着时间的推移而更新。因此，在实际开发中，建议查阅各个浏览器的官方文档或平台支持信息以获取最新的支持状态和详细的使用说明。
以下浏览器版本经过测试支持使用EyeDropper Microsoft Edge：Microsoft Edge 版本 115.0.1901.188 (正式版本) (64 位) 以下浏览器版本经过测试不支持使用EyeDropper 360安全浏览器：360安全浏览器13 版本号: 13.1.1469.0|内核版本:86.0.4240.198 Chrome浏览器: 版本 86.0.4240.198（正式版本） （32 位）
▶Uncaught (in promise) ReferenceError: EyeDropper is not defined
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a35504a74093fc6451584bcace2dd0d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/affd4af1e851a730a829f5e76d49617e/" rel="bookmark">
			ant-design-vue 4.x升级问题-样式丢失问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[vue] ant-design-vue 4.x升级问题-样式丢失问题 项目环境问题场景解决方案 该文档是在升级ant-design-vue到4.x版本的时候遇到的问题
项目环境 "vue": "^3.3.4", "ant-design-vue": "^4.0.0", "vite": "^4.4.4", "unplugin-vue-components": "^0.25.1" 以上是开发项目时使用的包以及包的版本，使用的脚手架是vite
问题场景 当使用ant-design-vue3.x版本时没有任何问题，但是当升级ant-design-vue到4.0版本时，因为ant-design-vue4.x使用了css-in-js需要修改vite.config.js配置
plugin:[ Components({ resolvers: [AntDesignVueResolver({ importStyle: "less" })] }), ] 变更为
plugin:[ Components({ resolvers: [AntDesignVueResolver({ resolveIcons: true, cjs: true, importStyle: false })] }), ] 修改后当开发环境正常展示的时候，打包出了问题，发现自定义的组件以及单文件中通过&lt;style lang="css"&gt;&lt;/style&gt;定义的样式都失效了，样式中的图片也自然失效了
通过观察发现打包生成的文件中存在样式，但是确没有被引用，一直没有找到有效的解决方案，在ant-design-vue官网中提到说是插件’unplugin-vue-components’会引发一些不可预测问题，尝试删除unplugin-vue-components的使用
解决方案 unplugin-vue-components 插件是一个按需引入的插件，所以删除该插件后，也要删除对应生成的 components.d.ts 文件，然后手动引入所有使用的 ant-design-vue 组件在打包后发现正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb36ac51a190692f7bd59cfdb9e90fb/" rel="bookmark">
			《OWASP代码审计》学习——跨站脚本注入（XSS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、跨站脚本概述 1.什么是跨站脚本 跨站点脚本(XSS)是一种编码注入漏洞。它通常出现在 web 应用程序中。XSS 使攻击者能够向其他用户浏览的网页中注入恶意内容。XSS 允许攻击者绕过访问控制，它是 OWASP Top10 最常见的漏洞之一。XSS 是网络服务器上的第二大漏洞。根据易受攻击站点处理的数据的敏感性和站点组织实施的任何安全缓解措施的性质，此漏洞的严重性/风险可能从有害到主要安全风险不同等级
2.类型 有三种类型的 XSS，反射 XSS，存储 XSS，和基于 DOM 的 XSS。每种类型都有不同的方式向服务器传递恶意负载。攻击的效果是一样的。
3.审计内容 跨站点脚本漏洞很难从 web 应用程序中识别和移除。搜索缺陷的最佳实践是执行严格的代码审计，并搜索用户通过 HTTP 输入的内容可能在任何系统 HTML 输出的地方。
（1）不受信任的数据不会像超文本标记语言或 JavaScript 那样在相同的超文本传输协议响 应中传输。 （2）当数据从服务器传输到客户端时，不可信的数据和 HTTP 响应必须被正确编码。不要假 设服务器上的数据是安全的。最佳做法是始终审计数据。 （3）当引入到 DOM 中时，不可信数据必须使用以下应用编程接口之一来引入: a) Node.textContent b) document.createTextNode c) Element.setAttribute(仅第二个参数) 代码审计者也应该知道 HTML 标签(比如&lt; img src…&gt;，&lt; iframe…&gt;，&lt; bgsound src…&gt;等。可以用来传输恶意的 JavaScript。网络应用程序漏洞自动工具/扫描仪可以帮助发现跨站点脚本漏洞。然而，他们无法找到所有的 XSS 漏洞，因此手动代码审计很重要。手动代码审计也不能涵盖所有内容，但是基于您的风险水平，实施深度防御方法始终是最好的方法。OWASP Zed 是一个易于使用的集成渗透测试工具，用于发现网络应用程序中的漏洞。ZAP 提供了自动扫描仪以及一套工具，允许您手动查找安全漏洞。它充当一个网络代理， 108您可以将浏览器指向它，这样它就可以看到流向某个站点的流量，并允许您对应用程序进行爬虫、扫描、模糊和攻击，还有其他开源和商用扫描仪。
二、.NET ASPX框架 关于 ASPX.网页代码审计应该审计以确保 web 配置文件不会关闭页面验证。
&lt; pages validateRequest="false" /&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb36ac51a190692f7bd59cfdb9e90fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/211d52218ce95b131fb63300ae9cff60/" rel="bookmark">
			Sourcetree打不开、无法启动、闪退解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不知道你们有没有出现过突然Sourcetree软件打不开了，打开的时候只出现弹框一两秒。
后来发现只要删除一个文件即可恢复
路径查找找到删除的文件就可以直接运行了
C:\Users\admin\AppData\Local\Atlassian
顺便告诉大家一个快捷找到删除文件的路径方式
1、右击桌面图标，选择打开文件所在的位置
2、后退文件夹到Local，然后找到Atlassian点进去，然后删除如下图的第二个文件夹即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15cb620a9c89e2de55e39e959b1538a3/" rel="bookmark">
			Android平台HWASan使用介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android平台HWASan使用介绍 Hardware Address Sanitizer (HWASan)是应在开发期间使用的内存 bug 检测工具。对于 arm64，建议使用 HWASan；对于 32 位 arm 和非 Arm 平台，建议使用 ASan。两者提供的功能相同，并且都应当用于检测用户空间代码中的内存安全 bug。
如何启用HWASan 在Android系统编译时加入如下配置：
SANITIZE_TARGET=hwaddress 在Rockchip的Android11及以上平台的修改如下：（在device下面的产品目录的BoardConfig.mk中修改）
Android13_29_sdk/device/rockchip/rk3588$ git diff diff --git a/BoardConfig.mk b/BoardConfig.mk old mode 100644 new mode 100755 index 5a6cb59..47db367 --- a/BoardConfig.mk +++ b/BoardConfig.mk @@ -128,3 +129,6 @@ BOARD_BASEPARAMETER_SUPPORT := true #pcie ethernet PRODUCT_HAVE_PCIE_ETHERNET := true +SANITIZE_TARGET=hwaddress 修改后完整编译Android并烧写固件即可。
了解 HWASan 报告 当 HWASan 工具检测到内存 bug 时，系统会通过 abort() 终止该进程，并将报告输出到 stderr 和 logcat。与 Android 上的所有原生代码崩溃问题一样，HWASan 错误也可以在 /data/tombstones 下找到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15cb620a9c89e2de55e39e959b1538a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f7092e49fd2ac1464f260be181f03c/" rel="bookmark">
			Try removing the extra positional arguments, or specifying the name for named arguments.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错图片应该是这样的。
组件传参与一般的函数传参不一样，我们需要在调用它的地方，括号里面加上每个参数声明时候的名字 。
例如：
声明时候 ：
在调用时候： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4cee7d37acdf8bcc6da20f4a36471ce/" rel="bookmark">
			【随手查】数据手册研读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个付费课程的学习之旅，将课程中所学到的东西以及实践中学到的悟到的记录下来，方便日后查看，持续更。。。
笔记目录 一、电阻1、贴片电阻表面的阻值标记2、额定功率下降曲线3、贴片电阻的温度系数 二、电容1、电容值的计算公式2、ESR曲线3、如何获取电容的特性参数4、电容是否都区分正负极 三、电感1、电感的应用2、电感的几个参数 四、瞬态抑制二极管，TVS五、压敏电阻六、发光二极管🚀datasheet中的常见名词 一、电阻 1、贴片电阻表面的阻值标记 （1）一般封装≥0805的（0805、1206、1210、2010、2512），使用4位E96标记
4位E96：四位数字为 ABCD，其表示的阻值为 ABC×10^D
（2）0603的E24
3位E24：标记三位数字为 ABC,其表示的阻值为 AB×10^C
（3）0603的E96
这个就需要查表了
前二位数字表示 E-96 系列阻值代码（可查表一），后一位字母表示乘数代码（可查表二）。需要注意的是不是所有的厂家都是按照下面的表格，只是大部分是这样子。具体还是得查看对应厂家给的电阻的datasheet。
表一：
表二：
2、额定功率下降曲线 当环境温度超过70℃时，电阻的功率会降低，无法达到额定功率。
（所以一般不要满功率输出？）
3、贴片电阻的温度系数 电阻的阻值是会随着温度的变化而变化的。
ppm：part per million ，百万分之……
二、电容 1、电容值的计算公式 2、ESR曲线 ESR是指电容的等效串联电阻或阻抗。
下图圈起来的这个点称为谐振点，当频率大于谐振点的频率之后，电容的阻抗特性呈现电感特质，频率越高，感性阻抗越大。
以下内容来自https://murata.eetrend.com/article/2020-11/1003980.html ，仅为日后查看笔记方便，侵删。
（1）关于这个曲线的来源
（2）电容的容性与抗性
在频率很低的时候，可以看到，感抗远小于容抗，并且复阻抗的相位为负值，说明电流超前电压，这是典型的电容充电特性，所以说，电容在低频主要表现为容性。
而在高频的时候，感抗远大于容抗，复阻抗的相位为正值，说明电压超前电流，是典型的电感施加电压时的行为特征，所以说，电容在高频时表现为电感特性。
而在谐振时，容抗和感抗相抵为0，此时电容的总阻抗最小，复阻抗相位为0，表现为纯电阻特性，这个点就是电容的自谐振频率。
总结：在谐振频率左边，电容主要呈容性；在谐振频率右边，电容主要呈感性；在频率点上，表现为电阻特性。
（3）大电容滤低频，小电容滤高频
容量大的电容ESR比较小，谐振频率比较低，主要滤低频；容量小的电容ESR比较大，谐振频率比较高，主要滤高频。
（4）滤波时为什么要大电容并联小电容
当频率大于f1并小于f2时，大电容呈感性小电容呈容性，两者并联，就像是一个电感和一个电容并联，构成了LC并联谐振电路，并在某一个频率点发生并联谐振，导致该处阻抗很大。就能对该范围的频率的信号产生一定的阻碍作用。
（5）为什么滤波的时候要同样阻值的电容并联？
n个相同的电容并联，谐振频率和单个电容一样，但是在谐振点处的阻抗是原来的n分之一，因此，多个相同的电容并联后，阻抗曲线整体形状不变，但是各个频点的整体阻抗变小。
3、如何获取电容的特性参数 网址：https://ds.murata.co.jp/simsurfing/mlcc.html?lcid=zh-cn
（1）获取某一电容容值的datasheet
（2）获取不同型号电容的同一参数的对比图
比如获取不同容值对应的谐振频率，
获取0.4pf的谐振频率
获取4pf的谐振频率
获取10pf的谐振频率
然后就可以得到多个电容容值谐振频率的对比图了
4、电容是否都区分正负极 贴片电容（MLCC）不区分正负极
钽电容与电解电容都区分正负极
三、电感 1、电感的应用 电感主要应用于高频滤波与电源
电感值范围自谐振频率高频用电感（谐振电路、扼流、射频滤波器——LPF、BPF、HPF）0.6~390nH12GHz电源用电感（BUCK、BOOST等DCDC电源拓扑功率电感）1~470uH几十到几百MHz 2、电感的几个参数 （1）直流电阻（DirectiveCurrent Resitance，DCR）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4cee7d37acdf8bcc6da20f4a36471ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60d217ae174318ba0ac79c349a69ffe1/" rel="bookmark">
			Flutter、Android Studio 安装详细步骤以及常错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、介绍
三、安装
(一）、安装Flutter SDK
1）双击文件夹，打开之后就是这样：​编辑
2）双击此文件：​编辑
3）此过程问题：
(二）、配置 Flutter SDK 环境变量
在 windows输入框中输入 env 找到编辑系统环境变量
(三）、安装 Android Studio
1）问题
​编辑
2）双击打开
3）初次使用​编辑 (四）、配置Android SDK的环境变量
1） 找到你所下载他的位置，打开目录。里面应该是这样的​编辑
2）复制该路径，再次打开 编辑环境变量，添加如下变量值：​编辑 再双击打开 Path ，添加下面两个​编辑
3）问题解决
四、实现虚拟设备
(一）、点击​编辑
（二）、选择操作系统，下载：​编辑
（三）、选择加速，一定要选择这个​编辑
（四）、运行项目
一、前言 我出这个教程，是因为我在安装过程遇到许多问题，耗费了很多时间，为了帮助初次安装 flutter 的小伙伴能够更顺利。当然学者方面也是需要一点Java基础的，所以本教程基于你的电脑成功安装jdk，并环境变量配置无问题。
二、介绍 Flutter 为软件开发行业带来了革新：只要一套代码库，即可构建、测试和发布适用于移动、Web、桌面和嵌入式平台的精美应用。
Flutter官网：Flutter: 为所有屏幕创造精彩 - Flutter 中文开发者网站 - Flutter
从上面可以看出，学习 Flutter 已是重中之重的事情！！！
下面就说一下使用 Flutter 所需要安装的东西以及初次使用，本教程基于最新版的安装（当然每个版本相差不大）
三、安装 (一）、安装Flutter SDK 安装压缩包：（点击即可下载）flutter_windows_3.10.6-stable.zip
也可以到官网下载其它版本：Flutter SDK 归档版本列表
下载完，就是一个压缩包，解压后就是这样的一个文件夹
在这里说一点：（放哪里都影响不大）
如果你 C盘 空间大，就放 C盘；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60d217ae174318ba0ac79c349a69ffe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855bd968c3695177698d9f9205151cff/" rel="bookmark">
			git Bash修改默认路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用git进行命令行的输入是很便捷的，但是在Windows平台，因为存在盘符的概念，导致路径的切换过程变得繁琐而头疼，在打开git Bash的时，系统会默认将当前路径设置为C盘的用户路径，但是我们日常使用的时候基本都不会在用户路径，于是我们需要将git Bash默认路径修改。
首先查看当前的默认路径，输入命令pwd查看当前路径， 得到如下返回结果：
可以看到，在我的电脑上的默认路径为C盘Users下的Mobius文件夹，这个是怎么来的呢？
我们可以在git Bash上右键，点击【属性】
然后系统就会打开如下界面：
可以看到，上图中用红色方框框住的内容就是系统为什么会自动跳转到用户路径的原因，--cd-t0-home就是在打开git Bash的一瞬间会执行的一条语句，将路径切换到home，但是Windows下面没有home，于是它会根据起始位置填写的参数进行查找，%HOMEDRIVE%%HOMEPATH%其实就是一个系统变量，对，就是那个很多软件安装都需要配置的系统变量或者叫环境变量，但是这个是系统内置的，我们不需要手动配置。
知道了其中的原因之后，我们可以动手修改了，首先将【目标】的--cd-t0-home删除，然后将【起始位置】修改到你自己经常需要进入的工作目录，比如我这里就直接改为D盘，输入D:\
修改之后点击【确定】，此时可能会提示要管理员权限，点击【是】即可，再次打开git Bash，输入pwd查看当前路径：
可以看到路径已经修改成功，默认路径为d盘。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d8ede854f0c7441d11d32632e50dff/" rel="bookmark">
			【Java 多线程】【Synchronized 原理&amp;死锁】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、Synchronized 原理
1.1 加锁（锁的升级）
1.1.1 无锁
1.1.2 偏向锁
1.1.3 自旋锁 1.1.4 重量级锁 1.2 锁的优化
1.2.1 锁消除
1.2.2 锁粗化
2、死锁
2.1 死锁是什么
2.2、死锁产生的原因（4个必要条件）
2.3 容易出现死锁的情况
2.4. 解决死锁
1、Synchronized 原理 结合锁策略，总结出 Synchroized 具有的特性（JDK1.8）
开始是 乐观锁 ，如果出现 锁冲突，转换为 悲观锁开始是 轻量级锁， 锁被持有的时间较长，转换为 重量级锁；实现轻量级锁 用到 自旋锁是 不公平锁 ，锁竞争是 可重入锁不是读写锁 1.1 加锁（锁的升级） Synchroized 对对象加锁时，根据情况，JVM将Synchroized 锁分为：
无锁、偏向锁、轻量级锁、重量级锁 状态，依次升级，不能降级
1.1.1 无锁 无锁：没有加任何锁，不会出现锁竞争
1.1.2 偏向锁 偏向锁：存在锁竞争，尝试加锁状态，但不是真正的加锁，而是打上个偏向锁的标记，记录这个锁属于哪个线程
如果没有其他的线程来竞争，就不用实际加锁后续有其他的线程来竞争，取消原来的偏向锁状态，实际加上锁，进入轻量锁 偏向锁本质是：延迟加锁，非必要，不加锁，避免加锁的开销
偏向锁标记：区分是否真正需要加锁，有其他的线程来打标记，JVM就会通知赶紧加上锁
1.1.3 自旋锁 自旋锁：遇到锁竞争，就是自旋锁（轻量级锁）
轻量级锁 是通过 CAS来实现自旋锁一直处于自旋状态，比较浪费CPU资源，因此达到一定时间/次数，就不自旋了 1.1.4 重量级锁 重量级锁：锁竞争更加激烈，多条线程进入自旋，就会升级为重量级锁
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d8ede854f0c7441d11d32632e50dff/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/104/">«</a>
	<span class="pagination__item pagination__item--current">105/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/106/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>