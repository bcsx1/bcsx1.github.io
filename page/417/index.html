<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65cd78c83ba433a468e8bf1dd5a9ed34/" rel="bookmark">
			patchelf 的功能以及使用 patchelf 修改 rpath 以解决动态库问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 低版本 libc 库运行高版本 libc 库编译的程序 这篇博客中我描述了使用 patchelf 来修改动态库链接器的方法，在本篇文章中，我完整的列举下 patchelf 的功能，并介绍另外一个实际的应用。
patchelf 具有的功能 运行 patchelf -h 能够得到如下信息：
syntax: patchelf [--set-interpreter FILENAME] [--page-size SIZE] [--print-interpreter] [--print-soname] Prints 'DT_SONAME' entry of .dynamic section. Raises an error if DT_SONAME doesn't exist [--set-soname SONAME] Sets 'DT_SONAME' entry to SONAME. [--set-rpath RPATH] [--remove-rpath] [--shrink-rpath] [--allowed-rpath-prefixes PREFIXES] With '--shrink-rpath', reject rpath entries not starting with the allowed prefix [--print-rpath] [--force-rpath] [--add-needed LIBRARY] [--remove-needed LIBRARY] [--replace-needed LIBRARY NEW_LIBRARY] [--print-needed] [--no-default-lib] [--debug] [--version] FILENAME 中文翻译如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65cd78c83ba433a468e8bf1dd5a9ed34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bbb2c1f8328a736c69238eaf8c44e24/" rel="bookmark">
			三角函数正交性的推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 定理：
一个三角函数系：1 cosx sinx cos
一个三角函数系：1，cosx , sinx , cos2x , sin2x , … , cosnx , sinnx , … 如果这一堆函数（包括常数1）中任何两个不同函数的乘积在区间[-π, π]上的积分等于零，就说三角函数系在区间[-π, π]上正交。
以上各式在区间[-π, π]的定积分均为0，第１第２式可视为三角函数cos和sin与１相乘的积分；第3-5式则为sin和cos的不同组合相乘的积分式。除了这5个式子外，不可能再有其他的组合了。注意，第4第5两个式中，k不能等于n，否则就不属于“三角函数系中任意两个不同函数”的定义了，变成同一函数的平方了。但第3式中，k与n可以相等，相等时也是二个不同函数。下面对上面5个式子进行验证推导：
等式一的推导过程： 图示分析：
从图中，可以直观看出余弦曲线在【-π, π】区间的积分，正负半周相互抵消，正好是0。
等式二的推导过程： 图示分析：
从图中，可以直观看出正弦曲线在【-π, π】区间的积分，正负半周相互抵消，正好是0。
等式三的推导过程： 图示分析：
根据一式和二式，可知正弦曲线和余弦曲线在【-π, π】区间的积分都为0，所以sinx*cosx在【-π, π】区间的积分也为0。
等式四的推导过程： 图示分析：
从图中可以看出余弦和余弦曲线的乘积在【-π, π】区间的积分都为0。
等式五的推导过程： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c16b4d72b637fc41f1c1713ec05b86/" rel="bookmark">
			Spring Security集成与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 security会对服务端的接口添加权限过滤，不具备权限的请求将被拒绝。
引入security 要引入security，只需添加依赖即可：
在pom.xml中引入security：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; 运行工程，控制台会生成一个随机的密码：
当用浏览器访问服务端接口时，会提示输入用户名和密码。用户名为user，密码即为生成的随机密码。该验证方式为httpSecurity basic验证。
若要直接调用接口访问，则需要在请求头的Authorization中附加用户名/密码。
使用postman时，需要将请求的Authorization属性的TYPE设置为Basic Auth。
若要关闭该验证功能，则为Application启动类的@SpringBootApplication注解添加排除类SecurityAutoConfiguration.class：
@SpringBootApplication(exclude=SecurityAutoConfiguration.class) public class DemoApplication { public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 但该方式的优先级低于配置类。若配置类设置了开启验证，则依然还是需要进行验证。
设置 设置用户名和密码 在application.properties中添加属性：
spring.security.user.name=user spring.security.user.password=123 这样，就将security验证的用户名和密码修改为user和123。但这样意味着登录系统的用户名和密码是固定的，不推荐。
若使用配置类，则可以不用在application.properties中添加属性，而是直接在配置类中设置。
配置类优先级更高。若配置类中没有设置用户名和密码，则使用application.properties中的设置。
使用配置类 添加一个配置类：
@EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { // 设置密码验证方式 @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } // 设置对各个接口的访问过滤 @Override protected void configure(HttpSecurity httpSecurity) throws Exception { httpSecurity.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0c16b4d72b637fc41f1c1713ec05b86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/372b161c905bdee886a511fa87259052/" rel="bookmark">
			C&#43;&#43; -- 基于多态的后宫管理系统（其实就是职工管理或者图书管理系统根据我自己的需求改编，毕竟追我的人太多了，要好好管理一下）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux环境下C++基于多态的后宫管理系统
实现如下几个功能
后宫每位佳丽都有4个属性，分别是编号、姓名、颜值、身份
并且把数据保存到文件中，保证数据不会在程序结束时流失，下一次使用还可以恢复以前的数据
让我们来看看添加功能
当输入正确时添加成功
当输入编号已经存在或者身份不对时，提示输入失败
显示功能，输入2显示所有人信息
删除功能
两种模式，姓名模式输入要删除的姓名，编号模式输入要删除的编号，当有重名人时，不能用姓名模式删除，当输入的编号或姓名不存在时，提示用户不存在
其他经过测试都是成功的，就不一一放图了
修改功能也是姓名和编号两种方式查找，找到了重新输入信息，找不到提示不存在
排序功能有4个模式，按照编号的升降序和按照颜值的升降序。
查看功能就是输入姓名或者编号，存在则打印这个人的信息
不存在则提示不存在
程序源码：
#include"iostream" #include"stdlib.h" #include"string" #include"fstream" #define FILENAME "a.txt" using namespace std; //枚举类型，(退出，添加，显示，删除，修改，排序，查找) enum { quit, add, display, del, alter, sort, Find, }; //女孩类，抽象类，无法实例化 class girl { public: //纯虚函数 virtual void work() = 0; //编号 int num; //姓名 string name; //颜值 int yanzhi; //身份 int sf; }; //女朋友类，继承女孩类 class girlfriend : public girl { public: //参数构造函数，初始化编号、姓名、颜值，女朋友类的身份统一初始化为1 girlfriend(int a, string b, int c) { sf = 1; num = a; name = b; yanzhi = c; } //多态，重写父类的纯虚函数，实现打印信息 void work() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/372b161c905bdee886a511fa87259052/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a070fb7207085039bb6350addc5ab17d/" rel="bookmark">
			如何使用码云搭建博客
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进入自己创建的项目才可以创建博客
写好了就可以部署了
当我们部署上去以后一定要重写更新一下码云的那个地址，因为免费的不会帮我们自动部署。
hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹
以后我们每次使用只需要
hexo new 自己的博客的名字 hexo clean //清楚一下缓冲 hexo deploy //部署到码云 最后进码云的服务里面更新一下 如何删除自己发布到码云上的博客
hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。 hexo server -s #以静态模式启动 hexo server -p 5000 #更改访问端口 (默认端口为4000，'ctrl + c'关闭server) hexo server -i IP地址 #自定义 IP hexo clean #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹 hexo g #生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将"/blog/source/" 下面的.md后缀的文件编译为.html后缀的文件,存放在"/blog/public/ " 路径下) hexo d #将本地数据部署到远端服务器(如github) hexo init 文件夹名称 #初始化XX文件夹名称 npm update hexo -g#升级 npm install hexo -g#安装 node-v #查看node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a070fb7207085039bb6350addc5ab17d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f57b3ca0ff639954f2fae12de03306/" rel="bookmark">
			unity简单的背包制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背包系统基本功能：添加物品、删除物品、拖拽物品、交换物品位置、排列物品等等。
首先在unity将背包的UI界面制作完成，如图：
Text是用来显示当前格子物品的数量。
然后将需要生成的物品UI制作成预制物，如图所示：
接下来上代码
1、添加物品
添加物品的时候需要注意的是（1）当前格子是否为空（2）当前格子是否有跟需要添加相同的物体（3）格子为空的时候需要按照空格子的顺序添加物体（4）当前格子有需要添加的物体时，只需要数量++
/// &lt;summary&gt; /// 添加物品 /// &lt;/summary&gt; /// &lt;param name="objnum"&gt;&lt;/param&gt; void LoadObjs(int objnum) { switch (objnum) { case 101: //red GameObject objred = GameObject.Find("red"); if (objred != null) { int num = int.Parse(objred.transform.parent.GetChild(0).GetComponent&lt;Text&gt;().text); num++; objred.transform.parent.GetChild(0).GetComponent&lt;Text&gt;().text = num.ToString(); return; } for (int i = 0; i &lt; bagBakcGround.transform.childCount; i++) { if (bagBakcGround.transform.GetChild(i).childCount &lt;= 1) //格子为空 创建新物体 { GameObject go = Instantiate(Resources.Load&lt;GameObject&gt;("objs/red")); go.transform.parent = bagBakcGround.transform.GetChild(i); go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7f57b3ca0ff639954f2fae12de03306/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/150fa3798994571660ef26bc968358a1/" rel="bookmark">
			h2数据库介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、H2介绍 H2是一个用Java开发的嵌入式数据库，它本身只是一个类库，可以直接嵌入到应用项目中。
常用的开源数据库有：H2，Derby，HSQLDB，MySQL，PostgreSQL。其中H2和HSQLDB类似，十分适合作为嵌入式数据库使用，而其它的数据库大部分都需要安装独立的客户端和服务器端。
H2的优势：
1、h2采用纯Java编写，因此不受平台的限制。
2、h2只有一个jar文件，十分适合作为嵌入式数据库试用。
3、h2提供了一个十分方便的web控制台用于操作和管理数据库内容。
4、功能完整，支持标准SQL和JDBC。麻雀虽小五脏俱全；
5、支持内嵌模式、服务器模式和集群。
用途：
H2最大的用途在于可以同应用程序打包在一起发布，这样可以非常方便地存储少量结构化数据。它的另一个用途是用于单元测试。启动速度快，而且可以关闭持久化功能，每一个用例执行完随即还原到初始状态。H2的第三个用处是作为缓存，作为NoSQL的一个补充。当某些场景下数据模型必须为关系型，可以拿它当Memcached使，作为后端MySQL/Oracle的一个缓冲层，缓存一些不经常变化但需要频繁访问的数据，比如字典表、权限表。不过这样系统架构就会比较复杂了。 2、h2下载、安装 H2数据库下载地址：http://www.h2database.com/html/download.html
H2数据库的目录结构
h2
|---bin
| |---h2-1.1.116.jar //H2数据库的jar包（驱动也在里面）
| |---h2.bat //Windows控制台启动脚本
| |---h2.sh //Linux控制台启动脚本
| |---h2w.bat //Windows控制台启动脚本（不带黑屏窗口）
|---docs //H2数据库的帮助文档（内有H2数据库的使用手册）
|---service //通过wrapper包装成服务。
|---src //H2数据库的源代码
|---build.bat //windows构建脚本
|---build.sh //linux构建脚本
打开浏览器，输入地址：http://localhost:8082访问H2数据库的Web Console，如下图所示：
能够看到这个界面，就说明了H2数据库可以正常使用了。
3、简单使用H2数据库 3.1、登录H2数据库的WebConsole控制台 连接测试通过之后，点击【连接】按钮，登录到test数据库的webConsole，如下图所示：
3.2、sql执行： DROP TABLE IF EXISTS TEST;
CREATE TABLE TEST(ID INT PRIMARY KEY, NAME VARCHAR(255));
INSERT INTO TEST VALUES(1, 'Hello');
INSERT INTO TEST VALUES(2, 'World');
SELECT * FROM TEST ORDER BY ID;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/150fa3798994571660ef26bc968358a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a3ac8745718bba878f793b0b38ecb3/" rel="bookmark">
			C&#43;&#43;中move和forward（完美转发）在模板编程中的使用、runtime_error异常操作、C&#43;&#43;打印[1,2]这种格式打印tuple
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		move、forward、模板类型推断分析 下面这张图是模板类型推断原则：runtime_error异常打印tuple总结 引用折叠原则和完美转发是有联系的，可以说后者是基于前者的某些特性实现的，具体来看一下。
要理解完美转发，需要了解两个知识点：
引用折叠原则（Reference collapsing rules）。
右值函数模版参数类型推导（Template argument deduction）
我们先来分析一下为什么需要使用到move呢？
C++11多出来一个move语义，意图是解决临时对象重复拷贝和释放引发的资源浪费，move与右值引用进行搭配可以完美的解决这个问题。
比如在进行vector中的insert函数的时候，如果模板类型是string，通过move(str1)我们就可以只将string中的指针进行交换，即可实现插入到vector容器中的操作。而不用再进行深拷贝的动作。
需要注意的是，如果使用move进行左值变右值之后，该左值不能再利用，因为它里面的信息可能已经被更改，对应的string就是，指向字符串的指针被打断了。
下面这张图是模板类型推断原则： 这是函数模板参数类型推导中一种比较特殊的情况，这种情况会把模板参数作为右值引用使用，例如：
template&lt;typename T&gt; void foo(T&amp;&amp;); 其中T为模板类型，T&amp;&amp;为参数类型。这种情况会产生两种结果：
1. 当传给foo函数的参数是一个左值引用时，例如：
int i = 29; foo(i);//i为左值引用 此时，T的类型为int的左值引用：int&amp;，参数类型为int &amp; &amp;&amp;，（既T&amp;&amp;），结合上面的引用折叠规则，最终参数的类型为int的左值引用：int&amp;。
2. 当传给foo函数的参数是一个右值引用时，例如：
foo(29); 此时，T的类型为int，参数类型为int&amp;&amp;，（既T&amp;&amp;）。
那么，为什么需要forward呢？
我们先来看下以下例子：
template&lt;typename T&gt; void show1(T &amp;&amp; a) { cout &lt;&lt; "我是右值引用" &lt;&lt; endl; } template&lt;typename T&gt; void show1(T &amp; a) { cout &lt;&lt; "我是左值引用" &lt;&lt; endl; } template&lt;typename T&gt; void show(T &amp;&amp; a) { show1(forward&lt;T&gt;(a)); } //我们通过以下进行调用； show(2); 该函数第进入show之后会调用show1的调用，如果此时没有用forward进行转发的话，会调用到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8a3ac8745718bba878f793b0b38ecb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c8ba375f0e7db167703766e77777a41/" rel="bookmark">
			设置ClickHouse默认用户default的密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、明文密码 （1）查找user.xml文件
[root@elastic1 app]# cd /etc/clickhouse-server/ [root@elastic1 clickhouse-server]# ll total 40 drwxr-xr-x 2 root root 4096 Sep 11 13:39 config.d -rw-r--r-- 1 root root 22601 Sep 11 13:45 config.xml lrwxrwxrwx 1 root root 41 Sep 11 13:39 preprocessed -&gt; /var/lib/clickhouse//preprocessed_configs drwxr-xr-x 2 root root 4096 Sep 11 13:39 users.d -rw-r--r-- 1 root root 5190 May 19 00:26 users.xml [root@elastic1 clickhouse-server]# vi users.xml （2）修改密码
&lt;!-- Users and ACL. --&gt; &lt;users&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c8ba375f0e7db167703766e77777a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7ddb56ebc2120f1aca9e5195f1dd50a/" rel="bookmark">
			ICP点云配准的原理推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ICP点云配准的原理推导
文章目录 一、背景与意义二、点云配准理论基础二、使用步骤 总结 一、背景与意义 点云数据能够以较小的存储成本获得物体准确的拓扑结构和几何结构，因而获得越来越广泛的关注。在实际的采集过程中，因为被测物体尺寸过大，物体表面被遮挡或者三维扫描设备的扫描角度等因素，单次的扫描往往得不到物体完整的几何信息。因此，为了获得被测物体的完整几何信息，就需要将不同视角即不同参考坐标下的两组或者多组点云统一到统一坐标系下，进行点云的配准。在配准算法中，研究者使用最多的是ICP算法。下面将介绍ICP算法的基本原理以及步骤。
二、点云配准理论基础 二、使用步骤 （1）刚性变换矩阵
点云配准的最终目的是通过一定的旋转和平移变换将不同坐标系下的两组或者多组点云数据统一到同一参考坐标系下。这个过程，可以通过一组映射来完成。假设映射变换为H，这H可以用以下的公式来表示。
刚性变换矩阵中涉及到六个未知数α、β、γ、 tx、ty、tz。要唯一确定这六个未知参数，需要六个线性方程，即至少需要在待匹配点云重叠区域找到3组对应点对，且3组对应点对不能共线，才可以得到这几个未知数的值，进而完成刚性矩阵的参数估计。通常情况下，人们会选择尽可能多的对应点对，进一步提高刚性变换矩阵的参数估计精度。
（3）目标函数
在待匹配的两组点云数据的重叠区域内，分别选取两个点集来表示源点集和目标点集，其中P={pi|pi∈R3，i=1,2，……n}为源点集，Q ={qj|qj∈R3，j=1,2，……m}为目标点集，m和n分别代码两个点集的规模。设旋转矩阵为R，平移矩阵为t，用f（R，t）来表示源点集P在变换矩阵（R，t）下与目标点集Q之间的误差。则求解最优变换矩阵的问题就可以转化为求满足min（f（R，t））的最优解（R，t）。
三、ICP算法的原理与步骤
ICP算法的基本原理是：分别在带匹配的目标点云P和源点云Q中，按照一定的约束条件，找到最邻近点（pi，qi），然后计算出最优匹配参数R和t，使得误差函数最小。误差函数为E（R，t）为：
其中n为最邻近点对的个数，pi为目标点云 P 中的一点，qi 为源点云 Q 中与pi对应的最近点，R 为旋转矩阵，t为平移向量。
ICP算法步骤：
（1）计算最近点集:在目标点云P中取点集pi∈P,找出源点云Q中的对应点集qi∈Q，使得||qi-pi||=min；
总结 转载自https://blog.csdn.net/vjhghjghj/article/details/89138266
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb2e3b79c562dfd990041c80df417e2a/" rel="bookmark">
			Redis 变慢了？那你这样试试，不行就捶我
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在一些网络服务的系统中，Redis 的性能，可能是比 MySQL 等硬盘数据库的性能更重要的课题。比如微博，把热点微博[1]，最新的用户关系，都存储在 Redis 中，大量的查询击中 Redis，而不走 MySQL。
那么，针对 Redis 服务，我们能做哪些性能优化呢？或者说，应该避免哪些性能浪费呢？
Redis 性能的基本面
在讨论优化之前，我们需要知道，Redis 服务本身就有一些特性，比如单线程运行。除非修改 Redis 的源代码，不然这些特性，就是我们思考性能优化的基本面。
那么，有哪些 Redis 基本特性需要我们考虑呢？Redis 的项目介绍中概括了它特性：
Redis is an in-memory database that persists on disk. The data model is key-value, but many different kind of values are supported.
首先，Redis 使用操作系统提供的虚拟内存来存储数据。而且，这个操作系统一般就是指 Unix。Windows 上也能运行 Redis，但是需要特殊处理。如果你的操作系统使用交换空间，那么 Redis 的数据可能会被实际保存在硬盘上。
其次，Redis 支持持久化，可以把数据保存在硬盘上。很多时候，我们也确实有必要进行持久化来实现备份，数据恢复等需求。但持久化不会凭空发生，它也会占用一部分资源。
第三，Redis 是用 key-value 的方式来读写的，而 value 中又可以是很多不同种类的数据；更进一步，一个数据类型的底层还有被存储为不同的结构。不同的存储结构决定了数据增删改查的复杂度以及性能开销。
最后，在上面的介绍中没有提到的是，Redis 大多数时候是单线程运行[2]的（single-threaded)，即同一时间只占用一个 CPU，只能有一个指令在运行，并行读写是不存在的。很多操作带来的延迟问题，都可以在这里找到答案。
关于最后这个特性，为什么 Redis 是单线程的，却能有很好的性能(根据 Amdahl’s Law，优化耗时占比大的过程，才更有意义)，两句话概括是：Redis 利用了多路 I/O 复用机制[3]，处理客户端请求时，不会阻塞主线程；Redis 单纯执行（大多数指令）一个指令不到 1 微秒[4]，如此，单核 CPU 一秒就能处理 1 百万个指令（大概对应着几十万个请求吧），用不着实现多线程（网络才是瓶颈[5]）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb2e3b79c562dfd990041c80df417e2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13e457d0b7bb04ff191367e149ec925/" rel="bookmark">
			如何对Win10的文件夹进行批量顺序重命名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何对Win10的文件夹进行批量顺序重命名
（1）ctrl + a选中，全部；
（2）F2
（3）空格
（4）enter
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde0408ad4d5d6d1a8159d169c27d90a/" rel="bookmark">
			Android -- TextView（二）追加文字，并自动滚动（触底时）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android – TextView（二）追加文字，并自动滚动（触底时） **实现要求：**在固定高度的TextView内追加显示内容，当内容高度超出TextView高度时，内容自动向上滚动（能显示最下方内容）。
布局：
&lt;!--最后三个属性很重要--&gt; &lt;TextView android:id="@+id/tvLog" android:layout_width="match_parent" android:layout_height="match_parent" android:enabled="false" android:focusable="false" android:gravity="center_vertical|top" android:inputType="textMultiLine" android:scrollbars="vertical" android:scrollbarStyle="insideOverlay" android:fadeScrollbars="false" android:scrollbarFadeDuration="2000"&gt; &lt;/TextView&gt; 自定义方法：
private TextView tvLog; tvLog = findViewById(R.id.tvLog); tvLog.setMovementMethod(ScrollingMovementMethod.getInstance()); //当需追加新内容时，直接调用此方法即可； public void addLog(final String strLog) { final String strText = strLog; runOnUiThread(new Runnable() { @Override public void run() { //附加与log前的时间标签（可注释） SimpleDateFormat formatter = new SimpleDateFormat("hh:mm:ss"); Date curDate = new Date(System.currentTimeMillis());// 获取当前时间 String strDate = formatter.format(curDate); //已有的log String strLogs = tvLog.getText().toString().trim(); if (strLogs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bde0408ad4d5d6d1a8159d169c27d90a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f631c757cc9c3ff2cadc07e895030ce/" rel="bookmark">
			微信APP授权登陆与微信小程序授权同时使用 （php版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发的工程过程中，一般喜欢是用微信授权登陆，但是怎么实现app授权与小程序授权同时存在呢？
一、一个项目即要使用app授权登陆，又要使用小程序授权登陆。而且要保证同一个微信号，这个时候就不可以使用openid,因为app授权登陆拿到的是app应用获取的openid与小程序授权登陆获取到的openid肯定是不一致的，这个时候就需要使用他们的共同唯一标示 UnionID 因为同一用户，对同一个微信开放平台下的不同应用，UnionID是相同的。微信官网介绍：UnionID 机制说明
二、怎么拿到UnionID？
1、app授权登陆是可以直接拿到UnionID；
2、小程序就需要你自己去获取了，我使用是 调用接口 wx.login() wx.getUserInfo()，从解密数据中获取 UnionID。注意本接口需要用户授权，请开发者妥善处理用户拒绝授权后的情况。代码如下：
$open_info = get_user_openid($js_code);//$js_code wx.login 授权时候能获取到 function get_user_openid($js_code) { $appid = 'appid';//小程序唯一标识 (在微信小程序管理后台获取) $appsecret = 'appsecret' ;//小程序的 app secret (在微信小程序管理后台获取) $grant_type = "authorization_code"; //授权（必填） $curl = curl_init(); //使用curl_setopt() 设置要获得url地址 $url = 'https://api.weixin.qq.com/sns/jscode2session?appid=' . $appid . '&amp;secret=' . $appsecret . '&amp;js_code=' . $js_code . '&amp;grant_type=' . $grant_type; curl_setopt($curl, CURLOPT_URL, $url); //设置是否输出header curl_setopt($curl, CURLOPT_HEADER, false); //设置是否输出结果 curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); //设置是否检查服务器端的证书 curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); //使用curl_exec()将curl返回的结果转换成正常数据并保存到一个变量中 $data = curl_exec($curl); //关闭会话 curl_close($curl); return json_decode($data,true); } $result = get_decryptData($param['encryptedData'],$param['iv'],$open_info['session_key']); /** * 检验数据的真实性，并且获取解密后的明文.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f631c757cc9c3ff2cadc07e895030ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c030d0f91491434317a7a3f171e53ac4/" rel="bookmark">
			php bug：Fatal error: Uncaught PDOException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fatal error: Uncaught PDOException: SQLSTATE[HY000] [1045] Access denied for user 'codeslat_web'@'localhost' (using password: YES) in C:\xampp\htdocs\portfolio-master\functions.php:20 Stack trace: #0 C:\xampp\htdocs\portfolio-master\layouts\header.php(3): getPDO() #1 C:\xampp\htdocs\portfolio-master\index.php(12): include('C:\\xampp\\htdocs...') #2 {main} thrown in C:\xampp\htdocs\portfolio-master\functions.php on line 20 这是因为mysql文件还没上传连接
解决办法
点击XAMPP的mysql的admin进入mysql数据库，新建new数据表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1949e9bd4830028dc94c83e685896a7/" rel="bookmark">
			js原生实现防抖节流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		共同点：都用到了setTimeout定时器，都是在指定时间间隔后执行函数，都是为了解决数据时时变化而时时请求导致性能差的问题
区别：防抖在指定时间间隔里再次调用函数，会清除定时器，重新计时，直到在最新的计时时间间隔里没有调用函数，才会执行定时器里的函数。而节流会在指定时间间隔后会执行一次函数，不会清除定时器而重新计时
防抖缺点：当用户在指定时间间隔里一直操作，那么setTimeout里的函数永远不会执行
节流缺点：如果用户一直操作，那么setimeout里的函数会在指定时间间隔后都会执行一次，如此反复
以监听input的值举例：
// 防抖 var input = document.getElementById('input') input.addEventListener('input', debounce(handle, 1000)) function debounce(fn,delay){ var timer return function(...args){ if(timer){ clearTimeout(timer) } timer = setTimeout(()=&gt;{ fn.apply(this,args) }, delay) } } function handle(e){ console.log(e.target.value) } // 节流 var input = document.getElementById('input') input.addEventListener('input', throttle(handle, 200)) function throttle(fn,delay){ let timer let flag = true return function(...args){ if(!flag){ return } flag = false timer = setTimeout(()=&gt;{ fn.apply(this,args) flag = true },delay) } } function handle(e){ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1949e9bd4830028dc94c83e685896a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dcf5c2935f418938715d1230ca1a2ac/" rel="bookmark">
			前端vue：解决Invalid prop: type check failed for prop “model“. Expected Object, got Array问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前台页面报错“Invalid prop: type check failed for prop “model”. Expected Object, got Array ” 错误是：期望对象，得到的是数组
从后台获取的数据是数组类型，需要把它改为Object 第一种情况： 组件传值 1、父组件
2、子组件
3、报错提示
改正 第二种情况： 获取数据的代码为
this.update = response.data; 改为：
this.update = response.data[0]; 总结：可能大家遇到的情况都不一样，总之只要报这个错就是需要把数组改成对象就可以啦
智慧前端云技术交流群
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a70921defa3fead13101125aced6f996/" rel="bookmark">
			JSON.parse 解析json字符串时，提示 Unexpected token
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var objbillEntry = JSON.parse(billEntry); //由JSON字符串转换为JSON对象
但是以上方式有隐患，如果Json字符串有换行的话，这样转换就会报错。
billEntry = '[{"srm_remark":"1. (6804104515) ;池号：2000##\n"}]'; 错误原因：JSON.parse转json字符串时遇到一些特殊字符需要先转义。
用str.replace(/\n/g,"\\n")转义,'\\'转成单个'\','\\n'转成'\n',最后转成'\\n'这样就可以用parse转成对象时变为'\n'，取出的字符串设置到html文本中\n被解析为换行。
可以这样转义：.replace(/\n/g,"\\n").replace(/\r/g,"\\r")。
var objbillEntry=JSON.parse(billEntry.replace(/\n/g,"\\n").replace(/\r/g,"\\r"));
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/642d63f382a4e91d8a6b37a0beaa8493/" rel="bookmark">
			C&#43;&#43; 数组排序返回下标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C++ 数组排序返回下标 # scores为std::vector&lt;float&gt; 型数组 std::vector&lt;size_t&gt; idx(scores.size()); std::iota(idx.begin(), idx.end(), 0); std::sort(idx.begin(), idx.end(), [&amp;scores](size_t index_1, size_t index_2) { return scores[index_1] &gt; scores[index_2]; }); # idx保存的是数组排完序后下标 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/210ec7c3af8b26ebc4e3008b663a9187/" rel="bookmark">
			STANet 代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Github地址
LEVIR-CD数据集下载
STANet论文解读
LEVIR-CD是一种新型的大型遥感建筑物变化检测数据集。
Prerequisites:
windows or Linux
Python 3.6+
CPU or NVIDIA GPU
CUDA 9.0+
PyTorch &gt; 1.0
visdom==0.1.8.1
dominate
pip install visdom==0.1.8.1 pip install dominate 数据集准备，文件路径：
数据集图片原始大小为1024x1024，我们给切成无重叠的256x256。
要确保A,B,label文件夹里图片命名是一致的。
RUN-----baseline
1.Baseline
python ./train.py --save_epoch_freq 1 --angle 15 --dataroot ./LEVIR-CD/train --val_dataroot ./LEVIR-CD/val --name LEVIR-CDF0 --lr 0.001 --model CDF0 --batch_size 8 --load_size 256 --crop_size 256 --preprocess rotate_and_crop 报错：
from scipy.misc import imresize
ImportError: cannot import name 'imresize'
解决方法：
Imresize在scipy新版本里已经没有了。卸载当前的scipy，pip install scipy==1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/210ec7c3af8b26ebc4e3008b663a9187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83a4e0f53bbde24fbd91e413e6eb44b5/" rel="bookmark">
			Maven系列第二讲 安装、配置、mvn运行过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven系列第二讲 本篇环境linux中安装安装mavenwindows安装mavenMaven的运行原理详解Maven的一些配置 本篇环境 jdk1.8maven3.6.3 我们要写java代码，需要安装jdk，那我们要使用maven，也类似，需要在我们的机器中安装maven。
linux中安装安装maven maven是使用java语言编写的，所以我们要运行maven，需要先安装jdk。
咱们到maven官网中下载最新的maven，地址如下：
https://maven.apache.org/download.cgi 1 最新的版本是apache-maven-3.6.2，linux中我们需要下载apache-maven-3.6.2-bin.tar.gz这个。
[root@ady01 jdk]# mkdir /opt/maven [root@ady01 jdk]# cd /opt/maven/ [root@ady01 maven]# wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.2/binaries/apache-maven-3.6.2-bin.tar.gz --2019-11-01 13:47:11-- http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.2/binaries/apache-maven-3.6.2-bin.tar.gz Resolving mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)... 101.6.8.193, 2402:f000:1:408:8100::1 Connecting to mirrors.tuna.tsinghua.edu.cn (mirrors.tuna.tsinghua.edu.cn)|101.6.8.193|:80... connected. HTTP request sent, awaiting response... 200 OK Length: 9142315 (8.7M) [application/octet-stream] Saving to: ‘apache-maven-3.6.2-bin.tar.gz’ 100%[==================================================================================================================================&gt;] 9,142,315 10.2MB/s in 0.9s 2019-11-01 13:47:13 (10.2 MB/s) - ‘apache-maven-3.6.2-bin.tar.gz’ saved [9142315/9142315] [root@ady01 maven]# ls apache-maven-3.6.2-bin.tar.gz 123456789101112131415 上面我们创建了/opt/maven目录用来存放maven相关软件，然后使用到wget命令，这个是linux中的一个命令，可以访问一个http地址，将其下载到当前目录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83a4e0f53bbde24fbd91e413e6eb44b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f38229be7ae62a337589dbaa6e50053/" rel="bookmark">
			Xception简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xception简介 1. 熟悉Xception论文 1.1 Xception简介 Xception是Google公司继Inception后提出的对 Inception-v3 的另一种改进。作者认为，通道之间的相关性与空间相关性最好要分开处理。于是采用 Separable Convolution来替换原来 Inception-v3中的卷积操作。
深度可分离卷积 Depthwise Separable Convolution
传统卷积的实现过程：
Depthwise Separable Convolution 的实现过程：
Depthwise Separable Convolution 与 极致的 Inception 区别：
极致的 Inception：
第一步：普通 1×1 卷积。
第二步：对 1×1 卷积结果的每个 channel，分别进行 3×3卷积操作，并将结果 concat。
Depthwise Separable Convolution：
第一步：Depthwise 卷积，对输入的每个channel，分别进行 3×3卷积操作，并将结果 concat。
第二步：Pointwise 卷积，对 Depthwise 卷积中的 concat 结果，进行1×1卷积操作。
两种操作的顺序不一致：Inception 先进行1×1卷积，再进行3×3 卷积；Depthwise Separable Convolution 先进行 3×3卷积，再进行 1×1卷积。（作者认为这个差异并没有大的影响）
1.2 Xception网络框架 先进行普通卷积操作，再对 1×1 卷积后的每个channel分别进行 3×3 卷积操作，最后将结果 concat。
1.3 启发性 Xception作为Inception v3的改进，主要是在Inception v3的基础上引入了depthwise separable convolution，在基本不增加网络复杂度的前提下提高了模型的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a64933be63e7ab217243fe744e4718b/" rel="bookmark">
			Maven项目中＜packaging＞pom＜/packaging＞的意思
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目的打包类型：pom、jar、war
packing默认是jar类型，
pom ---------&gt; 父类型都为pom类型
jar ---------&gt; 内部调用或者是作服务使用
war ---------&gt; 需要部署的项目
参考网址：
pom
maven中的packaging标签
Maven的pom.xml文件结构之基本配置packaging和多模块聚合结构（微服务）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/822487ed12dc48cf6dfd813edcc381ad/" rel="bookmark">
			C/C&#43;&#43;实现你的浪漫表白：浪漫流星雨表白程序，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想要讨女朋友欢心也巩固自己所学的知识，各位小伙伴有自己的想法了吗？准备好想要怎样实施了吗？有什么美好的计划了吗？如果没有的话那么别慌，我知道，在座的各位肯定都是有自己的心仪的姑娘，那么今天就教大家一招，做一个表白程序去进行表白，别等了，赶紧打开你的IED，跟着代码敲起来，不然的话，喜欢的人都跟别人跑了！
直接源码分享：
#include&lt;stdio.h&gt; #include&lt;graphics.h&gt; //图形库：easyX201905 #include&lt;conio.h&gt; #include&lt;time.h&gt; #define MAXSTAR 1314 #define MAXMETEOR 520 //结构体 //几个星星:1000 struct Star { int x, y; int color; int step; }star[MAXSTAR]; //流星结构 struct Meteor { int x, y; int style; int step; }meteor[MAXMETEOR]; IMAGE img1, img2;//1.定义图片变量 void printText() { //设置文字颜色 settextcolor(RGB(255, 0, 255));//三原色：红，绿，蓝 //调整字体大小 settextstyle(50, 0, "华文行楷"); //你的文采：发到公屏上 /* 海底月是天上月，眼前人是心上人 春分十里，我喜欢你 终是庄周圆了梦 这是我的手背，这是我的脚背，你是我的宝贝。 一粥一饭/不及你/颦颦一笑 问君能有几多愁？家人未入眼帘人消瘦 我喜欢你，像风走了八万里，不问归期 白酒清欢无别事，我在等风也在等你 就承认一笑倾城一见自难忘 问君能有几多愁？佳人未入眼帘人消瘦 ABCDEFGHIJKLMNOPQRSTVWXYZ */ //在指定位置输出字符串 outtextxy(450, 20, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/822487ed12dc48cf6dfd813edcc381ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22a066919190216715628c20ddceef00/" rel="bookmark">
			js根据名字将数组对象中名字相同的项组成一个相同的数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var beforeData = [{ name: "tony", id: "1", age: "20" }, { name: "jack", id: "2", age: "21" }, { name: "tony", id: "3", age: "50" }, { name: "jack", id: "4", age: "10" }, { name: "mark", id: "5", age: "22" }, { name: "mark", id: "6", age: "40" } ]; let afterData=[] getNew = () =&gt; { let tempArr = []; for (let i = 0; i &lt; beforeData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22a066919190216715628c20ddceef00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88aab7138f69451627324532a6b4e75f/" rel="bookmark">
			ArcGIS批量修改字段的属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 修改之前记得备份！备份！备份！
需求一：需要给某个字段批量赋值，如给字段type赋值为：污染 1、打开属性表 &gt; 右击需要赋值的属性字段 &gt; 字段计算器
2、在输入框中输入：“污染”。（引号为英文双引号；如果是数字的话直接输入即可。）
需求二：根据条件将字段修改为不同的值，如：修改生活污染强度字段值，将小于50的改为0，大于等于50的不变。 1、打开属性表 &gt; 右击需要赋值的属性字段 &gt; 字段计算器 &gt; python &gt; 显示代码块。
2、输入以下代码。
def Reclass(value): if value &lt; 50: return 0 else: return value 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c49e8850e3cb918d86998156a338125/" rel="bookmark">
			FPGA学习笔记---Verilog HDL 可综合语句和不可综合语句汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 作为HDL语言，有两种基本的用途：系统仿真和设计实现。所有的HDL描述都可用于仿真，但并非所有的HDL描述都可综合。
一般综合工具支持的Verilog HDL结构
Verilog HDL结构可综合性说明module,macromodule√wire,reg,integer 数据类型√parameter√ 端口类型说明
input,output,inout
√ 运算符
+,-,*,%
&amp;,~&amp;,|,~|,^,^~
==,!=,&amp;&amp;,||,!
~,&amp;,|,^,^~
&gt;&gt;,&lt;&lt;,?:,{}
大部分可综合:
全等运算符(=== !==)不支持：
多数工具对除法(/)和求模(%)有限制；
如对除法操作，只有当除数是常数，且是2的指数时才支持；
基本门元件
and,nand,nor,or,xor,xnor,buf,not,
bufif0,bufif1,notif0,notif1,pullup,pulldowm
全部可综合
但某些工具对取值x和z有所限制
持续赋值 assign√ 过程赋值: 阻塞赋值( = ) 非阻塞赋值( &lt;= ) 支持，但对同一reg型变量只能采样阻塞和非阻塞赋值的其中一种进行赋值 条件语句：
if-else,case,casex,casez,endcase
一般支持，但有的综合不支持casex，casezfor循环语句√ always 过程语句
begin-end 块语句
√function,endfunction√task,endtask一般支持，少数综合器不支持编译向导: `include,`define,`ifdef,`else,`endif√ 一般综合工具忽略的Verilog HDL结构
Verilog HDL结构这些结构和语句在综合时全被忽略延时控制 #xxxscalared， vectoredspecifysmall， large， mediumweak0,weak1,highz0,highz1,pull0,pull1timewait 一般综合工具不支持的Verilog HDL结构
Verilog HDL结构可综合性说明在assign持续赋值中，等式左边含有变量的位选择 多数综合器对这些结构和语句不支持，这些语句描述的程序代码不能转换为具体的电路网表结构，但这些结构都能够被仿真工具（如ModeSim等）所支持
全等运算符===,!==cmos,nmos,rcmos,rnmos,pmos,rpmosdeassign,defparam,eventforce,releasefork,joinforever,while,repeatrtran,tran,tranif0,tranif1,rtranif0,rtranif1initialtable,endtable,primitive,endprimitive 可综合设计的要点
不使用初始化语句。不使用带有延时的描述。不使用循环次数不确定的循环语句，如forever、while等。尽量采用同步方式设计电路除非是关键路径设计，一般不采用调用门级元件来描述设计的方法，建议采用行为语句来完成设计。用always过程块描述组合逻辑，应在敏感信号列表中列出所有的输入信号。所有的内部寄存器都应该能够被复位，应尽量使用器件的全局复位端作为系统总的复位。用户自定义原语（UDP元件）是不可综合的，它只能用来建立门级元件的仿真模型。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d07a7b543cc42bc68bc2ef5602792e/" rel="bookmark">
			Substance  Painter里  AO贴图  烘焙黑图 原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		检查：
1高低模 输入对了吗？反了，错了？
2高模在 max /maya 里相对低模，没有位移和缩放，否则烘焙时候，高低模对不上，会黑（我是这个原因，不小心缩放了）
3材质，是不是用了一个材质，如果多个材质右上角有没有选正确的那一个
以上三个方面如果还不能解决，真爱莫能助了，建议找一个建模的同学过来现场调试
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc778db0d93d2c2c96cfb2babd8c80b/" rel="bookmark">
			css 媒体查询 移动端_为移动Web开发：第1部分-CSS媒体查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		css 媒体查询 移动端
Developing our web pages for the mobile web has never been more important than it is now. While the stats vary a bit, the general consensus is that more and more people own or have access to a mobile device and one in five Americans use a mobile phone for their primary access to the internet. Some don’t even own a computer.
为移动网络开发网页比以往任何时候都更加重要。 尽管统计数据略有不同，但普遍的共识是，越来越多的人拥有或可以使用移动设备，并且五分之一的美国人主要通过手机使用手机上网。 有些人甚至没有电脑。 I grew up in the early stages of the internet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bc778db0d93d2c2c96cfb2babd8c80b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48c4aea117027258405692d360047c52/" rel="bookmark">
			day9常用类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scanner 类 用于获取键盘录入的数据 public String nextline 通过scanner获取字符串数据 public class sacnner { public static void main(String[] args) { Scanner sc= new Scanner(System.in); String line=sc.nextLine(); System.out.println("line:"+line); } } 如何查看源码 ctrl+xxx
无参构造 alt + /
带参构造 alt +shift +s +o
object类 根类，所有类的继承该类
直接输出对象名，输出底层调用的是该对象的toString（）方法，
建议所有子类重写该方法
tostring方法 toString() 方法用于返回该对象的字符串表现。
equals 查看两个对象是否相等
object类中的object比较的是对象的地址是否相等
如果想比较对象的内容是否相等，必须自己重写方法
stu s1=new stu("hehe",30); stu s2=new stu("hehe",30); System.out.println(s1.equals(s2)); equals解析 @Override public boolean equals(Object obj) { if (this == obj)//此时this代表s1 object代表s2 return true;//此时s1和s2的地址值不相同，继续往下执行 if (obj == null) return false;//此时查看s1是不是为空，不为空，继续执行 if (getClass() !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48c4aea117027258405692d360047c52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe35775be04eb2a0f67d394959a120f/" rel="bookmark">
			软件测试--基础知识1--测试简介、软件质量等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、测试基础1、什么是软件测试2、软件测试的目的、意义3、测试原则4、测试对象介绍5、测试级别6、系统测试分类7、常见的系统测试方法1）按测试对象进行分类2）按测试对象是否执行进行分类3）按测试手段进行分类 二、软件质量1、软件质量2、软件测试流程3、常见的软件架构1）两种架构的比较 一、测试基础 1、什么是软件测试 两个依据（需求、测试用例），两个方法（手工、自动），一个对比（预期结果比实际结果的对比）
2、软件测试的目的、意义 初期：尽量多的发现缺陷生成相关规范
中期：尽量早的发现缺陷
后期：尽量预防问题，通过以往的经验积累
控制成本（贯穿始终）尽量少的时间和人力发现更多的缺陷
3、测试原则 所谓测试原则指的是我们在执行测试工作时必须要遵守的一些规则
测试证明软件存在缺陷：无论执行什么样的测试操作都能证明当前软件是有缺陷的不能执行穷尽测试：有些功能是没有办法将所有的测试情况都罗列出来，所以任何的测试操作都有结束的时间缺陷存在群集现象：对于软件功能来说，核心功能占20%(比如 QQ)，非核心是80%(QQ炫舞等衍生品)。在实际工作中我们会集中测试20%的核心功能，所以这个部分发现缺陷的几率就会高于80%。因此我们就会遇到缺陷都集中在20%功能模块里的现象。某些测试需要依赖特殊的环境：例如ipthone手机在寒冷的区域会出现异常关机，是因为当时测试时未在这种环境下测试测试应尽早介入：为了更多的发现和更好的解决软件中的缺陷，我们追求测试工作尽早的开展杀虫剂现象：同样的一个测试用例不能重复的执行多次，因为软件会对它产生免疫；即对于某个出现问题，开发人员会就这个问题去解决，所以测试时需要换为同一类型的另外的问题测试不存在缺陷谬论：任何软件不可能是完美的 4、测试对象介绍 对于当前的测试行业来说我们最经常测试的主体就是软件（主体功能），但是需要我们明白的是一个软件也不仅仅只有功能需要测试。
我们可以将软件分为三个部分组成：功能集合、使用说明书、配置数据
对于一款软件来说从无到有需要不同的过程，我们可以将这个过程分为不同阶段，然后每个阶段都会有相应的测试对象
下列为各个阶段对应的测试对象：
需求阶段：各种需求规格说明书(这个过程分析要实现什么功能，这些功能在现有的资源上是否可以实现)软件架构设计：API接口文档（接口测试）编码实现阶段：源代码（白盒测试、单元测试）系统功能使用：软件功能主体（当前行业做的最多的一种测试） 5、测试级别 软件开发都会依据相应的开发模型，在这个开发模型中会有人为定义的开发步骤，我们把这个开发步骤称为测试级别。
常见的级别分类为：
单元测试(UT unit test)：在软件测试中，单元指的是组成软件最小的底层代码结构，一般就是类、函数、组件集成测试（IT ingertaion test）：将多个单元块组合到一起，然后验证它们之间沟通的“桥梁”是否能正常工作（接口测试）系统测试（ST system test）：这是当前行业做的最多的一种测试，由测试人员充当用户然后对软件功能主体进行测试验收测试： alpha测试–内测beta测试–公测UAT测试–由客户派出对于业务非常精通的人员来使用该软件，从而对功能进行测试验收测试的核心就是让用户为当前软件’买单‘ 6、系统测试分类 功能测试：验证当前的软件主体功能是否可用兼容性测试：验证当前软件在不同的环境下是否还可以使用（不同操作系统中、不同终端上、不同浏览器）安全测试：验证软件是否只是对授权用户提供功能使用性能测试：相对于当前软件消耗的资源，它的产出能力 7、常见的系统测试方法 1）按测试对象进行分类 白盒测试： 指的是把盒子打开，研究里面的源代码和程序结构 黑盒测试： 又称数据驱动测试，完全不考虑程序内部结构和内部特性，注重于测试软件的功能需求，只关心软件的输入数据和输出数据 灰盒测试：介于两者之间（接口测试）上述三种方法当中的“盒”指的就是被测对象 2）按测试对象是否执行进行分类 静态测试：指的就是测试不可行的（测文档）动态测试：将软件运行在真实的使用环境中进行测试 3）按测试手段进行分类 手工测试：由测试人员手动的对被测对象进行验证，优点可以灵活的改变测试操作及环境。自动化测试：所谓自动化主要有两种形式，一种是自己写测试脚本，另外一种就是通过第三方的工具对被测对象进行测试。优点就是可以高效率的去执行一些人工无法实现的操作 二、软件质量 1、软件质量 描述当前软件是否好用，在当前的软件行业里我们所采用的一套标准是基于ISO组织制定的。
需要我们记忆的就是软件质量的六大特性：
功能性：软件需要满足用户显式或隐式的功能易用性：软件易于学习、易于上手使用，容易吸引用户可靠性：指的就是软件必须实现需求中指明的功能效率性：类似于软件的性能可维护性：要求软件具有将某个功能修复之后还可以继续使用的功能可移植性：当前软件可以从一个平台移植到另一个平台上使用的能力 功能靠用，效率可以
2、软件测试流程 根据团队、公司的习惯，业务流程的不同，软件测试流程都不同。
下面为尽可能多的流程
需求分析 当前阶段的核心目的就是梳理清楚我们需要设计的点是什么需求的来源：需求规格说明书、API文档、竞品分析、个人经验 设计用例 用例就是用户为了测试软件的某个功能而执行的操作过程设计用例是有方法的（等价类、边界值、判定表。。。。） 评审用例：对当前用例进行添加或者删除配置环境 环境：指的是当前被测对象运行所需要的执行环境，作为测试人员需要具备配置环境的能力（一般情况下都会使用一键安装的集成环境）环境分类：操作系统、服务器软件、数据库、当前软件底层代码的执行环境 执行用例 一般在执行用例之前我们会做一个冒烟测试（这种测试的核心就是快速对当前软件的核心功能或者主体执行流程进行验证，如果冒烟测试阶段有问题，则可以将此版本回退给开发）如果冒烟测试通过那么才会开展全面的测试 回归测试及缺陷跟踪 回归测试指的是当我们将某个缺陷提交给开发之后，由他们进行修复，修复完成之后需要测试人员再次对其进行测试缺陷跟踪：指的就是当测试人员发现某个缺陷之后需要一直对其进行状态的跟踪 输出测试报告
将当前的测试过程中产生的数据进行可视化的输出，方便其他人去查看测试结束：
将整个测试过程中产生的文档进行整理归档，方便后续版本使用 3、常见的软件架构 所谓的软件架构我们可以理解为是用来指导我们软件开发的一种思想，目前来说最常见的两种架构模式就是B/S 、C/S
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fe35775be04eb2a0f67d394959a120f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ed4bcc8dbfdf2460c7870695be1936/" rel="bookmark">
			关于es5和es6作用域的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		var/let 在ES5中的var修饰符是没有块级作用域的，除了在函数里面定义的，其他的都是全局作用域，也就是定义了一个var修饰的变量(除了在函数里面的)，全局都可以访问
在ES6中的let修饰符块级作用域，在跨级作用域定义了变量以后，其他地方不能访问。
var aa = 12; function toAdd() { var bb = 13; console.log(aa);//12 console.log(bb);//13 } toAdd(); console.log(aa);// 12 // console.log(bb);//bb is not defined { var cc = 14; } console.log(cc);//14 { let aa1 = 10; }; console.log(aa1);//aa1 is not defined //如果需要添加作用域，那只能在函数里面才有局部作用域，不会被外部访问到，如：加入一个匿名闭包，将变量隔离开来 &lt;button class="btns"&gt;点击1&lt;/button&gt; &lt;button class="btns"&gt;点击2&lt;/button&gt; &lt;button class="btns"&gt;点击3&lt;/button&gt; // js for (var i = 0; i &lt; btns.length; i++) { btns[i].addEventListener('click', function() { console.log('第' + i + '个按钮被点击') }) } //实际上循环里面执行了三次,且最终赋值为2（是全局的），最后++变为3 i = 2 { i = i; btns[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28ed4bcc8dbfdf2460c7870695be1936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b331dbcadedf1fd00db7bea8f4f76dfe/" rel="bookmark">
			邂逅Vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		邂逅Vue Vue 什么是Vue 官网：https://cn.vuejs.org/
作者：尤雨溪 美籍华人 2014年2月 vue1.0 vue2.0 vue3.0
渐进式 JavaScript 框架
框架：express / koa / Vue
库：bootstrap，jquery，zepto, swiper
Ajax 阿贾克斯
Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。
渐进式框架 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。不仅易于上手，还便于与第三方库或既有项目整合
一步一步的
Vue（全家桶）: 框架 vuejs + vue-cli(day 4) + vuerouter(day 6) + vuex(day 7,8)
Vuejs: 框架的核心
作为开发者而言，vue这个框架的组成并不是全部必须使用，可以根据自己项目的需求和难易程度来自行选择
优点 解耦（耦合度，藕断丝连）数据和视图，今后，只要想让页面发生改变，只需要修改数据即可。在框架内，尽量避免使用DOM操作
// 原生 div里js语法渲染一个变量 var str = "hello" var div = document.querySelector("div") div.innerHTML = str; str = "world" div.innerHTML = str; str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b331dbcadedf1fd00db7bea8f4f76dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d78577a9125a71fc553b64797caf8d2/" rel="bookmark">
			重复性、分辨率的计算方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、重复性的计算
在这里举例计算气体浓度的重复性
1、首先测定某一浓度值，取大约30-50个浓度点，计算平均值。
2、在计算这几个点的标准偏差σ。
由下列图片也可得知公式
二、分辨率的计算
1、分辨率 = 噪声 / 响应度；单位：ppm
2、响应度 = 抗值 / 浓度变化值； 单位：ppm
3、噪声 = 3 * 标准偏差； 单位：ppm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dd1db4266e2e9701b242636d0911d29/" rel="bookmark">
			Linux文件系统--文件类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux中一切都是文件，文件类型有多种，使用ls -l命令可以查看文件属性，所显示结果的第一列的第一个字符用来表示文件类型，如下：
1.普通文件
第一列第一个字符为“-”的文件为普通文件。 创建普通文件我们用：touch newfile 命令 删除普通文件我们用：rm newfile 命令 2.目录文件
第一列第一个字符为“d”（directory）的文件为目录文件。 创建目录文件我们用：mkdir directory 命令 删除空目录文件我们用：rmdir directory 命令 删除非空目录文件我们用： rm -r directory 命令（谨慎使用，会删除目录下所有文件且过程不可逆） 3.链接文件
第一列第一个字符为“l”的文件为链接文件。（只有软链接会显示字符“l”，硬链接还是普通文件“-”）如下图： 1.sh是原文件，11.sh是1.sh的硬链接，111.sh是1.sh的软链接 1）软链接 软链接相当于给原文件创建了一个快捷方式，删除原文件则相对应的软链接文件也会消失。 创建软链接文件我们用：ln -s 1.sh 111.sh 命令 2）硬链接 硬链接相当于给原文件取了个别名，其实两者是同一个文件，删除两者中的任意一个，另一个不会消失，对其中任意一个进行修改，另一个的内容也会随之改变；因为这两个文件本质上是同一个文件，只是名字不同。 创建硬链接文件我们用：ln 1.sh 11.sh 命令 4.设备文件
设备文件分为两种： 1）块设备文件 第一列第一个字符为“b”（block）的文件为块设备文件。 2）字符设备文件 第一列第一个字符为“c”（char）的文件为字符设备文件。 5.管道文件（FIFO文件）
第一列第一个字符为“p”（pipe）的文件为管道文件。 创建管道文件我们用：mkfifo fifo_file 命令 6.套接口文件
第一列第一个字符为“s”（socket）的文件为套接口文件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c4158904fbc29f4c85db4d76ea37bc/" rel="bookmark">
			centos7安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装gcc gcc-c++(如新环境,未安装请先安装) yum install -y gcc gcc-c++
安装PCRE库 cd /usr/local/ wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gz tar -zxvf pcre-8.33.tar.gz cd pcre-8.33 ./configure make &amp;&amp; make install 安装SSL库 cd /usr/local/ wget http://www.openssl.org/source/openssl-1.0.1j.tar.gz tar -zxvf openssl-1.0.1j.tar.gz cd openssl-1.0.1j ./config make &amp;&amp; make install 安装zlib库存 cd /usr/local/ wget http://zlib.net/zlib-1.2.11.tar.gz tar -zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make &amp;&amp; make install 安装nginx cd /usr/local/ wget http://nginx.org/download/nginx-1.8.0.tar.gz tar -zxvf nginx-1.8.0.tar.gz cd nginx-1.8.0 默认配置 ./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-openssl=ssl路径 自定义配置 ./configure --user=nobody --group=nobody --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_gzip_static_module --with-http_realip_module --with-http_sub_module --with-http_ssl_module make &amp;&amp; make install .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93c4158904fbc29f4c85db4d76ea37bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccd176ac124561d1c67d9efb96018aa2/" rel="bookmark">
			操作系统概念复习第二章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统结构 操作系统服务 操作系统提供对用户有用的函数：
用户界面UI：命令行界面CLI，图形用户界面GUI程序执行：系统必须将程序装入内存并运行。程序必须能结束执行。I/O操作文件系统操作通信：可以通过共享内存或消息交换技术实现 在同一台计算机运行的两个进程间运行在由网络连接起来不同计算机的进程间 错误检测：错误可能发生在CPU或内存硬件（内存错误、电源失败）、I/O设备（磁带奇偶出错、网络连接出错、打印机缺纸）和用户程序中（算术溢出、试图访问非法内存地址、使用CPU时间过长） 操作系统函数：用于确保系统本身高效运行
资源分配统计：统计哪些用户使用了多少和什么类型的资源保护和安全：保护即确保所有对系统资源的访问是受控的。 OS的用户界面 命令解释程序 在具有多个命令解释程序选择的系统中，解释程序被称为外壳Shell
命令解释程序主要用于获取并执行用户指定的下一条指令。执行命令的两种方法：
命令解释程序本身包含代码并执行这些命令。由系统程序实现绝大多数命令，命令解释程序不用理解命令，只要用命令识别文件以装入内存并执行。这样能通过创建合适名称的新文件来向系统增加命令。 系统调用 系统调用提供了OS提供的有效服务界面。这些调用通常用C或C++ 编写。
应用程序接口API：适用于应用程序员的函数，包括传递给每个函数的参数和其返回的值。Win32 API，POSIX API（UNIX、Linux和Mac OS X），Java API
在后台，组成API的函数通常为应用程序员调用实际的系统调用。
API编程好处：可移植性
每个系统调用有一个相关的数字，系统调用接口根据数字维护一个列表索引。
向OS传递参数的方法：
通过寄存器传递。参数数量少于寄存器参数存于内存的块和表中，将块的地址通过寄存器传递。不限制传递参数的数量和长度
参数通过程序放在或压入堆栈中，通过操作系统弹出。不限制传递参数的数量和长度 系统调用类型 进程控制 运行程序需要能正常或非正常地中断其执行（end或abort）。如果一个系统调用被用来非正常中断程序或程序运行碰到问题而引起错误陷阱，可能会有内存信息转储并产生一个错误信息。内存信息转储通常写到磁盘上并被调试器检查和确定问题原因。
不管是正常还是非正常中止，os必须将控制权交给调用命令解释器，解释器接着读取下一条命令。
文件管理 详细内容看10、11章
设备管理 OS控制的不同的资源可以当作设备看待。
详细内容见7章
信息维护 OS维护所有进程的信息。
通信 消息传递模型：通信进程通过彼此之间交换消息。直接或间接地通过一个共同的邮箱，消息可以在进程之间得到交换。
通信流程：
打开连接，需要知道另一个通信实体的名称——系统调用get hostid和get processid转换主机名和进程名为标识符便于OS引用——标识符传递给文件系统提供的通用open和close系统调用（open connection和close connection系统调用，取决于通信模型）——接收方通过accept connection调用允许通信——能接收连接的进程为特殊用户的后台程序，它们执行wait for connection调用，当有连接时会被唤醒——通过read messagr和write message系统调用来交换消息——close connection调用终止通信
共享内存模型：进程使用shared memory create和shared memory attach系统调用来获得其他进程所拥有的内存区域的访问权。
系统程序 计算机逻辑层次：最底层硬件——操作系统——系统程序——应用程序
系统程序提供一个方便的环境来开发和执行程序。
文件管理
状态信息
文件修改
程序语言支持
程序装入和执行
通信
操作系统设计和实现 设计目标 定义系统的目标和规格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccd176ac124561d1c67d9efb96018aa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54f5477c0de056ae417eec73d75f8dc4/" rel="bookmark">
			gpedit.msc无法启动，提示：管理员已阻止你运行此应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案
（1）win+R输入regedit，打开注册表
（2）找到注册表编辑器的计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer目录（没有的话在Policies文件那里右击新建-&gt;项）
（3）将RESTRICTRUN的键值设为0即可
（4）重启电脑，运行命令gpedit.msc
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63a2dba7c43e6d91194900259f99c07a/" rel="bookmark">
			python学习笔记5——抽象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、pandas是什么？二、使用步骤 1.引入库2.读入数据总结 抽象 本章介绍如何将语句组合成函数，这让你能够告诉计算机如何完成任务，且只需说一次，无需反复向计算机传达详细指令。本章详细介绍参数和作用域，还将讨论递归是什么及其在程序中的用途。
一、懒惰是一种美德
示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。
二、使用步骤 1.引入库 代码如下（示例）：
import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import warnings warnings.filterwarnings('ignore') import ssl ssl._create_default_https_context = ssl._create_unverified_context 2.读入数据 代码如下（示例）：
data = pd.read_csv( 'https://labfile.oss.aliyuncs.com/courses/1283/adult.data.csv') print(data.head()) 该处使用的url网络请求的数据。
总结 提示：这里对文章进行总结：
例如：以上就是今天要讲的内容，本文仅仅简单介绍了pandas的使用，而pandas提供了大量能使我们快速便捷地处理数据的函数和方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4862bc8b7cf1113177b5eadef4a2296/" rel="bookmark">
			判断一个数是否为素数(质数) c语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数。最小的质数是2，它也是唯一的偶数质数。
原理：number 只需被 (2 ~ 根号下number)之间的每一个整数去除就可以了（包括 根号下number这个数）。如果 nummber不能被 (2 ~ 根号下number) 间任一整数整除，number 必定是素数
#include"stdio.h" #include"math.h" main() { int number,i,n; printf("请输入一个正整数:\t"); scanf("%d",&amp;number);	while(number&gt;0)//输入0或小于0的数，结束循环 { n=(int)sqrt(number);//开平方 if(number==1) { printf("1既不是素数，也不是合数\n");//注：1既不是素数，也不是合数 scanf("%d",&amp;number); continue; //跳出这一次循环 } for(i=2;i&lt;=n;i++) //2和3的开平方分别为1.414和1.732，不满足循环条件(i&lt;=n) { if(number%i==0) break; } if(i&gt;n) //i=2,2和3满足(i&gt;n),所以是素数 printf("%d是素数\n",number); else printf("%d不是素数\n",number); printf("请输入一个正整数:\t"); scanf("%d",&amp;number);	} } 运行：
2.以下是函数形式
#include"stdio.h" #include"math.h" void find_prime(int number) { int n,i; n=(int)sqrt(number); for(i=2;i&lt;=n;i++) { if(number%i==0) break; } if(i&gt;n) printf("%d是素数\n",number); else printf("%d不是素数\n",number); } void main() { int number; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4862bc8b7cf1113177b5eadef4a2296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8e8de9ba7f8db09c0a4ef2654fe2856/" rel="bookmark">
			SQL Server查询死锁进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 查询死锁的sql --查询死锁 select request_session_id spid,OBJECT_NAME(resource_associated_entity_id) tableName from sys.dm_tran_locks where resource_type='OBJECT' ; 结束进程 declare @spid1 int Set @spid1 = 60; --锁表进程 declare @spid2 int Set @spid2 = 59; --锁表进程 declare @sql varchar(1000) set @sql='kill '+cast(@spid as varchar) exec(@sql) --杀死死锁进程 KILL 60; KILL 59; --显示死锁相关信息 exec sp_who2 59; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dc88ac4bcd870f1951e0856faa6e0b4/" rel="bookmark">
			LSTM的优点和缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优点： 在序列建模问题上有一定优势，具有长时记忆功能。实现起来简单。
解决了长序列训练过程中存在的梯度消失和梯度爆炸的问题。
缺点：
并行处理上存在劣势。与一些最新的网络相对效果一般
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3446cfa773ce18521c3b2355b0d57cf2/" rel="bookmark">
			pyecharts绘制漂亮图3：添加标注点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用pyecharts绘制漂亮图：6个基本步骤
使用pyecharts绘制这幅漂亮图
这是昨天代码跑出来的图：
今天，教会大家，如何显示标注点(MarkPoint)，即下图所示的两个最大、最小标注点。
一步一步 首先，标注点属于y轴的一个元素，所以在add_yaxis方法中设置。
其次，markpoint_opts为对应标注点的配置属性，它的类型为opts.MarkPointOpts
标注点对象中的文本显示对象，类型是opts.LabelOpts对象，设置它的颜色color
opts.MarkPointOpts的data 属性是个列表。
最大值、最小值标注点由对应的opts.MarkPointItem对象控制，其中最大值点为:
opts.MarkPointItem( type_ = 'max', name = '最大值' ) 最小值点：
opts.MarkPointItem( type_ = 'min', name = '最小值' ) put it together markpoint_opts=opts.MarkPointOpts( label_opts=opts.LabelOpts( color = '#fff' ), data = [opts.MarkPointItem( type_ = 'max', name = '最大值' ),opts.MarkPointItem( type_ = 'min', name = '最小值' )] ) 完整代码 import pyecharts.options as opts from pyecharts.charts import Line x_data = [str(i)+'日' for i in range(1,31)] y_data = [509, 917, 2455, 2610, 2719, 3033, 3044, 3085, 2708, 2809, 2117,2000,1455,1210,719,\ 733,944,2285,2208,3372,3936,3693,2962,2810,3519,2455,2610,2719,2484,2078] y2_data = [ 2136,3693,2962,3810,3519,3484,3915,3823,3455,4310,4019,3433,3544,3885,4208,3372,\ 3484,3915,3748,3675,4009,4433,3544,3285,4208,3372,3484,3915,3823,4265,4298] ( Line(opts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3446cfa773ce18521c3b2355b0d57cf2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5004ebf3a9673837ce2df0204d364f9b/" rel="bookmark">
			springmvc的详细的执行流程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当页面请求一发送，以前在servlet时是request接收请求，但是到了springmvc，就是前端控制器DispatcherServlet接收，为什么呢？看看DispatcherServlet的继承树，如下
可以看到DispatcherServlet实际上是HttpServlet的子类，那么也就说的通啦
那请求收到DispatcherServlet是怎么处理的呢？
在HttpServletBean中没有看到对请求方式的处理
在看看它的子类FrameworkServlet的方法，发现有了对各种请求方式的处理
看看是怎么处理的，发现都是一样的调用了processRequest(request, response)方法
进入processRequest方法一探究竟
发现最终是交给了DispatcherServlet的doService(request, response)方法处理
以为到此结束了，发现然并卵，哈哈
最终跑到了doDispatch方法里面
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { try { ModelAndView mv = null; Object dispatchException = null; try { //检查是否是文件上传 processedRequest = this.checkMultipart(request); multipartRequestParsed = processedRequest != request; //通过处理器处理请求找到匹配的处理器，也就是controller mappedHandler = this.getHandler(processedRequest); //找不到，报异常 if (mappedHandler == null) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5004ebf3a9673837ce2df0204d364f9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cedb02c8e59eaa7dedb114709482e98f/" rel="bookmark">
			python while循环实现九九乘法表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用while循环实现九九乘法表
代码如下：
i = 1 j = 1 while i&lt; 10: while j&lt;(i+1): print("%d*%d=%d"%(j,i,i*j),end="\t") j=j+1 print() i=i+1 j=1 效果如下：
这里需要注意的是 制表符end="\t"
然后里层的while的循环完之后，需要换行，用print()即可，
重点是：里层的循环完了之后，需要将里层循环的变量置为1，重新开始循环。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16eeb1cea0d9567727862eb27bd49842/" rel="bookmark">
			Element-ui input 输入框限制只能输入数字的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求说明 后台管理系统，使用element-ui el-input组件，要求只能输入数字，最先使用的办法：
&lt;el-input
v-model.number='count'
type='number'
maxLength='9'
/&gt;
复制代码
存在的问题
1. maxLength不生效
2. 可以输入e
3. 可以输入1.1.....11...1
复制代码
目前解决的办法（可以生效）
&lt;el-input
v-model='count'
oninput="value=value.replace(/[^\d]/g,'')"
maxLength='9'
/&gt;
复制代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b85667bac6a137a5f3d2b9cd07944edf/" rel="bookmark">
			随机森林计算特征重要性_随机森林中计算特征重要性的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随机森林计算特征重要性
The feature importance describes which features are relevant. It can help with a better understanding of the solved problem and sometimes lead to model improvement by utilizing feature selection. In this post, I will present 3 ways (with code) to compute feature importance for the Random Forest algorithm from scikit-learn package (in Python).
功能重要性描述了哪些功能是相关的。 它可以帮助您更好地了解已解决的问题，有时还可以利用特征选择来改进模型。 在这篇文章中，我将介绍3种方法(使用代码)，以scikit-learn包(在Python中)为随机森林算法计算功能重要性。 内置随机森林重要性 (Built-in Random Forest Importance) The Random Forest algorithm has built-in feature importance which can be computed in two ways:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b85667bac6a137a5f3d2b9cd07944edf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fb3ea020e766ad18a713031efba799e/" rel="bookmark">
			Java集合--ConcurrentHashMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ConcurrentHashMap，HashTable，TreeMap，LinkedHashMap ConcurrentHashMap
ConcurrentHashmap与HashMap相似，其特点有：
支持并发操作，是线程安全的采用了分段锁(Segment锁)，来实现并发操作。 ConcurrentHashMap包括多个Segment段，相当于Segment数组，每个Segment继承了ReentrantLock来进行加锁，每次锁操作锁住的是一个Segment，于是一个线程在读写某个Segment时，该Segment上锁，保证了线程的安全，同时其他的线程可以读写没被上锁的Segment，实现了多线程的并发操作。
concurrencyLevel: 并发数，Segment数。表示ConcurrentHashMap中包含的Segment数量，默认值是16.
也就是最多同时支持16个线程的写操作。并发数可以在初始化时设置，一旦初始化后不能扩容。
Java8中ConcurrentHashMap也引入了红黑树，每个Segment的实现与HashMap类似。
ConcurrentHashMap的方法与HashMap基本相同，详见HashMap用法
HashTable
HashTable是遗留的类，功能与HashMap类似，是线程安全的，同一时间只有一个线程能写，并发性不如ConcurrentHashMap。
不建议使用HashTable，可以用HashMap和ConcurrentHashMap代替。
TreeMap
TreeMap实现了SortedMap接口，能够根据键值排序，默认按键值升序排序。
也可以指定排序的比较器。
使用TreeMap时，key要实现Comparable接口或者传入自定义的Comparator比较器，也就是key要能够比较都行，否则报错。
LinkedHashMap
在HashMap的基础上，记录了元素插入的顺序，因此其遍历顺序与插入顺序是相同的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe73123c02ed4a705c6ab5dcaf6e477/" rel="bookmark">
			刷机流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刷机流程
（1）首先配置adb环境变量，win+r输入cmd进入命令行，输入adb。
此时表示adb已经配置成功。
（2）将设备连接到主机后，在命令行输入：adb reboot edl。进入EDL模式后开始进行刷机。
（3）打开QFIL，点击Configuration进入FireHose Configuration。
（4）出现Download Configuration窗口，对Device Type选择为ufs，并选择Reset After Download(下载后重启)。设置好后关闭窗口。
（5）然后在QFIL界面上点击SelectPort选择要要刷机的设备。
（6）最后点击LoadContent,选择相应版本的content.xml。
（7）点击Download Content进行下载，完成后Status会显示下载成功。此时平板进行重启，刷机完成。、
adb 常用指令：
adb devices :显示当前可用设备。
adb reboot :重启设备。
adb logcat:打印日志到目录。
adb shell:进入设备。
adb pull:从设备拉取文件。
Lenovo File Exchange
可以通过Lenovo File Exchange可以作为版本上传的platform(平台)；当乙方在Lenovo File Exchange上传版本后，甲方可通过它进行下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e40a9e43a9542c12ee69c62654446206/" rel="bookmark">
			Java集合--HashMap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java集合–HashMap 简介
HashMap是Java集合的一种，实现了Map接口，使用频率非常高。
HashMap中存储的是Entry&lt;&gt;键值对&lt;key,value&gt;，key与value一一对应，在Map中Key值是唯一的，但value值可以有重复。
HashMap的特点有：
允许空键和空值(但空健只能有一个，且放在第一位)元素是无序的，而且输出顺序和存放顺序不一样key值不能重复底层的实现是数组+链表，JDK8后又加了红黑树，链表长度达到8之后变成红黑树可以在o(1)时间定位到要查询的数据同一时间内可以有多个线程同时读写，所以是线程不安全的 常用方法 创建
HashMap&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;(); 添加元素：put()
map.put(1,"one"); 取出元素：get()
String val = map.get(1); // "one" String val2 = map.get(5); // null 判断为空：isEmpty()
map.isEmpty(); // false 判断是否含有key：containsKey(key)
map.containsKey(2); // false 判断是否含有value：containsValue(value)
map.containsValue("one"); // true 删除key对应的值：remove(key)
String str = map.remove(1); // "one" 删除键值对：remove(key,value)
map.remove(1,"two"); // 键值对不存在时，返回false map.remove(1,"one"); // 键值对存在时，删除并返回true HashMap中元素的个数
map.size(); 显示所有的value：values()
map.values(); // [] 显示所有的key：keySet()
map.keySet(); // [] 显示所有的key和value：entrySet()
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e40a9e43a9542c12ee69c62654446206/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/416/">«</a>
	<span class="pagination__item pagination__item--current">417/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/418/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>