<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64da6f00d925074593af934a9e2fd167/" rel="bookmark">
			关于mysql双游标嵌套循环方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql双游标嵌套循环 系统要上线新功能，引入了BPMN流程引擎，引入该引擎后就会涉及到历史数据处理问题，因为系统已经生成了上千条业务数据，由于不是靠BPMN引擎流转的，所以需要将业务数据和流程引擎关联起来，有多少条在执行的业务数据，就生成多少条流程实例，我们的流程引擎使用的是activiti流程引擎框架；
其中一块的历史数据处理是要查询出符合条件的历史数据，然后遍历循环业务，业务数据中有个处理人的字段是多人的，要把这个多人的以逗号分隔开，有几人再次循环几次；
废话不多说，直接上代码：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64da6f00d925074593af934a9e2fd167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078fd9db714c6e14586ae2e348f6350b/" rel="bookmark">
			FFT频谱分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FFT是离散傅立叶变换的快速算法，可以将一个信号变换到频域。有些信号在时域上是很难看出什么特征的，但是如果变换到频域之后，就很容易看出特征了。这就是很多信号分析采用FFT变换的原因。另外，FFT可以将一个信号的频谱提取出来，这在频谱分析方面也是经常用的。
虽然很多人都知道FFT是什么，可以用来做什么，怎么去做，但是却不知道FFT之后的结果是什意思、如何决定要使用多少点来做FFT。 现在就根据实际经验来说说FFT结果的具体物理意义。一个模拟信号，经过ADC采样之后，就变成了数字信号。采样定理告诉我们，采样频率要大于信号频率的两倍。&lt;
采样得到的数字信号，就可以做FFT变换了。N个采样点，经过FFT之后，就可以得到N个点的FFT结果。为了方便进行FFT运算，通常N取2的整数次方。假设采样频率为Fs，信号频率F，采样点数为N。那么FFT之后结果就是一个为N点的复数。
每一个点就对应着一个频率点。这个点的模值，就是该频率值下的幅度特性。具体跟原始信号的幅度有什么关系呢？假设原始信号的峰值为A，那么FFT的结果的每个点（除了第一个点直流分量之外）的模值就是A的N/2倍。而第一个点就是直流分量，它的模值就是直流分量的N倍。
而每个点的相位呢，就是在该频率下的信号的相位。第一个点表示直流分量（即0Hz），而最后一个点N的再下一个点（实际上这个点是不存在的，这里是假设的第N+1个点，也可以看做是将第一个点分做两半分，另一半移到最后）则表示采样频率Fs，这中间被N-1个点平均分成N等份，每个点的频率依次增加。例如某点n所表示的频率为：Fn=(n-1)Fs/N。由上面的公式可以看出，Fn所能分辨到频率为为Fs/N，如果采样频率Fs为1024Hz，采样点数为1024点，则可以分辨到1Hz。1024Hz的采样率采样1024点，刚好是1秒，也就是说，采样1秒时间的信号并做FFT，则结果可以分析到1Hz，如果采样2秒时间的信号并做FFT，则结果可以分析到0.5Hz。如果要提高频率分辨力，则必须增加采样点数，也即采样时间。频率分辨率和采样时间是倒数关系。假设FFT之后某点n用复数a+bi表示，那么这个复数的模就是An=根号aa+b*b，相位就是Pn=atan2(b,a)。
根据以上的结果，就可以计算出n点（n≠1，且n&lt;=N/2）对应的信号的表达式为：An/(N/2)cos(2piFnt+Pn)，即2An/Ncos(2piFn*t+Pn)。对于n=1点的信号，是直流分量，幅度即为A1/N。 由于FFT结果的对称性，通常我们只使用前半部分的结果，即小于采样频率一半的结果。
好了，说了半天，看着公式也晕，下面以一个实际的&lt;/s信号来做说明。 假设我们有一个信号，它含有2V的直流分量，频率为50Hz、相位为-30度、幅度为3V的交流信号，以及一个频率为75Hz、相位为90度、幅度为1.5V的交流信号。用数学表达式就是如下：
S=2+3cos(2pi50t-pi30/180)+1.5cos(2pi75t+pi90/180)
式中cos参数为弧度，所以-30度和90度要分别换算成弧度。我们以256Hz的采样率对这个信号进行采样，总共采样256点。按照我们上面的分析，Fn=(n-1)*Fs/N，我们可以知道，每两个点之间的间距就是1Hz，第n个点的频率就是n-1。我们的信号有3个频率：0Hz、50Hz、75Hz，应该分别在第1个点、第51个点、第76个点上出现峰值，其它各点应该接近0。实际情况如何呢？我们来看看FFT的结果的模值如图所示。
从图中我们可以看到，在第1点、第51点、和第76点附近有比较大的值。我们分别将这三个点附近的数据拿上来细看：
1点： 512+0i
2点： -2.6195E-14 - 1.4162E-13i
3点： -2.8586E-14 - 1.1898E-13i
50点：-6.2076E-13 - 2.1713E-12i
51点：332.55 - 192i
52点：-1.6707E-12 - 1.5241E-12
75点：-2.2199E-13 -1.0076E-12i
76点：3.4315E-12 + 192i
77点：-3.0263E-14 +7.5609E-13i
很明显，1点、51点、76点的值都比较大，它附近的点值都很小，可以认为是0，即在那些频率点上的信号幅度为0。接着，我们来计算各点的幅度值。分别计算这三个点的模值，结果如下：
1点： 512
51点：384
76点：192
按照公式，可以计算出直流分量为：512/N=512/256=2；
50Hz信号的幅度为：384/(N/2)=384/(256/2)=3；75Hz信号的幅度为192/(N/2)=192/(256/2)=1.5。可见，从频谱分析出来的幅度是正确的。
然后再来计算相位信息。直流信号没有相位可言，不用管它。先计算50Hz信号的相位，atan2(-192,
332.55)=-0.5236,结果是弧度，换算为角度就是180*(-0.5236)/pi=-30.0001。再计算75Hz信号的相位，atan2(192,
3.4315E-12)=1.5708弧度，换算成角度就是180*1.5708/pi=90.0002。可见，相位也是对的。根据FFT结果以及上面的分析计算，我们就可以写出信号的表达式了，它就是我们开始提供的信号。
总结：假设采样频率为Fs，采样点数为N，做FFT之后，某一点n（n从1开始）表示的频率为：Fn=(n-1)*Fs/N；该点的模值除以N/2就是对应该频率下的信号的幅度（对于直流信号是除以N）；该点的相位即是对应该频率下的信号的相位。相位的计算可用函数atan2(b,a)计算。atan2(b,a)是求坐标为(a,b)点的角度值，范围从-pi到pi。要精确到xHz，则需要采样长度为1/x秒的信号，并做FFT。要提高频率分辨率，就需要增加采样点数，这在一些实际的应用中是不现实的，需要在较短的时间内完成分析。解决这个问题的方法有频率细分法，比较简单的方法是采样比较短时间的信号，然后在后面补充一定数量的0，使其长度达到需要的点数，再做FFT，这在一定程度上能够提高频率分辨力。具体的频率细分法可参考相关文献。
[附录：本测试数据使用的matlab程序] close all; %先关闭所有图片 Adc=2;&amp;nbsp;&amp;nbsp;%直流分量幅度 A1=3;&amp;nbsp; &amp;nbsp;%频率F1信号的幅度 A2=1.5; %频率F2信号的幅度 F1=50;&amp;nbsp;&amp;nbsp;%信号1频率(Hz) F2=75;&amp;nbsp;&amp;nbsp;%信号2频率(Hz) Fs=256; %采样频率(Hz) P1=-30; %信号1相位(度) P2=90;&amp;nbsp;&amp;nbsp;%信号相位(度) N=256;&amp;nbsp;&amp;nbsp;%采样点数 t=[0:1/Fs:N/Fs]; %采样时刻 %信号 S=Adc+A1*cos(2*pi*F1*t+pi*P1/180)+A2*cos(2*pi*F2*t+pi*P2/180); %显示原始信号 plot(S); title('原始信号') figure; Y = fft(S,N); %做FFT变换 Ayy = (abs(Y)); %取模 plot(Ayy(1:N)); %显示原始的FFT模值结果 title('FFT 模值'); figure; Ayy=Ayy/(N/2);&amp;nbsp; &amp;nbsp;%换算成实际的幅度 Ayy(1)=Ayy(1)/2; F=([1:N]-1)*Fs/N; %换算成实际的频率值 plot(F(1:N/2),Ayy(1:N/2));&amp;nbsp; &amp;nbsp;%显示换算后的FFT模值结果 title('幅度-频率曲线图'); figure; Pyy=[1:N/2]; for i="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/078fd9db714c6e14586ae2e348f6350b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec815b8e30d1ab68899469e83fbd2dda/" rel="bookmark">
			cas整合client端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概念 首先我们来说一下CAS，CAS全称为Central Authentication Service即中央认证服务，是一个企业多语言单点登录的解决方案，并努力去成为一个身份验证和授权需求的综合平台。
2.流程图 Service ticket(ST) ：服务票据，服务的惟一标识码 , 由 CAS Server 发出（ Http 传送），通过客户端浏览器到达业务服务器端；一个特定的服务只能有一个惟一的 ST ；
3.实现 3.1导入依赖 &lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-support-springboot&lt;/artifactId&gt; &lt;version&gt;3.6.3&lt;/version&gt; &lt;/dependency&gt; 3.2 写入cas集成配置类 /** * CAS集成核心配置类 */ @Configuration @Slf4j @ConditionalOnProperty(value = "cas.loginType", havingValue = "cas") public class CasFilterConfig { /** * 需要走cas拦截的地址（/* 所有地址都拦截） */ @Value("${cas.urlPattern:/login}") private String filterUrl; /** * 默认的cas地址，防止通过 配置信息获取不到 */ @Value("${cas.server-url-prefix:https://ip/cas}") private String casServerUrl; /** * 认证地址（这个地址需要在cas服务端进行配置） */ @Value("${cas.authentication-url-patterns:https://ip/cas}") private String authenticationUrl; /** * 应用访问地址（这个地址需要在cas服务端进行配置） */ @Value("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec815b8e30d1ab68899469e83fbd2dda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c925d924dc11b3b30a164f9c96e6ff28/" rel="bookmark">
			gerber导出文件解析，二十几个文件都是干什么的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.drc文件和html文件2.apr文件3.DRR文件4.EXTREP文件5.GBL文件6.GBO文件7.GBS文件（这个就是绿油上需要开窗的地方，目的是允许焊接）8.GD1文件9.GG1文件10.GM1、GM13、GM15文件11.GPB文件、GPT文件12.GTL文件、GTO文件、GTP文件、GTS文件 1.drc文件和html文件 答：这两个就是ad进行drc规则检查之后，输出的文件，每种规则检查是否存在问题。
2.apr文件 答：
“apr” 文件扩展名通常用于表示 Aperture Data（光圈数据）。
Aperture Data 文件包含了描述 PCB 制造过程中使用的光圈（也称为绘制对象、元件或图形）的信息。光圈定义了 PCB 上的不同绘制形状和尺寸。
在 Gerber 文件中，光圈定义了 PCB 的电路连接、丝印、阻焊层等等。光圈数据文件（.apr）包含了定义这些不同绘制对象的几何形状、尺寸和参数信息。Gerber 文件中的其他文件通过引用特定光圈来指定特定的绘制对象或绘制要素。
光圈数据文件通常由 PCB 设计软件生成，并与其他 Gerber 文件一起用于制造和生产过程中的 PCB 制造。它们对于正确表示和定位 PCB 中的不同绘制对象是至关重要的。
3.DRR文件 答：
钻孔报告文件（DRR，Drill Report）是一个文本文件，为 PCB 制造过程中的钻孔操作提供了详细信息。它列出了 PCB 上每个钻孔的位置、尺寸、孔径以及必要的钻孔操作说明。
4.EXTREP文件 额外文件，可能会补充以下信息：
Center Mark（中心标记）：如果 PCB 需要定位或机械加工（例如钻孔），“extrep” 文件可能包含每个元件或每个图层的中心坐标。这样，在加工过程中，设备可以根据这些坐标进行定位和对齐。
Assembly Reference（装配参考）：“extrep” 文件可能还包含用于组装或焊接的引用点或参考点的位置信息。这些信息可用于确保组装过程中正确放置元件，并与其他元件对齐。
特殊要求：某些情况下，“extrep” 文件可能包含特定的制造要求或设计规则。这些要求可能涉及特殊的工艺、层厚、金属厚度、阻焊颜色等。
5.GBL文件 答：
Bottom Layer 底层走线
6.GBO文件 答：
Bottom Overlay 底层丝印
7.GBS文件（这个就是绿油上需要开窗的地方，目的是允许焊接） 答：
Bottom Solder 底层阻焊(也叫防锡层,负片)
（1）当GBS文件是这样的，实际出来的pcb板就会变成这样，因为都被阻焊层覆盖了，所以元器件内根本没有绿油，这个插座的40个pin都接在一起，会造成短路…
（2）正常应该是这样的，黑色的部分会覆盖上绿油，粉色的位置会阻焊开窗，这样就是正常的焊接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c925d924dc11b3b30a164f9c96e6ff28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac1983f21cc162683254eb34cbf3bf9/" rel="bookmark">
			H5端Video无法自动播放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景说明 开发活动落地页需要自动视频，发现在PC端chrome【版本:116】上，autoplay属性就能正常播放。
但是在H5端微信和safari浏览器上的表现，都是不能自动播放。
翻了一些资料，以下为整理的解决文案。
微信环境不能自动播放 // 解决 ios 微信 video 自动播放 document.addEventListener( 'WeixinJSBridgeReady', function () { const video = document.querySelector('video'); video &amp;&amp; video.play(); }, false, ); 手机浏览器不能自动播放【以下方式按需使用】 Tip: Js和标签上的属性都很重要。【muted，playsInline】
解决方式一： // js const video = document.querySelector('video'); video.playsInline = true; // html &lt;video autoPlay muted preload="auto" // 视频优先加载 x5-video-player-type="h5" //同层H5播放器，就是在视频全屏的时候，div可以呈现在视频层上 x5-video-player-fullscreen="false" // 全屏播放 src={videoUrl} /&gt; 解决方式二： // js const video = document.querySelector('video'); let videoPromise; if (video) { videoPromise = video?.play(); if (videoPromise !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac1983f21cc162683254eb34cbf3bf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8530c7c1214b6aae14f343b1b3fb24c9/" rel="bookmark">
			JDK21最终版协程实现之虚拟线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 全新并发编程模式 JDK9 后的版本你觉得没必要折腾，我也认可，但是JDK21有必要关注。因为 JDK21 引入全新的并发编程模式。
一直沽名钓誉的GoLang吹得最厉害的就是协程了。JDK21 中就在这方面做了很大的改进，让Java并发编程变得更简单一点，更丝滑一点。
之前写过JDK21 Feature。Virtual Threads、Scoped Values、Structured Concurrency就是针对多线程并发编程的几个功能。。
2 发展历史 虚拟线程是轻量级线程，极大地减少了编写、维护和观察高吞吐量并发应用的工作量。
虚拟线程是由JEP 425提出的预览功能，并在JDK 19中发布，JDK 21中最终确定虚拟线程，以下是根据开发者反馈从JDK 20中的变化：
现在，虚拟线程始终支持线程本地变量。与在预览版本中允许的不同，现在不再可能创建不能具有线程本地变量的虚拟线程。对线程本地变量的有保障支持确保了许多现有库可以不经修改地与虚拟线程一起使用，并有助于将以任务为导向的代码迁移到使用虚拟线程直接使用Thread.Builder API创建的虚拟线程（而不是通过Executors.newVirtualThreadPerTaskExecutor()创建的虚拟线程）现在默认情况下也会在其生命周期内进行监控，并且可以通过描述在"观察虚拟线程"部分中的新线程转储来观察。 基于协程的线程，与其他语言中的协程有相似之处，也有不同。虚拟线程是依附于主线程的，如果主线程销毁了，虚拟线程也不复存在。
3 目标 使采用简单的 thread-per-request 模式编写的服务器应用程序，能以接近最佳的硬件利用率扩展使利用java.lang.Thread API的现有代码能在最小更改下采用虚拟线程通过现有的JDK工具轻松进行虚拟线程的故障排除、调试和分析 4 非目标 不是删除传统的线程实现，也不是悄悄将现有应用程序迁移到使用虚拟线程不是改变Java的基本并发模型不是在Java语言或Java库中提供新的数据并行构造。Stream API仍是处理大型数据集的首选方式。 5 动机 Java开发人员在近30年来一直依赖线程作为并发服务端应用程序的构建块。每个方法中的每个语句都在一个线程内执行，并且由于Java是多线程，多个线程同时执行。
线程是Java的并发单元：它是一段顺序代码，与其他这样的单元并发运行，很大程度上是独立的。每个线程提供一个堆栈来存储局部变量和协调方法调用及在出现问题时的上下文：异常由同一线程中的方法抛出和捕获，因此开发可使用线程的堆栈跟踪来查找发生了啥。
线程也是工具的核心概念：调试器逐步执行线程方法中的语句，分析工具可视化多个线程的行为，以帮助理解它们的性能。
6 thread-per-request模式 服务器应用程序通常处理彼此独立的并发用户请求，因此将一个线程专用于处理整个请求在逻辑上是合理的。这种模式易理解、易编程，且易调试和分析，因为它使用平台的并发单元来表示应用程序的并发单元。
服务器应用程序的可扩展性受到Little定律约束，该定律关联延迟、并发性和吞吐量：对给定的请求处理持续时间（即延迟），应用程序同时处理的请求数量（并发性）必须与到达速率（吞吐量）成比例增长。如一个具有平均延迟为50ms的应用程序，通过同时处理10个请求实现每秒处理200个请求的吞吐量。为使该应用程序扩展到每秒处理2000个请求吞吐量，它要同时处理100个请求。如每个请求在其持续时间内都使用一个线程（因此使用一个os线程），那在其他资源（如CPU或网络连接）耗尽前，线程数量通常成为限制因素。JDK对线程的当前实现将应用程序的吞吐量限制在远低于硬件支持水平的水平。即使线程进行池化，仍然发生，因为池化可避免启动新线程的高成本，但并不会增加总线程数。
7 使用异步模式提高可扩展性 一些开发人员为了充分利用硬件资源，已经放弃了采用"thread-per-request"的编程风格，转而采用"共享线程"。这种方式，请求处理的代码在等待I/O操作完成时会将其线程返回给一个线程池，以便该线程可以为其他请求提供服务。这种对线程的精细共享，即只有在执行计算时才保持线程，而在等待I/O时释放线程，允许高并发操作而不消耗大量线程资源。虽然它消除了由于os线程有限而导致的吞吐量限制，但代价高：它需要一种异步编程风格，使用一组专门的I/O方法，这些方法不会等待I/O操作完成，而是稍后通过回调通知其完成。
在没有专用线程情况下，开发须将请求处理逻辑分解为小阶段，通常编写为lambda表达式，然后使用API（如CompletableFuture或响应式框架）将它们组合成顺序管道。因此，他们放弃语言的基本顺序组合运算符，如循环和try/catch块。
异步风格中，请求的每个阶段可能在不同线程执行，每个线程交错方式运行属于不同请求的阶段。这对于理解程序行为产生了深刻的影响：堆栈跟踪提供不了可用的上下文，调试器无法逐步执行请求处理逻辑，分析器无法将操作的成本与其调用者关联起来。使用Java的流API在短管道中处理数据时，组合lambda表达式是可管理的，但当应用程序中的所有请求处理代码都必须以这种方式编写时，会带来问题。这种编程风格与Java平台不符，因为应用程序的并发单位——异步管道——不再是平台的并发单位。
8 通过虚拟线程保持 thread-per-request 编程风格 为了在保持与平台和谐的情况下使应用程序能扩展，应努力通过更高效方式实现线程，以便它们可更丰富存在。os无法更高效实现操作系统线程，因为不同编程语言和运行时以不同方式使用线程堆栈。然而，JRE可通过将大量虚拟线程映射到少量操作系统线程来实现线程的伪装丰富性，就像os通过将大型虚拟地址空间映射到有限的物理内存一样，JRE可通过将大量虚拟线程映射到少量操作系统线程来实现线程的伪装丰富性。
虚拟线程是java.lang.Thread一个实例，不与特定os线程绑定。相反，平台线程是java.lang.Thread的一个实例，以传统方式实现，作为包装在操作系统线程周围的薄包装。
采用 thread-per-request 编程风格的应用程序，可在整个请求的持续时间内在虚拟线程中运行，但虚拟线程仅在它在CPU上执行计算时才会消耗os线程。结果与异步风格相同，只是它是透明实现：当在虚拟线程中运行的代码调用java.* API中的阻塞I/O操作时，运行时会执行非阻塞的os调用，并自动暂停虚拟线程，直到可稍后恢复。对Java开发，虚拟线程只是便宜且几乎无限丰富的线程。硬件利用率接近最佳，允许高并发，因此实现高吞吐量，同时应用程序与Java平台及其工具的多线程设计保持和谐一致。
9 虚拟线程的含义 虚拟线程成本低且丰富，因此永远都不应被池化：每个应用程序任务应该创建一个新的虚拟线程。因此，大多数虚拟线程将是短暂的，且具有浅层次的调用栈，执行的操作可能只有一个HTTP客户端调用或一个JDBC查询。相比之下，平台线程是重量级且代价昂贵，因此通常必须池化。它们倾向于具有较长的生命周期，具有深层次调用栈，并在许多任务间共享。
总之，虚拟线程保留了与Java平台设计和谐一致的可靠的 thread-per-request 编程风格，同时最大限度地利用硬件资源。使用虚拟线程无需学习新概念，尽管可能需要放弃为应对当前线程成本高昂而养成的习惯。虚拟线程不仅将帮助应用程序开发人员，还将帮助框架设计人员提供与平台设计兼容且不会牺牲可伸缩性的易于使用的API。
10 描述 如今，JDK 中的每个 java.lang.Thread 实例都是平台线程。平台线程在底层os线程上运行 Java 代码，并在代码的整个生命周期内捕获os线程。平台线程的数量受限于os线程的数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8530c7c1214b6aae14f343b1b3fb24c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/930522f44cff64ac451d20bf0550ce96/" rel="bookmark">
			github 网页显示不全？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 解决 1、检查网页，打开 network，重新刷新 github 网页
2、查看无法加载的资源（如 css 文件）
3、查看域名地址 站长工具 DNS，github.githubassets.com（检查网页元素，点击无法获取的资源）
4、修改 host 文件，添加 TTL 值最大的域名映射
也可以通过 Ping 检测，选择响应时间最短的那个 IP 地址。
修改保存，最后刷新ipconfig /flushdns 或重启电脑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7570db07bc6c11c330aef436d9bc6471/" rel="bookmark">
			在crontab中使用$(date&#43; %Y%m%D)的引发的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题原因 前几天有个定时任务执行经常出现问题，开发有没有执行日志，查看/var/log/cron定时任务执行日志，到了执行时间也确实执行了命令，但是没有执行结果，开发说能不能把执行结果展示出来，我说没问题，首先在命令行测试一下，发现执行成功，于是在cron里添加了个重定向，命令如下：
xxxx &gt; /var/log/check/$(date +\%Y\%m\%d)-check.log 2&gt;&amp;1 到了第二天，开发说定时任务依旧没有执行，我说我看看执行日志，发现 /var/log/check/没有定义好的check.log，这下郁闷了，压根没有执行，但是/var/log/cron却显示执行了，实际是执行失败，按照我的理解，即使后面的重定向命令执行失败，是不会影响前面的命令执行的，现实是前面的命令确实没有执行，为了验证，我又在在测试服务期又做了一遍测试，随便写了个命令，按照上面的格式添加了crontab，定时任务依旧没执行，这下妥妥的打脸了，当时还给开发保证，cron命令写的没错，于是百度查找原因，找到了一篇文章：】
Cron job with $(date) command and redirect won’t run
里面在Best answer里有个回答：
I’m not sure how I missed this before but you are using a bash syntax for creating a subshell to run your command in. Since cron is not bash, this won’t work.
原因是你使用了shell，但是cron并不是shell，所以它无法工作。按照Linux命令的执行规则，执行命令是首先执行最右边的子shell，如果子shell执行失败，前面的则不会在执行。而$(date +\%Y\%m\%d)恰恰是个子shell，所说义执行失败
同时作者给了正确的写法：
0 20 * * * /data/code/scripts/foo.sh &gt;/root/foo.`date +\%Y-\%m-\%d-\%T`.log 2&gt;&amp;1 按照文章提示的方法，重新改写，果然执行成功，并且给出来了具体的错误原因，开发修改后，测试了几次，没在出问题。
总结 做任何事话不要说死；认真测试；做好笔记； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee1e614bbb8e61c72fc27223f9983652/" rel="bookmark">
			统计一个目录下各类文件数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近笔者在研究tomcat底层架构，肯定要扒一扒tomcat源码，笔者希望知道工作量有多大，也就是统计一下tomcat源码中文件有多少。笔者首先是个比较懒得人（不懒也不会干IT）,所以不可能手动的去统计，也不会自己写代码去统计，然后在网上找了一个java版本的代码。
java代码如下：
package statistic; import java.io.File; public class Test { static int count=0; public static void main(String[] args) { getFile("D:/eclipse/work/apache-tomcat-6.0.35-src"); System.out.println("共有"+count+"个文件"); } public static void getFile(String filepath) { //com.bizwink.cms.util.Convert con = new com.bizwink.cms.util.Convert(); File file = new File(filepath); File[] listfile = file.listFiles(); for (int i = 0; i &lt; listfile.length; i++) { //System.out.println("****** = "+listfile[i].getPath().toString()); if (!listfile[i].isDirectory()) { //com.bizwink.cms.util.Convert con = new com.bizwink.cms.util.Convert(); String temp=listfile[i].toString().substring(7,listfile[i].toString().length()) ; //System.out.println("temp=="+temp); //con.convertFile(listfile[i].toString(), "D:\\newtest"+temp, 0, 3); count++; //System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee1e614bbb8e61c72fc27223f9983652/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56528ba76b67ac76f389a868cb0d94d2/" rel="bookmark">
			使用ElementUI完成登入注册的跨域请求提高开发效率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🎬 艳艳耶✌️：个人主页
🔥 个人专栏 ：《Spring与Mybatis集成整合》​​​​​​​
⛺️ 生活的理想，为了不断更新自己 !
目录
​编辑
1、前言
1.1.什么是ELementUI
2、完成登陆注册前端页面
2.1环境搭建
运行项目
使用命令添加Element-UI模块
测试ELementUI
2.2. 登录页面搭建
3、数据交互
3.1.安装相关模块
安装模块
引用模块
3.2.axios的get请求
3.3.axios的post请求
3.注册功能
4、跨域的概述
4.1.跨域​​​​​​​是什么
4.2.怎么解决跨域问题 1、前言 1.1.什么是ELementUI Element 是一款基于 Vue.js 的开源 UI 组件库，旨在帮助开发者构建出现代化的 Web 应用程序界面。它提供了丰富多样的可重用组件，并支持自定义主题和样式，使开发者能够快速搭建出具有良好用户体验的界面。
Element 是一个功能强大的前端 UI 组件库，通过提供丰富的组件和灵活的定制选项，使开发者能够快速构建现代化的 Web 应用程序界面。
2、完成登陆注册前端页面 2.1环境搭建 首先我们准备一个SPA项目
如果不会的话，可以参照我之前写的博客
【Vue】如何搭建SPA项目--详细教程https://blog.csdn.net/2301_76988707/article/details/133146622
运行项目 在SAP项目的根目录输入cmd后在cmd窗口输入npm run dev
输入最后那个网址结果就出来了。
使用命令添加Element-UI模块 npm install element-ui -S
先把项目终止，再进行下载，中途不可断开。
下载完成后项目里就会看该依赖
测试ELementUI 导入ELement的css与js到main.js中
// 新添加1 import ElementUI from 'element-ui' // 新添加2，避免后期打包样式不同，要放在import App from '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56528ba76b67ac76f389a868cb0d94d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96a20dd7d9e7f81b4c2d6a8fa9b44107/" rel="bookmark">
			Python深度学习入门 - - Transformers网络学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 一、Transformers架构原理 Transformer 架构与传统循环神经网络RNN、LSTM相比具有并行计算、自注意力机制、位置编码和多头注意力等方面的差异。这些差异使得 Transformer 在处理长序列、建模上下文关系和并行计算方面表现出更强的能力，成为自然语言处理和其他序列任务中的重要架构。
编码器由 6 个相同的层堆叠组成。每一层都有两个子层。第一个是多头自注意机制，第二个是简单的位置全连接前馈网络。我们在两个子层的每个周围都采用了残差连接，然后进行层归一化。
解码器也由6 个相同的层堆叠组成。除了每个编码器层中的两个子层外，解码器还插入了第三个子层，对编码器堆栈的输出执行多头关注。与编码器类似，我们在每个子层周围采用残差连接，然后进行层归一化。
1、自注意力层（Self-Attention） Transformers架构中加入了自注意力层，自注意力层相比之前GRU（门控循环单元），能并行地关注更多序列信息，这使得Transformers网络不再简单地依据前后依赖关系来建模序列信息的相关性，Transformers网络能关注更远的序列信息，从而捕获建模更长的时序关系。
假设输入序列为 X ∈ R L × d model X \in \mathbb{R}^{L \times d_{\text{model}}} X∈RL×dmodel​，其中 L L L 表示序列长度， d model d_{\text{model}} dmodel​ 表示隐藏层的维度。多头注意力机制将输入序列分别映射为 h h h 个不同的查询（Query）、键（Key）和值（Value）序列，用于计算注意力分数。 S e l f − A t t e n t i o n Self-Attention Self−Attention 层的输入用矩阵 X i X_{i} Xi​ 进行表示，一般为词向量，则可以使用线性变换矩阵 W Q W^Q WQ， W K W^K WK， W V W^V WV用矩阵运算得到 Q i Q_i Qi​， K i K_i Ki​， V i V_i Vi​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96a20dd7d9e7f81b4c2d6a8fa9b44107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96851d92e2609d0fef5f141409dd2b63/" rel="bookmark">
			Mac上的utools无法找到本地搜索插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		utools安装地址
utools本地搜索用法
目前本地搜索只在win下，mac无福了
Mac可用cmd+space方法使用聚焦搜索，来搜索本地文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/983ddf778abd7a7b6bca5f6991c25ce1/" rel="bookmark">
			STM32/51单片机编程入门(点亮LED）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Keil 和 Proteus 的安装使用 keil软件的project建立和流水灯代码编辑。
proteus的文件建立和使用，这是流水灯的仿真图构建，灯的颜色是红黄绿，红黄绿，红黄。将Keil编辑的流水灯代码编译导出hex文件，再将hex文件导入51单片机里面就可以运行流水灯。
运行图：
以上就是利用Keil编辑流水灯代码运行并导出hex文件，再利用proteus软件进行仿真实验。
2.ARM开发：使用MDK编译stm32简单程序（闪烁LED） 在第一部分中已经安装了keil软件，在第二部分只用安装stm32 pack.
安装完成。
根据教程和查阅资料后编译程序。
编译完成后就进行仿真调试。
因为没用接入硬件设施，所以只能先进行程序的编译和仿真测试，但是后续可以利用proteus进行更加真实的仿真实验
Proteus的仿真
仿真之间的建立文件过程和第一部分一致。
3. 理论概念-常见嵌入式岗位面试题 1）嵌入式C程序代码对内存中的变量的修改操作与对外部设备(寄存器)的操作有以下相同和差别：
相同点： - 都需要使用相应的数据类型和语法进行读写操作。 - 都可以使用指针和地址操作符来访问和修改相应的值。 - 都需要注意数据的有效范围和溢出问题。
差异点： - 对内存中的变量的修改操作只涉及到内部存储器的读写，操作较为灵活，没有涉及到外部设备的时序和IO接口特性。 - 对外部设备的操作需要借助寄存器的读写，包括控制寄存器和数据寄存器，操作受设备的特性限制。 - 对外部设备的操作通常需要配置相应的时序和IO口的状态。 - 对外部设备的操作通常需要关注中断和事件的处理机制。
2）对于为什么51单片机的LED点灯编程要比STM32简单，主要是由于以下几个方面的原因：
- 51单片机的架构较为简单，IO口的数量较少且直接可用，所以只需要通过简单的配置和控制即可实现LED点灯。而STM32芯片拥有复杂的外设和IO口资源，配置和控制的步骤相对较多。 - 51单片机的编程环境和工具链相对简单，学习和上手较容易。而STM32的编译环境和开发工具链相对复杂，需要更多的学习和配置工作。 - 51单片机的文档和资料较为丰富，社区支持较好，可以方便地获取到各种例程和教程等资源。而STM32的文档和资料相对较多，但是由于种类繁多，有时可能需要花费更多的时间来找到适合的资源。
综上所述，相比于STM32芯片，51单片机的LED点灯编程更加简单和直接。但是需要注意的是，STM32芯片强大的外设资源和丰富的功能还是给嵌入式系统开发带来了更大的灵活性和扩展性。
4.理论概念-常见嵌入式岗位面试题 register关键字： register关键字用于提示编译器将变量存储在寄存器中，而不是存储在内存中。寄存器具有更快的访问速度，因此将变量存储在寄存器中可以提高程序的执行效率。然而，编译器不一定会将变量存储在寄存器中，因为寄存器的数量有限。当使用register关键字时，编译器会尽量将变量存储在寄存器中，但具体是否存储在寄存器中取决于编译器的决策。
使用register关键字声明的变量通常用于频繁访问的变量，例如循环计数器或状态标志位等。
示例代码： ```c void foo(void) { register int a = 0; // 将变量a存储在寄存器中
for (a = 0; a &lt; 10; a++) { // do something } } ```
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/983ddf778abd7a7b6bca5f6991c25ce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d5f3fc0d3e5c2a8b6c69bf2e0c2cfee/" rel="bookmark">
			Rocky Linux/CentOS/Alma上装KDE Plasma桌面环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍在Rocky Linux/CentOS/Alma Linux系统上安装KDE Plasma桌面环境的方法，用户请按照以下步骤安装KDE Plasma Desktop，请注意，只有系统支持dnf命令才可以使用以下方法，比如它不适用于Debian、Ubuntu、Linux Mint系统中。
1、添加EPEL存储库 在Rocky Linux/CentOS/Alma Linux系统中添加EPEL存储库，运行以下命令：
sudo dnf install epel-release
2、安装KDE Plasma 在添加EPEL存储库完成后下载并且安装KDE Plasma，运行以下命令：
sudo dnf groupinstall -y “KDE” 或
sudo dnf groupinstall -y “KDE Plasma Workspaces”
3、启用PowerTools 以下步骤可以不执行 安装dnf-plugins-core，运行以下命令：
sudo dnf install dnf-plugins-core
完成后，启用PowerTools：
sudo dnf config-manager --set-enabled powertools
sudo dnf --enablerepo=epel,powertools group -y install “KDE Plasma Workspaces” “base-x”
此时系统如果运行的是最小服务器，需要把默认系统的目标设置为graphical，如下所示：
sudo systemctl set-default graphical
4、更改桌面环境 完成后，需要重新启动系统才能切换到刚安装好的KDE Plasma桌面，请运行sudo reboot命令重启或注销重启后就可以切换到Plasma桌面了，如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d361c0ea9165588e02c355b2a33ec053/" rel="bookmark">
			AD 2020 入门教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Altium designer（简称AD）是一款电子产品开发系统软件。该软件通过把原理图设计、电路仿真、PCB绘制编辑、拓扑逻辑自动布线、信号完整性分析和设计输出等技术完美融合，为设计者提供全新的设计解决方案，熟练使用这一软件能提高电路设计的质量和效率。
和C语言学习中的“hello world”一样，我们学习AD最开始也将从建立一个工程项目开始。因为我这里的版本是AD 2020，所以我用2020版本来演示，但其他版本步骤基本是一样的。
一、新建项目 打开AD 2020，点击左上角的File--＞New--＞Project，如下图所示。
然后自定义项目名称和保存位置，这个根据自己习惯来就好，最后点击create。 二、添加文件 在建立好工程文件后，可以看到左边项目栏显示“No Documents Added”，也就是这个项目是空的，因为我们没有添加任何文件，接下来我们就开始往这个空项目里添加文件。
1、添加原理图
在设计pcb之前，我们首先要根据项目要求来进行原理图的设计，也就是首先要添加原理图。详细步骤就是Project--＞Add New to Project--＞Schematic，这里的Schematic就是指原理图。
2、生成PCB
假设我们现在已经画完了原理图，接下来就是生成对应的PCB。这里我拿一个我之前画过的原理图示例，如下图所示。
生成PCB之前很重要的一步就是给我们原理图中的元件添加封装。元件封装（Footprint）也就是元件外形名称，因为每个人的元件封装库是不一样的，但是当我们设计PCB时，我们需要根据我们手边的实物元件的对应封装来设计，不然你PCB画出来，元件也会焊不上去，因此我们这里首先给原理图上的元件添加合适的封装，这里以稳压芯片LM7812为例。
首先，我们鼠标左键点击我们所需要的元件，可以看到软件界面右栏会弹出这个元件的相关属性，这个时候我们点击 Footprints ，可以看到左下图，因为我事先已经添加过封装，所以这里直接有对应的封装图显示。
一般情况下，如果元件没有封装或者需要修改对应的封装，这个时候就要点击右上图中的 Value 右边的箭头，然后就会弹出很多封装选项，点击图中的 Click to display preview，就可以看到每款封装的样子，你选择对应的就好了，剩余的所有元件也是一样。
如果出现没有封装的情况，就说明你还没有安装元件库，元件库的资源网上还是很多的，可以自行下载，封装库后缀名一般是.Pcblib，下载下来双击就会自动安装。
在给所有的元件添加好对应的封装后，下一步就是生成PCB了，具体操作如下。
首先要添加一个空PCB，详细步骤就是Project--＞Add New to Project--＞PCB。完成上述步骤后，在PCB文件界面中，依次单击工具栏的“设计”--&gt;“Import changes from xxx.PrjPcb”选项，如下图所示，然后进入下一步。
完成上述步骤后，在出现的窗口中，单击“生效更改”按钮，再单击“执行更改”按钮，进入下一步。
最后进行的就是布线工作了。
电气研究生，接下来会将自己所学的知识慢慢分享出来，欢迎大家关注！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af4fde87d5b306a8423b70bbc834d8a8/" rel="bookmark">
			Linux用c&#43;&#43;实现TCP通信（详细注解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用c++实现TCP通信（详细注解） 主要为socket通信的知识
Server端：
#include &lt;iostream&gt; using namespace std; #include &lt;winsock2.h&gt; #pragma comment(lib,"Ws2_32.lib") const int BUF_SIZE = 2048;	//缓冲区大小 char sendbuf[BUF_SIZE];	//发送缓冲区 char recvbuf[BUF_SIZE];	//接受缓冲区 void initialization()	／／初始化操作 { //WSADATA是一种数据结构，用来存储被WSAStartup函数调用后返回的Windows sockets数据，包含Winsock.dll执行的数据。需要头文件 WSADATA wsadata; //MAKEWORD声明调用不同的Winsock版本。例如MAKEWORD(2,2)就是调用2.2版 WORD wsaversion = MAKEWORD(2, 2);	//WSAStartup函数必须是应用程序或DLL调用的第一个Windows套接字函数 //可以进行初始化操作，检测winsock版本与调用dll是否一致，成功返回0 if (WSAStartup(wsaversion, &amp;wsadata) != 0) { cout &lt;&lt; "载入socket库失败" &lt;&lt; endl; } else { cout &lt;&lt; "初始化成功" &lt;&lt; endl; } } int main() { SOCKET sockSer;	//创建服务器套接字 SOCKET sockCli;	//SOCKADDR_IN是系统封装的一个结构体，具体包含了成员变量：sin_family、sin_addr、sin_zero SOCKADDR_IN addrSer; SOCKADDR_IN addrCli; initialization(); //socket(int domain, int type, int protocol) //domain表示要使用的协议AF_INET指ipv4,type指套接字类型 stream指tcp //协议“protocol”一般设置为“0”，就是说在已经确定套接字使用的协议簇和类型时，这个参数的值就为0。 sockSer = socket(AF_INET, SOCK_STREAM, 0); //初始化地址包 //sin_addr主要用来保存IP地址信息 //htonl 函数可用于将主机字节顺序中的 IPv4 地址转换为网络字节顺序中的 IPv4 地址。 addrSer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af4fde87d5b306a8423b70bbc834d8a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ce3c9ef6c788d5e0dc77f61b2785948/" rel="bookmark">
			【Python】Pycharm中设置使用conda的虚拟环境（保姆级图文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 添加新的环境添加conda环境等待库加载加载成功总结 欢迎关注 『Python』 系列，持续更新中
添加新的环境 添加conda环境 虚拟环境路径 G:\anaconda3\envs\paddle_env\python.exe conda路径 G:\anaconda3\Scripts\conda.exe 等待库加载 第一次这个库加载可能要20分钟很久，但是如果30分钟了都没有加载（其实这个时候能用，但是加载不出来会一直卡着ide，比如说我快捷键注释代码都不行，得手动打字# 才能注释，我受不了，尝试以下方法解决）
【Python】Pycharm使用anaconda中的PaddleOCR的虚拟环境 卡在loading package list（保姆级图文）
加载成功 加载成功后库都显示成功，方便进一步的操作。
总结 大家喜欢的话，给个👍，点个关注！继续跟大家分享敲代码过程中遇到的问题！
版权声明：
发现你走远了@mzh原创作品，转载必须标注原文链接
Copyright 2022 mzh
Crated：2022-1-10
欢迎关注 『Python』 系列，持续更新中
**欢迎关注 [『Python』 系列]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e09a8e8e12718968502a931e8f6f0af5/" rel="bookmark">
			AHK c&#43;&#43; 禁用鼠标设备实现完美息屏（不是休眠）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何实现完美息屏呢？虽然可以用ahk实现息屏，但桌子一晃动，鼠标稍微偏移一下，又亮了，导致息屏无效！
win10 更新了设备管理器，现在可以禁用鼠标设备了。以前这里是灰色的。
c++ 禁用鼠标 那么，怎么编程调用它呢？
两个办法，一个ahk模拟用户操作，这个是不得以而为之、没有办法的办法。
另一个是c++编程。首先谷歌关键词“c++ disable windows device”，发现问答社区的交流比较老旧，而且没有确切的信息。但是第二个就是一个完善的gist分享，代码直接就能用：
Disable or Enable Device with Hardware ID 原代码如下：
/* for Devpkey */ #define INITGUID /* dependencies */ #pragma comment (lib, "SetupAPI") #include &lt;windows.h&gt; #include &lt;SetupAPI.h&gt; #include &lt;Devpkey.h&gt; VOID SetDeviceState(LPCWSTR lpszHardwareId, DWORD dwState) { HDEVINFO devInfo; if (devInfo = SetupDiGetClassDevsW(NULL, NULL, NULL, DIGCF_ALLCLASSES)) { DWORD dwBuffersize; SP_DEVINFO_DATA devData; DEVPROPTYPE devProptype; LPWSTR devBuffer; devData.cbSize = sizeof(SP_DEVINFO_DATA); for (int i = 0; ; i++) { SetupDiEnumDeviceInfo(devInfo, i, &amp;devData); if (GetLastError() == ERROR_NO_MORE_ITEMS) break; /* calculate buffer size */ SetupDiGetDevicePropertyW(devInfo, &amp;devData, &amp;DEVPKEY_Device_HardwareIds, &amp;devProptype, NULL, 0, &amp;dwBuffersize, 0); /* real call */ if (devBuffer = HeapAlloc(GetProcessHeap(), 0, dwBuffersize)) { SetupDiGetDevicePropertyW(devInfo, &amp;devData, &amp;DEVPKEY_Device_HardwareIds, &amp;devProptype, (PBYTE)devBuffer, dwBuffersize, NULL, 0); if (lstrcmpW(devBuffer, lpszHardwareId) == 0) { /* matched */ SP_CLASSINSTALL_HEADER ciHeader; ciHeader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e09a8e8e12718968502a931e8f6f0af5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64706bbaed57d616e32609ce6399bc1b/" rel="bookmark">
			机器学习之监督学习，无监督学习，强化学习相关概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 监督学习（Supervised Learning）2. 无监督学习（Unsupervised Learning）3. 强化学习（Reinforcement Learning）总结 机器学习可以按照模型使用情况分为三大类：监督学习、无监督学习和强化学习。以下是对每种类型的详细介绍：
1. 监督学习（Supervised Learning） 概念：监督学习是一种机器学习方法，其基本思想是通过使用带有标签的训练数据，使模型学习从输入数据到输出标签之间的映射关系。训练数据包括输入特征和相应的目标标签，模型的任务是学习如何根据输入来预测正确的输出。应用：监督学习广泛应用于分类和回归问题。例如，垃圾邮件过滤、图像识别、语音识别、股票价格预测等都可以通过监督学习解决。算法：监督学习算法包括线性回归、逻辑回归、决策树、随机森林、支持向量机、神经网络等。 2. 无监督学习（Unsupervised Learning） 概念：无监督学习是一种机器学习方法，其目标是从未标记的数据中发现模式、结构和关系。在无监督学习中，模型不知道预测目标，只是试图将数据组织成有意义的结构。应用：无监督学习常用于聚类、降维、异常检测等任务。例如，K均值聚类、主成分分析（PCA）、自编码器等都是无监督学习的应用。算法：无监督学习算法包括K均值聚类、层次聚类、PCA、t-SNE、自编码器等。 3. 强化学习（Reinforcement Learning） 概念：强化学习是一种机器学习方法，其核心思想是通过模拟智能体与环境的交互来学习最佳行为策略，以最大化累积奖励。在强化学习中，智能体通过尝试不同的行动来学习哪些行为会导致更大的奖励或更小的惩罚。应用：强化学习在自动驾驶、游戏玩法、机器人控制、金融交易等领域有广泛的应用。元素：强化学习中的基本元素包括智能体（Agent）、环境（Environment）、状态（State）、动作（Action）、奖励（Reward）和策略（Policy）。算法：强化学习算法包括Q-学习、深度Q网络（DQN）、策略梯度方法、蒙特卡洛树搜索（MCTS）等。 总结 形式
这三种机器学习类型在不同应用场景中发挥作用，选择合适的类型取决于问题的性质和可用的数据。监督学习适用于有明确标签的数据，无监督学习适用于无标签数据的探索性分析，而强化学习则适用于智能体需要在与环境的互动中学习最佳行为策略的情况。在实际问题中，有时也会将这些类型组合使用，以充分利用不同类型的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53be7e15d951e2366ad417e88bf741db/" rel="bookmark">
			防火墙应用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 防火墙支持那些NAT技术，主要应用场景是什么？ 防火墙NAT技术简介：
NAT是一种地址转换技术，可以将IPv4报文头种的地址转换为另一个地址。通常情况下，利用NAT技术将IPV4报文头中的私网地址转换为公网地址，可以实现位于私网的多个用户使用少量的公司地址同时访问Internet。用于解决公网地址短缺的问题。
NAT类型：
NAT No-PAT：类似于Cisco的动态转换，只转换源IP地址，不转换端口，属于多对多转换，不能节约公网IP地址，使用情况较少。
NAPT（Network Address and Port Translation，网络地址和端口转换）：类似于Cisco的PAT转换，NAPT即转换报文的源地址，又转换源端口。转换后的地址不能是外网接口IP地址，属于多对多或多对一转换，可以节约公网IP地址，使用场景较多。
出接口地址（Easy-IP）：因其转换方式非常简单，所以也被称为Easy-IP、和NAPT一样，即转换源IP地址，又转换源端口。区别是出接口地址方式转换后的地址只能是NAT设备外网接口所配置的IP地址，属于多对一转换，可以节约IP地址
NAT Server：静态一对一发布，主要用于内部服务器需要对Internet提供服务时使用。
Smart NAT（智能转换）：通过预留一个公网地址进行NAPT转换，而其他的公网地址用来进行NAT No-PAT转换，该方式不太常用。
三元组NAT：与源IP地址、源端口和协议类型有关的一种转换，将源IP地址和源端口转换为固定公网IP地址和端口，能解决一些特殊应用在普遍NAT中无法实现的问题。主要应用于外部用户访问局域网的一些P2P应用。
2. 当内网PC通过公网域名解析访问内网服务器时，会存在什么问题，如何解决？请详细说明 当内网PC访问公网域名时，根据缺省路由，PC会去访问外网的同域名服务器，去外网的dns进行解析，最后访问到公网的同域名服务器。
需要在做NAT的路由器或防火墙上配置域内的NAT转换，让PC访问该公网域名时，防火墙或者路由器能正确的寻址。
3. 防火墙使用VRRP实现双机热备时会遇到什么问题，如何解决？详细说明 防火墙使用vrrp实现双机热备的时候遇到的问题有：如果主出现问题了就要切到备份的防火墙上，但是会话表有个首包机制，会话表是首包建立起来的，如果切换到备份的防火墙上那么会话表无法起来，这样流量就过不去。对于这个问题的解决方法是：关闭状态检测机制即可。
还有个问题是：需要左右两边的vrrp的动作要一致，这样切换就没什么问题，这里就会用到vgmp，vgmp管理多个vrrp。优先级和vrrp一样就是优先级和抢占性
4. 防火墙支持那些接口模式，一般使用在那些场景？ 物理接口：防火墙支持的接口可以是二层的接口，也可以是三层接口
二层接口：交换接口 portswitch
三层接口： undo portswitch 类似于路由器的接口
逻辑接口：
1.tunnel接口，null接口
2.vlanif接口
3.三层以太网子接口（备份时）、loopbak接口
5. 防火墙旁挂引流方案有哪些？好处是什么？ 防火墙旁挂引流方案是一种网络架构配置，旨在改善网络性能和安全性。
负载均衡器：通过在防火墙前面添加负载均衡器，可以分散流量负载，提高网络性能和可用性。好处包括更好的流量分发和故障恢复能力。
Web应用程序防火墙（WAF）：将WAF放置在防火墙旁边可提供对Web应用程序的更精细的安全保护，有助于检测和防止Web攻击，如SQL注入和跨站点脚本攻击。
反病毒/反恶意软件网关：这些网关可以检测和拦截网络中的恶意软件和病毒，以提高网络安全性。
SSL/TLS终端代理：这种方案允许防火墙旁的设备对传入和传出的加密流量进行解密和检查，以确保流量的安全性。
内联网络安全监测工具：将入站和出站流量重定向到网络安全监测工具，以进行深度分析和检测威胁，有助于及早发现和应对安全事件。
好处包括增强了网络性能、提高了安全性、简化了网络管理和监控，以及提供了更多的灵活性，使您能够轻松添加新的安全工具和服务，以应对不断变化的威胁。
实验复现 防火墙的配置：
通过vrf技术创建一个 新的路由表，与全局public路由相互隔离
把下联R3的接口划入vrf trust路由表
[r2-GigabitEthernet0/0/2]ip add 10.1.2.2 24
[r2-GigabitEthernet0/0/2]ip binding vpn-instance trust
ip route-static 1.1.1.1 255.255.255.255 10.1.1.1 //从防火墙10.3.1.0/24出来去往1.1.1.1的路由指向R1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53be7e15d951e2366ad417e88bf741db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a261a86f57665d53fcda1994eaf67d/" rel="bookmark">
			OpenCV开发之——将官方示例迁移到项目上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述 官方示例提供的DetectionBasedTracker.java与jni下的DetectionBasedTracker_jni.cpp交互当进行项目迁移时，包名发生变化，若将jni下的内容copy到新包后，DetectionBasedTracker.java找不到jni下的DetectionBasedTracker_jni.cpp文件重新编写jni下的文件生成DetectionBasedTracker_jni.h和DetectionBasedTracker_jni.cpp 二 FdActivity、DetectionBasedTracker和jni的关系 2.1 之间的调用关系 FdActivity中调用DetectionBasedTracker.java中的start()方法时
执行DetectionBasedTracker.java中的native方法nativeStart(long thiz)
DetectionBasedTracker.java中的native方法已在jni中的DetectionBasedTracker_jni.h中声明
DetectionBasedTracker_jni.cpp中实现了DetectionBasedTracker_jni.h中声明的方法
2.2 调用关系示意图 三 知识要点 具备知识：NDK和JNI依赖：OpenCV和javacpp及javacv 四 项目迁移 4.1 创建新项目如(MyOpenCV) 4.2 添加opencv及依赖 4.2.1 导入opencv-sdk 依次点击：File——&gt;New——&gt;Import module from source，导入opencv-sdk
4.2.2 配置NDK 导入后，可能会显示如下错误(可能是未下载NDK或配置NDK引起)
安装NDK：点击SDK Manager——&gt;Appearance&amp;Behavior&gt;System Settings&gt;Android SDK——&gt;SDK Tools，安装NDK和CMake
配置SDK：依次点击：File——&gt;Project Struct——&gt;SDK Location，选择NDK文件位置
settings.gradle中配置opencv-sdk(因为与项目在同一目录下，opencvsdk=‘’，上一级目录，opencvsdk=‘…/’)
def opencvsdk='' //def opencvsdk='/&lt;path to OpenCV-android-sdk&gt;' include ':opencv' project(':opencv').projectDir = new File(opencvsdk + '/sdk') app/build.gradle下添加opencv和javacpp，javacv
//opencv-人脸检测 implementation project(':opencv') //人脸识别 implementation 'org.bytedeco:javacpp:1.5.5' //javacpp implementation 'org.bytedeco:javacv:1.5.5' //javac implementation group: 'org.bytedeco', name: 'javacv-platform', version: '1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6a261a86f57665d53fcda1994eaf67d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28f60f6723c990d87c17ab4cb860378a/" rel="bookmark">
			AndroidStdio入门：创建界面与基本界面布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.创建界面 新建一个java类
例子中为Activity创建的类叫MainActivity，覆盖了其onCreate方法，在其中编写了创建界面的代码。首先创建了一个TextView控件，并将其显示的文本设置为“Hello World”。然后将该TextView设置为Activity的视图，即显示的界面。具体代码如下：
package com.wcm.a0301uibasic; import android.app.Activity; import android.os.Bundle; import android.widget.TextView; public class MyActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText("hello World!"); setContentView(tv); } } 在AndroidManifest.xml中声明Activity（写在application中）的代码如下：
&lt;activity android:name=".MyActivity" android:label="@string/app_name" android:exported="true"&gt; &lt;!-- 把我们的activity作为应用的主活动 主应用:桌面有这个应用图表,一点这个应用就跳到我们的这个activity --&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 2.创建布局文件 新建xml文件
添加字符串资源，布局文件是一个XML文件，所以也可以直接修改其xml代码。可以直接添加text，修改text属性
添加字符串变量作为添加到text中的内容
调用刚刚生成的text进行显示，在原来的MainActivity进行修改：
public class MyActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); // TextView tv = new TextView(this); // tv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28f60f6723c990d87c17ab4cb860378a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034f2b22be340c40da55dee0c594b79a/" rel="bookmark">
			使用Keil进行软件模拟仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在程序编译完之后，没有硬件条件，可以通过嵌入式软件开发工具自带的模拟器进行纯软件模拟调试。关于本文如果有问题，欢迎指正和质疑，也欢迎大佬分享别的解决办法。
实现步骤 步骤来自《嵌入式系统原理及应用——基于ARM Cortex-M3内核的STM32F103系列微控制器》
在顶部菜单栏中找到魔术棒，单击点开。 在Options for Target中找到Debug,并点开。 选择Debug中的Use Simulator 将CPU DLL设置为 SARMCM3.DLL 将CPU DLL后面的Parameter设置为空 这里我尝试过，这个Parameter保留内容好像不会有什么问题，依然可以调试，不过不知道是不是对的，建议按照书上的步骤来（有大佬来解释一下嘛）
将Dialog DLL设置为 DARMSTM.DLL 将Dialog DLL后面的Parameter设置为-p+芯片型号 【这个parameter的内容对应选择的芯片】
然后点OK保存即可 保存之后先编译，再调试。 否则会显示找不到axf文件 问题补充 如果编译不出来axf文件可以尝试一下下面这位作者的办法
KEIL5工程不能编译和下载，运行时提示找不到.axf文件(Error: Flash Download failed - Could not load file“.axf“)_缺少axf文件_工藤新一_柯南的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd4bc417a0d01e12bc24c5d4d46450cf/" rel="bookmark">
			Windows下部署Hadoop3.3.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在搭建Hadoop环境之前需要先安装JDK，并且配置好Java环境变量。注意：Java环境变量中不允许有空格，如 C:\Program Files(x86)\java\xxxxx , 后续步骤中在 hadoop-env.cmd 配置 JAVA_HOME 时，这种环境变量的是无法识别的，容易报 “Error JAVA_HOME is incorrectly set.” 之类的错误。
1.下载安装 Hadoop3.3.0 下载地址：http://archive.apache.org/dist/hadoop/common/hadoop-3.3.0/
解压到指定目录，解压后如下图，注意data文件是后续生成的
2.配置Hadoop环境变量 在系统变量中新建HADOOP_HOME路径，如图所示
在path路径中新建%HADOOP_HOME%\bin并上移到最上方
3.修改配置文件 这里需要修改的配置文件有：
core-site.xmlhdfs-site.xmlyarn-site.xmlhadoop-env.cmd 3.1 core-site.xml 这个文件没有特别需要注意的地方，直接覆盖就行
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/D:/work/soft/hadoop_temp/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 3.2 hdfs-site.xml 这是Hadoop分布式文件系统的配置，主要是配置 namenode 和 datanode（执行start-all后生成的）的路径
这里指定了生成路径为D:\hadoop\hadoop-3.3.0\data\datanode和D:\hadoop\hadoop-3.3.0\data\namenode
**(注意正反斜杠)**上图的data目录便是执行此文件后生成的
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/D:/hadoop/hadoop-3.3.0/data/namenode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/D:/hadoop/hadoop-3.3.0/data/datanode&lt;/value&gt; &lt;/property&gt; &lt;!-- 50700打不开请配置这个. --&gt; &lt;property&gt; &lt;name&gt;dfs.http.address&lt;/name&gt; &lt;value&gt;localhost:50070&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd4bc417a0d01e12bc24c5d4d46450cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d569dfd0f1b2287c2e7c2d10b0250c0d/" rel="bookmark">
			mySQL查看数据库有多少张表命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.获取mysql下所有数据库表的数量 select count(*) tables, table_schema from information_schema.tables group by table_schema; 二.获取指定数据库的表的数量 select count(*) tables, table_schema from information_schema.tables where table_schema = '数据库名' group by table_schema; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ce3e325c10e519d5fec4f9fcec4c2e3/" rel="bookmark">
			Ubuntu设置sudo免密码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤1：使用su命令切换至root用户 在终端中输入以下命令：
sudo su -
输入当前用户的密码，即可切换至root用户。
步骤2：使用如下命令修改sudoers文件权限 在终端中输入以下命令：
chmod 777 /etc/sudoers 这将允许用户以写入方式修改sudoers文件。
步骤3：编辑sudoers文件 在终端中输入以下命令：
visudo
这将打开sudoers文件，并使用vi编辑器进行编辑。请注意，不要直接使用vi命令编辑sudoers文件，因为这可能会导致文件格式出现问题。
在文件末尾添加以下行：
user ALL=(ALL:ALL) NOPASSWD:ALL 请注意，user需要替换为希望设置sudo免密码的用户名。
保存并退出文件。在vi编辑器中，可以使用以下命令保存并退出：
:wq 步骤4：重启使配置生效 在终端中输入以下命令，重启以使配置生效：
sudo reboot
现在，用户user将不再需要输入密码即可以管理员权限执行sudo命令。
⚠️需要注意的是，修改sudoers文件时一定要小心，不当的修改可能会导致系统无法启动。如果不确定如何修改sudoers文件，建议先备份原文件，或请有经验的管理员协助操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb7a37ad1b4bd815b9cad5946cca758/" rel="bookmark">
			【Nuxt3】路由参数（动态路由、嵌套路由）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		页面路由参数 query 参数
目录
|- pages | |- foo.vue 路由地址
https://loaclhost:8080/foo?id=1 参数获取
// foo.vue &lt;template&gt; &lt;div&gt; id: {{ route.query.id }} &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; const route = useRoute() console.log('id:', route.query.id) &lt;/script&gt; params 参数
目录
|- pages | |- foo-[name] | | |- [id].vue 路由地址
https://loaclhost:8080/foo-admin/1 参数获取
// [id].vue &lt;template&gt; &lt;div&gt; name: {{ route.params.name }} id: {{ route.query.id }} &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; const route = useRoute() console.log('name:', route.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fb7a37ad1b4bd815b9cad5946cca758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05fd27543c64fa097af3e4679a7edbc5/" rel="bookmark">
			矿山安全生产：煤矿智慧矿山ai建设方案详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能（AI）技术的快速发展，智慧矿山正在成为煤矿行业的新趋势。通过应用AI技术，煤矿可以实现自动化控制、数据智能分析以及智能化决策，极大地提升煤矿的安全性、生产效率和经济效益。本文将详细介绍煤矿智慧矿山AI建设方案，探讨其意义和优势，并分析具体的实施步骤和预期效果。
一、煤矿智慧矿山AI建设方案的意义和优势
智慧矿山AI建设方案意在利用人工智能技术的优势，改变传统煤矿的生产方式和管理模式。具体来说，它可以实现以下方面的优势：
1. 提升生产效率：通过应用AI技术，可以实现煤矿设备的智能化控制和优化调度，提高生产效率。例如，通过智能化调度系统对设备进行智能化监控和调度，可以实现设备的高效运行，减少时间浪费和资源浪费，提高生产效益。
2. 提高矿工安全：煤矿是一个高风险的工作环境，事故发生的可能性较大。智慧矿山AI建设方案可以实现对矿工的实时监控和预警，降低事故发生的概率。例如，通过AI技术监测矿工的体温、呼吸频率等生理指标，可以在矿工出现异常情况时及时发出警报，及时采取措施避免事故发生。
3. 优化管理决策：智慧矿山AI建设方案可以实现对大量的数据进行智能化分析，为管理者提供决策支持。通过分析历史数据和实时数据，可以发现潜在的问题和矛盾，并提供优化建议。例如，通过对设备运行数据进行分析，可以确定设备维护和更换的最佳时机，节省成本并保证生产的持续性。
二、煤矿智慧矿山AI建设方案的实施步骤
要实施煤矿智慧矿山AI建设方案，需要按照以下步骤进行：
1. 数据采集和清洗：首先，需要采集煤矿中涉及的各种数据，包括设备数据、矿工数据、环境数据等。然后，对这些数据进行清洗和预处理，保证数据的准确性和完整性。
2. 模型训练和优化：基于清洗后的数据，可以建立AI模型并进行训练。通过不断优化和调整模型，可以提高模型的准确性和稳定性。
3. 系统集成和部署：在模型训练和优化完成后，需要将模型集成到智慧矿山系统中，并进行系统测试和调试。确保系统的稳定性和可靠性后，可以进行正式部署。
三、煤矿智慧矿山AI建设方案的预期效果
实施煤矿智慧矿山AI建设方案后，预期可以达到以下效果：
1. 生产效率提升：通过智能化设备控制和优化调度，可以提高生产效率，降低生产成本，并保证生产的持续性。
2. 矿工安全提高：通过矿工实时监控和预警系统，可以降低事故发生的概率，保障矿工的健康和安全。
3. 管理决策优化：通过对大量数据的智能分析，可以提供管理决策的更好支持，发现问题和矛盾，并提供优化建议。
总之，智慧矿山AI建设方案将带来煤矿行业生产方式和管理模式的重大变革。通过应用AI技术，可以实现煤矿生产的高效、安全和可持续发展，促进煤矿行业的升级和转型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9439c7d7fe3f15257cf895d28ff416c/" rel="bookmark">
			Kong集群(hybrid混合)部署模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.简介 上一篇文章简单入门和了解到了Kong自定义插件开发方式。紧跟着，这篇主要介绍Kong集群部署模式。生产环境/流量较大的环境下，我们的Kong就要解决单点问题和性能问题，单个Kong节点无法满足我们高并发、高访问量的需求。那么我们自然想到，Kong自身有提供集群部署模式么?答案是肯定的。
如果Kong自身没有提供集群模式，那么我们也可以自己通过负载均衡的模式，在前端架设一个高可用的7层入口代理Nginx(例如阿里云的ALB、腾讯的SLB等等)，再反向代理到后端每个Kong结点，理论上也是可行的。 但是我们要考虑到一个问题，Kong每个节点的配置信息可能是存在缓存更新问题，通过LB虽然可以分摊访问压力，但是配置信息的及时更新又造成新的问题。例如A节点更新了某个route配置，但是此时新的流量跑到了B节点，B节点的配置还未及时更新，导致执行到旧的逻辑等等此类问题。
所以，看起来仅仅我们用LB负载均衡的方式来实现，是不太完美的。那我们看看Kong自身是如何来解决这个集群问题的.
Kong将节点分为2种角色:
1.数据平面节点(Data Panle， 简称DP节点)
2.控制平面节点(Control Panle ,简称CP节点)
实现架构原理还跟版本不一样， 1.x版本是DP、CP节点通过共享PgSQL数据库和定时更新缓存来更新配置信息， 2.x版本则是所有DP节点的配置信息都依赖CP节点，CP节点依赖PgSQL数据库,保证配置信息统一及时更新的问题(大致看了一下，应该是通过websocket的方式来实现配置同步)。
二.1.x版本集群-实现原理 1.原理介绍 多个Kong节点连接同一个PgSQL数据库，定时从数据库读取拿到配置信息(Route、Service、Upstream、Target)等等，然后缓存到自己的内存中。
优点: 部署简单，只要Kong都连接一个PgSQL数据库即可
缺点: Config配置信息同步不及时，例如A节点同步删除了一个Route，但是B节点还没去轮询DB拿到新的Config数据，则导致信息同步延迟落后，导致B节点访问出现错误.
2.架构图 三.2.x版本集群-实现原理 1.原理介绍 所有的DP节点连接同一个CP节点的8005端口来读取Config配置信息并且可以进行缓存。如果CP节点改变了配置信息,DP节点能及时拿到更新消息，对自己的缓存进行更新.(实现原理: websocket)
优点:
1.消息同步及时，无延迟。规避了1.x版本同步Config配置不及时的问题.无须配置PgSQL相关信息，只需要配置CP节点连接ip与端口即可。
缺点:
1.配置相对于1.x版本门槛较高，需要设置几个配置项。才能让DP节点连接到CP节点，协助搭建成集群为外部提供服务。
2.架构图 四.集群模式-Promethues指标采集问题 大家可能会发现部署完Kong集群之后，相对于查看或者部署单个节点时候，采集Prometheus指标的方式明显发生了变化。 如果我们部署单个节点的Kong，利用Grafana官方的dashbord可以明显查看到流量信息、service信息、route、upstream等等信息。但是如果采用集群模式部署以后,CP节点(ip:8001/metrics)只采集到集群信息了。但是此时我们想查看整个集群的流量信息，那我们该怎么采集呢? 访问DP节点(ip:8001/metrics)也不能访问，那怎么搞?
1.采集CP节点指标
1.添加全局Promethues插件
2.访问ip:8100/metrics即可采集CP节点信息。
如果此时是单个Kong节点模式，则采集到的是Data数据，不存在集群相关信息。如果是集群模式，则采集的是集群信息，不包含route、upstream、target等数据信息。
2.采集DP节点指标
1.添加全局Promethues插件
2.修改配置文件，开启 status_listen=0.0.0.0:8100 配置项. kong prepare &amp;&amp; kong reload重启后, 访问ip:8100/metrics则可以拿到数据节点的指标信息.
因为此时是【集群模式】，DP和CP节点责任分离，DP节点自然不会开启8100端口(admin api管理端口)的监听，访问ip:8100/metrics肯定是失败的。 这里估计会懵逼很多人，有坑。要不然是采集不到DP节点的相关指标信息的。
————————————————
版权声明：本文为CSDN博主「极客跳跳」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xyz_dream/article/details/122865895
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377bbb2bdcc52f9bc007b6c6607a52ca/" rel="bookmark">
			kong 集群部署（混合模式 Hybrid Mode）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在1.x版本中，kong的集群其实是通过运行多个实例，访问同一个数据库来实现的。具体表现为
定时轮询数据库，获取最新的 Services，Routes，Consumers，Plugins等信息，并缓存它们，直到下一次请求数据库时再更新数据
如果某个节点通过admin api对数据库中保存的代理配置进行更改，这个节点本身会立即生效，但其他节点需要等到下一次轮询时才会获取最新的数据
到了2.0版本，kong提供了 混合模式 来部署kong集群
在这种模式下，kong的节点被分为两种角色，分别是控制节点CP和数据节点DP
控制节点 CP 用于提供admin api，负责直接连接数据库并管理各种代理配置。它监听两个端口
admin_listen (默认8001): 原来的admin apicluster_listen (默认8005): 用于与数据节点DP连接，提供最新的配置 数据节点 DP 提供代理的服务，但是代理配置不再从数据库直接获取，而是通过连接 CP 进行获取
监听端口
proxy_listen (默认8000) ：提供代理服务 混合模式的优点 相较于1.x版本的集群，现在的混合模式有以下优点
减少数据库访问量：现在只有CP节点直接连接数据库提高安全性：一个DP节点的服务器遭受入侵不会影响到其他的DP节点易于管理：只需要通过CP节点就可以获取集群状态信息 安装步骤 1. 生成证书/秘钥对 首先生成证书/秘钥对保证CP与DP之间的通信安全
执行命令 kong hybrid gen_cert 在当前目录下生成cluster.crt和cluster.key这两个文件 将这两个文件传输到所有需要部署CP和DP节点的服务器上
2. 部署CP节点 复制默认配置 cd /etc/kong cp kong.conf.default cp.conf vim cp.conf 修改配置文件 role = control_plane #指定为CP节点 #上一步生成的文件路径 cluster_cert = cluster.crt cluster_cert_key = cluster.key # 还需要指定数据库配置 # database = postgres # pg_host = # pg_password = 启动
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/377bbb2bdcc52f9bc007b6c6607a52ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05c515991b380cad178d486db057aed2/" rel="bookmark">
			Goland设置头注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package ${GO_PACKAGE_NAME} * @Author: 坐公交也用券 * @HomePage: https://liumou.site * @File: ${NAME}.go * @Date: ${DATE} ${TIME} * @Des: 文件作用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87127619cc6bbe80df97639a54d9370f/" rel="bookmark">
			【全网最全】2023华为杯研究生数学建模B题完整思路&#43;python代码&#43;20页超详细启发式算法&#43;FFT（后续会更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
点击资料获取入口
DFT在通信等领域的重要应用,以及目前采用FFT计算DFT的硬件开销大的问题。提出了将DFT矩阵分解为整数矩阵乘积逼近的方法来降低硬件复杂度。 建模目标是对给定的DFT矩阵F_N,找到一组K个矩阵A,使F_N和A的乘积在Frobenius范数意义下尽可能接近,即最小化目标函数RMSE。 硬件复杂度C的计算公式给出,与矩阵A中元素的取值范围q和复数乘法次数L相关。 给出了两种约束条件。约束1限制A中每个矩阵的每行最多2个非零元素。约束2限制A中每个矩阵的元素取值范围为整数集P。 对DFT大小N=2^t,t=1~5给出不同约束条件下的优化问题,要求求出最小RMSE和相应的硬件复杂度C。
添加图片注释，不超过 140 字（可选）
问题一：
要求在约束条件1(每个矩阵最多2个非零元素)下,对DFT矩阵F_N(N=2^t,t=1,2,3...)进行分解逼近,并计算最小误差和硬件复杂度。 这里采用的思路是: 1. 将DFT矩阵F_N拆分为多个对角矩阵的乘积,每个对角矩阵只有一个非零元素,这样就满足了约束条件1。 2. 对角矩阵的顺序和元素值可以通过搜索算法优化,以得到最小的逼近误差。 3. 由于本题中没有限制取值范围,为简化计算,可将所有非零元素设为1。 4. 硬件复杂度即为矩阵乘法次数,这里每个矩阵只有一个非零元素,所以复杂度就是矩阵个数。 例如当N=4时:
$$
F_4 \approx \begin{bmatrix}1&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0\end{bmatrix}
\begin{bmatrix}0&amp;0&amp;0&amp;0\0&amp;1&amp;0&amp;0\0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0\end{bmatrix}
\begin{bmatrix}0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0\0&amp;0&amp;1&amp;0\0&amp;0&amp;0&amp;0\end{bmatrix}
\begin{bmatrix}0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;1\end{bmatrix}
$$ 按此方法,计算了N=2至N=8的最小误差和复杂度如下:
N=2,误差=0,复杂度=2
N=4,误差=2,复杂度=4
N=8,误差=6,复杂度=8
N=16,误差=14,复杂度=16
N=32,误差=30,复杂度=32
N=64,误差=62,复杂度=64可以看出,随着N增大,误差也线性增大,但复杂度只与N线性相关。
1. DFT矩阵F_N的定义:
$$ F_N = \frac{1}{\sqrt{N}} \begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1 \
1 &amp; w &amp; w^2 &amp; \cdots &amp; w^{N-1} \
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87127619cc6bbe80df97639a54d9370f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6760d575a55c7e3a0a1858d80a1254ca/" rel="bookmark">
			在哪可以查询某一地区的历史气象数据（如气温、湿度、降雨、风速、太阳辐射等）？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		气象数据指标 气温：指高地面约1.5-2米处百叶箱中的温度
湿度：指高地面约1.25～2米的空气湿度
气压：指该地区的气压值
降水量：是指从天空降落到地面上的液态或固态（经融化后）水，未经蒸发、渗透、流失，而在水平面上积聚的深度
经向风：指高地面约10m风的经向分量（南风为正）
纬向风：指高地面约10m风的纬向分量（西风为正）
地面风速：指高地面约10米的风速
风向：指风的来向，正北方向为0°，顺时针为正
地表水平辐射：射入地表单位水平表面的太阳辐射总量
直接辐射：指太阳圆面和离太阳最近的区域（以太阳为中心5度的太阳圆面）放射出来的直射太阳辐射
散射辐射：指太阳光在穿过大气层到达地面过程中遇到云、气体分子、尘埃等产生散射，以漫射形式到达地球表面的辐射能 ​
数据来源：羲和能源大数据平台 (xihe-energy.com)
查询步骤 一、羲和平台进行地理位置选择，可选择全球任意单点数据或选择省/直辖市、市、区/县级区域平均数据
二、确认数据源
三、输入想查询下载的起止时间，可选历史40年和未来7日
四、选择所需要的气象数据下载，导出csv格式（可用excel打开、编辑）小时级数据，保存数据可视化图片。也可选择定制api
五、“更多属性”中“检索属性”获取更多数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9ceff7a0037a50a23a71919f400d9b0/" rel="bookmark">
			minio报错should be less than or equal解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		minio报错should be less than or equal解决方案 问题背景解决方案Lyric： 当作你的请求 问题背景 在进行minio扩容时，报错
parity validation returned an error: parity 4 should be less than or equal to 2 &lt;- (4, 4), for pool(2nd 解决方案 minio对节点的数目是有要求的，4的倍数，如果报以上类似的错误，不能增加节点，可以去增加data文件夹的数量
如我原本的启动命令 #!/bin/bash export MINIO_ROOT_USER=admin export MINIO_ROOT_PASSWORD=123456789 nohup /minio/run/minio server --config-dir /minio/config --address :8009 http://192.168.3.{102...105}/minio/data/data{1...2} --console-address ":8002" &gt; /minio/minio.log 2&gt;&amp;1 &amp; 更改之后，我分别在103、104两个节点各增加了1个挂载盘/incease，每个盘增加了data{1…4} 4个文件夹
#!/bin/bash export MINIO_ROOT_USER=admin export MINIO_ROOT_PASSWORD=123456789 nohup /minio/run/minio server --config-dir /minio/config --address :8009 http://192.168.3.{102...105}/minio/data/data{1...2} http://192.168.3.{103...104}/increase/data/data{1...4} --console-address "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9ceff7a0037a50a23a71919f400d9b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/700119a545129376ac193e34c9c930ae/" rel="bookmark">
			webrtc代码下载编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.开启vpn
我这里使用的是protin VPN 在这里插入代码片
2.开启后ping google.com 如果ok那说明开启成功了 274001
3.安装google工具和脚本：执行 git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
4.vi ~/.bashrc
按i后在最后面添加：
export DEPOT_TOOLS_PATH=~/depot_tools export PATH=${PATH}:${DEPOT_TOOLS_PATH} 输入完毕之后按’esc’键，再按w保存退出即可
使环境变量生效：$ source ~/.bashrc
5.下载android 代码：fetch --nohooks webrtc_android
如果异常断开执行:gclient sync //若是异常断开，可多执行几次
等待…这个过程会比较久，代码大概17G左右
下载途中可能出现如下错误：
这个由于VPN限制登入，换个VPN的IP就解决了
6.编译
6.1 进入src目录，切换分支
我这边选用的108
git checkout -b M108 branch-heads/5359
切换后的分支如下
6.2.执行 gclient sync(此处可能需要等待时间长)
6.3 sudo ./build/install-build-deps.sh
6.4 sudo ./build/install-build-deps-android.sh
6.5 使用gn命令编译：gn gen out/Debug --args=‘target_os=“android” target_cpu=“arm” treat_warnings_as_errors=false’
使用自己的openssl:gn gen out/Debug --args=‘target_os=“android” target_cpu=“arm” treat_warnings_as_errors=false rtc_build_ssl=false rtc_ssl_root=“/home/hyh/share/webrtc_linux/src/openssl/include”’
下面是备注下编译不用版本的
编译arm-v7版
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/700119a545129376ac193e34c9c930ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb7a36d353c173089dda3b788f89b3b/" rel="bookmark">
			Activiti7工作流 二【Activiti7入门、Activiti7进阶】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 六、Activiti7入门6.1 业务流程建模6.1.1 绘制流程图6.1.2 指定任务负责人6.1.3 生成png格式流程图 6.2 部署流程定义6.3 启动流程实例6.4 任务查询6.5 任务处理6.6 添加审批意见6.6 查看历史审批 七、Activiti7进阶7.1 流程定义相关7.1.1 流程定义查询7.1.2 流程资源下载7.1.3 流程定义删除 7.2 流程实例相关7.2.1 什么是流程实例7.2.2 BusinessKey（业务标识）7.2.3 流程定义/实例挂起/激活 7.3 任务分配负责人7.3.1 固定分配7.3.2 UEL表达式分配7.3.3 监听器分配 7.4 流程变量7.4.1 什么是流程变量？7.4.2 流程变量类型7.4.3 流程变量的作用域7.4.4 流程变量的使用方法7.4.5 使用global变量控制流程 7.5 任务候选人7.5.1 设置任务候选人7.5.2 部署&amp;启动流程7.5.3 查询候选人任务7.5.4 领取候选人任务7.5.4 完成任务 7.6 网关7.6.1 排他网关7.6.2 并行网关7.6.3 包含网关 六、Activiti7入门 6.1 业务流程建模 6.1.1 绘制流程图 在resource目录下新建bpmn目录用于存放所有的流程文件 ,在bpmn目录下新建leave.bpmn,内容如下:
6.1.2 指定任务负责人 为每个任务结点指定负责人，如部门经理的审核人是李四。 6.1.3 生成png格式流程图 bpmn文件本质上是xml格式,我们打开看到的是图片格式是因为我们在IDEA中安装了actiBPM的插件.
如果我们把bpmn文件部署到Web环境,那么就只能看到xml信息,无法看到类似上面的图形了.
我们可以再部署之前，根据bpmn文件生成png文件，然后把bpmn和png文件同时部署到Web环境中.如果我们想查看流程图的话，我们就可以通过Activiti把这个png文件读取出来. 接下来我们把bpmn导出为png文件
将leave.bpmn文件重命名为leave.xml文件 右键点击leave.xml文件 --&gt; Diagrams --&gt; Show BPMN Designer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb7a36d353c173089dda3b788f89b3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/595d71c17b5219c688bc81514487121d/" rel="bookmark">
			Activiti7工作流 一【工作流介绍、什么是Activiti7？、Activiti7环境、集成Activiti7、流程引擎API】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Activiti7工作流一、工作流介绍1.1 概念1.2 适用行业1.3 应用领域1.4 传统实现方式1.5 什么是工作流引擎 二、什么是Activiti7？2.1 概述2.2 Activiti7内部核心机制2.3 BPMN2.4 Activiti如何使用2.4.1 整合Activiti2.4.2 业务流程建模2.4.3 部署业务流程2.4.4 启动流程实例2.4.5 查询待办任务2.4.6 处理待办任务2.4.7 结束流程 三、Activiti7环境3.1 开发环境3.2 安装Activiti流程设计器3.2.2 本地安装 3.3 解决actiBPM中文乱码3.4 Activiti支持的数据库 四、集成Activiti74.1 创建Maven项目4.2 添加Maven依赖4.3 添加log4j日志配置4.4 添加核心配置文件4.5 测试4.6 数据库表的命名规则 五、流程引擎API5.1 Service总览 Activiti7工作流 一、工作流介绍 1.1 概念 工作流(Workflow)，就是通过计算机对业务流程自动化执行管理。它主要解决的是“使在多个参与者之间按照某种预定义的规则自动进行传递文档、信息或任务的过程，从而实现某个预期的业务目标，或者促使此目标的实现”。
案例: 出差费用报销
目标: 公司把出差费用转账到自己的账户中.
参与人: 申请人、部门主管、总经理、财务
传递文件/执行任务
什么是工作流系统?
一个软件系统中具有工作流的功能，我们把它称为工作流系统。
1.2 适用行业 消费品行业，制造业，电信服务业，银证险等金融服务业，物流服务业，物业服务业，物业管理，大中型进出口贸易公司，政府事业机构，研究院所及教育服务业等，特别是大的跨国企业和集团公司。
1.3 应用领域 企业: 采购流程、合同审核流程
客户: 客户电话投诉处理流程
生活中: 住房贷款审批流程、办理身份证、办理准生手续
行政: 出差审批、报销流程、请假审批、用车流程、会议室申请
银行业: 信贷审批、信用卡发卡审批
人事: 员工培训、绩效考核、职位变动
1.4 传统实现方式 我们可以思考下,如果需要实现【出差费用报销】工作流程,代码应该如何实现?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/595d71c17b5219c688bc81514487121d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c2e4261253ebf1f9b5f4861edc860c7/" rel="bookmark">
			【Vue3 源码解析】reactive 全家桶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 泛型约束：只能传入引用类型 export function reactive&lt;T extends object&gt;(target: T): UnwrapNestedRefs&lt;T&gt; // 判断只读，否则创建reactive响应式对象 export function reactive(target: object) { // if trying to observe a readonly proxy, return the readonly version. if (isReadonly(target)) { return target } return createReactiveObject( target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap ) } 这段代码是 Vue 3 中的 reactive 函数的实现部分，它用于将一个对象转化为深度响应式代理对象。下面是这段代码的详细解释：
函数签名：
function reactive&lt;T extends object&gt;(target: T): UnwrapNestedRefs&lt;T&gt;：这是 reactive 函数的类型签名，它接受一个泛型参数 T，表示目标对象的类型，并返回一个与目标对象类型相同的深度响应式代理对象。UnwrapNestedRefs&lt;T&gt; 类型用于解包嵌套的 Ref，以获得原始值。
function reactive(target: object)：这是 reactive 函数的实际实现。
实现逻辑：
首先，函数检查目标对象 target 是否已经被标记为只读（readonly）。如果是只读的，就直接返回目标对象本身，因为只读对象不应该被转化为响应式对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c2e4261253ebf1f9b5f4861edc860c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d753ab154e0e205db8d8d99e18aecb5/" rel="bookmark">
			【SpringBoot】7 种实现 HTTP 调用的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者在工作中，遇到一些需要调用三方接口的任务，就需要用到 HTTP 调用工具。这里，我总结了一下 实现 HTTP 调用的方式，共有 7 种（后续会继续新增），分别如下：
HttpClientOkHttpOKHttpUtilJodd HTTPHutool HTTPRestTemplateforest 1. HttpClient &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.6&lt;/version&gt; &lt;/dependency&gt; public class HttpClientUtil { public static String get(String url, Map&lt;String, String&gt; urlParam, Map&lt;String, String&gt; header, boolean ssl) { return get(url, urlParam, header, CharEncoding.UTF_8, ssl); } public static String get(String url, Map&lt;String, String&gt; urlParams, Map&lt;String, String&gt; headers, String charSet, boolean ssl) { HttpGet httpGet = new HttpGet(charSet == null ? addParams(url, urlParams) : addParamsWithCharSet(url, urlParams, charSet)); return getResponse(httpGet, charSet, headers, ssl); } // 以请求体JSON发送数据 public static String postJson(String url, Map&lt;String, String&gt; urlParams, Map&lt;String, String&gt; headers, String data, boolean ssl) { HttpPost httpPost = new HttpPost(addParams(url, urlParams)); httpPost.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d753ab154e0e205db8d8d99e18aecb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1bdb861bea1503e60eec9c84182efe/" rel="bookmark">
			利用DreamBooth实现对于文生图扩散模型的微调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用DreamBooth实现对于文生图扩散模型的微调 文章目录 利用DreamBooth实现对于文生图扩散模型的微调1.背景2.DreamBooth3.基本效果(1).一般效果(2).和Textual Inversion对比 3.摘要一个小问题 4.Personalization of Text-to-Image Models(1).目标与思路(2).为什么要选小样本？(3).那么问题来了(4).模式坍塌是啥？(5).那咋办？ 5.Designing Prompts for Few-Shot Personalization(1).构造提示词的方法(2).为什么要选择稀有词而不是随机词？ 6.Class-specific Prior Preservation Loss(1).新的问题！(2).Language Drift是什么？#1.*Countering Language Drift with Seeded Iterated Learning*#2.*Countering Language Drift via Visual Grounding* (3).所以，我们选择PPL(4).这里说的过拟合又是什么？ 7.实验(1).数据集(2).训练消耗(3).消融实验(4).Prior Preservation Loss Ablation#1.先看看图#2.再看看数据 (5).Class-Prior Ablation(6).效果 8.自行训练(1).利用Diffusers库进行DreamBooth训练 总结 Google Research在2022年8月提出的一种 全新的对于文生图扩散模型(Text-to-Image Diffusion Model)的微调方式，在之后也成功入选 CVPR 2023，论文链接： DreamBooth: Fine Tuning Text-to-Image Diffusion Models for Subject-Driven Generation DreamBooth的效果是相当卓越的，我们能够让模型“记住”某个物体长什么样，然后像照相馆一样，给你拍出各种各样的照片来。
所以接下来我们先来介绍一下微调技术出现的一些背景。
1.背景 目前出现的很多文生图大模型已经具备了相当卓越的生成能力，例如Stable-Diffusion、Imagen等等。如果我们在Prompt中输入一个 [Van Gogh Style]，或许它能很快给你画出梵高风格的一幅画，但我作为一个不知名的人，我也不能奢求Stable Diffusion在训练的时候把我的画也加进去是吧？所以如果我们能自己个性化调整一下这个模型就好了。也正是因为上面说的，结合扩散模型本身生成内容的多样性我们可以知道：同一个提示词生成几十几百次得到的图片可能都不一样，现在的模型不能保证生成相同物体的一致性。而如果依照我们的自然想法，那肯定是把整个模型重新训练调整一下，但是这样一来首先我们肯定需要比较大的数据样本，二来对于整个大模型进行重新训练的成本非常高，训练整个Stable-Diffusion-1.4大概要15万GPU小时，如果是这样对于我们来说就变得很不可及了。 2.DreamBooth 于是，Google Research团队提出了一种名为DreamBooth的全新微调方法。
原本的Text-to-Image模型(左侧红色的部分)能够根据"A dog"这条Prompt生成不同的狗的照片，经过DreamBooth微调后的模型能够在接收"A [V] dog"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1bdb861bea1503e60eec9c84182efe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22c74eafe1e62f4b3b4236df2b737d02/" rel="bookmark">
			一文搞懂域泛化、域适应、few-shot、zero-shot、open-world、open-vocabulary
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		域泛化（Domain Generalization）： 定义：域泛化是一种机器学习任务，旨在让模型在不同于训练数据的新领域（或域）中进行泛化。这意味着模型在未见过的领域中也能表现良好，而不仅仅在训练时使用的领域中表现好。
区别：域泛化关注的是在多个领域中进行泛化，而不仅仅是一个特定的领域。
着重：源域和目标域的观测量和标签分布不一致的问题，同时训练时完全没有目标域的信息。
域适应（Domain Adaptation）： 定义：域适应是一种机器学习任务，旨在将模型从一个领域（源域）适应到另一个领域（目标域）。这通常涉及到在目标领域上进行微调或调整，以提高模型在目标领域中的性能。
区别：域适应专注于从一个领域向另一个领域的知识转移。
着重：源域和目标域的观测量和标签分布不一致的问题，训练时有目标域的信息，通俗来说就是DA在训练时可以拿到少量目标域数据，这些目标域数据可能是有标签的（有监督DA），也可能是无标签的（无监督DA）。
Few-shot Learning（少样本学习）： 定义：Few-shot学习是一种机器学习任务，其中模型需要在非常有限的样本上进行训练，通常是几个样本或更少。它要求模型具有在只有很少示例的情况下进行泛化的能力。
区别：Few-shot学习强调的是模型在少量样本上进行泛化的能力，而不考虑特定领域。
着重：更关注类别不一致，并非分布的不一致性。
Zero-shot Learning（零样本学习）： 定义：Zero-shot学习是一种机器学习任务，其中模型需要在没有看到过的类别或标签上进行泛化。这意味着模型需要从训练中获得一些关于新类别的信息，并在测试时进行分类。
区别：Zero-shot学习关注的是模型在未见过的类别上进行泛化，而不是领域或样本。
着重：更关注类别不一致，并非分布的不一致性。
Open-world Recognition（开放世界识别）： 定义：开放世界识别是一种机器学习任务，其中模型需要能够处理未知类别或标签，并在测试时识别它们，而不仅仅是已知的类别。这是一种应对未知数据的挑战。
区别：开放世界识别关注的是处理未知类别的能力，与Zero-shot Learning类似，但更强调应对未知类别的不确定性。
着重：更关注类别不一致，并非分布的不一致性，很像Zero-shot Learning。
Open-vocabulary Recognition（开放词汇识别）： 定义：开放词汇识别是一种自然语言处理任务，其中模型需要处理和理解不在其词汇表中的词汇或术语。这需要模型能够推断未知词汇的含义。
区别：开放词汇识别是自然语言处理领域的概念，与计算机视觉的其他术语略有不同，它强调了模型在处理未知词汇时的能力。
着重：处理词汇。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19c444caac3a51c44beb5a6d1beaea4d/" rel="bookmark">
			JVM调优参数设置步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、war包部署在tomcat中设置 二、jar包部署在启动参数设置 1、打开需要添加启动参数的对话框
2、配置启动参数
系统环境变量不能直接以空格分隔，要点击最右侧的图标，进入设置：
其实就是，系统环境变量之间要以;分隔 3.启动参数示例解析
在Run/Debug Configurations页面主动有三个内容需要被关注：VM options、Program arguments、Environment variable。
1&gt; VM options
设置JVM参数 或 系统属性，需要以 -D 或 -X 或 -XX 开头，每个参数使用空格隔开；
2&gt; Program arguments
设置运行参数，以--k=v的方式设置一个参数，每个参数需要以空格隔开；
3&gt; Environment variable
设置环境变量，多个以;分隔；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df5520734a193b2e9dda66eb7739a7e/" rel="bookmark">
			C&#43;&#43; 共享内存相关的API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ 共享内存相关的API 1.什么是共享内存1.共享内存的概念2.共享内存的原理3.共享内存使用注意点 2.共享内存有关API的操作函数及示例1.新建共享内存-shmget2.连接共享内存到当前的地址空间-shnat3.当前进程分离共享内存shmdt4.控制共享内存-shmctl5.共享内存操作示例 3.共享内存的使用场景有哪些 1.什么是共享内存 1.共享内存的概念 共享内存是一种操作系统提供的机制，用于实现多个进程之间共享数据的方式。在共享内存中，多个进程可以访问同一块物理内存区域，从而实现数据的共享和通信，而不需要进行显式的数据拷贝或进程间的消息传递。
2.共享内存的原理 共享内存的基本原理是将一块内存区域映射到多个进程的地址空间中，使得这些进程可以直接访问该内存区域。这种共享的内存区域被称为共享内存段。多个进程可以通过读写共享内存段来实现数据的共享和交互。
3.共享内存使用注意点 使用共享内存可以提高数据访问和传输的效率，因为数据直接存储在物理内存中，进程可以直接读写内存，而不需要进行数据的拷贝或消息的传递。然而，由于多个进程可以同时访问共享内存，因此需要采取适当的同步机制，如锁或信号量，来保证数据的一致性和避免竞态条件。
2.共享内存有关API的操作函数及示例 1.新建共享内存-shmget int shmget (key_t __key, size_t __size, int __shmflg) key:共享内存的键值，可以理解为共享内存的唯一性标记
size:共享内存的大小
shmflag:创建进程和其他进程的读写权限标识
返回值：响应的共享内存的标识符，失败返回-1
2.连接共享内存到当前的地址空间-shnat void *shmat (int __shmid, const void *__shmaddr, int __shmflg) shm_id：共享内存标识符
shm_addr:指定共享内存连接到当前进程的地址；通常为0，表示由系统来选择
shmflag：标志位
返回值：指向共享内存第一个字节的指针，失败返回-1
3.当前进程分离共享内存shmdt int shmdt (const void *__shmaddr) 4.控制共享内存-shmctl int shmctl (int __shmid, int __cmd, struct shmid_ds *__buf) 和信号量的semctl函数类似，控制共享内存
shm_id:共享内存标识符
command:有三个值：
IPC_STAT：获取共享内存的状态信息，包括共享内存的大小、创建时间、最后访问时间、进程ID等。 IPC_SET：设置共享内存的状态信息，例如修改共享内存的权限、最后访问时间等。 IPC_RMID：删除共享内存段，释放分配的内存资源。 需要注意的是，shmctl函数的第三个参数__buf是一个指向shmid_ds结构体的指针，用于传递共享内存的状态信息。在使用IPC_STAT命令时，__buf指向的结构体将被填充共享内存的状态信息。在使用IPC_SET命令时，__buf指向的结构体应该包含要设置的共享内存状态信息。在使用IPC_RMID命令时，__buf可以为NULL。
除了上述常用的命令，还有其他一些命令可供使用，例如：
IPC_INFO：获取系统中共享内存的状态信息，包括共享内存的总数、使用的共享内存段数量、共享内存的最大大小等。 SHM_LOCK：锁定共享内存，阻止其被交换到磁盘上。 SHM_UNLOCK：解锁共享内存，允许其被交换到磁盘上 5.共享内存操作示例 #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;sys/ipc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df5520734a193b2e9dda66eb7739a7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/728c07b6af158d8937563d52e0523fd5/" rel="bookmark">
			JDK源码——linux下jdk8源码编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 大家平时用的JDK都是orcal官网等进行编译好了。但是有同学在公司做开发时候或者是自学习的时候需要对源码进行操作，甚至对JDK做定制化的开发的时候，就需要我们自己进行源码进行重新编译。因此博文将详细介绍JDK8源码自编译的流程，给大家一个学习和参考的方法。
一、linux系统安装所需的依赖 yum install alsa-lib-devel cups-devel libX* gcc gcc-c++ freetype-devel libstdc++-static ant make yum install clang -y yum install clang++ -y yum install autoconf -y yum install freetype freetype-config -y 检查依赖是否安装成功：
二、安装一个jdk作为bootstrap jdk 你要编译openjdk8 那么电脑上至少都要装一个jdk7，下图是我电脑上配置的jdk，配置流程跟在Linux上配置jdk一样的
三、下载openjdk源码 Java Platform, Standard Edition 8 ReferenceImplementations
四、自动配置 解压下载好的源码包之后，进入解压后的源码包（下图为目录结构），输入 sh configure 进行自动配置（默认没有build目录，这是编译成功后生成的）
五、进行编译 第一次编译输入make all (全量编译)指令，等待时间比较久，耐心等待
进入build目录在进入生成的 linux-x86_64-normal-server-release目录
这里面的images目录是编译生成的jdk成品镜像， 六、源码编译结果测试 修改好自己的代码后进行 make images（增量编译） 就能完成源码的修改并生效。PS：给虚拟机的内存要大，不然打开idea执行编译是内存会不够用，或者把idea关闭之后执行编译
特别提示：注意的是此JDK源码是在linux下进行编译的，因此生成的SDK的包只能在linux下能运行成功。如果将这个SDK导入woidow将不会起作用。
有朋友就会问，我平时码代码的时候都是在window工作的，你用Unix内核的系统给我编译出来的玩意能在window上运行么？回答肯定是不行的，还记得java为什么能跨平台么？没错不是java能跨平台，而是JVM的实现是居于不同平台的，那就意味着，不同平台编译出来的JDK只能在对应平台上运行，JVM根据不同平台翻译为对应的机器码，JVM才是java能跨平台的基石；那么window平台的码友就不好意思了，只能自己尝试在window上编译。
博文参考 JDK---00Linux上编译openjdk8 - Jenne - 博客园
Ubuntu14.04LTS编译JDK1.8 - _小妖 - 博客园
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/728c07b6af158d8937563d52e0523fd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02411c90a4672f6668744a1570746168/" rel="bookmark">
			软考软件设计师-存储管理-文件管理-计算机网络（中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、存储管理页面置换算法 (最佳OPT)存储页面-先进先出置换算法（FIFO)最久未使用算法(最近最久未使用LRU） 二、文件管理初识文件管理文件目录-绝对路径文件管理-文件的结构文件管理-索引的分配 空闲存储空间的管理(位示图法）三、计算机网络的分类网络的标准互联网服务 一、存储管理 分成存储大小相同的存储块，然后程序按程序的逻辑关系进行分段然后再将每个段换成若干个的页，最后以页为单位离散的存储。
页面置换算法 (最佳OPT) 只要在内存块中没有的都是缺页面的，比如内存块701一直到2才是没有缺页的。
访问到0的时候0是有的不需要置换，当访问到33在里面没有所以需要置换进去。置换条件是要往后看
只有后面没有在使用的才能进行替换，比如3后面的0和2都是马上需要访问到的所以不能换，1排在最后面优先把1替换掉把1换走把3换进来。后面的数字都是一样以此类推。
存储页面-先进先出置换算法（FIFO) 这个算法是把最早进入页面的内存块给换走，比如3是最早进入页面的所以首先把3给换走
最久未使用算法(最近最久未使用LRU） 接口就是往前推算，从3这个内存块开始，最近使用过8，1，2就不能把他们换走，往前看最久一次使用的是7所以先把7给换走。
二、文件管理 初识文件管理 文件目录-绝对路径 文件管理-文件的结构 文件管理-索引的分配 通过第5块号的地址溃疡找到他的块是58。
因为题目中说每个地址项的大小为4字节然后磁盘数据块和索引块都是1kb的大小。
1kb/4B 用1kb除4个字节就能求出我们每一个磁盘索引块中可以装几个地址
以上相除后得到256
逻辑块是5我们直接求他的最后一块是多少，第一块是5一共要装256块因为第一块已经装上了那就是256-1减去第一块。就是255块地址
然后255块地址加上第一块的地址内容就是260，所以最后的一块地址就是260。因为这个地址没有下一块所以只能跑到下一个，下一个就是261所以答案是261
空闲存储空间的管理(位示图法） 一共有4195个物理块因为是从0开始的所以要加多1，在除于我们每个字段多少位，4195/32=131.125
131个字存完还不够所以还得往下一位那就是132位
因为是分配给了某文件所以肯定是占用看，所以第二题的空肯定不是选0，。
通道控制方式可以看作一个被阉割版的cpu
三、计算机网络的分类 网络的标准 互联网服务 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c062547bf99516bf0a374fe0f86fc8b/" rel="bookmark">
			【C&#43;&#43;】静态成员函数 ( 静态成员函数概念 | 静态成员函数声明 | 静态成员函数访问 | 静态成员函数只能访问静态成员 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、静态成员函数简介1、静态成员函数概念2、静态成员函数声明3、静态成员函数访问4、静态成员函数只能访问静态成员 二、代码示例 - 静态成员函数 一、静态成员函数简介 1、静态成员函数概念 静态成员函数归属 : 在 C++ 类中 , 静态成员函数 是一种 特殊的函数 , 该函数属于类 , 而不是属于 类实例对象 ;
静态成员函数调用不依赖于对象 : 即使 没有创建 类 的 实例对象 , 也可以 通过 类名:: 调用 类中定义的 静态成员函数 ;
静态成员函数作用 : 静态成员函数 通常用于 执行与类本身相关的操作 , 执行该函数 不涉及到 类实例对象中的信息 , 也不能在 静态成员函数 中访问 普通的 成员变量 和 成员函数 ;
2、静态成员函数声明 静态成员函数声明 : 使用 static 关键字 修饰 成员函数 , 就可以将 普通的成员函数 转为 静态成员函数 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c062547bf99516bf0a374fe0f86fc8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13b938d4abcaa965eb84d95c0953770/" rel="bookmark">
			uniapp确认提示框；uniapp判断输入框值是否符合正常手机号，身份证号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		确认提示框 UniApp 中，你可以使用 uni.showModal 方法来创建确认提示框。以下是一个示例：
&lt;template&gt; &lt;view class="container"&gt; &lt;button @click="showAuthModal"&gt;显示确认提示框&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { methods: { showAuthModal() { uni.showModal({ title: '授权提示', content: '我们需要获取您的位置信息，请点击确定进行授权。', success: (res) =&gt; { if (res.confirm) { // 用户点击了确定按钮 this.getLocation(); } else if (res.cancel) { // 用户点击了取消按钮 console.log('用户取消了授权'); } } }); }, getLocation() { // 在这里处理获取位置信息的逻辑 // ... } } }; &lt;/script&gt; 在这个示例中，我们在页面上放置了一个按钮，当用户点击按钮时会触发 showAuthModal 方法。在该方法中，我们调用了 uni.showModal 方法来显示确认提示框。确认提示框中包含标题（title）、内容（content）以及确定和取消按钮。
根据用户的选择，success 回调函数将返回一个 res 对象，其中的 confirm 属性表示用户是否点击了确定按钮，cancel 属性表示用户是否点击了取消按钮。根据用户的选择，你可以执行相应的操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13b938d4abcaa965eb84d95c0953770/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac47dd0ff78b950835e29db9f033358/" rel="bookmark">
			MyBatis递归查询学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司业务要求,将邀请用户全部做成层级表放在邀请人的下面,需要使用到递归查询.
首先现将尝试过的递归方法写下来,有的虽然可以实现递归但与业务不相契合,所以弃用
1.树结构查询
写的还可以的思路
我们的这个需求符合树形结构,所以树状查询才符合业务要求(之前找到过一篇自己写的树状结构工具的文章找不到了,写的挺好的可惜的是他是查询父级和下面子集的,不符合业务要求),我们需要的是向下树状查找.
2.Hutool工具实现
使用该工具也可以实现树状结构查询,也能满足业务需求,但是返回结果只能返回Tree&lt;String&gt;数据,很无奈也放弃了.
public HashMap&lt;UserDO, List&lt;Tree&lt;String&gt;&gt;&gt; getChildUserList() { //获取所有数据 List&lt;UserDO&gt; list = userMapper.selectList(null); //具有顶级特征的集合 List&lt;UserDO&gt; fatherList = userMapper.selectList(new EntityWrapper&lt;UserDO&gt;().isNull("inv_id")); // huTool工具构建树形结构对象 TreeNodeConfig treeNodeConfig = new TreeNodeConfig(); //数结构主键ID treeNodeConfig.setIdKey("id"); //父结构ID treeNodeConfig.setParentIdKey("inviteUserId"); //子节点 treeNodeConfig.setChildrenKey("childList"); //存放父节点和其下面的子节点 HashMap&lt;UserDO, List&lt;Tree&lt;String&gt;&gt;&gt; userDOListHashMap = new HashMap&lt;&gt;(); for (UserDO fatherDO : fatherList) { List&lt;Tree&lt;String&gt;&gt; treeNodes = TreeUtil.build(list, fatherDO.getId().toString(), treeNodeConfig, (treeNode, tree) -&gt; { tree.setId(treeNode.getId().toString()); if (treeNode.getInviteUserId() != null) tree.setParentId(treeNode.getInviteUserId().toString()); //扩展属性 tree.putExtra("childList", treeNode.getChildList()); tree.putExtra("phone", treeNode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac47dd0ff78b950835e29db9f033358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5abacce867ba17dc265a83580ac2b477/" rel="bookmark">
			vagrant如何实现共享项目目录，实现即时更新，并且解决访问缓慢问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://www.toymoban.com/diary/apps/115.html
Vagrant 如何解决即时更新到 linux 服务器上，共享目录 最近 Vagrant+ Oracle VM VirtualBox 在本地环境配置 Linux开发环境，项目文件修改起来很麻烦怎么才能实现 本地 和 虚拟机系统项目文件同步的问题。
方案一，使用自带的 VirtualBox 共享方式 1、配置 通过 Vagrantfile 配置文件中中的 config.vm.synced_folder 方法配置同步目录。修改如下：
Vagrant.configure("2") do |config| # other config here config.vm.synced_folder "/vBox/Centos7/wwwroot", "/www/wwwroot" end 说明：
/vBox/Centos7/wwwroot
为本地的真实路径，wwroot 为新建目录，默认是在D盘下，详情查看，Linux开发环境
/www/wwwroot
为Linux虚拟机上面的站点目录
2、重启
配置完成后，冲过命令重启 虚拟机就可以了。
vagrant reload 方案二，使用 nfs 方式 vagrant 默认是使用VirtualBox的共享的方式实现两个系统之前文件的共享， 该共享方式访问速度比较慢， 所以， vagrant作为web开发环境时， 访问会比较慢。
vagrant官方的文档上建议优化该io性能问题的方法是使用nfs,
1、通过命令安装 nfs vagrant plugin install vagrant-winnfsd 2、修改配置文件 Vagrantfile 在 synced_folder 配置后加上，类型：
config.vm.synced_folder "/vBox/Centos7/wwwroot", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5abacce867ba17dc265a83580ac2b477/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f447b7220787080da430fc8194b6e75/" rel="bookmark">
			PHP如何获取前几天日期时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 来源：https://www.toymoban.com/diary/php/109.html 1、获取前N天的时间戳 &lt;?php $N = 5; echo strtotime("-$N day"); //获取前5天时间戳 echo date("Y-m-d",strtotime("-$N day")); //获取前5天的日期 ?&gt; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/84/">«</a>
	<span class="pagination__item pagination__item--current">85/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/86/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>