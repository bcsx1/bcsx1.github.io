<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2130d71cb4c1e0734a1dd77d91123b4b/" rel="bookmark">
			[ 注意力机制 ] 经典网络模型2——CBAM 详解与复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 Author ：Horizon Max
✨ 编程技巧篇：各种操作小结
🎇 机器视觉篇：会变魔术 OpenCV
💥 深度学习篇：简单入门 PyTorch
🏆 神经网络篇：经典网络模型
💻 算法篇：再忙也别忘了 LeetCode
[ 注意力机制 ] 经典网络模型2——CBAM 详解与复现 🚀 Convolutional Block Attention Module🚀 CBAM 详解🎨 背景知识🎨 论文贡献🎨 Convolutional Block Attention Module🚩 Channel Attention Module🚩 Spatial Attention Module🚩 CBAM 的应用 🚀 CBAM 复现 🚀 Convolutional Block Attention Module Convolutional Block Attention Module 简称 CBAM，Sanghyun等人于2018年提出的一种新的 卷积注意力模块 ；
创新提出了 通道注意力与空间注意力融合 的注意力机制 ；
对前馈卷积神经网络 是一个 简单而有效的 注意力模块 ；
因为它的 轻量级和通用性 ，可以 无缝集成到任何CNN网络 当中 ；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2130d71cb4c1e0734a1dd77d91123b4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c9759a3624c54dfc896d9086128466f/" rel="bookmark">
			[ 注意力机制 ] 经典网络模型1——SENet 详解与复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 Author ：Horizon Max
✨ 编程技巧篇：各种操作小结
🎇 机器视觉篇：会变魔术 OpenCV
💥 深度学习篇：简单入门 PyTorch
🏆 神经网络篇：经典网络模型
💻 算法篇：再忙也别忘了 LeetCode
[ 注意力机制 ] 经典网络模型1——SENet 详解与复现 🚀 Squeeze-and-Excitation Networks🚀 SENet 详解🎨 Squeeze-and-Excitation block🚩 Squeeze: Global Information Embedding🚩 Excitation: Adaptive Recalibration🚩 在非残差网络中的应用🚩 在残差网络中的应用 🚀 SENet 复现 🚀 Squeeze-and-Excitation Networks Squeeze ：挤压 Excitation ：激励 ；
Squeeze-and-Excitation Networks 简称 SENet ，由 Momenta 和 牛津大学 的Jie Hu等人 提出的一种新的网络结构；
目标是通过建模 卷积特征通道之间的相互依赖关系 来提高网络的表示能力；
在2017年最后一届 ImageNet 挑战赛(ILSVRC) classification 任务中获得 冠军，将错误率降低到 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c9759a3624c54dfc896d9086128466f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4584269559581aa8b8f88b043f496a4c/" rel="bookmark">
			[ 数据集 ] VOC 2012 数据集介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵 Author ：Horizon Max
✨ 编程技巧篇：各种操作小结
🎇 机器视觉篇：会变魔术 OpenCV
💥 深度学习篇：简单入门 PyTorch
🏆 神经网络篇：经典网络模型
💻 算法篇：再忙也别忘了 LeetCode
文章目录 VOC 2012分类 / 检测分割 VOC 2012 文件夹介绍1）Annotations2）ImageSetsActionLayoutMainSegmentation 3）JPEGImages4）SegmentationClass5）SegmentationObject VOC 2012 它从根本上说是一个有监督的学习问题，提供了一组标记图像的训练集。
包括二十个对象类别：
Person ：person
Animal ：bird, cat, cow, dog, horse, sheep
Vehicle ：aeroplane, bicycle, boat, bus, car, motorbike, train
Indoor ：bottle, chair, dining table, potted plant, sofa, tv/monitor
有三个主要的对象识别竞赛：分类 、检测 和 分割 ；
官方链接 ：VOC 2012
下载链接 ： training / validation data 官方文档 ： (VOC2012) 开发套件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4584269559581aa8b8f88b043f496a4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da8897ce6d250b00c445416b1d7aea1f/" rel="bookmark">
			MySQL中索引与事务内容总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录👀
1️⃣一、索引介绍
1、索引的优缺点
二、索引分类
三、索引的创建与删除
1、在创建表时创建索引
2、在已经存在的表上创建索引
第一种：通过create语法创建索引
第二种：通过alter语法创建
3、删除索引
2️⃣四、事务定义
五、事务特征（ACID）
事务的原子性（Atomic）
事务的一致性（Consistency）
事务的隔离性（Isolation）
事务的持久性（Durability）
六、事务的使用
1、查看事务
2、修改事务
3、事务操作
(1)开启事务
(2)事务提交
(3)事务回滚
(4)保存点
七、并发事务问题
1、脏数据（Dirty READ）
2、不可重复读（UnrepeatableRead）
3、幻读（phantom Read）
1️⃣一、索引介绍 索引是一种数据结构，是对数据库表中的一列或多列的值进行排序的一种结构。【索引就类似于书中的目录】
1、索引的优缺点 在数据库中创建索引的优点：
① 加快查询速度，避免全表扫描
② 保证数据的唯一性；
③ 使用group by、order by子句进行查询时，利用索引可以减少排序和分组的时间。
缺点：
索引并非越多越好，过多的索引会导致CPU的使用率居高不小索引会占据磁盘空间索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。 设计索引时，应考虑以下数据库准则：
（1）一个表如果建有大量索引，会影响insert、update和delete语句的性能。
（2）避免对经常更新的表创建过多的索引。
（3）使用多个索引可以提高更新少而数据量大的查询的性能。
（4）对小表进行索引可能不会产生优化效果；因为对于非常小的表而言，大部分情况下简单的全表扫描更高效。
二、索引分类 普通索引：没有任何限制条件，可以给任何类型的字段创建普通索引
唯一性索引：使用unique修饰的字段，索引列中的值必须是唯一的，且不能重复，但是允许为空值。
主键索引：使用primary key修饰的字段，索引列中的值必须是唯一的，不允许有空值。
单列索引：在一个字段上创建索引
多列索引：在表中多个字段上创建索引
全文索引：使用fulltext参数设置全文索引，只能在char、varchar和text类型的字段上创建全文索引，常用于数据量较大的字符串类型上，可以提高查询速度，MyISAM存储引擎支持全文索引，InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。
聚集性索引：在InNoDB引擎下建立的索引，将索引及数据存放在一起
非聚集性索引：在MyISAM引擎下建立的索引，将索引和数据分开存储在不同的文件中
三、索引的创建与删除 1、在创建表时创建索引 create table 表名( 属性名 属性类型 [完整性约束] [unqiue|fulltext|spatial] index|key [别名] 属性名 （asc,desc） ); 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da8897ce6d250b00c445416b1d7aea1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72e4aa7f16a5a74bc6ff91d4afd7042/" rel="bookmark">
			敏捷软件开发原则、模式与实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 敏捷软件开发宣言
人和交互 重于 过程和工具 团队的构建比环境的构建重要得多。许多团队和管理者就犯了先构建环境，然后期望团队自动凝聚在一起的错误，相反，应该首先致力于构建团队，然后再让团队基于需要来配置环境。
可以工作的软件 重于 面面俱到的文档 编写并维护一份系统原理和结构方面的文档总是一个好主意，但是那份文档应该短小并且主题这突出。主题突出的意思是说，应该仅论述系统的最高层儿概括的设计原理。
许多团队因为注重文档而非软件，从而导致进度拖延，这常常是一个致命的缺陷。有一个简单规则可以预防该缺陷的发生。——直到迫切需要并且意义重大时，才编制文档。
客户合作 重于 合同谈判 成功的项目需要定期且频繁的客户反馈。不是依赖于合同或者关于工作的陈述，而让软件的客户和开发团队密切地工作在一起，并尽量经常地提供反馈。
随时应对变化 重于 遵循计划 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d784851023905bd6545fe06b7176f1/" rel="bookmark">
			boost库中优秀的网络库asio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、须知二、ASIO三、我们将从研究同步操作开始四、当使用异步操作时，会发生不同的事件序列五、Proactor模型六、常用内容七、C++ 建立本地网络服务器 （Boost.Asio库）1.服务器用例1.建造（Build）2.聆听（Listen）3.处理（Operation）4.异步（Async） 八、简易并发服务器类总诉 一、须知 开发大型项目，肯定需要使用一些框架，这些框架可以由你自己亲自手工实现，也可以直接引用第三方库。
1、自己实现框架
优点：程序的所有细节都能非常清楚的掌握。
缺点：工作量大、难度高。
2、引用第三方库
优点：选择一个稳定、靠谱的第三方框架，将很大程度降低工作量、提高开发效率，将精力重点放在业务逻辑。
缺点：库本身有功能和性能问题。
因此，请尽量使用优秀的第三方库，避免重复造轮子（自己造的轮子问题频发）。
二、ASIO asio 是boost库中优秀的网络库。asio是一个异步的io库，支持以同步或异步的方式处理事件，也可以用于基于tcp或udp的网络通信。
（1）可移植到windows、linux、FreeBSD。
（2）可扩展性。
（3）效率很高。
（4）易使用，类 Socket API 编程模型。
支持同步、异步通信方式。
三、我们将从研究同步操作开始 asio可以进行io对象（比如socket套接字）进行同步操作和异步操作。 在使用Asio之前，对Asio的各个部分、你的程序以及它们是如何一起工作的有个概念的了解是很有用的。作为一个介绍性的例子，让我们考虑一下在套接字上执行连接操作时会发生什么。
你的程序至少会有一个I/O执行上下文，比如asio::io_context对象，asio::thread_pool对象，或者asio::system_context。这个I/O执行上下文表示程序到操作系统I/O服务的链接。
asio::io_context io_context; 要执行I/O操作，你的程序需要一个I/O对象，比如一个TCP套接字:
asio::ip::tcp::socket socket(io_context); 当执行同步连接操作时，会发生以下事件序列:
你的程序通过调用I/O对象来启动连接操作 socket.connect(server_endpoint); I/O对象将请求转发给I/O执行上下文。
I/O执行上下文调用操作系统来执行连接操作。
操作系统将操作的结果返回给I/O执行上下文。
I/O执行上下文将操作产生的任何错误转换为asio::error_code类型的对象。error_code可以与特定的值进行比较，或者作为布尔值进行比较(如果结果为假，则表示没有发生错误)。然后将结果转发回I/O对象。
如果操作失败，I/O对象会抛出一个asio::system_error类型的异常。如果初始化操作的代码被写成:
asio::error_code ec; socket.connect(server_endpoint, ec); 然后error_code变量ec将被设置为操作的结果，并且不会抛出异常。
四、当使用异步操作时，会发生不同的事件序列 你的程序通过调用I/O对象来初始化连接操作 socket.async_connect(server_endpoint, your_completion_handler); 其中your_completion_handler是一个带有签名的函数或函数对象:
void your_completion_handler(const asio::error_code&amp; ec); 所需的确切签名取决于正在执行的异步操作。参考文档指出了每个操作的适当形式。
I/O对象将请求转发给I/O执行上下文。
I/O执行上下文向操作系统发出信号，说明它应该启动异步连接。
操作系统通过将结果放置在一个队列中表示连接操作已经完成，准备由I/O执行上下文获取。
当使用io_context作为I/O执行上下文时，你的程序必须调用io_context::run()(或类似的io_context成员函数)以便检索结果。当有未完成的异步操作时，调用io_context::run()会阻塞，所以你通常会在你开始第一个异步操作时调用它。
在调用io_context::run()时，I/O执行上下文会将操作的结果从队列中取出，转换成一个error_code，然后将其传递给完成处理程序。
五、Proactor模型 各部分内容 — Asynchronous Operation (异步操作) 定义一个异步执行的操作，如Socket异步读写。 Asynchronous Operation Processor (异步操作执行器) 执行一个异步操作，并执行完成事件队列中的队列事件，从更高层次上说，像reactive_socket_service的服务就是一个异步操作处理器。 Completion Event Queue (事件完成队列) 缓存完成事件直到被异步事件分离器弹出队列。 Completion Handler (处理器) 处理异步操作的结果，处理器是函数对象，往往使用bind创建。 Asynchronous Event Demultiplexer (异步事件分离器) 阻塞等待在完成事件队列中事件发生，之后向调用者返回完成事件。 Proactor 调用异步事件信号分离器将事件移出队列，并分配一个关联的处理器(如调用函数对象)，这个功能封装在io_service类中。 Initiator 执行特定程序代码启动异步操作，初始化器通过如basic_stream_socket等高层次接口与异步操作处理器交互，并返回reactive_socket_service等类型的服务代理。 六、常用内容 asio::io_context asio提供的一个基本的io对象，只有调用其run方法的线程才会被asio调度去执行任务，可以通过post方法添加一个任务。 asio::io_context main; //make_work_guard作用，创建一个executor_work_guard对象，在构造时通知io_context有任务开始，保证run方法不会退出 //析构时相反，让run方法在没有未完成任务时退出 auto i = aso::make_work_guard(main); another.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d784851023905bd6545fe06b7176f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9d9e2c7a51890963a7a83a73cabc99e/" rel="bookmark">
			[R]_使用filter_all()，filter_at()，filter_if()筛选数据框的行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前的文章讲了使用mutate_all()，mutate_at()，mutate_if()操作数据框的列，今天来讲讲使用filter_all()，filter_at()，filter_if()筛选数据框的行。使用过R，尤其是其中dplyr包的同学，对filter()这个函数不会陌生，filter_all()，filter_at()，filter_if()其实属于filter()更高级的用法，可以更有效地提高数据清洗的效率。这三者之间的区别和mutate_all()，mutate_at()，mutate_if()之间的区别相似。 filter_all() 作用于所有变量。filter_at()作用于按条件筛选后的变量。filter_if()作用于按条件筛选后的变量。
在这里我们以R的另一个数据集USArrests为例，这是美国50个州的犯罪指标，是一个50行4列的数据集，具体数值代表什么，我也不知道，只知道是American的数据就好了，不妨碍咱们对它做探索。
USArrests 数据集长这样
我们先用filter_all()筛选出大于5的行，在使用filter_all()之前，我们要区分其中参数any_vars和all_vars的用法，简单地说，any_vars是用“或”（“|”）连接所用变量，而all_vars是用“且”（“&amp;”）连接所有变量。
data_1=filter_all(USArrests,any_vars(.&gt;5)) 得到的数据集长这样
我们可以看到Connecticut那一行还是有小于5的值，这就是因为any_vars使用“或”连接，所以只要那一行有一个值大于5就会被保留下来。所以我们需要试一下all_vars。
data_2=filter_all(USArrests,all_vars(.&gt;5)) 数据集长这样
我们可以看到Connecticut这一行就被筛出去了，这就是因为all_vars使用“且”连接，需要所有列都大于5才会被保留下来。
接下来我们使用filter_at()做筛选，同样也要注意any_vars和all_vars的区分，这里我们用all_vars来筛选，选择UrbanPop和Rape都大于40的行
data_3=filter_at(USArrests,vars(UrbanPop,Rape),all_vars(. &gt;=40)) 得到如下数据集
这里就选出了UrbanPop和Rape都大于40的行。
接下来再用filter_if()，同样注意any_vars和all_vars的区分。
data_4=filter_if(USArrests,is.numeric,any_vars(is.numeric(.))) 数据集长这样
这里因为所有的数据都是numeric，所以is.numeric的结果都是TRUE，所以data_4的结果和原数据集是一样的。
到这里，我们就知道了filter_all()，filter_at()，filter_if()的使用方法，在实际使用时要注意any_vars() 和 all_vars()的区别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4667e44f8b9a4a7feaf05fad31a72c45/" rel="bookmark">
			java文件左下角出现橙色小J，无法识别为maven项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 新建项目或新导入项目的情况下
问题描述 java文件右下角有个J，无法识别为maven项目
原因分析： 所有java文件左下角显示橙色的小J，正常应该是蓝色。原因是idea进行加载时没有按照Source Root进行识别
解决方案： 我的笔记本是mac版的汉化idea，但一般使用的是英文版，在这里就使用英文版的步骤说，截图使用含化版，但两种的位置是一致的：
1、点击File &gt;&gt; Project Structure：
2、在Project Structure页面 选择 Project Settings下的 Modules,点击右侧删除项目Contect Root
3、点击Add Content Root 选择项目路径java文件夹
4、添加后如图标识完成
5、确认会到项目界面,显示正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43592776d24025d478ce31ac3bf67ef5/" rel="bookmark">
			openpilot了解与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. openpilot是什么 首先我们需要对openpilot要有个清楚的认知，openpilot主要基于python语言编写。openpilot进程之间通过ZMQ进行通信，使用订阅者和发布者模式，进程订阅其他进程的信息，进程一系列处理，将得到的结果发布出去，让其他进程获取其处理结果。整个openpilot项目可以分为以下几个模块：定位、决策、控制这几个部分。openpilot的实现原理类似于特斯拉靠的是纯视觉的解决方案，但因为camera只有两颗（一颗用于拍摄实现的路况，另一颗用于监控驾驶员），所以openpilot支持也比较有限， 主要支持车道保持 、ACC巡航、自动辅助变道这三个功能。当然如果是需要在汽车上使用起来需要使用EON、Harness这一系列官方的设备对接完成设备的安装与使用，但是我们也需要注意的是，openpilot同样是一个开源项目，这也就导致我们可以轻松地学习里面的一些操作以及算法。即使没有特殊的硬件或汽车，openpilot的所有服务也可以在PC上正常运行。这里官方推荐使用Carla Simulator在模拟中运行openpilot。这使openpilot可以在Ubuntu机器上的运行虚拟数据。
1. 数据结构 官方的代码还是比较清楚的，我们这里先来研究一下openpilot的整体目录
. ├── cereal # 用于所有日志的消息规范和LIB ├── common # openpilot中开发的类库功能 ├── docs # 文档 ├── opendbc # 显示如何解释汽车数据的文件，并以人类可读的方式对理解车辆CAN总线流量所需的信息进行编码。 ├── panda # CAN通信的代码 ├── third_party # 扩展第三方文件包 ├── pyextra # 扩展第三方python文件包 └── selfdrive # 驾驶汽车所需的代码 ├── assets # 用于用户界面的字体、图像和声音 ├── athena # 允许与应用程序app实现通信 ├── boardd # 守护进程与面板的通信 ├── camerad # 通过驱动程序从摄像头传感器捕获图像 ├── car # 用于读取状态和控制执行器的车辆特定代码 ├── common # 用于守护程序的共享C/C++代码 ├── controls # 规划和控制 ├── debug # 帮助您调试和执行汽车端口的工具 ├── locationd # 精确定位与车辆参数估计 ├── logcatd # Android logcat作为服务 ├── loggerd # 汽车数据记录器和上传器 ├── modeld # 驾驶和监控模型 ├── proclogd # 从proc记录信息 ├── sensord # IMU接口代码 ├── test # 单元测试、系统测试和汽车模拟器 └── ui # 用户界面 从这里我们可以发现基本上所有的核心操作都在selfdrive内部，当然也包括最核心的定位部分和规控部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43592776d24025d478ce31ac3bf67ef5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927fc3fc0515ea76f08bf8d400838a98/" rel="bookmark">
			JS高级语法十个重点和难点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JS高级语法十个重点和难点 一、立即执行函数 函数在进行定义的时候就立即执行
// 定义函数 function getName(){ console.log('你的名字') } // 调用函数 getName() (function(){ console.log('立即执行函数') })() 二、闭包 闭包是函数内部可以使用函数外部的变量
function f1(){ var n = 1; function f2(){ n+1; console.log(n) } return f2 } var result = f1(); result()//2 result()//3 result()//4 三、使用闭包定义私有变量 使用闭包定义私有变量，只能在函数内部进行使用
function f1(){ var name = '彦祖'; this.GetName = function(){ return name } this.SetName = function(value){ name = value } } var s1 = new f1(); console.log(s1.name)//undefined console.log(s1.GetName())//彦祖 四、原型和原型链 JavaScript所有的构造函数都有一个原型对象prototype，用于设置所有实例对象需要共享的属性和方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/927fc3fc0515ea76f08bf8d400838a98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2107d1fdc0850f2a516bfc2efadf86b1/" rel="bookmark">
			浅谈 —— AAA认证（认证&#43;授权）详解&#43;配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、AAA认证简介：
二、认证流程：
三、相关配置配置： （1）认证：
（2）授权：
一、AAA认证简介： AAA是认证（Authentication）、授权（Authorization）和计费（Accounting）的简称，是网络安全中进行访问控制的一种安全管理机制，提供认证、授权和计费三种安全服务，数据中心被大量应用
AAA提供的安全服务具体是指：
认证（Authentication）：是对用户的身份进行验证，判断其是否为合法用户。授权（Authorization）：是对通过认证的用户，授权其可以使用哪些服务。审计（Accounting）：是记录用户使用网络服务的资源情况，这些信息将作为计费的依据。 ——————————————————————————————————————————————————————————
二、认证流程： 数据中心常用（用于控制工程师权限，员工权限等.....) —————————————————————————————————————————————————————————— 三、相关配置配置： （1）认证： ①第一步：开启AAA认证 r2(config)#aaa new-model ②第二步：配置线下保护（console接口不参与AAA认证 , 防止某天AAA认证服务器出现故障时，不能通过调试线缆操作服务器）（！！！） r2(config)#aaa authentication login no-rz line none ——对登录的流量做一个名称为no-rz（不认证）的策略：如果原来这个console接口配置了一个password认证， 还是采用原来的password认证，如果没有配置的话，我后面就对这个console接口不认证了 也可以给console接口配置一个简单的密码： r2(config)#line console 0 r2(config-line)#password 123456 r2(config-line)#login authentication no-rz //调用策略no-rz r2(config-line)#exit ③第三步:对R1设备telnet我R2的时候提供AAA认证 r2(config)#user aaa password bbb // 创建本地用户名和密码数据库 r2(config)# tacacs-server host 192.168.100.100 key kkk r2(config)# radius-server host 192.168.100.100 key kkk //声明TACACS服务器或者radius服务器在哪，与这个AAA认证服务器传输数据的时候加密的密钥是KKK r2(config)#aaa authentication login telnet-rz group tacacs+ local （//认证的时候先进行AAA server 认证，如果AAA server认证失败或者AAA server不存在的话，进行本地认证。） （r2(config)#aaa authentication login telnet-rz local group tacacs+） //先采用本地数据库对login（登录）行为进行认证，如果本地数据库没有配置则采用身后的AAA认证服务器里面的用户名和密码对客户进行认证,认证策略名称为telnet-rz r2(config)#line vty 0 8 //在VTY线程里调用认证策略 r2(config-line)#login authentication telnet-rz r2(config-line)#exit ———————————————————————————————————————————————————————— （2）授权： ④第四步：对R1设备telnet我R2的时候提供AAA 用户级别授权 用户级别一共有0——15，共16个级别，15级权限最高，0和1级都有其特定的命令，2-14级没有，15级有些命令是属于1和0级的，2-14级命令库是空的，但是由于2-14级别比0和1级要高，所以权力使用0和1级的，但是0和1级的命令所有权是属于本身的。例如，我给我儿子买了玩具，这个玩具的所有权是属于我儿子的，但是我有权力使用这些玩具。 show privilege ——查看用户级别 r2(config)#username aaa privilege 5 //在本地定义这个用户级别为5 r2(config)#aaa authorization exec telnet-author group tacacs+ local exec：登录后直接进入到特权模式 r2(config)#aaa authorization exec telnet-author local group tacacs+ //先采用本地授权，如果我和服务器失去联系，再采用身后的AAA服务器为客户进行授权 r2(config)#line vty 0 8 //在telnet里面调用授权策略 r2(config-line)#authorization exec telnet-author r2(config-line)#exit ⑤第五步：AAA本地命令授权 r2(config)#privilege exec level 5 config t config t //是在EXEC特权模式下输入的，把这个命令剪切到5级命令库里面去 r2(config)#privilege configure level 5 int interface是在configuration 全局模式下输入的，把此命令剪切到5级里面去 r2(config)#privilege interface level 5 ip address r2(config)#privilege interface level 5 no shut r2(config)#privilege configure all level 5 router 把router后面的所有配置命令都剪切到5级命令库里面；router配置命令在configuration模式下输入的 详细：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2107d1fdc0850f2a516bfc2efadf86b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8aa12a52b36f9afd067da0e18639cad/" rel="bookmark">
			解决mysql锁死问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行以下命令
use information_schema; select a.host,a.db,a.info, b.trx_state, b.trx_started, b.trx_mysql_thread_id from processlist a join innodb_trx b on a.id = b.trx_mysql_thread_id where a.db='数据库名'; 杀掉导致锁死的进程
kill 结果表中的trx_mysql_thread_id；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1873539c333a6952763935b7dcc0a8a7/" rel="bookmark">
			linux shell find神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学好linux， find是我们必须掌握的一个命令，因此需要掌握常见用法，了解不常见的用法。常见用法整理如下：
1. find dir -name "xxx"， dir表示需要查找的目录， xxx表示文件/目录名，xxx可以用正则表达式。
2. find dir -type f \( -name '*.in' -o -name '*.in.2' \)， -type表示类型，后面跟的f表示文件，如果d表示查找目录。-name '*.in'表示查找以.in结尾的字符串，-name '.in.2'表示查找以.in.2结尾的字符串。这种方式可以连续查找多个文件/目录
3. find . -type f -name "*.txt" -delete，这种用法是查到后删除，也是比较常用的一种用法
待完善。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929e29e03c5049837fbf883b9fc7ee88/" rel="bookmark">
			`英语` 2022/8/29
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		moving bodies 运动物体 \text{moving bodies \quad 运动物体} moving bodies 运动物体
reconcile 调和, 使..和谐 \text{reconcile \quad 调和, 使..和谐} reconcile 调和, 使..和谐
reconcile A with B by C 通过C, 来调和A和B \text{reconcile A with B by C \quad 通过C, 来调和A和B} reconcile A with B by C 通过C, 来调和A和B
A, resulting from B A, 是B的结果 \text{A, resulting from B \quad A, 是B的结果} A, resulting from B A, 是B的结果
discredit 破坏..名誉, 否定 \text{discredit \quad 破坏.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/929e29e03c5049837fbf883b9fc7ee88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20a3b33b69ba6753941293ae6115cf6a/" rel="bookmark">
			spring boot sluth 日志记录 traceId
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring boot sluth 日志记录 traceId 场景 traceId 方便在日志中追踪信息
引入依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;version&gt;2.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; application.properties spring.profiles.active=dev spring.cloud.nacos.config.server-addr=192.168.226.10:8848 spring.cloud.nacos.discovery.server-addr=192.168.xxx.10:8848 spring.application.name=nacos-sluth server.port=8080 spring.cloud.nacos.config.file-extension=properties spring.cloud.nacos.config.group=DEFAULT_GROUP spring.cloud.nacos.discovery.namespace=a16fc3c1-c808-49f2-88e8-ec692ab150d1 spring.cloud.nacos.config.namespace=a16fc3c1-c808-49f2-88e8-ec692ab150d1 logback.xml &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;configuration scan="true" scanPeriod="30 seconds"&gt; &lt;!--0. 日志格式和颜色渲染 --&gt; &lt;!-- 彩色日志依赖的渲染类 --&gt; &lt;conversionRule conversionWord="clr" converterClass="org.springframework.boot.logging.logback.ColorConverter" /&gt; &lt;conversionRule conversionWord="wex" converterClass="org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter" /&gt; &lt;conversionRule conversionWord="wEx" converterClass="org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter" /&gt; &lt;!-- 彩色日志格式 --&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20a3b33b69ba6753941293ae6115cf6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec00de2bd004c938e4d19b9a5c4a1018/" rel="bookmark">
			w001 GeoScene Portal服务启动失败解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先检查一下杀毒软件，将GeoScene安装目录添加到杀毒软件白名单里；
2.Powershell手动开启服务；
sc create GeoScenePortal binpath=D:\geoscene\portal\framework\service\bin\GeoScenePortal.exe 或者 sc.exe create GeoScenePortal binpath=D:\geoscene\portal\framework\service\bin\GeoScenePortal.exe 3.多试几次，我的就是试了好几次才可以正常启动，如下图：
4.最后记得发服务的时候把Portal的所有系统服务都打开。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b142c71e929f562258a04eaad23e4067/" rel="bookmark">
			深度学习（PyTorch）——循环神经网络（RNN）基础篇五
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B站up主“刘二大人”视频 笔记
本文章是该视频的一部分，该部分的案例代码使用RNN做一个简单的实验，其余部分见作者的其他文章。
一、什么是循环神经网络
循环神经网络出现于20世纪 80年代，最近由于网络设计的推进和图形处理单元上计算能力的提升，循环神经网络变得越来越流行。这种网络尤其是对序列数据非常有用，因为每个神经元或者单元能用它的内部存储来保存之前输入的相关信息。在语言的案例中，“I had washed my house”这句话的意思与“I had my house washed”大不相同。这就能让网络获取对该表达更深的理解。
注意到这点很重要，因为当阅读一个句子甚至是一个人时，你就是要从它之前的单词中提出每个词的语境。
一个循环神经网络里有很多个环，这些环能允许带着信息通过神经元，同时在输入中读取它们。
二、循环神经网络能干什么
RNN 有很多应用。一个不错的应用是与自然语言处理（NLP）的合作。网上已经有很多人证明了 RNN，他们创造出了令人惊讶的模型，这些模型能表示一种语言模型。这些语言模型能采纳像莎士比亚的诗歌这样的大量输入，并在训练这些模型后生成它们自己的莎士比亚式的诗歌，而且这些诗歌很难与原作区分开来。
另一个让人惊喜的 RNN 应用是机器翻译。这种方法很有趣，因为它需要同时训练两个 RNN。在这些网络中，输入的是成对的不同语言的句子。例如，你能给这个网络输入意思相同的一对英法两种语言的句子，其中英语是源语言，法语作为翻译语言。有了足够的训练后，你给这个网络一个英语句子，它就能把它翻译成法语！这个模型被称为序列到序列模型（Sequence to Sequences model ）或者编码-解码模型（Encoder- Decoder model）。
三、RNN使用案例，代码如下：
import torch num_class = 4 input_size = 4 hidden_size = 8 embedding_size = 10 num_layers = 2 batch_size = 1 seq_len = 5 idx2char = ['e', 'h', 'l', 'o'] x_data = [[1, 0, 2, 2, 3]] # hello y_data = [3, 1, 2, 3, 2] # ohlol inputs = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b142c71e929f562258a04eaad23e4067/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11cff775054698c7af2272350dd76a47/" rel="bookmark">
			蓝牙协议之GATT学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Generic Attribute Profile(GATT) 像GAP层实现大多数连接相关的功能一样，BLE低功耗协议栈的GATT层被应用程序用于实现两个连接设备的数据通信。数据以特性的形式传递和存储，这些特性存储在蓝牙低功耗设备的存储器中。站在GATT层角度看，两个连接的设备分别处于GATT服务器和GATT客户端两个角色之一。
（1）GATT服务器：
这种设备包含特性数据库，供客户端读或者写访问。
（2）GATT客户端：
这种设备从服务器读或者写数据。
GATT的角色和GAP的角色是相互独立的存在，集中器可以是GATT服务器，也可以是GATT客户端，外部设备也一样。
2. GATT Characteristic And Attribute 参考蓝牙低功耗的描述，特性和属性从概念上有时可互换。特性可以看成是一个集合，而属性就像是特性的子集。实际上，设备之间传输的信息就是特性。特性约定和使用属性作为value(数值)、properties(权限)和configuration information(配置信息)。典型的特性由以下几个属性组成：
Characteristic Value特性值顾名思义，就是特性的值Characteristic Declaration声明描述权限、位置还有特性值的类型Client Characteristic Configuration配置允许GATT服务器配置特性为notified(通知)(异步发送消息)或者indicated(指示)(有响应地异步发送消息)Characteristic User Description描述用ASCII码字符串描述该特征 *注：后面两个（配置和描述）可选。
这些属性存储在GATT服务器属性表中，除了value之外，其他属性都有以下的Properties(这里不就再译为属性了，避免混淆)：
（1）Handle:属性在表格中的索引（每个属性有独一无二的句柄）
（2）Type:指明属性数值代表的是什么(UUID)，有些UUID是SIG技术联盟定义的，有些是用户自定义的
（3）Permissions: GATT客户端设备对属性值的访问权限
这是什么意思呢？可以看看下面的表格：
句柄类型uuidValue0x0010Primary ServiceLink loss0x0011Characteristic (rw, 0x0012, Alert Level)0x0012Alert Level0x000x0020Primary ServiceTx Power0x0021Characteristic(r, 0x0022, Tx_Power dBm)0x0022Tx_Power dBm0x040x0030Primary ServiceImmediate Alert0x0031Characteristic(w, 0x0032, Alert Level)0x0032Alert Level 属性Property是最小可寻址的数据单元，可以通过16BIT的Handle句柄寻址，它的类型UUID可以是16BIT的、32BIT的甚至是128BIT的(这里简单说一下UUID，UUID有些是蓝牙技术连门SIG定义的，有些是我们用户自己定义的，完整的UUID都是128BIT长度，我们遇到的很多16bit的UUID只是SIG定义的128BITUUID中的一部分，而我们用户自定义的UUID，那么这128Bit都可自己定义)，属性有一个数据域，其字节数最高达512字节。总结，ATT协议定义属性由句柄、UUID、数值组成。一个Characteristic至少包含一个数值属性和一个声明属性，数值属性的意义定义在Profile中，声明总是出现在数值属性的前面，用于描述数值属性是否具备读或者写、特性的UUID以及特性值的句柄（可以从上表体会）。
一个Peer device(这里你可以简单理解为GATT客户端设备)可以通过属性的句柄寻址，并且设备只能对属性进行空中操作。在无线传输协议中并没有服务和特性的概念，仅有属性的概念，意思就是说蓝牙无线传输都是传的属性，设备端自行将收到的解析成服务和特性。
3. GATT Client Abstraction GATT客户端抽象层，GATT客户端没有属性表或者配置文件，不存在服务信息。分层如下：
4. GATT Server Abstraction 作为GATT服务器，大多数的GATT功能都有独自的GATT配置文件(profiles)封装。这些profiles使用GATTServApp(TI是用这个模块，名字就叫做 GATTServApp，应该其他蓝牙芯片也有相似的模块)来存放和管理属性表 。
上面的图片是 GATT Server的分层框架，可见，比客户端的多了两层，分别是GattServApp、Profiles。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11cff775054698c7af2272350dd76a47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/000a153a4eeb61d01387e83aaf8f0e3f/" rel="bookmark">
			MySQL中多表查询、表连接（内连接和外连接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
表与表的关系
一对一关系
一对多关系
多对多关系
表与表之间的连接
笛卡尔积
什么是笛卡尔积：
内连接：
1、通过where关键字进行关联
2、通过inner join on进行关联
外连接：
1.左连接（left join）
2.右连接right join
子查询
有时候我们所需要的数据不止在一张表中，需要多个表做结合的查询，这时就需要进行表连接。
表与表的关系 多表连接主要需要决定关系：方向性、主附关系
一对一关系 在一对一关系中，A表中的一行最多只能匹配B表中的一行，反之亦然，创建的就是一对一关系。
一对多关系 一对多关系是最常见的一种关系，A表中的一行可以匹配B表中的多行，但是B表中的一行只能匹配A表中的一行。
例如：存在部门表和人员表之间具有一对多的关系，每个部门有很多的员工，但是每个员工只属于一个部门
只有当一个相关列是一个主键或者具有唯一性约束时，才能创建一对多的关系。
多对多关系 在多对多的关系中，A表中一行可以匹配B表中的多行，反之亦然。
要创建这种关系，需要定义第三张表，称之为结合表，他的主键由A表和B表外部键组成
表与表之间的连接 笛卡尔积 什么是笛卡尔积： 数学上，有两个集合A={a,b},B={1,2,3},则两个集合的笛卡尔积={{a,1}, {a,2}, {a,3}, {b,1}, {b,2}, {b,3}} 列出所有情况,一共是2*3=6条记录；
在数据库中，笛卡尔积是多表查询没有连接条件时返回的表结果。
笛卡尔积的元素是元组，关系A和关系B的笛卡尔积可以记为（AXB），如果A表a条，B表为b条，那么A和B的笛卡尔积为（a+b）列数，有（a*b）行的元素集合。检索出来的条目是将第一个表中的行数乘以第二个表中的行数。
避免全笛卡尔积 ：在 where 加入有效的连接条件；
消除笛卡尔积：使用等值连接和非等值连接；
内连接： 内连接称之为普通连接或自然连接，按照连接条件，返回两张表中的满足条件的记录。
内连接查询的特征：只关联表与表中能够匹配到的数据信息，才能有对应的查询结果，如图所示：
内连接提供了两种表与表之间的连接方式：
1、通过where关键字进行关联 格式一： select 表1.列名1，表2.列名1 from 表名1，表名2 where 表1.列名1=表2.列名1; 注意：
表与表之间建立起关联的列，列名可以不一样，但是这两个列的数据类型和内容必须保持一致要查询的字段，必须要在字段的前面加上表名或者表的别名 2、通过inner join on进行关联 inner是可以省略的，可写可不写。
格式二： select 表1.列名1，表2.列名1 from 表名1 [inner] join 表名2 on 表1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/000a153a4eeb61d01387e83aaf8f0e3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a58924ef1fd0402d9991a65737f174/" rel="bookmark">
			【Transformers】BertModel模块的输入与输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 通常我们使用bert进行模型fine-tune时，大多是使用Transformer这个包，官方地址：https://huggingface.co/. 如果想使用Bert获取任务对应的动态词向量，那么这时我们就需要了解Bert模型需要的输入与输出了。如果对bert模型不了解的可以看看我之前的文章：【NLP】BERT(BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding)阅读与总结.
BertModel对象构建 想要使用Bert模型获取对应内容的动态词向量的第一步则是先构建Bert模型，现如今Bert模型也多种多样，在不同的任务中选择合适的预训练模型。对应的预训练模型可以在官网上离线下载，也可以在线下载。当然，毕竟模型那么大，我们通常使用的离线下载的模型。以bert-base-chinese为例。我们首先进入模型列表：
然后根据下面操作就可以进入bert-base-chinese预训练模型的地址了：
然后选择下面三个文件下载：
注意文件的名称要保持不变。下载的文件顾名思义就是对应模型文件，配置文件，词表文件。
那么模型的加载如下：
from transformers import BertModel bert = BertModel.from_pretrained("pre_model/bert-base-chinese") print(bert) 模型如下：
模型的输入 我们可以从官方文档中：https://huggingface.co/docs/transformers/model_doc/bert#transformers.BertModel 可以看到模型的输入：
( input_ids: typing.Optional[torch.Tensor] = None, attention_mask: typing.Optional[torch.Tensor] = None, token_type_ids: typing.Optional[torch.Tensor] = None, position_ids: typing.Optional[torch.Tensor] = None, head_mask: typing.Optional[torch.Tensor] = None, inputs_embeds: typing.Optional[torch.Tensor] = None, labels: typing.Optional[torch.Tensor] = None, next_sentence_label: typing.Optional[torch.Tensor] = None, output_attentions: typing.Optional[bool] = None, output_hidden_states: typing.Optional[bool] = None, return_dict: typing.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7a58924ef1fd0402d9991a65737f174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acc1e7c4e22c955eb61725c89876b2bf/" rel="bookmark">
			【pytorch报错】If you tried to load a PyTorch model from a TF 2.0 checkpoint, please set from_tf=True
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 加载torch的huggingface的bin模型，未使用复杂处理逻辑，但是出现异常，详细报错内容
OSError: Unable to load weights from pytorch checkpoint file for 'xxxxx/huggingface_model/bart-large-chinese' at 'xxxxxx/huggingface_model/bart-large-chinese/pytorch_model.bin' If you tried to load a PyTorch model from a TF 2.0 checkpoint, please set from_tf=True. 尝试 设置from_tf=True， 结果并有改善按照提示，以为是TF的版本太高，于是查看TF版本，结果报错 ImportError: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.20' not found (required by xxxxx/lib/python3.7/site-packages/tensorflow/python/_pywrap_tensorflow_internal.so) 发现机器上并没有安装TF
解决办法 说来解决办法有点水，参考之前有效的机器，发现torch的版本是1.11，后来将原始版本升级到1.11
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1ecc49a183c76010199ad7e43139c2/" rel="bookmark">
			cs224w（图机器学习）2021冬季课程学习笔记9
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		维生素C吃多了会上火-个人CSDN博文目录
cs224w（图机器学习）2021冬季课程学习笔记集合
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34290a7e1ecc38634bd291cf65c63440/" rel="bookmark">
			手动部署jumpserver堡垒机（完整过程&#43;常见错误）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、网站架构为什么需要跳板机，堡垒机
二、跳板机和堡垒机概念
跳板机：
堡垒机：
堡垒机的作用：
堡垒机模块
堡垒机的功能
jumperserver官网
三、jumpserver服务器部署
1、环境准备，关闭防火墙
2、配置yum源，准备好阿里云的yum源
3、安装系统初始化环境
5、修改系统的字符集，改为中文的
6、部署mysql5.6数据库
6.1、官网下载mysql5.6版本
6.2、解压缩数据包
6.3、修改一些mysql的配置文件
6.4、myql进行初始化
6.5、登陆数据库后，创建运行jumpserver所需的用户信息（并更改字符编码为utf8，使其支持中文）
6.6、创建用户（@占位符，%允许用户在任何地方登陆，identified by指定密码）
6.7、给该用户赋予权限
7、部署python3.6
7.1、下载python3.6的源代码
7.2、解压编译python安装包
7.3、配置python3的环境变量
7.4、创建python3的虚拟环境
------注意如果创建虚拟环境时出现这种报错 ------ 出错原因
解决方法
7.5、更换pip3的源
7.6、再安装pip3 install virtualenv 模块
7.7、激活虚拟python3.6
8、部署redis数据库
8.1、安装redis数据库
8.2、启动验证服务 9、部署jumpserver服务
9.1、下载jumpserver程序的代码
9.2、解压源码，安装jumpserver需要的依赖软件
9.3、安装运行jumpserver所需的模块
9.4、修改jumpserver配置文件
10、对python程序进行数据库迁移
10.1、首先进入mysql查看一下库
10.2、jumpserver后台程序，数据库迁移命令
------注意如果在进行数据库迁移时出现这种报错------
主要原因
解决办法
再次进行python3 /opt/jumpserver/apps/manage.py makemigrations ，问题解决！！！！
10.3、继续下一步，数据库迁移命令2
10.4、进入mysql验证一下数据库中数据
10.5、启动jumpserver服务
11、部署CoCo/koko组件
11.1、下载koko组件
11.2、解压koko
11.3、启动koko程序
12、安装Guacamole的
12.1、部署Guacamole组件
12.2、安装guacamole组件需要的一些软件包
12.3、安装FFmpeg工具
12.4、编译安装guacamole
12.5、安装java开发环境
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34290a7e1ecc38634bd291cf65c63440/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/005bf913c2c061ca33782264f6c4e7ce/" rel="bookmark">
			《零基础D编程入门三》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章：win系统下安装D
3.1 要求及下载
3.2 文件
3.3 安装
3.4 示列
3.5 连接
3.6 环境变量
3.7 sc.ini 初始化文件
3.8 常见的安装问题
3.9 Windows 和 Linux 两种版本的区别
3.10 D 接口文件
3.11 建造执行文件
3.12 建造库
3.13 编译 dmd
3.14 编译 Phobos什么？
一：要求及下载 1.下载D编译器
2.32位Windows(Win32)操作系统，如WindowsXP
3.下载Win32版本的dmc.zip(C和C++编译器)（非必要的，它是Windows版的
dmd的补充）（64位相同，我这使用32位系统演示后期更新64位系统安装）
二：文件 \dmd2\src\phobos\：D语言运行库源码
\dmd2\src\dmd\：D编译器前端源码遵从双重证书——GPL和Artistic
\dmd2\html\d\
：文档
\dmd2\samples\d\：D程序示例
\dmd2\windows\bin\dmd.exe：D编译器执行文件
\dmd2\windows\bin\shell.exe：简单命令行shell
\dmd2\windows\bin\sc.ini：全局编译器设置
\dmd2\windows\lib\phobos.lib：D运行库
三：安装 打开控制台窗口（在WindowsXP里，可以通过点击[开始][运行]）。所有的工具都是命令行工具，这意味着它们都可以运行在控制台窗口里。切换到根目录。在根目录下解压文件。dmd.zip将会创建目录\dmd2，用于存放压缩包里所有文件。dmc.zip会创建目录\dm，用于存放压缩包里所有文件。
通常的过程看起来就象这样：
C:\DocumentsandSettings\YourName&gt;cd\ C:\&gt;unzipdmd.zip C:\&gt;unzipdmc.zip 四：示列 \dmd2\windows\bin\shellall.sh 五：连接 在成功编译后，直接由dmd编译器完成连接。想要禁止dmd运行连接器，请使用开关-c。
程序必须跟D运行库phobos.lib连接，同时还有C运行库snn.lib。只要这些库在环境变量LIB所指定的路径里，这个操作会自动完成。设置LIB常用的方式是：
setLIB=\dmd2\lib;\dm\lib 如果使用dmd命令来进行编译然后连接成执行文件，那么它将进行一些仅针对Windows执行文件效的优化。在DLL里不要使用结果.obj文件。要将模块编译成可以在exe或DLL里使用的.obj文件，使用-c进行编译。
使用optlink连接器来完成连接。
六：环境变量 D编译器dmd使用了下列环境变量：DFLAGS：DFLAGS的值等同于在命令行添加给dmd.exe。
LIB：连接器使用LIB来指定搜索库文件的地方。在D中，通常的设置是：
setLIB=\dmd2\lib;\dm\lib LINKCMD：dmd通常通过寻找link.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/005bf913c2c061ca33782264f6c4e7ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c5127e8abc556d7c734f9ae596de81e/" rel="bookmark">
			小米开机the system has been destroyed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：可能是升级/刷机系统之时重启导致，也可能是刷机时选择了【全部删除并/lock】导致系统损坏，非硬件损坏，可以通过刷机解决。 解决步骤 1、解锁BL，登录后进行解锁。 2、解锁后刷机即可 记得点击全部删除
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4414d5f631dcb3285a1a1f12c2ae502a/" rel="bookmark">
			基于javaweb&#43;jsp的酒店管理系统(JavaWeb MySQL JSP Bootstrap Servlet SSM SpringBoot)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+jsp的酒店管理系统(JavaWeb MySQL JSP Bootstrap Servlet SSM SpringBoot)
JavaWeb JavaBean JSP MVC MySQL Tomcat JavaScript Bootstrap.
基础JSP+Servlet或JSP+SSM(Spring、SpringMVC、MyBatis)框架或JSP+SSM+Maven(pom.xml)框架或SpringBoot…均可
开发工具：eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
&lt;div class="index-content"&gt; &lt;div class="index-content-operation"&gt; &lt;a class="info-detail"&gt;修改客房&lt;/a&gt; &lt;br&gt; &lt;br&gt; &lt;/div&gt; &lt;br&gt; &lt;form action="roomEdit" method="post" onsubmit="return check()"&gt; &lt;input type="hidden" id="id" name="id" value="${vo.id}"/&gt; &lt;table class="index-content-table-add"&gt; &lt;tr&gt; &lt;td width="12%"&gt;房间号：&lt;/td&gt;&lt;td&gt;&lt;input class="index-content-table-td-add" type="text" id="roomName" name="roomName" value="${vo.roomName}"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width="12%"&gt;类型：&lt;/td&gt; &lt;td&gt; &lt;input name="roomLevel" type="radio" value="普通" ${vo.roomLevel=='普通'?'checked':''}/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;普通&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input name="roomLevel" type="radio" value="贵宾" ${vo.roomLevel=='贵宾'?'checked':''}/&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;贵宾&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; //调用Service层的增加（insert）方法 lodgingService.insert(vo); this.redirectList(request, response); } /** * 删除住宿 * * @param response * @param request * @throws IOException */ @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4414d5f631dcb3285a1a1f12c2ae502a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72818de0d34d085d9de7d6eda9d354b2/" rel="bookmark">
			JavaScript中函数的声明方式、作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、函数的调用 函数之家可以相互进行调用
//1-函数可以相互调用 function fn() { console.log(111); fn1()//在fn中调用了fn1函数 } fn(); function fn1() { console.log(22); } fn1() 案列展示： 根据用户输入年份，输出当年2月份的天数
//案列-根据用户年份输出2月份天数 function backDay() { var year = prompt('请输入年份：'); if (isRun(year)) { alert('当前年份是闰年，2月份有29天！') } else { alert('当年是平年，2月份有28天！') } } backDay(); function isRun(year) { var flag = false; if (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) { flag = true; } return flag } 2、函数的两种声明方式 （1）利用函数关键字自定义函数（命名函数） function fn(){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72818de0d34d085d9de7d6eda9d354b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39b204fc26ee98bbc11d6661c2b646bf/" rel="bookmark">
			android自定义弹窗：Dialog
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android制作一个等待框
创建文件 Dialog.java
import android.app.Activity; import android.app.AlertDialog; import android.os.Bundle; import android.view.Gravity; import android.view.Window; import android.view.WindowManager; import android.view.animation.AnimationUtils; import android.view.animation.LinearInterpolator; import android.widget.ImageView; import com.Amusic.R; import android.widget.Toast; import android.widget.TextView; public class Dialog extends AlertDialog { private Activity context; private ImageView myImageView; private TextView wb1; private int time,image; private String text; private boolean delay = false; public load(Activity context) { super(context); this.context = context; } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39b204fc26ee98bbc11d6661c2b646bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b1923c298a539a58b2d7c3343a35285/" rel="bookmark">
			Node学习（三）03-处理POST请求、静态资源、404——Postman使用和设置参数&amp;POST请求-浏览器提交数据给服务器&amp;res.statusCode设置状态码&amp;fs.readFile读取文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Node学习（三）03-处理POST请求、静态资源、404——Postman使用和设置参数&amp;POST请求-浏览器提交数据给服务器&amp;res.statusCode设置状态码&amp;fs.readFile读取文件 2.4.4 处理浏览器POST方式提交的数据 浏览器要发送POST方式的请求比较麻烦，所以这里可以使用POSTMAN软件来模拟请求。
上一节，我们根据不同的url地址，对不同的请求，做出了不同的响应。但这些请求都是GET方式的请求，如果浏览器使用POST方式向服务器发送了一次请求，又该如何处理呢？
POST请求一般会提交数据给服务器，服务器在接收数据的时候也是分块接收的
1、初始结构 1.1、Postman使用界面和设置请求参数
1.2、设置本地node的接口js文件
061-处理POST请求.js
const http = require('http'); const server = http.createServer(); server.listen(3000, () =&gt; console.log('启动了')); // 只要有浏览器发来请求，就会触发下面的事件 server.on('request', (req, res) =&gt; { console.log('123'); console.log(req.method); // POST }); 1.3、打开终端，执行命令
node ./061-处理POST请求.js 此时显示，默认请求方式GET
打开Postman使用界面，设置请求参数，点击send按钮
Postman显示上图
node终端显示下图
2、完整结构 062-处理POST请求.js
const http = require('http'); const server = http.createServer(); server.listen(3000, () =&gt; console.log('启动了')); // 只要有浏览器发来请求，就会触发下面的事件 server.on('request', (req, res) =&gt; { // console.log('123'); // console.log(req.method); // POST // POST请求，意思是浏览器提交数据给服务器 // 服务器肯定要接收这些数据，并把这些数据保存 // 如何接收POST提交过来的数据 /** * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b1923c298a539a58b2d7c3343a35285/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f359709502e56e0cc62afe8eac62d930/" rel="bookmark">
			C&#43;&#43; Protobuf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Protobuf protobuf (protocol buffer) 是谷歌内部的混合语言数据标准。通过将结构化的数据进行序列化(串行化)，用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。
序列化： 将结构数据或者对象转换成能够用于存储和传输的格式。
反序列化： 在其他的计算环境中，将序列化后的数据还原为数据结构和对象
下载安装 sudo apt install autoconf automake libtool curl make g++ unzip https://github.com/protocolbuffers/protobuf/releases/ cd protobuf ./autogen.sh ./configure make make check sudo make install sudo ldconfig Proto3中的数据类型限定修饰符： repeated 表示一个数组类型 protobuf中常用的数据类型： bool, 布尔类型double, 64位浮点数float, 32位浮点数int32, 32位整数int64, 64位整数uint64, 64位无符号整数sint32, 32位整数，处理负数效率更高sint64, 64位整数，处理负数效率更高string, 只能处理ASCII字符bytes, 用于处理多字节的语言字符enum, 枚举类型 默认值 解析消息时，如果编码的消息不包含特定的单数元素，则已分析对象中的相应字段将设置为该字段的默认值。这些默认值是特定于类型的：
对于字符串，默认值为空字符串。对于字节，默认值为空字节。对于布尔值，默认值为 false。对于数值类型，默认值为零。对于枚举，默认值是第一个定义的枚举值，该值必须为 0。对于消息字段，未设置该字段。它的确切值取决于语言。 举个栗子 syntax = "proto3";	//默认proto2，这里用proto3 package pt; //C++ 类似 namespace enum EnMsgType{ EnMsgTypeP = 0; //占位 LOGIN_MSG = 1; // 登录消息 LOGIN_MSG_ACK = 2; // 登录响应消息 LOGIN_OUT_MSG = 3; // 注销消息 REG_MSG = 4; // 注册消息 REG_MSG_ACK = 5; // 注册响应消息 ONE_CHAT_MSG = 6; // 聊天消息 ADD_FRIEND_MSG = 7; // 添加好友消息 CREATE_GROUP_MSG = 8; // 创建群组 ADD_GROUP_MSG = 9; // 加入群组 GROUP_CHAT_MSG = 10; // 群聊天 } message MsgType{ EnMsgType msgtype = 1; } enum ErrCode { SUCCESS = 0; //正确 FAILURE = 1; //失败 ONLINE = 2; //已在线 }; message FriendsInfo { int32 id = 1; string name = 2; string state = 3; } message UsersInfo{ int32 id = 1; string name = 2; string state = 3; string role = 4; } message GroupsInfo{ int32 id = 1; string groupname = 2; string groupdesc = 3; repeated UsersInfo users = 4; } message Login { MsgType msgid = 1; int32 id = 2; string pwd = 3; } message LoginRsp{ MsgType msgid = 1; int32 id = 2; string name = 3; repeated string offlinemsg = 4; repeated FriendsInfo friends = 5; repeated GroupsInfo groups = 6; ErrCode errcode = 7; string errmsg = 8; } 生成代码 protoc test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f359709502e56e0cc62afe8eac62d930/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e738d57bd3f8a5751fa18aa4a450f02a/" rel="bookmark">
			C语言基础入门——保姆式教程（2022版最全最新整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一. 前言二. 第一个C语言程序三. 数据类型四. 变量和常量a）变量1）局部变量2）全局变量 b）常量1）字面常量（相当于直接写）2）const修饰的常量3）#define定义的标识符常量4）枚举常量 五. 字符串+转义字符+注释a）字符串1）字符数组 b）转义字符c）注释 六. 选择语句（分支语句）a）if语句b）switch语句1）default 七. 循环语句a）while语句b）for语句c）do ... while语句d）goto语句 八. 函数a）函数分类1）库函数2）自定义函数 b）函数参数1）实际参数（实参）2）形式参数（形参） c）函数调用1）传值调用2）传址调用 d）函数的嵌套调用和链式访问1）嵌套调用2）链式访问 e）函数的声明和定义1）函数声明2）函数定义 f）函数递归 九. 数组a）一维数组1）一维数组的创建2）一维数组的初始化 b）二维数组1）二维数组的创建2）二维数组的初始化 c）数组越界d）数组作为函数参数e）数组名 十. 操作符a）算术操作符b）移位操作符1）左移2）右移x1）逻辑移位x2）算术移位 c）位操作符1）&amp;:按位与2）|:按位或3）^:按位异或 d）赋值操作符e）单目操作符1）！逻辑反操作2）sizeof3）~ 按（二进制）位取法4）++ 前置、后置++5）-- 前置、后置 --6）（类型）强制类型转换7）&amp; 取地址操作符 * 解引用操作符 f）关系操作符g）逻辑操作符h）条件操作符i）逗号表达式j）下标引用、函数调用和结构成员1）下标引用[]2）函数调用() k）表达式求值1）隐式类型转换x1）整形提升 2）算术转换3）操作符的属性 十一. 常见关键字a）autob）externc）registerd）signede）unsignedf）static1）static修饰局部变量2）static修饰全局变量3）static修饰函数 g）unionh）voidi）typedef 十二. define定义常量和宏a）define定义常量b）define定义宏 十三. 指针a）指针的基本认识b）指针的意义c）野指针1）指针未初始化2）指针越界访问3）指针指向的空间释放 d)如何规避野指针1）指针初始化2）小心指针越界3）指针指向空间释放即使置NULL4）避免返回局部变量的地址5）指针使用之前检查有效性 e）指针运算1）指针+-整数2）指针-指针3）指针的关系运算 f）指针和数组g）二级指针h）指针数组 十四. 结构体十五. 补充a）scanf函数b）调试1）调试的基本步骤2）快捷键x1）内存x2）调用堆栈x3）打断点x4）常用快捷键 3）常用的调试技巧x1）使用assertx2）尽量使用constx3）养成良好的编码风格x4）添加必要的注释x5）避免编码的陷阱 4）编译常见的错误x1）编译型错误x2）链接型错误x3）运行时错误 一. 前言 本文是作者初学C语言的笔记整理哦，已进行6次更新（还会不断更新，结束会说明哦），小伙伴们注意接收哦，另外有什么问题可以留下你的邮箱，我会及时查看哦，另外制作不易，一键三连哦~本文现已结束初阶C语言，接下来将进入进阶C语言 二. 第一个C语言程序 #include &lt;stdio.h&gt; int main() { printf("初学C语言"); return 0; } 这里说明下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e738d57bd3f8a5751fa18aa4a450f02a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30d12ec8d51dd1b30aa2c59cd1038bd9/" rel="bookmark">
			list集合 去重的3个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.*; import java.util.stream.Collectors; /** * 集合去重方法 */ public class CollectionDistinct { public static void main(String[] args) { List list = Arrays.asList(1, 2, 3, 4, 5, 6, 1, 5, 5); list.forEach(i -&gt; System.out.print(i + " ")); System.out.println(" - 原集合"); HashSetDistinct(list).forEach(System.out::print); System.out.println(" - 通过HashSet自动去重"); SteamDistinct(list).forEach(System.out::print); System.out.println(" - 使用steam去重"); ListContainsDistinct(list).forEach(System.out::print); System.out.println(" - 使用list contains去重"); } /** * 使用 steam 去重(需要 Java 1.8或以上) * * @param data * @return */ static List SteamDistinct(List data) { return (List) data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30d12ec8d51dd1b30aa2c59cd1038bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e63b6439e4b6512b0a941e2b0e6b961f/" rel="bookmark">
			从零实现自动求导以及线性回归实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、定义自己的Tensor 这里为了方便起见，只支持float类型的数据，而且只支持标量，不支持向量：
class Tensor: def __init__(self, data, requires_grad=False): """ 初始化Tensor，只支持float类型的标量 """ if not type(data) is float: raise RuntimeError(f'invalid data type {type(data).__name__}') self.data = data self.requires_grad = requires_grad # 初始化梯度 self.grad = None # 用于计算图的操作算子 self._op = None 当清楚梯度时，直接将梯度设置为None
def zero_grad(self): self.grad = None 为了方便调试，重写了__str__和__repr函数：
def __str__(self): return f"kyTorch.Tensor({self.data:.4f}, requires_grad={self.requires_grad})" def __repr__(self) -&gt; str: return f"Tensor({self.data:.4f}, requires_grad={self.requires_grad})" 测试：
a = Tensor(2., requires_grad=True) print(a)	# kyTorch.Tensor(2.0000, requires_grad=True) b = Tensor(4) print(b)	# RuntimeError: invalid data type int 二、实现Tensor的加法和乘法 定义运算操作的基类，为了便于复用，并不直接使用forward做运算，而是使用apply。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e63b6439e4b6512b0a941e2b0e6b961f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/091ea21fbcceb93b3dbe1765332e66dc/" rel="bookmark">
			Centos&#43;php&#43;nginx&#43;mysql环境部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos+php+nginx+mysql环境部署 Centos环境下部署php环境经常会遇到一些问题，每次历尽千辛万苦解决后又没有做记录，再次遇到部署的时候又会重来头疼不已
在这里我写一个非常详细的文章记录最近一次部署过程
1 部署环境 服务器：CentOS 8
PHP版本：7.3.20
mysql：5.7
web服务器：nginx 1.14.1
2 安装PHP环境 我们使用 dnf 来安装 PHP环境，不推荐使用 yum 直接来按，因为很有可能会遇到各种冲突
使用 dnf 很有可能会遇到
Failed to Download Metadata for Repo ‘AppStream’ 问题yum 命令直接提示找不到软件包源 我们拿到空白服务器后首先配置好各种软件包源，确保安装顺畅
设置CentOS软件包源为华为云镜像 https://mirrors.huaweicloud.com/home
# 备份原有软件仓库文件 cp -a /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak # 下载华为云镜像仓库文件 wget -O /etc/yum.repos.d/CentOS-Base.repo https://repo.huaweicloud.com/repository/conf/CentOS-8-reg.repo # 清除原有yum缓存 yum clean all # 刷新缓存 yum makecache # 执行软件包更新 yum update 增加 dnf 源
sed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-* sed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/091ea21fbcceb93b3dbe1765332e66dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca43beb2a7315bc5f8de98b3a46b7604/" rel="bookmark">
			为什么Vue组件中的data是一个函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统方式编写应用存在的弊端 不同界面使用相同的代码时，依赖关系混乱，修改样式时，会造成其他界面的样式随之改变
组件化编码 不同功能区域划分为不同的组件，多个界面共同使用的组件可抽象位公共组件进行复用
模块与组件、模块化与组件化 模块 1. 理解: 向外提供特定功能的 js 程序, 一般就是一个 js 文件 2. 为什么: js 文件很多很复杂 3. 作用: 复用 js, 简化 js 的编写, 提高 js 运行效率 组件 1. 理解: 用来实现局部(特定)功能效果的代码集合(html/css/js/image…..) 2. 为什么: 一个界面的功能很复杂 3. 作用: 复用编码, 简化项目编码, 提高运行效率 模块化 当应用中的 js 都以模块来编写的, 那这个应用就是一个模块化的应用。 组件化 当应用中的功能都是多组件的方式来编写的, 那这个应用就是一个组件化的应用 非单文件组件 一个文件中包含 n 个组件
单文件组件 一个文件只包含一个组件
data的两种写法 第一种：对象式写法 data:{ name:'尚硅谷' } 第二种写法：函数式写法 data:function(){ return{ name:'尚硅谷' } } 组件中只能使用 函数式写法 组件的创建就是被用来复用的，若A界面改变了A组件的data数据，B界面在使用A组件时，其中的数据也会随着A界面的改变 而变化，这是我们不希望看到的，因此通过函数的方式，在每次调用data函数式，都返回一个新的对象，就可以保证各个组件都有自己的一套独立的数据，不会互相造成影响。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6140f579d704bb1b932043461179815/" rel="bookmark">
			【Pytorch】下载CIFAR10数据集报错：urllib.error.URLError: ＜urlopen error name: https）的有效解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Pytorch】下载CIFAR10数据集报错：urllib.error.URLError: ＜urlopen error name: https&gt; 首先
要在代码开始前加入如下这两行代码（我的是windows 10系统）
import ssl ssl._create_default_https_context = ssl._create_unverified_context 但是
会发现接下来运行代码时又会报这样的错：
import _ssl # if we can't import it, let the error propagate ImportError: DLL load fail 找不到指定的模块 解决方式
就是重新启动pycharm打开这个文件并选择之前使用的conda环境，再次运行代码即可下载数据集了（成功下载如下截图中的进度条）哈哈哈嗝!]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba30931f244728d1908dfa90e0af993b/" rel="bookmark">
			android4.0 添加一个新的android 键值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里添加新的键值，不是毫无凭据凭空创造的一个键值，而是根据kernel中检测到的按键值，然后转化为android所需要的数值：
以添加一个linux键值为217，把它映射为android的键值Browser(这个键值之前不存在)为例介绍一下：
1、android之前没有这个键值，需要定义
/frameworks/base/core/java/android/view/KeyEvent.java
//定义这个新的键值
public static final int KEYCODE_BROWSER = 210;
然后我们会看到有如下注释：
// NOTE: If you add a new keycode here you must also add it to:
// isSystem()
// native/include/android/keycodes.h
// frameworks/base/include/ui/KeycodeLabels.h
// external/webkit/WebKit/android/plugins/ANPKeyCodes.h
// frameworks/base/core/res/res/values/attrs.xml
// emulator?
// LAST_KEYCODE
// KEYCODE_SYMBOLIC_NAMES
//
// Also Android currently does not reserve code ranges for vendor-
// specific key codes. If you have new key codes to have, you
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba30931f244728d1908dfa90e0af993b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2927b0fa5c3c817d27ceecfd1b6001d9/" rel="bookmark">
			CentOS7日志文件及journalctl日志查看方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 日 志 文 件 说 明1、概述2、查看所有日志3、查看内核日志4、查看系统本次启动的日志5、查看上一次启动的日志6、查看指定时间的日志7、按服务过滤消息日志8、按进程、用户或者群组ID9、按优先级10、输出格式11、journal维护12、启用日志消息的持久存储 日 志 文 件 说 明 tail /var/log/messages //系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一 tail -f /var/log/secure //与安全相关的日志信息 tail /var/log/maillog //与邮件相关的日志信息 tail /var/log/cron //与定时任务相关的日志信息 tail /var/log/dmesg //和系统启动相关 tail /var/log/audit/audit.log //系统审计日志 tail /var/log/yum.log //yum tail /var/log/xferlog //和访问FTP服务器相关 tail /var/log/wtmp //当前登录的用户（命令：w） tail /var/log/btmp //最近登录的用户（命令last） tail /var/log/lastlog //所有用户的登录情况（命令lastlog ） tail /var/log/boot.log //守护进程启动和停止相关的日志消息 tail /var/log/spooler //与UUCP和news设备相关的日志信息 #清理日志文件 cat /dev/null &gt; /var/log/boot.log cat /dev/null &gt; /var/log/btmp cat /dev/null &gt; /var/log/cron cat /dev/null &gt; /var/log/dmesg cat /dev/null &gt; /var/log/firewalld cat /dev/null &gt; /var/log/grubby cat /dev/null &gt; /var/log/lastlog cat /dev/null &gt; /var/log/mail.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2927b0fa5c3c817d27ceecfd1b6001d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea478f197c499300adbb3ab0c4e94022/" rel="bookmark">
			SpringBoot&#43;Vue&#43;Element-UI实现协同过滤算法商品推荐系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql 5.7/8.0
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
浏览器：谷歌浏览器
前言介绍 本次设计任务是要设计一个基于协同过滤算法的商品推荐系统，通过这个系统能够满足商品推荐系统的管理功能。系统的主要包括首页，个人中心，用户管理，商品类型管理，商品信息管理，系统管理，订单管理等功能。
管理员可以根据系统给定的账号进行登录，登录后可以进入商品推荐系统对个性化智能商品推荐所有模块进行管理。包括查看和修改自己的个人信息以及登录密码。
该系统为每一个用户都分配了一个用户账号，用户通过账号的登录可以在系统中查看个性化智能商品推荐信息及对个人信息进行修改等功能。
性能需求分析 对系统的性能，从（功能、运行、界面、安全）等方面进行，下面我们逐一进行分析；
1. 系统的功能是否完整进行分析：系统的功能，能对应设计出原始代码和算法，以表格同文字的形式进行详细介绍个人信息保证功能完整。
2. 系统的运行是否通畅进行分析：系统的每个功能都有编写数据的关系和应对的代码，通过需求分析和可行性分析进行分析和显示系统的物理数据，保证其进行通畅。
3. 系统的界面设计进行分析：对系统中的软件进行处理与分析的方式是由不同代码来进行的；从而使界面容易操作。
4. 系统的安全性进行分析：这样才可以每个角色的不同对应的信息也就不同，在登录系统务必使用自己的账号，密码登录，账号与密码错误自然就登录失败了。登录成功可以对自己的信息进行操作，不能对别人的账号的信息进行查看等操作，这样自然保证系统的安全性。
协同过滤算法简介 协同过滤算法是一种较为著名和常用的推荐算法，它基于对用户历史行为数据的挖掘发现用户的喜好偏向，并预测用户可能喜好的产品进行推荐。也就是常见的“猜你喜欢”，和“购买了该商品的人也喜欢”等功能。它的主要实现由：
（1）根据和你有共同喜好的人给你推荐
（2）根据你喜欢的物品给你推荐相似物品
（3）根据以上条件综合推荐
（4）因此可以得出常用的协同过滤算法分为两种，基于用户的协同过滤算法(user-based collaboratIve filtering)，以及基于物品的协同过滤算法(item-based collaborative filtering)。特点可以概括为“人以类聚，物以群分”，并据此进行预测和推荐。
系统展示 前台页面 商品信息推荐 商品推荐是使用协同算法根据用户购买商品进行推荐
商品信息 商品资讯 购物车 管理员页面 用户管理 商品类型管理 商品信息管理 部分核心代码 商品类型 /** * 商品类型 * 后端接口 * @author * @email * @date 2022-04-17 14:24:14 */ @RestController @RequestMapping("/shangpinleixing") public class ShangpinleixingController { @Autowired private ShangpinleixingService shangpinleixingService; /** * 后端列表 */ @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea478f197c499300adbb3ab0c4e94022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b751ddb3c9f483f1d6fac392438bbabf/" rel="bookmark">
			Flannel host-gw 和 vxlan
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Overview Flannel 是 LCK 默认采用的网络插件方案，默认条件下 LCK 使用的是 vxlan 的模式，私有化场景下，如果确定客户的主机都在一个子网内，可以使用 host-gw 模式提高网络性能
安装 Flannel 的安装逻辑如下，通过安装的 yaml 文件里有两个 initContainer，专门就是用来做 CNI 和 Flannel 配置的安装，所以命名也是叫 install-cni-plugin 以及 install-cni
那么这两个容器主要是怎么安装的呢，其实很简单，可以看看 args 字段，实际上就是把 flannel 的二进制，以及 cni-conf.json 和 10-flannel.conflist 通过 cp 复制到指定的目录
initContainers: - name: install-cni-plugin #image: flannelcni/flannel-cni-plugin:v1.1.0 for ppc64le and mips64le (dockerhub limitations may apply) image: rancher/mirrored-flannelcni-flannel-cni-plugin:v1.1.0 command: - cp args: - -f - /flannel - /opt/cni/bin/flannel volumeMounts: - name: cni-plugin mountPath: /opt/cni/bin - name: install-cni #image: flannelcni/flannel:v0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b751ddb3c9f483f1d6fac392438bbabf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5498e9b1a3826b8eb868bf724e9eb571/" rel="bookmark">
			ue5 小知识点 actor和actor之间的嵌套
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		actor 包含两种component
一种是scene component 这种是带transform的 是能在场景中渲染的，同时很重要的是 能嵌套的
第二种是普通的actor component 这种不带transform 在actor中是平级的
actor和actor的嵌套
UE里是通过Child:AttachToActor或Child:AttachToComponent来创建父子连接的
内部还是 scene component的嵌套
所以actor之间没有直接的addactor等操作 而是变相的通过scene component的层级结构来确定actor之间的层级结构。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e92ae68363901725b01814c2b9f0edd2/" rel="bookmark">
			ImportError: cannot import name ‘MethodViewType‘ from ‘flask.views‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现这样的问题是因为Flask自2.2.x版本之后删除了flask/views/MethodViewType方法,所以需要我们将flask版本回滚到2.1.x版本或更早版本
解决方案:
pip uninstall flask pip install flask==2.1.3 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c777d665aab9332cb65e435d59807f79/" rel="bookmark">
			WPA-Supplicant 极简交叉编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一： Could not connect to wpa_supplicant - re-trying 答： 1、wpa_supplicant 需要首先启动 （不需要关注是否能够连上设备） 举例：wpa_supplicant -Dnl8021 -iwlan0 -c /etc/wpa_supplicant.conf 2、确认 /var/run/wpa_supplicant/wlan0 权限是不是 root:root 3、这时候就可以进行测试了 问题二： WPA: 4-Way Handshake failed - pre-shared key may be incorrect 可以通过以下几点逐一排查 1、密码是否正确 2、确认芯片底层是否支持对应协议，（一些老芯片仅能支持 WPA/WPA2 但不支持 WPA2-PSK 等协议） 3、对接路由器的协议以及信号类型，（老芯片不支持 5G 信号仅能支持 2.4G 信号） 4、最后根据 wpa_supplicant 自带的 example 尝试调整各个参数（下载后直接看） 注意: 交叉编译内容应该与交叉编译器时间相近 下载以下内容： expat-2.4.8 dbus-1.14.0 libnl-3.7.0 openssl-1.1.1 wpa_supplicant 逐一编译以下内容：
## expat-2.4.8 # 编译脚本, 放到文件夹内 echo "xorg_cv_malloc0_returns_null=yes" &gt; arm-linux.cache ./configure --cache-file=arm-linux.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c777d665aab9332cb65e435d59807f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd66c69f7f42b06870244c75b009607d/" rel="bookmark">
			cdn实战-七牛云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本理论 假设我有一个网站wp.tangwx.site,我使用nginx做反向代理。核心配置如下：
upstream cloudreve { server 127.0.0.1:5212; } server { listen 80; listen [::]:80; listen 443 ssl; ssl_certificate /usr/local/nginx/conf/ssl2/cert.pem; ssl_certificate_key /usr/local/nginx/conf/ssl2/key.pem; server_name wp.tangwx.site; index index.html index.htm index.php; root /data/wwwroot/wp.tangwx.site; if ($scheme = http ) { return 301 https://$host$request_uri; } location / { proxy_set_header HOST $host; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_redirect off; proxy_pass http://cloudreve; client_max_body_size 2000m; } location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ { proxy_pass http://cloudreve; expires 30d; access_log off; } location ~ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd66c69f7f42b06870244c75b009607d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6031391cbe49ace621146bb5ded1d587/" rel="bookmark">
			EChart如何实现中国地图和省份下钻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于项目需要，做一个地图相关的需求研究了一波，分享出来，希望对大家有所帮助
效果图如下：
代码如下：
前台jsp代码
&lt;%@ page language="java" contentType="text/html; charset=utf-8"%&gt; &lt;%@ page import="java.util.List"%&gt; &lt;%@ page import="java.util.Map"%&gt; &lt;% String path = request.getContextPath(); String orgkey = request.getParameter("orgkey"); path+="/dealmap?f="+System.currentTimeMillis()+"&amp;orgkey="+orgkey; %&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta name="description" content="ECharts"&gt; &lt;title&gt;ECharts · Example&lt;/title&gt; &lt;script type="text/javascript" src="webos/js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="webos/js/echarts.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="chart" class="chart" style="height: 530px;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; //散点相关信息 var fenCompany = [{"cp":[120.756939,31.645717],"name":"常熟分公司"}, {"cp":[121.126012,31.454056],"name":"太仓分公司"}, {"cp":[120.651997,31.168648],"name":"吴江分公司"}, {"cp":[120.98034,31.389019],"name":"昆山分公司"}, {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6031391cbe49ace621146bb5ded1d587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e900343d99ce5b529110d853ae7e46/" rel="bookmark">
			超详细的介绍 get 和 post 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 比较详细的讨论一下get和post的区别：
● 关于浏览器回退
get请求浏览器回退是无害的，具体指：get请求url资源会被浏览器缓存，回退时则会从缓存中获取该url的资源，而不会发起新的请求。
post请求浏览器回退时会重新发起请求，创建新的资源。
术语上说：get请求是幂等的，post请求是非幂等的。
如何理解幂等呢，我的理解就是：对于同一种行为，无论执行多少次，它返回的结果都是与第一次没有差异。
值得注意的是：幂等性指的是作用于结果本身，而并非资源是否相同，可能某个方法可能每次会得到不同的返回内容，但并不影响结果，这样的也满足幂等性，例如get服务器当前时间。
由于get后续请求都是从浏览器缓存中获取，后续请求结果都与第一次相同，所以它是幂等的。
而非幂等，则是返回的结果与执行次数有关，每次执行返回不同的结果，最简单的例子就是累加操作。
由于前面说到，post请求每次都会创建新的资源（结果不同了），所以它是非幂等的。
● 关于浏览器对url资源的处理
前面也说到了，get请求url地址会被浏览器主动缓存，而post不会（除非手动设置）
● get 请求的url地址可以被bookmark（存为书签），而post产生的url地址不可以保存为书签，同时get请求的url地址会被存入浏览器历史记录中，而post请求则不会。
● 关于参数长度不同的解释，这里我以前也是认为get参数是有长度限制的，post的参数则不限制长度。实际上，通过查阅相关文章，我发现：
Http的get请求方法提交的数据大小长度并没有限制，Http协议规范没有对URL长度进行限制。目前说的get长度有限制，是特定的浏览器及服务器对它的限制。
理论上讲，post是没有大小限制的。Http协议规范也没有进行大小限制，起限制作用的是服务器处理程序的处理能力。
● 安全性
get请求参数会暴露在url中进行传输，而post请求参数是放在Request Body中，相对来说比get安全。
● get请求只支持url编码，而post支持多种编码方式。
● 针对数据的操作不同
get主要是用来读取数据，而post主要对数据进行增删改。
● get比较常见的是通过url发起请求，而post的较为常见的是通过表单发起请求。
● get请求产生1个TCP数据包，post请求产生2个TCP数据包。
对于get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
相当于post会向服务器发送一次预检请求，服务器会返回一些信息，通过这些信息可以判断该请求是否应该被发起。
因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？
GET与POST都有自己的语义，不能随便混用。据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41a573b4ed3f75b45c4b7822b8dacb97/" rel="bookmark">
			MyBatis学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 MyBatis简介什么是 MyBatis？如何获得MyBatis？持久化持久层MyBatis特点 第一个MyBatis程序1、搭建环境2、创建一个模块3、编写代码3、测试 CRUD1、namespace2、select3、insert4、update5、delete6、Map(了解) 配置解析1、核心配置文件2、环境配置（environments）3、属性（properties）4、类型别名（typeAliases）5、设置（settings）6、映射器（mapper）7、其他配置作用域（Scope）和生命周期 解决属性名和字段名不一致的问题resultMap(结果映射) 日志日志工厂LOG4J 分页Limit分页RowBounds分页分页插件（了解） 使用注解开发注解增删改查（CRUD） Mybatis执行流程Lombok（了解）多对一处理测试环境搭建（回顾之间知识）按照查询嵌套处理按照结果嵌套处理测试 一对多处理测试环境搭建按照查询嵌套处理按照结果嵌套处理测试一对多，多对一小结和注意点 面试高频MySQL引擎、INNODB底层原理、索引、索引优化（查文章看一下） 动态SQL环境搭建IFchoose(when，otherwise)trim(where，set)SQL片段Foreach 缓存简介Mybatis缓存一级缓存二级缓存Mybatis缓存原理自定义缓存-ehcache 完结 MyBatis 简介 什么是 MyBatis？ MyBatis 是一款优秀的持久层框架它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 如何获得MyBatis？ maven仓库 &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; Github：https://github.com/mybatis/mybatis-3中文文档：https://mybatis.org/mybatis-3/zh/index.html 持久化 数据持久化
持久化就是将程序的数据在持久状态和瞬间状态转化的过程内存：断电即失数据库（JDBC）:io文件持久化 持久层 Dao层，Service层，Controller层…
完成持久化工作的代码块层界限十分明显的的 MyBatis特点 解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离。sql和代码的分离，提高了可维护性。提供映射标签，支持对象与数据库的orm字段关系映射提供对象关系映射标签，支持对象关系组建维护提供xml标签，支持编写动态sql。 第一个MyBatis程序 1、搭建环境 搭建数据库
CREATE DATABASE `mybatis`; USE `mybatis`; CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL )ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `user`(`id`,`name`,`pwd`) VALUES(1,'刚龙','123456'),(2,'倩倩','123456'),(3,'肖总','123456') 新建项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41a573b4ed3f75b45c4b7822b8dacb97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38008dd81c2f4d7985ecf6e0ce8af1d1/" rel="bookmark">
			Spring
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Spring5IOC理论推导IOCIOC创建对象的方式Spring配置说明别名aliasBean的配置import 依赖注入构造器注入Set方式注入 ***拓展方式注入Bean的作用域 Bean的自动装配xml中显示的装配隐式的自动装配bean ***byName自动装配byType自动装配 注解实现自动装配@Autowired注解@Resource注解 Spring注解开发Java配置Spring代理模式静态代理模式动态代理模式 AOP(面向切面编程)AOP在Spring中的作用Spring实现AOP**方式一:使用原生Spring API接口****方式二:自定义实现AOP【主要是切面定义】****方式三：使用注解实现AOP** 整合Mybatis回顾MybatisMybatis-Spring 一Mybatis-Spring 二 声明事务回顾事务spring中的事务管理 完结 Spring5 Spring是一个开源的免费的框架（容器）Spring是一个轻量级的、非入侵式的框架控制反转（IOC），面向切面编程（AOP）支持事务的处理，对框架整合的支持 Spring是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架
IOC理论推导 传统方式：
UserDao接口 package com.sgl.dao; public interface UserDao { void getUser(); } UserDaoImpl、UserMysqlImpl、UserOracleImpl实现类 package com.sgl.dao; public class UserDaoImpl implements UserDao{ @Override public void getUser() { System.out.println("默认获取用户数据"); } } package com.sgl.dao; public class UserMysqlImpl implements UserDao{ @Override public void getUser() { System.out.println("Mysql获取用户数据"); } } package com.sgl.dao; public class UserOracleImpl implements UserDao{ @Override public void getUser() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38008dd81c2f4d7985ecf6e0ce8af1d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908cbe95e865e5b8d63e3dfdb40155a5/" rel="bookmark">
			语音信号的倒谱分析及其应用案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		根据对语音产生的机理的研究可知，语音信号x（n）可看作是声门激励信号x1（n）和声道冲激响应信号x2（n）的卷积，即 为了便于处理各卷积信号，系统通常采用同态处理的方法进行解卷积，即将卷积关系变为求和关系，分离参与卷积的各个信号。一般同态系统可分解为三个部分，如图所示。
如图所示，系统包含两个特征子系统（取决于信号的组合规则）和一个线性子系统（取决于处理的要求）。图中，符号*、+和 · 分别表示卷积、加法和乘法运算。第一个子系统完成将卷积性信号转化为加性信号的运算，即对于信号x（n）=x1（n）*x2（n）进行如下运算处理：
第二个子系统是一个普通线性系统，满足线性叠加原理，用于对加性信号进行线性变换。由于为加性信号，所以第二个子系统可对其进行需要的线性处理得到。
第三个子系统是逆特征系统，它对进行逆变换，使其恢复为卷积性信号，处理如下：
由此可知，通过第一个子系统，可以将x（n）=x1（n）*x2（n）变换为。此时，如果与处于不同的位置并且互不交替，那么适当地设计线性系统，便可将x1（n）与x2（n）分离开来。
在和系统中，和信号也是时域序列，但是它们与x（n）和y（n）所处的
离散时域不同，称为复倒频谱域。是x（n）的复倒频谱域，简称复倒谱。其表达式如下：
MATLAB工具箱为倒谱计算提供了三个函数：
1）cceps函数——计算复倒谱
调用格式：
[xhat,nd]=cceps(x)
说明：x是被测信号序列；xhat是实信号序列x的复倒谱；nd是为了保证频率m处具有
零相位特性而对信号x所做的单位圆延迟。
2）rceps函数——计算实倒谱
调用格式：
[xh,yh]=rceps(x)
说明：x是被测信号序列；xh是实信号序列x的实倒谱；yh是最小相位重构序列。
3）icceps函数——计算逆复倒谱
调用格式：
xh =icceps(xhat,nd)
说明：xh是复倒谱xhat的逆变换；nd为所要去除的时间延迟。
案例、从sul.txt中读入语音数据，信号的采样频率为16000Hz，计算信号的倒谱，并从中把语音的声门激励信号和声道冲激响应分离，分别得到声门激励信号的频谱和声道冲激响应的频谱。
程序如下：
clear all; clc; close all; y=load('su1.txt'); % 读入数据 fs=16000; nfft=1024; % 采样频率和FFT的长度 time=(0:nfft-1)/fs; % 时间刻度 figure(1), subplot 211; plot(time,y,'k'); % 画出信号波形 title('信号波形'); axis([0 max(time) -0.7 0.7]); ylabel('幅值'); xlabel(['时间/s' 10 '(a)']); grid; figure(2) nn=1:nfft/2; ff=(nn-1)*fs/nfft; % 计算频率刻度 Y=log(abs(fft(y))); % 按式(3-1-8)取实数部分 subplot 211; plot(ff,Y(nn),'k'); hold on; % 画出信号的频谱图 z=ifft(Y); % 按式(3-1-8)求取倒谱 figure(1), subplot 212; plot(time,z,'k'); % 画出倒谱图 title('信号倒谱图'); axis([0 time(512) -0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/908cbe95e865e5b8d63e3dfdb40155a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dc16b338bfbaa1ef38289bf69350f63/" rel="bookmark">
			js两个数组对象去重，删除两个数组中相同的对象、删除数组对象中某个对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模拟一些数据： let arr1 = [ {id:1,name'小明',age:18}, {id:2,name'小红',age:16}, {id:4,name'小紫',age:22}, {id:5,name'小绿',age:20}, ] let arr2 =[ {id:2,sex:女}, {id:5,sex:男}, ] 方式一：两个数组通过arr1的id和arr2的id比较，返回去重后的arr1 //函数封装 resArr(arr1, arr2) { return arr1.filter((v) =&gt; arr2.every((val) =&gt; val.id!= v.id)); }, //调用 let newArr= this.resArr(arr1,arr2) console.log(newArr); 写法二 let newArr= arr1.filter((v) =&gt; arr2.every((val) =&gt; val.id != v.id) ) 打印的结果：console.log(newArr); [ {id:1,name'小明',age:18}, {id:3,name'小红',age:16}, {id:4,name'小紫',age:22}, ] 方式二：删除两个数组对象中相同的对象
let getId = arr2.map(item=&gt;item.id) console.log(set) let newArr = arr1.filter(item=&gt;!getId.includes(item.id)) console.log(newArr) 方式三：es6 去掉两个数组中相同值的对象 let newArr = arr1.filter((item) =&gt; !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6dc16b338bfbaa1ef38289bf69350f63/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/238/">«</a>
	<span class="pagination__item pagination__item--current">239/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/240/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>