<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c405b25d36572db52da7b958e76fb8/" rel="bookmark">
			GhostNet解析以及Tensorflow2中实现Ghost模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GhostNet解析以及Tensorflow2中实现Ghost模块 笔者从事嵌入式图像开发相关工作，希望能在ZYNQ上实现目标检测任务，故把更多的注意力放在轻量级网络上。
现阶段较为流行的轻量级网络有：MobileNetv1,v2,v3,ShuffleNet，EfficientNet和本文介绍的GhostNet。可能因为GhostNet是华为的成就或单纯的喜欢“Ghost"这个名字，笔者首先介绍GhostNet,其余网络结构将在后续文章中介绍。
GhostNet源于华为诺亚方舟实验室，可在同样的精度下，速度和计算量都小于SOTA算法。
该论文提供了一个全新的Ghost模块，旨在通过廉价操作生成更多的特征图。基于一组原始的特征图，作者应用一系列线性变换，以很小的代价生成许多能从原始特征发掘所需信息的“幻影”特征图（Ghost feature maps）。该Ghost模块即插即用，通过堆叠Ghost模块得出Ghost bottleneck，进而搭建轻量级神经网络——GhostNet。在ImageNet分类任务，GhostNet在相似计算量情况下Top-1正确率达75.7%，高于MobileNetV3的75.2%。
笔者更注重算法的实现部分，因此和之前博文一样，原理部分不做详细解释，如有需要可参考（https://zhuanlan.zhihu.com/p/109325275）
GhostNet_tensorflow2.0+实现源码参考：https://blog.csdn.net/qq_36758914/article/details/107511908
GhostNet核心思想： 首先，从全局的角度看一下GhostNet的模型结构：
注：exp表示扩展的尺寸，out表示输出的维度，SE表示使用SE模块，Stride表示步长。
可以看到，整个网络结构用了大量的G-bneck模块。在G-bneck模块中使用了SE模块。
Ghost Module是整个网络的核心，也是论文的精髓。接下来简单介绍下Ghost Module 的原理。
论文中使用上图来向大家介绍，相同颜色的框可以通过线性变换得到。基于这个理论，作者提出：将用于获得这张特征图的卷积核数量减少一半（则得到的特征图的通道数会减少一半），然后将得到的特征图进行线性运算（在下图中用扳手表示），得到缺少的另一半特征图，最后将这两部分特征图合并，得到和原来特征图相同的尺寸。如下图所示：
可以这样理解这个算法，使用正常的卷积生成原有特征层的一半，再对得到的这些特征层进行线性运算，类似（WX+b)，只不过这里我们用的是卷积来实现线性运算，最后得出与原有特种层一样的特征层个数。这样子操作的好处可以大大降低速度和参数量。
使用Ghost模块升级普陀卷积的理论加速比为：
同样，理论压缩比可以计算为
Ghost模块实现： Ghost模块中包含了SE模块，因此在介绍Ghost模块之前先介绍SE模块相关知识。第一次接触到SE模块是在MobileNet中，个人对SE模块的理解是通过池化，线性操作获取每个网络特征层的权重，然后根据权重将特征层进行重现排布。如下图所示：
增加特征权重后等同于增加注意注意力机制，且消耗参数与运算力均可以接收。SE代码如下：
class SEModule(Layer): def __init__(self, filters, ratio): super(SEModule, self).__init__() self.pooling = GlobalAveragePooling2D() self.conv1 = Conv2D(int(filters / ratio), (1, 1), strides=(1, 1), padding='same', use_bias=False, activation='relu') self.conv2 = Conv2D(int(filters), (1, 1), strides=(1, 1), padding='same', use_bias=False, activation=None) self.relu = Activation('relu') self.hard_sigmoid = Activation('hard_sigmoid') def call(self, inputs): x = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53c405b25d36572db52da7b958e76fb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a1d6c8882e48b49bdb44b5197e78ea/" rel="bookmark">
			第二讲 JavaScript概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列课程目录 第二讲 JavaScript概述
目录 系列课程目录前言一、介绍1.什么是JavaScript2.JavaScript能做什么3.JavaScript发展历程3.网页的解析原理4.JavaScript的组成 二、JavaScript的基本使用内嵌式外联式行内JS输入/输出语句转义字符JavaScript的调试 三、课堂作业1.按照要求完成任务2.解析代码 总结 前言 JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。 提示：以下是本篇文章正文内容，下面案例可供参考
一、介绍 1.什么是JavaScript JavaScript是一门客户端脚本语言
运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎
脚本语言：不需要编译，直接就可以被浏览器解析执行
2.JavaScript能做什么 客户端表单验证
动态效果
改变页面内容
3.JavaScript发展历程 如下（示例）：
3.网页的解析原理 如下（示例）：
HTML：结构
决定网页的结构和内容（是什么）
CSS：样式
决定网页的表现样式（什么样子）
JS：行为
决定网页的行为（做什么）
4.JavaScript的组成 如下（示例）：
ECMAScript 语法
变量；数据类型；关键字；保留字；运算符；逻辑控制语句；对象等；
BOM
通过BOM操作浏览器，如移动、缩放、关闭窗口；打开新窗口；页面跳转等；
DOM
通过DOM操作HTML文档，如读取、修改页面内容等；
二、JavaScript的基本使用 内嵌式 将JS代码写在&lt; script &gt;标签内，&lt; script &gt;标签可放置于任何位置
下面展示一些 内联代码片。
&lt;script type="text/javascript"&gt; alert(‘hello world!’) //alert()方法为弹出一个警告对话框 &lt;/script&gt; 外联式 将JS代码写入外部JS文件中，通过
&lt;script src="./index.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt; 行内JS 直接将代码写在HTML元素内，该方法问题较多，不推荐使用
&lt;button type="button" onclick="javascript:alert('hello world!')"&gt;click me&lt;/button&gt; 输入/输出语句 如下（示例）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4a1d6c8882e48b49bdb44b5197e78ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1123e0db15874df14224a0bb816a3f4/" rel="bookmark">
			电荷泵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电荷泵，又称为电容式的开关稳压器，或开关电容DC-DC变换器，无感式DC-DC变换器
电荷泵采用电容作为开关和储能的元件
如图所示，S1与S3闭合，S2与S4断开，则Vin给电容充电，而后S1与S3断开，S2与S4闭合，则电容放电，此时Vout=Vin，此时C成为飞跨电容
如图所示，S1与S3闭合，S2与S4断开，C1电容被充电，其电荷为上正下负，而后S1与S3断开，S2与S4闭合，则电容放电，此时C1上的电压没有变，C2的正端电位被定在GND，此时Vout=-Vin
此时为反压型电荷泵
如上图所示，左边当S1与S3闭合，S2与S4断开，C1电容被充电，其电荷为上正下负，而后S1与S3断开，S2与S4闭合，则电容放电，此时C1上的电压没有变，C2与C1串联放电，即Vout=2Vin
如上图右半边所示（画错了，Vin和Vout的位置对调一下），左边当S1与S3闭合，S2与S4断开，C1与C2电容被充电，其电荷为上正下负，充电完毕每个电容上都有一半的Vin，放电时两个电容并联，将1/2的Vin送入Vout
注意：
1. 电荷泵的效率高于LDO，低于电感开关电源
2. 是用于整数倍的升压或降压
3. 由于电荷泵电容（外部电容）经常要倒换极性，因此优选陶瓷电容，不能选择电解电容（有极性的电容）
4. 优选ESR低的电容
5. 电荷泵电容（飞跨电容）容量越大，则其能够提供电流的能力越强
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0626b7208a1acbd9b27f4750e297311b/" rel="bookmark">
			HTML-CSS小知识——box-shadow的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML-CSS小知识——box-shadow的使用 属性基本属性的使用附加说明 属性 box-shadow是给盒子添加阴影效果。
box-shadow: h-shadow v-shadow blur spread color inset; 基本属性的使用 h-shadow：必填，作用为水平阴影，可为负值
v-shadow：必填，作用为垂直阴影，可为负值 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div{ width: 300px; height: 300px; background-color: red; border: 10px solid green; margin: 60px auto; box-shadow: 20px 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; box-shadow:20px 100px; 这时box-shadow只填两个必填值，效果如下
当h-shadow为负值时，就是向左移动阴影，相应的v-shadow为负值就向上移动阴影
box-shadow:-20px 100px; blur为模糊距离，就是把阴影边缘进行模糊化。当填入三个数值时，第三个值就为blur
box-shadow: h-shadow v-shadow blur
box-shadow:50px 100px 10px; spread将阴影向外延申，相当于给已有的阴影增加边框（用边框较容易理解）。这时box-shadow已填入四个数值，那第四个数值就是spread。 box-shadow:50px 100px 10px 40px; 为了更好地体现边框的理解，可以把前三个数值设置为0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0626b7208a1acbd9b27f4750e297311b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6c4fb9472fa15cb744420cfbd81a13a/" rel="bookmark">
			社区贡献者&#43;1，大四毕业生开源跨平台TDengine图形化管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们团队做智能电表项目时，选用了基于 TDengine 的数据存储方案，开发过程中发现，如果没有图形化管理工具，查看数据不太方便，于是内部开发了 TDengineGUI，用来数据管理。追随 TDengine 团队彻底开源的理念，现将这个小工具开源出来，方便大家开发使用。
TDengineGUI 简介 TDengineGUI 是一个基于 electron 构建的，针对 TDengine 开发的图形化管理工具。具有跨平台、易于使用、版本适应性强等特点。
获取方式 下载最新版可执行文件 GitHub：https://github.com/skye0207/TDengineGUI/releases/tag/v1.0.0
码云：https://gitee.com/skyebaobao/TDengineGUI/releases/v1.0.0
当前版本功能 通过 TDengine RESTful 接口连接到数据库，使用基本不受服务器版本升级影响
数据库添加删除操作，显示数据库属性
显示数据库中超级表和表信息，删除超级表与表功能
显示超级表和表数据功能，提供分页、时间段检索、字段过滤、排序等功能
通过源代码运行开发版本 1. 克隆项目 :
git clone https://github.com/skye0207/TDengineGUI.git 如果 GitHub 下载慢，可以下载码云上的同步更新版本 ：
git clone https://gitee.com/skyebaobao/TDengineGUI.git 2. 安装依赖 :
npm install 3. 启动开发版本 :
npm run start 4. 生成桌面应用 :
npm run build //安装包和可执行文件，生成在dist文件夹下 原文首发于：https://mp.weixin.qq.com/s/s8VHp_fIkHLtXZejPyv5OA
使用说明 打开软件后，界面左侧会显示需要管理的数据库服务器列表和服务器中数据库列表，同时显示数据库服务器的版本号。
图为新建连接和数据库选择页面
可以通过“新建连接”按钮，添加新的服务器进行管理。需要提供数据库服务器的 IP 地址、RESTful服务的端口号（默认为6041）、连接服务器的用户名和密码（默认为root:taosdata）
图为新建连接表单
可以通过点击添加数据库图标，进行添加数据库操作。可以在添加时选择数据库属性（具体属性含义请参考TDengine官方文档）
图为添加数据库表单
可以通过点击服务器连接后的删除图标，进行删除数据库连接操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6c4fb9472fa15cb744420cfbd81a13a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb7c5090d555ce28f35090f2a4103c46/" rel="bookmark">
			泊松公式推导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泊松分布是二项式分布的一种极限情况，一般用于时间或者面积这种可以无限细分的抽象概念。
问题引入 在一段时间T里面期望发生n次事件a，求在时间段T发生k次事件a的概率。（这里的期望指的是数学期望，就是n重伯努利试验中事件发生的概率乘以n）
推导过程 1.假设时间T是一个线，事件a发生在线T上的某一个点上，不妨先把点看成是一跟无限短的线。 2.将T进行n等分均分，并保证每等分的情况∈{发生一次，没有发生}。 这就将题目变成了一个二项分布的问题（二项等概率事件在n次实验下发生k次的概率问题），。
3.根据2就可以得出如下公式。 n就是区间的个数，但是由于题目讨论的是线上的点，所以可以让n趋向于无穷大，那区间足够小就可以视作一个点。p就是a发生在区间上的概率。
4.接着3继续分析，可以得到两个公式。 点的概率公式：
λ=np，即事件发生的数学期望。
时间段T内发生k次事件的概率：
第一个公式是该点发生事件a的概率公式，k(事件期望发生次数)除以n（实验次数），得到了事件a在该点发生的概率。第二个公式是利用二项分布公式的极限情况，算出的概率。
5.然后开始化简第二个公式。 根据化简后的公式，只需要知道λ，就可以很容易的求出在k为任意数的概率，相比于二项分布公式，大大简化了计算，解的误差也很小。
总结： 泊松分布用于解决可以无限细分的问题，或者是采用二项分布计算过于麻烦且精度要求没那么高的场合，总的思路就是将事件无限细分，让每个细分区间都可能发生两种情况，然后利用二项分布公式求的近似解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6473bebee8e7495e9ad2f208e71ff39/" rel="bookmark">
			推荐几个靠谱的技术公众号！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人生就是一个磨练的过程，在阳光下灿烂，风雨中奔跑，泪水中成长，拼搏中展望。
今天我来推荐几个靠谱的技术公众号，祝愿大家新的一年里技术突飞猛进！
阿枫科技 科技如果有颜色，那么一定是黑色...
Python爱好者社区 人生苦短，我用Python。分享Python相关的技术文章、工具资源、精选课程、视频教程、热点资讯、学习资料等。每天自动更新和推送。
良许Linux 良许，自学转行IT，现为世界500强Linux开发工程师。公众号分享大量Linux干货，包括Linux基础、Linux应用、Linux工具软件、Linux资讯，以及git、数据库、树莓派等方面技术知识。
（后台回复1024免费赠送资源）
程序员八卦 程序员八卦！有深度、有温度、有态度，在这里读懂程序员！改变世界的往往是那些默默无闻的程序员！
Python头条 为你提供最纯粹的Python技术文章阅读体验。
GitHub指南 GitHub源码学习指南，分享既有趣又干货，还能直接拿来做项目的开源项目！涵盖：Java、Python、Web、AI、前端、大数据、数据分析等多个技术领域的优质学习资源。欢迎关注！
编程指北 编程学习之路的好帮手、指南针~
涛哥聊Python 本公众号主要关注Python技术，数据分析，AI，包括但不限于Python，docker容器化等后端技术，定期分享技术资料，奖品礼物。回复「Python」获取资料包一份。
小林coding 时而图解技术，时而拍拍猫片，时而说说杂事
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/214e27424518983216ff7ee9fb6ce630/" rel="bookmark">
			exfat默认配置大小_U盘exFAT格式分配单元大小选多少合适?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		U盘一般有三种常见的格式：FAT32，NTFS和exFAT。
现在超过4GB的U盘格式化时默认是NTFS分区，但是这种格式是很伤U盘的，因为NTFS分区是采用“日志式”的文件系统，需要记录详细的读写操作，肯定会比较伤闪盘芯片，因为要不断读写。
如果你要存大的文件的话建议用exFAT
---------------------------------------------------------------------
首先来说U盘的默认格式化的方式都是FAT32的，或者可以使用exFAT的格式，exFAT是比较新的一种专门针对移动存储设备的格式化格式，支持单个大于4GB的文件的操作，对于分配单元大小可以简单的说分配的单元的数值越大读写越快，但是存储空间会浪费。
这里先解释一下“分配单元大小”的含义。所谓分配单元大小，即是系统对磁盘以及移动存储设备进行读写的最小单位。在极限速度以内，分配单元大小越大读写速度越快，反之则越慢。但是这里要注意一个问题，单元分配越大越会造成空间的浪费，这就好比你拿许多同样大小的正方形纸片要将一个形状完全覆盖，纸片的面积越大越省事，但是相比于较小的纸片，边缘会有更多的无用面积，磁盘分配单元也是同样的道理。
格式化的时候的选择方式建议使用默认数值，系统会为你调节到最匹配的默认数值，无需手动管理，之后选择快速格式化后就立即生效了。
最常用的FAT32
最新的的U盘分区格式，最大支持最大支持16EB的文件。1EB=1024TB，1TB=1024GBexFAT是专门为闪存类设备开发的方案。
取消
评论
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b107640dbc48a814dea9fa01f53b294/" rel="bookmark">
			Maven的安装与配置(eclipse和idea)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Maven的安装与配置 一、安装本地Maven二、在Eclipse上安装maven三、在idea上安装maven补充 一、安装本地Maven 下载地址maven官网，下载最新版本即可
博主准备了3.5.2和3.6.3两个版本的资源包，点击即可下载
选择第二个二进制zip存档下载
Maven 下载后，将 Maven 解压到一个没有中文没有空格的路径下，比如 D:\work\maven\apache-maven-3.5.2 下面。
解压后目录结构如下：
--&gt; bin:存放了 maven 的命令，比如我们前面用到的 mvn tomcat:run
--&gt; boot:存放了一些 maven 本身的引导程序，如类加载器等
--&gt; conf:存放了 maven 的一些配置文件，如 setting.xml 文件
--&gt; lib:存放了 maven 本身运行所需的一些 jar 包
然后配置maven环境变量,如图
系统变量:MAVEN_HOME = D:\work\maven\apache-maven-3.5.2
系统变量:path = %MAVEN_HOME%\bin;注意末尾的 “ ; ”
然后win+R 运行cmd 输入 mvn -version，如图所示则配置成功
二、配置settings文件
1.在conf目录下可以找到settings.xml文件，配置本地仓库位置（maven 的安装目录下），打开 settings.xml文件，配置如下：maven仓库自己随便建立一个文件夹就好了，如：maven_repository就是博主建的
将地址配置成你们本地仓库的位置，博主的本地仓库位置如下：
&lt;localRepository&gt;D:\work\maven\maven_repository&lt;/localRepository&gt; 2. 配置jar下载镜像(因为国外的服务器下载jar包很慢)，找到 &lt; mirrors&gt; &lt; /mirrors&gt;，在中间加上代码
&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 以上maven的基本配置就已经完成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b107640dbc48a814dea9fa01f53b294/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa89f98bbee5a6a00f72720f751eef30/" rel="bookmark">
			C# List集合中获取重复值及集合运算详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要介绍了C# List集合中获取重复值及集合运算详解，具有很好的参考价值，希望对大家有所帮助。一起跟随小编过来看看吧
话不多说，直接上实例：
一、获取集合内重复值
public void GetDuplicateValue() { List&lt;string&gt; lisA = new List&lt;string&gt; { "A", "B", "C", "A" }; //方式一 借助字典 Dictionary&lt;string, int&gt; dic = new Dictionary&lt;string, int&gt;(); lisA.ForEach(x =&gt; { if (dic.ContainsKey(x)) dic[x] += 1; else dic[x] = 0; }); List&lt;string&gt; lisDupValues = dic.Where(x =&gt; x.Value &gt; 0).Select(x =&gt; x.Key).ToList(); //结果{"A"} //方式二 List&lt;string&gt; lisDupValues2 = lisA.GroupBy(x =&gt; x).Where(x =&gt; x.Count() &gt; 1).Select(x =&gt; x.Key).ToList(); //结果{"A"} //方式三 等同于方式二 List&lt;string&gt; lisDupValues3 = (from r in lisA group r by r into g where g.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa89f98bbee5a6a00f72720f751eef30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fd18ead8dc561bcf1742c0f57426b3b/" rel="bookmark">
			CCF-CSP 201803-1 跳一跳 [C&#43;&#43;]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CCF-CSP 201803-1 跳一跳 问题描述 问题链接
代码 # include &lt;bits/stdc++.h&gt; using namespace std; int main() { string line; getline(cin,line); stringstream ss(line); int count = 0; int temp; int p = 1; bool first = true; while (ss &gt;&gt; temp) { if (temp == 0) { break; } else if (temp == 1) { count ++; p = 1; } else { if (p == 1) { count += 2; p = 2; } else { p += 2; count += p; } } } cout &lt;&lt; count &lt;&lt; endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce10f1cdfc54488a02d300c70eb613d1/" rel="bookmark">
			第一讲 响应式网页
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列课程目录 第一讲 响应式网页
目录 系列课程目录前言一、什么是响应式网页？二、常用编辑器与浏览器三、如何建立项目四、任务一 课堂作业1.按照要求完成任务2.解析代码 五、知识点1.媒体查询2.常用断点3.结合使用 五、任务二 课后作业1.按照要求完成任务 总结 前言 例如：随着社会上各种各样的智能设备的出现，做出能够兼容大部分设备并且耗费更少人力与资源的响应式网页应运而生。 提示：以下是本篇文章正文内容，下面案例可供参考
一、什么是响应式网页？ 页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。
二、常用编辑器与浏览器 如下（示例）：
三、如何建立项目 如下（示例）：
四、任务一 课堂作业 1.按照要求完成任务 如下（示例）：
2.解析代码 如下（示例）：
注释中为清除浮动，避免使用过程中下方黑块填充至上方。
如下（示例）：
五、知识点 1.媒体查询 运用此处知识点可实现用户自由调整页面大小时，网页页面呈现出不一样的效果。
如下（示例）：
2.常用断点 此处为常用断点，可以作为设置参数时的参照。
如下（示例）：
3.结合使用 结合media语句与常用断点形成语句在实际网页制作中可以灵活运用。
如下（示例）：
五、任务二 课后作业 1.按照要求完成任务 如下（示例）：
总结 本课讲了什么是响应式网页，并且留下了相关习题练习，帮助加深印象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/defe1bb087b7ce589871f51e8628705a/" rel="bookmark">
			CCF-CSP 201809-2 买菜[c&#43;&#43;]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CCF-CSP 201809-2 买菜 文章目录 CCF-CSP 201809-2 买菜题目描述代码 题目描述 问题链接
代码 #include &lt;bits/stdc++.h&gt; using namespace std; class Node{ public: int x,y; Node(int a,int b) { x = a; y = b; } }; int main() { ios::sync_with_stdio(false); int n; cin &gt;&gt; n; vector&lt;Node&gt; a; vector&lt;Node&gt; b; int x,y; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; a.push_back(Node(x,y)); } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; b.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/defe1bb087b7ce589871f51e8628705a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7ab6aa69b8d33dd50f60031ebfe548a/" rel="bookmark">
			CCF-CSP 201809-1 卖菜 [C&#43;&#43;]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CCF-CSP 201809-1 卖菜 文章目录 CCF-CSP 201809-1 卖菜问题描述代码 问题描述 问题链接
代码 #include &lt;bits/stdc++.h&gt; using namespace std; int main() { int num[2000] = {0}; int n; cin &gt;&gt; n; int i; for (i = 0; i &lt; n; i++) { cin &gt;&gt; num[i]; } int res[2000] = {0}; for (i = 0; i &lt; n; i++) { if (i == 0) { cout &lt;&lt; ((num[i] + num[i+1])/2) &lt;&lt; " "; } else if (i == n-1) { cout &lt;&lt; ((num[i-1] + num[i])/2) &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7ab6aa69b8d33dd50f60031ebfe548a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f28fc5e007ea102662b9768a4a228732/" rel="bookmark">
			2021-03-03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;bits/stdc++.h&gt; typedef long long ll; using namespace std; class Node{ public: string op; float p; int s; int index; Node(string _op, float _p, int _s, int _index) { op = _op; p = _p; s = _s; index = _index; } }; bool comp(Node* n1, Node* n2) { return n1-&gt;p &gt; n2-&gt;p; } int main() { vector&lt;Node*&gt; buys; vector&lt;Node*&gt; sells; //输入数据 int lineNo = 0; string line; string op; int s; float p; while (getline(cin,line)){ lineNo++; stringstream ss(line); ss &gt;&gt; op; if (op == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f28fc5e007ea102662b9768a4a228732/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2fbdb28a14f06f5b211667ac697f30a/" rel="bookmark">
			使用SSO增强身份安全性的四个原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 尽管人们普遍认为“外围设备已经过时”，但当前的现实迫使许多组织以比计划更快的速度改进其安全方法。
传统的防火墙和基于VPN的安全模型根本不是为了保护当今高度分布式的IT环境而构建的。随着企业采用云和混合基础架构，越来越多的SaaS应用程序鼓励员工远程工作，很明显，身份确实是唯一真正的边界。如今，有效的企业安全取决于能否安全地管理和验证身份，并控制每个人员，应用程序和机器（无论它们在网络范围之内还是之外）的特权访问。在当今的环境中，根据身份，所有身份都可以在特定条件下获得特权，这取决于他们访问的系统、环境、应用程序或数据，或者他们执行的操作类型。
密码问题 在这样的背景下，网络犯罪分子将特权用户凭据作为首要目标并不奇怪——这是基于他们能够提供对组织最关键数据和基础设施的巨大访问。根据2020年Verizon DBIR报告，超过80％的与黑客有关的数据泄露涉及使用丢失或被盗的凭证或暴力手段。通过泄露特权凭据，攻击者可以访问内部资源、获取机密数据并中断业务。然而，许多组织仍然依赖密码来保护用户凭据。
每天有超过3亿次欺诈性登录Microsoft Services的尝试，但是，有53％的用户在过去12个月中没有更改过密码。即使有，新密码也很容易被破解或在多个地方使用。根据Google的一项研究，有52％的人对多个帐户使用相同的密码。
当然，许多组织已采取措施来保护身份，例如强制使用唯一的密码，需要频繁更改密码和强制实施密码复杂性策略。但是，这些控制措施实际上可能弊大于利，这可能会导致最终用户采取危险的密码做法（例如将其写下来！），并给负责手动管理访问权限的IT团队带来不必要的负担。
记住，忘记，输入和重置密码是一个巨大的痛苦，并且会浪费生产力。特别是在远程工作时代，员工和第三方供应商严重依赖应用程序进行协作和访问公司资源。如今，典型员工每周损失大约12.6分钟的时间来输入和重置密码。普华永道(PwC）的一项研究发现，所有帮助台呼叫中约有30％与密码有关，这将宝贵的IT资源从更具战略意义的计划中抽离。通过一些简单的计算，使用密码的生产力成本约为每位员工每年725美元。
立即将SSO添加到安全工具包中的四个原因 单点登录（SSO）解决了这个普遍存在的密码问题，并通过使组织能够：
1. 通过完全消除对单个密码的需求，一贯地执行更严格的密码策略， 并降低不良密码做法的风险。借助SSO，组织可以为所有应用程序，端点和资源使用一个安全标识。
2. 通过允许本地和远程用户一键访问指定的云和内部部署应用程序，增强最终用户体验。为了帮助员工保持生产效率和业务速度，一些SSO解决方案只需要对高风险、特权访问请求进行额外的安全控制。
3. 打破孤岛,并通过无缝目录集成简化用户和帐户的管理。
4. 全面了解用户的访问活动, 帮助满足访问方面的合规性要求，简化报告并改善总体安全状况。
并非所有SSO解决方案都是平等的 SSO的直接好处是显而易见的：通过加强身份安全控制，企业可以降低风险，增强用户体验，简化对企业资源的访问，同时减轻IT的负担。
但是，通过实施SSO解决方案，组织可以实现许多额外的长期好处，这些好处在最初的讨论中经常被忽略。例如，通过适当配置的自助服务工具，公司可以通过减少与密码相关的服务台票证和电话的数量来显著降低IT成本。此外，SSO可以消除在员工更换角色或离开公司时账户保持活动状态的可能性。正确的SSO解决方案甚至可以将安全功能扩展到密码之外，包括多因素身份验证（MFA）和无密码身份验证方法。
本文翻译自Stas Neyman 所撰 《Four Reasons to Strengthen Identity Security with SSO》一文。
原文链接: https://www.cyberark.com/resources/all-blog-posts/four-reasons-to-strengthen-identity-security-with-sso
关于我们 「龙归科技」 是一个专注于低代码赋能企业级信息化服务提供商。核心创始人团队来自绿盟安全、红帽开源操作系统、知名游戏玩蟹科技、知名开源社区等专家共同创立。
「龙归科技」 致力于让中国每一个企业拥有专属的自动化办公操作系统，助力企业或政府拥抱 （Cloud Native First）云原生优先战略，帮助客户构筑以「身份与应用」为中心的现代化 IT 基础设施！从而实现 「数字化转型」 及 「软件行业工业化生产」 ！
主打产品：ArkOS方舟操作系统：一个企业级办公自动化操作系统 ，结合自研低代码应用开发平台，构建产业生态，专注为各类企业与组织机构打造一体化全栈云原生平台。系统自带应用包括：ArkID 统一身份认证，ArkIDE，ArkPlatform，App Store 等产品。截至目前，公司已经获得 15个 软件著作权、2个发明专利，并与2020年11月份，获得北京海淀区中关村国家高新技术企业认定。
相关链接： 官网：https://www.longguikeji.com/
文档：https://docs.arkid.longguikeji.com/
开源代码仓库地址：
https://github.com/longguikeji
https://gitee.com/longguikeji
历史文章
登录的轮子，你还在造？企业级单点登录——信息化体系建设基础远程办公，你准备好了吗？企业信息化，怎样才算数？龙归科技 | 对未来的若干猜测龙归科技 | 企业办公自动化的未来龙归科技 | 软件的成本下降开源软件项目的定性和定量分析指标 —— CHAOSS 指标解析 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a77fcf77691ede2c8b62c614f21d7b6/" rel="bookmark">
			椭圆检测（Ellipse Detection）算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		————————————————
版权声明：本文为CSDN博主「今天不飞了」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xsz591541060/article/details/107813895
原文链接
最近在写一些关于椭圆检测的程序，看到了这个帖子，写的比较好，尤其文末的几篇论文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e28a9b4209d089c43b02e97dcb1477b4/" rel="bookmark">
			linux内核无法使用数学函数解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux内核无法使用数学函数解决方法 1、在linux内核中调用用户空间的程序
2、linux 内核调用用户程序（带程序）
3、自己写一个数学函数（指数与对数）
实际上，在精度要求不高的情况下直接用泰勒展开式编写的计算效率是最高的，只需取前面几次展开精度就可以达到百分位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/099b7ab7b9b7e63a4e269edac831a3d7/" rel="bookmark">
			电脑使用小常识（5）：电脑已经登录的 WIFI 密码忘记怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		经常有这种情况：朋友来玩，问 WIFI 密码。卧槽，居然搞忘了~~怎么办？
不用怕，按照以下几步，轻松找回被忘掉的密码。
1. 点击电脑右下角网络图标，点开“网络和 internet 设置” 2. 选择“更改适配器选项” 3. 在已经连接的 WLAN 上，右击，选择“状态” 4. 选择“无限属性” 5. “安全”、显示字符 就可以看到已经记录的 wifi 密码了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23e8d12462e9a29aefceb8a65ade6cd9/" rel="bookmark">
			亲测有效，VM虚拟机提示“此主机支持AMD-V，但AMD-V处于禁用状态”解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华硕主板，安装虚拟机出现上述报错，按照下面的步骤就能解决，之前也不懂，亲测有效。
报错解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e1e3816daffe0758dc223a107c6fe6/" rel="bookmark">
			window10刷新卡顿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转发自：https://jingyan.baidu.com/article/ff42efa9c4a817c19e22029f.html 亲测有效 第一步在电脑上鼠标右键进行刷新，出现卡顿，如下图所示：
第二步我们来解除鼠标右键刷新卡顿的问题，按win+R键打开运行，输入regedit，如下图所示：
第三步点击确定之后，进去注册表编辑器，选择HEKY_CLASSES_ROOT，如下图所示：
第四步依次点击“HEKY_CLASSES_ROOT-&gt;Directory-&gt;Background-&gt;shellex\Contextmenuhandler”，如下图所示：
第五步将Contextmenuhandler项的下方的除了“NEW”和“WorkFolders”项留下，其他的都可以右键进行删除，如下图所示：
第六步删除完成之后，重启电脑，再次鼠标右键刷新就不卡顿了，如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3017246b8d2574dcfe14c2993d675c4/" rel="bookmark">
			Python初学15——wordcloud库简介与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、wordcloud库基本介绍
二、wordcloud库使用说明（
.WordCloud(width= ,height=, min_font_size=, max_font_size=, font_step=, font_path=, max_words=, stop_words=, mask=, background_color= )、
.generate()、.to_file()、绘制词云三步走）
三、“词云”实例
一、wordcloud库基本介绍 wordcloud库是优秀的词云展示第三方库，词云：以词语为基本单位，更加直观和艺术的展示文本。
用户使用前需要额外安装，安装过程参考“Python初学11”第二章（对应安装命令改为：pip install wordcloud）若安装出错，请首先转看 python安装第三方库遇到 ERROR: Command errored out with exit status 1: 二、wordcloud库使用说明（ .WordCloud(width= ,height=, min_font_size=, max_font_size=, font_step=, font_path=, max_words=, stop_words=, mask=, background_color= )、 .generate()、.to_file()、绘制词云三步走） wordcloud库把词云当作一个WordCloud对象，即 wordcloud.WordCloud() 代表一个文本对应的词云。可以根据文本中词云出现的频率等参数绘制词云绘制词云的形状、尺寸个颜色都可以设定 创建词云对象：
w = wordcloud.WordCloud(&lt;参数&gt;)
表2-1 词云对象配置参数 参数说明width 指定词云对象生成图片的宽度，默认400像素
如：w = wordcloud.WordCloud(width=600)
height 指定词云对象生成图片的高度，默认200像素
如：w = wordcloud.WordCloud(height=400)
min_font_size 指定词云中字体的最小字号，默认4号
如：w = wordcloud.WordCloud(min_font_size=10)
max_font_size 指定词云中字体的最大字号，默认根据高度参数自动调节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3017246b8d2574dcfe14c2993d675c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a740f841d76f7c08ae2a596969e8c98e/" rel="bookmark">
			刷题路-求极差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 求极差 题目描述 给出 n(n≤100) 和 n 个整数 (0≤i≤100)，求这 n 个整数中的极差是什么。极差的意思是一组数中的最大值减去最小值的差。
输入格式 无
输出格式 无
输入输出样例 输入 #1 6
1 1 4 5 1 4
输出 #1 4
#include&lt;bits/stdc++.h&gt; using namespace std; int main(){ int n,maxn=-1,minn=1001; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i){ int tmp; cin&gt;&gt;tmp; maxn=max(tmp,maxn);//算最大值 minn=min(tmp,minn);//算最小值 } cout&lt;&lt;maxn-minn;//求差 return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02983047d96907cf45935b2750a25aa1/" rel="bookmark">
			关于vetur自动将PX转成小写px的问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在项目中做屏幕自适应的时候，难免要用到
postcss-px2rem 它会将我们样式中的px全部转成rem（包括style里面，less，sass，scss），但是使用过程中，有些样式中的px我们是不想让它转的。
.ant-menu-inline-collapsed { width: 80px; /*no*/ } 后面加/no/ 就可以使postcss-px2rem不去转这个值，很小的一个改动，却很有用，记录一下，方便大家的使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54847e97dda72f08df38c463f23a590/" rel="bookmark">
			调研
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现网上可参考的资料太少了，最近有开个专题（文章+视频，从基础原理到编码实现）的想法，，不知道是对心理学实验程序设计PSYCHTOOLBOX（PTB）感兴趣的人多一些还是对信号处理算法感兴趣的人多一些呢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b21d8c93e252fab2c28b4e7fe1ca7bd/" rel="bookmark">
			我的分享：第八章：redis专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现了一位大佬的redis专题，个人觉得写的很到位，这里给上地址：
https://www.cnblogs.com/ysocean/tag/Redis%E8%AF%A6%E8%A7%A3/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f77be31aa09e59220b539c1923caf1c/" rel="bookmark">
			启动配置服务提示Could not resolve placeholder ‘config‘ in value “${config}解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 这是Nacou 创建的配置 !在这里插入图片描述
2 , 这是项目中配置的
3 , 问题原因 , 本地配置文件 与 Nacos 配置中的名称后缀不一致,
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f8beac303eb5a4b70ca90d759fde89b/" rel="bookmark">
			java 多线程协同_JAVA并发梳理（三） 多线程协作方式及实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程间的基本协作方式请参考 多线程协作方式。
在此基础上，结合源码梳理一下每种方式的实现原理。
Synchronized
·synchronized·是Java原生的互斥同步锁，使用方便，对于·synchronized·修饰的方法或同步块，无需再显式释放锁。·synchronized·底层是通过·monitorenter·和·monitorexit·两个字节码指令来实现加锁解锁操作的。
除Synchronized之外的线程同步工具
除了Synchronized，其余的线程协作方式都是在Java API层面的。这些工具基本都依赖于AbstractQueuedSynchronizer。AbstractQueuedSynchronizer是Java并发很强大的同步器，它内部维护了一个等待锁的双向链表。链表节点是自定义的Node(定义参考以下源码)，每个Node包含了一个线程对象，它的前后指针，以及节点的状态。对于线程的阻塞和唤醒又是基于LockSupport提供的park, unpark实现。
LockSupport，是线程阻塞的原语。详细请参考 JAVA并发梳理(一)LockSupport。
static final class Node {
/** Marker to indicate a node is waiting in shared mode */
static final Node SHARED = new Node();
/** Marker to indicate a node is waiting in exclusive mode */
static final Node EXCLUSIVE = null;
/** waitStatus value to indicate thread has cancelled */
static final int CANCELLED = 1;
/** waitStatus value to indicate successor's thread needs unparking */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f8beac303eb5a4b70ca90d759fde89b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c3c0c4876fbb42e28992e4bf4e5e8a/" rel="bookmark">
			vue全局存/读取字典值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue全局存/读取字典值
tips：如大项目常需用到很多字典值，很多数据都是从后端拿来然后控制前端的，就需要进行存储字典值，通常就是存储无数个对象嵌套对象，然后进行键值对的读取
例如：全局挂载字典
Vue.prototype.$window = {} let lodash = require('lodash') Vue.prototype.$window.utils = { //判断是否有重复 sameObj: function sameObj(o1, o2) { if (o1 === o2) return true let keys1 = o1 &amp;&amp; Object.keys(o1).sort() let keys2 = o2 &amp;&amp; Object.keys(o2).sort() if (JSON.stringify(keys1) !== JSON.stringify(keys2)) { // console.log('不一样的属性: ' + JSON.stringify(keys1), JSON.stringify(keys2)) return false } let isSame = true let len = keys1.length for (let i = 0; i &lt; len; i++) { let key = keys1[i] let item1 = o1[key] let item2 = o2[key] if (typeof item1 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c3c0c4876fbb42e28992e4bf4e5e8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c235f8c28574de0337278a75421da118/" rel="bookmark">
			spring &#43;ehcache 持久化数据，重启恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 配置ehcache.xml 配置好
2. 记得缓存的对象要 可序列化。 public class Folder implements Serializable { }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/797e7a99d8caccf0205a73ada8bbfebb/" rel="bookmark">
			分别在windows和linux下安装配置vscode&#43;latex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows安装vscode+latex windows安装vscode+latex安装和卸载latex安装和配置vscodeUbuntu18.04下如何添加latex宏包 windows安装vscode+latex 主要介绍安装vscode和latex配置
安装和卸载latex tex拥有多个版本，我们这里选择安装 TexLive
选择线上安装，参考链接linux版本的线上安装包链接，安装教程参考。卸载latex sudo apt-get purge texlive* rm -rf /usr/local/texlive and rm -rf ~/.texlive* rm -rf /usr/local/share/texmf rm -rf /var/lib/texmf rm -rf /etc/texmf sudo apt-get remove tex-common --purge rm -rf ~/.texlive* 安装和配置vscode 安装继续参考上述链接；安装好VScode之后需要再配置一下setting.json，添加下列文本到json文件中。 { "latex-workshop.latex.tools": [ { "name": "xelatex", "command": "xelatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] }, { "name": "pdflatex", "command": "pdflatex", "args": [ "-synctex=1", "-interaction=nonstopmode", "-file-line-error", "%DOC%" ] }, { "name": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/797e7a99d8caccf0205a73ada8bbfebb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2db27ae898d1bfdecf5aa018ee4d1ad/" rel="bookmark">
			Oracle Select for update用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Oracle Select for update用法 通常情况下Select不会对资料加锁，不会影响其他Session执行DML和DDL，借助for update子句就可以实现对资料加锁保护操作。當只允許一個session進行update的時候, for update十分有用.
在select … for update之后，可以使用of子句对select的特定资料进行加锁操作，不适用of子句表示在select所有的表加锁。
select * from test for update; 會對table test進行加鎖. 此時只允許當前的session對已經存在的資料進行更新. 但其它session仍可以進行insert的操作，只是不允许进行update操作。
select * from Table1 a join Table2 b on a.pkid=b.pkid where a.pkid = 10 for update of a.pkid 只鎖定Table1中滿足條件的行, 這就是使用of子句的作用. 比較常用於多個表的操作.
加入for update之後，Oracle就要求啟動一個新事務，嘗試對資料進行加鎖。如果當前已經被加鎖，預設的行為必然是block等待。使用nowait子句的作用就是避免進行等待，當發現請求加鎖資源被鎖定未釋放的時候，直接報錯返回。如果不使用nowait或wait子句, 新的加鎖請求會一直hang住, 直到原來的commit或rollback.
select * from test where a=2 for update nowait;
ERROR at line 1:
ORA-00054: resource busy and acquire with NOWAIT specified or timeout expired
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2db27ae898d1bfdecf5aa018ee4d1ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bdea8be0f8589eb18f4f079f78675d8/" rel="bookmark">
			java 线程的插队运行_Java实战开发篇-11 多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程
一、多线程中的几个概念
1.程序：静态的代码
2.进程：正在运行的一个程序 正在使用的QQ，Android Studio。进程用于管理所有的资源，不进行实际的任务
3.线程：完成具体任务，QQ运行起来就是线程(一个进程里面可以有多个线程)。运行QQ，聊天、视频、QQ游戏同时运行，这就是一个个线程
4.主线程：Java里面，main方法里面的代码就在主线程中运行。在手机里面，我们看到的主界面，就是一个主线程
5.子线程：除了主线程之外的线程
二、为什么使用多线程
在主线程里面，任务的执行是从上至下的，如果其中一个任务需要耗费大量时间。那么这个任务后面的任务就必须等这个任务结束后才能被执行，就会形成阻塞。这个时候就需要将这个任务放在另一个线程里面去执行(子线程)
*注：不管是主线程还是子线程都有自己独立的执行路径
三、如何开启一个线程
1.写一个类继承于Thread
步骤：
(1)创建类继承于Thread，具体执行的任务放在run()里面
(2)创建类的对象
(3)调用start()方法执行
注*线程的执行是通过抢占时间片来获取执行机会的，时间片是由操作系统来分配的
所以有多个线程的时候，每次执行的结果可能不一样
class TestThread extends Thread{
//1.创建一个类继承于Thread
//可以通过重写构造方法给子线程命名
public TestThread(@NonNull String name) {
super(name);
}
@Override
//子类必须实现父类的run方法，这个线程执行的任务在run方法里面
public void run() {
System.out.println(getName());
//也可以用Thread.currentThread()，获取当前线程的名字
System.out.println("Hello World");
}
}
public class MyClass {
public static void main(String[] args){
//2.创建具体的对象
TestThread testThread = new TestThread("子线程");//给子线程命名
//3.启动线程,不调用start无法启动线程
testThread.start();
}
}
public static void testRunnable(){
//2.创建具体对象
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bdea8be0f8589eb18f4f079f78675d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99d9ba3ee647f8b72c5212ef09f400d5/" rel="bookmark">
			雷达原理（一）：雷达波形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		雷达原理（一）：雷达波形 目录 雷达原理（一）：雷达波形1.低通，带通信号和正交分量2.解析信号3.连续和脉冲波形4.线性调频波形 5. 高距离分辨率6.其他波形以后待补充（接着这篇文章添加） 写在前面的话：
这个系列主要学习雷达的相关原理和其 m a t l a b matlab matlab实现。
参考书籍：《雷达系统设计 m a t l a b matlab matlab仿真》
1.低通，带通信号和正交分量 如果信号包含的主要频率处于包括直流 ( D C ) (DC) (DC)在内的低频频带,则称其为低通 ( L P ) (LP) (LP)信号。如果信号包含的主要频率处于离开原点的某个频率附近,则称其为带通 ( B P ) (BP) (BP)信号。一个实带通信号 x ( t ) x( t) x(t)在数学上可表示为:
x ( t ) = r ( t ) c o s ( 2 π f 0 t + ϕ x ( t ) ) x(t)=r(t)cos(2\pi f_{0}t+\phi_{x}(t)) x(t)=r(t)cos(2πf0​t+ϕx​(t)) 其中， r ( t ) r(t) r(t)是幅度调制或包络， ϕ x ( t ) \phi_{x}(t) ϕx​(t)是相位调制， f 0 f_{0} f0​是载波频率， r ( t ) r(t) r(t)和 ϕ x ( t ) \phi_{x}(t) ϕx​(t)所含的频率成分都比 f 0 f_{0} f0​显然要小，调制频率为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99d9ba3ee647f8b72c5212ef09f400d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/357ba80d44e43ff4d24383916586e7d7/" rel="bookmark">
			Oracle中判断日期是星期几（函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 根据函数来判断日期是星期几 原表
使用to_char函数
to_char(date,‘D’)：返回的是cher类型的数字
to_char(date,‘DAY’)：返回的是cher类型的汉字
注意两种用法的对应结果！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc85b06e60e9d08948d8e32cca9f8a65/" rel="bookmark">
			调试经验——Tensorflow中生成独热编码（One-hot encoding）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习吴恩达深度学习的过程中，出现了独热编码这一概念。
说明：
代码：
def one_hot_matrix(labels, C): """ Creates a matrix where the i-th row corresponds to the ith class number and the jth column corresponds to the jth training example. So if example j had a label i. Then entry (i,j) will be 1. Arguments: labels -- vector containing the labels C -- number of classes, the depth of the one hot dimension Returns: one_hot -- one hot matrix "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc85b06e60e9d08948d8e32cca9f8a65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30a81c725fc46711c974e53bbc5a924a/" rel="bookmark">
			YOLOV4用到的一些tricks以及代码实现（1）——CutMix and Mosaic data augmentation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOV4用掉的一些tricks以及代码实现（1）——CutMix and Mosaic data augmentation 之前的几篇博客将YOLOV4整个流程都过了一边，其中把重心放在相关的语法中，从这篇博客开始，我将YOLOV4中提到的一些tricks逐一进行介绍并用代码实现。首先看下论文提到了哪些tricks：
Bag of Freebies(BoF) 指那些能够提高精度而不增加推断时间的技术。比如数据增广的方法图像几何变换、CutOut、grid mask等，网络正则化的方法DropOut、DropBlock等，类别不平衡的处理方法、难例挖掘方法、损失函数的设计等。
Bag of Specials (BoS)是指那些增加稍许推断代价，但可以提高模型精度的方法，比如增大模型感受野的SPP、ASPP、RFB等，引入注意力机制Squeeze-and-Excitation (SE) 、Spatial Attention Module (SAM)等 ，特征集成方法SFAM , ASFF , BiFPN等，改进的激活函数Swish、Mish等，或者是后处理方法如soft NMS、DIoU NMS等。
本篇博客主要介绍：CutMix and Mosaic data augmentation 代码来源：https://github.com/jason9075/opencv-mosaic-data-aug
示例代码利用opencv展示Mosaic data augmentation算法
原理： Yolov4的mosaic数据增强参考了CutMix数据增强方式，理论上具有一定的相似性！
CutMix数据增强方式利用两张图片进行拼接。
但是mosaic利用了四张图片这样在BN计算的时候一下子会计算四张图片的数据！
实现思路
1、每次读取四张图片。
2、分别对四张图片进行翻转、缩放、色域变化等，并且按照四个方向位置摆好。
3、进行图片的组合和框的组合。
通过查看实现思路，其实发现整体思路并不复杂，真正复杂的实在代码实现上，包括坐标转换，标签转换等。
本次示例中，利用opencv仅仅用于图像展示，算法原理与yoloV4中data augment 一模一样。
按照笔者一贯思路，逐一对代码进行分析后，解答上诉问题：
def get_dataset(anno_dir, img_dir): 首先通过dataset获取标签数据和图像数据。
for anno_file in glob.glob(os.path.join(anno_dir, '*.txt')) 遍历anno_dir中的数据，这其中牵扯到glob语法。glob模块是最简单的模块之一，内容非常少。用它可以查找符合特定规则的文件路径名。跟使用windows下的文件搜索差不多。查找文件只用到三个匹配符：””, “?”, “[]”。””匹配0个或多个字符；”?”匹配单个字符；”[]”匹配指定范围内的字符，如：[0-9]匹配数字。
在这里就是查找以“txt"结尾的文件，返回的是文件路径。
xmin = max(obj[1], 0) / img_width ymin = max(obj[2], 0) / img_height xmax = min(obj[3], img_width) / img_width ymax = min(obj[4], img_height) / img_height 获取到标注信息的位置后进行归一化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30a81c725fc46711c974e53bbc5a924a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ced7bdac4b8b323dbb1a940402ca312f/" rel="bookmark">
			HTML-CSS小知识——overflow使用细节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML-CSS小知识——overflow使用细节 overflow overflow overflow需要元素在同一层级，若子元素脱离标准流，也就是层级高于父元素后，就不受父元素的overflow限制。
子元素img绝对定位，父元素a没有定位，代码如下 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;小米商城&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } #top .top-banner{ height: 120px; width: 100%; } #top .top-banner a{ display: inline-block; /* position: relative; */ height: 120px; width: 100%; overflow: hidden; } #top .top-banner a img{ position: absolute; height: 120px; top: 0px; left: -50%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header id="top"&gt; &lt;div class="top-banner"&gt; &lt;a href="#"&gt;&lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ced7bdac4b8b323dbb1a940402ca312f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c164add20f9d7f8c6b1e8e5ea0d28c/" rel="bookmark">
			指数加权移动平均
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习吴恩达深度学习课程时，遇到“指数加权移动平均”这一概念，看似简单，实则深奥。本文通过一个Excel示例，加深对其理解。
以下为2021年2月份上海市日最高气温（℃）表对应的折线图。
可以看出，折线图中的温度曲线起伏较大，十分“不平滑”。那么，有没有办法让其更平滑呢？可以考虑使用指数加权移动平均法。
注：Excel源文件已上传至：
http://localhost:8888/edit/GitHub/Andrew-Ng-Deep-Learning-notes/iTechMemo.xlsb
worksheet: EWMA
可以看出，β值较低时（β=0.1），移动平均曲线与原曲线差别不大；β值较高时（β=0.9（修正）），移动平均曲线相比原曲线有了明显的“平滑”效果。
参考文章：
1. 吴恩达深度学习学习笔记——C2W2——算法优化-1
https://blog.csdn.net/hpdlzu80100/article/details/113399321
2. 通俗理解指数加权平均
https://zhuanlan.zhihu.com/p/29895933
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c1cd7ff2cc2d7431bfb24301564e65f/" rel="bookmark">
			vue&#43;element-ui el-tabs切换面板el-tab-pane切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在vue项目中，el-tabs在页面的右侧显示，切换面板，下面的内容是正常显示的
效果如下：
代码如下：
父组件
&lt;el-card&gt; &lt;span&gt;数据信息&lt;/span&gt; &lt;el-tabs class="tabRight" v-model="activeName" type="card" @tab-click="handleClick" &gt; &lt;el-tab-pane label="实时数据图表" name="first" :key="first"&gt; &lt;/el-tab-pane&gt; &lt;el-tab-pane label="历史数据图表" name="second" :key="second"&gt; &lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;child1 v-if="activeName=='first'" /&gt; &lt;child2 v-if="activeName=='second'" /&gt; &lt;/el-card&gt; &lt;script&gt; import enviroChild1 from './enviroChild1'; import enviroChild2 from './enviroChild2' export default { name: "", components: { child1: enviroChild1, child2: enviroChild2 }, data() { return { activeName: "first", } }, &lt;style lang="scss" scoped&gt; .tabRight { float: right; } &lt;/style&gt; 子组件代码enviroChild1和enviroChild2代码一样，所以只贴了一份
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c1cd7ff2cc2d7431bfb24301564e65f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aab0767ef52d1d53106e469e1f15828/" rel="bookmark">
			微信扫网址的二维码，却只显示链接地址，无法跳转到网页的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		期望效果：微信扫描二维码，用微信自带的浏览器打开指定的网页
如果你生成的微信二维码，里面的地址内容是 www.baidu.com 微信扫码就会出现下面这个页面
我记得以前的微信这样的地址是会自动打开网页的，但现在不行了，得加上前缀 http:// 或 https://
当你微信二维码里面的地址为 http://www.baidu.com 再用微信扫码，出现下面
问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c63411cbcae34a7faca00ffa3d4d886/" rel="bookmark">
			【高级开发进阶】Redis的单线程和高性能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis的单线程和高性能
Redis是单线程吗？
Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。
Redis 单线程为什么还能这么快？
因为它所有的数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。
Redis 单线程如何处理那么多的并发客户端连接？
Redis的IO多路复用：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。
# 查看redis支持的最大连接数，在redis.conf文件中可修改，
# maxclients 10000 127.0.0.1:6379&gt; CONFIG GET maxclients ##1) "maxclients" ##2) "10000"
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c3472c67caa07dc59369e2bd6ff91b7/" rel="bookmark">
			把软件装进U盘，真正做到即插即用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把软件装进U盘，真正做到即插即用 如果你觉得到处携带电脑十分的不方便，但是换一个工作环境，临时电脑上又没有常用的软件，例如：PS，AE等等，现在看来有两种解决方案，一种是个别网络厂商提供的在线版软件，另一种是就是今天即将介绍的，把软件装进U盘，做到即插即用。
首先在线提供的软件具有一定的局限性，网络，网速等等，所以先来看看这个方法吧。
使用这种方法也不会在临时的电脑上留下使用痕迹，非常适合经常在不同的电脑上办公的用户群体。
portableapps 今天介绍的主角就是portableapps，下载链接放在文章末尾
portableapps本身就是一个非常小巧的软件，本身就只有5M，portableapps翻译过来就是绿色便捷软件，简单的说就是可以通过这款软件，让你的应用程序可以运行在U盘上，做到即插即用。
portableapps安装教程 双击安装程序，出现以下界面，点击下一步：
image-20210228204358352 选择全新安装，然后点击下一步：
image-20210228204521687 选择便携式，然后点击下一步：
image-20210228204651531 选择安装在自己的U盘上，然后开始安装
image-20210228204822866 软件安装教程 内置软件安装 安装完成之后，我们可以看到已经内置了很多的软件，从安全工具到网络工具再到游戏基本都配置了一些，我们可以直接在这安装使用。
image-20210228205134198 勾选我们需要安装的软件，然后点击下一步，就会开始下载并安装
image-20210228205432432 安装完成之后，就可以在软件列表里面找到，然后双击运行即可。
image-20210228205618772 自定义软件安装 我们打开官方的论坛网站，在右上角的搜索框中搜索自己需要的软件，这里以编程工具IDEA为例
image-20210228210016143 找到IDEA软件，然后找到先下载入口，并点击下载，这里一般下载.paf.exe结尾的软件。
官网提供的下载通道下载速度较慢
image-20210228210204439 然后在该软件的控制面板中，找到应用管理
image-20210228210613443 然后点击安装新的便携应用，找到刚刚下载的.paf.exe结尾的安装包，点击开始安装。
image-20210228210640444 image-20210228210749456 安装路径可以不用更改
image-20210228210815396 下载链接 关注微信公众号：科技毒瘤君
回复关键字：验证码
因为科技毒瘤君微信公众号自定义关键字回复有限，所以资源逐步转移到北忘山的博客，所以公众号只提供验证码服务。复制到验证码到下面的链接即可。
https://www.beiwangshan.com/archives/123.html
点击左下方阅读原文直达哦~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db6ef2e12e05354fb15354ad1fabcf77/" rel="bookmark">
			（八）面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（一） 1.1 面向对象的定义 通常类中的方法都有一个self参数，除过self参数，不用考虑，其他传递的参数都需要考虑适用于函数特多，将函数进行划分归类的情况【封装】注意：类名要大写，方法（函数）要有self参数 class 类名： def 方法名（self,*args）: print(*args) return 123 obj = 类名（） res = obj.方法名（‘run’） print(res) #函数 def func1(): pass #类 class Account(): #方法 def func1(self): pass 1.2 类的调用 先创建一个对象通过使用对象，调用类中的方法 #类 class Account(): #方法 def func1(self): print('func1') return 123 #创建一个Account对象 x = Account() res = x.func1() print(res) 1.3 对象的作用【封装】 存储一些值，方便以后自己使用
每创建一个对象，都会为这些对象重新开辟一块新的内存空间，在对象中封装【独有的性质】，方便以后调用
class File(): #方法 def read(self): print('read' ) with open(self.path , mode='r',encoding='utf-8') as f: data = f.read() return data def write(self,content,path): with open(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db6ef2e12e05354fb15354ad1fabcf77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a36acb352483074e17a019e0f7ab92/" rel="bookmark">
			python中random模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中的random模块用于生成随机数，它提供了很多函数。常用函数总结如下：
1. random.random()
用于生成一个0到1的随机浮点数: 0 &lt;= n &lt; 1.0
2. random.seed(n)
用于设定种子值，其中的n可以是任意数字。random.random() 生成随机数时，每一次生成的数都是随机的。但是，使用 random.seed(n) 设定好种子之后，在先调用seed(n)时，使用 random() 生成的随机数将会是同一个。
3. random.uniform(a,b)
返回a,b之间的随机浮点数，若a&lt;=b则范围[a,b]，若a&gt;=b则范围[b,a] ，a和b可以是实数。
4. random.randint(a,b)
返回a,b之间的整数，范围[a,b]，注意：传入参数必须是整数，a一定要比b小。
5. random.randrange([start=0], stop[, step=1])
返回前闭后开区间[start,stop)内的整数，可以设置step。只能传入整数。
6. random.choice(sequence)
从sequence（序列，列表、元组和字符串）中随机获取一个元素。
7. random.choices(sequence, k)
从sequence（序列，列表、元组和字符串）中随机获取k个元素，可能重复，k用参数名传值，k省略则默认取1个，返回list。
8. random. shuffle(x)
用于将列表中的元素打乱顺序，俗称为洗牌。
9. random. sample(sequence,k)
从指定序列中随机获取k个不重复元素作为一个列表返回， sample函数不会修改原有序列。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d04f2d26f18a6484d8649d511bfa93f8/" rel="bookmark">
			CMake来编译OpenCV，细致教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、openCV配置cmake编译二、使用步骤1.下载openCV [openCV官网](https://opencv.org/releases/)2.创建build文件夹3.下载opencv_contrib-4.5.1（此版本与opencv版本对应）4.下载cmake 并编译4.CMake来编译OpenCV 常见问题总结 前言 提示：示例系统为 win10 64位：
CMake来编译OpenCV，以匹配自己使用的VS版本。
提示：以下是本篇文章正文内容，下面案例可供参考
一、openCV配置cmake编译 使用到的软件 cmake ，vs2019（选择自己的vs版本即可），opencv，opencv_contrib-4.5.1
二、使用步骤 1.下载openCV openCV官网 ：
进入网站 选择 Sources 下载
创建一个文件夹（这里以opencv为例）
打开创建的文件夹，把刚才下载的opencv Sources文件解压到此文件夹
2.创建build文件夹 在opencv文件夹下 创建一个名为build文件（用于后期cmake build）
3.下载opencv_contrib-4.5.1（此版本与opencv版本对应） 下载压缩包并解压到opencv文件目录下，下载地址
4.下载cmake 并编译 cmake下载地址选择此版本安装的时候，注意勾选cmake加入path路径选项
4.CMake来编译OpenCV 打开cmake 第一个路径选择opencv-4.5.1所在的路径
第二个build路径选择 上面所创建的build目录路径
点击Configure，选择自己vs版本和处理器（这里是win10 64位系统）故选x64
点击Finish
这个会出现很多错误，但是我们只需要修改一个OPENCV_EXTRA_MODULES_PATH
找到此文件，后面添加路径（opencv_contrib-4.5.1中modules所在的路径）
再点击Configure（Configuring done）点击Generate，完成（Generating done）点击open Project 就可以使用啦
常见问题总结 问：出现 no cmake_cxx_compiler could be found 错误答：下载安装Window 相应的SDK（使用vs的，直接在visual stdio installer 上 单个组件安装 SDK），还不行就安装vs扩展（visual stdio installer中） 问：在使用opencv和cmake时 configure时出现does not appear to contain CMakeLists.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d04f2d26f18a6484d8649d511bfa93f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc95d0f45408b37e3384a819e568d876/" rel="bookmark">
			强缓存和协商缓存详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		强缓存 到底什么是强缓存？强在哪？其实强是强制的意思。当浏览器去请求某个文件的时候，服务端就在respone header里面对该文件做了缓存配置。缓存的时间、缓存类型都由服务端控制，具体表现为：
respone header 的cache-control，常见的设置是max-age public private no-cache no-store等
如下图,
设置了cahe-control:max-age=31536000,public,immutable
max-age表示缓存的时间是31536000秒（1年），public表示可以被浏览器和代理服务器缓存，代理服务器一般可用nginx来做。immutable表示该资源永远不变，但是实际上该资源并不是永远不变，它这么设置的意思是为了让用户在刷新页面的时候不要去请求服务器！啥意思？就是说，如果你只设置了cahe-control:max-age=31536000,public 这属于强缓存，每次用户正常打开这个页面，浏览器会判断缓存是否过期，没有过期就从缓存中读取数据；但是有一些 “聪明” 的用户会点击浏览器左上角的刷新按钮去刷新页面，这时候就算资源没有过期（1年没这么快过），浏览器也会直接去请求服务器，这就是额外的请求消耗了，这时候就相当于是走协商缓存的流程了（下面会讲到）。如果cahe-control:max-age=315360000,public再加个immutable的话，就算用户刷新页面，浏览器也不会发起请求去服务，浏览器会直接从本地磁盘或者内存中读取缓存并返回200状态，看上图的红色框（from memory cache）。这是2015年facebook团队向制定 HTTP 标准的 IETF 工作组提到的建议：他们希望 HTTP 协议能给 Cache-Control 响应头增加一个属性字段表明该资源永不过期，浏览器就没必要再为这些资源发送条件请求了。
强缓存总结 cache-control: max-age=xxxx，public
客户端和代理服务器都可以缓存该资源；
客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，如果用户做了刷新操作，就向服务器发起http请求
cache-control: max-age=xxxx，private
只让客户端可以缓存该资源；代理服务器不缓存
客户端在xxx秒内直接读取缓存,statu code:200
cache-control: max-age=xxxx，immutable
客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求
cache-control: no-cache
跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了no-cache就不会走强缓存了，每次请求都回询问服务端。
cache-control: no-store
不缓存，这个会让客户端、服务器都不缓存，也就没有所谓的强缓存、协商缓存了。
二、协商缓存 上面说到的强缓存就是给资源设置个过期时间，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。所以，强缓存就是为了给客户端自给自足用的。而当某天，客户端请求该资源时发现其过期了，这是就会去请求服务器了，而这时候去请求服务器的这过程就可以设置协商缓存。这时候，协商缓存就是需要客户端和服务器两端进行交互的。
怎么设置协商缓存？
response header里面的设置
etag: '5c20abbd-e2e8' last-modified: Mon, 24 Dec 2018 09:49:49 GMT etag：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，每个资源都会有这个东西，如： app.js打包后变为 app.c20abbde.js，加个唯一hash，也是为了解决缓存问题。
last-modified：文件的修改时间，精确到秒
也就是说，每次请求返回来 response header 中的 etag和 last-modified，在下次请求时在 request header 就把这两个带上，服务端把你带过来的标识进行对比，然后判断资源是否更改了，如果更改就直接返回新的资源，和更新对应的response header的标识etag、last-modified。如果资源没有变，那就不变etag、last-modified，这时候对客户端来说，每次请求都是要进行协商缓存了，即：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc95d0f45408b37e3384a819e568d876/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d7ccc3dc548ce77945e1ccbbf0f3e01/" rel="bookmark">
			ES的近实时性以及持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、近实时性 ElasticSearch的搜索是近实时性的，简单来讲，就是说如果你新增一个文档，然后马上又发送一个查询该报文的请求，有可能得到空的结果。过一会再查，才能查到该文档。
可以理解成新增的索引还没那么快同步到索引中，这个同步的时间可以设置，默认是1秒。
为什么ES要这么设计呢？归根到底，还是出于性能的考虑。
这里先讲下ES中的一些基础概念，Shard（片）、Segment（段）、 In-memory buffer（内存索引缓存区）。
ES中的文档，是被组织在一个个片中的，一个索引可以分成多个分片，这个分片的数量在创建索引时，就要确定好。而每个片，是由多个Segment组成的，也就是说，ES存储数据的基本物理单元是Segment。
新增或修改一个文档的操作是这样的：
客户端对文档的修改，会放到内存索引缓存区中，在内存索引缓存区中会将这些修改组织成一个Segment，然后将这个Segment持久化到磁盘中。一旦Segment持久化成功，该文档的修改对客户端才可见。
如图：In-memory buffer就是内存索引缓存区，这里的内容将会组织成一个个Segment，此时它还不可搜索。
矛盾来了，Segment持久化就要写磁盘，而写磁盘是非常耗性能的。
因此，ES引入一个FileSystem Cache（文件系统缓存）的概念。
In-memory buffer 中的内容，先不持久化到磁盘，而是先写入FileSystem Cache，一旦写入FileSystem Cache ，则这些内容也可以索引到了。当FileSystem Cache 达到一定数量级，或者达到某个时间点，它会调用写磁盘的操作，把它的内容写入磁盘（这一点在下文持久化中详细说明）。这样，就不会频繁写入磁盘了。
写入FileSystem Cache 是一个比较轻量级的操作，In-memory buffer 写入FileSystem Cache 的频率可以控制，默认是1s写入一次。
这也解释了开头说的ES近实时性。即对文档的修改，默认最多等 1s，就可以索引到了。
In-memory buffer 写入FileSystem Cache 的动作，称为Refresh。
Refresh的频率可以调整，对于迁移旧索引文件的操作，则可以把Refresh频率设置更长时间，比如30s，因为你对实时性要求并不高。
如果你实时性要求很高，也可以手工调用Refresh进行数据的刷新。
这里，官网有这么一段话：
尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候， 手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。 相反，你的应用需要意识到 Elasticsearch 的近实时的性质，并接受它的不足。
至此，ES的近实时性我们分析完了。
二、持久化 上面仔细看的同学，可能会注意到，FileSystem Cache之所以快，是因为他是内存的写入，没有及时提交到磁盘。如果FileSystem Cache在提交前，ES崩了，那数据不是丢失了吗？
因此，ES又引入一个概念：translog（事务日志）
每一次对 Elasticsearch 进行操作时均会进行translog的记录。所以，引入translog后的写数据过程，是这样的：
1. 一个文档被索引之后，就会被添加到内存缓冲区（In-memory buffer），并且 追加到了 translog 。
如下图所示：
2. 每秒钟通过refresh，会将In-memory buffer 中的数据写入FileSystem Cache，并清空In-memory buffer，注意，此时并不会清空translog，如下图所示：
3. 这个进程不断工作，Translog大小不断增加；此时，ES会执行一个Flush操作，该操作可以将Translog截断，清空原来的Translog区，并且，此时FileSystem Cache 中的内容也会持久化到磁盘。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d7ccc3dc548ce77945e1ccbbf0f3e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdafd3015404f6d0f5c1028bf6419086/" rel="bookmark">
			Python初学13——jieba库简介与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、jieba库基本介绍
二、jieba库的使用说明（三种模式、lcut()、lcut_for_search()、add_word() ）
三、“文本词频统计”实例
一、jieba库基本介绍 jieba 是一个中文分词第三方库，被称为最好的 Python 中文分词库。支持三种分词模式：精确模式、全模式和搜索引擎模式，并且支持繁体分词和自定义词典。用户只需掌握一个函数 lcut()用户使用前需要额外安装，安装过程参考“Python初学11”第二章（对应安装命令改为：pip install jieba） 简单说，jieba是一个非常好用的中文工具，以分词起家，但功能比分词要强大很多。而且，全国计算机等级考试二级Python语言必考jieba库。
二、jieba库的使用说明（三种模式、lcut()、lcut_for_search()、add_word() ） jieba分词依靠中文词库，确定汉字之间的关联概率。除了分词，用户还可以添加自定义的词组。
精确模式：把文本精确的切分开，不存在冗余单词
全模式：把文本中所有可能的词语都扫描出来，有冗余
搜索引擎模式：在精确模式的基础上，对长词再次切分
表2-1 jieba库常用函数 函数说明lcut(s) 精确模式
返回一个列表类型的分词结果
图2-1 lcut(s, cut_all=True) 全模式
返回一个列表类型的分词结果，存在冗余
图2-2 lcut_for_search(s) 搜索引擎模式
返回一个列表类型的分词结果，存在冗余
图2-3 add_word(w)向分词词典增加新词 w 三、“文本词频统计”实例 1. 需求：《三国演义》文章中，出现了哪些词？哪些词出现的次数最多？
注：网上搜索三国演义TXT文本下载，并将三国演义.txt文本与.py代码文件存放的同一路径下。
import jieba txt = open('三国演义.txt', 'r', encoding="utf-8").read() # 读取txt文本 words = jieba.lcut(txt) # 对文本进行分词 '对分词后的词语进行统计，不统计单字词语' counts = {} # 创建空字典 for i in words: if len(i) == 1: continue else: # 字典中的键为分词词语，值是对应分词出现的次数 counts[i] = counts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdafd3015404f6d0f5c1028bf6419086/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b37456cf7ebd066e6b4fb65c567de1f/" rel="bookmark">
			K-近邻算法（k-NN）的原理及python代码案例实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 K-NN算法的原理 1.1 K-NN概念 K Nearest Neighbor算法⼜叫KNN算法， 这个算法是机器学习⾥⾯⼀个⽐较经典的算法， 总体来说KNN算法是相对⽐
较容易理解的算法。
定义：
如果⼀个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某⼀个类别， 则该样本也属于这
个类别。（起源：KNN最早是由Cover和Hart提出的一种分类算法）；俗话就是：根据“邻居”来推断出你的类别。
1.2 基本流程 1)计算已知类别数据集中的点与当前点之间的距离2)按距离递增次序排序
3)选取与当前点距离最小的k个点
4)统计前k个点所在的类别出现的频率
5)返回前k个点出现频率最高的类别作为当前点的预测分类
什么意思呢？看下这张图
根据上来面的流程来讲：
1.给定了红色和蓝色的训练样本，绿色为测试样本
2.计算绿色点到其他点的距离
3.选取离绿点最近的k个点
4.选取k个点中，同种颜色最多的类。例如：k=1时，k个点全是蓝色，那预测结果就是Class 1；k=3时，k个点中两个红色一个蓝色，那预测结果就是Class 2
举个实例：电影类型分析
假设我们现在有几部电影，如下图所示：
其中9号电影属于什么电影类型的电影呢？如何去预测，我们可以利用k近邻算法的思想去算：
分别计算每个电影与9号电影之间的距离（这里采用欧氏距离算法），然后求解得到下图：
结果分析：由上图易知，当K= 3 时，三个都是喜剧片，根据判断法则，9号电影属于喜剧片；当K=5时，有三个喜剧片，有两个爱情片，根据判断法则，9号电影属于喜剧片；
1.3 K值的选择 k值过大：容易受到异常点的影响
K值过小：受到样本均衡的问题（如果不同种类的样本数量一样多，当 K=样本数/种类 时，就不能对未知数据进行分类判断）
K值选择问题，李航博士的一书「统计学习方法」上所说：
1) 选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；
2) 选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。
3) K=N（N为训练样本个数），则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的类，模型过于简单，忽略了训练实例中大量有用信息。
在实际应用中，K值一般取一个比较小的数值，例如采用交叉验证法（简单来说，就是把训练数据在分成两组:训练集和验证集）来选择最优的K值。
近似误差： 对现有训练集的训练误差，关注训练集，如果近似误差过小可能会出现过拟合的现象（过拟合：对现有的训练集能有很好的预测，但是对未知的测试样本将会出现较大偏差的预测。）模型本身不是最接近最佳模型。估计误差： 可以理解为对测试集的测试误差，关注测试集，估计误差小说明对未知数据的预测能力好，模型本身最接近最佳模型。 小结：
K值过小： 容易受到异常点的影响容易过拟合k值过大： 受到样本均衡的问题容易欠拟合 1.4距离公式内容的补充：（其它公式后期补上） 欧氏距离：
2 案例：鸢尾花种类预测 lris数据集是常用的分类实验数据集，由Fisher,1936收集整理。lris也称鸢尾花卉数据集，是一类多重变量分析的数据集。关于数据集的具体介绍:
2.1分析步骤 1.获取数据集
2.数据基本处理
3.特征⼯程
4.机器学习(模型训练)
5.模型评估
2.2代码实现 代码涉及sklean库，需要安装sklearn库，百度一下就知道怎么安装了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b37456cf7ebd066e6b4fb65c567de1f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/379/">«</a>
	<span class="pagination__item pagination__item--current">380/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/381/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>