<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1f8b3ff0a8be87d9640a8913f018e55/" rel="bookmark">
			获取流量水文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		获取流量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99c13acd5399bba6cf63715b14bc1ddb/" rel="bookmark">
			波奇学Linux：进程等待
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		僵尸进程(Z状态)无法被kill指令杀死，通过进程等待杀掉它，解决内存泄漏问题（进程处于僵尸态，仍然维护pcb结构体来解决问题）
通过进程等待，获得进程退出情况
wait回收僵尸态进程 我们可以看到进程由五秒后子进程从僵尸态销毁，wait可以杀掉僵尸态的进程
wait每次只能回收一个僵尸进程
循环等待回收多个僵尸态进程 阻塞等待
如果子进程不是僵尸态，父进程在调用wait()时会进入阻塞状态，等待子进程结束，这是软件的阻塞状态，等待外设输入，属于硬件的阻塞状态。
waitpid() wait的int* status获取子进程退出信息 status作为输出型参数，相当于传入一个空间，进程结束后把子进程的信息放入status指向的空间
status保存的内容
//00000000 00000000 00000000 00000000 (只看后16位) 00000000 //前8位退出码 0 // 第8位 core dump 0000000//1到7位 终止信号 信号码表示进程是否正常终止，退出码表示进程结束后，退出信息(return 0,exit(0) 0为退出码)
有信号码表示进程因为除0或者野指针等错误，不能正常终止。被操作系统干掉。
非阻塞轮询：父进程多次访问子进程结束状态 pid_t waitpid(pid_t pid,int *status,int options) options默认是0，默认情况下是阻塞方式，父进程会一直等待子进程，直到进程运行完。
当options的值是WNOHANG时，父进程不会阻塞，可以继续向下运行其他代码。
非阻塞轮询就是父进程不阻塞下在循环下多次间隔访问 waitpid的返回值大于0，等待正常，返回值小于0，等待失败（等待的进程不是父进程的子进程时）等于0，函数运行正常，但还没确定结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4b0d73dd7b72fe969d07e197fb76fd9/" rel="bookmark">
			[足式机器人]Part4 南科大高等机器人控制课 Ch09 Dynamics of Open Chains
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供学习使用
本文参考：
B站：CLEAR_LAB
笔者带更新-运动学
课程主讲教师：
Prof. Wei Zhang
南科大高等机器人控制课 Ch09 Dynamics of Open Chains 1. Introduction1.1 From Single Rigid Body to Open Chains1.2 Preview of Open-Chain Dynamics1.3 Lagrangian VS. Newton-Euler Methods 2. Inverse Dynamics: Recursive Newton-Euler Algorithm(RNEA)2.1 RNEA: Notations2.1.1 RNEA: Velocity and Accel. Propagation(Forward Pass) 2.1.2 RNEA: Force Propagation(Backward Pass)2.1.3 Recursive Newton-Euler Algorithm 3. Analytical Form of the Dynamics Model3.1 Structures in Dynamic Equation3.2 Properties of Dynamics Model of Multi-Body Systems 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4b0d73dd7b72fe969d07e197fb76fd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a0456d0ce6634f4716374ed12b5f007/" rel="bookmark">
			基于Python的课程案例研究系统的设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于Python的课程案例研究系统的设计和实现|计算机毕业设计|Java毕业设计|课程设计|Python毕设|小程序|毕业设计选题推荐 该项目采用技术Python的django框架、mysql数据库 ，项目含有源码、论文、PPT、配套开发软件、软件安装教程、项目发布教程、核心代码介绍视频等
技术路线： 软件开发环境及开发工具：
开发语言：python
使用框架：Django
前端技术：JavaScript、VUE.js（2.X）、css3
开发工具：pycharm、Visual Studio Code、HbuildX
数据库：MySQL 5.7.26（版本号）
数据库管理工具：phpstudy/Navicat或者phpstudy/sqlyog
python版本：python3.0及以上
主要功能： 前台注册用户的功能如下：
注册登录：用户填写个人信息，并验证手机号码进行账户注册，注册成功后方可登录系统。
章节学习：用户可以对章节知识进行学习。
题库练习：在线进行答题操作。
管理员功能如下：
修改密码：管理员可以随时修改自己进入系统的登录密码，以保证系统的安全性。
用户管理：对注册的商家、用户信息进行维护管理等。
章节知识管理：对章节知识进行维护，添加、删除、修改。
题库练习管理：对学生提交的练习信息进行维护管理。
毕业答辩流程： 具体的毕业答辩流程可能会根据学校和学院的规定有所不同，一般包括以下环节：
答辩准备：准备答辩展示材料和PPT，并详细准备自己对项目的阐述和回答问题的准备。展示与介绍：简要介绍项目的背景、目标和开发过程，强调项目的创新点和价值。报告：详细介绍项目的研究内容、方法和实际操作，包括需求分析、系统设计、功能实现、测试结果等。提问与答辩：教师、评委等提问，对项目的技术、创新、实际应用等方面进行深入探究，并回答评委的问题。答辩评价：评委根据自己的评分标准对毕业论文的质量和答辩表现进行评价。答辩结果：评委根据评分结果，最终确定论文的质量与成绩。 在答辩过程中，要充分展示对项目的深入研究和对技术的理解，结合实际案例和数据，清晰阐述项目的创新、可行性和应用价值，回答评委问题时要有条理、准确表达自己的观点。
祝您论文和答辩顺利进行！如有其他问题，我将尽力帮助您。
下面是资料信息截图： 下面是系统运行起来后的一些截图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d6743e1378a352a627d3f021e369a3/" rel="bookmark">
			基于Python的汽车销售系统的设计和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基于Python的汽车销售系统的设计和实现|计算机毕业设计|Java毕业设计|课程设计|Python毕设|小程序|毕业设计选题推荐 该项目采用技术Python的django框架、mysql数据库 ，项目含有源码、论文、PPT、配套开发软件、软件安装教程、项目发布教程、核心代码介绍视频等
技术路线： 软件开发环境及开发工具：
开发语言：python
使用框架：Django
前端技术：JavaScript、VUE.js（2.X）、css3
开发工具：pycharm、Visual Studio Code、HbuildX
数据库：MySQL 5.7.26（版本号）
数据库管理工具：phpstudy/Navicat或者phpstudy/sqlyog
python版本：python3.0及以上
主要功能： 前台用户的功能如下：
采购员用户：管理采购表、预售表。
仓管员用户：管理库存车辆，入库表，出库表。
销售员：库存车辆、预售表、销售表数据。
管理员功能：
修改密码：管理员可以随时修改自己进入系统的登录密码，以保证系统的安全性。
采购员管理、仓管员管理、销售员管理、管理员管理等。
库存车辆管理：查看车辆编号，状态，库存数量等。
采购管理：对不同车辆的采购时间，数量，品牌的管理。
入库管理：对各种车辆的入库时间，数量，颜色的管理。
出库管理：办理汽车销售金额统计等。
预售管理：对销售员，销售车辆，数量，销售车辆品牌的预售信息管理。
销售管理：对销售员，销售车辆，数量，销售车辆品牌的已售信息管理。
毕业答辩流程： 具体的毕业答辩流程可能会根据学校和学院的规定有所不同，一般包括以下环节：
答辩准备：准备答辩展示材料和PPT，并详细准备自己对项目的阐述和回答问题的准备。展示与介绍：简要介绍项目的背景、目标和开发过程，强调项目的创新点和价值。报告：详细介绍项目的研究内容、方法和实际操作，包括需求分析、系统设计、功能实现、测试结果等。提问与答辩：教师、评委等提问，对项目的技术、创新、实际应用等方面进行深入探究，并回答评委的问题。答辩评价：评委根据自己的评分标准对毕业论文的质量和答辩表现进行评价。答辩结果：评委根据评分结果，最终确定论文的质量与成绩。 在答辩过程中，要充分展示对项目的深入研究和对技术的理解，结合实际案例和数据，清晰阐述项目的创新、可行性和应用价值，回答评委问题时要有条理、准确表达自己的观点。
祝您论文和答辩顺利进行！如有其他问题，我将尽力帮助您。
下面是资料信息截图： 下面是系统运行起来后的一些截图： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae504f19a39aa212614d8f23124fc53/" rel="bookmark">
			c&#43;&#43;产生随机数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产生随机数 C++产生随机数的方法十分简单：**rand（）函数** C++产生随机数的方法十分简单：rand（）函数 此函数需要包含头文件：cstdlib
#include&lt;cstdlib&gt; 注意：rand()函数产生随机数的范围为0—32767
例如：产生一个随机数在1~100的范围之内。
int res=rand()%100+1;//生成随机数后与100取模，保证产生的随机数在0~99之内，加一即可在1~100之内 为了保证每次产生的随机数不相等，需要采用srand函数来设置随机种子。
但是要注意：采用time函数需要包括头文件ctime
#include&lt;ctime&gt; 法一：
srand((unsigned int) time(NULL));//参数包括srand函数包含的无符号整型和time函数所需要的指针类型(空指针)，其中(unsigned int)可以省略, 即srand((time(NULL))); 法二：
srand((time(0))); 1. 先生成1~100的随机数，取50到100的数并输出
代码实例：
随机生成100个50~100的随机数。
算法思想：
采用死循环方式，设置一个变量ans表示产生的随机数在50到100范围之内的个数，每次产生一个范围在1到100的随机数，如果这个随机数在50~100的范围之内，则将其输出，同时ans++，当ans的值等于100的时候，跳出循环即可。
#include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include&lt;queue&gt; #include&lt;string&gt; #include&lt;cmath&gt; #include&lt;cstring&gt; #include&lt;cstdlib&gt; #include&lt;ctype.h&gt; #include&lt;iomanip&gt; #include&lt;fstream&gt; #include&lt;ctime&gt; #include&lt;set&gt; #include&lt;map&gt; #include&lt;unordered_set&gt; #include&lt;unordered_map&gt; using namespace std; #define endl '\n' #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); typedef unsigned long long ULL; typedef pair&lt;int, int&gt; PII; typedef long long ll; const int N = 1e3 + 10, null = 0x3f3f3f3f,M=2*N; const double eps=1e-6; int main() { ios; int ans=0; //srand((unsigned int) time(NULL));//参数包括srand函数包含的无符号整型和time函数所需要的指针类型(空指针) srand((time(0)));// while(1) { int res=rand()%100+1;//产生一个1~100的随机数 if(res&gt;=50&amp;&amp;res&lt;=100) ans++,cout&lt;&lt;res&lt;&lt;endl; if(ans==100) break; } return 0; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae504f19a39aa212614d8f23124fc53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9460ca385effaaacc90b079adf70fc1/" rel="bookmark">
			windows批量删除文件——bat命令方法（用于内存清理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tips：可以直接点击目录中的【！！！错误*】查看你对应的报错情况
目录
1、思路
1.1 bat下的for循环格式：
！！！注意：
参数：
eg：
@echo off
pause
1.2 bat的删除
rd（删除目录）参数：
del（删除文件）参数：
2、实施
1、思路 遍历目标文件夹 → 删除文件
1.1 bat下的for循环格式： ！！！注意： 这有一个大坑，使用参数“\d”,“\r”时的格式有差异，除非不写路径，就在当前目录下执行，两者差不多。
for [参数] %%变量名 in (匹配符) do (执行的命令) \d: for \d %%变量名 in (路径\匹配符) do (执行的命令) \r: for \r 路径 %%变量名 in (匹配符) do (执行的命令) 参数： 无参：遍历当前文件夹下的文件/d：遍历当前文件夹下的子文件夹/r：深度遍历当前文件夹下的所有文件/l：迭代数值范围，使用迭代变量设置起始值，然后逐步执行一组范围的值，直到该值超过所设置的终止值（这里不详解）/f：用于解析文件内容（这里不详解） eg： # 写法1 @echo off for /r D:\Desktop\test %%i in (*.txt) do echo %%i pause # 写法2 @echo off for /r D:\Desktop\test %%i in (*) do ( echo %%i ) pause 同时想遍历文件夹和文件这样写（最好把括号都加上）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9460ca385effaaacc90b079adf70fc1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020fca5a58d950545a63bfead3f6c963/" rel="bookmark">
			js中国标准时间转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、将中国标准时间转换为 例如 2023-12-18 08:00:00 // 获取今天的日期 let today = new Date(); // 设置 beginDate 为今天的上午8点 let beginDate = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 8, 0, 0, 0); // 设置 finishDate 为 beginDate 的后三天的0点 let finishDate = new Date(beginDate.getFullYear(), beginDate.getMonth(), beginDate.getDate() + 3, 0, 0, 0,0); // 设置 publicityDate 为 finishDate 的后三天的0点 let publicityDate = new Date(finishDate.getFullYear(), finishDate.getMonth(), finishDate.getDate() + 3, 0, 0, 0,0); beginDate=formatDate(beginDate); finishDate=formatDate(finishDate); publicityDate=formatDate(publicityDate); 主要方法:
function formatDate(date){ let y = date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/020fca5a58d950545a63bfead3f6c963/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1793637b89324f8c25e0d34245d8f92d/" rel="bookmark">
			压力测试过程中内存溢出（堆溢出、栈溢出、持久代溢出）情况如何解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在压力测试过程中，可能会遇到内存溢出的问题，其中常见的包括堆内存溢出、栈内存溢出和持久代溢出。解决这类问题需要首先理解各种内存溢出的原因和特点。
堆内存溢出：这种情况通常发生在稳定性压测一段时间后，系统报错，日志报java.lang.OutOfMemoryError.Java heap space。可以通过使用jmap -histo pid | head -20
命令来dump堆内存使用情况，查看堆内存排名前20个对象，看是否有自己应用程序。
栈内存溢出：栈溢出通常是由于程序所要求的栈深度过大，线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError。Java的栈空间默认是1M大小，可以通过 -Xss 调整。
持久代溢出：持久代是用于存放Class对象的，如果Class对象未被释放，Class对象占用信息过多，有过多的Class对象，就可能发生持久代溢出。
对于解决这些问题的策略，可以从以下几个方面入手：
1.优化代码：检查代码中是否存在内存泄漏或者不必要的对象创建，优化这些部分可以减少内存的使用。
2.增加JVM堆大小：如果内存溢出是由于堆空间不足导致的，可以尝试增加JVM堆的大小，以提供更多的内存空间。
3.调整垃圾回收策略：可以尝试调整JVM的垃圾回收策略，如使用G1垃圾回收器或者调整新生代和老年代的比例，以提高内存的使用效率。
4.使用内存映射文件：如果内存溢出是由于持久代空间不足导致的，可以尝试使用内存映射文件来存储持久化数据，以减少持久代的使用。
5.分布式测试：如果测试环境允许，可以将压力测试分布到多台机器上进行，以分担单个机器的内存负载。
6.限制内存使用：在测试环境中，可以使用操作系统的资源管理工具，如Linux的cgroups或Windows的Job Objects，来限制被测试应用程序的内存使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe3d3cbdea273f2f55618b795d4fe5c6/" rel="bookmark">
			人体关键点检测4：C/C&#43;&#43;实现人体关键点检测(人体姿势估计)含源码 可实时检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人体关键点检测4：C/C++实现人体关键点检测(人体姿势估计)含源码 可实时检测 目录
人体关键点检测4：C/C++实现人体关键点检测(人体姿势估计)含源码 可实时检测
1.项目介绍
2.人体关键点检测方法
(1)Top-Down(自上而下)方法
(2)Bottom-Up(自下而上)方法：
3.人体关键点检测模型
（1） 人体关键点检测模型的训练
（2） 将Pytorch模型转换ONNX模型
（3） 将ONNX模型转换为TNN模型
4.人体关键点检测C/C++部署
（1）项目结构
（2）配置开发环境(OpenCV+OpenCL+base-utils+TNN)
（3）部署TNN模型
（4）CMake配置
（5）main源码
（6）源码编译和运行
（7）Demo测试效果 5.项目源码下载
6.人体关键点检测Android版本
1.项目介绍 人体关键点检测（Human Keypoints Detection）又称为人体姿态估计2D Pose，是计算机视觉中一个相对基础的任务，是人体动作识别、行为分析、人机交互等的前置任务。一般情况下可以将人体关键点检测细分为单人/多人关键点检测、2D/3D关键点检测，同时有算法在完成关键点检测之后还会进行关键点的跟踪，也被称为人体姿态跟踪。
项目将实现人体关键点检测算法，其中使用YOLOv5模型实现人体检测(Person Detection)，使用HRNet，LiteHRNet和Mobilenet-v2模型实现人体关键点检测。为了方便后续模型工程化和Android平台部署，项目支持高精度HRNet检测模型，轻量化模型LiteHRNet和Mobilenet模型训练和测试，并提供Python/C++/Android多个版本；项目分为数据集说明，模型训练和C++/Android部署等多个章节，本篇是项目《人体关键点检测(人体姿势估计)》系列文章之C/C++实现人体关键点检测(人体姿势估计)，主要分享将Python训练好的模型移植到C/C++平台，搭建一个可实时的人体关键点检测C/C++ Demo，且支持多人关键点检测。
轻量化Mobilenet-v2模型在普通Android手机上可以达到实时的检测效果，CPU(4线程)约50ms左右，GPU约30ms左右 ，基本满足业务的性能需求。下表格给出HRNet，以及轻量化模型LiteHRNet和Mobilenet的计算量和参数量，以及其检测精度。
模型input-sizeparams(M)GFLOPsAPHRNet-w32192×25628.48M5734.05M0.7585LiteHRNet18192×2561.10M182.15M0.6237Mobilenet-v2192×2562.63M529.25M0.6181 【尊重原创，转载请注明出处】https://blog.csdn.net/guyuealian/article/details/134881831
C/C++版本人体关键点检测与Python版本的检测效果基本一致：
更多项目《人体关键点检测(人体姿势估计)》系列文章请参考： 人体关键点检测1：人体姿势估计数据集(含下载链接) https://blog.csdn.net/guyuealian/article/details/134703548人体关键点检测2：Pytorch实现人体关键点检测(人体姿势估计)含训练代码和数据集 https://blog.csdn.net/guyuealian/article/details/134837816人体关键点检测3：Android实现人体关键点检测(人体姿势估计)含源码 可实时检测 https://blog.csdn.net/guyuealian/article/details/134881797人体关键点检测4：C/C++实现人体关键点检测(人体姿势估计)含源码 可实时检测 https://blog.csdn.net/guyuealian/article/details/134881831手部关键点检测1：手部关键点(手部姿势估计)数据集(含下载链接)https://blog.csdn.net/guyuealian/article/details/133277630手部关键点检测2：YOLOv5实现手部检测(含训练代码和数据集)https://blog.csdn.net/guyuealian/article/details/133279222手部关键点检测3：Pytorch实现手部关键点检测(手部姿势估计)含训练代码和数据集https://blog.csdn.net/guyuealian/article/details/133277726手部关键点检测4：Android实现手部关键点检测(手部姿势估计)含源码 可实时检测https://blog.csdn.net/guyuealian/article/details/133931698手部关键点检测5：C++实现手部关键点检测(手部姿势估计)含源码 可实时检测https://blog.csdn.net/guyuealian/article/details/133277748 2.人体关键点检测方法 目前主流的人体关键点检测(人体姿势估计)方法主要两种：一种是Top-Down（自上而下）方法，另外一种是Bottom-Up（自下而上）方法；
(1)Top-Down(自上而下)方法 将人体检测和人体关键点检测(人体姿势估计)检测分离，在图像上首先进行人体目标检测，定位人体位置；然后crop每一个人体图像，再估计人体关键点；这类方法往往比较慢，但姿态估计准确度较高。目前主流模型主要有CPN，Hourglass，CPM，Alpha Pose，HRNet等。
(2)Bottom-Up(自下而上)方法： 先估计图像中所有人体关键点，然后在通过Grouping的方法组合成一个一个实例；因此这类方法在测试推断的时候往往更快速，准确度稍低。典型就是COCO2016年人体关键点检测冠军Open Pose。
通常来说，Top-Down具有更高的精度，而Bottom-Up具有更快的速度；就目前调研而言， Top-Down的方法研究较多，精度也比Bottom-Up（自下而上）方法高。本项目采用Top-Down(自上而下)方法，先使用YOLOv5模型实现人体检测，然后再使用HRNet进行人体关键点检测(人体姿势估计)；
本项目基于开源的HRNet进行改进，关于HRNet项目请参考GitHub
HRNet: https://github.com/leoxiaobin/deep-high-resolution-net.pytorch
3.人体关键点检测模型 （1） 人体关键点检测模型的训练 本项目采用Top-Down(自上而下)方法，使用YOLOv5模型实现人体检测，并基于开源的HRNet实现人体关键点检测(人体姿态估计)；为了方便后续模型工程化和Android平台部署，项目支持轻量化模型LiteHRNet和Mobilenet模型训练和测试，并提供Python/C++/Android多个版本；轻量化Mobilenet-v2模型在普通Android手机上可以达到实时的检测效果，CPU(4线程)约50ms左右，GPU约30ms左右 ，基本满足业务的性能需求
本篇博文主要分享Android版本的模型部署，不包含Python版本的训练代码和相关数据集，关于人体关键点检测的训练方法和数据集说明，可参考 : Pytorch实现人体关键点检测(人体姿势估计)含训练代码和数据集 https://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe3d3cbdea273f2f55618b795d4fe5c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e737fc8ee273903e3544fb85d552f53/" rel="bookmark">
			最全的用户数据指标解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是指标？
现代管理学之父 彼得·德鲁克 提出用管理促进企业增长，他讲过一句非常经典的话：如果你不能衡量，那么你就不能有效增长。
那么，如何去衡量呢？
就是用某个统一标准去衡量业务，这个统一标准就是指标。
2.什么是用户数据？
用户数据是指用户的基本情况，包括姓名、性别、邮箱、年龄、家庭住址、教育水平、职业等。
3.常用的用户数据指标有哪些？
如果把一款产品看作我的一个鱼塘，那么使用产品的用户就是鱼塘里的鱼。上次我聊到一款产品有3种用户：新增用户，活跃用户，留存用户。其中活跃用户对应的是不活跃用户，留存用户对应的是流失用户。
村里有很多人都有鱼塘，为了成为村里的首富，娶到村长的女儿，实现人生逆袭。我必须找到合适的指标来衡量鱼塘的鱼，从而制定对应的运营策略，才能靠养鱼赚到钱。
对于新增用户使用指标：日新增用户
对于活跃用户使用指标：活跃率
对于留存用户使用指标：留存率
下面我们分布来看下这3个用户数据指标。
(1)日新增用户
日新增用户：就是产品每天新增用户是多少。
比如微信公众号的日新增用户是指每天新关注微信公众号的人数。下面图片里是我微信公众号（猴子聊人物）最近30天的日新增用户，将每天新增用户用折线连起来，就可以看出用户增长或者下跌的趋势。
为什么要关注新增用户呢？
一个产品如果没有用户增长，用户数就会慢慢减少，越来越惨淡，比如人人网。
同时，新增用户来自产品推广的渠道，如果按渠道维度来拆解新增用户，我们可以看出不同渠道分别新增了多少用户，从而判断出渠道推广的效果。
(2)活跃率
怎么定义活跃呢？是指某个用户登陆了app算活跃用户？还是打开使用了app里哪个功能算活跃用户？
不同的产品定义不一样，所以看到这样的指标，一定要要搞清楚活跃是怎么定义的。
活跃用户数按时间又分为日活跃用户数(简称日活,DAU，Daily Active User)，周活跃用户数，月活跃用户数。
日活跃用户数(简称日活,DAU)：一天之内活跃的用户数。比如把打开微信公众号文章定义为活跃，日活跃用户数就是一天内打开微信公众号文章的人数。
周活跃用户数：一周之内至少活跃一次的用户总数。比如把打开微信公众号文章定义为活跃，周活跃用户数就是一周内打开微信公众号文章的人数。
月活跃用户数：一个月之内至少活跃一次的用户总数。比如把打开微信公众号文章定义为活跃，月活跃用户数就是一个月内打开微信公众号文章的人数。
上面图片中是三大电商2018年3月的累计月活跃人数。
需要注意的是，统计人数要去掉重复的数据，比如小明每天都在看我的微信公众号文章，每天活跃1次，一个月30天活跃30次。那么，月活跃人数是30吗？
当然不是，一个人一个月内活跃多次，也算1个人。所以活跃人数是1。
活跃率：是活跃用户在总用户数的占比，用活跃用户数除以总用户数。
根据时间可分为日活跃率、周活跃率、月活跃率等。
3）留存率
什么是留存？
通过渠道推广过来的新用户，经过一段时间可能会有一部分用户逐渐流失了，那么留下来的用户就称为留存，也就是有多少人留下来了。
所以留存和流失正好是相反的概念，好比一对分手的恋人，一个爱上了别人跑了，一个还爱着对方，留在原地。
我还是通过微信公众号来举例，把取消关注微信公众号的用户定义为流失，那么关注微信公众号的用户就是留存用户。上面图片里是我微信公众号后台的数据，7月1日有117人新关注了我的微信公众号，其中有14人又取消了关注，那么这新关注人里，剩下的103人就是这一天的留存用户数。
再比如在游戏app中，通过渠道推来的新用户，在一段时间内还会再再次登录游戏账号的就是留存用户。
为什么要关注留存呢？
可以评估产品功能对用户的黏性。如果一个产品留存低，那么说明用户对产品的黏性就小，就要想办法来提高留存了。留存反映了不同时期获得新用户的流失情况，如果留存低，就要找到用户流失的具体原因。
反映用户留存的指标，用留存率来表示。
留存率：（第1天新增的用户中，在第N天使用过产品的用户数）/第1天新增总用户数
这里需要注意的是“使用过产品”，不同的业务这块定义的不一样，要根据具体情况来确定，比如微信公众号使用过产品是指还关注该公众号。一款app，使用过产品是指打开过app。
根据时间，留存率又分为次日留存率，第7日留存率，第30日留存率等
次日留存率：（当天新增的用户中，在第2天使用过产品的用户数）/第一天新增总用户数
第3日留存率：（第一天新增用户中，在第3天使用过产品的用户数）/第一天新增总用户数
第7日留存率：（第一天新增的用户中，在第7天使用过产品的用户数）/第一天新增总用户数
第30日留存率：（第一天新增的用户中，在第30天使用过产品的用户数）/第一天新增总用户数
举个例子，某个app，我们把打开app定义为使用过产品。第一天新增用户100个，第二天这100个人里有40个人打开过app，那么次日留存率=40/100=40%。如果第七天这100个人人里有20个人打开过app，那么称七日留存率=40/100=20%
Facebook有一个著名的40-20-10法则，即新用户次日留存率为40%，7日留存率为20%，30日留存率为10%，有这个表现的产品属于数据比较好的。
4.总结
用户数据指标，记住这张鱼塘的案例图就可以了。用户数据指标有3个：日新增用户，活跃率，留存率。
我是猴子，中科院硕士/前IBM高级软件工程师/豆瓣8分《数据分析思维》作者，我在知乎知学堂上线了一个数据分析课程，结合IBM项目经验和国内互联网大厂一线业务案例，讲解常用模型+逻辑框架，还有常用数据分析工具带练+业务实操带练，数据分析技能和思维两条腿走路，让你成为真正的数据分析师，而不是数据处理工具人。
无论你是想学习个辅助工作的技能，还是想转行数据分析，都可以点击文末阅读原文链接学习：
往
一张图看懂sql运行顺序
期
领导让我预测下一年销量，怎么办？
回
一张图看懂数据分析、机器学习、深度学习、人工智能的关系
顾
带你了解数据分析的日常工作
⬇️点击「阅读原文」
进入 数据分析训练营
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1adcb37c1551f40d15a5ca704991d032/" rel="bookmark">
			【【深入浅出了解IIC协议】】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深入浅出了解IIC协议 SCL ： 传输时钟信号
SDA ： 传输数据信号
1.空闲状态 ：
SDA 与 SCL都处于高电平
2.起始状态 ：
在SCL为高的时候 主设备控制 SDA 从1 到 0 在进入起始位之后，我们把SCL翻转 从设备开始等待主机传输地址
3.发送阶段 ：
先发送地址 确定的是哪一个设备 ，每个地址的编号都是唯一的
主设备按照从高到低的顺序，依次发送地址
并且附带上 读写控制位
读写控制位 0表示 主机对从机写 1表示 主机对从机读
因为SCL是时钟线 SDA传输数据 所以我们在SCL低的时候将 数据放到 SDA上
在SCL为高时 开始对SDA的数据进行采样
4.响应位 ;
我们观察 整个数据传输 会发现最后还剩下了一个 响应位
主机开始的时候 拥有对SDA的绝对控制权
（ 我们在传输完地址之后 怎么表示正确传输了 这就需要从机来确认）
所以主机 在传输完成后 释放对SDA的控制 因为SDA 默认为拉高的状态 我们释放之后 交由 从机控制 如果从机接受到了响应 那么就把 高电平拉至 低电平 完成响应 表示我正确接收到了地址信息
5.数据位：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1adcb37c1551f40d15a5ca704991d032/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a379e2cbfd3978ecd7a733f84df0bf1/" rel="bookmark">
			Vue集成UEditor puls富文本编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前端配置： 1、下载代码https://gitee.com/modstart-lib/ueditor-plus/tree/master
2、解压压缩包，如下图
3、拿到dist文件夹的内容，重命名为UEditor，并将其复制到vue项目的public下，如图
4、安装UEditor插件 npm i vue-ueditor-wrap
5、全局挂载组件或引用组件（二选一）
全局挂载组件：找到main.js 加入一下代码：
import VueUeditorWrap from 'vue-ueditor-wrap'; Vue.component('VueUeditorWrap', VueUeditorWrap) 如图：
引用组件：在具体用到富文本的页面加入一下代码，
import VueUeditorWrap from 'vue-ueditor-wrap'; components:{ //VueUeditorWrapA //**更正代码231109** VueUeditorWrap } 具体位置如图：
6、使用富文本编辑器，在具体位置引用
&lt;vue-ueditor-wrap v-model="form.content" editor-id="editor" :config="editorConfig" :editorDependencies="['ueditor.config.js','ueditor.all.js']" style="height:500px;"/&gt; 其中在data里定义editorConfig（注意UEDITOR_HOME_URL的写法）：
增加一行 UEDITOR_CORS_URL: ‘/UEditor/’, 不然部分组件点击会跳出404页面
editorConfig: { //serverUrl: process.env.VUE_APP_BASE_API + "/config"', //**更正代码231109** serverUrl: process.env.VUE_APP_BASE_API + "/config", UEDITOR_HOME_URL: '/UEditor/', //**代码补充231218** UEDITOR_CORS_URL: '/UEditor/', zIndex: 99999,//设置z轴顺序值，避免工具栏下拉组件被遮挡 }, serverUrl需后端提供接口，实现相关上传功能。
至此前端基本配置完成，运行效果如图，其他更多功能配置，请查阅官方文档。
二、后端java配置 1、引入依赖：
&lt;dependency&gt; &lt;groupId&gt;com.blingblingbang&lt;/groupId&gt; &lt;artifactId&gt;ueditor&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; 2、在resource下添加config文件夹并加入config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a379e2cbfd3978ecd7a733f84df0bf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae2cbf21bc60fd7c502cb9e9caf2e1d/" rel="bookmark">
			人体关键点检测2：Pytorch实现人体关键点检测(人体姿势估计)含训练代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人体关键点检测2：Pytorch实现人体关键点检测(人体姿势估计)含训练代码 目录
人体关键点检测2：Pytorch实现人体关键点检测(人体姿势估计)含训练代码
1. 前言
2.人体关键点检测方法
(1)Top-Down(自上而下)方法
(2)Bottom-Up(自下而上)方法：
3.人体关键点检测数据集
4.人体检测模型训练
5.人体关键点检测模型训练
（1）项目安装
（2）准备Train和Test数据
（3）配置文件configs
（4）开始训练
（5）Tensorboard可视化训练过程
6.人体关键点检测检测模型效果
7.人体关键点检测(推理代码)下载
8.人体关键点检测(训练代码)下载
9.人体关键点检测C++/Android版本
1. 前言 人体关键点检测（Human Keypoints Detection）又称为人体姿态估计2D Pose，是计算机视觉中一个相对基础的任务，是人体动作识别、行为分析、人机交互等的前置任务。一般情况下可以将人体关键点检测细分为单人/多人关键点检测、2D/3D关键点检测，同时有算法在完成关键点检测之后还会进行关键点的跟踪，也被称为人体姿态跟踪。
本项目将实现人体关键点检测算法，其中使用YOLOv5模型实现人体检测(Person Detection)，使用HRNet，LiteHRNet和Mobilenet-v2模型实现人体关键点检测。项目分为数据集说明，模型训练和C++/Android部署等多个章节，本篇是项目《人体关键点检测(人体姿势估计)》系列文章之Pytorch实现人体关键点检测(人体姿势估计)；为了方便后续模型工程化和Android平台部署，项目支持高精度HRNet检测模型，轻量化模型LiteHRNet和Mobilenet模型训练和测试，并提供Python/C++/Android多个版本；
轻量化Mobilenet-v2模型在普通Android手机上可以达到实时的检测效果，CPU(4线程)约50ms左右，GPU约30ms左右 ，基本满足业务的性能需求。下表格给出HRNet，以及轻量化模型LiteHRNet和Mobilenet的计算量和参数量，以及其检测精度
模型input-sizeparams(M)GFLOPsAPHRNet-w32192×25628.48M5734.05M0.7585LiteHRNet18192×2561.10M182.15M0.6237Mobilenet-v2192×2562.63M529.25M0.6181 先展示一下人体关键点检测效果：
Android人体关键点检测APP Demo体验(下载)：https://download.csdn.net/download/guyuealian/88610359
【尊重原创，转载请注明出处】https://blog.csdn.net/guyuealian/article/details/134837816
更多项目《人体关键点检测(人体姿势估计)》系列文章请参考：
人体关键点检测1：人体姿势估计数据集(含下载链接) https://blog.csdn.net/guyuealian/article/details/134703548人体关键点检测2：Pytorch实现人体关键点检测(人体姿势估计)含训练代码和数据集 https://blog.csdn.net/guyuealian/article/details/134837816人体关键点检测3：Android实现人体关键点检测(人体姿势估计)含源码 可实时检测 https://blog.csdn.net/guyuealian/article/details/134881797人体关键点检测4：C/C++实现人体关键点检测(人体姿势估计)含源码 可实时检测 https://blog.csdn.net/guyuealian/article/details/134881831手部关键点检测1：手部关键点(手部姿势估计)数据集(含下载链接)https://blog.csdn.net/guyuealian/article/details/133277630手部关键点检测2：YOLOv5实现手部检测(含训练代码和数据集)https://blog.csdn.net/guyuealian/article/details/133279222手部关键点检测3：Pytorch实现手部关键点检测(手部姿势估计)含训练代码和数据集https://blog.csdn.net/guyuealian/article/details/133277726手部关键点检测4：Android实现手部关键点检测(手部姿势估计)含源码 可实时检测https://blog.csdn.net/guyuealian/article/details/133931698手部关键点检测5：C++实现手部关键点检测(手部姿势估计)含源码 可实时检测https://blog.csdn.net/guyuealian/article/details/133277748 2.人体关键点检测方法 目前主流的人体关键点检测(人体姿势估计)方法主要两种：一种是Top-Down（自上而下）方法，另外一种是Bottom-Up（自下而上）方法；
(1)Top-Down(自上而下)方法 将人体检测和人体关键点检测(人体姿势估计)检测分离，在图像上首先进行人体目标检测，定位人体位置；然后crop每一个人体图像，再估计人体关键点；这类方法往往比较慢，但姿态估计准确度较高。目前主流模型主要有CPN，Hourglass，CPM，Alpha Pose，HRNet等。
(2)Bottom-Up(自下而上)方法： 先估计图像中所有人体关键点，然后在通过Grouping的方法组合成一个一个实例；因此这类方法在测试推断的时候往往更快速，准确度稍低。典型就是COCO2016年人体关键点检测冠军Open Pose。
通常来说，Top-Down具有更高的精度，而Bottom-Up具有更快的速度；就目前调研而言， Top-Down的方法研究较多，精度也比Bottom-Up（自下而上）方法高。本项目采用Top-Down(自上而下)方法，先使用YOLOv5模型实现人体检测，然后再使用HRNet进行人体关键点检测(人体姿势估计)；
本项目基于开源的HRNet进行改进，关于HRNet项目请参考GitHub
HRNet: https://github.com/leoxiaobin/deep-high-resolution-net.pytorch
3.人体关键点检测数据集 本项目主要使用COCO数据集和MPII数据集，关于人体关键点检测数据集说明，请参考《人体关键点检测1：人体姿势估计数据集》https://blog.csdn.net/guyuealian/article/details/134703548
4.人体检测模型训练 本项目采用Top-Down(自上而下)方法，使用YOLOv5模型实现人体目标检测，使用HRNet进行人体关键点检测(人体姿势估计)；关于人体检测模型训练方法，可参考 :
行人检测(人体检测)2：YOLOv5实现人体检测(含人体检测数据集和训练代码)
5.人体关键点检测模型训练 整套工程项目基本结构如下：
. ├── configs # 训练配置文件 ├── data # 一些数据 ├── libs # 一些工具库 ├── pose # 姿态估计模型文件 ├── work_space # 训练输出工作目录 ├── demo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ae2cbf21bc60fd7c502cb9e9caf2e1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e996b440b3a9afc1a7bf984f69e3d7c4/" rel="bookmark">
			手部关键点检测5：C&#43;&#43;实现手部关键点检测(手部姿势估计)含源码 可实时检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手部关键点检测5：C++实现手部关键点检测(手部姿势估计)含源码 可实时检测 目录
手部关键点检测4：C++实现手部关键点检测(手部姿势估计)含源码 可实时检测
1.项目介绍
2.手部关键点检测(手部姿势估计)方法
(1)Top-Down(自上而下)方法
(2)Bottom-Up(自下而上)方法：
3.手部关键点检测模型
（1） 手部关键点检测模型的训练
（2） 将Pytorch模型转换ONNX模型
（3） 将ONNX模型转换为TNN模型
4.手部关键点检测C/C++部署
（1）项目结构
（2）配置开发环境(OpenCV+OpenCL+base-utils+TNN)
（3）部署TNN模型
（4）CMake配置
（5）main源码
（6）源码编译和运行
（7）Demo测试效果 5.项目源码下载
1.项目介绍 本篇文章是项目《手部关键点检测(手部姿势估计)》系列文章之《C++实现手部关键点检测(手部姿势估计)含源码 可实时检测》；项目基于Pytorch深度学习框架，实现手部关键点检测(手部姿势估计)模型，其中手部检测采用YOLOv5模型，手部关键点检测是基于开源的HRNet进行改进，构建了整套手部关键点检测的训练和测试流程；为了方便后续模型工程化和Android平台部署，项目支持高精度HRNet检测模型，轻量化模型LiteHRNet和Mobilenet模型训练和测试，并提供Python/C++/Android多个版本；
本篇主要分享将Python训练后的手部检测和手部关键点检测模型部署到C/C++平台。我们将开发一个简易的、可实时运行的手部关键点检测的C/C++ Demo。下表格给出HRNet，以及轻量化模型LiteHRNet和Mobilenet的计算量和参数量，以及其检测精度
模型input-sizeparams(M)GFLOPsAPHRNet-w32192×19228.48M5734.05M0.8570LiteHRNet18192×1921.10M182.15M0.8023Mobilenet-v2192×1922.63M529.25M0.7574 先展示一下C/C++版本的手部检测以及手部关键点检测(手部姿势估计)效果：
Android手部关键点检测(手部姿势估计)APP Demo体验：
https://download.csdn.net/download/guyuealian/88418582
【尊重原创，转载请注明出处】https://blog.csdn.net/guyuealian/article/details/133277748
更多项目《手部关键点检测(手部姿势估计)》系列文章请参考：
人体关键点检测1：人体姿势估计数据集(含下载链接) https://blog.csdn.net/guyuealian/article/details/134703548人体关键点检测2：Pytorch实现人体关键点检测(人体姿势估计)含训练代码和数据集 https://blog.csdn.net/guyuealian/article/details/134837816人体关键点检测3：Android实现人体关键点检测(人体姿势估计)含源码 可实时检测 https://blog.csdn.net/guyuealian/article/details/134881797人体关键点检测4：C/C++实现人体关键点检测(人体姿势估计)含源码 可实时检测 https://blog.csdn.net/guyuealian/article/details/134881831手部关键点检测1：手部关键点(手部姿势估计)数据集(含下载链接)https://blog.csdn.net/guyuealian/article/details/133277630手部关键点检测2：YOLOv5实现手部检测(含训练代码和数据集)https://blog.csdn.net/guyuealian/article/details/133279222手部关键点检测3：Pytorch实现手部关键点检测(手部姿势估计)含训练代码和数据集https://blog.csdn.net/guyuealian/article/details/133277726手部关键点检测4：Android实现手部关键点检测(手部姿势估计)含源码 可实时检测https://blog.csdn.net/guyuealian/article/details/133931698手部关键点检测5：C++实现手部关键点检测(手部姿势估计)含源码 可实时检测https://blog.csdn.net/guyuealian/article/details/133277748 ​
2.手部关键点检测(手部姿势估计)方法 手部关键点检测(手部姿势估计)的方法，目前主流的方法主要两种：一种是Top-Down（自上而下）方法，另外一种是Bottom-Up（自下而上）方法；
(1)Top-Down(自上而下)方法 将手部检测和手部关键点估计分离，在图像上首先进行手部目标检测，定位手部位置；然后crop每一个手部图像，再估计每个手部的关键点；这类方法往往比较慢，但姿态估计准确度较高。目前主流模型主要有CPN，Hourglass，CPM，Alpha Pose，HRNet等。
(2)Bottom-Up(自下而上)方法： 先估计图像中所有手部的关键点，然后在通过Grouping的方法组合成一个一个手部实例；因此这类方法在测试推断的时候往往更快速，准确度稍低。典型就是COCO2016年人体关键点检测冠军Open Pose。
通常来说，Top-Down具有更高的精度，而Bottom-Up具有更快的速度；就目前调研而言， Top-Down的方法研究较多，精度也比Bottom-Up（自下而上）方法高。
本项目基于开源的HRNet进行改进，关于HRNet项目请参考GitHub
HRNet: https://github.com/leoxiaobin/deep-high-resolution-net.pytorch
3.手部关键点检测模型 （1） 手部关键点检测模型的训练 本篇博文主要分享C++版本的模型部署，不包含Python版本的手部关键点检测以及相关训练代码，关于手部关键点检测的训练方法和数据集说明，请参考本人另一篇博文《手部关键点检测3：Pytorch实现手部关键点检测(手部姿势估计)含训练代码和数据集》手部关键点检测3：Pytorch实现手部关键点检测(手部姿势估计)含训练代码和数据集-CSDN博客
（2） 将Pytorch模型转换ONNX模型 目前CNN模型有多种部署方式，可以采用TNN，MNN,NCNN，以及TensorRT等部署工具，鄙人采用TNN进行C/C++端上部署。部署流程可分为四步：训练模型-&gt;将模型转换ONNX模型-&gt;将ONNX模型转换为TNN模型-&gt;C/C++部署TNN模型。
训练好Pytorch模型后，我们需要先将模型转换为ONNX模型，以便后续模型部署。
原始项目提供转换脚本，你只需要修改model_file为你模型路径即可 convert_torch_to_onnx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e996b440b3a9afc1a7bf984f69e3d7c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24625c17a3f1d4b64a377fa9c05f3a10/" rel="bookmark">
			21.Servlet 技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaWeb应用的概念 在Sun的Java Servlet规范中，对Java Web应用作了这样定义：“Java Web应用由一组Servlet、HTML页、类、以及其它可以被绑定的资源构成。它可以在各种供应商提供的实现Servlet规范的 Servlet容器 中运行。”
Java Web应用中可以包含如下内容:
• Servlet
• JSP
• 实用类
• 静态文档如HTML、图片等
• 描述Web应用的信息（web.xml）
Servelt 与 Servlet 容器 Servlet容器的概念 Servlet容器为JavaWeb应用提供运行时环境，它负责管理Servlet和JSP的生命周期，以及管理它们的共享数据。Servlet容器也称为JavaWeb应用容器，或者Servlet/JSP容器。
目前最流行的Servlet容器软件括:
• Tomcat
• Resin
• J2EE服务器（如Weblogic）中也提供了内置的Servlet容器
Servlet 简介 Java Servlet是和平台无关的服务器端组件，它运行在Servlet容器中。Servlet容器负责Servlet和客户的通信以及调用Servlet的方法，Servlet和客户的通信采用“请求/响应”的模式。
Servlet可完成如下功能：
• 处理请求；
• 发出响应
Servlet容器响应客户请求的过程 ServletAPI Servlet 创建的三种方式 实现 Servlet 接口
继承 HttpServlet 类
继承 GenericServlet 类（几乎不用）
Servlet的注册与运行 • Servlet程序必须通过Servlet容器来启动运行，并且储存目录有特殊要求，通需要存储在&lt;WEB应用程序目录&gt;\WEB-INF\classes\目录中。
• Servlet程序必须在WEB应用程序的web.xml文件中进行注册和映射其访问路径，才可以被Servlet引擎加载和被外界访问。
• 一个元素用于注册一个Servlet，它包含有两个主要的子元素：和，分别用于设置Servlet的注册名称和Servlet的完整类名。
• 一个元素用于映射一个已注册的Servlet的一个对外访问路径，它包含有两个子元素：和，分别用于指定Servlet的注册名称和Servlet的对外访问路径。
Servlet映射的细节 • 同一个Servlet可以被映射到多个URL上，即多个元素的子元素的设置值可以是同一个Servlet的注册名。
• 在Servlet映射到的URL中也可以使用通配符，但是只能有两种固定的格式：一种格式是“.扩展名”，另一种格式是以正斜杠（/）开头并以“/*”结尾。
Servlet容器响应客户请求的过程 • ①Servlet引擎检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24625c17a3f1d4b64a377fa9c05f3a10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b83c93a06ba841913edefee4cfc4f9f2/" rel="bookmark">
			Linux面试题分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Linux？
答：Linux是一种开源的操作系统内核，它是基于UNIX的设计原理和哲学而开发的。
Linux的主要特点是什么？
答：Linux的主要特点包括开源、可定制性强、多用户、多任务、稳定性高以及良好的网络支持等。
Linux的发行版有哪些？
答：常见的Linux发行版有Ubuntu、Debian、Fedora、CentOS、Red Hat等。
什么是Shell？
答：Shell是Linux操作系统中的命令行解释器，它接收用户的命令并将其转化为操作系统能够理解的指令。
如何在Linux系统中查看文件内容？
答：可以使用命令cat、less或者more来查看文件内容。
如何在Linux系统中查找文件？
答：可以使用命令find来查找文件，例如find / -name filename可以在根目录下查找名为filename的文件。
如何在Linux系统中安装软件包？
答：可以使用包管理工具如apt、yum等来安装软件包，具体命令取决于所使用的Linux发行版。
如何在Linux系统中管理用户和用户组？
答：可以使用命令useradd和userdel来添加和删除用户，使用命令groupadd和groupdel来添加和删除用户组。
如何在Linux系统中设置文件和文件夹的权限？
答：可以使用命令chmod来设置文件和文件夹的权限，例如chmod 755 filename将文件的权限设置为rwxr-xr-x。
如何在Linux系统中查看系统日志？
答：可以使用命令dmesg或者查看/var/log目录下的日志文件来查看系统日志。
如何在Linux系统中查看当前的IP地址？
答：可以使用命令ifconfig或者ip addr来查看当前的IP地址。
如何在Linux系统中查看系统的负载和资源利用情况？
答：可以使用命令top或者htop来查看系统的负载和资源利用情况。
如何在Linux系统中安装和配置网络服务？
答：可以使用命令如apt、yum来安装网络服务，然后使用相应的配置文件进行配置。
如何在Linux系统中设置定时任务？
答：可以使用命令crontab来设置定时任务，通过编辑crontab文件添加相应的任务。
如何在Linux系统中查看进程和杀死进程？
答：可以使用命令ps来查看进程，使用命令kill来杀死进程。
如何在Linux系统中进行文件压缩和解压缩？
答：可以使用命令tar进行文件压缩和解压缩，例如tar -czvf archive.tar.gz folder将folder文件夹压缩为archive.tar.gz。
如何在Linux系统中设置防火墙规则？
答：可以使用命令如iptables或者ufw来设置防火墙规则。
如何在Linux系统中进行远程登录？
答：可以使用SSH协议进行远程登录，例如使用命令ssh user@host来登录远程主机。
如何在Linux系统中查看系统硬件信息？
答：可以使用命令如lshw或者dmidecode来查看系统硬件信息。
如何在Linux系统中查看磁盘空间使用情况？
答：可以使用命令如df或者du来查看磁盘空间使用情况。
如何在Linux系统中查找特定类型的文件？
答：可以使用命令find来查找特定类型的文件，例如find /path -type f -name "*.txt"可以在指定路径下查找所有扩展名为.txt的文件。
如何在Linux系统中进行进程管理？
答：可以使用命令如ps、top或者htop来查看和管理进程，例如kill命令可以杀死指定的进程。
如何在Linux系统中查看系统版本信息？
答：可以使用命令如lsb_release或者cat /etc/os-release来查看系统版本信息。
如何在Linux系统中设置环境变量？
答：可以将要设置的环境变量添加到用户的配置文件（如~/.bashrc）或者系统的配置文件（如/etc/profile）中。
如何在Linux系统中进行软件包更新？
答：可以使用包管理工具如apt、yum来更新软件包，例如apt update可以更新apt软件包列表，apt upgrade可以升级已安装的软件包。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b83c93a06ba841913edefee4cfc4f9f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b731bf038d5ac30b09534874fef9c02/" rel="bookmark">
			Opencv-Python(4):OpenCV图像读取/显示/保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.电脑环境
2.图像读取
3.图像显示
4.图像保存
5.综合应用示例
6.Matplotlib读入和显示图像
7.总结
1.电脑环境 win7 64位系统
python版本：3.6.8 （x64）
opencv版本：3.4.2.16
IDE：pycharm2017(Ananconda 3.5.2)
2.图像读取 OpenCV-Python中使用函数cv2.imread() 读入图像。该函数的用法如下：
cv2.imread(filename, flags) 其中，filename是要读取的图像文件的路径和名称，读取的图像应在此程序的工作路径下面或者给函数提供完整路径才可以。flags是一个可选参数，用于指定图像的读取方式(告诉函数应如何如读取这幅图片)。常用的flags取值有：
cv2.IMREAD_COLOR 读入一副彩色图像，图像的透明度会被忽略，这个是默认参数。cv2.IMREAD_GRAYSCALE ，以灰度模式读入图像。cv2.IMREAD_UNCHANGED 读入一幅图像并且包括图像的alpha通道。 该函数会返回一个numpy数组，表示读取的图像。如果读取失败，则返回None。 下面展示图像和代码在同一路径下的三种读取方式：
import cv2 # 读取彩色图像，也可以设置为0 image_color = cv2.imread('image.jpg', cv2.IMREAD_COLOR) # 读取灰度图像，也可以设置为1 image_gray = cv2.imread('image.jpg', cv2.IMREAD_GRAYSCALE) # 读取包含透明通道的图像 image_alpha = cv2.imread('image.png', cv2.IMREAD_UNCHANGED) 如果读取别的路径下的图片，需要使用完整的路径，完整的路径方式有 以下两种：
img_path = 'C:/Course/images/trex.png'， #斜线路径 img_path =r'C:\Course\images\trex.png' # 无转义路径 特别提醒：就算图像的路径是错误的，OpenCV 也不会提示报错，但是当你使用命令print(img)时得到的返回结果是None。 3.图像显示 cv2.imshow()是OpenCV-Python库中用于显示图像的函数，其语法如下：
cv2.imshow(winname, mat) 其中，winname是显示图像窗口的名称，mat是要显示的图像。该函数会创建一个窗口，将图像显示在窗口中，窗口会自动调为图像大小。窗口的名称由winname参数指定，如果指定的名称已存在，则会在原有窗口中显示图像。图像由mat参数指定，可以是一个numpy数组或者Mat对象。你可以创建多个窗口，但是必􅈪给他们不同的名字。
下面是一个使用cv2.imshow()函数显示图像的示例代码：
import cv2 # 读取图像 image = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b731bf038d5ac30b09534874fef9c02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6033e237611ef5b40c0e38ec551bc29/" rel="bookmark">
			了解java的控制语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在java中的控制语句有三种：分支语句、循环语句、跳转语句
分支语句：if和wsitch
循环语句：while、do -- while、for
跳转语句：break、continue、return、throw
1.分支语句
1.1 if语句
1.1.1 if结构：
if(条件表达式)//如果满足条件表达式执行语句组1，否则不执行
{
语句组 1
}
if结构例如：
int s=80; if(s&gt;60) { System.out.println("大于60"); } 输出结果：
大于60
1.1.2 if - else结构
if(条件表达式)//如果满足表达式执行语句组1，否则执行语句组2
{
语句组1
}
else
{
语句组2
}
if-else结构例如：
int sj=70; if(sj&gt;60) { System.out.println("及格"); } else { System.out.println("不及格"); } 输出结果
及格
1.1.3 else-if结构
if(条件表达式1)
{
语句组1
}
else if(条件表达式2)
{
语句组2
}
…………
else if(条件表达式n)
{
语句组n
}
else
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6033e237611ef5b40c0e38ec551bc29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c632f2931b3bc2a27d67d7d67e75a7f/" rel="bookmark">
			如何在Linux上搭建本地Docker Registry并实现远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🔥博客主页： 小羊失眠啦.
🎥系列专栏：《C语言》 《数据结构》 《Linux》《Cpolar》
❤️感谢大家点赞👍收藏⭐评论✍️
前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站。
Linux 本地 Docker Registry本地镜像仓库远程连接 Docker Registry 本地镜像仓库,简单几步结合cpolar内网穿透工具实现远程pull or push (拉取和推送)镜像,不受本地局域网限制！
1. 部署Docker Registry 使用官网安装方式,docker命令一键启动,该命令启动一个registry的容器,版本是2,挂载宿主机端口是5000端口,挂载后,5000端口就是我们连接镜像仓库的本地端口
docker run -d -p 5000:5000 --name registry registry:2 Bash
Copy
执行后,输入docker ps ,我们可以看到运行的容器
2. 本地测试推送镜像 Docker Registry 运行正常后,本地测试推送一个镜像到Registry里面,这边测试把本地mysql镜像推送:
给镜像加上标签
docker image tag mysql localhost:5000/myfirstimage Bash
Copy
推送
docker push localhost:5000/myfirstimage Bash
Copy
可以看到推送成功,本地推送镜像到Docker Registry表示成功,下面安装cpolar 内网穿透工具,实现远程推送
3. Linux 安装cpolar 上面我们安装成功了Docker Registry本地镜像库,下面我们在Linux安装cpolar内网穿透工具,通过cpolar 转发本地端口映射的http公网地址,我们可以很容易实现远程连接,而无需自己注册域名购买云服务器.下面是安装cpolar步骤
cpolar官网地址: https://www.cpolar.com
使用一键脚本安装命令 curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash Bash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c632f2931b3bc2a27d67d7d67e75a7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/126f7fa408bfd2dbee9e9134f9416127/" rel="bookmark">
			手机大厂的自由窗口freeform功能基于aosp14/安卓14适配完成-千里马android framework实战开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 hi，粉丝朋友们：
今年2023年已经块过去了，各个手机厂商已经开始适配aosp14，甚至有的是已经适配完成，明年市场就大部分手机出厂就都是android 14了。
近期有个马哥学员刚好求助马哥一个关于以前马哥课程里面自由窗口项目，这个项目在android 13上做的，但是他们公司是aosp14，希望我能帮忙尽快升级到14。
国内大厂情况 这里可以看到国内大厂普遍都是这种自由窗口，看着确实是湿滑流畅
课程的项目成果情况 马哥课程中自由窗口效果可以看出来基本和国内手机各个大厂自由窗口效果是不是大体相同，课程实现是带大家手把手进行实现的。
不过上面是基于aosp13进行的，最新的aosp14上这部分原生有较大修改，最重要相关修改有如下：
1、把原来的自由窗口自己的顶部栏显示等，独立成了一个窗口，移植到了如下目录
2、Shell包运行在systemui进程，原来直接控制Task窗口相关操作都需要通过如下操作方式
wct.setBounds(mWindowDecoration.mTaskInfo.token, mRepositionTaskBounds); mTaskOrganizer.applyTransaction(wct); 都是通过相关的跨进程通讯来更新相关的Task窗口信息
aosp14适配成果展示 展示成果：
patch修改涉及到的类如下：
ps:相关patch需要购买马哥自由窗口课程才可以获取，具体可以私聊马哥
更多framework干货获取相关可以 私聊+v(androidframework007)
点击这里 https://mp.weixin.qq.com/s/Qv8zjgQ0CkalKmvi8tMGaw
视频：https://www.bilibili.com/video/BV1Jg4y1C7fw/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fb6dff8f2097872a17ac90c6f1ff309/" rel="bookmark">
			模块测试：确保软件质量的关键步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言：
在软件开发过程中，模块测试是确保软件质量的关键环节。通过模块化的设计和测试方法，可以提高开发效率、降低错误率，并最终提供稳定可靠的软件产品。本文将介绍模块测试的概念、重要性以及实施步骤，帮助读者了解如何有效地进行模块测试。
一、什么是模块测试？
模块测试是指对软件系统中的单个模块进行测试的过程。每个模块都是一个独立的功能单元，具有特定的输入和输出。通过对每个模块进行测试，可以验证其功能的正确性、性能的稳定性以及与其他模块的交互是否正常。
二、为什么模块测试如此重要？
1. 提高开发效率：通过模块化的设计和测试方法，可以将复杂的软件系统分解为多个小的模块，每个模块由一个或几个开发人员负责开发和测试。这样可以加快开发进度，减少开发周期。
2. 降低错误率：模块测试可以在早期发现和修复问题，避免问题在整个系统中蔓延。通过及时的反馈和修复，可以降低错误的传播风险，提高软件质量。
3. 提供稳定可靠的软件产品：通过对每个模块进行充分的测试，可以确保每个模块的功能正确性和性能稳定性。只有当所有模块都经过严格的测试后，才能保证整个软件系统的稳定性和可靠性。
三、模块测试的实施步骤
1. 确定测试目标：在进行模块测试之前，需要明确测试的目标和范围。根据需求文档和设计文档，确定需要测试的模块以及测试的重点和优先级。
2. 设计测试用例：根据测试目标，设计相应的测试用例。测试用例应该覆盖各种正常和异常情况，以确保模块在各种情况下都能正常工作。
3. 执行测试用例：按照设计的测试用例，执行相应的测试操作。可以使用自动化测试工具来提高测试效率和准确性。
4. 分析测试结果：在执行完测试用例后，需要对测试结果进行分析和评估。如果发现有错误或问题，需要及时记录并进行修复。
5. 修复错误和问题：根据测试结果，修复发现的错误和问题。修复后，需要重新执行相关的测试用例，确保问题已经解决。
6. 重复测试过程：对于每个模块，都需要重复上述的测试过程，直到所有的模块都通过了测试。
四、模块测试的挑战和解决方案
1. 挑战：模块之间的依赖关系可能导致测试的复杂性增加。如果一个模块依赖于其他模块的功能，那么在没有其他模块的情况下，无法对当前模块进行充分的测试。
解决方案：可以通过模拟依赖模块的行为或者使用桩（stub）来解决这个问题。模拟依赖模块的行为可以模拟出依赖模块的响应，以便对当前模块进行测试。使用桩可以替代真实的依赖模块，以便于对当前模块进行独立测试。
2. 挑战：由于时间和资源的限制，可能无法对所有模块进行全面的测试。
解决方案：可以通过制定优先级和策略来确定哪些模块需要进行重点测试。可以根据模块的重要性、风险程度以及功能复杂度等因素来确定优先级。同时，可以使用自动化测试工具来提高测试效率，减少人力成本。
结论：
模块测试是确保软件质量的关键步骤。通过模块化的设计和测试方法，可以提高开发效率、降低错误率，并最终提供稳定可靠的软件产品。在实施模块测试时，需要明确测试目标、设计测试用例、执行测试用例、分析测试结果、修复错误和问题，并重复这个过程直到所有的模块都通过了测试。尽管模块测试面临一些挑战，但通过合理的策略和工具的使用，可以有效地解决这些问题。
总结：
本文介绍了模块测试的概念、重要性以及实施步骤。通过模块化的设计和测试方法，可以提高开发效率、降低错误率，并最终提供稳定可靠的软件产品。在实施模块测试时，需要明确测试目标、设计测试用例、执行测试用例、分析测试结果、修复错误和问题，并重复这个过程直到所有的模块都通过了测试。尽管模块测试面临一些挑战，但通过合理的策略和工具的使用，可以有效地解决这些问题。通过有效的模块测试，可以确保软件质量，提供稳定可靠的软件产品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b4b9623371b2bd2a541b8fc3f490e46/" rel="bookmark">
			Python基础练习题附带解题思路与代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目1 编写一个Python程序，要求实现一个猜数字游戏，玩家有10次机会猜测一个1到100之间的随机数，如果猜对了，程序会输出“恭喜你，猜对了！”；如果猜错了，程序会提示玩家还剩下多少次机会，并输出当前猜测的数字。
思路 先引入随机数的包，定义一个变量来接收随机数，加上for循环10次在里面接收玩家输入的数字，对输入的数字进行与随机数的判断，如果错误返回玩家还剩下多少次机会与数字是大是小，如果正确返回猜对了
代码 #设置编码格式 # -*- coding: utf-8 -*- # 引入随机数 import random #实现一个猜数字游戏，玩家有10次机会猜测一个1到100之间的随机数，、 # 如果猜对了，程序会输出“恭喜你，猜对了！”； # 如果猜错了，程序会提示玩家还剩下多少次机会，并输出当前猜测的数字。（4分） def guess_number(): number = random.randint(1, 100) for i in range(1,11): guess = int(input("请输入一个1到100之间的数字：")) if guess == number: print("恭喜你，猜对了！") return elif guess &lt; number: print("你猜的数字太小了，还剩", 10 - i, "次机会") else: print("你猜的数字太大了，还剩", 10 - i, "次机会") print("很遗憾，你没有猜对，正确的数字是", number) #主函数 if __name__ == '__main__': #调用测试函数 guess_number() 结果 题目2 编写一个Python程序，要求实现一个将一个字符串转换成回文字符串的函数，并调用该函数测试一个字符串是否为回文字符串。
思路 首先说一下什么是回文字符串
回文字符串就是一个字符串,从头读到尾和从尾读到头,字符出现的顺序是一样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b4b9623371b2bd2a541b8fc3f490e46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a93d8a7611f9e0fe30ba807040cb0817/" rel="bookmark">
			使用Feign时内部接口Token传递及调度任务没有Token问题的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 使用Feign调用内部接口时，前端发起的请求Token传递有问题，无法正常解析Token信息。定时任务调用Feign接口的时候，由于是内部发起的调用，自然也没有Token，也报错Token解析异常。
Feign依赖 &lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
解决方案 import cn.dev33.satoken.same.SaSameUtil; import feign.RequestInterceptor; import feign.RequestTemplate; import org.apache.commons.lang3.StringUtils; import org.springframework.http.HttpHeaders; import org.springframework.stereotype.Component; import org.springframework.web.context.request.RequestAttributes; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.context.request.ServletRequestAttributes; import javax.servlet.http.HttpServletRequest; @Component public class FeignInterceptor implements RequestInterceptor { /** * 为 Feign 的 RCP调用 添加请求头Token */ @Override public void apply(RequestTemplate requestTemplate) { RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); if (requestAttributes == null){ // 不是Web请求，使用SaToken提供的 SAME_TOKEN requestTemplate.header(SaSameUtil.SAME_TOKEN, SaSameUtil.getToken()); return; } // 获取 HttpServletRequest 对象 HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a93d8a7611f9e0fe30ba807040cb0817/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05feb1187529013952b5d83d02ca6259/" rel="bookmark">
			swift动态成员查找 @dynamicMemberLookup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看Alamofire源码的时候，看到@propertyWrapper和@dynamicMemberLookup，这篇说下dynamicMemberLookup
Swift 4.2 中引入了一个新的语法@dynamicMemberLookup（动态成员查找）。使用@dynamicMemberLookup标记了目标（类、结构体、枚举、协议），实现subscript(dynamicMember member: String)方法后我们就可以访问到对象不存在的属性。
@dynamicMemberLookup：可标记类、结构体、枚举、协议subscript(dynamicMember member: String)：实现该方法，可以像数组和字典一样，用下标的方式去访问属性，通过所请求属性的字符串名得到并返回想要的值可提高与 Python 或 Javascript 等动态语言的互操作性。它允许动态成员查找调用看起来像访问类型属性的常规调用： let people = People()
let name = people.name // 像访问属性一样
name是从字典中查找的，而不是作为 People 的属性访问的。
如何使用动态成员查找？
要在你的自定义类型中使用动态成员查找，请使用 @dynamicMemberLookup标注你的类型，并实现如下方法：
subscript(dynamicMember:)
该方法接收一个String或KeyPath类型参数
我们来看看People是如何实现动态成员查找的，下面是一个demo：
@dynamicMemberLookup struct People { private var map = ["name": "drbox", "job": "developer"] subscript(dynamicMember key: String) -&gt; String { map[key] ?? "undefine" } } 现在你可以像访问它的属性一样查找 People 对象的成员。
let people = People() let name = people.name let job = people.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05feb1187529013952b5d83d02ca6259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffdbff41573e50e03a42f480f6f09c4c/" rel="bookmark">
			C&#43;&#43;带参数的单例模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 C++ 中实现带参数的单例模式可以通过以下步骤完成：
1. 创建一个类，该类负责管理单例对象的创建和访问，并提供一个静态方法来获取单例对象。
2. 在该类中添加一个私有的静态成员变量，用于保存单例对象的实例。
3. 添加一个静态方法，用于获取单例对象的实例。在该方法中，可以根据参数的不同来创建不同的单例对象。
4. 将构造函数设为私有，以防止外部代码直接实例化该类。
下面是一个简单的示例代码，演示了如何在 C++ 中实现带参数的单例模式：
```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;
class Singleton {
public:
static Singleton* getInstance(const std::string&amp; config) {
if (!instance) {
instance = new Singleton(config);
}
return instance;
}
void printConfig() {
std::cout &lt;&lt; "Config: " &lt;&lt; config &lt;&lt; std::endl;
}
private:
Singleton(const std::string&amp; config) : config(config) {}
static Singleton* instance;
std::string config;
};
Singleton* Singleton::instance = nullptr;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffdbff41573e50e03a42f480f6f09c4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69d10fefda7fb382127888469ef24fe/" rel="bookmark">
			C语言大整数运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大整数运算是指对于超过计算机数据类型范围的数进行运算的一种方法。在C语言中，通常使用数组来存储大整数，并通过编写相应的函数实现加、减、乘、除等运算。
在进行大整数运算时，需要注意以下几点：
数组长度要足够长，以存储所需的位数。例如，如果需要计算1000位的数字，则数组长度至少要为1000。
进行加减法时，需要考虑进位和借位的情况。可以通过循环遍历数组，并使用一个变量来记录进位或借位。
加法
#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAX_LEN 1000 void add(char *a, char *b, char *res) { int carry = 0; int len_a = strlen(a); int len_b = strlen(b); int i = len_a - 1; int j = len_b - 1; int k = MAX_LEN - 1; // 初始化res的index为最大长度 - 1 // 初始化res为全0 memset(res, '0', MAX_LEN); res[k--] = '\0'; // 以空字符终止res字符串 while (i &gt;= 0 || j &gt;= 0 || carry) { int sum = carry; if (i &gt;= 0) { sum += a[i--] - '0'; } if (j &gt;= 0) { sum += b[j--] - '0'; } res[k--] = sum % 10 + '0'; carry = sum / 10; } // 移除前导零 for (i = 0; i &lt; MAX_LEN - 1; ++i) { if (res[i] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b69d10fefda7fb382127888469ef24fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f9a142c715a3c68c806fe953755f8a/" rel="bookmark">
			函数栈帧的创建与销毁（超详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数栈帧的创建与销毁 1、什么是函数栈帧2、理解函数栈帧能解决什么问题3、函数栈帧的创建和销毁解析3.1 什么是栈？3.2 认识相关寄存器和汇编指令3.3 解析函数栈帧的创建和销毁3.3.1 预备知识3.3.2 函数的调用堆栈3.3.3 准备环境3.3.4 转到反汇编3.3.5 函数栈帧的创建3.3.6 函数栈帧的销毁 1、什么是函数栈帧 我们在写C语言代码的时候，经常会把一个独立的功能抽象为函数，所以C程序是以函数为基本单位的。那函数是如何调用的？函数的返回值又是如何待会的？函数参数是如何传递的？这些问题都和函数栈帧有关系。
函数栈帧（stack frame）就是函数调用过程中在程序的调用栈（call stack）所开辟的空间，这些空间是用来存放：
函数参数和函数返回值临时变量（包括函数的非静态的局部变量以及编译器自动生产的其他临时变量）保存上下文信息（包括在函数调用前后需要保持不变的寄存器）。 2、理解函数栈帧能解决什么问题 理解函数栈帧有什么用呢？
只要理解了函数栈帧的创建和销毁，以下问题就能够很好的额理解了：
局部变量是如何创建的？为什么局部变量不初始化内容是随机的？函数调用时参数时如何传递的？传参的顺序是怎样的？函数的形参和实参分别是怎样实例化的？函数的返回值是如何带会的？
让我们一起走进函数栈帧的创建和销毁的过程中。 3、函数栈帧的创建和销毁解析 3.1 什么是栈？ 栈（stack）是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，没有栈就没有函数，没有局部变量，也就没有我们如今看到的所有的计算机语言。
在经典的计算机科学中，栈被定义为一种特殊的容器，用户可以将数据压入栈中（入栈，push），也可以将已经压入栈中的数据弹出（出栈，pop），但是栈这个容器必须遵守一条规则：先入栈的数据后出栈（First In Last Out， FILO）。就像叠成一叠的术，先叠上去的书在最下面，因此要最后才能取出。
在计算机系统中，栈则是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增大，而弹出操作使得栈减小。
在经典的操作系统中，栈总是向下增长（由高地址向低地址）的。在我们常见的i386或者x86-64下，栈顶由成为 esp 的寄存器进行定位的
3.2 认识相关寄存器和汇编指令 相关寄存器
eax：通用寄存器，保留临时数据，常用于返回值ebx：通用寄存器，保留临时数据ebp：栈底寄存器esp：栈顶寄存器eip：指令寄存器，保存当前指令的下一条指令的地址 相关汇编命令
mov：数据转移指令push：数据入栈，同时esp栈顶寄存器也要发生改变pop：数据弹出至指定位置，同时esp栈顶寄存器也要发生改变sub：减法命令add：加法命令call：函数调用，1. 压入返回地址 2. 转入目标函数jump：通过修改eip，转入目标函数，进行调用ret：恢复返回地址，压入eip，类似pop eip命令 3.3 解析函数栈帧的创建和销毁 3.3.1 预备知识 首先我们达成一些预备知识才能有效的帮助我们理解，函数栈帧的创建和销毁。
每一次函数调用，都要为本次函数调用开辟空间，就是函数栈帧的空间。这块空间的维护是使用了2个寄存器： esp 和 ebp ， ebp 记录的是栈底的地址， esp 记录的是栈顶的地址。
如图所示：
函数栈帧的创建和销毁过程，在不同的编译器上实现的方法大同小异，本次演示以VS2019为例。 3.3.2 函数的调用堆栈 演示代码：
#include &lt;stdio.h&gt; int Add(int x, int y) { int z = 0; z = x + y; return z; } int main() { int a = 3; int b = 5; int ret = 0; ret = Add(a, b); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93f9a142c715a3c68c806fe953755f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb4a3b91916da6fa1229f28296452dd7/" rel="bookmark">
			查看端口占用并杀死进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.安装查看工具 sudo yum install net-tools 2.查看占用情况 netstat -tunlp | grep 8089 3.杀死进程 kill -9 227 附件：后台启动python程序：
nohup python script.py &amp; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93cd6562cb2a70cb6b8c0249d5ee37ef/" rel="bookmark">
			监听页面滚动，使某块内容区域opacity 由1慢慢变为0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 data() { return { scrollDistance: 0, // 初始滚动距离为0 opacity: 1, // 初始opacity为1 }; }, onPageScroll(e) { // 获取滚动距离 this.scrollDistance = e.scrollTop; // 根据滚动距离计算新的opacity值 // 假设滚动100px时，opacity为0 // 这里使用一个简单的线性计算函数 this.opacity = Math.max(1 - (this.scrollDistance / 100), 0); }, &lt;template&gt; &lt;view :style="`opacity: ${opacity}`"&gt;内容区域&lt;/view&gt; &lt;/template&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30374b0aabe58451f7065e8e41da209a/" rel="bookmark">
			Python3，10行代码，写一个气球运行小游戏，再也不无聊了。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		五彩缤纷气球 1、引言2、实战2.1 安装2.2 示例 3、总结 1、引言 小屌丝：鱼哥，你看这个。
小鱼：嗯，不错哦， 挺好看的。
小屌丝：嗯，既然这么好看那你能不能帮我搞一个这个？
小鱼：你这不是都有了，还要咋搞？
小屌丝：我想要实现的代码啊
小鱼：这个动图谁给你的啊， 你问他要哦。
小屌丝：我在网上随便找的动图，看着挺不错，就想着让你帮忙实现。
小鱼：… 你这是那我练手呢？
小屌丝：没有啊，我就是觉得天冷了，应该去泡个澡。
小鱼：… 这个理由，我无法反驳。
小屌丝：嘿嘿，快点，整完咱俩早点去，听说新增泰式的哦。
小鱼：…
2、实战 2.1 安装 因为PyGame是三方库，所以，要使用的话，需要安装，老规矩， 先pip 方式安装：
pip install pygame 其余安装方式，可以参照这两篇：
《Python3，选择Python自动安装第三方库，从此跟pip说拜拜！！》《Python3：我低调的只用一行代码，就导入Python所有库！》 2.2 示例 # -*- coding:utf-8 -*- # @Time : 2023-12-16 # @Author : Carl_DJ ''' 实现功能： 使用pygame实现五彩气球 ''' import pygame import random import time # 初始化pygame pygame.init() # 设置屏幕大小 screen_width = 800 screen_height = 600 screen = pygame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30374b0aabe58451f7065e8e41da209a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da074f0ddf3f79307fb7cc1b811e875/" rel="bookmark">
			玩转字词句魔法：打造超强样本集的数据增强策略，句式变换揭秘同义句生成与回译在数据增强中的创新应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NLP专栏简介：数据增强、智能标注、意图识别算法|多分类算法、文本信息抽取、多模态信息抽取、可解释性分析、性能调优、模型压缩算法等
专栏详细介绍：NLP专栏简介：数据增强、智能标注、意图识别算法|多分类算法、文本信息抽取、多模态信息抽取、可解释性分析、性能调优、模型压缩算法等
前人栽树后人乘凉，本专栏提供资料：数据增强、智能标注、意图识别算法|多分类算法、文本信息抽取、多模态信息抽取、可解释性分析、性能调优、模型压缩算法等项目代码整合，省去你大把时间，效率提升。 帮助你快速完成任务落地，以及科研baseline。
玩转字词句魔法：打造超强样本集的数据增强策略，句式变换揭秘同义句生成与回译在数据增强中的创新应用 1. WordSimilarity 这是一个基于同义词词林扩展版的单词相似度计算方法的python实现，参考论文如下：
pip install WordSimilarity from word_similarity import WordSimilarity2010 ws_tool = WordSimilarity2010() b_a = "抄袭" b_b = "克隆" sim_b = ws_tool.similarity(b_a, b_b) print(b_a, b_b, '相似度为', sim_b) #抄袭 克隆 最终的相似度为 0.585642777645155 更多项目参考：
https://github.com/BiLiangLtd/WordSimilarity
https://github.com/ashengtx/CilinSimilarity 实现了三种计算方法。
https://github.com/Xls1994/Cilin
http://www.codepub.cn/2015/08/04/Based-on-the-extended-version-of-synonyms-Cilin-word-similarity-computing/ Java实现
2.OpenHowNet OpenHowNet API由清华大学自然语言处理实验室（THUNLP）开发，提供方便的义原信息查询、义原树展示、基于义原的词相似度计算等功能。网站体验词语义原在线查询和展示功能。
官网：https://openhownet.thunlp.org/
https://openhownet.thunlp.org/item?id=000000265705
2.1 HowNet简介 HowNet是最典型的义原知识库。义原在语言学中被定义为最小的语义单位，有语言学家认为世界所有语言的所有词语的语义都可以用一个有限的义原集合来表示。董振东和董强先生父子将此思想付诸实践，耗时近30年构建了HowNet（知网），通过预定义的2000多个义原为20多万个由中英文词语所表示的概念进行了标注。
HowNet词典
HowNet核心数据（即HowNet词典，可从OpenHowNet网站下载）包括237,973个概念。每个概念由中英文词语及其词性、情感倾向、例句、义原标注等信息组成。下面是HowNet中一个概念的示例： NO.=000000026417 # 概念编号 W_C=不惜 # 中文词语 G_C=verb # 中文词语词性 S_C=PlusFeeling|正面情感 # 中文词语情感倾向 E_C=~牺牲业余时间，~付出全部精力，~出卖自己的灵魂 # 中文词语例句 W_E=do not hesitate to # 英文词语 G_E=verb # 英文词语词性 S_E=PlusFeeling|正面情感 # 英文词语情感倾向 E_E= # 英文词语例句 DEF={willing|愿意} # 义原标注 RMK= 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da074f0ddf3f79307fb7cc1b811e875/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a223bd07bf75f51c532ff3859fb1bea/" rel="bookmark">
			1拖2功率分配快充线方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着PD3.1协议的市场应用越来越多，一些充电器的Type-C接口的输出功率达到百瓦及以上，如何充分利用好这类充电器设备，乐得瑞电子推出1拖2快充线缆解决方案，支持智能功率分配策略+支持私有快充协议。
如上图是乐得瑞1拖2功率分配快充线样线实物，以乐得瑞LDR6020方案设计小PCB板为“桥梁”，输入端连接单USB-C线，输出端分出两条USB-C线。
这样对于目前的一些单USB-C口充电器来说，基于乐得瑞推出高功率线缆解决方案便可以实现双设备同时快充而无需另外购买多口充电器。一般来说，数据线价格都会比充电器便宜些，对于消费者来说更实惠。这个是LDR6020 二合一快充充电线的框架图，具体原理图请找方案。USB- Power Delivery（USB PD） 是主流的快充协议之一。是由USB-IF组织制定的一种快速充电规范，USB PD透过USB电缆和连接器增加电力输送，扩展USB应用中的电缆总线供电能力。该规范可实现更高的电压和电流，输送的功率最高可达100瓦，并可以自由的改变电力的输送方向。
这款一拖二快充线采用小板设计，小板焊接USB-C输入及对应的输出导线，可实现多口充电器和两条充电线的功能，满足两台设备的同时快充需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d09c615c8832b13f5f93e6b30eecacc/" rel="bookmark">
			USB PD3.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先了解一下PD3.1:
5月25日，USB-IF协会推出了USB Type-C线缆和接口标准v2.1版本，其中更新了有关供电能力的章节。USB PD3.1规范将原来的USB PD3.0内容归到标准功率范围（Standard Power Range，简称SPR）里面，最大功率保持100W不变；同时增加了扩展功率范围（Extended Power Range，简称EPR），最大功率由100W扩展到240W。
根据USB-IF协会公布的资料显示，在扩展功率范围EPR中，新增了28V、36V和48V三种固定电压档和三种可调电压档（Adjustable Voltage Supply，简称AVS）。
其中最大电流等级维持最大5A不变；100-140W功率是28V AVS，电压范围是15V-28V；大于140W到180W功率是36V AVS，电压范围是15V-36V；大于180W到240W是48V AVS，电压范围是15V-48V。
在USB PD3.1标准下，USB Type-C线缆分20V等级的普通线缆和50V等级的EPR线缆两种规格。超过100W的功率输出，不仅需要使用EPR（扩展功率）的5A线缆，而且还必须在Source，Sink和Cable之间通过EPR特定信息握手才能由SPR进入到EPR；如果线缆是固定在充电器上的Captive cable，则只需要Source和Sink之间握手即可。
由于电压等级大幅度调高，所以安全问题非常重要，EPR对连接器和线缆等的安规提出更高的要求。需要重点关注IEC 62368关于限功率电源（Limited Power Supply，简称LPS）的规定。
值得注意的是，本次USB PD3.1规范的制订中，华为、小米、立讯精密、慧能泰等多家国内公司都积极参与其中，为新标准做出了重要贡献，被写入标准起草企业目录。
USB-IF全称为USB Implementers Forum，成立于1995年，总部位于美国，由Apple苹果、HP惠普、Intel英特尔、Microsoft微软、Renesas瑞萨、ST意法半导体、TI德州仪器等公司共同开创。2020年12月会员总数累计已经突破12USB-IF是一个致力于发展Universal Serial Bus技术并推广其应用的非营利性组织，USB通过提供标准并统一化的传输接口规格，让计算机与外围配备间的连接传输变得轻松容易，省去使用外接卡或交换器的不便。一般应用USB规格的信息产品包罗万象，诸如计算机、相机、打印机、键盘、鼠标、屏幕、网络装置、手机及各种新式消费电子产品。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe6276430379301620d8d4cbbd917606/" rel="bookmark">
			Verilog实现以太网接收部分的学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言1 以太网基础知识的掌握2 以太网的数据传输格式2.1 数据链路层的数据帧2.2 网络层的IP报文格式2.3 传输层的UDP协议2.3.1 UDP数据传输的格式2.3.2 UDP以太网传输的设计方法2.3.3 ARP协议（地址解析协议）2.3.3.1 ARP传输数据格式 3 UDP以太网传输的接收部分的verilog代码编写 前言 最近需要进行aurora接口的报文解析，所以学了一下以太网的报文解析方法。
基于verilog实现以太网收发通信时，主要包括四个模块：GMII 转 RGMII接口模块（4bit转8bit）、以太网接收模块、以太网发送模块以及以太网的控制模块。
1 以太网基础知识的掌握 首先大概了解一下以太网的基础概念以及相关的IP五层模型。
如下图所示，为模型的各个层。各层之间可以简单理解成不断组包和拆包的过程。
另外对于数据包以及报文或者帧差不多，主要是在不同的层有不同的称号。比如说一般在数据链路层，我们称为数据帧，而在网络层一般称为报文。
理解七层之后，我们要了解每层要重点掌握的东西。
物理层的话，我理解的是主要掌握通信接口的外部输入输出引脚的分配，比如说RX和TX端的连接等。另外重点掌握以太网的传输格式（数据链路层、网络层、传输层），这也是后续设计收发状态机以及编写代码的关键。应用层是计算机用户，以及各种应用程序和网络之间的接口。我的理解是这方面又软件或驱动来控制，主要负责在应用层下报文。 2 以太网的数据传输格式 2.1 数据链路层的数据帧 如下图所示，为整个以太网的数据传输格式：
其存在于数据链路层。前面说了，各层之间就是组包和拆包的过程，所以将数据链路层的前导码、SFD、以太网帧头以及FCS去掉之后，剩下的以太网数据就是网络层的报文了。
每个字段的含义（重点看一下加粗部分即可）：
● 前导码(Preamble)：帧头，用于数据同步。物理层使用固定的连续7Byte的0x55实现。
● 帧起始定界符(SFD，Start Frame Delimiter)：用于区分前导码与数据段，为固定1Byte的0xd5。
● 目的MAC地址：即接收端物理MAC地址，占6Byte，为固定值，因为每个设备都对应唯一个MAC地址。MAC地址从应用上可分为单播地址、组播地址和广播地址。
单播地址：第一个字节的最低位为0，比如0-00-00-11-11-11，一般用于标志唯一的设备；
组播地址：第一个字节的最低位为1，比如01-00-00-11-11-11，一般用于标志同属一组的多个设备；
广播地址：全为1，即FF-FF-FF-FF-FF-FF，用于标志同一网段中的所有设备。
● 源MAC地址：即发送端物理MAC地址，6Byte。
● 数据帧类型/长度：2B，当这两个字节的值小于1536 (十六进制为0x0600)时代表该以太网中数据段的长度；如果这两个字节的值大于1536，则表示与以太网帧相关的MAC客户端协议的类型，例如0x0800代表IP协议(网际协议)、0x0806 代表ARP协议(地址解析协议) 等
● 以太网数据：长度为46-1500Byte。最大值1500称为以太网的最大传输单元(MTU，Maximum Transmission Unit)。接收到的数据包如果少于64字节会被认为发生冲突，数据包被自动丢弃。
● 校验(FCS，Frame Check Sequence)：确保数据的正确传输，在数据的尾部加入了4Byte的循环冗余校验码(CRC)来检验数据是否传输错误。CRC数据校验从目的MAC地址开始。
● 帧间隙(IFG，Interpacket Gap)：以太网相邻两帧之间的时间间隔，即网络设备和组件在接收一帧之后，需要短暂的时间来恢复并为接收下一帧做准备的时间，最小值是96 bit time(媒介中发送96位原始数据所需要的时间)。
2.2 网络层的IP报文格式 接下来分析以太网数据部分，即网络层报文。由于网络层需要进行IP寻址操作，因此传入网络层的以太网数据中包含20 字节的IP协议首部（IP报文头） + 报文数据。同样，将IP报文头拆掉之后，传入传输层。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe6276430379301620d8d4cbbd917606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/303bdceff25d6b81272943a1ea25ac68/" rel="bookmark">
			虚拟机Linux（Centos7）安装Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果没有安装虚拟机的，可以参考这篇VMware虚拟机安装Linux操作系统（CentOS7）
文章目录 0.安装Docker1.CentOS安装Docker1.1.卸载（可选）如何看自己的虚拟机上是否安装过docker？ 1.2.安装docker1.3.启动docker1.4.配置镜像加速 0.安装Docker Docker是一个开源的容器化平台，用于构建、打包、部署和运行应用程序。它通过使用容器来实现应用程序的隔离性，使得应用程序可以在不同的环境中轻松部署和运行，而无需考虑底层操作系统和硬件的差异。
以下是一些关键概念和特点：
容器化：Docker利用容器技术实现应用程序的隔离，每个容器都包含一个完整的运行环境，包括代码、运行时环境、系统工具和依赖库。容器可以快速启动、停止和迁移，提供了更高的灵活性和可移植性。
易于构建和部署：使用Docker，开发人员可以将应用程序及其所有依赖打包到一个称为镜像的独立文件中。镜像可以在任何支持Docker的环境中运行，极大地简化了应用程序的部署过程。
轻量级和高效：相比于传统的虚拟化技术，Docker容器更加轻量级和高效。它们与宿主机共享操作系统内核，因此启动和运行速度更快，并占用更少的系统资源。
可移植性：由于Docker容器在不同的环境中以相同的方式运行，因此应用程序可以轻松地在开发、测试和生产环境之间迁移，而无需担心环境差异带来的问题。
生态系统和工具支持：Docker拥有庞大的生态系统和丰富的工具支持，包括Docker Compose、Docker Swarm、Kubernetes等。这些工具使得管理、编排和扩展容器变得更加简单和高效。
Docker为应用程序的构建、部署和运行提供了一种快速、灵活和可移植的解决方案，被广泛应用于开发、测试和生产环境中。
Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。
Docker CE 分为 stable test 和 nightly 三个更新频道。
官方网站上有各种环境下的 安装指南，这里主要介绍 Docker CE 在 CentOS上的安装。
1.CentOS安装Docker Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。
1.1.卸载（可选） 如何看自己的虚拟机上是否安装过docker？ 直接输入查看docker版本的命令docker -v，如果安装过就会有版本号出来，没有的话就是没有安装过。
如果之前安装过旧版本的Docker，可以使用下面命令卸载：
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine \ docker-ce 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/303bdceff25d6b81272943a1ea25ac68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0148c510dd0ee8d239e7c33c176541/" rel="bookmark">
			微信小程序（五）地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 作者开发《目的地到了》需要满足用户选取地址作为目的地的需求，所以需要使用到地图。作者用的是腾讯地图，这里介绍下技术实现。
二、引包 引入腾讯地图的组件包微信小程序JavaScript SDK | 腾讯位置服务，根据经纬度调用里面的api才能获取周围的地图数据展示
目录结构是这样的
/** * 微信小程序JavaScriptSDK */ var ERROR_CONF = { KEY_ERR: 311, KEY_ERR_MSG: 'key格式错误', PARAM_ERR: 310, PARAM_ERR_MSG: '请求参数信息有误', SYSTEM_ERR: 600, SYSTEM_ERR_MSG: '系统错误', WX_ERR_CODE: 1000, WX_OK_CODE: 200 }; var BASE_URL = 'https://apis.map.qq.com/ws/'; var URL_SEARCH = BASE_URL + 'place/v1/search'; var URL_SUGGESTION = BASE_URL + 'place/v1/suggestion'; var URL_GET_GEOCODER = BASE_URL + 'geocoder/v1/'; var URL_CITY_LIST = BASE_URL + 'district/v1/list'; var URL_AREA_LIST = BASE_URL + 'district/v1/getchildren'; var URL_DISTANCE = BASE_URL + 'distance/v1/'; var URL_DIRECTION = BASE_URL + 'direction/v1/'; var MODE = { driving: 'driving', transit: 'transit' }; var EARTH_RADIUS = 6378136.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf0148c510dd0ee8d239e7c33c176541/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2e2634bacd528d17931e0d3339bf42e/" rel="bookmark">
			解决接入mPaas一直Starting Gradle Daemon...问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、新版开发工具 如若使用的是新版开发工具则在settings.gradle中加入
// google() maven { url 'https://mvn.cloud.alipay.com/nexus/content/repositories/releases/' } 一定要把 google()等注释掉如下
// google() 2.旧版的话在工程目录的build.gradle添加 // google() maven { url 'https://mvn.cloud.alipay.com/nexus/content/repositories/releases/' } 一定要把 google()等注释掉如下
gradlePluginPortal() // google() mavenCentral() 3.最终settings.gradle文件 pluginManagement { repositories { maven { url 'https://mvn.cloud.alipay.com/nexus/content/repositories/releases/' } gradlePluginPortal() // google() mavenCentral() maven { url 'https://maven.aliyun.com/nexus/content/groups/public/' } maven { url 'https://maven.aliyun.com/nexus/content/repositories/jcenter' } maven { url 'https://maven.aliyun.com/nexus/content/repositories/google' } maven { url 'https://maven.aliyun.com/nexus/content/repositories/gradle-plugin' } maven { url 'https://jitpack.io' } maven { url 'https://maven.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2e2634bacd528d17931e0d3339bf42e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f26df65d24ced12812455423cda008/" rel="bookmark">
			为什么参数上必须加@RequestBody？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@PostMapping("/login") public Result&lt;Map&lt;String,Object&gt;&gt; login(@RequestBody User user){ return Result.success(); } 在这个 @PostMapping("/login") 的控制器方法中，使用 @RequestBody 注解的目的是将请求体中的 JSON 数据映射到方法参数 User user 上。
假设前端发送的 POST 请求体是一个包含用户信息的 JSON 数据，例如
{ "username": "exampleUser", "password": "examplePassword" } 通过使用 @RequestBody 注解，Spring 框架会尝试将这个 JSON 数据转换成 User 对象。而不使用 @RequestBody 的话，Spring 会默认将请求体中的参数作为表单数据处理，而不是 JSON 数据。
具体来说，@RequestBody 注解告诉 Spring 框架，要从请求体中获取数据，并将其转换成方法参数 user 的实例。这样，你就能够方便地在方法体内使用这个 user 对象，而不需要手动解析请求体中的 JSON 数据。
总结一下，使用 @RequestBody 的目的是让 Spring 自动将请求体中的 JSON 数据转换为方法参数的实例，使得在控制器方法中能够方便地操作请求体中的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bd640d2b3c7d5c9f55fad148b0a59f2/" rel="bookmark">
			【LangChain学习之旅】—（3） LangChain快速构建本地知识库的智能问答系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LangChain学习之旅】—（3） LangChain快速构建本地知识库的智能问答系统 项目及实现框架开发框架核心实现机制数据准备及加载加载文本文本的分割向量数据库存储文本的“嵌入”概念向量数据库概念 相关信息获取RetrievalQA生成回答并展示示例小结 Reference：LangChain 实战课
项目及实现框架 项目名称：“易速鲜花”内部员工知识库问答系统。项目介绍：“易速鲜花”作为一个大型在线鲜花销售平台，有自己的业务流程和规范，也拥有针对员工的 SOP 手册。新员工入职培训时，会分享相关的信息。但是，这些信息分散于内部网和 HR 部门目录各处，有时不便查询；有时因为文档过于冗长，员工无法第一时间找到想要的内容；有时公司政策已更新，但是员工手头的文档还是旧版内容。 基于上述需求，我们将开发一套基于各种内部知识手册的 “Doc-QA” 系统。这个系统将充分利用 LangChain 框架，处理从员工手册中产生的各种问题。这个问答系统能够理解员工的问题，并基于最新的员工手册，给出精准的答案。
开发框架 开发框架：下面这张图片描述了通过 LangChain 框架实现一个知识库文档系统的整体框架。
整个框架分为这样三个部分。数据源（Data Sources）：数据可以有很多种，包括 PDF 在内的非结构化的数据（Unstructured Data）、SQL 在内的结构化的数据（Structured Data），以及 Python、Java 之类的代码（Code）。在这个示例中，我们聚焦于对非结构化数据的处理。大模型应用（Application，即 LLM App）：以大模型为逻辑引擎，生成我们所需要的回答。用例（Use-Cases）：大模型生成的回答可以构建出 QA/ 聊天机器人等系统。 核心实现机制 核心实现机制：这个项目的核心实现机制是下图所示的数据处理管道（Pipeline）
在这个管道的每一步中，LangChain 都为我们提供了相关工具，让你轻松实现基于文档的问答功能。
具体流程分为下面 5 步：
Loading：文档加载器把 Documents 加载为以 LangChain 能够读取的形式。Splitting：文本分割器把 Documents 切分为指定大小的分割，我把它们称为“文档块”或者“文档片”。Storage：将上一步中分割好的“文档块”以“嵌入”（Embedding）的形式存储到向量数据库（Vector DB）中，形成一个个的“嵌入片”。Retrieval：应用程序从存储中检索分割后的文档（例如通过比较余弦相似度，找到与输入问题类似的嵌入片）。Output：把问题和相似的嵌入片传递给语言模型（LLM），使用包含问题和检索到的分割的提示生成答案。 上面 5 个环节的介绍都非常简单，有些概念（如嵌入、向量存储）是第一次出现，理解起来需要一些背景知识，接下来具体讲解这 5 步。
数据准备及加载 数据的准备和载入“易速鲜花”的内部资料包括 pdf、word 和 txt 格式的各种文件，可以
在此下载。
其中一个文档的示例如下：
首先用 LangChain 中的 document_loaders 来加载各种格式的文本文件。在这一步中，我们从 pdf、word 和 txt 文件中加载文本，然后将这些文本存储在一个列表中。（注意：可能需要安装 PyPDF、Docx2txt 等库）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bd640d2b3c7d5c9f55fad148b0a59f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88276d915e9c871135fcd28105500092/" rel="bookmark">
			使用Halcon实现模板匹配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片:
代码:
read_image (Image, 'C:/Users/14348/Desktop/mobanpipei.jpg') get_image_size (Image, Width, Height) dev_close_window() dev_open_window (0, 0, Width, Height, 'black', WindowHandle) dev_display (Image) draw_rectangle1 (WindowHandle, Row1, Column1, Row2, Column2) gen_rectangle1 (Rectangle, Row1, Column1, Row2, Column2) reduce_domain (Image, Rectangle, ImageReduced) crop_domain (ImageReduced, ImageA) *创建匹配模板 *Model_ID 最终匹配的模板文件 create_shape_model (ImageA, 'auto', rad(0), rad(90), 'auto', 'auto', 'use_polarity', 'auto', 'auto', ModelID) dev_display(Image) find_shape_model (Image, ModelID, rad(0), rad(90), 0.5, 0, 0.5, 'least_squares', 0, 0.9, Row, Column, Angle, Score) tuple_length (Score, Length) for Index := 0 to Length-1 by 1 disp_cross (WindowHandle, Row, Column, 20, 0) disp_message (WindowHandle, 'Score'+Score[Index], 'window', Row[Index], Column[Index]+100, 'black', 'true') endfor 结果:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86de90a92e96da5b2b3d62fd6feba8b5/" rel="bookmark">
			【经典LeetCode算法题目专栏分类】【第4期】BFS广度优先算法：单词接龙、最小基因变化、二进制矩阵中的最短路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《博主简介》
小伙伴们好，我是阿旭。专注于人工智能AI、python、计算机视觉相关分享研究。
✌更多学习资源，可关注公-仲-hao:【阿旭算法与机器学习】，共同学习交流~
👍感谢小伙伴们点赞、关注！
一般涉及到最小层数问题，要想到BFS。只要找到第一个符合条件的就是最小层数。
单词接龙 # 单向BFS
class Solution:
def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; int:
queue = [(beginWord, 1)]
word_list = [ chr(ord('a') + i) for i in range(27)]
wordList = set(wordList)
n = len(beginWord)
while queue:
word, step = queue.pop(0)
if word == endWord:
return step
for i in range(n):
for c in word_list:
tmp = word[:i] + c + word[i+1:]
if tmp in wordList:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86de90a92e96da5b2b3d62fd6feba8b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4a8af81d141b2009e43b045aeac647/" rel="bookmark">
			【经典LeetCode算法题目专栏分类】【第2期】组合与排列问题系列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《博主简介》
小伙伴们好，我是阿旭。专注于人工智能、AIGC、python、计算机视觉相关分享研究。
✌更多学习资源，可关注公-仲-hao:【阿旭算法与机器学习】，共同学习交流~
👍感谢小伙伴们点赞、关注！
组合总和1 class Solution:
def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:
def DFS(candidates,target,start,track):
if sum(track) == target:
res.append(track.copy())
return
if sum(track) &gt; target:
return
for i in range(start,len(candidates)):
track.append(candidates[i])
DFS(candidates,target, i, track)
track.pop()
res =[]
DFS(candidates,target,0,[])
return res
元素可以重复使用,进入下一层时从i开始。元素不能重复使用时，进入下一层时从i+1卡开始。
组合总和2 class Solution:
def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:
def DFS(candidates, target,start, track):
if sum(track) &gt; target:
return if sum(track) == target:
res.append(track.copy())
for i in range(start,len(candidates)):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4a8af81d141b2009e43b045aeac647/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c73169688dc3de30ad6ec25ea675a8c5/" rel="bookmark">
			【经典LeetCode算法题目专栏分类】【第1期】左右双指针系列：盛最多水的容器、接雨水、回文子串、三数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《博主简介》
小伙伴们好，我是阿旭。专注于人工智能、AIGC、python、计算机视觉相关分享研究。
✌更多学习资源，可关注公-仲-hao:【阿旭算法与机器学习】，共同学习交流~
👍感谢小伙伴们点赞、关注！
《------往期经典推荐------》
一、AI应用软件开发实战专栏【链接】
项目名称项目名称1.【人脸识别与管理系统开发】2.【车牌识别与自动收费管理系统开发】3.【手势识别系统开发】4.【人脸面部活体检测系统开发】5.【图片风格快速迁移软件开发】6.【人脸表表情识别系统】7.【YOLOv8多目标识别与自动标注软件开发】8.【基于YOLOv8深度学习的行人跌倒检测系统】9.【基于YOLOv8深度学习的PCB板缺陷检测系统】10.【基于YOLOv8深度学习的生活垃圾分类目标检测系统】11.【基于YOLOv8深度学习的安全帽目标检测系统】12.【基于YOLOv8深度学习的120种犬类检测与识别系统】13.【基于YOLOv8深度学习的路面坑洞检测系统】14.【基于YOLOv8深度学习的火焰烟雾检测系统】15.【基于YOLOv8深度学习的钢材表面缺陷检测系统】16.【基于YOLOv8深度学习的舰船目标分类检测系统】17.【基于YOLOv8深度学习的西红柿成熟度检测系统】18.【基于YOLOv8深度学习的血细胞检测与计数系统】19.【基于YOLOv8深度学习的吸烟/抽烟行为检测系统】20.【基于YOLOv8深度学习的水稻害虫检测与识别系统】21.【基于YOLOv8深度学习的高精度车辆行人检测与计数系统】 二、机器学习实战专栏【链接】，已更新31期，欢迎关注，持续更新中~~
三、深度学习【Pytorch】专栏【链接】
四、【Stable Diffusion绘画系列】专栏【链接】
《------正文------》
1. 盛最多水的容器 class Solution: def maxArea(self, height: List[int]) -&gt; int: # 左右双指针 left = 0 right = len(height) - 1 res = 0 while left &lt; right: if height[left] &gt; height[right]: area = (right - left) * height[right] right -= 1 else: area = (right - left) * height[left] left += 1 res = max(res, area) return res 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c73169688dc3de30ad6ec25ea675a8c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9583e8b9cbb2097283fa21cc84e1e465/" rel="bookmark">
			C# DotNetCore AOP简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 实际开发中业务和日志尽量不要相互干扰嵌套，否则很难维护和调试。
示例 using System.Reflection; namespace CSharpLearn { internal class Program { static void Main() { int age = 25; string name = "bingling"; Person person = new(age, name); Console.WriteLine("====================不使用AOP===================="); person.DisplayMessage(); Console.WriteLine(); person.DisplayMessage("name"); Console.WriteLine("====================不使用AOP===================="); Console.WriteLine(); /*============================代理对象============================*/ PersonProxyDynamic&lt;Person&gt; personProxyDynamic = new(); personProxyDynamic.Before += (methodInfo) =&gt; { List&lt;string&gt; pt = new(); foreach (ParameterInfo? parameterInfo in methodInfo.GetParameters()) { if (parameterInfo.ParameterType.FullName != null) { pt.Add(parameterInfo.ParameterType.FullName); } } Console.WriteLine($"准备执行{methodInfo.Name}({string.Join(",", pt)})"); }; personProxyDynamic.After += (methodInfo) =&gt; { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9583e8b9cbb2097283fa21cc84e1e465/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2122bbe2b63be6b5e8483246c0642a7/" rel="bookmark">
			Java并发(十九)----Monitor原理及Synchronized原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Java 对象头 以 32 位虚拟机为例
普通对象
|--------------------------------------------------------------| | Object Header (64 bits) | |------------------------------------|-------------------------| | Mark Word (32 bits) | klass Word (32 bits) | |------------------------------------|-------------------------| 数组对象
|---------------------------------------------------------------------------------| | Object Header (96 bits) | |--------------------------------|-----------------------|------------------------| | Mark Word(32bits) | Klass Word(32bits) | array length(32bits) | |--------------------------------|-----------------------|------------------------| 其中 Mark Word 结构为
|-------------------------------------------------------|--------------------| | Mark Word (32 bits) | State | |-------------------------------------------------------|--------------------| | hashcode:25 | age:4 | biased_lock:0 | 01 | Normal | |-------------------------------------------------------|--------------------| | thread:23 | epoch:2 | age:4 | biased_lock:1 | 01 | Biased | |-------------------------------------------------------|--------------------| | ptr_to_lock_record:30 | 00 | Lightweight Locked | |-------------------------------------------------------|--------------------| | ptr_to_heavyweight_monitor:30 | 10 | Heavyweight Locked | |-------------------------------------------------------|--------------------| | | 11 | Marked for GC | |-------------------------------------------------------|--------------------| 64 位虚拟机 Mark Word
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c2122bbe2b63be6b5e8483246c0642a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403c0e11f0bb5868bb493fce7d177b7e/" rel="bookmark">
			“华为杯” 第二十届中国研究生数学建模竞赛 数模之星、华为之夜与颁奖大会
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言二、主要内容三、总结 🍉 CSDN 叶庭云：https://yetingyun.blog.csdn.net/
一、前言 不以物喜，不以己悲。见众生，见自己。
作为荣获一等奖的学生代表，我有幸参加了 “华为杯” 第二十届中国研究生数学建模竞赛颁奖典礼暨二十周年庆祝大会。此次盛会于 2023 年 12 月 15 日至 17 日在南京东南大学隆重举行，对我而言，这是一次极具意义的参会经历。
通过本篇博客，我愿意与读者分享我在整个活动中所获得的独特体验和深刻感受，并将其作为一个珍贵的记念。
东南大学校训：止于至善
华为的愿景与使命是把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界。
二、主要内容 缘起：
叮咚！一封来自数模二十周年颁奖盛典的邀请函：https://mp.weixin.qq.com/s/tfE1xSebo9xciFtJDSblqg重磅预告 | 第二十届中国研究生数学建模竞赛 “数模之星” 决赛答辩会即将来袭：https://mp.weixin.qq.com/s/V1QVa3Mj-tUWjLBIhczCCA 2023 年 12 月 15 日乘坐飞机抵达南京禄口机场，然后前往分配到的酒店报道以及领取相关物资。
2023 年 12 月 16 日，数模之星答辩。北京理工大学的一个团队非常厉害（京工数学建模队，做的是华为题），最后拿到了数模之星冠军。
👏👏 京工数学建模团队实至名归，遥遥领先！（微信视频号可以搜到有人现场录制的答辩视频）
值得一提的是，E 题的一个数模之星貌似不会算二分类任务的 F1 score！ 😅😅
尊敬的读者，您可能会对此感到一丝娱乐之情：将这样的研究结果展示于答辩的 PPT 中，实在是一种大胆之举。然而，似乎并没有多少人对此表示关注。针对 E 题的提问仅有一位女性专家进行了探讨，她很可能就是出题的专家。感觉她主要关注的是预测模型在临床应用中的价值。遗憾的是，两支答辩团队在回答时似乎都未能深入分析预测模型的可解释性以及关键预测指标在临床上的重要性。个人感觉，其中一个团队显得过度包装。
如上图 PPT 所示，令人惊讶的是，该机器学习预测模型的 F1 分数竟然达到了 1！ 在这种情况下，我们有必要仔细审查数据集的划分方法以及是否存在过拟合现象。显然，报告中并未提供关于均值、方差和混淆矩阵的详细分析。很可能是因为没有采用分层 K 折交叉验证方法，导致预测性能评估结果的可靠性大打折扣，尤其在标签类别不平衡的情况下。
此外，在认真审查计算结果后，作为一名具有丰富机器学习和数据科学经验的技术博主，我发现这些结果有点诡异。Precision 和 Recall 的值均未达到 1，那么如何得出 F1 分数为 1 的结论呢？ 这一点值得我们深入探讨和质疑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/403c0e11f0bb5868bb493fce7d177b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f6fdbbf4dbaa4cb8398e0579ac72ee/" rel="bookmark">
			【LangChain学习之旅】—（2） LangChain系统快速入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LangChain学习之旅】—（2） LangChain系统快速入门 LangChain 的基本安装OpenAI APIChat Model 和 Text ModelChat Model，聊天模型Text Model，文本模型 调用 Text 模型第 1 步第 2 步第 3 步第 4 步第 5 步第 6 步 调用 Chat 模型消息角色systemuserassistant Chat 模型响应 Chat 模型 vs Text 模型Chat 模型设计的主要优点： 通过 LangChain 调用 Text 和 Chat 模型调用 Text 模型调用 Chat 模型 小结 Reference：LangChain 实战课 LangChain 的基本安装 LangChain 的基本安装特别简单。pip install langchain。但是LangChain 要与各种模型、数据存储库集成，比如说最重要的 OpenAI 的 API 接口，比如说开源大模型库 HuggingFace Hub，再比如说对各种向量数据库的支持。默认情况下，是没有同时安装所需的依赖项。也就是说，当你 pip install langchain 之后，可能还需要 pip install openai、pip install chroma（一种向量数据库）……
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7f6fdbbf4dbaa4cb8398e0579ac72ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76179793c93b0aa0ba1c967f31bd9771/" rel="bookmark">
			2678. 老人的数目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你一个下标从 0 开始的字符串 details 。details 中每个元素都是一位乘客的信息，信息用长度为 15 的字符串表示，表示方式如下：
前十个字符是乘客的手机号码。
接下来的一个字符是乘客的性别。
接下来两个字符是乘客的年龄。
最后两个字符是乘客的座位号。
请你返回乘客中年龄 严格大于 60 岁 的人数。
示例 1：
输入：details = ["7868190130M7522","5303914400F9211","9273338290F4010"]
输出：2
解释：下标为 0 ，1 和 2 的乘客年龄分别为 75 ，92 和 40 。所以有 2 人年龄大于 60 岁。
示例 2：
输入：details = ["1313579440F2036","2921522980M5644"]
输出：0
解释：没有乘客的年龄大于 60 岁。
提示：
1 &lt;= details.length &lt;= 100
details[i].length == 15
details[i] 中的数字只包含 '0' 到 '9' 。
details[i][10] 是 'M' ，'F' 或者 'O' 之一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76179793c93b0aa0ba1c967f31bd9771/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7568dca428fd0648065e01eb4396e97b/" rel="bookmark">
			Java基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、@RestController @Controller相同点和不同点 @RestController和@Controller是Spring MVC中用于创建web控制器的两个核心注解，它们在定义控制器时有着不同的用途和行为。以下是它们的主要相似之处和区别：
相同点 组件扫描：两者都会被 Spring 的组件扫描机制识别，这意味着当你在类上使用这些注解时，Spring 会在启动时自动注册这些类作为 Spring 应用上下文中的 Bean。请求映射：两者都可以配合@RequestMapping或其派生的注解（如@GetMapping, @PostMapping等）来处理特定的HTTP请求。依赖注入：都可以利用Spring的依赖注入特性，比如通过@Autowired注入所需的依赖。 不同点 响应体处理：@RestController是@Controller和@ResponseBody注解的组合。在@RestController中，每个方法都隐含地定义为返回一个响应体，这意味着它会自动进行消息转换。而在@Controller注解中，你需要指定@ResponseBody来表明方法的返回结果应该直接写入HTTP响应体中，而不是被解析为跳转路径。用途： @Controller通常用于传统的MVC控制器，其中方法返回的是视图名称（例如JSP页面的路径），而视图负责渲染模型数据。@RestController用于创建RESTful控制器，它返回的对象数据直接写入HTTP响应体，通常用于构建API。这意味着你通常不会从@RestController方法返回视图名称。 消息转换：由于@RestController的方法默认加上了@ResponseBody，因此返回的对象会自动转换为JSON或XML等。在@Controller中，你需要指定@ResponseBody（或使用@RestControllerAdvice）来实现相同的效果。 源码级别的区别 @RestController的定义如下：
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Controller @ResponseBody public @interface RestController { @AliasFor(annotation = Controller.class) String value() default ""; } 如你所见，@RestController内部标注了@Controller和@ResponseBody，这意味着它继承了这两个注解的特性。
而@Controller的定义如下：
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Controller { @AliasFor(annotation = Component.class) String value() default ""; } @Controller被标注为一个常规的组件，但没有指定返回值的处理方式，因此你需要使用@ResponseBody或返回一个视图名称。
总结 在Spring MVC中，你会根据应用的不同需求选择使用@Controller或@RestController。如果你正在构建一个HTML界面，可能会选择@Controller来返回视图。而如果你在构建一个服务于客户端如移动应用、前端框架（如React或Angular）的后端API，那么@RestController会是一个更好的选择，因为它默认返回JSON或XML响应。
Java中每一个对象都可以作为锁，这是synchronized实现同步的基础 普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁
静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁
同步方法块，锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
2、springboot starter机制 Spring Boot的Starter机制是其核心特性之一，旨在简化依赖管理和自动配置，以便快速启动和运行Spring应用程序。Starter依赖是预定义的依赖集合，这些集合帮助你在项目中包含所需的Spring及相关技术的库。
Starter的特点 依赖传递：每个Starter都是一个Maven项目，它包含了需要启动某个功能所需的依赖库。当你在项目中包含一个Starter时，这个Starter相关的依赖也会被传递性地添加到你的项目中。自动配置：Spring Boot会利用Starter中包含的依赖来提供自动配置。这通常是通过@Configuration类实现的，该类中定义了条件化的Bean声明，只有在特定条件满足时这些Bean才会被创建。约定优于配置：使用Starter时，Spring Boot会提供一组默认配置，这些通常是基于约定的最佳实践。你可以通过在application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7568dca428fd0648065e01eb4396e97b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/39/">«</a>
	<span class="pagination__item pagination__item--current">40/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/41/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>