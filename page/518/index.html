<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78c9514be9dcc932a2ff1a4b44a1ee70/" rel="bookmark">
			进一步理解阿贾克斯（Ajax）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ajax简介 1、Asynchronous JavaScript and XML(异步的Javascript和XML） 2、是一种在无需重新加载整个网页的情况下能够更新部分网页的技术。 二、ajax同步&amp;异步 1、ajax同步和异步 利用XMLHTTPrequest对象和web服务器进行数据的异步交换 2、ajax-XMLHTTPrequest对象创建 var xhr = new XMLHttpRequest（）； //浏览器兼容 3、ajax-HTTP请求 HTTP：超文本传输协议，是一种无状态协议。 请求过程： 4、ajax- XMLHTTPrequest发送请求 1）open（method，URL，async） methold：get、postURL：async：true 2）send（string） 5、ajax-XMLHTTPrequest取得相应 responseText：获得字符串形式的响应数据responseXML：获得XML形式的响应数据status和statusText：以数字和文本形式返回HTTP状态码getAllResponseHeader():获取所有的响应报头getresponseheader（）：查询响应中的某个字段的值 转载于:https://www.cnblogs.com/chaojiaheng/p/8541158.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb7f446abf4ed9fe927f724bf11c516/" rel="bookmark">
			Windows平台JDK8下载和安装说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本页介绍如何安装和卸载Windows的JDK 8。
该页面包含以下主题：
“系统要求”
“安装说明符号”
“安装说明”
“卸载JDK”
“已安装的目录树”
“安装疑难解答”
有关安装JDK 8和JRE 8的一般信息，请参阅“JDK 8和JRE 8安装从这里开始”。
系统要求 查看http://www.oracle.com/technetwork/java/javase/certconfig-2095354.html有关支持的平台，操作系统和浏览器的信息。
请参阅“适用于JDK和JRE的Windows系统要求”以了解最低处理器，磁盘空间和内存要求。
注意：
JDK和JRE有一个版本字符串，使您可以确定版本号。请参阅http://www.oracle.com/technetwork/java/javase/jdk8-naming-2157130.html有关Java SE 8版本号的信息。
JDK可以选择安装公共JRE。有关JRE安装的更多信息，请参阅“适用于Microsoft Windows的JRE安装”。
如果您遇到任何困难，请参阅“安装疑难解答”或提交错误报告http://bugreport.java.com/bugreport/。
安装说明符号 对于本文档中包含以下标记的任何文本，您必须替换适当的更新版本号：
版 例如，如果您正在下载用于更新1.8.0_01的32位系统的JDK安装程序，则文件名称：jdk-8version-windows-i586.exe将变为jdk-8u1-windows-i586.exe。
同样，如果您正在下载用于更新1.8.0_01的64位系统的JDK安装程序，则文件名将jdk-8version-windows-x64.exe变为jdk-8u1-windows-x64.exe。
安装说明 在这些说明中，您将运行自行安装的可执行文件来解压缩并安装JDK。作为JDK的一部分，此安装包含一个包含公共Java运行时环境的选项。（JDK还包含一个专用JRE，仅供其工具使用;请参阅“Private Versus Public JRE”以获取更多信息。）
通过执行以下操作来安装JDK：
“下载安装程序”
“运行JDK安装程序”
“无声安装JDK”
“更新PATH环境变量”
“开始使用JDK”
下载安装程序 如果将自行安装的可执行文件保存到磁盘而不从网站的下载页面运行，请记下下载页面上指定的文件大小。下载完成后，确认您已下载完整文件。
运行JDK安装程序 您必须具有管理权限才能在Microsoft Windows上安装JDK。
该文件jdk-8version-windows-i586-i.exe是32位系统的JDK安装程序。该文件jdk-8version-windows-x64.exe是用于64位系统的JDK安装程序。如果您下载了任一文件而不是直接从网站运行它，请双击安装程序的图标。然后，按照安装程序提供的说明进行操作。完成安装后，可以删除下载的文件以恢复磁盘空间。
JDK 7u6及更高版本的安装程序安装JavaFX SDK并将其集成到JDK安装目录中。JDK 7u2到7u5的安装程序首先安装JDK，然后启动JavaFX SDK安装程序，该安装程序将JavaFX SDK安装在默认目录C:\Program Files\Oracle\JavaFX 2.0 SDK或C:\Program Files (x86)\Oracle\JavaFX 2.0 SDK64位操作系统上。如果要使用JDK 7u1或更早版本安装JavaFX SDK（2.0.2版），请参阅http://docs.oracle.com/javafx/2/installation/jfxpub-installation.htm以获取更多信息。
Java开始菜单 从JDK 7u40发行版开始，将Java菜单项添加到Windows“开始”菜单中，以便轻松访问Java资源。
在JDK安装期间，Windows开始菜单中会创建一个Java Development Kit文件夹，其中包含以下项目：
参考文档：打开在线API文档网页。
Java任务控制：打开Java任务控制概要分析和诊断工具套件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb7f446abf4ed9fe927f724bf11c516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eab490373a950bff9141a7d608fe3250/" rel="bookmark">
			shell 异常输出不显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 echo "123" &gt;/dev/null 2&gt;&amp;1
&gt; 代表重定向到哪里，例如：echo "123" &gt; /home/123.txt 1 表示stdout标准输出，系统默认值是1，所以"&gt;/dev/null"等同于"1&gt;/dev/null" 2 表示stderr标准错误 &amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee049bdc17aeb3384a8df5f16df3f582/" rel="bookmark">
			JAVA iterator的两种遍历方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 迭代器（Iterator） 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。 Java中的Iterator功能比较简单，并且只能单向移动： (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是; font-family:" pingfang="" text-align:="" background-color:="" /&gt; (2) 使用next()获得序列中的下一个元素。
(3) 使用hasNext()检查序列中是否还有元素。
(4) 使用remove()将迭代器新返回的元素删除。
Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。 迭代器应用： List list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); //方法一： for (Iterator i =list.iterator(); i.hasNext();) { int str = (int) i.next(); System.out.print(str); } //方法二： Iterator it = list.iterator(); while (it.hasNext()) { int str = (int) it.next(); System.out.print(str); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8e61801f208f6de28e861d3b5ad9b5/" rel="bookmark">
			白话讲排序系列（五） 归并排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何用最通俗易懂的话把归并排序说明白，这是个问题，本文只是做尝试；如果讲得不好，还请大家批评；如果讲得好，欢迎评论，转载。
好的，废话少说，开讲！
归并，之所以叫归并，就是算法的核心在于归并上；这就好比冒泡排序算法的核心，在于冒泡；选择排序的算法，核心在于从待排序的队列中选择出合适的数字一样。
（1）：归并，既然是并；那至少得是两个数列吧？是不是？要不然一个巴掌拍不响啊！
既然是两个数列，那么，最最简单的情况，每个数列都只有一个数字，直接比较一下大小就能够合并，这再简单不过了，是不是？
好的，我们已经踏出了归并算法的第一步；比如说两个数，1和2 ；一次比较得出结果，两个数字合在一起，组成了有序数列{1，2}。
然后呢，又来了一个数字，比如说这次来的是3，那么，其会跟原先的数列进行一下比较，发现可以放在数列的最后，三个数字商量一下，组成了{1，2，3}这样一个有序数列。
从最通俗的话来说，寥寥几句，其实就谈到了归并算法的精髓，那就是合并。
（2）如果合并的两个序列多了呢，怎么来从代码的角度阐述这个问题呢，接下来讨论。
比如说，现在来了两个序列，一个是a = {1，3，5}；一个是b = {2，4，6}。
很明显，合并后会出现一个大小为6的空间，我们先弄出来这么一个数组，比方说array。
首先，a中取出最小的元素，a[1] = 1,把这个数字放入新建的队列里；然后我们去看b，取出了b[1] = 2；取出来的这个数，要和已经在数组中的元素比较下，然后确定自己的位置，这样，array = {1，2}。
这里需要注意：我们是两个数列同时遍历的，所以要准备两个索引，对于a来说，就是i；对于b来说，就是j；这两个索引定义了a和b分别遍历到了什么位置。
大家可能会想到了，那么array是不是也需要一个位置来确定，其到底填充到了什么层次呢？是的，那需要不需要重新定义第三个变量？
这是不需要的，稍微想一下就能看出来，其实i和j与array的索引位置有着很密切的关系，所以array中填充到的位置，就可以用这两个值的组合来表示了：应该是i+j。
这时候，有心的同学可能会注意到了，为什么a和b都是有序的，真正排序的时候，不会出现这种巧合吧？
请认真想一下这个问题，后文会再度详细说明整体的流程。
就这样，a和b几乎是齐头并进，但是，他们两个总会有一个先全部为空的；即便是两个数列个数相同，但也会因为插入的先后次序，导致一个序列先插入到array中。
比如说，这时候1，2，3，4，5都插入到array中了，那剩下b中的数据，肯定要比前面五个元素都要大，因为b是有序的！！！
所以，哪一个序列多出来数字了，直接一股脑扔进array中，就可以了。
核心的归并，就是这么做的：双队列齐齐遍历，比较插入新数列中。
（3）回答一下上面我提出的问题，为什么拿出来两个有序的队列呢？
假如说，我们现在拥有一个序列 newArray = {1,3,5,4,7,6,9,8}；大家需要注意了，我们排序的是一个序列，而不是前面举例子用到了单个元素和队列中的部分元素。
那么，怎么才能把上面的思想用到这里呢？
答案是：先拆分。
当然，这里并不是真的拆分，而是从单个元素的角度去考虑，这里面共有八个元素，我们从单个元素的角度看，然后两两合并，经过一轮合并，就变成了四组，每组两个元素。
第二轮呢，再把四组元素两两合并，结果，就成为了两组元素。
第三轮，把上文的两组元祖再予以合并，最终，整个队列就变成了完全有序的了。
是不是很好理解？
想要真正理解这个算法，必须要记住，这是一种我们从单个元素开始考虑的算法，单个元素合并，逐渐合并成大的元素，最终，达到整个元素有序的目的。
网上找到了一张图，有助于理解，其本质，就是两步：第一，拆分；第二，归并。
多说无益，直接上代码：这是第一版本的代码
public class MergeSort { public static void main(String[] args) { int[] array = new int[] { 2, 1, 4, 3, 6, 10, 8, 7 }; // 注意，这里调用的时候，我们传入的是整个数组，从第一个元素到最后一个元素排序 sort(array, 0, array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8e61801f208f6de28e861d3b5ad9b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8cc14afdcd815f8e00f7dc18f0f58e3/" rel="bookmark">
			MS15-002 telnet服务缓冲区溢出漏洞分析与POC构造
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cssembly · 2015/01/16 9:09
0x00 漏洞原理分析 MS15-002是微软telnet服务中的缓冲区溢出漏洞，下面对其原理进行分析并构造POC。
telnet服务进程为tlntsvr.exe，针对每一个客户端连接会相应启动执行一个tlntsess.exe进程，补丁修补的是tlntsess.exe文件，通过补丁比对，确定漏洞位置如下，函数为
#!c++ signed int __thiscall CRFCProtocol::ProcessDataReceivedOnSocket(CRFCProtocol *this, unsigned __int32 *a2) 复制代码 补丁前，该函数分别为：
补丁后，该函数为：
也就是说原来一个缓冲区变成了两个，调用完
#!c++ (*(void (__thiscall **)(CRFCProtocol *, unsigned __int8 **, unsigned __int8 **, unsigned __int8))((char *)&amp;off_1011008 + v12))(v2,&amp;v13,&amp;v9,v6) 复制代码 之后，先对缓冲区中的数据长度进行判断，如果
#!c++ (unsigned int)(v9 - (unsigned __int8 *)&amp;Src - 1) &lt;= 0x7FE 复制代码 则判断目标缓冲区中可容纳字符的个数，如果
#!c++ (unsigned int)((char *)v14 + v7 - (_DWORD)&amp;Dst) &gt;= 0x800 复制代码 则退出，否则执行
#!c++ memcpy_s(v14, (char *)&amp;v18 - (_BYTE *)v14, &amp;Src, v9 - (unsigned __int8 *)&amp;Src) 复制代码 将数据拷贝到Dst缓冲区。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8cc14afdcd815f8e00f7dc18f0f58e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ae821deb846976dd25d7f6a40ac1ac5/" rel="bookmark">
			解决C# Random生成随机数重复的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#中我们通常使用Random类生成随机数，在一些场景下，我却发现Random生成的随机数并不可靠，在下面的例子中我们通过循环随机生成5个随机数：
for (int i = 0; i &lt; 5; i++) { Random random = new Random(); Console.WriteLine(random.Next()); } 这段代码执行后的结果如下所示：
2140400647 2140400647 2140400647 2140400647 2140400647 通过以上结果可知，随机数类生成了5个相同的数，这并非我们的预期，为什么呢？为了弄清楚这个问题，零度剖析了微软官方的开源Random类，发现在C#中生成随机数使用的算法是线性同余法，经百科而知，这种算法生成的不是绝对随机，而是一种伪随机数，线性同余法算法的的公式是：
第N+1个数 = ( 第N个数 * A + B) % M 上面的公式中A、B和M分别为常数，是生成随机数的因子，如果之前从未通过同一个Random对象生成过随机数（也就是调用过Next方法），那么第N个随机数为将被指定为一个默认的常数，这个常数在创建一个Random类时被默认值指定，Random也提供一个构造函数允许开发者使用自己的随机数因子，这一切可通过微软官方开源代码看到：
public Random() : this(Environment.TickCount) { } public Random(int Seed) { } 通过默认构造函数创建Random类时，一个Environment.TickCount对象作为因子被默认传递给第二个构造函数，Environment.TickCount表示操作系统启动后经过的毫秒数，计算机的运算运算速度远比毫秒要快得多，这导致一个的具有毫秒精度的因子参与随机数的生成过程，但在5次循环中，我们使用了同一个毫秒级的因子，从而生成相同的随机数，另外，第N+1个数的生成与第N个数有着直接的关系。
在上面的例子中，假设系统启动以来的毫秒数为888毫秒，执行5次循环用时只有0.1毫秒，这导致在循环中创建的5个Random对象都使用了相同的888因子，每次被创建的随机对象又使用了相同的第N个数（默认为常数），通过这样的假设我们不难看出，上面的结果是必然的。
现在我们改变这个格局，在循环之外创建一个Random对象，在每次循环中引用它，并通过它生成随机数，并在同一个对象上多次调用Next方法，从而不断变化第N个数，代码如下所示：
Random random = new Random(); for (int i = 0; i &lt; 5; i++) { Console.WriteLine(random.Next()); } 执行后的结果如下所示： 391098894 1791722821 1488616582 1970032058 201874423 虽然通过我们的随机数看起来也很随机了，但必定这个算法是伪随机数，当第N个数和因子都相同时，生成的随机数仍然是重复的随机数，由于Random提供一个带参的构造函数允许我们传入一个因子，如果传入的因子随机性强的话，那么生成的随机数也会比较可靠，为了提供一个可靠点的因子，我们通常使用GUID产生填充因子，同样放在循环中测试：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ae821deb846976dd25d7f6a40ac1ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc37424e9879c6a9aaa12fcd8fab361/" rel="bookmark">
			椭圆曲线--给自己看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结合：http://8btc.com/article-138-1.html， http://www.8btc.com/introduction 和https://www.cnblogs.com/Kalafinaian/p/7392505.html
关于椭圆曲线公式 已知P，Q两点 R=P+Q,求R 1.若P=Q 2.若P！=Q 直线斜率 那么根据带入椭圆曲线中求点R坐标（xR’,yR’）（R点经过对称坐标为（xR’,-yR’)） 根据三元方程中，当三次项系数为1时（有x1.x2.x3 三个解），常数项系数为 -x1x2x3，一次项系数为 x1x2+x2x3+x3x1，二次项系数为-(x1+x2+x3)。 于是得出：
密码学的应用
椭圆曲线是连续的，并不适合用于加密；所以，我们必须把椭圆曲线变成离散的点，我们要把椭圆曲线定义在有限域上。 我们给出一个有限域Fp
Fp中有p（p为质数）个元素0,1,2,…, p-2,p-1
Fp的加法是a+b≡c(mod p)
Fp的乘法是a×b≡c(mod p)
Fp的除法是a÷b≡c(mod p)，即 a×b^(-1)≡c (mod p)，b-1也是一个0到p-1之间的整数，但满足b×b-1≡1 (mod p)
Fp的单位元是1，零元是 0
Fp域内运算满足交换律、结合律、分配律 例题：椭圆曲线已知E23(1,1)上两点P(3,10)，Q(9,7)，求(1)-P，(2)P+Q，(3) 2P 考虑K=kG ，其中K、G为椭圆曲线Ep(a,b)上的点，n为G的阶（nG=O∞ ），k为小于n的整数。则给定k和G，根据加法法则，计算K很容易但反过来，给定K和G，求k就非常困难。因为实际使用中的ECC原则上把p取得相当大，n也相当大，要把n个解点逐一算出来列成上表是不可能的。这就是椭圆曲线加密算法的数学依据 点G称为基点（base point）k（k 小于n）为私有密钥（privte key）K为公开密钥（public key) ECC保密通信算法 1.Alice选定一条椭圆曲线E，并取椭圆曲线上一点作为基点G 假设选定E29(4,20)，基点G(13,23) , 基点G的阶数n=37
2.Alice选择一个私有密钥k（k小于n），并生成公开密钥K=kG 比如25, K= kG = 25G = (14,6）
3.Alice将E和点K、G传给Bob
4.Bob收到信息后，将待传输的明文编码到上的一点M（编码方法略），并产生一个随机整数r（r小于n,n为G的阶数） 假设r=6 要加密的信息为3,因为M也要在E29(4,20) 所以M=(3,28)
5.Bob计算点C1=M+rK和C2=rG C1= M+6K= M+6*25*G=M+2G=(3,28)+(27,27)=(6,12) C2=6G=(5,7)
6.Bob将C1、C2传给Alice
7.Alice收到信息后，计算C1-kC2，结果就应该是点M C1-kC2 =(6,12)-25C2 =(6,12)-25*6G =(6,12)-2G =(6,12)-(27,27) =(6,12)+(27,2) =(3,28)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fc37424e9879c6a9aaa12fcd8fab361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c9c25d0c887fbdf681a86fcf0319cde/" rel="bookmark">
			第一章  课后习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 面向对象程序设计概论 课后习题 一、名词解释
抽象：面向对象方法中的抽象，是指对具体问题(对象) 进行概括，找出一类对象的公共性质并加以描述的过程。
封装：面向对象方法中的封装就是把抽象出来的对象的属性和行为结合成一个独立的单位，并尽可能隐蔽对象的内部细节。
消息：消息机制是面向对象程序设计用来描述对象之间通信的机制。一个消息就是一个对象要求另一个对象实施某种操作的一个请求。
二、填空题
（1） 目前有 面向过程的结构化程序设计方法 和 面向对象的程序设计方法 两种重要的程序设计方法。 （2） 结构化程序设计方法中的模块由 顺序 、 选择 和 循环 3 种基本结构组成。
（3）在结构化程序设计方法中，程序可表示为 程序=数据结构+算法 ; 而面向对象的程序设计方法，程序可表示为 程序=对象+消息。
（4）结构化程序设计方法中的基本模块是 过程 ; 而面向对象程序设计方法中的基本模块是 类 .
（5）面向对象程序设计方法具有 抽象性 、 封装性 、 继承性 和多态性等特点。
三、选择题（至少选一个，可以多选）
（1）面向对象程序设计着重于（B）的设计。
A.对象 B.类 C.算法 D.数据
（2） 面向对象程序设计中，把对象的属性和行为组织在同 一个模块内的机制叫做（C）
A.抽象 B.继承 C.封装 D.多态
（3）在面向对象程序设计中，类通过（D）与外界发生关系。
A.对象 B.类 C.消息 D.接口
（4）面向对象程序设计中，对象与对象之间的通信机制是（C）
A.对象 B.类 C.消息 D.接口
（5）关于C++与C语言的关系的描述中，（D）是错误的。
A.C语言是C++的一个子集 B.C语言与C++是兼容的
C.C++对C 语言进行了一些改进 D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c9c25d0c887fbdf681a86fcf0319cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05fa0e16cb988f7aed92f932be51b1e/" rel="bookmark">
			白话讲排序系列（四）选择排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开门见山，本文讲述一下选择排序的原理，后附代码：
1：什么是选择排序？
选择排序，重在选择二字，拿出来与冒泡排序对比下，可能更好地理解这个选择排序的处理逻辑。
在冒泡排序中，每一趟都要保证排序序列中的最大数字，到整个数列的一端，比如说按照升序排序的话，最大数字会跑到整个数列的最右边；而冒泡排序每一趟是怎么做才达到目标的呢？交换，从待排序列的最左端一直交换，如此，最大值就交换到了最右边；循环往复，排序效果完成。
这里，重点在于交换。
好，那么，这种交换是不是必要的呢？
仔细思考下交换的目的，是为了最终能够把最大的数据交换到最后；但实际上，为了达到这个目标，并不一定需要不断交换，可以考量的思路是，从左向右一直比较，把最小或者最大数字的索引记录下来，然后把这个索引所对应的值与最左边或者最右边的值进行一下交换，这样，是不是也达到了相同的目标？
仔细思考十秒钟。
的确如此，如果我们在比较的过程中，只是进行比较，而不涉及交换操作，这个效率毫无疑问要比冒泡排序高一些，但实际上依旧属于交换类算法；因为其做法相当于是从一堆数中找到最小或者最大的数，是个选择操作，所以，称为选择排序。
这里，重点在于比较记录索引，不进行交换。
是不是通俗易懂？这就是选择排序的基本原理和思想。
下面附上代码：
public class SelectSorting { public static void main(String[] args) { int[] array = new int[] { 1, 3, 5, 7, 9, 2, 4, 6, 8, 10, 13, 15, 11 }; selectSort(array); for (int ele : array) { System.out.print(ele + " "); } } /** * @description * @param array */ public static void selectSort(int[] array) { // 重在于找到最大值的位置 int len = array.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c05fa0e16cb988f7aed92f932be51b1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a2efd574e5a80d3e4e2d0834a65a21c/" rel="bookmark">
			从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在浏览器地址栏输入URL 2、浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 ①如果资源未缓存，发起新请求 ②如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 ③检验新鲜通常有两个HTTP头进行控制Expires和Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 3、浏览器解析URL获取协议，主机，端口，path 4、浏览器组装一个HTTP（GET）请求报文 5、浏览器获取主机ip地址，过程如下： ①浏览器缓存 ②本机缓存 ③hosts文件 ④路由器缓存 ⑤ISP DNS缓存 ⑥DNS递归查询（可能存在负载均衡导致每次IP不一样） 6、打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： ①客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 ②服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 ③客户端发送ACK=Y+1， Seq=Z 7、TCP链接建立后发送HTTP请求 8、服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 9、服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 10、处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 11、服务器将响应报文通过TCP连接发送回浏览器 12、浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： ①主动方发送Fin=1， Ack=Z， Seq= X报文 ②被动方发送ACK=X+1， Seq=Z报文 ③被动方发送Fin=1， ACK=X， Seq=Y报文 ④主动方发送ACK=Y， Seq=X报文 13、浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 14、如果资源可缓存，进行缓存 15、对响应进行解码（例如gzip压缩） 16、根据资源类型决定如何处理（假设资源为HTML文档） 17、解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 18、构建DOM树： ①Tokenizing：根据HTML规范将字符流解析为标记 ②Lexing：词法分析将标记转换为对象并定义属性和规则 ③DOM construction：根据HTML标记关系将对象组成DOM树 19、解析过程中遇到图片、样式表、js文件，启动下载 20、构建CSSOM树： ①Tokenizing：字符流转换为标记流 ②Node：根据标记创建节点 ③CSSOM：节点创建CSSOM树 21、根据DOM树和CSSOM树构建渲染树: ①从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none ②对每一个可见节点，找到恰当的CSSOM规则并应用 ③发布可视节点的内容和计算样式 22、js解析如下： ①浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading ②HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 ③当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 ④当文档完成解析，document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a2efd574e5a80d3e4e2d0834a65a21c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28bf975163033bc1127920f79a0a85e7/" rel="bookmark">
			白话讲排序系列（三） 快速排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同冒泡排序一样，快速排序属于交换类排序，但是，因为加入了分而治之的思想，快速排序的平均复杂度可以达到O(nlogn)；本文将用大白话讲述一下快速排序的实现原理；同样，末尾将附上完整可行的快速排序算法代码（Java版本）。
注：文中有些图可能来自于其他链接，会在文末附上。
为了方便介绍快速排序的整体思想，这里先定义一个数组：
int[] array = new int[] { 45, 38, 65, 97, 76, 13, 27, 49, 20, 54 };
接下来的数据分析，都以该数组为基础：
一个基本概念：基数。
什么是基数呢？就是我们从待排序的数列中，随机选出一个数，就可以称为基数，它没什么特殊的含义，就是完全随机挑出来的一个数，我们只是称其为基数；通常呢，我们会挑选第一个数字作为基数，对于讨论的数组，就是45，其作为基数。
好地，接下来真正进入快速排序的流程，全是大白话，绝对通俗易懂：
当前：数组元素为：45 38 65 97 76 13 27 49 20 54；10个数字，前文已经选定了基数为45。
第一步，我们把45单独挖出来，其所在的位置，就形成了一个坑（__符号表示此处是坑，没有萝卜（数字））；挖掉之后的效果如下：注：上面一行是索引值；这里以0为开始索引。
0 1 2 3 4 5 6 7 8 9
__ 38 65 97 76 13 27 49 20 54
第二步，从右侧开始遍历，寻找第一个比基数，就是我们定义的那个基数45小的数字，我们从右向左走，找到的数字是20，这是第一个遇到的比45小的数字，接着，将其挖掉，则原地就留下了另一个坑，这时候，效果如下：
0 1 2 3 4 5 6 7 8 9
__ 38 65 97 76 13 27 49 __ 54 :注意，目前图中有了两个深坑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28bf975163033bc1127920f79a0a85e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410803bbfd1d11b8d7d4327d8bf7a1b1/" rel="bookmark">
			CCS 中项目文件解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.include头文件（.h)的主要作用 头文件，一般用于定义程序中的函数、参数、变量和一些宏单元，同库函数配合使用。因此，在使用库时，必须用相应的头文件说明。 2.DSP/BIOS CONFIG FILES 开发基于DSP/BIOS的程序保存BIOS配置之后自动产生的文件。在保存BIOS配置时候会产生program.cbd/programcfg.h54/programcfg.s54/programcfg.cmd/programcfg.h/programcfg_c.c(C5000的example，program为你的项目名)，这些文件被分配在project不同目录。 3.Source Files 源程序，实现DSP系统指定功能的主要代码部分 4.Program.cmd 链接文件，在源文件经过汇编器（Assembler）输出的OBJ Files（目标文件）需要通过Linker（链接器）才能得到OUT files，在链接阶段Linker根据.cmd里面存储区、Section分配以及lib来链接rst.lib、csl.lib、DSP/BIOS library跟对段的重定位 5.Library Filers的作用 Rst.lib：C语言实时运行支持库，建立C运行环境，由_c_int00主要完成设置堆栈指针、初始化全局变量、调用main（） Csl.lib：芯片支持库，实现片内外设的操作 DSPLIB/IMGLIB：信号处理库，利用针对不同DSP的优化的函数进行数学运算 通用的视/音LIB：例如263、264、jpeg、G.7XX、mp3、wmv。。。 其他自己封装的LIB：例如bsl.lib（board source library），对DSP系统板上资源的操作。 其他文件： .opt工程关于开发环境的参数文件。如工具条位置等信息； .aps (AppStudio File),资源辅助文件,二进制格式,一般不用去管他. .clw ClassWizard信息文件,实际上是INI文件的格式,有兴趣可以研究一下.有时候ClassWizard出问题,手工修改CLW文件可以解决.如果此文件不存在的话,每次用ClassWizard的时候绘提示你是否重建. .dsp (DeveloperStudio Project):项目文件,文本格式,不过不熟悉的话不要手工修改.DSW(DeveloperStudio Workspace)是工作区文件,其他特点和DSP差不多. .plg 是编译信息文件,编译时的error和warning信息文件（实际上是一个html文件）,一般用处不大.在Tools-&gt;Options里面有个选项可以控制这个文件的生成. .hpj (Help Project)是生成帮助文件的工程,用microsfot Help Compiler可以处理. .mdp (Microsoft DevStudio Project)是旧版本的项目文件,如果要打开此文件的话,会提示你是否转换成新的DSP格式. .bsc 是用于浏览项目信息的,如果用Source Brower的话就必须有这个文件.如果不用这个功能的话,可以在Project Options里面去掉Generate Browse Info File,可以加快编译速度. .map 是执行文件的映像信息纪录文件,除非对系统底层非常熟悉,这个文件一般用不着. .pch (Pre-Compiled File)是预编译文件,可以加快编译速度,但是文件非常大. .pdb (Program Database)记录了程序有关的一些数据和调试信息,在调试的时候可能有用. .exp 只有在编译DLL的时候才会生成,记录了DLL文件中的一些信息.一般也没什么用. .ncb 无编译浏览文件(no compile browser)。当自动完成功能出问题时可以删除此文件。build后会自动生成。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a83d98e8573ebb8a41555514606a04dc/" rel="bookmark">
			白话讲排序系列（二） 冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原理，参考自数据结构（C语言版）严蔚敏：
首先，对于一个无序数列，每一趟排序，都会有一个最大的元素沉到水底。
从上图中可以看出，每经过一趟排序，最大的记录都会到达序列的末端，这是每一趟冒泡排序的过程，需要达到的目的，下面，探讨过程，如何才能每一趟实现这个目标。
条件：
需要排序的序列：49 38 65 97 76 13 27 49排序的目标：无序数列成为升序数列 冒泡排序过程中，为了实现该目标，在每一趟排序的过程中，采取的是相邻元素交换的方式，按照指定的逻辑，交换相邻的元素，达到这个目标；下面用白话阐述一下第一趟排序的过程：
首先，49和38进行比较，发现49更大，二者交换（注意，这里必须是交换，而不是赋值操作）；交换过后的结果：
38 49 65 97 76 13 27 49；
接着，49和65比较，发现满足升序关系，不进行交换；
接着，65和97比较，发现同样满足升序关系，依旧不进行交换。
接着，97和76比较，发现不满足升序，二者交换，结果变成：38 49 65 76 97 13 27 49；
接着，97和13进行比较，二者交换；结果变成：38 49 65 76 13 97 27 49；
接着，97和27进行比较，二者交换，结果变成：38 49 65 76 13 27 97 49；
接着，97和49进行比较，结果变成：38 49 65 76 13 27 49 97；
好了，现在第一趟的排序结束了，通过元素遍历交换的方式，现在最大的元素成功地沉到了水底；然后第二次排序，倒数第二大的元素继续跑到倒数第二的位置。
每一趟排序，都会有一个元素到达自己最终的位置，这是冒泡排序的一个特点；而且冒泡排序属于交换类排序。
基本思想，就是这样：相邻元素交换，最大元素沉底。
算法思想明了，接下来就是代码实现了；这里提供一种实现形式，其实只要满足这个思想，都可以叫做冒泡排序，不必拘泥于代码的内容，重在思想。
/** package com.ccx; /** * @author yuzhao.yang * @description: * @time:2018年3月6日 下午5:25:19 */ public class BubbleSorting { public static void main(String[] args) { int a[] = new int[] { 38, 49, 65, 97, 76, 13, 27, 49, 20 }; bubbleSort(a); } public static void bubbleSort(int a[]) { int len = a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a83d98e8573ebb8a41555514606a04dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e048448d96d76e2a36c756aa3e8042/" rel="bookmark">
			fatal error C1083: 无法打开预编译头文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前时不时遇到有关无法打开预编译头文件的错误，具体错误信息大致如下：
fatal error C1083: 无法打开预编译头文件：“Debug/UGFace.pch”: No such file or directory 以前总是想不明白为何出现这个错误。今天同事又问我这个问题，在一刹那我突然想明白了这个问题。
我的思考过程是这样的：既然错误提示是UGFace.pch不存在，那么就是说它没有生成。那么问题来了，为什么UGFace.pch没有生成，它又是由哪个文件生成的呢？我们知道预编译头文件主要是将系统库(如Windows SDK)的常用头文件都放到一个头文件stdafx.h里包含，那么xxx.pch就是通过stdafx.cpp生成的。而stdafx.cpp没有生成xxx.pch是因为没有设置它的属性为创建预编译头，实际上很多时候不知为何把它设为了使用预编译头。因此需要在stdafx.cpp的属性设置中将它设为创建预编译头，具体如下图：
注意工程的预编译头属性还是使用预编译头，网上很多以讹传讹的文章说是把工程属性改为不使用预编译头，应该说这种办法也能解决问题，但毫无疑问没有使用预编译头会大大降低编译效率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3935407351ae67f9e10cd89a598f6938/" rel="bookmark">
			论文Sequential Short-Text Classification with Recurrent and Convolutional Neural Networks 的实验部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的基本模型结构：
结果和讨论
为了找到有效的超参数，我们每次只改变一个超参数，同时保持其他固定。表2显示我们的超参数选择。
我们对DSTC4，用谷歌新闻的word2vec预训练的300维的词向量初始化词向量。对MRDA和SwDA，用Glove和Twitter预训练的200维的词向量。因为这些选择能够在公开可达的word2vec，Glove，SENNA和RNNLM词向量上产生最好的结果。
对短文本和分类表示的原始尺寸d1和d2的影响在表3中呈现，用于LSTM和CNN模型。在两个模型中，增加d1的同时保持d2=0，能将性能提高1.3-4.2个百分点。相反，增加d2保持d1=0能产生更好的结果，但是性能增加的不是那么明显：在短文本表示级合并序列信息比在类别表示级更有效。
在短文本表示级和分类表示级使用序列信息在大多数情况下都不会有所帮助，甚至还可能会降低性能。我们假设短文本表示比分类表示包含更丰富和普遍的信息。因为前者维度更高。分类表示可能较短文本表示不会传达额外的信息，并且可能从前面错误的分类中传播错误。
表4是我们的结果和一些先进结果的比较。在总体上，我们的模型展现了可比的结果，然而不需要人工设计的特征。严格的比较很难绘制，比如文本预处理的许多重要细节，训练/验证/测试集可能不同，尽管训练过程中一部分的随机性，许多研究的执行失败了好几次，例如权重初始化。
展示的是在验证集上有最高精度时测试集上运行的结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43666034be78fa8fd87c0064cb86ec90/" rel="bookmark">
			白话讲排序系列（一） 直接插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接插入排序的基本思想，就是：每次将一个待排序的记录，将其按照关键字大小插入到前面已经排好序的子序列中的适当位置，知道全部记录插入完成为止。
算法的思想，可以参照平时玩纸牌的时候（来源于算法导论的例子），我们拿到第一张牌，本身就是有序的，第二张牌与第一张牌比较下，看大小，决定放在第一张牌的前面还是后面。
如果手里已经有了N张牌，然后取了第N+1张牌，这张牌从最后面与前面的牌进行比较，如果大，则就放在第N张牌后面；如果小，那就继续与第N-1张牌比较，一直找到合适的地方为止。
总的来说，就是循环比较找位置，移动数据来插入。
本人用Java比较多，这里选择用Java进行开发：
无序数组排序如下：
public class InsertSorting{ public static void main(String[] args) { int[] array = new int[] { 1, 3, 5, 4, 6, 2, 7, 9, 8 }; selectorSort(array); } public static void selectorSort(int array[]) { // 此处从第二个元素开始，因为第一个元素自身肯定是有序的 // 而且外循环肯定是要遍历从第二个元素开始的所有元素 for (int i = 1; i &lt; array.length; i++) { // 内循环是为了确定插入元素的位置，所以要遍历前面的有序集合 int j = i - 1; int num = array[i]; for (; j &gt;= 0; j--) { // 如果元素大于num if (array[j] &gt; num) { // 该元素往后挪动一个位置 array[j + 1] = array[j]; } else { break; } } // 最后在确定的位置上插入数据 array[j + 1] = num; } for (int ele : array) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43666034be78fa8fd87c0064cb86ec90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fedd03d09f0f7f920f5624c2ce5163b/" rel="bookmark">
			Spring Cloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2018-03-05 erixhao 技术极客TechBooster 很久以前就想写篇关于Spring Cloud的文章，然而终究许久未动笔，直到时间的车轮转到2018。
本篇以基础概要介绍为主，适合宏观了解Spring Cloud的整体布局及主要组件用途。
目录
Spring Cloud背景简介
Microservice微服务
Spring Cloud - Netflix
Sping Cloud - Main Projects
Cloud v.s. Dubbo
总体回顾
背景简介 1 Spring Cloud是在云时代背景下，由Spring家族于2015年推出的主要针对分布式系统开发的基础设施，组合，集成了一系列经典的框架（17年版本中就集成了19+个子项目），提供了分布式开发的核心基础功能如服务注册与发现，配置，消息总线，服务网关，负载均衡，服务熔断，数据治理与监控等，它整个框架系列构建与自身家族Spring Boot，大大简化了开发，实现和部署。当然，其幕后推手除了本身大东家Pivotal外，还有Netfix作为强大后盾。
这套框架的整合，集成之道，又一次发挥，弘扬了Spring的“吸星大法”，这正是Spring在框架，架构上的精髓，尽量避免重复轮子，取各家之精华，整合为我用，抽象并构建统一而简单的接口给开发人员，当然Spring初创之时当然自带神器。
另外，Spring Cloud之所以变得炙手可热，除了后云时代，很大程度上也借助了近几年兴起的微服务之风。正是由于Spring Cloud诞生于云端，生而为支持分布式系统及基础，与微服务架构不谋而合，甚至很多人提及Spring Cloud就认为其就是一个微服务框架。
Microservices 微服务 2 既然谈到这里，顺便提议一下微服务。微服务是一种架构风格，组件的另一种模式或实现，一个大型的系统由多个微服务组成，每个微服务可以独立部署，并且微服务间是松耦合。其中每个微服务理想情况，完成一个小的业务能力。
其实微服务在软件行业发展多年后，突然发现在工业，硬件领域，似乎其更加模块化，一个大型器械或者我们更熟悉的电脑可以通过每个独立的模型部件快速拼搭而成，而一个软件项目则说来惭愧，无法像积木一样快速搭建，尽管已经大规模模块化，组件化...（当然，近几年软件业蓬勃发展，已经有了很多容器技术如Docker, 集群技术K8s, Mesos 等等）
其实“微服务”这个概念名词源于2014年3月Martin大叔写的一片文章 “Microservices”，既然出自大师之手，自然瞬间在坊间开始追捧，推动。
简单来说，微服务架构是以专注于单一职责的小型功能模块为子服务，一个后台服务通过RPC相互通信，去中心化，松耦合化完成复杂业务系统的设计思想。
微服务框架核心要解决或者基础设施必须要做到RPC, 服务注册与发现，负载均衡，分布式配置，服务熔断机制和服务网关路由几个核心要素。
在带来上述好处的同时，也具有维护，部署，版本，运营，DevOps，分布式事务以及本身服务间通信成本，测试等一些列挑战，当然，对于坊间的架构师来说，这都不是事，每一个新技术都看作圣杯，情怀第一。
SpringCloud - Netfilx 3 赶快进入正题 - SpringCloud，先从主要且重要的五大神兽说起：
服务发现 - Netflix Eureka 负载均衡 - Netfilx Ribbon
服务熔断 - Netfix Hystrix
服务网关 - Netflix Zuul
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fedd03d09f0f7f920f5624c2ce5163b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa78060075650a185a9f3d51375ca35a/" rel="bookmark">
			理解图像中的低频分量和高频分量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
http://blog.sina.com.cn/s/blog_8da31aa3010142x8.html
http://blog.sina.com.cn/s/blog_a98e39a201012hpp.html#cmt_532CFB31-7F000001-7D764EA9-873-8A0
总得来说，低频分量（低频信号）代表着图像中亮度或者灰度值变化缓慢的区域，也就是图像中大片平坦的区域，描述了图像的主要部分。。高频分量（高频信号）对应着图像变化剧烈的部分，也就是图像的边缘（轮廓）或者噪声以及细节部分。
之所以说噪声也对应着高频分量，是因为图像噪声在大部分情况下都是高频的。
低频分量：主要对整幅图像强度的综合度量。高频分量：主要是对图像边缘和轮廓的度量。而人眼对高频分量比较敏感。
我们试着用傅立叶变换站在另外一个角度观察图像，将图像从灰度分布转化到频率分布（频谱图）上去观察图像的特征。需要了解的是，图像进行二维傅立叶变换之后得到的频谱图，就是图像梯度的分布图。具体的，傅立叶频谱图上我们能看到明暗不一的亮点，实际是图像上某一点与邻域点差异的强弱，即梯度的大小。
所以说，如果一幅图像的各个位置的强度大小相等，则图像只存在低频分量。从图像的频谱图上看，只有一个主峰,且位于频率为零的位置.。需要提一句的是，图像的频谱图可以由傅里叶变换得到。
如果一幅图像的各个位置的强度变化剧烈，则图像不仅存在低频分量，同时也存在多种高频分量。从图像的频谱上看，不仅有一个主峰,同时也存在多个旁峰。可以这样理解：图像中的低频分量就是图像中梯度较小的部分，高频分量则相反。
从直方图上看，低频分量对应直方图内大块区域，而小块或者离散的区域就是高频分量。这说明低频分量占据了图像的主要部分。
从二维函数上理解，变化剧烈的地方就是高频分量，变化少的地方就是低频分量。
总结 总的来说，其实低频分量和高频分量只是一种相对的概念。对于二维信号来说，即图像，低频分量和高频分量与像素值的大小无关。比如一张全白的图像，从像素值的意义上来说它的值全是255，在uint8中已经是像素的最大值，但是它却只有低频分量而没有高频分量。因为每一个像素点(目标像素点)的周围都不具有对比度，即周围像素点没有相对于目标像素点的像素值大或者小。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d90c0a5ab3fcf8e6f6608cb3d3a1559/" rel="bookmark">
			ReLu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ReLu是神经网络中的一个激活函数，其优于tanh和sigmoid函数。
1.为何引入非线性的激活函数？
如果不用激活函数，在这种情况下每一层输出都是上层输入的线性函数。容易验证，无论神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当，这种情况就是最原始的感知机（Perceptron）了。因此引入非线性函数作为激活函数，这样深层神经网络就有意义了（不再是输入的线性组合，可以逼近任意函数）。最早的想法是sigmoid函数或者tanh函数，输出有界，很容易充当下一层输入。
2.引入ReLu的原因
第一，采用sigmoid等函数，算激活函数时（指数运算），计算量大，反向传播求误差梯度时，求导涉及除法，计算量相对大，而采用Relu激活函数，整个过程的计算量节省很多。
第二，对于深层网络，sigmoid函数反向传播时，很容易就会出现梯度消失的情况（在sigmoid接近饱和区时，变换太缓慢，导数趋于0，这种情况会造成信息丢失，，从而无法完成深层网络的训练。
第三，ReLu会使一部分神经元的输出为0，这样就造成了网络的稀疏性，并且减少了参数的相互依存关系，缓解了过拟合问题的发生。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a5d75f613d9b9e5dbc1cf9c843c9b03/" rel="bookmark">
			jQuery添加/改变/移除CSS类及判断是否已经存在CSS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. removeClass() - 移除CSS类 $("#target").removeClass("oldClass"); //#target 指的是需要移除CSS类的元素的ID //oldClass 指的是CSS类的名称 2.addClass() - 添加CSS类 $("#target").addClass("newClass"); //#target 指的是需要添加样式的元素的ID //newClass 指的是CSS类的名称 3. toggleClass() - 添加或者移除CSS类：如果CSS类已经存在，它将被移除；相反，如果CSS类不存在，它将被加上。 $("#target").toggleClass("newClass") //如果ID为“target”的元素已经定义了CSS样式，它将被移除； //反之，CSS类“newClass”将被赋给该ID 4.hasClass("className") - 判断是否已经存在CSS 在实际运用中，我们通常是先定义好这些CSS类，然后通过Javascript事件触发（比如点击某个按钮）来改变页面元素样式。 此外，jQuery还提供一种方法 hasClass("className")，用来判断某个元素是否已经被赋予某个CSS类。 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.4.2.min.js"&gt;&lt;/script&gt; &lt;style&gt; .xxx{background:#f00;color:#fff} &lt;/style&gt; &lt;div class="city" id="city-area" filt="nameTag"&gt; &lt;div class="filted" key="location" value="北京"&gt; 北京 &lt;/div&gt; &lt;div class="btn" key="location" value="上海"&gt; 上海 &lt;/div&gt; &lt;div class="btn" key="location" value="天津"&gt; 天津 &lt;/div&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a5d75f613d9b9e5dbc1cf9c843c9b03/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96ee9072534578c37123c51a650ce8e/" rel="bookmark">
			ITOO测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试ITOO 前言： 学习靠的是主动，这次我很好 的主动了，因为我并不是ITOO测试组的，但是我因为积极主动了，就临时让我加了进去，而这其中我学到了很多的东西！
正文： 通过ITOO我学到很多我之前没有的体验，下面是我的分享 第一，考试需求和流程 第二，考试过程中作为内部人员和测试人员的关系 第三，测试过程中需要测试的内容 第四，常见问题的处理和紧急问题的处理 第五，备份的需求 第六，录屏的作用 第七，数据的保存
流程 人员作用 人员作用开发人员对系统进行开发测试人员对系统进行测试，发现问题上报内部人员对系统进行维护，解决问题 测试内容 1、网页能否进入 2、学生出题是否正常 3、服务器能够承受的压力值 4、浏览器网速的正常与否
问题的处理 常见问题处理（PS：因为不知道代码的处理，所以就写一下处理的方向，具体处理方法等待后期借鉴师哥们的博客进行补充）：
问题一：学生网页登陆不上。 处理办法：检查服务器是否打开，服务器权限，是否为一个局域网。 问题二：学生没有题。 处理办法：检查数据库，检查该生是否配题，检查学生漏题的原因 问题三：服务器内存不足，导致提交后信息丢失 处理办法：如果能在短时间内换则换，第二就是给学生留下json文件进行人工处理 备份作用 在一个企业和系统中对数据的备份是很重要的，当因为某些原因让数据丢失后这个时候由于拥有备份可以直接恢复，使其的损失降到最低。 在这个ITOO中我知道了一些内容需要备份： 试题内容，学生答题记录，学生信息等等。
录屏 对测试过程中的问题有一个依据，分析其中的原因时候可以找到依据去分析，判断找到的原因的正确性。也是对该软件的使用情况的适用度进行合理的分析。
存档 对学生考试后的结果存档，这里也是需要备份的，其中一份可以进行处理，另一份方便学生以后查看成绩。
目录 用 [TOC]来生成目录：
测试ITOO 前言：正文：流程 人员作用测试内容问题的处理 问题一：学生网页登陆不上。 处理办法：检查服务器是否打开，服务器权限，是否为一个局域网。 问题二：学生没有题。 处理办法：检查数据库，检查该生是否配题，检查学生漏题的原因 问题三：服务器内存不足，导致提交后信息丢失 处理办法：如果能在短时间内换则换，第二就是给学生留下json文件进行人工处理 备份作用录屏存档目录 -
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c417430548ecdfe8ae59ddd1423d633/" rel="bookmark">
			如何解决过拟合问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何降低过拟合？这是深度学习中非常重要的问题。关于过拟合的相关概念和过拟合带来的危害，可参考笔者之前的博客：过拟合与欠拟合简要总结。
如何解决过拟合？ 1. 获取和使用更多的数据集 对于解决过拟合的办法就是给与足够多的数据集，让模型在更可能多的数据上进行“观察”和拟合，从而不断修正自己。然而事实上，收集无限多的数据集几乎是不可能的，因此一个常用的办法就是调整已有的数据，添加大量的“噪音”，或者对图像进行锐化、旋转、明暗度调整等优化。
另外补充一句，CNN在图像识别的过程中有强大的“不变性”规则，即待辨识的物体在图像中的形状、姿势、位置、明暗度都不会影响分类结果。
2. 采用合适的模型 目前来说，针对不同的情况和分类要求，对使用的模型也是千差万别。过于复杂的模型会带来过拟合问题。
对于模型的设计，目前公认的一个深度学习规律“deeper is better”。国内外各种大牛通过实验和竞赛发现，对于CNN来说，层数越多效果越好，但是也更容易产生过拟合，并且计算所耗费的时间也越长。因此对于模型的设计需要合理参考各种模型的取舍。
3. 使用 Dropout Dropout 是一个非常有用和常用的方法。Dropout 指的是在训练过程中每次按一定的几率关闭或忽略某些层的节点。使得模型在使用同样的数据进行训练时相当于从不同的模型中随机选择一个进行训练。
至于 Dropout 起作用的原因，可以简单理解成在训练过程中会产生不同的训练模型，不同的训练模型也会产生不同的的计算结果，随着训练的不断进行，计算结果会在一个范围内波动，但是均值却不会有很大变化，因此可以把最终的训练结果看作是不同模型的平均输出。
4. 正则化 正则化又称为权重衰减，具体做法是将权值的大小加入到损失函数中，在实际使用中分为 L1 正则与 L2 正则。关于正则化能够防止过拟合的原因，笔者会在下一篇博客中专门花篇幅详细讲解。
5. Early Stopping Early Stopping 是参数微调中的一种，即在每个循环结束一次以后（这里的循环可能是 full data batch,也可能是 mini batch size），计算模型的准确率（accuracy）。当准确率不再增加时就停止训练。
这是一种非常简单和自然的办法，准确率不再增加时就停止训练，防止模型对已有的数据继续训练。但是问题在于，准确率在每个循环之后的计算是变化的，没有任何人和任何模型能保证准确率不会变化，可能某次循环结束后，准确率很高，但是下一轮结束后准确率又降得很低。
这里笔者建议的一个办法是人为地设定一个范围。当连续10次准确率在此范围内波动时就停止循环。
6. 可变化的学习率 可变化的学习率也是根据模型计算出的准确率进行调整。一个简单的方法是在人为设定的准确率范围内，达到10次范围内的波动后，依次将学习率减半，直到最终的学习率降为原始的 1/1024 时停止模型的训练。
7. 使用 Batch_Normalization 还有一个数据处理的方法 Batch_Normalization，即数据在经过卷积层之后，真正进入激活函数之前需要对其进行一次 Batch_Normalization，分批对输入的数据求取均值和方差之后重新对数据进行归一化计算。
这样做的好处就是对数据进行一定程度的预处理，使得无论是训练集还是测试集都在一定范围内进行分布和波动，对数据点中包含的误差进行掩盖化处理，从而增大模型的泛化能力。
除此之外还有哪些常用的消除过拟合的方法？ 除了上述提到的方法，还有常用的是交叉验证、PCA特征提取、增加各种噪音等。这样实际上还是属于增加了数据集，增加数据集是解决过拟合的根本性方法。除此之外对于模型来说，尽量选择较为简单的模型也是解决过拟合的一个常用方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c182512291547ab93c3da8730bbe9424/" rel="bookmark">
			PhotoView-github
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://github.com/chrisbanes/PhotoView 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0131b08cfff01081e1c4b12a46a6c2ed/" rel="bookmark">
			java序列化框架（protobuf、thrift、kryo、fst、fastjson、Jackson、gson、hessian）性能对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ 我们为什么要序列化 举个栗子：下雨天我们要打伞，但是之后我们要把伞折叠起来，方便我们存放。那么运用到我们java中道理是一样的，我们要将数据分解成字节流，以便存储在文件中或在网络上传输，这叫序列化。我们要用的时候，就需要将字节流重构成对象，这叫反序列化。不知道我这么说大家能不能理解。
java序列化的缺点 java自己提供序列化而且用起来也非常简单，但是在远程服务调用中很少用它，主要存在以下缺点：
1.无法跨语言。这应该是java序列化最致命的问题了。由于java序列化是java内部私有的协议，其他语言不支持，导致别的语言无法反序列化，这严重阻碍了它的应用。 2.序列后的码流太大。java序列化的大小是二进制编码的5倍多！ 3.序列化性能太低。java序列化的性能只有二进制编码的6.17倍，可见java序列化性能实在太差了。 总结 我们判断一个编码框架的优劣主要从以下几个方面：
1.是否支持跨语言，支持语种是否丰富 2.编码后的码流 3.编解码的性能 4.类库是否小巧，API使用是否方便 5.使用者开发的工作量和难度。 几个流行的编解码框架 1.google的Protobuf Protobuf是google开源的项目，全称 Google Protocol Buffers.特点：
1.结构化数据存储格式（xml,json等） 2.高性能编解码技术 3.语言和平台无关，扩展性好 4.支持java,C++,Python三种语言。 2.faceBook的Thrift Thrift源于faceBook，2007年facebook将Thrift做为一个开源项目交给了apache基金会。特点：
1.Thrift支持多种语言（C++,C#,Cocoa,Erlag,Haskell,java,Ocami,Perl,PHP,Python,Ruby,和SmallTalk） 2.Thrift适用了组建大型数据交换及存储工具，对于大型系统中的内部数据传输，相对于Json和xml在性能上和传输大小上都有明显的优势。 3.Thrift支持三种比较典型的编码方式。（通用二进制编码，压缩二进制编码，优化的可选字段压缩编解码） 3.kryo
官方文档中文翻译：http://blog.csdn.net/fanjunjaden/article/details/72823866
1.速度快，序列化后体积小 2.跨语言支持较复杂 4.hessian
1.默认支持跨语言 2.较慢 5.fst
高性能序列化框架FST:http://liuyieyer.iteye.com/blog/2136240
1.fst是完全兼容JDK序列化协议的系列化框架，序列化速度大概是JDK的4-10倍，大小是JDK大小的1/3左右。 6.序列化成json
各个JSON技术的比较详解：http://developer.51cto.com/art/201506/480273.htm
6.1、开源的Jackson
相比json-lib框架，Jackson所依赖的jar包较少，简单易用并且性能也要相对高些。 而且Jackson社区相对比较活跃，更新速度也比较快。 Jackson对于复杂类型的json转换bean会出现问题，一些集合Map，List的转换出现问题。 Jackson对于复杂类型的bean转换Json，转换的json格式不是标准的Json格式 6.2、Google的Gson
Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来， 但自从在2008年五月公开发布第一版后已被许多公司或用户应用。 Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。 而在使用这种对象转换之前需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。 类里面只要有get和set方法，Gson完全可以将复杂类型的json到bean或bean到json的转换，是JSON解析的神器。 Gson在功能上面无可挑剔，但是性能上面比FastJson有所差距。 6.3、阿里巴巴的FastJson
Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。 无依赖，不需要例外额外的jar，能够直接跑在JDK上。 FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。 FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。 综上4种Json技术的比较，在项目选型的时候可以使用Google的Gson和阿里巴巴的FastJson两种并行使用， 如果只是功能要求，没有性能要求，可以使用google的Gson， 如果有性能上面的要求可以使用Gson将bean转换json确保数据的正确，使用FastJson将Json转换Bean。
以上所有框架性能测试数据结果：http://developer.51cto.com/art/201506/480273.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73911d9deb4cdd88e910413616f87c3c/" rel="bookmark">
			《Qt基础教程之Qt学习之路》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Qt开源社区中，有一个很好的Qt教程，叫做《Qt 学习之路》，下面是它的链接和目录。
链接地址：http://www.qter.org/thread-629-1-1.html
评论区说上面这个地址打不开，有可能没人管理了。可以试一下面的：
https://www.devbean.net/2012/08/qt-study-road-2-catelog/
目录 第1篇 序
第2篇 Qt简介
第3篇Hello, world!
第4篇 信号槽
第5篇 自定义信号槽
第6篇 Qt模块简介
第7篇MainWindow 简介
第8篇 添加动作
第9篇 资源文件
第10篇 对象模型
第11篇 布局管理器
第12篇 菜单栏、工具栏和状态栏
第13篇 对话框简介
第14篇 对话框数据传递
第15篇 标准对话框 QMessageBox
第16篇 标准对话框 QMessageBox
第17篇 标准对话框 文件对话框
第18篇 标准对话框 事件
第19篇 标准对话框 事件的接受与忽略
第20篇event()
第21篇 事件过滤器
第22篇 事件总结
第23篇 自定义事件
第24篇 Qt绘制系统简介
第25篇 画刷和画笔
第26篇 反走样
第27篇 渐变
第28篇 坐标系统
第29篇 绘制设备
第30篇Graphics View Framework
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73911d9deb4cdd88e910413616f87c3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cab1d10307a322d4e2297c7906ae35a/" rel="bookmark">
			利用MapReduce对HBase数据进行统计分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、HBase作为一种kv数据库，能够很好的面对高吞吐率的在线数据读写服务，尤其是写操作，但是在非rowkey多条件查询、数据分析、统计等场景下，HBase表现的就不是很好了，这些场景下就比较适合来用MapReduce来计算。
2、应用场景
假设有一张HBase表article,它有一列是数据来源source，现在需要统计不同来源的文章数量(数据行数)，对于这样的简单统计需求，可以利用MapReduce程序来实现。
3、Map程序
TableAnalyzeMap继承HBase的TableMapper基类，把source列看做文本，行数自然是整数，所以key-value输出类型自然是&lt;Text,IntWritable&gt;。
[java] view plain copy public class TableAnalyzeMap extends TableMapper&lt;Text, IntWritable&gt; { @Override protected void map(ImmutableBytesWritable key, Result value, Mapper&lt;ImmutableBytesWritable, Result, Text, IntWritable&gt;.Context context) throws IOException, InterruptedException { try { for (Cell cell : value.listCells()) { String qualifier = new String(CellUtil.cloneQualifier(cell)); String colValue = new String(CellUtil.cloneValue(cell), "UTF-8"); System.out.print(qualifier + "=" + colValue + "\t"); context.write(new Text(colValue), new IntWritable(1)); } } catch (Exception e) { e.printStackTrace(); } } } 4、Reduce程序 TableAnalyzeReduce继承HBase的TableReducer基类，这里需要把最终聚合后的结果写到目标表中，rowkey对应source，行数对应目标表的column:count列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6cab1d10307a322d4e2297c7906ae35a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3a0923da2a9d5f258df96890e933c25/" rel="bookmark">
			将matlab折线图平滑化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考文献：http://blog.csdn.net/steelbasalt/article/details/48756143
有两种方法可以画平滑曲线，第一种是拟合的方法，第二种是用spcrv，其实原理应该都一样就是插值。下面是源程序，大家可以根据需要自行选择，更改拟合的参数。 clc,clear; a = 1:1:6; %横坐标 b = [8.0 9.0 10.0 15.0 35.0 40.0]; %纵坐标 plot(a, b, ‘b’); %自然状态的画图效果 hold on; %第一种，画平滑曲线的方法 c = polyfit(a, b, 2); %进行拟合，c为2次拟合后的系数 d = polyval(c, a, 1); %拟合后，每一个横坐标对应的值即为d plot(a, d, ‘r’); %拟合后的曲线 plot(a, b, ‘‘); %将每个点 用画出来 hold on; %第二种，画平滑曲线的方法 values = spcrv([[a(1) a a(end)];[b(1) b b(end)]],3); plot(values(1,:),values(2,:), ‘g’); 效果如下： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7da545e792d6f9f7f353f778624b3ba7/" rel="bookmark">
			精通Cocos2d-x游戏开发（进阶卷）第5章 分辨率适配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注1：本书作者王永宝，出版时间：2017-03-01。 注2：《Cocos2d-x 2.x、3.x读书摘要》这篇日志过于凌乱，计划按照知识点拆分细化，故转载王永宝这本书的这一章节。 第5章 分辨率适配 5.1 Cocos2d-x适配策略 5.1.1 分辨率适配策略 5.1.2 坐标编码 5.1.3 OpenGL窗口与可视化窗口 5.1.4 setDesignResolutionSize详解 5.2 分辨率适配经验 5.2.1 宽度或高度锁定 5.2.2 计算设计分辨率 5.2.3 场景固定内容 5.2.4 经验小结 5.3 CocoStudio分辨率适配 当在不同的分辨率下运行程序时，就会碰到分辨率适配的问题，如出现黑边、界面的一部分显示在屏幕外，我们希望程序在不同的分辨率下运行都能有良好的表现。在Cocos2d-x中，可以通过选择合适的分辨率适配策略，结合合适的坐标编码，适配各种不同的分辨率。而灵活使用Cocos2d-x的分辨率适配策略，还可以解决各种分辨率适配的难题。本章主要介绍以下内容： * Cocos2d-x适配策略。 * 分辨率适配经验。 * CocoStudio分辨率适配。 5.1 Cocos2d-x适配策略 可以在Cocos2d-x中调用CCEGLView的setDesignResolutionSize方法设置游戏的分辨率策略，以及我们的设计分辨率。 setDesignResolutionSize()方法包含3个参数，分别是设计分辨率的宽和高，以及分辨率的适配策略。下面这行代码设置了960×640的设计分辨率，并使用了SHOW_ALL分辨率适配策略。 Director::getInstance()-&gt;getOpenGLView()-&gt;setDesignResolutionSize(960, 640, ResolutionPolicy::SHOW_ALL); 5.1.1 分辨率适配策略 Cocos2d-x的分辨率适配一般不是为每一种分辨率设计一种布局方案，而是在一种分辨率下进行设计（也就是设计分辨率），然后通过分辨率适配策略，让程序能够适应不同的分辨率。Cocos2d-x提供以下5种分辨率适配策略。 * EXACT_FIT以设置的分辨率为标准，按照该分辨率对x和y进行拉伸。 * NO_BORDER不留黑边，不拉伸，等比缩放，有一个方向（上下或左右）可能超出屏幕。 * SHOW_ALL设置的分辨率区域内全部可见，但上下左右都可能出现黑边。 * FIXED_HEIGHT锁定分辨率的高度，宽度不管，可能出现黑边也可能超出屏幕。 * FIXED_WIDTH锁定分辨率的宽度，高度不管，可能出现黑边也可能超出屏幕。 通过图5-1～图5-3可以直观地了解到在不同分辨率下，各个分辨率适配策略的表现。以960×640为设计分辨率，然后通过调整窗口的实际分辨率，选择不同的适配模式进行观察。在PC上调用Director的setFrameSize()方法可以自定义窗口的尺寸，但不要在移动设备上设置FrameSize。 首先是EXACT_FIT模式，当在不同的分辨率下运行时，界面的宽和高都会根据我们的设计分辨率进行缩放，例如，当设计分辨率是100×200，在200×300的分辨率下运行时，宽会放大2.0，高会放大1.5，当实际分辨率小于设计分辨率时，Cocos2d-x又会相应地缩小界面使其适配，如图5-1所示。 图5-1 EXACT_FIT模式 NO_BORDER模式下会根据实际分辨率进行等比缩放，不留黑边。首先按照EXACT_FIT模式的缩放规则计算出宽和高的缩放值，按照*高的缩放值进行等比缩放。当实际分辨率无法完整放下缩放后的界面时，会有一部分内容显示在屏幕外，如图5-1所示，当界面以NO_BORDER模式进行适配时，红色边框为界面的完整内容，红色边框左下角的红色原点为OpenGL窗口的原点坐标，如图5-2所示。 图5-2 NO_BORDER模式 SHOW_ALL模式下会根据实际分辨率进行等比缩放，完全显示界面的完整内容，与NO_BORDER模式相反，其会先按照EXACT_FIT模式的缩放规则计算出宽和高的缩放值，按照*低的缩放值进行等比缩放。由于是按照*小的分辨率进行缩放，所以左右和上下都有可能出现黑边，图5-3右侧图片中的红点处为OpenGL窗口的原点坐标，如图5-3所示。 FIXED_HEIGHT和FIXED_WIDTH模式比较类似，它们会将高度或宽度锁定，按照高度或宽度进行等比缩放，另外一个方向既可能超出，也有可能留下黑边。这两种模式会先按照EXACT_FIT模式的缩放规则计算出宽和高的缩放值，FIXED_HEIGHT取高度缩放值进行等比缩放，保证设计分辨率的高度刚好铺满设计分辨率，FIXED_WIDTH取宽度进行等比缩放，保证设计分辨率的宽度刚好铺满设计分辨率。 图5-3 SHOW_ALL模式 5.1.2 坐标编码 当我们的程序在不同的分辨率下运行时，setDesignResolutionSize()方法会对整个程序按照适配策略根据设计分辨率和实际分辨率进行缩放。在对坐标进行编码时，需要使用相对坐标编码，而根据窗口尺寸可以进行相对坐标的编码，如希望将一个节点放置在屏幕的正中间，就需要将其坐标的x和y分别设置为窗口尺寸的宽和高的1/2。相对左下角原点的坐标则可以直接使用绝对坐标，设置相对位置可以使得程序在不同的分辨率下运行，我们的对象都能够显示在正确的位置上。 在使用相对坐标编码时，Director单例中有几个方法可以获取尺寸，下面了解一下这几个获取尺寸相关的方法。 * getWinSize，获取OpenGL窗口的单位尺寸。【之前认为getWinSize就代表设计分辨率大小，是不严谨的】 * getWinSizeInPixels，获取OpenGL窗口的实际像素尺寸。 * getVisibleSize，获取可视窗口的尺寸。 * getVisibleOrigin，获取可视窗口左下角坐标的位置。 另外GLView对象还提供了以下两个接口来获取其他的尺寸。 * getFrameSize，获取设备或窗口的尺寸。 * getDesignResolutionSize，获取设置的设计分辨率。 如图5-4直观地演示了上面描述的各种尺寸，WinSize和WinSizeInPixels分别是当前整个OpenGL窗口的单位尺寸和像素尺寸。VisibleSize和VisibleOrigin可以共同构成当前窗口中实际可见部分内容的矩形范围，FrameSize为当前窗口或设备的真实尺寸。 图5-4 WinSize与VisibleSize * WinSize分别为图5-4中左右两图的红色框范围，虽然看上去范围不同，但这是一个单位尺寸，所以值并没有变化，也就是原图尺寸960×640，一般等同于设计分辨率的尺寸，也是OpenGL窗口的单位尺寸。 * WinSizeInPixels也对应图5-4两图中的红色框范围，但这个尺寸为实际占用的像素尺寸，所以在不同分辨率下有不同的值（程序逻辑中使用的坐标是单位尺寸，而非像素尺寸）。 * VisibleSize表示可视内容的尺寸，在图5-4左图中为红色框范围，右图则为黄色框范围，也就是可以看到的有内容的显示区域尺寸。 * VisibleOrigin表示可视内容的左下角坐标，分别是左右图中左下角的红点的位置，左图中OpenGL窗口原点的坐标与红点重叠，而右图中OpenGL窗口的原点为红色框的左下角，VisibleOrigin的Y轴比原点高了64个像素。 * FrameSize为窗口或设备的实际尺寸，也就是图5-4中两个窗口的窗口大小1200×640。 Cocos2d-x推荐使用VisibleSize和VisibleOrigin进行相对位置的计算，就是因为根据它们来计算可以保证我们的对象能够处于可视范围中。 WinSize和(0,0)坐标构成了OpenGL窗口，VisibleSize和VisibleOrigin构成了可视窗口，可视窗口不会大于OpenGL窗口，因为OpenGL窗口以外的内容都是不可见的！但OpenGL窗口范围内的对象并不一定可见，如当屏幕窗口容不下OpenGL窗口时。可视窗口可以理解为OpenGL窗口和设备实际分辨率窗口相交的矩形区域。 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7da545e792d6f9f7f353f778624b3ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef071a6001400738f5cd0425610e9f5f/" rel="bookmark">
			vue全栈商场项目-商品列表页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.vue后缀的有组件，有页面，页面放在views文件夹，组件放在components文件夹；
css文件导入：
组件导入：
实际上此处的&lt;nav-header&gt;可以匹配nav-header,navHeader,NavHeader;
对此有疑惑，请看关于组件的命名；
面包屑组件的slot：
slot什么都不放：
在nav-bread标签里加一个Goods：
slot加name属性：
传送门：官方文档讲解slot
内置express框架对服务端路由的加载（mock数据）：
通过get方法设置前端请求的地址
后端代码（dev-server）：
前端代码：
价格过滤栏：
此时每个价格区间选中时没有选中状态，添加选中状态：
&lt;!-- filter --&gt; &lt;div class="filter" id="filter" v-bind:class="{'filterby-show':filterBy}"&gt; &lt;dl class="filter-price"&gt; &lt;dt&gt;价格区间:&lt;/dt&gt; //判断当前字段是否等于'all',是的话应用样式 &lt;dd&gt;&lt;a href="javascript:void(0)" v-bind:class="{'cur':priceChecked=='all'}"&gt;选择价格&lt;/a&gt;&lt;/dd&gt; &lt;dd v-for="(item,index) in priceFilter"&gt; &lt;a href="javascript:void(0)" @click="priceChecked==index" v-bind:class="{'cur':priceChecked==index}"&gt;￥ {{item.startPrice}} - {{item.endPrice}}&lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; 参考链接：v-bind:class用法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/279e1c6e2d0458c63cdb51863db18ab5/" rel="bookmark">
			C&#43;&#43;多态、虚函数表、动态链接，虚函数指针，RTTI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多态 多态的概念：基类指针指向派生类的地址，通过实现派生类的重写函数实现同一个函数接口不同的功能。多态性在Object Pascal和C++中都是通过虚函数（Virtual Function）实现的，因为通过父类的指针去调用不同的子类指针对父类虚函数的重写方法实现多态，同样的接口函数可以实现不同的功能。
虚函数通过动态绑定实现、动态绑定通过vfptr（虚函数指针）和vftable（虚函数表）来实现的
联编/绑定：程序调用函数，编译器决定调用哪个函数地址。
静态绑定：函数重载和运算符重载，它是在编译过程汇总进行的联编，又称早期联编。静态联编在汇编的底层是通过绑定绝对地址来实现的，call指令后面是具体的函数地址。这个地址是线性地址，也就是说是一个虚拟地址。而在进行函数的地址的访问的时候是需要通过地址映射完成线性地址到物理地址转换的过程。
动态绑定：是在程序运行过程中才动态的确定调用函数的地址，在汇编的底层来看就是call指令后面是一个eax寄存器的值，其具体的地址只有在程序运行的时候才确定eax寄存器上的具体值。在函数调用时，如果被调用的函数是虚函数，那么发生的就是动态绑定。
虚函数：
虚函数就是在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数。
用法格式为： virtual 函数返回类型函数名（参数表） {函数体}；
如果在基类中定义了虚函数，那么派生类中的同名函数将自动变为虚函数，但是我们可以在派生类同名函数前也加上virtual关键字，这样会增加程序的可读性。
注意：
在析构函数中如果基类的析构函数声明了是虚函数，那么派生类的析构函数也是虚函数，虽然他们的名字不同！在有时候必须将基类的析构函数声明为虚函数。
注意：
这里一定要注意什么时候会调用用虚函数，必须是用指针或引用调用虚函数时，因为如果是通过对象调用虚函数，那么编译的时候就知道应该用哪个方法了，这是静态绑定，不是动态绑定。
多态的本质：不是重载声明而是覆盖。 虚函数调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。
那么虚函数指针是在运行的什么时候初始化的？
·拥有虚函数的类会有一个虚表，而且这个虚表存放在类定义模块的只读数据段中。模块的数据段通常存放定义在该模块的全局数据和静态数据，这样我们可以把虚表看作是模块的全局数据或者静态数据
·类的虚表会被这个类的所有对象所共享。类的对象可以有很多，但是他们各自的虚表指针都指向同一个虚表，从这个意义上说，我们可以把虚表简单理解为类的静态数据成员。值得注意的是，虽然虚表是共享的，但是虚表指针并不是，类的每一个对象有一个属于它自己的虚表指针，该指针的优先级比较高，总是在对象的前四个字节。
·虚表中存放的是虚函数的地址。其中在虚表的前四个字节存的是RTTI指针，指向的是RTTI信息，也就是一个运行时类型识别功能就是通过RTTI指针来是实现的。接下来的四个字节是一个偏移量，表示虚函数指针在对象中的偏移量，最后才是虚函数的地址！
类的非静态成员函数调用时，编译器会传入一个"隐藏"的参数。这个参数就是通常我们说的"this"指针，它的值就是对象的地址。在代码中，寄存器 EAX 保存的就是这个。
由此可见，虚表的地址被存放在对象的起始位置，即对象的第一个数据成员也就是我们说的虚表指针。同时我们还可以注意到，虚表指针的初始化确实发生在构造函数的调用过程中，但是在执行构造函数体之前，即进入到构造函数的"{"和"}"之前。为了更好的理解这一问题，我们可以把构造函数的调用过程细分为两个阶段，即：
1. 进入到构造函数体之前。在这个阶段如果存在虚函数的话，虚表指针被初始化。如果存在构造函数的初始化列表的话，初始化列表也会被执行。
2. 进入到构造函数体内。这一阶段是我们通常意义上说的构造函数。
总结：虚函数表在编译的时候就确定了，而类对象的虚函数指针vptr是在运行阶段赋值根据虚函数表加载到内存中的地址进行赋值的。先调用基类构造函数把基类的虚函数表地址赋值到虚函数指针上，但又在自身构造函数或初始化列表之前，再次让虚函数指针指向派生类类型的虚函数表，对继承过来的基类的虚函数表进行函数的覆盖，这是实现多态的关键!
静态(编译时期)绑定和动态(运行时期)绑定问题
对象的内存会改变：vfptr虚函数指针
vfptr =&gt;&gt;&gt;&gt; vftable：指向虚函数表的地址
vftable虚函数表是什么时候产生的？运行时它存放在哪个内存区域？
编译阶段产生的，运行时加载到内存中.data段中的.rodata段只读数据段
vftable里面放的是什么东西？
虚函数的入口地址，最后四个字节是NULL表示虚函数表的结束
构造函数能实现成虚函数吗？ static成员方法呢？友元方法呢？
构造函数不可以实现为虚函数，析构函数可以，静态方法和友元方法都不行。
构造函数和静态成员函数不能是虚函数，还没有构造成对象，因此没有对象地址。
静态函数通过类的作用域就可以调用，不需要生成对象，调用静态函数是静态绑定的过程和虚函数的实现机制是相反的。
析构函数可以是虚函数：有时候必须为虚析构函数。
因为在一个类里声明友元时，由于友元不是自己的成员函数自然在自己的类里不能把它声明为虚函数。
注意：友元是另外一个类的成员函数(在那个类里它可以定义为虚函数)而这个类将它声明为自己的友元,只是让它可以存取自己的私有变量
构造函数为什么不能是虚函数？：
1，从内存空间角度
虚函数对应一个vptr，可是这个vptr其实是存储在对象的内存空间的。
运行时指向只读数据段的vftable。问题出来了，如果构造函数是虚的，就需要通过 vptr来调用，可是对象还没有实例化，也就是内存空间还没有，此时就不知道vptr具体的地址。所以构造函数不能是虚函数，不能通过vptr指针去调用虚的构造函数。 2，从使用角度
虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化对象，那使用虚函数也没有实际意义呀。
虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数
3、从实现上看，vfptr在构造函数调用后才建立，因而构造函数不可能成为虚函数。 从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。
vftable虚函数表的地址是什么时候写到vfptr虚函数指针当中的？
vfptr是在构造函数的栈帧进行初始化的时候：在构造函数初始化列表之后并调用构造函数第一行代码之前,函数栈帧开辟后进行赋值虚表地址赋值给vfptr的，This指针的赋值也是在构造函数的栈帧进行。
析构函数能不能实现为虚函数？什么时候必须实现为虚函数？
可以实现虚函数，并且在基类指针指向堆空间开辟的派生类对象的时候必须将基类的析构函数实现为虚构造函数，因为后面需要程序员自己delete该基类指针。
如果基类的析构函数不是虚函数的话，Delete基类指针时对基类析构函数的调用只是静态绑定，只会调用基类的析构函数，派生类的析构函数无法调用，造成派生类的资源无法释放。
如果基类中析构函数是虚函数的话，派生类的析构函数自动成为虚函数。基类就有一张虚函数表，派生类继承基类的时候会把自己的析构函数覆盖到虚函数表中，delete基类指针的时候就发生动态绑定，调用的就是该派生类析构函数而该派生类析构函数会先释放派生类对象再释放基类对象。这样的话就不会造成派生类的资源没有释放的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/279e1c6e2d0458c63cdb51863db18ab5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c82b8b9b86726a27b2e81cbbb28cf11f/" rel="bookmark">
			微信小程序-实现扫码自动连接wifi(android)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目实路
饭店,商铺存在共享的wifi的地方,只需要贴出二维码,用户扫描后自动连接
小程序 缺点:android6版本 ios11版本
图片演示
实现代码(IOS没看懂文档说明 只简单的带过 希望能实现的朋友@我一下)
// pages/wifi/wifi.js Page({ data: { startError: '',//初始化错误提示 wifiListError: false, //wifi列表错误显示开关 wifiListErrorInfo: '',//wifi列表错误详细 system: '', //版本号 platform: '', //系统 android ssid: 'wifi帐号',//wifi帐号(必填) pass: 'wifi密码',//无线网密码(必填) bssid: '',//设备号 自动获取 endError: ''//连接最后的提示 }, onLoad: function () { var _this = this; //检测手机型号 wx.getSystemInfo({ success: function (res) { var system = ''; if (res.platform == 'android') system = parseInt(res.system.substr(8)); if (res.platform == 'ios') system = parseInt(res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c82b8b9b86726a27b2e81cbbb28cf11f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/feaf0250de9fe0fb967c66aeefe04023/" rel="bookmark">
			java读取pfx格式的证书-并获取公钥私钥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.hgh.javase.security; import java.io.FileInputStream; import java.security.KeyStore; import java.security.PrivateKey; import java.security.PublicKey; import java.security.cert.Certificate; import java.util.Enumeration; public class ReadPFX { public ReadPFX (){ } //转换成十六进制字符串 public static String Byte2String(byte[] b) { String hs=""; String stmp=""; for (int n=0;n&lt;b.length;n++) { stmp=(java.lang.Integer.toHexString(b[n] &amp; 0XFF)); if (stmp.length()==1) hs=hs+"0"+stmp; else hs=hs+stmp; //if (n&lt;b.length-1) hs=hs+":"; } return hs.toUpperCase(); } public static byte[] StringToByte(int number) { int temp = number; byte[] b=new byte[4]; for (int i=b.length-1;i&gt;-1;i--){ b[i] = new Integer(temp&amp;0xff).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/feaf0250de9fe0fb967c66aeefe04023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68cdbffedc4b8d0f93a3b7f8de4ae504/" rel="bookmark">
			如果有一个500G的超大文件，里面都是数值，如何对这些数值排序？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，对于这个这样一个问题，我们肯定不能直接一次性全部将数据加载到内存里面。
解决思路：
1.先将这个文件里面的值拆分成多个文件，每个文件大小差不多512M。
2.在这1000个小文件里面的值进行排序去重
分两种情况：
① 如果里面的数值不是很大，这样拼接1000文件数值，拼接，去重，排序。对于8G的内存计算机应该是可以处理的。
② 文件里面的数值就是坑爹的大。
3.对于②处理也很简单，对于1000小文件，比如就按升序排序，我们不是已经拿到了每个的 排序么。我们把1000个文件里面最小的值（也就是第一个）拿出来，并把他们从这些文件中删除，拿这些最小值去重排序作为第一个文件，
4.重复上面的步骤，这样我们也得到1000个 这样排好序的文件。
举例 如果有个文件（-1,5，2，1,4,3，2,4,5）
第一步：截取，每3个一个文件得到（-1,5，2），（1,4,3），（2,4,5）
第二步：去重排序（-1，2，5），（1，3,4），（2,4，5）
第三步：拿第一个去重排序得到新的3个小文件（-1,1,2），（2,3,4），（4,5）
看到了吧！按从小到大的顺序就出来了，我们最后都知道（-1,5，2，1,4,3，2,4,5）文件从小到大的顺序是-1,1,2，3,4,5。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/265ba6fda6d0d44053d53c1a5c9c7e63/" rel="bookmark">
			Hbase原理理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：本博客乃是自己对于Hbase的一部分理解，所参考的资料，会列在本文的末尾处。
先来上一张随处可见的图：
Hbase即分布式的数据库，其底层基于HDFS，提供了随机访问的存储和检索数据的功能。
对于HDFS来说，实现随机访问的代价太高了，因为hdfs使用的更好情况是，基于文件的顺序读写；但是，其本身的实时性能也并不是很高。
HBase的文件存储是基于HDFS，其底层的运算采用的是MapReduce，这里，其实可以用spark的高性能来提高效率，其实，对于如今的hadoop来说，最优异的，或者说最有价值的还是HDFS，其中的运算框架，完全可以用性能更加优良的运算框架来实现，比如说spark以及flink等。
闲话少说，还是继续讲HBase。
综述：使用zookeeper来对集群进行管理，使用HDFS来作为底层存储，而基本架构则是通过由zookeeper选择出来的HMaster来实现对集群的管理，多个HRegionServer负责对数据的管理。（架构核心：HMaster和HRegionServer）。
HRegionServer对应于集群中的一个节点，类似于HDFS中的datanode，其管理多个HRegion，而一个HRegion代表一张表中的部分数据；而数据划分的依据则是根据rowkey来划分一定的范围，归于哪个HRegion。（重点：HRegion，RowKey）。
单说一下HMaster：其并不存储任何数据，而只是存储数据到HRegionServer的映射关系，通俗来说就是元数据（想起来Hive中也提供了元数据的概念，好像很多地方都用到了这个东西）。
再来一张图，大家可以看到这张图是从别人那边粘来的，这张图很详细的介绍了HBase的基础架构，接下来的讲述都是针对于本图的。
我觉得，对于这张图，大家一定要注意其中的彼此的数量关系，图中就画的很清楚。
1：HLog：在数据写入的过程中，为了避免突然的内存崩溃等问题，导致数据丢失，会依靠这种WriteAheadLog机制，在数据写入这内存的时候，同时会写入日志中，如果崩溃了的话，还是能够恢复的。
这里，几个问题说下：
HLog肯定会越写越大，这样的话，一定会有把磁盘撑爆的那一天的，而实际上，在不断写入的过程中，HBase会通过HLog过期的方式，譬如说，当memstore已经刷新到磁盘中后，这一部分的写入日志就可以清除掉了，而这时候也存在个问题，如果HLog的内容丢失，会不会对于后期的数据恢复有影响？个人觉得，这里不仅是写入磁盘了，更重要的是写入到了HDFS系统中，所以，恢复的时候，可能不仅仅是通过HLog，同时还有HDFS存下来的数据，比如HFile作为保障吧！ 注：这里面有一个我当时天资愚钝，很长时间没想通的问题，大家能够看到是一个HRegionServer对应一份HLog，也就是说，如果本台机器崩溃之后，其他机器怎么可能读取到本机的HLog呢？其实，这个HLog是存储在HDFS系统内的，图中的箭头表明了这个方向。
2：HRegion：HBase的表示基于列，或者说是基于列族的，但实际上，数据也是一行一行的，每一行都有绝对唯一的rowkey，当随着存储数据的不断增加，最初写入的HRegion会不断变大，达到一定的大小，就会拆分为两个HRegion，换句话说，这就是HBase的默认分表，到底多大会划分，可以自行配置
3：Store：这是HBase整个存储的核心，大家可以看到其中有一个MemStore，这个就是内存存储，写入的时候都会写入到这里，随着占用内存越来越大，会刷到磁盘中（很多地方都是这么用的，譬如说MapReduce中的spill阶段，也是把数据先写入内存，然后达到百分之八十的占用后，会spill到磁盘之中），这里，我觉得应该也是有控制的，为了提高性能，肯定是内存写入到一定程度，就开始向磁盘中存储，这时候，就会生成StoreFile，而同样，storeFile的数据会越来越多，这时候，就会进行compact操作，多个storeFile生成一个文件（其实这里有一个疑问，compact的过程中，有没有排序？数据写入内存的时候，有没有排序呢？），而按照上图，实际上在磁盘上生成的文件叫做HFile，这才是数据写入的最小单元；这里还有一点东西，列族，实际上，对于每一个Store，就是一个列族，有多少个Store，就有多少个列族。
注：memStore的数据刷盘，有笔记说，刷盘的时间内，该region的数据是拒绝访问的，此部分暂时未能理解（参考资料2）
查阅了大神的笔记（末尾参考笔记2），提到这一点：写入到memstore中的数据都是预先按照rowkey的值进行排序的，这样有利于后续数据查查；所以，肯定是有排序的。
HBase读数据和写入数据的流程：
写入数据：写过Java相关代码，其实client是通过访问zk来先行获取HMaster的地址，然后向机器请求元数据，然后才获取到具体的表地址的；然后，client会直接向该机器发出请求，请求数据写入的；而且，会有缓存，这样方便第二次读取了。读出数据：大致相同，先根据zookeeper去获取一个连接，然后进行数据的读取。 2：使用场景：
想要了解一个东西，必须要知道其使用场景，不然等于白学，原理要掌握，代码要会写，问题要能够解决，知道在哪儿用，怎么用，才算真正掌握了。
场景1：我们比较一下HBase和关系型数据库，先不说大小，因为mysql也可以做成集群了；但是mysql比较苦逼的一点是，不支持表结构的更改，但是hbase因为有列族这个概念，其下堪称是可以无限添加列，完美解决了这个问题。
场景2：记录非常稀疏的情况，这里，因为RDBMS的行有多少列全都是固定的，无论有无数据都会占据存储空间，而对于HBase对于那些空的列，并不会被存储，这的确也是个好处。
场景3：多版本的数据，这个的确很妙，因为hbase只支持数据的不断添加，而实际上，前面的并不会删除，大家可以想象，如果去删除前面的数据，这部分的性能消耗会是多高，相当于随机处理了；所以，其做到的就是，让你每次查询数据的时候，只会查询到最新插入的数据，这就相当于是变相的删除了，而同时，你还可以完美查询多个版本的数据，一举两得。
场景4：HBase的横向无缝扩展，其实这个东西，我觉得对于分布式来说，没有这个优点，那还叫分布式吗？
表的设计问题：
3：HBase设计
毫无疑问，表需要设计，尤其是其中的rowkey，作为绝对唯一的值，更需要谨慎涉及，其实可以采用MD5的串，或者时间戳，或者UUID的串，这些值基本，或者绝对不会重复的。
4：HBase的各种操作方式：
如果真想把HBase用起来，这部分非常重要。
暂时手里没有代码，先把用法贴在这里：
可以用MapReduce来操作HBase，实现数据的读出和写入可以用Spark来操作HBase，实现数据的读出和写入 个人见解：其实HBase最核心的理论基础应该还是在谷歌的那一篇论文里，具体叫什么忘记了，但是基于其开发出很多的类似HBase的东东，大家都可以看一下，最好是了解其中的核心原理，才是最重要的。
参考资料：
http://blog.csdn.net/carl810224/article/details/51970039/：本文写的很好，但是并没有讲到底层的与HDFS牵涉到的细节，也没有但具体讲解HFile，但总体来说很不错。
http://blog.csdn.net/xgjianstart/article/details/53290155：这篇文章非常好，讲的东西比较深刻。
https://www.cnblogs.com/qiaoyihang/p/6246424.html：这篇是我学习HBase的启蒙文章，介绍的非常详尽；强烈建议本文。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b9fae38d37926807d8ccd0ef9e03cc9/" rel="bookmark">
			C&#43;&#43;中bitset用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：http://www.cnblogs.com/RabbitHu/p/bitset.html
以下内容翻译自cplusplus.com。
bitset存储二进制数位。
bitset就像一个bool类型的数组一样，但是有空间优化——bitset中的一个元素一般只占1 bit，相当于一个char元素所占空间的八分之一。
bitset中的每个元素都能单独被访问，例如对于一个叫做foo的bitset，表达式foo[3]访问了它的第4个元素，就像数组一样。
bitset有一个特性：整数类型和布尔数组都能转化成bitset。
bitset的大小在编译时就需要确定。如果你想要不确定长度的bitset，请使用（奇葩的）vector&lt;bool&gt;。
定义一个bitset // constructing bitsets #include &lt;iostream&gt; // std::cout #include &lt;string&gt; // std::string #include &lt;bitset&gt; // std::bitset int main () { std::bitset&lt;16&gt; foo; std::bitset&lt;16&gt; bar (0xfa2); std::bitset&lt;16&gt; baz (std::string("0101111001")); std::cout &lt;&lt; "foo: " &lt;&lt; foo &lt;&lt; '\n'; std::cout &lt;&lt; "bar: " &lt;&lt; bar &lt;&lt; '\n'; std::cout &lt;&lt; "baz: " &lt;&lt; baz &lt;&lt; '\n'; return 0; } 输出结果：
foo: 0000000000000000 bar: 0000111110100010 baz: 0000000101111001 bitset的运算 bitset的运算就像一个普通的整数一样，可以进行与(&amp;)、或(|)、异或(^)、左移(&lt;&lt;)、右移(&gt;&gt;)等操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b9fae38d37926807d8ccd0ef9e03cc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae75f67ca79dcc865c028388af365061/" rel="bookmark">
			使用web3和infura开发以太坊ethereum区块链
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		web3 Github： https://github.com/ethereum/web3.js/ web3.js是以太坊提供的一个Javascript库，它封装了以太坊的RPC通信API，提供了一系列与区块链交互方法，使js与以太坊交互变得简单。
infura 官网： https://infura.io/ 本地安装geth的方法需要花比较多的时间和空间来同步区块，利用infura可以简单很多，infura提供公开以太坊和测试节点，可以利用infura提供的api访问以太坊以及IPFS。去官网只需要提供email注册得到链接即可。
使用web3和infura开发 最常用的操作例如查看一个以太坊地址的ether余额为例（类似etherscan）.
通过npm或其他方式引入web3, 并使用infura提供主网/测试网进行初始化。
// xxxx为你在infura申请的地址 web3 = new Web3(new Web3.providers.HttpProvider("https://mainnet.infura.io/xxxxxxxx")); 接下来就可以调用web3的接口了,例如获取一个地址的ether数量
// wei是以太坊上的的最小单位，ether小数点后18位为一个wei var balanceWei = web3.eth.getBalance("0xC257274276a4E539741Ca11b590B9447B26A8051").toNumber(); // 从wei转换成ether var balance = web3.fromWei(balanceWei, 'ether'); 至此便可以从以太坊主网上进行操作了，例如查看区块信息，部署智能合约等。 具体开发可以参考以太坊JS API： https://github.com/ethereum/wiki/wiki/JavaScript-API demo 简单的etherscan Demo Github: https://github.com/wlchn/ethersee
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513788b49e351aa479968b0f57efa8b2/" rel="bookmark">
			POP3接收邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#SMTP用于发送邮件，如果要收取邮件呢？ #收取邮件就是编写一个MUA作为客户端，从MDA获取邮件到用户的电脑或手机上。收取邮件最常用的协议是POP，目前版本是3，俗称POP3. #Python内置了一个poplib模块，用于实现POP3协议，可以直接用来收取邮件。 #注意POP3协议收取的不是可以阅读的邮件，而是邮件的原始文本。这和SMTP协议很像，SMTP发送的也是经过编码后的一大段文本。 #要把POP3收取的文本变成可以阅读的邮件，还需要用email模块提供的各种类解析原始文本。 #收取邮件分为以下两个步骤 1）、用poplib把邮件的原始文本下载到本地。 2）、用email解析原始文本，还原为邮件对象。 1、POP下载邮件 #pop3协议很简单。下面获取最新一封邮件的内容，代码如下： 1 #! /usr/bin/python3 2 #-*-coding:UTF-8-*- 3 #Email_pop3 4 5 import poplib 6 from email.parser import Parser 7 8 #输入邮箱地址、密码和POP服务器地址 9 email=input('Email:') 10 password=input('Password:') 11 pop3_server=input('POP3 server:') 12 13 #连接到POP3服务器 14 server=poplib.POP3(pop3_server) 15 16 #可以打开或关闭调试信息 17 server.set_debuglevel(1) 18 19 #可选：输出pop3服务器的欢迎文字 20 print(server.getwelcome().decode('utf-8')) 21 22 #身份认证 23 server.user(email) 24 server.pass_(password) 25 26 #stat()返回邮件数量和占用空间 27 print('Message:%s.Size:%s'%server.stat()) 28 29 #list()返回所有邮件的编号 30 resp,mails,octets=server.list() 31 32 #可以查看返回的列表，类似[b'1 82923',b'2 2184',.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/513788b49e351aa479968b0f57efa8b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b99f0aa42c317fccaf1d4e13ef983cf/" rel="bookmark">
			【附源码】小程序初窥之简单查单词
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新年假期百无聊赖，于是就看了一下微信小程序的开发方法，花了两天时间入了个门，这里记录一下。
阅读之前，先确定你知道基本的 html+css+js 语法，这样就能更好地和我一样，以一个新手的视角来理解小程序。
目标 目标是编写一个查单词的小程序，很明显需要一个输入框（如果有一个placehoder就更好了），然后再加上一个按钮，点击之后如果成功就显示结果，如果失败就提示失败。查词api使用扇贝api。
所以最后为了简单起见，界面的最终形态就是这样：
文件结构 小程序里的最主要的文件有四种： .js .json .wxml .wxss
简单理解就是：
.js 用于控制页面逻辑。.json 用于页面配置，不必须，也可以全局配置，但是页面配置权重高于全局配置。.wxml 类似于 .html ,用于设置页面内容.wxss 类似于 .css ，用于设置页面样式，不必须，代码也可以直接写在 .wxml 内 由此，这个迷你项目的项目结构就如下图所示：
唯一的页面是 index ， app.js app.json project.config.json 应用于全局。
开始编码 基本设置 首先，我们要告诉小程序有哪些页面。 其次，需要设置小程序的导航栏标题，因为只有一页，所以只需要设置这一页的内容就可以了，所以统一写在 app.json 里，当然，你也可以新建一个 index.json 。
// app.json { "pages": [ "src/pages/index/index" ], "window": { "navigationBarBackgroundColor": "#ffffff", "navigationBarTextStyle": "black", "navigationBarTitleText": "简单查单词", "backgroundColor": "#eeeeee", "backgroundTextStyle": "light", "enablePullDownRefresh": false } } 页面内容 首先我们需要一个输入框，从微信文档可以看到，我们需要一个 input 控件。通过 placeholder 属性添加占位符，然后通过 bindinput 与输入事件绑定，每当有输入事件的时候，就调用 wordInput 函数。这里的 focus 与 confirm-type 含义你可以查看文档来了解。第二步我们需要一个按钮，点击调用处理函数。所以这里我们用 bindtap 绑定一个 btnClick 函数。最后我们需要显示翻译和例句，使用 {{}} 来绑定变量，此处的控件为 text ，它的具体的使用可以看这里 由此，我们得到了如下代码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b99f0aa42c317fccaf1d4e13ef983cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f63c272d273b447e41108c67e93b651b/" rel="bookmark">
			Windows错误恢复无限重启；开机后灯亮风扇转下停下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说第一个问题：Windows错误恢复无限重启
开机后到了这个界面“windows错误恢复”，选择修复不能通过，提示找到一个根本错误“可能修改了硬件设置”；选择正常启动则闪一下还是到了windows错误恢复这个界面。尝试如下方法：
1.开机马上按F8进入安全模式，选“最近一次的正确配置”回车修复，还不行按F8进入安全模式还原一下系统或重装系统（如果重装也是这样，建议还是检修一下去，如果可以进入安全模式，说明你安装了不合适的东西，将出事前下载的不合适东西全部卸载，或还原系统或重装，如果您的电脑是Win8，进不了系统是进不了安全模式的，只有重装了）。
2.如果进入不了安全模式，那么应该不是软件的问题，可能是硬件问题或者硬件配置问题：开机按DEL或者F2进入Bios设置，设置Sata Mode有IDE改为AHCI，重启； 还不行就加载Bios默认设置试一下。
再说第二个问题：开机后灯亮风扇转下停下
出现这种情况很可能是内存条问题，如果有多个内存条则拔下只留一个试试看能否启动，如果只有一个拔下后用橡皮擦或者尼龙布擦拭内存条的金牙，然后插上去重启试试看。
春节放了十天假，初七早上来了一开机风扇转一下停一下，拔了2根内存条后能开机了，我想试一下哪个内存条问题，把这2根和右侧的两根对换，能开机但遇到了Windows错误恢复无限重启的问题，折腾了一上午也没搞好，还差进了光盘差一点重装系统（我的C盘装了许多软件的），后来了个技术人员把SataMode改为Ahci,重启好使了，说的是系统安装时选择的什么模式以后启动都要是该模式，可能是放假期间主板没电了恢复到默认设置的IDE模式了。奇怪的是我拔下纽扣电池后再拔下左侧两根内存条为啥能正常开机，对换后却不能正常开机了。不过最终还是搞好了，开始忙碌工作吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9196bdb71099cfb97278215ee8d25420/" rel="bookmark">
			【Python】正则表达式 re.findall 用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正则 re.findall 的简单用法（返回string中所有与pattern相匹配的全部字串，返回形式为数组） 语法： 1 findall(pattern, string, flags = 0 ) import re Python 正则表达式 re findall 方法能够以列表的形式返回能匹配的子串 # print (help(re.findall)) # print (dir(re.findall)) findall查找全部r标识代表后面是正则的语句 1 2 3 regular_v1 = re.findall(r "docs" , "https://docs.python.org/3/whatsnew/3.6.html" ) print (regular_v1) # ['docs'] 符号^表示匹配以https开头的的字符串返回, 1 2 3 regular_v2 = re.findall(r "^https" , "https://docs.python.org/3/whatsnew/3.6.html" ) print (regular_v2) # ['https'] 用$符号表示以html结尾的字符串返回,判断是否字符串结束的字符串 1 2 3 regular_v3 = re.findall(r "html$" , "https://docs.python.org/3/whatsnew/3.6.html" ) print (regular_v3) # ['html'] # [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9196bdb71099cfb97278215ee8d25420/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4f76ad4fcd0e14cd14f8afbcc95fa6e/" rel="bookmark">
			发送邮件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#SMTP是发送邮件的协议，Python内置对SMTP支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。本节腾讯企业邮箱的服务为例进行介绍。学习本节内容时，可以自己开通对应的邮箱服务，各个邮件服务公司有介绍邮箱服务的开通方法，参照这些开通方法开通即可。如果安装了邮箱服务，就可以使用自己的邮箱服务器进行学习。 1、SMTP发送邮件 #Python对SMTP的支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件。 #简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）是从源地址到目的地址传送邮件的规则，由该协议控制信件的中转方式。 #Python的smtplib提供了一种很方便的途径发送电子邮件，对SMTP协议进行了简单的封装。 #Python创建SMTP对象的语法如下： 1 smtpObj=smtplib.SMTP([host[,port[,local_hostname]]]) #语法中各个参数说明如下： #host：SMTP服务器主机。可以指定主机的IP地址或域名（如www.baidu.com）,是可选参数。 #port：如果提供了host参数，就需要指定SMTP服务使用的端口号。一般情况下SMTP的端口号为25. #local_hostname：如果SMTP在本机主机上，只需要指定服务器地址为localhost即可。 #如果创建SMTP对象时提供了host和port两个参数，在初始化时会自动调用connect方法连接服务器。 #PythonSMTP对象使用sendmail方法发送邮件的语法如下： 1 SMTP.sendmail(from_addr,to_addrs,msg[,mail_options,rcpt_options]) #语法中各个参数说明如下： #from_addr:邮件发送者的地址。 #to_adds：字符串列表，邮件发送地址。 #msg：发送消息。 #msg是字符串，表示邮件内容。我们知道邮件一般由标题、发信人、收件人、邮件内容、附件等构成，发送邮件时，要注意msg的格式。这个格式就是SMTP协议中定义的格式。 #SMTP类中提供了下表所示的一下常用方法。 方法 描述 set_debuglevel(level) 设置是否为调试模式。默认为False，即非调试模式， 表示不输出任何调试信息 connect([host[,port]]) 连接到指定的SMTP服务器。参数分别表示SMTP主机和端口 docmd(cmd,[,argstring]) 向SMTP服务器发送指令。可选参数argstring表示指令的参数 helo([hostname]) 向服务器确认身份。相当于告诉SMTP服务器“我是谁” has_extn(name) 判断指定名称在服务器邮件列表中是否存在， 出于安全考虑。SMTP服务器往往屏蔽该指令 verify(address) 判断指定邮件地址是否在服务器中存在。 出于安全考虑，SMTP服务器往往屏蔽该指令 login(use,password) 登陆SMTP服务器。现在几乎所有SMTP服务器都必须验证 用户信息合法后才允许发送邮件 quit() 断开与SMTP服务器的连接，相当于发送quit指令 #普通文本邮件发送的实现关键要将MIMEText中的_subtype设置为plain。首先导入smtplib和mimetext。创建smtplib.smtp实例，连接邮件SMTP服务器，登陆后发送，具体代码如下： 1 #! /usr/bin/python3 2 #-*-coding:UTF-8-*- 3 #Email 4 5 import smtplib 6 from email.mime.text import MIMEText 7 from email.header import Header 8 sender='from@qq.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4f76ad4fcd0e14cd14f8afbcc95fa6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d85494ef1049eb7ab514ec93e0b6aa06/" rel="bookmark">
			手链样式--蓝桥杯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小明有3颗红珊瑚，4颗白珊瑚，5颗黄玛瑙。 他想用它们串成一圈作为手链，送给女朋友。 现在小明想知道：如果考虑手链可以随意转动或翻转，一共可以有多少不同的组合样式呢？ 分析：这个题首先一定要理解题意，转动和翻转是个什么意思，转动就是我们所得到的的排列是个环，即起点不固定，具体点说即使1234和2341是一种方式（3421也一样）。翻转就是，这个排列是个立体的，可以上下左右翻转， 具体点说即 1 1
2 3 和 3 2 是一样的（左右翻转），弄清了题意，就能事半功倍。 4 4 方法一：利用数学的排列组合进行求解，首先我们科普一个小的知识，见图： 意思很明白了，这个题，我们就是先C（12，3）选出红珊瑚的位置，在 C（9，5）选出黄马瑙的位置，这就是总的情况了，由于是环排列，我们将结果除以12，得到不考虑翻转的情况，然后再考虑翻转的时候要考虑到对称的情形，这种翻转是没有影响的， 对称即 A A A B B B B C C C C C 这种类型，这种情形的一共有C(5,2)*C(3,2) = 30种（只看一侧的），那么结果即：（2310-30）/2+30 = 1170；（立体排列除以2） 方法二：暴力枚举，我们直接把每一次得到的串先复制拼接一下（模拟旋转）成环，再翻转一下，如果两次得到的串在已得的串里面没有就加入，直接看代码吧，挺清楚的，鉴于c++里面有直接全排列去重的方法，那么我借鉴了，Java没有啊，直接写很麻烦。。。。 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;string&gt; v; //存储已经找出的情况 int sum = 0; int main(){ string str = "aaabbbbccccc"; do{ vector&lt;string&gt;::iterator it; for(it=v.begin(); it != v.end(); it++){ if((*it).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d85494ef1049eb7ab514ec93e0b6aa06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f221b6c5842ae20e97543a73e0f772b/" rel="bookmark">
			windows 7 UEFI 启动模式安装,解决win7 64 setup会提示GPT分区不支持的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows 操作系统的启动方式，有两种: 模式1: BIOS 配为常规+MBR分区模式 模式2: BIOS 配为UEFI使能 + GPT分区模式
名词说明: BIOS
是英文"Basic Input Output System"的缩略词，直译过来后中文名称就是"基本输入输出系统"。在IBM PC兼容系统上，是一种业界标准的固件接口。
UEFI:
可扩展固件接口(英文名Extensible Firmware Interface 或EFI)是由英特尔，一个主导个人电脑技术研发的公司推出的一种在未来的类PC的电脑系统中替代BIOS的升级方案。
MBR:
主引导记录, 旧的磁盘分区方案，MBR最多支持2^32个扇区，如果每个扇区为512byte,硬盘最多支持2T,最多支持4个主分区.
GPT:
分区模式:是当前的新方案（理论上无限制，如果每个扇区为512byte,windows硬盘最多支持18E, 1EB=1024 PB，PB=1024 TB) ，win7 32位不支持，win7 64位，Win8以上才支持。
安装步骤:
1.硬盘采用GPT方式分区。第一区,ESP分区，分为200M, fat16格式;第2区,MSR分区，分为100M, MSR格式;第3分区用ntfs,用于安装win7 64位 （分区软件建议选diskgenius 64版，可以在360软件管家直接下载）
2.用ghost 或小白安装软件（http://www.xiaobaixitong.com/），装win7 64位到第3分区，注:直接用原版的win7 64 setup会提示GPT分区不支持。
3.用uefi启动修正软件，或小白安装软件（http://www.xiaobaixitong.com/），进行指定ESP分区的位置。并进行修正。
4.重启后，就可以按正常方式安装。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6d21aef5d7345678d92fa9427e36a0e/" rel="bookmark">
			SqlHelper的发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：说实话，在这个我真的没有怎么懂得这个是如何做的，在我一头雾水的时候我 还是 尝试去敲打，去理解其中的含义，于是经过一段时间的研究发现，我只是发现了其中的作用，就好像是一种增删改查中的调用数据库中的那一块，主要的重用在于对UI层中需要用到的数据进行一个数据调用的过程，用了之后然后将数据进行保存。 正文：那么问题就来了，什么是SQLHelper呢？ 答：SqlHelper是一个基于.NET Framework的数据库操作组件。组件中包含数据库操作方法。SqlHelper用于简化你重复的去那些数据库连接（SqlConnection）,SqlCommand,SqlDataReader等等。 好处：sqlHelper 封装过后通常是只需要给方法传入一些参数如数据库连接字符串，SQL参数等，就可以访问数据库了，很方便。 问：如何实现sqlHelper? 答：先看代码： public class sqlHelper { public DataTable ExecuteNonQuery(string cmdTxt, CommandType cmdType, SqlParameter[] paras) { string StrDB = System.Configuration.ConfigurationSettings.AppSettings["ConnStr"];//接收来自配置文件的数据 SqlConnection conn = new SqlConnection(StrDB); //创建数据库的链接 SqlCommand cmd = default(SqlCommand); //定义命名变量 DataSet adataset = null; //定义数据适配器，dataset类表示一个存放于内存中数据缓存 SqlDataAdapter adaptor = default(SqlDataAdapter); //sqlDataAdapter类目的是填充Dataset cmd = new SqlCommand(cmdTxt, conn); //在conn上面执行实例化命名变量，并执行语句cmdtype cmd.CommandType = cmdType; //命令执行的类型 cmd.Parameters.AddRange(paras); //命令执行的参数 adaptor = new SqlDataAdapter(cmd); //初始化SQLDataAdapter类的新实例，用指定的cmd作为SelectCommand的属性 adataset = new DataSet(); try { if (conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6d21aef5d7345678d92fa9427e36a0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a182a4115d1ac908f98a16cac65ea5b/" rel="bookmark">
			BaseRecyclerViewAdapterHelper的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		﻿﻿ BaseRecyclerViewAdapterHelper是一个强大且灵活的RecyclerViewAdapter,那么它都能做什么呢? 可以大量减少Adapter中的代码(对于多类型数据,不再需要写ViewHolder,只需要写多个bean类即可);可以定义一个多类型的 MultiesAdapter替代多个adapter使用;可以很轻松的添加RecyclerView加载动画;添加头部、添加尾部;支持下拉刷新、上拉加载更多(作为条目填充);支持分组(Section,可以看成是多类型条目的一种,有两种类型);支持自定义item类型;支持setEmptyView;可以添加item点击事件;支持子布局多个控件的点击事件;
好的,接下来我们直接来谈其配置和使用: 在 build.gradle 的 repositories 添加:
allprojects { repositories { maven { url "https://jitpack.io" } } } 然后增加dependencies
dependencies { compile 'com.github.CymChad:BaseRecyclerViewAdapterHelper:v1.9.7' } 这里需要说明一下,依赖的BaseRecyclerViewAdapterHelper不同,会导致方法使用上是有差别的,下边提供其他依赖: 'compile
'com.github.CymChad:BaseRecyclerViewAdapterHelper:v1.5.8'
'compile 'com.github.CymChad:BaseRecyclerViewAdapterHelper:v1.5'
1，单类型BaseQuickAdapter使用 [java] view plain copy print ? public class MyQuickAdapter extends BaseQuickAdapter&lt;MultyItemBean&gt; implements View.OnClickListener,View.OnLongClickListener{ public MyQuickAdapter(int layoutResId, List&lt;MultyItemBean&gt; data) { super(layoutResId, data); } public MyQuickAdapter(List&lt;MultyItemBean&gt; data) { super(data); } public MyQuickAdapter(View contentView, List&lt;MultyItemBean&gt; data) { super(contentView, data); } @Override protected void convert(BaseViewHolder baseViewHolder, MultyItemBean multyItemBean) { baseViewHolder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a182a4115d1ac908f98a16cac65ea5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3730f0fdad4a05bb04e41ec6a317fecc/" rel="bookmark">
			移动端vw布局详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关于移动端的适配布局一直以来都是众说纷纭，对应的解决方案也是有很多种。在《使用Flexible实现手淘H5页面的终端适配》提出了Flexible的布局方案，随着viewport单位越来越受到众多浏览器的支持，因此在《再聊移动端页面的适配》一文中提出了vw来做移动端的适配问题。到目前为止不管是哪一种方案，都还存在一定的缺陷。言外之意，还没有哪一个方案是完美的。
事实上真的不完美？其实不然。最近为了新项目中能更完美的使用vw来做移动端的适配。探讨出一种能解决不兼容viewport单位的方案。今天整理一下，与大家一起分享。如果方案中存在一定的缺陷，欢迎大家一起拍正。
准备工作 对于Flexible或者说vw的布局，其原理不在这篇文章进行阐述。如果你想追踪其中的原委，强烈建议你阅读早前整理的文章《使用Flexible实现手淘H5页面的终端适配》和《再聊移动端页面的适配》。
说句题外话，由于Flexible的出现，也造成很多同学对rem的误解。正如当年大家对div的误解一样。也因此，大家都觉得rem是万能的，他能直接解决移动端的适配问题。事实并不是如此，至于为什么，我想大家应该去阅读flexible.js源码，我相信你会明白其中的原委。
回到我们今天要聊的主题，怎么实现vw的兼容问题。为了解决这个兼容问题，我将借助Vue官网提供的构建工程以及一些PostCSS插件来完成。在继续后面的内容之前，需要准备一些东西：
NodeJsNPMWebpackVue-clipostcss-importpostcss-urlpostcss-aspect-ratio-minipostcss-cssnextautoprefixerpostcss-px-to-viewportpostcss-write-svgcssnanopostcss-viewport-unitsViewport Units Buggyfill 对于这些起什么作用，先不阐述，后续我们会聊到上述的一些东西。
使用Vue-cli来构建项目 对于NodeJs、NPM和Webpack相关介绍，大家可以查阅其对应的官网。这里默认你的系统环境已经安装好Nodejs、NPM和Webpack。我的系统目前使用的Node版本是v9.4.0；NPM的版本是v5.6.0。事实上，这些都并不重要。
使用Vue-cli构建项目 为了不花太多的时间去深入的了解Webpack（Webpack对我而言，太蛋疼了），所以我直接使用Vue-cli来构建自己的项目，因为我一般使用Vue来做项目。如果你想深入的了解Webpack，建议你阅读下面的文章：
Webpack文档Awesome WebpackWebpack 教程资源收集Vue+Webpack开发可复用的单页面富应用教程 接下来的内容，直接使用Vue官方提供的Vue-cli的构建工具来构建Vue项目。首先需要安装Vue-cli：
$ npm install -g vue-cli 全局先安装Vue-cli，假设你安装好了Vue-cli。这样就可以使用它来构建项目：
vue init webpack vw-layout 根据命令提示做相应的操作：
进入到刚创建的vw-layout:
cd vw-layout 然后执行:
npm run dev 在浏览器执行http://localhost:8080，就可以看以默认的页面效果：
以前的版本需要先执行npm i安装项目需要的依赖关系。现在新版本的可以免了。
这时，可以看到的项目结构如下：
安装PostCSS插件 通过Vue-cli构建的项目，在项目的根目录下有一个.postcssrc.js，默认情况下已经有了：
module.exports = { "plugins": { "postcss-import": {}, "postcss-url": {}, "autoprefixer": {} } } 对应我们开头列的的PostCSS插件清单，现在已经具备了：
postcss-importpostcss-urlautoprefixer 简单的说一下这几个插件。
postcss-import postcss-import相关配置可以点击这里。目前使用的是默认配置。只在.postcssrc.js文件中引入了该插件。
postcss-import主要功有是解决@import引入路径问题。使用这个插件，可以让你很轻易的使用本地文件、node_modules或者web_modules的文件。这个插件配合postcss-url让你引入文件变得更轻松。
postcss-url postcss-url相关配置可以点击这里。该插件主要用来处理文件，比如图片文件、字体文件等引用路径的处理。
在Vue项目中，vue-loader已具有类似的功能，只需要配置中将vue-loader配置进去。
autoprefixer autoprefixer插件是用来自动处理浏览器前缀的一个插件。如果你配置了postcss-cssnext，其中就已具备了autoprefixer的功能。在配置的时候，未显示的配置相关参数的话，表示使用的是Browserslist指定的列表参数，你也可以像这样来指定last 2 versions 或者 &gt; 5%。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3730f0fdad4a05bb04e41ec6a317fecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c610ade246653b75e1b903084406530e/" rel="bookmark">
			GPIO子系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://blog.rongpmcu.com/gpiozi-xi-tong-he-pinctrlzi-xi-tong/#
GPIO算是一种设备，有设备那我们就要对这个设备进行一个抽象，同时为了各种各样的GPIO设备会去抽象出一个gpio的核心层gpiolib.c，用于管理各种各种各样的gpio， （话外：感觉内核对于设备的管理最精髓的就是核心层总线和driver，device分开，device，driver只需要向核心层去注册就好，核心层会去管理他们） 内核抽象的设备结构体就是：gpio_chip gpio driver的工作就是去初始化实现这个结构体，然后注册这个结构体，此时gpio就可以工作了。 从层次来分，内核的gpio接口有两层，一层是提供给bsp用于实现gpio功能的，一层是提供给其他驱动去在内核态使用gpio的 如何使用gpio： 1.内核态：
使用gpio lib中提供的gpio子系统接口 gpio_request(30, "j15"); 申请该gpio gpio_direction_input(30);置方向输入 gpio_get_value(20);输入模式下获取电平状态 gpio_direction_output(30);方向输出 gpio_set_value(20,0);输出模式下置高 gpio_set_value(20,1);输出模式下置低 gpio_free(20);释放gpio资源 上述就是一个完整的在内核中如果想操作一个gpio的流程 上述操作是基于内核的标准gpio子系统而注册gpiodriver后才可以使用，其他各种不标准的做法不可以使用上述即下述的操作
2.用户态： http://blog.csdn.net/xgbing/article/details/51009384 http://blog.chinaunix.net/uid-27875-id-3979149.html （1）.将GPIO通过sysfs导出到用户空间 要想在用户空间访问GPIO，首先需要在sysfs中使能GPIO支持。
Device Drivers ---&gt; [*] GPIO Support ---&gt; [*] /sys/class/gpio/... (sysfs interface) 配置后gpiolib_sysfs.c才可以支持编译。 此时系统会有目录/sys/class/gpio这个文件夹出现
cd /sys/class/gpio ls export gpiochip0 gpiochip32 gpiochip64 gpiochip96 unexport 或者使用：for i in gpiochip* ; do echo `cat $i/label`: `cat $i/base` ; done /soc/gpio@18000100: 0 /soc/gpio@18000120: 32 /soc/gpio@18000140: 64 /soc/gpio@18000160: 96 这个表示目前系统中有4组gpio，index从0开始一直到96+32 = 127 此时若要操作某个gpio，现将其导出 echo 139 &gt;/sys/class/gpio/export export_store: invalid GPIO 139 sh: write error: Invalid argument //因为139号引脚不存在，所以报错 echo 26 &gt;/sys/class/gpio/export //没有报错 ls export gpio26 gpiochip0 gpiochip32 gpiochip64 gpiochip96 unexport//此时已经有gpio26被导出在sysfs空间了 cd gpio26 //进入gpio发现会有这么多它的属性，此时我们可以cat这些属性查询他们的default状态 # ls active_low direction power uevent device edge subsystem value 我们对gpio26的direction属性做操作 echo out &gt; /sys/class/gpio/gpio26/direction //置为输出状态 echo 1 &gt; /sys/class/gpio/gpio26/value //设置为高电平 # cat value //查看设置成功 1 echo 26 &gt; /sys/class/gpio/unexport //取消导出 s export gpiochip0 gpiochip32 gpiochip64 gpiochip96 unexport //此时已经看不到 gpio26 这个文件了，表示取消成功 上述我们看到要操作一个gpio的时候可以要使用echo 26 &gt;/sys/class/gpio/export才可以导出gpio26这个文件，其实也可以预先让其默认让其导出， 在内核代码中当使用gpio_export()函数去使能： gpio_request(26, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c610ade246653b75e1b903084406530e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbd1902b0a2642b2fd214f95364c7dc3/" rel="bookmark">
			arm-xilinx-linux-gnueabi-gcc常用的命令参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编译分四个阶段：①预处理②编译③汇编④链接
以main.c为例：
arm-xilinx-linux-gnueabi-gcc -o main mian.c 执行全部过程生成main.out,如果不指定mian，默认输出a.out
arm-xilinx-linux-gnueabi-gcc -c main.c 只对main.c经行编译生成main.o
arm-xilinx-linux-gnueabi-gcc -S main.c 只对main.c经行编译生成main.s
arm-xilinx-linux-gnueabi-gcc -v -o main mian.c 在编译过程中显示详细信息
arm-xilinx-linux-gnueabi-gcc -Wall -o main mian.c 打开警告显示
arm-xilinx-linux-gnueabi-gcc -Ox -o main mian.c 打开优化，x为优化等级，值为空，0，1，2，3，4
arm-xilinx-linux-gnueabi-gcc -I home/include -o main mian.c 添加头文件路径
arm-xilinx-linux-gnueabi-gcc -L home/lib -o main mian.c 添加库文件路径
（上面两条所述的添加路径的方法不常用，要是经常使用某些外来库的include和lib，建议直接将其拷贝到交叉编译器的标准库路径下。)
arm-xilinx-linux-gnueabi-gcc -static -o libexample.a libexample.c 生成静态链接库文件 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/778ec77774fc21afdb99323f55becf4e/" rel="bookmark">
			使用Java poi编辑word.docx文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置了解 这里仅说明以docx后缀的word文件，doc文件似乎用的是另一个api，不是很了解。
首先在使用poi之前，需要了解word.docx的存储方式。右键word文档，我们可以发现选项中是有打开压缩包等选项的。解压缩后文件夹格式如下：
-word -_rels - .rels -customXml ... -docProps ... -media - 1.png - 2.png - ... -word ... - document.xml ... [Content_Types].xml 复制代码 其中我们需要关注的主要是media文件夹，它下面是该word文档中所有的图片；以及word文件夹下的document.xml，该xml文件统领全局，包括了word文档中的文字、格式、图片的引用等等。
使用poi 如果使用maven的话，可以添加如下引用：
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-scratchpad&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; 复制代码 如果需要处理word中的数学公式，那么还需要添加：
&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; 复制代码 document 首先是获取文档的内容，XWPFDocument document = new XWPFDocument(new FileInputStream(filePath));
接下来说下document的整体格式。
此时我们获取的document，很大程度上就是对应了之前word文件夹下的document.xml文件，我们之后也会很多的使用xml的方式来处理word文档。用文本编辑器打开document.xml，这个文件是经过混淆的，我这里使用sublime的插件来进行重新排版。
从document.xml文件可以看到，根节点w:document下紧跟的是w:body，body节点下几乎包括了所有的文件信息。body下是三种节点：
1.&lt;w:sectPr&gt;:该节点下定义了该word文档的整体信息，包括页眉页脚的引用，你可以在解压后的word文件夹下找到页眉页脚的定义。另外也包括了页面的大小。这一部分我在使用过程中不需要获取，具体内容也不是很了解。可以在复制新的document时使用document方法直接整体set进去（如果不需要获取格式内容的话，接下来的段落、表格及它们内部的节点同理，格式部分直接用原来的设置）；
2.&lt;w:p&gt;：段落，对应XWPFParagraph。段落下主要也有三个节点
1.&lt;w:pPr&gt;与sectPr同理，格式部分内容，接下来的各部分的格式部分就不在重复了，基本上每一个节点都拥有一个属性，对应poi中的一个类
2.&lt;w:run&gt;run标签，对应XWPFRun，是段落中格式相同的一部分内容，主要包括了属性部分，图片部分，文字部分。也就是说，一个段落中如果有多个格式的文字，或是图片，那么该段落节点下相应的就会有多个run标签。
--------1.文字部分：在text标签下，设置和获取都很简单，相应对象中有直接的方法
--------2.图片部分：&lt;w:drawing&gt;标签，对应XWPFPictureData。需要注意的是，word中每一张图片都对应一个Id：
&lt;pic:blipFill&gt; &lt;a:blip cstate="print" r:embed="rId15"/&gt; &lt;a:stretch&gt; &lt;a:fillRect/&gt; &lt;/a:stretch&gt; &lt;/pic:blipFill&gt; 复制代码 找到其中的该部分内容，其中我们可以得到该图片的id为rId15，我们可以直接通过XWPFPictureData picture = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/778ec77774fc21afdb99323f55becf4e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/517/">«</a>
	<span class="pagination__item pagination__item--current">518/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/519/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>