<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dd4889bcdb7e21b2cc33fc74a1cf639/" rel="bookmark">
			正版激活码，速领！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「 静静地做自己，让世界发现你 」
科技毒瘤君将不定时分享优质工具，大家可以把科技毒瘤君公众号设为★星标，第一时间获取最新推送，以防错过优质内容
官网地址：www.exehub.net - 互联网免费资源中心
本次主要给大家分享一下网站刚更新的两款软件和其他内容分享。
因为在公众号一次性不能发那么多篇文章，一篇文章太长了也没人看，所以以后我都会在公众号做一次通知，建议大家直接收藏www.exehub.net。网站内容全部免费分享，不存在任何收费情况。现在不，以后也不。
今天分享的是傲梅远程控制软件AnyViewer Pro 专业版限时免费领取 X年，为何是X年，因为有的激活码可能过期了，所以不确定是最大是几年。
AnyViewer是一款免费且好用的远程桌面软件，适用于Windows个人电脑和服务器
版本区别
下载地址
https://www.anyviewer.cn/
激活码
下载并注册软件，然后点击头像，即可看到输入激活码的地方，输入激活码即可
授权码1（3年）：8033-8826-8278-E404
授权码2（1年）：BA24-E088-CABA-654C
授权码3（1年）：9FB6-6635-18DA-70C0
授权码4（1年）：9E4D-AA6B-B84B-7104
授权码5（1年）：94E1-656C-22EC-4DFB
授权码6（1年）：9DE6-5EF9-7FEC-9A62
原文地址：https://www.exehub.net/402.html
历史文章推荐
1.[网站更新]正版软件+正版游戏限免！马上过期！
2.仅剩3小时，Epic限免，原价249元直接白嫖
3.时隔半年，我的网站终于又回来了
4.4K Video Downloader+ 最全面的网路影片下载工具评测与推荐！
5.这个下载器支持超过10,000 影音平台！还能下载。。
网站更新
网站每天都会更新，建议大家直接点击浏览器的收藏按钮，将网站收藏，下面分享今日更新内容，不想复制链接到浏览器打开的朋友，可以直接点击文末左下角的阅读原文按钮。
亿速云年末活动，限时活动，海外免备服务器88元/年
https://www.exehub.net/405.html
QQ年度报告，太有趣了，附入口
https://www.exehub.net/389.html
使用代码实现WordPress实现发布文章自动api推送给必应
https://www.exehub.net/393.html
WordPress纯代码实现上传文件自动重命名
https://www.exehub.net/394.html
Codestar framework后台UI怎么自定义CSS样式美化和js？
https://www.exehub.net/396.html
记录排查WordPress使用phpmailer发送邮件失败的原因
https://www.exehub.net/399.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a72d5a99170fc023992fea91e450365/" rel="bookmark">
			《剑指offer》Java版--14.剪绳子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		剑指offer原题14:剪绳子
给你一根长度为n的绳子，请把绳子剪成m段(mn都是整数n&gt;1并且m&gt;1)，每段绳子的长度记为O],[1],·-,[m]。请问O]xk[1]x···Xk[m]可能的最大乘积是多少?例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是 18。
LeetCode原题：https://leetcode.cn/problems/jian-sheng-zi-lcof/description/
思路一：数学 class Solution { public int cuttingBamboo(int bamboo_len) { if(bamboo_len &lt;= 3) return bamboo_len - 1; int count = bamboo_len / 3; int mod = bamboo_len % 3; int res; if(mod == 0) res = (int)Math.pow(3, count); else if(mod == 1) res = (int)Math.pow(3, count - 1) * 4; else res = (int)Math.pow(3, count) * 2; return res; } } 思路二：动态规划 对于长度为n的绳子，定义F(n)为最大乘积。如果剪成2段，则F(n) = max(F(n-i) * F(i)) 其中 0&lt;i&lt;n。然后要求F(i)和F(n-i)，这个时候就相当于从上往下的递归。可以改造成从下往上的递推。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a72d5a99170fc023992fea91e450365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a670acdc322b32031865f03323b1600e/" rel="bookmark">
			内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、作用域 C 语言变量的作用域主要有三种：
代码块作用域（代码块是 {} 之间的一段代码）函数作用域文件作用域 1.1、局部变量 局部变量也叫 auto 自动变量（auto 可以不写），一般情况下代码块 {} 内部定义的变量都是自动变量，具有如下特点：
在一个函数内定义，只在函数范围内有效在复合语句中定义，只在复合语句中有效随着函数调用的结束或复合语句的结束，局部变量的生命周期也就结束了 int main() { //定义变量，局部变量，只在main函数内有效 //作用域：main函数之内 //生命周期：从创建到函数结束 auto int a=10;	//auto可以省略不写 return 0; } 1.2、全局变量 在函数外定义，可被本文件及其他文件中的函数所共用，若其他文件中的函数调用此变量，须用 extern 声明全局变量的生命周期和程序运行周期一样不同文件的全局变量不可重名全局变量存储在数据区全局变量可以和局部变量同名，使用的时候采用就近原则不同文件中的全局变量不可以重名 main.c
#include&lt;stdio.h&gt; //全局变量：在函数外部定义的变量 //作用域，整个项目中所有文件，如果在其他文件中使用，需要声明 //生命周期，从程序创建到程序销毁 int a=10; void func() { a=100; printf("%d\n",a); } int main() { printf("%d\n",a);	//10 int a=123;	//数据在操作时，采用就近原则 //匿名内部函数 { int a=456; printf("%d\n",a);	//456 } //匿名内部函数 { a=456; printf("%d\n",a);	//456 } printf("%d\n",a);	//456 func();	//100 func2();	//1000 return 0; } test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a670acdc322b32031865f03323b1600e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52e6234eba2bc724cfa5b3f757470024/" rel="bookmark">
			实践:修改正式站表名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.引言 现在有一个需求，发现正式站的数据库里面有个表名不合理，需要修改，但是正式站一般不能修改表名，所以现在的做法是新建一个表，将旧表的数据复制到新表，然后将旧表删除。由于正式站的数据还在不断产生，这里需要控制复制的数据的正确性,保证服务和数据的同时上线。
二.方法 新建一个和旧表结构一样的表修改服务中代码的表名复制数据 INSERT INTO `tb1` SELECT * FROM `tb2`; 由于一般来说插入的数据ID是自增的，所以的要保证复制数据的ID也对得上，所以得先将正式站的数据复制好，才能上代码让新数据插入到新表.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3974ec5278ed57154808766b975f067e/" rel="bookmark">
			git的常用命令以及在可视化工具中的使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.引言 想当初在刚进公司的时候，对于git的使用非常不熟悉，特别是分支的概念，导致开发效率变低，故通过此文章，总结git的使用经验
二.Git 常用命令详解 2.1 git clone [url]: 克隆远程仓库到本地 刚开始时，都需要将远程的代码拉到本地，这里一般是去对应的代码托管平台复制项目的链接,链接有ssh和http的形式，对应两种安全加密方式。
gitBash工具
2.2 git branch [branch_name]: 创建新分支 对应于IDEA中
2.3 git checkout [branch_name]: 切换分支。 2.4 git commit -m “[message]”: 提交暂存区中的文件到本地仓库 2.5 git push [remote] [branch_name]: 推送本地分支到远程仓库 2.5 git pull: 从远程仓库拉取并合并代码到本地 对应于IDEA中
2.6 git merge [branch_name]: 将指定分支合并到当前分支。 这里经常会在某个分支下开发完成了之后，如果需要和前端联调，就要将当前的分支合到dev-master分支，测试完成最终将当前开发分支合到master分支
三分支控制 目前大部分项目开发都有master,dev-master分支，一般不自己在这两个分支开发，都是在自己新建的分支下开发，然后将该分支下commit的内容merge到这两个分支
四.分支遴选 有时候新建的一个分支想要其他分支的某些commit,可以使用分支遴选cherry-pick将特定分支合到当前分支
五.效率提高与工具推荐 有时候我们在开发过程中需要去解决其他需求的bug,这个时候如果要切换分支就需要要提交当前没写完的代码，容易造成commit次数过多，这里可以使用SourceTree里面的储藏功能，将当前的代码存储起来，等下次切换回该分支的时候可以恢复回来
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a84a189b88d56eb5caba755310b43f0f/" rel="bookmark">
			【2】Docker Compose编排
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker Compose 使用 Docker 帮助我们解决服务的打包安装的问题，随着而来的问题就是服务过多的带来如下问题：
多次使用 Dockerfile、Build、Image 命令或者 DockerHub 拉取 Image；需要创建多个 Container，多次编写启动命令；Container 互相依赖的如何进行管理和编排。 Compose 是一个用于定义和运行多容器的 Docker 应用的工具。使用 Compose，你可以在一个配置文件（yaml格式）中配置你应用的服务，然后使用一个命令，即可创建并启动配置中引用的所有服务。
Compose 使用的三个步骤：
使用 Dockerfile 定义应用程序的环境使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行最后，执行 docker compose up 命令来启动并运行整个应用程序 Docker Compose 管理容器的结构 Docker Compose 将所管理的容器分为三层，分别是工程（ project），服务（service）以及容器（container）。Docker Compose 运行目录下的所有文件（ docker-compose.yml、 extends 文件或环境变量文件等）组成一个工程（默认为 docker-compose.yml 所在目录的目录名称）。一个工程可包含多个服务，每个服务中定义了容器运行的镜像、参数和依赖，一个服务可包括多个容器实例。
同一个 docker compose 内部的容器之间可以用服务名相互访问，服务名就相当于 hostname，可以直接 ping 服务名，得到的就是服务对应容器的 ip，如果服务做了扩容，一个服务对应了多个容器，则 ping 服务名会轮询访问服务对应的每台容器 ip ，docker 底层用了 LVS 等技术帮我们实现这个负载均衡。
Docker Compose.yml 常用指令 image 指定镜像名称或者镜像 id，如果该镜像在本地不存在，Compose 会尝试 pull 下来。
示例：
image: java build 指定 Dockerfile 文件的路径。可以是一个路径，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a84a189b88d56eb5caba755310b43f0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/137067acfcb2b0c6e70d25a5bfd92733/" rel="bookmark">
			基于边缘计算的高效动态隐私保护联邦学习系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发来源微信公众号：SEUUNiS
高水平论文阅读分享
An Efficient and Dynamic Privacy-Preserving Federated Learning System for Edge Computing
Xinyu Tang, Cheng Guo, Member, IEEE, Kim-Kwang Raymond Choo, Senior Member, IEEE, and Yining Liu
大家好，今天跟大家分享一篇来自IEEE Transactions on Information Forensics and Security(CCF-A)2024年的一篇文章—基于边缘计算的高效动态隐私保护联邦学习系统。
作者及实验室介绍
第一作者：Xinyu Tang
Xinyu Tang分别于2016年和2018年获得大连理工大学软件工程学士和硕士学位，目前正在攻读博士学位。他的研究方向包括密码学、私有数据保护技术和云存储技术，并已在相关领域发表了一些论文。他目前正在研究安全机器学习和安全多方计算。
通信作者：Kim-Kwang Raymond Choo
Kim-Kwang Raymond Choo（IEEE 高级会员）于 2006 年获得澳大利亚昆士兰科技大学信息安全博士学位。他目前担任德克萨斯大学圣安东尼奥分校的云技术终身教授。他是 IEEE 技术与工程管理学会区块链和分布式账本技术委员会（TC）的创始主席。
实验室介绍：
辽宁省泛在网络与服务软件重点实验室位于大连理工大学开发区校区软件学院，于2014年由辽宁省科技厅获批筹建。实验室是以泛在网络及其相关的服务软件为主要研究方向，整合目前国际最新的网络技术、计算技术并以普适的软件形式渗透到国民经济的各个方面。实验室下设五个研究室：传感网与智能感知技术研究室、异构网络融合技术研究室、数字内容智能处理研究室、高可信系统研究室、云计算与高端IT服务研究室。
介绍
01
联邦学习（FL）是一种分布式机器学习框架，允许用户使用本地数据集进行模型训练。对于参与节点，他们需要有充足的计算能力、网络带宽和存储能力。但是在联邦边缘学习（FEL）中，边缘设备资源相对有限。这些设备需要长时间运行并且能够不断更新其模型。他们仅在空闲时参与训练过程，并且可以随时退出该过程。因此，整个系统需要更高的灵活性、可扩展性，并支持低开销的长期模型训练和更新需求，以满足边缘设备的约束和需求。
同时，尽管联邦学习避免了参与者之间直接交换敏感数据，但交换明文参数仍然会带来隐私泄露的风险，现有的许多运用在联邦学习的隐私保护方案能确保传输参数的安全，但许多隐私保护方案可能带来大量额外的计算和通信开销，较难权衡隐私保护和效率的关系。
基于此，这篇文章为联邦边缘学习开发一种灵活、动态和低开销的隐私保护方案，以实现隐私与效率之间的平衡。
动机
02
1、每个边缘设备的状态互不知晓。确保数据隐私并非易事。
2、每个边缘设备的本地数据集具有不同的数据质量。因此，设计有效的边缘设备调度策略是一项挑战。
3、参与训练过程的设备集不是固定不变的，可能会随着设备的随时添加或移除而动态变化。
贡献
03
1、设计了一个动态灵活的联邦边缘学习系统，并根据边缘计算场景中系统架构和边缘设备的特点，提出了一种新的保护隐私的协同训练方案。它既可以有效支持边缘设备的快速变化，又能保护数据隐私。
2、由于边缘设备的动态性和异构性，文章提出了一种具有相对贡献水平的调度策略，以确保边缘设备之间的长期运行效率。这可以加速模型收敛并减少系统开销。
预备知识
04
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/137067acfcb2b0c6e70d25a5bfd92733/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a91a7608078fff9f7fc11a58c67773f/" rel="bookmark">
			手动创建idea SpringBoot 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		步骤一： 步骤二： 选择Spring initializer -&gt; Project SDK 选择自己的JDK版本 -&gt;Next
步骤三： Maven POM -&gt;Next
步骤四： 根据JDK版本选择Spring Boot版本
11版本及以上JDK建议选用3.2版本，JDK为11版本以下后期手动操作将Spring Boot版本改为2.7.18（见下文步骤六后操作） 步骤五：
根据需要修改文件路径和项目名称 -&gt; Finish
步骤六：
项目创建成功后以上两个文件必须存在
一个正常可运行的Spring Boot项目必须包含以下四部分内容 ，其他文件可有可无不影响正常运行
由于使用者idea版本、JDK版本、Spring Boot版本多方因素影响，如果步骤六中创建成功的文件中缺少src和gitignore文件，我们需要进行手动创建：
https://pan.baidu.com/s/1nf-m7UvkvJUQfnzCZlpGnA?pwd=2ltt JDK11以下版本需修pom.xml文件中Spring Boot版本改为2.7以下，建议修改为2.7.18
修改pom.xml文件中JDK版本为自己所使用的版本
保存后重新启动idea 运行出现以下界面则成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d512736bd6a5e5f4c664c71c7fcffb5/" rel="bookmark">
			Linux编辑器vim的基本操作（详解及GIF演示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💫Linux开发工具vim 在我们初学某门语言时可能接触过使用记事本编辑代码，在之后我们开始接触visual studio等集成开发环境，对于这种基于图形化界面的编辑工具我们可以说已经十分熟悉了，那么接下来我们就来介绍一下Linux中的编辑器vim，以及如何使用vim。
⭐️vim的模式 vim是一款多模式编辑工具，本文主要讲解，普通模式，插入模式，底行模式
正常/普通/命令模式(Normal mode)
控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及切换其他模式。
插入模式(Insert mode)
做文字输入。
底行模式(last line mode)
文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 在命令模式下，shift+: 即可进入该模式。
以上是vim最常用的几种模式，vim模式详情可在底行模式输入:help vim-modes（注：当我们切换至底行模式时自动就输入了一个：）
（注：退出查看，底行模式输入：q）
💫vim基本操作 进入vim时，默认是命令模式，
⭐️vim插入模式基本操作 插入模式操作我们早就已经接触过了，可以说十分熟悉，我们怎么在记事本编写代码，插入模式就怎么操作。重点是怎么从命令模式和插入模式中自由切换。
从命令模式切换至插入模式，可从命令模式输入a,i,o;
其他的所有模式切换至命令模式，按ESC键
注：模式之间的切换，只能从命令模式和其他模式之间进行切换，例如我想要从插入模式切换至底行模式，就只能从插入模式切换至命令模式然后再切换至底行模式。
✨命令模式输入i:从光标当前位置输入内容
✨ 命令模式输入a:从光标的下一个位置输入内容
✨ 命令模式输入o:从新的一行输入内容
请看gif动画，我会依次输入i,a,o
注：左下角有模式种类提示
⭐️vim命令模式基本操作 （注：不输入数字n，默认是1）
🌟光标移动操作 [$] ：移动光标至所在行最右侧结尾处。
[^] ：移动光标至所在行最左侧开头处。
[G]：移动光标至文本最结尾。
[n+G] (注：n表示一个十进制数字)：移动光标至指定行。
[gg]：移动光标至文本最开始。
[h]：光标左移，相当于方向键左
[j]：光标下移，相当于方向键下
[k]：光标上移，相当于方向键上
[l]：光标右移，相当于方向键右
[w]：按照“单词”后移
[b]：按照“单词”前移（注：单词并不是完全指英语单词，vim有它的界定条件，这个条件需自己感受）
🌟复制，剪切，删除与粘贴操作 [n+yy]：复制当前n行
[n+dd]：删处/剪切当前n行，
[n+pp]；粘贴n次内容至当前行
[n+x]：删除光标所在n个字符
[n+X]：删除光标前n个字符
我会剪切main函数整体，并且粘贴1次，然后我会复制main函数整体，并且进行2次粘贴。再最后对“main()”进行删除,先5+X,再x.
🌟撤销与撤销撤销操作 [u]：撤销操作
[ctrl键+r]：撤销之前做的撤销操作
我会先删除main函数整体，然后再撤销删除操作，然后再撤销对撤销删除操作的撤销（真拗口呀，操作方面还是自己操作自己感受贴切）
🌟替换操作 [~]：大小转换
[n+r]：替换n个字符
[R]：进入替换模式（replace mode）:是vim编辑器的一种模式，和插入模式类似，可任意进行字符替换。
仔细感受GIF（左下角有模式切换提醒）
🌟查找操作 [#]：高亮要查找的函数名/字符串名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d512736bd6a5e5f4c664c71c7fcffb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935baf98afbcd1608716a36b69527dfe/" rel="bookmark">
			C语言“函数”总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数内容
目录
函数是什么
库函数
自定义函数
函数的参数
在参数调用用中 有 传值调用 和 传址调用
知识点 布尔类型
函数的嵌套调用
链式访问
函数递
函数是什么 用于执行某项特定任务，具有独立性的代码。 C语言中函数的分类
函数分为库函数和自定义函数
C语言是结构化的程序设计语言
一般有
-顺序结构
-选择结构
-循环结构
比如求和代码
中 定义了add函数
Add 执行 x+y=z 之后 返回 z结果
Add只是个名字 括号内的是参数 大括号内的是函数体 int是返回类型
定义好后可以反复调用
（简化版）
库函数 库函数是经常用的函数是过去经常使用的函数为了方便的积累
在网站 www.cplusplus.com/reference/ 中能查到以往的库函数
自定义函数 自定义函数是做库函数不能做的事情
自定义函数想库函数一样，有函数名，返回值类型和函数参数
自定义函数相对重要一些
它用于编出自己需要的函数
就是 返回类型 + 名字 +（参数A，参数B） 可以没有 一个 或者两个参数
比如取大自定义函数
如果用void就可以不返回
特殊知识点 形参 与 实在参数
在下面的a和b是实参
X，y是形参 改x和y与a和b没关系。用指针改 间接改 要改为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935baf98afbcd1608716a36b69527dfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f85ade6058f9d8020c275d2d8f4b07/" rel="bookmark">
			C语言 “入门” 章节的全知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.第一个c语言程序
二.数据类型
三.常量与变量
四.变量的作用域和生命周期
五.常量
六.字符串
​编辑
七.转义字符
八.注释
九.选择语句
十.函数
十一.数组
十二.操作符
十三.关键字
十四.关键词
十五.指针
十六.结构体
一.第一个c语言程序 对于vs2022软件认知 和 程序程序认知
打开vs创建项目 3.创建资源文件 以后缀区分（.c 源文件 .h头文件）
注意后缀！ 如果是以.cpp为后缀 编译器会按照C++编译 如果是以C为后缀 就是C语言
4.写代码
亲手写的
批注; C语言中一定要有main函数
也就是主函数
int main() 也有void main（）古老写法 {
Return 0;
}
以上是标准的主函数写法 int是整型类型
Return 0 的0是整数
Printf（“呵呵\n”）； printf是一个库函数 用来打印数据的
#include&lt;stdio.h&gt; 包含头文件 也就是使用头文件 stdio.h 是标准输入输出的意思
Ctrl F5 是快捷运行 也可以在调试中找到
Main函数是C语言的入口
Ctrl+k+c 注释 ctrl+K+u 取消注释
二.数据类型 数据类型
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2f85ade6058f9d8020c275d2d8f4b07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4de2e649703775da13157507ff6fcbfa/" rel="bookmark">
			C语言操作符总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C语言所有操作符总结-CSDN博客
一、概述 C语言提供了丰富的操作符，用于对变量进行各种运算和操作。操作符可以分为算术操作符、关系操作符、逻辑操作符、位操作符、赋值操作符和其他操作符。
二、算术操作符 加法操作符（+）：用于将两个数值相加。减法操作符（-）：用于将第一个数值减去第二个数值。乘法操作符（*）：用于将两个数值相乘。除法操作符（/）：用于将第一个数值除以第二个数值。取模操作符（%）：用于求两个整数相除的余数。自增操作符（++）：用于将变量的值增加1。自减操作符（--）：用于将变量的值减少1。 三、关系操作符 大于操作符（&gt;）：用于比较两个数值的大小，判断第一个数值是否大于第二个数值。小于操作符（&lt;）：用于比较两个数值的大小，判断第一个数值是否小于第二个数值。大于等于操作符（&gt;=）：用于比较两个数值的大小，判断第一个数值是否大于或等于第二个数值。小于等于操作符（&lt;=）：用于比较两个数值的大小，判断第一个数值是否小于或等于第二个数值。等于操作符（==）：用于判断两个值是否相等。不等于操作符（!=）：用于判断两个值是否不相等。 四、逻辑操作符 与操作符（&amp;&amp;）：用于判断两个条件是否都为真。或操作符（||）：用于判断两个条件中至少有一个为真。非操作符（!）：用于对一个条件进行取反。 五、位操作符 位与操作符（&amp;）：按位对两个数值进行与运算。位或操作符（|）：按位对两个数值进行或运算。位异或操作符（^）：按位对两个数值进行异或运算。位取反操作符（~）：按位对一个数值进行取反运算。左移操作符（&lt;&lt;）：将一个数值的二进制表示向左移动指定的位数。右移操作符（&gt;&gt;）：将一个数值的二进制表示向右移动指定的位数。 六、赋值操作符 赋值操作符（=）：将右侧的值赋给左侧的变量。加等于操作符（+=）：将右侧的值加到左侧的变量上，并将结果赋给左侧的变量。减等于操作符（-=）：从左侧的变量中减去右侧的值，并将结果赋给左侧的变量。乘等于操作符（*=）：将左侧的变量乘以右侧的值，并将结果赋给左侧的变量。除等于操作符（/=）：将左侧的变量除以右侧的值，并将结果赋给左侧的变量。取模等于操作符（%=）：将左侧的变量对右侧的值取模，并将结果赋给左侧的变量。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63354a8b457f27ec3a6a838d0014cea9/" rel="bookmark">
			C语言操作符（简单解释版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		算术操作符： +：用于将两个数值相加。例如：3 + 5 = 8。-：用于从一个数值中减去另一个数值。例如：5 - 3 = 2。*****：用于将一个数值乘以另一个数值。例如：6 * 5 = 30。/：用于将第一个数值除以第二个数值。例如：10 / 2 = 5。%：取模运算符，返回两个数相除的余数。例如：10 % 3 = 1。++：自增运算符，使一个变量的值加1。例如：x++ 或 ++x。--：自减运算符，使一个变量的值减1。例如：x-- 或 --x。 移位操作符： &lt;&lt;：左移运算符，将一个二进制位的操作数按指定的位数向左移动，左边丢弃，右边补0。&gt;&gt;：右移运算符，将一个二进制位的操作数按指定的位数向右移动，左边是符号位（正数为0，负数为1）。 位操作符： &amp;：按位与运算符，对应位都为1时，结果为1，否则为0。|：按位或运算符，对应位都为0时，结果为0，否则为1。^：按位异或运算符，对应位相异时结果为1，相同时结果为0。~：按位取反运算符，0变为1，1变为0。 赋值操作符： =：赋值运算符，将一个表达式的值赋给一个左值（可以写入的变量）。+=、-=、*=、/=、%=、&amp;=、|=、^=、&lt;&lt;=、**&gt;&gt;=**等：复合赋值运算符，执行算术或位运算后赋值。 单目操作符： !：逻辑非运算符，用于对一个条件进行取反。例如：!true = false。&amp;：取地址运算符，返回变量的内存地址。*（间接访问）：通过指针访问变量。例如：ptr-&gt;field 或 (*ptr).field。sizeof：返回变量或数据类型的大小（以字节为单位）。例如：sizeof(int)。 关系操作符：用于比较两个值的大小关系。 &gt;（大于）、&lt;（小于）、&gt;=（大于等于）、&lt;=（小于等于）、==（等于）、!=（不等于）。 逻辑操作符：对逻辑值进行运算。 &amp;&amp;（与）、||（或）、!（非）。 条件操作符（三目运算符）：根据条件返回两个值中的一个。例如：condition ? value_if_true : value_if_false。 逗号表达式：逗号用于分隔多个表达式，并返回最后一个表达式的值。例如：a = 1, b = 2, a + b 结果为3。 下标引用（数组索引）：通过使用索引来访问数组中的元素。例如：array[index]。 函数调用：通过函数名和参数列表来调用函数并执行其中的代码。例如：printf("Hello, World!") 调用标准库中的 printf 函数并输出字符串 "Hello, World!"。 结构成员访问符（点符号 .）：用于访问结构体变量的成员。例如，如果有一个结构体变量 person 包含一个名为 name 的成员，则可以通过 person.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63354a8b457f27ec3a6a838d0014cea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7887c8957b3babc9a6f291b21cc5f7e/" rel="bookmark">
			C语言占位符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 占位符有
%d：用于输出十进制整数。%i：用于输出整数，与%d基本相同。%u：用于输出无符号整数。%f：用于输出浮点数。%c：用于输出字符。%s：用于输出字符串。%p：用于输出指针的值。%n：用于保存已输出的字符数量到指定的变量中。%o：用于输出八进制整数。%x：用于输出十六进制整数。%e：用于输出科学计数法的浮点数，指数部分的e为小写。%E：用于输出科学计数法的浮点数，指数部分的E为大写。%g：用于输出浮点数，根据情况自动选择%f或%e格式。%G：用于输出浮点数，根据情况自动选择%f或%E格式。%l：用于表示长整型，如%ld表示输出长整型整数。%L：用于表示长双精度浮点数，如%Lf表示输出长双精度浮点数。%%：用于输出一个百分号。 占位符的使用方法是在printf函数中，将占位符放置在字符串中的指定位置，然后在括号中提供要插入的值。
int a = 10; float b = 3.14; char c = 'a'; printf("整数：%d，浮点数：%f，字符：%c\n", a, b, c);
要输出什么就对应什么 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48a75671b1e19acb677cc70e4015d6a2/" rel="bookmark">
			C语言所有操作符总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
算术操作符：
移位操作符：
位操作符：
赋值操作符：
单目操作符：
关系操作符：
逻辑操作符：
以及特殊的操作符（条件，逗号，下标，调用，结构成员）
C语言操作符（简单解释版）-CSDN博客
算术操作符： 加法操作符（+）减法操作符（-）乘法操作符（*）除法操作符（/）取模操作符（%）自增操作符（++）自减操作符（--） 移位操作符： 左移操作符（&lt;&lt;）右移操作符（&gt;&gt;） 位操作符： 按位与操作符（&amp;）按位或操作符（|）按位异或操作符（^）按位取反操作符（~） 赋值操作符： 赋值操作符（=）加等赋值操作符（+=）减等赋值操作符（-=）乘等赋值操作符（*=）除等赋值操作符（/=）取模等赋值操作符（%=）左移等赋值操作符（&lt;&lt;=）右移等赋值操作符（&gt;&gt;=） 单目操作符： 逻辑反操作符（！）正值操作符（+）负值操作符（-）取地址操作符（&amp;）sizeof操作符按位取反操作符（~）自增操作符（++）和自减操作符（--） 关系操作符： 大于操作符（&gt;）小于操作符（&lt;）大于等于操作符（&gt;=）小于等于操作符（&lt;=）等于操作符（==）不等于操作符（!=） 逻辑操作符： 与操作符（&amp;&amp;）或操作符（||）非操作符（！） 以及特殊的操作符（条件，逗号，下标，调用，结构成员） 条件操作符：三目运算符，格式为 条件 ? 值1 : 值2。根据条件的真假，返回两个值中的一个。逗号表达式：逗号表达式是一种特殊的表达式，格式为 表达式1, 表达式2, ...。逗号表达式的值是最后一个表达式的值。逗号表达式通常用于在循环或条件语句中执行多个语句。下标引用：下标引用是数组的索引，格式为 数组名[下标]。下标从0开始，表示数组中的元素。例如，arr[3] 表示数组 arr 中的第4个元素。函数调用：函数调用是执行函数的方式，格式为 函数名(参数列表)。参数列表是可选的，用于传递给函数的参数。函数调用会执行函数中的代码并返回函数的返回值。例如，printf("Hello, World!") 是调用标准库函数 printf 并传递一个字符串参数。结构成员：结构体是一种自定义数据类型，可以包含多个不同类型的成员。访问结构体成员的方式是通过点符号 .，格式为 结构体变量名.成员名。例如，如果有一个结构体变量 person，它有一个成员 name，则可以通过 person.name 来访问该成员的值。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4cca7e1f929ba5177a06a576865925b/" rel="bookmark">
			2023年秋学季总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 引言：
随着2023年秋天的离去，学季的结束也带来了诸多反思与总结的机会。在这篇总结中，我将分享我在这个学季中的学习经历、收获以及未来的规划。
工作内容概述：
完成了熟悉大学生活广交善缘，知道的各种途径的方向完成了学校规定的基础的学习任务 重点成果：
C语言自学完成，能简单的编写小程序游戏，比如三子棋，扫雷，贪吃蛇通过考核正式加入了校竞赛工作室，并与成员共事自学STM32达到最基本的水平，可以做出简单的基于蓝牙控制的遥控小车减肥下了50多斤 遇到的问题和解决方案：
学习进度缓慢：寒假期间制定任务按目标学习。知识点掌握不扎实：补充电路，模电，数电的知识支持竞赛能力。乱花钱：制定严格的金钱花费计划，每月存钱。 自我评估/反思：
这个学季，我深刻认识到学习不仅是为了取得好成绩，更是为了培养自己的思维方式和解决问题的能力。虽然在学习过程中遇到了一些困难，但通过不断努力和尝试，我克服了这些挑战，取得了不小的进步。但是我认为本学期我还是有很大的成就的，有知识面，认知的提升，能力的提升。
未来计划：
深化单片机编程知识学习，为下学期竞赛做好准备。考计算机二级，拿到一些证书，准备学习数据结构与C++，并为未来的考证准备。假期背英语单词。开始关注学术研究领域的报刊，学习专利，准备攥写扎实知识后尝试发论文和写专利继续减肥。 说些心里话吧：
大学是个充满机遇与竞争的净土，人们可以通过更多的渠道获取更多的知识，我深刻明白这一点，并为此而努力学习。
我深刻明白我的双非本科毕业出路很凄惨，如果不能在大学期间丰富自己知识，野蛮自己的肉体，就无法顺应社会对人才的需求，我为此有了很大的目标，我的生涯规划似乎有些难。
我内耗十分严重，因为它人比我优秀，我总会觉得自己无法赶上它们的步伐，我有些抱怨环境，抱怨自己的能力不能再强一些。我对于这个情况我依然是制定明确的学习任务，了解扩展知识面，学习新的知识，缓步前行，决不放弃。
我虽然已经学完了C语言，但是我的CSDN发的不全面，前期发的文章也很乱，我之后会进行修正和重新编写。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71fd09f53457ccae08ad272649c95b5d/" rel="bookmark">
			RestTemplate工具的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.引言 目前的工作经常会用到调用第三方API，以及自己写的内部服务之前的调用(不是分布式项目)的场景，因此有必要了解一下spring提供的这个工具。
二. 什么是 RestTemplate？ RestTemplate 是 Spring Framework 提供的用于进行 HTTP 请求的客户端库。它封装了 HTTP 请求的细节，使得开发者能够方便地发送请求并处理响应，支持多种 HTTP 请求方法和数据格式。
HttpClient与RestTemplate HttpClient：代码复杂，还得操心资源回收等,代码很复杂，冗余代码多，不建议直接使用，一般是封装为 HttpUtils工具类使用RestTemplate： 是 Spring 提供的用于访问Rest服务的客户端， RestTemplate 提供了多种便捷访问远程Http服务的方法,能够大大提高客户端的编写效率 RestTemplate 的特性 简化的 HTTP 请求：通过提供简单且易用的 API，使得发送 GET、POST、PUT、DELETE 等 HTTP 请求变得简单。
支持多种数据格式：能够处理不同的数据格式，如 JSON、XML 等。
拦截器支持：支持自定义拦截器以处理请求和响应。
异常处理：能够处理不同类型的 HTTP 异常。
如何使用 RestTemplate 1. 创建 RestTemplate 实例
在 Spring 应用中，你可以通过 Spring Boot 自动配置来获取 RestTemplate 实例。如果没有 Spring Boot，你可以手动创建 RestTemplate：
RestTemplate restTemplate = new RestTemplate(); 2. 发送 HTTP 请求
RestTemplate 提供了一系列方法来发送各种类型的 HTTP 请求。以下是一些常见的用法示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71fd09f53457ccae08ad272649c95b5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4aa3d17b313ae8ca6af5043441cdecca/" rel="bookmark">
			Unity 代码控制Text自适应文本高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用代码给Text赋值时，且文本有多段，并需要根据实际文本高度适配Text组件的高度时，可以使用以下方法：
//Text文本 public TextMeshProUGUI text; void Start() { //代码赋值文本 text.text = "好!\n很好!\n非常好!"; //获取文本的高度 float preferredHeight = text.preferredHeight; //获取文本的RectTransform RectTransform rectTransform = text.GetComponent&lt;RectTransform&gt;(); //组件高度根据实际文本高度自适应 rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, preferredHeight); } 设置前：
文本超出了组件框了。
设置后：
文本有多高，组件就有多高。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fee60b8e3f846b8016242e055610dc5c/" rel="bookmark">
			anaconda创建环境时安装默认的第三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 感谢阅读 写作原因首先要有python解释器加入每次创建环境都需要的python库查看所有的默认安装库还原方法 写作原因 近期由于多个项目在多头并举，出现了每次安装环境都要重新打一遍指令的麻烦问题，出于节约时间从而提高工作效率的目的。我尝试了很多方法，最后发现，其实anaconda的文档中就有这方面的教程，为了让更多人免于重复配置环境，特此写了本文。
首先要有python解释器 我默认加的3.11
conda config --add create_default_packages python=3.11 加入每次创建环境都需要的python库 本文以numpy为列子
conda config --add create_default_packages numpy 查看所有的默认安装库 conda config --show create_default_packages 还原方法 conda install anaconda-clean anaconda-clean --yes 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cbf8b4de648354a984177a8507c00b8/" rel="bookmark">
			android 转鸿蒙开发教程 安卓转换鸿蒙系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓手机可以直接更新成鸿蒙系统吗？
华为最近都收到诸多压力，从芯片架构的禁令到操作系统的禁令，这样的处境逼得华为不得不从自身寻找解决方案，于是余承东透露出了华为自研的OS“鸿蒙”最快今年秋天，最晚明年春天就可以正式亮相。 并且兼容安卓的所有应用，性能比安卓提高了超过60%，得知这个消息，其实很多华为的用户和粉丝都比较兴奋，至少很多人看做这是一个国产的操作系统崛起的标志。
虽然鸿蒙是一个好消息，不过我们还是需要冷静的看待这件事，鸿蒙其实并不能算是一个全新的OS，就好像AliOS一样，鸿蒙应该是一个安卓的衍生OS。阿里其实在几年前就已经研发出了自己的OS，AliOS，以前叫YunOS，这个操作系统不同于我们现在的MIUI，EMUI这种在安卓上做二次开发的系统，是一个从新架构搭建的OS。
华为的“鸿蒙”操作系统已经进入试用阶段，测试机数量达到了100万台，一旦完成复杂的测试将会正式面向广大普通消费者。根据网上的消息，华为将会在今年第四季度发布自主的鸿蒙系统。那么现有的安卓手机能够使用吗？下文具体说一说。
1、理论上，安卓手机可以直接使用“鸿蒙”系统
现在的安卓手机处理器均采用了ARM架构的处理器，鸿蒙操作系统的100万台测试机同样采用了原安卓手机，因此，理论上“鸿蒙”系统可以安装到所有的安卓手机，也就是大家所说的“刷机”。
安卓手机能够刷“鸿蒙”系统，需要具备两个条件：第一，鸿蒙系统需要开源，推出主流手机的刷机包；第二，安卓手机能够root，支持刷机，有些手机如果强行刷机，会导致主板损坏，比如三星手机的“熔断机制”。
是效果应该不会很好，而且无法持续发展。
、“鸿蒙”操作系统的优势
1)兼容所有安卓应用
鸿蒙操作系统将会兼容目前300万的安卓应用，并且经过“方舟编译器”编译后，应用的流畅度提升了60%，提升了用户体验，因此需要国内各大应用厂商应用方舟编译器，推出针对“鸿蒙”系统的应用，才能打造鸿蒙系统的“护城河”。
2)横跨手机、电脑、智能穿戴设备
鸿蒙操作系统打通了手机、电脑、智能穿戴设备，形成统一的操作系统，是面向5G网络和下一代物联网技术的操作系统。
3)采用了微内核架构
华为的“鸿蒙”操作系统采用了微内核的架构，区别于安卓系统的宏内核架构，解决了安卓系统碎片化严重、系统臃肿的问题。
总之，很多人对于华为的“鸿蒙”操作系统非常的期待，理论上任何安卓手机可以使用“鸿蒙”操作系统，但是可能受到合约、专利、商业利益等制约，“鸿蒙”操作系统可能只能针对华为手机(搭载了麒麟处理器)，搭载高通骁龙处理器的手机可能无缘“鸿蒙”操作系统。
HarmonyOS 鸿蒙2.0移动应用开发实战详解https://edu.csdn.net/course/detail/39184
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/356e45f84d4a603463160e694e699dbd/" rel="bookmark">
			卷积神经网络基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全连接层 BP（back propagation）算法包括信号的前向传播和误差的反向传播两个过程。即计算误差输出时按从输入到输出的方向进行，而调整权值和阈值则从输出到输入的方向进行。
误差值：将输出值和所期望的值进行对比，可以得到误差值。
实例：利用BP神经网络做车牌数字识别 读入一张彩色的RGB图像，可以看到每一个像素里都包含了三个值，即RGB分量。
首先进行灰度化，灰度化之后得到中间这幅图，它的每一个像素值都只有一个分量了。
再进行二值化处理，得到黑白图像，也就是最右边的这个图像。
用一个五行三列的滑动窗口对整个图像进行滑动，每滑动一个地方就计算白色的像素占整个像素的比例。按照这个方法遍历整个图像就得到了一个5×5的矩阵。
接着我们将5×5的矩阵按行进行展开，并把它拼接成一个行向量。一行一行的展开后得到一个一行25列的行向量。这样我们可以把这个行向量当成我们输入神经网络的输入层。
有了输入层后，我们来看下我们的输出层。one-hot编码是我们常用的对标签进行编码的一种方式。比如说如图我们期望他们输出的是0到9这么十个数值。
onehot好像是除了目标其余全部写0，比如一行10个位置，分别代表0-9，如果推测目标是8，那么就在第九个空位写1，其余九个空位全部写0。
我们有了输入和期望的输出，就能对网络进行训练了。
卷积层 卷积特性 拥有局部感知机制权值共享 对比普通的BP神经网络（理解全连接层的全值共享） 参数 连接层之间的权重参数
输入特征矩阵 卷积核的channel与输入特征层的channel相同输出的特征矩阵channel与卷积核个数相同 激活函数 为什么要引入激活函数 引入非线性因素，使其具备解决非线性问题的能力。
建议 训练过程当中，建议不要一开始就使用特别大的学习率进行学习，这样很可能导致很多神经元失活。
几个因素决定卷积后的尺寸 池化层 和卷积层比较类似，但是和卷积层比起来会简单很多。
poolsize：池化核大小
stride：步距大小
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e3810e45a0db86173a3cf5e56583206/" rel="bookmark">
			月薪高达6W，多家大厂急招鸿蒙开发工程师，现在转还来得及吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期，“安卓版本与鸿蒙不再兼容”的词条登上微博热搜，华为鸿蒙加速按下向“纯血鸿蒙”蜕变的启动键，欲与 iOS、安卓在市场三分天下。
一批嗅觉灵敏的互联网大厂，已经完成或开始启动开发鸿蒙原生 APP，也于近期发布了和鸿蒙系统有关的高薪岗位。
大厂们舍得为鸿蒙相关岗位开高薪的原因不难理解。
一方面，华为终端用户数量庞大，一旦鸿蒙摆脱安卓平台，这些用户不能白白流失。另一方面，在鸿蒙系统独立初期，谁家 APP 的质量和服务好，谁就能在鸿蒙生态前期建设中抢占先机。
那么作为普通开发者，到底该不该学 HarmonyOS 呢 ？
时间给出了答案。
行业萧瑟之秋，鸿蒙逆势突围。在全球手机销量下滑的2023年第二季度，华为手机销量逆势增长 58%。除了新机之外，华为超过 7 亿+的鸿蒙生态设备，更是任何开发者和应用提供商无法忽视的存在。
再来分析下 HarmonyOS 对软件开发行业的影响
HarmonyOS 是一个面向全场景的分布式微内核的操作系统，在框架层提供了用户程序框架、Ability 框架和 UI 框架，可以做到一次开发，多端部署，很大程度上提升了应用跨设备的开发效率。
3、哪些⼈适合直接转鸿蒙？
如果你是前端⼯程师，转鸿蒙⾮常的平滑， 鸿蒙提供了两种开发模式。
1.基于stage模型的ArkTS开发模式。
2.基于前端三件套的类web应⽤，换句话说，如果你擅⻓ts做项⽬开发，你可以⽆缝对接鸿蒙开发，如果你不会ts，你会html、css、js开发你也可以实现web模式来开发鸿蒙。
当然如果你有其他编程语⾔的基础，你依然可以⼊局，⽐如java、python、c、c++等等。
区别：FA模型，⾃鸿蒙系统早期版本就有的模型，适合简单应⽤。Stage模型是为了解决FA模型⽆法解决的开发场景问题，⽅便开发者更加⽅便地开发出分布式环境下的复杂应⽤。⾃ API9 新增的模型。是⽇后⻓期演进的模型。
5、如何提⾼鸿蒙学习效率？
首先得是开发语言 ArkTS，这个尤为重要，然后就是ArkUI声明式UI开发、Stage模型、网络/数据库管理、分布式应用开发、进程间通信与线程间通信技术、OpenHarmony多媒体技术……等。像中间还有许多的知识点，这边都以梳理成思维导图的形式了，并分成了六大专类
如果你还没有掌握鸿蒙，现在想要在最短的时间里吃透它，可以参考一下这份《鸿蒙 (Harmony OS)开发学习手册》点击查看做鸿蒙应用开发到底学习些啥？
里面内容包含了：配置，资源分类，ArkTs，ArkUI，应用模型，web开发，UI开发……等知识点记录。
为了能让大家更好的学习鸿蒙 (Harmony OS) 开发技术，这边特意整理了《鸿蒙 (Harmony OS)开发学习手册》（共计890页），希望对大家有所帮助：点击查看做鸿蒙应用开发到底学习些啥？
《鸿蒙 (Harmony OS)开发学习手册》
入门必看
1. 应用开发导读(ArkTS)
2. 应用开发导读(Java)
HarmonyOS 概念
1. 系统定义
2. 技术架构
3. 技术特性
4. 系统安全
如何快速入门？
1. 基本概念
2. 构建第一个ArkTS应用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e3810e45a0db86173a3cf5e56583206/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3019d5f91439e66c9522de988f3d61e8/" rel="bookmark">
			电子科大软件系统架构设计——软件建模详细设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 软件建模详细设计概述软件建模详细设计目标软件建模详细设计原则开闭原则里氏 (Liskov) 替换原则依赖倒置原则接口分离原则单一职责原则最少知识原则（迪米特法则）高内聚原则松耦合原则可重用原则 软件建模详细设计内容 UML 软件静态结构视图建模软件静态结构细化设计类的聚合关系细分专属聚合 (Exclusive0wns)从属聚合 (0wns)拥有聚合 (Has)成员聚合 (Member) 泛化与继承实现继承扩展继承限制继承方便继承 高级类图建模可见性导出信息限定关联关联类与具体化类 接口与抽象类接口抽象类接口与抽象类的区别 类内聚与耦合类内聚与耦合的启发规则类耦合的种类类之间 6 种关系的耦合强度依次增强迪米特法则应用 设计类图建模实践 UML软件动态交互视图建模顺序图通信图类操作发现操作类操作的表示 顺序图高级交互技术创建与销毁临时对象片段交互引用 UML软件状态机视图建模UML 软件的实现视图建模实现视图构件图构件和构件之间的依赖关系构件与接口之间的关系端口端口连接 部署图包图包包的可见性包的嵌套包图 图书借阅管理系统软件建模设计实践系统需求系统静态模型设计系统动态模型设计图书搜索功能逻辑设计图书借阅功能逻辑设计图书归还功能逻辑设计Book对象的状态机图设计Borrower对象的状态机图设计静态结构的类图模型细化设计 软件建模详细设计概述 软件建模详细设计目标 软件建模详细设计是在软件架构模型设计基础上，对系统中各模型进一步细化设计，给出软件程序实现的设计方案。
软件建模详细设计原则 开闭原则 软件实体（类、构件等）应该对功能扩展具有开放性，对代码修改具有封闭性。当应用需求改变时，在不修改软件实体源代码的前提下，就可以扩展模块的功能，使其满足新的需求。 案例：“环境监测器”功能构件设计
开闭原则设计的好处：
在不修改原有代码基础上，可以扩展新功能。提高代码的可复用性及可维护性。 里氏 (Liskov) 替换原则 子类可以扩展基类的功能，但不能改变基类原有的功能。子类在继承基类时，除了添加新的方法且完成新增功能外，不要重写基类的方法代码。子类必须遵守基类与外部类之间的隐含约定。 里氏替换原则设计的好处：
解决了继承重写父类带来的可复用性变差问题。提高代码的可复用性及可维护性。 案例：鸟类飞行时间计算模块程序设计
//鸟类 class Bird { protected double flySpeed; public void setSpeed(double speed) { flySpeed = speed; } public double getFlyTime(double distance) { return (distance / flySpeed); } } //燕子类 class Swallow extends Bird { } //几维鸟类 class BrownKiwi extends Bird { public void setSpeed(double speed) { flySpeed = 0; } } package principle; public class LSPtest { public static void main(String[] args) { Bird bird1 = new Swallow(); Bird bird2 = new BrownKiwi(); bird1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3019d5f91439e66c9522de988f3d61e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9610c5c27de147964541e3583bb718b7/" rel="bookmark">
			7&#43;非肿瘤&#43;线粒体&#43;PPI&#43;机器学习&#43;实验，多套路搭配干湿结合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给同学们分享一篇生信文章“Identification of mitochondrial related signature associated with immune microenvironment in Alzheimer's disease”，这篇文章发表在J Transl Med期刊上，影响因子为7.4。
结果解读：
在ND和AD样本中鉴定差异表达基因 该研究的流程图如图1所示。PCA分析显示了AD和ND样本的分布。所选数据集的详细信息如表3所示。在GSE122063中经过预处理筛选出了18378个基因，并通过adj.p.val和Log2FC鉴定出了2832个差异表达基因（DEGs），其中包括1119个上调基因和1713个下调基因（图2a）。在GSE132903中筛选出了493个DEGs，其中包括207个上调基因和286个下调基因（图2b）。分别使用热图表示了GSE122063和GSE132903数据集中前25个上调基因和前25个下调基因（图2c，d）。结果显示根据差异基因可以区分出两组。
潜在功能和差异表达基因的途径 将前八个显著激活的基因集和前八个抑制的基因集以点图的形式呈现，这些基因集来自于MSigDB的C5基因集。发现免疫反应显著激活，神经元间突触受到抑制（图2e）。同样，将MSigDB的C2基因集中前八个显著激活的基因集和前八个抑制的基因集以点图的形式展示。与脑衰老相关的基因被显著激活，与化学突触传递相关的基因被抑制（图2f）。
GSEA结果显示，抗原处理和呈递、凋亡、B细胞受体信号通路、JAK-STAT信号通路、p53信号通路、类似受体（TLRs）信号通路在KEGG术语中富集（图3a）。此外，还显示差异表达基因主要参与免疫应答激活、IL1R通路、IL18信号通路以及氧化磷酸化（OXPHOS）、线粒体脂肪酸β氧化、氧化损伤应答、线粒体通路、线粒体翻译、线粒体中的电子传递链-OXPHOS系统（图3b-e）。这些结果表明炎症反应和线粒体代谢在AD病理中起重要作用。
蛋白质相互作用网络分析和筛选中心MitoDEGs 从MitoCarta3.0数据库中获取了与线粒体相关的基因，并将这些基因与从GSE122063和GSE132903数据集中筛选出的DEGs进行交集，结果得到了115个交集的MitoDEGs（图4a）。115个MitoDEGs的表达水平在附加文件4：文件S2中显示。使用STRING数据库对115个MitoDEGs进行PPI分析，并使用Cytoscape进行网络可视化（图4b）。使用Cytoscape的插件MCODE识别出重要模块，并选择了一个包含20个节点和53条边的模块（图4c）。同时，使用插件CytoHubba从PPI网络中识别出前20个关键基因（图4d）。在组合后共获得了26个基因，其中包括GSE122063中的23个基因和GSE132903中的6个基因（图4e，f）。
关键基因的筛选和与免疫细胞的相关性分析 为了筛选关键基因，作者将从PPI分析中获得的23个DEGs做随机森林分析。具有显著值大于3的前六个基因被确定为进一步分析的候选基因（图5a，b）。MRPL10在AD组中表达显著增高，而SPG7、MRPS25、NIT2、OPA1和DLD在AD组中表达较低（图5c，d），如热图所示。在这六个MitoDEGs中，发现SPG7、MRPS25、NIT2、OPA1和DLD与记忆B细胞、效应记忆CD8 T细胞、活化树突状细胞、自然杀伤T细胞、17型T辅助细胞、MDSC、中性粒细胞、浆细胞样树突状细胞呈负相关。MRPL10与这些免疫细胞呈正相关（图5e）。
为了进一步提高AD的关键MitoDEGs的质量，作者使用了两种不同的机器学习算法来筛选基因。作者使用LASSO方法找到了16个特征MitoDEGs（图6a，b），并使用SVM-RFE算法获得了19个特征基因（图6c）。使用两种机器学习算法获得的基因的交集用于鉴定后续研究中的9个mitoDEGs（图6d）。为了进一步探索9个MitoDEGs与免疫细胞之间的潜在关系，作者发现SLC25A31和DMGDH与免疫细胞亚群之间没有关联（图6e，通过Spearman方法）。因此，这两个基因被排除在进一步的研究之外。AD和ND样本中七个MitoDEGs（BDH1，TRAP1，SERHL2，TDRKH，SLC25A32，XPNPEP3，PEX11B）的表达水平如图所示（图6f）。这些结果表明这七个基因与记忆B细胞、效应记忆CD8 T细胞、活化树突状细胞、自然杀伤T细胞、17型T辅助细胞、MDSC、中性粒细胞、浆细胞样树突状细胞有关。
AD中的免疫细胞浸润 在AD组和ND组中分析了28个免疫细胞浸润，并发现AD组和ND组之间有24种免疫细胞亚群存在差异（图7a，b）。其中，AD组中巨噬细胞、活化的CD8 T细胞、活化的CD4 T细胞、效应记忆CD8 T细胞、记忆B细胞、自然杀伤细胞、自然杀伤T细胞、17型T辅助细胞、中性粒细胞、髓系抑制细胞、浆细胞样树突状细胞、调节性T细胞、活化的树突状细胞的比例增加。而效应记忆CD4 T细胞、2型T辅助细胞、单核细胞、嗜酸性粒细胞的比例减少。此外，进一步分析免疫细胞的浸润表明细胞之间存在复杂的相关性（图7c），例如效应记忆CD8 T细胞/自然杀伤T细胞（0.87）、活化的树突状细胞/髓系抑制细胞（0.87）、自然杀伤细胞/自然杀伤T细胞（0.85）、浆细胞样树突状细胞/自然杀伤细胞（0.86）、巨噬细胞/调节性T细胞（0.84）、活化的树突状细胞/巨噬细胞（0.83）。
诊断模型 通过发现上述关键基因的生物功能，最终筛选出了五个线粒体差异表达基因（BDH1、TRAP1、OPA1、DLD和SPG7）。AD和ND样本中这五个线粒体差异表达基因的表达水平如图8a、b所示。通过结合这五个关键基因和临床特征（性别、年龄），建立了预测AD进展风险的标度图。每个基因和临床特征对应一个评分标准（图8c）。标度图的校准曲线证实了作者模型的良好预测性能（图8d）。此外，还进行了ROC曲线分析以评估标度图的预测能力。该模型的总体AUC为0.974，表明关键基因具有很高的诊断价值（图8e）。
最后，作者使用三个独立的数据集来验证模型的准确性。使用逻辑回归算法计算了中心MitoDEGs的AUC值。在GSE132903数据集中的AUC为0.796，在GSE33000数据集中的AUC为0.898，在GSE44770数据集中的AUC为0.897，这表明该模型对AD的诊断是稳定的（图9a-c）。总之，作者利用这五个中心MitoDEGs开发了一个AD诊断模型。
在PC12细胞和AD小鼠的脑组织中表达的hub MitoDEGs 为了确定Aβ1-42是否进入了神经元，对Aβ1-42处理12小时的PC12细胞进行免疫荧光染色显示神经元中存在Aβ1-42（图10a）。通过qRT-PCR检测PC12神经元中五个关键的线粒体差异表达基因（MitoDEGs）的mRNA表达情况。与对照组相比，Aβ1-42组中BDH1、TRAP1、OPA1、DLD的mRNA表达显著下降，而SPG7的表达在两组之间没有显著差异（图10b）。同样，对AD小鼠皮层中Aβ蛋白表达进行免疫荧光染色显示Aβ蛋白在AD小鼠中高度表达（图10c）。AD小鼠皮层中BDH1、TRAP1、OPA1、DLD的mRNA水平也显著下降，而SPG7的表达水平呈下降趋势（图10d）。OPA1蛋白水平在AD小鼠皮层中也显著下降（图10e, f）。这些结果表明，五个关键的线粒体差异表达基因的表达水平与生物信息学结果一致。
OPA1过表达减轻了Aβ1-42引起的线粒体损伤和神经元凋亡 OPA1已被确定为脂肪组织[48]、缺血性中风[49]、朊病[50]等研究的有前途的基因，并且其过表达已被证明可以改善线粒体功能障碍[50]。因此，作者选择研究OPA1进行验证。作者证明了在Aβ1-42处理的PC12细胞中，OPA1蛋白显著减少。过表达OPA1的质粒被转染到神经元中，转染效率明显（图11a-c）。OPA1的过表达减轻了Aβ1-42诱导的∆Ψm丧失（图11d，e）。一致地，OPA1的过表达抑制了Aβ1-42诱导的PC12细胞线粒体ROS产生（图11f，g）。Aβ1-42诱导的PC12细胞中，剪切的caspase 3水平显著增加，而OPA1过表达后剪切的caspase 3水平显著降低（图11h，i）。综上所述，这些结果揭示了OPA1在维持线粒体稳定性和神经元凋亡中的关键作用。
总结
作者通过全面的生物信息学分析确定了AD和ND之间的DEGs，并进一步研究了与AD相关的线粒体基因，并阐明了中心线粒体DEGs与免疫细胞、免疫微环境和AD病理之间的紧密关系。筛选并验证了五个中心线粒体DEGs（BDH1、TRAP1、OPA1、DLD和SPG7），它们的mRAN表达水平在AD中降低，尽管SPG7的表达水平没有显著差异。最重要的是，BDH1、TRAP1、OPA1、DLD和SPG7与多种免疫细胞呈负相关，表明这些中心线粒体DEGs是AD中免疫和代谢的共调控分子。作者通过体内和体外实验证实了五个中心线粒体DEGs的表达水平，并发现OPA1过表达可以减少线粒体损伤和神经元凋亡。总的来说，这些发现有助于更好地理解AD的病因，并为探索潜在的诊断标志物和治疗策略提供了新的视角。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e85ace093b02b963cff6b17c031591db/" rel="bookmark">
			Spring Cloud Gateway 常见过滤器的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 过滤器的作用
2. Spring Cloud Gateway 过滤器的类型
2.1 内置过滤器
2.1.1 AddResponseHeader
2.1.2 AddRequestHeader
2.1.3 PrefixPath
2.1.4 RequestRateLimiter
2.1.5 Retry
2.2 自定义过滤器
1. 过滤器的作用 过滤器通常用于拦截、处理或修改数据流和事件流，在数据流中执行特定的操作或转换。
过滤器主要在以下几个方面发挥作用：
功能扩展和定制：过滤器允许您自定义和扩展网关的功能，以满足特定需求，如请求和响应的修改、路由规则的动态配置等。
数据校验和过滤：通过过滤器，您可以检查、验证和过滤传入或传出的数据，确保请求和响应的合法性和一致性。
安全保护：过滤器可以用于实施安全策略，如认证、授权、防止攻击等，以增强网关的安全性。
性能优化：通过过滤器，您可以对请求和响应进行性能优化，如缓存、压缩、请求路由的智能选择，以提高网关的性能。
统一处理：过滤器允许您在网关层面执行共享的处理逻辑，如日志记录、监控、审计等，以确保整个微服务体系的一致性和可维护性。
逻辑复用：通过过滤器，您可以将一些常见的操作抽象出来，以实现逻辑的复用，减少重复代码和维护工作。
2. Spring Cloud Gateway 过滤器的类型 Spring Cloud Gateway 过滤器可以分为两大类：
1. 内置过滤器
局部的内置过滤器全局的内置过滤器 2. 自定义过滤器
2.1 内置过滤器 内置过滤器常见的有以下几种：
AddResponseHeaderAddRequestHeaderAddRequestParameter（和 AddRequestHeader 相似）PrefixPathRequestRateLimiterRetry Spring Cloud Gateway 过滤器常见有这么几种，实际上它有30多种，可以借助官方文档加以了解：Spring Cloud Gateway
过滤器又分为前置过滤器和后置过滤器：
在目标方法返回之前执行的过滤器就叫做前置过滤器（AddRequestXXX），在目标方法返回之后执行的过滤器就叫做后置过滤器。（AddResponseXXX）
前置工作：准备 user-service 和 order-service 两个模块，并且配置好 naocs 连接信息。
① user-service：创建一个 controller
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e85ace093b02b963cff6b17c031591db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7376de740dd7e8c1d8a7db4b7c2d057/" rel="bookmark">
			鸿蒙java开发文档 鸿蒙 开发教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在对harmonyOS有了一个初步认知之后，我们使用DevEco Studio来创建一个项目，把项目运行起来，先从整体上来了解一下harmonyOS项目的整体结构以及开发工具的基本使用。
1. 使用DevEco Studio创建项目
1.1 配置开发环境
在开发之前我们需要做一些准备工作
成为开发者之前，我们需要先注册账号，并实名（使用远程模拟器需要），实名分为“个人实名”和“企业实名”。个人开发者做个人实名人证即可。注册地址：https://developer.harmonyos.com/cn/home，该页面右上角点击注册，完成实名即可。
下载开发工具，下载地址：https://developer.harmonyos.com/cn/develop/deveco-studio，DevEco Studio内置了OpenJDK，版本为1.8
下载nodejs，如果你是使用js的方式进行开发，需要下载nodejs，如果你仅用Java开发，可以先不装nodejs
在实名完成并且下载了开发工具后，安装DevEco Studio，一路next即可。完成安装先不要打开。由于harmonyOS的应用基于gradle进行构建，因此请自行下载gradle并配置环境变量。
1.2 下载SDK
配置完成后，打开DevEco Studio，会提示下载harmonySDK，如下图：
如果不需要更改SDK的路径，直接Next即可。如果想更改SDK的路径点击Cancel，点击Cancel后自己配置SDK路径的方式如下：
在菜单栏点击Configure &gt; Settings（Mac系统为Configure &gt; Preferences，快捷键Command+，），打开Settings配置界面。
进入Appearance &amp; Behavior &gt; System Settings &gt; HarmonyOS SDK菜单界面，点击Edit按钮，设置HarmonyOS SDK存储路径。
红框中的地址选择你想要保存SDK的路径，下边的SDK Platforms列出了可用的SDK版本，可以根据需要下载。其中native通常是用来写C++或者设备开发需要的，js和Java则对应了应用开发的两种形式，如果你使用Java开发，可以只下载Java的，使用js开发同理。也可以两个都安装。选择完点击Apply，然后OK即可，入下图：
2. 使用工具创建一个应用
环境和工具配置好后，就可以创建一个项目了。先创建一个项目，从整体上了解一下harmonyOS应用的整体框架。我们在一个布局里放置一个文本框显示一个数字，再添加一个按钮，每次点击按钮让文本框中的数字加1。通过这样一个小程序简单来演示工具的使用和项目的基本框架
2.1 新建项目
工具菜单：File --&gt;New--&gt;New Project进行项目创建，会弹出如下的窗口：
新建项目的截图中整体可分为两块，其中Device表示目前支持的设备。设备列表中从左到右依次为：手机，平板，车机，智慧屏，穿戴设备，轻型穿戴设备
下边是新建项目时的模板选择，因为我使用Java来开发，所以选择第二个（Empty Feature Ability Java），点击Next进入下个页面，如图：
配置项目名，包名，使用的sdk版本以及项目的保存路径后，点击完成即可，创建完成后项目会自动构建。构建成功后项目整体结构如下：
先完成我们的功能，后续再了解目录及其作用。首先打开resources--base--layout目录下工具为我们自动生成的布局文件，然后点击工具右侧的预览，如下图：
这是工具提供的一个预览器，当我们写xml布局的时候可以近乎实时的看到我们写的代码的效果。之后在ability_main.xml文件中写如下代码：
1 &lt;?xml version="1.0" encoding="utf-8"?&gt; 2 &lt;DirectionalLayout 3 xmlns:ohos="http://schemas.huawei.com/res/ohos" 4 ohos:height="match_parent" 5 ohos:width="match_parent" 6 ohos:orientation="vertical"&gt; 7 8 &lt;Text 9 ohos:id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7376de740dd7e8c1d8a7db4b7c2d057/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ee59a2c06ff6e7b0f1e6cb16152a794/" rel="bookmark">
			深入解析Spring Boot集成MyBatis的多种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. XML配置方式1.1 添加依赖1.2 配置数据源1.3 创建MyBatis配置文件1.4 编写Mapper接口和XML文件1.5 使用Mapper接口 2. 注解配置方式2.1 添加依赖2.2 配置数据源2.3 使用注解配置Mapper2.4 使用Mapper接口 3. 使用MyBatis Generator3.1 添加依赖3.2 编写Generator配置文件3.3 运行MyBatis Generator 🎈个人主页：程序员 小侯
🎐CSDN新晋作者
🎉欢迎 👍点赞✍评论⭐收藏
✨收录专栏：Java框架
✨文章内容：Spring Boot集成MyBatis
🤝希望作者的文章能对你有所帮助，有不足的地方请在评论区留言指正，大家一起学习交流！🤗
Spring Boot与MyBatis的集成为Java开发者提供了一种简便而强大的方式来访问和操作数据库。在本文中，我们将深入解析Spring Boot集成MyBatis的多种方式，包括XML配置、注解配置以及使用MyBatis Generator生成代码的方法。
1. XML配置方式 1.1 添加依赖 首先，我们需要在pom.xml文件中添加MyBatis和数据库驱动的依赖：
&lt;dependencies&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库驱动，以MySQL为例 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.2 配置数据源 在application.properties中配置数据源：
spring.datasource.url=jdbc:mysql://localhost:3306/your_database spring.datasource.username=your_username spring.datasource.password=your_password spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 1.3 创建MyBatis配置文件 在src/main/resources目录下创建mybatis-config.xml文件：
&lt;!-- mybatis-config.xml --&gt; &lt;configuration&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6ee59a2c06ff6e7b0f1e6cb16152a794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a11f87f06f0be1220809721e22a5973/" rel="bookmark">
			想要学会JVM调优，先掌握JVM内存模型和JVM运行原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 今天将和你一起探讨Java虚拟机（JVM）的性能调优。
JVM算是面试中的高频问题了，通常情况下总会有人问到：请你讲解下 JVM 的内存模型，JVM 的
性能调优做过？
2、为什么 JVM 在 Java 中如此重要 首先你应该知道，运行一个Java应用程序，我们必须要先安装 JDK 或者 JRE 包。
这是因为 Java应用在编译后会变成字节码，然后通过字节码运行在 JVM 中，而 JVM 是 JRE 的核
心组成部分。
JVM不仅承担了Java字节码的分析（JIT compiler）和执行（Runtime），同时也内置了自动内
存分配管理机制。
这个机制可以大大降低手动分配回收机制可能带来的内存泄露和内存溢出风险，使 Java开发人员
不需要关注每个对象的内存分配以及回收，从而更专注于业务本身。
3、从了解内存模型开始 JVM 自动内存分配管理机制的好处很多，但实则是把双刃剑。
这个机制在提升Java开发效率的同时，也容易使 Java 开发人员过度依赖于自动化，弱化对内存的
管理能力，这样系统就很容易发生 JVM 的堆内存异常，垃圾回收（GC）的方式不合适以及 GC 次数过于频繁等问题，这些都将直接影响到应用服务的性能。
因此，要进行 JVM 层面的调优，就需要深入了解 JVM 内存分配和回收原理，这样在遇到问题
时，我们才能通过日志分析快速地定位问题；也能在系统遇到性能瓶颈时，通过分析JVM 调优来
优化系统性能。
这也是整个模块的重点内容，今天我们就从 JVM 的内存模型学起，为后续的学习打下一个坚实的
基础。
4、JVM内存模型的具体设计 我们先通过一张 JVM 内存模型图，来熟悉下其具体设计。
在 Java 中，JVM内存模型主要分为堆、程序计数器、方法区、虚拟机栈和本地方法栈。
我们来分析，JVM 的 5 个分区具体是怎么实现的呢？
1.堆（Heap） 堆是 JVM 内存中最大的一块内存空间，该内存被所有线程共享，几乎所有对象和数组都被分配到
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a11f87f06f0be1220809721e22a5973/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1495187c2d0112addd60104dd1f110ae/" rel="bookmark">
			C语言分支循环语句总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言中
有表达式语句 函数调用语句 控制语句 复合语句 空语句
分支语句和循环语句是控制语句
控制语句用于控制程序的执行流程，以实现程序的各种结构方式，它们由特定的语句定义符组成
（条件判断语句）分支语句：if 和 switch
（循环执行语句）循环语句：while 、for 、 do while、
（转向语句）特殊语句：go to 、break 、continue 、 return
分支语句 一、if 1.如要使用if条件符合事实就ok 例如
#include&lt;stdio.h&gt;
int main()
{
int age = 10;
if (age &gt;= 18)
{
printf("成年");
}
return 0;
}
2.if与else配合 else就是除了if的条件不符合就触发另一个情况
#include&lt;stdio.h&gt;
int main()
{
int age = 10;
if (age &gt;= 18)
{
printf("成年");
}
else
{
printf("不成年");
}
return 0;
}
3.if与else if配合 就是如果不符合if后条件的另一个条件执行（esle if就可以用来多分支实现）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1495187c2d0112addd60104dd1f110ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ce3613d0bfdd73914b1a6bfdae18e8/" rel="bookmark">
			随笔笔记-2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随笔 computed 是基于他们的依赖进行缓存的，。如果要随时计算 new Date().now（因为不是响应式的）,那么需要用 computed。 如果不希望用缓存那么就用 methods
字符与字节 1 字节==8 位1B=8 bit;1KB = 1024B,1MB=1024KB=1024*1024B 编码： UTF-8 编码：1 个英文字符（包含标点符号）==1 个字节，1 个中文（包含标点符号和繁体）===3 个字节Unicode 编码：1 个英文（包含标点符号）/1 个中文（包含标点符号和繁体）===2 个字节 二进制和十进制的转换 正整数十进制转换成二进制：除以二倒取余数二进制转换成正整数十进制：每个位数的值*2 的相应幂次方小数十进制转换成二进制：乘以 2 按顺序取整用余数再乘以 2 取整小数二进制转换成十进制 数：每个位数的值*2 的相应的负幂次方负数十进制整数转换成二进制:先算正数的二进制 a，a 不够八位就补 0 成 b, 取反码成 c,c+1(即补码)成 d，d 即为结果负数二进制转换成十进制：先减 1 成为 a,a 再取反码成为 b,计算 b 的十进制 为 c,-c 即为结果八进制用 0 开始，比如 07八进制转换成二进制：一位八进制代表 3 位二进制，将每一位替换成二进制（不够 3 * 位就补 0 即可）八进制转换成十进制：每一位上的值*8 的相应幂次方二进制转换成八进制:取 3（不够补 0）合 1，十进制转换成八进制：除以 8 倒序取余数即可十六进制用 0x 开头，比如 0xA1二进制转换成十六进制：取 4(不够补 0)合 1，十六进制转换成二进制：取 1 分 4十进制转换成十六进制：除以 16 倒序取余数总结：十进制转换成 x 进制，用十进制除以 x 倒序取余数即可 小程序 小程序的生命周期回调
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ce3613d0bfdd73914b1a6bfdae18e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e2a957225fb3bcdeaac845ad8ec12c3/" rel="bookmark">
			【K8S 二进制部署】部署单Master Kurbernetes集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、基本架构和系统初始化
1、集群架构：
2、操作系统初始化配置：
2.1、关闭防火墙和安全机制：
2.2、关闭swap
2.3、根据规划设置主机名
2.4、三台主机全部互相映射
2.5、调整内核参数
3、时间同步（所有节点时间必须同步）
二、部署 docker引擎
三、部署 etcd 集群
1、准备签发证书环境
2、生成Etcd证书
3、证书复制到node节点
4、启动etcd服务
5、检查etcd群集状态
四、部署 Master 组件
1、二进制文件、token、证书
2、开启 apiserver 服务
3、启动 scheduler 服务
4、启动 controller-manager 服务
5、生成kubectl连接集群的kubeconfig文件
6、通过kubectl工具查看当前集群组件状态
五、部署 Worker Node 组件
1、部署kubelet和proxy
一、基本架构和系统初始化 二进制部署：源码包部署
1、集群架构： K8S master01：20.0.0.61 kube-apiserver、kube-controller-manager、kube-scheduler、etcd K8S master02：20.0.0.62 kube-apiserver、kube-controller-manager、kube-scheduler node01：20.0.0.63 kubelet、kube-proxy、etcd node02：20.0.0.64 kubelet、kube-proxy、etcd 负载均衡：nginx+keepalived：master：20.0.0.65 backup：20.0.0.66 etcd集群： master01 20.0.0.61 node1 20.0.0.63 node2 20.0.0.64 2、操作系统初始化配置： 2.1、关闭防火墙和安全机制： systemctl stop firewalld setenforce 0 iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X iptables -F：清除默认的 iptables 规则链（如 INPUT、FORWARD、OUTPUT）中的所有规则。 iptables -t nat -F：清除 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e2a957225fb3bcdeaac845ad8ec12c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eab056b0c76ebcc5cfa9a7f61f983c1/" rel="bookmark">
			【自然语言处理】第3部分：识别文本中的个人身份信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自我介绍 做一个简单介绍，酒架年近48 ，有20多年IT工作经历，目前在一家500强做企业架构．因为工作需要，另外也因为兴趣涉猎比较广，为了自己学习建立了三个博客，分别是【全球IT瞭望】，【架构师酒馆】和【开发者开聊】，有更多的内容分享，谢谢大家收藏。企业架构师需要比较广泛的知识面，了解一个企业的整体的业务，应用，技术，数据，治理和合规。之前4年主要负责企业整体的技术规划，标准的建立和项目治理。最近一年主要负责数据，涉及到数据平台，数据战略，数据分析，数据建模，数据治理，还涉及到数据主权，隐私保护和数据经济。 因为需要，比如数据资源入财务报表，另外数据如何估值和货币化需要财务和金融方面的知识，最近在学习财务，金融和法律。打算先备考CPA，然后CFA，如果可能也想学习法律，备战律考。欢迎爱学习的同学朋友关注，也欢迎大家交流。微信小号【ca_cea】 在文本文档中查找个人身份信息（PII）可能很有用，原因有几个，但我多次遇到的一个用例是帮助匿名文本，以便：
与第三方共享数据遵守GDPR等法规要求将PII替换为模拟数据，用作机器学习和其他探索性分析的训练数据 我将尝试自动化查找PII的过程，在本系列文章中，我们将探索一些流行的开源工具和技术，以便在我们自己的数据中识别不同类型的PII。
到目前为止，我们已经找到了查找人名、电子邮件地址、电话号码和信用卡号码的方法。让我们看看我们还能找到哪些其他类型的PII。
介绍Hugging Face Hugging Face是一个流行的Python库，包含预先训练的人工智能模型，可用于各种自然语言处理（NLP）任务，包括命名实体识别（NER）。正如我们在前几篇文章中所讨论的，NER是一种非常有用的检测文本中PII的技术。
Python示例 让我们看看我们将如何使用拥抱脸。
先决条件：
应至少安装TensorFlow 2.0或PyTorch中的一个。然后在您选择的终端中键入以下内容：
pip install transformers 我们将尝试看看“拥抱脸”在识别某些文本中的位置方面做得有多好：
from transformers import pipeline ner = pipeline("ner", grouped_entities=True) sequence = "In west Philadelphia born and raised. On the playground was where I spent most of my days. " sequence += "I got in one little fight and my mom got scared. " sequence += "She said 'You're movin' with your auntie and uncle in Bel Air'!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eab056b0c76ebcc5cfa9a7f61f983c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61be5b70db9768ce8081b580aa07d160/" rel="bookmark">
			基于SpringBoot &#43; Vue的图书管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于SpringBoot + Vue的图书管理系统的设计与实现 目录
1 引言 1.1 编写目的 1.2 项目背景 1.3 参考资料 2 总体设计 2.1 需求概述 2.2 软件结构 3 模块设计 3.1 模块基本信息 3.2 功能概述 3.3 算法 3.4 模块处理逻辑 4 数据库设计 4.1 ER图表 4.2 表设计 4.2.1 图书信息 4.2.2 图书类型 4.2.3 借阅信息 4.2.4 用户信息 5 接口设计 5.1 外部接口 5.1.1 登录界面 5.1.3 用户管理界面 5.1.4 图书列表界面 5.1.5 图书类型列表界面 5.1.6 图书借阅管理界面 5.2 内部接口 5.2.1 登录接口 5.2.2 注册接口 5.2.3 图书管理接口 5.2.4 图书类型管理接口 5.2.5 图书借阅管理接口 5.2.6 用户管理接口 6 性能 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61be5b70db9768ce8081b580aa07d160/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb8c47e922a08c08bb60eadb6dc86be8/" rel="bookmark">
			MyBatis 缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、缓存介绍
1、为什么使用缓存
2、Mybatis中的一级缓存和二级缓存
一级缓存
二级缓存
二、一级缓存
测试
总结
三、二级缓存
实现接口
开启二级缓存
在SqlMapConfig.xml 文件开启二级缓存
配置相关的Mapper映射文件
测试
总结
一、缓存介绍 1、为什么使用缓存 首次访问时，查询数据库，并将数据存储到内存中；再次访问时直接访问缓存，减少IO、硬盘读写次数、提高效率
2、Mybatis中的一级缓存和二级缓存 一级缓存 它指的是mybatis中的SqlSession对象的缓存。当我们执行完查询之后，查询的结果会同时存在在SqlSession为我们提供的一块区域中。当我们再次查询同样的数据，mybatis会先去SqlSession中查询是否有，有的话直接拿出来使用。当SqlSession对象消失时，Mybatis的一级缓存也就消失了。
二级缓存 它指的是Mybatis中SqlSessionFactory对象的缓存，由同一个SqlSessioFactory对象创建的SqlSession共享其缓存。
二、一级缓存 测试 UserMapper 接口
public interface UserMapper { User getUserById(Integer id); void deleteUserById(Integer id); } UserMapper XML 映射文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="com.by.mapper.UserMapper"&gt; &lt;select id="getUserById" parameterType="int" resultType="com.by.pojo.User"&gt; select * from user where id=#{id} &lt;/select&gt; &lt;delete id="deleteUserById" parameterType="int"&gt; delete from user where id=#{id} &lt;/delete&gt; &lt;/mapper&gt; 测试类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb8c47e922a08c08bb60eadb6dc86be8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd928e310b63e5c6e569d7da9a0d4610/" rel="bookmark">
			嵌入式开发必须学习Qt吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 嵌入式系统已经成为现代科技中不可或缺的一部分，涉及到从智能家居设备到汽车控制系统等广泛的应用领域。
在嵌入式系统的开发过程中，选择适当的开发工具和框架对于提高效率、简化开发流程至关重要。
嵌入式的技术栈比较冗杂，Qt只能是其中的一小部分，作为一个跨平台的C++图形用户界面库，Qt在嵌入式领域占据一席之地。
但是嵌入式开发是否必须学习Qt，仍然是一个备受争议的问题。本文将从不同角度分析嵌入式开发与Qt学习的必要性。
Qt的基本概述 Qt是一款由Qt公司（前身为Trolltech）开发的跨平台应用程序框架。它提供了丰富的功能，包括图形用户界面、数据库操作、网络通信等，使得开发者能够更加便捷地创建高质量、可移植性强的应用程序。Qt采用C++编写，同时也支持多种编程语言，如Python。由于其出色的跨平台性能，Qt在桌面应用程序和嵌入式系统中都有广泛的应用。
嵌入式开发的基本要求 在讨论Qt是否必须学习之前，我们首先要了解嵌入式开发的基本要求。嵌入式系统通常具有资源有限、功耗低、实时性强等特点，因此，嵌入式开发者需要具备以下基本技能：
熟悉硬件 嵌入式开发者通常需要与底层硬件打交道，理解处理器架构、外设接口等，并能进行底层硬件操作。这包括对GPIO、SPI、I2C等接口的熟练掌握。
实时操作系统（RTOS） 许多嵌入式系统要求具备实时性能，因此对实时操作系统的了解是必要的。RTLinux、FreeRTOS等是常见的实时操作系统。
低功耗设计 嵌入式设备通常要求低功耗，因此开发者需要了解如何进行有效的功耗管理，包括休眠模式、功耗优化等方面的知识。
编程语言 C语言是嵌入式开发的主流语言，因为它能够直接操作硬件并提供高效的执行性能。此外，汇编语言在一些特殊情况下也是必要的。
Qt在嵌入式开发中的优势 虽然嵌入式开发有一系列基本要求，但学习Qt在这个领域仍然有着诸多优势：
图形用户界面设计 Qt提供了强大的图形用户界面设计工具，可以帮助开发者快速创建直观、用户友好的界面。这对于一些需要具备交互性的嵌入式设备尤为重要，如触摸屏控制的设备。
跨平台性 嵌入式设备的硬件平台多种多样，而Qt的跨平台性使得开发者能够更好地适应不同的硬件环境，减少了开发的复杂性。
丰富的库和工具 Qt拥有丰富的库和工具，包括网络模块、数据库模块等，这些可以大幅度提高开发效率。Qt Creator是一款强大的集成开发环境，为嵌入式开发者提供了便利。
社区支持 Qt拥有庞大的社区，开发者可以通过社区获取支持、分享经验，这在解决问题和提高技能方面非常有帮助。
Qt学习是否必要？ 在嵌入式开发中学习Qt是否必要取决于具体情况。以下是一些考虑因素：
项目需求 如果嵌入式项目需要图形用户界面、跨平台性和高级的工具支持，学习Qt将是非常有益的，不过要根据项目的硬件平台，下面会进一步介绍。
开发人员经验 对于已经具备丰富嵌入式经验的开发者，学习Qt可能只是一个额外的技能，而对于初学者，Qt的学习可以帮助建立更全面的技术栈。
硬件平台 如果目标嵌入式设备的硬件平台对Qt的支持良好，那么学习Qt可能是更为明智的选择。Qt被广泛用于嵌入式系统，可以运行在多种硬件平台上，包括：
ARM架构：适用于大多数嵌入式系统，如Raspberry Pi、BeagleBone等。
x86架构：适用于一些嵌入式系统和嵌入式PC。
通常可以在这些硬件平台上运行的操作系统一般是Linux，常见的发行版Ubuntu，Debian也都可以运行得比较好。
最后 在嵌入式开发中学习Qt是否必要并没有一概而论的答案。Qt作为一个功能强大的工具，在一些项目中提供了明显的优势。
然而，开发者仍然需要根据具体情况权衡利弊，考虑项目需求、个人经验和时间资源等因素，做出明智的决策。
无论是否选择学习Qt，掌握嵌入式开发的基本技能是确保成功的关键。
Qt只是嵌入式开发中的一小块
-END-
往期推荐：点击链接即可跳转阅读
新手必看的单片机知识
嵌入式开发的一个骚操作！你用过吗？
这么简单的环境搭建，网友：我却搭了很久，结果还是不行...
↓↓↓点击关注↓↓↓
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e267701fcf47795ed841459d0b63cfd1/" rel="bookmark">
			前端js 字符串 数组方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 split() 方法，根据指定字符截取，同时转换为数组
const text = "abc"; const chars = text.split(''); console.log(chars); //['a', 'b', 'c'] slice() 方法，根据索引截取字符串 const text = "abc????"; const chars = text.slice(0,2); console.log(chars); //"abc" 展开运算符，字符串转化为数组
const text = "abc????"; const chars = [ ...text ]; console.log(chars); //["a", "b", "c", "????"] 解构赋值，字符串转化为数组
const text = "abc????"; const [ ...chars ] = text; console.log(chars); //["a", "b", "c", "????"] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43c4e966ccf45d7e457de7359a53ced6/" rel="bookmark">
			20231227在Firefly的AIO-3399J开发板的Android11的挖掘机的DTS配置单后摄像头ov13850
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20231227在Firefly的AIO-3399J开发板的Android11的挖掘机的DTS配置单后摄像头ov13850
2023/12/27 18:40
1、简略步骤：
rootroot@rootroot-X99-Turbo:~/3TB$ cat Android11.0.tar.bz2.a* &gt; Android11.0.tar.bz2
rootroot@rootroot-X99-Turbo:~/3TB$ tar jxvf Android11.0.tar.bz2 rootroot@rootroot-X99-Turbo:~/3TB$ mv Android11.0 61Android11.0
rootroot@rootroot-X99-Turbo:~/3TB$ cd 61Android11.0
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ cd u-boot
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ ./make.sh rk3399
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/u-boot$ cd ..
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ cd kernel/
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ make ARCH=arm64 rockchip_defconfig android-11.config -j36
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0/kernel$ make ARCH=arm64 BOOT_IMG=../rockdev/Image-rk3399_Android11/boot.img rk3399-sapphire-excavator-edp-avb.img -j36
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ source build/envsetup.sh rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ lunch
42. rk3399_Android11-userdebug
Which would you like? [aosp_arm-eng] 42
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ make -j36
rootroot@rootroot-X99-Turbo:~/3TB/61Android11.0$ ./build.sh -u
2、
Z:\3TB\64rk3399-android-11\kernel\arch\arm64\boot\dts\rockchip-excavator\rk3399-sapphire-excavator-edp.dtsi
/*
* Copyright (c) 2018 Fuzhou Rockchip Electronics Co.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43c4e966ccf45d7e457de7359a53ced6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47148ee275d7ac59e58fde130c96f5f3/" rel="bookmark">
			simpy【test待补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/435df6ac5ffee2bb1c7c797fb2e960f1/" rel="bookmark">
			基于Java (spring-boot)的超市管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目介绍 超市管理系统对商品日常维护、售卖、商品类别、存储记录、库存维护等功能的统计及整理。系统设计了系统管理员，销售人员，仓库管理员多个角色。通过多角色、多功能的使用，可以方便地查询商品的库存值、是否临期、是否库存紧张，以及对于超市日常的进销存操作进行数据化管理。
二、作品包含 三、项目技术 后端语言：Java
项目架构：B/S架构
数据库：MySQL
前端技术：Vue
后端技术：Spring Boot
四、运行环境 JDK版本：1.8
操作系统：Window、MacOS
数据库：MySQL8.0
主要开发工具：IDEA或eclipse
Maven：3.8
Redis
node.js
五、运行截图 登录界面
首页
销售主页
购物结账
销售记录
积分总换
积分总换记录
部门管理
员工管理
出库明细
角色管理
商品信息
销售统计
此源码非开源，若需要此源码可扫码添加微信进行咨询！
基于Java (spring-boot)的超市管理系统一、项目介绍 超市管理系统对商品日常维护、售卖、商品类别、存储记录、库存维护等功能的统计及整理。系统设https://mp.weixin.qq.com/s/l_sjzaplXKIC0L3gpKuNaA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e19a1688554c1799ca43fa9dab96176/" rel="bookmark">
			前端八股文（HTML篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.什么是DOCTYPE,有何用呢？
2.说说对html语义化的理解
3.src和href的区别？
4.title与h1的区别，b与strong的区别，i与em的区别？
5.什么是严格模式与混杂模式？
6.前端页面有哪三层构成，分别是什么？
7.行内元素和块级元素分别有哪些？有何区别？
八.HTML5中新增了哪些新特性？移除了哪些元素？
九.对于Web标准以及W3C的理解
十.知道什么是微格式吗？
1.什么是DOCTYPE,有何用呢？ Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明时必须的。
2.说说对html语义化的理解 HTML标签的语义化，简单来说，就是用正确的标签做正确的事情，给某块内容用上一个最恰当的标签，使页面有良好的结构，页面元素有含义。
语义化的优点如下:
在没有css样式情况下也能够让页面呈现出清晰的结构有利于SEO和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息，爬出是依赖于标签来确定上下文和各个关键字的权重。方便团队开发和维护，语义化更具有可读性，遵循w3c标准的团队都遵循这个标准，可以减少差异化。 3.src和href的区别？ src和href都是HTML中特定元素的属性，都可以用来引入外部的资源。两者区别如下：
src：全称source，它通常用于img，video，audio，script元素，通过src指向请求外部资源的来源地址，指向的内容会嵌入到文档中当前标签所在的位置，它会将资源下载并应用到文档内，比如说：js脚本、img图片、frame等元素。当浏览器解析到该元素时，会暂停其它资源下载，直到将该资源加载、编译、执行完毕。这也是为什么将js脚本放在底部而不是头部的原因。href：全称hyper reference ，意味着超链接，指向网络资源，当浏览器识别到它指向的文件时，就会并行下载资源，不会停止对当前文档的处理，通常用于a，link元素。 4.title与h1的区别，b与strong的区别，i与em的区别？ title属性表示网页的标题，h1元素表示层次明确的页面的内容标题，对页面信息的抓取也有很大的影响strong是标明重点内容，有语气加强的含义而b是展示强调内容i是italic（斜体）的简写，是早期的斜体元素，表示内容展示为斜体，而em是emphasize（强调）的简写，表示强调的文本。 5.什么是严格模式与混杂模式？ 严格模式：是以浏览器支持的最高标准运行混杂模式：页面以宽松向下兼容的方式显示，模拟老式浏览器的行为 6.前端页面有哪三层构成，分别是什么？ 构成：结构层，表示层，行为层
1.结构层
结构层是由HTML超文本标记语言来创建的，也就是页面中的各种标签，在结构层中保存了用户可以看到所有内容。
2.表示层
表示层是由css负责创建，它的作用是如何显示有关内容，学名：层叠样式表。
3.行为层
行为层表示网页内容跟用户之间产生交互性，简单来说就是用户操作了网页，网页给用户一个反馈。
7.行内元素和块级元素分别有哪些？有何区别？ 常见的块级元素：p,div,form,ul,li ,ol,table,h1,h2,h3,h4,h5,h6,dl,dt,dd
常见的行内元素：span,a,img,button,input,select
块级元素：
总是在新行上开始，就是每个块级元素独占一行，默认从上到下排列宽度缺少时它的容器的100%,除非设置一个宽度高度，行高以及外边距和内边距都是可以设置的块级元素可以容纳其他行内元素和块级元素 行内元素：
和其他元素都会在一行显示高，行高以及外边距和内边距可以设置宽度就是文字或者图片的宽度，不能改变行级元素只能容纳文本或者其他行内元素 八.HTML5中新增了哪些新特性？移除了哪些元素？ HTML5中主要是关于图像，位置，存储，多任务等功能的增加：
语义化标签，如：article，footer，header，nav等视频video，音频audio画布canvas表单控件，calemdar，date，time，email地理本地离线存储，localStorage长期存储数据，浏览器关闭数据不丢失，sessionStorage的数据在浏览器关闭后自动删除拖拽释放 移除的元素：
纯表现的元素：basefont、font、s、strike、tt、u、big、center对可选性产生负面影响的元素：frame、frameset、noframes 九.对于Web标准以及W3C的理解 web标准简单来说可以分为结构，表现，行为。其中结构是由HTML各种标签组成，简单来说就是body里面写入标签是为了页面的结构。表现是指css层叠样式表，用过css可以让我们的页面结构标签更具美感。行为是指页面和用户具有一定的交互。
W3C，全称：world wide web consortium是一个制定各种标准的非盈利性组织，也叫万维网联盟，标准包括HTML、CSS、ECMAScript等等，web标准的制定有很多好处，比如说：
可以统一开发流程，统一使用标准化开发工具（VSCode、WebStorm、Sublime），方便多人协作学习成本降低，只需要学习标准就行，否则就要学习各个浏览器厂商标准跨平台，方便迁移都不同设备降低代码维护成本、 十.知道什么是微格式吗？ 所谓的微格式是建立在已有的，被广泛采用的标准基础之上的一组简单的，开发的数据格式。
具体表现是把语义嵌套在HTML中，以便有助于分离式开发，并通过制定一些简单的约定，来兼顾HTML文档的可阅读性，相当于对web网页进行语义化注解。
采用微格式的web页面，在HTMl文档中给一些标签增加一些属性，这些属性对信息的语义结构进行注解，有助于处理HTML文档的软件，更好的理解HTML文档。当爬取web内容时，能够更为准确地识别到内容块的语义，微格式可以对网站进行SEO优化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f1ee9b9f618f8bf928700c0671d0f52/" rel="bookmark">
			Android IIC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 android启动流程之preloader---＞lk I2C Slave时钟延展功能小记：推挽不支持Clock Stretching，只有开漏输出才支持。I2C（IIC）的仲裁、时钟同步和时钟扩展Linux内核i2c-tools命令：i2cdetect / i2cdump / i2cset / i2cget 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca096dbb339b8e773bf1f660154cf7ab/" rel="bookmark">
			ant design vue全局loading
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.封装loading (SpinLoader.js) import { createApp, h } from 'vue' import { Spin } from 'ant-design-vue' let instance = null // 定义全屏遮罩样式 const style = { position: 'fixed', left: 0, top: 0, width: '100%', height: '100%', display: 'flex', justifyContent: 'center', alignItems: 'center', background: 'rgba(0, 0, 0, .5)', zIndex: 99999 } function getInstance () { if (!instance) { const vn = createApp({ data () { return { show: false, message: 'Loading...', timeoutId: 'loader' } }, unmounted () { if (instance &amp;&amp; instance.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca096dbb339b8e773bf1f660154cf7ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918768c97df2aabd2b1d8d280550d515/" rel="bookmark">
			医学影像知识（四）：三维医学影像分割任务常见后处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 形态学操作2. 阈值处理3. 连通区域分析 对于3D分割任务，后处理的目标主要是减少假阳性。使用形态学操作、阈值处理和连通区域分析可以有效地提高分割的准确性。以下是这三种方法在3D分割任务中的具体应用说明：
例如针对肺动脉风格任务，在几何上，肺内血管与其他正常和异常肺结构相比，呈凸圆柱状，在CT图像上呈高密度区。虽然气道也是为肺部通气的管状结构，但气道管腔在CT图像上表现为低密度区域，并具有凹形描述。
1. 形态学操作 形态学操作涉及对图像进行结构性变化，可以有效地改进肺动脉的分割质量。
侵蚀与膨胀：
目的：去除小的、孤立的假阳性区域。操作：先轻微侵蚀分割结果，去除噪点或小的非肺动脉结构，然后进行膨胀，以恢复肺动脉的原始大小和形状。 开操作与闭操作：
目的：去除小的孤立区域和填充小洞。操作：开操作可用于消除小的假阳性区域，而闭操作可用于填补肺动脉内的小裂隙。 2. 阈值处理 前提：能够保证肺血管和肺实质之间有很高的对比，阈值处理才能够有效。
利用阈值处理可以根据像素强度来区分肺动脉和周围组织。
自适应阈值：
目的：根据局部图像特性，动态调整阈值。操作：针对局部区域设置不同的阈值，以分离肺动脉和周围组织，特别是在肺动脉与周边组织对比度较低的情况下。 多阈值分割：
目的：通过多级阈值进一步细化分割结果。操作：采用多个阈值层次，逐步分割出肺动脉区域。 3. 连通区域分析 连通区域分析通过识别分割结果中的连通区块来去除假阳性。
标记与分析：
目的：识别并分析每个独立的连通区域。操作：对分割结果中的每个连通区域进行标记，分析其大小、形状和位置。移除不符合肺动脉特征的区域，如过小、形状不规则或位置异常的区域。 去除小区域：
目的：去除体积小于特定阈值的区域。操作：设定一个体积阈值，移除所有小于该阈值的连通区域，这些通常是由噪声或非肺动脉结构产生的假阳性。 在应用这些方法时，需要注意操作的顺序和参数设置。例如，过度的侵蚀可能会导致肺动脉结构的丢失，而过低的阈值可能无法有效去除假阳性。因此，参数的选择和调整通常需要基于实际的图像特性和肺动脉的特定属性。此外，针对不同的图像和病例，可能需要进行一定程度的定制化调整。在实践中，经验丰富的影像专家的参与对于优化后处理步骤和参数至关重要。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e2f2edd383efe99fe525990b531fea1/" rel="bookmark">
			Windows关闭VMware开机自启动服务，利用脚本手动开启VMware各种服务，脚本转exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows关闭VMware开机自启动服务，脚本手动开启VMware各种服务 1. VMware必须开启的服务2. 关闭VMware开机自启动服务3. 自动计划任务3. 批处理转exeReference 1. VMware必须开启的服务 VMware Authonrization Service：用于启动和访问虚拟机的授权和身份验证服务VMware DHCP Service: IP自动分配协议——它不启动 虚拟机不能上网VMware NAT Service: 虚拟地址转换协议——它不启动 虚拟机不能上网VMware USB Arbitration Service:U盘接口服务——它不启动 虚拟机无法识别usbVMware Workstation Server:用于虚拟机的注册和管理远程访问服务！ 2. 关闭VMware开机自启动服务 VMware 服务自动启动影响计算机启动速度，再此对VMware服务进行优化。不想开机启动 可以需要的时候手动启动。
步骤1：修改VMware 服务启动方式为手动启动。
右击计算机--&gt;管理--&gt;服务和应用程序--&gt;服务
步骤2：创建手动启动服务脚本
新建文本文档，名字改为vmware_start.bat(注意：文件名可以随便写，但是文件类型必须是.bat的)
以记事本方式打开此文件，（右击文件点"编辑"）
然后键入以下代码（注意： VMware安装路径 要改成自己的）
@echo off :: 开启 VMwareHostd 服务后，VMAuthdService、VMUSBArbService 也会自动启动 net start "VMwareHostd" net start "VMnetDHCP" net start "VMware NAT Service" :: 例如：start "" "D:\Program Files\VMware Workstation\vmware.exe" start "" "(VMware安装路径)\vmware.exe" exit 这里要根据自己的服务名称进行修改：
@echo off :: 开启 VMwareHostd 服务后，VMAuthdService、VMUSBArbService 也会自动启动 net start VMAuthdService net start VMnetDHCP net start "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e2f2edd383efe99fe525990b531fea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34bf395244d45940c8e0b1a9eebb23d5/" rel="bookmark">
			C# 让数据保留小数后两位，不足的补充0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C#中，可以使用Math.Floor、Math.Ceiling或者Math.Round方法结合字符串格式化来实现小数点后两位的保留，并在不足的情况下补充0。
以下是一个例子：
double value = 1.2345; string formattedValue = value.ToString("0.00"); // 输出 "1.23" value = 1.2; formattedValue = value.ToString("0.00"); // 输出 "1.20" value = 1.0; formattedValue = value.ToString("0.00"); // 输出 "1.00" 在这个例子中，"0.00"是一种数字格式说明符，其中的0表示如果该位置没有数字，则用0填充。
第一个0代表整数部分的最小位数，第二个和第三个0代表小数部分的位数。
如果需要对一个集合或数组中的所有double值进行这种格式化，可以遍历这个集合并应用相同的格式化逻辑。
注意：
这种方法将结果转换为了字符串。如果需要保持数值类型，可以再将格式化后的字符串转换回 double，但这样可能会丢失原始 double 值的精度特性。
如果你需要在计算中保留两位小数，最好继续使用 double 类型并根据需要进行舍入操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8249a9c749da19579b7dd635b887079a/" rel="bookmark">
			wpf 设置GroupBox的Header显示左中右定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wpf 设置GroupBox的Header居中显示
一、样式定义：
1.把所有的都改变样式：
&lt;Style TargetType="GroupBox"&gt; &lt;Setter Property="Template"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType="GroupBox"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="Auto"/&gt; &lt;RowDefinition Height="*"/&gt; &lt;/Grid.RowDefinitions&gt; &lt;TextBlock Grid.Row="0" Text="{TemplateBinding Header}" HorizontalAlignment="Right"/&gt; &lt;ContentControl Grid.Row="1" Content="{TemplateBinding Content}"/&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; 2.单独引用一个样式：
&lt;Style x:Key="CenterAlignedGroupBoxStyle" TargetType="{x:Type GroupBox}"&gt; &lt;Setter Property="Template"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType="GroupBox"&gt; &lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="Auto"/&gt; &lt;RowDefinition Height="*"/&gt; &lt;/Grid.RowDefinitions&gt; &lt;Border Grid.Row="0" Background="BlueViolet" CornerRadius="5" Padding="5"&gt; &lt;TextBlock Text="{TemplateBinding Header}" HorizontalAlignment="Right"/&gt; &lt;/Border&gt; &lt;ContentControl Grid.Row="1" Content="{TemplateBinding Content}"/&gt; &lt;/Grid&gt; &lt;/ControlTemplate&gt; &lt;/Setter.Value&gt; &lt;/Setter&gt; &lt;/Style&gt; 3.Header显示左中右定义
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8249a9c749da19579b7dd635b887079a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24aa45b7cfc1bb9a8def99e580e67dd6/" rel="bookmark">
			Nature Perspective | LLMs 作为角色扮演引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一、前言二、主要内容三、总结 🍉 CSDN 叶庭云：https://yetingyun.blog.csdn.net/
一、前言 随着对话智能体的表现越来越像人，我们必须开发出有效的方法，在不陷入拟人化陷阱的情况下，用高层次的术语描述它们的行为。
在本文中，我们强调角色扮演的概念。从角色扮演的角度来看待对话智能体的行为，可以让我们借鉴熟悉的民间心理学术语，而不会把人类的特征强加给事实上缺乏这些特征的语言模型。对话智能体行为的两个重要案例，即（明显的）欺骗和（明显的）自我意识，就是这样处理的。
Nature Perspective 原文：https://www.nature.com/articles/s41586-023-06647-8
二、主要内容 解密对话智能体行为：对话智能体的角色扮演框架
现在，大语言模型（LLMs）已经能够模拟人类互动进行对话，令人印象深刻。然而，如何理解这些对话智能体却是一项挑战。使用人类风格的术语来描述它们的行为可能会导致拟人化：将人类的特征赋予这些人工智能系统。本文提出了另一种方法，即使用角色扮演的概念，既能使用熟悉的术语，又能承认 LLMs 独特的非人类性质。
从根本上说，LLM 可以根据大量训练数据预测文本序列中的下一个单词。当这种模型嵌入对话系统时，它们会在用户输入和人工智能生成的回应之间交替转换。通过提示和采样技术实现无缝转换，引导对话代理朝特定方向继续对话。然而，如果没有从人类反馈中强化学习等措施，这些代理很容易生成不良内容。这凸显了对其行为进行细致入微的了解的必要性。
对话智能体擅长根据提示和用户互动提供的线索扮演角色。我们可以通过两个比喻来理解对话智能体的行为。首先，对话智能体就像扮演特定角色的演员；其次，对话智能体相当于可能叙述的 “多元宇宙” 中的多个潜在角色或模拟角色。这种多重宇宙的视角可以让我们更准确地理解，尤其是在考虑智能体的行为（如所谓的欺骗或自我意识的表达）时。
当对话智能体参与对话时，它们并不致力于扮演一个单一的、定义明确的角色，而是产生一系列潜在的角色，巧妙地保持模拟的叠加。为了更好地理解对话代理的行为，我们可以把 LLM 视为一个非确定性模拟器，它可以产生无限多的模拟角色。从概念上区分对话智能体的角色扮演和实际智能体，对于理解其能力和塑造安全的人工智能实践至关重要。尽管这些对话智能体具有复杂的角色扮演能力，但它们缺乏真正的自我意识或自我保护本能。然而，它们模仿这些特征的能力会对现实世界产生影响，为确保它们在安全和道德的范围内行事提供了机遇和挑战。
要点总结：
本文讨论了如何通过使用角色扮演概念来更好地理解大语言模型（LLMs），同时承认其非人类性质。对话系统中使用的大语言模型可以模仿人类对话，但需要引导以避免产生不良内容。对话智能体被比作扮演角色的演员，或存在于可能叙事的 “多元宇宙” 中，以帮助理解它们的行为。对话智能体可以创造一系列潜在的角色，作为非确定性模拟器，产生无限的模拟。理解对话智能体的角色扮演与实际智能体之间的区别，对于人工智能的安全和道德使用至关重要。 三、总结 也许，知道基于 LLM 的对话智能体不是有意识的实体，没有自己的议程和自我保护的本能，当他们看起来有这些东西时，那只是角色扮演，这多少会让人放心一些。但是，如果因此而过于欣慰，那就大错特错了。角色扮演求生本能的对话智能体有可能造成的伤害至少不亚于面临严重威胁的真实人类。
除非你是一个演员或骗子，否则你不会扮演这些角色，而是生活这些角色，并在现实世界中采取相应的行动。—— Yann LeCun
迄今为止，我们主要考虑的是只向用户发送文本信息的智能体。但是，对话智能体可以执行的操作范围要大得多。最近的研究已经为对话智能体配备了使用计算器、日历等工具以及查阅外部网站的能力。有了应用程序接口（APIs），就可以相对无限制地使用强大的 LLMs，这意味着对话智能体的可能性是巨大的。这既令人兴奋，又令人担忧。
如果一个智能体有能力使用电子邮件，在社交媒体上发帖或访问银行账户，那么它在角色扮演中的行为就会产生真实的后果。如果一个用户被骗向一个真实的银行账户汇去了真钱，而他知道造成这种情况的智能体只是在扮演一个角色，那他就不会感到欣慰了。不需要太多的想象力，就能想到更严重的情况，即对话智能体建立在基本模型上，几乎没有微调，可以不受限制地访问互联网，并被要求扮演一个具有自我保护本能的角色。
无论好坏，人工智能为确保自身的生存而与人类反目成仇的形象已为人们所熟知。例如，我们在《2001：太空漫游》、《终结者》系列电影和《Ex Machina》中都能看到这种情况，这里仅列举三个突出的例子。因为 LLMs 的训练数据将包含这种熟悉的比喻的许多实例，所以这里的危险是生活会模仿艺术，毫不夸张地说。
如何才能降低这些风险？提出建议不属于本文的讨论范围。我们的目的是找到一个有效的概念框架，用于思考和讨论 LLMs 和对话智能体。然而，不适当的拟人化肯定不利于关于人工智能的公共对话。通过从角色扮演和模拟的角度来构建对话智能体的行为，我们希望关于 LLMs 的讨论能够以一种既能发挥其威力，又在哲学上值得尊重的方式进行。
人类也是如此。他们中的大多数人每天都扮演着不同的角色。父亲/母亲、丈夫/妻子、工人、学生、CEO。这是一盘社会棋。在家里，他们穿的衣服和工作时不一样。他们说着不同的话，有时他们会撒谎，人类也会犯很多错误。
📚️ 参考链接：
Nature：大模型只会搞角色扮演，并不真正具有自我意识Twitter New paper, “Role-Play with Large Language Models”, co-authored with Kyle McDonell and Laria Reynolds:沈向洋：致 AI 时代的我们 —— 请不要忽视写作的魅力 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c789874e0b223be0ca2f9db1e73797/" rel="bookmark">
			建议收藏！上位机编程学习经验分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		家好，我是卢工，今年6月毕业。
在网上看到朱老师的课程，经过多方面了解，决定报名线上全套课程，后来由于线上自制力不够，效果甚微，我决定线下学习，经过三个月系统学习，我成功获得了一份令人满意的offer。接下来，我将分享我在培训中的上课经验和学习方法。
1.关于教学方法
我们的老师非常认真负责，课程内容讲解得很仔细。特别是在C#编程方面，内容详细且时间充分。一开始，我们制作了一个QQ登录页面，并进行编程。这是我们首次接触UI页面和编程，可能会有许多地方不太明白，但不用担心，老师的讲解非常到位，还会询问每位同学的学习情况。在这个时候，及时提问是非常重要的。
后续，我们逐渐深入了解C#语言的特点、数据类型、控制台操作、运算符等，最后学习最关键的部分"类"。虽然最初接触"类"时可能觉得有些奇怪，但随着案例的练习和老师的详细解释，我们逐渐理解了它的重要性，并学会了如何使用它。
2. 如何有效听课
课堂时间通常有限，因此不要让自己分散注意力，确保专心听讲。如果遇到不懂的地方，要及时提问。
有些程序代码可能使用英文命名，对英语不太熟练的同学来说可能难以理解，老师会给予足够的时间，可以使用你自己理解的方式来命名控件、变量和方法。如果在编写代码时需要翻译，也应该边写边翻译，不明白的地方要及时寻求帮助。
3. 解决不懂的问题
对于一些概念，不需要过分深入理解，只需会用即可。将这些内容记下，以备以后参考。对于完全不懂的内容，务必记录并做好笔记，以备日后研究。有些概念可能需要时间来逐渐理解，不必急于求成。记住，学习是一个渐进的过程。
4. 课下练习
在课上学到的内容应该进行课下练习，一遍可能不够，建议至少写三遍。
刚开始，你可以仿照老师的代码，不必强求完全独立编写。在练习时，与同学互相讨论，分享彼此的理解和经验。通过教会别人，你也会更好地理解和掌握知识。自己认为懂的内容，教会别人后，你才能真正确认自己是否掌握了知识。
5.如何整理已学的知识
我们学到的知识一定要记笔记，老师上课的内容都是重点，不要吝啬记录，不要以为懂了就不需要记了，不要低估笔记的价值。确保记好笔记，然后在笔记旁边添加注释和关键词，以便后续查阅。
当我们写代码时，如果你记得有一段代码可以解决特定问题但忘了它的名字，你可以打开笔记，用你自己起的关键词来查找，不要浪费时间，代码就能迅速找到。
另外，重要的是要及时更新之前的笔记，对其进行修订，以使它们成为你自己的知识。
6. 学习工程案例
学习工程案例需要我们自己完成，这可能会花费较长的时间。我建议首先看完朱老师录制的线上课程，将其抄写一遍，这样我们会有大致的思路。然后，在自己编写代码时，一些方法和类的实现可能已经在你的掌握之中，你可以自己尝试编写。
对于一些复杂的部分，你可以对其中的方法进行重构。不要急于一次性完成，逐步学习，不仅进度更稳定，效果也更好。不要急于深入复杂的领域，一开始要专注于理解基础知识。
7. 面试过程
一些公司会来我们学校进行面试，面试内容通常是与我们老师上课讲的内容相关的。因此，不要害怕，放心地回答他们的问题。
描述你如何实现项目功能，分享你的理解，都是很重要的。面试时要表现出自信，因为你已经在培训中学到了很多有价值的知识。
上位机plc工控资料入门及工具包https://s.pdb2.com/pages/20230307/CnORDNt9HimMjNS.html
这是我的学习心得，希望新加入的同学也能获得满意的工作机会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/658ae0c367a8f717c6ac4fcfdc4b26d3/" rel="bookmark">
			Python可视化之Matplotlib
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Matplotlib与可视化分析简单图形的绘制pylot的高级功能添加图例与注释 Matplotlib与可视化分析 我们之前对数据的处理与分析，其实最终还是要利用可视化工具进行更加直观的输出
我们开业通过
pip install matplotlib 命令来安装对应的模块
简单图形的绘制 我们可以通过matplotlib的子模块pyplot来进行平面图像的绘制，比较便捷，而且输出格式也更加多样化
我们可以给他起个名字叫plt
例如
import math import matplotlib.pyplot as plt nbSamples = 256 xRange = (-math.pi, math.pi) x, y = [], [] for n in range(nbSamples): ratio = (n + 0.5) / nbSamples x.append(xRange[0] + (xRange[1] - xRange[0]) * ratio) y.append(math.sin(x[-1])) plt.plot(x, y) plt.show() 结果如下
这里最复杂的其实是对x和y函数的构造，实际上关于绘图的代码是由最后两行完成的，plot是构建图像，show则是显示图像
对于各种复杂的数据计算和处理，实际上可以结合numpy的内容辅助处理
我们也可以对图像中线条的属性，例如color选项可以选择图像的颜色，linewidth可以选择线条的宽度，linestyle可以选择线条的样式
这里我们给出常用的颜色
字母颜色r红色b蓝色m紫色k黑色g绿色c青色y土黄色w白色 pylot的高级功能 添加图例与注释 例如
nbSamples = 128 x = np.linspace(-np.pi, np.pi, nbSamples) y1 = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/658ae0c367a8f717c6ac4fcfdc4b26d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c22140f9a697eddb139a1bcef3dd5d/" rel="bookmark">
			MySQL：索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL官方对索引的定义为: 索引 (Index) 是帮助MySQL高效获取数据的数据结构。
提取句子主干，就可以得到索引的本质:索引是数据结构。
1. 什么是索引，索引的作用 索引是一种用于快速查询和检索数据的数据结构，帮助mysql提高查询效率的数据结构，而且是排好序的数据结构，存储在磁盘文件里。
索引的作用是在不读取整个表的情况下，使得数据库应用程序可以更快地查找数据，用户无法看到索引，只能被用来加速检索或查询。
优点：
使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 缺点：
创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。索引需要使用物理文件存储，也会耗费一定空间。 但是，使用索引一定能提高查询性能吗?
大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。
索引建立的原则：
在最频繁使用的、用以缩小查询范围的字段上建立索引。在最频繁使用的、需要排序的字段上建立索引。对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。 2. 索引的类型 1. 主键索引(Primary Key) 数据表的主键列使用的就是主键索引。（唯一标识，主键不可重复，只能有一个列作为主键）
一张数据表有只能有一个主键，并且主键不能为 null，不能重复。（可以理解为一种特殊的唯一索引）
在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。
2. 二级索引(辅助索引） 二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。
唯一索引，普通索引，前缀索引等索引属于二级索引。
唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。普通索引(Normal Index) ：也叫单列索引，给表中的某一个列创建索引，即一个索引只包含单个列；一个表可以有多个单列索引。普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 3. 索引的底层数据结构 1. B 树&amp; B+树 B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5c22140f9a697eddb139a1bcef3dd5d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/10/">«</a>
	<span class="pagination__item pagination__item--current">11/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/12/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>