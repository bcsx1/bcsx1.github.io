<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14cafd52763d9470bfe5e84289c37871/" rel="bookmark">
			kubectl常用的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
安装 kubectl
一、命令自动补全
二、常用命令
1、查看所有pod列表
2、查看RC和service列表
3、显示Node的详细信息
4、显示Pod的详细信息, 特别是查看Pod无法创建的时候的日志
5、 根据yaml创建资源, apply可以重复执行，create不行
6、基于nginx.yaml定义的名称删除指定资源
7、删除所有包含某个label的pod和service
8、删除默认命名空间下的所有 Pod
9、执行pod命令
10、查看容器日志
11、查看节点 labels
12、重启pod
三、创建命令
四、查看和查找资源 五、删除资源 六、Pod常用操作 Kubernetes 是一种用于自动化部署、扩展和管理容器化应用程序的开源平台。而 kubectl 则是 Kubernetes 的命令行工具，用于管理 Kubernetes 集群。
在本文中，我们将深入介绍 kubectl 的各种用法和功能。
安装 kubectl 要安装 kubectl，需要使用的操作系统的软件包管理器或者前往 Kubernetes 官方网站下载二进制文件。在安装之前，确保Kubernetes集群已经启动并正在运行。
一、命令自动补全 source &lt;(kubectl completion bash) #在bash中设置当前shell的自动补全，要先安装bash-completion包。 echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc 二、常用命令 1、查看所有pod列表 查看所有的pod列表，-n 后跟namespace，查看指定的命名空间
kubectl get pod kubectl get pod -n kube-system #查看指定的命名空间的pod ​kubectl get pod -owide #查看更详细的信息，比如pod 所在的节点 kubectl get pod --show-labels #获取pod 并查看pod 的标签 2、查看RC和service列表 查看RC和service列表， -o wide查看详细信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14cafd52763d9470bfe5e84289c37871/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/409ef7f50c66f08e53d909762e71acf4/" rel="bookmark">
			Python-Django毕业设计基于JAVA线上订餐系统（程序&#43;Lw)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该项目含有源码、文档、程序、数据库、配套开发软件、软件安装教程
项目运行
环境配置：
Pychram社区版+ python3.7.7 + Mysql5.7 + HBuilderX+list pip+Navicat11+Django+nodejs。
项目技术：
django + python+ Vue 等等组成，B/S模式 +pychram管理等等。
环境需要
1.运行环境：最好是python3.7.7，我们在这个版本上开发的。其他版本理论上也可以。
2.pycharm环境：pycharm都可以。推荐pycharm社区版;
3.mysql环境：建议是用5.7版本均可
4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
6.Navcat11：这个版本不限10/11/14/15都可以。；
Python-Django毕设帮助，指导，本源码(见文末)，调试部署
4.1运行环境 4.1.1硬件环境 开发本系统时，本人所使用的电脑带有酷睿i5的cpu,gtx 950m的显卡，4G的运行内存。
4.1.2软件环境 开发本系统时本人使用的是windows win 10的操作系统，使用了MySQL数据库管理工具，版本为5.0，JDK版本为1.8，开发工具为ECLIPSE , web容器使用的为ECLIPSE 自带的tomcat。
4.2系统实现 4.2.1系统功能模块 线上订餐系统，在系统首页可以查看首页、菜品信息、留言反馈、个人中心、后台管理等内容进行操作，如图4-1所示。
图4-1系统首页界面图
菜品信息；在菜品信息页面中可以查看菜品名称、菜品类型、图片、口味、价格、数量、预计时间、电话、详细地址、菜品简介等内容，可进行加入购物车、评论或收藏操作；如图4-2所示。
图4-2菜品信息界面图
会员注册；在会员注册页面中输入会员号、密码、姓名、邮箱、手机等内容进行注册操作，如图4-3所示。在个人中心页面中输入会员号、密码、姓名、性别、图片、邮箱、手机等内容，进行更新信息，并可以根据需要对我的收藏进行相应的操作，如图4-4所示。
图4-3会员注册界面图
图4-4个人中心界面图
4.2.2管理员功能模块 管理员登录，通过填写注册时输入的用户名、密码、选择角色进行登录，如图4-5所示。
图4-5管理员登录界面图
管理员登录进入线上订餐系统可以查看首页、个人中心、会员管理、菜品类型管理、菜品信息管理、购物车管理、订单信息管理、留言板管理、系统管理等信息进行详细操作，如图4-6所示。
图4-6管理员功能界面图
会员管理：在会员管理页面中可以对索引、会员号、姓名、性别、头像、邮箱、手机等内容进行详情、修改或删除等操作；如图4-7所示。
图4-7会员管理界面图
菜品类型管理；在菜品类型管理页面中可以对索引、菜品类型等内容进行修改或删除等操作；如图4-8所示。
图4-8菜品类型管理界面图
菜品信息管理：在菜品信息管理页面中可以对索引、菜品名称、菜品类型、图片、口味、价格、数量、预计时间、电话、详细地址等内容进行详情、修改、查看评论或删除等操作，如图4-9所示。
图4-9菜品信息管理界面图
购物车管理；在购物车管理页面中可以对索引、菜品名称、价格、数量、总价格、下单时间、会员号、姓名、手机等内容进行详情、修改或删除等操作；如图4-10所示。
图4-10购物车管理界面图
订单信息管理；在订单信息管理页面中可以对索引、订单编号、菜单列表、会员号、姓名、手机、总价格、下单时间、是否支付等内容进行详情、修改或删除等操作；如图4-11所示。
图4-11订单信息管理界面图
留言板管理；在留言板管理页面中可以对索引、用户名、留言内容、回复内容等内容进行详情、修改、回复或删除等操作；如图4-12所示。
图4-12留言板管理界面图
4.2.3会员后台功能模块 会员登录进入系统后台可以查看首页、个人中心、购物车管理、订单信息管理、留言板管理、我的收藏管理等内容进行详细操作，如图4-13所示。
图4-13会员后台功能界面图
购物车管理；在购物车管理页面中可以对索引、菜品名称、价格、数量、总价格、下单时间、会员号、姓名、手机等内容进行详情或删除等操作；如图4-14所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/409ef7f50c66f08e53d909762e71acf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f399b62b46749c9869853db952247ff/" rel="bookmark">
			ESPnet搭建记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESPnet 是一个端到端的语音处理工具包，主要专注于端到端的语音识别和端到端的文本转语音。ESPnet 使用chainer和pytorch作为主要的深度学习引擎，并遵循Kaldi风格的数据处理、特征提取/格式和配方，为语音识别和其他语音处理实验提供完整的设置。
系统环境信息：Ubuntu 18.04.4 LTS，CUDA Version 10.0.130，CUDNN Version 7.6.3,
1.安装vim
有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，这个时候就需要安装vim，可是当你敲apt-get install vim命令时，提示：
Reading package lists... Done Building dependency tree Reading state information... Done E: Unable to locate package vim 运行 apt-get update，然后执行 apt-get install -y vim
2.安装Anaconda
bash Anaconda3-5.2.0-Linux-x86_64.sh
然后一直按提示操作即可, 建议安装默认位置就不用配置环境变量了.
刷新环境变量 配置了环境变量并不会生效，需要刷新才会生效。
source ~/.bashrc 3.相关依赖安装
cmake3 用于某些扩展
sudo apt-get install cmake sox
sudo apt-get install sox libsndfile1-dev
sudo apt-get install libsndfile1-dev ffmpeg（安装时不需要，但在某些地方中使用）
sudo apt-get install ffmpeg flac（安装时不需要，但在某些地方中使用）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f399b62b46749c9869853db952247ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef3638e0cb3697ed1be80e4a4876efd/" rel="bookmark">
			python学习之10行代码制作炫酷的词云图（匹配指定图形形状）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、需要准备什么？二、代码实现（示例）三、读入数据四、结果展示五、修改词云颜色后的运行结果展示：总结 前言 想必大家有一个问题：什么是词云呢？
词云又叫名字云，是对文本数据中出现频率较高的“关键词”在视觉上的突出呈现，形成关键词的渲染形成类似云一样的彩色图片，从而一眼就可以领略文本数据的主要表达意思。
网页上有许多词云的效果图：
一、需要准备什么？ python代码运行需要安装第三方模块pillow（PIL）、matplotlib、jieba、wordcloud 和numpy
如果安装库有遇到问题，可以参见下面的解决办法，在windows上测试可用。
python学习之报错：ModuleNotFoundError: No module named ‘pandas‘解决方法
python学习之数据分析和图表的应用（第一部分）报错：ModuleNotFoundError: No module named ‘wordcloud’
二、代码实现（示例） 代码如下（示例）：
#导入matplotlib模块pyplot函数并使用as给函数起个别名plt import matplotlib.pyplot as plt import jieba #导入jieba分词模块 import wordcloud #导入词云图模块 from wordcloud import ImageColorGenerator import numpy as np #导入numpy模块 from PIL import Image #从PIL模块中导入Image函数 # 读取文本文件 text = open('elsa.txt','r').read() #elsa.txt可以改成自己的文件 cut_text = jieba.cut(text) #分词处理 word = ' '.join(cut_text) #以空格分割文本 #读取图片 pic = np.array(Image.open('aa.png')) image_colors = ImageColorGenerator(pic) #生成图片颜色中的颜色 wd = wordcloud.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef3638e0cb3697ed1be80e4a4876efd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7331173c6e308e3091c1743840f7316f/" rel="bookmark">
			软件开发基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、软件的概念
1、软件：是计算机系统中与硬件相互依存的部分，它包括程序、数据及相关文档的完整集合。其中
Ø 程序－是按照事先设计的功能和性能的要求执行的指令序列
Ø 数据－是使程序正常操纵信息的数据结构
Ø 文档－是程序开发、维护和使用有关的图文资料
2、软件分类（按功能划分）
Ø 系统软件：如操作系统、数据库管理系统、设备驱动程序等
Ø 支撑软件：协助用户开发软件的工具性软件，如微软可视化开发平台工具
Ø 应用软件：为特定目的服务的软件，如财务管理软件。
二、软件工程和软件开发
1、 软件工程
Ø 一系列完善的工程化原则。
软件工程是为经济地获得能够在实际机器上有效运行的可靠软件而建立和使用的一系列完善的工程化原则。
Ø 软件工程是开发、运行、维护和修复软件的系统方法。
1983年，IEEE（电气和电子工程师学会）作出定义，软件工程是开发、运行、维护和修复软件的系统方法。软件定义为：计算机程序、方法、规则、相关的文档资料以及在计算机上运行时所必须的数据。
Ø 主要思想是强调软件开发过程需要英语工程化的原则。
2、 软件的生存周期
按照软件工程的过程（plan, do,check, action）即软件规格说明、软件开发、软件确认，软件演进，进一步展开，软件的生存周期包括6个阶段
（1） 制定计划
（2） 需求分析
（3） 软件设计
（4） 程序编写
（5） 软件测试
（6） 运行和维护
3、 软件开发
开发阶段有三个相互关联的步骤组成，即设计、实现（编码）、测试。
三、各个阶段的目标和主要工作
制定计划
管理层面的内容。
Ø 制定待开发软件系统的总目标，给出它的功能、性能、可靠性以及接口等方面的要求；
Ø 研究完成该项软件任务的可行性，探讨解决问题的可能方案；
Ø 制定开发实施计划，可行性研究报告。
需求分析
对待开发软件提出的需求进行分析并给详细定义出
需求分析的目标：
Ø 是深入描述软件的功能和性能，确定软件设计的约束、软件同其它系统元素的接口细节，
Ø 分析阶段只确定软件系统要“做什么”，
Ø “怎么做’有后续的设计阶段完成。对算法的详细描述也是在设计阶段给出。
Ø 定义软件的其它有效性需求。
需求分析的任务：
Ø 通过与用户的合作，了解用户对待开发系统的要求；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7331173c6e308e3091c1743840f7316f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45a3d097fc0b23ebfe9711eead41e2a2/" rel="bookmark">
			基于卷积神经网络CNN的图片分类实现——附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
摘要：
1.卷积神经网络介绍：
2.卷积神经网络（CNN）构建与训练：
2.1 CNN的输入图像
2.2 构建CNN网络
2.3 训练CNN网络
3.卷积神经网络（CNN）的实际分类测试：
4.本文Matlab实验代码：
摘要： 使用Matlab自带的深度学习工具箱构建卷积神经网络（CNN）进行图片分类，以识别并分类手写数字为例。首先将大量的图片数据导入；然后给不同种类的图片打上对应的分类的标签，划分为训练集和测试集；构建CNN网络其中包括3层2维卷积和3个池化层，全连接层及分类层；调整好输入输出格式对CNN进行训练及测试；最后结果表明CNN可以有效的对手写数字图像进行分类。代码已做标准化处理，使用者可通过替换数据实现自己需要的功能。
1.卷积神经网络介绍： 卷积神经网络 (Convolutional Neural Network，CNN) 这一概念最早由 Yann Lecun 于 20 世纪 80 年代提出，是受到生物神经学中感受野的启发而发展起来的一种前馈神经网络结构模型。其作为一种有监督深度学习算法，端到端的数据处理模式，由于特征提取阶段不需要人工选择，而被广泛应用在各个领域的设备状态监测中。
2.卷积神经网络（CNN）构建与训练： 2.1 CNN的输入图像 本文CNN的输入图像如下：为1-9的手写数字，对应分类标签为1-9。
2.2 构建CNN网络 本文构建的CNN结构如下图所示：
图像输入层：用于指定图像大小，在本例中为 28×28×1。这些数字对应于高度、宽度和通道大小。数字数据由灰度图像组成，因此通道大小（颜色通道）为 1。对于彩色图像，通道大小为 3，对应于 RGB 值。卷积层：在三层卷积层中，第一层有8个3*3的卷积核，第二层有16个3*3的卷积核，第三层有32个3*3的卷积核。卷积层逐渐加深，不断提取输入图像的特征。批量归一化层批量归一化层对网络中的激活值和梯度传播进行归一化，使网络训练成为更简单的优化问题。在卷积层和非线性部分（例如 ReLU 层）之间使用批量归一化层，来加速网络训练并降低对网络初始化的敏感度。ReLU 层：批量归一化层后接一个非线性激活函数。最常见的激活函数是修正线性单元 (ReLU)。使用 reluLayer 创建 ReLU 层。最大池化层：卷积层（带激活函数）有时会后跟下采样操作，以减小特征图的空间大小并删除冗余空间信息。通过下采样可以增加更深卷积层中的滤波器数量，而不会增加每层所需的计算量。下采样的一种方法是使用最大池化，在此示例中，该矩形区域的大小是2全连接层：卷积层和下采样层后跟一个或多个全连接层。顾名思义，全连接层中的神经元将连接到前一层中的所有神经元。该层将先前层在图像中学习的所有特征组合在一起，以识别较大的模式。最后一个全连接层将特征组合在一起来对图像进行分类。因此，最后一个全连接层中的 OutputSize 参数等于目标数据中的类数。softmax 层： softmax 激活函数对全连接层的输出进行归一化。分类层：最终层是分类层。该层使用 softmax 激活函数针对每个输入返回的概率，将输入分配到其中一个互斥类并计算损失。 2.3 训练CNN网络 定义网络结构体后，指定训练选项。使用具有动量的随机梯度下降 (SGDM) 训练网络，初始学习率为 0.01。将最大训练轮数设置为 4。将数据分为训练集和测试集，对构建好的CNN进行训练，训练过程中的误差曲线如下：
3.卷积神经网络（CNN）的实际分类测试： 使用经过训练的网络预测验证数据的标签，并计算最终验证准确度。准确度是网络预测正确的标签的比例。在本例中，超过 99% 的预测标签与验证集的真实标签相匹配。
4.本文Matlab实验代码： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dde880f1403ece3a9300142e6dba47da/" rel="bookmark">
			【计算机毕业设计】在线考试系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、系统截图（需要演示视频可以私聊） 摘 要
本论文主要论述了如何使用JAVA语言开发一个在线考试系统，本系统将严格按照软件开发流程进行各个阶段的工作，采用B/S架构，面向对象编程思想进行项目开发。在引言中，作者将论述在线考试系统的当前背景以及系统开发的目的，后续章节将严格按照软件开发流程，对系统进行各个阶段分析设计。
在线考试系统的主要使用者分为管理员和学生，实现功能包括管理员：个人中心、学生管理、考试科目管理、考试成绩统计管理、试题管理、管理员管理、试卷管理、考试管理，学生：个人中心、考试科目管理、考试管理等功能。由于本网站的功能模块设计比较全面，所以使得整个在线考试系统信息管理的过程得以实现。
本系统的使用可以实现本在线考试系统管理的信息化，可以方便管理员进行更加方便快捷的管理。
关键词：在线考试系统；JSP技术；MYSQL数据库；
目 录
摘 要 1 绪论 1.1研究背景 1.2研究现状 1.3研究内容 2 系统关键技术 2.1 JSP技术 2.2 JAVA简介 2.3 MYSQL数据库 2.4 B/S结构 3 系统分析 3.1 可行性分析 3.1.1 技术可行性 3. 1. 2经济可行性 3. 1. 3操作可行性 3.2 系统性能分析 3.3 系统功能分析 3.4系统流程分析 3.4.1登录流程 3.4.2注册流程 3.4.3添加信息流程 3.4.4删除信息流程 4　系统设计 4.1系统概要设计 4.2系统结构设计 4.3系统顺序图设计 4.3.1登录模块顺序图 4.3.2添加信息模块顺序图 4.4数据库设计 4.4.1数据库E-R图设计 4.4.2数据库表设计 第5章 系统详细设计 5.1管理员功能模块 5.2学生功能模块 6 系统测试 6.1 测试定义 6.2 测试目的 6.3测试方案 （1）模块测试 （2）集成测试： （3）验收测试： 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dde880f1403ece3a9300142e6dba47da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23c034bc7ba28e13bf70064565876a91/" rel="bookmark">
			粒子群算法(PSO)优化的BP神经网络预测回归——附代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
摘要：
1.BP模型神经网络模型
2.粒子群优化算法（PSO）
伪代码实现
3.粒子群算法结合BP神经网络（PSO-BP）
4.程序运行结果
5.本文Matlab代码
摘要： BP神经网络是一种常见的多层前馈神经网络，本文通过粒子群算法(PSO)对BP神经网络的网络参数进行寻优，得到最优化的网络参数，并与未使用PSO的BP网络对同一测试样本进行预测，对比分析并突出PSO-BP的优越性。本文章代码可改性强，注释详细，替换输入与输出后即可满足不同的任务，实现自己想要的功能，适合新入门神经网络的同学学习。
1.BP模型神经网络模型 2.粒子群优化算法（PSO） 粒子群算法的思想源于对鸟群觅食行为的研究，鸟群通过集体的信息共享使群体找到最优的目的地。如下图，设想这样一个场景：鸟群在森林中随机搜索食物，它们想要找到食物量最多的位置。但是所有的鸟都不知道食物具体在哪个位置，只能感受到食物大概在哪个方向。每只鸟沿着自己判定的方向进行搜索，并在搜索的过程中记录自己曾经找到过食物且量最多的位置，同时所有的鸟都共享自己每一次发现食物的位置以及食物的量，这样鸟群就知道当前在哪个位置食物的量最多。在搜索的过程中每只鸟都会根据自己记忆中食物量最多的位置和当前鸟群记录的食物量最多的位置调整自己接下来搜索的方向。鸟群经过一段时间的搜索后就可以找到森林中哪个位置的食物量最多（全局最优解）。
在找到这两个最优值时,粒子根据如下的公式来更新自己的速度和新的位置
v[ ] 是粒子的速度，present[ ] 是当前粒子的位置。pbest[ ] 和 gbest[ ] 如前定义。rand() 是介于(0,1)之间的随机数。c1，c2是学习因子。通常c1=c2=2。
伪代码实现 For each particle
____Initialize particle
END
Do
____For each particle
________Calculate fitness value
________If the fitness value is better than the best fitness value (pBest) in history
____________set current value as the new pBest
____End
____Choose the particle with the best fitness value of all the particles as the gBest
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23c034bc7ba28e13bf70064565876a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daa736981024e64375516e071c9f8eda/" rel="bookmark">
			JavaScript鼠标拖动事件监听使用方法及实例效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先鼠标拖动事件需要与标签的draggable属性配合使用，在标签中设置draggable属性为true则表示允许拖动该元素
&lt;body&gt; &lt;!-- 设置draggable为true --&gt; &lt;div draggable="true"&gt;&lt;/div&gt; &lt;/body&gt; drag事件 鼠标拖动事件，当元素被拖动时该事件会持续重复触发，可以用于实时定位鼠标位置以让某元素跟随鼠标
&lt;body&gt; &lt;div draggable="true"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; let div = document.querySelector("div"); div.addEventListener("drag", (params) =&gt; { console.log("drag事件触发"); }) &lt;/script&gt; dragstart事件 当拖动开始时触发一次该事件，可以用于拖动前对元素进行一些预处理
&lt;body&gt; &lt;div draggable="true"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; let div = document.querySelector("div"); div.addEventListener("dragstart", (params) =&gt; { console.log("dragstart事件触发"); }) &lt;/script&gt; dragenter事件 当正在拖拽元素的鼠标进入监听元素时触发事件，需要注意的是此监听事件需要赋在被进入的元素上，事件源event指向被进入的元素，可以用于当拖拽鼠标位于某一元素时对该元素进行一些改变
&lt;body&gt; &lt;div style="background-color: blue;"&gt;&lt;/div&gt; &lt;div draggable="true"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; let div = document.querySelector("div"); div.addEventListener("dragenter", (e) =&gt; { console.log("dragenter事件触发"); e.target.style.backgroundColor = "green" console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daa736981024e64375516e071c9f8eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee531690a6da9c1728175483023f817c/" rel="bookmark">
			Windows Server 2019安装docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows Server 2019安装docker 实验环境：一台Windows Server 2016中文版，关闭防火墙，IP地址192.168.10.1/24 还需要一张网卡，需要连接外网，给Windows Server 2016下载更新文件 下载更新 sconfig #打开参数菜单 下载最新版的安装包，安装并重启 选择数字6，下载并安装更新，弹出黑色对话框后，选择A 让它下载更新并重启，此操作必须进行，否则后续安装会失败或者各种报错类似于linux各种软件版本依赖 打开powershell以管理员方式运行 由于Windows Server 2016中文版不支持安装的NuGet，需要使用命令将原有的Tls一级，修改成二级，才能安装NuGet服务 [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12; #修改成二级 安装NuGet服务 Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force #指定NuGet安装包最小版本 Install-Module -Name DockerMsftProvider -Force #安装docker模块 Install-Package -Name docker -ProviderName DockerMsftProvider -Force #安装docker包 注意：如果这一步没有安装成功的话，报错如下
去C盘下面找到这个路径，如果是空白的，需要下载补丁包
https://dockermsft.blob.core.windows.net/dockercontainer/docker-1-12-2-cs2-ws-beta.zip
以上是补丁包文件，把它下载下来后放入刚刚空白的文件夹下
然后重新运行上面的docker包就可以安装了 Restart-Computer -Force #安装完成后重启计算机生效 重启好了之后，打开powershell输入docker info docker version #查看docker版本 docker安装就完成了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b04f79803a9535696073c9c7af3191/" rel="bookmark">
			华为eNSP配置防火墙命令行放行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		防火墙命令行放行 三种区域: DMZ区域是非军事化区域，外网流量要先访问DMZ区域，DMZ从而进行更好的阻拦 trust区域是内部区域，俗称内网 untrust区域是外部区域，俗称外网 内网需要做安全策略才能访问外网，外网是不能访问内网的 准备工作: 所有设备修改名称 配置IP地址 防火墙默认阻挡所有流量通过
配置IP地址: LSW1配置: vlan 10 int vlan 10 undo shutdown port-group group-member eth0/0/1 eth0/0/2 port link-type access port default vlan 10 ​ AR1配置: int gi0/0/0 ip add 10.1.1.2 24 undo shutdown ​ int loopback 0 ip add 1.1.1.1 32 ​ FW1配置: vlan 10 int vlan 10 ip add 192.168.10.254 24 undo shutdown int gi1/0/2 portswitch #转换成二层接口 port link-type access port default vlan 10 undo shutdown ​ int gi1/0/1 ip add 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22b04f79803a9535696073c9c7af3191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e936f8cbfa9ddbca5d61155c92aad62d/" rel="bookmark">
			HJ54表达式求值【pyhon3】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定一个字符串描述的算术表达式，计算出结果值。
输入字符串长度不超过 100 ，合法的字符包括 ”+, -, *, /, (, )” ， ”0-9” 。
数据范围：运算过程中和最终结果均满足 ∣ v a l ∣ ≤ 2 31 − 1 |val| \le 2^{31}-1 ∣val∣≤231−1 ，即只进行整型运算，确保输入的表达式合法
输入描述 输入算术表达式
输出描述 计算出结果值
思路 通过栈对表达式求值是很经典的了。针对本题来说主要有三个步骤：
把输入的字符串表达式拆分成列表，作为中缀表达式存储把中缀表达式转换成后缀表达式计算后缀表达式 拆分成中缀表达式列表 刚开始做的时候想了蛮久的，首先是要思考怎么把运算数字提取出来，这一点很简单，其实就是判断连续的数字子串。牛客这个题库里有不少字符串问题的解决思路类似，但是后面发现还有处理算式中有负数的情况，卡了蛮久的。
代码1 初次做的时候老是发现新的问题，一步步改的，因此第一次实现的代码比较难看，以下是思路：
通过在运算符的左边或者右边加空格的形式，最后split(' ')得到结果。其中非括号的运算符左右两边都要加空格，(只需加在右边，)加在左边，这样便可以保证数字与运算符之间会存在一个空格第一步并没有考虑负数情形。事实上，本题算式中的负号判断可以只根据这一个标准：-号左边仍是运算符（其实只能是()），右边是数字。那么这个-和它右边的数字应当是构成一个负数的。故对于运算符是-时，做特殊判断。先处理第一个数就是负数的情形，再处理内部的。 #根据符号拆分中缀表达式 def divide_zhongzhui(S): L=[x for x in S] for i in range(len(S)): if L[i].isdigit()==False: if L[i] not in '()': if i==0 and L[0]=='-': #处理第一位数是负数的情况 msg=L[i] else: if L[i-1]=='( ': msg=L[i] else: msg=' '+L[i]+' ' L[i]=msg elif L[i]=='(': msg=L[i]+' ' L[i]=msg else: msg=' '+L[i] L[i]=msg return (''.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e936f8cbfa9ddbca5d61155c92aad62d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fe8ef6ac4af724277b76050243ef2a4/" rel="bookmark">
			QT多线程Qthread
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.回顾linux多线程
pthread_create( 函数指针); //通过函数指针，指明你这个线程需要完成的任务
2.QT中多线程的使用
原理：当你调用start方法开启一个线程的时候，run方法会被自动调用
第一步：创建一个子类继承QThread，然后重写QThread中的run()方法
virtual void QThread::run() //虚函数,线程的任务函数,创建线程需要完成的任务就靠它来实现
如何在QT工程中新增一个C++类
右键点击工程名--》add new--》选择C++--》C++类
第二步：创建子类对象，启动线程
void QThread::start(); 3.常用方法
(1)延时
[static] void QThread::sleep(unsigned long secs) //单位秒
[static] void QThread::msleep(unsigned long msecs) //毫秒
[static] void QThread::usleep(unsigned long usecs) //微秒
(2)终止线程 void QThread::terminate()
(3)回收线程
bool QThread::wait(unsigned long time = ULONG_MAX) //参数是超时时间
#include "mainwindow.h" #include "ui_mainwindow.h" MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); } MainWindow::~MainWindow() { delete ui; } //启动线程 void MainWindow::on_pushButton_clicked() { thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fe8ef6ac4af724277b76050243ef2a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/095798535fd64ad8b35ed6d817e46983/" rel="bookmark">
			c&#43;&#43;多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、多态的概念
多态的概念：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会
产生出不同的状态。
二、多态的定义及实现
2.1虚函数
虚函数：即被virtual修饰的类成员函数称为虚函数。
class Person { public: virtual void fun() { cout &lt;&lt; "Person::fun()" &lt;&lt; endl;} }; fun()就是虚函数
2.2虚函数的重写
虚函数的重写(覆盖)：派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的
返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。
class A { public: virtual void fun() { cout &lt;&lt; "A::fun()" &lt;&lt; endl; return nullptr; } }; class B :public A { public: virtual void fun() { cout &lt;&lt; "B::fun()" &lt;&lt; endl; return nullptr; } }; 虚函数重写的俩个例外：
（1）协变：基类与派生类返回值类型不同，基类返回值是基类对象的指针或者引用，子类返回值是子类对象的指针或者引用，称为协变
// 协变(基类与派生类返回值类型不同) // 基类返回基类对象的指针或引用，派生类返回派生类对象的指针或引用 class A { public: virtual A* fun() { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/095798535fd64ad8b35ed6d817e46983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d910963f0109ac4ecf9e26c54a9caaa2/" rel="bookmark">
			预处理【详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本期介绍🍖
主要介绍：#define如何定义宏，宏替换的规则，为什么宏定义时不要吝啬我们的括号，为什么宏的参数不能带有副作用，宏和函数的区别。还讲解了预处理符号#和##，#undef指令，众多条件编译指令，以及文件包含的方式，与如何解决文件的重复包含👀。
文章目录 一、预定义符号🍖二、#define🍖2.1 #define 定义标识符🍖2.2 #define 定义宏🍖2.2.1 宏应尽量多用括号🍖2.2.2 宏替换规则🍖2.2.3 带副作用的宏参数🍖2.2.4 宏与函数的对比🍖2.2.5 命名约定🍖 三、预处理操作符#和##🍖3.1 #的用法🍖3.2 ##的用法🍖3.3 嵌套使用宏🍖 四、#undef 指令🍖五、命令行定义🍖六、条件编译🍖七、文件包含🍖7.1 头文件被包含的方式🍖7.2 重复头文件包含的解决办法🍖 一、预定义符号🍖 C语言在设计之初就预先定义了下面这些可以使用，但不能修改的宏。
__FILE__：返回当前正在编译文件的文件名。__LINE__：返回当前的行号。__DATE__：返回文件编译日期。__TIME__：返回文件编译时间。__STDC__：如果编译器遵循ANSI C，其值为1，否则未定义。 下面就可以
二、#define🍖 2.1 #define 定义标识符🍖 大多数时候我会像这样#define MAX 100来使用#define，也就是定义一个数字常量。但如果你了解过#define的替换逻辑，就会发现它的用法可不仅于此。就譬如：
定义字符串常量：#define name "xiaoming"简化关键字：#define reg register替换语句：#define forever for(i = 0; i &lt; 10; i++) 注意：如果#define定义的内容过长可以换行继续写，但需要在存了最后一行外，每一行后面加一个反斜杠（续行符），如下所示。
#define DEBUG_PRINT printf("file:%s\tline:%d\t \ date:%s\ttime:%s\n" ,\ __FILE__,__LINE__ ,\ __DATE__,__TIME__ ) 2.2 #define 定义宏🍖 #define除了可以定义标识符之外，还有另外一种机制，可以像函数那样传递参数，这种实现被称为：宏或定义宏。
语法：#define name( parament-list ) stuff
其中name是宏名，parament-list是参数列表，需要用逗号隔开，stuff为宏体，也就是宏的内容。
注意：宏是把参数直接替换到宏内容中去的，与函数传递参数有本质的区别。函数在传递参数前会先把值求出来，然后在传递过去。可宏不是这样，参数是什么样，替换过去还是什么样。下面举个例子：
2.2.1 宏应尽量多用括号🍖 我们在定义宏的时候，应尽量不吝啬括号。为什么呢？要知道宏会把参数原封不动的替换到宏体中，这就导致了一问题的出现：如果参数中具有操作符，并且宏体中也有操作符，那么当参数替换完成后，可能就会因为操作符的优先级，而使得表达式的计算顺序达不到我们的预期。下面来举个例子：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d910963f0109ac4ecf9e26c54a9caaa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11c9ab9b5b145a724e34f7d0ed664b1a/" rel="bookmark">
			Pascal VOC 和 Microsoft COCO(MS COCO)(COCO2017&amp;COCO2014) 数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pascal VOC（Pascal Visual Object Classes）数据集 VOC数据集是目标检测/分割经常用的一个数据集，从05年到12年都会举办比赛
VOC数据集的格式
用于分割
Paslcal VOC 2012 用于分隔的数据集是由20个类+1个背景类
训练集1464张
val集 1449张
Microsoft COCO(Common Objects in Context)数据集 COCO是微软团队2014年发布的一个可以用来进行图像识别的数据集。
在MS COCO数据集上可以做多种任务
coco2017数据集共80个类，类别id号不连续，最大为90。 8w张图
COCO通过在Flickr上搜索80个对象类别和各种场景类型来收集图像，其使用了亚马逊的Mechanical Turk（AMT）
Image Captioning也是用的这个数据集
2014版本的coco dataset包括82,783 个训练图像、40,504个验证图像以及40,775个测试图像，270k的分割出来的人以及886k的分割出来的物体。
数据集有20G左右的图片和500M左右的标签文件。标签文件标记了每个segmentation+bounding box（即分割物+分割物的边界）的精确坐标，其精度均为小数点后两位。
MS COCO种类数要远比 PASCAL VOC多(VOC有的种类他都有)，每个类别标注的目标个数，COCO数据集也明显比VOC多。所以很多文章都会使用COCO数据集进行预训练，再用迁移学习方法在VOC上进行再训练。而且如果想训练自己的数据集的话，一般也会基于COCO数据集预训练好的权重去做迁移学习
test集是不放出来的 标注格式
coco的segmentation格式 iscrowd=0的时候，表示这是一个单独的物体，轮廓用Polygon(多边形的点)表示，iscrowd=1的时候表示两个没有分开的物体，轮廓用RLE编码表示，比如说一张图片里面有三个人，一个人单独站一边，另外两个搂在一起（标注的时候距离太近分不开了），这个时候，单独的那个人的注释里面的iscrowing=0,segmentation用Polygon表示，而另外两个用放在同一个anatation的数组里面用一个segmention的RLE编码形式表示
[poly]的形式是这样的[x1,y1,x2,y3,x3,y3,...,xn,yn]
mask不论是polygon还是rle都会被转换成rle再做iou
COCO相关数据格式可视化
Mask_RCNN/inspect_data.ipynb at master · matterport/Mask_RCNN (github.com)
COCO的格式示例 可以看到它这里是images和annotations是分开的
即annotations里面可能好几项都是同一个图片的框
{ # "info": 'coco',	#optional # "license": ['none'],	#optional "images": [ { "height": 224, #int "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11c9ab9b5b145a724e34f7d0ed664b1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55a6ad92720e3adfef2d272cb4bd31c4/" rel="bookmark">
			在 VMware Workstation 中配置固定 IP 地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 系统环境：CentOS 7.6 1. 为什么需要固定 IP 地址？ 虚拟机中的 Linux 操作系统，其 IP 地址是通过 DHCP 服务 获取的。
DHCP ：动态获取 IP 地址，即每次重启设备后都会获取一次 IP 地址，所以 IP 地址也会频繁变更。
原因1：办公电脑 IP 地址变化无所谓，但是我们要远程连接到 Linux 系统，如果 IP 地址经常变化，我们就要频繁修改适配，这就很麻烦。
原因2：远程终端配置了虚拟机 IP 地址和主机名映射，如果 IP 频繁更改，也需要频繁更新映射关系。 综上所述，为了避免不必要的麻烦，我们需要把 IP 地址固定下来，不在变化。
2. 配置步骤 配置固定 IP 需要 2 个大步骤：
① 在 VM Workstation 配置 IP 地址网关和网段（IP 地址的范围）
② 在 Linux 系统中手动修改配置文件，固定 IP
2.1 修改虚拟机配置 ① 在 Windows 终端中查看 VMware Network Adapter VMnet8 的 IPv4 地址，并且记住它，后面会用到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55a6ad92720e3adfef2d272cb4bd31c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cae4f913184dcb2c173b1991edd8ef3/" rel="bookmark">
			要买的书籍记录 - 机器人相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 待买的书籍：
机器人学：机器视觉与控制 MATLAB算法基础 - Peter Corke 已买：
SLAM 14讲计算机视觉中的多视图几何概率机器人 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/294b83534596fd5b985661f7c07c6d19/" rel="bookmark">
			用keras搭建LSTM神经网络的经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 神经网络作为目前较为流行的一种机器学习模型，在很多领域都发挥着非常重要的作用，个人觉得神经网络也非常重要，无论是你工作还是科研。在工作中可以利用tensorflow等工具快速的搭建一个神经网络模型是一项很必要的技能，在科研中学会使用神经网络模型，熟悉A+B=C的写作套路，会让你写文章贼快。尤其神经网络，其实大部分文章都是这几种常见的网络结构，例如CNN，GNN, GCN, LSTM， RNN等。所以说学会神经网络模型真的是超级无敌重要。
LSTM经验 大家知道LSTM神经网络是处理时间序列的机器学习模型，而且要比RNN要优秀，但是在使用LSTM时要注意什么呢？接下来我就给大家介绍以下自己踩过的坑，因为我主要用的是tensorflow,所以我主要讲的是tensorflow的经验，当然也有一些基础的，供大家参考：
（1）在大家决定用LSTM做预测时，一定要注意数据集和自己的用用场景，当你的数据集里面时间间隔不连续而且数据差别太大的时候，LSTM网络的效果可能不是很好，大家可以看一下下面的数据
第三列和第四列代表经纬度，当你像预测这些经纬度的时候，用这个数据集就不太好，你设置的步长在稍微大一点（有的同学可能认为，步长越长，数据越多，精度越高）但是数据差别大的时候，就会造成数据质量太差。下面这个数据集的预测效果就会不错，大家可以自行对比一下：
（2）也就是要适当选取步长，也就是LSTM网络层中的input_shape参数的值
(3) 由于LSTM处理的数据时时间序列，所以不建议大家在划分数据集的时候直接采用python自带的包，因为训练LSTM的时候要保证数据时间的连续性，比如有100个数据，你可以把前90个做训练集，后10个做测试，但是你不能把中间90个做训练，前面5个和后面5个做测试。
结语 目前，本人遇到的坑就这三个，在大家实际应用的时候一定要根据应用场景和数据考虑考虑自己到底该用什么模型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab6653cd8f32bc885f582e3d7b87ce20/" rel="bookmark">
			【总线】SPI 通信协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SPI总线协议概述
串行与并行通信
SPI通信介绍
SPI的工作原理
时钟
从属选择
多个从机
常规方法
菊花链方法
MOSI 和 MISO
SPI 数据传输的步骤
SPI 的优缺点
优点
缺点
文章参考
SPI总线协议概述 SPI是许多不同设备使用的通用通信协议。例如，SD卡读卡器模块、RFID卡读卡器模块和 2.4GHz无线发射器/接收器都使用 SPI 与微控制器进行通信。
电子设备之间的通信就像人与人之间的通信。双方都需要说同一种语言。在电子学中，这些语言被称为通信协议。常见的通信协议有SPI、UART、I2C等。
首先，我们将从一些关于电子通信的基本概念开始，然后详细解释SPI的工作原理。
SPI，I2C和UART比USB，以太网，蓝牙和WiFi等协议慢得多，但它们更简单，使用更少的硬件和系统资源。SPI、I2C 和 UART 非常适合微控制器之间以及不需要传输大量高速数据的微控制器和传感器之间的通信。
串行与并行通信 电子设备通过设备之间物理连接的电线发送数据位来相互通信。设备之间通过传递位来进行通信，位是二进制的，只能是1或0。通过电压的快速变化，位从一个设备传输到另一个设备。在5 V工作系统中，0V的电压值为0，而5V的电压值为1。
数据位可以并行或串行形式传输。在并行通信中，数据位同时发送，每个数据位都通过单独的导线发送。下图显示了字母“C”在二进制（01000011）中的并行传输：
在串行通信中，位通过单根线逐个发送。下图显示了字母“C”在二进制（01000011）中的串行传输：
SPI通信介绍 SPI的一个独特优势是数据可以不间断地传输。可以在连续流中发送或接收任意数量的位。使用I2C和UART，数据以数据包形式发送，限制为特定数量的位。开始和停止条件定义了每个数据包的开始和结束，因此数据在传输过程中会中断。
通过SPI进行通信的设备处于主从关系中。主机是控制设备（通常是微控制器），而从机（通常是传感器、显示器或存储芯片）从主机获取指令。SPI最简单的配置是单个主机，单从系统，但一个主机可以控制多个从机（下面将详细介绍）。
MOSI（主输出/从输入）：主机将数据发送到从机的线路。
MISO（主输入/从输出）：从机将数据发送到主机的线路。
SCLK（时钟）：时钟信号的线。
SS/CS（从机选择/芯片选择）：主机选择线，用于选择要将数据发送到哪个从机。
所需的线
2
最大速率
高达10Mbps
同步或异步
同步
串行或并行
串行
主机的最大个数
1
从机的最大个数
理论上没有限制
在实践中，从机的数量受到系统负载电容的限制，这降低了主机精确切换电压电平的能力。
SPI的工作原理 时钟 时钟信号将主机的数据位输出与从器件的位采样同步。每个时钟周期传输一位数据，因此数据传输的速度由时钟信号的频率决定。SPI通信始终由主站启动，因为主机配置并生成时钟信号。
设备共享时钟信号的任何通信协议都称为同步。SPI 是一种同步通信协议。还有一些不使用时钟信号的异步方法。例如，在UART通信中，双方都设置为预配置的波特率，该波特率决定了数据传输的速度和时间。
SPI中的时钟信号可以使用时钟极性和时钟相位属性进行修改。这两个属性协同工作，以定义何时输出位以及何时对位进行采样。时钟极性可由主器件设置，以允许在时钟周期的上升沿或下降沿输出和采样位。时钟相位可以设置为在时钟周期的第一边沿或第二边沿上进行输出和采样，无论它是上升还是下降。
在SPI中，主机可以选择时钟极性和时钟相位。CPOL 位设置空闲状态期间时钟信号的极性。空闲状态定义为 CS 为高并在传输开始时转换为低电平的周期，以及当 CS 处于低电平并在传输结束时转换为高电平的周期。CPHA 位选择时钟相位。根据CPHA位，上升或下降时钟沿用于采样和/或移位数据。主机必须根据从机的要求选择时钟极性和时钟相位。根据 CPOL 和 CPHA 位选择，提供四种 SPI 模式。表中显示了四种SPI模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab6653cd8f32bc885f582e3d7b87ce20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/733d1b8d4fab276fc9c8d8a14b79cacc/" rel="bookmark">
			Caused by: org.postgresql.util.PSQLException: 错误: 逻辑解码要求wal_level ＞= logical
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用cloudcanal pg数据库双主集群搭建时报错：
Exception stack is java.lang.RuntimeException: init pg replication error,response msg:invoke rcontroller method failed.Request id:a2b25648-a91f-11ed-98c7-ab261137fb5amsg:PSQLException: 错误: 逻辑解码要求wal_level &gt;= logical. target sidecar is 172.31.238.4, route name is pgInitReplicationAndFetchLsn
报错截图如下
原因：因为wal_level 的级别小于logical，修改wal_level即可
解决：把wal级别调成logical
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac5d4e4c57e6a8f1ccf90e1c9cad704e/" rel="bookmark">
			robotstudio要从当前占位符中提取IRB2600....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如上图所示，在添加singal后重启控制器便出现了这样的提示。找了一圈也没有找到答案，希望有高人指点指点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37fcbfe1432933d99d34e1c24b57b0e2/" rel="bookmark">
			单例模式（懒汉&amp;饿汉）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式
单例模式是一种创建型的设计模式，使用单例模式进行设计的类在程序中只有一个实例，并且在程序的任何地方都可以调用到，这个类称为单例类。
单例模式又分为懒汉模式和饿汉模式
饿汉模式
饿汉模式是指在类加载的时候就创建对象，直接将对象实例化完毕，资源申请完毕，在使用的时候可以直接使用
优点：效率高，资源使用的时候可以直接使用
缺点：程序初始化满，资源占用多
代码：
#include&lt;iostream&gt; using namespace std; //饿汉模式 class Signleton { private: int _data; private: static Signleton _eton; Signleton() //构造函数私有化，目的是该类只能实例化一个对象 { _data = 10; } public: static Signleton* Getinstance() { return &amp;_eton; //返回对象的地址 } int GetData() { return _data; } }; Signleton Signleton::_eton; int main() { Signleton* p = Signleton::Getinstance(); //用指针访问对象 cout &lt;&lt; p-&gt;GetData() &lt;&lt; endl; return 0; } 懒汉模式
懒汉模式是指在使用的时候才创建单例对象，即资源用到的时候在去申请
优点：程序初始化速度快，资源占用少
缺点：第一次访问对象时候速度较慢，而且存在线程安全问题
代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37fcbfe1432933d99d34e1c24b57b0e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ddcb843a8403edf7480b41b54e5c64b/" rel="bookmark">
			平衡二叉搜索树（Balanced Binary Tree）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 平衡二叉搜索树是一种结构平衡的二叉搜索树，它的每个结点的左右两颗子树的高度差都不超过一的二叉树。它可以在平均和最坏情况下都在 O ( l o g n ) O({\bf log}n) O(logn)的时间复杂度内完成插入、删除和查询等操作。
正常的二叉搜索树最好可以在 O ( l o g n ) O({\bf log} n) O(logn)的时间内完成查询等操作，但是如果二叉树退化为单链表，那么其的搜索效率降低为 O ( n ) O(n) O(n)。因此提出了平衡二叉搜索树，来保持树左右两端深度的平衡。
定义 平衡二叉搜索树又叫AVL树，简称为平衡二叉树，它需要满足以下性质：
可以为空树。如果不为空树，则任意一个结点的左子树和右子树都是平衡二叉树，且高度之差的绝对值不超过1。 为了度量一颗二叉搜索树是否为平衡二叉搜索树引入了平衡因子，它是表示某结点左子树和右子树高度的差，平衡二叉树中不存在平衡因子绝对值大于1的结点。
失衡调整 了解平衡调整策略之前先引入一个最小失衡子树的概念：在新插入的结点向上查找，以第一个平衡因子的绝对值超过1的结点为根的子树。平衡二叉树的失衡调整主要通过旋转最小失衡子树实现的（旋转的目的是为了调整左右子树的高度，哪棵子树高哪棵子树向上旋转）。旋转常见的两种方法为左旋和右旋。
左旋 如上图所式，插入99结点之后不再满足二叉平衡树的性质，此时最小失衡子树为以66结点为根的二叉树，对其进行以下左旋操作：
右孩子代替最小失衡子树根所在的位置（77代替66的位置）右孩子的左子树变为原该子树根的右子树（75的父结点改为66，作为右孩子）原来的根节点作为新子树根的左孩子（66的父节点改为77，作为左孩子） 右旋 如上图所式，插入43结点之后不再满足二叉平衡树的性质，此时最小失衡子树为以66结点为根的二叉树，对其进行以下右旋操作：
左孩子代替最小失衡子树根所在的位置（60代替66的位置）左孩子的右子树变为原该子树根的左子树（63的父结点改为66S，作为左孩子）原来的根节点作为新子树根的右孩子（66的父节点改为60，作为右孩子） 不同破坏平衡方式的调整方式 一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指针为A（即A是离插入结点最近，且平衡因子绝对值不超过1的祖先结点），则失去平衡后进行调整的规律可以归纳为一下4种情况：
在A的左子树根节点的左子树上插入结点而破坏平衡（LL）：使用单向右旋平衡方法。在A的右子树根节点的右子树上插入结点而破坏平衡（RR）：使用单向左旋平衡方法。在A的左子树根节点的右子树上插入结点而破坏平衡（LR）：使用先左旋后右旋的平衡处理方法。在A的右子树根结点的左子树上插入结点而破坏平衡（RL）：使用先右旋后左旋的平衡处理方法。 LL 该示例可以看此前失衡调整的右旋。
RR 该示例可以看此前失衡调整的左旋。
LR 如上图所示，插入65结点之后，不再是二叉平衡，此时再单纯进行右旋不能使树重新平衡，因进行以下操作：
对失衡节点的左孩子进行左旋操作（60为根进行左旋）对失衡节点做右旋操作（66为根进行右旋） 第一步：
第二步：
RL 如上图所示，插入76结点之后，不再是二叉平衡，此时再单纯进行左旋不能使树重新平衡，因进行以下操作：
对失衡节点的右孩子进行右旋操作。（77为根进行右旋）对失衡节点66做左旋操作（66为根进行左旋） 第一步：
第二步：
总结 在所有的不平衡情况中，都是按照先寻找最小不平衡树，然后寻找所属的不平衡类别，再根据4种类别进行固定化程序的操作。在LR和RL中如果进行第一次旋转之后不论有没有出现新的最小平衡树，下一次调整的还是最初最小平衡树的根节点。 删除操作 这一部分我没有找到很好的文献，希望有知道的同学们推荐一下，下面是我对平衡二叉搜索树删除的理解。有错误可以指出，我修改一下。
上面讲的都是平衡二叉搜索树的插入。而平衡二叉搜索树的删除操作和二叉搜索树的删除一致，都有以下情况：
如果结点没有孩子结点，则直接删除该结点，并从删除结点的父结点开始检查并调整。如果结点只有左子树或者右子树中的一个，则直接将该子树移到被删除结点的位置，并从子树顶结点开始向上检查并调整。如果结点拥有两个子树，则用后继或者先驱结点取代被删除的结点，并从后继或者先驱结点的父节点开始检查并调整。 参考文献：
什么是平衡二叉树（AVL）JAVA实现平衡二叉树（AVL）——有源码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a6338a9c29b6d6db0e38d3ac18f16e/" rel="bookmark">
			仅轨迹生成和跟踪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是想在第一次实现后重新规范一下代码，然后整体重新实现并记录一下过程，完整代码见github https://github.com/USE-jx/Robomaster-uav-competition。
先将任务简化为轨迹生成和轨迹跟踪，不考虑障碍环在一定范围内移动的问题，根据大致的圆环中心生成minimum jerk轨迹，轨迹跟踪采用Geometric controller。（写这篇时已经识别出圆心了，就差轨迹重规划一下了，但是还是想先把之前记录一下，修改一下代码整体结构）。
分析一波 整体分成轨迹规划和轨迹跟踪两个模块。
规划模块输入几个圆心waypoints，生成一条轨迹，发布轨迹上每一时刻的状态给控制模块作为期望状态，odom在发布状态，停止以及以后的重规划会用到，尤其时间戳很有用。所以规划模块订阅里程计消息，发布期望状态消息。
控制模块接收规划模块发来的期望状态和里程计的真实状态，发布控制器输出命令给飞控。所以控制模块订阅里程计消息和期望状态消息，发布控制命令消息。
综上，需要的模块之间通信的消息类型有里程计消息，期望状态消息和控制命令消息。
创建工作空间 第一步肯定是创建一个工作空间了，然后才是创建各种功能包。
mkdir -p uav_ws/src cd uav_ws catkin_make cd src //在src中创建各种功能包 自定义消息 里程计消息直接用ros官方消息，所以自定义一个角速率推力消息和一个期望状态消息，期望状态根据控制器需要什么状态来定义，几何控制需要位置速度加速度和偏航,其他控制器需要什么再加上就好。
//创建功能包和依赖 catkin_create_pkg uav_msgs std_msgs geometry_msgs roscpp cd uav_msgs/ mkdir msg cd msg touch AngleRateThrottle.msg touch DesiredStates.msg DesiredStates.msg中填入下面语句
std_msgs/Header header geometry_msgs/Vector3 position geometry_msgs/Vector3 velocity geometry_msgs/Vector3 acceleration float64 yaw AngleRateThrottle.msg中填入下面语句
float64 rollRate float64 pitchRate float64 yawRate float64 throttle 在package.xml中填入下面两行
&lt;build_depend&gt;message_generation&lt;/build_depend&gt; &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt; 在CmakeLists中做如下修改
//添加message_generation find_package(catkin REQUIRED COMPONENTS ... message_generation ) //添加message_runtime catkin_package( .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35a6338a9c29b6d6db0e38d3ac18f16e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb47b9ddadf9d92d2f963d79217d461a/" rel="bookmark">
			一篇刷题所需的查找表-Java(未完)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 刷题
去重
排序
去重+排序(使用库)
算法优势
字符串操作
进制操作
数据操作
自测题目
刷题 第一件事 : 牛客网需要验证输入数据内容和类型，leetcode直接开始下一步。
import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); while(in.hasNext()){ System.out.println(in.next()); System.out.println(in.next().getClass()); } } } 第二件事再根据输入与输出格式，进行对数据结构的选择和解决答案 : 先解决问题再优化为主要思想。例如，题目中提到有同学名字和成绩，根据同学成绩排序，则需要选择有序的数据结构，且有键和值可以放同学名字和成绩， 先选择TreeMap去解决问题，之后若有多余的时间再进行时间和空间的优化。
去重 1. 使用HashSet
特点 : 无序，无重复元素
HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。
HashSet 允许有 null 值。
HashSet 是无序的，即不会记录插入的顺序。
HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。
HashSet 实现了 Set 接口。
// 引入 HashSet 类 import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb47b9ddadf9d92d2f963d79217d461a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2c547d1a22d3b14c9f5413dcf6a519/" rel="bookmark">
			Markdown(1):markdown设置标题、代码、图片、链接、标题、页内跳转、配置vscode插件、删除线、公式符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我基于vscode进行下面的markdown学习，应该适用于ubuntu和window系统；window系统下有比较好的破解版软件，大家可以去看看，ubuntu下感觉vscode比较好用。
目录
一、语法学习
1.1 标题
1.1.1 使用'#'表示标题
1.2 代码块
1.2.1 行内代码块
1.2.2 代码块
1.2 插入链接
1.3 插入标题
1.4 公式
1.4.1 markdown下标、上标
1.5 markdown设置页内跳转
1.6 删除线
二 插入图片
2.1 html风格代码：
（1）插入图片
（2）设置图片比例/高度/宽度
（3）设置图片对齐
2.2 另一种风格代码
2.3 图片并排显示
三、vscode插件
3.1 Markdown Preview Enhanced
3.2 Markdown All in One
3.3 Markdown TOC
3.4 Markdown PDF
参考链接：
1 markdown语法学习
2 markdown开发的vscode插件:
3 markdown插入图片
3 markdown导出pdf的插件
一、语法学习 1.1 标题 1.1.1 使用'#'表示标题 '#'必须在行首，'#'越多，标题的级别越低
1.2 代码块 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2c547d1a22d3b14c9f5413dcf6a519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67873695e9c20d24bd5861926999bcfe/" rel="bookmark">
			在windows 10操作系统，用delphi XE5编程语言，如何把其它程序而不是本软件在通知区域的图标隐藏？不是关闭进程。请举个详细代码例子，Shell_NotifyIcon和Showwindow...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以使用Windows API的DeleteTrayIcon函数来实现该功能，具体代码如下： // 获取DEVBIT.exe的句柄 HANDLE h = FindWindow("DEVBIT.exe",NULL); // 将句柄传递给DeleteTrayIcon函数 DeleteTrayIcon(h);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ba193fc9c910352e665fdaf37afa7c2/" rel="bookmark">
			C语言课程设计 《 运动会比赛计分系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我可以为您提供一些建议：1.首先了解C语言的基础语法；2.明确比赛计分系统的功能要求，以及实现这些功能所需的数据结构；3.确定程序的结构，并编写相应的函数；4.测试程序，确保它能够正确地实现所有功能；5.最后，完善程序，使其更
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b106aaa7f9c364790eaa9fde2a8cddb/" rel="bookmark">
			写一个管理学生信息、课程信息、成绩管理、学生考勤等信息的系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我可以为您建议一个基于web的学生信息管理系统，它可以帮助您更好地管理学生信息、课程信息、成绩管理、学生考勤等信息。该系统具有安全可靠的数据库，可以提供可靠的数据支持，帮助您快速、有效地处理信息，并具有友好的用户界面，使用户可以轻松地进行查询、添加、编辑、删除等操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3383d221e7767e62c946295431c75b99/" rel="bookmark">
			delphi XE5如何把其它程序而不是本软件在通知区域的图标隐藏？不是关闭进程。请举个详细例子，比如Shell_NotifyIcon...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Delphi XE5可以使用API函数Shell_NotifyIcon来实现隐藏其它程序的图标。具体代码例子如下：procedure HideIcon(APid: Cardinal); var noteIconData: TNOTIFYICONDATA; begin noteIconData.cbSize := SizeOf(TNOTIFYICONDATA); noteIconData.hWnd := 0; noteIconData.uID := APid; Shell_NotifyIcon(NIM_DELETE, @noteIconData); end;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f63638615b8994285f877e9792cd6a/" rel="bookmark">
			量化交易之linux篇 - makefile - 动态库.so、静态库.a的制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// 静态库制作的步骤 主函数测试数据：main.c 功能函数实现：add.c add.h 将功能函数编译为库函数（二进制文件） 1. 将功能文件*.c编译成*.o文件 gcc add.c -o add.o -c 2. 将*.o文件塞入.a文件之中, 文件名开头需要添加lib ar rcs libadd.a add.o 3. 联合编译 gcc main.c libadd.a -o main 4. 测试 ./main // 动态库制作的步骤 主函数测试数据：main.c 功能函数实现：add.c add.h 将功能函数编译为库文件（二进制文件） 1. 将功能函数源文件编译为*.o文件 gcc add.c -o add.o -fPIC -c 2. 将*.o文件塞入.so文件之中, 文件名开头需要添加lib gcc -shared -fPIC -o libadd.so add.o 3. 联合编译需要链接动态库 gcc main.c -o main -L . -ladd // -L . 代表路径 4. 测试 ./main 如果报错如下: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8f63638615b8994285f877e9792cd6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5a3b195af5194669dbbfd91d0cfd2bc/" rel="bookmark">
			麻烦给我一个可以将vue项目打包成docker镜像的Dockerfile文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我可以提供一个可以将vue项目打包成docker镜像的Dockerfile文件的示例：FROM node:10.15WORKDIR /appCOPY . .RUN npm installRUN npm run buildFROM nginx:1.15COPY --from=0 /app/dist /usr/share/nginx/htmlEXPOSE 80CMD ["nginx", "-g", "daemon off;"]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813540b72eca087c3b3fbe5d24228ea4/" rel="bookmark">
			写一个  constexpr 元编程 的代码例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		constexpr auto add_two_numbers(int a, int b) { return a + b; } int main() { constexpr auto result = add_two_numbers(4, 5); static_assert(result == 9); }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a47b5b07871c83ddd15ede298058b086/" rel="bookmark">
			我想要pytorch绘制loss曲线的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我可以提供一些建议来帮助您绘制PyTorch的损失曲线。首先，您可以使用PyTorch的nn.BCEWithLogitsLoss()函数计算损失值。然后，您可以使用PyTorch的optim.SGD()函数来初始化模型参数，并使用PyTorch的nn.Module.fit()函数来训练模型。最后，您可以使用PyTorch的torch.Tensor.plot()函数来绘制损失曲线。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b206d07520f8383f8cb5c8b62180141f/" rel="bookmark">
			用c语言实现冒泡排序代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用C语言实现冒泡排序代码的思路是：首先，取出数组中的第一个数字，与其他数字进行比较，将最大的数字放到数组的最后一位；然后，取出数组中的第二个数字，与剩余的数字进行比较，将最大的数字放到数组的倒数第二位；依次类推，直到完成整个数组的排序。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d705b52f3a93dbcc8b255b14c2e481a/" rel="bookmark">
			给我用C语言写一个二叉树的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我可以给你一个例子： #include &lt;stdio.h&gt; struct node { int data; struct node left, right; }; / function to print leaf nodes of a binary tree/ void printLeaves(struct node* root) { if ( root != NULL ) { printLeaves(root-&gt;left); // 如果节点为叶子节点，则打印 if ( root- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93897ad6828c731c6ac43c855fcc4b17/" rel="bookmark">
			请分别创建出listA、listB、listC，完成以下各题 (1)将listC中的内容添加到listB中: (2)输出listA与listB的交集listD; (3)输出listA与listB的并集...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答: (1) 将listC中的内容添加到listB中: 将listC中的每一项元素都添加到listB尾部。 (2) 输出listA与listB的交集listD: 定义一个空listD，遍历listA中的每个元素，如果listB中有相同的元素，则将该元素加入listD，最后输出listD。 (3) 输出listA与listB的并集listE: 定义一个listE，将listA和listB中的元素依次加入listE，如果listA和listB中有重复的元素，只加入一次，最后输出listE。 (4) 输出listA相对listB的补集listF: 定义一个listF，遍历listA，如果listB
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca28799d764d58c95f8cb5d98fc10e9/" rel="bookmark">
			java se ee 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java SE(Standard Edition)是Java的标准版本，主要用于桌面和嵌入式应用程序的开发。Java EE(Enterprise Edition)是面向企业的Java，主要用于开发大型的、可伸缩的网络应用。它们之间的主要区别是Java EE专注于企业级应用，而Java SE专注于桌面应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e849fe9a38cecafbfb03750455420807/" rel="bookmark">
			给我一份类似微信聊天的前端dome，完整代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很高兴为您提供帮助，下面是一份完整的微信聊天前端dome的代码： 微信聊天前端dome 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51df048ec6f342f3c977d2d4b0b37353/" rel="bookmark">
			如何用tkinter写一个gui
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我可以给你一些建议：使用Python中的tkinter模块来创建GUI应用程序，它提供了一组类和函数来完成GUI应用程序的开发。你可以使用tkinter来创建按钮，文本框，输入框，单选按钮，滑块等等，以帮助你创建一个GUI界面。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f452bae912232fa82e32e198f54795ee/" rel="bookmark">
			javascript实现冒泡排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript 实现冒泡排序的方法是：首先，比较相邻的元素。如果第一个比第二个大，就交换他们两个。然后，对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。然后再下一轮，重复上述过程，直到排序完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3024825c3f181a56e718b77fbbeeeff2/" rel="bookmark">
			Unity mlagent中强化学习ppo算法的参数怎么设置？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity ML-Agents的PPO算法参数可以通过设置ML-Agents的Hyperparameter设置来调整，具体有：batch_size、discount、gae_lambda、learning_rate、entropy_coeff、max_step、 optimizer、num_epoch、num_layers、num_hidden_units等等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6afd38674df9b17ef47523928c3488b4/" rel="bookmark">
			如何配置vscode，使其能编写并运行urho3d的lua脚本？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答：要配置VSCode以编写和运行Urho3D的Lua脚本，您需要安装Lua插件，并在VSCode中设置Lua语言支持。您还可以为VSCode添加Urho3D相关的代码提示和自动完成功能，以便更轻松地编写代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92cc8d022274770cebf0e18328b4c73a/" rel="bookmark">
			翻译：In this thesis, we use latent semantic indexing (LSI, an information  retrieval technique) [7] to...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在这篇论文中使用潜在语义索引(LSI，一种信息检索技术)[7]从蛋白质互作网络中检索蛋白质之间的关系。 LSI可以解决信息检索(IR)中的同义词(表达给定概念的许多方式)和多义词(单词有多种含义)问题。 这个属性对于解决我们的问题也很有用。 我们的实验结果表明，我们的方法确实克服了使用蛋白质互作网络预测蛋白质功能的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/923263a62637859585ae26b032faf2ab/" rel="bookmark">
			请用python随便写一个游戏。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		答：我可以用Python写一个简单的游戏，比如贪吃蛇。首先，需要创建一个画布，用于显示游戏界面；然后，创建一个贪吃蛇对象，它可以在画布上移动；接着，创建一个食物对象，使贪吃蛇可以吃到它；最后，就可以开始游戏了，比如让贪吃蛇吃到食物，让它自动移动，玩家可以通过控制贪吃蛇来控制游戏。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b6237ba052aad957cc1ea30b5fe01d/" rel="bookmark">
			请问强化学习的策略梯度定理的推导过程是上面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		强化学习的策略梯度定理的推导过程是基于马尔可夫决策过程(MDP)和概率理论的基础上推导的。它的推导步骤是：1)定义状态空间S、行为空间A、折扣因子γ和回报函数R；2)构建状态值函数V(s)；3)求解状态值函数V(s)的期望值；4)构建策略函数π(s)；5)求解策略函数π(s)的期望值；6)推导策略梯度定理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62816d1829b606f3b96732c5eabedfdf/" rel="bookmark">
			用python代码实现加载csv文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常可以使用Python的csv模块来加载CSV文件。例如，下面的代码可以用来加载一个CSV文件：import csvwith open('my_file.csv', 'r') as f: reader = csv.reader(f) for row in reader: print(row)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d4bd3806146a860b543bb573751842d/" rel="bookmark">
			ThreadPoolExecutor的使用示例，怎么创建线程和使用，给出详细代码，顺便解释一下，通俗一点哦...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ThreadPoolExecutor的使用示例示例如下：import java.util.concurrent.Executors; import java.util.concurrent.ThreadPoolExecutor;public class ThreadPoolExecutorExample { public static void main(String[] args) { // 创建一个可重用固定线程数的线程池 ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c781b13614f9471bc961ff5c6434ad5/" rel="bookmark">
			矩阵的转置用C语言怎么实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵的转置用C语言可以使用两种方法实现：第一种是使用循环，可以使用两层循环来遍历矩阵中的每一个元素，然后交换每一个元素的行索引和列索引；另一种是使用矩阵乘法，首先将原矩阵的转置矩阵与原矩阵相乘，则可以得到原矩阵的转置矩阵。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/178/">«</a>
	<span class="pagination__item pagination__item--current">179/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/180/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>