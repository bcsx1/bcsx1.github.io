<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0697aa30a7fd1d14841a8eba10c84dda/" rel="bookmark">
			Mysql数据库时间和系统时间不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 本地请求时间跟系统Mysql数据库记录的时间对不上。
原因分析： 两个系统的时区不一致，导致本地请求时，在插入数据库数据的时候使用自动生成的时间戳时不一致。
解决方案： 方案1：
修改my.cnf文件 [mysqld] default-time-zone='+8:00' 重启mysql 方案2：
show VARIABLES like '%zone%'; set global time_zone = '+08:00'; flush privileges; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa98149b0beea33f351dd153eebff764/" rel="bookmark">
			windows安装maven，配置环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网下载： 其他版本找 Other Releases
配置环境变量 1、解压缩之后开始配置环境变量
2、右键此电脑，选中属性-&gt;高级系统设置-&gt;高级-&gt;环境变量。
3、①和②任选一个都可
①在系统变量那边增加MAVEN_HOME，路径是解压缩后的文件路径。之后再在系统变量那边找到Path，选中编辑，添加%MAVEN_HOME%\bin
②直接在系统变量那边找到Path，添加全路径的bin文件
4、最后打开cmd，运行：mvn -version 查看是否配置成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a82e1971b8950dc89a9cb92713c746eb/" rel="bookmark">
			Python实现求解上个工作日逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、需求描述二、代码实现三、测试结果 一、需求描述 因工作需要，现需获取任意一个日期的上个工作日，要求考虑法定假日及周末。
例如：2024年2月10日（春节）的上一个工作日为2024年2月9日，2024年2月17日的上一个工作日仍为2024年2月9日，而2024年2月18日的上一个工作日为2月17日，以此类推
二、代码实现 # 获取上个工作日逻辑,包含节假日、调休逻辑 import datetime import pandas as pd import chinese_calendar def get_last_workday(today): """ 获取上一个工作日的年月日字符串 """ weekday = today.weekday() # 如果今天是周天，上一个工作日是上周五;如果周六补班，上个工作日则是周六 if weekday == 6: last_workday = today - datetime.timedelta(days=1) # 周六不上班则上个工作日为周五 if chinese_calendar.is_holiday(last_workday): last_workday -= datetime.timedelta(days=1) else: last_workday = today - datetime.timedelta(days=1) #不变 else: # 否则，上一个工作日就是昨天 last_workday = today - datetime.timedelta(days=1) # 如果上一个工作日是法定节假日，则调整为法定节假日结束后的第一个工作日 while chinese_calendar.is_holiday(last_workday): last_workday -= datetime.timedelta(days=1) return last_workday.strftime('%Y-%m-%d') def get_date_df(dates,last_workday_list): ''' 输出最终24年每天的对应上个工作日，以及当天的工作日标签 ''' date_df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a82e1971b8950dc89a9cb92713c746eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0468a8c0dadd5748e988597f7e5cbe98/" rel="bookmark">
			Python引用(指针)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其实文章的标题严谨性有所欠缺，虽然底层是用C语言实现的，但是python语言没有指针这一说。这么取名是为了和我们学过的内容相互联系类比，从而获得更好的理解。
在Python中，有时候想当然认为使用等号赋值如
b = [1, 2, 3, 4] a = b 可以获得一个变量的副本，其实并不如此。实际上此时的a获得的是b的一个引用，如下图所示：
可以看到，a和b指向的是同一个内容，也即此时的等号赋值并不是复制，而是传递引用。两者指向同一个对象。
这个问题在很多场合都没有问题（例如遍历a和遍历b），只是相当于换了一个名字而已，用a和b都没有任何区别。
但是当到了需要对数据操作的时候（例如增加数据，删除数据）的时候就会发生问题。
给定如下程序，试分析其输出：
a = {'a': 1} c = [] for i in range(3): b = a b['b'] = i c.append(b) print(c) 第一直觉分析，输出列表c包含3个字典，每个字典包含2个项，如下所示：
[{'a': 1, 'b': 0}, {'a': 1, 'b': 1}, {'a': 1, 'b': 2}] 然而实际输出为：
[{'a': 1, 'b': 2}, {'a': 1, 'b': 2}, {'a': 1, 'b': 2}] 为什么其中的每个项都是一样的？ 错误在于使用了b = a对a进行复制，该语句并不会对a进行复制，而是生成一个a的引用。
如上图所示，每次使用b = a时，都只是生成了字典a的引用，每次append到列表c中的都是字典a的引用，所以每次修改a都对列表c中的所有项生效，经过3次循环，最后一次修改字典a得到的是{'a': 1, 'b': 2}，于是列表c中的每一项都是一样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0468a8c0dadd5748e988597f7e5cbe98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/736ad756443f3fc3033b8e4aec1a2373/" rel="bookmark">
			高科技电子行业采购供应链管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着新一代信息技术的发展，我们迈入了数智化时代，各行各业借助技术的升级，加快自身数字化转型的步伐。高科技电子行业作为技术创新的前沿地带，在智能化的道路上也走在传统行业的前面，这其中包括生产研发的技术创新，研发管理的创新，多维的数智化转型，推动高科技电子行业向“智造”进一步迈进。
01 「洞察需求」：高科技电子行业供应链管理“难”在哪？
高科技电子行业是知识与技术密集型产业，技术难度大、智力要求高、竞争性和渗透性强、投资多、风险大，是对人类社会的发展进步具有重大影响的前沿科学产业。
信息技术在国家“十二五”规划中被确立为七大战略性新兴产业之一，这其中包括下一代通信网络、物联网、三网融合、新型平板显示、高性能集成电路和以云计算为代表的高端软件。高科技电子行业作为信息技术产业的有机组成部分，也受到市场红利的极大辐射。
在不断扩大市场的同时，高科技电子行业在企业经营管理上也面临着诸多难点：
产品生命周期短：技术创新、产品创新在高科技电子行业中的作用十分显著。高新技术产品生命周期短、更新快、时效性强且难以预料，所以要求不断地进行产品创新，以适应新的市场需求。所以产品的研发、生产、溯源等方面都要求实现高水平管理。
物料管理难：物料管理影响产品研发，物料计划，生产发料，仓库管理等环节。高科技电子行业的原材料体积小、种类繁多，数量巨大、次品率高，易受供货市场、原材价格、产品功能要求、客户需求等因素的影响；使用替代料的情况也很多。
生产计划变更频繁，难控成本：高科技电子行业的生产一般是离散型制造，订单多批次、小批量且经常变更，常出现紧急插单，要求高效的协同效率；而且产品种类多、返工频繁，成本核算费时费力，难以掌握实际成本。
复杂产品结构搭建不完善：手动导出、人为线下搭建、数据独立存储、手动传递导入等多种产品结构管理模式，难以支撑快速演变的产品需求。后端工艺设计、生产制造、采购等业务，难以保证设计源头数据的完整性、准确性和一致性，导致变更、返工、重购等问题，影响产品质量、交付。
供应商协同过程及追溯不清晰：传统邮件、电话、微信等交互模式，难以对供应商数据协同过程进行有效记录，影响对历史数据的查询和追溯，也难以及时了解和管控供应商数据的交付及时性，导致等待、催货等情况发生，影响终端产品交付。
作为技术型产业的高科技电子行业，是新技术应用、实现智能制造的沃土，尤其在应对快速发展的市场中迫切需要通过智能制造来实现透明化、精益化生产，实现计划与物流的协同、采购与生产的协同、物料和质量的全流程追溯、设备与工艺的无缝连接等。这其中，智慧供应链是实现智能制造的必要一环。
02 「制胜之道」：SRM采购管理平台建构智慧供应链
“智慧供应链”是结合物联网技术和现代供应链管理的理论、方法和技术，在企业中和企业间构建的，实现供应链的智能化、网络化和自动化的技术与管理综合集成系统。其核心是实现供应链中商流、信息流、物流、资金流的无缝对接，尽可能消除不对称影响因素带来的影响，进而提高企业内部以及整个行业供应链的效率与运营质量。与传统供应链相比，智慧供应链技术渗透性更强、可视化更强、信息集成性更强、可延展性更强、协作性更强、敏捷性更强。
智慧供应链的打造，并非一日之功，既要满足更精准掌控供应链运作的信息，又要满足供应链服务降低成本和管理便捷化等要求，这必然需要更高质量的供应链服务。数字化采购服务专家，其SRM采购管理系统，提供专业化的行业解决方案，搭建匹配不同采购场景的智能化采购平台，服务企业打造智慧供应链。
| 平台化管理，标准化供采协同全流程，完整数据链条
作为生产的上游，也是供应链的起点，采购管理直接影响到产品研发、生产制造。企企通SRM采购管理系统，让企业能实现高度流程化、集成化、平台化管理，以降本增效推动高质量发展。
统一门户、采购流程、业务内容、数据集成、业务消息、组织体系，由SRM管理系统构建采购管理应用，根据需求实现便捷的调整与扩展，完成管理的平台化、集成化升级。通过SRM采购管理平台，采购企业与外部供应商能建立起统一的协作通道，将采购全流程进行信息化梳理、固定，将标准化制度、业务规则以软件形式进行规范化的自定义管控，支撑多样化的业务场景，畅通信息流通道，让采供双方高效执行业务，提高运作效率。
同时，SRM采购管理平台内连OA、PLM、WMS、ERP、OMS、TMS等内部业务系统，外接供应商，打通完整的采购业务数据链条。需求变更、计划调整等信息即时同步SRM，自动核算成本，并提供成本分析等各类数据工具，实现智慧决策。利用SRM，数据关联，保障需求源头数据、订单过程等的完整性、准确性与一致性，减少返工、重购等情况发生。在出现异常情况，也能即时溯源追踪，把控风险。
| 双向交易机制，一站式交易闭环
信息流程通道畅通下，加快物流响应时间、更高效运作起来，实现商流的快速流动，最终缩短资金流完成时间，整体上提升供应链的效率。SRM采购管理平台，将商品信息、询比价管理、订单管理、支付管理、电子合同、交付管理、财务对账、评价体系等全流程进行系统化、数字化管理，简化供采双方交易路径与实现交易智能化，帮助企业建立供应链交易闭环系统，四流合一，提升供应链响应能力。
| 精细化出入库管理，加强交货协同
高科技电子行业的原材料体积小、类型多、数量巨大，尤其随着研发创新的加快，需要管理越来越庞大的物料库。智能制造企业，必须建立应用集成环境等推进文档、物料及BOM和流程的全面数字化，对物料完成在库管理。
物料的出入库管理则可以交给SRM采购管理系统，其与PLM、ERP、WMS等内部管理系统可实现无缝对接，通过SRM就能与供应商协同物资的交付，利用专门的送货单，标准物料条码，进行扫码质检、出入库的统一管理，并连通MES分料，物料管理实现系统到系统的无缝流转、服务生产。
| 强化供应商管理，从生态合作到生态协同
供应链管理升级、实现更科学的管理模式，是智慧供应链打造的必然要求。通过SRM管理系统，企业建立与供应商统一的数据协同平台，工艺、UDF、模具、签样信息等在线货架展示，实现各类数据的在线交互，实现数据收发即时有效的通知与反馈，提高触达效率，及时知晓与管控供应商任务执行情况，控制采购风险。
供应链协同要求的是供应链所有成员为了一个共同的目标，在采购、生产、研发、销售等环节上实现协同管理，是企业与企业间的勾连。通过SRM，高科技电子企业能打造万企互联的商业网络，与供应商伙伴的合作模式由生态合作向生态协同转变，实现战略协同、资源协同、能力协同。
利用SRM采购管理平台，实现对供应商从准入、等级分类、业务协同到整改优化直、退出的全生命周期管理，并搭建起统一规范的供应商绩效考核制度。细化考核指标，数据辅助对供应商进行战略、优选、及格等等级划分，进行优胜劣汰，培养人才企业，以及利用降低激励政策门槛，扩大激励范围、加大激励投入，让伙伴更多获利，吸引更多优质伙伴。强化信任下，企业选择性地与上下游企业分享预测、订单、库存等信息，提高预测的准确性，加强计划协同与补货，提升资源利用效率。以生态协同聚能，打造高质量、高密度的合作生态网。
03「增长利器」：自建商城平台，增加企业营收渠道
当前世界经济的不稳定因素增多，企业在稳定已有市场的情况下，更要谋求更多利益增长点，提高自身的抗风险能力。通过有效利用本企业生态环境中上下游的供应商与采购商，将现有的客户资源变现，扩大销售业务，就是高科技电子企业可以选择的增长点之一。
基于电商化的交易模式，企企通商城云可帮助企业打造行业对口的B2B/B2B2B商城，涵盖撮合交易、自营、企业入驻联营等模式，将采购方、供应商、平台资源有效整合，构建企业自己的采购交易平台，实现采供销一体化。
一方面，企业打造自营商城，将自有品牌产品上架推广，向下游经销商、代理商出售，可连通SRM系统，实现采购、销售业务协同“一站式”企业生态管理平台搭建，覆盖业务分配、成本控制、采购执行、对账付款等，打通业务流程数据链路，进行销售转采购业务协同，提升销售额与供应链效率。
另一方面，建立起B2B/B2B2B商城，企业也可以仅作为平台运营方，利用自身的供应商资源库，以及吸引更多平台商家入驻，撮合供应商、零部件商家等直接与下游制造企业、电子产品企业等采购商实现端到端的精准对接、合作交易，提供从线索、商机、订单到回款，实时追踪，双向结算服务，企业通过产品销售、商家入驻服务、运营服务、广告位、资金沉淀收入、流量入口等多种盈利模式，增加企业收入。
工业已迈入4.0时代，高科技电子行业的发展趋势是高质量、高品质、绿色化，而智能制造是必由之路，智慧供应链是必备支撑。企业通过数字化工具建构智慧供应链，完成采购透明化、生产精益化，对商流、信息流、物流、资金流的一体化整合，实现企业的降本提质，为更多传统企业、行业树立起数字化转型典范，引领智能制造发展。
高科技行业是指生产经营过程中，研究与开发费用投入大，拥有较高比率的科技型人才，并以研究开发、生产销售创新产品或创新技术服务的行业。
高科技行业的特征
高科技行业是指生产经营过程中，研究与开发费用投入大，拥有较高比率的科技型人才，并以研究开发、生产销售创新产品或创新技术服务的行业。和传统行业相比高科技行业在很多方面有所不同，可以将高科技行业的特征概括为高投入性、高技术人才密集性、高创新性、高增长性、高收益性、高风险性、组织结构扁平化等典型特征。
常见的高科技行业，它主要包括电子装配的行业，如：导航仪生产，手机生产，电脑整机生产，高像素相机生产；还有高新产品的零配件加工的行业，如：PCBA、手机触控屏、芯片封装；另外，如光伏、LED显示屏、节能灯等企业也都属于高科技行业。
高科技行业生产的主要特点是：生产方式主要是离散型生产、产品结构清晰明确、工艺流程自动化程度较高，工艺路线比较固定，产能一般都比较紧张、物料种类多，仓储管理复杂、生产计划的制订与生产任务的管理难度大。
高科技行业的管理重点和难点 ，主要包含如下几个方面：
（1）高科技行业的产品研发管理：技术创新、产品创新在高科技行业中的作用都十分显著。企业不创新甚至创新缓慢，企业将会面临被淘汰；另外，高新技术产品生命周期短、更新快、时效性强且难以预料，所以要求不断地进行产品创新，以适应新的市场需求。基于高新产品的这些特点，所以高科技行业的研发管理很重要，它不担但要管理到产品的全生命周期，还需作产品的版本管理和追溯功能。
（2）替代料管理：高科技行业，产品的BOM组件种类多，易受供货市场、原材价格、产品功能要求、客户需求等因素的影响。使用替代料也情况也比较多，如果替代料管理不好，对产品研发，物料计划，生产发料，仓库管理等环节都会产生很大的影响。
（3）主生产计划和物料需求计划管理：高科技行业的生产一般是离散型制造，订单多批次、小批量且经常变更，急插单的情况很多。所以主生产计划的难度很大；物料需求计划主要靠手工，准确率很低，要么经常缺料，要么导致原材料积压。
（4）订单的全过程跟踪管理：市场变化莫测，客户需求千变万化，要快速响应市场的变化就需要实时掌握订单的状态。
（5）库存原材料的先进先出，追溯及防呆管理：高科技行业原材料种类多，很多电子原材料的外观相似。另外，产品的生命周期短，对质量要求高，因此需对原材料实行先进先出及追溯管理。
（6）呆滞料管理：订单变更、ECN原因、工艺变更、替代料、计划不准、最小包装要求等原因，都会导致呆滞料的产生，从而严重影响公司收益。
（7）高科技行业对信息化的需求是一个非常复杂的综合系统，包含了产品生命周期管理（PLM）、企业资源计划（ERP）、客户关系管理（CRM）、供应商关系管理（SRM）、制造执行系统（MES）、立体仓库管理（WMS）、移动应用（Mobility）、大数据分析（BI）等不同方面的信息化组成部分。
高科技行业解决方案概述
高科技行业的公司，产品推陈出新频率高，公司扩张快 ，首先，系统的设置要适合高科技公司快速发展的需要，以及产品更新换代快的需要。快易生乱，因此也需要通系统的设置，建立一个公司统一的管理平台，以确保公司的管理流程、质量体系、计划体系，成本体系标准化。
其次，具有完整的MRP和供应链协同功能。在高科技行业生产时，需要通过MRP的主生产计划、产能计划与物料需求计划协助高科技企业在生产规划与原料供应保持准确。
第三，在高科技产品的生产环节，工艺流程较长，产品加工所经过的工序多且细，生产数据的采集工作量大。另外，在生产过程中，所需要的原材料种类较多，有时一种原材料可能会在多个工序上使用。因此在设置系统时，要考虑怎么样高效地采集生产数据，方便后续的订单状态跟踪及未来产品质量追溯。
第四，工程变更和替代料是高科技行业的一个管理难点，在产品研发环节，采购价格管理环节，物料需求计划环节，库存消耗环节，都要充分考虑替代料的因素，从而避免因人为干预不到位，而导致物料计划不准确或库存呆滞等情况的发生。
第五，高科技行业的原材种类多，材料的价格高、体积小，原材料的技术革新快，很多材料外观相似等特点，这样就要求仓库的管理水平很高。在系统设置上可启用系统的条码管理功能，通过系统功能自动实现仓库的先进先出管理，有效日期管理，防呆管理及仓库管理员的绩效管理。
最后，因为高科技行业要求对市场的变化有敏捷的反应能力，所以可根据不同应用场景设计开发的多种移动互联解决方案将能够很好的解决信息分发和人员随时方便使用的需求。
综上所述，高科技行业有非常突出的行业特性和个性化的信息化解决方案需求，为此，基于大量项目实施经验的基础上总结出的高科技行业解决方案支持企业在不同核心竞争能力上的提升，同时结合移动互联网技术基本可实现所有功能的移动化管理：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77669db001ab904b577e5cbafc136b9/" rel="bookmark">
			【实操记录】Oracle数据整库同步至Apache Doris
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是Oracle数据整库同步至Apache Doris实操记录，仅供参考
参考：https://cn.selectdb.com/blog/104
1、Oracle 配置 [root@node1 oracle]# pwd /u01/app/oracle [root@node1 oracle]# mkdir recovery_area [root@node1 oracle]# chown -R oracle:dba recovery_area SQL&gt; conn sys/ as sysdba 输入口令: 已连接。 SQL&gt; alter system set db_recovery_file_dest_size = 2G; 系统已更改。 SQL&gt; alter system set db_recovery_file_dest='/u01/app/oracle/recovery_area' scope=spfile; 系统已更改。 SQL&gt; SQL&gt; shutdown immediate; 数据库已经关闭。 已经卸载数据库。 ORACLE 例程已经关闭。 SQL&gt; startup mount; ORACLE 例程已经启动。 Total System Global Area 1068937216 bytes Fixed Size 2233344 bytes Variable Size 624954368 bytes Database Buffers 436207616 bytes Redo Buffers 5541888 bytes 数据库装载完毕。 SQL&gt; alter database archivelog; 数据库已更改。 SQL&gt; alter database open; 数据库已更改。 SQL&gt; archive log list; 数据库日志模式 存档模式 自动存档 启用 存档终点 USE_DB_RECOVERY_FILE_DEST 最早的联机日志序列 1 下一个存档日志序列 2 当前日志序列 2 SQL&gt; ALTER DATABASE ADD SUPPLEMENTAL LOG DATA; 数据库已更改。 SQL&gt; 2、Oracle 数据 SQL&gt; CREATE USER admin IDENTIFIED BY 123; 用户已创建。 SQL&gt; GRANT dba TO admin; 授权成功。 SQL&gt; quit; [root@node1 ~]# sqlplus admin/123 SQL*Plus: Release 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77669db001ab904b577e5cbafc136b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e7004dcc4aac2fa92c327651ae9f6e7/" rel="bookmark">
			ssh脚本找不到命令或者执行无效的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如图：今天在编写脚本时发现的这个问题，
在排除脚本语法错误、编码格式等情况下，仍然出现“bash 。。未找到命令”的字样
解决办法：
给每台虚拟机的环境变量source一下：
命令如下
source /etc/profile 或者输入
vim ~/.bashrc 在末尾加上
source /etc/profile 再用分发脚本分发一下
xsync ~/.bashrc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72420c91603b863902a9c21b6d23df14/" rel="bookmark">
			顶点着色器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		顶点着色器(vertex shader)是-一段运行在图形卡GPU中的程序，它可取代固定功能流水线中的变换和光照环节(当然，这也不是绝对的，因为在硬件不支持顶点着色器的情况下，Dict3D运行时就会用软件运算方式来模拟顶点着色器)
可以看出，顶点是以局部坐标（局部坐标系中的坐标）输入顶点着色器的，而且顶点着色器必须将照亮的（上色的）顶点输出到齐次裁剪空间中。由于顶点着色器其实就是我们用HLSL语言编写的一段定制程序，这样我们在可实现的图形效果上就获得了很大的灵活性。例如借助顶点着色器，我们就可使用任何可在顶点着色器中实现的光照算法。这样，我们就不再受制于Direct3D的固定功能流水线了。而且这种对顶点位置进行操作的能力具有广泛的应用场合，例织物模拟、粒子系统的点尺寸处理、顶点融合/变形技术(morphing)等。
此外，可用的顶点数据结构也更加灵活，而且可编程流水线中的顶点结构可以包含比固定功能流水线更加丰富的数据。顶点着色器仍然是一项相对比较新的特性，目前许多图形卡尚不支持该特性，尤其是伴随DirectX9发布的那些比较新的顶点着色器版本。您可通过检查D3DCAPS9结构的成员VertexShaderVersion并与宏D3DVS_VERSION进行比较，来检测您的图形卡是否支持某个顶点着色器版本。D3DVS_VERSION宏中的俩个参数分别表示主版本号和次版本号，目前D3DXCompileShaderFromFile函数支持的顶点着色器版本为1.1、2.0和3.0。
//If the device's supported version is less than version 2.0 if(caps.VertexShaderversion &lt; D3DVS_VERSION(2,0)) //Then vertex shader version 2.0 is not supported on this device 顶点声明 到月前为止，我们一直都在用灵活顶点格式(FVF)来描述顶点结构的分量。但是在可编程流水线中，顶点结构甚至可以包含那些超出FVF描述能力的数据。因此，我们通常使用描述能力更强、功能更丰富的顶点声明(vertex declaration)。
在可编程流水线中，如果顶点结构可用FVF来描述，我们仍可使用它。但是这仅仅是为了表示方便，实际上在可编程流水线内部，FVF最终将被转换为顶点声明。
顶点声明的描述 我们将顶点声明描述为一个D3DVERTEXELEMENT9类型的结构数组。该结构数组中的每个元素都描述了顶点结构的一个分量。所以，如果您的顶点结构具有3个分量（比如位置、法向量、颜色），则相应的顶点声明就可用一个维数为3的D3DVERTEXELEMENT9类型的结构数组来描述。
typedef struct _D3DVERTEXELEMENT9 { WORD Stream; // Stream index WORD Offset; // Offset in the stream in bytes BYTE Type; // Data type BYTE Method; // Processing method BYTE Usage; // Semantics BYTE UsageIndex; // Semantic index } D3DVERTEXELEMENT9, *LPD3DVERTEXELEMENT9; Stream：指定与顶点分量关联的数据流
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72420c91603b863902a9c21b6d23df14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ff90752c5ad8e7481279a437ad8b43/" rel="bookmark">
			原力CEO赵锐：ToDesk是国内唯一适合高精远程办公需求的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数字办公在各行业的渗透，远程办公也逐渐成为一种常态。2000多名艺术家员工遍布全球各地的江苏原力数字科技股份有限公司（下称：原力），是一家国内业务范围、规模均遥遥领先的数字业务内容提供商。一直以来，原力都依靠跨区域远程协同的方式进行创作和服务客户。这种数字图形图像远程协同的“生产”和“交付”方式，对远程办公软件有着极高要求。一年前，这家3D数字内容巨头突然做了个重大决定：用国产ToDesk替换原有海外远程办公软件。
ToDesk出自一家初创公司，它为何能迅速得到3D数字内容行业巨头的认可？ 01 缘起：“ToDesk是国内唯一适合高精远程办公需求的解决方案” 一个陌生拜访电话，引起了赵锐的注意。以技术出身的他没想到，国内居然也有企业在做远程办公协同软件。抱着了解看看的心态，原力CEO赵锐约见了久尺网络科技有限公司（下称：久尺网络）销售VP吴申立。这一见，赵锐就被ToDesk的技术突破力深深吸引，不久后便敲定了测试试用时间。
“我们一直用海外的一些产品。在使用过程中，其实有非常多限制，也有很多达不到我们需求的地方。”注重产品使用体验的赵锐，难以从国内外产品中找到适合图形图像远程创作的软件。毕竟真正保障图形图像传输时效和远程画面还原度的产品少之又少，而在保证真彩色前提下，实现50帧或者60帧刷新率，还支持多屏和手绘板等外设接入的产品更是难得。“可以说，ToDesk是我们当时能找到的，国内唯一适合高精远程办公需求的解决方案。”赵锐回忆道。
02 深耕：从“还不错”到“完美”的产品迭 赵锐坦言，测试久尺网络ToDesk时，他依旧处在一个将信将疑的心理状态。因为他不确定，这家国内公司的办事风格是否与海外公司一样，需要客户跟着产品走，任何使用问题和需求反馈都难以得到及时响应。久尺网络紧跟客户需求、快速迭代产品的强烈意愿，打消了赵锐的顾虑。历经近一年时间的合作打磨，久尺网络已经向原力交付了一套全面适用高精远程办公需求的解决方案。产品上线交付后，就为1500名普遍全球各地的艺术家带来了接近完美的远程办公体验。
这套方案除远程控制外，还融入了企业安全服务，在确保图形图像等高复杂数据实时传输的同时，能最大程度保证数据安全，便利企业统一管理。“ToDesk原始产品挺不错，加上久尺网络是家看重长远，愿意从客户需求角度去迭代产品的公司。所以，在未来5年、10年甚至更长的时间，我们会一直使用这套远程办公解决方案。”赵锐以“值得相信”的态度与行动，助力久尺网络这家本土创业公司完成了产品从“还不错”到“完美”的质变。
03 开拓：高精行业远程办公新视界 对于原力CEO赵锐的高度评价，久尺网络销售VP吴申立用“感恩”一词作为回应。在吴申立看来，为客户量身打造解决方案的过程虽然不轻松，会面临方方面面的压力，但这个持续的付出迎来了正向回报。“在服务原力的过程中，久尺网络发现了高精行业远程办公需求这一蓝海市场。”通过原力这个标杆项目的打磨，才有了今天的ToDesk企业版，以及包括勘探设计、汽车设计等行业在内的30万家客户的认可
远程控制一台电脑，打开并进行文档编辑仅是最基础的功能，久尺网络远程办公解决方案最大的亮点在于，它无限逼近真机的体验操作，尤其在图形图像制作、虚拟现实等高精领域的远程交互上有出色的表现。吴申立强调：“为进一步满足各行业客户的远程办公需求，久尺网络推出了Desktron云桌面。Desktron云桌面有别于传统云桌面，它继承了ToDesk远程协作的高性能核心优势，支持4K60FPS高清画质的流畅传输，可为游戏研发、工业仿真设计等高精行业用户提供与本地无差异的远程办公体验。"
04 展望：携手共创远程办公价值 远程办公的便利助推了不少企业的成长势能，近年来原力的人员规模、客户量都显著增长。赵锐希望原力能成为国际上领先的3D数字内容服务提供商。而实现这一企业发展愿景离不开原力完整的全链条服务能力，这其中就包括协同遍布全球的数千名艺术家，以及远程服务全球顶尖客户的能力。久尺网络将持续携手原力，通过不断优化产品，形成更贴合高精应用所需的远程办公解决方案，助力更多类似原力的本土企业成为行业佼佼者。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f2144adafa23c7df6277e6134ee1c58/" rel="bookmark">
			js 处理时间格式——可指定时区进行转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同时区，对时间进行格式化处理，获取为指定时区时间。
（注：new Date()不进行处理则获取到为本地时区的时间）
js
// 处理时间的方法 // 此处的i为8是北京东八区的时间，如果是西n区，则此处为：-n formate (data, format, i=8) { if (!data) { return '' } if (typeof data === 'string') { data = data.replace(/-/g, '/') } let d = new Date(data); //得到1970年一月一日到现在的秒数 let len = d.getTime(); //本地时间与GMT时间的时间偏移差 let offset = d.getTimezoneOffset() * 60000; //得到现在的格林尼治时间 let utcTime = len + offset; data = new Date(utcTime + 3600000 * i); if (!format) { return data } let o = { 'M+': data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f2144adafa23c7df6277e6134ee1c58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7602624108c3391a802a3367a0f3851/" rel="bookmark">
			国际腾讯云服务器自动断开连接且关闭进程原因与解决方案！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云服务器是一种可扩展的计算服务，它供给了可靠、安稳、安全的云根底架构，为用户供给了高效的应用部署和运转环境。然而，有时用户或许会遇到腾讯云服务器主动断开衔接且封闭进程的问题，这不仅会影响应用的正常运转，还会带来一系列的安全风险。本文将具体阐明这个问题的原因，并供给相应的解决方案。
原因一：网络问题腾讯云服务器主动断开衔接且封闭进程或许是因为网络问题导致的。例如，网络故障、网络推迟、网络带宽缺乏等都或许导致这个问题。解决方案是查看网络衔接，保证网络的安稳性和带宽。
原因二：服务器装备问题假如腾讯云服务器的装备不合理，也或许导致主动断开衔接且封闭进程。例如，系统资源缺乏、内存过低、CPU过高、磁盘空间缺乏等都或许导致这个问题。解决方案是查看服务器的装备，进行适当的调整。
原因三：应用程序问题假如应用程序存在严重的问题，也或许会导致腾讯云服务器主动断开衔接且封闭进程。例如，应用程序过错、应用程序溃散、应用程序被歹意攻击等都或许导致这个问题。解决方案是查看应用程序，修复应用程序的过错，并保证应用程序的安全性。
原因四：服务器运转环境问题假如服务器的运转环境有问题，也或许导致腾讯云服务器主动断开衔接且封闭进程。例如，操作系统版本过低、系统补丁未装置、系统病毒未铲除等都或许导致这个问题。解决方案是查看服务器的运转环境，进行适当的更新和整理。
原因五：腾讯云服务器服务问题假如腾讯云服务器的服务出现问题，也或许导致主动断开衔接且封闭进程。例如，腾讯云服务器的网络服务、存储服务、计算服务等出现问题，都或许导致这个问题。解决方案是联系腾讯云的客服，报告这个问题，并恳求帮助。
总的来说，腾讯云服务器主动断开衔接且封闭进程的问题，或许是由于网络问题、服务器装备问题、应用程序问题、服务器运转环境问题，或者是腾讯云服务器服务问题等导致的。针对不同的原因，需求采纳不同的解决方案。同时，用户也应注意定期查看服务器的状态，及时发现问题，并及时处理，以保证服务器的安稳运转。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1dace06c4dd41e0256e8e847886a38f/" rel="bookmark">
			国际阿里云服务器太慢怎么办？解决方法在这里！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		假如你在运用阿里云服务器时遇到速度慢的问题，这篇文章将为你供给处理方案。咱们将从硬件晋级、网络优化、服务器软件优化等多角度来探讨如何提高阿里云服务器的速度。
阿里云服务器是云计算的一种服务，它供给了各种计算、存储和网络服务。但是，许多用户在运用阿里云服务器时，会遇到服务器运转缓慢的问题。那么，当阿里云服务器运转速度太慢时，咱们应该如何处理呢？本文将从硬件晋级、网络优化、服务器软件优化等多个方面为你供给处理方法。
一、硬件晋级
服务器的运转速度不只取决于服务器软件，还取决于服务器的硬件。因而，假如阿里云服务器运转速度过慢，咱们首先要考虑的可能是服务器硬件的问题。
1.晋级CPU：假如服务器的CPU处理能力缺乏，可能会导致服务器运转速度慢。这时，咱们能够经过晋级CPU来提高服务器的运转速度。
2.晋级内存：假如服务器的内存缺乏，也可能会导致服务器运转速度慢。这时，咱们能够经过晋级内存来提高服务器的运转速度。
3.晋级硬盘：假如服务器的硬盘空间缺乏，也可能会导致服务器运转速度慢。这时，咱们能够经过晋级硬盘来提高服务器的运转速度。
二、网络优化
服务器运转速度还遭到网络环境的影响。假如网络环境差，可能会导致服务器运转速度慢。
1.优化网络装备：能够经过优化网络装备来提高服务器的网络速度。例如，能够添加网络带宽、优化网络路由等。
2.更新网络驱动：假如服务器的网络驱动过期，可能会导致服务器网络速度慢。这时，咱们能够经过更新网络驱动来提高服务器的网络速度。
3.运用CDN服务：假如服务器部署在地理位置偏僻的地方，可能会导致服务器网络速度慢。这时，咱们能够考虑运用CDN服务来提高服务器的网络速度。
三、服务器软件优化
服务器运转速度还遭到服务器软件的影响。假如服务器软件装备不合理，可能会导致服务器运转速度慢。
1.优化服务器软件：能够经过优化服务器软件来提高服务器的运转速度。例如，能够关闭不必要的服务器服务、优化服务器装备等。
2.晋级服务器软件：假如服务器软件版本过旧，可能会导致服务器运转速度慢。这时，咱们能够经过晋级服务器软件来提高服务器的运转速度。
3.运用性能剖析东西：假如服务器运转缓慢，咱们还能够运用性能剖析东西来找出服务器运转慢的原因。经过剖析东西，咱们能够更准确地找到问题所在，并针对性地进行优化。
总结，阿里云服务器运转速度太慢，咱们能够经过硬件晋级、网络优化、服务器软件优化等多角度来处理。只要找到问题的本源，才能有效地提高阿里云服务器的速度。希望本文能对你有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d538fca94c853a688791587e0700f4b7/" rel="bookmark">
			【ARFoundation学习笔记】点云与参考点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面的话
本系列笔记旨在记录作者在学习Unity中的AR开发过程中需要记录的问题和知识点。主要目的是为了加深记忆。其中难免出现纰漏，更多详细内容请阅读原文以及官方文档。
汪老师博客
文章目录 点云新建点云 参考点参考点的工作原理何时使用参考点使用参考点的注意事项 平面分类（补充） 点云 AR应用的目的是为用户加强对现实环境的体验，为用户带来真实性。因此AR应用需要理解所处的周围环境，知道哪里是垂直平面，哪里是水平平面。
点云是特征点的集合，特征点是指AR Foundation通过VIO检测捕获的摄像头图像中的视觉差异点，这些视觉差异点是从图像中明暗、颜色、灰度差异比较大的点中挑选出来的，AR Foundation会实时更新这些特征点。
在对图像的实时检测中，点云会不断获取特征点，一些特征点被删除，也有一些特征点被加入，通过算法获得那些比较稳定的特征点，这些稳定的特征点就会被机器视觉解析为特定的位置信息，那么只需计算特征点的变化就可以计算出物体在现实中位置的变化。
检测的特征点信息与设备IMU的惯性测量结果结合，不仅可以跟踪用户（手机设备）随着时间推移而相对于周围世界的姿态，还可以大致了解用户周边的环境结构。
在之前平面管理时我们提到，AR Plane上有个public的字段——特征点变化阈值来设定可接受的特征点的置信值。
由众多的特征点，就构成了点云，单个特征点不是Trackable的（但可以通过ID识别），而点云是Trackable的。
每个特征点都具有Vector3的Position信息，ulong类型的id，和float的置信度Confidence value。特征点的位置信息是Session空间中的坐标值，可以通过ARPointCloud.position来获取。id则通过ARPointCloud.identifiers来获取。置信度则表示了机器视觉对特征点识别的确信程度。
点云由AR Point Cloud Manager组件负责管理，该组件负责点云的创建以及特征点的创建、更新、移除。特征点检测的启用和禁用、特征点的显示和隐藏与平面处理方式完全一致。
点云数据可以辅助平面检测，更重要的是点云数据是环境重建的基础，这对AR理解环境非常关键。随着时间的延长，点云数据中的特征点会迅速增长，为了防止特征点过多而影响性能，点云中的总特征点必须要控制在一定的数值范围内，如ARCore将特征点的最大数限制在61 440个。
新建点云 点云的创建也很简单，类比于之前平面的创建流程。此后的一些物体的创建在ARfoundation中也都是类似的：
首先创建一个AR Default Point Cloud组件 然后将刚刚的AR Default Point Cloud组件做成预制件，在AR Session Origin上挂载一个AR Point Cloud Manager，根据我们之前的学习，AR Session Origin上处理的是Session空间上的姿态信息，所以要实例化Trackable物体的话，就需要把对应的Manager挂载在AR Session Origin上。
编译运行，找一个富纹理物体或表面，左右移动手机，这时AR Foundation会对特征点进行检测，效果如图所示。
本节所演示的点云数据会实时变化，置信值小的点云数据会被移除，新的点云数据会被加入，因此，如果希望保存所有检测到的点云数据，可以将这些数据存储在Dictionary或者List中，这对一些应用，如网格重建、遮挡实现会非常有用。
参考点 AR Foundation中的参考点（Reference Point）与ARCore中的Anchor或ARKit中的ARAnchor其实是同一概念，即锚点。由于跟踪使用的陀螺仪的特性，误差会随着时间积累，因此需要通过图像检测等方式对误差进行修正，如果已存在于空间上的对象不同步进行校正则会出现偏差。锚点的功能就是绑定虚拟物体与AR空间的位置。（类似于UGUI的锚点，以Anchor为中心去固定与其他空间的相对位置）
被赋予Anchor的对象将被视为固定在空间上的特定位置，并自动进行位置校正，因此锚点可以确保物体在空间中保持相同的位置和方向，让虚拟物体在AR场景中看起来待在原地不动。
参考点的工作原理 在AR应用中，虚拟物体在现实空间的姿态信息每帧都会更新，由于陀螺仪的误差累积，虚拟物体在应用中会出现飘移现象。如果将一个锚点固定在空间中，来计算虚拟物体相对于锚点的姿态信息，就可以避免位置的飘移，这个锚点就是参考点Reference point。然而还需要保证参考点在空间中的姿态能保持不变，也就是需要消除参考点的偏差。消除这个偏差的方法就是视觉校准技术，通过视觉校准来保证参考点在绝对空间中保持不变的位置与方向。
将参考点作为锚点，在绝对空间中的参考点姿态信息不变的前提下，保持参考点上连接的虚拟物体相对于这个锚点的姿态信息，就可以保证在每帧的实时更新中虚拟物体相对于现实世界空间的姿态变化，就像虚拟物体真的固定在了现实空间一样。
何时使用参考点 参考点是一种对资源消耗比较大的可跟踪对象，参考点的跟踪、更新、管理需要大量的计算开销，因此需要谨慎使用并在不需要的时候分离参考点。
作者对使用参考点的时机给出了几点建议：
一个参考点保持多个虚拟对象的相对位置，这样这些物体之间的位置关系就不会受到其他因素影响。保证虚拟物体的独立性。在前文中我们使用射线检测，在触碰到的平面物体上创建了预制体。通常情况下没有问题，但如果因为某些原因导致AR Plane Manager被禁用、平面被销毁或者隐藏，就会影响到以平面为参考的虚拟物体位置的稳定性，导致虚拟物体飘移。如果使用参考点来锚定物体，就能保持物体的独立性而不受到平面的影响。提高追踪稳定性。由于参考点需要独立追踪，因此能提高挂载在其上的物体的追踪稳定性。保持追踪对象与平面的相对位置稳定。使用AttachReferencePoint()方法可以将一个参考点与平面绑定起来，从而保持挂载在该参考点下的虚拟物体与平面保持关系一致。如在一个垂直平面上使用AttachReferencePoint()方法建立一个参考点（位置关系的传递，虚拟物体锚定平面位置，平面位置锚定参考点），在参考点更新时就会锁定x、z分量值，从而保持参考点与平面位置关系始终一致。 在AR Foundation中，AR Reference Point Manager提供了如表所示方法管理参考点：
方法描述AddReferencePoint(Pose)用给定的Pose添加一个参考点，Pose为世界空间中的姿态，返回一个新的ARReferencePoint。AttachReferencePoint(ARPlane, Pose)用给定的Pose创建一个相对于已检测到平面的ARReferencePoint，其中ARPlane是一个已检测到的平面，Pose为世界空间中的姿态。RemoveReferencePoint(ARReferencePoint)移除一个ARReferencePoint，如果移除成功则返回True，如果返回False通常意味着这个ARReferencePoint已经不在跟踪状态。referencePointsChanged在ARReferencePoint发生变化是触发的事件，如一个新的ARReferencePoint创建、对一个现存的ARReferencePoint进行更新、移除一个ARReferencePoint。 AddReferencePoint和AttachReferencePoint都是创建了新的参考点。但是又有所不同，从两个方法的名称不难看出，一个是新增参考点，一个是绑定参考点。新增的参考点位基于指定的Pose信息，并进行独立跟踪，如果Session变化时它可能会随之更新。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d538fca94c853a688791587e0700f4b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e598cbea8ad1beadf73696576d9798/" rel="bookmark">
			泛微E9，独立选择框对应数据库表查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		泛微E9，独立选择框对应数据库表查询 文章目录 泛微E9，独立选择框对应数据库表查询步骤一：准备姓名、姓名文本字段：步骤二：获取选择框字段的id：其他 需求描述：假如流程表单有两个字段，一个是独立选择下拉框（单选），一个是普通文本框，需要对选择框的选项自动赋值到文本框。
图例：比如前面选择姓名，自动把名字赋值到后面的文本字段，由于泛微OA选择框实际存储的是id，图例中张三对应：0，李四对应：1，王五对应2，直接获取姓名字段的值获取到的也是id，因此，此处可以通过插入js、字段属性两种方式解决，本文讲解字段属性。
步骤一：准备姓名、姓名文本字段： 步骤二：获取选择框字段的id： 直接点击选择框字段，在表单右下角显示的字段信息，field 后面的数字就是字段对应的 fieldid。
查数据库核对全部选项
select * from ecology.dbo.workflow_SelectItem where fieldid = 69818 核对完毕，对文本字段插入字段属性：
这样就完成了选择框字段的文本赋值。
其他 流程独立选择框对应数据库表：workflow_SelectItem
公共选择框查询
select * from workflow selectitem
select * from mode_selectitempage
select * from mode_selectitempagedetail
自定义字段选择框select * from cus selectitem
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2484169e321a0a9e9aa2f8fcf6902447/" rel="bookmark">
			80端口被占用问题根源解决 HTTP Error 404. The requested resource is not found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		80端口被占用问题根源解决 HTTP Error 404. The requested resource is not found. 命令netstat -ano | findstr "80"查询80端口的占用情况若是占用端口的进程号是4，根据localhost打开的提示HTTP Error 404. The requested resource is not found.搜索问题说是sql server导致的解决方法：停止SQL Server Reporting Services (MSSQLSERVER)就可以解决问题，
或者输入net stop ReportServer 参考链接：https://blog.csdn.net/u010042660/article/details/122187975
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/affba04fc1a5b7fa5dc7867749998a22/" rel="bookmark">
			Page分页records有数据，但是total=0，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Page分页records有数据，但是total=0，解决办法 问题：程序运行起来后，后端接收前端传来的搜索请求信息正常，但无法在前端正确反馈信息，通过在后端排查发现total一直等于零，但数据库中有数据，排查发现是Page有问题。
程序截图
解决方法
（1）先查看引用的mybatis-plus的版本；低于3.4.0的可先升级版本到3.4.0
（2）配置分页拦截器 @Configuration public class MybatisPlusConfig { // 旧版 @Bean public PaginationInterceptor paginationInterceptor() { PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); return paginationInterceptor; } // 最新版 @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } 主要是用最新的分页拦截器即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/343918ab2a01405243066fc85099c2e2/" rel="bookmark">
			机器学习代码遇到的问题（11.15）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AttributeError: 'Annotation' object has no property 'FontProperties' matplotlib版本与python不对应 改为3.3.4即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd7a7be7b731e8e1b020823c0aae1e2e/" rel="bookmark">
			JavaScript中的迭代方法和这些方法的重构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、迭代方法
1.forEach方法
2.every方法
5.map方法 二、重构迭代方法
1.重构forEach方法
2.重构every方法
3.重构some方法
4.重构filter方法
5.重构map方法
一、迭代方法 1.forEach方法 作用：循环遍历数组元素 for循环升级版 参数：function(item,index,arr){} 返回值：无 不修改原数组
var arr = ['tom','jack','larry','terry']; arr.forEach(function(item,index,arr){ /** * item---&gt;数组每一项 * index---&gt;数组每一项所对应的下标 * arr---&gt;数组本身 */ console.log(item,index,arr); }); 代码运行结果如下：
2.every方法 作用：检测数组元素是否符合表达式 只要有一项不符合直接返回false并且跳出循环 如果全部符合则返回true
参数：function(item,index,arr){} 返回值:true或者false 不修改原数组
var arr = [1,2,3,4,5]; var res = arr.every(function(item,index,arr){ console.log('every') return item&gt;0 }); console.log(res,arr); 代码运行结果如下：
3.some方法
作用：检测数组元素是否符合表达式 只要有一项符合返回true 跳出循环 全部不符合返回false
参数：function(item,index,arr){} 返回值：true或者false 不修改原数组
var arr = [1,2,3,4,5]; var res = arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd7a7be7b731e8e1b020823c0aae1e2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/132b89abaf4638624225edfdb3596fa2/" rel="bookmark">
			Linux （iSCSI、MariaDB、PXE/Kickstart）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十六、使用iSCSI服务部署网络存储 iSCSI 技术实现了物理硬盘设备与 TCP/IP 网络协议的相互结合，使得用户能够通过互联网方便地访问远程机房提供的共享存储资源。本章将带领大家在 Linux 系统上部署iSCSI 服务端程序，并分别基于 Linux 系统和 Windows 系统来访问远程的存储资源。 1.iSCSI技术介绍 硬盘是计算机硬件设备中重要的组成部分之一，硬盘存储设备读写速度的快慢也会对服 务器的整体性能造成影响。 硬盘存储结构、 RAID 磁盘阵列技术以及 LVM 技术等都是用于存储设备的技术，尽管这些技术有软件层面和硬件层面之分，但是它们都旨在解决硬盘存储设备的读写速度问题，或者竭力保障存储数据的安全。 为了进一步提升硬盘存储设备的读写速度和性能，人们一直在努力改进物理硬盘设备的接口协议。当前的硬盘接口类型主要有 IDE 、 SCSI 和 SATA 这 3 种。 IDE： 一种成熟稳定、价格便宜的并行传输接口。 SATA： 一种传输速度更快、数据校验更完整的串行传输接口。 SCSI：一种用于计算机和硬盘、光驱等设备之间系统级接口的通用标准，具有系统资源占用率低、转速高、传输速度快等优点。 无论使用什么类型的硬盘接口，硬盘上的数据总是要通过计算机主板上的总线与 CPU、内存设备进行数据交换，这种物理环境上的限制给硬盘资源的共享带来了各种不便。后来，IBM 公司开始动手研发基于 TCP/IP 协议和 SCSI 接口协议的新型存储技术，这也就是我们目前能看到的互联网小型计算机系统接口（ iSCSI ， Internet Small Computer System Interface）。这是一种将 SCSI 接口与以太网技术相结合的新型存储技术，可以用来在网络中传输 SCSI 接口的命令和数据。这样，不仅克服了传统 SCSI 接口设备的物理局限性，实现了跨区域的存储资源共享，而且可以在不停机的状态下扩展存储容量。 既然要通过以太网来传输硬盘设备上的数据，那么数据是通过网卡传入到计算机中的么？这就有必要向大家介绍 iSCSI-HBA 卡了 。与一般的网卡不同（连接网络总线和内存，供计算机上网使用）， iSCSI-HBA 卡连接的则是 SCSI 接口或 FC（光纤通道）总线和内存，专门用于在主机之间交换存储数据，其使用的协议也与一般网卡有本质的不同。运行 Linux 系统的服务器会基于 iSCSI 协议把硬盘设备命令与数据打包成标准的TCP/IP 数据包，然后通过以太网传输到目标存储设备，而当目标存储设备接收到这些数据包后，还需要基于iSCSI 协议把 TCP/IP 数据包解压成硬盘设备命令与数据。 总结来说，iSCSI 技术具有硬件成本低、操作简单、维护方便以及扩展性强等优势，为我们提供了数据集中化存储的服务，而且其以区块为单位的数据存储空间，在简化了存储空间管理步骤的前提下，还增添了存储空间的弹性。对于用户而言，仿佛计算机上多了一块新的“本地硬盘”，可以使用本地的计算机操作系统进行管理，就像是使用本地硬盘那样来使用远程存储空间。这种高扩展性和低组建成本、低维护成本的整合存储方式，正是大部分预算受限的中小企业和办公室所需要的。 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/132b89abaf4638624225edfdb3596fa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92411a22c0a31912b8a66b03fff16713/" rel="bookmark">
			Linux Windows相互下载 传输文件 scp命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【1】windows上操作 打开cmd
【2】linux下载文件到windows
scp -P 9000 username@101.10.190.192:/mnt/datadisk/username/project_n/00fastq_data/P_rep1_1.fastq.gz E:/project_n
把服务器的/mnt/datadisk/username/project_n/00fastq_data/P_rep1_1.fastq.gz下载到本地E:/project_n
参数p不一定要加，port默认为22
如果是文件夹，则为scp -r -P 9000 username@101.10.190.192:/mnt/datadisk/username/project_n/00fastq_data/ E:/project_n
【3】windows上传文件到linux
scp -P 9000 E:/project_n/test1111.txt username@101.10.190.192:/mnt/datadisk/username
把E:/project_n/test1111.txt上传到服务器/mnt/datadisk/username
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db817ee9e8199ff4578712f2930b6461/" rel="bookmark">
			vue3中的::v-deep深度选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是::v-deep？ scoped 属性是HTML5中的新属性，&lt;style&gt;标签在加上了scoped属性时，样式实现组件私有化，父组件的样式不会渗透到子组件，不会造成局部或全局的污染。这个时候如果你想让样式中的一个选择器作用得更深（渗透到子组件），可以使用深度选择器::v-deep。
2.举个栗子 在&lt;style&gt;中加了scoped属性后，子组件的内部元素不会自动增加 data-v-xxxx属性，我们直接修改element按钮里的文字样式时，这样写并不能生效，除非去掉scoped。
&lt;template&gt; &lt;el-row class="mb-4"&gt; &lt;el-button&gt;按钮&lt;/el-button&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;style lang="scss" scoped&gt; .el-button&gt;span { color: red; } &lt;/style&gt; 使用::v-deep，即可解决这个问题
&lt;template&gt; &lt;el-row class="mb-4"&gt; &lt;el-button&gt;按钮&lt;/el-button&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;style lang="scss" scoped&gt; ::v-deep(.el-button&gt;span) { color: red; } &lt;/style&gt; 还有写法2
:deep(.el-button&gt;span) { color: red; } 以前的写法，现在已不支持：
&gt;&gt;&gt; .el-button&gt;span { color: red; } 报错：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f845a32dc058760c4516d809ad58a553/" rel="bookmark">
			Android 8.1 persisten 应用通过安装方式更新升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近接到一个客户需求：
SystemUI 想通过安装的方式直接升级更新
但是systemUI 是有标记persistent=true ，无法正常安装，PMS会报错，因为这种应用死掉后会自启，无法杀死应用去重新安装app。
所以只能从系统源码下手 frameworks/base/services/core/java/com/android/server
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -6471,7 +6471,14 @@ public class ActivityManagerService extends IActivityManager.Stub
ProcessRecord app = apps.valueAt(ia);
if (app.persistent &amp;&amp; !evenPersistent) {
// we don't kill persistent processes
- continue;
+ if ( TextUtils.equals(app.processName, "com.android.systemui") )
+ {
+ Slog.w(TAG, "ignore persistent " + app.processName);
+ }
+ else
+ {
+ continue;
+ }
}
+++ b/services/core/java/com/android/server/pm/PackageInstallerSession.java
@@ -944,7 +944,15 @@ public class PackageInstallerSession extends IPackageInstallerSession.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f845a32dc058760c4516d809ad58a553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e88470f2c37542fdd5f46dea773d0ce0/" rel="bookmark">
			vue2富文本编辑---简单实现文字、图片、视频等功能可以同时编辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图： 1、安装 按照顺序执行 1、yarn add @wangeditor/editor # 或者 npm install @wangeditor/editor --save
2、yarn add @wangeditor/editor-for-vue # 或者 npm install @wangeditor/editor-for-vue --save
2、在对应使用页面加入 a、html: &lt;template&gt; &lt;div class="content-box"&gt; &lt;!-- 引入富文本编辑器 start --&gt; &lt;template&gt; &lt;div style="border: 1px solid #ccc;margin: 20px 20px 20px 30px;"&gt; &lt;Toolbar style="border-bottom: 1px solid #ccc" :editor="editor" :defaultConfig="toolbarConfig" :mode="mode" /&gt; &lt;Editor style="height: 500px; overflow-y: hidden;" v-model="html" :defaultConfig="editorConfig" :mode="mode" @onCreated="onCreated" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;!-- 引入富文本编辑器 end --&gt; &lt;/div&gt; &lt;/template&gt; b、js: 在&lt;script&gt;内引入组件和需要用的文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e88470f2c37542fdd5f46dea773d0ce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b8dfd8e87c7ecf6399b5d57d0ffbc99/" rel="bookmark">
			docker 安装xxl-job
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.拉取镜像
docker pull xuxueli/xxl-job-admin:2.4.0 2.docker镜像创建并运行 docker run -e PARAMS="--spring.datasource.url=jdbc:mysql://xxxxx:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;zeroDateTimeBehavior=CONVERT_TO_NULL --spring.datasource.username=root --spring.datasource.password=xxx" -p 8080:8080 -v /opt/xxljob:/data/applogs --name xxl-job-admin -d xuxueli/xxl-job-admin:2.4.0 --privileged=true --restart=always 3.参数解释
--privileged=true container内的root拥有真正的root权限 -v 目录挂载 左边主机日志目录，右边是容器内目录 -p 端口 左边宿主机 右边容器 4.查看启动结果
用户名 admin/123456
http://120.46.1.1:8080/xxl-job-admin 备注命令：
docker run -e PARAMS="--spring.datasource.url=jdbc:mysql://121.0.2.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;zeroDateTimeBehavior=CONVERT_TO_NULL --spring.datasource.username=root --spring.datasource.password=xxxx"
-p 8080:8080
-v /opt/xxljob:/data/applogs
--name xxl-job-admin -d xuxueli/xxl-job-admin:2.4.0 --privileged=true --restart=always
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19667290400e2ea3eefae4e687d0f607/" rel="bookmark">
			js[DOM、BOM、Ecmascript][记录]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js是由Dom、Bom 和 Ecmascript三个部分组成的，通常意义下我们所说的js语法其实指的是Ecmascript的各种语法。因此我们有必要去更多的了解下Bom和Dom
BOM BOM：全称Browser Object Model，即浏览器对象模型，提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。这个对象存在于浏览器本身的内置内容中，直接调用即可。
BOM提供了多个内置Browser对象：大概5个
Window 对象：表示浏览器打开的窗口，包括获取焦点、改变滚动条、设置定时器等等。
------Window 对象的方法可以直接使用
------在浏览器中Window是顶层对象：其他的如：Navigator、Screen 、–History 、Location 、Document都是其子对象。
------Window对象的所有属性和方法
Navigator 对象：包含浏览器信息。如：获取浏览器名称、版本信息、操作系统平台信息等等。
------Navigator对象的所有属性和方法
Screen 对象：包含屏幕信息。如：获取屏幕高度、宽度等等。
------Screen 对象的所有属性和方法
History 对象：可对当前页的浏览历史进行操作，如：前进、后退等。
------History 对象的所有属性和方法
Location 对象：可对当前页面的URL进行操作，如：导航到新的页面、获取URL信息等。
------Location 对象的所有属性和方法
DOM DOM：全程Document Object Model，即文档对象模型，是W3C组织推荐的处理可扩展标志语言的标准编程接口。DOM解决了Netscape的JavaScript和 Microsoft的JavaScript之间的冲突，给予web设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对象
DOM可以理解为HTML的一种访问和操作的标准接口。
1.Document对象 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。
Document 对象的所有属性和方法
2.标签元素及其属性和方法 在Html中标签即指元素节点。如：a、p、span标签等，每种标签都有各自的属性或者是共同的节点属性，如：a、p、span标签都有class属性来定义样式类名称，但只有a标签有：href节点属性来定义跳转。
公共的节点属性有：https://www.w3school.com.cn/jsref/dom_obj_attributes.asp元素节点，如html为最外层的根节点，而body则为html的子节点，节点是可以通过js进行操作的。操作方法有：https://www.w3school.com.cn/jsref/dom_obj_all.asp每个元素节点都有对应的事件句柄。如onclick、onchange
所有的事件句柄：
https://www.w3school.com.cn/jsref/dom_obj_event.asp 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/609f7fb2aad75e3cede0f9ce9fc52df3/" rel="bookmark">
			js[es6相较于es5常用内容整理]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		es6又称es2015，这个是es中的一个大版本的改变，因此相较于es5来说有了许多的变化。而后续的es6以上的版本通常是以年份来叫如es2015(es6)、es2016(es7)、es2017…
es6的具体新增内容可以参考阮一峰老师的：ECMAScript 6 入门
es6常用内容整理 1.新增块级作用域以及let、const常量变量命名 2.解构赋值 解构赋值即指将一种数据结构拆分为更小的内容单位，然后将其赋值给另一个结构类似的变量的过程，解构赋值可以用于许多的地方：数组、对象、字符串、数值、布尔值、函数参数等，不同的数据格式赋值的规则会有细微的差距
3.字符串、正则、数值、函数、数组、对象都有新的内容及方法的拓展 常用的拓展
------ 字符串
模板字符串（用反引号包裹,可放置变量${}等）新增字符串方法（includes()、startsWith()、endsWith()、endsWith()、padStart()、padEnd()、trimStart()、trimEnd()） ------ 正则
u/y修饰符新增一些相关属性和方法 ------ 数值
Number对象新增属性和方法方法(EPSILON、isFinite()、isNaN()、isInteger()、isSafeInteger())Math对象的一些方法拓展指数运算符 ------ 函数
函数参数可以指定默认值函数的name属性，返回该函数的函数名箭头函数（最明显的作用就是不改变this的指向） ------ 数组
拓展运算符新增静态方法（from()、of()）新增实例方法（copyWithin()、find()、findIndex()、fill()、entries()，keys()、values()、includes()、flat()、flatMap()、） ------ 对象
属性的简介表示发以及属性名表达式方法含有name属性新增对象遍历的方法super 关键字的使用链判断运算符Null 判断运算符新增方法（is()、assign()、fromEntries()、entries()、values()、keys()、setPrototypeOf()、getPrototypeOf()） 4.新的原始数据类型Symbol ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。目的是为了防止属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。
5.Set 和 Map 数据结构 可以看作类数组或者是类对象、Set 和 数组的区别是里面的内容唯一、Map和对象的区别在于键名是可以随意拓展
6.Proxy 代理器对象 ES6 为了操作对象而提供的新 API
在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因而可以对外界的访问进行过滤和改写。
7.Reflect ES6 为了操作对象而提供的新 API
Reflect对象的设计目的有这样几个。
（1）将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。（2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。（3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。（4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 8. Promise对象、async函数、Generator 函数 这三种都是ES6 提供的异步编程解决方案，基本使用方式参考：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/609f7fb2aad75e3cede0f9ce9fc52df3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb6f901fea5bef051d4599367ba73bb4/" rel="bookmark">
			Express基本接口开发-入门学习与后续进阶
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提推荐 任何一个新的知识都是从文档看起，因此express官方文档示例有必要去学习一遍。
推荐看：
推荐入门指南-路由指南-中间件 看完这几个内容之后心里大概知道express有些什么东西了，然后现在就可以去练习了
注意：更多示例-代码可以在了解基本的内容之后在去看去练习
第一步：了解Express应用程序生成器 项目说明
通过命令行执行之后会生成一个文件夹。现在了解该文件夹
1./bin/www (项目的启动配置文件，包含了启动端口配置，服务器错误与事件监听(这个文件夹完全可以不用管，端口为3000)
/public/ (一个公共静态数据文件夹，里面的images，javascripts，stylesheets都可以不管)
/routes/ (路由编写文件夹，这里面用来编写接口的)
/views/ (jade 数据模板文件夹，这个其实没啥用。如果仅仅只是开发接口的话完全可以删除掉，但是要注意删除或注释app.js 中的这两行
app.js 这是一个核心文件，中间件注册，路由注册等功能都在这个文件夹
package.json 包管理文件
第二步：连接数据库 npm install --save mysql
建立数据库连接文件
第三步：操作数据，使用最原始的sql拼接方式 user.js中如下
var express = require('express'); var router = express.Router(); var connection = require('./db/connection.js') /** * 单表增删查改处理 * // 多表联表类似，仅需拼接对应的sql即可 */ /* 查询用户列表数据 */ router.get('/list', function(req, res) { const { userName } = req.query let sql = `select * from sys_user` if(userName){ sql = sql + ` where user_name like '%${userName}%'` } // 执行sql语句查询sys_user表中所有数据，最纯粹的方式就是自己拼sql语句 try { connection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb6f901fea5bef051d4599367ba73bb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d224522560cc1314270a6d18869bc21f/" rel="bookmark">
			数据结构 | 单链表专题【详解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构 | 单链表专题【详解】 文章目录 数据结构 | 单链表专题【详解】链表的概念及结构单链表的实现头文件打印尾插头插尾删头删查找在指定位置之前插入数据在指定位置之后插入数据删除pos节点删除pos之后的节点销毁链表 源码 顺序表遗留下来的问题
中间/头部的插⼊删除，时间复杂度为O(N)增容需要申请新空间，拷贝数据，释放旧空间。会有不小的消耗。增容⼀般是呈2倍的增长，势必会有⼀定的空间浪费。例如当前容量为100，满了以后增容到
200，我们再继续插入了5个数据，后⾯没有数据插入了，那么就浪费了95个数据空间。 那么如何解决以上问题呢？
那这个时候我们就要开始我们的链表专题了~~
链表的概念及结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表
中的指针链接次序实现的 。
链表的结构跟火车车厢相似，淡季时车次的车厢会相应减少，旺季时车次的车厢会额外增加几节。只需要将火车里的某节车厢去掉/加上，不会影响其他车厢，每节车厢都是独立存在的。
车厢是独立存在的，且每节车厢都有车门。想象一下这样的场景，假设每节车厢的车门都是锁上的状态，需要不同的钥匙才能解锁，每次只能携带一把钥匙的情况下如何从车头走到车尾？
最简单的做法：每节车厢里都放一把下一节车厢的钥匙。
在链表里，每节“车厢”是什么样的呢？我们来看下面：
与顺序表不同的是，链表里的每节"车厢"都是独立申请下来的空间，我们称之为“结点/节点”
节点的组成主要有两个部分：当前节点要保存的数据和保存下一个节点的地址（指针变量）。
图中指针变量 plist保存的是第一个节点的地址，我们称plist此时“指向”第一个节点，如果我们希望plist“指向”第二个节点时，只需要修改plist保存的内容为0x0012FFA0。
为什么还需要指针变量来保存下一个节点的位置？
链表中每个节点都是独立申请的（即需要插入数据时才去申请一块节点的空间），我们需要通过指针变量来保存下一个节点位置才能从当前节点找到下一个节点。 结合前面学到的结构体知识，我们可以给出每个节点对应的结构体代码：
假设当前保存的节点为整型：
struct SListNode { int val; struct SListNode* next; } 当我们想要保存一个整型数据时，实际是向操作系统申请了一块内存，这个内存不仅要保存整型数据，也需要保存下一个节点的地址（当下一个节点为空时保存的地址为空）。
当我们想要从第一个节点走到最后一个节点时，只需要在前一个节点拿上下一个节点的地址（下一个节点的钥匙）就可以了。
给定的链表结构中，如何实现节点从头到尾的打印？
思考：当我们想保存的数据类型为字符型、浮点型或者其他自定义的类型时，该如何修改？
补充说明：
1、链式机构在逻辑上是连续的，在物理结构上不一定连续
2、节点一般是从堆上申请的
3、从堆上申请来的空间，是按照一定策略分配出来的，每次申请的空间可能连续，可能不连续
单链表的实现 我们老样子，先来定义结构体，要用的头文件引入~~
头文件 SList
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;assert.h&gt; #include&lt;stdbool.h&gt; typedef int SLNDataType; typedef struct SListNode { SLNDataType val; struct SListNode* next; }SLNode; 我们要实现哪些功能呢？
//打印 void SLTPrint(SLNode* phead); //尾插 void SLTPushBack(SLNode** pphead, SLNDataType x); //头插 void SLTPushFront(SLNode** pphead, SLNDataType x); //尾删 void SLTPopBack(SLNode** pphead); //头删 void SLTPopFront(SLNode** pphead); //查找 SLNode* SListFind(SLNode** phead, SLNDataType x); //在指定位置之前插入数据 void SLTInsert(SLNode** pphead, SLNode* pos, SLNDataType x); //删除pos节点 void SLTErase(SLNode** pphead, SLNode* pos); //在指定位置之后插入数据 void SLTInsertAfter(SLNode* pos, SLNDataType x); //删除pos之后的节点 void SLTEraseAfter(SLNode* pos); //销毁链表 void SListDesTroy(SLNode** pphead); 好接下来我们开始实现~~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d224522560cc1314270a6d18869bc21f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6545eb20ebb2937ecaf1edf61ea96e51/" rel="bookmark">
			H5 HTML 移动端触摸拖拽drag drop 自定义拖拽样式 使用PointerEvent模拟的拖拽方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 原生的drag事件有许多诟病，
比如拖拽时跟随鼠标指针的那个元素样式过分简陋。比如dataTransfer在除start和drop外无法访问，从而让drop元素无法很好的判断是否接受drop比如无法优雅的设置拖拽过程中的鼠标指针。。。。比如不支持触摸。。。。 处于对多输入设备的兼容及花里胡哨的功能，我需要模拟一套drag和drop事件以实现需求。
这期主要是想安利一波我探索出的一种模拟浏览器原生的拖拽元素方案，兼容各种输入设备（PC/移动端适配）
PointerEvent 如今能跑网页的设备除了电脑，还有手机/平板等,其输入方式可能是鼠标/触摸/数位板或者什么的…
PointerEvent便是为此而生.
它的宗旨是为多种输入设备提供统一的事件模型.已是W3C标准的一部分。
现阶段各大浏览器都可以兼容.有关其详细文档请戳《MDN 指针事件》或《整合鼠标、触摸 和触控笔事件的Pointer Event Api》
我们先来看一下它提供了哪些事件 onpointerdown //元素的一个点被按下，可能是鼠标/触摸/压感笔onpointermove //元素上某点被移动onpointerup //元素的某点抬起 onpointerenter//某点进入了元素范围内（包括超出尺寸的子元素）,且没有遮挡。onpointerleave //某点离开了元素范围内（包括超出尺寸的子元素）,且没有遮挡。 onpointerover //元素自身或子元素某点进入事件，可通过e.target区分onpointerout //元素自身或子元素某点离开事件，可通过e.target区分 onpointercancel //当元素被按下，且浏览器认为该事件不会再有后续事件发生的时候触发.比如触摸过程手机锁屏，输入点过多等一些意外情况导致的中断(部分浏览器暂未支持) 我为你提供了一个测试页面，它几乎包含了所有可能出现的情况，
这可以帮助你更好的理解事件的触发机制!其源码放在了最后。
Codepen - PointerEvent触发机制测试 开始 有了上述事件以后，你大概会考虑使用down move up来实现模拟drop的逻辑。
let div = document.querySelector('#a'); div.addEventListener('pointerdown', (e) =&gt; { document.addEventListener('pointerup', pointerup); document.addEventListener('pointermove', pointermove); document.addEventListener('pointercancel', pointerup); function pointerup(e) { document.removeEventListener('pointerup', pointerup); document.removeEventListener('pointermove', pointerup); document.removeEventListener('pointercancel', pointerup); } function pointermove(e) { } }); 这样很好，简单的拖拽事件完成了。
此时你可能会思考着给每个需要drop的对象注册enter和leave事件，并搞一个全局变量来标记当前激活的drop对象,并在up的时候判断这个变量。
是的，你可以这么做。对于简单的拖拽来说这足够了。
设置指针样式 但如果你需要实现一个跟随鼠标的元素并设置拖拽过程的鼠标指针样式，你就无法使用pointer-events: none来将跟随元素穿透,这会导致需要drop的元素无法触发相关事件.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6545eb20ebb2937ecaf1edf61ea96e51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e77373cfad6573aa180fe709b9701eff/" rel="bookmark">
			C#调用curl命令，C#无法获取curl输出解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#通过进程调用curl命令，可以形成成功，但是curl输出C#应用无法获取解决，导致curl执行成功与否无法知道。
解决方法：
可以C#调用批处理，批处理再调用curl，curl加上参数–stderr，将输出定向到文件，在通过 type命令将输出文件显示，C#就可以获取curl输出结果。
C#代码：
private int ExeUpLoadFile(TextBox resulttxtbox)
{
int ret = 0;
string workingFolder = System.IO.Directory.GetCurrentDirectory();
string curlcmd = workingFolder + “\plugin\curl” + “upload.bat”;
string cmdarg = this.UserNameTextBox.Text + " " + this.PasswordTextBox.Text + " " +
this.DeviceIPTextBox.Text + " " + this.UpdateFileTextBox.Text;
//创建进程对象
Process tmpprocess = new Process();
tmpprocess.StartInfo.FileName = curlcmd;//设定需要执行的命令
tmpprocess.StartInfo.Arguments = cmdarg;
tmpprocess.StartInfo.UseShellExecute = false;//不使用系统外壳程序启动
tmpprocess.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
tmpprocess.StartInfo.RedirectStandardInput = true;//不重定向输入
tmpprocess.StartInfo.RedirectStandardOutput = true; //不重定向输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e77373cfad6573aa180fe709b9701eff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02d265eb2f30bbf3d7bf391260464087/" rel="bookmark">
			C语言简易小游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、猜数字游戏二、旋转光标三、多个字符从两端移动，向中间汇聚四、恶搞：关机小程序五、闪烁的五彩爱心六、扫雷七、三子棋 前言 本篇博客将带领大家自己动手写一下一些C语言小游戏；以增加对于C语言的兴趣😀😀😀😀😀
一、猜数字游戏 首先呢我们先来简单介绍一下这个小游戏：
通常由两个人玩，一方出数字，一方猜。出数字的人要想好一个没有重复数字，不能让猜的人知道。猜的人就可以开始猜。
如正确答案为576，而猜的人猜的56，则我们可以给猜的人一点提示，告诉他猜小了；如果猜的人猜的人为999，则我们可以给猜的人一点提示，告诉它猜大了；直到猜中为止；😀😀😀。
分析：
1、既然需要猜数字，我们玩家就不能知道，电脑就得随机产生一个值给我们猜；
2、既然需要随机值，我们可以调用rand（）函数来生成随机值；
rand能生成随机数的范围是0~RAND_MAX;
RAND_MAX是多少呢？
于是我们来测试一下，看是否真能生成随机数；
经过我们多次测试，发现rand一直生成41，没变过，并没有生成随机数；这就很令人费解，rand生成的真的是随机数吗？
实际上，rand函数是对一个叫做“种子”的基准值加以运算来生成随机数的。之所以先前每次都会生成相同的一个数，就是因为rand函数默认的种子常量是1.要生成不同的随机数，就必须改变种子的值；
而改变这个的就是需要srand函数来实现；
比如我们调用srand（2），就会以2为基准生成随机数；但是一旦种子确定了，生成的随机数也就确定了，
因此我们必须把种子值本身从常量变成随机数，然而我们为了生成随机数而需要随机数，这本身就很矛盾；
我们一般的解决办法是：把运行程序的时间当作种子；
这里有用到了time函数
简单介绍下：
运行结果：
至此我们解决了如何生成随机数的问题；
3、如何控制范围？
为了减小游戏难度，我们得控制住所生成数字的范围：
一般方法只需：b+rand()%(a+1)//生成大于等于b且小于等于b+a的随机数；
至此思路已经大致理顺；
接下来我们就可以用代码实现了：
#include&lt;time.h&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; enum GAME//利用枚举常量表示，使代码可读性更高； { EXIT,//默认从0开始，后面依次递增 PLAY, }; void menu()//简单写个菜单增加给予玩家良好的界面； { printf("+******* 猜数字游戏(1~100) *******+\n"); printf("l************ 1.PLAY *************l\n"); printf("l************ 0.EXIT *************l\n"); printf("+*********************************+\n"); } void game() { int key = rand() % 100 + 1;//生成1~100的随机数 int val = 0;//我们猜的数； while (1)//利用死循环，给玩家无线猜的机会； { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02d265eb2f30bbf3d7bf391260464087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d1c52b1a7340710d7230b7acc521b34/" rel="bookmark">
			安装pytorch步骤及遇到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装pytorch
步骤参考：【最新】2021.10.17 conda安装pytorch 1.8（【最新】2021.10.17 conda安装pytorch 1.8_conda install pytorch1.8.0 torchvision0.9.0 to_MUKCHAN的博客-CSDN博客）
安装过程中遇到的问题：
（1）Conda安装卡在solving environment这一步
解决办法：采用阿里云的镜像源，试了清华源和中科大的解决不了
首先恢复默认源：conda config --remove-key channels
输入阿里源：
conda config --add channels http://mirrors.aliyun.com/anaconda/pkgs/main
conda config --add channels http://mirrors.aliyun.com/anaconda/pkgs/r
conda config --add channels http://mirrors.aliyun.com/anaconda/pkgs/msys2
conda config --set show_channel_urls yes
（2）验证pytorch时出现如下错误
numpy和pytorch版本不匹配的问题
解决办法：用bard或者new bing搜一下对应的版本
(1)卸载numpy: pip uninstall numpy
(2)安装对应版本的numpy：pip install numpy==1.24
验证成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac4b663decf4a5419c45b21cdfe0528c/" rel="bookmark">
			Axure基础详解二十：中继器随机抽奖效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 效果演示 组件 一、中继器
建立一个“中继器”内部插入一个“正方形”，给“正方形”添加一个【样式效果】&gt;&gt;【选中状态】填充背景为红色，字体白色。在中继器表格中插入两列数据函数：【xuhao】(序号列，按12345……填写，用来实现随机抽取时的位置；)和【xuanzhong】(只用于报税抽奖过程中的选中状态。0代表未被选中，1代表被选中，默认值为1；)中继器布局：为【横向】水平分布，每行项目数为3。 二、“开始抽奖”按钮
全局变量 设置两个【全局变量】
xuanzhongxuhao : 表示被选中的位置序号，用于记录闪烁的位置，默认值为1。quanshu：用于记录抽奖轮回闪烁的次数。 交互设置 一、页面载入时交互 【设置变量】“quanshu"为“[[Math.floor(Math.random()*9+18)]]”（【random()】函数表示获取一个0-1之间的数；*9是为了在序号1-9中随机抽取一个；+18表示先让抽奖效果闪烁两遍；【floo()】函数表示向上取整。）
二、中继器每项加载时交互 【设置文本】将item.xuhao的值设置给中继器里的“正方形”的文本；
【设置选中状态】当“xuanzhong”的值为0时：“正方形”选中状态为“假”；当“xuanzhong”的值为1时：“正方形”选中状态为“真”。
三、“抽奖按钮”单击时交互 “抽奖按钮”单击时交互有三种判断条件
1、当“xuanzhongxuhao≥1”和“xuanzhongxuhao≤dataCount”和“quanshu&gt;0”三个条件共同满足时（【dataCount】变量表示“中继器”最大行数。）
【禁用按钮】鼠标单击按钮以后，我们要首先禁用掉当前按钮，为了防止重复点击而出现的问题。【标记行】标记中继器里的所有行，然后更新已标记的行，即更新所有行，将所有行里面的xuanzhong列的值都改为0，目的是将全部“正方形”的设置未被选中状态。【更新行】更新的【规则】逻辑是当【“xuhao”==“xuanzhongxuhao”】，将这一行的xuanzhong列的值更新为1。这样就可以保证每次只会选中1个，而且选中这个之后又会自动设置记录文本+1，从而实现循环。【等待】设置一个等待的时间，即每个“正方形”选中显示蓝色背景的时间，为200毫秒。【设置变量】设置“xuanzhongxuhao”为他原来的值+1，代表当前“正方形”已经闪烁完成了，记录下一个要闪烁的“正方形”的序号；设置“quanshu”为他原来的值-1，代表刚开始随机出来的闪烁次数不断减小。【触发事件】触发当前“抽奖按钮”鼠标单击时事件实现循环。例如刚开始随机出来的数字是20，那么他就会一直不断的循环在转，20到19到18……到0，才会停止。 2、当“xuanzhongxuhao&gt;dataCount"（【dataCount】变量表示“中继器”最大行数。）
【设置变量】设置“xuanzhongxuhao”为1，表示重头开始。【触发事件】触发当前“抽奖按钮”鼠标单击时事件实现循环。 3、当“quanshu=0”时
【触发事件】触发页面载入时事件，重置随机次数；【设置变量】“xuanzhongxuhao”为1，表示重头开始；【启用按钮】完成一轮抽取，得到结果，重启按钮。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bf401e0f40b8d38078bca54d3a3f498/" rel="bookmark">
			学妹教我区块链【2】--区块链中的数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哈希指针 在区块链中，哈希指针（Hash Pointer）是一种指向数据块（通常是前一个区块）的指针，哈希指针和普通指针不同的地方在于哈希指针除了保存前一个链表元素的地址还保存了前一个指针的hash值。哈希值是通过对数据块进行哈希运算得到的固定长度的字符串，这个哈希值是数据块内容的“指纹”。
区块链是由一系列区块组成的分布式数据库，每个区块包含一些交易或其他信息，以及前一个区块的哈希值。这种设计形成了一个不可篡改的链条，因为每个区块的哈希值都依赖于前一个区块的内容。如果尝试更改任何一个区块的数据，将会导致该区块的哈希值发生变化，从而破坏了整个链的一致性。
默克尔树（merkle tree） 默克尔树（Merkle tree）是一种哈希二叉树，由一个根节点、一组中间节点和一组叶节点组成。最下面的叶节点包含存储数据或其哈希值，每个中间节点是它的两个孩子节点内容的哈希值，根节点也是由它的两个子节点内容的哈希值组成。
比特币是最早引入区块链技术的应用之一。在比特币的区块中，交易数据不是直接放置在区块中，而是被组织成一个默克尔树的结构。这种安排的一个重要原因是提高交易验证的效率。
默克尔树的叶节点包含了每笔交易的哈希值，中间节点是它们两两组合的结果，而根节点的哈希值则是由左右两个子节点的哈希值组合而成。这样的设计使得验证某一笔交易是否包含在区块中变得高效。通过对比交易的哈希值和默克尔树根节点的哈希值，可以快速验证交易的完整性，而无需遍历整个区块的所有交易。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9403acbcd553b6505c405e75fa50696b/" rel="bookmark">
			tensorflow 1.15 gpu docker环境搭建；Nvidia Docker容器基于TensorFlow1.15测试GPU；——全流程应用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言: TensorFlow简介 TensorFlow 在新款 NVIDIA Pascal GPU 上的运行速度可提升高达 50%，并且能够顺利跨 GPU 进行扩展。 如今，训练模型的时间可以从几天缩短到几小时
TensorFlow 使用优化的 C++ 和 NVIDIA® CUDA® 工具包编写，使模型能够在训练和推理时在 GPU 上运行，从而大幅提速
TensorFlow GPU 支持需要多个驱动和库。为简化安装并避免库冲突，建议利用 GPU 支持的 TensorFlow Docker 镜像。此设置仅需要 NVIDIA GPU 驱动并且安装 NVIDIA Docker。用户可以从预配置了预训练模型和 TensorFlow 库支持的 NGC (NVIDIA GPU Cloud) 中提取容器
CPU擅长逻辑控制、串行计算，而GPU擅长高强度计算、并行计算。CUDA是NVIDIA推出用于自家GPU的并行计算框架，cuDNN &amp; tensorflow是一系列机器学习，深度学习库，用于训练机器学习、深度学习模型
2. 依赖环境准备
选取centos7.3作为基础操作系统镜像，选取适配驱动：Nvidia
GPU部署预装机器
深度学习框架：cuda、cudnn、tensorflow
由于cuda、cudnn、tensorflow等机器学习、深度学习框架，依赖python3，需要在centos7.3操作系统中集成python3
一、 nvidia-docker的安装cpu架构：x86 受够了TensorRT+cuda+opencv+ffmpeg+x264运行环境的部署的繁琐，每次新服务器上部署环境都会花费很大的精力去部署环境，听说nvidia-docker可以省去部署的麻烦，好多人也推荐使用docker方便部署，咱也在网上搜索了下，学习了下，根据网上的资料，开始安装docker学习一下，把学习记录记在这儿，听说要想使用GPU，就要安装Docker-CE和NVIDIA Container Toolkit，好的，开始。
1. 安装Dokcer-CE
首先，我的机器上没有安装过docker,要先把docker安装上,执行以下脚本，开始安装。
curl https://get.docker.com | sh \ &gt; &amp;&amp; sudo systemctl --now enable docker 安装结束后，查看Docker版本：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9403acbcd553b6505c405e75fa50696b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/144bf981c678d792d986c3b3f40ba35e/" rel="bookmark">
			vue通过span-method合并列之后，合并列显示在中间位置，根据鼠标滑动跟随展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当vue通过span-method合并列之后，出现的合并列显示在中间位置，但是如果页面没有分页，如何进行展示呢，难道要滑到最下面去看吗，下面我们来根据鼠标滑动跟随展示
没有处理的合并页面
&lt;template&gt; &lt;el-table :data="tableData" :span-method="objectSpanMethod" border style="width: 100%; margin-top: 20px"&gt; &lt;el-table-column prop="id" label="ID" width="180"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; 处理之后的合并页面
&lt;el-table-column prop="id" label="ID" class-name="ssi-col" width="180"&gt; &lt;template slot-scope="props"&gt; &lt;div class="ssi-info"&gt; &lt;span &gt;{{ scope.row.id }}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-table-column&gt; 理论上是
给td层加height:1px,给cell加visible之类，给内部span加position：sticky
css样式如下
&lt;style long="scss"&gt; .ssi-col { height: 1px; .cell { position: relative; height: 100%; overflow: visible; }.ssi-info{ position: sticky; top: 45%; } } 结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67db20d16abda61f9462264a5f7c7f7c/" rel="bookmark">
			欢迎使用Markdown编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
检查列表：Ctrl/Command + Shift + C
插入代码：Ctrl/Command + Shift + K
插入链接：Ctrl/Command + Shift + L
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67db20d16abda61f9462264a5f7c7f7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b508e67a9e7f74ce01a3deb2a95d936/" rel="bookmark">
			MyBatis批量更新(updateBatch) ，批量插入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更新多条数据，每条数据都不一样 通常有两种解决方法：
1) 在业务代码中循环遍历逐条更新。 2) 一次性更新所有数据（更准确的说是一条sql语句来更新所有数据，逐条更新的操作放到数据库端，在业务代码端展现的就是一次性更新所有数据）。 逐条更新（java实现） updateBatch(List&lt;MyData&gt; datas){ for(MyData data : datas){ try{ myDataDao.update(data);//更新一条数据，mybatis中如下面的xml文件的update } catch(Exception e){ ...//如果更新失败可以做一些其他的操作，比如说打印出错日志等 } } } //mybatis中update操作的实现 &lt;update&gt; update mydata set ... where ... &lt;/update&gt; 这种方式最大的问题就是效率问题，逐条更新，每次都会连接数据库，然后更新，再释放连接资源（虽然通过连接池可以将频繁连接数据的效率大大提高，抗不住数据量大），这中损耗在数据量较大的时候便会体现出效率问题。这也是在满足业务需求的时候，通常会使用上述提到的第二种批量更新的实现
逐条更新(mybatis实现) 通过(foreach标签实现)
要实现批量更新，首先得设置mysql支持批量操作，在jdbc链接中需要附加&amp;allowMultiQueries=true属性才行
jdbc:mysql://localhost:3306/dbname?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true &lt;update id="updateBatch" parameterType="java.util.List"&gt; &lt;foreach collection="list" item="item" index="index" open="" close="" separator=";"&gt; update course &lt;set&gt; name=${item.name} &lt;/set&gt; where id = ${item.id} &lt;/foreach&gt; &lt;/update&gt; foreach 元素的属性主要有 item，index，open，separator，close，collection。
属性描述collection表示迭代集合的名称，可以使用@Param注解指定， 该参数为必选item表示本次迭代获取的元素，若collection为List、Set或者数组，则表示其中的元素；若collection为map，则代表key-value的value，该参数为必选open表示该语句以什么开始，最常用的是左括弧’(’，注意:mybatis会将该字符拼接到整体的sql语句之前，并且只拼接一次，该参数为可选项close表示该语句以什么结束，最常用的是右括弧’)’，注意:mybatis会将该字符拼接到整体的sql语句之后，该参数为可选项separatormybatis会在每次迭代后给sql语句append上separator属性指定的字符，该参数为可选项index在list、Set和数组中,index表示当前迭代的位置，在map中，index代指是元素的key，该参数是可选项。 sql批量更新 原始sql 批量更新语句
update mydata_table set status = case when id = #{item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b508e67a9e7f74ce01a3deb2a95d936/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6950890cc661a2284f981dd807d8c6d6/" rel="bookmark">
			混合开发(Android原生与H5交互) 说明文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 目前，比如微信、QQ、淘宝、京东、知乎、各大银行App等大量软件都内嵌了部分H5。Android与H5（JS）互调可以让我们实现混合开发。混合开发就是在一个APP中内嵌一个轻量级的浏览器，一部分原生的功能改为Html5来开发。
拿微信举例：微信属于以原生为主，H5为辅，App大部分页面用原生完成，小部分用WebView加载H5的模式。
原理：就是Java代码和JavaScript之间的调用。
什么时候使用Native，什么时候使用H5呢？
1.Web的优势 在图文排版，很适合做辅助。
例如 页面功能时效性短，更新快 就很适合H5;
H5还可以降低更新频率，尤其是格式比较丰富（如字体多样等）的展示界面，的H5会比较方便。用H5，维护起来更容易 只需要服务器更新就行。
2. 原生的优势在于缓存、APP反应速度、网络、调用硬件这几方面。即使无网/离线或弱网环境依然满足用户，还有硬件的支持。
例如：登录和注册等基础功能,或者存在弱网络环境，可能会等半天还没加载出页面的情况。所以使用Native开发会快一些。
如果讲究APP 反应速度（含页面切换流畅性），则选用原生开发，因为H5其本质是网页，换页时，基本要加载整个页面，就像是浏览器打开一个新页面一样，显得较慢，而原生系统则只加载变化部分。
如果APP对有无网络、网络优劣敏感（譬如有离线操作，在线操作），那么，选用原生开发。
如果APP需要频繁调用硬件（摄像头、麦克风、检测仪等）那么，选用原生开发，这样支持硬件更多，更容易扩展，且调用速度更快。
方案考量：
考虑到用户体验和性能的情況下，可以结合实际 部分模块采用混合开发方案。
如图：
App混合开发（Hybrid app）
混合开发的App，就是混合了原生技术与Web技术进行开发的移动应用。本质上，是在原生的 App 中使用 WebView 作为容器直接承载 Web页面。
通俗来讲就是：开发者在原生APP代码里面挖一个洞，用来响应网页传给原生APP的指令和发送原生APP给网页的指令的接口。
被取代的部分功能可以享有h5在开发时程上的优势，又不影响全面的原生体验，这样一来，就可以做到 在不升级App的情况下动态更新。
历史开发经验中涉及 混合开发的模块 举例：
1.货运项目：对Banner对应的活动页、裂变模块、平台入驻、三方(油卡、保险、ETC、金融等)
2.电商项目：商品详情的介绍、积分玩法、个人中心等
3.其他：比如 IM项目等
使用(罗列一下双方的基础数据通信)：
加载方式有两种：
一种是加载服务器的H5页面
一种是加载本地的H5页面
加载服务器H5: 使用简单，只要load一下URL就可以。必要时也可通过URL拼接数据传基础参。
加载本地的H5页面，需要将H5页面存放在本地，包括关联的CSS和JS文件，这种方式相对服务器H5加载要复杂一些，但是加载速度会更快。
移动端：
WebView控件的加载方法：
//方式一：加载assets文件夹下的js_java_interaction.html页面 webView.loadUrl("file:///android_asset/js_java_interaction.html"); //方式二：加载网页 //webView.loadUrl("http://www.baidu.com"); WebSettings的基础设置：
//Android如何调用H5（JS）中的方法 //想要调用JS方法，那么必须让webView支持 WebSettings webSettings=mWebView.getSettings(); //设置为可调用js方法 webSettings.setJavaScriptEnable(true); webView.setWebViewClient(new WebViewClient()); webView.setWebChromeClient(new WebChromeClient()); 有返回值时： H5（JS）代码 简单举例：
//有参有返回值的方法 function sum(a,b) { &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6950890cc661a2284f981dd807d8c6d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d71231eefd7c2db4d990407eee284ea/" rel="bookmark">
			国际站腾讯轻量级云服务器是什么、如何使用及优势？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着云计算的不断发展，越来越多的企业和个人开始运用云服务器。腾讯轻量级云服务器是腾讯公司推出的一款轻量级云服务器产品，以其高性价比、简略易用、灵敏扩展等优势，受到了广阔用户的喜欢。本文将具体解析腾讯轻量级云服务器是什么、怎么运用及优势。
腾讯轻量级云服务器是什么？
腾讯轻量级云服务器是腾讯公司推出的一款云服务器产品，它采用最新的云计算技术，供给了高效稳定的计算才能。腾讯轻量级云服务器能够依据用户的需求进行灵敏扩展，能够满意用户的各种运用需求。同时，腾讯轻量级云服务器还供给了丰厚的安全防护办法，能够确保用户的数据安全。
怎么运用腾讯轻量级云服务器？
运用腾讯轻量级云服务器十分简略，用户只需求经过腾讯轻量级云服务器的办理界面，就能够轻松地创立、办理和运用云服务器。在创立云服务器时，用户只需求选择需求的装备，然后提交订单，等待服务器创立完结即可。在运用云服务器时，用户能够经过腾讯轻量级云服务器的办理界面，远程操控和办理云服务器，包含启动、停止、重启、装备等操作。
腾讯轻量级云服务器的优势
1.高性价比：腾讯轻量级云服务器的价格十分亲民，比市场上其他的云服务器产品要便宜许多，十分合适预算有限的企业和个人运用。
2.简略易用：腾讯轻量级云服务器的操作界面十分简略，用户只需求按照提示操作，就能够轻松地创立、办理和运用云服务器。
3.灵敏扩展：腾讯轻量级云服务器能够依据用户的需求进行灵敏扩展，能够满意用户的各种运用需求。
4.安全防护：腾讯轻量级云服务器供给了丰厚的安全防护办法，能够确保用户的数据安全。
5.高可用性：腾讯轻量级云服务器采用了最新的云计算技术，供给了高可用性的服务，能够确保用户的服务稳定性。
总结
腾讯轻量级云服务器是一款高性价比、简略易用、灵敏扩展、安全防护和高可用性的云服务器产品，十分合适预算有限的企业和个人运用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5daaeb59908b783be88604c4405583a4/" rel="bookmark">
			Epsapg：一个结合Mmseqs2和PSI-BLAST的流水线，可以快速生成大量的蛋白质序列比对图谱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👉论文下载👈
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e7a0be3c517c38fb9e67100b51bec8f/" rel="bookmark">
			js封装 JS 时间格式化函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将当前时间戳转换为日期格式（年-月-日-时-分-秒） function formatDate() { const date = new Date(); const year = date.getFullYear(); const month = ('0' + (date.getMonth() + 1)).slice(-2); const day = ('0' + date.getDate()).slice(-2); const hours = ('0' + date.getHours()).slice(-2); const minutes = ('0' + date.getMinutes()).slice(-2); const seconds = ('0' + date.getSeconds()).slice(-2); return `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`; } 使用方法：
const formattedDate = formatDate(); // '2022-01-01-13-00-00'（示例） console.log(formattedDate); 在 ECharts 的 X 轴上显示当前日期前一周的月/日 // 在 ECharts 的 X 轴上显示当前日期前一周的月日 const today = new Date() // 当前日期 const lastWeek = new Date( today.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e7a0be3c517c38fb9e67100b51bec8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e9224239680889f85001bf13fed5758/" rel="bookmark">
			高级着色语言(HLSL)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		High-Level Shading Language，简称为HLSL，可以使用HLSL编写顶点着色器和像素着色器程序，简要地说，顶点着色器和像素着色器就是我们自行编写的一些规模较小的定制程序，这些定制程序可取代固定功能流水线中某一功能模块，并可在图形卡的GPU(Graphics Processing Unit,.图形处理单元)中执行。通过这种功能替换，我们便在实现各种图形效果时获得了巨大的灵活性。也就是说，我们不再受制于那些预定义的“固定”运算。
还有一点要注意，如果您的图形卡不支持项点着色器和像素着色器，在运行着色器例程时，请务必切换至REF设备。使用REF设备也就意味着该着色器例程的运行速度将会很慢，但显示的结果一定是正确的，这样我们仍可验证代码的正确性。顶点着色器可用软件顶点运算方式来模拟，即在创建设备时，将设备行为标记设定为D3DCREATE_SOFTWARE_VERTEXPROCESSING。
HLSL着色器程序的编制 HLSL着色器程序可以一个长字符串的形式出现在应用程序的源文件中。但更方便也更模块化的做法是将着色器代码与应用程序代码分离。基于上述考虑，我们可在记事本中编写着色器代码并将其保存为常规的ASCll文本文件。接下来就可以使用函数D3DXCompileShaderFromFile对着色器文件进行编译了。
下面向您介绍一个用HLSL编写的顶点着色器程序，该程序是在记事本中编辑的，并保存在文本文件“Transform.txt”中。该顶点着色器程序对顶点实施了取景变换(view transformation)和投影变换(projection transformation)，并将顶点的漫反射颜色分量设为蓝色。
全局变量 matrix ViewProjMatrix; vector Blue={0.0f,0.0f,1.0f,1.0f}; matrix是HLSL中内置类型，表示维数4x4的矩阵，该变量存储了取景变换矩阵和投影变换矩阵的乘积，这样它就同时描述了俩种变换，vector表示一个4D向量，我们只是将其视为RGBA颜色向量，并将其初始化为蓝色。
输入和输出结构 struct VS_INPUT { vector position : POSITION; }; struct VS_OUTPUT { vector position : POSITION; vector diffuse : COLOR; }; 对于顶点着色器，输入和输出结构分别定义了该着色器的输入和输出的顶点数据，冒号语法用来指定变量的用途，：POSITION的意思指position用于描述输入顶点的位置信息，：COLOR意思是指diffuse用于描述输出顶点的颜色信息。
从底层观点看，语义语法建立了着色器中的变量与硬件寄存器之间的联系。即输入变量总是与输入寄存器相联系的，而输出变量总是与输出寄存器相联系的。例如，VS_INPUT结构的成员position将被连接到一个特定的项点输入位置寄存器。类似地，VS_OUTPUT结构中的diffuse成员将被连接到一个特定的顶点输出颜色寄存器。
入口函数 像C++程序一样，每个HLSL程序也应该有一个入口点。在上面的着色器例程中，入口函数为Main。但是，该名称并非强制性的。在遵循函数命名规则的前提下，着色器的入口函数的命名可自由选择。入口函数必须有一个可接收输入结构的参数，该参数将用于把输入顶点传给着色器，而且入口函数必须返回一个输出结构的实例，用来将经过处理的顶点自着色器输出。mul是HLSL的内置函数，它既可进行向量-矩阵乘法，也可以进行矩阵-矩阵乘法。
VS_OUTPUT Main(VS_INPUT input) { //对该结构示例化，并将各成员设为0 VS_OUTPUT output = (VS_OUTPUT)0; output.position = mul(input.position,ViewProjMatrix); output.diffuse = Blue; return output; } 输入和输出结构的使用并非强制性，例如有时会遇到类似下面的用法，该用法在像素着色器程序中尤为常见，我们输入3个纹理坐标，着色器返回一个单个颜色作为输出，这是通过在函数签名后加上"：COLOR"：从语义层面表示的。
float4 Main(in float2 base : TEXCOORD0, in float2 spot : TEXCOORD1, in float2 text : TEXCOORD2) : COLOR { } 上面定义等价于
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e9224239680889f85001bf13fed5758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae3be29f15ee3c699280b2d975c3d06e/" rel="bookmark">
			js获取时间戳转化成日期格式的直接使用和封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、在页面中直接使用
1. 通过模板字符串使用
2. 定义变量存放时间
3. 在 mounted() 方法里调用
二、封装函数（推荐）
1. 在单独的 js 文件内书写格式化的代码
2. 导入方法并使用
3. 定义变量存放时间并使用
4. 在 mounted() 函数中获取当前时间戳并转化为固定格式赋值给定义的变量显示
三、其他
一、在页面中直接使用 1. 通过模板字符串使用： {{ times }} 2. 定义变量存放时间： data() { return { times: "", }; }, 3. 在 mounted() 方法里调用： mounted() { const date = new Date(); const Y = date.getFullYear(); const M = date.getMonth() + 1 &lt; 10 ? "0" + (date.getMonth() + 1) : date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae3be29f15ee3c699280b2d975c3d06e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbcafc20ad42621dbcd153126ee7e641/" rel="bookmark">
			openEuler 安装lightdm&#43;xfce桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、更新软件源 [root@openeuler100 ~]# sudo dnf update 2、安装字体 [root@openeuler100 ~]# sudo dnf install dejavu-fonts liberation-fonts gnu-*-fonts google-*-fonts 3、安装Xorg [root@openeuler100 ~]# sudo dnf install xorg-* 4、安装xface [root@openeuler100 ~]# sudo dnf install xfwm4 xfdesktop xfce4-* xfce4-*-plugin network-manager-applet *fonts 5、安装登录管理器
[root@openeuler100 ~]# sudo dnf install lightdm lightdm-gtk 6、设置默认桌面为XFCE 通过root权限用户设置
[root@openeuler100 ~]# echo 'user-session=xfce' &gt;&gt; /etc/lightdm/lightdm.conf.d/60-lightdm-gtk-greeter.conf 这一步可选，在greeter界面可以选择使用那个session 7、使用登录管理器登录XFCE
[root@openeuler100 ~]# sudo systemctl start lightdm [root@openeuler100 ~]# sudo systemctl enable lightdm [root@openeuler100 ~]# sudo systemctl set-default graphical.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbcafc20ad42621dbcd153126ee7e641/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c3d7ef3f73ea0c44291cd569b2ce97/" rel="bookmark">
			前端mockjs使用方式[express-mockjs]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提 现在基本上都是前后端分离项目的开发，而前端对于UI界面开发完毕之后往往都需要等待后端的接口提供，因此为了解决这个问题，这里提供一个由express和mockjs结合的本地服务应用项目，可以前端随意造数据配合UI页面进行开发。
个人不喜欢在前端项目中直接插入mockjs，因为感觉会让前端脚手架复杂难看，因此这里直接提供一个express后端服务器跑起来即可，里面可以随意编写mockjs接口，然后前端直接像调用后端接口一样调用
仓库 gitee仓库：https://gitee.com/twang-gitee/web-server-study.git
位置是：nodejs-study/express-mock
clone下载跑起来
npm install npm run start:watch 按理说这个时候就已经跑起来了
补充说明 1.项目说明： /mock/json 对于json文件的放置与管理文件夹
/mock/utils 常用工具方法文件夹
/mock/user.js 包含mock的基本增删查改操作
/mock/user_json.js 包含对Json文件的基本增删查改操作
app.js 项目启动文件
所有的内容都已经配置好了无需去改动什么
2.新增方式 1.mock中新建自己的文件。如：role.js
2.参考user.js 的方式编写相关接口和数据处理逻辑（关于mockjs的示例文档：http://mockjs.com/examples.html）
3.app.js中注册自己对应的路由
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e3e9c26effa039893cf04fb8446b80/" rel="bookmark">
			基于猕猴感觉运动皮层的神经元运动调制分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公开数据集中文版详细描述参考前文：https://editor.csdn.net/md/?not_checkout=1&amp;spm=1011.2124.3001.6192神经元Spike信号分析参考前文：https://blog.csdn.net/qq_43811536/article/details/134359566?spm=1001.2014.3001.5501 目录 0. 公开数据集1. 分析神经元对速度编码模型的拟合程度 0. 公开数据集 网址：Nonhuman Primate Reaching with Multichannel Sensorimotor Cortex Electrophysiology 1Session： " indy_20170124_01 "" indy_20161206_02 " 1. 分析神经元对速度编码模型的拟合程度 神经元运动调制分析是一种研究神经元如何响应动物行为或刺激的方法。这种分析可以帮助我们了解神经元如何编码行为和刺激，并揭示神经元与行为和感觉信息处理的关系。在神经元运动调制分析中，通常会记录神经元的活动，并同时记录动物的运动或刺激。然后，使用不同的方法来分析神经元的活动如何随着动物运动或刺激而变化。
这里，我们对同一只猕猴的不同日期记录的光标"cursor"运动的调制进行分析。时间箱设置为100ms，最小发放率为2，同时采用决定系数（R2）来表示拟合程度的大小。理论上神经元对速度编码模型的拟合程度会随时间推移逐渐提高 2，如 Figure 1 所示：
Figure 1. 不同日期下神经元对速度编码模型的拟合表现 创作不易，麻烦点点赞和关注咯！ Makin, J. G., O’Doherty, J. E., Cardoso, M. M. B. &amp; Sabes, P. N. (2018). Superior arm-movement decoding from cortex with a new, unsupervised-learning algorithm. J Neural Eng. 15(2): 026010. doi:10.1088/1741-2552/aa9e95 ↩︎
Collinger J L, Wodlinger B, Downey J E, et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0e3e9c26effa039893cf04fb8446b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83614c12b8c57c9bd00d72b2ed881b0/" rel="bookmark">
			企业级真实应用利用Mybatis-Plus进行分页查询处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么导入依赖我在之前的文章里边有说过不理解的可以看看
你应该懂点Mybatis-plus，真的好用
1：了解Page&lt;T&gt;类的使用 首先我们需要使用到Page类 ，建立一个Page类，泛式类型中放入我们需要输出的类，是列表的话就放入列表。
MyBatis Plus 是 MyBatis 的增强包装库，MyBatis 是一种流行的 Java 应用程序持久性框架。MyBatis Plus 提供了额外的特性和实用程序来简化数据访问层代码的开发。
在MyBatis Plus中，该类Page&lt;T&gt;是用于分页的通用类。它代表一个数据页面，并提供检索有关当前页面的信息以及执行与分页相关的操作的方法。
Page&lt;T&gt;下面是MyBatis Plus 中类的一些常用方法和属性：
getCurrent()：返回当前页码。getSize()：返回每页的记录数。getRecords()：返回当前页面的记录列表。getTotal()：返回所有页面的记录总数。getPages()：返回总页数。hasNext():true如果有下一页则返回，false否则返回。hasPrevious()：true如果有上一页则返回，false否则返回。next()：移至下一页并返回一个新Page&lt;T&gt;对象。previous()：移至上一页并返回一个新Page&lt;T&gt;对象。convert(Function&lt;? super T, ? extends U&gt; mapper)：使用提供的映射函数转换当前页面上的记录。 import com.baomidou.mybatisplus.core.metadata.IPage; import com.baomidou.mybatisplus.extension.plugins.pagination.Page; public IPage&lt;User&gt; getUsersByPage(int pageNumber, int pageSize) { Page&lt;User&gt; page = new Page&lt;&gt;(pageNumber, pageSize); IPage&lt;User&gt; userPage = userMapper.selectPage(page, null); List&lt;User&gt; userList = userPage.getRecords(); long total = userPage.getTotal(); int currentPage = userPage.getCurrent(); int pageSize = userPage.getSize(); int totalPages = userPage.getPages(); boolean hasNext = userPage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e83614c12b8c57c9bd00d72b2ed881b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd8654a07551c23266fdf69e83aa51d8/" rel="bookmark">
			汽车SOA架构设计方法及关键技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SOA概述 软件定义汽车时代，面向服务的软件架构（Service Oriented Architecture, SOA）为软件定义汽车提供了一套良好的解决方案。
Q：什么是SOA？ SOA将车辆传统的面向信号的架构升级为面向服务的架构，面向服务的架构是一种系统架构设计的方法论，通过将系统的能力抽象成多个服务，并运用多个服务之间的依赖关系来满足车辆系统的多种需求。
汽车SOA常采用上层应用程序+中间层操作系统+底层硬件的分层开发模式，实现了软硬件解耦。SOA将上层应用程序的不同功能单元进行模块化，定义为不同的服务（Service），服务是可发现的软件实体，服务之间可以通过服务接口实现相互访问，并且可以动态发现和调用其他服务。服务接口的设计采用标准的接口定义和通信协议，使服务独立于硬件平台、操作系统及应用程序内部软件代码。
Q：SOA的特点？ SOA架构具备以下特点：
▲ 复用性：通过服务之间的编排，重组，单个服务可以在不同的应用程序中重复使用；
▲ 灵活性：服务独立于硬件和操作系统，支持跨车型、跨平台使用，可实现灵活部署；
▲ 屏蔽异构性：服务之间采用的标准化接口，屏蔽不同硬件、软件、开发语言间的差异，更容易与其他系统集成；
▲ 增强互操作性：SOA架构依赖于标准化的中间件，更易于实现数据共享，软件程序的互操作性较高；
▲ 拓展性：在不改变硬件设施的前提下可以根据业务需求增加新的服务，且单个服务可以独立的拓展和升级。
Q：SOA的优势？ 面向服务的架构开发为主机厂实现软件定义汽车提供了可能性，SOA可帮助企业构建灵活，可拓展，可维护的系统，支持多个平台使用，快速响应市场变化和业务需求。
SOA架构的具体优势主要体现在以下几个方面：
▲ 为汽车平台未来的发展提供了基础，ECU的升级（如版本升级，功能升级，信号升级）只需变更上层代码，无需变更底层硬件，为未来功能的拓展和更新提供了保障，形成更大的汽车开发生态系统。汽车销售后，整车功能可以持续升级迭代，延长了主机厂的服务周期。
▲ 节约成本，传统的汽车架构采用面向信号的方式，控制器由不同的供应商提供，软硬件具有较强的耦合关系，集成难度大，通信困难，复用性差，如果想升级功能或增加新的功能，从软件代码到硬件到通信链路整体都需要重新配置。SOA可实现软硬件解耦，在脱离硬件设备的基础上实现功能的升级和替换。
▲ SOA架构适配多个车型，软件的升级和更新可以为智能汽车带来更多的使用场景和功能，基于SOA架构，为汽车应用开发提供一个标准的基础平台，主机厂可在现有的架构平台之上运用服务，实现更多的功能使用场景，灵活构建系统。
▲ 增加供应商多元化选择，主机厂由硬件制造转型为软件开发，整车功能软硬件不再受制于供应商，主机厂可在已有的硬件设施基础上，改进软件代码，实现功能的拓展。
Q：SOA的关键技术？ 服务抽象 将应用程序抽象成服务，需要综合考虑多方面的因素，如技术，成本，安全等。服务发布的信息传达了它的目的和能力，并给潜在用户提供了关于该服务应该如何通过程序进行调用和使用的详细信息，没有发布的服务信息用来保护它和未来用户之间形成的耦合关系的完整性，从而保障服务在满足契约的前提下进行演化的能力。
服务抽象的原则一般以划分层级的原则进行设计，服务进行分层管理，将相同类型的服务打包到相同的服务层，决不允许将不同类型的服务放到同一逻辑层，尽可能做到服务组合，而非迭代继承服务。
一般划分为三个层级：基础服务（Basic Service）、扩展服务（Extended Service）以及应用服务（Application Service），如下图所示。
基础服务提供车辆最基础的功能，和电子电气硬件（如传感器）强相关，比如摄像头数据的提供和处理功能；
扩展服务相对更复杂，其功能的实现需要调用多个基础服务，如不同传感器（毫米波雷达、激光雷达，摄像头等）的数据融合功能；
应用服务一般为用户可感知的功能，并且与车辆场景强相关，如驻车辅助功能，应用服务的实现，依赖于一个或多个扩展服务。
SOA中间件 目前适用于SOA架构通用接口的中间件主要包括：SOME/IP，DDS，MQTT，HTTP，各中间件的特点如下：
▲ SOME/IP：位于传输层之上的应用层通信协议，动态的创建服务提供者和服务使用者之间的连接，服务上线后广播告知域内其他节点，其他节点收到服务广播后，请求或者订阅相关服务接口。
▲ DDS：新一代分布式实时通信中间件协议，采用发布/订阅体系架构，强调以数据为中心，提供丰富的QoS服务质量策略，以保障数据进行实时、高效、灵活地分发，可满足各种分布式实时通信应用需求。
▲ HTTP：互联网常用的服务协议，使用GET/POST等机制来获取或者设置相关数据。在汽车行业内，一般用于车内节点和云端无线通信协议，传输大于10MB的数据。
▲ MQTT：互联网常用的服务协议，基于订阅和发布机制来获取或者设置相关数据。在汽车行业内，一般也用于车内节点和云端无线通信协议，传输小于10MB的数据。
HTTP，DDS，MQTT和SOMEIP均可用于实现SOA架构的通信，只是负责的场景不同，SOME/IP，DDS协议用于车内节点之间的服务通信，HTTP，MQTT用于一般用于车内节点和云端无线模块通信。
服务治理 服务治理可以实现服务的复用，降低开发成本，提高服务质量，提高服务的可靠性和安全性，对于服务化架构开发非常重要。服务治理包含如下部分：
▲ 服务设计：服务有详细的设计要求，确保服务的设计满足业务需求。
▲ 服务实现：根据服务接口实现代码开发，确保服务开发质量和可靠性。
▲ 服务部署：服务可成功部署至目标环境中，服务具备跨平台属性，在不同环境、硬件、系统中部署一个或多个实例，以达到最大化的重用率。
▲ 服务管控：服务管控包含服务监控和服务管理，服务监控是指服务运行过程中，及时发现和解决问题，保证服务的稳定性和可靠性；服务管理是指在整个服务的生命周期内对服务进行管理，包括版本控制、服务状态管理、服务执行管理、安全管理、数据管理等，给服务乃至整个系统提供强有力的性能保证。
▲ 服务的权限配置：服务发布后，可控制对外的授权管理，保证只有被授权才可以使用服务。
▲ 服务升级：服务可进行升级和更新，以满足业务需求和技术要求。
Q：SOA的实现？ SOA的目的是建立驱动汽车平台不断升级的架构，服务架构需要深入理解业务本质，业务本质是根基，根基打好了，我们才能在此基础上追溯，抽象，归纳，演绎不同场景，拓展业务，升级业务，因此，汽车架构平台的升级脱离不开基础平台。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd8654a07551c23266fdf69e83aa51d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa484fa7aa6125eede17a5e74d321872/" rel="bookmark">
			数据结构-二叉排序树（建立、查找、修改）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉排序树概念 二叉排序树是动态查找表的一种，也是常用的表示方法。
其中，它具有如下性质：
1.若它的左子树非空，则其左子树的所有节点的关键值都小于根节点的关键值。
2.若它的右子树非空，则其右子树的所有节点的关键值都大于根结点的关键值。
3.它的左右子树也分别都是二叉排序树。
PS：对二叉排序树进行中序遍历，得到的序列，总会是一个升序的数列。
二叉排序树的建立 我们使用C语言来建立。
其中我们对二叉排序树的结构体定义如下： typedef int ElemType; typedef struct BTNode{ ElemType key; struct BTNode *lchild,*rchild; }BTNode,*BSTree; 建立二叉排序树的代码如下： BSTree InsertBST(BSTree bst,BSTree s)	//遍历二叉排序树,找到合适的位置 { if(bst==NULL) bst = s; else{ if(s-&gt;key &lt; bst-&gt;key) bst-&gt;lchild = InsertBST(bst-&gt;lchild,s); if(s-&gt;key &gt; bst-&gt;key){ bst-&gt;rchild = InsertBST(bst-&gt;rchild,s); } } return bst; } BSTree CreateBST()	//建立二叉排序树 { BSTree bst,s; int key; bst = NULL; printf("请输入关键字值,输入-1结束.\n"); while(1){ scanf("%d",&amp;key); if(key!=-1){ s = (BSTree)malloc(sizeof(BTNode)); s-&gt;key = key; s-&gt;lchild = NULL; s-&gt;rchild = NULL; bst = InsertBST(bst,s); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa484fa7aa6125eede17a5e74d321872/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/60/">«</a>
	<span class="pagination__item pagination__item--current">61/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/62/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>