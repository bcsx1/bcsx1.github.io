<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f49133ed52ef8637d6aecafbcd8257d/" rel="bookmark">
			数据结构与算法笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构： 就是指一组数据的存储结构
算法： 就是操作数据的一组方法
数据结构和算法 两者关系 数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。
数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。
举例 图书馆储藏书籍你肯定见过吧？为了方便查找，图书管理员一般会将书籍分门别类进行“存储”。按照一定规律编号，就是书籍这种“数据”的存储结构。那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。
以上就是数据结构和算法的解释。
正文 这里面有
10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
复杂度分析（上） 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到：时间、空间复杂度分析。
为什么需要复杂度分析？ 你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫事后统计法。但是，这种统计方法有非常大的局限性。比如，测试结果非常依赖测试环境，测试结果受数据规模的影响很大。
所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。这就是时间、空间复杂度分析方法。
大 O 复杂度表示法 算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？
这里有段非常简单的代码，求 1,2,3...n 的累加和。现在，一块来估算一下这段代码的执行时间。
int cal(int n) { int sum = 0; int i = 1; for (; i &lt;= n; ++i) { sum = sum + i; } return sum; } 从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？
第 2、3 行代码分别需要 1 个 unit_time（指令周期） 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time。可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f49133ed52ef8637d6aecafbcd8257d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/403f5e3aab43813acf2ea84700bc0a5f/" rel="bookmark">
			【C&#43;&#43;】STL 容器 - set 集合容器 ① ( set 集合容器简介 | set 集合容器操作的时间复杂度 | set 集合容器常用操作 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、set 集合容器1、set 集合容器简介2、set 集合容器操作的时间复杂度3、set 集合容器常用操作 二、代码示例 - set 集合容器1、代码示例2、执行结果 一、set 集合容器 1、set 集合容器简介 C++ 语言中的 STL 容器中的 set 容器 , 是 " 集合容器 " ,
容器中的 每个元素 是 " 唯一的 " ,并且 集合容器 中的元素 是按照一定的顺序进行排列的 ; 向 set 集合容器 中 插入元素时 , 都会先验证集合中是否已经存在该元素 , 然后再根据排序规则 , 插入到指定的位置 ;
set 集合容器 不支持 将 元素插入到指定位置 ;
set 集合容器 也不支持 使用 下标位置 直接访问元素 ;
使用 set 集合容器前 , 需要 导入 set 头文件 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/403f5e3aab43813acf2ea84700bc0a5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d510427438665c46b05d8f7762bbf605/" rel="bookmark">
			【每日随笔】情绪操控术 ① ( 三层大脑模型 - 爬行脑 / 情绪脑 / 理性脑 | 情绪脑负面效果 | 不要激活情绪脑 / 情绪中心 | )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、三层大脑模型1、三层大脑的进化2、三层大脑的分层包裹关系 二、情绪脑的负面效果1、情绪脑 VS 理性脑2、情绪脑功能3、情绪脑负面效果 一、三层大脑模型 1、三层大脑的进化 人的大脑是几亿年来逐步进化出来的 , 不同的 脑区 产生的时间是不同的 ;
爬行脑 进化了 3 亿年 ; 爬行脑 是 最早还是 爬行动物时 就进化出来的 , 只能维持人的生命 , 负责 调节 体温 , 维持呼吸 , 进行基础的动作 如 走路 爬行 ;
情绪脑 进化了 5000 万年 , 很多高级哺乳动物 都有 , 负责 情感 , 冲动 , 安全警戒 , 逃避 , 自我奖励 ;
理性脑 进化了 300 万年 , 负责 思考 , 认知 , 语言 , 想象 , 推理 等 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d510427438665c46b05d8f7762bbf605/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/159e42e0777599926f8e8f28c13794da/" rel="bookmark">
			案例189:基于微信小程序的高校教务管理系统设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：springboot
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
用户信息管理
教师信息管理
成绩信息管理
课表信息管理
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 互联网发展至今，无论是其理论还是技术都已经成熟，而且它广泛参与在社会中的方方面面。它让信息都可以通过网络传播，搭配信息管理工具可以很好地为人们提供服务。针对高校教师成果信息管理混乱，出错率高，信息安全性差，劳动强度大，费时费力等问题，采用基于web的高校教务管理系统可以有效管理，使信息管理能够更加科学和规范。
基于web的高校教务管理系统使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理员管理试卷以及组成试卷的题库信息，查看学生的成绩，管理班级和学生。总之，基于web的高校教务管理系统集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
系统展示 用户信息管理 此页面提供给管理员的功能有：用户信息的查询管理，可以删除用户信息、修改用户信息、新增用户信息，还进行了对用户名称的模糊查询的条件
教师信息管理 此页面提供给管理员的功能有：查看已发布的教师信息数据，修改教师信息，教师信息作废，即可删除，还进行了对教师信息名称的模糊查询 教师信息信息的类型查询等等一些条件。
成绩信息管理 此页面提供给管理员的功能有：根据成绩信息进行条件查询，还可以对成绩信息进行新增、修改、查询操作等等。
课表信息管理 此页面提供给管理员的功能有：根据课表信息进行新增、修改、查询操作等等。
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !user.getPassword().equals(password)) { return R.error("账号或密码不正确"); } String token = tokenService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/159e42e0777599926f8e8f28c13794da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/542b9ae3b7afa0769e4d68e5885fb18a/" rel="bookmark">
			案例179:基于微信小程序的在线选课系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：springboot
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
教师信息管理
课程信息管理
课程类型管理
公告信息管理
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 互联网发展至今，无论是其理论还是技术都已经成熟，而且它广泛参与在社会中的方方面面。它让信息都可以通过网络传播，搭配信息管理工具可以很好地为人们提供服务。针对在线选课信息管理混乱，出错率高，信息安全性差，劳动强度大，费时费力等问题，采用基于web的在线选课系统可以有效管理，使信息管理能够更加科学和规范。
基于web的在线选课系统使用Java语言进行编码，使用Mysql创建数据表保存本系统产生的数据。系统可以提供信息显示和相应服务，其管理员管理试卷以及组成试卷的题库信息，查看学生测试试卷的成绩，管理班级和学生。学生选择试题进行答题，可以查看答题成绩。
总之，基于web的在线选课系统集中管理信息，有着保密性强，效率高，存储空间大，成本低等诸多优点。它可以降低信息管理成本，实现信息管理计算机化。
系统展示 教师信息管理 此页面提供给管理员的功能有：教师信息的查询管理，可以删除教师信息、修改教师信息、新增教师信息，还进行了对用户名称的模糊查询的条件
课程信息管理 此页面提供给管理员的功能有：查看已发布的课程信息数据，修改课程信息，课程信息作废，即可删除，还进行了对课程信息名称的模糊查询 课程信息信息的类型查询等等一些条件。
课程类型管理 此页面提供给管理员的功能有：根据课程类型进行条件查询，还可以对课程类型进行新增、修改、查询操作等等。
公告信息管理 此页面提供给管理员的功能有：根据公告信息进行新增、修改、查询操作等等。
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.selectOne(new EntityWrapper&lt;UserEntity&gt;().eq("username", username)); if(user==null || !user.getPassword().equals(password)) { return R.error("账号或密码不正确"); } String token = tokenService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/542b9ae3b7afa0769e4d68e5885fb18a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c84df35eb869304c76718027f3da94c1/" rel="bookmark">
			案例174:基于微信小程序的教学质量评价系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末获取源码
开发语言：Java
框架：SSM
JDK版本：JDK1.8
数据库：mysql 5.7
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.5.4
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
目录
前言
系统展示
后台模块的实现
教师信息管理
课程信息管理
学生信息管理
微信小程序模块的实现
登录
评价
我的评价
代码实现
登录功能实现代码
注册功能实现代码
密码重置功能实现代码
修改信息功能实现代码
删除信息功能实现代码
保存信息功能实现代码
前言 随着信息技术在管理上越来越深入而广泛的应用，管理信息系统的实施在技术上已逐步成熟。本文介绍了基于微信小程序的教学质量评价系统的开发全过程。通过分析基于微信小程序的教学质量评价系统管理的不足，创建了一个计算机管理基于微信小程序的教学质量评价系统的方案。文章介绍了基于微信小程序的教学质量评价系统的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本基于微信小程序的教学质量评价系统有管理员，教师，学生三个角色。管理员功能有个人中心，学生管理，教师管理，课程类别管理，课程信息管理，教学评价管理，系统管理。微信小程序部分教师和学生都可以注册登录，教师可以查看课程信息并且可以查看学生的评价，学生可以查看课程信息，教师信息，并且可以对教师的教学质量进行评价操作，还可以查看校园资讯。。因而具有一定的实用性。
本站后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得基于微信小程序的教学质量评价系统管理工作系统化、规范化。
系统展示 后台模块的实现 教师信息管理 管理员可以管理教师信息，可以对教师信息添加修改删除。
课程信息管理 管理员可以对课程信息进行添加修改删除操作。
学生信息管理 管理员可以对学生信息进行添加修改删除操作。
微信小程序模块的实现 登录 小程序用户是需要注册才可以进行登录的，在登录界面下方可以看到注册按钮，登录的时候需要输入账号密码外还需要选择身份。
评价 学生用户可以在选择课程后进行评价，评价主要是对课程相关的教学方法，教师评分，课程评分，并且还可以留言。界面如下图所示：
我的评价 学生可以在我的界面点击我的评价，可以显示自己的所有评价，还可以删除自己曾经的评价。界面如下图所示：
代码实现 登录功能实现代码 @IgnoreAuth @PostMapping(value = "/login") public R login(String username, String password, String captcha, HttpServletRequest request) { UserEntity user = userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c84df35eb869304c76718027f3da94c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9725101662c334dd6e6a0e3fe75e8b22/" rel="bookmark">
			Postman常见问题及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、网络连接问题 如果Postman无法发送请求或接收响应，可以尝试以下操作：
检查网络连接是否正常，包括检查网络设置、代理设置等。
确认请求的URL是否正确，并检查是否使用了正确的HTTP方法（例如GET、POST、PUT等）。
如果使用HTTPS协议，可以检查证书是否有效。
如果是内部API，可以尝试使用IP地址替换域名进行访问。
2、授权问题 如果API需要授权才能访问，可以按照以下步骤设置授权信息：
在Postman中选择适当的授权类型，例如Basic Auth、OAuth 2.0等。
输入正确的用户名和密码等凭证信息，或者提供正确的Access Token等令牌信息。
3、请求参数问题 在发送请求时，需要注意以下几点：
检查请求体、查询参数、请求头等是否填写正确，如果有错误可以在Postman中进行修改。
对于文件上传等特殊情况，需要选择适当的请求类型和编码方式。
如果需要发送JSON格式的数据，可以使用Postman提供的“Raw”选项卡进行编辑，同时设置正确的Content-Type头部信息。
4、响应解析问题 在收到响应后，需要正确地解析响应体以获得所需的数据。可以按照以下步骤进行解析：
使用Postman提供的解析器，例如JSON、XML等。
手动解析响应体，例如使用正则表达式、字符串操作等方式。
如果需要对响应进行处理，可以编写JavaScript脚本进行自定义处理。
5、API端点更新问题 如果API端点发生了变化，需要根据实际情况进行调整：
可以重新设置请求URL或修改Postman中的环境变量等配置项。
如果API文档有更新，可以及时更新Postman中的相关信息。
如果API的授权方式发生改变，需要修改Postman中的授权信息。
6、集成问题 如果需要与其他工具或平台进行整合，可以按照以下步骤进行配置：
使用Postman提供的集成功能，例如使用Newman进行自动化测试、使用Postman Monitors进行监控等。
编写自定义脚本，例如使用JavaScript进行自动化测试、使用Postman API进行自动化部署等。
7、测试用例编写问题 在编写测试用例时，需要注意以下几点：
确保每个用例都有明确的目的和预期结果。
使用Postman提供的测试脚本功能，例如使用JavaScript编写断言、使用环境变量进行测试数据管理等。
对于需要重复执行的测试用例，可以使用Postman的集合功能进行批量执行。
8、数据驱动测试问题 在进行数据驱动测试时，需要注意以下几点：
使用Postman提供的数据文件功能，例如使用CSV、JSON等格式的测试数据文件。
在测试脚本中使用循环结构和数组等操作，对测试数据进行遍历和操作。
考虑数据完整性和隔离性等问题，尽可能保证各个测试用例之间的独立性。
9、高级设置问题 在使用Postman进行高级设置时，需要注意以下几点：
确认所需的配置项是否已经开启，例如使用代理、自定义证书、跨域资源共享等。
对于需要自定义配置的请求头或响应头信息，可以在Postman设置中进行修改。
考虑安全和性能等问题，需要谨慎设置和使用高级功能。
10、可维护性问题 为了增强Postman测试脚本的可维护性，可以采取以下几种方式：
将测试脚本分解成多个模块，每个模块负责特定的功能或场景。
对测试脚本进行注释和说明，以便后续维护者能够快速理解脚本逻辑和设计思路。
对测试脚本进行版本管理，并保留历史记录和重要变更信息。
总之，要想充分利用Postman进行API开发和测试，需要熟练掌握其各种功能和配置项，并能快速定位和解决常见问题。同时，需要注重可维护性和可扩展性等方面，以便更好地支持团队的协作和项目的发展。还需要注意API的变化，及时更新Postman中的相关信息，以便保持API测试的准确性和有效性。
最后感谢每一个认真阅读我文章的人，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae48a7b6c05ac9a255e76c43e6ed3f59/" rel="bookmark">
			数据结构--查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 查找的基本概念
2. 线性表的查找
3. 树表的查找
3.1 二叉排序树
3.1.1 定义:
3.1.2 存储结构：
3.1.3 二叉排序树的查找
3.1.4 二叉排序树的插入
3.1.5 二叉排序树删除
3.2 平衡二叉树（AVL
3.2.1 为什么要有平衡二叉树
3.2.2 定义
3.3 B-树
3.3.1 m阶的B-树的结构定义：
3.3.2 B-树的性质：
3.3.3 B-树的查找
3.3.4 B-树的插入
3.3.5 B-树的中序遍历
3.3.6 B-树的删除(存疑
3.4 B+树
3.5 红黑树
4. 哈希表的查找
4.1 哈希函数
4.2 哈希函数的构造方法
4.2.1 直接定址法
4.2.2 数字分析法
4.2.3 平方取中法
4.2.4 折叠法
​编辑
4.2.5 除留余数法
4.3 哈希冲突
4.3.1 开放地址法
4.3.2 二次探测
4.3.3 双哈希
4.3.4 拉链法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae48a7b6c05ac9a255e76c43e6ed3f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e9df4b6d59a2d2e36827e28e7a4b3bd/" rel="bookmark">
			Shell基础编程1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		shell解释器：在Linux内核与用户之间的解释器程序。通常指/bin/bash,负责向内核翻译及传达用户/程序指令，相当于操作系统的“外壳”。 交互式（命令行）：人工干预、智能化程度高，逐条解释执行、效率低 非交互式（脚本）：需要提前设计、智能化难度大，批量执行、效率高，方便在后台静悄悄的运行 常见的shell解释器：/etc/shells文件 不同的解释器的风格不一样 相较于其他解释器，bash有很多优点如tab键、历史命令、别名、管道、重定向、上下左右键等。 shell脚本：提前写好可执行语句，能够完成特定任务的文件，顺序、批量化处理 脚本的编写规范： 1、脚本的声明（声明使用那种解释器）：#！/bin/bash 2、注释信息：#脚本功能变量作用等信息 3、执行指令：ls cd 创建测试脚本 第一种执行方式：给执行文件添加x权限,以相对路径和绝对路径执行 登录root进入bash创建子进程bash（脚本声明的）执行脚本命令echo(声明的bash解释器执行echo），执行完后会自动退出 第二种执行方式：使用解释器执行，无需x权限 登录root进入bash创建子进程bash（自己开的）执行脚本命令echo(自己开bash解释器执行echo，在脚本文件中没有声明解释器也能执行），执行完后会自动退出 第三种执行方式：使用source或者 . 执行脚本，无需x权限 登录root进入bash执行脚本命令echo--&gt;使用系统的解释器执行，执行完后不会退出 当使用bash和source执行脚本时结果不一样 使用source命令执行，此时命令执行完成，并且cd进入到创建的目录 使用bash命令执行后虽然命令完成了，当并没有进入到该目录 因为bash使用的是自己开的解释器，执行完脚本后就会退回出到系统的bash解释器，而source使用的就是系统的bash解释器，执行完脚本后不会退出。 使用shell脚本搭建yum仓库 此时该yum文件就创建成功 列二搭建网站，&amp;&gt;重定向标准、错误输出到/dev/null 变量：使用固定的名称存放可能发生变化的值，可以提高脚本的灵活度、适应力。 定义赋值变量： 变量种类： 1，自定义变量，由用户自己修改及使用，《变量名=变量值》名称可以用数字、字母、下划线，不能用数字开头，等号两边不能空格，使用unset 变量名（或者变量名=空），取消变量 加上大括号防止和后面的常量混合 2，环境变量，系统自己定义的，变量名通常大写，由系统维护用来设置工作环境，只有个别变量用户可以直接修改，常见的环境变量有：$USER、$UID、$HOME、$SHELL、$PWD、$HOSTNAME、$PS1（一级提示符）、$PS2（二级提示符）、$PATH（存储命令的路径） env命令：查看所有环境变量 3，位置变量与预定义变量 $1：执行脚本时后面第一个位置参数 $2：执行脚本时后面第二个位置参数 $3：执行脚本时后面第三个位置参数 $*：执行脚本时后面所有位置参数 $#：执行脚本时后面位置参数的个数 $$：当前程序的进程号 $?：判断上一条指令是否执行成功，0成功，非0失败 编写脚本创建用户并设置密码 输入位置变量 set命令：查看所有变量 声明全局变量，export 变量名，当新开一个解释器也能使用该变量 扩展赋值操作： 双引号 “ ”：允许扩展，以$引用其他变量 单引号 ‘ ’：禁用扩展，即使$也视为普通字符 反撇号 ` `：将命令的执行输出作为变量值（或者$( ) ） read标准输入取值：read [-p “提示信息”] 变量名 变成交互式脚本 stty -echo 屏蔽回显，关闭终端输出无显示 stty echo：恢复终端输出 此时输入密码不会显示在屏幕上 整数基本运算：1、expr：计算指定的表达式，并输出结果 2、$[ ]：计算结果替换表达式本身，可结合echo命令输出，引用变量可省略$符号，或者使用$(()) 3、使用let命令，不输出结果，专门用于变量的创建和变量的自增减 使用bc实现小数运算 条件测试：赋予脚本智能判断的能力，1，test 表达式，2，[ 表达式 ] 表达式两边空格 1，对字符串测试。成功返回0，不成功返回非0 ==:两边相等 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e9df4b6d59a2d2e36827e28e7a4b3bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/844a72d842300d981cd06b34ae0a9c52/" rel="bookmark">
			Ubuntu安装K8S的dashboard（管理页面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文网址：Ubuntu安装k8s的dashboard（管理页面）-CSDN博客
简介 本文介绍Ubuntu安装k8s的dashboard（管理页面）的方法。
Dashboard的作用有：便捷操作、监控、分析、概览。
相关网址
官网地址：https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/
github：https://github.com/kubernetes/dashboard/releases
1.安装dashboard 先去github上找找当前的稳定版：github地址，当前是2.7.0
1.下载dashboard配置 创建文件夹
mkdir -p /work/devops/k8s/dashboard/config cd /work/devops/k8s/dashboard/config 下载 dashboard配置
wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml 2.修改配置，允许外部访问 默认Dashboard只能集群内部访问，修改Service为NodePort类型，暴露到外部。
找到 kubernetes-dashboard 的 service，添加 type: NodePort ，这里我指定的 nodePort 是 30001（这个有限制：30000~32767）。如下图所示（左侧是原文件，右侧是修改后的（忽略中间的大于号））：
3.启用dashboard kubectl apply -f recommended.yaml 结果
4.查看状态 查看service
kubectl get services -A 或者 kubectl get services -n kubernetes-dashboard 结果 查看pods
kubectl get pods -n kubernetes-dashboard 或者
kubectl get pods -A 结果
这样是有问题的，解决方法如下：
解决K8S的dashboard一直Pending的问题-CSDN博客
解决K8S的dashboard的ImagePullBackOff和ErrImagePull的问题-CSDN博客
最终结果：
查看services
kubectl get services -A 结果 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/844a72d842300d981cd06b34ae0a9c52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc1fefe533f8ccd8d35e46054383c362/" rel="bookmark">
			认识Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，这里是七七，今天起开起我们的Docker技术篇，本文是介绍Docker的，不介绍如何使用和安装Docker，只是单纯的介绍Docker。
目录
一、历史
二、Docker究竟是什么
三、Docker的结构与特性
1、Docker仓库
2、Docker自身程序
3、工作流程
4、Docker化应用的存在形式
5、Docker对变更的管理
四、为什么使用Docker
1、从代码管理说起
2、当前的优化策略
3、Github版的应用部署解决方案
4、Docker应用场景
场景一
场景二
5、Docker可以解决哪些痛点
1、开发人员
2、测试人员
3、运维人员
6、Docker的学习成本
一、历史 关于Docker的历史，这里我们简要介绍它是dotCloud公司内部使用的Container容器技术，拿出来开源后广受好评。其老板随着Docker的知名度越来越高，直接将公司名字改为Docker股份有限公司，重心转向Docker。
之后，Docker发布了V1.0版，许多大公司均表示加入Docker阵营。在那之后，Docker又完成了几轮融资。如今，在业界影响力很大。
二、Docker究竟是什么 按照官方的说法，Docker是一个开源的应用容器引擎。但这个说法太抽象，不容易理解。
那就从最熟悉的事物说起，但凡从事过计算机相关行业的人，对Java、Android和Github都很熟悉
先说Java，在Java之前的编程语言，像C/C++，是严重依赖平台的，在不同平台下，需要重新编译才能运行。Java的一个非常重要的特性就是与平台无关性，而使用Java虚拟机是实现这一特性的关键。Java虚拟机屏蔽了与具体平台相关的信息，使得Java编译程序只需生成可以在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。
软件部署也依赖平台，Ubuntu的软件包在Centos下可能就运行不起来。和Java虚拟机类似，Docker使用容器引擎解决平台依赖问题，它在每台宿主机上都启动一个Docker的守护进程，守护进程屏蔽了与具体平台相关的信息，对上层应用提供统一的借口。这样，Docker化的应用，就可以在多个平台下运行，Docker会针对不同的平台，解析给不同平台下的执行驱动、存储驱动和网络驱动去执行。
Java曾提出"写一次，在哪儿都运行"的口号，而Docker则提出了"搭建、设置一次，在哪儿都能运行"。虽然，Java和Docker是为了解决不同领域的问题，但在平台移植方面却面临相同的问题，使用的解决方式也相似。
提起Android，我们会想到它是一个开源的手机操作系统，也是一个生态圈，其App以apk形式打包、发布，可以运行在任何厂商的Android手机上。它还有一个官方的安卓市场，提供各种各样的App，我们需要某个App时，就从安卓市场上搜索下载，手机开发者也可以编写一些App，发布到安卓市场，给别人使用，Android也允许在第三方的安卓市场上下载或上传应用。
如果把软件部署的应用看作Android的App，Docker简直和Android一模一样。Docker是一个开源的容器引擎，也有自己的生态圈，它的应用以镜像（image）的形式发布，可以运行在任何装有Docker引擎的操作系统上。它有一个官方的镜像仓库，提供各种各样的应用，当需要某个应用时，就从官方的仓库搜索并下载，个人开发者也可以提交镜像到官方仓库，分享给别人使用。Docker也允许使用第三方的镜像仓库。
最后，再谈Github。它主要用来做版本控制，不仅可以比较两个版本的差异，还可以基于某些历史版本创建新的分支。
使用Docker后，软件部署的应用也可以具备类似Github的版本控制功能，对应用做一些修改，提交新版本，运行环境可以在多个版本间快速切换，自由选择使用哪个版本对外提供服务。
通过和Java、Android、Github的对比，大家对Docker应该有了比较直观的认识，Docker用来管理软件部署的应用，Docker把应用打包成一个镜像，镜像带有版本控制功能，应用的每次修改迭代就对应镜像的一个版本，制作好的镜像可以发布到镜像仓库；也可以直接从镜像仓库下载别人制作好的应用，不做任何修改，即可运行起来。
三、Docker的结构与特性 了解完Docker，我们再来看看它的结构。
如果把Docker当做一个独立的软件来看，它就是用Golang写的开源程序，采用C/S架构，包含Docker Sever和Docker Client，源代码在Github上。
如果把Docker看做一个生态的话，它主要由两部分组成：Docker仓库和Docker自身程序。拿iPhone做类比的话，Docker仓库相当于Appstore，Docker相当于iOS手机操作系统。
1、Docker仓库 Docker仓库snag有非常多的应用，既有各大公司打包的应用，也有大量个人开发者提供的应用。如redis，ubuntu，mysql等等。
2、Docker自身程序 Docker本身是一个单机版的程序，运行在Linux上，属于用户态程序，通过一些接口和内核交互。
由于Docker需要用到Linux的cgroups、namespace等特性，所以目前只能运行在Linux下。
Docker是一个C/S架构，它的Docker Daemon作为Server端，在宿主机上以后台守护进程的形式运行。Docker Client使用比较灵活、既可以在本机上以bin命令的形式（如Docker info、Docker start）发送指令，也可以在远端通过RESTful API的形式发送指令；Docker的Server端接受指令并把指令分解为一系列任务去执行。
3、工作流程 在了解了Docker的构成后，再来看看如何使用Docker。
首先，在Linux上安装Docker软件包，并启动Docker Daemon守护进程。然后，就可以通过Docker Client端发送各种指令，Docker Daemon守护进程执行完命令，向Client端返回结果。
假如要启动一个新的Docker应用app1，其工作流程大致如下：
DockerClient向Daemon发送启动app1指令因为我们的Linux只装有Docker软件包，没有app1相关软件或服务，Docker Daemon就发请求给Docker的官方仓库，在仓库中搜索app1如果找到app1，就把它下载到我们的服务器上Docker Daemon启动app1把启动app1应用是否成功的结果返回给Docker Client Docker的其他操作，比如停止或删除Docker应用和启动的流程差不多，这里就不一一介绍了。
4、Docker化应用的存在形式 我们知道，经过这么多年，Linux下的软件不计其数，安装方式也千奇百怪。有些依赖特定操作系统，有些依赖特定内核版本，有些依赖一些第三方软件和共享库等。
既然软件安装部署方式没有一个统一的标准，那么Docker的官方仓库该如何做呢？总不能一个软件写一个安装说明书吧。
换个角度想一下，用户的需求只是把软件运行起来，至于怎么安装软件、软件运行在什么操作系统下用户不提关心。那么，就把软件和它依赖的环境（包括操作系统和共享库等）、依赖的配置文件打包在一起，以虚拟机的形式放到官方仓库，供大家使用。只要有虚拟机的运行环境，就可以不做任何修改把软件运行起来。只要有一个人把软件安装和配置好，交到官方仓库，其他人直接下载就可以用。以这种方式解决了软件安装部署方式没有一个统一标准的问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc1fefe533f8ccd8d35e46054383c362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2f7a534b9892a06bb320b95ecdb7570/" rel="bookmark">
			【网页设计期末】个人网站模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		诚接计算机专业编程作业(C语言、C++、Python、Java、HTML、JavaScript、Vue等)，
标价10RMB/15RMB每份，如有需要请私信我
本文资源：https://download.csdn.net/download/weixin_47040861/88670537https://download.csdn.net/download/weixin_47040861/88670537
1.题目要求 2.实现功能 1、主页
主页展示了个人信息，这些信息可以被修改，单击主页左侧“相册”和“个人信息”页面可以跳转到另外两个页面，当form表单没有提交过内容的时候，主页会显示默认内容，这些内容可以在index.html文件中修改。
以下是index.html页面中的默认内容
2、表单页面
该页面包含一个form表单，当用户点击提交按钮时会将表单中输入的内容保存到sessionstorage中，并跳转回主页，主页的内容会随着表单内容修改。
3、相册页面
页面右侧的图片均来自于该项目文件下的photo文件夹中，只要将图片放入该文件夹就能自动读取，单击右侧小图可以切换左侧的大图。
photo文件夹中的图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4d375c5c9a010d6566964bf2d46d6d6/" rel="bookmark">
			docker安装ElasticSearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装ElasticSearch(存储和检索数据) # 拉取ElasticSearch docker pull elasticsearch:7.4.2 #ES的配置文件存放的位置 mkdir -p /mydata/elasticsearch/config #ES相关的数据 mkdir -p /mydata/elasticsearch/data #将"http.host: 0.0.0.0"(可以被任何的机器访问)的配置写入elasticsearch.yml中（注意冒号后面的空格） echo "http.host: 0.0.0.0" &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml #设置文件的权限 # 递归更改权限，es需要访问 chmod -R 777 /mydata/elasticsearch/ #运行容器的命令 9200端口用于发送请求使用 9300端口用于集群中节点中的通信使用 #单节点运行 #初始占用64m，最大占用512m（不指定，ES会占用所有的内存） docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \ -e "discovery.type=single-node" \ -e ES_JAVA_OPTS="-Xms64m -Xmx512m" \ -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \ -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \ -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \ -d elasticsearch:7.4.2 # 设置开机启动elasticsearch docker update elasticsearch --restart=always #访问端口 测试是否安装成功 http://虚拟机的ip:9200/ 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4d375c5c9a010d6566964bf2d46d6d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b53ec71b2e3af03039125b41a9d2176e/" rel="bookmark">
			element 分页 el-pagination
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;el-pagination @size-change="handleSizeChange" @current-change="handleCurrentChange" :page-sizes="[10, 20, 30, 40]" :current-page="pagination.pageNum" :page-size="pagination.pageSize" layout="total, sizes, prev, pager, next, jumper" :total="pagination.total" &gt; &lt;/el-pagination&gt; data() { return { pagination: { total: 100, pageNum: 1, pageSize: 10, }, }; }, methods: { //监听 pagesize 改变的事件 handleSizeChange(newSize) { this.pagination.pageSize = newSize; this.getList(); }, //只要页码值发生变化就触发事件 handleCurrentChange(newPage) { this.pagination.pageNum = newPage; this.getList(); }, }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1497abe070aca04deaee2460e96f028/" rel="bookmark">
			学之思开源考试系统是一款 java &#43; vue 的前后端分离的考试系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生系统功能 模块介绍登录用户名、密码注册年级、用户名、密码任务中心管理员发布的年级任务，每个学生只能做一次考试题干支持文本、图片、数学公式、表格等，学生答题支持：文本固定试卷可重复练习、自行批改的试卷时段试卷在时间限制内，可重复练习、自行批改的试卷考试记录查看答卷记录和试卷信息错题本答错题目会自动进入错题本，显示题目基本信息个人信息显示学生个人资料更新信息修改个人资料、头像个人动态显示用户最近的个人动态消息中心用于接收管理员发送的消息 管理系统功能 模块介绍登录用户名、密码主页试卷总数、题目总数、用户活跃度、题目月数量学生列表显示系统所有的学生，新增、修改、删除、禁用管理员列表显示系统所有的管理员，新增、修改、删除、禁用学科列表学科查询、修改、删除学科创编创建学科试卷列表试卷查询、修改、删除试卷创编创建的试卷为时段试卷、固定试卷、任务试卷题目列表题目查询、修改、删除题目创建题目支持单选题、多选题、判断题、填空题、简答题，题干支持文本、图片、表格、数学公式任务列表任务查询、修改、删除消息列表显示已发送的消息，消息已读人数等信息消息发送发送消息给多个用户用户日志显示所有用户日志个人资料显示管理员用户名、真实姓名时间线显示管理员创建时间修改资料修改姓名、手机号 小程序功能 模块介绍登录用户登录登出功能，登录会自动绑定微信账号，登出会解绑注册年级、用户名、密码任务中心管理员发布的年级任务，每个学生只能做一次考试题干支持文本、图片、数学公式、表格等，学生答题支持：文本固定试卷可重复练习、自行批改的试卷时段试卷在时间限制内，可重复练习、自行批改的试卷考试记录查看答卷记录和试卷信息错题本答错题目会自动进入错题本，显示题目基本信息个人信息显示学生个人资料更新信息修改个人资料、头像个人动态显示用户最近的个人动态消息中心用于接收管理员发送的消息 系统展示 学生考试系统 小程序考试系统 后台管理系统 源码地址:
在线考试系统: 学之思开源考试系统是一款 java + vue 的前后端分离的考试系统。主要优点是开发、部署简单快捷、界面设计友好、代码结构清晰。支持web端和微信小程序，能覆盖到pc机和手机等设备。 支持多种部署方式：集成部署、前后端分离部署、docker部署
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f54366b4ce5483381b6f7e784217fec6/" rel="bookmark">
			openGauss学习笔记-175 openGauss 数据库运维-备份与恢复-导入数据-管理并发写入操作示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 openGauss学习笔记-175 openGauss 数据库运维-备份与恢复-导入数据-管理并发写入操作示例175.1 相同表的INSERT和DELETE并发175.2 相同表的并发INSERT175.3 相同表的并发UPDATE175.4 数据导入和查询的并发 openGauss学习笔记-175 openGauss 数据库运维-备份与恢复-导入数据-管理并发写入操作示例 本章节以表test为例，分别介绍相同表的INSERT和DELETE并发，相同表的并发INSERT，相同表的并发UPDATE，以及数据导入和查询的并发的执行详情。
CREATE TABLE test(id int, name char(50), address varchar(255)); 175.1 相同表的INSERT和DELETE并发 事务T1：
START TRANSACTION; INSERT INTO test VALUES(1,'test1','test123'); COMMIT; 事务T2：
START TRANSACTION; DELETE test WHERE NAME='test1'; COMMIT; 场景1：
开启事务T1，不提交的同时开启事务T2，事务T1执行INSERT完成后，执行事务T2的DELETE，此时显示DELETE 0，由于事务T1未提交，事务2看不到事务T1插入的数据；
场景2：
READ COMMITTED级别
开启事务T1，不提交的同时开启事务T2，事务T1执行INSERT完成后，提交事务T1，事务T2再执行DELETE语句时，此时显示DELETE 1，事务T1提交完成后，事务T2可以看到此条数据，可以删除成功。
REPEATABLE READ级别
开启事务T1，不提交的同时开启事务T2，事务T1执行INSERT完成后，提交事务T1，事务T2再执行DELETE语句时，此时显示DELETE 0，事务T1提交完成后，事务T2依旧看不到事务T1的数据，一个事务中前后查询到的数据是一致的。
175.2 相同表的并发INSERT 事务T1：
START TRANSACTION; INSERT INTO test VALUES(2,'test2','test123'); COMMIT; 事务T2：
START TRANSACTION; INSERT INTO test VALUES(3,'test3','test123'); COMMIT; 场景1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f54366b4ce5483381b6f7e784217fec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c721f5326a2bb11a0889db05eea0fa78/" rel="bookmark">
			spring boot 增量包部署，jar包变小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		##pom.xml配置
&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;includes&gt; &lt;include&gt; &lt;groupId&gt;non-exists&lt;/groupId&gt; &lt;artifactId&gt;non-exists&lt;/artifactId&gt; &lt;/include&gt; &lt;/includes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;!--依赖jar包的输出目录，根据自己喜好配置--&gt; &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt; &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt; &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; ##编译目录结构
##运行时拷贝lib目录的jar包到zsjf-resources-file-1.0.jar同级目录。-Dloader.path指定lib目录
java -jar -Dloader.path=./lib zsjf-resources-file-1.0.jar
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cada48af2ba56429a13f198b516daf7/" rel="bookmark">
			【Liunx笔记】Linux常用命令，值得收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、系统信息Linux常用命令 arch 显示机器的处理器架构
uname -m 显示机器的处理器架构
uname -r 显示正在使用的内核版本
dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)
hdparm -i /dev/hda 罗列一个磁盘的架构特性
hdparm -tT /dev/sda 在磁盘上执行测试性读取操作
cat /proc/cpuinfo 显示CPU info的信息
cat /proc/interrupts 显示中断
cat /proc/meminfo 校验内存使用
cat /proc/swaps 显示哪些swap被使用
cat /proc/version 显示内核的版本
cat /proc/net/dev 显示网络适配器及统计
cat /proc/mounts 显示已加载的文件系统
lspci -tv 罗列 PCI 设备
lsusb -tv 显示 USB 设备
date 显示系统日期
cal 2022 显示2022年的日历表
date 061217002022.00 设置日期和时间 - 月日时分年.秒
clock -w 将时间修改保存到 BIOS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cada48af2ba56429a13f198b516daf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6885e7c8caa639e0b7f04c8c8a38ada6/" rel="bookmark">
			openGauss学习笔记-174 openGauss 数据库运维-备份与恢复-导入数据-管理并发写入操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 openGauss学习笔记-174 openGauss 数据库运维-备份与恢复-导入数据-管理并发写入操作174.1 事务隔离说明174.2 写入和读写操作174.3 并发写入事务的潜在死锁情况 openGauss学习笔记-174 openGauss 数据库运维-备份与恢复-导入数据-管理并发写入操作 174.1 事务隔离说明 openGauss基于MVCC（多版本并发控制）并结合两阶段锁的方式进行事务管理，其特点是读写之间不阻塞。SELECT是纯读操作，UPDATE和DELETE是读写操作。
读写操作和纯读操作之间并不会发生冲突，读写操作之间也不会发生冲突。每个并发事务在事务开始时创建事务快照，并发事务之间不能检测到对方的更改。 读已提交隔离级别中，如果事务T1提交后，事务T2就可以看到事务T1更改的结果。可重复读级别中，如果事务T1提交事务前事务T2开始执行，则事务T1提交后，事务T2依旧看不到事务T1更改的结果，保证了一个事务开始后，查询的结果前后一致，不受其他事务的影响。 读写操作，支持的是行级锁，不同的事务可以并发更新同一个表，只有更新同一行时才需等待，后发生的事务会等待先发生的事务提交后，再执行更新操作。 READ COMMITTED：读已提交隔离级别，事务只能读到已提交的数据而不会读到未提交的数据，这是缺省值。REPEATABLE READ：事务只能读到事务开始之前已提交的数据，不能读到未提交的数据以及事务执行期间其它并发事务提交的修改。 174.2 写入和读写操作 关于写入和读写操作的命令：
INSERT，可向表中插入一行或多行数据。UPDATE，可修改表中现有数据。DELETE，可删除表中现有数据。COPY，导入数据。 INSERT和COPY是纯写入的操作。并发写入操作，需要等待，对同一个表的操作，当事务T1的INSERT或COPY未解除锁定时，事务T2的INSERT或COPY需等待，事务T1解除锁定时，事务T2正常继续。
UPDATE和DELETE是读写操作（先查询出要操作的行）。UPDATE和DELETE执行前需要先查询数据，由于并发事务彼此不可见，所以UPDATE和DELETE操作是读取事务发生前提交的数据的快照。写入操作，是行级锁，当事务T1和事务T2并发更新同一行时，后发生的事务T2会等待，根据设置的等待时长，若超时事务T1未提交则事务T2执行失败；当事务T1和事务T2并发更新的行不同时，事务T1和事务2都会执行成功。
174.3 并发写入事务的潜在死锁情况 只要事务涉及多个表的或者同一个表相同行的更新时，同时运行的事务就可能在同时尝试写入时变为死锁状态。事务会在提交或回滚时一次性解除其所有锁定，而不会逐一放弃锁定。例如，假设事务T1和T2在大致相同的时间开始：
如果T1开始对表A进行写入且T2开始对表B进行写入，则两个事务均可继续而不会发生冲突；但是，如果T1完成了对表A的写入操作并需要开始对表B进行写入，此时操作的行数正好与T2一致，它将无法继续，因为T2仍保持对表B对应行的锁定，此时T2开始更新表A中与T1相同的行数，此时也将无法继续，产生死锁，在锁等待超时内，前面事务提交释放锁，后面的事务可以继续执行更新，等待时间超时后，事务抛错，有一个事务退出。如果T1，T2都对表A进行写入，此时T1更新1-5行的数据，T2更新6-10行的数据，两个事务不会发生冲突，但是，如果T1完成后开始对表A的6-10行数据进行更新，T2完成后开始更新1-5行的数据，此时两个事务无法继续，在锁等待超时内，前面事务提交释放锁，后面的事务可以继续执行更新，等待时间超时后，事务抛错，有一个事务退出。 👍 点赞，你的认可是我创作的动力！
⭐️ 收藏，你的青睐是我努力的方向！
✏️ 评论，你的意见是我进步的财富！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/358620c182eafe1122f7a405bc0eb1fd/" rel="bookmark">
			宝塔面板打开提示：您的连接不是私密连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在登录BT面板的时候无法直接进入，而是有出现"您与此网站的连接不是私密连接"的提示问题，看来是有权限被限制导致的。
解决方法如下：
然后进行命令操作，关闭23认证。然后我再重启服务器之后可以登录宝塔面板，估计开启到BasicAuth认证功能，导致无法访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4865845ebad9eda262b41d52ded05d60/" rel="bookmark">
			k8s二进制最终部署（网络 负载均衡和master高可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s中的通信模式 1、pod内部之间容器与容器之间的通信，在同一个pod 中的容器共享资源和网络，使用同一个网络命名空间，可以直接通信的
2、同一个node节点之内，不同pod之间的通信，每个pod都有一个全局的真实的IP地址，同一个node直接的不同pod可以直接使用对方pod的IP地址通信
pod1和pod2是通过docker0的网桥来进行通信
3、不同node节点的上的pod之间如何进行通信？
cni的插件 cni是一个标准接口，用于容器运行时调用网络插件，配置容器网络，负责设置容器的网络命名空间，IP地址，路由等等参数
flannel插件：功能就是让集群之中不同节点的docker容器具有全集群唯一的虚拟IP地址
overlay网络，在底层物理网络的基础之上，创建一个逻辑的网络层，二层和三层的集合，二层是物理网络，三层是逻辑上的网络层，overlay网络也是一种网络虚拟化的技术
flannel支持的数据转发方式 1、UDP模式，默认模式，应用转发，配置简单，但是性能最差
2、vlan，基于内核转发，也是最常用的网络类型（一般都是小集群）
3、host-gw（性能最好，但是配置麻烦）
UDP：基于应用转发，fannel提供路由表，flannel封装数据包，解封装
node都会有一个flannel的虚拟网卡
vxlan：使用的就是overlay的虚拟隧道通信技术，二层+三层的模式
upd基于应用层，用户态
vxlan：flannel提供路由表，内核封装解封装
在 node01 节点上操作 #上传 cni-plugins-linux-amd64-v0.8.6.tgz 和 flannel.tar 到 /opt 目录中 cd /opt/ docker load -i flannel.tar mkdir -p /opt/cni/bin tar zxvf cni-plugins-linux-amd64-v0.8.6.tgz -C /opt/cni/bin //在 master01 节点上操作 #上传 kube-flannel.yml 文件到 /opt/k8s 目录中，部署 CNI 网络 cd /opt/k8s kubectl apply -f kube-flannel.yml kubectl get pods -n kube-system NAME READY STATUS RESTARTS AGE kube-flannel-ds-hjtc7 1/1 Running 0 7s kubectl get nodes NAME STATUS ROLES AGE VERSION 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4865845ebad9eda262b41d52ded05d60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03fcec9fdd0abb7c525b1f83b5c35340/" rel="bookmark">
			阿里云 ACK 云上大规模 Kubernetes 集群高可靠性保障实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：贤维 马建波 古九 五花 刘佳旭
引言 2023 年 7 月，阿里云容器服务 ACK 成为首批通过中国信通院“云服务稳定运行能力-容器集群稳定性”评估的产品， 并荣获“先进级”认证。随着 ACK 在生产环境中的采用率越来越高，稳定性保障已成为基本诉求。本文基于 ACK 稳定性保障实践经验，帮助用户全面理解 ACK 稳定性理论和优化策略，并了解如何使用相应的工具和服务进行稳定性保障。
K8s 集群稳定性和大规模场景下的挑战 K8s 常见的稳定性痛点 Kubernetes 在提供丰富的技术和功能外，架构和运维具有较高的复杂性，也产生了诸多的痛点。
痛点 1：在发布、弹性等高峰期，集群控制面服务时断时续，甚至完全不可用 面对大流量请求，如果控制面没有自动弹性扩容能力，会无法对负载自适应、导致控制面服务不可用。
例如：客户端存在高频度持续 LIST 集群中的大量资源，集群 apiserver/etcd 无法自动弹性就可能联动出现 OOM。
ACK Pro 托管版 K8s 可以对控制面组件根据负载压力做 HPA 和 VPA，可以有效解决该痛点。
痛点 2：集群节点批量 NotReady 导致雪崩，严重影响业务！ 部分节点出现 NotReady，节点上 Pod 被驱逐调度到健康节点，健康节点由于压力过大也变为 NotReady，加剧产生了更多 NotReady 的节点，业务持续重启。
ACK 提供了托管节点池功能，可以对出现 NotReady 的异常节点治愈，重新拉会 Ready 状态，可以有效解决该痛点。
痛点 3：业务高峰期需快速弹性，节点上拉取 Pod 镜像耗时长达分钟级，影响业务 节点上 kubelet 并发拉取镜像遇到网络带宽限制，需要镜像加速功能支持。
ACR 提供了基于 DADI（Data Accelerator for Disaggregated Infrastructure）的按需镜像加载和 P2P 镜像加速的功能，可以加速镜像拉取，可以有效解决该痛点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03fcec9fdd0abb7c525b1f83b5c35340/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc3304a5bbe75b1b875b7ab8edd993b6/" rel="bookmark">
			《2023中国企业数智化转型升级服务全景图/产业图谱3.0版》重磅发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据猿出品
本次“数据猿2023年度三大媒体策划活动——《2023企业数智化转型升级服务全景图/产业图谱3.0版》”的发布，是数据猿在2023年2.0版本的基础上，迭代升级的2023开年的第三个版本。下一次版本迭代将于2024年4月底发布2024年1.0版，敬请期待，欢迎报名。
大数据产业创新服务媒体
——聚焦数据 · 改变商业
在数字化浪潮中，企业数智化转型升级正成为推动现代商业进步的关键动力。数智化转型不仅是技术的革新，更是商业思维和管理模式的根本变革。企业如何借助数据的力量，从传统经营模式迈向智能化、数字化，是当下最值得关注的议题之一。
探索企业内部数据处理的演变，揭示如何通过数据集成、分析和应用，提升决策精准度和运营效率，成为了数智化转型的核心。同时，数据智能在捕捉市场动态、提升客户体验方面的作用不容忽视，它为企业在竞争中保持领先提供了新的思路。
当然，数智化转型也面临诸多挑战，包括数据安全、隐私保护和人才培养等。要解决这些问题，需要整个行业的集体努力。其中，尤为关键的是数据智能产业里的各个企业，他们的行为塑造了整个行业的未来。找到那些支撑行业发展的关键企业，也就找到了打开未来的钥匙。
自2023年2月，数据猿携手上海大数据联盟正式推出横跨“2023全年度的三大策划活动”以来，此次涵盖❶访谈调研+❷企业盘点&amp;内容选题合作+❸产业图谱+❹榜单/奖项于一体的大型媒体策划活动收到了业界数百家企业的踊跃报名参与。
数据猿作为一家致力于“聚焦数智·改变商业”的数据智能产业创新服务媒体，以推动大数据、人工智能、云计算、物联网、5G等新技术在产业中的应用与发展为宗旨，希望以媒体的力量推动产业的发展与行业的进步。
在历经数月的时间里，由数据猿内部员工组成的初审小组、核心粉丝群组成的公审团，以及外部行业专家成员组成的终审团，通过直接申报交流、访谈调研、外界咨询评价、匿名访问等交叉验证的层层筛选推荐机制下，最终制作形成了《2023中国企业数智化转型升级服务全景图/产业图谱3.0版》。
以下为《2023中国企业数智化转型升级服务全景图/产业图谱3.0版》示意缩略图
原图获取方式
欲获取超高清原版大图，在数据猿微信公众号后台回复关键词“2023企业数智化图谱3.0”即可。
以下是《2023中国企业数智化转型升级服务全景图/产业图谱3.0版》中部分典型性代表企业： 分贝通定位于一体化企业支出管理平台，一个平台同时满足企业小额高频的商旅和费控需求，以及大额低频的支付和采购需求，用数据赋能企业降本增效。
●上述产业图谱中，分贝通隶属的核心服务板块/领域：财务
财务方面，凭借强大的事前管控模式和深厚的商务消费商家资源积累，并通过联合系统侧的OA和财务系统厂商、供应链侧的商旅资源商、商城合作方以及众多优质银行，分贝通首创“商旅+费控+支付”的融合解决方案。
基于一体化平台，分贝通能有效助力客户及时有效的费用管控，最终通过数据归集、穿透和分析，赋能企业从规则优化、预算调配到决策建议的降本增效实践。
1）支出管理：包括商旅用餐/补助福利/企业卡/预算管理/费用报销等5个产品模块，覆盖企业小额/高频/多人的支出场景，附带交付服务，包括账户资金/公共平台/交付实施/客户服务/结算开票等。
2）企业支付：包括对公付款/银企直联/网银付/企业采购/电子档案等5个产品模块，覆盖企业大额/低频/少人的支付场景。
3）数据BI：包括数据报表/商旅费控BI/业财一体BI等。
服务过的典型性客户：元气森林、乐金生活、万泰生物、晓羊教育、钱大妈、中智药业等
以元气森林项目为例：元气森林是一家致力于为美好生活创造健康好产品的中国食品饮料企业。企业快速增长之下，“报销之痛”显现。元气森林率先用“系统”将零散费用进行统一管理，实现“一体化报销”。元气森林用“系统”持续加深报销电子化和线上化的程度，成为了数字化先行者。
分贝通3大解决方案：
1、无纸化：数字化报销改革
减少90%垫款，一个平台消费
全面“电子票”，免交纸质票
缩短进程，发票自动验真
2、事前管：前置规则，标准落地
系统前置各场景规则
按职级等配置多套规则
关联预算，避免超支发生
3、聚数据：深度分析，降本提效
对标行业数据，优化规则
分析报销数据，辅助业务
托管高频商家，节约成本
利用“系统”，元气森林不仅人员工作效率提升近95%，还优化费用管理节约百万级费用成本。
卡奥斯COSMOPlat是海尔集团基于“人单合一”和“大规模定制”模式打造的工业互联网平台，致力为不同行业和规模的企业提供基于场景生态的数字化转型解决方案，构建“大企业共建、小企业共享”的产业新生态。
“卡奥斯”的名字来源于古希腊神话中的“元始之神”，寓意在混沌中创造新生。目前，卡奥斯COSMOPlat已经链接企业90万家，赋能企业15.8万家，孕育出化工、模具等诸多行业生态，并在20多个国家复制推广，连续五年蝉联国家工信部跨行业、跨领域工业互联网平台首位。
●上述产业图谱中，卡奥斯COSMOPlat隶属的核心服务板块/领域：工业互联
工业互联方面，技术优势：卡奥斯COSMOPlat创新打造ONE-COSMO平台“三驾马车”——大规模个性化定制套件、BaaS工业大脑、BaaS数字工业操作系统。其中BaaS数字工业操作系统以“大连接—大数据—大模型”为发展主线，在数据采集、数据沉淀处理、数据应用等环节具备领先能力。
研发能力：卡奥斯COSMOPlat累计主导和参与84项国家/行业标准，以及涵盖ISO、IEC、IEEE、UL等权威组织的10项国际标准。在软件开发领域，顺利通过CMMI- V2.0ML5级认证，在软件过程改进和软件开发管理方面达到国际领先水平。
实施能力：卡奥斯COSMOPlat基于ONE-COSMO平台架构，通过数字孪生体、工业机理模型、知识图谱等模块，向上生长工业应用，向下接入工业设备，打造行业领先的共性基础技术平台。同时，坚持“大企业共建，小企业共享”，帮助企业间突破边界、链接更广阔的生产要素，提升生态力。
服务保障：卡奥斯COSMOPlat通过软硬组合，为企业提供更高水准、更加完善的数字化、智能化产品和服务。同时，作为“国际数据空间”协会（IDSA）早期基石成员，参与国际数据空间建设，发起成立工业数据空间技术组。
服务过的典型性客户：亨氏调味、金鼎矿业、天津八里台工业园、海螺新材、青岛市政府等
卡奥斯COSMOPlat创新探索出“场景－企业－园区－行业－城市”立体化赋能路径，构建起跨行业、跨领域、跨区域的赋能生态：
在场景端，打造数字化基础设施，实现数字化管控，已覆盖细分场景206个。
在企业端，提供轻量化应用，补齐数字化能力，满足“千企千面”需求，已赋能15.8万多家企业。
在园区端，探索“平台+园区”模式，打造数字产业园区，实现绿色低碳新发展，已赋能天津八里台等10余个园区。
在行业端，与“链主”企业共建，贯通产业链上下游，促进大中小企业融通发展，已覆盖化工、模具、能源等15个行业生态。
在城市端，创新工业互联网赋能“1+N+X”模式，打造城市经济新引擎，已赋能全国10余个城市产业数字化升级。
以海螺（安徽）节能环保新材料股份有限公司项目为例：海螺（安徽）节能环保新材料股份有限公司公司始建于1995年，总部设在安徽芜湖，是海螺集团实施“跨地区、跨行业”发展战略的标志性企业，在国内外拥有20余家子公司。主营业务涵盖高中档塑钢及铝合金型材、SCR脱硝催化剂、门窗、生态板材等节能环保产品的生产、销售和科研开发。
痛点需求：数据集成难度大、分析能力弱，驱动力不足；综合协同效率差，传统作业模式亟待优化；用户体验感差，个性化不足。
解决方案：
① 构建型材产业生态。在宏观层面，从行业发展维度建设产业生态。打造全国首个型材行业工业互联网平台，利用5G、人工智能、区块链、数字孪生等技术，通过“平台+产业”模式构建型材产业生态，吸引型材采购方、设计师、代理商等上下游生态方“上平台”，开发定制、设计、管理等子平台供各方“用平台”，打通从用户下单、在线设计到生产管理、仓储物流全流程，共同打造以用户需求为中心的生态体系。
② 打造数字化智慧工厂。在微观层面，从工厂维度解决生产的基本问题。依托工业互联网平台，为工厂提供信息化解决方案，实现工厂数字化生产、数字化管理，提高工厂的加工品质和效率，满足终端用户需求。
③ 完成企业内部数字化改造。融合卡奥斯COSMOPlat大数据治理、微服务架构、人工智能、物联网、工业PON网等先进技术，采用边缘层、IaaS、PaaS、SaaS四层架构，按照型材业务线和门窗业务线2条业务主线，建设二十个子系统/子平台，将传统线下业务进行线上数据化、信息化升级改造。
赋能成效：打造出以“大规模个性化定制”为核心的新模式新业态，初步完成“企业数字化”。积极对外赋能，平台厂家入驻数量已达到4910家，其中商业地产273家，城投地产1350家，合作门窗2138家，渠道网络378家，家装店16家。
合思作为敏捷的财务收支管理平台，创立于2014年11月，致力于云产品服务的创新，运用数字科技和前瞻的创想理念，服务未来财务人。在广泛连接的生态、双轮驱动的模式创新和自主研发的全链路L4级“无需报销”解决方案的基础上，进一步构建敏捷的财务收支管理平台，为企业提供智能聚合消费、费控报销、收付款管理、财务收支经营分析及电子会计档案等全方位财务数字化服务，解放双手释放人的创造力，助力企业实现业财融合。超300万未来财务人正在使用合思的产品服务，超6000家企业客户选择合思，实现降本增效、合规经营和低碳运营，让有限更有效。 合思秉承以客户为中心的服务理念，分别在北京、杭州、南昌设立研发中心，并在全国22个城市设有直营服务网络，通过500+合作伙伴覆盖国内外数百个城市，为客户提供敏捷的财务收支管理服务。合思是专精特新企业，公司成立以来先后获得险峰长青、明势资本、极客帮、DCM、老虎环球、红杉中国、曼图资本、软银愿景等知名投资机构投资。截至目前，已累计融资超15亿元人民币。
●上述产业图谱中，合思隶属的核心服务板块/领域：财务
财务方面，未来财务用合思，旗下核心产品——合思费控，全链路L4级无需报销费用控制管理平台；合思付款，连接型采购对账、收票、付款管理平台；合思收款，一站式销售开票、收款、对账管理平台；合思档案，领先的单套制电子会计档案管理平台；合思BI，智能化财务收支经营分析平台。
服务过的典型性客户：北京动力源、洁柔、红星二锅头、苏州泽璟制药、帆书（原樊登读书）、零食很忙等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc3304a5bbe75b1b875b7ab8edd993b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68e6c43b146e49d21236d03a1085977a/" rel="bookmark">
			【金猿信创展】鼎捷软件——赋能产业自主可控，引领科技创新发展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		‍
国产化/信创·鼎捷软件
本内容由鼎捷软件投递并参与“数据猿年度金猿策划活动——2023大数据产业年度国产化优秀代表厂商”评选。
大数据产业创新服务媒体
——聚焦数据 · 改变商业
鼎捷软件股份有限公司（DigiwinSoft，股票码：SZ300378）成立于1982 年，是国内领先的企业信息化、数字化解决方案服务提供商，并于2014年在深圳证券交易所创业板正式挂牌上市。公司总部位于上海，大陆与台湾两岸员工人数超过5000人，业务区域遍布亚太，在大陆、台湾、越南、马来西亚及泰国等地拥有三十余家集团分、子公司与分支机构公司。
鼎捷软件专注于制造业与流通业企业的信息化服务，公司方案与服务覆盖制造业80多个细分行业，超过5万家客户选择公司的服务。近年来公司在“智能+ ”整体战略布局下，确立“一线三环互联”战略路径，面对融合自动化、信息化以及云计算、大数据、人工智能的转型浪潮，不断开拓并积累在制造、流通两大产业领域的核心竞争力，帮助企业积极变革运营模式，实践智能+转型。
据鼎捷软件2022年年度报告，公司实现营业收入 199,520.43 万元。
国产化/信创资质
鼎捷数据中台V1.3.1.1版本在下述环境完成部署并稳定运行。硬件环境：TaiShan 200服务器，型号2280 （处理器（8 cores） 内存（3*16GB） 硬盘（3*200 NVMe SSD） 网卡（1*4*GE） ）；软件环境：openEuler环境（华为）、OceanBase数据库（阿里）、Hadoop （3.3.6）、Hive（3.1.3）、Hbase（2.5.5）、 Zookeeper（ 3.5.6 ）、Kafka （2.8.1 ）、Datax （v202308）、 Elasticsearch（7.9.3）、 Atlas （2.3.0 ）、Nginx （1.16.1）。 经华为技术有限公司测评，由鼎捷自主研发的鼎捷数据中台V1.3.1.1版本凭借高效安全稳定的运行结果和优秀的兼容性，完成并通过了华为技术有限公司相互兼容性测试认证，双方在兼容性及稳定性测试中达成预期目标，应用流畅，高效稳定。
鼎捷数据中台V1.3.1.1版本在2023年10月获得鲲鹏技术认证书，拥有KUNPENG COMPATIBLE证书及认证徽标的使用权，有效期：2023年10月--2026年10月。
上游产业链
基于鲲鹏、欧拉、高斯、OceanBase、大数据开源组件等可信技术，实现了硬件（TaiShan 200服务器）+操作系统（华为欧拉）+数据库软件（OceanBase数据库）+鼎捷雅典娜数据中台（自主研发）+TBB（鼎捷）的深度融合。
首先，在服务器硬件方面，我们支持华为的TaiShan 200服务器，降低了对国外硬件供应的依赖。
其次，在操作系统层面，支持华为的openEuler 20.03LTS，采用这样的操作系统不仅提高了系统的安全性和稳定性，还充分满足了国内法规和政策的要求，为企业提供了可靠的国产化支持。
在业务数据库方面，我们适配了阿里云的OceanBase数据库，将其作为一项自主研发的分布式数据库系统，这样的选择不仅提高了对数据的本地化管理和控制，也减少了对国外数据库技术的依赖。
大数据底座方面，我们采用了包括Apache的Hadoop、Hive、Hbase、Zookeeper、Kafka、Atlas，以及Elastic的Elasticsearch等一系列开源组件。尽管这些组件主要源自国外，我们在获取到源代码基础上进行了二次开发，关键核心算法进行了优化，可以做到源码的可控；同时为进一步提高国产化水平，我们也支持了国内开源的StarRocks和TiDB，提供了大数据组件替代部分的选择，这一灵活的替代性策略降低了对国外技术的过度依赖，同时进一步加强了整体系统的灵活性和安全性。
下游产业链
鼎捷数据中台广泛应用于政府、工业、金融、电信、园区、医疗等领域。数据中台核心能力是将数据变成资产并以批量订阅与API的方式对下游输出服务，为数据中台上层应用提供数据服务。
数据可视化领域：数据中台提供丰富的api接口，输出结构化数据和json格式数据，为BI工具实现制作灵活多样报表、自助分析、数据可视化（大屏）等功能提供业务数据，支持国产化BI软件低成本实现数据可视化功能，满足下游国产软件开发商的多维度数据查询需求。
智能分析报表领域：数据中台可以提供高效准确的数据模型和业务模型，向国产AI分析报表软件输出全面的数据分析能力，国产AI分析软件将业务模型和语言模型相结合即可以实现企业数据报表智能展示、智能分析、智能决策，大大降低国产AI进入数据分析领域的门槛。
人工智能领域：数据中台提供模型训练和部署的环境，将海量数据作为参数输入到深度学习算法模型和机器学习模型，不断优化并调整模型训练过程，为无人驾驶、智慧医疗等领域国产化软件提供高效准确的自然语言、机器视觉模型，为国产化人工智能系统提供支持。
核心技术及产品突破
我司近期在数据管理领域取得了两项重要的技术突破，为国内企业在数字化转型中提供了有力支持。
首先，我们开发了一种独特的管理接口系统及方法，通过将 API映射成数据库中的表，实现了对接口数据的即时查询和二次计算，同时保障数据不离地，大幅度降低了使用门槛。该技术在混合云环境中尤为实用，使得数据得以保留在本地，通过接口轻松上云，极大地提升了数据的安全性。此项技术尚未在国外厂商中发现，我们也已经成功提交了相关专利。 其次，我们推出了一款先进的数采工具产品，通过这一产品，用户可以轻松地打通IT和OT的数据，实现了两者的快速关联分析。这一工具的独特之处在于其简化了IT和OT数据的采集过程，极大地降低了数据采集的难度，从而加速了IT与OT数据的融合。我们对该技术进行了深度研发，目前在国内外尚未发现类似的商用产品，这使得我们在该领域具备了技术领先地位。
这两项技术的成功研发填补了国内在数据管理领域的国产化空白，对企业数字化转型具有深远意义。同时，我们通过提交专利巩固了在这两项技术领域的创新地位，为公司在国际市场上赢得竞争优势奠定了基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/989128cac1a6b51ae77379d6aca87b80/" rel="bookmark">
			【金猿案例展】国元证券——建立一体化智能可观测平台实现APP体验数字化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		‍
博睿数据案例
本项目案例由博睿数据投递并参与“数据猿年度金猿策划活动——2023大数据产业年度创新服务企业榜单/奖项”评选。
大数据产业创新服务媒体
——聚焦数据 · 改变商业
近年来，证券期货业移动应用体系建设快速发展，环境日臻完善，工具应用日益广泛，移动应用提供了快速便捷的证券业务服务。证券类APP活跃用户规模持续上升，智能移动炒股成为行业标配。据艾媒咨询数据显示，2021年中国证券APP用户规模为1.5亿人。随着中国证券市场的不断成熟以及投资者数量的持续增多，中国证券APP用户规模仍将保持较快增长，预计2025年达2.6亿人。
国元证券金融科技部从2021年开始建立体系化应用性能管理平台，从高频功能操作自动化执行、APP崩溃卡顿、兼容性bug、启动速度等多个角度把控APP质量，提升APP功能应用和性能体验。
随着证券期货移动端APP用户规模持续上升，移动端APP的网络环境变得越来越复杂，设备型号众多，使用场景多元。面对广大的用户需求及高时效性的证券业务特点，如何通过保障系统质量，提升用户服务，有机结合国家金融安全与行业数字化发展，探索安全可靠的数字化技术、新模式，成为APP产品质量保障的下一步重要工作。
实施时间：
项目开始时间：2021年6月
中间重要时间节点：2023年6月
项目完结时间：本项目由国元证券金融科技部主导，项目实施周期2年。其中，金融科技部两名测试开发人员、一名系统架构师参与项目开发与实施。
应用场景
本方案立足国家标准和公司移动端应用的实际情况，着眼于发展和完善测试质量体系，通过技术创新和模式创新相结合，以创造更高更优质的服务体验为目标。
针对证券用户特有的高频使用场景，制定了以下场景策略。
稳定APP版本：针对不同机型可能存在的兼容性问题，国元证券通过收集和分析版本的性能数据，及时发现并解决潜在的问题。通过模拟用户常用场景，国元证券能够提供更稳定、更可靠的线上版本，确保用户在使用过程中获得更好的体验。
新交易上线保障：在新的交易功能上线过程中，国元证券通过模拟各种业务场景的崩溃和卡顿情况，为灰度逐步发布提供保障。这有助于确保新功能的顺利推出，减少故障历时和运维成本。同时，国元证券基于相关数据快速定位和解决问题，保障APP投产的稳定性和用户体验。
客户端系统和硬件分布分析：国元证券通过分析客户端系统和硬件的分布情况，提前安排架构适配工作。这有助于提高APP的稳定性和用户体验，确保用户在不同设备和操作系统上都能够获得一致、优质的服务体验。
此外，国元证券还通过定期质检和持续数据分析，实现APP的“全方位”保障。这有助于及时发现并解决潜在的问题，帮助用户快速定位故障点，减少故障历时和运维成本。同时，根据长期的功能和非功能性测试的数据积累，国元证券建立了质量门禁，形成完善可持续的质量管理制度和测试指引。
综上所述，本方案旨在为证券期货移动端APP的用户提供更高更优质的服务体验。
面临挑战
证券期货业是一个瞬息万变的领域，具有场景多元化、机型众多，及网络环境复杂等特点，为应对这些挑战，移动端APP的成功开发和运营需要综合运用先进的技术手段、严谨的管理体系和敏锐的市场洞察，以应对行业的复杂性和多变性。
从场景多元化的角度来看，证券期货市场的投资品种多样，投资策略各异，使得移动端APP的功能需求变得异常复杂。不同的用户有不同的投资需求和习惯，这就要求APP的功能要全面、灵活，能够满足不同用户的需求。
机型众多也是证券期货移动端APP面临的一个挑战。为满足用户的多样化需求，证券公司需要开发针对不同手机操作系统、不同屏幕尺寸以及不同网络环境的移动端APP。这不仅增加了开发成本和时间，也给后期测试和维护带来了很大的困难。
由于用户所处的网络状态可能会不断变动，网络环境复杂是证券期货移动端APP所必须应对的重大挑战之一。在交易过程中，用户可能会遇到网络延迟、断线等问题，这会对用户的交易决策产生重大影响。因此，移动端APP需要具备强大的网络容错能力和快速恢复能力，以确保用户能够顺利进行交易。
已有的性能管理平台提供的性能指标能够主动的解决很多以崩溃卡顿为主的问题。但是如何事前识别问题及事后高效精准快速的定位用户反馈过来的问题，成为APP产品质量保障的下一步重要工作。
应用技术与实施过程
由博睿数据提供的Bonree ONE 一体化智能可观测平台的实践应用中，移动端APP系统架构主要由手机端、PC端、Server端、web端和大数据组成，通过终端采集性能数据，由PC端将数据传递到Server端进行数据回收与数据处理，处理后的数据存到数据库和到WEB端进行展示。在合作初期，国元证券整合了Bonree ONE的可观测性技术，并搭建本地服务器进行性能管理。
技术方案
性能管理平台通过无侵入方式采集请求响应时间、DNS时间、TCP时间、SSL握手时间、请求时间、服务响应时间、数据接收时间、信号量、请求错误发生时间等网络性能数据；同时可采集使用过程中视图性能、崩溃、卡顿报错日志。
在APP上线发布阶段，随着业务拓展与调整，证券移动APP版本迭代和功能更新较快，新功能的增加是否仍然能保证APP具有高可用性和高性能。结合客户端性能管理平台数据，对新版本性能数据重点保障，并对比历史版本，快速识别上线新问题并协助定位。无异常时再逐步灰度发布，保障上线过程稳定性。
主要目标如下：
1、用户体验：了解用户性能体验对业务过程的影响情况，助力优化产品性能，提升用户体验和业务价值；
2、问题分析:了解问题形成原因，掌握故障影响范围；
3、事件追溯:针对特定问题提供回溯能力，确认问题原因，为事件处置提供日志支持。
图：性能平台架构
崩溃信息
APP崩溃是导致用户流失的重要因素之一。由于大多数公司在APP上线之前无法做到在各种环境下的全面适配测试，出现崩溃在所难免，所以快速定位问题点及问题复现是崩溃分析的意义所在。
崩溃分析报告可以让直观的了解所选时间范围内的崩溃数量、崩溃率等概要信息，也可以通过视图、OS版本、设备型号、APP版本等维度查看崩溃的分布。
通过深入崩溃影响分析，支持对应用发生崩溃时的环境信息进行统计。区分崩溃影响的独立用户数，统计某类崩溃在各类设备、操作系统和各 APP 版本中出现的次数，被该崩溃影响的用户数。
ANR分析
主要针对Android版APP独有的分析模块。通过采集ANR堆栈信息、AnrTrace、ANR部件、ANR类型等多维度数据，进行深入的ANR分析，准确发现线程阻塞、挂起或死循环等问题。通过还原ANR问题背景，可以帮助发现APP运行过程中，由于种种原因导致主线程阻塞、挂起或死循环等问题，并帮助开发者分析定位产生的原因，为进一步优化APP稳定性和用户体验提供依据。
卡顿率标准
卡顿分析主要展示当前查询时间范围内的卡顿次数，启动次数卡顿率，影响用户数等信息，在卡顿分析中通过流畅度定义卡顿。
Android系统：通过定义流畅度帧数来判断是否卡顿。
IOS系统：通过子线程监测检查一次循环时间是否超过一定值，判断是否卡顿。
通过流畅度帧数来获取，依据流畅度定义（帧率为60fps）即尽量保证每次在16ms内处理完所有的CPU与GPU计算、绘制、渲染等操作，当每次处理过程超过16ms时，视为一次卡顿。例如安卓卡顿标准：主线程Runloop循环耗时超过5s判定为卡顿。或者主线程vSync每秒钟循环少于40次，连续出现5个周期时也判定为卡顿。
日志分析
日志诊断中的问题检索功能可以快速协助定位问题，并依据详细的日志信息和上下文，帮助解决问题。
● 通过日志诊断功能在问题定位和解决方面具有显著优势，有助于提高用户体验和可靠性。
● 通过日志分析，可以追踪应用程序的活动、了解系统资源的使用情况、监测网络连接等。此外，日志分析还可以用于性能分析、合规性审计和故障恢复等方面。
商业变化
管理证券APP整体性能，精准定位疑难问题
通过可观测性性能管理系统宏观掌控APP质量，判断问题归属。可以主动的关注定位协助解决例如崩溃卡顿等性能问题，提升用户体验。同时针对用户反馈的应用问题，由于移动端APP复杂的网络环境、设备型号众多、使用场景多元，通常较难复现定位，通过平台日志进行分析，问题日志上下文，可以使问题定位所需时间从天降到分钟。大幅度提升客户端APP的稳定性。
建立质量门禁，避免APP迭代对证券用户常用场景带来的性能降低
积累功能测试和非功能性测试的数据，形成交互分析、崩溃、卡顿、启动性能和资源消耗等性能指标，建立性能门禁，设置预警值，量化APP质量，形成可持续发展的质量保障制度体系。
技术创新驱动，证券移动APP性能与质量全面提升
将证券移动APP性能多角度数据可视化，宏观管理APP质量，及时主动发现APP质量问题并主动修复。同时将证券用户遇到的问题转换成IT语言，可快速还原IT语言事故现场。节省运维和研发人员定位解决问题时间。
经过对崩溃问题、ANR问题、卡顿问题的持续优化，结合博睿数据Bonree ONE的迭代修复，APP稳定性达到优秀水平。具体数据如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/989128cac1a6b51ae77379d6aca87b80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5c65b6ca060405234aa11aa3ee27ee3/" rel="bookmark">
			财报造假有新招？数据资产入表的黑暗面曝光！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据产业创新服务媒体
——聚焦数据 · 改变商业
在这个数字驱动的时代，数据就像企业的新黄金，价值连城。但是，当我们尝试把这些数据的价值放进财务报表时，事情就变得复杂了。最近出台的《企业数据资源相关会计处理暂行规定》，试图给这个问题找到答案。但这同时也让我们陷入了一个新的难题：企业会不会利用这个新规定来玩点“财技”呢？
接下来，我们就要深挖这个话题，看看数据资产入表到底会带来什么影响，特别是由于数据资产入表，企业是否会增加一些新的“财技”，来粉饰财务报表。
企业为什么要用“财技”？
在讨论所谓的”财技“之前，我们首先要想的一个问题是：企业为什么要用“财技”？一般在什么情况下企业可能会用“财技”？
一般来看，一个企业如果开始在财技上动心思，往往是以下几种情况：
想象一下你是个公司老板，当然希望自己的公司看起来特别棒。所以，有些公司就会动点小手脚，比如调整他们的收入或者利润。这样做的目的，简单来说，就是为了让公司在股市里看起来更闪亮，或者吸引更多的投资者和贷款。比如，如果一个公司即将进行融资，他们可能就会想方设法让财报看起来更漂亮一些。
还有一种情况是，公司的老板们可能面临着来自股东的压力，要求他们达到一些挺高的财务目标。这时候，“财技”就成了一种手段，让一切看起来都是那么的美好和顺利，哪怕实际上公司的情况可能并没有那么好。
税务优化也是一个原因，有些公司会通过会计上的调整，比如改变资产的分类或者重新评估它们的价值，来减少他们需要交的税。这么一来，他们手上就能留下更多的钱。
但也不是所有的“财技”都是为了看起来更好，也可能是为了“遮丑”。有时候，公司可能会用这种方法来掩盖实际上的一些问题，比如销售额下滑、负债累累或者运营效率低下。这就像是把问题藏在地毯下面，希望没人注意到。
不过说实话，虽然“财技”可能短期内看起来有效，但这些手段通常都涉及到一些操纵和误导。长远来看，这种做法可能会对公司的健康和声誉造成不小的伤害。就像玩火一样，短期内可能感觉挺刺激，但长期来看，却可能烧毁了自己的家园。
所以，下次你看到一些公司的财报特别亮眼，可能就要多想想了，这背后是不是有什么“财技”在起作用。
都有哪些“财技”？
那么，具体都有哪些“财技”呢？
在探讨公司会计报表中的“财技”时，我们可以把它们分为三大类：
1、收入与利润操控
首先，让我们谈谈收入和利润的操控，这里的关键是让公司看起来比实际运营状况更好。一个常见的策略是“收入平滑”，公司通过这种方式调整收入确认的时机，让财务结果看起来更稳定。例如，在一个季度业绩不佳时，公司可能会提前确认一些本应在下个季度确认的收入，以平衡业绩波动。
然后是大规模重组费用，有时公司会在一次重组中记录大量费用，这使得未来的盈利看起来更好，因为这些费用已经在前期被记录。
还有关联方交易，这些交易可能被用来调整利润，通过高价或低价与关联方交易，公司可以人为地提升或降低收入和利润。
2、资产与负债调整
第二大类是关于资产和负债的调整，这里的关键是通过会计手段改善资产负债表的表象。一个常见的做法是将某些支出资本化而非立即费用化，这样做的结果是，短期内减少了费用的确认，从而提高了当期的利润。
存货的估值方法也是一个重要的考虑点，公司可能会改变存货的估值方法，如从先进先出（FIFO）改为后进先出（LIFO），或反之，以影响存货的账面价值和成本货物销售的计算。
折旧和摊销政策的变化也是一种常见的“财技”，通过改变固定资产和无形资产的折旧或摊销方法，企业能够影响其每期的费用。
此外，递延所得税资产的处理也是一个关键点，公司可能会通过调整递延所得税资产的计算，来改善其财务状况。
3、会计估计与判断
第三大类涉及会计估计和判断的调整，这些调整虽然通常在会计准则允许的范围内，但可能会对财务报表的呈现产生重大影响。
比如说，坏账准备的计算就是一个关键的领域。公司可能会调整其对坏账准备的估计，以改变其应收账款的净值。
特别项目或一次性项目的处理也是一个重要的领域，这些项目的分类和处理可能会显著影响公司的财务表现。
股权奖励的计算也是一个关键点，根据不同的估值模型和假设，股权奖励的会计处理可能会大不相同，从而影响相关的费用和利润。
通过了解这些不同的“财技”类别，分析师和投资者可以更加深入地评估公司的财务透明度和真实性。这不仅关系到对一家公司健康状况的理解，也关系到整个市场的健康运作。
数据资产更适合“财技”？
当我们聊到数据资产和“财技”，有个有趣的点是，数据资产确实有些独特的特性，让它们在某些情况下似乎更适合用来做些会计上的小动作。
首先，说到估值，这玩意儿真是个难题。数据资产的价值，比如一个客户名单或者用户行为数据，这些东西的价值有时候真的很难说清楚。它们的价值可能取决于很多东西，像是这些数据有多稀少，用起来多方便，或者在你的业务里能发挥多大的作用。这种估值上的模糊地带，给了那些想要在财报上动点手脚的公司一些空间。
然后，你得知道，给数据资产估值没有一个固定的规则。这跟估计一栋大楼或者一项专利的价值完全不一样。每个公司可能都有自己一套估值方法，这就意味着他们有很大的灵活性去选择一个对自己最有利的方法。
技术变化快，市场也是变化无常，这也是个因素。数据资产的价值受这些因素影响很大。比如今天这个数据特别火，可能明天就不值钱了，这种快速的变化为公司在财报上“调整”数据资产的价值提供了机会。
再说，决定怎么在账上处理这些数据资产也是个技术活。比如，你是把它算作无形资产，还是存货，或者别的什么？这种分类上的不确定性给公司留了操作的空间。
最后，透明度问题也不小。数据资产比较新，很多时候它们的会计处理不像处理传统资产那样标准化和清晰。这就可能导致信息不对称，也就是说投资者或者别的利益相关者可能不太容易理解这些数据资产到底值多少钱。
正是因为数据资产有这些特点，随着数据资产入表新规的正式落地实施，有一种可能性，就是有些企业可能将其作为粉饰财务报表的新工具。接下来，我们就来具体解剖一下数据资产有哪些可能的“财技”。
数据资产入表，可能有哪些“财技”？
当我们聊到公司怎么把数据资产算进他们的会计报表时，你会发现这里面有些小门道。这些门道，或者说“财技”，有时候会让公司的账看起来比实际上要好。但这不总是完全反映出公司的实际情况。来看看他们都玩些什么把戏吧：
1. 估值操纵：
想象一下，一个公司有一大堆用户数据，这在市场上可能值很多钱。这个公司可能就会说：“嘿，我们觉得这些数据未来能赚大钱。” 然后他们就在账上给这些数据标一个很高的价值。这样做的话，他们的资产总额看起来就会增加，让公司看起来更有钱一些。
2. 玩弄收入的时间：
有些公司在报收入的时候会选择一个“合适”的时间。比如，他们可能会在财报季节结束前把一些本应下个季度才确认的收入算进去。就好像一个网上广告公司，在季度快结束时突然说：“我们这个季度卖了超多的数据，赚了不少！” 实际上，那笔交易可能还没完全成交。
3. 决定是花钱还是投资：
当公司花钱开发数据资产，比如建个数据分析平台时，他们可以选择把这笔钱算作投资（也就是资本化），或者就当作是普通的开销（费用化）。如果他们把这些开销算作投资，那在财报上这些钱就变成了一项资产，可以慢慢摊销。这样一来，短期内公司的利润就不会受太大影响。如果直接算作开销，那利润就会立即减少。
4. 摊销和折旧怎么算：
想象一下，一个科技公司开发了一个有价值的数据集，然后把它当作无形资产记在账上。这个资产要在它的“使用寿命”里慢慢摊销掉，如果这家公司想让当年的利润看起来更高，他们可能就会说：“嗯，我们觉得这个数据集能用个10年。” 这样，每年摊销的费用就变少了，短期内的利润就看起来更高。
5. 存货怎么估值：
比如说，有个在线商店有一堆用户的购物数据。如果这些数据被当作存货，公司就得决定怎么给这些存货估值。如果数据的市场价值在上涨，他们可能用先进先出（FIFO）的方法来算，这样可以显示更高的利润。反之，如果数据价值在下跌，他们可能选择后进先出（LIFO），这样利润就会看起来更低。
6. 和关联公司的交易：
假设一家公司有很多消费者数据，然后决定以一个不太合理的价格卖给它的关联公司。比如，如果他们需要提高利润，就可能以一个高得离谱的价格卖出去。这种交易虽然增加了利润，但实际上并不反映数据的真实市场价值。
7. 玩税务游戏：
还有，如果一家国际大公司在很多国家都有业务，他们可能会把数据资产转移到税率低的地方。比如，把数据资产的所有权转到爱尔兰，利用那里低得多的企业税率来减税。这样一来，他们就能在高税国家减少利润，从而降低整体的税务负担。
这些“财技”就像是在财务报表上的魔术，技术上可能没什么问题，但它们可能会让人误解公司的真实财务状况。所以啊，对于公司来说，透明和按规矩来其实更重要，毕竟真实地反映出数据资产的价值才是王道。
好了，我们聊了这么多企业用的那些“财技”，现在得说说这么做可能带来的麻烦。首先，搞这些“财技”，特别是过了头的那种，可能会有法律上的大麻烦。想想看，如果被抓到了，那罚款、审查、甚至可能被告上法庭，这些都不是小事。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5c65b6ca060405234aa11aa3ee27ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ad364c4ae3a8bfb314b7a124a13c768/" rel="bookmark">
			为什么设计制造行业需要数据加密？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计制造行业是一个涉及多种技术、工艺、材料和产品的广泛领域，它对经济和社会的发展有着重要的影响。然而，随着数字化、智能化和网络化的发展，设计制造行业也面临着越来越多的数据安全风险，如数据泄露、数据篡改、数据窃取等。这些风险不仅会损害设计制造企业的商业利益、知识产权和竞争优势，也会威胁到国家的安全和社会的稳定。
因此，设计制造行业需要采取有效的措施，保护其数据的完整性、机密性和可用性，防止数据被非法访问、使用或破坏。数据加密是一种常用的数据保护方法，它通过使用数学算法，将数据转换为无法直接理解的密文，只有拥有正确的密钥的人才能解密还原为原始数据。数据加密可以在数据的存储、传输和处理过程中，提供一层额外的安全防护，使得即使数据被截获或窃取，也无法被恶意利用或泄露。
数据加密在设计制造行业中有着广泛的应用场景，例如：
设计数据加密：设计数据是设计制造行业的核心资产，它包括了产品的结构、功能、性能、外观等信息，以及设计过程中的各种参数、模型、图纸等。设计数据的泄露或篡改，可能会导致产品的质量下降、成本增加、市场失去、甚至造成安全事故。因此，设计数据需要在存储和传输过程中进行加密，防止被未经授权的人员访问或修改。制造数据加密：制造数据是设计制造行业的重要支撑，它包括了生产的计划、进度、工艺、质量、成本等信息，以及制造过程中的各种监测、控制、优化等数据。制造数据的泄露或篡改，可能会影响生产的效率、稳定性、可靠性、安全性等。因此，制造数据需要在存储和传输过程中进行加密，防止被竞争对手或恶意攻击者利用或破坏。产品数据加密：产品数据是设计制造行业的重要输出，它包括了产品的标识、属性、状态、位置等信息，以及产品在使用过程中的各种反馈、评价、维护等数据。产品数据的泄露或篡改，可能会损害产品的功能、性能、品牌、信誉等。因此，产品数据需要在存储和传输过程中进行加密，防止被假冒、伪造、篡改或窃取。
数据加密是设计制造行业保护数据安全的一种有效手段，它可以提高数据的保密性、完整性和可信性，从而保障设计制造企业的商业利益、知识产权和竞争优势，以及国家的安全和社会的稳定。设计制造行业应该根据自身的数据特点和安全需求，选择合适的数据加密方案和技术，建立完善的数据加密管理制度和流程，提升数据加密的水平和效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68b0b482bb36fad9cc352c1de682c73b/" rel="bookmark">
			【Unity】「DES」数据加密解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义秘钥 //加解密密钥,可自行替换 protected static string tmpDESkey = "gBPZodCkn6T"; // Create sha256 hash static SHA256 mySHA256 = SHA256Managed.Create(); protected static byte[] basekey = mySHA256.ComputeHash(Encoding.ASCII.GetBytes(tmpDESkey)); // Create secret IV protected static byte[] baseiv = new byte[16] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }; 加密 #region DESEnCode DES加密 public static string DESEnCode (string plainText) { byte[] key=basekey; byte[] iv=baseiv; Aes encryptor = Aes.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68b0b482bb36fad9cc352c1de682c73b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/505a249c5935de321ddacae8e9b9071b/" rel="bookmark">
			unity 怎么实现AES加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity可以使用C#中的System.Security.Cryptography命名空间下的Aes类来实现AES加密，具体步骤如下：
导入命名空间 using System.Security.Cryptography; 创建Aes实例并设置参数 Aes aes = Aes.Create();aes.KeySize = 256; // 设置密钥长度aes.BlockSize = 128; // 设置分块大小aes.Mode = CipherMode.CBC; // 设置加密模式aes.Padding = PaddingMode.PKCS7; // 设置填充方式 生成随机密钥和向量 byte[] key = aes.Key;byte[] iv = aes.IV; 创建加密器，并将明文转换为字节数组进行加密 ICryptoTransform encryptor = aes.CreateEncryptor();byte[] plaintextBytes = Encoding.UTF8.GetBytes(plaintext);byte[] ciphertextBytes = encryptor.TransformFinalBlock(plaintextBytes, 0, plaintextBytes.Length); 将密钥、向量和密文保存到文件或网络传输等位置
解密时，读取密钥、向量和密文，并创建解密器，对密文进行解密
Aes aes = Aes.Create();byte[] key = 获取密钥;byte[] iv = 获取向量;byte[] ciphertextBytes = 获取密文;aes.Key = key;aes.IV = iv;ICryptoTransform decryptor = aes.CreateDecryptor();byte[] plaintextBytes = decryptor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/505a249c5935de321ddacae8e9b9071b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ac21d2daa5864858e62040d48173adc/" rel="bookmark">
			【python】爬取斗鱼直播照片保存到本地目录【附源码&#43;文末免费送书】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、导入必要的模块： 这篇博客将介绍如何使用Python编写一个爬虫程序，从斗鱼直播网站上获取图片信息并保存到本地。我们将使用requests模块发送HTTP请求和接收响应，以及os模块处理文件和目录操作。
如果出现模块报错
进入控制台输入：建议使用国内镜像源
pip install requests -i https://mirrors.aliyun.com/pypi/simple 我大致罗列了以下几种国内镜像源：
清华大学 https://pypi.tuna.tsinghua.edu.cn/simple 阿里云 https://mirrors.aliyun.com/pypi/simple/ 豆瓣 https://pypi.douban.com/simple/ 百度云 https://mirror.baidu.com/pypi/simple/ 中科大 https://pypi.mirrors.ustc.edu.cn/simple/ 华为云 https://mirrors.huaweicloud.com/repository/pypi/simple/ 腾讯云 https://mirrors.cloud.tencent.com/pypi/simple/ 二、发送GET请求获取响应数据： 设置了请求头部信息，以模拟浏览器的请求，函数返回响应数据的JSON格式内容。
def get_html(url): header = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36' } response = requests.get(url=url, headers=header) # print(response.json()) html = response.json() return html 如何获取请求头： 火狐浏览器： 打开目标网页并右键点击页面空白处。选择“检查元素”选项，或按下快捷键Ctrl + Shift + C（Windows）在开发者工具窗口中，切换到“网络”选项卡。刷新页面以捕获所有的网络请求。在请求列表中选择您感兴趣的请求。在右侧的“请求标头”或“Request Headers”部分，即可找到请求头信息。 将以下请求头信息复制出来即可
3.解析响应数据中的图片信息 用于解析响应数据中的图片信息。通过分析响应数据的结构，提取出每个图片的URL和标题，并将其存储在一个字典中，然后将所有字典组成的列表返回。 def parse_html(html): image_info_list = [] for item in html['data']: image_url = item['image_url'] title = item['title'] image_info = {'url': image_url, 'title': title} image_info_list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ac21d2daa5864858e62040d48173adc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e00ae221d6fe50dffd037e3647164791/" rel="bookmark">
			Ndk编译hevc静态库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码下载:
https://hg.videolan.org/x265
然后执行以下脚本:
#!/bin/bash # 设置NDK路径，根据你的实际安装路径修改 NDK_PATH=/mnt/c/Users/Administrator/ubuntu_dev/ndk/android-ndk-r21e # 设置目标平台和ABI版本，可以根据实际情况修改 aarch64-linux-android armv7a-linux-androideabi TARGET=aarch64-linux-android API_LEVEL=21 # 设置x265源码路径 X265_SOURCE_PATH=./ # 设置输出目录 OUTPUT_DIR=android/x265_64 # 进入x265源码目录 cd $X265_SOURCE_PATH # 清理之前的编译结果 make clean # 设置交叉编译环境变量 export CC=$NDK_PATH/toolchains/llvm/prebuilt/linux-x86_64/bin/$TARGET$API_LEVEL-clang export CXX=$NDK_PATH/toolchains/llvm/prebuilt/linux-x86_64/bin/$TARGET$API_LEVEL-clang++ # 创建输出目录 mkdir -p $OUTPUT_DIR # 使用CMake配置 cmake \ -DENABLE_SHARED:bool=off \ -DENABLE_CLI:bool=off \ -DCMAKE_SYSTEM_NAME=Android \ -DCMAKE_ANDROID_ARCH_ABI=$TARGET \ -DCMAKE_ANDROID_NDK=$NDK_PATH \ -DCMAKE_ANDROID_API=$API_LEVEL \ -DCMAKE_ANDROID_STL_TYPE=c++_shared \ -DCMAKE_INSTALL_PREFIX=$OUTPUT_DIR \ . # 编译x265 make -j8 # 安装（拷贝）编译好的库文件到输出目录 make install echo "编译完成，输出目录：$OUTPUT_DIR" 替换掉上面的目标平台，输出目录，源码路径，ndk路径等信息即可自己编译出android平台下的x265库。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e00ae221d6fe50dffd037e3647164791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da5e0beb0ae587f83da5eef308bf274b/" rel="bookmark">
			GPT分区格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPT分区格式 [root@localhost ~]# gdisk /dev/sdb -bash: gdisk: 未找到命令 [root@localhost ~]# yum -y install gdisk - gdisk命令用于查看磁盘使用情况和磁盘分区（GPT分区格式）
- 命令格式：gdisk [选项...] [设备路径]
- 常用选项：-l 列出磁盘分区表类型与分区信息
[root@localhost ~]# gdisk /dev/sdb [root@localhost ~]# fdisk -l [root@localhost ~]# mkfs.xfs /dev/sdb1 [root@localhost ~]# blkid /dev/sdb1 /dev/sdb1: UUID="adb85183-9036-4e9c-ba48-aa008bcbebf2" TYPE="xfs" PARTLABEL="Linux filesystem" PARTUUID="5dd8dd16-0e61-47fd-9c24-58ac87f1ceb3" [root@localhost ~]# lsblk [root@localhost ~]# vgdisplay -v --- Volume group --- VG Name centos System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 3 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 1 Act PV 1 VG Size &lt;19.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da5e0beb0ae587f83da5eef308bf274b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5d2134391d2ccd73018e5a68a249680/" rel="bookmark">
			【动态规划】路径问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎来到Cefler的博客😁
🕌博客主页：那个传说中的man的主页
🏠个人专栏：题目解析
🌎推荐文章：题目大解析（3）
目录 👉🏻不同路径I👉🏻不同路径II👉🏻礼物的最大价值 👉🏻不同路径I 原题链接：不同路径
mycode:
class Solution { public: int uniquePaths(int m, int n) { vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1 )); dp[0][1] = 1; for(int i = 1;i&lt;=m;i++) { for(int j = 1;j&lt;=n;j++) { dp[i][j] = dp[i-1][j]+dp[i][j-1]; } } return dp[m][n]; } }; 👉🏻不同路径II 原题链接：不同路径II
mycode:
class Solution { public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) { int m = obstacleGrid.size(),n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1 )); dp[0][1] = 1; for(int i = 1;i&lt;=m;i++) { for(int j = 1;j&lt;=n;j++) { dp[i][j] = dp[i-1][j]+dp[i][j-1]; if(obstacleGrid[i-1][j-1]==1) dp[i][j] = 0; } } return dp[m][n]; } }; 👉🏻礼物的最大价值 原题链接：珠宝的最高价值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5d2134391d2ccd73018e5a68a249680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a1ecfd9b795a725935be23e6953e6b6/" rel="bookmark">
			【量化】商品期货换月的处理思路（old）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		商品期货存在换月的情况，即期货合约是有到期日的，如果不想实物交割就得将持仓转换到之后的合约上，而不同月份的价格是不一样的，也就是不连续的，在回测中需要处理换月带来的跳空：
比如上图中的PG是逐月换月的，鼠标标记处就有500点的价差，如果不处理，回测中做多则多了500点的利润、做空则多了500点的亏损，但这在实际换月中不会出现。
因此这和股票中的复权一样都是基础性问题，但是看到中文网络上很少有相关文章去讨论、处理这方面的问题，请教邢大说：
你可以自己定好规则，比如说次月的合约成交量比当月的高了。连续高三天，那你就换到次月的
紧接着问问chatGPT，经过一系列友好交流后：
用邢大的思路先自己拼接一个主连。
准备工作 分合约的商品期货数据。可在量化小讲堂这里下载：
持仓量主力换月 wind里面对自己主连设计的解释是：
由不同时期持仓量最大合约的行情数据拼接而成的拟合合约。因在换月期前后最大持仓量会在不同合约间来回摆动，所以Wind主连合约规则定为只向前切换不回退，每日收盘结算后判断是否切换。
由此可见他们是按持仓量来进行划分的，因此我们这里也用持仓量作为划分标准。
首先，我们把原始数据拼接起来，形成一个具有多个交易日期、但每个合约仅有一个交易日期的表格（以甲醇为例）：
from glob import glob kline_path = r'path' for i in ['symbol']: symbol_file_path = glob(kline_path + '/%s/*[0-9].csv' % i) # 此处是寻找所有数字结尾的csv文件 df_list = [] for i in symbol_file_path: df_list.append(pd.read_csv(i, encoding='GBK', skiprows=1, parse_dates=['交易日期'])) all_coin_data = pd.concat(df_list, ignore_index=True) data_need_to_prepare = all_coin_data.sort_values('交易日期') 接下来开始整理工作，按合约名字把持仓量铺平开来：
# 计算每个合约在每个交易日的持仓量 holdings = data_need_to_prepare.groupby(['交易日期', '合约代码'])['持仓量'].sum().unstack() 其次用rolling求出来过去滚动5日持仓量最大的值，获取每日横截面比较最大的合约名为一个series，最终用inner的方式把df和series给merge起来，得到的就是我们要的结果。
# 求出过去五日的最大值 rolling_max = holdings.rolling(window=5).max() # 找到最大值所在的列名 max_columns = rolling_max.idxmax(axis=1) series_df = max_columns.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a1ecfd9b795a725935be23e6953e6b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc4fcc99dc33b1ed1916d2e39b60fdf/" rel="bookmark">
			向ES索引里面添加一个字段并更新旧文档数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题 最近需要调整ES索引，添加1个字段，并且，对旧文档数据更新新加的字段默认值。
解决思路 通过利用Update mapping API添加1个新字段后，然后，利用Update By Query API将向旧文档数据添加新加字段默认值。
添加字段 PUT dev_zyl/_mapping { "properties": { "levelScore": { "type": "double", "null_value": 1 } } } 这里添加了一个levelScore字段，这个字段是double类型，默认值为1。
更新旧文档 POST dev_zyl/_update_by_query { "query": { "match_all": {} }, "script": { "source": "ctx._source['levelScore'] = 1" } } 这是查询出所有文档，然后，将levelScore字段设置为1。
总结 现在这个时间点，ES不能通过在mapping接口添加新字段的时候，影响到旧数据。不过，单独出一个接口处理旧数据也是很合理的。
参考： Update mapping APIUpdate By Query APINumeric field typesHow to update multiple documents that match a query in elasticsearch 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8fa830f880e71202f9033147f6434bb/" rel="bookmark">
			9种卷积注意力机制创新方法汇总，含2024最新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天咱们来聊聊卷积注意力机制。
相信各位在写论文的时候都苦恼过怎么更好地改模型，怎么更高效地提高模型的性能和泛化能力吧？我的建议是，不妨考虑考虑卷积+注意力。
卷积注意力机制是一种通过关注输入数据中的不同部分来改进模型性能的方法，结合了卷积网络和Transformer各自的优势，以同时获得更好的泛化能力和更大的模型容量。因此，通过将二者有效结合，卷积注意力机制就能帮助我们在准确性和效率之间实现更好的平衡。
今天我就帮同学们整理了卷积注意力机制3种创新思路，帮助想发论文的同学更高效地改模型涨点，早点发出自己的顶会。另外，每种思路我都整理了对应的论文和代码，方便同学们更好地理解这些创新思路是如何落地的。
论文和代码看文末
融合卷积与自注意力机制的新架构 DAS: A Deformable Attention to Capture Salient Information in CNNs 一种可变形的注意力机制，用于捕捉CNN中的显著信息
「简述：」CNN在图像识别中擅长处理局部空间模式，但有些重要的信息可能超出了CNN的识别范围。传统的自我注意力机制虽然能处理全局信息，但计算量大。论文提出了一种名为DAS的新方法。这种方法不仅简单、快速，而且能有效地捕捉相关图像区域的信息。与传统的注意力机制相比，DAS的计算量更小。实验表明，DAS可以显著提高CNN的性能，尤其是在图像分类和目标检测任务上。
X-volution: On the Unification of Convolution and Self-attention 关于卷积和自注意力的统一
「简述：」论文介绍了一种名为X-volution的方法，用于将卷积和自注意力统一起来。作者认为卷积和自注意力是深度神经网络中两个重要的构建块，但现有的架构缺乏一种方法来同时应用这两种操作。因此，作者提出了一个多分支基本模块，由卷积和自注意力操作组成，能够统一局部和非局部特征交互。经过训练后，这个多分支模块可以转换为单个标准卷积操作，称为X-volution，可以作为原子操作插入到任何现代网络中。
CoAtNet: Marrying Convolution and Attention for All Data Sizes 结合卷积和注意力处理各种数据规模
「简述：」论文介绍了一种名为CoAtNet的混合模型，用于结合卷积和注意力的优势。作者认为Transformers具有更大的模型容量，但由于缺乏正确的归纳偏置，其泛化能力可能不如卷积神经网络。为了有效地结合两种架构的优点，作者提出了CoAtNets，这是一类基于两个关键见解构建的混合模型：(1)深度卷积和自注意力可以通过简单的相对注意力自然地统一起来；(2)以合理的方式垂直堆叠卷积层和注意力层可以显著提高泛化能力、容量和效率。
UniFormer: Unified Transformer for Efficient Spatiotemporal Representation Learning 用于高效时空表示学习的统一的Transformer
「简述：」论文介绍了一种名为UniFormer的模型，用于从高维视频中学习丰富的多尺度时空语义。作者提出了一种新的方法，将3D卷积和视觉Transformer结合起来，以解决视频帧之间的局部冗余和全局依赖关系问题。通过在浅层和深层分别学习局部和全局令牌亲和力，UniFormer能够有效地捕获长距离依赖并减少局部冗余。实验表明，UniFormer在流行的视频基准上取得了最先进的性能，同时需要更少的计算资源。
开发动态和自适应的注意力卷积方法 Dynamic Convolution: Attention over Convolution Kernels 卷积核上的注意力机制
「简述：」动态卷积是一种轻量级的卷积神经网络设计，通过动态聚合多个并行卷积核来增加模型复杂度，从而提高性能。它不需要增加网络深度或宽度，同时具有计算效率高和表示能力强等优点。在ImageNet分类任务上，使用动态卷积可以将MobileNetV3-Small的top-1准确率提高2.9％，同时仅增加了4％的额外FLOPs。
Omni-Dimensional Dynamic Convolution 全维动态卷积
「简述：」全维动态卷积（ODConv）是一种轻量级的卷积神经网络设计，通过学习多个并行卷积核的线性组合来提高性能。与现有的研究不同，ODConv关注所有四个维度（即每个卷积核的空间大小、输入通道数和输出通道数）的卷积核空间，并利用一种新的多维注意力机制和并行策略来学习互补的注意力。作为常规卷积的替代品，ODConv可以插入到许多CNN架构中。在ImageNet和MS-COCO数据集上的实验表明，ODConv为各种流行的CNN骨干网络带来了可靠的准确率提升，同时减少了额外参数。
多尺度注意力卷积网络 EPSANet: An Efficient Pyramid Squeeze Attention Block on Convolutional Neural Network 一种高效的金字塔压缩注意力块卷积神经网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8fa830f880e71202f9033147f6434bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/766b8bc02e58bc997f25db6f557621fb/" rel="bookmark">
			【Graylog】通过Pipelines在Graylog生成IP地理位置信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序 在当今数字化时代，随着网络攻击的不断增加和全球化的用户活动，了解IP地址的地理位置信息变得越来越重要。对于网络安全和营销策略来说，掌握IP地址的地理信息可以带来许多好处。
接下里将介绍如何通过Graylog的Pipelines功能，在日志管理平台Graylog中生成IP地址的地理位置信息。Graylog作为一个强大的日志分析工具，不仅可以帮助我们收集和分析日志数据，而且通过Pipelines功能，还可以对日志进行处理和增强。
操作步骤 获取 GeoIP 数据库文件：首先，需要获取 GeoIP 数据库文件，这些文件包含了 IP 地址与地理位置的映射信息。可以从 MaxMind 或其他提供商获取这些文件。然后将数据库文件上传到服务器上，本例中保存位置为：/usr/share/graylog/data/config/GeoLite2/GeoLite2-City.mmdb
https://www.maxmind.com/ 免费注册并下载
接下来，在 System -&gt; Lookup Tables 下找到“Data Adapters”，在页面上，选择 “Create data adapter”，并填写如下所示的信息：
下一步，使用如下所示在Cache下，点击“Create cache”按钮创建一个新缓存：
在 Lookup Table 的最后一步中，我们需要使用之前两个步骤创建的Data Adapter 和Cache 来创建Lookup Table
现在Lookup Table已经创建好了，并可以使用了，然后需要创建一个Pipeline规则来利用它，并在每条带有 IP 地址的消息中添加元数据。
前往（System -&gt; Pipelines），在“Manage rules”下创建一个新规则。给它一个描述，以便记住它，在“Rule Source”中放入以下内容：
rule "GeoIP lookup: nf_src_address" when has_field("nf_ipv4_src_addr") then let geo = lookup("GeoLite2-City", to_string($message.nf_ipv4_src_addr)); set_field("nf_src_addr_geo_location", geo["coordinates"]); set_field("nf_src_addr_geo_country", geo["country"].iso_code); set_field("nf_src_addr_geo_city", geo["city"].names.en); end 此规则仅适用于nf_ipv4_src_addr。如果还需要查找目标地址，可以在此规则中添加额外的行，或者为带有目标 IP 地址的日志创建第二个规则。
‍![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/cdddc716e62c4b84a4eb7d246a6e0e54.png 在创建Rules之后，需要将把它添加到处理带有 IP 地址的日志的Pipeline中的一个阶段中，然后处理将开始运行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/766b8bc02e58bc997f25db6f557621fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc10345a2a349d7e29c2af7590115d4/" rel="bookmark">
			2024，5G-A风起，中兴通讯破浪
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于通信圈而言，2024年最关键的里程碑，当属3GPP R18版本即将冻结。作为5G国际标准化组织，3GPP的意义是推动成员公司、工作组和技术规范的研究，让5G发展更有章法。
放眼整个5G技术的演进，其实大致分为两个阶段。第一阶段为R15-R17版本，在这一阶段中，中国5G建设硕果累累，截至11月末，我国5G基站总数已达328.2万个，5G移动电话用户达7.71亿户，5G DOU（接入流量）是商用之初的4倍，物联网连接总数已经达到22.6亿，行业专网数达到2万张，国民经济大类中其中有67个大类已经被5G涵盖。
马上，中国5G即将迎来第六年商用。以R18-R20标准为代表的第二阶段有望进一步增强5G服务行业应用的能力，扎根生花，实现5G从“能用”到“好用”，这一阶段还不算6G，业界曾称其为5.5G。
2021年4月，5.5G正式被3GPP官方命名为5G-Advanced，并启动相关的标准化工作。按既定规划，即将冻结的R18标准中，5G-A将双手入泥，挖潜5G更多潜力。
众人拾柴火焰高，5G-A的迭代，离不开全球产业团结协作。一直以来，中兴通讯积极布局5G时代，在标准制订、产业共鸣中发挥积极作用。在2024年来临之际，5G-A风起云涌之时，和讯网与中兴通讯面对面沟通，探讨5G-A的发展周期。
正如中兴通讯副总裁及RAN产品总经理李晓彤所言，5G-A既是对5G的增强，又是对6G美好的衔接。在这个阶段新的业务应运而生，因此需要用更新的技术、更新的架构去支撑新应用。
5G-A升级“六边形战士”
5G发展之初便定义了三大场景，即eMBB（超宽带）、mMTC（大连接）跟uRLLC（低时延高可靠），在增强移动宽带场景、海量机器类通信、超高可靠低时延通信三大方向上，除了满足人与人通信需求外，更重要的是解决人与物、物与物通信的问题，5G的三角形场景从根本支撑起了确定性连接。
在工业、矿山、电力、港口等垂直行业，5G应用也不断涌现，帮助大量企业实现了提质、降本、增效。
尽管如此，依旧有许多行业企业反馈，5G很难完整支撑多样性的物联场景需求。“无论从提升效率还是降低成本的角度，行业都希望能提供更多价值。”中兴通讯副总裁及系统产品MKT总经理柏钢告诉和讯网。
在他看来，如果能将5G场景的“三角形”扩展成5G-A场景的“六边形”，可以更好地实现5G从支撑万物互联到使能万物智联。
所谓六边形，一方面是指5G-A在原有的eMBB、mMTC和uRLLC三个方向上进行增强。在eMBB方向，从千兆连接走向万兆连接；而大连接方向，从百亿连接走向千亿连接。在uRLLC即低时延高可靠这个方向，需要确定性的能力去支撑行业的纵深拓展。
从另一个更宽广的维度来看，5G-A还新增了三个场景，即全域的通感、泛在智能和空天地一体，共同构建起六大场景的5G-A能力。
在李晓彤的畅想下，拥有了这些能力后，就能够逐步在To B、To C跟To X三个领域去拓展应用。To C方面构筑人类生活，更好地连接虚拟跟现实世界。To B方面，通过数智进入到行业的生产域，帮助生产系统提高效率。To X可以拓展To C、To B以外其他的一些场景，包括车联网、低空、卫星连接等，构建面向5G-A更大的宏观愿景。
或许有人会问，5G曾被质疑缺少杀手级应用，回报率不足，还需要特别去推5G-A吗？
从消费端的角度而言，5G-A意味着满足用户更深层次的需求。毕竟需求，是技术发展的第一推动力。
一定有人可以体会，在万人演唱会、大型游乐场、地铁运行中，视频加载失败，以及发不出去的情况时有发生，究其原因，现在的5G还不足以支撑大规模的容量。
中兴通讯在5G-A时代给出的解决办法是，将原有的“道路”拓宽，把设备从64通道提升到128通道，甚至再多修一条“路”，引入新的频谱。
容量有了，覆盖也很关键。李晓彤解释道，覆盖的意义是：要保证在每个地方都能感受到同样的体验，为了更好地提升体验，中兴通讯推出了RIS解决方案，这是5G-A时代的一次新尝试。“通过特殊材料制作的反射板，智能反射无线电磁波。基于终端的位置不断调整波束方向和角度后，实时跟基站互动，达到更良好的覆盖水平，覆盖范围可提升30%以上，上行速率更提升20倍以上。“
容量和覆盖做好后，中兴通讯提供的5G-A万兆体验跃然纸上。在上海地铁4号线上，可以支持整车乘客同时观看高清视频；在使用VR设备时，不再需要携带厚重的工具，玩家也不会头晕目眩，可以沉浸式体验游戏的快感；在浩瀚的杭州钱塘江游船上，视频回传、网红直播、扫码付款也不再卡顿。
打破进入行业的壁垒
对于面向B端的行业互联网，情况要稍显复杂。业界常说“千行百业”，其实已经直白地说明了每个行业都有专属的多样化工作场景，因此C端的现象级应用，在B端很难出现，且培育周期，也远远超过消费侧。
企业客户到底对5G-A有需求吗？在与中兴通讯的交流中，我们找到了肯定的答案。
在李晓彤看来，5G时代在生产侧主要解决的是普遍接入的问题，而在5G-A阶段，要使网络具备能力，能深入到生产域，帮助企业提高生产效率、降低成本，这时就需要四个能力，驱动5G-A在B端的诞生。
首先，需要构建一张确定性的网络。这张网络高带宽、低时延、us级抖动、具可靠性，可以确定性地满足生产域的要求，保证生产不停歇。举个例子，在中兴通讯的调配下，现在工厂5G可以提供4ms 99.999%的确定性能力，而5G-A可以在关键控制领域摸到更高，如1ms 99.999%甚至1ms 99.9999%，在可靠性方面，中兴通讯也通过双终端FRER（双发选收）来保证控制平面的工作，达到核心生产领域对控制的要求。
其次，产品适配应用场景。工厂中更需要极简的设备，如果可以把网络设备和算力设备有机融合，形成一套算网一体的产品，更适配于工厂场景。柏钢解释道，5G网络是一个纵深的体系，不止技术，应用需要搭建在上层，例如部署MEC（边缘计算）、PLC控制（工业控制装置）等。“而中兴通讯通过算网一体机系列产品，将5G连接和算力放在一起，可以达到灵活性部署，更像是一整套工业现场网方案。”
然后，现如今工厂业务百花齐放，存在多种协议，因此对终端的生态要求极高，终端既要有可靠性，又要适配各种工业化能力，因此需要多样化的工业定制终端。实际上，在我国传统工业领域，使用了大量的工业控制相关协议，未来5G-A时代，中兴通讯针对工业协议演进上，需要做到在兼容的基础上，延伸更先进的架构。“保证工业企业不需要付出更多成本，就能实现对整个现网生产装备和设备的改进。”柏钢告诉和讯网。
最后，许多工厂里的人并不懂网络，更希望设备能够即插即用。所以需要免开通、免调测、免维护的“三免”服务，这也是中兴通讯多年洞察工厂需求后，一直戮力的工作。
可以看见，中兴通讯一直在试图打破5G-A进入行业的壁垒，解决了5G应用的确定性、应用的便利性，同时也解决协议包括终端生态的匹配，最后搭建好建设运维，让企业愿意用、用得好，赋能、使能双剑并行。
现在，已经有企业进行了5G-A的试点，并给出了对它的初步评价。在中兴通讯自己的南京滨江工厂，通过引入5G-A，实现柔性生产，局部车间实现了黑灯工厂，整体人员减少28%，生产效率提升20%以上；在武汉钢铁，通过5G-A赋能，实现整体效益提升19％，减少人力成本23％，降低能耗10％，每年减少碳排放75万吨。
不能一蹴而就
在To B上获得一些有益的尝试之后，中兴通讯把5G-A扩展到了更多领域。有了网络，就能孵化出更多应用，抹平数字鸿沟，助力数字新经济腾飞。
统计发现，拥有智能座舱的汽车每月的流量消耗大概在40GB左右，这是非常惊人的流量。“除了满足第四块屏流量的需求，未来，车载系统一定是往更安全、更可靠、更高效去走，5G-A带来的是安全效率的提升。在这些方向，5G-A都可以帮助车企更多。”柏钢说道。
此前，中兴通讯在珠海和重庆两地推出了车路协同5G-A系统，通过路侧系统监控信息，实时传递到车上，车辆判断避让行人，提高安全。
同时，在一些半开放场景，例如公交车自动驾驶上，也可以帮助司机提高驾驶的安全性。“未来城市内可以建立一张连续的5G-A网络，利用智能交通提高安全性和效率。”柏钢说。
可以预见，5G-A箭在弦上，但一个新技术的发展一定是循序渐进的。
目前，5G RedCap（5G轻量化）作为5G-A的前奏曲已经就绪。为了降低模组成本，RedCap对5G进行了部分优化，不仅继承了低时延等优点，在功耗和价格也有优势。
当下，5G的三大场景都有制定完备的标准，且在众多物联场景中落地，但是，三者之间还存在一些“中间地带”，这使得5G网络能力并不能完全覆盖所有无线场景，而这一片“中间地带”，恰恰就是5G RedCap针对千亿物联的用武之地。例如，基于RedCap的无线摄像头，可以省去传统有线摄像头所需的挖沟、放缆工作，但清晰度不会打折扣。
按照李晓彤的预测，从5G-A落地的时间表来看，看好RedCap在2024年会迎来大规模商用，产业链上下游的终端和模组已经具备了商用的能力，“中兴现在所有网络的设备全部支持RedCap，在广东已部署开通7千站规模，随时可以商用。”
空天地一体在终端侧的应用已经上路。现在，越来越多的手机终端开始设计直连卫星功能，但依旧有诸多痛点，例如发热等功耗难题。下一阶段，业界将逐渐攻克基站上星、5G网络上星等技术难题，进一步提升性能，使得打卫星电话或用卫星上网体验与在地面上网的体验类似。李晓彤告诉和讯网，中兴通讯在舟山做了IoT-NTN测试，解决了海域物联、应急通信等问题。未来将在抗震救灾等方面贡献更多。
通感等技术场景的应用则还处于爆发前夜。对于低空场景而言，我国过去几年发展迅猛，无人机经济今年有望突破1600亿元，但同时也对无人机管理提出了更高的要求，而5G-A非常适合感知业务，对于空中飞行物，识别的精准度达到分米级别，单站能感知到的距离超过1公里以上，可以适应部分场景的需求。
“通感还需要通过做一些小规模的验证，观察是不是能完美地匹配业务的需求，路径还是比较长的。”李晓彤向和讯网坦言，明年就是要把这些技术点打出来，去证明商业逻辑成立，立起示范的商用点，再去逐渐铺开，最终形成成熟的商业模式。
尽管很多关键场景还需培育时日，但推广5G-A肯定不能一蹴而就。好消息是，在与中兴通讯无线首席架构师吴明皓等专家的交流中可以确定，5G-A是场景覆盖，只会在有需要的地方建设，不会浪费资源，更为关键的是，铺设5G-A成本不会明显抬升，打消了产业链诸多顾虑。
在逐浪5G-A过程中，除了在技术上实现先发优势，中兴通讯认为生态也是演进的重中之重。无论在标准层面，抑或是实践层面，小到一颗芯片，大到系统跟算法，都需要一个先锋者走在前面去开拓，然后整个产业链实现协同。而翻看整个通信发展史，中兴通讯一直在担当这样的角色。
最后，李晓彤总结道，“政府、运营商、产业几方力量通力合作，延续5G建设时的路径，相信还能基于5G-A为社会创造更多价值。”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4779f083aab3b020af420c15b1da3d93/" rel="bookmark">
			RocketMQ 消费失败了，怎么处理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是 RocketMQ 推模式的一段代码：
public static void main(String[] args) throws InterruptedException, MQClientException { Tracer tracer = initTracer(); DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("CID_JODIE_1"); consumer.getDefaultMQPushConsumerImpl().registerConsumeMessageHook(new ConsumeMessageOpenTracingHookImpl(tracer)); consumer.subscribe("TopicTest", "*"); consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET); consumer.setConsumeTimestamp("20181109221800"); consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { try{ System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs); }catch (Exception e){ return ConsumeConcurrentlyStatus.RECONSUME_LATER; } return ConsumeConcurrentlyStatus.CONSUME_SUCCESS; } }); consumer.start(); } 从这段代码可以看出，消费者消费消息后会返回一个消费状态，那消费状态有哪些呢？参见类 ConsumeConcurrentlyStatus 中定义：
消费成功，返回 CONSUME_SUCCESS；
消费失败，返回 RECONSUME_LATER。
下面代码就是返回上面两个状态的逻辑，对于消费状态，如果返回 null，会给它赋值 RECONSUME_LATER，处理逻辑如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4779f083aab3b020af420c15b1da3d93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/994c4af91326164ac4f174c4687e2040/" rel="bookmark">
			如何对服务器性能进行优化？（建议收藏）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们开发的软件服务需要在服务器上运行，所以服务器性能代表了软件的性能上限，因此服务器性能调优是个十分重要的环节，然而大部分同学对服务器性能调优关注的较少，今天从3个部分对服务器性能调优进行介绍，分别是：服务器配置选择，服务器负载分析，服务器内核参数调优。
云原生实战系列正在热更中，赶紧进来学习吧～
服务器配置选择 服务器一般是由CPU、内存、磁盘和网卡组成，因此选择服务器配置就是选择CPU核数、内存大小、磁盘大小及类型、网络带宽。但是，服务器配置的选择是很难标准化的，也就是说很难推断出“一台需要达到1000TPS的后端服务器”的配置应该是什么样的。因为软件的最终运行性能与软件的实现方式是紧密相关的，即使是同一个后端应用程序中的两个接口，由于具体功能的差别，性能也会有所差别。
因此，服务器配置的选择应该基于具体的测试结果。一开始可以选用配置较低的服务器做调优和测试，并以该服务器的测试结果作为选择服务器的依据。
以一个订单业务为例，经过测试后，一台配置为4核 CPU 、16GB内存、10Mbps带宽、50GB机械磁盘的服务器的测试结果为：支持50并发量和300TPS吞吐量（增大并发量后会出现超时报错）。而在压力测试过程中， CPU 的使用率接近75%，内存使用率在 50％以下，带宽使用率在50％以下，除去日志以外无磁盘操作。
因此可以认为，一台配置为4核 CPU ( CPU 使用率需要在75％以下）、8GB内存（内存使用率可以接近100%)、 5Mbps 带宽（带宽使用率可以接近100%）的服务器，可以满足订单接口支持50并发量、300TPS吞吐量的压力。
如果需要达到200并发数、2400TPS吞吐量的目标的话，则需要8台配置为4核 CPU 、8GB内存、5Mbps带宽的服务器，或者1台配置为32核 CPU 、64GB内存、40Mbps带宽的服务器。当然，最终的服务器配置还是需要通过测试来验证。
注意：在以上订单接口的例子中，后端服务器和数据库等服务器需要一起调试，避免后端服务器性能过剩，而数据库等服务器性能不足的情况发生。另外，以上选择服务器配置的方法不一定适用于所有场景，请斟酌参考。
服务器负载分析 在性能调优时，需要先对服务器负载进行分析，通常而言，我们主要分析CPU使用率、内存使用率、磁盘I/O，服务器负载和带宽使用情况。
CPU使用率 CPU使用率反应的是CPU的忙碌情况。当CPU达到100%时，部分进程会进入等待状态，CPU暂时不会对其进行处理。在实际情况下，为了应对一下突发性的请求压力，服务器CPU使用率一般需要在75%以下。如果一台服务器的CPU使用率多次高于75%，这时候就考虑增加新的服务器。
监控CPU使用率我推荐大家使用htop工具，可以非常直观看到CPU使用率、内存使用率、及负载等信息。
使用htop查看CPU负载 首先我们需要安装htop，以centos为例，安装命令如下：
yum install htop -y 安装完成后我们就可以通过htop命令观察CPU负载了
htop 输入htop命令后我们可以很直观的看到CPU负载情况，该命令的CPU使用率会以多个核作为单位进行显示。操作系统机会自动分配多个核的负载，当所有核的CPU使用率都超过75%时才能认为服务器的CPU使用率已经超过75%。
cpu负载
如上图所示，这是一个4核CPU服务器，在截图的时候其中3核CPU使用率都超过了75%，再观察一会发现所有CPU的使用率都在85%左右徘徊，说明CPU负载很高了，需要考虑增加新的服务器。
内存使用率 内存使用率反应的是内存的使用情况。内存用于存放程序的代码及数据，一般分为物理内存和虚拟内存，其中物理内存指的是服务器的内存，而虚拟内存指的是硬盘的一块空间。当物理内存使用率达到100%时将会使用虚拟内存。需要注意的是，虚拟内存的读写速度远远低于物理内存，如果程序被放在了虚拟内存执行，那么程序的执行效率会变得很低。
一般而言，服务器的物理内存应该保持在80%以下，虚拟内存使用率保持在0%。
服务器内存使用情况还是可以通过hop工具进行查看
内存使用率
上面显示了服务器的内存使用情况：总内存16G，使用了10G左右，内存使用率62%，可以继续使用，同时关闭了Swap虚拟内存。
在下MEM%栏中显示了单个进程的内存使用率。
磁盘I/O 磁盘I/O指的是磁盘的读写，在软件系统中，日志、文件操作、数据库操作都会造成磁盘读写压力，其中又以数据库操作为甚，在高并发情况下往往数据库会首先成为系统的瓶颈。
磁盘监控我推荐大家使用iostat工具，可以很方便查看磁盘的使用情况。
使用iostat查看磁盘I/O 首先我们需要安装iostat，以centos为例，安装命令如下：
yum install sysstat -y 安装完成后我们就可以通过iostat命令磁盘使用情况了。
# 查看磁盘总体读写情况， 1代表每1秒读取一次数据 iostat -x 1 磁盘IO
输入iostat命令后，磁盘总体读写情况如上所示。磁盘负载主要关注2个指标：%idle，%util
%idle:表示CPU除去等待磁盘I/O以外的空闲时间百分比，这个指标应该要保证在70%以上
%util:该设备用于I/O操作的时间百分比，这个指标需要保证在70%以下，当到达100%时表示已经满负载。为了降低磁盘负载，可以采用性能更高的磁盘（OSD，PCIE）或者降低磁盘的操作频率（异步写、合并写）
平均负载 平均负载指的是单位时间内平均的活跃进程数，是一个表示服务器负载的指标。一般情况下需要保证平均负载的值小于当前服务器的CPU核数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/994c4af91326164ac4f174c4687e2040/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cbf4dba68ec64c4bce56b0519ff0968/" rel="bookmark">
			C#(Unity)循环遍历Dictionary，并修改内容或删除内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		头文件 using System.Linq; 代码 /// &lt;summary&gt; /// RotateObjectList ：旋转列表 &lt;物体本身，(Y轴当前旋转值，Y轴旋转目标)&gt; /// &lt;/summary&gt; Dictionary&lt;HLSceneObject, (float,float)&gt; RotateObjectList = new Dictionary&lt;HLSceneObject,(float, float)&gt;(); update(){ // 物体旋转列表遍历 if (RotateObjectList.Count &gt; 0) { for (int i = 0; i &lt; RotateObjectList.Count; i++) { var item = RotateObjectList.ElementAt(i); float value = item.Value.Item1; if (...) { // 旋转 value += rotateDirection * ScrollAnglePerTime * time * 5; item.Key.RotateObject(value); // 写回 RotateObjectList[item.Key] = (value, item.Value.Item2); // 判断是否结束 if (.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cbf4dba68ec64c4bce56b0519ff0968/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ee3a2ddac429fded99f55f54006752d/" rel="bookmark">
			医院云HIS系统源码，saas多医院版，适用于专科医院、集团医院、基层医院
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		医院云HIS系统源码，自主研发，自主版权，电子病历病历4级
系统概述： 一款满足基层医院各类业务需要的云HIS系统。该系统能帮助基层医院完成日常各类业务，提供病患挂号支持、病患问诊、电子病历、开药发药、会员管理、统计查询、医生站和护士站等一系列常规功能，还能与公卫、PACS等各类外部系统融合，实现多层机构之间的融合管理。
云HIS系统采用B/S架构云端SaaS服务的方式提供，使用用户通过浏览器即能访问，无需关注系统的部署、维护、升级等问题，系统充分考虑了模板化、配置化、智能化、扩展化等设计方法，覆盖了基层医院的主要工作流程，能够与监管系统有序对接，并能满足未来系统扩展的需要。
云HIS系统分为两个大的系统：综合管理系统和业务系统
1、综合管理系统：由运营商、开发商和监管机构使用，用来进行运营管理、运维管理和综合监管。
2、业务系统：由基层医院使用，用来支撑医院各类业务运转。
技术细节： 前端：Angular+Nginx
后台：Java+Spring，SpringBoot，SpringMVC，SpringSecurity，MyBatisPlus，等
数据库：MySQL + MyCat
缓存：Redis+J2Cache
消息队列：RabbitMQ
任务调度中心：XxlJob
接口技术：RESTful API + WebSocket + WebService
报表组件：itext + POI + ureport2
数据库监控组件：Canal
系统功能介绍： 一、云his综合管理系统 1、运维管理：主要由开发人员管理使用，对提供不同服务的后台服务器进行管理，对程序接口、应用部署、菜单配置等进行统一管理。
2、综合监管：综合监管是监管方用来查看所有使用云his系统的医疗机构信息。
3、运营管理：运营管理是综合管理系统的核心部分，由运营商和医院管理人员使用。运营管理包括：机构管理、药品目录管理、用户管理、角色管理、字典管理、模板管理、参数设置、消息管理、售后服务、运营配置、外部系统11个子模块，实现机构、用户、角色管理、药品目录管理以及通用的字典管理；可以根据业务需要为各医院定制病历模板和报表模板；可以对医院收费外接设备进行参数设置，对业务进行配置；可以管理消息及售后信息等。
二、云his业务系统 系统包括：预约挂号、划价收费、医生工作站、护士工作站、电子病历、开药发药、住院登记结算、住院管理、药库管理、药房管理、会员管理、统计查询、财务管理、系统管理等模块。
功能模块：
1、门诊部分
挂号及预约、划价及收费、门诊处方及病历...
2、住院部分
入院及出院登记、住院收费、住院清单、出院结算、住院医生工作站、住院护士工作站...
3、电子病历
医嘱管理、护嘱管理、电子病历、护理病历、病历质控...
4、药物管理
门诊发药、住院发药、退药、药品出入库、药物调拨、盘点、控制、拆分...
5、统计报表
门诊收入汇总、住院收入汇总、缴款日报、住院结算汇总、检查项目汇总、药品进销存统计...
6、综合维护
系统设置、字典维护、综合查询、参数设置...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b94e76a5b69c0201e81f280c16b7db7d/" rel="bookmark">
			园区规划的一些体会和设想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络节点设备 erp系统 终端设备 数据库
1.权限限制（su权限类似的需要管理层以上审批才可以使用）（多级分层）
2.访问限制：不管是IPV4还是IPV6，只能是允许访问的目标网段（可多个 甚至使用vlan 让某个端口作为蜜罐口 ）
3.MAC白名单绑定账号，管理员账号在其他设备无法登录
4.身份多次验证，可以考虑使用生物信息，但是如果本身园区的安全就存在后门的话，尽可能减少避免暴露关键人员的任何相关信息。
5.蜜罐不要考虑把实际地点隐藏，尽可能让实际地点存在光明正大的入口，欢迎大家参观，顺便测试目前的安防系统（物理的程度）而关键信息，不以任何纸质版资料进行记载，全部使用云，云这边假设可以考虑专门一个安防部门，甚至多点（实际物理地址）但是访问不用镜像，用高通用量集群，备份镜像同样如下，访问不适用密匙还需要审批登录。
6.监管信息不考虑实际页面，毕竟在这么高分析也没有实际意义，毕竟信息传递不一定可以作为呈堂证供，而且存在失实性，误判，甚至人员本身是我方人员，但是在不知名情况下携带了违规物品，且本身该人员是不知情的情况下。所以最好在关键地方使用热成像监控，而温差本身是有颜色差异的，必要的地方考虑安检过机的形式布置隐形检索装置。
7.门闸不用实际物理的形式，以声音报警，毕竟火灾时，你这门就是个隐患。
8.刷卡验证在重要场所，不留下检验的机制，不以板卡进行验证，架设专门的云服务检验CS端，尽可能避免使用BS端，毕竟Web其实很脆弱。
9.尽可能多的留下空白盲区，但是该区域不以封闭的建筑遮挡，使用玻璃挡风，并且这些区域照明要使用多个备用电源，保证就算火灾这个地方也是最亮的。
10.如果是在已规划或规划中的区域工作，尽可能利用现有场所资源改造，毕竟重建的话，电路等已经架设完毕，即使修改，也是个大工程，还辛苦原供应商们重新工作，运输材料。所以在加固安防的同时，尽可能完善园区工作环境，而资金目前除了加重安防的使用，还需要优化工作环境。
11.公司专用设备，终端，且上级已提醒这是内网设备，即使出于保管的需要，也不应在未请示上级的时候，私自用其链接私网，而且保证登录终端是具备密码锁定功能。
设计理念：（需扩展）
“透明”的概念： ”透明”是一个很重要的术语。它表示，某一个实际存在的事物看起来却好像不存在一样。
“安全”的概念： “安全不单单是一个园区网络策略等安全控制，还需要保证施工过程不出现意外的人员伤亡，毕竟不管论不论风水，一旦出现这些意外，就会影响工人的积极性，注意几点，不管任何，多大规模的园区，防火消防必定是首位，这不应该就地取材，而是保证水管和消防设施齐全，最后才使用就地取材方式补救，因为前面的设备都不齐全，才会考虑使用这种必然带破坏性的补救方法。
“人员管控，材料确认” 施工区注定了有不同的供应商，所以记录人脸本身就是个不科学且麻烦的手段，一般都是使用安全帽的颜色加以区分不同人员，但是如何确认该人员是在登机的公司内，可以考虑门闸关卡（内部也可以存在关卡，考虑发放必要物资的时候，记录常见人员（登记者可以考虑和政府安防单位有合作，如果安防等级要求高的话。）大门的话由供应商的登记人员领入，（上班时间），不需要去询问，因为那样其实会得罪供应商，也影响工人心情，只要记住供应商的关键人员，或者第一次进行确认后即可，不然，这个大门关卡是不及格的，需要考虑补救措施。
材料不可以只考虑使用出现问题的时候找供货商，最好货到之前做一次抽检，避免因为量过大存在瑕疵，如果等保要求高的话。
“夜间工作的意外保证” 在园区，一般是郊外，可以考虑使用报警装置（声音，特殊信号灯，呼喊，工作人员距离不太远等。）其次照明是必须要保证的，不管是日间还是夜间，存在意外风险的地方，必须保证照明，且特殊区域，在施工前，就必须确认监控等系统已经架设完全无死角，即使因为一两个存在意外，（无法避免的，量太多，施工肯定有风险）但是这个风险，不单是供应商的责任，在场任何一个参与施工的人员都有责任（如果等保要求高的话。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e4950ab64dc36688e68c8e00951e39/" rel="bookmark">
			观B站IPv6讲解视频有感
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考视频链接
B站 电子监听、全国断网，棱镜门背后，中国如何从末路狂奔到世界之巅
硬件不兼容 IPv4 和 IPv6 两个协议之间是不兼容的，所以如果要使用IPv6，必须保证硬件上支持IPv6协议才可以。
可以这样类比理解：
操作系统分为32位和64位，具体是由于所使用的CPU架构不同所导致的，因此原本支持IPv4的硬件设备未必就一定支持IPv6。
NAT技术 为了使现在有限的IPV4地址更大程度的发挥其本身作用，在IPv4的地址中，分组规划私网和公网地址段，从而仅可能利用现有IPv4地址。
因上述两个问题的存在，一开始企业对于IPv6的使用是存在抵触心理的，因为需要大批量更换现存设备，这需要一笔不菲的资金，另外由于NAT（NAPT）技术的出现，现有的IPv4地址完全足够企业内部使用，且与他人或另一个企业交流也能保证畅通无阻，毕竟还有VPN的技术，所以这时候，拦在IPv4与IPv6的技术前面，就剩DNS这个难题了，毕竟虽然有了足够的IP地址，但是如何让网站与IP地址挂钩，靠的是DNS服务器的解析，那么，这又存在什么难关呢？
DNS（Domain Name System）是互联网中用于将域名转换为IP地址的系统。在DNS中，有两种常见的查询方式：递归查询和迭代查询。
递归查询：递归查询是指本地域名服务器向根域名服务器发起查询请求，并一直向下追踪，直到找到所需的IP地址或者得到一个错误响应。在递归查询中，本地域名服务器会负责处理所有的查询过程，直到返回结果给客户端。迭代查询：迭代查询是指本地域名服务器向根域名服务器发起查询请求，根域名服务器会返回下一步应当找的顶级域名服务器的IP地址，然后本地域名服务器再向顶级域名服务器发起查询请求，以此类推，直到找到所需的IP地址或者得到一个错误响应。在迭代查询中，本地域名服务器会将查询结果返回给客户端，而不负责处理所有的查询过程。 对于不同的域名模式，递归查询和迭代查询的使用方式可能会有所不同。例如，在单一域名模式下，递归查询是最常见的方式，本地域名服务器会负责处理所有的查询过程。而在分布式域名模式下，迭代查询更为常见，本地域名服务器会根据根域名服务器返回的IP地址，依次向下追踪，直到找到所需的IP地址。
单一域名，可以理解为自定义域名后面只有一个 ".组织名" 即不存在多个域服务器 分布式域名则在自定义域名后面有多个 ".组织名" 总结起来，递归查询是本地域名服务器负责处理所有的查询过程，而迭代查询是本地域名服务器根据根域名服务器返回的IP地址，依次向下追踪查询。根据不同的域名模式，选择适合的查询方式可以提高DNS查询的效率和准确性。
因此可知根服务器是DNS查询网址的核心
危机出现 2014年1月21日，中国国内各大网站均无法访问，后经国家互联网应急中心证实，是根服务器遭到了攻击，且奇怪的是，该根服务器上所有有关中国的域名均出现乱码，无法解析。
之前IPv4启用时，主根服务器和大部分根服务器均是建立在美国的，而新建IPv6的DNS服务器，由于硬件上要升级，所以IPv4原有的DNS服务器是不支持IPv6的。
有关IPv6根服务器资料记载 —雪人计划
虽然全世界仅有三个主根，但是规定，主干间无法互相影响。
简要说明，这只是一个试验性计划，主根数据来自日本的M根服务器，而中国提供主要技术搭载IPv6网络，美国这边原有多个IPv4根服务器，可以方便数据迁移。
另一场发生在我国的危机：
在祖国高速发展的现在，许多设备走上了智能化的道路，但是网络中是依靠IP这个逻辑地址通信的，单有二层MAC地址是无法走出物联网的，所以，越来越多的传感器注定了要使用IPv6，这个目前已知可用地址最广的IP协议。而现在IPv4并非不能实现上述需求，只是需要重重叠加NAT或NAPT，这样进一步减缓了数据包传递的速度，不利于以后互联网的高速互联。
工程师和程序员让传感器维持一个心跳，不断保持主机和传感器间的通信。但是这种行为大大增加了设备功耗和信令负担。
信令负担是指在通信过程中，手机信令所产生的数据量和对网络资源的消耗。 简单来说，当我们使用手机进行通信时，手机会与基站进行信号交互，以建立通信连接。这个过程中，手机会发送一些信令数据给基站，告诉基站自己的身份和通信需求。而基站也会通过信令数据告诉手机一些网络信息，比如信号强度、可用频段等。 信令负担主要包括两个方面的问题。首先，信令数据的传输会占用一定的网络资源，包括带宽和处理能力。如果信令数据量过大，就会导致网络资源紧张，影响其他用户的通信质量。其次，信令数据的处理也需要消耗手机的电量和计算资源。如果信令负担过重，就会导致手机电量消耗过快，影响手机的续航能力。 为了减轻信令负担，可以采取一些优化措施。比如，可以通过优化信令协议和算法，减少信令数据的传输量。同时，可以通过优化网络架构和资源分配策略，提高网络的处理能力，减少信令数据的处理时间。此外，还可以通过优化手机的硬件设计和软件算法，减少信令数据对手机电量和计算资源的消耗。 总之，信令负担是指手机信令所产生的数据量和对网络资源的消耗。为了减轻信令负担，可以采取一些优化措施，包括优化信令协议和算法、优化网络架构和资源分配策略，以及优化手机的硬件设计和软件算法。 注意一个要点，现在虽然使用NAT技术实现了IPv4的尽可能重复利用，但是放大到工业物联网，不同的NAT园区有可能出现IPv4私有地址冲突的问题，毕竟虽然NAT使内网IPv4在出公网时使用公网的IPv4地址封装了源IP，但是对方那边，依然有可能由于NAT技术的存在，使用了和发出数据包一样的目的IP终端，那么，这能建立TCP链接吗？显然不可能。毕竟走二层，ARP地址表都混乱了。
那如果使用IPv6是否就能避免这个问题呢？目前已存在一种尝试的手段，就是NAT-PT技术。
NAPT技术和NAT-PT技术并不是完全相同的技术。虽然它们都涉及到网络地址转换（NAT），但是它们的应用场景和实现方式有所不同。 NAPT（Network Address Ports Translator）技术是一种在面临IPv4地址枯竭的情况下开发的技术。它可以将一个全局IP地址与多个主机的通信关联起来，通过转换TCP和UDP端口号来实现。NAPT技术主要用于在本地网络中使用私有地址，在连接互联网时转换为全局IP地址。 NAT-PT（Network Address Translation - Protocol Translation）技术是一种用于IPv4和IPv6之间相互通信的技术。它可以实现IPv4和IPv6地址的转换，以便在IPv4和IPv6网络之间进行通信。NAT-PT技术主要用于提高网络安全性和促进IPv6的部署。 因此，尽管NAPT和NAT-PT都涉及到网络地址转换，但它们的应用场景和实现方式是不同的。 NAT-PT技术可以让IPv6的地址翻译成IPv4，可以类比GRE隧道等封装概念。
且我国宣布推出公共DNS服务，具体配置如下：
DNS站点 240C::6666 或 240C::6644
家长管理模式，从网络层控制机器上网行为，网站： https://www.ipv6dns.com
甚至可以做一个大胆的预测，单公网中使用纯IPv6地址进行通信，NAT-PT技术会成为下一代NAT，私网设备全部使用IPv4地址，这样可想而知，网络中存在的设备将不会因为IP地址匮乏，导致无法智联使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/143abf3b65930cd9da15bba01c07356e/" rel="bookmark">
			分享七种msvcp140.dll丢失的解决方法，帮助大家解决msvcp140.dll丢失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		msvcp140.dll是一个重要的系统文件，它是微软视觉C++可再发行包的一部分。这个动态链接库（DLL）文件对于运行那些用Visual Studio 2015及其更新版本开发的应用程序至关重要。在Windows操作系统中，DLL文件提供执行许多常见任务的必要指令，使程序员能够重用代码并提供模块化程序设计。
一.msvcp140.dll文件的属性 文件名称：msvcp140.dll
描述：Microsoft C Runtime Library
隶属：Microsoft Visual C++ Redistributable for Visual Studio 2015
大小：不同版本的文件大小可能会有所不同
版本号：随 Visual Studio 版本变化而变化
通常位于：Windows系统的System32或SysWOW64文件夹内
二.msvcp140.dll丢失的解决方法 重新安装程序：如果特定的程序无法运行，并显示msvcp140.dll丢失的错误，首先尝试重新安装该程序。
使用dll修复工具：dll修复工具能够有效的修复文件丢失的问题，在浏览器顶部中输入：dll修复.site，DLL修复工具_一键修复所有dll缺失msvcp140.dll丢失的解决方法–电脑修复精灵
点击前往进入，就可以开始对丢失的msvcp140.dll文件进行修复，这工具有两种修复方式，方式一：使用一键修复，可以将msvcp140.dll文件和dll文件一起修复，方式二：使用手动修复，只将msvcp140.dll文件进行修复，直接搜索msvcp140.dll文件进行修复即可。
安装Visual C++ 可再发行包：由于msvcp140.dll是Microsoft Visual C++ Redistributable的一部分，所以下载并安装最新的Microsoft Visual C++ Redistributable Package可以解决这个问题。你可以从微软的官方网站直接下载安装，或者在程序中找到Microsoft Visual C++ Redistributable进行修复也可以解决msvcp140.dll丢失的问题。
手动复制文件：如果你确定自己的操作，也可以从另一台正常的电脑上复制正确版本的msvcp140.dll文件到你的电脑上出现问题的目录中去，但这种方法风险较大，可能带来版本不兼容和安全问题。
使用系统文件检查器：运行系统文件检查器(SFC)扫描可能修复损坏的msvcp140.dll文件。打开命令提示符(cmd)，输入sfc /scannow并执行。这里需要注意的是打开以管理员的身份才能将命令提示符正常使用。
进行系统还原：如果问题出现在最近的系统更改之后，使用系统还原到一个早前的恢复点可能会解决问题。
检查病毒或恶意软件感染：有时候病毒或恶意软件可能会假冒、修改或删除DLL文件。使用可靠的安全软件扫描系统，确保没有任何恶意干扰。
三.msvcp140.dll文件的常见问题 常见的msvcp140.dll问题往往发生在程序运行时，特别是当用户尝试启动使用了Visual C++库的应用程序时。通常，如果系统缺少Visual C++可再发行组件，或者msvcp140.dll文件损坏或被错误地删除，都可能导致上述错误出现。
解决msvcp140.dll丢失的问题通常不太复杂。根据上述步骤，通常可以快速恢复文件或修复错误。若你不熟悉这些步骤或感到不安，请咨询专业的技术支持人员。在尝试任何复杂的修复之前，记得备份你的数据以防万一。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a8b0cc87a3285483eec22bffe511d93/" rel="bookmark">
			数据分析之词云图绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试验任务概述：如下为所给CSDN博客信息表，分别汇总了'ai', 'algo', 'big-data', 'blockchain', 'hardware', 'math', 'miniprog'等7个标签的博客。对CSDN不同领域标签类别的博客内容进行词频统计，绘制词频统计图，并根据词频统计的结果绘制词云图。
数据表链接：https://download.csdn.net/download/m0_52051577/88669409?spm=1001.2014.3001.5503 import pandas as pd data=pd.read_csv(open('D://实训课//实训课数据csdn.csv'),sep=',') //导入数据 data //数据预览 如图，数据信息包括class、url、title、content四个类标签，分别表示博客所属领域类别、对应链接、博文题目和博客内容。下面第一步对这些博文按类别进行分类。
session=data.loc[:,'class'].values set(session)//对数据表的class类别列切分 def classma(i): class1=data.loc[data['class']==class_list[i],:] print(class1) return class1 //定义切分函数，按类别列作为索引返回每一类别对应的数据信息 class_list=['ai', 'algo', 'big-data', 'blockchain', 'hardware', 'math', 'miniprog'] # for i in range(len(class_list)): # classma(i) ai=classma(0) 分类结果如下图所示： 导入停用词表，对所分类数据进行停用词处理。
file_path='D:/..csv' def getStopword(file_path): stop_list=[line[:-1] for line in open(file_path+'/哈工大停用词表 .txt','r',encoding='UTF-8')] return stop_list getStopword(file_path) import jieba def preProcess(all_data,stop_list): xdata=all_data['content'] result_data=list(xdata) result=[] for doc in result_data: doc=doc.strip() cut_list=jieba.lcut(doc) doc_result=[word for word in cut_list if word not in stop_list] result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9a8b0cc87a3285483eec22bffe511d93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d40be29c43ac00486d74d59f1c0e0f38/" rel="bookmark">
			Linux 系统参数和变量配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、常见系统参数配置 （一）用户系统资源限制 文件路径：/etc/security/limits.conf
常见配置：
对appuser做资源限制 appuser soft nofile 655360 对所有用户做资源限制 * soft nofile 655360 对用户组做限制 @student hard nofile 65535 类型： soft 超过阈值告警 hard 真正的上限 命令：ulimit
ulimit -a 显示当前所有的资源限制 ulimit -H 设置硬件资源限制 必须卸载n参数前面 ulimit -S 设置软件资源限制 ulimit -n 设置进程最大打开文件描述符数 ulimit -f 设置可以建立的最大文件容量 注意：
可以限制通过PAM登录的用户资源使用，但是不对系统服务生效动态的参数同样会写进/pro/sys 目录下很多软件都有推荐的ulimit配置 （二）内核参数配置 文件 内核静态参数配置 /etc/sysctl.conf
例如：
在配置文件中追加：net.ipv4.ip_forward=1 sysctl -p /etc/sysctl.conf 使参数生效
命令 内核运行参数配置 sysctl
内核参数位置：/proc/sys 参数名称是以文件所在的路径，并将 '/' 以 '.' 来取代
例如：/proc/sys/net/ipv4/ip_forward的参数名称为net.ipv4.ip_forward
sysctl -w net.ipv4.ip_forward=1
等价于
echo 1 &gt; /proc/sys/net/ipv4/ip_forward
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d40be29c43ac00486d74d59f1c0e0f38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fffe039e0fb81629ee231ade811d49d/" rel="bookmark">
			缓存和缓冲的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近期被这两个词汇困扰了，感觉有本质的区别，搜了一些资料，整理如下
计算机内部的几个部分图如下
缓存（cache） https://baike.baidu.com/item/%E7%BC%93%E5%AD%98
提到缓存（cache），就想到了 cpu 高速缓存，其实最开始的缓存也是这个。
目的就是为了让 cpu 和内存之间的数据交互速度变快设计的。
从下到上访问速度依次递减，容量也越来越大。内存的访问速度比 cpu 缓存访问速度慢 100倍。
https://www.zhihu.com/question/349982942/answer/2935754503
其他缓存
浏览器缓存 https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98
之前的时代，网络不发达，带宽小，有了浏览器，打开一个网页需要每次加载页面需要的资源会时间长，后面浏览器的开发者就想到了重复的资源没必要重新加载，就考虑到浏览器缓存。
对于访问的资源如果每个请求后面都加了时间戳就没缓存了（缓存失效），相对于不加对于打开一个页面会发现明显变慢。
内存缓存 redis 对于数据库访问这块，为了减少数据库的访问次数，redis 的大神就想到了在内存中暂存这些数据。
因为内存通常来讲大一些，速度比硬盘快多了，所以在内存上暂存数据是一个不错的选择。
但是 redis 不是只有缓存功能，还有一些其他的功能。
缓冲（buffer） 为了提高内存和硬盘或其他io设备之间数据交换的速度设计的。在上面 cpu 缓存的基础上，硬盘比内存慢了几个数量级。
本质就是在内存上单独开辟了一个数组来存储当前的数据，将对磁盘的操作由随机操作变为顺序操作。由于磁盘的随机操作与顺序操作之间的数量级差距，在执行结果中会看到明显的差距。是用空间换时间的思想的实现。
压缩文件类似原理，将一个文件夹中的多个文件进行压缩，将多个小文件整理为一个文件，在磁盘上空间连续，在传输的过程中感觉快，如果是复制整个文件夹，会发现传输时间相对于压缩文件长，对于那些小文件数量多的情况下特别明显。
java 实现 如下 java.io 自带的原始的缓冲类
BufferedInputStream package java.io; public class BufferedInputStream extends FilterInputStream { private static int DEFAULT_BUFFER_SIZE = 8192; protected volatile byte buf[]; public BufferedInputStream(InputStream in) { this(in, DEFAULT_BUFFER_SIZE); } } BufferedOutputStream package java.io; public class BufferedOutputStream extends FilterOutputStream { protected byte buf[]; public BufferedOutputStream(OutputStream out) { this(out, 8192); } }	BufferedReader package java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fffe039e0fb81629ee231ade811d49d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72bbb1496fea77d6f01ef1282c151083/" rel="bookmark">
			2024美赛数学建模思路A题B题C题D题E题F题思路汇总 选题分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1 赛题思路2 美赛比赛日期和时间3 赛题类型4 美赛常见数模问题5 建模资料 1 赛题思路 (赛题出来以后第一时间在CSDN分享)
https://blog.csdn.net/dc_sinor?type=blog
2 美赛比赛日期和时间 比赛开始时间：北京时间2024年2月2日（周五）6:00
比赛结束时间：北京时间2024年2月6日（周二）9:00
提交截止日期：北京时间2024年2月6日10点（周二）
比赛结果：结果将于2024年5月31日或之前公布。
3 赛题类型 美国大学生数学建模竞赛目前分为两种类型，MCM（Mathematical Contest In Modeling）和 ICM（Interdisciplinary Contest In Modeling)，两种类型竞赛采用统一标准进行，竞赛题目出来之后，参数队伍通过美赛官网进行选题，一共分为 6 种题型。
MCM：A：连续型 B：离散型 C：大数据
ICM：D:运筹学/网络科学 E：可持续性 F：政策
4 美赛常见数模问题 趁现在赛题还没更新，A君给大家汇总一下建模经常使用到的数学模型，题目八九不离十基本属于一下四种问题，对应的解法A君也相应给出
分别为：
分类模型优化模型预测模型评价模型 4.1 分类问题
判别分析：
又称“分辨法”，是在分类确定的条件下，根据某一研究对象的各种特征值判别其类型归属问题的一种多变量统计分析方法。
其基本原理是按照一定的判别准则，建立一个或多个判别函数；用研究对象的大量资料确定判别函数中的待定系数，并计算判别指标；据此即可确定某一样本属于何类。当得到一个新的样品数据，要确定该样品属于已知类型中哪一类，这类问题属于判别分析问题。
聚类分析：
聚类分析或聚类是把相似的对象通过静态分类的方法分成不同的组别或者更多的子集，这样让在同一个子集中的成员对象都有相似的一些属性，常见的包括在坐标系中更加短的空间距离等。
聚类分析本身不是某一种特定的算法，而是一个大体上的需要解决的任务。它可以通过不同的算法来实现，这些算法在理解集群的构成以及如何有效地找到它们等方面有很大的不同。
神经网络分类：
BP 神经网络是一种神经网络学习算法。其由输入层、中间层、输出层组成的阶层型神经网络，中间层可扩展为多层。RBF（径向基）神经网络：径向基函数(RBF-Radial Basis Function)神经网络是具有单隐层的三层前馈网络。它模拟了人脑中局部调整、相互覆盖接收域的神经网络结构。感知器神经网络：是一个具有单层计算神经元的神经网络，网络的传递函数是线性阈值单元。主要用来模拟人脑的感知特征。线性神经网络：是比较简单的一种神经网络，由一个或者多个线性神经元构成。采用线性函数作为传递函数，所以输出可以是任意值。自组织神经网络：自组织神经网络包括自组织竞争网络、自组织特征映射网络、学习向量量化等网络结构形式。K近邻算法：　K最近邻分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。
4.2 优化问题
线性规划：
研究线性约束条件下线性目标函数的极值问题的数学理论和方法。英文缩写LP。它是运筹学的一个重要分支，广泛应用于军事作战、经济分析、经营管理和工程技术等方面。建模方法：列出约束条件及目标函数；画出约束条件所表示的可行域；在可行域内求目标函数的最优解及最优值。
非线性规划:
非线性规划是具有非线性约束条件或目标函数的数学规划，是运筹学的一个重要分支。非线性规划研究一个 n元实函数在一组等式或不等式的约束条件下的极值问题，且 目标函数和约束条件至少有一个是未知量的非线性函数。目标函数和约束条件都是 线性函数的情形则属于线性规划。
整数规划：
规划中的变量（全部或部分）限制为整数，称为整数规划。若在线性模型中，变量限制为整数，则称为整数线性规划。目前所流行的求解整数规划的方法往往只适用于整数线性规划。一类要求问题的解中的全部或一部分变量为整数的数学规划。从约束条件的构成又可细分为线性，二次和非线性的整数规划。
动态规划：
包括背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等。
动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。
多目标规划：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72bbb1496fea77d6f01ef1282c151083/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc5e89d6e73b129374196c9ec15c6b4/" rel="bookmark">
			R语言整洁编码的12大原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		好的编码风格就像正确使用标点符号一样，可以让我们写的代码更容易阅读。要知道，代码很多时候写出来，是给人看的，可能是自己，也可能是他人。
对于R语言新手，也建议大家规范编码。刚开始可能不习惯，但如果坚持练习，很快就能适应并成为你的第二天性，看着不规范的代码就难受，代码完美主义技能 get。
本文我们就来学习一下R语言整洁编码的12大原则。
命名
R语言变量的命名，应仅使用小写字母（a-z）和数字（0-9）组成，可用下划线（ _ ）分隔名称中的单词。如：
# 提倡: short_flights &lt;- flights |&gt; filter(air_time &lt; 60) # 避免: SHORTFLIGHTS &lt;- flights |&gt; filter(air_time &lt; 60) 原则一：根据一般经验，变量名尽量有意义，可以使用长而有描述性的名称，不应使用短的没意义的名称。但是一些特殊场合可以使用短名称，如代表循环计数的 i，大家普遍采用，使用短名称更显简洁。
原则二：如果有一系列相关变量，可以给它们一个相同的前缀，而不是相同的后缀，因为相同的前缀在开发环境中自动变量补全时具有优势。
空白
我见过新手写的R语言代码，行内无空格，行之间无空行，看着让人非常压抑。比如：
flights|&gt;filter(dest=="IAH")|&gt;group_by(year,month,day)|&gt;summarize(n=n(), delay=mean(arr_delay,na.rm=TRUE))|&gt;filter(n&gt;10) flights|&gt;filter(carrier=="UA",dest%in%c("IAH","HOU"),sched_dep_time&gt; 0900,sched_arr_time&lt;2000)|&gt;group_by(flight)|&gt;summarize(delay=mean( arr_delay,na.rm=TRUE),cancelled=sum(is.na(arr_delay)),n=n())|&gt;filter(n&gt;10) 相信很多人都拿到过类似的代码。留白非常重要，适时空格和空行，让代码看起来更具美感，画家作画还要留白呢，是吧？
原则三：在赋值运算符两侧加空格。
原则四：在数学运算符两侧加空格（指数运算符^除外）。
# 提倡 z &lt;- (a + b)^2 / d # 避免 z&lt;-( a + b ) ^ 2/d 原则五：常规函数调用时，函数名与括号之间不要有空格。总是在逗号后面紧跟一个空格，就像标准英语一样。
# 提倡 mean(x, na.rm = TRUE) # 避免 mean (x ,na.rm=TRUE) 原则六：为了代码整洁美观，可以增加必要的空格，如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffc5e89d6e73b129374196c9ec15c6b4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/11/">«</a>
	<span class="pagination__item pagination__item--current">12/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/13/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>