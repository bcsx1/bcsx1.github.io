<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/976fbb9e228609e5b7907b33e8393c8c/" rel="bookmark">
			搞不懂SDN？那是因为你没看这个小故事…
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 戳蓝字“CSDN云计算”关注我们哦！
作者 | 小枣君
来源 | 鲜枣课堂
很久很久以前，有一个村子，名叫“通信童心村”。
村里的每一户，都有一个男人和一个女人。
每一户，都以搬砖为生。
从不同的地方，搬到不同的地方。
他们怎么办呢？很简单，男人负责搬，女人负责告诉男人往哪搬。。。
每个家庭，都服从村委会的指挥。
村委会根据砖厂老板的需求，跑去告诉每家每户该怎么搬。。。
最开始，大家搬砖搬得挺开心的，一切都很顺利。
可是，砖头越来越多，村子规模大了，村户也多了。
每次搬砖计划有变动，村委会都要挨家挨户通知，实在太累了。
而且，因为村委会不能及时通知到位，影响了搬砖效率，砖厂老板们也很不开心。
于是，村委会请来了一个名叫“傻大妞（SDN）”的姑娘。
这个傻大妞说：
于是，傻大妞把每个家庭的女人们都赶回了娘家。。。
然后，傻大妞告诉每个家庭的男人们，以后只能说普通话（以前每家每户男人女人都说的是自己的方言），而且，只需要听她和她团队的。。。
男人们只听傻大妞的
傻大妞还告诉村委会，搬砖方案直接告诉她的团队就行。
于是，全新的搬砖方法开始运作了。。。
因为傻大妞全面接管了男人们。。。所以村委会省事了很多。。。命令直接传达给傻大妞。。。 效率得到提升，砖厂老板们更开心了，想往哪搬，就往哪搬。。。
故事愉快滴结束了。。。
不过，好像也不是每个人都那么愉快。。。
被fired（解雇）掉的女人们▼
（我是分割线）
好了。。。不知道这个故事大家看懂没有。。。
今天我们说的傻大妞，就是本文重点要说的“SDN”。
关于SDN的定义，有很多种说法，比较流行的定义是下面这个：
SDN是一种新兴的、控制与转发分离、并直接可编程的网络架构。
它的核心理念是，希望应用软件可以参与对网络的控制管理，满足上层业务需求，通过自动化业务部署简化网络运维。
其实说通俗一点，就是把“传统软硬件网络”给软件化、抽象化了。
简单来说，就是把现在复杂的传统网络设备全部对上层应用不可见。上层管理层，只需要像配置软件程序一样，对网络进行简单的部署，就能够让网络实现所需要的功能。不再需要和以前一样，一个一个去配置网络上所有节点的网络设备。
SDN架构示意图：
对比我们刚才的搬砖故事：
村子：通信网络
砖头：数据
每一户家庭：网络中的每一个网络设备
男人：网络设备的转发功能
女人：网络设备的控制功能
砖厂老板：上层用户
村委会：网络服务提供商
SDN带来的好处，显而易见：
1、控制和转发分离（男人和女人拆开），各个硬件厂家不能够再针对每个硬件设计和安装对应的软件系统（淘汰了方言），使得硬件可以通用化。打破了垄断，降低了设备成本。
2、SDN控制器进行统一管理（傻大妞团队统一接管男人），实现了集中控制，降低网络维护难度（村委会不用挨家挨户一个一个跑），缩短网络部署周期（砖厂老板们灵活调运砖头），降低运维成本。
对于那些女人们（传统硬件设备商），傻大妞（SDN）的出现确实并不是一个好消息，而对于砖厂老板们（用户）和村委会（服务提供商），傻大妞（SDN）肯定是很受欢迎的选择。
所以，几家欢喜几家愁咯。。。
SDN虽然看上去很强大，但仍然处于发展期，很多技术细节还不够成熟。
不过，SDN所代表的开放网络架构，肯定是未来网络的趋势。
这样的趋势，不可阻挡。
好啦，相信大家已经知道SDN是什么意思啦！ 重磅推荐↓ ↓ ↓
福利
扫描添加小编微信，备注“姓名+公司职位”，加入【云计算学习交流群】，和志同道合的朋友们共同打卡学习！
推荐阅读：
不让华为收专利费？美议员提案“秀下限”
如何给老婆解释什么是微服务？
阿里巴巴杨群：高并发场景下Python的性能挑战那些去德国的程序员后来怎么样了？新技术“红”不过十年，半监督学习为什么是个例外？独家对话V神! 质疑之下的以太坊路在何方?
真香，朕在看了！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc8790b2572920ecdedee1180fec9471/" rel="bookmark">
			绘制带有空洞的面要素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.新建要素面
2选择构造工具面。
3任意地方画线，画完不要双击，左键完成部件
4再画好的面内再画多边形，左键完成部件
5点完成草图，带空洞的面要素即画成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c777276dc71c6289dd7f59eb1277a2/" rel="bookmark">
			【ArcGIS】本地计算机上的ArcGIS Server服务启动后停止。某些服务在未由其他服务或程序使用时将自动停止
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：ArcGISServer安装后跳转页面打不开，服务起不来。
问题原因：卸载重装后目录没清干净，
参考：Arcgis server服务启动后停止
一般是因为多次安装server，且后面一次安装的路径和前面的一样，或者站点配置的时候，arcgisserver相关的目录和上一次安装的配置一样，导致
解决思路：
按照文章内容，重新配置server的账号和计算机管理里面更改server的用户名和密码 都没用，先卸载，删光相关server目录，然后重启服务器，都没采用第一次安装的默认目录，改为新目录，包括根服务器目录和配置存储目录，一套操作下来好了。
根服务器目录:E:\ArcGISServer\directories
配置存储:E:\ArcGISServer\configstore
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fdb14a52a6e7a62677bce1914469e72/" rel="bookmark">
			ijkplayer 编译总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在通过多次的尝试和多方查资料后，最终成功的编译了ijkplayer，并且添加了自己想要的mp2的音频编码。一开始的时候以为是一件比较难的事情，最后编译成功后，还是觉得比较的简单。
编译环境： 系统 ubuntu ，ndk 14 ，sdk ，git , yasm
我只在ubuntu的环境下编译，并没有在其他的环境下进行尝试，在环境中，最重要的是ndk的版本，需要在10 -14之间，我用了18 ，19 ，都失败，并且最低的ndk版本也是需要10以上。
这里是ndk旧版的下载地址，可以下载ndk14的版本：ndk旧版下载地址
将下载后的ndk解压到某个路径下，可以选择配置sdk和ndk的环境变量，也可以选择在我们编译ijkplayer的时候，需要用到的init-android.sh ，compile-ffmpeg.sh ，compile-ijk.sh ，的头部添加sdk和ndk的环境配置。
例如我们的sdk和ndk的环境变量配置为如下：
export ANDROID_SDK=/***/***/***/android/sdk export PATH=$ANDROID_SDK/platform-tools:$PATH export PATH=$ANDROID_SDK/tools:$PATH export ANDROID_NDK=/***/***/***/android/ndk14/android-ndk-r14b export PATH=$ANDROID_NDK:$PATH 然后可以在compile-ffmpeg.sh中做如下的添加
这样在编译的时候，就会自动的找到sdk和ndk的位置。
git 和 yasm的安装可以通过如下方式
sudo apt-get install git sudo apt-get install yasm 接下来是正题。这里是github中的ijkplayer的项目的地址 ijkplayer项目地址，在编译或是使用的过程中遇到的问题，都可以在这项目中的issues中查询。
以下是官方提供的编译的流程，我也是通过这个流程并且编译成功。
git clone https://github.com/Bilibili/ijkplayer.git ijkplayer-android cd ijkplayer-android git checkout -B latest k0.8.8 ./init-android.sh cd android/contrib ./compile-ffmpeg.sh clean ./compile-ffmpeg.sh all cd .. ./compile-ijk.sh all 通常这样编译就已经可以了，但是当我们想要兼容更多的视频格式或是音频的格式的时候，我们就需要修改 ijkplayer-android/config 下的文件。在这个路径下有4个文件。一下是官方提供的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fdb14a52a6e7a62677bce1914469e72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e649120b82d2f7022f79db0840a12f77/" rel="bookmark">
			javascript中: (function(){})();如何理解?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个项目产品都会让你加埋点，你是愿意花几天一个个加，还是愿意几分钟一个小时加完去喝茶聊天？来试试这520web工具, 高效加埋点，目前我们公司100号前端都在用，因为很好用，所以很自然普及开来了，推荐给大家吧
http://www.520webtool.com/
自己开发所以免费，埋点越多越能节约时间，点两下埋点就加上了，还不会犯错，里面有使用视频，反正免费 😄
转载于:https://zhidao.baidu.com/question/156291805.html
javascript中: (function(){})()是匿名函数，主要利用函数内的变量作用域，避免产生全局变量，影响整体页面环境，增加代码的兼容性。
(function(){})是一个标准的函数定义，但是没有复制给任何变量。所以是没有名字的函数，叫匿名函数。没有名字就无法像普通函数那样随时随地调用了，所以在他定义完成后就马上调用他，后面的括号()是运行这个函数的意思
扩展资料
函数声明：使用function声明函数，并指定函数名。　function setFn() { // coding }
函数表达式：使用function声明函数，但未指定函数名，将匿名函数赋予一个变量。
var setFn = function() { // coding}
匿名函数：使用function关键字声明函数，但未指定函数名。匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。
function() { // coding}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/051d857ba98af7f98f2148dd565911c6/" rel="bookmark">
			日期相关类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在实际软件项目开发中，经常会遇到处理时间和日期的情况。学会处理时间和日期，是程序员的一项基本技能。Java 语言中提供了Date、Calendar、GregorianCalendar、DateFormat、SimpleDateFormat类共同组成了标准日期时间处理类。Date、Calendar和GregorianCalendar位于java.util包中，而DateFormat和SimpleDateFormat位于java.text包中。
Date类
Date类表示特定的瞬间，精确到毫秒。该类提供了很多方法，但是很多已经过时，不推荐使用。
方 法
描 述
boolean after(Date when)
测试此日期是否在指定日期之后
boolean before(Date when)
测试此日期是否在指定日期之前
long getTime()
返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数
void setTime(long time)
设置此 Date 对象，以表示 1970 年 1 月 1 日 00:00:00 GMT 以后 time 毫秒的时间点
DateFormat抽象类与SimpleDateFormat类
java.text.DateFormat是一个抽象类，我们可以使用它用预定义的本地化方式格式化和解析时间日期。因为DateFormat是一个抽象类，所以不能直接实例化，但是它提供了大量的静态方法返回一个具体的子类，让我们可以用不同的方法格式化日期时间。
DateFormat类的getDateInstance()方法返回一个将日期按照默认地区或者特定地区的方式格式化的DateFormat对象，此外，还可以使用DateFormat的常量FULL、LONG、SHORT或DEFAULT来指定格式化的风格。与此类似，DateFormat类的getTimeInstance()方法返回一个DateFormat对象格式化时间，getDateTimeInstance()方法返回一个DateFormat对象格式化日期和时间。这些方法都带有可选的格式化风格的常量以及代表地区的Locale对象的常量。最后，getInstance()方法返回一个默认的DateFormat对象，将时间和日期都按照SHORT样式格式化。
得到了DateFormat类的具体子类后，我们就可以调用具体子类的Format()方法，按照预定义的方式格式化日期时间。
上面对日期时间格式化，都是采用默认的格式进行格式化。如果要采用自定义的格式输出日期时间格式，就要采用DateFormat的具体化子类SimpleDateFormat了。SimpleDateFormat类是一个以与语言环境相关的方式来格式化和分析日期的具体类，它可以让我们选择任何用户定义的日期/时间格式的模式来格式化日期和时间。
创建SimpleDateFormat对象时，需要传入一个日期和时间格式字符串做为格式化的模板。日期和时间格式由日期和时间模式字母所组成的字符串来指定。
模 式 字 母
日期或时间元素
示例
G
公元
公元
y
年
1996、 96
M
年中的月份
一月、二月 w
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/051d857ba98af7f98f2148dd565911c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8ec2c0602d9256ffc582c5b7f6643b5/" rel="bookmark">
			小波变换时频图绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		绘制原理： 需要用到的小波工具箱中的三个函数cwt()，centfrq()，scal2frq()
COEFS = cwt(S,SCALES,'wname') 该函数实现连续小波变换，其中S为输入信号，SCALES为尺度，wname为小波名称
FREQ = centfrq('wname') 该函数求以wname命名的母小波的中心频率。
F = scal2frq(A,'wname',DELTA) 该函数能将尺度转换为实际频率，其中A为尺度，wname为小波名称，DELTA为采样周期。
尺度与频率之间的关系
设a为尺度，fs为采样频率，Fc为小波中心频率，则a对应的实际频率Fa为
Fa＝Fc* fs/a，显然，根据采样定理，为使小波尺度图的频率范围为(0,fs/2)，尺度范围应为(2*Fc,inf),其中inf表示为无穷大。在实际应用中，只需取尺度足够大即可。
尺度序列的确定
由上式可以看出，为使转换后的频率序列是一等差序列，尺度序列必须取为以下形式： c/totalscal, c/(totalscal-1), …,c/2,c 其中，totalscal是对信号进行小波变换时所用尺度序列的长度(通常需要预先设定好)，c为一常数。 而尺度c/totalscal所对应的实际频率应为fs/2，于是可得 c=2Fctotalscal 于是可得到所需的尺度序列。
时频图的绘制
确定了小波基和尺度后，就可以用cwt求小波系数coefs（系数是复数时要取模），然后用scal2frq将尺度序列转换为实际频率序列f，最后结合时间序列t，用imagesc(t,f,abs(coefs))便能画出小波时频图。
二、应用例子 下面给出一实际例子来说明小波时频图的绘制。所取仿真信号是由频率分别为50Hz和100Hz的两个正弦分量所合成的信号
% 小波时频分析 clc clear all close all % 原始信号 fs=1000; f1=50; f2=100; t=0:1/fs:1; s=sin(2*pi*f1*t)+sin(2*pi*f2*t); figure plot(t, s) % 连续小波变换 wavename='cmor3-3'; totalscal=256; Fc=centfrq(wavename); % 小波的中心频率 c=2*Fc*totalscal; scals=c./(1:totalscal); f=scal2frq(scals,wavename,1/fs); % 将尺度转换为频率 coefs=cwt(s,scals,wavename); % 求连续小波系数 figure imagesc(t,f,abs(coefs)); set(gca,'YDir','normal') colorbar; xlabel('时间 t/s'); ylabel('频率 f/Hz'); title('小波时频图'); 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8ec2c0602d9256ffc582c5b7f6643b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b2c6653b5d59ada43cb6d0a9666a545/" rel="bookmark">
			laravel:The only supported ciphers are AES-128-CBC and AES-256-CBC with the correct key lengths.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Laravel 出现"RuntimeException inEncrypter.php line 43: The only supported ciphers are AES-128-CBC and AES-256-CBC with the correct key lengths."问题的解决办法 首先在cmd命令行下定位到项目所在的根目录下，接着输入：
php artisan key:generate 这时候项目根目录下的.env文件里的APP_KEY应该会有值了：
若没有，则将上一步生成的key值输入进去即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/840702d50999cc91277343708fa624f4/" rel="bookmark">
			python 将json文件存入mongodb &amp; 从 mongodb 读取json文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python 将json文件存入mongodb &amp; 从 mongodb 读取json文件 from pymongo import MongoClient import json class Json2Mongo(object): def __init__(self): self.host = '0.0.0.0' self.port = 27017 # 创建mongodb客户端 self.client = MongoClient(self.host, self.port) # 创建数据库dialog self.db = self.client.dialog # 创建集合scene self.collection = self.db.scene # 写入数据库 def write_database(self): with open('dfcg_ivr.json', 'r') as f: # 转换为dict json_data = json.load(f) data = { "name": "dfcg_ivr", "content": json_data } try: myquery = {"name": "dfcg_ivr"} # 查询条件 self.collection.update(myquery, data, upsert=True) # upsert=True不存在则插入，存在则更新 # self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/840702d50999cc91277343708fa624f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2586cdb7854aebf4ddfbd1a1f847201/" rel="bookmark">
			AI&#43;testing  AI方法在测试中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Software Testing + AI = ? 没有人知道这个鬼怎么解。
也许有人说这是蹭热度，但是不可否认的一点，AI是现在很火的一个概念，把Ai 和测试结合在一起。为什么不能呢？
在测试领域工作多年，我们也经历了几个不同的阶段。
手动测试自动测试CI+ 自动化测试 构建快速迭代的测试环境... 下一步会是AI+ testing 吗？ 我也想过这个问题很久，实际在工作中。我们已经或多或少的接触到.
我们通过jieba+多义词词库 来对一个QA系统提供测试数据语音识别 校验... 这两天接触到一本介绍AI 在测试中应用的书。 想借这个机会记录一下吧。盗一个图说明Ai
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ecdc99435943ce87857a7a2b2d24146/" rel="bookmark">
			JVM类加载过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. JVM类加载过程 1.概述
从类的生命周期而言，一个类包括如下阶段：
加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序进行，而解析阶段则不一定，它在某些情况下可能在初始化阶段后在开始，因为java支持运行时绑定。
2. 类加载时机
加载（loading）阶段，java虚拟机规范中没有进行约束，但初始化阶段，java虚拟机严格规定了有且只有如下5种情况必须立即进行初始化（初始化前，必须经过加载、验证、准备阶段）：
（1）使用new实例化对象时，读取和设置类的静态变量、静态非字面值常量（静态字面值常量除外）时，调用静态方法时。
（2）对内进行反射调用时。
（3）当初始化一个类时，如果父类没有进行初始化，需要先初始化父类。
（4）启动程序所使用的main方法所在类
（5）当使用1.7的动态语音支持时。
如上5种场景又被称为主动引用，除此之外的引用称为被动引用，被动引用有如下3种常见情况
通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。定义对象数组和集合，不会触发该类的初始化类A引用类B的static final常量不会导致类B初始化（注意静态常量必须是字面值常量，否则还是会触发B的初始化） public class TestClass { public static void main(String[] args) { System.out.println(ClassInit.str); System.out.println(ClassInit.id); } } class ClassInit{ public static final long id=IdGenerator.getIdWorker().nextId();//需要初始化ClassInit类 public static final String str="abc";//字面值常量 static{ System.out.println("ClassInit init"); } } 通过类名获取Class对象，不会触发类的初始化。如System.out.println(Person.class);通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化。通过ClassLoader默认的loadClass方法，也不会触发初始化动作 注意：被动引用不会导致类初始化，但不代表类不会经历加载、验证、准备阶段。
3. 类加载方式
这里的类加载不是指类加载阶段，而是指整个类加载过程，即类加载阶段到初始化完成。
（1）隐式加载
创建类对象使用类的静态域创建子类对象使用子类的静态域在JVM启动时，BootStrapLoader会加载一些JVM自身运行所需的class在JVM启动时，ExtClassLoader会加载指定目录下一些特殊的class在JVM启动时，AppClassLoader会加载classpath路径下的class，以及main函数所在的类的class文件 （2）显式加载
ClassLoader.loadClass(className)，只加载和连接、不会进行初始化Class.forName(String name, boolean initialize,ClassLoader loader); 使用loader进行加载和连接，根据参数initialize决定是否初始化。 2. 加载阶段 加载是类加载过程中的一个阶段，不要将这2个概念混淆了。
在加载阶段，虚拟机需要完成以下3件事情：
通过一个类的全限定名来获取定义此类的二进制字节流将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 加载.class文件的方式
从本地系统中直接加载通过网络下载.class文件从zip，jar等归档文件中加载.class文件从专有数据库中提取.class文件将Java源文件动态编译为.class文件 相对于类生命周期的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ecdc99435943ce87857a7a2b2d24146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2239abda01f670ea17f79f14e1894b63/" rel="bookmark">
			Oracle数据库之oracle update set select from 关联更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要向大家介绍了Oracle数据库之oracle update set select from 关联更新，通过具体的内容向大家展现，希望对大家学习Oracle数据库有所帮助。
工作中有个需求，现在新表中有一些数据跟老表的基本一样，这样只需要把老表中数据搬到新表中就可以了，同时把不同的字段修改下数据即可，在修改字段时发 现，需要指定一个条件，比如主键id，来修改某条记录，这样一条一条修改效率太低了，有没有批量操作的方式 呢？SQL&gt;select * from wwn2;
TOWN ID
-------------------- ----------
222 222
111 111
ww‘jj 111
llll 1111
dddd 2222
lllldf 111
lllldf 111
dsafdf 111
3435 111
ljjjjj 222
dsafdf 111
3435 111
ljjjjj 222
SQL&gt; select * from wwm5; TOWN ID
-------------------- ----------
lllldf 111
test 9984
SQL&gt; select wwm2.* from wwm2,wwm5 where wwm2.id=wwm5.id
TOWN ID
-------------------- ----------
111 111
ww‘jj 111
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2239abda01f670ea17f79f14e1894b63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/058813aa6c7b4f80793b2d50d4366458/" rel="bookmark">
			站内信（系统消息） 发送给所有用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打算做一个站内信 又不想做成那种 查询所有用户 每一个用户发送一条消息 就建立了 两个数据表 进行了一下简单的优化 也不是很完善 大家 有好的方案 请多指教 CREATE TABLE `system_message` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '文档id', `user_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '指定接收人ID', `content` varchar(256) NOT NULL DEFAULT '' COMMENT '消息内容', `is_read` enum('0','1') NOT NULL DEFAULT '0' COMMENT '是否到达:0=否,1=是', `event` varchar(128) NOT NULL DEFAULT '' COMMENT '事件', `is_all` enum('0','1') NOT NULL DEFAULT '0' COMMENT '是否是群发消息:0=否,1=是'， `msgtype` tinyint(1) NOT NULL DEFAULT '1' COMMENT '消息类型', `create_time` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8mb4 COMMENT='系统消息模型扩展表'; 这个是信息的 主表 记录所有的信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/058813aa6c7b4f80793b2d50d4366458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac6a86661a3383de9426ae21e3d5b54/" rel="bookmark">
			多项式乘法 快速傅里叶变换FFT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 多项式的表示系数表达点值表达 基于单位复数根的FFT思路单位复数根的定义和性质快速傅里叶变换（FFT） FFT的高效实现 多项式的表示 系数表达 我们把一个次数界为n的多项式记为 A ( x ) = a [ 0 ] + a [ 1 ] x + a [ 2 ] x 2 + a [ 3 ] x 3 . . . A(x) = a[0]+a[1]x+a[2]x^2+a[3]x^3... A(x)=a[0]+a[1]x+a[2]x2+a[3]x3... ，其系数可以用一个一维向量 ( a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] . . . ) (a[0],a[1],a[2],a[3]...) (a[0],a[1],a[2],a[3].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac6a86661a3383de9426ae21e3d5b54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b27b84ebb3d621caaaaf6a811ab53d35/" rel="bookmark">
			Freemaker FTL指令常用标签及语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FTL指令常用标签及语法
注意：使用freemaker，要求所有标签必须闭合，否则会导致freemaker无法解析。
freemaker注释:&lt;#-- 注释内容 --&gt;格式部分,不会输出
---------------------------------- 基础语法 ---------------------------------- 1、字符输出 ${emp.name?if_exists} // 变量存在，输出该变量，否则不输出
${emp.name!} // 变量存在，输出该变量，否则不输出
${emp.name?default("xxx")} // 变量不存在，取默认值xxx
${emp.name!"xxx"} // 变量不存在，取默认值xxx
常用内部函数：
${"123&lt;br&gt;456"?html} // 对字符串进行HTML编码，对html中特殊字符进行转义
${"str"?cap_first} // 使字符串第一个字母大写
${"Str"?lower_case} // 将字符串转换成小写
${"Str"?upper_case} // 将字符串转换成大写
${"str"?trim} // 去掉字符串前后的空白字符
字符串的两种拼接方式拼接：
${"hello${emp.name!}"} // 输出hello+变量名
${"hello"+emp.name!} // 使用+号来连接，输出hello+变量名
可以通过如下语法来截取子串:
&lt;#assign str = "abcdefghijklmn"/&gt;
// 方法1
${str?substring(0,4)} // 输出abcd
// 方法2
${str[0]}${str[4]} // 结果是ae
${str[1..4]} // 结果是bcde
// 返回指定字符的索引
${str?index_of("n")}
2、日期输出 ${emp.date?string('yyyy-MM-dd')} //日期格式
3、数字输出(以数字20为例) ${emp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b27b84ebb3d621caaaaf6a811ab53d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5d09ba958e20f51df3ea90d0b9cabf0/" rel="bookmark">
			四旋翼飞行器控制原理与设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、相关理论知识
1.坐标系与欧拉角
进行动力学建模之前首先建立坐标系，在此建立地球坐标系和机体坐标系，如图所示，这里地球系z轴方向向下指向地心，机体系x轴为机头方向。
当描述一个三维空间内的刚体转动时，需要选用三个独立的角度来表示刚体的相对位置。即，刚体绕固定点的旋转可以看成是若干次旋转的合成，旋转方法不是唯一的，所以欧拉角有多种取法，不同的取法、不同的转动顺序都会对于不同的旋转矩阵。在研究四旋翼时，为了与四旋翼的滚转、俯仰、偏航相对应，可以取绕x旋转角度为φ（滚转，右滚为正），绕y轴旋转角度为θ（俯仰，仰头为正），绕z轴旋转为ψ（偏航，右偏为正）。
由地球坐标系转到机体坐标系为xyz旋转，又称卡尔丹角。实际上理论分析时，旋转顺序不是很重要，zyx、zxy都可以，虽然最后姿态解算时四元数与欧拉角的关系式不同，但是都可以进行解算。
2.旋转矩阵
绕x轴旋转的旋转矩阵为，
绕y轴旋转的旋转矩阵为，
绕z轴旋转的旋转矩阵为，
这样，xyz旋转时，一个向量由地球系的表示转为机体系的表示，可以写成，
由机体系转向地球系的姿态矩阵为，
3.四元数及其与欧拉角的关系
关于四元数的详细定义等参见秦永元的《惯性导航》，非常详细，这里不搬了。
以zyx旋转顺序为例，此时其旋转矩阵
此时由四元数表示的旋转为
这样一一对应，可以求得后面姿态解算时要用到的一些式子，
①重力在机体坐标系下的表示：
②四元数与欧拉角的关系：
四元数具体的推导和计算太多了，详见《捷联式惯性导航原理》。关于四元数与旋转矩阵我查阅了很多资料，比较官方的书呢，推导都是用的zyx旋转顺序，推出上式中四元数与欧拉角的关系。其他资料呢，有用不同的旋转顺序，但是对应旋转矩阵时很容易搞错。我觉得四元数与欧拉角的关系不是唯一的，只取决于使用的四元数，旋转顺序不同，对应的四元数自然不同。这主要影响的是解算过程中，q的值可能是不同的，但解算出的欧拉角都是一样的。
二、控制模型建立
首先，建模的目的是基于这个模型设计控制器。四旋翼是一个非线性的多输入系统，但是，为了简化处理，在小角度时，可以将模型简化为线性的，进而就可以使用线性控制的方法处理。
1.四旋翼动力学模型
①欧拉角表示为，
其中，
②四元数表示为，
（上面两个式子实际上是四元数运动学微分方程，后面姿态解算时会用到）
2.简化为控制模型
在这里研究给定期望姿态角，期望高度的控制模型，这样可以分为四个通道：高度通道、俯仰通道、滚转通道、偏航通道，俯仰通道、滚转通道、偏航通道模型是一样的，是姿态模型。
①先看高度通道（z方向）的化简，
变为，
（俯仰、滚转都很小时）
②再看姿态通道的化简，
变为，
（角度小，速度小时）
3.四旋翼控制分配模型
控制分配模型是建立伪控制量与实际控制量之间关系的模型，以X4型传统四旋翼为例，其伪控制量实际是几个通道经过pid之后的输出值pidout，高度通道的输出可以看做是总拉力，.姿态通道可以看成是力矩（具体分析就涉及到pid控制器的设计了）；其实际控制量可以看成是电机转速的平方。这几个伪控制量与实际控制量的对应关系如下：
,其中是电机转速平方与拉力之间的关系系数，是电机转速平方与反扭力之间的关系系数，d是机臂长度。
控制分配模型在普通四旋翼上的分配基本是固定的，但是当伪控制量与实际控制量个数不一致时，控制分配就很重要。
三、控制算法及实现
全自主飞控的控制逻辑是从给定期望轨迹和期望偏航开始的，首先经过这一位置控制得到期望的拉力和期望的三个姿态角，在这里，我暂不考虑轨迹控制，即飞控的逻辑是从给定期望姿态角和期望高度开始。
这样，飞控底层框架大致如下图，
图比较乱，硬件、算法、数据都在里面了，基本能看懂…可以看出，四旋翼的三个核心算法：姿态解算算法、pid控制算法、控制分配算法。
1.姿态解算
四旋翼姿态解算的方法有很多，有基于四元数，有基于旋转矩阵，有互补滤波，有卡尔曼滤波，其实不管是哪种滤波解算的算法，思想都是利用加速度计解算出得数据去修正陀螺仪积分产生偏差。在这里我主要研究了一下最常用的，四元数互补滤波，这个资料已经比较全了，每一个步骤我只记录一下我的理解。
（1）初始化四元数
static float q0 = 1.0f; static float q1 = 0.0f;
static float q2 = 0.0f;
static float q3 = 0.0f; （2）加速度计低通滤波，去除一部分高频噪声，获取加速度计、陀螺仪值
（3）加速度计测量值规范化
normalise = invSqrt(acc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5d09ba958e20f51df3ea90d0b9cabf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd839addfabb3306e8a8b4942b549a8/" rel="bookmark">
			四旋翼飞控原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前，搞无人机的十个人有八个是航空、气动、机械出身，更多考虑的是如何让飞机稳定飞起来、飞得更快、飞得更高。如今，随着芯片、人工智能、大数据技术的发展，无人机开始了智能化、终端化、集群化的趋势，大批自动化、机械电子、信息工程、微电子的专业人材投入到了无人机研发大潮中，几年的时间让无人机从远离人们视野的军事应用飞入了寻常百姓家、让门外汉可以短暂的学习也能稳定可靠的飞行娱乐。不可否认，飞控技术的发展是这十年无人机变化的最大推手。
飞控是什么？
飞行控制系统（Flight control system）简称飞控，可以看作飞行器的大脑。多轴飞行器的飞行、悬停，姿态变化等等都是由多种传感器将飞行器本身的姿态数据传回飞控，再由飞控通过运算和判断下达指令，由执行机构完成动作和飞行姿态调整。
控可以理解成无人机的CPU系统，是无人机的核心部件，其功能主要是发送各种指令，并且处理各部件传回的数据。类似于人体的大脑，对身体各个部位发送指令，并且接收各部件传回的信息，运算后发出新的指令。例如，大脑指挥手去拿一杯水，手触碰到杯壁后，因为水太烫而缩回，并且将此信息传回给大脑，大脑会根据实际情况重新发送新的指令。
无人机的飞行原理及控制方法（以四旋翼无人机为例）
四旋翼无人机一般是由检测模块，控制模块，执行模块以及供电模块组成。检测模块实现对当前姿态进行量测；执行模块则是对当前姿态进行解算，优化控制，并对执行模块产生相对应的控制量；供电模块对整个系统进行供电。
四旋翼无人机机身是由对称的十字形刚体结构构成，材料多采用质量轻、强度高的碳素纤维；在十字形结构的四个端点分别安装一个由两片桨叶组成的旋翼为飞行器提供飞行动力，每个旋翼均安装在一个电机转子上，通过控制电机的转动状态控制每个旋翼的转速，来提供不同的升力以实现各种姿态；每个电机均又与电机驱动部件、中央控制单元相连接，通过中央控制单元提供的控制信号来调节转速大小；IMU惯性测量单元为中央控制单元提供姿态解算的数据，机身上的检测模块为无人机提供了解自身位姿情况最直接的数据，为四旋翼无人机最终实现复杂环境下的自主飞行提供了保障。
现将位于四旋翼机身同一对角线上的旋翼归为一组，前后端的旋翼沿顺时针方向旋转，从而可以产生顺时针方向的扭矩；而左右端旋翼沿逆时针方向旋转，从而产生逆时针方向的扭矩，如此四个旋翼旋转所产生的扭矩便可相互之间抵消掉。由此可知，四旋翼飞行器的所有姿态和位置的控制都是通过调节四个驱动电机的速度实现的。一般来说，四旋翼无人机的运动状态主要分为悬停、垂直运动、滚动运动、俯仰运动以及偏航运动五种状态。
悬停
悬停状态是四旋翼无人机具有的一个显著的特点。在悬停状态下，四个旋翼具有相等的转速，产生的上升合力正好与自身重力相等，即。并且因为旋翼转速大小相等，前后端转速和左右端转速方向相反，从而使得飞行器总扭矩为零，使得飞行器静止在空中，实现悬停状态。
垂直运动
垂直运动是五种运动状态中较为简单的一种，在保证四旋翼无人机每个旋转速度大小相等的倩况下，同时对每个旋翼增加或减小大小相等的转速，便可实现飞行器的垂直运动。当同时増加四个旋翼转速时，使得旋翼产生的总升力大小超过四旋翼无人机的重力时，即，四旋翼无人机便会垂直上升；反之，当同时减小旋翼转速时，使得每个旋翼产生的总升力小于自身重力时，即，四旋翼无人机便会垂直下降，从而实现四旋翼无人机的垂直升降控制。
翻滚运动
翻滚运动是在保持四旋翼无人机前后端旋翼转速不变的情况下，通过改变左右端的旋翼转速，使得左右旋翼之间形成一定的升力差，从而使得沿飞行器机体左右对称轴上产生一定力矩，导致在方向上产生角加速度实现控制的。如图2.3所示，增加旋翼1的转速，减小旋翼3的转速，则飞行器倾斜于右侧飞行；相反，减小旋翼４，增加旋翼２，则飞行器向左倾斜飞行。
俯仰运动
四旋翼飞行器的俯仰运动和滚动运动相似，是在保持机身左右端旋翼转速不变的前提下，通过改变前后端旋翼转速形成前后旋翼升力差，从而在机身前后端对称轴上形成一定力矩，引起角方向上的角加速度实现控制的。如图2.4所示，增加旋翼３的转速，减小旋翼１的转速，则飞行器向前倾斜飞行；反之，则飞行器向后倾斜。
偏航运动
四旋翼的偏转运动是通过同时两两控制四个旋翼转速实现控制的。保持前后端或左右端旋翼转速相同时，其便不会发生俯仰或滚动运动；而当每组内的两个旋翼与另一组旋翼转速不同时，由于两组旋翼旋转方向不同，便会导致反扭矩力的不平衡，此时便会产生绕机身中心轴的反作用力，引起沿角角加速度。如图2.3所示，当前后端旋翼的转速相等并大于左右端旋翼转速时，因为前者沿顺时针方向旋转，后者相反，总的反扭矩沿逆时针方向，反作用力作用在机身中心轴上沿逆时针方向，引起逆时针偏航运动；反之，则会引起飞行器的顺时针偏航运动。
综上所述，四旋翼无人机的各个飞行状态的控制是通过控制对称的四个旋翼的转速，形成相应不同的运动组合实现的。但是在飞行过程中却有六个自由度输出，因此它是一种典型的欠驱动，强耦合的非线性系统。例如，旋翼1的转速会导致无人机向左翻滚，同时逆时针转动的力矩会大于顺时针的力矩，从而进一步使得无人机向左偏航，此外翻滚又会导致无人机的向左平移，可以看出，四旋翼无人机的姿态和平动是耦合的。
四旋翼无人机自主飞行的控制
四旋翼无人机的精确航迹跟踪是实现无人机自主飞行的基本要求。由于四旋翼无人机自身存在姿态与平动的耦合关系以及模型参数不确定性与外界扰动，因此只有实现姿态的稳定控制才能完成航迹的有效跟踪。
在四旋翼无人机的自主控制系统中，姿态稳定控制是实现飞行器自主飞行的基础。其任务是控制四旋翼无人机的三个姿态角（俯仰角、滚转角、偏航角）稳定地跟踪期望姿态信号，并保证闭环姿态系统具有期望的动态特性。由于四旋翼无人机姿态与平动的耦合特点，分析可以得知，只有保证姿态达到稳定控制，才使得旋翼总升力在期望的方向上产生分量，进而控制飞行器沿期望的航迹方向飞行。而四旋翼无人机的姿态在实际飞行环境中回受到外界干扰和不精确模型的参数误差、测量噪声等未建模动态对控制效果的影响。所以，需要引入适当的观测器和控制器对总的不确定性进行估计和补偿，并对其估计的误差进行补偿，来保证四旋翼无人机在外界存在干扰下对姿态的有效跟踪。
四旋翼无人机的姿态控制应根据其实际的工作特性以及动力学模型，进而针对姿态的三个通道（俯仰，翻滚和偏航）分别设计姿态控制器，每个通道中都对应引入相应的控制器，其流程如下所示。
此方法可以基本保证每个通道的实际姿态值跟踪上期望值。但是，在只考虑对模型本身进行控制时，没有考虑到外部不确定性对闭环系统的影响。微小型无人机在飞行时，由于机体较小，电机的振动较强，很容易受到外界环境的干扰。因此，整个通道中必然存在不确定因素，比如模型误差、环境干扰、观测误差等，这些不确定性将降低系统的闭环性能。所以在设计无人机控制系统时，必须要考虑系统的抗干扰性能，即闭环系统的鲁棒性。因此需要设计一定的干扰补偿器对干扰进行逼近和补偿，以实现姿态角的稳定跟踪。
只有在保证飞机姿态可以保持稳定才能进一步讨论如何控制路径保持稳定，在时间尺度上进行分析，飞机的姿态角变化的频率要大于飞机位置的频率。所以，针对轨迹跟踪应当使用内外双环控制，内环控制姿态角，外环控制位置。
无人机飞控系统组成及作用
IMU惯性测量单元
现在的飞控内部使用的都是由三轴陀螺仪，三轴加速度计，三轴地磁传感器和气压计组成的一个IMU，也称惯性测量单元。那么什么是三轴陀螺仪，什么是三轴加速度计，什么是三轴地磁传感器呢，什么是气压计呢？它们在飞机上起到的是什么作用呢，这三轴又是哪三个轴呢？
三轴陀螺仪，三轴加速度计，三轴地磁传感器中的三轴指的就是飞机左右，前后垂直方向上下这三个轴，一般都用XYZ来代表。左右方向在飞机中叫做横滚，前后方向在飞机中叫做俯仰，垂直方向就是Z轴。陀螺都知道，小时候基本上都玩过，在不转动的情况下它很难站在地上，只有转动起来了，它才会站立在地上，或者说自行车，轮子越大越重的车子就越稳定，转弯的时候明显能够感觉到一股阻力，这就是陀螺效应，根据陀螺效应，聪明的人们发明出的陀螺仪。最早的陀螺仪是一个高速旋转的陀螺，通过三个灵活的轴将这个陀螺固定在一个框架中，无论外部框架怎么转动，中间高速旋转的陀螺始终保持一个姿态。通过三个轴上的传感器就能够计算出外部框架旋转的度数等数据。
由于成本高，机械结构的复杂，现在都被电子陀螺仪代替，电子陀螺仪的优势就是成本低，体积小重量轻，只有几克重，稳定性还有精度都比机械陀螺高。说道这，大家也就明白陀螺仪在飞控中起到的作用了吧，它就是测量XYZ三个轴的倾角的。
那么三轴加速度计时干什么的呢？刚刚说道三轴陀螺仪就是XYZ三个轴，现在不用说也就明白三轴加速度计也是XYZ三个轴。当我们开车起步的一瞬间就会感到背后有一股推力，这股推力呢就是加速度，加速度是速度变化量与发生这一变化时间的比值，是描述物体变化快慢的物理量，米每二次方秒，例如一辆车在停止状态下，它的加速度是0，起步后，从每秒0米到每秒10米，用时10秒，这就是这辆车的加速度，如果车速每秒10米的速度行驶，它的加速度就是0，同样，用10秒的时间减速，从每秒10米减速到每秒5米，那么它的加速就是负数。三轴加速度计就是测量飞机XYZ三个轴的加速度。
我们日常出行都是根据路标或记忆来寻找自己的面向的，地磁传感器就是感知地磁的，就是一个电子指南针，它可以让飞机知道自己的飞行朝向，机头朝向，找到任务位置和家的位置。气压计呢就是测量当前位置的大气压，都知道高度越高，气压越低，这就是人到高原之后为什么会有高原反应了，气压计是通过测量不同位置的气压，计算压差获得到当前的高度，这就是整个IMU惯性测量单元，它在飞机中起到的作用就是感知飞机姿态的变化，例如飞机当前是前倾还是左右倾斜，机头朝向、高度等最基本的姿态数据，那么这些数据在飞控中起到的作用是什么呢？
飞控最基本的功能控制一架飞机在空中飞行时的平衡，是由IMU测量，感知飞机当前的倾角数据通过编译器编译成电子信号，将这个信号通过信号新时时传输给飞控内部的单片机，单片机负责的是运算，根据飞机当前的数据，计算出一个补偿方向，补偿角，然后将这个补偿数据编译成电子信号，传输给舵机或电机，电机或舵机在去执行命令，完成补偿动作，然后传感器感知到飞机平稳了，将实时数据再次给单片机，单片机会停止补偿信号，这就形成了一个循环，大部分飞控基本上都是10HZ的内循环，也就是1秒刷新十次。
这就是飞控最基本的功能，如果没有此功能，当一个角一旦倾斜，那么飞机就会快速的失去平衡导致坠机，或者说没有气压计测量不到自己的高度位置就会一直加油门或者一直降油门。其次，固定翼飞控还有空速传感器，空速传感器一般位于机翼上或机头，但不会在螺旋桨后边，空速传感器就是两路测量气压的传感器，一路测量静止气压，一路测量迎风气压，在计算迎风气压与静止气压的压差就可以算出当前的空气流速。
有了最基本的平衡、定高和指南针等功能，还不足以让一家飞机能够自主导航，就像我们去某个商场一样，首先我们需要知道商场的所在位置，知道自己所在的位置，然后根据交通情况规划路线。飞控也亦然，首先飞控需要知道自己所在位置，那就需要定位的，也就是我们常说的GPS，现在定位的有GPS、北斗、手机网络等定位系统，但是这里面手机网络定位是最差的，误差好的话几十米，不好的话上千米，这种误差是飞控无法接受的，由于GPS定位系统较早，在加上是开放的，所以大部分飞控采用的都是GPS，也有少数采用的北斗定位。精度基本都在3米内，一般开阔地都是50厘米左右，因环境干扰，或建筑物、树木之类的遮挡，定位可能会差，很有可能定位的是虚假信号。这也就是为什么民用无人机频频坠机、飞丢的一个主要原因。
GPS定位
GPS定位原理就是三点定位，天上的GPS定位卫星距离地球表面22500千米处，它们所运动的轨道正好形成一个网状面，也就是说在地球上的任意一点，都有可以同时收到3颗以上的卫星信号。卫星在运动的过程中会一直不断的发出电波信号，信号中包含数据包，其中就有时间信号。GPS接收机通过解算来自多颗卫星的数据包，以及时间信号，可以清楚的计算出自己与每一颗卫星的距离，使用三角向量关系计算出自己所在的位置。GPS也定位了，数据也有了，这个信号也会通过一个编译器在次编译成一个电子信号传给飞控，让飞控知道自己所在的位置、任务的位置和距离、家的位置和距离以及当前的速度和高度，然后再由飞控驾驶飞机飞向任务位置或回家。
刚刚我们也说了，GPS能够测速也能够测高度，为什么要有气压计和空速计呢？这就是为了消除误差，飞机飞起来是不与地面接触的，直接接触的是空气，假设飞行环境是无风的环境，飞机在地面滑跑加速，加速到每秒20米的速度然后再拉升降舵起飞，这样GPS测量到的数值是准确的，但是要是逆风呢，是因为机翼与空气相对的运动达到了一定的速度才能够产生一定的升力让飞机起飞，如果在逆风环境下，风速每秒10米，飞机只需要加速到每秒10米就可以正常离地了，如果加速到每秒20米，相对空气的速度已经达到了每秒30米，或者说顺风起飞，风速每秒20米，飞机GPS测速也达到了20m/s的速度，这个时候拉升降舵，飞机动都不会动，因为相对空气速度是0米，达不到起飞条件，必须加速到每秒40米的时候才能达到升力起飞。
这就是空速计的作用，GPS测量的只是地速，刚刚降到，GPS也可以定高，第一GPS定位精度是3米内，也就是说飞控能感知到的是平面方向的两倍误差，信号不好的话十几米都有可能，还有GPS不定位的时候，另外GPS定高数据是海拔高度并不是地面垂直高度，所以GPS定高在飞控中不管用。有了GPS飞控也知道飞机位置了，也知道家的位置和任务位置，但是飞控上的任务以及家的位置飞控是怎么知道的呢，这就是地面站的作用。
地面站
地面站，就是在地面的基站，也就是指挥飞机的，地面站可以分为单点地面站或者多点地面站，像民航机场就是地面站，全国甚至全球所有的地面站都在时时联网，它们能够清楚的知道天上在飞行的飞机，并能时时监测到飞机当前的飞行路线，状况，以及飞机的时时调度等。像我们用的无人机大部分都是单点地面站，单点地面站一般由一到多个人值守，有技术员，场务人员，后勤员，通信员，指挥员等人组成。像玩家一般都是一个人。
地面站设备组成一般都是由遥控器、电脑、视频显示器，电源系统，电台等设备组成，一般简单的来说就是一台电脑，一个电台，一个遥控，电脑上装有控制飞机的软件，通过航线规划工具规划飞机飞行的线路，并设定飞行高度，飞行速度，飞行地点，飞行任务等通过数据口连接的数传电台将任务数据编译传送至飞控中，这里就有讲到数传电台，数传电台就是数据传输电台，类似我们最和耳朵一样，好比领导说今天做什么任务，我们接受到任务并回答然后再去执行任务，执行任务的时候时实情况实时汇报给领导，这其中通信就是嘴巴和耳朵。
数传电台就是飞机与地面站通信的一个主要工具，一般的数传电台采用的接口协议有TTL接口、RS485接口和RS232接口，的不过也有一些CAN-BUS总线接口，频率有2.4GHZ、433MHZ、900MHZ、915MHZ，一般433MHZ的较多，因为433MHZ是个开放的频段，再加上433MHZ波长较长，穿透力强等优势所以大部分民用用户一般都是用的433MHZ，距离在5千米到15千米不等，甚至更远。最终达到的就是飞机与电脑间的通讯，电脑给飞机的任务，飞机时时飞行高度，速度等很多数据都会通过它来传输。以方便我们时时监控飞机情况，根据需要随时修改飞机航向。
整套无人机飞控工作原理就是地面站开机，规划航线，给飞控开机，上传航线至飞控，再设置自动起飞及降落参数，如起飞时离地速度，抬头角度（起飞攻角，也称迎角），爬升高度，结束高度，盘旋半径或直径，清空空速计等，然后检查飞控中的错误、报警，一切正常，开始起飞，盘旋几周后在开始飞向任务点，执行任务，最后在降落，一般郊外建议伞降或手动滑降，根据场地选择。飞机在飞行过程中如果偏离航线，飞控就会一直纠正这个错误，一直修正，直到复位为止。
无人机飞控系统的主要功能
飞行状态
飞控系统主要用于飞行姿态控制和导航，对于飞控而言，首先要知道飞行器当前的状态，比如：三维位置、三维速度、三维加速度、三轴角度和三轴角速度等，总共15个状态。由于多旋翼飞行器本身是一种不稳定系统，要对各个电机的动力进行超高频率地不断调整和动力分配，才能实现稳定悬停和飞行，所以，对于航拍无人机来说，即使最简单的放开摇杆飞行器自主悬停的动作，也需要飞控持续监控这15个量，并进行一系列“串级控制”，才能做到稳定悬停，这一点肉眼看起来很简单，但飞控系统里面的运算其实是非常复杂的。
飞控系统最基础也最难控制的技术难点，其实是要准确地感知这一系列状态，如果这些感知数据问题或者有误差都会导致无人机做一些非正常的动作。目前，无人机一般使用GPS、IMU（惯性测量单元）、气压计和地磁指南针来测量这些状态。GPS获取定位、在一些情况下也能获取高度、速度；IMU主要用来测量无人机三轴加速度和三轴角速度，通过计算也能获得速度和位置；气压计用于测量海拔高度；地磁指南针则用于测量航向。
由于目前传感器设计水平的限制，这些传感器测量的数据都会产生一定的误差，并可能受到环境的干扰，从而影响状态估计的精度。为了保障飞行性能，就需要充分利用各传感器数据共同 融合出具有高可信度的15个状态，即组合导航技术。组合导航技术结合GPS、IMU、气压计和地磁指南针各自的优缺点，通过电子信号处理领域的技术，融合多种传感器的测量值，获得更精准的状态测量。
组合导航
为了提升航拍无人机的感知能力和飞行性能，除了以上基础传感器方案以外，现在主流的无人机产品都加入了先进的视觉传感器、超声波传感器和IMU与指南针冗余导航系统。双目立体视觉系统可根据连续图像计算出物体的三维位置，除了避障功能以外还能提供定位与测速。机身下方的超声波模块起到辅助定高的作用，而冗余的IMU和指南针在一个元件受到干扰时，冗余导航系统会自动切换至另一个传感器，极大提高了组合导航的可靠性。
正是因为这些传感器技术的完美融合，无人机有了智能导航系统，拓展了活动环境，并提升了可靠性。使用传统导航系统的无人机在室内等无GPS的环境中无法稳定飞行，而智能导航系统在GPS信号良好时，可通过视觉提升速度和位置测量值的精度；在GPS信号不足的时候，视觉系统可以接替GPS提供定位与测速，让无人机在室内与室外环境中均能稳定飞行。
智能导航系统引入了多个传感器，数据量和复杂程度大幅提升，获悉大疆其实针对视觉和传感器对导航和飞行控制算法进行多次系统重构，增加新的软件模块与架构，全面提升了飞行的性能与可靠性。
控制性能
飞控系统先进的控制算法为航拍无人机的飞行和操控带来了很高的控制品质，比如在普通状态下的表现是控制精度高，飞行稳定，速度快。高速飞行不仅对动力系统有较高的要求，更重要的是飞控要达到很高的控制品质和响应速度，除高速飞行以外，飞行器在悬停和慢速控制上也能达到很高的精度。
另外，在设计飞控时，不仅需要考虑到正常飞行状态的控制精度，如悬停位置控制精度，姿态控制精度等，还需要加强了异常飞况的控制品质。如在飞行器断桨、突然受到撞击、突加负重或被其他外力干扰后，控制恢复能力更强，鲁棒性较强，能够应对很多极端状况，这对于飞行安全性来说尤其重要。
故障诊断
在起飞前或飞行过程中，任何微小故障都有可能引发飞行事故。如果飞控系统能实时不断地进行故障监控与故障诊断，就能大幅降低事故发生的概率。飞控系统可以监控诸如振动、电压、电流、温度、转速等各项飞行状态参数，并通过这些监控特征信号进行故障诊断。但是这些信号往往是复杂且没有明显规律的，只有通过对大量故障数据进行数据挖掘，用深度学习技术建立了飞控故障诊断系统，采用模式识别判定故障发生的概率，这套系统才能判定从空中射桨到IMU故障诊断等，对故障进行早期预报，或进行应急处理，使飞行变得更加安全。
只有最快速监测并判定故障，同时在刹那之间飞控系统采用正确信息进行飞行操控，飞行器其实是在自己“分析并拿主意”。到这时，从某种意义上说，那就是真正的“智能机器人”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6022cd30fc067efb7207bcd8146a3cf/" rel="bookmark">
			四旋翼无人机飞行器基本知识（四旋翼无人机结构和原理&#43;四轴飞行diy全套入门教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一篇《四旋翼飞行器结构和原理》
第二篇《四旋翼飞行diy全套入门教程》 四旋翼飞行器结构和原理
1.结构形式
旋翼对称分布在机体的前后、左右四个方向，四个旋翼处于同一高度平面，且四个旋翼的结构和半径都相同，四个电机对称的安装在飞行器的支架端，支架中间空间安放飞行控制计算机和外部设备。结构形式如图 1.1所示。
.工作原理
四旋翼飞行器通过调节四个电机转速来改变旋翼转速，实现升力的变化，从而控制飞行器的姿态和位置。四旋翼飞行器是一种六自由度的垂直升降机，但只有四个输入力，同时却有六个状态输出，所以它又是一种欠驱动系统。 四旋翼飞行器的电机 1和电机 3逆时针旋转的同时，电机 2和电机 4顺时针旋转，因此当飞行器平衡飞行时，陀螺效应和空气动力扭矩效应均被抵消。
在上图中，电机 1和电机 3作逆时针旋转，电机 2和电机 4作顺时针旋转，规定沿 x轴正方向运动称为向前运动，箭头在旋翼的运动平面上方表示此电机转速提高，在下方表示此电机转速下降。 （1）垂直运动：同时增加四个电机的输出功率，旋翼转速增加使得总的拉力增大，当总拉力足以克 服整机的重量时，四旋翼飞行器便离地垂直上升；反之，同时减小四个电机的输出功率，四旋 翼飞行器则垂直下降，直至平衡落地，实现了沿 z轴的垂直运动。当外界扰动量为零时，在旋翼 产生的升力等于飞行器的自重时，飞行器便保持悬停状态。 （2）俯仰运动：在图（b）中，电机 1的转速上升，电机 3 的转速下降（改变量大小应相等），电机 2、电机 4 的转速保持不变。由于旋翼1 的升力上升，旋翼 3 的升力下降，产生的不平衡力矩使 机身绕 y轴旋转，同理，当电机 1 的转速下降，电机 3的转速上升，机身便绕y轴向另一个 方向旋转，实现飞行器的俯仰运动。 （3）滚转运动：与图 b 的原理相同，在图 c 中，改变电机 2和电机 4的转速，保持电机1和电机 3 的 转速不变，则可使机身绕 x 轴旋转（正向和反向），实现飞行器的滚转运动。 （4）偏航运动：旋翼转动过程中由于空气阻力作用会形成与转动方向相反的反扭矩，为了克服反扭 矩影响，可使四个旋翼中的两个正转，两个反转，且对角线上的各个旋翼转动方向相同。反扭 矩的大小与旋翼转速有关，当四个电机转速相同时，四个旋翼产生的反扭矩相互平衡，四旋翼 飞行器不发生转动；当四个电机转速不完全相同时，不平衡的反扭矩会引起四旋翼飞行器转 动。在图 d中，当电机 1和电机 3 的转速上升，电机 2 和电机 4 的转速下降时，旋翼 1和旋翼3 对机身的反扭矩大于旋翼2和旋翼4对机身的反扭矩，机身便在富余反扭矩的作用下绕 z轴转动， 实现飞行器的偏航运动，转向与电机 1、电机3的转向相反。 （5）前后运动：要想实现飞行器在水平面内前后、左右的运动，必须在水平面内对飞行器施加一定 的力。在图 e中，增加电机 3转速，使拉力增大，相应减小电机 1转速，使拉力减小，同时保持 其它两个电机转速不变，反扭矩仍然要保持平衡。按图 b的理论，飞行器首先发生一定程度的倾 斜，从而使旋翼拉力产生水平分量，因此可以实现飞行器的前飞运动。向后飞行与向前飞行正 好相反。（在图 b 图 c中，飞行器在产生俯仰、翻滚运动的同时也会产生沿 x、y轴的水平运 动。） （6）倾向运动：在图 f 中，由于结构对称，所以倾向飞行的工作原理与前后运动完全一样。 转自：http://zhan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6022cd30fc067efb7207bcd8146a3cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e3c7d9fe264b77d2b4bc53f2e72ae6c/" rel="bookmark">
			【MPLAB X IPE】：XIPE烧写教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 MPLAB X IPE版本：v5.10
步骤 1、打开MPLAB X IPE，首先选择Family，然后选择Device。单片机型号选择好后，点击Apply按钮确定。IPE通常可以自动枚举下载工具，例如PICkit3 S.No:BUR124203688。
2、点选菜单Settings\Advanced Mode，弹出Advanced Mode对话框。
3、在密码框中输入密码，点击Log in。IPE界面变为下图所示。
4、点击Option\Power，界面弹出Power Settings页面。在ICSP Options选项框中勾选Power Target circuit from Tool（翻译为：通过工具给目标电路供电）。
5、 切换主页面为Operate，点击Connect按钮。
6、点击Connect按钮，连接成功后，按钮名变为Disconnect。
输出日志如下
***************************************************** 连接到MPLAB PICkit 3... Currently loaded firmware on PICkit 3 固件套件版本.....01.54.00 固件类型..............dsPIC33F/24F/24H Programmer to target power is enabled - VDD = 3.250000 volts. Target device PIC24FJ32GA002 found. 器件ID版本 = 3046 7、 点击Browse按钮。
在弹出对话框中，选择需要下载的HEX文件。
8、点击Program按钮。
烧写成功，日志输出如下。 正在加载代码E:\XXX.X.production.hex... 2019-06-19 15:25:35 +0800 - Hex file loaded successfully. 2019-06-19 15:26:57 +0800 - Programming.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e3c7d9fe264b77d2b4bc53f2e72ae6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80fb3480e96358fe42c87caa8046a2a7/" rel="bookmark">
			在函数&#39;_start&#39;中:(.text&#43;0x20):对&#39;main&#39;未定义的引用collect2 :error: ld returned 1 exit status  解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误信息：
在函数'_start'中:(.text+0x20):对'main'未定义的引用collect2 :error: ld returned 1 exit status
问题：
在文章《linux下编译c文件成为可执行文件的实例和详细过程》中说到，gcc编译分四步，预编译、编译、汇编、链接，但是在链接时，始终不成功
使用的命令：
预编译：gcc -E hello.c -o hello.i
编译：gcc -S hello.i -o hello.s
汇编：gcc -C hello.s -o hello.o
链接：gcc hello.o -o hello
在执行链接命令gcc hello.o -o hello时，总是提示错误，错误信息提示如下：
而使用命令gcc hello.c -o hello直接生成可执行文件，则没有任何问题。
解决：
经过分析发现，汇编时使用的命令错误，应该是gcc -c hello.s -o hello.o，而非gcc -C hello.s -o hello.o，故做此记录，希望帮到有类似问题的朋友。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcbbdedb22b704637b8791d2659c3ce9/" rel="bookmark">
			配置wireshark解析MMS协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工控中的IEC61850的MMS协议有时可以解析，有时无法解析，以下方法可以有效根治
1 wireshark
wireshark很简单， 选择 Edit-&gt;preferences-&gt;protocol-&gt;PRES ，然后编辑 users context tale，添加一项：context = 3 and OID = 1.0.9506.2.3，
然后重启 作者：绿子i
来源：CSDN
原文：https://blog.csdn.net/qq_27396789/article/details/77367603
版权声明：本文为博主原创文章，转载请附上博文链接！
https://blog.csdn.net/qq_27396789/article/details/77367603
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b38e9cd1b72adf6a07b282af16876e0/" rel="bookmark">
			Spring Boot Devtools 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：https://howtodoinjava.com/spring-boot2/developer-tools-module-tutorial/
如果您已经处理过最新的UI开发框架，例如节点，角度，gulp等然后你必须已经意识到只要某些代码发生变化，就可以在浏览器中自动重新加载UI。它非常实用，可以节省大量时间。
好吧，使用spring-boot-devtools依赖提供的功能，可以在spring启动应用程序中使用相同的功能。让我们了解如何启用这些功能并使用它们。
Enabling Dev Tools Module 在Spring引导应用程序中启用开发工具非常容易。只需在构建文件中添加spring-boot-devtools依赖项即可。
maven &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; gradle dependencies { compile("org.springframework.boot:spring-boot-devtools") } Static Resource Caching 为了提高性能，开发工具缓存静态内容/模板文件，以便更快地为浏览器/客户端提供服务。这是生产中非常好的特性，每毫秒的性能改进都很重要。但是在开发环境中，它可能是一个问题并导致过时的缓存问题，您可能无法立即在浏览器中看到您的更改。开发工具模块通过设置少量属性来提供此功能。
默认情况下，此功能已禁用。您可以通过设置属性使其在生产环境中使用。
有许多此类UI模板库支持此功能。e.g. thymeleaf, freemarker, groovy, mustache etc.
application.properties
#spring.freemarker.cache = true //set true in production environment spring.freemarker.cache = false //set false in development environment; It is false by default. //Other such properties spring.thymeleaf.cache = false spring.mustache.cache = false spring.groovy.template.cache = false Auto-refresh vs Auto-restart
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b38e9cd1b72adf6a07b282af16876e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/811a1fea0a9db97446bd5a0d9424f09e/" rel="bookmark">
			linux下编译c文件成为可执行文件的实例和详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、目录
一、准备C文件
二、编译
三、执行
四、编译的四个步骤
一、准备C文件
在命令行模式下输入:vim hello.c
进入编辑模式，输入以下代码：
#include&lt;stdio.h&gt; int main(void){ printf("Hello World!\n"); return 0; } 首先点击ESC键退出编辑模式，然后输入:wq(注意输入的时候有冒号哦)回到命令行。
二、编译
编译C文件成可执行文件
执行的命令：gcc hello.c -o hello
输入ls命令，能看到当前文件夹下多了一个文件：hello
三、执行
执行：./hello
可得输出hello World！
四、编译的四个步骤
使用gcc把C文件编译成可执行文件可分为四步：预编译、编译、汇编、连接。
1、预编译（生成.i文件）
预编译器cpp把源文件和相关的头文件（如实例代码中的头文件stdio.h）预编译成一个.i的文件。
执行的命令：gcc -E hello.c -o hello.i
预编译的作用：
a、处理所有的“#include”预编译指令
b、处理所有的"#define"指令，将代码中所有的"#define"删除，并展开所有的宏定义
c、处理所有的条件预编译指令，如#if #elif #else #ifdef #ifnodef #endif等
d、删除所有的注释
e、添加行号和文件名标识，以便产生错误时给出提示信息
2、编译（生成.s文件）
编译器gcc把预处理后的文件进行语法分析、语义分析以及优化后生成汇编代码文件。
执行的命令：gcc -S hello.i -o hello.s
3、汇编(生成.o文件)
汇编器把汇编代码文件转换成中间目标文件
执行的命令：gcc -c hello.s -o hello.o (注意：这里是小写的-c，而不是大写的-C，本人在此处踩坑，出现异常)
4、链接(生成可执行文件)
链接器ld把目标文件与所需要的所有的附加的目标文件(如静态链接库、动态链接库)链接起来成为可执行的文件
执行的命令：gcc hello.o -o hello
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1903511e13e1ea57500dbffbb7cd94fc/" rel="bookmark">
			python3 遍历 所有句柄及窗口名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 # -*- coding: utf-8 -*- """ Created on Mon Jun 17 22:55:29 2019 @author: Administrator """ import win32gui hwnd_title = dict() def get_all_hwnd(hwnd,mouse): if win32gui.IsWindow(hwnd) and win32gui.IsWindowEnabled(hwnd) and win32gui.IsWindowVisible(hwnd): hwnd_title.update({hwnd:win32gui.GetWindowText(hwnd)}) win32gui.EnumWindows(get_all_hwnd, 0) for h,t in hwnd_title.items(): if t is not "": print(h, t) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e440b35465849a3413315d6f8d7125/" rel="bookmark">
			哥德巴赫猜想 ——— 极限算法（你要是能写出比我用时还短的代码算我输）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哥德巴赫猜想
哥德巴赫猜想概述：
任何一个≥6之偶数，都可以表示成两个奇质数之和
那么，接下来，我们就来研究研究哥德巴赫猜想的验证及优化方案:
第一步，先建立头文件 “mec.h”（建立头文件的目的：简化程序，使程序更加直观，编写更加方便，在查找错误以及修改程序时，更加方便）：
#ifndef _MEC_H_ #define _MEC_H_ typedef unsigned char boolean; #define TRUE	1 #define FALSE	0 #define SET(v, i) (v |= (1 &lt;&lt; ((i) ^ 7))) #define CLR(v, i) (v &amp;= ~(1 &lt;&lt; ((i) ^ 7))) #define GET（v, i）((v) &amp; (1 &lt;&lt; ((i) ^ 7))) #endif 这里解释一下这个头文件的内容：用C语言编译器来实现java中数据类型boolean，这种类型的函数主要是用来辨别的，即：判断是否满足一些要求，满足，则返回值为TRUE，不满足，则返回值为FALSE。
第二步，开始编写主函数（伪代码版本）： #include &lt;stdio.h&gt; //因为头文件&lt;stdio.h&gt;中所涉及函数太广泛，所以可以上手就将其写上 int main() { int maxNum; int i; printf("请输入一个范围："); scanf("%d", &amp;maxNum); for(i=6; i&lt;maxNum; i+=2) { if(不满足歌德巴赫猜想) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e440b35465849a3413315d6f8d7125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6bc9c0a08573ee0341fcc8c31c37e62/" rel="bookmark">
			ONVIF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ONVIF相关学习 声明 什么是ONVIFONVIF规范的作用和优势规范的作用规范的优势 ONVIF规范的实现机制Web ServicesWSDLSOAP ONVIF规范的内容ONVIF规范的应用对本小节中用到的一些名词进行统一的说明传统视频监控系统的一个局域网应用场景应用ONVIF规范后的场景ONVIF规范的应用带来了什么变化 生成ONVIF源码框架从wsdl生成c头文件从头文件生成源码框架 ONVIF开发常用调试方法打开ONVIF调试开关,以便让ONVIF打印一些可用的调试信息一些常见的错误解决方法 一些参考文档==ONVIF Profile S Specification====Reference_of_ONVIF_Development_v1.01.02====ONVIF-Media-Service-Spec-v220====http://www.onvif.org/onvif/ver20/util/operationIndex.html== 致谢 声明 该篇文章主要是参考了网络上的资料整合起来的,给自己做一个备份
什么是ONVIF 2005年由AXIS、BOSCH、SONY三个公司联手推出的一个[国际开放型网络视频产品标准网络接口开发论坛]
Open Network Video Interface Forum 开放型网络接口论坛.
ONVIF 标准将为网络视频设备之间的信息交换定义通用协议,即ONVIF规范包括装置搜寻、实时视频、音频、元数据和控制信息等！
ONVIF规范的作用和优势 规范的作用 (1) ONVIF规范描述了网络视频的模型、接口、数据类型以及数据交互的模式.
(2) ONVIF规范的目标是实现一个网络视频框架协议,使得不同厂商所生产的网络视频产品(包括摄录前端,录像设备等)完全互通.
(3) ONVIF规范中设备管理和控制部分所定义的接口均以Web Services 的形式提供.
(4) ONVIF规范涵盖了完全的XML和WSDL的定义.
(5) 服务端和客户端的数据交互采用SOAP协议
(6)ONVIF中的其他部分,比如音视频流,则通过RTP/RTSP进行
规范的优势 (1)协同性: 不同厂商所提供的产品,均可以通过一个统一的"语言"来进行交流,方便了系统的集成
(2) 灵活性: 终端用户和集成用户不需要被某些设备的固有解决方案所束缚,大大降低了开发成本
(3) 质量保证: 不断扩展的规范将由市场来导向,遵循规范的同时也满足主流的用户需求.
(4) 由于采用WSDL+XML模式,使得ONVIF规范的后续扩展不会遇到太多的麻烦.
(5) XML极强的扩展性和SOAP协议开发的便捷性将吸引更多的人来关注和使用ONVIF规范
ONVIF规范的实现机制 客户端根据WSDL描述文档,会生成一个SOAP请求消息,该请求会被嵌入在一个HTTP POST请求中,发送到Web Services所在的Web服务器.------&gt;Web Services 请求处理器解析收到的SOAP请求,调用相应的Web Services.然后再生成相应的SOAP应答------&gt;Web服务器 得到SOAP应答后,会再通过HTTP应答的方式把信息送回到客户端
Web Services 详细介绍了web serveces和soap等 https://www.cnblogs.com/fnng/p/5524801.html
(1) Web Services 是基于网络的、分布式的模块化组件,执行特定的任务.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6bc9c0a08573ee0341fcc8c31c37e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5c2b715bc6c57ea068be234689797a2/" rel="bookmark">
			ERROR：随机数产生函数总是产生相同随机数的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 程序：
int main() { for(int i=0;i&lt;20;i++) {	srand(time(0)); cout&lt;&lt;rand()&lt;&lt;endl; } return 1; } 结果生成的20个随机数都是一样的…
原因：srand调用了次数太多，而且系统时间没有变化，所以长生的随机数相同
解决方法： 把srand(time(0));放在所有for循环的外面！
int main() { srand(time(0)); for(int i=0;i&lt;20;i++) {	cout&lt;&lt;rand()&lt;&lt;endl; } return 1; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be87f316375fc0d0685e667514ed30b/" rel="bookmark">
			Vim编辑器的基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vi编辑器是Unix系统最初的编辑器。它使用控制台图形模式来模拟文本编辑窗口，允许查看文件中的行、在文件中移动、插入、编辑和替换文本。尽管它可能是世界上最复杂的编辑器（至少讨厌它的人是这么认为的），但其拥有的大量特性使其成为Unix系统管理员多年来的支柱性工具。在GNU项目将vi编辑器移植到开源世界时，他们决定对其作一些改进。由于它不再是以前Unix中的那个原始的vi编辑器了，开发人员也就将他重命名为vi improved, 或vim。
1、vim基本使用
在终端键入vim命令和要编辑的文件的名字就可以启动vim编辑器（如在启动vim时未指定文件名，或是这个文件不存在，vim会开辟一段新的缓冲区域来编辑）。
vim编辑器有两种操作模式：
普通模式插入模式 刚启动vim编辑器，默认进入普通模式，在这个模式下，vim编辑器会将按键解释成命令（这也是vim特殊的地方，很多没有使用过vim的人刚开始打开vim时会被这个模式吓倒，毕竟在键盘上按键但一点反应都没有的编辑器实在是少见）。
在普通模式下键入i可进入插入模式（insert。事实上，键入a或者s也可进入插入模式），在插入模式下，vim会将你在光标位置输入的每个键都插入到缓冲区（也就是直接输入到文本中，并在屏幕上打印出来）。要退出插入模式返回普通模式话，就要键入退出键（ESC键，也就是Escape键）。
在普通模式下，若是vim能正确识别你的终端类型（正常情况下应该都可以的），就可以直接使用方向键在文本区域移动光标。
vim也有独有的用来移动光标的命令。
h：左移一个字符j ：下移一个字符k：上移一个字符l ：右移一个字符Ctrl+F（PageDown）：下翻一屏Ctrl+B（PageUp）：上翻一屏G：移到缓冲区最后一行num G：移到缓冲区第num行gg：移到缓冲区第一行 vim编辑器在普通模式下可按冒号键：进入命令行模式，可以输入额外的命令来控制vim的行为。
q：如果未修改缓冲区数据，退出q！：取消所有对缓冲区数据的修改并退出w filename：将文件保存到另一个文件中wq：将缓冲区数据保存到文件中并退出 2、在普通模式下编辑数据
x：删除当前光标所在位置的字符dd：删除当前光标所在行dw：删除当前光标所在位置的单词d$：删除当前光标所在位置至行尾的内容J：删除当前光标所在行行尾的换行符（拼接行）u：撤销前一编辑命令a：在当前光标后追加数据A：在当前光标所在行行尾追加数据r char：用char替换当前光标所在位置的单个字符R text：用text覆盖当前光标所在位置的数据，直到按下ESC键 有些编辑命令允许使用数字修饰符来指定重复该命令多少次，如：命令2x会删除从光标当前位置开始的两个字符，命令5dd会删除从光标当前所在行开始的5行。
另外，vim编辑器在普通模式下通常会把删除键（Delete键）识别成x命令的功能，通常不识别退格键（Backspace键）。
3、复制和粘贴
vim编辑器在删除数据时，实际上会将数据保存在单独的一个寄存器中，可以用p命令取回。例如，可以用dd命令删除一行文本，然后把光标移动到缓冲区的某个要放置该文本的地方，然后用p命令，该命令会将文本插入到当前光标所在行之后。
vim编辑器中复制命令是y（代表yank），可以在y命令后面使用和d命令相同的第二字符（如：yw代表复制一个单词，y$代表复制到行尾）。在复制文本后，把光标移动到想放置文本的地方，键入p命令，复制的文本就会出现在该位置。
复制命令一般在可视模式下使用。可视模式会在移动光标的同时高亮显示文本，键入v键可进入可视模式，如下图所示。
可先在可视模式下覆盖要复制的文本，然后键入y命令来激活复制命令，之后移动光标到要放置文本的位置，使用p命令将寄存器中的文本粘贴下来。
4、查找和替换
vim编辑器在普通模式下，可使用/（斜线键）来查找文本。按下/后，光标会跑到消息行，然后vim会显示出斜线。输入要查找的文本，按下回车键便可完成查找。vim编辑器会采用以下三种回应中的一种：
如果要查找的文本出现在光标位置之后，则光标会跳到该文本出现的第一个位置。如果要查找的文本未在光标当前位置之后出现，则光标会绕过文件末尾，出现在该文本所在的第一个位置（并用一条消息指明）。输出一条错误消息，说明在文件中没有找到要查找的文本。 要继续查找同一个文本，可键入/（斜线键），然后键入回车键。或者键入n命令，表示下一个（next）。
vim编辑器在命令行模式下可使用替换命令。替换命令的格式是：:s/old/new/。vim编辑器会跳到old第一次出现的地方，并用new来替换。还可用以下命令来替换多处文本：
:s/old/new/g ：替换一行中的所有old:n,ms:/old/new/g ：替换行号n和m之间的所有old:%s/old/new/g ：替换整个文件中的所有old:%s/old/new/gc ：替换整个文件中的所有old，但在每次出现时提示，询问是否要替换 以上便是博主对vim编辑器一些基本用法的总结，熟悉以上vim的基本操作之后，便可使用vim高效地完成日常文本文件的编辑。
Ramscy
2019.6.16 15:03
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de8accc49c1006dd1a253675979662d/" rel="bookmark">
			zookeeper3.5.5启动报错java.io.IOException: No snapshot found, but there are log entries. Something i问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、由于之前3.5.5版本一直启动报错，解决之前先用了老版本的zk2.4.8,并修改zk2.4.8的dataDir=/usr/lib/zookeeper/zkdata,
用了一阵子，后来3.5.5搞定后，启动居然报这个错，后来经百度查询，这个错是在启动zk是恢复数据报错的，因为之前的data全是我3.4.8版本的数据，现在启动3.5.5恢复这个数据就报错了（ps:我zk3.5.5和zk3.4.8的配置文件zoo.cfg的dirData都写的同一个目录，所以报错的），解决办法是把我zk3.5.5的dataDir=换一个目录就行了
2、参考：https://blog.csdn.net/jpf254/article/details/80769525
总结：为了用上zk3.5.5真是费老鼻子劲了，小白的我为了用上最新的zk3.5.5写了三篇博客，有其他问题参考我写的其他的文章，有用请点赞、评论、转发（请标注出处），谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1caa0ea23ca02451d08ec5023fbcd748/" rel="bookmark">
			SVN本地服务器搭建（Windows10）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装
下载地址
下载地址：https://www.visualsvn.com/server/download/下载地址
进入主页面进行下载，注意选择正确的版本
3.下载好之后点击安装
4.至此安装完成，点击运行程序，主界面如下
二、配置
点击Finish之后，一个库已经创建完毕
三、创建用户
四、给用户名分配权限
复制地址后可以在浏览器中输入，并用刚才创建的用户名及密码登陆了，登录后的界面如下图：
SVN服务器及用户名等都已经准备完成，接下来就可以从SVN客户端进行登录下拉及上传代码到库里面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874b0174f605ad561653027fed915d93/" rel="bookmark">
			zookeeper启动端口占用，org.apache.zookeeper.server.admin.AdminServer$AdminServerException: Problem starting
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、zk admin启动默认端口是8080，但是我有其他服务是8080在用，启动时就报错了，端口已被绑定
2019-06-16 10:40:29,724 [myid:] - ERROR [main:ZooKeeperServerMain@79] - Unable to start AdminServer, exiting abnormally org.apache.zookeeper.server.admin.AdminServer$AdminServerException: Problem starting AdminServer on address 0.0.0.0, port 8080 and command URL /commands at org.apache.zookeeper.server.admin.JettyAdminServer.start(JettyAdminServer.java:107) at org.apache.zookeeper.server.ZooKeeperServerMain.runFromConfig(ZooKeeperServerMain.java:138) at org.apache.zookeeper.server.ZooKeeperServerMain.initializeAndRun(ZooKeeperServerMain.java:106) at org.apache.zookeeper.server.ZooKeeperServerMain.main(ZooKeeperServerMain.java:64) at org.apache.zookeeper.server.quorum.QuorumPeerMain.initializeAndRun(QuorumPeerMain.java:128) at org.apache.zookeeper.server.quorum.QuorumPeerMain.main(QuorumPeerMain.java:82) Caused by: java.io.IOException: Failed to bind to /0.0.0.0:8080 at org.eclipse.jetty.server.ServerConnector.openAcceptChannel(ServerConnector.java:346) at org.eclipse.jetty.server.ServerConnector.open(ServerConnector.java:308) at org.eclipse.jetty.server.AbstractNetworkConnector.doStart(AbstractNetworkConnector.java:80) at org.eclipse.jetty.server.ServerConnector.doStart(ServerConnector.java:236) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68) at org.eclipse.jetty.server.Server.doStart(Server.java:396) at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68) at org.apache.zookeeper.server.admin.JettyAdminServer.start(JettyAdminServer.java:103) ... 5 more Caused by: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/874b0174f605ad561653027fed915d93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e152746cde693e793b1caa0280d83a/" rel="bookmark">
			zookeeper3.5.5启动报错Error contacting service. It is probably not running 问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天公司内部要搭建dubbo，当然首先第一步就是搭建zk，找到zookeeper官网，看最新稳定版本是3.5.5，以我的性格必须要用最新稳定版啊，于是乎下载最新版的3.5.5，今天是2019年6月16日周日，北京小雨凉飕飕，看官网最新更新日期是19年5月20日【20 May, 2019: release 3.5.5 available - 来自官网】截图如下，点击红框的Download下载3.5.5按网上各种航大神的教程把conf目录下的zoo_sample.cfg改为zoo.cfg 3、zoo.cfg的路径如上，内容如下，当然dataDir对应的目录你自己要在适当地方新建一个
4、启动zk3.5.5，好像是起来了，嗯，看样子是的
5、But、用status查看结果是酱紫的
6、那，OK，去看下zk日志，日志好像也说的很明白，找不到那个类org.apache.zookeeper.server.quorum.QuorumPeerMain
7、【划重点】，看下zk3.5.5的目录发现，看，这是给了源码嘛，没有class
8、【解决办法】，看截图就应该明白了，如果不明白我解释下，就是到zookeeper-server目录打下包，package下就行了，如果报了mvn错，那么maven安装配置不在本次讨论范围内，另行百度
9、【最终结果】：不出意外是下面这样，看到这个有没有很爽的感觉,target里就有jar了
10、【zk3.5.5启动演示，凑够十条，十全十美嘛】
总结：问题发生时找了网上各种解决办法都就有解决（ps:可能我没有找到吧），以上做个分享，如果对您有帮助，请点赞，转发，评论，转载请说明出处，谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d3b5fc42c02bf427a11aca1d82aa369/" rel="bookmark">
			实现三个线程轮流执行顺序打印ABC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这道题目在多线程的面试题中可能遇到的比较多，由于最近一直在学习Java多线程编程的知识，这里做一个总结，总结的可能并不是很全面，有问题或者有更好的编程方法也欢迎大家指出。
这道题目的实现方式很多，这里就以我了解的进行一个总结。
首先，我们看一下题目：
有三个线程A、B、C，采用多线程的方式使三个线程轮流执行顺序打印ABC 10次，结果如下：
通过wait/notify实现 package test.printThread.test2; /** * * &lt;p&gt;Title: PrintABCUsingWaitNotify.java&lt;/p&gt; * &lt;p&gt;Description: * ABCABCABCABCABCABCABCABCABCABC * &lt;p&gt; * @author tianqb * @mail tqb820965236@163.com * @date 2019年6月7日下午5:29:39 * @version 1.0 * */ public class PrintABCUsingWaitNotify { private int times;// 打印的次数 private int state = 0;// 打印的状态 private Object objectA = new Object(); private Object objectB = new Object(); private Object objectC = new Object(); public PrintABCUsingWaitNotify(int times) { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d3b5fc42c02bf427a11aca1d82aa369/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/296c52f2e62bb1365bddfa0f25265ac6/" rel="bookmark">
			bat循环运行jar包，不同端口，模拟分布式场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 要在本机测试分布式场景下的SpringBoot程序，运行一个bat,启动多个程序，模拟多服务器的通讯用。
很实用！
循环运行jar包，不同端口，模拟分布式场景
@echo off for /L %%i in (0,1,4) do start cmd /c "title 900%%i &amp;&amp; java -Dserver.port=900%%i -jar SpringBoot-WebSocket-v1.jar" pause 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecffece63864902a21e9da1ee98e9b20/" rel="bookmark">
			pcb电路板绘制教程之电路板（1）——开发环境讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习内容：
熟悉软件开发环境集成元件库的使用和设计原理图设计pcb设计 对于基础入门来说，一开始只需要掌握基础技巧就能够快速的学会整个pcb的设计流程
当我们能够从头到尾，能够简单的设计pcb之后呢，我们就可以针对，每一部分细化深入，在不断的使用中进步提高
对于技术型的开发多动手实践是非常重要的，
接下来学习，
汉化AD15 AD15的集成开发环境主要有那几部分组成怎么打开关闭的工作区面板AD15设计pcb是主要用到，哪几种设计环境。怎样创建pcb工程，以及怎样在工程中创建，添加，删除原理图，及pcb文件怎样创建集成库工程，以及怎样在工程中创建，添加，删除，原理图原件库及pcb封装库 汉化AD15 点击系统菜单下的DXP --preserences(参数选择)——system——General——localization——使用本地资源——然后出现提示框，提示重启以后才会有效，点击OK,然后关闭软件，当再次打开的时候就会变成中文的
整个界面组成是这样的
最上面是系统菜单栏
下面是工具栏，右侧是导航栏，
我们可以看到导航栏中有一个人虚线的东西，长按可以拖动，移动位置，
工具栏和导航栏右上角，有一个可以关闭的标志，可以关闭，然后怎么再次打开呢
选择视窗，工具栏，然后点击，原来关闭掉的，窗口。
软件可根据我们打开的文件格式不同，显示不同的菜单功能
比如我们打开原理图
上面就多了许多，功能，如放置，设计，工具，等等
下面多出了几个我们开发过程中快捷开发的工具
同样的pcb环境下，同样会多出来许多的系统菜单栏和工具栏
我们回到软件的初始界面，这里有我们，左下侧常用的工作面板，
同样的右侧也有一些工作面板
我们可以直接把鼠标移动到右侧的隐藏面板，当我们隐藏的面板会弹出来，当然我们也可以点击它，当然，他不会立即隐藏，需要在点击他时才会隐藏，或者在工作区的空白位置点击一下，它才会隐藏。
我们锁定的面板中，有一个图钉一样的标志，点击它，离开，面板就可以隐藏
如果我们将面板关闭不知道在哪里打开，有一个人快速简便的方法，打开视图——桌面布局——defanglt,
这样整个的桌面布局，就会恢复到原来的状态了，
将文件面板关闭，怎么打开呢，打开查看按钮---工作区面板----system---文件
就可以了
还有就是右下角的面板控制中心，如system，直接点击是比较快捷的，
对于可以隐藏弹出的修速度可能会不合适，怎么修改呢，：
打开DXP———参数选选择（设置图标）——view 就可以修改延时了
在设计pcb时候哦首先要做的事情，就是创建一个pcb工程，用来管理我们即将创建和生成的相关设计文件
pcb工程的创建 通过系统菜单 Flie——New——Project——新建Pcb工程
怎么查看保存的路径
可以选择——DXP——参数选择（设置图标）——system——default locations
怎么移除工程
右键选择close project
2.通过工程面板
创建一个空的pcb工程
右下角隐藏的工程面板里面有，files——new(新的)——blank project (pcb)
这样的工程是没有保存的，想要保存的话，通过文件——保存，或者让另存为
或者在工程名字上面，右键——保存工程
3.直接在工程面板里直接
右击添加新的工程——pcb工程
怎样把已经有的工程打开 文件——打开——找到文件夹双击PCB工程
或者从文件夹中找到工程直接双击
下面在为大家讲解怎样在工程中创建，添加，删除原理图文件和pcb文件 1.在工程名字上右键—— 新建工程——原理图文件（我的软件面板里没有原理图这个选项）
第二种方法
直接文件——新建——原理图
2.添加一个pcb文件
右键给工程添加新的——pcb
3.保存
将添加的pcb保存，原理图保存，新的工程保存
4.移除原理图或者pcb，可以在上面右键——从工程中移除 因为是打开状态
然后就会出现一个自由文档，然后我们可以close pcb关闭他们
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecffece63864902a21e9da1ee98e9b20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3be8f852f2a249aa28dff91ba160424/" rel="bookmark">
			springboot schedule 解决定时任务不执行的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@schedule 注解 是springboot 常用的定时任务注解,使用起来简单方便,但是如果定时任务非常多,或者有的任务很耗时,会影响到其他定时任务的执行,因为schedule 默认是单线程的,一个任务在执行时,其他任务是不能执行的.解决办法是重新配置schedule,改为多线程执行.只需要增加下面的配置类就可以了.
import org.springframework.boot.autoconfigure.batch.BatchProperties; import org.springframework.context.annotation.Configuration; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.scheduling.annotation.SchedulingConfigurer; import org.springframework.scheduling.config.ScheduledTaskRegistrar; import java.lang.reflect.Method; import java.util.concurrent.Executors; @Configuration public class ScheduleConfig implements SchedulingConfigurer { @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) { Method[] methods = BatchProperties.Job.class.getMethods(); int defaultPoolSize = 3; int corePoolSize = 0; if (methods != null &amp;&amp; methods.length &gt; 0) { for (Method method : methods) { Scheduled annotation = method.getAnnotation(Scheduled.class); if (annotation != null) { corePoolSize++; } } if (defaultPoolSize &gt; corePoolSize) corePoolSize = defaultPoolSize; } taskRegistrar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3be8f852f2a249aa28dff91ba160424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32fc61c8a7bfccd7a12b8e3a10d02af8/" rel="bookmark">
			visual studio 2019 工具里添加开发中命令提示符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		→_→→_→觉得有帮助，点个赞吧
最新新装了visual studio 2019,发现默认的没有开发者命令提示符
现将添加步骤描述如下：
从VS2019菜单选择“Tools”，然后选择“外部工具”。输入如下：
标题：Visual Studio 命令提示(&amp;C)命令：%systemroot%\system32\cmd.exe参数：/K "vsdevcmd.bat -no_logo"初始目录：E:\Program Files (x86)\Microsoft Visual Studio\2019\Community\Common7\Tools 注意：初始化目录为你安装vs2019的目录中找
然后点击【应用】，【确认】即可
来张图吧：
→_→→_→觉得有帮助，点个赞吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa4435cab801f46bc963257382f0f0f0/" rel="bookmark">
			进程和程序概念的区别和联系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		进程概念和程序概念最大的不同之处在于：
1、进程是动态的，而程序是静态的。
2、进程有一定的生命期，而程序是指令的集合，本身无“运动”的含义。没有建立进程的程序不能作为1个独立单位得到操作系统的认可。
3、1个程序可以对应多个进程，但1个进程只能对应1个程序。进程和程序的关系犹如演出和剧本的关系。
4、进程和程序的组成不同。从静态角度看，进程由程序、数据和进程控制块（PCB）三部分组成。而程序是一组有序的指令集合。
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65abce2ef4441604d522d210531027a8/" rel="bookmark">
			混淆矩阵（confusion_matrix）的可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		混淆矩阵可视化 混淆矩阵的可视化可以让多分类问题变得更加明了，在使用了几个别人写的案例后都不太理想，于是通过官网上的例子进行了一下小小的修改，得到了自己满意的结果。
环境：jupyter Notebook
aa=[[5354,1,0,0,8,0,1,1,0,0], [4,59,0,0,0,0,0,0,0,0], [19,0,4,2,8,0,0,0,0,0], [1,0,1,39,1,0,0,0,0,0], [9,0,0,1,428,0,3,3,0,0], [4,0,0,0,0,27,0,0,1,0], [5,0,0,0,0,0,253,0,0,0], [2,0,0,0,9,0,0,551,1,0], [6,0,0,0,3,0,0,1,54,0], [15,0,0,1,0,0,0,0,0,0]] def plot_confusion_matrix(cm, classes, normalize=False, title=None, cmap=plt.cm.Blues): """ This function prints and plots the confusion matrix. Normalization can be applied by setting `normalize=True`. """ if not title: if normalize: title = 'Normalized confusion matrix' else: title = 'Confusion matrix, without normalization' # Compute confusion matrix # Only use the labels that appear in the data # classes = classes[unique_labels(y_true, y_pred)] if normalize: cm = cm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65abce2ef4441604d522d210531027a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22822a156f9ada974fee1138517826de/" rel="bookmark">
			找自幂数的逐步优化算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自幂数是指一个 n 位数，它的每个位上的数字的 n 次幂之和等于它本身。（例如：当n为3时，有1^3 + 5^3 + 3^3 = 153，153即是n为3时的一个自幂数） 自幂数包括：独身数、水仙花数、四叶玫瑰数、五角星数、六合数、北斗七星数、八仙数、九九重阳数、十全十美数 。
下面分析怎样找出自幂数的算法：
1：首先要能判断一个自幂数
(这里面可以分为几个函数
1.找出数字的位数
2.给一个算次方的函数)
2：给定范围，查找自幂数
说到这里有的小朋友可能特别疑惑了，为神魔要自造一个算次方的函数呢?
C语言的math.h库里面不是有pow（）函数直接调用吗？
请注意本文章的标题，我们要优化，优化，优化，我们要给一个更快的方法，嘿哈。
先给出我第一次写出来的代码
#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include "./include/mec.h" boolean isSelfPower(int num); int intLen(int num); int intPow(int a, int p); boolean isSelfPower(int num) { int cnt; int sum; int n; cnt = intLen(num); sum = 0; for (n = num; n &amp;&amp; sum &lt;= num; n /= 10) { sum += intPow(n % 10 ,cnt); } return sum == num; } int main() { int num; int maxNum; long startTime; long endTime; long deltaTime; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22822a156f9ada974fee1138517826de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b559ec377dee159425ea68246d2a58cc/" rel="bookmark">
			Docker学习之搭建ActiveMQ消息服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。
在生产项目中，很多时候需要消息中间件来进行分布式系统间的通信。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能。
概念 JMS消息模式 点对点或队列模式
包含三个角色：消息队列（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。
每个消息只有一个消费者（Consumer），即一旦被消费，消息就不再在消息队列中发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列接收者在成功接收消息之后需向队列应答成功 Pub/Sub 发布/订阅模式
包含三个角色：主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。
每个消息可以有多个消费者发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。为了消费消息，订阅者必须保持运行的状态。 为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。
如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型。
JMS消息基本组件 ConnectionFactory
创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。
Destination
Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。
所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。
Connection
Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。
Session
Session是操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。
消息的生产者
消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。
消息消费者
消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。
MessageListener
消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。
Transport传输方式 ActiveMQ目前支持的Transport有：VM Transport、TCP Transport、NIO Transport、SSL Transport、Peer Transport、UDP Transport、Multicast Transport、HTTP and HTTPS Transport、WebSockets Transport、Failover Transport、Fanout Transport、Discovery Transport、ZeroConf Transport等。
VM Transport：允许客户端和Broker直接在VM内部通信，采用的连接不是Socket连接，而是直接的方法调用，从而避免了网络传输的开销。应用场景也仅限于Broker和客户端在同一JVM环境下。TCP Transport：客户端通过TCP Socket连接到远程Broker。配置语法：tcp://hostname:port?transportOptionsHTTP and HTTPS Transport：允许客户端使用REST或者Ajax的方式进行连接。这意味着可以直接使用Javascript向ActiveMQ发送消息。WebSockets Transport：允许客户端通过HTML5标准的WebSockets方式连接到Broker。Failover Transport：青龙系统MQ采用的就是这种连接方式。这种方式具备自动重新连接的机制，工作在其他Transport的上层，用于建立可靠的传输。允许配置任意多个的URI，该机制将会自动选择其中的一个URI来尝试连接。配置语法：failover:(tcp://localhost:61616,tcp://localhost:61617,.....)?transportOptionsFanout Transport：主要适用于生产消息发向多个代理。如果多个代理出现环路，可能造成消费者接收重复的消息。所以，使用该协议时，最好将消息发送给多个不相连接的代理。 Persistence持久化存储 AMQ Message Store
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b559ec377dee159425ea68246d2a58cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3486b4cb5b07d9e862118021c878545/" rel="bookmark">
			从简历被拒到收割今日头条offer，他花了一年时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备面试 其实从三月份投递简历开始准备面试到四月份收offer，也不过1个月的时间，但这都是建立在我过去一年的积累啊，无数次的通宵自习室，图书馆的专属椅子都被我坐的陷进去。避免误导大家，这次也不做标题党，写了准备一年，踏踏实实干事。
都是比较不错的书单
以下是我去年给自己订的学习计划：
一月：
大数据入门
整个一月份都在刷入门视频和《Hadoop权威指南》，又临近期末，每天5点半起床，看两个小时的视频然后上课或者复习期末考。
二月：
剑指offer刷一遍、数据结构、JavaSE、JVM、多线程剑指offer有些搞不懂的直接跳过，等下个月第二遍再刷；数据结构重点是各种树、二叉树、红黑树的一些特性以及链表的特性；JavaSE主要是类对象接口的区别，能不能继承，Static的特点，各种Hashmap，ArrayList等集合框架的原理源码；JVM是根据网上整合的高频面试题进行学习的，刷了一遍面试题之后才去看周志华的《深入理解Java虚拟机》，JVM难的不是JVM布局，垃圾回收算法等这些理论，而是结合代码和项目场景。比如说一段代码，有很多个类、方法，其中又有静态类和全局变量，这时候项目跑起来的时候哪些先加载，哪些变量存放在哪个区，不止要懂理论，还要结合代码懂理论。还有就是项目中的OOM，栈溢出，JVM的参数调优等等。多线程也是刷网上面试题和博客的，几本多线程的书都是一坨一坨的，理解不来。先动手把几个多线程实现方法实现了一遍，然后分析优缺点，再由此切进去线程不安全和各种锁。多线程学习不同JVM，自己多动手，多调试一下，控制台都会告诉你答案。 三月：
剑指offer二刷，数据库、操作系统、网络、准备面试
剑指offer第二遍重点刷第一遍时思路懂代码不懂的。数据库刷了牛客网SQL实战100多题的，其他都是索引原理，悲观乐观锁等理论。操作系统刷高频面试题。死锁的产生条件、解决方法等等，资源调度算法，并发和并行等。网络也是刷面试题。三次握手四次挥手以及为什么要这样做、TCP和UDP、网页请求过程、DNS解析过程、网络模型、响应码的意思等。我每刷一道算法或者理解了一道面试题都会进行整理，所以到面试之前看看整理的文档和博客就行，异常轻松。这个月也继续投递简历进行面试，从三月份开始都是边投边准备，不存在全部准备好再去投。 三月份收了京东、瓜子二手车等二线大厂的offer。
四月：
大数据项目、手写剑指offer、继续面试
三月份被阿里菜鸟部门的三面面试官怼了一发，说简历没有大数据项目面大数据岗，理论会再多有什么用，于是打算在四月份补一下项目。在补项目的同时，不忘算法，练习白板写代码。 四月份收了腾讯、去哪儿一些offer，腾讯和去哪儿终面都得现场面，所以一天飞北京，一天飞深圳。拿到腾讯offer的时候跟HR商量能不能去上海或者北京的base，HR说不行，于是就没去了。选工作和生活城市有一个硬性标准：离家远！那些在北方读书的同学毕业之后一直要往家里跑，而我则是一直往外跳，或许是因为在厦门待了四年吧，家乡也是「围城」啊。
5-12月：
实习，看框架源码，面试，整理面经
最后选择了去Kyligence实习了，刚好趁这个机会学习了Kylin源码，看了Hadoop和Spark的部分源码。后面的面试也是为了倒逼自己学习，在面试中找不足，也顺便整理了一些面试资料。
总结：
一定要列好自己的学习计划，也要学会根据自己的学习情况调整计划。项目是面试的敲门砖，也是面试的大头，我是从大二出去实习的，所以在项目这边可以花较少的时间，不用从零开始学。底层理论一定要会，不然大厂无望。算法一定要硬刚，总共就那几种题型，我刚开始也很抵触的，觉得太难了，后面迎难而上也就那么回事。第一遍不行就第二遍，不然就第三遍，直到现在剑指offer里面也有一些我不懂的题目，但我也不会去深究，大局为重，不抠细节。
别的同学放寒假的时候，自己一个人在学校旁边租了个小房子学到过年前夕；为了巩固实习的项目更好地面试，跑了几次之前实习的公司请同事吃饭问项目细节；为了阿里面试用肝硬刚，连夜复习；简历投的太多，信息都被卖了，而且一听到手机响就以为是面试电话；去腾讯终面，在深大的通宵自习室连夜复习。
以上是我过去一年的准备，说说我从投递简历到收offer这一个月的准备。
1.复习算法。把以前刷过的算法题分类整理了一下，因为之前有整理过，所以复习起来没用多少时间，还特意去理解了长长的KMP算法，LRU算法。
2.复习理论基础。除了复习整理的面经和资料之外，还特意去了解了一下Golang，因为头条用的go语言。
3.特意准备了几个项目技术难点，能在面试的时候炫一下。
二、头条一面（Java+项目） 倒排索引讲讲redis里面的哈希表？happen-before的规则？volatile修饰符，synchronize锁java单例模式的实现，懒汉、饿汉？进程与线程的区别，多进程和多线程的区别？HashMap原理，为什么用红黑树，红黑树的特点？快排时间空间复杂度，最好最坏的情况，优化方案？TCP的拥塞控制，具体过程是怎么样的？UDP有拥塞控制吗？如何解决？讲讲了解的垃圾回收算法和回收器，什么时候执行STOP THE WORLD？了解Go语言吗？ 三、头条二面（大数据+项目） Kylin的项目架构Paxos和ZAB协议CAP理论，分区容错性的意义大表Join小表优化，如何处理数据倾斜？讲一下最大堆和最小堆HDFS的读取、写入，容错处理。（源码）MapReduce的过程（第一版和第二版的）MR shuffle，Spark shuffle。namenode HA，脑裂，Yarn的调度机制。Hive的内部表和外部表区别、数仓建模模型、数仓分层、雪花模型和星型模型。了解ClickHouse吗？它与Kylin的区别？ 四、头条三面（算法+场景题） LRU算法实现（伪代码）链表倒数第K个数（讲思路）一堆螺丝和螺母用最短时间匹配（代码实现）求每天浏览页面的新用户（Hive QL实现）求抖音小视频每日点击量最高的10个（Hash + 最大堆） 五、如何通过头条笔试？ 这次的笔试里总共有5道，我AC了2.5题，第一题90%，第二题90%，第三题70%，不算好，但勉强通过了。去年的这个时候我可是连题目都看不懂的，看得懂的只知道用嘴怎么说，不会用代码实现。通过这段时间的算法训练，总结了如下几点算法笔试经验：
1.平时刷题一定要总结归纳，最好分类。比如关于树的题型，链表的，数组等等，观察它们的解题思路，总结出解题套路。
2.积累工具类算法。什么叫工具类算法？就是你解一道算法题需要用到另一种算法，这个被调用的算法就是解决这道算法题的工具。比如常见的「深度优先遍历」、「广度优先遍历」、「01背包」、「KMP算法」以及常见的选择和排序算法都是经常使用的工具类算法。
3.学会抽象题目。笔试算法题不同于面试算法，不会直白跟你说要使用哪种算法去解答，更多的要自己学会抽象，抛开题目本身，要明白内部讲的是什么，别被题目的糖衣炮弹迷惑了。只有把题目抽象成最原始的算法你才能更好地使用工具类算法进行解答。
六、如何准备头条面试？ 头条面试和其他大厂可能大同小异，但就是这个小异才是关键地方，能异于其他人的地方。可以从如下几个方面去做准备：
1.特意准备几个面试题源码。像我在回答一些中规中矩面试题的时候，都会从源码角度出发。比如常见的HashMap等集合类，多线程的各种锁以及大数据框架的部分源码。
2.特意准备项目难点。面一些大厂的时候避免不了被问到项目难点，不可能用普通Bug含糊过去啊。这边可以从项目用到的技术栈出发，去寻找技术栈在项目中会存在的难点，然后套进自己的项目，找个自己能懂，最好能全懂的。
3.针对性去了解公司的技术栈使用情况。比如头条使用Go，众人皆知，那为什么我不突击学习一下呢？比如从业内人士得知头条最早使用的是Kylin框架，后面慢慢转为ClickHouse，那我必须了解一下两者的不同啊，而且可以结合头条的业务场景。
七、一个关于如何进大厂的小建议 我一直崇尚「曲线救国」的做法，也一直在向别人传播这种做法。现在能力背景不足没关系，只要规划好自己的学习路线，一步步阶梯式往上爬，总可以实现目标。因为我自己二本出身，但我意识的早，大二就开始实习，用项目和实习经历弥补我背景不足，然后一步步走到「offer自由」。很多时候并不是只有巨人才可以成功，你只需要做到行动上的普通人，就可以超过很多思想上的巨人，行动上的矮子。
读者福利 同时我自己也总结出了互联网公司java程序员面试涉及到的绝大部分面试题及答案做成了文档和架构视频资料免费分享给大家（包括Dubbo、Redis、Netty、zookeeper、Spring cloud、分布式、高并发等架构技术资料），希望能帮助到您面试前的复习且找到一个好的工作，也节省大家在网上搜索资料的时间来学习。
加群：1017599436领取面试资料（助你面试无忧） 合理利用自己每一分每一秒的时间来学习提升自己，不要再用"没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！
转载于:https://juejin.im/post/5d02337f51882571521112fa
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd36dc781d535c9233a094d0db8e20c5/" rel="bookmark">
			spring 整合spring  data mongodb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。
MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。
为什么需要MongoDB
MongoDB与MySQL的区别 关于MongoDB与MySQL的区别可以参考网上关于NoSQL与MySQL的区别，以下是找到的网上的关于两者区别的截图：
总体上讲：
由于MongoDB独特的数据处理方式，可以将热点数据加载到内存，故而对查询来讲，会非常快（当然也会非常消耗内存）；同时由于采用了BSON的方式存储数据，故而对JSON格式数据具有非常好的支持性以及友好的表结构修改性，文档式的存储方式，数据友好可见；数据库的分片集群负载具有非常好的扩展性以及非常不错的自动故障转移（大赞）。
不足：数据库的查询采用了特有的查询方式，有一定的学习成本（不高）；索引不咋滴；锁只能提供到collection级别，还做不到行级锁；没有事务机制（不能回滚啊）；学习资料肯定没有MySQL的多。
其他不多说，下面开始结合spring 整合spring data mongodb 。
1，添加依赖，现在项目用的是spring版本是
&lt;spring.version&gt;4.3.12.RELEASE&lt;/spring.version&gt; 所以决定spring data mongodb版本采用（注意，根据自己的spring版本去依赖，不然会报错）
&lt;version&gt;1.10.4.RELEASE&lt;/version&gt; 2，spring data mongodb的配置有两种方式，一个注解方式，还有xml方式，现在大家都趋向用springBoot，所以还是用注解配置吧，方便向后集成。
2.1: 新建MongoProperties类，这里需要根据mongodb.properties中的值赋值
2.2：新建MongoConfiguration，这里是整合的核心部分，利用@Configuration可实现和xml配置一样的效果，
另外initMongo()是在springIOC容器加载MongoConfiguration类，初始化会调用的方法，有的时候这里给出一些日志信息，便于我们观察到底使用的是什么环境，哪些参数等，比如将方法体改成：
在项目启动的时候，将看到控制台输出：对应的host地址，使用的数据库是什么。
2.3：新建mongodb.properties
这里又几个问题需要注意一下。mono.host默认配置是localhost,我们一般在Windows上搭建mongoDB时，mongoDB服务默认监听的地址就是127.0.0.1.也就是localhost,如下列图
用Notepad++打开，找到对应的行
这里你想修改成本机的ip地址，比如192.168.0.13，修改这一行就可以了，再重新启动（有的时候，即使修改了，但是在测试的时候，还是报链接失败等错误，可以检查自己的ip是否是正确的，比如我原本的ip地址是192.168.0.17，但是不知道什么时候分配成192.168.0.13,最后当然报错，如果用的是他人的monog,最后再用命令 ping ip 检查是否链接）
到这里整合就差不多了，最后就是写demo，进行测试。
最后再提一点，spring data mongodb 可以实现MongoRepository接口，也可以用他的模板MongoTemplate。整合完毕，Over.
，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0e0ff57965bb07eabed355ebf39689b/" rel="bookmark">
			微PE制作U盘启动盘教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、微PE简介 微PE是目前最受欢迎的PE工具，工具纯净无广告，功能强大，极致精巧。微PE可以安装到当前系统下，开机通过启动菜单可以进入；也可以将PE安装到U盘、移动硬盘，当Windows系统无法进入时，可以通过U盘或移动硬盘启动进入PE；此外，它还可以将PE生成ISO格式的文件，方便的进行光盘刻录。
二、工具准备 * 移动硬盘1T 或者格式化好的U盘 * Windows 系统镜像文件
* WinPE安装包 1、Windows系统镜像下载及版本介绍（见本人博客）：Windows官方纯净系统镜像下载及相关介绍
2、微PE工具箱下载
微PE工具箱官网下载：http://www.wepe.com.cn百度云盘下载链接（微PE工具箱V2.0 64位）：https://pan.baidu.com/s/1gIueacZuV7lmQwX-ynuBlA 提取码：escp 三、微PE制作U盘启动盘步骤 1、首先将U盘插入到电脑，然后双击WePE_64_V2.0.exe文件，启动微PE工具箱程序，来的主界面，如下图所示：
2、点击如下图右下角第一个图标
3、点击后进入U盘制作界面，此时工具箱会自动识别U盘信息，此时我们需要选择一些自己需要的制作信息，安装方法默认推荐的即可，默认格式化，格式化后的U盘格式有三种，推荐的也是默认的exFAT格式，U盘运行模式为USB-HDD，U盘卷标可以自己取名字，PE壁纸可以自选，其他默认即可。 4、点击“开始制作”，等待完成即可。
5、微PE制作U盘启动盘成功后，原来的U盘会变成如下图形态，将Windows系统镜像拷贝到对应文件夹下即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92eab3cf60902c0de0e03d0504d54a26/" rel="bookmark">
			中望CAD二次开发环境配置及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天第一次接触中望CAD的二次开发，首先就需要搭建开发环境，网上的资料太少了，试着自己做了一下，现将整个过程记录下来，备查。
（1）下载中望CAD2018，我在官网下的，试用30天，没去找破解版。我用的64位的
ZWCAD_2018_CHS_Win_64bit.exe,直接安装。
（2）下载中望CAD二次开发的sdk，ZWCAD_2018_ZRXSDK.exe，直接安装。（我放在了中望CAD2018的安装路径下)。安装完后，里面有个doc文件夹，所有的帮助就在里面了。
（3）我使用visual studio 2010做开发平台。打开VS2010，具体过程如下：（来自doc目录下的ZRXDev.chm）
a) Create a new project in Visual Studio 2010
b) Click Next to next step
c) Click Finished to end the wizard
（4)进入工程后，对项目属性进行配置
输入附加依赖项： ZwRx.lib; ZwZrx.lib; ZwDatabase.lib; ZwGeometry.lib; ZWCAD.lib; ZdUI.lib; ZwUI.lib
按确定，至此配置结束。
自带demo，直接编译，注意：选择平台，你是32位的，就编成32位，64位就用64位。
找到:
打开中望CAD，在管理-扩展工具
最后一步了，根据程序命令输入指令，如下图，
回车，弹出对话框
至此，整个配置和运行第一个demo完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ce990e5d82922c4428e0fc37614e07/" rel="bookmark">
			HAL库下Uart与SPI的DMA发送与接收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HAL库下Uart与SPI的DMA发送与接收
一直有想法对HAL库下对串口与与SPI进行DMA方式接收与发送的详细配置了解，以及正确的操作流程。
首先介绍Uart在HAL中实现DMA的发送与接收
串口配置这个就无需我在此叙述，直接进入主题：
软件配置如图，DMA中断默认开启，需要我们采用DMA传输必须要使能串口中断；
HAL_UART_Transmit_DMA(&amp;huart1,Uart_tx_buf,sizeof(Uart_tx_buf));为DMA发送函数
在配置完成后，调用上面的函数就可以直接发送到电脑。
串口的DMA接收，就要麻烦一些，需要了解回调函数：
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)和
HAL_UART_Receive_IT(&amp;huart1,(uint8_t *)Uart_rx_temp,Length);//Uart_DMA数据缓存接收中断
其中Uart_rx_temp，Length为在进入callback函数之前需要接收到的数据长度以及数据接收存放地址。所以在代码main初始化时需要加上。当满足一次接收中断的要求后，就会直接调转到HAL_UART_RxCpltCallback；当然此前CUBEMAX已经就为我们初始化了Uart1的中断。
下面是一段简单的测试代码：
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
if(huart-&gt;Instance == USART1)
{
Uart_rx_buf[Rx_cnt++]= Uart_rx_temp[0];
Uart_rx_buf[Rx_cnt++]= Uart_rx_temp[1];
if((Uart_rx_temp[0] == 0x0D)&amp;&amp;(Uart_rx_temp[1] == 0x0A)) { Uart_rec_success= 1; } HAL_UART_Receive_IT(&amp;huart1,(uint8_t *)Uart_rx_temp,Length); } 在主函数中我们就只要轮询 Uart_rec_success= 1;这个条件是否满足，去执行相对应的结果就行。
在此我遇到一个DMA发送的一个坑，就是谨防在DMA数据没有发送完成时，将数据进行改变。我最开始用：HAL_SPI_Transmit(&amp;hspi1,(uint8_t*)tx_buf,1,10);测试没有任何问题，但： HAL_UART_Transmit_DMA(&amp;huart1,Uart_tx_buf,11);会出现数据掉包，不完整的；结果是因为我在下面一条语句就是
for(i=0;i&lt;Rx_cnt;i++)
Uart_rx_buf[i] = 0;
我也就不多说串口 。下面介绍SPI_DMA 中的配置；
最开始测试：采用 HAL_SPI_Transmit_DMA(&amp;hspi1,(uint8_t*)tx_buf,7);
效果波形如图：
数据正常，但是数据边沿有脉冲，考虑原因可能是采样率太高，造成波形抖动，降低采样率后，有好转，但是尚未完全解决。
HAL_SPI_TransmitReceive_DMA(&amp;hspi1,(uint8_t *)tx_buf,(uint8_t *)rec_buf,(sizeof(tx_buf)/sizeof(uint16_t)));
函数在最开始使用时，数据掉包，审查了发现：
HAL_SPI_TransmitReceive_IT(&amp;hspi1,(uint8_t *)tx_buf,(uint8_t *)rec_buf,7);
接收数据正常，与上图波形一致。为什么DMA全双工数据就会掉包呢？
考虑到并未对缓冲区数据进行操作，就去检查自己的配的工程，发现原来没有打开SPI接收DMA。在此三个函数都能正常数据传输。
对于回调函数，也和串口相似，只需要在发送或则从机接收完成后，就会进去执行各种flag，需要控制操作就在主函数进行操作判断。但是最近从机的SPI一直有问题，数据乱码不稳定，希望后面能够解决，或得到网友的帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6165f1c14490d89f3a04f05b06db578b/" rel="bookmark">
			HTML5 WebSocket&#43;Asp.Net 实例四-用户标识，后台推送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Asp.Net 后台操作定义
注：当前示例仅考虑了单个链接的打开，对于多页面打开或者换浏览器打开的情况没做处理。
/// &lt;summary&gt; /// Socket后台代码示例 /// &lt;/summary&gt; public class SocketOneController : Controller { static Dictionary&lt;string, WebSocket&gt; CONNECT_POOL = new Dictionary&lt;string, WebSocket&gt;();//用户连接池 //测试1,定义socke监听 public void One(string user) { HttpContextBase context = ControllerContext.HttpContext; context.AcceptWebSocketRequest(async (ctx) =&gt; { //开启socket监听 WebSocket socket = ctx.WebSocket; while (true) { ArraySegment&lt;byte&gt; buffer = new ArraySegment&lt;byte&gt;(new byte[1024]); CancellationToken token; if (socket.State == WebSocketState.Open) { //后台上线处理 if (CONNECT_POOL.Keys.Contains(user) == false) CONNECT_POOL.Add(user, socket); WebSocketReceiveResult result = await socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6165f1c14490d89f3a04f05b06db578b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46ebec96328c71a37e63f3ab9d295669/" rel="bookmark">
			js返回，跳转页面等的浏览器及物理监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window.onbeforeunload = function(e) {
if (edu.n&gt;0&amp;&amp;flag) {
edu.getTimer();
} }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb9d63a84abb9af0de0f3eff6d6ab93c/" rel="bookmark">
			Spring Cloud Alibaba实战(八) - Dubbo &#43; Nacos
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
(一)Nacos动态配置
(二)Nacos注册中心
(三)Sentinel之限流
(四)Sentinel之熔断
(五)Gateway之路由、限流
(六)Gateway之鉴权、日志
(七)Gateway搭配Nacos实现动态路由
(八)Dubbo + Nacos
正文
通常来说，RPC协议比REST具有更好的性能，服务的内部调用可以考虑使用RPC方式来提高效率。下面来改造account和payment服务，在account中通过dubbo协议来调用payment的查询余额接口，并使用Nacos作为注册中心。
首先创建基于Dubbo的payment服务应用(SpringBoot)，即providor端：
pom.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.github.autfish&lt;/groupId&gt; &lt;artifactId&gt;payment-dubbo-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;payment-dubbo-service&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;alibaba.version&gt;0.9.0.RELEASE&lt;/alibaba.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;${alibaba.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;${alibaba.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-dubbo&lt;/artifactId&gt; &lt;version&gt;${alibaba.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb9d63a84abb9af0de0f3eff6d6ab93c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0025f6f1d0ad2a57d77ce40764be9175/" rel="bookmark">
			反常积分(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		性质3,记住啊！！！！！！！！！！！！！！！！！！！！ 若 ∫ a + ∞ ∣ f ( x ) ∣ \int_{a}^{+ \infty}|f(x)| ∫a+∞​∣f(x)∣收敛（也就是 ∫ a + ∞ f ( x ) \int_{a}^{+ \infty}f(x) ∫a+∞​f(x)绝对收敛的意思），则
∫ a + ∞ f ( x ) d x \int_{a}^{+ \infty}f(x)dx ∫a+∞​f(x)dx亦收敛哦！
且有
(3) ∣ ∫ a + ∞ f ( x ) ∣ d x ≤ ∫ a + ∞ ∣ f ( x ) ∣ d x |\int_{a}^{+ \infty}f(x)|dx\le \int_{a}^{+ \infty}|f(x)|dx \tag{3} ∣∫a+∞​f(x)∣dx≤∫a+∞​∣f(x)∣dx(3)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0025f6f1d0ad2a57d77ce40764be9175/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/475/">«</a>
	<span class="pagination__item pagination__item--current">476/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/477/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>