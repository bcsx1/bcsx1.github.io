<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8785b9a0629bdafca5674f9d91e018c/" rel="bookmark">
			opencv Nv12 转jpg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 int nWidth = 1920; int nHeight = 1080; unsigned char* pYuvData = new unsigned char[nWidth * nHeight * 3 / 2]; FILE* file = fopen("D:\\LoadBmp\\1.yuv", "rb+"); fread(pYuvData, 1, nWidth * nHeight * 3 / 2, file); fclose(file); cv::Mat image(nHeight + nHeight / 2, nWidth, CV_8UC1, pYuvData); cv::Mat cv_img = cv::Mat(nHeight, nWidth, CV_8UC3); cv::cvtColor(image, cv_img, COLOR_YUV2BGR_NV12); cv::imwrite("2.jpg", cv_img); delete[] pYuvData; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b557731e6fe74822482bd83741c31a8d/" rel="bookmark">
			vue创建项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、配置node环境 Node.js 安装配置-----菜鸟教程
npm 使用介绍-----菜鸟教程
淘宝镜像
淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。
可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:
npm install -g cnpm --registry=https://registry.npmmirror.com 这样就可以使用 cnpm 命令来安装模块了：
cnpm install [name] npm 版本需要大于 3.0，如果低于此版本需要升级它：
查看版本
$ npm -v &gt; 2.3.0 #升级 npm cnpm install npm -g #升级或安装 cnpm npm install cnpm -g 2、安装及创建 2.1 独立版本 我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 下载vue.js（2.0版本）
下载vue.js (版本为@3.2.36)
2.2 使用 CDN 方法 2.2.1 vue2版本 Staticfile CDN（国内): https://cdn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b557731e6fe74822482bd83741c31a8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ac358c326276f6dc83d02a22048a7fb/" rel="bookmark">
			图片曝光修正方法（直方图均衡和CNN）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像过曝或曝光不足时需要曝光处理，
这里以曝光不足举例。
直方图均衡法： 通过RGB通道的直方图均衡达到处理曝光不足的效果。
代码：
underexpose = cv2.imread("exposure_test.jpg") #underexpose = cv2.cvtColor(underexpose, cv2.COLOR_BGR2RGB) equalizeUnder = np.zeros(underexpose.shape, underexpose.dtype) equalizeUnder[:, :, 0] = cv2.equalizeHist(underexpose[:, :, 0]) equalizeUnder[:, :, 1] = cv2.equalizeHist(underexpose[:, :, 1]) equalizeUnder[:, :, 2] = cv2.equalizeHist(underexpose[:, :, 2]) cv2.imshow(equalizeUnder) CNN方法 Learning Multi-Scale Photo Exposure Correction（CVPR2021）
paper
python版github地址
按github配置环境，下载weight.
with torch.no_grad(): MSPEC_net = MSPEC_Net().cuda() MSPEC_net =torch.nn.DataParallel(MSPEC_net) MSPEC_net.load_state_dict(torch.load('./snapshots/MSPECnet_woadv.pth')) MSPEC_net.eval() data_input = cv2.imread('test.jpg') output_image = down_correction(MSPEC_net,data_input) #在mspect_test.py中 if output_image.dtype == 'uint8': cv2.imwrite( "output.jpg",output_image) else: cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ac358c326276f6dc83d02a22048a7fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abde49d9e33db2cef9d3d0f64402ba7f/" rel="bookmark">
			2023-南京荣耀Honor最新探访-OPEN DAY，实况记录！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 金九银十的秋招季缓缓落幕！ 接完offer，博主也回归啦！有幸带着公开公平的心态，给大家分享一波南京荣耀总部的实况解密！ 最基础的环境状况，有图有真相！~上图~ 民以食为天-南京荣耀食堂！ 荣耀有自己的食堂，两层！晚8：30后免费领夜宵，种类丰富！ 运动健身超nice- 南京荣健身房！ 荣耀有自己的健身房，注重劳逸结合！爱运动的小伙伴可以看一看，还有淋浴间！超新！ 长年累月工作区-南京荣耀工位概览 弧型工位，空间满满！人工学椅，贴心护腰！零食多多！顶楼风景更好！ 期间还有很多的经验分享，对新员工的宽容度、指导性，全是诚意满满！ 期待成为快乐的小💊子！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45825565e7ab56ec69e194b0f247ba3/" rel="bookmark">
			Spring常见面试题55道（附答案2023最新版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是 Spring 框架 Spring框架是一个开源的Java平台，它最初由Rod Johnson创建，并在2003年首次公布。它的主要功能是简化Java开发，特别是企业级应用程序的开发。Spring框架的设计哲学是通过提供一系列模块化的组件，帮助开发者创建高性能、易测试、可重用的代码。现在，让我们更深入地了解Spring框架的核心部分和特性。
核心特性 依赖注入（DI）：
这是Spring框架的核心特性之一，它通过控制反转（IoC）的方法来管理对象的创建和它们之间的依赖关系。它允许对象定义它们依赖的组件（例如其他对象），而不是自己构造它们或查找服务定位器模式。 面向切面编程（AOP）：
AOP允许开发者将某些功能分割出来进行模块化，如事务管理、日志记录等，这些功能可以横切多个类型和对象。通过AOP，可以将这些横切关注点从对象的核心业务逻辑中分离出来，从而提高模块性。 模块化和分层架构：
Spring框架具有模块化结构，可以根据需要包含或排除具体的模块。它支持分层架构，将不同的关注点（如数据访问、业务逻辑、表示层等）分离到不同的层次。 事务管理：
Spring提供了一致的事务管理接口，可以支持声明式或编程式的事务管理。这降低了对特定数据库或JTA事务API的依赖。 MVC框架：
Spring Web MVC是一个基于模型-视图-控制器设计模式的富特性Web框架。它轻松集成了其他Spring功能，如依赖注入，并提供了灵活的URL映射和视图解析。 高级特性 数据访问/集成：
Spring简化了与数据库的交互，提供了一个一致的数据访问模型，无论是使用JDBC还是ORM框架。它提供了对JPA、Hibernate、JDO等ORM框架的支持，并处理了样板代码和异常处理。 消息传递：
Spring的消息传递模块提供了使用消息队列进行异步通信的能力。它通过Spring Integration提供了企业集成模式的支持。 Web应用开发：
除了Spring MVC，Spring也支持Websocket、STOMP、WebFlux等，提供了创建响应式应用程序的能力。 测试：
Spring提供了一个测试模块，以支持使用JUnit或TestNG对Spring组件进行单元和集成测试。它提供了模拟对象、测试数据的管理和Spring容器的测试功能。 安全：
Spring Security提供了身份验证和授权的全面解决方案，包括对OAuth、OpenID、LDAP等标准的支持。 Spring Boot：
虽然不是Spring框架的一个模块，但Spring Boot是基于Spring构建的，它提供了快速开发和运行Spring应用程序的能力，通过极简的配置支持。 设计原则 轻量级：
Spring是一个轻量级的框架，不仅在大小上（它的核心容器很小），也在概念上（它不强迫使用任何特定的编程模型）。 非侵入性：
Spring代码通常不依赖于Spring框架特定的类和注解，这提高了代码的可重用性和可测试性。 后向兼容性：
Spring致力于在版本升级时保持向后兼容性，这减少了升级的复杂性。 支持多种技术适配：
Spring提供了与多种技术集成的支持，包括JDK标准、第三方库和框架。 结论 Spring框架是构建Java应用程序的强大工具，它提供了丰富的功能集合，从基本的核心功能到集成层和高级企业服务。它通过DI、AOP、声明式服务和许多其他特性，大大简化了编程模型和代码量，使开发者能够更快地构建灵活、可伸缩的应用程序。
Spring 框架优点 Spring 框架的优点体现在多个方面，这些优势使得Spring成为了Java企业应用开发中广泛使用的框架之一。以下是Spring框架的主要优点：
1. 促进松耦合 通过依赖注入（DI）和控制反转（IoC），Spring允许组件之间的依赖关系在运行时自动解决，这减少了组件间的直接依赖。因此，可以更容易地更换组件的实现，提升了代码的可维护性和可复用性。
2. 声明式编程支持 Spring支持声明式事务管理，这使得开发者可以不必深入了解事务API就能管理事务。类似地，通过AOP，开发者可以将安全、事务、日志等横切关注点从业务逻辑中分离，这样业务逻辑更加清晰，也易于测试和维护。
3. 灵活性和兼容性 Spring高度灵活，几乎可以和Java的任何应用程序一起工作。它支持与多种技术集成，如JDBC、Hibernate、JPA、JMS、邮件服务、定时任务等。还能适应各种数据库和中间件产品。
4. 全面的数据访问支持 Spring提供了一层抽象来简化数据访问技术的使用，包括异常处理转换，这样开发者在编码时就不必担心数据库的具体异常和错误代码。
5. 事务管理 Spring的事务管理抽象允许开发者使用声明式或编程式的事务管理，无需依赖于容器的事务特性。这一点在非容器环境中尤其有用。
6. 综合Web支持 Spring框架包含一个成熟的MVC框架，该框架是一个可选的Web模块，为构建Web应用程序提供了一个MVC实现，并且可以与其他视图技术如JSP、Freemarker、Velocity等无缝集成。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d45825565e7ab56ec69e194b0f247ba3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c50aedf211e195173c5224f32202682/" rel="bookmark">
			大数据之Hive:正则表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 背景一、正则的通配符简介1、正则表达式的符号及意义2、字符簇：3、各种操作符的运算优先级： 二、regexp函数三、regexp_extract函数四、regexp_replace函数 背景 最近在工作中，遇到一些匹配，需要使用正则表达式，发现自己在这一块知识有所欠缺，故总结一下；
一、正则的通配符简介 1、正则表达式的符号及意义 符号含义实列\做为转意，即通常在" \ "后面的字符不按原来意义解释如" * “匹配它前面元字符0次或多次，/a*/将匹配a,aa,aaa，加了”/"后，/a/* /将只匹配"a* "^匹配一个输入或一行的开头/^a/匹配"an A"，而不匹配"An a"$匹配一个输入或一行的结尾/a$/匹配"An a"，而不匹配"an A"*匹配前面元字符0次或多次/ba*/将匹配b,ba,baa,baaa+匹配前面元字符1次或多次/ba+/将匹配ba,baa,baaa?匹配前面元字符0次或1次/ba?/将匹配b,ba(x)匹配x保存x在名为$1…$9的变量中x竖y匹配x或y{n}精确匹配n次{n,}匹配n次以上{n,m}匹配n-m次[xyz]字符集(character set)，匹配这个集合中的任一一个字符(或元字符)[^xyz]不匹配这个集合中的任何一个字符\d匹配一个字数字符//d/ = /[0-9]/\D匹配一个非字数字符//D/ = /[^0-9]/\s匹配一个空白字符，包括/n,/r,/f,/t,/v等\S匹配一个非空白字符，等于/[^/n/f/r/t/v]/\w匹配一个可以组成单词的字符(alphanumeric，这是我的意译，含数字)，包括下划线，如[/w]匹配"$5.98"中的5，等于[a-zA-Z0-9]\W匹配一个不可以组成单词的字符，如[/W]匹配"$5.98"中的 $，等于[^a-zA-Z0-9] 备注：
‘( )’ 标记一个子表达式的开始和结束位置。
‘[]’ 标记一个中括号表达式。
/num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。
2、字符簇： [[:alpha:]] 任何字母。
[[:digit:]] 任何数字。
[[:alnum:]] 任何字母和数字。
[[:space:]] 任何白字符。
[[:upper:]] 任何大写字母。
[[:lower:]] 任何小写字母。
[[:punct:]] 任何标点符号。
[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]
3、各种操作符的运算优先级： 转义符&gt;圆括号和方括号&gt;限定符&gt;位置和顺序
具体如下：
/ 转义符
(), ( ?: ), (?=), [] 圆括号和方括号
*, +, ?, {n}, {n,}, {n,m} 限定符
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c50aedf211e195173c5224f32202682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/084d431e9a1bbc25a974d1faaf1f41b4/" rel="bookmark">
			VS2019 钥匙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio 2019 Enterprise（企业版）：BF8Y8-GN2QH-T84XB-QVY3B-RC4DF
Visual Studio 2019 Professional（专业版）：NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/372b4450bf7f2ab0406f4a5e7300266e/" rel="bookmark">
			G1506 小电流升压型LED驱动芯片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 G1506 小电流升压型LED驱动芯片 概述 ： G1506是一种专为以恒定电流来驱动白光LED而设计的升压型DC/DC变换器。该器件能利用一节锂离子电池来驱动两个、三个或四个串联的LED采用LED串联连接的方法可以提供相等的LED电流·从而能获得均匀的亮度且无需镇流电阻器。G1506的开关频率为1.3MHz，因而允许采用小巧的外部元件。由于可使用数值仅为0.22uF的输出电容器，因此，与其他的解决方案相比，在占用空间和成本上均有所节省。95mV的低反馈电压最大限度地降低了电流调节电阻器的功耗，从而提高了效率。G1506采用SOT-23封装. 特性： 固有匹配的LED电流 高效率：84%（典型） 可由一个3.2V电源驱动多达四个LED 可由一个5V电源驱动多达六个LED 性能稳定的36V双极开关 快速1.3MHz开关频率 采用高度仅1mm的纤巧型电感器 只需0.22uF的输出电容器 采用扁平的SC70和 ThinSOT封装 应用： ■蜂窝电话 ■PDA、手持式电脑 ■数码相机 ■MP3播放机 ■GPS接收机 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f00b8e77e31e50d1c270f59bb7fca2b/" rel="bookmark">
			一款视频行为分析系统，可轻松开发安全行为检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列版本介绍 基于视频行为分析系统v4系列版本可以在不用考虑流媒体音视频开发，编解码开发，界面开发等情况下， 只需要训练自己的模型，开发自己的行为算法插件，就可以轻松开发出任何你想要的安全行为检测，比如周界入侵，打架，斗殴，跌倒，人群聚集，离岗睡岗，安全帽检测，充电桩，工作服， 疲劳检测，交通拥堵等等。（当前仅提供Windows版编译安装包，其他平台编译请联系作者） 启动程序 （编译安装包）直接运行 VideoAnalyzer.exe 即启动整个项目，启动项目前可以参考下面的配置说明（当前仅提供Windows版编译安装包，其他平台编译请联系作者） 启动配置说明 //config.json { "host": "127.0.0.1", //部署机器IP地址（可以使用127.0.0.1,推荐使用ipconfig获取本机局域网IP地址） "adminPort": 9001, //后台管理服务器端口 "analyzerPort": 9002,//视频分析服务端口 "mediaHttpPort": 9003, //流媒体服务器端口 "videoAnalyzerPort": 9004, //启动工具端口 "mediaRtspPort": 9554, //流媒体服务器RTSP协议端口 "mediaSecret": "aqxY9ps21fyhyKNRyYpGvJCTp1JBeGOM",//流媒体服务器安全码 "uploadDir": "Admin\\static\\upload", //后台管理上传算法，音频，报警视频等文件根目录 "workerConcurrency": 20, //默认支持布控数量（系统在运行过程中，还会自动调节支持的布控数量） "supportHardwareVideoDecode": false, //是否支持硬件解码（建议关闭硬件解码，将硬件资源留给算法） "supportHardwareVideoEncode": false //是否支持硬件编码（建议关闭硬件编码，将硬件资源留给算法） } 进入后台管理 在浏览器输入 http://127.0.0.1:9001系统默认账号 用户名：admin 密码：admin888 v4.2.2 发布时间 2023.12.14（1）分析器在布控时新增推理设备是否支持的检测（2）分析器优化报警合成队列的使用机制（3）后台管理新增新版本检测功能，新版本弹窗提示功能 v4.2.1 发布时间 2023.12.13（1）优化解码和分析以及推流的队列内存复用（2）优化算法推流的流畅性 v4.2 发布时间 2023.12.10（1）解决系统稳定性问题，已经可以非常稳定的运行在配置比较一般的Windows设备（4000元左右的8G内存轻薄本，也可以非常稳定的布控10-20路1080p视频流）（2）系统启动时新增环境检测功能，环境检测包括端口占用检测，程序重开检测，后续会增加处理器支持检测，显卡支持检测（3）FFmpeg-4.4升级至FFmpeg6.0 v4.1.2 发布时间 2023.12.9（1）解决视频分析器在大规模布控情况下，布控超过1小时，必崩溃的稳定性问题。（与视频流拉流解码时线程安全有关，OpenCV-3.4.10版本有关）（2）OpenCV-3.4.10升级至OpenCV-4.7.0，考虑到该项目目标是让足够多的普通笔记本电脑能够运行，因此该OpenCV库未扩展cuda模块，仅扩展了dnn模块。（注意：仅有支持N卡的机器才能运行包含cuda模块的OpenCV库） v4.1.1 发布时间 2023.12.7（1）视频分析器优化布控调节，解决因为超量布控导致的程序崩溃（2）后台管理支持批量布控，布控复制，布控日志查询 v4.1 发布时间 2023.12.5v4.1视频介绍地址 https://www.bilibili.com/video/BV1dH4y1C7hY（1）视频分析器新增支持API类型的基础算法接入（2）后台管理新增支持API类型的基础算法（3）后台管理基础算法支持设置布控数量上限 v4.0 发布时间 2023.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f00b8e77e31e50d1c270f59bb7fca2b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bc509394e8b4d4907aa2e1b256806f9/" rel="bookmark">
			VSCode调试Vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 代码在某个平台运行时，会将运行时的状态通过某种方式暴露出来。这些状态信息可以通过某种方式传递给开发工具，以便进行UI的展示和交互。这样的交互可以辅助开发者排查问题、梳理流程，并更好地了解代码的运行状态。这就是我们通常所说的调试。 在过去，我们常常需要在浏览器中进行调试，但这种方式往往显得繁琐，尤其是在只有一个屏幕的情况下，我们很难同时查看代码和调试信息。然而，VSCode 拥有内置的 Debug 功能，使得调试变得更加便捷。
问题 在使用 VSCode 进行调试时，我们可以通过 Debug 窗口的 " create a launch.json file " 快速创建配置文件。然而，有时候我们会发现 VSCode 提示未绑定断点，这时我们需要去浏览器中对应文件看看是什么情况。可能是因为某些特定的代码行没有被正确地设置为断点，或者可能是因为某些设置或配置问题导致的。 我们去浏览器中查看对应路径，发现路径后面多了个 ?bc11（ hash 字符串），导致在本地项目目录中找不到对应的文件。那么为什么会多了一个哈希字符串呢？
这是因为 Vue Cli 默认的 devtool 设置是 eval-cheap-module-source-map，而 eval 是每个模块用 eval 包裹，并且通过 sourceURL 指定文件路径，通过 sourceMappingURL 指定 sourcemap。
而 sourceURL 和 sourceMappingURL 是两个 JavaScript 的编译器选项，它们用于提供源代码的映射信息。这些选项主要用于调试，让开发者能够看到原始源代码，而不是编译后的代码，可以帮助开发者更容易地调试和了解编译后的代码是如何生成的。
sourceURL 这是一个字符串，它提供了源代码的 URL。当使用 eval() 执行代码时，这个 URL 会被添加到编译后的代码中，这样开发者就可以知道哪些代码是通过 eval() 执行的。例如，如果你有一个模块，你使用 eval() 来包裹它，你可以使用 sourceURL 来指定这个模块的源代码 URL。这使得在浏览器的开发者工具中，你可以直接跳转到这个模块的源代码位置。 sourceMappingURL 这是一个 URL，指向源代码的映射信息。源代码映射是一个数据结构，它描述了编译后的代码与原始源代码之间的映射关系。这使得开发者可以更容易地理解编译后的代码是如何从原始源代码生成的。当你在浏览器中打开开发者工具并查看编译后的代码时，如果这个文件有源映射，那么你可以点击某个位置，直接跳转到原始的源代码位置。 所以我们可以发现是 Vue CLI 默认的 devtool 设置所导致的，那么我们就可以通过修改对应的配置项来解决问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bc509394e8b4d4907aa2e1b256806f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa7f2ab53336fbc3500f6a968f872690/" rel="bookmark">
			Unity中 URP 下的棋盘格Shader
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、制作思路法1：使用纹理采样后，修改重铺效果法2：计算实现 二、粗略计算实现棋盘格效果1、使 uv.x &lt; 0.5 区域 = 0 。反之， = 0.52、使 uv.y &lt; 0.5 区域 = 0 。反之， = 0.53、使两个颜色相加4、取小数部分5、乘以2 三、去除 if 条件语句后的精简方法1、我们在图形计算器中看一下2、向下取整3、乘以24、我们在属性面板使用参数控制棋盘格重复度5、使棋盘格Shader适用于Cube6、使棋盘格颜色从下到上渐变7、我们可以给棋盘格Cube加一个父对象，使缩放时，不会Cube中心为调整的位置（按需使用）8、可以在属性面板加一个颜色来调整棋盘格颜色(按需使用) 四、测试代码 前言 我们展示我们Shader效果，一般放于棋盘格中来展示。我们在这篇文章中，制作棋盘格效果。
一、制作思路 法1：使用纹理采样后，修改重铺效果 法2：计算实现 我们在这篇文章中，主要计算实现该效果
二、粗略计算实现棋盘格效果 1、使 uv.x &lt; 0.5 区域 = 0 。反之， = 0.5 if(i.uv.x &lt; 0.5)
col1 = 0;
else
col1 = 0.5;
2、使 uv.y &lt; 0.5 区域 = 0 。反之， = 0.5 if(i.uv.y &lt; 0.5)
col2 = 0;
else
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa7f2ab53336fbc3500f6a968f872690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cc86068e830944576791136051eac10/" rel="bookmark">
			删除win10服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前工作需要在我电脑上安装了一个天气的服务，我想删掉但是在任务管理器里删不掉，请教了大佬
删除方法是，在开始菜单里找到命令提示符
右键-以管理员方式打开命令提示符
输入sc 按enter键，可以查看一些操作命令
删除服务的话，输入sc delete 服务名称 然后按enter键即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6578391811cb8092ece94b6934b6cbb2/" rel="bookmark">
			Linux CentOS下Composer简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载composer-setup.php cd /usr/local/src php -r “copy(‘https://install.phpcomposer.com/installer’, ‘composer-setup.php’);” 2.安装composer php composer-setup.php 3.设置全局composer cp composer.phar /usr/local/bin/composer 4.设置国内镜像
composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 或
composer config -g repo.packagist composer https://packagist.phpcomposer.com 5.查看全局配置 composer config -l -g 输出： Do not run Composer as root/super user! See https://getcomposer.org/root for details Continue as root/super user [yes]? yes [repositories.packagist.org.type] composer [repositories.packagist.org.url] https://packagist.phpcomposer.com [process-timeout] 300 [use-include-path] false [use-parent-dir] prompt [preferred-install] dist [audit.abandoned] default [notify-on-install] true [github-protocols] [https, ssh] [gitlab-protocol] [vendor-dir] vendor (/root/vendor) [bin-dir] {$vendor-dir}/bin (/root/vendor/bin) [cache-dir] /root/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6578391811cb8092ece94b6934b6cbb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df3a9f72306b73229498c28b6e1ef18/" rel="bookmark">
			如何建立自己的代理IP池，减少爬虫被封的几率
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、了解代理IP的工作原理
二、获取代理IP
2.1 免费代理IP网站
2.2 付费代理IP服务商
三、验证代理IP的可用性
四、建立代理IP池
五、定期更新代理IP池
总结
前言 建立自己的代理IP池可以帮助减少爬虫被封的几率。通过使用代理IP，我们可以隐藏爬虫的真实IP地址，提高爬取网站的稳定性和安全性。本文将介绍如何建立一个代理IP池，并提供相关代码示例。
一、了解代理IP的工作原理 在开始建立代理IP池之前，我们需要了解代理IP的工作原理。代理IP是一个位于客户端和服务器之间的中间人，它负责转发客户端的请求并返回服务器的响应。通过使用代理IP，我们可以隐藏真实的请求来源，并模拟不同的访问行为。
二、获取代理IP 要建立一个代理IP池，首先需要获取可用的代理IP。以下是几种获取代理IP的常用方法：
2.1 免费代理IP网站 有很多免费的代理IP网站提供可用的代理IP列表。我们可以通过爬取这些网站来获取代理IP。以下是一个示例代码，使用requests库爬取代理IP网站：
import requests from bs4 import BeautifulSoup def get_proxies(url): response = requests.get(url) soup = BeautifulSoup(response.text, 'html.parser') proxies = [] for row in soup.find_all('tr'): cols = row.find_all('td') if len(cols) &gt;= 2: ip = cols[0].get_text() port = cols[1].get_text() proxies.append(ip + ':' + port) return proxies # 示例使用的代理IP网站是 https://www.zdaye.com/ url = 'https://www.zdaye.com/' proxies = get_proxies(url) print(proxies) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3df3a9f72306b73229498c28b6e1ef18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9367f19ecc5d46f6d9dedcdcea6fd1fb/" rel="bookmark">
			LeetCode59. 螺旋矩阵 II（java实现，史上最详细教程，想学会的进！！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天来分享一下螺旋矩阵的解题思路及代码的实现。
题目描述如下：
首先拿到这道题，首先不要慌张，我们来仔细分析一下会发现并没有那么难。
首先看下边界的元素是1、2、3递增的，那么我们也许可以根据这一点先把边界的元素一个一个给加入到数组中。
具体思路如下：
我们看下面这个例子，我们创建一个4行4列的螺旋矩阵来进行分析
如果我们每次处理前3个数字，比如第一行我们处理1-3，然后继续处理列也就是4-6，然后处理7-9，这样可以发现一个规律就是我们每次都不对末尾的元素进行处理，这样遵循了循环不变原则。
然后处理完一圈之后一次对内部的13、14、15、16依次处理。
那么需要注意的是输入的n是奇数和偶数的处理还是有一定的区别。
完整的代码如下：
```java public static int[][] generateMatrix(int n) { int i=0; int j=0; int startx=0; int starty=0; int count=1;//用于1-16的赋值 int flag=1; int[][] arr=new int[n][n]; int k=n; while (k/2&gt;0){//控制循环的次数 //处理第一行 for (j=starty;j&lt;n-flag;j++){ //这里需要注意，行要为startx，如果行设置为i的话， // 由于执行了第4个for循环后，i指向了0，那么在第一轮while循环没有问 //题，但是会影响2、3。。。次while循环的赋值 arr[startx][j]=count;//每次赋值完之后记得对count进行++ count++; } for (i=startx;i&lt;n-flag;i++){ arr[i][j]=count; count++; } for (j=n-flag;j&gt;starty;j--){ arr[i][j]=count; count++; } for (i=n-flag;i&gt;startx;i--){ arr[i][j]=count; count++; } k-=2;//每次循环后k-2 /** * 当经过一次循环后，需要对startx、y、flag进行++，便于后续的while循环的赋值 */ flag++; startx++; starty++; } //如果输入的n为奇数将中间的值进行赋值。 if (n%2!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9367f19ecc5d46f6d9dedcdcea6fd1fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75bce1df0b3281ccea66785095ef4a3c/" rel="bookmark">
			vue2入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue2官方文档：安装 — Vue.js
1、安装 新建"vue"文件夹——&gt;新建vue1.html
直接用&lt;script&gt;标签引入vue：
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"&gt;&lt;/script&gt; tips:
CDN:一个网络加速的技术
完整代码如下：
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;vue学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 此时就已经引入成功了
2、vue的变量渲染 使用双括号(胡子)语法，就实现了文本渲染。
我们在绑值语法里可以写字符串、数字、布尔、表达式。
字符串、数字、布尔示例：
&lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt; {{message}} &lt;div&gt; {{num++}} &lt;!-- `{{num++}}` 表示使用 `num` 的当前值，然后再将 `num` 值加一； 而 `{{++num}}` 表示先将 `num` 的值加一，然后再使用新的值。 --&gt; &lt;/div&gt; &lt;div&gt; {{bool}} &lt;/div&gt; &lt;div&gt;{{bool?'a':'b'}}&lt;/div&gt; &lt;!--如果bool为true显示a，false显示b--&gt; &lt;/div&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.14/dist/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue({ el:'#app', data:{ message:'hello', num:1, bool:true } }) &lt;/script&gt; &lt;/body&gt; 显示结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75bce1df0b3281ccea66785095ef4a3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3209327e25f415d22909adce1dc1f90/" rel="bookmark">
			MIT_线性代数笔记：第 19 讲 行列式公式和代数余子式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 行列式公式 Formula for the determinant代数余子式 Cofactor formula 我们已经认识到了行列式的性质，应该推导出其公式了。 行列式公式 Formula for the determinant 行列式有如下三个性质：
det( I )=1。如果交换行列式的两行，则行列式的数值会反号。行列式是“矩阵的行”的线性函数。
从这三条性质可以推导出后续的七条性质，从这十个性质出发可以得到二阶方
阵的行列式公式：
通过性质 3 对 n 阶矩阵的行列式进行拆分，我们可以得到所有只包含 n 个非零元素的行列式，对于二阶行列式我们从 1 个拆分为 2 个，然后拆分成 4 个。而对于三阶矩阵我们从 1 个拆分成 3 个，然后拆分成 9 个，最后要拆分成 27 个。但最终这些行列式中有很大一部分等于 0。
每一个拆分出来的非 0 行列式都是在每行每列都有且只有一个元素，就如同置换矩阵的元素分布。应用性质 3 可以将元素从行列式中提出来，而置换矩阵的行列式值为+1 或者-1，因此可以给出行列式的公式。n 阶拆分矩阵非 0 行列式的个数的计算方法就如同计算置换矩阵的个数一样，第一行放置一个非 0 元素的位置有 n 个选择，第二行为 n-1 个……。最后得到共 n！个矩阵。
对于拆分得到的三阶矩阵，元素从上至下朝向右侧方向的，其行列式的数值为正，朝向左侧方向的则为负。但是这个规律只适用于三阶矩阵，不适用于高阶矩阵。
其中列标号（α, β, γ……ω）是列标号（1, 2, 3……n）的某个排列。比如说对于单位阵而言，只有α=1，β=2……ω=n 所得到的行列式为+1，其它都为零，所以单位阵的行列式为 1。
列标号取（4,3,2,1）得到第一个拆分行列式，符号为正，因为只要经过两次交换就能变为（1,2,3,4）。第二个为（3,2,1,4），因为只需交换一次就可变为正序，所以符号为负。因此本行列式为 0。 代数余子式 Cofactor formula 代数余子式是用较小的矩阵的行列式来写出 n 阶行列式的公式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3209327e25f415d22909adce1dc1f90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca48b4d9d2ccbc74172f92255f21325/" rel="bookmark">
			解决kindle返回不了主页的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图，想要出现红色框内的“&lt;-- 主页” 的图标，需要在当前kindle页面，点击绿色框的区域，注意是点击一下屏幕，不是从上往下滑动，轻点屏幕，就会出现“&lt;-- 主页” 的图标了，快去试试吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de374768e8325b3f7fbd775513ff6646/" rel="bookmark">
			浏览器触发下载Excel文件-Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1:引入maven
2:代码实现
3.导出通讯录信息到Excel文件 4.生成并下载Excel文件部分解释 1:引入maven 添加依赖：首先，在你的项目中添加EasyExcel库的依赖。你可以在项目的构建文件（如Maven的pom.xml）中添加以下依赖项： &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt; &lt;/dependency&gt; 2:代码实现 写入Excel文件：使用EasyExcel写入Excel文件非常简单。下面的示例演示如何将数据写入Excel文件： import com.alibaba.excel.EasyExcel; import com.alibaba.excel.write.metadata.style.WriteCellStyle; import com.alibaba.excel.write.metadata.style.WriteFont; import com.alibaba.excel.write.style.HorizontalCellStyleStrategy; import com.github.pagehelper.PageHelper; import com.github.pagehelper.PageInfo; public class ExcelWriterExample { public static void process(HttpServletResponse response,String fileName) throws IOException { PageHelper.startPage("1", "10"); PageInfo&lt;User&gt; userListInfo =getUserList(); // 定义数据列表 List&lt;User&gt; userList = userListInfo.getList(); WriteCellStyle headWriteCellStyle = new WriteCellStyle(); //设置背景颜色 headWriteCellStyle.setFillForegroundColor(IndexedColors.WHITE.getIndex()); //设置头字体 WriteFont headWriteFont = new WriteFont(); headWriteFont.setFontHeightInPoints((short) 13); headWriteFont.setBold(true); headWriteCellStyle.setWriteFont(headWriteFont); //设置头居中 headWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER); //内容策略 WriteCellStyle contentWriteCellStyle = new WriteCellStyle(); //设置 水平居中 contentWriteCellStyle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de374768e8325b3f7fbd775513ff6646/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7126980be56869e88a513e9b3f332aa/" rel="bookmark">
			实用又好用Mybatis-Plus版的EasyCode模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：插件下载 Plugins中搜索EasyCode,并且下载安装 2：模板编写 2.1：entity.vm.java模板 ##引入宏定义 $!{define.vm} ##使用宏定义设置回调（保存位置与文件后缀） #save("/entity", "DO.java") ##使用宏定义设置包后缀 #setPackageSuffix("entity") ##使用全局变量实现默认包导入 $!{autoImport.vm} import java.io.Serializable; import com.baomidou.mybatisplus.annotation.TableField; import com.baomidou.mybatisplus.annotation.TableId; import com.baomidou.mybatisplus.annotation.TableName; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; import lombok.Data; import lombok.EqualsAndHashCode; import lombok.experimental.Accessors; import lombok.Getter; import lombok.Setter; import com.baomidou.mybatisplus.extension.activerecord.Model; ##使用宏定义实现类注释信息 #tableComment("实体类") @Data @EqualsAndHashCode(callSuper = false) @TableName("$!{tool.hump2Underline($!{tableInfo.name})}") @ApiModel(value = "$!{tableInfo.name}", description = "$tableInfo.comment") public class $!{tableInfo.name}DO implements Serializable { private static final long serialVersionUID = $!tool.serial(); #foreach($column in $tableInfo.fullColumn) #if(${column.comment}) /** * ${column.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7126980be56869e88a513e9b3f332aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98c7c79fefdccb7568790eacedbbc884/" rel="bookmark">
			Python3，100行代码，写一段新年祝福视频，为新年喝彩。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新年祝福 1、引言2、代码示例2.1 思路2.2 介绍2.2.1 画布2.2.2 用法 2.3 实例 3、总结 1、引言 小屌丝：鱼哥， 这2023年马上就结束了， 是不是要表示表示。
小鱼：我也在思考这个事情。
小屌丝：这还需要思考？
小鱼：那可不，毕竟马上新年了，我不能草率啊。
小屌丝：那你准备怎么表示，表示多少，去哪表示啊？
小鱼：在C站一篇博文。
小屌丝：…
小鱼：不然呢，我还要写几篇啊。
小屌丝：…
小鱼：这个咋样。
小屌丝：…
小鱼：这表情，不太乐意啊
小屌丝：我还以为你能给会员卡充满呢。
小鱼：这不是你的事情嘛。
小屌丝：…
小鱼：我想好了，写一个新年祝福视频。
小屌丝：… 这压力给到我了。
小鱼： 嘿嘿~
2、代码示例 2.1 思路 其实这篇的思路，跟这篇《Python3，10行代码，写一个气球运行小游戏，再也不无聊了。》的思路差不多。
这里就不在赘述，如果不太了解，那直接跳转到这一篇，查看即可。
2.2 介绍 2.2.1 画布 1、画布的高宽及颜色：
turtle.screensize(canvwidth=None, canvheight=None, bg=None)，
canvwidth=None：宽canvheight=None：高bg=None： 背景色 2、画布像素及位置：
turtle.setup(width=0.5, height=0.75, startx=None, starty=None)，
width=“整数”，像素 ；width=“小数”，占据电脑屏幕比例height=“整数”，像素 ；height=“小数”，占据电脑屏幕比例startx, starty ：窗口坐标位置 2.2.2 用法 命令用法turtle.forward(distance)向当前画笔⽅向移动distance像素长度turtle.backward(distance)向当前画笔相反⽅向移动distance像素长度turtle.right(degree)顺时针移动degree°turtle.left(degree)逆时针移动degree°turtle.pendown()移动时绘制图形，缺省时也为绘制turtle.goto(x,y)将画笔移动到坐标为x,y的位置turtle.penup()提起笔移动，不绘制图形，⽤于另起⼀个地⽅绘制turtle.circle()画圆，半径为正(负)，表⽰圆⼼在画笔的左边(右边)画圆setx( )将当前x轴移动到指定位置sety( )将当前y轴移动到指定位置setheading(angle)设置当前朝向为angle⾓度home()设置当前画笔位置为原点，朝向东。dot( r )绘制⼀个指定直径和颜⾊的圆点 学习了turtle的基本用法，接下来，我们就要实践了。
2.3 实例 # -*- coding:utf-8 -*- # @Time : 2023-12-17 # @Author : Carl_DJ ''' 实现功能： 使用turtle绘制五彩气球，并写上新年祝福语 ''' import turtle as tu import random as ra import math #设置画板大小 tu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98c7c79fefdccb7568790eacedbbc884/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67dfa6c72b6784acb2ca39456849ac49/" rel="bookmark">
			医学影像知识（二）：医学影像常见数据预处理方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		医学影像常见数据预处理 医学影像数据分析过程图像去噪频域去噪方法（傅里叶变换，小波变换）空间域去噪方法（高斯滤波，算术均值滤波，中值滤波） 图像重采样图像增强直方图均衡化对比度拉伸 图像归一化 医学图像数据分析是研究生物标记物并验证其准确性的过程，就像警察追踪嫌疑人一样，根据特征来识别目标并确认身份。这过程包括筛选特征以及验证结论的正确性。
医学图像涵盖了病理图像、影像图像（如X光、CT扫描、MRI图像）和检验图像等。我们将重点介绍对影像图像的数据分析。比如，CT图像是由不同灰度构成的，医生通过观察图像上的异常特征来做出疾病诊断，比如肺癌病变通常呈现为肿块，具有特定的边缘特征。
不过，这些特征通常是肉眼观察得出的。我们可以利用工具来提取更多特征，因为提取的特征越多，我们获得的判断证据也越充分。获得特征后，我们可以进行各种分析，得出各种参数和数据，最终得出结果，如疾病类型、性质、良恶性等。因此，影像图像数据分析本质上就是特征分析的过程。
医学影像数据分析过程 不同的影像有不同的数据保存方式，其中医学影像主要为 dicom和nii格式。在图像的产生、传输和存储过程中都会不可避免地出现图像清晰度下降、对比度偏低和包含噪声等降质现象。因此我们需要进行图像预处理，即采用一些技术和方法优化图像的质量，为图像分析的后续过程打好基础。首先，为了看清医学影像组织需要根据文件中的窗宽窗位进行相应的调整，最后进行图像的预处理，包括图中提到的图像重采样、高斯过滤（去噪）、归一化处理等。那么我们详细介绍图像预处理的详细技术。
图像去噪 图像噪声就像普通照片上的颗粒点一样，它会影响图像的质量，给图像的内容带来一定的干扰。在原始医学图像中，大多数都包含噪声，这些噪声会显著影响医学图像的分析和处理，增加了对图像细节的识别和分析的难度。
因此，我们需要选择合适的图像去噪技术，以消除或减少图像中的噪声，从而降低对医学图像后续处理的不利影响。在医学图像去噪领域，平滑技术是目前最常用的技术，它包括频域去噪方法和空域去噪方法两大类别。
频域去噪方法（傅里叶变换，小波变换） 傅里叶变换
小波变换
空间域去噪方法（高斯滤波，算术均值滤波，中值滤波） 高斯滤波
算术均值滤波
中值滤波
在这里，我们将重点介绍一种常见的空域去噪方法，即中值滤波：
1.确定一个以某个像素为中心点的邻域。
2.将邻域中的像素按灰度级进行排序。
3.选择该组排序后的中间值作为输出像素值。
图像重采样
图像重采样 图像增强 图像增强是另一个重要的预处理步骤，它有助于改善图像的视觉质量和可分析性。以下是一些常见的图像增强技术：
直方图均衡化 直方图均衡化是一种用于增加图像对比度的方法。它通过重新分布图像的像素值，使得图像中的不同区域具有更均匀的像素分布。
对比度拉伸 对比度拉伸是一种用于增加图像对比度的简单方法。它可以通过拉伸图像的像素值范围来增强图像的细节。
图像归一化 图像归一化是确保图像具有一致的亮度和对比度，以便进行进一步的分析。这可以通过线性或非线性方法来实现，以使不同图像之间具有一致的可比性。
在医学影像领域，数据预处理是确保准确分析和诊断的关键步骤。通过适当的数据预处理，我们能够改善图像质量，减少噪声，增强对比度，并确保数据的一致性，从而为后续的医学图像分析提供可靠的基础。在将来的博客中，我们将更详细地讨论每个预处理步骤以及它们的具体实施方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03f18e0f8d9cc67c9aa5925dec893ad6/" rel="bookmark">
			Android排队预约系统(Java&#43;SqLite&#43;ZXing)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己写的排队预约系统，可改写，添加功能，如管理用户，查询排队人数等功能。(由于是选修课课设，所以写的比较粗糙)
使用方法：
1.使用Android studio导入项目。
2.使用gradle加载build.gradle.kts中的依赖。
3.数据库会在第一次运行时由程序自动创建，无需设置账号密码。
4.安装配置好虚拟机或用usb链接手机开启调试。
5.运行项目，自动生成app。
有问题请评论区问，我会看。
界面预览:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c019a4472e0017f4eedd3760f9fc81f7/" rel="bookmark">
			DAPLINK烧录M4内核单片机接线图（M3内核单片机不能进行烧录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DAPLINK可以选择只用SWDIO,SWCLK,GND即可（其他可以不用），本文基于DAPLINK烧录器增加了typeC口，6pin线和杜邦线，焊接DAPLINK后面的SWDIO,SWCLK,GND接口（自己使用的烧录器）：
DAPlink接线图：
TyeC接线图（左），引出来的线（SWCLK,SWDIO直接与MCU对应端口连接）
最后将TypeC的线引出来使用电烙铁将其与DAPlink焊接在一起，最后效果如下图所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b956eb2e721a11af6e7283dd25a42a4/" rel="bookmark">
			04-网络安全框架及模型-PDRRA模型(PDR2A)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
PDRRA模型（也可以叫PDR2A）
1 背景概述
2 工作原理
3 安全性判断
4 具体介绍
5 优势和局限性
PDRRA模型（也可以叫PDR2A） 1 背景概述 PDRRA模型是在原PDRR安全模型的基础上提出的，由Protection（防护）、Detection（检测）、Response （响应）、Recovery（恢复）、Auditing（审计）组成。PDRRA模型在PDRR模型的基础上增加了审计分析模块。
审计分析是利用数据挖掘方法对处理后的日志信息进行综合分析，及时发现异常、可疑事件，以及受控终端中资源和权限滥用的迹象，同时把可疑数据、入侵信息、敏感信息等记录下来，作为取证和跟踪使用，以确认事故责任人。通过审计分析，管理员可以参考审计结果对安全策略进行更新，提高系统安全性。
安全策略是整个内网安全监管系统的核心，包括安全防护策略、监控策略、报警响应策略、系统恢复策略、审计分析策略、系统管理策略，它渗透到系统的防护、检测、响应、恢复、审计各个环节，所有的监控响应、审计分析都是依据安全策略实施的。
PDR2A模型的提出是为了更好地指导组织开展信息安全管理工作，使其能够更好地识别和应对信息安全威胁，更好地保护信息资产的安全和完整性。
2 工作原理 PDRRA模型的原理是基于五个关键环节：防护（Protection）、检测（Detection）、响应（Response）、恢复（Recovery）和审计（Auditing）。下面我将详细介绍每个环节的原理：
防护（Protection）：防护是指采取各种措施来预防信息系统受到威胁和攻击。这包括建立安全策略、实施访问控制、加密通信、设备安全配置等。通过有效的防护措施，可以减少潜在的安全漏洞，提升系统的安全性。
检测（Detection）：检测是指监控和识别潜在的安全事件和威胁。这包括使用入侵检测系统（IDS）、网络流量分析、异常行为检测等技术手段，及时发现异常活动、入侵尝试或其他安全事件。检测可以帮助组织及早发现问题，并采取相应的应对措施。
响应（Response）：响应是指对检测到的安全事件和威胁作出及时反应。当发现安全事件时，需要立即采取适当的措施来控制和消除威胁。这可能包括隔离系统、封锁攻击源、更新防护措施等。响应的目标是减少损失并恢复系统的正常运行。
恢复（Recovery）：恢复是指在安全事件发生后，恢复受影响的系统和数据的完整性和可用性。这包括备份恢复、数据恢复、系统修复等操作。通过及时恢复操作，可以将受影响的系统和数据恢复到正常状态，减少停机时间和业务中断。
审计（Auditing）：审计是对信息系统的活动进行监视和记录，以确保合规性和追踪异常行为。通过审计分析，可以发现潜在的安全问题、检测安全事件，并确定责任人。审计结果还可以为安全策略的更新和改进提供依据，提高系统的安全性。
PDRRA模型通过综合应用这五个环节，形成一个完整的信息安全管理模型，帮助组织更好地管理和保护信息资产的安全。它强调了预防、检测、响应、恢复和审计等方面的综合性，使组织能够全面应对安全威胁和风险。
3 安全性判断 PDRRA模型通过多种方法来判断信息系统的安全性。下面是一些常见的判断方法：
风险评估：进行风险评估可以确定系统面临的潜在威胁和漏洞，并对其进行定量或定性评估。风险评估通常包括威胁分析、脆弱性评估和影响分析等，以确定系统的安全风险级别。
安全策略和控制规范：PDRRA模型强调建立和实施适当的安全策略和控制规范。这些策略和规范可以包括访问控制、身份验证、加密通信、设备配置要求等，以确保系统满足安全要求。
安全事件检测：通过使用入侵检测系统（IDS）、网络流量分析、异常行为检测等技术手段，可以监测和检测潜在的安全事件和威胁。这些检测工具和技术可以提供实时的安全监控和警报，帮助判断系统的安全性。
安全事件响应：当发生安全事件时，及时采取适当的响应措施可以减少损失并保护系统的安全性。根据安全事件的严重性和类型，采取相应的响应措施，如隔离系统、封锁攻击源、修复漏洞等。
审计分析：通过审计分析可以监视和记录系统的活动，发现潜在的安全问题和异常行为。审计可以帮助判断系统的安全性，并确定责任人。审计结果还可以为安全策略的更新和改进提供依据。
综合应用以上方法，PDRRA模型可以对信息系统的安全性进行评估和判断。这样的综合性方法可以更全面地了解系统的安全状况，并采取相应的措施来保护系统免受威胁和攻击。
4 具体介绍 防护（Protection）：
防护是指采取措施预防信息系统受到威胁和攻击。主要目标是减少潜在的安全漏洞，提升系统的安全性。
具体措施包括但不限于：
建立安全策略和规范：明确安全目标和要求，并制定相应的安全策略和操作规范。
实施访问控制机制：限制用户的权限和访问范围，确保只有授权人员能够访问敏感数据和系统资源。
使用加密技术：对敏感数据的传输和存储进行加密，防止数据在传输和存储过程中被窃取或篡改。
配置设备和系统的安全设置：例如设置防火墙、入侵防御系统、反病毒软件等，以减少系统受到攻击的风险。
提供员工的安全意识培训：向员工提供相关的安全培训，教育他们了解和遵守安全规定，同时提高其安全意识。
2.检测（Detection）
检测是指监控和识别潜在的安全事件和威胁。通过及时发现异常活动、入侵尝试或其他安全事件，可以采取相应的措施来控制和消除威胁。
常见的检测方法包括：
使用入侵检测系统（IDS）和入侵防御系统（IPS）：监控网络流量，识别可能的入侵行为并采取相应措施进行阻止。
异常行为检测：通过分析用户的行为模式和网络流量，识别不正常或异常的活动，及时报警。
分析日志文件和事件记录：对系统和网络的日志文件进行分析，发现潜在的安全问题和攻击迹象，以及其他异常活动。
3.响应（Response）
响应是指对检测到的安全事件和威胁作出及时反应。主要目标是减少损失并恢复系统的正常运行。
常见的响应措施包括：
隔离受感染的系统或网络：一旦发现有受感染的系统或网络，及时隔离，以防止攻击扩散。
封锁攻击源或关键漏洞：通过封锁攻击源IP地址、关闭关键漏洞等方式，限制攻击者的进一步活动。
更新防护措施和补丁：定期更新和升级防火墙规则、入侵检测系统、反病毒软件等防护措施，并及时应用系统和应用程序的安全补丁。
启动紧急响应计划：根据紧急情况启动事先制定的紧急响应计划，协调各个相关团队的行动，采取必要的紧急措施。
4.恢复（Recovery）
恢复是指在安全事件发生后，恢复受影响的系统和数据的完整性和可用性。主要目标是尽快将受影响的系统和数据恢复到正常状态，减少停机时间和业务中断。
具体措施包括：
进行备份恢复：定期进行数据备份，并在系统故障或受攻击后使用备份数据重建受损的系统。
进行数据恢复：对受损的数据进行修复或恢复，确保数据的完整性和可用性。
进行系统修复：重新配置和修复受影响的系统，以确保系统能够恢复到正常状态。
进行业务持续性计划（BCP）和灾难恢复计划（DRP）：制定和实施紧急情况下的业务恢复计划，确保业务能够快速恢复。
5.审计（Auditing）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b956eb2e721a11af6e7283dd25a42a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141d728d74e12a42486cb908e419ad99/" rel="bookmark">
			基于Phalcon的PHP开源知识付费系统，酷瓜云课堂v1.6.7 发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 更新内容 增加文章分类功能增加问题分类功能增加审核等批量功能增加若干业务插件埋点精简重构大量业务逻辑移除秒杀营销功能已发现的问题修复 系统介绍 酷瓜云课堂，依托腾讯云基础服务架构，采用C扩展框架Phalcon开发，GPL-2.0开源协议，致力开源网课系统，开源网校系统，开源知识付费系统，开源在线教育系统。
系统功能 实现了点播、直播、专栏、面授、问答、会员、积分等。
友情提示：
演示系统配置低（1Core，1G，1M 跑多个容器）切莫压测课程数据来源于网络（无实质内容）切莫购买管理后台已禁止数据提交，私密配置已过滤 桌面端演示：
前台演示后台演示 演示账号：100015@163.com / 123456 （前后台通用）
支付流程演示：
MySQL提升课程全面讲解MySQL架构设计（0.01元）Nginx入门到实践Nginx中间件（0.01元）数据库与中间件的基础必修课（0.02元） Tips: 测试支付请用手机号注册一个新账户，以便接收订单通知，以及避免课程无法购买
微信推送演示：
Tips: 请用手机注册一个新账号，用户中心 -&gt; 关注订阅，扫码关注公众号。之后的登录、购买、退款、直播、咨询等会有消息推送。
项目组件 后台框架：phalcon 3.4.5前端框架：layui 2.8.8全文检索：xunsearch 1.4.9即时通讯：workerman 3.5.22基础依赖：php7.3， mysql5.7， redis5.0 项目文档 运行环境搭建系统服务配置客户终端配置 意见反馈 码云平台官方社区 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d44b0ffb2c4b31bb5f20df7417f32065/" rel="bookmark">
			DAY10 指针(2)----指针与数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数组名 先看一个案例
在这个代码中，我们提取了数组的首字母的地址和数组名来进行打印，结果是这样的：
可以发现它们两个的地址是相同的，所以我们可以得出
在通常情况下，数组名表示的就是数组首元素(第⼀个元素)的地址。
再来看一个案例：
在这个代码中，我们打印sizeof(数组名)，结果是这样的：
理论上来说如果数组名是数组首元素的地址，那打印出来应该是4或8也就是一个元素所占的字节，但这里却是40。
别急，再看一个案例：
这里我们打印数组名和&amp;数组名，也就是取地址数组名，结果是这样的：
这里我们不看打印结果，直接看类型，可见一个是int[10]一个是int[10]* 也就说一个是数组一个是数组解引用。
所以除了通常情况下，还有两个例外：
• sizeof(数组名)，sizeof中单独放数组名，这⾥的数组名表示整个数组，计算的是整个数组的大小，单位是字节
• &amp;数组名，这里的数组名表示整个数组，取出的是整个数组的地址（整个数组的地址和数组首元素的地址是有区别的）
我们还可以通过另一个代码来更好理解第二个例外：
我们发现：
&amp;arr[0]和&amp;arr[0]+1相差4个字节，arr和arr+1 相差4个字节，是因为&amp;arr[0] 和 arr 都是首元素的地址，+1就是跳过⼀个元素。
但是&amp;arr 和 &amp;arr+1相差40个字节，这就是因为&amp;arr是数组的地址，+1 操作是跳过整个数组的。
2.使用指针访问数组 既然arr是数组的首元素的地址，那么它赋值给p时，其实可以认为p等价于arr。所以arr[i]也就等价于p[i]。
我们需要知道的一个很重要的事实是：
数组其实就是指针，它的底层含义就是地址。
从1中我们也得知数组名就是其首元素地址。
所以其实满足这样的关系式：
arr[i]==*(arr+i)==*(i+arr)==i[arr]（满足交换律）
数组元素的访问在编译器处理的时候，也是转换成首元素的地址+偏移量求出元素的地址，然后解引用来访问的。
3.一维数组传参本质 数组传参本质上传的是数组首元素的地址。sz1是整个数组元素的个数（因为它是直接打印主函数中的数组元素个数）；
而sz2是函数中的数组元素的个数，但这里其实取的只是首元素，也就只有一个了。
函数形参的部分是使用指针变量来接收首元素的地址。那么在函数内部我们写 sizeof(arr) 计算的是⼀个地址的大小（单位字节）而不是数组的大小（单位字节）。
正是因为函数的参数部分是本质是指针，所以在函数内部是没办法求数组元素个数的。
4.二级指针/多级指针 指向某一个变量的地址就是指针，当这个变量本身不是指针时，那么这里的指针叫做一级指针。
我们知道，指针变量是指向某一类型数据的内存地址的变量，它作为变量的本质是不会改变的。
那么只要是变量就会有地址。
所以指针变量的地址就叫做二级指针。它是指向指针的指针。
那么如果我们要通过pp来找到或者改变a变量，就要解引用两次。
既然二级指针是指向指针的指针，那么肯定就有指向二级指针的指针，被称为三级指针，还有四级指针五级指针...它们都被统称为多级指针。
5.指针数组 这个名词的主体是数组，所以顾名思义：
指针数组就是数组内所有元素都是指针的数组，也就是用来存放指针的数组。 对比两个数组，它们的区别在于一个数组内的元素类型是整型int，另一个是整形指针int*。
既然指针数组的每一个元素都是地址，那么元素的数量也就是数组内指向的地址的数量。
6.指针数组与数组指针 指针数组是元素是指针的一类数组，它的本质是数组。
数组指针是指向某个数组的指针，它的本质是指针。
7.指针数组与普通数组的联系 1. 数据类型不同 普通数组的数据类型是普通的类型，但指针数组的数据类型实际上是普通的类型再加上*号，用来表明该数据是指针。
2. 存储的内容不同 普通数组直接存储数据的值，而指针数组存储的是指针，即存储了数据的内存地址。
3. 访问方式 普通数组可以直接通过下标访问数组中的元素，而指针数组需要通过指针来访问数组中的元素，即先获取指针，然后通过指针访问数据。
在这里我们可以思考：是否可以用指针数组来模拟实现二维数组呢？毕竟只需要获取指针就可以访问数据，也就可以模拟实现二维数组了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d44b0ffb2c4b31bb5f20df7417f32065/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3083e514a34d954b741f92b86bedf67c/" rel="bookmark">
			DAY11 不同指针变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字符指针变量及其他简单类型指针变量 字符的类型是char；
字符指针的类型是char*
表达方式如下：
int main() { char ch = 'w'; char *pc = &amp;ch; *pc = 'w'; return 0; } 这是最简单也是最普遍的表达方式。
但是还有另外一种：
char* pstr = "hello bit."; 在这行代码中，貌似将hello bit.这个字符串放进了字符指针变量pstr中，但事实真的如此吗？
实际上，它的本质是把这个字符串的首字符h的地址放进了pstr中 我们会发现这个概念貌似似曾相识，没错，它跟数组指针的存放方式相差无几。
可以把字符串想象成一个字符数组，因为数组就是地址，取字符串的地址也就可以相当于取数组
当常量字符串出现在表达式中时候，它的值也就是第一个字符的地址。
但是需要注意的是：内容相同的常量字符串只会保存一份地址：
const char *str3 = "hello bit."; const char *str4 = "hello bit."; 这两个不同的指针变量实际上指向的是同一个常量字符串hello bit.
所以这里的str3==str4。
事实上，
各种简单类型例如整型int，字符型char等的指针变量事实上意义和用法都大同小异：
整型指针变量：用来存放整型变量的地址，
int a = 100; int *p_a = &amp;a; 字符指针变量：用来存放字符型变量的地址， char b="hello world."; cahr *p_b = &amp;b; 浮点指针变量：用来存放浮点型变量的地址，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3083e514a34d954b741f92b86bedf67c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7f46f49e4f5dfec761fc3321477aabf/" rel="bookmark">
			02-网络安全框架及模型-PPDR模型（P2DR）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
PPDR模型（也可以叫P2DR）
1 背景概述
2 工作原理
3 安全性判断
4 具体介绍
5 优势和局限性
PPDR模型（也可以叫P2DR） 1 背景概述 PPDR模型的出现源于对日益严峻的网络安全威胁的需求。随着信息技术的快速发展和互联网的普及，网络安全问题变得越来越重要。各种类型的网络攻击和威胁不断涌现，给个人、组织和国家带来了巨大的风险和损失。
为了有效应对不断变化的网络安全环境，人们意识到需要一种综合性的方法来管理和保护网络安全。因此，PPDR模型应运而生。它将策略、防护、检测和响应四个要素结合起来，提供了一个全面的框架来处理网络安全问题。
背景包括以下几个方面：
威胁的加剧：随着网络技术的迅猛发展，黑客、病毒、勒索软件等网络威胁的数量和复杂性不断增加。传统的安全防护手段已经无法满足对抗这些新型威胁的需求，因此需要一种更加综合和全面的方法。
业务的数字化转型：许多组织和企业正在进行数字化转型，依赖于网络和信息技术来支持业务运营。这使得网络安全问题对他们的核心业务产生了更大的影响，同时也增加了网络攻击的目标。
法规和合规要求：随着对数据隐私和信息安全保护的关注增加，许多国家和地区都出台了相关的法规和合规要求。组织需要确保其网络安全措施符合这些要求，并能够有效应对安全事件。
技术的进步：新的安全技术和工具的不断涌现，为构建综合性的网络安全管理模型提供了可能。策略、防护、检测和响应等方面的技术不断发展，为网络安全提供了更加全面和高效的解决方案。
综上所述，PPDR模型的诞生是为了应对日益严峻的网络安全挑战，通过综合考虑策略、防护、检测和响应四个要素，提供一种全面的网络安全管理方法。它可以帮助组织建立完善的安全体系，预防和应对网络安全威胁，保护关键信息和业务的安全。
2 工作原理 PPDR模型的原理是将策略、检测、防护和响应四个要素结合起来，形成一个综合性的网络安全管理框架。其原理如下：
策略（Policy）：制定和实施合适的网络安全策略。这包括确定访问控制政策、密码策略、数据分类和保护政策等。策略定义了组织对网络安全的期望和要求，为其他要素提供指导。
防护（Protection）：采取各种措施来防止网络安全威胁造成的损害。这包括使用防火墙、加密通信、安全认证、漏洞管理和访问控制等技术和方法，以减轻攻击的影响并提高网络的安全性。
检测（Detection）：使用各种技术和工具来检测网络安全威胁的存在和活动。入侵检测系统（IDS）、入侵防御系统（IPS）、行为分析工具等可以监测网络上的异常行为和攻击行为，及时发现潜在的安全问题。
响应（Response）：在发生安全事件时，快速响应并采取适当的行动。这包括隔离受感染的系统、恢复数据、修复漏洞、收集证据和通知相关方等。有效的响应可以降低损失，并帮助组织从安全事件中恢复过来。
PPDR模型通过将策略、防护、检测和响应四个要素有机地结合起来，提供了一个全面的网络安全管理方法。它不仅强调预防和检测网络威胁，还强调及时采取防护和响应措施来应对安全事件。这种综合性的管理方法有助于组织建立健全的安全策略和流程，提高网络的安全性和应对能力。
3 安全性判断 PPDR模型判断网络安全性的方法主要依赖于以下几个方面：
策略评估：通过评估组织的网络安全策略，包括访问控制政策、密码策略、数据分类和保护政策等，判断策略的合理性和有效性。这可以包括检查策略是否符合法规和合规要求，是否与组织的风险承受能力相匹配，并且是否考虑了各种安全威胁和应对措施。
防护效果评估：通过评估已实施的防护措施的有效性和适用性，判断网络的安全性。这可以包括检查防火墙、加密通信、安全认证、漏洞管理和访问控制等措施的配置和运行情况，以及它们对各种安全威胁的抵御效果。
检测分析：通过监测和分析网络上的异常行为、攻击行为以及潜在的安全威胁，判断网络的安全性水平。入侵检测系统（IDS）、入侵防御系统（IPS）等工具可以帮助检测和分析网络中的安全事件，提供关于攻击类型、攻击来源和攻击影响等信息，从而评估网络的安全状况。
响应能力评估：通过评估组织在安全事件发生时的响应能力和措施，判断网络的安全性。这可以包括评估组织的应急响应计划、安全事件管理流程以及与相关方的沟通协调能力，以确保在安全事件发生时能够快速响应并采取适当的行动。
综合以上几个方面的评估，PPDR模型可以判断网络的安全性，并提供有针对性的建议和改进措施，以提高网络的安全水平。这种综合性的评估方法有助于组织全面了解自身的安全状况，识别潜在的安全风险，并采取相应的措施来保护网络安全。
4 具体介绍 策略（Policy）
网络安全策略是指制定并实施一系列政策、规范和措施，以保护组织的信息系统和数据免受潜在的安全威胁。
策略制定需要考虑以下几个方面：
风险评估：识别和评估组织所面临的安全风险，包括内部和外部威胁，以便制定相应的安全策略。
合规要求：确保网络安全策略符合适用的法规、标准和合规要求。
访问控制：制定明确的访问控制政策和权限管理机制，限制未经授权的用户访问敏感信息。
员工培训：提供网络安全意识培训，使员工了解安全风险和最佳实践，并促使他们采取正确的安全措施。
2.防护（Protection）
网络安全防护是指采取各种措施来保护网络免受潜在的安全威胁。
以下是一些常见的防护方法：
防火墙：通过监控和过滤网络流量，限制未经授权的访问和防止恶意行为。
加密通信：使用加密技术保护敏感数据的传输和存储，确保数据安全性和机密性。
访问控制：实施适当的身份验证、授权和权限管理机制，只允许授权用户访问敏感资源。
恶意软件防护：使用反病毒软件和恶意软件检测工具来防止恶意软件的感染和传播。
3.检测（Detection）
网络安全检测是指使用各种技术和工具来监测网络活动，识别异常行为和安全威胁。
以下是一些常见的检测方法：
入侵检测系统（IDS）：监测网络流量，识别可能的入侵行为和攻击。
入侵防御系统（IPS）：在检测到入侵行为时采取主动防御措施，如阻止恶意流量。
日志分析：对网络设备和系统的日志进行分析，以识别异常活动和潜在的安全问题。
漏洞扫描：扫描网络和系统以发现潜在的漏洞，及时修补以减少攻击面。
4.响应（Response）
网络安全响应是指在发生安全事件时，及时采取行动以限制损害并恢复正常运行。
以下是一些常见的响应措施：
应急响应计划：制定和实施应急响应计划，包括明确的责任分工、沟通渠道和紧急恢复流程。
漏洞修补：及时修补系统和应用程序中发现的漏洞，以减少攻击的可能性。
数据恢复：备份关键数据，并建立有效的数据恢复机制，以便在数据丢失或损坏时能够快速恢复。
安全事件调查：收集和分析有关安全事件的证据，以确定攻击来源和行为，并采取适当的法律行动。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7f46f49e4f5dfec761fc3321477aabf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464ac49ca3025130d805c0a5d8be8550/" rel="bookmark">
			Unity中URP下的顶点偏移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、实现思路二、实现URP下的顶点偏移1、在顶点着色器中使用正弦函数，实现左右摇摆的效果2、在正弦函数的传入参数中，加入一个扰度值，实现不规则的顶点偏移3、修改正弦函数的振幅 A，让我们的偏移程度合适4、修改正弦函数的 ω 来调节周期，调节偏移频率5、对其 x 也做同样的偏移(该效果根据个人喜好添加)6、在属性面板定义一个四维变量 用来控制 正弦的振幅 和 周期 三、测试代码 前言 在上篇文章中，我们实现了URP下的半透明效果。
Unity中URP下的半透明效果实现 在这篇文章中，我们实现一下像鬼魂一样的顶点偏移效果。
一、实现思路 在顶点着色器中，对模型本地空间坐标在转化成齐次裁剪坐标前，进行赋值修改
y = A sin(ωx + φ) + B 二、实现URP下的顶点偏移 1、在顶点着色器中使用正弦函数，实现左右摇摆的效果 v.vertexOS.z += sin(_Time.y);
2、在正弦函数的传入参数中，加入一个扰度值，实现不规则的顶点偏移 这里用模型顶点本地空间下的 y 值 作为扰度值
v.vertexOS.z += sin(_Time.y + v.vertexOS.y);
3、修改正弦函数的振幅 A，让我们的偏移程度合适 在图形计算器中，看一下效果
v.vertexOS.z += 0.3 * sin(_Time.y + v.vertexOS.y);
4、修改正弦函数的 ω 来调节周期，调节偏移频率 在图形计算器中，看一下效果
v.vertexOS.z += 0.3 * sin((_Time.y + v.vertexOS.y)*6);
5、对其 x 也做同样的偏移(该效果根据个人喜好添加) v.vertexOS.x += 0.3 * sin((_Time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/464ac49ca3025130d805c0a5d8be8550/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6719dec53501c6a7e3595f55a490abee/" rel="bookmark">
			position定位在实际项目中的便利布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码 页面效果 主页面页面test1 &lt;template&gt; &lt;div class="test1"&gt; &lt;div class="mapView" @click="print('map')"&gt;map&lt;/div&gt; &lt;test2&gt;&lt;/test2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import test2 from "./test2.vue"; export default { components: { test2 }, data () { return { } }, methods: { print(code){ alert(code) } } } &lt;/script&gt; &lt;style lang="less" scoped&gt; .mapView { position: absolute; z-index: 0; width: 48%; height: calc(90% ); left: 26%; top: 9%; background: rgba(255, 0, 0, .1); } &lt;/style&gt; 子组件test2 &lt;template&gt; &lt;div class="test2"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6719dec53501c6a7e3595f55a490abee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97957df72bccd7fcfcef58d2c17294aa/" rel="bookmark">
			EasyExcel导入excel文件解析日期格式数据出现偏差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Excel日期字段值： 7:00:00
解决方案：
增加 @DateTimeFormat("HH:mm")
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3573fc22cb55e1760db41f1e79bb5031/" rel="bookmark">
			Object.defineProperty
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 直接在一个对象上定义一个新属性，或者修改一个已经存在的属性
Object.defineProperty(obj,prop,desc)
let person = { name: '码农' age: 18 } Object.defineProperty(person,'sex',{value: '男'}) console.log(person) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a951ac5ff5038c64fbcdac08eae4dcc9/" rel="bookmark">
			华为OD机试真题 2023 B &#43; 2023 C&amp;D 卷（JAVA&amp;JS&amp;Python&amp;C&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 华为机试题库已于11月8号由2023 B卷 切换为 2023 C&amp;D 卷 C&amp;D卷区Java、JS版地址 →→→ 华为OD机试真题2023C&amp;D卷（JAVA&amp;JS）
(需要单独订阅）C&amp;D卷区Python、C++版地址 →→→ 华为OD机试真题2023C&amp;D卷（Python&amp;C++）
C&amp;D卷持续更新中。。。
各位同学如果收到的是A卷则刷下面的题，如果收到的是B卷则去B卷区刷题 B卷区地址 →→→ 华为OD机试真题2023 B卷（JAVA&amp;JS） 华为机试有三道题目，第一道和第二道属于简单或中等题，分值为100分，第三道为中等或困难题，分值为200分。总分为400分，150分钟考试时间。之前通过为150分，现在好像分数提高了，大家不要太大意，一定要多刷题，争取拿高分，毕竟分数越高评级越高，工资也就越高。OD的工资待遇还是很可观的15K-30K*14-16，希望大家努力（肺腑之言） ★★★很多题博主都发布了获得【满分】同学的算法，大家可以参考参考。有些题的满分题解可能无法通过自己的部分测试用例，不必纠结，以满分为主。 部分无法获取满分答案的题目，博主也会提供尽可能多的真实测试用例来给大家避坑，让大家尽可能的获取高分，为后面的薪资谈判提供筹码！！！
本栏准备了90+ 道机试真题，全刷完应该就十拿九稳了！大家加油！！！
每道题我都有些自己的解题思路，帮助大家更好的理解题意和代码。
基础题： 序号题目知识点分值1【满分】猜字谜字符串1002【满分】木板数组1003【满分】查找重复代码字符串1004【满分】查找单入口空闲区域递归、DFS搜索、数组1005【满分】单词倒序字符串1006【满分】打印文件队列1007【满分】对称字符串字符串、递归1008【满分】分界线字符串、排序1009【满分】关联端口组合并set、数组、递归10010【满分】货币单位换算字符串、数学10011【满分】获得完美走位字符串、滑窗10012【满分】简单的自动曝光数组10013【满分】日志采集系统数组10014【满分】数组的中心位置数组、前缀和10015【满分】通信误码滑窗10016网上商城优惠活动（一）贪心、数组、排序10017【满分】开心消消乐深度搜索、广度搜索10018【满分】获取最大软件版本号字符串、排序10019【满分】寻找链表的中间结点链表、数组10020【满分】最小的调整次数栈、队列10021【满分】字符串解密数组、字符串、排序10022【满分】投篮大赛字符串10023【满分】任务总执行时长数组、递归10024【满分】找数字数组10025【满分】整理扑克牌贪心、排序10026【满分】箱子之形摆放数组10027【满分】异常的打卡记录数组、字符串10028【满分】最左侧冗余覆盖子串字符串10029【满分】最多提取子串数目字符串、统计10030【满分】找出通过车辆最多颜色数组、滑窗10031【满分】优秀学员统计统计、排序10032【满分】租车骑绿道双指针、数组、排序10033【满分】相同数字的积木游戏1数组10034【满分】工作安排动态规划10035【满分】预定酒店排序10036【满分】学校的位置数组、排序10037【满分】寻找密码字符串10038【满分】寻找关键钥匙字符串、排序10039【满分】查找充电设备组合贪心、回溯10040【满分】知识图谱新词挖掘1滑窗10041【满分】静态代码扫描服务数学10042【满分】不爱施肥的小布二分查找10043【满分】AI处理器组合数组10044【满分】新员工座位安排系统数组、滑窗10045【满分】光伏场地建设规划数组10046【满分】微服务的集成测试深度搜索10047【满分】字符串重新排序字符串、排序10048【满分】MVP争夺战深度搜索10049贪心的商人贪心10050【满分】核酸检测人员安排动态规划100 进阶题： 序号题目知识点分值1【满分】不含101的数深度搜索、二叉树2002【满分】取出尽量少的球二分法2003【满分】最多等和不相交连续子序列贪心2004【满分】Excel单元格数值统计数组、递归、数学2005【满分】寻找符合要求的最长子串map2006【满分】分奖金数组2007【满分】计算至少需要多少个快递主站点递归2008【满分】基站维修工程师深度搜索2009【满分】数字加减游戏广度搜索20010【满分】最大数字数组、单调栈20011【满分】最差产品奖滑窗20012【满分】去除多余空格字符串、数组20013【满分】统计差异值大于相似值二元组个数进制转换、数组20014【满分】最优资源分配数组、贪心20015【满分】最少数量线段覆盖排序、贪心20016【满分】区间连接器数组、排序、滑窗20017【满分】机房布局数组20018快递投放问题map20019【满分】优雅数组双指针、数组、滑窗20020【满分】组装新的数组回溯、数组20021上班之路深度搜索、广度搜索20022【满分】区块链文件转储系统滑窗20023【满分】快速开租建站深度搜索20024【满分】字母组合回溯20025【满分】机器人活动区域深度搜索、广度搜索20026【满分】寻找相似单词字符串、排序20027【满分】递增字符串字符串、贪心20028【满分】硬件产品销售方案深度搜索、数组20029【满分】组合出合法最小数数组、排序20030【满分】云短信平台优惠活动动态规划、数组、贪心20031【满分】统计匹配的二元组个数数组20032【满分】狼羊过河回溯、贪心20033【满分】计算网络信号数组、广度搜索20034【满分】天然蓄水库双指针20035【满分】查找树中元素深度搜索20036【满分】红黑图数组、枚举20037【满分】Linux发行版的数量深度搜索、广度搜索、并查集20038【满分】信号发射和接收数组、单调栈20039【满分】垃圾信息拦截数组、逻辑20040【满分】简单的解压缩算法队列20041【满分】任务混部数学20042士兵过河II排序20043几何平均值最大子数组滑窗20044【满分】统一限载货物数最小值二分法、回溯20045【满分】最多几个直角三角形递归、深度搜索20046寻找核酸检测点数学20047最佳对手数组20048服务中心的最佳位置二分法、双指针20049单核CPU任务调度队列、优先级队列200 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a498ac1557c58a7bcc49073593874a10/" rel="bookmark">
			操作系统实验——移动头磁盘调度算法模拟实现与比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实验目的
​ 理解并掌握主要的移动头磁盘调度算法的基本设计思想和编程实现要旨。
2、实验内容
​ 利用标准 C 语言，编程设计与实现关于移动头磁盘调度的先来先服务调度算法（FCFS）、最短寻道时间优先调度算法（SSTF）、电梯调度算法（SCAN）、循环式单向电梯调度算法（CSCAN）、双队列电梯调度算法（FSCAN），并随机发生一组磁盘访问事件（磁道号）序列，开展有关算法的测试及性能比较。
3、开发环境
​ Vs 2021+Windows操作系统
4、算法流程和实现方法
FCFS（先来先服务）
关键数据结构： 仅需要请求队列即可，按照请求顺序进行处理。 算法流程： 请求按照到达的顺序依次处理。磁头从当前位置移动到下一个请求所在的磁道。移动完成后，继续处理下一个请求，直至队列中的所有请求被满足。 SSTF（最短寻道时间优先）
关键数据结构： 请求队列，当前磁头位置。 算法流程： 每次选择离当前磁头位置最近的请求来处理。算法优先处理离当前磁头最近的磁道，最大限度地减少寻道时间。该算法可能导致某些请求长期等待，产生"饥饿"问题。 SCAN（扫描算法）
关键数据结构： 请求队列，当前磁头位置。 算法流程： 磁头按照一个方向（通常是向某一方向移动）扫描所有请求。当达到最边缘时，方向改变并继续扫描，而不返回到最初的位置。这个算法可能导致某些磁道长期无法被访问到（产生"电梯"效应）。 CSCAN（循环扫描算法）
关键数据结构： 请求队列，当前磁头位置。 算法流程： 类似于SCAN，但是在到达最边缘后，直接回到另一端而不是返回最初的位置。这样做有助于减少某些磁道长期无法访问的情况，减少"电梯"效应。 FSCAN（双重扫描算法
关键数据结构： 两个请求队列，分别为当前进行的队列和等待的队列。 算法流程： 将所有请求分为两个队列，在处理当前队列的同时，后续请求进入等待队列。当前队列处理完毕后，切换到等待队列处理请求。这种方法减少了某些请求长时间等待的情况，减轻了"饥饿"和"电梯"效应。 5、技术难点及解决方案
算法效率与性能
难点：算法的效率和性能是关键指标，但不同算法在不同场景下的表现可能不同。
解决方案：进行实际测试和性能评估，比较不同算法在不同数据集和工作负载下的表现。根据实验结果优化算法选择，或者结合多种算法实现智能调度机制。
算法的正确性
难点：确保算法的正确性和稳定性，避免出现错误和异常情况。
解决方案：进行严格的测试和验证，针对各种边界条件和极端情况对算法进行全面测试，确保算法在各种情况下都能正确运行并且表现稳定。
6、运行截图
性能比较：
FCFS：
优点：简单易实现。缺点：可能会导致平均寻道时间较长，因为它忽略了寻找最优路径的可能性。 SSTF：
优点：最小化了磁头移动距离，平均寻道时间较短。缺点：可能产生"饥饿"问题，某些请求长时间等待。 SCAN：
优点：减少了某些磁道长期无法访问的情况。缺点：可能导致某些请求长时间等待，产生"电梯"效应。 CSCAN：
优点：减少了某些磁道长期无法访问的情况。缺点：与SCAN类似，可能产生长时间等待的情况。 FSCAN：
优点：减轻了"饥饿"和"电梯"效应，提高了公平性。缺点：实现相对复杂。 7、源代码：
#define _CRT_SECURE_NO_WARNINGS 1 #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;time.h&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; using namespace std; const int maxRightValue = 199;//磁头移动的最右边界值 const int minLeftValue = 0;//磁头移动的最左边界值 vector&lt;int&gt; FSCAN_SHOW;//存放FSCAN_SHOW算法的访问顺序 void getRandomNumber(vector&lt;int&gt;&amp; randValue, int&amp; pos) { for (int i = 0; i &lt; 100; i++) randValue.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a498ac1557c58a7bcc49073593874a10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5dc02a8bd71a4730b4dcfcb558ffcfa/" rel="bookmark">
			leetcode-两数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。
1.方法1 双重循环笨方法
1.外层循环控制所有数
2.内层循环，从外层循环数开始，依次往后遍历，判断两数之和是否等于target
public static int[] twoSum1(int[] nums,int target){
if(nums.length&lt;2){ return null; } for (int i = 0; i &lt;nums.length ; i++) { for (int j = i+1; j &lt;nums.length ; j++) { if(nums[i]+nums[j]==target){ return new int[]{i,j}; } } } return null; } 2.Map解法 map中存放我们遍历的数的值和下标
每次用target-当前遍历数然后去map的key过滤，如果存在说明map的key所对应的下标和当前遍历数的下标就是结果
public static int[] twoSum(int[] nums,int target){
if(nums==null||nums.length&lt;2){
return null;
}
Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5dc02a8bd71a4730b4dcfcb558ffcfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da4bda609b308826f35687355042988/" rel="bookmark">
			学习使用DDP: DistributedDataParallel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 “DistributedDataParalled” 是Pytorch中用于分布式训练的模块，相较与比较老的DataParallel更高效，易用（我在使用DataParallel时经常遇到参数和数据没有在一块卡的报错情况，非常烦人），简单说DP是一进程多线程，DDP是多进程。它允许在多个GPU甚至多个节点上并行，在每个GPU上分发参数并建立模型副本。每个进程都会加载不同的数据，DDP会自动处理跨GPU的梯度同步，每个GPU上的模型都会在自己的数据上进行前向反向传播，然后通过梯度同步机制更新模型参数。 名词定义 WORLD_SIZE:总进程数量，通常每个进程都会被分配一个唯一的 rank，而 world_size 就是所有进程的总数量。MASTER_ADDR 和 MASTER_PORT：这两个环境变量用于指定主进程的地址和端口号。在分布式训练中，主进程通常用于协调其他进程的工作。LOCAL_RANK 和 LOCAL_SIZE: 这两个环境变量是 torch.distributed.launch 工具特有的，用于指定当前进程在本地节点上的 local_rank 和节点上 GPU 的总数量 local_size。RANK 和 WORLD_SIZE（对于 torch.multiprocessing）: 在使用 torch.multiprocessing 进行分布式训练时，RANK 和 WORLD_SIZE 是用于指定进程全局排名和总进程数量的环境变量。 具体步骤 初始化分布式环境 import torch.distributed as dist # 在 torch.distributed.launch 中设置 local_rank 和 rank local_rank = int(os.environ['LOCAL_RANK']) #这里的local_rank相当于告诉程序这是第几个进程 rank = int(os.environ['RANK']) # 初始化分布式环境 dist.init_process_group(backend='nccl', init_method='tcp://localhost:23456', world_size=world_size, rank=rank) # 使用 local_rank 指定当前进程在本地节点上的 GPU 设备 torch.cuda.set_device(local_rank) device = torch.device("cuda", local_rank) 这里我的理解是：在命令行中通过torch.distributed.launch启动了多个进程，每个进程都运行main.py, 同时通过分配local_rank来识别每个进程。 2.通过torch.nn.parallel.DistributedDataParallel定义模型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da4bda609b308826f35687355042988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/775bb358f6d569d17a1a7896018f97d3/" rel="bookmark">
			【具身智能评估9】Open X-Embodiment: Robotic Learning Datasets and RT-X Models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文标题：Open X-Embodiment: Robotic Learning Datasets and RT-X Models
论文作者：–
论文原文：https://arxiv.org/abs/2310.08864
论文出处：–
论文被引：–（12/18/2023）
论文代码：https://github.com/google-deepmind/open_x_embodiment
项目主页：https://robotics-transformer-x.github.io/
Abstract 在不同数据集上训练的大型高容量模型在高效处理下游应用方面取得了显著的成功。在从 NLP 到计算机视觉等领域，这导致了预训练模型的整合，通用预训练骨干成为许多应用的起点。机器人技术能否实现这种整合？传统的机器人学习方法是为每种应用、每个机器人甚至每个环境训练一个单独的模型。我们能否训练出 “通用型” X-robot 策略，使其能有效地适应新的机器人、任务和环境？在本文中，我们提供了标准化数据格式和模型的数据集，以便在机器人操纵的背景下探索这种可能性，同时还提供了有效 X-robot 策略的实验结果。我们汇集了 21 家机构合作收集的 22 种不同机器人的数据集，展示了 527 种技能（160266 项任务）。我们的研究表明，在这些数据基础上训练出来的大容量模型（我们称之为 RT-X）可以利用来自其他平台的经验，实现正迁移并提高多个机器人的能力。更多详细信息，请访问项目网站 https://robotics-transformer-x.github.io/。
I. INTRODUCTION 从机器学习和人工智能的最新进展中得到的一个重要启示是，通过提供通用的预训练模型，从广泛多样的数据集中进行大规模学习，可以使人工智能系统具备能力。事实上，通常在大型、多样化数据集上训练的大规模通用模型，其性能往往优于在较小但更具任务针对性的数据集上训练的狭义目标模型。例如，在从网络上抓取的大型数据集上训练的开放词汇图像分类器（如 CLIP [1]）往往优于在更有限的数据集上训练的固定词汇模型，而在海量文本语料库上训练的大型语言模型 [2, 3] 往往优于只在狭窄的特定任务数据集上训练的系统。越来越多的情况是，处理特定狭窄任务（如视觉或 NLP）的最有效方法是调整通用模型。然而，这些经验很难应用到机器人领域：任何单一的机器人领域都可能过于狭窄，虽然计算机视觉和 NLP 可以利用从网络上获取的大型数据集，但机器人交互领域却很难获得类似的大型、广泛数据集。即使是最大规模的数据收集工作，最终得到的数据集在规模和多样性上仍然只是视觉（5-18M）[4, 5]和 NLP（1.5B-4.5B）[6, 7]基准数据集的一小部分。也许更重要的是，这些数据集在某些变化轴上仍然很狭窄，要么只关注单一环境、单一物体集，要么只关注狭窄的任务范围。我们如何才能克服机器人学中的这些挑战，将机器人学习领域推向在其他领域取得巨大成功的那种大数据体系？
受在不同数据上对大型视觉或语言模型进行预训练可实现通用化的启发，我们认为， 训练可通用的机器人策略这一目标需要进行 X-embodiment 训练，即使用来自多个机器人平台的数据。虽然每个单独的机器人学习数据集可能过于狭窄，但所有这些数据集的联合能更好地覆盖环境和机器人的变化。学习可通用的机器人策略需要开发能够利用 X-embodiment 数据的方法，挖掘来自许多实验室、机器人和环境的数据集。即使这些数据集目前的规模和覆盖范围不足以达到大型语言模型所展示的令人印象深刻的泛化结果，但在未来，这些数据的联合有可能提供这种覆盖范围。正因为如此，我们认为，在当前的关键时刻，对 X-embodiment 机器人学习的研究至关重要。
根据这一原理，我们的工作有两个主要目标：
1）证明根据来自多个不同机器人和环境的数据训练的策略可以实现正向增益，比仅根据来自每个评估设置的数据训练的策略获得更好的性能。2）为机器人界提供数据集、数据格式和模型，以促进未来对 X-embodiment 模型的研究。 我们的工作重点是 机器人操纵（robotic manipulation）。
针对目标（1），我们的经验性贡献是证明了最近的几种机器人学习方法，只需极少的修改，就能利用 X-embodiment 数据并实现正迁移。具体来说，我们在 9 个不同的机器人操纵器上训练 RT-1 [8] 和 RT-2 [9] 模型。结果表明，我们称之为 RT-X 的模型可以改进仅在评估域数据上训练的策略，表现出更好的泛化能力和新功能。针对目标（2），我们提供了 Open X-embodiment（OXE）资源库，其中包括一个数据集，包含来自 21 个不同机构的 22 种不同的机器人装置，可以帮助机器人社区进一步研究 X-embodiment 模型，并提供开源工具以促进此类研究。我们的目标不是在特定架构和算法方面进行创新，而是提供我们训练的模型以及数据和工具，为围绕 X-embodiment 机器人学习的研究注入活力。 II.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/775bb358f6d569d17a1a7896018f97d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c38556283168c0390b60352f9ff10250/" rel="bookmark">
			【具身智能评估8】BEHAVIOR-1K: A Benchmark for Embodied AI with 1,000 Everyday Activities and ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文标题：BEHAVIOR-1K: A Benchmark for Embodied AI with 1,000 Everyday Activities and Realistic Simulation
论文作者：Chengshu Li, Ruohan Zhang, Josiah Wong, Cem Gokmen, Sanjana Srivastava, Roberto Martín-Martín, Chen Wang, Gabrael Levine, Michael Lingelbach, Jiankai Sun, Mona Anvari, Minjune Hwang, Manasi Sharma, Arman Aydin, Dhruva Bansal, Samuel Hunter, Kyu-Young Kim, Alan Lou, Caleb R Matthews, Ivan Villa-Renteria, Jerry Huayang Tang, Claire Tang, Fei Xia, Silvio Savarese, Hyowon Gweon, Karen Liu, Jiajun Wu, Li Fei-Fei
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c38556283168c0390b60352f9ff10250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c653a92e919f2094b4d38edef62288d4/" rel="bookmark">
			【具身智能评估7】ProcTHOR: Large-Scale Embodied AI Using Procedural Generation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文标题：ProcTHOR: Large-Scale Embodied AI Using Procedural Generation
论文作者：Matt Deitke, Eli VanderBilt, Alvaro Herrasti, Luca Weihs, Jordi Salvador, Kiana Ehsani, Winson Han, Eric Kolve, Ali Farhadi, Aniruddha Kembhavi, Roozbeh Mottaghi
论文原文：https://arxiv.org/abs/2206.06994
论文出处：–
论文被引：69（12/18/2023）
论文代码：https://github.com/allenai/procthor，183 star
项目主页：https://procthor.allenai.org/
Abstract 海量数据集和大容量模型推动了计算机视觉和自然语言理解领域的许多最新进展。这项工作提供了一个平台，使具身人工智能也能取得类似的成功。我们提出的 PROCTHOR 是一个程序化生成具身人工智能环境的框架。PROCTHOR 使我们能够对多样化、交互式、可定制和高性能虚拟环境的任意大型数据集进行采样，以训练和评估导航、交互和操作任务中的具身智能体。我们通过 10,000 个生成的房屋样本和一个简单的神经模型展示了 PROCTHOR 的功能和潜力。在 PROCTHOR 上仅使用 RGB 图像训练的模型，在没有显式映射和人类任务监督的情况下，在导航、重新排列和手臂操纵等 6 项具身人工智能基准测试中取得了最先进的结果，其中包括目前正在进行的 Habitat 2022、AI2-THOR Rearrangement 2022 和 RoboTHOR 挑战赛。我们还通过在 PROCTHOR 上进行预训练，而不对下游基准进行微调，在这些基准上展示了强大的 零样本结果，击败了以前使用下游训练数据的最先进系统。
1 Introduction 通过使用大规模训练数据，计算机视觉和自然语言处理模型变得越来越强大。最近的模型，如 CLIP [ 93 ]、DALL-E [ 95 ]、GPT-3 [ 10 ] 和 Flamingo [ 3 ]，都使用了大量与任务无关的数据来预训练大型神经架构，这些架构在下游任务（包括零样本和少镜头设置）中表现出色。相比之下，Embodied AI（E-AI）研究界主要是在场景少得多的模拟器中训练智能体[ 94 , 63 , 27 ]。由于任务的复杂性和需要较长的规划时间，表现最好的 E-AI 模型在有限的训练场景中仍会过拟合，因此对未知环境的泛化能力较差。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c653a92e919f2094b4d38edef62288d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79cdc51e324ae5de76127c807d54f940/" rel="bookmark">
			Linux shell编程学习笔记36：read命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		*更新日志 *2023-12-18 1.根据[美] 威廉·肖特斯 （Willian shotts）所著《Linux命令行大全（第2版）》
更新了-e、-i、-r选项的说明
2.更新了 2.8 的实例，增加了gif动图
3.补充了-i的应用实例 2.12
目录 目录0 前言1 read命令的功能、格式、返回值和注意 1.1 命令功能1.2 命令格式1.3 返回值1.4 注意事项2 命令应用实例 2.1 一次读入多个变量值2.2 不指定变量名2.3 测试read命令的返回值2.3 指定输入时限并进行相应处理2.4 -t 指定结束符2.5 -n 指定输入字符个数2.6 -N 指定输入字符个数2.7 -s不回显来自终端的输入2.8 -e使用命令补全功能2.9 -r 允许输入的值中包含的反斜杠\也作为值输出2.10 -a 读取数组值2.11 -u指定文件说明符2.12 -i 使用初始值 0 前言 在交互式编程中，有时我们需要用户先通过键盘来输入数据，然后程序根据用户输入的数据来做相应的处理。
在之前的学习中，我们已经使用read命令来读取用户通过键盘输入的数据，但对read命令没有做进一步的说明。
现在我们来研究一下read命令的详细用法。
1 read命令的功能、格式、返回值和注意 我们可以使用命令 help read 来查看seq命令的帮助信息：
purleEndurer @ bash ~ $ help read
read: read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79cdc51e324ae5de76127c807d54f940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6baa5c1fa350ba54d3a0d50ef7a550f9/" rel="bookmark">
			【经典LeetCode算法题目专栏分类】【第6期】二分查找系列：x的平方根、有效完全平方数、搜索二位矩阵、寻找旋转排序数组最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《博主简介》
小伙伴们好，我是阿旭。专注于人工智能AI、python、计算机视觉相关分享研究。
✌更多学习资源，可关注公-仲-hao:【阿旭算法与机器学习】，共同学习交流~
👍感谢小伙伴们点赞、关注！
X的平方根 class Solution:
def mySqrt(self, x: int) -&gt; int:
l, r, ans = 0, x, -1
while l &lt;= r:
mid = (l + r) // 2
if mid * mid &lt;= x:
ans = mid
l = mid + 1
else:
r = mid - 1
return ans
有效完全平方数 class Solution:
def isPerfectSquare(self, num: int) -&gt; bool:
l = 0
r = num
while l &lt;= r:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6baa5c1fa350ba54d3a0d50ef7a550f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9834495cb8d3ecd47f262fc3bb2050a1/" rel="bookmark">
			【百度PARL】强化学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 强化学习基本知识一些框架Value-based的方法Q表格举个例子 强化的概念TD更新 Sarsa算法SampleSarsa Agent类 On_policy vs off_policy函数逼近与神经网络DQN算法DQN创新点DQN代码实现model.pyalgorithm.pyagent.py总结：举个例子 实战 视频：世界冠军带你从零实践强化学习
代码：github仓库
因项目需要，这系列课程只学到了DQN。本人首先先学习了李宏毅的policy-based的课程，然后再学习这里百度飞桨科科老师的强化学习课程，主要学习了value-based的内容。科科老师这里对代码逻辑的讲解更加清晰，非常的好。
强化学习基本知识 算法库 一些框架 PARL 对于一个新的example，只需要修改一下agent/model就可以了算法在parl文件夹中也将所有算法定义好了 第一部分总结 Value-based的方法 下图的过程是符合马尔科夫决策过程的，俗称MDP
如果状态转移概率和reward都是已知的，那么就称这个环境是已知的 model-based P函数和R函数已知可以直接用动态规划求解 model-free P函数和R函数未知试错探索，现实世界的环境往往未知我们主要学习这个用Q函数和V函数来表示 Q表格 反应在某个s下，哪个动作价值高
Q表格：指导每一个Step的动作选择，目标导向：未来的总收益
我们的收益要看的更远一些
但是有时候看的太远也不好，所以引入衰减因子 γ \gamma γ
举个例子 折扣因子 我们就是要求解Q表格 刚开始全部初始化为0，当足够多的与环境交互之后，Q表格就会更新足够完善 强化的概念 时序差分
主要特点是在估计当前策略的价值函数时，它不需要等到一个完整的序列（如一局游戏）结束后才更新价值估计，而是在每一步之后立即进行更新李宏毅讲过 在不断的重复试验之后，原本是要看到熊发怒才会瑟瑟发抖，不断试验之后，看到有熊爪就会瑟瑟发抖
意味着agent学会了预测熊发怒这一状态的价值，并将这种预期的负面价值向前传播到先前的状态（熊爪）。这种向前传播的过程是通过Temporal Difference Error来完成的，这个错误是实际奖励和智能体预测的未来奖励之间的差异。智能体使用这个TD错误来更新其关于当前状态和动作的价值估计，使得未来的决策更加准确。 下一个状态的价值，是可以不断强化影响上一个状态的价值
下一个状态的价值只与当前状态有关，历史的状态已经融合到当前状态 状态价值迭代 demohttps://cs.stanford.edu/people/karpathy/reinforcejs/gridworld_td.html TD更新 拿下一步的Q值去更新这一步的Q值
刚开始 Q ( S t , A t ) Q(S_t,A_t) Q(St​,At​)初始化为0，其要去逼近Target、也就是未来收益之和 G t G_t Gt​。在做一个简单的数学变换我们可以发现 G t G_t Gt​ = R t + 1 + γ G t + 1 R_{t+1}+{\gamma}G_{t+1} Rt+1​+γGt+1​因为 Q ( S t , A t ) Q(S_t,A_t) Q(St​,At​)要逼近 G t G_t Gt​所以差不多 Q ( S t + 1 , A t + 1 ) Q(S_{t+1},A_{t+1}) Q(St+1​,At+1​)要逼近 G t + 1 G_{t+1} Gt+1​ α：学习率，决定了新信息覆盖旧信息的速度当前的Q值会向目标Q值逼近，而目标Q值是基于智能体获得的实际奖励和下一个状态-动作对的预期Q值计算得来的。右侧的图表示了状态和动作之间的转移，以及如何更新Q值。每次智能体在状态 ( $S_t $) 下采取动作 ( A t A_t At​ )，都会转移到新的状态 ( $S_{t+1} KaTeX parse error: Can't use function '\)' in math mode at position 1: \̲)̲ 并采取新的动作 \( A_{t+1} $)，同时接收奖励 ( $R_{t+1} $)，然后基于这些信息来更新Q值。 所谓的软更新其实像一种误差，表示预期（即时奖励加上对下一状态的Q值的估计）与当前估计之间的差异
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9834495cb8d3ecd47f262fc3bb2050a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c9da56f9a421b8d782a95004a7474b/" rel="bookmark">
			推荐几款值得收藏的3DMAX插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐几款值得收藏的3DMAX插件
StairGenerator
StairGenerator一键楼梯插件，不需要花费太多的时间，轻松从2D平面图生成3D楼梯模型，生成的楼梯模型细节丰富真实。
【主要功能】
1.简单：轻松实现2D到3D建模。
2.具有最详细三维结构的台阶平面图。
3.楼梯各部件完全参数化。
4.自动生成材质。
【适用版本】
3dMax2009或更高版本
Citytraffic
城市交通是一个智能插件，用于创建基于人工智能的交通模拟。它有很多很酷的功能，如道路网络（基于样条线）、公交车站、限速器，可以帮助您为项目创建逼真的交通流。
【适用版本】
支持3dMax 2008及更高版本
Afterburn
AfterBurn是一个高级的体积粒子效果引擎插件，可以渲染各种逼真的效果，包括云、火山碎屑烟雾、灰尘、爆炸效果、液态金属和各种程序定义的对象。与FumeFX一起，它是VFX工具箱的完美工具。它被用于许多电影项目，包括《世界末日》、《K-19》、《德古拉2000》、《凤凰城的飞行》等。
StitchLines
3dMax创建缝线插件StitchLines，一键生成车缝线建模，该脚本与可编辑多边形、可编辑样条线或 编辑多边形修改器一起使用，创建一条样条曲线（车缝线），它将以几何体形式在视口中和渲染中显示。
【适用版本】
3dMax2018.2及更高版本
MultiScatter
MultiScatter是3ds Max的一个插件，基于VRayScatter技术，它不仅适用于V-Ray，还适用于Arnold、Mental Ray、Corona、Octane、Maxwell、FStormRender（其他可以使用我们的SDK添加）
MultiScatter允许渲染引擎在数组中生成大量对象。
对64位系统的支持允许MultiScatter在眨眼之间创建并提交渲染，例如森林甚至城市。
通过优化的RAM管理，对象的快速渲染时间生成使场景创建过程非常高效。
GrassScatter
3DMAX一键种草插件GrassScatter，用于控制草的创建和散布，快速生成草坪建模！
【版本要求】
3dMax2012及更高版本
DashedShape
DashedShape实线转虚线（虚线形状）插件，允许从3DMAX场景中选择的一条或多条样条线形状创建虚线形状。
【主要特性】
1.一键将实线转换为虚线。
2.支持多条线段同时转换。
3.支持可渲染。
【版本要求】
支持3dMax2018.2及更高版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc0195052ad7a5313ed0dbc55bd2c51/" rel="bookmark">
			算法设计与分析2023秋-头歌实验-实验七 动态规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1关：数塔问题任务描述相关知识编程要求解题思路测试说明参考答案 第2关：最长公共子序列任务描述相关知识编程要求解题思路：测试说明参考答案 第3关：求序列-2 11 -4 13 -5 -2的最大子段和任务描述相关知识编程要求解题思路：测试说明参考答案 第4关：求最长的单调递增子序列长度任务描述相关知识编程要求解题思路：测试说明参考答案 第5关：矩阵连乘问题任务描述相关知识编程要求测试说明参考答案 第1关：数塔问题 任务描述 本关任务：编写用动态规划解决数塔问题。
相关知识 为了完成本关任务，你需要掌握：动态规划。
编程要求 求上图从顶层到顶层的一个路径，使路径上的数字和最大。要求输出最大的数字和max和数值和最大的路径。
解题思路 原始信息有层数和数塔中的数据，层数用一个整型变量n存储，数塔中的数据用二维数组data，存储成如下的下三角阵:
9 12 15 10 6 8 2 18 9 5 19 7 10 4 16 必需用二维数组d存储各阶段的决策结果。二维数组d的存储内容如下：、
d[n][j]=data[n][j]， j=1,2,……,n； d[i][j]=max(d[i+1][j]，d[i+1][j+1])+data[i][j]， i=n-1,n-2,……1，j=1,2,……,i 最后d[1][1]存储的就是问题的结果。
测试说明 平台会对你编写的代码进行测试：
测试输入：
5 9 12 15 10 6 8 2 18 9 5 19 7 10 4 16 输出示例：
max=59 数值和最大的路径是：9-&gt;12-&gt;10-&gt;18-&gt;10 参考答案 #include &lt;stdio.h&gt; #define N 5 //问题规模 int main() { int a[50][50]; a[1][1] = 9; a[2][1] = 12, a[2][2] = 15; a[3][1] = 10, a[3][2] = 6, a[3][3] = 8; a[4][1] = 2, a[4][2] = 18, a[4][3] = 9, a[4][4] = 5; a[5][1] = 19, a[5][2] = 7, a[5][3] = 10, a[5][4] = 4, a[5][5] = 16; int i, j, dp[50][50] = { 0 }, path[50][50] = { 0 }; for (j = 1; j &lt;= N; j++) //初始子问题 ，倒数第二层（第i-1层）开始 dp[N][j] = a[N][j]; for (i = N - 1; i &gt;= 1; i--) //进行第 i+1 层的决策，从i 到 1 向上 for (j = 1; j &lt;= i+1; j++) { //每一层有 i+1 个 if (dp[i + 1][j] &gt; dp[i + 1][j + 1]) { dp[i][j] = a[i][j] + dp[i + 1][j]; path[i][j] = j; //本次决策选择下标j的元素 } else { dp[i][j] = a[i][j] + dp[i + 1][j + 1]; path[i][j] = j + 1; //本次决策选择下标j+1的元素 } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc0195052ad7a5313ed0dbc55bd2c51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3424a4cac4c5ac2bccca8508009f3e52/" rel="bookmark">
			算法设计与分析2023秋-头歌实验-实验一 循环与递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 第1关：从自然数中取3个数进行组合之循环算法任务描述编程要求测试说明参考答案 第2关：从自然数中取3个数进行组合之递归算法任务描述编程要求测试说明参考答案 第3关：求n的阶乘n!任务描述编程要求测试说明参考答案 第4关：求斐波那契额数列的前10项任务描述编程要求测试说明参考答案 第1关：从自然数中取3个数进行组合之循环算法 任务描述 本关任务：用循环算法找出 5 个自然数中取 3 个数的组合。
编程要求 请在右侧编辑器Begin-End处补充代码，完成本关任务。
测试说明 平台会对你编写的代码进行测试，比对你输出的数值与实际正确数值，只有所有数据全部计算正确才能通过测试：
测试输入：5 3 （n=5，r=3；，表示从1,2,3,4,5自然数中选择 3 个数)
预期输出：
1 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5 参考答案 #include &lt;stdio.h&gt; void combloop1(int n, int r) { /********** Begin **********/ for(int i=1;i&lt;=n;i++){ for(int j=2;j&lt;=n;j++){ for(int k=3;k&lt;=n;k++) if((i&lt;j)&amp;&amp;(j&lt;k)){ printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3424a4cac4c5ac2bccca8508009f3e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f68bf7357add8bde25fe0b5eaf66eb25/" rel="bookmark">
			【时间序列】Tempo：基于提示工程的预训练时序预测模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章：TEMPO: PROMPT-BASED GENERATIVE PRE-TRAINED TRANSFORMER FOR TIME SERIES FORECASTING
文章地址：https://arxiv.org/pdf/2310.04948.pdf
1. 概要 今天介绍一篇谷歌在今年10月挂在arxiv上的论文，文章以GPT为backbone来进行时间序列预测，并且引入了提示工程来帮助模型更好地适配来自于不同领域的非平稳时序数据。Tempo模型首先将复杂的时间序列解耦为趋势项、季节项和残差项，进一步将其映射到相应的隐藏空间，以构建GPT能够识别的输入。考虑提示技术可以帮助语言模型更好地利用预训练期间学习到的信息来应对零样本学习任务，而不再需要从头开始训练。因此，Tempo构造了一个prompt池，为解耦得到的不同成分分配不同的提示词，使得模型利用历史信息来适应时间序列分布的变化。下面就一起看看吧～
2. 模型介绍 老生常谈，先回顾下多维时间序列预测任务的定义如下：
与常规的时序预测模型不同的是，这里参考语言模型在预测过程中为要预测的输入窗口添加了提示词。
序列分解
对于输入序列，可以将每个通道的变量都分解成如下形式：
其中，i表示第i个通道的序列，趋势项可通过计算指定滑窗内的均值得到，即，其中m=2k+1，k为滑窗长度。
周期项是将原序列减去趋势项后通过Loess smoother计算得到，具体细节可查看文章，这里就不赘述了。原序列减去趋势项和周期项后就剩下残差项。
序列预处理
接下来对每个通道序列进行建模，通过上述分解每个通道的数据一分为三，接下来以i通道的周期项为例说明建模流程。这里作者采用的是patchTST（结构如下图所示）相同的预处理方式～
首先对进行instance normalization：,和为可学习参数。
接着，将序列分成长度为的个patch,patch之间存在一定的重叠，重叠长度为s。切分好的patch送入如下的embedding层进行编码：
这里Tempo使用的backbone是预训练好的基于decoder层的GPT，编码能够将时序数据转化成大语言模型能理解的输入形式，而将原始数据分成不同的patch能够在保留局部语义的同时增大模型感受野。
Prompt设计
考虑到实际场景中时间序列数据通常具有非平稳特性（分布随时间不断变化），文章引入了一个共享的提示词集合，集合中保存了不同的键值对。理想情况下，相似的输入时间序列倾向于从集合中检索出同一组提示词，这将允许模型有选择性地回忆在单个时间序列实例层面最具代表性的提示，从而利用让模型更好地利用已有的经验知识。提示词记录了有关周期、趋势、时序相关性等相关的信息，定义如下：
M表示提示词的个数，表示单个提示词，,与注意力机制中的Key相同，与序列的编码得到的embbeding进行相似度计算，即：
基于,根据上述计算，将从提示词集合中找到k个与本序列相关的提示，并将提示词与原始序列的embedding进行拼接得到最终有关趋势项的输入：
有关周期项和残差项的输入也是以相同方式构造，其中V采用端到端的训练方式，文章中并没有介绍太多，具体细节可后续蹲一波作者公开代码。
Backbone
文章使用预训练好的GPT-2作为预测模型，有两种形式，一是经过上面操作后的趋势项、周期项和残差项再进行拼接，然后输入GPT。另一种是使用独立的GPT分开建模趋势项、周期项和残差项。对于GPT块内部，文章在训练过程中冻结了前馈层，只更新位置嵌入层和层归一化层的梯度。此外，采用LORA进行微调，以适应不同的时间序列分布。最后将各个分支的输出进行反归一化后累加即可得到最终的预测值。
3. 实验结果 实验验证数据是老选手了，就是那七个常见数据集，Tempo这次对比14个算法，主要可以分成（1）预训练的LLM模型，包括Bert、GPT2（GPT4TS）、T5和LLaMA。（2）基于Transformer的模型，包括PatchTST、Autoformer、FEDformer、Informer、ETSformer、非平稳Transformer（Non-Stat.）和Reformer。（3）基于线性层的模型，包括NLinear、DLinear和LightTS模型。（4）2D模型如TimesNet。评价指标主要考虑的是MAE和MSE，具体结果如下。
对于单个数据集，Tempo效果的效果还是很不错，偶尔一两个数据集稍微差点，但也落后的不多，在Weather数据集上甚至有点要遥遥领先的意思。进一步文章进一步测试了多数据集的效果（即五个数据集用于训练，两个数据集作为测试的），Tempo效果依旧不错。
推荐阅读：
我的2022届互联网校招分享
我的2021总结
浅谈算法岗和开发岗的区别
互联网校招研发薪资汇总
2022届互联网求职现状，金9银10快变成铜9铁10！！
公众号：AI蜗牛车
保持谦逊、保持自律、保持进步
发送【蜗牛】获取一份《手把手AI项目》（AI蜗牛车著）
发送【1222】获取一份不错的leetcode刷题笔记
发送【AI四大名著】获取四本经典AI电子书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0844dd9e5d61ab352275649cad7e819/" rel="bookmark">
			Redis数据持久化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOF日志 AOF日志：Append Only File，相比于常见的数据库写前日志（Write Ahead Long, WAL），AOF日志是写后日志，也就是Redis先执行命令将数据写入到内存中，然后才记录日志
AOF里记录的是Redis收到的每一条记录，这些记录通过文本形式进行保存。
AOF采用写后记录的好处：
避免了额外的检查开销，Redis在向AOF中记录日志的时候，不需要先对命令进行正确性检测，先让系统执行命令，只有命令执行成功之后才会写入到AOF日志中，可以防止在AOF日志中写入错误的命令导致后续恢复数据时失败不会阻塞当前的写操作，命令执行之后才去进行日志写入，可以防止日志的写入操作阻塞了当前的数据写入 AOF写回策略 控制从内存缓冲区写入到磁盘的时机
AOF机制提供了三种写回策略，也就是AOF的appendfsync配置项。
Always，同步写回，每个写命令执行完，立刻同步的将日志写回到磁盘中Everysec，每秒写回，每个写命令执行完，先把日志写到AOF文件的内存缓冲区，每隔1秒把缓冲区的数据写入到磁盘中No，操作系统控制写回，每个写命令执行完，先把日志写到AOF文件的内存缓冲区，由操作系统来决定什么时候将缓冲区的数据写入到磁盘中 配置项
写回时机
优点
缺点
Always
同步写回
可靠性高，数据基本不丢失
每个写命令都要落盘，性能影响较大
Everysec
每秒写回
性能适中
宕机时丢失1秒内的数据
No
操作系统控制写回
性能好
宕机时可能会丢失大量数据
AOF重写机制 随着Redis中的写命令执行的越来越多，AOF文件会变得越来越大，此时也会引发一定的问题
文件系统本身对文件大小有限制，无法写入过大的文件文件过大的情况下，追加写入的效率降低当Redis宕机之后需要读取AOF日志中的每一条命令进行数据恢复，文件过大会导致Redis恢复过慢 AOF重写就是基于Redis数据库的现状来创建一个新的AOF日志文件，在AOF重写的时候，会读取当前数据库中的所有键值对，然后将这些键值对的写入命令记录在AOF日志文件中
AOF重写过程 AOF的写回操作是由主线程来执行的，但是AOF的重写是通过后台子进程bgrewriteaof来完成的，所以AOF重写的时候不会阻塞主线程
每次执行重写操作的时候，主线程会fork出来一个后台子进程bgrewriteaof，fork出来的子进程会包含主线程的内存空间的所有数据，然后这个后台子进程就会在不影响主线程的前提下，将最新的数据记入到新的AOF日志中由于AOF重写的时候不会阻塞主线程，所以还会有新的数据写入，此时就会将新的写入操作记录在两份日志中，会同时写在原本的AOF日志的缓冲区以及新的AOF日志的缓冲区 重写AOF日志的时候，不会复用原本的AOF日志文件，而是新建一个新的AOF日志文件，在新的AOF文件重写完成之后覆盖老的AOF文件，防止AOF重写失败的情况下污染老的文件，导致数据无法恢复
在AOF重写的过程中，为了防止在重写过程中对原有key的写入导致数据不一致问题，Redis会设置一个AOF缓冲区，缓冲区在创建了子进程之后开始使用。在重写AOF期间，Redis执行完一个写命令后，会将这个命令写入到AOF缓冲区以及AOF重写缓冲区。
当子进程完成了重写工作后，会将信号发送给主进程，主进程调用一个信号处理函数，
将AOF重写缓冲区的数据全部写入到新的AOF日志中，保证AOF日志与数据库的数据一致性新的AOF文件进行改名覆盖老的AOF文件 子进程进行重写操作 子进程会带有主进程的数据副本，创建出来的子进程会以只读的方式与主进程共享内存，当父子进程有一方对数据进行修改了之后，就会触发写时复制，父子进程就会拥有不同的数据副本了。
如果使用子线程，那么多线程之间会共享内存，在修改共享内存的数据的时候就需要考虑采用加锁的方式来保证数据的一致性，会有性能的损耗。
主进程在fork一个子进程的时候，操作系统会把主进程的页表复制一份给子进程，这个页表中会记录着虚拟地址和物理地址映射关系，此时不会有物理内存的复制，也就是说此时父子进程的虚拟内存是不一样的，但是指向的是同一个物理内存，这种情况下，子进程就共享了父进程的数据，内存权限会标记为只读当主进程或者子进程对这块共享内存进行写操作的时候，会触发CPU的写保护中断，这个中断是由于违反权限导致的，然后操作系统会在中断函数中进行物理内存的复制，并重新设置内存映射关系，同时将父子进程的内存权限修改为可读写，最后进行写操作，这整个就是写时复制（Copy On Write）。 写时复制中，在发生写操作的时候，操作系统才会复制物理内存
阻塞主线程的重写操作 在fork子进程的时候，需要复制父进程的页表等数据结构，阻塞的时间与页表的大小有关，页表越大，阻塞的时间越长创建完子进程之后，如果有父进程或者子进程的写操作，会触发写时复制，会对物理内存进行拷贝操作，物理内存越大，阻塞时间越长当子进程完成AOF重写工作，主进程开始执行信号处理函数的时候也会造成主线程阻塞 RDB日志 内存快照，内存中的数据在某一时刻的状态记录
Redis生成RDB日志的命令：
save：在主线程中执行，会导致阻塞bgsave：创建一个子进程，专门用来写入RDB文件，避免了主线程的阻塞，默认配置 Redis通过操作系统提供的写时复制机制实现在生成RDB文件的同时不影响主线程响应客户端的命令进行写入操作。
发生写时复制之后，RDB日志中保存的是原本的数据，而不是更新后的数据。
混合持久化 混合持久化的工作在AOF重写的时候
开启混合持久化之后，当触发AOF重写的时候，fork出来的重写子进程会先将共享内存中的数据以RDB日志的格式写入到新的AOF日志文件中，当写入完成之后，会将AOF重写缓冲区中的数据以AOF日志的格式继续追加写入到AOF日志之后，然后再用新的AOF日志替换旧的AOF日志。
混合持久化生成的AOF日志前半部分是RDB格式，后半部分是AOF原本的格式。这样重启加载数据的时候，由于前半部分是RDB，加载速度就会有一定的提升。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138ef543c7bbc84a590917139e192c1b/" rel="bookmark">
			【MySQL异常】MySQL出现 You can‘t specify target table for update in FROM clause 错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL出现 You can‘t specify target table for update in FROM clause 错误的解决方法 一、背景描述二、原因分析三、解决方案四、踩过的坑 一、背景描述 MySQL 数据库，版本号为 5.7.37（语句为 SELECT VERSION();）
在 mysql 数据库中有一张表为 device_data_monitor，需求是更改这个表中的某一列的值。于是就使用以下语句更新 pillar_id 这一列的值。
UPDATE device_data_monitor SET pillar_id = 29 WHERE monitor_id IN ( SELECT monitor_id FROM device_data_monitor WHERE pillar_id = 10 ); 结果就会报错，内容如下：
You can‘t specify target table for update in FROM clause 结果如下：
二、原因分析 在MySQL中，可能会遇到 You can’t specify target table ‘表名’ for update in FROM clause 这样的错误
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/138ef543c7bbc84a590917139e192c1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08352caabae5b5cb1c85bc72d03d8005/" rel="bookmark">
			鸿蒙原生应用再添新丁！米哈游入局鸿蒙
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鸿蒙原生应用再添新丁！米哈游入局鸿蒙
来自 @HarmonyOS 微博12月18日消息，！#米哈游宣布启动鸿蒙原生应用开发#，当“技术宅拯救世界”的@米哈游miHoYo @原神 遇上#HarmonyOS NEXT#，将为跨平台的游戏玩法和玩家体验带来更多可能。#鸿蒙千帆起# ##HarmonyOS#市场或迎来爆发式增！
学习鸿蒙正当时！以下是一些学习资料，可以作为参考：
《跟老卫学 HarmonyOS 开发》 开源免费教程：GitHub - waylau/harmonyos-tutorial: HarmonyOS Tutorial. 《跟老卫学HarmonyOS开发》
《鸿蒙 HarmonyOS 手机应用开发实战》（清华大学出版社）：713页鸿蒙巨作！《鸿蒙HarmonyOS手机应用开发实战》简介 | 老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化 | waylau.com
《鸿蒙 HarmonyOS 应用开发从入门到精通战》（北京大学出版社）：GitHub - waylau/harmonyos-tutorial: HarmonyOS Tutorial. 《跟老卫学HarmonyOS开发》
“鸿蒙系统实战短视频 App 从 0 到 1 掌握 HarmonyOS” ：鸿蒙系统实战短视频App 从0到1掌握HarmonyOS_实战课程_慕课网
《鸿蒙HarmonyOS应用开发入门》（清华大学出版社）：轻松掌握ArkTS！鸿蒙新作《鸿蒙HarmonyOS应用开发入门》简介 | 老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化 | waylau.com
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/40/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>