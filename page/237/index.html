<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af68265f132a0ab02993c0158bd825a5/" rel="bookmark">
			清除redis数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在redis目录或者bin里
redis-cli.exe -h 127.0.0.1 -p 6379
auth ****** （****** 是密码）
flushall
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c26f6d3ee7b1d214e3f021771551555/" rel="bookmark">
			Jetson Nano NX TX2 Xavier 设置Nvme启动保姆级教程（附shell脚本)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://github.com/jetsonhacks大佬工具集合访问地址
采用 M.2 Key M SSD 为系统盘 SSD 作用 NVMe SSD 硬盘仅作为系统盘（rootfs 和用户区），系统的启动引导依然是通过 SD 卡或 EMMC，比如升级设备树 dtb 还是在 SD 卡或 EMMC 中。
步骤一、准备 SSD 并格式化为 GPT 1.准备 M.2 Key M SSD 《本例采用的是 WD PC SN520 型号 SSD》
1.打开 Ubuntu18.04 自带 Disks 工具，'Ctrl+F' 或点击右上角选择‘Format Disk' 并将其格式化为 GPT 格式
2.格式化时必须选择“Ext4”， 等待完成后，点击下方 '三角按钮'，mount 到固定目录如/media/nvidia/xxxx
3.参考下图操作:
1)首先左上角搜索 disks 进入disks,找到安装的 ssd,点击”+”号; 3 按键Ctrl+F 格式化格式化并选择Ext4
创建名称并且输入密码
点击图中位置 终端执行下面步骤
git clone https://github.com/jetsonhacks/rootOnNVMe.git cd rootOnNVMe ./copy-rootfs-ssd.sh ./setup-service.sh sudo reboot 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773c17f7ef60b6c415bee04e2ec23261/" rel="bookmark">
			[足式机器人]Part1 序言&#43;简介Ch01——【Legged Robots that Balance 读书笔记】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅供学习使用
本文结合个人理解体会作者的思路，也从个人科研角度出发，部分翻译参考由：QQ群（2群legged robot that balance）提供，感谢他们为本文英文版翻译所做的贡献（但有些部分阅读起来仍有困难），若有改进之处欢迎共同讨论！
序言+简介Ch01 1. 序言2. 简介2.1 足式机器人的研究意义2.2 提高机动性——动力学与平衡性2.3 足式机器人的研究史——静平衡2.4 主动平衡研究史——倒立摆（inverted pendulums）2.5 运动控制的三部曲2.6 三维空间运动2.6 多足机器人的奔跑运动2.7 机器人与动物的对称性2.8 总结 1. 序言 问题源于想象一个自行车轮从楼梯下落：
由于辐条的刚度较大，车轮几乎不会转动，停留时间不够长——圆心（轮毂）几乎不会在车轮与地面接触时发生运动——缺少弹性；轮胎几乎一直在滚动的状态中，很难保持一种直立的状态——缺少平衡机制； 动物在运动过程中：弹性对应肌肉与腱，平衡机制则是对其的控制，从而才有作者后续对足式运动基本理解的第一步：弹簧棒单腿（a computer controlled pogostick）
2. 简介 2.1 足式机器人的研究意义 足式机器人在复杂地形中具有更好的驱动性——自然界中动物们所能达到的地方比车轮或履带要多得多（需要连续性支撑路径）——足式移动的灵活性受限于可达地形上的最优支撑点，而轮式移动受限于最差地形——爬梯子。 Only about half the earth’s landmass is accessible to existing wheeled and tracked vehicles, whereas a much larger fraction can be reached by animals on foot. It should be possible to build legged vehicles that can go to the places that animals are already able to reach.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773c17f7ef60b6c415bee04e2ec23261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285ad264d49f4aeaac9debba99f0b38e/" rel="bookmark">
			【从0-1成为架构师】高可用架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高可用的网络架构 在企业中为了保障可用性，对于硬件的机器选择要求都会比较高，并且对与软件来说硬件的故障是常态，并且也不是好解决的，所以想要打造一个高可用的架构就要从软件层下功夫。保障网站的可靠性就是需要保障在硬件故障的时候网站还是可用的。
所以实现网站可用性的手段是数据和服务的冗余和失效转移，一旦某些服务宕机，可以快速的将请求转移到其他的服务上，如果磁盘损坏，则从备份的磁盘上读取数据。
网站的架构模式按照以下模型分层，对于不同的分层模型的用处是不一样的，那么对于高可用的要求和手段也是不一样的
应用层主要是负责业务的处理，服务层负责提供可复用的服务，数据层负责数据的储存和访问。
位于应用层的服务一般为了高并发，会通过负载均衡设备将一组服务器组成一个集群共同对外提供服务。当负载均衡设备通过心跳检测监控到某一服务不可用后，会将剔除集群，并将请求分发到其他服务器上保证高可用。
服务层与应用层大致相同，只是服务层是负载均衡后的应用层调用的，并通过服务注册中心对提供服务的服务器进行心跳检测，发现有服务不可用，立即通知客户端程序修改服务访问列表。剔除不可用服务。
位于数据层的服务比较特殊，数据服务上存储着数据，为了保证服务数据不丢失，数据访问不中断，需要在数据写入的时候进行数据同步复制，将数据写入多台服务器，实现数据冗余备份。当数据服务宕机时，应用程序将访问切换到有备份数据的服务器上。
应用的高可用 应用层主要负责处理网站应用的逻辑处理，应用的一个明显的特征就是无状态行。无状态指的是应用服务不保存业务的上下文。多个服务器是完全对等的，请求放在那个服务器上请求结果都是对等的。
通过负载均衡进行无状态服务的失效转移 既然服务是无状态的，那么当任意一个主机宕机是，请求转移到集群中的任意一个可用的服务处理，这样结果是正确的。整个集群还是可用的。
负载均衡顾名思义，主要是在业务量和数据量较高的情况下，一台机器无法处理的时候，通过将服务器部署成一个集群来分摊请求和数据量。来提高整体的处理能力。目前的负载均衡服务都提供失效转移功能。
当Web服务器集群中的服务器都可用的时候，负载均衡服务器会通过策略将服务分到到服务器上，当服务器10.0.0.1宕机是，负载均衡服务器通过心跳检测机制发现服务不可用时就会把它剔除调，让其他的服务器去处理请求返回结果
由于负载均衡在应用层可以实现高可用，所有建议网站的应用服务器至少两个，实现负载均衡。
应用服务器集群的Session共享 web请求中将多次请求修改使用的上下文称为会话，就是用来记录用户的信息，在单机情况下可以服务在服务器上的web容器来记录，但是在集群环境下就需要一个Session服务器来管理。
这种解决方案是将应用服务器的状态剥离，分为有状态的session服务器和无状态的session服务器。
对于有状态的session服务器，一种简单的方法是分布式缓存或者数据库等。
服务的高可用 可复用的服务模块为业务模块提供基础公共服务，大型网站中这些服务通常都独立分布式部署，被具体服务远程调用，和应用层一样也是无状态的，除了也需要负载均衡提供高可用外，还需要提供一些其他的规则。
1.分级管理 运维上将服务分级管理，对于重要的，请求量多的服务优先使用更好的硬件，同时在服务部署上也做到隔离，避免连锁的故障响应。
2.超时设置 由于服务宕机或者死锁等原因，可能导致应用程序对服务端的调用失去响应，进而导致用户长时间的得不到响应，同时还占用资源，不利于即时将访问转移到正常的服务器上。
3.异步调用 应用调用服务异步调用，避免一个服务失败导致整个应用请求失败的情况，如注册用户分为3步，将用户信息写入数据库，发送邮件，开通权限。这个就可以采用异步的方式去调用发送邮件服务，这样发送邮件失败并不会影响到用户注册的结果。
当然，也不是所有的流程的适合用异步的方式，对于获取用户信息的场景异步服务会延长处理时间，得不偿失。对于那些必须判断成功才能下一步的流程也不适合使用异步。
4.服务降级 在网站高峰期，服务可能由于大量的并发调用导致性能下降，最后引起服务不可用，为了保证网络和核心流程可用，需要服务降级，服务降级有两个手段：拒绝服务和关闭服务。
拒绝服务：拒绝低优先级的服务，减少服务并发数或者随机拒绝部分请求。
服务关闭：关闭不重要服务或者服务内部关闭部分不重要功能。
5.幂等性设计 应用调用服务失败后，会将请求重新转发到其他服务上，这个时候要进行幂等性的判断，有可能服务调用失败是网络问题导致的，实际上业务处理成功了。
数据的高可用 对于网站而言，数据是最宝贵的资产。不同于应用的高可用，由于数据存储服务器上的数据不同，当某台服务宕机的时候，数据访问请求不能任意切换到集群其他机器上。
保证数据存储高可用手段主要是冗余备份和失效转移机制。数据备份是保证数据有多副本，任意副本的失效都不会导致数据的永久丢失。从而实现数据完全的持久化。而失效转移机制是保证当一个数据副本不可访问时，可以快速切换访问数据的其他副本。保证数据可用。
数据备份 数据备份可以分为冷备份和热备份。冷备份就是传统的数据拷贝，优点是简单和低廉，缺点是数据的时效性不行，容易丢失数据，也不能保证数据的可用性，冷备份回复时间也比较长。
因此冷备份在企业中也会用，但是只是一个保底手段，还有与热备份同时使用。
热备份又可分为两种：异步热备份和同步热备份
异步热备份是指多份数据副本的写入操作异步完成，应用程序在收到数据服务写成功的时候只收到一份，存储系统会异步的写其他副本
异步备份写入中，存储服务器分为主存储服务器和从存储服务器，应用程序正常的时候只连接主服务器，数据写入的时候有主存储的写操作代理模块将数据写入后立即返回，然后再异步的写入其他服务器
同步热备份就是多份数据副本的写入操作同步完成，应用程序在收到数据服务写成功的时候多分副本都响应成功了，但当应用程序响应失败的时候，可以有部分副本写入成功部分写入失败。
同步热备份具体实现时会开多个线程同步写，在都写完之后在返回结果。
这种情况下没有主从之分，完全对等，更便于维护和理解。
失效转移 如数据服务器集群上任意服务宕机，那么应用服务器针对这台服务器所有的读写操作都需要重新路由到其他服务器，保证数据访问不会失败。
失效转移分为三个步骤：失效确认，访问转移，数据恢复
1.失效确认 判断服务宕机是系统确认服务宕机的第一步，主要手段有心跳检测和应用程序访问失效报告
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-T2J6uQzG-1662298123102)(evernotecid://DED20B32-7319-43F6-995F-0BB020671E91/appyinxiangcom/22603206/ENResource/p916)]
2.访问转移 确认某台服务宕机后，就需要将数据读写访问重新路由到其他服务上，对于对等存储的服务器器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上，如果存储不对等，那么久需要重新计算路由。选择存储服务器。
3.数据恢复 由于某台服务器宕机，所以副本数就会减少，必须将副本数恢复到设定的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a6c319fbce668cfdb929e965668ecd5/" rel="bookmark">
			《绝地求生》玩家排名预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.项目背景
2.数据集介绍
3. 项目评估方式
3.1 评估方式
3.2 MAE(Mean Absolute Error)介绍
4.代码实现
4.1 获取数据、基本数据信息查看
4.2 数据基本处理
4.2.1 数据缺失值处理
4.2.2 特征数据规范化处理
4.2.3 部分变量合成
4.2.4 异常值处理
4.2.5 类别型数据处理
4.2.6 数据截取
4.2.7 确定特征值和目标值
4.2.8 分割训练集和测试集
4.3 机器学习（模型训练）和评估
4.3.1 使用随机森林对模型进行训练
4.3.2 使用lightGBM对模型进行训练
1.项目背景 绝地求生(Player unknown’s Battlegrounds)，俗称吃鸡，是一款战术竞技型射击类沙盒游戏。
这款游戏是一款大逃杀类型的游戏，每一局游戏将有最多100名玩家参与，他们将被投放在绝地岛(battlegrounds)上，在游戏的开始时所有人都一无所有。玩家需要在岛上收集各种资源，在不断缩小的安全区域内对抗其他玩家，让自己生存到最后。
该游戏拥有很高的自由度，玩家可以体验飞机跳伞、开越野车、丛林射击、抢夺战利品等玩法，小心四周埋伏的敌人，尽可能成为最后1个存活的人。
该游戏中，玩家需要在游戏地图上收集各种资源，并在不断缩小的安全区域内对抗其他玩家，让自己生存到最后。
2.数据集介绍 train_V2.csv - 训练集
test_V2.csv - 测试集
数据集局部图如下图所示:
数据集中字段解释：
3. 项目评估方式 3.1 评估方式 你必须创建一个模型，根据他们的最终统计数据预测玩家的排名，从1（第一名）到0（最后一名）。
最后结果通过平均绝对误差（MAE）进行评估，即通过预测的winPlacePerc和真实的winPlacePerc之间的平均绝对误差
3.2 MAE(Mean Absolute Error)介绍 4.代码实现 在接下来的分析中，我们将分析数据集，检测异常值。
然后我们通过随机森林模型对其训练，并对对该模型进行了优化。
# 导入数据基本处理阶段需要用到的api import pandas as pd import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a6c319fbce668cfdb929e965668ecd5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7881129ade303b89ea9d5709a95bcef7/" rel="bookmark">
			获取指定日期的前一个工作日
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求描述 获取指定日前的前一个工作日，比如需要获取2022年5月30日的前一个工作日，那就是2022年5月27日，这里还要考虑到节假日调休的情况，比如今年劳动节，2022年5月5日的前一个工作日是2022年4月29日。
实现代码 代码依赖第三方库：chinese_calendar
安装命令如下：
pip install chinese_calendar 获取代码方式 关注微信公众号“白术的Python自动化实战”，后发送信息“获取前一个工作日”，即可获得代码下载链接
拓展 这个代码只需要改变第8行和第10行的数字，就可以拓展为“获取指定日期前或后的第几个工作日”
例如需要获取指定日期后第三个工作日，就把数字改为+3：
中秋假期为9.10-9.12，所以9.9之后的第三个工作日是9.15
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e6cd54d24570e6071253c2eae22997/" rel="bookmark">
			深入剖析 Python 最常用数据结构：列表(List) &amp; 元组(Tuple)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 定义 列表和元组，都是一个可以放置任意数据类型的有序集合。
在大多数编程语言中，集合内元素的数据类型必须保持一致，但在 Python 的列表与元组中，没有这个约束。
示例 列表 List = [‘Tom’, 22, 33, ‘tony’]
元组 Tuple = (‘China’, 10)
如上列表与元组的示例，列表与元组集合内同时存放了 int 类型和 string 类型的元素
2. 区别 列表是动态的，长度大小不固定，可以随意地新增、删除、修改集合内元素
input:
test_list = ['Tom', 22, 33, 'tony'] test_tuple = ('jack', 10) # test_list新增元素 test_list.append('100') test_list.append('200') print(test_list) # test_list修改元素 test_list[0] = 'xiaomin' print(test_list) # test_list删除元素 test_list.pop() print(test_list) output:
['Tom', 22, 33, 'tony', '100', '200'] ['xiaomin', 22, 33, 'tony', '100', '200'] ['xiaomin', 22, 33, 'tony', '100'] 从输入，输出可以证明列表支持集合内元素的新增、删除、修改
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09e6cd54d24570e6071253c2eae22997/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bb42bf6aa6e281a78119145aa8fd2fc/" rel="bookmark">
			学 Python 这么久，终于把类函数 &amp; 成员函数 &amp; 静态函数给整明白了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 学过 Python 的小伙伴应该知道，在类定义过程中，会依据对具体需求的分析，对类函数,成员函数,静态函数进行声明与定义。
Python 基础稍弱的同学可能会对这三个函数的名称有些陌生，但你很有可能曾经见到过他们仨，只是没认出来而已(开个玩笑哈~)
下面将会对他们仨一一介绍，让你下次再见到他们仨时不再感到陌生。
类函数 1. 定义 使用@classmethod装饰器修饰的函数，且函数第一个参数为cls，表示该类函数被调用时第一个参数必须传入一个类。
2. 代码示例 @classmethod def create_new_init(cls,name,age): return cls(name=name, age=age, nation='china') 3. 作用 类函数最常用的功能是实现不同的init构造函数，如上面的代码示例。
在声明类函数时，前面会有__init__构造函数，此处省略__init__构造函数的代码。
从类函数的代码示例中，也可以推断出__init__构造函数的内容，定义了name,age,nation三个属性，由类对象定义时传入的参数决定对象的这三个属性值。
类函数可以访问和修改对象的属性，例如代码示例中的nation='china'就对属性nation进行了修改，固定其值为china，不受对象定义时传入的参数影响。
成员函数 1. 定义 成员函数是最正常的类的函数，它不需要使用任何装饰器修饰声明，第一个参数self代表当前对象的引用，也可以传入其他参数。
可以通过此函数，来实现想要的查询 或 修改类的属性等功能。
2. 代码示例 def get_length_name(self): return len(self.name) 3. 作用 成员函数可以访问和修改对象的属性，例如代码示例中的len(self.name)就是对对象的name属性进行访问并计算其长度。
静态函数 1. 定义 使用@staticmethod装饰器来修饰的函数，静态函数与类没有什么关联，不访问和修改对象的属性。
相较于类函数与成员函数，静态函数的第一个参数没有任何特殊性，只是普通的形参，如代码示例中的的参数msg。
2. 代码示例 @staticmethod def get_message(msg): return str(msg).split(':')[0] 3. 作用 静态函数可以用来做一些简单独立的任务，比较方便测试，同时也能优化代码结构。
如果一个函数不需要访问或修改这个类对象的属性，如果将其放到类外面似乎有点不恰当，此时静态函数是一个不错的选择。
欢迎关注 无量测试之道 公众号，回复：领取资源
Python+Unittest框架API自动化、
Python+Unittest框架API自动化、
Python+Pytest框架API自动化、
Python+Pandas+Pyecharts大数据分析、
Python+Selenium框架Web的UI自动化、
Python+Appium框架APP的UI自动化、
Python编程学习资源干货、
Vue前端组件化框架开发、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bb42bf6aa6e281a78119145aa8fd2fc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ac24bb3d28a4f71fd8f9f6a8e2350d/" rel="bookmark">
			实战|轻松用 Python 开发一个简单有趣的聊天小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Internet 协议集支持一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。
UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。
UDP 的特性：它不属于连接型协议，因而具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用 UDP 较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。
比如我们聊天用的 QQ 就是使用的 UDP 协议。
——摘自百度百科
今天的分享内容是使用 Python 结合 UDP传输协议 来开发一个简单的聊天小程序
环境准备 1. 准备工具：网络调试助手 如下图所示，选择UDP测试这个 tab 栏
2. 本地&amp;目标 ip 与 port 配置 1）本地端口这栏需要配置一个指定的端口并绑定，因为在 Python 程序中需要指定这个 ip 地址和绑定的 port 号来接收信息
2）目标 IP 与目标端口也需要配置，用于 Python 程序接收从网络调试助手页面发送的消息，目标 IP 我这里和本地 IP 是一致的，目标端口则是 Python 程序中代码指定的
代码实战 import socket class UdpMessage: def send_message(self, udp_socket): # 接收控制台输入的需发送消息的内容 msg = input('请输入您要发送的信息：') try: # 接收控制台输入的发送对象的实际ip地址 dest_ip = input('请输入您要发送对象的ip地址：') # 接收控制台输入的发送对象的实际port地址，port必须是int类型，使用int强转 dest_port = int(input('请输入您发送对象的端口号：')) # 调用sendto方法先将消息内容进行utf-8的编码，后再将消息发送至目标对象 udp_socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51ac24bb3d28a4f71fd8f9f6a8e2350d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3a9b11cefa972f60dac9eb33377c38/" rel="bookmark">
			RT-Thread 学习记录之 IPC （线程间同步）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RT-Thread 学习记录之 IPC （线程间同步） 文章目录 RT-Thread 学习记录之 IPC （线程间同步）IPC 简介源码简析基础结构信号量互斥量事件集 补充优先级翻转问题生产者消费者模型 IPC 简介 IPC 是保证多线程之间协助关系和数据传递的一种机制。当系统里有多个任务运行时，经常需要互相无冲突地访问同一个共享资源，比如一些全局变量之类，这时操作系统必须具有对任务运行进行协调的能力，也就是 IPC 机制。
RT-Thread 支持的基础 IPC 有：信号量（sem）、互斥量（mutex）、事件集（event）、邮箱（mailbox）、消息队列（messagequeue）。
源码简析 在此仅对线程间同步部分做简析，即信号量、互斥量、事件集三种。
基础结构 IPC 对象基础数据结构：
struct rt_ipc_object { struct rt_object parent; /* 父对象 */ rt_list_t suspend_thread; /* 挂起线程链表 */ }; rt_ipc_object_init （通过调用 rt_list_init 进行 IPC 链表初始化）：
rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc) { /* IPC 链表初始化 */ rt_list_init(&amp;(ipc-&gt;suspend_thread)); return RT_EOK; } rt_ipc_list_suspend（此函数将挂起 IPC 对象列表的线程。） ：
rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t *list, struct rt_thread *thread, rt_uint8_t flag) { /* 挂起 IPC 所在线程 */ rt_thread_suspend(thread); /* 判断 IPC 初始化设置的模式 */ switch (flag) { /* FIFO（先入先出）模式 */ case RT_IPC_FLAG_FIFO: /* 将此线程插入挂起链表表尾 */ rt_list_insert_before(list, &amp;(thread-&gt;tlist)); break; /* RT_IPC_FLAG_FIFO */ /* PRIO（优先级）模式 */ case RT_IPC_FLAG_PRIO: { struct rt_list_node *n; struct rt_thread *sthread; /* 寻找合适的位置 */ for (n = list-&gt;next; n !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac3a9b11cefa972f60dac9eb33377c38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3846e8e5c831e95f177091fae9cc0254/" rel="bookmark">
			RecyclerView详解一，使用及缓存机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文大致会先讲解RecyclerView的基础知识及使用，最后会深入讲解一点原理。当然，本人知识水平有限哈，太深入的东西我现在还没接触到，还请大家包容，阿里嘎多~
一、RecyclerView的历史与发展 既然讲到了RV，那不得不先知道它怎么来的。
RecyclerView是Android 5.0提出的新的UI控件，与其一起诞生的还有著名的Material Design以及CardView等新特性。最初位于support.v7包中，这里既然提到了v7，那我就简单介绍一点v4，v7包以及androidx的历史发展。support-v4是Android 3.0推出的库，为了加入Fragment以及向下兼容老系统，即最低兼容到Android 1.6。support-v7向下兼容到Android 2.1，这两个库中包含有RecyclerView、ViewPager等常用控件。随着时间的推移，现在的Android系统已经发展到13了，显然这两个库就有些跟不上时代了，于是从Android 9.0开始，Google推出了androidx，以后推出的所有新特性都会加入到androidx中，并且androidx包下面的API都是随着扩展库发布的，这些API基本不会依赖于操作系统的具体版本，所有命名中它就不再包含版本号了。
所以，现在我们使用的RecyclerView都是包含在androidx包中。我们最开始学Android的时候肯定都接触过ListView，ListView的功能也很强大，在RecyclerView没出现之前，开发者们使用的都是ListView来展示大量的数据。但是ListView的性能比较差，之后我会对比一下二者的缓存策略，扩展性也不是很好，所以具有更加强大功能的RecyclerView诞生了。它包含有横向纵向排列的LinearLayoutManager、网格排列的GridLayoutManager和瀑布流排列的StaggeredGridLayoutManager。下面我先来带大家简单了解一下RecyclerView的使用。
二、RecyclerView的使用 这部分我不会讲很多，毕竟学会使用它也不是很难，具体的大家可以去参考一下《第一行代码》，本文的重点还是放在更深一点的缓存策略，回收复用，LayoutManager 以及 ItemTouchHelper等分析上。
（1）创建数据列表 这里演示的就不搞那么复杂了
class Data(val string: String) （2）创建Adapter class BasicAdapter(private val dataList: List&lt;Data&gt;) : RecyclerView.Adapter&lt;BasicAdapter.ViewHolder&gt;() { inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) { val dataString: TextView = view.findViewById(R.id.tv_str) } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder { val view = LayoutInflater.from(parent.context) .inflate(R.layout.title_item, parent, false) return ViewHolder(view) } override fun onBindViewHolder(holder: ViewHolder, position: Int) { val data = dataList[position] holder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3846e8e5c831e95f177091fae9cc0254/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fd3d5f80c2626e3b36e33cc88fc19a9/" rel="bookmark">
			Windows 和 Linux 系统下，如何区分相同PID VID 的USB-HID设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言
最近项目中，再次使用到USB设备，而项目需要是在系统中，也就是一台电脑同时使用两个USB涉设备。这两个USB设备，底层固件一模一样，因此，两个设备在系统中枚举出来的 PID 和 VID 是一样的。由于以前项目上，一般都是使用一个设备，在使用代码查找目标HID 设备时，都是只使用PID 和 VID 。因此，如何解决，在一个操作系统中，怎么区分相同PID 和 VID 两个设备，并同时与其通讯，由此，写下这篇文章记录。
二、关于USB-HID设备
可以查看我之前的文章，已经分享很多篇，这里不再赘述。
三、在系统中如何区分相同PIV 和 VID 的USB-HID 设备
1. 在windows 使用 USB-TreeView 软件查看，usb 设备的详细信息，
2. 根据USB规范的定义，所有的USB设备都用供应商ID（VID）和产品识别码（PID），主机通过不同的VID和PID来区别不同的设备，VID和PID都是两个字节长，其中，VID由供应商向USB执行论坛申请，每个供应商的VID是唯一的，PID由供应商自行决定，理论上来说，不同的产品、相同产品的不同型号、相同型号的不同设计的产品最好采用不同的PID，以便区别相同厂家的不同设备。
3. 但是呢， 在实际上由于设备厂家为了方便，一般相同型号的设备，PID 和 VID 都是一样的，很少会去给每个设备分配不同的ID。并且，同款产品，每个设备要保证PID 和 VID 不同，是非常困难的一件事情，并且成本高。
4. 在实际更多的厂家中，为了方便管理，不同型号的usb设备，其设备的PID 和 VID 都是一样。
这样子操作对于开发者都是非常方便。
5. 当有多个vid，pid相同的usb设备一起插入到电脑上，他们在系统的USB是通用串行总线上都是可以识别出来的。因此当一个usb 设备插入总线上会自动分配一个地址给该设备，每个设备都具有唯一的地址。
因此，当上面，提到当有多个vid，pid相同的usb设备一起插入到电脑上，usb 设备总线，也会分别给它们在分配一个地址，这个地址在总线上是唯一的，不会重复。
7. 根据上面所述，可以的得出，假设，有多个vid，pid相同的usb设备一起插入到电脑上，如何来区分到底是哪一个usb设备？可以根部不同设备在USB总线上地址来区分。
四、在Windows上
1. 使用Win API 寻找USB设备，在获读取设备的信息，可以看到返回设备的地址，如图
这个是设备在系统中唯一的地址，具体代码如下，
当遇到，目标设备的PID 和 VID 保存对应的strtDetailData-&gt;DevicePath, 即可，后续使用时，直接调用CreateFile(), 打开设备记录。 strtDetailData-&gt;DevicePath 每个设备不一样，可以确保操作的是目标设备。
五，在Linux 系统上
在linux操作，一般使用的是libusb, 使用libusb 库中的testlibusb 例程，调用打印可以发现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fd3d5f80c2626e3b36e33cc88fc19a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3f6b11b176f811e24aad2547d9b9af5/" rel="bookmark">
			十六进制与rgb颜色转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十六进制转换为RGB const hexToRGB = hex =&gt; { let alpha = false, h = hex.slice(hex.startsWith('#') ? 1 : 0); if (h.length === 3) h = [...h].map(x =&gt; x + x).join(''); else if (h.length === 8) alpha = true; h = parseInt(h, 16); return ( 'rgb' + (alpha ? 'a' : '') + '(' + (h &gt;&gt;&gt; (alpha ? 24 : 16)) + ', ' + ((h &amp; (alpha ? 0x00ff0000 : 0x00ff00)) &gt;&gt;&gt; (alpha ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3f6b11b176f811e24aad2547d9b9af5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39d6b7d0b55438d2923ec2779b5ffbf4/" rel="bookmark">
			random链表的深拷贝
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一种特殊的单链表节点类描述如下
static class Node{ int val; Node next; Node random; public Node(int val){ this.val = val; } } random 指针是单链表节点结构中新增的指针,random可能指向链表的任意一个节点,也可能指向null.
给定一个Node 节点类型组成的无环链表的节点head ,请实现一个函数 完成这个函数完成这个链表的深拷贝,并返回复制新链表的头结点.
要求时间复制度为O(N) 空间复制度为O(N)
使用容器
public static Node copyRandomList(Node head){ if(head==null){ return head; } Map&lt;Node,Node&gt; map = new HashMap&lt;&gt;(); Node cur = head; while(cur!=null){ map.put(cur,new Node(cur.val)); cur = cur.next; } cur = head; while(cur!=null){ map.get(cur).next = map.get(cur.next); map.get(cur).random = cur.random!=null ? map.get(cur.random) : null; cur = cur.next; } return map.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39d6b7d0b55438d2923ec2779b5ffbf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d079bb34995863bea98a262aa26543d6/" rel="bookmark">
			链表的荷兰国旗问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将单向链表按某值划分成左边小.中点相等,右边大的形式.
链表问题还是可以有两种解法:(使用容器和不使用容器)
1) 把链表放入数组中,在数组上做patition(使用容器)
public static Node patition(Node head,int num){ if(head==null || head.next==null){ return head; } List&lt;Node&gt; list = new ArrayList&lt;&gt;(); Node cur = head; while(cur!=null){ list.add(cur); cur = cur.next; } int index = 0; int lessL = -1; int moreR = list.size(); while(index&lt;moreR){ if(list.get(index).val&lt;num){ swap(list,index++,++lessL); }else if(list.get(index).val&gt;num){ swap(list,index,--moreR); }else{ index++; } } for(int i = 1;i&lt;list.size();i++){ list.get(i-1).next = list.get(i); } return list.get(0); } private static void swap(List&lt;Node&gt; list,int x,int y){ Node tem = list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d079bb34995863bea98a262aa26543d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/877fc3a89d50e3cd1b81ce87e727ff10/" rel="bookmark">
			回文链表的解法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是回文结构?
回文结构就是正着读和倒着读都一样!!!
链表题的策略就是一个有容器的解法和没容器的解法.
首先我们要抓住中点就是---&gt;分别从头遍历和从尾遍历,看看分别是否相等
有容器:
public static boolean isPalindrome1(Node head){ if(head==null || head.next==null){ return true; } Node cur = head; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while(cur!=null){ stack.push(cur); cur = cur.next; } while(!stack.isEmpty()){ if(stack.pop().val!=head.val){ return false; }else{ head = head.next; } } return true; } 首先栈的结构正好能够满足倒叙的要求.(或者放在数组中,从后往前遍历)
无容器策略:
对于节点个数为奇数个的链表:
首先: 1-&gt;2-&gt;3-&gt;4-&gt;5
首先我们先找到中节点 就是-&gt;节点3
然后逆序使链表变成这样: 1-&gt;2-&gt;3&lt;-4&lt;-5
节点3的next指向空,这样就能从前往后遍历,知道两个引用相等
节点个数为偶数的链表我们取上中点视为中点开始逆序,直到 前面的引用指向了null
public static boolean isPalindrome(Node head){ if(head==null || head.next==null){ return true; } Node fast = head; Node slow = head; while(fast.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/877fc3a89d50e3cd1b81ce87e727ff10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1728a42820d06874f4066da2c664aab/" rel="bookmark">
			WSL sudo不能用了？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你使用 sudo 会出现以下报错提示信息时，那么不妨可以试试我的解决办法
sudo: /etc/sudoers is owned by uid 1000, should be 0 sudo: no valid sudoers sources found, quitting sudo: unable to initialize policy plugin 首先运行以下命令
su root 它将询问密码，然后逐个运行以下命令
chown root:root /etc/sudoers chmod 440 /etc/sudoers chown -R root:root /etc/sudoers.d chmod 755 /etc/sudoers.d chmod 440 /etc/sudoers.d/* 然后在使用 sudo 就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b198695cb72f1d425af4c4f5af74c49f/" rel="bookmark">
			Latex常见语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、输入公式 用$$,在第一个$和第二个$中间输入字符。如：
当输入$a$时，结果为 a a a
2、公式居中 居中的格式是四个$，在第二个$和第三个$中间输入字符。
当输入$ $ a $ $时(此处为了显示方便在字符中间插入了空格，输入时去掉空格即可)，结果为 a a a
3、分数 输入格式：$\frac{a}{b}$
显示内容： a b \frac{a}{b} ba​
4、上标 输入格式：$a^2$
显示内容： a 2 a^2 a2
5、下标 输入格式：$a_1$
显示内容： a 1 a_1 a1​
6、上下标 输入格式：$a_1^2$ 或者 $a^2_1$，不区分上下标的前后。
显示内容： a 1 2 a_1^2 a12​ a 1 2 a^2_1 a12​（按上述两种方式分别输入的结果）
4、根号 输入格式：$\sqrt{a}$
显示内容： a \sqrt{a} a ​
5、积分 输入格式：$\int{xdx}$
显示内容： ∫ x d x \int{xdx} ∫xdx
6、求和 输入格式：$\sum_{n=a}^bn$
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b198695cb72f1d425af4c4f5af74c49f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99355294ac7550e0d230d8f8509add2a/" rel="bookmark">
			Stream 流 根据对象属性去重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、实现原理
二、实现过程
三、filter过滤器的原理
总结
前言 这篇文章介绍一种通过stream流对集合中的对象根据key值去重的简便方法。
一、实现原理 通过Stream流中的filter方法实现对数据的去重，具体操作是构造一个Predict对象，在Predict中通过检查数据是否存在返回断言中的布尔值。
二、实现过程 代码如下：
public static &lt;K&gt; Predicate&lt;K&gt; distinctPredicate(Function&lt;K,Object&gt; function){ ConcurrentHashMap&lt;Object, Boolean&gt; map = new ConcurrentHashMap&lt;&gt;(); return (t)-&gt; null == map.putIfAbsent(function.apply(t),true); } // 测试代码 public static void main(String[] args) { HashMap&lt;String, Object&gt; map1 = new HashMap&lt;&gt;(); map1.put("key1","value1"); HashMap&lt;String, Object&gt; map2 = new HashMap&lt;&gt;(); map2.put("key1","value1"); ArrayList&lt;Map&gt; maps = new ArrayList&lt;&gt;(); maps.add(map1); maps.add(map2); List&lt;Map&gt; distinctMap= maps.stream().filter(distinctPredicate(m -&gt; m.get("key1"))).collect(Collectors.toList()); } 对于上面代码distinctPredicate方法，我是有一点疑惑的，因为在我看来filter方法每次调用distinctPredicate方法，都会重新初始化ConcurrentHashMap&lt;Object, Boolean&gt; map = new ConcurrentHashMap&lt;&gt;()这行代码，这就意味着，这个方法的map对象里永远只会有一个值，那么也就不会出现存在key就put的情况。如果你也有这样的疑问，下面有这个问题的答案。 三、filter过滤器的原理 下面是filter中的源码部分，通过接口中的注释可以看到filter对每一个输入的元素都执行一次predicate的test方法，从而决定集合中是否需要包含这个元素。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99355294ac7550e0d230d8f8509add2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a5b34257e884dd1615de3f26ed2cce0/" rel="bookmark">
			Nacos注册中心集群数据一致性问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos集群数据一致性问题 一、集群架构1.1 Master - Slave1.2 Leader - Follower 二、Nacos注册中心集群架构2.1 DistroConsistencyServiceImpl2.1.1 init() 方法2.1.2 load() 方法2.1.3 Notifier 线程(事件监听)2.1.4 put(String key, Record value) 方法2.1.5 TaskDispatcher2.1.6 DataSyncer2.1.7 Nacos 分区一致性算法总结 2.2 RaftConsistencyServiceImpl2.2.1 Raft算法2.2.2 Nacos中Raft算法的具体实现2.2.2.1 RaftPeerSet(Leader选举)2.2.2.2 RaftCore1. RaftCore init()2. Notifier 线程(事件监听)3. MasterElection 线程(投票选举)4. HeartBeat 线程(心跳检测)5. RaftCore.signalPublish() 2.2.3 Nacos Raft算法总结 文章系列
【一、Nacos-配置中心原理解析】
【二、Nacos-配置中心原理解析】
【三、Nacos注册中心集群数据一致性问题】
一、集群架构 1.1 Master - Slave 也就是我们说的主从复制，主机的数据更新后根据配置和策略，自动同步到备机的master/slave机制，当主节点宕机后，集群会根据某种分布式一致性协议(Raft、gossip协议、ZAB协议等)选举出新的Master节点。
Master负责读写，Slave只负责读。
在很多组件中都有使用这种思想，比如Mysql主从架构、Redis主从架构、kafka里面的数据副本机制等等。
常见的主从复制架构有：
一主多从
主主复制
级联复制
多主一从
1.2 Leader - Follower 这也是比较常见的集群架构，各自职责如下：
Leader：领导者，主要的工作任务有两项
事物请求的唯一调度和处理者，保证集群事物处理的顺序性集群内部各服务器的调度者 Follower：跟随者，主要职责是
处理客户端非事物请求、转发事物请求给 Leader 服务器参与事物请求的投票，如Zookeeper半数以上Follower通过才能通知 Leader commit数据参与Leader选举的投票 在很多组件中都有使用这种思想，比如ZooKeeper集群等等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a5b34257e884dd1615de3f26ed2cce0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b201cddb32f0fc057178854727933a15/" rel="bookmark">
			Nacos-注册中心原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nacos-注册中心原理解析 一、注册中心二、Nacos注册中心原理解析2.1 NamingService2.2 NacosNamingService2.2.1 NamingProxy2.2.2 BeatReactor2.2.3 HostReactor2.2.3.1 FailoverReactor2.2.3.2 PushReceiver 2.3 服务注册2.3.1 namingProxy.registerService2.3.1 服务端InstanceController2.3.1.1 serviceManager.registerInstance2.3.1.2 Service 服务对象2.3.1.3 Cluster 集群对象 2.4 服务发现2.4.1 hostReactor.getServiceInfo2.4.2 hostReactor.updateServiceNow2.4.3 hostReactor.processServiceJSON2.4.4 hostReactor.scheduleUpdateIfAbsent2.4.5 UpdateTask（HostReactor的内部类）2.4.6 hostReactor.getServiceInfoDirectlyFromServer2.4.6 服务端接受客户端请求返回 2.5 心跳检测机制2.5.1 客户端发送心跳包(BeatReactor)2.5.2 服务端心跳检查(ClientBeatCheckTask) 2.6 服务列表变化通知2.6.1 客户端定时发送更新请求(UpdateTask)2.6.2 服务信息发现变化时，主动通知 三、总结 文章系列
【一、Nacos-配置中心原理解析】
【二、Nacos-配置中心原理解析】
【三、Nacos注册中心集群数据一致性问题】
一、注册中心 服务注册与发现是微服务架构得以运转的核心功能，它不提供任何业务功能，仅仅用来进行服务的发现和注册，并对服务的健康状态进行监控和管理。
其核心的工作原理：
服务提供者注册信息到注册中心上；服务消费者通过注册中心获取服务地址列表；注册中心动态感知服务的上线与下限(心跳)；服务列表变化通知（pull、push）； 二、Nacos注册中心原理解析 2.1 NamingService Nacos为服务注册与发现提供了一个SDK类 NamingService，通过该类，可以实现服务的注册与发现、订阅服务的动态变化、获取服务实例、获取注册中心的健康状态等等。
其中，NamingService中的接口，可以分为以下几类：
namingService.registerInstance()：注册实例namingService.deregisterInstance()：取消注册namingService.getAllInstances(String serviceName)：获取服务的所有实例namingService.getServicesOfServer(int pageNo, int pageSize)：分页查询，从服务器获取所有服务名称namingService.getSubscribeServices()：获取当前客户端所有订阅的服务namingService.selectInstances()：根据条件获取服务实例namingService.selectOneHealthyInstance()：根据条件选择一个健康的实例namingService.subscribe()：订阅服务以接收实例更改事件namingService.unsubscribe()：取消订阅namingService.getServerStatus()：获取服务器健康状态 创建 NamingService：
NamingService namingService = NacosFactory.createNamingService(properties); 获取 NacosNamingService 中带Properties形参的构造函数，然后反射创建。
public class NamingFactory { public static NamingService createNamingService(Properties properties) throws NacosException { try { Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b201cddb32f0fc057178854727933a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51f03e3f6ea66cd2bf660fe1e344aca0/" rel="bookmark">
			Springboot之Jasypt配置文件加密/解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jasypt配置文件加密/机密 一、Jasypt介绍二、Springboot整合Jasypt2.1 环境配置2.2 添加依赖2.3 添加Jasypt配置2.4 编写加/解密工具类2.5 修改配置文件2.5 如何进一步防止密码泄露2.5.1 自定义加密器2.5.3 加密盐值通过环境变量指定 文章系列
【一、Springboot之Jasypt配置文件加密/解密】
【二、Springboot之Jasypt配置文件加密/解密【源码分析】】
一、Jasypt介绍 前言
在大多数项目中，配置文件中的 mysql 数据库密码、redis 密码等其他敏感性密码都是以明文形式存在，这种配置本身没有任何问题，但是，在某些情况下，可能会对公司造成不可挽救的损失，比如：某一天，小明因为加班过度，头脑发昏，不小心把公司项目上传到自己的 GitHub 仓库里面了，导致的后果就是，公司数据库用户名密码泄露，被某些大佬加以利用…
所以，基于上面这种情况，加入配置文件中数据库用户密码等其他敏感信息都是经过加密处理过的呢？？？是不是可以大概率避免这种情况。Jasypt 因此应运而生。
什么是Jasypt？
Jasypt 是一个 java 库，可以使开发者不需要太多操作来给 Java 项目添加基本加密功能，而且不需要知道加密原理。Jasypt 为开发人员提供了一种简单易用加密功能，包括：密码认证、字符串加密等。
Jasypt 有哪些特点？
高安全性、基于标准的加密技术，适用于单向和双向加密。加密密码、文本、数字、二进制文件适合集成到基于 Spring 的应用程序中用于加密应用程序（即数据源）配置的集成功能 哪些信息要加密呢？
一般来说，项目配置文件里，所有涉及信息安全的配置项（或字段）都应该做处理，典型的比如：
数据库密码，如mysql第三方缓存中间件的密码，如 redis、mongodb其他中间件，如消息中间件、zk、nacos等各种第三方服务的 Access_Key… 二、Springboot整合Jasypt 2.1 环境配置 SpringBoot2.0以上Jasypt 3.0.3jdk8 2.2 添加依赖 创建一个 Springboot 项目，项目版本 2.0 以上，并添加 Jasypt 相关依赖。
&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.3&lt;/version&gt; &lt;/dependency&gt; 2.3 添加Jasypt配置 jasypt: encryptor: # 盐值 password: 123 # 指定加密方式 algorithm: PBEWithMD5AndDES iv-generator-classname: org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51f03e3f6ea66cd2bf660fe1e344aca0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1678812e298288953b4ec0095fd8f05/" rel="bookmark">
			git: Could not resolve hostname : Name or service not known
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景:
在docker 镜像里面,执行了一个从git clone的命令 . 启动镜像,就报错
Could not resolve hostname : Name or service not known
解决历程:
第一步, 在docker所在的主机,先执行git clone. 如果不报 以上错误.
当然会报git 的 pub key的问题,可以参考 配置ssh认证方式_我家小宝_朱朱的博客-CSDN博客_ssh 配置认证方式
说明可能是docker 容器 里面有问题 第二步: 启动docker 镜像,进入容器, 发现ping 不同 git的域名 解决: 重启docker , service docker restart 然后所有问题解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/966e4ad7f583c56eb82f7a0f35035833/" rel="bookmark">
			Animate.css在vue中的简易使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Animate.css的大致作用：在vue中引入后，可以通过简单的添加类名使元素有生动的效果
1.Animate.css的安装 npm安装
npm install animate.css 在main.js引入和使用
import animate from "animate.css"; 2.简单应用 给标签添加类名后便有动画效果
&lt;div class="animate__animated animate__fadeIn"&gt;内容部分&lt;/div&gt; 注意：
类名中一定要添加“animate__animated”
而“animate__fadeIn”为可替换部分
官网：Animate.css | A cross-browser library of CSS animations.
可替换其他动画（部分，详细请看官网👆）：
弹跳动画：animate__bounce
淡入淡出：animate__fadeIn（淡出则将“In”替换为“Out”）
.........
3.个人觉得比较实用用法 把router-view包装起来，当路由跳转展示出来的页面就会有动画效果，显得不会太生硬
&lt;transition enter-active-class="animate__animated animate__lightSpeedInRight" leave-active-class="animate__animated animate__lightSpeedOutRight" &gt; &lt;router-view /&gt; &lt;/transition&gt; 4. 动画效果不能滥用，否则会本末倒置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90bda7e37f132b1330a33174a3e0fc35/" rel="bookmark">
			《整理》JavaScript前端开发实习面试需知道的基础知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript基础中需要掌握的 1、数据类型、检测和转换。 JavaScript数据类型 数据类型
基础类型：Number、String、Boolean、undefined、null、Symbol、bigint
复杂类型：Object（Function / Array / Date / Math / Set / Map…）
类型检测
typeof、instanceof、toString、constructor 、isArray（isNumber、isString、isObject、isDate、…）
typeof 1 === 'number' //true typeof 'a' === 'string' //true // 不能使用typeof判断引用类型 typeof null === 'object' //true typeof {} === 'object' //true // 判断引用类型可以使用instanceof、Object.prototype.toString.call()、constructor // 判断变量是数组还是对象 var a = [] console.log(Object.prototype.toString.call(a)) //[Object Array] console.log(a.constructor == Array) //true console.log(a instanceof Array) //true console.log(Array.isArray(a)) //true instanceof、constructor 这两个弊端？
两个都返回false
类型转换
显示类型转换： Number（）、String（）、Boolean（）
隐式类型转换： 四则运算、判断语句、Native调用、Json方法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90bda7e37f132b1330a33174a3e0fc35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f3efd53af2dbac672ca0172fc427b1/" rel="bookmark">
			C语言趣味小游戏——扫雷（详解版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ​ 全篇无任何废话，本文的解释大多数都在代码段中，所以一定要看代码，边看边学边理解。 这只是初学者入门的一个小游戏，不难懂，没有什么复杂的内容
可以先学习一下比扫雷还简单的猜数字和三子棋
C语言趣味小游戏——猜数字
​C语言趣味小游戏——三子棋
游戏实现的条件（简单版） 1:创建三个文件
1:(test.c)：用于游戏的逻辑测试，游戏菜单的打印，游戏设计的展示
2:(game.c)：用于游戏功能的具体实现，游戏的核心代码
3:(game.h)：用于头文件的包含，符号以及函数的声明
2：先布置10个雷
3：扫雷
（1）：输入坐标，是雷游戏结束
（2）：输入坐标，不是雷，以坐标为中心，遍历周围的8个位置中有多少雷，就显示对应的数字
3：直到把所有非雷的位置找出来，游戏结束，扫雷成功
打印简易的菜单 1：先打印一个简单的菜单，过程不过多赘述，这个链接有详解
三子棋——打印一个简易的菜单
void menu() { printf("**********************\n"); printf("****** 1.play ******\n"); printf("****** 0.over ******\n"); printf("**********************\n"); } //	void test() { int input = 0; do { menu(); printf("选择 1 进入游戏,选择 0 退出游戏\n"); scanf("%d", &amp;input); switch (input) { case 1: // game(); 假设这是游戏 printf("扫雷游戏\n"); break; case 0: printf("退出游戏\n"); break; default: printf("请重新输入\n"); } } while (input); } // int main() { test(); return 0; } 雷盘的初始化 1：创建一个9*9的二维数组并且创建数组存放10个雷
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f3efd53af2dbac672ca0172fc427b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a0c367edddcd5b0ebbccc27a10e0278/" rel="bookmark">
			CS109: Probability for Computer Scientists笔记1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		维生素C吃多了会上火-个人CSDN博文目录
CS109: Probability for Computer Scientists, Summer 2022笔记合集
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc4ad7df58919de9cce0c2a7b5aeaf5/" rel="bookmark">
			维生素C吃多了会上火-个人CSDN博文目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 算法数学机器学习/深度学习/人工智能/数据分析PyTorch图机器学习/图神经网络GNN/图深度学习/图表示学习/图挖掘论文笔记情感计算比赛记录 计算机基础知识记录其他 算法 2022蓝桥杯算法知识点 数学 1.CS109: Probability for Computer Scientists, Summer 2022
机器学习/深度学习/人工智能/数据分析 PyTorch 图机器学习/图神经网络GNN/图深度学习/图表示学习/图挖掘 cs224w（图机器学习）2021冬季课程学习笔记集合 论文笔记 AI论文精度 情感计算 DAIC-WOZ数据集文论复现设计思路 比赛记录 计算机基础知识 计算机网络 记录 学习记录/计划 其他 从googleDriver下载贼大数据集 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed5a45747e27c0ba597c33e5e73c8edd/" rel="bookmark">
			小爱同学&#43;8266的小爱语音台灯，基于Blinker库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我们的动力源于对电子的热爱”
为大家详细介绍最近的语音台灯，不用了解各种通讯协议，直接调用函数，小白也会！
链接：https://pan.baidu.com/s/12m0TMhjH7SR9DHA_pTowBg?pwd=m4zf 提取码：m4zf
目录
想法的产生
软件描写
使用Blinker.app 将设备接入米家
Arduino IDE
环境搭建：
EC11编码按键
WS2812
工程代码
代码详解
硬件搭建 灯板
台灯主板
亮度控制
电池充电芯片4056
灯板供电升压 芯片XL6007E1
ESP-12S
供电切换
WS2812焊接
外壳
工程链接
想法的产生 刷B站时发现一位博主 用8266+blinker库制作了一个语音台灯，讲解的非常详细
原视频链接：
ESP8266联动小爱同学/点灯科技远程控灯，小白也能轻松搞定。_哔哩哔哩_bilibili
会用到的点灯科技公司网址：点灯科技-点灯物联网解决方案
有不懂的可以直接查看开发文档，遇到的问题都可以在论坛上查到
我能不能做一个像米家台灯一样的物联网台灯呢，于是就有了这个项目
台灯要可以小爱同学语音控制，还可以在手机上查看台灯的状态信息，还有实体按键控制
8266-12s + EC11编码按钮 + WS2812
软件描写 使用Blinker.app 需要到点灯科技官网下载
注册好后进入此界面（台灯是我已经注册好的） ，点击右上角+添加设备，点击独立设备
我用的ESP8266，所以选择网络接入，接下来生成密钥（设备身份证）
界面就会生成新的设备了， 可以点击编辑按钮添加组件，当组件触发后只需要在8266中的回调函数执行相应任务就行了 将设备接入米家 需要8266烧入代码，点灯科技有示例代码，认真看就懂
#define BLINKER_WIFI #define BLINKER_MIOT_LIGHT //小爱同学light接口函数 #include &lt;Blinker.h&gt; char auth[] = "********"; //换成APP获取到的密匙 char ssid[] = "********"; //WiFi账号 char pswd[] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed5a45747e27c0ba597c33e5e73c8edd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eaba10eb545c681de97b5d08a4b8d1ba/" rel="bookmark">
			Sublime Text3 最简单的修改字体的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sublime text 3是Preference→Settings 然后就是下面的界面。复制下面两行文字放进去即可。
"font_face": " ", //把双引号里写上你喜欢的字体就OK "font_size": 12 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/533c78db6b7bf730c1829ff35f803428/" rel="bookmark">
			Sublime Text 最简单的更换主题和字体颜色的办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在我重新开始写前端代码的时候，我突然发现现在自己Sublime Text3中的代码字体和颜色看起来怎么这么刺眼，给人一种再看几眼眼睛快要瞎了的感觉，因此我就在Github上找了几款比较好看的主题，在这里推荐给大家！
安装 简单的 自动安装
通过 ctrl+ shift+p 调出命令板，在命令板中输入 pci 并回车，在新出现的窗口中输入自己想要下载的主题名字后，点击下载即可。
更换主题和字体颜色 1）设置颜色
点击Sublime text3工具栏上[Preferences] --&gt;Select Color Theme --&gt; 选中：Monokai，就可以更换字体颜色了。 2）设置主题 点击Sublime text3工具栏上[Preferences] --&gt;Select Theme --&gt; 选中：Seti，就可以更换主题了。 这里推荐两款好看的主题 (一)Afterglow—monokai（推荐指数 ☆☆☆☆） 强烈推荐—这一配色相对Monokai主题来说语言高亮部分显得亮度没有那么刺眼，比较柔和
（二）Monokai（推荐指数 ☆☆☆☆） Monokai这一款配色适合于之前习惯在其他软件中使用Monokai这一主题的小伙伴。该主题仅有一款配色，即Monokai主题色本色。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b825bdb85de9f9c73afbf8e6ce17ce/" rel="bookmark">
			【HAL】STM32CubeMX学习笔记（一）——串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【HAL】STM32CubeMX学习笔记（一）——串口通信 前言串口通信串口通信思路软件部分代码设计串口发送部分串口接收部分串口接收数据解析部分 硬件部分代码设计 测试部分测试模板搭建测试 完整源码硬件部分完整源码软件部分完整源码 前言 关于STM32的串口通信之前的文章里有介绍过，传送门如下。
串口通信（往期）传送门
【串口通信】K210与STM32串口通信、K210与OpenMV串口通信
但是我觉得之前这一份代码还不够好用，因此我重制了一份。
本篇博文主要介绍STM32（HAL库）如何进行串口通信，使用的STM32型号为STM32F103ZET6，工程模板使用STM32CubeMX生成， 我将串口通信代码划分为了两部分，一部分为硬件部分，一部分为软件部分。 软件部分与库无关，不管是HAL库还是标准库都能用，硬件部分则是兼容HAL库或者标准库，本篇主要介绍HAL库的串口通信。 事实上，在其他平台，只要配置好串口，软件部分的代码也是能够通用的。
如果你需要标准库的串口通信，也可以看
【STM32】STM32标准库学习笔记（一）——串口通信
串口通信 串口通信思路 串口通信的思路就是发送端将数据打包发送，接收端从帧头开始接收数据，为了防止帧头和发送数据混在一起，所以设置两个帧头。当两个帧头都满足条件时才会继续接收，设置有效数据长度位是为了方便灵活接收不同长度的数据，比如有效数据长度位是2，则有data[0]和data[1]两个数据，最后再接收一位校验位，若校验通过则解析并保存数据。
帧头1帧头2有效数据长度位data[0]……data[n]校验位 软件部分代码设计 依据上面的串口通信思路，同时为了方便定义变量，定义结构体来保存各类变量， 在需要定义新变量的时候使用结构体定义即可。这部分保存在uartprotocol.h中，完整源码在文章末尾。
// 串口发送相关结构体 typedef struct { uint8_t	head1;	// 帧头1 uint8_t	head2;	// 帧头2 uint8_t length;	// 有效数据长度 uint8_t cnt;	// 总数据长度 uint8_t data[40];	// 有效数据数组 uint8_t transmit_data[50];	// 实际发送的数组 附带上帧头1 帧头2 有效数据长度位 校验位 }DataTransmit; // 串口接收相关结构体 typedef struct { uint8_t	head1;	// 帧头1 uint8_t	head2;	// 帧头2 uint8_t length;	// 有效数据长度 uint8_t cnt;	// 总数据长度 uint8_t state;	// 接收状态 uint8_t i;	// 有效数据下标 uint8_t data;	// 接收数据缓冲位 uint8_t receive_data[50];	// 实际接收的数组 附带上帧头1 帧头2 有效数据长度位 校验位 }DataReceive; // 接收数据解析相关结构体 typedef struct { uint16_t	x;	// 目标x轴坐标 uint16_t	y;	// 目标y轴坐标 uint8_t color;	// 目标颜色标志位 uint8_t shape;	// 目标形状标志位 uint8_t flag;	// 目标标志位 }TargetProperty; 串口发送部分 定义串口发送数据结构体初始化函数 Data_Transmit_Init
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3b825bdb85de9f9c73afbf8e6ce17ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bca449ff12323bb83bced4d4121b81ee/" rel="bookmark">
			C&#43;&#43;11多线程部分知识点 &#43; 多线程顺序执行 &#43; 交替打印字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在Linux下操作C的API pthread相关函数 写多线程，或者使用Qt的QThread实现多线程编程，不太具备通用性C++11相较于C++98添加了蛮多的多线程编程的特性，本文记录下其中部分知识。 1. 基础知识 C++ 多线程编程入门基础： 学习链接
C++并发编程 - 同步并发操作:添加链接描述
2. 按序打印 代码解法类似 1.基础知识 里面的最后一个案例
class Foo { public: Foo() { } void first(function&lt;void()&gt; printFirst) { // printFirst() outputs "first". Do not change or remove this line. printFirst(); flag1 = true; cv.notify_all(); } void second(function&lt;void()&gt; printSecond) { unique_lock&lt;mutex&gt; loc(m); while(flag1==false){ cv.wait(loc); } // printSecond() outputs "second". Do not change or remove this line. printSecond(); flag2 = true; cv.notify_all(); } void third(function&lt;void()&gt; printThird) { unique_lock&lt;mutex&gt; loc(m); while(flag2==false){ cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bca449ff12323bb83bced4d4121b81ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3775b51a671667b07419897769292c63/" rel="bookmark">
			【MySql】MySQL概述及其语法概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.MySQL概述 1.1数据库相关概念 名称全称简称数据库有组织的进行存储数据的仓库DataBase（DB）数据库管理系统操纵和管理数据库的大型软件DataBase ManagementSystem (DBMS)SQL操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准Structured QueryLanguage (SQL) 目前主流的关系型数据库管理系统:
不论我们使用的是上面的哪一个关系型数据库，最终在操作时，都是使用SQL语言来进行统一操作，SQL语言是操作关系型数据库的统一标准 。
1.2 MySQL数据库 1.2.1下载与安装 官网：https://www.mysql.com/cn/
###　1.2.2配置环境变量
配置环境变量，这样才可以在任何目录下连接MySQL。
1.2.3启动停止 可以手动的通过指令启动停止，以管理员身份运行cmd，进入命令行执行如下指令:
ps:注意：上述的 mysql80 是我们在安装MySQL时，默认指定的mysql的系统服务名，不是固定的，如果未改动，默认就是mysql80。
1.2.6客户端连接 ####　1). 方式一：使用MySQL提供的客户端命令行工具
2). 方式二：使用系统自带的命令行工具执行指令 [ ]内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果连接本地的MySQL，则无需指定这两个参数。
1.2.5 数据模型 1). 关系型数据库（RDBMS） 概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库(指的是由行和列组成的表，类似于Excel表格数据),不是基于二维表存储数据的数据库，就是非关系型数据库。
特点：
A. 使用表存储数据，格式统一，便于维护。
B. 使用SQL语言操作，标准统一，使用方便。
2). 数据模型 MySQL是关系型数据库，是基于二维表进行数据存储的。
操作过程：
A.我们可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。
B.可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。
连接 使用SQL语句操作(B) MySQL客户端 数据库管理系统DBMS 数据库DB 2. SQL语法概述 SQL全称 Structured Query Language，是结构化查询语言，定义了一套操作关系型数据库统一标准。
2.1基础语法 1). SQL语句可以单行或多行书写，以分号结尾。
2). SQL语句可以使用空格/缩进来增强语句的可读性。
3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。
4). 注释：单行注释：-- 注释内容或 # 注释内容 多行注释：/* 注释内容 */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3775b51a671667b07419897769292c63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958c321cc7a4c35b8bbfe24ce0c1bdf8/" rel="bookmark">
			Blazor错误处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件创建错误处理：
&lt;ErrorBoundary Context="错误"&gt; &lt;ChildContent&gt; &lt;FetchData/&gt; &lt;/ChildContent&gt; &lt;ErrorContent&gt; &lt;div class="alert alert-danger"&gt; @*BootStrap图标*@ &lt;svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bug-fill" viewBox="0 0 16 16"&gt; &lt;path d="M4.978.855a.5.5 0 1 0-.956.29l.41 1.352A4.985 4.985 0 0 0 3 6h10a4.985 4.985 0 0 0-1.432-3.503l.41-1.352a.5.5 0 1 0-.956-.29l-.291.956A4.978 4.978 0 0 0 8 1a4.979 4.979 0 0 0-2.731.811l-.29-.956z" /&gt; &lt;path d="M13 6v1H8.5v8.975A5 5 0 0 0 13 11h.5a.5.5 0 0 1 .5.5v.5a.5.5 0 1 0 1 0v-.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/958c321cc7a4c35b8bbfe24ce0c1bdf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5bd7dfd7e8f4566637dc94f2e3c3183/" rel="bookmark">
			Bayes‘ theorem贝叶斯定理(基础理论&#43;心理学小例子)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Bayes' theorem 1. 基本内容2. 例子与证明过程3. 应用场景 1. 基本内容 P ( H ∣ E ) = P ( H ) × P ( E ∣ H ) P ( E ) P(H|E)=\tfrac{P(H)\times P(E|H)}{P(E)} P(H∣E)=P(E)P(H)×P(E∣H)​
条件：B事件集 是 A事件集 的 子集
结论：
B在R中发生的概率 = A在R中发生的概率 X B在A中发生的概率 2. 例子与证明过程 Steve：A meek and tidy soul一个温顺而又井井有条的人, he has a need for order and structure, and a passion for detail.
那么，你认为以下哪种说法可能性更大：
Steven是一位农民Steven是一位图书管理员 以上是两位心理学家有关“人对事物的判断”、“什么时候这些判断与概率论定律建议的做法之间产生非理性的矛盾”研究的例子之一。
上述的这个例子就阐述了一个特定类型的非理性alleged irrationality
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5bd7dfd7e8f4566637dc94f2e3c3183/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd71f1d9c71b09033ce0454d35e86125/" rel="bookmark">
			让所有GUI都自动化-PyAutoGUI（GUI自动化工具）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、前言
2、简介
3、安装
4、常用函数
5、保护措施
6、鼠标函数
7、键盘函数
8、消息弹窗函数
9、截屏函数
‍10、示例
1、前言 在使用 Selenium 进行自动化测试时，鼠标事件可以用 ActionChains 类，键盘事件可以用 Keys 类。本篇将介绍一款自动化工具-PyAutoGUI，除了可以满足鼠标、键盘事件操作外，还可以进行消息弹窗、截屏等操作。
2、简介 PyAutoGUI 是一个纯 Python 的 GUI 自动化工具，其目的是可以用程序自动控制鼠标和键盘操作，多平台支持（Windows，macOS，Linux），并在 Python 2 和 3 上运行。
PyAutoGUI 可以模拟鼠标的移动、点击、拖拽，键盘按键输入、按住操作，以及鼠标+键盘的热键同时按住等操作，可以说手能动的都可以。
PyAutoGUI 有几个特点：
1、移动鼠标并单击其他应用程序的窗口。
2、向应用程序发送点击输入（例如，填写表格）。
3、截取屏幕截图，并给出一个图像（例如，一个按钮或复选框），然后在屏幕上找到它。
4、找到应用程序的窗口，然后移动、调整大小、最大化、最小化或关闭它（目前仅限 Windows）。
5、显示警报和消息框。
Github地址：
https://github.com/asweigart/pyautogui
3、安装 1、Windows 环境下
PyAutoGUI 没有任何依赖，因为它用 Python 的 ctypes 模块，所以不需要 pywin32。
pip3 install pyautogui 2、macOS 环境下
PyAutoGUI 需要 PyObjC 运行 AppKit 和 Quartz 模块。
sudo pip3 install pyobjc-core sudo pip3 install pyobjc sudo pip3 install pyautogui 3、Linux 环境下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd71f1d9c71b09033ce0454d35e86125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c7ded54c03ffcdf0f2b30eee5f3706/" rel="bookmark">
			深度学习（PyTorch）——flatten函数的用法及其与reshape函数的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flatten层用来将输入“压平”，即把多维的输入一维化，常用在从卷积层到全连接层的过渡。Flatten不影响batch的大小。
就是把高纬度的数组按照　ｘ轴或者ｙ轴　进行拉伸，变成一维的数组
为了更好的理解Flatten层作用，我把这个神经网络进行可视化如下图：（来自网络）
flatten(),默认缺省参数为0，也就是说flatten()和flatte(0)效果一样。
python里的flatten(dim)表示，从第dim个维度开始展开，将后面的维度转化为一维.也就是说，只保留dim之前的维度，其他维度的数据全都挤在dim这一维。
比如一个数据的维度是，flatten(m)后的数据为
案例程序如下：
import torch import torchvision from torch import nn from torch.nn import Linear from torch.utils.data import DataLoader dataset = torchvision.datasets.CIFAR10("./data_CIFAR10", train=False, transform=torchvision.transforms.ToTensor(),download=True) dataloader = DataLoader(dataset,batch_size=64) class Tudui(nn.Module): def __init__(self): super(Tudui, self).__init__() self.linear1 = Linear(196608,10) def forward(self,input): output = self.linear1(input) return output tudui = Tudui() for data in dataloader: imgs, targets = data print(imgs.shape) # output = torch.reshape(imgs,(1,1,1,-1)) output = torch.flatten(imgs) print(output.shape) output = tudui(output) print(output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52c7ded54c03ffcdf0f2b30eee5f3706/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1108ba942b9744f47f4d8543eb3fb6a/" rel="bookmark">
			Android 多行RadioGroup 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求如下：
思路有多种，可以用自定义布局、RecycleView、代码动态控制布局、RadioGroup 等方式实现；今天我用的RadioGroup ，实现思路如下:
布局文件如下：
&lt;RadioGroup android:id="@+id/three_rg" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/two_title" android:layout_marginTop="8dp" android:orientation="horizontal"&gt; &lt;RadioButton android:id="@+id/btn_1" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginRight="16dp" android:layout_weight="1" android:background="@drawable/radio_select_feedback" android:button="@null" android:checked="true" android:gravity="center" android:text="Task" android:textColor="@drawable/radio_select_feedback_textcolor" android:textSize="12sp" /&gt; &lt;RadioButton android:id="@+id/btn_2" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginRight="8dp" android:layout_weight="1" android:background="@drawable/radio_select_feedback" android:button="@null" android:gravity="center" android:text="Invitation" android:textColor="@drawable/radio_select_feedback_textcolor" android:textSize="12sp" /&gt; &lt;RadioButton android:id="@+id/btn_3" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginLeft="16dp" android:layout_weight="1" android:background="@drawable/radio_select_feedback" android:button="@null" android:gravity="center" android:text="Exchange" android:textColor="@drawable/radio_select_feedback_textcolor" android:textSize="12sp" /&gt; &lt;/RadioGroup&gt; &lt;RadioGroup android:id="@+id/four_rg" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_below="@id/three_rg" android:layout_marginTop="8dp" android:orientation="horizontal"&gt; &lt;RadioButton android:id="@+id/btn_4" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginRight="16dp" android:layout_weight="1" android:background="@drawable/radio_select_feedback" android:button="@null" android:checked="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1108ba942b9744f47f4d8543eb3fb6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/667a0b54920dc48b94b905eb6b555931/" rel="bookmark">
			CCS 快捷键查看和文字大小调整快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 快捷键查看 1.1首先打开属性 1.2属性窗口中点击keys 1.3 快捷键一览 2.文字大小调整 2.1当代码文字太小时，通过以下快捷键: Ctrl /Shift/ +
可以实现代码字体变大；
2.2当代码文字太大时，通过以下快捷键: Ctrl/-
可以实现文字代码变小；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2df92ff71961c9550654933255ac85ff/" rel="bookmark">
			单片机IO口模拟串口UART
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、模拟串口思路二、参考程序1.UART.h2.UART.c3.[程序地址](https://github.com/TimeCentury/STM32_Drive/tree/main/Softwate_UART) 一、模拟串口思路 UART使用时一般包含1个起始位、8个数据位、1个停止位，在不发送数据时UART为高电平表示空闲，在空闲模式下出现一个位的低电平表示起始位，紧随其后的是8个数据位和一个停止位，在其9600波特率下一个位的宽度为104微妙。
我的思路是使用一个定时器产生一个位宽时间除去3的中断，除3是因为要对一位进行三次采样以次数多的为准，如三次采样中高电平次数为2次，则为1，低电平次数为2则为0，进行三次采样的原因为防止采样点落在每一位的边沿上，而进行三次采样即使有一次落在边缘上也可以保证数据的准确性。
二、参考程序 1.UART.h /** * @Author: 时间世纪 * @Date: 2022-08-15 15:53:26 * @Description: 模拟串口,应定时调用UART_S_ReadDrive，UART_S_SendDrive函数， * UART_S_SendDrive定时时间为 1秒 / 想要的波特率 * UART_S_ReadDrive定时时间为 1秒 / 想要的波特率 / 3，除3是因为对1bit要进行三次采样以次数多的为准，如三次采样中高电平次数为2次，则为高电平 * 否则为低电平，进行三次采样的原因为防止采样点落在bit的边缘上，而进行三次采样即使有一次落在边缘上也可以保证数据的准确性，不建议超过9600波特率 * 如想要9600波特率，则定时时间为1秒 / 9600 / 3 = 34.7us，所以UART_S_ReadDrive为每34us调用一次，UART_S_SendDrive为每102us调用一次 * 如果想要4800波特率，则定时时间为1秒 / 4800 / 3 = 69.4us，所以UART_S_ReadDrive为每69us调用一次，UART_S_SendDrive为每207us调用一次 * 如果想要1200波特率，则定时时间为1秒 / 1200 / 3 = 277.7us，所以UART_S_ReadDrive为每277us调用一次，UART_S_SendDrive为每831us调用一次 * 如果两片单片机全部使用模拟串口通信也可以自定义波特率时间 */ #ifndef _UART_H_ #define _UART_H_ #include "HAL_Driver.h" #include &lt;stdio.h&gt; #include &lt;stdarg.h&gt; typedef struct { HAL_GPIO_TypeDef TX; HAL_GPIO_TypeDef RX; uint16_t RxState : 3;//发送状态 uint16_t RxTestCnt : 3;//读取IO计数 uint16_t RxHighCnt : 3;//高电平计数 uint16_t RxBitCnt : 4;//接收位计数 uint16_t RxReserve : 3;//保留 uint8_t RxData;//接收数据 uint8_t TxState : 3;//发送状态 uint8_t TxBitCnt : 4;//发送位计数 uint8_t TxBusy : 1;//发送忙标志 uint8_t TxData;//发送数据 uint8_t *TxBuf;//发送缓冲区 uint8_t TxBufLen;//发送缓冲区长度 uint8_t TxHeadIndex;//发送缓冲区头指针 uint8_t TxTailIndex;//发送缓冲区尾指针 uint8_t TxBufDataCnt;//发送缓冲区数据个数 void (*ReadCallback)(void *self, uint8_t dat);//读取回调函数 void (*ReadErrorCallback)(void *self, uint8_t errcode);//读取错误回调函数 } UART_S_TypeDef; /** * @brief 初始化一个模拟串口 * @param UART_S_TypeDef *pUART * @param uint8_t *TxBuf * @param uint8_t TxBufLen * @retval */ void UART_S_Init(UART_S_TypeDef * const pUART, uint8_t *TxBuf, uint8_t TxBufLen); /** * @brief 发送一个字节 * @param UART_S_TypeDef *pUART * @param uint8_t dat * @retval 0:成功 1:失败 */ uint8_t UART_S_SendByte(UART_S_TypeDef * const pUART, uint8_t dat); /** * @brief 发送数据 * @param UART_S_TypeDef *pUART * @param uint8_t *dat * @param uint8_t len * @retval 发送的字节数 */ uint8_t UART_S_SendBytes(UART_S_TypeDef * const pUART, uint8_t *dat, uint8_t len); /** * @brief 发送字符串 * @param UART_S_TypeDef *pUART * @param uint8_t *dat * @retval 发送的字节数 */ uint8_t UART_S_SendString(UART_S_TypeDef * const pUART, uint8_t *dat); /** * @brief 格式化发送字符串 * @param UART_S_TypeDef *pUART * @param char *fmt * @retval: */ uint8_t UART_S_Printf(UART_S_TypeDef * const pUART, const char *fmt, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2df92ff71961c9550654933255ac85ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcd5083e13580d1f4d1bace874c106c/" rel="bookmark">
			Android11获取当前手机已安装应用列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在上架GooglePlay，奈何Google8月份刚发布的审核警告
Google也说了能适用的APP类型如下：
其实 QUERY_ALL_PACKAGES 这个权限是针对 Android11以及以上系统获取不全当前手机已安装app列表添加的权限。 Android11以下不添加这个权限，是正常拿到列表的。 但我们做程序怎么可能不考虑适配呢。于是乎，解决思路根据Google文档的方案。
在AndroidManifest.xml 中添加
&lt;queries package="${applicationId}"&gt; &lt;intent&gt; &lt;action android:name="android.media.action.IMAGE_CAPTURE"/&gt; &lt;/intent&gt; &lt;intent&gt; &lt;action android:name="android.media.action.ACTION_VIDEO_CAPTURE"/&gt; &lt;/intent&gt; &lt;intent&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent&gt; &lt;/queries&gt; @NonNull public static List&lt;String&gt; getAllApps(@NonNull Context context) { List&lt;String&gt; apps = new ArrayList&lt;&gt;(); PackageManager pManager = context.getPackageManager(); // 获取手机内所有应用 @SuppressLint("QueryPermissionsNeeded") List&lt;ApplicationInfo&gt; packlist = pManager.getInstalledApplications(0); for (int i = 0, len = packlist.size(); i&lt;len; i++) { ApplicationInfo pak = (ApplicationInfo) packlist.get(i); // if()里的值如果&lt;=0则为自己装的程序，否则为系统工程自带 if ((pak.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdcd5083e13580d1f4d1bace874c106c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f4a66998b7a9d4e25102ea8adad8d3/" rel="bookmark">
			【TypeScript语法基础】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、TypeScript 是什么1.1 获取 TypeScript1.安装 TypeScript2.编译 TypeScript 文件 二、TypeScript 变量声明1、TypeScript 变量的命名规则：2、变量的声明： 三、TypeScript 的数据类型3.1、Boolean 类型3.2、Number 类型3.3、String 类型3.4、Array 类型3.5、Enum 类型3.6、Any 类型 四、TypeScript Map 对象4.1创建 Map4.2 Map 相关的函数与属性：4.3 迭代 Map 五、TypeScript 元组5.1、声明一个元组并初始化：5.2、访问元组5.3、元组运算：5.4、更新元组5.5、解构元组：可以把元组元素赋值给变量 六、TypeScript 联合类型6.1、语法格式6.2、联合类型数组 七、循环结构：7.1、for循环7.2、for...in 循环7.3、for…of循环7.4、forEach循环7.5、every循环 一、TypeScript 是什么 TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。
1.1 获取 TypeScript 1.安装 TypeScript $ npm install -g typescript
2.编译 TypeScript 文件 $ tsc helloworld.ts
# helloworld.ts =&gt; helloworld.js
二、TypeScript 变量声明 1、TypeScript 变量的命名规则： (1) 变量名称可以包含数字和字母。
(2) 除了下划线 _ 和美元 $ 符号外，不能包含其他特殊字符，包括空格。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3f4a66998b7a9d4e25102ea8adad8d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bd2ad7fbb378e105b63da3b3dc3319a/" rel="bookmark">
			计算机网络——网络层の选择题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络层的功能 1、在路由器互连的多个局域网的结构中，要求每个局域网（）
A、物理层协议可以不同，而数据链路层及其以上的高层协议必须相同
B、物理层、数据链路层协议可以不同，而数据链路层以上的高层协议必须相同
C、物理层、数据链路层、网络层协议可以不同，而网络层以上的高层协议必须相同
D、物理层、数据链路层、网络层及高层协议都可以不同
解析：选C
路由器是网络层设备，向传输层及以上层次隐藏下层的具体实现，就是网络层及以下可以协议不一样，路由器都会帮其隐藏差异，但是传输层及以上层次必须一样，要不然用不了，不能通信了。
特定的路由器连接IPv4和IPv6网络，就是典型的网络层协议不同而实现互联的例子。
2、下列协议中属于网络层协议的是（）
a.IP
b.TCP
c.FTP
d.ICMP
A、a和b
B、b和c
C、c和d
D、a和d
解析：选D
IP协议： 网际互连协议，是整个TCP/IP协议族的核心，也是构成互联网的基础。IP位于TCP/IP模型的网络层(相当于OSI模型的网络层)，它可以向传输层提供各种协议的信息，例如TCP、UDP等；对下可将IP信息包放到链路层，通过以太网、令牌环网络等各种技术来传送。
ICMP协议： 是一种面向无连接的协议，用于传输出错报告控制信息。主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。工作在网络层
TCP协议： 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。
FTP协议： 文件传输协议，是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。工作在应用层
3、下列描述中，（）不是软件定义网络（SDN）的特点
A、控制与转发功能分离
B、控制层面集中化
C、接口开放可编程
D、Openflow取代了路由协议
解析：选D
软件定义网络（SDN）：采用集中式的控制层面和分布式的数据层面，两个层面相互分离，控制层面利用控制-数据接口对数据层面上的路由器进行集中式控制，方便软件来控制网络。
优点：
①全局集中式控制和分布式高速转发； =&gt;A、B对
②灵活可编程与性能的平衡；C对
③降低成本
对于D，Overflow协议是控制层面和数据层面之间的接口，在SDN中，路由器之间不在互相交换路由信息，由远程控制计算器算出最佳路由。所以是远程控制计算器取代了路由协议。
路由算法 1、下列关于分层路由的描述中，（）是错误的
A、采用分层路由后，路由器被划分成区域
B、每个路由器不仅知道如何将分组路由到自己区域的目标地址，而且知道如何路由到其他区域
C、采用分层路由后，可以将不同的网络连接起来
D、对于大型网络，可能需要多级的分层路由来管理
解析：选B
对于A，分层路由就是将整个互联网划分为许多较小的自治系统AS，每个自治系统有权自主决定自治系统内部是用什么样的路由协议。大白话之把一整个互联网划分成许多小区域，自己进行管理。
对于C，内部网关协议用于自治系统内部，是内部使用的路由选择协议。
外部网关协议用于自治系统外部，是外部使用的连接各个自治系统的协议。
使用外部网关协议可以将不同的网络和自治系统连接起来。
对于D，对于大型网络，可能需要使用OSPF协议，将自治系统划分为更小的区域，降低每个区域内部路由信息的通信量大小。
对于B，只有处在边界的路由器才不仅知道如何将分组路由到自己区域的目标地址，而且知道如何路由到其他区域，对于自治系统内部的路由器，只知道如何将分组路由到自己区域的目标地址，对于要出去的分组，同一路由给处于边界的负责与外界连通的路由器。
be like:只有路由器A、B不仅知道如何将分组路由到自己区域的目标地址，而且知道如何路由到其他区域
IPv4 1、以下关于IP分组结构的描述中，错误的是（）
A、IPv4分组头的长度是可变的
B、协议字段表示IP的版本，值为4表示IPv4
C、分组有长度字段以4B为单位，总长度字段以字节为单位
D、生存时间字段值表示一个分组可以经过的最多的跳数
解析：选B
对于A，IPv4有20B固定不变的分组头长度和一部分可选字段，其长度可变，用来提供错误检查及安全等机制。包括两部分如下图：
对于B，协议字段：占8位，指出此分组携带的数据使用何种协议，即分组的数据部分应上交给哪个协议进行处理，如TCP，UDP等，其中值为6表示TCP，值为17表示UDP。
版本是用来表示IP版本的，值为4表示IPv4。
对于C，分组的长度字段即首部长度，占4位，基本单位是4B。总长度字段占16位，指首部和数据之和的长度，单位为字节。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bd2ad7fbb378e105b63da3b3dc3319a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a0f5d79a8e11433bc5b26ff4ea989ad/" rel="bookmark">
			前缀和以及哈希表优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引入 最近在刷题的时候，遇到了一些前缀和结合子数组的题目，这些题目，有一个共同的特性，就是说，刚开始都能够想利用前缀和进行优化，然后再结合子序列的左右端点进行枚举，最后确定哪一个区间或者哪一些是能够满足我们的题目要求，但是有一个问题就是，我们在枚举区间的两个端点的时间复杂度是 O ( n 2 ) O(n^2) O(n2)的，所以一旦题目数据给的特别大的时候，就会过不了，这个时候就需要利用题目的相关性质结合哈希表解题，把时间复杂度降到 O ( n ) O(n) O(n)以下，就可以过了，这里整理了相关类似的题目，此专题也会持续的更新…
二、题目汇总 ①力扣1124.表现良好的最长时间段 原题(来源于leetcode) 暴力分析 ①第一种暴力的想法，就是枚举左右端点，再通过一层循环枚举每一个左右端点形成的区间的表现良好和不良好的时间段的个数，那么一旦符合良好的个数大于我们的不良好的个数，就可以更新我们的答案了，时间复杂度为O(n^3)，肯定是过不了的。
②显然我们利用前缀和可以优化一层找良好和不良好时间段的个数，记良好的为1，不良好的为-1，那么一段区间的区间和大于0就说明良好严格大于不良好，那么最终的时间复杂度为 O ( n 2 ) O(n^2) O(n2)的，如果n比较小，那么这个方式是可以过的。
优化分析 由于暴力过不去，那么此时我们想的问题应该是，如何不直接两层循环枚举左右端点就可以求出我们的最终结果呢？
提示1 其实这个地方可以说利用了贪心的一个思想，因为题目很明确的说了，求的是最大的子区间长度，那么我们其实不妨，枚举的时候从右往左枚举，对于一个左端点，一旦右端点从最右往左到某一个位置恰好满足题意的话，那么我们就可以不用继续让右端点往左了，因为已经找到一个可能为答案的备选最大值。
提示2 整个问题变成，如何找一段区间长度和大于0，且这个区间的长度是求最大值。我们只需要记录可能成为左端点的下标，并且满足一旦某个点的前缀和成为了我们左端点的备选点后，在他右边所有和他等值的点都不会成为我们的左端点备选点。
提示3 备选点从左到右一定是严格单调下降的,在实现遍历的时候便是利用单调栈的思想。
提示4 这里有一篇相关题解，里面有比较详细的说明。
完整AC代码 class Solution { public: int longestWPI(vector&lt;int&gt;&amp; hours) { int n = hours.size(); vector&lt;int&gt; pre(n + 1, 0); for(int i = 1; i &lt;= n; i ++ ) { auto now = hours[i - 1]; if(now &gt; 8) pre[i] = 1; else pre[i] = -1; pre[i] += pre[i - 1]; } stack&lt;int&gt; stk; int ans = 0; for(int i = 0; i &lt;= n; i ++ ) { if(stk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a0f5d79a8e11433bc5b26ff4ea989ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29c5db12011ff37bf4636e34d797b017/" rel="bookmark">
			什么是异常，如何进行异常处理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.什么是异常 异常是指在程序的运行过程中所发生的不正常的事件，它会中断正在运行的程序。
二.如何进行异常处理？ Java的异常处理是通过5个关键字来实现的：try、catch、 finally、throw、throws
语法：
public class Test { public static void main(String[] args) { try { //程序代码块 }catch (异常类型 异常名){ //对异常进行处理的代码段 }catch(Exception e){ //对异常进行处理的代码段 }finally { //程序代码段 } } } 注意：
catch：捕获异常，可以同时编写多个catch。 Exception 只能写到最后一个catch中，其作用是为了兜底异常。
finally：无论程序中有无异常发生，并且无论之前的try-catch语句块是否顺利执行完毕，都会执行finally语句
finally语句不会执行的四种特殊情况
在finally语句块中发生了异常 在前面的代码中使用了System.exit()退出程序。（System.exit(1)——小括号内非零的数字，异常退出；0正常退出程序） 程序所在的线程死亡 关闭cpu 三.如何声明异常以及抛出异常 声明异常使用关键字：throws；语法：访问修饰符 返回值类型 方法名(参数列表) throws 异常类型
抛出异常使用关键字：throw。语法：throw new 异常类型，与throws声明的异常类型一致
1.使用throws关键字声明异常：通常应用在声明方法时，多个异常使用逗号隔开，声明的异常不需要解决，谁调用这个方法，谁解决。
public static void MyException() throws Exception { //方法体 } 2.使用throw关键字抛出异常：通常应用在方法体中，且只能抛出一个异常.与throws配合使用。
//方法类 public class TThrow { public void setAge(int age) throws Exception { if (age&gt;0 &amp;&amp; age&lt;=100){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29c5db12011ff37bf4636e34d797b017/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77be3cb11338201f5e9acfe4a9d56c4a/" rel="bookmark">
			【React Hooks&amp;Redux--学习小结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、React Hooks1、useState： 可以在函数组件中使用state2、useRef：看成是createRef的Hook版。3、useEffect4、Hooks的使用规则5、自定义Hooks：在应用中可以将一些需要重复使用的逻辑自定义成Hook 二、Redux1、三大核心：2、Redex的函数：3、store对象提供的方法： 一、React Hooks 1、useState： 可以在函数组件中使用state 2、useRef：看成是createRef的Hook版。 使用方法：
(1)先将ref存入变量
let el = useRef()
(2)再将变量与DOM节点进行绑定，通过ref的current属性来获取DOM节点
&lt;p ref={ el }&gt;web开发&lt;/p&gt;
el.current
useRef的作用：
(1)可以绑定DOM组件
(2)可以获取组件渲染之前的数据
3、useEffect useEffect：在类组件中副作用通常在componentDidMount、componentDidUpdate、componentWillUnMount 生命周期函数中进行处理。
在函数组件中useEffect相当于以上三个钩子函数的集合体。
包含两个参数：第一参数是执行时的回调函数、第二个参数是依赖参数；并且回调函数,还有一个返回函数。
(1)依赖参数：是一个数组,数组中存放的是要依赖的数据，当这些数据更新时就会执行回调函数
(2)执行过程：
组件挂载–&gt;执行副作用(回调函数)–&gt;组件更新–&gt;执行清理函数(返回函数)–&gt;执行副作用(回调函数)–&gt;组件准备卸载–&gt;执行清理函数(返回函数) --&gt;组件卸载
4、Hooks的使用规则 (1)只能在函数组件和自定义的Hooks中调用Hooks。类组件和普通函数不能使用Hooks
(2)只能在函数的第一层中调用Hooks。在函数中若使用了流程控制语句(if、for、while),在流程控制语句不能使用Hooks;若函数中定义了子函数，子函数中也不能使用Hooks
5、自定义Hooks：在应用中可以将一些需要重复使用的逻辑自定义成Hook 示例：自定义一个Hook，返回一个和滚动条位置实时同步的state
二、Redux Redux：是一个状态管理的库。不是React内置的，是独立的JavaScript的状态容器，提供可预测的状态管理,在React中使用Redux，可以把所有的state集中到组件的顶部，能够灵活地将所有的state分发给所有组件。方便了开发者管理React中的状态,也方便了不同组件间的通信
1、三大核心： (1)store：是一个数据容器,用来管理和保存整个项目的state。整个项目中只能有一个store
(2)state：是一个对象，在state中存储相应的数据，当开发者需要使用数据时,可以通过store提供的方法来获取state
(3)action：是一个通知命令，用于对state进行修改。通过store提供的方法可以发起action完成对state的修改
2、Redex的函数： (1)action：本质是JavaScript对象，在action中包含一个字符串类型的type属性，作用是指定要对state进行何种操作。action会通过store将要进行的操作传给reducer函数，由reducer 函数完成对state的修改
action({type:‘add’,data:‘’})
(2)reducer：是一个纯函数。有两个参数state和action。该函数一定有一个返回值，是修改后的state
纯函数：
a、纯函数在执行过程中没有任何副作用。如定时器、网络请求
b、如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部状态或 数据的变化。
function reducer(state={ count:1},action){
switch(action.type){
case ‘ADD’:
return {count: state.count+1 }
case ‘SUB’:
return {count: state.count-1 }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77be3cb11338201f5e9acfe4a9d56c4a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41b28108899abf9fb6324bd91403336/" rel="bookmark">
			【ECharts】柱状图自动滚动，结束后从头开始
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		柱状图自动滚动，每次向后滚动一个，到最后一个结束后，从头开始。
eacharts柱状图自动滚动，结束后从头开始
主要代码：
dataZoom: [ //滑动条 { xAxisIndex: 0, //这里是从X轴的0刻度开始 show: false, //是否显示滑动条，不影响使用 type: "inside", // 这个 dataZoom 组件是 slider 型 dataZoom 组件 startValue: 0, // 从头开始。 endValue: 4, // 一次性展示几个。 }, ], if (x.length &gt; 0 &amp;&amp; y.length &gt; 0) { this.timechartes = setInterval(function () { // 每次向后滚动一个，最后一个从头开始。 if (option.dataZoom[0].endValue == x.length) { option.dataZoom[0].endValue = 4; option.dataZoom[0].startValue = 0; } else { option.dataZoom[0].endValue = option.dataZoom[0].endValue + 1; option.dataZoom[0].startValue = option.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41b28108899abf9fb6324bd91403336/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52cd57a1fe08fbffc89f48ec8a860617/" rel="bookmark">
			关于STM32F407的学习（第五章 按键输入实验 GPIO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 值得注意的是：
当WK_UP按键按下去之后，IO口检测到高电平；
当KEY0/1/2按下，IO口检测到低电平；
所以KEY0/1/2用上拉输入，WK_UP用下拉输入。
一共有三种方法输入电平：
1，读取IO口输入电平调用库函数为：
uint8_t GPIO_ReadInputDataBit(GPIO_Yype*GPIOx,uint16_t GPIO_Pin); 2，读取IO口输入电平操作寄存器为：
GPIOx_IDR:端口输入寄存器
3，使用位带操作读取IO口输入电平方法：
PEin（4） 读取GPIOE.4口电平
PEin（n） 读取GPIOE.n口电平
操作IO口之前必须使能按键对应的IO口时钟，调用函数
RCC_AHB1PeriphClockCmd(); 还要初始化IO模式：上拉下拉输入，调用函数：
GPIO_Init(); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7482a5932afd100bd4442062e9001a4f/" rel="bookmark">
			C语言—— 字符串与指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐️1 字符串的表示形式 在C程序中，可以用两种方法访问一个字符串 (1)用字符数组存放一个字符串，然后输出该字符串。 (2)用字符指针指向一个字符串 ⭐️2 字符指针作函数参数 将一个字符串从一个函数传递到另一个函数，可以用地址传递的方法，即用字符数组名作参数，也可以用指向字符的指针变量作参数。在被调用的函数中可以改变字符串的内容，在主调函数中可以得到改变了的字符串。
(1)用字符数组作参数 (2)形参用字符指针变量 ⭐️3 对使用字符指针变量和字符数组的讨论 虽然用字符数组和字符指针变量都能实现字符串的存储和运算，但它们两者之间是有区别的，不应混为一谈，主要有以下几点。 (1)字符数组由若干个元素组成，每个元素中放一个字符，而字符指针变量中存放的是地址，决不是将字符串放到字符指针变量中。
(2)赋值方式。
(3)对字符指针变量赋初值。
(4)如果定义了一个字符数组，在编译时为它分配内存单元，它有确定的地址。而定义一个字符指针变量时，给指针变量分配内存单元，在其中可以放一个字符变量的地址，也就是说，该指针变量可以指向一个字符型数据，但如果未对它赋予一个地址值，则它并未具体指向一个确定的字符数据。
(5)指针变量的值是可以改变的。
(6) 用指针变量指向一个格式字符串，可以用它代替printf函数中的格式字符串。
看下例题 例题：指针实现，判断一个子字符串是否在某个给定的字符串中出现。
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int isSubstring(char *str,char *substr)
{
char *ch,*s;
int flag ;
while(*str!='\0'){
if(*str == *substr)
{ s = str;
ch = substr;
while(*ch!='\0')
{
if(*s++ != *ch++ )
{ flag = 0; break;}
}
if(*ch=='\0')
flag = 1;
}
str++;
}
return flag;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7482a5932afd100bd4442062e9001a4f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/236/">«</a>
	<span class="pagination__item pagination__item--current">237/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/238/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>