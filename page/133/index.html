<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4afd6eb1ac22d6e7b8ff6151f89ed5a/" rel="bookmark">
			JAVA各种加密与解密方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、凯撒加密 在密码学中，凯撒加密是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。
public class caesarCipher { public static void main(String[] args) { String show = "ABCDEFGHIJKLMNOPQRSTUVWXYZ~~"; int key = 3; String ciphertext = encryption(show, key, true); System.out.println(ciphertext); String showText = encryption(ciphertext, key, false); System.out.println(showText); } /** * @param text 明文/密文 * @param key 位移 * @param mode 加密/解密 true/false * @return 密文/明文 */ private static String encryption(String text, int key, boolean mode) { char[] chars = text.toCharArray(); StringBuffer sb = new StringBuffer(); for (char aChar : chars) { int a = mode ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4afd6eb1ac22d6e7b8ff6151f89ed5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5747ea4c113ff1fc25ba3c7900f10015/" rel="bookmark">
			ffmpeg之avformat_open_input函数详细解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		avformatopeninput() 函数是用于打开媒体文件并获取媒体文件信息的函数，该函数定义在libavformat/avformat.h中。
函数原型为：
int avformat_open_input(AVFormatContext **ps, const char *url, AVInputFormat *fmt, AVDictionary **options); 该函数的参数含义如下：
ps：AVFormatContext结构体的指针。该参数用于存储打开的媒体文件的信息。当该函数成功返回时，AVFormatContext结构体中将存储媒体文件的相关信息。
url：要打开的媒体文件的URL。可以是本地文件路径，也可以是HTTP URL或其他协议的URL。
fmt：AVInputFormat结构体的指针，用于指定媒体文件的格式。如果该参数为NULL，则根据文件扩展名自动选择输入格式。
options：AVDictionary结构体的指针，用于传递打开媒体文件时的选项。
下面是一个简单的示例，演示如何打开一个本地MP3文件并获取媒体文件的信息：
#include &lt;libavformat/avformat.h&gt; int main(int argc, char *argv[]) { AVFormatContext *fmt_ctx = NULL; // 打开媒体文件 int ret = avformat_open_input(&amp;fmt_ctx, "example.mp3", NULL, NULL); if (ret &lt; 0) { // 打开文件出错 av_log(NULL, AV_LOG_ERROR, "Cannot open input file\n"); return -1; } // 获取媒体文件信息 ret = avformat_find_stream_info(fmt_ctx, NULL); if (ret &lt; 0) { // 获取文件信息出错 av_log(NULL, AV_LOG_ERROR, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5747ea4c113ff1fc25ba3c7900f10015/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f27efe36e05b4234cfc1be2f940fee1d/" rel="bookmark">
			异步加载回调问题，多个资源异步加载，让其全部加载完回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刚刚遇到一个bug，场景大图需要提前加载，所有场景组件就需要等图加载好后再处理，但是由于场景背景图是异步加载的，并且是同时for循环进行异步加载的，所以无法确认哪一个图是最后加载出来的，抱着试一试的心态，这样写了一下，发现没用：
---记载所有背景图 function LoadBgRawImage(mapID,func) for i = 1, len do ... local path = "xxx\xxx\xxx.jpg" local bgFunc = nil if i == len then bgFunc = func end ---异步加载图片 LoadRawImage(path,func) end end ---异步加载图片 function LoadRawImage(path,func) ...(保护代码) IOSystem.LoadAssetAsync(path,function(Prefab)) ... if func then ---执行回调 func() end end) end 然后求助幸福的xx（同事），获得醍醐灌顶的指点：
---记载所有背景图 function LoadBgRawImage(mapID,func) ... local loadedcount = len for i = 1, len do ... ---异步加载图片 LoadRawImage(path,function() loadedcount = loadedcount - 1 if loadedcount&lt;=0 then if func then func() end end end) end end ---异步加载图片 function LoadRawImage(path,func) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f27efe36e05b4234cfc1be2f940fee1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c5f4d1b293bcb7cb839b3095d57fe52/" rel="bookmark">
			yum安装nginx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.nginx和httpd对比
2.安装
1.查看安装包
2.安装epel源
3.安装nginx
4.启动
3.使用
1.反代使用
2.代理使用
3.前端使用
4.常用命令
1.检测语法是否正确
2.配置生效 1.nginx和httpd对比 nginx是俄罗斯人编写的十分轻量级的HTTP服务器，是一个高性能的HTTP和反向代理服务器。
Nginx相对于Apache httpd：
1、高并发响应性能非常好。（单台万级并发连接30000-50000/s（简单静态页））
2、反向代理性能非常好。（可用于负载均衡）
3、内存和cpu占用率低。（为Apache的1/5-1/10）
4、功能较Apache少（常用功能均有）
2.安装 1.查看安装包 [root@service01 html]# yum list | grep nginx pcp-pmda-nginx.x86_64 4.3.2-13.el7_9 updates 2.安装epel源 因为没有nginx安装包，所以我们需要安装一个yum源
sudo yum install epel-release 3.安装nginx yum install -y nginx #安装所有模块 yum -y install nginx-all-modules.noarch 4.启动 systemctl start nginx 3.使用 1.反代使用 修改/etc/nginx/nginx.conf
在http下面加上
upstream xxx-api{ server ip:port; } 在server下面加上
server { listen 80; listen [::]:80; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c5f4d1b293bcb7cb839b3095d57fe52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e6ec3ab8123250cd0547e4e9cd3246/" rel="bookmark">
			Altium designer 学习第一课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录
1.原理图的建立
2.PCB图的建立
3.原理图库建立
4.PCB库制作
1.原理图的建立 打开Properties就能设置原理图的大小，和去掉右下角的Title Block
这里可以去掉网格的可见性
选择window，垂直平铺，便于查看原有原理图 给原理图所有标号重命名
放置线 选择右上角A，然后英文输入法下按Tab键就能设置
给原理图画边界线
选择Net,能够给每部分功能打标签
2.PCB图的建立 选择验证变更，执行变更 然后建立了原理图和PCB图的联系
把元器件放置在板子的周围
3.原理图库建立 由于AD中原理图库的器件很少，使用在使用时需要我们手动添加原理图库
本文主要通过使用立创EDA来添加的
1.1首先打开立创EDA来找到我们需要的器件
以STC89C52-35I-LQFP44器件举例：
在下图的最右侧我们可以看到器件的原理图与pcb图
接着使用AD格式导出，并使用Altium designer打开
建立元器件库
此时无法从导入的文件中简单复制原理图到stm32.SchLib中，那么我们先把原理图复制stm32.SchDoc中
接着选择Design-&gt;Make Schematic Library创建出一个stm32_1.SCHLIB
此时就能把原理图复制到stm32.SchLib原理图库中了
此时把该库添加，就能在绘制时使用到 4.PCB库制作 导出封装图
创建PCB库，并把文件复制过来 最后添加该库，具体步骤如上面原理图库添加一样
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68e00ea1b3b859ea5eabe74970aadedd/" rel="bookmark">
			win10和ubuntu18.04双系统条件下ubuntu根目录扩容方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章:ubuntu16.04使用GParted对/根目录扩容_gparted 扩容_Carina_Cao的博客-CSDN博客
本人电脑是双系统，在给电脑装ubuntu系统时将根目录留的空间只有20G，导致在后续使用过程中安装的apt逐渐占满系统根空间，无法继续安装其他，同时win10系统仍然有很大空间剩余，所以可将win10系统空间转移到ubuntu根空间，以下是具体方法：
目录
（1）ubuntu下安装GParted
（2）制作ubuntu启动盘
（3）win10系统留出空间
（4）通过GParted分配空间
（1）ubuntu下安装GParted 打开ubuntu，在终端输入sudo apt-get install gparted
输入ubuntu系统密码
安装GParted完成
打开GParted：sudo gparted
（2）制作ubuntu启动盘 在window系统中下载ubuntu镜像文件，ubuntu官网下载Ubuntu桌面系统 | Ubuntu，点击下载，
点击其他下载，
点击查看历史版本，
根据自己的ubuntu系统选择相同的版本（我的是18.04），
点击ubuntu-18.04.6-desktop-amd64.iso，下载镜像文件，
进入网站Win32 Disk Imager download | SourceForge.net，点击Download，
下载镜像安装工具， 并安装，
准备一个4G以上容量的U盘，打开安装好的Win32 Disk Imager，映像文件选择刚才下载好的ubuntu-18.04.6-desktop-amd64.iso，点击写入，等待完成即可（出现提示，点yes即可，会清空U盘原有内容）。
启动盘制作完成。
（3）win10系统留出空间 在win0系统中右键此电脑，点击磁盘管理，G盘后面是我的ubuntu系统相关盘空间，打算将G盘空间分出一部分给Ubuntu根目录，
右键G盘点击压缩卷，输入压缩空间量100000（按自己需求分配），多出的未分配空间将分给Ubuntu。
（4）通过GParted分配空间 将U盘启动盘插入主机，重启计算机，进入U盘的ubuntu系统。
ctrl+alt+t打开终端，输入sudo gparted进入GParted,
接下来具体操作按照该作者文章即可，亲测有效ubuntu16.04使用GParted对/根目录扩容_gparted 扩容_Carina_Cao的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bb88ec144a638d5d84f546ed5c2a93d/" rel="bookmark">
			git提交之后再pull导致很多代码被修改，但是修改又不是你修改的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景 git提交之后再pull导致很多代码被修改，但是修改又不是你修改的，导致你本地很多修改，怎么抛弃掉这些修改呢。
原因分析 你本地没有拉master代码，但是你本地提交了一个评审，但是还没和入，这个之后pull一下会把你上次代码更新到这次所有的代码都进行一个对比，如何提交这个。
有个办法就是直接commit，然后提交，但是如果代码库限制了每次只能有一个commit，不能有两个commit。
然后我们本地执行下面这个命令
git pull --rebase 这样变基到当前仓库分支最新的提交，并将本地的提交应用到最新的提交之上，与普通git pull命令不同，git pull --reabse会将本地的提交变基到最新的提交之上，而不是将本地的提交和远程的提交合并。
使用git pull --rebase可以保持提交历史的线性，避免出现不必要的合并提交。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aacbefc75e6d474fc223eb4c23452694/" rel="bookmark">
			程序员如何做副业可以实现财富自由？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几年呢，我做包括自媒体在内的各种副业，也挣了一些钱，更有想象不到的一些收获。
最近呢，也有一些朋友问我说晚风怎么样做一些副业，那今天呢，我就给大家分享五点，我认为做副业必须要考虑的问题.
1、副业和主业尽量相关
那第一点呢，就是如果你决定做副业的话呢，我个人建议呢，你还是要副业和主业尽量相关，这样呢，一个是成本非常的低，另外一个就是你不怕失败。
我给大家举个例子，比如说你本身是做程序员的，有两个副业在你的面前，一个是开发代码卖给别人，另外一个是去做导游，那我更建议呢，你去开发代码卖给别人，一个是你有的技术就可以做得到，你的时间成本，你学习成本都非常的低，另外一个呢，就是哪怕这个代码卖不出去，你本身程序员的技能也是在提高的，所以说你不怕失败。
2、有耐心
对吧。那第二点就是做副业呢，一定要有耐心，我也是做了两三年吧，前两年可以说是一分钱都没挣到，多少挣了几分钱，所有的钱都是从第三年开始，往后才慢慢的越挣越多，规模越做越大。所以说不能急功近利。
3、产品过硬
那第三点也是不急功近利带来的好处就是你的产品是过硬的。
其实我们不论是做副业也好做自己的职业发展也好，最大的破产我认为是信任破产。
你做副业，实际上我们想做一个斜杠青年呢，希望大家就是每条杠都足够的硬，你拿出来的作品是别人可以认可的，虽然你是个副业，但是我一样能拿出专业的水平来。
4、谨防被骗
然后第四点呢，也是非常重要的一点，就是其实大家千万不要被骗，因为现在好像说副业刚需，或者说之类的这种广告课程特别的多，但凡是告诉你，躺着就能赚钱，学习成本非常低的，你就都不要相信了好吧。
踏踏实实的挣钱，也不要碰灰色收入，这样呢，有一天你真的做大了，你才会睡得踏实。
5、持续学习
然后最后一点呢，我想给大家说的就是，如果你决定做副业了，你一定要注意，那你就需要花大量的时间去学习，你要比没有做副业的人付出更多的努力，你要做好这个心理准备好吧，那下面呢，我也把我经常看的一些对我帮助比较大的副业相关的课程放在这里：​ ​别一听「副业刚需，轻松躺赚」就给人交钱​​
​ 最后 为了帮助大家更好的学习Python，小编给大家准备了一份Python学习资料，里面的内容都是适合零基础小白的笔记和资料，不懂编程也能听懂、看懂，需要获取方式：点击这里【 Python全套资料】 即可获取。
​
CSDN大礼包：《Python开发全套学习笔记/实战项目/安装工具》免费分享
👉Python学习路线汇总👈
Python所有方向的技术点做的整理，形成各个领域的知识点汇总，它的用处就在于，你可以按照上面的知识点去找对应的学习资源，保证自己学得较为全面。
​👉Python必备开发工具👈
👉精品Python学习书籍👈
当我学到一定基础，有自己的理解能力的时候，会去阅读一些前辈整理的书籍或者手写的笔记资料，这些笔记详细记载了他们对一些技术点的理解，这些理解是比较独到，可以学到不一样的思路。
温馨提示：篇幅有限，已打包文件夹，获取方式：点击这里【 Python全套资料】 即可获取。
CSDN大礼包：《Python开发全套学习笔记/实战项目/安装工具》免费分享
👉Python学习视频600合集👈
观看零基础学习视频，看视频学习是最快捷也是最有效果的方式，跟着视频中老师的思路，从基础到深入，还是很容易入门的。
​​​👉100道Python练习题👈
👉面试刷题👈
​​​
👉实战案例👈
光学理论是没用的，要学会跟着一起敲，要动手实操，才能将自己的所学运用到实际当中去，这时候可以搞点实战案例来学习。
👉Python副业兼职与全职路线👈
​​​获取方式：点击这里【 Python全套资料】 或扫描下方即可获取。
​
CSDN大礼包：《Python开发全套学习笔记/实战项目/安装工具》免费分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa4aa4a2d748608fb42a2851913294c/" rel="bookmark">
			菜鸟云打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装菜鸟打印组件 https://support-cnkuaidi.taobao.com/doc.htm#?docId=108934&amp;docType=1
Html: &lt;%@ Page Language="C#" AutoEventWireup="true" CodeBehind="JS_CloudPrint.aspx.cs" Inherits="Demo.JS_CloudPrint" %&gt; &lt;!DOCTYPE html&gt; &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt; &lt;head runat="server"&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="https://g.alicdn.com/fi/bui/jquery-1.8.1.min.js"&gt;&lt;/script&gt; &lt;script src="CloudPrinter.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="javascript:;" onclick="doPrint()"&gt;打印&lt;/a&gt;&lt;br /&gt;&lt;br /&gt; &lt;a href="javascript:;" onclick="doPreview()"&gt;预览&lt;/a&gt;&lt;br /&gt;&lt;br /&gt; &lt;/body&gt; &lt;/html&gt; CloudPrinter.js：(jquery-1.8.1.min大家自己下载) var socket; var printers; var defaultPrinter; var printTaskId; var taskers; var waybillPrintStatus; var waybillNO = '000000000000'; var waybillTemplateURL = 'http://cloudprint.cainiao.com/template/standard/101/123'; var printData; //自动连接 doConnect() //连接打印机并监听 function doConnect() { socket = new WebSocket('ws://127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0fa4aa4a2d748608fb42a2851913294c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c10d167483d519f9bece296506ce4e0/" rel="bookmark">
			服务器重启后卡死在Windows Update 界面问题处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器是ESXI6.0主机中的虚拟机
操作系统Windows Server 2008 R2 版
重启服务器一直卡在配置Windows Update界面，等待半小时以上无法应。解决方法如下
【实体服务器请直接看第三步】
第一步
在虚拟机中找到启动文件（实体服务器请跳过）
第二步
将虚拟机电源关闭，将PE启动文件加载到光驱
第三步
启动虚拟器进入PE系统
第四步
删除以下路径中的所有文件（我是剪切到了别的盘）
C:\Windows\SoftwareDistribution\Download\
第五步
删除以下路径的指定文件（我是剪切到了别的盘）
C:\Windows\winsxs中的【pending.xml】文件
第六步
进入C:\Windows，打开【regedit.exe】
第七步
展开HKEY_CURRENT_USER \Software \Microsoft \Windows \CurrentVersion \Policies \Explorer
第八步
在右边窗口中新建一个DWORD值，将其命名为“NoWindowsUpdate”,然后将其数值数据修改为“1”
第九步
关闭注册表编辑器，检查下文件删除完全没有，确认步骤都做完了就可以按【F8】重启进入安全模式
注：进入安全模式不能跳过更新，也需要等一段时间，进入windows安全模式。，我是虚拟机，等了十几分钟，这个时间不是一定的
第十步
在安全模式中，将【Windows Update】服务改为禁用
第十一步
重启服务器，就能正常进入到系统了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1d18d1a5b020dba66aebebf10eae794/" rel="bookmark">
			docker部署redis集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.无密码版 ①创建并运行容器
docker run -d --name redis-node-1 --net host --privileged=true -v /data/mydata/redis/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381 docker run -d --name redis-node-2 --net host --privileged=true -v /data/mydata/redis/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382 docker run -d --name redis-node-3 --net host --privileged=true -v /data/mydata/redis/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383 docker run -d --name redis-node-4 --net host --privileged=true -v /data/mydata/redis/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384 docker run -d --name redis-node-5 --net host --privileged=true -v /data/mydata/redis/redis-node-5:/data redis:6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1d18d1a5b020dba66aebebf10eae794/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f575915003495ab307e6d0b638cf164/" rel="bookmark">
			linux部署redis集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载redis解压 2.编译源码并安装到指定目录 make PREFIX=/data/mydata/redis5/redis1 install make PREFIX=/data/mydata/redis5/redis2 install make PREFIX=/data/mydata/redis5/redis3 install make PREFIX=/data/mydata/redis5/redis4 install make PREFIX=/data/mydata/redis5/redis5 install make PREFIX=/data/mydata/redis5/redis6 install 3.创建配置文件 vi /data/mydata/redis5/redis1/bin/redis.conf redis.conf
port 7000 protected-mode no daemonize no appendonly yes cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 20000 masterauth 123321 requirepass 123321 将redis.conf复制到剩余5个redis的bin目录，修改各自端口
4.到各自bin目录启动redis ./redis-server redis.conf &amp; 5.创建集群 到任意一个redis的bin目录下
./redis-cli -a 123321 --cluster create 192.168.111.222:7000 192.168.111.222:7001 192.168.111.222:7002 192.168.111.222:7003 192.168.111.222:7004 192.168.111.222:7005 --cluster-replicas 1 6.查看集群信息 ./redis-cli -p 7000 -a 123321 cluster info cluster nodes －c表示以集群的方式登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f575915003495ab307e6d0b638cf164/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a37ddc76fcd72b18b48aa0be9d97196/" rel="bookmark">
			Javascript 俄罗斯方块 游戏代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本俄罗斯方块代码采用 JavaScript 脚本代码写成，简单易懂；
全代码采用静态类及静态变量成员组成；
全脚本通过实现代码全局配置 OLSFK.Options = {...}
定义方块起始坐标及定义各自的旋转点；
从初始化俄罗斯方块界面开始，再监听键盘事件；以及左右，向下及旋转动作判断，重新渲染方块位置；
判断是否消行，以及相应的加级判断，执行速度，加分操作来执行；
最后以判断是否当前级别大于所定义的最大级别来判断是否结束；
代码说明讲解
OLSFK.Options = { //相关参数 width:12,//界面横向方块数 height:20,//界面纵向方块数 boxWidth : '16px', curLevel:1, speed : 1000, //setInterval,setTimeout direct : { //可以设定是A S D W, 还是← ↓ → Down: 40 , /*run speed*/ Left: 37, Right: 39, Rotate: 38 }, Move:true,//是否正在移动 Eventing:false, Levels: { 1:1000, 2:900, 3:800, 4:700, 5:600, 6:500, 7:400, 8:300, 9:200, 10:100 }, curBlock:4, //当前移动的图形名称 nextBlock:0, GampMap:new Object(), Timer:null, deline:0, Score:0, Deling:false, Start:false, lineNum:10, //删除几行了，加级 ScoreNum:40 //消一行加分 } direct 表示 使用键盘方位键来操作方块的移动方向；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a37ddc76fcd72b18b48aa0be9d97196/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d4f999c11754f1b1a861db2fc38c143/" rel="bookmark">
			[总结]蓝牙各个版本的关系和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		怎么查看手机蓝牙版本（轻松几步教你查看蓝牙适配器版本）
前言 蓝牙技术是一种短距离无线通信技术，被广泛应用于各类电子设备之间的数据传输。目前，蓝牙技术已经发展到第五代（Bluetooth 5.0）。
Bluetooth 1.0 和 1.1 版本 这两个版本是最早的蓝牙版本，主要用于连接手机、电脑等设备。它们的最大缺点是传输速度慢、传输距离短，限制了其在一些应用场景中的使用。
Bluetooth 1.2 版本 这个版本在之前版本的基础上做了一些改进，包括提高了传输速度、降低了功耗、增强了安全性等。
Bluetooth 2.0 + EDR 版本 这个版本在传输速率和功耗方面有了很大的提升。其中，EDR（Enhanced Data Rate）技术可以将传输速率提高到了3倍，最高传输速率为3Mbps。
Bluetooth 2.1 + EDR 版本 这个版本在之前版本的基础上增加了一些新的功能，如Secure Simple Pairing（SSP）技术，可以加强安全性。
Bluetooth 3.0 + HS 版本 这个版本引入了高速（HS）模式，可以将传输速率提高到24Mbps。此外，该版本还支持802.11联合传输（AMP）技术，可以实现蓝牙和Wi-Fi之间的无缝连接。
蓝牙4.0 这个版本主要针对物联网应用场景做了优化，包括降低功耗、增加传输距离、支持扩展数据包等。4.0版本还开发了两种低功耗模式：BLE（Bluetooth Low Energy）和Bluetooth Smart，这两种模式用于连接低功耗设备，如传感器、健康监测器等。
蓝牙4.1 介绍一下蓝牙5.2 发展历史 时间 特点 缺点并以markdown表格形式列出，表头为蓝牙版本、时间 、特点、缺点
蓝牙4.2 蓝牙5.0 这个版本是目前最新的蓝牙版本，主要增加了传输速度、传输距离、数据容量、广播容量等方面的改进。此外，该版本还支持Mesh网络，可以实现多个设备之间的互联互通。
蓝牙5.1 蓝牙5.1相对于5.0来说，没有太多革命性的变化，主要的改进是在定位方面，可以提供更高的精度和方向探测功能。同时，由于这些改进的实现需要更高的成本和复杂性，这也是它的一大缺点。此外，由于信号可能会被物体阻挡，因此在某些场景下定位精度可能会受到影响。
蓝牙5.2 蓝牙5.2是蓝牙技术的最新版本，于2020年正式发布。
总体来说，蓝牙5.2版本在定位精度、广播数据容量、安全性、音频传输和IoT设备连接方面有了明显的提升，但是仍然存在传输距离受限的问题，并且需要使用专门的芯片和硬件支持。
蓝牙各个版本比较 蓝牙版本时间特点缺点Bluetooth 1.0/1.11999/2001传输速度慢 传输距离短 安全性较弱传输速度慢，不适合大数据传输 传输距离有限，只适用于近场通信Bluetooth 1.22003提高传输速度 降低功耗 增强安全性仍然有一定的传输延迟 传输距离仍有限Bluetooth 2.0+EDR2004提高传输速度 降低功耗 EDR技术可以将传输速率提高3倍仍然有一定的传输延迟 传输距离仍然有限Bluetooth 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d4f999c11754f1b1a861db2fc38c143/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41b4b7085f2ec6030a1bb7758132531f/" rel="bookmark">
			保姆级教程深度学习环境配置(GPU版本)（Anaconda&#43;Pycharm&#43;CUDA&#43;cuDNN&#43;Tensorflow）--序言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lz历时一周，终于配置好了深度学习环境，其过程可谓是一波三折。接下来，我就手把手把我的安装流程、遇到的困难，解决办法以及我的理解分享给大家。
对于非计算机专业，刚刚入门深度学习的小伙伴，突然面临这么多繁杂的名称，肯定摸不着头绪，无从下手，接下来，我将就安装顺序以及各个软件是干什么的做下简单的介绍：
※注:GPU版本只适用于英伟达NVIDIA的显卡（GPU），务必看下自己的电脑里有无英伟达显卡
查看步骤：任务管理器——&gt;性能；即可查看到自己电脑的GPU信息
推荐安装顺序: Anaconda--&gt;Pycharm--&gt;CUDA--&gt;cuDNN--&gt;Tensorflow（gpu）
Anaconda：在我看来，Anaconda更像是一栋大楼，而我们配置的各个不同的环境则是这栋大楼里的一个个房间。环境的名称则是我们给每个房间的命名or编号。当我们在做不同的项目（Project）时，很可能需要不同的环境，此时只需要把不同的项目（Project）放在我们在Anaconda中创建的与其相兼容的环境（env）中 即可运行。在Anaconda中，几乎有各个版本的库，python编辑器等等。
Pycharm ：Pycharm是一款优异的IDE软件。他在我看来则是方便我们运行项目，调试代码的一个更好的集成开发平台。在Pycharm中，我们可以创建不同的项目（Project），并且为其搭配我们在Anaconda中提前搭配好可以兼容的环境（env），以及每个环境中的python编辑器（Interpreter）。在Pycharm窗口界面，我们可以很清晰地看到项目中各个文件（file）的Python代码，以及代码运行的结果。而且Pycharm支持语法高亮等功能，更容易帮助我们发现代码中的错误。
CUDA：是一种由NVIDIA推出的通用的并行计算架构，该架构使GPU能够解决复杂的计算问题。通俗一点来讲，当我们使用GPU进行计算时，CUDA是必不可少的
cuDNN：NVIDIACUDA®深度神经网络库（cuDNN）是GPU加速的用于深度神经网络的原语库。cuDNN为标准例程提供了高度优化的实现，例如向前和向后卷积，池化，规范化和激活层。目前，全球的深度学习研究人员和框架开发人员都依赖cuDNN来实现高性能GPU加速。它使他们可以专注于训练神经网络和开发软件应用程序，而不必花时间在底层GPU性能调整上。
Tensorflow: 是AI开发项目的工具箱，是一个基于数据流编程（dataflow programming）的符号数学系统，被广泛应用于各类机器学习（machine learning）算法的编程实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5885443b62fbd8b53e993dce535e722a/" rel="bookmark">
			MyMath百分比计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/**
@author zjx
@Description: 百分比
*/
public class MyMath {
private MyMath() {
}
/**
@param d1：分子；@param zs：分母；@param dot：要保留的小数@Description: 计算百分
*/
public static double percentage(double d1, double zs, int dot) {
double bs = Math.pow(10.0, toDouble(dot + 2, 0.0));
double cs = Math.pow(10.0, toDouble(dot, 0.0));
double num = 0.0;
if (zs &gt; 0) {
num = Math.floor(d1 * bs / zs) / cs;
}
return num;
} /**
@param d1：分子；@param zs：分母；@param dot：要保留的小数@return@Description: 计算百分比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5885443b62fbd8b53e993dce535e722a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ac4a42bf0bb8e076f617dc224fcd32f/" rel="bookmark">
			Unity——在C#中调用C&#43;&#43;动态链接库（DLL）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建C++动态链接库（DLL） 1、新建C++空项目 打开VS，新建一个C++空项目，自命名项目名称与位置。
2、配置项目属性为动态链接库 右键项目，点击属性，打开项目属性页，将常规中的配置类型改为动态库（.dll)。
3、添加.h头文件 右键头文件，点击添加—&gt;新建项，选择头文件.h，命名为DllForUnity.h，点击添加。
代码如下： #pragma once #include&lt;math.h&gt; #include&lt;string.h&gt; #include&lt;iostream&gt; #define _DllExport _declspec(dllexport) //使用宏定义缩写下 extern "C" { float _DllExport GetDistance(float x1, float y1, float x2, float y2); } 4、添加.cpp文件 右键源文件，点击添加—&gt;新建项，选择C++文件.cpp，命名为DllForUnity.h，点击添加。
代码如下： #include &lt;DllForUnity.h&gt; float GetDistance(float x1, float y1, float x2, float y2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); } 5、设置编译为C++代码 右击项目，点击属性，对C/C++下面的高级中的编译为选择“编译为C++代码(/TP)”。
6、生成解决方案 点击生成-&gt;生成解决方案,生成之后，会显示出生成成功。
7、确定生成.dll文件 在项目路径下x64文件夹的Debug中就可以看到生成的.dll文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ac4a42bf0bb8e076f617dc224fcd32f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3630ba4c31d4d2eb318bd13bb4dd08f/" rel="bookmark">
			用Global Mapper提取栅格影像边界，比ArcGIS简单！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前不久写了一篇文章，是用ArcGIS提取栅格影像的边界，用到了ArcGIS镶嵌数据集功能，对这一知识点感兴趣的朋友可以看看下面这篇。
【arcgis每天学一点】快速获取栅格影像边界的方法
​
这几天发现，用Global Mapper实现同样的效果，步骤更少，速度更快，只需简单一步！下面王石头就来介绍一下这种方法。这里需要说明一下，我们提取的是影像有效值的边界，就是说，影像周围的值为Nodata，如下图所示：
​
操作步骤如下：
1、在Global Mapper软件加载影像；
​
2、点击图层---&gt;创建 图层覆盖框/多边形 区图元;
​
3、在弹出界面中，如果要获得影像有效值的边界，应该选择否-创建多边形覆盖区域，当然，如果要获取影像范围的外接矩形，就选择是-创建矩形区域；
​
4、GM软件经过计算，就能直接获得影像的边界；
​
5、GM软件获取的是覆盖影像的面，
​
以填充为透明，并和影像叠加的效果如下：
​
总结：
相对于ArcGIS，Global Mapper提取影像边界的方法步骤更加简单，速度也快多了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a3d98b5e40c338bd433e6a49594c88/" rel="bookmark">
			【python代码】Kittle数据集的ground truth生成深度图攻略|彩色深度图|代码无恼运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.明确KITTLE数据集特性
2.选择groundtruth
3.转换深度图
4.转换彩色深度图
1.明确KITTLE数据集特性 KITTI数据集包含了来自车载传感器的多模态数据，包括激光雷达、摄像头和GPS/惯性测量单元（IMU）等。该数据集主要采集于城市环境中，涵盖了驾驶场景中的各种复杂情况，如城市街道、高速公路和乡村道路等。
2.选择groundtruth 选择KITTLE数据集中的proj_depth/groundtruth,选择需要的grouth truth。(细看懂的都懂)
3.转换深度图 代码可直接执行：
加载图像，将其转换为NumPy数组，并除以256。获取有效像素点的位置（xy）。获取有效像素点的深度值。生成一个大小为N×3的数组。 Load image, convert to numpy array and divide by 256Get location (xy) for valid pixelesGet depth values for valid pixelesGenerate an array Nx3 import PIL.Image as Image from scipy.interpolate import LinearNDInterpolator import numpy as np import cv2 # 稀疏-插值-稠密 def lin_interp(shape, xyd): # taken from https://github.com/hunse/kitti m, n = shape ij, d = xyd[:, 1::-1], xyd[:, 2] f = LinearNDInterpolator(ij, d, fill_value=0) J, I = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38a3d98b5e40c338bd433e6a49594c88/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e49a0e1d196b7da8084b56d52024139/" rel="bookmark">
			全国1:1万至1:100万比例尺图幅接合图表分享（附下载链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图幅接合图表实质上是将由图幅分幅线构成的网格叠置在行政区划图上而复合成的图表。
地形图图幅接合表是从事测绘生产管理不可缺少的图件资料。我国使用的地形图中小比例尺有8种，分别是1:5000、1:1万、1:2.5万、1:5万、1:10万、l:25万、1:50万和1:100万。
1992 年国家颁布实施的国家基本比例尺地形图分幅和编号标准（GB/T13989-1992）规定：沿用各比例尺地形图原分幅的经纬差，均以1:100 万地形图为基础图，按相应的经纬差逐级划分图幅，从左上角开始，逐行逐列地进行编号。
新图幅号由10 位组成：第一位是基础图行号的字符码；第二、三位是基础图列号的数字码；第四位是比例尺的代码，分别以B、C、D、E、F、G、H 表示1:50 万、l:25 万、1:10 万、1:5 万、1:2.5 万、1:5000 各种比例尺；第五至第七位为编号行号的数字码，不足3 位的用0 补足。第八至第十位为编号列号的数字码，不足3 位的用0 补足。
本次3S技术之家分享全国基本比例尺地形图接合图表，包括了1:1万至1:100万之间的8种不同比例尺，格式为ArcGIS Mdb个人地理数据库，图幅编号都为新图幅编号。
接合图表主要参数如下： 坐标系：wgs_84地理坐标系
文件格式：mdb数据库
文件大小：207Mb
包含的比例尺：1比1万、1比2.5万、1比5万、1比10万、1比20万、1比25万、1比50万、1比100万
接合图表图形展示： 1:100万接合图表
1:50万接合图表
1:25万接合图表
1:20万接合图表
1:10万接合图表
1:5万接合图表
1:2.5万接合图表
1:1万接合图表
上海市1比1万接合图表
图幅接合表是从事测绘生产管理不可缺少的图件资料，在测绘工作中的应用非常普遍，它能够轻松地查找全国不同比例尺下各区域的图幅号，是工作中不可缺少的好工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0f1ce15dc567bd7ba7ac1236a627240/" rel="bookmark">
			STM32最小系统的组成部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32是意法半导体（STMicroelectronics）公司推出的一系列32位ARM Cortex-M微控制器。最小系统是指将STM32微控制器与必要的外部元件组合在一起，以实现基本的运行功能。下面是一个常见的STM32最小系统的组成部分：
STM32微控制器：选择适合你的应用需求的具体型号，例如STM32F103C8T6。
时钟源：通常使用晶体振荡器（crystal oscillator）作为系统时钟源。常见的晶体振荡器频率为8MHz或16MHz。
复位电路：包括复位电路芯片（reset circuitry）和复位按键（reset button）。复位电路用于初始化微控制器并确保其正常启动。
电源管理电路：包括电源滤波电容和稳压器（voltage regulator）。电源滤波电容用于平滑电源噪声，稳压器则将输入电压稳定为微控制器所需的工作电压。
编程/调试接口：通常使用SWD（Serial Wire Debug）接口或JTAG（Joint Test Action Group）接口进行编程和调试。这些接口允许你使用专用的编程器/调试器与STM32微控制器进行通信。
引脚连接：将STM32微控制器的引脚与外部元件（例如传感器、显示器、按钮等）进行连接，以实现特定的应用功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e293379c5a4bc5e943971fcd10f8fbf5/" rel="bookmark">
			ElasticSearch dense_vector向量写入-Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 介绍2. ElasticSearch 索引设计3. 索引单个文档4. 批量索引文档 1. 介绍 本文介绍了如何使用Java High level API 完成dense_vector类型向量的写入，内容包含了单个文档的索引和批量文档的索引。
2. ElasticSearch 索引设计 PUT caster_vector1 { "settings": { "number_of_replicas": 0, "number_of_shards": 2 }, "mappings": { "properties": { "my_vector": { "type": "dense_vector", "dims": 2 }, "my_text": { "type": "text" } } } } 3. 索引单个文档 package com.example.elasticsearchdemo; import org.apache.http.HttpHost; import org.elasticsearch.action.index.IndexRequest; import org.elasticsearch.action.index.IndexResponse; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestHighLevelClient; import java.io.IOException; import java.util.HashMap; import java.util.Map; public class IndexDoc { public static void main(String[] args) throws IOException { // 创建一个RestHighLevelClient对象 RestHighLevelClient client = new RestHighLevelClient( RestClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e293379c5a4bc5e943971fcd10f8fbf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36907617be6d0f6e4e915976ad8d252/" rel="bookmark">
			ElasticSearch dense_vector向量查询-Java实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 简介 本文介绍如何使用ElasticSearch的Java High Level API执行向量查询，向量类型为dense_vector。
2. ElasticSearch 索引设计 PUT caster_vector1 { "settings": { "number_of_replicas": 0, "number_of_shards": 2 }, "mappings": { "properties": { "my_vector": { "type": "dense_vector", "dims": 2 }, "my_text": { "type": "text" } } } } 3. 向量查询 package com.example.elasticsearchdemo; import org.apache.http.HttpHost; import org.elasticsearch.action.search.SearchRequest; import org.elasticsearch.action.search.SearchResponse; import org.elasticsearch.client.RequestOptions; import org.elasticsearch.client.RestClient; import org.elasticsearch.client.RestHighLevelClient; import org.elasticsearch.index.query.QueryBuilders; import org.elasticsearch.index.query.functionscore.ScriptScoreQueryBuilder; import org.elasticsearch.script.Script; import org.elasticsearch.script.ScriptType; import org.elasticsearch.search.SearchHit; import org.elasticsearch.search.builder.SearchSourceBuilder; import java.io.IOException; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e36907617be6d0f6e4e915976ad8d252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f2eb1137887ec515b21412b10e07295/" rel="bookmark">
			IDEA 启动报错 Internal error. Please refer to https://jb.gg/ide/critical-startup-errors 问题修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在IDEA安装一个插件后，重启IDEA时报错，打不开IDEA。（如下图）
解决 进入C:\Users\{用户名}\AppData\Roaming\JetBrains\IntelliJIdea2020.3\plugins 下删除自己刚才安装的插件，再重新启动下IDEA解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc38b47ee3868a8a585c57c38ab73ace/" rel="bookmark">
			redis中quicklist浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面我们分析了redis中的ziplist相关实现，在结构上一个链表结构，但是在底层用的是一整块内存，在数据量较小的时候，其查找和分配都比较快，但是当数据量比较大的时候，查找和分配就比较慢了。
因此，redis提供了quicklist数据结构，
quicklist的声明如下：
typedef struct quicklist { quicklistNode *head; // quicklistNode *tail; unsigned long count; /* total count of all entries in all ziplists */ unsigned long len; /* number of quicklistNodes */ int fill : QL_FILL_BITS; /* fill factor for individual nodes */ unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */ unsigned int bookmark_count: QL_BM_BITS; quicklistBookmark bookmarks[]; } quicklist; typedef struct quicklistNode { struct quicklistNode *prev; struct quicklistNode *next; unsigned char *zl; unsigned int sz; /* ziplist size in bytes */ unsigned int count : 16; /* count of items in ziplist */ unsigned int encoding : 2; /* RAW==1 or LZF==2 */ unsigned int container : 2; /* NONE==1 or ZIPLIST==2 */ unsigned int recompress : 1; /* was this node previous compressed?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc38b47ee3868a8a585c57c38ab73ace/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8731c6101641a865e259b0bf5896ecce/" rel="bookmark">
			Linux中使用SCP命令进行上传或者下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文目录 1、本地主机与远程主机之间进行文件传输1.1、单个文件的上传与下载1.2、多个文件的上传与下载1.3、按目录进行上传与下载 2、远程主机与远程主机之间进行文件传输 SCP(Secure Copy Protocol)是一种基于SSH的在网络上安全传输文件的文件传输协议，使用SSH（Secure Shell）加密技术来保证数据在传输过程中的安全性。SCP 命令是Linux主机之间进行上传或者下载文件的最常用的命令，这是一个功能非常强大的工具，可以在任意二个主机之间快速的上传与下载一个或者多个文件或者按指定文件夹直接完成整个文件夹下所有文件和文件夹的传输。
1、本地主机与远程主机之间进行文件传输 1.1、单个文件的上传与下载 将本地主机/home/user目录下的example.txt 文件上传到目标主机192.168.3.3的/home/user目录下 scp /home/user/example.txt root@192.168.3.3:/home/user/ 将目标主机192.168.3.3的/home/user目录下的example.txt 文件下载到本地主机/home/user目录下 scp root@192.168.3.3:/home/user/example.txt /home/user 1.2、多个文件的上传与下载 注意这里第二条命令中的转意义字符大括号前的那个\
将本地主机当前目录下的example.txt和example2.txt 文件上传到目标主机192.168.3.3的/home/user目录下： scp ./example.txt ./example2.txt root@192.168.3.3:/home/user/ 将目标主机192.168.3.3的/home/user目录下的example.txt 和example2.txt 文件下载到本地主机的当前目录下： sudo scp root@192.168.3.3:/home/user/\{example.txt,example2.txt\} ./ 1.3、按目录进行上传与下载 将本地主机当前目录下的myfolder1和myfolder2里的所有文件和子文件夹全部上传到目标主机192.168.3.3的/home/user目录下： scp -r ./myfolder1 ./myfolder2 root@192.168.172.104:/home/user/ 将目标主机192.168.3.3的/home/user目录下的temp目录及其所有文件了子目录下载到本地主机当前目录的target目录下： scp -r root@192.168.172.104:/home/user/temp ./target 2、远程主机与远程主机之间进行文件传输 二个远程主机之间传输文件，文件夹的命令和第一章是类似的，只要把源或者目标文件从本地文件替换成远程主机文件则可，如本机是192.168.3.220, 命令需要从192.168.3.10传送一个文件a.out到192.168.3.11:
scp root@192.168.3.10:/home/user/a.out root@192.168.3.11:/home/user/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbcc969d8c5543b2993beb0871fc5971/" rel="bookmark">
			【Django Celery取消预取机制】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django Celery取消预取机制 基本情况问题解决 基本情况 Django + celery，消息队列用的是redis，开启Django服务后，接着开启celery，开启celery的命令如下：
# Linux celery -A zy_ds worker -l info # 测试使用 nohup celery -A zy_ds worker -l info &gt; celery.log 2&gt;&amp;1 &amp; # 正常启动 nohup celery -A zy_ds worker --prefetch-multiplier=1 -l info &gt; celery.log 2&gt;&amp;1 &amp; # 设置并发量为1 # Windows celery -A zy_ds worker -l info -P eventlet # Windows中需要加-P eventlet # Windows中需要提前pip install eventlet settings.py中celery的配置如下：
# ../zy_ds/zy_ds/settings.py # celery配置 CELERY_BROKER_URL = 'redis://:123456@127.0.0.1:6379/0' CELERY_RESULT_BACKEND = 'redis://:123456@127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbcc969d8c5543b2993beb0871fc5971/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/491bed09460577b0c826a927623074b9/" rel="bookmark">
			bat 批处理 批量江文件名称字符串 替换或删除指定字符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@echo off
set /p str1= 请输入要替换的文件(文件夹)名字符串（可替换空格）：
set /p str2= 请输入替换后的文件(文件夹)名字符串（若删除直接回车）：
echo.
echo 正在操作中，请稍候……
for /f "delims=" %%a in ('dir /s /b ^|sort /+65535') do (
if "%%~nxa" neq "%~nx0" (
set "file=%%a"
set "name=%%~na"
set "extension=%%~xa"
call set "name=%%name:%str1%=%str2%%%"
setlocal enabledelayedexpansion
ren "!file!" "!name!!extension!" 2&gt;nul
endlocal
)
)
exit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33c989e49efdbf0f69953eccc3320cb1/" rel="bookmark">
			代码随想录算法训练营第十一天| 20. 有效的括号 、 1047. 删除字符串中的所有相邻重复项 、 150. 逆波兰表达式求值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20. 有效的括号
题目： 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。
示例 1：
输入：s = "()"
输出：true
示例 2：
输入：s = "()[]{}"
输出：true
示例 3：
输入：s = "(]"
输出：false
思路： 先来分析一下 这里有三种不匹配的情况，
第一种情况，字符串里左方向的括号多余了 ，所以不匹配。 第二种情况，括号没有多余，但是 括号的类型没有匹配上。 第三种情况，字符串里右方向的括号多余了，所以不匹配。
那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。
分析完之后，代码其实就比较好写了，
但还有一些技巧，在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！
代码： class Solution { public: bool isValid(string s) { stack&lt;int&gt; st; if(s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求 for(int i = 0; i &lt; s.size(); i++){ if(s[i] == '(') st.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33c989e49efdbf0f69953eccc3320cb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89f9f01e2c73fd9b21685de9039385fc/" rel="bookmark">
			大厂面试必备，字节架构师总结的LeetCode算法刷题笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 想必一些小伙伴都想进大厂吧，但是进大厂，对于程序员来说算法是重中之重，必须攻克，大厂面试必考。
所以小编来给大家送凉爽啦，送一份阿里大佬刷Leetcode总结的算法笔记，如果你能吃透，那我相信80%的技术面试都会不在话下。
限于文章篇幅原因，只能以截图的形式展示出来，有需要的小伙伴可以文末获取↓↓↓
必读系列 动态规划系列 数据结构系列 算法思维系列 高频面试系列 技术文章系列 ​限于文章篇幅原因，就展示到这里了，有需要的小伙伴可以查看下方名片↓↓↓ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48444dba5417ff09b2c3ee25b14c10f0/" rel="bookmark">
			Neo4j apoc一些简单常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apoc.convert.fromJsonList()-字符串数组转json格式
apoc.convert.fromJsonMap()-字符串json转json格式
apoc.convert.toSet(list)- list去重
RETURN apoc.convert.fromJsonList("['xxx']") RETURN apoc.convert.fromJsonMap('{"product": {"name": "Bloom"}}', '$.product') AS output; //转化成json并提取指定key的值 RETURN apoc.convert.toSet([1,2,3,2]) AS output; //[1, 2, 3] apoc.convert.getJsonProperty()- 提取字符串json内的值
CREATE (:Person {json:'{a:[1,2,3]}'}); RETURN apoc.convert.getJsonProperty(p, "json") AS output; //{a: [1, 2, 3]} RETURN apoc.convert.getJsonProperty(p, "json", "$.a") AS output; // [1, 2, 3] create (n:JsonPathNode{prop:'{"columns":{"col2":{"_id":"772col2"}}}'}) RETURN apoc.convert.getJsonProperty(n, 'prop', '$..columns', ['ALWAYS_RETURN_LIST']) AS output; //指定返回格式 // [ {"col2": { "_id": "772col2" }}, null, null ] apoc.coll.contains(list,str) 判断str是否存在list中，返回true和false
RETURN apoc.coll.contains([1,2,3,4,5], 4) AS output; //单个匹配 RETURN apoc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48444dba5417ff09b2c3ee25b14c10f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20bc17e3e414b078fcfcf7a9fe2225a2/" rel="bookmark">
			Curl【实例 01】curl下载使用及cmd实例脚本分享（通过请求下载文件）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Curl 官方下载地址 可下载不同平台不同版本的安装包，本次使用的是Windows解压版本curl-8.0.1_9-win32-mingw.zip。
curl下载使用及cmd实例 1.是什么1.1 curl1.2 bat和cmd 2.常用命令2.1 发送GET请求并显示响应头信息2.2 显示详细的请求和响应信息2.3 限制重定向次数2.4 带Json数据的Post请求发送2.5 带文件的Post请求发送2.6 使用代理服务器发送请求2.7 下载文件并保存到指定路径 3.实例分享3.1 直接下载3.2 保存后复制3.3 实际演示图 1.是什么 1.1 curl curl是一个开源的命令行工具和库，用于在终端和脚本中进行网络数据传输。它支持多种协议，如HTTP、HTTPS、FTP、SMTP等，可以通过URL进行数据传输和通信。
curl的功能非常强大，它可以执行各种操作，包括发送HTTP请求、下载文件、上传文件、进行身份验证、处理cookie等。它提供了丰富的选项和参数，可以灵活地配置请求和处理服务器响应。
通过curl，我们可以轻松地在命令行中执行各种网络操作，比如获取网页内容、测试API接口、下载文件等。同时，由于curl是一个非常常见和流行的工具，几乎在所有主流操作系统中都有可用的版本。
除了作为命令行工具，curl还提供了一个C语言库，可以在程序中嵌入和使用。这使得开发人员可以利用curl的功能和接口，编写自己的网络应用程序。
总而言之，curl是一个功能强大的命令行工具和库，用于在终端和脚本中进行网络数据传输和通信。它在各种场景下都是一个非常有用的工具，特别是在自动化测试、调试和开发过程中。
我们曾经用wget实现了网站数据的爬取，想必curl应该也是可以的。
1.2 bat和cmd .bat和.cmd是Windows操作系统中常见的批处理脚本文件的扩展名。它们在功能上非常相似，但有一些区别。
执行方式：.bat文件通常由旧版本的Windows命令解释器（COMMAND.COM）执行，而.cmd文件通常由新版本的Windows命令解释器（CMD.EXE）执行。CMD.EXE提供了更多的功能和特性，因此.cmd文件更加灵活。
执行环境：.bat文件在Windows的实模式下运行，而.cmd文件在Windows的保护模式下运行。保护模式提供了更好的内存管理和系统资源支持。
可移植性：由于.bat文件是在旧版本的命令解释器下执行，它们的兼容性可能受到限制。相比之下，.cmd文件在更广泛的Windows系统上具有更好的兼容性。
命令扩展：.cmd文件支持更多的命令扩展，如IF EXIST、FOR /F等，而.bat文件可能不支持这些扩展。
脚本编写：由于.cmd文件支持更多的命令扩展和功能，因此它们提供了更强大的脚本编写能力。
总的来说，.cmd文件比.bat文件更加灵活和功能丰富，并提供更好的可移植性。如果你需要使用更多的命令扩展或希望在较新的Windows系统上运行脚本，建议使用.cmd扩展名。
2.常用命令 注意：以下命令未经验证。
2.1 发送GET请求并显示响应头信息 # 这个命令将向"https://api.example.com/users"发送一个HEAD请求，并显示服务器返回的响应头信息，而不包括响应体。 curl -I https://api.example.com/users 2.2 显示详细的请求和响应信息 # 使用"-v"选项，这个命令将显示完整的请求和响应信息，包括请求头、响应头和响应体。 curl -v https://api.example.com/users 2.3 限制重定向次数 # 通过"-L"选项，这个命令将跟随重定向，并使用"--max-redirs"选项限制重定向的次数为3次。 curl -L --max-redirs 3 https://example.com 2.4 带Json数据的Post请求发送 curl -X POST -H "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20bc17e3e414b078fcfcf7a9fe2225a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cb9b9e9c1604fa9fcf376e2dfe8e291/" rel="bookmark">
			打车/代驾/跑腿小程序源码司机入住uniapp/thinkphp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发代驾+顺风车+货运
客户端：Uniapp 开发
司机端：Uniapp 开发
后台：thinkphp5 框架
数据库：MySQL
打车/代驾/跑腿小程序源码司机入住uniapp/thinkphp
为什么用UNIAPP开发？
UNIAPP框架简单，学习成本低，开发周期短，一套代码可生成多端版本(h5、小程序(各个平台)、APP），这就是现在为什么软件开发公司使用UNIAPP开发了
&lt;template&gt;
&lt;view&gt;
&lt;view class="header"&gt;
&lt;image src="../../static/booklist-header.png" mode=""&gt;&lt;/image&gt;
&lt;/view&gt;
&lt;empty top="180" v-if="list.length==0" text="暂无车主"&gt;&lt;/empty&gt;
&lt;view style="padding-bottom: 150rpx;"&gt;
&lt;view @click="toDetail(item.id)" v-for="(item,i) in list"
:key="i"&gt;
&lt;view class="text-center blue bold"&gt;
{{item.start_time}}
&lt;/view&gt;
&lt;view class="flex mt-10"&gt;
&lt;view class=""&gt;
&lt;text class="gray-2"&gt;【车主】&lt;/text&gt;{{item.driver_name}}
&lt;/view&gt;
&lt;view class="flex1 flex-middle"&gt;
&lt;text class="gray-2"&gt;【余座】&lt;/text&gt;{{item.more_seats}}
&lt;u-icon name="arrow-right" color="rgba(51,51,51,0.3)" size="35"&gt;&lt;/u-icon&gt;
&lt;/view&gt;
&lt;/view&gt;
&lt;view class="mt-10"&gt;
&lt;text class="gray-2"&gt;【车型】&lt;/text&gt;{{item.car_type}}
&lt;/view&gt;
&lt;view class="flex1 mt-10"&gt;
&lt;text class="gray-2"&gt;【路线】&lt;/text&gt;
&lt;view class="u-flex-1"&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cb9b9e9c1604fa9fcf376e2dfe8e291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a473c85a4bdd07d3771e12dd86c587/" rel="bookmark">
			在SQL server中用sql语句实现数据库的备份以及还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文给大家提供并讲解了在SQL server中用SQL语句实现数据库的备份已经还原
备份数据库 假设你已经有一个数据库Student
创建备份设备，其名称为bk_Student，保存文件为D:\ Student.bak，并对Student数据库进行完全备份，备份到备份设备bk_ Student中。
EXEC sp_addumpdevice 'disk', 'bk_Student', 'D:\Student.bak' BACKUP DATABASE Student TO DISK = 'D:\Student.bak' with format; 在Student数据库中，创建一张表temp并对Student数据库进行第一次差异备份，备份到备份设备bk_Student中 //表的内容不重要
下面这段代码的意思是进行一次差异备份，并且备份到bk_Student
如果需要进行第二次差异备份，那就在你进行完对表的操作后再用一次下面的代码
backup database Student to disk ='D:\Student.bak' with DIFFERENTIAL; 还原数据库 还原完整数据库 从备份设备bk_ Student中恢复Student数据库
RESTORE DATABASE Student FROM DISK = 'D:\Student.bak' WITH REPLACE, RECOVERY 还原差异数据库 将Student数据库恢复到第一次差异备份后的状态
RESTORE DATABASE Student FROM DISK = 'D:\Student.bak' WITH NORECOVERY 下面FILE可以在服务器对象--备份对象--bk_Student2--介质内容中可以看到位置2是差异备份，位置1是完整备份的（如果是按照我这篇文章的顺序的话）
若在后面加入多次差异备份，可以更改file的值，当file=3时，还原的时候将会把第二次差异备份的内容还原，包括之前备份的内容
RESTORE DATABASE Student FROM DISK = 'D:\Student.bak' WITH file=2, NORECOVERY; 当你执行完还原操作后，一定要进行下面的操作，这样就可以结束当前还原操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a473c85a4bdd07d3771e12dd86c587/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/968ad4c2ab1d63ac51fc4f47a76edb70/" rel="bookmark">
			ESP32 FreeRTOS-事件组(10)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：好记性不如烂笔头。本博客作为学习笔记，有错误的地方希望指正
文章目录 前言：一、xEventGroupCreate()二、xEventGroupCreateStatic()三、vEventGroupDelete()四、xEventGroupWaitBits()五、xEventGroupSetBits()六、xEventGroupSetBitsFromISR()七、xEventGroupClearBits()八、xEventGroupClearBitsFromISR()九、xEventGroupGetBits()十、xEventGroupGetBitsFromISR()十一、xEventGroupSync()十二、事件组示例 前言： 参考资料：FreeRTOS API参考
事件组我们可以实现多个任务同时等待一个事件，或者多个事件中一个事件执发生之后的检测，实现事件的同步和事件等待。
一、xEventGroupCreate() API原型：
EventGroupHandle_t xEventGroupCreate( void ); 创建一个新的 RTOS 事件组，并返回 可以引用新创建的事件组的句柄。
要使此 RTOS API 函数可用：
configSUPPORT_DYNAMIC_ALLOCATION 必须在 FreeRTOSConfig.h 中设置为 1，或保留未定义状态（此时 默认为 1）。RTOS 源文件 FreeRTOS/source/event_groups.c 必须 包含在构建中。
每个事件组都需要非常少量 RAM 来保存 事件组的状态。 如果使用 xEventGroupCreate() 创建事件组， 则会从 RAM 堆FreeRTOS中自动分配所需的 。 如果使用 xEventGroupCreateStatic() 创建事件组 则 RAM 由应用程序编写者提供，这需要用到一个附加参数， 但允许在编译时静态分配 RAM 。 请参阅静态分配与 动态分配页面了解更多信息。 事件组存储在 EventBits_t 类型的变量中。 如 果 configUSE_16_bit_TICKS 设置为 1，则事件组内实现的位（或标志）数为 8； 如果 configUSE_16_bit_TICKS 设置为 0，则为 24。 依赖于 configUSE_16_BIT_TICKS 的值 取决于 RTOS 任务内部实现中用于线程本地存储的数据类型。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/968ad4c2ab1d63ac51fc4f47a76edb70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3b73852f31686cbb6b955b2d992691e/" rel="bookmark">
			Springboot整合canal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载canal 配置 下载地址：Releases · alibaba/canal · GitHub
解压文件到windows下
修改解压文件的文件下面箭头指向的这两个文件（注意这两个文件不在一个目录下）
修改canal.properties文件 （其他根据自己需求修改）
# 端口默认的改不改都可以 canal.port = 11111 # 这个example 就指向conf文件夹下的example文件夹 canal.destinations = example # 这个根据自己需求修改 tcp, kafka, rocketMQ, rabbitMQ, pulsarMQ canal.serverMode = tcp 修改 example/instance.properties 文件信息（其他信息根据自己需求） canal.instance.mysql.slaveId=20 //不要重复 canal.instance.master.address=127.0.0.1:3306// 数据库地址 canal.instance.dbUsername=root //连接自己数据库的账号密码 canal.instance.dbPassword=password 注意 example 可以有多个 名字必须不一样，可以配置监听多个数据库 比如默认的是example 你可以创建一个 exampl01 ，检测另一个数据库 把exampl目录下的东西复制到exampl0，修改instance.properties 文件 根据需求 然后更改canal.properties 文件 canal.destinations = example01
然后启动canal
启动成功的界面如下
2.mysql配置 在mysql的my.ini文件下添加 [mysqld] # 打开binlog 设置生成文件的地址根据自己的选择 log-bin=C:/xxx/xxx/mysql-bin.log # 选择ROW(行)模式 binlog-format=ROW # 监控的数据库,不配置监控所有库的变化 binlog-do-db=ajax # 配置MySQL replaction需要定义，不要和canal的slaveId重复 server_id=1 配置完 mysql配置 重启mysql服务，必须重启，否则不生效
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3b73852f31686cbb6b955b2d992691e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba57126f3b3976d9a374035b7aee52c/" rel="bookmark">
			阿里面试必问：Hash冲突怎么办，哪些解决散列冲突的方法？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。
创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。
下面以创建哈希表为例，说明解决冲突的方法。常用的解决冲突方法有以下四种：
开放定址法 这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。
这种方法有一个通用的再散列函数形式：
Hi=（H（key）+di）% m i=1，2，…，n
其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：
线性探测再散列
dii=1，2，3，…，m-1
这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。
二次探测再散列
di=12，-12，22，-22，…，k2，-k2 ( k&lt;=m/2 )
这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。
伪随机探测再散列，di=伪随机数序列。
具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。
例如，已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。
如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。
如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。
如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。
再哈希法 这种方法是同时构造多个不同的哈希函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ba57126f3b3976d9a374035b7aee52c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8662e9faffda388aaccdf73a511bce44/" rel="bookmark">
			4 种 MySQL 同步 ES 方案，yyds！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上周听到公司同事分享 MySQL 同步数据到 ES 的方案，发现很有意思，感觉有必要将这块知识点再总结提炼一下，就有了这篇文章。
本文会先讲述数据同步的 4 种方案，并给出常用数据迁移工具，干货满满！
不 BB，上文章目录：
1. 前言 在实际项目开发中，我们经常将 MySQL 作为业务数据库，ES 作为查询数据库，用来实现读写分离，缓解 MySQL 数据库的查询压力，应对海量数据的复杂查询。
这其中有一个很重要的问题，就是如何实现 MySQL 数据库和 ES 的数据同步，今天和大家聊聊 MySQL 和 ES 数据同步的各种方案。
我们先看看下面 4 种常用的数据同步方案。
2. 数据同步方案 2.1 同步双写 这是一种最为简单的方式，在将数据写到 MySQL 时，同时将数据写到 ES。
优点：
业务逻辑简单；
实时性高。
缺点：
硬编码，有需要写入 MySQL 的地方都需要添加写入 ES 的代码；
业务强耦合；
存在双写失败丢数据风险；
性能较差，本来 MySQL 的性能不是很高，再加一个 ES，系统的性能必然会下降。
2.2 异步双写 针对多数据源写入的场景，可以借助 MQ 实现异步的多源写入。
优点：
性能高；
不易出现数据丢失问题，主要基于 MQ 消息的消费保障机制，比如 ES 宕机或者写入失败，还能重新消费 MQ 消息；
多源写入之间相互隔离，便于扩展更多的数据源写入。
缺点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8662e9faffda388aaccdf73a511bce44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9069475336f2e97f677b7574b1687c4e/" rel="bookmark">
			word文档显示文件已损坏打不开怎么办呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#word技巧#有几种可能的原因导致 Word 文档损坏，比如磁盘驱动器故障、文件传输或下载错误、病毒攻击等等。以下是几种可以尝试修复损坏的 Word 文档的方法： 1. 使用 Word 的“打开和修复”功能。在 Word 中，选择“文件”&gt;“打开”，然后选择受损的文件。在打开的窗口上点击下拉箭头，然后选择“打开和修复”，然后尝试“恢复文本”或“恢复文本和格式”选项。如果您运气好，该方法可能会修复您的文件。
2. 尝试使用其他文本编辑器打开文件。有时，其他的编辑器（如Notepad++）比 Word 更专业地处理文件损坏问题，可能会让您将一部分至少的文本恢复到另一个文档中。
3. 使用“Open and Repair”功能。在 Windows 资源管理器中，右键单击受损的文件，然后选择“属性”。在“属性”对话框中，选择“常规”选项卡，然后单击“高级”。在“高级属性”对话框中，选中“打开和修复”，然后单击“OK”。重新打开文件，看看它是否修复。
4. 使用第三方工具。有一些第三方工具可以帮助恢复损坏的 Word 文档，如Kernel for Word，S2 Recovery Tools for Microsoft Word等。
总之，您可以尝试以上这些方法来修复损坏的 Word 文档。如果以上方法都不能解决问题，您可能需要考虑重建文件或者找到原始文档重新编辑。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b87e09669484a8b027da7ccbbd95cb09/" rel="bookmark">
			搭建一个vuepress静态网站及配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搭建一个vuepress静态网站及配置 一、搭建一个vuepress网站1、创建并进入一个新目录2、初始化3、安装依赖4、创建文档5、配置启动命令及启动6、展示效果 二、配置及丰富vuepress网站1、增加配置文件2、配置侧边栏目录3、使用部分markdown语法完善页面 一、搭建一个vuepress网站 前提条件：
VuePress 需要 Node.js (opens new window)&gt;= 8.6
1、创建并进入一个新目录 mkdir vuepress-starter &amp;&amp; cd vuepress-starter 2、初始化 yarn init 或 npm init 一路回车生成package.json
3、安装依赖 根据项目开发环境安装vuepress依赖
yarn add -D vuepress 或 npm install -D vuepress 注意:
如果你的现有项目依赖了webpack 3.x ，我们推荐使用 Yarn (opens new window)而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树。
4、创建文档 mkdir docs &amp;&amp; echo # Hello VuePress &gt; docs/README.md 5、配置启动命令及启动 在package.json中配置scripts，可以替换启动命令，如果不配置的话，启动的命令则是npx vuepress dev docs
"scripts": { "dev": "vuepress dev docs", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b87e09669484a8b027da7ccbbd95cb09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d0d01684dd0da1b3f35a288c7442aa0/" rel="bookmark">
			Fay控制器及数字人模型，可灵活组合出不同的应用场景：虚拟主播、现场推销货、商品导购、语音助理、远程语音助理、数字人互动、数字人面试官及心理测评、贾维斯、Her
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FAY 数 字 人 Fay 控 制 器(这是元宇宙吗？) Fay是一个完整的开源项目，包含Fay控制器及数字人模型，可灵活组合出不同的应用场景：虚拟主播、现场推销货、商品导购、语音助理、远程语音助理、数字人互动、数字人面试官及心理测评、贾维斯、Her。开发人员可以利用该项目简单地构建各种类型的数字人或数字助理。该项目各模块之间耦合度非常低，包括声音来源、语音识别、情绪分析、NLP处理、情绪语音合成、语音输出和表情动作输出等模块。每个模块都可以轻松地更换。
推荐集成的开源仓库 消费级pc大模型：https://github.com/THUDM/ChatGLM-6B
全平台抖音抓包：https://github.com/wwengg/douyin
UE5工程：https://github.com/xszyou/fay-ue5
实时照片驱动集成：https://github.com/waityousea/xuniren
一、Fay控制器用途 远程语音助理 PC demo 远程语音助理 android demo 与数字形象通讯（非必须,控制器需要关闭“面板播放”） 控制器与采用 WebSocket 方式与 UE 通讯
下载工程: https://pan.baidu.com/s/1RBo2Pie6A5yTrCf1cn_Tuw?pwd=ck99
下载windows运行包: https://pan.baidu.com/s/1CsJ647uV5rS2NjQH3QT0Iw?pwd=s9s8
工程及运行包：https://github.com/xszyou/fay-ue5
发您的Fay运行效果视频至公众号领取最新的UE5模型哦
通讯地址: ws://127.0.0.1:10002（已接通）
消息格式: 查看 WebSocket.md
与远程音频输入输出设备连接（非必须,外网需要配置http://ngrok.cc tcp通道的clientid） 控制器与采用 socket(非websocket) 方式与 音频输出设备通讯
内网通讯地址: ws://127.0.0.1:10001
外网通讯地址: 通过http://ngrok.cc获取（有伙伴愿意赞助服务器给社区免费使用吗？）
消息格式: 参考 remote_audio.py
二、Fay控制器核心逻辑 注：
1、去API及会话管理功能将在下一版本发布；
2、以上每个模块可轻易替换成自家核心产品。
3、本地nlp（rasa+chatglm）的替换方法（https://m.bilibili.com/video/BV1D14y1f7pr?wxfid=o7omF0Vs6RIQFUGAzB6LXOBHa6Yg）： 1、安装启动chatglm(github) 2、安装rasa 包：rasa、rasa-sdk 3、进入test/rasa目录启动actions：rasa run actions 4、启动rasa api server：rasa run --enable-api -p 5006 5、fay_core.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d0d01684dd0da1b3f35a288c7442aa0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5184693abc19530d7840b12b4656fb14/" rel="bookmark">
			PyQt5中模拟快捷键触发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述：项目中需要测试快捷键操作，就整理了这个小demo import functools import os import sys from PyQt5.Qt import * class Widget(QWidget): def __init__(self, parent=None): super().__init__(parent) self.resize(900, 600) size = 150, 50 tt1 = QToolButton(self) tt1.setFixedSize(*size) ac = QAction("快捷键D测试") ac.setShortcut("D") ac.triggered.connect(functools.partial(self.ac_slot, ac)) tt1.setDefaultAction(ac) tt2 = QToolButton(self) tt2.setFixedSize(*size) tt2.move(0, 50) ac = QAction("快捷键Shift+D测试") ac.setShortcut("Shift+D") ac.triggered.connect(functools.partial(self.ac_slot, ac)) tt2.setDefaultAction(ac) tt2 = QToolButton(self) tt2.setFixedSize(*size) tt2.move(0, 100) ac = QAction("快捷键Shift+Alt+D测试") ac.setShortcut("Shift+Alt+D") ac.triggered.connect(functools.partial(self.ac_slot, ac)) tt2.setDefaultAction(ac) t = QTimer(self) t.timeout.connect(self.tt_slot1) t.start(2000) t = QTimer(self) t.timeout.connect(self.tt_slot2) t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5184693abc19530d7840b12b4656fb14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a54c12b6573b91db08ed4e953df06a6e/" rel="bookmark">
			QtWebEngine - qt 版本与Chromium版本对应关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QtWebEngine - qt 版本与Chromium版本对应关系 Qt VersionChromium Version6.5.0108.0.5359.1816.4.0102.0.5005.1776.3.094.0.4606.1266.2.6-6.2.8102.0.5005.1776.2.4-6.2.594.0.4606.1266.2.090.0.4430.2285.15.3–5.15.x87.0.4280.1445.15.283.0.4103.1225.15.0–5.15.180.0.3987.1365.14.0–5.14.177.0.3865.985.13.0–5.13.273.0.3683.1055.12.0–5.12.769.0.3497.1135.11.0–5.11.365.0.3325.1515.10.161.0.3163.1405.10.061.0.3163.995.9.0–5.9.956.0.2924.1225.8.053.0.2785.1485.7.0–5.7.149.0.2623.1115.6.349.0.2623.1115.6.0–5.6.245.0.2554.1015.5.0–5.5.140.0.2214.1155.4.0–5.4.237.0.2062.103 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ec8ed96215c226dbe91f5209188bdc/" rel="bookmark">
			一直在说高并发，多少QPS才算高并发？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		高并发的四个角度 只说并发不提高可用就是耍流氓。可以从四个角度讨论这个问题。
首先是无状态前端机器不足以承载请求流量，需要进行水平扩展，一般QPS是千级。 然后是关系型数据库无法承载读取或写入峰值，需要数据库横向扩展或引入nosql，一般是千到万级。 之后是单机nosql无法承载，需要nosql横向扩展，一般是十万到百万QPS。 最后是难以单纯横向扩展nosql，比如微博就引入多级缓存架构，这种架构一般可以应对百万到千万对nosql的访问QPS。 当然面向用户的接口请求一般到不了这个量级，QPS递增大多是由于读放大造成的压力，单也属于高并发架构考虑的范畴。
PV和QPS 比如微博每天1亿多pv的系统一般也就1500QPS，5000QPS峰值。
比如有人说：
2C4G机器单机一般1000QPS。8C8G机器单机可承受7000QPS。 要多久才能处理完这些请求 首先需要明确两个基本点：
1、处理每个请求需要耗费时间，哪怕时间很短
2、服务资源是有限的，不能一次性处理全部请求
假定总并发请求数量为10000，每个请求的处理时间为t秒，服务器一次性可以处理的请求数量为n个，那么处理完所有的请求需要用时为T
T = (10000 / n ) * t
由此可知，如果一次性可以处理10000个请求，那么总耗时只需要t秒
写在后面 具体多少QPS跟业务强相关，只读接口读缓存，将压力给到缓存单机3000+没问题，写请求1000+也正常，也复杂些可能也就几百+QPS。
所以QPS和业务场景和设计相关性很大，比如可以通过浏览器本地缓存，用缓存做热点数据查询，写事务MQ异步处理等方式提升QPS。
转载于:https://my.oschina.net/u/1000241/blog/3065185
2023-05-30 18时~19时（xx序，没算埋点）
(2283917+2320542)/(60*60)=1279
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abacc14997d7b4895cc813a754b12e91/" rel="bookmark">
			SpringBoot统一功能处理（统一处理用户登陆权限验证、统一异常处理以及统一数据返回格式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. SpringBoot统一功能处理简介
2. 统一处理用户登陆验证
2.1 原生SpringAOP实现统一登陆验证的问题
2.2 Spring拦截器实现用户统一登陆验证
2.3 扩展: 统一访问前缀添加
3. 统一异常处理 4. 统一数据返回格式
4.1 统一数据返回格式的必要性
4.2 实现统一数据返回格式的功能
5. 总结
1.SpringBoot统一功能处理简介 我们在上篇博客中学习了AOP思想以及SpringAOP实现，但是在实际的业务开发中，使用原生的SpringAOP开发是很难满足我们真正的的业务需求的。我们在这里总结的SpringBoot统一功能处理就是对原生的SpringAOP操作的一种增强集合，为什么这么说呢，一起来向下看吧！
2.统一处理用户登陆验证 2.1 原生SpringAOP实现统一登陆验证的问题 在学习了SpringAOP的原生操作后，我就立即着手想着去写一个统一处理用户登陆权限验证的功能。可能大多数小伙伴的想法和我一致，直接使用SpringAOP的前置通知方法或者环绕通知方法来实现不就行了吗？但是在真正使用原生SpringAOP对该功能进行实现时，我遇到了以下几个问题：
首先是要验证用户的登陆状态，就要先获取到内存中的session对象，但是通过前置或者环绕通知的方式时很难拿到请求对象的，也就很难拿到session对象进行判断。其次是与我们用户相关的控制器中并非所有方法都要进行拦截判断（像登录、注册方法），那这样就大大增加了通过原生SpringAOP的切点表达式配置拦截规则的难度 那该怎么解决上述的问题呢？——更好的解决办法就是使用Spring拦截器~
2.2 Spring拦截器实现用户统一登陆验证 使用Spring拦截器实现用户统一验证登录的步骤整体上分为以下几步：
创建一个自定义类实现HandlerInterceptor接口，并重写preHandler方法，在该方法中编写进行统一用户登陆验证的逻辑代码。将1中创建的拦截器加入到系统配置中，并配置拦截器的拦截规则。本步骤其实就是通过创建一个自定义类实现WebMvcConfigurable接口，并标注@Configuration注解将该类交由Spring进行管理，同时重写接口的addInterceptors方法，在该方法中将创建的HandlerInterceptor接口子类传入，并配置拦截规则。 接下来我们在程序中实际定义一个用户登陆权限校验的拦截器来学习以下上边拦截器的具体实现过程及定义的相关注意事项：
0.准备工作。
1.首先创建自定义类LoginInterceptor拦截器类实现HandlerInterceptor接口，并重写preHandler方法，在其中编写我们进行用户统一登录的验证逻辑。
2.创建自定义系统配置类实现WebMvcConfigurable接口，并重写addInterceptors方法，加上@Configuration将我们创建的拦截器类的实例对象加入到系统配置中并指定该拦截器的拦截规则。
3.到这里，我们自定义的拦截器就完成配置啦！接下来，我们启动程序来进行测试。
2.3 扩展: 统一访问前缀添加 在实际的业务场景中，一台服务器上时可能会有多个服务的。而这些服务通常也是通过同一端口来与外界进行通信的。那么，它们是怎么实现同一端口通信的呢？这个时候就需要用到统一前缀添加了。给同一台服务器上的不同服务加上不同的统一前缀，这样就能够让网关系统识别并匹配到对应的服务。那该怎么实现统一前缀添加呢？实现方式有以下两种：
在系统配置中配置
在实现了WebMcvConfigurer的类中覆写接口中的configurePathMatch方法并指定统一前缀。 在SpringBoot的application配置文件中配置 # 在配置文件中配置，在所有的路由最前统一加上前缀/bai server: servlet: context-path: /bai 通过了以上配置，我们再来请求原来的路由对应的接口，会发现页面信息不存在。这个时候就需要加上程序中添加的统一前缀了。之后服务器的网关才能够通过识别这个统一前缀将你的请求转发到指定的服务进行处理返回。
3. 统一异常处理 为什么要进行统一异常处理呢？
这是因为如果我们不进行统一的异常处理，那么当后端程序抛出异常后程序不再往下运行，前端会在控制台报错，而用户发送请求后由于后端程序没有响应也就导致页面无响应，大大降低了客户的体验感。我们来模拟一下后端程序抛出异常时的场景：
接下来我们就来实现一下程序的统一异常处理功能，对比下统一异常处理后我们的后端程序的有哪些优点。
实现统一异常处理的步骤如下：
创建一个统一异常处理类，标注上@ControllerAdvice注解表示这是一个统一异常处理类，@ControllerAdvice注解中包含@Component注解，所以该类也会加入到Spring中随着框架的加载而加载。再类中定义异常处理方法，标注上@ExceptionHandler异常管理器注解订阅异常，并在方法中将异常处理后的结果返回给前端。 接下来我们一起来实现以下统一异常处理的功能，学习一下实现的细节和注意事项：
通过上述的实现过程，我们可以总结出统一异常处理功能实现时要注意：
当有多个异常处理的通知方法时，程序抛出的异常对象是按照由子类到父类的顺序进行匹配的。 实现统一异常处理使用到注解@ControllerAdvice、@ResponseBody（选用，看你返回的是页面还是数据）以及@ExceptionHandler。 4. 统一数据返回格式 4.1 统一数据返回格式的必要性 要知道，实际的开发场景中，一个项目不可能是由我们一人独自完成的。如果这时候每个后端开发程序员返回给前端的数据以及数据格式各式各样，那前端程序员大概率要懵逼：“这个接口返回的数据是什么来着？这个接口返回的数据格式是什么来着？...晕😵”！当统一了数据的返回格式后，优点是十分显著的，例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abacc14997d7b4895cc813a754b12e91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0697c0fbc8cf04ae0116f3bd0f2df0d/" rel="bookmark">
			C&#43;&#43;实现sqlite单表增删改查的详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境准备 coding之前需要先安装好C++的集成开发环境， 我这里选择的是Visual Studio 2022，本来想使用CLion的， 但是破解太麻烦，懒得整了。
Visual Studio 2022 2.项目创建及编码 启动visual studio, 点击创建项目，选择“空项目”
配置项目名称和项目工作目录以及解决方案名称，之后， 点击“创建”即可创建一个C++空项目。
CREATE TABLE IF NOT EXISTS t_student ( id INTEGER PRIMARY KEY, name TEXT, age INTEGER, gender TEXT, class_no TEXT, grade_no TEXT, nation TEXT ); 代码实现
#include &lt;sqlite3.h&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; const char* DB_FILE_PATH = "D:/commonTools/sqliteDB/student.db"; class DatabaseManager { public: DatabaseManager() { int result = sqlite3_open(DB_FILE_PATH, &amp;db_); if (result != SQLITE_OK) { std::cerr &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0697c0fbc8cf04ae0116f3bd0f2df0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5de28b008d1edd5ac0e7a11d0c3c3f00/" rel="bookmark">
			ubuntu 离线安装gcc-10 ( 系统 20.0.4 focal )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo lsb_release -a 显示系统版本
根据系统版本信息在
http://packages.ubuntu.com/precise/amd64/g++/filelist
找到对应的系统安装内容
https://packages.ubuntu.com/focal/devel/
http://archive.ubuntu.com/ubuntu/pool/main/ 这个是文件下载内容地址
在页面
https://packages.ubuntu.com/focal/devel/
找到gcc-10 ,点击到
https://packages.ubuntu.com/focal/devel/gcc-10 里面有标注相关依赖包。
http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-10/
在 https://packages.ubuntu.com/focal/devel/gcc-10 子页面在点进去子下载页面会告诉文件的下载位置
对应版本在内容页面标注了文件名
gcc-10-base pool/main/g/gcc-10/ gcc-10-base_10-20200411-0ubuntu1_amd64.deb
linux-libc-dev pool/main/l/linux/ linux-libc-dev_5.4.0-26.30_amd64.deb
libbinutils pool/main/l/linux/ libbinutils_2.34-6ubuntu1_amd64.deb
binutils-common pool/main/b/binutils/ binutils-common_2.34-6ubuntu1_amd64.deb
libctf0 pool/main/b/binutils/ libctf0_2.34-6ubuntu1.5_amd64.deb
binutils-x86-64 pool/main/b/binutils/ binutils-x86-64-linux-gnu_2.34-6ubuntu1_amd64.deb
binutils pool/main/b/binutils/ binutils_2.34-6ubuntu1_amd64.deb
libasan6 pool/main/g/gcc-10/ libasan6_10-20200411-0ubuntu1_amd64.deb
libatomic1 pool/main/g/gcc-10/ libatomic1_10-20200411-0ubuntu1_amd64.deb
libitm1 pool/main/g/gcc-10/ libitm1_10-20200411-0ubuntu1_amd64.deb
liblsan0 pool/main/g/gcc-10/ liblsan0_10-20200411-0ubuntu1_amd64.deb
libquadmath0 pool/main/g/gcc-10/ libquadmath0_10.3.0-1ubuntu1~20.04_amd64.deb
libtsan0 pool/main/g/gcc-10/ libtsan0_10-20200411-0ubuntu1_amd64.deb
libubsan1 pool/main/g/gcc-10/ libubsan1_10-20200411-0ubuntu1_amd64.deb libcrypt-dev pool/main/libx/libxcrypt/ libcrypt-dev_4.4.10-10ubuntu4_amd64.deb
libcrypt1 pool/main/libx/libxcrypt/ libcrypt1_4.4.10-10ubuntu4_amd64.deb
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5de28b008d1edd5ac0e7a11d0c3c3f00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0b4f5024f4411db8bb4b00ab7bd7fad/" rel="bookmark">
			全网最全的微服务&#43;Outh2套餐，你确定不来试一试？（入门到精通，附源码）满足你的味蕾需要（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		outh2是什么？ OAuth 2.0不是一个API或者服务，是一个业界标准的授权协议，而是一个验证授权(Authorization)的开放标准 。OAuth 2.0提供一种协议交互框架，让某个 A应用 能够以安全地方式获取到 B用户 的 C委派书，这个 C委派书 在OAuth 2.0中就是访问令牌（access token），随后 A应用 便可以使用 该C委派书，代表 B用户 来访问 B用户的相关资源。
什么？上面那些你一句看不懂？那看这里，今天必须让你吃饱！
俗话：我 在 CSDN平台 要登录账号，但是不想通过CSDN注册账号，我选择通过点击 CSDN平台登录下方的 微信 登录，手机扫码后 微信 告诉是不是要在 CSDN平台 上登录并授权自己的 微信基本信息，我选择了 登录并授权 ， CSDN平台 就帮我注册了一个账号，并且账号里还有我的一些 微信 的基本信息。
在OAuth 2.0的协议交互中，有四个角色的定义，
资源所有者（Resource Owner）：即（ 我 ）用户，（但不限于人，如某些应用也会创建资源），拥有资源的所有权。资源服务器（Resource Server）：（ 微信基本信息 ）即保存着受保护的用户资源，本身可以是资源服务。应用程序（Client）：即（ CSDN平台 ）（ 微信 ）准备访问用户资源的应用程序，其可能是web应用，或是后端web服务应用，或是移动端应用，也或是桌面可执行程序。授权服务器（Authorization Server）：即（ 登录并授权 ）授权服务器，在获取用户的同意授权后，颁发访问令牌给应用程序，以便其获取用户资源。 Oauth选择依赖包应该怎么选？ #在接下来的演示中不会出现该依赖包 spring-security-oauth2 -&gt; 被废弃，建议不使用，否则后期无法维护 spring-security-oauth2-autoconfigure -&gt; 自动配置，没有用处 #主要使用以下的依赖包 spring-boot-starter-oauth2-client -&gt; 最新 spring-boot-starter-oauth2-resource-server -&gt; 最新 spring-cloud-starter-oauth2 -&gt; 引用 spring-security-oauth2，但尚未标注被废弃 项目介绍 在接下来的章节中，将使用 微服务Gateway+Redis+Token+Nacos+Security+Oauth2。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0b4f5024f4411db8bb4b00ab7bd7fad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ad01b40b8a79e42f9e10218f174483b/" rel="bookmark">
			梯度收费算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		交电费按梯度收费，总用电
小于等于5度电，每度30元；
大于5度小于等于20度的，每度15元；
大于20度小于等于50度的，每度10元。
大于50度小于等于100度，每度9元；
大于100度小于等于500度，每度8元；
大于500度小于等于1000度，每度7元；
大于1000度小于等于2000度，每度6元；
大于2000度小于等于3000度，每度5元；
大于3000度小于等于4000度，每度4元；
大于4000度小于等于5000度，每度3元；
大于5000度小于等于6000度，每度2元；
大于 6000度 ，每度1元。
例如，某月总用电量为6度，则电费为5*30+1*15 = 165元。
算法实现：
根据题目把交费电量分为12个区间，用两个数组分别存储每个区间的度数及价格，算出每个区间应交费多少，每个区间的交费加起来即可。
例如第一个区间是5度，第二个区间是6度至20度，说明第二个区间的度数为15度。先看总电量是否大于第一个区间的度数5度，如果大于，则5度在第一个区间，按照第一个区间缴费，总电量减5，剩下的电量又看是否大于第二个区间的度数....
下面写了两个方法，第1个是递归方法，代码简单，也好理解，用到了两个额外数组；第2个非递归，代码多一点，用到了一个额外数组。
public class DegreesTest { // 区间度数数组 public static double[] sectionDegrees = new double[]{5, 15, 30, 50, 400, 500, 1000, 1000, 1000, 1000, 1000, 0}; // 区间价格数组 public static double[] sectionPrices = new double[]{30, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}; public static void main(String[] args) { //方法1 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ad01b40b8a79e42f9e10218f174483b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5bbe14f290a4be4977cbf5d7bfb67da/" rel="bookmark">
			【Scannet V2 三维数据集下载】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scannet V2三维数据下载 Scannet V2数据介绍：“ScanNet 是一个 RGB-D 视频数据集，包含 2 多次扫描中的 5 万次观看，并带有 1500D 摄像机姿势、表面重建和实例级语义分割进行注释。 为了收集这些数据，我们设计了一个易于使用且可扩展的RGB-D捕获系统，其中包括自动表面重建和众包语义注释。 我们表明，使用这些数据有助于在多个 3D 场景理解任务上实现最先进的性能，包括 3D 对象分类、语义体素标记和 CAD 模型检索。 更多信息可以在我们的论文: link中找到。”
更多关于Scannet数据的介绍可以查看这篇CSDN博客: scannet数据集简介和下载
因为我的目的是用Scannet V2的三维数据集来进行HAIS论文复现，所以这里我只复述一下我是如何下载该三维数据集的。Scannet数据按正常流程来说，是需要签订一份协议并且向该数据团队申请的，发完邮件之后等他们通过申请然后回复下载数据的python脚本。但是等待回复的时间有长有短，我着急复现实验，所以直接上网扒代码进行下载。
电脑配置： Ubuntu20.0
python2.7
这里需要注意，运行下载scannet数据的代码可以用python2.7也可以用python3.x。
注意事项： 因为我用的是python2.7，所以在运行时可能会出现一些问题。比如：
1.ERROR:SyntaxError: Non-ASCII character ‘\xe5’ in file
这是因为当使用中文输出或注释时运行脚本的时候，导致出现问题。因为python默认的编码文件是ASCII码，但是你的代码中使用中文或者非英语字符，第一种最最简单的方法就是去文件里把中文部分处理掉，如果不想动它，建议在每个源文件的基础上，使用文件顶部的特殊注释声明编码，使python源代码编码既可见又可更改。即在代码页的最顶端，第一行加入以下编码提示：
# coding: utf-8 #!/usr/bin/env python 或者
# -*- coding:UTF-8 -*- #!/usr/bin/env python 注意：coding: utf-8中，coding后面不能有空格，即#coding ：utf-8会报错。
在Ubuntu系统上#coding ：utf-8需要放在代码的第一行，而在Windows系统上，#coding ：utf-8好像不需要放在第一行，只要放在开头就行。
2.在代码运行时：
会出现Press any key to countinue ,or CTRL-C to exit，这个时候，如果是Windows系统的话不用管它，也不要按任何键盘上的按键，它自己就会跟着下载数据（不知道这是否只有我一个人是这样的情况，我仅仅是把我所遇到的问题陈述出来）。如果是在Ubuntu系统上，则需要键入任意数字，然后摁下回车键即可，如果直接摁下回车键或者其他的字符都会报错。
3.在download_scannetv2.py中，如果用python2.7需要更改几行代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5bbe14f290a4be4977cbf5d7bfb67da/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/132/">«</a>
	<span class="pagination__item pagination__item--current">133/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/134/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>