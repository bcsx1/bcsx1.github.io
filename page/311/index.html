<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af756efcf013f0ae5796ee06643a6e3/" rel="bookmark">
			实现自动滚动（且可以设置各种属性）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		`页面的自动滚动效果
页面的自动滚动效果，可由javascript来实现，
但是有一个html标签 - 可以实现多种滚动效果，无需js控制。
使用marquee标记不仅可以移动文字，也可以移动图片，表格等.
语法：&lt;marquee&gt;...&lt;/marquee&gt;； 说明：在标记之间添加要进行滚动的内容。
重要属性：
1.滚动方向direction（包括4个值：up、 down、 left和 right）
语法：&lt;marquee direction="滚动方向"&gt;...&lt;/marquee&gt;
2.滚动方式behavior（scroll:循环滚动，默认效果； slide:只滚动一次就停止； alternate:来回交替进行滚动）
语法：&lt;marquee behavior="滚动方式"&gt;...&lt;/marquee&gt;
3.滚动速度scrollamount（滚动速度是设置每次滚动时移动的长度，以像素为单位）
语法：&lt;marquee scrollamount="5"&gt;...&lt;/marquee&gt;
4.滚动延迟scrolldelay（设置滚动的时间间隔，单位是毫秒）
语法：&lt;marquee scrolldelay="100"&gt;...&lt;/marquee&gt;
5.滚动循环loop（默认值是-1，滚动会不断的循环下去）
语法：&lt;marquee loop="2"&gt;...&lt;/marquee&gt;
6.滚动范围width、height
7.滚动背景颜色bgcolor
8.空白空间hspace、vspace
代码示例
&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;div&gt;&lt;marquee direction="up" behavior="scroll" scrollamount="1" scrolldelay="0" loop="-1" width="1000" height="50" bgcolor="#0099FF" hspace="10" vspace="10"&gt; 确实好用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2552570defe752e922218d01ed40d81a/" rel="bookmark">
			springboot运行配置jsp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/qq_43470725/article/details/119750430
https://blog.csdn.net/qq_43470725/article/details/121969868
pom: &lt;!-- servlet依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- tomcat的支持--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; yml: #jsp支持 mvc: view: prefix: /WEB-INF/jsp/ suffix: .jsp #关闭默认模板引擎（thymeleaf）,才会支持jsp thymeleaf: cache: false enabled: false jsp： &lt;%@ page import="java.io.File" %&gt; &lt;%@ page import="org.apache.commons.fileupload.disk.DiskFileItemFactory" %&gt; &lt;%@ page import="org.apache.commons.fileupload.servlet.ServletFileUpload" %&gt; &lt;%@ page import="org.apache.commons.fileupload.FileItem" %&gt; &lt;%@ page import="java.text.SimpleDateFormat" %&gt; &lt;%@ page import="java.util.*" %&gt;&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2021/8/17 Time: 10:23 To change this template use File | Settings | File Templates.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2552570defe752e922218d01ed40d81a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c0272a26f740f9da8a0d08918a7fcfb/" rel="bookmark">
			Qt 编译mysql 依赖库提示“ error: unrecognized command line option ‘-Wdate-time’”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境centos7.9 Qt 5.12.4 ，编译mysql依赖库libqsqlmysql.so提示‘-Wdate-time’无法识别的命令行选项。原因GCC版本太低。
解决升级GCC版本
下载GCC 安装包Index of /software/gcc/releases ，选择一个高版本下载，并保存在/home/data目录下
tar -vxzf gcc-10.1.0.tar.gz
cd gcc-10.1.0/
./contrib/download_prerequisites
mkdir build
cd build
[root@localhost gcc-10.1.0]# ./contrib/download_prerequisites 2021-12-16 11:21:08 URL:http://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2 [2383840/2383840] -&gt; "./gmp-6.1.0.tar.bz2" [1] 2021-12-16 11:22:00 URL:http://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2 [1279284/1279284] -&gt; "./mpfr-3.1.4.tar.bz2" [1] 2021-12-16 11:22:24 URL:http://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz [669925/669925] -&gt; "./mpc-1.0.3.tar.gz" [1] 2021-12-16 11:23:54 URL:http://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2 [1658291/1658291] -&gt; "./isl-0.18.tar.bz2" [1] gmp-6.1.0.tar.bz2: 确定 mpfr-3.1.4.tar.bz2: 确定 mpc-1.0.3.tar.gz: 确定 isl-0.18.tar.bz2: 确定 All prerequisites downloaded successfully. ../configure --enable-checking=release --enable-languages=c,c++ --disable-multilib
make [这里非常慢]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c0272a26f740f9da8a0d08918a7fcfb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b231bcfbded4ae538460a1eb017923ac/" rel="bookmark">
			ifstream读文件操作（以特定符号作为分隔符）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ifstream读文件时，区分以“，”为分隔符的字符串 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;string&gt; using namespace std; int main() { string file_path= "D:\\###\\###\\mac.txt"; string mac_; ifstream ifs; ifs.open(file_path, ios::in); if(ifs.is_open()) { while(getline(ifs,mac_)) { // 输出每行总字符串 cout&lt;&lt;mac_&lt;&lt;endl; //记录逗号出现的位置 long pos= mac_.find(",",0); cout&lt;&lt;"逗号出现的位置："&lt;&lt;pos&lt;&lt;endl; // 记录字符串的总长度 int mac_size= mac_.size(); cout&lt;&lt;"mac_的总长度："&lt;&lt;mac_size&lt;&lt;endl; // 以逗号为分隔符 分别输出前后字符串 cout&lt;&lt; mac_.substr(0,pos)&lt;&lt;"------"&lt;&lt;mac_.substr(pos+1, mac_size-pos-1)&lt;&lt;endl; cout&lt;&lt;endl; } } system("pause"); return 0; } 特别注意：string.substr()的用法，第一个参数为 以0为基准的索引值，第二个参数为 从改值开始的后 n 个数字。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3300b4f148fdad80878d7a53e6bfef88/" rel="bookmark">
			配置ubuntu优先使用wifi上网，而不是直连
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当同时连接热点和接入网线的情况下，如果网线没网，那么可能导致无法上网。这个时候，把网线拔掉，发现连接的热点就可以上网了。但是我们可能同时需要用接入网线来访问内网资源，所以这时需要配置使用wifi作为作为网上冲浪的那个网卡，因此设定无线的ip地址段为默认路由，并删除之前的默认路由。
# ********** WifiGateway.sh ************ #!/bin/bash wifi=wlp0s20f3 _ip=`ip addr show wlp0s20f3 | head -3 | tail -1 | awk '{print $2}'` echo "Wifi IP:"$_ip _gw=`echo $_ip | awk -F . '{printf("%s.%s.%s.1",$1,$2,$3)}'` echo "Wifi gateway: "$_gw echo "Set the Wifi gateway as the default gw now" route delete default route add default gw $_gw echo "Set the Wifi gateway as the default gw end" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a248d960b8ebe061cabb9b0311a705c/" rel="bookmark">
			【linux】ssh 远程执行命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 转载并且补充：ssh 远程执行命令
SSH 是 Linux 下进行远程连接的基本工具，但是如果仅仅用它来登录那可是太浪费啦！SSH 命令可是完成远程操作的神器啊，借助它我们可以把很多的远程操作自动化掉！下面就对 SSH 的远程操作功能进行一个小小的总结。
2.远程执行命令 如果我们要查看一下某台主机的磁盘使用情况，是不是必须要登录到目标主机上才能执行 df 命令呢？当然不是的，我们可以使用 ssh 命令在远程的主机上执行 df 命令，然后直接把结果显示出来。整个过程就像是在本地执行了一条命令一样：
$ ssh nick@xxx.xxx.xxx.xxx "df -h" 那么如何一次执行多条命令呢？其实也很简单，使用分号把不同的命令隔起来就 OK 了：
$ ssh nick@xxx.xxx.xxx.xxx "pwd; cat hello.txt" 第一条命令返回的结果： /home/nick
这说明用这种方式执行命令时的当前目录就是登陆用户的家目录。
第二条命令返回 hello.txt 文件的内容。
注意，当命令多于一个时最好用引号括起来，否则在有的系统中除了第一个命令，其它都是在本地执行的。
2.1 执行需要交互的命令 有时候我们需要远程执行一些有交互操作的命令。
$ ssh nick@xxx.xxx.xxx.xxx "sudo ls /root" $ ssh nick@xxx.xxx.xxx.xxx "top" 这两条命令虽然提示的失败原因不同，但它们有一个共同点：都需要与用户交互(需要 TTY)。所以它们失败的原因也是相同的：
默认情况下，当你执行不带命令的 ssh 连接时，会为你分配一个 TTY。因为此时你应该是想要运行一个 shell 会话。
但是当你通过 ssh 在远程主机上执行命令时，并不会为这个远程会话分配 TTY。此时 ssh 会立即退出远程主机，所以需要交互的命令也随之结束。
好在我们可以通过 -t 参数显式的告诉 ssh，我们需要一个 TTY 远程 shell 进行交互！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a248d960b8ebe061cabb9b0311a705c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a47c0b1b65ae14b951904b14db0641/" rel="bookmark">
			adb从手机拷贝文件到电脑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上找的方法都不正确
正确的办法是：
1.adb shell
2.cd到指定路径
3.exit退出
4.adb pull 手机路径/要拷贝的文件名 电脑中要保存到的位置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a77fe07845ab4bba113f942d5ec11db/" rel="bookmark">
			个人记录——Maven: Idea bug依赖更新不成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天记一档离谱的事情,谈不上什么原理和方法论,就是单纯的随缘解决了一个bug.
项目结构如图:
B接口要用到A类,由于是两个不同的模块,自然在ly-item-service模块导入ly-common模块的依赖,更新依赖后正常来说就能使用了.但当时情况是下图标注的地方和maven依赖都爆红,即找不到.
尝试手动导包,idea也能一步步提示包名,类名,说明实际上是能找到的.
最后,我根据光标提示,进行了依赖的update index,然后重启idea,发现不爆红了,就这么神奇的解决了.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c73fb1989233d18276bc5c70c8c20e8/" rel="bookmark">
			项目管理基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目管理的知识体系 项目管理的知识体系大体分为项目管理五大过程组和十大知识领域。
十大知识领域 整体领域：整合管理
核心领域：范围管理、时间管理、成 本管理、质量管理
辅助领域：人力资源管理、沟通管理、干系人管理、风险管理，采购管理
管理项目时可以从十大领域角度分析项目，进行梳理整理出项目整体的情况，建立全局观。
五大过程组 项目管理活动分成了五大过程组：启动过程组、规划过程组、执行过程组、监控过程组 和收尾过程组
启动过程组：启动新项目时建立项目章程，明确干系人的期望，设定愿景目标和重要里程碑，确定责任分工和沟通机制等。规划过程组：把愿景目标转化为可落地的行动方案和工作路线，拆分到具体版本和工作项。 执行过程组：整合资源，推进项目落地，已完成规划中的工作项。监控过程组：定期对项目的进展、范围、质量等进行跟踪和监控，识别目前的进 度与计划之间的偏差，从而快速准确地采取办法进行纠正和调整。 收尾过程组：交付项目成果，组织团队的回顾复盘，归档所有文档。不管项目成功与 否，“趁热”复盘都是极为重要的一步。 十大知识领域与五大过程组合 识别项目中的四类干系人 从项目的权利和利益角度上，可将干系人识别为四类：高利益 - 高权力，高利益 - 低权力，低利益 - 高权力，低利益 - 低权力。
项目发起人就是 高利益-高权利 代表，需要从发起人找到一些问题的答案：
最初你发起这个项目的背景和初衷是什么？项目组的整体目标和愿景是什么？如何知道我们做到了？为了实现这个目标，我们有哪些资源短缺或限制因素？涉及哪些外部资源的管理？哪些是项目获得成功的关键资源？ 顼目组的決策流程是怎样的？需求如何通过审核？如何确认变更呢？你是如何考虑项目团队的组织结构的？团队组建多长时间了？各个角色的合作状况如何？在团队及组织结构上，是否有需要特别关注的状况？ 你通过什么样的渠道了解项目状态？你希望我以什么样的方式跟你保持信息同步？哪些风险和问题需要经过特别审批？你最看重项目的哪些要素(进度/质量/成本/范围）？在极端情 况下，这些要素如何排序？你希望我在承担项目管理工作后给项目及团队的哪些方面带来提升？ 想要低利益-高权利干系人的态度发生改变，需要弄清楚背后的原因，一定有干系人对现状的某种认知。只有真正地理解了对方的逻辑，才有可能进一步对其施加影响。
对于管理高利益-低权利的干系人，如项目成员，就是要做到项目事项的随时告知，及时通报项目的进展和困难。
规划：排除计划中延期地雷 项目管理中 计划 是用来多角色系统协调工作的重要工具，本质上是对项目的集体聚焦，减少计划中存在的问题。
如何做一个好的计划 够具体：有时间节点，明确的依据和来源。 WBS 工作分解法：将工作中可交付的部分分解成小而可执行的具体步骤，描述项目工作之间的相互联系。提供具体的任务排期 识别出关键环节 指定具体任务列表时，需要标明具体依赖的资源和步骤。找到依赖画出决定项目工期的关键路径。（任何关联路径上的延迟都会影响上线计划） 后期对关键路径进行持续关注，把控关键路径上的风险。 定义计划中完成的标准。 以始为终，越早定义完成标准，就越容易完成。常见的关键阶段标准：需求/设计确认 ，功能完成/提测，上线归回完成 与团队形成共识。 做好的计划要实时同步，可以通过邮件或者通讯工具类，不单是口头形式传达。在达成共识前，还可以进一步进行讨论和调整，保证多角色间的信息对等。 变化及时反馈 计划赶不上变化，每一次调整都要确保项目中每个人都清楚当前计划是什么，要如何调整。对于变化要跟项目各干系人进行讨论，明确变动造成的影响，完善决策。 执行：打造品质，要从头开始“闭环” 在项目开发过程中，为了合理试错，减少不必要的返工情况，需要有效的闭环反馈系统来支撑。
方案评审 需求评审，交互评审，技术评审，测试评审都是基本的闭环验证方式。
不是简单的开会，而是需要多个角色配合决策。
负责人（Owner）：负责给出方案，组织各方讨论并推进做出最终的决定；批准者 （Approver)：最终批准者； 审核者（Reviewer）：负责人和批准者挑选出的审核人。审核者有责任对文档进行讨论 分析，并提出反馈意见，负责人必须重视并给予回复；参与者 （Participant）：其他提供意见的人。参与者会收到文档的相关信息，可以对相关问题做出反馈。 Bug 大扫除 在一个专门的时间段，所有参与项目的人集中精力给项目找 Bug，除了应用于测试阶段，还可以用于产品需求验证阶段，给需求稿找问题。
冒烟测试评审 什么是冒烟测试：基本关键功能的测试。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c73fb1989233d18276bc5c70c8c20e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e48c8168eff4dbd55e6314ef623869f8/" rel="bookmark">
			js：如何获取select选中的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我想获取select选中的value，或者text，或者……
比如这个：
&lt;select id="select"&gt;
&lt;option value="A" url="http://www.baidu.com"&gt;第一个option&lt;/option&gt;
&lt;option value="B" url="http://www.qq.com"&gt;第二个option&lt;/option&gt;
&lt;/select&gt;
一：JavaScript原生的方法
1:拿到select对象： `var myselect=document.getElementById("select");
2：拿到选中项的索引：var index=myselect.selectedIndex ; // selectedIndex代表的是你所选中项的index
3:拿到选中项options的value： myselect.options[index].value;
4:拿到选中项options的text： myselect.options[index].text;
5:拿到选中项的其他值，比如这里的url： myselect.options[index].getAttribute('url');
二：jQuery方法
1:var options=$(“#select option:selected”); //获取选中的项
2:alert(options.val()); //拿到选中项的值
3:alert(options.text()); //拿到选中项的文本
4:alert(options.attr('url')); //拿到选中项的url值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7fc389e8940b03c2d916825b273482b/" rel="bookmark">
			如何使用 iTMSTransporter 命令行上传 ipa 到 App Store
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装 Transporter 命令 方法1：（XCode 11 及以上）
直接在【终端】执行安装命令：
xcrun iTMSTransporter 安装好以后，iTMSTransporter 的文件位置在：
/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework/itms/bin/iTMSTransporter (藏得真深 =_=b)
方法2：（推荐）
从 Mac App Store 下载 Transporter 应用。下载地址：
https://apps.apple.com/cn/app/transporter/id1450874784?mt=12
安装好以后，则可以在 app 包里找到 iTMSTransporter 命令：
/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter 二、准备“App 专用密码” （后面要用到） 1. 进入苹果官网 http://www.apple.com/cn/
2. 拉到页底，选择账户-管理你的Apple ID
3. 登录（如果开启双重验证，在点击登录后需要输入一个6位的密码，可以在使用相同密码已登录的其他设备上找到。）
4. 在“登录和安全”栏目里找到一个叫“APP专用密码”的条目，点击进去按系统系统提示操作生成专用密码即可。
5. 最后生成的专用密码赶紧保存下来，关掉这个弹窗就看不到了（只能重新生成）。
三、使用 iTMSTransporter 命令上传 ipa 直接上命令：
/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter -m upload -assetFile &lt;ipa_path&gt; -u &lt;user_name&gt; -p &lt;private_password&gt; -v informational 命令详解：
/Applications/Transporter.app/Contents/itms/bin/iTMSTransporter：命令所在的位置。根据第一部分中的描述找到自己电脑中安装的 iTMSTransporter 命令。 设置好 TRANSPORTER_HOME 环境变量后，可以不用带上命令路径，直接使用命令。
若要添加 TRANSPORTER_HOME 环境变量，请在您的 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7fc389e8940b03c2d916825b273482b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29f032f648d54507028c6f7b22235fa/" rel="bookmark">
			Vue移动端项目中px转rem的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）使用lib-flexible动态设置REM基准值(html标签的字体大小) 安装依赖 yarn add amfe-flexible // 或者 npm i amfe-flexible 然后在main.js中引入加载执行该模块 import 'amfe-flexible' 最后测试：在浏览器中切换不同设备尺寸，观察html标签font-size的变化。成功后，以后的单位直接写px即可。 2）使用postcss-pxtorem将px转为rem。 安装依赖 yarn add postcss-pxtorem -D // 或者 npm i postcss-pxtorem -D 然后在项目根目录中创建postcss.config.js文件 // postcss.config.js module.exports = { plugins: { 'postcss-pxtorem': { rootValue: 37.5, // 此设计稿尺寸为375px propList: ['*'], }, }, }; 如果设计稿的尺寸不是 375，而是 750 或其他大小，可以将 rootValue 配置调整为: // postcss.config.js module.exports = { plugins: { // postcss-pxtorem 插件的版本需要 &gt;= 5.0.0 'postcss-pxtorem': { rootValue({ file }) { return file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d29f032f648d54507028c6f7b22235fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c1c7caa4eb45721510c7a9f9c089f4/" rel="bookmark">
			hadoop3.X学习笔记进阶篇-HDFS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HDFS概述 1.1HDFS优缺点1.2HDFS组成架构 1.3HDFS文件块大小（面试重点） HDFS的Shell操作（开发重点） 1.1 命令大全1.2 命令实操 HDFS的读写流程（面试重点）NameNode和SecondaryNameNodeCheckPoint时间设置DataNode HDFS优缺点HDFS概述 1.1HDFS优缺点 HDFS定义:
HDFS（Hadoop Distributed File System），它是一个文件系统，用于存储文件，通过目录树来定位文件；其次，它是分布式的，由很多服务器联合起来实现其功能，集群中的服务器有各自的角色。
HDFS的使用场景：适合一次写入，多次读出的场景。一个文件经过创建、写入和关闭之后就不需要改变。
1.1优点
1.2 缺点
1.2HDFS组成架构 client: 对集群增删改查的操作，例如：http://hadoop102:9870/explorer.html#/input
1.3HDFS文件块大小（面试重点） HDFS的Shell操作（开发重点) 1.1 命令大全 [@hadoop102 hadoop-3.1.3]$ bin/hadoop fs [-appendToFile &lt;localsrc&gt; ... &lt;dst&gt;] [-cat [-ignoreCrc] &lt;src&gt; ...] [-chgrp [-R] GROUP PATH...] [-chmod [-R] &lt;MODE[,MODE]... | OCTALMODE&gt; PATH...] [-chown [-R] [OWNER][:[GROUP]] PATH...] [-copyFromLocal [-f] [-p] &lt;localsrc&gt; ... &lt;dst&gt;] [-copyToLocal [-p] [-ignoreCrc] [-crc] &lt;src&gt; ... &lt;localdst&gt;] [-count [-q] &lt;path&gt; ...] [-cp [-f] [-p] &lt;src&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01c1c7caa4eb45721510c7a9f9c089f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42666e4ddcd94798f904845de2959fac/" rel="bookmark">
			数据结构 实验二 单链表的基本操作 ① 逆序建立单链表② 遍历单链表(输出单链表每个元素的值)③ 在单链表第5个元素前插入一个值为999的元素.④ 删除单链表第5个元素.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验二 单链表的基本操作（必做，设计性实验） 实验目的 了解线性表的链式存储结构和顺序存取特性，熟练掌握线性表的链式存储结构的C语言描述方法，熟练掌握动态链表的基本操作查找、插入、定位等，能在实际应用中选择适当的链表结构。掌握用链表表示特定形式的数据的方法，并能编写出有关运算的算法。
实验内容 已知线性表中的元素以值递增有序排列，并以单链表作存储结构。试写一高效算法，删除表中所有值大于mink且小于maxk的元素（若表中存在这样的元素）同时释放被删结点空间，并分析你的算法的时间复杂度（注意：mink和maxk是给定的两个参变量，它们的值可以和表中的元素相同，也可以不同）。完成单链表上的如下操作： ① 逆序建立单链表
② 遍历单链表(输出单链表每个元素的值)
③ 在单链表第5个元素前插入一个值为999的元素.
④ 删除单链表第5个元素.
问题描述 （说明你选做的题目及要求）
1、已知线性表中的元素以值递增有序排列，并以单链表作存储结构。试写一高效算法，删除表中所有值大于mink且小于maxk的元素（若表中存在这样的元素）同时释放被删结点空间，并分析你的算法的时间复杂度（注意：mink和maxk是给定的两个参变量，它们的值可以和表中的元素相同，也可以不同）。
2、完成单链表上的如下操作：
① 逆序建立单链表
② 遍历单链表(输出单链表每个元素的值)
③ 在单链表第5个元素前插入一个值为999的元素.
④ 删除单链表第5个元素.
数据结构定义 （说明你算法中用到的数据结构、数据类型的定义）
数据结构：线性表的链式存储
在单链表中，假定每个结点类型用Linklist表示，它包括存储元素的数据域，用data表示，其类型用通用类型标识符ElemType 表示，还包括存储后续元素位置的指针域 用next表示。
LinkList类型的定义如下:
Typedef struct LNode
{ ElemType data;
Struct LNode *next;
}LinkList;
算法思想及算法设计 （先文字说明算法的思想，然后给出类C语言算法）
1、
尾插法建表：
从一个空表开始，读取字符数组a中的字符，生成新结点，将读取的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头上，直到结束为止
void CreateList(LinkList &amp;L, int n) { L = new LNode; L-&gt;next = NULL; LNode *r; r = L; for (int i = 0; i &lt; n; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42666e4ddcd94798f904845de2959fac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb5abef63555f197e2f3bcb85ce37aa/" rel="bookmark">
			机器学习相关 解答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解答 一、机器学习相关 1、基本概念 1-1 简述解决一个机器学习问题时，你的流程是怎样的？ 确定问题：有监督问题还是无监督问题？回归问题还是分类问题？
数据收集与处理
特征工程：包括特征构建、特征选择、特征组合等
模型训练、调参、评估：包括模型的选择，选择最优的参数
模型部署：模型在线上运行的效果直接决定模型的成败
1-2 损失函数是什么，如何定义合理的损失函数？ 机器 学习模型关于单个样本的预测值与真实值的差称为损失。用于计算损失的函数称为损失函数。损失函数是​和​的非负实值函数函数。1-3 回归模型和分类模型常用损失函数有哪些？各有什么优缺点 回归模型常用的损失函数有： 0-1损失函数：
绝对损失函数：异常点多的情况下鲁棒性好；但不方便求导
平方损失函数：求导方便，能够用梯度下降法优化；对异常值敏感
对数损失函数/对数似然损失函数：
Huber 损失函数：结合了绝对损失函数和平方损失函数的优点；缺点是需要调整超参数 ​
Log-Cosh 损失函数：具有Huber的所有优点，同时二阶处处可微（牛顿法要求二阶可微）
1-4 什么是结构误差和经验误差？训练模型的时候如何判断已经达到最优？ 经验风险（经验损失）：模型 ​关于训练数据集的平均损失
结构风险：是在经验风险上加上表示模型复杂度的正则化项
经验风险最小化的策略认为，经验风险最小的模型是最优的模型。
结构风险最小化是为了防止过拟合而提出的，结构风险最小化等价于正则化。结构风险最小化的策略认为结构风险最小的模型是最优的模型。
1-5 模型的“泛化”能力是指？如何提升模型泛化能力？ 通常将模型对未知数据的预测能力称为泛化能力（generalization ability）。现实中采用最多的方法是通过测试误差来评价学习方法的泛化能力。
1-6 如何选择合适的模型评估指标？AUC、精准度、召回率、F1值都是什么？如何计算？有什么优缺点？ TP：将正类预测为正类数
FN：将正类预测为负类数
FP：将负类预测为正类数
TN：将负类预测为负类数
分类任务指标​
Accuracy（准确率）：分类正确的样本占总样本个数的比例
缺点：不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。比如，当负样本占99%时，分类器把所有样本都预测为负样本也可以获得99%的准确率。
解决：可以使用每个类别下的样本准确率的算术平均（平均准确率）作为模型评估的指标。
Precision（精确率）：分类正确的正样本个数占分类器判定为正样本的样本个数的比例
Recall（召回率）：分类正确的正样本数占真正的正样本个数的比例
F1-score：precision和recall的调和平均值；当精确率和召回率都高时，F1值也会高
在排序问题中，通常没有一个确定的阈值把得到的结果直接判定为正样本或负样本，而是采用Top N返回结果的Precision和Recall值来衡量排序模型的性能。即认为模型返回的Top N结果就是模型判定的正样本，计算前N个位置的Precision@N和Recall@N。为了综合评估一个排序模型的好坏，不仅要看模型在不同Top N下的Precision@N和Recall@N，而且最好画出模型的P-R曲线。P-R曲线的横轴是Recall，纵轴是Precision。
ROC：横坐标为假阳性率（False Positive Rate，FPR）；纵坐标为真阳性率（True Positive Rate，TPR）
其中P是真实的正样本的数量，N是真实的负样本的数量，TP是P个正样本中被分类器预测为正样本的个数，FP是N个负样本中被预测为正样本的个数。
【如何绘制ROC曲线】通过不断移动分类器的“截断点”来生成曲线上的一组关键点。在二分类问题中，模型输出一般是预测样本为正例的概率，在输出最终的正例负例之前，我们需要制定一个阈值。大于该阈值的样本判定为正例，小于该阈值的样本判定为负例。通过动态调整截断点，绘制每个截断点对应位置，再连接所有点得到最终的ROC曲线。
AUC：ROC曲线下的面积大小。计算AUC值只要沿着ROC横轴做积分就可以。AUC取值一般在0.5~1之间。AUC越大，分类性能越好。AUC表示预测的正例排在负例前面的概率。
指标想表达的含义，简单来说其实就是随机抽出一对样本（一个正样本，一个负样本），然后用训练得到的分类器来对这两个样本进行预测，预测得到正样本的概率大于负样本概率的概率
AUC为0.5表明对正例和负例没有区分能力，对于不论真实类别是1还是0，分类器预测为1的概率是相等的。
我们希望分类器达到的效果：对于真实类别为1的样本，分类器预测为1的概率（TPR）要大于真实类别为0而预测类别为1的概率（FPR），即y&gt;x
AUC的计算方法同时考虑了分类器对于正例和负例的分类能力，在样本不平衡的情况下，依然能够对分类器作出合理的评价。
思路：1.首先对预测值进行排序，排序的方式用了python自带的函数sorted，详见注释。
2.对所有样本按照预测值从小到大标记rank，rank其实就是index+1，index是排序后的sorted_pred数组中的索引
3.将所有正样本的rank相加，遇到预测值相等的情况，不管样本的正负性，对rank要取平均值再相加
4.将rank相加的和减去正样本排在正样本之后的情况，再除以总的组合数，得到auc
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcb5abef63555f197e2f3bcb85ce37aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbf9f66bc0a7963fc12b92ceaebd35c/" rel="bookmark">
			C语言练习，利用求阶乘函数Fact()，编程计算并输出从1到n之间所有数的阶乘值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 利用求阶乘函数Fact()，编程计算并输出从1到n之间所有数的阶乘值。 **输入格式要求："%u" 提示信息："Input n(n&gt;0):" **输出格式要求："%d! = %lu\n" 程序运行示例如下： Input n(n&gt;0):10 1! = 1 2! = 2 3! = 6 4! = 24 5! = 120 6! = 720 7! = 5040 8! = 40320 9! = 362880 10! = 3628800 代码如下：
#include&lt;stdio.h&gt; void Fact(int n) { int i; long sum=1; for(i=1;i&lt;=n;i++) { sum*=i; printf("%d! = %lu\n",i,sum); } } void Fact(int n); int main() { int n; printf("Input n(n&gt;0):"); scanf("%u",&amp;n); Fact (n); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7b1470e18b00860b87a7a4fc6ab7a5f/" rel="bookmark">
			L2-012 关于堆的判断 (25 分)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目链接
思路 小根堆的建立+字符串处理，真的好爱考字符串呀。。。
代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int N = 1e3+9; int a[N]; unordered_map&lt;int,int&gt; pos; //堆化 void build(int n){ int t=n; while(t/2&gt;=1 &amp;&amp; a[t/2]&gt;a[t]){ swap(a[t/2],a[t]); t/=2; } } int main(){ int n,m; scanf("%d %d",&amp;n,&amp;m); for(int i=1; i&lt;=n; i++){ scanf("%d",a+i); //在堆中插入 build(i); } for(int i=1; i&lt;=n; i++) pos[a[i]]=i; while(m--){ string s; int x=0,y=0; scanf("%d",&amp;x); while(cin&gt;&gt;s) { if(s=="and") { scanf("%d",&amp;y); } if(s=="root"){ if(pos[x]==1) puts("T"); else puts("F"); break; } else if(s=="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7b1470e18b00860b87a7a4fc6ab7a5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7f1f419de4542720e6d14a7d9b1a4d1/" rel="bookmark">
			Android 最新状态栏处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 中状态栏的处理无非两种，一种是显示隐藏状态栏，另外一种是状态栏字体颜色的修改，之前的写法都已经废弃了，来看看最新的版本中应该如何处理吧。
显示隐藏状态栏 先来看下之前的写法吧：
/** * 设置透明状态栏 */ fun Activity.transparentStatusBars() { val option = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN val vis = window.decorView.systemUiVisibility window.decorView.systemUiVisibility = option or vis window.statusBarColor = Color.TRANSPARENT } 这样看着是没有什么问题，但是。。。来看下代码的截图吧：
发现了没有，咱们一直使用的方法其实都废弃了。。。点击去看下描述：
@deprecated SystemUiVisibility flags are deprecated. Use {@link WindowInsetsController} 可以看到官方让使用 WindowInsetsController 来替换之前的写法，其实 WindowInsetsController 是一个接口，可以通过 ViewCompat.getWindowInsetsController 来进行实例化，来看下如何使用吧：
/** * 设置透明状态栏 */ fun Activity.transparentStatusBar() { val controller = ViewCompat.getWindowInsetsController(window.decorView) // 隐藏状态栏 controller?.hide(statusBars()) // 设置状态栏颜色为透明 window.statusBarColor = Color.TRANSPARENT } 状态栏字体颜色修改 同上面一样，先来看下之前的代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7f1f419de4542720e6d14a7d9b1a4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdde77ad9bc0f52011d8f965638666dc/" rel="bookmark">
			HTTP协议的请求头 响应头 响应体 区别与作用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常，Web服务器一直使用指定端口（默认为80端口）监听客户端的请求。请求由客户端发起，创建一个到服务器指定端口的TCP连接。一旦收到请求，服务器会向客户端返回一个状态，比如“HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其他信息，这就是服务器端的响应。
常见的请求头 1、 GET或POST：请求类型，后接请求资源、协议和版本
2、 Host：主机和端口
3、 Connection：是否使用持续连接
4、 User-Agent：客户端浏览器的名称
5、 Accept：浏览器可接受的MIME类型
6、 Accept-Encoding：浏览器知道如何解码的数据编码类型
7、 Accept-Language：浏览器指定的语言
8、 Accept-Charset：浏览器支持的字符编码
9、 Cookie：保存的Cookie对象
响应状态 响应信息的第一行就是响应状态，内容依次是当前HTTP版本号，三位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。状态代码的第一个数字代表当前响应的类型，xx表示两位数字。
a、 1xx消息：请求已被服务器接收，继续处理
b、 2xx成功：请求已成功被服务器接收、理解、并接受
c、 3xx重定向：需要后续操作才能完成这一请求
d、 4xx请求错误：请求含有词法错误或者无法被执行
e、 5xx服务器错误：服务器在处理某个正确请求时发生错误
响应头 响应头用于指示客户端如何处理响应体，告诉浏览器响应的类型、字符编码和字节大小等信息。
1、 Allow：服务器支持哪些请求方法（如GET、POST等）
2、 Content-Encoding：文档的编码（Encode）类型。只有在解码之后才可以得到Content-Type头指定的内容类型
3、 Content-Length：内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据
4、 Content-Type：表示后面的文档属于什么MIME类型
5、 Date：当前的时间
6、 Expires：文档过期时间
7、 Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计
8、 Server：服务器名称
9、 Set-Cookie：设置与页面关联的Cookie
10、 WWW-Authenticate：客户应该在Authorization头中提供的授权信息类型
响应体 响应头之后紧跟着一个空行，然后接响应体。响应体就是Web服务器发送到客户端的实际内容。除网页外，响应体还可以是诸如Word、Excel或PDF等其他类型的文档，具体是哪种文档类型由Content-Type指定的MIME类型决定。
参考博客：https://www.cnblogs.com/lonelyshy/p/13651159.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fbbf6a97746ab567ee8664da3c0792d/" rel="bookmark">
			经典运放电路分析—虚短虚断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提起运放电路，很多人很头疼，但是基本运放电路又是模拟电路的学习重点。如果没有正确的角度切入，理解起来会有些吃力。一般的教材和课程先给电路来 个定性，比如这是一个同向放大器，然后去推导它的输出与输入的关系，然后得出Vo=(1+Rf)Vi，那是一个反向放大器，然后得出Vo=-Rf*Vi。诸如此类，虽记住了公式，但若将电路稍微改变，便理解困难。此文将从“虚短”“虚断”角度理解基本运算电路。
由于运放的电压放大倍数很大，一般通用型运算放大器的开环电压放大倍数都在80 dB以上。而运放的输出电压是有限的，一般在 10 V～14 V。因此运放的差模输入电压不足1 mV，两输入端近似等电位，相当于 “短路”。开环电压放大倍数越大，两输入端的电位越接近相等。“虚短”是指在分析运算放大器处于线性状态时，可把两输入端视为等电位，这一特性称为虚假短路，简称虚短。当然两输入端不是真正短路。
由于运放的差模输入电阻很大，一般通用型运算放大器的输入电阻都在1MΩ以上。因此流入运放输入端的电流往往不足1uA，远小于输入端外电路的电流。故 通常可把运放的两输入端视为开路，且输入电阻越大，两输入端越接近开路。“虚断”是指在分析运放处于线性状态时，可以把两输入端视为等效开路，这一特性称为虚假开路，简称虚断。当然两输入端不是真正断路。
下面将从这个维度来分析常用的比例、加减、积分、微分等基本运算电路。
1、反向放大器
图1 运放的同向端接地=0V，反向端和同向端虚短，所以也是0V，反向输入端输入电阻很高，虚断，几乎没有电流注入和流出，那么R1和R2相当于是串联的，流过一个串联电路中的每一只组件的电流是相同的，即流过R1的电流和流过R2的电流是相同的。
流过R1的电流 ① I1 = (Vi - V-)/R1
流过R2的电流 ② I2 = (V- - Vout)/R2
③ V- = V+ = 0
④ I1 = I2
求解上面的初中代数方程得Vout = (-R2/R1)*Vi
这就是传说中的反向放大器的输入输出关系式了。
2、同相放大器
图2 Vi与V-虚短，则 ① Vi = V-
因为虚断，反向输入端没有电流输入输出，通过R1和R2 的电流相等，设此电流为I，由欧姆定律得： ② I = Vout/(R1+R2)
Vi等于R2上的分压，即： ③ Vi = I*R2
由①②③式得Vout=Vi*(R1+R2)/R2
这就是传说中的同向放大器的公式了。
3、加法器1
图3 由虚短知：① V- = V+ = 0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fbbf6a97746ab567ee8664da3c0792d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c784bb1cda6b2552ab380ad94db1ecc/" rel="bookmark">
			ArcGIS Enterprise10.8.1部署在Linux环境下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 准备工作 1.1 远程到Linux服务器 Linux一般作为服务器使用，而服务器一般放在机房，你不可能在机房操作你的Linux服务器，这时我们就需要远程登录到Linux服务器来管理维护系统。
Linux系统中是通过ssh服务实现的远程登录功能，默认ssh服务端口号为 22。
Window系统上Linux远程登录客户端有SecureCRT, Putty, SSH Secure Shell等，这里我用的是putty。
安装好之后，输入服务器的ip和账户密码即可连接上。
连接之后显示界面如下，在这个界面中我们就可以输入各种Linux命令了：
1.2 拷贝并解压安装介质 1.2.1 拷贝 首先，我们需要将放置在windows系统下的安装文件拷贝到Linux系统下。这里我用的是一款绿色免安装的WinSCP软件，可以可视化的在windows和Linux之间上传下载文件。
为了保险起见，上传完后我把文件夹改成了全英文，以保证全英文路径，如下/root/。
1.2.2 解压 接下来我们就可以使用以下命令对安装文件进行解压了，依次将所有文件和安装包都解压完成。如：
$ tar -zxvf ArcGIS_Server_Linux_1081_175289.tar.gz
1.3 环境说明 系统版本：CentOS 7.6.1810
软件版本：ArcGIS 10.8.1。
查看系统版本命令：cat /etc/redhat-release
本次采用1台机器的安装方式，即将Portal、Server、ArcGIS Web Adaptor、ArcGIS Data Store的基础组件都装在同一台机器上。
1.4 环境准备 1.4.1 关闭防火墙（可选） 停止防火墙：
[root@localhost home]# systemctl stop firewalld.service
禁用防火墙的开机启动：
[root@localhost home]# systemctl disable firewalld.service
查看防火墙状态：
[root@localhost home]# systemctl status firewalld.service
以下提示说明防火墙已经关闭:
Tips：不关闭防火墙时，可选择放行端口。单机环境下部署ArcGIS Enterprise时，可考虑仅开启：
80和443，确保外部客户端可通过Web Adaptor访问到Portal for ArcGIS或ArcGIS for Server服务页面；当Web Adaptor层未启用ArcGIS for Server的管理功能时，则需开启6080和6443端口，确保外部客户端上的ArcMap向此环境下的ArcGIS for Server发布服务。关于ArcGIS Enterprise更多的端口信息，请参考下面的链接。 ArcGIS Server所用端口号：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c784bb1cda6b2552ab380ad94db1ecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33848577e3b7902b928c82521c08672a/" rel="bookmark">
			数据仓库基础1-维度模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
这个系列将从小白视角讲述构建数据仓库过程所需的知识和问题，主要受众是数据中台产品、数据开发、数据分析人员。
引入 在大学就听说过数据仓库，但是当时被书的厚度劝退。后来工作中要做数据仓库，这次不得不咬牙重新翻开那些经典大头书。
一开始，我想赶紧落地，快速过了一遍概念性的东西，业务过程、粒度、维度、事实、度量等等。做到中途发现，各种基础抽象概念没搞清，竞品的某些功能我都看不懂。
正所谓欲速则不达，这些底层的知识，是数据类不变的产品的内核，搞懂了这些，才能跑得快跑得稳跑得远。
01 什么是模型，什么是建模 什么是模型？作为数据行业从业者，如果你从来没有思考过这个问题，你一定要看下去。
先看一个例子：
2021年 3 月 6 日，小明到楼下【行家】便利店买吃的，来来回回逛了几圈，虽然很饿，但又想减肥，最终拿了 1 个【柯德吉】人造肉汉堡。
准备付账的时候，收银员跟他说，最近搞活动，加 4 块可以选一瓶原价 8 块的【卡石】酸奶。小明觉得很划算，于是去拿了酸奶，一共付了 12
块。
上面的这段文字，就是模型。
作为计算机专业的学生，第一次看到别人给我解释这个模型的时候，我第一反应是What？这不就是一段文字嘛？都没数据库，都不是表单，这能算模型？
别急，先看看百度百科给出的模型定义。
模型，是指通过主观意识借助实体或者虚拟表现构成客观阐述形态结构的一种表达目的的物件（物件并不等于物体，不局限于实体与虚拟）
简单来说，模型是映射 “事实” 的东西，构建这个东西的动作就叫做建模。
其实，如果我们学了数据库，且没认真读教科书，很容易狭隘地只从数据库、数据结构的层面去理解模型。
上述的例子，是一种“文字模型”。而且，这个模型还可以补充更多细节，比如，采用什么方式付款、支付了多少钱。
为了表达更加简洁，我们可以省略更多的信息，只记录关键信息：
“ 2021年 3 月 6 日，小明买了，一个 柯德吉 牌人造肉汉堡，一瓶 卡石 牌酸奶（共计 ￥12）”。
如果用 Excel，我们可以更加简洁（节省空间你懂的）：
02 范式模型，为了更好地记录和更新 计算机的出现，也诞生了新的语言，我们也顺理成章地开始用新语言去建模。
这里，我省去长篇的对关系模型、范式模型的介绍，直接跳到应用场景，假设这个便利店用了现成的 ERP、CRM 系统，这些系统设计好了模型，数据会填充成如下的样子：
1）订单表
2）订单详情表
3）商品详情表
数据量不大，分析人员写 SQL 直接对范式模型进行查询，算账分析无所不能，小几十万数据，速度完全 OK。
03 维度模型，为分析而生 范式模型很好地解决了快速记录和节约存储空间。
但事物都有两面性，当数据量大的时候，从范式模型中查询取数，就比较慢了。但数据量一大，就顶不住了。
人类社会，但凡出现问题，总会天降猛士。Innon 和 Kimball 等人提出来新方案：为数据分析设计一套新模型。
范式模型主要解决数据的插入和更新，维护一致性等问题，维度模型则解决大数据场景分析的问题，这两者也就是所谓的 OLTP 和 OLAP 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33848577e3b7902b928c82521c08672a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1032148d169b47b1ddd39f9d40c30776/" rel="bookmark">
			df.dropna() 过滤数据中的缺失数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DataFrame.dropna（axis = 0，how = 'any'，thresh = None，subset = None，inplace = False） 参数： axis：{0 or ‘index’, 1 or ‘columns’}, default 0，确定是否删除包含缺失值的行或列，在1.0.0版中进行了更改：将元组或列表传递到多个轴上。只允许一个轴。
how：{‘any’, ‘all’}, default ‘any’，当我们有至少一个NA或全部NA时，确定是否从DataFrame中删除行或列，'any'：如果存在任何NA值，则删除该行或列，'all'：如果所有值均为NA，则删除该行或列。
thresh：int, optional，需要许多非NA值。
subset：array-like, optional，要考虑的其他轴上的标签，例如，如果要删除行，这些标签将是要包括的列的列表。
inplace：bool, 默认为False。
官网案例 代码：
df = pd.DataFrame({"name": ['Alfred', 'Batman', 'Catwoman'], "toy": [np.nan, 'Batmobile', 'Bullwhip'], "born": [pd.NaT, pd.Timestamp("1940-04-25"), pd.NaT]}) df 输出： name toy born 0 Alfred NaN NaT 1 Batman Batmobile 1940-04-25 2 Catwoman Bullwhip NaT 过滤掉有缺失数据 代码：
df.dropna() 输出：
name toy born 1 Batman Batmobile 1940-04-25 但此时df的值是，没有更改，因为inplace=False：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1032148d169b47b1ddd39f9d40c30776/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e06ca3ee6a30c85d8af0797cec6b72c/" rel="bookmark">
			ls列出最近修改文件,将前若干个拷贝到目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 命令如下
acat@acat-xx:下载$ ls -lrt | sed "s:^:`pwd`/ :" | tail -20 | awk -F ' ' '{print $1$NF}' 其中，ls -lrt用于以最近修改的文件的顺序显示文件，sed用于输出绝对路径，tail用于取最后面的若干个结果，这里取20，awk用于输出制定的列。这里将$1和$NF合并在一起输出，其中$1表示文件的父目录绝对路径，$NF表示文件名，合在一起就是文件的路径。
2. 执行结果
acat@acat-xx:下载$ ls -lrt | sed "s:^:`pwd`/ :" | tail -20 | awk -F ' ' '{print $1$NF}' /home/acat/下载/ashe.2.16.zip /home/acat/下载/twentysixteen.2.5.zip /home/acat/下载/storefront.3.9.1.zip /home/acat/下载/twentyfifteen.3.0.zip /home/acat/下载/botiga.1.0.8.zip /home/acat/下载/blank-canvas.1.2.9.zip /home/acat/下载/twentyfourteen.3.2.zip /home/acat/下载/colormag.2.1.0.zip /home/acat/下载/customify.0.3.7.zip /home/acat/下载/twentytwelve.3.5.zip /home/acat/下载/skt-minimal.1.0.zip /home/acat/下载/signify-dark.2.0.zip /home/acat/下载/scapeshot.1.0.8.zip /home/acat/下载/chic-lite.1.0.7.zip /home/acat/下载/bard.1.97.zip /home/acat/下载/own-store.1.0.5.zip /home/acat/下载/virtue.3.4.5.zip /home/acat/下载/vilva.1.1.5.zip /home/acat/下载/zoologist.1.0.20.zip /home/acat/下载/cenote.1.3.9.zip 3. 对这些文件执行拷贝命令
acat@acat-xx:下载$ ls -lrt | sed "s:^:`pwd`/ :" | tail -20 | awk -F ' ' '{print $1$NF}' | cp $(awk '{print $1}') '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e06ca3ee6a30c85d8af0797cec6b72c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9ffd92cfd34f8f8b07cd15282061c6f/" rel="bookmark">
			Python-正则表达式的 . \d \. &#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源代码如下：
import re print(re.search(r'JingJing', 'I love JingJing ~~~.')) print(re.search(r'.', 'I love JingJing ~~~.')) print(re.search(r'JingJin.', 'I love JingJing ~~~.')) print(re.search(r'\.', 'I love JingJing ~5~2~1.')) print(re.search(r'\d', 'I love JingJing ~5~2~1.')) print(re.search(r'.\d+', 'I love JingJing ~5~2~1.')) print(re.search(r'(.\d)+', 'I love JingJing ~5~2~1.')) 运行结果如下：
&lt;re.Match object; span=(7, 15), match='JingJing'&gt;
&lt;re.Match object; span=(0, 1), match='I'&gt;
&lt;re.Match object; span=(7, 15), match='JingJing'&gt;
&lt;re.Match object; span=(22, 23), match='.'&gt;
&lt;re.Match object; span=(17, 18), match='5'&gt;
&lt;re.Match object; span=(16, 18), match='~5'&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9ffd92cfd34f8f8b07cd15282061c6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62297530b07d8a921c4fb6c012cd25a4/" rel="bookmark">
			P1017 [NOIP2000 提高组] 进制转换（C&#43;&#43;/Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题是我刷洛谷题的开篇，主要针对洛谷 普及/提高组 的题目，写博客的目的也是希望在提高自己能力的同时，能够分享给大家一些思路。能力有限，不对的地方还请大家批评指正。
本题传送门：P1017 进制转换
负进制数与正进制数的转换大同小异，都是除以基数再倒取余数就可以，但是负进制转换的过程中，取余时可能会出现负数，这是我们就需要将负余数转换成正数。方法为：将得到的负余数mod + 要转换的进制R，即mod+|R|，这样就使其变成了正数。
C++代码：
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; /** * 设 n / R = t ... mod * 若 mod &lt; 0， 则 mod + |R| -&gt; mod - R * 此时 n = t * R + mod - R + R -&gt; n = (t + 1) * R - R，这样就使负余数变正了 */ int n, R, temp; int i = 0; char ans[1100] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62297530b07d8a921c4fb6c012cd25a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1aca4ab3f3ca86323a51c215cb6a097c/" rel="bookmark">
			AD画板，如何提高工作效率？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，今天跟大家分享一下用AD画PCB过程中的一些基础知识。
完成后的PCB
通常原理图设计完成后，就开始PCB设计。有几个地方需要注意：
1.原理图设计完成后一定要先评审，确保无误后再进行PCB设计。
2.PCB布局（保证USB，RJ45及其它连接器位置合适），这些都需要跟结构工程师一起确认。
3.设置好走线规则，否则事倍功半。
4.覆铜前一定要记得补泪滴。
以上就是PCB设计前的一些准备工作。
PCB设计过程中的一些快捷方式有助于提高画板效率。
Ctrl+鼠标左键 对正在布的线完成自动布线连接（如果走线比较长，这个快捷键挺好用）。
E+M+C 点击空白处可迅速找到PCB上想要的元件。
J+C 弹出对话框输入元件位号，可直接找到元件位置。
E+O+S 设置原点（一般设置在PCB左下角，方便贴片的时候导出元件位置）
P+T 布线
选中 + 空格 旋转元器件
V + F 整个PCB全局最大显示
V + B 查看PCB反面布局
T+E 补泪滴
P+G 铺铜
Ctrl + M 测量距离
Shift + C 取消高亮（也可以取消测量距离的显示）
Ctrl + H 删除同一网络的走线（这个用起来比较方便，也可用T+U+N）
Q 快速切换公制/英制单位（在对话框中快速切换快捷键为CTRL+Q）
Shift+S 切换单层显示和多层显示（在画完PCB检查的时候用起来比较方便）
shift+ctrl+空格 切换布线形式（45度，任意角度或弧形走线）
Ctrl + Shift + L/R/T/B 两个及以上元件的左/右/上/下对齐
Ctrl + Shift + H,V 两个及以上元件的水平对齐/垂直等距离对齐
T + U+A 删除所有走线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1aca4ab3f3ca86323a51c215cb6a097c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6cee49c899eaf59a55b17529b62c3663/" rel="bookmark">
			Vue 前端 put 或 post 请求发送到 Spring Boot 后端无法接收到数据的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： Vue前端向Spring Boot后端发送put或post请求，使用axios 问题描述： Vue前端向Spring Boot后端发送数据，使用的是post或是put请求时，后端获取不到数据，显示为空 原因分析： axios默认post请求格式为json，但spring boot默认不使用json格式解析 解决方案： 1、后端处理 在controller方法中的参数前面加入@RequestBody
例：
@PostMapping public void add(@RequestBody Obiect o) { System.out.println(o); } 2、前端处理 将表单数据格式化为字符串
先安装qs库
npm i qs 在axios中的配置文件中加入如下配置即可
import Qs from "qs"; request.interceptors.request.use(config =&gt; { if (config.method === 'put' || config.method === 'post') { config.headers = {'Content-Type': 'application/x-www-form-urlencoded'} config.data = Qs.stringify(config.data) } return config } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16deaecdcf8ca1d555bcf0aea05942cf/" rel="bookmark">
			Spark优化最全解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark 优化 资源调优 在部署spark集群中指定资源分配的默认参数 在spark安装包的conf下spark-env.sh文件
SPARK_WORKER_CORES SPARK_WORKER_MEMORY SPARK_WORKER_INSTANCES #每台机器启动worker数 在提交Application的时候给当前的Application分配更多的资源 提交命令选项：（在提交Application的时候使用选项） --executor-cores --executor-memory --total-executor-cores 配置信息：（Application的代码中设置或在Spark-default.conf中设置） spark.executor.cores spark.executor.memory spark.max.cores 动态分配资源 spark.shuffle.service.enabled true //启用External shuffle Service服务 spark.shuffle.service.port 7337 //Shuffle Service服务端口，必须和yarn-site中的一致 spark.dynamicAllocation.enabled true //开启动态资源分配 spark.dynamicAllocation.minExecutors 1 //每个Application最小分配的executor数 spark.dynamicAllocation.maxExecutors 30 //每个Application最大并发分配的executor数 spark.dynamicAllocation.schedulerBacklogTimeout 1s spark.dynamicAllocation.sustainedSchedulerBacklogTimeout 5s 并行度调优 并行度的合理调整，可以降低资源浪费提高spark任务的运行效率。
task的数量应该设置为sparkCPU cores的2-3倍。
如果读取的数据在HDFS中，降低block大小，相当于提高了RDD中partition个数sc.textFile(xx,numPartitions)sc.parallelize(xxx, numPartitions)sc.makeRDD(xxx, numPartitions)sc.parallelizePairs(xxx, numPartitions)repartitions/coalesceredecByKey/groupByKey/join —(xxx, numPartitions)spark.default.parallelism 500spark.sql.shuffle.partitions—200自定义分区器如果读取数据是在SparkStreaming中
Receiver: spark.streaming.blockInterval—200ms定义的是max
Direct:读取的topic的分区数 代码调优 避免创建重复的RDD val rdd1 = sc.textFile(path1) val rdd2 = sc.textFile(path1) 这就是创建了重复的RDD
有什么问题？ 对于执行性能来说没有问题，但是呢，代码乱。
对多次使用的RDD进行持久化 如何选择一种最合适的持久化策略?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16deaecdcf8ca1d555bcf0aea05942cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5563d00e8892d86b4f953b218bc2e520/" rel="bookmark">
			Docker教程：解决Docker容器内不能使用vim命令的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker教程：解决Docker容器内不能使用vim命令的问题
在使用docker容器时，有时候里边没有安装vim，敲vim命令时提示说：vim: command not found，如图所示：
这时候就需要安装vim。
可是当你敲apt-get install vim命令时，提示：
Reading package lists... Done Building dependency tree Reading state information... Done E: Unable to locate package vim 如图所示：
这时候需要敲：apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。
等更新完毕以后再敲命令：apt-get install vim命令即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10b80b6bc4b581e2f1f33b6bdb6af4dd/" rel="bookmark">
			ubuntu18.04同时使用多个有线网络和无线网络时如何设置优先级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 当在工控机上使用ubuntu18.04进行工业控制时，我们经常需要将工控机与局域网、其他硬件等通过网线连接，同时我们的工控机可能还配置了无线网卡用来连接因特网（用来浏览网页或者下载安装因特网上的各种包）。
在这种情况下，我们经常会遇到一个问题：工控机同时连接了多个有线网口以及用无线网卡连接了因特网，但是打开浏览器时无法连接到因特网或者是使用apt工具下载安装功能包时无法连接到因特网。 原因分析： 打开浏览器或者使用apt工具下载包时系统默认使用了其他网口，而没有使用连有因特网的无线网卡。即无线网卡的使用优先级较低。 解决思路： 通过修改网络的metric值提高无线网卡的使用优先级。
metric是为路由指定的跃点数（范围是 1 ~ 9999），它用来在路由表里的多个路由中选择与转发包中目标地址最为匹配的路由。跃点数能够反映跃点的数量、路径的速度、路径可靠性、路径吞吐量以及管理属性等。metric的值越小，优先级越高。如果两块网卡的metric值相同，就会因为抢占优先级出现网卡冲突，将会有一块网卡无法连接。
具体方法： 1 方法一：使用终端命令临时提升无线网卡的优先级 （方法一适用于临时调试时，提升所连临时网络的优先级，断网后重连失效，偶尔使用时方便快捷）
1.1 打开终端，输入下方命令，查询路由表 route -n 结果如下图：
图中Gateway一列显示的是网关IP，Iface一列显示的是网卡名称（eno1、enp6s0是有线网口名称，wlp1s0是无线网卡名称）。
1.2 终端输入命令，指定metric值，可以通过网卡名称指定或者通过网关IP指定（任选其一即可） 1.2.1 通过网卡名称指定metric值
sudo ifmetric wlp1s0 90 命令中wlp1s0是无线网卡的名称。
终端执行命令route -n重新查询路由表，检查对应的metric值是否设置成功，结果如下图。
图中显示wlp1s0无线网卡的metric值设置为90，低于其他网络的metric值，所以会优先使用。此时浏览器将会使用无线网卡上网。
1.2.2 通过网关IP指定metric值
ip route add default via 192.168.43.1 metric 80 命令中192.168.43.1是无线网卡所连的网关IP。
终端执行命令route -n重新查询路由表，检查对应的metric值是否设置成功，结果如下图。 图中显示网关192.168.43.1的metric值设置为80，低于其他网络的metric值，所以会优先使用。此时浏览器将会使用192.168.43.1网关上网。
2 方法二：使用netplan配置网络 （方法二适用于长期调试时，提升所连网络的优先级，不用每次在终端输入命令）
2.1 查看配置文件 ls /etc/netplan 可以看到配置文件名称。
2.2 打开配置文件 sudo gedit /etc/netplan/*.yaml 命令中*是步骤2.1中看到的文件名，比如我的是50-cloud-init.yaml。
2.3 编辑配置文件 network: version: 2 ethernets: eno1: #网卡1名称，使用ifconfig -a可以查看 dhcp4: false #false-dhcp4关闭，true-dhcp4开启 addresses: [192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10b80b6bc4b581e2f1f33b6bdb6af4dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/debdf978e82a04e22c30f4ca680bfb58/" rel="bookmark">
			JavaWeb学习笔记-Tomcat虚拟目录与虚拟主机介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat虚拟目录与虚拟主机介绍 1.主配置文件 server.xml conf文件夹中包含server.xml配置文件
8080 端口：tomcat服务默认端口号。访问url地址后必须手动写：808080端口：http协议采用的端口号。访问url地址后不用写：80 2.虚拟目录 虚拟目录的作用：可以发布任意目录下的项目
编辑server.xml配置文件，找到标签加入以下内容
path属性：访问资源的虚拟目录名称
docbase属性：项目真实存在的路径
再次启动tomcat
3. tomcat配置虚拟主机 虚拟主机的作用：可以指定访问路径
1、编辑server.xml配置文件，找到标签
2、加入以下内容
name：表示访问虚拟主机的名称
appBase:项目存放的路径
unpackWARS:是否自动解压war包
autoDeploy:是否自动发布
3.修改hosts文件
加入 127.0.0.1 www.webdemo.com
host文件位置
关于如何修改hosts文件，这里需要权限：
可以鼠标右键windows，选择powershell(管理员)
然后输入notepad 这时会弹出一个窗口，txt文件，选择打开，打开上述hosts文件，在尾部添加127.0.0.1(这个ip地址代表本机ip)
www.webdemo.com
4.浏览器中输入www.webdemo.com:8080
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be0979a4fedc895dab0e0755ab133b0/" rel="bookmark">
			一文看懂volatile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		volatile是java提供的弱同步机制，只能用来声明变量。
回顾一下，Java 内存模型中的可见性、原子性和有序性。
可见性：
可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。
在 Java 中 volatile、synchronized 和 final 实现可见性。
原子性：
原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。
在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。
有序性：
Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行
1、volatile的特点 当一个变量被定义为volatile时候，就具备2个特性。 1.1 可见性 保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。
1.2 禁止指令重排序 有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。
2、volatile 的性能 读性能和其他普通变量没什么差别。 写性能就比普通变量要慢一些，因为本地代码需要插入一些内存屏障指令，从而保证处理器不发生乱序执行。 3、volatile 和 synchronized的比较 3.1 volatile 只能声明变量。synchronized关键字可以修饰方法，也可以声明变量、还有代码块
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9be0979a4fedc895dab0e0755ab133b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5285a1039d74ef253dcb6d589f22175e/" rel="bookmark">
			echarts实现地图下钻
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公司的新项目需要写这样的地图，还要能两级下钻到省，下面是我写好了的样子，我今天就是复一下盘：
如何用echarts显示地图 首先需要下载map的Json数据，我放到这里：mapJson
然后使用echarts的geo配置，或者series的type = 'map’就可以加载地图了：
import chinaMapJson from "./china.json" echarts.registerMap('china', chinaMapJson) var options = { tooltip:{ show:false }, geo: { map: 'china', roam:false, label: { emphasis: { show: false } } } } const el = document.getElementById("chart") const chart = echart.init(el) chart.setOption(options) 这样就可以显示中国地图。
第二种是series的type设置为map:
import chinaMapJson from "./china.json" echarts.registerMap('china', chinaMapJson) var options = { tooltip:{ show:false }, series: [ { type: 'map', map: 'china' } ] } const el = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5285a1039d74ef253dcb6d589f22175e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e1704e1807d61e8627ab9324022d964/" rel="bookmark">
			(成功解决)网页无法打开位于http://www.baidu.com/的网页无法加载，因为:net:ERR_NAME_NOT_RESOLVED
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Android跳转webview报错：net:ERR_NAME_NOT_RESOLVED问题描述：解决方案一、关闭模拟器重新启动二、查看模拟器中的网络是否打开三、修改mainifests文件 Android跳转webview报错：net:ERR_NAME_NOT_RESOLVED 网页无法打开位于http://www.baidu.com/的网页无法加载，因为:net:ERR_NAME_NOT_RESOLVED
问题描述： Android测试webview，打开模拟器时出现如下图所示的状况，网页无法打开
解决方案 一、关闭模拟器重新启动 这个方法看运气，说不定就成功了（不推荐）
二、查看模拟器中的网络是否打开 可以看到网络开关并没有打开，那么我们打开它再运行一遍
成功运行
三、修改mainifests文件 在AndroidMainifest.xml清单文件里添加一行代码，位置在上方
&lt;uses-permission android:name="android.permission.INTERNET" /&gt; 之后再重新运行一次
成功运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc06608eab30a238c15ae9c44f79d20e/" rel="bookmark">
			postman断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、先说返回数据json断言
在断言列表中选择自己想要的断言函数，参数替换成自己的即可
我的返回体是这样的：
原始的函数：
pm.test("Your test name", function () { var jsonData = pm.response.json(); pm.expect(jsonData.value).to.eql(100); }); 然后我的断言函数这样改
pm.test("断言msg值为：查询成功", function () { var jsonData = pm.response.json(); pm.expect(jsonData.msg).to.eql("查询成功"); }); 学废了吗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b57807fce39799228ca257b8f5b98e40/" rel="bookmark">
			Python 生成器和迭代器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		迭代器 在python中列表（list）、元组（tuple）、字典（dict）、集合（set）这些数据容器都有一个共同的特性，它们都支持使用for循环遍历容器中存储的元素，都是可迭代的也成为迭代器。
迭代时访问集合元素的一种非常强大的方式。迭代器可以记住遍历位置，不会对例如列表这样的数据容器一次性全部生成，而是等到用的时候才会去生成。我们也可以创建一个可迭代的对象：只要此对象含有__iter__方法，那么它就是一个可迭代的对象
如果要自定义实现一个迭代器，则类中必须实现以下两个方法：
__next(self)：返回容器的下一个元素__iter(self)：该方法返回一个迭代器（iterator）。 这两个方法是迭代器最基本的方法，一个用来获得迭代器对象，一个用来获取容器中的下一个元素。
通过iter()方法获得了list的迭代器对象，然后就可以通过next()方法来访问list中的元素了。当容器中没有可访问的元素后，next()方法将会抛出一个StopIteration异常终止迭代器。
其实，当我们使用for语句的时候，for语句就会自动的通过__iter__()方法来获得迭代器对象，并且通过next()方法来获取下一个元素。
如下实例，自定义一个简易的列表容器迭代器
class Test: def __init__(self): self.__date=[] #==&gt; list_t = [] self.__step = 0 def __next__(self): if self.__step &lt;= 0: raise StopIteration self.__step -= 1 #返回下一个元素 return self.__date[self.__step] def __iter__(self): #实例对象本身就是迭代器对象，因此直接返回 self 即可 return self #添加元素 def __setitem__(self,key,value): self.__date.insert(key,value) self.__step += 1 t_list = Test() t_list[0]='jibu' t_list[1]='zhangsan' for i in t_list: print (i) 结果 zhangsan jibu python 内置的iter()函数也会返回一个迭代器
# 将列表转换为迭代器 test = iter([1, 2]) # 依次获取迭代器的下一个元素 print(test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b57807fce39799228ca257b8f5b98e40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f33b50c5c7e7b30e4008393c6394fdf/" rel="bookmark">
			jmeter内存溢出的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 jmeter内存溢出的解决方法
参考文章：
（1）jmeter内存溢出的解决方法
（2）https://www.cnblogs.com/hd-test/p/12176579.html
备忘一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a5673d51d66fb43f4f6361dcf100655/" rel="bookmark">
			webpack 最全的总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webpack 安装 安装之前进行项目初始化生成 package.json 文件
npm init -y npm init 接下来安装 webpack 和 webpack-cli
npm i webpack webpack-cli --save 配置命令行 在package.json文件的scripts字段中配置启动命令
"scripts":{ "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev":"webpack --mode development", "build":"webpack --mode production", } 创建入口文件 webpack 默认的入口文件是 src 目录下的 index.js;
需要在项目的根目录下创建src文件夹，在里边创建 index.js 文件作为入口文件
执行命令 命令执行成功后。会自动在项目的根目录下生成一个dist 文件，该文件就是打包后的产物； dist 文件不是必须的，可以随时删除的
开发环境 npm run dev 生产环境 npm run build webpack 支持的模块化 webpack 支持 CommonJs 模块化 和 es6的模块化
CommonJs // 模块导出 module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a5673d51d66fb43f4f6361dcf100655/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b6a820b4faa4a6f0e4b050e6743a5e2/" rel="bookmark">
			魔改nnU-Net夺冠！2021 BraTS 脑肿瘤分割竞赛第一名解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击下方卡片，关注“CVer”公众号
AI/CV重磅干货，第一时间送达
转载自：集智书童 Extending nn-UNet for brain tumor segmentation
论文：https://arxiv.org/abs/2112.04653
代码（刚刚开源）：
https://github.com/rixez/Brats21_KAIST_MRI_Lab
本文描述了基于nn-UNet试验了几种改进，包括使用更大的网络、用GN替换BN以及在解码器中使用Axial Attention。与Baseline相比，量化指标略有改进。在unseen test data的最终排名中，nn-UNet赢得了第一名的好成绩。
1改进策略 1.1 数据方面 BraTS2021包括了来自2000名患者的多参数MRI扫描结果，其中1251人的图像提供了分割标签给参与者来开发算法，其中219人在验证阶段被用于公共排行榜，其余530个案例用于私人排行榜和参与者的最终排名。
MRI扫描有4种对比:
原生T1加权图像
对比后T1加权(T1GD)
T2加权
T2流体衰减反转恢复(T2-Flair)
注释由1-4个评分员手工完成，最终得到有经验的神经放射学家的批准。这些标签包括gd增强肿瘤(ET)、瘤周水肿/侵袭组织(ED)和坏死肿瘤核心(NCR)区域。所有MRI扫描均通过同解剖模板配准、各向同性1mm3分辨率插值和颅骨剥离进行预处理。所有MRI扫描及相关标记的图像大小为240×240×155。
图1 图1显示了这4种对比与分割的代表性切片。在输入网络之前，对提供的数据进行了进一步的处理。为了减少计算量，将volumes裁剪为non-zero voxels。由于MR图像的强度是定性的，因此根据其均值和标准差对voxels进行归一化。
1.2 模型方面 1、Baseline nnU-Net nnU-Net核心是一个在128×128×128大小的Patch上运行的3D U-Net。该网络具有编码-解码器结构，并带有Skip Connection，将两条路径连接起来。
该编码器由5个相同分辨率的卷积层组成，具有卷积下采样功能。该解码器遵循相同的结构，使用转置卷积上采样和卷积操作在同一级别上的编码器分支的串联Skip特征。每次卷积操作后，采用斜率为0.01的Leaky ReLU(lReLU)和批归一化处理。mpMRI volumes被连接并作为4通道输入。
nnU-Net应用Region-Based训练，而不是预测3个相互排斥的肿瘤子区域，而不是预测3个互斥肿瘤分区,与提供的分割标签一样，该网络预测的是增强肿瘤的3个重叠区域如加强肿瘤(ET,original region),肿瘤核心或TC(ET+necrotic tumor),和整个肿瘤或WT(ET+NT+ED)。
网络的最后一层的softmax被sigmoid所取代，将每个voxels作为一个多类分类问题。
由于公共和私人排行榜的计算指标是基于这些区域的，这种基于区域的训练可以提高表现。额外的sigmoid输出添加到每个分辨率除了2个最低的水平，应用深度监督和改善梯度传播到早期层。卷积滤波器的数量被初始化为32个，并且分辨率每降低一倍，最大可达320个。
2、更大的网络和GN 第一个修改是，通过将编码器中的kernel数量加倍，同时在解码器中保持相同的kernel，非对称地增加了网络的大小。由于训练数据的数量是前一年的4倍，增加网络的容量将有助于它能够建模更大的数据种类。kernel的最大数量也增加到512个，改进后的网络结构如图2所示：
图2 第二个修改是用GN代替所有BN。即使使用混合精度训练，3D卷积网络也需要大量的GPU内存，这限制了在训练中可以使用的Batch-Size。
3、Axial attention解码器 最后添加的是在解码器中使用Axial attention。Self-Attention或Transformer是一个突破性的想法，允许学习一个输入序列的自适应注意力仅仅基于它自己。Self-Attention最初是在自然语言处理中，现在已经慢慢被计算机视觉研究所采用。当试图将Self-Attention应用于视觉问题时，主要的障碍之一是注意力机制的计算复杂度与输入的大小成二次方，这使得它不可能适合或训练网络在一个标准的工作站设置。当处理带有额外维度的3D数据时，这是一个更大的问题。
Axial attention最近被提出作为将注意力应用于多维数据时的一种有效解决方案。通过将Self-Attention独立地应用于输入的每一个轴上，计算只与图像大小成线性比例，使注意力机制即使与3D数据整合成为可能。
本文将Axial attention应用到网络的解码器上，将其运行在转置卷积上采样的输出上，然后将它们相加。
图3 显示了Axial attention解码器块的示意图。即使有了更有效的注意力，作者发现这种方法也不可能应用于最高分辨率的特征(128×128×128)，因此只选择了4个较低分辨率的特征。注意力头的数量和每个头的尺寸随着分辨率的降低而增加一倍，分别从4和16(64×64×64分辨率)开始。
1.3 训练策略 这里遵循nnU-Net训练方法。每个网络都接受了5倍交叉验证的训练。在训练过程中，动态地应用数据增强来提高泛化能力。数据增强包括随机旋转和缩放、弹性变形、附加亮度增强和伽玛缩放。
优化的目标是binary entropy loss和Dice loss的总和，计算在最终的全分辨率输出以及在低分辨率的辅助输出。使用Batch Dice loss代替sample Dice loss，将整个批次作为一个样本来计算损失，而不是平均每个样本在小批中的Dice。批量Dice帮助稳定训练通过减少来自样本的错误，少量的注释样本。网络采用Nesterov动量为0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b6a820b4faa4a6f0e4b050e6743a5e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6bbe35a2a0d5039c72ecb4a30e034b6/" rel="bookmark">
			Centos安装NextCloud
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章参考 特此说明
https://blog.csdn.net/sadcd/article/details/104832779
无法连接OFFICE
用docker安装Nextcloud 出现无法连接外部数据库以及集成onlyoffice时报错的解决方法_lggirls的博客-CSDN博客_nextcloud连接不上数据库
帮助文档
NextCloud实现文件在线预览和编辑 · 自建企业网盘：镜像部署与使用实战 · 看云
Memory caching — Nextcloud latest Administration Manual latest documentation
1.在使用nextcloud 集成onlyoffice时，会出现提示 ：host violates local access rules
需要在配置文件 config.php 中增加下列语句：
'allow_local_remote_servers' =&gt; true,
写此文章记录自己搭建过程
1.服务器硬件准备 CPU：根据自己需求选择
内存：2G以上
硬盘：2T以上（最后讲如何扩容）
1.安装Centos系统/Ubuntu系统 本文章采用Centos7系统
安装完成后更新一下系统
yum update # (Centos) //Ubuntu需要两条指令来升级 apt-get update -y # (Ubuntu) apt-get upgrade -y # (Ubuntu) 2.安装宝塔控制面板（安装LAMP环境） 宝塔控制面板官网 宝塔面板 - 简单好用的Linux/Windows服务器运维管理面板 感兴趣的可以看看
使用命令安装
//Centos指令 yum install -y wget &amp;&amp; wget -O install.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6bbe35a2a0d5039c72ecb4a30e034b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a64793624925d34aa4a5454ef0068bf/" rel="bookmark">
			Tableau豆瓣电影项目实战作业 Day8
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作业要求
1、使用“全球超市订单数据”，创建市场-销售条形图，将市场和细分市场合并为市场层级，显示销售额标签，图像中要下钻到细分市场层级，添加说明，导出图像；
2、使用“全球超市订单数据”，筛选出中国，然后将省份按照下面的地理地区重新分组，分组后创建各地区利润的填充地图，添加地区和利润标签，分析说明，导出图像。
中国一般分为七大地理地区：
东北（黑龙江省、吉林省、辽宁省）；
华东（上海市、江苏省、浙江省、安徽省、福建省、江西省、山东省、台湾省）；
华北（北京市、天津市、山西省、河北省、内蒙古自治区）；
华中（河南省、湖北省、湖南省）；
华南（广东省、广西壮族自治区、海南省、香港特别行政区、澳门特别行政区）；
西南（重庆市、四川省、贵州省、云南省、西藏自治区）；
西北（陕西省、甘肃省、青海省、宁夏回族自治区、新疆维吾尔自治区）
1.将市场和细分市场组合添加分层结构，拉到行标签
2.首先是调出经纬度到行和列标签，我是先拉了省市自治区维度到图上显示，筛选出中国，然后先将几个点分组再进行划分区域，步骤较麻烦。广西和台湾好像是没数据没能纳入到
这个博主比较简便
Tableau 数据分层、数据分组https://blog.csdn.net/Nicole_678/article/details/115050805?spm=1001.2014.3001.5501
THE END
第一次在CSDN写下自己学习分享的博客，通过用案例实战，希望尽快学好Tableau，马上过渡到SQL学习当中——正在努力想要转型数据分析师的广告优化师。（分析点评的语术可能比较口语化和欠缺经验，希望各位DS和DA大神多多指教，虚心受教。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38deeb3ec90ed00fce0431602c500f9/" rel="bookmark">
			滑块验证码破解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滑块验证码破解 最近在爬虫开发的过程中，遇到了关于滑块验证码，需要进行滑块验证码破解。这里涉及到图像方面的技术，可以借助OpenCV进行解决。
通过CV2解决滑块验证 这里通过CV2库进行滑块验证的解决。简单介绍一下滑块验证的几个步骤。
1. 获取图片（缺口图，缺块图） 根据网页，获取到滑块图片，一般来说分为两个图片，一个是缺口图，也就是缺少缺口的图片。一个是滑块图，也就是缺口图缺少的图片。假设缺口图为img1,滑块图为img2。
img1:
img2:
2. 识别缺口位置，计算滑动距离 一般而言，我们通过网页获取到的图片和实际在网页上显示的图片大小是不一致的。读者可以根据自己需要破解的滑块验证码进行校验。查看在网页中的图片大小和下载的图片大小是否一致。如果不一致，那么需要调整下载的图片的大小为网页中图片的大小，因为移动的距离是以网页为准。
读取图片，然后调整图片的大小为网页中显示的大小。
img1 = cv2.imread(缺口图的路径) img1 = cv2.resize(img1, (网页缺口图实际宽度, 网页缺口图实际高度)) img2 = cv2.imread(缺块图的路径) img2 = cv2.resize(img2, (网页缺块图实际宽度, 网页缺块图实际高度)) 如果要识别缺口位置，可以借助cv2库的matchTemplate方法来获取缺块距离缺口的位置。实现代码如下所示，一般来说这种方法识别会带有误差，也就是存在失败的情况，这个时候可以在程序中进行设置，进行多次尝试解决滑块验证(可以采用循环处理的办法，重复多次滑块验证解决流程)，以达到解决滑块问题的效果。
img1_gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY) # 对图片灰度化处理 img2_gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)# 对图片灰度化处理 res = cv2.matchTemplate(img1_gray, img2_gray, cv2.TM_CCOEFF_NORMED) value = cv2.minMaxLoc(res) #获取缺口和缺块的距离 value = value[3][0] #value值就是缺块距离缺口的距离 3. 模拟运动 我们可以借助selenium进行模拟滑块拖动的过程，但是在模拟滑块的拖动过程中，需要模拟人的速度。人在拖动滑块的时候，正常是先快后慢的过程，这个时候我们可以设置一个先快后慢的过程（可以设置两个运动方程，一段加速度为a1,一段加速度为a2），用于模拟人拖动滑块。示例代码如下所示：
# ditance为移动的距离，也就是上面获得的value def getTrack(self,distance): #用于存储每个过程中，拉动滑块的距离 track = [] # 当前位移 current = 0 # 当距离超过什么时候，进行减速 mid = distance * 4 / 5 # 计算间隔 t = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38deeb3ec90ed00fce0431602c500f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93472cc0a79f280344282a590eb3c180/" rel="bookmark">
			在react中使用highlight.js将页面上的代码高亮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通过 highlight.js 库实现对文章正文 HTML 中的代码元素自动添加语法高亮，highlight.js官方文档
下载highlight.js npm i highlight.js 导入highlight.js import hljs from 'highlight.js' import 'highlight.js/styles/vs2015.css' 用highlight.js useEffect(() =&gt; { // 配置 highlight.js hljs.configure({ // 忽略未经转义的 HTML 字符 ignoreUnescapedHTML: true }) // 获取到内容中所有的code标签 const codes = document.querySelectorAll('pre code') codes.forEach((el) =&gt; { // 让code进行高亮 hljs.highlightElement(el as HTMLElement) }) }, []) 实例代码 import hljs from 'highlight.js' import 'highlight.js/styles/vs2015.css' import { useEffect } from 'react' export default function Question () { useEffect(() =&gt; { // 配置 highlight.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93472cc0a79f280344282a590eb3c180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eedbbcc6e7768b21ad776031bb24bb8/" rel="bookmark">
			微信小程序自定义select组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Select组件 wxss文件
.select-box { position: relative; /* width: 100%; */ /* font-size: 30rpx; */ } .select-current { width: 730rpx; height: 45rpx; background-color: white; margin-left: 10rpx; position: relative; padding: 0rpx 10rpx; /* line-height: 40rpx; */ /* border: 1rpx solid #ddd; */ border-radius: 10rpx; box-sizing: border-box; } .select-current::after { position: absolute; display: block; right: 16rpx; top: 18rpx; content: ''; width: 0; height: 0; border: 10rpx solid transparent; border-top: 10rpx solid #999; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eedbbcc6e7768b21ad776031bb24bb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c52ac4cfdf3b7d375c9351786b450a79/" rel="bookmark">
			缺少lib库文件解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缺少lib库文件解决方法 1.缺少依赖包ld-linux.so.2
/lib/ld-linux.so.2: bad ELF interpreter: 没有那个文件或目录
yum install glibc.i686 2.缺少依赖包libaio.so.1
mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such f
yum install -y libaio 3.缺少依赖包libncurses.so.5 mysql: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory
centos7：yum -y install libaio numactl-1ibs centos8：yum -y install libncurses* 4…缺少依赖包libtinfo.so.5
mysql: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c52ac4cfdf3b7d375c9351786b450a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18104d0137a8c5481520dfc844dbb9a0/" rel="bookmark">
			python列表、字典、元组、集合学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信公众号：运维开发故事，作者：wanger
列 表
列表在python里是有序集合对象类型。
列表里的对象可以是任何对象：数字，字符串，列表或者字典，元组。与字符串不同，列表是可变对象，支持原处修改的操作
python的列表是：
任意对象的有序集合
通过偏移读取
可变长度、异构以及任意嵌套
属于可变序列的分组
对象引用数组
列表的操作 列表的操作和字符串大部分都相同：
合并/重复：
list1+list2：结果是两个列表按顺序结合
list*3：结果是列表list重复三次
for i in list1: print(i)：按顺序打印列表里的内容
3 in list：判断列表里有没有一个对象是对象3
list1.index(1)：查找列表里第一个为1的对象的位置
list1.count(1)：查找列表里对象为1的个数
list1[x:y]：取第x到y的对象，重新建立一个列表
len(list1)：list1里的对象个数
基本列表操作 创建一个列表： &gt;&gt;&gt; list=[] &gt;&gt;&gt; list=[1,2,'3',[]] &gt;&gt;&gt; list [1, 2, '3', []] 列表取值： &gt;&gt;&gt; list[1] 2 &gt;&gt;&gt; list[0:3] [1, 2, '3'] 重复列表内容： &gt;&gt;&gt; list*3 [1, 2, '3', [], 1, 2, '3', [], 1, 2, '3', []] 使用in方法来判断对象是否在列表中： &gt;&gt;&gt; 3 in listFalse &gt;&gt;&gt; [] in list True 循环打印： &gt;&gt;&gt; for i in list: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18104d0137a8c5481520dfc844dbb9a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8959cd3c919655eff6c6b2894de246d/" rel="bookmark">
			setContentView流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、activity、window、DecorView、ViewRoot之间的预备知识 activity activity是Android的四大组件之一，负责控制activity的生命周期和处理事件，负责视图的添加与显示，以及通过一些回调方法与window和View进行交互。一个activity包含一个window,window才是真正的窗口
Window Window是一个抽象类，它真正的实现类是PhoneWindow。Window通过WindowManager加载一个DecorView到Window中，并将DecorView交给ViewRoot。
FrameWork定义了三种窗口类型，三种类型定义在WindowManager,通过LayoutParams.type设置
应用窗口，对应于一个Activity。加载Activity由AmS完成，创建一个应用窗口只能在Activity内部完成（层级1~99）。子窗口，必须依附于任何类型的父窗口（层级1000~1999）。系统窗口，不需要对应任何Activity，如：状态栏，导航栏,普通应用程序不能创建系统窗口，必须要有系统应用权限.（层级2000~2999）。 DecorView DecorView是FrameLayout的子类，它可以被认为是Acitivity的视图根节点。是setContentView所设置的View的父容器。
ViewRoot ViewRoot对应ViewRootImp类，它是连接WindowManager和DecorView的纽带，在ActivityThread中，当Activity对象创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImp对象，并将ViewRootImp对象和DecorView建立关联。View的三大流程measure layout draw都是通过ViewRoot完成。ViewRoot并不属于View树的一部分，从源码上看它既非View的子类，也非View的父类，但是它实现了ViewParent接口，所以可以算作名义上的View的父视图。ViewRoot继承了Handler类，Android所有的触屏事件、按键事件、界面刷新等事件都是通过ViewRoot进行分发的.
ViewRootImpl中调用performTraversals方法，然后便开始测量布局绘画了，界面才得以显示出来，这就是View的绘制流程起点。
2、activity、window、decorView的视图层级关系 看下一张图
上图描述了activity、window、decorView和设置View的视图层级关系
3、setContentView的具体流程源码 先从Activity.java的setContentView()开始
public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 可以看到如下步骤：
获取window(PhoneWindow)调用PhoneWindow的setContentView方法。初始化dcorView的ActionBar（3.0推出，目的是为了统一界面风格，现在已经被5.0出的ToolBar取代） PhoneWindow.java的setContentView过程 @Override public void setContentView(int layoutResID) { if (mContentParent == null) { //安装 installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { //生成的布局内容添加到 decoView的contentView中去 mLayoutInflater.inflate(layoutResID, mContentParent); } //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8959cd3c919655eff6c6b2894de246d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1396ae864976bfdfcf8ee68cc6fa4d6b/" rel="bookmark">
			vue项目中优雅的导入全局过滤器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue项目中优雅的导入全局过滤器 在项目src目录下创建一个filters目录，用来放全局的过滤器
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MYjHWD9z-1639378809904)(http://ptf.chao-yu.cn/blog/2021/09/28/8f4663edbd7e10458892de709e16abb7-cc3587.png)]
在filters目录下创建index.js文件
例如，创建两个测试过滤器
/** * 测试filter * @param {*} num * @returns */ export const testFilter = (num) =&gt; { return `test${num}` } /** * 测试filter2 * @param {*} num * @returns */ export const testFilter2 = (num) =&gt; { return `test${num}` } 在main.js导入所有的过滤器
import * as filters from '@/filters' Object.keys(filters).forEach(key =&gt; { Vue.filter(key, filters[key]) }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3208ec5afd1b170780ab9d8086bf70f1/" rel="bookmark">
			查找（一）——静态查找表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、查找的基本概念
二、顺序查找 （线性查找）
1、基本思想
2、核心代码
3、顺序查找设置哨兵
4、顺序查找的优点：
5、顺序查找的缺点：
6、折半查找
7、折半查找判定树
8、线性表查找的特点
三、索引顺序表（分块查找）
1、分块查找表存储结构
2、分块查找的基本思想
3、分块查找的代码举例
静态查找表主要有三种结构：
（1）顺序表；
（2）有序顺序表；
（3）索引顺序表。
针对静态查找表的查找算法主要有：
（1）顺序查找（线性查找）；
（2）折半查找（二分查找）；
（3）分块查找（索引顺序查找）。
一、查找的基本概念 列表：由同一类型的数据元素组成的集合。
关键码：数据元素中的某个数据项，可以标识列表中的一个或一组数据元素。 键值：关键码的值。
主关键码：可以唯一地标识一个记录的关键码。
次关键码：不能唯一地标识一个记录的关键码。
查找：在具有相同类型的记录构成的集合中找出满足给定条件的记录。 查找的结果：若在查找集合中找到了与给定值相匹配的记录，则称查找成功；否则，称查找失败。 静态查找：不涉及插入和删除操作的查找 。
动态查找：涉及插入和删除操作的查找。 静态查找适用于：查找集合一经生成，便只对其进行查找，而不进行插入和删除操作; 或经过一段时间的查找之后，集中地进行插入和删除等修改操作；
动态查找适用于：查找与插入和删除操作在同一个阶段进行，例如当查找成功时，要删除查找到的记录，当查找不成功时，要插入被查找的记录。
查找结构：面向查找操作的数据结构 ，即查找基于的数据结构。
线性表：适用于静态查找，主要采用顺序查找技术、折半查找技术。
树表：适用于动态查找，主要采用二叉排序树的查找技术。
散列表：静态查找和动态查找均适用，主要采用散列技术。 二、顺序查找 （线性查找） 1、基本思想 从线性表的一端向另一端逐个将关键码与给定值进行比较，
若相等，则查找成功，给出该记录在表中的位置；
若整个表检测完仍未找到与给定值相等的关键码，则查找失败，给出失败信息。
2、核心代码 int LineSearch::SeqSearch(int k){ i=n; while (i&gt;0 &amp;&amp; data[i]!=k) i--; return i; } 3、顺序查找设置哨兵 哨兵就是待查值，将哨兵放在查找方向的尽头处，免去了在查找过程中每一次比较后都要判断查找位置是否越界，从而提高查找速度。
4、顺序查找的优点： 算法简单而且使用面广。
对表中记录的存储结构没有任何要求，顺序存储和链接存储均可；
对表中记录的有序性也没有要求，无论记录是否按关键码有序均可。
5、顺序查找的缺点： 平均查找长度较大，特别是当待查找集合中元素较多时，查找效率较低
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3208ec5afd1b170780ab9d8086bf70f1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/310/">«</a>
	<span class="pagination__item pagination__item--current">311/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/312/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>