<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8120c5f6c807e470f32dc98dbe4444d8/" rel="bookmark">
			NNDL 实验七 循环神经网络(1) RNN记忆能力实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
循环神经网络的记忆能力实验
数据集构建
数据集的构建函数
加载数据并进行数据划分
构造Dataset类
模型构建
嵌入层
SRN层
线性层
模型汇总
模型训练
训练指定长度的数字预测模型
多组训练
损失曲线展示
模型评价
总结：
参考：
循环神经网络（Recurrent Neural Network，RNN）是一类具有短期记忆能力的神经网络。在循环神经网络中，神经元不但可以接受其他神经元的信息，也可以接受自身的信息，形成具有环路的网络结构，和前馈神经网络相比，循环神经网络更加符合生物神经网络的结构。
目前，循环神经网络已经被广泛应用在语音识别、语言模型以及自然语言生成等任务上。
简单循环网络在参数学习时存在长程依赖问题，很难建模长时间间隔的状态之间的依赖关系。
本章内容主要包含两部分：
模型解读：介绍经典循环神经网络原理，为了更好地理解长程依赖问题，我们设计一个简单的数字求和任务来验证简单循环网络的记忆能力。长程依赖问题具体可分为梯度爆炸和梯度消失两种情况。对于梯度爆炸，我们复现简单循环网络的梯度爆炸现象并尝试解决。对于梯度消失，一种有效的方式是改进模型，我们也动手实现一个长短期记忆网络，并观察是否可以缓解长程依赖问题。案例实践：基于双向长短期记忆网络实现文本分类任务．并了解如何进行补齐序列数据，如何将文本数据转为向量表示，如何对补齐位置进行掩蔽等实践知识。 (PS:循环神经网络的参数可以通过梯度下降法来学习。和前馈神经网络类似，我们可以使用随时间反向传播（BackPropagation Through Time，BPTT）算法高效地手工计算梯度，也可以使用自动微分的方法，通过计算图自动计算梯度。
循环神经网络被认为是图灵完备的，一个完全连接的循环神经网络可以近似解决所有的可计算问题。然而，虽然理论上循环神经网络可以建立长时间间隔的状态之间的依赖关系，但是由于具体的实现方式和参数学习方式会导致梯度爆炸或梯度消失问题，实际上，通常循环神经网络只能学习到短期的依赖关系，很难建模这种长距离的依赖关系，称为长程依赖问题)
循环神经网络的记忆能力实验 循环神经网络的一种简单实现是简单循环网络（Simple Recurrent Network，SRN）
下图是一个按时间展开的循环神经网络，
简单循环网络在参数学习时存在长程依赖问题，很难建模长时间间隔（Long Range）的状态之间的依赖关系，所以构建一个数字求和任务去测试简单循环网络的记忆能力。
数字求和任务的输入是一串数字，前两个位置的数字为0-9，其余数字随机生成（主要为0），预测目标是输入序列中前两个数字的加和，如下图展示了长度为10的数字序列，
如果序列长度越长，准确率越高，则说明网络的记忆能力越好．因此，我们可以构建不同长度的数据集，通过验证简单循环网络在不同长度的数据集上的表现，从而测试简单循环网络的长程依赖能力。
数据集构建 构建不同长度的数字预测数据集DigitSum
数据集的构建函数 输入序列的前两位数字为0−9，其组合数是固定的，所以可以穷举所有的前两位数字组合，并在后面默认用0填充到固定长度. 但考虑到数据的多样性，这里对生成的数字序列中的零位置进行随机采样，并将其随机替换成0−9的数字以增加样本的数量．
我们可以通过设置k的数值来指定一条样本随机生成的数字序列数量.当生成某个指定长度的数据集时，会同时生成训练集、验证集和测试集。当k=3时，生成训练集。当k=1时，生成验证集和测试集。代码实现如下：
import os import torch import random import numpy as np import torch.nn as nn # 固定随机种子 random.seed(0) np.random.seed(0) def generate_data(length, k, save_path): if length &lt; 3: raise ValueError("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8120c5f6c807e470f32dc98dbe4444d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60e51b78cd8fc9f638517f71880e705f/" rel="bookmark">
			ScanNet数据集下载与导出颜色图、深度图、内参、位姿数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 介绍(1)简介(2)版本 1 申请与下载1.1 申请1.2 使用数据脚本下载指定序列 2 将下载的数据序列进行转化(1)使用python2.7(ubuntu18.04自带环境)----采用方案报错1：报错2 (3)使用python3.8(anaconda创建环境)----弃用方案/参考意义报错1报错2 (3)其他序列同样处理： 3附录3.1 python2.7(ubuntu18.04自带环境)--环境配置： ScanNet数据集下载与导出颜色图、深度图、内参、位姿数据 0 介绍 (1)简介 ScanNet是一个RGB-D视频数据集，包含1500多个扫描中的250万个视图，用3D摄像机的姿势、表面重建和实例级的语义分割来注释。为了收集这些数据，我们设计了一个易于使用和可扩展的RGB-D捕捉系统，包括自动表面重建和众包语义注释。我们表明，使用这些数据有助于在几个三维场景理解任务上实现最先进的性能，包括三维物体分类、语义体素标签和CAD模型检索。
(2)版本 在ScanNet之后发布了ScanNet v2(全部文件很大, 共1.3T)，好像现在大部分使用的都是v2版本，具体更改见：ScanNet Changelog，主要更改如下：
Changelo中ScanNet v2 (2018-06-11)声明为:
ScanNet 的新 2D/3D 基准挑战(benchmark challenge) 新的语义标签和实例注释(semantic label and instance annotations ) 新的场景类型注释 新的轴对齐 1 申请与下载 一般从别的博客直接copy下来的代码好像不能进行下载，所以需要自己申请一下。
1.1 申请 参考github:https://github.com/ScanNet/ScanNet
填写申请：https://kaldir.vc.in.tum.de/scannet/ScanNet_TOS.pdf
注：PI可以理解为学术带头人或导师：https://wap.sciencenet.cn/blog-293721-337429.html?mobile=1
发送到邮箱：scannet@googlegroups.com,周一中午12:03发送的邮件，当天下午6:15接收到邮件
1.2 使用数据脚本下载指定序列 参考命令：
download-scannet.py -o [directory in which to download] --id 注：使用vpn的话下载速度会快一些。
scene0004_00
python download-scannet.py -o . --id scene0004_00
下图第一个箭头按任意键进行下载确认，第二个箭头不按下n键，因为第一次使用该数据集，宁愿下载更多无用的避免后续出问题。
scene0005_00
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60e51b78cd8fc9f638517f71880e705f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd286e8c83132e7450ff12268a5c46ff/" rel="bookmark">
			输入十个数并输出其最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;
int main(){
int a[10];//定义一个有十个数的数组 int i;//下标 int max=0;//初始化最大值 printf("请输入十个整数:");
for(i=1;i&lt;=10;i++){
scanf("%d",&amp;a[i]);//从第一个数到第十个数，依次在键盘上输出 }
for(i=1;i&lt;=10;i++){
if(a[i]&gt;a[max]){//依次比较这十个数的大小，如果a[i]这个值大于你输入的这十个数的最大值 max=i;//把i的值赋给max }
}
printf("最大值=%d",max);
return 0;
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d834cb26661386745223264ddaff11/" rel="bookmark">
			【SpringBoot】SpringBoot项目常用依赖及其配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【SpringBoot】SpringBoot项目常用依赖及其配置 文章目录 【SpringBoot】SpringBoot项目常用依赖及其配置一 基本设置1. Maven常用依赖2. yml基本配置 二 拓展配置1. Redis依赖及配置1.1 Redis依赖1.2 Redis配置 2. MongoDB依赖及配置2.1 MongoDB依赖2.2 MongoDB配置 3. JavaMail依赖及配置3.1 JavaMail依赖3.2 JavaMail配置 4. 七牛云依赖及配置4.1 七牛云依赖4.2 七牛云配置 配置自定义，无固定写法。5. RabbitMQ依赖及配置5.1 RabbitMQ依赖5.2 RabbitMQ配置 一 基本设置 1. Maven常用依赖 数据库为mysql，连接池为druid，orm为mp。版本根据需要而变化
&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;!--mysql驱动--&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--工具--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--德鲁伊连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d834cb26661386745223264ddaff11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06d12a646141d3355e43d9384a1be4f1/" rel="bookmark">
			keil调试监视变量的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		凯尔调试过程查看全局变量和局部变量的方法及编译器优化 一、查看全局变量的方法:监视窗口
这看窗口允许计算符号、寄存器和表达式。该窗口显示项目名称、值和类型。
通过工具栏按钮或使用菜单打开此窗口视图–观察窗口. view---watch窗口
在哪里
搜索框允许在当前名称列表中查找表达式。搜索字符串可以由字母数字字符和掩码字符组成，如附录中所述F.TR1搜索表达式.名字列出表达式名称。符号名称符合中描述的规则程序变量(符号)。项目标有图标:-标识复杂类型的项，如结构或数组。-标识简单类型的项，如整数或字符。价值显示内存地址或表达式的计算值。该字段可以包含说明性文本。类型的表达式无符号字符显示值和相应的字符。单引号(‘)指示该值是从以前的调试会话中恢复的。值被更新:每当程序执行停止。在程序执行期间，当视图-定期窗口更新已启用。当单击工具箱按钮更新窗口.类型显示表达式的类型。对于函数，该字段显示返回和参数类型。 使用监视窗口
将表达式拖放到其他窗口，例如内存、命令或逻辑分析仪窗口。
添加表达式
双击文本并开始编辑。请参阅一节公式详情请见。将表达式从其他窗口拖放到“监视”窗口中。打开文件的上下文菜单。使用将项目添加到-观察#。鼠标位置下方的变量被添加到“监视”窗口中。使用命令手表套装贴在窗口上命令. 删除表达式
单击项目名称，然后按删除钥匙。使用命令守望杀手贴在窗口上命令. 更改表达式的值
单击值字段并开始编辑。不是所有的表达式都接受变化。 这上下文菜单允许:
移除表达式。更改值的表示。设置断点。向其他窗口添加表达式。显示或隐藏包含搜索框. 二、查看局部变量的方法:调用堆栈和局部变量窗口
这调用堆栈+局部变量窗口显示当前堆栈上的对象。显示了使用RTX-RTOS的应用程序的任务。每个对象都与其位置或值以及类型相关联。
从工具栏或使用菜单打开此窗口查看-调用堆栈窗口.
在哪里
名字显示符号名称。当前活动的功能或任务以绿色突出显示。双击项目节点以展开或折叠项目。位置/价值显示该项目的内存地址或值，或者有说明性文本。对于类型的物料无符号字符该字段显示值和字符。类型显示对象类型。函数与其返回类型和参数类型相关联。 窗口内容会自动更新:
每当程序执行停止时。在程序执行期间，当视图-定期窗口更新已启用。 上下文菜单允许:
跳转到呼叫者代码。跳转到被调用方代码。在十六进制和十进制表示值之间切换。 三、编译器优化:编译器优化级别和调试视图
编译器执行的精确优化取决于所选择的优化级别，以及您是针对性能还是代码大小进行优化。
编译器支持以下优化级别:
0
最小优化。关闭大多数优化。启用调试时，此选项会提供最佳的调试视图，因为生成代码的结构直接对应于源代码。所有干扰调试视图的优化都被禁用。特别是:断点可以设置在任何可到达的点上，包括死代码。变量的值在其作用域内的任何地方都是可用的，除了未初始化的地方。Backtrace给出了预期从读取源开始的开放函数激活的堆栈。请注意，尽管由-O0与源代码最接近，用户可能更喜欢由-O1因为这将在不改变基本结构的情况下提高代码的质量。注意死代码包括对程序结果没有影响的可达代码，例如从未使用过的局部变量赋值。不可到达的代码是指不能通过任何控制流路径到达的代码，例如紧跟在return语句之后的代码。
1
受限优化。编译器只执行可以由调试信息描述的优化。移除未使用的内联函数和静态函数。关闭严重降低调试视图质量的优化。如果与一起使用--debug，这个选项给出了一个总体上令人满意的调试视图，代码密度很高。调试视图与–O0are:不能在死代码上设置断点。变量的值在初始化后可能在其作用域内不可用。例如，如果他们被分配的位置已经被重新使用。没有副作用的函数可以不按顺序调用，或者在不需要结果时可以省略。由于tailcalls的存在，Backtrace可能不会给出读取源时预期的开放函数激活的堆栈。优化级别–O1在源代码和目标代码之间产生良好的对应，尤其是当源代码不包含死代码时。生成的代码将比–O0，这可以简化目标代码的分析。
2
高度优化。如果与一起使用--debug，调试视图可能不太令人满意，因为目标代码到源代码的映射并不总是清晰的。编译器可能会执行调试信息无法描述的优化。这是默认的优化级别。调试视图与–O1由于多个源代码位置映射到文件的一个点的可能性，以及更激进的指令调度，源代码到目标代码的映射可能是多对一的。指令调度允许跨序列点。这可能会导致在某个特定点报告的变量值与您可能从阅读源代码中得到的值不匹配。编译器自动内联函数。
3
最大优化。启用调试时，此选项通常会给出一个糟糕的调试视图。ARM建议在较低的优化级别进行调试。如果你使用-O3和-Otime编译器一起执行更激进的额外优化，例如:高级标量优化，包括循环展开。这可以以较小的代码规模成本带来显著的性能优势，但代价是更长的构建时间。更积极的内联和自动内联。这些优化有效地重写了输入源代码，导致目标代码与源代码的对应性最低，调试视图最差。这--loop_optimization_level=option控制在下执行的循环优化量–O3 –Otime。循环优化的数量越多，源代码和目标代码之间的一致性就越差。有关在源代码上执行的高级转换的更多信息，请访问–O3 –Otime使用--remarks命令行选项。
因为优化会影响目标代码到源代码的映射，所以优化级别的选择-Ospace和-Otime通常会影响调试视图。
选择-O0如果需要简单的调试视图，则是最好的选择。选择-O0通常会将ELF图像的大小增加7%到15%。若要减小调试表的大小，请使用--remove_unneeded_entities选项。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3fae420c072ad95a50a4715fb9cc1a0/" rel="bookmark">
			ValueError: Cannot load file containing pickled data when allow_pickle=False
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在用np.load()加载pkl文件时，报了这个错误：
ValueError: Cannot load file containing pickled data when allow_pickle=False 根据评论区哥们niubiqigai的留言，首先需要检查是否是加载的文件有问题，例如文件不完整、文件空白等。如果文件完整的话，然后可以检查是否是numpy版本的问题。
将numpy切换成如下版本，可以解决问题。
pip install numpy==1.14.* 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f05d97edd241c979fbb378c159174d6/" rel="bookmark">
			一张图看懂 USDT三种类型地址 Omni、ERC20、TRC20的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		USDT是当前实用最广泛，市值最高的稳定币，它是中心化的公司Tether发行的。在今年的4月17日之前，市场上存在着2种不同类型的USDT。4月17日又多了一种波场TRC20协议发行的USDT，它们各自有什么区别呢?哪个转账最快到账？哪种最安全？手续费最低？
USDT三种链类型Omni、ERC20、TRC20的区别
Tether公司发行发行的USDT稳定币一共有三种类型，分别是基于比特币、以太坊和TRON。基于比特币和基于以太坊的USDT，两者不兼容、不能相互转账，可以从存储的地址中判断USDT是属于哪一种。
USDT是Tether公司推出的基于稳定价值货币美元（USD）的代币Tether USD（简称USDT），1 USDT=1美元。
USDT的发行和交易使用的是Omni（原Mastercoin）协议，它是一个基于比特币区块链的2.0币种。USDT的交易确认等参数与比特币是一致的。用户可以通过SWIFT电汇美元至Tether公司提供的银行帐户，或通过交易所换取USDT。赎回美元时，反向操作即可。用户也可在交易所用比特币换取USDT。
Tether公司严格遵守1：1的准备金保证，即每发行1枚USDT代币，其银行帐户都会有1美元的资金保障。用户可以在Tether平台进行资金查询，以保障透明度。
USDT是中心化的公司Tether发行的。在今年的4月17日之前，市场上存在着2种不同类型的USDT。
第一种是基于比特币的USDT (基于Omni协议发行)。 这种USDT存储在比特币地址上，所以每次转账（链上转账）时，都需要支付少量的比特币作为矿工费。
除了转账需要比特币作为矿工费之外，每发起一笔USDT转账，都会对应地生成一笔数量极小的比特币转账。所以，每发起一笔基于比特币的USDT转账，钱包地址中至少要有0.0002个比特币才能保证转账成功。同时，收款方在收到一笔 USDT转账时，也会收到一笔最小金额的比特币转账。
第二种是基于以太坊的USDT（基于ERC-20协议发行）。这种USDT存储在以太坊地址上，相对应的，每次转账（链上转账）时，需要消耗Gas，也就是ETH。
目前，市场上的USDT绝大部分是基于比特币的USDT，基于以太坊的USDT份额很低（约3%）。
4月17日，第三种USDT诞生了，它是基于TRON网络（波场）发行的USDT。基于TRON网络的TRC-20 USDT，存储在TRON的地址当中，充值、提现都是通过TRON网络进行，而且转账免费。
上述三种USDT，哪种转账最快呢？因为波场网络达到1500TPS，目前来说转账最快。
哪种USDT转账最安全？有人表示波场的DPoS 27名超级节点没有其它两个网络来得安全，最安全的也就只有比特币网络了。
到底选哪个USDT好？
大笔转账推荐基于比特币的USDT，折中选择基于以太坊的ERC-20 USDT，小额转账可以选择基于波场的USDT，速度更快一点。
02 充值、提现时谨防资产丢失 基于比特币的USDT，和基于以太坊的USDT，两者是不兼容、不能相互转账的。
那么，如何知道你的USDT，是属于哪一种USDT呢？
其实很简单，可以通过存储的USDT地址判断：地址是“1”开头的，属于基于比特币的USDT；地址是“0x”开头的，属于基于以太坊的USDT。换句话说，基于比特币的USDT，只能存储在比特币地址上；基于以太坊的USDT，只能存储在以太坊地址上。
至于第三种基于TRON的USDT，目前有一部分交易平台已经支持了，地址是“T”开头的。
▲ 三种USDT地址示例
无论是转账，还是从交易平台充值、提现，都需要注意分清楚将要操作的USDT是属于哪一种类型
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1808c6da8237dd0b76f3eae3d44431dc/" rel="bookmark">
			Vue使用vue-image-crop-upload实现图片的上传与显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
效果展示
具体操作
1.使用npm下载vue-image-crop-upload
2.前端代码分析
3.后端代码分析
效果展示 修改头像前
修改后
这里说明一下这个组件可以让我们在修改头像的时候可以进行裁剪的操作。
具体操作 1.使用npm下载vue-image-crop-upload npm i babel-polyfill -S npm i vue-image-crop-upload -S 2.前端代码分析 （1）imagecropperShow = true 是开启组件的元素，imagecropperShow值为false是关闭，在上传图片成功后，要将这个值设置成false来关闭组件。
（2）&lt;img :src="avatar"/&gt;图片的显示，可以在cropSuccess方法中将img设置成上传的图片， this.avatar = imgDataUrl;
&lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;!-- 图片展示 --&gt; &lt;img :src="avatar"/&gt; &lt;!-- 修改头像的按钮 --&gt; &lt;button class="btn btn-default" @click="imagecropperShow = true"&gt; 修改头像 &lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;my-upload //没有这个可能无法关闭组件 :modelValue.sync="imagecropperShow" :key="imagecropperKey" lang-type="zh" img-format="png" @crop-success="cropSuccess" @crop-upload-success="cropUploadSuccess" @crop-upload-fail="cropUploadFail" url="http://localhost:8088/upload"//这个是与后端网址 &gt;&lt;/my-upload&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 使用头像上传组件 import myUpload from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1808c6da8237dd0b76f3eae3d44431dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3ad419bd0ffa2b2b0e4fd644c1bf12e/" rel="bookmark">
			Java数据结构之哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.题目引出: 看一个实际需求，google公司的一个上机题;
有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的所有信息.
要求:不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列)
添加时，保证按照id从低到高插入
1.哈希表的介绍 散列表（Hash table，也叫哈希表),是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
2.哈希表实现思路 3.代码实现 public class HashTableDemo { public static void main(String[] args) { HashTable hashTable = new HashTable(7); Scanner scan = new Scanner(System.in); while (true){ System.out.println("添加员工:add"); System.out.println("显示员工:list"); System.out.println("退出系统:exit"); System.out.println("查找员工:find"); System.out.println("删除员工:delete"); String key = scan.next(); switch (key){ case "add": System.out.print("输入id:"); int id = scan.nextInt(); System.out.print("输入名字:"); String name=scan.next(); Employee employee = new Employee(id, name); hashTable.add(employee); break; case "list": hashTable.list(); break; case "find": System.out.print("请输入id:"); hashTable.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3ad419bd0ffa2b2b0e4fd644c1bf12e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98456bd63f2c6d6a48977495cc8ceeec/" rel="bookmark">
			node.js&#43;Express框架，前端自己创建接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装
1、安装node.js
2、安装Express框架
3、安装nodemon
二、写接口
三、连接数据库
1、安装：
2、连接数据库
3、执行
具体连接过程如下：
四、注意事项
1、跨域
这篇文章看完如果您觉得有所收获，认为还行的话，就点个赞收藏一下呗
一、安装 1、安装node.js node就不讲了，你们应该都安装过了 2、安装Express框架 官方给出的概念:Express是基于Node.js平台，快速、开发、极简的Web开发框架 通俗的理解：Express的作用和Node.js内置的http模块类似，是专门用了创建Web服务器的
在项目所处的目录中（输入cmd即可看到终端），运行如下的终端命令，即可将express安装到项目中使用：
（1）全局安装 express npm install -g express-generator （2）查看是否安装成功 express -v （3）建立后端服务器文件夹 server express server -e. （4）进入创建的文件夹 cd server （5）安装 npm i 到这里安装就结束了，目录的介绍如下
然后把文件server用vscode打开，打开控制台输入命令npm start 然后打开浏览器，输入默认地址http://localhost:3000/即可打开网页
若是想要不想使用默认端口3000，可以自己定义端口号
打开server/app.js，在文件中写以下代码
// 监听端口 app.listen(888, () =&gt; { console.log('服务器已经启动'); }) 然后重新启动服务器
3、安装nodemon nodemon是一个自动启动node文件的第三方包 。
在编写调试Node.js项目的时候，如果修改了项目的代码，则需要频繁的手动close掉，然后再重新启动，非常繁琐。可以使用nodemon（nodemon - npm）这个工具，他能够监听项目文件的变动，当代码被修改后，nodemon会自动帮我们重启项目，极大方便了开发个调试。
只能在开发阶段使用，因为他是通过watch来进行检测代码，
（1）安装 nodemon npm install -g nodemon （2）使用 nodemon 传统的方式是运行node app.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98456bd63f2c6d6a48977495cc8ceeec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c73e2f3f3b86732954de3aa7b2d1605/" rel="bookmark">
			selenium4和selenium3的区别 selenium不能使用find_element_by_class_name
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://zhuanlan.zhihu.com/p/567199598)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ebe96fbabd42cdad4947112da9fddab/" rel="bookmark">
			iOS 关于iTMSTransporter上传IPA报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因为疫情，然后就半个月才上班，今天上APP新版本的时候发现iTMSTransporter无法使用了。
一、报错 Cannot obtain the content provider public id. Please specify a provider short name using the -asc_provider option. 二、解决方法 这个好解决，主要添加-asc_provider参数即可，也就是TeamID ，
xcrun altool --list-providers -u xxx.com -p xxx 然后命令为：
/usr/local/itms/bin/iTMSTransporter -assetFile HotsMeta.ipa -u xx.com -p xxx -m upload -assetDescription AppStoreInfo.plist -asc_provider TeamID 但是，还有报错 1 package(s) were not uploaded because they had problems: { "errors": [{ "status": "401", "code": "NOT_AUTHORIZED", "title": "Authentication credentials are missing or invalid.", "detail": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ebe96fbabd42cdad4947112da9fddab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe3ae0dd779765e1826abef988a01487/" rel="bookmark">
			配置NAT【eNSP实现】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IPv4网络地址有耗尽的可能性，而IPv6地址目前又无法立刻替换现有成熟且广泛应用的IPv4网络。因此必须使用一些技术手段来延长IPv4的寿命，其中广泛使用的技术之一就是网络地址转换NAT。
NAT【Network Address Translation】是将IP数据报文报头中的IP地址转换为另一个IP地址的过程，主要用于实现内部网络【私有IP地址】访问外部网络【公有IP地址】的功能。NAT有三种类型：静态NAT、动态地址NAT以及网络地址端口转换NAPT。
NAT转换设备【实现NAT功能的网络设备】维护着地址转换表，所有经过NAT转换设备并且需要进行地址转换的报文，都会通过该表做相应转换。NAT转换设备处于内部网络和外部网络的连接处，常见的有路由器、防火墙等。
实验目的 理解NAT的应用场景掌握静态NAT的配置掌握NAT Outbound的配置掌握NAT Easy-IP的配置掌握NAT Server的配置 实验拓扑 路由器选型最好为AR2220，否则可能出现NAT语句无法发挥作用的情况。
实验步骤 如图进行基础配置，路由器接口主机号若未特别说明则与其路由器编号一致
R1: &lt;Huawei&gt;sys [Huawei]undo info-center en [Huawei]sysname R1 [R1]int g0/0/1 [R1-GigabitEthernet0/0/1]ip address 172.16.1.254 24 [R1-GigabitEthernet0/0/1]int g0/0/2 [R1-GigabitEthernet0/0/2]ip address 172.17.1.254 24 [R1-GigabitEthernet0/0/2]int g0/0/0 [R1-GigabitEthernet0/0/0]ip address 202.169.10.1 24 R2: &lt;Huawei&gt;sys [Huawei]undo info-center en [Huawei]sysname R2 [R2]int g0/0/0	[R2-GigabitEthernet0/0/0]ip address 202.169.10.2 24 [R2-GigabitEthernet0/0/0]int loopback 0 [R2-LoopBack0]ip address 202.169.20.1 24 R1: //配置默认路由，使得R1知道如何通向R2 [R1]ip route-static 0.0.0.0 0 202.169.10.2 R2: //配置默认路由，使得R2知道如何通向R1 [R2]ip route-static 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe3ae0dd779765e1826abef988a01487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64cc267181f49f019cc5603c67d2a188/" rel="bookmark">
			冒号 : 与双冒号 :: 的C&#43;&#43;用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.冒号（:）用法
（1）类名冒号：定义类的继承。
（2）构造函数后面的冒号：分割作用，类给成员变量赋值。
初始化列表，更适用于成员变量的常量const型。
struct _XXX{
_XXX() : y(0xc0) {}
};
（3） public:和private:后面的冒号：后面定义的所有成员都是公有或私有的。直到下一个"public:”或"private:”出现为止。"private:"为默认处理。
（4）表示变量占几个bit空间
typedef struct _XXX{
unsigned char a:4;
unsigned char c;
} ; XXX
2. 作用域限定符号::
作用：
（1） 在类外部声明成员函数。void Point::Area(){};
（2）调用类的静态方法： 如：CDisplay::display()。
（3）调用全局函数；表示引用成员函数变量及作用域，作用域成员运算符 例：System::Math::Sqrt() 相当于System.Math.Sqrt()。
如果 ::前面没有域名 那么就是全局。
双冒号前面可以是 类名，命名空间来限定双冒号后面的内容从哪里读取。
————————————————
版权声明：本文为CSDN博主「兔子爱读书」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ztf312/article/details/50898211
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b890ee25e707dc6881670b80db25938/" rel="bookmark">
			java：定义一个类、方法max，求double数组最大值并返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 package one; public class two { public static void main(String[] args) { A01 a1 = new A01(); double[] arr = {16,2,4};//将arr数组的初始值放这里 //注意是数据类型 变量名=初始值，而不是调用a1.方法（传值） Double res = a1.max(arr);//用一个Double类型的值接收 if (res!=null) {	System.out.println(res); }else { System.out.println("输入有误"); }	} } //定义类A01,方法max，求double数组最大值，并返回 class A01{ public Double max(double[] arr) {//返回一个包装类Double,每个基本类型都有一个 //包装类，首字母大写，除了int和char if (arr!=null&amp;&amp;arr.length&gt;0) { //如果这里没有arr!=null&amp;&amp;则在输入null时会报错 double max = arr[0];//max可同名放在方法里	for (int i = 0; i &lt; arr.length; i++) { if (max&lt;arr[i]) { max=arr[i]; } } return max; }else { return null;//返回为空，如果类型是double会报错 //return -1不合适，因为数组可能有-1 } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c640ed32793d2d1b3dd5b73977e462e/" rel="bookmark">
			如何使用全局变量QT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		兩種方法：
第一：使用extern關鍵字聲明（不推薦，破壞了封裝性）
第二：新建一個類，存放全局的變量，函數 第一：使用extern關鍵字聲明（不推薦，破壞了封裝性） 在一个头文件中声明int var_name全局变量,在另一个cpp文件中引用此变量: extern int var_name;
指出var_name是在外部文件定时的变量,编译器会自动在所有文件中查找var_name的定义,如:
aaa.h:
#ifndef AAA_H
#define AAA_H
int var_name; static bool fun() { dosth }
#endif // AAA_H
main.cpp:
#include &lt;QtCore/QCoreApplication&gt;
#include "aaa.h"
#include &lt;qdebug.h&gt;
extern int var_name;//只需导入即可,不可再定义,函數可用也可不用extren聲明
int main(int argc, char *argv[])
{
QCoreApplication a(argc, argv); if (!dun()) return 1;
qDebug()&lt;&lt;var_name;//全局整形变量会赋默认值0
return a.exec();
}
第二：新建一個類，存放全局的變量，函數（static关键字） 在.h文件下定义类 class temp{ private: static int x; } 在.cpp下定义 int temp::x=0; 这样就可以当全局变量使用了，
以下为转来的实例 qt中的全局变量_xiehuin的博客-CSDN博客
这一段开发一个程序，需要多个源文件，包括若干个头文件和若干个定义文件。因此如何在多个源程序间开发传递变量就成了一个关键问题。一般来说在多个源程序间传递变量大概有两种方法，一是利用extern声明全局变量来进行传递，二是将全局变量定义成一个类的静态变量，通过类名：：变量名进行调用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c640ed32793d2d1b3dd5b73977e462e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54ee5d2c36312944873212a9e8aad7a3/" rel="bookmark">
			【NLP论文翻译】基于显著性感知主题建模的面向主题的客户服务口语对话摘要
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本博客为博主论文阅读记录，原论文和github地址如下：
原论文下载：https://ojs.aaai.org/index.php/AAAI/article/view/17723/17530
代码：https://github.com/RowitZou/topic-dialog-summ
本篇博客所介绍论文为AAAI 2021论文
NLP领域有哪些国际顶级会议？
对话文本摘要概述
仅供学习，请勿转载。如有侵权，请联系作者删除。
Topic-Oriented Spoken Dialogue Summarization for Customer Service with Saliency-Aware Topic Modeling 摘要
在客户服务系统中，对话摘要可以通过自动创建长时间的用户和客服试图解决有关特定主题的问题对话的摘要来提高服务效率。在这项工作中，我们专注于主题导向(topic-oriented)的对话摘要，它生成高度抽象的摘要，保留了对话的主要思想(main ideas)。在口语对话中，大量的对话噪音和常用语可能会模糊潜在的信息内容，使一般主题建模方法难以应用。此外，对于客户服务来说，特定于角色的信息很重要，也是摘要中不可或缺的一部分。为了有效地对对话进行主题建模并捕获多角色信息，在这项工作中，我们提出了一种新的主题增强两阶段对话摘要器（TDS）和显著性感知神经主题模型（SATM），用于面向主题的客服对话摘要。对真实的中国客户服务数据集的综合研究表明，我们的方法相对于几个强大的基线具有优越性。
这里common semantics指的是常用语，例如thanks,humm，please？还是共同语义的表达？我认为作者的意思是前者。
1 Introduction 在一个活跃的客户服务系统中，在用户(customers)和客服(agents)之间实时生成大量传递重要信息的对话。在这样的背景下，如何有效地利用对话信息成为一个非常重要的问题。对话摘要是一项旨在浓缩对话，同时保留显著(salient)信息的任务，它可以通过自动创建简明摘要来提高服务效率，避免耗时的对话阅读和理解。
大多数现有的对话摘要工作主要集中在冗长而复杂的口头对话，如会议和法庭辩论，通常通过串联所有对话点来摘要，以保持完整的对话流程。然而，在客服场景中，对话演讲者通常有强烈而明确的动机，并致力于解决有关特定主题的问题。更好地了解用户和客服的意图，在这项工作中，我们专注于面向主题的对话摘要，它旨在提取语义一致的主题并生成高度抽象的摘要，以保持对话的主要思想。
最近，已经引入了数十种主题感知模型(topic-aware models)来帮助文档摘要任务。然而，口语对话往往是由话语(utterances)组成的，而不是传统文献中符合语法规则的句子。突出信息(Salient information)在这些话语中被稀释，并伴随着常用语(common semantics)。此外，噪音以不相关的聊天和转录错误的形式大量存在。这些常见或嘈杂的单词，例如，请(please)、谢谢(thanks)和哼(humm)，通常频率很高，并与其他信息性单词同时出现。因此，一般的基于主题的方法很难统计地区分有用和无用内容的混合，从而导致对主题分布的不准确估计。此外，在客服对话场景，参与角色是稳定的：用户倾向于提出问题，客服需要提供解决方案。图1显示了一个真实的客服对话以及一个摘要，其中包括两位发言者的关键信息。因此，该模型还被期望捕获角色信息，以帮助显著信息估计。
C表示用户，A表示客服。摘要包含客户的问题（红色）和客服的解决方案（蓝色），分别以红色和蓝色突出显示。
在这项工作中，我们提出了一种新的两阶段神经模型和一种增强的主题建模方法，用于口语对话摘要。第一，为了更好地将潜在信息内容与丰富的常用语和对话噪声区分开来，我们引入了一种显著性感知主题模型（SATM），其中主题被分成两组：信息性主题(informative topics)和其他主题(other topics)。在话题建模的生成过程中，我们限制了与黄金摘要(gold summary)相对应的每个突出单词从信息性话题中生成，而对话中的其他单词（包括噪声和常见的单词）仅从其他话题中生成。通过这个训练过程，SATM可以将对话中的每个单词与显著性（信息主题）或不显著性（其他主题）联系起来。第二，为了获取角色信息并从对话中提取语义主题，我们使用SATM分别对用户话语、客服话语和整体对话进行多角色主题建模。然后，设计了一个主题增强的两阶段对话摘要器（TDS），它由一个话语提取器(utterance extractor)和抽象提取器(abstractive refiner)组成。它可以通过了解主题的注意力机制(topic-informed attention mechanism)在话语水平和单词水平上提取与主题相关的显著信息。
此外，由于缺乏合适的公共基准，我们收集了一个具有高度抽象摘要的真实客服对话数据集。在所提出的数据集上的实验结果表明，我们的模型在各种指标下表现出一系列强基线。代码、数据集和补充可以在Github上找到。
总之，我们的贡献如下：
我们引入一种新的主题模型，通过直接学习单词显著性对应关系，可以感知对话中潜在的信息内容。基于多角色主题建模，我们提出了一个主题增强的两阶段模型，该模型具有了解主题的注意力机制用于执行显著性评估和客服对话摘要。在收集数据集上的实验结果表明我们的方法在不同方面的有效性。 2 Method 在本节中，我们将详细介绍显著性感知主题模型（SATM）和主题增强的两阶段对话摘要模型（TDS）。SATM基于信息主题和其他主题推断多角色主题表示。然后，主题信息通过主题通知注意机制被合并到TDS的提取器和精炼器中。
我们模型的总体架构如图2所示。
总体结构很重要！！！图二很重要！！！结合第二部分Method的所有内容理解。
extract提取出显著性的语句，通过refine，refine是精炼/提炼？
2.1 Saliency-Aware Neural Topic Model（SATM） 我们提出的SATM基于具有变分推理的神经主题模型（NTM），该模型通过神经网络从每个对话d中推断主题分布θ。我们用一种新的生成策略来扩展NTM，以学习单词显著性相关性。SATM与NTM的架构比较如图3所示。
图3得结构很重要，注意图3-(b)
SATM公式整理
2.1.1 Basic NTM with Variational Inference 从形式上讲，在去掉停止词的情况下给定对话d∈R^|V|的词袋表示，我们构建了一个推理网络q（θ|d）来近似后验p（θ| d），其中V是词典(vocabulary)。q（θ|d）由一个函数θ=f（z）组成，该函数以对角高斯分布z∼ N（µ（d），σˆ2（d））为条件，其中其中µ（d）和σ（d）是神经网络。在实践中，我们可以采样zˆ使用重新参数化技巧通过ˆz=µ（d）+eps·σ（d），eps从N（0，Iˆ2）中采样。然后，采样的ˆθ∈ RˆK导出为：
Wθ，bθ是可训练参数，K表示主题数。然后，我们定义β∈ RˆK×|V|, φ ∈ RˆK×H，e∈Rˆ|V |×H分别表示主题词分布、主题向量和词向量。这里，H是向量的维数。φ是随机初始化的，e可以是预先训练的词嵌入。β用φ和e计算如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54ee5d2c36312944873212a9e8aad7a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de42ea394f0eda34f81f103ec6d136fe/" rel="bookmark">
			毕业小半年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		毕业小半年 国考差一分，省考差一名，就这样和自己的目标擦肩而过了两次。期间手机卡还坏了，一直懒得去修，换了个新的手机卡，忙着毕业的事情和考事业单位。懒着懒着，虽然有班上了，但是手机号也成空号了，账号一直登录不了。无意间刷到自己最后一篇博客，突然有种续写的执念。总而言之，顺利（其实也并不顺利）毕业了，到事业单位上班啦，做总务的工作，暂时还是充满热情，感觉比读研轻松了很多，主要是因为不用做那个很可恶的课题了，期待去学习自己想学的东西，成为自己想成为的样子。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e35123849cd30ab3582a7f58e4c04a/" rel="bookmark">
			【css】滚动条webkit-scrollbar样式重置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ::-webkit-scrollbar 仅在基于 Blink 或 WebKit 的浏览器（例如，Chrome、Edge、Opera、Safari、iOS 上所有的浏览器，以及其它基于 WebKit 的浏览器）上可用(修正版)
伪类注解::-webkit-scrollbar滚动条整体部分::-webkit-scrollbar-button滚动条两端的按钮。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。::-webkit-scrollbar-track外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果。::-webkit-scrollbar-track-piece内层轨道，滚动条中间部分（除去）。::-webkit-scrollbar-thumb滚动条里面可以拖动的那部分::-webkit-scrollbar-corner边角::-webkit-resizer定义右下角拖动块的样式 ::-webkit-scrollbar { width: 4px; height: 4px; } ::-webkit-scrollbar-track{ border-radius: 10px; background-color: transparent; } ::-webkit-scrollbar-thumb { border-radius: 10px; background-color: rgba(0, 0, 0, 0.3); } ::-webkit-scrollbar-corner{ background-color: transparent; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133abe7dbfa352d26948b99a9020a8d5/" rel="bookmark">
			C# Word文档中插入、提取图片，文字替换图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Download Files: http://www.c-sharpcorner.com/UploadFile/26b237/image-operations-using-word-document-in-C-Sharp/download/ImageOperationsInWord.zip
如文章代码学习需要解释，可以参考视频教程c# 2015 &amp; 2017 视频教程|xin3721自学网c#入门经典视频教程https://www.xin3721.com/eschool/CSharpxin3721/
简介 在这篇文章中我们可以学到在C#程序中使用一个Word文档对图像的各种操作。图像会比阅读文字更有吸引力，而且图像是与内容紧密相关的。有时图像可以将内容描述的更为清晰，就像使用图表显示某一周期内的数据变化。
Spire.Doc for .NET是一个的基于.NET 的专业Word组件，它不仅可以在脱离微软office自动化的情况下快速地生成、打开、修改、保存Word文档 ，还支持用户使用C#将图像插入Word并根据页面设置它的大小。这篇就是介绍给大家一个简单的方法来插入图像----使用Spire.Doc for .NET。
以下就是我们要学习的操作步骤：
1、在Word文档中插入一张图片。
2、从Word文档中提取一张图片。
3、在Word文档中将图片替换成文字。
在进行这些操作之前我们要先创建Word文档。在这里我使用Spire.Doc for .NET来创建文档并完成后续的操作。
创建一个控制台程序来做演示。根据以下步骤： 1、打开Visual Studio 2、"File" -&gt; "New" -&gt; "Project..." 3、选择C#语言然后选择控制台程序并命名为“ImageOperationInWord” 4、单击OK。
在Word中插入图片 首先，创建新的Word文档并为之添加章节和段。然后，使用p.AppendPicture(Image)方法将图像插入到新段中。设置图像的高度和宽度属性来规定图片大小。使用以下代码来用C#把图片插入到Word中。
Namespace 使用：
using Spire.Doc; using Spire.Doc.Documents; using Spire.Doc.Fields; using System.Drawing; 在Word文档中创建并插入图像：
private static void InsertImage() { //Create Document Document document = new Document(); Section s = document.AddSection(); Paragraph p = s.AddParagraph(); //Insert Image and Set Its Size DocPicture Pic = p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/133abe7dbfa352d26948b99a9020a8d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/109cec5c158b1cae6cb4145f0a331ccb/" rel="bookmark">
			Android源码编译（基于Ubuntu18.0.4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、环境搭建硬件要求软件要求操作系统和 JDK主要软件包 软件安装Git安装repo工具安装安装 openJDK 8其他依赖安装 二、源码下载建立源码文件夹初始化仓库源码同步小结 三、源码编译四、常见错误内存不足导致编译失败脚本文件导致编译出错模拟器开启失败其他错误 参考资料 一、环境搭建 硬件要求 如果是 Gingerbread (2.3.x) 及更高版本（包括 master 分支），需要使用 64 位环境。如果是较低的版本，则可以在 32 位系统中进行编译。如果是校验代码，至少需要 100GB 可用磁盘空间；如果要进行编译，则还需要 150GB。如果要进行多次编译或使用 ccache，则需要更多空间。如果您在虚拟机中运行 Linux，则至少需要 16GB 的 RAM/交换空间。 软件要求 操作系统和 JDK 操作系统要求 Android版本Ubuntu最低版本Android 6.0至AOSP masterUbuntu 14.04Android 2.3.x至Android 5.xUbuntu 12.04Android 1.5至Android 2.2.xUbuntu 10.04 对于 Java 开发套件 (JDK)，需要注意的是 AOSP 中 Android 的 master 分支带有预编译版本的 OpenJDK；因此无需进行额外安装。较低的版本则需要单独进行安装，包括 Android 7.0 (Nougat) - Android 8.0 (O)：Ubuntu - OpenJDK 8；Mac OS - jdk 8u45 或更高版本Android 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/109cec5c158b1cae6cb4145f0a331ccb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce12a3dcd834c5681e1fd7b53bcf929/" rel="bookmark">
			web基础漏洞之CSRF（跨站请求伪造漏洞)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cookie session token 我觉得在开始学习CSRF之前应该先学会区分这三种东西：cookie session token
cookie: Cookie，有时也用其复数形式 Cookies。类型为“小型文本文件”，是某些网站为了辨别用户身份，进行Session跟踪而储存在用户本地终端上的数据（通常经过加密），由用户客户端计算机暂时或永久保存的信息
浏览器第一次访问服务端时，服务器此时肯定不知道他的身份，所以创建一个独特的身份标识数据，格式为key=value，放入到Set-Cookie字段里，随着响应报文发给浏览器。浏览器看到有Set-Cookie字段以后就知道这是服务器给的身份标识，于是就保存起来，下次请求时会自动将此key=value值放入到Cookie字段中发给服务端。服务端收到请求报文后，发现Cookie字段中有值，就能根据此值识别用户的身份然后提供个性化的服务。 session:
如果将账户的一些信息都存入Cookie中的话，一旦信息被拦截，那么我们所有的账户信息都会丢失掉。所以就出现了Session，在一次会话中将重要信息保存在Session中，浏览器只记录SessionId一个SessionId对应一次会话请求。
token:
Session是将要验证的信息存储在服务端，并以Session Id和数据进行对应，SessionId由客户端存储，在请求时将SessionId也带过去，因此实现了状态的对应。而Token是在服务端将用户信息经过Base64Url编码过后传给在客户端，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了，这个方法叫做JWT(Json Web Token)。
概念： 跨站请求伪造（Cross-Site Request Forgery，简称CSRF）是指，攻击者可能利用网页中的恶意代码强迫受害者浏览器向被攻击的Web站点发送伪造的请求，篡夺受害者的认证Cookie等身份信息，从而假冒受害者对目标站点执行指定的操作。
攻击原理： 总结一下：要想实现这个攻击，需要满足：登录受信任网站A，并在本地生成Cookie。在不登出A的情况下，访问危险网站B。
1、客户端通过账户密码登录访问网站A。
2、网站A验证客户端的账号密码，成功则生成一个sessionlD，并返回给客户端存储在浏览器中。
3、该客户端Tab—个新页面访问了网站B。
4、网站B自动触发要求该客户端访问网站A。(即在网站B中有链接指向网站A)
5、客户端通过网站B中的链接访问网站A。(此时携带有合法的SessionID进行访问站A的)
6、此时网站A只需检验sessionIlD是否合法，合法则执行相应的操作。(因此具体啥工具就得看链接，以及网站B要求访问时携带的数据
csrf的两类： 一：Get类型的csrf
仅仅须要一个HTTP请求。就能够构造一次简单的CSRF
样例：
银行站点A：它以GET请求来完毕银行转账的操作，如：
http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 危险站点B：它里面有一段HTML的代码例如以下：
&lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先。你登录了银行站点A，然后访问危险站点B，噢，这时你会发现你的银行账户少了1000块。
为什么会这样呢？原因是银行站点A违反了HTTP规范，使用GET请求更新资源。
在访问危险站点B的之前。你已经登录了银行站点A，而B中的 一个合法的请求，但这里被不法分子利用了）。
所以你的浏览器会带上你的银行站点A的Cookie发出Get请求，去获取资源以GET的方式请求第三方资源（这里的第三方就是指银行站点了）
demo：dvwa:low level
这是一个修改密码的界面，然后我们点击右下角查看源码，
首先分析一下源码，他这个首先就是通过get方式传进password_new和password_conf这两个参数，然后判断用户输入的这两个参数是否一样。没有什么防控csrf的措施，所以很容易受到CSRF的攻击。
于是构造url:
http://64336ea7-ad15-47e2-bf11-17a61a7c78e4.node4.buuoj.cn:81/vulnerabilities /csrf/?password_new=123456&amp;password_conf=123456&amp;change=change 登陆成功。over
现实中，攻击者往往会先搭建一个站点，然后上传一个html文档，该文档中含有恶意的链接。让后将这个html文档的地址发送给用户，用户一旦点击将会自动加载恶意链接完成攻击。
2. POST类型的CSRF:
在普通用户的眼中，点击网页-&gt;打开试看视频-&gt;购买视频是一个很正常的一个流程。可是在攻击者的眼中可以算正常但又不正常的，当然不正常的情况下，是在开发者安全意识不足所造成的。攻击者在购买处抓到购买时候网站处理购买(扣除)用户余额的地址。
比如:
/coures/user/handler666buy.php&lt;/font&gt; 通过提交表单，buy.php处理购买的信息，这里的666为视频ID。那么攻击者现在构造一个链接，链接中包含以下内容。
&lt;form action=/coures/user/handler/666/buy method=POST&gt; &lt;input type="text" name="xx" value="xx" /&gt; &lt;/form&gt; &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 当用户访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作，自动购买了id为666的视频，从而导致受害者余额扣除。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fce12a3dcd834c5681e1fd7b53bcf929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a310ff9096446c50bb3c3cdd302edb48/" rel="bookmark">
			51单片机 （七）数码管
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数码管介绍：
LED数码管：数码管是一种简单、廉价的显示器，是由多个发光二极管封装在一起组成“8”字型的器件。
一个数码管是由八个二极管所组成的，我们分别给它命名为 a、b、c、d、e、 f、g、dp；如果八个二极管的阳极连接在一起，那么我们就称这个为共阳极数码管，如果八个二极管的阴极连接在一起，那么我们就称这个数码管为共阴极数码管。由上图可见，八个发光二极管围成了一个 8 字形，那么我们要让它显示什么数字或者形状只需要点亮对应的二极管即可。 这个是单个数码管的硬件电路图 这个是多个数码管的硬件电路图
这种数码管点亮的时候需要我们对它进行选择，也就是点亮哪一个，这种选择方式我们叫做‘位选’；而当我们选择数码管之后，我们让被选中的数码管显示何种数字或者形状，这种我们称为‘段选’。 这个是实验所用开发板的数码管原理图 在实际当中，单片机所发出的电流是微安(uA)级别的，但是驱动数码管点亮的电流需要 10 毫安(mA),于是我们会使用电流放大装置来使单片机发出的电流 被放大。有些开发板所用的电流放大装置为三极管，而有些开发板的电流放大装置为锁存器。图中的 74HC245 即是锁存器。 如何点亮数码管 在上面我们有介绍到单个数码管是由八个发光二极管所组成的；点亮数码管的方式跟点亮流水灯的方式类似。我们实验室所用使用的开发板有八个 LED 灯，我们是通过十六进制数来选择哪个 LED 灯亮或者灭，那么我们的数码管也是如此。 首先我们来重新看一遍单个数码管的原理图 当我们赋给发光二极管 a 的值为 0 的时候，发光二极管 a 就会被点亮，同理，我们知道当给哪一个发光二极管赋予低电平时它就会被点亮。 我们现在将单个数码管的八个发光二极管进行一个排序，排序顺序如下： 我们现在想要使单个数码管显示数字 1，那么我们对应所需要点亮的发光二极管就是 b 和 c。那么此时我们给这八个发光二极管所赋的值就如下： 对应转化称十六进制数就是 0x9f; 下面为示例代码和开发板的显示详情： 我们现在可以看到，数码管并没有按照我们的预期显示数字 1 ，我们刚才说显示数字 1 需要我们点亮发光二极管 b 和 c ，但是开发板显示的却是 f 和 g ，由此我们可以推测，我们排序发光二极管的时候，将二极管的顺序搞反了，所以我们现在对单个数码管的八个发光二极管进行重新排序： 那么我们现在重新对 c 和 b 进行点亮操作，这个时候的赋值如下：
这个时候的十六进制数表示为：0xf9 下面为示例代码和开发板的显示详情： 现在我们看到开发板上的第一个数码管显示了数字 1 ，证明我们现在的代码是正确的。 如何同时点亮多个数码管 如果我们仔细观察我们可以发现，数码管在我们的生活当中无处不在，例如教室的电子时钟。 现在我们思考一个问题，数码管这么多个，它是同时亮着显示的吗？答案是否定的，厂家为了节省开发板的能源损耗，将数码管设置为在某一个时间段只点亮单个数码管，而我们的人眼看到的数码管它好像是全部亮着的，这是利用了人的视觉的暂留效应。当一个东西闪得很快的时候，我们人眼是观察不出来的，所以这个时候我们看着它好像就是一直亮着的。我们的开发板多个数码 管就是利用了这样的原理。 下面为示例代码 #include &lt;REGX52.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a310ff9096446c50bb3c3cdd302edb48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab50f4bc4ab56b9091afe6d7f69acb5b/" rel="bookmark">
			【数据库】查询所有表名及表注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查询所有表名及表注释： SELECT TABLE_NAME,COMMENTS from all_tab_comments where OWNER='PORTAL' 2、查询所有表名： 方法一：
指定Oracle用户名（即schema(模式)，即库名）进行查询
-- 模式名必须是大写 SELECT * FROM all_tables WHERE OWNER = '模式名' -- 加 ORDER BY TABLE_NAME 是让结果按照表名顺序展示 SELECT * FROM all_tables WHERE OWNER = '模式名' ORDER BY TABLE_NAME 方法二：
查看当前登录用户（schema）下的表
SELECT * FROM user_tables -- 加 ORDER BY TABLE_NAME 是让结果按照表名顺序展示 SELECT * FROM user_tables ORDER BY TABLE_NAME 注释表也一样，all_tab_comments 和 user_tab_comments
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b411668270efa7810ae3e8f13f00188/" rel="bookmark">
			pycharm创建新的conda虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、安装conda，并且添加环境变量
2、进入pycharm，新建虚拟环境
红框选择，虚拟环境的目录，需要是空的
第二个箭头，是安装的conda路径，弄好之后，点击ok，等待完成即可
conda简单使用 conda env list # 查看windows中所有的conda环境 conda activate (env1) # 括号中是需要激活的环境的name conda deactivate # 退出当前conda环境 # 在conda虚拟环境中pip安装模块 conda activate (env1) # 先激活你需要安装模块的环境 pip install (name) # 括号中需要安装的模块名称 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f80eb2291995d642aa188eb5e83fdcfd/" rel="bookmark">
			数学符号大全（量词符号、代数符号等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		量词符号 任意：∀ 存在：∃ 且：∧ 或：∨ 非：﹁ 数学符号 ≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ⊥ ‖ ∠ ⌒ ≌ ∽ √ （） 【】｛｝ Ⅰ Ⅱ ⊕ ⊙∥α β γ δ ε ζ η θ Δ
Α	α	alpha	alfa	阿耳法 Β	β	beta	beta	贝塔 Γ	γ	gamma	gamma	伽马 Δ	δ	deta	delta	德耳塔 Ε	ε	epsilon	epsilon	艾普西隆 Ζ	ζ	zeta	zeta	截塔 Η	η	eta	eta	艾塔 Θ	θ	theta	θita	西塔 Ι	ι	iota	iota	约塔 Κ	κ	kappa	kappa	卡帕 ∧	λ	lambda	lambda	兰姆达 Μ	μ	mu	miu	缪 Ν	ν	nu	niu	纽 Ξ	ξ	xi	ksi	可塞 Ο	ο	omicron	omikron	奥密可戎 ∏	π	pi	pai	派 Ρ	ρ	rho	rou	柔 ∑	σ	sigma	sigma	西格马 Τ	τ	tau	tau	套 Υ	υ	upsilon	jupsilon	衣普西隆 Φ	φ	phi	fai	斐 Χ	χ	chi	khai	喜 Ψ	ψ	psi	psai	普西 Ω	ω	omega	omiga	欧米伽 常用数学输入符号： ≈ ≡ ≠ ＝ ≤≥ ＜ ＞ ≮ ≯ ∷ ± ＋ － × ÷ ／ ∫ ∮ ∝ ∞ ∧ ∨ ∑ ∏ ∪ ∩ ∈ ∵ ∴ ≱ ‖ ∠ ≲ ≌ ∸ √ （） 【】｛｝ Ⅰ Ⅱ ⊕ ≰∥α β γ δ ε δ ε ζ Δ 公式输入符号 ≈≡≠＝≤≥＜＞≮≯∷±＋－×÷／∫∮∝∞∧∨∑∏∪∩∈∵∴≱‖∠≲≰≌∸√ 数学符号（理科符号）——运算符号 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f80eb2291995d642aa188eb5e83fdcfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e54700bad0a7c330aaaa9a504bf2dd/" rel="bookmark">
			VS2022快捷键修改 快速注释 块(行)注释 ctrl &#43;/
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 配置完成之后的效果是： Ctrl + / 块注释
Ctrl+Shift+/ 取消块注释
注：
①当光标勾选范围如下图时，按Ctrl+/，会出现/* */的块注释
效果图：
②当光标勾选范围如下图时，按Ctrl+/，会出现 // 的行注释
效果图：
1.点击“工具-&gt;选项”。 2.点击左边菜单“环境-&gt;键盘”，在命令搜索框输入“注释”。 3、按图中所示进行 移除操作 4、按图中所示进行添加快捷键操作 5、点击确定即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c26ca5ba5870847f6281a32db452c98/" rel="bookmark">
			Error: The project seems to require yarn but it‘s not installed.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天把之前做过的vue项目拷贝到新电脑上，运行启动命令后发现报了如下错误：
我查了一下资料，我是这么解决的：
是因为项目中存在：yarn.lock 文件，先把这个文件删除掉。
把这个文件删除后，执行如下命令：
npm install -g yarn 下载完成后重新启动文件。
有的时候遇到安装依赖装不上的问题，可以执行这个命令：
npm i --force 强制安装依赖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d6c0560bdfb669c4d771d25f733760/" rel="bookmark">
			本地镜像发布到阿里云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.本地镜像发布到公有仓库步骤 1.登录阿里云控制台（我之前手机号注册的，登录选主账号登录-手机号登录）
https://home.console.aliyun.com/home/dashboard/ProductAndService
2.打开镜像容器服务，打开之前创建的个人实例
3.打开‘命名空间’—‘创建命名空间’，并设置仓库类型为”公开“。
4.打开”镜像仓库“–”选择刚创建的命名空间“—”创建镜像仓库“
5.创建完仓库后会自动生成一堆命令，按要求操作就行。复制黏贴，修改一下。
注意：
二.本地镜像发布到私有库流程 DockerHub, 阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队用，基于公司内部项目构建镜像。Docker Registry这是官方提供的工具，可用于构建私有镜像仓库。
1.下载镜像Docker Registry 2.运行私有库Registry，相当于本地有个私有Docker Hub 3.案例演示创建一个新镜像，ubuntu安装ifconfig命令 4.curl验证私服库上有什么镜像 #这时是空的，没有镜像 5将新镜像修myubuntu:1.1.0修改符合私服规范的Tag -----&gt; 公式：docker tag 镜像:Tag Host:Port/Repository:Tag 6.修改配置文件使之支持http 7.push推送到私服库 8.curl验证私服库上有什么镜像 #这时应该能看到推送上去的镜像 9.pull到本地并成功运行 docker pull registry docker run -d -p 5000:5000 -v /xman/myregistry/:/tmp/registry --privileged=true registry #默认情况下，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调，xman是用户名 docker run -it ubuntu /bin/bash apt-get update apt-get install -y ifconfig 按ctrl+q+p退出，获得正在运行的unbuntu的容器id进行commit命令 docker commit -m='add ifconfig' -a='xman' 容器id myubuntu:1.1.0 curl -XGET http://172.17.0.1:5000/v2/_catalog #查看私有仓库有哪些镜像，这个ip是你宿主机的ip（localhost），用ifconfig查看，后面的写死，（其实这里的ip写错了，写的是docker0的ip，也能跑通，貌似是因为桥接的是宿主机的网络。用localhost也能跑通= =） 按照公式修改符合私服规范： docker tag 镜像:Tag Host:Port/Repository:Tag ----&gt; tag是写死的，Tag是版本号 docker tag myubuntu:1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37d6c0560bdfb669c4d771d25f733760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d3030da3528d2f341fa8fb2646d89d/" rel="bookmark">
			ADC测试杂谈一：配置基于matlab&#43;quartus的测试环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 ADC的测试比较复杂，除了要有相对干净的信号源/电源设备、布局合理的PCB板卡，一套稳定的数据读取接口也必不可少。对于批量生产的商业ADC，芯片测试一般采用NI或者国内厂商的整套方案；而对于实验室阶段的小规模debug，一般采用MCU/FPGA将数据读取后传输到主机进行分析。相比于MCU常用的UART串口，FPGA的JTAG通信更快。
本系列主要介绍基于Altera FPGA的中低速ADC测试方法，高速ADC不做讨论。
本篇博文主要讲matlab读取FPGA数据的方法及相关软件配置。
一、整体架构 一般ADC常见接口为并行接口或串行，FPGA可以轻松地从ADC抓取并行数据或者自定义一个spi接口来抓取串行数据。在Altera器件专用的quartus工具中，可以通过signaltap接口直接访问FPGA上的数据，将ADC的一批量化数据保存下来进行分析。
为了更便捷的读取数据，可以采用matlab的alt_signaltap_run函数抓取数据，然后直接进行ADC领域常见的静态分析或者动态分析。
二、软件配置 quartus端的相关配置如链接所示：
https://blog.csdn.net/woshiyuzhoushizhe/article/details/83346228 为了让matlab识别到alt_signaltap_run函数，需要将quartus的bin64路径添加到matlab的path和系统的path环境变量中，两者缺一不可。
此时，在matlab中运行data=alt_signaltap_run(‘stp地址’)即可取出FPGA里的数据，便于做进一步的数据分析。
三、常见的bug 3.1 JTAG误码 JTAG接口本身有误码率，所以取数据过程可能会丢失几个点。但是对于16384点以下的fft运算还是可以满足的；
3.2 signaltap恶化时序 signaltap消耗了更多的FPGA资源，时序可能会恶化；因此，建议对主要的时钟做一下约束；
3.3 matlab调用alt_signaltap_run失败 由于JTAG连接错误等问题，matlab调用alt_signaltap_run可能会失败，必须重启matlab才能继续读取数据。Intel官方推荐的解决方式是在matlab里运行：
clear alt_signaltap_run 具体参考如下链接：
https://www.intel.cn/content/www/cn/zh/support/programmable/articles/000081528.html 四、总结 本文简单介绍了如何通过matlab接收FPGA的数据，后面会简单地介绍如何通过matlab向FPGA发送数据以及如何通过FPGA向ADC发送数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c09cd7e149232b5a6cfe037ee3fc7f/" rel="bookmark">
			frp内网穿透教程，ssh远程连接，服务自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 有时候我们需要从公网中远程连接自己的设备（SSH，远程桌面，远程文件等)，虽然诸如teamviewer和向日葵等可以较为方便的实现连接操作，但是网络不稳定，操作卡顿的现象却让我们十分难受。
frp内网穿透可以帮助我们实现自己的需求，它是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。具体介绍请点开前面的链接查看官方文档。
先简单看一下技术原理，参见下图[1]：
图中VPS即是frps(service)，待远程连接的电脑就是frpc(client)。
我们需要借助一台VPS(虚拟主机)来完成中转任务。
准备工作 一台VPS(或者你有公网IP的实体主机)，可以参考之前的文章，vultr新建虚拟主机待远程连接的电脑 VPS服务器端部署 假设你VPS上装的是Debian或者Ubuntu的64位系统，这里他俩并没有什么区别。
远程ssh连接上服务器
下载frp到vps，执行以下命令：
wget https://github.com/fatedier/frp/releases/download/v0.39.1/frp_0.39.1_linux_amd64.tar.gz ps:本教程更新时frp最新版本是V0.39.1，请点击前方连接到官网下载最新版
解压:
tar -zxvf frp_0.39.1.0_linux_amd64.tar.gz 复制到新的frp文件夹：
cp -r frp_0.39.1.0_linux_amd64 frp 进入新目录：
cd frp 查看文件
ls -a 里面会包含frps, frps.ini, frpc, frpc.ini 等文件
这里我们是部署服务器端，所以删除客户端client的文件：
rm frpc rm frpc.ini 修改服务器端文件配置，打开frps.ini
vim frps.ini 填写以下内容[1]：
[common] bind_port = 7000 dashboard_port = 7500 token = mypwd dashboard_user = root dashboard_pwd = 123456 vhost_http_port = 10080 vhost_https_port = 10443 # frp日志配置 log_file = /var/log/frps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56c09cd7e149232b5a6cfe037ee3fc7f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/053fe4eb8aeeddf3c1babbe2cb031b41/" rel="bookmark">
			python求字符串最大回文串（LeedCode练习题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述： 即在一个给定的或者用户键盘输入的字符串中输出一个长度最长的头尾相同的子字符串。
示例1：
输入：s = “babad” 输出：“bab”
解释：“aba” 同样是符合题意的答案。
方法1：暴力循环法 即遍历所有子串，判断每一个子串是否为回文串。
一：利用while循环遍历
def get_reverstring(string): substring_length = len(string) while substring_length &gt; 0: for i in range(len(string) - substring_length + 1): temp = string[i: i + substring_length] if temp == temp[::-1]: return temp substring_length -= 1 print (get_reverstring("buabfafbucbubwcaw")) 二：设立头尾两个游标遍历
def get_reverstring(str) -&gt; str: length = len(str) max_substring = 0 if str == '' or length == 1: return str for i in range(length): for j in range(length,i,-1): if str[i:j] == str[i:j][::-1] and (j-1) &gt; max_substring: max_substring = (j-1) temp_result_str = str[i:j] break return temp_result_str print (get_reverstring("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/053fe4eb8aeeddf3c1babbe2cb031b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9f20236e4062a85fd6482fc44a586d7/" rel="bookmark">
			python对列表中某一列进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 test = [ [1, 2.0], [4, 1.1], [5, 3.1], [2, 1.2] ] # 如下表示对test列表进行排序，且是按照第二列的值来排序， # reverse为True表示降序，为False(默认值)表示升序排序 sort_test = sorted(test, key = lambda x:x[1], reverse = True) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c82e15d483dfa50a644c7ffa6d66d18/" rel="bookmark">
			C语言循环常见问题（献给初学者）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.循环次数问题 这个代码运算结果是4，很多初学者都会觉得是3，因为第二次运行出结果后会和2比大小然后计算机不会主动停止循环，而是继续转向下一次循环，这时n再进行一次循环语句的值为4.
这个do while语法 运行结果为0，容易出错的点在于循环到0时输出，执行printf语句时存在y--，这个通俗来讲就是先用再减，但是这个步骤输出为0，如果加一步printf（“%d\n”,y）;此时输出就为-1；
这个代码的次数为0，==代表的是绝对等于，而不是赋值，所以该代码循环不执行 这个代码的运算结果为1，2，0 循环语句中a&lt;b&lt;c是分开的，计算机中比大小只能两两相比，所以这个代码中a先和b相比完成第一次循环，然后b与c相比完成第二次循环。
（个人学习经验大佬勿喷） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c7652791bf4cfbe0c33f481b15f7844/" rel="bookmark">
			杂记（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.filter和backdrop-filter:blur(xx px) 都可以实现背景模糊，但是要注意，当背景是背景颜色不是图片的时候，backdrop-filter无效
2.修改element-ui的源码样式 项目需求是这样的：需要修改所有表格内容的字体颜色，一个页面一个页面的样式穿透我觉得很麻烦而且如果后期再更改的话改动的地方也很多，所以我想通过改变源码的css来统一进行修改，通过开发者工具我确定这个需要修改的样式是.el-table,通过搜索确定了需要修改的样式在node_modules/element-ui/lib/theme-chalk/table.css，但是修改了之后没有效果，于是我又在网上搜索了相关的处理方法，见：
如何修改ElementUI源码_wx6136ee27af82e的技术博客_51CTO博客
vue - 修改ElementUi 源码_颜景锐的博客-CSDN博客_修改elementui源码
https://www.jianshu.com/p/4b3757347ef5
奈何找不到element-ui的源码(git网站打不开)，我个人立即node_modules里应该就是源码，但是按网上操作了一番，在执行npm run dist的时候一直报错，后来无意在看node_modules/element-ui/pakage.json文件时发现
于是我就尝试在这里面修改.el-table的 样式，问题解决
3.base64格式文件上传 今天遇到接口需要上传文件内容的base64位编码
开始我的处理方法是把文件对象直接使用base64编码函数进行编码，提示错误，于是我又把文件对象通过JSON.stringify变成字符串之后 进行编码，请求之后发现接口返回不对，和接口人员沟通后发现接口没有问题，于是我想应该是这个编码还是不对，上网查询才知道获取文件的base64位编码要这样处理才可以，这样处理之后，接口就返回了正确的内容
参考文章：vue中上传文件获得base64编码文件,并用此参数传递给后台调取接口?_浅浅一笑^*^的博客-CSDN博客_vue拿到base64串后怎么发送文件给后台
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/085e1d3ea5ecc4f787a6bb219d3367d1/" rel="bookmark">
			vscode不能打开终端问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到vscode不能打开终端问题，一直以为是安全软件限制问题，也没搜到解决方案，因为影响也不大，就没有管。
最近，要用vscode调试代码，发现不能打开终端，没法玩了，又来看这个问题，终于解决了。
记录下来，希望帮助到遇到同样问题的朋友。
终端进程启动失败: Windows cannot open this program because it has been prevented by a software restriction policy. For more information, open Event Viewer or contact your system Administrator。
这的确是因为限制问题，不过是因为powershell本身的限制，因为我直接打开powershell都打不开。
vscode默认使用的终端是powershell，所以打不开终端也就是正常现象了。
只需要打开设置(ctrl+,)搜索终端，找到Windows下的终端配置。
添加默认终端配置：
"terminal.integrated.defaultProfile.windows": "Command Prompt" Command Prompt表示的就是cmd终端。
还可以添加终端配置，比如，想用git之类的作为终端，就可以，在这个配置文件中添加：
"terminal.integrated.profiles.windows": { "gitBash": { "path": "D:\\tool\\Git\\bin\\bash.exe", "color": "terminal.ansiYellow" }, "cmd": { "path": "C:\\WINDOWS\\System32\\cmd.exe", "color": "terminal.ansiRed" } } 把路径改成自己的可执行程序路径就可以了。
可以选择终端。
接下来接可以愉快的进行调试了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe25615bb3df5e6d478c4a2900b56558/" rel="bookmark">
			数据结构 Prim and Kruskal 算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 根据输入创建无向网。分别用Prim算法和Kruskal算法构建最小生成树。（假设：输入数据的最小生成树唯一）
输入 顶点数n
n个顶点
边数m
m条边信息,格式为：顶点1 顶点2 权值
Prim算法的起点v
输出 输出最小生成树的权值之和
对两种算法，按树的生长顺序，输出边信息(Kruskal中边顶点按数组序号升序输出)
输入样例 输出样例 v1 v2 v3 v4 v5 v6 15
10 prim:
v1 v2 6 v1 v3 1
v1 v3 1 v3 v6 4
v1 v4 5 v6 v4 2
v2 v3 5 v3 v2 5
v2 v5 3 v2 v5 3
v3 v4 5 kruskal:
v3 v5 6 v1 v3 1
v3 v6 4 v4 v6 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe25615bb3df5e6d478c4a2900b56558/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f8afb46b95ae65f3a6a793c6afe7892/" rel="bookmark">
			微信点金计划对接笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
做了一款H5页面，调用JSAPI实现的微信支付功能，在支付完成后跳转到指定页面，后来却直接关闭当前H5窗口返回到微信页面。
经过排查，原来是因为需求方把之前收款的微信账号由普通商户，改成了特约商户，需要配置点金计划来进行返回页面
问题排查：
1.普通商户可以调用JSAPI支付后的回调函数
2.特约商户JSAPI支付后后会关闭H5页面
解决方案：
1.根据公众号上的定金计划配置开通点金计划
2.代码展示
注：后端接口请求不能超过3秒，超过3秒将显示失败，点金文档上有
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset=utf-8&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name=referrer content="origin"&gt; &lt;meta name=viewport content="width=device-width, viewport-fit=cover, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"&gt; &lt;meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/&gt; &lt;title&gt;支付完成&lt;/title&gt; &lt;script type="text/javascript" src="https://cdn.jquery.js"&gt;&lt;/script&gt; &lt;script type=text/javascript charset=UTF-8 src=https://wx.gtimg.com/pay_h5/goldplan/js/jgoldplan-1.0.0.js&gt;&lt;/script&gt; &lt;style&gt; body { font-family: PingFang SC, "Helvetica Neue", Arial, sans-serif; } .order-box {· text-align: center; } .merchant-name { font-size: 16px; font-weight: 500; color: #333333; margin-top: 6px; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f8afb46b95ae65f3a6a793c6afe7892/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e21e740c72db1dd21734eb8455993ce7/" rel="bookmark">
			Cisco Packet Tracer实验一：Telnet远程登录、交换机的基本配置实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验软件：思科模拟器Cisco Packet Tracer 7.3.0
链接：https://pan.baidu.com/s/1PLEiqCKqQSxPv7lDcruoWA
提取码：aan4
交换机的基本配置内容，参考链接如下：
Cisco Packet Tracer 实验——配置交换机_不周阁的博客-CSDN博客_cisco packet tracer交换机配置
使用思科模拟器 Cisco Packet Tracer 模拟交换机基本配置_硕子鸽的博客-CSDN博客_思科模拟器交换机
目录
1.拖出1个交换机、1个PC端
2.使用配置线来连接交换机和PC
3.终端配置(默认为用户模式)
4.交换机配置内容
5.PC端配置内容
6.设置特权密码
6.1举例子说明这两种特权密码：
7.保存配置内容
8.指令简写
1.拖出1个交换机、1个PC端 交换机2960：[网络设备]→[交换机]→[2960-24TTSwitch 0] //[Network Devices]→[Switches]→[2960-24TTSwitch 0] PC端：[终端设备]→[电脑] //[End Devices]→[PC]
2.使用配置线来连接交换机和PC 配置线：[连线]→[配置线] //[Connections]→[Console]
说明：交换机本身是不能实现远程管理的，所以需要配置线来连接电脑【即PC端】的RS 232接口和交换机的Console接口来进行配置管理，连接好后，如下图所示：
3.终端配置(默认为用户模式) 点击[电脑]→[桌面]→[终端]→[终端配置]→使用默认数值点击[OK] →进入用户模式 //Click[PC]→[Desktop]→[Terminal]→[Terminal Configuration]→[OK]→Enter user mode
4.交换机配置内容 Switch&gt;en //进入交换机的特权模式
Switch#conf t //进入交换机的全局配置模式
Enter configuration commands, one per line. End with CNTL/Z.
Switch(config)#int vlan 1 //进入交换机的Vlan 1的接口配置模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e21e740c72db1dd21734eb8455993ce7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf6a3769728d5b7852a026d4691c2db0/" rel="bookmark">
			Redis 实现限流策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		除了控制流量，限流还有一个应用目的是用于控制用户行为，避免垃圾请求。
比如在 UGC 社区，用户的发帖、回复、点赞等行为都要严格受控，一般要严格限定某行为在规定 时间内允许的次数，超过了次数那就是非法行为。对非法行为，业务必须规定适当的惩处策略。
如何使用 Redis 来实现简单限流策略？ 接口的定义
# 指定用户 user_id 的某个行为 action_key 在特定的时间内 period 只允许发生一定的次数 max_count def is_action_allowed(user_id, action_key, period, max_count): return True # 调用这个接口 , 一分钟内只允许最多回复 5 个帖子 can_reply = is_action_allowed("laoqian", "reply", 60, 5) if can_reply: do_reply() else: raise ActionThresholdOverflow() 解决方案 这个限流需求中存在一个滑动时间窗口，想想 zset 数据结构的 score 值，是不是可以通过 score 来圈出这个时间窗口来。
Redis sorted sets | Redis
而且我们只需要保留这个时间窗口，窗口之外的数据都可以砍掉。那这个 zset 的 value 填什么比较合适呢？它只需要保证唯一性即可，用 uuid 会比较浪费空间，那就改用毫秒时间戳吧。
如图所示，用一个 zset 结构记录用户的行为历史，每一个行为都会作为 zset 中的一个 key 保存下来。同一个用户同一种行为用一个 zset 记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf6a3769728d5b7852a026d4691c2db0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ff1aebd59bcc507f460656418f1def/" rel="bookmark">
			Ubuntu 20.04 虚拟机安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先你需要下载 VMware，建议不要放于C盘，不会下载的建议看 哔哩哔哩Frank。下载 Ubuntu 20.04 镜像，也是建议不放于C盘，我放在了 E:\Ubuntu 20.04 iso
完成上诉步骤，打开VMware，点击创建新的虚拟机。选择 自定义，点击 下一步点击 下一步看看和下图选择的一样嘛，一样就点击 下一步看看和下图选择的一样嘛，一样就点击 下一步点击浏览，不要放于C盘。建议新建一个文件夹专门存放。然后点击 下一步选 2，2，要求你的电脑最低要8G内存，然后点击 下一步选 4G ，要求你的电脑最低要8G内存，然后点击 下一步 看看和下图选择的一样嘛，一样就点击 下一步看看和下图选择的一样嘛，一样就点击 下一步看看和下图选择的一样嘛，一样就点击 下一步看看和下图选择的一样嘛，一样就点击 下一步看看和下图选择的一样嘛，一样就点击 下一步点击 下一步点击 自定义硬件点击 打印机，点 移除，因为用不到
点击新 CD/DVD，选择 使用 ISO 映像文件，点击浏览，找到之前你下载好的Ubuntu 20.04 镜像文件，然后点击 关闭。点击 完成点击 开启此虚拟机选 English ，然后点击 Install Ubuntu 看看和下图选择的一样嘛，一样就点击 Continue看看和下图选择的一样嘛，一样就点击 Continue点击 Install Now 点击 Continue选Shanghai，点击 Continue设置用户名，密码，点击 Continue点击 Skip点击 Restart Now点击输入密码，输完按下回车键点击 Skip点击 Next点击 Next点击 Next点击 Done之后如图之后的步骤请看 Ubuntu 20.04 虚拟机镜像源更改 ，Ubuntu 20.04 虚拟机更新教程， 文章知识点与官方知识档案匹配，可进一步学习相关知识 CS入门技能树Linux入门在线安装软件 22294 人正在系统学习中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23ea245e30cb3f8053d3fcc5ad319ac1/" rel="bookmark">
			String详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String类的理解： 什么是String类？
String类实现了Serializable接口，对象可以被序列化，序列化之后，对象可以进行网络传输，或者持久化。String类实现的Comparable接口，对象可以比较大小。String类实现了CharSeqence接口，将String类与StringBuffer和StringBuilder类关联起来String类有一个char类型的数组value，它是用来储存字符串的，value属性是被final修饰的，所以value里的值是不能修改的 String类创建对象？
方式一：直接赋值
String str = "123"; JVM会先在字符串常量池中去找“123”这个值，如果没有，就在字符串常量池中创建一个空间，把这个值存进空间，并返回一个地址给当前字符串引用str。
String str1 = "123"; 同样的JVM先在字符串常量池中去找“123”这个值，此时，字符串常量池中有“123”这个值，那么就不会在开创一个新的空间，而是把已经存在的值的地址返回给str1。
底层原理：
在类加载的过程中JVM会创建一个String实例来对应字符串常量池中的“123”字面量，再将地址赋给str。
方式二：构造器赋值
String str = new String("213"); 也是在类加载时，查找字符串常量池中有没有字面量“213”，没有就在常量池中创建一个“213”实例，在将地址传给运行时在堆创建的String对象，再将对象的地址传给str。
注意：
由于存放String字符串值的属性value是被final修饰的，所以String字符串的值是不能被修改的
String str = "abd"; str = "acb"; 在这里创建了两个String对象实例，第一个是与字面量“abd”相对应的String对象实例，第二个是与“acb”相对应的String对象实例，在此期间str的值由“abd”的地址，变为的“acb”的地址。
intern方法
当调用intern方法时，如果常量池中已经包含一个等于此String对象的字符串（用equals（Object）方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89940548c0feff172d733ac5d9b48222/" rel="bookmark">
			基于Python仓库管理系统的设计与实现django框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
随着信息化时代的到来，系统管理都趋向于智能化、系统化，仓库管理系统也不例外，但目前国内的有些公司仍然都使用人工管理，公司规模越来越大，同时信息量也越来越庞大，人工管理显然已无法应对时代的变化，而仓库管理系统能很好地解决这一问题，轻松应对公司平时的工作，既能提高人力物力财力，又能提高工作的效率，取代人工管理是必然趋势。
本仓库管理系统以Django作为框架，Python语言，B/S模式以及MySql作为后台运行的数据库。本系统主要包括以下功能模块：公告信息、仓管员、采购员、财务员、商品分类、供应商、仓管理库、仓库信息、商品信息、采购订单、商品入库 、出库账单等模块。
本文着重阐述了仓库管理系统的分析、设计与实现，首先介绍开发系统和环境配置、数据库的设计，接着说明功能模块的详细实现，最后进行了总结。
关键词：仓库管理系统; Django框架;MySql数据库;Python语言
Abstract
With the advent of the information age, the system management tends to be intelligent and systematic, and the warehouse management system is no exception. However, at present, some domestic companies still use manual management. The scale of the company is becoming larger and larger, and the amount of information is becoming larger and larger. It is obvious that manual management can no longer cope with the changes of the times, and the warehouse management system can solve this problem well and easily deal with the company's usual work, It can not only improve human, material and financial resources, but also improve work efficiency.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89940548c0feff172d733ac5d9b48222/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca34bf443547fba4f21243213d0245b/" rel="bookmark">
			黑客实战：从app渗透到网站沦陷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下今天对某app进行渗透测试，从基础的信息收集到拿到网站的shell。总体来是还是很简单的，也没什么技术含量
使用模拟器挂上代理并对app进行抓包，我们把其域名给拿出来
2. 使用工具对主域名进行敏感目录扫描，发现存在一个admin的目录
对该目录进行访问，发现存在管理后台，且目前看没有验证码，可以尝试爆破
输入不同的账号，看是否存在用户名枚举，如下输如admin显示账号或者密码错误
输入admin2显示账号未注册，所以此处存在账号枚举漏洞
3. 进行表单爆破
使用burpsuite先进行枚举存在的账号，测试发现存在admin和wangjie两个账号
使用这两个账号然后对密码进行爆破。因为该密码进行了md5加密，所以爆破前进行md5加密就行。如下成功爆破出来了
对md5进行解密，发现密码就是123456，这密码也够nice
4. 使用该账号密码成功登陆后台
接着寻找可以利用的漏洞点，然后发现存在文件上传的地方，随便传了个后缀的文件过去，发现能上传成功
5. 辨别网站使用的脚本语言
由于在http请求数据及浏览器插件中都没找到该网站使用的什么脚本语言。于是我搜索该app对应的公司，然后看他们公司的招聘岗位。发现正在招聘安卓开发，好家伙，那不就是java吗
6. 上传jsp冰蝎🐴
访问马子，没啥反应，估计行了吧
连接马子
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aac236ce1a00efbf9b3073d5e72e4f5/" rel="bookmark">
			Kimball 维度建模理论
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、维度建模分为两种表 事实表
存在这样一些数据，如行为记录，操作记录，订单，日志等，都可以作为事实表
特点：每条数据都有一个唯一键，数据通常来说不会更新，随着时间的增加而增加维度表
维度表是分析数据角度的信息表，如商家信息，地区信息，用户信息为角度存储的表，适合经常更新，一般和事实的关系是一对多 二、维度建模三种模型： 星型模型雪花模型星座模型 说明： 1）. 星型模型
以事实表为中心，所有的维度表直接连在事实表上，比较常用的一种形式。这样维度加事实的结构即便于维度数据（少数据量）更新，又能够满足自由组合满足不同的分析维度
如上图所示：
产品表与部门表，会存在更新现象，而事实表，一般只存储部门ID,产品ID,在需要的时候再进行关联这样的结构能够以部门的维度做数据分析，如统计某部门的销售金额，亦能够以产品的角度分析某个产品的销售总额，能够灵活的以不同角度分析和查看数据 2）. 雪花模型
雪花模型指的是在星型模型的基础上，维度表再关联维度表，这种结构应该在OLTP场景下会用这样的结构，在数仓下基本没人使用。如果业务数据存储为这样的结构，常常将数据打平，即合并成一张维度表，这样它将会上级为星型模型。之所以如此是为了减少表连接查询的性能开销和维护的复杂程度，雪花模型如下：
2）. 星座模型
在实际业务中，星座模型才是数仓建设的最终归属，它也是建立在星型模式下，不同的是只是和其他事实表共享了维度表，即存在多张事实表，共享一张维度表的情况
kimball 维度建模，星型和星座 模型核心在于将事实表（过程数据通常不变的数据）与主体信息表（常更新的数据，有维度信息）逻辑进行拆分。 实现任意维度分析的需求下，减少表连接查询的深度，这也是市面上常见的数仓建设理论
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5eece6dce051ac9dca832b0186442e3/" rel="bookmark">
			C&#43;&#43;中变量前加(void)的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言 看C++项目的源代码时，发现很多地方出现void(val);，百思不得其解，甚至还在VS里面自己写了一遍，发现(void)并不会改变变量类型，怎么尝试也不知道为什么，书上更是没有提及，今天看到一篇文章终于明白。
为什么使用void(val);？ 通过自己查资料，才发现作用是避免编译器警告。
声明/定义了但没使用的变量，在编译时会生成warning。
如果项目里是打开了-Werror选项，会将warning视为error，这样的话无法通过编译。
所以需要用这种方法绕过无关紧要的warning。
总结 看来实际的工程项目里面存在很多“潜规则”哇。用void来避免未使用警告真是太聪明了。这是教科书上不会讲的内容，只有实际开发时才会遇到。
参考 变量前（void）的作用？ - 诸葛不亮的回答 - 知乎
https://www.zhihu.com/question/67831689/answer/256930061 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c316ec7fbfb0997dec2df5a1541fcc8/" rel="bookmark">
			MQTT问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 是否存在c-&gt;ping_outstanding = 1;的后一秒就触发TimerIsExpired(&amp;c-&gt;last_received)
int keepalive(MQTTClient *c) { int rc = SUCCESS; if (c-&gt;keepAliveInterval == 0) goto exit; if (TimerIsExpired(&amp;c-&gt;last_sent) || TimerIsExpired(&amp;c-&gt;last_received)) { if (c-&gt;ping_outstanding) rc = FAILURE; /* PINGRESP not received in keepalive interval */ else { Timer timer; TimerInit(&amp;timer); TimerCountdownMS(&amp;timer, 1000); int len = MQTTSerialize_pingreq(c-&gt;buf, c-&gt;buf_size); if (len &gt; 0 &amp;&amp; (rc = sendPacket(c, len, &amp;timer)) == SUCCESS) // send the ping packet c-&gt;ping_outstanding = 1; } } exit: return rc; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec28b1feeba8f647799fe6b94970d4c4/" rel="bookmark">
			安装axios失败
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 npm i axios --legacy-peer-deps 网络不好报错
npm config set registry https://registry.npmmirror.com npm i axios --legacy-peer-deps 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1b9368a98108088e7d2d36bae2850e4/" rel="bookmark">
			安装ENDNOTE后在Word里面找不到怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多次遇到这个问题，经验也总结了好几遍，但是发现也有之前经验没有覆盖到的，因此除了推送之前的经验，也在此补充一个新的内容。
参见教你把endnote加载到Word
上述操作一般情况下是没有问题的，奈何有时候也是会出现Word里面还是找不到endnote的情况，别慌，再试试这招：首先打开cmd, 然后键入regsvr32.exe "D:\ennote7\endnote\Product-Support\CWYW\Cwyw_x64\EndNote Cwyw.dll"，红色部分符号和字母千万别打错了，需要注意的是引号内路径就是教你把endnote加载到Word里面解压Cwyw_x64后的EndNote Cwyw.dll的文件路径。
科研不容易，工具能省力，希望我们都能跟这些工具和谐相处
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e75b95b36fef1b92dcac23cbebb7250/" rel="bookmark">
			依赖注入有几种实现方式？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		依赖注入是时下最流行的IOC实现方式，依赖注入分为接口注入（Interface Injection），Setter方法注入（Setter Injection）和构造器注入（Constructor Injection）三种方式。其中接口注入由于在灵活性和易用性比较差，现在从Spring4开始已被废弃。
构造器依赖注入：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。
Setter方法注入：Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/209/">«</a>
	<span class="pagination__item pagination__item--current">210/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/211/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>