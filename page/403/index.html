<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/066faac7b4bf18bb40794bb1728b5013/" rel="bookmark">
			pandas fillna_机器学习教程之小白入门Pandas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你想要利用python来学习数据分析和机器学习，你将很有可能使用非常强大的Pandas库。Pandas是python的一个可供数据操纵和分析的开源库。今天的内容是小编带你对Pandas进行简单的入门。
1 读取数据
这有一种很简单的方式，就是你可以用Python加载数据表(tables)以及excel文件：
Pandas可以让我们读取电子表格并且用python程序化地操纵它们。
Pandas的核心是DataFrame——基本上是一个数据表，每个行和列都有一个label。
现在先让小编演示如何读取一个包含音乐服务数据的基本CSV文件。
import pandasdf=pandas.read_csv('music.csv') read_csv函数可以把轻松地把数据搬到DataFrame里。同学们还要注意修改括号里文件的路径。
接下来就可以对数据进行切分用来分析了。
2 选择数据
根据它的label选择任意一列：
df['Artist'] 也可以使用它的行号来选择一行或者多行：
df[1:3] 我们可以使用loc函数和列标签、行号来选择表格的任意一块，
要注意的是与上一种方法不同，这里要包含两个边界标号：
df.loc[1:3,['Artist']] 3 过滤
我们还可以使用行的特定的值来对数据进行过滤：
df[df['Genre']=='Jazz'] df[df['Listeners']&gt;1800000] 4 处理缺失值
你面对的数据集里将经常遇到缺失值，如下图。
那么让小编带你看看如何处理缺失值。
有很多方法可以采用，其中有一个简单的方法就是把有缺失值的行删掉：
df.dropna() 还有利用 fillna() 函数来填充缺失值，比如用零：
df.fillna(0) 5 分组
还有一个有趣的操作，就是你可以用一定的规则来把数据分组并且整合数据。比如，我们用流派“genre”来分组，并且看看每个流派有多少听众和播放量：
df.groupby('Genre').sum() Pandas将两个“Jazz”行组合为一行，由于我们使用sum()进行聚合，因此它将两个Jazz艺术家的听众和播放量相加，并在combined Jazz列中显示总和。
这是一种非常强大的数据分析方法。现在你已经知道groupby()，就可以使用这个工具来折叠数据集并从中得到你的见解。学会聚集统计学的基础工具之一groupby()，相信这对你有很大的帮助。
除了sum()之外，Pandas还提供了多个聚合函数，包括mean()来计算平均值、min()、max()和多个其他函数。
6 从存在的列中创建新的列
通常在数据分析过程中，我们发现我们需要从现有的数据中创建新的列。Pandas可以轻而易举地实现这个。
df['Avg Plays']=df['Plays']/df['Listeners'] 通过告诉Pandas将一列除以另一列，它意识到我们要分别除以各个值(即每行的Plays值除以该行的Listeners值)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77df4c254478c33c02eb854ddfbf454b/" rel="bookmark">
			GopherChina 2020 Go Programming Patterns 学习笔记篇1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天学习的是左耳朵耗子老师的 Go Programming Patterns，包括Slice，深度比较，接口，多态，Time，性能以及委托模式和错误处理等话题。
Topic 1 Slice 我们知道Slice是一个结构体
type SliceHeader struct { Data uintptr Len int Cap int } 一个var a []int 是nil，但是它的len和cap都将是零，因为值是初始化这个slice结构体的零值，即
SliceHeader{ Data: nil, Len: 0, Cap: 0, } PPT里讨论的是slice的共享内存，在append时候，是否会reallocate。如下代码，分配一个32的长度的slice a，此时新建slice b指向a的1到15，然后改变a中index为2的值，这个会导致b变化吗？这里是不会的，因为a在append(a,1)时候已经reallocate了。a之所以会reallocate是因为make里指定的长度为32，cap也是32，这时候append会导致长度+1，cap不足，致使扩容，然后a就会被赋新的地址。而b依然指向的是之前的地址。
a := make([]int, 32) a[2] = 41 b := a[1:16] // a[2] 和 b[1] 指向的index是同一个 a = append(a, 1) a[2] = 42 fmt.Printf("a[2]=%d\n", a[2]) // 打印42 fmt.Printf("b[1]=%d", b[1]) // 打印41 何时会导致slice扩容呢，只有cap不够的时候。看以下代码，dir1的cap是多少呢？是path的长度，即14，那么dir2也是14吗？不是的，dir2的cap是从它的起始位置开始计算到指向的slice的末尾，也就是从9。那么此时向dir1 append 数据，只要不超过14，就不会导致slice扩容，也就不会memory reallocate，但是会影响dir2的内容，因为dir1和dir2共享path的memory。
path := []byte("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77df4c254478c33c02eb854ddfbf454b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1b94fb1a3e350e5b44417f3711579f/" rel="bookmark">
			从零开始学PCR技术（一）：PCR技术简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCR 可能是分子生物学中使用最广泛的技术。虽然我本科学的是生物科学，提过 DNA，也跑过 PCR，但现在都快忘了 PCR 的步骤是三个还是四个了。赶快网络搜索之，整理成一个从零开始学系列。
聚合酶链式反应（Polymerase Chain Reaction，PCR）是一项利用 DNA 双链复制原理，在生物体外复制特定 DNA 片段的的核酸合成技术。可在短时间内大量扩增目的 DNA 片段，而不必依赖大肠杆菌或酵母菌等生物体。
DNA 的半保留复制是生物进化和传代的重要途径。双链 DNA 在多种酶的作用下可以变性解旋成单链，在 DNA 聚合酶的参与下，根据碱基互补配对原则复制成同样的两分子拷贝。在实验中发现，DNA 在高温时也可以发生变性解链，当温度降低后又可以复性成为双链。因此，通过温度变化控制 DNA 的变性和复性，加入设计引物，DNA 聚合酶，dNTP 就可以完成特定基因的体外复制，这是 PCR 的理论基础。
一、反应体系 PCR 反应是在体外模拟 DNA 的复制过程，因此反应体系中必须具有 DNA 复制所需的基本要素：
模板（template），含有需要扩增的 DNA 片段。
引物（primer），一对引物决定了需要扩增的起始和终止位置。
聚合酶（polymerase ），DNA 聚合酶复制需要扩增的区域。
脱氧核苷三磷酸（dNTP），用于构造新的互补链。
缓冲液（buffer），提供适合聚合酶行使功能的化学环境。
二、反应步骤 标准 PCR 过程分为三步：
变性（Denaturation）：利用高温使 DNA 双链分离。DNA 双链之间的氢键在高温下（93 - 98℃）被打断。
退火（Annealing）：在 DNA 双链分离后，降低温度使得引物可以结合于单链 DNA 上。
延伸（Extension）：DNA 聚合酶由降温时结合上的引物处开始沿着 DNA 链合成互补链。延伸完成，则完成一轮循环，DNA 片段数增加一倍。往复循环这三个步骤 25-35 次，DNA 片段数将得到指数级增加。
聚合酶链式反应简图 三、结果检测 PCR 反应扩增出了高的拷贝数，下一步检测就成了关键。荧光素（溴化乙锭，EB）染色凝胶电泳是最常用的检测手段。电泳法检测特异性是不太高的，因此引物两聚体等非特异性的杂交体很容易引起误判。但因为其简捷易行，成为了主流检测方法。近年来以荧光探针为代表的检测方法，有逐渐取代电泳法的趋势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a1b94fb1a3e350e5b44417f3711579f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccdc8eda7108e849e4c5cdc65d8887a4/" rel="bookmark">
			matlab 工业相机 曝光时间_工业相机之全局曝光与卷帘曝光
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是快门
全局曝光和卷帘曝光是常见的相机曝光方式。一般来说，CCD相机是全局曝光，而CMOS相机则存在卷帘曝光。那么，这两种方式孰优孰劣呢？或者说，他们两者的差别在哪里呢？那么，先从两者的定义说起。
快门是照相机用来控制感光片有效曝光时长的组件，是照相机的重要组成部分，快门的结构/形式及功能是决定照相机档次的一个重要因素。通常来说，快门的时间范围越大越好。秒数低的适合拍摄运动的物体。当我们拍摄夜晚的车水马龙，灯绘光绘的时候，快门时间就要拉长。同理，照片中常见的丝绸般的流水也是选择慢速快门才能够拍摄出来。
卷帘快门与全局快门
卷帘快门，通常用于CMOS传感器逐行曝光的方式实现的。在曝光开始的时候，传感器逐行扫描逐行进行曝光，直至所有像素点都被曝光。所有的动作都在极短的时间内完成。不同行像元的曝光时间不同。
全局快门通过整幅场景在同一时间曝光实现的。传感器(Sensor)所有像素点同时收集光线，同时曝光。在曝光开始的时候，传感器开始收集光线。在曝光结束的时候，光线收集电路被切断。然后传感器读出为一幅照片。CCD就是使用全局快门工作方式，所有像元同时曝光。
对于相机厂家来说，卷帘快门可以达到更高的帧速，但当曝光错误或物体移动较快时，卷帘快门记录到的和我们人眼所看到的就有所偏差。
一般来说，CCD传感器多用全局快门，CMOS传感器多用卷帘快门。厂商为传感器选择某一种快门速度需要考虑多种因素，如：处理速度，电池消耗，制造成本及整体复杂性等问题。所以说，对于静态拍照来说不是问题，但是在拍摄视频时选择哪一种快门就很重要了，特别是拍高速运动的物体时。
为何会出现这种现象
对于多数相机来说，快门的“卷帘”速度是1/30秒，大部分物体的运动变化不是很明显。但当我们拍摄高速运动物体时，如飞机的螺旋桨，“拍摄效果”会非常的明显。
但拍摄高速物体并不是唯一会出现的问题。但我们坐在高速行驶的汽车中，通过窗户对外拍摄，也会出现卷帘快门效果。下面我们就模拟了一块10✖️10传感器的效果。
这也就解释了，我们坐在高铁上拍摄外面的树为什么会有一点斜。
有趣的效果
其实卷帘快门并不是一种“缺点”。虽然大多数情况下我们并不希望看到“卷帘效应”，不过我们还是可以利用它拍摄到一些有趣的画面。
全局曝光
全局曝光的方式比较简单。也就是说光圈打开后，整个图像芯片同时曝光。因此，曝光时间与机械的开关速度有关。既然与机械运动相关，所以，存在理论上的最小曝光时间
优点：所有像素点同时曝光
缺点：曝光时间存在局限，存在机械极限的最小曝光时间
卷帘曝光
顾名思义，卷帘曝光的方式可能与卷帘的概念相关。此种曝光方式是当光圈打开后，还存在具有一定间隔的卷帘来控制传感器的曝光时间。注意，如下图所示，卷帘的方式是从左到右的。因此，曝光时间的长短完全取决于卷帘的开口大小与卷帘的运动速度。也就是说，卷帘运动得越快，卷帘间距越小，其传感器的曝光时间越小。因此，卷帘曝光方式能够具有更小的曝光时间。
其卷帘运动的方式由下图所示：卷帘在运动时，其卷帘开口的传感器来能接受光。
卷帘移动过程中的某个位置
卷帘在移动过程中的后一个位置
优点：具有更小的曝光时间
缺点：逐行曝光，存在拖影，不适合拍摄运动物体
拖影分析
专业描述：拖影是在曝光的时候，拍摄目标与摄像系统之间存在相对运动形成的，因为这种 相对运动导致芯片上形成的图像一直在变化，各个部位的像元在曝光的过程中受到来自物体不同位置成像的影响，最终形成的图片是一个连续变化图像空间内图片的叠加。
关于曝光时间的问题，其实就是相机采集图像过程包括的两个部分，第一部分是曝光(exposure)，第二部分是曝光完成后，从传感器的寄存器中读出数据并传送出去(Readout)。当相机正在1号点位置拍摄快速运动物体A时，如果相机的曝光时间过长(即采集1号点图像的时间过长)，此时物体A却已发生了位移，因此采集所得图像并非完全是1号点处的图像，此时采集到的图像是在运动过程中采集得到(稍稍偏离1号点图像与1号点图像的叠加)，由此产生拖影。
曝光时间越长，拍摄速度越慢，但是曝光时间越短，进光量就会变少，此时则需调大光圈，增加光照，才能保证图像的亮度。所以，对于拍摄运动物体，曝光时间需设置合理，不能因图像亮度效果需要就盲目将曝光时间设置过大，否则容易产生拖影，对于由曝光时间小而产生的图像亮度不佳，此时应通过调大光圈和增加光照来进行调整。
逐行曝光
图1 逐行曝光模式
逐行曝光sensor 实现如图1逐行曝光模式所示。与全局曝光不同，逐行曝光从第一行开始曝光，一个行周期之后第二行才开始曝光。依次类推，经过N-1 行后第N 行开始曝光。第一行曝光结束后开始读出数据，读出一行需要一行周期时间(含行消隐时间)。至第一行完全读出后，第二行刚好开始读出，依次类推，当第N-1 行读完后，第N 行开始读出，直到整幅图像完全读出。逐行曝光的sensor 技术难度较全局曝光sensor 低，价格便宜，且分辨率较大，对于一些静态图像拍摄是不错的选择。
全局曝光
图2 全局曝光模式
全局曝光 sensor实现如图2所示， Sensor的所有行同时开始曝光，并同时结束曝光，在曝光结束后，Sensor将所有电子从感光区转到存储区，之后逐行地读出像素数据。这样曝光的好处是获得图像每一行的曝光时间比较一致，并且在拍摄运动物体时图像不会出现偏移和歪斜。
注：电子快门曝光时间的变化，仅仅改变了CCD光敏像元对外来光的感应时间，并不会改变CCD内在的视频读出周期。
推荐阅读
(点击标题可跳转阅读)
最详细、最完整的相机标定讲解 深度学习+机器视觉=下一代检测 视觉检测系统最经典的结构你了解吗？ 机器视觉技术的十大应用领域 工业相机和普通相机究竟有什么不同？ 基于机器视觉和深度学习的智能缺陷检测 波士顿等移动机器人的视觉算法解析 2020年37个人工智能技术发展趋势 机器视觉的光源选型及打光方案分析 光学三维测量技术及应用 国内80%搞机器视觉的工程师，走的路子是错的！ 视觉+机器人，如何实现连接器的自动装配？ 机器视觉技术发展的五大趋势 搞懂机器视觉基本内容，这份PPT就够了 机器视觉：PC式视觉系统与嵌入式视觉系统区别 基于HALCON的机器视觉开发，C++或C#如何选择？ 3D视觉技术在机器人抓取作业中的应用实例 基于机器视觉的粗糙度检测方案 机器视觉常用图像软件对比及分析 工业相机编程流程及SDK接口使用汇总 End 商务合作：QQ：1504328545
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccdc8eda7108e849e4c5cdc65d8887a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b2bcc81c76894017b7fcd802990a57e/" rel="bookmark">
			android studio_基于NCNN的Android应用程序环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio安装 直接下载Android Studio压缩包，解压放置到合适的位置，命令行调用bin目录下的studio.sh即可运行（相当于绿色软件）。为方便调用，在用户环境变量文件~/.bashrc中加入下述命令，即可在任意控制台内使用studio.sh调用
export ANDROID_HOME=/usr/local/android-studio/bin export PATH=$PATH:$ANDROID_HOME 安装Android SDK，NDK，Gradle
Android SDK安装 使用 studio.sh运行android studio，提示找不到SDK，不用管一直向下，用Android SDK Manager自动下载相应的版本
NDK安装 单独下载与使用，主要利用它将C++代码编译成.so文件提供给Android调用，这里将其加入到AS中作为外部工具
Gradle安装 AS打开一个工程时，会先读取{your project}/gradle/wrapper/gradle-wrapper.properties 文件，从而知道这个工程需要的gradle版本（由下图最后一句决定），然后就会去保存gradle的文件夹GRADLE_USER_HOME去查看是否存在这个版本的gradle，不存在则会去distributionUrl去下载
（1）因此，首先修改gradle-wrapper.properties中的gradle的版本，改成想要的，然后去https://services.gradle.org/distributions/下载对应的版本（在线下载太容易成功）
（2）打开项目，此时AS会自动下载gradle，并创建好目录，此时直接退出，可得到gradle的创建目录
linux：~/.gradle/wrapper/dists windows: C:users{user name}.gradlewrapperdists 将下载的gradle放入对应目录下（一堆乱码文件夹下），不要解压。
错误解决1: 当新建项目clean project等操作时会出现下列问题：
Error:Execution failed for task ':app:preDebugAndroidTestBuild'.
&gt; Conflict with dependency 'com.android.support:support-annotations' in project ':app'. Resolved versions for app (26.1.0) and test app (27.1.1) differ. See https://d.android.com/r/tools/test-apk-dependency-conflicts.html for details.
此时需将下面命令添加到 app/build.gradle中
错误解决2:AS报错Configuration on demand is not supported by the current version of the Android Gradle, Suggestion: disable configuration on demand by setting org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b2bcc81c76894017b7fcd802990a57e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34dd81e063c5f503421fc85dfec50e62/" rel="bookmark">
			Spring依赖注入的方式有几种，各是什么?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、构造器注入 将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。
优点：
对象初始化完成后便可获得可使用的对象。
缺点：
当需要注入的对象很多时，构造器参数列表将会很长；
不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。
二、setter方法注入 IoC Service Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。
优点：
灵活。可以选择性地注入需要的对象。
缺点：
依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。
三、接口注入 依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参
数就是要注入的对象。
优点：
接口注入中，接口的名字、函数的名字都不重要，只要保证函数的参数是要注入的对象类型即可。
缺点：
侵入行太强，不建议使用。
PS：什么是侵入行？
如果类A要使用别人提供的一个功能，若为了使用这功能，需要在自己的类中增加额外的代码，这就是侵入性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4a26175f6aed2e4ade4a58e50539a5e/" rel="bookmark">
			Spring之AOP的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 什么是AOPjdk动态代理实现AOPspring实现AOP 什么是AOP AOP（Aspect Oriented Programming）意为面向切面编程，我们所熟悉的是面向对象编程（OOP），将程序中所有参与模块都抽象成对象，然后通过对象之间的相互调用关系来完成需求。
AOP 是对 OOP 的一个补充，是在另外一个维度上抽象出对象，具体是指程序运行时动态地将非业务代码切入到业务代码中，从而实现代码的解耦合，将非业务代码抽象成一个对象，对该对象进行编程这就是面向切面编程思想。
jdk动态代理实现AOP 创建一个计算器接口 Cal：
public interface Cal { public int add(int num1,int num2); public int sub(int num1,int num2); public int mul(int num1,int num2); public int div(int num1,int num2); } 创建实现类：
public class CalImpl implements Cal { public int add(int num1, int num2) { int result = num1+num2; return result; } public int sub(int num1, int num2) { int result = num1-num2; return result; } public int mul(int num1, int num2) { int result = num1*num2; return result; } public int div(int num1, int num2) { int result = num1/num2; return result; } } 这是一个很简单的实现简单计算的实现类，现在我们有一个需求，需要在方法计算之前打印日志记录方法信息，方法结束后再记录一次日志打印返回值等信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4a26175f6aed2e4ade4a58e50539a5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1448d98db6819e266ef335700a2c2713/" rel="bookmark">
			JS 在数组指定位置插入/删除/替换数据的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。
语法糖：
arrayObject.splice(index,howmany,item1,.....,itemX) 参数说明：
参数描述index必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, …, itemX可选。向数组添加的新项目。 添加一个元素：
var array = [1,2,3,4,6]; array.splice(4,0,5); 结果：array为[1,2,3,4,5,6]。
删除并替换一个元素：
var array = [1,2,2,4,5]; array.splice(2,1,3); 结果：array为[1,2,3,4,5]。
取数组的后几个元素：
var array = [1,2,2,4,5]; array.slice(-1); // 倒数第一个元素 array.slice(-2); // 倒数第二个元素 结果：array为[5]。
结果：array为[4,5]。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a78b41e7819ce3d09e6a885ee55b05e/" rel="bookmark">
			devops开发运维一体化_云原生、微服务、容器、DevOps概念扫盲，资深技术人员请回避！...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着企业数据量持续增长、业务系统日趋复杂、市场竞争日趋激烈，用户需求需要得到越来越及时的响应，用户服务需要不间断地进行。但采用的传统的云计算服务模式，即按照传统模式开发业务系统然后部署到云上，会使得云计算按需定制、弹性伸缩等优势难以充分发挥。为解决以上问题，“云原生”就此诞生。 云原生是指专门为在云平台部署和运行而设计的应用及架构，包括十二项基本要素，分别是：
1.同一应用对应同一套基准代码，并能多次部署；
2.显式声明第三方依赖；
3.将配置存储至环境变量；
4.将后端服务作为松耦合的资源；
5.严格分离构建阶段与运行阶段；
6.将应用作为无状态的进程运行；
7.通过端口绑定对外发布服务；
8.能够通过水平伸缩应用程序进程来实现并发；
9.可以快速启动和关闭应用；
10.要保持开发环境与生产环境等价；
11.使用事件流处理日志；
12.将后台管理任务当做一次性进程运行。 更具体来说，云原生涉及一系列技术，典型技术包括以Docker和Kubernetes编排工具为主的容器技术、以Service Mesh为发展方向的微服务技术，以及以快速迭代、持续交付为目的的DevOps(开发运维一体化)技术。
关于容器技术。
容器是指将应用程序及其环境一起打包作为交付物，该交付物可以随时构建、装载、运行。由于其它类型容器(如RKT)市场占比较低，容器一般指Docker。
容器编排工具是指让集群中的多个容器能够按计划、有组织运行的工具。Kubernetes作为CNCF孵化项目，相比Mesos和Swarm已经呈现出十分明显的优势。
传统虚拟机包含完整的操作系统，一旦开启即对硬件资源的一部分独占。容器引擎只是一个隔离的进程，对资源并不独占，因此是一种更轻量的虚拟化。这使得容器在文件体积、启动速度、占用资源和开启数量上都具有明显优势。
容器将依赖环境一起打包，因而屏蔽了开发、测试和运行环境的差异，再加上秒启、可多开的特性，使得微服务和DevOps均得以实现。所以可以说，容器技术是云原生的最佳载体，成为云原生的基石 关于微服务。
采用化整为零的概念，将复杂的IT系统部署，通过功能化、原子化分解，形成一种松散耦合的组件，让其更容易升级和扩展。
每个应用组件将其自身功能以服务的形式展现出来，并按照预先定义的协议进行交互，各个服务组件之间是松耦合的。
某个应用组件的编程语言与技术选型不会影响主体应用，如某个服务组件可以用Java 开发，而另一个可以用.NET开发。
每个服务组件都可以享有自己的数据库，且该数据库仅供该服务组件自己使用，其他服务组件都不能读取或者修改。
每个服务组件都是可以自行部署和测试的，任何一个服务组件在测试、部署和运行的时候都不依赖其他服务组件。
任何一个服务组件的故障都应该是隔离的，单个服务组件的故障不应该拖垮整个应用，也不应该影响其他服务组件。
微服务是云原生的实现方式，不仅涉及技术架构，还涉及业务怎么划分以及组织如何管理，如不同步规划将无法发挥其价值。 关于DevOps。
随着企业IT系统越来越复杂，功能迭代、局部升级、A/B Test甚至版本回滚成为常态，这都对开发、运维模式提出了新挑战，DevOps应运而生。
DevOps即开发运维一体化，是敏捷开发的继承和发展，目的是持续集成、持续交付，贯穿于开发到上线的始终。
DevOps因Docker的使用而更加简单，所以完整的DevOps体系中会包含Docker、Kubernetes等工具。
DevOps和微服务很多技术都是重合的，但两者的关注点并不同，微服务帮助我们以一种细颗粒度的方式开发、测试和发布服务，而DevOps提倡小规模和小批量的持续集成和持续部署，两者相辅相成的，共同解决问题；
DevOps进一步增强了云原生的敏捷特性，但其同样对企业内部的业务职责划分和组织架构调整提出了要求。 总结一下，容器+微服务+DevOps是实现云原生的最佳组合，但只有容器是一种比较明确的技术，而微服务和DevOps更像是一种方法论，仅仅有技术层面的配合是远远不够的，还需要有组织架构层面以及管理流程层面的共同配合才能发挥作用。 创作不易，欢迎朋友们关注、评论、转发。如企业转载或其它，请联系：keji5u(科技无忧订阅号)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e620dc1c60c408969078983f3fa92c2/" rel="bookmark">
			opencv（C&#43;&#43;）像素存储原理与操作（入门）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、像素点存储方式总结 前言 今天是opencv刚入门不久，学习起来更是摸不着头脑。想使用图片做个卷积运算，但是却不知道像素点的存储原理是怎么样的。最后自己写程序自己调试出来。最后总结一下自己的心得。
一、像素点存储方式 像素采用RGB方式存储，经过代码测试发现一个像素点（蓝，绿，红）。
代码如下（示例）：
#include &lt;iostream&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; using namespace cv; using namespace std; int main() { Mat img = Mat::zeros(10, 10, CV_8UC(3)); //自定义一张图片，初始像素值为0 namedWindow("原图", WINDOW_NORMAL); cout&lt;&lt; "img = " &lt;&lt; img &lt;&lt; endl; imshow("原图", img); Mat dst = Mat::zeros(img.size(), img.type()); //初始化目标图片，图片大小和类型和原图的一样 uchar * output = dst.ptr&lt;uchar&gt;(); //定义指针操作图片像素 //注释坐标从“1”开始（注意不是“0”） output[0] = 255;	//操作第1行第1列（1,1）的像素点的蓝色通道 output[1 + dst.cols*dst.channels()] = 255;//操作第2行第1列（2,1）的像素点的绿色通道 output[2 + 2*dst.cols*dst.channels()] = 255;//操作第3行第1列（3,1）的像素点的红色通道 output[3*dst.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e620dc1c60c408969078983f3fa92c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95e92a5b729f74494bdacae0c843d6ec/" rel="bookmark">
			密码学中的“盐值 Salt”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么要在密码里加点“盐” 盐（Salt）
在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。
以上这句话是维基百科上对于 Salt 的定义，但是仅凭这句话还是很难理解什么叫 Salt，以及它究竟起到什么作用。
第一代密码 早期的软件系统或者互联网应用，数据库中设计用户表的时候，大致是这样的结构：​
mysql&gt; desc User; +----------+--------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+--------------+------+-----+---------+-------+ | UserName | varchar(50) | NO | | | | | PassWord | varchar(150) | NO | | | | +----------+--------------+------+-----+---------+-------+ 数据存储形式如下：
mysql&gt; select * from User; +----------+----------+ | UserName | PassWord | +----------+----------+ | lichao | 123 | | akasuna | 456 | +----------+----------+ 主要的关键字段就是这么两个，一个是登陆时的用户名，对应的一个密码，而且那个时候的用户名是明文存储的，如果你登陆时用户名是 123，那么数据库里存的就是 123。这种设计思路非常简单，但是缺陷也非常明显，数据库一旦泄露，那么所有用户名和密码都会泄露，后果非常严重。参见《CSDN 详解 600 万用户密码泄露始末》。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95e92a5b729f74494bdacae0c843d6ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6fcdc5975a8058c90554acdc129b5f0/" rel="bookmark">
			解决Latex中文环境下使用\textbf{}无法加粗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		尝试了多种方法都不行，后来才发现没有引入包：\usepackage{ctex}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07704baab43d48091efcdd5503597cf9/" rel="bookmark">
			JS获取屏幕宽高属性总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		平时在写界面获取屏幕、浏览器宽高时，经常会搞不清楚window、body、screen中的clientWidth、offsetWidth、width的区别，今天做一个总结帮助自己理解。
window、document、screen、body、documentElement的关系 window是浏览器中JavaScript的顶层对象，所有全局变量与函数都是window对象的成员，而document也是window的对象，表示当前的浏览器载入的网页（DOM树）。比如像window.alert() = alert()、window.document.body.clientWidth=document.body.clientWidth。
screen也是window的对象，表示当前浏览器所在的屏幕。
documentElement和body，前者是指文档的html元素对象，后者指文档的body对象
window相关宽高属性 innerWidth：浏览器窗口内部宽度（包含垂直滚动条）innerHeight：浏览器窗口内部高度（包含水平滚动条）outerWidth：整个浏览器窗口的宽度outerHeight：整个浏览器窗口的高度 document相关宽高属性 相关的有3类属性：
client相关offset相关scroll相关 client相关属性 document.body.clientWidth：body的宽度（padding + content，不包含滚动条）document.body.clientHeight: body的高度 offset相关属性 document.body.offsetWidth：body包含border的宽度（padding + content + border）document.body.offsetHeight：body包含border的高度 scroll相关属性 document.body.scrollWidth：body可滚动的宽度，包括overflow溢出看不到的内容document.body.scrollHeight：body可滚动的高度，包括overflow溢出看不到的内容 documentElement与使用body类似，将以上body改为documentElement，测量宽高的元素就是html了。
看个例子，设置了reset.css后，设置当前页面的css
body { font-family: "sans-serif"; height: 800px; border: 40px solid orange !important; } screen相关宽高属性 screen.width：屏幕宽度，浏览器最大化时的最大宽度screen.height：屏幕高度，浏览器最大化时的最大高度screen.availWidth：浏览器可使用的屏幕最大水平宽度screen.availHeight：浏览器可使用的屏幕最大的垂直高度 如果对你有帮助的话，点赞、评论、收藏、赞赏都是对我的鼓励，也是支持我写下去的动力，笔芯~
本文原创发布于微信公众号「程序员张晴天」，欢迎关注第一时间获取最新分享，一起进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/842596c9b2de9a7a2e5d637343a21c0c/" rel="bookmark">
			c# 使用winform内嵌浏览器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c# 使用winform内嵌浏览器 前言：用WebBrowser使用谷歌内核出现问题，改用CefSharp，简单方便
nuget包
2.编写代码放在窗体加载事件 Cef.Initialize(new CefSettings()); string Url = ConfigurationManager.AppSettings["Url"]; ChromiumWebBrowser webBro = new ChromiumWebBrowser(Url); this.Controls.Add(webBro); webBro.Dock = DockStyle.Fill; 3.引用命名空间 完事（注意Url配置在配置文件上面了）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00d8b146222cbb420a9a7d84100070f/" rel="bookmark">
			mac版python3.7安装教程_M是什么意思_M的翻译_音标_读音_用法_例句_爱词霸在线词典...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全部
四级
六级
高考
I'm so tired. I can hardly see straight.
出自-2013年12月听力原文
They are both really good here.
出自-2013年12月听力原文
On New Year's Eve, Russians have the world's latest bedtime, hitting the hay at around 3:30 a.m.
2015年12月四级真题（第三套）阅读 Section C
The big meal came at around 1 p.m.
2016年6月四级真题（第二套）阅读 Section C
Federation of American Societies for Experimental Biology recommended that every postdoctoral researcher put together an IDP m consultation with an adviser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a00d8b146222cbb420a9a7d84100070f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fa51dc39392f0882ba40ca269f0d88b/" rel="bookmark">
			Restful请求之@PutMapping使用总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接收方法中的注解常见注解： @PathVariable（路径变量）注解的使用
带占位符的 URL 是 Spring3.0 新增的功能,该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义。
@PathVariable(“xxx”)
通过 @PathVariable 可以将URL中占位符参数{xxx}绑定到处理器类的方法形参中@PathVariable(“xxx“)
@RequestMapping(value=”user/{id}/{name}”)
请求路径：http://localhost:8080/hello/show5/1/james
@RequestParam：
@RequestParam：将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）
语法：@RequestParam(value=”参数名”,required=”true/false”,defaultValue=””)
value：参数名
required：是否包含该参数，默认为true，表示该请求路径中必须包含该参数，如果不包含就报错。
defaultValue：默认参数值，如果设置了该值，required=true将失效，自动为false,如果没有传该参数，就使用默认值
@RequestBody
@requestBody注解常用来处理content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型。@RequestBody接受的是一个json格式的字符串，一定是一个字符串。
GET、POST方式提时， 根据request header Content-Type的值来判断:
① application/x-www-form-urlencoded， 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）
②multipart/form-data, 不能处理（即使用@RequestBody不能处理这种格式的数据）
③ 其他格式， 必须（其他格式包括application/json, application/xml等。这些格式的数据必须使用@RequestBody来处理）；
PUT方式提交时， 根据request header Content-Type的值来判断:
application/x-www-form-urlencoded， 必须；
multipart/form-data, 不能处理；
其他格式， 必须；
说明：request的body部分的数据编码格式由header部分的Content-Type指定；
注意：
前端的请求头中的Content-Type设置的是json格式的，而json格式需要对应post请求的接口参数需要对应是@RequestBody；
如果想使用RequestParam，那么则需要前端的Content-Type要设置成application/x-www-form-urlencoded类型。
@PostMapping 更新或者查询请求 前端请求示例：
export function getTreeAll (id) { return request({ url: '/api/sys/dept/tree/gettreeall', method: 'post', params: { id } }) } 后端接收示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fa51dc39392f0882ba40ca269f0d88b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56287c9b05e5c6f3da6b0baec7e2a0d7/" rel="bookmark">
			相机与imu的标定(Kalibr)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行vio算法开发前最重要的事是对设备内参外参的标定，其准确性直接决定了算法的有效性．这里我将对最著名的kalibr标定工具的使用步骤进行说明，包括安装、相机标定、imu标定、相机与imu联合标定等步骤．
Kalibr安装 1. ros安装（支持ros indigo和ros kinetic版本） 2. 安装依赖 sudo apt-get install python-setuptools python-rosinstall ipython libeigen3-dev libboost-all-dev doxygen libopencv-dev ros-indigo-vision-opencv ros-indigo-image-transport-plugins ros-indigo-cmake-modules python-software-properties software-properties-common libpoco-dev python-matplotlib python-scipy python-git python-pip ipython libtbb-dev libblas-dev liblapack-dev python-catkin-tools libv4l-dev sudo pip install python-igraph --upgrade 3. 创建工作空间 mkdir -p ~/kalibr_workspace/src cd ~/kalibr_workspace source /opt/ros/indigo/setup.bash catkin init catkin config --extend /opt/ros/indigo catkin config --merge-devel # Necessary for catkin_tools &gt;= 0.4. catkin config --cmake-args -DCMAKE_BUILD_TYPE=Release 4. clone源码 cd ~/kalibr_workspace/src git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56287c9b05e5c6f3da6b0baec7e2a0d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d928c064d05ca6932c14e381c85ea48/" rel="bookmark">
			SpringMVC 拦截器(Interceptor)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.　拦截器方法 方法名说明preHandle()该方法在请求处理之前执行, 返回值是boolean类型, 当返回false时, 表示请求结束, 后续的方法不在执行. 当返回值为true时就会调用下一个Interceptor的preHandle方法postHandle()该方法在请求处理之后被调用, 前提是preHandle方法的返回值为true时才执行. 且它会在DispatcherServlet进行视图返回渲染之前被调用, 所以我们可以在这个方法中对Controller处理之后的ModelAndView对象进行操作afterCompletion()该方法在整个请求结束之后执行, 也就是在DispatcherServlet渲染了对应的视图之后执行, 前提是preHandle方法返回true 2. 编写代码测试 2.1 添加依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.2 编写SpringMVC核心配置文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 组件扫描 --&gt; &lt;context:component-scan base-package="site.zhouyun.controller" /&gt; &lt;!-- 开启注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d928c064d05ca6932c14e381c85ea48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/007d564da80994609428b1c5faa37b90/" rel="bookmark">
			SpringMVC 单个或多个文件上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 添加依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2. 编写SpringMVC核心配置文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="site.zhouyun.controller" /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件上传解析器 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 最大上传大小, 单位byte --&gt; &lt;property name="maxUploadSize" value="5242880" &gt;&lt;/property&gt; &lt;!-- 默认编码 --&gt; &lt;property name="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/007d564da80994609428b1c5faa37b90/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8039a750f4ad7c24c17eca52dd6d6fdf/" rel="bookmark">
			使用python&#43;sqlalchemy把温湿度传感器的数据通过usb串口存到sqlite
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://dsx2016.com/?p=1472
公众号：大师兄2016
前言 已经完成了前期的几个操作
Arduino Software (IDE) 开发环境已配置好,实现Hello World,程序正常编译
使用DHT11和Arduino获取房间中的温度和湿度数据(需要了解基本电路,先点灯,灯亮再试传感器)
使用python实现win10系统和arduino usb串口通信(蓝牙和wifi都暂时不考虑,usb通信优先)
上述步骤能够正常拿到温湿度数据,并且传递给win10系统
本文接着描述如何通过python+sqlalchemy把数据存到sqlite数据库(后期再写接口把温湿度提供给前端可视化)
操作 1.安装sqlalchemy
pip install SQLAlchemy 2.创建数据库和表
# 引入sqlalchemy中相关模块 from sqlalchemy import create_engine, MetaData from sqlalchemy import Column, Integer, String, Table from sqlalchemy.ext.declarative import declarative_base ​ # 连接数据库(有会自动忽略,无会自动创建) engine = create_engine('sqlite:///thermometer.db', echo=True) # 基本类 Base = declarative_base() ​ # 表要继承基本类 # 设置温湿度数据的类 class Thermometer(Base): __tablename__ = 'thermometer' # 表的名字 ​ # 定义各字段 id = Column(Integer, primary_key=True) # 温度 temperature = Column(String(3)) # 湿度 humidity = Column(String(3)) # 时间戳 timestamp = Column(String(20)) ​ def __str__(self): return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8039a750f4ad7c24c17eca52dd6d6fdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e67b55370c578eecefd2023769f8b49/" rel="bookmark">
			springsecurity_Spring Security
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Security 一、 Spring Security 简介 1 概括 Spring Security 是一个高度自定义的安全框架。利用 Spring IoC/DI 和 AOP 功能，为系统提供了声明式安全访问控制功能，减少了为系统安全而编写大量重复代码的工作。 使用 Spring Secruity 的原因有很多，但大部分都是发现了 javaEE的 Servlet 规范或 EJB 规范中的安全功能缺乏典型企业应用场景。同时认识到他们在 WAR 或 EAR 级别无法移植。因此如果你更换服务器环境，还有大量工作去重新配置你的应用程序。使用 Spring Security解决了这些问题，也为你提供许多其他有用的、可定制的安全功能。 正如你可能知道的两个应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两点也是 Spring Security 重要核心功能。“认证”，是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统），通俗点说 就是系统认为用户是否能登录。“授权”指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情。 2 历史 Spring Security 以“The Acegi Secutity System for Spring” 的名字始于 2003 年年底。其前身为 acegi 项目。起因是 Spring 开发者邮件列表中一个问题，有人提问是否考虑提供一个基于 Spring 的安全实现。限制于时间问题，开发出了一个简单的安全实现，但是并没有深入研究。几周后，Spring 社区中其他成员同样询问了安全问题，代码提供给了这些人。2004 年 1 月份已经有 20 人左右使用这个项目。随着更多人的加入，在 2004 年 3 月左右在 sourceforge 中建立了一个项目。在最开始并没有认证模块，所有的认证功能都是依赖容器完成的，而 acegi 则注重授权。但是随着更多人的使用，基于容器的认证就显现出了不足。acegi 中也加入了认证功能。大约 1 年后 acegi 成为 Spring子项目。在 2006 年 5 月发布了 acegi 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e67b55370c578eecefd2023769f8b49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd6ef5901f23e71817c783426b1b85ec/" rel="bookmark">
			group by很多字段是不是会很慢_为什么你的SQL执行很慢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL语句执行很慢原因分析 先来回答第一个问题，如果一条SQL语句执行会很慢，会有哪些可能的原因。为了方便说明问题，这里先给出建表语句和初始化语句：
CREATE TABLE `t` ( `id` int(10) NOT NULL AUTO_INCREMENT, `a` int(10) DEFAULT NULL, `b` varchar(16) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_a` (`a`), KEY `idx_b` (`b`)) ENGINE=InnoDB;insert into t values (null, 1,'1');insert into t values (null, 2,'2');insert into t values (null, 3,'3'); 1.没走索引
首先，绝大部分人都能想到的一点就是SQL语句没有走索引。明明给相关字段加了索引，可为什么就是不走索引呢？极大概率是因为索引失效了，以下场景都有可能导致索引失效。
1.1对索引字段进行了计算操作
看这个例子：
为什么对索引字段进行了计算操作之后，就不会走索引了呢？
这里我们需要明白，走索引的本质其实是利用了B+树的有序性以便进行快速定位。但是对索引字段进行计算操作之后，有可能会破坏这种有序性(非线性计算)，导致无法利用B+树的这一特性，因此优化器会放弃使用B+树的树搜索功能。
注意，这里要特别强调的是，这种情况下优化器只是放弃了树搜索的能力，而并不是一定会放弃走索引。什么意思呢？请继续看这个例子：
你看，在这个例子中，虽然依然对索引字段a做了计算操作，但是最终优化器还是走了索引idx_a。从执行计划还可以看出，优化器对该索引做了全索引扫面，且使用了覆盖索引。之所以没有选择遍历主键索引，是因为辅助索引更小，且可以利用覆盖索引。
所以，正确的姿势应该是这样的，把函数计算放在变量上：
1.2存在隐式类型转换
我们知道，MySQL中数字和字符串之间可能存在隐式类型转换，很多人都认为当发生隐式类型转换的时候，就不会走索引。真的是这样吗？我们来看两个例子：
在上面两个例子中，字段a和b其实都发生了隐式类型转换，但是结果却不一样。这是因为在MySQL中，当发生字符串和数字比较的场景时，会把字符串隐式转换为数字。
1.3 like操作
在like操作中，当%在前面时，也不会走索引。
1.4隐式编码转换
前面3种没有走索引的场景很多人都能答得上来，但还有一种比较不常见的，也是丁奇老师在他的课程中提到的隐式编码转换场景。
在MySQL中，每张表都可以单独指定其字符集，最常见的就是utf8和utf8mb4了，当两张表字符集不同时，进行联表操作会存在字符集转换，从而导致索引失效。这里不展开，具体可以参考丁奇老师的课程。
1.5 not in 操作
MySQL5.6之前的版本，not in操作也会导致索引失效。但在MySQL5.6引入ICP优化之后，not in操作也是可以走索引的，请看：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd6ef5901f23e71817c783426b1b85ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99aae2bd6e25306417f841eeee4d813c/" rel="bookmark">
			Flink流处理API之Sink
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flink流处理API 代码主要分为四个模块：environment， source，transform，sink
Sink flink中对外的输出都要利用sink的完成
Kafka object KafkaSinkTest { def main(args: Array[String]): Unit = { val env = StreamExecutionEnvironment.getExecutionEnvironment env.setParallelism(1) val dataStream = env.readTextFile("E:/qmlidea/flink/src/main/resources/sensor.txt") val dataStream2 = dataStream.filter(x =&gt; !x.isEmpty) .map(data =&gt; { val dataArray = data.split(",") SensorReading(dataArray(0).trim, dataArray(1).trim.toLong, dataArray(2).trim.toDouble).toString }) dataStream2.addSink(new FlinkKafkaProducer[String]("192.168.0.80:9092", "qml", new SimpleStringSchema())) env.execute("kafka sink test") } } 依赖版本对应： Redis object RedisSinkTest { def main(args: Array[String]): Unit = { val env = StreamExecutionEnvironment.getExecutionEnvironment env.setParallelism(1) val dataStream = env.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99aae2bd6e25306417f841eeee4d813c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2965d68e18ce15b6b51411ba866bff23/" rel="bookmark">
			C语言 考试座位号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。
输入格式：
输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。
考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。
输出格式：
对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。
输入样例：
4 3310120150912233 2 4 3310120150912119 4 1 3310120150912126 1 3 3310120150912002 3 2 2 3 4 输出样例：
3310120150912002 2 3310120150912119 1 代码：
#include&lt;stdio.h&gt; int main() { int i,n; scanf("%d",&amp;n); //考生人数总数 long long a[n]; //用于存储准考证号 int b[n][2]; //用于存储试机座位号 考试座位号 for(i=0;i&lt;n;i++) { scanf("%lld %d %d",&amp;a[i],&amp;b[i][0],&amp;b[i][1]); } int m; //查询人数 scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2965d68e18ce15b6b51411ba866bff23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/853c640565ee9b1ce3280345eab1cb56/" rel="bookmark">
			SpringClound-SpringCloundAlibaba-SpringBoot版本对应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cef055a59a670554842ca6f7caf6d61/" rel="bookmark">
			jMeter单独运行每个线程组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：此方式是下个线程组只能等上个线程组全部彻底迭代完成才会执行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ca6295b1bbb2ca7417d83cc01c7ca52/" rel="bookmark">
			ArcGIS Pro中如何对矢量切片进行属性查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到用户咨询ArcGIS Pro中如何对矢量切片进行Identify，也就是如何实现在地图上点击vtpk时弹出属性。我们知道切片图层一般是无法弹出属性的，但是矢量切片却是可以的，但这种可以是有前提的，也就是是需要进行设置的，可以分为两种方法。本文以ArcGIS Pro 2.6为例进行介绍。
法一、通过关联web feature layer方式实现 顾名思义，这种方法需要关联一个事先发布的服务图层，在点击vtpk时获取的是该服务中的属性信息，具体步骤如下：
1，先将想要查询的要素类发布为要素服务，然后创建含有该要素类的vtpk；
2，ArcGIS Pro中加载该vtpk，图层目录中选中该图层，右键-&gt;点击Set Pop-up Source，弹出下面窗体，可以从组织中选择Item，也可以按指定URL加载。我们这里使用的是之前发布好的要素服务的URL，回车，然后点击Set Pop-up Source:
3，图层右键-&gt;点击Enable Pop-ups:
接下来就可以对该矢量切片图层进行点击查询了：
如果您觉得这种方法需要事先发布服务比较麻烦的话，那么可以使用方法二，该方法不需要关联服务。
法二、直接从矢量切片中获取 该方法不需要关联已有服务图层，也就是不需要事先发布服务，但是需要在打包vtpk之前做些什么：
1，在原始要素图层处右键-&gt;Design-&gt;Fields
弹出Fields窗体，勾选上想要显示出属性的字段的Highlight属性，保存。
Tips：这里一定要勾选OBJECTID字段，不然是无法点击查询的。
2，将含有该图层的Map打包为vtpk。
3，ArcGIS Pro中加载该vtpk，图层右键-&gt;Enable Pop-ups
然后就可以对该vtpk进行点击查询了，如下图：
不知道您注意到了没，这时属性窗体中显示的属性值就是刚刚Highlight的哪几个字段。这种方法相比第一种更简便，详细信息请参考ArcGIS Pro帮助。
上面我们介绍了在ArcGIS Pro中对vtpk进行点选查询的两种方法，那么如何在Portal中查询呢？
Portal中对矢量切片的查询并不能通过上述方法，最简单的方法就是叠加一个要素服务图层，将其颜色设置为透明，然后进行点选查询，实际上是查询的要素服务的属性。
1， 将vtpk发布为矢量切片服务，然后将该服务和之前的要素服务添加到Map上。
2，设置要素服务的透明度为透明：
点击查询：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d3c5113c67a9075c40dc63baf357489/" rel="bookmark">
			Factory method ‘sqlSessionFactory‘ threw exception； nested exception is java.lang.NoSuchMethodError:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot 引入mybatis-plus后报错：
Factory method ‘sqlSessionFactory’ threw exception; nested exception is java.lang.NoSuchMethodError: com.baomidou.mybatisplus.entity.GlobalConfiguration.getWorkerId()Ljava/lang/Long;
org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)
Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 13:48:24.428 ERROR o.s.boot.SpringApplication [845] - Application run failed org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'goodsController': Unsatisfied dependency expressed through field 'goodsService'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'goodsService': Unsatisfied dependency expressed through field 'baseMapper'; nested exception is org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d3c5113c67a9075c40dc63baf357489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c301b3c4fad7706f3c22b64203f0a41/" rel="bookmark">
			DefaultIdentifierGenerator 雪花算法 生成 重复 id 解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DefaultIdentifierGenerator 雪花算法 生成 重复 id 前言问题发生排查原因问题解决 前言 利用 mybatisplus 的 DefaultIdentifierGenerator 生成 id 当做主键，人家的代码没有问题，是自己程序代码问题导致。
问题发生 利用 mybatisplus 的 DefaultIdentifierGenerator 生成 id 当做主键，然后批量新增数据后，丫的报错了
BatchUpdateException: Duplicate entry '1331426208168046594' for key 'PRIMARY'" 主键冲突！！！！
可是创建的 id 是用方法生成了啊 (ノへ￣、)
private Number createId() { IdentifierGenerator identifierGenerator = new DefaultIdentifierGenerator(); return identifierGenerator.nextId(new Object()); } 排查原因 接下来就是排查原因了，首先看一下它源码是怎么生成数据的。
首先看到了锁，java 在jdk1.6之后优化了 synchronized ，使得它不会是直接变成重量级锁，所以调用此方法并不会有并发问题，且对同一毫秒的判断序列号也自增了，理论上并不会出现重复id的情况。
观察一遍发现问题所在。
它的 时间判断参数是一个成员变量，生命周期跟着 当前类走。
而调用的方法并不是个单例模式，所以每次新建一个对象，其内部判定的时间判断参数都是独立存在的，这样的话在并行程序的过程中，是有可能生成相同的id的。
原本怀疑是否是使用了 java 8 的 stream 的原因。然而发现，人家默认就是串行流，要使用并行流是需要而外加方法的，所以和这个没有关系。
问题解决 有两种方式解决：
写一个 IdentifierGenerator util ，既然 DefaultIdentifierGenerator 的 Sequence 不是单例，那么我们就在外层做操作，把调用到的 IdentifierGenerator 变成单例。IdWorker 这个类是 MyBatis Plus 雪花算法的实现，直接调用其方法获取，它内部是单例实现的。ps（若没有特殊需求，用官方提供的就好了） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e676af20eddbf331ded45dc34622228/" rel="bookmark">
			linux下gdb的安装及查看方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux下gdb的安装方法 gdb是Linux环境下的代码调试工具，其安装步骤如下：
安装 step1：首先检查系统中有没有安装过，有的话用一下命令卸载gdb旧版本
step2：在网址：http://ftp.gnu.org/gnu/gdb下载gdb源码包（这里楼主选的是8.0.1版本）；
或者直接在linux系统中用wget命令下载：wget http://ftp.gnu.org/gnu/gdb/gdb-8.0.1.tar.gz
会下载到当前目录下。
将源码包放在home目录的Download目录中。
step3：打开Download目录，用tar -zxvf 命令解压缩你下载的源码包
step4：.用以下命令生成makefile文件 1. ./configure
2.make（这个需要的时间比较长，耐心等待哟~）
3.sudo make install
4.查看安装是否成功：gdb -v
完成！
查看core文件
产生core文件后，就可以利用命令gdb进行查找。
切换到core文件所在的目录，输入命令：gdb ./test core-test-26795-1519971969
参数一是应用程序的名称，参数二是core文件，展示错误内容，如下图所示：
（gdb）后输入where，就会看到程序崩溃时堆栈信息（当前函数之前的所有已调用函数的列表（包括当前函数），gdb只显示最近几个
本文转载自：https://blog.csdn.net/chengsi101/article/details/79424083
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e7c28b86a525830962ce9513400b1bc/" rel="bookmark">
			功能测试宏的参数必须是简单标识符_【Just For Fun】C - 宏开发 - 建立唯一的变数名称, __COUNTER__...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Just For Fun】 本系列纯粹娱乐、研究用。一些旁门左道的东西。 事实上可能完全没用。 (๑•̀ω•́๑) ▌前置知识： 【Just For Fun】C - 预处理器、宏 #, ##、预先定义的宏
▌什么是 __COUNTER__ ？ 预定义宏 ( Predefined Macros ) 的其中之一，这是编译器拓展，gcc, vs 都支援。
根据某某 GCC.GNU 的文档，
This macro expands to sequential integral values starting from 0. In conjunction with the ## operator, this provides a convenient means to generate unique identifiers. Care must be taken to ensure that __COUNTER__ is not expanded prior to inclusion of precompiled headers which use it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e7c28b86a525830962ce9513400b1bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca487b26b3ead1b9e8381e1746f17333/" rel="bookmark">
			逻辑回归—C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇介绍目前为止的最后一个算法，逻辑回归。后边如果有机会可能会继续更新。
同样使用随机梯度下降法。
算法介绍 模型可以如下表示：
y h a t = e b 0 + b 1 × x 1 1 + e b 0 + b 1 × x 1 yhat = \frac{e^{b0+b1×x1}}{1+e^{b0+b1×x1}} yhat=1+eb0+b1×x1eb0+b1×x1​
可简化为(简单数学计算即可)
y h a t = 1.0 1.0 + e − ( b 0 + b 1 × x 1 ) yhat = \frac{1.0}{1.0+e^{-(b0+b1×x1)}} yhat=1.0+e−(b0+b1×x1)1.0​
更新方程：
b = b + l e a r n i n g r a t e × ( y − y h a t ) × y h a t × ( 1 − y h a t ) × x b = b+learning\space rate × (y-yhat)×yhat×(1-yhat)×x b=b+learning rate×(y−yhat)×yhat×(1−yhat)×x
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca487b26b3ead1b9e8381e1746f17333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edeaf071d43cab04d900a041216a0c56/" rel="bookmark">
			多元线性回归—C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇已经介绍过简单线性回归了，这篇介绍第二个算法，多元线性回归，仅介绍两个主要函数：预测函数和训练函数。
算法介绍 模型可以如下表示：
y = b 0 + b 1 × x 1 + b 2 × x 2 + . . . y = b_0+b_1×x_1+b_2×x_2+... y=b0​+b1​×x1​+b2​×x2​+...
随机梯度下降法 多元线性回归采用的是随机梯度下降方法，该方法具体介绍同样自行百度，在这里不做详细介绍。仅介绍C语言实现方法
这里给出更新方程：
b = b − l e a r n i n g r a t e × e r r o r × x b = b-learning\space rate × error × x b=b−learning rate×error×x
函数 读取csv 以下三个函数分别为获取行数、获取列数、获取文本内容。 double **dataset; int row,col; int get_row(char *filename)//获取行数 { char line[1024]; int i = 0; FILE* stream = fopen(filename, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edeaf071d43cab04d900a041216a0c56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/763411db9617b256909f0d62f657d3b3/" rel="bookmark">
			简单线性回归—C语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单线性回归应该是最简单的机器学习算法了，在这里主要介绍一下算法主要函数的C语言实现，具体算法原理简单一提，如果要学习，可以自行百度。
算法介绍 模型可以如下表示：
y = b 0 + b 1 × x y = b_0 + b_1 × x y=b0​+b1​×x
训练主要依据以下公式：
B 1 = ∑ i = 1 n ( ( x i − m e a n ( x ) ) × ( y i − m e a n ( y ) ) ) ∑ i = 1 n ( x i − m e a n ( x ) ) 2 B_1 = \frac{\sum_{i=1}^{n}{((x_i - mean(x))×(y_i - mean(y)))}}{\sum_{i=1}^{n}{(x_i - mean(x))^2}} B1​=∑i=1n​(xi​−mean(x))2∑i=1n​((xi​−mean(x))×(yi​−mean(y)))​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/763411db9617b256909f0d62f657d3b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7933abe3190aa4a5ed4a7ff7bd607002/" rel="bookmark">
			记账小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 ​ 现在是2020年11月23日
​ 最近时间比较多，一直想整理一下本科这两年开发的一些小作品，考虑到年后要准备考研，于是决定最近完成这项工作。
​ 首先发一个比较简单的，前段时间自己做的一个记账小程序，起因是觉得花钱太多，想记录一下日常花销，于是准备自己做一个自己专用的小程序，后来觉得只能自己用太没意思了，所以它最后面向了所有用户（如果有兴趣，欢迎体验）。
​ 先声明一下，我是数学专业的，做这个仅仅是因为如上所述，并非专业。所以有很多地方做的不是很成熟，还请大家见谅！好了，下面开始
目录 小程序功能介绍小程序视频展示小程序源码 小程序功能介绍 如果不想看，可以直接看下面的展示视频
一.记账页面 第一个页面，用于记账
1、价格显示 最顶端显示的是今日总价和本月总价，可以根据记账实时变化 2、记账功能 中间部分可以选择分类（只写了4类调试用）和支付方式。名称和价格可以自行输入输入完成后点击保存即完成一次记账，数据库会更新。清空则清除填入的内容。点击保存会自动检测输入的内容是否为空和是否合法。最下面的“今日已买”即显示今日已经记录的账单，可以实时变化。“今日”已买可以删除，点击对应删除按钮即从当前页面和数据库中删除这条账单记f录。 二、分析页面 第二个页面，主要用于账单分析，分为七日支出分析和本月分析
1、七日支出 记录了自昨日起的前七天的内容，包括七日平均日总价，七日总价，及七日账单价格走势图。查看详情和收藏分享本来打算后期开发，结果因为自己都懒得记账了，所以也至今也没有开发。不过说不定等后面哪天心血来潮可以会完成这项工作（可能性不大），如果完成了我会来更新的。 2、本月总计 记录了本月总价和本月的平均日总价饼状图显示了各个类别（记账时选择的类别）花销占的比例。 三、记账提醒功能 在小程序加载之初会向用户询问是否订阅用于每天向用户发送记账提醒。我这里设定的是每天晚上9:30用个人服务器自动向用户推送订阅，订阅内容包括 昨日支出，本月指出，本月收入（为了后续开发，在这里就提前加了）以及记账提醒。以上基本就是小程序的全部功能，接下来的视频会展示这些功能。 展示视频 [video(video-BUAcUt8l-1606225337098)(type-bilibili)(url-https://player.bilibili.com/player.html?aid=457920444)(image-https://img-blog.csdnimg.cn/img_convert/dded3534f915d122a859016745c9a8ff.png)(title-记账小程序展示)]
源码 源码我就不一一介绍了，直接全部放在下面了。源码中页面设计用到了vant-weapp插件。
在这里简单介绍一下整个小程序的架构：
小程序加载页面通过openid查询数据库是否有历史信息，如果没有，自动初始化该用户的数据库信息，完成后跳转至首页。如过有，直接跳转至首页。
此过程中会询问用户是否订阅。
记账页面
从云数据库中获取本日本月信息，存放到本地用于显示。
每次保存账单会同时对数据库和本地信息进行更新。
分析页面
从云数据库中获取本日本月信息，存放到本地用于显示。 源码如下
1、APP
app.js
//app.js/* /* */ var timestamp = Date.parse(new Date()), date = new Date(timestamp), //获取年份 year = date.getFullYear(), //获取月份 month = (date.getMonth() + 1 &lt; 10 ? '0' + (date.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7933abe3190aa4a5ed4a7ff7bd607002/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b004e844c7bd760621ad147141a67bb9/" rel="bookmark">
			关于novikoff定理成立的条件（感知机的收敛性）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读李航的《统计学习方法》时，读到了novikoff定理，内容如下：
我马上感到困惑，k怎么与学习率无关呢？难道学习率再小也能保证在此上界次数内学完？
研究公式发现，更新k次后得到超平面方程为
其中求和项内是每次（共k次）用来更新权重的误分类实例。
显然，如果，则可约去，此方程与学习率无关，那么总学习次数与也无关；
如果，则此方程与和都有关，总学习次数与和也都有关，这时公式（2.9）就未必成立了。那么究竟它还成不成立呢，让我们做个实验。
实验 假设训练数据集的正实例点是(3,3), (4,3)，负实例点是(1,1).
那么满足条件且使超平面将训练数据集正确分开，于是可求得，取。
又，易求得，于是.
设定，改变学习率，发现学习次数不变：
trainX = np.array([[3,3],[4,3],[1,1]], dtype=np.float64) trainY = [1,1,-1] for i in range(6): lr = 0.1**i w = np.array([0,0], dtype=np.float64) b = 0 sign = True cnt = 0 while sign: sign = False for x,y in zip(trainX, trainY): if y*(np.dot(w,x) + b) &lt;= 0: w += lr*y*x b += lr*y cnt += 1 sign = True break print(cnt) ’‘’运行结果： 7 7 7 7 7 7 ‘’‘ 设定，改变学习率，发现学习次数变化，且可能大于286：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b004e844c7bd760621ad147141a67bb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100f9bf9b3d40df57097ce33344aba65/" rel="bookmark">
			《综合项目：模块1--数仓系统》视频及资料更新到2.0版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多易教育，专注大数据培训； 课程引领市场，就业乘风破浪
多易教育官网地址
https://www.51doit.cn
多易教育在线学习平台
https://v.51doit.cn
各位线上视频学员，《综合项目模块1–数仓系统》视频及资料更新到2.0版，请到网盘下载新版。
\数仓\doit07-综合项目-模块1-数据仓库-day01
01.项目开发前置知识–git版本管理–gitee码云-提交-拉取-分支操作.wmv
02.项目背景介绍.wmv
03.项目背景介绍（2）.wmv
04.项目模块1-数仓介绍–字典数据构建需求.wmv
05.数据库和数据仓库等概念的厘清.wmv
06.项目开发工程骨架搭建和测试.wmv
07.项目开发–地理位置字典构建–geohash编码原理和工具包.wmv
08.项目开发–地理位置字典构建—代码实现（1）.wmv
09.项目开发–商圈字典构建—代码实现.wmv
10.项目开发–公司内部数据–流量日志详细解析.wmv
11.项目开发–内部数据预处理–需求说明.wmv
12.项目开发–内部数据预处理–代码骨架编写.wmv
13.高德地理位置服务api介绍.wmv
14.高德地理位置服务api-编写demo示例.wmv
\数仓\doit07-综合项目-模块1-数据仓库-day02
01.内部流量日志预处理代码实现（1）.wmv
02.内部流量日志预处理代码实现（2）.wmv
03.内部流量日志预处理代码实现（3）.wmv
04.自定义schema的方式让spark自动解析json数据为dataframe.wmv
05.数仓建模思想阐述–业务–需求–主题–分层.wmv
06.数仓ods层建模–建表–数据加载–检测.wmv
\doit07-综合项目-模块1-数据仓库-day03
01.sql关键语法复习梳理.wmv
02.流量分析-dwd_traffic_log表加工生成.wmv
03.流量分析-dwd_traffice_agg_session会话级别明细表.wmv
04.流量分析-流量概况维度报表-ads_traffic_summary_cube.wmv
05.用户分析–建模设计–详细过程.wmv
号外：如何拷贝涛哥的CDH虚拟机集群及网络配置.wmv
号外：补充两个hive的小技能–多重插入-动态分区.wmv
\数仓\doit07-综合项目-模块1-数据仓库-day04
01.olap数据立方体多维分析–hive高阶聚合函数–groupingset–cube.wmv
02.olap数据立方体多维分析–hive高阶聚合函数–grouping__id-rollup.wmv
03.用户分析–日新dws_user_dnu-日活dws_user_dau-历史记录dws_user_hisu-表开发.wmv
04.用户分析–日新人数多维报表-ads_user_dnu_cube.wmv
05.用户分析–日新日活加维度（周-月-季）–自动化shell脚本开发.wmv
06.截止今日的etl流程梳理–自动化脚本开发.wmv
\数仓\doit07-综合项目-模块1-数据仓库-day05
01.勘误：历史用户记录明细表-fulljoin-忘写条件.wmv
02.截止今日所有任务的脚本开发（2）.wmv
03.脚本总调度开发.wmv
04.用户分析–留存分析–建模设计.wmv
05.用户分析–留存分析–留存明细表计算.wmv
06.用户分析–活跃拉链表–建模和计算流程.wmv
07.用户分析–活跃拉链表–代码编写.wmv
\数仓\doit07-综合项目-模块1-数据仓库-day06
01.用户留存分析–建模设计–运算逻辑–拉链表计算逻辑复习梳理.wmv
02.报表开发–整体趋势报表–模型设计–计算流程梳理.wmv
03.报表开发–整体趋势报表–ads_overall_trend开发.wmv
04.报表开发–用户新鲜度报表-ads_user_fresh建模.wmv
05.报表开发–用户新鲜度报表-ads_user_fresh开发.wmv
06.报表开发–用户活跃留存报表-ads_user_act_retention.wmv
07.报表开发–用户活跃留存报表-方案2-with-as必须写在最前.wmv
08.报表开发–活跃用户成分分析报表（连续天数）-ads_user_act_ingredients.wmv
\数仓\doit07-综合项目-模块1-数据仓库-day07
01.报表统计-用户使用间隔分布统计-ads_user_interval-spark任务实现.wmv
02.报表统计-用户使用间隔分布统计-ads_user_interval-sql实现.wmv
03.事件分析主题–事件日志数据获取的背景介绍.wmv
04.事件分析主题–转化率（漏斗模型）概念详解–需求分析.wmv
05.事件分析主题–DWD层建模etl-dwd_event_detail.wmv
06.事件分析–事件概况报表-ads_event_overall.wmv
号外:mapreduce-shuffle环形缓冲区详解.wmv
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/100f9bf9b3d40df57097ce33344aba65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1e1f63db441f3162ffb47f3ebededa1/" rel="bookmark">
			按键精灵获取系统时间进行其他操作_「按键精灵」如何做一个自动打开APP进入注册页面自动输入手机号...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 按键精灵，虽然很早听过，但是一直没有真正使用过，所以最近有点时间也简单试一下，通过脚本自动清理APP缓存，打开百家号并自动进入注册页面输入自己的手机号。
软件清单
1. 雷电手机模拟器：https://www.ldmnq.com/
2. 按键精灵手机助手：http://download.myanjian.com/
扩展平台
1. 打码平台：http://www.fateadm.com/
2. 短信验证接收：http://www.51ym.me/
手机模拟器和按键精灵安装完毕后，使用按键精灵助手连接模拟，模拟器授权给精灵就可以正常调试了。这里也可以安装其他夜神模拟器等，或者直接USB连接手机，如果需要在真机上调试脚本需要手机安装了“按键精灵安卓版”和有ROOT权限。同时PC的按键精灵手机助手也可以将写好的脚本以及控制的UI界面打包成APK，目前是需要登录办理会员才可以，如果没有其他要求完全就在模拟器上运行脚本也可以。
实践步骤
1. 获取需要打开APP的包名，以下打开的是趣头条APP。
Dim bundleNamebundleName = Sys.GetFront()TracePrint bundleName 2. 完全关闭APP后再打开，以下可以理解是重启。
Sys.ClearAppCache "com.baidu.baijia" //先关闭当前百家号APPDelay 1000RunApp "com.baidu.baijia" //延时1秒打开百家号 3. 使用“抓抓”找特定图点进入需要跳转的页面。
Delay 3000Dim intX,intYFindPic 0,0,0,0,"Attachment:截图1.png 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d43208a208bc580b9a0093390ed58d8/" rel="bookmark">
			C#执行系统命令（CMD&amp;&amp;powershell）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CMD:
Process p = new Process(); p.StartInfo.FileName = "cmd.exe"; //p.StartInfo.Arguments = "/c C:\\Windows\\System32\\cmd.exe"; p.StartInfo.UseShellExecute = false; //是否使用操作系统shell启动 p.StartInfo.RedirectStandardInput = true;//接受来自调用程序的输入信息 p.StartInfo.RedirectStandardOutput = true;//由调用程序获取输出信息 p.StartInfo.RedirectStandardError = true;//重定向标准错误输出 p.StartInfo.CreateNoWindow = false;//不显示程序窗口 p.Start(); //向cmd窗口发送输入信息 p.StandardInput.WriteLine(cmd + "&amp;exit"); p.StandardInput.AutoFlush = true; //p.StandardInput.WriteLine("exit"); //向标准输入写入要执行的命令。这里使用&amp;是批处理命令的符号，表示前面一个命令不管是否执行成功都执行后面(exit)命令，如果不执行exit命令，后面调用ReadToEnd()方法会假死 //同类的符号还有&amp;&amp;和||前者表示必须前一个命令执行成功才会执行后面的命令，后者表示必须前一个命令执行失败才会执行后面的命令 //获取cmd窗口的输出信息 output = p.StandardOutput.ReadToEnd(); Powershell
引用：调用方法需要添加一个引用System.Management.Automation.dll
如果找不到可以到这个路径下找到：C:\windows\assembly\GAC_MSIL\System.Management.Automation\1.0.0.0__31bf3856ad364e35\System.Management.Automation.dll
在这里插入代码片 public static void RunPs(String cmd,QueuedMessageEventArgs e) { String rs = ""; using (Runspace runspace = RunspaceFactory.CreateRunspace()) { runspace.Open(); PowerShell ps = PowerShell.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d43208a208bc580b9a0093390ed58d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4897ed563e01a1726d36be15357850e/" rel="bookmark">
			Gitlab CI配置文件job的script中执行if、for等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 需要在Gitlab CI job的关键字script中执行一个if判断或者for循环等
问题描述： 初始配置是这样的
build-job: stage: deploy only: - develop script: - set +e - 一行一行的命令... - set -e if多行执行没报错，但每次啥都执行了
build-job: stage: deploy only: - develop script: - set +e - 一行一行的命令... - if [ "$latest_update_time" != "$formart_date" ] - then - echo “开始干活...” - fi - set -e 解决方案： 1、在shell脚本内执行
build-job: stage: deploy only: - develop script: - /bin/bash ./build.sh build.sh内容
#!/bin/bash if [ "$latest_update_time" != "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4897ed563e01a1726d36be15357850e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d2d49079a3833e309cc6685aed8a77a/" rel="bookmark">
			python语言例子_【Python】SimPy的使用示例-Go语言中文社区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用SimPY进行离散事件仿真
SimPY是一个Python下的第三方库，可以方便的进行离散事件的仿真。仿真速度比较快。下面记录一下我的一点心得，不保证完全正确，供参考。
安装
$ pip install -U simpy
pycharm可以再File | Settings | Project: Simulation | Project Interpreter中添加
主要概念
Environment
Process
Event
Resource
SimPY使用Environment，Process，Event，Resource四大概念来进行离散事件的仿真。
Environment就是整体仿真所在的时间，主要用于提取时间。
Process就是仿真过程中的实体，如：顾客， 设备， 车辆等。 Process本质上也是一个event。源代码里面可以看到是继承Event的一个类。
Event是仿真中触发的事件，可以理解为一个定时器。当定时器到时时，触发事件。
Resource是仿真中的资源，如ATM机，服务器等。
官方示例：
&gt;&gt;&gt; import simpy
&gt;&gt;&gt;
&gt;&gt;&gt; def clock(env, name, tick):
... while True:
... print(name, env.now)
... yield env.timeout(tick)
...
&gt;&gt;&gt; env = simpy.Environment()
&gt;&gt;&gt; env.process(clock(env, 'fast', 0.5))
&gt;&gt;&gt; env.process(clock(env, 'slow', 1))
&gt;&gt;&gt; env.run(until=2)
fast 0
slow 0
fast 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d2d49079a3833e309cc6685aed8a77a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f47f0d41a267fa12e90312fb1b7d958/" rel="bookmark">
			idle python_IDLE (Tk) - Python 中文开发手册 - 开发者手册 - 云&#43;社区 - 腾讯云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDLE是Python的集成开发和学习环境。
IDLE具有以下功能：
使用tkinterGUI工具包编码为100％纯Python
跨平台：在Windows，Unix和Mac OS X上大体相同
Python shell窗口（交互式解释器），具有代码输入，输出和错误消息的颜色
多窗口文本编辑器，多重撤销，Python着色，智能缩进，调用提示，自动完成和其他功能
在任何窗口中搜索，在编辑器窗口中进行替换，并搜索多个文件（grep）
具有持久性断点的调试器，步进以及查看全局和本地命名空间
配置，浏览器和其他对话框
1.菜单
IDLE有两种主要的窗口类型，Shell窗口和Editor窗口。可以同时拥有多个编辑器窗口。输出窗口（例如用于编辑/在文件中查找）是编辑窗口的子类型。它们目前与编辑器窗口具有相同的顶部菜单，但是具有不同的默认标题和上下文菜单。
IDLE的菜单根据当前选择的窗口动态更改。下面记录的每个菜单都指示与哪个窗口类型相关联。
1.1 文件菜单（Shell 和编辑器）
新建FileCreate一个新的文件编辑窗口。打开...用打开对话框打开一个现有的文件。最近的文件打开最近的文件列表。单击一个打开它。打开模块...打开一个现有的模块（搜索sys.path）。类浏览器显示当前编辑器文件中的函数，类和方法的树结构。在shell中，首先打开一个模块.Path BrowserShow sys.path树结构中的目录，模块，函数，类和方法。如果存在，则将当前窗口保存到关联的文件中。自打开或上次保存以来更改的Windows在窗口标题之前和之后都有*。如果没有关联的文件，请执行另存为。另存为...使用另存为对话框保存当前窗口。保存的文件成为窗口的新关联文件。保存副本为...
1.2 编辑菜单（Shell 和编辑器）
撤消撤消对当前窗口的最后更改。最多1000次更改可能会被撤消.RedoRedo最后一次撤消当前窗口的更改.CutCopy选择进入系统范围的剪贴板; 然后将selection.Copy选择删除到系统范围的剪贴板中。将系统范围的剪贴板的内容粘贴到当前窗口中。
剪贴板功能也可在上下文菜单中使用。
选择全部选择当前窗口的全部内容。查找...打开具有多个选项的搜索对话框查找再次重复上次搜索，如果有的话。找到SelectionSearch为当前选定的字符串，如果有的话。找到文件...打开文件搜索对话框。将结果放入新的输出窗口中。替换...打开搜索和替换对话框。转到LineMove游标所需的行号并使该行可见。显示完成打开可滚动列表以允许选择关键字和属性。请参阅下面“提示”部分的“完成”。展开WordExpand您已输入的前缀，以匹配同一窗口中的完整单词; 重复以获得不同的扩展。显示调用tipA函数的未闭括号后，用函数参数hint打开一个小窗口。显示周围的parens高亮显示周围的括号。
1.3 格式菜单（仅限编辑器窗口）
缩进区域通过缩进宽度向右移动所选行（默认4个空格）.Dedent RegionShift缩进宽度左侧的所选行（默认4个空格）。注释选定行前的RegionInsert ##。注释RegionRemove从选定行的前导＃或##划线区域将主要的空间延伸到标签中。（注意：我们建议使用4个空格块来缩进Python代码。）请删除RegionTurn 全部标签到正确数量的空格中。切换标签打开一个对话框，用于在具有空格和标签的缩进之间切换。新缩进宽度打开一个对话框来更改缩进宽度。Python社区接受的默认值是4个空格.Format ParagraphReformat注释块中的当前空行分隔段落或多行字符串或字符串中的选定行。段落中的所有行将被格式化为小于N列，其中N默认为72.Strip尾随空白删除行的最后一个非空格字符后的任何空格字符。
1.4 运行菜单（仅限编辑器窗口）
Python ShellOpen或唤醒Python Shell窗口。检查ModuleCheck在编辑器窗口中当前打开的模块的语法。如果模块未保存，IDLE将提示用户保存或自动保存，如在“空闲设置”对话框的“常规”选项卡中所选。如果出现语法错误，则在编辑器窗口中显示大概位置。运行模块检查模块（上图）。如果没有错误，请重新启动外壳以清理环境，然后执行该模块。输出显示在Shell窗口中。请注意，输出需要使用print或write。执行完成后，Shell将保留焦点并显示提示。此时，可以交互式地探索执行结果。这与python -i file使用命令行执行文件类似。
1.5 Shell菜单（仅限Shell 窗口）
查看上次重新启动将Shell窗口滚动到最后一个Shell重新启动Shell重新启动shell以清除环境。中断Execution停止正在运行的程序。
1.6。调试菜单（仅限Shell窗口）
转到当前行的File / LineLook。用光标，上面一行代表文件名和行号。如果找到，请打开文件（如果尚未打开），并显示该行。使用它可以查看异常回溯中引用的源代码行和查找文件中找到的代码行。也可在Shell窗口的上下文菜单中找到并输出windows.Debugger（toggle）激活时，在Shell中输入或从编辑器运行的代码将在调试器下运行。在编辑器中，可以使用上下文菜单设置断点。此功能仍然不完整，有点实验性。堆栈查看器显示堆栈跟踪树形控件中的最后一个异常，可访问本地和全局。自动打开Stack ViewerToggle会自动在未处理的异常情况下打开堆栈查看器。
1.7 选项菜单（Shell 和编辑器）
配置IDLE
打开一个配置对话框，并为以下内容更改首选项：字体，缩进，键绑定，文本颜色主题，启动窗口和大小，其他帮助源和扩展（请参阅下文）。在OS X上，通过选择应用程序菜单中的首选项来打开配置对话框。要在较旧的IDLE中使用新的内置颜色主题（IDLE Dark），请将其保存为新的自定义主题。
非默认用户设置保存在用户主目录中的.idlerc目录中。通过编辑或删除.idlerc中的一个或多个文件来解决由不良用户配置文件引起的问题。
代码上下文（切换）（仅限编辑器窗口）在编辑窗口的顶部打开窗格，其中显示在窗口顶部滚动的代码的代码上下文。
1.8 窗口菜单（Shell 和编辑器）
缩放高度在正常大小和最大高度之间切换窗口。初始大小默认为40行80个字符，除非在配置IDLE对话框的常规选项卡上更改。
该菜单的其余部分列出了所有打开的窗口的名称; 选择一个将其带到前台（如果需要，可以对其进行解密）。
1.9 帮助菜单（Shell 和编辑器）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f47f0d41a267fa12e90312fb1b7d958/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f1b825cc58ceee022d99724daeda2a/" rel="bookmark">
			【转载】Ubuntu系统中防火墙的使用和开放端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu系统中防火墙的使用和开放端口
目录
1、Ubuntu查看防火墙的状态... 2
2、Ubuntu开启防火墙... 2
3、Ubuntu添加开放SSH端口... 3
4、Ubuntu防火墙常用命令... 5
4.1、查看ufw防火墙的状态... 5
4.2、启用ufw防火墙... 6
4.3、重启ufw防火墙... 6
4.4、关闭ufw防火墙... 6
4.5、设置外来访问默认权限... 6
4.6、端口的开放与关闭... 7
4.6.1、开放普通端口... 7
4.6.2、关闭普通端口... 8
4.6.3、开放规定协议的端口... 8
4.6.4、关闭指定协议端口... 9
4.6.5、开放限定ip地址端口... 10
注意：不管是在Linux服务器还是在Ubuntu服务器中，当防火墙开启以后，会开放一些常用的端口，这时常常直接到自己Windows上telnet已经开放的端口，通常会忽略开放的这些端口在服务器中是否有程序进行监听，如果没有程序进行监听，telnet开放的这些端口时往往是不通的。
1、Ubuntu查看防火墙的状态 在Ubuntu系统进行安装的时候默认安装了ufw防火墙
查看防火墙的状态
命令：
sudo ufw status
系统提示： “Status: inactive”状态：不活跃
上面提示表示没有开启防火墙，并不是没有安装防火墙
如果没有安装可以使用命令安装
命令：
sudo sudo apt-get install ufw
2、Ubuntu开启防火墙
开启防火墙，
命令：
sudo ufw enable //开启防火墙
注意：Command may disrupt existing ssh connections. Proceed with operation (y|n)?
表示：命令可能会中断现有的ssh连接。继续操作(y|n)?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19f1b825cc58ceee022d99724daeda2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53ac4127d110617b88257f846e898289/" rel="bookmark">
			ArcGIS Pro中3D自定义工具整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前在研究ArcGIS Pro中的三维功能，陆陆续续地发现了一些问题，针对这些问题开发了四个自定义工具，这里整理一下，首先工具箱长这样：
接下来分别介绍一下每个工具的使用说明以及解决了什么问题。
1，Chaifen Obj 工具 使用说明：
该工具主要用于将较大的obj文件拆分为多个小的obj文件，输入obj所在的文件夹路径即可，可以批量处理。
解决问题：
该工具主要解决两个问题：一是将obj进行拆分，拆分后的obj以原始obj中的object对象命名，便于后面属性挂接；二是同时进行了纹理优化，解决纹理丢失和变暗问题。
Tips：如果要保留原始的obj，注意提前备份。
2，Optimize Obj工具 使用说明：
该工具主要用于优化obj文件的纹理，输入obj所在的文件夹路径即可，可以批量处理。
解决问题：
该工具主要解决两个问题：一是通过Import 3D files工具导入obj时纹理丢失，而Quick Import工具则可以正常导入；二是通过Import 3D files工具导入obj后生成的Multipatch纹理变暗，如下图：
Tips：该工具与ArcGIS Pro的版本无关，任何版本都可以使用。
3，Optimize Slpk Size工具 使用说明：
该工具用于优化slpk的大小，仅针对I3S 1.7版本生成的slpk（倾斜或者3D Object类型都可以）。输入slpk所在的文件夹路径，选择要保留的纹理类型，建议两种格式都保留，可以批量处理。
解决问题：
在不改变性能的前提下解决了如下问题：1，压缩slpk之后占用硬盘空间变小，所以后续上传至Portal和发布slpk的时间也相应变短；2，浏览器端加载时不会访问重复纹理，提升浏览器端显示性能。
例如：一个倾斜类型的slpk原始大小是：2.8G，压缩之后大小是：2.05G；一个3D Object类型的slpk原始大小是494M，压缩之后是232M。
Tips: 压缩比不是固定的，和具体的slpk有关，有的slpk压缩的比较多，有的slpk压缩的比较少。该工具针对I3S 1.7版本。
4，osgbToslpk工具 使用说明：
1，输入osgb文件夹路径那里选择Data的上一级文件夹；
2，工具会自动寻找输入文件夹下有没有metadata.xml文件，如果有的话，输入锚点文件参数下会自动识别出该文件，没有的话可以手动选择shapefile文件；
3，空间参考输入WKID即可。
解决问题：
osgb文件夹里有时会多出一些不属于该区域的osgb文件，这些osgb文件不仅会增加生成slpk时的处理时间，有时也会导致结果出错。该工具会忽略这些错误的osgb文件，仅处理属于该区域的osgb文件，加快处理速度。
Tips：该工具仅适用于Pro 2.6版本。
最最重要的问题来了，那么工具在哪里呢？工具在这里：
Pro 2.5版本
Pro 2.6版本
最后，欢迎大家下载试用，有问题可以给我留言哦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f50f877a3cbf41b0230992d1472e013f/" rel="bookmark">
			网页上如何显示数学题特殊符号与公式前台展现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先上个图，这个图是利用程序给的数据代码编译成数学公式。
使用，MathJax 是一个开源的基于 Ajax 的数学公式显示的解决方案，结合多种先进的Web技术，支持主流的浏览器。
具体的涉及到的伙伴可以研究下这个。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683e43a3790d975d2710f6a15f2b6eac/" rel="bookmark">
			python用递归方式实现最大公约数_Python实现求两数最大公约数(四种方法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 辗转相除法(while循环实现)
(1) 两数求余temp = p % q
(2) temp = 0时，q为最大公约数
(3) temp !=0时，p = q；q = temp注：该循环的是否继续的判断条件就是temp是否为0
def fuc(p, q):
temp = p % q
while temp!=0:
p = q
temp = p
q = temp % q
return q1
2
3
4
5
6
7
2.辗转相减法
(1) 如果p &gt; q ，p = p - q
(2) 如果q &gt; p ，q = q - p
(3) 假如p = q ，则 p或q 是最大公约数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/683e43a3790d975d2710f6a15f2b6eac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/009295b4ffb74764743ae960181f21af/" rel="bookmark">
			exfat 分配单元大小_伙伴分配器的一个极简实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(感谢网友 @我的上铺叫路遥 投稿)
提起buddy system相信很多人不会陌生，它是一种经典的内存分配算法，大名鼎鼎的Linux底层的内存管理用的就是它。这里不探讨内核这么复杂实现，而仅仅是将该算法抽象提取出来，同时给出一份及其简洁的源码实现，以便定制扩展。
伙伴分配的实质就是一种特殊的“分离适配”，即将内存按2的幂进行划分，相当于分离出若干个块大小一致的空闲链表，搜索该链表并给出同需求最佳匹配的大小。其优点是快速搜索合并(O(logN)时间复杂度)以及低外部碎片(最佳适配best-fit)；其缺点是内部碎片，因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。但若需求本身就按2的幂分配，比如可以先分配若干个内存池，在其基础上进一步细分就很有吸引力了。
可以在维基百科上找到该算法的描述，大体如是：
分配内存：
1.寻找大小合适的内存块(大于等于所需大小并且最接近2的幂，比如需要27，实际分配32)
1.如果找到了，分配给应用程序。
2.如果没找到，分出合适的内存块。
1.对半分离出高于所需大小的空闲内存块
2.如果分到最低限度，分配这个大小。
3.回溯到步骤1(寻找合适大小的块)
4.重复该步骤直到一个合适的块
释放内存：
1.释放该内存块
1.寻找相邻的块，看其是否释放了。
2.如果相邻块也释放了，合并这两个块，重复上述步骤直到遇上未释放的相邻块，或者达到最高上限(即所有内存都释放了)。
上面这段文字对你来说可能看起来很费劲，没事，我们看个内存分配和释放的示意图你就知道了：
上图中，首先我们假设我们一个内存块有1024K，当我们需要给A分配70K内存的时候，
我们发现1024K的一半大于70K，然后我们就把1024K的内存分成两半，一半512K。然后我们发现512K的一半仍然大于70K，于是我们再把512K的内存再分成两半，一半是128K。此时，我们发现128K的一半小于70K，于是我们就分配为A分配128K的内存。 后面的，B，C，D都这样，而释放内存时，则会把相邻的块一步一步地合并起来(合并也必需按分裂的逆操作进行合并)。
我们可以看见，这样的算法，用二叉树这个数据结构来实现再合适不过了。
我在网上分别找到cloudwu和wuwenbin写的两份开源实现和测试用例。实际上后一份是对前一份的精简和优化，本文打算从后一份入手讲解，因为这份实现真正体现了“极简”二字，追求突破常规的，极致简单的设计。网友对其评价甚高，甚至可用作教科书标准实现，看完之后回过头来看cloudwu的代码就容易理解了。
分配器的整体思想是，通过一个数组形式的完全二叉树来监控管理内存，二叉树的节点用于标记相应内存块的使用状态，高层节点对应大的块，低层节点对应小的块，在分配和释放中我们就通过这些节点的标记属性来进行块的分离合并。如图所示，假设总大小为16单位的内存，我们就建立一个深度为5的满二叉树，根节点从数组下标[0]开始，监控大小16的块；它的左右孩子节点下标[1~2]，监控大小8的块；第三层节点下标[3~6]监控大小4的块……依此类推。
在分配阶段，首先要搜索大小适配的块，假设第一次分配3，转换成2的幂是4，我们先要对整个内存进行对半切割，从16切割到4需要两步，那么从下标[0]节点开始深度搜索到下标[3]的节点并将其标记为已分配。第二次再分配3那么就标记下标[4]的节点。第三次分配6，即大小为8，那么搜索下标[2]的节点，因为下标[1]所对应的块被下标[3~4]占用了。
在释放阶段，我们依次释放上述第一次和第二次分配的块，即先释放[3]再释放[4]，当释放下标[4]节点后，我们发现之前释放的[3]是相邻的，于是我们立马将这两个节点进行合并，这样一来下次分配大小8的时候，我们就可以搜索到下标[1]适配了。若进一步释放下标[2]，同[1]合并后整个内存就回归到初始状态。
还是看一下源码实现吧，首先是伙伴分配器的数据结构：
struct buddy2 {
unsigned size;
unsigned longest[1];
};
这里的成员size表明管理内存的总单元数目(测试用例中是32)，成员longest就是二叉树的节点标记，表明所对应的内存块的空闲单位，在下文中会分析这是整个算法中最精妙的设计。此处数组大小为1表明这是可以向后扩展的(注：在GCC环境下你可以写成longest[0]，不占用空间，这里是出于可移植性考虑)，我们在分配器初始化的buddy2_new可以看到这种用法。
struct buddy2* buddy2_new( int size ) {
struct buddy2* self;
unsigned node_size;
int i;
if (size &lt; 1 || !IS_POWER_OF_2(size))
return NULL;
self = (struct buddy2*)ALLOC( 2 * size * sizeof(unsigned));
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/009295b4ffb74764743ae960181f21af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc2171a8e075ed11dba3ab6552acfb8b/" rel="bookmark">
			python列表写入字典_python  – 将列表字典写入CSV文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我正在努力将列表字典写入.csv文件.
这就是我的字典的样子：
dict[key1]=[1,2,3]
dict[key2]=[4,5,6]
dict[key3]=[7,8,9]
我希望.csv文件看起来像：
key1 key2 key3
1 4 7
2 5 8
3 6 9
起初我写了标题：
outputfile = open (file.csv,'wb')
writefile = csv.writer (outputfile)
writefile.writerow(dict.keys())
到目前为止一切都那么好……但是,我的问题是我不知道如何将一个列表分配给相应的列.例如.：
for i in range(0,len(dict[key1])):
writefile.writerow([dict[key1][i],dict[key2][i],dict[key3][i])
将随机填充列.另一个问题是,我必须手动填写密钥,不能将它用于另一个带有4个密钥的字典.
解决方法:
如果你不关心列的顺序(因为字典是无序的),你可以简单地使用zip()：
d = {"key1": [1,2,3], "key2": [4,5,6], "key3": [7,8,9]}
with open("test.csv", "wb") as outfile:
writer = csv.writer(outfile)
writer.writerow(d.keys())
writer.writerows(zip(*d.values()))
结果：
key3 key2 key1
7 4 1
8 5 2
9 6 3
如果您关心订单,则需要对密钥进行排序：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc2171a8e075ed11dba3ab6552acfb8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dffade45e023c55caa35e7df7188e2b/" rel="bookmark">
			python 语句块_python言语语句块的标记是什么？_后端开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python中没有显著的语句块标记，是经由过程缩进来辨认语句块的。Python是一种跨平台的计算机程序设计言语；是一个高层次的连系了解释性、编译性、互动性和面向对象的脚本言语；多被用于自力的、大型项目的开发。
python没有显著的语句块标记，是经由过程缩进来辨认语句块的。
这里翻开编辑器，新建一个py文件作为树模。
def happy():
print("Very Happy!")
happy()
建立函数的时刻，冒号今后须要举行缩进，标记语句块。
x = 1
while x &lt; 5:
print(x)
x += 1
在用while的时刻，冒号今后须要举行缩进，标记语句块。
x = 1
if x &lt; 10:
print("ok")
else:
print("not ok")
在用if和else语句的时刻，冒号今后须要举行缩进，标记语句块。
假如不必标记语句块，是会报错的。
def hey():
x = 1
while x &lt; 3:
print("hey")
x += 1
if x == 3:
print("ok")
hey()
每一次冒号今后都是须要标记语句块，而且要根据花样一层一层标记。
引荐教程：《python教程》
以上就是python言语语句块的标记是什么？的细致内容，更多请关注ki4网别的相干文章！
收藏 | 0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255171e101ea3477071a81e72c54f517/" rel="bookmark">
			用python计算100以内所有偶数的和_用python计算100以内所有整数和的多种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法用range函数
sum = 0
for x in range(101):
sum = sum + x
print(sum)
#range()函数可以生成一个整数序列，再通过list()函数可以转换为list。
比如range(5)生成的序列是从0开始小于5的整数
第二种方法使用数学公式
n=100
print(n*n/2+n/2)
# 1 2 3 4...100...n 以上数列可以看出
当n为偶数时 这个数列最后一个和第一个的和等于第二个和倒数第二个的和
这个和有n/2个 推倒出这个数列的所有整数和为（n+1)*n/2也就是 n*n/2+n/2
当n为奇数时 和为(n+1)(n-1)/2+(n+1)/2 最终计算结果也是n*n/2+n/2
当n为偶数时 所有偶数和为n*n/4+n/2 奇数和n*n/4
当n为奇数时 所有偶数和为n*n/4-1/4 奇数和n*n/4+n/2+1/4
第三种方法使用while循环
x=0
b=0
while x&lt;101:
b=b+x
x=x+1
print(b)
#使用break如下
x=0
b=0
while True:
x=x+1
if x==101:
break
b=b+x
print(b)
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/402/">«</a>
	<span class="pagination__item pagination__item--current">403/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/404/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>