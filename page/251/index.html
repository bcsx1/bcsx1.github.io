<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36f909b46f7fa95b9d82598c8d0608a9/" rel="bookmark">
			C&#43;&#43;一行代码实现任意系统函数Hook！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 | 一句话实现系统API的Hook，参数记录以及数据过滤与修改，关注敏感数据本身而不是哪个API的哪个参数可能有敏感的需要处理的信息，写工具的时候想到上述能力可以借助模板实现，赶紧尝试了一下，也做个笔记分享供大家学习。
一、AnyCall
（一）背景 一般来说所有ApiHook库都会需要提供一个与被HookApi相似/相同的Myxxx函数以实现参数访问，这里以BlackBone的LocalHook举例，其需要的是被HookApi的引用参数形式，如下所示：
bool TestFunc1(char a, int b) { return a + b; } bool MyTestFunc1(char&amp; a, int&amp; b) { return a + b; } blackbone::Detour&lt;decltype(&amp;TestFunc1)&gt; hook; hook.Hook(&amp;TestFunc1, &amp;MyTestFunc1, blackbone::HookType::Inline); 上述使用方式需要为每个被挂钩的函数都写一个符合参数要求的Myxxx函数并将其所有的参数加上引用符号，多写些API就产生了大量重复性的代码。
（一）通用化处理逻辑的优势 既然在这里已经知道被钩挂的函数类型，那么是否可以利用C++模板为我们自动生成一个通用函数，以实现一行代码完成任意API的Hook呢？进一步来说，这样的处理方式是否可以分离API和参数的对应关系，使我们不再关注需要修改哪个API的哪个参数的内容，而是只关注什么数据是敏感数据，对所有参数只要出现敏感数据的参数就进行修改呢，下面是尝试实现上述逻辑的代码笔记。
（二）类型萃取生成函数 函数的参数类型萃取需要借助struct辅助实现，先看下如果不使用struct辅助直接定义模板函数的困难在哪，代码如下：
template&lt;typename RET, typename... ARGS&gt; RET FunctionCreater(ARGS&amp;... args) { //do something... } blackbone::Detour&lt;decltype(&amp;TestFunc1)&gt; hook; hook.Hook(&amp;TestFunc1, &amp;FunctionCreater&lt;bool,char,int&gt;, blackbone::HookType::Inline); 这里的模板参数需要用testFuncHooker&lt;bool，char，int&gt;形式传递，即先是返回值类型再是各个参数类型，如果需要进一步自动化处理的话则需要实现自动提取参数类型并将其逐个依次在此展开的能力，使用struct可以避免实现上述复杂的逻辑，代码如下：
template&lt;typename RET, typename... ARGS&gt; struct AnyCall; template&lt;typename RET, typename... ARGS&gt; struct AnyCall&lt;RET(ARGS...)&gt; { static RET FunctionCreater(ARGS&amp;.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36f909b46f7fa95b9d82598c8d0608a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5831279f6fb88e8257cde809f0705fdb/" rel="bookmark">
			python知识复习二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、迭代器与生成器二、python3函数1.定义一个函数2.函数调用3.函数调用4.参数传递5.匿名函数6.return语句 三、python数据结构四、读和写文件五、文件方法六、os文件及目录方法七、类八、命名空间九、标准库概览十、内置函数 一、迭代器与生成器 迭代器是访问集合内元素的一种方式，一般用来遍历数据。迭代器只能一条一条的产生数据，下标不能返回。迭代器提供了一种惰性访问的方式。
python迭代器的用途：用next函数获取下一个元素，只能向前取值，不会后退。
python生成器的用途：动态提供数据，调用return生成一个StopIteration异常，通知next(it)函数不再提供数据。
StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。
如
class MyNumbers:
def iter(self):
self.a = 1
return self
def next(self):
if self.a &lt;= 20:
x = self.a
self.a += 1
return x
else:
raise StopIteration
myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:
print(x)
输出
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5831279f6fb88e8257cde809f0705fdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5131ac88066015d8ec9e61357eff143e/" rel="bookmark">
			Pycharm虚拟环境中安装及使用Pytest
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、创建干净的虚拟环境 创建项目时不勾选“inherit global site-packages”表示不继承原始解释器的库，也不勾选“Make available to all projects”表示当前虚拟环境的库不会共享给虚拟环境 确认虚拟环境已经创建好 二、安装pytest
方式1：Terminal中命令安装 pip install -U pytest 方式2：Settings中界面搜索安装
验证安装完成，用查看pytest版本的方式
pytest --version 三、使用pytest
方式1：Terminal 命令方式调用，直接用命令“pytest”
方式2：Pycharm中测试用例执行框架改成pytest（默认是Unittests）
改好之后可直接在方法左侧入口执行：
运行效果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a26c6d76299e9ead7e7a2c2936aab8aa/" rel="bookmark">
			linux基础篇（一）——GCC和Makefile编译过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux系列目录： linux基础篇（一）——GCC和Makefile编译过程
linux基础篇（二）——静态和动态链接
ARM裸机篇（一）——i.MX6ULL介绍
ARM裸机篇（二）——i.MX6ULL启动过程
ARM裸机篇（三）——i.MX6ULL第一个裸机程序
ARM裸机篇（四）——重定位和地址无关码
ARM裸机篇（五）——异常和中断
linux系统移植篇（一）—— linux系统组成
linux系统移植篇（二）—— Uboot使用介绍
linux系统移植篇（三）—— Linux 内核使用介绍
linux系统移植篇（四）—— 根文件系统使用介绍
linux驱动开发篇（一）—— Linux 内核模块介绍
linux驱动开发篇（二）—— 字符设备驱动框架
linux驱动开发篇（三）—— 总线设备驱动模型
linux驱动开发篇（四）—— platform平台设备驱动
文章目录 linux系列目录： 引入GCC 编译工具链GCC 编译器做了什么GCC 编译过程GCC基本语法glibc库的作用 Makefile的引入Makefile简介 源码编译过程 引入 使用文本文件编写一个Hello World程序，文件名命名为hello.c：
#include &lt;stdio.h&gt; int main() { printf("Hello World\n"); return 0; } 然后我们如何使这个Hello World程序按我们预想的样子执行呢？平常我们都会使用各种集成开发环境(IDE),比如 Visual Studio、Keil等，这样的IDE一般都将编译和链接的过程一步完成，它们提供的默认配置、编译和链接参数对我们日常使用而言已经足够了，但是我们往往也会被这些复杂的集成工具所提供的强大功能所迷惑，很多系统软件的运行机制与机理被掩盖。
接下来请思考以下几个问题：
#include &lt;stdio.h&gt;是什么意思？把stdio.h包含进来意味着什么？为什么要有mian函数？程序为什么会从main函数开始运行？printf是怎么实现的？它为什么可以在终端显示？return 0意味着什么？return以后程序跑到哪了？ 看似简单的一个Hello World程序想要运行起来，背后其实隐藏了大量的细节，Hello World程序从源代码到变成可执行文件的一个简单流程大概如下图所示：
源代码大家都已经比较熟悉了，接下来我会通过几篇文章来简单的介绍一下剩下步骤和使所使用到的工具，并尝试挖掘出Hello World程序背后隐藏的细节。
GCC 编译工具链 GCC 编译工具链（toolchain）是指以 GCC 编译器为核心的一整套工具，用于把源代码转化成可执行应用程序。它主要包含以下三部分内容：
• GCC 编译器 : 用于完成预处理和编译过程，例如把 C 代码转换成汇编代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a26c6d76299e9ead7e7a2c2936aab8aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/100e3a4cbb0198f4313f7b2f84f6d38e/" rel="bookmark">
			Quest2的建图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不管的房间有多大，quest2都可以给你建出来
这个建图app是要付费的，8刀 约为 55块人民币。这样这个技术的商业模式是清晰的，是一个独立的app。
背景中的墙：
地面：
有地图的好处是：你动了，周围的环境也动，与你形成真实的交互。交付非常重要。
有地图的条件下，就可以从see through 到 pass through.
youtube-prez
建图步骤：
1. 告诉系统哪里是墙，哪里是地面。
2. 告诉系统哪里是天花板
3. 要把角点弄出来
完成重建之后，就可以换装，交互。
https://www.youtube.com/watch?v=lARn-aKKKNU
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca6942d82da9186e84aea562fecfd34e/" rel="bookmark">
			2020新型冠状病毒肺炎的传播分析及对经济的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 新型冠状病毒肺炎（COVID-19）的传播分析及对经济的影响 新型冠状病毒肺炎（COVID-19）的传播分析及对经济的影响体现在哪些方面？这种题怎么做？
请你建立 COVID-19 传播的数学模型，定量地研究传染病的传播规律，利用所给（不限于）资料和数据，作出预测并给出控制传染病蔓延的对策建议，具体要求如下：
建立模型，预测不同国家或地区（至少预测两个国家或地区）确诊病例和死亡病例数的变化。对具体国家或地区卫生部门所采取的措施做出评论，如：
针对美国采取的防控措施，讨论实施或取消居家令（stay-at-home）和就地避难令（shelter-in-place）对疫情传播的影响；或针对我国采取的隔离措施，讨论提前或延后 3-5 天采取严格的隔离措施，对疫情传播所造成的影响。收集 COVID-19 对经济某个方面影响的数据（须说明数据获取方式或来源），建立相应的数学模型并进行预测。结合你们模型和预测数据，给相关国家或地区的卫生部门写一篇短文，对该国或该地区的疾病防控给出对策建议。
问题分析
针对问题一，我们运用主成分分析法从多个角度去分析影响疫情的因素。于是我们最后选择了人口数、感染数量、人均 GDP、疫情持续时间、老年人年占比情况等方面进行分析。我们通过 SPSS 进行数据筛选得到疫情较为严重国家的确诊人数、治愈人数、死亡人数、疫情发展时间、地点的数据。随后我们通过 OECD 经济合作与发展组织官方数据库查找到了居民病床占比、居民医生占比、护士占比、国民贫困率、国民 GDP、老年人占比等数据。然后通过数据库的数据筛选得到了疫情较为严重国家的数据。并绘制了相关折线图、条形图。我们通过 SPSS 运用因子分析对疫情较为严重的国家进行分析，并到得到了相关性矩阵。最后通过各项影响进行建立评估模型，求出估算平均值。筛选出流行系数较高与较低的国家进行对比分析。并通过建立灰色预测模型进行预测两个国家的疫情走势并绘制相关回归曲线。 word and model 程序 代码一： x1=0:1000:83356; x2=0:1000:177644; y1=((2.101*(1404676330-x1))*(1/3)+(2.700*(1404676330-x1))*1/2)/x1; y2=((3.880*(46754783-x2))*1/3+(5.740*(46754783-x2))*1/2)/x2; plot(x1,y1，’b’) hold on; plot(x2,y2,’r’) 代码二： x1=0:1000:83356; x2=0:1000:177644; y1=((2.101*(1404676330-x1))*(1/3)+(2.700*(1404676330-x1))*1/2)/x1; subplot(1,2,1); y2=((3.880*(46754783-x2))*1/3+(5.740*(46754783-x2))*1/2)/x2; subplot(1,2,2); plot(x1,y1,’b’) plot(x2,y2,’b’) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd5ae31ac23707866e72ea4445f13ce/" rel="bookmark">
			分布式调度框架Elastic-Job
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Elastic-Job介绍 Elastic-Job是当当网开源的⼀个分布式调度解决方案，基于Quartz二次开发的，由两个相互独立的子项目Elastic-Job-Lite和Elastic-Job-Cloud组成。我们要学习的是 Elastic-Job-Lite，它定位为轻量级无中心化解决方案，使用Jar包的形式提供分布式任务的协调服务，而Elastic-Job-Cloud子项目需要结合Mesos以及Docker在云环境下使用。
Elastic-Job的github地址：https://github.com/elasticjob
主要功能介绍
分布式调度协调，在分布式环境中，任务能够按指定的调度策略执行，并且能够避免同⼀任务多实例重复执行丰富的调度策略 基于成熟的定时任务作业框架Quartz cron表达式执行定时任务弹性扩容缩容 当集群中增加某⼀个实例，它应当也能够被选举并执行任务；当集群减少⼀个实例时，它所执行的任务能被转移到别的实例来执行。失效转移 某实例在任务执行失败后，会被转移到其他实例执行错过执行作业重触发 若因某种原因导致作业错过执行，自动记录错过执行的作业，并在上次作业完成后自动触发。支持并行调度、支持任务分片，任务分片是指将一个任务分为多个小任务项在多个实例同时执行。作业分片一致性，当任务被分片后，保证同一分片在分布式环境中仅一个执行实例。 2、Elastic-Job-Lite应用 jar包（API） + 安装zk软件
Elastic-Job依赖于Zookeeper进行分布式协调，所以需要安装Zookeeper软件（3.4.6版本以上），Zookeeper的本质功能：存储+通知。
安装Zookeeper（此处单例配置）
1）我们使用3.4.10版本，在linux平台解压下载的zookeeper-3.4.10.tar.gz
2）进⼊conf目录，cp zoo_sample.cfg zoo.cfg
3) 进⼊bin目录，启动zk服务
启动 ./zkServer.sh start
停止 ./zkServer.sh stop
查看状态 ./zkServer.sh status
3、Zookeeper的树形节点结构图 引入Jar包
&lt;!-- https://mvnrepository.com/artifact/com.dangdang/elastic-job-lite-core--&gt; &lt;dependency&gt; &lt;groupId&gt;com.dangdang&lt;/groupId&gt; &lt;artifactId&gt;elastic-job-lite-core&lt;/artifactId&gt; &lt;version&gt;2.1.5&lt;/version&gt; &lt;/dependency&gt; 定时任务实例
需求：每隔两秒钟执行一次定时任务（resume表中未归档的数据归档到resume_bak表中，
每次归档1条记录）
1）resume_bak和resume表结构完全⼀样
2）resume表中数据归档之后不删除，只将state置为"已归档"
数据表结构 -- ---------------------------- -- Table structure for resume -- ---------------------------- DROP TABLE IF EXISTS `resume`; CREATE TABLE `resume` ( `id` BIGINT ( 20 ) NOT NULL AUTO_INCREMENT, `name` VARCHAR ( 255 ) DEFAULT NULL, `sex` VARCHAR ( 255 ) DEFAULT NULL, `phone` VARCHAR ( 255 ) DEFAULT NULL, `address` VARCHAR ( 255 ) DEFAULT NULL, `education` VARCHAR ( 255 ) DEFAULT NULL, `state` VARCHAR ( 255 ) DEFAULT NULL, PRIMARY KEY ( `id` ) ) ENGINE = INNODB AUTO_INCREMENT = 1001 DEFAULT CHARSET = utf8; SET FOREIGN_KEY_CHECKS = 1; 程序开发
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd5ae31ac23707866e72ea4445f13ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8be08a05ab07849b3cbedbef5452ee1/" rel="bookmark">
			解决VirtualBox增强功能异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VirtualBox增强功能异常的排查 每次安装完vbox的增强功能总是会有各种异常问题，比如：
共享文件不能使用。复制粘贴不能使用。显示器分辨率不能自动调整。OpenGL 3D加速不能使用。 排查方法：
确认安装的增强功能包的版本与virtualbox的版本匹配。ps -ef | grep VBoxClient查看VBoxClient进程是否启动。lsmod | grep vbox查看驱动是否加载。systemctl status vboxadd.service查看服务状态是否报错。 版本匹配 一般来说，需要确保增强功能包的版本与virtualbox主程序一致。
也有例外情况，比如我在使用5.2.24版本的时候，测试下来5.2.38版本的功能包是最合适的。
VBoxClient VBoxClient是启动增强功能的关键程序，桌面启动时通常会加载VBoxClient-all来启动所有需要的功能，这是通过/etc/xdg/autostart/vboxclient.desktop文件实现的。
如果你使用如i3wm这样的其他桌面环境，那么VBoxClient可能不会自动加载，这就需要你在对应的启动配置中手动调用VBoxClient-all程序。以i3wm为例，需要在~/.config/i3/config中增加exec --no-startup-id VBoxClient-all。
如果正常，使用ps -ef|grep VBoxClient命令，你应该能看到类似下面的输出，不同版本会有些许不同。
liyt 1869 1 0 13:46 ? 00:00:00 /usr/bin/VBoxClient --clipboard liyt 1871 1869 0 13:46 ? 00:00:00 /usr/bin/VBoxClient --clipboard liyt 1883 1 0 13:46 ? 00:00:00 /usr/bin/VBoxClient --seamless liyt 1885 1883 0 13:46 ? 00:00:00 /usr/bin/VBoxClient --seamless liyt 1893 1 0 13:46 ? 00:00:00 /usr/bin/VBoxClient --draganddrop liyt 1895 1893 0 13:46 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8be08a05ab07849b3cbedbef5452ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a21a451787fdfd6c8e44e2b678a8c7b/" rel="bookmark">
			synchronized(this)锁定的是对象还是方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		synchronized(this)锁住的到底是对象还是方法？我们来看一个简单的例子：
线程类JavaFunTest 在main方法中创建了两个线程。
public class JavaFunTest extends Thread{ private Test test; public JavaFunTest(Test test) { this.test = test; } @Override public void run() { test.printThreadName(); } } class Test { public void printThreadName() { synchronized (this) { for (int i = 0; i &lt; 100; i++) { System.out.println(Thread.currentThread().getName() + " , i = " + i); } } } } 1.首先我们先给两个线程类传入不同测试对象。
public static void main(String[] args) { Test test1 = new Test(); Test test2 = new Test(); JavaFunTest javaFunTest1 = new JavaFunTest(test1); JavaFunTest javaFunTest2 = new JavaFunTest(test1); javaFunTest1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a21a451787fdfd6c8e44e2b678a8c7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/151bc43b66ef55e4d21082670d6dc2c2/" rel="bookmark">
			数学分析-1.2数列和收敛数列-例题1、2、3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Eg 1：证明：收敛数列极限唯一
对于数列 { a n } \{a_n\} {an​}，若存在两个极限：
lim ⁡ n → ∞ a n = a ， lim ⁡ n → ∞ a n = b \underset{n\rightarrow \infty}{\lim}a_n=a，\underset{n\rightarrow \infty}{\lim}a_n=b n→∞lim​an​=a，n→∞lim​an​=b证明 a = b a=b a=b即可
∀ ε &gt; 0 , ∃ N 1 , 当 n &gt; N 1 时： ∣ a n − a ∣ &lt; ε 2 \forall \varepsilon &gt;0,\exists N_1, \text{当}n&gt;N_1\text{时：}\left| a_n-a \right|&lt;\frac{\varepsilon}{2} ∀ε&gt;0,∃N1​,当n&gt;N1​时：∣an​−a∣&lt;2ε​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/151bc43b66ef55e4d21082670d6dc2c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4809faacfbd57677b5be2e5033690768/" rel="bookmark">
			matlab的find()函数的一些用法(快速查找符合条件的值)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有些时候，有一组数据，而任务呢，则是需要我们在这一组数据中找到符合某种规则的数据的位置，比如大于一个数，或者是等于一个数，或者是某个数的倍数等等。诸如此此类的问题有时也会令我们感到头痛。现在呢，咱们想一个办法，使得这个问题可以被很好地解决。
对于这类问题，一个最简单的，写一个循环遍历，找到符合条件的数据，确定其位置(索引值)，然后保存这些位置数据。没错，这很简单，接下来也会把这个方法实现。
问题背景：一组数据依次为[1，2，3，4，0，1，0，10，12，16]，当然，也可能更多，找到可以被2整除的数据，并记录其位置。
clc;clear;M=[1,2,3,4,0,1,0,10,12,16];n=length(M);List=[];j=0;for i=1:n if mod(M(i),2)==0 %判断是否可以被2整除 j=j+1; List(j)=i; endenddisp(List)%输出符合条件的数据的位置RE=M(List);%得到符合条件的数据disp(RE)%输出符合条件的数据 ​​​​​​​
结果： 2 4 5 7 8 9 10 %符合条件的数据的位置 2 4 0 0 10 12 16 %符合条件的数据 当然，这可以很好的把问题解决。但是，却有点复杂，有没有更为简单的办法？好吧，确实有。
形式一：find(判断条件)​​​​​​
M=[1,2,3,4,0,1,0,10,12,16]; r1=find(M==0); %找到数据的0元素的位置 disp(r1); r2=find(M~=0);%找到数据的非0元素的位置 disp(r2); r3=find(M==1);%找到等于某个值(这里为1)的元素的位置 disp(r3); r4=find(M&gt;10);%找到大于某个值(这里为10)的所有元素的位置 disp(r4); r5=find(mod(M,2)==0);%找到可以被2整除的所有元素的位置 disp(r5); 结果： 5 7 1 2 3 4 6 8 9 10 1 6 9 10 2 4 5 7 8 9 10 当然，这个判断条件可以很多很多，具体依自己实际需要自行设置即可。
形式二(主要操作与0有关):
1 index=find(M)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4809faacfbd57677b5be2e5033690768/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75722cc2ae2f69bc9436965cc04b91dd/" rel="bookmark">
			matlab绘图|坐标轴axis的一些常用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图形的用处有很多，我们在阅读一些论文时，常常会看见一些非常精美的图片，这会使得我们对于内容的理解更加深刻。常用的绘图之前已经写过，这里写一下绘完图后，如何对坐标轴进行设置，使得图片更加符合实际需要！
基本图形：
代码：x=0:pi/4:2*pi;y=sin(x);plot(x,y,'-co'); 这个图是直接画出的，下面对其坐标轴进行一些设置！
01
axis off:关闭所有的坐标轴标签、刻度、背景​​​​​​​
x=0:pi/4:2*pi;y=sin(x);plot(x,y,'-co');axis off; 02
axis([xmin xmax ymin ymax]):设置图形的坐标范围，分别为x轴的最小、最大值，y轴的最小最大值。
​​​​​​​
x=0:pi/4:2*pi;y=sin(x);plot(x,y,'-co');axis([0,2*pi,-1,1]); 03
axis ij:将坐标轴设置为矩阵模式。此时水平坐标轴从左到有取值，垂直坐标从上到下
​​​​​​​
x=0:pi/4:2*pi;y=sin(x);plot(x,y,'-co');axis ij; 04
axis square:将坐标轴设置为正方形
​​​​​​​
x=0:pi/4:2*pi;y=sin(x);plot(x,y,'-co');axis square; 05
axis equal :设置屏幕高宽比，使得每个坐 标轴的具有均匀的刻度间隔
x=0:pi/4:2*pi;y=sin(x);plot(x,y,'-co');axis equal; 公众号：简单编程之旅
欢迎关注！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/661171c305f0a77589c591c332bf96b3/" rel="bookmark">
			模型优化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
引入概念(可以反向传播去推导):
sigmoid
tanh
以上问题解决
Relu
通过调整学习率缓解Dead Relu Problem
引入概念(可以反向传播去推导): 每一层的梯度都与它当前层数接收到的数据相关，除此之外，层数越往前，和梯度相关的因素就越多(后面层数的梯度 与 后面层接收到的数据经过目标函数的导函数 的 累乘将越多)，这里累乘意味着当相关因素大于1的时候，前几层的梯度会比较大，小于一时，会非常小，对后几层的影响会越来越小。过大过小的情况，分别被称为，梯度爆炸和梯度消失。
sigmoid 左图为sigmoid函数图像，右图为导函数图像，对于sigmoid激活函数，其导函数最大值为0.25，在累乘情况下有可能出现梯度消失的现象。
如果sigmoid函数接收到的值处于饱和状态(非常大或非常小)，此时导函数取值趋近于零，则更容易导致模型梯度消失。此时对于复杂模型而言，看似层数很多，但前几层的梯度非常小，因此梯度更新慢，学习能力较弱，单纯的增加层数也无法得到更好的效果。
tanh 对与tanh函数，因为函数可以输出负值，则可以输入零均值的数据，就意味着导函数接受到的结果也可能在0附近，此时导函数取得最大值1，也保证后续层接受到的数据为零均值的数据(Zero-centered Data)，可有效避免梯度消失的情况。
梯度和导函数关系如下:
但是，如果梯度更新中，出现个别参数，较大的情况，则更新过程会出现波动，一部分更新很快，一部分得不到更新，出现梯度爆炸(梯度不平稳)的情况
以上问题解决 无论是梯度爆炸还是梯度消失，都属于梯度不平稳的现象，解决此现象，一般有:参数初始化方法，数据的归一化方法，衍生激活函数使用方法，学习率调度方法和梯度下降方法。这些方法都有一个基本的理论:glorot条件
通过之前的经验，要让梯度有一个稳定的变化，核心是激活函数的导数值尽可能区最大值，也就是输入数据为Zero-centered Data。输入数据一般为X*w，X可以用归一化方法处理，关键在于w如何变为Zero-centered Data(一般w会给到网络自动生成)。对于w，明确的一点是它的均值为0，而方差的确定需要满足glorot条件，即:正向传播时，每个线性层输入数据的方差等于输出数据的方差，同时，反向传播时，数据流经某层之前和流经某层之后该层的梯度也具有相同的方差。(主要围绕tanh函数的优化)
Relu relu函数的累乘不会出现梯度爆炸或者梯度消失的现象，但由于其部分数值归零的特性，会出现Dead Relu Problem(神经元活性失效) 问题。
根据上面的导函数图像性质，当输入数据为负时，会存在导函数取值为零，则后续梯度的累乘过程中都为零，此时梯度无法更新。
通过调整学习率缓解Dead Relu Problem 当迭代次数越多，越容易陷入我们梯度全为零的问题中，而较小的学习率就以为更小的步长，此时模型更加保守，更加不容易走到梯度为零的位置，而更小的梯度则需要更多的迭代次数(迭代次数与计算量有关)，但relu函数的计算量相对于前两个函数来说较小，不会有显著提升(初始化输入的数据不能让梯度为零)。
而只要不出现神经元活性失效问题，则导函数取值都为一，梯度的取值也会更加平稳，不会出现梯度爆炸或者消失的现象。小批量梯度下降中，可能会出现一批数据输出是零的情况，此时，梯度是不更新的，而不为零，则为一。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eaa9532a41bb8adbee130c8f7115938/" rel="bookmark">
			阿里云使用docker急速部署kafka
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kafka部署 准备工作：阿里云服务器安装docker，docker-compose
下载docker-compose.yml
curl -sSL https://raw.githubusercontent.com/bitnami/bitnami-docker-kafka/master/docker-compose.yml &gt; docker-compose.yml 修改 docker-compose.yml，配置内外网访问 version: "2" services: zookeeper: image: docker.io/bitnami/zookeeper:3.8 ports: - "2181:2181" volumes: - "zookeeper_data:/bitnami" environment: - ALLOW_ANONYMOUS_LOGIN=yes kafka: image: docker.io/bitnami/kafka:3.2 ports: - "9092:9092" - "9093:9093" volumes: - "kafka_data:/bitnami" environment: - KAFKA_CFG_ZOOKEEPER_CONNECT=阿里云内网:2181 - ALLOW_PLAINTEXT_LISTENER=yes - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CLIENT:PLAINTEXT,EXTERNAL:PLAINTEXT - KAFKA_CFG_LISTENERS=CLIENT://0.0.0.0:9092,EXTERNAL://0.0.0.0:9093 - KAFKA_CFG_ADVERTISED_LISTENERS=CLIENT://阿里云外网:9092,EXTERNAL://阿里云外网:9093 - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=CLIENT depends_on: - zookeeper volumes: zookeeper_data: driver: local kafka_data: driver: local docker-compose部署命令
docker-compose up -d 执行后会自动部署zookeeper、kafka服务
docker 部署时报错 ERROR [KafkaServer id=1001] Fatal error during KafkaServer startup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eaa9532a41bb8adbee130c8f7115938/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7d61f523ddcf1cd32241544f617cd39/" rel="bookmark">
			stm32 RT-Thread移植lvgl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 简介 在stm32上移植lvgl，上篇文章中已经讲解过了，今天教大家如何在rt thread中使用lvgl。
二. 移植lvgl 移植好rt -thread和lvgl之后，最大的一点需要注意的是修改堆栈空间的大小。
在裸机工程中，我们是在.s文件中修改的，但是加入了rtthread之后，就不行了。
需要在创建线程的时候，给它一个足够大的栈空间就可以了，其余的和裸机一样，就不作过多的说明了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/283cfe8bbf29467d3ab7f2323aa1cf96/" rel="bookmark">
			docker中neo4j数据导入和导出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导出 首先停止要导出的neo4j数据库
docker-compose stop 或者 docker stop neo4j执行备份
docker run -it --rm -v /data/neo4j:/data neo4j:4.4.7 neo4j-admin dump --to=/data/backups/20220601.db --database=graph.db
参数说明：
-v：/data/neo4j本机数据目录；/data容器内数据目录
--to：数据保存的路径（容期的绝对路径）
--database：数据库启动导出的neo4j数据库
docker-compose start 或者 docker start neo4j 导入 首先停止要导入的neo4j数据库
docker-compose stop 或者 docker stop neo4j执行备份
docker run -it --rm -v /data/neo4j:/data neo4j:4.4.7 neo4j-admin load --from=/data/backups/20220601.db --database=graph.db --force
参数说明：
-v：/data/neo4j本机数据目录；/data容器内数据目录
--from：数据保存的路径（容期的绝对路径）
--database：数据库
--force：强制覆盖原来的数据库启动导入的neo4j数据库
docker-compose start 或者 docker start neo4j 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b7711c19937110a932375d40cd9946/" rel="bookmark">
			R语言怎么批量进行fisher检验？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接上文，朋友告诉我，并不是只求一个 p 值，而是要计算许多 p 值，即批量进行 fisher 检验。
我们先看看数据：
library(knitr) df = read.table('fisher_test.tsv', header = TRUE) kable(df) GenemMutmWtnonMutnonWtTP5314241320IFITM3731429MTRNR2L2533429USP17L10533429CDH1830627CLCNKA632627USP17L18335330GOLGA6L18335528NBPF14731825 这是一个基因突变的统计表，记录了肿瘤转移组与非转移组的基因突变情况，表头解释如下：
Gene, 基因名称
mMut，转移组突变的样本数
mWt，转移组未突变的样本数
nonMut,非转移组突变的样本数
nonWt，非转移组未突变的样本数
现在想知道，表中的基因在转移组与非转移组之间的突变频率是否有显著差异，通过循环进行fisher检验即可，代码如下：
out &lt;- data.frame() for (i in 1:nrow(df)){ t &lt;- fisher.test(matrix(as.vector(t(df[i, 2:5])), ncol=2)) d &lt;- df[i, ] d$p.value &lt;- t$p.value d$OR &lt;- t$estimate[[1]] d$OR.lower95 &lt;- t$conf.int[1] d$OR.upper95 &lt;- t$conf.int[2] out &lt;- rbind(out, d) } kable(out) GenemMutmWtnonMutnonWtp.valueOROR.lower95OR.upper95TP53142413201.00000000.89880780.30886112.617323IFITM37314290.52699811.62594880.36714408.395215MTRNR2L25334291.00000001.09701640.21333076.080139USP17L105334291.00000001.09701640.21333076.080139CDH18306271.00000001.19693310.31677994.766989CLCNKA6326271.00000000.84578130.20007163.571860USP17L183353301.00000000.85901400.10687876.901324GOLGA6L183355280.45868620.48498840.06927612.741811NBPF147318250.57423210.70915400.18979612.587077 可以看到，结果也是一个表格，其中包含原表格数据以及我们最关心的 4 个值：p.value、OR、OR.lower95以及OR.upper95。
粉丝福利 学生信，计算机基础一定要好。毫不夸张地说，计算机基础决定了你能否入门，而生物学修养决定你能走多远。没有出发，如何走得远？
从零开始学生信交流群，免费咨询，量身定制学习计划
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2be55c244bbb67f769b5378f7e5d79/" rel="bookmark">
			深拷贝与浅拷贝的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. js中的深拷贝（值拷贝）： js 中的基本数据类型：String，Number，Boolean，Null，Undefined，在赋值的过程中都是值拷贝。
例如，let a = 10; b = a ，修改其中一个变量的值，不会影响到另一个变量的值。
2.js 中的浅拷贝（引用拷贝）： js 中的对象数据类型：Object，Array，Function，Map，Set，在赋值过程中都是引用拷贝。
let obj = {	name:'静如秋叶', age: 3, height:100 } let obj2 = obj obj2.name = '小花'; console.log(obj) // {name:'小花',age: 3,height:100} console.log(obj2) // {name:'小花',age: 3,height:100} 当修改obj2的name属性时，也会修改obj的name，因为他们指向同一块内存地址。
3. 将浅拷贝转换为深拷贝 在实际的项目开发中，我们在多数情况下不希望将对象进行浅拷贝，因为值会相互影响，容易出错。
3.1 Array的深拷贝 1. 通过slice方法 slice() 操作数组时，不会对原数组有影响，会产出一个新的数组。
let arr1 = [1,42,5,6] let arr2 = arr1.slice() arr2[0] = 100 console.log(arr1) // [1,42,5,6] console.log(arr2) // [100,42,5,6] 数组arr2的改变未引起arr1的变化。
2. 通过concat方法 数组的concat() 方法，能够连接两个数组，同样不会改变原来的数组。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2be55c244bbb67f769b5378f7e5d79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/602afa7822f3e47d51041d5b6e306013/" rel="bookmark">
			告别鼠标神器-----ideavim
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插件神器推荐时间到！！！ ​ hello,大家好！我是留乘船，又到了一年一度的神器分享时刻，入行这么久了，相信大家都有和小编一样的苦恼。当你在键盘敲击着代码的时候，因为有些代码需要用光标选中，进行剪切、复制、删除，替换等操作。每次都需要通过移动鼠标来操作，刚开始写代码的时候科能觉得没什么，但是手放在键盘久了就不想再去碰鼠标去移动光标。尽管IDEA给我们提供着很多的快捷键，但是因为习惯用鼠标而太常用这些快捷键。对于一个程序员在编码的时候，多次挪动鼠标是一个效率极低的行为！
​ 那么有没有一种编辑方式可以不用靠鼠标操作呢？这时学过linux的朋友就熟悉了,那就是"vi/vim"编辑器，使用vim对代码编辑操作就不用使用到烦人的鼠标了。要是可以在IDEA上使用就好了，这个时候“插件”出现在了我的脑海！在花了不到10秒的搜寻过程中我终于找到了：ideavim.那就开始为自己的IDEA赶紧装上吧。
首先打开IDEA，点击file后选择setting
然后选择plugins,并进行搜索，如图所示点击安装
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传
接下来点击RestartIDE重启IDEA
当右下角有哥哥v的标志的时候就说明安装成功：
这时ideavim插件就可以使用了，以后对一行代码进行删除时就按两下d就可以实现了。具体vim语法请看我的这篇博客： link
。学会vim编辑器，你的代码效率直接起飞，至于，鼠标----“在我写代码时，别烦我！我的双手与键盘永不分开”！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82f06b08efd2e63a23ad27365cfe81ed/" rel="bookmark">
			Python中给列表除重(去除重复元素)的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python中给列表除重(去除重复元素)的方法—有两种方法 1、方法一：利用Python内置函数set() （1）set的含义 是一个不允许内容重复的组合，而且set里的内容位置是随意的，所以不能用索引列出。可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。
（2）set()用法 代码如下：
set1 = set([1, 2, 3, 4, 5, 6, 7, 8]) print('set1:', set1) set2 = set('Hello') print('set2:', set2) set3 = set('1233672') print('set3:', set3) 输出结果如下：
set1: {1, 2, 3, 4, 5, 6, 7, 8} set2: {'H', 'e', 'l', 'o'} set3: {'2', '7', '1', '6', '3'} （3）set给列表除重实例(除重并排序) 假如现在有两个列表x和y，如下所示：
x = [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8] y = [2, 126, 65, 28, 9, 513, 344, 217, 2, 126, 65, 28, 9, 513, 344, 217] 现在想对列表x和y中的元素进行排序(按照升序排序)，排序完成后再进行除重。代码如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82f06b08efd2e63a23ad27365cfe81ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4df3041051cdd4db65e640061add2d/" rel="bookmark">
			使用gdb调试Android(aarch 64)可执行二进制文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android官方提供了调试ndk进行
使用场景 在pc端编写Android可执行程序（注意不是App进程程序，这里指的是一个可执行文件比如linux的ELF文件、windows exe文件）
现在市面上基本是都是aarch64位的手机也就是arm64-v8a架构的cpu手机，当然，也可以通过adb shell 'cat /proc/cpuinfo'进行查看
电脑手机模拟器的架构一般是x86架构，下面的教程要按你的架构去选择对应的文件
Main Android是魔改的linux但是一些shell解释器是通用的，且核心架构还是linux内核，我们可以通过C语言编写Android下的可执行文件，首先如下文件：
demo.c
#include&lt;stdio.h&gt; int main(){ printf("hello \n"); return 0; } 在windows下可以通过软件一键运行、在Linux下可以gcc demo.c -o demo、Mac clang demo.c -o demo 那么Android正常情况下是没有终端提供的，就需要电脑进行操作，clang+llvm可以实现进行多架构程序，当然这里不讲太深，在PC端下载Android-NDK就可以得到一个NDK工具包一级目录如下：
21.0.6113669 » ls ~/Library/Android/sdk/ndk/21.0.6113669 CHANGELOG.md ndk-build prebuilt sysroot NOTICE ndk-gdb python-packages toolchains NOTICE.toolchain ndk-stack shader-tools wrap.sh README.md ndk-which simpleperf build package.xml source.properties meta platforms sources 方便起见讲这个目录添加环境变量
export PATH=$PATH:~/Library/Android/sdk/ndk/21.0.6113669 然后在demo.c的同级目录下编写配置文件（也可不同级，但是需要制定路径，这里为了方便），名字不能错Android.mk 、 Application.mk 具体的属性配置可以去官网配合着看
$ cat Android.mk ~/home/work # 一个Android.mk file首先必须定义好LOCAL_PATH变量。 # 它用于在开发树中查找源文件。在这个例子中，宏函数’my-dir’, # 由编译系统提供，用于返回当前路径（即包含Android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a4df3041051cdd4db65e640061add2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f8204a607e9ddfa7d68b14013daa8e/" rel="bookmark">
			初识c语言之循环语句与分支语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
​编辑
一、分支语句（if，Switch）
1、if的基本用法
2、Switch的基本用法
二、循环语句
1、while的基本用法
while中的break问题
while中的continue问题
while中getchar的解读
2、for语句的基本用法
3、do while的基本用法
三、总结
​​​​🛰️🛰️什么是语句呢？a+b;是一个语句，a；是一个语句，甚至；也是一个语句，叫做空语句。
🚄​​​​​​​🚄C语言语句总共分为五类：
1、表达式语句
2、函数调用语句
3、控制语句
4、符合语句
5、空语句
下面我们来了解一下控制语句吧！
一、分支语句（if，Switch） 分支语句又叫做选择语句，其中包括了两大类，一个是if，另一类是Switch
1、if的基本用法 基本类型 if（表达式） 语句； 双分支 if（表达式） 语句； else 语句； 多分支 if（表达式） 语句； else if（表达式） 语句； ... else 语句； 🛳️🛳️当if中表达式为真时，进入if，为假时，无法进入。什么是真与假？当表达示为0时，则是假，非0则是真，也就是表达式正确时是非0，错误的时候为0。并且，当表示的值为0时，也为假，为非0的值的时候，为真。这个真假，需要我们自己意会一下。
当不满足所有分支进入的条件时，则进入else分支，进行else分支的内容
悬空else
🛰️🛰️当if中内容有多条语句时我们需要用{ }，来进行代码块的使用，不然会造成悬空else，只会读取第一个语句的内容，让我们不方便判断程序的运行。下面我们来看一个例子
#include&lt;stdio.&gt; int main() { int a=0; int b=2; if(a==1) if(b==2) printf("hehe\n"); else printf("haha\n"); return; } 🛳️🛳️大家觉得答案是什么呢？是不是觉得是hehe，其实答案是空。因为根本就进入不了循环，else是就近匹配，所以他与第二个if匹配，而第二个if在第一个if的里面，第一个if根本就不能进入。这里就体现了格式和好的编译器的重要性。如果我们加了{ }，是不是就更加容易判断了，而好的编译器，会帮你提前进行代码阅读，从而排版与第二个if对齐，会让你发现自己的错误，提高可读性。
2、Switch的基本用法 🚄​​​​​​​🚄Switch一般用于多分支，且分支点的条件一般为唯一点时使用，这时相较于if更加方便
switch（整型表达式） { case 整型常量表达式： 语句； } 🛳️🛳️当整型常量等于整型表达的值时，就从该case开始执行Switch语句中的内容；值得注意的是，如果没有break，则会一直按顺序向下执行，直到遇到break才跳出Switch语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92f8204a607e9ddfa7d68b14013daa8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0415103bd42aba9326a9ba27b58faf6/" rel="bookmark">
			java基础学习（一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java简介 java是被广泛运用的一种编程语言，用于应用程序开发的计算机平台。在笔记本电脑，数据中心，游戏机，手机等中大量应用java。它的特点有：
面向对象
跨平台（一次写入，导出运用)
java 的发展历程 1990年由sun公司创立，最初命名为Oak,致力于家用电器等小型系统的程序语言，需求没有预期高，最终放弃。创始人 James Gosling中文名詹姆斯·高斯林
1995年以java的名称正式发布
2000年发布JDK1.3版本
2004年发行JDK1.5，改名java SE 5.0,java EE,Java ME
2009年Oracle公司收购sun公司的java
2013年发行JDK1.8版本
目前市场上的主流产品为1.8,11,17
java的运行机制 简单来说Java程序的运行机制分为编写、编译和运行三个步骤。 编写是指在Java开发环境中进行程序代码的编辑，最终生成后缀名为“.java”的Java源文件。 编译是指使用Java编译器对源文件进行错误排查的过程，编译后将生成后缀名为.class的字节码文件，该文件可以被Java虚拟机（JVM）的解释器正常读取。 运行是指使用Java解释器将字节码文件翻译成机器代码，执行并显示结果。
JDK安装 在系统环境配置中添加变量名：JAVA_HOME，并添加地址如：C:\Program Files\Java\jdk1.8.0_311
并在系统环境配置中的path中添加%JAVA_HOME%\bin
%是引用的意思，exe文件在bin目录下
（注意： 如果path环境变量中有其它java目录的设置，先删除掉。 比如安装jdk之后就会有一个 .... /Oracle/javapath）
检查是否配置正确
在命令窗口输入java -version，若正确则显示JDK版本号，可改变JAVA_HOME中的地址改变所使用的JDK版本。
纯手工java程序 建立txt文件，并改名hello.java
public class Hello{ public static void main(String[] args){ System.out.println("Hello HQYJ"); } } 编译java文件为字节码文件(class文件)
在命令窗口进入文件所在位置
dir 显示文件目录
start 文件夹路径 打开文件夹
explorer 文件夹路径 =start
文件路径 打开文件
javac hello.java 执行成功后会在当前目录生成一个同名的class文件 Hello.class(字节码文件)
在命令行执行命令
java命令后面的参数是类名， 不需要扩展名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0415103bd42aba9326a9ba27b58faf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7138e2e6960f22a84833696dc7fad3/" rel="bookmark">
			Sql注入流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Sql注入本质是把用户输入都数据当做代码来执行，最终达到欺骗服务器执行恶意的SQL命令。
标题Sql注入的流程： 1、寻找注入点 常见的注入点：网站的用户登录界面，搜索框等
2、判断闭合方式（以sqli-labs靶场的第一、二关为例） 第一关：
可以发现：第一关输入id=1和输入id=1sdgfgkdg显示的内容相同且不报错。
所以：第一关属于字符型，需要判断闭合方式。
判断方法：观察报错信息，去掉两边的分号和输入内容，右边的内容就是其闭合的方式。
通过观察图中报错信息可以知道闭合方式为’
即单引号闭合
第二关：
可以发现第二关报错
所以，第二关属于数字型，不需要判断闭合方式。
3、验证漏洞 ？id = 1 and 1 --+ 正常显示
？id = 1 and 0 --+ 无显示
可以通过sql命令来控制页面显示。
4、判断列数及回显位 列数：
？id = 1 order by 3 --+
若3正常显示且4报错，则证明列数为3
回显位：
?id=-1 union select 1,2,3 --+
可以看到回显位为2、3
5、取数据 A、查数据库名
在2或3的位置加上database()，得到数据库名为：security
B、查表名
在2或3的位置加上 (select group_concat(table_name) from information_schema.tables where table_schema=database()) 查看数据库下所有的表名。
C、查列名
在2的位置加上 (select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=’emails’) 查看emails表下所有的列。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f7138e2e6960f22a84833696dc7fad3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/691b98a73962fb3e1e18e89ea1eb7bd8/" rel="bookmark">
			java FileReader类、FileWriter类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、FileReader 类型概述 Java FileReader类用于从文件读取数据。它以字节格式返回数据，例如FileInputStream类。它是面向字符的类，用于Java中的文件处理。
构造方法 FileReader(String file)	以字符串形式获取文件名。它以读取模式打开给定的文件。如果文件不存在，则抛出FileNotFoundException。
FileReader(File file) 在文件实例中获取文件名。它以读取模式打开给定的文件。如果文件不存在，则抛出FileNotFoundException。
对象方法 1、close函数 void close() 关闭该流并释放与之关联的所有资源。
2、getEncoding函数 String getEncoding() 返回此流使用的字符编码的名称。
3、read函数 int read() 读取单个字符。返回值为读入字符对应的int值（0~65535）
int read(char[] cbuf, int offset, int length) 将字符读入数组中的某一部分。返回值为读入字符个数
使用示例 import java.io.File; import java.io.FileReader; import java.io.IOException; import java.io.PrintStream; public class Test { public static void main(String[] args) throws IOException { // 创建一个文件对象 File file = new File("src/demo5/test.txt"); // 创建一个FileReader对象 FileReader fileReader = new FileReader(file); // 将文件内容复制到数组a char[] a = new char[10]; fileReader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/691b98a73962fb3e1e18e89ea1eb7bd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f0dee1b0b997351db7d0de59382e82e/" rel="bookmark">
			k8s nginx .yaml 测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apiVersion: apps/v1
kind: Deployment
metadata:
name: nginx-test
spec:
replicas: 2
selector:
matchLabels:
app: nginx-test
template:
metadata:
labels:
app: nginx-test
spec:
containers:
- name: nginx-test
image: nginx:1.19
ports:
- containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
name: nginx-test
spec:
type: NodePort
ports:
- port: 8080
targetPort: 80
nodePort: 38888
selector:
app: nginx-test
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dfabddd5f760c18c2304350e1c47596/" rel="bookmark">
			使用ComposeDesktop开发一款桌面端多功能APK工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 终于算是忙完了一个阶段！！！从4月份开始，工作内容以及职务上都进行了较大的变动，最直接的就是从海外项目组调到了国内项目组。国内项目组目前有两个应用在同时跑着，而且还有几个马甲包也要维护，不知道大家发版的时候复杂不复杂，反正我们每次发版的时候都需要经历–打包、加固、对齐、重签名、打渠道包、上传云存储、生成渠道推广链接、生成内更SQL、上传Mapping文件等等步骤(xN)，简直是折磨人啊。
所以首要任务就是做出一套自动化的基础设施来，最初直接考虑到的方案是【Jenkins+Docker+360命令行加固+VasDolly+Bugly等】的方案（下一篇文章会给大家分享该方案），整个过程下来基本能达到自动化的目的。就这么稳定的跑了一个多月，然而，在5月下旬的时候360加固发布了一个通知，大致内容就是免费版用户无法使用命令行的加固方式了，只能手动用工具加固。这就导致最初的方案直接垮掉，我花费了个把月学习Linux，Pipeline，Docker，还制作了各种镜像，结果突然不能用了，心塞。然而路还是要继续走下去的，在尽量不花钱的前提下，想到了开发桌面端工具的方案。
功能一览 接下来先给大家一览下桌面端工具的基本功能，我的电脑是Windows的，所以都是基于Windows平台下的build-tools相关工具进行开发的。首先大部分的功能都是基于jar或exe文件，那么在Java（Kotlin）中我们可以通过如下方式来调用这些外部程序，exec其实最终也是调用了ProcessBuilder，整体的原理就是如此：
//方式1 Runtime.getRuntime().exec(cmd) //方式2 ProcessBuilder(cmd) 多渠道打包 这是该工具最基本的功能，使用VasDolly方案对APK文件进行多渠道打包（当然该APK文件需要是签名好的）。
多渠道包命令行工具即 VasDolly.jar，该文件可以在上述GitHub仓库中找到，常用的命令如下：
// 获取指定APK的签名方式 java -jar VasDolly.jar get -s [源apk地址] // 获取指定APK的渠道信息 java -jar VasDolly.jar get -c [源apk地址] // 删除指定APK的渠道信息 java -jar VasDolly.jar remove -c [源apk地址] // 通过指定渠道字符串添加渠道信息 java -jar VasDolly.jar put -c "channel1,channel2" [源apk地址] [apk输出目录] // 通过指定某个渠道字符串添加渠道信息到目标APK java -jar VasDolly.jar put -c "channel1" [源apk地址] [输出apk地址] // 通过指定渠道文件添加渠道信息 java -jar VasDolly.jar put -c channel.txt [源apk地址] [apk输出目录] // 提供了FastMode，生成渠道包时不进行强校验，速度可提升10倍以上 java -jar VasDolly.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dfabddd5f760c18c2304350e1c47596/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/203e84293be0f2089b3d8de54bd16830/" rel="bookmark">
			Burp Suite下载CA证书
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Burp Suite默认这能抓取HTTP的包，如果要抓HTTPS的包的话，需要下载Burp Suite的CA证书。
下载方法如下：
一、设置浏览器代理 在浏览器设置中搜索net，打开网络设置
手动设置http代理为127.0.0.1，端口8080。
二、下载CA证书 浏览器访问http://burp （只有设置浏览器代理才能访问成功）
点击右侧的CA Certificate下载
三、导入证书 浏览器设置–搜索证书–查看证书
–证书颁发机构–导入–确定
至此，可以使用Burp Suite抓取HTTPS的包了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61e71c5f57e57124a2c3879daf997b8/" rel="bookmark">
			遗传算法适应度计算函数——ranking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 调用格式 1.Fitnv=ranking(objv)
2.Fitnv=ranking(objv,rfun)
3.Fitnv=ranking(objv,rfun,subpop)
举个例子 %% 适应度函数——ranking %格式一： objv=[1;2;3;4;5;10;9;8;7;6] fitnv=ranking(objv)%将个体的目标值objv（列向量）按从小到达的顺序排列，并返回个体适应度fitnv的列向量 %例如这里[1;2;3;4;5;10;9;8;7;6]为一个列向量，得到的个体适应度的列向量为：[2.0;1.77;1.55;1.33;1.1;0;0.22;0.44;0.66;0.88] %注意这里返回的列向量的位置还是原先元素的位置。 %这里默认压差为2，所谓压差即是一个[2,0]的区间，将原先的[1，10]映射到[2,0]上,即1为0，10为0其余数字按大小顺序线性插值。 %格式二： %当线性排列的时候，标量指定的选择压差rfun必须要在[1,2]区间，对于非线性排列[1,length(objv)-2]区间 fitnv=ranking(objv,[1.5,0]) %格式三： fitnv=ranking(objv,[2,0],1) %这里subpop是一个任选参数，知名objv中子种群的数量，如果subpop=1则要求，objv中的每一个子种群大小必须相同，如果ranking被调用于多子种群，则ranking独立地对每个子种群执行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9033c937935964ed932082a4be8a6187/" rel="bookmark">
			Java 跳出for循环几个的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一共四种类型 一、跳出本次循环（continue）
for(int i = 0; i&lt; 999; i++){ if(i == 520){ log.debug("啊哈!"); continue; } log.debug("芜湖!"); } 二、跳出本层循环，也就是这个循环体的结束（break）
for (int i = 0; i &lt; 999; i++) { for (int j = 0; j &lt; 999; j++) { if (j == 520) { log.debug("你好啊!"); break; } if (j == 456) { log.debug("我很好!"); } log.debug("芜湖!"); } } 三、.跳出多层循环。（break loop）loop可以自己定义
loop: for (int i = 0; i &lt; 999; i++) { for (int j = 0; j &lt; 99; j++) { if (j == 52) { log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9033c937935964ed932082a4be8a6187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fad8853b63070e5ddd1289fe62d9070/" rel="bookmark">
			fastjson按照ascii码排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JSON.toJSONString(JSON.parseObject(srcData),SerializerFeature.MapSortField);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/701741941cba675f0066d9a57fe6b3bb/" rel="bookmark">
			初识Linux下的gcc与makefile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推荐文章：https://blog.csdn.net/chenlong_cxy/article/details/119183448
最近在学linux相关的操作，接触到makefile文件，在此做个笔记
文章目录 gcc1.预处理2. 编译3.汇编4.链接 makefile不使用makefilemakefile格式第一个makefile常用规则看第二个makefile gcc gcc常用命令选项：
刚接触linux时，关于gcc编译器只会用形如 gcc hello.c 的命令来对代码进行编译（实际上这个命令是一键完成上面四个编译过程的），对整个编译过程还不了解，以至于后面在接触makefile的编写时出问题。现在先来看一看gcc的基础知识：
如上图所示，c程序的编译过程分为以上四个步骤，这四个步骤在c基础中也学过，但过于理论导致一知半解：
预处理：包括(宏替换，头文件展开，去掉注释)，生成.i文件，(看内容实际上也是.c文件)编译 ：检查代码规范，语法错误等，生成汇编文件汇编：转成二进制目标代码链接：生成最终可执行文件 1.预处理 使用命令：gcc -E hello.c –o hello.i，得到预处理后的文件，这里的-o是重命名的意思。如下
可以用vim打开hello.i文件，可看到源代码本只有几行，经过预处理后得到几百行。
2. 编译 使用命令：gcc -S hello.i -o hello.s，生成汇编文件。
用vim打开可见：
3.汇编 使用命令：gcc -c hello.s -o hello.o，生成二进制文件，但还不能直接运行，这里-c命令是将代码转换为二进制语言，不进行链接。
关于-c这个命令，参考gcc 和 gcc -c有什么区别呢
4.链接 使用命令：gcc hello.o。尽管3中得到了二进制文件，但还是不能直接执行，需要通过链接，得到a.out文件，才能运行。
makefile 了解了上述gcc编译过程之后，接下来就可学习makefile了。
先给出测试例子–三个.c文件：
main.c ：
#include &lt;stdio.h&gt; extern void fun1(); extern void fun2(); int main() { printf("main\n"); fun1(); fun2(); return 0; } fun1.c：
#include &lt;stdio.h&gt; void fun1() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/701741941cba675f0066d9a57fe6b3bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d17bce4f8151d8844a5d6c61db1a2e7/" rel="bookmark">
			python 导包错误“ImportError: No module named”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 完整的导包错误参考博客：python找不到包的总结: ImportError: No module named
我在添加了__init__.py 后仍然报错找不到包，通过添加环境变量即可解决：
export PYTHONPATH=. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/badde390fefcf28f9e263d6439c6ced2/" rel="bookmark">
			动态加载内容爬取，Ajax爬取典例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本问包含内容，Ajax数据获取，线程池简单使用，xlwt模板数据写入exel
有时候我们在用 requests 抓取页面的时候，得到的结果可能和在浏览器中看到的不一样：在浏览器中可以看到正常显示的页面数据，但是使用 requests 得到的结果并没有。这是因为 requests 获取的都是原始的 HTML 文档，而浏览器中的页面则是经过 JavaScript 处理数据后生成的结果，这些数据的来源有多种，可能是通过 Ajax 加载的，可能是包含在 HTML 文档中的，也可能是经过 JavaScript 和特定算法计算后生成的。
目录
1.导入模块
2.获取请求头
3.获取Ajax加载数据
4.解析页面信息
5.将获取到的数据写入exel
6.开辟线程池运行程序
7.相对完整代码
下面我们以新发地为例获取Ajax动态加载的内容
1.导入模块 注意看代码注释
import requests import xlwt # 用于将数据储存到exel文件 from concurrent.futures import ThreadPoolExecutor # 导入线程池给爬虫加速 简单请求我们使用requests就好 2.获取请求头 在开发者面板找到如下请求头，这是Ajax数据获取所需的请求头
如果想要运行注意根据实际情况修改请求头参数
base_url = "http://xinfadi.com.cn/getPriceData.html" headers = { 'Host': 'xinfadi.com.cn', # 在开发者面板都可以找到的请求头 'Origin': 'http://xinfadi.com.cn', 'Referer': 'http://xinfadi.com.cn/priceDetail.html', 'User-Agent': '', # 填写自己的User-Agent 'X-Requested-With': 'XMLHttpRequest' # 获取Ajax数据需要加入的请求 } 链接可以根据实际情况填入
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/badde390fefcf28f9e263d6439c6ced2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5984ff748a1c810f507b49017ac0c94/" rel="bookmark">
			R语言怎么计算两个比值的 p 值？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有朋友问两个比值数据，怎么求他们的 p 值？
例如，两组人，分别接受两种药物治疗，想知道疗效之间是否有差异，计算 p 值。
接受药物 1 治疗，30 人，其中 20 人有疗效，10 人没有疗效。 接受药物 2 治疗，30 人，其中 10 人有疗效，20 人没有疗效。 直观上判断，药物 1 的疗效要好（20:10 vs 10:20），但与药物 2 的疗效相比，是否达到了显著性的差异了呢？
这种情况可以用 fisher 检验来探索，R 代码如下：
fisher.test(matrix(c(20, 10, 10, 20), ncol = 2)) ## ## Fisher's Exact Test for Count Data ## ## data: matrix(c(20, 10, 10, 20), ncol = 2) ## p-value = 0.01938 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5984ff748a1c810f507b49017ac0c94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fff8cc6bbf3bc32ef6ddbee544366d0a/" rel="bookmark">
			图解最小生成树 --- 克鲁斯卡尔算法(Kruskal)与普里姆算法(Prim)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般来说，最小生成树算法以克鲁斯卡尔(Kruskal)和普里姆(Prim)较为经典。最小生成树是什么呢？
举个例子，对于无向图来说，如果2个顶点如果要实现互相连通，至少需要1条边；3个顶点要互相连通，至少需要2条边；n个顶点如果需要互相连通，至少需要n-1条边。如果n个顶点有n条边，那一定有一个环存在。生成树就是无环图。
克鲁斯卡尔(Kruskal) 算法思想
首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。
流程 下图是所有点之间的权重图
第1-2步
第一步：因为E和F之间的权值是2，权值最小，所以第一步选择E和F相连
第二步：在剩下的权值中，权值3最小，是C和D。而且，C和D之间连接后不会产生环，所以第二步选C和D相连
第3-4步
第三步：在剩下的权值中，权值为4是最小的，也就是E和D相连，而且E和D相连后不会产生环，所以选择E和D相连。
第四步：在剩下的权值中，权值为5是最小的，也就是C和E相连，但是如果把C和E相连后，（CDE）就产生了环，就不是生成树了，摒弃。接着，剩下的权值中，权值为6是最小的，也就是C和F相连，但是如果把C和F相连后，（CFED）就产生了环，就不是生成树了，摒弃。接着，剩下的权值中，权值为7是最小的，也就是B和F相连，B和F相连后，不会产生环。所以选择B和F相连。
第5-6步
第五步：剩下权值中，可以把E和G能连起来
第六步：剩下权值中，可以把A和B连起来，其他的连起来会产生环。到此，克鲁斯卡尔(Kruskal)算法结束。
普利姆(Prim) 算法思想
(将所有顶点分成两个集合，集合M和N。M是需要的，N是剩下的)
①以一个点出发，这个点组成一个集合M，剩下的点组成集合N
②在集合B中找一个点，这个点距离集合M距离最小
③循环第2个过程，直到集合M是全集，N是空集
流程
下图是所有点之间的权重图
第1-2步
第一步：以A点出发（也可以以其他的点），A点组成了M集合，所有的点到集合M的距离中，最小的是B-A，距离为4。
第二步：此时A-B组成了M集合，剩下的点到集合M的路径有C-M和H-M，距离都是8。随便定一个点H，（也可以C）
此时B-A-H组成一个集合M
第3-4步
第三步：B-A-H组成集合M，剩下的点到这个集合的距离的最小值是1，也就是G到M的距离，也就是G到H的距离。
第四步：B-A-H-G组成集合M，剩下的点到这个集合的距离的最小值是2，也就是F到M的距离，也就是F到G的距离
此时B-A-H-G-F组成集合M
第5-6步
第五步：B-A-H-G-F组成集合M，剩下的点到这个集合的距离的最小值是4，也就是C到M的距离，也就是C到F的距离。
第六步：B-A-H-G-F-C组成集合M，剩下的点到这个集合的距离的最小值是2，也就是I到M的距离，也就是I到C的距离
此时B-A-H-G-F-C-I组成了集合M
第7-8步
第七步：B-A-H-G-F-C-I组成集合M，剩下的点到这个集合的距离的最小值是7，也就是D到M的距离，也就是D到C的距离。
第八步：B-A-H-G-F-C-I-D组成集合M，剩下的点到这个集合的距离的最小值是9，也就是E到M的距离，也就是E到D的距离
此时B-A-H-G-F-C-I-D-E组成了集合M，算法结束。
总结
克鲁斯卡尔(Kruskal)和普里姆(Prim)都是最小生成树的算法，克鲁斯卡尔(Kruskal)是近似贪心算法，一直找权值最小的边，但是这个过程不能让这棵树有环。普里姆(Prim)体现一种集合的思想，将这棵树作为一个整体，从剩下的点中找到与这个集合的最短的边。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecc0b5da30bb0f9ebaf489572050b4cb/" rel="bookmark">
			MATLAB图像处理之图像类型的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像类型转换函数表 函数名函数功能dither图像抖动，将灰度图变成二值图或将真彩色图像抖动成索引色图像gray2ind将灰度图像转换成索引图像grayslice通过设定阈值将灰度图像转换成索引色图像im2bw通过设定亮度阈值将真彩色，索引色，灰度图转化成二值图像 ind2gray
将索引图像转化成灰度图像ind2rgb将索引图像转化成真彩色图像mat2gray将数值矩阵转换成灰度图像rgb2gray将真彩色图像转化为灰度图像rgb2ind将真彩色图像转化为索引色图像 RGB图像转换为灰度图像 在MATLAB中，将RGB图像转换为灰度图像，需要调用函数rgb2gray( )，其调用格式如下：
X=rgb2gray(I)：该函数是将RGB图像I转换为灰度图像X，其中I表示RGB图像，X表示转换后的灰度图像。 I = imread('test1.jpg'); %读取文件格式为.jpg X = rgb2gray(I); %将RGB图像转化为灰度图像 figure, subplot(121),imshow(I); subplot(122),imshow(X); 运行结果如下：
RGB图像转换为索引图像 在MATLAB中，将真彩色图像转换成为索引图像直接调用函数rgb2ind ( )，在函数rgb2ind ( )还可以输入参数项dither_option，其表示是否使用抖动，其调用格式如下：
[X,map] = rgb2ind(I,tol) ：该函数利用均匀量化方法将RGB图像转换为索引图像，I为原RGB图像，容差为tol，map包含至少个颜色[X,map] = rgb2ind(I,N) ：使用具有 Q 种量化颜色的最小方差量化法并加入抖动，将 RGB 图像转换为索引图像 X，关联颜色图为map，map中至少包含N个图像。X= rgb2ind(I,map)： 该函数通过与RGB中最相近的颜色进行匹配生成颜色映射的表map，将RGB图像转换为索引色图像。其中I为原RGB图像，map中的颜色是与RGB图像中颜色匹配最相近的颜色。[...]= rgb2ind(...,dither_option)：启用或禁用抖动。其中dither表示抖动，从而达到更好的颜色效果；nodither表示不抖动。 &gt;&gt; RGB = imread('test1.jpg'); &gt;&gt; [X1,map1]=rgb2ind(RGB,64); &gt;&gt; [X2,map2]=rgb2ind(RGB,0.2); &gt;&gt; map3=colorcube(128); &gt;&gt; X3=rgb2ind(RGB,map3); &gt;&gt; figure; &gt;&gt; subplot(131);imshow(X1,map1); &gt;&gt; subplot(132);imshow(X2,map2); &gt;&gt; subplot(133);imshow(X3,map3); 运行结果如下：
灰度图像转化为索引图像 在MATLAB中，灰度图像是一个二维数组矩阵，而索引图像不仅包括一个二维的数组矩阵，还包括一个M×3的颜色映射表。所以要想将灰度图像转换成为索引图像，则必须生成对应的颜色映射表。在MATLAB中可以直接调用函数gray2ind( )来实现图像转换。其调用格式如下：
[X,map]=gray2ind(I,n)：该函数是将灰度图像I转换为索引图像，其中I指的是原灰度图像，n是灰度级数，默认值为64，[X,map]对应转换后的索引图像，map中对应的颜色值为颜色图gray(n)中的颜色值。[X,map]=gray2ind(BW,n)：该函数是将二值图像BW转换为索引图像，其中I指的是二值图像，n是灰度级数，默认值为2，[X,map]对应转换后的索引图像，map中对应的颜色值为颜色图gray(n)中的颜色值。二值图像实际上也是灰度图像，只是其灰度级为2 而已 &gt;&gt; I=imread('test.tif'); &gt;&gt; [X,map]=gray2ind(I,128); &gt;&gt; figure,imshow(I); &gt;&gt; figure,imshow(X,map); 运行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecc0b5da30bb0f9ebaf489572050b4cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98fd409a1f2524d1306db2617d3b732b/" rel="bookmark">
			空洞卷积详解（输入输出大小分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		空洞卷积 空洞卷积的提出主要是为了解决图像分割问题中存在的信息丢失问题，之前的图像分割算法往往会使用深度卷积神经网络，卷积层之间往往会夹杂着池化层来增大感受野，最后再通过一系列的上采样操作来将小尺寸的特征图样变换到输入图像的大小输出。使用池化层固然可以增加感受野，但是这一操作过程中会丢失许多的信息，这一点和hinton对于池化层的想法不谋而合。而同样的在上采样过程中，从小尺寸变换到大尺寸会存在着精度损失的问题，这一点在图像先缩小再复原的过程就可见端倪。因此我们需要一种可以不使用池化（下采样）和上采样，就能增加感受野的操作来代替原本的池化+上采样操作。空洞卷积应运而生。
空洞卷积和普通卷积 空洞卷积和普通卷积的区别不大，只是多了一个 "dilation rate"的参数，这个参数定义了卷积核中两相邻元素的距离。普通卷积中卷积核中不同元素是紧密相连的，而在空洞卷积的卷积核中不同元素的距离可以不为1，这个距离越大意味着空洞卷积的感受野越大； 或者也可以认为是一个相同感受野大小的普通卷积，只是中间填充了许多权重不更新的零值。普通卷积和空洞卷积的示意图如下所示
上图即为普通卷积，下图为dilation rate=2时的空洞卷积，可以看出一个 3 × 3 3\times3 3×3大小的空洞卷积在进行卷积操作时，核捏内元素的距离为2，实际上等价于一个 5 × 5 5\times 5 5×5大小的只在棋盘区域存在非零值的普通卷积。
而普通卷积可以通过padding操作使得输入输出特征图样的大小相同，因此空洞卷积拥有了以下两个优势。1
扩大感受野: 使用空洞卷积可以使得参数量相同的情况下，增加卷积的感受野，原本 3 × 3 3\times3 3×3的卷积核只能覆盖面积为9的区域，而相同参数量的空洞卷积可以覆盖面积为25的感受野。且随着dilation rate的提升，感受野会进一步的増大。起到了原本池化层的作用。保持图像分辨率：由于空洞卷积可以认为是稀疏的普通卷积，在运算过程中我们可以通过paddding使得输入输出特征图样的分辨率相同。从而在图像分割任务中，避免了下采样和上采样带来的信息损失。 以上两个优势使得空洞卷积较好的适应于图像分割任务，可以摒弃原本的池化和上采样操作。而据作者在论文中的描述，通过设置不同的dilation rate，卷积操作拥有了不同大小的感受野，可以获得多尺度的信息2。因此作者使用了连续7层dilation rate不完全相分别为{1, 1, 2, 4, 8, 16, 1, 1}的空洞卷积层构成了”上下文模块（context module）"，从而可以聚合多尺度的上下文信息3。（说实话，没看出这里和多尺度有啥关系，笔者所认为的多尺度信息应该指的是对不同分辨率的特征图样进行操作，如FPN；或者是使用不同大小的卷积核对同一特征图样进行操作，再进行拼接，如GoogLeNet，但这里的空洞卷积层是连缀在一起的，基本就类似于一系列不同大小的卷积层级联，没看出和多尺度的联系在哪，也没找到解释，可能作者意思是只要使用了不同大小的卷积核就算是多尺度。）
空洞卷积感受野的计算 空洞卷积感受野的计算和普通卷积是一样的，只是需要将真实的卷积核大小用dilataionn rate补足即可。堆叠后的普通卷积感受野大小为4:
r n = r n − 1 + ( k n − 1 ) ∏ n = 1 n − 1 s i r_n=r_{n-1}+(k_n-1)\prod^{n-1}_{n=1}s_i rn​=rn−1​+(kn​−1)n=1∏n−1​si​
其中 r n r_n rn​为本层的感受野大小， k n k_n kn​为本层的核尺寸（实际覆盖尺寸，空洞卷积需要考虑dilation rate,池化层同理）， s i s_i si​为第 i i i层的步长。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98fd409a1f2524d1306db2617d3b732b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e8d050fe4526cb88f331dc1d183fb3/" rel="bookmark">
			HTML5&#43;CSS3实现小米商城 （完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 对于小米商城，也是自己初学前端的一个小作品吧，这个网页大概写了有三四天吧，总体感受就是写着还行，只要有耐心，就一定能成功。
一 、网页分析 1. 头部导航栏。 2. 两边的侧边栏。 3.中间的轮播图。 4.下面的广告部分。 二 、效果展示 三 、代码分析 注 ：因为代码较多，这里展示部分，全部代码 放在下方 链接网盘里。 1. 轮播图部分 .head3 { // CSS部分 width: 1226px; margin-left: 146px; margin-right: 146px; height: 400px; margin-top: 14px; margin-bottom: 35px; overflow: hidden; float: left; } .head3_lunbo { width: 4904px; height: 400px; animation: text 15s infinite backwards; /*消除图片间隔*/ } .head3_lunbo img { width: 1226px; height: 400px; float: left; } @keyframes text { /*0%-20%是播放下一个图片，0%-10%是图片暂停的时间*/ 0%, 20% { margin-left: 0px; } 25%, 45% { margin-left: -1226px; } 50%, 70% { margin-left: -2452px; } 75%, 100% { margin-left: -3678px; } } &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e8d050fe4526cb88f331dc1d183fb3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e40df28e53da4530a2fc65753ec5a877/" rel="bookmark">
			office回退版本，从2021到2019
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装office2021，把office2021卸载后重新安装了2019的版本。一直提示
后来在网上查了一下，原来是因为版本许可证书的问题。之前office2021的版本许可证书还在，我们要做的就是把许可证书卸载掉就OK了。
搜索框里搜索cmd命令，然后用管理员身份打开。（必须用管理员身份打开）
使用cd命令切换到C:\Program Files (x86)\Microsoft Office\Office16目录。输入命令cscript ospp.vbs /dstatus查看office版本证书，如下图所示：
手工输入命令卸载许可证
卸载成功，再次输入命令确认一下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e08de76b4b12d50229de0384376ca3c8/" rel="bookmark">
			辗转相除法求最大公约数--递归函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目的：定义递归函数来求两个数的最大公约数
/* 目的：辗转相除法求最大公约数。 方法：函数的递归调用 */ # include &lt;stdio.h&gt; //首先定义一个递归函数，两个整型形参，返回最大公约数。 # 大数在右小数在左 int gcd(int a, int b) { if(b%a==0) return a; else return gcd(b%a,a); } int main(void) { int num_1, num_2; int res, temp; printf("请输入两个整数，中间用空格隔开："); scanf("%d %d", &amp;num_1, &amp;num_2); if(num_1&gt;num_2)//保证调用gcd函数时两个参数从小到大排列 { temp=num_1; num_1=num_2; num_2=temp; } res=gcd(num_1, num_2); printf("%d和%d之间的最大公约数是%d。", num_1, num_2, res); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b12db8ce826c7faed10f3606ee3b9562/" rel="bookmark">
			关于数字类型的字符串，或者double，或者integer 相除得到百分数 并四舍五入保留两位小数的通用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，数字类型的字符串，相除得到百分数 并四舍五入保留两位小数的通用方法
（注意的点：1，如何判断字符串是合法的数字–包括小数，正负数（看下面代码中的正则表达式，但是效率不高，详细解释看第6点）
2，字符串的数字怎么转变成数字类型—new BigDecimal(v1)
3，BigDecimal类型的数字怎么和零进行比较
4，b1.divide–进行除法
5，percent.format–对一个数字生成百分数
6，如何判断字符串是数字，
链接：1，https://www.jianshu.com/p/bf81ede32976
Java正则表达式验证字符串是否为正负整数和小数
注意：用正则表达式判断 没有StringUtils.isNumeric(str)效率高。
但是StringUtils.isNumeric(str)有一个坑：https://blog.csdn.net/qq_53316135/article/details/120267724
System.out.println("传入小数输出的结果为：" + StringUtils.isNumeric("1.0")); // false 那用正则表达式效率不高，StringUtils.isNumeric又判断不了正负数和小数，怎么办呢？
看StringUtils.isNumeric的内部实现：
public static boolean isNumeric(String str) { if (str == null) { return false; } int sz = str.length(); for (int i = 0; i &lt; sz; i++) { if (Character.isDigit(str.charAt(i)) == false) { return false; } } return true; } 可以看到：是判断每位是否是数字，那么改进一下这个方法：当有小数点或者正负号的时候，不return false ，return true就可以了
还有一个办法更简单：https://blog.csdn.net/weixin_52935673/article/details/122718608
只不过你的项目中要能引入：cn.hutool.core.util.NumberUtil这个包）
7，java判断字符串是否为double型：https://blog.csdn.net/JauneChing/article/details/122431885
/** * 两个数相除，返回一个百分数 * @param v1 * @param v2 * @return */ public static String getRatio(String v1, String v2) { String regularExpression = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b12db8ce826c7faed10f3606ee3b9562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f02f8e60812ac5b064e7bb7a0dbda6b/" rel="bookmark">
			kali中使用Docker搭建vulhub靶场和vulapps靶场（新手向）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 Docker安装与配置 1、Docker安装 sudo apt-get install -y docker-compose 2、查看版本 docker --version
docker-compose --version
3、启停管理： sudo systemctl start/stop/restart docker 4、配置加速器 vim /etc/docker/daemon.json 按a/i/o进入编辑模式，输入以下内容保存退出（按esc键，输入:wq）
{"registry-mirrors":[ "https://dockerhub.azk8s.cn", "https://reg-mirror.qiniu.com", "https://1rqfztnd.mirror.aliyuncs.com" ] } 5、使加速器生效 重新加载配置文件
systemctl daemon-reload
重启docker
systemctl restart docker
二、 Vulhub靶场搭建 1、下载vulhub git clone https://github.com/vulhub/vulhub.git 2、用cd命令切换到vulhub目录，在用ls命令查看目录内容 3、vulhub的使用（以tomcat弱口令靶场为例） 4、建立容器 docker-compose build 5、启用漏洞环境 docker-compose up -d 6、访问靶场环境 虚拟机IP：8080（虚拟机IP通过ifconfig命令查看）
7、关闭漏洞环境 docker-compose down 三、 vulapps靶场搭建 1、下载镜像 docker pull medicean/vulapps:s_shiro_1
2、启用vulapps docker run -d -p 80:8080 medicean/vulapps:s_shiro_1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f02f8e60812ac5b064e7bb7a0dbda6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a514e0ae79a4e5116128976fa88a61d/" rel="bookmark">
			标准C库的IO函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、标准C的IO函数二、虚拟地址空间三、文件描述符四、Linux的系统调用open，打开文件closeopen，创建文件readwritelseekstatlstataccesschmodchmodtruncatemkdirrmdirrenamechdirgetcwdopendirreaddirclosedirdupdup2fcntlerrno 总结 前言 标准C库的IO函数就是调用Linux系统的IO函数。
一、标准C的IO函数 库函数参数返回值FILE* fopen(const char* pathname,const char* mode)pathname: 路径名字，mode: 打开方式成功：文件指针，失败：NULLint fclose(FILE* stream)stream: 文件指针成功：0，失败：-1int fseek(FILE* stream,long offset,int whence)【文件偏移】stream: 文件指针，offset： 偏移数（负号向左，正好向右），whence： SEEK_SET文件的开头，SEEK_CUR 文件指针的当前位置，SEEK_END 文件的末尾成功：0，失败 -1long int ftell(FILE *stream)【返回当前文件位置】stream： 文件指针成功：标识符的当前值，失败：-1void rewind(FILE* stream) 【返回到文件开头】stream： 文件指针char *fgets(char *s, int size, FILE *stream)s: 存储读到的字符，size： 最大存储字符数，stream： 文件指针成功：读到的字符，失败：NULLint fputs(char* s,FILE* stream)s： 写入的字符，stream： 文件指针成功：0，失败：-1size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 【二进制读入】ptr： 存放文件内容地址，size： 读取的块大小，nmemb： 块数（读取文件大小 = 块数*每块大小） ，stream： 文件指针成功读取到文件块数size_t fwrite(void *ptr, size_t size, size_t nmemb, FILE *stream) 【二进制写出】ptr： 写入文件内容地址，size： 块大小，nmemb： 块数（写出文件大小 = 块数*每块大小），stream 文件指针成功：写入到文件块数int fflush(FILE *stream) 【刷新缓冲区】stream： 文件指针成功：0,失败：-1 文件指针（结构体）的包含内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a514e0ae79a4e5116128976fa88a61d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db460a7e8c145fc1f53465a66bcddb1e/" rel="bookmark">
			pyspark基础学习——数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、准备工作和数据的导入选择1.1 导入数据1.2 选择数据子集：1.3 列名重命名 二、数据清洗2.1 检测空值数量2.2 删除存在空值的行2.3 forward，backward填充 三、 数据处理3.1 数据筛选3.2 数据统计3.3 数据类型转换3.4 采用SQL语法进行处理 四、数据导出总结 前言 上一篇文章中讲了如何在windows下安装和检测: pyspark，同时简单介绍了运行的环境。本文想就我的一些学习经验，分享一下使用pyspark来处理csv文件上的一些常用的pyspark语法。
一、准备工作和数据的导入选择 运行python代码，第一件事当然是导入对应的包，同时我们要为spark先创建好相应的环境，并且，spark中支持SQL，而且在SQL中有众多的函数，因此我们可以创建SparkSession对象，为了后续SQL函数的调用，我们要导入functions包，以及数据类型转换的时候，我们要导入types的包。
import pyspark from pyspark.sql import SparkSession from pyspark.sql.types import * from pyspark.sql.functions import * from pyspark.sql.types import TimestampType spark = SparkSession.builder.getOrCreate() sc = spark.sparkContext 1.1 导入数据 将csv文件导入为Dataframe样式：
header表示是否需要导入表头；inferSchema表示是否需要推导出数据的类型（false默认为string）；delimiter表示指定分隔符进行读取。file对应文件的位置。
df1 = spark.read.options(header='True', inferSchema='True', delimiter=',').csv(file) 1.2 选择数据子集： drop中填入不需要的列的列名。
df2 = df1.drop('列名') 1.3 列名重命名 df3=df2.withColumnRenamed("original name", "modified name") 如果有多个列的列名要进行修改，可以直接在后面再加上withColumnRenamed()进行修改
二、数据清洗 因为数据本身的问题，在处理的过程中需要我们对一些空值、异常值等进行处理。但是此次作业获取到的数据中主要是对空值的处理，因此对于异常值的处理不进行讨论
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db460a7e8c145fc1f53465a66bcddb1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b70c13bbc014c67ddcd904564e52bae/" rel="bookmark">
			Jetson-inference -Coding Your Own Image Recognition Program (Python)学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有多种类型的深度学习网络可用，包括识别、检测/定位和语义分割。我们在本教程中重点介绍的第一个深度学习功能是图像识别，使用在大型数据集上训练的分类网络来识别场景和对象。 镜像操作
docker pull dustynv/jetson-inference:r32.6.1 传输文件到docker容器，这个你网不好的情况下也不会在容器内添加代理的话可以使用的到。
首先需要知道docker容器的container_id,可以使用docker ps命令来查看你要操作的docker容器的container_id
Docker容器向宿主机传送文件 docker cp container_id:&lt;docker容器内的路径&gt; &lt;本地保存文件的路径&gt; 宿主机向Docker容器传送文件
docker cp 本地文件的路径 container_id:&lt;docker容器内的路径&gt; git clone --recursive https://github.com/dusty-nv/jetson-inference cd jetson-inference docker/run.sh 首先，让我们尝试使用imagenet程序在一些示例图像上测试imagenet识别。它加载一个或多个图像，使用TensorRT和imageNet类进行推理，然后覆盖分类结果并保存输出图像。该项目附带示例图像供您使用，位于图像/目录下。
构建项目后，确保您的终端位于aarch64/bin目录中：
$ cd jetson-inference/build/aarch64/bin # C++ $ ./imagenet images/orange_0.jpg images/test/output_0.jpg # (default network is googlenet) # Python $ ./imagenet.py images/orange_0.jpg images/test/output_0.jpg # (default network is googlenet) # C++ $ ./imagenet images/strawberry_0.jpg images/test/output_1.jpg # Python $ ./imagenet.py images/strawberry_0.jpg images/test/output_1.jpg 除了加载单个图像外，还可以加载目录或图像序列或视频文件。有关详细信息，请参阅“相机流和多媒体”页或启动带有该标志的应用程序。--help
下载其他分类模型 默认情况下，该项目将在构建步骤中下载 GoogleNet 和 ResNet-18 网络。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b70c13bbc014c67ddcd904564e52bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2388a531ce9414a69acad529ea7e062/" rel="bookmark">
			Kali虚拟机安装phpstudy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		命令：
wget -O install.sh https://notdocker.xp.cn/install.sh &amp;&amp; sudo bash install.sh 安装完成后输出访问的域名/用户名/密码
浏览器访问上图的内网地址，输入用户名和密码登录
（注意这个IP可能会在虚拟机重启后改变，可以使用 ifconfig查看最新IP）
安装并启用MySQL:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55239700ef0a790bed35deca33015d1a/" rel="bookmark">
			数据结构——树与二叉树の选择题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树的概念 1、一个有124个叶子节点的完全二叉树，最多有（）个结点
A、247
B、248
C、249
D、250
解析：选B
假设n2为由2个孩子的结点数量，n1为由1个孩子的结点数量，n0为由0个孩子的结点数量。
在完全二叉树中n0=n2+1，因为n0=124，因此n2=123。
在完全二叉树中，n1为1或0，要使有最多结点，此时n1=1。故最多一共有124+123+1=248个结点
2、在一棵完全二叉树中，其根的序号为1，（）可判定序号为p和q的两个结点是否在同一层。
A、⌊ log2p ⌋ = ⌊ log2q ⌋
B、log2p = log2q
C、⌊ log2p ⌋ + 1 = ⌊ log2q ⌋
D、⌊ log2p ⌋ = ⌊ log2q ⌋ + 1
解析：A
由完全二叉树的性质，序号为i（i &gt;=1）的结点，在第⌊ log2i ⌋ + 1层，因此序号为p的结点在⌊ log2p ⌋ + 1层，序号为q的结点在⌊ log2q ⌋ + 1。若两者在同一层，则⌊ log2p ⌋ + 1 = ⌊ log2q ⌋ + 1。因此⌊ log2p ⌋ = ⌊ log2q ⌋ 可以进行判断。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55239700ef0a790bed35deca33015d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171b0a91a79e729517fbd50fee3e3149/" rel="bookmark">
			windows10搭建DVWA靶场（新手向）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 下载并安装phpstudy 下载地址：https://www.xp.cn/download.html
二、 下载DVWA环境源码 官方v1.0版下载链接：https://codeload.github.com/ethicalhack3r/DVWA/zip/master
官方v1.9版下载地址：https://codeload.github.com/ethicalhack3r/DVWA/zip/v1.9
将压缩包解压至D:\phpstudy_pro\WWW目录下：
三、 用phpstudy创建网站 四、 配置DVWA 访问网址发现报错
1.进入D:\phpstudy_pro\WWW\DVWA-master\config目录下找到config.inc.php.dist文件去掉 .disc。
打开config.inc.php文件修改如下信息
再次访问
2.此时，我们看到PHP function allow_url_include显示的是Disabled，找到安装目录D:\phpstudy_pro\Extensions\php\php7.3.4nts中的php.ini配置文件
以记事本方式打开编辑 allow_url_include=On，并重启mysql，再次刷新DVWA页面。
3.出现 reCAPTCHA:Missing 字样，需要在 DVWA里的configure.inc.php中配置两个量
进入D:\phpstudy_pro\WWW\DVWA-master\config目录修改config.inc.php文件的如下信息：
$_DVWA[‘recaptcha_public_key’ ] = ‘6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg’;
$_DVWA[‘recaptcha_private_key’]=‘6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ’;
刷新页面：
4.创建数据库
出现如下界面表示创建成功
进入登陆界面,使用默认账号登录，密码：password
进入如下界面表示靶场搭建成功：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8640e9514e933188be812d92f2fd038/" rel="bookmark">
			win10 删除文件夹需要管理员权限无法删除的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10 删除文件夹需要管理员权限无法删除的方法 当我们删除某个文件夹时，经常会遇到以下情况需要管理员权限
方法：
1、打开cmd，
2、点击以管理员身份运行
3、跳到要删除文件夹的父目录
4、执行命令 rmdir /s/q 文件夹名
即可删除
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/250/">«</a>
	<span class="pagination__item pagination__item--current">251/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/252/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>