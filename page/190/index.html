<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf36cbde17182e12b4c7a39a8559dbdb/" rel="bookmark">
			C&#43;&#43;内存分配方法new与placement new使用方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tags: C++ 写在前面 总结一下C++内存分配中的new/delete方法, 以及一个很有意思的工具: placement new.
参考:
cppprimer5ed, pp409, pp726(19.1).侯捷C++ video new的基本使用 编译器角度 在使用new分配内存的时候, 例如下面这样:
string *sp = new string("abc"); // 分配并初始化一个string对象 string *sa = new string[10]; // 分配10个默认初始化的string对象 上面的new内存分配, 本质上进行了三个步骤:
new表达式调用一个名为operator new(或operator new[])的标准库函数, 这个函数分配了一块足够大的/原始的/未命名的内存空间, 以便存储特定类型的对象(或对象构成的数组);编译器运行相应的构造函数以构造这些对象, 传入初始值;对象被分配空间, 并且构造完成, 返回指向该对象的指针. 对于delete, 同理:(两个步骤)
delete sp; // 销毁*sp, 释放sp所指向的内存空间 delete[] sa; // 销毁数组中的元素, 然后释放对应的内存空间 步骤:
对sp所指向的对象或者arr所指的数组中的元素执行相应的析构函数;编译器调用operator delete(或operator delete[])释放内存. operator new/operator delete调用规则 当重载了全局的operator new和operator delete之后, 内存分配就不是系统默认的了, 所以这两个函数一定要保证正确.
分配内存/析构内存时, 编译器首先在被分配内存类(及其基类)的作用域中查找, 是否有定义operator new和operator delete成员函数. 若未找到, 则在全局作用域内查找, 最后, 会调用标准库定义的版本.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf36cbde17182e12b4c7a39a8559dbdb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caa5691b577613c29bc4f81123e1b9be/" rel="bookmark">
			C&#43;&#43; set用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++ set用法 一、set介绍 vector封装数组，list封装了链表，map和set封装了二叉树
set 翻译为集合，是一个内部自动有序且不含重复元素的容器。
当出现需要去掉重复元素的情况，而且有可能因这些元素比较大或者类型不是 int 型而不能直接开散列表，在这种情况下就可以用 set 来保留元素本身而不考虑它的个数。
当然，上面说的情况也可以通过再开一个数组进行下标和元素的对应来解决，但是set提供了更为直观的接口，并且加入set之后可以实现自动排序。
二、set定义 set&lt;typename&gt; name; //这里的typename可以是任何基本类型，例如 int、double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。
定义 set 数组： set&lt;typename&gt; Arrayname[arraySize]; 这样 Arrayname[0] ~ Arrayname[arraySize -1] 中每一个都是一个 set 容器。
三、set 容器内元素的访问 set 只能通过迭代器访问：set&lt;typename&gt;::iterator it；
eg:
#include&lt;stdio.h&gt; #include&lt;set&gt; using namespace std; int main() { set&lt;int&gt; st; for (int i = 1; i &lt;= 5; i++) { st.insert(i); } for (set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) { printf("%d "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caa5691b577613c29bc4f81123e1b9be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98432fad241333b7617a6885d6604194/" rel="bookmark">
			python将折线平滑为曲线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 曲线的曲率介绍平滑方法介绍1. 环境及模块介绍：2. 代码示例3. 整体代码 曲线的曲率介绍 曲线的曲率（curvature）：就是针对曲线上某个点的切线方向角对弧长的转动率，通过微分来定义，表明曲线偏离直线的程度。数学上表明曲线在某一点的弯曲程度的数值。
曲率越大，表示曲线的弯曲程度越大。曲率的倒数就是曲率半径。
曲线的两端的端点是没有曲率可谈的，和滑动平均类似，曲率的求解方式和滑动平均有类似之处，曲率达到一定范围，才认为其有拐点 平滑方法介绍 1. 环境及模块介绍： 环境 编译器：python 3.x 需要使用的模块： numpymatplotlibscipy 环境安装
# 在终端中输入 pip install numpy -i https://pypi.tsinghua.edu.cn/simple pip install matplotlib -i https://pypi.tsinghua.edu.cn/simple pip install scipy -i https://pypi.tsinghua.edu.cn/simple 2. 代码示例 随机生成10个坐标点 import numpy as np import matplotlib.pyplot as plt from scipy.interpolate import make_interp_spline import matplotlib matplotlib.use('TkAgg') x = np.linspace(0, 20, 10) y = np.random.uniform(-10, 10, 10) 先画出散点图看看 plt.figure(figsize=(10, 5), dpi=100) # plt.plot(x, y) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98432fad241333b7617a6885d6604194/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1010a1913dda3ec076277d7f5e3f34b6/" rel="bookmark">
			vue组件af-table-column表格文字内容太长，自动变省略号，鼠标悬浮上去显示全称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 vue组件af-table-column内容太长，如下：
&lt;af-table-column prop="prod" label="产品" width="100"&gt;&lt;/af-table-column&gt; 获取鼠标事件提示产品名称：使用show-overflow-tooltip属性，如下：
&lt;af-table-column prop="prod" label="产品" width="100" show-overflow-tooltip&gt;&lt;/af-table-column&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263d23f54d9ce2e68b71ea488d734b3e/" rel="bookmark">
			l2fwd收发队列的分析。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以l2fwd程序举例（igb为例）
1 收队列
1.1 收队列的建立
1，rte_eth_rx_queue_setup调用eth_igb_rx_queue_setup来创建队列，会根据需求创建同样数量的sw_ring 核rx_ring,如下图所示，dev-&gt;data-&gt;rx_queues[queue_idx]=rxq.
1.2 入队列
l2fwd使用rte_eth_tx_burst结构发送包，通过函数指针tx_pkt_burst，调用eth_igb_xmit_pkts发包，eth_igb_xmit_pkts的流程如下图
1.2.1 rte_pktmbuf_free_seg
rte_pktmbuf_free_seg用于把内存还给队列，会调用rte_mbuf_raw_free，rte_mbuf_raw_free调用rte_mempool_put，
rte_mempool_put调用rte_mempool_put_bulk，rte_mempool_put_bulk调用rte_mempool_generic_put，rte_mempool_generic_put调用__mempool_generic_put，
rte_mempool_generic_put的流程如下图
1.2.2 rte_mempool_ops_enqueue_bulk
rte_mempool_ops_enqueue_bulk通过函数指针enqueue从队列中出队列，enqueue对应多种方法，根据mp-&gt;ops_index来确定，本文主要分析common_ring_sc_dequeue，
common_ring_sc_dequeue调用rte_ring_sc_dequeue_bulk，rte_ring_sc_dequeue_bulk调用__rte_ring_do_dequeue。
1.3 出队列
l2fwd使用rte_eth_rx_burst接口收包，通过函数指针rx_pkt_burst，调用eth_igb_recv_pkts进行收包，eth_igb_recv_pkts的流程如图
1.3.1 rte_mbuf_raw_alloc
rte_mbuf_raw_alloc接口用于分配mbuf，主要是调用rte_mempool_get接口，rte_mempool_get接口再调用rte_mempool_get_bulk，rte_mempool_get_bulk再调用__mempool_generic_get接口
1.3.2 rte_mempool_ops_dequeue_bulk
rte_mempool_ops_dequeue_bulk通过函数指针dequeue从队列中出队列，dequeue对应多种方法，根据mp-&gt;ops_index来确定，本文主要分析common_ring_mc_dequeue
common_ring_mc_dequeue调用rte_ring_mc_dequeue_bulk，rte_ring_mc_dequeue_bulk调用__rte_ring_do_dequeue，队列的结构如下图
1.3.2.1 ring队列的创建
ring队列的创建是通过mempool_ops_alloc_once创建的，mempool_ops_alloc_once调用rte_mempool_ops_alloc，rte_mempool_ops_alloc根据ops_index，查找对应alloc接口，本文主要讲ring队列调用的是common_ring_alloc接口
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09ff271807d309e9ef4d70e79189f3af/" rel="bookmark">
			【C&#43;&#43;】多线程同步
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程间的同步方法大体可以分为两类：用户模式和内核模式。内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。
用户模式下的方法有：原子操作（例如一个单一的全局变量）、临界区。特点是：同步速度特别快。内核模式下的方法有：事件、信号量、互斥量。同步速度较慢，但适用性比较好。 **临界区：**通过对多线程的串行化来访问公共资源或一段代码、速度快，适合控制数据访问。
**互斥量：**为协调共同对一个共享资源的单独访问而设计的。
**信号量：**为控制一个具有有限数量用户资源而设计的。
**事件：**用来通知线程有一些时间已发生，从而启动后继任务的开始。
1 atomic atomic&lt;int&gt; num{0}; int main(int, char **) { std::cout &lt;&lt; "========boot=======" &lt;&lt; endl; //检查是否无锁的 std::cout &lt;&lt; "num.is_lock_free():" &lt;&lt; num.is_lock_free() &lt;&lt; endl; num.store(10); //存储值 std::cout &lt;&lt; "num:" &lt;&lt; num.load() &lt;&lt; endl; //读取值 int a = num.exchange(100); //交换值,返回原来的值 std::cout &lt;&lt; "num:" &lt;&lt; num.load() &lt;&lt; endl; std::cout &lt;&lt; "========over=======" &lt;&lt; endl; } atomic并不能保证类型T是无锁的，另外不同平台的处理器处理方式不同，也不能保证必定无锁，所以该类型都会有is_lock_free() 函数来判断是否无锁。
有一个比较特殊的原子类型是atomic_flag，因为atomic_flag与其他原子类型不同，它是无锁的，即线程对其访问不需要加锁，而其他的原子类型不一定是无锁的。
atomic_flag flag = ATOMIC_FLAG_INIT; //初始化 int main(int, char **) { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09ff271807d309e9ef4d70e79189f3af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/656a699e3da5869cd4db058a139db4ab/" rel="bookmark">
			算法设计与分析——多段图的最短路径问题（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题】设图 G = (V，E) 是一个带权有向图，如果把顶点集合 V 划分成 k 个互不相交的子集(2 ≤ k ≤ n，1 ≤ i ≤ k)，使得 E 中的任何一条边 &lt;u，v&gt;，必有 u V，v ( 1 ≤ i &lt; k，1 &lt; i+m ≤ k)，则称图 G 为多段图，称 s 为源点，t 为终点。多段图的最短路径问题 (multi-segment graph shortest path problem) 求从源点到终点的最小代价路径。
【想法】由于多段图将顶点划分为 k 个互不相交的子集，所以，可以将多段图划分为 k 段，每一段包含顶点的一个子集，根据多段图的定义,，每个子集中的顶点互不邻接。不失一般性，将多段图的顶点按照段的顺序进行编号，同一段内顶点的顺序无关紧要。假设图中的顶点个数为 n，则源点 s 的编号为 0，终点t的编号为 n-1，并且对图中的任何一条边&lt;u，v&gt;，顶点 u 的编号小于顶点 v 的编号。下图（一个多段图）所示是一个含有10个顶点的多段图。
首先证明多段图的最短路径问题满足最优性原理。设 是从 s 到 t 的一条最短路径，从源点 s 开始，设从 s 到下一段的顶点 已经求出，则问题转化为求从 s 到 t 的最短路径，显然 一定构成一条从 到 t 的最短路径，如若不然，设 是一条从 到 t 的最短路径，则 将是一条从 s 到 t 的路径且比 的路径长度要短，从而导致矛盾。所以，多段图的最短路径问题满足最优性原理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/656a699e3da5869cd4db058a139db4ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e607879f084e19e4dc0b4442dcc37e6a/" rel="bookmark">
			【问题收纳】! [remote rejected] master -＞ master (pre-receive hook declined)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 问题描述 问题描述 在使用Git Push的时候出现了下面的错误提示log：
! [remote rejected] master -&gt; master (pre-receive hook declined) error: failed to push some refs to 'your repo address' 这个是说明我们队Master分支没有权限，需要我们自己创建一个单个分支。
创建单个分支的方法如下所示：
git branch 你的分支名字 首先我们运用 git branch 后面紧接着我们想要的分支名字， 这个命令创建我们的branch 分支
创建之后我们需要切换到这个分支，这个时候我们需要checkout 这个命令
git checkout you-create-branchname 这里的 you-create-branchname代表的就是我们刚刚创建的那个分支的名字
这个时候我们就可以在这个分支上进行一些我们想要的操作，e.g.,
git add . git commit -m "cmt info' git push --set-upstream origin you-create-branchname 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b654a038ed9b992ea2c33f9f330f25e2/" rel="bookmark">
			RabbitMQ--扩展--2.1--性能测试--window.md
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RabbitMQ–扩展–2.1–性能测试–window.md 1、rabbitmq-perf-test工具 是一个测试吞吐量的性能测试工具基于Java开发的客户端有额外的工具可以输出成HTML图形能够对RabbitMQ单节点和集群进行性能测试。可以模拟下面2种负载 基本负载高级负载 1.1、下载地址 https://github.com/rabbitmq/rabbitmq-perf-test/releases 2、安装 2.2、直接解压 2.2、将标红的文件贝到bin目录下 结果
3、使用说明 3.1、切换到bin目录下 3.2、查看帮助 runjava com.rabbitmq.perf.PerfTest --help 内容
D:\rabbitmq-perf-test-2.18.0\bin&gt;runjava com.rabbitmq.perf.PerfTest --help usage: &lt;program&gt; -?,--help show usage -a,--autoack auto ack(客户端在处理完messages之后会给服务端返回一个ack确认信息，服务端在收到该ack信息之后才会把messages删除) -A,--multi-ack-every &lt;arg&gt; (每多少条消息返回一次ack信息给服务器端,消费者可以一次确认多条消息，例如，下面是100条消息确认一次 runjava com.rabbitmq.perf.PerfTest -x 1 -y 2 -u "test-6" --id "test-6" -f persistent --multi-ack-every 100) -ad,--auto-delete &lt;arg&gt; should the queue be auto-deleted, default is true -b,--heartbeat &lt;arg&gt; heartbeat interval -B,--body &lt;arg&gt; (使用逗号分隔的文件列表，用在消息的内容中(这里是多个由逗号分隔开的文件名，把文件中的内容作为消息体写入到指定queue中)) -bc,--body-count &lt;arg&gt; number of pre-generated message bodies. Use with --json-body.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b654a038ed9b992ea2c33f9f330f25e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/878d021672b7551923af595bb4a6ca4b/" rel="bookmark">
			MySQL中给字符串字段加索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、前缀索引和普通索引二、前缀索引对覆盖索引的影响三、优化前缀索引 前言 学完了MySQL索引部分，我们清楚的认识到给子段添加索引可以快速的进行查询，节约时间。但是索引有很多。那么对于字段怎么加索引，加什么索引。加到索引不同，效率肯定也会有不同的。接下来，我们研究下，怎么给字符串字段加索引
一、前缀索引和普通索引 我们依旧是通过一个例子进行讲解。
我们用邮箱登录这个业务。创建了一个用户表，SQL句如下：
create table SUser( ID bigint unsigned primary key, email varchar(64), ... )engine=InnoDB; 要是有邮箱登录，业务代码中一定会出现如下这样的SQL语句：
select f1,f2 from SUser where email='xxx'; 对于这查询语句，相比加上索引效率效率更高。
但是加上什么索引呢？
如果只是普通的加上索引，那么相应的索引对应的B+树中存储的就这email索引列的全部内容。想必都知道，一个邮箱账号包含的字符串是很长。如果把这一个很长的字符串充当索引，那是很浪费存储空间的。为此，我们可以使用前面提到过前缀索引，即把email的一部分字符串设置为索引。接下来，我们分析学习下两者的效率。
针对email字段创建如下两个不同的索引，进行分析：
alter table SUser add index index1(email); 或者 alter table SUser add index index2(email(6)); 第一个语句创建的index1索引里面，包含了每个记录的整个字符串；而第二个语句创建的index2
索引里面，对于每个记录都是只取前6个字节。
针对这两个的存储，存储结构图，如下所示：
对index1:
对index2：
从图中的存储可以看出，email(6)这个存储占用的空间更小。这是使用前缀索引的优势，但是查询效率上呢，接下来我们分析一下。
执行下面的SQL语句，看看不同的索引执行流程有何不同：
select id,name,email from SUser where email='zhangssa@xxx.com'; 如果使用的是index1（即email整个字符串的索引结构），执行顺序是这样的：
从index1索引树找到满足索引值的这条记录，取得ID2的值；到主键上查到主键值是ID2的行，判断email的值是正确的，将这行记录加入结果集；取index1索引树上刚刚查到的位置的下一条记录，发现已经不满足条件了,循环结束。 这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。
如果使用的是index2 （即email(6)索引结构），执行顺序是这样的：
从index2索引树找到满足索引值是’zhangs’的记录，找到的第一个是ID1；到主键上查到主键值是ID1的行，判断出email的值不是这行记录丢弃；取index2上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出ID2，再到ID索引上取整行然后判断，这次值对了，将这行记录加入结果集；重复上一步，直到在idxe2上取到的值不是’zhangs’时，循环结束。 通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。
通过看使用前缀索引结构，进行检索。如果设置的前缀个数较少，那各个字段的区分度不大，就会有很多重合的索引，就需要多次回表进行检查。区分度越高越好。因为区分度越高，意味着重复的键值越少。但是要存储的字符串就会越多，所以要平衡下，找到最好的前缀索引。
二、前缀索引对覆盖索引的影响 我们将上面的SQL查询语句，变成下面的：
select id,email from SUser where email='zhansss%@xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/878d021672b7551923af595bb4a6ca4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b289662b7063540a1bdb2489f161c85/" rel="bookmark">
			matlab曲线拟合工具箱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		matlab曲线拟合工具箱 文章内容部分参考自【数模国赛救急】13分钟学会matlab曲线拟合工具箱哔哩哔哩bilibili
题目 题目摘自司守奎老师的《数学建模算法与应用（第2版）》
首先我们对数据做一个散点图，来观察一下初步的形状，得到一条曲线
plot(X,Y,'o'); X=[1790 1800 1810 1820 1830 1840 1850 1860 1870 1880 1890 1900 1910 1920 1930 1940 1950 1960 1970 1980 1990 2000] Y=[3.9 5.3 7.2 9.6 12.9 17.1 23.2 31.4 38.6 50.2 62.9 76 92 106.5 123.2 131.7 150.7 179. 204 226.5 251.4 281.4] 分析 用拟合工具箱进行对xm和r的参数拟合
可以在APP中找到curve fitting tool或者直接在命令行中输入cftool，都是可以打开的
拟合工具箱的左侧是让我们选择数据的窗口，可以看到有X/Y/Z三个数据选项
意思是说，我们的拟合工具箱最多可以用来处理一个变量或者两个变量的拟合问题
如果是多维的拟合，我们可以用粒子群算法
在数模比赛中，我们最常用的拟合算法有两种：Custom Equation和Polymial(多项式拟合)
Custom Equation Custom Equation是用户自定义函数拟合，比如这道题，题目要求我们用指定的函数拟合
就可以选择这种方法,x是关于t的函数，然后对应函数的形式把函数输入到框中xm/(1+(xm/3.9-1)exp(-r(t-1790)))
此时我们已经得到了一条拟合曲线，但是效果非常的差
导致这种现象发生的原因是：在拟合的时候matlab会自动为我们选择xm和r的初值
但如果初值的选取不合理，就会造成这种现象，方法是我们在选项中对初值进行调试
现在就得到了一条正常的曲线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b289662b7063540a1bdb2489f161c85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8d04467733224bf53f2bb0e79023a85/" rel="bookmark">
			朴素贝叶斯分类算法和实例演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 贝叶斯公式算法原理实例演示代码实现 本文开始，我们来学习一种新的机器学习方法：贝叶斯算法。
这次从最基础的朴素贝叶斯分类算法出发，了解相关的算法原理。
考虑如下一种分类问题：样本中只包含2类特征，标签只有0和1。
目前要评估两个特征值分别为a和b时的分类结果。
使用朴素贝叶斯分类算法的核心逻辑是：基于概率论的相关理论直接计算两个特征值分别为a和b时，标签值为0和1的概率，然后选择更大的概率值对应的标签值作为分类结果。
贝叶斯公式 既然是基于概率论，那就得先清楚算法使用所必要的概率论原理。
说来尴尬，虽然我本科概率论的课程成绩还看得过去，但是实际上大部分内容都已经忘记了，所以还是从尽量基础的条件概率公式开始
P ( B ∣ A ) = P ( A B ) / P ( A ) P(B|A)=P(AB)/P(A) P(B∣A)=P(AB)/P(A)
此处， P ( B ∣ A ) P(B|A) P(B∣A)指的是B在A发生的条件下发生的概率（后验概率）， P ( A B ) P(AB) P(AB)指的是A和B同时发生的概率，P(A)指的是A发生的概率（先验概率）。
先找个简单实例重温一下条件概率公式：假设有5个完全相同的箱子，只有一个箱子内有钱，定义A为第1箱子内无钱，B为第2个箱子有钱。用最朴素的直观逻辑，可以得知
P ( A ) = 4 / 5 , P ( A B ) = 1 / 5 , P ( B ∣ A ) = 1 / 4 P(A)=4/5,P(AB)=1/5,P(B|A)=1/4 P(A)=4/5,P(AB)=1/5,P(B∣A)=1/4
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8d04467733224bf53f2bb0e79023a85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ecbcf5070dd331a179da266b49a025/" rel="bookmark">
			idea设置方法注释模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法注释模板设置
1、创建一个模板组，在settings——&gt;editor——&gt;live templates——&gt;template group
名称为：my
2、添加注释目标
模板内容如下：
* * * @Param $param$ * @Return $return$ * @Author panwenlong * @Date $date$ $time$ **/ 3、配置变量：
当param的值为methodParameterTypes()是，参数会在一行显示。
当值为下面时，参数会分行显示
groovyScript("def result=''; def params=\"${_1}\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').split(',').toList(); for(i = 0; i &lt; params.size(); i++){if(i==0){result = params[i] + ' '}else{result+='\\n '+'* @Param: ' + params[i] + ' ' + ((i &lt; params.size() - 1) ? '' : '')}}; return result", methodParameters()) return参数
groovyScript("def result=''; def params=\"${_1}\".replaceAll('[\\\\[|\\\\]|\\\\s]', '').
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ecbcf5070dd331a179da266b49a025/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/520183c0df4a5dd765a2c763839b2cdf/" rel="bookmark">
			【OPENCV_系列电子PDF图书连载】计算机视觉从入门到精通完整学习路线专栏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OPENCV_PDF图书连载之— 图像的几何变换 一、图像几何变换 1.3_a:图像坐标仿射 仿射自定义代码展示： warpAffine.pointsAffine【自定义包】
from img_pakage.ocv import warpAffine img_path = f'../img/three_angle.png' warpAffine.pointsAffine(img_path,0,0,24,217,220,160,0,0,24,217,220,160) print(warpAffine.pointsAffine.__doc__) if __name__ =='__main__': pass 库warpAffine.pointsAffine__doc__:输出帮助截图：
三点坐标变换仿射 上图，下图对应三个顶点坐标，通过运算，生成图像的变换的仿射。
● src：源图像中三角形顶点的坐标，也就是在源图像中任找不在同一直线上的三个点，将三个点的坐标作为三个元素放到src对应列表中
● dst：目标图像中相应三角形顶点的坐标，也就是三个点在变换后图像中的坐标列表，要求与源图像三个点一一对应
● 返回值：从三对对应的点计算出来的仿射变换矩阵
例2_三角形解析 按照 P-B-C顺序，建立三个顶点，对应的在右图也建立P-B-C三个顶点，我们此时可以把左右两图坐标设置为完全相同的顶点坐标。
按照图片显示，我们尝试向上移动P点：
调节P点坐标向上，原P点坐标为[0,0], 调节后的点坐标为[0, -8]向上平移8点像素，同理P的辅助线值也向上平移了8个像素。
认真观察左图和右图，我们得到了一些规律，三点仿射选点规则，按下图中1，2，3顺序分别在源图和目标图中选择了对应点这里是P,B,C,作参照点：
左图：P(76,58)[0,0] — B(24,217)[24,217] — C(164, 217)[220,160]
右图：P(76,58)[0,0] — B(24,217)[24,217] — C(164, 217)[220,160]
三顶点变换仿射命令下，我们会得到完全相同的图片，接下来我们如果想让P点向右移动10个像素点，即P的x坐标向右移动，我们只需要把P点的横坐标增加+10(76,58)[+10,0],
三点仿射的选点顺序 下图中的1,2,3顺序号是图片定点的位置顺序：
B,C坐标值不变情况下，我们就完美得到了点P移动后效果：
左图：P(76,58)[0,0] 右图：P(76,58)[10,0] ，
如果我们想进一步调节右图的点位置，只需要对应的改变每个点的X,Y坐标值就可以了。
1.4、图像平移 使用平移矩阵M,通过设置点坐标的形式进行图像的平行移动，效果如下：
矩阵原型：M = np.float32([[1,0,xtr],[0,1,ytr]])
分析原型：
我们看到的[1,0,xtr]—是对x轴方向的平移控制
看到的[0,1,ytr]—是对y轴方向的平移控制
例1：平移自定义代码展示 from img_pakage.ocv import warpAffine img_path = f'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/520183c0df4a5dd765a2c763839b2cdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3bfcb7a5f929107bba3ae7a96f4651f/" rel="bookmark">
			在外网和内网部署nextcloud&#43;onlyoffice实现在线编辑功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在外网和内网部署nextcloud+onlyoffice实现在线编辑功能 在线部署 1在线安装docker 2通过docker安装并运行nextcloud+onlyoffice/documentserver镜像 3访问nextcloud和onlyoffice/documentserver 4在nextcloud中的应用-&gt;Files中搜索onlyoffice下载 5在管理设置-&gt;OnlyOffice中填写上OnlyOffice服务器的地址 内网部署 1离线安装docker 2通过docker命令导出nextcloud和onlyoffice镜像和mysql镜像 3官网下载onlyoffice应用离线版后导入到nextcloud容器中 4配置mysql数据库 5运行docker容器并挂载数据卷 6安装 7成功启动 常见错误： 1无法正常启动 2通过不被信任的域名访问 3连接是发生异常 (文档服务内部发生异常: Invalid token) 因为需要搭建一个能够实现在线多人同时编辑功能的工具，所以在网上查询资料，发现大多数人都在使用nextcloud+onlyoffice这一套组件，nextcloud作为一个私有网盘，可以上传下载文件，同时搭载了onlyoffice插件，可以实现多人在线文档编辑。
因为nextcloud和onlyoffice的使用需要多个软件的协同，比如一个onlyoffice就需要同时下载安装RabbitMQ，Erlang等软件，且版本兼容问题也很难解决，在网上又看到大多数人选择采用Docker进行镜像安装，因为Docker将每个应用的Libs函数库，Deps依赖，配置和应用一起打包，放到一个隔离容器中运行，避免互相干扰，以及系统函数库，从而解决了依赖兼容问题和操作系统版本环境差异的问题，所以最后决定通过Docker运行nextcloud+onlyoffice。
操作步骤：在CentOS7虚拟机上先进行测试，测试通过后再部署到对应的服务器上，一台是腾讯云服务器，一台是公司内网服务器，192.168.200.132为虚拟机IP
在线部署 1在线安装docker 1.1安装yum工具
1.2更新本地镜像源
1.3输入命令,安装docker-ce(docker-ce为社区免费版本)
1.4启动docker
​ 1.4.1关闭防火墙
1.4.2通过命令启动docker
​ 1.4.3然后输入命令，可以查看docker版本：
如图：
参考文章
nextcloud手动插件NextCloud 离线安装扩展插件 OnlyOffice 插件实现协同办公编辑软件...weixin_39538500的博客-CSDN博客
nextcloud手动插件_NextCloud 离线安装扩展插件 OnlyOffice 插件实现协同办公编辑软件..._weixin_39538500的博客-CSDN博客
docker：如何将本地文件复制到docker容器内普通网友的博客-CSDN博客docker怎么把文件拷贝到容器里面
docker：如何将本地文件复制到docker容器内_普通网友的博客-CSDN博客_docker传文件到容器
2通过docker安装并运行nextcloud+onlyoffice/documentserver镜像 docker运行镜像，会首先从www.hub.docker.com上拉取镜像，拉取到镜像后，再按照指定方式运行
2.1运行nextcloud镜像
2.2运行onlyoffice/documentserver镜像
3访问nextcloud和onlyoffice/documentserver 3.1在浏览器输入http://192.168.200.132:5757访问nextcloud
192.168.200.132为虚拟机IP
3.2在浏览器输入http://192.168.200.132:443http://192.168.200.132:443访问onlyoffice/documentserver 4在nextcloud中的应用-&gt;Files中搜索onlyoffice下载应用 5在管理设置-&gt;OnlyOffice中填写上OnlyOffice服务器的地址 内网部署 1离线安装docker 1.1选择系统的型号，下载对应的离线安装包
Index of linux/static/stable/x86_64/
因为离线无法安装yum，所以直接下载docker对应版本的离线安装包
1.2上传文件到服务器
1.3安装开始
1.3.1解压缩
1.3.2将解压得到的文件复制到/usr/bin目录下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3bfcb7a5f929107bba3ae7a96f4651f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4300017e619a0c6bd54ffb6351db80/" rel="bookmark">
			编程输出所有的“水仙花数”。所谓水仙花数，是指一个3位数，其各个数位上的数字立方和等于该数本身。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 编程输出所有的“水仙花数”。所谓水仙花数，是指一个3位数，其各个数位上的数字立方和等于该数本身。例如：153=13+53+33 运行结果示例：
水仙花数有 153 370 371 407
说明：
（1）提示性文字输出格式：“水仙花数有”
（2）结果输出格式："%5d"
#include&lt;stdio.h&gt; int main() { int i, j, k, n; printf("水仙花数有"); for (n = 100; n &lt; 1000; n++) { i = n / 100; j = (n - i * 100) / 10; k = n % 10; if (n == i * i * i + j * j * j + k * k * k) printf("%5d", n); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8e8e085476d9b10e50fb6adae93cf6/" rel="bookmark">
			mycat schema.xml配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt; &lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt; &lt;!-- name：为mycat逻辑库的名字，对应server&lt;property name="schemas"&gt;mydatabase&lt;/property&gt;， 建议设置跟数据库一样的名称 checkSQLschema：自动检查逻辑库名称并拼接，true会在sql语句中的表名前拼接逻辑库名， 例如select * from mydatabase.t_user; sqlMaxLimit：查询保护、如果没有写limit条件，会自动拼接。只查询100条。 --&gt; &lt;schema name="mydatabase" checkSQLschema="true" sqlMaxLimit="100"&gt; &lt;!-- name:为物理数据库的表名，命名与物理数据库的一致 dataNode:为dataNode标签(&lt;dataNode name="dn1" dataHost="dtHost1" database="db1" /&gt;)里面的name值 dataNode里面填写的节点数量必须和rule里面的规则数量一致 例如rule里面只定义了两个0-1M=0 1M-2M=1那么此处只可以指定两个节点,1M=10000，M为单位万 primaryKey:为表的ID字段，建议和rule.xml里面指定的ID和物理库的ID一致 rule：分片规则，对应rule.xml中&lt;tableRule name="student_id"&gt;的name type：表格类型，默认非global，用于全局表定义 --&gt; &lt;table name="t_user" dataNode="dn1,dn2,dn3" primaryKey="id" rule="auto-sharding-long"&gt; &lt;!--ER分片注意childTable 标签需要放到table标签内，是主外键关联关系， name:为物理数据库的表名，命名与物理数据库的一致 primaryKey:为表t_loginlog的ID字段，建议和rule.xml里面指定的ID和物理库的ID一致. joinKey：从表t_loginlog的外键字段，需要和物理库的字段名称一致 parentKey：为主表t_user的字段名，依据此字段做关联，进行ER分片 --&gt;	&lt;childTable name="t_loginlog" primaryKey="id" joinKey="user_id" parentKey="id"&gt;&lt;/childTable&gt; &lt;/table&gt; &lt;table name="t_student" dataNode="dn1,dn3" primaryKey="id" rule="student_id" /&gt; &lt;table name="t_dictionaries" dataNode="dn1,dn2,dn3" type="global" /&gt; &lt;table name="t_teacher" dataNode="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d8e8e085476d9b10e50fb6adae93cf6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d5122bad7e7c6fc7fa515c0f9519f4/" rel="bookmark">
			BP神经网络工具箱使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BP神经网络工具箱使用 文章内容部分参考自基于matlab实现BP算法的神经网络 - 阿璃阿狸 - 博客园 (cnblogs.com)
【数模国赛救急】11分钟学会matlab神经网络工具箱哔哩哔哩bilibili
一、概念 神经网络的本质就是进行数据的拟合，工作状态分为学习和工作两种状态，即训练和仿真两个步骤。
在训练阶段，给出输入数据与正确的输出数据，神经网络根据输入数据进行复杂的运算得出实际的输出数据，实际的输出数据与正确的输出数据之间的差别就叫做误差。
而BP算法就是会反向传播误差一层一层不断修正各层神经元之间的连接权值，正所谓信号的正向传播和误差的反向传播，直到误差在规定的范围内或运行次数达到规定的学习次数，
此时结束算法，否则选取下一个学习样本及对应的期望输出，返回进入下一轮学习。
仿真阶段，在经过训练阶段的大量样本数据训练之后，神经网络已经较为准确，输入数据，运行得出输出数据，此即为预测过程。
BP网络的训练就是通过应用误差反传原理不断调整网络权值，使网络模型输出值与已知的训练样本输出值之间的误差平方和达到最小或小于某一期望值的过程。
二、基本运用 1.拟合——&gt;进行数据的预测
2.分类（包含评价）——&gt;聚类分析
注意：运用神经网络的场景一定要样本数量很多的，不然训练会不准确，以下代码只是为了展示效果。
三、MATLAB BP神经网络工具箱使用步骤 第一步：数据导入 X代表输入数据，Y代表输出结果
第二步：使用神经网络工具箱构建模型 打开神经网络工具箱：nftool
然后按照下面截图一步一步操作：
绿色圆圈的那个点是MSE最小的点，记录下对应的w(权重)和b(阈值)用来预测
最后一个函数显示神经网络示意图：
第三步：进行预测 保存结果后，结果区出现了net,output,error(残差)
现在我们可以根据函数sim进行预测
我们把要预测的几组数据拿进来
代码：
&gt;&gt;Predict_Y=zeros(10,1); ​ fori=1:10 ​ Predict_Y(i,1)=sim(net,Predict_X(i,:)');%这里需要转置 ​ end 成功预测
&gt;&gt;disp(Predict_Y) ​ 87.7623 ​ 87.6196 ​ 88.3190 ​ 85.3254 ​ 85.3956 ​ 84.5900 ​ 87.5035 ​ 87.2341 ​ 88.6420 ​ 87.3312 四、参数解读 1.、泛化性： 表示BP神经网络在训练过程中，如果均方误差（MSE）连续6次不降反升，则网络停止训练
2、误差精度： 关于mu参数含义的一种理解是，mu是误差精度参数，用于给神经网络的权重再加一个调制，这样可以避免在BP网络训练的过程中陷入局部最小值，mu的范围为0到1
3、实现BP网络预测的步骤 读取数据 设置训练数据和预测数据 训练样本数据归一化 构建BP神经网络 网络参数配置(训练次数，学习速率，训练目标最小误差.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7d5122bad7e7c6fc7fa515c0f9519f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e18a8346145a38794075fccb2fa0b2e9/" rel="bookmark">
			CityGML标准文档（4）（简介——历史背景）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0.2 历史背景 （译者注：本文中所涉及的LOD相关概念，如LOD2、LOD3请自行百度，译为 层次细节 或 多细节层次）
CityGML自2002年以来由特殊利益集团3D（SIG 3D）成员开发。自2010年以来，该小组已成为德国空间数据基础设施（GDI-DE）倡议*（注：initiative 是否在这里翻译为“倡议”，我不清楚）的一部分。2010年之前，SIG 3D隶属于北莱茵-威斯特法伦州地理数据基础设施（GDI NRW）倡议（注：initiative 是否在这里翻译为“倡议”，我不清楚）*。SIG 3D是一个开放小组，由来自德国、英国、瑞士和奥地利的70多家公司、市政当局和研究机构组成，致力于开发和商业利用可互操作的3D城市模型和地理可视化。SIG 3D工作的另一个成果是提出了Web 3D服务（W3DS），这是一种三维描述服务，也正在开放地理空间联盟（ (OGC Doc. No. 05-019 and OGC Doc. No. 09-104r1)）中讨论。
2005年，GDI NRW的“三维试点”项目首次成功实施，并且在项目实施过程中，对CityGML标准里的部分内容进行评估。与会者来自德国各地，一起论证了在城市规划场景和旅游上的应用。2006年初，EuroSDR（欧洲空间数据研究）开展的CityGML项目开始聚焦于欧洲三维城市建模的协调应用。2006年6月至12月，人们开始通过开放GIS 网络服务测试-4（OWS-4），对CityGML在CAD/GIS/BIM线程中的使用进行评估并应用。自2008年起，CityGML（版本1.0.0）成为OGC标准。
从那时起，CityGML便在全球传播推广。德国和欧洲其他国家（柏林、科隆、德累斯顿和慕尼黑，仅举几个例子）的许多城市都在CityGML中提供了他们自己的三维城市模型。在法国，项目Bâti3D（IGN France）定义了CityGML LOD2的概况，并提供了巴黎和普罗旺斯艾克斯、里尔、南特和马赛市中心的数据。CityGML在三维试点项目中也发挥了重要作用，被荷兰作为三维地理信息标准和三维基础设施。欧洲的许多城市，如摩纳哥、日内瓦、苏黎世和利沃登，开始使用CityGML LOD 2或LOD 3完成三维模型的数据描述和数据交换，而丹麦的城市除使用LOD 2和LOD 3以外，部分模型采用了LOD 4 层次进行表示。CityGML强烈影响了欧盟委员会INSPIRE倡议的建筑模型（2.0版），该倡议旨在创建一个以互操作方式，以为公共部门提供欧洲空间数据基础设施数据。在亚洲，伊斯坦布尔（LOD1和LOD2）、多哈、卡塔尔（LOD3）和横滨（LOD2）的三维城市模型开始使用CityGML标准进行表示和开展数据交换。此外，CityGML在马来西亚的3D空间数据基础设施建设中发挥着至关重要的作用。
今天 （注：2012年左右） ，许多商业和学术工具通过定义好的接口，提供导入、导出的功能，实现了对CityGML文件的支持。比如三维城市数据库，它是一个免费的开源三维地理数据库，柏林理工大学在Oracle 10g R2和11g R1/R2上，实现了对虚拟3D城市模型的存储、表示（表达）和管理。他们实现了对CityGML的完全支持，并附带了一个用于CityGML模型导入和导出的工具。此外，柏林理工大学还提供了一个用于处理CityGML模型（citygml4j）的开源Java类库和API。Safe Software股份有限公司的转换工具FME（要素操纵引擎）可作为ESRI ArcGIS互操作性扩展的一部分，也具有CityGML的读写接口。（注：关于FME工具以及如何在ArcGIS中集成FME扩展，可自行百度） CityGML也同样适用于Bentley Systems的Bentley Map等CAD工具，以及CPA Geo Information的SupportGIS等GIS工具。许多3D查看器（都是免费提供的）为CityGML提供了可视化界面：来自波恩大学的Aristoteles Viewer，Autodesk股份有限公司的LandXplorer CityGML Viewer（用于创作和管理的工作室版本不是免费的）和KIT Karlsruhe的FZKViewer for IFC和CityGML以及Bitmanagement Software GmbH的BS Contact，后者为地理空间扩展BS Contact-Geo提供CityGMI插件。软件工具的列举并非详尽无遗，而且还在稳步增长。请访问CityGML官网：http://www.citygml.org/ 以及CityGML维基百科 http://www.citygmlwiki.org/ 获取更多内容。
（注：IFC格式的模型，也是当前BIM领域以及BIM+GIS领域的一个核心研究点，可自行百度IFC概念及基础知识，并参考相关IFC标准进行学习）
IFC标准参考文档：
IFC4: http://www.bim-times.com/ifc/ifc4/index.htm
IFC 2X3: http://www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e18a8346145a38794075fccb2fa0b2e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7680017492c2d7e21e298f631631be29/" rel="bookmark">
			TypeScript类型 ： any，unknown，void，never，tuple
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.any类
2.unknown类型
any和unknown区别：
3.void类型
4.never类型
5.tuple类型
1.any类 在某些情况下，我们确实无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用any类型（类似 于Dart语言中的dynamic类型）。
any类型有点像一种讨巧的TypeScript手段：
1.我们可以对any类型的变量进行任何的操作，包括获取不存在的属性、方法；
2.我们给一个any类型的变量赋值任何的值，比如数字、字符串的值；
如果对于某些情况的处理过于繁琐不希望添加规定的类型注解，或者在引入一些第三方库时，缺失了类型注解，这个时候 我们可以使用any：
包括在Vue源码中，也会使用到any来进行某些类型的适配；
2.unknown类型 unknown是TypeScript中比较特殊的一种类型，它用于描述类型不确定的变量。
感觉可以使用unknown类型的地方也可以使用any类型，但是还是有区别的 any和unknown区别： 1.unknown类型只能赋值给any和unknown类型，any类型太灵活，不安全
2.any类型可以赋值给任意类型
3.void类型 void通常用来指定一个函数是没有返回值的，那么它的返回值就是void类型：
我们可以将null和undefined赋值给void类型，也就是函数可以返回null或者undefined
function sum(num:number,num2:number){ console.log(num + num2) } 这个函数我们没有写任何类型，那么它默认返回值的类型就是void的，我们也可以显示的来指定返回值是void：
function sum(num:number,num1:number): void { console.log(num + num1) } 4.never类型 never 表示永远不会发生值的类型，比如一个函数：
如果一个函数中是一个死循环或者抛出一个异常，那么这个函数会返回东西吗？
不会，那么写void类型或者其他类型作为返回值类型都不合适，我们就可以使用never类型；
function loopFun(){ while(true){ console.log('loopFun') } } function loopErr(){ throw new Error() } function handleMessage(message: string | number){ swith( typeof message){ case 'string': console.log('str') break case 'number': console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7680017492c2d7e21e298f631631be29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3c8e96fd1a5cb3d4f0a8e5345f03aa8/" rel="bookmark">
			基于51单片机PM2.5空气质量检测系统（源程序&#43;仿真&#43;原理图&#43;PCB&#43;论文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料编号：208
功能介绍：（全套毕设资料齐全）
本电路是由51单片机为控制核心，另外主要通过5个模块的电路设计实现功能，他们分别是LCD显示模块、粉尘传感器、A/D转换、蜂鸣器电路、LED指示电路。
设计的主要内容 本设计提出的检测空气质量PM2.5的方案最基本的实现方法是由单片机、粉尘监测传感器、显示模块、报警模块等组成的电路， GP2Y1010AU0F粉尘传感器采集空气中PM2.5的浓度值，经过STC89C51单片机处理后，在LCD1602液晶上显示，并通过LED和蜂鸣器提示浓度状态。
设计的主要意义 21世纪的今天，科学技术的发展日新月异，科学技术的进步同时也带动了测量技术的发展，现代控制设备不同于以前，它们在性能和结构发生了翻天覆地的变化。我们已经进入了高速发展的信息时代，测量技术是当今社会的主流，广泛地深入到应用工程的各个领域。
因为空气质量的恶化，阴霾天气现象出现增多，危害现象加重。中国不少地区把阴霾天气现象并入雾一起作为灾害性天气预警预报。统称为“雾霾天气”。雾霾主要由PM2.5、PM10、PM0.1以及重金属镍砷铬铅等颗粒组成。在空气动力学和环境气象学中，颗粒物是按直径大小来分类的，粒径小于100微米的称为TSP(TotalSuspendedParticle)，即总悬浮物颗粒；粒径小于10微米的称为PM10(PM为ParticulateMatter缩写)，即可吸入颗粒物；粒径小于2.5微米的称为PM2.5，即可入肺颗粒物，它的直径仅相当于人的头发丝粗细的1/20。虽然PM2.5只是地球大气成分中含量很少的组分，但它与较粗的大气颗粒物相比，粒径小，富含大量的有毒、有害物质且在大气中的停留时间长、输送距离远，因而对人体健康和大气环境质量影响更大。
世界卫生组织发布的报告显示，无论是发达国家还是发展中国家，目前大多数城市和农村人口均遭受到颗粒物对健康的影响。高污染城市中的死亡率超出相对清洁城市的15%至20%。据统计，在欧洲，PM2.5每年导致386000人死亡，并使欧盟国家人均期望寿命减少8.6个月。人体的生理结构决定了对PM2.5没有任何过滤、阻拦能力，而PM2.5对人类健康的危害却随着医学技术的进步，逐步暴露出其恐怖的一面。气象专家和医学专家认为，由细颗粒物造成的灰霾天气对人体健康的危害甚至要比沙尘暴更大。粒径10微米以上的颗粒物，会被挡在人的鼻子外面；粒径在2.5微米至10微米之间的颗粒物，能够进入上呼吸道，但部分可通过痰液等排出体外，另外也会被鼻腔内部的绒毛阻挡，对人体健康危害相对较小；而粒径在2.5微米以下的细颗粒物，直径相当于人类头发的1/10大小，不易被阻挡。被吸入人体后会直接进入支气管，刺激呼吸道，干扰肺部的气体交换，从而引发咳嗽、呼吸困难、哮喘、慢性支气管炎等呼吸系统的疾病并导致心律不齐、非致命性心脏病等心血管方面的疾病。其中，老人、小孩以及心肺疾病患者是PM2.5污染的敏感人群。
因此，对PM2.5的监测与治理便显得越来越重要。
程序部分展示（有中文注释，新手容易看懂）
#include &lt;intrins.h&gt;
#define uint unsigned int
#define uchar unsigned char //宏定义
sbit RS=P1^6;//液晶接口
sbit EN=P1^7;
sbit LED = P2^0;//粉尘传感器控制接口
sbit ADCS = P3^7;//AD0832接口
sbit ADCLK =P3^5;
sbit ADDI = P3^6;
sbit ADDO = P3^6; sbit SET= P1^1;//按键接口
sbit ADD= P1^2;
sbit DEC= P1^3;
sbit BEEP=P2^1;//蜂鸣器接口
uchar set_st;
uchar tab[5];
uint DUST_SET=150; //固体颗粒的阈值
//bit shanshuo_st; //闪烁间隔标志
bit beep_st; //蜂鸣器间隔标志
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3c8e96fd1a5cb3d4f0a8e5345f03aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/962bb3514a5dfbb1e7edcc53eb6679df/" rel="bookmark">
			基于51单片机的篮球赛计时计分器（仿真&#43;源程序&#43;原理图&#43;PCB&#43;论文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料编号：207
功能介绍（全套毕设资料齐全）
采用51单片机一种篮球赛计时计分器的设计方法，即单片机带外围扩展来驱动数码管工作的电路。电路采用单片机作为核心元件，利用两个供阴的三位一体数码管来显示两队的分数，一个四位一体数码管显示时间的计时。显示分数范围可达0～999分，足够赛程计分的需要。四位一体数码管中2个用于显示分钟，2个用于显示秒钟。
该系统具有赛程定时设置，赛程时间暂停，及时刷新甲、乙双方的成绩等功能。设计分为软件设计和硬件设计两部分。主控芯片采用AT89C51，使用C语言编写软件程序，主体分为计时显示模块、计分显示模块、定时报警、按键控制模块。编程后利用Keil C51软件来进行编译，再将生成的HEX文件装入芯片中，检验功能是否能够正常实现。
一、设计要求：
1、能记录整个赛程的比赛时间，并能修改时间，暂停比赛时间。
2、能随时刷新甲、乙两队在整个赛程中的比分。
3、场中交换比赛场地时，能交换甲、乙两队比分的位置。
4、比赛时间结束时，能发出报警指令。
5、有24秒倒计时功能，可通过按键随时复位24秒，如果24秒违例会启动蜂鸣器报警，同时比赛时间暂停，处理好后按一下24秒复位键，比赛继续。
二、实现功能：
1、一个四位一体数码管显示比赛时间，时间格式如：15：00，两个三位一体数码管显示甲乙两对的比分，比分格式如：008。
2、比赛时间采用倒计时方式，以一秒的频率减时，上电时默认初值为15：00，在没有开始比赛时，可以修改时间，比赛开始后不能修改。
3、甲乙队比分采用三位数，上电初值为000，最大值为999，满足常理要求，未开始比赛以及比赛结束后比分无法加减，
4、比赛未开始之前，可以通过ADD1、DEC1键对比较时间的分钟进调时，通过ADD2、DEC2键对比较时间的秒进行调时。
5、可随时暂停/启动比赛时间。
6、比赛进行时，可以通过ADD1、DEC1键对甲队比分加、减，可以通过ADD2、DEC2对乙队比分加、减。每按一次键，加/减1分。
7、当一节比赛完后，可以通过（EXCHANGE）换场键换场，换场后，比分交换显示，交换后，下一节比赛开始时，相应的比分加减键也随之交换。
8、当比赛结束时，发出报警。
三、作用说明：
1、调整比赛时间：插上电源后，系列默认比赛时间为15：00，甲乙队比分默认000，此时按下ADD1键，可以对比赛时间分钟加1，按下DEC1键，可以对比赛时间的分钟减1，按下ADD2键，可以对比赛时间秒加1，按下DEC2键，可以对比赛时间秒减1。
2、启动比赛：按下RUN/STOP键，计时开始，比赛时间以1秒的频率倒计时。
3、暂停比赛：比赛运行的状态下，按RUN/STOP键，比赛暂停，计时暂停。
4、比分加减，在比赛进行的状态下按ADD1，DEC1键，可以对甲队比分加、减1，按ADD2、DEC2键，可以对乙队比分加、减1.
5、交换场地：在一节比赛时间结束后，按下EXCHANGE键，比赛时间重新预置为15：00，同时左右两边数码管的比分交换显示。此时按下启动键可以开始新一节的比赛。
6、报警提示：在一节比赛时间倒计时到00：00时，蜂鸣器发出报警提示。
7、比赛时，24秒会以1秒的速度减，可随时按下24秒复位键重置24秒。
程序中文注释，新手容易看懂，下面是程序部分展示：
sbit add1=P1^0;//甲对加分，每按一次加1分 /在未开始比赛时为加时间分
sbit dec1=P1^1;//甲对减分，每按一次减1分/在未开始比赛时为减时间分
sbit exchange=P1^2;//交换场地
sbit add2=P1^3;//乙对加分，每按一次加1分/在未开始比赛时为加时间秒
sbit dec2=P1^4;//乙对减分，每按一次减1分/在未开始比赛时为减时间秒
sbit p24_sec=P1^5;
sbit secondpoint=P0^7;//秒闪动点
//----依次点亮数码管的位------
sbit led1=P2^7;
sbit led2=P2^6;
sbit led3=P2^5;
sbit led4=P2^4;
sbit led5=P2^3;
sbit led6=P2^2;
sbit led7=P2^1;
sbit led8=P2^0;
sbit led9=P3^7;
sbit led10=P3^6;
sbit led11=P3^5;
sbit led12=P3^4;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/962bb3514a5dfbb1e7edcc53eb6679df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89b7b3fd010788b6f6c77c29c01ad512/" rel="bookmark">
			基于51单片机的直流电机调速测速正反转控制（仿真&#43;源程序&#43;原理图&#43;PCB）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		资料编号：206
1.本设计采用STC89C51/52（与AT89S51/52、AT89C51/52通用，可任选）51单片机作为主控制器
2.采用霍尔传感器非接触式测电机转速
3.LCD1602液晶显示当前的转速，转速单位为转/分（RPM）。和显示当前的pwm占空比0~100%。
4.电机的速度可以通过按键调整，也可以开始暂停，正转和反转。
注意：磁铁和霍尔元件最近距离在2mm左右，太近可能会在电机转动时碰到霍尔元件，太远霍尔元件可能会检测不到磁铁。
使用说明：
液晶屏第一行显示电机转速，第二行显示占空比，占空比数值越大，电机转速越快。
系统一共有6个按键，单片机附近的独立按键是系统的复位按键，按下单片机会复位。
下面一排是控制按键：
1键：加速键，可以短按，占空比加1，也可长按，占空比连续加；
2键：减速键，可以短按，占空比减1，也可长按，占空比连续减；
3键：反转切换键，按下后电机反转；
4键：正转切换键，按下后电机正转；
5键：开始暂停键，按一下开始，再按一下暂停。
下面是仿真图：
下面是原理图：
下面是PCB：
下面是程序文件，有中文注释，新手容易看懂
void keyscan() //键盘扫描函数
{ if(num1==0) {
delay(5); //消除抖动
if(num1==0)
{
if(m&lt;=199)
m++;
displaym(); //设定占空比加一
}
}
if(num2==0)
{
delay(5);
if(num2==0)
{
if(m&gt;=1)
m--;
displaym();//设定占空比减一
}
}
if(num3==0)
{
delay(5);
if(num3==0)
{
zheng=1; //初始化电机正转动
fan=0;
}
}
if(num4==0)
{
delay(5);
if(num4==0)
{
zheng=0; //初始化电机正转动
fan=1;
}
}
if(num5==0)
{
delay(5);
if(num5==0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89b7b3fd010788b6f6c77c29c01ad512/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5467425886f6017142d8555acf44f3d/" rel="bookmark">
			Linux——gcc/g&#43;&#43;以及make/Makefile的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在Linux的系统中，想要完成代码编译，gcc/g++是不可缺少的工具，而make/Makefile能否熟练应用则从一个侧面体现出一个人是否有能力独自完成一个大型工程，而本篇文章就带领大家了解一些gcc/g++和make/Makefile使用的基础知识。 一、编辑器gcc/g++使用 1.1 背景知识 GCC是以GPL许可证所发行的自由软件，也是GNU计划的关键部分。GCC的初衷是为GNU操作系统专门编写一款编译器，现已被大多数类Unix操作系统（如 Linux、 BSD、MacOS X等）采纳为标准的编译器，甚至在微软的Windows上也可以使用GCC。GCC支持多种 计算机体系结构芯片，如 x86、 ARM、MIPS等，并已被移植到其他多种硬件平台[1] PS：gcc适用于C语言编译，g++适用于c++和c，两者的语法完全相同， 1.2 gcc的完成过程 格式：[gcc [选项] 要编译的文件 [选项] [目标文件]] 1.2.1 预处理阶段（进行宏替换） 作用：包括 处理宏定义，文件包含展开，条件编译，去注释等等 命令： -E ，意思是编译到预处理阶段停止，预处理阶段的文件我们一般以 .i为后缀命名 格式：[gcc -E [要编译的文件] -o [编译后的名字] ] 如图所示，左边是经过预处理后的源代码，我们发现宏定义都已经带入，而左边代码八百多行，是引用的stdio.h文件已经展开，而注释以及去除，条件编译也只留下了符合条件的。 1.2.2 编译阶段（生成汇编） 作用：在这个阶段中,gcc 首先要检查代码的规范性、是否有语法错误等,以确定代码的实际要做的工作,在检查无误后,gcc 把代码翻译成 汇编语言。 命令：-S，文件编译到编译阶段停止，编译阶段的文件我们一般以 .s为后缀 格式：[gcc -S [要编译的文件] -o [编译后的名字]] 如图左边就是编译阶段的文件，如图所示已经转为汇编语言。 1.2.3 汇编阶段（生成机器可以识别的代码） 作用：汇编阶段是把编译阶段生成的“.s”文件转成目标文件 命令：-c，将文件编译到汇编阶段停止，一般以.o为后缀 格式：[gcc -c [要编译的文件] -o [编译后文件的名字]] 如图所示，左边就是经过汇编变为机器可以读取的二进制代码 1.2.4 链接阶段（生成可执行文件和库文件） 作用：在成功编译后进入链接阶段，将程序和函数库链接起来，形成可执行文件和库文件 命令：直接gcc即可，一般不许要后缀 格式：[gcc [要编译的文件] -o [编译后的名字]] 如图，亮绿光的那个文件就是链接后的可执行文件，执行后即可实现代码。 1.3 函数库 在链接阶段，我们涉及到了一个关键概念——函数库。 我们的C程序中，并没有定义“printf”的函数实现,且在预编译中包含的“stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5467425886f6017142d8555acf44f3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51f30feeec582f33d36572f328bf6e7/" rel="bookmark">
			OpenFeign 基本介绍和原理了解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		了解 OpenFeign OpenFeign 组件的前身是 Netflix Feign 项目。后来 Feign 项目被贡献给了开源组织，才有了今天使用的 Spring Cloud OpenFeign 组件。
OpenFeign 提供了一种声明式的远程调用接口，它可以大幅简化远程调用的编程体验。用一个代码片段看一下，由 OpenFeign 发起的远程服务调用的代码风格是什么样的。
String response = helloWorldService.hello("Spring Cloud"); 可以发现，使用 OpenFeign 组件来实现远程调用非常简单，就像使用本地方法一样，只要一行代码就能实现 WebClient 组件好几行代码干的事情。而且这段代码不包含任何业务无关的信息，完美实现了调用逻辑和业务逻辑之间的职责分离。
OpenFeign 组件背后的工作流程 OpenFeign 使用了一种动态代理技术来封装远程服务调用的过程，在上面的例子中看到的 helloWorldService 其实是一个特殊的接口，它是由 OpenFeign 组件中的 FeignClient 注解所声明的接口。
import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.*; @FeignClient(value = "hello-world-service") public interface HelloWorldService { @PostMapping("/sayHello") String hello(String guestName); } 远程服务调用的信息被写在了 FeignClient 接口中。在上面的代码里，可以看到，服务的名称、接口类型、访问路径已经通过注解做了声明。OpenFeign 通过解析这些注解标签生成一个动态代理类，这个代理类会将接口调用转化为一个远程服务调用的 Request，并发送给目标服务。
OpenFeign 的动态代理 在项目初始化阶段，OpenFeign 会生成一个代理类，对所有通过FeignClient 接口发起的远程调用进行动态代理。如图：
上图中的步骤中，在项目启动阶段加载完成的是 1 ~ 3步 ，只有第 4 步（调用远程服务）是发生在项目的运行阶段。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c51f30feeec582f33d36572f328bf6e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6cf25892d544ad8767e1b4dd5f85459/" rel="bookmark">
			Arduino UNO驱动 AT24C256 EEPROM存储器模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Arduino UNO驱动 AT24C256 EEPROM存储器模块 AT24C256模块简介模块引脚定义Arduino UNO与模块接线测试代码实验结果 AT24C256模块简介 AT24C256是一个串行EEPROM存储器，提供了256k bit=256*1024 bit=262144 bit=32768 Byte=32K Byte大小的存储空间，在芯片内部被分配为512页，每页64-Byte，写入数据时可按单字节写入或按整页写入，读取数据时可按当前地址读取一个字节或顺序读取多个字节或随机读取一个字节。数据保持最大可达40年而不丢失，擦写次数可达100万次。IIC通信接口，7位器件地址为1010A2A1A0，通信速率可达1MHz。带硬件读写保护引脚。
由于Arduino UNO自带了很小的EEPROM 1KB，若要存储大量的数据的话是不够的，若外接一个EEPROM可增大其存储空间。
模块引脚定义 SCL：IIC接口时钟信号线；SDA：IIC接口数据信号线；VCC：1.7-5.5V电源正极；GND：电源负极
由原理图可知器件地址为0x50
Arduino UNO与模块接线 Arduino UNODS1307A4SDAA5SCLVCCVCCGNDGND 测试代码 在Arduino IDE库管理器搜索AT24C256，并安装如图示所例程库
打开read_write.ino例程
#include &lt;AT24C256.h&gt; AT24C256 eeprom(0x50); void setup() { char message[30]; char writemessage[] = "https://www.yourcee.com"; Serial.begin(9600); Serial.println("reading eeprom"); eeprom.read(0, (uint8_t*) message, sizeof(message)); Serial.println(message); eeprom.write(0, (uint8_t*)writemessage, sizeof(message)); Serial.println("wrote eeprom"); Serial.println("reading eeprom"); eeprom.read(0, (uint8_t*) message, sizeof(message)); Serial.println(message); } void loop() { // put your main code here, to run repeatedly: } 实验结果 通过串口助手显示出写入和读取存储器的数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fdee6713c126c86af202cc04b28d695/" rel="bookmark">
			（03）JS/VUE获取一个月有多少天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一：
new Date()第3个参数默认为1，就是每个月的1号，把它设置为0时， new Date()会返回上一个月的最后一天，然后通过getDate()方法得到天数
function getMonthDay(year,month) { let days = new Date(year, month + 1, 0).getDate(); console.log(days); return days; } getMonthDay(2023,1) //28 方法二：
可以把每月的天数写在数组中，再判断时闰年还是平年确定2月分的天数
function getDays(year, month) { let days = [31,28,31,30,31,30,31,31,30,31,30,31] if ( (year % 4 ===0) &amp;&amp; (year % 100 !==0 || year % 400 ===0) ) { days[1] = 29 } console.log(days[month]); return days[month] } getDays(2023,0) // 31 方法三：
function getMonthDays (myMonth){ let monthStartDate = new Date(new Date().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fdee6713c126c86af202cc04b28d695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/918be43817847fbfe5c3b48894716723/" rel="bookmark">
			Windows10如何删除流氓文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、删除文件提示在另一程序中打开 进入安全模式删除：
开始—设置—更新和安全—恢复—立即重新启动—疑难解答—高级选项—启动设置—重启—键盘摁4。
进入安全模式后将文件删除即可，重启直接退出安全模式。
若进入安全模式后删除文件提示需要管理员权限则转二。
二、删除文件提示需要管理员权限 在开始旁边的搜索栏搜索gpedit.msc，一般情况下第一次使用都搜索不到。则需配置过程如下：
1、新建一个txt文件。
2、将以下内容复制到文件中。
@echo off pushd "%~dp0" dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum &gt;List.txt dir /b C:\Windows\servicing\Packages\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum &gt;&gt;List.txt for /f %%i in ('findstr /i . List.txt 2^&gt;nul') do dism /online /norestart /add-package:"C:\Windows\servicing\Packages\%%i" pause 3、将文件的拓展名由txt格式改成cmd格式。
4、选中文件右击，以管理员的身份运行，接下来会弹出一个cmd运行框，等待系统自动将组件加载完成即可按任意键退出cmd运行框。
配置好后就可以直接搜索gpedit.msc找到本地组策略编辑器窗口了。
在改窗口中依次点击“计算机配置”、“Windows配置”、“安全设置”、“本地策略”、“安全选项”。
将“用户账户控制：以管理员批准模式运行所有管理员“和“用户账户控制：用于内置管理员账户的管理员批准模式”设置为已禁用，“帐户：管理员账户状态“设置为已启用。
重启计算机后即可删除文件。
若文件仍删不掉则进入安全模式删，若还删不到就继续以下步骤：
1、打开要删除的文件，每层都删除一次，留下的都是要Administrator权限才能删除的文件。
2、来到最里层（不是文件夹即为最里层），右击某个剩下的文件选中属性→安全→编辑→点击User（没有user就点击everyone）→选中完全控制→点击应用和确定。
3、把所有剩下的文件按第二步做一遍，最后全部删除即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c7dde096ce05b4228a5dbce1985e41c/" rel="bookmark">
			seata配置使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		spring-cloud微服务项目Seata的配置 1、下载seata 下载地址: https://github.com/seata/seata/releases/v0.9.0/
2、配置seata 我们下载下来之后，会是一个压缩包。我们把这个压缩包打开之后进行相关配置。
2.1 修改registry.conf，指定seata使用nacos注册中心 D:\seata-server-0.9.0\seata\conf\registry.conf
registry { type = "nacos" nacos { serverAddr = "localhost" namespace = "public" cluster = "default" } } config { type = "nacos" nacos { serverAddr = "localhost" namespace = "public" cluster = "default" } } 2.2 修改nacos-config.txt，指定我们的服务名称 D:\seata-server-0.9.0\seata\conf\nacos-config.txt 将如下配置
service.vgroup_mapping.my_test_tx_group=default
修改为：
service.vgroup_mapping.shop-orders=default
service.vgroup_mapping.shop-product=default
2.3 初始化seata在nacos中的配置
D:\seata-server-0.9.0\seata\bin
运行如下命令将seata初始化配置到nacos中
seata-server.sh 127.0.0.1
执行成功后可以打开Naco的控制台，在配置列表中，可以看到初始化了很多Group为SEATA_GROUP的配置。
2.4 启动seata服务 D:\seata-server-0.9.0\seata\bin
运行如下命令启动seata服务
seata-server.bat -p 9000 -m file
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c7dde096ce05b4228a5dbce1985e41c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd170462253d9de057e7039a7d408b3e/" rel="bookmark">
			【玩具代码】用C&#43;&#43;获取窗体进程对应的PID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		桌面上莫名其妙弹出来弹窗，光关掉可不行，还得知道是哪个进程搞的鬼。
用C++(Windows API)写一段小小的代码，获取鼠标所在位置窗口的句柄，进而得到对应的 PID，代码很简单，就不做解释了。
#include &lt;Windows.h&gt; #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std; POINT lastCursorPos; POINT CursorPos; HWND hWnd; char line[100] = "\0"; int len = 0; DWORD GetPIDFromCursor(POINT &amp;CursorPos) { //从鼠标位置获取当前窗体的句柄 hWnd = WindowFromPoint(CursorPos); if (NULL == hWnd) { // cout &lt;&lt; "\nNo window exists at the given point!" &lt;&lt; endl; return 0; } //获取窗体句柄的pid DWORD dwProcId; GetWindowThreadProcessId(hWnd, &amp;dwProcId); return dwProcId; } bool equal(const POINT &amp;p1, const POINT &amp;p2) { if (p1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd170462253d9de057e7039a7d408b3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14e4610e19fc44725adc53ae97c55d06/" rel="bookmark">
			【刘二大人】PyTorch深度学习实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、overview1 机器学习 二、Linear_Model（线性模型）1 例子引入 三、Gradient_Descent(梯度下降法)1 梯度下降2 梯度下降与随机梯度下降（SGD）对比3 Mini-Batch 四、Back Propagation（反向传播）1 线性模型叠加的神经网络2 反向传播3 在PyTorch中进行前馈和反馈的运算 五、PyTorch实现线性回归1、准备数据集2、设计模型3、构造损失函数和优化器4、训练过程5、代码实现 六、Logistics_Regression（逻辑回归）1 二分类和sigmoid函数2 逻辑回归3 代码实现 七、Multiple Dimension Input（多维特征的输入）1 多维逻辑回归模型2 线性层和人工神经网络3 例子：糖尿病是否恶化的预测3.1 数据集3.2 代码实现 八、Dataset（加载数据集） and Dataloader（Mini-batch）1 Dataloader2 定义Dataset3 代码实现 九、softmax classifier1 softmax层2 损失函数3 代码实现 十、CNN1 basic_CNN1.1 卷积神经网络1.2 卷积操作1.2.1 单通道输入卷积操作1.2.2 3通道输入卷积操作1.2.3 N通道输入 M通道输出卷积操作**1.2.4 卷积层 1.3 basic代码实现1.4 扩充（padding）1.5 步长（stride）1.6 池化（polling）1.7 如何把运算迁移至GPU1.7.1 代码实现 2 advanced_CNN ---- GoogLeNet2.1 GoogLeNet2.2 Inception Module2.2.1 1*1卷积2.2.2 拼接2.2.3 Inception Module代码 2.3 GoogLeNet代码实现 3 advanced_CNN ---- ResNet3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14e4610e19fc44725adc53ae97c55d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7916cb163f67f5da7855364d6d3282da/" rel="bookmark">
			Windows 批处理 DOS命令小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DOS命令 基础 echo
echo "hello world" 实例:
@echo off echo hello world pause @echo off关闭盘符echo 打印输出语句pause 不立刻关闭终端 算术运算* / % + -
set /a 1+2 实例:
@echo off set /a var = 1 + 2 echo %var% pause set /a算术运算
echo %var%输出var变量的值
重定向&gt; &gt;&gt; &lt; &lt;&lt;
我只知道&gt; &gt;&gt;是写入文件
实例:
@echo off echo hh &gt; a.txt pause echo hh &gt; a.txt把字符串hh写入a.txt文件(覆盖) &gt;&gt;表示追加
多命令运算&amp;&amp; ||
&amp;&amp;命令与运算 符号左边执行成功才会执行符号右边的
||命令或运算 符号左边执行成功不会执行符号右边的 左边未执行成功再执行符号右边的
管道符号|
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7916cb163f67f5da7855364d6d3282da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf91d4a83781ad585faee26299684384/" rel="bookmark">
			三种伺服电机控制方式总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		伺服电机速度控制和转矩控制都是用模拟量来控制，位置控制是通过发脉冲来控制。具体采用什么控制方式要根据客户的要求以及满足何种运动功能来选择。
接下来，给大家介绍伺服电机的三种控制方式：
如果您对电机的速度、位置都没有要求，只要输出一个恒转矩，当然是用转矩模式。
如果对位置和速度有一定的精度要求，而对实时转矩不是很关心，用速度或位置模式比较好。
如果上位控制器有比较好的闭环控制功能，用速度控制效果会好一点。如果本身要求不是很高，或者基本没有实时性的要求，用位置控制方式对上位控制器没有很高的要求。
就伺服驱动器的响应速度来看：转矩模式运算量最小，驱动器对控制信号的响应最快；位置模式运算量最大，驱动器对控制信号的响应最慢。
对运动中的动态性能有比较高的要求时，需要实时对电机进行调整。
如果控制器本身的运算速度很慢（比如PLC，或低端运动控制器），就用位置方式控制。
如果控制器运算速度比较快，可以用速度方式，把位置环从驱动器移到控制器上，减少驱动器的工作量，提高效率；
如果有更好的上位控制器，还可以用转矩方式控制，把速度环也从驱动器上移开，这一般只是高端专用控制器才能这么做。
一般说驱动器控制的好坏，有个比较直观的比较方式，叫响应带宽。
当转矩控制或速度控制时，通过脉冲发生器给它一个方波信号，使电机不断的正转、反转，不断的调高频率，示波器上显示的是个扫频信号，当包络线的顶点到达最高值的70.7%时，表示已经失步，此时频率的高低，就能说明控制的好坏了，一般电流环能做到1000HZ以上，而速度环只能做到几十赫兹。
01
转矩控制
转矩控制方式是通过外部模拟量的输入或直接的地址的赋值来设定电机轴对外的输出转矩的大小，具体表现为例如10V对应5Nm的话，当外部模拟量设定为5V时电机轴输出为2.5Nm：如果电机轴负载低于2.5Nm时电机正转，外部负载等于2.5Nm时电机不转，大于2.5Nm时电机反转（通常在有重力负载情况下产生）。可以通过即时的改变模拟量的设定来改变设定的力矩大小，也可通过通讯方式改变对应的地址的数值来实现。
应用主要在对材质的受力有严格要求的缠绕和放卷的装置中，例如饶线装置或拉光纤设备，转矩的设定要根据缠绕的半径的变化随时更改以确保材质的受力不会随着缠绕半径的变化而改变。
02
位置控制
位置控制模式一般是通过外部输入的脉冲的频率来确定转动速度的大小，通过脉冲的个数来确定转动的角度，也有些伺服可以通过通讯方式直接对速度和位移进行赋值。由于位置模式可以对速度和位置都有很严格的控制，所以一般应用于定位装置。应用领域如数控机床、印刷机械等。
03
速度模式
通过模拟量的输入或脉冲的频率都可以进行转动速度的控制，在有上位控制装置的外环PID控制时速度模式也可以进行定位，但必须把电机的位置信号或直接负载的位置信号给上位反馈以做运算用。位置模式也支持直接负载外环检测位置信号，此时的电机轴端的编码器只检测电机转速，位置信号就由直接的最终负载端的检测装置来提供了，这样的优点在于可以减少中间传动过程中的误差，增加了整个系统的定位精度。
04
伺服控制3环
伺服电机一般为三个环控制，所谓三环就是3个闭环负反馈PID调节系统。最内的PID环就是电流环，此环完全在伺服驱动器内部进行，通过霍尔装置检测驱动器给电机的各相的输出电流，负反馈给电流的设定进行PID调节，从而达到输出电流尽量接近等于设定电流，电流环就是控制电机转矩的，所以在转矩模式下驱动器的运算最小，动态响应最快。
第2环是速度环，通过检测的电机编码器的信号来进行负反馈PID调节，它的环内PID输出直接就是电流环的设定，所以速度环控制时就包含了速度环和电流环，换句话说任何模式都必须使用电流环，电流环是控制的根本，在速度和位置控制的同时系统实际也在进行电流（转矩）的控制以达到对速度和位置的相应控制。
第3环是位置环，它是最外环，可以在驱动器和电机编码器间构建也可以在外部控制器和电机编码器或最终负载间构建，要根据实际情况来定。由于位置控制环内部输出就是速度环的设定，位置控制模式下系统进行了所有3个环的运算，此时的系统运算量最大，动态响应速度也最慢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7acec43d4b273af7f568ae5a6dc9604/" rel="bookmark">
			【C语言】两种方法将字符串中的空格替换为%20
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法1 原始数组
要把空格替换为“%20”，其实是把一格变成了三格，即每有一个空格就要扩两格，所以字符串长度要变长。
做法是，统计整个数组中的空格个数count，然后new_length应该等于length+count*2 ,
即17
过程如图
两指针重叠以后就不用再换了，因为两指针最开始就相差4格，即2count，count为空格数，所以当两指针重叠就代表前面没有空格了。
void replaceSpace(char* str, int length) { char* p = str; int count = 0; while (*str != '\0')//统计空格个数 { if (*str == ' ') { count++; } str++; } char* p1 = str;//原始末尾 char* p2 = p + length + 2 * count;//扩展后末尾 while (p1 != p2) { if(*p1 != ' ') { *p2-- = *p1--; } else { *p2-- = '0'; *p2-- = '2'; *p2-- = '%'; p1--; } } } int main() { char str[17] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7acec43d4b273af7f568ae5a6dc9604/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4744950c4be01f64b35e0159ccf40070/" rel="bookmark">
			STM32的HAL库开发系列 - 串口DMA发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 STM32的HAL库开发系列 - 串口DMA发送
DMA串口发送函数：
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, 函数的参数如下：
huart 串口句柄pData发送的数据指针Size 数据长度（数据的字节数） 返回值：
HAL_status 共有四种状态 HAL_OK、HAL_ERROR、HAL_BUSY、HAL_TIMEOUT
在需要的地方调用HAL_UART_Transmit_DMA（······）即可完成数据发送。
例如：
uint8_t data_16[4]={0x11,0x22,0x33,0x44}; uint8_t data_character[]="hello"; HAL_UART_Transmit_DMA(&amp;huart1, data_16,4); HAL_Delay(1); HAL_UART_Transmit_DMA(&amp;huart1, data_character, sizeof(data_character)); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b24943d652c5e732d2f06a83c7d1d9a0/" rel="bookmark">
			BP神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章内容部分参考自：数学建模--BP神经网络算法及Matlab实现 - 知乎 (zhihu.com)
(9条消息) 数学建模——人口预测模型公有木兮木恋白的博客-CSDN博客数学建模人口预测模型
一、人工神经网络（ANN）概述 这个算法功能很强大用起来却又很冒险。它模拟的是人脑的神经元突触，以达到信息并行处理、自学习、推理能力（模拟人脑的反射运动）。神经网络是深度学习中的非常重要的算法，现在有非常多的种类（如前向反馈网络BP、径向基网络RBF等等），这里总结对ANN的一些理解。
以BP网络为例，该网络按数据传递的路线分有输入层、隐含层、输出层（隐含层可能不只有一层，也可以有很多层），其建模流程大致为：输入数据-确定网络规模、规定激励函数（三种形态：阀值型、线性型、S型）-确定调整权值的方式（BP网络的核心是梯度下降法）-训练网络。
ANN是一种拟合，这种拟合源于数学却又不限于数学，源于数学是因为它有背后的数学逻辑，如和多项式拟合一样，拟合的结果是否符合实际受到所用数据的真实性与数据量的影响，而且影响程度很大（数据越多，拟合效果越好，类比一些深度学习的例子），说它不限于数学是因为数学的拟合是严谨的、符合数据规律与数学规则的（简单的理解是拟合时的“多对一”，即拟合时多种数据输入、一种数据输出，最终求出的结果也是单一数据）而神经网络的拟合是可以做到“多对少”（输出可以不是一种数据）
二、BP模型简介 BP网络（Back-Propagation Network）是1986年被提出的，是一种按误差逆向传播算法训练的多层前馈网络，是目前应用最广泛的神经网络模型之一，用于函数逼近、模型识别分类、数据压缩和时间序列预测等。
三、学习过程 1、正向传播 输入信号从输入层经过各个隐含层向输出层传播，在输出层得到实际的响应值，若实际值与期望值误差较大，就会转入误差反向传播阶段。
2、反向传播 按照梯度下降的方法从输出层经过各个隐含层并逐层不断地调整各神经元的连接权值和阈值，反复迭代，直到网络输出的误差减少到可以接受的程度，或者进行到预先设定的学习次数。
BP神经网络通过有指导的学习方式进行训练和学习。标准的BP算法采用误差函数按梯度下降的方法学习，使网络的设计输出值和期望输出值之间的均方误差最小。BP神经网络的传输函数通常采用sigmoid函数，而输出层则采用线性传输函数。
四、matlab实现 （一）案例一 题目：创建BP神经网络
散点图如下：
代码：
P = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; T = [0, 1, 2, 3, 4, 3, 2, 1, 2, 3, 4]; %由于feedforwardnet函数自动对样本进行归一化和划分训练、验证、测试集, %所以就不用手动将数据进行归一化处理，但不知道有没有打乱顺序 % n=size(P,2); temp=randperm(n); P_train=P(temp(1:8)); % T_train=T(temp(1:8)); P_test=P(temp(9:end)); T_test=T(temp(9:end)); % % [p_train,p_input]=mapminmax(P_train,0,1); % [t_train,t_output]=mapminmax(T_train,0,1); % p_test=mapminmax(P_test,p_input); net = feedforwardnet(5, 'traingd'); %是'5'是指隐含层有5个神经元，这里只有一个隐含层，多个隐含层神经元的个数设置为[5,3,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b24943d652c5e732d2f06a83c7d1d9a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eb0f919998362df1c45003f4806cfcb/" rel="bookmark">
			jmeter参数化之 __CSVRead（）参数化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参数化步骤 1.确定接口参数中哪些请求参数需要进行参数化 在设计测试用例时，我们针对商品编号，商品规格，商品数量来准备数据，故对id，attr，number参数化
2.将测试数据放在外部一个文档保存，文件类型为csv或txt --&gt;*.csv or *.txt 新建一个testdata.csv，一行写一个用例，多个参数值默认用，分隔（注意不要写列标题）∶
__CSVRead（）函数，不能去首行，所以不要写列表题，那么没有标题，就要靠序号去分别，所以，列的编写规则是：从0开始，每次递增1，也就是说0表示第一列，1表示第二列
case1,9,226,3 case2,,226,1 case3,9,,1 case4,9,226, 3.调用__CSVRead（）函数获取外部数据文件中的数据 选项-函数助手对话框，打开"函数助手"，选择"__CSVRead"
4.在请求中将写死的数据用第3步中定义的变量进行替换 data_--&gt; ${varName}
比如 S{attr}
5.配置参数化 _CSVRead函数参数配置项
5.1 将线程数设置为用例的个数（如果采用多线程的方式，就不要进行换行，也可以读取得到每一行数据）
5.2 如果有多组数据，但是线程数只设置为一个，就要设置换行，因为__CSVRead（）函数不是jmeter内部的元素，所以循环控制器对其没有作用，如果想要循环读取到每一行而不是只读取第一行，那么这个时候就要换行，如果想要实现换行，那么就要在数据读取到最后一列之后在进行，换行的函数语句是：将生成的函数中的第二个参数（列号）改为next，然后在与读取到的最后一列的函数进行拼接
比如：haha.txt文件共有4列，那么最后一列的列号就是3，然后在读取到第四列的时候进行换行，所以最后在请求的时候的参数应该像如下这样填写：
别名的使用 1.定义别名： __CSVRead（）函数中第一参数为文件的路径，第二个参数为别名的名字，要以*开头
${__CSVRead(/Users/zhangshanshan/Desktop/haha.txt,*heihie)} 2.别名的使用 ${__CSVRead(/Users/zhangshanshan/Desktop/haha.txt,*heihie)} *heihie 就可以替代/Users/zhangshanshan/Desktop/haha.txt路径
在使用别名的时候要注意，我们要把定义别名的函数语句写在第一次使用别名之前，否则会报错
对参数文件路径进行参数化 模拟三个用户，每个用户查看两次
u1 -------&gt; haha1.csv 2组数据 u2 -------&gt; haha2.csv 2组数据 u3 -------&gt; haha3.csv 2组数据 /Users/zhangshanshan/Desktop/haha1.txt
线程组下线程的编号规则：按照线程启动的先后顺序进行编号，从1开始，每次递增
线程编号不能跨线程组
${__threadNum} :获取线程组下线程的编号
参数文件的路径：线程编号和文件名组合起来. haha${__threadNum}.csv ${__CSVRead( haha${__threadNum}.csv ,0)} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445dd826fea1fa32967b319d6bcf2f79/" rel="bookmark">
			网络方案设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3217e775111d832ebe54ac21354b4e11/" rel="bookmark">
			springboot&#43;rabbitmq搭建mqtt协议实现订阅发布（亲测9w消息并发）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、mqtt协议简单介绍 mqtt是一种基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet
of Thing）中的一个标准传输协议。
二、rabbitmq的安装部署 1. 安装Erlang环境 yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel yum -y install ncurses-devel 2. 下载Erlang rpm 安装包和rabbitmq rpm安装包 rpm包自取：https://pan.baidu.com/s/1UGuxeEIYMK9hBHKYBClfTQ
提取码：tmfm
RPM 下载包版本地址：https://packagecloud.io/rabbitmq/erlang
下载RabbitMQ rpm 安装包： https://github.com/rabbitmq/rabbitmq-server/releases/
*注意版本统一
安装erlang
rpm -Uvh erlang-23.2.7-1.el7.x86_64.rpm yum install -y erlang
erl -v 安装rabbitmq
yum install -y socat rpm -Uvh rabbitmq-server-3.9.15-1.el7.noarch.rpm yum install -y rabbitmq-server 启动rabbitmq
systemctl start rabbitmq-server 查看rabbitmq状态
systemctl status rabbitmq-server 3、添加用户 添加root用户取代guest用户
rabbitmqctl add_user root root rabbitmqctl set_user_tags root administrator rabbitmqctl set_permissions -p "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3217e775111d832ebe54ac21354b4e11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b5d3aba8e6d4fbdbd7a03a3b40d8077/" rel="bookmark">
			SVN使用 &amp;&amp; SVN服务器的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SVN是WIN和linux下都可以使用的软件版本控制工具。
（1）以实际在windows下使用的经历来说明使用法则。
1，从SVN服务器上下载code，就是下载一个最新的版本在工作目录机上使用，然后把自己的code改动加上去之后，加上标识上传至服务器，即成为最新的code。
2，如果自己改动的跟服务器上的同名文件改动有冲突，或者服务器上是最新的文件，那就把服务器上的文件下载到本地，合并自己的改动加上去并确认后再上传，而不致于会冲突。
3，删除服务器上的版本库的某个不想跟踪的目录，svn delete多余本地文件，再上传commit告诉服务器，其他地方同步时就会删除本地不想跟踪的文件。
4，如果一次要添加的文件在不同的文件夹内，切换到共同的上层目录，在该层目录用SVN COMMIT并选择属于同一批次的改动文件即可。
5，SVN 本地更新时，由于一些操作中断更新，如磁盘空间不够，用户取消。可能会造成本地文件被锁定的情况。一般出现这种情况，可以使用SVN clean up来清除锁定。
6，忽略类型设置，点击右键设置-》常规设置-》全剧忽略样式。针对Linux，也可以在终端中编辑各自用户目录下的配置文件，如vi ~/.subversion/config，找到# global-ignores = 即可。注意：这两者是都需设置的，windows设置了，linux仍然可能存在忽略异常。
7，如果使用SVN自带的比较查看器不太习惯，可以使用通用的BC来查看，也就是用外部的比较查看器。设置方法是：右键-》SVN-》External Programmes-》Diff Viewer，选择external之后，就可以选择C盘特定的应用软件EXE就行了。
8，如果想使用之前的某个版本，点击文件右键SVN后，点击update to version，输入具体想恢复的版本号，就可以了（也可以svn up -r 版本号来更新文件）。但是如果想把当前恢复的这个上传，则不会提示有更新（因为本地svn记录了是恢复旧的文件）。此时备份这些文件，再把目录文件更新到最新后，再用备份的替换掉，touch，再上传就行。
（2）以下是linux终端常用的SVN命令说明。
1，svn update（up）：更新工作拷贝到本机，如果想更新到中间的某个版本（比如svn 103）： svn update -r 103 mediatek/custom/XXX.C。实例：$ svn update
认真检查svn update的输出，一个字母显示在每一个项目之前，来让你知道Subversion对你的工作拷贝做了什么操作。如果解决svn update 产生Node remains in conflict的问题，使用svn revert --depth=infinity xxx再svn up，请参见解决svn update 产生Node remains in conflict的问题_运维天空_51CTO博客
2，svn add 做出添加。如果添加的目录或者文件包含有lib、bin、图片等非文本文件时一定记得带 --no-ignore参数。svn add xxxx --no-ignore 。
如果是提交目录，比如用svn status比较出新加的目录，同样用svn add 目录名，提交时用svn commit -m "xxx" 目录名，会自动添加目录和目录下的文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b5d3aba8e6d4fbdbd7a03a3b40d8077/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5372f3ad7c62cdc5b953b5e1cbbf70a5/" rel="bookmark">
			计算机基础（基本DOS命令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 常见的的Dos命令 exit 退出当前Dos命令窗口dir 列出当前路径下的子目录cls(clear screen) 清屏cd … 返回上一级目录cd \ 返回根目录c: 盘符切换d: 盘符切换（cd 目录名 ）直接跳到该目录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/556ae44cb1fdaf559c24b592765a42e2/" rel="bookmark">
			MinIO客户端（mc命令）实现数据迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一.概述二.docker启动mc实例,并进入容器内部三.通过mc命令连接两个minio服务四.迁移数据五、其他命令一些说明 一.概述 mc 命令提供了一个方便管理 ~/.mc/config.json 配置文件中的主机信息的方式，你也可以用文本编辑器手动修改这个配置文件。
通过minio提供的客户端实现资源迁移，本文章的mc通过docker创建。
minio1的api地址是192.168.180.45:39000
minio2的api地址是192.168.180.37:39000
二.docker启动mc实例,并进入容器内部 docker run -it --entrypoint=/bin/sh minio/mc 三.通过mc命令连接两个minio服务 #查看cat ~/.mc/config.json里的配置 mc config host ls #添加新的minio服务地址 mc alias set 名称 服务地址 用户名 密码 mc alias set minio1 http://192.168.180.45:39000 admin Qwe@1245 mc alias set minio2 http://192.168.180.37:39000 admin Qwe@1245 四.迁移数据 #全量迁移,重名文件不覆盖,bucket不存在会自动创建 mc mirror minio1 minio2 #只是迁移某个bucket,以test为例,目标的bucket需要提前建好 mc mirror minio1/test minio2/test #覆盖重名文件,加--overwrite mc mirror --overwrite minio1/test minio2/test 五、其他命令 mc命令详解
MinIO Client (mc)为ls，cat，cp，mirror，diff，find等UNIX命令提供了一种替代方案。它支持文件系统和兼容Amazon S3的云存储服务（AWS Signature v2和v4）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/556ae44cb1fdaf559c24b592765a42e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faf7bcfdfc703c92451339451f81ea6d/" rel="bookmark">
			window 下boost库 安装及VS引用（一劳永逸）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初步学习bosst库，留记于此，供后来人参考，若有错误，请各位指正！
一、获取文件 依照各自需求下载即可 https://www.boost.org/users/download/
送大家一个简单BOOST中文文档 http://zh.highscore.de/cpp/boost/
二、 区分 boost常用部分无需安装，可直接头文件引用，以下给出列表，可自行判断。 1、无需安装 Boost.Chrono
Boost.Context
Boost.Filesystem
Boost.GraphParallel
Boost.IOStreams
Boost.Locale
Boost.MPI
Boost.ProgramOptions
Boost.Python
Boost.Regex
Boost.Serialization
Boost.Signals
Boost.System
Boost.Thread
Boost.Timer
Boost.Wave
2、需要安装 Boost.DateTime
Boost.Graph
Boost.Random
Boost.Exception
三、 安装（安装所有库，若需定制安装，请自行百度） 1、命令行模式（win + r cmd），切换到自己boost文件目录下 C:\Users\SCboy\Desktop\boost_1_70_0**（请自行替换为个人相应目录下）** 2、依次输入以下命令进行安装 bootstrap .\b2 3、安装完成界面有两个路径需要在VS中添加（没有也无所谓） 四、 VS配置 1、 视图 -&gt; 其他窗口 -&gt;属性管理器 2、WIN32 -&gt;VC++目录-&gt;添加包含目录、库目录（安装完成界面所示） 若安装完成界面缺少上述两个路径，按照下述路径配置即可。 包含目录：boost文件路径 库目录:boost文件路径/state/lib 五、官方文档 https://www.boost.org/doc/libs/1_62_0/more/getting_started/windows.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeaa25bffe5684a0fa89dae621ced90e/" rel="bookmark">
			句子逆序 C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 句子逆序 描述
将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”
所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符
数据范围：输入的字符串长度满足1≤n≤1000
注意本题有多组输入
输入描述：
输入一个英文语句，每个单词用空格隔开。保证输入只包含空格和字母。
输出描述：
得到逆序的句子
示例1
输入：
I am a boy
输出：
boy a am I
示例2
输入：
nowcoder
输出：
nowcoder
代码
# include&lt;stdio.h&gt; int main() { char str[1000][1000]; int count=0; while(~scanf("%s",str[count])) { count++; } for(int i=count-1;i&gt;=0;i--) { printf("%s ",str[i]); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/941491c8941c58b83fc928d7846c5f56/" rel="bookmark">
			k8s命令（pod相关（驱逐、强制删除）、让Master当Node用、修改nodeport端口范围、修改k8sDNS、运行nslookup容器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、pod相关（驱逐、强制删除） 1、kubectl drain可以让node在维护期间排除节点。drain本意排水，意思是将出问题的node下的pod转移到其它node下运行。
kubectl drain nodename --delete-local-data --ignore-daemonsets --force 2、将node置为SchedulingDisabled不可调度状态
kubectl cordon nodename 将node置为SchedulingDisabled不可调度状态，后续的新创建pod容器时scheduler调度不会考虑该node，旧的pod容器不会受影响，仍可以对外提供正常服务。(特殊情况：pod容器如果跟node绑定的话，容器下次更新就不会回到原宿主机，该情况如何处理呢？可能设置成不可调度状态就不太合适。调度器 预调度策略）
恢复调度
kubectl uncordon nodename 3、Terminating可使用kubectl中的强制删除命令
# 删除POD kubectl delete pod PODNAME --force --grace-period=0 二、让Master也能当作Node使用 #将 Master 也当作 Node 使用 kubectl taint node nodename node-role.kubernetes.io/master- [root@app01 home]# kubectl taint node app01 node-role.kubernetes.io/master- node/app01 untainted [root@app01 home]# #将 Master 恢复成 Master Only 状态 kubectl taint node nodename node-role.kubernetes.io/master="":NoSchedule [root@app01 rabbitmq]# kubectl taint node app01 node-role.kubernetes.io/master="":NoSchedule node/app01 tainted [root@app01 rabbitmq]# 三、修改nodeport端口范围（nodePort 端口默认范围为:30000-32767） 编辑 kube-apiserver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/941491c8941c58b83fc928d7846c5f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11deef8cade983f23ae8ec0fcef0ced/" rel="bookmark">
			定制 kali nethunter内核 (官方不支持的手机)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Kali Linux NetHunter内核编译指南 发表于 2021-09-12 更新于 2022-10-08 分类于 kali 阅读次数： 阅读次数： 1890 Valine： 2
本文字数： 12k 阅读时长 ≈ 10 分钟
0x00 前言 近年来随着各种HVV活动的兴起，各种新的概念层出不穷。其中就有近源渗透这个概念。
黑客行走江湖，哪儿能没有些趁手的兵器装备呢？ 相信很多人都曾梦想过拥有一台黑客专属手机，走到哪儿黑到哪儿。那么现实中这样的手机存在吗？答案是肯定的！NetHunter就能满足你所有的需求！
Kali Linux NetHunter是由Offensive-Security团队打造的基于Android平台的渗透测试环境。
通过使用Kali Linux NetHunter我们可以使用诸如外接无线网卡破解WiFi，模拟BadUSB设备进行HID攻击，外接USB蓝牙适配器进行蓝牙攻击……等各种近源渗透活动。
在Kali Linux NetHunter官网我们可以查阅官方支持的设备型号列表。
对读者的要求
如果你会玩安卓刷机且手机型号恰好被官方支持，那么直接按照官方教程一步步来就好。
如果很不幸你的手机不被官方所支持但你会玩Linux且懂一些安卓开发以及C语言方面的知识想给自己的手机适配NetHunter，那么本篇教程就带你如何给一台不被官方支持的手机适配Kali NetHunter。
开始前的准备
· 一台能解锁BootLoader且内核源码开源的安卓手机
· 一台高性能x86_64 PC
内核源码的选择
一般来说，手机厂商开源的内核源码代码质量参差不齐（一言难尽），如果我们要选择自己适配NetHunter的话最好选择知名第三方开发者Fork的源码进行编译。
比较知名的有：
· LineageOS
· PixelExperience
· crDroid
· MoKee
· Havoc-OS
· Arter97
…等，这里不再一一列举。
交叉编译工具链的选择
对于较老版本的内核（3.18.x以下）的一般是使用Google GCC4.9
对于较新版本的内核（4.4.x以上）的建议使用Clang来编译
对于Google gcc编译器，使用以下命令下载
64位：
1 git clone https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b11deef8cade983f23ae8ec0fcef0ced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d8e72073a10bea835e47e1a0b84926/" rel="bookmark">
			输入整型数组和排序标识，对其元素按照升序或降序进行排序 C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入整型数组和排序标识，对其元素按照升序或降序进行排序 输入整型数组和排序标识，对其元素按照升序或降序进行排序
数据范围： 1 ≤ n ≤ 1000 ，元素大小满足 0 ≤ val ≤ 100000
输入描述：
第一行输入数组元素个数
第二行输入待排序的数组，每个数用空格隔开
第三行输入一个整数0或1。0代表升序排序，1代表降序排序
输出描述：
输出排好序的数字
示例1
输入：
8
1 2 4 9 3 55 64 25
0
输出：
1 2 3 4 9 25 55 64
示例2
输入：
5
1 2 3 4 5
1
输出：
5 4 3 2 1
代码
#include &lt;stdio.h&gt; int main() { int n; scanf("%d",&amp;n); int a[1000]; for(int i=0;i&lt;n;i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d8e72073a10bea835e47e1a0b84926/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc77ec8d1232f4c6038b796a7abbafe6/" rel="bookmark">
			零基础学JavaWeb开发（一）之 sql与mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL快速入门 一、SQL语句 1、SQL语句概述 1.SQL 是用于访问和处理数据库的标准的计算机语言。
2.SQL指结构化查询语言，全称是 Structured Query Language。
3.SQL 可以访问和处理数据库。
4.SQL 是一种 ANSI（American National Standards Institute 美国国家标准化组织）标准的计算机语言。
2、SQL语句特点 1. 具有综合统一性，不同数据库的支持的sql稍有不同
为许多任务提供了统一的命令，这样方便用户学习和使用，基本的 SQL 命令只需很少时间就能学会，甚至最高级的命令也可以在几天内掌握。数据库的操作任务通常包括以下几方面：增、删、改、查
常见数据库（mysql、sqlserver、oracle、db2等）
2. 非过程化语言
3.语言简捷，用户容易接受 select , drop, alter, create, insert, update ,delete
select * from mayikt_users ----查询 mayikt_users 的数据
4.集合性
SQL 可以在高层的数据结构上进行工作，工作时不是单条地处理记录，而对数据进行成组的处理语句都接受集合作为输入，并且返回集合作为输出
3、SQL语法特点 1.SQL 对关键字大小不铭感;
2.SQL语句可以单行或者多行数据，以分行结束;
3.SQL语句注释：
-- 单行注释 （后面一定要加一个空格） #单行注释 #后面可以不用加空格 /* 多行注释 多行注释 */ 数据库系统简介 数据库是一个以某种有组织的方式存储在硬盘上数据集合；
id
name（名称）
age(年龄)
1
mayikt
23
2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc77ec8d1232f4c6038b796a7abbafe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d861621ddb1c5c93195db424242569d/" rel="bookmark">
			并发编程(多线程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、进程与线程 多进程编程已经能够解决并发编程的问题了(已经可以利用cpu多核资源了).但是仍然存在这缺陷.
就是,进程太重了(消耗资源多,速度慢),线程应运而生被称为"轻量级编程",解决并发编程的各种问题的同时,让IO速度大大提升.
线程"轻"主要"轻"在申请资源/释放资源的操作上.
1.进程与线程的区别 这里我们举个例子:
如果在一个院子里有一条生产线,但现在产品饱和我们要扩大生产.该怎么办?
两种方法:
1.另外找一个院子复制一个一摸一样的生产线生产产品.(多进程)
2. 在原有的院子中再创建一条生产线.扩大生产.(多线程)
在这里方法一对应的就是进程的实现方法,而方法二对应的就是线程的实现方法.线程比进程节省了物流以及院子的资源.
进程和线程的关系:
进程包含一个或多个线程(不能没有),所以说在线程中只有第一个启动消耗的资源比较大.
在一个进程里的多个个线程调用的是同一份资源(主要指内存和文件描述表)
操作系统在实际调用的时候,其实是以线程为单位的.(进程调度相当于每个进程中只有一个线程)但如果进程中有多个线程,那么线程就是操作系统调度执行的基本单位.
总结:一个核心上只能有一个进程,而一个进程上有多个线程,在操作系统调度执行的时候只关心线程的线程的基本属性,而不关心进程.
二、进程安全问题 这里我们还是用一个例子来解释:
一个人吃100只鸡
两个房间,两个人一人吃50只鸡,速度就快于之前(多进程) 现在我们考虑多线程方式吃鸡:在一个房间放很多人一起吃鸡
但是桌子的面积是有限的(CPU的核心数量是有限的),所以说速度提升也是有上限的.人太多,多数资源都被分配在了选择让谁去吃鸡上了,就影响了正在吃鸡的人(线程太多,核心数量有限,不少开销都被浪费在了线程调度之上了)
并且,多数的人吃鸡还有可能产生纠纷,如两个人同时访问一块肌肉.导致发生问题,这种问题就被称为"线程安全问题".
一旦出现"两个人争夺一个鸡的情况",程序会直接崩溃,所以要妥善解决线程安全问题.
三、多线程 Java多线程最重要的类就是Thread类(不需要import任何包).
1.最基本的多线程代码 多线程需要使用Thread类在主线程上创建对象实现继承了Thread的自己创建的MyThread
在这里自己写的MyThread就是脱离主线程的另外的线程.
再在主线程里使用对象调用start()方法启动线程,就能保证两个线程同时运行了.
2.抢占式执行 抢占式执行是多线程编程最基本的性质.
看上面的代码运行结果:
这里的hello world和hello thread的执行顺序是随机的.是不可控的.(基本上无解)
3.jconsole jconsole是jdk自带的一个小工具,作用是查看Java中运行的进程.
这里第一个是 IDEA,第二个是jconsole工具自己,第三个是我们刚才运行的进程.
点击连接自己创建的线程可以看到里面用很多线程,其中main和Thread-0是和我们刚刚写的代码密切相关的. 也可以查看线程内部的调用栈来查看线程在哪里出错.
4.Java中创建线程的方法 1)继承Thread,重写run() 就是我们之前写的那个.
2)实现Runnable接口 依然需要Thread配合Runnable使用,注意:Runnable接口,需要重写抽象方法run(). 这里总结一下普通类、抽象类、接口:
抽象类里都是抽象方法和对象的抽象属性,而想要使用抽象类需要自己写个子类继承抽象类然后重写抽象方法.而接口里面只有抽象方法,想要使用的话也得写个子类继承抽象类然后重写抽象方法.
优势:解耦合,将线程创建与子类分开.
3)使用匿名内部类,继承Thread 创建了一个Thread的子类.(子类没有名字,所以才被称为匿名),并且创建了子类的实例用thread启动.
优势:在一个类中实现多线程.
4)使用匿名内部类,实现Runnable接口. 本质上和方法二相同,只不过把实现Runnable任务交给了匿名内部类的语法,此处是创建了一个类,实现Runnable,同时创建了类的实例,并且传给了Thread的构造方法.
5)使用Lambda表达式 这种方法是最简单也是最推荐使用的对线程实现方法. 5.Thread的用法 可以利用语法格式创建线程名字,也可用 jconsole查看线程
5.2 thread的几个常见属性 主要讲一下这个后台线程,在日常的代码中所写的所有代码都属于前台线程(包括main)用isDaemon()这个方法设置为后台线程.
后台线程的用法: 在程序中程序的是否结束就和后台线程无关了,只和前台线程有关.
是否存活指的是代码是否进入运行阶段,如创建了一个线程thread,在调用线程thread.start()之前isAlice()就是false,在调用thread.start()之后isAlice()就是true.
5.3 线程中断 1).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d861621ddb1c5c93195db424242569d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9be1709ea1734ac6a4dac8a44425485/" rel="bookmark">
			数字颠倒 C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数字颠倒 描述
输入一个整数，将这个整数以字符串的形式逆序输出
程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001
数据范围： 0 ≤ n ≤ 2 30 − 1 0≤n≤2^{30}-1 0≤n≤230−1
输入描述：
输入一个int整数
输出描述：
将这个整数以字符串的形式逆序输出
示例1
输入：
1516000
输出：
0006151
示例2
输入：
0
输出：
0
代码
#include &lt;stdio.h&gt; // 取余 int main() { int n; scanf("%d",&amp;n); do { printf("%d",n%10); n/=10; }while(n); return 0; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/189/">«</a>
	<span class="pagination__item pagination__item--current">190/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/191/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>