<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97201ef33e95fd46348a81eff18b488/" rel="bookmark">
			ParseError: not well-formed (invalid token): line 1, column 0问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现这个问题一般都是文件内部原因，第一行就停止读取，格式不正确。查看自己要读取的文件第一行。 使用解析xml文件，代码如下: def extract_xml(infile): tree = ET.parse(infile) root = tree.getroot() size = root.find('size') classes = [] for obj in root.iter('object'): cls_ = obj.find('name').text classes.append(cls_) return classes def extract_xml(infile): #与上述代码效果相同 with open(infile,'r') as f: #解析xml中的name标签 xml_text = f.read() root = ET.fromstring(xml_text) classes = [] for obj in root.iter('object'): cls_ = obj.find('name').text classes.append(cls_) return classes 找了很久的资料也没发现问题，我这个问题的主要原因就是在xml文件中第一行是一个""，导致读取文件停止。 只需要去掉""即可正常解析提取想要的信息。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ded91ab73849aad64b6a1974a3a3561/" rel="bookmark">
			Docker 的前世今生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自乐字节
要解释清楚 Docker，首先要解释清楚容器（Container）的概念。要解释容器的话，就需要从操作系统说起。操作系统太底层，细说的话一两本书都说不清楚。这里就一句话来总结一下：操作系统（Operating System，简称OS）是管理计算机硬件与软件资源的计算机程序，并且为软件运行提供通用服务的系统软件。
随着硬件的性能提升，软件种类的丰富，有两种情况变得很常见：
硬件性能过剩——很多计算机的硬件配置，往往会有大量时间处于硬件资源闲置的状态。例如一般家用电脑，已经是四核、六核的配置了，除了3A游戏、视频制作、3D渲染、高性能计算等特殊应用外，通常有 90% 以上时间 CPU 是闲置的；
软件冲突——因为业务需要，两个或者多个软件之间冲突，或者需要同一个软件的不同版本。例如早几年做 Web 前端的，要测试网页在不同版本的 IE 上是否能正常显示，然而 Windows 只能装一个版本的 IE。
为了解决软件冲突，只能配置多台计算机，或者很麻烦的在同一台电脑上安装多个操作系统。显然这两个方案都有其缺点：多台计算机成本太高，多操作系统的安装、切换都很麻烦。在硬件性能过剩的时候，硬件虚拟化的普及就很自然而然的提出来了。
所谓硬件虚拟化，就是某个特殊的软件，仿真出一台或者多台计算机的各种硬件，用户可以在这一台虚拟机上安装、运行操作系统（一般叫来宾操作系统，Guest OS）和各种应用，并且把 Guest OS 和上面应用软件对硬件资源的访问转发到底层的硬件上来实现。
对于 Guest OS 和上面的应用程序来说，这台虚拟机和普通物理计算机是完全一样没有任何区别的——除了性能可能差一点。全球第一人气的 VMware Workstation 就是这么一个软件，Oracle 的 VirtualBox 以及 Microsoft 的 Virtual PC 都是。这类软件英语有一个专用的单词是 Hypervisor（虚拟机管理程序）。
虚拟机的优点
可以把资源分配到不同的虚拟机，达到硬件资源的最大化利用；
相比直接在物理机上部署应用，虚拟机更容易扩展应用；
云服务：通过虚拟机虚拟出不同的物理资源，可以快速搭建云服务。
虚拟化技术主要用来解决高性能的物理硬件产能过剩和老旧的硬件硬件产品产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件。
虚拟机的缺点
虚拟机的缺点在于 Guest OS 通常会占用不少硬件资源。例如 Windows 安装 VMware 并开机 Guest OS，不运行任何应用的情况下，就需要占用 2 ~ 3G 内存，20 ~ 30G 硬盘空间。而且为了应用系统运行的性能，往往还要给每台虚拟机留出更多的内存容量。虽然不少 Hypervisor 支持动态内存，但基本上都会降低虚拟机的性能。在这样的资源占用情况下，少量的虚拟机还是可以接受的，如果同时运行十多台或数十台虚拟机，硬件资源的浪费就会成倍递增。通常来说，其中相当大一部分甚至全部 Guest OS 都是相同的。
能不能所有应用使用同一个操作系统减少硬件资源的浪费，但是又能避免包括运行库在内的软件冲突呢？操作系统层虚拟化——容器概念的提出，就是为了解决这个问题。Docker 就是一个容器的标准化实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ded91ab73849aad64b6a1974a3a3561/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c8aca170a984a0e37b603c70d6f57bc/" rel="bookmark">
			关于HTTP请求出现405状态码 Method not allowed的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图所示：
httppost请求目标网站会出现405 状态码，是因为 Apache、IIS、Nginx等绝大多数web服务器，都不允许静态文件响应POST请求。
所以将post请求改为get请求即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb9f110b5f7337a5ef72cf0ef55753bb/" rel="bookmark">
			swiper调整左右滑动按钮的位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		swiper本来的左右滑动按钮是跟slide重合的。
先看一下最终效果：
说一下大概的思路。
就是在swiper容器的最外层再加一层div 然后把左右滑动的按钮放在跟swiper平级。
代码：
css:
.swiper-father { width: 80%; height: 15%; top:75%; margin-left: auto; margin-right: auto; z-index: 9999; position: relative; } /*轮播按钮属性*/ .swiper-container { width: 90%; height: 100%; z-index: 9999; } .swiper-slide{ text-align: center; font-size: 18px; /*设置背景图片 及自适应*/ background: url("/assets/images/buttonStyle.jpg") no-repeat; border-style: none; background-size:cover; -webkit-background-size:cover; -o-background-size:cover; background-position:center; height: calc((100% - 50px) / 2); display: flex; justify-content: center; align-items: center; } 这里宽度自己设置，不能设置100% 是为了给滑动按钮留出空间
html:
&lt;#--地图下方的轮播按钮--&gt; &lt;div class="swiper-father"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb9f110b5f7337a5ef72cf0ef55753bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68c524b9f4e17bf395ed84b09af56ad0/" rel="bookmark">
			生物统计分析之主成分分析（PCA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 在医学统计中，尤其是在临床实验中，每个观测对象记录的观测结果包含多个反应变量（Respone Variables）。例如，血记录有收缩压、舒张压、脉压等，这种有多个变量的数据称为多变量数据。主成分分析是多变量分析方法中的一种分析方法，常见的多变量分析方法还包括多变量方差分析（Multivariate analysis of variance，MANOVA）、因子分析（Factor analysis）、典型相关（Canonical correlation analysis）、以及聚类分析（Cluster analysis）等。主成分分析（Principal Component Analysis，PCA）是一种掌握事物主要矛盾的统计分析方法，它可以从多元事物中解析出主要影响因素，揭示事物的本质，简化复杂的问题。计算主成分的目的是将高维数据投影到较低维空间。
主成分分析 主成分分析（Principal Component Analysis，PCA）通过将原始变量转换为原始变量的线性组合（主成分），在保留主要信息的基础上，达到简化和降维的目的。主成分与原始变量之间的关系主要有：
主成分是原始变量的线性组合。主成分的数量相对于原始数量更少。主成分保留了原始变量的大部分信息。主成分之间相互独立。 主成分分析的优点 不要求数据呈正态分布，主成分就是按数据离散程度最大的方向对基组进行旋转，这个特性扩展了其应用范围。通过对原始变量进行综合与简化，可以客观地确定各个指标的权重，避免主观判断的随意性。 分析流程 先进行相关性检验，如KMO检验和Bartlett 的检验，判断数据是否适合进行主成分分析。选取初始变量，统一量纲，将数据进行标准化处理。根据初始变量特性选择使用协方差矩阵还是相关矩阵来求主成分。计算协方差矩阵或相关矩阵的特征值和特征向量。确定主成分个数。提取主成分。对主成分做解释，主成分的意义由各线性组合中权重较大的几个指标来确定。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d510fecf920550c7b7726f76b2c0754d/" rel="bookmark">
			使用Wireshark抓取https加密报文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wireshark抓取https加密报文 原文链接：https://segmentfault.com/a/1190000023568902
1. 通过浏览器的 SSL 日志功能 目前该方案只支持Chrome和Firefox浏览器，通过设置SSLKEYLOGFILE环境变量，可以指定浏览器在访问SSL/TLS网站时将对应的密钥保存到本地文件中，有了这个日志文件之后wireshake就可以将报文进行解密了。
首先设置SSLKEYLOGFILE环境变量：
配置wireshake，首选项-&gt;Protocls-&gt;TLS：
将第一步中指定的文件路径配置好
重启浏览器，进行抓包：
同样的可以抓取到 HTTP 明文。
注：不抓包时记得把环境变量删掉，以避免性能浪费和安全性问题
可以抓取任意网站
SSL/TLS加密的报文，唯一的缺点就是只能是浏览器支持的情况才行，而方案一可以针对任何 HTTP 客户端进行抓包。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1035e2f3813dfaa77c9ed5ae884afc8/" rel="bookmark">
			java反序列化基础知识笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 反射基础知识动态代理基础知识静态代理动态代理 序列化相关函数反序列化的利用CTF java反序列a_piece_of_java 反射基础知识 反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。
通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。
反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。
反射常见的函数有
获取类的方法：forname
实例化类对象的方法：newInstance
获取函数的方法：getMethod
执行函数的方法：invoke
下面通过几个demo来看下这几类函数的用法。
public class reflectstudy { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { Class c = Class.forName("java.lang.Runtime"); Object o = c.newInstance(); Method method = c.getMethod("exec", String.class); method.invoke(o,"Calc.exe"); } 第一个例子首先通过forName获得c的Class对象，然后通过类对象的newInstance方法得到一个实例，通过getMethod方法获得exec函数。最后invoke执行函数传入执行的参数和一个类实例。
但是这个例子会报错，报错的原因是
因为Runtime这个类的默认构造方法是私有方法，我们不能用newInstance直接调用它。
所以我们尝试第二种方法
public class reflectstudy { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException { Class c = Class.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1035e2f3813dfaa77c9ed5ae884afc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ebdcbaff5f65c29428ebc935163158a/" rel="bookmark">
			HOG描述子的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于：(1 &lt;&lt; -1) - 1的博客
转载过来就乱码，希望原作者千万别删帖。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/392da403b0668fcfb5a2f9bbeb5cfb23/" rel="bookmark">
			32、给出一组区间，请合并所有重叠的区间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目 给出一组区间，请合并所有重叠的区间。
请保证合并后的区间按区间起点升序排列
二、实现 对左边界排序，如果下一个区间的左边界在前一个的有边界内，考虑是否要更新边界，
如果如果下一个区间的左边界在前一个的有边界外，说明区间无法合并，开始计算下一个区间
首先我们来考虑一个问题：什么样的两个区间可以合并？
像上图这样，起点大的那个区间（[13，16]）的起点在另一个区间的范围之内，这样两个区间就可以进行合并了
所以我们把全部的区间按起点进行排序，然后看一下第i个区间能不能和i-1个区间合并，如果能合并的话，就删掉第i-1个区间，然后把第i个区间变成这两个区间的合并
/** * Definition for an interval. * public class Interval { * int start; * int end; * Interval() { start = 0; end = 0; } * Interval(int s, int e) { start = s; end = e; } * } */ import java.util.*; public class Solution { public ArrayList&lt;Interval&gt; merge(ArrayList&lt;Interval&gt; intervals) { ArrayList&lt;Interval&gt; res = new ArrayList&lt;&gt;(); //结果集 //1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/392da403b0668fcfb5a2f9bbeb5cfb23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3837e632e261ef4a032acd847c3ba497/" rel="bookmark">
			2021-5-6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux
wc 命令
-c 显示文件字节数
-l 显示文件行数
-w 显示文件 内的字数
如果用 wc 命令，想要获取行号：wc -l &lt; nowcoder.txt 即可。
练习处
linux 显示文件倒数n行的内容
二叉树前序遍历，具有唯一性（前序遍历序列化成数组时，空需要用null 填充补位–》这样才可以保证唯一的结构）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/febe5028f8e7133d709d244e308fe503/" rel="bookmark">
			linux文件传输c代码,linux下网络文件传输C代码.doc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器(Server)代码：
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
void *thread(void *p);
int download(int client);
int uploading(int client);
int clientfd1;
int clientfd2;
int clientfd;
int main(int argc,char **argv)
{
int socketfd;
pthread_t tid1;
pthread_t tid2;
struct sockaddr_in info;
socketfd=socket(AF_INET,SOCK_STREAM,0);//创建一个用于网络通信的套接字
if(socketfd&lt;0)
{
printf("socket error\n");
return 1;
}
info.sin_family=AF_INET;
info.sin_port=htons(6688);
info.sin_addr.s_addr=0;
bind(socketfd,(const struct sockaddr *)&amp;info,sizeof(info));//一个套接字指明一个本地IP 和协议端口号
listen(socketfd,20);//服务器使用listen 是套接字处于被动状态(准备接受联入请求)
clientfd1=accept(socketfd,NULL,NULL);//服务器调用socket 创建一个套接字，用bind 指定一个本地IP 地址和协议端口号，然后用listen 使套接字处于被动状态，并设置连接请求队列的长度
if(clientfd&lt;0)
{
printf("accept error\n");
return 2;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/febe5028f8e7133d709d244e308fe503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87545b838b1163d8a4125d537409576a/" rel="bookmark">
			linux卸载gdb,安装/卸载GDB
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卸载原有GDB
１. 查询　ｇｄｂ是否安装
[root@test01~]# rpm -qa |grep gdb
gdb-7.0.1-37.el5_7.1
gdbm-1.8.0-26.2.1
２.　删除包
rpm-e --nodeps gdb-7.0.1-37.el5_7.1
注：
rpm -qa 后面要跟上包的名字才能搜索到
比如，rpm-qa http 搜不到，是因为包的名字叫做 httpd
rpm-qa | grep是把搜索到的全部包的名字交给 grep 去过滤，只要包含那个字符串就会被显示出来
安装新版本GDB
１.获获取gdb-7.2.tar.gz版本安装包
如果为gdb-7.2.tar.gz形式的则用
[root@localhost]# tar –xvzf gdb-7.2.tar.gz
２.　安装执行步骤
基本上所有的源码包都是三步，configure，make，make install。 进入gdb解压后的目录，按顺序执行以下命令：
[root@test01gdb-7.2]#./configure
[root@test01gdb-7.2]#make
[root@test01gdb-7.2]#make instal
[root@test01gdb-7.2]# cp gdb/gdb /usr/bin
查看gdb版本
[root@test01 gdb-7.2]# gdb GNU gdb (GDB) 7.2 Copyright (C) 2010 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later This is free software: you are free to change and redistribute it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87545b838b1163d8a4125d537409576a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80cd0ac9604053a7c7b21364db74362f/" rel="bookmark">
			fatal: unable to access ‘https://github.com/frozeman/bignumber.js-nolookahead.git/‘: Failed to conne
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fatal: unable to access ‘https://github.com/frozeman/bignumber.js-nolookahead.git/’: Failed to connect to github.com 问题描述：npm install web3@0.20.1 报错
run
git config --global url.git://github.com/.insteadOf https://github.com/ OK！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64303b232f7bcbf43f5d16efa5c6dbfa/" rel="bookmark">
			MySQL系统库之sys
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sys这个数据库主要是通过视图的形式把information_schema和
performance_schema结合起来，让程序员可以更方便的了解MySQL服务器的一
些性能信息。
sys系统库通常都是提供给专业的DBA人员排查一些特定问题使用的，其下
所涉及的各项查询或多或少都会对性能有一定的影响。
在使用上：
sys系统库支持MySQL 5.6或更高版本，不支持MySQL5.5.x及以下版本。
sys库的启用 因为sys系统库提供了一些代替直接访问performance_schema的视图，所
以必须启用performance_schema（将performance_schema系统参数设置为ON），sys系统库的大部分功能才能正常使用。
同时要完全访问sys系统库，用户必须具有以下数据库的管理员权限。
当然sys系统库本身已经提供了启用所有需要的功能的存储过程，比如：
启用所有的wait instruments：
mysql&gt; call sys.ps_setup_enable_instrument('wait'); +-------------------------+ | summary | +-------------------------+ | Enabled 315 instruments | +-------------------------+ 1 row in set (0.12 sec) Query OK, 0 rows affected (0.12 sec) 启用所有事件类型的current表：
mysql&gt; call sys.ps_setup_enable_consumer('current'); +---------------------+ | summary | +---------------------+ | Enabled 3 consumers | +---------------------+ 1 row in set (0.00 sec) Query OK, 0 rows affected (0.00 sec) 注意：performance_schema的默认配置就可以满足sys系统库的大部分数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64303b232f7bcbf43f5d16efa5c6dbfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e61816e2bf069faf74ce3f4353fe2729/" rel="bookmark">
			element table 中sortable排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中做表格的排序，我使用的是自定义的排序，也就是通过后台接口进行的排序，写个文章记录一下element的三种排序方式。
在列中设置sortable属性即可实现以该列为基准的排序，接受一个Boolean，默认为false。可以通过 Table 的default-sort属性设置默认的排序列和排序顺序。可以使用sort-method或者sort-by使用自定义的排序规则。如果需要后端排序，需将sortable设置为custom，同时在 Table 上监听sort-change事件，在事件回调中可以获取当前排序的字段名和排序顺序，从而向接口请求排序后的表格数据。在本例中，我们还使用了formatter属性，它用于格式化指定列的值，接受一个Function，会传入两个参数：row和column，可以根据自己的需求进行处理。
一、default-sort
你需要在那个列上加排序就在那一份列上加sortable ，加完后就会出现排序的按钮了，default-sort 可以设置默认的列和它默认的排列方式 ， order 为 ascending 按钮选中的是向上的箭头，如果 order 为 descending 那选中的是向下的箭头。
&lt;el-table :data="tableData" height="250" border style="width: 100%" :default-sort="{ prop: 'date', order: 'ascending' }" &gt; &lt;el-table-column prop="date" sortable label="日期" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; 二、sort-method
自定义方法我们需要在当前列加入sort-method，然后它的方法和sort排序是一样的，这样我们就可以自定义排序
&lt;el-table :data="tableData" height="250" border style="width: 100%"&gt; &lt;el-table-column prop="date" sortable label="日期" :sort-method="fn2" width="180" &gt; &lt;/el-table-column&gt; &lt;el-table-column prop="name" label="姓名" width="180"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e61816e2bf069faf74ce3f4353fe2729/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/546bd9394cd3836ce9b00bd15ddcd8b4/" rel="bookmark">
			快速学会JPA中所有findBy语法规则（好文章！简单明了！精辟！！）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、findBy findAllBy的区别 它们之间没有区别，它们将执行完全相同的查询，当从方法名称派生查询时，Spring Data会忽略All部分。
唯一需要强调重要的一点是By关键字，其后面的任何内容都被视为字段名称，如 findXXXXXXXXXXXXXByName 实际上==》 findByName
2、JPA中支持的关键词 And --- 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；
Or --- 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；
Between --- 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；
LessThan --- 等价于 SQL 中的 "&lt;"，比如 findBySalaryLessThan(int max)；
GreaterThan --- 等价于 SQL 中的"&gt;"，比如 findBySalaryGreaterThan(int min)；
IsNull --- 等价于 SQL 中的 "is null"，比如 findByUsernameIsNull()；
IsNotNull --- 等价于 SQL 中的 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/546bd9394cd3836ce9b00bd15ddcd8b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8baffca1ef3139e95d7302fabd813bd/" rel="bookmark">
			Java 字符串生成二维码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pom
&lt;!-- https://mvnrepository.com/artifact/com.google.zxing/core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; package cn.decentchina.kentucky.merchant.order.controller; import cn.decentchina.kentucky.common.enums.ErrorCodeEnum; import cn.decentchina.kentucky.common.exceptions.ErrorCodeException; import com.google.zxing.BarcodeFormat; import com.google.zxing.MultiFormatWriter; import com.google.zxing.common.BitMatrix; import lombok.extern.slf4j.Slf4j; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.nio.charset.StandardCharsets; /** * @Description: &lt;br/&gt; * 生成二维码 * &lt;p&gt; * &lt;br/&gt; * @Author: Qz1997 * @create 2020/12/29 14:12 */ @Slf4j public class GenerateQrCodeFile { /** * 黑 */ private static final int BLACK = 0xFF000000; /** * 白 */ private static final int WHITE = 0xFFFFFFFF; /** * 文件后缀 */ private static final String format = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8baffca1ef3139e95d7302fabd813bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f81e8453986d82a9b6a4ed756d7137f5/" rel="bookmark">
			文件上传excel使用easyexcel将excel中的数据导入数据库中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 添加依赖
&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; 页面
&lt;form action="weiuser/upload" th:action="@{/weiuser/upload}" method="post" enctype="multipart/form-data"&gt; &lt;input style="margin-top: 20px" th:type="file" th:name="file"&gt; &lt;br&gt; &lt;button id="btn" class="btn btn-success radius" th:type="submit"&gt;确认导入&lt;/button&gt; &lt;/form&gt; Controller
@RequestMapping("upload") public String upload(@RequestParam("file")MultipartFile multipartFile) throws IOException { Class&lt;WeiUser&gt; clazz=WeiUser.class; EasyExcel.read(multipartFile.getInputStream(), clazz, new AnalysisEventListener&lt;WeiUser&gt;() { @Override public void invoke(WeiUser weiUser, AnalysisContext analysisContext) { weiUserService.insert(weiUser); } @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) { System.out.println("数据解析完成"); } }).sheet().doRead(); return "redirect:/weiuser/getUserList"; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a979633205f96adb7f21343a2e8441/" rel="bookmark">
			2021-05-07
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插画的引用小技巧
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
开发工具与关键技术： PS
作者：苏莹
撰写时间：2021/5/7
打开PS软件点击文件，鼠标左击按一个新建然后这里会出一个新建框用一个椭圆形状画出圆形，填充你想填入的颜色 4.再用钢笔形状画出你想画出的图形，再填入适当颜色
5.再用钢笔形状画出适当形状，填充颜色
6.下面，再用钢笔形状画出形状，填充颜色。上面的用椭圆形
剪除一个图形再用（ctrl+alt）复制图形
7.再用钢笔形状画出来，填充颜色
这是我所学到的布尔运算引用步骤，所以我要分享给你们，希望可以帮助到你们。
以上就是我的分享，新手上道，请多多指教。如果有更好的方法或不懂得地方欢迎在评论区教导和提问喔！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1adab79ff5bf16807a5ebca90ea512cb/" rel="bookmark">
			腾讯云 ddns 配置 shell 脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/usr/bin/env bash # ========================================= # 个人信息 # ========================================= domain='yourdoman.com' subDomain='www' sId='腾讯云id' sKey='腾讯云秘钥' # 一般不会变动，所以手动就行，包含在注释掉的打印信息中 recordId='记录id' # ========================================= signatureMethod='HmacSHA1' timestamp=$(date +%s) nonce=$(head -200 /dev/urandom | cksum | cut -f2 -d" ") region=bj url="https://cns.api.qcloud.com/v2/index.php" # 获取 IP 的 api，可以自己替换 ip=$(curl -s ip.cip.cc) action='RecordList' src=$(printf "GETcns.api.qcloud.com/v2/index.php?Action=%s&amp;Nonce=%s&amp;Region=%s&amp;SecretId=%s&amp;SignatureMethod=%s&amp;Timestamp=%s&amp;domain=%s" $action $nonce $region $sId $signatureMethod $timestamp $domain) signature=$(echo -n $src | openssl dgst -sha1 -hmac $sKey -binary | base64) params=$(printf "Action=%s&amp;domain=%s&amp;Nonce=%s&amp;Region=%s&amp;SecretId=%s&amp;Signature=%s&amp;SignatureMethod=%s&amp;Timestamp=%s" $action $domain $nonce $region $sId "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1adab79ff5bf16807a5ebca90ea512cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1425191a59c5656fed0e2d942dfd2a87/" rel="bookmark">
			Java序列化Long类型数据到前端数据越界
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Java序列化Long类型数据到前端数据失真
现象
项目中用到了唯一ID生成器.生成出的ID是long型的(比如说4616189619433466044).
通过某个rest接口中返回json数据后,发现浏览器解析完变成了4616189619433466000.
原因
大致描述:java中得long能表示的范围比js中number大,也就意味着部分数值在js中存不下(变成不准确的值).
解决方法
方法就是不用number来保存long值,而是使用string.可以在客户端js修改,
也可以在服务端序列化的时候修改.
方案1：
import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer; //序列化成String的传 @JsonSerialize(using = ToStringSerializer.class) private Long id; 方案1：
@Configuration public class WebAppConfig extends WebMvcConfigurerAdapter { @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { MappingJackson2HttpMessageConverter jackson2HttpMessageConverter = new MappingJackson2HttpMessageConverter(); ObjectMapper objectMapper = new ObjectMapper(); /** * 序列化json时,将所有的long变成string * 因为js中得数字类型不能包含所有的java long值 */ SimpleModule simpleModule=new SimpleModule(); simpleModule.addSerializer(Long.class, ToStringSerializer.instance); simpleModule.addSerializer(Long.TYPE, ToStringSerializer.instance); objectMapper.registerModule(simpleModule); jackson2HttpMessageConverter.setObjectMapper(objectMapper); converters.add(jackson2HttpMessageConverter); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05e9325771327c03fc754463a7fc176f/" rel="bookmark">
			esp8266教程：GPIO输入输出模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公众号 欢迎扫码关注本人微信公众号：公众号上分享更多嵌入式知识和资料，分享个人学习嵌入式的心得体会。欢迎大家一起来玩呀。
esp8266教程：GPIO 什么是GPIO？ GPIO是（英语：General-purpose input/output）的简写,翻译成中文就是通用的输入、输出。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-5Ho4QDw0-
我们看到芯片上面伸出来的金属引脚大部分是GPIO引脚（部分为VCC、GND、模拟输入引脚）。
输出模式 当我们编程把GPIO引脚配置为输出模式的时候，可以控制引脚输出高电平或者低电平，如果芯片供电为5V，我们设置GPIO引脚为高电平，使用万用表测量GPIO的引脚可以量到引脚的电压为5V，反之设置GPIO引脚为低电平，那么通过万用表测试GPIO的引脚电压为0V。如果芯片的供电为3.3V，那么如果引脚设置为输出且为高电平的时候的引脚的电压为3.3v，所以我们可以知道GPIO上面的引脚的高电平的电压等于芯片的供电电压。
输出模式编程 #define GPIO_OUTPUT_IO_0 15 //配置GPIO15 #define GPIO_OUTPUT_IO_1 16 //配置GPIO16 #define GPIO_OUTPUT_PIN_SEL ((1ULL&lt;&lt;GPIO_OUTPUT_IO_0) | (1ULL&lt;&lt;GPIO_OUTPUT_IO_1)) GPIO初始化部分 gpio_config_t io_conf; //构建一个gpio_config_t 结构体，然后配置GPIO //因为设置为输出没有中断，所以关闭中断 io_conf.intr_type = GPIO_INTR_DISABLE; //设置为输出模式 io_conf.mode = GPIO_MODE_OUTPUT; //我们要配置两个输出引脚分别为GPIO15和GPIO16 io_conf.pin_bit_mask = GPIO_OUTPUT_PIN_SEL; //关闭下拉使能，下拉配置一般是输入的时候配置的 io_conf.pull_down_en = 0; //关闭上拉使能，上拉配置一般是输入的时候配置的 io_conf.pull_up_en = 0; //把我们构建的gpio_config_t结构体，传入gpio_config这个函数完成GPIO15和GPIO16输出的配置。 gpio_config(&amp;io_conf); //调用gpio_set_level这个函数将GPIO15和GPIO16输出低电平 gpio_set_level(GPIO_OUTPUT_IO_0, 0); gpio_set_level(GPIO_OUTPUT_IO_1, 0); //调用gpio_set_level这个函数将GPIO15和GPIO16输出高电平，gpio_set_level这个函数需要传入两个参数， //一个是控制那个GPIO引脚，我们这里是GPIO15和GPIO16，第二个参数代表高低电平，如果设置为高则传入1，反之传入0 gpio_set_level(GPIO_OUTPUT_IO_0, 1); gpio_set_level(GPIO_OUTPUT_IO_1, 1); 输出模式常用使用场景 通过控制GPIO引脚点亮LED灯。如图我们可以看到如果我们输出电平为高的时候GPIO引脚P3.0（P3.0只是对一个引脚的别名）和VDD都为高电平，没有电流通过led灯，所以led灯不亮。反之我们把GPIO的引脚配置为低电平，VDD因为是高电平，在led灯两端有电压差，所以就会有电流通过led灯，所以led灯会发光发亮。通过上面的实验我们可以初步的使用GPIO引脚。
输入模式 当我们编程把芯片的引脚配置为输入模式的时候，我们可以读取芯片的某个寄存器可以知道引脚上面的电压是高电平还是低电平。
输入模式的使用场景 我们有很多的电子产品都有按键，所以我们要知道用户是否按下就需要使用将GPIO引脚设置为输入模式了，当用户按下按键的时候GPIO连接到GND，所以读取寄存器可以读取到的是低电平，用户释放按键的时候，GPIO连接串联一个电阻连接到VCC，所以读取寄存器可以读取到的是高电平。
输入模式编程 #define GPIO_INPUT_IO_0 4 //配置输入引脚GPIO4 #define GPIO_INPUT_IO_1 5 //配置输入引脚GPIO5 #define GPIO_INPUT_PIN_SEL ((1ULL&lt;&lt;GPIO_INPUT_IO_0) | (1ULL&lt;&lt;GPIO_INPUT_IO_1)) gpio_config_t io_conf; //构建一个gpio_config_t 结构体，然后配置GPIO //这里我们不使用中断的方式，中断配置为关闭 io_conf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05e9325771327c03fc754463a7fc176f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c927e0a4579d4ba04b40c986c6861f0/" rel="bookmark">
			解决Ubuntu18.04更新遇到处理软件包(--configure)时出错的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 最近笔者在update升级Ubuntu18.04时遇到了一个bug，在upgrade时会提示"dpkg: 处理软件包 shim-signed (–configure)时出错"这个错误一直困扰了笔者好几天，终于找到了解决方法。
文章目录 0×1.如何解决dpkg处理软件包时出错等问题 0×1.如何解决dpkg 处理软件包时出错等问题 问题复现：
笔者安装的ubuntu版本是Ubuntu18.04，在使用下面命令升级的过程中，出现了如下错误信息：
qing@qingsword.com:~$ sudo apt update &amp;&amp; sudo apt upgrade ... dpkg: 处理软件包 shim-signed (--configure)时出错： 依赖关系问题 - 仍未被配置 因为错误消息指示这是由于上一个问题导致的错误，没有写入 apport 报告。 在处理时有错误发生： grub-efi-amd64-signed shim-signed 在这个问题中，笔者安装出错的软件包是"shim-signed"，随后笔者查询了部分网上资料发现，这个bug存在一个共性，报错信息大致如下，其中xxxx可以是任何软件包的名称：
dpkg: 处理软件包 xxxx (–configure)时出错
解决方法：
#1.重命名dpkg目录下的info目录 qing@qingsword.com:~$ sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_qingsword #2.创建一个新的info文件夹 qing@qingsword.com:~$ sudo mkdir /var/lib/dpkg/info #3.执行更新操作 qing@qingsword.com:~$ sudo apt-get update &amp;&amp; sudo apt-get -f install #4.将更新操作产生的文件，全部复制到重命名的info_qingsword文件夹下 qing@qingsword.com:~$ sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_qingsword #5.删除创建的info文件夹 qing@qingsword.com:~$ sudo rm -rf /var/lib/dpkg/info #6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c927e0a4579d4ba04b40c986c6861f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbc2a2002ce36f012cf2ef31455a0b5/" rel="bookmark">
			Macos JDk7（7u271）和 JDK8（8u261）以上版本没有 jmc 解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Macos 中 Jdk 安装路径为：/Library/Java/JavaVirtualMachines/jdk1.8.0_291.jdk/Contents/Home/bin
解决版本：
根据，Home 目录下面的 jmc.txt 中提示，该版本的 JDK 已经不包括 Java Mission Control（JMC），JMC 需要单独进行下载，下载网址为：https://www.oracle.com/javase/jmc，根据该网页提示，最终点击的下载网址为：https://www.oracle.com/java/technologies/javase/products-jmc8-downloads.html 然后选择下载即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2dda0a8d386622921d37a9386c6d0cf/" rel="bookmark">
			linux usleep函数,linux下，测试usleep函数对CPU占用率的影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、本机环境
CPU信息
Intel(R) Core(TM) i3 CPU M 350 @ 2.27GHz
Intel(R) Core(TM) i3 CPU M 350 @ 2.27GHz
Intel(R) Core(TM) i3 CPU M 350 @ 2.27GHz
Intel(R) Core(TM) i3 CPU M 350 @ 2.27GHz
内存信息
MemTotal: 1990228 kB
二、搭建测试代码
1.测试代码
#include #include using namespace std;
#define ElapsedTime 1
int
main(void)
{
cout &lt;&lt; "current pid : " &lt;&lt; getpid() &lt;&lt; endl;
while (1)
{
//usleep(ElapsedTime);
}
return 0;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b2dda0a8d386622921d37a9386c6d0cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89ba54d79e685e54d741fe4e6830a001/" rel="bookmark">
			linux执行命令提示缺少so,Linux软件缺少动态链接库.so怎么办
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux在安装软件的时候有时会出现错误，提示缺少动态链接库.so，该问题是由什么原因导致的呢?又该如何解决?下面学习啦小编就给大家介绍下解决Linux软件提示缺少动态链接库.so的方法，一起来了解下吧。
Linux安装软件时提示缺少动态连接库.so的情况：
1.缺少动态连接库.so-cannot open shared object file:No such file or directory
2.缺少动态连接库.so.0-cannot open shared object file:No such file or directory
3.缺少动态连接库.so.1-cannot open shared object file:No such file or directory
可以直接： # sudo ldconfig
再编译，如果不行，按以下方法做：
总结下来主要有3种方法：
1. 用ln将需要的so文件链接到/usr/lib或者/lib这两个默认的目录下边
ln -s /where/you/install/lib/*.so /usr/libsudo ldconfig
2.修改LD_LIBRARY_PATH
export LD_LIBRARY_PATH=/where/you/install/lib：$LD_LIBRARY_PATHsudo ldconfig
3.修改/etc/ld.so.conf，然后刷新
vim /etc/ld.so.conf
add /where/you/install/lib
sudo ldconfig
上面就是Linux安装软件时提示缺少动态链接库的解决方法的介绍了，一共有三种提示情况，解决的方法也有三种，根据具体情况来解决问题。
Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38f2ea4cceea7220498aae5e824f9a4b/" rel="bookmark">
			linux命令安装openssl函数库,ubuntu安装openssl库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux版本：ubuntu14.04
输入以下命令：
sudo apt-get install openssl
sudo apt-get install libssl-dev
sudo apt-get install libssl0.9.8
sudo apt-get install libgtk2.0-dev
备注：在执行sudo apt-get install libssl-dev时，遇到了问题：
The following packages have unmet dependencies:
libssl-dev: Depends: libssl0.9.8 (= 0.9.8k-7ubuntu8.6) but 0.9.8k-7ubuntu8.8 is to be installed
E: Broken packages
解决办法：
编辑/etc/apt/sources.list ,添加以下内容
deb http://security.ubuntu.com/ubuntu lucid-security main
# sudo apt-get update
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d228e8257b1da35b769f326893a1c2f/" rel="bookmark">
			第69节 用指针法访问数组元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.你将发现一个内幕!
#include &lt;stdio.h&gt;	#define n 5 int main() { unsigned int a[n] = { 123,5,9,11,33 }; printf("%x\n", a); printf("%x\n", &amp;a[0]); printf("%d\n", a[0]); printf("%d\n", *a); } 运行结果: 135fd94 135fd94 123 123 结论: 数组名,即数组的地址!数组首元素的地址!
二.掌握内幕之后……
1.数组名为数组首元素的地址,可知
① 定义: int a[10] ; int *p ;
② 等价的赋值 : p=&amp;a[0] &lt;=&gt; p=a;
③ 指针变量赋初值: int *p=&amp;a[0]; &lt;=&gt; int *p=a;
④ 指针引用数组元素: printf("%d %d", *p, *(p+1)) &lt;=&gt; printf("%d %d", a[0], a[1]);
⑤ p+i的意义：p之后第i个单元
2.因数组名等同于指向数组首元素的指针,可知
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d228e8257b1da35b769f326893a1c2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d013593bac2568abc8bc54368e9df0e/" rel="bookmark">
			2021年华为c&#43;&#43;面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++面试题 3.python中 tuple 和 list的区别 Python 的元组与列表类似，不同之处在于元组的元素不能修改。
元组使用小括号 ( )，列表使用方括号 [ ]。
4.python 和 C++的区别，两者的应用场景有什么差别。 1、运行效率：C++ &gt;&gt; Python
2、开发效率：Python &gt;&gt; C++
5.说一说二分法是什么，算法的思路，常见的用途 分法查找适用于数据量较大时，但是数据需要先排好顺序。
其实，部分有序也可以用二分法
6.说一说 链表和数组 的区别，我python最近用的少，就用C++的 list array vector举例说的底层实现以及数据结构的含义 vector （向量）——STL中标准而安全的数组。只能在vector 的“前面”增加数据。
deque （双端队列double-ended queue）——在功能上和vector相似，但是可以在前后两端向其中添加数据。
list （列表）——游标一次只可以移动一步。如果你对链表已经很熟悉，那么STL中的list则是一个双向链表（每个节点有指向前驱和指向后继的两个指针）。
set （集合）——包含了经过排序了的数据，这些数据的值(value)必须是唯一的。
map （映射）——经过排序了的二元组的集合，map中的每个元素都是由两个值组成，其中的key（键值，一个map中的键值必须是唯一的）是在排序或搜索时使用，它的值可以在容器中重新获取；而另一个值是该元素关联的数值。比如，除了可以ar[43] = "overripe"这样找到一个数据，map还可以通过ar[“banana”] = "overripe"这样的方法找到一个数据。如果你想获得其中的元素信息，通过输入元素的全名就可以轻松实现。
multiset （多重集）——和集合（set）相似，然而其中的值不要求必须是唯一的（即可以有重复）。
multimap（多重映射）——和映射（map）相似，然而其中的键值不要求必须是唯一的（即可以有重复）。
序列式容器
vector -》底层数据结构为数组，支持快速随机访问 list -》底层数据结构为双向链表，支持快速增加和删除 deque -》底层数据结构为一个中央控制器和多个缓冲区 stack、queue -》(适配器：对容器的封装)底层数据结构为list或deque（vector容量大小有限制不使用） priority_queue -》底层数据结构为vector，以堆的处理规则来管理 关联式容器
底层数据结构为红黑树，有序的 set -》不可重复 map -》不可重复 multiset -》可重复 multimap -》可重复 底层数据结构为哈希表，无序的 unordered_set -》不可重复 unordered_map -》不可重复 unordered_multiset -》可重复 unordered_multimap -》可重复 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d013593bac2568abc8bc54368e9df0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/737e532b3ca257fc3e3e8ad3bdee69d4/" rel="bookmark">
			Xms、Xmx、MaxMetaspaceSize含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Xms：表示JVM Heap（堆内存）最小尺寸，初始分配空间；
Xmx：表示JVM Heap（堆内存）最大允许的尺寸，过小可能会导致java.lang.OutOfMemory
PermSize：永久代最小尺寸，初始分配
MaxPermSize：永久代最大的尺寸，过小会导致java.lang.OutOfMemoryError：PermGen space
MetaspaceSize：元空间最小尺寸，初始分配
MaxMetaspaceSize：元空间最大的尺寸
注：Java8以后，永久代被元空间取代，同时元空间不像永久代一样受制于内存，元空间是基于操作系统内存的，理论上可以一直扩展内存知道操作系统的极限。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d2ad0f8a450bbb26b0c2f210a4d15df/" rel="bookmark">
			C语言三子棋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 三子棋游戏规则2.设计思路3.代码详解4.完整代码 1. 三子棋游戏规则 是黑白棋的一种。三子棋是一种民间传统游戏，又叫九宫棋、圈圈叉叉、一条龙、井字棋等。将正方形对角线连起来，相对两边依次摆上三个双方棋子，只要将自己的三个棋子走成一条线，对方就算输了。但是，有很多时候会出现和棋的情况。
2.设计思路 游戏流程：
1.创建棋盘，并且初始化，将所有位置设置为空格。
2.打印棋盘
3.玩家通过输入坐标（row,col)进行落子
4.判定胜负
5.电脑随机落子
6.判断胜负
具体实现：
1.用一个3*3的二维数组来表示棋盘，数组的每个元素是char类型
2."x"表示玩家1，"o"表示玩家2，空格即为空白。
3.rand&amp;srand控制电脑随机落子
3.代码详解 （1）.3为魔幻数字，为了避免混乱则使用宏定义
#define MAX_ROW 3 #define MAX_COL 3 char chessBoard[3]3]; char chessBoard[MAX_ROW][MAX_COL]; 不建议定义为全局变量
（2）.初始化函数 将棋盘的每一个位置都初始化为空格
void init(char chess[MAX_ROW][MAX_COL]) { for (int row = 0; row &lt; MAX_ROW; row++) { for (int col = 0; col &lt; MAX_COL; col++) { chess[row][col] = ' '; } } } （3）.打印棋盘
void print(char chess[MAX_ROW][MAX_COL]) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d2ad0f8a450bbb26b0c2f210a4d15df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca356742fa812758613cfe4fe8fb68a/" rel="bookmark">
			2021-5-4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java 面向对象的三个特性和五个基本原则
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/325843825a2745a2a8f9b9e3355cb864/" rel="bookmark">
			2021-05-06
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Internet中，IP数据报从源结点到目的结点可能需要经过多个网络和路由器。在整个传输过程中，IP数据报头部中的源IP地址和目的IP地址（）。
（5.0分）5.0 分
A、
源地址和目的地址都不会发生变化
B、
源地址不会发生变化而目的地址有可能发生变化
C、
源地址和目的地址都有可能发生变化
D、
源地址有可能发生变化而目的地址不会发生变化
正确答案： A 我的答案：A
2
*RIP 协议报文中可能出现的最大跳数是（）。
（5.0分）0.0 分
A、
25
B、
15
C、
30
D、
16
正确答案： D 我的答案：B
3
*在数据传输过程中路由是在（ ）实现的。
（5.0分）5.0 分
A、
物理层
B、
链路层
C、
网络层
D、
传输层
正确答案： C 我的答案：C
4
*设某路由器建立了如下路由表：
目的网络 子网掩码 下一跳 128.96.39.0 255.255.255.128 接口0 128.96.40.0 255.255.255.128 R2 192.4.153.0 255.255.255.192 R3 0.0.0.0 0.0.0.0 R4 现收到1个分组，其目的地址为： 192.4.153.11 ，该路由器会将分组转发给（ ）。
（5.0分）0.0 分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/325843825a2745a2a8f9b9e3355cb864/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c70574c92038fd2ca1c2dd5767f9545/" rel="bookmark">
			linux安装kde桌面环境,在Debian 10（Buster）上安装KDE桌面环境的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍在Debian 10(Buster)操作系统上安装KDE桌面环境(KDE Plasma Desktop Environment)的方法。Debian并没有为每个新版本提供KDE版本，但你可以在Debian 10(Buster)上轻松安装KDE桌面环境，此安装适用于运行Debian 10(Buster)桌面版本的用户， 如果你在云中运行Debian 10，或者没有GUI运行虚拟机管理程序，或者不想使用GUI，则此安装不适合你。要安其它桌面可参考在Debian 10 Buster上安装Cinnamon桌面环境的方法。
在Debian 10(Buster)上安装KDE桌面环境
从Debian 10(Buster)安装KDE桌面，安装期间添加了官方上游存储库，运行：
sudo apt -y install task-kde-desktop
安装，注销或重启后开始使用Debian 10 Buster上的KDE桌面环境：
$ logout
或：
$ reboot
使用登录屏幕上的桌面环境切换器选择KDE Plasma：
至此，已成功登陆到KDE桌面中：
相关主题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1402de41d3ecf40b84f7c954276d74a1/" rel="bookmark">
			Zookeeper- 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Zookeeper- 总结 如想了解更多更全面的Java必备内容可以阅读：所有JAVA必备知识点面试题文章目录：
JAVA必备知识点面试题 文章目录 Zookeeper- 总结1、Http和RPC的区别？2、Google的GFS(google file system)集群中是怎么进行master选举的？3、说说zookeeper是什么？4、Zookeeper提供了哪些常用的功能？5、什么是leader选举和原子广播？6、说说你对Zookeeper节点和节点状态信息的理解？7、说说Zookeeper中Watcher作用？8、Zookeeper是如何实现服务的注册与发现？9、Zookeeper中watcher机制的特性是什么？10、Zookeeper原生提供了哪些监听事件？11、Curator提供了几种Watcher来监听节点的变化？12、Zookeeper分布式锁的实现原理？13、curator提供了哪些常用的Zookeeper分布式锁的封装?14、leader节点和各个follower节点如何保证数据一致性？15、各个follower在收到COMMIT命令前leader就挂了，导致数据不一致情况，Zookeeper是怎么处理的？16、Zookeeper是如何保证事务的顺序一致性的？17、什么情况下会进行leader选举？18、Zookeeper下Server 工作状态？19、Zookeeper服务器角色有哪些？20、服务器启动时的leader选举实现原理？21、运行过程中leader节点宕机，整个集群无法处理写请求，如何快速从其他节点里面选举出新的leader呢？22、什么是ACL权限控制机制？23、Chroot特性是什么?24、zookeeper负载均衡和nginx负载均衡区别？25、集群最少要几台机器，集群规则是怎样的?26、集群支持动态添加机器吗？27、chubby是什么？28、ZAB和Paxos算法的联系与区别？29、Zookeeper的典型应用场景？ 1、Http和RPC的区别？ RPC(Remote Produce Call 远程过程调用)：自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型。
Http：网络传输协议：基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。
相同点：底层通讯都是基于socket，都可以实现远程调用，都可以实现服务调用服务
不同点：
RPC：当使用RPC框架实现服务间调用的时候，要求服务提供方和服务消费方 都必须使用统一的RPC框架，要么都dubbo，要么都cxf
跨操作系统在同一编程语言内使用
优势：调用快、处理快
应用：dubbo、cxf、（RMI远程方法调用）Hessianhttp：当使用http进行服务间调用的时候，无需关注服务提供方使用的编程语言，也无需关注服务消费方使用的编程语言，服务提供方只需要提供restful风格的接口，服务消费方按照restful的原则请求服务即可。
跨系统跨编程语言的远程调用框架
优势：通用性强
应用：httpClient 2、Google的GFS(google file system)集群中是怎么进行master选举的？ 在Google有一个文件系统GFS(google file system)，需要从多个gfs server中选出一个master server。
GFS就是使用Google Chubby来解决这个问题的。【Google Chubby 不开源】
所有的server通过Paxos协议到Chubby server上的一个节点上创建同一个文件，当然，最终只有一个server能够成功创建这个文件，这个server就成为了master，它会在这个文件中写入自己的地址，这样其它的server通过读取这个文件就能知道被选出的master的地址。
3、说说zookeeper是什么？ ZooKeeper：是一个高可靠的分布式协调中间件。它是Google Chubby的一个开源实现。
ZooKeeper分为服务器端（Server）和客户端（Client）客户端，客户端可以连接到整个ZooKeeper的任意服务器上（除非参数zookeeper.leaderServes=no，leader不允许接受客户端连接）
客户端使用并维护一个TCP连接，通过这个连接发送请求、接受响应、获取观察的事件以及发送心跳。如果这个TCP连接中断，客户端将自动尝试连接到另外的ZooKeeper服务器。
ZooKeeper服务端启动时，将从实例中选举一个leader，Leader负责处理事务请求、数据同步等操作，一个更新操作成功的标志是当且仅当超过半数以上Server在内存中成功修改数据。
Zookeeper集群间通过Zab协议（Zookeeper Atomic Broadcast）来保持数据的一致性。Zab协议包含两个阶段：leader选举/崩溃恢复(leader election)阶段 和 原子广播(Atomic Brodcast)阶段。
4、Zookeeper提供了哪些常用的功能？ Watcher监听心跳监测主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程。分布式锁：提供两种锁：独占锁、共享锁。命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。ACL对节点权限控制 5、什么是leader选举和原子广播？ 集群启动，在集群中将选举出一个leader，其他的机器则称为follower，所有的写操作都被传送给leader，并通过广播将所有的更新告诉给follower。当leader崩溃或者leader失去大多数的follower时，需要重新选举出一个新的leader，让所有的服务器都恢复到高可用状态。当leader被选举出来，且大多数服务器完成了和leader的状态同步后，leader选举的过程就结束了，就将会进入到原子广播的过程。原子广播是同步leader和follower之间的信息，保证数据在集群中各个节点的一致性。 6、说说你对Zookeeper节点和节点状态信息的理解？ Zookeeper每一个节点称之为ZNode，是Zookeeper的最小单元。每个ZNode上都可以保存数据以及挂载子节点。构成一个层次化的树形结构。
ZNode节点类型：
#### zookeeper-3.5.3 CreateMode类源码如下： public enum CreateMode { //【持久化节点】：创建后会一直存在 zookeeper 服务器上，直到主动删除 PERSISTENT (0, false, false, false, false), //【持久化有序节点】：每个节点都会为它的一级子节点维护一个顺序 PERSISTENT_SEQUENTIAL (2, false, true, false, false), //【短暂的临时节点】：临时节点的生命周期和客户端的会话绑定在一起，当客户端会话失效该节点自动清理 EPHEMERAL (1, true, false, false, false), //【短暂的临时有序节点】：在临时节点的基础上多了一个顺序性 EPHEMERAL_SEQUENTIAL (3, true, true, false, false), //容器节点：是特殊用途的节点，用于leader、lock等方法。当容器的最后一个子元素被删除时，该容器将成为将来某个时候服务器删除的候选对象。 CONTAINER (4, false, false, true, false), //客户端断开连接后不会自动删除Znode，如果该Znode没有子节点且在给定TTL时间内无修改，该Znode将会被删除；TTL单位是毫秒，必须大于0且小于或等于EphemeralType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1402de41d3ecf40b84f7c954276d74a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16efe72cc131b1a3cf22371c74108c7c/" rel="bookmark">
			linux设置网卡采集模式,参考ethtool写了个Linux设置、获取网卡模式的接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		差不多一个月没写文章了，这期间，主要是搞一些比较复杂的问题，一直被搞，没有搞其它的东西，也就没写出什么东西来。
在找问题过程中，上网了解到ethtool这个工具十分强大，以为这个代码很复杂，而恰好领导要求我提供设置网卡信息的接口，于是下了代码，研究了一下，参考了一下，整理了一下。当然文中写的是第一个版本，要是这样的接口提供出去，其它部门的人肯定会有意见的。
Linux内核很早就已经加入ethtool相关的控制命令了(不是内核fans，不了解是哪个版本加入的)，在用户空间调用ioctl函数即可。有空的话，就专门写篇关于ethtool的内核跟踪的文章。现在只需知道，在本文提到的功能中，使用ethtool的ETHTOOL_GSET可以获取网卡信息，而ETHTOOL_SSET是设置网卡信息，其它的可以查询ethtool.h这个头文件。当中最重要的结构体是ethtool_cmd，其定义如下：
/* This should work for both 32 and 64 bit userland. */
structethtool_cmd {
__u32 cmd;
__u32 supported; /* Features this interface supports */
__u32 advertising; /* Features this interface advertises */
__u16 speed; /* The forced speed, 10Mb, 100Mb, gigabit */
__u8 duplex; /* Duplex, half or full */
__u8 port; /* Which connector port */
__u8 phy_address;
__u8 transceiver; /* Which transceiver to use */
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16efe72cc131b1a3cf22371c74108c7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63ee44c5f049e6df11f7db00cee41f9a/" rel="bookmark">
			SDWAN-虚拟网卡（最全详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.虚拟网卡介绍 虚拟网卡通常称为为tap/tun。
tap/tun 是 Linux 内核 2.4.x 版本之后实现的虚拟网络设备，不同于物理网卡靠硬件网卡实现，tap/tun 虚拟网卡完全由软件来实现，功能和硬件实现完全没有差别，它们都属于网络设备，都可以配置 IP，都归 Linux 网络设备管理模块统一管理。
二.物理网卡收发包流程 1.收包：外界向该物理网卡发送数据包时，外界发送到网卡的数据包最终会传输到内核空间的网络协议栈中
2.发包：本机要从物理网卡发送数据包时，数据将从内核的网络协议栈传输到网卡，网卡负责将数据发送出去
注：现在的网卡具备DMA能力，所以网卡和网络协议栈之间的数据传输由网卡负责，而非由内核亲自占用CPU来执行读和写
一般来说，数据的起点和终点是用户程序，所以多数时候的数据需要在用户空间和内核空间(网络协议栈)再传输一次：
物理网卡需要通过网卡驱动在内核中注册后才能工作，它在内核网络协议栈和外界网络之间传递数据，用户可以为物理网卡配置网卡接口属性，比如IP地址，这些属性都配置在内核的网络协议栈中。
三.虚拟网卡收发包流程 内核也可以直接创建虚拟的网卡，只要为虚拟网卡提供网卡驱动程序，使其在内核中可以注册成为网卡设备，它就可以工作。
从Linux内核3.x版本开始，物理网卡和虚拟网卡是平等的设备，它们都会在注册时创建net_device数据结构来保存(物理或虚拟)设备信息。
相比于物理网卡负责内核网络协议栈和外界网络之间的数据传输，虚拟网卡的两端则是内核网络协议栈和用户空间，它负责在内核网络协议栈和用户空间的程序之间传递数据。
1.收数据包： 数据如何从内核空间到用户空间呢？这里用到一个字符设备。
在 Linux 中，用户空间和内核空间的数据传输有多种方式，字符设备就是其中的一种。tap/tun 通过驱动程序和一个与之关联的字符设备，来实现用户空间和内核空间的通信接口。
在 Linux 内核 2.6.x 之后的版本中，tap/tun 对应的字符设备文件分别为：
tap：/dev/tap0 tun：/dev/net/tun 设备文件即充当了用户空间和内核空间通信的接口。当应用程序打开设备文件时，驱动程序就会创建并注册相应的虚拟设备接口，一般以 tunX 或 tapX 命名。当应用程序关闭文件时，驱动也会自动删除 tunX 和 tapX 设备，还会删除已经建立起来的路由等信息。
tap/tun 设备文件就像一个管道，一端连接着用户空间，一端连接着内核空间。当用户程序向文件 /dev/net/tun 或 /dev/tap0 写数据时，内核就可以从对应的 tunX 或 tapX 接口读到数据，反之，内核可以通过相反的方式向用户程序发送数据。
2.发包流程 Tap/Tun如何和网络协议栈传输数据 tap/tun 通过实现相应的网卡驱动程序来和网络协议栈通信。一般的流程和物理网卡和协议栈的交互流程是一样的，不同的是物理网卡一端是连接物理网络，而 tap/tun 虚拟网卡一般连接到用户空间。
如上图所示，假设APP A要访问 192.168.1.200的服务器，数据包经过协议栈如下几个步骤：
1.APP A发送数据包到内核协议栈
2.经过内核协议栈的路由判决，判断下一个出接口为TunX
3.TunX接收到数据后，将数据包发送到字符设备/dev/net/tun
4.APP B从字符设备读取出数据包，已知要访问192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63ee44c5f049e6df11f7db00cee41f9a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2340e810486a0246e538eb23de881b18/" rel="bookmark">
			ZYNQ7000 （二十）等精度频率计的原理分析和实例实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		等精度频率计的原理分析和实例实现
这一视频主要来分析实现等精度频率计。通过分析硬件实现原理，编写
PL的逻辑实现部分，以及对应 PS的 C语言操作，操作挂在 PS寻址空间的寄存器，
达到控制等精度频率计逻辑，读取计数结果，并在 PS里通过运算，计算出实际
所要测试的频率值。这是一个很好的软件硬件分工协作的例子。硬件逻辑中有精
确到时钟边缘的失序，而软件运算为了提高精度使用了双精度浮点运算。学习这
一视频希望大家在掌握等精度原理和进一步熟悉软件操作的基础上体会如何下
手分析一个设计，进行软件硬件的分工，并最终实现所有细节。
等精度说的就是精度相等，也就是测试出来的精度取决于参考时钟的精度。
他是使用两个计数器同时计数，两个计数器的时钟分别是参考时钟和被测试信号
的时钟。同时【注】开启计数器和同时关闭计数器，运行同样长的时间。
Cref\Fref = Tref
Cin\Fin = Tin
Tref = Tin
所以
Cref\Fref =Cin\Fin
得到
Fin = ( Fref * Cin ) / Cref ;
分析框图，看看具体实现有什么说法：我们看到两个计数器和一个使能控制
寄存器。这两个计数器分别接参考时钟和被测试的信号，在这里被测试信号被当
做一个时钟，在每一个被测信号上升边缘
做一个时钟，在每一个被测信号上升边缘+1。他们是受同一个使能信号控制的，。他们是受同一个使能信号控制的，只有使能信号为只有使能信号为1时候才允许累加。这是基本原理。时候才允许累加。这是基本原理。
控制的时候主控部分输出使能信号（预制门），在被采集信号的上升边缘到
控制的时候主控部分输出使能信号（预制门），在被采集信号的上升边缘到来以后两来以后两个计数器再以自己时钟频率计数。当我们要读取两个计数器的时候，就个计数器再以自己时钟频率计数。当我们要读取两个计数器的时候，就先关闭掉使能信号。在被采集信号的上升边缘到来后两个计数器停止累加采集。先关闭掉使能信号。在被采集信号的上升边缘到来后两个计数器停止累加采集。这样我们读出两个计数器的数值，结合参考频率运算出被测试信号的频率数值。这样我们读出两个计数器的数值，结合参考频率运算出被测试信号的频率数值。而下次控制采集之前，要先清除一下当前的计数器数值，通过清零信号置位。而下次控制采集之前，要先清除一下当前的计数器数值，通过清零信号置位。
我们继续看看一下使能信号的产生，一个外部控制信号出来接在一个同步寄
我们继续看看一下使能信号的产生，一个外部控制信号出来接在一个同步寄存器上，这个寄存器的时钟是被采集信号，这点很重要，也是设计的精髓：我们存器上，这个寄存器的时钟是被采集信号，这点很重要，也是设计的精髓：我们知道是在时钟的上升边缘寄存器知道是在时钟的上升边缘寄存器D的输入更新到的输入更新到Q的输出，看输出波形。我们的输出，看输出波形。我们看下面这个波形图。经过了被采集信号同看下面这个波形图。经过了被采集信号同步的使能信号，去控制被采集时钟的计步的使能信号，去控制被采集时钟的计数器是完全同步，去控制参考时钟的计数器时，会存在最多一个被采集周期的偏数器是完全同步，去控制参考时钟的计数器时，会存在最多一个被采集周期的偏差，可能计数多累加了一个，也可能计数少累加了一个，但是最多就是一个。而差，可能计数多累加了一个，也可能计数少累加了一个，但是最多就是一个。而这一个周期我们可以提高参考时钟频率或提高采集时间的长度来减小这点误差这一个周期我们可以提高参考时钟频率或提高采集时间的长度来减小这点误差的影响，达到可以忽略的要求。的影响，达到可以忽略的要求。
这里还要注意
这里还要注意clr（清零）这个信号，主要看看同步清零和异步清零。写法（清零）这个信号，主要看看同步清零和异步清零。写法以及这里需要用到异步清零。以及这里需要用到异步清零。
用
用verilog语言描述这部分。（分析对应）。语言描述这部分。（分析对应）。
module frc_cal( input ref_clk, input sig_clk, output reg [31:0] ref_c , output reg [31:0] sig_c , input clr, input cal_en ); reg cal_enr ; always @ (posedge sig_clk or posedge clr) if (clr) cal_enr &lt;= 0;else cal_enr &lt;= cal_en ; always @ (posedge ref_clk or posedge clr)if (clr)ref_c&lt;=0;else if (cal_enr)ref_c &lt;= ref_c + 1 ; always @ (posedge sig_clk or posedge clr)if (clr)sig_c&lt;=0;else if (cal_enr)sig_c &lt;= sig_c + 1 ; endmodule 之后我们做成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2340e810486a0246e538eb23de881b18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efc19162d38f6afefd44d9f3ff2b4708/" rel="bookmark">
			mqtt.fx软件使用教程(连接阿里云)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 根据mqtt标准协议连接云平台,这里以阿里的物联网平台为例。用mqtt.fx进行topic的订阅与发布
mqtt.fx下载地址 mqtt.fx最新版下载地址
还要用到技小新MQTT编程工具，这个是用来自动生成连接阿里云的信息，这些信息用来配置mqtt.fx软件，连入阿里云平台。
技小新MQTT编程工具下载链接
提取码：ypf5
mqtt.fx的使用 在使用mqtt.fx连入阿里云前，需要登陆阿里云平台，并登陆。
https://www.aliyun.com/
1、登录阿里云后，找到物联网平台 2、选择华东2，点击公共实例 3、点击产品，创建产品 4、填入产品名称，选择自定义品类。也可以选择官方的标准品类，后面选择直连设备，连网方式根据自己的需求进行选择，这里以WIFI为例，其他默认，点击确定 5、添加设备，在devicename填入自己想要的名字，备注想写就写，不写也行，这里devicename以project_test为例。最后点击查看设备信息 6、连接测试，找到设备，点击查看，一键复制设备证书。 7、将刚才复制的设备证书粘贴到技小新 MQTT编程工具（文章开始有下载链接）。SN/MAC输入设备的名称，点击生成基本信息。 8、打开mqtt.fx软件（下载链接文章开始有），显示界面如下： 9、点击设置 10、将对应的信息复制到mqtt.fx软件中，点击apply后，点击cancel。 11、点击connect，进行连接。 12、连接成功的话，这里会显示绿色。查看阿里云平台之前创建的产品，并刷新，显示在线。 13、接下来用mqtt.fx软件订阅topic。复制属性上报中的topic，将devicename改为之前命名的设备名称，或者直接复制mqtt单片机编程工具生成的信息，服务器回复中的内容，这俩个内容是一样的。 14、将上面复制的内容粘贴到mqtt.fx软件中后，点击Subscribe,订阅成功后，下面会有相应的内容。 15、给设备添加功能，点击产品，选择功能定义，点击编辑草稿，之后点击添加自定义功能，将信息填写完整，标识符之后在发布时会用到。这里以temp为例。填写完成后，点击确定。最后点击发布上线。 16、接下来使用mqtt.fx软件发布消息。复制mqtt单片机编程工具中属性上报topic,将其粘贴到mqtt.fx软件中，编辑内容，进行发布，其格式为固定的，格式如下： { "id": "dht11", "version": "0.0", "params" : { "temp": 23.66 , }, "method":"thing.event.property.post" } 其中，id为设备名称，version随便，temp是变量的名称，是之前创建变量的标识符，其他按格式来。
点击publish后，订阅端显示success,说明成功。
17、接下来在阿里云进行查看，温度显示23.66，说明我们所创建的设备是正确的，可以将产品接入这个平台，如用stm32接入阿里云平台，进行数据的上传，以及命令的下发。 至此就完成了利用mqtt.fx软件发布数据并订阅数据，在阿里云上查看具体的消息。
大家不要尝试连接我所创建的设备哦，你懂的！！！😂 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec3898af73efc58527522efd73d1f70/" rel="bookmark">
			GeoHash原理以及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Geohash 算法简介 Geohash 是一种地理编码，由 Gustavo Niemeyer 发明的。它是一种分级的数据结构，把空间划分为网格。Geohash 属于空间填充曲线中的 Z 阶曲线（Z-order curve）的实际应用。
Geohash 能够提供任意精度的分段级别。一般分级从 1-12 级。
我们可以利用 Geohash 的字符串长短来决定要划分区域的大小。这个对应关系可以参考上面表格里面 cell 的宽和高。一旦选定 cell 的宽和高，那么 Geohash 字符串的长度就确定下来了。这样我们就把地图分成了一个个的矩形区域了。
地图上虽然把区域划分好了，但是还有一个问题没有解决，那就是如何快速的查找一个点附近邻近的点和区域呢？
Geohash 有一个和 Z 阶曲线相关的性质，那就是一个点附近的地方(但不绝对) hash 字符串总是有公共前缀，并且公共前缀的长度越长，这两个点距离越近。
由于这个特性，Geohash 就常常被用来作为唯一标识符。用在数据库里面可用 Geohash 来表示一个点。Geohash 这个公共前缀的特性就可以用来快速的进行邻近点的搜索。越接近的点通常和目标点的 Geohash 字符串公共前缀越长（但是这不一定，也有特殊情况，下面举例会说明）
geohash各级别误差：
Geohash 也有几种编码形式，常见的有2种，base 32 和 base 36。
base32编码：是用0-9、b-z（去掉a, i, l, o）这32个字母进行编码。（一般选32）
base 36 的版本对大小写敏感，用了36个字符，“23456789bBCdDFgGhHjJKlLMnNPqQrRtTVWX”。
2.为什么要使用GeoHash 需求：地图app 界面上会显示出自己附近一个范围内可用的出租车或者共享单车。假设地图上会显示以自己为圆心，5公里为半径，这个范围内的车。如何实现呢？
查询数据库所有的车的位置信息，计算出与自己的距离，筛选出距离小于等于5公里的，然后再推数据界面显示，非常耗时。
如果采用geoHash，只用模糊查询自身点的geohash编码的前几位，来模糊查询附近的geohash点，再关联该点的出租车或共享单车。以存geohash的字段建立索引，加快查询效率。
3.Geohash 实际应用举例 地图中间有一个美罗城，假设需要查询距离美罗城最近的餐馆，该如何查询？
第一步我们需要把地图网格化，利用 geohash。通过查表，我们选取字符串长度为6的矩形来网格化这张地图。 经过查询，美罗城的经纬度是[31.1932993, 121.43960190000007]。 先处理纬度。地球的纬度区间是[-90,90]。把这个区间分为2部分，即[-90,0)，[0,90]。31.1932993位于(0,90]区间，即右区间，标记为1。然后继续把(0,90]区间二分，分为[0,45)，[45,90]，31.1932993位于[0,45)区间，即左区间，标记为0。一直划分下去。 再处理经度，一样的处理方式。地球经度区间是[-180,180]
纬度产生的二进制是101011000101110，经度产生的二进制是110101100101101，按照“偶数位放经度，奇数位放纬度”的规则，重新组合经度和纬度的二进制串，生成新的：111001100111100000110011110110，最后一步就是把这个最终的字符串转换成字符，对应需要查找 base-32 的表。11100 11001 11100 00011 00111 10110转换成十进制是 28 25 28 3 7 22，查表编码得到最终结果，wtw37q。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ec3898af73efc58527522efd73d1f70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0487c14d34de178e76e7b733c43193d/" rel="bookmark">
			重磅！阿里首推内部“SpringCloudAlibaba项目文档”这细节讲解，神了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Spring Cloud Alibaba为分布式应用开发提供了一站式解决方案。它包含开发分布式应用程序所需的所有组件，可以轻松地使用Spring Cloud开发应用程序。
使用Spring Cloud Alibaba，只需添加一些注解和少量配置，即可将Spring Cloud应用连接到Alibaba的分布式解决方案中，并使用Alibaba中间件构建分布式应用系统。
正是基于这些原因，我们有必要来学习SpringCloud Alibaba技术。那如何学习呢？市面上对于SpringCloud Alibaba讲解的资料零零碎碎，根本不成完整体系；去官网学习又无从下手，饱受打击，因此我将在这分享给大家！
Spring-Cloud-Alibaba详细笔记预览
详细内容 模块一 微服务架构设计： 本模块主要介绍了什么是微服务体系结构，以及微服务体系结构设计中的一些常见问题。
模块二 Nacos 服务治理：Nacos注册中心是整个微服务体系结构的核心。本文将详细介绍Nacos的安装、使用和集群构建过程，并以图文的形式介绍Nacos服务发现的基本原理。
模块三 系统保护：Sentinel是Alibaba提供的服务保护中间件。使用sentinel可以有效地防止分布式体系结构的系统崩溃。在此阶段，我们将解释Sentinel在限流、熔断、代码控制等方面的最佳实践。
模块四 高级特性：在这一阶段，我们将介绍SpringCloudAlibaba提供的许多高级功能。例如：配置中心、链路跟踪、性能监控、分布式事务、消息队列等。我们将从应用介绍到原理分析，逐一讲解这些技术。
模块五 微服务通信：当服务需要相互通信时，springcloudAlibaba支持RPC和restful解决方案。相应的产品是Dubbo和openfeign。在这个阶段，我将给出这些组件的最佳实践和原理分析。
模块六 微服务架构最佳实践：这阶段，我将拿出自己的私藏干货，为大家讲解微服务架构的综合应用和项目实践。在这里我们将接触到Seata分布式事务架构、多级缓存设计、老项目升级策略！
本资料整理自网络，只用于学习和研究，禁止他用
资料获取
1. 识别并关注下方公众号「java版web项目」；
2. 在下面公众号后台回复关键字「阿里巴巴」即可下载。
扫描关注，回复"阿里巴巴"即可下载
最后再送上一套字节跳动的 《设计模式宝典》
这份资料非常全面且详细，覆盖了 设计模式 基础学习的方方面面，非常适合初学者入门！
资料也按目录进行编排，每一章下面都有更具体的内容：
有趣的插图：
资料获取
1. 识别并关注下方公众号「程序员闪充宝」；
2. 在下面公众号后台回复关键字「设计模式」即可下载。
扫描关注，回复"设计模式"即可下载
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c751fab19ccf288b5eebd7687c844ecc/" rel="bookmark">
			5.使用Kettle的注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 1.文件路径问题1.1绝对路径1.2相对路径 2.操作相关2.1操作快捷键 3.使用过程中的bug 1.文件路径问题 在作业中可以添加转换，也可以添加作业；添加的时候就存在绝对路径与相对路径的问题。
1.1绝对路径 当作业与需要添加的作业或转化不在同一文件夹下的时候，添加的时候使用的绝对路径。如：
而使用绝对路径的时候，当文件转移至其它地方或者修改文件夹名称时需要修改路径，不方便。
1.2相对路径 当作业与需要添加的作业或者转化在同一文件夹下的时候，添加的时候使用的是相对路径。
如：
2.操作相关 2.1操作快捷键 1.两个图标快速相连，按住shift，然后使用鼠标相连。 3.使用过程中的bug ORA-00933: SQL 命令未正确结束
在使用表输入的时候，写了一句sql语句，然后在数据库中直接执行没有问题在kettle中执行报错，是因为该sql语句最后加了一个分号，将分号去除后，问题解决 ORA-00942: 表或视图不存在
在查询oracle中的某张视图时，直接输入视图名称报错，后来使用了模式（schema）.视图名称，问题解决。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/643ef895e07a40342a37a4b5f6daa55e/" rel="bookmark">
			基于FFTW3.3.9的FFT标准测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于FFTW3.3.9的FFT标准测试 1 环境准备1.1 确保g++可用1.2 下载 FFTW 3.3.9 源码包1.3 解压缩 fftw-3.3.9 源码包 2 编译安装3 准备代码以及编译4 运行测试 1 环境准备 1.1 确保g++可用 本次编译是基于 GNU C++ 环境的，因此务必确定g++编译器可用，使用如下命令验证：
g++ --version 出现类似如下输出则表明编译器可用：
1.2 下载 FFTW 3.3.9 源码包 到FFTW官网(http://www.fftw.org/download.html)下载活着直接使用命令下载：
wget http://www.fftw.org/fftw-3.3.9.tar.gz 1.3 解压缩 fftw-3.3.9 源码包 直接使用 Centos 下的解压缩命令即可：
tar -xvf fftw-3.3.9.tar.gz 解压缩后进入hpl-2.3目录
cd fftw-3.3.9 注意：此目录为本文所有操作的主目录，若下文提到主目录，皆表示此处。 2 编译安装 ./configure --enable-threads make sudo make install 3 准备代码以及编译 FFT测试的代码如下所示：
/* * @Author: Bo Cai * @Mail: caibo0520@qq.com * @Date: 2021-04-01 20:35:07 * @LastEditors: Bo Cai * @LastEditTime: 2021-04-01 20:44:27 */ #include &lt;fftw3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/643ef895e07a40342a37a4b5f6daa55e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b63ad9f549eaf7f2f98383c46b121d4/" rel="bookmark">
			CentOS下IOZone编译安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CentOS下IOZone编译安装 1 编译环境准备1.1 确认 gcc 编译器正常1.2 下载与解压缩 iozone3_490 源码包 2 编译2.1 添加环境变量（可选） 1 编译环境准备 1.1 确认 gcc 编译器正常 IOZone 源码包提供的 makefile 是使用 gcc 编译器的，因此务必确认系统中可正常使用 gcc ：
gcc --version 如图所示，输出类似结果即代表 gcc 编译器可正常使用。
1.2 下载与解压缩 iozone3_490 源码包 直接使用wget命令下载即可：
wget http://www.iozone.org/src/current/iozone3_490.tar 然后直接使tar命令解压缩即可：
tar -xvf iozone3_490.tar 2 编译 进入 iozone3_490 编译目录：
cd iozone3_490/src/current 编译安装：
make linux 验证安装：
./iozone -v 如图所示，输出结果即表示安装成功。
2.1 添加环境变量（可选） 将 iozone 二进制文件添加至系统的PATH环境遍历即可：
vim ~/.bashrc 在文件尾添加以下内容：
export PATH=$PATH:/path/to/iozone # 请替换为您的iozone二进制文件所在目录 export PATH=$PATH:/path/to/iozone # 请替换为您的iozone二进制文件所在目录 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fd38943cb110c8b6b3a798427274d15/" rel="bookmark">
			linux脚本 文件为空,linux – 由cron运行时,shell脚本中使用的环境变量在日志文件中显示为空白...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原谅我的无知,但我对
shell脚本和在
Linux中使用环境变量有些新意.
我有一个执行MySQL数据库备份的脚本.我在脚本中有以下几行用于记录数据库的成功转储：
output=`date; echo "Database export successful from $ENV_HOSTNAME to $BACKUP_HOSTNAME"`
echo $output &gt;&gt; /var/log/errorLog
我在/ etc / profile中定义了变量(ENV_HOSTNAME和BACKUP_HOSTNAME),如下所示：
export ENV_HOSTNAME="env1.somename.com"
export BACKUP_HOSTNAME="env2.somename.com"
当我调用printenv时,我可以看到列出的这些变量,并且当我运行此脚本(以root身份)时,变量值正确显示在日志文件中.但是,当我将此脚本设置为使用cron运行时,变量值不会出现在日志文件中.我知道脚本运行是因为我可以看到日期和字符串的其余部分,但变量是空白的：
Fri Nov 6 22:31:05 EST 2009 Database export successful from to
我确定我在这里遗漏了一些简单的东西,所以请提前感谢您的帮助.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f224493ee18250234a13c7139ff727f/" rel="bookmark">
			数学建模系列：历年优秀论文&#43;入门&#43;进阶&#43;国赛&#43;美赛&#43;其他
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数模系列：历年优秀论文+入门+进阶+国赛+美赛+其他（待更新中） 数模成绩为国二\省一\o奖\H奖，在博客做一个总结。先放国赛美赛的历年优秀论文，资料来源微信公众号数学模型。（目前完成部分：入门+进阶+美赛，接下来随缘更新国赛篇）
国赛历年优秀论文（提取码: nae6）
美赛历年优秀论文（提取码: vuyq）
文章目录 数模系列：历年优秀论文+入门+进阶+国赛+美赛+其他（待更新中）一、数模入门1.数模是什么2.入门级知识储备 二、进阶1.分析2.通用建模方法3.例子 三、国赛1.团队赛前准备2.题目分析解读3.优秀模型分析 四、美赛1.团队赛前准备2.题目分析解读第一问：第二问：第三问：3.优秀模型分析 五、其他总结 一、数模入门 本章以下内容主要面向零基础和有一定基础的数模同学
1.数模是什么 数学建模：数模是用对实际问题做适当简化抽象，用数学方法模拟、求解、分析。
求解一道数模题时，一般的，我们需要提炼题目的关键词和隐含信息，查阅资料加深对于题目背景和题目问题的认识，量化条件，抽象问题，求解分析，验证讨论。在这个过程中，建模人的分析、抽象、推导、创新等多种能力都发挥各自的作用。而对于入门者，抽象量化能力的强化是最迫切的需求。
抽象量化，狭义上指的是：
1.方程、不等式、图、向量机、决策树、自动机等有解空间或者多个离散解的数学方式表达问题的求解和条件；
2.用变量、向量、含有信息的矩阵、状态、节点、集合、元胞、坐标、进过函数映射的y等方法抽象欲求解和欲表达的量；
3.用数学化或者符合数学思想的方法剥离题目来构建模型。
抽象量化的一般方法是结合理解让需要被抽象的对象和已知的数学对象“对号入座”。首先去捕捉对象的特点、条件、约束，尽量概括成具有数学性的话或者符号公式，接着列举符合的数学对象，根据提炼的东西来筛选和修改已选数学对象。
举个不恰当的例子，如何用抽象量化的方法描述“栈”？首先分析栈的特点：1.有存储元素的能力2.读出时优先读出后写入的元素。
根据第一点，我们想到图、向量、树、矩阵、集合是符合的。接着我们提炼信息：读出元素优先最新写入的元素。从这一点我们抓到关键变量“写入时间的先后”，令元素在数据结构中排列是遵循写入时间的先后的正序，并且在写操作时我们优先修改最后一位元素，这种特征下我们可以排除集合和矩阵，考虑用图的节点抽象元素，让单向图中的节点按照写入顺序生成子节点来写入新元素；当然按照写入顺序排序的向量也是同理。
概括的说：
一、变量设置方面：决策（是否xxx）往往可以抽象为布尔型的变量，数量和价格、距离等可以计算对象往往可以抽象为方程或者不等式中的未知量x，而时间、总价格、效率、总距离、统计量（均值方差协方差）往往作为min或者max的修饰对象，需要用其他参数和变量写成函数格式。
二、模型搭建方面：选址、传播、设置站点或岗哨、建设xx服务类设施的题目优先考虑网络图，需要方案的问题可以在目标规划求解的基础上构建自己的评价指标，涉及服务和被服务关系时排队论往往不可或缺、预测方法固定的有回归、灰度、马尔科夫、时间序列。在有数据、需要探究其关系或者做出决策时，回归和决策树、贝叶斯概率、聚类是主要手段。在传统的模型不适用的情况下，可以查询相关文章寻找特殊的量化公式或者模型，我们只需要抓住一些关键信息量化新的指标来优化和完善模型，就能起到事半功倍的效果。
2.入门级知识储备 常用的资源：
走近数学——数学建模篇（全国大学生数学建模竞赛组织委员会）
《数学建模》（姜启源）（提取码:cxar ）
MathorCup高校数学建模挑战赛
深圳杯数模挑战赛
常用的模型：
规划类：线性规划、非线性规划、动态规划、多目标优化模型 模拟类：线性回归、多元线性回归、BOX-COX变换、残差分析 预测类：时间序列、灰度、logistics、SEIR、微分差分方程、马尔科夫链 权重确定类：AHP、主成分分析、因子分析法、熵权法、模糊评价法 其他常用类：图、排队论、社会力模型、决策树、博弈论 常用的方法：
蒙特卡洛法、Dijkstra、Floyd、穷举法、元胞自动机 常用的学习思路：
先学习模型的公式，再了解模型的使用情境、可应用的问题类型，最后将公式推 导和原理推导手动完成一遍。 常见的子问题：
在各类数模题中往往有与如下问题有相似的类型的子问题，如果能对下列问题有一套甚至几套建模方法，个人认为已经可以解决70%+的数模问题。
1.已知x1,x2,x3,...，单位盈利为w1,w2,w3,...，多个目的地与起点的距离是d1,d2,d3,...，对应的单位距离的运费为z1,z2,z3,...，试求一个盈利最大运费最小的方案。 2.已知路口的车流流入量lamdba，红绿灯n秒且忽略黄灯，在车流量稳定的情况下试分析车辆在路口的平均等待时间。 3.结合第a学期b门课程的成绩，评估某年级某院某班级的每个学生的学习能力。 4.结合历年来五一长假期间西安机场的航班情况，试预测今年五一期间机场在何时达到客流量的高峰，客流量大致为多少。 5.TSP问题。 6.试画出各种数据已知的气球在穿越n层风速为vi（i=1,2,3,...,n）的气流层时的轨迹。 7.试给出方案确定学校应该新增座椅的数量和位置，学校地形、椅子成本已知。 8.商场拟定根据历年来顾客的购买数据进行分析，调整促销商品的种类和价格，试给出方案。 9.请根据雪崩的物理原理建立模型模拟雪崩随时间的变化。 10.根据每日治愈人数、感染人数以及其他数据建立传染病模型。 二、进阶 注：由于本人是一个建模水平一般但是想法很多的人，因此以下经验可能更适合同类型的同学作参考。
许多建模同学的问题可能并不是对上述问题没有解决手段，而是模型拿出来千篇一律、没有亮点，或者对自己好的思路不知道怎么构建、实现。我认为这是处于一个厚积薄发的瓶颈期，如果能找到克服问题的方法，建模能力就会更上层楼、登堂入室（自己深有体会）。那么进阶中需要的能力是什么呢？如何强化呢？
1.分析 结合不同情况，可以分为三类。
一类同学是做题总是拿老一套模型；或者做题的时候脑子就想不到其他模型也适用。对于这类同学，我认为主要问题是储备的模型并不牢靠，对模型比较生疏，不太会使用也不清楚它适用于哪些问题。建议是加强论文阅读或者博客阅读，可以查阅模型相关的文章，引申到模型适用于哪些情景和问题。同时不要吝惜练习，在训练中大胆地使用这些要学习的模型，与其他同学交流该模型的优劣、用途。
二类同学是模型拿得出，但是缺乏亮点，看上去食之无味弃之可惜。对于这类同学，他\她可能已经在模型的运用和练习上打下了一定的底子，不过欠缺一些创造力和想象力。而我认为，想象力和创造力抽象后是相似+随机+推导，相似是指创新的想法来源于已知的知识体系但是又不完全等同于已知的知识，在思考的过程中大脑有意识或者无意识地捕捉到了解决该问题或者构建该模型的过程与曾经的xxx有相似之处，可以类比或者在此之上发散；随机是指在整顿思路得到创新点和梁点的时候，优化创新的方向是随机的、未知的，这种随机与做题的经验和感觉有很大的关系；推导是指把成型的思路量化成公式、根据思路优化改造模型的能力。对于相似和推导能力，我们可以通过对各种模型的理论推导来强化，对于随机能力，积累做题经验，阅读有想法的文章，及时总结，都不失为优化的方法。
三类同学的特征是状态不稳定，有时候自己思路泉涌，模型有自己的东西；有时候觉得自己脑子空空，面对问题只能挤出来一两个老模型应付应付；有的时候自己有了一些想法，但是落到模型上不知道从何下手。这种情况比较复杂，也许你是想法很多但是基础薄弱的小白，也许你是积累颇丰无处发力的建模人。首先应该认真的审视自己的真实水平，确定自己是积累不足还是想法不足，审视的方法因人而异，不过多赘述。积累不足去补基础，认真学习；想法不足或者实现想法的能力不强的同学，你不稳定的发挥说明你的理论基础和储备基础是在线的，可能是缺乏系统的训练总结限制了你的稳定性。这种情况下优秀的榜样可以起到很好的引领作用，推荐阅读优秀国一论文和o奖论文，在那些比较有新意的模型或者量化点上多推敲琢磨一下，总结心得即可
（在国赛和美赛篇我会列举一些个人的推荐，同时展示个人总结和心得）。
2.通用建模方法 整理思路(总理)➡剥茧抽丝(挖掘)➡师夷长技(吸收)➡优化改造(优化)
首先快速浏览问题梗概，分析问题需求(把问题具体化)，抓取关键词或者关键信息，有时候题目动则在一个很大的范围内要求你规划什么什么方案，这种情况下结合信息简化问题就显得很重要。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f224493ee18250234a13c7139ff727f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9de53009b4cb240f59c6d76269d468c7/" rel="bookmark">
			springboot2中jackson设置的LocalDateTime全局序列化不生效的问题存在情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如，你可能设置了如下的配置，获取其他的方式 @Configuration public class WebMvcConfig { @Bean public Converter&lt;String, LocalDate&gt; localDateConverter() { return new Converter&lt;String, LocalDate&gt;() { @Override public LocalDate convert(String source) { return DateUtil.parseDate(source); } }; } @Bean public Converter&lt;String, LocalDateTime&gt; localDateTimeConverter() { return new Converter&lt;String, LocalDateTime&gt;() { @Override public LocalDateTime convert(String source) { return DateUtil.parseDateTime(source); } }; } } 3.反正就是不想使用@JsonFormat这个注解在字段上
4.究其原因，其实在maven中有了fastJson的引入之后，fastJson会优先于jackson加载(为啥亲儿子还没干儿子有优先权呢)，既然找到原因所在了，那么我们只需要在配置中将fastjson移除掉，然后再重新配置下jackson的配置就可以(移除fastjson的消息转换器不影响你在其他地方使用fastjson，因为默认的还是Jackson)
@Configuration public class WebMvcConfig extends WebMvcConfigurationSupport { @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { // 如果存在fastJson的转换器，将其移除 converters.removeIf(httpMessageConverter -&gt; httpMessageConverter instanceof FastJsonHttpMessageConverter); // 需要重新加入jackson的转换器，该处的objectMapper已经在配置中注册了 converters.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9de53009b4cb240f59c6d76269d468c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfaf98d5370f244c3190e57f30a3f361/" rel="bookmark">
			设计模式07 之Bridge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计模式07 之Bridge 1. “单一职责” 模式： .在软件组件的设计中，如果责任划分的不清晰，使用继承得到的结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。典型模式 Decorator（装饰模式）Bridge（桥模式） 2. Bridge 桥模式 1. 动机（Motivation） 由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个纬度的变化。如何应对这种“多维度的变化”?如何利用面向对象技术来使得类型可以轻松地沿着两个乃至多个方向变化，而不引入额外的复杂度? 2. 模式定义 将抽象部分(业务功能)与实现部分(平台实现)分离，使它们都可以独立地变化。
3. 结构（Structure） 4. 要点总结 Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。Bridge模式有时候类似于多继手素心福赘娟莆植花鞍罢。Bridge模式是比多继承方案更好的解决方法。Bridge模式的应用一般在“两个非常强的变化维度”…，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。 3. Code Bridge1.cpp class Messager{ public: virtual void Login(string username, string password)=0; virtual void SendMessage(string message)=0; virtual void SendPicture(Image image)=0; virtual void PlaySound()=0; virtual void DrawShape()=0; virtual void WriteText()=0; virtual void Connect()=0; virtual ~Messager(){} }; //平台实现 class PCMessagerBase : public Messager{ public: virtual void PlaySound(){ //********** } virtual void DrawShape(){ //********** } virtual void WriteText(){ //********** } virtual void Connect(){ //********** } }; class MobileMessagerBase : public Messager{ public: virtual void PlaySound(){ //========== } virtual void DrawShape(){ //========== } virtual void WriteText(){ //========== } virtual void Connect(){ //========== } }; //业务抽象 class PCMessagerLite : public PCMessagerBase { public: virtual void Login(string username, string password){ PCMessagerBase::Connect(); //.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfaf98d5370f244c3190e57f30a3f361/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7a57a57b20844eeaed76255a61c087d/" rel="bookmark">
			linux显示查看时间为中文,Archlinux下的时间时区设置 leafpad中文显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载于
http://blog.samsonis.me/2009/02/archlinux下的时间时区设置/
原来Archlinux下仅在/etc/rc.conf里把TIMEZONE设成”Asia/Shanghai”是不够的，还要在/etc/localtime做个软链接给具体的zoneinfo：
$ sudo ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
这个时候时区应该算是正确设置好了，把硬件时钟再同步回系统来，
$ sudo hwclock --hctosys
这个时候时间又不对了，因为之前我是人为滞后了8小时(当时是负负得正，时间倒正好是正确的，而且平时也不会去关心这个，估计Sunng不说我是不会发现的了:-))，但是现在时区对了，所以现在时间应该正好晚了8小时。
接下来有两种方法，一种是直接人为改到正确的时间，还有一种是用NTP(Network Time Protocol)进行同步，本质上差不多，但是由于之前人为改吃了苦头，所以这回用另一种方法：)
参考，装了个openNTPD，
$ sudo pacman -S openntpd
配置文件看了下，基本都不用修改，直接起服务：
$ sudo /etc/rc.d/openntpd start
确保网络通畅，等一会，系统时间应该就会更新了，确实蛮方便
最后在rc.conf的DAEMONS里面加上@openntpd，确保开机后台运行
Archlinux下leafpad打开txt中文乱码
在windows下的txt文件打开会遇到乱码，这是由于编码不同的
喜欢简单的我安装了leafpad文字编辑软件，由于是英文环境，没改成中文环境，打开txt就遇到了中文乱码(网上有人说中文环境的话打开是不会乱码的……没试过)
乱码解决方法：
#leafpad /usr/share/applications/leafpad.desktop
找到 exec=leafpad %f 这一行
改为 exec=leafpad --codeset=gbk %f
保存就OK了……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9cdaba4c63a6bf4a40e09acec0d2b5/" rel="bookmark">
			介绍metamask添加bsc的配置参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、关于metamask钱包的安装、创建、使用详见以下链接
https://blog.csdn.net/weixin_39842528/article/details/115175555?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control
https://blog.csdn.net/inthat/article/details/113844933
2、本文 主要介绍 钱包安装好之后的BSC配置 毕竟涉及到链上转币、提币等资金安全问题 下面引用官方文档
官方doc连接：https://docs.binance.org/smart-chain/developer/rpc.html
网络名称：自定义 BSC币安智能链
RPC URL：参考 推荐的几个地址
链ID ：56 符号：BNB
区块链URL：https : //bscscan.com
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/365/">«</a>
	<span class="pagination__item pagination__item--current">366/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/367/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>