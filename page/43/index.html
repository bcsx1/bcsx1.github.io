<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b1c551b90583d251f0bd9c461b46c21/" rel="bookmark">
			Date()函数小结 时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		let y = new Date().getFullYear() let m = new Date().getMonth()+1&lt;10?'0'+(new Date().getMonth()+1):(new Date().getMonth()+1) let d = new Date().getDate()&lt;10?'0'+new Date().getDate():new Date().getDate() let hh = new Date().getHours()&lt;10?'0'+new Date().getHours():new Date().getHours(); let mm = new Date().getMinutes()&lt;10?'0'+new Date().getMinutes():new Date().getMinutes() let ss = new Date().getSeconds()&lt;10?'0'+new Date().getSeconds():new Date().getSeconds() this.endDate = y +'-' + m + '-' + d + ' ' + hh + ':' + mm + ':' + ss this.endDate = this.endDate.replace(/\s+/g, 'T')+'+08:00' // 2020-08-14T11:33:26-07:00 var str = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b1c551b90583d251f0bd9c461b46c21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8cc456da2d47831480e514e9b513bd9/" rel="bookmark">
			汽车清除积碳和清洗节气门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汽车清除积碳和清洗节气门 汽车需要清除积碳的部位检查积碳方法： 清除积碳和清洗节气门风险：燃油宝 第一次清除积碳1万公里2万公里3万公里--5万公里6万公里以上 汽车需要清除积碳的部位 节气门喷油嘴进气道燃烧室 检查积碳方法： 建议每3到5万公里用内窥镜检查一次。
拆下一个火花塞；用内窥镜放到汽缸内部；观察活塞的顶部。 如果积碳堆积不多，可以看到活塞自身的颜色，就暂时可以不清洗。
如果积碳堆积很多，（下图）活塞周围都是黑色，而且有黑色碳颗粒附着，建议立刻清洗。
清除积碳和清洗节气门 90%聚醚胺除碳剂，能清除积炭和清洗节气门。
风险： 如果一次加太多，有可能造成积炭大块脱落，卡在缸壁上，造成拉缸。
燃油宝 燃油宝是助燃剂+低浓度聚醚胺除碳剂，不能清除积碳，但是能起到一点预防积碳生成的作用。
第一次清除积碳 汽车厂商建议是：每5000公里使用一次积碳清洁剂。
1万公里 低于1万公里，没有清除积碳的必要。
1万公里时，油箱加满油后，在油箱中加半瓶90%聚醚胺除碳剂，油箱跑完即可；
跑高速清除效果更佳。
2万公里 2万公里时，第一次清除积碳。
油箱加满油后，在油箱中加1瓶90%聚醚胺除碳剂；油箱跑完即可完成清除积碳``清洗节气门。
3万公里–5万公里 3万公里以后，第一次清除积碳。
连续使用2次油箱加满后添加1瓶90%聚醚胺除碳剂；2箱油跑完后即可有效清除积碳和清洗节气门。
6万公里以上 六万公里以后，第一次清除积碳。
连续使用4次油箱加满后添加1瓶90%聚醚胺除碳剂；4箱油跑完后即可有效清除积碳和清洗节气门。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d4a4de58903e03de4c8dbe8d489051/" rel="bookmark">
			上传数据，轻松分析 | 云上转录组标准分析流程使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工具地址 Galaxy中国（UseGalaxy.cn）&gt; RNA ANALYSIS TOOLS &gt; Standard Analysis &gt; 有参转录组标准分析
功能描述 本工具用于转录组二代测序数据的标准分析，可生成表达量矩阵和测序数据质控结果。
这是一套非常流行的转录组定量分析流程，即 Hisat2 + Stringtie 经典组合，其步骤为：
hisat2，将经过质控得到的 Clean data，比对到参考基因组上；
samblaster，去除PCR或光学重复;
samtools，去除不合格的比对序列，将 SAM 文件转换成 BAM 文件；
stringtie，结合 hisat2 得到的比对文件（BAM）和基因组注释文件（GTF），进行定量分析，得到每个样本的表达量文件（FPKM / TPM）；
prepDE.py，将 FPTM / TPM 转化为 Counts 计数的表达量矩阵，用于后续差异基因等分析。
TIPs：
原始数据处理，需要大量计算资源（按需付费），请联系管理员配置（ 微信：ilovebtit ）。
所有样本并行处理，运算时间跟数据量最大的那个样本有关，提交任务后请耐心等待。
操作步骤 1. 创建一个新的历史面板 在网站右侧的历史面板上方，点击 + 号，创建一个新的历史面板，可以为新面板取一个名字，如：Three Yeast Test。
2. 数据准备 2.1 共享数据的使用方法 如果使用测试数据，可以在网站上方菜单栏，找到：
数据共享 &gt; 数据库 &gt; RNA-seq &gt; Three Yeast
可以看到6个Fastq文件，是3个酵母样本的双端测序数据（抽样数据用于工具测试） 。
全选6个Fastq文件。
点击上方 Add to History 按钮，点击 as Datasets，将数据添加到刚才新建的历史面板。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7d4a4de58903e03de4c8dbe8d489051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab8fdccb746b8fc860a02a92bf48197/" rel="bookmark">
			vite&#43;vue3&#43;ts&#43;eslint&#43;prettier&#43;stylelint&#43;husky&#43;jest搭建项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. vite1.02. vite2.03. 引入 typescript配置 jsx 支持 4. 加入 vue-router、pinia，并实现 pinia 持久化5. 按需引入 vant、移动端适配 rem5. （推荐）另一种方式按需引入 vant, 自动引入 vue、vue-router、hooks5.1 按需引入组件5.2 自动引入 vue/vue-router/hooks 等 6. 配置 eslint、prettier7. 配置 stylelint8. 引入 jest 测试9. husky 和 lint-staged 构建代码工作流10. vscode 保存自动格式化11. 生成自定义 changelog 更多内容可参考我的博客
1. vite1.0 pnpm i -g create-vite-app create-vite-app vite-demo 2. vite2.0 pnpm init @vitejs/app 3. 引入 typescript pnpm i typescript -D 在 项目根目录下创建 typescript 的配置文件 tsconfig.json
{ "compilerOptions": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ab8fdccb746b8fc860a02a92bf48197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0297e9f0885df1e8a905897f07856b37/" rel="bookmark">
			求解相交列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环
package com.lf.java.algorithm; public class IntersectionOfTwoLinkedLists { static class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } /** * 有个难理解的点是为什么要 * @param headA * @param headB * @return */ public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode pA = headA; ListNode pB = headB; // 遍历两个链表，直到两个指针相等或都达到链表末尾 while (pA !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0297e9f0885df1e8a905897f07856b37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824b4e3ab3bb2682ec82050854f7b759/" rel="bookmark">
			冠赢互娱基于 OpenKrusieGame 实现游戏云原生架构升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于冠赢互娱 冠赢互娱是一家集手游、网游、VR 游戏等研发、发行于一体的游戏公司，旗下官方正版授权的传奇类手游——《仙境传奇》系列深受广大玩家们的喜爱。基于多年 MMORPG 类型游戏的自研与运营经验，冠赢互娱正式推出了 2D MMO 游戏开发引擎 Thousand，并成功应用至近期上线的《仙境传奇-梦回零三》 手游。其背后采用的云原生架构大幅度提升了游戏开服、更新等运维效率，同时降低了服务器的资源成本，并为后续开发更优秀的产品、加快游戏生态成型提供扎实基奠。
MMORPG 手游《仙境传奇-梦回零三》
启用云原生架构的初衷 在 Thousand 引擎立项之初，研发团队基于传统区服类游戏的特点，决定采用云原生架构。主要的考虑如下：
1. 区服之间具有强隔离属性，应尽量避免资源抢占。过往运营游戏时会出现同台宿主机上不同区之间相互资源干扰的情况，加大了受影响的玩家数量。而利用容器技术可以实现精细化的资源控制，避免区服之间相互干扰，能够有效降低故障影响面。
2. 通过声明式的方式进行游戏服管理带来了效率优势。从过去运维机器、执行一系列脚本演化为以服务为对象、批量且自动化管理的方式，不仅可大幅度提升开服效率，同时也能降低游戏维护时的出错概率。
3. 需要更加精细化的故障定位、及业务快速恢复的能力。区服共享计算节点，当故障发生时，无法及时定位故障根因源自区服 A、区服 B、还是宿主机，且当机器故障时，业务迁移效率十分低下。通过云原生架构，基础设施资源与业务一定程度的解耦带来了业务故障快速定位的能力，并且容器轻量且环境一致性的特点带来了高效的业务恢复能力，问题定位及恢复的效率大幅度提升。
4. 云原生生态日益茁壮，通过云原生技术不仅可高度集成计算、网络、存储等基础设施资源、而且可以非常轻便地利用上可观测、调度、应用交付等能力。
游戏服落地 Kubernetes 的挑战 然而，云原生化绕不开的容器编排标准 Kubernetes 对游戏的支持力度十分有限，冠赢传奇类游戏在落地 Kubernetes 的过程中也遇到了众多挑战：
众多区服，如何在 Kubernetes 上进行管理
1. 每个区服需要单独暴露公网地址，玩家选择服务器后可直连对应区服。额外进行接入层网络管理无疑增加了区服批量管理时的运维成本；同时如果选择单个区服 pod 绑定 EIP 的模式又会消耗大量的 EIP 资源，造成经济成本浪费。
2. 单个区服是由多个服务共同组成，容器化后以一种“富容器”的形态存在。原生 Kubernetes 对业务状态管理停留在容器层面，无法精细化感知容器中特定进程状态，造成故障或异常难以定位处理；而将服务拆分，单独部署增加了架构复杂性、改造难度将急剧上升。
3. 一个完整的游戏服由引擎侧与脚本侧组成，游戏服引擎支持热更脚本，避免频繁停服造成玩家流失。研发团队设计了多种游戏服落地 Kubernetes 后的热更方案，包括从公共服务器拉取最新热更文件、或通过云储存动态挂载热更文件。但无论哪种方式，都会遇到各式问题，包括：
1）不支持版本化管理热更文件，更新频繁后实际存在的众多版本无法与文件形成对应关系，造成更新失败后回滚复杂；
2）更新状态难以定位。即使对容器中的文件进行了更新替换，但执行重载命令时难以确定当前热更文件是否已经挂载完毕，这种更新成功与否的状态维护需要交给运维者额外管理，也一定程度上提高了运维复杂度；
3）在容器异常时，pod 重建拉起旧版本的镜像，热更文件并未能持续化保留；
4）更新速度始终不尽人意。
OpenKruiseGame 助力游戏服云原生化落地 冠赢利用社区的开源项目 OpenKruiseGame 解决了上述问题，实现了 2D MMO 游戏开发引擎 Thousand 在 Kubernetes 的平滑落地。OpenKruiseGame（简称 OKG），是 CNCF 孵化项目 OpenKruise 在游戏领域的子项目，其专门为游戏打造，协助游戏开发者实现更敏捷的游戏弹性架构、统一标准的运维动作、多云一致性交付、建立游戏自运维平台等能力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/824b4e3ab3bb2682ec82050854f7b759/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/279058587a1795f915e89e43b2427ae3/" rel="bookmark">
			使用docker部署onlyoffice插件步骤及踩坑问题（win10/linux）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 最近公司系统插件从金格换成了OnlyOffice，需要重新安装部署，做个记录。
安装onlyoffice有两种方式，第一种是独立安装nginx、epel、PostgreSQL、RabbitMQ等依赖项，再安装OnlyOffice文档插件。此种方式较为繁琐，暂不赘述，附同事分享的文档在资源内。
第二种为docker安装部署，省心方便，操作快捷。（注：部署docker需要重启计算机或服务器，谨慎选择）
这里对第二种方式进行介绍。
最开始尝试在应用服务器：Windows Server2019上安装，由于安装环境较为复杂，为三层嵌套虚拟机，且客户不愿为该虚拟机开启嵌套虚拟化，Docker Desktop无法顺利启动，故放弃。
最后在win10和Anolis Os8.6QU1（Linux）系统中安装部署成功。
注：必须保证应用所在服务器和onlyoffice插件所在服务器的网络互相能够ping通。
二、Win10安装 获取Docker Desktop Installer.exe。
下载地址：
点击直接下载 Docker Desktop
Installer.exe，下载后安全扫描
双击运行，安装docker，略慢，需等待一会儿。完成后关闭安装界面，打开docker。不登录，直接进入。
修改存储路径。
打开命令提示符，输入docker，查看是否安装成功。
在命令提示符内使用docker拉取OnlyOffice镜像（7.2版本之前的），等待下载完成。
docker pull onlyoffice/documentserver:7.1.1 进入docker，查看镜像。
启动OnlyOffice镜像，配置80端口的映射端口及文件夹路径。这里映射端口设置为了9696，可根据实际情况配置。
host路径容器路径/app/onlyoffice/DocumentServer/logs/var/log/onlyoffice/app/onlyoffice/DocumentServer/sdkjs-plugins/var/www/onlyoffice/documentserver/sdkjs-plugins/plugin/app/onlyoffice/DocumentServer/data/var/www/onlyoffice/Data查看容器，圈出部分为容器id。
安装测试实例（如有需要）：
docker exec 容器id（替换成自己的） sudo supervisorctl start ds:example 根据自己的应用服务配置接口。笔者所用应用需配置.properties文件。
使用互通网络的服务器访问插件所在服务器ip:端口/，查看是否启动成功。
查看样例是否可以正常使用。
从应用跳转。
三、Anolis Os8.6QU1安装（CentOS可用） 直接拉取Docker。
yum -y install docker 启动docker
service docker start 查看docker启动状态
service docker status 如图所示状态，表示启动成功。
拉取OnlyOffice镜像（7.2版本之前的），等待下载完成。
docker pull onlyoffice/documentserver:7.1.1 启动容器，配置映射端口及路径（同windows）
sudo docker run -i -t -d -p 9696:80 --privileged=true \ -v /app/onlyoffice/DocumentServer/logs:/var/log/onlyoffice \ -v /app/onlyoffice/DocumentServer/sdkjs-	plugins:/var/www/onlyoffice/documentserver/sdkjs-plugins/plugin \ -v /app/onlyoffice/DocumentServer/data:/var/www/onlyoffice/Data onlyoffice/documentserver:7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/279058587a1795f915e89e43b2427ae3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/705dc1ed75aa2470e348df2261b77125/" rel="bookmark">
			Qt5 CMake环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Qt5 CMake环境配置 设置Qt路径 有两种方法
Qt5_DIR，使用这个变量，必须把路径设置到Qt5Config.cmake所在文件夹，也就是安装目录下的lib/cmake/Qt5CMAKE_PREFIX_PATH，只需要设置到安装目录就可以了，这个目录就是bin、lib等文件夹所在目录 # set(CMAKE_PREFIX_PATH "E:\\ProgramFiles\\Qt\\5.15.2\\msvc2019_64;${CMAKE_PREFIX_PATH}") # set(Qt5_DIR "D:\\ProgramFiles\\Qt\\5.15.2\\5.15\\msvc_2015_64\\lib\\cmake\\Qt5") set(CMAKE_PREFIX_PATH "D:\\ProgramFiles\\Qt\\5.15.2\\5.15\\msvc_2015_64;${CMAKE_PREFIX_PATH}") 启用代码生成 用于处理信号槽代码生成、资源文件生成、UI文件生成
set(CMAKE_AUTOMOC ON) set(CMAKE_AUTORCC ON) set(CMAKE_AUTOUIC ON) 查找需要的库 LinguistTools是为了处理ts文件用的，无需链接
find_package(Qt5 COMPONENTS Core Widgets LinguistTools REQUIRED) `` 链接的时候可以直接使用`Qt::`作为前缀，不需要`Qt5::` ```cmake target_link_libraries(${PROJECT_NAME} PUBLIC Qt::Core Qt::Widgets) 添加翻译文件 使用qt5_create_translation
从当前目录中的源文件中递归查找Qt翻译，并使用lupdate生成或更新Demo_en.ts和Demo_fr.ts文件。将所述文件编译为构建目录中的Demo_fr.qm和Demo_fr.qm文件：
set(TS_FILES Demo_en.ts Demo_fr.ts) qt5_create_translation(QM_FILES ${CMAKE_SOURCE_DIR} ${TS_FILES}) QM_FILES是输出变量
添加编译文件 对于qrc文件和ui文件，直接add_executable就可以了
add_executable( ${PROJECT_NAME} main.cpp MainWindow.h MainWindow.cpp MainWindow.ui resources.qrc ${QM_FILES} ) 源码 cmake_minimum_required(VERSION 3.18) project("Demo" VERSION 1.0.0 LANGUAGES CXX) # set(CMAKE_PREFIX_PATH "E:\\ProgramFiles\\Qt\\5.15.2\\msvc2019_64;${CMAKE_PREFIX_PATH}") # set(Qt5_DIR "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/705dc1ed75aa2470e348df2261b77125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b36cb0921397e1f1e40798c4fa0cb44/" rel="bookmark">
			架构（九）云服务器-Docker容器-系统搭建部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 最近公司在海外上云服务器，作者自己也搞了云服务器去搭建部署系统，方便了解整体架构和系统的生命周期，排查解决问题可以从原理侧进行分析实验。虽然用的云不是同一个，但是原理都是相通的。
二、选型 作者选用的是腾讯云，没别的原因，就是便宜加牌子大。
阿里云肯定是更好一些的，不管是服务售后还是服务器内核和操作系统都是比较活跃的，毕竟作者以前公司用的就是阿里云，了解一些。
不过以前都是和运维沟通排查问题，作者自己只能看到一些服务器监控和运维的截图，这对于了解整个云服务架构体系的生命流程是不太友好的。
操作系统选择了CentOS7.6-Docker20，毕竟linux的底层是必须的，目前的容器环境也是服务的基础。
基本参数如下，没必要太好
CPU - 2核 内存 - 4GB系统盘 - SSD云硬盘 60GB管理快照流量包 - 500GB/月（带宽：5Mbps） 三、系统搭建部署 作者准备把springboot用Maven打包，jar包拿到docker容器运行
3.1、后端 后端是SpringBoot，SSM框架，代码就不贴了，作者写了个小程序给家里人用的。
3.2、打包 这一步很麻烦，打出来的包很小，作者当时还没意识到问题，本地java -jar运行一下，报错了。显示no main manifest attribute, in /**.jar，问了一下chatGpt，这就很扯，做了这么久的SpringBoot，他里面的application怎么可能不是字段设置为主类的呢。
作者有找了网上的一些文章，有的说是打包的时候没有设置入口类，pom的build重新设置一下。
&lt;build&gt; &lt;plugins&gt; &lt;!-- maven-compiler-plugin 插件配置 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- maven-jar-plugin 插件配置 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;mainClass&gt;**.Application&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 其他插件... --&gt; &lt;/plugins&gt; &lt;/build&gt; 然后出现了新的错误：Caused by: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b36cb0921397e1f1e40798c4fa0cb44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42c750d9428bccf9131e31352458c135/" rel="bookmark">
			架构（七）热点探测-HotKey在物联网可以做什么
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 博主今天聊一聊物联网领域的热点探测，讲一讲架构和源码，依赖的中间件主要是京东武伟峰的HotKey（这里已经征得创作者同意）hotkey: 京东App后台中间件，毫秒级探测热点数据，毫秒级推送至服务器集群内存，大幅降低热key对数据层查询压力 核心功能：热数据探测并推送至集群各个服务器，适用于各种第三方存储的热点探测。
说起来有点显得官方，具体看一下这个中间件在物联网、资产领域可以使用到的场景，然后介绍一下它的实现原理，便于搭建和二次开发。
二、物联网、资产场景 1、跳变 机器在一些特定的使用方式和组合情况下会导致跳变，概括的内容其实很多，主要是反复持续的发生一些动作，比如卡口一松一紧、行程开关反复打开等。
这些会导致预警、修理等业务场景的频繁无效处理，导致大量的物联网心跳被消费，浪费性能和资源。
这里其实就可以使用HotKey，比如设置规则两秒接收五次以上的跳变就标记为问题，停止无用的处理，并且识别出之后交给硬件进行识别检测。
有的同学可能会说，我自己在服务里面做不也行吗？
是的，但是这偏向于技术需求，导致的问题也不严重，花时间精力做一个有点定制化而不是通用的需求，这不太现实。但是使用框架之后，除了搭建和运维需要一些成本，其他处处通用，而且作为服务开发人员不关心这些运维的事情，用起来简单就可以了。
2、查询超时 对于调用别人的服务还是自己的服务给别人调来说，性能都是很重要的事情，对于性能要求没那么高的系统例如门店列表、机器列表、相关组织区域等，秒级的查询肯定也是刚需，不然服务质量管理组就要来找你了，很大一部分查询无解是因为：
1、调用外部系统过多
2、调用外部系统或者提供外部查询的时候流量突然的高峰，然后不管是磁盘还是网络瞬间的io都飚上去了
这种情况也可以用hotkey，把热点数据临时缓存，直接从本地内存查询，然后sla就不会找麻烦了。
三、原理 1、热key探测 1.1、探测策略 在开源社区有许多人在一开始不了解这个中间件的时候认为他的策略是基于拦截的，比如拦截了发送给redis的请求发送给服务端计算是否热key。
实际上并不是这样，而且他针对的是所有热key，也就是说他不区分第三方存储是什么，无论是es、db、redis等等第三方存储，他都可以计算热key。
那么他是怎么做的呢，实际上是基于业务思维去考虑的，他的创作者武伟峰也是业务开发，不是中间件团队。
那么业务思维是什么呢，如果这对一个key-value你需要对外暴露或者统计，那么一定会先被查一下是不是热key，是就从本地缓存拿数据，不是的话再从其他存储取，那么这个时候代表这个key被访问了一次，就可以开始计数了。
如果足够热点，isHotKey这个方法就会被访问很多次。
1.2、客户端访问key 客户端主要是JdHotKeyStore这个类作为依赖包中的暴露点其中最主要的是isHotKey方法，先在本地计数存一下，不会立刻发送给服务端。
public static boolean isHotKey(String key) { try { if (!inRule(key)) { return false; } boolean isHot = isHot(key); if (!isHot) { HotKeyPusher.push(key, null); } else { ValueModel valueModel = getValueSimple(key); //判断是否过期时间小于1秒，小于1秒的话也发送 if (isNearExpire(valueModel)) { HotKeyPusher.push(key, null); } } //统计计数 KeyHandlerFactory.getCounter().collect(new KeyHotModel(key, isHot)); return isHot; } catch (Exception e) { return false; } } 基本是攒0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42c750d9428bccf9131e31352458c135/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e02498c0457c53e456791398f623eb0/" rel="bookmark">
			宏图一号标准数据产品格式说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 适用范围 本文档规定了HT-1卫星的数据产品格式和标准，并将在后续逐渐完善对“女娲星座”卫星数据产品规范。
缩略语 简称全称中文全程HT-1HT-1宏图一号SLCSingle Look Slant Range Complex单视斜距复图像SLPSingle Look Slant Range Pair单视复干涉对图像SGCSystem Geometric Correction系统几何校正影像GTCGeocoded Terrain Corrected地理编码地形校正影像AGCAccurate Geometric Correction几何精校正影像DOMDigital Orthophoto Map数字正射图RPCRational Polynomial Coefficients有理多项式系数SLSpotlight Mode聚束模式SMStripmap Mode条带模式TOPSARTerrain Observation with Progressive Scans SAR渐进扫描SAR地形观测R×ARange×Azimuth距离向×方位向 版本控制 序号版本号版本日期更改内容更改人1v1.02023-08-08创建张添，路聚峰2v1.12023-12-11更新元数据文件内容张添，路聚峰 参考文档 GF-3卫星产品用户手册。TerraSAR-X Ground Segment Level 1b Product Format Specification.Radarsat-2 Product Format Definition.Sentinel-1 User Handbook. 卫星简介 宏图一号SAR卫星系统是全球首个采用四星车轮式编队构型的多星分布式干涉雷达卫星系统。2023年 3月30日18时50分，航天宏图一号在太原卫星发射中心，成功搭载长征二号丁运载火箭以“一箭四星”方式发射升空并顺利进入预定轨道。
截至2023年8月3日，已经组织完成卫星第1900余圈跟踪任务，顺利完成卫星早期轨道控制、SAR载荷开机成像等任务，现已到达预定轨道（528km）并成功进行四星编队构型，目前星地系统状态正常，多星成像、定标、多星干涉等测试都在有序进行中。
宏图一号首图发布后，得到了社会各界的关注和认可，在轨测试期间就收到大量客户和事业部的订单。面对近期的洪灾威胁，宏图一号卫星在轨测试的同时，第一时间积极响应灾害发生后的请求，快速启动SAR卫星任务，对北京、河北、黑龙江等受灾地区进行全面的扫描和监测。在地面系统成像后，进行影像校正，提取泛洪区水体范围，将高质量、高分辨率的SAR数据归档并分发给相关应急部门，为灾害救援工作提供了有力支持。
​ 图1 8月3日宁波某区域L2级产品影像图
为方便大家对宏图一号数据有个整体性了解，文档分别从卫星成像模式、标准产品分级与定义、文件命名方式、文件组成、常见元数据、配套软件等方面进行了详细的介绍，供技术人员参考。
【注】：随着卫星在轨测试的推动，元数据若干字段会有小的调整，后续会同步更新文档和软件插件。
成像模式 宏图一号共有6种成像模式，每种成像模式对应的分辨率、成像带宽和极化方式见下表。
​ 表1 HT-1卫星成像模式
标准产品分级与定义 ​ 表2 标准产品分级与定义
L1级产品描述 文件格式 图像产品采用GeoTIFF格式。
产品命名规范 产品命名包含了描述产品状态的基本信息，包括卫星标识、传感器标识、地面站标识、成像模式、采集日期、产品类型等。产品名称由以下几部分组成：卫星标识_站名_成像模式_产品名称_产品级别极化方式_数据获取年月日_景中心经度（E东经、W西经小数点后一位）_景中心纬度（N北纬、S南纬小数点后一位）_轨道号（6位）_产品号（4位）_升/降轨信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e02498c0457c53e456791398f623eb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29740f2c52c6735a079170cc35c20822/" rel="bookmark">
			swiper播放视频，完成后自动切换下一张
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		video 属性和事件用法大全： https://www.cnblogs.com/rogerwu/p/10072119.html
我的思路是监听视频播放进度，如果播放完毕再开启swiper的自动轮播，因为我的需求是只有第一个swiper才是视频，后边的都是图片，那就需要轮播到第一个swiper的时候停止自动轮播，继续等待视频播放完毕再次开始自动轮播。
把swiper的默认自动轮播时间设置的小一点，视频播放完后切换下一张swiper的等待时间就不会有太长时间间隔，其余需要正常时间切换的通过 data-swiper-autoplay 属性控制
开启自动轮播 swiper0.autoplay.start(); 查看文档
关闭自动轮播 swiper0.autoplay.stot();
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link type="text/css" href="./assets/css/swiper.min.css" rel="stylesheet"&gt; &lt;style&gt; .swiper-slide { width: 100%; height: 100vh; } .swiper-slide video { width: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="swiper-container swiper0" id="banner-swiper"&gt; &lt;div class="swiper-wrapper"&gt; &lt;div class="swiper-slide"&gt; &lt;video id="sVideo" muted loop&gt;&lt;source src="./assets/images/s_video.mp4" type="video/mp4"&gt;&lt;/video&gt; &lt;/div&gt; &lt;div class="swiper-slide" data-swiper-autoplay="3000" style="background-color: antiquewhite;"&gt; 1111 &lt;/div&gt; &lt;div class="swiper-slide" data-swiper-autoplay="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29740f2c52c6735a079170cc35c20822/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/940eef5724f5b0375411c5e4b145357f/" rel="bookmark">
			搭建Vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装 node 安装 vue 前电脑中必须已经安装成功 node.js
node.js 下载链接
下载完成后，执行安装程序，直接进行安装即可
安装完成后，打开命令行窗口（cmd）
输入 node -v 和 npm -v 可查看安装的 node.js 和 npm 的版本号
2、安装编译器 VSCode下载链接
3、安装Vue 使用 npm 进行安装，安装速度慢，因为资源在国外，可以使用国内镜像
1.首先切换淘宝镜像
npm config set registry http://registry.npm.taobao.org/ 2.安装 vue 的脚手架
npm install –g @vue/cli 4、创建Vue项目 4.1、创建文件 创建文件夹用 vscode 打开，点击终端按钮，cd 进入到你要创建的文件夹里，输入命令
vue create vue01 4.2、选择配置信息 通过上下方向键选择，然后回车确认，选择 Manually select features 自定义配置。
之后按空格键选择要安装的资源配置，为*号说明已选中。
选择vue版本
4.3、路径模式选择 是否使用 history router? 我选n，即不使用。
4.4、选择 Css 预处理语言 选择 Less，主要为 css 解决浏览器兼容，简化 css 代码等问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/940eef5724f5b0375411c5e4b145357f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4bef0ba1cceea1645294f033853831fe/" rel="bookmark">
			资产管理系统部署及库存告警
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.需求：对电脑，办公设备，耗材等做资产盘点和整理，并对库存预警。
2.选型：snipeit
3.部署
#!/bin/bash docker run -d -p 80:80 --name="snipeit" --env-file=snipeit.env --mount source=snipe-vol,dst=/var/lib/snipeit --privileged snipe/snipe-it snipeit.env: PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=f3dee7edd3f7 TERM=xterm MYSQL_PORT=tcp://mysql.sit.xxx.com:3306 MYSQL_PORT_3306_TCP=tcp://mysql.sit.xxx.com:3306 MYSQL_PORT_3306_TCP_ADDR=mysql.sit.xxx.com MYSQL_PORT_3306_TCP_PORT=3306 MYSQL_PORT_3306_TCP_PROTO=tcp #MYSQL_NAME=/snipeit/mysql MYSQL_ENV_MYSQL_ROOT_PASSWORD=xxx MYSQL_ENV_MYSQL_DATABASE=snipeit MYSQL_ENV_MYSQL_USER=snipeit MYSQL_ENV_MYSQL_PASSWORD=xxx MYSQL_ENV_APP_URL=http://192.168.3.231:80 MYSQL_ENV_APP_TIMEZONE=Asia/Shanghai MYSQL_ENV_APP_LOCALE=zh-CN MYSQL_ENV_GOSU_VERSION=1.12 MYSQL_ENV_MYSQL_MAJOR=5.6 MYSQL_ENV_MYSQL_VERSION=5.6.51-1debian9 MYSQL_ROOT_PASSWORD=xxx MYSQL_DATABASE=snipeit MYSQL_USER=snipeit MYSQL_PASSWORD=yuj1Iqu4Eef MAIL_PORT_587_TCP_ADDR=c2.xxx.net MAIL_PORT_587_TCP_PORT=465 MAIL_ENV_FROM_ADDR=it_xxx@xxx.com MAIL_ENV_FROM_NAME=snipeit MAIL_ENV_ENCRYPTION=tcp MAIL_ENV_USERNAME=it_xxx@xx.com MAIL_ENV_PASSWORD=xxx SNIPEIT_SMTP_ENCRYPTION=ssl MAIL_DRIVER=smtp MAIL_HOST=c2.xxx.net MAIL_PORT=465 MAIL_FROM_ADDR=it_xxx@xxx.com MAIL_FROM_NAME=snipeit MAIL_ENCRYPTION=tcp MAIL_USERNAME=it_xxx@xxx.com MAIL_PASSWORD=xxx MAIL_ENCRYPTION=ssl APP_ENV=production APP_DEBUG=false APP_KEY=base64:uNRDxRe96zAcZkkchW3byQf0ukPZtaMhUI3lrC2KS/g= APP_URL=http://192.168.3.231 APP_TIMEZONE=Asia/Shanghai APP_LOCALE=zh-CN HOME=/root SN_LDAP_ENABLED=true SN_LDAP_SERVER=ldap://ldap.xxx.com:389 SN_LDAP_BIND_DN="cn=auth,dc=xxx,dc=com" SN_LDAP_BIND_PASSWORD=xxx SN_LDAP_USER_BASE_DN="dc=xxx,dc=com" SN_LDAP_USER_FILTER="(&amp;(|(memberOf=cn=it,dc=xxx,dc=com))(&amp;(objectClass=person)(cn=%(user)s)))" 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4bef0ba1cceea1645294f033853831fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51ba101641078233cd98ddfc2dbe4f1f/" rel="bookmark">
			微信小程序（一）域名备案及HTTPS访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 接上篇云服务器-Docker容器-系统搭建部署-CSDN博客，一方面是提高实践架构技术，一方面给家里人做点生活小工具。
在搭建好服务器和前后端程序之后，经过测试，作者给家里人做的生活系微信小程序就差不多可以用了。
先搞了一个体验版本试用。然后就崩了，接口不通，打开调试器再使用又可以了。
二、分析 这种调试情况可用，线上版本（不管是体验版还是发布版）不通的情况，肯定是微信做了什么拦截，在社区问了一下，其他博主说是微信必须使用域名访问，网络请求必须使用Https，域名还要在页面配一下合法。
那么这就引出来很多其他工作了，大的方向可用分为域名、Https部署、ssl证书、小程序页面配置。还有很多备案之类的细节工作。
技术上还需要考虑的是解析转发问题，请求通过域名dns解析到服务器之后，https 的解析无非两种做法：springboot部署或者nginx解析转发，
1、springboot与Nginx解析https选型 先看看springboot部署大致需要做什么：
1、证书文件放置在应用程序的classpath下，配置SSL证书： server.ssl.key-store=classpath:** server.ssl.key-store-password=** server.ssl.key-store-type=** server.ssl.key-alias=** 2. 配置HTTPS连接： server.port=443 server.ssl.enabled=true 这里的`443`是HTTPS连接的端口号，`true`表示启用HTTPS连接。 3. 配置HTTP重定向： @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addRedirectViewController("/", "/index.html"); } @Bean public TomcatServletWebServerFactory servletContainer() { TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory() { @Override protected void postProcessContext(Context context) { SecurityConstraint securityConstraint = new SecurityConstraint(); securityConstraint.setUserConstraint("CONFIDENTIAL"); SecurityCollection collection = new SecurityCollection(); collection.addPattern("/*"); securityConstraint.addCollection(collection); context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51ba101641078233cd98ddfc2dbe4f1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddc33d8d6cad38acdb43b2ee2d8d9969/" rel="bookmark">
			ER图制图软件，让你的数据库设计优化到极致！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在现今数据驱动的世界中，数据库设计扮演了至关重要的角色。为了实现有效且准确的数据存储和检索，企业们开始倾向于采用实体关系图（Entity-Relationship Diagram，简称ER图）来优化他们的数据库设计流程。今天要介绍一款强大的软件，它就是itBuilder软件，一款在线表结构设计软件，借助人工智能提高效率，可以生成CRUD代码并推送至开发工具中；它涵盖了几乎所有语言，如Java、Python、JavaScript等，并且支持团队多人协作，实时通信，无缝协作。结尾放置白嫖渠道，亲自上手感受AI与数据库相结合的强大之处，才能更加有体会。
我们需要了解ER模型中的两个基本概念：实体和关系。实体是数据库中存储的对象，如人、产品、订单等。关系则是实体之间的关联，如人与人之间的关系、人与产品之间的关系等。itBuilder提供了直观的可视化界面，让您能够轻松设计表结构并制作ER图。您可以根据个人需求设置颜色、设置表之间字段关联，以及进行灵活的布局。不再需要手动绘制ER图，同时，也可以将生成的ER图进行导出，方便分发和分享用户的模型。
总结来说，ER图在数据库设计中起到了连接各个实体和关系的作用，帮助我们更好地组织和管理数据。通过ER图，我们可以清晰地了解实体之间的关系，从而设计出更合理和高效的数据库结构。
在系统分析与设计中，ER图被广泛应用于数据库设计。数据库设计是指根据系统需求和业务规则，设计出合理的数据库结构以存储和管理数据。ER图作为一种图形化工具，可以帮助分析师和设计师理解业务需求，并将其转化为可操作的数据库模型。
itbuilder是一款功能强大的在线表结构设计软件，它借助AI技术实现自动生成表结构和代码，并支持团队协作、版本控制等多种功能，大大提高了开发效率和减少了错误。如果您在进行数据库表结构设计时需要一款高效的工具，itbuilder将是一个不错的选择。https://www.itbuilder.cloud/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dcd31d0d6e0e3c1b2017a43e601feb4/" rel="bookmark">
			生产问题（七）Mysql for update 导致大量行锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、引言 最近同事的复盘会上提到自己for update一个不存在的where条件导致表锁，然后产生大量的事务失败和读写超时，这时博主非常奇怪，因为虽然网上许多博客写Innodb的表锁行锁与锁升级，但是事实上这都是错误的观点。
二、分析 首先博主的环境是Mysql5.7，隔离级别是RC
博主为什么说这些都是错误的观点呢？因为在《高性能Mysql》和《Innodb存储引擎当中》，非常明确的提出：
1、Innodb不存在锁升级，所以不存在因为锁的数据量大或者多表，导致行锁升级成表锁。 2、当for update一个不存在的where条件时，Innodb加的是Record级别锁 这一点可以通过验证得到
不存在的where set autocommit = 0 ;
begin;
select * from t_aac_battery_compensate where gmt_create in ('2020-05-21 07:02:37') for update ;
存在的where begin;
select * from t_aac_*** where gmt_create in ('2020-05-21 07:32:37') for update ;
然后执行
select * from information_schema.INNODB_LOCKS il 可以看到锁
可以看到两个事务加的都是行级别锁。
可能有的同学会对锁住的行数量和数据有疑惑，这里博主发现这两个数值统计的方式是不准的，包括在《Innodb存储引擎》作者明确提出lock_data是不准确的。
也有的同学疑惑他加行锁为什么会阻塞其他读写，这里是innodb加了行锁之后最后一起释放，虽然不知道它这样的设计是出于什么考虑。
3、Innodb如果在索引中找不到记录，会在行数据进行搜索，锁住主键，而不是锁表 所以一些博客说根据索引加不到锁，innodb就会锁全表，这是错误的理解
只是可能在一些情况下他搜索行数据对主键加锁的数量过多，之前也说了innodb加行锁是最后一起释放的，所以阻塞了其他读写
4、Innodb加锁的方式是从上到下的，自动加锁只有表级别的意向锁和行级锁，表级别的意向锁只会阻塞全表扫描 5、RR级别加锁情况 上文都是基于博主线上环境配置，如果是RR隔离级别，还会有GapLock与行锁进行Next_keyLock算法加锁，其实简单说就是锁住当前B+树种当前索引到上一个索引之间（或当前行到上一行）的间隔，防止在这个过程中有插入数据，也就是防止幻读。
但是这个情况不是绝对的，对于唯一索引，innodb会降低级别行级锁，不会锁住范围
三、总结 通过以上分析得到结论：
1、RC级别下innodb都是行级锁，表级的意向锁只会阻塞全表扫描
2、innodb不存在锁升级
3、innodb加不到索引会搜索行，对主键加锁
4、当for update一个不存在的where条件时，Innodb加的是Record级别锁
以上分析除了实际操作验证和权威书籍理解之外，博主与DBA也经过深入探讨，如果有异议欢迎讨论。 另外希望各位同学，多实际操作、多看权威书籍和源码，对于网上的博客看一半信一半，要有自己的判断，书籍和源码的查看也要结合实际经验，因为每个人的脑回路是不一样的，一不小心理解方向就可能歪了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5039baa825e36facd33febccf9b8ebe8/" rel="bookmark">
			生产问题（五）TCP丢包解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、引言 接上篇TCP丢包排查_tingmailang的博客-CSDN博客，丢包的排查确认在环境、网络链路层，对于后续的排查以及解决方案博主全程跟踪，这里再分享下。
二、丢包原因-操作系统层面 上篇文章定位到tcp握手偶发丢包，运维联系了阿里云人员排查丢包是否和云平台有关，阿里云进行了系统监控，发现的确是有不少丢包现象。
阿里云说明在kernel-4.19.91-25.1.al7及之前的内核版本上，当应用程序同时发起多条TCP连接请求时，大量TCP报文经过NAT表并有概率获取到重复的端口。Conntrack模块在确认阶段发现端口存在重复的情况，丢弃了相关的TCP报文。
iptables防火墙可以用于创建过滤(filter)与NAT规则，所有Linux发行版都能使用iptables。所以获取到NAT的重复端口的linux的机制决定的。
有的同学可能有疑问，k8s不是隔离的吗，怎么会出现端口重复使用？实际上如果一个物理机一个k8s容器，那的确是隔离的，但这样也失去了k8s的意义：隔离内存磁盘等物理机上容易相互干扰的资源，干脆一个物理机一个服务算了。
生产环境基本上一个物理机会有十几个服务，而内核cpu、网络端口这些实际上是被k8s容器中的服务共用的。
总结一下当前微服务环境下的请求发送过程：
①x服务发出请求，通过iptables的NAT表对（数据包的）网络地址（IP + Port）进行转换，获取端口
②端口发送tcp握手包，Linux的Conntrack模块自检确认（包会经过 nf_conntrack_in() 、 nf_conntrack_confirm() 进行创建（new）和确认（confirm）两个阶段 ）
③请求到达服务网格1
④服务网格通过iptables的NAT表对（数据包的）网络地址（IP + Port）进行转换，获取端口，建立tcp链接
⑤网格发送tcp握手包，Linux的Conntrack模块自检确认（包会经过 nf_conntrack_in() 、 nf_conntrack_confirm() 进行创建（new）和确认（confirm）两个阶段 ）
⑥服务端操作系统收到握手请求包，通过iptables的NAT表获取端口，使用该端口与客户端网格建立tcp链接
⑦网格1转发数据给网格2
⑧服务网格2接收请求数据，转发给y服务处理
这里可以看出这一次的问题就在第二、五，获取端口重复，linux自检确认的时候就会直接丢弃这个数据包，握手超时，tcp再次发起握手。
三、丢包解决-操作系统层面 根据阿里云的描述4.19的时候是顺序获取，所以比较频繁，使用yum升级到5.x以上，5.X的内核是随机获取，出现端口重复的频率比较低。
这种解决方式是概率性的，重复端口丢包的风险依然存在，只是频率会下降，不过阿里云做了其他优化，在端口重复丢包的时候会立刻通知tcp重传，这样延时就降低到了ms级别。
四、丢包解决-服务层面 虽然说丢包是操作系统与网络层面的问题，但是服务层面也不是没有优化解决的办法，或许不能称之为解决，和操作系统的升级一样，只是尽量降低丢包频率。
根据上一篇文章定位到的，丢包基本是第一次握手发生，那么是否可以尽量避免tcp新建链接，多多复用呢？
还是有这种办法的，服务使用的json序列化是fasterxml.jackson默认的EAGER_DESERIALIZER_FETCH，这种序列化读取响应json的时候最后一个\r\n有可能不会读取 这样下一次复用连接的时候会发现有脏数据\r\n关闭连接，并且进行新建tcp链接。
修改为使用FAIL_ON_TRAILING_TOKENS就可以减少上面这种情况的新建tcp，对于jackson自身的影响是如果是"{json}xxxxx" 这样的字符串 之前是可以反序列的 加了以后会失败，但是在正常的业务场景不会出现这种异常json。
当然，这种改动并不是直接针对丢包的，主要是想复用tcp，所以效果是有概率的，新建链接是不可避免的，链接不会一直被复用，就看因为网络原因会丢包的时候，是正好复用链接还是新建链接。
五、总结 最终定位到了tcp握手丢包是阿里云内核容易取到重复端口建立tcp链接，linux自检确认发现重复使用就会丢弃握手数据包。
解决方案是操作相通升级内核（随机获取替代顺序获取、端口重复丢包的时候会立刻通知tcp重传）、服务使用json配置FAIL_ON_TRAILING_TOKENS（减少新建tcp链接）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbac6329e47e923e40dd68940db2c70e/" rel="bookmark">
			2023年四川网信人才技能大赛 决赛 实操赛 Writeup
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Crypto比base64少的baseaffine简单的RSA Misc不要动我的flagSimpleUSB猜猜我是谁不聪明的AI Pwngetitezbbstack Reverse谁的DNA动了Don't Touch Me Weblittle_gamejustppbezbbssmart 题目附件，文章末尾微信公众号点点关注亲，谢谢亲~
题目附件链接：https://pan.baidu.com/s/1kC9kiyUCfjTxqkXPpUFoXw 提取码：dh2w Crypto 比base64少的base affine wohz{k533q73q-t76t-9292-351w-h880t22q2q59} a=3 b=7 简单的RSA p = r**5 + r**4 - r**3 + r**2 - r + 2023 q = r**5 - r**4 + r**3 - r**2 + r + 2023 所以n近似等于
r**10 - r**8 + 2*r**7 - 3*r**6 + 4050*r**5 - 3*r**4 + 2*r**3 - r**2 + 4092529==n z3求解出r，进而得到p、q ，然后进行常规的解密
n = 25066797992811602609904442429968244207814135173233823574561146780193277243588729282392464721760638040595480284865294238118778099149754637586361909432730412493061503054820202744474632665791457 r = Real('r') s = Solver() s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbac6329e47e923e40dd68940db2c70e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84bad3a3e9003455ea83d1b184ee49d4/" rel="bookmark">
			系统架构设计师教程（五）软件工程基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件工程基础知识 5.1 软件工程5.1.1 软件工程定义5.1.2 软件过程模型5.1.3 敏捷模型敏捷开发的特点敏捷方法的核心思想主要敏捷方法简介 5.1.4 统一过程模型 (RUP)RUP的生命周期RUP中的核心概念RUP的特点 5.1.5 软件能力成熟度模型 5.2 需求工程5.2.1 需求获取需求获取的基本步骤需求获取方法 5.2.2 需求变更变更控制过程变更控制委员会 5.2.3 需求追踪 5.3 系统分析与设计5.3.1 结构化方法结构化分析结构化设计结构化编程数据库设计 5.3.2 面向对象方法面向对象分析面向对象设计面向对象编程数据持久化与数据库 5.4 软件测试5.4.1 测试方法5.4.2 测试阶段 5.5 净室软件工程5.5.1 理论基础5.5.2 技术手段5.5.3 应用与缺点 5.6 基于构件的软件工程5.6.1 构件和构件模型5.6.2 CBSE过程5.6.3 构件组装 5.7 软件项目管理5.7.1 项目管理概述5.7.2 软件进度管理5.7.3 软件配置管理5.7.4 软件质量管理软件质量保证软件质量认证 5.7.5 软件风险管理 5.1 软件工程 5.1.1 软件工程定义 软件工程过程是指为获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动，包括以下4个方面。
P(Plan)——软件规格说明。规定软件的功能及其运行时的限制。D(Do)——软件开发。开发出满足规格说明的软件。C(Check)——软件确认。确认开发的软件能够满足用户的需求。A(Action)——软件演进。软件在运行过程中不断改进以满足客户新的需求。 5.1.2 软件过程模型 软件要经历从需求分析、软件设计、软件开发、运行维护，直至被淘汰这样的全过程，这个全过程称为软件的生命周期。
瀑布模型
已经有了蓝图，按部就班地去完成，中间客户的需求根本不会改变。原型化模型
这个就比较惯着客户了，先给出一个小样，不断地去修改完善，有时候也不会完善了，就是给客户一个灵感来源。
螺旋模型
螺旋模型 (Spiral Model) 是在快速原型的基础上扩展而成。不断地修修补补。
5.1.3 敏捷模型 敏捷开发的特点 敏捷型方法是“适应性” (adaptive) 而非“预设性” (predictive)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84bad3a3e9003455ea83d1b184ee49d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5091fe31860ab964369cb92eeec9014/" rel="bookmark">
			Linux驱动：华硕Pro WS W790E-SAGE SE 板载10G网卡Linux驱动（Intel X710）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux的驱动一直比较难找，这里特地整理一些工作中用到的linux网卡驱动，希望能帮到大家。 i40e-2.23.17.tar.gz
链接：https://pan.baidu.com/s/1Y-ug0eFntGpuKOdVOQWMcA?pwd=lctf
提取码：lctf
华硕Pro WS W790E-SAGE SE 板载10G网卡Linux驱动（Intel X710） 主板网口名：Intel X710-AT2 Daul 10G
Centos7.6系统中lspci查出的网口名：Intel Corporation Device 15ff (rev 02)
步骤 1.tar zxf i40e-&lt;x.x.x&gt;.tar.gz 2.cd i40e-&lt;x.x.x&gt;/src/ 3.make install 官网地址：用于 700 系列装置的 i40e Linux* 基础驱动程序版本 2.23.17 详细说明 概述 此版本包括适用于 Intel® 乙太網路 网络连接的 i40e Linux* 基础驱动程序。
i40e 驱动程序支持基于以下控制器的设备：
Intel® 乙太網路控制器 I710
Intel® 乙太網路控制器 X710
Intel® 乙太網路控制器 XL710
Intel® 乙太網路 网络联机 X722
Intel® 乙太網路控制器 XXV710
Intel® 乙太網路控制器 V710
i40e-x.x.x.tar.gz
由于 Linux 内核的不断发展，驱动程序的更新频率高于捆绑版本。最新的驱动程序可在 http://e1000.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5091fe31860ab964369cb92eeec9014/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b374aadf41a8ae5c72c3b45f6d94965/" rel="bookmark">
			Python3， 一文掌握PyMuPDF的主要功能，再也不需要东奔西跑了。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一文掌握PyMuPDF 1、引言2、PyMuPDF2.1 介绍2.2 功能2.3 安装2.4 示例2.4.1 读取并打印PDF中的文本2.4.2 从PDF中提取特定区域的图像2.4.3 拆分PDF文件2.4.4 提取PDF文件内容2.4.5 添加注释 3、总结 1、引言 小屌丝：我的纸飞机呀，飞呀飞~
小鱼：你要往哪儿飞
小屌丝：飞到你的童年
小鱼：… 能不能不这么扯
小屌丝：(⊙o⊙)…
小鱼：时光如梭，梭梭催人老。
小屌丝：好吧…
小鱼：你就不会说，飞到芦荡边？
小屌丝：…
小鱼：算法，不跟你说了， 我继续写文章了。
小屌丝：额， 写啥文章啊
小鱼：回到童年的文章
小屌丝：…写啥嘛
小鱼：纸飞机
小屌丝：…谢少吗
2、PyMuPDF 2.1 介绍 在日常工作和学习中，我们经常会遇到需要处理PDF文件的需求，例如提取文本、查找关键词、合并拆分文件等。
PyMuPDF是由德国的Till Pieper开发的，用于处理PDF文件的Python库。它基于muPDF，一个轻量级、高效的PDF处理库。PyMuPDF可以运行在Windows、macOS和Linux操作系统上，并且支持Python 2.7和3.x。
本文，小鱼将介绍PyMuPDF的基本信息、主要功能、安装方法以及代码示例。
一次掌握PyMuPDF的主要功能。
2.2 功能 PyMuPDF是基于C++的MuPDF库的Python封装，它提供了许多有用的功能，包括：
文本提取：可以从PDF文件中提取文本内容，方便进行关键词搜索、文本分析等操作。
图像提取：可以提取PDF文件中的图像，方便进行图像处理、识别等操作。
页面操作：可以对PDF文件中的页面进行旋转、裁剪、缩放等操作，实现自定义的页面处理。
注释和标记：可以添加、修改和删除PDF文件中的注释和标记，方便进行文档批注和标记重点内容。
导出和转换：可以将PDF文件导出为图片或其他格式，也可以将其他格式的文件转换为PDF格式。
修改PDF内容：可以在现有PDF的基础上添加、删除或更改内容。
合并或拆分PDF文件：可以将多个PDF文件合并成一个，也可以将单个大文件拆分成多个小文件。
生成SVG图像：可以将PDF转换为可缩放的矢量图形(SVG)。
加密和解密PDF文件：可以给PDF文件设置密码，防止未经授权的访问
了解了PyMuPDF的功能，接下来，就到了我们实际操练的步骤了。
2.3 安装 因为 PyMuPDF是三方库，所以，需要先安装，在使用。
老规矩， pip安装
pip install pymupdf 其它安装方式，直接看这两篇:
《Python3，选择Python自动安装第三方库，从此跟pip说拜拜！！》
《Python3：我低调的只用一行代码，就导入Python所有库！》
2.4 示例 2.4.1 读取并打印PDF中的文本 # -*- coding:utf-8 -*- # @Time : 2023-12-02 # @Author : Carl_DJ ''' 实现功能： 使用 PyMuPDF 读取并打印PDF中的文本 ''' import fitz # 打开名为'example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b374aadf41a8ae5c72c3b45f6d94965/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cdb962d05620bf89d6fec8326890048/" rel="bookmark">
			光线追踪器实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们收到了很多读者的电子邮件，询问：“好吧，如果这很容易做到，你不能给我们提供一个真实的例子吗？”
这与计划不同（因为我们的想法是逐步编写渲染器），但我们编写了一个简约的光线追踪器，在大约几个小时内编写了大约 30000 行。 尽管我们不一定为这种性能感到自豪，但我们想表明，当人们很好地了解这些技术时，实施它们并不困难。 源代码可供下载。 我们没有也不会花时间评论这个计划。 写得比较快，所以还有改进的空间。
NSDT工具推荐： Three.js AI纹理开发包 - YOLO合成数据生成器 - GLTF/GLB在线编辑 - 3D模型格式在线转换 - 可编程3D场景编辑器 - REVIT导出3D模型插件 - 3D模型语义搜索引擎
1、基础版光线追踪器实现 在此版本的光线追踪器中，我们使光线可见（球体），因此其反射会出现在反射球中。 有时很难看到玻璃球何时透明（白色），因此在我们的示例中，我们将它们稍微着色（红色）。 在现实世界中，透明玻璃不一定可见。 这取决于环境。 请注意，生成的图像需要更准确。 透明红色球体下方的阴影不应完全不透明。 在以后的课程中，我们将学习如何快速纠正这种视觉不准确。 我们还实现了其他功能，例如假菲涅耳（使用一种称为面比的技术）和折射。 所有这些内容都将在稍后进行研究，因此，如果你需要帮助清楚地理解它们，请随意。 至少你现在有一个小程序可以玩了。
要编译程序，请将源代码下载到你的硬盘上。 你将需要一个 C++ 编译器（例如 clang++）。 这个程序不需要任何特殊的东西来编译。 使用终端（例如，Windows 版的 GitBash 或 Linux 或 macOS 下的终端）并在文件所在位置键入以下命令（如果你使用 gcc）：
c++ -O3 -o raytracer raytracer.cpp 如果你使用 clang，请改用以下命令：
clang++ -O3 -o raytracer raytracer.cpp 要创建图像，请在 shell 中键入 ./raytracer 来运行程序。 等几秒钟。 当程序返回时，你的磁盘上应该有一个名为 untitled.ppm 的文件。 可以使用 Photoshop、Preview（在 Mac 上）或 Gimp（专门讨论读取和显示 PPM 图像的课程）打开此文件：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cdb962d05620bf89d6fec8326890048/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1b91626cb789e00ff654eab603f8658/" rel="bookmark">
			【Python】人工智能-机器学习——不调库手撕深度网络分类问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 作业内容描述 1.1 背景 数据集大小150该数据有4个属性，分别如下 Sepal.Length：花萼长度(cm)Sepal.Width：花萼宽度单位(cm)Petal.Length：花瓣长度(cm)Petal.Width：花瓣宽度(cm)category：类别（Iris Setosa\Iris Versicolour\Iris Virginica) 1.2 要求 在不调用机器学习库的情况下，使用神经网络模型来预测一个花所属的种类。
2. 作业已完成部分和未完成部分 该作业已经全部完成，没有未完成的部分。全部代码我已经放在GitHub上和colab上了，可以点击下面的链接进行跳转。
GitHub For DNNColab For DNN 3. 作业运行结果截图 最后得出使用深度神经网络的模型预测的准确率为 95.555 % 95.555\% 95.555%
4. 核心代码和步骤 4.1 第一步将数据集读入 4.1.1 原始的数据集 data.txt 部分截图： 稍微进行改动一下（添加了属性列并将格式转换为.csv）
4.1.2 修改后的数据集 data.csv 部分截图 4.1.3 将 data.csv 读入并且将其存入标识符 df 中，定义数据集的筛选条件 expr_1;expr_2;expr_3 expr_1: 用于赛选 Category 属性列为 iris-setosa 的类 sql 语句expr_2: 用于赛选 Category 属性列为 Iris-versicolor 的类 sql 语句expr_3: 用于赛选 Category 属性列为 Iris-virginica 的类 sql 语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1b91626cb789e00ff654eab603f8658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd2835f112c78ec4de9632bf6292eff/" rel="bookmark">
			【Linux】Firewalld防火墙新增端口、开启、查看等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Linux操作系统中，Firewalld防火墙相关操作如下：
安装 yum install firewalld firewalld-config Firewall开启常见端口命令
新增端口： firewall-cmd --zone=public --add-port=80/tcp --permanent firewall-cmd --zone=public --add-port=443/tcp --permanent firewall-cmd --zone=public --add-port=22/tcp --permanent firewall-cmd --zone=public --add-port=21/tcp --permanent firewall-cmd --zone=public --add-port=53/udp --permanent 关闭端口 firewall-cmd --zone=public --remove-port=80/tcp --permanent firewall-cmd --zone=public --remove-port=443/tcp --permanent firewall-cmd --zone=public --remove-port=22/tcp --permanent firewall-cmd --zone=public --remove-port=21/tcp --permanent firewall-cmd --zone=public --remove-port=53/udp --permanent 防火墙常见操作 # 启动防火墙 systemctl start firewalld.service # 重启防火墙，添加或删除之后需要重启 firewall-cmd --reload # 或者 service firewalld restart # 查看端口列表 firewall-cmd --permanent --list-port # 禁用防火墙 systemctl stop firewalld # 查看状态 systemctl status firewalld # 或者 firewalld-cmd --state 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e81cb3b1d93db395b506a660c6dc1800/" rel="bookmark">
			微信小程序--多种类型日期选择器（年月、月日...）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题
微信小程序--多种类型日期选择器（年月、月日...）
时间选择器（年月日）
时间选择器（年月）
时间选择器（年）
时间选择器（月日）
时间选择器（月）
时间选择器（日）
微信小程序–多种类型日期选择器（年月、月日…）
在业务开发的过程中，有许多对picker选择器的使用场景，根据开发需要列出了几种常见的类型，可供大家共同参考、学习
时间选择器（年月日）
效果图：
wxml：
&lt;picker mode="date" header-text="选择时间" value="{{date}}" bindchange="bindDateChange"&gt; &lt;view class="font30"&gt; &lt;text class="color3"&gt;填报时间：&lt;/text&gt; &lt;text class="color6"&gt;{{date}}&lt;/text&gt; &lt;text class="timeIcon"&gt;▼&lt;/text&gt; &lt;/view&gt; &lt;/picker&gt; js
data:{ date:'2021-01-01', }, bindDateChange: function(e) { console.log('picker发送选择改变，携带值为', e.detail.value) this.setData({ date: e.detail.value }) }, wxss
.font30{ font-size: 30rpx; } .color3{ color: #333; } .color6{ color: #666; } .timeIcon{ color:#666; font-size:18rpx; margin-left: 5rpx; } 时间选择器（年月） 效果图：
wxml：
&lt;picker mode="date" header-text="选择时间" fields="month" value="{{date}}" bindchange="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e81cb3b1d93db395b506a660c6dc1800/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e5673fa9fa0c4291b8cd5a44f1f40e/" rel="bookmark">
			十进制整数转二进制数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		十进制整数转二进制数
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % 函 数 名：dec_2_bin % 功 能：十进制整数转二进制数 % 输入参数： % % 1.参数dec：十进制数 % % 2.参数width：用多少位宽表示二进制数 % 输出参数： % % 1.参数BIN：求得的二进制数 % % 2.参数flag1： % % 作 者： % 日 期： % 版 本： % % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % function BIN = dec_2_bin(dec,width) BIN = zeros(1,width); for i=0:width if dec==0 BIN = zeros(width); real = 0; break elseif 2^i&gt;=dec real = i; BIN(real) = 1; real = real -1; dec = dec-2^(real); break elseif 2^i==dec real = i+1; BIN(real) = 1; real = real-1; dec = dec-2^real; break end end while real&gt;=1 if 2^(real-1)&gt;dec BIN(real) = 0; real = real-1; elseif 2^(real-1)&lt;dec BIN(real) = 1; real = real-1; dec = dec-2^real; elseif 2^(real-1)==dec BIN(real) = 1; if real&gt;1 BIN(1:real-1) = 0; end break end end for i=1:width BIN_real(i) = BIN(width+1-i); end BIN = BIN_real; end 十进制数转为二进制补码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32e5673fa9fa0c4291b8cd5a44f1f40e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb5a525dee99c92f52328c12f5a41e49/" rel="bookmark">
			第一次数学建模赛后总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，这里是七七。
前些日子参加了一次数学建模比赛，赛后总结了一下，发现有很多事情是到了动手操作的时候，才发现问题的。总结了一下，有以下几点。
一、准备 在赛前准备阶段只傻傻的准备了很多学校给我们列举的数学模型和方法，但当到了比赛中时，就发现准备的模型没有用上，相反，用到的只是几个以前没有接触过的模型。思考之后，发现导致出现这样的情况是由于没有去优先掌握主流的模型。
要先去掌握主流模型
二、分工 在准备阶段每个人都有自己的分工，但在比赛时团队的分工在比赛时很不明确，写代码的配合查资料，很乱。分析之后，发现是准备阶段出了些问题。准备阶段每个人真被的东西都是大致相同的，而没有去有针对性的去准备自己应该负责的东西。因此之后应在准备阶段有明确的准备目标。
分工一定要明确，在准备阶段每个人有针对性的准备自己负责的东西
三、实践与理论 学习理论要配合实践，这一点这次算是用事实来告诉我了。准备阶段每个人都只分析某些模型以及一些例子，但没有人实际操作完成某个模型。以为知道了就可以。但在实际操作中，总是会出现这样那样意料之外的问题。对此，解决办法是在以后准备阶段直接准备具体实例，一定要去实现。不知道的理论去查查，不求多少量，但一定要把实例给复现出来。
用实例去学习理论。实例一定要能自己给复现出来
四、工具 赛前以为用matlab就可以了。实际上，python和spss等工具在某些方面具有得天独厚的优势。在比赛中学习使用是很托节奏的。
要多掌握一些工具，并知道它们哪些方面是优势
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e04c878fdc65e33c92e908d0d0d2d72a/" rel="bookmark">
			【Python】人工智能-机器学习——不调库手撕贝叶斯分类问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 作业内容描述 1.1 背景 数据集大小150该数据有4个属性，分别如下 Sepal.Length：花萼长度(cm)Sepal.Width：花萼宽度单位(cm)Petal.Length：花瓣长度(cm)Petal.Width：花瓣宽度(cm)category：类别（Iris Setosa\Iris Versicolour\Iris Virginica) 1.2 要求 在不调用机器学习库的情况下，使用贝叶斯分类来预测一个花所属的种类。
2. 作业已完成部分和未完成部分 该作业已经全部完成，没有未完成的部分。全部代码我已经放在GitHub上和colab上了，可以点击下面的链接进行跳转。
GitHub For BayesianColab For Bayesian 3. 作业运行结果截图 最后得出使用贝叶斯分类的模型预测的准确率为 75 % → 90 % 75\% \to 90\% 75%→90%
4. 核心代码和步骤 4.1 第一步将数据集读入 4.1.1 原始的数据集 data.txt 部分截图： 稍微进行改动一下（添加了属性列并将格式转换为.csv）
4.1.2 修改后的数据集 data.csv 部分截图 4.1.3 将 data.csv 读入并且将其存入标识符 df 中，定义数据集的筛选条件 expr_1;expr_2;expr_3 expr_1: 用于赛选 Category 属性列为 iris-setosa 的类 sql 语句expr_2: 用于赛选 Category 属性列为 Iris-versicolor 的类 sql 语句expr_3: 用于赛选 Category 属性列为 Iris-virginica 的类 sql 语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e04c878fdc65e33c92e908d0d0d2d72a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4062dd9d5d2eed6f62d3582c15ce8e80/" rel="bookmark">
			使用AES ECB加密解密前后端多语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 由于项目需要，要对一些敏感数据进行对称加密、解密，因此在多种加密方式中，选择使用轻便高效的AES算法实现。
加密算法参数 加密模式：ECB填充方式：PKCS5数据块大小：128位密码长度：16或32位偏移量：默认输出：Base64字符集：UTF-8 前端Node.js实现 import CryptoJS from 'crypto-js' /** * 加密 * @param text 明文字符串 * @param secretKey 密钥 * @returns {string} 加密结果 */ function Encrypt(text, secretKey) { let key = CryptoJS.enc.Utf8.parse(secretKey); let srcs = CryptoJS.enc.Utf8.parse(text); let encrypted = CryptoJS.AES.encrypt(srcs, key, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 }); return encrypted.toString(); } /** * 解密 * @param encryptStr 密文 * @param secretKey 密钥 * @returns {string} 明文 */ function Decrypt(encryptStr, secretKey) { let key = CryptoJS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4062dd9d5d2eed6f62d3582c15ce8e80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17549b79c95a63f0799b6acac563b5a/" rel="bookmark">
			供应链生产主计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习生产计划相关内容，以下是整理生产计划流程：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16640bac8f065838ea8e7463b0653898/" rel="bookmark">
			python实现切割mp4视频，按照指定要求截取视频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方法一： 该python代码用以将一长段视频，分割成自己需要的时长段的视频
import cv2 START_HOUR = 0 START_MIN = 0 START_SECOND = 0 START_TIME = START_HOUR * 3600 + START_MIN * 60 + START_SECOND # 设置开始时间(单位秒) END_HOUR = 0 END_MIN = 0 END_SECOND = 11 END_TIME = END_HOUR * 3600 + END_MIN * 60 + END_SECOND # 设置结束时间(单位秒) video = "img/video.mp4" cap = cv2.VideoCapture(video) FPS = cap.get(cv2.CAP_PROP_FPS) # print(FPS) size = (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))) print(size) TOTAL_FRAME = int(cap.get(cv2.CAP_PROP_FRAME_COUNT)) # 获取视频总帧数 frameToStart = START_TIME * FPS # 开始帧 = 开始时间*帧率 # print(frameToStart) frametoStop = END_TIME * FPS # 结束帧 = 结束时间*帧率 # print(frametoStop) videoWriter = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16640bac8f065838ea8e7463b0653898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/521d7923002017df790b5b8c184544ef/" rel="bookmark">
			完全免费白嫖 GPT-4 的终极方案！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章链接 https://my.oschina.net/u/4148359/blog/9870024 免费拿 https://www.forefront.ai/app/chat/new 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f25cb9c72d8d5e1c8c002f41307f5c98/" rel="bookmark">
			vue3 父子组件传参详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：我引用了大佬的文章，但我实在找不到网址链接了，我记录在笔记上的。如果大佬看见了，麻烦给我说一下，我注明一下出处
&gt;关于兄弟组件传参&gt;：Vue3 兄弟传参-CSDN博客
建议先看son.vue 里面写了那四种方式 首先放一个我的demo //defineProps什么的父子传参api不用引入！直接用，内置API
father.vue
&lt;template&gt; &lt;div class="box"&gt; &lt;son-item @fua="fub" :numa="numb" ref="childRef"&gt;&lt;/son-item&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import sonItem from '@/components/son.vue'; import { ref } from 'vue'; let numb = ref(0) const childRef= ref()//注册响应数据！！！！！！！！！！！！！！！！ //一定要注意这句，要去注册ref，不然就不能解析出来了，这是个踩过的坑 let fub = (e)=&gt;{ //第二种方法返回的结果： console.log('这是父组件被动接收的子组件的参数'+e); numb.value++ //第三种方法返回的结果： console.log('这是父组件主动获取的子组件的参数:'+childRef.value.selfNum);//偷了懒，没有单独去写一个方法，反正也是父组件里面的方法，将就用一下 } setTimeout(()=&gt;{ childRef.value.openSon(xxx)//父组件调用子组件方法 并传参xxx给子组件 },1000) &lt;/script&gt; son.vue
&lt;template&gt; &lt;div class="box"&gt; 子组件接收的参数：{{ numa }}&lt;br&gt; 子组件自定义的参数：{{ selfNum }}&lt;br&gt; //打印表里面有父组件主动获取子组件自定义的参数&lt;br&gt; &lt;button @click="fuc"&gt;this is a magic button&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref } from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f25cb9c72d8d5e1c8c002f41307f5c98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69c343ba60d06e8b7d0bd5c201a364de/" rel="bookmark">
			二分法、三分法 --算法竞赛专题解析（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章已经于2022年出版：《算法竞赛》
网购：京东 天猫 当当
作者签名书（有发票） 加微信：13916333036
文章目录 1. 二分法的理论背景 2. 整数二分模板 2.1 基本形式2.2 STL的lower_bound()和upper_bound()2.3 简单例题 3. 整数二分典型题目3.1 最大值最小化（最大值尽量小3.1.1序列划分问题3.1.2 通往奥格瑞玛的道路 3.2 最小值最大化（最小值尽量大） 4. 实数二分4.1 基本形式4.2 实数二分例题 5. 二分法习题6. 三分法求极值6.1 原理6.2 实数三分6.2.1 实数三分习题 6.3 整数三分 二分法和三分法是算法竞赛中常见的算法思路，本文介绍了它们的理论背景、模板代码、典型题目。
1. 二分法的理论背景 在《计算方法》教材中，关于非线性方程的求根问题，有一种是二分法。
方程求根是常见的数学问题，满足方程：
f(x) = 0 (1-1)
的数x’称为方程(1-1)的根。
所谓非线性方程，是指f(x)中含有三角函数、指数函数或其他超越函数。这种方程，很难或者无法求得精确解。不过，在实际应用中，只要得到满足一定精度要求的近似解就可以了，此时，需要考虑2个问题：
（1）根的存在性。用这个定理判定：设函数在闭区间[a, b]上连续，且f(a) ∙ f(b) &lt; 0,则f(x) = 0存在根。
（2）求根。一般有两种方法：搜索法、二分法。
搜索法：把区间[a, b]分成n等份，每个子区间长度是∆x，计算点xk = a + k∆x (k=0,1,2,3,4,…,n)的函数值f(xk)，若f(xk) = 0，则是一个实根，若相邻两点满足f(xk) ∙ f(xk+1) &lt; 0，则在(xk, xk+1)内至少有一个实根，可以取(xk+ xk+1)/2为近似根。
二分法：如果确定f(x)在区间[a, b]内连续，且f(a) ∙ f(b) &lt; 0，则至少有一个实根。二分法的操作，就是把[a, b]逐次分半，检查每次分半后区间两端点函数值符号的变化，确定有根的区间。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69c343ba60d06e8b7d0bd5c201a364de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e9e7e3bcbe39d8b5ee3e9ab3b19c62e/" rel="bookmark">
			数据结构 | Log-Structured Merge Tree (LSM Tree)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天介绍LSM Tree这个数据结构，严格意义上来说，他并不像他的名字一样是一棵树型的数据结构，而更多是一种设计思想。
LSM Tree最先在1996年被提出，后来被广泛运用于现代NoSQL（非关系型数据库）系统中，包括BigTable, Dynamo, HBase, Cassandra, LevelDB, RocksDB, and AsterixDB.
LSM Tree主要是瞄准了IO操作中，顺序写的速度比随机写快几个数量级的特点，采用out-of-place 更新的特性，将随机写入累积到顺序写入，以利用存储设备的高顺序写入带宽。
那他是怎么做到的呢？实际上设计上其实也相当的简单粗暴。
LSM Tree通过将写入操作集中在内存中，并定期将数据合并到持久性存储介质（如磁盘）上，实现了高吞吐量的写入和高效的查询性能。LSM Tree引入了“组件”的概念，组件是指存储数据的单元或数据结构，它们按照特定规则组织和管理数据。
组件根据其存在于内存中或是磁盘中，被划分为：
1. 内存组件（Memory Component）：LSM树通过内存组件（也称为memtable）存储最近写入的数据。内存组件通常是一个有序的数据结构（如平衡树或跳表），它提供快速的写入和查询操作。写入操作首先在内存组件中进行，以实现低延迟的写入性能。
2. 磁盘组件（Disk Component）：当内存组件达到容量限制或触发某些条件时，LSM树将内存组件中的数据刷新到磁盘组件中。磁盘组件通常是一系列按键有序存储的文件（SSTable），其中每个文件称为一个层级（level）。较新的数据存储在较高的层级，而较旧的数据存储在较低的层级。每个层级的文件都是顺序写入的。磁盘组件之间的数据合并操作以保持数据的有序性和紧凑性。
因此，不难看出，无论是在内存组件还是磁盘组件，LSM Tree都是使用有序的数据结构实现的，这也是为什么说LSM Tree是一种设计思想，而不是一个具体的数据结构的原因，在内存组件中，C0 tree可以采用B+树、红黑树等数据结构实现，他们可以被随机访问，直接修改，内存组件由于存在于内存中，访问快但容量小。在内存组件满或某些条件触发时，从内存组件中刷到磁盘组件中，因此，就起到了将随机写整合为顺序写的效果。
LSM Tree的查询过程
1. 首先进行内存查询：首先，查询操作会在内存组件（如memtable）中进行。由于内存组件是一个有序的数据结构，可以使用二分查找或其他高效的查找算法来定位所需的键。如果找到了匹配的键，则返回对应的值。如果在内存组件中未找到匹配的键，查询将继续进入下一个阶段。
2. 内存缺失时磁盘查询：如果在内存组件中未找到匹配的键，查询将继续在磁盘组件中进行查找。LSM树的磁盘组件通常由多个层级的文件组成，其中较新的数据存储在较高的层级，较旧的数据存储在较低的层级。
LSM Tree的增删改过程
LSM Tree的增删改过程都在内存中进行，按照内存中的有序结构的方式进行增加操作，删除过程同样都可以视作“增”，对于删除操作，在内存中将关键字打上标记，这样，在合并过程中，该key就会被忽略，从而实现删除的效果。
LSM Tree的合并过程
将高一层级的LSM Tree合并到第一层级会触发合并（也可以叫压缩），LSM树会从每个层级中选择一组候选文件进行合并。通常，合并操作从较高层级开始，逐渐向下进行。选择候选文件的策略可以根据不同的实现和需求而有所不同，常见的策略包括选择最旧的文件、选择文件大小最接近某个阈值的文件等。选定的候选文件会按照键的顺序进行排序。这可以通过一次性读取文件中的数据，并使用外部排序算法（如归并排序）来实现。排序后的数据将成为合并操作的输入。合并操作会将排序后的数据合并到一个新的文件中。新文件通常位于较低层级。合并操作的目标是保持数据的有序性和紧凑性。它会逐个比较排序后的键值对，并根据键的顺序将它们写入新文件。如果有重复的键，则通常选择最新的键值对作为合并结果。合并后的新文件可能会包含一些重复的键值对或已标记为删除的数据。为了优化存储空间，可以进行压缩操作。压缩操作会移除重复的键值对、删除标记和其他冗余数据，以减少文件的大小。压缩操作通常在合并操作之后进行，以避免对正在合并的数据产生冗余的压缩开销。
多Level LSM Tree
LSM Tree可以具有多个磁盘组件（似乎在后面的实现中往往只有一种），称为多组分LSM树（Multi-component LSM-trees）是LSM树的一种变体，它引入了多个组件类型以优化存储和查询性能。
在传统的LSM树中，通常只有两种组件类型：内存组件和磁盘组件。然而，多组分LSM树引入了额外的组件类型，以更好地适应不同的工作负载和性能需求。
多组分LSM树的主要组件类型包括：
内存组件（memtable）：内存组件是多组分LSM树中的一个重要组成部分，它与传统LSM树中的内存组件相同。它存储最近的写入操作，并提供快速的插入和查询性能。与传统LSM树不同的是，多组分LSM树中的内存组件可以具有不同的配置和特性，以适应不同类型的数据和查询负载。
热存储组件（hot storage component）：热存储组件是多组分LSM树中的一种组件类型，用于存储频繁访问的热数据。热存储组件可以位于内存或者高性能的存储介质上，以提供更快的查询响应时间。它通常用于存储最常访问的数据，以减少查询延迟。
冷存储组件（cold storage component）：冷存储组件用于存储不经常访问的冷数据。这些组件通常位于较低性能的存储介质上，如磁盘或者低成本的云存储。冷存储组件可以容纳大量的数据，并提供较低的存储成本，但查询性能可能相对较低。
归档存储组件（archive storage component）：归档存储组件用于长期存储和归档数据，这些数据很少被访问。归档存储组件通常采用高度压缩的格式，以减小存储空间的占用。这些组件通常位于持久性存储介质上，如冷存储或者备份存储。
多组分LSM树通过引入不同类型的组件，根据数据的访问模式和性能需求，将热数据存储在高性能组件中，而将冷数据存储在较低性能组件中。这样可以提高查询性能和存储效率，同时满足不同类型的数据访问需求。
LSM Tree的异地更新特性
传统的索引结构通常采用in-place更新策略，即直接覆盖旧记录来存储新的更新。而LSM树采用了out-of-place更新策略，即始终将更新存储在新的位置，而不是直接覆盖旧条目。
LSM树的out-of-place特性带来了一些优势。首先，它提高了写入性能，因为可以利用顺序I/O来处理写入操作。相比之下，传统的in-place更新结构需要进行随机的I/O操作，影响写入性能。其次，out-of-place特性简化了恢复过程，因为它不会覆盖旧数据，可以更容易地进行数据恢复。此外，LSM树的out-of-place特性还允许对数据进行可调整的并发控制和高空间利用率的管理。
然而，out-of-place特性也带来了一些挑战。由于记录可能存储在多个位置，读取性能可能会受到影响。此外，LSM树通常需要进行单独的数据重新组织过程，以持续改善存储和查询的效率。
LSM树的out-of-place特性是其设计的关键部分，它使LSM树成为现代NoSQL系统中存储层的重要组成部分，并为各种工作负载提供了高性能和高效的存储管理。
如何继续优化LSM Tree
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e9e7e3bcbe39d8b5ee3e9ab3b19c62e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52c817be7ec3624fdb1cbfa53001d12/" rel="bookmark">
			C&#43;&#43;求解01背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 你是一个探险家，有一天，你在某个神秘的洞穴中发现N件珠宝，每件珠宝上写着其重量wi和价值vi。由于你发现得比较晚，这个地方随时会出现塌陷等事故，这事你就得考虑把一部分珠宝放入你的随身背包中带走，以便不虚此行。但是，由于你个子吃紧，最多可以带走的珠宝总重量不超过W，那你将如何挑选呢？
输入格式 第一行：N M，表示N件珠宝，你的承重能力W
接下来是N行，每行输入wi vi，表示第i件珠宝的单重和单价
输出格式 一行，表示你能带走珠宝的最佳方案所能达到的价值
示例 输入
【3件珠宝，10总承重】
【珠宝重量[9,5,5]】 【珠宝价值[9,5,5]】
3 10 9 9 5 5 3 5 输出
【应该挑第2件和第3件珠宝带走，总重量8小于自身承重，总价值10】
10 代码 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cmath&gt; using namespace std; int main() { int N,W; cin&gt;&gt;N&gt;&gt;W; vector&lt;int&gt; w(N+1,0); vector&lt;int&gt; v(N+1,0); for(int i=1; i&lt;=N; i++) { cin&gt;&gt;w[i]&gt;&gt;v[i]; } vector&lt;vector&lt;int&gt; &gt; res(N+1,vector&lt;int&gt;(W+1,0)); for(int i=1; i&lt;=N; i++) { for(int j=0; j&lt;=W; j++) { if(j&lt;w[i]) { res[i][j]=res[i-1][j]; } else { res[i][j]=max(res[i-1][j],res[i-1][j-w[i]]+v[i]); } } } cout&lt;&lt;res[N][W]&lt;&lt;endl; return 0; } 运行结果 3 10 9 9 5 5 3 5 10 -------------------------------- Process exited after 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b52c817be7ec3624fdb1cbfa53001d12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf712a596f5ad97e9a74daf4aba83686/" rel="bookmark">
			20231213给Ubuntu18.04.6LTS新加一块HDD机械硬盘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		20231213给Ubuntu18.04.6LTS新加一块HDD机械硬盘
2023/12/13 22:50
rootroot@rootroot-X99-Turbo:~$ cat /etc/issue
Ubuntu 18.04.6 LTS \n \l
sudo fdisk -l
rootroot@rootroot-X99-Turbo:~$ rootroot@rootroot-X99-Turbo:~$ sudo fdisk -lu
Disk /dev/sda: 2.7 TiB, 3000592982016 bytes, 5860533168 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 4096 bytes
I/O size (minimum/optimal): 4096 bytes / 4096 bytes
sudo mkfs -t ext4 /dev/sdb
rootroot@rootroot-X99-Turbo:~$ df -l
rootroot@rootroot-X99-Turbo:~$ df -h
rootroot@rootroot-X99-Turbo:~/3TB$ ls -l /dev/disk/by-uuid/ lrwxrwxrwx 1 root root 15 12月 13 18:50 1EA81334A8130A43 -&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf712a596f5ad97e9a74daf4aba83686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35dc42801d463622f1db47b9121a929e/" rel="bookmark">
			AD20的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、AD设置1.1 更新设置1.2 优选项设置 二、常用快捷键三、常用小技巧3.1 迅速查找元器件3.2 在PCB高亮显示 四、工程创建4.1 创建工作区4.2 创建库文件 五、库文件制作5.1 封装库制作5.2 原理图库制作 六、原理图操作6.1 调整原理图版面大小6.2 放置元件6.3 元器件连接6.4 修改参数 七、PCB操作7.1 导入元件7.2 画板边框7.3 元器件布局7.4 PCB规则约束器7.5 元件布线7.5.1 布线过程中层的切换7.5.2 手动画线7.5.3 自动画线7.5.4 焊盘和过孔 7.6 敷铜 前言 介绍Altium Designer20的基本配置，与常规操作
一、AD设置 1.1 更新设置 Extensions and Update（在右上角）—— Configure… —— 勾选后Apply
1.2 优选项设置 右上角设置按钮
1.System
（1）切换中文显示
System —— General —— 勾选使用本地资源 —— （关闭重启AD）
（2）设置默认路径
System——Default Locations
（3）关闭开始出现Home page界面
System —— General —— Startup —— 取消勾选OpenHome page on start
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35dc42801d463622f1db47b9121a929e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6028c7fda663416a80dea27d6ae9eda6/" rel="bookmark">
			grpc 返回错误8, 资源不足
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在client调用server的过程中发生了错误8，资源不足 通常由于grpc传递的数据量太大导致，grpc 默认通信长度为 4M( 4 * 1024 * 1024 )， 而我们传递的数据长度将近50Mb。所以需要调整服务端接收消息的最大长度
grpc::ServerBuilder builder; builder.SetMaxReceiveMessageSize(1024*1024*60);//设置服务端接收最大60Mb builder.AddListeningPort(g_host.c_str(), grpc::InsecureServerCredentials()); builder.RegisterService(&amp;service); grpc状态码查阅 grpc Status codes链接点我
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6c59ff154ee376ba36d8793cbefd329/" rel="bookmark">
			服务器环境copy时，报错：bash ./miniconda3/envs/nn/bin/pip：./miniconda3/envs/nn/bin/python 3.7：解释器错误: 没有那个文件或目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接copy 208服务器 下的环境到 110服务器上
问题 在安装依赖时报错：
bash:/media/hyq/miniconda3/envs/nn/bin/pip：/home/hyq/hyq/miniconda3/envs/nn/bin/python3.7：解释器错误: 没有那个文件或目录
解决 vim /media/hyq/miniconda3/envs/nn/bin/pip 修改第一行的路径为：/media/hyq/miniconda3/envs/nn/bin/python3.7
注意！！！虽然第一行写着#！但是这个路径并不是注释掉的意思，因此我们需要将路径修改成 /media/hyq/miniconda3/envs/nn/bin/python3.7 即可。
注： #! 是 Unix/Linux 里面用于指示脚本解释器的特定语法，位于脚本中的第一行，以 #! 开头，接着是该脚本的解释器，通常是 /bin/bash、/usr/bin/python 之类
参考：
pip / conda有关 “解释器错误: 没有那个文件或目录” 的解决办法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9af59ba9b1cfb501caec7556ff764cc/" rel="bookmark">
			Vue3安装使用Mock.js--解决跨域
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先使用axios发送请求到模拟服务器上，再将mock.js模拟服务器数据返回给客户端。打包工具使用的是vite。
1.安装 npm i axios -S
npm i mockjs --save-dev
npm i vite-plugin-mock --save-dev
2.在vite.config.js文件中配置vite-plugin-mock等消息 import { viteMockServe } from 'vite-plugin-mock' plugins: [vue(), viteMockServe({ supportTs:true, logger: false, mockPath: "./mock/" // 注意：此时的 mockPath 地址是真正安装的 mock 文件夹的地址; }) ] 3.在根目录下创建mock文件夹及index.js文件： 4.在index.js文件中进行配置： import Mock from 'mockjs' const listUser = function() { const a = Mock.mock({ 'list|1-20':[{ 'userId|+1':0, 'userName|1':["张三",'李四',"鲍勃","丽丽","李阳","杨洋","王五","周星星","大仙","孤影"], 'role|1':["系统管理员","操作人员","销售","平台管理者","仓库管理员","部长"], }] }) return a; } export default [ { url:'/hello', method:'get', response: () =&gt; { return listUser; } } ] 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9af59ba9b1cfb501caec7556ff764cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95a68b1fe322854f5642af090cbb5bbf/" rel="bookmark">
			CTF比赛必备常用工具（附下载方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文中介绍的所有工具，均在压缩包中，结合本文更便于大家下载使用，快速上手。
CTF常用工具下载
CTF比赛必备常用工具 一、什么是CTF二、比赛中工具的重要性三、常用MISC（杂项）工具 1. Audacity （提取莫斯密码辅助工具）2. stegsolve （图片隐写分析工具）3. QR_Research （二维码工具）4. ZipCenOp.jar(验证是否为伪加密工具)5. AAPR(rar密码破解工具)6. Ziperello(zip密码破解工具)7.Winhex(程序查看调试工具)8. RouterPassView(路由器配置查看工具) 四、常用REVERSE（逆向）工具 1. ExeinfoPe （判断软件版本和是否有壳）2. IDA64位3. IDA32位 五、ctf常用扫描字典 一、什么是CTF 在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。
主要包括六大类：PWN、CRYPTO(解密)、REVERSE（逆向）、WEB、MISC(杂项)
其中，REVERSE（逆向）和MISC(杂项)，在比赛中要使用大量的辅助工具，才能快速解题。本文章也主要聚焦这两类赛题的工具。
二、比赛中工具的重要性 有参加过CTF比赛的小伙伴们都知道，在比赛中分秒必争，却又毫无头绪的时候，一款合适的工具往往能直接决定比赛的成绩。
对很多初次接触CTF的小伙伴们就更是这样。题目本身就有难度，如果我们连基础工具都没有，那第一步找问题点都会很困难，就更不要提解题了。
本文就给大家介绍几款CTF比赛中常用的工具，
文中介绍的所有工具，均在压缩包中，结合本文更便于大家下载使用，快速上手。
[CTF常用工具下载]
文中介绍的都是常用且基础的工具 ，也许你还有更好更强大的工具，不妨分享出来，共同学习进步。但比赛前，各位同学电脑上还没有本文介绍的基础工具，那还是草率了些，哈哈。
三、常用MISC（杂项）工具 1. Audacity （提取莫斯密码辅助工具） 题目中遇到音频文件，听到长短不一的声音，往往就是摩斯密码题了，你还傻傻靠自己耳朵听几长几短吗？别做梦了，你不是间谍，搞不定的。仅需将文件拖进这个软件，如下图，一目了然。
2. stegsolve （图片隐写分析工具） 此款软件，非常常用，建议下载后，网上搜索学习如何使用。
简单介绍就是：选中可疑图片打开。利用四个功能，查看图片中隐藏的各种信息。
打开可疑动图
因为是动图，选择逐帧查看，果然发现在21帧开始陆续隐藏了信息
（）
3. QR_Research （二维码工具） 查找二维码信息的工具，选取工具中截图查看二维码
4. ZipCenOp.jar(验证是否为伪加密工具) 有些压缩包是伪加密的。表现形式是压缩包需要解压密码，但是破解工具又找不到密码。如果是伪加密，其实只要修改hex文件中某位为偶数，即可无密码打开。具体原理可以自行搜索。（如何修改详见下文Winhex工具的介绍）
5. AAPR(rar密码破解工具) rar压缩包是加密的打不开，不要紧，使用此工具，轻松破解
6. Ziperello(zip密码破解工具) 使用方式与上面的软件类似，不过这个速度更快，接近准工业级的破解速度了，非常惊人。
7.Winhex(程序查看调试工具) 使用很简单，将文件拖进winhex即可。如上题，将伪加密压缩包拖进这个文件，修改hex（奇数改为偶数即可），破解加密防护。
修改前 最后蓝线09 00
修改后 08 00 然后另存为一个压缩吧，直接打开，不再需要密码。伪加密的压缩包就是这么纸老虎，仅此而已。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95a68b1fe322854f5642af090cbb5bbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adb3371b2c9b22b915cf88606f188682/" rel="bookmark">
			Postman-脚本自动化及定时执行脚本（7）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.postman脚本自动化（从postman至Newman可以一键执行脚本并生成报告：）
Postman Newman 是一个 CLI（命令行界面）工具，可以使用它来运行 Postman 中的集合（Collection）和环境（Environment）进行自动化测试。postman使用newman插件完成命令执行postman脚本。﻿**(1)newman按装**
﻿1.Newman安装
﻿步骤&lt;1&gt;：首先安装nodejs
a.下载nodejs:https://nodejs.cn/download/
b.“傻瓜式”安装
c.安装完成通过cmd执行如下指令验证是否安装成功（显示版本号，即安装成功）
D:\nodejs&gt;node -v v20.10.0 D:\nodejs&gt;npm -v 10.2.3 步骤&lt;2&gt;：newman安装
a.cmd执行以下指令：
npm install -g newman b.安装完成后执行以下指令，验证是否安装成功（安装成功显示版本号）
D:\nodejs&gt;newman -v 6.0.0 步骤&lt;3&gt;：测试报告安装
a.执行以下命令
npm install -g newman-reporter-html b.安装完成显示如下
补充：安装测试报告或newman时一直停止不动
解决方案：
更换下载源为路径为淘宝，执行以下指令：
npm config set registry https://registry.npm.taobao.org ```javascript 配置后可通过以下指令来验证下载源是否更新成功（然后重新执行newman或测试报告安装相关指令） ```javascript npm config get registry 2.newman相关指令（持续集成——报告）
a.Newman指令格式：newman run 脚本名 -e 环境变量名 -g 全局变量名 -d 数据驱动文件名 -r cli,html,json,junit --reporter-html-export 报告名
-e、 --environment＜path＞指定Postman环境的URL或路径 -g、 --globals＜path＞指定包含Postman globals的文件的URL或路径 **-r**、 --报告程序[报告程序]指定用于此运行的报告程序（默认值：[“cli”]） -n、 --迭代次数&lt;n&gt;定义要运行的迭代次数 **-d**、 --迭代数据＜path＞指定用于迭代的数据文件（JSON或CSV） --folder&lt;path&gt;指定要从集合中运行的文件夹。可以多次指定为 运行多个文件夹（默认值：[]） --global var＜value＞允许通过命令行指定全局变量，在 key=值格式（默认值：[]） --env-var＜value＞允许通过命令行在 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adb3371b2c9b22b915cf88606f188682/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/366282c6ac1c1633c6e603891547d879/" rel="bookmark">
			Linux救援：开机进不了系统，显示”GRUB＞”命令提示符的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux系统中，GRUB是一个常见的启动加载器，负责加载系统的内核和初始文件系统。
然而，当出现某些错误时，系统可能会在开机时出现”GRUB&gt;”命令提示符，而无法正常启动。
在本文中，我们将介绍如何修复这种情况。
了解GRUB和问题原因 首先，我们需要了解什么是GRUB，以及为何会出现”GRUB&gt;”提示符。
GRUB是Grand Unified Bootloader的简写，是一个多操作系统启动程序。
当你看到”GRUB&gt;”提示符时，通常表示GRUB无法找到正常的配置文件，因此进入了命令行模式。
找出正确的启动设备和分区 在”GRUB&gt;“提示符下，我们可以使用”ls”命令来查看可用的设备和分区。例如：
grub&gt; ls (hd0) (hd0,msdos2) (hd0,msdos1) 在这个例子中，(hd0)表示第一个硬盘，(hd0,msdos2)和(hd0,msdos1)表示该硬盘上的第二个和第一个分区。
手动启动Linux系统 首先用ls查看存在vmlinuz文件和initramfs文件的分区目录：
grub&gt; ls (hd0,msdos1)/ 以上截图说明是(hd0,msdos1)；
一旦我们找到了正确的设备和分区，我们就可以手动启动系统。以下是一个示例步骤：
grub&gt; set root=(hd0,msdos1) grub&gt; linux /vmlinuz-3.10.0-1160.el7.x86_64 root=/dev/sda1 grub&gt; initrd /initramfs-3.10.0-1160.el7.x86_64.img grub&gt; boot 这些命令的含义如下：
设置root设备为(hd0,msdos1)。
加载/vmlinuz内核，设定根文件系统为/dev/sda1。
3.10.0-1160.el7.x86_64为所用的内核版本，需视情况改成对应版本，根文件系统也需视情况改为对应目录。
加载初始RAM磁盘镜像/initrd.img。
启动系统。
ps:linux和initrd命令用于传统模式下加载 32 位或 64 位 Linux 内核。在大多数情况下，你应该使用 linux 命令来启动你的 Linux 系统，如果内核是16位的，则需要使用linux16和initrd16命令；
ps:在 EFI 系统上，启动过程与传统的 BIOS 系统有所不同，因此需要使用特定的命令来加载，需要把命令换成linuxefi和initrdefi命令；
linuxefi用于在 EFI（可扩展固件接口）系统上加载 64 位 Linux 内核。
initrdefi：这个命令用于在 EFI 系统上加载 initramfs。
修复GRUB 如果能够成功手动启动系统，那么接下来我们就可以修复GRUB。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/366282c6ac1c1633c6e603891547d879/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9bf771f6945bc0c9d16527e27fc113/" rel="bookmark">
			SQL数据库基础语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		插入语句（增） 插入语句基本语法：insert into 表名（列名，列名） values（值，值） 2、插入多行数据（在此语句中不能使用default默认关键字）：
insert into 表名（列名） select 列名对应的数值
union
select 列名对应的数值
例：insert A (ID,name,sex) select 1,’闪闪',’女’ union
select 2,’珊珊',’女’ union
select 3,’潸潸',’女’ union
select 4,’讪讪',’女’ 把查询结果放到一个新表中：select......into （例-将旧表中，女生的信息插入到新表中：select * into新表 from旧表 where sex=‘女’）
（注：使用select......into......语句向表中添加数据时，这个表必须是原数据库中不存在的新表，否则会出现错误）
删除语句（删） 删除语句基本语法：delete from 表名 where 判断条件 删除表中所有数据： (1) delete from 表名 DELETE语句删除的是一整行数据，而不是删除某列数据，因此DELETE关键字和FROM关键字之间不能放列名
(2) truncate table 表名
执行速度更快，使用的系统资源和事务日志更少；有外键约束的数据表不能使用 truncate table
删除表：drop table 表名 更新语句（改） 更新语句基本语法：update 表名 set 列名=值 where 判断条件
在使用update修改数据时一定要注意where语句约束修改范围，当where子句省略时，则修改表中的所有行。
例：将A表中ID为1的记录的姓名改为“潸潸”—update A set name=’潸潸’ where ID=1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f9bf771f6945bc0c9d16527e27fc113/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edc0ab3e08ce9377f1ce3cdaeb68443/" rel="bookmark">
			29. 深度学习进阶 - 卷积的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hi,你好。我是茶桁。
在结束了RNN的学习之后，咱们今天开始来介绍一下CNN。
CNN是现代的机器深度学习一个很核心的内容，就假如说咱们做图像分类、图像分割，图像的切分等等。
其实这些过程就是你让计算机能够自动识别，不仅能够识别图像里有什么，还能识别图像里这些东西分别是在什么地方。这种复杂操作其实都是基于啊CNN的变体。要给计算机有识别图像的能力。
再比方说大无人驾驶汽车，它要识别行人在哪里。
再比如安防的摄像头，要能够检测出来我们人在哪里。
这些事情背后都是计算机视觉的问题。
大概一九五几年、六几年的时候，哈佛大学曾经做过一个研究，给猫的大脑上装了一些电极，让这个猫去看前面的一个幻灯片，然后通过切换幻灯片的内容，然后观察猫的大脑哪些地方活跃。
就发现两个特点，第一个它有一种一层一层的特性，比方说我换了颜色，它固定的就这几层会活跃，离眼睛远的地方会活跃。如果换了线条，颜色没变，会是另外的一层区域会活跃，不同层其实对于不同的特定变化是不一样的。
第二个发现，越靠近眼睛的地方，越低级的层次的变化会越明显，比如线条颜色。眼睛越远的距离，线条和颜色没变，但是眼睛变大了或者变小了，那么这些地方它会更明显。
也就是说，第一个它是有分层的，第二个，它不同的这个层的抽象性是不一样的，对于什么东西的感受力是不一样的。
沿着这个思路，人们当时就提出来了一些方法。当时人们做计算机视觉，主流不是机器学习。但是人们提出来一个一个这样的filter：
filter = np.array([ [1, 0, -1], [1, 0, -1], [1, 0, -1] ]) 这样的filter是人刻意的，主观的提出来的。他们把这个filter去应用到一个一个的图像上。
比方说我们的图像是a b c d e f g h i j k l，然后按4*4的矩阵相乘，再加起来，比如 a w + b x + e y + f z aw+bx+ey+fz aw+bx+ey+fz，这样就得到了一个新的内容。大家把这个操作就叫做卷积操作。
看个示例：
import numpy as np image = np.array([ [10, 10, 10, -3, -3, -3], [10, 10, 10, -3, -3, -3], [10, 10, 10, -3, -3, -3], [10, 10, 10, -3, -3, -3], [10, 10, 10, -3, -3, -3], [10, 10, 10, -3, -3, -3], ]) plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edc0ab3e08ce9377f1ce3cdaeb68443/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93db09936e3fb8f7eb423b00e9069074/" rel="bookmark">
			为pixhawk4添加外置adis16470传感器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译驱动
make px4_fmu-v5_default boardconfig 在MavLink控制台
adis16470 start -S 可以看到IMU3
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33e1d7adbc0618c4b8e4c3140340586f/" rel="bookmark">
			TensorRT基础知识及应用【学习笔记（十）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、准备知识1.1 环境配置A. CUDA DriverB. CUDAC. cuDNND. TensorRT 1.2 编程模型 二、构建阶段2.1 创建网络定义2.2 配置参数2.3 生成Engine2.4 保存为模型文件2.5 释放资源 三、运行时阶段3.1 反序列化并创建Engine3.2 创建一个ExecutionContext3.3 为推理填充输入3.4 调用enqueueV2来执行推理3.5 释放资源 四、编译和运行 一、准备知识 NVIDIA® TensorRT™是一个用于高性能深度学习的推理框架。它可以与TensorFlow、PyTorch和MXNet等训练框架相辅相成地工作。
1.1 环境配置 A. CUDA Driver 使用CUDA前，要求GPU驱动与cuda 的版本要匹配，匹配关系如下：
参考：https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#cuda-major-component-versions__table-cuda-toolkit-driver-versions
检查机器建议的驱动 有recommended这一行中的是系统推荐安装的nvidia-driver-525驱动版本
$ ubuntu-drivers devices // 比如我的机器输出如下 (base) enpei@enpei-ubutnu-desktop:~$ ubuntu-drivers devices == /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 == modalias : pci:v000010DEd00001C03sv000010DEsd000011D7bc03sc00i00 vendor : NVIDIA Corporation model : GP106 [GeForce GTX 1060 6GB] driver : nvidia-driver-525 - distro non-free recommended driver : nvidia-driver-510 - distro non-free driver : nvidia-driver-390 - distro non-free driver : nvidia-driver-520 - third-party non-free driver : nvidia-driver-515-server - distro non-free driver : nvidia-driver-470 - distro non-free driver : nvidia-driver-418-server - distro non-free driver : nvidia-driver-470-server - distro non-free driver : nvidia-driver-525-server - distro non-free driver : nvidia-driver-515 - distro non-free driver : nvidia-driver-450-server - distro non-free driver : xserver-xorg-video-nouveau - distro free builtin 上面信息提示了，当前我使用的GPU是[GeForce GTX 1060 6GB]，他推荐的（recommended）驱动是nvidia-driver-525。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33e1d7adbc0618c4b8e4c3140340586f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7b970a8e8a5e8e6cc3040829b9441b4/" rel="bookmark">
			k8s探针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/42/">«</a>
	<span class="pagination__item pagination__item--current">43/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/44/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>