<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89d0db9957bb6bd8103657d48cfd520a/" rel="bookmark">
			modern cpp 左值右值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本概念： 左值：在内存中有可以访问的地址，对象是一个左值。
右值：不可以取地址，整数10是个右值。
引用：对象的别名，没有创建新的对象，仅仅给已经存在的对象赋予了一个新的名字。
引用是对象的别名，对于引用的一切操作都是对对象的操作；
引用自身从概念上没有大小（或者就是对象的大小）；但引用在传递或需要存储时，其传递或存储的大小为地址的大小。
引用必须初始化；
引用不可能重新绑定；
将指针所指向的对象绑定到一个引用时，需要确保指针非空。
任何引用类型的变量，都是左值。
四种类型引用：
类型例子备注const lvalue refrenceFoo foo(10); const Foo&amp; ref = foo;const rvalue refrenceconst Foo&amp; ref = Foo(10);non-const lvalue refrenceFoo foo(10); Foo&amp; ref = foo;non-const rvalue refrenceFoo&amp;&amp; ref=Foo(10);C++11才开始有 move语义： C++11 之前，只有 copy 语意，这对于极度关注性能的语言而言是一个重大的缺失。
对move 语意的急迫需求，到了 C++11 终于被引入。其直接的驱动力很简单：在构造或者赋值时，如果等号右侧是一个中间临时对象，应直接将其占用的资源直接 move 过来（对方就没有了）。
但问题是，如何让一个构造函数，或者赋值操作重载函数能够识别出来这是一个临时变量？
/hello.cpp/ #include &lt;iostream&gt; using namespace std; struct Foo { Foo(){ cout &lt;&lt; "Foo()" &lt;&lt; endl; } Foo(const Foo&amp;ref){ cout &lt;&lt; "Foo(const Foo&amp;)"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89d0db9957bb6bd8103657d48cfd520a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e47ed532a8896189ce6bc9fce9b3b5e/" rel="bookmark">
			Android12(SDK31)通知栏通知报错问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前Android11时候加了个通知栏常驻通知，今天升级Android12突然就凉了，项目框框报错
java.lang.IllegalArgumentException: com.ibptadb: Targeting S+ (version 31 and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE be specified when creating a PendingIntent.
2022-07-13 10:48:01.939 31160-31160/com.xxx I/info: Strongly consider using FLAG_IMMUTABLE, only use FLAG_MUTABLE if some functionality depends on the PendingIntent being mutable, e.g. if it needs to be used with inline replies or bubbles.
报错写的清楚明了，就是SDK31版本的问题，然后网上一搜索是在Android12中待处理的PendingIntent必须声明可变性。
要声明给定PendingIntent对象是可变的或不可变的 ，请分别使用 PendingIntent.FLAG_MUTABLE 或 PendingIntent.FLAG_IMMUTABLE标志。
代码就是：
NotificationManager nm = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); Intent intent = new Intent(this, Main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e47ed532a8896189ce6bc9fce9b3b5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96ffb6c3fcc88ff2afc84928e30d6f5c/" rel="bookmark">
			centos6-vault的yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos-vault | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
https://mirror.tuna.tsinghua.edu.cn/help/centos-vault/
把原本默认文件手动修改成清华大学的yum源
# CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96ffb6c3fcc88ff2afc84928e30d6f5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/586a0a39060dfd368f69ab2d480da97a/" rel="bookmark">
			电脑如何安装无线网卡？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：自己组装了台式机，电脑离家里路由器太远（比如两者间隔两道门和一条走廊），且路由器不方便移动的情况下，想要在主机上安装无线网卡。
适用安装无线网卡的情况:
自己家没有网，但隔壁家有WiFi且知道人家WiFi密码。（至少我们手机在我们电脑所处的地方可以连上WiFi）自己组装了台式机，没有无线上网功能。家里路由器离电脑很远，用网线连接会不美观或不方便。 注意：装无线网卡的前提：自己家或隔壁家有WiFi，且知道人家WiFi密码！！！ **购买无线网卡：**我在京东上购买的，去年65块，今年55块。价格可以参考，品牌就不说了，我今天也才第一次用。一定要吐槽一下他们家的说明书，写的太太太复杂了。明明安装极其简单，我却被说明书误导浪费了一个小时，最后问的客服解决的。 安装无线网卡的步骤： 方案一：电脑主机上安装了光驱，如何安装无线网卡？ 网卡拿到会发现盒子里还附有一个小光盘，里面装的是驱动程序。
将电脑联网。【我是手机连接了家里WiFi，然后使用原装数据线连接手机和电脑主机，再打开手机，选择设置–连接与共享，将“USB共享网络”打开。则电脑联网成功。】将无线网卡插到电脑主机的USB口上。（我接的USB3.0接口）将光盘插入电脑主机的光驱里。双击盘符，打开对应的驱动文件夹，双击“Setup.exe”运行安装程序，等待安装好后，选择下一步完成。这样驱动就下载好了。（注意：如果安装文件是压缩包，需要先解压才能安装。） 方案二：电脑主机上没有安装光驱，如何安装无线网卡？ 将电脑联网。然后将无线网卡插到电脑主机的USB口上。（我接的USB3.0接口）联系店家将适用于我们购买网卡型号的驱动的官方下载链接发过来，在电脑上打开链接，并下载其驱动压缩包。【注意：这里下载的是驱动的压缩包，之后需要解压才能安装。】
双击“Setup.exe”运行安装程序，等待安装好后，选择下一步完成。这样驱动就下载好了。 如何检查无线网卡及其驱动是否安装成功： 点击电脑右下角任务栏，如下图所示，如果网卡图标为这种红色竖条，说明无线网卡及其驱动已经装好，但还没联上网。接下来只需要连上自家或邻居家WiFi即可。
如下图，打开WiFi，找到你们家或邻居家的网，确保密码输入正确。
联网成功后，你会发现无线网卡图标会由红色变为绿色。
到这里，无线网卡就安装成功啦！可以正常上网啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee4ac0c45b9d1939bfc5bb33cf512a39/" rel="bookmark">
			vue动态表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 动态表格 在前端开发中，表格是不可或缺的一环，现在就浅讲下动态表格的实现， &lt;template&gt; &lt;div&gt; &lt;el-table :data="tableData" border stripe style="width: 100%" id="table" &gt; &lt;el-table-column type="index" label="序号" width="100" show-overflow-tooltip &gt;&lt;/el-table-column&gt; &lt;el-table-column v-for="item in tableHeader" :label="item.title" :key="item.name" :prop="item.name" :show-overflow-tooltip="true" &gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { tableData:[ {name:"怨种",age:"24"}, {name:"老六",age:"28"}, ], tableHeader: [ {name:"name",title:"姓名"}, {name:"age",title:"年龄"},], } } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/677b95a256f4bf2a6a5ad8158a5571a6/" rel="bookmark">
			数字锁相环——环路滤波器参数设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		😣 太难了，好像懂了，又好像没懂，梳理一下。
​
模拟环路滤波器分别有RC积分滤波器、无源比例积分滤波器、有源比例积分滤波器。
​
上图为有源比例积分滤波器，固有频率 ω n \omega_n ωn​和阻尼系数 ξ \xi ξ， ω n \omega_n ωn​为 ξ = 0 \xi=0 ξ=0时的振荡频率。
τ 1 = R 1 C \tau _1=R_1C τ1​=R1​C， τ 2 = R 2 C \tau _2=R_2C τ2​=R2​C ，则环路滤波器的传输函数为
理想二阶锁相环路的传输模型为 ，其中 K K K为环路增益。
令
将其带入 H ( s ) H(s) H(s)，可得
双线性变换公式为
s = 2 T 1 − z − 1 1 + z − 1 s=\frac{2}{T}\frac{1-z^{-1}}{1+z^{-1}} s=T2​1+z−11−z−1​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/677b95a256f4bf2a6a5ad8158a5571a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd3b30b82a0e8bad40d0724fe184a85d/" rel="bookmark">
			CCAFNet: Crossflow and Cross-scale Adaptive Fusion Network for Detecting Salient Objects in RGB-D Im
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CCAFNet: Crossflow and Cross-scale Adaptive Fusion Network for Detecting Salient Objects in
RGB-D Images
CCAFNet跨流和跨尺度自适应融合网络用于RGB-D 图像显著目标检测
一 动机 现有的 SOD 模型主要利用 RGB 图像及其在三个融合域中的相应深度信息之间的关系：输入 RGB-D 图像、提取的特征图和输出显着对象。然而，这些模型并没有很好地利用高级和低级信息之间的交叉流动。此外，这些模型中的解码器使用涉及多个计算的传统卷积。
二 方法 提出了一种跨流和跨尺度自适应融合网络 (CCAFNet) 来检测 RGB-D 图像中的显著对象
三 网络框架 该网络包括一个特征编码器和一个特征解码器。 在编码器中，RGB 图像及其对应的深度图首先被馈送到 SOD 的双流架构。 骨干网络VGG，CFM 和 SFM 改进了低级空间信息和高级语义信息的融合。 不仅使用高级语义信息，还使用低级空间信息来实现跨模态语义和空间互补信息的融合。
3.1 通道融合模块CFM 提出了 CFM 以改进对高级交叉流和跨尺度语义信息的处理。 具体来说，鉴于 RGB 和关于 layer4_r 和 layer4_d 以及 layer5_r 和 layer5_d 输出之间的公共对象的深度信息之间的强相关性，CFM 自适应地融合了高级语义信息。
CFM 涉及三个步骤。
第一步，RGB特征通过通道注意力与深度相乘再残差：
第二步：将第一步得出的结果与原始RGB特征拼接，再sigmoid，split() 表示根据通道数分成两部分
分为以上两部分之后，深度通道与第一步得到的结果相乘再与第一步的结果相加；RGB通道与原始RGB特征相乘再与原始RGB特征相加；最后将两个部分相加
第三步：将第二步得到的结果与上一级的特征经过3ｘ３卷积两倍上采样做减法，再与第二步的结果相乘，再相加，abs() 绝对函数。其中Fi+1代表第i+1个融合模型的输出特征，Fi代表CFM的输出。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd3b30b82a0e8bad40d0724fe184a85d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2c3c316ecdc50e41e655545cb77c25/" rel="bookmark">
			【FPGA目标跟踪】基于FPGA的帧差法和SAD匹配算法的目标跟踪实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.软件版本 quartusii12.1
2.系统FPGA实现 FPGA整体的算法流程如下图所示：
FPGA的模块主要包括如下几大模块：
摄像机驱动程序，SDRAM控制程序，显示屏驱动程序，中值滤波程序，帧差法模块，SAD模板匹配模块，跟踪定位模块等等。
跟踪模块顶层程序
帧差法模块
SAD模板匹配模块，R通道
SAD模板匹配模块，G通道
SAD模板匹配模块，B通道
显示定位跟踪效果
中值滤波，R通道
中值滤波，G通道
中值滤波，B通道
跟踪模块
开发板LED控制模块
系统复位模块
摄像机视频图像捕获模块
摄像机采集数据转换为RGB像素的模块
开发板数码管模块
SDAM核
SDRAM控制器
I2C配置，主要用来配置相机的初始化状态。
1.帧差法模块
这个部分，就是将当前一帧图像，延迟一帧，然后相减，就可以得到。这个也是传统的差分，但是这种方法误差极大。主要包括：
目标跟踪中，基础的差分法，存在较大的缺陷，比如目标静止状态，那么就无法检测，如果场景中，运动的物体非常多，那么就会出现检测混乱的情况，如果摄像机存在较为剧烈的抖动，同样会导致检测失败。然后我们考虑到在实际中，各种跟踪目标具有一定的特殊性。因此，针对各种不同的应用场景，设置不同的模板，结合传统的帧差法，从而提升系统的性能。
帧差，其FPGA成像如下所示：
2.SAD模板匹配模块，RGB通道
这个部分的代码如下所示：
这个模块里面，我们选择的窗口大小为20*20，即在进行模板匹配的时候，选择20*20区域内的像素进行求和运算。
这个模块的实现过程是延迟，相加实现。
相当于公式：
3.显示定位跟踪效果
将差分，和模板匹配得到后的图像用一个轮廓进行表示。具体可以看仿真录像。
4.中值滤波，RGB通道
这个将图像中3*3区域内的图像的像素值，取其中间值来实现，具体可以参考中值滤波的相关原理。
5.跟踪模块
这个是根据差分帧，进行二值判决，得到大概的运动区域。
6.开发板LED控制模块
开发板硬件的配置，不涉及具体的算法原理
7.系统复位模块
开发板硬件的配置，不涉及具体的算法原理
8.摄像机视频图像捕获模块
这个部分，提供了摄像机的具体型号的datasheet，可以参考下。
9.摄像机采集数据转换为RGB像素的模块
将摄像机采集到的数据，进行拆分，然后组成RGB形式输出。
10.开发板数码管模块
开发板硬件的配置，不涉及具体的算法原理
11.SDAM核
这个部分是调用PLL核，产生控制SDRAM的时钟信号。
12.SDRAM控制器
SDRAM控制器，开发板硬件的配置，不涉及具体的算法原理
13.I2C配置，主要用来配置相机的初始化状态
I2C总线配置。开发板硬件的配置，不涉及具体的算法原理
整个系统的资源占用情况如下所示：
整个系统的RTL结构如下所示：
3.核心程序 //reset signals Reset_Delay	u2	(	.iCLK(CLOCK2_50), .iRST(KEY[0]), .oRST_0(DLY_RST_0), .oRST_1(DLY_RST_1), .oRST_2(DLY_RST_2), .oRST_3(DLY_RST_3), //auto-start start point .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2c3c316ecdc50e41e655545cb77c25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a73b5194d5f35c6daeb2e26868b13e/" rel="bookmark">
			前端性能分析工具-Lighthouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 对于前端开发人员来说，除了实现页面功能外，那就是页面的性能响应问题也要关注。同样对于测试人员在进行性能测试时，也要关注前端页面的性能指标。测试前端性能市面上可以用到的工具也比较多，比如可以用 HttpWatch 进行页面的抓取与分析，或者也可以使用抓包工具如 Fiddler 抓接口的形式进行分析。
本篇将介绍一款前端性能分析工具，即集成在 Chrome 开发者工具-Lighthouse。
2、简介 Lighthouse 用于分析 Web 应用程序和网页，收集性能指标和对开发人员最佳实践的见解。
架构图：
github地址：
https://github.com/GoogleChrome/lighthouse
3、使用 前提：需要安装 Chrome 浏览器。
1、打开 Chrome 浏览器，跳转到要进行性能监控的页面，例如作者的 CSDN 地址：https://blog.csdn.net/wangmcn
2、之后打开 Chrome 开发者工具（快捷键 F12）。
选择 Lighthouse 面板，设备可选择移动或桌面，如图所示设备为桌面。
然后点击“生成报告”。
运行完成后，展示性能测试报告，例如性能分数打78分。
查看性能原始跟踪。
并同时给出了一些诊断建议信息。
可访问性分数打了71分，并给出改进建议。
如图所示设备为移动时，分析过程中的效果。
最后可将报告进行打印、拷贝、下载等操作。
最后： 可以在公众号：伤心的辣条 ！ 自行领取一份216页软件测试工程师面试宝典文档资料【免费的】。以及相对应的视频学习教程免费分享！，其中包括了有基础知识、Linux必备、Shell、互联网程序原理、Mysql数据库、抓包工具专题、接口测试工具、测试进阶-Python编程、Web自动化测试、APP自动化测试、接口自动化测试、测试高级持续集成、测试架构开发测试框架、性能测试、安全测试等。
现在我邀请你进入我们的软件测试学习交流群：【746506216】，备注“入群”， 大家可以一起探讨交流软件测试，共同学习软件测试技术、面试等软件测试方方面面，还会有免费直播课，收获更多测试技巧，我们一起进阶Python自动化测试/测试开发，走向高薪之路。
喜欢软件测试的小伙伴们，如果我的博客对你有帮助、如果你喜欢我的博客内容，请 “点赞” “评论” “收藏” 一 键三连哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01cb9ea5cc0b4f4e53701f22ff9b41e2/" rel="bookmark">
			shell脚本实现批量解析域名IP地址（支持多DNS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		脚本介绍 多DNS解析（目前支持最多3个目标DNS服务器）支持解析域名的A记录和CNAME记录自定义DNS，内网DNS服务器，或公网DNS多域名同时从目标DNS解析记录（脚本从文本读取域名列表） 实现代码 #!/bin/bash #Author：cosann #Create Time：20220714 #Description：批量解析域名A记录和CNAME记录脚本 #初始化DNS服务器 dns1=$1 dns2=$2 dns3=$3 #初始化解析库 dns_file=$4 #DNS检测函数定义 function Ping_Stat_1 (){ ping -w 1 $dns1 &amp;&gt; /dev/null if [ "`echo $?`" == 0 ] then return 100 else return 200 fi } function Ping_Stat_2 (){ ping -w 1 $dns2 &amp;&gt; /dev/null if [ "`echo $?`" == 0 ] then return 100 else return 200 fi } function Ping_Stat_3 (){ ping -w 1 $dns3 &amp;&gt; /dev/null if [ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01cb9ea5cc0b4f4e53701f22ff9b41e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c56a9be89483ce9305bf921d3157925/" rel="bookmark">
			网络基础学习系列二(socket编程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.预备知识1.1理解源IP地址和目的IP地址1.2认识端口号1.3理解 "端口号" 和 "进程ID"1.4认识TCP协议1.5认识UDP协议1.6网络字节序 2.socket编程接口2.1socket常见API2.2udp服务器的简单应用场景2.2.1sockaddr结构2.2.2编写server1.创建套接字2.给该服务器绑定端口和ip（特殊处理）3.提供服务4.编写client 2.2.3改进：做一个小型的shell 2.3Tcp服务器的简单应用场景2.3.1单进程版本2.3.2多进程版本2.3.3修改补充多进程版本2.3.4使用线程2.3.5单例模式线程池 3.TCP协议通讯流程 1.预备知识 1.1理解源IP地址和目的IP地址 IP地址（公网IP）唯一的标识互联网中的一台主机
在IP数据包头部中, 有两个IP地址, 分别叫做源IP地址, 和目的IP地址
源ip地址：指的就是发送数据包的那个电脑的ip地址
目的ip地址：就是你想要发送到的那个电脑的ip地址
源IP，目的IP：对一个报文来讲，从哪来，到哪里去
最大的意义：指导一个报文该如何进行路径选择
到哪里去：本质就是让我们根据目标，进行路径选择的依据！
目的地址：下一跳（mac地址的变化）
1.2认识端口号 数据从A主机到达B主机，不是目的！
数据到目标主机B的一个进程，提供数据处理的服务
数据刚开始的时候，从哪里来？是在计算机上凭空产生的吗？
计算机本身不产生数据，产生数据的是人！人是通过特定的客户端，产生数据！
本质上，所有的网络通信，站在普通人的角度，都是人和人之间通信
技术人员的视角，我们学到的网络通信，本质上：是进程间通信！
例如：app客户端《—》服务器（也是一个进程）
IP仅仅是解决了两台物理机器之间互相通信
但是我们还要考虑如何保证双方用户之间能看到发送的和接受的数据IP地址（公网IP）唯一的标识互联网中的一台主机呢？
端口号：唯一的标识一台机器上的唯一的一个进程！
IP地址（公网IP）唯一的标识互联网中的一台主机
—》
IP+PORT = 能够标识互联网中的唯一的一个进程!
整个网络看作是一个大的OS，所有的网络上网行为，基本都是在这一个大的OS内，进行进程间通信！
IP+PORT端口号 = 套接字
1.3理解 “端口号” 和 “进程ID” 进程具有独立性，进程间通信的前提工作：先让不同的进程，看到同一份资源！（网络）
问题：一个进程可以关联多个端口号吗？可以
一个端口号可以关联多个进程吗？不可以
pid 表示唯一一个进程; 此处我们的端口号也是唯一表示一个进程
1.4认识TCP协议 TCP(Transmission Control Protocol 传输控制协议)
传输层协议
有连接
可靠传输
面向字节流
发送数据时，要进行深入沟通，报文，如果丢失该如何？该找谁？找到了之后应该如何？
各种事情都要仔细问清楚，然后再将数据转发出去！如果数据丢失了，就会回来重新获得一份数据，然后再发送。
1.5认识UDP协议 UDP(User Datagram Protocol 用户数据报协议)
传输层协议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c56a9be89483ce9305bf921d3157925/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45f1028b6f8e34d1c026f87531a13940/" rel="bookmark">
			python socket库实现接口的监听，信息提取并返回
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import socket import threading import time import json import numpy as np def get_data(data): # 转为json data = str(data) # print(data) json_data = data.split('Content-Length', 1) # print(json_data[1]) jd = json_data[1].split("{", 1) jd1 = "{" + jd[1] # jd1 = jd1[:-1] # print("信息为") # print(str(jd1)) # print(repr(jd1)) js2 = json.loads(str(jd1)) # print(js2) return js2 def get_area(data1): # 计算面积 length = 24 up = max(data1) print("up: %d"%up) down = min(data1) print("down: %d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45f1028b6f8e34d1c026f87531a13940/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8c585a49fd93ba76f2155d81092cabc/" rel="bookmark">
			echarts 自定义tooltip显示的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		针对某种情况下 图表tooltip 展示的数据异常及不是我们想要的效果
话不多说，直接上代码：
tooltip: { trigger: 'axis', extraCssText:'height:60px;', axisPointer: { type: 'cross', label: { backgroundColor: '#6a7985' } }, formatter: function(params) { let result = '' params.forEach(function (item) { let dotHtml = '&lt;span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:'+item.color+'"&gt;&lt;/span&gt;' result += `${dotHtml}${item.seriesName}: ${item.data}&lt;br/&gt;` }) return result } }, 直接cv即刻使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11899421ba8dc7b78262551fdc35439e/" rel="bookmark">
			PLSQL Developer14连接Oracle详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、下载并解压Oracle客户端 下载地址：Instant Client for Microsoft Windows (x64) 64-bit | Oracle 中国
解压客户端工具到一个目录（解压文件到当前目录，自动合并成一个目录）
​
二、配置window操作系统环境变量 电脑（右键）→属性→高级系统设置→环境变量→系统环境变量→新建
变量名：NLS_LANG
变量值: AMERICAN_AMERICA.ZHS16GBK
​
变量名：TNS_ADMIN
变量值：C:\xiaxinyu\software\Oracle\instantclient_19_10
​
三、Oracle客户端配置 在Oracle客户端（C:\xiaxinyu\software\Oracle\instantclient_19_10）的解压目录下创建文件夹network/admin/，里面创建名为"tnsnames.ora"文件，添加以下内容：
## service_name1 为自定义名称 {service_name1} = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {127.0.0.1})(PORT = {1521})) ##修改要连接机器的IP和监听端口 ) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = {service_name} ) ##数据库服务名 ) ) 四、PLSQL Developer14配置 配置➡首选项➡连接
1.添加Oracle主目录 ：将Oracle客户端解压目录到Oracle主目录 我本机的路径为：
C:\xiaxinyu\software\Oracle\instantclient_19_10 2.添加OCI库：将Oracle客户端解压目录下oci.dll文件复制为路径，添加到OCI库 我本机的oci.dll文件文件位置为：
C:\xiaxinyu\software\Oracle\instantclient_19_10\oci.dll 五、PLSQL Developer14并使用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b028c673d0c6a5b9d2a5ac9e7f85aef/" rel="bookmark">
			物理层——计算机网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 物理层的基本概念物理层作用物理层的功能常用术语信道调制极限容量 物理层下的传输媒体电路交换网络复用频分复用时分复用波分复用码分复用 物理层拓展以太网集线器 三总交换的优缺点 物理层的基本概念 物理层考虑的是怎样才能怎样才能连接各种计算机传输媒体上传输数据比特流，而不是连接具体的传输媒体。作用是屏蔽不同传输媒体和通讯手段的差异。物理层协议也称物理层规范 物理层作用 确定传输媒体的接口的一些特点，如：接口的形状、尺寸、引线数量等解决计算机间的比特传输问题（透明的传输比特流），关心点到点的问题 物理层的功能 接口特性：物理层不包含物理媒介，而是确定接口特性机械特性：规定接口的形状，尺寸，引线数目。电气特性：各个接口上的电压范围、阻抗匹配。功能特性：某一接口上出现某一电压的用途、接口信号的用途。过程特性：各条物理线路的工作过程，时序关系。 常用术语 数据：消息的实体信号：数据的（电气或 电磁）表现模拟信号：连续的消息参数取值数字信号：离散的消息参数取值码元： 信道 信道：表示某一个方向传递信息的媒体单向通信：只能一个方向通信，反向不行（广播，收音机）双向交替通信（半双工）：双方都可以发送信息， 但不能同时（对讲机）双向同时通信（全双工）：~~（电话） 调制 基带信号：计算机输出的代表各种文字或图形文件的信号都是调制：把信道不能传输的低频、直流成分转化成可传输的基带调制（编码）：基带信号（不适应）转化为基带信号（适应）带通调制：基带信号转化为模拟信号（把基带信号频率调高成模拟信号） 调幅：调节幅度调频：调节频率调相：调节初相位（一个是正弦波，一个是余弦波） 极限容量 任何信道在传输时都会受到干扰码元传输速率越高、信号传输距离越远、传输媒介质量越差，都会使失真严重
1.如果码元传输速率没有上限（可传输的范围太宽），就会出现码间串扰。
2.如果信道频带越宽（能通过的信号高频分量越多），就可以使用更高的速率传送码元，而不会出现串码
噪声存在于所有电子设备和同道中，噪声随机产生，瞬时值很大。
信噪比：当信号强度越大时，噪声的影响也就越小信噪比香农公式：用信息论的理论推出带宽受限制且有高斯白噪音干扰的信道极限、无差错的信息传输速率。 物理层下的传输媒体 双绞线：同轴电缆：用于传输高速数据光纤： 多模光纤：信号损耗大，传输距离远单模光纤：信号损耗小，传输距离近光猫：把光纤中的光信号转化计算机能识别的电信号。 光纤优点：通信容量大，损耗小，距离远，抗干扰能力强，保密性好，体积小，重量轻
电波传输：短波微波：卫星 电路交换网络复用 频分复用 把带宽分成多份，用户分配到不同的频率。所有户在同样时间占用不同的带宽。（“带宽”是频路带宽，而怒视数据发送速率） 时分复用 每一个用户所占用的时间间隙，成周期性 波分复用 码分复用 个用户挑选不同的码型因此不会造成干扰。这种抗干扰能力强码片：每个站发动的码片序列必须各不相同，相互正交，在实际系统中使用伪随机码序列 随机码：无论多长不会循环伪随机码：码长达到一定长度，开始循环。（CDMA采用42位伪随机码，循环可能位4.4亿分之一） 物理层拓展以太网 主机使用光纤和一对光纤调制解调器宽展以太网。用集线器宽展以太网。 集线器 碰撞域： 一台设备发送数据，其他设备发送数据与之发生冲突，这些设备的集合就称之为碰撞域 用集线器宽展以太网的优点：
可以进行跨碰撞域的通信（不属于同一个碰撞域的以太网上的计算机的通信）扩大了以太网的地理范围
缺点：碰撞域增大，但是吞吐量没有提高不同碰撞域使用不同数据率，是不能用集线器互联在一起 三总交换的优缺点 电路交换：整个报文的比特流连接的从源点发往终点分组交换：把整个报文分成多个分组，单个分组转发到相邻接点，储蓄下来后查找转发表，发送到下一个分组。报文交换：整个报文转发到相邻接点，全部储蓄下来后查找转发表，发送到下一个分组。 电路交换分组交换报文交换优点时延小、交换成本低可以对不同的系统终端匹配、传输时延小、线路利用率高、可靠性高、经济效益好电路利用率高、不同终端接口可以相互通信、无呼损缺点网络利用率低、电路利用率低、对长报文信息的传输率低、传输时延大、变化范围大，对交换系统要求高 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a43be4362039c2b5231d7b7699fd948d/" rel="bookmark">
			Linux学习：vim编辑器的三种模式及常见命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三种模式 1、一般模式 在一般模式下，我们可以使用快捷键。用vim打开一个档案就直接进入一般模式了，在这个模式中，可以使用【上下左右】按键来移动光标，可以使用【删除字符】或【删除整行】来处理档案内容，也可以使用【复制、粘贴】。
dd：剪切光标所在的行（在前加数字表示剪切多少行）
yy：复制光标所在的行（在前加数字表示复制多少行）
p：粘贴复制的行
gg：光标切换到第一行
G：光标切换到最后一行
行号+G：光标切换到指定的行
x：向后删除一个字符（在前加数字表示删除多少个）
X：向前删除一个字符（在前加数字表示删除多少个）
u： 恢复最后一个指令之前的结果
Ctrl+r 可以恢复撤消前内容，按多次可恢复多次
J：将光标所在行与下一行数据合并成一行
/word：向光标之后寻找名为word的字符串,当找到第一个word后,按下"n"继续查找后一个，按下"N",反方向查找下一个
?word：向光标之前寻找名为word的字符串,当找到第一个word后,按下"n"继续查找后一个,按下"N",反方向查找下一个
:n1,n2s/word1/word2/g：在n1和n2行之间查找wordl字符串并替换为word2
:1,$s/word1/word2/g：从第一行到最末行,查找word1并替换成word2
:1,$s/word1/word2/gc：在第一行和最末行之间查找word1,替换为word2之前需要用户确认
2、插入模式/编辑模式 按下【i,I,o,O,a,A,r,R】其中任一键进入编辑模式，可以修改档案内容。
3、命令行模式 按【esc】+【:】进入命令行模式，在该模式中，可以提供相关指令完成读取、存盘、替换、离开vim、显示行号等动作。
w：保存文本
w! ：如果文件属性为只读时，强制保存
w [filename]：将文档另存为filename
q：退出vim
q!：强制退出vim，不管编辑还是未编辑都不保存退出
wq：保存之后退出
ZZ ：等价于wq
e!：将文档还原成最原始状态
r [filename]：在光标所在行的下面读入filename文档的内容
set nu：在每行的行首设置行号
set nonu：取消行号
n1,n2 w [filename]：将n1到n2行的内容另存为filename文件中
!command：暂时离开vim，执行某个Linux命令，例如：:ls/home 暂时列出/home下的文件，然后会提示按回车返回vim
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9dcdf091f89b6e5be0ed0106812fb4c/" rel="bookmark">
			Java高级面试题及答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		List和Set比较，各自的子类比较 对比一：Arraylist与LinkedList的比较
1、ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高(在内存里是连着放的)。
2、因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。 3、LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。
4、因为LinkedList要移动指针,所以查询操作性能比较低。
适用场景分析：
当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。
对比二：ArrayList与Vector的比较
1、Vector的方法都是同步的，是线程安全的，而ArrayList的方法不是，由于线程的同步必然要影响性能。因此，ArrayList的性能比Vector好。 2、当Vector或ArrayList中的元素超过它的初始大小时，Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样。ArrayList就有利于节约内存空间。
3、大多数情况不使用Vector，因为性能不好，但是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性。
4、Vector可以设置增长因子，而ArrayList不可以。
适用场景分析：
1、Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。
2、如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。
对比三：HashSet与TreeSet的比较
1.TreeSet 是二叉树实现的，Treeset中的数据是自动排好序的，不允许放入null值 。
2.HashSet 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束 。
3.HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例。
适用场景分析：
HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。
HashMap和ConcurrentHashMap的区别 1、HashMap不是线程安全的，而ConcurrentHashMap是线程安全的。
2、ConcurrentHashMap采用锁分段技术，将整个Hash桶进行了分段segment，也就是将这个大的数组分成了几个小的片段segment，而且每个小的片段segment上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段segment，然后再在这个片段上面进行插入，而且这里还需要获取segment锁。
3、ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。
JVM的内存结构 根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。
1、Java虚拟机栈：
线程私有；每个方法在执行的时候会创建一个栈帧，存储了局部变量表，操作数栈，动态连接，方法返回地址等；每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。
2、堆：
线程共享；被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。
3、方法区：
线程共享；被所有线程共享的一块内存区域；用于存储已被虚拟机加载的类信息，常量，静态变量等。
4、程序计数器：
线程私有；是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。
5、本地方法栈：
线程私有；主要为虚拟机使用到的Native方法服务。
强引用，软引用和弱引用的区别 强引用：
只有这个引用被释放之后，对象才会被释放掉，只要引用存在，垃圾回收器永远不会回收，这是最常见的New出来的对象。
软引用：
内存溢出之前通过代码回收的引用。软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。
弱引用：
第二次垃圾回收时回收的引用，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。
springmvc的核心是什么，请求的流程是怎么处理的，控制反转怎么实现的 核心：
控制反转和面向切面
请求处理流程：
1、首先用户发送请求到前端控制器，前端控制器根据请求信息(如URL)来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；
2、页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个ModelAndView(模型数据和逻辑视图名)；
3、前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；
4、前端控制器再次收回控制权，将响应返回给用户。
控制反转如何实现：
我们每次使用spring框架都要配置xml文件，这个xml配置了bean的id和class。
spring中默认的bean为单实例模式，通过bean的class引用反射机制可以创建这个实例。
因此，spring框架通过反射替我们创建好了实例并且替我们维护他们。
A需要引用B类，spring框架就会通过xml把B实例的引用传给了A的成员变量。
BIO、NIO和AIO的区别 Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9dcdf091f89b6e5be0ed0106812fb4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee9fc4bb021494253336f4da6e45d1d/" rel="bookmark">
			关于临时表空间问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle经常需要查数据库临时表空间大小，使用率，加表空间等，这里总结临时表空间相关的语句：
0、查看实例的临时表空间
SELECT * FROM dba_tablespaces t where t.CONTENTS='TEMPORARY'; SELECT PROPERTY_NAME, PROPERTY_VALUE FROM DATABASE_PROPERTIES WHERE PROPERTY_NAME='DEFAULT_TEMP_TABLESPACE'; 1、查询临时表空间路径：
select tablespace_name,file_name,bytes/1024/1024 file_size,autoextensible from dba_temp_files; 2、新增临时表空间：
alter tablespace srmqy_temp add tempfile '/data/oradata/srmqy_temp01.dbf' size 64m autoextend on next 64m maxsize unlimited; 3、查询临时表空间使用情况：
select c.tablespace_name, to_char(c.bytes/1024/1024/1024,'99,999.999') total_gb, to_char( (c.bytes-d.bytes_used)/1024/1024/1024,'99,999.999') free_gb, to_char(d.bytes_used/1024/1024/1024,'99,999.999') use_gb, to_char(d.bytes_used*100/c.bytes,'99.99') || '%'use from (select tablespace_name,sum(bytes) bytes from dba_temp_files GROUP by tablespace_name) c, (select tablespace_name,sum(bytes_cached) bytes_used from v$temp_extent_pool GROUP by tablespace_name) d where c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee9fc4bb021494253336f4da6e45d1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b524d903ffae75d69f9d6f83759cb52/" rel="bookmark">
			1.二分法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0、絮絮叨叨 守护全网讲的最好的二分法博主
注：本文用JavaScript写的~
1、伪代码 //二分查找伪代码模版 let left = 0, right = length - 1;① while (left &lt;= right) {② mid = (left + right) / 2;③ if (array[mid] === target) return result; else if (array[mid] &lt; target) left = mid + 1;④ else if (array[mid] &gt; target) right = mid - 1; } return -1;⑤ 2、容易出错的地方 1.right = length 还是 length - 1？ 答：取哪个对应的是相应的搜索区间 比如取right = length - 1；对应区间[0, length - 1]，后边left = mid + 1； 比如取right = length；对应区间[0, length）。本质是一样的，后边left = mid； 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b524d903ffae75d69f9d6f83759cb52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bba03cc532d76f029092d2e1d2b9cc11/" rel="bookmark">
			spring boot中动态代理导致自定义注解扫描失败以及解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 背景 在spring boot中，利用ApplicationContext扫描自定义方法注解，可能出现无法获取自定义注解的情况
通过debug得到class文件名含有EnhancerBySpringCGLIB，类似于这样：
或含有$ProxyXXX，类似于这样：
2 原因 其根本原因在于，applicationContext.getBeansWithAnnotation(类注解.class) 方法获取Bean时，可能拿到的是GClib代理后的类或者Jdk代理的类，导致 bean.getClass().getDeclaredMethods() 拿不到原真实类的方法
因此需要根据具体情况，判断是何种代理，然后利用反射去获取对应真实类，拿到其方法
3 案例 这里封装了一个自定义方法注解，用于监听MQ消息：
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited public @interface MqttListener { /** * TOPIC，支持处理多个消息 * * @return */ String[] value() default {}; /** * QOS * * @return */ int qos() default 0; } 将注解添加到对应的方法上
@MqttListener(Topic.TEST) public void test(MqttEntity entity) { log.info("接收到的数据：{}", entity); testSync(entity.getValues()); } 在项目中新增一个配置类实现CommandLineRunner，实现其run方法，通过ApplicationContext扫描程序中的bean，拿到对应的注解
@Component @Slf4j public class MqttAnnotationScanner implements CommandLineRunner { @Autowired private ApplicationContext applicationContext; @Override public void run(String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bba03cc532d76f029092d2e1d2b9cc11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/478517099173481abfef31646643393c/" rel="bookmark">
			【栈】HJ54.表达式求值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
解答：
def compute(st1,st2): b=st1.pop() a=st1.pop() op=st2.pop() if op=='+': a+=b elif op=='-': a-=b elif op=='*': a*=b elif op=='/': a//=b st1.append(a) def priority(op1,op2): if op1=='(': return False elif (op1=='+' or op1=='-') and (op2=='*' or op2=='/'): return False return True while True: try: s=input() st1=[] #记录操作数 st2=[] #记录运算符 st2.append('(') s+=')' flag=0 #0表示当前为数字，1表示当前为运算符 i=0 #print(s) while i&lt;len(s): #print(i,s[i],flag,st1,st2) if s[i]=='(': st2.append('(') i+=1 elif s[i]==')': while(st2[-1]!='('): compute(st1,st2) st2.pop() #弹出左括号 i+=1 elif flag: #运算符 while priority(st2[-1],s[i]): #栈中运算符优先级是否更高，若更高，则可对当前栈中元素进行运算 compute(st1,st2) st2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/478517099173481abfef31646643393c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f229461fb4f0623daafc6fb36da59252/" rel="bookmark">
			html表单最全详解，初学必看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家去面试，去开户都要填各式各样的表单，填好之后给工作人员，他们会按照表单项目与你填的内容来帮你完成业务。
同样的，在互联网冲浪也需要填各种各样的表单，比如用户问卷调查，新注册账号等。那么我们填好的表单谁去帮我们处理呢从而完成业务呢？答案就是后端程序，我么只要把表单传给后端，后端专门处理业务的逻辑代码就会来完成处理表单的任务。
现阶段，我们只要把表单的格式设计好，各个方面都完善之后，拿给后端程序员看，后端程序猿依照前端小姐姐设计的表单格式来写一段业务逻辑代码就OK了。
表单使网页具有交互性，因为他把浏览器与服务器进行了链接，实现两台电脑间的数据互传与交换。
目录
一，表单标签
二，表单的组成元素
三，文本框元素input type="text"
四，密码框元素input type="password"
五，单选按钮input type="radio"
六，复选框input type="checkbox"
七，文件选择input type="file"
八，提交按钮input type="submit"
九，重置按钮input type="reset"
十，普通按钮 input type="button"&amp;button
十一，图像图片按钮input type="image"
十二，下拉列表select&amp;option&amp;optgroup
十三，多行文本框textarea
十四，label标签
十五，H5新增type类型之email
十五，H5新增type类型之url
十六，H5新增type类型之search
十七，H5新增type类型之tel
十八，H5新增type类型之color
十九，H5新增type类型之number
二十，H5新增type类型之range
二一，H5新增type类型之date，month，week
二二，H5新增type属性之autofocus
二三，H5新增type属性之placeholder
二四，H5新增type属性之required
一，表单标签 表单标签是&lt;form&gt;&lt;/form&gt;，是一个双标签。他是一个容器，里面装着一些控件与元素，之所以叫做容器，因为他是一个整体，网页排版的时候将他作为一个整体可以放在网页上的任何位置。
常见写法如下：action指的是处理表单的业务逻辑代码地URL地址，一般为php语言和各种后端框架所写。method指的是http协议里面请求方法。
&lt;form action="" method="get|post"&gt; &lt;/form&gt; 二，表单的组成元素 能够在网页上显示并能实现功能的表单有三部分：表单标签；表单域；表单按钮。其中表单标签用来告诉浏览器这是一个表单，你帮我显示在网页上 ；表单域就是表单里面的内容，也就是各种条条框框需要我们填的，表单按钮用来绑定事件。
表单一般用作用户填写资料，使用最多的就是各种形式的输入框，也就是&lt;input&gt;标签。&lt;input&gt;标签可以在&lt;body&gt;标签里随处方法，但更多的是放在form表单里。&lt;input&gt;标签是非块级元素，也就是说&lt;input&gt;标签在网页中默认一个一个在一行中挨着排队显示。西面进行演示。
&lt;form&gt; &lt;input type="text"&gt;111 &lt;input type="text"&gt;111 &lt;input type="text"&gt;111 &lt;/form&gt; 网页显示如下：
三，文本框元素input type="text" 文本框类似于微信聊天的打字框，功能是让用户输入一些字母、汉字和数字。可以使用标签&lt;input type="text"&gt;来实现。type是标签&lt;input&gt;的属性，不同的属性值会有不同的效果。
&lt;input type="text"&gt; 四，密码框元素input type="password" 密码框就是特殊的文本框，他把输入的内容用小圆点来代替，防止被别人看到。使用&lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f229461fb4f0623daafc6fb36da59252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b63e2eebb016c881e865ffa1649988/" rel="bookmark">
			Linux curl命令最全详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、最常用的curl命令
1、发送GET请求
2、发送POST请求
3、发送json格式请求：
二、curl命令语法与curl命令参数详解
1、curl命令语法
2、curl命令参数详解
三、Linux curl命令退出码
四、常见用法
1、下载(option:-o或者option:-O)
2、上传文件(option:-T)
3、伪造来源页面|伪造referer|盗链 (option：-e)
4、伪造代理设备(模仿浏览器)
5、设置http请求
6、http响应头
7、发送表单数据
8、cookie
9、测试一个网址
10、保存访问的网页(&gt;&gt;)
11、请求方式
12、调试
13、显示抓取错误
curl是一个非常实用的、用来与服务器之间传输数据的工具；支持的协议包括 (DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, TELNET and TFTP)，curl设计为无用户交互下完成工作；curl提供了一大堆非常有用的功能，包括代理访问、用户认证、ftp上传下载、HTTP POST、SSL连接、cookie支持、断点续传...。
一、最常用的curl命令 1、发送GET请求 curl URL curl URL?a=1&amp;b=nihao 2、发送POST请求 curl -X POST -d 'a=1&amp;b=nihao' URL 3、发送json格式请求： curl -H "Content-Type: application/json" -X POST -d '{"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b63e2eebb016c881e865ffa1649988/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bfe38a18153f5498b2c322d25e137dc/" rel="bookmark">
			利用redis&#43;lua优雅实现每天给用户发短信次数限制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近的一个需求要求实现每天给用户发短信不超过3次，并且发短信间隔不能小于1小时，思来想去有没有什么比较好的实现方式呢，最终决定用redis+lua来实现，第一次写lua脚本。还不太熟练，不过完美的把功能实现了，废话不多说，上代码
1.controller层的调用
package com.example.lua.controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.core.io.ClassPathResource; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.data.redis.core.script.DefaultRedisScript; import org.springframework.scripting.support.ResourceScriptSource; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.time.LocalDateTime; import java.util.Arrays; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.stream.Collectors; @RestController public class Test1Controller { @Autowired private StringRedisTemplate redisTemplate; @RequestMapping("test1") public void test() { System.out.println("xxxxxxxxxxxxxx"); //调用lua脚本并执行 DefaultRedisScript&lt;Boolean&gt; redisScript = new DefaultRedisScript&lt;&gt;(); redisScript.setResultType(Boolean.class);//返回类型是Long redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("redis/clear-local-key1.lua"))); LocalDateTime now = LocalDateTime.now(); int dayOfYear = now.getDayOfYear(); int minute = now.getMinute(); int hour = now.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1bfe38a18153f5498b2c322d25e137dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d7ac3a8ff7c0f29fbb9ba14a8ccf4c1/" rel="bookmark">
			Vue3&#43;Vite2自动载入常用API操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.我们在写vue3的时候 每个api都要频繁的引入像下面这样、很繁琐 import { reactive, toRefs, onMounted, getCurrentInstance } from 'vue' 2.这时候只需要下载一个插件、并且简单的配置以下就可以解决上面的烦恼了 npm i -D unplugin-auto-import 3.在项目 vite.config.ts/js 进行以下配置、就可以在页面中直接使用api了无需再引入 import AutoImport from 'unplugin-auto-import/vite'; plugins: [vue(), AutoImport({ imports: ['vue'], dts: 'src/auto-import.d.js' })], 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39907ff442c3a17af94f4d6d511b673a/" rel="bookmark">
			十种经典排序算法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冒泡排序 稳定的，一开始正序的话，不需要交换，但是也要比较固定次数。逆序比较和交换次数最多。
冒泡优化：可以设置一个标记位，如果某次循环中有交换出现，就把标记位置为1，如果标记位是0的话直接退出（说明剩下的都有序）。
选择排序 每次循环找到最小的一位位置，遍历一边后交换。选择排序不稳定！一开始正序的话，还是要全部遍历比较。逆序的话交换次数不是最多。
优化方法：一趟中既选出最小值，也选出最大值，交换两个位置。
插入排序 假定前面部分都排好序，把每一个元素在已排数组中从后往前找合适位置。插入排序是稳定排序！因为移动耗时高，时间复杂度也是n方。一开始有序的话，也要进行全部比较。逆序的话移动次数最多。
优化方法：在寻找方面使用二分查找，减少比较次数；每次多拿几个元素一起插入；数据链表化，可以精准插入，不用移动这么多次。不过这些都是n方复杂度。还有一个希尔排序，理解就行。
希尔排序，对插入排序的改进方法。分多个间隔的插入排序。减少移动元素的次数，和查找的次数。时间复杂度突破n方，但是如果采用步长为长度一半的方法的话，最坏也是n方，具体跟选择步长有关，下界是nlogn。不是稳定排序。
快速排序 就是挖坑填数加分治。不稳定的。在选择的基准值为最值的时候退化为n方复杂度。
优化方法：更合理的基准数，可以从多个数中选中值，避免选到极值。结合插入排序，当序列数少于10时，用插入排序做。
归并排序 将两个有序的子数列合并，将每个数看成一个子序列，然后不断两两组合归并排序。时间复杂度nlogn，归并排序稳定。局部有序时交换次数比较小。（明天看看代码）
计数排序 复杂度n+k，稳定。要求必须是整数，且元素比较集中。
优化方法：记录最小值和最大值，类似操作系统内存装入时冲定位寄存器。
桶排序 准备几个桶，按最高位数放到桶里单独排序。根据每个桶的排序算法不同，时间复杂度和稳定性不一定。分布要比较均匀，
基数排序 分别按个位十位百位的数字分配到好几轮桶中，比如按个位分配到十个桶，然后按十位分配到十个桶等等，然后拿出按个位排的顺序，再放到十位桶，再按顺序拿出来，再放到百位桶………最后拿出来就是有序的，而且稳定。时间复杂度nk，稳定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e80a9ef908716bd57b3e112ab7256f2a/" rel="bookmark">
			Axure创建团队共享项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何构建Axure团队项目管理
1、激活Axure 在构建Axure团队项目前，Axure需进行激活授权。授权码必须是以Team edition方式生成，否则在Axure中看不到团队菜单栏。
2、打开Axure创建账号 创建Axure个人账号，并在Axure中进行登录。
3、登录Axure官方网站 登录Axure官网，地址：https://app.axure.cloud/
登录后，创建我们的第一个项目。点击Workspaces旁边的"+"号。
输入我们创建的name，点击创建。
5、上传项目 打开Axure,点击团队-从当前文件创建项目-弹出上传框。
点击choose Existing workspace，可查看到在Axure中所创建worksapce名称。
也可直接填写团队项目名称及新增工作空间上传。
填写项目名称，选择创建的workspace，点击创建团队项目。
这样我们就创建项目成功。
回到Axure官网，在第一个项目下面，就有一个A项目文件，此文件就是我们原型文件。
5、添加团队成员 添加成员，点击填写成员，输入成员邮箱。
Axure会给成员发送邮箱，请注意Axure发送邮箱会存在延迟或者邮件会在垃圾箱里面，注意进行查看。
点击邮箱中的Join workspace ，加入团队，回到Axure中，我们就能获取该团队项目。
6、团队获取项目 打开Axure,点击团队-获取并打开项目文件。
选择我们的项目文件，点击获取项目
保存项目文件
打开项目文件
打开项目后，就可以看到，修改任何页面都需要进行迁出。
我们构建Axure共享项目就完成了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7208d125e2f58a8e1723fdcbcddfd36c/" rel="bookmark">
			如何在硬件上实现算法——基于FPGA的目标识别与跟踪设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献：基于FPGA的嵌入式图像处理系统设计（第四章设计流程）
引言 一、开发嵌入式图像处理的步骤 1、问题描述：系统功能定义、系统性能指标定义、系统运行环境（系统要做什么、为什么这么做）
系统性能指标定义：对于实时图像处理来说，允许的最大延迟和帧率是两个很重要的指标
2、算法开发：确定图像处理操作的顺序
3、结构选择：确定应用和操作级算法所需的处理器的计算结构（定义算法在计算方面如何实现：应用层算法硬软件分离算）
4、系统实现：将算法映射到结算结构上（包括系统测试）
二、算法移植的介绍 不能直接在硬件FPGA上开发算法，因此调试算法周期过长，一般地，我们采用软件来开发算法，后移植到硬件上，但是硬件实现算法的关键不是直接移植一个已有的串行算法，而是将算法转化成可用的计算架构。
由上图可知，算法实现主要分为两步：分析算法和设计算法结构隐含的计算结构。
分析算法：
找出基本的算法结构——对算法整体分析且能进行修改。 分析时，将基本算法进行转化，转化成更简单有效的形式，从而映射到硬件上实现。
1、 尽可能多的采用流处理的方式，从而消除中间的帧缓冲器——任何采用窗口扫描处理数据的操作均可采用流处理的方式。
流处理：用流水线结构来克服存储器限制的瓶颈，无需从存储器读像素，处理后在将结果写入，而是一级一级的送入下一操作，从而算法速度不在受访问存储器数量和速度的限制，起到加速效果；流处理的一个重要特点：有固定的时钟速率，通常每像素一个clk，时钟速率受输入（相机）或输出（显示器）的限制，在输入端，进来的像素必须被处理，否则丢失；显示的时候也必须一个clk产生一个像素，否则显示数据丢失。因此流处理系统的设计至少在输入输出是同步的。流处理很适合低级图像处理操作，入点操作和局部滤波器。
2、许多循环中的迭代类型操作可设计成并行的方式。
3、学会简化处理顺序，比如说做灰度形态学滤波，后进行阈值处理，就完全可以等价于先进行阈值处理，然后二值形态学滤波，这样就可以减少硬件资源的消耗，缩短延迟的时间。
4、还可对数据编码来降低数据量（游程编码）。
设计算法结构隐含的计算结构：
1、主要是对算法进行转化，从而能更有效的利用并行性，达到高效利用硬件资源的效果
2、低级流水线和时序调整可用来减少组合延迟，以提高时钟速率
3、要能选择合适的硬件结构，让它能与软件算法中用到的数据结构一致
算法软硬件划分 并不是算法的所有部分都能很好地映射到硬件上实现，如动态可变长度循环的算法并不适合，对于复杂控制序列的算在软件中实现更好（本质：串行操作）。因此我们应更好地对算法进行软硬件划分：
在指令级层上，应用的大部分在软件中实现，FPGA来实现定制指令，其中FPGA部分被称为硬件加速模块。但对于图像处理来说，这种方式实现整个算法不现实。在任务级层上，整个任务可分配给软硬件来处理，二者相互独立但有必要的通信。如图像采集和低级图像处理由硬件实现，将结果传给软件，来进行高级图像处理操作。 基于FPGA实现图像处理算法流程 提出问题，用Matlab开发图像算法，选择计算结构，算法映射，硬件描述语言设计执行，编译仿真调试等
目标识别与跟踪 一、研究背景 机器视觉应用领域广泛，在工业制造等场景中均扮演着重要的角色。它相当于系统的眼睛，智能机器人视觉系统有着执行自主定位、环境识别、障碍物检测、目标跟踪等仿生功能。但是传统的机器视觉系统（以计算机作为处理器）存在着实时性差的问题，于是根据FPGA体积小、功耗低、速度快、配置灵活、移植方便等优势，我们提出了基于FPGA的目标识别和跟踪。其中主要以FPGA和COMS图像传感器为核心平台来进行视觉系统硬件设计，以硬件描述语言为工具完成了常见经典的数字图像处理算法实现，起到算法加速的效果，最终完成了目标识别跟踪系统的应用开发。
二、主要工作 硬件系统平台搭建与模块化设计、图像预处理算法和目标提取算法的硬件化移植和加速、目标跟踪算法的硬件化实现。
（1）模块化：图像采集、SDRAM存储、VGA显示等。优化：乒乓操作。整体搭建成图像采集与显示的系统。
（2）图像预处理算法的移植。包括RGB-Ycbcr图像灰度转换、快速排序的中值滤波算法、Sobel边缘检测、3*3矩阵的生成以及模板的卷积运算、二值化处理。
（3）对不断运动的目标检测和跟踪，用帧间差分算法（确定目标从背景区域中清晰地提取出来），将算法进行实现和移植，提取运动目标的边缘轮廓，选取运动目标的边缘特征完成基于特征匹配的跟踪算法（目标检测），并计算运动目标的形心位置，对其所在位置进行实时跟踪（目标跟踪）。
目标跟踪：在采集到的连续视频图像中，得到运动目标的位置和完整运动轨迹，并能实时的跟踪定位。
2.1 图像预处理部分 图像预处理算法适合在FPGA上完成，原理简单且需要快速处理，通常有中值、均值滤波等，以及颜色空间转换算法。
2.1.1 图像灰度化
灰度图像是一种特殊的彩色图像（R=G=B的彩色图像）
灰度化处理目的：RGB色彩空间数据计算量大，每一个通道颜色分量都需要计算，另外它不能全面的描绘图像的轮廓特征，只能形成各种各样的颜色。灰度图像可以描述图像轮廓特征且计算数据量小。
灰度化的方法：
（1）三种色彩分量平均化 （2）RGB--Ycbcr 代码实现
2.1.2 中值滤波算法
（能尽可能保留原始图像的信息，减少噪声且保留边缘效果，主要处理椒盐噪声。）
原理是排序比较。将目标图像中的任意像素点的周围像素点的灰度值提取出来，进行中值计算，然后用中值代替该点的像素灰度值。W：模板
代码实现
2.1.3 均值滤波算法
（高频信号被滤除，使得图像平滑模糊，因为它能将突变点的灰度值平均到相邻像素点中，缺点：在像素点跨越连通区域便捷的时候，由于不同区域像素点参与运算，所以会破坏图像的细节，边界模糊）
原理：用任意像素点领域内的像素平均值来代替该像素点的灰度值。M：邻域内包含的总像素点的个数，mn邻域像素点到中心像素点横纵坐标距离的数值。
均值滤波
2.1.4 Sobel边缘检测
对图像的局部像素点进行平均化计算，达到消除噪声和平滑图像的效果（处理具有大量噪声点的图像时效果也好）。
原理：利用梯度信息来对边缘进行检测，通过阈值判断像素点是否属于边缘点。
下图通过设置的阈值对不稳定边缘点进行了剔除。
边缘信息（携带很多轮廓信息）：图像中灰度值出现跳变或者间断的像素点所携带的信息，即局部像素点发生更为明显变化的像素点集合。
Sobel算子包含两个3*3矩阵，即横向算子和纵向算子，两个算子分别与图像做卷积运算，得到横向灰度值和纵向灰度值。
其他目标边缘提取的方式：roberts、prewitt、神经网络。
代码实现：
2.2 运动目标检测算法原理 原理：将确定的运动目标从所在的图像背景区域中清晰的分离，并且进行分析处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7208d125e2f58a8e1723fdcbcddfd36c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deaf7a13f9678a891dcd5e619cb4cd26/" rel="bookmark">
			Python实现四则运算练习系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要知识点：
1）函数
一、菜单函数：
程序流程图：
菜单显示代码： #显示菜单 def Menu(): print("1 加法运算") print("2 减法运算") print("3 乘法运算") print("4 除法运算") print("0 退出") choice = int(input("请输入-&gt;")) return choice 二、实现加法程序
流程图：
代码：
def Add(): for each in range(1,M+1): a = int(random.randint(1,101)) b = int(random.randint(1,101)) ret = a + b print(each,'-&gt;',a,"+",b,"=",end="") ans = int(input()) if ans == int(ret): print("回答正确") else: print("回答错误,正确答案是-&gt;",ret) 完整程序流程图：
完整代码：
#小学生四则运算练习系统 import random #随机数模块 M = 10 #显示菜单 def Menu(): print("1 加法运算") print("2 减法运算"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deaf7a13f9678a891dcd5e619cb4cd26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cd016dcaed2626d52468fa0a882eeaf/" rel="bookmark">
			WINFORM &#43; C# GDI&#43;编程实现Photoshop, Illustrator类似绘图工具箱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看效果：
其中，比较麻烦的是颜色选取工具，如下图：
要求点击上图颜色区域均可弹出如下图所示的颜色选取器对话框，其中：
1、左侧左上角为对象填充，点击右侧右下角为边框颜色选择，左侧左下角为默认颜色填色方式（前景为白色，边框为黑色）。
2、右侧上方按钮为当前颜色选取，中间为渐变颜色填充（待实现），右下角为空颜色（如当前为背景填充，则背景为空，否则边框颜色为空）。
效果如：
此时，前景填充为绿色，边框为深橙色。
由于本项目是公司专为客户产品定制，故无法公开源码，见谅！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ec124137868beb935f9cff5d036e5e3/" rel="bookmark">
			【oracle】随笔
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle数据类型 ① char(size) 定长字符串，最多可以放2000个字符。
name char(32) 如果插入的数据少于32，那么就用空格来填充，如果多余32个，就报错。（一个中文字，占用两个字符空间），一个字符空间是使用一个字节来设计的。
② varchar2(size) 变长，最多可以存放4000个字符。
name(32) 如果插入数据少于32个，那么实际是多长就占用多长，剩余的空间就被回收了。如果超过32个字符，那么会自动增加存储空间。
如果以后要存储的数据是定长的，比如商品编号，身份证号，那么就使用char，不但约束了存储的长度，并且char的存储速度比varchar2快，如果存储的字符是变长的，那么就使用varchar来存储。
③ nchar(size) 定长，最长可以存储2000个字符
nchar采用的是unicode的编码方式。(一个中文字，占一个字符空间)，因为一个字符空间是使用两个字节来设计的。
④ nvarchar2(size) 变长，最长可以存储4000个字符
采用unicode编码方式。
⑤ clob 变长，字符型大对象，最多可存储8TB
⑥ blob 变长，二进制数据，可以存放图片和视屏等
⑦ number(p,s) ，变长
可以存放整数和小数。
p：代表有效位 1 &lt;= p &lt;= 38
s：代表小数位 -84 &lt;= s &lt;= 127
保存数据范围：-1.0e-130 &lt;= number &lt; 1.0e+126
⑧ date 日期类型
按照日-月-年的方式存储的
insert into users vaues(‘12-11月-2017’)；
comment （注释） Oracle数据复库中 comment （注释） 修改方法：分两种情况，一种是表注释制，一种是字段注释。对表或表字段增加或修改注释内容的方法都是一样的。2113
一、表注释修改语法：comment on table 表名 is ‘注释内容5261’;
4102二、字段注释修改语法：comment on column 表名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ec124137868beb935f9cff5d036e5e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9490b359bb7c64ef618497154415cbcb/" rel="bookmark">
			安装的sourcetree打不开，点击完总是出现两个很快闪过
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把C:\Users\admin\AppData\Local\Atlassian里面的文件删除，然后再运行就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbcc976d35e45c79ef45936f9fc3782/" rel="bookmark">
			[echarts] echarts markLine使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="zh-CN" style="height: 100%"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body style="height: 100%; margin: 0"&gt; &lt;div id="container" style="height: 100%"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="https://fastly.jsdelivr.net/npm/echarts@5.3.3/dist/echarts.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var dom = document.getElementById('container'); var myChart = echarts.init(dom, null, { renderer: 'canvas', useDirtyRect: false }); var xAxisData = []; var lineData = []; for (let i = 0; i &lt; 1000; i++) { xAxisData[i] = String(i); lineData[i] = 60 } /** 设值data数据 */ function setValue(start, end, val) { for (let i = start; i &lt; end; i++) { lineData[i] = val } } setValue(200, 210, 59); setValue(210, 260, 58); setValue(400, 420, 40); setValue(420, 430, 59); lineData[560] = 0; lineData[580] = 50; setValue(590, 999, 49); var option = { tooltip: { trigger: 'axis' }, backgroundColor: 'rgb(255,255,255)', grid: { left: '8%', top: 30, right: '5%', bottom: 30, }, xAxis: { type: 'category', boundaryGap: false, axisLabel: { interval: 99 }, data: xAxisData, }, yAxis: { type: 'value', name: '发电期望/W', nameLocation: 'center', nameGap: 50, nameTextStyle: { color: '#000', fontSize: 12 } }, series: [ { symbol: 'none', data: lineData, type: 'line', smooth: true, markLine: { silent: true, symbol: 'arrow', data: [ { silent: false, xAxis: 600, // 表现自定义的位置，可赋值 label: { position: 'end', // 表现内容展示的位置 formatter: '当前值', // 标线展示的内容 color: '#8C8C8C' // 展示内容颜色 }, // lineStyle: { type: 'solid', color: '#C1E7FF', width: 3 } // 样式： 线型、颜色、线宽 }, [ { name: '历史值', label: { position: 'middle', // 表现内容展示的位置 // formatter: '当前值', // 标线展示的内容 color: '#8C8C8C' // 展示内容颜色 }, symbol: 'arrow', coord: [0, 30] }, { symbol: 'arrow', coord: [600, 30] } ], [ { name: '预测值', label: { position: 'middle', // 表现内容展示的位置 // formatter: '当前值', // 标线展示的内容 color: '#8C8C8C' // 展示内容颜色 }, symbol: 'arrow', coord: [600, 30] }, { symbol: 'arrow', coord: [999, 30], } ], ] } } ] }; if (option &amp;&amp; typeof option === 'object') { myChart.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8fbcc976d35e45c79ef45936f9fc3782/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d35022179e0bb08508220b8e9cc1f2e/" rel="bookmark">
			Pytorch（二）:数据读取机制(DataLoader、DataSet)与图像预处理模块(transforms)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：Pytorch是目前学术界使用较为广泛的一种深度学习框架，要想能够熟练使用这个工具，就需要对它有一个全面系统的了解，本专栏就是为了带领大家系统地梳理Pytorch工具中的一些重要知识点，欢迎各位读者批评指正。
目录
1、Pytorch的数据读取机制 1.1数据 1.2 DataLoader
1.3 Dataset
2、图像预处理模块(transforms)
2.1图像变换
2.2图像裁剪
2.3图像翻转与旋转
3、用Pytorch构造自己的数据集(代码实现）
3.1准备数据
3.2读取数据并进行图像预处理
1、Pytorch的数据读取机制 1.1数据 深度学习项目主要由数据、模型、损失函数、优化器以及迭代训练五个模块组成。很明显本小节要讲的Pytorch数据读取机制就是数据模块主要分支中的一个，数据模块包含的内容如下图1所示。Pytorch有一套自己的数据读取方式，就是通过DataLoader来完成的。
图1
1.2 DataLoader torch.utils.data.DataLoader()：构建可迭代的数据装载器, 我们在训练的时候，每一个for循环，每一次iteration，就是从DataLoader中获取一个batch_size大小的数据的。
DataLoader中常用的参数主要有下面5个：
①dataset: 继承于Dataset类， 决定数据从哪读取以及如何读取
②bathsize: 批大小
③num_works: 是否多进程读取机制
④shuffle: 每个epoch是否乱序
⑤drop_last: 当样本数不能被batchsize整除时， 是否舍弃最后一批数据
DataLoader数据读取机制的逻辑是按这3个问题进行下去的：
1）读哪些数据？ 我们每一次迭代要去读取一个batch_size大小的样本，那么读哪些样本呢？
2）从哪读数据？ 也就是在硬盘当中该怎么去找数据，在哪设置这个参数。
3）怎么读数据？也就是通过什么方式来读取到数据。
针对第一个问题， DataLoader是通过自动调用Pytorch内部自带的sampler.py文件来获取每个batch要读取样本的索引的；
针对第二，第三个问题，DataLoader是通过调用Dataset类中的函数来实现的，这里我们必须写一个类来继承Pytorch中的Dataset类，并且必须覆盖重写__init__()，__getitem__()，__len__()三个方法。
1.3 Dataset dataset(继承于Dataset)是DataLoader实例化的一个参数，是需要我们自己用代码实现的一个类，这个类中主要包括__init__()，__getitem__()，__len__()这三个函数：
1）__init__()：相当于Java中类的构造函数，主要解决从哪里读取数据的问题，也就是说该函数里面会定义存放数据的路径；
2）__getitem__()：这个函数主要解决怎么读取数据的问题，就是通过传入的索引Index来读取；
3）__len__()：这个函数主要用来获取数据集中样本的总个数，要不然没法根据batchsize去确定一共有多少批数据。
讲到这里，Pytorch的DataLoader数据读取机制思路基本上理清楚了，接下来谈一谈图像预处理模块（transforms)。
2、图像预处理模块(transforms) transforms中包含了各种常用的图像预处理方法，存放在torchvision这个计算机视觉工具包中，具体见Pytorch官网https://pytorch.org/vision/stable/index.html，主要包括以下方法：
2.1图像变换 ①transforms.Pad(padding, fill=0, padding_mode='constant'): 对图片边缘进行填充
②transforms.ColorJitter(brightness=0, contrast=0, saturation=0, hue=0):调整亮度、对比度、饱和度和色相， 这个是比较实用的方法， brightness是亮度调节因子， contrast对比度参数， saturation饱和度参数， hue是色相因子。
③transfor.RandomGrayscale(num_output_channels, p=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d35022179e0bb08508220b8e9cc1f2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abd0266d7538750be7dbe2ae31ade415/" rel="bookmark">
			基于STM32的数显温度计设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、设计目的 利用STM32完成数显温度计的制作，功能包括实时温度显示（摄氏度与华氏度)，高温与低温报警，以及温区设置。
二、设计方案 系统采用STM2F103C8T6芯片实现，温度传感器采用DS18B20与LM335，显示采用OLED屏幕，温度报警使用LED灯，利用按键进行温区设置。
1.STM32F103C8T6 STM32F103C8T6是一款基于ARM Cortex-M3内核（ARM公司在ARM11以后改用Cortex命名，并分成A、R和M三类，M系列有M0、M0+、M3、M4、M7）的32位的微控制器，采用LQFP48封装，由意法半导体公司（ST）推出，属于STM32系列（ST公司还有SPC5X系列微控制器）。其程序存储器FLASH容量是64KB (64K x 8bit)，RAM容量是20KB(20K x 8bit)，2个12bit ADC合计12路通道（外部通道只有PA0到PA7、PB0到PB1，并不是18通道），37个通用I/O口（PA0-PA15、PB0-PB15、PC13-PC15、PD0-PD1），4个16bit通用定时器（TIM1（带死区插入，常用于产生PWM控制电机）、TIM2、TIM3、TIM4），2个看门狗定时器（独立看门狗、窗口看门狗）1个24bit向下计数的滴答定时器（很重要，一般delay都使用这个定时器实现），2IIC，2SPI，3USART，1CAN，工作电压2V~3.6V，工作温度为-40°C ~ 85°C，系统时钟最高可到72MHz（一般是由8MHz的外部时钟经锁相环9倍频到72MHz）。
2.DS18B20 ( 1 )采用单总线的接口方式 与微处理器连接时仅需要一条口线即可实现微处理器与 DS18B20 的双向通讯。单总线具有经济性好，抗干扰能力强，适合于恶劣环境的现场温度测量，使用方便等优点，使用户可轻松地组建传感器网络，为测量系统的构建引入全新概念。
( 2 )测量温度范围宽，测量精度高 DS18B20 的测量范围为 -55 ℃ ~+ 125 ℃ ; 在 -10~+ 85°C范围内，精度为 ± 0.5°C 。
( 3 )在使用中不需要任何外围元件。
( 4 )持多点组网功能 多个 DS18B20 可以并联在惟一的单线上，实现多点测温。
( 5 )供电方式灵活 DS18B20 可以通过内部寄生电路从数据线上获取电源。因此，当数据线上的时序满足一定的要求时，可以不接外部电源，从而使系统结构更趋简单，可靠性更高。
( 6 )测量参数可配置 DS18B20 的测量分辨率可通过程序设定 9~12 位。
( 7 ) 负压特性电源极性接反时，温度计不会因发热而烧毁，但不能正常工作。
3.LM335 LM335是可以轻松校准的精密温度传感器。它们用作2端稳压管，击穿电压与10mV/°K的绝对温度成正比。
该电路的动态阻抗小于1Ω，可在450mA至5mA的电流范围内工作，而不会改变其特性。
4.OLED OLED 屏幕作为一种新型的显示技术，其自身可以发光，亮度，对比度高，功耗低，在当下备受追捧。而在我们正常的显示调整参数过程中，我们越来越多的使用这种屏幕。我们使用的一般是分辨率为 128x64 ，屏幕尺寸为 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abd0266d7538750be7dbe2ae31ade415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f54348085eb2b7df0cf211bca4f5e57/" rel="bookmark">
			Android AIDL的使用与实现（接上一篇HIDL的实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 AIDL的创建与使用一、server，aidl的服务端二. client，AIDL的客户端3.如有错误，请指正，谢谢 AIDL的创建与使用 server+client 一、server，aidl的服务端 先从AndroidManifest.xml开始
&lt;application android:name=".ApiApplication" android:allowBackup="true" android:directBootAware="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:persistent="false" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true"&gt; &lt;service android:name=".APIService" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="com.xxxxapi.intent.ACTION_API_SERVICE" /&gt; &lt;/intent-filter&gt; &lt;/service&gt; &lt;/application&gt; 里面具体的参数赋值的意义，可以自行百度
&lt;action android:name="com.xxxxapi.intent.ACTION_API_SERVICE" /&gt;这个很重要，在客户端绑定服务端时，需要用到这个intent filter 再创建以下xxxxAPI.aidl文件
package com.emdoor.xxxxapi; import com.emdoor.xxxxapi.APIListener; interface xxxxAPI { int getDisplayInputPortState(int port);	//服务端的API方法 //sendUartData，接引另一篇文章&lt;&lt;Android C++服务创建和HIDL的生成&gt;&gt;， //client通过aidl连接server，server再通过这个方法发送data到hal层的TestOfHidl服务 //TestOfHidl服务server实现的onDataReceived方法,通过APIListener中的onUartDataReceived(in byte[] data)返回数据给app //具体可见稍后的代码 void sendUartData(in byte[] data);	void setAPIListener(in APIListener listener);	//app监听 } 再创建监听文件
// APIListener.aidl package com.emdoor.xxxxapi; interface APIListener { void onUartDataReceived(in byte[] data); } 创建服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f54348085eb2b7df0cf211bca4f5e57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/138cc5415d09be01aab959ed3cb54bbd/" rel="bookmark">
			MATLAB中滤波函数、频率响应函数以及频率响应函数不同表达形式的转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、理论公式 频率响应函数的表达式：
对应的z变换的多项表达式：
Z变换的零极点表达形式：
Z变换的二阶因子级联形式：
二、滤波函数filter filter函数，仅可以用于零状态响应系统。 y=filter(b,a,x) ； %b为z变换多项表达式公式中[b0,b1...bM]的矩阵
%a为z变换多项表达式公式中[a0,a1...aN]的矩阵
%x为输入的原始信号
移动平均滤波的matlab程序示例：
%求解零状态差分方程函数--LTI系统 % y=filter(b,a,x); N=201; n=rand(1,N)-0.5;%噪声信号 k=0:N-1;% x=2*k.*(0.9.^k)+2.0*cos(0.02*pi*k)+5.0;%输入信号 y=x+n;%包含噪声的信号 plot(k,n,'g--',k,x,'b--',k,y,'r-');%显示三个函数图像， xlabel('Time index k'); legend('n[k]','x[k]','y[k]');%添加图例 M=10; b=ones(M,1)/M;%移动平均滤波，10个点相加，再除10，算出平均值 a=[1]; filter_y=filter(b,a,y); plot(k,x,'b-',k,y,'g--',k,filter_y,'r-');%显示三个函数的波形 xlabel('Time index k'); legend('x[k]','y[k]','filter_y[k]');%添加图例 得出的波形如下图：
三、频率响应函数 H=freqz（b,a,w）；
%b为z变换多项表达式公式中[b0,b1...bM]的矩阵
%a为z变换多项表达式公式中[a0,a1...aN]的矩阵
%w为输入的角频率
matlab程序示例
%freqz用以分析离散系统的频率响应 b=[1]; %分子矩阵 a1=[1,-0.9]; a2=[1,0.9];%分母矩阵 w=linspace(0,pi,512);%在0-π范围内等间隔分512份 h1=freqz(b,a1,w);%计算频率响应 h2=freqz(b,a2,w);%计算频率响应 % plot(w,abs(h1),w,abs(h2),':'); plot(w/pi,abs(h1),w/pi,abs(h2),':'); legend('a=0.9','a=-0.9'); 可以看出在分母矩阵为[1,-0.9]时，系统为低通滤波器；分母矩阵为[1,0.9]时，系统为高通滤波器。
四、频率响应函数不同形式的转换 b=[1,4];%Z变换的分子矩阵 a=[1,0.1,-0.2];%Z变换的分母矩阵 z=zeros(1,2);%2*1的矩阵，值为0 % [z,p,K]=tf2zp(b,a);%多项式转零极点表达式 [z,p,K]=tf2zpk(b,a);%多项式转零极点表达式 sos=zp2sos(z,p,K);%零极点转二阶因子级联形式 多项式表达式为
经过matlab计算，得到其零极点表达式为
二阶因子级联形式： （只有1级）
需要注意的是：tf2zp计算出来的结果中只有一个零点，而 tf2zpk计算出来的结果中有两个零点（多出来一个位置在0处的零点）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/138cc5415d09be01aab959ed3cb54bbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26d552330b378436cbdb5e824e348d75/" rel="bookmark">
			VMware vCenter Server Appliance（VCSA）6.0安装过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备 VCSA是vCenter Server Appliance的缩写，是一台预装了vCenter的应用服务器，操作系统为SUSE Linux，最大优点是部署方便，支持内部自带的数据库，或者是使用外部Oracle数据库，VMware vCenter Server Appliance（VCSA）6.0的部署和之前的版本不同，在5.5及之前的版本可以通过导入OVA文件的方式快速部署，但从6.0开始需要在Windows平台上执行安装程序，由安装程序向导完成VCSA的部署。 安装步骤如下：
可以新建一台windows系统的虚拟机，建议win2008或以上，win7有失败的经历。
1、从官网下载VMware-VCSA-all-6.0.0-3634788.iso(3634788是具体版本，也可以是其它版本)； 2、挂载虚拟光驱或解压。 3、先安装VMware-ClientIntergrationPlugin-6.0.0插件。 4、安装完成后，双击vssa-vcsa.html进行安装向导，最好提前安装谷哥浏览器。
二、开始安装
1、选择安装。
2、输入需要部署vcsa的esxi主机的IP地址，以及用户名密码。
3、 输入VCSA的虚拟机名称以及root密码。
4、输入SSO密码，以及域名、站点名称。
5、根据虚拟化平台规档模选择。
6、选择虚拟机存储空间
7、选择嵌入式数据库。
8、输入虚拟机相关信息，FQDN如果没有域环境，就填写IP地址。
9、开始安装过程，很慢。 9、完成后，通过浏览器打开vcsa的IP地址打开登录界面。以刚才设置的SSO用户名登录，如：administrator@ha.local。
由于adobe flash插件的原因，某些浏览器可能会有问题，一般表现为空白页面。这时也可以通过VMware vSphere Client登录。
这时也可以通过VMware vSphere Client客户端登录：
致此，vcsa6.0安装完成。再进行下一步的设置即可。更新许可证，新建数据中心，新建群集，加入主机，新建虚拟机，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d6b8360109eb2cc4fe6db2f4eda9ab8/" rel="bookmark">
			[ WXML 文件编译错误] (env: macOS,mp,1.06.2206090； lib: 2.19.4)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 微信小程序中，通过app.json文件创建一个页面demo，然后开始报错
问题描述 [ WXML 文件编译错误] (env: macOS,mp,1.06.2206090; lib: 2.19.4)
原因分析： 提示的是文件编译错误，然后各种百度都没有查到这个问题。根据提示，应该是该文件中的代码出现错误，导致编译出现问题，但只加入一行，没有动其他的地方，不应该出现这个问题。。。
然后删掉新增出来的整个demo模块文件夹，提示查找不到该 demo文件。重新添加该行代码后，demo文件重新生成，但依然报错。。。
解决方案： 最后是关掉微信开发工具，重新打开，该问题 消失，页面正常显示了。。。自动热重载已经打开了，不应该存在该问题，应该某个bug，或者就是我没有发现是哪里出了什么问题。。。。
在此为出现一样问题的小伙伴提供一个解决方法，另外也请有知道原因的大神说一下原因。。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c6776fa35cacfc0802232a211c941d/" rel="bookmark">
			ES6-string
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		string-includes var str="hello,成都" console.log(String.prototype) var re1=str.includes("成") var re2=str.includes(" ") var re3=str.includes("") console.log(re) 结果：
从上面可以看出string-includes方法就是来检测()内是否存在于被检测字符串中，而且空字符串是存在所有字符串中的
string-startsWith string-endsWith var str="182828323410" var str2=str.startsWith("81",1) var str3=str.endsWith("2341",11) console.log(str2,str3) 结果
startsWith 在代码中所表达的意思就是，是否在字符串中从第二个数字开始为81
endsWith 在代码中表达的意思就是，是否在字符串中以第12位结束的前四位是否是2341
string-repeat var str="重庆" var str2=str.repeat(2) console.log(str2) 结果就是将重庆打印两次
var str="EDG666" var str2="*".repeat(str.length) console.log(str2) 用*将所有的字符串覆盖掉
string-padEnd string-padStart var str="99" var str2=str.padEnd(6,"abc") var str3=str.padStart(6,"abc") console.log(str2,str3) 代码中的padEnd就是将字符串的后6位用abc重复补全
padStart就是将字符串的前6位用abc重复补全
在字符串中使用变量 一共两种方法： 在" "中使用 '+ +' 将变量名包起来就可以使用变量了： var str1="hello" var r=200 var str2='&lt;div style="color:rbg('+r+',100,100)"&gt;'+str1+"&lt;/div&gt;" 在` `中使用${}将变量名包括起来也可以使用变量 var str1="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0c6776fa35cacfc0802232a211c941d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc40100fe1749c7a4af516744299297c/" rel="bookmark">
			Mac：使用IntelliJ IDEA搭建Maven项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关联文件（反正不要钱，一块儿看看吧）
一、maven项目搭建
关联文件（反正不要钱，一块儿看看吧） Mac：如何配置java和maven环境变量
Mac：给IntelliJ IDEA内配置Maven
Mac：使用IntelliJ IDEA搭建Maven项目
一、maven项目搭建 1、首先新建一个项目
​
2、其次，选择maven，并勾选骨架“create from archetype”（目的是方便便捷的开发）。
​
3、创建一个 “项目名称” 和 “项目存放地址”。
​
4、填写maven配置：
（1）Maven home path：一般选择自己下载的maven文件夹的 “根目录”。
（2）user setting file：一般选择自己下载的maven文件夹的 “setting.xml”文件
（3）local repository：本地仓库目录，这个地址是专门存放，所有maven下载的jar包的地方（建议和maven文件在同一个层级下，最好是在 “.m2” 文件夹在；不建议放C盘，比较占用内存）
​
5、最后，maven加载完成之后，就可以进行maven项目编写了（到此maven项目创建完成）。
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f313478e1c29f83eaba400a3f15737/" rel="bookmark">
			lsof命令简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lsof命令简单使用 1.命令用途2.常用的命令列出本机所有的网络连接列出所有tcp 网络连接信息列出所有udp网络连接信息列出正在使用某个端口的进程列出正在使用某个特定的udp端口的进程列出正在使用某个特定的tcp端口的进程查看进程打开的文件查看work用户打开了哪些文件查看进程打开了哪些文件 1.命令用途 lsof 命令常用于查找进程打开了哪些文件以及与打开文件相关联的内容。
2.常用的命令 lsof 列出本机所有的打开的文件
lsof -i :22 查看22端口现在运行什么程序
列出本机所有的网络连接 lsof -i
列出所有tcp 网络连接信息 lsof -i tcp
列出所有udp网络连接信息 lsof -i udp
列出正在使用某个端口的进程 lsof -i :3306
列出正在使用某个特定的udp端口的进程 lsof -i udp:55
列出正在使用某个特定的tcp端口的进程 lsof -i tcp:80
查看进程打开的文件 -c string : 输出 COMMAND 列中包含 string 的项：
lsof -c mysql
-c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成lsof | grep mysql
lsof /usr/local/openresty/nginx/logs/access.log 查看哪些进程在使用文件：/usr/local/openresty/nginx/logs/access.log
针对上面的命令来说，nginx主进程，还要nginx的work进程都会使用该日志文件。
查看work用户打开了哪些文件 lsof -u work 查看work用户打开了哪些文件
查看进程打开了哪些文件 lsof -p 1265 查看pid为1265的进程打开了哪些文件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea442b5b2cf4e97fd11ed0ce363ed8b/" rel="bookmark">
			在CentOS系统下实现MySQL自动全量备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转载自：http://www.softeng.cn/?p=175，本文已获得作者授权，未经作者同意，不可转载。
前言 在Linux操作系统上实现MySQL的自动备份，主要需要两个资料，一个是MySQL数据库备份所需要的脚本，一个是crontab这样的定时任务执行程序。这个脚本可以是任何语言的，只要最终能够将MySQL数据库，导出成SQL文件或者其他你需要的文件即可，而定时任务执行程序，可以是Linux下常用的crontab，也可以是其他定时任务程序。
本文是以shell脚本及crontab定时任务为基础，实现的MySQL数据库定时自动全量备份。其功能具体描述为：
实现当前Linux服务器上MySQL服务器里的所有库的全量数据+结构备份；实现备份脚本只保留近15天，15天以前的备份脚本自动删除；实现每天在指定的时间开始进行备份工作。 准备工作 使用如下命令安装crontab（已安装的可以跳过）
yum install -y vixie-cron crontabs 创建mysql备份文件的存放路径
mkdir -p /alidata/backup/databases mkdir -p /alidata/backup/databases/mysql 这里的路径可以根据实际情况修改，但是如果修改了这里的路径，也需要修改下面备份脚本里的路径。这里的路径只需要具有root权限就可以了。
MySQL备份脚本 下面先贴出本文所需要使用的MySQL备份脚本
#!/bin/bash PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/alidata/server/mysql/bin:/root/bin:~/bin export PATH #current datetime DATE=$(date -d '+0 days' +%Y%m%d%H%M) #backup directory BACKUP_ROOT=/alidata/backup/databases BACKUP_DIR=mysql DATA_DIR=mysql_$DATE #get all database name SQL_STRING="SELECT SCHEMA_NAME AS db FROM information_schema.SCHEMATA WHERE SCHEMA_NAME NOT IN ('mysql', 'information_schema', 'performance_schema');" DBS=$(echo $SQL_STRING | mysql -Bs) #package name ZIP_NAME="mysql_"$DATE".tar.gz" #remove backup of the database before 15 days find $BACKUP_ROOT/$BACKUP_DIR -name "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dea442b5b2cf4e97fd11ed0ce363ed8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23b59832cf6533a327c9a62e42a09e89/" rel="bookmark">
			mongodb压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装压测工具 # 1 mongodb环境 已安装mongodb单节点服务或副本集模式选择对主节点测试即可 # 2 安装 JAVA 和 Maven yum install java-devel -y wget http://ftp.heanet.ie/mirrors/www.apache.org/dist/maven/maven-3/3.1.1/binaries/apache-maven-3.1.1-bin.tar.gz tar xzf apache-maven-*-bin.tar.gz -C /usr/local cd /usr/local ln -s apache-maven-* maven # 编辑 maven.sh 添加内容： vim /etc/profile.d/maven.sh # 加入如下内容： export M2_HOME=/usr/local/maven export PATH=${M2_HOME}/bin:${PATH} source /etc/profile # 确定 mvn 是否安装成功： mvn -version # 3 下载 YCSB cd /usr/src curl -O --location https://github.com/brianfrankcooper/YCSB/releases/download/0.5.0/ycsb-0.5.0.tar.gz tar xfz ycsb-0.5.0.tar.gz cd ycsb-0.5.0 # 4 编辑配置文件 vim workloads/workloada # 修改如下内容： mongodb.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23b59832cf6533a327c9a62e42a09e89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf376772f4e7d76bd5bc734637dda1d8/" rel="bookmark">
			Springboot中单元测试处理@value简单方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/loongshawn/article/details/109394633
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e8e9bb1e767faa3d693f8e1d4a4d486/" rel="bookmark">
			Python通过selniumwire抓取公开信息全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python抓取数据解析有两种模式，一种是网站前后端融合的情况，利用Beautiful Soup 来解析，即网页显示有什么就能抓取什么，这种方法缺陷是解析速度慢，以及网页结构可能变化要随时修正脚本。另一种是针对前后端分离的情况，网站后端通过接口返回数据给前端解析显示，这种时候我们只需要抓到这个接口，再发起请求就可以得到数据字段比页面显示更丰富、格式更标准的数据。
对前后端分离的网站，在发起请求时会调用自身的接口返回数据给前端，如果是普通网站这时候我们已经可以通过浏览器F12观察接口的header，在脚本里构造好带cookies、header、请求参数params的get/post请求。这里使用高级查询功能调用接口
但在脚本里直接用request请求接口时候会发现，接口只可用一次，每次只返回20条数据。这是因为请求里含分页信息，每页只返回20条，获取更多则需要在请求参数里填写请求第二页第三页。而我们脚本利用构造的请求时，只会返回当页请求，无法返回第二页第三页，仔细观察，原来是请求头headers中构造了一个企查查的自定义字段，每次发起新请求时(包括请求其他页数)该字段都会变化，所以脚本无法直接利用request请求所有数据。
但是我们在浏览器里访问的时候，是可以手动点击下一页下一页的，所以我们可以采用selnium来模拟浏览器的操作，来获得每次请求时网站生成的header中随机自定义字段，再利用request请求调用企查查原生接口获得返回数据。selnium是用脚本模拟人操作浏览器的工具，可以做到和人工操作一样，来完成一些纯请求脚本不好做的事情，支持多种浏览器，这里下载一个谷歌浏览器，再下载对应谷歌浏览器版本的selnium驱动放到Python文件夹里即可。我们在这里除了要模拟浏览器操作，还需要获取请求头headers的信息，所以我们要用的是selniumwire，可以理解为selnium加强版。
技术路径准备好后，考虑抓取流程，即使在浏览器里查看，每次最多也只会返回5000条数据，所以要把这500多W条抓完，就必须把数据分段，这里可以使用企业注册日期来分段，使得每个日期区间的企业数量在5000条内即可，然后脚本中模拟人工查询、翻页操作，再调用request请求解析最后写入数据库。
首先我们要做日期分段功能，把日期切分到每段区间不超过5000条。人工观察了下，越早注册的企业越少，后期成都注册的企业一天就几千条了，所以我按照时间来粗分。2003年以前，以30天为分段；2003-2015以5天为分段；2015以后，每天为分段。期间如果多天分段的大于5000条则进一步拆分为每天分段，如果每天也大于5000则记录到日志中跳过，如果某段结果小于1000条，则扩展该段日期。
导入和定义一些基础信息 import sys from ast import keyword from asyncio.windows_events import NULL from cgitb import small from cmath import e from ctypes import addressof from email import header import email import errno import json from nturl2path import url2pathname from os import stat from pickletools import long1 from re import S from tkinter import E from urllib.error import HTTPError import winreg #windows相关库 #加载自动化测试模块 #from selenium import webdriver from bs4 import BeautifulSoup #网页解析库 import urllib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e8e9bb1e767faa3d693f8e1d4a4d486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1481f329fde745bf4713af2584dcaf2b/" rel="bookmark">
			钢筋盘点计数数据集图片展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集分为训练集和测试集，其中训练集共有569张已标注图片，测试集共有85张未标注图片，共计654张。其图片质量与标注质量满足工业化生产实际需要，质量保障。
有需要的可以到我的资源中进行下载，链接如下：
https://download.csdn.net/download/qq_41007606/86050276
​​​​​​​https://download.csdn.net/download/qq_41007606/86053800
https://download.csdn.net/download/qq_41007606/86053836
https://download.csdn.net/download/qq_41007606/86053869
https://download.csdn.net/download/qq_41007606/86053899
https://download.csdn.net/download/qq_41007606/86053921
https://download.csdn.net/download/qq_41007606/86053944
https://download.csdn.net/download/qq_41007606/86053967
训练集：
标注文件：
测试集：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f14f1fd17a482de59656ea1293a30f03/" rel="bookmark">
			JAVA快速入门、IDEA开发工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42372075ef80e53ee330e8710f73fde0/" rel="bookmark">
			virtuoso配合calibre进行电路后仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 提取寄生参数以进行后仿真是电路设计的必由之路。
一、寄生参数提取的基本介绍 在calibre PEX流程中，常见的输出方式有calibre view和spectre netlist。
calibre输出格式选择 前者直接生成一幅直观的电路图，甚至器件的位置都和版图大致对应，非常方便观察内部的节点，但缺点是生成这么大一幅电路图，很容易卡顿；而仿真时要将这么大一幅电路图生成netlist，也会很卡顿。
注：最重要的是很多low工艺不提供接口文件，无法生成calibre view。
后者是以网表文件形式存储寄生参数，不是很直观，但是速度相对较快。以最复杂的r+c+cc为例，输出方式选取为spectre netlist时，会生成三个文件。top.pex.netlist, top.xxx.pxi, top.xxx.pex.
其中netlist后缀的文件是顶层文件，列出了电路中用到的所有器件。
二、如何用生成的netlist仿真？ 和AMS混仿相似，需要为已有的仿真电路建立config，然后在config中将某个模块的view设置为spice文件：
config中调用含寄生参数的网表 其后的流程和正常仿真相同。
三、常见的问题 3.1 生成的netlist端口不对应 pex生成spectre netlist时，默认的端口顺序是按照字母进行排列的。这就会导致端口不对应的问题。按照下图方式进行设置即可：
设置网表端口的顺序 3.2 仿真时不支持总线 有的电路中存在总线端口，例如test&lt;3:0&gt;，仿真时可能会出错。解决方法是先打开config的properties：
然后在下图中输入-auto_bus：
四、屏蔽部分模块 后仿真可能会看到性能的衰退，例如在一个SAR ADC中，电容阵列版图必然存在着不对称的寄生，导致后仿真性能下降。但是，电容阵列的失配将在测试时被校准，仿真时不必在意。因此，后仿时需要屏蔽掉电容阵列的寄生来评估性能。
为了屏蔽某个模块的寄生参数，首先选择gate level格式：
然后配置xcell文件，例如要屏蔽cellA这个模块，xcell文件里这样写即可：cellA cellA.
此时，生成的netlist文件中，只会对cellA这个模块进行例化。注意此时并不能正常仿真，因为生成的netlist只是例化了cellA，并没有给出cellA内部的电路。为了正常仿真，在ADE窗口-setup-simulation file添加cellA的spectre网表。
五、观测内部节点 按照如上的方式进行后仿真时，所有的内部节点均被“埋在”了pex生成的netlist中，无法用ADE–&gt;OUTPUT–&gt;Saved这种方式直接保存。
此时需要用到deepprobe来观测内部节点，具体用法不再赘述。
如果采用AMS仿真，问题会稍麻烦。此时AMS仿真器生成的网表格式如下：
module top_testbench: port: I0 I1 ... I_pex(xxx xxx xxx) ... endmodule include I_pex.netlist 概括来说就是：Verilog格式的网表调用spectre格式的网表。
笔者目前使用的cadence版本中，deep probe不支持probe这种形式的内部节点。为解决这个问题，需要将I_pex.netlist中需要探测的节点做成端口，在顶层的top_testbench中增加一根线来连接到I_pex.netlist中新增的端口。
例如要观测I_pex.netlist中的test001节点，此时需要在I_pex.netlist中手动增加一个test001端口，再将上述网表改为：
module top_testbench: port: wire test001; I0 I1 ... I_pex(xxx xxx xxx test001) .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42372075ef80e53ee330e8710f73fde0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5d0810f4f1c380a3c1df1dd87401a0e/" rel="bookmark">
			PTP移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：libmnl移植
源码：git clone git://git.netfilter.org/libmnl
./autogen.sh
交叉编译：
1 ./configure --host=arm-linux-gnueabi CC=交叉编译工具 CFLAGS=-march=armv5te --prefix=安装目录 2 make -j6 3 make install 2.移植ethtool
源码 ：ethtool - utility for controlling network drivers and hardware (kernel.org)
./autogen.sh ./configure --host=arm-linux-gnueabi CC=arm-linux-gnueabi-gcc MNL_CFLAGS="-I/tmp/libmnl/include" MNL_LIBS="-L/tmp/libmnl/lib -lmnl" --prefix=安装目录
make
make install
3:查看网卡是否支持软硬件时间戳
ethtool -T eth0
软件时间戳需要包括参数
SOF_TIMESTAMPING_SOFTWARE
SOF_TIMESTAMPING_TX_SOFTWARE
SOF_TIMESTAMPING_RX_SOFTWARE
硬件时间戳需要包括参数
SOF_TIMESTAMPING_RAW_HARDWARE
SOF_TIMESTAMPING_TX_HARDWARE
SOF_TIMESTAMPING_RX_HARDWARE
4:PTP交叉编译
源码：linuxptp download | SourceForge.net
1.首先更改makefile
CC= gcc #这里修改成你的交叉编译器
2.make
编译完成，生成ptp4l phc2sys
参数：ptp4l参数如下：
$ ptp4l -h 延迟机制选项 -A Auto，自动选择延迟机制。,从E2E开始，当收到对等延迟请求时切换到P2P -E E2E，选择延迟请求 - 响应（E2E）机制。 默认是用这个机制。 单个PTP通信路径上的所有时钟必须使用相同的机制。 使用E2E机制在端口上收到对等延迟请求时，将输出warning -P P2P，对等延迟机制 网络传输选项 -2 IEEE 802.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5d0810f4f1c380a3c1df1dd87401a0e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/253/">«</a>
	<span class="pagination__item pagination__item--current">254/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/255/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>