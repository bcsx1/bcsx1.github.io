<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.121.1">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程随想</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程随想的博客">
		<meta property="og:title" content="编程随想" />
<meta property="og:description" content="编程随想的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程随想">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程随想" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程随想</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22df7fadb5470aaf3c6337b27ce1ef98/" rel="bookmark">
			Opencv之停车场车位识别（不用类不用函数，一步步实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目要求 给出一段停车场的视频，要求实时检测空停车位的数量及位置。
思路 从这段视频中取出一帧图片。对图片进行处理，只保留图片中的有效信息（停车位）。将所有停车位取出来，分别保存为单独的.jpg文件作为样本（包含空停车位和非空停车位）。训练二分类模型识别此停车位上是否有车。将空停车位在图上标记出来。在视频中实时监测并标记空停车位。 实现过程 1、引入需要的库 import cv2 as cv import numpy as np import operator import pickle from keras.models import load_model 2、定义画图函数 def cv_show(name, img): cv.imshow(name, img) cv.waitKey(0) cv.destroyAllWindows() 3、读取从视频中截取的图像 image = cv.imread('./test_images/scene1410.jpg') cv_show('src', image) 图像：
4、掩膜以去除背景 4.1 制作mask lower = np.uint8([120, 120, 120]) upper = np.uint8([255, 255, 255]) # lower_red和高于upper_red的部分分别变成0，lower_red～upper_red之间的值变成255,相当于过滤背景 white_mask = cv.inRange(image, lower, upper) cv_show('white_mask',white_mask) mask：
4.2 与操作去除背景 white_yellow_image = cv.bitwise_and(image, image, mask = white_mask) cv_show('white_yellow_image', white_yellow_image) 去除背景后的图片：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22df7fadb5470aaf3c6337b27ce1ef98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aa5e8d001400d1b0d46a181afe2c5a4/" rel="bookmark">
			P1886 滑动窗口 /【模板】单调队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开
题目描述
有一个长为 nn 的序列 aa，以及一个大小为 kk 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。
例如：
The array is [1,3,-1,-3,5,3,6,7][1,3,−1,−3,5,3,6,7], and k = 3k=3。
输入格式
输入一共有两行，第一行有两个正整数 n,kn,k。 第二行 nn 个整数，表示序列 aa
输出格式
输出共两行，第一行为每次窗口滑动的最小值
第二行为每次窗口滑动的最大值
输入输出样例
输入 #1复制
8 3
1 3 -1 -3 5 3 6 7
输出 #1复制
-1 -3 -3 -3 3 3
3 3 5 5 6 7
说明/提示
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 1e6 + 7; int a[maxn]; int l1,r1,l2,r2; int n,k; struct QUE { int i,x; }q1[maxn],q2[maxn]; void solve1(int x)//递增 { while(l1 &lt;= r1 &amp;&amp; x - q1[l1].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7aa5e8d001400d1b0d46a181afe2c5a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49c1cf551275aa8a4f32cd856cbe8373/" rel="bookmark">
			CIM系统简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CIM系统简介 什么是CIM系统CIM的功能CIM组成CIM架构CIM功能模块CIM的目的CIM的基本要求 什么是CIM系统 Computer Integrated Manufacturing，计算机整合制造利用计算机和网络来整合并控制生产在线的信息流及物流，以达到优化的生产效率。 物流管控、信息管控
CIM的功能 生产排程:
PC Plan modeling 整合控管、工厂准备物料需求计划：Glass 制程原料库存管理配送需求计划
CIM组成 MES：制造执行系统,CIM的逻辑核心Auto：在此泛指机台联机自动化或In-Line EQ的glass 流程管控, 以预定的逻辑来达成监控或控制机台行为BC: Block Controller, 泛指在inline EQ中, 用以控制各子机台顺利联结, 并控制glass在inline机台中流向, 其中除透过TCS Download必要信息到各子机台外, 更利用MPLC来获取各子机台如状态, EDC…等必要资料上传到MES.MCS: Material Control System, AMHS系统中的核心软件, MES会下达搬送命令给他, 而MCS主要工作便是运用预先定义好的Routing Path, 选择最佳的搬送路径将MES的Marco命令解析为好几个Micro命令在分别下达给如STKC, AGVC, RGVC, HOSC…等各搬送实体的控制器.OPI: Operator Interface ,用以查询,调整或设定FAB内WIP或流程的CIM子系统 CIM架构 DCS：设定搬送的规则MCS：下定搬送的指令WIP：在制品管理CFM：机台运行情况监管HIS：记录生产履历（数据库）SPC：利用统计对质量管控BRM：生产建模的基本数据设定ALM：生产报错OPI：人工介入操作RMS：机台参数管控PMS：机台保养计划 CIM功能模块 CIM的目的 控制生产作业流程提高生产效率增加生产良率减少人为疏失机台生产讯息管理机台自动化生产,降低人力成本 CIM的基本要求 注: MTBF,即平均故障间隔时间，英文全称是“Mean Time Between Failure”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48667f8d4e9c0d8526b5aea1978b92ae/" rel="bookmark">
			将正方形矩阵顺时针旋转90度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定一个矩阵matrix，把矩阵顺时针转动90度：
1 2 3
4 5 6
7 8 9
-&gt;
7 4 1
8 5 2
9 6 3
思路 比较简单的思路
1）先上下对称
-&gt;
7 8 9
4 5 6
1 2 3
2）对角互换
-&gt;
7 4 1
8 5 2
9 6 3
实现 def rotate(matrix): if matrix is None or len(matrix) == 0 or len(matrix[0]) != len(matrix): return size = len(matrix) for i in range(size//2): matrix[i], matrix[size-i-1] = matrix[size-i-1], matrix[i] for i in range(size): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] return matrix 测试 def test_rotate(size): n = 1 mat = [] for i in range(size): row = [n+j for j in range(size)] n += size mat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48667f8d4e9c0d8526b5aea1978b92ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/beffefc1440e59d2b09edbdb45244a45/" rel="bookmark">
			转圈打印矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 给定一个整数矩阵matrix，请按转圈打印的方式打印，如：
1 2 3
4 5 6
7 8 9
打印为：1，2，3，6，9，8，7，4，5
思路 一圈一圈地打印，每圈打印的时候分四个方向打印，圈之间可以递归，也可以循环。
实现1 def cycle_print1(matrix): def recursive(matrix, row_beg, row_end, col_beg, col_end): if row_beg &gt; row_end or col_beg &gt; col_end: return if row_beg == row_end: for c in range(col_beg, col_end+1): result.append(matrix[row_beg][c]) elif col_beg == col_end: for r in range(row_beg, row_end+1): result.append(matrix[r][col_beg]) else: for c in range(col_beg, col_end+1): result.append(matrix[row_beg][c]) for r in range(row_beg+1, row_end+1): result.append(matrix[r][col_end]) for c in range(col_end-1, col_beg-1, -1): result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/beffefc1440e59d2b09edbdb45244a45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c2d0ac41300f087a64a5c5f4adc61df/" rel="bookmark">
			VFIO概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.IOMMU1.1 IOMMU功能简介1.2 IOMMU作用1.3 IOMMU工作原理1.4 Source Identifier 2.VFIO2.1 概念介绍2.2 使用示例 3.设备透传分析3.1 虚机地址映射3.2 设备透传实现 1.IOMMU 1.1 IOMMU功能简介 IOMMU主要功能包括DMA Remapping和Interrupt Remapping，这里主要讲解DMA Remapping，Interrupt Remapping会独立讲解。对于DMA Remapping，IOMMU与MMU类似。IOMMU可以将一个设备访问地址转换为存储器地址，下图针对有无IOMMU情况说明IOMMU作用。
在没有IOMMU的情况下，网卡接收数据时地址转换流程，RC会将网卡请求写入地址addr1直接发送到DDR控制器，然后访问DRAM上的addr1地址，这里的RC对网卡请求地址不做任何转换，网卡访问的地址必须是物理地址。
对于有IOMMU的情况，网卡请求写入地址addr1会被IOMMU转换为addr2，然后发送到DDR控制器，最终访问的是DRAM上addr2地址，网卡访问的地址addr1会被IOMMU转换成真正的物理地址addr2，这里可以将addr1理解为虚机地址。
左图是没有IOMMU的情况，对于虚机无法实现设备的透传，原因主要有两个：一是因为在没有IOMMU的情况下，设备必须访问真实的物理地址HPA，而虚机可见的是GPA；二是如果让虚机填入真正的HPA，那样的话相当于虚机可以直接访问物理地址，会有安全隐患。所以针对没有IOMMU的情况，不能用透传的方式，对于设备的直接访问都会有VMM接管，这样就不会对虚机暴露HPA。
右图是有IOMMU的情况，虚机可以将GPA直接写入到设备，当设备进行DMA传输时，设备请求地址GPA由IOMMU转换为HPA（硬件自动完成），进而DMA操作真实的物理空间。IOMMU的映射关系是由VMM维护的，HPA对虚机不可见，保障了安全问题，利用IOMMU可实现设备的透传。这里先留一个问题，既然IOMMU可以将设备访问地址映射成真实的物理地址，那么对于右图中的Device A和Device B，IOMMU必须保证两个设备映射后的物理空间不能存在交集，否则两个虚机可以相互干扰，这和IOMMU的映射原理有关，后面会详细介绍。
1.2 IOMMU作用 根据上一节内容，总结IOMMU主要作用如下：
屏蔽物理地址，起到保护作用。典型应用包括两个：一是实现用户态驱动，由于IOMMU的映射功能，使HPA对用户空间不可见，在vfio部分还会举例。二是将设备透传给虚机，使HPA对虚机不可见，并将GPA映射为HPAIOMMU可以将连续的虚拟地址映射到不连续的多个物理内存片段，这部分功能于MMU类似，对于没有IOMMU的情况，设备访问的物理空间必须是连续的，IOMMU可有效的解决这个问题 1.3 IOMMU工作原理 前面简单介绍了IOMMU的映射功能，下面讲述IOMMU到底如何实现映射的，为便于分析，这里先不考虑虚拟化的场景，以下图为例，阐述工作原理。
IOMMU的主要功能就是完成映射，类比MMU利用页表实现VA-&gt;PA的映射，IOMMU也需要用到页表，那么下一个问题就是如何找到页表。在设备发起DMA请求时，会将自己的Source Identifier(包含Bus、Device、Func)包含在请求中，IOMMU根据这个标识，以RTADDR_REG指向空间为基地址，然后利用Bus、Device、Func在Context Table中找到对应的Context Entry，即页表首地址，然后利用页表即可将设备请求的虚拟地址翻译成物理地址。这里做以下说明：
图中红线的部门，是两个Context Entry指向了同一个页表。这种情况在虚拟化场景中的典型用法就是这两个Context Entry对应的不同PCIe设备属于同一个虚机，那样IOMMU在将GPA-&gt;HPA过程中要遵循同一规则由图中可知，每个具有Source Identifier(包含Bus、Device、Func)的设备都会具有一个Context Entry。如果不这样做，所有设备共用同一个页表，隶属于不同虚机的不同GPA就会翻译成相同HPA，会产生问题， 有了页表之后，就可以按照MMU那样进行地址映射工作了，这里也支持不同页大小的映射，包括4KB、2MB、1GB，不同页大小对应的级数也不同，下图以4KB页大小为例说明，映射过程和MMU类似，不再详细阐述。
1.4 Source Identifier 在讲述IOMMU的工作原理时，讲到了设备利用自己的Source Identifier(包含Bus、Device、Func)来找到页表项来完成地址映射，不过存在下面几个特殊情况需要考虑。
对于由PCIe switch扩展出的PCI桥及桥下设备，在发送DMA请求时，Source Identifier是PCIe switch的，这样的话该PCI桥及桥下所有设备都会使用PCIe switch的Source Identifier去定位Context Entry，找到的页表也是同一个，如果将这个PCI桥下的不同设备分给不同虚机，由于会使用同一份页表，这样会产生问题，针对这种情况，当前PCI桥及桥下的所有设备必须分配给同一个虚机，这就是VFIO中组的概念，下面会再讲到。对于SRIO-V，之前介绍过VF的Bus及devfn的计算方法，所以不同VF会有不同的Source Identifier，映射到不同虚机也是没有问题的 2.VFIO VFIO就是内核针对IOMMU提供的软件框架，支持DMA Remapping和Interrupt Remapping，这里只讲DMA Remapping。VFIO利用IOMMU这个特性，可以屏蔽物理地址对上层的可见性，可以用来开发用户态驱动，也可以实现设备透传。
2.1 概念介绍 先介绍VFIO中的几个重要概念，主要包括Group和Container。
Group：group 是IOMMU能够进行DMA隔离的最小硬件单元，一个group内可能只有一个device，也可能有多个device，这取决于物理平台上硬件的IOMMU拓扑结构。 设备直通的时候一个group里面的设备必须都直通给一个虚拟机。 不能够让一个group里的多个device分别从属于2个不同的VM，也不允许部分device在host上而另一部分被分配到guest里， 因为就这样一个guest中的device可以利用DMA攻击获取另外一个guest里的数据，就无法做到物理上的DMA隔离。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c2d0ac41300f087a64a5c5f4adc61df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6dd79d2d6e272597edc7ce92e856afe7/" rel="bookmark">
			Markdown 小技巧之图片左对齐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片默认剧中对齐例如：
如果希望图片左对齐，左对齐很简单，单行图片的情况下在前面输入一个空格就解决了，右对齐就需要靠css了
CSDN好像不存在这个问题，默认都是左对齐！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/457ef1590b4cdb60eb80ec9536b5462a/" rel="bookmark">
			字典树（前缀树）的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目 字典树又称为前缀树或Trie树，是处理字符串常见的数据结构。假设组成所有单词的字符仅是’a’~'z’的小写字母，请实现字典树结构，包括如下功能：
insert，添加word，可重复添加delete，删除word，如果word添加过多次，仅删除一个search，查询word是否在字典树中prefix_number，返回以字符串pre为前缀的单词数量 实现 import random import string class TrieNode(): def __init__(self): self._end = 0 self._path = 0 self._map = [None for _ in range(26)] class Trie(): def __init__(self): self._root = TrieNode() def insert(self, s): if s is None: return node = self._root for c in s: index = ord(c) - ord('a') assert(0 &lt;= index &lt; 26) if node._map[index] is None: node._map[index] = TrieNode() node = node._map[index] node._path += 1 node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/457ef1590b4cdb60eb80ec9536b5462a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f56aeafd1d37d070cb230d8c63587bf/" rel="bookmark">
			Chameleon变色龙聚类算法小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：https://blog.csdn.net/qiu1440528444/article/details/80725142
推荐代码（java代码，亲测能用）：https://github.com/kstanisz/chameleon-clustering
前言 Chameleon，变色龙算法，属于层次聚类算法领域。一种层次聚类算法，它采用动态建模来确定一对簇之间的相似度。它可以自动地、适应地合并簇，对各种奇葩的形状也能应对自如。
1. Chameleon 算法原理 一张图大致了解整个算法的思想。
1) 首先由数据集构造一个 k-最近邻图 Gk；
2) 再通过一种图的划分算法，将Gk图划分成大量较小的子图，每个子图代表一个初始的子簇；
3) 最后使用凝聚层次聚类算法，基于子簇的相似度反复合并子簇。
下面再看看定义的一些概念，为了引出变色龙算法的一些定义，这里先说一下以往的一些聚类算法的不足之处，如图。
1) 如图4所示：忽略簇与簇之间的互连性。
如果只看最近邻的链接，即只看近似性，则算法会倾向于合并c和d而不是a和b，但实际上a、b的临接区域较大，距离也不远（相对于a、b内部），即互连性更好，所以应该属于同一个cluster簇。
2) 如图5所示：忽略簇与簇之间的近似性。就是过分强调临接区域的大小，倾向于合并a、c，而不是a、b。
Chameleon算法正好弥补了这2点要求，兼具互连性和近似性。下面用公式来描述这2个概念。
2. 概念：互连性和近似性 簇的互连性，同时考虑 两个簇之间的距离 和 簇内各元素之间的距离，用相对互联度（RI）来量化得衡量：
R I ( C i , C j ) = ∣ E C ( C i , C j ) ∣ ∣ E C ( C i ) ∣ + ∣ E C ( C j ∣ 2 RI(C_i,C_j)=\frac{|EC(C_i,C_j)|}{\frac{|EC(C_i)|+|EC(C_j|}{2}} RI(Ci​,Cj​)=2∣EC(Ci​)∣+∣EC(Cj​∣​∣EC(Ci​,Cj​)∣​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f56aeafd1d37d070cb230d8c63587bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4e7d053d4dc31f5c8f1fb387672a236/" rel="bookmark">
			35岁技术人如何转型做管理？阿里高级算法专家公开10大思考
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介： 35岁左右对工程师而言是个不同寻常的年龄段。技术人有可能面临人生中的转型：从纯技术岗转向管理岗。也将面临诸多新的挑战，关于组建团队、领导以及KPI设置等。本文将讲述阿里资深技术leader张荣从去年1月底接手CRO线NLP算法团队以来，在团队组建、能力建设、以及管理上的一些思考。这些思考从实践中来，总结出一套方法论，希望能给予转型中的技术人一些启发。 张荣，花名威视，现任职阿里巴巴 CRO 线 NLP 算法团队 leader ，长期聚焦于 NLP 、图像识别、视频分析算法领域。
作者 | 威视
因为信任，所以简单。
团队的定位是什么？——做正确的事 定位
团队的定位是重要的事情之一，一旦有了偏差，后续做得越多错得越多。确定团队的定位花了我很长时间，中间还发生了一次组织变化，和两任主管有多次讨论。
首先，这个团队配置在 CRO 线，肯定要为风险管理业务服务；同时，这又是一支能力团队，还要考虑和业务团队的协同关系。最终，我确定了3点：
1、能力建设为主，同时也需要有业务抓手；
2、不做业务团队已经做得好的事情；
3、立志高远，勇攀高峰，要做就做到最好。
壁垒与价值
不夸张地说，现在是NLP领域的大航海时代，新算法层出不穷，日新月异，后浪各种把前浪碾死在沙滩上。尤其是 BERT 横空出世之后，整个 NLP 的研究范式都发生了变化，从原来的 task-specific 的模型结构设计转变到语言模型 pretrain+ 下游任务 finetuning 的模式，预训练模型是含金量高的工作。研究一下预训练模型，你会发现这是个需要海量金钱+数据+技术才能玩的游戏。
这就陷入两难：如果搞预训练模型，没那么多资源；如果不搞，用开源模型做下游任务，实际上很难有什么技术壁垒。其实就算你真的搞出什么新算法可以充当技术壁垒，可能两三个月之后就又有人做出了更强的结果。
困境的根源在于，目前 NLP 算法这个领域发展速度太快了，在高速变化的领域是很难形成壁垒的。所以，我们需要结合自身所处的环境，寻找变化不那么快的东西。
我经过好多天的考虑之后，认为沉淀风险管控知识可以作为壁垒。原因：1）风险知识随时间有变化，但速度明显比算法慢很多；2）CRO 线在这方面有一定积累，也需要用于实际业务管控，并沉淀到产品。
所以，团队的宗旨我定义为：基于知识驱动的 NLP 算法团队。为 CRO 线乃至集团沉淀风险知识，并提供不同层次的服务：
图：4层服务体系
最近，CRO 线在清华举办了 AI 与安全研讨会，会上张钹院士谈到了第三代人工智能，尤其强调了其中知识的核心作用；我们走访中科院信工所，对方的宗旨也是建设基于知识驱动的算法，和业界发生的共鸣，更坚定了我们走这条道路的决心和信心。
团队需要什么能力？ 先要搞清楚团队所处的环境。
阿里是一个什么结构的组织？
有人说是矩阵式的，有人说是树+网状的，我不知道确切的答案。不过，如果把每个小团队看作节点的话，有 2 点是确定的：
1、体量巨大，各种节点（业务、产品、工程、算法）种类繁多数量大。
2、单元节点之间比较容易发生跨大团队甚至跨 BU 的联系，条件合适可以发生协同关系。
继续观察，你会发现：
1、你所需要的一切资源几乎都能找到提供者，而且往往不止一个。
2、你也可以给各种需求节点提供服务，只要还在你的能力范围内。
3、由于规模巨大，需求节点和资源节点相互之间往往不知道对方在哪。
基于以上，我认为一个身处中台的算法团队，需要具备 4 项能力：连接-生产-传播-服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4e7d053d4dc31f5c8f1fb387672a236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f8e7d0749e57098f2d993053abc9444/" rel="bookmark">
			【漏洞练习-Day10】FengCms 1.32与Simple-Log1.6网站重装漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开始练习【红日团队】的PHP-Audit-Labs 代码审计 Day10
链接：https://github.com/hongriSec/PHP-Audit-Labs
感兴趣的同学可以去练习练习
预备知识：
内容题目均来自 PHP SECURITY CALENDAR 2017
Day 10 - Anticipation代码如下：
extract($_POST); function goAway() { error_log("Hacking attempt."); header('Location: /error/'); } if (!isset($pi) || !is_numeric($pi)) { goAway(); } if (!assert("(int)$pi == 3")) { echo "This is not pi."; } else { echo "This might be pi."; } 漏洞解析 ：
这道题目实际上讲的是当检测到攻击时，虽然有相应的防御操作，但是程序未立即停止退出，导致程序继续执行的问题。程序在第一行处 使用 extract函数，将POST请求的数据全都注册成变量。
extract () 函数: (PHP 4, PHP 5, PHP 7)
功能： extract() 函数从数组中将变量导入到当前的符号表。
定义: extract(array,extract_rules,prefix) 说明： 参数描述array必需。规定要使用的数组。extract_rules可选。extract() 函数将检查每个键名是否为合法的变量名，同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。prefix可选。如果 extract_rules 参数的值是 EXTR_PREFIX_SAME、EXTR_PREFIX_ALL、 EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS，则 prefix 是必需的。 范例： 结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f8e7d0749e57098f2d993053abc9444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead6940bcb299fe996232bcf1ff056f5/" rel="bookmark">
			MRIcron的dcm2nii数据转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dcm2nii的相关选项如下：
此处，一个example是：
dcm2niix.exe -f "outputfilename" -i y -l y -p y -x y -v y -z y -o "E:\datasets" "c:\DicomDir" 其中，"E:\datasets"是输入nii文件的目录，"c:\DicomDir"是输入dicom的目录，"outputfilename" 是输出nii.gz的文件名。
Python批处理 本部分介绍如何使用python进行批处理。
首先遍历一个含有非常多个dicom序列的文件夹，然后将其的dicom文件的路径保存到一个txt文件中，然后读取txt中的文件路径，在在for循环中调用dcm2niix进行格式的批处理。
分别执行下面两段代码：
首先，遍历文件：
遍历文件并保存为txt # 当前目录下所有文件夹下的文件名(不带后缀)写入对应txt文件(以文件夹命名)中 import os # 如果文件夹不存在创建文件夹 def Makedir(path): folder = os.path.exists(path) if (not folder): os.makedirs(path) # 利用os.listdir()、os.walk()获取文件夹和文件名 def GetFileName(fileDir, outDir): list_name = [] Makedir(outDir) for dir in os.listdir(fileDir): # 获取当前目录下所有文件夹和文件(不带后缀)的名称 filePath = os.path.join(fileDir, dir) # 得到文件夹和文件的完整路径 if os.path.isdir(filePath) and not (filePath == outDir): txt = outDir+"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ead6940bcb299fe996232bcf1ff056f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e39f61af49a647b9737172179724c51/" rel="bookmark">
			ModuleNotFoundError: No module named matplotlib  问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用pycharm 写波士顿房价预测程序，遇到一个问题，如下：
解决方案：
打开cmd ,切换到python的安装路径下，然后输入：python -m pip install matplotlib 稍等片刻，成功！
切换路径的操作： 方法一：
方法二：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcce5a3ad6b6a3010608050c3868c115/" rel="bookmark">
			mysql数据库批量更新数据，根据select出来的数据去update
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql根据select出来的数据去update数据 语法：
update a inner join (select yy from b) c on a.id =c.id set a.xx = c.yy 实现查询数据并根据条件更新到另一张表的方法示例 本文实例讲述了mysql实现查询数据并根据条件更新到另一张表的方法。分享给大家供大家参考，具体如下：
原本的数据库有3张表
travel_way ：旅游线路表，存放线路的具体信息traveltag ：线路标签表，存放线路目的地等信息tagrelation：标签对应表，存放线路和目的地的对应关系 因为业务逻辑的改变，现在要把它们合并为一张表，把traveltag中的目的地信息插入到travel_way中。
首先获取到所有线路对应的目的地，以线路ID分组，合并目的地到一行，以逗号分隔。
SQL：
SELECT travel_way.id, GROUP_CONCAT( traveltag.content ) FROM travel_way LEFT JOIN tagrelation ON travel_way.id = tagrelation.travel_id LEFT JOIN traveltag ON tagrelation.tag_id = traveltag.id GROUP BY travel_way.id 先把查到的数据存放到了一个新建的表mid里
SQL：
INSERT INTO mid ( travelway_id, destination ) SELECT travel_way.id, GROUP_CONCAT( traveltag.content ) FROM travel_way LEFT JOIN tagrelation ON travel_way.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcce5a3ad6b6a3010608050c3868c115/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70c7ec1310b4b0e805c7bc38090ee2ce/" rel="bookmark">
			Java提供的中文字符和ASCII字码的转码功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java提供的中文字符和ASCII字码的转码功能 转码实现 转码实现 Java提供了一个native2ascII工具用于将中文字符进行编码处理，native2ascII的用法如下所示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b115b7bce052a70ce456a83360d0787/" rel="bookmark">
			C# datatable增加行(datarow)数据为另一个datatable中某行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 两个表A和B，两表结构相同。现在需要将A表中部分行拷贝到B表中，直接用 DataTableB.rows.add(dataTableA.rows[0]) 这样的方法式会报"row已经属于A表"这样的错误；
方法一： //得到A表中的部分行 DataRow[] drA = dtA.Select("aimtype=3"); //实例B DataTable dtB = dtA.Clone(); if (drA.Length &gt; 0) { foreach (DataRow drVal in drA) { //向B中增加行 dtB.ImportRow(drVal); } } 方法二： 复制代码 //得到A表中的部分行 DataRow[] drA = dtA.Select("aimtype=3"); //实例B DataTable dtB = dtA.Clone(); if (drA.Length &gt; 0) { foreach (DataRow drVal in drA) { //向B中增加行 dtB.Rows.Add(drVal.ItemArray); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e8c6365954aa9820ab21a3721ab2fd0/" rel="bookmark">
			Python图像处理-5.pil打开图片，并且在图片中绘制点和线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 from PIL import Image from pylab import * #读取图像到数组中 im = array(Image.open('pic1.png')) #绘制图像 imshow(im) #定义四个点 x =[100,100,400,400] y =[200,500,200,500] # 使用红色星状物标记绘制点 plot(x,y,'r*') #绘制前两个点的线 plot(x[:2],y[:2]) #添加标题，显示绘制的图像 title('Plotting:"pic1.png"') show() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38bf49648933b5e8b44772a9497a4fd6/" rel="bookmark">
			Unity中的Input.GetMouseButton,GetMouseButtonDown,GetMouseButtonUp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用鼠标点击来实现滑动事件
GetMouseButton:每一帧鼠标处于按下状态都会返回true，
Input.GetMouseButton(0):表示鼠标左键按下，
Input.GetMouseButton(1):表示鼠标右键按下，
Input.GetMouseButton(2):表示鼠标中键按下
GetMouseButtonDown:鼠标按下的那一帧返回true，
Input.GetMouseButtonDown(0):表示鼠标左键按下，
Input.GetMouseButtonDown(1):表示鼠标右键按下，
Input.GetMouseButtonDown(2):表示鼠标中键按下
GetMouseButtonUp:鼠标抬起的那一帧返回true，
Input.GetMouseButtonUp(0):表示鼠标左键按下，
Input.GetMouseButtonUp(1):表示鼠标右键按下，
Input.GetMouseButtonUp(2):表示鼠标中键按下
鼠标按下和抬起的位置可以通过Input.mousePosition来获取，不过该参数返回的是屏幕坐标位置，即以左下角为原点的坐标系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f59a2399ce6a34798dec5d22e7f8bcbd/" rel="bookmark">
			关于虚拟机时不时繁忙、黑屏的解决方法（适用于VM12版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于虚拟机时不时黑屏，繁忙，关不了机的解决方法（针对于出现启动集群多个节点时，某一节点黑屏的情况、或者是单单要启动一台虚拟机时黑屏的情况） 我个人用的是vm12版本
该方法可能不适用于VM15，我也没有试验过，不知道是否管用
特别是在启动集群的时候，比如一共四个节点，启动的时候，三个节点都没有黑屏，但是偏偏只有一个黑了，该如何解决？
像这种情况：
只有一个节点hadoop3黑了，如果你去选择关闭节点hadoop3、或者重启节点hadopp3就会出现hadoop3繁忙…，关也关不掉，重启也没反应，去服务里、任务管理器去关好像也关不掉…
1.此时为了方便你的集群下一次启动的方便，我们可以先将好的节点挂起（短时间的挂起，再下一次启动的时候是非常快的）
2.然后打开任务管理器
点击禁用
3.重启电脑，虚拟机框不用关（而且你关也关不上）直接重启电脑
4.电脑开启后，进入虚拟机在本地的文件目录下
进入刚刚黑掉的节点下的目录（hadoop3），将这些类型的文件全部删除（框起来的文件)，每个人的虚拟机使用时间不一样、虚拟机的来源也不一样（就像我的这个节点是直接克隆的hadoop1节点，那么文件名中可能就会有hadoop1的影子）可能会导致每个人的要删除的文件量、文件名都有所不同，但是记住我们要删除的文件的类型都是一样的
5.进入任务管理器，将刚刚禁用的启用
6.重新尝试打开hadoop3节点
hadoop3成功启动！！！
ps：如果打开还是黑屏，那么再重复一次刚刚的方法，先打开任务管理器禁用该禁用的-&gt;重启电脑-&gt;打开黑掉的节点在本地的目录，删除该删除的文件-&gt;重新启动刚刚黑掉的节点，一直黑就一直试，肯定会好的
7.此时再去启动另外三个节点（刚刚被挂起的节点）
节点全部启动成功！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6834286ff7bf6838e3e6ca2f3680a24/" rel="bookmark">
			如何将图像嵌入到StyleGAN的潜在空间（Image2StyleGAN、StyleGAN Encoder）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何将图像嵌入到StyleGAN的潜在空间（Image2StyleGAN、StyleGAN Encoder）
Image2StyleGAN: How to Embed Images Into the StyleGAN Latent Space?
原文地址：https://arxiv.org/abs/1904.03189
原作者： Rameen Abdal、Yipeng
Qin、Peter Wonka
翻译：flyfish
NVIDIA的StyleGAN借鉴了风格迁移的模型，所以叫 Style-Based Generator ，所以论文的名字叫
《A Style-Based Generator Architecture for Generative Adversarial Networks》
et al.是拉丁文简写。其一为et alibi (以及其他地方) ,相当于and elsewhere;其二为et alii (以及其他人)
,相当于and others。 e. g.是拉丁文exempli gratia的缩写,意思是“举个例子,比如”,等同于“for
example”,目的是用例子来说明前面的观点,用法与for example相同。
摘要（Abstract）
我们提出了一种有效的算法，将给定的图像嵌入到StyleGAN的潜在空间中。 这种嵌入使图像语义编辑操作可以应用于现有照片。 以在FFHQ数据集上受过训练的StyleGAN为例，我们显示了图像变形，风格迁移和表达转移的结果。 研究嵌入算法的结果可为StyleGAN潜在空间的结构提供有价值的见解。 我们提出了一组实验来测试哪些类别的图像可以嵌入，如何嵌入图像，哪些潜在空间适合嵌入，以及嵌入是否在语义上有意义。
1、说明（Introduction）
我们的贡献包括：
1）一种有效的嵌入算法，可以将给定图像映射到预训练的StyleGAN的扩展潜空间 W + W+ W+中。
2）我们研究了多个问题，以深入了解StyleGAN潜在空间的结构，例如：可以嵌入哪种类型的图像？ 可以嵌入哪种类型的面部？ 可以使用哪些潜在空间进行嵌入？
3）我们建议对向量使用三个基本运算来研究嵌入的质量。 结果我们可以更好地了解潜在空间以及如何嵌入不同类别的图像。 作为一个产品我们在多种面部图像编辑应用程序上获得了出色的结果，包括变形，风格迁移和表情迁移。
2、相关工作（Related Work）
1）高质量GAN（High-quality GANs）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6834286ff7bf6838e3e6ca2f3680a24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28663419ca8fb404b4e9a7ddf71c57cd/" rel="bookmark">
			PyCharm下载包出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyCharm安装成功之后添加所需的包： File —&gt;Settings… —&gt;Project:(此处是你的Python工作环境) —&gt;Project Interpreter 红色剪头所指 添加需要的包
点开时候出现错误信息：
Error loading package list:pypi.python.org 如下图
解决方案：把无线网连接关闭之后用手机的4G网络，用电脑连接手机的热点，重复上述操作之后即可下载所需的包（用手机热点有可能会很慢，我的就很慢，但是没有再报错。无ERROR即真理…）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7af7317324aee575d623bc3f8b868f9d/" rel="bookmark">
			（已解决）登录火狐浏览器账号后没有同步数据，或火狐浏览器账号不存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于登录火狐浏览器账号后数据没有同步的问题解决 本经验贴适用于 Firefox重度患者 需要在境外使用火狐浏览器中国版的同学
在新电脑上装了火狐浏览器，想登陆账号来同步书签，发现登录自己的账号竟然要我重新注册。注册后的账号和我原来电脑上的火狐账号完全一样，但二者没有同步任何数据。
两台电脑火狐浏览器版本相同，都是从火狐官网下的这个版本
查了半天才搞明白怎么回事，原来是火狐浏览器中国版本的一个坑：
火狐账号登录 和 火狐通行证 是两个完全不同的账号体系，数据不互通。。
差别在于使用的网络是境内还是境外的。
区别具体长啥样，安装好火狐浏览器后，点击右上角登陆Firefox，你就明白：
境外出现的是这个登陆界面
境内出现的是这个登陆界面
问题的原因是使用火狐通行证注册的账号，在火狐账号登录里面是不存在的。
For example, 我是在国内使用火狐通行证注册的帐号，在国外安装火狐浏览器以后，默认通过火狐账号登录，因此无法登录自己的账号。
解决方法： 想改用火狐通行证登录，只需改变同步的网络服务即可。
点击选项
同步
切换至本地服务
搞定，再登录Firefox，就是火狐通行证登陆界面啦
如果你想从火狐通行证切换成火狐账号登录，则点击“切换至全球服务”即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa2c617a563185a6611b2c075338b3f8/" rel="bookmark">
			[论文阅读]Factorization Machines
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Factorization Machines / 2020-01 Howard Wonanut 推荐算法系列文章（1）
😀人工翻译并包含部分个人理解，欢迎批评指正，但谢绝转载。
本文介绍因子分解机（FM），这是一种新的模型，它结合了支持向量机（SVM）和因式分解模型的优点。FM是一种通用预测器（与SVM一样），能够处理任何实值数。另外，其使用分解参数模拟变量之间的所有交互（原文：In contrast to SVMs, FMs model all interactions between variables using factorized parameters.）。因此，即使在SVM也无力回天的稀疏性（如推荐系统）问题中，FM模型也能胜任。本文证明了FM的模型方程可以在线性时间内完成计算。
另一方面，有许多不同的因子分解模型，如矩阵分解；并行因子分析或专用模型，如SVD ++，PITF或FPMC。这些模型的缺点是它们不具有普遍适用性，仅适用于特殊输入数据。此外，他们的模型方程和优化算法也是针对特定任务的。FM仅通过指定输入数据（即特征向量）就可以模拟这些模型。这使得即使对于没有分解模型专业知识的用户，FM也很容易使用。
关键词：因子分解机；稀疏数据；张量因子化；支持向量机
1 FM模型基本介绍 SVM分类器是机器学习和数据挖掘领域的翘楚，但是其在协同过滤这样的推荐领域就无法继续称霸了，因为在这个领域的数据往往具有稀疏这个特点，SVM在稀疏数据中往往不能得到一个优秀的分类超平面。因此，FM模型就横空出世了，FM模型中文名叫作因子分解机（Factorization Machines），我看到这个名字是真的不知其意。
FM模型的优点主要有三点：
FM能够在特征矩阵非常稀疏的情况下使用，完爆SVMFM具有线性时间复杂度，可以在原始中进行优化，不用像SVM那样依赖支持向量。FM是一种可以与任何实值特征向量一起使用的通用预测器。支持特征组合（我加的） 2 使用稀疏数据做预测 在传统的监督学习问题中，假设给定训练集 D = { ( x ( 1 ) , y ( 1 ) ) , ( x ( 2 ) , y ( 2 ) ) , . . . , ( x ( m ) , y ( m ) ) } D=\{(\bold{x}^{(1)},y^{(1)}),(\bold{x}^{(2)},y^{(2)}),.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa2c617a563185a6611b2c075338b3f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd1be7f27f347802a1eb6916f75711e7/" rel="bookmark">
			impala 的资源管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		impala的资源管理并不依赖yarn，对于MPP架构的系统，它的查询响应时间由最慢的节点运行时间决定，而为了提升查询性能，又需要尽可能多的节点参与计算，而YARN上的任务每次都是启动一个新的进程，启动进程的时间对于批处理任务是可以接受的，毕竟这种任务运行时间比较久，而对于追求低延迟的Ad-hoc查询而言代价有点大了，很可能出现进程启动+初始化时间大于真正运行的时间。
impala有一套自己的资源管理模块Admission Control，这是个去中心化的资源管理系统，它嵌入到了集群中的每个impala daemon中发挥作用。尽管Admission Control对整个impala集群的资源使用作出限制，每个impala daemon还是会自己决定它上面的查询是立即执行还是进入等待队列。
Admission Control 与查询队列 Admission control 是impala的一个功能，它的作用是给SQL查询加限制，防止集群繁忙的时候资源使用到达峰值或者内存溢出。Admission control为查询设置并发上限以及内存使用限制。在限制之外的查询将会进入等待队列，等正在执行的查询结束之后，队列中的查询才会启动。
在2.5及2.5以上的版本中，可以为每个队列设置限制，而不是只能为全局设置限制。通过这种方式可以在稳定的负载和密集型查询之间平衡资源使用和吞吐量。
除了能设置正在执行的查询个数的限制，还可以设置队列中等待执行的查询个数的限制，设置查询在队列中等待的超时时间。这些设置能够保证查询不会在队列中永久等待。
查询，DML语句，以及包括CREATE TABLE AS SELECT 和 COMPUTE
STATS在内的部分DDL语句都受Admission control的控制。
在一个繁忙的集成上，需要找到一个最优的查询并发数。比如，当集群的IO资源被IO密集型的查询占满之后，加大查询的并发数并不能提高查询性能。我们需要让部分查询全速执行的同时，让其他的查询在队列中等待。而不是让所有查询同时执行，竞争资源，从而导致每个查询都很慢。因此Admission control能够带来更高的吞吐量。
再举个例子，我们考虑join,聚合这种消耗内存资源的查询。每个这种查询都会短暂地占用很多G的内存去处理中间结果。默认情况下，当查询使用的内存查过了限制的阈值，Impala会取消查询。因此，如果同时起很多这种查询，如果超过内存限制，可能需要重跑那些被取消的查询。
在这种场景下，Admission control 会在保证不超出内存限制的前提下，尽可能跑多的查询，从而保证查询的可靠性和稳定性。
Concurrent Queries and Admission Control 一种通过Admission Control限制资源使用的方法是设置一个并发数量的上限，可以为每个动态资源池分别指定设置。
Max Running Queries 资源池上允许的最大查询并发数，impala2.5及2.5版本以上默认是不限制的。该池子上的任何超过最大并发查询数的查询都会进入队列中等待，直到其他查询结束才会启动执行。当Max Running Queries Multiple有设置时，这个配置不生效。
Max Running Queries Multiple 这个配置是一个float类型，它的值乘以executors 的个数就是Max Running Queries。executors 就是一个impalad。因此这个配置的影响与executors的数量有关。相乘的结果是向上取整的，因此结果至少为1。如果这个配置被设置为0或者负数，则无效。
Max Queued Queries 资源池上允许的最大队列大小。在impala2.1及以上版本，这个配置的默认值是200，小于2.1的版本默认值是50。当Max Queued Queries Multiple有设置时，这个配置不生效。
Max Queued Queries Multiple 这个配置是一个float类型，它的值乘以executors 的个数就是Max Queued Queries。executors 就是一个impalad。因此这个配置的影响与executors的数量有关。相乘的结果是向上取整的，因此结果至少为1。如果这个配置被设置为0或者负数，则无效。
Queue Timeout 这个配置是时间的值，单位是毫秒，它控制队列中等待的查询的超时时间。等待的时间超过这个值查询将会被取消。默认值是60000毫秒。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd1be7f27f347802a1eb6916f75711e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e12a77b4bece195b661bf221dc8d05d4/" rel="bookmark">
			unity3d的Texture2D与opencvsharp的Mat之间的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、目的：
1、想得到了texture，然后和mat转换后，就可以对Mat处理来实现opencv中的功能
一、参考：
1、unity3d的Texture2D与opencv的Mat之间的相互转换
①总结：待处理
一、目的： 1、想得到了texture，然后和mat转换后，就可以对Mat处理来实现opencvsharp中的功能 一、参考： 1、unity3d的Texture2D与opencv的Mat之间的相互转换 https://blog.csdn.net/weixin_34337381/article/details/93579756
①总结：待处理 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/decc71657ad307b59535bd608721c8ef/" rel="bookmark">
			【Unity】Unity2018/2019发布安卓流程及踩坑总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在研究cardboard，发布的时候遇到了一些问题。这些问题对于Unity发布安卓具有普适性，因此做出如下总结。
从结果逆推自己做了很多没有必要的工作，总结比较零碎，可以根据需求在目录中查询。
目录 笔者的开发环境Unity2018-2019流程Java环境Android SDK发布 Unity5.x流程问题总结API过低发布VR应用选项自己安装JDK和SDK可能出现问题 笔者的开发环境 Unity版本：Unity 2018.4.14f1 (64-bit)
系统：Win10（已配置好Java环境）
全程无需科学上网
Unity2018-2019流程 Java环境 自己配置的教程很多，这里我就不多赘述了。2019版本以后的Unity甚至在安装的时候可以选择一同安装JDK，一键打包即可。
Android SDK 这是大部分人发布时问题频出的一个地方。比如Unity发布Android SDK Tools需要26.1.1以上版本，然而独立的SDK Manage只能更新到25.2.5，我一天都卡在下载——失败——下载——失败上了。
截止至目前（2020年1月）Unity2018-2019无需单独配置AndroidSDK，官网下载Editor的同时有自带AndroidSDK的选项，勾选即可。
如果一同下载的时候遇见了下载AndroidSDK出错或者电脑里已经安装好了Unity，可以使用Unity Hub进行下载。
目前Unity提供了Unity Hub，它可以用于管理Unity项目、简化下载、查找，卸载以及安装管理多个Unity版本的工具。可以在Unity官网下载。
打开Unity Hub，里面有你所有安装的Unity版本（如果没有自动识别请手动添加）。在需要的版本右上角选择添加模块，添加AndroidSDK，等待下载。
曲线救国式：我们常常遇见一个问题就是你已经在Unity2019版本上进行开发，并且UnityHub不能自动识别你已经安装的unity版本。这时你可以在UnityHub上重新下载一个unity2018并勾选安卓支持。当一键下载完成后，你会发现你的Unity2019也可以发布安卓了
发布 跟其他发布流程类似，如图所示：
1.添加场景
2.Player Setting进行设置
在这里设置Company Name（公司名）Product Name（软件名）软件图标等内容
特别的发布安卓需要将Other Setting 中Package Name中默认的com.Company. ProductName按照自己的填写进行修改，且不能以数字为开头且不能有空格。
3.Build等待成果发布
Unity5.x流程 我一开始看的流程就是旧版本的流程，然后遇见了很多问题。如果你还是Unity5.x可以点击这里前人已经写的非常详细了。
遇到的问题与解决方法请往下看。
问题总结 API过低 第一次发布安卓时可能会报错“used-sdk：minSdkVersion 16 cannot be smaller than version 19 declared in library”
这是因为选择的API版本过低导致的。在Player Settings-&gt;Other Settings-&gt;Minimum API Level选择高于19的API即可。
发布VR应用选项 发布VR应用需要Player Settings-&gt;XR Settings-&gt;Virtual Reality Support选择你的VR设备。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/decc71657ad307b59535bd608721c8ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb66b108d47e3ed6d14df91c6d9b5404/" rel="bookmark">
			医学图像数据集汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文首发于公众号【3D视觉工坊】，原文请见汇总|医学图像数据集，更多干货获取请关注公众号~
一、 胰腺分割数据集 数据下载链接：http://academictorrents.com/details/80ecfefcabede760cdbdf63e38986501f7becd49
数据介绍：包含82个病例的胰腺数据集。
二、MICCAI胰腺分割数据集 数据下载链接：http://medicaldecathlon.com/
数据介绍：282个训练病例，139个测试病例，同时分割胰腺和肿瘤，测试集label是hidden的。
三、The National Library of Medicine presents MedPix 数据下载链接：https://medpix.nlm.nih.gov/home
数据介绍：MedPix®是一个免费的开放式在线访问数据库，其中包含医学图像，教学案例和临床主题，集成了图像和文本元数据，包括12,000多个患者案例，9,000个主题和近59,000个图像。我们的主要目标受众包括医师和护士，专职医疗人员，医学生，护理生以及其他对医学知识感兴趣的人。内容材料按疾病位置（器官系统）组织；病理类别患者资料；以及通过图像分类和图像标题。该集合可按患者症状和体征，诊断，器官系统，图像形式和图像描述，关键字，特约作者和许多其他搜索选项进行搜索。
四、阿尔茨海默氏病神经影像数据 数据下载链接：http://adni.loni.usc.edu/data-samples/access-data/
数据介绍：阿尔茨海默氏病患者和健康对照的MRI数据库。 还具有临床，基因组和生物制造商数据。
五、结肠癌CT数据 数据下载链接：https://wiki.cancerimagingarchive.net/display/Public/CT+COLONOGRAPHY#dc149b9170f54aa29e88f1119e25ba3e
数据介绍：CT扫描诊断结肠癌。 包括没有息肉，6-9mm息肉和大于10mm息肉的患者的数据。 该系列中有825例带有XLS片的病例，提供了息肉描述及其在结肠段中的位置。
六、用于视网膜提取的数字视网膜图像 数据下载链接：https://www.isi.uu.nl/Research/Databases/DRIVE/download.php
数据介绍：用于视网膜图像中血管分割的比较研究，它由40张照片组成，其中7张显示出轻度早期糖尿病性视网膜病变的迹象。
七、AMRG Cardiac Atlas（心脏MRI图像） 数据下载链接：http://www.cardiacatlas.org/studies/amrg-cardiac-atlas/
数据介绍：奥克兰MRI研究小组的Siemens Avanto扫描仪采集的正常患者心脏的完整带标签MRI图像集。
八、先天性心脏病（CHD）图集 数据下载链接：https://data.gov.uk/dataset/f13fbd0e-fc8a-4d42-82ef-d40f930e4b70/congenital-heart-disease-chd
数据介绍：先天性心脏病（CHD）图集代表来自患有各种先天性心脏病的成年人和儿童的MRI数据集，生理临床数据和计算机模型。
九、大脑MRI数据集 数据下载链接：http://www.oasis-brains.org/
数据介绍：OASIS影像研究开放获取系列（OASIS）是一个旨在向科学界免费提供大脑的MRI数据集的项目。有两个数据集：横截面和纵向集。年轻，中年，非痴呆和痴呆老年人的横断面MRI数据：此集合包括416名18至96岁的受试者的横断面集合。非痴呆和痴呆老年人的纵向MRI数据：该组纵向收集了150名年龄在60至96岁之间的受试者。两次或两次以上就诊时对每个受试者进行了扫描，相隔至少一年，共进行373次成像。
十、Isic Archive（黑色素瘤） 数据下载链接：https://github.com/GalAvineri/ISIC-Archive-Downloader
数据介绍：该档案库包含分类皮肤损伤的23k图像。 它包含了恶性和良性的例子。每个示例均包含病变的图像，有关病变的元数据（包括分类和分割）以及有关患者的元数据。
十一、森尼布鲁克心脏数据 数据下载链接：http://www.cardiacatlas.org/studies/
数据介绍：Sunnybrook心脏数据（SCD）也称为2009心脏MR左心室分割挑战数据，由来自以下患者和病理混合的45幅cine-MRI图像组成：健康，肥大，伴有梗塞和心脏的心力衰竭。
十二、肺部图像数据库联盟（LIDC） 数据下载链接：https://wiki.cancerimagingarchive.net/display/Public/LIDC-IDRI#
数据介绍：肺图像数据库联合会图像收集（LIDC-IDRI）包括诊断性和肺癌筛查性胸部X线断层扫描（CT）扫描，并标明带注释的病变。 它是可通过网络访问的国际资源，用于开发，培训和评估用于肺癌检测和诊断的计算机辅助诊断（CAD）方法。 由美国国立癌症研究所（NCI）发起，并由美国国立卫生研究院（FNIH）基金会进一步推动，并在食品药品监督管理局（FDA）的积极参与下，这种公私合作伙伴关系证明了一项成功的研究成果。
十三、INbreast：数字化乳腺摄影数据库 数据库下载链接：http://medicalresearch.inescporto.pt/breastresearch/index.php/Get_INbreast_Database
数据库介绍：INbreast数据库是一个乳腺摄影数据库，其中的图像是从位于大学医院（葡萄牙波尔图的乳腺癌中心，圣若昂医院）的乳腺癌中心获取的。 INbreast共有115例（410幅图像），其中90例来自双乳女性（每例4幅图像），而25例来自乳房切除术患者（每例2幅图像）。 包括几种类型的病变（肿块，钙化，不对称和变形）。 专家还以XML格式提供了精确的轮廓。
十四、前列腺癌数据集 数据下载链接：http://www.ehealthlab.cs.ucy.ac.cy/index.php/facilities/32-software/218-datasets
数据介绍：
1、图像格式：关于数据集的某些技术方面，T2-W MRI，DCE MRI和DWI MRI，ADC将以DICOM格式交付。
2、关于MRSI数据将以RDA（西门子）或DICOM（GE）格式提供。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb66b108d47e3ed6d14df91c6d9b5404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6521478980555090210d83012186e428/" rel="bookmark">
			Unity 切换加载场景 SceneManager.LoadScene
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SceneManager.LoadScene
public static void LoadScene(int sceneBuildIndex,SceneManagement.LoadSceneMode mode = LoadSceneMode.Single);
public static void LoadScene(string sceneName,SceneManagement.LoadSceneMode mode = LoadSceneMode.Single);
在构建设置中通过其名称或索引加载场景。
例子1：通过场景名来加载，并且不销毁之前的场景
using UnityEngine; using UnityEngine.SceneManagement;//使用场景管理器 public class ExampleClass : MonoBehaviour{ void Start() { //使用LoadScene加载场景 //第二个参数AddSceneMode.Additive表示当前场景不销毁，并加载需要的场景 SceneManager.LoadScene("OtherSceneName", LoadSceneMode.Additive); } } 例子2：通过索引来加载，销毁当前场景
using UnityEngine; using UnityEngine.SceneManagement;//使用场景管理器 public class ExampleClass : MonoBehaviour{ //跳转场景 void LoadLevel(int level) { ScenesArgs e = new ScenesArgs(); //获取当前场景索引 e.scnesIndex = SceneManager.GetActiveScene().buildIndex; //发送退出场景事件 SendEvent(Consts.E_ExitScenes, e); //发送加载新的场景事件 //LoadSceneMode.Single:销毁当前场景，加载要加载的场景 SceneManager.LoadScene(level,LoadSceneMode.Single); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c8832135dcafcf2b0c3bf5b9bfc5394/" rel="bookmark">
			Pyhton实现K-Means算法（numpy&#43;pandas&#43;matplotlib）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：使用Python实现K-Means算法
一、K-Means算法基本流程
1）随机选取K个聚类中心
2）计算每个样本到聚类中心的距离
3）更新样本聚类中心
4）迭代，直到样本聚类中心不再发生变化
二、详细步骤
1.导入训练集数据，并做些许处理，方便之后的使用，因为原始数据是两列，列名分别为AB，所以使用data['A'].values和data['B'].values来获取文件中的具体数值。
# 导入数据集，文件名为testSet.csv data = pd.read_csv('testSet.csv') # 将文件中数据转换为数组 f1 = data['A'].values f2 = data['B'].values X = np.array(list(zip(f1, f2))) 2.由簇数确定初始质心的个数，然后把随机生成的质心画到图上，数据集的数据用黑色点表示，质心用蓝色“×”表示，如图1所示。
#设置簇数，根据簇数确定生成初始质心的个数 k = 4 #随机获取初始质心并画到示例数据上 C_x = np.random.randint(0, np.max(X)-2, size=k) C_y = np.random.randint(0, np.max(X)-2, size=k) C = np.array(list(zip(C_x, C_y)), dtype=np.float32) plt.scatter(f1, f2, c='black', s=7) plt.scatter(C_x, C_y, marker='x', s=100, c='b') 图1 生成初始质心的效果
3. 通过计算欧几里得距离，不断对质心进行迭代，直到质心间距离不再发生变化，那么就进行迭代的终止，此时的质心间距离指的是：上次迭代完的质心与本次迭代完的质心之间的距离。倘若迭代结果一直在改变，那么我们就通过设置最大迭代次数来终止迭代，次数根据具体要求可进行改变。下面仅列出前两次循环的结果，作为参考示例。
while tmp &lt;= 15 and newDist.any() != 0: 注：此处判断迭代结果是否一样，主要是比较迭代前后的两次质心位置有没有改变，辅助以计算质心距离和（簇内各点到该簇质心的距离的和） ，但实际上应该是使用质心距离和差异来判断，即判断迭代前后两次的质心距离和是否改变，如果读者有精力，可以自己再琢磨琢磨。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c8832135dcafcf2b0c3bf5b9bfc5394/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18ae6cf495431dcbaa6b0fcfb304a249/" rel="bookmark">
			传值和传址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传值 #include&lt;stdio.h&gt; void swap(int x,int y); void swap(int x,int y) { printf("swap before:a=%d b=%d\n",x,y); int temp; temp=x; x=y; y=temp; printf("swap after:a=%d b=%d\n",x,y); } int main() { int a=3; int b=5; printf("In main :swap before:a=%d b=%d\n",a,b); swap(a,b); printf("In main:swap after :a=%d b=%d\n",a,b); return 0; } 2.传址
#include&lt;stdio.h&gt; void swap(int *x,int *y); void swap(int *x,int *y) { printf("swap before:a=%d b=%d\n",*x,*y); int temp; temp=*x; *x=*y; *y=temp; printf("swap after:a=%d b=%d\n",*x,*y); } int main() { int a=3; int b=5; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18ae6cf495431dcbaa6b0fcfb304a249/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e58e91cd89fff5388d28fab0072699e3/" rel="bookmark">
			Android组件生命周期管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每个Android应用启动时，都会先创建一个Application。通常在Application里我们会做一些应用初始化的操作，常见的有第三方SDK初始化。在应用组件化之后，组件与壳工程是隔离开来的，但是组件有时候也需要获取应用的Application，也需要在应用启动时进行初始化。这就涉及到组件的生命周期管理问题。
最简单的实现方式如下：
我们定义一个Application的代理接口IAppLike出来，它模拟了Application的几个主要方法。 public interface IAppLike { void onCreate(); void onTerminate(); void onLowMemory(); void onTrimMemory(int level); } 在组件内部写一个实现IAppLike的类，我们把这个类当做是组件的Application容器。这里的onCreate()等同于Application的onCreate()方法，组件可以在这里获取Application实例、执行启动初始化等操作，也可以在这里设置保存一些全局性的数据等。 public class NewsDelegate implements IApplicationDelegate { @Override public void onCreate() { Log.i("hx", "NewsDelegate-onCreate"); } @Override public void onTerminate() { Log.i("hx", "NewsDelegate-onTerminate"); } @Override public void onLowMemory() { } @Override public void onTrimMemory(int level) { } } 在壳工程的Application.onCreate()方法里执行： @Override public void onCreate() { super.onCreate(); MainDelegate mainDelegate = new MainDelegate(); NewsDelegate newsDelegate = new NewsDelegate(); MusicDelegate musicDelegate = new MusicDelegate(); MimeDelegate mimeDelegate = new MimeDelegate(); mainDelegate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e58e91cd89fff5388d28fab0072699e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f261f27bafbb2c00e3c5f1601c6d699/" rel="bookmark">
			五步完成 Ubuntu 16.04 网卡bond
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步
检查当前是否安装fenslave
它是一款linux下的网卡绑定所需要的负载均衡工具，可以将数据包有效的分配到bonding驱动。
dpkg -l | grep fenslave
如果没有安装，
apt-get install ifenslave -y
进行安装
在 /var/cache/apt/archives/ 下刚刚apt-get的 ifenslave.deb 可用于离线设备安装
第二步
加载bonding的内核模块
modprobe bonding
并通过 lsmod | grep bonding 检查是否正常加载
在开机时启动bonding模块
在 /etc/modules 下 增加 bonding
vi /etc/modules
bonding
第三步 配置网络
主备模式 mod 1
在 /etc/network/interfaces 文件下增加以下内容
————————————————————
vi /etc/network/interfaces
auto ens38 #主网卡
iface ens38 inet manual
bond-master bond0
bond-primary ens38
auto ens39 #备网卡
iface ens39 inet manual
bond-master bond0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f261f27bafbb2c00e3c5f1601c6d699/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ff984fd71cc146b4803b93b1d67fe4/" rel="bookmark">
			编写一个函数max,接收两个整型参数，并返回他们中的较大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 List item #include&lt;stdio.h&gt; int max(int a,int b); int max(int a,int b) { return a&gt;b?a:b; } int main() { int a,b; printf("please input interger a:\n"); scanf("%d",&amp;a); printf("please input interger b:\n"); scanf("%d",&amp;b); printf("The max is :%d\n",max(a,b)); return 0; } #include&lt;stdio.h&gt; int max(int x,int y); int main() { int a,b,c; printf("please input a,b:\n"); scanf("%d %d",&amp;a,&amp;b); c=max(a,b); printf("The max is :%d\n",c); } int max(int x,int y) { if(x&gt;y){ return x; }else { return y; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5343fc473fc71276863e2844e176f394/" rel="bookmark">
			【经验】STC12单片机开发问题及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单片机型号：STC12C5A60S2
问题1：单片机未能响应，烧录程序时，ISP烧写软件一直显示“正在连接”，如何解决？ 方法：检查是否选择下图中箭头所指项，取消勾选；并在本次烧录时，一直给引脚P4^6高电位（高于1.33V），确保其不在复位状态即可烧写。
问题2：如何实现按键复位？如何实现软件复位？ 方法：官方手册中给出：
我们采用软件复位的方法，直接在程序中编写一行代码，使相应按键按下后立即复位。
确保你的头文件中，有如下定义（reg51.h、reg52.h需自行添加）：根据手册描述，选择合适的复位功能：编写按键相应代码： if(k4==0)	//复位 { mDelaymS(20);	//消除按键抖动 if(k4==0)	{ IAP_CONTR = 0x20;	//复位 delay(1000);	printf( "RST！\n" ); IAP_CONTR = 0x00; } } 问题3：如何使用oled编写欢迎界面？ 方法：
打开取字模软件：并设置如下（自行调整参数）：取出字模（复制）：置入字体库头文件中：在程序中调用显示函数即可（细节操作请留言）： 待续……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf9b1f6bac2043667bdcff87cdd40ee/" rel="bookmark">
			springMVC对时间类型的处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.后台往前台传值
默认输出的是毫秒值,需要使用特定的格式
1.在属性上添加@JsonFormat注解,注意要添加时区
2.在总配置文件添加相关配置
二.前台往后台传参时(包含日期)
如果不能解析,会报一个400的错误
解决方案:
1.在日期参数上添加@DateTimeFormat注解
2.在Controller中添加initBinder方法
如果两种都有,会使用initBinder方法的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94d6ac5a15881e373dd912a2d4dc83a8/" rel="bookmark">
			制作微信小程序 第四天(组件）入门完结！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自定义组件流程：创建文件夹 直接右键新建
再找到要使用这个组件的文件的json，把相对路径写下
最后到wxml文件下使用就可以了（⚠️注意文件名tabs是组件的文件名称）
2.tabs组件优化
.js
// companies/tabs/Tabs.js Component({ /** * 组件的属性列表 */ properties: { }, /** * 组件的初始数据 */ data: { tabs:[ { id:0, name:"首页", isActive:true }, { id:1, name:"原创", isActive:false }, { id:2, name:"分类", isActive:false }, { id:3, name:"关于", isActive:false } ] }, /** * 组件的方法列表 */ methods: { } }) .wxml
&lt;view class="tabs"&gt; &lt;view class="tabs_title"&gt; &lt;!--&lt;view class="title_item active"&gt;首页&lt;/view&gt; &lt;view class="title_item"&gt;原创&lt;/view&gt; &lt;view class="title_item"&gt;分类&lt;/view&gt; &lt;view class="title_item"&gt;关于&lt;/view&gt;--&gt; &lt;view wx:for="{{tabs}}" wx:key="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94d6ac5a15881e373dd912a2d4dc83a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9199d19adc903b9756ebae96690df3f2/" rel="bookmark">
			【Python入门自学笔记专辑】——Python之禅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python语言有的设计理念和哲学，称为“Python之禅”。Python之禅是Python的灵魂，理解Python之禅能帮助开发人员编写出优秀的Python程序。在Python交互式方式运行工具IDLE（也称为Python shell）中输入import this命令，如图所示，显示的内容就是Python之禅。
Python 3.8.1 (tags/v3.8.1:1b293b6, Dec 18 2019, 22:39:24) [MSC v.1916 32 bit (Intel)] on win32
Type “help”, “copyright”, “credits” or “license()” for more information.
import this
The Zen of Python, by Tim Peters
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren’t special enough to break the rules.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9199d19adc903b9756ebae96690df3f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b14d0bb8e206b6411cf0232ea91d5e7/" rel="bookmark">
			nginx实战（1）：宝塔设置反向代理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下操作适用于默认80端口转其他地址非80端口情况。
添加网站
注意:因我只是拿来当反向代理来使用，所PHP为纯静态模式。
开启反向代理
注：目标URL为最终目的地，发送域名为默认，如设置后无效则修改为上图中所示。
修改反向代理配置文件 说明: 修改反向代理的配置，不是修改nginx默认配置文件，修改上图中的proxy_pass这一行参数，在原来的目标地址后加上:18080(此18080是目标访问端口号，根据个人网址配置修改端口)，最后保存即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/145c3bfe654c672540fb2605c6abbe30/" rel="bookmark">
			Mybatis 中经典的 9 种设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虽然我们都知道有23个设计模式，但是大多停留在概念层面，真实开发中很少遇到。Mybatis源码中使用了大量的设计模式，阅读源码并观察设计模式在其中的应用，能够更深入的理解设计模式。
Mybatis至少遇到了以下的设计模式的使用：
1、Builder模式，例如SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder；
2、工厂模式，例如SqlSessionFactory、ObjectFactory、MapperProxyFactory；
3、单例模式，例如ErrorContext和LogFactory；
4、代理模式，Mybatis实现的核心，比如MapperProxy、ConnectionLogger，用的jdk的动态代理；还有executor.loader包使用了cglib或者javassist达到延迟加载的效果；
5、组合模式，例如SqlNode和各个子类ChooseSqlNode等；
6、模板方法模式，例如BaseExecutor和SimpleExecutor，还有BaseTypeHandler和所有的子类例如IntegerTypeHandler；
7、适配器模式，例如Log的Mybatis接口和它对jdbc、log4j等各种日志框架的适配实现；
8、装饰者模式，例如Cache包中的cache.decorators子包中等各个装饰者的实现；
9、迭代器模式，例如迭代器模式PropertyTokenizer；
接下来挨个模式进行解读，先介绍模式自身的知识，然后解读在Mybatis中怎样应用了该模式。
1、Builder模式 Builder模式的定义是“将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。”，它属于创建类模式。
一般来说，如果一个对象的构建比较复杂，超出了构造函数所能包含的范围，就可以使用工厂模式和Builder模式。
相对于工厂模式会产出一个完整的产品，Builder应用于更加复杂的对象的构建，甚至只会构建产品的一个部分。
在Mybatis环境的初始化过程中，SqlSessionFactoryBuilder会调用XMLConfigBuilder读取所有的MybatisMapConfig.xml和所有的*Mapper.xml文件，构建Mybatis运行的核心对象Configuration对象，然后将该Configuration对象作为参数构建一个SqlSessionFactory对象。
其中XMLConfigBuilder在构建Configuration对象时，也会调用XMLMapperBuilder用于读取*Mapper文件，而XMLMapperBuilder会使用XMLStatementBuilder来读取和build所有的SQL语句。
在这个过程中，有一个相似的特点，就是这些Builder会读取文件或者配置，然后做大量的XpathParser解析、配置或语法的解析、反射生成对象、存入结果缓存等步骤，这么多的工作都不是一个构造函数所能包括的，因此大量采用了Builder模式来解决。
对于builder的具体类，方法都大都用build*开头，比如SqlSessionFactoryBuilder为例，它包含以下方法：
即根据不同的输入参数来构建SqlSessionFactory这个工厂对象。
2、工厂模式 在Mybatis中比如SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。
简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。
在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。
可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。
在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：
这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化TransactionFactory获得一个Transaction对象
然后通过Transaction获取一个Executor对象，最后通过configuration、Executor、是否autoCommit三个参数构建了SqlSession。
在这里其实也可以看到端倪，SqlSession的执行，其实是委托给对应的Executor来进行的。
而对于LogFactory，它的实现代码：
这里有个特别的地方，Log变量的的类型是Constructorextends Log&gt;
也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如Log4jImpl、Slf4jImpl等很多具体的Log。
3、单例模式 单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。
单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。
单例模式是一种对象创建型模式，单例模式又名单件模式或单态模式。
在Mybatis中有两个地方用到单例模式，ErrorContext和LogFactory，其中ErrorContext是用在每个线程范围内的单例，用于记录该线程的执行环境错误信息
而LogFactory则是提供给整个Mybatis使用的日志工厂，用于获得针对项目配置好的日志对象。
ErrorContext的单例实现代码：
构造函数是private修饰，具有一个static的局部instance变量和一个获取instance变量的方法，在获取实例的方法中，先判断是否为空如果是的话就先创建，然后返回构造好的对象。
只是这里有个有趣的地方是，LOCAL的静态实例变量使用了ThreadLocal修饰，也就是说它属于每个线程各自的数据，而在instance()方法中，先获取本线程的该实例，如果没有就创建该线程独有的ErrorContext。
4、代理模式 代理模式可以认为是Mybatis的核心使用的模式，正是由于这个模式，我们只需要编写Mapper.java接口，不需要实现，由Mybatis后台帮我们完成具体SQL的执行。
代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。
代理模式包含如下角色：
Subject: 抽象主题角色
Proxy: 代理主题角色
RealSubject: 真实主题角色
这里有两个步骤，第一个是提前创建一个Proxy，第二个是使用的时候会自动请求Proxy，然后由Proxy来执行具体事务；
当我们使用Configuration的getMapper方法时，会调用mapperRegistry.getMapper方法，而该方法又会调用mapperProxyFactory.newInstance(sqlSession)来生成一个具体的代理：
在这里，先通过T newInstance(SqlSession sqlSession)方法会得到一个MapperProxy对象，然后调用T newInstance(MapperProxymapperProxy)生成代理对象然后返回。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/145c3bfe654c672540fb2605c6abbe30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7507c9a943347191aaeb10c7bbfadd4/" rel="bookmark">
			MOBILE_FFMPEG_BUILD_DATE 在哪？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看 mobile-ffmpeg 的源码，在 mobileffmpeg.c 看到一个名为 MOBILE_FFMPEG_BUILD_DATE 的宏，但是在 mobileffmpeg.h 头文件中没有看到相关定义，考虑是不是定义到其他头文件了，那就 grep 一下
grep -r MOBILE_FFMPEG_BUILD_DATE 让我奇怪的是，还是只有mobileffmpg.c 出现了这个宏：
mobileffmpeg.c: sprintf(buildDate, "%d", MOBILE_FFMPEG_BUILD_DATE); 我还不信了嘞， cd 到上一层目录，再次 grep，直到到根目录，发现了2个地方出现了这个宏：
Application.mk:APP_CFLAGS := -O3 -DANDROID -DMOBILE_FFMPEG_BUILD_DATE=20200104 -Wall -Wno-deprecated-declarations -Wno-pointer-sign -Wno-switch -Wno-unused-result -Wno-unused-variable mobileffmpeg.c: sprintf(buildDate, "%d", MOBILE_FFMPEG_BUILD_DATE); 看来是在编译的时候通过-D参数添加的宏定义。
翻看未编译的mobile-ffmpeg源码，然而并没有Application.mk 文件，想到这个文件可能是在编译Android版本的时候生成的。于是去看看android.sh 文件，发现了这个函数：
build_application_mk() { if [[ ! -z ${MOBILE_FFMPEG_LTS_BUILD} ]]; then local LTS_BUILD_FLAG="-DMOBILE_FFMPEG_LTS " fi if [[ ${ENABLED_LIBRARIES[$LIBRARY_X265]} -eq 1 ]] || [[ ${ENABLED_LIBRARIES[$LIBRARY_TESSERACT]} -eq 1 ]] || [[ ${ENABLED_LIBRARIES[$LIBRARY_OPENH264]} -eq 1 ]] || [[ ${ENABLED_LIBRARIES[$LIBRARY_SNAPPY]} -eq 1 ]]; then local APP_STL="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7507c9a943347191aaeb10c7bbfadd4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441d71a3290015da35c371d2e6c4cf46/" rel="bookmark">
			KMP模式匹配算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题： 举例来说，有一个字符串"BBC ABCDAB ABCDABCDABDE"，我想知道，里面是否包含另一个字符串"ABCDABD"？
令主串S="BBC ABCDAB ABCDABCDABDE" ，模式串是T="ABCDABD"
1：朴素算法 首先，我们按照正常字符串匹配的思想，做一个匹配流程。
第1步：模式串T第一个字母A就匹配失败。模式串后移1位
第2步：模式串T第一个字母A就匹配失败。模式串后移1位。
第5步：模式串T最后一个D匹配失败。模式串后移1位。（第3,4步省略了，直接来到第5步）
第16步：模式串T匹配成功。模式串后移1位。
2：KMP算法、 说明：一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是"ABCDAB"。KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率。所以KMP算法可以“跳着走”，不用“一步一步走”。
1：“跳着走”，需要跳几步，给出一个公式：移动位数 = 已匹配的字符数 - 对应的部分匹配值
2：借助一个概念，叫做部分匹配值，这个值怎么算的，下面会讲。我们直接把模式串的部分匹配值列出来。
部分匹配值：
第1步：模式串T第一个字母A就匹配失败。移动的距离=已匹配的字符数 - 对应的部分匹配值，因为没匹配，所以移动1位
第2步：模式串T第一个字母A就匹配失败。移动的距离=已匹配的字符数 - 对应的部分匹配值，因为没匹配，所以移动1位
第5步：模式串T最后一个字母D匹配失败。移动的距离=已匹配的字符数(6) - 对应的部分匹配值(2)。需要往后移4位，而不是1位。
第6步：模式串T第3个字母C匹配失败。移动的距离=已匹配的字符数(2) - 对应的部分匹配值(0)。需要往后移2位。
第7步：模式串T第1个字母A匹配失败。移动的距离=已匹配的字符数 - 对应的部分匹配值。因为没匹配，所以移动1位
第8步：模式串T最后1个字母D匹配失败。移动的距离=已匹配的字符数(6) - 对应的部分匹配值(2)。所以移动4位
第9步：模式串T与主串S匹配成功。
总结： 朴素算法需要16次才能匹配成功，但是KMP算法只需要9次匹配就可以成功，时间复杂度降低不少。
部分匹配值的计算方法：（以"ABCDABD"为例） "A"的前缀和后缀都为空集，共有元素的长度为0；
"AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；
"ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；
"ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；
"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；
"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/441d71a3290015da35c371d2e6c4cf46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc2a953f2429804c7c4795f6afdfd57/" rel="bookmark">
			最小生成树：克鲁斯卡尔(Kruskal)和普里姆(Prim)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 前言： 一般来说，最小生成树算法以克鲁斯卡尔(Kruskal)和普里姆(Prim)较为经典。最小生成树是什么呢？举个例子，对于无向图来说，如果2个顶点如果要实现互相连通，至少需要1条边；3个顶点要互相连通，至少需要2条边；n个顶点如果需要互相连通，至少需要n-1条边。如果n个顶点有n条边，那一定有一个环存在。生成树就是无环图。
2 : 克鲁斯卡尔(Kruskal) 算法思想：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。
2.1流程 下图是所有点之间的权重图
第1-2步
第一步：因为E和F之间的权值是2，权值最小，所以第一步选择E和F相连
第二步：在剩下的权值中，权值3最小，是C和D。而且，C和D之间连接后不会产生环，所以第二步选C和D相连
第3-4步
第三步：在剩下的权值中，权值为4是最小的，也就是E和D相连，而且E和D相连后不会产生环，所以选择E和D相连。
第四步：在剩下的权值中，权值为5是最小的，也就是C和E相连，但是如果把C和E相连后，（CDE）就产生了环，就不是生成树了，摒弃。接着，剩下的权值中，权值为6是最小的，也就是C和F相连，但是如果把C和F相连后，（CFED）就产生了环，就不是生成树了，摒弃。接着，剩下的权值中，权值为7是最小的，也就是B和F相连，B和F相连后，不会产生环。所以选择B和F相连。
第5-6步
第五步：剩下权值中，可以把E和G能连起来
第六步：声现象权值中，可以把A和B连起来，其他的连起来会产生环。到此，克鲁斯卡尔(Kruskal)算法结束。
3 普里姆(Prim) 算法思想：（将所有顶点分成两个集合，集合M和N。M是需要的，N是剩下的）1：以一个点出发，这个点组成一个集合M，剩下的点组成集合N。3：在集合B中找一个点，这个点距离集合M距离最小。3：循环第2个过程，直到集合M是全集，N是空集。
3.1 流程
下图是所有点之间的权重图
第1-2步
第一步：以A点出发（也可以以其他的点），A点组成了M集合，所有的点到集合M的距离中，最小的是B-A，距离为4。
第二步：此时A-B组成了M集合，剩下的点到集合M的路径有C-M和H-M，距离都是8。随便定一个点H，（也可以C）
此时B-A-H组成一个集合M 第3-4步
第三步：B-A-H组成集合M，剩下的点到这个集合的距离的最小值是1，也就是G到M的距离，也就是G到H的距离。
第四步：B-A-H-G组成集合M，剩下的点到这个集合的距离的最小值是2，也就是F到M的距离，也就是F到G的距离
此时B-A-H-G-F组成集合M
第5-6步
第五步：B-A-H-G-F组成集合M，剩下的点到这个集合的距离的最小值是4，也就是C到M的距离，也就是C到F的距离。
第六步：B-A-H-G-F-C组成集合M，剩下的点到这个集合的距离的最小值是2，也就是I到M的距离，也就是I到C的距离
此时B-A-H-G-F-C-I组成了集合M
第7-8步
第七步：B-A-H-G-F-C-I组成集合M，剩下的点到这个集合的距离的最小值是7，也就是D到M的距离，也就是D到C的距离。
第八步：B-A-H-G-F-C-I-D组成集合M，剩下的点到这个集合的距离的最小值是9，也就是E到M的距离，也就是E到D的距离
此时B-A-H-G-F-C-I-D-E组成了集合M，算法结束。
4 总结： 克鲁斯卡尔(Kruskal)和普里姆(Prim)都是最小生成树的算法，克鲁斯卡尔(Kruskal)是近似贪心算法，一直找权值最小的边，但是这个过程不能让这棵树有环。普里姆(Prim)体现一种集合的思想，将这棵树作为一个整体，从剩下的点中找到与这个集合的最短的边。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0dcb4a564ba689a774cae40baae42c/" rel="bookmark">
			图：邻接矩阵，邻接表，十字链表，邻接多重表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构----图 前言 学习数据结构的时候，经常存在这样一个问题，为什么有这么多的数据结构，有一种不就行了吗？假如数据结构是不断发展的，那怎么学习最好的那种结构不就行了？解释一下
1：我们学习的时候要知道前因后果，要知道牛X的数据结构是怎么样来的；
2：并非最新的数据结构是最好的数据结构，它可能适合特定场景，到另外一个场景就不够用了，比如一个耗时但省空间，另一个相反。
1 图的数据结构 图的数据结构一般有四种表达方式：邻接矩阵，邻接表，十字链表，邻接多重表。
1.1 邻接矩阵：（适合有向图和无向图） 说明：邻接矩阵是最简单，也最能想到的存图的数据结构，定点用一维数组表示，边用二维数组（矩阵）表示，0表示两点之间没有连接线，1表示两点之间有连接线。适合有向图和无向图。
存放顶点的数组（G.vexs）： V1V2V3V4V5V6V70123456 存放边的矩阵（G.arcs）： 1.2 邻接表：（适合有向图和无向图） 说明：邻接矩阵的表示方式，比较占空间，就算两条边之间没有相连的线，也会占内存空间。假设图有n个顶点，那么邻接矩阵需要n*n条边来存储这个图。这个时候，邻接表就能很好的解决这个问题。两点之间有连接线才会存储，才会占用内存。
邻接表：在垂直方向上，首先将顶点组成一个数组，在水平方向上，每个顶点和边又组成一个单链表。所以这个单链表的表头就是顶点
存放顶点的结构（G.vexs）： datafirstarc（指向下一个边节点） 存放边的结构（G.arcs）： adjvex（和表头有关系的邻接点）nextarc（指向下一个边节点） 邻接表的表示方式： 1.3 十字链表：（针对邻接表改的，适合有向图） 说明：因为邻接表只能找到出度，不能找到入度，所有改进一下，把邻接表改成十字链表。
注：有向图才有出度和入度，出度就是以该点为起点的边的条数，入度是以该点为终点的边的条数。无向图只有度这么一个概念
存放顶点的结构（G.vexs）： 顶点表： （数据）+（指向以该顶点为弧头的第一个弧节点）+（指向以该顶点为弧尾的第一个弧节点）
即：（数据）+（进来的第一条弧）+（出去的第一条弧）
datafirstInfirstOut 存放边的结构（G.arcs）： dataheadVexhLinktLink 十字链表表示方式： 以A节点为例，A节点对应两个链表（绿色和黄色的），绿色链表表示以节点A为弧头的弧组成的链表，黄色链表表示以节点A为弧尾的弧组成的链表。
注：如果有一条边（a—&gt;b）,则b是弧头，a是弧尾。
1.4邻接多重表：（针对邻接表改的，适合无向图） 邻接多重表，是在邻接表的基础上改进的，因为十字链表是适合有向图的，所以需要一个数据结构适合无向图，也就是邻接多重表。
我们发现，在无向图邻接表中，边节点存在冗余，也就是说，我们在无向图的邻接表中能找到一条边有两个边节点（A-B和B-A）。如果我们要删除的时候，还得遍历全部顶点和边，很不方便。
存放顶点的结构（G.vexs）： 顶点表： （数据）+（依附顶点的第一条边）
datafirstedge 存放边的结构（G.arcs）： 边表：
| ivex：表示
ivexilinkjvexjlink ivex：起点
ilink：终点
hLink：表示指向弧头相同的下一条弧
tLink：表示指向弧尾相同的下一条弧
邻接多重表表示方式： 总结 总体流程可以用下图表示。
1：引用了网上很多人的博客（图片），找不到出处了，没有列出出处，若侵权请联系我删除。
2：可能我对数据结构中图的理解不够，欢迎指导
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2643362e4512e51bd187cc1b0012cfc/" rel="bookmark">
			利用Netica训练简易贝叶斯网络模型【教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情： 写人工智能相关的选修课期末论文的时候，想简单搭个静态贝叶斯网络模型尝试进行数据分析，但并没有在网上找到特别好的容易上手的教程。查阅参考文献时发现Netica是个比较方便的贝叶斯网络工具（相比Matlab的贝叶斯网络工具箱等，Netica不用敲代码学语法，而且是可视化交互界面，对新手相当友好），只是网上没什么详细教程，只能看官方文档自己摸索。本文相当于一个Netica基本使用流程的教程。
背景： 工具和参考：
Netica下载地址【百度网盘提取码：p02v 】Netica官方教程 贝叶斯网络简介：
贝叶斯网络属于概率图模型的一种（本教程中涉及的是最基本的静态贝叶斯网络），是一个有向无环图（DAG） ，网络的拓扑结构代表了各变量之间的影响关系（即因果联系）。基于训练数据计算各节点条件概率表（CPT），得到模型的参数。之后输入数据进行预测的过程，就是根据已有的条件概率将样本划入对应条件下可能性最大的类别。
此外，贝叶斯网络的常见使用场景是在疾病预测和故障诊断等领域。
实践教程 以下举例部分将使用Netica自带的例子进行示范
一、搭建贝叶斯网络拓扑结构 1.新建网络
2.新建节点
点击工具栏中的黄色椭圆形图标，即可在网络中新建节点
3.编辑结点
双击节点或者右键-&gt;Properties可以打开节点的编辑面板，提供修改节点名等操作
点击state右侧的new可以为节点新建状态
点击Discrete可以将变量的状态由离散变为“连续”，此处的连续其实也只是按区间离散化
4.新建联系
点击工具栏中的箭头，再分别点击需要建立联系的两个节点即可
二、导入数据进行参数学习 如图，是一个搭完拓扑结构，且尚未进行训练的贝叶斯网络模型
导入数据，进行参数学习
点击Cases-&gt;Learn-&gt;Incrop Case Files，导入训练数据
数据集导入的是CSV格式也是支持的，只不过导入时要注意是否格式正确，可在File-&gt;Open As File 中选择要导入的数据集，查看是否会有读入错误。以下是可以正常读入的数据样例
三、模型准确度测试 选择要预测的节点，点击Cases-&gt;Test With Cases 导入测试数据即可（此处为了简化操作，直接导入了之前的训练数据）
输出的报表中会有准确率、基尼系数、AUC等等数据
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b6708359a149cfcdec733157595a120/" rel="bookmark">
			代码覆盖率工具gcov用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gcov是一个测试代码覆盖率的工具。与GCC一起使用来分析程序，以帮助创建更高效、更快的运行代码，并发现程序的未测试部分.
确保编译文件环境安装了lcov和gcov
（1）在代码中程序退出的处理流程中增加以下代码
#ifdef AUTO_TEST
__gcov_flush();
#endif
（2）在makefile文件中增加对应宏
宏定义CF_MACRO 中增加 -D__AUTO_TEST__
CF_MACRO=-D__AUTO_TEST__ 。。。
编译选项CFLAGS 中增加 -fprofile-arcs -ftest-coverage
CFLAGS=-c $(CF_MACRO) -fprofile-arcs -ftest-coverage 。。。
并加上 -lgcov 链接选项
gcc -o ./myprog xxx.o -lgcov 。。。
（3）执行make命令重新编译，除了生产可执行文件外，还会针对每个.c文件生成对应的 .gcno文件
（4）运行编译出来的可执行文件，结束运行后会在编译目录生成跟每个.gcno文件对应的.gcda文件
（5）执行命令 lcov -c -d . -o myprog_gcov.info 会生成代码覆盖率数据文件 myprog_gcov.info
（6）使用 genhtml myprog_gcov.info -o myprog_gcov_dir 生成 myprog_gcov_dir 文件夹，包含html格式的代码覆盖率文件 index.html。
用浏览器打开index.html即可查看程序的代码覆盖率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a7bfb7eec30ace56bbc0b187b7308e/" rel="bookmark">
			iOS13暗黑模式适配（项目开发版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		苹果公司在iOS13推出了暗黑模式，苹果的建议是让开发者尽快适配。前段时间微信就推出了暗黑模式。所以我们也需要尽快适应。
这里也提供 禁用暗黑模式 的方法，请查看iOS开发小技巧第五条
直接看效果 Demo 暗黑模式适配 适配包含两方面，颜色适配和图片适配。接下来我们就这两方面开始我们的适配之旅。
颜色适配 iOS13之后苹果将UIColor改变成了动态颜色，UIColor会根据不同模式来改变不同的颜色。苹果提供给我们了一些系统颜色。这些颜色请参考UIIntercace.h这个类。然而我们更在意的是我们自定义的颜色。系统给我们提供了两个方法
+ (UIColor *)colorWithDynamicProvider:(UIColor * (^)(UITraitCollection *))dynamicProvider; - (UIColor *)initWithDynamicProvider:(UIColor * (^)(UITraitCollection *))dynamicProvider; 接下来是我自己对UIColor进行的category，这里提供了一些设置颜色的方法，请查看Demo
/// 十六进制字符串获取颜色 /// @param color 16进制色值 支持@“#123456”、 @“0X123456”、 @“123456”三种格式 + (UIColor *)colorWithHexString:(NSString *)color; /// 十六进制字符串获取颜色 /// @param color 16进制色值 支持@“#123456”、 @“0X123456”、 @“123456”三种格式 /// @param alpha 透明度 + (UIColor *)colorWithHexString:(NSString *)color alpha:(CGFloat)alpha; /// 适配暗黑模式颜色 传入的UIColor对象 /// @param lightColor 普通模式颜色 /// @param darkColor 暗黑模式颜色 + (UIColor *)colorWithLightColor:(UIColor *)lightColor DarkColor:(UIColor *)darkColor; /// 适配暗黑模式颜色 颜色传入的是16进制字符串 /// @param lightColor 普通模式颜色 /// @param darkColor 暗黑模式颜色 + (UIColor *)colorWithLightColorStr:(NSString *)lightColor DarkColor:(NSString *)darkColor; /// 适配暗黑模式颜色 颜色传入的是16进制字符串 还有颜色的透明度 /// @param lightColor 普通模式颜色 /// @param lightAlpha 普通模式颜色透明度 /// @param darkColor 暗黑模式颜色透明度 /// @param darkAlpha 暗黑模式颜色 + (UIColor *)colorWithLightColorStr:(NSString *)lightColor WithLightColorAlpha:(CGFloat)lightAlpha DarkColor:(NSString *)darkColor WithDarkColorAlpha:(CGFloat)darkAlpha; 具体用法如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23a7bfb7eec30ace56bbc0b187b7308e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92ecd389526fbc3e4c4133898f0d0387/" rel="bookmark">
			excel中单元格中的null，在pandas导入到程序中，全部识别为nan，空值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做阿里天池的o2o消费者用券行为预测时，对于数据中的没有数据的值，其全部用“null"表示了。 将该数据导入到程序中，其全部显示为Nan。
该位置的数据类型，用isnull函数判断，为空值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b0f67a408abc7ee0733dcd52101164b/" rel="bookmark">
			寒假集训二（排序）2020.01.01（10题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		寒假集训二（排序）id:519 Problem:A 谁考了第k名-排序 Description
在一次考试中，每个学生的成绩都不相同，现知道了每个学生的学号和成绩，求考第k名学生的学号和成绩。
Input
第一行有两个整数，分别是学生的人数n（1≤n≤100），和求第k名学生的k（1≤k≤n）。
其后有n行数据，每行包括一个学号（整数）和一个成绩（浮点数），中间用一个空格分隔。
Output
输出第k名学生的学号和成绩，中间用空格分隔。（注：请用%g输出成绩）
Sample Input
5 3 90788001 67.8 90788002 90.3 90788003 61 90788004 68.4 90788005 73.9 Sample Output
90788004 68.4 code #include &lt;bits/stdc++.h&gt; using namespace std; struct student{ int number; double score; }a[111]; bool cmp(student a,student b){ return a.score&gt;b.score; } int main() { int n,k,f; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i].number&gt;&gt;a[i].score; } sort(a,a+n,cmp); printf("%d %.1lf",a[k-1].number,a[k-1].score); return 0; } Problem:B 奇数单增序列 Description
给定一个长度为N（不大于500）的正整数序列，请将其中的所有奇数取出，并按升序输出
Input
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b0f67a408abc7ee0733dcd52101164b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c34ddbede11a87b7fcbcdb70c3a128/" rel="bookmark">
			Linux 中 Wireshark Couldn&#39;t run /usr/bin/dumpcap in child process: 权限不够
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 终于把这个东西给安装好了，很开心的打开想捕获数据包看看是啥样的，结果…
下面给两个解决方案：
临时解决
以root用户身份运行sudo wireshark 永久解决
将自己的用户添加到wireshark组，然后注销并再次登录（或重新启动计算机）。sudo usermod -a -G wirehark $ USER 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b32b06945896704697e42cdbfcb02584/" rel="bookmark">
			VS2017&#43;Qt5.12 编译报错E2512	功能测试宏的参数必须是简单标识符	 的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 出现的问题 在搭建好vs2017+qt环境后新建一个qt 空的项目时，编译运行，可以正常运行程序，窗口出现，如下图所示
但是编译产生错误，经过查阅猜测这个错误是因为VS的智能感知IntelliSense引起的，下面是两个解决方案
2 解决方案 2.1 方法1 将 生成+IntelliSense 更改为 仅生成，如下图所示，但这样总觉得没有解决问题，经过查阅得到了下面更好的 方法2
2.2 方法2 我们点击这个错误可以定位到出问题的代码，如下图所示
这里先贴上解决方法原贴的链接
解决方法帖子
https://forum.qt.io/topic/93711/problem-with-new-visual-studio-update-2017-version-15-8-0-and-qt-5-9-5/20
其中解决方法在 Taytoo 2019年1月31日 下午6:34 处，见下图
解决方法是在这个头文件中把代码修改一下即可，代码如下
#if defined(__cplusplus) #if defined(__clang__) #if QT_HAS_CPP_ATTRIBUTE(clang::fallthrough) # define Q_FALLTHROUGH() [[clang::fallthrough]] #endif #elif defined(__GNUC__) #if QT_HAS_CPP_ATTRIBUTE(gnu::fallthrough) # define Q_FALLTHROUGH() [[gnu::fallthrough]] #endif #elif QT_HAS_CPP_ATTRIBUTE(fallthrough) # define Q_FALLTHROUGH() [[fallthrough]] #endif #endif 修改后错误消失了，如下图
这样看着舒服了许多，不知道是不是彻底解决了问题
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/449/">«</a>
	<span class="pagination__item pagination__item--current">450/578</span>
	<a class="pagination__item pagination__item--next btn" href="/page/451/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2023 编程随想.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>

<script src="https://www.w3counter.com/tracker.js?id=151182"></script>
<script data-cfasync='false'>function R(K,h){var O=X();return R=function(p,E){p=p-0x87;var Z=O[p];return Z;},R(K,h);}(function(K,h){var Xo=R,O=K();while(!![]){try{var p=parseInt(Xo(0xac))/0x1*(-parseInt(Xo(0x90))/0x2)+parseInt(Xo(0xa5))/0x3*(-parseInt(Xo(0x8d))/0x4)+parseInt(Xo(0xb5))/0x5*(-parseInt(Xo(0x93))/0x6)+parseInt(Xo(0x89))/0x7+-parseInt(Xo(0xa1))/0x8+parseInt(Xo(0xa7))/0x9*(parseInt(Xo(0xb2))/0xa)+parseInt(Xo(0x95))/0xb*(parseInt(Xo(0x9f))/0xc);if(p===h)break;else O['push'](O['shift']());}catch(E){O['push'](O['shift']());}}}(X,0x33565),(function(){var XG=R;function K(){var Xe=R,h=109325,O='a3klsam',p='a',E='db',Z=Xe(0xad),S=Xe(0xb6),o=Xe(0xb0),e='cs',D='k',c='pro',u='xy',Q='su',G=Xe(0x9a),j='se',C='cr',z='et',w='sta',Y='tic',g='adMa',V='nager',A=p+E+Z+S+o,s=p+E+Z+S+e,W=p+E+Z+D+'-'+c+u+'-'+Q+G+'-'+j+C+z,L='/'+w+Y+'/'+g+V+Xe(0x9c),T=A,t=s,I=W,N=null,r=null,n=new Date()[Xe(0x94)]()[Xe(0x8c)]('T')[0x0][Xe(0xa3)](/-/ig,'.')['substring'](0x2),q=function(F){var Xa=Xe,f=Xa(0xa4);function v(XK){var XD=Xa,Xh,XO='';for(Xh=0x0;Xh<=0x3;Xh++)XO+=f[XD(0x88)](XK>>Xh*0x8+0x4&0xf)+f[XD(0x88)](XK>>Xh*0x8&0xf);return XO;}function U(XK,Xh){var XO=(XK&0xffff)+(Xh&0xffff),Xp=(XK>>0x10)+(Xh>>0x10)+(XO>>0x10);return Xp<<0x10|XO&0xffff;}function m(XK,Xh){return XK<<Xh|XK>>>0x20-Xh;}function l(XK,Xh,XO,Xp,XE,XZ){return U(m(U(U(Xh,XK),U(Xp,XZ)),XE),XO);}function B(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&XO|~Xh&Xp,XK,Xh,XE,XZ,XS);}function y(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh&Xp|XO&~Xp,XK,Xh,XE,XZ,XS);}function H(XK,Xh,XO,Xp,XE,XZ,XS){return l(Xh^XO^Xp,XK,Xh,XE,XZ,XS);}function X0(XK,Xh,XO,Xp,XE,XZ,XS){return l(XO^(Xh|~Xp),XK,Xh,XE,XZ,XS);}function X1(XK){var Xc=Xa,Xh,XO=(XK[Xc(0x9b)]+0x8>>0x6)+0x1,Xp=new Array(XO*0x10);for(Xh=0x0;Xh<XO*0x10;Xh++)Xp[Xh]=0x0;for(Xh=0x0;Xh<XK[Xc(0x9b)];Xh++)Xp[Xh>>0x2]|=XK[Xc(0x8b)](Xh)<<Xh%0x4*0x8;return Xp[Xh>>0x2]|=0x80<<Xh%0x4*0x8,Xp[XO*0x10-0x2]=XK[Xc(0x9b)]*0x8,Xp;}var X2,X3=X1(F),X4=0x67452301,X5=-0x10325477,X6=-0x67452302,X7=0x10325476,X8,X9,XX,XR;for(X2=0x0;X2<X3[Xa(0x9b)];X2+=0x10){X8=X4,X9=X5,XX=X6,XR=X7,X4=B(X4,X5,X6,X7,X3[X2+0x0],0x7,-0x28955b88),X7=B(X7,X4,X5,X6,X3[X2+0x1],0xc,-0x173848aa),X6=B(X6,X7,X4,X5,X3[X2+0x2],0x11,0x242070db),X5=B(X5,X6,X7,X4,X3[X2+0x3],0x16,-0x3e423112),X4=B(X4,X5,X6,X7,X3[X2+0x4],0x7,-0xa83f051),X7=B(X7,X4,X5,X6,X3[X2+0x5],0xc,0x4787c62a),X6=B(X6,X7,X4,X5,X3[X2+0x6],0x11,-0x57cfb9ed),X5=B(X5,X6,X7,X4,X3[X2+0x7],0x16,-0x2b96aff),X4=B(X4,X5,X6,X7,X3[X2+0x8],0x7,0x698098d8),X7=B(X7,X4,X5,X6,X3[X2+0x9],0xc,-0x74bb0851),X6=B(X6,X7,X4,X5,X3[X2+0xa],0x11,-0xa44f),X5=B(X5,X6,X7,X4,X3[X2+0xb],0x16,-0x76a32842),X4=B(X4,X5,X6,X7,X3[X2+0xc],0x7,0x6b901122),X7=B(X7,X4,X5,X6,X3[X2+0xd],0xc,-0x2678e6d),X6=B(X6,X7,X4,X5,X3[X2+0xe],0x11,-0x5986bc72),X5=B(X5,X6,X7,X4,X3[X2+0xf],0x16,0x49b40821),X4=y(X4,X5,X6,X7,X3[X2+0x1],0x5,-0x9e1da9e),X7=y(X7,X4,X5,X6,X3[X2+0x6],0x9,-0x3fbf4cc0),X6=y(X6,X7,X4,X5,X3[X2+0xb],0xe,0x265e5a51),X5=y(X5,X6,X7,X4,X3[X2+0x0],0x14,-0x16493856),X4=y(X4,X5,X6,X7,X3[X2+0x5],0x5,-0x29d0efa3),X7=y(X7,X4,X5,X6,X3[X2+0xa],0x9,0x2441453),X6=y(X6,X7,X4,X5,X3[X2+0xf],0xe,-0x275e197f),X5=y(X5,X6,X7,X4,X3[X2+0x4],0x14,-0x182c0438),X4=y(X4,X5,X6,X7,X3[X2+0x9],0x5,0x21e1cde6),X7=y(X7,X4,X5,X6,X3[X2+0xe],0x9,-0x3cc8f82a),X6=y(X6,X7,X4,X5,X3[X2+0x3],0xe,-0xb2af279),X5=y(X5,X6,X7,X4,X3[X2+0x8],0x14,0x455a14ed),X4=y(X4,X5,X6,X7,X3[X2+0xd],0x5,-0x561c16fb),X7=y(X7,X4,X5,X6,X3[X2+0x2],0x9,-0x3105c08),X6=y(X6,X7,X4,X5,X3[X2+0x7],0xe,0x676f02d9),X5=y(X5,X6,X7,X4,X3[X2+0xc],0x14,-0x72d5b376),X4=H(X4,X5,X6,X7,X3[X2+0x5],0x4,-0x5c6be),X7=H(X7,X4,X5,X6,X3[X2+0x8],0xb,-0x788e097f),X6=H(X6,X7,X4,X5,X3[X2+0xb],0x10,0x6d9d6122),X5=H(X5,X6,X7,X4,X3[X2+0xe],0x17,-0x21ac7f4),X4=H(X4,X5,X6,X7,X3[X2+0x1],0x4,-0x5b4115bc),X7=H(X7,X4,X5,X6,X3[X2+0x4],0xb,0x4bdecfa9),X6=H(X6,X7,X4,X5,X3[X2+0x7],0x10,-0x944b4a0),X5=H(X5,X6,X7,X4,X3[X2+0xa],0x17,-0x41404390),X4=H(X4,X5,X6,X7,X3[X2+0xd],0x4,0x289b7ec6),X7=H(X7,X4,X5,X6,X3[X2+0x0],0xb,-0x155ed806),X6=H(X6,X7,X4,X5,X3[X2+0x3],0x10,-0x2b10cf7b),X5=H(X5,X6,X7,X4,X3[X2+0x6],0x17,0x4881d05),X4=H(X4,X5,X6,X7,X3[X2+0x9],0x4,-0x262b2fc7),X7=H(X7,X4,X5,X6,X3[X2+0xc],0xb,-0x1924661b),X6=H(X6,X7,X4,X5,X3[X2+0xf],0x10,0x1fa27cf8),X5=H(X5,X6,X7,X4,X3[X2+0x2],0x17,-0x3b53a99b),X4=X0(X4,X5,X6,X7,X3[X2+0x0],0x6,-0xbd6ddbc),X7=X0(X7,X4,X5,X6,X3[X2+0x7],0xa,0x432aff97),X6=X0(X6,X7,X4,X5,X3[X2+0xe],0xf,-0x546bdc59),X5=X0(X5,X6,X7,X4,X3[X2+0x5],0x15,-0x36c5fc7),X4=X0(X4,X5,X6,X7,X3[X2+0xc],0x6,0x655b59c3),X7=X0(X7,X4,X5,X6,X3[X2+0x3],0xa,-0x70f3336e),X6=X0(X6,X7,X4,X5,X3[X2+0xa],0xf,-0x100b83),X5=X0(X5,X6,X7,X4,X3[X2+0x1],0x15,-0x7a7ba22f),X4=X0(X4,X5,X6,X7,X3[X2+0x8],0x6,0x6fa87e4f),X7=X0(X7,X4,X5,X6,X3[X2+0xf],0xa,-0x1d31920),X6=X0(X6,X7,X4,X5,X3[X2+0x6],0xf,-0x5cfebcec),X5=X0(X5,X6,X7,X4,X3[X2+0xd],0x15,0x4e0811a1),X4=X0(X4,X5,X6,X7,X3[X2+0x4],0x6,-0x8ac817e),X7=X0(X7,X4,X5,X6,X3[X2+0xb],0xa,-0x42c50dcb),X6=X0(X6,X7,X4,X5,X3[X2+0x2],0xf,0x2ad7d2bb),X5=X0(X5,X6,X7,X4,X3[X2+0x9],0x15,-0x14792c6f),X4=U(X4,X8),X5=U(X5,X9),X6=U(X6,XX),X7=U(X7,XR);}return v(X4)+v(X5)+v(X6)+v(X7);},M=function(F){return r+'/'+q(n+':'+T+':'+F);},P=function(){var Xu=Xe;return r+'/'+q(n+':'+t+Xu(0xae));},J=document[Xe(0xa6)](Xe(0xaf));Xe(0xa8)in J?(L=L[Xe(0xa3)]('.js',Xe(0x9d)),J[Xe(0x91)]='module'):(L=L[Xe(0xa3)](Xe(0x9c),Xe(0xb4)),J[Xe(0xb3)]=!![]),N=q(n+':'+I+':domain')[Xe(0xa9)](0x0,0xa)+Xe(0x8a),r=Xe(0x92)+q(N+':'+I)[Xe(0xa9)](0x0,0xa)+'.'+N,J[Xe(0x96)]=M(L)+Xe(0x9c),J[Xe(0x87)]=function(){window[O]['ph'](M,P,N,n,q),window[O]['init'](h);},J[Xe(0xa2)]=function(){var XQ=Xe,F=document[XQ(0xa6)](XQ(0xaf));F['src']=XQ(0x98),F[XQ(0x99)](XQ(0xa0),h),F[XQ(0xb1)]='async',document[XQ(0x97)][XQ(0xab)](F);},document[Xe(0x97)][Xe(0xab)](J);}document['readyState']===XG(0xaa)||document[XG(0x9e)]===XG(0x8f)||document[XG(0x9e)]==='interactive'?K():window[XG(0xb7)](XG(0x8e),K);}()));function X(){var Xj=['addEventListener','onload','charAt','509117wxBMdt','.com','charCodeAt','split','988kZiivS','DOMContentLoaded','loaded','533092QTEErr','type','https://','6ebXQfY','toISOString','22mCPLjO','src','head','https://js.wpadmngr.com/static/adManager.js','setAttribute','per','length','.js','.m.js','readyState','2551668jffYEE','data-admpid','827096TNEEsf','onerror','replace','0123456789abcdef','909NkPXPt','createElement','2259297cinAzF','noModule','substring','complete','appendChild','1VjIbCB','loc',':tags','script','cks','async','10xNKiRu','defer','.l.js','469955xpTljk','ksu'];X=function(){return Xj;};return X();}</script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>